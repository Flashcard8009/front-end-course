WEBVTT

00:00.110 --> 00:02.510
好 我们继续讲解我们的taro

00:02.510 --> 00:04.790
那么这节课给大家讲解一个

00:04.790 --> 00:07.870
我们的一个利用组件开发的一个小案例

00:07.870 --> 00:11.750
叫做计时器 一个时间显示

00:11.750 --> 00:17.030
这个案例主要还是作为对于我们组件的一个引用

00:17.030 --> 00:21.550
和局部操作这样的一个过程

00:21.550 --> 00:24.470
包括是状态 包括是preparatory

00:24.470 --> 00:27.630
包括是我们的一些函数的调用

00:27.630 --> 00:30.270
这里面的话 我们都会设计到一下

00:30.270 --> 00:34.350
然后我们来看 我们现在是一个没有component里面

00:34.350 --> 00:37.350
什么都没有 然后我们只保留一个页面

00:37.350 --> 00:42.350
这个页面相当简单 我们只是做了一个框架

00:42.350 --> 00:44.110
现在我们就可以开始做一下

00:44.110 --> 00:50.310
首先我们去到我们的组件里 生成一个组件出来

00:50.310 --> 00:53.510
那么组件的最简生成方式 我们来看

00:53.550 --> 00:57.430
首先 我们做一个datetime

00:58.710 --> 01:10.660
或者说 我们做一个显示 组件的一个目录

01:10.660 --> 01:13.460
然后在它下面 我们看要不要样式

01:13.460 --> 01:19.090
如果不要样式的话 你就直接写

01:19.090 --> 01:23.280
你直接写一个出来 修谈

01:23.280 --> 01:27.800
等你写完以后 紧接着 我们这里边注意

01:27.800 --> 01:30.840
我们组件里面最简写法

01:30.880 --> 01:37.000
也就意味着 组件里面唯一不能审的那些东西

01:37.000 --> 01:39.040
首先我这边 我没有那个样式

01:39.040 --> 01:40.680
所以我就不写那个了

01:40.680 --> 01:46.390
然后 import 我们写上taro

01:46.390 --> 01:51.750
它需要去完成我们现在的一个类的继承

01:51.750 --> 02:05.540
component from来自于taro.js tarot

02:05.580 --> 02:10.260
如果说你现在 我们依然强调

02:10.260 --> 02:13.340
我们应该可以打上这个 我们就打上

02:13.340 --> 02:15.100
但是如果你不打的话

02:15.100 --> 02:17.980
那么它非一个必选项

02:17.980 --> 02:19.300
就是你在这里面去打

02:19.300 --> 02:22.380
你说老师 我这里边用到了view

02:22.380 --> 02:23.780
你把它拿出来

02:23.780 --> 02:25.300
你说老师 我这边用到了view

02:25.300 --> 02:27.500
能不能不打 我们刚才说了

02:27.500 --> 02:29.740
它是一个非必打项

02:29.740 --> 02:35.580
所以你其实是可以对它进行不打的

02:35.580 --> 02:37.580
component

02:50.800 --> 02:52.880
没有样式 不导入

02:52.880 --> 02:54.360
那么紧接着

02:54.360 --> 02:55.800
它是作为一个组件

02:55.800 --> 02:57.320
组件最后的时候

02:57.320 --> 03:01.960
它会被导入直接完成在我们的页面的

03:01.960 --> 03:03.880
这里进行放置

03:03.880 --> 03:06.840
所以页面会有一个向外接口

03:06.840 --> 03:08.480
那么我们可以去写接口

03:08.480 --> 03:09.800
也可以不写接口

03:09.800 --> 03:16.820
所以我们直接写class

03:16.820 --> 03:19.700
然后直接来 我们做个终

03:19.700 --> 03:22.180
clock

03:22.180 --> 03:23.940
extence

03:23.940 --> 03:27.540
继承component

03:27.540 --> 03:29.380
你先把继承下来

03:29.380 --> 03:30.460
一旦有继承了

03:30.460 --> 03:34.060
那么我们里面就可以去书写我们的

03:34.060 --> 03:39.170
叫做构造函数

03:39.170 --> 03:42.370
构造函数是让它能够在运行期间

03:42.370 --> 03:43.330
直接完成

03:43.330 --> 03:45.490
比如说我们Stated的创建

03:45.490 --> 03:47.930
包括是我们向附类的component

03:47.930 --> 03:49.850
做一些super操作的

03:49.890 --> 03:51.090
都可以写

03:51.090 --> 03:51.850
构造函数

03:51.850 --> 03:53.010
我们的起名

03:53.010 --> 03:55.330
constractor

03:55.330 --> 03:57.690
constractor

03:57.690 --> 03:58.930
purpose

03:58.930 --> 04:01.610
你把你的所有参数都可以传输进来

04:01.610 --> 04:04.730
然后的话给到我们现在的

04:04.730 --> 04:05.570
注意

04:05.570 --> 04:07.410
构造函数有一个要求

04:07.410 --> 04:09.570
一旦你现在有继承

04:09.570 --> 04:11.690
你一旦有继承

04:11.690 --> 04:14.490
你非得有一个构造函数

04:14.490 --> 04:14.930
你说老师

04:14.930 --> 04:16.570
我平时以前写的时候没有

04:16.570 --> 04:17.810
没有没有关系

04:17.810 --> 04:19.410
但是你现在需要的话

04:19.410 --> 04:21.930
你一定要去打上super

04:21.930 --> 04:24.090
这个词

04:24.090 --> 04:26.770
我们就把你传进来参数直接给它

04:26.770 --> 04:27.850
那么这里面还能打

04:27.850 --> 04:29.370
我们现在先待会

04:29.370 --> 04:32.130
把构造函数的结构写好

04:32.130 --> 04:32.850
紧接着

04:32.850 --> 04:34.290
component的继承以后

04:34.290 --> 04:37.250
一定会需要一个render

04:37.250 --> 04:40.770
它需要一个render的函数

04:40.770 --> 04:42.410
进行数据返回

04:42.410 --> 04:45.210
就是jsX的一个结构

04:45.210 --> 04:45.890
扩号

04:45.890 --> 04:48.770
代表里面是我们要的数据

04:48.770 --> 04:53.210
那么我们就给出我们的一个结构题

04:54.490 --> 04:55.850
view

04:55.850 --> 04:57.210
里面放上内容

04:57.210 --> 04:58.410
我们放两行

04:58.410 --> 04:59.530
那么此时呢

04:59.530 --> 05:00.610
我们其实在这儿

05:00.610 --> 05:03.610
你就可以给出txtr

05:03.610 --> 05:09.730
那我就把txtr写在这里面

05:09.730 --> 05:13.700
写上

05:13.700 --> 05:16.640
terror

05:16.640 --> 05:18.800
学习

05:18.800 --> 05:24.520
第二个继续

05:24.520 --> 05:26.080
我们写上

05:26.120 --> 05:33.280
现在的时间是

05:33.280 --> 05:34.080
然后呢

05:34.080 --> 05:38.280
我们直接给出一个terror表达是

05:38.280 --> 05:41.840
我们去从stater里面去取值

05:41.840 --> 05:44.760
从状态里面取值

05:44.760 --> 05:45.840
stater

05:45.840 --> 05:46.880
我们还没有定义

05:46.880 --> 05:47.640
没有关系

05:47.640 --> 05:49.240
先把它写出来

05:49.240 --> 05:51.080
我们定一个data出来

05:51.080 --> 05:53.120
然后按照data的格式

05:53.120 --> 06:00.910
我们可以给一个time stream

06:00.910 --> 06:05.190
日期的一个local本地格式化

06:05.190 --> 06:06.150
那么这样的话

06:06.150 --> 06:07.110
我们就完成了

06:07.110 --> 06:09.750
最后输出时候的一个格式

06:09.750 --> 06:13.390
然后我们去定义这个stater

06:13.390 --> 06:16.310
那么如果说你现在有构造函数的话

06:16.310 --> 06:19.030
我们一般stater都会定义在构造里面

06:19.030 --> 06:23.410
作为它的初始时

06:23.410 --> 06:24.490
stater

06:24.490 --> 06:27.560
等于

06:27.560 --> 06:28.480
我们写上

06:28.480 --> 06:29.560
这个data

06:29.560 --> 06:31.760
它的值是什么呢

06:31.760 --> 06:33.760
我们就拿当前现在时间

06:33.760 --> 06:37.680
当前时间应该是由data来完成这个输出的

06:37.680 --> 06:38.480
对吧

06:38.480 --> 06:40.200
是这样的一个结构

06:40.200 --> 06:42.480
是这样的一个结构

06:42.480 --> 06:43.280
那么这样的话

06:43.280 --> 06:45.640
我们就可以现在来看一下

06:45.640 --> 06:49.080
它现在的这个输出会是什么样的情况

06:49.080 --> 06:54.200
我们现在回到我们的使用页

06:54.200 --> 06:56.360
使用页需要进行导入

06:56.360 --> 06:57.720
导入的方式

06:57.720 --> 07:00.320
找到我们现在的

07:00.320 --> 07:02.200
input最高

07:02.200 --> 07:03.320
然后完成

07:03.320 --> 07:04.600
我们现在写的是

07:05.800 --> 07:07.440
show data

07:07.440 --> 07:12.200
show clock

07:12.200 --> 07:13.440
show clock

07:13.440 --> 07:15.200
我们做一个这个操作

07:15.200 --> 07:16.000
然后

07:16.000 --> 07:19.710
from

07:19.710 --> 07:21.310
show clock from

07:21.310 --> 07:23.910
这边写上的是点点杠

07:23.910 --> 07:24.830
点点杠

07:24.830 --> 07:27.150
找到component下面的修态

07:28.230 --> 07:29.790
显示一个时间出来

07:29.790 --> 07:33.070
当然这个时间是一个中期时间

07:33.070 --> 07:35.630
然后把它写到我们的

07:36.590 --> 07:40.350
显示位

07:40.350 --> 07:40.710
好

07:40.710 --> 07:44.910
可以看一下界面

07:44.910 --> 07:45.630
对吧

07:45.630 --> 07:48.430
现在时间是这样的一个时间

07:48.430 --> 07:50.150
这是一个瞬间时

07:50.150 --> 07:51.190
也就是说

07:51.190 --> 07:52.870
在它显示那一刻

07:52.870 --> 07:55.790
它帮我读取到的一个new data

07:55.790 --> 07:57.150
这样一个格式

07:57.150 --> 08:00.630
那么它的一个显示格式由它来布置

08:00.630 --> 08:02.710
to local transfer

08:03.830 --> 08:05.150
这个local transfer

08:05.150 --> 08:07.230
它并不是一个固定的

08:08.150 --> 08:09.390
你如果在美国

08:09.430 --> 08:11.110
你如果在欧洲的任何国家

08:11.110 --> 08:12.390
那么当地的一个

08:12.390 --> 08:14.630
也就是你现在的计算机

08:14.630 --> 08:17.150
你现在的系统所设置时间格式

08:17.150 --> 08:18.390
这样的一个情况

08:18.390 --> 08:18.750
好了

08:18.750 --> 08:19.750
我们继续往下

08:20.590 --> 08:23.510
我们现在已经把这个内容给呈现出来了

08:23.510 --> 08:23.990
那么

08:23.990 --> 08:25.710
但是它现在没法动

08:25.710 --> 08:26.430
对吧

08:26.430 --> 08:28.310
那么这边额外说一下

08:28.310 --> 08:30.270
那么我们可以传指进来

08:30.270 --> 08:33.710
我们在这边也可以进行额外的一些操作

08:33.710 --> 08:34.430
我们说

08:34.430 --> 08:37.550
我们希望它能够有一些的更新的话

08:37.550 --> 08:39.230
那么应该在哪里做呢

08:39.270 --> 08:43.550
我们就应该单独的去单独写一个地方

08:44.270 --> 08:45.990
应该是什么样的一个情况

08:45.990 --> 08:46.830
我们说

08:46.830 --> 08:51.590
当你加载了当前这样的一个显示时钟的组件的时候

08:51.590 --> 08:55.590
它就应该能够完成它自行的一个操作

08:55.590 --> 08:59.870
而并非是我人需要去点击或者某一个动作

08:59.870 --> 09:01.310
而自行操作

09:01.310 --> 09:04.230
那就一味需要我们用到的是什么

09:04.230 --> 09:05.070
想想看

09:05.070 --> 09:07.230
有一些什么样的事情

09:07.310 --> 09:09.990
需要可以在一些特定时间操作

09:09.990 --> 09:11.470
一进来就操作的

09:11.830 --> 09:13.830
那就是生命周期的钩子函数

09:13.830 --> 09:14.710
对不对

09:14.710 --> 09:19.030
在我们的整个的组件里面

09:23.390 --> 09:24.990
在我们所有的组件里面

09:24.990 --> 09:28.110
生命周期钩子函数本身就拥有一定的

09:28.110 --> 09:30.230
我们现在的一个特权

09:30.230 --> 09:32.270
它有在各个时间点上

09:32.270 --> 09:36.070
能够以特定的方式运行的一种结构

09:36.070 --> 09:37.390
我们首先看到的是

09:37.390 --> 09:38.830
我们这边写的是

09:39.430 --> 09:39.950
写一个

09:39.950 --> 09:41.430
component

09:41.430 --> 09:42.590
你想想看

09:42.590 --> 09:44.790
刚进来应该在哪个上面

09:44.790 --> 09:46.710
我们强调过一点

09:46.710 --> 09:48.110
我们进来以后

09:48.110 --> 09:48.750
有两个

09:48.750 --> 09:50.270
一个是well mount

09:50.270 --> 09:51.870
一个是diddermount

09:51.870 --> 09:52.590
对不对

09:52.590 --> 09:53.590
有两个

09:53.590 --> 09:55.950
我们说过这两个都会执行一次

09:55.950 --> 09:57.270
但是well mount的时候

09:57.270 --> 10:00.150
它其实还没有去完成页面的渲染

10:00.150 --> 10:02.230
所以它不能去和页面交互

10:02.230 --> 10:03.550
只有diddermount可以

10:04.470 --> 10:06.190
所以你应该选择diddermount

10:07.310 --> 10:08.310
这是第一个

10:08.310 --> 10:09.310
我们称之为

10:12.920 --> 10:24.170
刚挂在完后的操作

10:24.890 --> 10:25.690
出发

10:27.520 --> 10:28.920
然后对于组件来讲

10:28.920 --> 10:32.000
我们其实运行的时候没有问题

10:32.000 --> 10:35.080
但是我们更希望能够做得更完善一点

10:35.080 --> 10:36.000
什么意思

10:36.000 --> 10:37.160
就是用的时候

10:37.160 --> 10:39.520
用不用的时候就不要它

10:39.520 --> 10:41.000
所以我们应该也有一个

10:41.000 --> 10:42.880
称之为卸载的功能

10:42.880 --> 10:44.600
我们每当程序

10:44.600 --> 10:48.600
在我们所移除掉我们当前的clock的时候

10:48.640 --> 10:50.640
我们都应该要清除

10:50.640 --> 10:52.520
当前的这样的一个功能

10:52.520 --> 10:53.320
那么这呢

10:53.320 --> 10:54.320
坐在哪里呢

10:54.320 --> 10:58.080
咱们坐在另外一个钩子函数里面

10:58.520 --> 10:59.960
我们应该移除掉它

11:01.240 --> 11:02.040
注意

11:02.040 --> 11:05.920
程序本身并非是你关闭

11:05.920 --> 11:07.320
它就关闭

11:07.320 --> 11:09.320
你需要人为地告知它

11:09.320 --> 11:10.760
我现在已经关闭了

11:10.760 --> 11:12.760
然后它可以去做后期处理

11:13.520 --> 11:16.600
所以我们应该做的是component

11:16.600 --> 11:17.880
有个什么呢

11:17.880 --> 11:19.480
我们在关闭

11:19.480 --> 11:20.560
注意关闭

11:20.560 --> 11:22.040
也就是我们称之为卸载

11:22.040 --> 11:24.440
应该有一个amount

11:24.440 --> 11:27.500
在这个上面

11:27.500 --> 11:28.860
在这个上面

11:28.860 --> 11:31.500
好

11:31.500 --> 11:32.500
我们来看

11:32.500 --> 11:44.620
这个叫做在卸载前的触发

11:44.620 --> 11:46.580
在卸载前的触发

11:46.580 --> 11:48.620
我们把这两个点都放好

11:48.620 --> 11:51.100
这两个点本身就可以帮助我们来实现

11:51.100 --> 11:55.620
现在的一个运行功能

11:55.620 --> 11:56.500
和卸载功能

11:56.500 --> 11:57.660
运行功能在这边写

11:57.660 --> 11:59.020
我们来看一下

11:59.020 --> 12:01.940
它应该是做一个什么

12:01.940 --> 12:05.760
set interval

12:05.760 --> 12:07.960
set interval

12:07.960 --> 12:13.700
set interval

12:13.700 --> 12:15.260
结构应该大家很简单吧

12:16.780 --> 12:19.260
它里面应该去执行一个方法

12:19.260 --> 12:19.900
是吧

12:19.900 --> 12:21.060
然后斗号

12:21.060 --> 12:22.260
每过1000

12:22.260 --> 12:25.020
也就是一秒钟去完成这个事情

12:25.020 --> 12:26.940
那这个方法是什么呢

12:26.940 --> 12:28.620
这个方法就是

12:28.620 --> 12:30.980
每隔一个时间

12:30.980 --> 12:34.180
去更新一下我们当前的data

12:34.180 --> 12:35.340
每隔一段时间

12:35.340 --> 12:36.420
你可以更新

12:36.420 --> 12:38.020
就是第一步操作

12:38.020 --> 12:39.140
同时

12:39.140 --> 12:40.740
它也能做的是什么

12:40.740 --> 12:42.100
它也能做到的是

12:42.100 --> 12:44.820
我们现在的一个方法

12:44.820 --> 12:48.900
我们可以把它定成一个方法来执行

12:48.900 --> 12:50.860
这个应该想相对而言

12:50.860 --> 12:52.460
比较合理一点

12:52.460 --> 12:53.340
记住

12:53.340 --> 12:55.700
我们的处理事件方法

12:55.700 --> 12:59.500
是按照你现在的一个

12:59.540 --> 13:01.740
模块事件来表述的

13:01.740 --> 13:02.580
也就是说

13:02.580 --> 13:03.740
这个事情

13:03.740 --> 13:06.060
你应该让它完整的一个事情

13:06.060 --> 13:08.300
有一个方法来处理

13:08.300 --> 13:09.380
我们称之为

13:09.380 --> 13:09.940
tick

13:09.940 --> 13:12.660
你自己写一个

13:12.660 --> 13:14.420
咱们把它标注为叫什么

13:14.420 --> 13:14.820
这是

13:16.260 --> 13:25.660
时间的重新设定

13:25.660 --> 13:30.270
时间的重新设定

13:30.270 --> 13:33.110
那么这边我们做的是

13:33.110 --> 13:33.910
修改

13:33.910 --> 13:42.960
data

13:42.960 --> 13:43.680
冒号

13:43.680 --> 13:48.140
new date

13:48.140 --> 13:52.420
把时间重新设定一下

13:52.420 --> 13:54.580
然后我们到下面来

13:54.580 --> 13:57.580
我们把它来进行一次调用

13:57.580 --> 14:03.060
我们放在当前的时间里面

14:03.060 --> 14:06.060
放在我们当前的运行的函数里面

14:06.060 --> 14:08.620
this.tick

14:08.620 --> 14:09.300
调用它

14:09.300 --> 14:12.070
扩好

14:12.070 --> 14:13.470
保存

14:13.470 --> 14:15.870
语法上在这里是没有问题的

14:15.910 --> 14:17.870
然后此时我们来看一下

14:19.550 --> 14:20.270
动了吧

14:22.310 --> 14:23.950
那么这边要注意一下

14:23.950 --> 14:26.510
待会我们一起总结一下

14:26.510 --> 14:28.910
data这个值有什么特点

14:28.910 --> 14:31.150
以及它有什么注意方式

14:31.150 --> 14:32.910
这边我们待会总结一下

14:32.910 --> 14:34.470
现在我们先往下写

14:34.470 --> 14:36.030
咱们继续往下看

14:36.030 --> 14:37.870
这边我已经进行触发了

14:37.870 --> 14:40.390
那么这边我想把这个时钟

14:40.390 --> 14:41.510
就是你现在的话

14:41.510 --> 14:42.430
你随便怎么做

14:42.430 --> 14:44.510
它这个时钟在跑

14:44.510 --> 14:46.310
我怎么样所谓的卸载

14:46.310 --> 14:48.430
或者称之为我们的操作

14:48.430 --> 14:50.230
停止掉它的话

14:50.230 --> 14:51.790
怎么做

14:51.790 --> 14:54.110
停止我们时钟的运行

14:54.110 --> 14:58.390
其实是停止你现在set interval的操作

14:58.390 --> 15:00.670
而你要完成set interval的操作

15:00.670 --> 15:04.030
那你就应该拿到set interval的剧柄

15:04.030 --> 15:05.470
也就是我们称之为的

15:05.470 --> 15:07.270
它有一个指向

15:07.270 --> 15:08.550
你必须由这个指向来

15:08.550 --> 15:09.590
如果是空指向

15:09.590 --> 15:11.190
你根本就不知道谁

15:11.230 --> 15:13.990
所以我们这边是可以有一个

15:15.190 --> 15:21.590
this点

15:21.590 --> 15:22.550
timer ID

15:22.550 --> 15:24.710
我们可以给一个这个出来

15:24.710 --> 15:26.670
好 这里我要说一下了

15:26.670 --> 15:28.390
这里我要说一下

15:28.390 --> 15:30.750
有时候我们会把

15:30.750 --> 15:35.230
直接写在我们的stator状态里面

15:35.230 --> 15:38.550
有时候我们会单独去创建一个

15:38.550 --> 15:40.310
如果是这里边设便量

15:40.310 --> 15:41.550
那问题不大

15:41.550 --> 15:43.990
但有时候我们直接这边写this

15:43.990 --> 15:45.190
this代表什么

15:45.190 --> 15:49.070
this代表的是当前这个类的一个属性

15:49.070 --> 15:51.870
为什么不把它也写到我们的

15:51.870 --> 15:54.790
那个stator状态里面去呢

15:54.790 --> 15:56.670
这里有一点需要说明的

15:56.670 --> 15:59.670
就是我们的stator状态值

15:59.670 --> 16:02.470
它其实是更多的是用于

16:02.470 --> 16:05.510
我们称之为叫视觉输出的

16:05.510 --> 16:06.430
也就是说

16:06.430 --> 16:09.870
你如果想给用户看到的数据

16:09.870 --> 16:13.070
我们把这些数据的变化和定义

16:13.070 --> 16:15.190
都定义在stator里面

16:15.190 --> 16:17.190
然后对它进行变化

16:17.190 --> 16:18.070
那么用户呢

16:18.070 --> 16:20.590
我们通过它的事件形式

16:20.590 --> 16:24.430
能够看到这些数值的一些运行情况

16:24.430 --> 16:25.830
但是有一些的

16:25.830 --> 16:28.630
我们并非要给用户能够看到

16:28.630 --> 16:30.590
就像我现在你看到的

16:30.590 --> 16:33.230
我现在这边有一个叫做timer ID

16:33.230 --> 16:35.870
这个ID的作用不是给用户看

16:35.870 --> 16:38.150
而是给我程序在后期的时候

16:38.150 --> 16:39.550
为了做它关闭

16:39.550 --> 16:41.470
而所需要设定的一个值

16:41.510 --> 16:43.350
所以在这种前提下

16:43.350 --> 16:45.070
我们只需要去设定

16:45.070 --> 16:47.390
这个类的一个属性就可以了

16:47.390 --> 16:50.190
你不需要去往我们stator里面放

16:50.190 --> 16:51.990
所以你这点也要明确

16:51.990 --> 16:56.190
不是所有的变量都要放在stator里的

16:56.190 --> 16:58.950
理解这样的一个区分点

16:58.950 --> 17:00.790
像这个data我得看呢

17:00.790 --> 17:02.150
所以我放进去

17:02.150 --> 17:03.750
你说这个能不能放进去

17:03.750 --> 17:06.110
语法上是可以做的

17:06.110 --> 17:09.350
但是它没有stator语意的概念

17:09.350 --> 17:10.510
你放在里面干嘛呢

17:10.510 --> 17:11.390
你放在外面

17:11.390 --> 17:12.110
我依然能用

17:12.110 --> 17:13.270
只要你带上dats

17:13.270 --> 17:14.710
它就是这个类的属性

17:14.710 --> 17:16.550
我在下面的时候依然

17:16.550 --> 17:18.470
我清除怎么做

17:18.470 --> 17:19.670
clear interval

17:19.670 --> 17:23.070
给它当前的timer ID

17:23.070 --> 17:25.940
这样给

17:25.940 --> 17:27.860
这样的话我就可以清除掉当前的

17:27.860 --> 17:30.220
这个timer ID就取这个作用

17:30.220 --> 17:34.100
我何必放到我们的stator状态值里面去呢

17:34.100 --> 17:34.860
理解吧

17:34.860 --> 17:35.740
这概念

17:35.740 --> 17:36.300
OK

17:36.300 --> 17:37.540
当你这样理解以后的话

17:37.540 --> 17:39.300
我们再来看一下

17:39.300 --> 17:41.460
它是很正常在运行

17:41.460 --> 17:42.780
那么什么时候卸载

17:42.780 --> 17:43.780
我们说关闭啊

17:43.780 --> 17:46.380
或者说它我们手动的去完成这个

17:46.380 --> 17:47.380
都是后期

17:47.380 --> 17:49.060
只要它有卸载动作

17:49.060 --> 17:52.100
它肯定逃不出这个well amount

17:52.100 --> 17:54.180
这样的一个生命周期购字函数

17:54.180 --> 17:56.060
然后它一定会去执行这个操作

17:56.060 --> 17:57.500
而这个timer ID

17:57.500 --> 17:58.700
就一定会获取到

17:58.700 --> 18:01.180
因为它是属性级的

18:01.180 --> 18:01.820
OK吧

18:01.820 --> 18:03.860
那么这个是我们看到的一个

18:03.860 --> 18:05.380
非常简单的案例

18:05.380 --> 18:06.860
这里面反馈出几个点

18:06.860 --> 18:08.100
我们这边捋一下

18:08.100 --> 18:09.380
你说老师这个没有行不行

18:09.380 --> 18:10.340
刚才前面我说了

18:10.340 --> 18:11.220
我把它给删了

18:11.220 --> 18:12.260
然后你现在再来看一下

18:12.260 --> 18:15.240
页面情况

18:15.240 --> 18:17.120
它同样是可以操作的

18:17.120 --> 18:19.000
它同样是可以操作的

18:19.000 --> 18:20.920
这就是我们前面说到的

18:20.920 --> 18:21.880
加与不加

18:21.880 --> 18:24.960
在我们的运行上面没有问题

18:24.960 --> 18:27.960
在与意和你的程序关系上

18:27.960 --> 18:29.760
最好是加的

18:29.760 --> 18:30.200
看一下

18:30.200 --> 18:31.720
刚才我们既然说到Stator了

18:31.720 --> 18:32.880
那我们就把Stator里面

18:32.880 --> 18:35.120
还有几件事给大家来说明一下

18:35.120 --> 18:35.920
第一

18:35.920 --> 18:37.640
Stator这个值得操作

18:37.640 --> 18:41.040
我们如果有同学忘记做这个事情了

18:41.040 --> 18:41.960
我们来看

18:41.960 --> 18:46.520
它直接对变量的复制操作系统是会爆错吗

18:46.520 --> 18:48.120
还是会依然会更新

18:48.120 --> 18:51.440
只不过我们使用了一种减变方法的

18:51.440 --> 18:52.400
我们来看

18:52.400 --> 18:53.480
DistanceData

18:53.480 --> 18:55.960
我们里面拿出这个Data

18:55.960 --> 18:59.540
我们直接这样对它更新

18:59.540 --> 19:00.540
写等号

19:01.740 --> 19:03.380
这个里面

19:03.380 --> 19:04.580
保存

19:04.580 --> 19:06.980
语法上这边还没有爆错

19:06.980 --> 19:08.380
那我们到这边来看

19:09.580 --> 19:10.780
看这边

19:10.780 --> 19:13.220
这边语法上也没有爆错

19:13.220 --> 19:15.460
但是它是不动的

19:15.460 --> 19:16.340
这个Tick

19:16.340 --> 19:17.620
我们没有山碑

19:17.620 --> 19:20.620
我们还是在刚进入我们的组件的时候

19:20.620 --> 19:22.620
生命周期函数触发了这个

19:22.620 --> 19:25.060
并且疫苗以后一定会触发

19:25.060 --> 19:25.660
对吧

19:25.660 --> 19:28.180
那么它怎么会没有被执行呢

19:28.180 --> 19:29.820
这里说明一点

19:29.820 --> 19:33.500
这个代码虽然语法上是成立的

19:33.500 --> 19:37.700
但是它是不会被我们程序所做渲染的

19:37.700 --> 19:38.900
你渲染的概念

19:38.900 --> 19:41.940
就是它会去重新刷新我们现在的页面

19:41.940 --> 19:43.740
改变现在数据的值

19:43.740 --> 19:45.140
它是不会去做的

19:46.140 --> 19:48.300
所以我们一旦发现

19:48.300 --> 19:51.180
你要修改Stator里面值的时候

19:51.180 --> 19:53.100
突然页面中没有变化

19:53.100 --> 19:54.780
你也应该去考虑一下

19:54.780 --> 19:56.340
你的书写的时候是否对

19:56.340 --> 19:57.300
因为你这样写

19:57.300 --> 19:58.700
编译没有问题的

19:58.700 --> 19:59.380
ok

19:59.380 --> 20:00.660
这点需要理解

20:00.660 --> 20:04.460
我们的修改我们状态值的唯一方法

20:04.460 --> 20:06.020
就是StateStator

20:06.860 --> 20:07.940
这是第一点

20:07.940 --> 20:09.660
我们这边註明一下

20:09.660 --> 20:10.860
我们把这个拿走

20:10.860 --> 20:11.660
打开吧

20:12.660 --> 20:21.340
这是属于不抱错的错误方法

20:22.940 --> 20:24.060
我这样去说明

20:24.660 --> 20:25.020
第二

20:25.020 --> 20:25.780
我们再来说一下

20:25.780 --> 20:26.780
这是第一点

20:26.780 --> 20:27.620
第二点

20:28.100 --> 20:29.900
我们所谓的更新

20:29.900 --> 20:32.940
它一定是一种异部操作

20:33.660 --> 20:34.140
注意

20:34.140 --> 20:34.780
第二点

20:34.780 --> 20:36.380
我这边把它空拿掉

20:42.660 --> 20:45.780
更新的异部操作概念

20:47.510 --> 20:49.230
异部操作就意味着

20:49.270 --> 20:51.350
我在前面所做的任何的操作

20:51.350 --> 20:52.910
我直接对它进行

20:52.910 --> 20:55.030
我们现在的一个货值

20:55.030 --> 20:55.950
你去看一下

20:55.950 --> 20:56.870
你是否可以拿到

20:56.870 --> 20:58.270
一般性我们有时候

20:58.270 --> 20:59.750
为了给它复完之以后

20:59.750 --> 21:01.110
下面直接取完以后

21:01.110 --> 21:02.510
该去做后期的逻辑

21:03.230 --> 21:03.710
我们

21:03.710 --> 21:05.670
但是这边能不能去看到

21:05.670 --> 21:06.790
我们来做一下

21:06.790 --> 21:07.630
首先

21:07.630 --> 21:10.190
我们前面对它复了一个值

21:10.190 --> 21:12.350
然后我们重新对它进行一个改变

21:12.350 --> 21:13.470
我们不要问StateStator了

21:13.470 --> 21:15.030
我们单独再来一个

21:17.480 --> 21:18.640
我们再来一个

21:18.640 --> 21:20.120
咱们称之为Number

21:20.120 --> 21:21.000
好吧

21:21.040 --> 21:23.000
Number这里面是给了一个0

21:23.880 --> 21:25.000
这里边给了一个0

21:25.640 --> 21:27.000
然后我们紧接着

21:27.480 --> 21:29.200
我们在同样

21:29.400 --> 21:32.200
Tick每一秒的里面

21:36.100 --> 21:37.420
我们不要做在每一秒

21:37.420 --> 21:38.900
我们单独做一个

21:39.140 --> 21:40.500
因为每一秒的更新的话

21:40.500 --> 21:42.300
它的速度会在下面呈现出来

21:42.300 --> 21:43.500
我们会看不清

21:43.980 --> 21:45.420
我们在

21:46.060 --> 21:48.740
这里边单独写一个按钮

21:55.550 --> 21:56.510
我们单独写一个按钮

21:56.510 --> 21:57.470
我点一下

21:57.470 --> 21:59.230
我修改一下State的值

21:59.230 --> 22:01.230
然后马上看一下这个效果

22:01.630 --> 22:02.670
以这个方式来

22:02.990 --> 22:04.070
这边写了button

22:04.070 --> 22:05.230
应该在哪注册

22:09.330 --> 22:09.930
对吧

22:10.490 --> 22:11.770
你别把所有

22:11.770 --> 22:12.610
你说老师

22:12.610 --> 22:13.850
这个里面注意

22:13.850 --> 22:15.930
我们把它讲得通俗一点的说法

22:15.930 --> 22:16.490
就是

22:16.770 --> 22:18.090
微信的一些标签

22:18.090 --> 22:18.730
你在这注册

22:18.730 --> 22:19.490
你别这么干

22:19.490 --> 22:20.010
你说老师

22:20.010 --> 22:21.450
我也要用一个ULI

22:21.450 --> 22:22.410
你也在这边注册去

22:22.930 --> 22:23.450
这个的话

22:23.450 --> 22:24.450
肯定抱你错

22:25.970 --> 22:26.370
OK

22:26.370 --> 22:27.330
我们继续往下

22:28.130 --> 22:29.650
我们写一按钮

22:29.650 --> 22:30.610
我们按钮上面

22:30.610 --> 22:31.410
我们写上

22:32.050 --> 22:37.370
这是State的改变

22:39.900 --> 22:41.740
然后我们写一个onclick

22:44.900 --> 22:49.020
我们写上当前的Changer

22:49.020 --> 23:01.730
我们写一个改变

23:03.620 --> 23:06.300
State的一个值

23:06.980 --> 23:08.740
改变就是这个number的值

23:08.740 --> 23:09.740
我们来看一下

23:09.940 --> 23:10.940
首先我们说

23:10.940 --> 23:11.940
正常的改变

23:11.940 --> 23:14.380
应该是this点

23:14.500 --> 23:15.900
setState

23:16.860 --> 23:17.260
大

23:17.420 --> 23:18.260
那个什么

23:18.260 --> 23:18.980
小过号

23:18.980 --> 23:19.780
大过号

23:20.300 --> 23:22.300
把你现在这个值往里放

23:22.420 --> 23:24.380
把你这个number往里放

23:24.740 --> 23:25.780
我们本来是0

23:25.780 --> 23:27.260
现在改成100

23:27.860 --> 23:28.660
改完了

23:28.660 --> 23:31.300
然后下面马上打印出来

23:36.770 --> 23:37.650
我们来看一下

23:37.650 --> 23:43.010
当前的State里面的number

23:44.450 --> 23:45.490
我们去这样做

23:47.010 --> 23:47.250
好

23:47.250 --> 23:48.130
我们来看一下

23:51.800 --> 23:52.320
看

23:53.360 --> 23:53.960
0

23:56.520 --> 23:58.160
如果同学没看清的话

23:58.160 --> 23:59.120
我们这边写上

23:59.920 --> 24:03.590
这是ChangerAft

24:05.740 --> 24:05.980
好

24:05.980 --> 24:06.860
我们这样做

24:07.380 --> 24:08.300
前面写一句

24:09.340 --> 24:10.540
这叫ChangerBefore

24:11.660 --> 24:12.980
这样应该看得清了吧

24:13.460 --> 24:15.220
ChangerBefore和ChangerAft

24:15.220 --> 24:18.100
中间做了一个number100的改变

24:18.540 --> 24:20.060
我们运行一下

24:23.630 --> 24:24.230
你看

24:24.790 --> 24:26.270
ChangerBefore是0

24:26.270 --> 24:27.150
我们很正常

24:27.150 --> 24:28.310
ChangerAft也是0

24:28.470 --> 24:29.550
这点就说到了

24:29.550 --> 24:31.550
我们刚才讲到的一个关键点

24:32.190 --> 24:34.670
我们所谓的Status

24:34.670 --> 24:35.670
StatusStatus

24:35.670 --> 24:37.270
它其实是一个异步操作

24:37.270 --> 24:38.190
也就是说

24:38.590 --> 24:41.110
你在执行这条命令的时候

24:41.110 --> 24:42.710
其实它并非

24:42.710 --> 24:45.390
可能还没有做number100

24:45.750 --> 24:47.270
也许它做完以后的话

24:47.270 --> 24:48.470
你已经输出了

24:48.790 --> 24:50.230
你们两擦肩而过

24:50.550 --> 24:52.390
这种时候我们说到

24:52.390 --> 24:53.830
那么你可以怎么样

24:53.830 --> 24:55.910
你说我非得获得这个值

24:56.230 --> 24:57.950
那么这种做法上其实可以的

24:58.750 --> 24:59.910
那么我们怎么做呢

25:00.110 --> 25:00.950
我们其实

25:01.310 --> 25:02.030
StatusStatus

25:02.030 --> 25:03.110
我们经常这么用

25:03.110 --> 25:03.470
对吧

25:03.470 --> 25:04.950
我们打一个小过号

25:04.950 --> 25:06.950
代表这是一个方法里面

25:06.950 --> 25:08.630
给它一个参数是个对象

25:08.910 --> 25:10.670
那么除了这个以外

25:10.670 --> 25:13.790
其实StatusStatus还可以有第二个参数

25:14.070 --> 25:15.710
它是有一个叫做callback

25:15.710 --> 25:16.630
回掉函数的

25:16.630 --> 25:17.510
它可以有一个

25:17.870 --> 25:19.350
在它完成以后

25:19.350 --> 25:20.470
也就是说

25:20.470 --> 25:21.990
它复完100以后

25:21.990 --> 25:23.870
我们再来看这个数值

25:23.870 --> 25:25.950
我们把这个放进来

25:26.990 --> 25:27.950
这样去保存

25:28.230 --> 25:29.470
此时你再来看一下

25:32.890 --> 25:33.690
看到了吗

25:33.930 --> 25:34.730
它改变了

25:37.860 --> 25:39.020
再点下去没关系

25:39.020 --> 25:41.460
因为前面本身已经改变过了

25:41.860 --> 25:42.900
所以我们看到

25:43.420 --> 25:45.660
你需要去获取到

25:45.660 --> 25:49.220
那个我们刚刚改变的Status

25:49.220 --> 25:51.260
状态值的属性的时候

25:51.460 --> 25:53.140
你需要去完成一个

25:53.140 --> 25:54.900
对StatusStatus第二函数

25:54.900 --> 25:56.660
就是我们的callback的操作

25:56.860 --> 25:59.180
它可以帮助你来看到

25:59.300 --> 26:01.380
当前已经完成的数据

26:01.620 --> 26:05.380
但是如果你直接把你的语句

26:05.420 --> 26:07.340
写在Status语句之后

26:07.540 --> 26:10.340
那么由于Status是一个易不操作

26:10.340 --> 26:11.900
所以它不会执行

26:12.340 --> 26:14.740
那么这里我们要说明一下的是

26:14.900 --> 26:16.340
包括我们大家

26:16.340 --> 26:19.140
而如果你去运寻我们的purpose

26:19.140 --> 26:21.100
就是我们称之为的属性的时候

26:21.260 --> 26:22.900
它也是一个易不操作

26:23.220 --> 26:25.500
所以这种在组件里面

26:25.500 --> 26:27.220
无论是状态的改变

26:27.220 --> 26:28.740
还是属性的操作

26:28.900 --> 26:30.780
你都需要去控制好

26:30.780 --> 26:32.980
你的易不操作的一个获取值的方式

26:33.140 --> 26:33.940
不然的话

26:33.940 --> 26:35.140
你很容易发生

26:35.260 --> 26:36.660
一个非常大的错误

26:36.940 --> 26:38.420
那么这一点上面

26:38.420 --> 26:39.380
我们注意一下

26:39.380 --> 26:40.660
这一点上面

26:40.860 --> 26:42.500
特别是在属性这些上面

26:42.500 --> 26:45.420
我们如果以前用过react的同学的话

26:47.220 --> 26:48.460
会觉得老师

26:48.460 --> 26:49.780
我以前reactor时候的话

26:49.780 --> 26:51.740
有时候也能得到值

26:51.940 --> 26:53.740
这就是telor跟reactor的最大的一个

26:53.740 --> 26:54.140
第二个

26:54.140 --> 26:54.780
不是第二个

26:54.780 --> 26:55.700
就是又一个区别

26:55.820 --> 26:57.420
应该前面好有好多区别

26:58.340 --> 26:59.820
telor和reactor之间

26:59.980 --> 27:01.540
不同的地方在这里有一个

27:01.540 --> 27:04.180
就是reactor中的StatusStatus

27:04.180 --> 27:05.940
它不一定总是易不的

27:05.940 --> 27:07.020
这点你需要知道

27:07.380 --> 27:08.540
这边我们写一下

27:10.400 --> 27:11.720
我们就写这边吧

27:13.240 --> 27:13.800
就是

27:15.440 --> 27:21.500
telor和reactor又一不同点

27:24.330 --> 27:34.020
那就是reactor的StatusStatus

27:37.820 --> 27:40.300
不一定总是易不

27:42.860 --> 27:44.860
那么它内部是有一套

27:44.860 --> 27:47.340
数机制控制着在reactor里面

27:47.900 --> 27:50.220
同时reactor根据不同的版本

27:50.220 --> 27:52.180
它的处理方式也是不一样

27:52.180 --> 27:54.060
所以我们根据不同的版本

27:54.060 --> 27:56.660
会去看一下它是否是易不操作

27:57.060 --> 27:58.060
是这个逻辑的

27:58.340 --> 28:00.140
而telor我们说一下

28:00.140 --> 28:03.100
telor它是指的是这个Status

28:03.100 --> 28:05.060
它一定是一个易不操作

28:05.380 --> 28:06.140
为什么

28:07.220 --> 28:08.860
telor的运行机制不一样

28:11.260 --> 28:13.300
它是用了reactor的语法

28:13.420 --> 28:15.980
但不是说它的运行机制是reactor

28:16.500 --> 28:17.980
telor是会合并

28:17.980 --> 28:18.980
你记住这个词

28:20.180 --> 28:21.260
你只要记住

28:21.260 --> 28:22.460
合并Status

28:25.480 --> 28:26.960
telor的所有的Status

28:26.960 --> 28:27.680
你页面中

28:27.680 --> 28:31.080
如果你有在同一个程序执行过程中

28:31.840 --> 28:34.280
你有两个Status的改变的话

28:34.280 --> 28:38.160
那么它会去合并掉Status以后才来执行

28:38.640 --> 28:40.040
你注意一下这点

28:40.200 --> 28:42.760
而并非是看到一个执行一个

28:43.480 --> 28:44.520
这点你要理解

28:44.800 --> 28:46.840
你比如说我们举一个势力

28:47.680 --> 28:48.840
我们把它拿出来

28:50.950 --> 28:53.110
我们虽然这个方法

28:53.270 --> 28:54.670
这是伟大马的结构

28:55.070 --> 28:58.550
但是我们把它来说明这样的一个事情

29:02.260 --> 29:05.100
比如说我这边再有一个辩量

29:07.200 --> 29:08.400
咱们里面写上

29:12.220 --> 29:12.620
念

29:23.550 --> 29:25.830
我们把这个纸写到我们的

29:26.870 --> 29:27.270
这样

29:35.060 --> 29:36.060
我去这样写

29:36.420 --> 29:37.100
那你注意

29:37.220 --> 29:38.900
我们写个伪结构出来

29:39.900 --> 29:40.740
然后注意一下

29:40.980 --> 29:43.020
你现在当然这个肯定是得不到

29:43.020 --> 29:43.580
对吧

29:43.980 --> 29:46.300
你现在它的运行机制是这样的

29:46.900 --> 29:48.580
它看到这边有个Status

29:49.700 --> 29:51.260
它不会马上运行

29:51.740 --> 29:52.980
它会去看下面

29:52.980 --> 29:54.460
看到这一句话输出

29:54.460 --> 29:55.340
那你先输出吧

29:55.340 --> 29:55.780
它说

29:56.140 --> 29:57.260
然后它再往下看

29:57.260 --> 29:58.780
有没有另外一句Status

29:58.900 --> 29:59.780
这句也有

30:00.020 --> 30:02.660
所以它看到在你整个执行代码期间

30:02.660 --> 30:03.740
你有两个Status

30:03.740 --> 30:06.540
它到这一句之后才来执行

30:06.540 --> 30:10.660
你现在的所谓的我们的一个更新

30:10.660 --> 30:13.460
所以它两个语句都一起更新

30:14.580 --> 30:15.620
知道这个逻辑

30:15.980 --> 30:19.020
那么你如果把它写在这个Callback里面

30:19.020 --> 30:20.540
那么它会去观察

30:20.540 --> 30:22.780
这个Number是否已经更新

30:22.780 --> 30:23.780
已经更新了

30:23.780 --> 30:25.020
它才会还给你

30:25.260 --> 30:27.020
如果说你没有更新

30:27.020 --> 30:29.260
它是不会执行我们Callback语句的

30:29.580 --> 30:31.580
那么你可以在两个Status里面

30:31.580 --> 30:34.340
分别单独定义两个我们Status

30:34.340 --> 30:35.340
这样的话

30:35.340 --> 30:37.860
我们就可以很容易的能够在

30:37.860 --> 30:40.740
它们两个虽然共同更新的点上

30:40.860 --> 30:43.460
去返回两个不同的回来函数

30:44.660 --> 30:45.820
理解这个逻辑

30:45.820 --> 30:47.740
所以这点我们要说明的是

30:47.740 --> 30:50.420
Status的更新它会被合并的

30:50.420 --> 30:53.500
所以从这个角度我们不能去

30:53.500 --> 30:54.380
就是说是

30:56.880 --> 30:59.600
你不能去说是我就会放在外面执行

30:59.840 --> 31:00.560
那么有同学说

31:00.560 --> 31:01.240
老师

31:01.240 --> 31:02.800
如果它是合并的话

31:02.800 --> 31:04.000
我能不能这么做

31:04.000 --> 31:05.920
我见过一个同学这么干

31:05.920 --> 31:06.920
它是说

31:06.920 --> 31:08.080
你说这两个合并

31:08.080 --> 31:10.600
那我就把获取Number这个值的方式

31:10.600 --> 31:11.960
在这里面去得到

31:14.200 --> 31:15.560
它不是一起做的吗

31:15.560 --> 31:16.560
你来看一下

31:18.890 --> 31:20.170
你觉得这样行吗

31:22.660 --> 31:23.860
你觉得这样行吗

31:24.460 --> 31:25.180
这个Number

31:25.780 --> 31:26.420
我们来看吧

31:26.420 --> 31:27.260
你看一下吧

31:32.280 --> 31:34.040
你要怀疑如果是缓存的话

31:34.040 --> 31:36.200
我们给它做一个简单修改

31:36.200 --> 31:37.840
比如说这后面都加个E

31:41.400 --> 31:42.240
都加个E

31:46.910 --> 31:48.070
你看是不是改变了

31:48.470 --> 31:50.150
那么这边我要说明一下

31:50.870 --> 31:53.230
这个写法上面不是说

31:53.230 --> 31:54.910
你在这里面能拿它

31:54.910 --> 31:56.590
而是你这两个都做完了

31:56.590 --> 31:57.870
都做完以后的话

31:57.870 --> 31:59.470
你再去通过这个

31:59.470 --> 32:00.830
不是拿这个的改变

32:00.830 --> 32:02.710
而是你拿上面State的值

32:03.270 --> 32:04.110
是这个意思

32:04.710 --> 32:05.750
所以我们讲

32:05.750 --> 32:07.990
一般信我们这种语法

32:07.990 --> 32:09.350
本身不会太出现

32:09.350 --> 32:11.070
但是如果你在长语矩

32:11.070 --> 32:12.870
长命令上面过程中

32:12.870 --> 32:14.590
有可能在不同的位置上面

32:14.590 --> 32:16.790
形成了不一样对State的更新

32:17.030 --> 32:19.070
那么只要你现在

32:19.070 --> 32:21.150
完成了整个这个操作以后

32:21.150 --> 32:23.150
它都会来得到这样的一个值

32:23.710 --> 32:24.350
那么有同学说

32:24.350 --> 32:25.030
那老师

32:25.030 --> 32:27.030
我在执行这个命令之前

32:27.030 --> 32:29.470
去完成Mand的获取

32:30.230 --> 32:31.630
Nand的获取

32:31.630 --> 32:32.430
可不可以

32:38.890 --> 32:39.090
好

32:39.090 --> 32:39.850
你来看一下

32:40.170 --> 32:42.370
首先这是Marry上面是什么

32:42.370 --> 32:43.810
上面是Hello对吧

32:44.810 --> 32:45.450
点掉

32:46.890 --> 32:47.490
Marry

32:47.850 --> 32:48.330
对吧

32:48.970 --> 32:49.410
好

32:49.690 --> 32:50.650
明确这一点

32:51.050 --> 32:52.770
我们不存在于

32:52.770 --> 32:54.330
这行做完先显示

32:54.330 --> 32:56.330
因为这两行合并起来以后

32:56.330 --> 32:57.250
一起做完

32:57.250 --> 32:58.730
所以你现在写这儿

32:58.730 --> 32:59.650
和写下面

32:59.810 --> 33:00.930
是没区别的

33:02.290 --> 33:03.330
OK 理解了吧

33:04.010 --> 33:05.690
当然这种情况本身来讲

33:05.690 --> 33:06.850
不会特别多

33:06.850 --> 33:08.490
那么你在前面更新以后

33:08.490 --> 33:10.250
后面再有一个更新

33:10.250 --> 33:12.770
当然不是我像我说的这种多

33:12.930 --> 33:13.610
就是直接

33:13.610 --> 33:15.250
这因为这是一个特殊的

33:15.250 --> 33:16.330
失利的代言是

33:16.450 --> 33:18.330
但是在现实生活中的确存在着

33:18.330 --> 33:19.810
我们这里边有寒树里面

33:19.810 --> 33:20.410
还有嵌套

33:20.410 --> 33:21.930
可能这里边还会有一些

33:21.930 --> 33:23.090
上有一层更新

33:23.090 --> 33:24.210
下一层更新

33:24.210 --> 33:26.530
那么我们系统的运行是合并操作

33:26.530 --> 33:27.610
但是我们获取的时候

33:27.610 --> 33:28.610
用回掉获取

33:28.730 --> 33:31.330
OK 这是这边所看到的一个失利

33:33.010 --> 33:34.450
那么这个案例

33:34.450 --> 33:35.730
我们就先讲到这里了

33:35.730 --> 33:36.810
因为本身来讲

33:36.810 --> 33:39.970
它的组件的使用对我们来讲

33:39.970 --> 33:42.010
现在应该不是一个陌生东西

33:42.010 --> 33:44.090
只是我在强调的是

33:44.090 --> 33:46.090
1 这里边的一些坑

33:46.090 --> 33:48.810
2 它里面的一些内部处理方式

33:48.810 --> 33:50.290
和你操作方式

33:50.290 --> 33:51.730
这些上面的东西

33:51.730 --> 33:53.570
OK 那么解决课就先讲

