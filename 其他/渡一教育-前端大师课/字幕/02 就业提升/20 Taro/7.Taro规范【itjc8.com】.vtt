WEBVTT

00:00.000 --> 00:02.500
好 我们去讲解TALO系列课程

00:02.500 --> 00:08.700
那么在之前我们已经做了一些对它的文件 框架

00:08.700 --> 00:12.300
整个里面包括是编写结构的一些认识

00:12.300 --> 00:16.700
那么这里我们需要给大家回到我们的愚法点上来

00:16.700 --> 00:20.000
讲一下TALO在编写上面的一些规范操作

00:21.000 --> 00:25.600
TALO本身的编写 它的书写过是有一些的规范要求

00:25.600 --> 00:29.800
这些要求包括一些 包括是位置 命名 后坠

00:30.800 --> 00:34.800
那么具体的话 我们来参考我们的一个TALO的规范要求

00:35.300 --> 00:36.300
我们来看一下

00:38.620 --> 00:41.120
TALO在规范上面的话 它有几点要求

00:41.120 --> 00:45.620
首先第一点 你所有的代码都必须放在SRC的文件加下面

00:45.620 --> 00:48.620
我们说OK 我们都是属于原码文件

00:49.120 --> 00:52.120
那么项目中有基本的两个文件

00:52.120 --> 00:54.620
我们称之为入口文件和页面文件

00:54.620 --> 00:57.620
我们从代码里面我们其实也能看到了

00:57.620 --> 01:00.620
对吧 我们把这个都关一下

01:00.620 --> 01:08.780
我们从代码里 其实我们也能看到入口文件

01:09.780 --> 01:12.780
对吧 我们的app.jsx

01:12.780 --> 01:16.780
然后我们的代码文件全是在我们的

01:16.780 --> 01:19.780
这里面 就是页面文件 对吧 我们的Peters里面

01:19.780 --> 01:21.780
紧接着 我们继续来看

01:22.780 --> 01:25.780
它所要求的是 我们的入口文件

01:25.780 --> 01:27.780
它叫js 对吧 其实我们是x结构

01:27.780 --> 01:31.780
然后文件页面 我们都放在我们的Peters

01:31.780 --> 01:33.780
为什么有这种要求呢

01:33.780 --> 01:35.780
因为它在最后编译的时候

01:35.780 --> 01:39.780
它会按照文件的路径和文件所存储的位置

01:39.780 --> 01:42.780
来形成不同的文件位置的放置

01:42.780 --> 01:45.780
比如说 我们所谓的configure对吧

01:45.780 --> 01:47.780
它会编成我们的一个js文件

01:47.780 --> 01:49.780
它会按照位置来进行区分

01:49.780 --> 01:52.780
那么这边我们就快速去过一下

01:52.780 --> 01:54.780
文件名主要的 它说的是

01:54.780 --> 01:58.780
你在里面用普通的文件名以小写命名方式

01:58.780 --> 02:02.780
多单词的话 我们下面可以用下滑线来描述

02:02.780 --> 02:05.780
那么注意一下 这个它不是说是必定项

02:05.780 --> 02:08.780
你不用下滑线 或者你连起来会暴躁

02:08.780 --> 02:12.780
那么它的建议就是用这样的方式去写你的文件名

02:12.780 --> 02:14.780
单文件名就没有关系

02:14.780 --> 02:17.780
如果你现在是注意组建命名的话

02:17.780 --> 02:19.780
那么在后面我们会讲到组建

02:19.780 --> 02:21.780
组建命名的话用pasker

02:21.780 --> 02:24.780
也就是我们所谓的以大写字母

02:24.780 --> 02:26.780
主要pasker的命名法的话

02:26.780 --> 02:28.780
都是手字母大写

02:28.780 --> 02:32.780
脱封命名法的话 手字母小写 后面都大写

02:32.780 --> 02:34.780
这样的 文件后坠

02:34.780 --> 02:36.780
文件后坠的话一般我们都是

02:36.780 --> 02:38.780
如果我用的是jsX

02:38.780 --> 02:40.780
或者用ts的话也是可以

02:40.780 --> 02:42.780
这个是我们系统生成的

02:42.780 --> 02:45.780
组建的话我们都是jsX

02:45.780 --> 02:47.780
这样的结构来进行操作

02:47.780 --> 02:50.780
然后书写的js规范我们这边来看一下

02:50.780 --> 02:54.780
基本规范的话 首先我们的缩进用两格

02:54.780 --> 02:59.780
那么这个的话在我们的VSCode里面

02:59.780 --> 03:02.780
其实我们这个就是两格缩进

03:02.780 --> 03:04.780
你用tab键来表述的话

03:04.780 --> 03:06.780
紧接着继续往下看

03:06.780 --> 03:10.780
我们的最后我们说不需要去使用封号

03:10.780 --> 03:12.780
不要在里面用封号来结束

03:12.780 --> 03:15.780
你要用上去的话你来看一下

03:16.780 --> 03:17.780
这里面不能用对吧

03:17.780 --> 03:20.780
我们在程序中

03:20.780 --> 03:25.920
不如在app.js我们得到页面中

03:25.920 --> 03:31.130
你比如这边我们打一个封号

03:31.130 --> 03:32.130
它其实不会爆错

03:32.130 --> 03:35.130
但是这个的话是一个不规范的操作

03:35.130 --> 03:37.130
我们说我们不需要去用它

03:37.130 --> 03:40.130
紧接着我们再来看文档

03:40.130 --> 03:43.130
它说自负转统一用单引号

03:43.130 --> 03:44.130
用单引号格式来做

03:44.130 --> 03:46.130
那么单引号会碰到三种情况

03:46.130 --> 03:49.130
第一种就是里面还有引号的话

03:49.130 --> 03:51.130
单引号里面有双引号

03:51.130 --> 03:53.130
第二种如果你要输出单引号

03:53.130 --> 03:55.130
你就是用转移的方式

03:55.130 --> 03:57.130
第三种你里面本身就有单引号

03:57.130 --> 04:00.130
你外面是要用es6的方式来写

04:00.130 --> 04:02.130
那么弹码的多余留白

04:02.130 --> 04:05.130
就属于你中间别去空太多

04:05.130 --> 04:06.130
你不能说去空

04:06.130 --> 04:08.130
就是要我空开一点来做

04:08.130 --> 04:09.130
测试的时候是可以

04:09.130 --> 04:11.130
但最后我们说

04:11.130 --> 04:12.130
我们需要进行发布了

04:12.130 --> 04:14.130
编译整个builder操作的时候

04:14.130 --> 04:17.130
我们把这些都清一下

04:17.130 --> 04:18.130
不是说大家现在全部记住

04:18.130 --> 04:20.130
但是你在写的过程中

04:20.130 --> 04:21.130
你需要注意

04:21.130 --> 04:23.130
关键字后面加空格

04:23.130 --> 04:24.130
这意思是

04:24.130 --> 04:26.130
关键字加空格主要是一幅后面

04:26.130 --> 04:28.130
它空开一点

04:28.130 --> 04:29.130
合在一起的话

04:29.130 --> 04:30.130
它说这是错误

04:30.130 --> 04:31.130
当然这个错误

04:31.130 --> 04:33.130
不是说不能运行

04:33.130 --> 04:34.130
还是那句话

04:34.130 --> 04:35.130
继续往下

04:35.130 --> 04:36.130
声明时

04:36.130 --> 04:38.130
扩号与函数之间加空格

04:38.130 --> 04:39.130
这意思

04:39.130 --> 04:40.130
比如说你看这个

04:40.130 --> 04:41.130
它加个空格

04:41.130 --> 04:42.130
表示ok

04:42.130 --> 04:43.130
但你连在一起

04:43.130 --> 04:45.130
它说这个写法不正确

04:45.130 --> 04:46.130
包括是这样的写法

04:46.130 --> 04:47.130
你看

04:47.130 --> 04:49.130
它在这边留个空格

04:49.130 --> 04:50.130
这设施

04:50.130 --> 04:51.130
但这边它没有留

04:51.130 --> 04:52.130
它表示这是错误

04:52.130 --> 04:54.130
再往下展开运算符

04:54.130 --> 04:55.130
它中间

04:55.130 --> 04:56.130
不要留白

04:56.130 --> 04:57.130
就属于这里面

04:57.130 --> 04:58.130
你给它空了一个

04:58.130 --> 04:59.130
不需要

04:59.130 --> 05:01.130
那么遇到封号时

05:01.130 --> 05:02.130
空格要留在

05:02.130 --> 05:03.130
前

05:03.130 --> 05:04.130
不留后

05:04.130 --> 05:05.130
什么意思呢

05:05.130 --> 05:06.130
咱们看到

05:06.130 --> 05:08.130
如果我用循环方式的话

05:08.130 --> 05:11.130
一定是封号跟着前面的数字

05:11.130 --> 05:13.130
后面去留开

05:13.130 --> 05:14.130
这个逻辑

05:14.130 --> 05:15.130
然后我们看到

05:15.130 --> 05:17.130
我们的守尾加空格

05:17.130 --> 05:19.130
这意思是指的是

05:19.130 --> 05:21.130
我们在这边加了空格

05:21.130 --> 05:22.130
然后的话

05:22.130 --> 05:23.130
这边也没有空

05:23.130 --> 05:25.130
然后我们说代码快

05:25.130 --> 05:26.130
刚才说了

05:26.130 --> 05:28.130
这里面其实和前面的有一个

05:28.130 --> 05:30.130
就是关键字的空格是一样的

05:30.130 --> 05:31.130
原扩号间

05:31.130 --> 05:32.130
不留空格

05:32.130 --> 05:34.130
你这时候不用去加

05:34.130 --> 05:36.130
直接写上去就行

05:36.130 --> 05:38.130
然后属性面前

05:38.130 --> 05:39.130
不加任何的空格

05:39.130 --> 05:40.130
就是这个时候

05:40.130 --> 05:42.130
我们大家其实这个的ok的

05:42.130 --> 05:43.130
你要加空格的话

05:43.130 --> 05:44.130
这个语法还正不对了

05:44.130 --> 05:46.130
除非你说是样式结构中

05:46.130 --> 05:47.130
对吧

05:47.130 --> 05:49.130
意愿运算符前面

05:49.130 --> 05:50.130
跟一个空格

05:50.130 --> 05:51.130
意愿运算符

05:51.130 --> 05:52.130
如果type off的话

05:52.130 --> 05:54.130
那么你这时候用一个

05:54.130 --> 05:55.130
感烫号

05:55.130 --> 05:56.130
我们去反操作

05:56.130 --> 05:57.130
跟一个空格

05:57.130 --> 05:59.130
那么注释守尾是留空格的

05:59.130 --> 06:01.130
那么这边也留开一点

06:01.130 --> 06:02.130
这边留开一点

06:02.130 --> 06:03.130
它是只有这个要求

06:03.130 --> 06:04.130
然后再往下

06:04.130 --> 06:05.130
模板字幕串中间

06:05.130 --> 06:07.130
前后不加空格

06:07.130 --> 06:08.130
那么你们看到

06:08.130 --> 06:09.130
它现在用了一个

06:09.130 --> 06:11.130
ES6的模板鞋式

06:11.130 --> 06:12.130
那么这时候你加空格

06:12.130 --> 06:14.130
其实是没意义的

06:14.130 --> 06:15.130
因为它本身是一个模板

06:15.130 --> 06:16.130
并不是一个

06:16.130 --> 06:18.130
布局的格式展示

06:18.130 --> 06:20.130
豆号前面要加空格

06:20.130 --> 06:22.130
那么看到我们现在

06:22.130 --> 06:23.130
E 豆号

06:23.130 --> 06:25.130
然后后面加个空格出来

06:25.130 --> 06:26.130
是这样的一个写法

06:26.130 --> 06:28.130
然后错误的话

06:28.130 --> 06:29.130
只连在一起

06:29.130 --> 06:32.130
不允许有连续多行空格

06:32.130 --> 06:33.130
就是什么呢

06:33.130 --> 06:35.130
这两行代码放在一起写

06:35.130 --> 06:36.130
这时候你写完一行

06:36.130 --> 06:38.130
巴巴巴巴空很多

06:38.130 --> 06:39.130
测试时候

06:39.130 --> 06:41.130
如果你真的要里面写点东西

06:41.130 --> 06:42.130
那没有问题

06:42.130 --> 06:43.130
但如果说你不是写东西

06:43.130 --> 06:44.130
你就直接在这边

06:44.130 --> 06:45.130
进行操作的话

06:45.130 --> 06:47.130
那么这边有一个问题

06:47.130 --> 06:48.130
就是所谓的

06:48.130 --> 06:49.130
这是

06:50.130 --> 06:51.130
DV

06:51.130 --> 06:52.130
Development 的时候做

06:52.130 --> 06:53.130
但是你现在没有办法

06:53.130 --> 06:54.130
让它所谓的

06:54.130 --> 06:57.130
就是在我们的发布的时候

06:57.130 --> 06:59.130
让它去这么写

06:59.130 --> 07:01.130
然后紧接着

07:01.130 --> 07:04.130
当行代码快两边加空格

07:04.130 --> 07:06.130
当行代码快两边加空格

07:06.130 --> 07:07.130
那么你看

07:07.130 --> 07:08.130
这行和这行

07:08.130 --> 07:10.130
如果是当行代码

07:10.130 --> 07:11.130
就一行

07:11.130 --> 07:13.130
那么你在这边去加一个空格

07:13.130 --> 07:14.130
看到吗

07:14.130 --> 07:15.130
这样的写法

07:15.130 --> 07:17.130
不要使用非法的

07:17.130 --> 07:18.130
用白符

07:18.130 --> 07:20.130
你去用这个东西在

07:20.130 --> 07:21.130
NBSP

07:21.130 --> 07:23.130
它是网页版的NBSP

07:23.130 --> 07:24.130
这个的话

07:24.130 --> 07:25.130
我们说错误

07:25.130 --> 07:26.130
不能就这么写的

07:26.130 --> 07:28.130
然后再往下看

07:28.130 --> 07:30.130
始终将斗号置于行墨

07:30.130 --> 07:32.130
始终于斗号置于行墨

07:32.130 --> 07:33.130
那么你注意

07:33.130 --> 07:34.130
这样写

07:34.130 --> 07:36.130
你感觉好像是在一行里的

07:36.130 --> 07:37.130
其实我们把斗号

07:37.130 --> 07:39.130
要放在上一行上

07:39.130 --> 07:40.130
再来

07:42.130 --> 07:43.130
点号操作符

07:43.130 --> 07:44.130
与属性

07:44.130 --> 07:45.130
需在同一行

07:45.130 --> 07:46.130
咱们看一下

07:46.130 --> 07:48.130
我们需要这样

07:48.130 --> 07:49.130
把它写下来

07:49.130 --> 07:50.130
console.log

07:50.130 --> 07:52.130
如果你直接用点换下来

07:52.130 --> 07:53.130
那不行

07:53.130 --> 07:54.130
但是你要换下来的话

07:54.130 --> 07:56.130
你把点一起换下来

07:56.130 --> 07:57.130
这样写

07:57.130 --> 07:58.130
那么行

07:58.130 --> 07:59.130
文件墨

07:59.130 --> 08:01.130
咱们说留一个空行

08:01.130 --> 08:02.130
那么看到吗

08:02.130 --> 08:03.130
就是这边

08:03.130 --> 08:04.130
如果你要写注释

08:04.130 --> 08:06.130
你留开一个空格

08:07.130 --> 08:08.130
注意一下这个概念

08:08.130 --> 08:09.130
然后

08:09.130 --> 08:10.130
建置队中间

08:10.130 --> 08:11.130
我们说

08:11.130 --> 08:12.130
要留空白

08:12.130 --> 08:13.130
key value

08:13.130 --> 08:14.130
帽号中间

08:14.130 --> 08:15.130
留个白出来

08:15.130 --> 08:16.130
是这个意思

08:16.130 --> 08:17.130
你看到吗

08:17.130 --> 08:18.130
这个结构

08:18.130 --> 08:19.130
同时

08:19.130 --> 08:21.130
你注意这两个区别

08:21.130 --> 08:22.130
那么我们这边的话

08:22.130 --> 08:23.130
帽号

08:23.130 --> 08:24.130
注意

08:24.130 --> 08:26.130
帽号后面留出来

08:26.130 --> 08:28.130
前面我们不留了

08:28.130 --> 08:29.130
对正确结构

08:29.130 --> 08:31.130
这是属于我们的几个

08:31.130 --> 08:32.130
要求

08:32.130 --> 08:34.130
大家的一边在做的过程中

08:34.130 --> 08:36.130
一边慢慢的去适应

08:36.130 --> 08:37.130
不能就是一下子

08:37.130 --> 08:38.130
你要说一下子我全改过来

08:38.130 --> 08:39.130
可能你的写法

08:39.130 --> 08:41.130
习惯上面还是有一点

08:41.130 --> 08:42.130
然后变量定义

08:42.130 --> 08:44.130
我们看到console.log

08:44.130 --> 08:45.130
局务变量

08:45.130 --> 08:46.130
和那个叫什么

08:46.130 --> 08:47.130
常量

08:47.130 --> 08:48.130
我们定义的时候

08:48.130 --> 08:49.130
你看他错误

08:49.130 --> 08:50.130
请使用lat

08:50.130 --> 08:51.130
注意

08:51.130 --> 08:52.130
我们说到了

08:52.130 --> 08:53.130
那么如果说

08:53.130 --> 08:55.130
你现在直接去这么去操作

08:55.130 --> 08:56.130
因为console.log

08:56.130 --> 08:57.130
本身很简单

08:57.130 --> 08:58.130
它是一个常量

08:58.130 --> 08:59.130
对吧

08:59.130 --> 09:00.130
你要这样去写

09:00.130 --> 09:01.130
你注意

09:01.130 --> 09:02.130
我们注意这个词

09:02.130 --> 09:04.130
我们在原有的一些

09:04.130 --> 09:05.130
编码过程中

09:05.130 --> 09:07.130
我们经常可以用var

09:07.130 --> 09:08.130
可变类型

09:08.130 --> 09:10.130
但是在我们现在的target中

09:10.130 --> 09:12.130
我们大家都用的是lat

09:12.130 --> 09:13.130
或者console

09:13.130 --> 09:14.130
这个

09:14.130 --> 09:16.130
然后每个console

09:16.130 --> 09:18.130
和lat关键字

09:18.130 --> 09:20.130
单独声明一个变量

09:20.130 --> 09:22.130
不能连续声明

09:22.130 --> 09:24.130
只能单独分开来进行操作

09:24.130 --> 09:25.130
你这样的换行

09:25.130 --> 09:27.130
其实也是连续

09:27.130 --> 09:29.130
不重复声明变量

09:29.130 --> 09:30.130
不重复的话

09:30.130 --> 09:31.130
就意味着

09:31.130 --> 09:32.130
你看到这边

09:32.130 --> 09:33.130
我念声明了一个

09:33.130 --> 09:34.130
再声明一个

09:34.130 --> 09:36.130
其实它不是属于talo

09:36.130 --> 09:37.130
我们所有的语法

09:37.130 --> 09:39.130
都不可以这样去做操作的

09:39.130 --> 09:40.130
对吧

09:40.130 --> 09:41.130
你声明还一个lat以后

09:41.130 --> 09:43.130
我们可以对它进行改变

09:43.130 --> 09:45.130
你可以附给它一个兴致

09:45.130 --> 09:46.130
注意

09:46.130 --> 09:48.130
不要使用andfide

09:48.130 --> 09:50.130
来初始化变量

09:50.130 --> 09:51.130
你定一个变量

09:51.130 --> 09:52.130
你给它andfide

09:52.130 --> 09:53.130
那么注意

09:53.130 --> 09:55.130
在我们的系统里面的话

09:55.130 --> 09:56.130
有一点要注意

09:56.130 --> 09:59.130
andfide跟nau是不一样的

09:59.130 --> 10:00.130
andfide

10:00.130 --> 10:02.130
是我空间还没有被开闭

10:02.130 --> 10:03.130
它是一个

10:03.130 --> 10:05.130
根本不存在的一内容

10:05.130 --> 10:06.130
而nau

10:06.130 --> 10:08.130
是我空间已经开闭出来了

10:08.130 --> 10:09.130
理解吧

10:09.130 --> 10:10.130
这意思

10:10.130 --> 10:11.130
所以你判空的时候

10:11.130 --> 10:13.130
你到底是希望它是

10:13.130 --> 10:14.130
里面没有东西

10:14.130 --> 10:16.130
还是说根本就没创建这个

10:16.130 --> 10:17.130
它是有这个区别的

10:17.130 --> 10:19.130
对于变量和函数名

10:19.130 --> 10:20.130
统一的投风命名

10:20.130 --> 10:21.130
咱们看到

10:21.130 --> 10:24.130
如果你是属于我们的function的话

10:24.130 --> 10:25.130
那么你投风命名

10:25.130 --> 10:26.130
小写大写

10:26.130 --> 10:27.130
这个是

10:27.130 --> 10:28.130
如果你现在

10:28.130 --> 10:29.130
是属于一个长量的话

10:29.130 --> 10:30.130
你看到

10:30.130 --> 10:31.130
小写大写

10:31.130 --> 10:32.130
这样的命名方式

10:32.130 --> 10:33.130
也就是我们所谓的投风

10:33.130 --> 10:34.130
对吧

10:34.130 --> 10:35.130
不要使用

10:35.130 --> 10:36.130
为使用

10:36.130 --> 10:38.130
为定义的变量

10:38.130 --> 10:40.130
就是属于你看到这边

10:40.130 --> 10:41.130
为定义使用变量

10:41.130 --> 10:42.130
就是属于这个

10:42.130 --> 10:43.130
你看到

10:43.130 --> 10:44.130
我们现在这里面有一个

10:44.130 --> 10:45.130
something

10:45.130 --> 10:46.130
something的话

10:46.130 --> 10:48.130
它其实没有所谓的

10:48.130 --> 10:49.130
哪里定义过something

10:49.130 --> 10:50.130
你直接使用了

10:50.130 --> 10:52.130
这个的话是不行的

10:52.130 --> 10:55.130
避免将变量负值给自己

10:55.130 --> 10:56.130
这个的话

10:56.130 --> 10:57.130
当然肯定不行

10:57.130 --> 10:59.130
我们在很多的时候

10:59.130 --> 11:00.130
无论是与法允许的话

11:00.130 --> 11:01.130
我们都觉得

11:01.130 --> 11:02.130
这是

11:02.130 --> 11:03.130
何必呢

11:03.130 --> 11:04.130
这样就是对吧

11:04.130 --> 11:05.130
那么基本类型

11:05.130 --> 11:06.130
简单说一下

11:06.130 --> 11:08.130
我们不要省去小数点

11:08.130 --> 11:09.130
前面的

11:09.130 --> 11:10.130
有些时候

11:10.130 --> 11:11.130
我们一些与法里面

11:11.130 --> 11:12.130
比较宽松

11:12.130 --> 11:13.130
你说点5

11:13.130 --> 11:14.130
它基本上就理解为0.5

11:14.130 --> 11:16.130
我们其实这边要写全

11:16.130 --> 11:17.130
第二个

11:17.130 --> 11:18.130
字符上拼接字符串

11:18.130 --> 11:19.130
拼接字后的话

11:19.130 --> 11:21.130
我们说之间要留空格

11:21.130 --> 11:22.130
你拼接一个的时候

11:22.130 --> 11:23.130
我们加号

11:23.130 --> 11:24.130
你看

11:24.130 --> 11:25.130
留空格

11:25.130 --> 11:26.130
这意思

11:26.130 --> 11:27.130
对吧

11:27.130 --> 11:28.130
你现在的话

11:28.130 --> 11:29.130
直接加号去

11:29.130 --> 11:30.130
直接拼的话

11:30.130 --> 11:31.130
那么这个在写法上

11:31.130 --> 11:32.130
它是认为是错误的

11:32.130 --> 11:34.130
不要使用多行字符串

11:34.130 --> 11:35.130
那么我们看到

11:35.130 --> 11:37.130
你在这边操作以后

11:37.130 --> 11:38.130
你把它换下来

11:38.130 --> 11:39.130
你用杠

11:39.130 --> 11:41.130
这个写法也是错误的

11:41.130 --> 11:42.130
还有我们判

11:42.130 --> 11:44.130
是否是我们的

11:44.130 --> 11:46.130
数次的话

11:46.130 --> 11:47.130
你不能用我们的

11:47.130 --> 11:48.130
NAN

11:48.130 --> 11:49.130
你要用IS

11:49.130 --> 11:51.130
用它的一个函数体来做

11:51.130 --> 11:53.130
你要用函数体来做

11:53.130 --> 11:54.130
好

11:54.130 --> 11:55.130
紧接着继续

11:55.130 --> 11:56.130
我们继续

11:57.130 --> 11:59.130
合法的字符串

11:59.130 --> 12:01.130
跟Type进行比较

12:01.130 --> 12:02.130
那么

12:02.130 --> 12:04.130
所有的合法字符串

12:04.130 --> 12:05.130
你不能去判空

12:05.130 --> 12:07.130
你一定要是判的是

12:07.130 --> 12:09.130
带上引号的

12:09.130 --> 12:10.130
对象与数组

12:10.130 --> 12:12.130
对象中定义了存值器

12:12.130 --> 12:14.130
一定要对应我们的

12:14.130 --> 12:15.130
定义的取值器

12:15.130 --> 12:16.130
什么意思呢

12:16.130 --> 12:18.130
还记得我们前面

12:18.130 --> 12:19.130
给大家讲过的

12:19.130 --> 12:21.130
就是set and get吗

12:21.130 --> 12:22.130
一个是

12:22.130 --> 12:23.130
我们称之为

12:23.130 --> 12:24.130
它是一个

12:24.130 --> 12:26.130
取合存的一个配对

12:26.130 --> 12:28.130
你如果有一个set

12:28.130 --> 12:30.130
那么你一定要有一个set and get

12:30.130 --> 12:31.130
它称之为

12:31.130 --> 12:33.130
对于这样的一个变量

12:33.130 --> 12:34.130
就是我们的nand的

12:34.130 --> 12:36.130
一个存和取的一个配套结构

12:36.130 --> 12:38.130
你不能简单就是一个设置

12:38.130 --> 12:39.130
接下去

12:39.130 --> 12:41.130
使用数字

12:41.130 --> 12:43.130
数组字面量的时候

12:43.130 --> 12:45.130
而不是够道气

12:45.130 --> 12:46.130
那么它其实指的是

12:46.130 --> 12:48.130
我们在创建数组的时候

12:48.130 --> 12:50.130
我们不去用new arrow

12:50.130 --> 12:51.130
这种写法

12:51.130 --> 12:53.130
我们直接用中国号的方式来做

12:53.130 --> 12:55.130
不要解构空值

12:55.130 --> 12:56.130
那么我们看到

12:56.130 --> 12:58.130
我们现在Constance里面

12:58.130 --> 12:59.130
我们把这个值

12:59.130 --> 13:00.130
需要把它解构出来

13:00.130 --> 13:01.130
解构的时候

13:01.130 --> 13:02.130
你这里面

13:02.130 --> 13:03.130
你就没放东西

13:03.130 --> 13:04.130
所以它解构一半

13:04.130 --> 13:05.130
你说a的话

13:05.130 --> 13:07.130
它是一个固定值

13:07.130 --> 13:08.130
它解构给谁

13:08.130 --> 13:09.130
它不会自动往里面放值

13:09.130 --> 13:11.130
它会把for里面的值

13:11.130 --> 13:12.130
直接解构到b

13:12.130 --> 13:13.130
正确的变量中

13:13.130 --> 13:15.130
需要这样去写

13:15.130 --> 13:17.130
对象字面量中

13:17.130 --> 13:19.130
不要定义重复的属性

13:19.130 --> 13:20.130
你去定义两个

13:20.130 --> 13:21.130
那怎么可能呢

13:21.130 --> 13:22.130
对吧

13:22.130 --> 13:24.130
不要扩展原生对象

13:24.130 --> 13:25.130
咱们看到

13:25.130 --> 13:26.130
我们在系统中

13:26.130 --> 13:28.130
我们用的perfect type

13:28.130 --> 13:29.130
那么这个的话

13:29.130 --> 13:31.130
是我们系统中

13:31.130 --> 13:32.130
我们拥有的

13:32.130 --> 13:34.130
原生对象的一个设置方式

13:34.130 --> 13:35.130
我们说

13:35.130 --> 13:36.130
我们自己不要

13:36.130 --> 13:37.130
去对它进行设定

13:37.130 --> 13:39.130
那么在我们的npview

13:39.130 --> 13:41.130
这样的一个框架里面

13:41.130 --> 13:44.130
我们是可以去设定原生的

13:44.130 --> 13:45.130
对吧

13:45.130 --> 13:46.130
我们原生设定以后的话

13:46.130 --> 13:47.130
在其他地方

13:47.130 --> 13:49.130
我们都可以像全局一样使用

13:49.130 --> 13:51.130
但是对于我们的tarrow来讲

13:51.130 --> 13:52.130
它不允许你

13:52.130 --> 13:53.130
去这样做一个原生的扩展

13:53.130 --> 13:55.130
这边已经告诉你了

13:55.130 --> 13:56.130
第二个的话

13:56.130 --> 13:57.130
外部变量

13:57.130 --> 13:59.130
不要对对象属性

13:59.130 --> 14:00.130
重明

14:00.130 --> 14:01.130
来看一下

14:01.130 --> 14:02.130
就是什么意思呢

14:02.130 --> 14:04.130
你看到这边

14:04.130 --> 14:06.130
外部有一个stop

14:06.130 --> 14:07.130
那么这时候

14:07.130 --> 14:09.130
你在这个方法里面

14:09.130 --> 14:10.130
你又完成一个stop

14:10.130 --> 14:12.130
那么这样的重明系统里面

14:12.130 --> 14:14.130
它会去识别

14:14.130 --> 14:16.130
你有重明的变量存在

14:16.130 --> 14:18.130
所以你不能对它进行使用

14:18.130 --> 14:19.130
因为你一旦这样用的话

14:19.130 --> 14:20.130
其实它是可以

14:20.130 --> 14:22.130
依然可以读到它的

14:22.130 --> 14:23.130
你里面的话

14:23.130 --> 14:24.130
它就不知道

14:24.130 --> 14:25.130
到底读的是你现在的这个

14:25.130 --> 14:26.130
还是外部这个

14:26.130 --> 14:27.130
所以我们说

14:27.130 --> 14:28.130
外部变量

14:28.130 --> 14:30.130
不要以我们对象的

14:30.130 --> 14:32.130
这是属于对象的一个属性

14:32.130 --> 14:33.130
重明

14:33.130 --> 14:34.130
对象属性

14:34.130 --> 14:36.130
切换时要注意

14:36.130 --> 14:37.130
代码的统一风格

14:37.130 --> 14:38.130
咱们看到这边

14:38.130 --> 14:40.130
这边的话

14:40.130 --> 14:42.130
是我们把一个对象

14:42.130 --> 14:43.130
横向放在一起

14:43.130 --> 14:44.130
这是ok的

14:44.130 --> 14:45.130
那么像这样的话

14:45.130 --> 14:46.130
你发现

14:46.130 --> 14:48.130
一行里面写了两个

14:48.130 --> 14:49.130
但是又有一个

14:49.130 --> 14:50.130
换下来了

14:50.130 --> 14:51.130
要不你像它一样

14:51.130 --> 14:52.130
全部换下来

14:52.130 --> 14:53.130
要不就是全部不换

14:53.130 --> 14:54.130
换一个下来

14:54.130 --> 14:55.130
那这个的话

14:55.130 --> 14:56.130
给人家看着上去

14:56.130 --> 14:57.130
就是不规范

14:57.130 --> 14:58.130
错误

14:58.130 --> 15:00.130
避免使用不必要的

15:00.130 --> 15:02.130
计算属性值

15:02.130 --> 15:03.130
你去使用这样的一个

15:03.130 --> 15:04.130
中国号

15:04.130 --> 15:06.130
我们说不可以

15:06.130 --> 15:07.130
中国号是一个

15:07.130 --> 15:09.130
计算属性的一个操作

15:09.130 --> 15:11.130
函数里面使用

15:11.130 --> 15:12.130
函数我们说了

15:12.130 --> 15:14.130
避免使用这两个操作

15:14.130 --> 15:15.130
因为我们

15:15.130 --> 15:16.130
本身来讲

15:16.130 --> 15:18.130
我们的有些的

15:18.130 --> 15:19.130
编译以后

15:19.130 --> 15:20.130
这两个是不支持

15:20.130 --> 15:21.130
我小人

15:21.130 --> 15:22.130
他本身就不支持这两个

15:22.130 --> 15:23.130
所以不要去用

15:23.130 --> 15:25.130
不要荣誉的残属

15:25.130 --> 15:26.130
什么意思呢

15:26.130 --> 15:27.130
你看A传过来

15:27.130 --> 15:28.130
B传过来

15:28.130 --> 15:29.130
再传个A

15:29.130 --> 15:30.130
我们要传餐

15:30.130 --> 15:32.130
就是传三个不同的参数

15:32.130 --> 15:34.130
避免多余的函数

15:34.130 --> 15:35.130
剩下文绑定

15:35.130 --> 15:36.130
这意思

15:36.130 --> 15:37.130
那你来看一下

15:37.130 --> 15:39.130
这是两个什么概念

15:39.130 --> 15:40.130
这个是指的是

15:40.130 --> 15:42.130
我们这一边直接使用

15:42.130 --> 15:43.130
get念

15:43.130 --> 15:44.130
而我们现在说

15:44.130 --> 15:45.130
需要的是

15:45.130 --> 15:46.130
这个U色的话

15:46.130 --> 15:47.130
我们需要

15:47.130 --> 15:48.130
Y步

15:48.130 --> 15:49.130
distance get a net

15:49.130 --> 15:50.130
需要做一个这样的指向

15:50.130 --> 15:51.130
这是属于

15:51.130 --> 15:52.130
荣誉代码

15:52.130 --> 15:53.130
应该讲

15:53.130 --> 15:54.130
大家应该能看懂

15:54.130 --> 15:55.130
evo的话

15:55.130 --> 15:56.130
是计算值

15:56.130 --> 15:57.130
对吧

15:57.130 --> 15:58.130
计算值的话

15:58.130 --> 15:59.130
那么在这上面

15:59.130 --> 16:00.130
我们会发现

16:00.130 --> 16:02.130
我们不能去使用这个操作

16:02.130 --> 16:03.130
因为不是说

16:03.130 --> 16:05.130
所有的他都能支持evo的

16:05.130 --> 16:07.130
整个计算的

16:07.130 --> 16:11.850
不要省多余的扩耗

16:11.850 --> 16:12.850
我会发现

16:12.850 --> 16:13.850
这边

16:13.850 --> 16:14.850
你在这里

16:14.850 --> 16:15.850
我们的扩耗是可以用

16:15.850 --> 16:16.850
扩耗在什么时候呢

16:16.850 --> 16:17.850
扩耗其实是

16:17.850 --> 16:19.850
能够帮助我们识别

16:19.850 --> 16:21.850
现在有一段数据

16:21.850 --> 16:22.850
需要进行输出

16:22.850 --> 16:23.850
但是你这样去

16:23.850 --> 16:24.850
多一个扩耗

16:24.850 --> 16:25.850
其实没有意义

16:25.850 --> 16:26.850
我们比如说

16:26.850 --> 16:28.850
在randow return 里面

16:28.850 --> 16:29.850
如果你需要有很多的

16:29.850 --> 16:30.850
一个JSX的

16:30.850 --> 16:31.850
一个数据返回

16:31.850 --> 16:32.850
并不是一个简单的

16:32.850 --> 16:33.850
那么你倒是可以

16:33.850 --> 16:34.850
去用一个扩耗来表述

16:34.850 --> 16:36.850
表示这是一个输出

16:36.850 --> 16:37.850
弹码断

16:37.850 --> 16:39.850
尽量避免

16:39.850 --> 16:41.850
我们说寒树的重新复制

16:41.850 --> 16:42.850
这意思

16:42.850 --> 16:43.850
你这已经定义了

16:43.850 --> 16:44.850
一个寒树了

16:44.850 --> 16:45.850
对吧

16:45.850 --> 16:46.850
寒树名

16:46.850 --> 16:47.850
你这时候再给他定义

16:47.850 --> 16:48.850
另一个寒树名

16:48.850 --> 16:49.850
这样的话

16:49.850 --> 16:50.850
我们说

16:50.850 --> 16:51.850
它是属于错误的

16:51.850 --> 16:53.850
注意影视的使用一个evo

16:53.850 --> 16:55.850
影视使用evo

16:55.850 --> 16:57.850
你现在有个set time out

16:57.850 --> 16:58.850
你在这里面

16:58.850 --> 16:59.850
直接使用了一个

16:59.850 --> 17:00.850
伺服串

17:00.850 --> 17:01.850
这个写法

17:01.850 --> 17:02.850
它肯定是错误

17:02.850 --> 17:03.850
那么你在这里面

17:03.850 --> 17:04.850
去使用一个方法

17:04.850 --> 17:05.850
当然

17:05.850 --> 17:06.850
它利用了alert

17:06.850 --> 17:07.850
对吧

17:07.850 --> 17:08.850
它是根据我们

17:08.850 --> 17:09.850
现在的

17:09.850 --> 17:11.850
可能用在H5

17:11.850 --> 17:12.850
页面上的时候

17:12.850 --> 17:14.850
它可以用到这个内容

17:14.850 --> 17:15.850
千头弹码中

17:15.850 --> 17:17.850
禁止再一次定义寒树

17:17.850 --> 17:19.850
这点需要注意一下

17:19.850 --> 17:20.850
千头弹码中

17:20.850 --> 17:21.850
我们现在

17:21.850 --> 17:22.850
这里边

17:22.850 --> 17:23.850
你说evo里面

17:23.850 --> 17:24.850
我再定一个内部寒树

17:24.850 --> 17:25.850
这个不允许

17:25.850 --> 17:27.850
禁止使用function的构造器

17:27.850 --> 17:29.850
这个也是不可以有的

17:29.850 --> 17:30.850
object的构造器

17:30.850 --> 17:31.850
也是禁止使用

17:31.850 --> 17:32.850
你不能说

17:32.850 --> 17:33.850
我去创建一个对象

17:33.850 --> 17:34.850
这个对象是什么

17:34.850 --> 17:35.850
不知道

17:35.850 --> 17:36.850
但是它就是个对象

17:36.850 --> 17:37.850
那不行

17:37.850 --> 17:38.850
这就是

17:38.850 --> 17:39.850
那个自调用

17:39.850 --> 17:40.850
匿名寒树

17:40.850 --> 17:41.850
库号内

17:41.850 --> 17:42.850
我们说

17:42.850 --> 17:43.850
包裹

17:43.850 --> 17:44.850
这点操作

17:44.850 --> 17:45.850
你看

17:45.850 --> 17:46.850
现在的话

17:46.850 --> 17:47.850
它现在形成了

17:47.850 --> 17:48.850
这样的一个写法

17:48.850 --> 17:49.850
就是

17:49.850 --> 17:50.850
我们现在有个空的

17:50.850 --> 17:51.850
一个寒树

17:51.850 --> 17:52.850
然后让它后面

17:52.850 --> 17:53.850
再跟上

17:53.850 --> 17:54.850
寒树体

17:54.850 --> 17:55.850
你把前面反过的内容

17:55.850 --> 17:57.850
作为新寒树的名称在

17:57.850 --> 17:58.850
这个是不可以的

17:58.850 --> 17:59.850
这样直接做

17:59.850 --> 18:00.850
你需要这样做的话

18:00.850 --> 18:02.850
你要带上一个库号

18:02.850 --> 18:03.850
或者你把前面

18:03.850 --> 18:04.850
库号带上

18:04.850 --> 18:05.850
不然系统认为

18:05.850 --> 18:06.850
这是一体的

18:06.850 --> 18:07.850
理解吧

18:07.850 --> 18:09.850
不要使用generate

18:09.850 --> 18:10.850
generate是什么

18:10.850 --> 18:11.850
构造寒树

18:11.850 --> 18:12.850
我们说

18:12.850 --> 18:13.850
构造器

18:13.850 --> 18:14.850
我们不要去使用

18:14.850 --> 18:15.850
这样的一个东西

18:16.850 --> 18:17.850
然后振泽

18:17.850 --> 18:18.850
那么振泽的话

18:18.850 --> 18:19.850
大家可以看一下

18:19.850 --> 18:20.850
这个的话

18:20.850 --> 18:21.850
应该讲

18:21.850 --> 18:22.850
还是比较简单

18:22.850 --> 18:24.850
不要使用我们的控制服

18:24.850 --> 18:26.850
包括是多余的空格

18:26.850 --> 18:27.850
类里面

18:27.850 --> 18:30.850
类名必须大写字母开头

18:30.850 --> 18:32.850
一定要是大写字母表示

18:32.850 --> 18:34.850
避免我们说

18:35.850 --> 18:37.850
对类名进行重新复制

18:37.850 --> 18:38.850
这个肯定不行

18:38.850 --> 18:39.850
对吧

18:39.850 --> 18:41.850
因为对于类来讲的话

18:41.850 --> 18:42.850
它其实指向的是

18:42.850 --> 18:44.850
类空间的一个地址

18:44.850 --> 18:45.850
然后我们现在对它

18:45.850 --> 18:46.850
重新复制

18:46.850 --> 18:47.850
那么这个复制是

18:47.850 --> 18:48.850
不可取的

18:48.850 --> 18:49.850
不能操作的

18:49.850 --> 18:50.850
对吧

18:50.850 --> 18:51.850
你看一下

18:51.850 --> 18:52.850
类构造器里面

18:52.850 --> 18:54.850
也就是我们大家俗称的

18:54.850 --> 18:55.850
构造寒树里面

18:55.850 --> 18:56.850
我们这边

18:56.850 --> 18:58.850
会用到一个super

18:58.850 --> 18:59.850
注意一下

18:59.850 --> 19:00.850
我们一定得使用super

19:00.850 --> 19:02.850
但是super使用的规则是什么

19:02.850 --> 19:03.850
规则是

19:03.850 --> 19:05.850
你有继承

19:05.850 --> 19:06.850
你有继承

19:06.850 --> 19:07.850
super的意义就在于

19:07.850 --> 19:09.850
它是会调用

19:09.850 --> 19:10.850
副类的

19:10.850 --> 19:11.850
副类的

19:11.850 --> 19:12.850
也就是俗称的

19:12.850 --> 19:13.850
G类

19:13.850 --> 19:15.850
G类的一个构造寒树

19:15.850 --> 19:16.850
如果你根本连G类都没有

19:16.850 --> 19:18.850
那你就不需要用super

19:18.850 --> 19:19.850
这个意思

19:19.850 --> 19:20.850
对吧

19:20.850 --> 19:21.850
使用this

19:21.850 --> 19:22.850
前

19:22.850 --> 19:24.850
请保持super的调用

19:24.850 --> 19:25.850
我们讲

19:25.850 --> 19:27.850
一般性我们的要求是

19:27.850 --> 19:29.850
如果你现在写类

19:29.850 --> 19:30.850
完成构造寒

19:30.850 --> 19:31.850
构造器的操作

19:31.850 --> 19:33.850
那么你第一句话

19:33.850 --> 19:34.850
如果你有继承的话

19:34.850 --> 19:36.850
就一定要写super

19:36.850 --> 19:38.850
如果你有参数

19:38.850 --> 19:39.850
构造器有参数

19:39.850 --> 19:41.850
就是在这个里面

19:41.850 --> 19:42.850
构好里面有参数的话

19:42.850 --> 19:43.850
你要把它

19:43.850 --> 19:45.850
一起丢给super

19:45.850 --> 19:46.850
这个意思

19:46.850 --> 19:47.850
我们说

19:47.850 --> 19:48.850
不要有

19:48.850 --> 19:49.850
勇于多余的

19:49.850 --> 19:51.850
就是你这啥时候不干

19:51.850 --> 19:52.850
啥时候不干

19:52.850 --> 19:53.850
这事里面

19:53.850 --> 19:54.850
直接这么写个空的

19:54.850 --> 19:55.850
那这事不行

19:55.850 --> 19:56.850
理解吧

19:56.850 --> 19:57.850
类中不要定义

19:57.850 --> 19:58.850
勇于的属性

19:58.850 --> 19:59.850
有两个

19:59.850 --> 20:01.850
勇于就是多个出现

20:01.850 --> 20:02.850
那么

20:02.850 --> 20:04.850
无参的构造权要带上扩号

20:04.850 --> 20:06.850
你不能直接单写一个这个

20:06.850 --> 20:07.850
你要带上一个扩号来写

20:07.850 --> 20:08.850
定义它的变量名

20:08.850 --> 20:10.850
你有实力的时候

20:10.850 --> 20:11.850
你要让它

20:11.850 --> 20:12.850
附给我们

20:12.850 --> 20:13.850
所要的一个对象

20:13.850 --> 20:14.850
使其能够

20:14.850 --> 20:15.850
接收到你

20:15.850 --> 20:16.850
现在这样的一个对象的

20:16.850 --> 20:17.850
一个名称

20:17.850 --> 20:19.850
如果你单创建这个纸的话

20:19.850 --> 20:21.850
那么它是没有办法去获取

20:21.850 --> 20:23.850
它直接消失在那存了

20:23.850 --> 20:24.850
理解吧

20:24.850 --> 20:25.850
这一次

20:25.850 --> 20:26.850
包括是后面模块

20:26.850 --> 20:27.850
语句上面

20:27.850 --> 20:28.850
也会有这样的一些

20:28.850 --> 20:29.850
这里

20:29.850 --> 20:30.850
大家看线

20:30.850 --> 20:31.850
后面还非常多

20:31.850 --> 20:32.850
那么我们

20:32.850 --> 20:33.850
希望大家

20:33.850 --> 20:34.850
在做的过程中

20:34.850 --> 20:35.850
去看一下

20:35.850 --> 20:37.850
我就后面再回一个读了

20:37.850 --> 20:38.850
那么大家

20:38.850 --> 20:39.850
主要看好以后的话

20:39.850 --> 20:41.850
在后面的编写过程中

20:41.850 --> 20:42.850
会有一定的识别

20:42.850 --> 20:44.850
那么还是那句话

20:44.850 --> 20:45.850
不需要大家

20:45.850 --> 20:46.850
从头到尾的

20:46.850 --> 20:47.850
一个全部的

20:47.850 --> 20:48.850
马上记住

20:48.850 --> 20:50.850
但是不断的去看

20:50.850 --> 20:51.850
然后对你后期

20:51.850 --> 20:52.850
无论写tallow

20:52.850 --> 20:54.850
还是写其他语法来讲

20:54.850 --> 20:56.850
都会有一定的编码规范

20:56.850 --> 20:57.850
这样对你来说

20:57.850 --> 20:59.850
有非常大的一个

20:59.850 --> 21:01.850
编码的好习惯

21:01.850 --> 21:02.850
这意思上

21:02.850 --> 21:03.850
那么我觉得

21:03.850 --> 21:04.850
tallow的规范

21:04.850 --> 21:05.850
这一块内容

21:05.850 --> 21:07.850
讲得非常的全

21:07.850 --> 21:09.850
把我们在编码过程中

21:09.850 --> 21:10.850
所涉及到的

21:10.850 --> 21:12.850
所有的那些写法

21:12.850 --> 21:14.850
都已经在上面写出来了

21:14.850 --> 21:15.850
所以我们觉得

21:15.850 --> 21:16.850
大家的话

21:16.850 --> 21:17.850
写其他的编码的时候

21:17.850 --> 21:18.850
也可以参照

21:18.850 --> 21:19.850
这样的结构来看

21:19.850 --> 21:20.850
那么之后

21:20.850 --> 21:22.850
我也会在不同的课程中

21:22.850 --> 21:23.850
给大家去讲解

21:23.850 --> 21:24.850
我们说

21:24.850 --> 21:25.850
这个部分

21:25.850 --> 21:26.850
是否空

21:26.850 --> 21:27.850
是否是好

21:27.850 --> 21:28.850
如果说

21:28.850 --> 21:29.850
我们在编写过程中

21:29.850 --> 21:31.850
发现我之前写的内容

21:31.850 --> 21:32.850
和它这不对

21:32.850 --> 21:33.850
虽然运行

21:33.850 --> 21:34.850
编译也成功了

21:34.850 --> 21:35.850
那么你可以作为

21:35.850 --> 21:36.850
下一次

21:36.850 --> 21:37.850
或者去改一下它

21:37.850 --> 21:38.850
那么这个对我们来讲

21:38.850 --> 21:39.850
都是一个好的

21:39.850 --> 21:40.850
变成习惯

21:40.850 --> 21:41.850
好吧

21:41.850 --> 21:42.850
那么在这上面

21:42.850 --> 21:43.850
我在这

21:43.850 --> 21:44.850
就不再去

21:44.850 --> 21:45.850
记得去说了

21:45.850 --> 21:47.850
因为它本身的规范

21:47.850 --> 21:48.850
还是比较多

21:48.850 --> 21:49.850
那么希望大家

21:49.850 --> 21:50.850
能够很好的

21:50.850 --> 21:52.850
对它进行一个看一下

21:52.850 --> 21:53.850
它不需要你编码

21:53.850 --> 21:54.850
只需要你去看一下

21:54.850 --> 21:55.850
它里面的

21:55.850 --> 21:56.850
包括它正确和错误

21:56.850 --> 21:57.850
也给你呈现出来了

21:57.850 --> 21:58.850
好

21:58.850 --> 21:59.850
那么规范的操作

21:59.850 --> 22:00.850
需要我们大家

22:00.850 --> 22:01.850
日日积月累

22:01.850 --> 22:03.850
而不是一处而就的

22:03.850 --> 22:04.850
那么但是

22:04.850 --> 22:05.850
好的习惯

22:05.850 --> 22:06.850
可以慢慢养成

22:06.850 --> 22:07.850
好 这节课

22:07.850 --> 22:08.850
就先上到这

