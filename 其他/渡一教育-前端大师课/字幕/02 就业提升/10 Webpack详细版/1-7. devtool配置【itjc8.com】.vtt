WEBVTT

00:01.010 --> 00:04.410
上课之前啊 我先说一个事儿

00:04.810 --> 00:07.210
就咱们学习技术啊

00:07.810 --> 00:09.910
要有一个东西就是大局观

00:12.680 --> 00:16.680
像我们这个vipac这个课程东西可能比较多

00:16.880 --> 00:19.480
而且呢 有些内容可能比较深

00:19.980 --> 00:22.180
大家呢可能会在学习的过程中呢

00:22.180 --> 00:25.980
出现了一些比较为难的情绪啊

00:26.180 --> 00:29.580
那么最那种情绪的可能的原因呢

00:29.580 --> 00:31.480
就是缺乏大局观

00:31.680 --> 00:32.980
这是什么意思呢

00:33.380 --> 00:35.980
就是当你去看待一个技术的时候呢

00:36.280 --> 00:39.080
你要知道这个技术的边界在哪里

00:40.580 --> 00:41.380
的边界

00:42.180 --> 00:43.880
比方说我们这个学习的vipac

00:43.980 --> 00:45.080
vipac这个课程

00:45.480 --> 00:46.380
它重不重要

00:46.880 --> 00:47.480
重要

00:48.180 --> 00:48.980
但是呢

00:48.980 --> 00:52.780
它也仅仅是为了实现前端工程化

00:52.980 --> 00:53.980
出了这么一个东西

00:54.180 --> 00:57.680
它无非就是把我们的写的原代码

00:57.980 --> 01:01.580
把它编译成为打包啊合并压缩

01:01.680 --> 01:03.380
最终成为一个最终的代码

01:03.580 --> 01:03.980
对吧

01:04.180 --> 01:06.280
它也仅仅是它再复杂

01:06.380 --> 01:08.780
也仅仅是来做这么一件事

01:09.480 --> 01:11.880
所以说就算你这个vipac没有学好

01:11.980 --> 01:13.680
影响了范围大吗

01:13.780 --> 01:14.580
它也不大

01:14.880 --> 01:17.880
它会不会影响你写业务逻辑代码

01:18.480 --> 01:19.180
不会吧

01:19.480 --> 01:22.180
比方说你以后写什么登录

01:22.380 --> 01:23.680
哎你写什么

01:23.780 --> 01:24.780
比方说啊

01:25.080 --> 01:26.580
写什么阿家克斯请求

01:26.580 --> 01:27.880
会不会影响这些代码

01:28.180 --> 01:28.980
它不会

01:29.280 --> 01:30.980
它仅仅是把你写的代码

01:30.980 --> 01:33.480
然后给你打包啊合并成一个

01:33.980 --> 01:34.780
新的代码

01:34.980 --> 01:36.480
它仅仅是在做这么一件事

01:36.980 --> 01:39.480
所以当你有了这样的一个大局观的时候呢

01:39.580 --> 01:40.980
你在学习它的时候呢

01:40.980 --> 01:44.080
你就没有那么的恐惧和害怕

01:44.380 --> 01:46.480
因为它影响的范围就那么一点点

01:46.980 --> 01:47.880
听懂这个意思吗

01:48.780 --> 01:51.980
包括vipac里边又涉及到了很多技术

01:52.080 --> 01:53.380
其他的边界呢

01:53.680 --> 01:55.480
你只要认识到它的边界过后呢

01:55.480 --> 01:58.380
你就知道在我们整个的开发流程里边

01:58.380 --> 02:00.080
它也只占那么一小块

02:00.980 --> 02:03.480
就算了我没有彻底的搞清楚它

02:03.780 --> 02:05.480
也问题了也不严重

02:06.080 --> 02:08.080
因此呢你有了这种大局观之后呢

02:08.080 --> 02:10.780
你再去学习很多东西的时候呢

02:10.980 --> 02:12.880
你对它有清晰的认知

02:13.280 --> 02:15.980
而且呢你不会对它有任何的恐惧

02:16.680 --> 02:18.780
一向我们技术这个领域呢

02:18.980 --> 02:19.780
学东西

02:20.080 --> 02:21.580
要学的东西太多了

02:21.580 --> 02:22.780
包括我现在啊

02:22.980 --> 02:24.880
我已经在这个行业里边多少年了

02:24.880 --> 02:25.680
十年了吧

02:26.180 --> 02:27.080
有十年的时间了

02:27.080 --> 02:28.780
我还在不停的学习新东西

02:29.080 --> 02:30.480
但是学习新东西我害怕吗

02:30.480 --> 02:31.280
我不害怕

02:31.480 --> 02:33.480
因为我首先会认识到这个东西

02:33.480 --> 02:34.880
它的边界在哪里

02:34.880 --> 02:36.280
它是在解决什么问题的

02:36.280 --> 02:38.780
那么除了这个边界就跟它没关系了

02:38.880 --> 02:40.880
所以说我学习它就算没有学习统

02:41.180 --> 02:43.680
它也不会对我其他东西造成任何影响

02:44.280 --> 02:45.680
不知道大家能不能

02:46.280 --> 02:47.480
感觉到这个东西啊

02:47.480 --> 02:49.080
能不能理解我说的话

02:49.780 --> 02:52.680
像我们这几个学校的这个东西叫DevTool配置

02:53.480 --> 02:55.480
它涉及到一个技术叫做Source Map

02:55.880 --> 02:57.680
可能这个技术大家听都没有听过

02:58.180 --> 02:59.680
但是我一解释过后呢

02:59.680 --> 03:02.180
你要清晰的认识到它的边界在哪里

03:02.180 --> 03:05.780
它也只是解决那么一个非常非常小的问题

03:06.580 --> 03:07.780
好 咱们来看一下啊

03:07.780 --> 03:10.480
咱们这里可以学到这个DevTool配置

03:10.780 --> 03:12.380
因为我们上一课讲的配置文件嘛

03:12.380 --> 03:12.680
对吧

03:12.680 --> 03:13.480
里面有很多配置

03:13.480 --> 03:15.580
那么现在我们学习个新的配置叫DevTool

03:16.780 --> 03:17.780
要学习这个配置呢

03:17.780 --> 03:20.480
我们首先要知道一个技术叫做Source Map

03:20.880 --> 03:21.680
那么学习的过程中

03:21.680 --> 03:23.480
大家要知道它的边界在哪里

03:24.180 --> 03:25.080
Source Map呢

03:25.080 --> 03:27.180
它我们把它称之为原码地图

03:27.180 --> 03:27.980
其实很多时候呢

03:27.980 --> 03:29.880
我们一般就直接叫Source Map

03:30.680 --> 03:31.980
那么这一部分的东西呢

03:32.080 --> 03:33.880
它跟Modepak是没有任何关系的

03:33.980 --> 03:34.980
一点关系都没有

03:35.480 --> 03:37.980
它是一个完全独立的技术

03:38.880 --> 03:39.680
什么意思呢

03:39.680 --> 03:42.180
好 接下来我来给大家介绍这个边界了

03:42.180 --> 03:43.580
它的指使的边界在哪里

03:44.580 --> 03:46.380
我们前端发展到目前这个阶段

03:46.380 --> 03:47.380
很多时候呢

03:47.380 --> 03:49.880
它不会直接运行原代码

03:50.580 --> 03:53.180
而是需要对原代码来进行合并

03:53.180 --> 03:54.480
比方说有很多个文件

03:54.580 --> 03:55.980
你要进行合并操作

03:56.380 --> 03:57.180
合并了之后呢

03:57.180 --> 03:59.180
可能为了减少体积

03:59.180 --> 04:00.280
你还要进行压缩

04:00.880 --> 04:01.580
或者说呢

04:01.580 --> 04:03.380
你做要做一些转换操作

04:03.480 --> 04:04.080
比方说什么呢

04:04.080 --> 04:06.580
你们后边会学习TS type scripts

04:06.880 --> 04:09.780
那么可能会不是用GS语言写的代码

04:09.980 --> 04:13.380
用其他的更加优雅的方式的写的代码

04:13.780 --> 04:15.680
然后把它转换成GS

04:15.780 --> 04:17.780
就是可能会进行一些转换操作

04:18.180 --> 04:19.180
也就是说呢

04:19.180 --> 04:20.980
我们直接写的代码呢

04:21.080 --> 04:23.580
很有可能是不会直接运行了

04:23.880 --> 04:25.180
就像我们的位派可一样

04:25.780 --> 04:26.780
有的位派可之后呢

04:26.780 --> 04:28.780
我们写的原代码会不会直接运行

04:28.780 --> 04:29.680
它不会对吧

04:29.880 --> 04:31.380
我们看一下再看一下这个图

04:32.080 --> 04:32.880
多来几次

04:33.080 --> 04:34.180
我们这边

04:34.480 --> 04:36.180
这一部分是我们的原代码

04:36.180 --> 04:36.680
对不对

04:36.780 --> 04:37.880
它不会直接运行

04:37.880 --> 04:38.680
运行的是什么呢

04:38.980 --> 04:40.480
是打包之后的代码

04:40.680 --> 04:41.680
是这一部分代码

04:42.980 --> 04:43.780
就这个意思

04:44.980 --> 04:45.780
那么你看啊

04:45.780 --> 04:46.480
这个一张图

04:46.480 --> 04:47.980
比方说我们有很多个GS

04:47.980 --> 04:48.380
甚至呢

04:48.380 --> 04:49.180
还有个TS

04:49.180 --> 04:50.580
就是用type script写的

04:50.580 --> 04:51.780
你们以后会学习

04:51.980 --> 04:52.580
那么最终呢

04:52.580 --> 04:53.780
会合并压缩

04:53.780 --> 04:54.180
然后呢

04:54.180 --> 04:55.180
变成了一个最终的

04:55.180 --> 04:56.280
要运行的代码

04:56.780 --> 04:58.080
我们对比方说啊

04:58.080 --> 04:58.880
压缩到一个文件

04:58.880 --> 05:00.380
叫做bundle的GS里边

05:00.980 --> 05:01.780
那么这个时候呢

05:01.780 --> 05:02.880
就会产生一个问题

05:02.880 --> 05:03.580
什么问题呢

05:03.580 --> 05:04.880
就给调试啊

05:05.080 --> 05:06.080
带到困难

05:06.480 --> 05:08.480
比方说我们代码里面爆缩了

05:08.780 --> 05:09.880
是在哪里面爆了缩

05:10.280 --> 05:11.580
是不是在这里爆了缩啊

05:11.880 --> 05:13.080
是不是在这里面爆了缩

05:13.280 --> 05:15.880
那么这里边是压缩合并之后的代码

05:15.880 --> 05:17.180
那么这个时候呢

05:17.480 --> 05:18.580
你这个错误信息呢

05:18.580 --> 05:19.780
就很难调试

05:19.880 --> 05:21.380
因为错误是爆在这里边的

05:21.780 --> 05:23.680
而不是在原代码里边

05:24.180 --> 05:25.880
所以说我们这一课已经明白了

05:25.880 --> 05:26.280
对吧

05:26.380 --> 05:28.180
我们讲我们解决的问题是什么

05:28.180 --> 05:29.380
就这么一个小问题

05:29.380 --> 05:30.480
就是个调试问题

05:30.880 --> 05:32.080
当然要解决这个调试问题

05:32.080 --> 05:33.280
然后又涉及到另外一个技术

05:33.280 --> 05:33.780
但是呢

05:34.880 --> 05:35.980
你心里面要清楚

05:36.080 --> 05:36.780
就这个技术呢

05:36.780 --> 05:38.780
它的边界也就是在解决这个问题

05:39.180 --> 05:39.980
超过这个范畴

05:39.980 --> 05:41.580
他已经就跟他没关系了

05:43.180 --> 05:45.280
但是我们平时调试的时候呢

05:45.280 --> 05:46.280
更加希望

05:46.380 --> 05:46.880
什么呢

05:46.880 --> 05:48.980
希望能看到原码中的错误

05:48.980 --> 05:50.680
就是比方说某一个地方爆缩了

05:50.680 --> 05:52.180
我希望能够看到

05:52.680 --> 05:53.980
在原式代码里边

05:53.980 --> 05:55.380
比方这个代码里边爆缩了

05:55.580 --> 05:58.180
而不是希望看到在这里边爆缩

05:58.180 --> 05:59.680
因为这里边的代码太乱了

05:59.780 --> 06:00.380
比方说

06:00.380 --> 06:01.380
大家举个例子

06:01.580 --> 06:02.780
你看这个接query

06:03.280 --> 06:05.580
接query其实有很多的代码写出来的

06:05.580 --> 06:07.380
有很多的介绍你也写出来的

06:07.780 --> 06:10.180
但是他一旦和平压缩了之后

06:10.180 --> 06:11.280
就变成什么样子了呢

06:11.380 --> 06:12.380
你看这个地址啊

06:12.580 --> 06:13.580
接query你们都学过

06:14.180 --> 06:15.180
就变成这个样子

06:15.280 --> 06:16.080
你说啊

06:16.280 --> 06:18.080
比方说你是接query的编写者

06:18.080 --> 06:19.180
你要进行调试对吧

06:19.180 --> 06:20.580
你要不断的去编写

06:20.580 --> 06:21.880
不断的去测试

06:23.080 --> 06:23.980
你在调试的时候

06:23.980 --> 06:25.380
在这里边给你爆一个错误

06:25.380 --> 06:26.280
你能调试吗

06:27.280 --> 06:29.580
你完全看不懂自己这个错误是什么情况

06:29.580 --> 06:29.980
对吧

06:29.980 --> 06:31.280
你完全是看不懂的

06:31.580 --> 06:33.080
因此你希望的是

06:33.080 --> 06:35.480
他发生错误的时候发生在原代码里边

06:35.480 --> 06:37.280
而不是在转换之后的代码里边

06:38.280 --> 06:39.880
那么为了解决这个问题呢

06:40.580 --> 06:43.280
谷歌他提出了一个概念叫做sauce map

06:43.880 --> 06:44.980
而且在他的浏览器

06:44.980 --> 06:47.380
crown里边率先支持了sauce map

06:47.380 --> 06:48.480
所以他在解决什么问题

06:48.480 --> 06:49.980
他就在解决调试的问题

06:50.080 --> 06:51.480
就是和平打包之后

06:51.680 --> 06:52.780
就很难调试错误了

06:52.780 --> 06:53.880
他在解决这个问题

06:54.780 --> 06:56.580
后来其他浏览器纷纷效仿

06:56.580 --> 07:00.080
所以说目前几乎所有的新版浏览器

07:00.080 --> 07:02.180
都支持了sauce map

07:03.180 --> 07:04.780
那么说到这问大家一个问题

07:04.780 --> 07:08.180
所以说对支持的边界的理解一定要清晰

07:09.580 --> 07:10.980
那我问他一个问题

07:11.980 --> 07:12.980
sauce map

07:12.980 --> 07:14.680
那么用了这个技术过后

07:14.680 --> 07:16.180
我们现在还都还没有说这个技术

07:16.180 --> 07:16.780
怎么回事

07:17.180 --> 07:18.080
那么说sauce map

07:18.080 --> 07:19.080
用了这个技术过后

07:19.080 --> 07:20.480
会不会有兼容性问题

07:22.080 --> 07:22.680
会不会

07:23.580 --> 07:24.880
会不会造成兼容性问题

07:24.880 --> 07:26.480
是不是我们要谨慎使用它

07:27.680 --> 07:29.480
不会根本就不会

07:29.480 --> 07:30.080
为什么

07:30.980 --> 07:32.180
这东西给谁用的

07:32.280 --> 07:33.880
是不是给调试用的

07:34.080 --> 07:35.280
谁在调试

07:35.280 --> 07:36.580
拥乎会不会调试

07:37.180 --> 07:38.680
你不要拥乎上网的时候

07:38.680 --> 07:39.580
这个网页打不开

07:39.580 --> 07:40.680
打不开就直接关掉了

07:40.680 --> 07:41.880
他给你调试吗

07:41.880 --> 07:44.080
他又不耽误跟他没关系

07:44.080 --> 07:45.280
他不会调试的

07:45.480 --> 07:47.180
调试给谁是谁在调试

07:47.180 --> 07:48.680
是不是开发者来调试

07:48.980 --> 07:50.580
开发者肯定使用最新版的

07:50.580 --> 07:51.980
谷歌榴弹期

07:52.380 --> 07:53.380
这还有什么说的

07:53.780 --> 07:54.180
所以说

07:54.380 --> 07:55.180
这个东西不会有

07:55.180 --> 07:56.380
任何的兼容性问题

07:56.680 --> 07:58.180
它仅仅是为了调试用的

07:59.180 --> 08:00.180
那么这个sauce map

08:00.180 --> 08:01.180
到底是一个什么东西

08:01.180 --> 08:02.480
它实际上就是一个配置

08:02.980 --> 08:03.780
一个配置文件

08:04.480 --> 08:05.380
那么这个文件中

08:05.680 --> 08:07.680
它不仅记录了原码类种

08:07.880 --> 08:09.680
还记录了转换之后的代码的

08:09.980 --> 08:11.380
跟原码的对应关系

08:11.380 --> 08:11.780
什么意思

08:12.180 --> 08:13.780
就是我们合并之后的代码

08:14.680 --> 08:15.580
合并之后代码

08:15.780 --> 08:16.380
可能很乱

08:17.180 --> 08:18.980
那么它就会多一个文件

08:19.280 --> 08:20.180
我们看下面这张图

08:21.180 --> 08:22.380
比方说

08:22.680 --> 08:24.680
这个东西就是我们合并之后的代码

08:25.680 --> 08:26.480
合并之后的代码

08:26.480 --> 08:28.480
你看我们这里边写了一些乱七八糟的东西

08:28.480 --> 08:29.880
就表示这里边代码很乱

08:30.180 --> 08:31.980
它的代码肯定不是这个样子的

08:32.280 --> 08:33.280
肯定不是这个样子的

08:33.680 --> 08:35.680
然后在这个代码的最后一行

08:35.680 --> 08:36.680
加上一个注释

08:37.180 --> 08:38.180
这个注释给谁看的

08:38.380 --> 08:39.880
给谷歌人流烂去看的

08:40.880 --> 08:41.480
加上个注释

08:41.480 --> 08:42.680
这个注释告诉他

08:43.080 --> 08:46.180
我们的原码地图的地址在哪呢

08:46.380 --> 08:47.780
在另外一个文件里边

08:47.780 --> 08:49.580
叫bundle map

08:49.580 --> 08:50.780
当然这个名字随便取

08:50.780 --> 08:52.080
随便取什么名字都行

08:52.680 --> 08:53.580
那么告诉他

08:53.580 --> 08:55.280
我们还有一个原码地图

08:55.280 --> 08:56.380
在另外一个文件里边

08:56.680 --> 08:58.580
那么另外一个文件里边记录了啥呢

08:58.980 --> 08:59.880
它就记录了

09:00.280 --> 09:01.880
这个里边就记录了

09:01.880 --> 09:03.080
之前合并之前

09:03.080 --> 09:04.380
就代码合并之前

09:04.980 --> 09:07.080
每一个原代码是什么样子

09:07.380 --> 09:08.480
记录了原式代码

09:08.480 --> 09:09.880
所以这个文件一般会很大

09:10.380 --> 09:11.980
它里边要记录原式代码

09:12.380 --> 09:13.580
而且还要记录

09:13.780 --> 09:15.380
最终运行的是哪个代码

09:15.380 --> 09:16.680
是不是运行的是这个代码

09:17.980 --> 09:18.880
运行的是这个代码

09:19.380 --> 09:21.980
那么最终运行的代码和原代码之间

09:22.180 --> 09:23.380
它们的对应关系

09:23.380 --> 09:24.380
它就记录这个东西

09:24.580 --> 09:25.980
那么这里边到底怎么记录的

09:25.980 --> 09:26.480
无所谓

09:26.480 --> 09:27.580
跟我们没关

09:27.580 --> 09:29.480
我们就不用去深刻去理解了

09:29.480 --> 09:30.480
这里边东西还是

09:30.680 --> 09:32.480
还是有点满复杂的

09:33.380 --> 09:34.780
不过不用去理解

09:34.780 --> 09:35.680
我们只需要知道

09:35.680 --> 09:36.480
它来解决什么问题

09:36.480 --> 09:37.980
它竟然去解决条式问题

09:38.380 --> 09:39.080
它怎么来解决的

09:39.080 --> 09:40.280
就通过原码地图

09:41.280 --> 09:42.080
通过这个地图

09:42.480 --> 09:43.280
里边记录

09:43.280 --> 09:45.180
跟原式代码的对应关系

09:45.780 --> 09:47.280
那么浏览器怎么操作的呢

09:47.380 --> 09:49.780
当你用谷歌浏览器去浏览页面的时候

09:49.780 --> 09:50.980
那么运行的是哪个代码

09:50.980 --> 09:52.080
首先请求的GS

09:52.080 --> 09:54.180
肯定是最重要运行的GS

09:54.180 --> 09:55.180
肯定是这个GS

09:55.780 --> 09:56.980
看到这个GS过后

09:57.180 --> 09:58.180
谷歌浏览器一发现

09:58.880 --> 10:00.280
这里边是不是有一个什么

10:00.580 --> 10:02.280
它有一个原码地图

10:02.780 --> 10:03.180
对吧

10:03.180 --> 10:03.680
你看

10:04.180 --> 10:04.880
浏览器发现了

10:04.880 --> 10:05.780
它里边有个注释

10:05.780 --> 10:07.180
这个注释是给浏览器看的

10:07.180 --> 10:08.480
它发现有个原码地图

10:08.580 --> 10:09.080
于是

10:09.580 --> 10:12.880
谷歌浏览器它又会重新去请求原码地图

10:13.680 --> 10:14.780
去请求原码地图

10:14.780 --> 10:16.880
也就是浏览器是不是会拿到两个文件

10:16.880 --> 10:18.980
一个是要运行的GS这个文件

10:18.980 --> 10:20.680
一个是原码地图这个文件

10:21.680 --> 10:23.380
那么在后续运行的时候

10:23.380 --> 10:24.280
会怎么来操作呢

10:24.680 --> 10:26.780
比方说谷歌浏览器在运行的时候

10:26.780 --> 10:27.880
运行的是这个GS

10:27.880 --> 10:28.280
对吧

10:28.280 --> 10:30.580
运行的是最终打包后的GS

10:30.780 --> 10:31.580
那么运行的过程中

10:31.580 --> 10:32.980
比方说有一个地方爆错了

10:32.980 --> 10:34.080
那么这个错误呢

10:34.180 --> 10:36.080
如果是放到这个最终运行的GS里边

10:36.080 --> 10:37.880
就很难发现这个错误到底是啥意思

10:38.580 --> 10:39.680
看不清楚

10:39.680 --> 10:40.180
对吧

10:40.380 --> 10:41.280
比方说这里爆错了

10:41.780 --> 10:42.480
发生错误

10:42.580 --> 10:43.480
发生错误的时候

10:43.480 --> 10:44.580
它就会从原码

10:44.580 --> 10:46.580
它对应的原码地图里边去找

10:47.680 --> 10:50.080
去找找到这个对应的原码位置

10:50.080 --> 10:51.580
于是它显示的错误呢

10:51.580 --> 10:53.280
显示的不是这个位置的错误

10:53.280 --> 10:55.080
而是显示的是原码

10:55.080 --> 10:56.980
原史代码中对应位置的错误

10:56.980 --> 10:58.880
来解决条式的难度

10:59.780 --> 11:00.380
这个问题

11:00.380 --> 11:01.380
这就是原码地图

11:02.580 --> 11:03.080
好

11:03.080 --> 11:04.780
那么理解的原码地图之后呢

11:04.780 --> 11:05.480
我们来说一下

11:05.480 --> 11:07.180
原码地图平时用的时候

11:07.180 --> 11:08.580
应该怎么去用

11:09.480 --> 11:10.580
这是一个最佳实验

11:10.980 --> 11:11.680
什么最佳实验呢

11:11.680 --> 11:13.080
就是最好

11:13.080 --> 11:15.280
就最推荐大家使用的方式

11:15.680 --> 11:17.680
就是原码地图它是用来调试的

11:17.680 --> 11:18.080
对吧

11:18.080 --> 11:21.480
所以说它应该尽量在开发环境里边去使用

11:21.480 --> 11:22.880
做一种调试手段

11:22.880 --> 11:24.880
因为我们在开发圈段会不断的运行

11:24.880 --> 11:26.080
不断的去测试

11:26.080 --> 11:27.880
那么我们希望如果爆错的话

11:27.880 --> 11:29.480
报道原码的位置上去

11:30.580 --> 11:34.280
原码地图是不建议在生产环境中使用的

11:34.880 --> 11:35.380
为什么呢

11:35.380 --> 11:36.480
你想这个道理啊

11:36.480 --> 11:39.080
因为原码地图它文件比较大

11:39.080 --> 11:39.780
你看这个

11:39.780 --> 11:42.080
因为它里边要记住所有的原史代码

11:42.080 --> 11:42.780
文件比较大

11:42.780 --> 11:43.780
它没有压缩

11:43.780 --> 11:45.480
这个文件一般会比较大

11:45.480 --> 11:47.380
如果说你在生产环境里边

11:48.080 --> 11:49.880
使用了原码地图的话

11:49.880 --> 11:51.280
你看一下这张图

11:51.280 --> 11:54.080
是不是浏览器会去请求原码地图

11:54.080 --> 11:54.480
对吧

11:54.480 --> 11:56.280
那么它就会下载这个原码地图

11:56.280 --> 11:59.280
那么这个会增加网络的传输

11:59.280 --> 12:01.080
而且有了原码地图之后

12:01.080 --> 12:04.080
是不是比方说有一些懂技术的用户

12:05.080 --> 12:07.080
它在浏览里的网站

12:07.080 --> 12:08.580
已经到生产环境里边了

12:08.580 --> 12:09.880
它在浏览里的网站

12:09.880 --> 12:12.080
你把原码地图给它了

12:12.080 --> 12:13.480
那么它是不是如果说爆错了

12:13.580 --> 12:15.580
它是不是可以看到你的原代吗

12:15.580 --> 12:15.980
对吧

12:15.980 --> 12:18.180
它可以看到你的原史代码是什么样子

12:19.580 --> 12:21.280
甚至网上还有一些工具

12:21.280 --> 12:24.180
把从原史地图里边还原原代

12:24.180 --> 12:26.080
因为原史地图里边就有所有的原代

12:26.080 --> 12:27.180
都记住在里边了

12:27.180 --> 12:29.080
所以说它可以还原你的原代

12:29.080 --> 12:31.780
这样子也容易爆出你的原代

12:31.780 --> 12:34.180
当然这不是说安不安全的问题

12:34.180 --> 12:37.580
至少你的知识产权没有受到保护

12:37.580 --> 12:37.880
对吧

12:38.880 --> 12:42.680
所以说我们一般不在生产环境里边去使用它

12:42.680 --> 12:45.280
如果说你一定要在生产环境里边去使用

12:45.280 --> 12:46.080
输smap

12:46.080 --> 12:47.080
比方说什么情况了

12:48.380 --> 12:51.080
就是如果说你要调是真实的代码运行问题

12:51.080 --> 12:51.780
什么意思

12:51.780 --> 12:52.680
就是有些问题呢

12:52.680 --> 12:54.880
我在开发间上没有发现问题

12:54.880 --> 12:56.480
没有解决

12:56.480 --> 12:57.880
它爆入到生产环境里边

12:57.880 --> 12:59.480
就真正投入使用过后了

12:59.480 --> 13:00.480
除了问题

13:00.480 --> 13:03.680
那么我想知道到底是什么问题

13:03.680 --> 13:05.780
因为生产环境的跟开发环境的

13:05.780 --> 13:08.080
可能多多少少还是有点差异的

13:08.080 --> 13:10.080
因此我还是想真实的知道

13:10.080 --> 13:12.080
真实的运行环境里边到底是什么问题

13:12.080 --> 13:13.880
那么可能需要用原码地图

13:13.880 --> 13:16.880
那么也要去做出一些方式

13:16.880 --> 13:17.880
做一些处理

13:17.880 --> 13:19.680
来规避刚才我们提到的

13:19.680 --> 13:21.080
网络传达数量增加

13:21.080 --> 13:22.480
还有暴露原事代码的问题

13:22.480 --> 13:23.480
都要去规避一下

13:23.480 --> 13:24.880
你不能说完全不管

13:25.980 --> 13:27.380
所以说我们输smap

13:27.380 --> 13:29.080
尽量在开发环境里边使用

13:29.080 --> 13:31.780
尽量少在生产环境里边使用

13:31.780 --> 13:35.380
我们把它清晰的认知之后

13:35.380 --> 13:36.980
对它就没有那么恐惧了

13:36.980 --> 13:38.480
它就是为了解决调是问题的

13:38.480 --> 13:40.480
它再复杂也就是为了解决调是问题

13:41.480 --> 13:43.480
接下来我们来看一下

13:43.480 --> 13:45.480
就是我们这一刻要讲的东西了

13:45.480 --> 13:47.080
认识的原码地图之后

13:47.080 --> 13:48.080
我们在webpack里边

13:48.080 --> 13:49.480
不是经常要进行打包合并吗

13:49.480 --> 13:50.480
压缩吗

13:50.480 --> 13:52.480
那么在webpack里边

13:52.480 --> 13:54.480
怎么来使用原码地图呢

13:54.480 --> 13:57.080
那么webpack它可以使用原码地图

13:57.080 --> 13:59.080
它本身天生就支持

13:59.080 --> 14:01.080
因为webpack它要变异

14:01.080 --> 14:02.080
变异过后的代码

14:02.080 --> 14:03.080
你们都懂得对吧

14:03.080 --> 14:04.480
代码很难调识的

14:04.480 --> 14:08.080
所以说我们要通过一个配置

14:08.080 --> 14:09.080
叫dev2

14:09.080 --> 14:10.080
dev是什么意思

14:10.080 --> 14:12.680
开发tool的工具

14:12.680 --> 14:14.680
通过这个配置

14:14.680 --> 14:16.680
来优化调识体验

14:16.680 --> 14:18.680
那么它具体怎么配置呢

14:18.680 --> 14:19.680
这里有个文档

14:19.680 --> 14:21.180
就是我们学习这门课

14:21.180 --> 14:24.180
我会经常带大家来看阅读文档

14:24.180 --> 14:26.080
因为这个文档阅读也是一个

14:26.080 --> 14:28.080
全端开发者必备的一个技能

14:28.080 --> 14:30.080
我们打开这个页面

14:30.080 --> 14:31.680
我们在阅读之前

14:31.680 --> 14:33.180
我们先把工程构建一下

14:33.180 --> 14:34.680
这里呢

14:34.680 --> 14:35.680
我们找到

14:35.680 --> 14:38.700
这里

14:38.700 --> 14:40.200
special

14:42.170 --> 14:44.570
首先我们用npm

14:44.570 --> 14:45.570
初始化一下

14:45.570 --> 14:49.140
test

14:51.140 --> 14:53.140
npm i

14:53.140 --> 14:54.140
橫钢D

14:54.140 --> 14:55.140
webpack

14:55.140 --> 14:57.140
webpack cd

14:58.140 --> 15:00.140
安装一下

15:02.140 --> 15:03.140
安装吧

15:03.140 --> 15:05.140
我们在这里新建个文件夹

15:05.140 --> 15:06.140
src

15:06.140 --> 15:08.140
然后在这里边

15:08.140 --> 15:10.140
写上一些代码

15:10.140 --> 15:12.140
比如index的介绍

15:12.140 --> 15:14.140
然后再写上一个

15:14.140 --> 15:15.140
a.js

15:15.140 --> 15:16.140
写两个模块吧

15:16.140 --> 15:18.140
index的介绍里边

15:18.140 --> 15:20.140
我们去使用require

15:24.140 --> 15:25.140
然后index

15:25.140 --> 15:26.140
我们这里输出一下吧

15:26.140 --> 15:28.140
index module

15:28.140 --> 15:30.140
ind 里边我们写一些代码吧

15:30.140 --> 15:32.140
写一些代码

15:32.140 --> 15:34.140
比方说我们写上

15:34.140 --> 15:36.140
有可能会爆错的代码

15:36.140 --> 15:38.140
比方说a

15:38.140 --> 15:40.140
比方说一个obj等于now

15:40.140 --> 15:42.140
然后我们去调用obj的方法

15:42.140 --> 15:43.140
abc

15:43.140 --> 15:45.140
最后我们输出

15:45.140 --> 15:47.140
a module

15:47.140 --> 15:48.140
OK

15:48.140 --> 15:50.140
我们就写了这么一些简单的代码

15:50.140 --> 15:52.140
那么这个webpack

15:52.140 --> 15:54.140
构建好了

15:54.140 --> 15:55.140
然后我们在这里

15:55.140 --> 15:57.140
去新建一个配置文件

15:57.140 --> 16:00.140
webpack.config.js

16:00.140 --> 16:01.140
这里该怎么写

16:01.140 --> 16:03.140
marge.export

16:03.140 --> 16:04.140
导出一个对象

16:04.140 --> 16:06.140
对象里面我们写个model吧

16:06.140 --> 16:07.140
比方说开发

16:07.140 --> 16:11.860
development

16:11.860 --> 16:13.860
OK 我就不写了

16:13.860 --> 16:15.860
我这里

16:15.860 --> 16:17.860
先不着急写Dev2

16:17.860 --> 16:19.860
先不着急

16:19.860 --> 16:21.860
接下来让我们直接运行minim

16:21.860 --> 16:23.860
webpack.minim

16:23.860 --> 16:25.860
npx.webpack

16:25.860 --> 16:27.860
运行minim

16:27.860 --> 16:29.860
好 首先大家看一下

16:29.860 --> 16:31.860
看它生存的结果

16:31.860 --> 16:33.860
made.js

16:33.860 --> 16:34.860
看它生存的结果

16:34.860 --> 16:36.860
然后我们用一个页面

16:36.860 --> 16:38.860
页面去引用这个节式

16:38.860 --> 16:40.860
看一下目前它爆错

16:40.860 --> 16:42.860
它是爆在哪里的

16:42.860 --> 16:43.860
它肯定会爆错吧

16:43.860 --> 16:44.860
因为我们代码里边有错误

16:44.860 --> 16:46.860
运行

16:46.860 --> 16:48.860
点击检查

16:48.860 --> 16:50.860
那么这里刷新

16:50.860 --> 16:53.860
它告诉你有错误发生了

16:53.860 --> 16:54.860
错误发生在哪呢

16:54.860 --> 16:56.860
点击adder.js

16:56.860 --> 16:57.860
看一下

16:57.860 --> 16:59.860
那么这个东西

16:59.860 --> 17:00.860
你看看这个东西

17:00.860 --> 17:01.860
是不是跟这个代码

17:01.860 --> 17:02.860
就不太一样了

17:02.860 --> 17:04.860
这是我们最终运行的代码

17:04.860 --> 17:05.860
那么它爆错的时候

17:05.860 --> 17:06.860
为什么能够显示这个东西呢

17:06.860 --> 17:07.860
是不是之前解释过

17:07.860 --> 17:08.860
为什么

17:08.860 --> 17:10.860
因为它默认的方式

17:10.860 --> 17:12.860
是使用evil这种方式来运行的

17:12.860 --> 17:13.860
而evil这种方式

17:13.860 --> 17:14.860
你可以理解为

17:14.860 --> 17:16.860
也是一个简易版的

17:16.860 --> 17:18.860
但它不是source map

17:18.860 --> 17:20.860
是一个简易版的source map

17:20.860 --> 17:21.860
那么它在运行一个代码的时候

17:21.860 --> 17:22.860
它后面

17:22.860 --> 17:24.860
浏览器它支持一种注释

17:24.860 --> 17:25.860
后面你看

17:25.860 --> 17:26.860
是不是加了一个注释

17:26.860 --> 17:27.860
对吧

17:27.860 --> 17:28.860
加一个注释

17:28.860 --> 17:29.860
那么这个注释

17:29.860 --> 17:30.860
就告诉浏览器

17:30.860 --> 17:31.860
到时候

17:31.860 --> 17:32.860
你调试的时候

17:32.860 --> 17:34.860
你把前面的这一部分代码

17:34.860 --> 17:37.860
做一个单独的环境来调试

17:37.860 --> 17:38.860
如果是告诉浏览器的

17:38.860 --> 17:40.860
浏览器它就会

17:40.860 --> 17:41.860
但是它不会对运行

17:41.860 --> 17:42.860
产生任何的影响

17:42.860 --> 17:44.860
只是浏览器

17:44.860 --> 17:45.860
它会把

17:45.860 --> 17:46.860
再产生错误的时候

17:46.860 --> 17:47.860
再调试的时候

17:47.860 --> 17:48.860
它会把它

17:48.860 --> 17:50.860
只是显示前面

17:50.860 --> 17:51.860
只显示前面

17:51.860 --> 17:52.860
这一部分就行了

17:52.860 --> 17:53.860
你看

17:53.860 --> 17:54.860
是不是只显示前面

17:54.860 --> 17:55.860
这一部分

17:56.860 --> 17:57.860
那么这里

17:57.860 --> 17:58.860
大家也可以看到

17:58.860 --> 17:59.860
我们在浏览器里边

17:59.860 --> 18:00.860
这里有个warepack

18:00.860 --> 18:01.860
帽号两个鞋杠

18:01.860 --> 18:03.860
那么这东西哪来的

18:03.860 --> 18:04.860
就是因为它注释了

18:04.860 --> 18:06.860
前面加了这个东西

18:07.860 --> 18:09.860
它注释前面加了这个东西

18:09.860 --> 18:10.860
加了这一部分

18:10.860 --> 18:11.860
那么浏览器

18:11.860 --> 18:14.860
它就是在调试的时候

18:14.860 --> 18:16.860
它就会把这些

18:16.860 --> 18:18.860
加入到这个目录里边去

18:18.860 --> 18:20.860
其实就是说白了

18:20.860 --> 18:21.860
就是浏览器

18:21.860 --> 18:22.860
用了一种调试方式

18:22.860 --> 18:24.860
让你更加清晰的来管理代码

18:24.860 --> 18:25.860
你看一下

18:25.860 --> 18:27.860
这边展开一个SRC目录

18:27.860 --> 18:29.860
一个什么in这个色的GS

18:29.860 --> 18:30.860
你看

18:30.860 --> 18:31.860
它变成这个样子

18:31.860 --> 18:32.860
对吧

18:32.860 --> 18:33.860
我们知道

18:33.860 --> 18:34.860
它变成了warepack

18:34.860 --> 18:35.860
require

18:35.860 --> 18:36.860
这样子

18:36.860 --> 18:37.860
那么它爆出的时候

18:37.860 --> 18:38.860
它就这样爆出

18:39.860 --> 18:41.860
是不是真的有这两个文件

18:41.860 --> 18:42.860
是不是真的有

18:42.860 --> 18:43.860
并没有

18:43.860 --> 18:45.860
它只是浏览器的一种

18:45.860 --> 18:46.860
调试手段

18:46.860 --> 18:48.860
你可以通过一个注释

18:48.860 --> 18:49.860
让它把这些代码

18:49.860 --> 18:50.860
来归纳到

18:50.860 --> 18:51.860
这个位置

18:52.860 --> 18:53.860
然后让它

18:53.860 --> 18:54.860
上面那个

18:55.860 --> 18:57.860
A掉GS也是一样

18:57.860 --> 18:59.860
让把这一部分代码

18:59.860 --> 19:00.860
归纳到哪个位置

19:00.860 --> 19:02.860
归纳到这个位置

19:02.860 --> 19:03.860
明显的意思吗

19:03.860 --> 19:04.860
就这么个意思

19:04.860 --> 19:05.860
所以说这个东西

19:05.860 --> 19:06.860
其实它起什么作用

19:06.860 --> 19:07.860
它对运行有没有影响

19:07.860 --> 19:09.860
一地运地而影响都没有

19:09.860 --> 19:11.860
它仅仅是浏览器的一种

19:11.860 --> 19:12.860
调试手段而已

19:12.860 --> 19:13.860
它把它归纳到这个位置

19:13.860 --> 19:16.860
让你看起来更加方便一点

19:16.860 --> 19:17.860
它只是

19:17.860 --> 19:18.860
那么这个东西

19:18.860 --> 19:20.860
它只是给浏览器看的

19:21.860 --> 19:22.860
好

19:22.860 --> 19:23.860
那么这种

19:23.860 --> 19:24.860
这是这种方式

19:25.860 --> 19:26.860
好 接下来我们再来看

19:26.860 --> 19:27.860
如果说我打包的时候

19:27.860 --> 19:29.860
使用的是product

19:30.860 --> 19:32.860
用生产环境的打包

19:33.860 --> 19:34.860
npx

19:37.300 --> 19:38.300
运行

19:39.300 --> 19:40.300
接下来我们来看一下

19:40.300 --> 19:41.300
这边

19:41.300 --> 19:42.300
好 同样的

19:42.300 --> 19:43.300
你看看

19:43.300 --> 19:44.300
控制台

19:44.300 --> 19:45.300
什么同样的有爆错

19:45.300 --> 19:46.300
对吧

19:46.300 --> 19:47.300
然后我们来看一下

19:47.300 --> 19:48.300
它爆出的位置

19:48.300 --> 19:49.300
Madele GS

19:50.300 --> 19:52.300
你看生产环境里边

19:52.300 --> 19:53.300
它是不是就没有这样做

19:53.300 --> 19:55.300
没有用Eval的这种方式

19:55.300 --> 19:56.300
没有用Eval的这种方式

19:56.300 --> 19:58.300
它没有用这种方式来做

19:58.300 --> 20:00.300
因此生产环境里

20:00.300 --> 20:01.300
是看不到这个效果的

20:01.300 --> 20:02.300
因此生产环境里

20:02.300 --> 20:03.300
一句发现

20:03.300 --> 20:04.300
它错误爆了哪儿的

20:05.300 --> 20:06.300
它错误爆在

20:06.300 --> 20:07.300
就真实的运行了

20:07.300 --> 20:08.300
JS里边

20:08.300 --> 20:09.300
那就很难调试了

20:10.300 --> 20:11.300
你看它默认就是

20:11.300 --> 20:12.300
这样子处理的

20:12.300 --> 20:14.300
那这种行为能不能改

20:15.300 --> 20:16.300
就可以改

20:16.300 --> 20:17.300
通过什么来改

20:17.300 --> 20:19.300
通过DevTool来配置来改

20:19.300 --> 20:20.300
首先就是你要清楚

20:20.300 --> 20:21.300
这个DevTool这个配置

20:21.300 --> 20:22.300
到底要配置啥的

20:22.300 --> 20:24.300
它就是要配置这个调试的

20:24.300 --> 20:25.300
其他也没啥用

20:26.300 --> 20:27.300
那么这个DevTool

20:27.300 --> 20:28.300
有哪些配置呢

20:28.300 --> 20:29.300
多的很

20:29.300 --> 20:30.300
你看下面有个表格

20:31.300 --> 20:32.300
你看

20:32.300 --> 20:33.300
它这里

20:33.300 --> 20:34.300
其实它这里写的

20:34.300 --> 20:35.300
不是很清楚

20:35.300 --> 20:37.300
它第一个配置就是浪

20:37.300 --> 20:38.300
浪它加了两个小过号

20:38.300 --> 20:40.300
一般加了两个小过号

20:40.300 --> 20:41.300
表示它是默认配置

20:41.300 --> 20:42.300
它实际上

20:42.300 --> 20:44.300
就是生产环境下面的

20:44.300 --> 20:45.300
默认配置

20:45.300 --> 20:46.300
如果你是打包过

20:46.300 --> 20:47.300
结果是要在

20:47.300 --> 20:48.300
生产环境运行的话

20:48.300 --> 20:49.300
它默认就是浪

20:49.300 --> 20:50.300
浪是什么意思

20:51.300 --> 20:52.300
来看一下

20:53.300 --> 20:54.300
DevTool配置

20:54.300 --> 20:55.300
不可以配置

20:55.300 --> 20:56.300
把它配置为浪

20:56.300 --> 20:57.300
浪是什么意思呢

20:57.300 --> 20:58.300
浪就是

20:59.300 --> 21:00.300
直接就是打包后的代码

21:00.300 --> 21:01.300
什么叫打包后的代码

21:01.300 --> 21:02.300
我们下面有解释

21:02.300 --> 21:03.300
这些东西都有解释的

21:04.300 --> 21:05.300
它就将所生成的代码

21:05.300 --> 21:06.300
视为一大扩代码

21:06.300 --> 21:08.300
你看不到相互分解的模块

21:08.300 --> 21:09.300
这个翻译过来

21:09.300 --> 21:10.300
就不是人话了

21:10.300 --> 21:11.300
什么意思呢

21:11.300 --> 21:12.300
它就是说

21:12.300 --> 21:14.300
没有原码地图

21:14.300 --> 21:16.300
就没有任何原码地图

21:16.300 --> 21:17.300
就是没有任何

21:17.300 --> 21:19.300
就是对这个调试

21:19.300 --> 21:20.300
起任何作用

21:20.300 --> 21:21.300
没有任何的代码

21:21.300 --> 21:23.300
对调试起任何作用

21:23.300 --> 21:24.300
所以这就是浪

21:24.300 --> 21:25.300
不调试

21:25.300 --> 21:27.300
不用去对调试

21:27.300 --> 21:28.300
对调试做特殊处理

21:28.300 --> 21:30.300
那么就直接在原码里

21:30.300 --> 21:31.300
不要爆出

21:31.300 --> 21:33.300
那么浪的这个结果

21:33.300 --> 21:34.300
默认生产环境

21:34.300 --> 21:35.300
就是浪这个结果

21:35.300 --> 21:36.300
那如果说

21:36.300 --> 21:38.300
我们直接手动把它配置为浪

21:38.300 --> 21:40.300
那么现在我们再把它改为

21:40.300 --> 21:41.300
Development

21:41.300 --> 21:45.080
你看一下

21:45.080 --> 21:46.080
WePack

21:46.080 --> 21:47.080
你看

21:47.080 --> 21:48.080
那么这样子一来

21:48.080 --> 21:49.080
都想让得到

21:49.080 --> 21:51.080
那么现在开发环境里

21:51.080 --> 21:52.080
是不是也没了

21:52.080 --> 21:53.080
对吧

21:53.080 --> 21:54.080
是不是也没了

21:54.080 --> 21:55.080
你看一下Made.js

21:55.080 --> 21:56.080
现在再看

21:56.080 --> 21:57.080
那么现在Made.js里

21:57.080 --> 21:58.080
是不是就没有把它

21:58.080 --> 21:59.080
放到Eva环境里

21:59.080 --> 22:00.080
你看

22:00.080 --> 22:01.080
是不是就没有放到

22:01.080 --> 22:02.080
Eva环境里面了

22:02.080 --> 22:03.080
对吧

22:03.080 --> 22:04.080
好

22:04.080 --> 22:05.080
咱们现在看一下

22:06.080 --> 22:07.080
它爆错了

22:07.080 --> 22:08.080
爆错爆到哪呢

22:08.080 --> 22:09.080
你看是不爆在这的

22:09.080 --> 22:10.080
对吧

22:10.080 --> 22:11.080
是爆在这的

22:11.080 --> 22:13.080
它就没有在Eva里面了

22:13.080 --> 22:14.080
也就是它

22:14.080 --> 22:15.080
不做任何的特殊控制

22:15.080 --> 22:17.080
这就是浪

22:17.080 --> 22:18.080
好

22:18.080 --> 22:19.080
另外一个叫做Eva

22:19.080 --> 22:20.080
Eva是什么呢

22:20.080 --> 22:21.080
默认

22:21.080 --> 22:23.080
如果说你打包环境

22:23.080 --> 22:25.080
默认是开发环境的话

22:25.080 --> 22:27.080
它默认就是Eva

22:27.080 --> 22:28.080
那么我们来看一下

22:28.080 --> 22:30.080
它变成生产环境

22:30.080 --> 22:32.080
然后把它变成Eva

22:32.080 --> 22:33.080
包存

22:33.080 --> 22:34.080
你看一下

22:34.080 --> 22:35.080
因为爆错

22:35.080 --> 22:36.080
有爆错

22:36.080 --> 22:38.080
那么点进去看一下

22:40.080 --> 22:41.080
这里没打包

22:41.080 --> 22:42.080
没重新打包

22:43.080 --> 22:44.080
打包一下

22:45.080 --> 22:46.080
把它变成Production

22:46.080 --> 22:48.080
然后Dev2变成Eva

22:49.080 --> 22:50.080
好

22:50.080 --> 22:51.080
那么现在再看一下

22:51.080 --> 22:52.080
有没有爆错

22:52.080 --> 22:53.080
有爆错

22:53.080 --> 22:54.080
点击

22:54.080 --> 22:55.080
是不是还在A.js里面

22:55.080 --> 22:56.080
对吧

22:56.080 --> 22:57.080
是不是还在这里面

22:57.080 --> 22:59.080
并没有爆在原码里面

22:59.080 --> 23:01.080
那么你看一下生产环境里面

23:01.080 --> 23:02.080
在生产环境里面

23:02.080 --> 23:03.080
它仍然用到了Eva

23:03.080 --> 23:04.080
肯定的

23:04.080 --> 23:05.080
这是一定的

23:05.080 --> 23:06.080
你看

23:06.080 --> 23:07.080
是不是还是用到了Eva

23:07.080 --> 23:08.080
后面加成个SourceUI

23:08.080 --> 23:10.080
就这么个意思

23:10.080 --> 23:12.080
那么它下面还有很多很多的配置

23:12.080 --> 23:14.080
超级多的配置

23:14.080 --> 23:15.080
每一种配置

23:15.080 --> 23:17.080
它有一个构建速度

23:17.080 --> 23:18.080
就打包速度

23:18.080 --> 23:19.080
还有一个重新构建速度

23:19.080 --> 23:20.080
什么叫重新构建速度

23:20.080 --> 23:21.080
就是你监控

23:21.080 --> 23:22.080
通过Watch

23:22.080 --> 23:23.080
我们之前知道

23:23.080 --> 23:24.080
一个Watch

23:24.080 --> 23:25.080
那么这个Watch

23:25.080 --> 23:27.080
其实也可以到这里边配置

23:27.080 --> 23:28.080
比方说这里

23:28.080 --> 23:29.080
Watch

23:29.080 --> 23:31.080
WatchV2

23:31.080 --> 23:33.080
也可以进行配置

23:33.080 --> 23:35.080
那么当文件改变的时候

23:35.080 --> 23:36.080
它会重新构建

23:36.080 --> 23:37.080
那么速度

23:37.080 --> 23:39.080
用加越多的话

23:39.080 --> 23:40.080
就表示构建速度越快

23:40.080 --> 23:41.080
就打包速度越快

23:41.080 --> 23:42.080
也就是说什么呢

23:42.080 --> 23:43.080
就是说运行命令的时候

23:43.080 --> 23:45.080
它打包的速度就越快

23:46.080 --> 23:48.080
如果说出现了这个减的话

23:48.080 --> 23:49.080
出现这个减的话

23:49.080 --> 23:51.080
那么打包的速度就越慢

23:51.080 --> 23:52.080
下面有解释

23:52.080 --> 23:53.080
放大一点

23:53.080 --> 23:55.080
加加加表示非常快

23:55.080 --> 23:56.080
加加自己去看

23:56.080 --> 23:57.080
自己去看

23:57.080 --> 23:59.080
每一种配置的方式

23:59.080 --> 24:00.080
它结果不一样

24:00.080 --> 24:02.080
那么也会影响它的速度

24:02.080 --> 24:04.080
当然这个速度

24:04.080 --> 24:05.080
不是执行速度

24:05.080 --> 24:06.080
只是打包速度

24:06.080 --> 24:08.080
只是构建速度

24:09.080 --> 24:10.080
跟这个最终代码

24:10.080 --> 24:11.080
执行没有什么关系

24:11.080 --> 24:13.080
那么后边打包的

24:13.080 --> 24:15.080
结果是什么样子的呢

24:15.080 --> 24:16.080
它后边有解释

24:16.080 --> 24:17.080
打包后的代码

24:17.080 --> 24:18.080
什么代码

24:18.080 --> 24:19.080
到底是什么意思

24:19.080 --> 24:20.080
下面去看

24:20.080 --> 24:22.080
那么这里我要说的

24:22.080 --> 24:23.080
我这里要一个一个去讲

24:23.080 --> 24:24.080
这个东西没必要

24:24.080 --> 24:25.080
因为它仅仅是

24:25.080 --> 24:26.080
影响的范围很窄

24:26.080 --> 24:27.080
它仅仅是影响一个条式

24:27.080 --> 24:28.080
那么我们只说一下

24:28.080 --> 24:30.080
它的最佳时间就行了

24:30.080 --> 24:32.080
它下面有

24:32.080 --> 24:34.080
它说你对于开发环境

24:34.080 --> 24:35.080
你应该去怎么去配

24:35.080 --> 24:37.080
对于生产环境

24:37.080 --> 24:38.080
应该怎么去配

24:38.080 --> 24:39.080
那么我们来看一下

24:39.080 --> 24:40.080
什么特殊场景

24:40.080 --> 24:41.080
我们就不用去管了

24:41.080 --> 24:43.080
对于开发环境

24:43.080 --> 24:44.080
它建议你呢

24:44.080 --> 24:46.080
在这四个配置中选一个

24:46.080 --> 24:47.080
一个是Evo

24:48.080 --> 24:49.080
开发环境下面

24:49.080 --> 24:50.080
默正就是Evo

24:50.080 --> 24:51.080
就是这个东西

24:51.080 --> 24:53.080
Development

24:53.080 --> 24:55.080
Ve

24:55.080 --> 24:58.080
Development

24:58.080 --> 24:59.080
默正就是Evo

24:59.080 --> 25:00.080
当然你不配置也可以

25:00.080 --> 25:01.080
情况一下

25:01.080 --> 25:02.080
NPS

25:02.080 --> 25:03.080
NPS

25:03.080 --> 25:04.080
WePad

25:05.080 --> 25:06.080
你看看

25:06.080 --> 25:07.080
默正情况下

25:07.080 --> 25:08.080
就是最早那个情况

25:08.080 --> 25:09.080
对吧

25:09.080 --> 25:10.080
就是最早

25:10.080 --> 25:11.080
早期那个情况

25:11.080 --> 25:12.080
就是Evo

25:12.080 --> 25:13.080
那么这种情况

25:13.080 --> 25:14.080
它告诉你

25:14.080 --> 25:15.080
每一个就是

25:15.080 --> 25:16.080
每一个模块的代码

25:16.080 --> 25:17.080
它都把它放到

25:17.080 --> 25:18.080
Evo里边去执行

25:18.080 --> 25:19.080
并且都带有这个东西

25:19.080 --> 25:20.080
SourceUIL

25:21.080 --> 25:22.080
这个地方写

25:22.080 --> 25:23.080
锦号也可以写

25:23.080 --> 25:24.080
Eta也可以

25:24.080 --> 25:25.080
那么这个持选项

25:25.080 --> 25:27.080
它的特点是

25:27.080 --> 25:28.080
构建速度会非常快

25:28.080 --> 25:29.080
你看上面的

25:29.080 --> 25:30.080
就是对比一下

25:30.080 --> 25:31.080
上面的速度

25:31.080 --> 25:32.080
你看是不是

25:32.080 --> 25:33.080
非常快 构建速度

25:33.080 --> 25:34.080
因为它并没有增加

25:34.080 --> 25:35.080
很多的东西

25:35.080 --> 25:36.080
它就是把原码

25:36.080 --> 25:37.080
放到Evo里边就完事了

25:37.080 --> 25:38.080
后面加上一个

25:38.080 --> 25:39.080
注释SourceUIL

25:40.080 --> 25:41.080
但是它缺点在哪呢

25:41.080 --> 25:43.080
缺点它并不能完全

25:43.080 --> 25:44.080
反映

25:46.080 --> 25:47.080
原世代

25:47.080 --> 25:48.080
它映射的是

25:48.080 --> 25:49.080
什么

25:49.080 --> 25:50.080
转换后的代码

25:50.080 --> 25:51.080
而不是原世代码

25:51.080 --> 25:52.080
什么意思呢

25:52.080 --> 25:53.080
大家看一下

25:53.080 --> 25:54.080
它有缺点

25:54.080 --> 25:55.080
它有缺点

25:55.080 --> 25:56.080
它也有缺点

25:56.080 --> 25:57.080
比方我们这里

25:57.080 --> 25:58.080
就用的是什么呢

25:58.080 --> 25:59.080
Evo对吧

25:59.080 --> 26:00.080
用的是Evo

26:00.080 --> 26:01.080
那么看一下

26:01.080 --> 26:02.080
它生成的就是

26:02.080 --> 26:03.080
这个东西

26:03.080 --> 26:04.080
你看A2JS

26:04.080 --> 26:05.080
好像是一样的

26:05.080 --> 26:06.080
不就是原码吗

26:06.080 --> 26:07.080
对吧

26:07.080 --> 26:08.080
但是你看

26:08.080 --> 26:09.080
英德克斯的JS

26:09.080 --> 26:10.080
这个玩意

26:10.080 --> 26:11.080
是不是我们写的代码

26:11.080 --> 26:12.080
并不是说

26:12.080 --> 26:13.080
我们写的是什么代码

26:13.080 --> 26:14.080
我们写的是这个代码

26:14.080 --> 26:16.080
require.a

26:16.080 --> 26:17.080
但是它变成了

26:17.080 --> 26:18.080
这样子

26:18.080 --> 26:19.080
有些同学说

26:19.080 --> 26:20.080
这个东西也不影响

26:20.080 --> 26:21.080
那是我们目前的东西

26:21.080 --> 26:23.080
学的知识还不多

26:23.080 --> 26:25.080
以后我们可以看到

26:25.080 --> 26:26.080
其实这个转

26:26.080 --> 26:27.080
这就叫做

26:27.080 --> 26:28.080
转换后的代码

26:28.080 --> 26:29.080
它把我们真实的

26:29.080 --> 26:30.080
原代码过后

26:30.080 --> 26:31.080
就会进行转换

26:31.080 --> 26:32.080
转换后的代码

26:32.080 --> 26:33.080
每个模块

26:33.080 --> 26:34.080
转换后的代码

26:34.080 --> 26:35.080
它可能

26:35.080 --> 26:37.080
以后可能会差异比较大

26:37.080 --> 26:38.080
但是如果说

26:38.080 --> 26:39.080
你这个东西

26:39.080 --> 26:40.080
能接受的话

26:40.080 --> 26:41.080
那么这个配置

26:41.080 --> 26:42.080
还是非常不错的

26:42.080 --> 26:43.080
因为它构建速度

26:43.080 --> 26:44.080
会非常快

26:44.080 --> 26:45.080
它有没有别的呢

26:45.080 --> 26:46.080
再看下面这个

26:46.080 --> 26:47.080
它说

26:47.080 --> 26:49.080
Evo Source Map

26:49.080 --> 26:50.080
它建议你的开发环境

26:50.080 --> 26:52.080
也可以用这个

26:52.080 --> 26:53.080
咱们用一下这个

26:53.080 --> 26:55.080
用一下看一下再说

26:56.080 --> 26:57.080
这里

26:57.080 --> 26:58.080
我们在微Pack里边

26:58.080 --> 26:59.080
Corepack里边

26:59.080 --> 27:00.080
这里选择这个

27:02.080 --> 27:03.080
然后我们再运行

27:04.080 --> 27:05.080
看一下

27:06.080 --> 27:07.080
运行完了

27:08.080 --> 27:09.080
那么你看一下

27:09.080 --> 27:10.080
它体积是不是增加了

27:10.080 --> 27:12.080
之前是4.13K

27:12.080 --> 27:14.080
现在是4.88K

27:14.080 --> 27:15.080
体积增加了

27:15.080 --> 27:16.080
那么这个构建速度

27:16.080 --> 27:17.080
肯定是没有Evo快的

27:17.080 --> 27:18.080
上面

27:18.080 --> 27:19.080
前面你可以对比

27:19.080 --> 27:20.080
这个文档你要会看

27:20.080 --> 27:21.080
前面你可以去对比

27:21.080 --> 27:22.080
Evo Source Map

27:22.080 --> 27:23.080
你看

27:23.080 --> 27:24.080
是不是速度比较慢

27:24.080 --> 27:25.080
但是重新构建的速度

27:25.080 --> 27:26.080
还可以

27:26.080 --> 27:28.080
那么这种方式又是什么呢

27:29.080 --> 27:31.080
它是把原码地图

27:32.080 --> 27:33.080
用一种编码方式

27:33.080 --> 27:35.080
直接放到哪呢

27:35.080 --> 27:37.080
它不作为一个单独的文件

27:37.080 --> 27:38.080
直接放到

27:38.080 --> 27:39.080
生存的结果里边

27:39.080 --> 27:40.080
你看一下

27:40.080 --> 27:41.080
现在这个结果

27:41.080 --> 27:42.080
这是我们自己写的代码

27:42.080 --> 27:43.080
对吧

27:43.080 --> 27:44.080
我们自己写的代码

27:44.080 --> 27:45.080
之后呢

27:45.080 --> 27:46.080
后边有个Source URL

27:46.080 --> 27:47.080
然后呢

27:47.080 --> 27:48.080
一个Source Mapping URL

27:48.080 --> 27:50.080
这就是对应原码地图了

27:50.080 --> 27:51.080
原码地图

27:51.080 --> 27:52.080
它用了什么方式呢

27:52.080 --> 27:53.080
它用的是这种方式

27:54.080 --> 27:56.080
Base64编码

27:56.080 --> 27:57.080
你们知道图片是可以

27:57.080 --> 27:59.080
Base64编码对吧

27:59.080 --> 28:00.080
那么很多文件都可以进行

28:00.080 --> 28:01.080
Base64编码

28:01.080 --> 28:03.080
那么它是把原码地图里边的东西

28:03.080 --> 28:04.080
用Base64编码

28:04.080 --> 28:06.080
生存很常用的东西

28:06.080 --> 28:07.080
所以放到这

28:07.080 --> 28:08.080
下面也是一样

28:08.080 --> 28:10.080
但是这个东西到底有多少

28:10.080 --> 28:12.080
跟Base64编码过合到底有多少

28:12.080 --> 28:14.080
取决于我们原式代码有多少

28:14.080 --> 28:15.080
总之它生存这个东西

28:15.080 --> 28:16.080
放到这

28:16.080 --> 28:17.080
也就是它把原码地图

28:17.080 --> 28:19.080
就签到了这个JS里边

28:19.080 --> 28:21.080
它没有作为单独的文件

28:21.080 --> 28:23.080
不像我们之前分析的那样子

28:23.080 --> 28:24.080
原码地图呢

28:24.080 --> 28:25.080
它可以作为单独的文件

28:25.080 --> 28:26.080
它其实也可以用这种方式

28:26.080 --> 28:27.080
签入进去

28:27.080 --> 28:28.080
它怎么签入进去的

28:28.080 --> 28:29.080
不用管

28:29.080 --> 28:30.080
我们只需要知道它

28:30.080 --> 28:32.080
这个地方就是原码地图

28:32.080 --> 28:33.080
然后我们再看一下

28:34.080 --> 28:35.080
刷新

28:35.080 --> 28:36.080
现在我们再看一下

28:36.080 --> 28:38.080
这个WayPike

28:38.080 --> 28:39.080
SRC

28:39.080 --> 28:40.080
你看

28:40.080 --> 28:41.080
ADLJS里边

28:41.080 --> 28:42.080
没问题

28:42.080 --> 28:43.080
应这个程度要接视的

28:43.080 --> 28:44.080
所以原式代码

28:45.080 --> 28:47.080
它就反映到原式代码里边去了

28:48.080 --> 28:49.080
这就是

28:49.080 --> 28:51.080
这种配置

28:52.080 --> 28:54.080
然后它下面还有建议

28:54.080 --> 28:56.080
我再举一个例子就行了

28:56.080 --> 28:57.080
因为我们这些课

28:57.080 --> 28:58.080
并不是说

28:58.080 --> 28:59.080
要告诉大家

28:59.080 --> 29:00.080
一定要用哪一个

29:00.080 --> 29:02.080
把每一个拿出来分析

29:02.080 --> 29:04.080
不会有这种讲课方式的

29:04.080 --> 29:05.080
讲课方式你一定是

29:05.080 --> 29:06.080
理解它的原理

29:06.080 --> 29:07.080
理解它的支持边界

29:07.080 --> 29:08.080
然后

29:09.080 --> 29:10.080
适当的时候

29:10.080 --> 29:11.080
该用什么

29:11.080 --> 29:12.080
以后你内在开发中

29:12.080 --> 29:14.080
该用什么去查阅文档

29:14.080 --> 29:16.080
这一定是正确的开发方式

29:16.080 --> 29:18.080
不是说我们要使机硬背

29:18.080 --> 29:19.080
把所有的支持全部记住

29:19.080 --> 29:20.080
你记不住的

29:20.080 --> 29:21.080
我这里一块也说了过

29:21.080 --> 29:22.080
你马上就忘了

29:22.080 --> 29:23.080
不要说你误了

29:23.080 --> 29:24.080
我都马上就忘了

29:24.080 --> 29:25.080
我需要去记它吗

29:25.080 --> 29:27.080
我根本不需要去记它

29:27.080 --> 29:28.080
我只需要知道

29:28.080 --> 29:29.080
它的原理是什么

29:29.080 --> 29:30.080
然后

29:30.080 --> 29:31.080
我需要用到的时候

29:31.080 --> 29:32.080
去查阅文档

29:32.080 --> 29:33.080
好

29:33.080 --> 29:34.080
咱们来看下一个

29:35.080 --> 29:36.080
CHIP

29:36.080 --> 29:37.080
Evo Source Map

29:37.080 --> 29:38.080
其实

29:38.080 --> 29:39.080
这些东西不用去背

29:39.080 --> 29:41.080
我们就了解一下就行了

29:41.080 --> 29:42.080
它什么意思呢

29:42.080 --> 29:43.080
它说它类似于

29:43.080 --> 29:44.080
Evo Source Map

29:44.080 --> 29:45.080
跟它差不多

29:45.080 --> 29:47.080
只不过

29:47.080 --> 29:48.080
它是低开销的

29:48.080 --> 29:49.080
它开销更加低

29:49.080 --> 29:51.080
它构建速度更加快

29:53.080 --> 29:54.080
我们比方说用它

29:54.080 --> 29:55.080
用它

29:55.080 --> 29:56.080
复制一下

29:57.080 --> 29:58.080
用它

29:59.080 --> 30:00.080
到这边来

30:00.080 --> 30:01.080
改一下

30:01.080 --> 30:02.080
用它

30:02.080 --> 30:03.080
你看

30:04.080 --> 30:05.080
我们npx

30:05.080 --> 30:06.080
vpec

30:07.080 --> 30:08.080
那么这样

30:08.080 --> 30:09.080
用了它之后

30:09.080 --> 30:10.080
它有什么样的

30:10.080 --> 30:11.080
特点呢

30:11.080 --> 30:12.080
它是

30:12.080 --> 30:13.080
因为我们知道

30:13.080 --> 30:14.080
Source Map 这个文件

30:14.080 --> 30:15.080
它这个配置

30:15.080 --> 30:18.080
它会把最终运行的代码

30:18.080 --> 30:20.080
它会去对应我们的元代

30:20.080 --> 30:21.080
对吧

30:21.080 --> 30:22.080
你最终运行的

30:22.080 --> 30:23.080
哪个位置

30:23.080 --> 30:24.080
对应我元代码的

30:24.080 --> 30:25.080
第几行

30:25.080 --> 30:26.080
就是这样子去映射

30:26.080 --> 30:27.080
那么它这种方式

30:27.080 --> 30:29.080
它只映射行

30:29.080 --> 30:31.080
它不映射力

30:31.080 --> 30:32.080
它不映射力

30:32.080 --> 30:33.080
它就是

30:33.080 --> 30:34.080
每一行代码

30:34.080 --> 30:35.080
它给你映射过

30:35.080 --> 30:36.080
它不映射力

30:36.080 --> 30:37.080
它就映射要少一些

30:37.080 --> 30:38.080
就是这么个意思

30:38.080 --> 30:39.080
它只映射行的数量

30:39.080 --> 30:40.080
它不映射力

30:40.080 --> 30:41.080
因此

30:41.080 --> 30:42.080
它的开销要少一些

30:42.080 --> 30:43.080
当然

30:43.080 --> 30:44.080
它的爆错的位置

30:44.080 --> 30:45.080
就没有它那么准确了

30:45.080 --> 30:47.080
没有让它那么精确了

30:47.080 --> 30:48.080
所以说

30:48.080 --> 30:49.080
有可能

30:49.080 --> 30:50.080
就是在同一行的代码里面

30:50.080 --> 30:51.080
爆了

30:51.080 --> 30:52.080
这一行的代码很长

30:52.080 --> 30:53.080
它可能

30:53.080 --> 30:54.080
爆了一个错误

30:54.080 --> 30:55.080
那个错误的位置

30:55.080 --> 30:56.080
它就不知道在哪了

30:56.080 --> 30:57.080
它只能告诉你

30:57.080 --> 30:58.080
这一行有个错误

30:58.080 --> 30:59.080
但是它准确的位置

30:59.080 --> 31:00.080
在哪它就不知道了

31:01.080 --> 31:02.080
会形成这么一个现象

31:02.080 --> 31:03.080
这就是

31:04.080 --> 31:05.080
那么

31:05.080 --> 31:06.080
它也可以

31:06.080 --> 31:07.080
它也可以

31:07.080 --> 31:08.080
它现在也爆错了

31:09.080 --> 31:10.080
但是我们目前

31:10.080 --> 31:11.080
因为这一行

31:11.080 --> 31:12.080
只有这么一点代码

31:12.080 --> 31:13.080
所以说

31:13.080 --> 31:14.080
看了不是很明显

31:14.080 --> 31:15.080
它只能告诉你

31:15.080 --> 31:16.080
哪一行出错了

31:16.080 --> 31:17.080
它不知道列在哪里

31:17.080 --> 31:18.080
这一行的哪一个位置出错了

31:18.080 --> 31:19.080
它不知道

31:19.080 --> 31:20.080
这是这个

31:23.080 --> 31:24.080
这就是我们开发环境

31:24.080 --> 31:25.080
它建议你用什么

31:25.080 --> 31:26.080
它说

31:26.080 --> 31:27.080
建议你说

31:27.080 --> 31:28.080
它说

31:28.080 --> 31:29.080
建议在生产环境里边

31:29.080 --> 31:30.080
使用这个东西

31:30.080 --> 31:31.080
因为它在生产环境里边

31:31.080 --> 31:33.080
有最佳品质的SourceMap

31:33.080 --> 31:35.080
它既能够准确的

31:35.080 --> 31:36.080
对应原代

31:36.080 --> 31:37.080
而且

31:37.080 --> 31:38.080
又能够

31:39.080 --> 31:41.080
把行和列的错误都给你

31:41.080 --> 31:42.080
准确的定位到

31:42.080 --> 31:43.080
而且

31:43.080 --> 31:45.080
文件的体积也不会太大

31:45.080 --> 31:46.080
它建议你在生产环境

31:46.080 --> 31:47.080
就是开发环境里边

31:47.080 --> 31:48.080
使用这个

31:49.080 --> 31:50.080
那么有些人就说

31:50.080 --> 31:51.080
我想真的是

31:51.080 --> 31:52.080
想看一下这个SourceMap

31:52.080 --> 31:53.080
这个文件

31:53.080 --> 31:54.080
这个文件

31:54.080 --> 31:55.080
不是说之前有

31:55.080 --> 31:56.080
单独一个文件吗

31:56.080 --> 31:57.080
可不可以呢

31:57.080 --> 31:58.080
可以

31:58.080 --> 31:59.080
你可以去找一下

31:59.080 --> 32:00.080
它前面的配置

32:00.080 --> 32:01.080
它有一个就是叫做

32:01.080 --> 32:02.080
SourceMap这个配置

32:02.080 --> 32:03.080
那么它的速度就很慢了

32:03.080 --> 32:05.080
因为它单独生成文件

32:06.080 --> 32:07.080
我们看一下吧

32:08.080 --> 32:09.080
我们在这里

32:09.080 --> 32:10.080
比方说我们这里

32:10.080 --> 32:11.080
写成一个SourceMap

32:12.080 --> 32:13.080
SourceMap

32:14.080 --> 32:15.080
好

32:15.080 --> 32:17.650
然后生成一次

32:17.650 --> 32:18.650
好 你看

32:18.650 --> 32:19.650
是不是多了一个文件

32:19.650 --> 32:20.650
Map

32:20.650 --> 32:21.650
Media.js.map

32:21.650 --> 32:23.650
然后我们的Media.js里边

32:23.650 --> 32:24.650
你看

32:24.650 --> 32:25.650
它就是正常代码了

32:25.650 --> 32:26.650
这些都是正常代码

32:26.650 --> 32:28.650
就转换后的正常代码

32:29.650 --> 32:30.650
然后呢

32:30.650 --> 32:31.650
一个注释你看

32:31.650 --> 32:32.450
两个鞋杠

32:32.450 --> 32:33.650
锦号SourceMap URL

32:33.650 --> 32:34.650
我们的SourceMap

32:34.650 --> 32:36.650
就是我们的原码地图在哪呢

32:36.650 --> 32:37.650
在这个文件

32:37.650 --> 32:38.650
你看一下跟我们刚才

32:38.650 --> 32:39.650
解释的是不一样的

32:39.650 --> 32:40.650
对吧

32:40.650 --> 32:41.650
是不是一样的

32:41.650 --> 32:42.650
好

32:42.650 --> 32:43.650
这个文件名字

32:43.650 --> 32:44.650
无所谓的

32:44.650 --> 32:45.650
它默认就是这样的

32:45.650 --> 32:46.650
就是后面加一个Map

32:46.650 --> 32:47.650
作为文件名

32:47.650 --> 32:48.650
好 接下来

32:48.650 --> 32:49.650
我们来看一下

32:49.650 --> 32:50.650
网络请求刷新

32:51.650 --> 32:52.650
这里

32:52.650 --> 32:55.280
强制刷新

32:57.280 --> 32:58.280
这里看不到

32:58.280 --> 32:59.280
这个SourceMap

32:59.280 --> 33:00.280
在这里看不到

33:00.280 --> 33:01.280
这里看不到

33:01.280 --> 33:02.280
实际上

33:02.280 --> 33:03.280
它有没有去请求SourceMap

33:03.280 --> 33:04.280
肯定是有的

33:04.280 --> 33:05.280
这个行为一问的

33:05.280 --> 33:07.280
肯定是有请求SourceMap

33:07.280 --> 33:08.280
只不过在这里

33:08.280 --> 33:09.280
它不给你显示出来

33:09.280 --> 33:10.280
然后呢

33:10.280 --> 33:11.280
我们来看一下

33:11.280 --> 33:12.280
那么现在呢

33:12.280 --> 33:13.280
我们到点击错误

33:13.280 --> 33:14.280
是不是还是发生在这

33:14.280 --> 33:15.280
然后呢

33:15.280 --> 33:16.280
在这边

33:17.280 --> 33:18.280
你看

33:18.280 --> 33:19.280
看到了就是完整的元代

33:19.280 --> 33:20.280
对吧

33:20.280 --> 33:21.280
看到就是完整的元代

33:22.280 --> 33:23.280
而且呢

33:23.280 --> 33:24.280
还可以看到这个

33:25.280 --> 33:26.280
它生成出来的代码

33:26.280 --> 33:27.280
也可以看得到的

33:27.280 --> 33:28.280
它全部

33:28.280 --> 33:30.280
就完整的给你对应起来

33:32.280 --> 33:33.280
当然这个东西

33:33.280 --> 33:34.280
效率太低了

33:34.280 --> 33:35.280
我们一般

33:35.280 --> 33:36.280
不太会去使用它

33:36.280 --> 33:37.280
好

33:37.280 --> 33:38.280
接下来我们再看

33:38.280 --> 33:39.280
如果说是生产环境的

33:39.280 --> 33:40.280
不是开放环境的

33:40.280 --> 33:41.280
是生产环境

33:41.280 --> 33:42.280
它建议你利用什么呢

33:42.280 --> 33:43.280
第一个

33:43.280 --> 33:44.280
它说

33:44.280 --> 33:45.280
你就直接使用默认值

33:45.280 --> 33:46.280
就不要去生成SourceMap

33:46.280 --> 33:47.280
它说这是一个

33:47.280 --> 33:48.280
非常不错的选择

33:49.280 --> 33:50.280
另外呢

33:50.280 --> 33:51.280
如果说你一定要在

33:51.280 --> 33:52.280
生产环境中

33:52.280 --> 33:53.280
去生成SourceMap

33:53.280 --> 33:55.280
就是你可能要去

33:55.280 --> 33:56.280
调是生产环境里边的

33:56.280 --> 33:57.280
一些真实的错误

33:57.280 --> 33:59.280
那么这个时候呢

33:59.280 --> 34:00.280
它都是有一些建议的

34:00.280 --> 34:02.280
第一个建议呢就是

34:02.280 --> 34:03.280
SourceMap

34:03.280 --> 34:04.280
你可以生产

34:04.280 --> 34:05.280
就直接使用这个

34:05.280 --> 34:06.280
我们这个配置

34:06.280 --> 34:07.280
就使用这个配置

34:08.280 --> 34:09.280
SourceMap

34:09.280 --> 34:10.280
可不可以生产

34:10.280 --> 34:11.280
可以生产

34:11.280 --> 34:12.280
有人说

34:12.280 --> 34:13.280
不对吧

34:13.280 --> 34:14.280
为什么这样子建议呢

34:14.280 --> 34:15.280
它不是说生产的SourceMap

34:15.280 --> 34:17.280
它构建速度慢吗

34:17.280 --> 34:19.280
注意是构建速度慢

34:19.280 --> 34:21.280
并不是运行速度慢

34:21.280 --> 34:22.280
有人说

34:22.280 --> 34:23.280
也不对啊

34:23.280 --> 34:24.280
它不是

34:24.280 --> 34:25.280
你这样子生产的SourceMap过后

34:25.280 --> 34:26.280
流浪器不会去

34:26.280 --> 34:28.280
多请求一个文件吗

34:28.280 --> 34:29.280
那么这样子

34:29.280 --> 34:31.280
额外的开销啊

34:31.280 --> 34:32.280
对不对

34:32.280 --> 34:33.280
想得有道理

34:33.280 --> 34:34.280
因此他后边怎么说的

34:34.280 --> 34:35.280
他说的是

34:35.280 --> 34:37.280
如果说你这样做了过后呢

34:40.280 --> 34:42.280
你应该将你的服务器

34:42.280 --> 34:44.280
就是因为我们生产环境社

34:44.280 --> 34:45.280
把它上传到服务器的

34:45.280 --> 34:47.280
SourceMap要上传到服务器

34:47.280 --> 34:49.280
他要去配置一下你的服务器

34:49.280 --> 34:51.280
不要允许普通用户

34:51.280 --> 34:52.280
用户

34:52.280 --> 34:54.280
访问这个SourceMap文件

34:54.280 --> 34:56.280
就这个SourceMap文件在不在

34:56.280 --> 34:57.280
在

34:57.280 --> 34:58.280
流浪器要不要去请求他

34:58.280 --> 34:59.280
要去请求

34:59.280 --> 35:01.280
但是服务器不给他

35:01.280 --> 35:03.280
避免传输大量的东西

35:03.280 --> 35:05.280
因为这个文件文件

35:05.280 --> 35:06.280
比较大的啊

35:06.280 --> 35:07.280
特别是我们代码多了

35:07.280 --> 35:08.280
模块多了

35:08.280 --> 35:10.280
这个文件会非常非常大

35:10.280 --> 35:11.280
现在我们还可能会用一些

35:11.280 --> 35:12.280
第三方模块

35:12.280 --> 35:13.280
也会在这里边

35:13.280 --> 35:14.280
因此呢

35:14.280 --> 35:15.280
他不建议你

35:15.280 --> 35:17.280
不建议你让服务器

35:17.280 --> 35:18.280
可以直接访问

35:18.280 --> 35:19.280
他让你服务器配置一下

35:19.280 --> 35:20.280
当然你们现在还不知道

35:20.280 --> 35:21.280
怎么去配置服务器

35:21.280 --> 35:22.280
你们以后会学

35:22.280 --> 35:23.280
配置了服务器过后

35:23.280 --> 35:24.280
流浪器去请求这个文件

35:24.280 --> 35:25.280
但是他请求不到

35:25.280 --> 35:26.280
服务器不给他

35:26.280 --> 35:28.280
可能只有开发者

35:28.280 --> 35:29.280
通过一些特殊的方式

35:29.280 --> 35:30.280
才能去请求到这个文件

35:30.280 --> 35:32.280
他都让你去处理的

35:32.280 --> 35:33.280
这就是我们之前说的

35:33.280 --> 35:34.280
在生产环境里边

35:34.280 --> 35:36.280
你即便是要用这个

35:36.280 --> 35:37.280
SourceMap

35:37.280 --> 35:38.280
也要做一些处理

35:38.280 --> 35:39.280
来规避网络传输的问题

35:39.280 --> 35:41.280
和代码暴露的问题

35:41.280 --> 35:44.280
他这里就提供了一些处理的方式

35:44.280 --> 35:45.280
还有什么呢

35:45.280 --> 35:46.280
还有这个HydonSourceMap

35:46.280 --> 35:48.280
这个很有意思

35:48.280 --> 35:49.280
它这个是什么意思呢

35:49.280 --> 35:51.280
他建议你在生产环境里边使用

35:51.280 --> 35:53.280
打个心

35:53.280 --> 35:54.280
他这个玩意呢

35:54.280 --> 35:55.280
他是要生成

35:55.280 --> 35:56.280
要不要生成SourceMap

35:56.280 --> 35:57.280
要

35:57.280 --> 35:58.280
你看光一个SourceMap文件

35:58.280 --> 36:00.280
他都有占三个多KB

36:00.280 --> 36:02.280
但我们现在代码很少

36:02.280 --> 36:04.280
代码很少都要占三个多KB

36:04.280 --> 36:05.280
还不要说

36:05.280 --> 36:06.280
我们用了一些第三方库

36:06.280 --> 36:07.280
代码多了

36:07.280 --> 36:08.280
可能更多

36:08.280 --> 36:09.280
现在他要不要

36:09.280 --> 36:10.280
有没有这个SourceMap

36:10.280 --> 36:11.280
有

36:11.280 --> 36:13.280
但是有了这个SourceMap过后

36:13.280 --> 36:15.280
他对用户是隐藏的

36:15.280 --> 36:16.280
什么意思

36:16.280 --> 36:17.280
他就是说

36:17.280 --> 36:18.280
你看那个文档

36:18.280 --> 36:19.280
他说

36:19.280 --> 36:21.280
他不会为我们最终生成的

36:21.280 --> 36:22.280
这个GS

36:22.280 --> 36:23.280
添加引用注释

36:23.280 --> 36:24.280
什么意思

36:24.280 --> 36:26.280
你看我们的GS里边

36:26.280 --> 36:27.280
要用这个SourceMap

36:27.280 --> 36:28.280
是不是最后呢

36:28.280 --> 36:29.280
他会多一行对吧

36:29.280 --> 36:31.280
多一行一个引用注释

36:31.280 --> 36:32.280
他就多这么一行

36:34.280 --> 36:36.280
SourceMap

36:37.280 --> 36:38.280
UIL

36:38.280 --> 36:40.280
他是不是多这么一行

36:40.280 --> 36:41.280
对不起

36:41.280 --> 36:42.280
你用这种配置的话

36:42.280 --> 36:43.280
他就没有多这么一行

36:43.280 --> 36:44.280
所以说这个SourceMap文件

36:44.280 --> 36:45.280
虽然存在

36:45.280 --> 36:46.280
但是呢

36:46.280 --> 36:48.280
你是看不到的

36:48.280 --> 36:49.280
比方说你这里

36:49.280 --> 36:50.280
你看

36:50.280 --> 36:51.280
爆错了

36:51.280 --> 36:52.280
是不是还在这个

36:52.280 --> 36:55.280
转换后的代码里边

36:55.280 --> 36:57.280
他并不在SourceMap里边

36:57.280 --> 36:59.280
那么这个有什么用了

36:59.280 --> 37:00.280
有一些工具呢

37:00.280 --> 37:02.280
可以去读取这个SourceMap

37:02.280 --> 37:06.240
有些工具是可以的

37:06.240 --> 37:07.240
那么这就是

37:07.240 --> 37:08.240
后边我们就不用看了

37:08.240 --> 37:09.240
不用去读看了

37:09.240 --> 37:11.240
那么这就是关于SourceMap

37:11.240 --> 37:13.240
以及DevTool这个配置

37:13.240 --> 37:14.240
因此我们讲的是什么

37:14.240 --> 37:15.240
讲的是DevTool这个配置

37:15.240 --> 37:16.240
但是呢

37:16.240 --> 37:17.240
他要用到另外一个知识点

37:17.240 --> 37:18.240
就是SourceMap

37:18.240 --> 37:19.240
但是我们讲完之后

37:19.240 --> 37:20.240
你会发现

37:20.240 --> 37:21.240
很简单

37:21.240 --> 37:22.240
就是你不要把他想得太复杂

37:22.240 --> 37:23.240
他解决什么问题

37:23.240 --> 37:24.240
就在解决调试的时候

37:24.240 --> 37:26.240
我们看不到原代码的问题

37:26.240 --> 37:28.240
他在解决这个问题

37:28.240 --> 37:29.240
那么他解决的方式呢

37:29.240 --> 37:30.240
有很多种方式

37:30.240 --> 37:31.240
有Eva的那种方式

37:31.240 --> 37:33.240
有SourceMap这种方式

37:33.240 --> 37:35.240
而且在生产环境里边

37:35.240 --> 37:37.240
有可能是需要用到

37:37.240 --> 37:38.240
什么比较好

37:38.240 --> 37:40.240
在开发环境里边用什么比较好

37:40.240 --> 37:41.240
那么这些东西

37:41.240 --> 37:42.240
你一个都不用去背

37:42.240 --> 37:43.240
千万不用去背

37:43.240 --> 37:44.240
那么这些东西

37:44.240 --> 37:45.240
我刚刚讲完了

37:45.240 --> 37:46.240
你忘完了没关系

37:46.240 --> 37:47.240
你只要知道他的知识的

37:47.240 --> 37:48.240
外语言

37:48.240 --> 37:50.240
就是知识的边界在哪里

37:50.240 --> 37:52.240
只要遇到这个点

37:52.240 --> 37:53.240
这个点

37:53.240 --> 37:54.240
我们有一些需求

37:54.240 --> 37:55.240
OK我们去查阅文档

37:55.240 --> 37:57.240
我们学东西的这样子学

37:57.240 --> 37:59.240
而不要去使尽用备

37:59.240 --> 38:00.240
好

38:00.240 --> 38:02.240
那么这是关于DevTour的配置

