WEBVTT

00:00.620 --> 00:07.620
来 咱们又来看一个插件 叫做copy webpack plug-in

00:07.620 --> 00:10.620
这个插件干嘛用的呢 我们来先来举一个例子

00:10.620 --> 00:12.620
这里其实我已经安装好了这个插件

00:12.620 --> 00:14.620
copy webpack plug-in

00:14.620 --> 00:18.620
先来看一个例子 就是我现在的配置是这样子

00:18.620 --> 00:22.620
这两个没啥好说的 然后我们输出的文件在这儿

00:22.620 --> 00:25.620
在这个目录下边 加入了这么一个插件

00:25.620 --> 00:28.620
学过了 对吧 加入了这么一个插件来生成一个文件

00:28.620 --> 00:31.620
我们来看一下我们的模办文件里边 是这样子写的

00:31.620 --> 00:34.620
一个HE 有个下面一个P元素 关键在这儿

00:34.620 --> 00:38.620
这个我们模办文件里边 用了一个静态图片

00:38.620 --> 00:41.620
就是写死的图片 就要显示在页面上的

00:41.620 --> 00:44.620
比方说有了页面上一些nogo 对吧 东西写死的图片

00:44.620 --> 00:48.620
那么这里有一个src的例子 在哪儿呢 在这个文件夹里边

00:48.620 --> 00:52.620
这个文件夹里边 来吧 接下来我们打包

00:52.620 --> 00:55.620
好 nps vpack

00:55.620 --> 00:58.620
这一打包呢 想一想啊 它就会出现问题

00:58.620 --> 01:01.620
打包完了 打包完了 我们来看一下

01:01.620 --> 01:04.620
在什么录里边 我们页面是不是出来了 对吧

01:04.620 --> 01:07.620
页面远风不动的出来了 对吧 就把这么页面

01:07.620 --> 01:10.620
因为它这个插件的作用 这个插件它就把我们的模办

01:10.620 --> 01:14.620
根据我们的模办生成一个结果 把script元素引用进来了

01:14.620 --> 01:17.620
这个没什么好说的 现在问题在哪儿呢

01:17.620 --> 01:20.620
GS是vpack本身的功能 对吧 它给我们打包成GS

01:20.620 --> 01:23.620
现在问题在哪儿呢 是不是在了这个东西

01:23.620 --> 01:27.620
是不是这个静态资源没过来啊 对吧 这个资源没过来

01:27.620 --> 01:31.620
为啥这个资源没过来了 因为这个资源啊

01:31.620 --> 01:35.620
它呢 跟我们这个GS有没有关系 是不是没关系

01:35.620 --> 01:38.620
这个GS 因为这个GS它没有导入这个资源啊

01:38.620 --> 01:41.620
里面又形成依赖 是不是跟它没关系

01:41.620 --> 01:44.620
跟它没关系呢 vpack本身 它打包的时候

01:44.620 --> 01:47.620
会不会打包这个玩意儿 它根本就不知道这个东西存在

01:47.620 --> 01:51.620
在vpack的世界里边 它根本就不是我们要找到资源

01:51.620 --> 01:54.620
跟vpack没关系 另外它的插件呢

01:54.620 --> 01:57.620
跟这个插件肯定没关系 对吧 它只是清楚目录的

01:57.620 --> 02:01.620
那么跟这个插件 它只是用这个模办来生成一个

02:01.620 --> 02:05.620
一天半夜面 它本管这个模办里面写的是啥 随便你写啥

02:05.620 --> 02:08.620
它本管它不会去解析这个模办里面的东西

02:08.620 --> 02:11.620
那么它直接把这个模办也生成最终形成了这个文件

02:11.620 --> 02:15.620
那么现在就遇到这么一个问题 就是public目录里面

02:15.620 --> 02:18.620
有些东西呢 我们希望了

02:18.620 --> 02:22.620
远风不动的放到电神部落里边来

02:22.620 --> 02:25.620
咱们可能有这么一个希望 比方说这里一个1米几图片

02:25.620 --> 02:28.620
对吧 可能还有些什么其他的乱七八糟的文件

02:28.620 --> 02:31.620
总之呢 我们可能希望 把一些文件呢

02:31.620 --> 02:34.620
微拍不管 你这个插件也不管 总得有人管吧

02:34.620 --> 02:37.620
像这种情况 是不是遇到麻烦了

02:37.620 --> 02:39.620
那么这样子呢 我们希望把有一个目录的东西

02:39.620 --> 02:41.620
远风不动的放到输出目录

02:41.620 --> 02:44.620
那么这个时候呢 你就可以用这个插件了

02:44.620 --> 02:46.620
这个插件叫做copy

02:46.620 --> 02:48.620
copy干嘛的 就复制粘贴

02:48.620 --> 02:51.620
把某一个地方的东西的复制粘贴到另一个地方

02:51.620 --> 02:56.830
就做这么一件事 咱们来看一下吧 特别简单

02:57.830 --> 02:59.830
叫做copy

02:59.830 --> 03:01.830
微拍 你看它们的命名呢 都是差不多的

03:01.830 --> 03:04.830
都是一种标准的命名方式

03:05.830 --> 03:07.830
来吧 插件怎么用 首先安装完了过

03:07.830 --> 03:12.830
它告诉你怎么用呢 告诉你先把插件导入进来

03:12.830 --> 03:14.830
它是个构造函数

03:14.830 --> 03:16.830
接下来 你不用看它的文章 你就知道了

03:16.830 --> 03:18.830
肯定要留一个copy

03:18.830 --> 03:21.830
plugin 对吧 肯定要留一个这么一个构造函数

03:21.830 --> 03:23.830
那么这个构造函数里边呢 它肯定是不知道

03:23.830 --> 03:25.830
到底要把哪个地方的东西复制到哪个地方

03:25.830 --> 03:27.830
它是不知道的 对吧

03:27.830 --> 03:29.830
那么你是不是要通过某些方式来告诉它

03:29.830 --> 03:31.830
那它这里决个例子啊

03:31.830 --> 03:34.830
怎么来告诉它呢 你看 它给它传了一个数组

03:34.830 --> 03:36.830
这个数组里面每一项是个对象

03:36.830 --> 03:38.830
那你可以猜一猜它是啥意思

03:38.830 --> 03:40.830
这个数组 那么数组你每一个对象

03:40.830 --> 03:42.830
是不是一个复制规则 对吧

03:42.830 --> 03:44.830
一个复制规则

03:44.830 --> 03:46.830
每一个对象就是一个复制规则

03:46.830 --> 03:48.830
也就是它可以复制多个地方的东西

03:48.830 --> 03:52.460
复制规则

03:52.460 --> 03:54.460
那么每一个复制规则怎么写呢

03:54.460 --> 03:57.460
你看它怎么写的 一个from 一个to

03:57.460 --> 04:00.460
就这么简单 一个from 一个to

04:00.460 --> 04:02.460
那么from是什么呢 你可以猜一下

04:02.460 --> 04:03.460
from是啥呢

04:03.460 --> 04:07.460
from应该就是从哪个地方复制到哪个地方

04:07.460 --> 04:09.460
对吧 那我们来猜一下

04:09.460 --> 04:11.460
那么我们只需要写一个就行了

04:11.460 --> 04:13.460
对吧 我们要把哪个地方呢

04:13.460 --> 04:15.460
要把public这个文件夹里边的东西

04:15.460 --> 04:17.460
所有东西 复制到哪呢

04:17.460 --> 04:19.460
复制到dash目录下面去

04:19.460 --> 04:21.460
那么我们现在比方说写一个dash

04:21.460 --> 04:24.460
来 我们试一下啊 试一下看能不能复制过去

04:24.460 --> 04:26.460
好 接下来你再来打包

04:26.460 --> 04:27.460
npxwebpack

04:27.460 --> 04:31.800
稍等 出来了

04:31.800 --> 04:33.800
那么现在呢你会发现

04:33.800 --> 04:34.800
跟我们想象的不太一样

04:34.800 --> 04:36.800
因为为什么呢 因为它的dash目录里面

04:36.800 --> 04:38.800
它直接把这两个文件扔过去了

04:38.800 --> 04:40.800
直接把这两个文件扔过去了

04:40.800 --> 04:42.800
对吧 它在这里面创建那个dash目录

04:42.800 --> 04:44.800
说明啥呀 说明它这个to啊

04:44.800 --> 04:46.800
是不是指的是相对于谁

04:46.800 --> 04:48.800
相对的就是输出目录

04:48.800 --> 04:50.800
对吧 相对的就是输出目录

04:50.800 --> 04:52.800
所以说这个to呢 我们该怎么写呢

04:52.800 --> 04:54.800
该怎样子写

04:54.800 --> 04:56.800
直接放到输出目录里面就行了

04:56.800 --> 04:58.800
所以这个to呢 因为这个东西

04:58.800 --> 05:00.800
你看文档也好

05:00.800 --> 05:01.800
你自己去测试一下也好

05:01.800 --> 05:02.800
也马上就明白了

05:02.800 --> 05:03.800
这个to是相对于的是谁

05:03.800 --> 05:04.800
相对于是这个dash目录

05:04.800 --> 05:06.800
因此我们后面没有必要

05:06.800 --> 05:07.800
没有必要再跟一个dash了

05:07.800 --> 05:08.800
不然的话

05:08.800 --> 05:10.800
它就会在里面创建一个dash目念夹

05:10.800 --> 05:12.800
所以说我们直接把它复制过去

05:12.800 --> 05:14.800
OK 那么再来

05:14.800 --> 05:15.800
这里

05:15.800 --> 05:20.010
我也拍

05:20.010 --> 05:21.010
打包

05:21.010 --> 05:22.010
打包完了 你看

05:22.010 --> 05:23.010
现在这个mg文件

05:23.010 --> 05:25.010
假是不是过来了 对吧

05:25.010 --> 05:26.010
不仅过来了

05:26.010 --> 05:27.010
那么这个public里面

05:27.010 --> 05:28.010
它不是还有一个这个东西吗

05:28.010 --> 05:29.010
index.atm

05:29.010 --> 05:31.010
对吧 是不是还有这么一个页面

05:31.010 --> 05:33.010
那现在会不会造成冲突啊

05:33.010 --> 05:35.010
你看这个插件

05:35.010 --> 05:36.010
不是来生成这个文件吗

05:36.010 --> 05:38.010
对吧 生成这个资源文件

05:38.010 --> 05:40.010
那么这个插件呢

05:40.010 --> 05:42.010
它又要把public里面

05:42.010 --> 05:43.010
这个东西要复制过来

05:43.010 --> 05:44.010
它是不是会造成冲突呢

05:44.010 --> 05:45.010
实际上

05:45.010 --> 05:46.010
我们来看一下atm

05:46.010 --> 05:47.010
是不是介石还占

05:47.010 --> 05:48.010
不会造成冲突

05:48.010 --> 05:49.010
为什么不会造成冲突呢

05:49.010 --> 05:50.010
其实这个插件呢

05:50.010 --> 05:52.010
它是考虑到这个问题的

05:52.010 --> 05:53.010
当它发现

05:53.010 --> 05:55.010
我们的输出的结果里面

05:55.010 --> 05:56.010
包含了一些文件

05:56.010 --> 05:57.010
我就不再复制了

05:57.010 --> 05:58.010
我就不再复制了

05:58.010 --> 05:59.010
所以说它考虑到这个问题的

05:59.010 --> 06:00.010
你不用担心

06:00.010 --> 06:01.010
就完事了

06:01.010 --> 06:02.010
就是这么一个插件

06:02.010 --> 06:03.010
它可以

06:03.010 --> 06:04.010
它可以做什么呢

06:04.010 --> 06:05.010
它就可以把我们某一些资源

06:05.010 --> 06:06.010
原分不动的

06:06.010 --> 06:07.010
copy到另一个位置

06:07.010 --> 06:08.010
主要是

06:08.010 --> 06:09.010
我们通常要用的就是

06:09.010 --> 06:11.010
把这个public目录

06:12.010 --> 06:13.010
东西呢

06:13.010 --> 06:14.010
一些静态的

06:14.010 --> 06:15.010
我们的介石代码

06:15.010 --> 06:17.010
没有一毛钱关系的东西

06:17.010 --> 06:19.010
那么copy到这里面

06:19.010 --> 06:21.010
那么通常用于什么情况呢

06:21.010 --> 06:22.010
通常用于

06:22.010 --> 06:23.010
就像那种图片

06:23.010 --> 06:24.010
有些图片

06:24.010 --> 06:26.010
它不是用介石来生成的

06:26.010 --> 06:27.010
就是不是用介石

06:27.010 --> 06:28.010
创建一个隐蔽级元素

06:28.010 --> 06:29.010
然后给它设置src

06:29.010 --> 06:31.010
如果说用介石生成的

06:31.010 --> 06:32.010
那就不一样了

06:32.010 --> 06:33.010
介石生成

06:33.010 --> 06:34.010
是不是我们之前

06:34.010 --> 06:35.010
在做一个例子的时候

06:35.010 --> 06:36.010
楼段的一个例子

06:36.010 --> 06:37.010
处理图片的一个例子

06:37.010 --> 06:39.010
那么我们要把图片

06:39.010 --> 06:40.010
当成一个一代的模块

06:40.010 --> 06:41.010
来处理

06:41.010 --> 06:42.010
那么是要把图片

06:42.010 --> 06:43.010
放到这里面的

06:44.010 --> 06:45.010
但是我们说的

06:45.010 --> 06:46.010
不是这种场景

06:46.010 --> 06:47.010
是我们的页面上

06:47.010 --> 06:48.010
直接把图片写死了

06:48.010 --> 06:49.010
像这种场景

06:49.010 --> 06:51.010
那么就是存静态的东西

06:51.010 --> 06:53.010
跟什么模块的东西

06:53.010 --> 06:54.010
没有任何关系

06:54.010 --> 06:55.010
存静态的内容

06:55.010 --> 06:56.010
那么对这种内容

06:56.010 --> 06:57.010
我们要复制

06:57.010 --> 06:59.010
就可以使用copy

06:59.010 --> 07:01.010
其他没啥了

