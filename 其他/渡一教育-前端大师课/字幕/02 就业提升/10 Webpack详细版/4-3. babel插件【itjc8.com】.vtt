WEBVTT

00:00.880 --> 00:05.120
上节课呢 咱们讲预设 这节课咱们讲插线

00:06.160 --> 00:11.760
讲课之前呢 首先补充一个知识啊 就是这个bible polyfill

00:12.680 --> 00:16.720
这个玩意儿干嘛用的呢 这个玩意儿是一些是一个过去的这么一个cool

00:17.240 --> 00:22.560
就是说我们上节课不是学了预设吗 对吧 那么预设是来转换什么 转换新的语法

00:23.080 --> 00:29.320
对API怎么样 对API它是不会转换的 那么有些旧的流量其他不支持新的API怎么办呢

00:29.440 --> 00:34.720
我们过去是用这个cool来解决的 不过这个cool已经过时了啊 有些同学就想问了

00:35.320 --> 00:38.520
老师你怎么知道它过时了 你从哪个渠道知道这个消息的

00:39.240 --> 00:47.080
没事呢 你去看一看一些npm的那些相关的一些官网啊 比方说你到npm里面去 你收一下这个cool啊

00:48.080 --> 00:55.120
收一下这个cool 其实你安装它的时候呢 它就会提醒你啊 如果去安装安装这个cool的时候 它就会提醒你啊

00:55.520 --> 01:01.600
你看它在我这里就写了啊 这个package呢 has been displayed cake 这个这么多

01:01.960 --> 01:08.520
deprecated 就是过时的意思啊 就已经过时了 现在建议你使用core gs和generated runtime

01:09.200 --> 01:13.800
建议你使用这两个cool 也就是我们上节课使用的 不过呢 以后呢 你 万一在公司里边

01:14.240 --> 01:21.080
有些比较老的项目 它可能还得用这个cool 不要不认识啊 其实也没啥 你到时候就去查网站 一查就明白了啊

01:21.480 --> 01:24.520
其实它就是实现这个功能的 OK 我补充一下

01:25.800 --> 01:27.960
好 那么这一刻我们讲插件

01:28.960 --> 01:35.720
好 有了插件之后呢 它会形成这么一个现象啊 就是我们这个bibol里边呢 它既使用了插件 又使用了

01:36.320 --> 01:40.360
预设 就是这个预设和插件都用了 那么它的转换顺序是什么样子的

01:41.440 --> 01:46.000
下面这三个点 来看一下吧 因为这个点呢 对我们开发其实没什么意义 主要是

01:47.400 --> 01:52.560
可能了会有在面试体里边 可能会有非常非常小的几率啊 会问道理

01:53.280 --> 01:59.120
就是说 有插件也有预设 它的运行顺序是什么样的 插件先运行 然后预设后运行

01:59.720 --> 02:04.800
在运行插件的时候呢 是从前向后 运行预设的时候呢 是从后向前

02:05.440 --> 02:12.520
啥意思呢 大家看一下吧 比方说我们这个配置啊 我们这个工程呢 跟上节课摸尾的那个配置啊 是完全一样的啊

02:12.960 --> 02:16.800
所以就接着上节课讲的 那么比方说我们的预设是这样子的

02:17.440 --> 02:24.240
就例子嘛 预设是A B啊 然后是下面那个plugging插件的是B

02:25.600 --> 02:29.680
C和D 那么它的运行顺序是怎么样子的 运行顺序

02:30.560 --> 02:34.400
运行顺序它就这样子 先运行插件 先把原代码交给C

02:35.200 --> 02:40.160
当它来进行转换 转换完了过后呢 再交给什么D 对吧 从前到后

02:40.880 --> 02:44.560
然后呢 在运行预设 预设的是从后到前 然后呢 交给B

02:45.120 --> 02:47.600
然后呢 交给A 啊 交给A

02:48.240 --> 02:52.720
那为什么他有这样的一种模式呢 我们就不展开了啊 这是他自己独有的一种方式

02:53.760 --> 02:58.320
好 这是关于他们的运行顺序啊 了解一下就行了 跟我们开发没有什么关系

02:59.280 --> 03:01.120
好 接下来我们把回去啊 回去

03:03.600 --> 03:11.680
ok 那么接下来我们看一下啊 有了预设之后为什么还需要插件呢 预设不是挺好的吗 可以转换运发 对吧

03:12.160 --> 03:19.200
有些新的API呢 我们可以可以可以靠这个call.js和generator runtime来进行解决 那为什么还需要插件呢 是这样子的

03:19.920 --> 03:22.880
我们上级和安装那个预设啊 他其实呢是

03:24.080 --> 03:31.920
不能说保护什么啊 他应该说是 他要考虑大部分情况 所以说他只转换那些已经成为正式标准的预发

03:32.400 --> 03:41.040
比方说箭头函数 他已经确定为正式标准了 只不过一些老的扭烂器呢 还不支持 所以他进行下转换 对吧 他只转换那些正式标准

03:42.160 --> 03:51.040
对于有一些处于早期阶段啊 就是还没有确定下来的标准 他不会做转换的 他也不认识 他甚至可能识别不了就爆错了啊

03:51.520 --> 03:53.280
所以说呢 对于对于一些

03:54.160 --> 04:00.720
早期阶段的预访了 他是不会做转换的 那么要转换这些预访你就要单独去使用一些插件

04:01.760 --> 04:09.040
好 那么下面呢 就给大家举一些插件的例子吧 他的插件非常非常多啊 到底有哪些插件了 大家可以看一下他的

04:09.360 --> 04:09.920
呃

04:11.680 --> 04:19.200
就是那个白玻的官方网站啊 不算 算是东文文档对吧 这里边有插件 你看 目前的官方收入的插件呢

04:19.680 --> 04:23.200
就就非常非常多啊 每个插件的最转换一部分语法

04:24.160 --> 04:34.240
很很多的啊 如果说其实他还有些东西呢 还没有包含包含在这个文档里边 那么平时呢 大家上一些博客啊 上些网站的时候呢 看到有一些比较神奇的

04:34.720 --> 04:42.640
转换语法的插件的 大家可以去用一下试一下啊 也挺有意思的 这就可能我们随便列举一些插件啊 直列举四个

04:42.880 --> 04:50.080
也不是说这四个呢 就是一定要用也不一定要用的啊 大家可以看一下每个插件的 他有一些非常非常特别又好玩的功能

04:50.560 --> 04:59.680
好 首先我们看第一个啊 第一个插件 第一个插件呢 名字很长啊 反而是新的插件呢 他一般来说都是用这个命名空间啊eta Bible

04:59.840 --> 05:03.200
开始 然后呢 后面跟上一个plugin 啊 后面什么什么什么什么

05:03.440 --> 05:07.920
对吧 那么这里呢 我们首先安装一下这个插件啊 先安装再说

05:09.440 --> 05:12.000
npm i 横杠地啊 安装一下

05:13.440 --> 05:14.400
回车啊 安装嘛

05:15.520 --> 05:24.720
好 那么这个插件有什么用了 他可以让你在内中书写初始化之段 这个我们以前是我讲我记得啊 我讲s6的时候应该是讲过的啊 就是初始化之段

05:25.520 --> 05:28.000
那么这个东西呢 他让你去写 可以写这样的语法

05:28.720 --> 05:36.640
那其实这个语法呢 他还没有确定成为最终标准 到现在都还没确定 虽然说是s6的语法啊 但是呢 目前还没有确定下来

05:37.440 --> 05:42.720
有些东西 很多其实 其实官方他提供了 就是s官方他有很多很多的提案

05:43.040 --> 05:48.240
只不过呢 很多提案了 后面就不了了之了啊 但是有些东西呢 民间还记得

05:48.560 --> 05:55.680
啊 咱们还记得还有语过这么一些提案 有些提案还蛮好的 但是最后呢 不知道什么原因 因为总统负担的原因 他没有形成最终的

05:56.480 --> 06:04.160
定下来的标准 所以说这种语法呢 这个n5呢 就是预设环境是不会给你转换的 那么 比如说啊 咱们这个代码放过去

06:04.800 --> 06:07.760
放到这里啊 你看一下 我们现在去转换一下啊

06:09.280 --> 06:12.160
npm装必有的 转换 你看能不能转换

06:13.760 --> 06:18.560
好 你看 转换是不是爆错了 对吧 转换的结果也没有爆错了 因为他识别不了这样的语法

06:18.960 --> 06:21.360
啊 这样的语法他识别不了 这个预设是识别不了的

06:21.840 --> 06:27.760
那么插件是可以识别的 所以说了配置一下啊 咱们有了预设之后呢 再给他配置一些插件啊 让插件先运行

06:28.720 --> 06:31.520
那么什么插件呢 第一个插件啊 第一个插件就这个

06:33.040 --> 06:33.600
啊 就这个

06:34.480 --> 06:39.120
啊 那么把全名写下来 那么我们来转换看一下 有了这个插件过后了他就可以转换了

06:41.380 --> 06:45.300
哎 是不是转换成功了 对吧 转换成功了 你看一下 他无非就是

06:46.020 --> 06:52.180
定义一个属性啊 他这里写个辅助函数 定义一个属性啊 定义一个属性给当前对象定一个属性 属性名为

06:52.420 --> 06:58.340
属性的值为1 那么就对应到这边 对这边 是不是这样的预访 对吧 构造函数里面给定义一个属性

06:58.900 --> 07:01.380
那又这么简单 然后呢 再把B负责为3

07:02.180 --> 07:05.780
B负责为3 对吧 这就是只要配置一下就行了啊

07:06.500 --> 07:09.780
在配置的时候呢 是还有这么一些 我记得啊 我

07:10.260 --> 07:15.620
看我也没有记错 就是在配置的时候呢 还有一个简单的配置方案 就是不写前面的前罪

07:16.340 --> 07:20.660
前面的这个bipo可以省略啊 他自动回应的加上 我记得好像是这样子

07:21.140 --> 07:24.340
试一下吧 不行就算了啊 我记得可能也不是很清楚

07:24.820 --> 07:27.860
哎呀 不行 不行 那不行就算了吧 不行就算了

07:28.420 --> 07:31.060
我记得好像是 我把这个parking再去掉了

07:31.780 --> 07:33.460
我把这个再去掉了 我试一下

07:34.100 --> 07:38.660
看他不行 找不到啊 找不到 那算了啊 我好像音乐记得有这么一回事啊

07:39.300 --> 07:40.340
不行啊 不行就算了吧

07:41.220 --> 07:46.420
好 那么这次关于这个插件 如果说插件里边还有配置的话 那么你可以用这种方式

07:46.980 --> 07:48.820
跟那个预设是一样的 用一个

07:49.300 --> 07:54.500
就是把它变成一个数组 数组的第二项其他的配置啊 关于这个插件本身里边的配置

07:55.700 --> 07:58.180
这个插件里边有这么一个配置叫做los

07:59.780 --> 08:03.220
los 就是宽松的 宽松的 不要那么严格

08:03.700 --> 08:05.620
那是什么意思呢 我们把它设为force

08:06.900 --> 08:11.220
把它设为q 把它设为宽松一点 好宽松一点 我们看一下结果你就明白了

08:13.700 --> 08:16.740
啊 编译完成 我们来看一下编译的结果

08:17.540 --> 08:22.260
也等于1 对吧 它就没有什么那个define property那个函数了 就没有用那个函数了

08:22.740 --> 08:25.380
其实那个函数里边做了一些验证啊 做了一些验证的

08:25.860 --> 08:28.260
它就没有用这个函数了 如此而已其他也没啥

08:29.620 --> 08:35.460
ok 那么这就是关于这个插件 当然这个也要配置也可以 不配置也无所谓

08:36.660 --> 08:40.980
好 这是这个插件 对吧 挺有意思的 好 咱们看下一个插件啊 下个插件

08:41.700 --> 08:44.980
这个插件呢 叫做 管它叫啥 我们复制一下

08:46.740 --> 08:48.020
npmi 很钢地

08:50.100 --> 08:55.460
安装 好 这个插件呢 它是用来绑定z关键制的 绑定z的

08:55.940 --> 08:57.620
什么意思呢 我给它复制一下

08:58.420 --> 09:01.780
看一下个带吧 这个插件有的时候还真的蛮好用的

09:02.260 --> 09:04.100
啊 还真的蛮好用的 我把这个

09:05.700 --> 09:07.220
去掉了 这个东西去掉了

09:07.940 --> 09:13.860
啊 什么意思呢 就是有的时候呢 我们书写了一个函数 这个函数呢 要输出当前对象的一个属性 对吧

09:14.580 --> 09:20.820
哎 我们有的时候呢 想把这个函数绑定到别的对象上面 我们以前咋做的 以前是不是用这种方式啊

09:21.460 --> 09:25.860
prevents core 对吧 把z是绑定进去 对吧 那么这里z是否绑定了ob界了

09:26.020 --> 09:30.660
对不对 那么它就可以输出了 但这样子写了 感觉上有点麻烦 于是呢

09:31.220 --> 09:37.940
呃 好像是ES7还是哪个版本啊 它有一个提案 就是说我发现 发明一个新的

09:38.740 --> 09:46.020
语法 就是两个帽号 两个帽号就表示绑定语法 就是Z时绑定语法 表示这个函数绑定了这个

09:46.820 --> 09:48.420
绑定了这个对象 对吧

09:49.140 --> 09:53.380
其实这个语法蛮好了 真的是蛮好的 你看 这样子写出来是不是特别的容易读取

09:53.940 --> 09:55.860
容易理解 对吧 特别容易理解

09:56.340 --> 10:02.660
呃 就是用ob界 用ob界去调用printer 对吧 虽然说printer不是ob界里面的方法

10:02.900 --> 10:07.380
但是呢 我们用ob界去调用printer 什么意思呢 就是printer里面的z呢 指向ob界

10:07.700 --> 10:10.420
是这个 这个这个语法蛮好用的 但是不知道为什么

10:11.620 --> 10:18.740
后来就不了了之了啊 那么就相当于是printer core 你看一下 我们这样子 有了这个插件之后呢 我们配置一下啊

10:19.700 --> 10:24.400
配置一下这个插件 这个插件的名字一尝穿

10:25.120 --> 10:32.140
复制一下吧 来吧 这里呢 我们运行一下啊

10:34.220 --> 10:39.340
哎 哎 运行成功了 你看 最终生成的结果里面是不是把他变成 core了 对吧 把他变成 core了

10:40.140 --> 10:46.460
就很好用了 这插件 就是这个语法 但是呢 目前呢 这个语法呢 不了了之了啊 不了了之了

10:46.940 --> 10:50.860
这里呢 有一个现象的就是很遗憾 其实我还蛮喜欢这种语法的

10:51.180 --> 10:54.620
就是很遗憾的是呢 目前vscode是无法词识别该语法的

10:55.580 --> 10:59.980
会在单码里面爆出 你看 在单码里面爆出了 对吧 但是呢 这个爆出并不影响

11:00.540 --> 11:08.060
他只是编辑器里面给你说啊 你这个单码是不是写错了 我们知道没有写错 因为bibode会帮我们进行转换 以转换就正常了 对吧

11:08.460 --> 11:14.220
但是呢 vscode他不知道 他故意知道有bibode存在 对吧 他不知道的 所以说他这里呢 给你爆了一个错误

11:14.620 --> 11:18.780
那么我当时 我记得 当时我在网上到处查到处找

11:19.340 --> 11:22.380
找不到怎么样解决这个问题啊 没法解决好像是

11:22.860 --> 11:27.900
如果说你们 同学们以后 如果说有别的方式能够解决vscode里面爆错的话

11:29.020 --> 11:33.100
可以联系我一下啊 可以跟我说一下 我也想知道怎么解决啊 所以说很遗憾

11:33.980 --> 11:38.220
其实这个东西你要说有影响多大了 其实也没多大啊 也没多大 他只是

11:38.700 --> 11:42.700
看上去不好看而已 因为他一切都是正常运行的 对吧 正常编译的

11:43.420 --> 11:50.220
只是呢编辑器给你写了一个红色出来 感觉很不舒服啊 但是我又是个完美主义者 因为看这个不舒服 我也不想用场

11:50.700 --> 11:54.060
这是关于这个语法 我觉得这个东西还蛮好用的

11:55.100 --> 11:59.820
好 下面这个东西 我这个东西我特别喜欢 特别特别喜欢这个东西

12:00.460 --> 12:05.020
几乎是我要做开发的话 我一定会安装这个东西啊 这个玩意是干嘛的呢

12:05.820 --> 12:09.500
我们直接看例子啊 先安装 先配置啊 然后先安装

12:11.260 --> 12:14.300
npni 安定 太方便了这个东西

12:17.260 --> 12:18.860
npni 安定

12:20.300 --> 12:22.540
这就复制一下 暂停过来

12:23.500 --> 12:29.460
然后这边配置一下 配置一下 这个玩意呢

12:30.820 --> 12:36.260
特别好用啊 而且呢 目前的vscode 他也是支持这样的语法的啊 只不过呢

12:37.460 --> 12:43.060
只不过了 目前呢 还没有最终确定为标准啊 但是他确实特别好用 我给他看一下这个代码

12:46.580 --> 12:52.180
啊 这个代码是什么意思呢 就是我一个对象 这个对象里边掏一个属性 属性就是对象 对象里边掏属性 属性又是一个属性

12:52.340 --> 12:53.060
啊 就这么个意思

12:54.420 --> 12:59.460
有的时候我们可能会产生这样一个东西 就是我要 就是个对象呢 是来自于别的地方

13:00.500 --> 13:08.260
他有可能来自于一个函数的反悔结果 他来自于或者是阿加克斯请求得到的结果 对吧 我要可能要判断一下一个对象里边

13:08.580 --> 13:12.580
某一个职势多少 比方说我要判断 判断什么呢

13:13.940 --> 13:19.220
obj里边啊 有没有一个附属 附属性里边的bar属性里边的

13:20.180 --> 13:23.860
啊 base啊 判断这个属性是不是等于42

13:24.500 --> 13:28.100
比方说我们要做这样的判断 那么这样的判断到底安不安全了

13:28.820 --> 13:34.340
实际上是非常不安全的 你们写了这么久的代码应该都懂 这样代码为什么不安全

13:35.620 --> 13:40.580
是不是有可能 这一个代码是不是有很多地方都可能爆错 他如果是undefined是不是爆错了

13:41.540 --> 13:48.420
他如果是undefined是不是爆错了 他如果是undefined是不是也爆错了 对吧 也就说你不知道这个对象里边有哪些属性

13:48.740 --> 13:54.820
这个对象是别的地方来的 来自于玩家是请求 来自于服务器反过结果 可能来自于另外一个函数的反过结果

13:55.140 --> 14:02.100
你根本就搞不清楚他哪来的 所以说呢 为了安全的判断的话 我们往往都要做一些事情特别特别麻烦

14:02.500 --> 14:09.780
就是要先判断obj是不是存在 如果他存在的话obj点负是不是存在 如果他存在的话obj点

14:10.180 --> 14:16.020
bar是不是存在 他存在的话obj点什么bar是不是存在 他存在的话obj

14:16.740 --> 14:23.380
不不不 还不是这样的判断啊 负是不是存在 然后点负点bar 你们懂得这个意思 对吧

14:23.940 --> 14:30.500
点负点bar点bar是 然后呢 然后再判断 负点bar

14:31.140 --> 14:36.180
bar是不等于事实 就特别特别麻烦 以前你只能这样做没办法

14:36.740 --> 14:40.980
但是现在有了这种语法过后呢 就会轻松的搞定这件事了 你看一下他怎么做的

14:41.380 --> 14:45.220
你只要在这个变量数线后表加上一个问号就表示

14:45.860 --> 14:51.060
安全性的读取 什么意思 就是说如果obj为安迪范 那么这里就整个

14:51.540 --> 14:55.060
整个表达式就结束了 就不往后边看了 直接返回安迪范

14:55.860 --> 14:58.980
好 那么他不是安迪范 那么再去读他的属性负

14:59.860 --> 15:03.140
读属性负 那么负是不是安迪范 是安迪范就直接返回了

15:03.620 --> 15:06.100
有这么个意思 如果他不是安迪范又读属性bar

15:06.420 --> 15:09.620
如果他是安迪范就直接返回 他如果不是安迪范读属性bass

15:10.180 --> 15:13.300
那么目前呢 我这里呢 有一都不是安迪范 所以得到42

15:14.100 --> 15:17.700
好 那么现在再看下面的obj是不是安迪范 不是 然后读这个属性

15:18.340 --> 15:24.020
叫什么qx啊 qx 那么读这个属性 这个属性没有对吧 安迪范 偶然会直接返回了

15:24.740 --> 15:31.220
他不会报出一个错误 好 咱们来看一下啊 有这样的语法 有了这个插件过后来又可以支持这样的语法

15:31.780 --> 15:32.180
np

15:33.060 --> 15:33.380
装

15:33.700 --> 15:34.100
b

15:36.110 --> 15:36.590
好 运行

15:37.230 --> 15:41.310
好 转换成功 那我们来看一下啊 你看转换出来过而后

15:41.550 --> 15:47.710
他用的是什么呢 他用的就是一个三目云刷服 对吧 一个不断嵌套的三目云刷服

15:48.270 --> 15:53.390
理由兴趣的话 自己可以看一下 obj是不是等于nau或者是obj是不是等于安迪范

15:53.390 --> 15:56.670
那么这个东西就相当于是安迪范的另外一种解法 对吧 void

15:57.150 --> 16:00.190
后面跟一个表达是 整个表达是无论如何都是返回

16:00.510 --> 16:06.190
安迪范的 对吧 那么就相当于是 他是不是nau或者是安迪范 如果是的话 那么就返回安迪范

16:07.150 --> 16:12.750
好 如果不是的话 那么又来看 不是的话 又后面这一坨 不是的话 又看这个

16:13.950 --> 16:17.230
obj多乐妇 看这个东西啊

16:18.110 --> 16:23.950
他这里定了个变量啊 多乐妇 就是把这个obj叫妇 妇子给他看一下 他是不是安迪范的

16:24.510 --> 16:29.550
是不是nau或者是安迪范 如果是的话又返回 对吧 他就是不断的嵌套三目云刷服

16:29.550 --> 16:34.670
来一步一步进行判断 他给你定了一些额外的变量来辅助来进行判断的

16:35.390 --> 16:38.350
ok 这就是 总之呢 还会正常的运行 咱们来看一下吧

16:39.470 --> 16:45.790
没有爆错 对吧 没有爆错 只不过我这里面输出嘛 比方说输出一下 输出

16:46.830 --> 16:54.190
好 看一下 这里输出一下 然后扣了 这样 试试安迪范 就可以安全地进行判断的 特别特别好用

16:54.670 --> 17:03.470
我强烈给大家推荐一下 这是关于这个这个插件 好 下面这个插件呢 也是蛮好用的 把它复制一下

17:04.590 --> 17:13.870
啊 这个插件呢 你可以看到那个 我记得那个npm上 营业好像有几百万的安装量呢 这个插件特别特别简单 我跟你说 简单到令人发指 但是它特别好用

17:14.910 --> 17:21.070
看一下吧 啊 这个插件是一个很老的插件啊 所以它不是以匿名空间开手的啊 我们这里呢

17:21.950 --> 17:25.230
复制一下啊 这里安装安装 然后呢 我们在这里配置一下

17:28.220 --> 17:33.740
诶 我记得是这个啊 好像是过去的这个东西呢 这个东西前面是可以省略的

17:34.140 --> 17:43.100
啊 我不知道记错了没有 还是记到别的东西去了 就是过去不是用匿名空间这种写法的时候呢 就是前面这个bible plugin是可以省略的

17:43.740 --> 17:48.860
啊 是可以省略的 咱们来试一下吧 现在我们还没用到它 对吧 看一下能不能变

17:49.820 --> 17:56.780
啊 对了 对了 对了 那我记错了啊 因为这个匿名空间的做法呢 是新出来的做法啊 以前呢 不是这种做法

17:56.940 --> 18:04.780
以前的老的插件呢 都是前面都是一个潜质bible plugin 对吧 那么在用插件的时候呢 你可以省略潜质的啊 你是可以省略的

18:05.180 --> 18:07.580
啊 我记成这 我记成了新的语法去了

18:08.140 --> 18:11.980
好 那么这个插件有什么用了 这个插件特别特别简单 我就拿这个例子来看嘛

18:12.220 --> 18:16.620
它能做什么事情呢 它就把你的代码里边所有的控制台输出全部给你去掉

18:16.700 --> 18:18.860
好 那么咱们来看一下啊 一保存

18:19.500 --> 18:22.140
那么到这边来 你看控制台输出是不是没了

18:22.780 --> 18:25.980
对吧 控制台输出没了 那么这个插件有什么用呢 有什么意义呢

18:26.700 --> 18:33.100
意义就在于 我们平时在开发阶段的时候 是不是需要一个控制台输出 对不对

18:34.140 --> 18:39.980
啊 因为我们要调是嘛 而我们到了生产环境里边呢 往往是不需要控制台输出的 对吧 你输出啥呀 谁去看你这些东西啊

18:40.300 --> 18:48.780
而我们到了生产环境里边呢 往往是不需要控制台输出的 对吧 你输出啥呀 谁去看你的控制台呀 用户不去看那控制台 你输出干嘛呢

18:49.260 --> 18:52.620
所以说呢 我们往往需要在生产环境里边把一些控制台输出去掉

18:53.260 --> 18:58.700
如果说没有这个插件的话 你可以自己手动的去 特别麻烦 所以说我们可以干嘛呢 我们可以在

18:59.420 --> 19:01.420
在那个就是

19:01.900 --> 19:03.820
开发阶段 就不要这个

19:04.540 --> 19:11.180
啊 不要这个到了生产环境要部署的时候呢 把这个插件加上 对吧 他一下就把一个控制台输出全部给你取掉了 特别特别好用

19:12.140 --> 19:17.100
ok 那么就是这个插件啊 其实还有很多很多的插件 那么大家呢 可以自行去

19:17.820 --> 19:24.620
官方网站去玩一玩啊 他里边这些插件其实也很简单啊 他都给你取了例子的啊 随便看一个吧 随便看一个

19:25.820 --> 19:28.700
嗯 我看一下这个玩意是吧 方可琴Sent

19:29.420 --> 19:35.980
哦 他是搞定那个generator的 是吧 他搞定generator的啊 好 然后再看一下

19:36.860 --> 19:38.460
嗯 pipe line

19:40.060 --> 19:40.860
注意没有例子

19:42.380 --> 19:42.620
嗯

19:43.980 --> 19:49.740
看一下 do expression 这个东西啊 这个东西我以前也用过 这个是玩意儿了 这个是

19:50.300 --> 19:52.380
嗯 他会把它转换成三目一串弧

19:52.940 --> 19:58.540
就是你看啊 他是怎么意思 他就是这个插件他都可以做到这件事啊 就是你写的代码可以这样子写

19:58.860 --> 20:02.780
这是什么代码 这个都完全不符合语法 对吧 那么但是没关系 他可以进行转换

20:03.020 --> 20:08.860
就是把a给他一副一个值 副什么值呢 他的值来自于一个代码段啊 如果说a

20:09.500 --> 20:17.180
另外一个变量x大于10的话 那么就给他副指为bake 你看这个代码都可以存在啊 嗯如果 else 的话就给他副指为一个small

20:17.740 --> 20:20.220
啊 那么他会转换把它转换成三目一串弧

20:20.540 --> 20:26.460
哎呦 但是有些同学说 那这个东西还不如写三目一串弧还要简洁一点 那么不一样哦 你看一下下面

20:26.940 --> 20:34.460
这种情况在写三目一串弧是不是特别复杂了 就很难写了 对吧 很难写了 那如果说你去写那个

20:35.100 --> 20:40.860
你去写那个真的是去写 else 的判断给f 值的话 你会发生很多重复的代码 就是a等于啥

20:41.260 --> 20:46.700
a等于啥 a等于啥 都要反复的写a等于啥 对吧 那么这一块呢 他直接把这个结果复制给a

20:47.260 --> 20:52.940
啊 这也是一种 这也是一个插件 他在做这么一件事啊 就是这些插件的他每个插件的转换

20:53.900 --> 20:57.020
一个比较特殊的代码 比较特殊的语法进行转换

20:57.900 --> 21:01.820
ok 那么插件这一块呢 我们见到的事 当然你不要指望我给你解 全部先稍微

21:02.460 --> 21:09.180
告诉你插件是什么运作的就可以了 是什么一个感觉就可以了 ok 这是bible的插件

21:09.980 --> 21:15.100
啊 这里再给他补充一下啊 我差点忘了啊 就是这还有这么一个插件

21:16.060 --> 21:18.220
啊 还有这么一个插件 他补充一下

21:18.940 --> 21:24.300
就这么一个插件 这个插件呢 他是要做什么呢 他是用于

21:26.220 --> 21:32.620
提供一些公共的api 啊 这些api

21:34.140 --> 21:37.500
会帮助代码转换

21:39.020 --> 21:41.980
什么意思呢 这个东西只能给大家举例子 比方说啊

21:42.940 --> 21:47.420
差点忘了啊 这里 我们这里呢 写了一个class 写了一个内

21:49.950 --> 21:55.390
啊 写了一个内 好 那么这里呢 我们写一个方法吧啊 写这么一个方法

21:56.110 --> 22:01.470
好 保存 你看他转换结果啊 看他转换结果 好 转换了 转换结果

22:03.070 --> 22:08.430
哎 你看是不是在这 对吧 转换结果 那么他为了实现啊 es6里边的内

22:08.910 --> 22:20.350
是不是 他做了很多转换 对吧 他他提供了一些辅助的函数 为了实现那些内 对吧 定义什么定义属性啊 包括那个就是那个z时的检查呀

22:21.230 --> 22:25.310
已经了创建整个内 他都是给你写了相应的函数来帮助你完成

22:26.030 --> 22:28.110
那么这些函数是不会占用一定的

22:29.310 --> 22:36.990
代码内容 对吧 如果说我们的代码文件多了 比方说我们这里有很多的代码文件 他都是这样子啊 比方说写了很多个文件

22:37.390 --> 22:44.190
那么你看每一个文件里面 是不是都有些重复的函数 对吧 都有些重复的函数 那么这样子呢 就会增加整个代码的

22:45.070 --> 22:52.030
尺寸 是不是变得多了 那么其中一种 我们要解决这个问题呢 其实最好的方式就是什么 把这些函数是不是提出去

22:52.510 --> 22:56.750
对吧 提到一个公共的库里边去啊 让那个公共的库里边根本提供这些函数

22:57.390 --> 23:00.910
啊 就是可以基于这么一个思路来解决这个问题 能听懂吗

23:01.710 --> 23:07.390
那么怎么来解决呢 就靠这个库啊 就这个库 这个库就可以解决这样的问题 所以说你只需要安装这个库就行了

23:08.910 --> 23:19.600
npm i很关键啊 安装一下这个库 那么这个库呢 还就在解决这个问题的 这个库里边他提供了一些公共的api啊 其实他就是个插件 你把它配置一下

23:21.520 --> 23:29.200
他提供了一些公共的api啊 哦 这里是可以减写的啊 我刚才查了一下 你减写的方式就是把这个取掉啊 只能这样子减写

23:29.680 --> 23:33.840
把这个plugin取掉啊 前面秘密空间是不能取的啊

23:34.960 --> 23:42.400
plugin取掉啊 可以减写啊 那么这样的一个库呢 他就是来提供一些公共的api啊 保存啊 咱们来看一下吧

23:43.760 --> 23:52.130
run build 啊 别人完成 你看一下 现在每一个代码里边 你看是不是有了这么一个东西 对不对

23:52.450 --> 23:57.650
哎 他是不是从别的 他就不是自己给你写好的 他就是从别的库倒进来的 是吧 那么这样子的

23:57.970 --> 24:02.850
整体的代码的数量是不是变少了 对不对 他就从别的库里边倒进来 你只要直接用就行了

24:03.250 --> 24:09.650
但大家注意一下啊 他用的别的库是用的是什么呢 用的别的库 用的别的库的库的名字叫做bible runtime

24:10.290 --> 24:13.250
啊 是不是你还要安装这个库 对吧 这个库也在安装

24:14.690 --> 24:16.290
所以说我们npmi啊

24:17.010 --> 24:25.810
因为最终代码要用的 所以说我们这里就是啊 直接用那个开普通依赖就行了 啊 这个库的已经在安装 不然的话他要爆错 对吧 他找不到这个库

24:26.290 --> 24:27.970
安装一下

24:28.930 --> 24:29.570
bible runtime

24:30.770 --> 24:39.970
所以说呢 乱七八糟的库安装的还是蛮多的 不过呢 你不用去背这个啊 千万不用去背这个 那么平时呢 我们以后遇到的时候呢 再来查阅一下就明白了啊

24:40.610 --> 24:43.090
平时不用去背 安装好了 我们现在运行一下

24:44.050 --> 24:49.330
你看 是不是不会爆错了 对吧 OK 那么就补充一下这个点啊 刚才讲到了

24:50.050 --> 24:52.850
那其他就没了啊 这是关于bible的插件

