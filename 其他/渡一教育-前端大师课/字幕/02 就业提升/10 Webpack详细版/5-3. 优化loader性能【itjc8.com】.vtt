WEBVTT

00:01.010 --> 00:03.850
在上课之前呢 我先说一件事

00:05.850 --> 00:08.690
你们都安装过一个vscode的插件

00:08.690 --> 00:10.530
对吧 就是这个叫做markdown

00:10.930 --> 00:12.890
preview 我说过

00:15.450 --> 00:17.610
preview in hammers

00:17.850 --> 00:20.530
那么这个插件呢 特别强大

00:20.530 --> 00:21.890
我之前给大家介绍过

00:22.570 --> 00:25.170
我的课件呢 都是基于markdown写的

00:25.170 --> 00:29.250
所以说你们下去呢 要把他课件运行出来了

00:29.410 --> 00:31.370
要显示一个比较好的效果

00:31.370 --> 00:33.490
那么需要使用这个vscode的插件

00:33.490 --> 00:35.250
你们都用过的 我就不再追数了

00:35.690 --> 00:37.930
但是呢 我后来发现了

00:37.930 --> 00:39.890
这个插件呢 有一个小的问题

00:39.890 --> 00:41.450
什么问题呢 就是关于图片

00:42.050 --> 00:44.450
关于图片什么问题呢

00:44.450 --> 00:45.570
我现在不好给大家演示

00:45.570 --> 00:47.530
就是图片显示出来过后了

00:47.650 --> 00:49.970
我很难在图片下边加一些注释

00:49.970 --> 00:51.810
或者是控制一下图片的宽度

00:51.810 --> 00:52.690
很难去做到

00:52.690 --> 00:54.010
比方说举个例子

00:55.130 --> 00:56.610
test md

00:57.490 --> 00:59.410
我们在这里呢 使用一张图片吧

00:59.410 --> 01:00.690
我们在随便写一些文字

01:00.690 --> 01:01.970
使用一张图片

01:02.170 --> 01:02.810
图片的话

01:02.810 --> 01:05.170
我们就用我们这几颗要讲的一张图片

01:05.170 --> 01:06.210
一个例子

01:06.450 --> 01:08.010
图片的使用是这样子

01:08.850 --> 01:09.650
就这个

01:10.410 --> 01:11.850
那么我们来看一下预兰

01:12.210 --> 01:12.930
这图片

01:15.770 --> 01:16.490
我图片呢

01:17.010 --> 01:18.530
还加个感堂号 是吧

01:18.530 --> 01:19.610
前面有个感堂号

01:20.210 --> 01:21.210
图片就出来了

01:21.770 --> 01:23.050
你们下去过后了

01:23.050 --> 01:25.490
你会发现我这边的图片显示出来

01:25.490 --> 01:27.850
跟你们那边用preview

01:27.850 --> 01:28.970
就是那个

01:29.330 --> 01:30.850
预兰的时候图片不太一样

01:30.850 --> 01:32.530
你看我这个图片是不是有边框

01:32.530 --> 01:34.450
你们那边是应该是没有的

01:34.810 --> 01:36.170
另外我可以在这里

01:36.170 --> 01:37.690
给图片写一些文字

01:37.850 --> 01:39.010
比方说我写个文字

01:41.730 --> 01:44.450
就是loader的执行过程

01:45.090 --> 01:45.930
比方写个文字

01:45.930 --> 01:47.290
那么我这边的文字

01:47.330 --> 01:48.130
在课件里边

01:48.130 --> 01:49.610
然后会出现在这个位置

01:49.730 --> 01:51.650
里面那边是应该不会出现的

01:52.610 --> 01:55.050
另外我还可以去限制这个图片的宽度

01:55.050 --> 01:56.490
比方说我在这里这样子写

01:57.210 --> 01:58.650
写一个200

01:59.050 --> 02:01.410
那么这个图片的宽度就被限制成200了

02:01.690 --> 02:03.930
所以说里面那边也不会出现这样的功能

02:04.210 --> 02:06.690
为了避免你们那边的课件

02:07.090 --> 02:08.010
它的显示

02:08.010 --> 02:09.250
跟我这边上课的时候

02:09.250 --> 02:10.250
课件显示不一样

02:10.650 --> 02:12.610
我给大家说一下怎么来处理这个问题

02:13.770 --> 02:14.770
怎么处理呢

02:15.250 --> 02:17.930
是因为我对这个插件做了一个自定义

02:18.610 --> 02:20.850
对这个插件做了一些扩展

02:21.330 --> 02:22.490
你们要跟着我做一遍

02:22.490 --> 02:23.610
你们要跟着我做一遍

02:23.610 --> 02:24.930
才能去完成这样的功能

02:25.250 --> 02:26.090
首先呢

02:26.090 --> 02:27.810
还有一些同学可能在问

02:28.010 --> 02:29.850
就是课件里边

02:30.170 --> 02:32.730
你看我这里把课件打开打打出来

02:33.650 --> 02:34.450
打开过后

02:35.970 --> 02:37.410
那么这边我是有个目录

02:37.410 --> 02:37.810
对吧

02:37.850 --> 02:39.410
我是有这么一个目录的

02:39.530 --> 02:40.690
而且我点击这个

02:40.690 --> 02:43.410
它还会有一个选中的效果

02:43.730 --> 02:45.170
里面那边应该是没有的

02:46.370 --> 02:46.890
怎么弄

02:46.890 --> 02:47.610
一步步说

02:47.610 --> 02:48.490
一步步说

02:48.650 --> 02:49.890
你跟着我视频做就行了

02:49.890 --> 02:51.570
所以这个东西我也不写文档了

02:51.570 --> 02:52.610
跟着我视频做就行了

02:52.850 --> 02:53.450
第一步

02:53.530 --> 02:54.410
找到文件

02:54.410 --> 02:55.210
首选项

02:55.210 --> 02:55.890
设置

02:57.170 --> 03:01.130
你要是开启这个预览里边的介式执行功能

03:01.130 --> 03:01.610
不然的话

03:01.610 --> 03:02.850
它不能执行介式的

03:03.490 --> 03:04.650
因为我写断介式

03:04.650 --> 03:06.130
带码签到英明里边去

03:06.690 --> 03:07.810
在这个扩展里边

03:07.810 --> 03:08.530
你收一下吧

03:08.730 --> 03:09.410
markdown

03:10.090 --> 03:10.930
preview

03:11.170 --> 03:11.850
我这里

03:12.490 --> 03:13.170
preview

03:13.450 --> 03:14.530
那么这里呢

03:14.530 --> 03:15.170
你要找

03:17.130 --> 03:17.850
找到

03:18.090 --> 03:20.090
excuses

03:20.730 --> 03:21.970
哎不对不对

03:22.690 --> 03:23.090
在哪

03:23.130 --> 03:23.770
在那

03:24.410 --> 03:25.610
叫做启用

03:25.730 --> 03:26.850
脚本执行

03:27.050 --> 03:28.330
启用介式脚本执行

03:28.330 --> 03:29.530
你要把这个勾选上

03:29.650 --> 03:29.850
好

03:29.850 --> 03:30.890
这个勾选上过后

03:30.930 --> 03:32.090
你就会有这个东西了

03:32.210 --> 03:33.970
你就会有这个就是目录了

03:34.170 --> 03:35.090
在侧边的目录

03:35.970 --> 03:36.130
好

03:36.130 --> 03:38.130
那么这个选中效果以及这个图片

03:38.130 --> 03:39.210
这些东西是怎么做的呢

03:39.490 --> 03:40.810
你就接下来

03:40.810 --> 03:41.770
你跟着我做

03:41.930 --> 03:43.170
首先按f1

03:44.610 --> 03:45.370
找到这个命令

03:45.530 --> 03:47.050
如果说你这边看不到的话

03:47.050 --> 03:48.130
你自己输一下

03:48.250 --> 03:49.010
markdown

03:49.410 --> 03:50.170
preview

03:50.170 --> 03:51.250
它应该就出来了

03:51.330 --> 03:53.570
叫做customize CSS

03:53.810 --> 03:55.130
自定义CSS

03:55.490 --> 03:56.970
这里你点进去

03:57.130 --> 03:58.970
我把这个CSS发给你

03:59.650 --> 04:01.170
复制一下发给你

04:02.050 --> 04:03.010
这里

04:04.090 --> 04:06.170
你根据自己的需要去调整一下就行了

04:06.170 --> 04:07.610
这个无非就是控制一下

04:07.610 --> 04:09.250
预兰里边的就是样式

04:10.210 --> 04:10.850
我这里

04:11.010 --> 04:11.970
进入文件夹吧

04:12.490 --> 04:13.210
就是markdown

04:15.910 --> 04:18.590
custom CSS

04:18.830 --> 04:20.790
你把这个CSS复制粘贴到

04:20.790 --> 04:22.350
粘贴到刚才的位置就行了

04:23.230 --> 04:24.270
那么它是一个ness

04:24.270 --> 04:25.470
它是一个ness文件

04:25.870 --> 04:27.110
它是一个ness文件

04:27.270 --> 04:28.310
我这里用ness

04:28.870 --> 04:29.230
OK

04:29.230 --> 04:30.510
那么就是这么个意思

04:30.950 --> 04:31.950
那么粘贴过去

04:31.950 --> 04:32.830
这是第一步

04:32.830 --> 04:34.230
搞定样式

04:34.910 --> 04:35.590
第二步

04:35.590 --> 04:37.030
你还上f1

04:37.030 --> 04:38.230
然后搜索这个命令

04:39.030 --> 04:40.270
extend theposer

04:40.510 --> 04:41.190
搜索这个命令

04:41.190 --> 04:43.350
那么这个是往里边加一些

04:43.630 --> 04:45.270
就是在预兰里边加一些

04:45.670 --> 04:48.950
js或者是解析markdown文件的时候

04:48.950 --> 04:50.310
加了一些额外的脚本

04:50.310 --> 04:51.430
我写了一段脚本

04:51.550 --> 04:52.470
那么把这个脚本

04:52.470 --> 04:53.910
我复制一下给你们

04:54.630 --> 04:55.870
就是poser

04:56.590 --> 04:57.670
解释

04:57.670 --> 04:58.350
这个脚本

04:58.350 --> 05:00.710
你把这个脚本间粘贴进去就行了

05:01.310 --> 05:02.310
其他就没了

05:02.310 --> 05:04.030
你把这两件事做到之后

05:04.350 --> 05:06.150
你就可以实现我这边的效果了

05:06.710 --> 05:07.070
OK

05:07.070 --> 05:08.830
那么这里我额外的说一下

05:10.310 --> 05:10.870
这个去了

05:12.550 --> 05:13.790
接下来我们来看这几课

05:14.510 --> 05:15.750
这几课咱们讲

05:15.750 --> 05:17.110
还是继续讲优化

05:17.230 --> 05:18.790
我们上节课讲了什么

05:18.830 --> 05:20.110
优化的其中一个方案

05:20.150 --> 05:22.190
就是减少模块的解析

05:22.190 --> 05:22.750
对吧

05:23.190 --> 05:25.230
减少模一个模块不解析了

05:25.230 --> 05:26.510
他要不要运行loader

05:27.870 --> 05:28.830
他又忘了

05:29.110 --> 05:30.190
原理要记住

05:30.190 --> 05:31.870
连API忘了都没关系

05:31.950 --> 05:32.750
模块不解析

05:32.750 --> 05:33.630
他要不要运行loader

05:33.630 --> 05:34.350
是不是还是要

05:34.350 --> 05:34.990
对不对

05:35.190 --> 05:36.150
那么这比较可能

05:36.150 --> 05:37.150
我们主要的是来看

05:37.350 --> 05:38.430
loader是反

05:38.470 --> 05:39.630
总之你配置到之后

05:39.630 --> 05:41.710
它跑不掉的总会要运行的

05:41.750 --> 05:44.310
那么我们如何来优化loader的性能呢

05:44.510 --> 05:46.270
因为我们知道性能损耗里边

05:46.270 --> 05:47.750
就是构建性能的损耗里面

05:48.390 --> 05:50.390
很多很大程度上

05:50.390 --> 05:51.510
跟loader有关系

05:51.550 --> 05:53.990
因为我们很多文件要经过loader的一步一步

05:53.990 --> 05:55.230
一个一个loader的处理

05:55.230 --> 05:56.710
才得到最终的结果

05:56.830 --> 05:57.670
那么loader的性能

05:57.710 --> 05:59.110
也是我们需要关注的

05:59.270 --> 06:02.030
我们来看如何来减少优化loader的性能

06:02.390 --> 06:04.470
这里分为三个部分

06:06.230 --> 06:07.430
相当困惊大不出来

06:11.610 --> 06:12.410
不好意思

06:13.410 --> 06:14.330
优化loader的性能

06:14.330 --> 06:16.250
我们从过三个方面来说

06:16.690 --> 06:17.770
第一个就是

06:17.970 --> 06:21.050
我们可以进一步限制loader的应用范围

06:21.810 --> 06:22.450
什么意思呢

06:22.450 --> 06:23.330
我们来看一下

06:23.850 --> 06:25.650
就针对某一些库

06:26.290 --> 06:28.330
我们可以不使用loader

06:29.650 --> 06:31.610
比方说我们byboardloader

06:31.610 --> 06:32.210
它干嘛呢

06:32.210 --> 06:33.490
它是来转换语法的

06:33.490 --> 06:33.810
对吧

06:33.810 --> 06:34.850
把s6的语法

06:34.850 --> 06:36.170
或者更高版本的语法

06:36.410 --> 06:37.530
转换成s5

06:37.650 --> 06:38.810
或者是s3的

06:39.210 --> 06:40.090
但是有些库呢

06:40.090 --> 06:41.530
它本身就是s5语法

06:41.530 --> 06:41.770
写的

06:41.770 --> 06:42.810
不需要转换了

06:42.970 --> 06:44.050
那么你使用它的时候

06:44.130 --> 06:45.770
反而会浪费构建时间

06:46.130 --> 06:46.730
对不对

06:46.730 --> 06:47.730
是不是有这么一个道理

06:47.810 --> 06:48.730
不要说下面都大戏

06:48.730 --> 06:49.570
就是这么一个库

06:49.810 --> 06:51.050
实际上很多库

06:51.850 --> 06:53.890
特别是用的人比较多的库

06:53.890 --> 06:55.650
它都要考虑一个兼容性问题

06:56.450 --> 06:57.890
所以说它一般来说

06:57.890 --> 07:00.090
它都已经把代码给你转换过了

07:00.810 --> 07:01.690
你得到了代码的

07:01.690 --> 07:03.290
都已经是转换过后的代码了

07:03.530 --> 07:05.850
所以说你就没有必要再进行是转换了

07:05.850 --> 07:07.050
再进行是转换的话

07:07.050 --> 07:09.130
你要通过byboard去分析

07:09.130 --> 07:10.250
这些乱七八糟的东西

07:10.250 --> 07:11.770
分析转换语法术的

07:12.370 --> 07:13.530
就特别浪费时间

07:14.810 --> 07:15.930
因为像有些库

07:15.970 --> 07:17.970
而且像这一库出现的比较早

07:17.970 --> 07:20.410
像楼大写的本身就是在ES5之前出现的库

07:20.410 --> 07:22.090
它使用的都不是ES5的语法

07:22.090 --> 07:24.050
它都使用了是ES3的语法

07:24.050 --> 07:25.610
像这些东西就根本不用转换了

07:26.170 --> 07:28.410
那么怎么来搞定这件事了

07:28.970 --> 07:30.690
我们就可以使用这么一个配置

07:30.690 --> 07:31.730
这是自带的配置

07:32.010 --> 07:34.610
叫exclude和include这个配置

07:34.610 --> 07:35.410
那么顾名思义

07:35.410 --> 07:36.250
一个是排除

07:36.250 --> 07:37.130
一个是包含

07:37.410 --> 07:38.970
当然这两个只配一个就行了

07:38.970 --> 07:40.090
配两个要冲突的

07:41.730 --> 07:44.490
就可以排除掉或者是紧包含

07:44.530 --> 07:46.290
需要用到loader的场景

07:46.530 --> 07:48.130
下面这个配置你看一下

07:48.450 --> 07:50.290
比方说我们遇到介石结尾的文件

07:50.290 --> 07:51.850
我们要经过bable loader

07:51.850 --> 07:52.850
bable loader

07:53.810 --> 07:55.410
应该又读错了

07:55.410 --> 07:56.130
bable loader

07:56.570 --> 07:57.370
bable loader

07:57.490 --> 07:58.250
经过它的时候

07:58.250 --> 07:59.130
它要分析这个文件

07:59.130 --> 07:59.330
对吧

07:59.330 --> 08:00.370
要对它进行处理

08:00.370 --> 08:02.210
但是我要排除掉一些东西

08:02.210 --> 08:03.850
那么我们就可以用一个正的表达式

08:04.730 --> 08:06.770
你这里边也有介石文件

08:06.770 --> 08:08.290
但是我要排除掉你

08:08.610 --> 08:10.010
那么遇到这种

08:10.570 --> 08:11.890
那个模困部路的话

08:11.890 --> 08:14.730
那么就不需要去使用bable loader

08:15.170 --> 08:16.090
就这么个意思

08:16.570 --> 08:17.450
接下来我们来看一下

08:17.450 --> 08:18.250
看一下

08:19.650 --> 08:21.130
我们这里有一个如何文件

08:21.170 --> 08:23.810
比方我们在这里用到了bable

08:24.810 --> 08:27.170
用到了这个就是loader

08:27.690 --> 08:30.130
说明loader需要打包到最终目录

08:30.130 --> 08:31.810
当然它也肯定要经过loader

08:32.290 --> 08:33.770
这里我们就输出

08:33.970 --> 08:34.690
随便输出一个

08:34.690 --> 08:36.850
我们就定一个是伪输主

08:37.090 --> 08:37.810
伪输主

08:38.210 --> 08:39.770
因为它里面有很多方法

08:40.170 --> 08:40.770
伪输主

08:40.770 --> 08:41.970
0等于A

08:42.690 --> 08:43.770
1等于B

08:43.770 --> 08:44.250
对吧

08:44.730 --> 08:46.650
那么我判断它到底是不是一个输主

08:47.170 --> 08:48.370
现在我们当然可以用

08:48.370 --> 08:48.770
array

08:48.770 --> 08:49.450
easy来判断

08:49.450 --> 08:49.850
对吧

08:49.930 --> 08:51.370
但是以前没有这个东西

08:51.570 --> 08:52.770
以前loader-easy里面

08:52.770 --> 08:53.610
它提供了一个

08:54.210 --> 08:55.330
叫做easy-array

08:57.210 --> 08:57.850
obj

08:58.490 --> 08:59.690
它都是一些过去的方法

08:59.690 --> 09:00.570
所以loader-easy这个空

09:00.970 --> 09:01.810
现在还有没有用了

09:01.810 --> 09:02.890
现在其实还有用

09:02.890 --> 09:03.810
它里面有些东西

09:03.850 --> 09:05.370
并不是es6

09:05.570 --> 09:07.410
或者是更高版本的es

09:07.450 --> 09:08.250
它还没有

09:08.330 --> 09:09.530
加入进去

09:09.650 --> 09:10.850
一些特别有用的API

09:10.850 --> 09:11.930
它现在还是有用的

09:11.930 --> 09:12.970
不是完全没用

09:13.410 --> 09:14.690
那么这里加进去了

09:14.970 --> 09:15.810
我们判断一下

09:16.570 --> 09:17.250
result

09:17.770 --> 09:18.930
输出而result

09:21.050 --> 09:22.250
为了让大家看到效果

09:22.250 --> 09:23.130
这里用const

09:25.310 --> 09:26.190
接下来我们再看一下

09:26.190 --> 09:27.150
wippack的配置

09:27.670 --> 09:29.510
我们配置里面做的一件很简单的事

09:29.510 --> 09:30.950
就是凡是GS文件

09:30.950 --> 09:32.310
我们都使用biproder

09:32.870 --> 09:33.030
好

09:33.030 --> 09:33.710
接下来我们看一下

09:35.590 --> 09:36.510
这里我们打包

09:41.430 --> 09:43.270
npxwipack

09:43.470 --> 09:43.990
打包

09:50.590 --> 09:52.710
然后打包完成

09:52.710 --> 09:52.910
对吧

09:52.910 --> 09:54.110
用了3秒多时间

09:54.110 --> 09:54.430
对不对

09:54.430 --> 09:55.310
用了3秒多

09:55.310 --> 09:56.630
为什么用这么久的时间

09:56.750 --> 09:58.550
我们现在把这个目录去

09:58.550 --> 09:59.470
把这个东西去掉

09:59.750 --> 10:01.310
把index.sdl

10:01.310 --> 10:02.150
里边的东西去掉

10:02.150 --> 10:03.310
我们来看一下现在打包

10:05.720 --> 10:06.480
印象

10:06.840 --> 10:08.160
打包是不是只有1秒多

10:08.760 --> 10:10.440
那么更多的时间耗在哪呢

10:10.440 --> 10:11.840
是不是耗在loader-easy里面

10:11.840 --> 10:13.200
对loader-easy进行解析

10:13.240 --> 10:15.160
因为我们这个东西没有什么好解析的

10:15.440 --> 10:16.320
特别简单

10:16.480 --> 10:18.520
那么更多的时候是耗在这里解析

10:18.520 --> 10:19.960
其实它根本就没有必要解析

10:20.000 --> 10:21.440
有什么好解析的

10:21.440 --> 10:22.640
因为它里边都是兼容信贷

10:23.400 --> 10:24.800
因此我们可以在这里边

10:25.160 --> 10:25.800
把它排除掉

10:26.640 --> 10:27.480
exclude

10:28.320 --> 10:28.920
exclude

10:29.400 --> 10:30.040
排除掉什么呢

10:30.040 --> 10:30.840
排除掉loader-easy

10:31.840 --> 10:32.280
loader-easy

10:32.640 --> 10:32.840
好

10:32.840 --> 10:34.120
接下来我们排除掉过后了

10:34.120 --> 10:34.600
你看一下

10:34.600 --> 10:35.960
之前没有排除3秒多的时间

10:35.960 --> 10:36.280
对吧

10:36.400 --> 10:37.240
那么排除掉过后

10:37.240 --> 10:37.840
我们来看一下

10:42.470 --> 10:43.070
爆错了

10:43.750 --> 10:44.190
我看一下

10:45.190 --> 10:46.550
这里应该哪里写错了

10:46.550 --> 10:47.590
include

10:47.590 --> 10:48.990
这个include写错了

10:49.870 --> 10:50.590
因为wipack

10:50.630 --> 10:52.110
它是要进行配置检查的

10:52.270 --> 10:53.790
你当然也使用了一些

10:55.710 --> 10:56.230
当然对

10:56.230 --> 10:57.310
我又写错了

10:57.550 --> 10:58.470
当里使用了一些

11:02.110 --> 11:03.830
当里使用了一些

11:04.270 --> 11:05.150
我想说啥呢

11:06.350 --> 11:08.510
一些无效的配置的时候

11:08.790 --> 11:10.830
那么它就是会爆错的

11:11.150 --> 11:12.950
现在我们看一下时间是不是明显减少了

11:13.190 --> 11:14.110
排除掉这个目录过后

11:14.110 --> 11:14.670
两秒钟了

11:14.910 --> 11:15.670
这个多大把几次

11:15.670 --> 11:16.710
你就可以看到效果了

11:19.310 --> 11:20.470
那么1秒多

11:21.110 --> 11:23.110
那么当然它不是一定的时间

11:23.110 --> 11:24.270
它有浮动的

11:24.470 --> 11:24.630
好

11:24.630 --> 11:25.310
那么这里

11:25.590 --> 11:26.990
是不是就时间要快一些了

11:26.990 --> 11:27.510
对不对

11:27.750 --> 11:28.670
就这么个意思

11:28.790 --> 11:29.630
就这么个意思

11:29.910 --> 11:30.950
所以这是exclude

11:31.350 --> 11:33.110
如果说下面有的时候

11:33.110 --> 11:34.230
以后在公司里面

11:34.470 --> 11:36.510
可能会看到一些更加暴力的写法

11:36.790 --> 11:38.830
就是直接把loader-easy目录排除掉

11:39.190 --> 11:40.750
当然不仅仅是介石文件

11:41.070 --> 11:41.990
不仅仅是介石文件

11:41.990 --> 11:42.950
像一些CSS

11:42.950 --> 11:44.950
也不需要经过poser-css

11:44.950 --> 11:45.630
加载的时候

11:45.630 --> 11:47.710
也可以通过exclude把排除掉

11:48.150 --> 11:50.150
就是只要加了exclude

11:50.190 --> 11:51.630
那么这条规则里边

11:51.630 --> 11:53.030
反而是遇到了它

11:53.150 --> 11:53.910
就不解析

11:54.830 --> 11:56.430
哪怕你匹配它都不解析

11:57.150 --> 11:58.390
反而是加了include

11:58.390 --> 12:00.070
只要在include里边才解析

12:00.070 --> 12:01.070
其他的都不解析

12:01.350 --> 12:01.990
所以有的时候

12:01.990 --> 12:03.270
会遇到一些暴力的写法

12:03.390 --> 12:04.990
排除掉整个loader-easy目录

12:05.070 --> 12:06.070
因为大部分的cool

12:06.070 --> 12:07.350
它已经做了监控性了

12:07.470 --> 12:09.430
所以说你都没有必要管它

12:10.270 --> 12:11.190
当然要慎重

12:11.310 --> 12:12.190
这东西要慎重

12:13.350 --> 12:15.470
或者是我们用include

12:16.470 --> 12:17.550
就是src

12:18.110 --> 12:19.070
我们只管

12:19.830 --> 12:20.710
只管什么

12:20.710 --> 12:23.270
只管当前目录下面的

12:23.470 --> 12:26.190
当前目录下面的src

12:26.590 --> 12:28.350
当前目录下面的src

12:29.670 --> 12:30.270
你看吧

12:32.540 --> 12:33.260
运行

12:33.820 --> 12:34.420
你看

12:34.860 --> 12:37.500
是不是更加了一个就是了

12:37.500 --> 12:37.780
对吧

12:37.780 --> 12:38.820
更加快了

12:38.820 --> 12:40.220
因为刚才实际上

12:40.220 --> 12:42.460
虽然排除了loader-easy

12:42.460 --> 12:43.500
还有一个问题

12:43.500 --> 12:44.620
就是wipack里边

12:44.620 --> 12:45.540
它还有一些代码

12:45.780 --> 12:46.940
wipack里边还有一些代码

12:46.940 --> 12:47.700
还没有排除

12:48.900 --> 12:49.740
所以说这里

12:49.780 --> 12:51.980
我们都把只管src目录

12:51.980 --> 12:52.980
这就快很多了

12:53.180 --> 12:54.540
这就是关于这一块

12:54.780 --> 12:56.460
能够提高loader的执行效率

12:56.660 --> 12:57.620
那么这一块

12:57.900 --> 12:59.380
它实际上跟loader-easy

12:59.380 --> 13:00.140
poss是不冲突的

13:00.140 --> 13:01.300
你可以连着用的

13:01.820 --> 13:03.140
就是对某一些cool

13:03.260 --> 13:04.980
我们可以不进行解析

13:05.100 --> 13:08.060
同时我们又可以排除掉这些cool

13:08.140 --> 13:08.940
经过loader

13:09.180 --> 13:10.140
因为loader-easy

13:10.140 --> 13:13.020
它是跟loader是没有关系的

13:13.020 --> 13:14.780
它还是会经过loader的

13:14.780 --> 13:16.500
这里我们只是排除掉loader

13:18.220 --> 13:19.180
这里第二个

13:20.740 --> 13:21.860
第二个方式

13:22.420 --> 13:25.060
第二种方式是缓存loader的结果

13:25.860 --> 13:27.060
缓存loader的结果

13:27.060 --> 13:28.020
我等一下

13:28.020 --> 13:28.860
我看一下这个

13:29.060 --> 13:30.060
我这样的配置

13:30.060 --> 13:31.580
有没有把这个解析出来

13:31.580 --> 13:33.140
有没有就是经过byboard

13:37.120 --> 13:38.320
这是loader-easy

13:40.570 --> 13:41.370
放下面

13:41.650 --> 13:43.170
这里没有经过byboard对吧

13:43.170 --> 13:44.370
src目录

13:44.370 --> 13:45.850
是没有经过byboard的

13:47.050 --> 13:48.250
第二鞋杠

13:48.490 --> 13:49.650
src

13:49.650 --> 13:50.410
看一下

13:51.210 --> 13:52.810
第二鞋杠

13:52.810 --> 13:54.050
src目录

13:55.090 --> 13:56.810
那么直接写个src

13:59.110 --> 13:59.910
再运销

14:04.150 --> 14:04.870
这样子才行

14:04.870 --> 14:06.510
刚才连我的文件都没有解析

14:06.510 --> 14:07.950
连我的文件都没有解析

14:08.110 --> 14:08.750
OK

14:09.590 --> 14:11.630
那么这里我们再看第二个

14:11.750 --> 14:13.190
缓存loader的结果

14:13.990 --> 14:15.430
从另一个方面来

14:15.430 --> 14:16.870
提高loader的执行效率

14:17.710 --> 14:18.550
这里的什么情况

14:18.630 --> 14:20.470
就是我们可以继续一种假设

14:21.670 --> 14:23.790
某一个文件内容不变的话

14:23.790 --> 14:25.070
经过loader解析之后

14:25.070 --> 14:26.470
解析的结果也不变

14:26.470 --> 14:28.150
如果说这个假设成立

14:28.590 --> 14:31.350
潜力条件是如果说这个假设成立的话

14:31.510 --> 14:32.670
那么就可以缓存

14:32.910 --> 14:35.230
比方说像我们这个入口文件

14:35.470 --> 14:37.950
你只要这个代码内容不变

14:37.950 --> 14:39.310
你知道这个文件不变

14:39.670 --> 14:41.870
你经过兼容性就是byboardloader

14:41.870 --> 14:43.590
经过兼容性的编译过后

14:43.590 --> 14:45.590
那么编译结果应该是一样的

14:45.590 --> 14:45.870
对吧

14:45.870 --> 14:46.550
是不是一样的

14:46.550 --> 14:47.670
它肯定是一样的

14:48.230 --> 14:49.910
那么既然这如此的话

14:49.910 --> 14:52.350
我们就可以把之前第一次

14:52.350 --> 14:53.470
对它进行编译的时候

14:53.470 --> 14:54.710
把它缓存起来

14:55.230 --> 14:56.710
把这个结果缓存起来

14:56.950 --> 14:58.870
那么后续对它进行编译的时候

14:58.870 --> 15:00.270
就不要对它编译了

15:00.270 --> 15:01.950
就不要对它进行编译了

15:01.950 --> 15:03.030
是这么个意思

15:03.590 --> 15:05.430
那么这就是缓存loader

15:06.510 --> 15:07.750
当然文件内容变了之后

15:07.750 --> 15:08.750
当然要经过编译

15:08.750 --> 15:09.830
都是不变的情况下

15:09.830 --> 15:11.070
就不需要编译了

15:12.550 --> 15:13.830
那么怎么样来实现这个功能

15:13.830 --> 15:15.710
就利用catchloader

15:16.710 --> 15:17.950
catch就是缓存的意思

15:18.550 --> 15:19.230
怎么用呢

15:19.230 --> 15:20.070
非常简单

15:20.070 --> 15:23.270
你只需要把catchloader放到对前边就行了

15:23.910 --> 15:24.630
比方说

15:24.710 --> 15:26.430
咱们在这里可以不使用

15:26.430 --> 15:27.950
怎么include exclude

15:27.950 --> 15:29.070
我们直接使用catch

15:29.070 --> 15:30.110
因为有缓存了

15:31.470 --> 15:32.750
它就直接用了缓存

15:33.830 --> 15:35.230
那么这样子更加保险一点

15:35.230 --> 15:36.950
万一loader码90目录下面

15:37.110 --> 15:38.990
有些东西是需要经过编译的了

15:38.990 --> 15:39.510
怎么办的

15:39.510 --> 15:39.950
对吧

15:39.950 --> 15:42.190
所以说我们只要需要经过loader的

15:42.190 --> 15:44.950
我把之前第一次经过loader的东西缓存下来

15:44.950 --> 15:46.070
它缓存成什么呢

15:46.070 --> 15:47.510
缓存成一个文件

15:47.510 --> 15:48.990
保存在某一个地方

15:50.030 --> 15:50.990
把缓存下来

15:51.230 --> 15:51.430
好

15:51.430 --> 15:52.350
接下来我们来看一下

15:55.630 --> 15:57.230
nps 微派

15:58.430 --> 15:59.550
等一下

15:59.910 --> 16:01.430
因为发现它特别特别慢

16:01.870 --> 16:02.550
为什么呢

16:02.550 --> 16:03.350
第一次

16:03.350 --> 16:04.750
它第一次的时候

16:04.750 --> 16:06.150
甚至有可能

16:06.150 --> 16:07.870
比你不使用它还要慢

16:07.870 --> 16:08.350
为什么

16:08.350 --> 16:09.630
它要把它的东西缓存下来

16:09.630 --> 16:10.830
保存到文件里面

16:10.830 --> 16:12.870
因为读写文件是需要花时间的

16:13.510 --> 16:13.910
好了

16:13.910 --> 16:15.190
但是后续就不一样了

16:15.190 --> 16:16.190
我们来看一下后续

16:16.190 --> 16:16.990
再打爆

16:20.760 --> 16:21.400
诶

16:21.400 --> 16:22.200
写错了

16:23.320 --> 16:24.040
微派

16:25.940 --> 16:26.820
后续再打爆

16:27.540 --> 16:28.860
那么是不是就少很多了

16:28.860 --> 16:29.460
时间

16:29.460 --> 16:30.260
对不对

16:30.260 --> 16:30.580
好

16:30.580 --> 16:31.420
那么因为什么呢

16:31.420 --> 16:32.820
它用到了缓存

16:33.420 --> 16:34.380
像这种

16:34.860 --> 16:35.780
像这种的话

16:35.780 --> 16:36.620
工程越大

16:36.620 --> 16:37.380
文件越多

16:37.380 --> 16:38.500
要解写的东西越多

16:38.500 --> 16:39.700
它越能够提高效率

16:39.940 --> 16:40.820
开启loader

16:41.020 --> 16:41.820
其实这个玩意儿

16:41.820 --> 16:43.060
你还可以多做一些

16:43.180 --> 16:44.620
自定义的一些配置

16:44.620 --> 16:45.260
比方说

16:45.260 --> 16:46.980
你可以配置 catch

16:47.900 --> 16:48.420
loader

16:48.620 --> 16:49.460
catchloader

16:51.860 --> 16:54.260
然后这里使用 catch

16:54.900 --> 16:55.860
director

16:57.180 --> 16:59.060
就是我们缓存的目录可以指定

16:59.060 --> 17:00.940
比方说我们放到我们本工程下边

17:01.940 --> 17:03.740
它应该是用的是windows的临时目录

17:03.740 --> 17:04.700
系统的临时目录

17:04.700 --> 17:06.260
那么我们这里可以把它放到

17:06.260 --> 17:07.100
我们的工程下边

17:07.100 --> 17:08.260
放到这个文念夹里面

17:08.260 --> 17:09.060
好看一下吧

17:16.260 --> 17:16.620
哦

17:16.620 --> 17:17.780
这应该是写错了

17:18.060 --> 17:18.740
catch

17:20.810 --> 17:21.650
director

17:24.400 --> 17:24.680
诶

17:24.680 --> 17:25.280
还是写错了

17:25.280 --> 17:26.160
那我们查一下文档

17:26.160 --> 17:27.440
这个API为忘了

17:28.000 --> 17:28.960
查一下文档

17:29.680 --> 17:30.880
预示不决查文档

17:30.880 --> 17:31.960
像这些API忘了

17:31.960 --> 17:32.680
就忘了吧

17:32.680 --> 17:33.680
开启loader

17:35.910 --> 17:36.190
好

17:36.190 --> 17:36.990
看一下吧

17:37.350 --> 17:39.430
这里边有 catch directory

17:39.430 --> 17:40.350
写得对了

17:42.320 --> 17:43.120
写得对了

17:44.400 --> 17:44.920
哦

17:44.920 --> 17:46.120
这个是opsins

17:46.120 --> 17:46.800
opsins

17:46.800 --> 17:47.840
我忘了写这个

17:51.460 --> 17:51.820
好

17:51.820 --> 17:52.260
保存

17:52.380 --> 17:53.260
再来打包

17:55.610 --> 17:55.850
好

17:55.850 --> 17:56.610
第一次比较慢

17:56.730 --> 17:57.610
第一次比较慢

17:58.610 --> 17:58.930
好

17:58.930 --> 17:59.450
打包完了

17:59.450 --> 17:59.890
三秒多

17:59.890 --> 18:00.250
对吧

18:00.250 --> 18:00.450
你看

18:00.450 --> 18:01.570
但是文件是不是放到这了

18:01.570 --> 18:02.090
对吧

18:02.210 --> 18:04.210
这些文件里边就存出了

18:04.330 --> 18:06.810
就是存出了就是编译过后的内容

18:06.810 --> 18:08.410
你看这个就是loader

18:08.410 --> 18:09.130
loader的东西

18:09.130 --> 18:10.330
编译过后变成这样子

18:10.530 --> 18:11.450
内容特别多

18:11.810 --> 18:12.250
好

18:12.610 --> 18:13.290
那么后续的

18:13.290 --> 18:14.570
我们再进行编译的时候

18:14.570 --> 18:16.090
还有直接读取这个文件了

18:16.650 --> 18:18.250
读取这个缓存目录里边文件

18:18.250 --> 18:19.490
就快了很多了

18:19.730 --> 18:20.890
这是 catch loader

18:21.890 --> 18:22.650
这个东西

18:22.970 --> 18:23.170
好

18:23.170 --> 18:24.170
那么当然

18:24.170 --> 18:25.730
开启loader还有很多的用法

18:25.730 --> 18:27.210
你可以去看一下这个文档

18:27.610 --> 18:28.690
如果有兴趣的话

18:28.690 --> 18:33.450
当然如果说你以后遇到了公司里面遇到特别特别特殊的需求

18:33.570 --> 18:36.290
你需要自己去控制它的缓存结果

18:36.290 --> 18:38.290
因为它的缓存结果是一个节省格式

18:38.490 --> 18:39.530
这个节省格式

18:39.530 --> 18:40.690
它是自行规定的

18:40.770 --> 18:42.490
那么如果说你要改成别的格式

18:42.490 --> 18:43.770
那么你自己要去写

18:43.770 --> 18:44.690
怎么缓存

18:44.690 --> 18:45.810
怎么进行缰息

18:46.050 --> 18:47.130
你自己可以去写的

18:47.130 --> 18:47.810
都可以控制的

18:47.810 --> 18:51.250
当然我们这里面就不去做这么深入的讲解了

18:51.370 --> 18:52.490
这只是一个库而已

18:52.890 --> 18:53.170
好

18:53.170 --> 18:55.130
另外我们要考虑另外一个问题

18:55.730 --> 18:56.810
这有重点来了

18:59.020 --> 19:02.660
我们明明是把 catch loader放到最前面的

19:03.380 --> 19:05.180
它怎么能够做到

19:05.780 --> 19:07.260
让后续的loader

19:07.820 --> 19:09.660
能控制后续的loader不运行的

19:09.660 --> 19:10.700
它怎么做到的

19:11.020 --> 19:11.860
什么意思呢

19:11.900 --> 19:13.860
就是你看这里是 catch loader

19:13.860 --> 19:14.420
对吧

19:14.420 --> 19:15.740
这里是bibler loader

19:15.740 --> 19:17.780
那么运行loader的顺序是什么样子

19:18.140 --> 19:19.420
先运行它

19:19.420 --> 19:20.820
它转换一个结果

19:20.820 --> 19:21.860
然后再交给它

19:21.860 --> 19:23.500
它干嘛把它缓存下来

19:24.540 --> 19:26.060
那么第二次的时候

19:26.060 --> 19:26.980
第二次运行的时候

19:26.980 --> 19:28.740
是不是还是要先运行它

19:29.420 --> 19:31.460
是不是还是要让它去转换一次

19:31.460 --> 19:33.820
然后再运行它

19:33.820 --> 19:36.260
那么它决定使不使用缓存结果

19:36.260 --> 19:37.900
但是使不使用已经晚了

19:37.900 --> 19:39.180
因为别人已经转换过了

19:39.180 --> 19:40.620
已经时间已经消耗掉了

19:40.980 --> 19:41.500
对吧

19:41.620 --> 19:42.940
就是说它把它放到第一个

19:42.940 --> 19:44.340
它是怎么来控制的

19:44.580 --> 19:46.740
这就是以前我们没有学过的

19:47.260 --> 19:48.340
因为之前我来纠结

19:48.340 --> 19:49.100
要不要讲那个pitch

19:49.100 --> 19:50.380
其实loader里面还是有

19:50.380 --> 19:51.380
还有部分知识

19:51.780 --> 19:53.740
不过那些知识太细节了

19:53.740 --> 19:54.260
太细节了

19:54.260 --> 19:55.100
我觉得没有必要

19:55.100 --> 19:56.620
平时完全用不到的

19:56.900 --> 19:58.060
那么当时我就在想

19:58.060 --> 19:59.740
pitch的东西有没有可能我们会用到

19:59.740 --> 20:00.940
当时我觉得也不会用到

20:00.940 --> 20:01.940
那讲到这的话

20:01.940 --> 20:02.780
那就没办法了

20:03.140 --> 20:04.140
给大家讲一讲

20:04.940 --> 20:06.260
就是loader的运行过程中

20:06.260 --> 20:07.500
其实还有一个过程

20:07.500 --> 20:08.380
叫做pitch

20:09.380 --> 20:10.500
我们写的loader是啥

20:10.500 --> 20:12.220
不就是一个函数吗

20:12.540 --> 20:13.460
我们看一下吧

20:15.180 --> 20:16.420
我们在这里随便写一个

20:16.420 --> 20:17.820
src里面随便写一个

20:18.100 --> 20:18.500
loader的

20:18.500 --> 20:20.180
而且是loader是啥

20:20.180 --> 20:21.500
loader不就是一个函数吗

20:21.740 --> 20:22.180
对吧

20:23.540 --> 20:24.100
loader

20:24.980 --> 20:27.460
这是给我们一个原代码

20:27.460 --> 20:28.940
我在函数里面进行转换

20:28.940 --> 20:30.180
返回一个新的原代码

20:30.180 --> 20:30.660
对吧

20:30.820 --> 20:32.660
返回一个新的原代码

20:35.330 --> 20:36.730
这就是loader

20:37.090 --> 20:37.850
那么loader里面

20:37.850 --> 20:39.010
其实还有一个东西

20:39.010 --> 20:41.890
就是一个函数的静态属性

20:42.330 --> 20:43.250
叫做pitch

20:44.290 --> 20:45.290
当你写的就有

20:45.290 --> 20:46.090
没有写就没有

20:46.090 --> 20:47.690
我们平时之前都没有写

20:49.010 --> 20:49.690
都没有写

20:50.290 --> 20:51.170
那么这个函数

20:51.170 --> 20:52.250
它会接受一个参数

20:52.250 --> 20:53.450
就是文件路径

20:53.570 --> 20:56.170
就是你要对哪个文件进行解析

20:56.330 --> 20:57.890
对哪个文件进行处理

20:58.610 --> 20:59.610
经过loader进行处理

20:59.610 --> 21:00.290
它是文件路径

21:00.290 --> 21:01.330
它不是文件内容

21:01.570 --> 21:02.530
这是文件路径

21:02.890 --> 21:04.090
然后你可以返回

21:04.090 --> 21:05.130
也可以不返回

21:05.130 --> 21:06.010
可返回

21:06.010 --> 21:07.050
可不返回

21:08.170 --> 21:09.010
可返回

21:09.450 --> 21:10.810
可不返回

21:11.050 --> 21:12.450
那么如果说返回的话

21:12.450 --> 21:13.170
返回什么了

21:13.810 --> 21:14.970
如果返回

21:15.490 --> 21:16.370
返回

21:18.530 --> 21:18.970
代码

21:19.450 --> 21:20.050
原代码

21:21.130 --> 21:21.810
返回代码

21:22.890 --> 21:23.890
那么以后是字母串

21:23.890 --> 21:27.050
一个代码格式的字母串

21:27.130 --> 21:28.090
最后让你导出

21:28.090 --> 21:29.890
导出的时候就是exports

21:30.130 --> 21:30.570
loader

21:31.450 --> 21:31.690
对吧

21:31.690 --> 21:32.850
loader本质上就是函数

21:32.850 --> 21:35.170
只不过我们之前没有接触过这个pitch

21:36.090 --> 21:37.530
那么这个pitch是什么意思呢

21:37.650 --> 21:38.290
看一下这个图

21:38.770 --> 21:40.090
比方说我们用了三个loader

21:40.090 --> 21:40.610
loader1

21:40.610 --> 21:41.050
loader2

21:41.050 --> 21:41.450
loader3

21:41.450 --> 21:44.290
它的运行顺序是不是321这样的方式来运行

21:44.450 --> 21:44.730
对吧

21:44.730 --> 21:46.170
你看我们之前的做的是

21:46.410 --> 21:47.770
把资源的

21:48.010 --> 21:51.690
把资源的什么内容交给loader3

21:51.930 --> 21:53.290
然后它转换过后

21:53.370 --> 21:54.970
把它转换的内容交给loader2

21:54.970 --> 21:56.650
再把它转换的内容交给loader1

21:56.650 --> 21:57.890
然后把loader1转换的内容

21:57.890 --> 21:58.810
就直接拿去用了

21:58.810 --> 22:01.010
拿去做抽象与发动分析

22:01.010 --> 22:01.810
然后分析依赖

22:01.810 --> 22:02.090
对吧

22:02.090 --> 22:02.810
拿去用了

22:03.530 --> 22:05.450
实际上它前边还有个过程

22:06.610 --> 22:07.570
前边什么过程呢

22:07.570 --> 22:08.530
它一开始的时候

22:08.530 --> 22:09.650
会把一个文件路径

22:09.650 --> 22:11.650
比方说我们现在index的介绍文件

22:12.730 --> 22:14.210
index的介绍文件

22:14.210 --> 22:17.730
它会把这个文件路径交给loader1.pitch

22:18.730 --> 22:19.650
会交给它

22:20.090 --> 22:21.810
会交给这个函数来运行

22:23.370 --> 22:24.530
这么一个函数来运行

22:25.410 --> 22:26.130
它运行完了

22:26.130 --> 22:28.010
如果它没有返回结果

22:28.130 --> 22:28.970
交给loader2

22:28.970 --> 22:30.450
又把patch又交给loader2

22:30.770 --> 22:32.770
如果loader2也没有返回结果

22:32.770 --> 22:34.050
又把patch交给loader3

22:34.290 --> 22:35.610
如果loader3也没有

22:35.610 --> 22:37.450
pitch也没有返回结果

22:37.850 --> 22:39.450
那么就直接进入资源了

22:39.450 --> 22:40.570
读取资源内容

22:40.570 --> 22:42.810
把内容就跟之前的流程一样了

22:42.810 --> 22:44.610
所以我们之前讲的流程

22:44.610 --> 22:45.690
是这一部分流程

22:46.450 --> 22:47.290
是这一部分流程

22:47.290 --> 22:48.450
其实前边还有一个

22:49.450 --> 22:50.930
那么patch有什么用呢

22:50.930 --> 22:52.010
patch它的好处在于

22:52.010 --> 22:54.210
它可以通过适否返回

22:54.210 --> 22:57.530
来控制下一步到哪

22:58.370 --> 23:02.890
比方说如果说loader1的patch它返回了

23:03.490 --> 23:04.570
返回了会怎么样呢

23:04.570 --> 23:05.730
返回了就直接结束了

23:06.170 --> 23:07.170
它就回到上一个

23:07.210 --> 23:08.170
上一个它没有

23:08.170 --> 23:09.290
上一个就结束了

23:09.290 --> 23:10.210
它会把返回的

23:10.210 --> 23:13.490
作为代码交给就直接结束了

23:13.490 --> 23:17.010
如果说loader1的patch没有返回

23:17.010 --> 23:18.490
那么loader2的patch返回了

23:18.490 --> 23:19.370
它有一个返回值

23:19.370 --> 23:21.170
就这个patch的函数有返回值

23:21.170 --> 23:22.050
那么它就会把返回值

23:22.050 --> 23:23.170
直接交给loader1

23:23.170 --> 23:24.530
作为内容交给loader1

23:24.530 --> 23:27.210
loader1又转换过后结束

23:27.210 --> 23:28.890
所以它有这么一个过程

23:28.890 --> 23:31.490
因此在patchloader它是怎么处理的呢

23:31.490 --> 23:32.650
它就非常简单了

23:32.650 --> 23:33.770
patchloader它在这

23:33.770 --> 23:34.010
对吧

23:34.010 --> 23:35.290
它在第1个

23:35.290 --> 23:37.050
它看一下现在有没有缓存

23:37.130 --> 23:38.530
如果说没有缓存的话

23:38.530 --> 23:39.490
我就不返回

23:39.490 --> 23:40.010
对吧

23:40.010 --> 23:40.770
不返回

23:40.770 --> 23:42.490
那就经过正常的流程

23:42.490 --> 23:44.010
流程我走完了过后

23:44.010 --> 23:44.970
是不是又回到它了

23:44.970 --> 23:45.210
对吧

23:45.210 --> 23:46.370
回到正常的loader了

23:46.370 --> 23:46.570
好

23:46.570 --> 23:48.050
这里还是开启loader

23:48.050 --> 23:49.410
开启loader它又干嘛呢

23:49.410 --> 23:51.770
它就把这个内容缓存下来

23:51.770 --> 23:52.610
好结束

23:52.610 --> 23:52.890
好

23:52.890 --> 23:53.770
第二次的时候

23:53.770 --> 23:54.770
再来再进来

23:54.770 --> 23:55.770
它发现有没有缓存呢

23:55.770 --> 23:56.810
也有缓存了

23:56.810 --> 23:58.770
那么它就直接返回一个结果

23:58.770 --> 23:59.730
返回什么结果

23:59.730 --> 24:01.690
就把缓存文件读出来

24:01.690 --> 24:03.450
对应的缓存文件读出来

24:03.450 --> 24:05.330
把文件的内容作为结果

24:06.330 --> 24:09.010
它就那么就不会经过后续的过程了

24:09.010 --> 24:11.010
它就减少了后续的过程

24:11.010 --> 24:12.010
就这么个意思

24:12.610 --> 24:13.250
OK

24:13.690 --> 24:15.690
这是关于 catchloader

24:15.690 --> 24:16.970
讲一下它的原理

24:17.970 --> 24:18.370
好

24:18.370 --> 24:18.810
第三个

24:19.810 --> 24:21.890
就是开启多线程

24:23.050 --> 24:24.130
那么这个水的

24:24.130 --> 24:25.650
我们知道的加瓦スクリプス

24:25.650 --> 24:26.770
是单线程的语言

24:26.770 --> 24:27.210
对吧

24:27.210 --> 24:28.690
无论是在流量器环境里边

24:28.690 --> 24:30.610
还是在loader环境里边

24:30.610 --> 24:32.050
实际上发展到现在

24:32.050 --> 24:33.810
你们知道ATM5里边

24:33.890 --> 24:35.090
实际上已经可以支持

24:35.090 --> 24:36.930
这个就是webwork

24:36.930 --> 24:37.290
对吧

24:37.290 --> 24:38.050
webwork

24:38.050 --> 24:39.330
那么支持多线程了

24:39.330 --> 24:41.970
实际上loader.js里边也可以开启多线程

24:41.970 --> 24:43.810
只不过我们webpack

24:43.810 --> 24:45.850
它没有在多线程环境里边运行

24:46.490 --> 24:48.610
很多时候我们在解析一些

24:49.610 --> 24:52.090
用loader去解析一些模块的时候

24:52.730 --> 24:54.170
因为它解析的过程

24:54.170 --> 24:55.890
计算量特别特别大

24:56.890 --> 24:59.530
比方说我们有10个文件要解析

25:00.650 --> 25:03.090
有10个有10个.js文件

25:03.210 --> 25:03.970
要解析

25:04.650 --> 25:07.090
那么你会发现解析的过程就很慢

25:07.090 --> 25:09.250
因为它首先把第一个文件解析的

25:09.250 --> 25:10.130
才能去解析第二个

25:10.130 --> 25:11.250
才能去解析第三个

25:11.250 --> 25:11.770
对吧

25:11.770 --> 25:13.130
它得这么做

25:13.730 --> 25:17.530
所以说这个过程也特别的漫长

25:17.530 --> 25:21.210
因此我们可以利用多线程的来处理这个问题

25:22.570 --> 25:25.050
那么税的loader它会开启一个线程池

25:25.050 --> 25:25.850
什么叫线程池

25:25.850 --> 25:27.970
你可以把它想象成一块内存空间

25:27.970 --> 25:30.370
内存空间里边可以包含很多个线程

25:31.490 --> 25:32.770
那么包含多少个线程的

25:32.810 --> 25:35.410
我只能告诉你包含的是适量的线程

25:36.130 --> 25:39.690
一般来说我们开启的线程数量不能过多

25:39.690 --> 25:40.930
也不能过少

25:40.930 --> 25:41.730
过少的话

25:41.730 --> 25:43.770
比方说你是一个8核的CPU

25:43.770 --> 25:44.730
8核的CPU的话

25:44.730 --> 25:46.610
那么你的CPU的核就用不完

25:46.610 --> 25:47.210
对吧

25:47.210 --> 25:49.370
至少一个核可以同时处理一件事

25:50.690 --> 25:52.930
但是你核就用不完浪费了资源

25:52.930 --> 25:53.970
你开的太多的话

25:53.970 --> 25:56.290
你它都忙着在不同的线程之间切换

25:56.290 --> 25:58.370
核已经满负核运作了

25:58.370 --> 26:00.330
但是它在不同的线程之间切换

26:00.330 --> 26:01.450
也会浪费时间

26:01.850 --> 26:02.810
包含一个适量的

26:02.810 --> 26:03.690
什么叫适量呢

26:03.690 --> 26:09.570
就是差不多跟多核的CPU的线程数量

26:09.570 --> 26:11.610
就核保持一致就行了

26:11.610 --> 26:14.290
那么水的node在默认情况下

26:14.290 --> 26:15.290
你只要不去碰它

26:15.290 --> 26:16.210
不去配置它

26:16.210 --> 26:16.970
那么它就是

26:16.970 --> 26:17.610
默认情况下

26:17.610 --> 26:22.290
就是根据你电脑里边CPU的核来进行控制的

26:23.530 --> 26:24.570
我给大家看一下吧

26:24.570 --> 26:25.610
咱们node接试里面

26:25.610 --> 26:26.610
实际上是可以这样做的

26:28.010 --> 26:30.780
看一下

26:30.780 --> 26:32.260
node接试里面是可以获取的

26:32.260 --> 26:33.980
CPU的核的数量

26:35.180 --> 26:37.020
好像叫做OS

26:37.020 --> 26:38.100
就是操作系统

26:38.100 --> 26:40.700
操作系统里边它有一个CPU

26:40.700 --> 26:41.900
CPU

26:42.900 --> 26:43.940
有多少个CPU

26:44.940 --> 26:45.940
CPUS

26:46.860 --> 26:48.420
输出CPUS

26:48.420 --> 26:49.180
要看一下吧

26:50.700 --> 26:54.980
npmnodeTest

26:56.620 --> 26:57.140
你看

26:57.900 --> 26:58.900
是不是得到一个数捉

26:59.340 --> 26:59.820
这个数捉

26:59.820 --> 27:01.740
每一个数捉的每一项

27:01.780 --> 27:03.540
就是一个CPU的描述

27:03.540 --> 27:05.180
我用的是这个东西

27:05.420 --> 27:06.860
每一项就是CPU的描述

27:06.860 --> 27:08.620
那么我们这里的CPU点镭子

27:09.420 --> 27:10.540
看一下数捉的长度

27:11.820 --> 27:12.860
我就是8核的

27:12.860 --> 27:13.420
是吧

27:13.420 --> 27:14.140
这么个意思

27:15.300 --> 27:16.300
那么利用它

27:16.300 --> 27:17.420
就会开启多个线程

27:17.420 --> 27:19.540
那么线程的数量就跟那个CPU的核

27:19.540 --> 27:20.620
数量是一致的

27:21.380 --> 27:22.700
那么开启了线程之后

27:22.980 --> 27:23.940
它会把后续

27:23.940 --> 27:25.300
也就是它是不是要放前边

27:25.300 --> 27:26.780
跟开启node是一样的

27:27.020 --> 27:28.140
它把它放前边

27:28.460 --> 27:30.460
那么它后续的处理

27:30.580 --> 27:32.780
它就会放到线程词里边进行处理

27:33.500 --> 27:35.340
放到新的线程里边处理

27:35.820 --> 27:36.700
就这么个意思

27:37.740 --> 27:38.860
那么我们怎么来用呢

27:38.860 --> 27:39.900
我这里已经安装好了

27:39.900 --> 27:41.300
所以说我这里像

27:41.300 --> 27:42.300
这些可需要的东西

27:42.300 --> 27:43.140
那我就安装好了

27:44.900 --> 27:46.140
避免浪费可能的时间

27:46.300 --> 27:47.420
那么我们放到哪呢

27:47.420 --> 27:48.380
我们可以放到这

27:48.380 --> 27:50.380
就看你自己的怎么去想

27:50.620 --> 27:51.340
可以放到这

27:51.700 --> 27:52.580
sweetloader

27:53.540 --> 27:54.420
放到这的话

27:54.420 --> 27:56.220
那么这个东西在新线程里边

27:56.220 --> 27:57.940
那么这个东西也在新线程里边

27:58.180 --> 27:59.180
都在线程里边

28:00.740 --> 28:01.900
如果说你放到这呢

28:03.020 --> 28:03.820
那么指的是

28:03.820 --> 28:05.420
它不在线程里边

28:05.580 --> 28:07.060
但是它后边的东西

28:07.060 --> 28:08.060
它在线程里边

28:08.060 --> 28:08.980
就这么个意思

28:09.980 --> 28:10.700
那么你想一想

28:10.700 --> 28:11.700
如果说这种场景的话

28:11.700 --> 28:12.380
应该放到哪

28:12.980 --> 28:13.500
放哪

28:14.860 --> 28:16.180
是不是放这比较合适一点

28:16.180 --> 28:16.460
对吧

28:16.460 --> 28:17.580
放这比较合适一点

28:18.660 --> 28:20.980
因为我们主要的开销

28:20.980 --> 28:22.700
在于node的解析

28:22.700 --> 28:24.660
node就是对元代码的解析

28:24.660 --> 28:25.340
那么这个玩意

28:25.340 --> 28:26.780
实际上没有解析元代码的

28:27.060 --> 28:28.980
所以它没有必要去新开线程了

28:29.300 --> 28:30.020
没有必要了

28:30.940 --> 28:32.820
所以说我们放到这比较合适的

28:33.580 --> 28:35.100
那么这里我们再继续看一下

28:35.100 --> 28:36.660
sweetloader它有些限制

28:37.020 --> 28:39.100
就是sweetloader后续的node

28:39.420 --> 28:40.460
由于后续node

28:40.460 --> 28:42.100
它会放到新的线程里边

28:42.300 --> 28:44.420
所以后续node它不能做一些事情

28:44.460 --> 28:46.300
有些功能性丢失了

28:46.740 --> 28:47.900
因为我们知道vpack

28:47.900 --> 28:48.860
它是在单个线程

28:48.860 --> 28:51.020
只在这个介绍的主线程运行的

28:51.260 --> 28:52.780
因此跑到别的线程里边

28:52.780 --> 28:54.100
有些东西就用不了了

28:54.220 --> 28:55.020
线程都不一样了

28:55.020 --> 28:55.860
有些东西用不了了

28:55.860 --> 28:56.740
我只能讲到这

28:56.740 --> 28:59.140
因为你们没有去用过这些多线程

28:59.500 --> 29:01.260
所以我就讲讲点到机子

29:01.980 --> 29:03.100
那么哪些东西用不了了

29:03.100 --> 29:04.660
比方webpack的API

29:04.660 --> 29:06.540
去用webpack的API去生存文件

29:06.540 --> 29:07.780
我们之前都学过的

29:07.780 --> 29:08.780
webpack API里边

29:08.780 --> 29:10.140
不是我们当时来学过这么大码

29:10.140 --> 29:12.140
ZS, MS, file

29:12.140 --> 29:13.100
有些同学可能还记得

29:13.100 --> 29:14.140
就是生存一个文件

29:14.140 --> 29:14.420
对吧

29:14.420 --> 29:15.340
生存一个文件

29:15.580 --> 29:16.740
那么这个东西用不了了

29:16.980 --> 29:18.340
因为这个API不存在了

29:18.500 --> 29:19.740
换到线程过后了

29:19.860 --> 29:21.620
webpack很多API就失效了

29:22.540 --> 29:24.020
而且你不能自定义的

29:24.020 --> 29:26.500
使用自定义的pluntyAPI

29:26.500 --> 29:27.260
什么意思呢

29:27.340 --> 29:29.780
就是以前都没学过这么一个酷

29:29.780 --> 29:32.460
叫做mini extract

29:34.580 --> 29:35.780
mini CSS

29:35.780 --> 29:36.780
好像叫这个名字

29:36.780 --> 29:37.300
我看一下

29:37.740 --> 29:38.780
名字有点忘了

29:40.260 --> 29:41.980
就是提取CSS文件的

29:43.580 --> 29:44.460
CSS

29:45.140 --> 29:46.780
就这个文件

29:48.760 --> 29:49.640
如果大家不知道

29:49.640 --> 29:50.680
大家还有没有印象

29:51.000 --> 29:52.200
就这个插件

29:52.200 --> 29:53.320
它提供了两个东西

29:53.320 --> 29:54.160
一个是loader

29:55.040 --> 29:55.880
一个是插件

29:55.880 --> 29:56.360
对吧

29:56.880 --> 29:58.160
那么它的loader里边

29:58.160 --> 30:00.600
它就会用到插件里边本身的API

30:01.040 --> 30:02.800
那么它通过插件

30:02.800 --> 30:08.240
像webpack注入了一些新的API

30:08.840 --> 30:10.400
像webpack注入了一些新的API

30:10.400 --> 30:12.640
那么loader会使用

30:13.200 --> 30:15.520
会使用这些API

30:15.680 --> 30:15.920
对吧

30:15.920 --> 30:16.800
会使用它们

30:17.320 --> 30:18.440
那么这样这种loader

30:18.440 --> 30:19.200
也不能用的

30:19.200 --> 30:20.600
也不能放到它后面了

30:20.720 --> 30:22.000
因为它会使用这些API

30:22.000 --> 30:22.880
要爆错的

30:22.960 --> 30:24.040
补行里面去试一下

30:25.600 --> 30:27.680
无法访问webpack options

30:27.800 --> 30:29.360
无法访问它的一些配置

30:29.360 --> 30:31.680
webpack的配置里面的内容都无法访问的

30:32.680 --> 30:34.480
所以说它能够后面能够做什么事情

30:34.480 --> 30:35.080
放什么呢

30:35.080 --> 30:37.040
放那些非常非常纯粹的

30:37.560 --> 30:38.920
转换代码的东西

30:38.920 --> 30:39.880
像byboardloader

30:39.880 --> 30:41.040
就是非常纯粹的

30:41.040 --> 30:43.320
它自己有一套玩弄的东西

30:43.320 --> 30:44.680
来解析代码

30:45.240 --> 30:46.600
跟那个webpack没有本质

30:46.600 --> 30:48.320
没有什么就是隔开的

30:48.320 --> 30:50.240
没有什么关系

30:50.920 --> 30:52.200
那么以后你如果说

30:52.200 --> 30:53.480
你们要用这个东西

30:53.480 --> 30:54.880
我怎么知道哪些东西纯粹

30:54.880 --> 30:55.920
哪些东西不纯粹的

30:56.160 --> 30:56.600
是

30:56.960 --> 30:57.520
就是

30:57.720 --> 30:58.480
你看它

30:58.640 --> 31:00.240
自行测试来确定

31:00.240 --> 31:01.280
它放到什么位置

31:01.280 --> 31:01.920
因为这个东西

31:01.920 --> 31:03.160
我确实没法跟你们

31:03.360 --> 31:04.400
诸说你写的多了

31:04.400 --> 31:05.320
你自然就知道了

31:06.960 --> 31:08.400
而且那个sreadloader

31:08.400 --> 31:09.520
就是我放过来了

31:09.520 --> 31:11.600
大家可以感受一下

31:12.360 --> 31:13.800
我们把catch去掉

31:13.800 --> 31:14.400
它去掉了

31:14.400 --> 31:16.320
更加有利于大家感受一下

31:16.320 --> 31:22.330
sreadloader npx

31:23.650 --> 31:24.610
就这个玩意

31:25.130 --> 31:27.250
在小型项目里边的时候

31:27.690 --> 31:29.010
它不要说提高性能

31:29.650 --> 31:31.250
它反而会导致性能更慢

31:31.650 --> 31:33.970
跑了4秒多

31:34.490 --> 31:36.170
它反而会导致性能更慢

31:36.650 --> 31:37.050
为什么

31:37.410 --> 31:39.850
因为开启一个现成

31:40.450 --> 31:42.290
和管理现成

31:42.690 --> 31:43.890
那么需要消耗时间

31:43.890 --> 31:45.250
特别是现成之间的切换

31:46.170 --> 31:47.490
在小型项目里边

31:47.490 --> 31:48.650
如果说去使用它的话

31:48.650 --> 31:50.530
反而会增加构建事件

31:50.730 --> 31:51.490
你是小型项目

31:51.490 --> 31:52.530
就不要去使用它了

31:52.530 --> 31:53.890
你们大型项目里边

31:54.010 --> 31:56.370
主要大型项目里边的构建

31:56.370 --> 31:57.570
构建就是项目的时候

31:57.810 --> 31:59.810
你把所有的优化手段都做了

31:59.810 --> 32:01.890
发现构建速度还是慢

32:02.330 --> 32:03.530
还是慢怎么慢的

32:03.530 --> 32:05.210
adis可以尝试一下多现成

32:05.210 --> 32:06.330
说不定有惊喜

32:06.330 --> 32:08.930
它是起这么一个景上天花的作用

32:09.210 --> 32:10.570
你不能去乱用它

32:10.850 --> 32:12.130
它可能会增加害肖

32:12.890 --> 32:14.610
实际上开启多现成

32:14.610 --> 32:17.330
把loader放到多现成里边了

32:17.970 --> 32:19.850
不仅现在我们用的最多的

32:19.850 --> 32:20.850
就是sreadloader了

32:20.850 --> 32:22.250
其实以前还有个酷

32:22.250 --> 32:24.210
以前有个酷的叫做happy pack

32:25.490 --> 32:26.490
快乐打包

32:27.250 --> 32:30.090
有特别民间的一个酷

32:30.970 --> 32:31.930
那么这个酷

32:31.930 --> 32:33.810
它现在没有那么流行的

32:33.970 --> 32:35.010
现在没有那么流行的

32:35.330 --> 32:37.770
现在它都建议你去使用sreadloader了

32:38.490 --> 32:39.330
它现在每周下台

32:39.330 --> 32:40.330
让只有13万多

32:40.330 --> 32:42.290
sreadloader要多的很多

32:42.770 --> 32:43.170
看一下

32:43.570 --> 32:45.130
sreadloader

32:47.290 --> 32:48.370
这个酷还多很多

32:48.770 --> 32:50.050
周下台有100多万

32:50.930 --> 32:51.370
好吧

32:51.370 --> 32:53.570
那么这就是我们这节课要讲的

32:53.690 --> 32:55.370
三种优化loader

32:55.370 --> 32:57.570
让loader快一点快一点快一点

32:57.570 --> 32:58.770
有三种手段

32:59.530 --> 32:59.930
好吧

32:59.930 --> 33:01.450
那么这就是这节课的内容

