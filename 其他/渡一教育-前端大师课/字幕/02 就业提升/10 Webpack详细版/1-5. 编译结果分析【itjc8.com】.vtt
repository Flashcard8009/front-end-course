WEBVTT

00:01.140 --> 00:09.300
这节课咱们来对这个webpack 它的编译结果有它打包的结果来进行一个分析

00:10.660 --> 00:14.420
我们这里有两个文件啊 我已经把这个webpack安装好了

00:15.140 --> 00:20.060
这里有两个文件 一个是模块a 它输出了一句话 然后导出一个字幕刷a

00:20.740 --> 00:24.580
我这里呢 为了让我们分析了变的方便 我这里使用的是

00:25.580 --> 00:31.020
common.js的方式来导出的 好 这边呢 我们使用的是common.js的方式来导入的

00:31.340 --> 00:40.540
导入模块a 然后呢 输出模块导出的结果 这里呢 我们输出这个入口模块啊 就入口 入口模块啊index module

00:41.740 --> 00:45.300
好 那么接下来呢 我们就使用webpack来进行编译

00:47.020 --> 00:53.140
啊 我这里说一下啊 为什么我这节课要去分析一下它的webpack的导出结果呢

00:54.580 --> 01:00.940
主要的事让大家呢 对webpack呢 它的就是那种编译编译的结果呢 有一个认识

01:01.500 --> 01:10.900
这样子呢 对于我们后续啊 去分析它的编译过程是有帮助的 而分析编译过程呢 它会对我们后边学习webpack的一些

01:11.820 --> 01:20.620
像什么夹仔器啊 插筋啊 这种东西 你让你们大家去理解这些东西呢 是有帮助的 总之有帮助就行了啊 跟着跟着我学习就行了

01:21.180 --> 01:27.700
好 接下来我们使用啊 npm wrong 对啊 这里呢 我已经配置好了啊 就是这么一个名令

01:28.340 --> 01:34.000
ok 那么我们这里让它编译好 等它编译完成啊

01:37.780 --> 01:46.660
ok 编译完成了 那么在dash目录下面是不是出现了一个media gs 哎 这节课呢 咱们就是对这个media gs里边的内容来看一看它到底是啥

01:47.540 --> 01:53.700
啊 如果说我们这一块直接看的话 大家可能没有那么好理解啊 这一块内容到底是啥呀 乱七八糟

01:54.660 --> 01:57.060
一大堆好 那么这里呢 我们这样子来做

01:58.340 --> 02:02.020
假设这个media gs呢 我们自己写行不行

02:03.140 --> 02:11.380
啊 我们按照我们的想法 自己来写 看会写成是一个什么样子 写完了之后呢 我们再去对比这个media gs 啊 它到底是怎么回事

02:12.340 --> 02:17.620
好 我们再来分析一下啊 比方说我们这里来建立一个文件啊 比方说我们另外取个名字吧啊

02:18.660 --> 02:22.900
my maid的节课啊 比方说啊 我们自己写一个

02:23.620 --> 02:26.100
好 我们要做的啥事啊 我们要做的

02:26.820 --> 02:35.300
我们未拍的作用是不是根据一个入口文件 哪个入口文件 是不是index的GS 对吧 来分析出这个文件的依赖关系

02:36.180 --> 02:44.020
分析出完了过后呢 把这些依赖的文件依赖的模块呢 全部合并成一个文件 对吧 一个文件 这是未拍的

02:45.060 --> 02:46.980
作用 那么我们自己熟悉一下呢

02:47.780 --> 02:55.060
我们的入口文件是啥 是index的GS 它依赖谁 是不是依赖a 怎么依赖a 是不是这里有一个require 是不是依赖a

02:55.700 --> 03:04.420
所以说我们这里呢 要合并的模块 是不是有一个一个一个模块是index 一个模是a 对吧 所以说我们这个里边呢 是不是要合并两个模块

03:05.300 --> 03:06.740
合并两个模块

03:07.460 --> 03:09.380
一个是什么呢 一个是a模块

03:10.180 --> 03:19.140
一个是啊 我们最好了把目录也写上吧啊 一个是在src目录下 src目录下面的a.GS这个模块

03:19.700 --> 03:24.580
一个呢 是src目录下面的index的GS模块啊 这个排名不分先后

03:25.620 --> 03:27.220
啊 这里是不是要合并这两个模块

03:27.780 --> 03:36.580
好 合并的结果里边呢 要首先我们大家想一想啊 合并的结果里边呢 有没有什么common.GS 有没有什么s6的模块化

03:37.060 --> 03:42.820
根本就没有 我之前说过 它打包的结果呢 就是一个普普通通的GS代码

03:43.380 --> 03:46.260
啊 就是靠函数啊 就是最原始的GS代码

03:46.820 --> 03:50.100
因此呢 它不会不会存在任何的模块化的东西的

03:50.740 --> 03:54.660
所以说这一块呢 我们就要去思考 那么这里的模块化代码怎么办

03:55.380 --> 04:00.980
因为我们之前学过模块化 模块化这里边所有东西都不会影响权具变量 对吧 都不会污染权具变量

04:01.300 --> 04:04.260
那么同样的你在合并之后 你不能造成权具变量的污染

04:04.900 --> 04:10.900
啊 不能说你合并过后了 你变成这个样子的啊 有人呢可能觉得很简单啊 哎 我把这个a的这个东西一复制

04:11.220 --> 04:14.580
哎 粘贴过来 然后呢 这个index一复制粘贴过来

04:15.300 --> 04:20.740
哎 我们最多修改一下吧 对吧 最多修改一下 修改什么了 这里不是导出a吗

04:20.980 --> 04:25.300
那么我这里不是导入这个a吗 ok 那么我们就把这个东西直接复制过来

04:26.420 --> 04:33.300
直接复制过来吧 这个东西删掉 好像看上去 哎 也差不多对吧 也差不多 是不是就可以运行 但是你这样子的话

04:33.700 --> 04:39.060
是不是就导致了什么呢 导致了权具变量的污染 因为你这里是不是就有个权具变量了

04:39.620 --> 04:43.780
对吧 所以说我们首先要搞定这个问题 那么这个问题怎么来解决呢

04:44.500 --> 04:52.740
我们回忆一下模块化的 就是之前学习的模块化 那么在common.js里边 他在node环境里边 他怎么来实现模块化的

04:53.620 --> 04:59.780
是不是把这些单码都放到一个函数环境里边去执行 对吧 是吧 这些放到一个函数环境里边执行

05:00.340 --> 05:04.180
那么这里有两个模块 那么每一个模块是不是就相当于是

05:04.900 --> 05:10.900
运行这个模块 就相当于是在运行一个函数 运行这个模块 是不是就相当于是在运行一个函数

05:11.780 --> 05:18.420
你要的意思吗 他把每一个模块的东西放到函数环境里边执行 那么这里呢 我们就可以 我们能不能这样子来做

05:19.220 --> 05:20.740
我们定一个变量啊 Marjus

05:21.780 --> 05:25.940
啊 这个变量了一会呢 我肯定 当然这个也会污染权具啊 一会我们会处理 不着急

05:26.580 --> 05:33.620
我们就写成一个对象的格式 有几个模块呢 有两个模块 第一个模块是这个 对吧 我们把它作为属性名

05:34.580 --> 05:40.660
我们可以这样做啊 就这个模块啊 我们可以认为了这个是模块的路径啊 它作为一个属性名

05:40.980 --> 05:47.620
那么这个模块呢 因为每一个模块的路径是唯一的嘛 对吧 是不是唯一的 每一个模块的路径是不是唯一的

05:47.780 --> 05:51.300
那肯定是唯一的呀 所以说 我把它作为一个属性名 那么这个

05:51.700 --> 05:54.260
只要通过这个属性名 是不是可以找到一个唯一的模块

05:54.740 --> 05:58.180
那么这个模块是啥呢 是不是就是可以把它写成一个函数

05:58.740 --> 06:03.700
对吧 然后把模块代码放哪呢 是不是把模块代码放到这个函数环境里边

06:04.180 --> 06:07.140
对不对 是放到函数环境里边 这样不就完了吗

06:08.100 --> 06:13.060
那这个函数里边 它不是用到什么margeo吗 对吧 margeo 它用到这个东西 那么

06:13.620 --> 06:18.500
在一个普通的解释环境里边 有没有这个东西啊 肯定是没有 那么这东西哪来的呢

06:18.900 --> 06:26.900
我们是不是就可以使用函数的参数给它传进来 对吧 你不是没有margeo吗 对吧 我给你传进来

06:28.100 --> 06:32.900
这里边 common解释里边 它还有可能会写这种代吗 是不是还有可能会写这种代吗

06:33.460 --> 06:37.460
对不对 那么也就是说它还可以 可能会直接使用export

06:37.780 --> 06:42.580
那么这里呢 我也是一样 我让margeo给你传进来 把这个export呢给你传进来

06:43.380 --> 06:50.100
是不是传进来就可以使用了 通过函数参数给你传进来 那么这参数是谁给的 它呢 我先不着急啊 我先把它写成这么一种格式

06:50.740 --> 06:56.820
一看一下是不是这个符合逻辑了 那么这样子呢 至少这个每一个模块里边的代码是不是没有五转圈就变亮

06:57.860 --> 07:01.620
没问题吧 好 同样的道理啊 那咱们再去写这个

07:02.580 --> 07:03.780
index.js

07:05.540 --> 07:08.100
方可行 是不是也可以写成这种模式

07:09.300 --> 07:13.700
对吧 是不是也可以写同样的函数 我们直接把index.se代码复制过来

07:14.740 --> 07:15.700
复制过来

07:15.700 --> 07:21.860
那么但是index.se ds里边 虽然说它没有用到这个东西 但是它可不可以用 可以用

07:21.860 --> 07:26.660
所以说这个两个东西也还是得给它 但是它里边还用到一个东西叫做require 对吧

07:27.140 --> 07:32.580
require 还用到了这个东西 那么也就说我们这里是不是还要给它提供一个require函数

07:33.380 --> 07:35.300
还要给它提供一个require函数

07:35.940 --> 07:43.860
这样子 那是不是就可以了 你看这里的变量是不是不会五转圈据了 你看 这是模块 这个模块代码把它放到一个函数环境里边

07:44.180 --> 07:49.620
然后这是这个模块代码 把它放到一个函数环境里边 对吧 就没问题了 对不对

07:50.500 --> 07:57.780
然后呢 这里呢 我们再去稍做一些改动 我们这里呢 你看啊 它在使用哪个模块 第2斜杠A

07:58.260 --> 08:01.860
那么这个A呢 相当于是哪个模块 是不是相当于是这个模块

08:02.580 --> 08:07.620
对吧 是不是这个模块 这个是模块的唯一的路径 对吧 每一个模块它对应一个唯一的路径

08:07.940 --> 08:11.460
我们只需要把这个require把它变到这 就行了

08:12.740 --> 08:16.340
就是用统一的路径 用统一的路径书写方式

08:16.820 --> 08:21.940
把它更改一下啊 这些呢 未拍个都可以都可以处理的 我们现在不不用去管未拍个

08:22.020 --> 08:26.820
就说我们手动手工来合并这两个文件的话 我们该怎么来合并 是不可以这样的合并

08:27.380 --> 08:29.140
每一个模块对应一个唯一的路径

08:29.700 --> 08:33.540
它对应它对应的是什么呢 一个函数 函数里面就是模块化里边代码

08:34.020 --> 08:38.020
每一个模块对应一个唯一的路径 它对应一个函数 函数里面就是模块化里边代码

08:38.420 --> 08:44.420
那么里边代码在require的时候呢 require哪来的通过函数参数传进来的 怎么传 我们现在还不知道啊

08:44.500 --> 08:50.660
还没还没有去分析到那 内不来 但是呢 我们可以知道啊require的时候呢 我们要给它一个模块的唯一路径

08:51.140 --> 08:55.460
就不能用之前的那种写法 之前的那种写法呢 分不清楚啊 分不清楚到底用的是哪一个模块

08:55.940 --> 09:02.260
那么到时候呢 你可以想象 我们用了唯一路径的时候呢 是不是可以在这个模块里边找 这个对象里边找找什么呢

09:02.980 --> 09:06.740
找 通过这个路径是不是可以找到一个函数去运行 对吧

09:07.700 --> 09:13.780
好 那么这样子呢 就形成了一个模块的对象 这个对象里边呢 就包含了所有的模块

09:14.740 --> 09:24.850
该对象中 我们起到这了 该对象啊 保存了所有的模块

09:25.730 --> 09:35.330
以及模块对应的呃代码 对吧 是不是对象里边就保存了所有 我们要合并两个模块嘛

09:35.330 --> 09:36.690
所以就把它保存到对象里边了

09:37.650 --> 09:40.690
那么这个对象交给谁呢 交给谁来处理呢

09:41.410 --> 09:44.530
我们可以专门来写一个函数来处理这个对象

09:46.290 --> 09:47.090
专门来写个函数

09:48.130 --> 09:50.850
比方说 我们这里呢 来写一个匿名函数

09:51.490 --> 09:55.890
因为我们尽量的去避免污染全局变量 你把模块的对象给我

09:56.850 --> 10:03.330
哎 我们直接运行 对吧 是不是一个立即执行函数 你只要把这个模块给我啊 把这个marge use给我

10:03.890 --> 10:09.330
ok 我来来处理这里边的所有模块 好 那么我这里呢 是不是就可以直接把这个东西传进来

10:09.730 --> 10:12.370
对吧 直接把这个东西传进来 是不是就把这个东西给他了

10:13.330 --> 10:21.010
哎 那既然你写到这的话啊 你跟着我收走啊 可能有些同学呢 听见了你为什么要这样子写呢 我写完了你就明白了啊 不要着急 你跟着我

10:21.170 --> 10:25.490
是失路走 因为这里一块呢 你们肯定是想不到的 你自己去想肯定是很难想象得到的

10:26.050 --> 10:28.930
好 那么这里呢 是不是又出现了一个全局变量污染

10:29.570 --> 10:37.330
这里会是不是出现了一个全局变量污染 好 那么既然它污染了 我能不能这样子呢 我就不污染呗 我直接把这个对象作为自变量传进来行不行

10:38.290 --> 10:41.970
所以可以这样做 这样子是不是没有污染任何的全局变量

10:42.450 --> 10:47.010
同时呢 又把这个模块构建好了 对吧 所有的模块全部保存在一个对象里边

10:48.370 --> 10:55.250
全部保存在一个对象里边啊 模块的路径 模块的寒树 模块的路径 模块的寒树 保存在对象里边 然后呢 把这个对象呢给谁给这个

10:55.970 --> 10:57.250
立即 立即执行寒树

10:58.370 --> 11:00.450
那么这个寒树里边干嘛呢 这个寒树

11:01.170 --> 11:07.330
这个寒树它要提供什么呢 它就要去提供一个东西 就是require这个寒树

11:07.970 --> 11:11.970
就它里边要做一个寒树出来 这个寒树的名字叫做require

11:12.450 --> 11:18.130
因为模块代码里边 模块代码里边肯定要去引用其他模块 到时候你要执行模块 对吧

11:18.450 --> 11:23.010
因为立即执行寒树嘛 我们有一个入口文件 入口文件是什么呢 入口的模块是不是它

11:23.330 --> 11:24.530
所以说我们一定会

11:25.650 --> 11:30.290
执行在这个寒树里边 因为立即执行寒树嘛 一定会执行入口模块

11:31.010 --> 11:35.410
是不是一定会执行它 而执行一个入口模块是不是就是一个require

11:36.370 --> 11:41.170
什么呢 第二鞋杠srcindex的解释 是不是就要做这么一件事 对吧

11:41.650 --> 11:48.290
你看啊 我们用这个寒树 这个寒树是不是相当于是require寒树

11:48.850 --> 11:51.650
你想那个道理啊 模块导入这个寒树

11:52.210 --> 11:53.650
相当于是

11:54.690 --> 11:56.530
导入什么呢 导入

11:57.090 --> 11:59.490
相当于是运行一个模块

12:00.690 --> 12:04.370
而且呢 得到模块导出结果

12:05.250 --> 12:08.130
回忆一下我们之前学习的common.js 是不是

12:08.530 --> 12:16.290
导入模块 是不是就相当于是运行一个模块 得到模块导出结果 那么我们一开始就要运行入口模块 是不是一开始要去require一次

12:17.010 --> 12:21.570
只不过呢 这个时候require这个寒树有吗 有这个require寒树吗 是不是没有

12:21.890 --> 12:26.370
没有的话 我在这里是不是可以写这么一个require寒树啊 是不是可以写一个

12:27.090 --> 12:28.290
写一个require寒树

12:29.010 --> 12:34.690
那么这个寒树要接受什么呢 是不是接受一个模块的路径啊 我们把它叫做marge ID

12:35.090 --> 12:41.330
叫做模块ID 就是模块唯一的唯一的东西 唯一的东西不就是个路径嘛 对吧 每一个模块的路径是唯一的

12:41.490 --> 12:43.090
所以我们把它认为模块ID

12:44.050 --> 12:47.250
这个这个寒树是什么作用呢 这个寒树的作用就是把它写上了

12:49.200 --> 12:54.000
这个寒树就相当于是运行一个模块的让模块的导出结果 那么这个marge ID

12:54.160 --> 13:04.080
就是模块的路径 模块的路径 因为每个模块的路径是唯一的 那么我们只要把这个require寒树实现

13:05.120 --> 13:10.080
是不是就完了 对不对 好 咱们来实现这个寒树啊 这个寒树其实特别简单

13:10.800 --> 13:16.800
怎么个简单法呢 你想啊 这里有一个模块ID给我了 那我是不是可以通过

13:17.040 --> 13:21.280
你这里不是把所有的模块全部给我了吗 你看这个对象是不是把所有的模块全部给我了

13:21.760 --> 13:25.440
所有的模块全部给我了 之后呢 我只要能够通过这个模块ID

13:26.560 --> 13:30.480
是不是就可以 相当于这个是个属性名 是不是可以通过这个模块ID

13:30.880 --> 13:33.040
从这个marge物使里边 是不是可以读出

13:33.760 --> 13:35.920
相应的模块寒树 对吧

13:36.640 --> 13:41.120
哎 那么这里这里呢 是不是可以读到模块的相应寒树

13:43.280 --> 13:45.600
就得到该模块

13:46.560 --> 13:51.120
通过这个模块路径得到该模块对应的寒树 是不是可以得到寒树

13:51.520 --> 13:55.280
那么这里呢require要运行这个模块 是不是就相当于是要运行这个寒树

13:55.680 --> 13:59.520
哎 我们直接运行就完事了啊 运行这个寒树 这个寒树要提供什么参数

13:59.920 --> 14:05.280
是不是有可能有三个参数 对吧 三个参数都给他 一个是marge 一个是export 一个是什么require

14:05.760 --> 14:11.200
是不是这三个东西都要给他 好来吧 第一个参数 marge 我们勾造一个呗 你不是没有吗

14:11.200 --> 14:13.760
ok 我给勾造一个啊 勾造一个marge

14:14.560 --> 14:16.400
可以吗 当然可以啊 当然可以

14:16.880 --> 14:19.520
好 我给你勾造一个marge marge等于什么呢

14:19.760 --> 14:25.120
他就是一个普通对象 就是一个普通对象 他里面有个什么属相 一个export的属相 对吧

14:26.560 --> 14:29.760
export是个属相 这个属性呢也是默认一个对象

14:30.480 --> 14:35.920
也是默认一个对象 对吧 marge marge 就是这样子一个格式 没有什么了 没有什么别的东西了

14:36.800 --> 14:39.920
那么他一个marge 一个是export对象 那么这里边

14:40.640 --> 14:42.960
那么funk里边我们是不是可以把marge传进去

14:43.680 --> 14:48.960
对不对 是不是可以把marge这个东西传进去 当然可以传进去啊 不就是一个普通对象吗

14:50.000 --> 14:55.680
然后呢 他里边的export呢 如果说你要用一些啊 比方common.js 你可以直接使用export 对吧

14:56.080 --> 15:00.480
你可以直接使用export 为什么呢 因为我第二个参数呢 我就把这个东西给你传进来

15:01.360 --> 15:06.960
margeexport 是不是直接把个对象给你传进来 对吧 你两个都可以用啊 两个都可以用

15:07.840 --> 15:09.760
是不是这样子就可以了 对不对

15:11.200 --> 15:14.960
好 然后呢 你看看就第一个是传整个marge对象

15:15.440 --> 15:19.440
第二个呢 是把人家margexport 就是把这个对象引用给你传进来啊

15:19.680 --> 15:26.480
也就是说跟common.js是一样的 那么就相当于是什么呢 就相当于是我这里又定义了一个export

15:28.080 --> 15:30.160
等于什么margexport

15:31.120 --> 15:35.440
然后呢 把这个export呢给你传进来 是不是一样的 又啥区别呢 对吧 又啥区别呢

15:35.760 --> 15:40.080
都是传的引用 对吧 都是把这个对象引用给他 然后再再通过参数给他

15:40.480 --> 15:45.360
啊 你可以也可以直接把这个表达是把这个对象引用给他 都是一样的啊 都是一样的

15:46.240 --> 15:52.640
你要的意思吗 好好去想一想啊 好好去评一评再对比一下之前的common.js 就是这么就是这么一个逻辑

15:53.280 --> 15:59.360
好 那么第三个参数是什么 第三个参数就是不是就requirerequire就是不是就是这个函数 okay 我就把这个函数传给你

16:00.800 --> 16:06.880
哎 那么你去搞定吧 你不是有个函数吗 我现在就 我现在要运行这个模块 我就把模块的函数找到

16:06.960 --> 16:11.120
然后去调用这个函数 我把我的这个marge给你构建好 这东西全部给你构建好

16:11.520 --> 16:17.920
构建好了require也给你 你怎么去运行你随便你 好总之你运行运行完了之后

16:18.560 --> 16:26.240
我怎么来获取这个模块的导出结果呢 是不是运行完了之后 我们通过这个marge的exports 是不是就可以得到模块的导出结果了

16:26.880 --> 16:30.560
你看啊 比方说啊 我们运行的是rook模块 他这个模块

16:31.600 --> 16:36.720
比方说我们运行的是这个模块啊 这个模块运行完了过后 那你看一下他是不是对marge的exports

16:37.120 --> 16:42.640
重新复制了 重新复制了过后 我这里再去得到marge的exports 是不是就可以得到得到

16:43.120 --> 16:48.160
他导出的结果了 那么这就是模块的导出结果 对吧 是不是就模块的导出结果

16:48.480 --> 16:54.640
那就这么简单 然后呢 我把这个导出结果干嘛呢 保存到一个变量里面啊 就是模块的导出结果

16:57.520 --> 17:01.040
得到 这上面这句话就是运行模块

17:01.840 --> 17:10.560
然后得到模块导出的结果 结果 然后呢就require这个函数要干嘛 require这个函数是不是要把这个导出结果返回

17:11.120 --> 17:14.640
对吧 那么我们这里用return result 是不是把这个导出结果就返回了

17:15.360 --> 17:19.600
就这么简单 真的就这么简单 一点都不复杂 就写完了

17:20.240 --> 17:24.240
咱们来试一下呗 我们这里去建立一个index的页面

17:26.780 --> 17:36.020
好 这里呢 好 这里运行啊 然后呢 埋媚了解释 你看一下 两个模块有没有合并啊 有没有合并

17:37.300 --> 17:40.820
这样子通过这种方式就把合并出来了啊 检查

17:44.020 --> 17:48.100
好 你看是不是又运行了 因为这个是margeal margeal a啊 a

17:48.660 --> 17:54.740
是不是运行出来了 相当于是啊 我们这执行入口模块 然后模块a还要导入a 那么又运行了a

17:55.220 --> 18:00.660
所以你看 又运行了margeal a 然后呢 它导出了a 它导出了a过后呢 把a放到这儿来了

18:00.660 --> 18:04.100
然后又输出a 是不是就输出了模块 导出了结果 a 对吧

18:04.660 --> 18:07.780
是不是运行出来了 就这么写 而且整个这个过程有没有

18:08.340 --> 18:12.580
有没有无暂任何的选举变量 并没有 因为是一个立即执行函数

18:12.580 --> 18:14.580
它就通过这种巧妙的方式来搞定的

18:15.620 --> 18:20.660
当然呢 这里的写法上面还有一些不太完善 比方说模块不是有缓存吗

18:21.140 --> 18:25.620
哎 如果说反复导入同一个模块啊 如果说到时候用require反复导入同一个模块

18:25.620 --> 18:30.020
那每一次都要去运行一下这个函数 跟我们的command界是不一样啊 它不是有缓存吗

18:30.500 --> 18:37.460
缓存简单呀 缓存我就这样呗 我就这样呗 那么我这里定义的变量啊 就用来做缓存

18:38.020 --> 18:40.180
就是把他取名为啊

18:41.220 --> 18:43.220
margeal export

18:44.660 --> 18:49.220
啊 他是个对象 用于缓存啊 用于缓存

18:49.940 --> 18:50.580
模块

18:52.020 --> 18:58.420
的导出结果啊 每一个模块导 只要模块导入了导 就是导入了一系统一个模块 我就把它缓存起来

18:59.060 --> 19:07.540
所以说你在导入的时候干嘛呢 首先检查有没有对应的缓存 那么这里边写的是啥呢 这里边就相当于是用这种解法啊 模块的id比方说啊

19:08.180 --> 19:11.220
del src a.js 这是模块的id

19:11.540 --> 19:16.900
然后它的导出结果是什么呢 就是一个a 对吧 还有可能是个对象 有可能是任何一个有可能是个函数 有可能是任何一个东西

19:17.140 --> 19:25.860
无所谓 总之呢 他导出结果就缓存在这 对吧 我们就这样子方式在写 所以说我们在导入的模块的时候呢 导入模块的时候 首先判断一下有没有缓存

19:26.660 --> 19:32.420
margeal export 有没有这个margeal id啊 检查是否有缓存

19:33.700 --> 19:34.900
是否有缓存

19:36.180 --> 19:40.820
好 如果有缓存的话 我们直接就返回结果了 我就不去再重新运行这个函数了

19:41.540 --> 19:42.580
直接返回这个结果

19:43.540 --> 19:52.340
对吧 好 如果没有缓存的话 OK 那么我们去得到模块的运行函数 然后呢 去运行函数 得到函数 得到这个模块的导出结果

19:52.420 --> 19:58.020
然后把这个模块导出结果缓存起来 好 缓存 那么我们这里就是margeal export

19:58.500 --> 20:02.100
好 margeal id 是不是把这个结果缓存起来

20:03.140 --> 20:03.860
缓存起来

20:05.140 --> 20:09.380
啊 那么这样子呢 我们如果说导入了多次导入同一个模块的话 那么

20:10.100 --> 20:16.820
他不会啊 他不会运行多次 比方说我们下面啊 在多次去导多次去运行一个a模块

20:16.980 --> 20:22.100
你看一下 他有没有同 有没有反复运行 margeal a 没有 因为有缓存结果了

20:22.820 --> 20:27.860
这样的意思吗 OK 那么这里呢 是不是就写完了 就这么简单单吗 其实一点都不复杂

20:28.420 --> 20:35.780
这就是他的 嗯 把合并之后的代码 没有污染任何全局变量 他通过这种巧妙的方式来把模块合并在一起

20:36.180 --> 20:45.060
好 嗯 然后呢 有一个细节就是他为了避免啊 为了避免这个require函数呢 跟loader环境下面的require函数重名

20:45.300 --> 20:50.340
所以说呢 这个地方呢 他把函数的改了一下名字 这个名字改了什么呢 改成了这个叫做

20:51.780 --> 20:52.500
webpack

20:53.220 --> 20:55.220
require 改成了这么一种格式

20:56.820 --> 21:01.780
他把这个require函数呢 改了一个名字啊 就改成了webpackrequire 那么这里呢也改了一个名字

21:02.020 --> 21:09.940
同样的道理 你模块里面凡是使用require的地方了 把它改成webpackrequire 那么效果肯定是一样的 没有什么区别 只是改了一个函数名字而已

21:11.380 --> 21:14.660
ok 那么这就是他编译结果的代码格式

21:15.380 --> 21:22.820
好 我们通过自己去分析 然后自己去写了一遍啊 你先把这个代码格式看懂 然后呢 我们再去看媒体结实你就会发现

21:23.940 --> 21:28.420
容易看懂了 我把这些注释乱七八糟的东西给大家删掉

21:31.710 --> 21:32.430
好 稍等啊

21:33.950 --> 21:37.470
我把这些东西乱七八糟给他删掉 这些注释删掉

21:38.110 --> 21:45.630
好 然后呢 这些东西啊 这些东西是为了适应一下一些别的别的模块化标准的啊 这些东西我们直接给他删掉

21:46.270 --> 21:54.750
啊 这些东西我们干到下 我们要删掉 我们只保留他核心的代码啊 只保留他核心的代码

21:56.430 --> 21:57.310
好 咱们来看一下

21:58.190 --> 22:08.370
你会发现他代码格式呢 是差不多的 下面把这些注释改删掉 那么大家就可以看得很清楚了

22:12.190 --> 22:12.510
ok

22:14.270 --> 22:22.830
稍等啊 打删一下 好 格式画一下 你看 看得很清楚 这里有一个函数

22:23.790 --> 22:33.230
这里有一个函数 Marjus 那么他接收所谓的模块 那么这是不是一个立即执行函数 对吧 立即执行 你看在这里是在调用 对吧 立即执行这个函数

22:33.870 --> 22:37.710
然后呢 这个函数里面是不是传了个对象进来 这个对象里面是不是每一个模块

22:39.150 --> 22:44.270
src.src.index.js 对吧

22:44.830 --> 22:50.270
好 那么每一个模块里面是不是有个函数 对吧 他只能用个小括号给你扩起来了啊 你不加小括号也可以

22:51.390 --> 22:57.230
是不是有一个函数 每一个模块他是不是对应一个函数 也就说我们的模块里面代码 他放到函数环境里面执行了

22:57.710 --> 23:05.230
好 那么我们的模块代码在哪呢 在这 他是放到eva里面的 他是放到eva里面的eva 我们知道啊 在js里面 他可以把一个制服串

23:05.470 --> 23:11.150
当成一个代码来执行 至于他为什么放eva 我们一会再解释啊 我们先看这个代码格式 好 那么这里呢

23:11.710 --> 23:14.750
我们把它写出来嘛 你看 写出来就是变成这个样子

23:15.550 --> 23:21.950
因为他代码也不多 我直接把它写出来 好 这里换行 对吧 这里换行 然后呢 我们看一下啊 Marjus.exports

23:22.910 --> 23:25.310
啊 Marjus.exports

23:27.710 --> 23:29.870
ok 那么接下来呢 后边呢

23:30.990 --> 23:38.350
没了 对吧 后边就没了 后面是一些注释啊 后面是一些注释 没了 好 没关系 我们一会再看这个这个东西 一会再去看这个东西

23:40.190 --> 23:45.790
好 接下来这里啊 这里 下面呢 我们也是common介绍把个这个代码写出来

23:46.750 --> 23:48.110
又看了 看了清楚一点

23:49.150 --> 23:53.630
好 这里把去掉啊 然后这一行 这一行代码

23:54.990 --> 24:04.000
ok 好 这里呢 注释呢 去掉 然后呢 这里console夹过来

24:07.740 --> 24:12.380
好 那么他形成的也就是这种代码 你看一下这个代码跟我们刚才写的那个mime

24:12.700 --> 24:14.860
是不是一样的 你对比一下

24:15.980 --> 24:18.380
是不是一样的 有什么区别呢 对吧 他只不过吧

24:18.860 --> 24:23.500
只不过这边呢 他一开始是把它放到eval里面的 他为什么放到eval里面 我们一会再说啊 一会再说

24:24.060 --> 24:27.580
好 那么这里呢 你看是不是一样的 好 那么他把这个东西传进去了

24:27.900 --> 24:32.540
好 传进去过后 他怎么处理的 是不是他这里边 我这里边用了变量的名字叫做multi-exports

24:32.540 --> 24:37.900
对吧 用于缓存 他这里边用了变量的名字 变量名字改了一下 改了变成了什么呢

24:38.460 --> 24:43.500
变量的名字是installed啊 就是已经夹载过的模块 是不是也是缓存的意思

24:43.980 --> 24:51.820
对吧 所以也是缓存的意思 好 那么这里呢 有一个webrequire函数 你看这里是不是webrequire函数 传一个模块id进来

24:52.700 --> 24:58.140
那么由于我们要一开始就要执行入口模块 是不是一开始 只不过他这里呢 用了一个return

24:58.700 --> 25:03.740
他这里用了一个return 只不过这个return呢 目前没有什么用啊 以后呢 学到一些webpack

25:03.820 --> 25:09.260
派个高级概念的时候呢 是有点用的啊 就是把这个立即执行函数返回个结果 我这里没有用return而已

25:09.980 --> 25:17.900
目前的return他也是没有什么用的 那么也就是说 一开始就是调用这个函数 把什么东西给他 这里一个负值表达式 我们知道一个负值表达式

25:18.780 --> 25:23.820
它的结果是不是就是负的值 就整个这个表达式的结果 是不是就是这个负的值

25:24.940 --> 25:30.060
那么这一块呢 你不用管啊 这块是为了适应其他模块化的东西 其他模块化标准而做的

25:30.460 --> 25:32.860
不用管 那么我们可以把简化一下 是不是就相当于是这个

25:33.500 --> 25:38.700
对吧 好 执行 一开始执行这个入口文件 为什么 因为摸的入口文件就是index的介石

25:39.260 --> 25:44.860
好 那么这个函数里边怎么写的呢 你看 首先看一下有没有模块 我这里我看一下啊

25:46.460 --> 25:51.900
我这里好像写 没关系啊 他的这个写的有点差异啊 有点差异 我们看一下吧

25:52.700 --> 25:55.580
首先看一下有没有这个模块啊 有没有缓存这个模块

25:56.060 --> 26:02.620
有缓存这个模块的话 他就把这个模块里边的exports返回 那么他这个模块我跟我们这边有点差异啊

26:02.860 --> 26:07.420
我们这边是要我尽量把它简化的 他这边是怎么做的呢 他这边是这样的格式

26:07.820 --> 26:08.940
比方说src

26:09.580 --> 26:14.940
a.gs 他里边本来应该是模块导出的结果 对吧 他不是这样做的 他这里边是一个对象

26:15.660 --> 26:21.980
他是一个对象 这个对象里边有三个属性 一个是i 表示模块的id 模块的id是什么呢 就是src

26:22.300 --> 26:23.340
a.gs

26:24.620 --> 26:27.420
另一个呢 是l 表示模块式讽加载完成

26:28.380 --> 26:35.420
他这里直接为2就表示加载完成 第三个exports呢 才是模块导出的结果 a 模块导出什么结果 是不导出 a

26:35.820 --> 26:40.460
对吧 他是这么一种格式啊 他是这么一种格式 他用这种格式呢 目前呢

26:40.940 --> 26:45.820
肯定是没有我们这种格式更加简洁 只不过呢 他是为了处理一些其他的问题 不用管 不用管

26:46.140 --> 26:46.940
这个东西不用管

26:48.940 --> 26:54.940
那总之呢 他这里边是不是一定可以通过通过他来找到缓存 是不是找到缓存的这个结果

26:55.180 --> 26:57.900
对吧 这个东西表示模块式讽加载完成 这个东西表示

26:58.620 --> 27:01.340
模块的id 其实id直接读这儿也可以

27:02.060 --> 27:06.380
别人的意思嘛 那么总之呢 他是这么一种格式啊 把注射掉吧

27:07.500 --> 27:14.140
于是呢 他在这儿 你看 是不是得到导出了一个结果啊 把这个东西啊 把这个东西对应的exports就导出

27:14.380 --> 27:14.700
返回

27:15.420 --> 27:19.660
require寒数 如果有缓存就把缓存返回 如果没有缓存呢

27:20.540 --> 27:23.820
如果说没有缓存呢 没有缓存呢 他就直接给他

27:24.300 --> 27:30.300
加一个缓存啊 通过这个模块id加一个缓存 只不过呢 一开始呢 缓存没有加载完成 他这个l是forced

27:30.780 --> 27:36.060
表示loaded 表示适逢加载完成 他一开始是forced 然后再复制给一个变量margeau

27:36.940 --> 27:41.660
好 然后 接下来他做的事情跟我们那边就一样了 通过什么margeaus

27:42.300 --> 27:42.860
通过这个

27:43.740 --> 27:47.340
来得到模块对应的函数 就得得到这个模块对应的函数

27:47.900 --> 27:49.660
然后呢 core 是不是调整函数

27:50.300 --> 27:56.780
调整函数 他第一个传Zis啊 zis 他这里呢 用的是把margeau.exports变成Zis啊 变成Zis

27:57.180 --> 27:57.660
然后呢

27:58.300 --> 28:02.380
这里margeau.exports传进来 你看这里是不是一样的 对吧

28:02.780 --> 28:06.140
我们这里呢 无非就是没有用core 而是直接调用的 对吧 他这里边

28:06.700 --> 28:14.220
考虑到zis的情况 所以说他把这个东西作为zis传进去 所以说你在模块内部你使用zis的话 使用的是 将来是使用的是他

28:15.340 --> 28:15.740
看到没

28:16.220 --> 28:21.660
好 然后呢 然后呢 然后这就这个函数运行完了过后呢 再把模块l设为q表示模块加载完成了

28:21.980 --> 28:24.300
最后呢 反回什么 反回margeau.exports

28:25.420 --> 28:30.940
因为模块他已经缓存起来了啊 一开始就给他加了一个缓存对象 你看一开始就给他加了一个缓存对象

28:31.260 --> 28:34.700
所以说呢 你最终改变了这个对象 相当于是改变了缓存对象

28:35.020 --> 28:40.060
所以说 这 我们这里 我们这里呢 是在后边在进行缓存的 对吧 你对比一下啊 其实功能是一样

28:40.860 --> 28:42.860
那么他这就是webpack 他处理

28:43.420 --> 28:47.500
合并代码的方式 你看 我们把稍微简化了一下 结果了肯定是一样的

28:48.460 --> 28:55.820
肯定是一样的 你看 是不是一样的 对吧 因为他的原理呢 跟我们这边的原理呢 是一样的

28:57.580 --> 29:04.780
好 这一块肯定要花 花费一些时间啊 因为这一块毕竟要涉及到代码分析 肯定是有多多少少有一些难度的

29:05.820 --> 29:12.220
啊 大家可能下来要花一些时间去好好理解 最好了你去手动写一下啊 为什么要去写这个东西呢

29:12.300 --> 29:19.820
主要是为了提升大家对webpack的理解 啊 如果说你实在不会实在理解不了啊 太痛苦了 理解不了

29:20.380 --> 29:27.580
啊 我觉得这也没有多少代码 大家尽量把理解一下 如果实在理解不了的话 啊 其实后边呢 学习呢

29:28.140 --> 29:32.700
影响了也没有那么的大 只是你对原理这一块呢 你肯定是搞不清楚了

29:33.660 --> 29:39.260
不过呢 你对webpack的使用了 就是跟着我去一步一步去使用吧 还可能还不会有太大的问题

29:39.980 --> 29:46.620
好 我建议大家一定要去下来啊 自己去写一下 理解一下 好 那么接下来我们来说一下 他为什么要把东西放到

29:47.020 --> 29:50.940
aver 里边 就把这个代码 他为什么不直接像我们这样子直接写出来

29:51.340 --> 29:56.300
他为什么要把这个模块合并之后呢 他把这一代码放到哪呢 放到eva里边 我们再来编一次

29:57.020 --> 29:58.940
重新编一次啊 看一下

29:59.740 --> 30:03.900
看他原设代码 他是放到哪的呢 他是放到这个eva里边的 他为什么这样做

30:04.700 --> 30:08.140
好 我给大家说一下啊 这个跟这个东西跟浏览器无关

30:08.860 --> 30:14.620
他怎么回上的 他是这样子的 如果说你这样子写的话 他有可能会出现这么一个现象

30:15.020 --> 30:20.700
就是你不好调试 你的模块代码 因为最终合并了之后就合并成我们这个样子过后了

30:21.180 --> 30:25.500
到时候呢 如果说你模块到时候爆出了 他不好调试 什么意思呢

30:26.620 --> 30:29.820
嗯 举个例子吧 我这里呢 比方说

30:30.140 --> 30:31.820
这里呢

30:32.940 --> 30:38.060
运行a里边的一个abc这个方法 有没有这个方法a里边

30:38.540 --> 30:45.900
因为他这边导出了a只是一个字无窜的吧 他没有这个abc方法 好 那么他这样子一合并 那么这边这个代码是不是会跑到这边来

30:46.860 --> 30:53.100
他是不是会跑到这边来 对吧 他这样的合并会是不是会跑到这边来 好跑到这边来过后

30:53.900 --> 31:01.740
那里看一下 是不是爆错了 这里运行是不是爆错了 好 爆错过后了 我们来在浏览器里边调试 又会发现一个严重的问题点击

31:03.340 --> 31:07.580
这是啥呀 怎么错误代码跑这来了 对吧 为什么

31:08.380 --> 31:11.900
因为我们最终运行的是啥 运行的是合并之后的代码

31:12.620 --> 31:18.380
那么在这个代码里面爆错了 是不是你只能在这个代码里面调试 是不是只能在这个代码里面调试

31:18.780 --> 31:24.460
就看起来很不方便 他就跟我们这里 跟我们之前的分开的模块化这种写法

31:24.940 --> 31:29.020
这不调试起来就不太方便 对吧 调试起来就不太方便 所以说呢

31:29.820 --> 31:36.140
他就做了这么一个处理 因为浏览器啊 他是支持这么一种情况的 我给大家看一下啊

31:36.860 --> 31:39.740
给大家看一下 我这里新 新建一个文件

31:40.700 --> 31:43.100
abc.cs 随便建一个啊 来说明一下问题

31:44.060 --> 31:47.740
我们这里呢 去引用 abc.cs

31:48.860 --> 31:54.620
这个cs里面呢 我们写上一些代码吧 比方说写上 a等于 a等于

31:56.620 --> 32:01.020
b等于2 c等于3啊 然后呢 d等于nau

32:01.580 --> 32:04.540
然后呢 我们调用地 调用地的一个方法啊 abc

32:05.420 --> 32:09.420
好 保存啊 是不是同样爆错啊 同样爆错 他说abc不是一个

32:09.820 --> 32:15.420
不能从nau里面去读去属性abc 那么我们点击错误的时候呢 你会看到他错误是包在这里的 对吧

32:15.900 --> 32:21.420
错误是不包在这里的 好 接下来我用一种方式 你会发现浏览器的爆错了会有差异

32:22.060 --> 32:28.380
我用evil 就执行一段代码 执行什么代码呢 执行这个 我们把这两句代码放过来

32:29.660 --> 32:34.860
地等于nau 好 然后呢 换行 他这里不是换行吗 对吧 换行 ok 那我这里也换行

32:35.260 --> 32:41.660
写刚恩 写刚恩 换行 然后呢 地点 abc 对吧 我们把代码放到这

32:42.620 --> 32:45.660
然后呢 后边加上 加上一个东西

32:46.940 --> 32:54.540
嗯 我们先不夹嘛 先不夹 直接放这 就是我们把这两个代码放到evil里边 你看一下浏览器的爆错会有什么样的差异

32:55.420 --> 32:59.820
好 同样的 他爆了一个同样的错误啊 还是abc为烙 然后呢 他会发现

33:00.460 --> 33:04.300
哎 这里 点进去过后呢 你看代码是不是只有两行呢

33:05.020 --> 33:07.900
为什么 因为他evil里边的代码呢 他是放到一个

33:08.780 --> 33:16.780
另一个环境里边去执行的啊 另一个环境里边去执行的 因此呢 浏览器呢 他认为你这一段代码呢 是单独的一个执行环境

33:17.260 --> 33:24.220
啊 因此呢 他把他放到这来了 所以说你这样子呢 就看不到abc里边的所有其他代码了 对吧 又看不到他其他代码的干扰了

33:24.780 --> 33:31.580
所以他为什么要放到evil里边 而且呢 他为了让这里看得更加更加清楚 比方说这里他显示的是一个啊

33:32.060 --> 33:40.300
呃 既也是执行引擎的一个虚礼机编号啊 vm 1559啊 他显示这个东西 那我如果说我这里希望改动这个显示呢也可以

33:41.500 --> 33:44.060
浏览器他支持这个东西啊 后边写上一个注释

33:45.180 --> 33:47.820
哎 我看一下我忘了这个注释怎么写的了 我看一下对比一下这边

33:48.700 --> 33:51.260
ok 我们直接复制过来吧 直接复制过来

33:53.500 --> 33:58.620
ok 那么这里呢 两一个注释后边跟他一个警号 后边跟他一个source url

33:59.020 --> 34:06.620
表示的是 哎 我这个代码呢 就告诉浏览器你在触发调试的时候呢 你显示的路径 显示哪呢

34:07.260 --> 34:12.220
前面不用管啊 前面不用管 显示的路径的是显示的是srca.js

34:12.540 --> 34:15.420
好 我们就这样解啊 后边写上是一个注释 他是不参与运行的

34:15.660 --> 34:24.620
因为我们知道两个双 两个警号 两个鞋杠就是一个注释嘛 对吧 后边写上一个警号 然后source url 这些东西呢都是跟浏览器看的 好 保存一下

34:25.500 --> 34:31.340
你看一下 同样的错误还是发生了 但是你会看到这里是不是有区别了 他显示的路径就是我们错误的

34:31.660 --> 34:35.340
代码发生到哪里路径呢 路径发生在srca.js里边

34:35.980 --> 34:39.740
对吧 你这里写啥 他就显示啥 他就显示啥

34:40.380 --> 34:45.980
好 那么这里点进去 你看 是不是错误发生在这 对吧 错误发生在这

34:46.540 --> 34:47.900
他就起这么一个作用

34:48.860 --> 34:54.940
这就是为什么media.js里边 他把这些代码放到这里evil里边去执行 就是这个原因

34:55.660 --> 35:01.020
他让你更加容易调试啊 更加容易调试 比方说啊 我们再来一次啊 比方说呃

35:01.580 --> 35:03.980
麦妹啊 我们在这里 我们自己也手动写一下

35:05.660 --> 35:12.700
evil 怎么了console log 哎 我们这里写进去啊 这改转移转移

35:13.420 --> 35:17.540
然后呢 这里换行啊 这里exports

35:20.020 --> 35:20.820
啊

35:22.020 --> 35:25.140
margeau.export 啊 该换行换行

35:26.740 --> 35:29.780
啊 该换行换行 然后呢 后边写上

35:31.140 --> 35:35.220
啊 这里两个转移啊 啊 后边写上两个写杠

35:36.660 --> 35:42.020
紧号 source url url 等于啊 看一下这边

35:43.540 --> 35:45.220
等于这个东西

35:46.580 --> 35:48.820
啊 等于这个东西啊 他他其实

35:49.700 --> 35:52.660
他在编译的时候呢 其实前面还加了这个东西啊 加

35:52.660 --> 35:55.380
加了这个东西 这个东西呢 就是表示这个是webpack啊

35:55.380 --> 35:59.300
他标注一个 前面标注一个 我们是webpack产生的啊 其实都是一样的

35:59.860 --> 36:00.980
本质上都是一样的

36:01.780 --> 36:04.500
啊 我们这里也可以标注一下吧 标注一下webpack

36:05.460 --> 36:09.620
好 那么同样的道理啊 这就去掉了 对吧 好 那么下面也是一样

36:11.380 --> 36:15.300
啊 首先呢 是console 把这个in这个是margeau 穿进去

36:17.220 --> 36:19.060
好 然后第二句话呢 是这个

36:20.260 --> 36:21.700
第二句话是这个

36:23.060 --> 36:24.340
转移啊 该转移转移

36:28.220 --> 36:30.220
好 第三句话呢 是a.abc

36:32.750 --> 36:34.270
a.abc

36:34.670 --> 36:37.390
好 第四句话呢 是console loga

36:40.260 --> 36:40.980
console loga

36:42.260 --> 36:42.580
ok

36:43.540 --> 36:48.100
那么下面代码就不要了 好 保存 你看一下吧 好 这里我们导入啊

36:48.100 --> 36:49.060
my

36:49.940 --> 36:50.340
导入

36:51.940 --> 36:56.020
你看 啊说abc is not function 那么点击啊 他告诉你 我们在

36:56.660 --> 37:01.460
包出来当然 包出来是不是在这 对吧 包出来这 我这里是不是哪里写错了 看一下

37:03.220 --> 37:07.380
source ur要webpack src 这里是index.js

37:09.330 --> 37:13.730
啊 这里写错了啊 好 那么一看一下啊 这里index.js还包出来这

37:14.290 --> 37:17.730
啊 来看一下 那么是不是错误发生在这 对吧 错误发生在这

37:19.010 --> 37:23.570
ok 那么这就是啊 他为什么把他放到eva里边 就是这个原因

37:24.050 --> 37:26.930
好 其他都没啥了 那么通过这里可能大家就理解到了

37:27.970 --> 37:35.330
他是怎么样把 呃 至少他过程先不管吧 至少他的结果他是怎么样把多个多个模块文件合并在一起的

37:35.890 --> 37:41.010
啊 其实我们你如果说你利用你用一些第三方库也是一样的 比方说eva里边他用到了一接query

37:41.330 --> 37:43.330
那想不想呢 也是一样的 你看着吧

37:44.770 --> 37:45.570
npm i

37:45.890 --> 37:46.530
接query

37:49.250 --> 37:50.370
好 稍等啊

37:53.620 --> 37:56.500
啊 我知道我为什么这里没有反应了啊 他实际上是在下载

37:56.820 --> 37:57.700
他只不过了这个

37:58.180 --> 38:05.860
地址办习的 他是无法把个下载显示出来啊 所以说你 其实他在那个等待过程是在下载啊 好 那么这里呢我们可以导入

38:06.580 --> 38:07.060
import

38:08.260 --> 38:11.380
啊 文用那个吧 用common.js吧啊 多了

38:12.260 --> 38:12.740
require

38:13.620 --> 38:14.180
接query

38:14.900 --> 38:15.460
啊 是一样的

38:16.100 --> 38:19.540
好 那么这里呢 s不是要依赖接query 现在我们再打包一次

38:20.420 --> 38:21.300
npm run

38:25.380 --> 38:26.820
好 现在我们再看一下妹

38:27.460 --> 38:30.580
看上去代码好像很多很复杂的样子 你看结构是一样的

38:31.380 --> 38:32.900
你看这个模块对象里边

38:33.700 --> 38:38.740
模块名 对吧 模块的id 是不是路径啊路径 是不是接query的js

38:38.980 --> 38:42.500
作为模块的路径 然后模块代码 你看是不是还是个函数

38:42.740 --> 38:48.020
margexponsrequire对吧 传进去 然后里边是不是有eva 这里边是不是接query

38:48.260 --> 38:50.180
里边代码全部放在里边来了

38:50.660 --> 38:56.260
一大堆 多数多 但是格式是不是完全一样的 好 接query代码全部搞定了 过后了再往下看

38:57.220 --> 39:06.820
搞定了之后 是不是srca就第一个对象的第一个数项搞定了 第二个数项srca是模块id 函数模块代码

39:07.700 --> 39:13.220
模块id 函数模块代码 是不是一样的 对吧 是一样的

39:13.940 --> 39:20.260
ok 这就是它的打包的这种方式啊 那么这是我们的开发环境 那么

39:21.460 --> 39:26.740
就是我们打包的结果呢 是放到了一个就是开发环境的 那如果是生产环境打包了

39:27.220 --> 39:30.900
好 比方说啊 我们为了看的清楚一点 把这个多的取掉啊 不要几颗

39:31.220 --> 39:34.020
好 我们用生产环境打包 npm rock build

39:38.500 --> 39:42.420
好 这是生产环境打包 好 生产环境打包过后呢 其实也是一样的

39:43.140 --> 39:49.540
只不过呢 他把很多的变量名呢 他为了更小的体积嘛 把很多代码的换行呢给你取消了

39:49.780 --> 39:54.820
然后呢 把变量名呢 给你尽量的减化了 比方说你他把那个就是

39:55.780 --> 40:01.620
缓存的模块了 他用一个变量n来表示 对吧 他把尽量的把变量名给你减化了 其实其他都是一样的

40:02.980 --> 40:04.260
因此呢 你理解了

40:05.300 --> 40:07.300
你理解了 就是我们这个代码

40:07.860 --> 40:11.780
那么你就理解了他的整个打包的结果 就是编译的结果

40:12.180 --> 40:14.740
好 你理解了编译结果 我们后边才能说

40:15.540 --> 40:20.180
他的编译过程 你理解了编译过程 你才能理解后边讲的一些

40:20.580 --> 40:26.740
什么像什么夹载器啊 插件啊 这些东西 你才能理解他的原理 当然你不理解原理也能用只不过呢

40:28.100 --> 40:28.420
你就

40:29.140 --> 40:30.260
认识的没有那么深刻

40:30.900 --> 40:31.780
ok 这是咱们

40:32.660 --> 40:33.540
这些客人说的

40:34.500 --> 40:37.540
下来就把一个代码 最好是能够自己去写一次

40:37.940 --> 40:42.580
他其实也没有那么的复杂 你自己去琢磨一下 也能够知道是怎么回事

