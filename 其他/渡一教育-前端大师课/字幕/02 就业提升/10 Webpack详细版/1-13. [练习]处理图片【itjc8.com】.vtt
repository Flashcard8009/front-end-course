WEBVTT

00:00.620 --> 00:06.020
好 这节课咱们来看一个更加有意识的一个关于loader的例子

00:06.020 --> 00:10.620
之前我们就用的是央视 央视本来不是介绍代码

00:10.620 --> 00:14.020
因此它在那个 我再看一下这个图 反复来看这个图

00:14.020 --> 00:18.620
在那个就是ST 抽象语法书分析的时候它要报错

00:18.620 --> 00:22.620
因为它不是介绍码 所以说我们可以通过加载性

00:22.620 --> 00:25.620
把CS代码来变成介绍码 它就能识别了

00:26.620 --> 00:32.620
另外除了央视之外 其实图片也可以用类似的方式来进行处理

00:32.620 --> 00:36.620
你看这里有一张静态图片 我这里顺便再说一句

00:36.620 --> 00:40.620
就是这个set文件夹 名字是随便取的 不说必须这个名字

00:40.620 --> 00:45.620
习惯上把什么图片 央视 也都放在这个文件夹里边去

00:45.620 --> 00:50.620
让它也参与打包 这个图片就是一张静态图片

00:50.620 --> 00:53.620
那么这个静态图片有的时候有两种用法

00:53.620 --> 00:58.620
就是在一面上直接使用什么呢 使用1米几元素引用的

00:58.620 --> 01:03.060
就在一面上 听没有

01:03.060 --> 01:06.060
一面上直接使用1米几元素去引用一张图片

01:06.060 --> 01:09.060
那么这个时候图片你肯定要放到这个目录

01:09.060 --> 01:12.060
这个毫无疑问 这个没办法 图片只能放到这个目录

01:12.060 --> 01:15.060
其实这个地方还是可以处理 我们之后再说

01:15.060 --> 01:19.060
这是一种静态图片 另外一种静态图片就是

01:19.060 --> 01:23.060
这个图片是我们自己用介式来生成的

01:24.060 --> 01:26.060
那有个同学说 什么叫动态图片呢

01:26.060 --> 01:31.060
动态图片是通过阿迦克斯请求从服务器去拿的图片入境

01:31.060 --> 01:34.060
比方说举个例子吧 这里虽然不管动态图片

01:34.060 --> 01:39.060
比方说阿迦克斯请求服务器 服务器给我们返回一个阶层数据

01:39.060 --> 01:42.060
比方说一个数主 或者是一个对象吧

01:42.060 --> 01:47.060
阶层数据比方说用户的用户名字 用户的姓名张三

01:47.060 --> 01:51.060
用户的头像 头像是个图片 头像地址

01:51.060 --> 01:54.060
那么头像地址已经存在服务器上了

01:54.060 --> 01:58.060
它会给你一个地址 比方说随便举个例子吧

01:58.060 --> 02:03.060
比方说地址是EmeG 哪个哪个什么图片

02:03.060 --> 02:06.060
这个图片你不需要到这 这个图片你是不需要到这了

02:06.060 --> 02:09.060
因为它已经在服务器上了 你直接去请求就完了

02:09.060 --> 02:14.060
这是要动态图片 就是我们在前端处理的时候不需要你去处理

02:14.060 --> 02:18.060
我们这里指的是前端的一些静态图片 静态图片也有两个位置

02:18.060 --> 02:23.060
一个是在页面上写实的 一个是用GS生存的一些静态图片

02:23.060 --> 02:27.060
那比方说我们现在只考虑在GS里面生存的静态图片

02:27.060 --> 02:31.060
那怎么来做呢 比方说我们这里有一张图片

02:31.060 --> 02:34.060
在WebPack的世界里面一切皆为模块

02:34.060 --> 02:38.060
那么这个GS我可以这样子写require

02:38.060 --> 02:41.060
require 第二 是吧

02:41.060 --> 02:46.060
而CS里面的WebPack当然要写后续名 因为它不是GS文件

02:47.060 --> 02:53.060
拿到之后 是不是可以 我们比方说能够拿到一个图片的src路径

02:53.060 --> 02:56.060
那么我这里怎么办 就可以用DocumentCreateElement

02:56.060 --> 02:59.060
创建一张图片 创建一个英米景元素

02:59.060 --> 03:03.060
这就是用GS来生存的图片

03:03.060 --> 03:06.060
那么元素的src路径 路径来自于哪呢

03:06.060 --> 03:10.060
来自于一张静态图片的路径 来自于这

03:10.060 --> 03:13.060
然后我们把这个英米景元素加到页面上去

03:13.060 --> 03:17.060
DocumentBodyAppendChild 加到页面上去

03:17.060 --> 03:19.060
对 我们就可以这样做

03:19.060 --> 03:22.060
那么现在能运行吗 现在肯定是不能运行

03:22.060 --> 03:25.060
肯定是运行不了的 你看吧

03:25.060 --> 03:27.060
哪里会出问题

03:27.060 --> 03:29.060
印象上在哪里会出问题

03:29.060 --> 03:34.060
Error 它说我这里已经写过了

03:34.060 --> 03:39.060
把这个去掉 从头再说 再来

03:39.060 --> 03:42.060
再来 打包 你看

03:42.060 --> 03:44.060
是搞不定 因为什么呢

03:44.060 --> 03:47.060
因为它说 完全没有办法

03:47.060 --> 03:49.060
它是有没有把这个文件读出来

03:49.060 --> 03:51.060
它是把这个文件读出来的

03:51.060 --> 03:55.060
用UTF-8这样的文件格式 把图片内容

03:55.060 --> 03:57.060
它就把它当成一个普通介石文件

03:57.060 --> 04:00.060
管理系是什么后续名 它都把它当成介石内容来读

04:00.060 --> 04:02.060
能不能读出来 读出来了

04:02.060 --> 04:05.060
这个里边的代码 这是二镜子格式的代码

04:05.060 --> 04:08.060
二镜子格式的代码 它能够把它解析成抽象与法术吗

04:08.060 --> 04:10.060
都解析不出来 又是在这里出了问题了

04:10.060 --> 04:12.060
所以说我们又得怎么办

04:12.060 --> 04:14.060
又得去写一个loader

04:14.060 --> 04:17.060
然后你把图片的那一种 就是二镜子数据给我

04:17.060 --> 04:19.060
ok 那么我给你翻译成介石代码

04:19.060 --> 04:22.060
然后再进行抽象与法术分析

04:22.060 --> 04:25.060
好 那么这个东西是不是也得写loader

04:25.060 --> 04:27.060
那现在肯定是错误的

04:27.060 --> 04:29.060
那么现在我们接个loader读文件

04:29.060 --> 04:31.060
然后我们这里边写上一个loader

04:31.060 --> 04:34.060
emd以及loader 叫介石

04:34.060 --> 04:36.060
那么这里导出什么

04:36.060 --> 04:38.060
marge export

04:38.060 --> 04:41.060
导出一个函数

04:41.060 --> 04:44.060
函数里边的source

04:44.060 --> 04:47.060
那么这里我们返回一个介石代码

04:47.060 --> 04:50.060
返回介石代码 返回的是

04:50.060 --> 04:52.060
一个空的吧 啥都不要

04:52.060 --> 04:55.060
这样子至少不爆错嘛 写好这么一个loader

04:55.060 --> 04:56.060
好 接下来我们在

04:56.060 --> 04:59.060
vpac.js里边是不是要配置marge

04:59.060 --> 05:02.060
然后rules

05:02.060 --> 05:05.060
每个数字一个规则 就一个规则

05:05.060 --> 05:06.060
tests

05:06.060 --> 05:08.060
我们的匹配的表达是什么呢

05:08.060 --> 05:11.060
匹配的路径 只要能够匹配

05:11.060 --> 05:14.060
以什么del 什么结尾呢

05:14.060 --> 05:17.060
png 或者图片 或者是什么呢

05:17.060 --> 05:20.060
jpg 或者是什么呢

05:20.060 --> 05:23.060
或者是gf

05:23.060 --> 05:26.060
总之呢 以这些结尾的

05:26.060 --> 05:28.060
我们怎么样呢

05:28.060 --> 05:31.060
我们怎么样 我们就可以那个

05:31.060 --> 05:33.060
使用use

05:33.060 --> 05:37.060
使用哪一个 使用loaders

05:37.060 --> 05:39.060
image loader

05:39.060 --> 05:42.060
这些介石 我这还少一个结尾

05:42.060 --> 05:44.060
只要以这个后维名结尾的

05:44.060 --> 05:46.060
这些后维名结尾的

05:46.060 --> 05:49.060
我们都会使用这个loader来处理

05:49.060 --> 05:51.060
那么这个loader目前没有做任何处理

05:51.060 --> 05:53.060
它只是把我们的图片里面的二进之内容

05:53.060 --> 05:55.060
转换成一个空置无穿的介石代码

05:55.060 --> 05:57.060
这里面就是介石代码 反悔

05:57.060 --> 05:59.060
那就完了

05:59.060 --> 06:01.060
那么接下来我们来看一下

06:01.060 --> 06:03.060
有点没有意思 咱们来看

06:03.060 --> 06:05.060
输出一下src

06:05.060 --> 06:07.060
咱们来看一下吧

06:07.060 --> 06:09.060
那么现在呢

06:09.060 --> 06:10.060
我们再再打包

06:10.060 --> 06:12.060
至少不会爆错了 这个是可以肯定的

06:12.060 --> 06:14.060
至少不会爆错了

06:14.060 --> 06:16.060
没爆错吧 没爆错 看电视目录

06:16.060 --> 06:17.060
没爆错吧

06:17.060 --> 06:19.060
那么我们针对图片这个模块

06:19.060 --> 06:21.060
你看 它里面就什么代码都没有

06:21.060 --> 06:22.060
就这么简单

06:22.060 --> 06:25.060
那么当然了 我这里打印出来会打印出来啥

06:25.060 --> 06:27.060
你看打印出来啥

06:27.060 --> 06:29.060
OK

06:29.060 --> 06:31.060
我不是在这

06:31.060 --> 06:32.060
在这

06:32.060 --> 06:34.060
我们在这里 听没有

06:34.060 --> 06:36.060
我们先引用一下这个介石

06:36.060 --> 06:38.060
卖一点介石

06:38.060 --> 06:40.060
OK 我们在这里引用一下

06:40.060 --> 06:41.060
打开

06:41.060 --> 06:43.060
你看 这图片是没显示出来

06:43.060 --> 06:44.060
为什么 因为它输出什么

06:44.060 --> 06:45.060
输出什么

06:45.060 --> 06:46.060
是不是一个空对象

06:46.060 --> 06:48.060
我们知道在common介石里面

06:48.060 --> 06:50.060
从来没倒出 是不是一个空对象

06:50.060 --> 06:51.060
对吧 就空对象

06:51.060 --> 06:53.060
所以说 目前的

06:53.060 --> 06:54.060
当然什么

06:54.060 --> 06:56.060
一个图片而src地址

06:56.060 --> 06:57.060
一个图片src地址

06:57.060 --> 06:59.060
复制为一个空对象

06:59.060 --> 07:00.060
它图示去过后

07:00.060 --> 07:01.060
就变成这个样子了

07:01.060 --> 07:02.060
那自然什么都没有

07:02.060 --> 07:03.060
什么都没有

07:03.060 --> 07:04.060
那么也就是说

07:04.060 --> 07:05.060
我们要处理的

07:05.060 --> 07:07.060
无非就是在这边

07:07.060 --> 07:08.060
要使用一个什么呢

07:08.060 --> 07:10.060
使用一个modular export

07:10.060 --> 07:11.060
倒出

07:11.060 --> 07:12.060
倒出这么一个东西

07:12.060 --> 07:13.060
对不对

07:13.060 --> 07:15.060
是不是在这里进行倒出

07:15.060 --> 07:17.060
是吧 要倒出这么一个东西

07:17.060 --> 07:18.060
倒出这么一个东西

07:18.060 --> 07:20.060
那么这个东西是啥呢

07:20.060 --> 07:21.060
这个东西

07:21.060 --> 07:23.060
我们这里有两种处理办法

07:23.060 --> 07:25.060
第一种处理办法是

07:25.060 --> 07:28.060
把它变成bass64格式

07:29.060 --> 07:31.060
你们学学的

07:31.060 --> 07:34.060
图片它可以是bass64的格式

07:34.060 --> 07:36.060
不用去生成文件

07:36.060 --> 07:37.060
直接把一个图片

07:37.060 --> 07:39.060
读出来它的bass64格式放到这

07:39.060 --> 07:40.060
这是地長方式

07:40.060 --> 07:41.060
那么我们这里

07:41.060 --> 07:43.060
可以写个辅助函数

07:43.060 --> 07:46.060
比如说to-bass64

07:46.060 --> 07:48.060
首先大家可以看一下

07:48.060 --> 07:49.060
这个source

07:49.060 --> 07:51.060
看一下这个source

07:51.060 --> 07:52.060
其实这些单码

07:52.060 --> 07:53.020
写不写 其实无所

07:53.060 --> 07:54.060
就是你会不会写

07:54.060 --> 07:55.060
其实无所谓的

07:55.060 --> 07:56.060
我们主要是通过

07:56.060 --> 07:58.680
大家加深对loader的认识

07:58.680 --> 08:02.720
不要那么看一下这个source

08:02.720 --> 08:04.360
看一下这个source到底是

08:04.360 --> 08:05.480
你看读出来是不是乱吧

08:05.480 --> 08:06.080
对吧

08:06.080 --> 08:07.600
他本来是个二净字

08:07.600 --> 08:09.160
你把它当成一个普通字无错来读

08:09.160 --> 08:10.200
肯定是乱吧

08:10.200 --> 08:11.400
读出来肯定是乱吧

08:11.400 --> 08:13.560
那么这样子不是我们希望看到的

08:13.560 --> 08:15.400
我们希望他给我们的代码的

08:15.400 --> 08:16.360
就是一个二净字

08:18.280 --> 08:19.320
你们学过ES-6

08:19.320 --> 08:21.320
二净字应该用什么样的表示

08:21.320 --> 08:22.200
二净字的数据

08:23.600 --> 08:24.880
是buffer

08:24.880 --> 08:25.840
二位buffer

08:25.840 --> 08:27.720
是不是应该用这种方式来表示

08:27.720 --> 08:29.040
但是他给我的是一个字无错

08:29.040 --> 08:30.760
那肯定我们到时候处理起来了

08:30.760 --> 08:31.800
不是很好处理

08:31.800 --> 08:34.040
因此我希望他给我的原代码的

08:34.040 --> 08:34.920
是一个二净字

08:34.920 --> 08:37.520
那么怎么样让Web派个

08:37.520 --> 08:39.200
给我们的代码是二净字呢

08:39.200 --> 08:39.800
很简单

08:39.800 --> 08:41.240
你这里导出了一个什么loader

08:41.240 --> 08:42.680
这是个loader函数对吧

08:42.680 --> 08:45.720
你只要给这个函数加一个静态属性

08:45.720 --> 08:46.400
怎么属性呢

08:46.400 --> 08:47.240
叫做弱

08:47.240 --> 08:48.080
弱表示什么意思

08:48.080 --> 08:49.240
原始格式

08:49.240 --> 08:54.720
该loader要处理的是原始数据

08:54.720 --> 08:56.480
那么什么意思呢

08:56.520 --> 08:57.240
这样子一来

08:57.240 --> 08:58.200
只要你加了这个true

08:58.200 --> 08:59.320
那么Web派可以看

08:59.320 --> 09:00.600
你给我这个函数

09:00.600 --> 09:01.520
他有个静态属性

09:01.520 --> 09:02.560
row他为true

09:02.560 --> 09:04.440
那么他到时候给力的就不是支不错了

09:04.440 --> 09:05.640
给力的是什么呢

09:05.640 --> 09:06.880
给的

09:06.880 --> 09:08.800
给的是buffer

09:08.800 --> 09:09.400
给的是buffer

09:09.400 --> 09:10.880
就是二净字格式

09:10.880 --> 09:11.040
好

09:11.040 --> 09:12.760
咱们现在再来看一下

09:12.760 --> 09:14.320
一看现在就不是乱码了

09:14.320 --> 09:16.480
他就是一个二净字

09:16.480 --> 09:16.880
哎

09:16.880 --> 09:18.440
这也抱错了

09:18.440 --> 09:21.440
怎么呢

09:21.440 --> 09:24.800
loader is not defined

09:24.800 --> 09:25.640
loader

09:27.320 --> 09:29.680
is not defined

09:29.680 --> 09:32.640
什么意思

09:32.640 --> 09:33.880
他这个loader

09:33.880 --> 09:35.080
他没有定义

09:35.080 --> 09:35.400
哦

09:35.400 --> 09:36.200
这是个表达式

09:36.200 --> 09:36.760
对吧

09:36.760 --> 09:37.640
这是个表达式

09:37.640 --> 09:38.440
这样吧

09:38.440 --> 09:39.240
因为表达式

09:39.240 --> 09:41.360
它函数名字是不能在外面使用的

09:41.360 --> 09:42.680
这是我们接视的基础

09:42.680 --> 09:43.040
我们这样

09:43.040 --> 09:44.320
我们把它写出去

09:44.320 --> 09:45.920
这样子来到导出loader

09:45.920 --> 09:46.320
一样的

09:46.320 --> 09:46.600
对吧

09:46.600 --> 09:46.920
一样的

09:46.920 --> 09:47.280
这样子

09:47.280 --> 09:50.360
我觉得可以在这里使用true了

09:50.360 --> 09:50.720
OK

09:50.720 --> 09:56.450
那么这样子来

09:56.450 --> 09:57.290
你看一下

09:57.290 --> 09:58.410
你看是不是得到buffer了

09:58.410 --> 09:59.130
对吧

09:59.130 --> 10:00.130
一共多号个字节

10:00.130 --> 10:02.090
五六九五个字节

10:02.290 --> 10:03.370
每个字节就是一个数字

10:03.370 --> 10:04.490
每个字节就是数字

10:04.490 --> 10:07.050
当然我们这里还可以输出

10:07.050 --> 10:09.130
文件数据大小

10:09.130 --> 10:09.770
大小多少呢

10:09.770 --> 10:10.970
多少个字节呢

10:10.970 --> 10:13.170
单位字节

10:13.170 --> 10:13.890
多少个字节呢

10:13.890 --> 10:14.570
我们学过的

10:14.570 --> 10:15.690
buffer里面有个什么

10:15.690 --> 10:18.570
现在我们就用buffer

10:18.570 --> 10:19.570
buffer里面有个什么

10:19.570 --> 10:20.490
bat

10:20.490 --> 10:21.090
nance

10:21.090 --> 10:21.810
对吧

10:21.810 --> 10:22.810
字节数

10:22.810 --> 10:23.690
咱们来看一下

10:23.690 --> 10:27.050
就可以得到文件的字节数了

10:27.050 --> 10:28.010
字节数

10:28.010 --> 10:29.370
我这里稍微一点误差

10:29.370 --> 10:30.250
575

10:30.250 --> 10:31.810
575

10:31.850 --> 10:32.450
没问题吧

10:32.450 --> 10:35.810
咱们这里就是得到文件的数据

10:35.810 --> 10:36.610
数据

10:37.770 --> 10:38.010
好

10:38.010 --> 10:38.690
那么接下来

10:38.690 --> 10:39.730
我们刚才说到了

10:39.730 --> 10:41.250
我们这里导出

10:41.250 --> 10:43.050
因为我这里可以要导入

10:43.050 --> 10:44.330
我这里一看

10:44.330 --> 10:45.010
js要导入

10:45.010 --> 10:46.250
我刚刚返回个js代码

10:46.250 --> 10:47.010
他肯定要导出

10:47.010 --> 10:48.130
不然他这里得不到东西

10:48.130 --> 10:49.530
就是空对象

10:49.530 --> 10:50.770
不然没代码

10:50.770 --> 10:53.170
所以说我们这里返回的代码

10:53.170 --> 10:54.810
就是一定要导出一个东西

10:54.810 --> 10:55.570
导出什么呢

10:55.570 --> 10:56.890
我们有两种方式

10:56.890 --> 10:59.730
一种方式就是get

10:59.730 --> 11:00.810
bass64

11:00.890 --> 11:03.410
得到bass64编码的格式

11:03.410 --> 11:04.450
你给我一个buffer

11:04.450 --> 11:05.730
我来给你返回一个bass64

11:05.730 --> 11:06.690
那么这个东西很简单

11:06.690 --> 11:07.850
你直接是buffer的

11:07.850 --> 11:08.810
toestune

11:08.810 --> 11:09.810
我不知道

11:09.810 --> 11:11.450
大家知不知道

11:11.450 --> 11:12.890
这个其实也很少用

11:12.890 --> 11:14.330
就这么样就完了

11:14.330 --> 11:15.090
特别简单

11:15.090 --> 11:16.050
特别简单

11:16.050 --> 11:17.410
咱们来看一下吧

11:17.410 --> 11:20.810
我们这里把这个buffer传进去

11:20.810 --> 11:22.290
getbass64

11:22.290 --> 11:23.570
buffer传进去

11:23.570 --> 11:25.970
buffer传进去过后

11:25.970 --> 11:27.850
是不是得到一个结果

11:27.850 --> 11:28.530
得到一个结果

11:28.530 --> 11:29.690
content内容

11:29.730 --> 11:32.530
图片内容就是bass64编码过后的内容

11:32.530 --> 11:33.330
保存

11:33.330 --> 11:37.930
你看一下吧

11:37.930 --> 11:40.130
你看是不是得到bass64编码过后的内容

11:40.130 --> 11:40.410
对吧

11:40.410 --> 11:43.370
bass64编码过后的内容就得到了

11:43.370 --> 11:44.330
得到了之后

11:44.330 --> 11:46.370
当然这个内容是不是要放在这

11:46.370 --> 11:46.650
对吧

11:46.650 --> 11:47.930
是不是要放在这

11:47.930 --> 11:50.330
当然这样的内容它还实编不了

11:50.330 --> 11:51.370
它还实编不了

11:51.370 --> 11:52.490
它还实编不了

11:52.490 --> 11:54.330
那么因为我们图片前面

11:54.330 --> 11:56.010
是不是还要加上了东西

11:56.010 --> 11:57.130
加上什么东西

11:57.130 --> 11:59.170
图片前面

11:59.170 --> 12:00.250
拼接一下

12:00.290 --> 12:02.090
图片前面说还要加上一个

12:02.090 --> 12:04.010
data

12:04.010 --> 12:05.410
前面MIME类型

12:05.410 --> 12:05.690
对吧

12:05.690 --> 12:06.210
img

12:06.210 --> 12:08.410
当然这个类型也可以根据文件名

12:08.410 --> 12:09.570
可以根据文件名单判断

12:09.570 --> 12:10.570
我这里哪里判断了

12:10.570 --> 12:11.770
就png得了

12:11.770 --> 12:12.290
哪里判断了

12:12.290 --> 12:14.250
当然可以根据文件名单判断

12:14.250 --> 12:15.210
png

12:15.210 --> 12:19.450
然后后面是bass64

12:19.450 --> 12:21.850
data冒号

12:21.850 --> 12:22.690
我看一下

12:22.690 --> 12:24.130
这个bass64格式怎么写

12:24.130 --> 12:25.170
我一点忘了

12:25.170 --> 12:25.890
我一点忘了

12:25.890 --> 12:27.170
查一下吧

12:27.170 --> 12:28.770
图片

12:28.770 --> 12:30.130
bass

12:30.170 --> 12:31.490
64格式

12:31.490 --> 12:32.490
我看一下

12:33.690 --> 12:35.130
这里转换工具

12:35.130 --> 12:36.410
我们转换一个吧

12:36.410 --> 12:37.650
看一下一个格式

12:38.970 --> 12:42.050
我们的图片在这

12:42.050 --> 12:46.900
把它复制到桌面上去吧

12:47.580 --> 12:48.580
复制到桌面

12:49.180 --> 12:50.220
然后重新打开一次

12:50.220 --> 12:51.220
上传图片

12:53.100 --> 12:54.180
做完成bass64

12:54.180 --> 12:55.260
前面一个data冒号

12:55.260 --> 12:55.620
img

12:55.620 --> 12:56.660
png

12:56.660 --> 12:57.700
分号bass64

12:57.700 --> 12:58.100
OK

12:58.100 --> 12:59.300
那我写对了

12:59.300 --> 13:00.220
bass64.o

13:00.220 --> 13:02.100
那么后面就是跟上bass64的编码

13:02.100 --> 13:03.660
我们返回这么一个字五串

13:03.700 --> 13:04.860
咱们站来看一下

13:05.540 --> 13:06.540
咱们站来看一下

13:06.900 --> 13:07.500
先打包

13:10.990 --> 13:11.830
你看一下

13:11.830 --> 13:13.990
那么这个bass64编码前面就加上这个东西了

13:14.550 --> 13:16.430
他现在是不是导出这个东西了

13:16.430 --> 13:17.470
marge.export

13:17.470 --> 13:18.750
我们看一下最终代码

13:18.750 --> 13:20.230
最终代码里面你看

13:20.590 --> 13:22.190
marge.export

13:22.190 --> 13:23.030
是不是导出这么一个

13:23.030 --> 13:24.110
很长的一个字五串

13:24.110 --> 13:24.630
对吧

13:24.630 --> 13:25.590
那么这样子

13:25.630 --> 13:27.390
这边组模块就入口模块

13:27.390 --> 13:28.110
一导入进来

13:28.110 --> 13:29.870
是不是就把这字五串导入进来了

13:29.870 --> 13:31.190
相当于src是什么

13:31.190 --> 13:32.230
src就是这个

13:32.230 --> 13:34.830
然后把这个src复制给图片的src

13:34.830 --> 13:35.870
你看这个图片

13:35.910 --> 13:37.030
是不是就能显示了

13:37.030 --> 13:39.030
图片里面src是不是就是这个东西

13:39.030 --> 13:39.310
对吧

13:39.310 --> 13:40.350
就bass64编码

13:40.350 --> 13:41.510
它不生成文件

13:41.510 --> 13:43.190
bass64编码的这种方式

13:43.190 --> 13:43.990
你看

13:43.990 --> 13:45.430
我们控载输出

13:45.430 --> 13:46.950
在主模块里面

13:46.950 --> 13:49.230
在index模块里面输出了这个src

13:49.230 --> 13:50.510
是不是就是这个src

13:50.510 --> 13:51.110
对吧

13:51.110 --> 13:51.390
好

13:51.390 --> 13:53.470
这是用bass64的方式对吧

13:53.470 --> 13:55.430
那么我们还有没有别的方式呢

13:55.430 --> 13:56.190
当然有

13:56.190 --> 13:57.110
当然有

13:57.110 --> 13:59.510
比方我们还可以用文件的方式

13:59.510 --> 14:00.430
get

14:01.870 --> 14:03.310
用文件的方式

14:03.310 --> 14:04.910
get file

14:05.590 --> 14:06.310
pass

14:06.310 --> 14:07.430
得到一个文件的路径

14:07.430 --> 14:07.630
对吧

14:07.630 --> 14:09.870
我们把文件的路径导出

14:09.870 --> 14:11.070
用这个方式

14:11.070 --> 14:11.830
用这种方式

14:13.150 --> 14:13.310
好

14:13.310 --> 14:14.790
那么这种方式呢

14:14.790 --> 14:15.230
怎么做呢

14:15.230 --> 14:17.150
就是是不是又生成一个文件

14:17.150 --> 14:18.870
就生成一个文件就完事了

14:18.870 --> 14:18.990
好

14:18.990 --> 14:19.990
那么比方说

14:19.990 --> 14:21.430
那么咱们去调用

14:21.430 --> 14:23.950
调用这个get file pass

14:23.950 --> 14:27.400
不用这种方式

14:27.400 --> 14:27.880
我们这里

14:28.960 --> 14:30.120
还是用content

14:30.120 --> 14:31.760
get file pass

14:32.720 --> 14:34.000
得到文件路径

14:34.000 --> 14:35.160
文件路径

14:35.160 --> 14:36.440
那么调用之后

14:36.480 --> 14:36.920
调用之后

14:36.920 --> 14:39.480
我们这里把这个文件路径

14:39.480 --> 14:40.240
输出

14:40.240 --> 14:41.040
文件路径输出

14:41.040 --> 14:42.800
我们来看一下这个东西

14:42.800 --> 14:44.320
那么怎么来得到文件路径了

14:44.320 --> 14:44.760
现在

14:44.760 --> 14:45.320
现在问题是

14:45.320 --> 14:46.520
怎么来得到文件路径了

14:46.520 --> 14:48.440
那你肯定要生成文件

14:48.440 --> 14:48.720
对吧

14:48.720 --> 14:49.920
肯定要生成文件

14:49.920 --> 14:50.080
好

14:50.080 --> 14:51.240
那么这里边呢

14:51.240 --> 14:52.080
有些新知识

14:52.080 --> 14:52.800
不过这些知识呢

14:52.800 --> 14:53.680
大家看一看

14:53.680 --> 14:54.800
过一过就得了

14:54.800 --> 14:56.680
因为不是重点

14:56.680 --> 14:57.560
因为这些东西呢

14:57.560 --> 14:58.440
你们平时以后

14:58.440 --> 15:00.840
也很少去自己写这个loader

15:00.840 --> 15:02.400
所以这个看一下就得了

15:02.400 --> 15:05.040
因为我们重点是让大家理解

15:05.040 --> 15:06.960
loader可以做什么

15:06.960 --> 15:07.160
好

15:07.160 --> 15:08.720
那么这个范围怎么写呢

15:08.720 --> 15:11.040
首先我们要得到一个文件名

15:11.040 --> 15:11.720
好

15:11.720 --> 15:13.280
那么得到文件名的事

15:13.280 --> 15:14.160
得到文件名呢

15:14.160 --> 15:14.920
我们就可以用这种

15:16.520 --> 15:20.480
首先用一个就是loader utl

15:20.480 --> 15:23.440
require

15:23.440 --> 15:26.920
就是loader utl

15:26.920 --> 15:27.920
这是我们安装的模块

15:27.920 --> 15:29.040
我已经安装好了

15:29.040 --> 15:30.120
loader utl

15:30.120 --> 15:31.080
这么一个模块

15:31.080 --> 15:34.440
那么这个模块里边有一个函数

15:34.440 --> 15:35.920
看着一点点

15:35.960 --> 15:37.120
我们先不输出

15:37.120 --> 15:38.280
先不输出

15:38.280 --> 15:38.440
好

15:38.440 --> 15:42.920
咱们这里直接loader utl

15:42.920 --> 15:44.840
然后这里有一个函数

15:44.840 --> 15:47.360
叫做interpolate name

15:47.360 --> 15:49.240
生成一个名字

15:49.240 --> 15:51.680
按照某一种规则来生成一个名字

15:51.680 --> 15:53.320
第一个参数要给上下文

15:53.320 --> 15:54.080
什么叫上下文

15:54.080 --> 15:55.120
也就是说这个函数里边

15:55.120 --> 15:56.320
z

15:56.320 --> 15:58.080
我们之前是不是有这么一个东西

15:58.080 --> 16:01.080
叫做getloader utl get

16:01.080 --> 16:02.840
option 是不是要给z

16:02.840 --> 16:04.120
是不是要给z

16:04.160 --> 16:07.480
那么这里的z是肯定不行

16:07.480 --> 16:08.600
这里的z就是undefine

16:08.600 --> 16:10.280
因为你是直接调用了函数

16:10.280 --> 16:11.320
所以说这个函数调用了

16:11.320 --> 16:12.320
我要这样调用

16:12.320 --> 16:13.400
call

16:13.400 --> 16:14.840
把z是绑定进去

16:14.840 --> 16:17.400
主要是要把z绑定进去

16:17.400 --> 16:19.400
这样子z就跑到这边来了

16:19.400 --> 16:20.800
就这边的z就跑到这边来了

16:20.800 --> 16:21.600
没问题吧

16:21.600 --> 16:22.520
那么这里

16:22.520 --> 16:24.400
它第一个参数就要给上下文

16:24.400 --> 16:25.680
就是z

16:25.680 --> 16:28.200
第二个参数就是名字

16:28.200 --> 16:29.720
就是名字

16:29.720 --> 16:31.840
名字是什么呢

16:31.840 --> 16:33.000
名字是什么呢

16:33.040 --> 16:33.720
名字呢

16:33.720 --> 16:34.480
我们这里呢

16:34.480 --> 16:36.600
可以给一个名字的规则

16:36.600 --> 16:37.600
规则

16:37.600 --> 16:37.960
是吗

16:37.960 --> 16:38.800
可以用哈希

16:38.800 --> 16:39.520
那么这里的哈希

16:39.520 --> 16:41.720
我们可以一般会用content哈希

16:41.720 --> 16:43.040
这个哈希大家没见过

16:43.040 --> 16:44.080
只指的是

16:44.080 --> 16:46.040
因为你现在要单独生成某一个文件

16:46.040 --> 16:47.720
那么你只需要单独的

16:47.720 --> 16:50.080
根据某一个文件的内容来生成哈希

16:50.080 --> 16:51.400
你看我们之前

16:51.400 --> 16:53.000
生成哈希是不是都

16:53.000 --> 16:54.320
要么就是根据多个文件

16:54.320 --> 16:54.720
要么对吧

16:54.720 --> 16:56.400
要么根据种植源列表

16:56.400 --> 16:57.000
对不对

16:57.000 --> 16:58.520
它没有一个根据单个文件

16:58.520 --> 16:59.200
生成的哈希

16:59.200 --> 17:00.880
那么这个content哈希呢

17:00.920 --> 17:03.400
指的是根据单个文件的内容生成哈希

17:03.400 --> 17:04.440
这个东西呢

17:04.440 --> 17:05.280
大家有的时候呢

17:05.280 --> 17:06.000
有可能啊

17:06.000 --> 17:08.200
如果说面上问的比较深的话

17:08.200 --> 17:10.240
那么它可能会问你这几个的区别

17:10.240 --> 17:11.240
哈希

17:11.240 --> 17:13.360
一个是创可哈希

17:13.360 --> 17:14.840
对吧

17:14.840 --> 17:16.400
content哈希

17:16.400 --> 17:16.880
对不对

17:16.880 --> 17:18.360
它有可能这三个会问你

17:18.360 --> 17:19.640
那么最大的就是哈希

17:19.640 --> 17:22.600
那么这个哈希是根据种植源列表生成的哈希

17:22.600 --> 17:23.280
创可哈希呢

17:23.280 --> 17:25.880
是根据每一个创可的资源生成的哈希

17:25.880 --> 17:27.520
那么这个content哈希呢

17:27.520 --> 17:29.160
指的是

17:29.160 --> 17:30.600
根据具体的某一个

17:30.640 --> 17:32.080
一个文件生成的哈希

17:32.080 --> 17:33.760
那么这里呢

17:33.760 --> 17:34.720
他当然你要告诉他

17:34.720 --> 17:35.760
文件的内容是啥

17:35.760 --> 17:35.960
对吧

17:35.960 --> 17:37.320
内容是啥

17:37.320 --> 17:38.160
内容是啥呢

17:38.160 --> 17:41.600
那么这里边有个content文件内容

17:41.600 --> 17:42.520
文件内容呢

17:42.520 --> 17:43.680
我们这里把buffer传进来

17:43.680 --> 17:45.480
把buffer传进来

17:45.480 --> 17:47.160
那么这边呢

17:47.160 --> 17:47.560
也是

17:47.560 --> 17:48.840
这边调的时候

17:48.840 --> 17:49.760
把buffer传进来

17:49.760 --> 17:53.040
那么这样子就可以生成一个文件名

17:53.040 --> 17:54.000
file name

17:54.000 --> 17:55.360
看一下吧

17:55.360 --> 18:01.040
contentbuffer

18:02.040 --> 18:03.160
OK

18:03.160 --> 18:04.040
我们这里输出一下

18:04.040 --> 18:08.230
输出一下file name

18:08.230 --> 18:09.070
这些东西

18:09.070 --> 18:10.590
摊个热脑就行了

18:10.590 --> 18:11.390
如果有兴趣的话

18:11.390 --> 18:12.630
自己可以去做一下

18:12.630 --> 18:13.190
你看

18:13.190 --> 18:14.950
生成的哈希是不是这个

18:14.950 --> 18:15.350
对吧

18:15.350 --> 18:15.590
这个

18:15.590 --> 18:16.270
当然这个哈希呢

18:16.270 --> 18:17.430
你也可以

18:17.430 --> 18:18.030
怎么样呢

18:18.030 --> 18:19.710
也可以设置一个

18:19.710 --> 18:22.920
先子为五位

18:22.920 --> 18:25.480
来看一下

18:25.480 --> 18:27.440
生成的哈希是不是这个

18:27.440 --> 18:28.440
我们的文件名

18:28.440 --> 18:30.160
如果说这个文件没有后维

18:30.160 --> 18:30.680
对吧

18:30.680 --> 18:31.560
后维

18:31.560 --> 18:33.200
后维你可以使用est

18:33.320 --> 18:35.200
est来作为后维

18:35.200 --> 18:36.560
这些都是这个模块里面

18:36.560 --> 18:38.320
给你提供的功能

18:38.320 --> 18:39.160
那么这里

18:39.160 --> 18:41.120
一个加一个站位符est

18:41.120 --> 18:42.960
那么它就会根据这个文件的内容

18:42.960 --> 18:44.000
来生成后维

18:44.000 --> 18:47.820
咱们来看一下

18:47.820 --> 18:49.700
太可

18:49.700 --> 18:50.500
第二png

18:50.500 --> 18:51.860
看看是不是生成这么一个文件

18:51.860 --> 18:52.620
就是这个文件名

18:52.620 --> 18:53.140
不一定

18:53.140 --> 18:54.860
当然你能不能就用原式的文件名

18:54.860 --> 18:55.620
也可以

18:55.620 --> 18:56.260
当然不一定

18:56.260 --> 18:59.540
因为为什么不建议用原式的文件名呢

18:59.540 --> 19:01.740
因为它这里可能有很多个文件夹

19:01.740 --> 19:02.580
那么文件夹那边

19:02.580 --> 19:03.300
不同的文件夹

19:03.300 --> 19:04.740
结构里边可能有重名

19:04.740 --> 19:06.420
所以说不建议用原文名名

19:06.420 --> 19:08.660
我们根据图片的内容来生成

19:08.660 --> 19:10.380
是最好的

19:10.380 --> 19:11.700
那么就生成文件名了

19:11.700 --> 19:12.420
当然这样的文件名

19:12.420 --> 19:14.100
它并不会打包生成到最多的文件

19:14.100 --> 19:14.540
对吧

19:14.540 --> 19:16.260
那么怎么样生成到最多的文件呢

19:16.260 --> 19:17.100
这个上下文

19:17.100 --> 19:17.860
sys里边

19:17.860 --> 19:19.260
它给你提供了这么一个方法

19:19.260 --> 19:19.900
sys

19:19.900 --> 19:21.420
amd

19:21.420 --> 19:22.260
file

19:22.260 --> 19:24.060
这个mdfile的方法了

19:24.060 --> 19:26.500
了解这些东西都不是重点

19:26.500 --> 19:28.140
这个方法有什么用呢

19:28.140 --> 19:29.700
这个方法主要的作用是

19:29.700 --> 19:30.820
它往最终的

19:30.820 --> 19:34.020
它可以往最终的文件列表里边

19:34.060 --> 19:35.580
加入一个资源

19:35.580 --> 19:37.020
它是往这里边加入一个资源

19:37.020 --> 19:37.740
就这么简单

19:37.740 --> 19:38.220
amdfile

19:38.220 --> 19:39.660
就是往这里边加入一个资源

19:39.660 --> 19:41.660
你只需要给它提供两个参数

19:41.660 --> 19:42.980
一个是文件名

19:42.980 --> 19:43.620
file列

19:43.620 --> 19:44.300
一个是什么呢

19:44.300 --> 19:45.180
文件内容

19:45.180 --> 19:47.340
buffer

19:47.340 --> 19:48.100
就完了

19:48.100 --> 19:49.700
它就生成出来了

19:49.700 --> 19:50.340
就没了

19:50.340 --> 19:50.580
没了

19:50.580 --> 19:51.380
咱们来看一下

19:51.380 --> 19:52.380
有了这么一句话之后

19:52.380 --> 19:52.940
咱们来看一下

19:55.740 --> 19:56.580
生成

19:56.580 --> 19:57.540
你看是不是多了一个文件

19:58.740 --> 19:59.580
是多了一个文件

19:59.580 --> 19:59.900
对吧

19:59.900 --> 20:01.180
这个文件没有任何创可

20:01.180 --> 20:01.780
没有任何创可

20:01.780 --> 20:02.060
为什么

20:02.060 --> 20:04.340
它是直接往最终资源里边加的

20:04.340 --> 20:05.420
你看是不是多了一个文件

20:07.220 --> 20:08.340
没问题吧

20:08.340 --> 20:10.420
这就是把文件夹过去了

20:10.420 --> 20:11.220
文件夹过去

20:11.220 --> 20:12.860
文件名是啥呢

20:12.860 --> 20:15.060
也就是我们的src地址是啥呢

20:15.060 --> 20:16.380
src地址

20:16.380 --> 20:18.260
src地址是不是就是file列

20:18.260 --> 20:19.100
对吧

20:19.100 --> 20:19.940
返回

20:19.940 --> 20:20.900
file列

20:20.900 --> 20:22.180
不就是这个玩意吗

20:22.180 --> 20:23.220
对不对

20:23.220 --> 20:23.380
好

20:23.380 --> 20:25.260
那么现在我们再输出这个康验词

20:25.260 --> 20:27.620
那么得到的是不是就是文件路径了

20:27.620 --> 20:27.980
来

20:27.980 --> 20:31.760
我们来看一下

20:31.760 --> 20:32.560
你看

20:32.560 --> 20:34.160
输出的就是这个东西

20:34.440 --> 20:35.600
我们得到了文件路径

20:35.600 --> 20:37.240
那么看一下页面上

20:37.240 --> 20:38.040
能不能显示出来了

20:38.040 --> 20:38.840
文件

20:38.840 --> 20:39.480
图片

20:39.480 --> 20:40.440
所以也可以显示出来

20:40.440 --> 20:42.000
那么现在就跟之前不一样了

20:42.000 --> 20:43.680
之前是bass60

20:43.680 --> 20:43.840
对吧

20:43.840 --> 20:45.160
现在就是用文件路径

20:45.160 --> 20:46.080
你看

20:46.080 --> 20:47.120
文件路径

20:47.120 --> 20:47.680
对吧

20:47.680 --> 20:49.920
那么这两种方式是不是都可以

20:49.920 --> 20:51.640
我们还可以继续的

20:51.640 --> 20:52.720
继续来优化它

20:52.720 --> 20:55.400
比方说我们这个东西交给拥护来处理

20:55.400 --> 20:56.520
就是拥护到底

20:56.520 --> 20:57.480
让我们用哪种方式

20:57.480 --> 20:58.720
我们就用哪种方式

20:58.720 --> 21:01.440
比方说我们用户可以这样来规定

21:01.440 --> 21:03.680
就是我们在使用这个加载器的时候

21:03.760 --> 21:04.880
可以来进行配置

21:04.880 --> 21:05.680
把它写成个对象

21:06.680 --> 21:07.120
楼上

21:08.120 --> 21:09.880
可以来进行配置

21:09.880 --> 21:10.720
配置什么

21:10.720 --> 21:11.720
Option是对吧

21:11.720 --> 21:12.520
配置

21:12.520 --> 21:14.880
配置这里也可以写两个limit

21:14.880 --> 21:15.760
表示什么意思呢

21:15.760 --> 21:19.120
表示的是资源的限定

21:19.120 --> 21:19.840
限定有多大

21:19.840 --> 21:21.600
比方是多少字节

21:21.600 --> 21:24.480
比方说有3000个字节

21:24.480 --> 21:25.560
什么意思呢

21:25.560 --> 21:26.760
都是字型规定的

21:26.760 --> 21:29.080
这些配置都是字型规定的

21:29.080 --> 21:32.480
3000字节以上

21:32.600 --> 21:33.680
使用图片

21:33.680 --> 21:34.560
这个文件比较大了

21:34.560 --> 21:37.400
我们使用图片以内

21:37.400 --> 21:41.720
3000字节以内使用BS64

21:43.440 --> 21:44.640
BS64

21:44.640 --> 21:45.480
那是可以规定

21:46.440 --> 21:48.440
而且文件名我们也可以配置

21:48.440 --> 21:49.720
文件名可以配置一下

21:49.720 --> 21:51.080
自己的字型来配置

21:51.080 --> 21:52.760
文件名我们可以使用

21:53.960 --> 21:55.280
银沫槓

21:55.280 --> 21:56.800
然后是content hash

21:56.800 --> 21:57.920
当然也可以用Hash

21:57.920 --> 21:59.560
也可以用总的资源的hash

21:59.560 --> 22:00.840
也可以用创可hash

22:00.840 --> 22:02.160
都可以

22:02.200 --> 22:02.920
但是呢

22:02.920 --> 22:04.360
这里我们用content hash

22:04.360 --> 22:05.160
是最好的

22:05.160 --> 22:06.720
因为这个文件跟别的文件

22:06.720 --> 22:07.480
是没有什么关系的

22:07.480 --> 22:09.360
它就是个普通的资源文件

22:09.360 --> 22:10.720
这个资源文件内容变化

22:10.720 --> 22:12.400
跟着变化

22:12.400 --> 22:14.440
所以我们content hash比较好一点

22:14.440 --> 22:16.000
那么这里我们使用

22:16.000 --> 22:17.400
比方说

22:17.400 --> 22:18.560
5嘛

22:18.560 --> 22:19.240
第二什么呢

22:19.240 --> 22:19.880
ESD

22:19.880 --> 22:22.120
我们字型规定

22:22.120 --> 22:22.960
那么到这边来

22:22.960 --> 22:25.120
是不是就可以读到它的配置了

22:25.120 --> 22:25.960
读到配置

22:25.960 --> 22:27.320
来吧

22:27.320 --> 22:28.600
我们读到配置

22:28.600 --> 22:30.240
loader utl

22:30.240 --> 22:31.840
get options

22:31.880 --> 22:33.880
是不是得到配置

22:33.880 --> 22:35.680
那么这里呢

22:35.680 --> 22:37.680
upshins

22:37.680 --> 22:39.440
我们这里定了两个辨量

22:39.440 --> 22:40.240
一个是

22:40.240 --> 22:41.640
或者直接在这里解构嘛

22:41.640 --> 22:42.640
解构

22:42.640 --> 22:43.520
nemets

22:43.520 --> 22:44.560
如果没有的话

22:44.560 --> 22:45.080
没有的话

22:45.080 --> 22:46.920
我给你默认1000

22:46.920 --> 22:47.720
没有默认1000

22:47.720 --> 22:49.280
就是解构语法

22:49.280 --> 22:49.920
然后呢

22:49.920 --> 22:50.880
file name

22:50.880 --> 22:51.960
如果没有的话

22:51.960 --> 22:52.400
没有的话

22:52.400 --> 22:53.480
给你一个默认

22:53.480 --> 22:54.600
给你一个默认

22:54.600 --> 22:57.640
就是content hash

22:57.640 --> 22:59.320
第二ST

22:59.320 --> 23:00.280
给一个默认

23:00.280 --> 23:00.960
那么有的话

23:01.000 --> 23:01.720
我就解构出来了

23:01.720 --> 23:02.080
对吧

23:02.080 --> 23:02.440
有的话

23:02.440 --> 23:03.600
我就解构出来了

23:03.600 --> 23:05.800
那么是不是把配置里面东西解构出来

23:05.800 --> 23:06.640
得到配置

23:06.640 --> 23:08.000
那么现在是不是可以判断了

23:08.000 --> 23:10.120
如果说

23:10.120 --> 23:11.200
我们

23:11.200 --> 23:13.800
我们的这个实际的文件大小

23:13.800 --> 23:14.920
batnance

23:14.920 --> 23:16.720
大于等于了

23:16.720 --> 23:18.240
大于等于

23:18.240 --> 23:19.240
大于等于呢

23:19.240 --> 23:19.960
nemets

23:19.960 --> 23:21.080
是不是超过限度

23:21.080 --> 23:22.440
那么这个时候用什么呢

23:22.440 --> 23:23.080
这个时候

23:23.080 --> 23:24.720
这个时候我们是不是用content

23:24.720 --> 23:26.760
用文件的这种方式

23:26.760 --> 23:29.040
但是文件的方式要把这个东西传进去

23:29.040 --> 23:29.960
它还少一个参数

23:29.960 --> 23:30.920
file name

23:31.400 --> 23:32.880
就是file name的格式

23:32.880 --> 23:34.600
file name的格式

23:34.600 --> 23:36.280
我们这里传过来

23:36.280 --> 23:38.400
那么这边接受一下

23:38.400 --> 23:40.240
接受一下

23:40.240 --> 23:41.320
一个name

23:41.320 --> 23:43.000
那么这里就可以是不是把name

23:43.000 --> 23:43.920
放在这

23:43.920 --> 23:44.920
name放在这

23:44.920 --> 23:47.080
就让别人来规定这个文件名的格式

23:47.080 --> 23:49.240
我就这里不直接规定了

23:49.240 --> 23:52.320
那么这样子是不是得到文件路径了

23:52.320 --> 23:53.560
另一种情况就是

23:53.560 --> 23:54.640
它没有超过限度

23:54.640 --> 23:55.240
没有超过限度

23:55.240 --> 23:56.160
我不得到文件

23:56.160 --> 23:57.720
我不知道文件是不是用原式的这种

23:57.720 --> 23:59.440
bass64的方式

23:59.480 --> 24:00.320
文官哪一种方式

24:00.320 --> 24:01.800
我最终都可以导出

24:01.800 --> 24:02.960
关于是bass64也好

24:02.960 --> 24:03.920
还是文件路径也好

24:03.920 --> 24:05.240
我全部给你导出

24:05.240 --> 24:05.800
那么这样子

24:05.800 --> 24:06.840
就把控制权是不是

24:06.840 --> 24:07.720
通过配置的方式

24:07.720 --> 24:09.520
交给用户来处理了

24:09.520 --> 24:12.360
那么这个loader就可以更加灵活了

24:12.360 --> 24:14.120
那现在我们来试一下

24:14.120 --> 24:15.400
试一下

24:15.400 --> 24:17.240
我们把这个desk

24:17.240 --> 24:18.680
把这些东西把它删了

24:18.680 --> 24:20.320
删了

24:20.320 --> 24:22.600
好 接下来来运行

24:22.600 --> 24:24.240
npx

24:24.240 --> 24:27.910
webpack

24:27.910 --> 24:28.710
好 生成了

24:28.710 --> 24:30.110
你看现在是不是有图片

24:30.110 --> 24:31.510
对吧 有图片

24:31.510 --> 24:33.950
图片出来了

24:33.950 --> 24:35.590
图片出来了

24:35.590 --> 24:37.790
为什么感觉不太对呢

24:37.790 --> 24:39.270
等一下 看一下

24:39.270 --> 24:40.670
图片倒是出来了

24:40.670 --> 24:41.230
出来了

24:41.230 --> 24:43.710
目前它是用文件的方式

24:43.710 --> 24:45.230
你看文件名倒是对的

24:45.230 --> 24:46.430
文件的方式

24:46.430 --> 24:50.950
但是它有5个多kb

24:50.950 --> 24:53.870
它实际上是超过了这个限度的

24:53.870 --> 24:56.310
它实际上是超过了这个限度的

24:56.310 --> 24:58.830
那么为什么

24:58.830 --> 24:59.670
对 超过了限度

24:59.670 --> 25:01.310
它就用文件 对了

25:01.350 --> 25:03.550
好 咱们再来试一下

25:03.550 --> 25:05.030
再来试一下 删掉

25:05.030 --> 25:06.670
那么现在我们改一下配置

25:06.670 --> 25:09.190
把这个nm成了设成1万

25:09.190 --> 25:10.630
设成1万是高一点

25:10.630 --> 25:15.830
那么这样子我们再来运行

25:15.830 --> 25:17.750
你看 是不是没有生成图片

25:17.750 --> 25:18.990
那么你看图片还是能显示

25:18.990 --> 25:19.510
它就用什么

25:19.510 --> 25:20.910
用bs64来显示

25:20.910 --> 25:21.590
就这些东西呢

25:21.590 --> 25:23.310
其实它并不复杂

25:23.310 --> 25:25.950
它就是可以用loader的这种方式来实现

25:25.950 --> 25:27.430
本质上就是原因是什么呢

25:27.430 --> 25:29.150
本质上就是图片我们实际不了

25:29.150 --> 25:30.030
webpack它实际

25:30.030 --> 25:31.630
它能够把它读出来

25:31.630 --> 25:33.830
它把它当desk代码来读

25:33.830 --> 25:34.430
肯定读不了

25:34.430 --> 25:36.510
那么需要我们有一个夹载器

25:36.510 --> 25:38.190
loader它能够帮助我们

25:38.190 --> 25:40.150
把图片的二净字数据

25:40.150 --> 25:41.030
把它设为处

25:41.030 --> 25:43.070
那么它就会给你传一个二净字buffer

25:43.070 --> 25:44.230
把这种二净字数据

25:44.230 --> 25:45.750
组变成js代码

25:45.750 --> 25:47.230
你看这个东西是不是js代码

25:47.230 --> 25:49.070
你看从最多的文件

25:49.070 --> 25:50.750
从最多的代码里面看得非常清楚

25:50.750 --> 25:53.630
就是一个js代码

25:53.630 --> 25:54.910
那么我们再来一次

25:54.910 --> 26:00.160
如果说把它变成文件

26:00.160 --> 26:00.800
把变成文件

26:00.800 --> 26:02.160
再看这个MediaJS

26:02.160 --> 26:05.160
你看MediaJS就很简单了

26:05.160 --> 26:06.240
MediaJS它生成的东西

26:06.240 --> 26:07.440
就是Module Exports

26:07.440 --> 26:09.360
把这个东西导出来之后

26:09.360 --> 26:10.760
就这么简单

26:10.760 --> 26:12.440
所以loader其实

26:12.440 --> 26:14.080
反正说过来说过去

26:14.080 --> 26:16.560
其实就是把一种形设代码

26:16.560 --> 26:18.520
通过你一种某种逻辑

26:18.520 --> 26:19.520
这些都是逻辑

26:19.520 --> 26:21.400
转换成另一种格设代码

26:21.400 --> 26:22.920
就是一种js代码

26:22.920 --> 26:23.600
那么它就可以

26:23.600 --> 26:25.600
这样你转换

26:25.600 --> 26:26.960
未拍的它就认识别了

26:26.960 --> 26:29.080
它就继续把这个代码分析成为

26:29.080 --> 26:29.840
抽象与法术

26:29.840 --> 26:32.400
然后进入一代就是一样的了

26:32.400 --> 26:33.480
OK 这就是

26:33.480 --> 26:35.120
咱们这一刻给它演示的

26:35.120 --> 26:36.320
就是这么一个例子

26:36.320 --> 26:37.280
这一刻的东西

26:37.280 --> 26:38.800
可能比上一刻稍微难一点

26:38.800 --> 26:40.760
不过有兴趣的同学可以去试一下

26:40.760 --> 26:42.120
也挺有趣的

26:42.120 --> 26:43.680
这是关于loader

26:43.680 --> 26:44.640
loader我们就讲到这了

