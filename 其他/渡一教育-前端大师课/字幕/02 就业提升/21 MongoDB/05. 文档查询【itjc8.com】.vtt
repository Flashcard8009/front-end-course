WEBVTT

00:00.110 --> 00:06.910
我们把查询说了 之前打算先把则三改说了

00:06.910 --> 00:09.110
然后再讲查询 但是想来想去的话

00:09.110 --> 00:11.110
我最好把查询先说了 说了过后了

00:11.110 --> 00:14.510
后边讲修改 删除都比较简单一点

00:14.510 --> 00:18.510
咱们来 首先我补充两个知识

00:18.510 --> 00:23.710
一个是关于MongerDB本身以及Monger故事

00:23.710 --> 00:26.910
我们约美级科都讲的是一个原生操作

00:26.910 --> 00:29.510
以及通过Monger故事进行操作 对吧

00:29.510 --> 00:32.310
那么两个操作的对比 给大家画了一张图

00:32.310 --> 00:33.910
就是如果说你通过MongerDB

00:33.910 --> 00:35.710
就是一个数据库本身进行操作的话

00:35.710 --> 00:37.510
就在控制台里边写 对不对

00:37.510 --> 00:41.910
就在控制台里边写Monger 对吧

00:41.910 --> 00:44.710
进入一个命令 然后开始输写我们的查询

00:44.710 --> 00:47.910
以及各种命令都可以在这里边写

00:47.910 --> 00:49.510
写的也是介石代码 对吧

00:49.510 --> 00:51.910
之前演示过 也是介石代码

00:51.910 --> 00:53.510
这是通过这种方式

00:53.510 --> 00:55.910
那么我们使用的API就是MongerDB

00:55.910 --> 00:58.710
它本身跟我们提供的API进行输写

00:59.110 --> 01:02.910
然后如果说我们使用Monger故事来进行操作的话

01:02.910 --> 01:04.710
那么我们使用的API是Monger故事

01:04.710 --> 01:05.910
给我们提供的API

01:05.910 --> 01:10.510
那么他们两个的API大部分操作感受都差不多

01:10.510 --> 01:12.110
只是有一些区别

01:12.110 --> 01:14.110
我们讲的时候会注意一些区别

01:14.110 --> 01:17.110
然后我们定义的模型以及Skeema

01:17.110 --> 01:20.310
Skeema在哪呢 是在这 在Monger故事里边

01:20.310 --> 01:22.110
实际上MongerDB有没有Skeema

01:22.110 --> 01:25.310
实际上它新版本里边是有的 是有Skeema的

01:25.310 --> 01:28.110
只不过它那个Skeema跟Monger故事里边的Skeema

01:28.110 --> 01:28.910
还是有一些区别

01:28.910 --> 01:31.110
比如Monger故事里边Skeema是不是有很多验证

01:31.110 --> 01:34.310
那么这些验证都发生在Monger故事里边

01:34.310 --> 01:35.910
对吧 发生在这里边

01:35.910 --> 01:38.510
所以我们操作它的时候是要经过Skeema验证的

01:38.510 --> 01:39.910
就这个区别

01:39.910 --> 01:40.910
然后Monger故事里边

01:40.910 --> 01:43.810
它Skeema里边不是会定义锁印吗

01:43.810 --> 01:44.310
对不对

01:44.310 --> 01:45.510
我们后边还有一些课

01:45.510 --> 01:46.710
专门来讲这个锁印

01:46.710 --> 01:48.710
定义锁印的时候

01:48.710 --> 01:51.310
实际上它会把锁印放到MongerDB里边

01:51.310 --> 01:53.710
所以我们的锁印最终会在MongerDB里边

01:53.710 --> 01:55.310
因此我们上节后回忆一下

01:55.310 --> 01:57.010
我们的模型验证

01:57.010 --> 01:59.110
验证发生在哪发生在Monger故事里边

01:59.110 --> 02:00.710
根本就没有到数据库

02:00.710 --> 02:01.310
原来的意思吧

02:01.310 --> 02:02.710
所以我们还有单独一个方法

02:02.710 --> 02:04.910
Validate直接验证模型

02:04.910 --> 02:06.610
跟我们数据库没关系

02:06.610 --> 02:08.810
然后如果说我们真正的去做什么

02:08.810 --> 02:10.110
那个数据库操作的时候

02:10.110 --> 02:11.410
它会有一个锁印的限制

02:11.410 --> 02:12.510
比方说尾翼锁印

02:12.510 --> 02:13.410
对吧

02:13.410 --> 02:14.610
锁印有很多类别

02:14.610 --> 02:16.310
其中一个类别就是尾翼锁印

02:16.310 --> 02:17.010
尾翼锁印的话

02:17.010 --> 02:18.410
还会保证值的尾翼

02:18.410 --> 02:19.310
所以它会爆错

02:19.310 --> 02:22.510
当时如果说我们的账号出现了重复

02:22.510 --> 02:23.610
爆错是谁爆错的

02:23.710 --> 02:25.210
是MongerDB爆错的

02:25.210 --> 02:26.110
它爆错了

02:26.110 --> 02:27.210
我们当我们Monger故事

02:27.210 --> 02:28.410
要去操作数据库的时候

02:28.410 --> 02:30.010
实际上它经过了一个过程

02:30.010 --> 02:31.910
就是我们调用API去操作Monger故事

02:31.910 --> 02:33.410
Monger故事要操作数据库

02:33.410 --> 02:34.210
它怎么办

02:34.210 --> 02:36.310
它首先调用的是MongerDB驱动

02:36.310 --> 02:37.410
之前是不是介绍过的

02:37.410 --> 02:39.510
MongerDB它会不同的语言

02:39.510 --> 02:41.510
给它添加了不同的驱动程序

02:41.510 --> 02:43.410
所以它会去调用一个驱动程序的API

02:43.410 --> 02:44.510
去操作数据库

02:44.510 --> 02:46.010
而驱动程序最终会调用

02:46.010 --> 02:47.910
MongerDB里面的API去操作

02:47.910 --> 02:50.310
是这么一条联系关系

02:50.410 --> 02:52.610
而MongerDB里面的驱动程序它的API

02:52.610 --> 02:54.310
跟这个API就非常接近了

02:54.310 --> 02:55.510
几乎是一样的

02:55.510 --> 02:57.910
所以我们直接学习这个API就够了

02:57.910 --> 03:00.210
这是它们的两个的

03:00.210 --> 03:01.810
它一些差一点的对比图

03:01.810 --> 03:03.010
给大家说一下

03:03.010 --> 03:04.110
另外给它补充一个

03:04.110 --> 03:06.310
就是关于MongerDB的备份语恢复

03:06.310 --> 03:08.910
因为我给大家加了一些很多的数据

03:08.910 --> 03:10.210
因此我一回去

03:10.210 --> 03:11.710
好像没有讲这个备份语恢复

03:11.710 --> 03:13.010
那么给它讲一讲

03:13.010 --> 03:14.510
首先说我们恢复

03:14.510 --> 03:16.110
恢复怎么来恢复呢

03:17.110 --> 03:20.410
我们在这里的数据库里边

03:20.410 --> 03:22.610
咱们直接到那个数据库里边

03:23.910 --> 03:24.910
数据库里边

03:24.910 --> 03:27.010
我这个数据库里边已经有很多数据了

03:27.010 --> 03:28.410
我用那个

03:28.410 --> 03:30.610
它给你自动分了页

03:30.610 --> 03:31.910
实际上这个数据很多了

03:31.910 --> 03:33.210
很多数据了

03:33.210 --> 03:35.110
然后由于这里边也有很多数据

03:35.110 --> 03:36.110
那么这些数据

03:36.110 --> 03:37.110
我们先说备份

03:37.110 --> 03:38.010
怎么来备份

03:38.010 --> 03:40.510
就是说如果说你要考不了另外一台计算机

03:40.510 --> 03:42.110
或者是分享给朋友

03:42.110 --> 03:44.210
或者是在服务器上要定期做备份

03:44.210 --> 03:45.310
那么怎么备份呢

03:45.410 --> 03:46.010
备份的话

03:46.010 --> 03:48.010
你要使用一个命令

03:48.010 --> 03:49.610
叫做Mongodom

03:49.610 --> 03:51.210
Dom不叫单词

03:51.210 --> 03:51.710
什么意思呢

03:51.710 --> 03:52.610
叫做轻道

03:52.610 --> 03:53.510
到了RG

03:53.510 --> 03:54.410
实际上它不是RG

03:54.410 --> 03:55.410
是我们的数据库

03:55.410 --> 03:56.610
就把轻道出来

03:56.610 --> 03:57.610
道出来

03:57.610 --> 03:59.110
那么这里怎么写这个命令呢

03:59.110 --> 04:00.010
比方说

04:01.610 --> 04:03.410
我们把它备份到我们这吧

04:03.410 --> 04:04.810
备份到我们的工程里边

04:04.810 --> 04:06.510
我们把备份到我们的工程里边

04:06.510 --> 04:07.510
所以说我们在

04:07.510 --> 04:08.610
首先进入这个目录

04:08.610 --> 04:09.710
进入这个目录过后

04:09.710 --> 04:13.210
我们这里使用一个命令叫做Mongodom

04:13.210 --> 04:14.910
然后后面给一个参数

04:15.010 --> 04:15.810
叫做钢地

04:15.810 --> 04:17.610
表示你要备份哪一个数据库

04:17.610 --> 04:18.710
备份哪个数据库呢

04:18.710 --> 04:20.710
我们的数据库的名称

04:21.310 --> 04:23.010
叫做Test

04:23.010 --> 04:23.410
对吧

04:23.410 --> 04:24.810
所以要叫做这个名称

04:24.810 --> 04:25.010
好

04:25.010 --> 04:26.810
那么我们备份这个数据库啊

04:27.210 --> 04:27.910
好来吧

04:29.510 --> 04:30.410
备份这个数据库

04:30.410 --> 04:31.610
Test这个数据库

04:31.610 --> 04:32.610
然后把它备份到哪呢

04:32.610 --> 04:33.970
一个钢O就是输出

04:33.970 --> 04:35.710
output输出目录

04:35.710 --> 04:37.310
output输出目录在哪呢

04:37.310 --> 04:38.610
我们可以用当前目录

04:38.610 --> 04:40.110
当前目录就相对于是

04:40.110 --> 04:41.310
咱们的工作目录

04:41.310 --> 04:42.910
就是命令行所在那目录

04:42.910 --> 04:43.710
当前目录

04:43.710 --> 04:45.410
当然你也可以写决定路径

04:45.410 --> 04:46.410
当前目录下面呢

04:46.410 --> 04:49.010
我们给他建立一个文件夹吧

04:49.010 --> 04:49.610
bicup

04:50.710 --> 04:52.210
备份到这个目录下面

04:52.210 --> 04:53.210
好来吧

04:53.210 --> 04:55.010
我们这里边使用bicup

04:56.010 --> 04:57.110
好回程

04:57.110 --> 04:58.510
那你看他就完成了

04:58.510 --> 04:58.810
钢

04:59.910 --> 05:01.210
就是完成了备份

05:01.210 --> 05:03.210
完成了备份

05:03.210 --> 05:03.810
一个是Test

05:03.810 --> 05:05.410
User是一个Test operation

05:05.410 --> 05:05.710
好

05:05.710 --> 05:07.510
咱们来看一下这个目录里边的东西

05:07.510 --> 05:09.010
是不是有多那个文件夹

05:09.010 --> 05:10.210
这个文件夹里边

05:10.210 --> 05:12.310
就有这么一些备份文件了

05:12.310 --> 05:13.110
那么这一备份文件

05:13.110 --> 05:14.210
实际上是二镜子的

05:14.210 --> 05:16.110
像这个叫做白省

05:16.110 --> 05:16.810
白省

05:16.810 --> 05:18.810
白省格式就是Bandery JSON

05:18.810 --> 05:21.510
就是二镜子格式的数据

05:21.510 --> 05:23.910
二镜子格式的内阶层数据

05:23.910 --> 05:24.810
那么备份到这了

05:24.810 --> 05:25.510
那么具体的格式

05:25.510 --> 05:26.810
大家不用去care

05:26.810 --> 05:28.010
那么如果我们备份过后

05:28.010 --> 05:29.110
如何来恢复呢

05:29.110 --> 05:30.310
比方说我们到数据库里边

05:30.310 --> 05:31.510
我们把这个数据库删掉

05:31.510 --> 05:32.810
drop data base

05:32.810 --> 05:33.710
给删除掉

05:33.710 --> 05:34.410
好删除掉过后

05:34.410 --> 05:35.610
我们来如何来恢复呢

05:35.610 --> 05:36.410
就可以使用命令

05:36.410 --> 05:38.510
叫做Mango Restore

05:39.710 --> 05:40.710
叫做重新

05:40.710 --> 05:42.210
restore就是重新存储

05:43.610 --> 05:44.910
恢复的后面一个钢地

05:44.910 --> 05:46.110
恢复的数据库名字

05:46.110 --> 05:47.410
当然也可以用别的名字

05:47.410 --> 05:48.910
比方说我们这里的数据库

05:48.910 --> 05:51.410
有什么有用户有操作

05:51.410 --> 05:52.310
没什么名字

05:52.310 --> 05:53.310
没什么名字可选

05:53.310 --> 05:54.810
那就随便还是用这些什么

05:54.810 --> 05:56.110
当这个名字可以改

05:56.110 --> 05:57.110
跟那个白色库一样

05:57.110 --> 05:57.510
对吧

05:57.510 --> 05:59.010
数据库的名字无所谓的

05:59.010 --> 05:59.310
然后呢

05:59.310 --> 06:00.310
接下来你写什么呢

06:00.310 --> 06:01.310
写的个备份目录

06:01.310 --> 06:02.610
备份目录是BIKE HUB

06:02.610 --> 06:03.310
下边的什么呢

06:03.310 --> 06:04.010
Test

06:04.010 --> 06:04.310
对吧

06:04.310 --> 06:06.310
我们的文件在哪呢

06:06.310 --> 06:07.710
我们的文件在这

06:07.710 --> 06:08.510
就在这

06:08.510 --> 06:09.610
在这个目录下面

06:09.610 --> 06:09.810
好

06:09.810 --> 06:11.410
我们用BIKE HUB TEST

06:11.410 --> 06:12.810
好 回色

06:12.810 --> 06:13.310
那么这里呢

06:13.310 --> 06:14.310
他告诉你

06:14.310 --> 06:16.310
2639个文档呢

06:16.310 --> 06:17.810
已经重新被存出了

06:17.810 --> 06:18.710
成功的被存出了

06:18.710 --> 06:20.110
没有一个文档失败

06:20.110 --> 06:20.410
好了

06:20.410 --> 06:21.610
那么我们现在再看一下数据库

06:21.610 --> 06:23.210
我们这里点击右键

06:23.210 --> 06:24.910
refresh

06:24.910 --> 06:25.410
刷新

06:25.410 --> 06:26.110
是不是已经出来了

06:26.110 --> 06:26.410
对吧

06:26.410 --> 06:27.610
我们的数据又回来了

06:27.610 --> 06:27.810
对吧

06:27.810 --> 06:29.610
这就是mangoDB的原来备份和恢复

06:29.610 --> 06:30.610
那么我们这个备份文件

06:30.610 --> 06:32.210
就给大家放在这

06:32.210 --> 06:33.810
大家可以用这些课的工程

06:33.810 --> 06:35.210
去恢复一下数据库

06:35.210 --> 06:36.410
因为我们这些课要讲查

06:36.410 --> 06:37.910
需要很多数据来测试

06:37.910 --> 06:38.610
其实这些数据呢

06:38.610 --> 06:40.210
你要加数据的时候

06:40.210 --> 06:41.110
其实也非常简单

06:41.110 --> 06:43.710
就是利用我们的mode介绍

06:43.710 --> 06:45.310
就是模拟数据

06:45.310 --> 06:47.710
已经在稍微的手动操作一下

06:47.710 --> 06:48.910
就可以制造很多数据了

06:48.910 --> 06:50.310
用一个循环什么样子

06:50.310 --> 06:51.310
一个数据之类的

06:51.310 --> 06:53.110
就可以加很多数据进去了

06:53.110 --> 06:53.310
好

06:53.310 --> 06:55.910
那么接下来我们开始来政参

06:55.910 --> 06:58.410
就是mangoDB的原生查询

06:58.410 --> 07:00.010
先看一下原生怎么来查询

07:00.010 --> 07:02.610
就直接操作mangoDB这个数据库进行查询

07:02.610 --> 07:04.310
那么你学习了原生查询过后

07:04.310 --> 07:05.110
再去学习这个东西

07:05.110 --> 07:06.610
就非常简单了

07:06.610 --> 07:08.110
我们现在说原生查询

07:08.110 --> 07:09.610
原生查询的语法非常简单

07:09.610 --> 07:10.610
就是DB

07:10.610 --> 07:11.610
扛了一个型

07:11.610 --> 07:13.310
后边给上一个集合的名字

07:13.310 --> 07:14.110
然后fan的

07:14.110 --> 07:15.710
后边两个可选参数

07:15.710 --> 07:17.110
可选参数一个是filter

07:17.110 --> 07:19.610
表示的是查询条件

07:19.610 --> 07:22.310
就跟那个mysoc里边的ware差不多

07:22.310 --> 07:24.510
perception叫做投影

07:24.510 --> 07:25.510
投影啥意思

07:25.510 --> 07:28.810
对比mysoc的话就相当于是select

07:28.810 --> 07:30.310
表示查询哪些数据

07:30.310 --> 07:30.510
对吧

07:30.510 --> 07:31.710
查询哪些字段

07:31.710 --> 07:32.610
这就是一个查询

07:32.610 --> 07:34.010
比方说咱们来一个

07:34.010 --> 07:34.110
比方说咱们来一个

07:34.110 --> 07:34.210
比方说咱们来一个

07:34.210 --> 07:34.310
比方说咱们来一个

07:34.310 --> 07:34.410
比方说咱们来一个

07:34.410 --> 07:34.710
比方说咱们来一个

07:34.710 --> 07:34.810
比方说咱们来一个

07:34.810 --> 07:34.910
比方说咱们来一个

07:35.010 --> 07:37.010
芒果进去

07:37.010 --> 07:38.210
然后让我们使用

07:38.210 --> 07:40.210
DB users fan的

07:40.210 --> 07:41.910
里边两个都是可选参数

07:41.910 --> 07:42.910
所以说我们可以不写

07:42.910 --> 07:44.310
直接查是不是全部查出来了

07:44.310 --> 07:45.310
它告诉你

07:45.310 --> 07:47.510
这里边还有很多很多数据

07:47.510 --> 07:49.710
让你type-8

07:49.710 --> 07:50.810
可以看更多

07:50.810 --> 07:52.310
可以看更多

07:52.310 --> 07:53.110
这有很多很多数

07:53.110 --> 07:54.310
因为有几百条

07:54.310 --> 07:56.410
所以说它显示不完

07:56.410 --> 07:57.410
这就查出来了

07:57.410 --> 07:58.010
对吧

07:58.010 --> 07:59.710
但是这个不是很好看

07:59.710 --> 08:01.510
我们也可以到那个

08:01.510 --> 08:02.410
robo3t里边

08:02.410 --> 08:03.410
比方打开user

08:03.410 --> 08:04.310
它默认你看一下

08:04.410 --> 08:05.710
是不是查询的全部

08:05.710 --> 08:07.210
当然它这里的写的是

08:07.210 --> 08:09.210
用一个函数要get collection

08:09.210 --> 08:11.310
user是把这个集合找到

08:11.310 --> 08:12.910
那么我们是直接使用这个集合

08:12.910 --> 08:13.710
所以是一样的

08:13.710 --> 08:16.310
效果是一样的

08:16.310 --> 08:17.710
concerned R

08:17.710 --> 08:18.310
重新运行

08:18.310 --> 08:19.510
是不是效果一样的

08:19.510 --> 08:21.010
对不对

08:21.010 --> 08:22.710
然后我们这边

08:22.710 --> 08:24.010
这边的查询结构里边

08:24.010 --> 08:25.410
你可以用这个表格试图

08:25.410 --> 08:26.610
你看这可以切换

08:26.610 --> 08:28.210
一种试图用对象

08:28.210 --> 08:29.610
节省格式浏览试图

08:29.610 --> 08:31.010
一种试用表格试图

08:31.010 --> 08:33.710
一种试用文本试图

08:33.810 --> 08:34.710
文本试图是这样子

08:34.710 --> 08:36.210
文本试图看得比较详细点

08:36.210 --> 08:37.510
我们用文本试图吧

08:37.510 --> 08:38.610
这就是一个查询

08:38.610 --> 08:38.810
对吧

08:38.810 --> 08:40.410
非常简单

08:40.410 --> 08:41.410
没问题吧

08:41.410 --> 08:42.910
这就是一个查询

08:42.910 --> 08:43.910
那么我们一个个说

08:43.910 --> 08:45.210
首先说它的返回结果

08:45.210 --> 08:46.410
它返回的是一个什么呢

08:46.410 --> 08:47.610
返回的是一个邮标

08:47.610 --> 08:48.810
咱们来看一下返回结果

08:48.810 --> 08:50.110
先说返回结果

08:50.110 --> 08:51.010
邮标是什么东西呢

08:51.010 --> 08:52.310
邮标叫cursor

08:52.310 --> 08:55.110
就有点像CSS里面的cursor鼠标

08:55.110 --> 08:55.910
对吧

08:55.910 --> 08:57.210
在这里的这个场景下面

08:57.210 --> 08:59.610
我们把它翻译成邮标

08:59.610 --> 09:00.310
邮标实际上

09:00.310 --> 09:03.410
它就是相当于是一个指针

09:03.410 --> 09:05.210
在我们的GS里面对比的话

09:05.210 --> 09:06.410
就相当于是一个迭代器

09:06.410 --> 09:07.910
迭代器里面说有next

09:07.910 --> 09:09.710
下一个

09:09.710 --> 09:10.910
那么邮标差不多

09:10.910 --> 09:13.210
我们来看一下这个邮标的概念

09:13.210 --> 09:14.610
比方说我们查询到了一个结果

09:14.610 --> 09:15.510
就查询所有

09:15.510 --> 09:16.910
查询到一个很多的结果

09:16.910 --> 09:18.510
我们邮标相当于是个指针

09:18.510 --> 09:20.210
它指向的一开始指向的是什么呢

09:20.210 --> 09:21.310
指向的是头部

09:21.310 --> 09:21.910
头指针

09:21.910 --> 09:23.210
头指针是空的

09:23.210 --> 09:25.810
头指针的主要重点就是指向下一个

09:25.810 --> 09:28.810
当我们去调用邮标里边的next的时候

09:28.810 --> 09:30.010
它会指向下一个

09:30.010 --> 09:32.610
于是同时把下一个结果返回

09:32.610 --> 09:35.610
然后当我们的邮标再去调用next

09:35.610 --> 09:36.910
它又会指向下一个

09:36.910 --> 09:38.210
又把下一个结果返回

09:38.210 --> 09:40.710
实际上这个图有点奇异

09:40.710 --> 09:41.810
就好像有一个多个邮标

09:41.810 --> 09:42.610
实际上只有一个

09:42.610 --> 09:44.510
它在不断的向下移动

09:44.510 --> 09:45.910
它没有办法往回移移动

09:45.910 --> 09:47.810
只能往下移动

09:47.810 --> 09:49.410
移动到最后一个就没有了

09:49.410 --> 09:51.210
比方说咱们来举个例子

09:51.210 --> 09:51.910
我们在这里呢

09:51.910 --> 09:57.110
dbcursor dbfan

09:57.110 --> 09:59.610
我们是不是dbusers fan

09:59.610 --> 10:01.410
是不是查询了所有的用户

10:01.510 --> 10:03.310
那么它会把这个查询的结果

10:03.310 --> 10:04.810
用一个邮标来表示

10:04.810 --> 10:06.010
cursor用邮标来表示

10:06.010 --> 10:07.210
这个邮标指向哪呢

10:07.210 --> 10:09.010
指向查询结果的最开始的位置

10:09.010 --> 10:10.710
就是这个位置

10:10.710 --> 10:11.810
我们来看一下

10:11.810 --> 10:13.010
好 咱们来看一下

10:13.010 --> 10:15.210
我们可以调用邮标的cursor.next

10:15.210 --> 10:16.510
是不是找到下一个

10:16.510 --> 10:18.110
那么让邮标向下移动

10:18.110 --> 10:18.910
是不是移动到下一个

10:18.910 --> 10:21.810
它就把第一条结果返回了

10:21.810 --> 10:24.010
是不是第一条结果返回了

10:24.010 --> 10:27.210
然后我们再来cursor.next

10:27.210 --> 10:28.410
它又继续往下

10:28.410 --> 10:30.410
比方说第一个人的名字叫line

10:30.410 --> 10:31.610
名字是水移生成的

10:31.610 --> 10:32.610
所以下一个叫eqline

10:32.610 --> 10:33.210
对不对

10:33.210 --> 10:34.410
它是一直往下

10:34.410 --> 10:36.210
直到找不到位置

10:36.210 --> 10:36.810
没啥意思吗

10:36.810 --> 10:37.610
这就是邮标

10:37.610 --> 10:39.610
那么它为什么要用邮标这种模式呢

10:39.610 --> 10:40.510
不直接可以问个数据

10:40.510 --> 10:41.410
不管了吗

10:41.410 --> 10:43.010
为什么要用邮标这种格式呢

10:43.010 --> 10:44.010
你可以想象

10:44.010 --> 10:45.210
咱们的查询

10:45.210 --> 10:46.610
因为这个monger db

10:46.610 --> 10:48.910
它是主要是处理大数据的

10:48.910 --> 10:50.310
数据量非常非常大的

10:50.310 --> 10:50.910
大的数据

10:50.910 --> 10:52.310
它要提高查询效率

10:52.310 --> 10:52.810
那如果说

10:52.810 --> 10:53.710
它把第一查询结果

10:53.710 --> 10:55.310
直接用一个数据给我的话

10:55.310 --> 10:57.310
那么内存是不是会吃不消

10:57.310 --> 10:59.310
有网络我这里有几千万条数据

10:59.310 --> 11:00.710
它把查出来的结果全部给我

11:00.710 --> 11:01.910
我是不是内存吃不消

11:01.910 --> 11:02.810
那怎么办呢

11:02.810 --> 11:04.310
它给我的啥都没有

11:04.310 --> 11:05.310
就一个纸针

11:05.310 --> 11:06.610
就一个纸针

11:06.610 --> 11:07.210
这个纸

11:07.210 --> 11:08.110
它就是内存里边

11:08.110 --> 11:09.410
它没有这些结果

11:09.410 --> 11:10.610
这结果还是在吃盘上

11:10.610 --> 11:11.910
它用纸针来操作

11:11.910 --> 11:14.810
我纸针指向我的第一条结果

11:14.810 --> 11:15.710
然后那个是

11:15.710 --> 11:18.210
是不是查一条出来到内存

11:18.210 --> 11:20.010
然后再那个是再查一条到内存

11:20.010 --> 11:20.310
对吧

11:20.310 --> 11:22.110
这就是迭战期的优势

11:22.110 --> 11:23.710
它可以要哪些数据

11:23.710 --> 11:24.510
取哪些数据

11:24.510 --> 11:26.310
我不需要把全部拿出来

11:26.310 --> 11:28.110
就起这么一个作用

11:28.110 --> 11:29.010
那么这个科

11:29.010 --> 11:30.610
那为什么刚才又同学教问了

11:30.610 --> 11:32.310
为什么我这里优热是fan的

11:32.310 --> 11:33.510
它能够查出来这么多的

11:33.510 --> 11:35.310
它能够显示这么多的

11:35.310 --> 11:36.610
是这个原因

11:36.610 --> 11:38.010
是因为在控制台里边

11:38.010 --> 11:41.210
它为了让我们有更加好的交互体验

11:41.210 --> 11:42.610
它要把东西给显示出来

11:42.610 --> 11:44.110
让我们更加清楚的看到

11:44.110 --> 11:47.310
因此你凡是给它的是一个邮标

11:47.310 --> 11:49.010
比方说像这个东西

11:49.010 --> 11:51.010
是不是给它的一个邮标

11:51.010 --> 11:51.410
对吧

11:51.410 --> 11:52.110
给它的一个邮标

11:52.110 --> 11:53.310
它如果说遇到邮标的话

11:53.310 --> 11:55.510
它会自动的把这个邮标便利出来

11:55.510 --> 11:56.310
一个一个拿出来

11:56.310 --> 11:58.210
全部给你显示出来

11:58.310 --> 11:59.310
咱们来看一下吧

11:59.310 --> 12:00.310
我如果说我们这里

12:00.310 --> 12:07.110
cursor db users fan的

12:07.110 --> 12:08.010
是不是拿到邮标

12:08.010 --> 12:10.210
那么我们直接把邮标打印一下

12:10.210 --> 12:12.010
你看控制台是不是自动会帮你便利

12:12.010 --> 12:12.410
对吧

12:12.410 --> 12:14.210
自动帮你便利这个邮标

12:14.210 --> 12:16.410
这就是它为什么可以显示出来

12:16.410 --> 12:18.210
实际上它本身是没有结果的

12:18.210 --> 12:19.310
实际上只有一个邮标

12:19.310 --> 12:21.610
是不是控制台它自动给你便利了

12:21.610 --> 12:22.710
我们来看一下这个邮标

12:22.710 --> 12:24.410
邮标实际上是个对象

12:24.410 --> 12:26.810
那么这个邮标它有哪些的成员

12:26.810 --> 12:27.910
第一个就是那个方法

12:27.910 --> 12:29.110
我们之前是看到过的

12:29.110 --> 12:30.710
往下一个一个一个移动

12:30.710 --> 12:31.810
如果说没有下一个的话

12:31.810 --> 12:32.910
它就爆错了

12:32.910 --> 12:33.810
直接爆错

12:33.810 --> 12:35.610
另外一个方法叫house next

12:35.610 --> 12:38.410
表示邮标是否还能向后移动

12:38.410 --> 12:40.210
如果说还能向后移动的话

12:40.210 --> 12:41.410
它就返回布尔

12:41.410 --> 12:42.710
如果说不能向后移动的话

12:42.710 --> 12:44.710
那就返回force

12:44.710 --> 12:46.210
它是这么一个逻辑

12:46.210 --> 12:48.110
那么我们是不是可以手动来便利

12:48.110 --> 12:49.410
比方说我们cursor

12:49.410 --> 12:50.710
当然我们一般来说

12:50.710 --> 12:51.910
也不会去手动便利

12:51.910 --> 12:53.710
只是说一下这个

12:53.710 --> 12:55.410
fan打一个邮标

12:55.410 --> 12:56.610
让我们怎么来写这个单码的

12:56.610 --> 12:57.610
我们可以这样写

12:57.610 --> 13:01.610
while cursor has next

13:01.610 --> 13:01.810
对吧

13:01.810 --> 13:04.210
它如果说只要有下一个

13:04.210 --> 13:05.210
按住shift

13:05.210 --> 13:06.610
回说它就不会运行

13:06.610 --> 13:07.410
这是fan行

13:16.200 --> 13:16.500
完了

13:18.200 --> 13:19.200
听着吧

13:19.200 --> 13:20.400
我又点了啥东西

13:21.800 --> 13:23.500
再来得到邮标

13:23.500 --> 13:31.610
然后while cursor has next

13:31.610 --> 13:32.410
好 换行

13:32.410 --> 13:33.510
然后每一次

13:33.510 --> 13:35.510
我们每一次

13:35.510 --> 13:37.410
我们打印一下cranes

13:37.410 --> 13:39.110
打印一下cursor

13:39.110 --> 13:40.910
它里面有一个函数叫cranes

13:40.910 --> 13:43.910
cursor next

13:43.910 --> 13:44.710
如果说有下一个

13:44.710 --> 13:47.410
我又打印下一个

13:47.410 --> 13:49.110
直到循环结束

13:49.110 --> 13:50.510
循环结束是不是没了

13:50.510 --> 13:52.110
对吧

13:52.110 --> 13:53.410
这里每一次打印出来

13:53.410 --> 13:53.910
是不是这个

13:53.910 --> 13:55.410
464个objects

13:55.410 --> 13:56.110
对不对

13:56.110 --> 13:56.810
就是一个objects

13:56.810 --> 13:57.710
有很多

13:57.710 --> 13:58.310
这里有很多

13:58.310 --> 13:59.310
400多个

13:59.310 --> 14:01.310
全部打印出来了

14:01.310 --> 14:02.010
那么这里

14:02.010 --> 14:03.710
有些人在说

14:03.710 --> 14:06.010
为什么没有把信息显示出来了

14:06.010 --> 14:08.110
因为我们这里要用这种方式

14:08.110 --> 14:09.210
如果要显示信息的话

14:09.210 --> 14:10.510
叫prase结束

14:14.010 --> 14:15.410
邮标已经结束了

14:15.410 --> 14:16.010
已经结束了

14:16.010 --> 14:17.510
它就无法进入循环了

14:17.510 --> 14:19.110
我们再重新来一次

14:19.110 --> 14:21.110
重新拿一个新的邮标

14:21.110 --> 14:21.610
再来

14:22.810 --> 14:23.910
prase结束

14:23.910 --> 14:25.310
是不是可以打印出来了

14:25.310 --> 14:25.510
对吧

14:25.510 --> 14:26.410
就这么简单

14:26.410 --> 14:27.510
这是关于邮标

14:27.510 --> 14:28.310
了解一下就行了

14:28.310 --> 14:29.410
我们平时也不会去用

14:29.410 --> 14:31.910
它本质就是通过邮标去一个个找的

14:32.210 --> 14:33.710
然后邮标里边还有一些东西

14:33.710 --> 14:34.710
叫skip

14:34.710 --> 14:36.710
就去掉前面n条数据

14:36.710 --> 14:38.710
比方说我们可以用这种方式

14:38.710 --> 14:40.210
dbu的是fan

14:40.210 --> 14:41.610
那么真的是不是拿到一个邮标

14:41.610 --> 14:42.810
那么邮标里边我们可以使用

14:42.810 --> 14:44.110
那个就是skip

14:44.110 --> 14:46.110
挑过前面几条记录

14:46.110 --> 14:47.310
大家有什么感觉

14:47.310 --> 14:48.310
是不是可以分页了

14:48.310 --> 14:48.510
对吧

14:48.510 --> 14:50.110
挑过15条记录

14:50.110 --> 14:50.610
那么前面

14:50.610 --> 14:52.410
当然你现在看不出来

14:52.410 --> 14:54.310
前面就是挑过了15条了

14:54.310 --> 14:56.210
不要那么挑过一条吧

14:56.210 --> 14:58.310
挑过一条可能看得

14:58.310 --> 14:59.710
稍微舒服一点

14:59.710 --> 15:00.310
挑过一条

15:00.310 --> 15:01.510
第一条是谁

15:01.610 --> 15:02.810
第一条是不是易修兰

15:02.810 --> 15:03.110
对吧

15:03.110 --> 15:04.410
然后我们看一下这边

15:04.410 --> 15:05.310
这边第一条是谁

15:05.310 --> 15:05.810
是不是耐劣

15:05.810 --> 15:07.010
第二条是易修兰

15:07.010 --> 15:08.310
是不是挑过了一条了

15:08.310 --> 15:08.710
对不对

15:08.710 --> 15:10.110
就这么简单

15:10.110 --> 15:11.310
这是个skip

15:11.310 --> 15:13.310
在邮标里边挑过

15:13.310 --> 15:15.310
然后我们看一下下面一个

15:15.310 --> 15:16.710
叫nemet

15:16.710 --> 15:18.410
nemet是10个

15:18.410 --> 15:19.910
比方说我们取10个

15:19.910 --> 15:21.010
或者是取5个

15:21.010 --> 15:22.610
或者是去取两个

15:22.610 --> 15:23.010
对吧

15:23.010 --> 15:25.010
那么就nemet表示取多少个

15:25.010 --> 15:26.810
就有点像mysc里面的nemet

15:26.810 --> 15:27.010
对吧

15:27.010 --> 15:28.410
就是一样的效果

15:28.410 --> 15:28.610
好

15:28.610 --> 15:30.210
咱们这个是不是通过skip

15:30.310 --> 15:31.910
和nemet可以完成分页

15:31.910 --> 15:32.510
对不对

15:32.510 --> 15:33.110
我们回车

15:33.110 --> 15:34.610
你看是不是只取出了两条

15:34.610 --> 15:35.810
一条数据

15:35.810 --> 15:37.110
两条数据

15:37.110 --> 15:37.910
没问题吧

15:37.910 --> 15:40.510
这是关于这个skip和nemet

15:40.510 --> 15:41.910
第三个是sort

15:41.910 --> 15:44.410
表示的是按条件排序

15:44.410 --> 15:45.810
咱们看一下这个东西

15:45.810 --> 15:49.010
usfand查询拿到一个邮标

15:49.010 --> 15:51.210
然后我们用sort排序

15:51.210 --> 15:51.710
排序的话

15:51.710 --> 15:53.010
我们标准用连细排序吧

15:53.010 --> 15:54.010
这里边传的是咋呢

15:54.010 --> 15:55.310
传的是一个对象

15:55.310 --> 15:56.210
我们在这边写吧

15:56.210 --> 15:58.910
这边也看得清楚一点

15:58.910 --> 16:00.010
这边fand

16:00.010 --> 16:01.510
fand我们这里放在里边

16:01.510 --> 16:02.810
不嫌不着急写参数

16:02.810 --> 16:05.310
然后我们调用sort排序

16:05.310 --> 16:07.610
排序里边能写个对象

16:07.610 --> 16:08.910
写个对象

16:08.910 --> 16:09.810
排序的时候

16:09.810 --> 16:12.510
他就问你按照什么来排序

16:12.510 --> 16:15.110
比方说我们要按照连细的排序

16:15.110 --> 16:16.310
连细怎么来排序呢

16:16.310 --> 16:18.310
连细用生序排序

16:18.310 --> 16:18.910
好

16:18.910 --> 16:19.310
运行

16:22.110 --> 16:22.810
这里说

16:23.810 --> 16:25.110
battle value

16:25.110 --> 16:25.310
1

16:26.510 --> 16:26.910
看一下

16:27.810 --> 16:29.810
这样子的连细就算了

16:29.810 --> 16:31.210
一是按照生序排序

16:31.210 --> 16:33.210
你看连细是不是11

16:33.210 --> 16:34.410
对不对

16:34.410 --> 16:35.610
然后12

16:35.610 --> 16:37.610
然后怎么来按照降序排序呢

16:37.610 --> 16:38.210
起个二

16:40.610 --> 16:41.210
完了

16:41.210 --> 16:42.810
我要查文档了

16:42.810 --> 16:44.110
这个地方我一点忘了

16:44.110 --> 16:45.110
mango db

16:45.110 --> 16:45.910
中文

16:47.410 --> 16:48.410
要查一下吧

16:48.410 --> 16:50.210
这些东西忘了很久了

16:50.210 --> 16:53.110
排序生序是这个样子的

16:53.110 --> 16:53.810
对的

16:53.810 --> 16:54.410
我想起来了

16:54.410 --> 16:55.810
我想起来了

16:55.910 --> 16:57.010
是负义

16:57.010 --> 16:57.910
降序是负义

16:59.110 --> 17:00.110
现在是按降序排序

17:00.110 --> 17:00.310
对吧

17:00.310 --> 17:01.710
从39往下排

17:01.710 --> 17:02.110
对对

17:02.110 --> 17:03.910
是按照连细来排序

17:03.910 --> 17:04.910
没问题吧

17:06.310 --> 17:08.310
那如果说连细一样的话

17:08.310 --> 17:09.110
我们按什么排序呢

17:09.110 --> 17:10.910
你是不是可以写第二个排序条件

17:10.910 --> 17:11.610
第二个排序条件呢

17:11.610 --> 17:13.110
比方说我们写的

17:13.110 --> 17:15.510
按照locking id

17:15.510 --> 17:17.110
这就没有什么别的排序了

17:17.110 --> 17:19.310
locking id 按照生序排序

17:19.310 --> 17:21.410
你看这个U字2过了是U字2

17:21.410 --> 17:22.910
你看都是39岁

17:22.910 --> 17:23.510
都是39岁

17:23.510 --> 17:25.710
然后这里U字2过了是U字49

17:25.910 --> 17:28.610
那么我们这里的按降序吧

17:28.610 --> 17:30.010
按降序排序

17:30.010 --> 17:30.610
好

17:30.610 --> 17:31.610
运行

17:31.610 --> 17:33.410
那么是不是都是39岁

17:33.410 --> 17:34.910
同位39岁里边

17:34.910 --> 17:36.710
是不是U字280

17:36.710 --> 17:38.210
然后是U字270

17:38.210 --> 17:38.510
对吧

17:38.510 --> 17:39.810
上到降序排序了

17:39.810 --> 17:40.810
就这么个意思

17:40.810 --> 17:42.510
这就是多个排序条件

17:42.510 --> 17:43.710
这就是排序的解放

17:43.710 --> 17:44.610
是不是很简单

17:44.610 --> 17:46.610
这些API都不要去背

17:46.610 --> 17:47.410
千万不要去背

17:47.410 --> 17:49.410
我从你们开始学程序

17:49.410 --> 17:50.410
开始到现在

17:50.410 --> 17:53.410
每一门课程我都反复的强调

17:53.410 --> 17:54.810
这API都不要去背

17:54.810 --> 17:55.810
你记不住的

17:55.810 --> 17:57.610
你就去理解它的含义就行了

17:57.610 --> 17:58.210
得到一个邮标

17:58.210 --> 18:00.310
邮标里边有一大堆方法可以操作

18:00.310 --> 18:02.110
你就可以大概知道这么一回事

18:02.110 --> 18:02.410
就行了

18:02.410 --> 18:03.110
然后去查文章

18:03.110 --> 18:06.110
你看这些文章都给你们写得很清楚了

18:06.110 --> 18:07.510
然后是COT

18:07.510 --> 18:11.110
表示得到的是结果的数量

18:11.110 --> 18:12.810
我们在这边来吧

18:12.810 --> 18:13.410
结果的数量

18:13.410 --> 18:14.710
那么我们来看一下吧

18:14.710 --> 18:15.710
我们拿到一个邮标

18:15.710 --> 18:16.610
拿到一个邮标过后

18:16.610 --> 18:18.310
我们使用COT

18:18.310 --> 18:20.310
再得到一个结果的数量

18:20.310 --> 18:21.210
运行

18:21.210 --> 18:23.110
是不是403条数据

18:23.110 --> 18:24.110
403条数据

18:24.110 --> 18:26.110
这就是COT这个函数

18:26.110 --> 18:27.910
然后我们再来

18:27.910 --> 18:31.110
下一个就是Size

18:31.110 --> 18:35.110
Size得到了是最终的结果数量

18:35.110 --> 18:37.110
这个东西跟COT有什么区别呢

18:37.110 --> 18:38.510
它有什么区别呢

18:38.510 --> 18:41.410
它就区别就在于主要是在于

18:41.410 --> 18:42.410
我们等一下说

18:42.410 --> 18:42.910
等一下说

18:42.910 --> 18:43.610
现在还说不了

18:43.610 --> 18:44.310
等一下说

18:44.310 --> 18:45.110
等几分钟

18:45.110 --> 18:45.910
咱们先看下面

18:45.910 --> 18:46.610
这个先略过

18:46.610 --> 18:48.310
我们先看下面

18:48.310 --> 18:49.610
前面几个函数里边

18:49.610 --> 18:50.610
你会看到有一些函数

18:50.610 --> 18:51.310
还比较特殊

18:51.310 --> 18:53.510
它会就是像这个skip函数

18:53.510 --> 18:55.210
limit函数和source函数

18:55.210 --> 18:57.510
它仍然会返回一个邮标

18:57.510 --> 18:58.910
它继续返回邮标

18:58.910 --> 19:00.910
而邮标里边是有这些成员

19:00.910 --> 19:03.310
所以说它就会形成链式编程

19:03.310 --> 19:04.010
啥意思呢

19:04.010 --> 19:04.810
你看着啊

19:04.810 --> 19:06.410
我们就可以这样子写

19:06.410 --> 19:08.110
比方说我们找到

19:08.110 --> 19:10.110
正式不得拿到个邮标对吧

19:10.110 --> 19:10.510
然后呢

19:10.510 --> 19:13.510
我们挑过前面两个

19:13.510 --> 19:15.610
在limit取三个

19:15.610 --> 19:17.210
然后再排序

19:17.210 --> 19:19.110
按照A级的生序排序

19:20.110 --> 19:21.610
是不是可以这样子写

19:21.610 --> 19:22.210
链式编程

19:22.210 --> 19:23.310
你看它返回个邮标

19:23.310 --> 19:24.610
邮标里边是不是有skip

19:24.610 --> 19:25.710
然后它又返回个邮标

19:25.710 --> 19:27.810
它又把邮标进一步操作过后

19:27.810 --> 19:28.810
就继续返回

19:28.810 --> 19:29.910
然后又返回个它

19:29.910 --> 19:30.610
又返回个它

19:30.610 --> 19:30.810
对吧

19:30.810 --> 19:33.010
是不是可以进行链式操作

19:33.010 --> 19:33.810
对不对

19:33.810 --> 19:35.010
链式操作

19:35.010 --> 19:35.410
好

19:35.410 --> 19:37.210
但是在这些链式操作里边

19:37.210 --> 19:39.210
大家有一个地方要注意

19:39.210 --> 19:41.610
就是调用顺序是没有关系的

19:41.610 --> 19:42.910
无论他们的调用顺序

19:42.910 --> 19:45.110
如何始终按照真正执行的时候

19:45.110 --> 19:46.710
始终按照下面的顺序执行

19:46.710 --> 19:48.510
sort,skip,limit

19:48.510 --> 19:50.010
就它先运行排序

19:50.010 --> 19:51.510
再运行skip

19:51.510 --> 19:52.810
再运行limit

19:52.810 --> 19:54.610
它始终是按照这样的顺序来执行的

19:54.610 --> 19:56.010
你看我们说说是要最后的

19:56.010 --> 19:56.510
对不对

19:56.510 --> 19:58.010
它实际上是先执行的

19:58.010 --> 19:59.910
它先把整个排序过后

19:59.910 --> 20:01.610
再排序完了过后的基础上

20:01.610 --> 20:02.910
再来去掉多少条

20:02.910 --> 20:05.110
再来去去多少条

20:05.110 --> 20:05.910
你不管你怎么写

20:05.910 --> 20:06.710
标语里说实

20:06.710 --> 20:08.510
你写前面

20:08.510 --> 20:13.500
要么你写这

20:13.500 --> 20:15.600
写这我们再运行

20:15.600 --> 20:16.600
你看是不是一样的效果

20:16.600 --> 20:16.700
对吧

20:16.700 --> 20:17.500
没有什么区别

20:17.500 --> 20:22.110
比方说你skip再往后边写

20:22.110 --> 20:23.210
就一样的效果

20:23.210 --> 20:24.210
它执行顺序

20:24.210 --> 20:26.310
不会因为你写的顺序变化而变化

20:26.310 --> 20:27.210
那是怎么回事呢

20:27.210 --> 20:29.410
实际上你调这些函数的时候

20:29.410 --> 20:31.110
它并没有真正的去执行

20:31.110 --> 20:32.010
它只是在记录

20:32.010 --> 20:33.410
记录你要干嘛

20:33.410 --> 20:34.410
你要按照这个排序

20:34.410 --> 20:34.610
OK

20:34.610 --> 20:35.310
我记录了

20:35.310 --> 20:36.010
然后limit

20:36.010 --> 20:36.510
你要干嘛

20:36.510 --> 20:37.610
我知道了

20:37.610 --> 20:40.410
你要取三条

20:40.410 --> 20:41.010
skip干嘛

20:41.010 --> 20:41.710
你要取两

20:41.710 --> 20:42.510
你要挑过两条

20:42.510 --> 20:42.710
对吧

20:42.710 --> 20:43.810
它只是做记录

20:43.810 --> 20:45.110
等到拿到邮标过后

20:45.110 --> 20:47.110
真正的来移动这个邮标的时候

20:47.110 --> 20:49.510
它才会真正的去执行这些东西

20:49.510 --> 20:50.310
明白了意思吧

20:50.310 --> 20:52.410
所以说你写的顺序无所谓的

20:52.410 --> 20:54.210
你可以随便写这个顺序

20:54.210 --> 20:55.710
这个地方给他说一下

20:55.710 --> 20:57.510
然后这里面就设计到一个现象

20:57.510 --> 20:59.510
就是我们的size和cord

20:59.510 --> 21:01.310
size它得到的是什么呢

21:01.310 --> 21:03.610
得到的是符合filter

21:03.610 --> 21:05.010
就是我们前面不是有条件吧

21:05.010 --> 21:06.510
我们现在还没有讲条件

21:06.510 --> 21:08.710
那么符合条件的查询结果

21:08.710 --> 21:10.310
它跟这些东西就没有什么关系了

21:10.310 --> 21:12.710
比方说我们在这里调了cord

21:12.710 --> 21:13.810
查询得到的结果

21:13.810 --> 21:15.910
你认为说多少条数据

21:15.910 --> 21:17.410
按理说应该是三条对吧

21:17.410 --> 21:18.010
不是的

21:20.310 --> 21:22.110
我们把他框选了

21:22.110 --> 21:22.710
403

21:22.710 --> 21:23.710
是不是还是整个数据

21:23.710 --> 21:24.010
对吧

21:24.010 --> 21:25.710
因为我们没有写查询条件

21:25.710 --> 21:26.810
没有查询条件就是所有

21:26.810 --> 21:28.410
所有的数据就是403条

21:28.410 --> 21:29.910
它始终得到的是

21:29.910 --> 21:31.510
按照查询条件的数据

21:31.510 --> 21:33.510
这对分页来说非常有用

21:33.510 --> 21:34.310
如果说分页来说

21:34.310 --> 21:36.310
如果说cord得到的是

21:36.310 --> 21:37.310
这些玩意的数据的话

21:37.310 --> 21:38.710
那我们分页肯定不对

21:38.710 --> 21:39.110
对吧

21:39.110 --> 21:40.110
我们分页的时候要得到的是

21:40.110 --> 21:41.110
从数据量

21:41.110 --> 21:43.110
就是按照我们这个查询条件下面

21:43.110 --> 21:44.610
能够得到多少条数据

21:44.610 --> 21:45.110
对吧

21:45.110 --> 21:45.810
应该是这样子

21:45.810 --> 21:47.310
比方性张的有多少同学

21:47.310 --> 21:47.610
对吧

21:47.610 --> 21:48.510
一共有多少同学

21:48.510 --> 21:50.510
然后我再分不同的业界

21:50.510 --> 21:53.510
这是查询满足条件的所有数据

21:53.510 --> 21:54.510
那么这个size

21:54.510 --> 21:58.510
就是按照前面乱七八糟的一大堆结果

21:58.510 --> 21:59.510
之后

21:59.510 --> 22:01.510
然后得到了数据

22:01.510 --> 22:02.510
是不是就只有3条

22:02.510 --> 22:02.710
对吧

22:02.710 --> 22:04.010
就是上面的区别

22:04.010 --> 22:04.910
那么这个size

22:04.910 --> 22:06.310
cord能不能换顺序写

22:06.310 --> 22:07.010
就不能了

22:07.010 --> 22:08.010
为什么

22:08.010 --> 22:09.010
因为size

22:09.010 --> 22:10.710
cord返回来根本就不是有标

22:10.710 --> 22:12.010
那么返回来不是有标

22:12.010 --> 22:13.510
你能提前写吗

22:13.510 --> 22:14.610
你肯定不能提前写

22:14.610 --> 22:16.210
比方说你这里能这样子写吗

22:16.210 --> 22:17.210
肯定是不行

22:17.210 --> 22:17.610
为什么呢

22:17.610 --> 22:18.610
因为这个地方的是不是

22:18.610 --> 22:20.110
已经拿到结果了

22:20.110 --> 22:21.110
是不是已经拿到结果了

22:21.110 --> 22:22.110
这拿到结果是啥

22:22.110 --> 22:23.110
是不是一个number

22:23.110 --> 22:23.310
对吧

22:23.310 --> 22:24.110
所以说把这些返回来

22:24.110 --> 22:25.110
已经没写到这

22:25.110 --> 22:26.110
所以发生了一个number

22:26.110 --> 22:27.610
number里面有skip这个函数吗

22:27.610 --> 22:28.110
肯定没有

22:28.110 --> 22:28.610
对吧

22:28.610 --> 22:30.110
肯定是要报错了

22:30.110 --> 22:31.110
是不是直接报错了

22:31.110 --> 22:32.610
他说 is not a function

22:32.610 --> 22:34.110
怎么怎么不是方式呢

22:34.110 --> 22:35.610
skip不是一个方式

22:35.610 --> 22:37.110
对不对

22:37.110 --> 22:38.610
因为前面是个number的一些

22:38.610 --> 22:39.110
好

22:39.110 --> 22:42.110
这个地方大家注意一下

22:42.110 --> 22:44.110
那么这里就是那个

22:44.110 --> 22:45.610
关于在mongerDB里面

22:45.610 --> 22:46.610
拿到这个有标过后

22:46.610 --> 22:47.610
可以做什么样的操作

22:47.610 --> 22:48.610
明白了吧

22:48.610 --> 22:49.610
没问题吧

22:49.610 --> 22:50.110
好

22:50.110 --> 22:51.110
咱们再继续

22:51.110 --> 22:52.110
接下来我们来看

22:52.110 --> 22:54.110
它里面的条件

22:54.110 --> 22:55.610
一个band里面

22:55.610 --> 22:56.610
不第一个参数是

22:56.610 --> 22:57.610
查询条件

22:57.610 --> 22:59.110
我们看一下条件怎么写

22:59.110 --> 23:00.610
因为在mongerDB里面

23:00.610 --> 23:01.610
它本身就不存在

23:01.610 --> 23:02.610
什么搜口语句

23:02.610 --> 23:03.610
没有什么搜口语句

23:03.610 --> 23:04.610
所以说它全都是

23:04.610 --> 23:06.110
用API的形式来写

23:06.110 --> 23:08.110
也就是届源式API的形式来写

23:08.110 --> 23:09.610
那么条件的写法

23:09.610 --> 23:11.610
它写法其实极其丰富的

23:11.610 --> 23:13.110
咱们下面练取了

23:13.110 --> 23:14.110
它一部分的写法

23:14.110 --> 23:15.110
这些写法

23:15.110 --> 23:15.910
已经能够帮我们

23:15.910 --> 23:17.410
解决99%的问题了

23:17.410 --> 23:19.410
如果说99%解决不了的话

23:19.410 --> 23:21.910
大家就去查它的API文档了

23:21.910 --> 23:23.910
就是它mongerDB的API文档

23:23.910 --> 23:25.410
我这里说一下

23:25.410 --> 23:27.410
就是这里不可能讲完的

23:27.410 --> 23:29.410
它的API实在是太多了

23:29.410 --> 23:30.910
你看一下文档的量

23:30.910 --> 23:31.910
有多少就知道了

23:31.910 --> 23:34.410
我们讲的都是你们今后来

23:34.410 --> 23:36.410
大部分如果说用mongerDB的话

23:36.410 --> 23:37.410
如果说用它的话

23:37.410 --> 23:38.410
大部分要使用的

23:38.410 --> 23:39.910
基本上跟大家讲清楚

23:39.910 --> 23:41.910
第一个是非常简单的

23:41.910 --> 23:42.910
查询那个field

23:42.910 --> 23:45.410
其实就是一个对象

23:45.910 --> 23:47.410
它里面就写条件

23:47.410 --> 23:48.910
最简单的就是一个界

23:48.910 --> 23:50.910
属性名等于什么值

23:50.910 --> 23:52.410
这就是个最简单的条件

23:52.410 --> 23:53.910
比方说咱们来看一下吧

23:53.910 --> 23:55.410
我们把这个复制一下吧

23:55.410 --> 23:57.410
这个玩意复制一下

23:57.410 --> 23:58.910
然后到这边来

23:58.910 --> 23:59.410
我们现在呢

23:59.410 --> 24:01.410
fender里面我们写条件

24:01.410 --> 24:02.410
第一个参数条件

24:02.410 --> 24:04.410
条件如果说你是个空对象的话

24:04.410 --> 24:05.410
它默认之前这里写的

24:05.410 --> 24:06.410
不就是个空对象吗

24:06.410 --> 24:07.410
它如果说是个空对象的话

24:07.410 --> 24:08.410
就表示没有条件

24:08.410 --> 24:09.910
跟查区所有是一样的

24:09.910 --> 24:10.910
跟第一个参数不传

24:10.910 --> 24:11.910
或者是传一个LOW

24:11.910 --> 24:13.910
或者传一个OND犯都是一样的

24:13.910 --> 24:14.910
写空对象

24:15.410 --> 24:16.410
现在不是空对象了

24:17.410 --> 24:19.410
我们这里来写上查询条件

24:19.410 --> 24:20.410
查询要是什么呢

24:20.410 --> 24:21.910
查询要是NAME等于潮名的

24:21.910 --> 24:23.410
就是纯粹是相等的查询

24:23.410 --> 24:24.410
那么查出来的时候

24:24.410 --> 24:25.910
你看NAME等于潮名

24:25.910 --> 24:27.410
NAME等于潮名

24:27.410 --> 24:28.410
就是查出来了

24:28.410 --> 24:30.410
非常非常简单

24:30.410 --> 24:33.410
这是关于这个查询条件

24:33.410 --> 24:35.410
相等的查询

24:35.410 --> 24:36.910
另外一个就是

24:36.910 --> 24:38.910
可以这里来说像两个现象

24:38.910 --> 24:41.410
一个是如果说多条件的话

24:41.410 --> 24:42.410
它们之间是并且关系

24:42.410 --> 24:43.410
你看第一个条件

24:43.410 --> 24:45.410
是并且关系都要满足

24:45.410 --> 24:46.410
而且还说明另一种情况

24:46.410 --> 24:47.410
就是模糊查询

24:47.410 --> 24:49.410
就是可以使用政策表达

24:49.410 --> 24:50.410
进行模糊查询

24:50.410 --> 24:51.410
你看这里我怎么查的

24:51.410 --> 24:53.410
LOCKING ID满足这个政策表达

24:53.410 --> 24:54.410
啥意思

24:54.410 --> 24:57.410
就是登录账号以7结尾

24:57.410 --> 24:59.410
NAME的满足这个政策表达

24:59.410 --> 25:01.410
是表示的是

25:01.410 --> 25:04.410
只要你包含名字就可以

25:04.410 --> 25:05.410
那么它整个查询条件

25:05.410 --> 25:06.410
是什么意思

25:06.410 --> 25:07.410
LOCKING ID以7结尾

25:07.410 --> 25:09.410
并且NAME包含名字

25:09.410 --> 25:10.410
比方说

25:11.410 --> 25:15.640
到这边

25:17.640 --> 25:18.640
我咱们来看一下

25:18.640 --> 25:19.640
这个查询

25:21.640 --> 25:22.640
运行

25:22.640 --> 25:23.640
你看

25:23.640 --> 25:25.640
现在我们包含名字

25:25.640 --> 25:26.640
包含名字

25:26.640 --> 25:28.640
然后以7结尾没问题

25:28.640 --> 25:30.640
以7结尾包含名字都没问题

25:30.640 --> 25:31.640
对吧

25:31.640 --> 25:32.640
查询出来了两个

25:33.640 --> 25:35.640
如果说我要查询所有信章的

25:37.640 --> 25:38.640
我要查询所有信章的

25:38.640 --> 25:39.640
那怎么查呢

25:39.640 --> 25:40.640
我们这样子查

25:40.640 --> 25:42.640
我们这里可以用

25:42.640 --> 25:44.640
一个开使符

25:44.640 --> 25:45.640
政策表达是不是要比

25:45.640 --> 25:46.640
Busker里面那个

25:46.640 --> 25:48.640
Nike要灵活太多太多了

25:48.640 --> 25:49.640
那么我们这里

25:49.640 --> 25:51.640
使用信章

25:52.640 --> 25:53.640
运行

25:53.640 --> 25:54.640
你看是不是都是

25:54.640 --> 25:55.640
一张开头的

25:55.640 --> 25:56.640
对不对

25:56.640 --> 25:58.640
这就是

25:58.640 --> 26:00.640
模糊查询已经多条件

26:00.640 --> 26:02.640
之间是并且关系

26:02.640 --> 26:03.640
好

26:03.640 --> 26:04.640
如果说你要用或者关系怎么办

26:04.640 --> 26:05.640
或者关系

26:05.640 --> 26:06.640
你要用一个特殊的

26:06.640 --> 26:07.640
这个东西

26:07.640 --> 26:08.640
这个东西

26:08.640 --> 26:09.640
我们下面看一下

26:09.640 --> 26:10.640
如果说查询里面

26:10.640 --> 26:11.640
出现了一些特殊的场景的话

26:11.640 --> 26:13.640
那么要用一些特殊的属性

26:13.640 --> 26:14.640
这些属性呢

26:14.640 --> 26:15.640
以多的开头

26:15.640 --> 26:16.640
它表达了特殊的含义

26:16.640 --> 26:17.640
我们把这些属性

26:17.640 --> 26:19.640
称之为操作符

26:19.640 --> 26:20.640
操作符在不同的场景里面

26:20.640 --> 26:21.640
不同的用途

26:21.640 --> 26:22.640
比方在查询里面

26:22.640 --> 26:24.640
有操作符就叫做查询操作符

26:24.640 --> 26:25.640
之后呢

26:25.640 --> 26:26.640
我们还会学习修改

26:26.640 --> 26:27.640
修改的时候呢

26:27.640 --> 26:28.640
还有修改操作符

26:28.640 --> 26:29.640
我们这里看一下

26:29.640 --> 26:31.640
有没有一些常用的操作符

26:31.640 --> 26:32.640
我们就表示

26:32.640 --> 26:33.640
我们默认条件是并且

26:33.640 --> 26:34.640
那如果说

26:34.640 --> 26:35.640
我要用或者的话

26:35.640 --> 26:36.640
就用哦

26:36.640 --> 26:37.640
后面跟一个数组

26:37.640 --> 26:38.640
数组里面每一个对象

26:38.640 --> 26:39.640
就是一个条件

26:39.640 --> 26:40.640
对象与对象之间

26:40.640 --> 26:41.640
就是或者

26:41.640 --> 26:42.640
你看这个

26:42.640 --> 26:43.640
或者就是我们的

26:43.640 --> 26:44.640
后面的条件

26:44.640 --> 26:45.640
全是或者的关系

26:45.640 --> 26:46.640
第一个条件

26:46.640 --> 26:48.640
登陆ID是这个

26:48.640 --> 26:50.640
第二个条件

26:50.640 --> 26:51.640
内容呢

26:51.640 --> 26:52.640
是这个

26:52.640 --> 26:53.640
那么就是

26:53.640 --> 26:54.640
这两个条件

26:54.640 --> 26:55.640
满足任何一个都可以

26:55.640 --> 26:56.640
那么如果说得要多

26:56.640 --> 26:57.640
三个 四个

26:57.640 --> 26:58.640
是不是接着写就完事

26:58.640 --> 26:59.640
对吧 我们把这个

26:59.640 --> 27:01.960
弄过去

27:01.960 --> 27:02.960
让我们看

27:02.960 --> 27:05.840
让你过来

27:05.840 --> 27:07.840
好 运行

27:07.840 --> 27:08.840
你看现在呢

27:08.840 --> 27:10.840
只要登陆ID以期结尾

27:10.840 --> 27:11.840
包含敏都没问题

27:11.840 --> 27:12.840
对吧

27:12.840 --> 27:13.840
然后登陆ID

27:13.840 --> 27:14.840
不是期结尾

27:14.840 --> 27:15.840
那你就必须要包含敏

27:15.840 --> 27:16.840
没问题吧

27:16.840 --> 27:17.840
没有包含敏

27:17.840 --> 27:18.840
就必须要以期结尾

27:18.840 --> 27:19.840
对吧 这是货责关系

27:21.840 --> 27:23.840
好 再来啊

27:23.840 --> 27:28.240
下一个

27:28.240 --> 27:30.240
我怎么写了两个呢

27:30.240 --> 27:32.620
好 下一个

27:32.620 --> 27:33.620
下一个呢

27:33.620 --> 27:34.620
是印这个

27:34.620 --> 27:35.620
印这个操作符

27:35.620 --> 27:36.620
这个操作符

27:36.620 --> 27:37.620
什么意思呢

27:37.620 --> 27:38.620
就表示的是在什么

27:38.620 --> 27:39.620
什么之中

27:39.620 --> 27:40.620
你的年龄呢

27:40.620 --> 27:41.620
必须要在什么

27:41.620 --> 27:42.620
什么之中

27:42.620 --> 27:43.620
你可以是18

27:43.620 --> 27:44.620
可以是20

27:44.620 --> 27:45.620
可以是25

27:45.620 --> 27:46.620
必须要在什么之中

27:46.620 --> 27:49.620
好 咱们把这个条件扶植一下

27:49.620 --> 27:54.280
咱们到这边来

27:54.280 --> 27:56.280
看一下吧

27:56.280 --> 27:59.280
你看 现在查出来的结果是什么呢

27:59.280 --> 28:02.280
条件是那个

28:02.280 --> 28:05.280
A级25可以

28:05.280 --> 28:06.280
对吧

28:06.280 --> 28:07.280
25可以

28:07.280 --> 28:08.280
然后呢

28:08.280 --> 28:09.280
20也可以

28:09.280 --> 28:11.280
还有18也可以

28:11.280 --> 28:14.280
下面应该有18

28:14.280 --> 28:15.280
18是不是也可以

28:15.280 --> 28:16.280
对吧

28:16.280 --> 28:17.280
蠻热热的小点都可以

28:17.280 --> 28:18.280
对不对

28:18.280 --> 28:19.280
那么这个印操作符

28:19.280 --> 28:20.280
还有一些别的用处

28:20.280 --> 28:23.280
比方说

28:23.280 --> 28:24.280
我们在这里

28:24.280 --> 28:25.280
看一下数组的查询

28:25.280 --> 28:27.280
比方说我们这里呢

28:27.280 --> 28:28.280
有个love

28:28.280 --> 28:29.280
我们的爱号

28:29.280 --> 28:30.280
爱号里边呢

28:30.280 --> 28:31.280
我希望呢

28:31.280 --> 28:33.280
如果说你直接写个数组的话

28:33.280 --> 28:34.280
那么就是要精确匹配了

28:34.280 --> 28:35.280
精确匹配这个数组了

28:35.280 --> 28:39.280
比方说我要匹配音乐

28:39.280 --> 28:41.280
音乐

28:41.280 --> 28:42.280
然后呢

28:42.280 --> 28:44.590
匪画

28:44.590 --> 28:45.590
匪画

28:45.590 --> 28:49.160
编程

28:49.160 --> 28:52.160
要精确匹配

28:52.160 --> 28:53.160
运行

28:53.160 --> 28:57.880
我这里少写个大包

28:57.880 --> 28:58.880
运行

28:58.880 --> 29:00.880
那么现在是不是只能匹配了

29:00.880 --> 29:04.880
爱号刚刚好是音乐匪画编程

29:04.880 --> 29:05.880
对不对

29:05.880 --> 29:06.880
好 那么

29:06.880 --> 29:08.880
如果说我要匹配的是

29:08.880 --> 29:10.880
只要包含音乐就行

29:10.880 --> 29:11.880
那么怎么写的

29:11.880 --> 29:12.880
最简单的写吧

29:12.880 --> 29:13.880
就这样写

29:13.880 --> 29:14.880
音乐

29:14.880 --> 29:15.880
只要你包含音乐就行

29:15.880 --> 29:16.880
有些人说不对啊

29:16.880 --> 29:18.880
你这个东西不是相等吗

29:18.880 --> 29:19.880
但是如果他会

29:19.880 --> 29:20.880
他会他非常智能的

29:20.880 --> 29:21.880
他发现他是数组的话

29:21.880 --> 29:23.880
他就不是用相等比较了

29:23.880 --> 29:24.880
他发现他是数组的话

29:24.880 --> 29:27.880
那么只要你包含这个就行

29:27.880 --> 29:28.880
包含

29:28.880 --> 29:29.880
只要你包含这个就行

29:29.880 --> 29:30.880
明白的意思吧

29:30.880 --> 29:32.880
那如果说我要写两个呢

29:32.880 --> 29:33.880
就是你包含

29:33.880 --> 29:35.880
我要包含音乐

29:35.880 --> 29:37.880
或者是

29:37.880 --> 29:40.880
或者是我要包含体育

29:40.880 --> 29:42.880
那么怎么办呢

29:42.880 --> 29:43.880
音乐体育中

29:43.880 --> 29:44.880
我包含任何一个都可以

29:44.880 --> 29:48.880
那么我们就可以用这种方式

29:48.880 --> 29:51.880
这些细节很微妙的

29:51.880 --> 29:53.880
音

29:53.880 --> 29:59.880
就是音乐体育

29:59.880 --> 30:01.880
运行

30:01.880 --> 30:02.880
他包含音乐可以

30:02.880 --> 30:06.880
一看音乐体育

30:06.880 --> 30:07.880
音乐

30:07.880 --> 30:08.880
你看这个时候包含的音乐

30:08.880 --> 30:09.880
还没有包含体育

30:09.880 --> 30:10.880
对吧

30:10.880 --> 30:11.880
也可以查出来

30:11.880 --> 30:12.880
包含音乐和体育

30:12.880 --> 30:14.880
但是在这个之中都可以

30:14.880 --> 30:16.880
然后呢体育

30:16.880 --> 30:18.880
然后呢音乐

30:18.880 --> 30:20.880
他要既要包含音乐

30:20.880 --> 30:21.880
又要包含体育

30:21.880 --> 30:23.880
怎么办呢

30:23.880 --> 30:24.880
这个是或者关系对吧

30:24.880 --> 30:25.880
那么既要包含音乐

30:25.880 --> 30:26.880
又要包含体育

30:26.880 --> 30:27.880
这样子写行不行

30:27.880 --> 30:29.880
这样子包含就写不行了

30:29.880 --> 30:30.880
这样子写的话就是

30:30.880 --> 30:31.880
只能包含音乐

30:31.880 --> 30:32.880
只能包含体育

30:32.880 --> 30:33.880
明白的意思吧

30:33.880 --> 30:34.880
如果说你要既要包含音乐

30:34.880 --> 30:36.880
只要能够包含音乐

30:36.880 --> 30:37.880
同时包含体育就可以了

30:37.880 --> 30:38.880
就OK了

30:38.880 --> 30:40.880
那怎么写呢

30:41.880 --> 30:43.880
这样子写

30:45.880 --> 30:46.880
看一下啊

30:46.880 --> 30:47.880
我们这里怎么写

30:47.880 --> 30:48.880
既要包含音乐

30:48.880 --> 30:50.880
又要包含体育

30:50.880 --> 30:51.880
其实很简单

30:51.880 --> 30:53.880
你把这句话翻译一下

30:53.880 --> 30:55.880
就是我这个爱好里边

30:55.880 --> 30:58.880
包含音乐并且

30:58.880 --> 30:59.880
我这个爱好里边

30:59.880 --> 31:00.880
包含体育

31:00.880 --> 31:01.880
是不是这么一个逻辑

31:01.880 --> 31:02.880
因此呢你该怎么写

31:02.880 --> 31:03.880
包含音乐

31:03.880 --> 31:04.880
然后呢

31:04.880 --> 31:05.880
再来一个条件

31:05.880 --> 31:07.880
那不是包含体育

31:07.880 --> 31:08.880
就应该这样子写

31:08.880 --> 31:09.880
但是这样子写能行吗

31:10.880 --> 31:11.880
能行吗

31:11.880 --> 31:12.880
肯定是不行的

31:12.880 --> 31:13.880
为什么呢

31:13.880 --> 31:14.880
因为这是一个对象

31:14.880 --> 31:15.880
这个对象里边

31:15.880 --> 31:17.880
出现了相同的属性名字

31:17.880 --> 31:18.880
后边的覆盖前面的了

31:18.880 --> 31:19.880
相当于是前面的

31:19.880 --> 31:20.880
跟写的更没写是一样的

31:20.880 --> 31:22.880
那么他只会

31:22.880 --> 31:24.880
只会看体育这一项

31:24.880 --> 31:25.880
体育

31:25.880 --> 31:26.880
你看

31:26.880 --> 31:27.880
下面体育

31:27.880 --> 31:28.880
只看体育这一项

31:28.880 --> 31:31.880
这不满足我们的要求

31:31.880 --> 31:32.880
那么我们要

31:32.880 --> 31:33.880
这里要怎么写的

31:33.880 --> 31:34.880
这里还可以提供了

31:34.880 --> 31:35.880
另外一个操作符

31:35.880 --> 31:36.880
叫做end

31:36.880 --> 31:38.880
end操作符

31:38.880 --> 31:40.880
我们这里记一笔

31:40.880 --> 31:42.880
下面写漏了

31:44.880 --> 31:45.880
下面还有一个end

31:46.880 --> 31:47.880
那么end操作符

31:47.880 --> 31:48.880
跟o操作符的用法

31:48.880 --> 31:49.880
是一样的

31:49.880 --> 31:50.880
表示并且

31:50.880 --> 31:51.880
他默认是并且

31:51.880 --> 31:52.880
但是有的时候

31:52.880 --> 31:53.880
你光用那个默认

31:53.880 --> 31:55.880
会造成属性名重复

31:55.880 --> 31:56.880
你就用end

31:56.880 --> 31:57.880
后边跟一个什么

31:57.880 --> 31:58.880
跟一个输主

31:58.880 --> 31:59.880
输主里面多个条件

31:59.880 --> 32:00.880
多个条件之间

32:00.880 --> 32:01.880
那就是并且关系

32:01.880 --> 32:02.880
第一个条件

32:02.880 --> 32:03.880
nubs

32:03.880 --> 32:04.880
是什么呢

32:04.880 --> 32:05.880
音乐

32:05.880 --> 32:06.880
要包含音乐

32:06.880 --> 32:07.880
第二个条件

32:07.880 --> 32:08.880
nubs

32:08.880 --> 32:12.320
要包含体育

32:12.320 --> 32:13.320
那么现在就不会

32:13.320 --> 32:14.320
造成属性名的重复了

32:14.320 --> 32:15.320
运行

32:15.320 --> 32:16.320
你看现在肯定是

32:16.320 --> 32:17.320
既要包含体育

32:17.320 --> 32:18.320
又要包含音乐

32:18.320 --> 32:19.320
音乐

32:19.320 --> 32:20.320
体育

32:20.320 --> 32:21.320
音乐

32:21.320 --> 32:22.320
体育

32:22.320 --> 32:23.320
再来一个编程

32:24.320 --> 32:25.320
nubs

32:25.320 --> 32:27.320
编程

32:27.320 --> 32:29.320
这样子结果少一点

32:29.320 --> 32:30.320
你看

32:30.320 --> 32:31.320
现在就是

32:31.320 --> 32:33.320
体育音乐编程

32:33.320 --> 32:34.320
他们都是并且关系

32:34.320 --> 32:36.320
体育音乐编程

32:36.320 --> 32:37.320
你自己去看

32:37.320 --> 32:38.320
肯定都是

32:38.320 --> 32:39.320
体育音乐编程

32:39.320 --> 32:40.320
好

32:40.320 --> 32:41.320
这就是

32:41.320 --> 32:42.320
nubs

32:42.320 --> 32:43.320
是用显示的

32:43.320 --> 32:44.320
nubs出现

32:44.320 --> 32:46.320
这是关于这个条件

32:46.320 --> 32:47.320
咱们继续看

32:48.320 --> 32:49.320
讲了什么呢

32:49.320 --> 32:50.320
讲了音乐

32:50.320 --> 32:51.320
还有一个就是nubs

32:51.320 --> 32:52.320
这个东西不用说了吧

32:52.320 --> 32:53.320
就是

32:53.320 --> 32:54.320
不在这里边

32:54.320 --> 32:56.320
连绵不在这里边

32:56.320 --> 32:57.320
那么就可以了

32:57.320 --> 32:58.320
说完了

32:58.320 --> 32:59.320
对不对

32:59.320 --> 33:00.320
好

33:00.320 --> 33:01.320
那么下面还有一个就是

33:01.320 --> 33:02.320
连绵在20到30之间

33:02.320 --> 33:03.320
那又怎么写呢

33:03.320 --> 33:04.320
我们把这个复制一下吧

33:04.320 --> 33:06.820
到这个

33:06.820 --> 33:07.820
到这边来

33:08.820 --> 33:10.820
连绵在20到30之间

33:10.820 --> 33:11.820
就连绵

33:11.820 --> 33:12.820
它一个条件

33:12.820 --> 33:13.820
条件是什么呢

33:13.820 --> 33:14.820
GT

33:14.820 --> 33:15.820
是不是特殊的操作服务

33:15.820 --> 33:16.820
GT greater than

33:16.820 --> 33:17.820
greater than

33:17.820 --> 33:18.820
20

33:18.820 --> 33:19.820
比20要大

33:19.820 --> 33:20.820
就大于20

33:20.820 --> 33:21.820
LT less than

33:21.820 --> 33:22.820
对吧

33:22.820 --> 33:23.820
小于30

33:23.820 --> 33:24.820
你看

33:24.820 --> 33:26.820
说的20到30之间

33:26.820 --> 33:27.820
20

33:27.820 --> 33:28.820
对不对

33:28.820 --> 33:30.820
当然你还可以排个序

33:30.820 --> 33:31.820
排个序

33:31.820 --> 33:32.820
按照什么排序呢

33:32.820 --> 33:34.820
按照A级的声序排序

33:35.820 --> 33:36.820
好

33:36.820 --> 33:37.820
你看

33:37.820 --> 33:38.820
是不是21开始

33:38.820 --> 33:39.820
21开始

33:39.820 --> 33:40.820
因为它大于20

33:40.820 --> 33:41.820
还不能去到20

33:41.820 --> 33:42.820
到25

33:42.820 --> 33:43.820
还没完

33:43.820 --> 33:44.820
还有下一页

33:44.820 --> 33:45.820
下一页

33:45.820 --> 33:46.820
后面没了

33:46.820 --> 33:47.820
就是下一页

33:47.820 --> 33:48.820
再往下看

33:48.820 --> 33:49.820
最高的就是29

33:49.820 --> 33:50.820
对吧

33:50.820 --> 33:51.820
好

33:51.820 --> 33:53.820
那么这些就是一些特殊的操作服务

33:53.820 --> 33:54.820
然后呢

33:54.820 --> 33:55.820
我们在这里来看一下

33:55.820 --> 33:56.820
有哪些操作服务

33:56.820 --> 33:57.820
或者 and

33:57.820 --> 33:58.820
并且 in

33:58.820 --> 33:59.820
在什么之中

33:59.820 --> 34:00.820
not in

34:00.820 --> 34:01.820
不在什么什么之中

34:01.820 --> 34:02.820
GT greater than

34:02.820 --> 34:03.820
or equal

34:03.820 --> 34:04.820
great than

34:04.820 --> 34:05.820
or equal

34:05.820 --> 34:06.820
equal

34:06.820 --> 34:07.820
就是等于

34:07.820 --> 34:08.820
大于等于

34:08.820 --> 34:09.820
LT小于

34:09.820 --> 34:10.820
less than equal

34:10.820 --> 34:11.820
小于等于

34:11.820 --> 34:12.820
not equal

34:12.820 --> 34:13.820
不等于

34:13.820 --> 34:15.820
就这么一些常见的操作服务

34:15.820 --> 34:16.820
好

34:16.820 --> 34:18.820
那么我们来做一个例子吧

34:18.820 --> 34:20.820
比方说我们这里要查啥呢

34:21.820 --> 34:23.820
我们要查的是这个东西

34:23.820 --> 34:24.820
比方说

34:24.820 --> 34:26.820
这里写个例子

34:27.820 --> 34:28.820
查询

34:29.820 --> 34:31.820
所有账号

34:32.820 --> 34:33.820
以

34:36.820 --> 34:37.820
期结为

34:40.520 --> 34:41.520
所谓账号为

34:41.520 --> 34:42.520
所谓账号必须以期结为

34:42.520 --> 34:44.520
我们这里这样写吧

34:44.520 --> 34:48.520
所有账号必须以期结为

34:48.520 --> 34:50.520
然后呢

34:50.520 --> 34:51.520
新名

34:52.520 --> 34:53.520
可以

34:54.520 --> 34:56.520
就是新名包含

34:56.520 --> 34:58.520
就是新名可以是姓张

34:59.520 --> 35:02.980
或者

35:02.980 --> 35:03.980
新王

35:04.980 --> 35:06.980
两个姓都可以

35:06.980 --> 35:07.980
新张或姓王

35:07.980 --> 35:09.980
但是账号必须要以期结为

35:09.980 --> 35:10.980
还有什么呢

35:10.980 --> 35:11.980
就年龄

35:13.980 --> 35:15.980
在20-30之间

35:18.980 --> 35:19.980
还有什么呢

35:19.980 --> 35:23.980
爱好必须包含

35:24.980 --> 35:26.980
体育和音乐

35:27.980 --> 35:28.980
那么这四个条件是不是

35:28.980 --> 35:30.980
四个条件之间是并且关系

35:30.980 --> 35:31.980
一个来吧

35:31.980 --> 35:32.980
首先呢

35:32.980 --> 35:34.980
我们是账号必须以期结为

35:35.980 --> 35:36.980
账号必须以期结为

35:36.980 --> 35:37.980
那么就是

35:37.980 --> 35:38.980
logging

35:38.980 --> 35:39.980
id

35:39.980 --> 35:40.980
重点表达是

35:40.980 --> 35:41.980
以期包含结为

35:41.980 --> 35:42.980
所以这个

35:42.980 --> 35:43.980
这样子是不是把所有的

35:43.980 --> 35:44.980
期结为的账号

35:44.980 --> 35:45.980
全部查出来了

35:45.980 --> 35:46.980
期结为的账号

35:46.980 --> 35:47.980
然后呢

35:47.980 --> 35:49.980
新名可以是姓张

35:49.980 --> 35:50.980
或者是姓王

35:50.980 --> 35:51.980
那么我们来新名

35:51.980 --> 35:52.980
新名是不是有两个条件

35:52.980 --> 35:53.980
两个条件之间是

35:53.980 --> 35:54.980
货者关系

35:54.980 --> 35:55.980
姓张或者姓王

35:55.980 --> 35:56.980
是不是一个or

35:56.980 --> 35:57.980
对不对

35:57.980 --> 35:59.980
就这个条件和

35:59.980 --> 36:02.980
这个条件之间是并且关系

36:02.980 --> 36:03.980
这个条件内部

36:03.980 --> 36:04.980
是一个货者关系

36:04.980 --> 36:05.980
第一个条件

36:05.980 --> 36:06.980
第一个条件是什么呢

36:06.980 --> 36:08.980
姓张就是

36:10.980 --> 36:11.980
张开头

36:11.980 --> 36:14.740
姓张

36:14.740 --> 36:15.740
或者是

36:15.740 --> 36:16.740
第二条件

36:16.740 --> 36:18.740
两个条件之间是货者关系

36:20.740 --> 36:21.740
姓王

36:23.740 --> 36:24.740
咱们再运行

36:25.740 --> 36:26.740
少了一个大方号

36:27.740 --> 36:28.740
运行

36:29.740 --> 36:30.740
就找不到了

36:30.740 --> 36:31.740
就找不到了

36:32.740 --> 36:33.740
我看一下

36:34.740 --> 36:35.740
没有姓张姓王的吗

36:35.740 --> 36:36.740
一切久

36:37.740 --> 36:39.740
姓汤姓猪

36:40.740 --> 36:41.740
姓鱼

36:44.370 --> 36:45.370
姓叶姓汤

36:46.370 --> 36:48.370
那么换一个姓吧

36:48.370 --> 36:49.370
意思一样就行

36:50.370 --> 36:51.370
姓猪的

36:54.130 --> 36:55.130
姓

36:55.130 --> 36:56.130
汤的

36:56.130 --> 36:58.700
运行

37:01.700 --> 37:02.700
这个地方

37:02.700 --> 37:04.700
这个地方是那个账者

37:04.700 --> 37:05.700
我写成

37:05.700 --> 37:06.700
这不算了

37:09.270 --> 37:10.270
账者

37:11.270 --> 37:13.270
那么就张浩以七结尾

37:13.270 --> 37:14.270
但是同时

37:14.270 --> 37:16.270
要姓汤或者是姓猪

37:16.270 --> 37:18.270
我看一下姓张和王

37:19.270 --> 37:24.310
数据会不会多一点

37:24.310 --> 37:25.310
无所谓吧

37:25.310 --> 37:26.310
你们体会要意识用心

37:26.310 --> 37:28.310
数据量还是少

37:29.310 --> 37:31.310
接下来年龄在二十到三十之间

37:31.310 --> 37:32.310
然后我们数据下面

37:32.310 --> 37:34.310
又要写一个并且条件

37:34.310 --> 37:35.310
第一个条件

37:35.310 --> 37:36.310
第二条件

37:36.310 --> 37:37.310
第三个条件

37:37.310 --> 37:38.310
年龄就是A级

37:38.310 --> 37:39.310
条件是什么呢

37:40.310 --> 37:41.310
GT

37:41.310 --> 37:42.310
这个写上

37:42.310 --> 37:43.310
GT

37:43.310 --> 37:45.310
年龄到二十到三十之间

37:45.310 --> 37:46.310
那么我们就用GT一括

37:46.310 --> 37:48.310
大于等于二十

37:48.310 --> 37:50.310
然后小于等于

37:51.310 --> 37:52.310
三十

37:53.310 --> 37:54.310
运行

37:54.310 --> 37:55.310
没了是吧

37:57.310 --> 37:58.310
没了

37:58.310 --> 37:59.310
一个是三十五

37:59.310 --> 38:00.310
一个是十六

38:00.310 --> 38:01.310
那就没了

38:01.310 --> 38:02.310
我就写吧

38:02.310 --> 38:03.310
那就强心写吧

38:03.310 --> 38:04.310
没关系

38:04.310 --> 38:05.310
就强心写

38:05.310 --> 38:06.310
然后下一个是

38:06.310 --> 38:07.310
I好必须是体育和音乐

38:07.310 --> 38:08.310
就是I好

38:08.310 --> 38:09.310
I好里面是不是

38:09.310 --> 38:10.310
要包含体育

38:10.310 --> 38:11.310
要包含音乐

38:11.310 --> 38:12.310
那么我们这里是不是

38:12.310 --> 38:13.310
可以用AND

38:15.310 --> 38:16.310
直接组合起来

38:16.310 --> 38:17.310
LOX

38:17.310 --> 38:18.310
比如包含体育

38:19.310 --> 38:20.310
还要包含

38:22.310 --> 38:23.310
LOX

38:23.310 --> 38:24.310
音乐

38:26.310 --> 38:27.310
运行

38:27.310 --> 38:28.310
查不出来

38:28.310 --> 38:29.310
但是意识大

38:29.310 --> 38:30.310
就这么个写法

38:31.310 --> 38:32.310
没了意思吧

38:33.310 --> 38:35.310
还有一个我说一下

38:36.310 --> 38:37.310
还有一个说一下

38:37.310 --> 38:39.310
还有一个就是关于

38:40.310 --> 38:41.310
这种查询

38:41.310 --> 38:42.310
一些特殊的查询

38:42.310 --> 38:43.310
就是包括指纹达的查询

38:43.310 --> 38:44.310
啥意思呢

38:44.310 --> 38:45.310
你看

38:45.310 --> 38:47.310
比方说我要查一些很特殊的

38:47.310 --> 38:49.310
我要查第1个I好必须是音乐

38:50.310 --> 38:51.310
I好是不是数组

38:51.310 --> 38:53.310
第1个I好必须要等于音乐

38:54.310 --> 38:55.310
必须要等于音乐

38:55.310 --> 38:56.310
那怎么写呢

38:56.310 --> 38:57.310
你可以这样写

38:58.310 --> 38:59.310
LOX

38:59.310 --> 39:00.310
0

39:00.310 --> 39:02.310
是不是数组的第1项

39:02.310 --> 39:03.310
它是支持这样的写法的

39:03.310 --> 39:04.310
如果说是数组的话

39:04.310 --> 39:06.310
那么就相当于是把他当一个对象

39:06.310 --> 39:07.310
取他的属性0

39:07.310 --> 39:08.310
数不是有一个对象吗

39:09.310 --> 39:10.310
他的0是不是下标

39:10.310 --> 39:11.310
下标也是个属性

39:11.310 --> 39:13.310
属性0要等于什么

39:15.310 --> 39:16.310
运行

39:16.310 --> 39:17.310
你看第1个属性一定是音乐

39:18.310 --> 39:19.310
对吧

39:19.310 --> 39:20.310
第1个属性一定是音乐

39:21.310 --> 39:22.310
好是这种写法

39:22.310 --> 39:23.310
然后再来

39:23.310 --> 39:25.310
如果说我要查询

39:25.310 --> 39:26.310
在那个

39:26.310 --> 39:27.310
哈尔滨的

39:27.310 --> 39:28.310
城市是哈尔滨的

39:28.310 --> 39:29.310
我可以这样写

39:29.310 --> 39:31.310
Provence.city

39:31.310 --> 39:32.310
为什么

39:32.310 --> 39:33.310
哈尔滨

39:34.310 --> 39:35.310
我看有没有哈尔滨

39:35.310 --> 39:36.310
没有

39:37.310 --> 39:38.310
成都呢

39:38.310 --> 39:42.070
数据量还是少

39:44.070 --> 39:45.070
没有

39:45.070 --> 39:46.070
这些人是谁

39:47.070 --> 39:48.070
好好学

39:48.070 --> 39:49.070
重庆

39:50.070 --> 39:51.070
要加个4是吧

39:51.070 --> 39:53.070
那我们就用正的表达试

39:53.070 --> 39:57.430
成都

39:58.430 --> 39:59.430
包含成都

40:00.430 --> 40:01.430
没有

40:01.430 --> 40:04.440
重庆

40:06.440 --> 40:07.440
没有

40:07.440 --> 40:08.440
刚才不是说重庆吗

40:09.440 --> 40:10.440
这里写错了

40:10.440 --> 40:12.440
这里是

40:14.440 --> 40:15.440
重庆的

40:15.440 --> 40:16.440
重庆的就查出来了

40:16.440 --> 40:17.440
重庆的

40:17.440 --> 40:18.440
看一下成都

40:20.440 --> 40:21.440
有一个

40:21.440 --> 40:22.440
然后看一下哈尔滨

40:23.440 --> 40:24.440
哈尔滨没有

40:25.440 --> 40:26.440
就这么个意思

40:26.440 --> 40:28.440
这就是可以做的那种

40:28.440 --> 40:30.440
这个东西叫做什么

40:30.440 --> 40:31.440
Property Path

40:31.440 --> 40:33.440
就是属性路径

40:33.440 --> 40:35.440
属性路径可以用这种属性的方式

40:36.440 --> 40:37.440
好了

40:37.440 --> 40:39.440
这就是原生里边的条件

40:39.440 --> 40:40.440
该怎么去写

40:40.440 --> 40:41.440
你来了吧

40:41.440 --> 40:42.440
好

40:42.440 --> 40:44.440
咱们看一下下一个

40:46.440 --> 40:47.440
下一个就是投印

40:48.440 --> 40:49.440
就是Fan的里边

40:49.440 --> 40:50.440
第二个参数

40:50.440 --> 40:51.440
第一个参数写条件

40:51.440 --> 40:52.440
返回的是邮标

40:52.440 --> 40:53.440
第一个参数写条件

40:53.440 --> 40:54.440
第二个参数是什么

40:54.440 --> 40:55.440
就是投印

40:55.440 --> 40:56.440
投印的话

40:56.440 --> 40:57.440
它是一个对象

40:57.440 --> 40:58.440
它对象非常简单

40:58.440 --> 40:59.440
你看看

40:59.440 --> 41:00.440
还有极动的写法

41:00.440 --> 41:01.440
你如果说你用这种写法的话

41:01.440 --> 41:02.440
就表示什么了

41:02.440 --> 41:03.440
你来查询结果中

41:03.440 --> 41:04.440
你不是有很多文档吗

41:04.440 --> 41:06.440
每个文档是一个对象

41:06.440 --> 41:07.440
那么对象里边

41:08.440 --> 41:09.440
A级属性

41:09.440 --> 41:10.440
另外一个

41:10.440 --> 41:11.440
它会自动给你加一个属性

41:11.440 --> 41:12.440
就是ID

41:12.440 --> 41:13.440
ID它会自动给你带过来

41:13.440 --> 41:14.440
好

41:14.440 --> 41:15.440
咱们看一下

41:15.440 --> 41:16.440
如果说Fan的里边

41:16.440 --> 41:20.440
我们找到重庆

41:20.440 --> 41:21.440
然后你再继续

41:21.440 --> 41:22.440
第二个参数

41:22.440 --> 41:23.440
第二个参数

41:23.440 --> 41:24.440
我们写投印

41:24.440 --> 41:25.440
投印的话是一个对象

41:25.440 --> 41:26.440
对象里边

41:26.440 --> 41:27.440
我们比方说是这样写

41:28.440 --> 41:30.440
Name等于E

41:30.440 --> 41:32.440
A级等于E

41:32.440 --> 41:33.440
我们这样写

41:33.440 --> 41:34.440
这样写过后

41:34.440 --> 41:35.440
我们来看一下查询结果

41:35.440 --> 41:36.440
你是不是看

41:36.440 --> 41:37.440
是不是只有Name和A级

41:37.440 --> 41:39.440
ID它会自动给你带进来

41:39.440 --> 41:40.440
就这么简单

41:40.440 --> 41:41.440
好

41:41.440 --> 41:42.440
另外一种写法是

41:42.440 --> 41:43.440
比方说这种写法

41:43.440 --> 41:44.440
Locking Password等于A级

41:44.440 --> 41:45.440
A级等于0

41:45.440 --> 41:46.440
就去掉这两个属性

41:46.440 --> 41:47.440
这两个属性不要

41:47.440 --> 41:49.440
其他的属性都给我弄进来

41:49.440 --> 41:50.440
比方说

41:50.440 --> 41:53.440
这些Locking Password等于0

41:53.440 --> 41:54.440
0就是没有

41:54.440 --> 41:55.440
A级等于0

41:55.440 --> 41:56.440
运行

41:56.440 --> 41:58.440
你看除了Locking Password的

41:58.440 --> 41:59.440
之外

41:59.440 --> 42:00.440
和A级之外

42:00.440 --> 42:01.440
这两个属性是不是没了

42:01.440 --> 42:02.440
对了

42:02.440 --> 42:03.440
其他都够带进来

42:03.440 --> 42:04.440
原来的意思

42:05.440 --> 42:06.440
一个是包含

42:06.440 --> 42:07.440
一个是去除

42:07.440 --> 42:08.440
好

42:08.440 --> 42:09.440
现在我们写个混合的

42:09.440 --> 42:11.440
Name要A级也要

42:11.440 --> 42:12.440
但是ID不要

42:12.440 --> 42:13.440
来看一下

42:13.440 --> 42:14.440
这种写法

42:15.440 --> 42:18.440
Name要ID不要

42:18.440 --> 42:19.440
运行

42:19.440 --> 42:20.440
你看是不是只有NameA级

42:20.440 --> 42:22.440
我们一般来说都要ID的

42:22.440 --> 42:23.440
那么如果说

42:23.440 --> 42:24.440
用下面那种写法

42:24.440 --> 42:26.440
就Name要A级不要了

42:26.440 --> 42:28.440
你会发现不行了

42:28.440 --> 42:29.440
这样子是不行的

42:29.440 --> 42:30.440
对吧

42:30.440 --> 42:31.440
它爆错了

42:31.440 --> 42:32.440
这是怎么回事呢

42:32.440 --> 42:34.440
因为ID比较特殊

42:34.440 --> 42:35.440
ID它会自动地带进来

42:35.440 --> 42:37.440
哪怕你说了

42:37.440 --> 42:38.440
我只要Name和A级

42:38.440 --> 42:39.440
它也会给大家ID

42:39.440 --> 42:41.440
所以说ID是允许你去掉的

42:41.440 --> 42:42.440
但是如果说

42:42.440 --> 42:43.440
除了ID之外

42:43.440 --> 42:44.440
其他的东西

42:44.440 --> 42:45.440
你既想去掉

42:45.440 --> 42:46.440
又想保留

42:46.440 --> 42:47.440
那么就会出现问题

42:47.440 --> 42:48.440
你看这个逻辑是不是出问题了

42:48.440 --> 42:49.440
Name

42:49.440 --> 42:50.440
就是说我只要Name

42:50.440 --> 42:51.440
其他的不要

42:52.440 --> 42:53.440
而A级

42:53.440 --> 42:54.440
A级就是说

42:55.440 --> 42:56.440
我不要A级

42:56.440 --> 42:57.440
其他的都要

42:57.440 --> 42:58.440
你看是不是矛盾了

42:58.440 --> 42:59.440
对于Name

42:59.440 --> 43:00.440
对于这个配置来说

43:00.440 --> 43:01.440
是不是A级应该不要

43:01.440 --> 43:02.440
对吧

43:02.440 --> 43:03.440
只要NameA级不要

43:03.440 --> 43:05.440
对于这个字段来说

43:05.440 --> 43:07.440
只要NameA级不要

43:07.440 --> 43:09.440
那么对于这个字段来说

43:09.440 --> 43:11.440
也是不要A级

43:11.440 --> 43:12.440
还不能这样解释

43:12.440 --> 43:13.440
应该这样解释

43:13.440 --> 43:14.440
比方说另外一个属性

43:14.440 --> 43:15.440
另外一个属性

43:15.440 --> 43:16.440
叫做

43:16.440 --> 43:17.440
就是地址

43:17.440 --> 43:18.440
家庭住址

43:18.440 --> 43:20.440
那么对于这个配置来说

43:20.440 --> 43:22.440
家庭住址是不是不要的

43:22.440 --> 43:23.440
对于这个配置来说

43:23.440 --> 43:24.440
家庭住址是不是要要

43:24.440 --> 43:25.440
对吧

43:25.440 --> 43:26.440
因为这个是

43:26.440 --> 43:27.440
只要Name不要其他的

43:27.440 --> 43:28.440
家庭住址肯定不能要的

43:28.440 --> 43:30.440
那么对于A级来说

43:30.440 --> 43:32.440
不要一级其他都要

43:32.440 --> 43:33.440
家庭住址又要要

43:33.440 --> 43:34.440
那到底要不还是不要的

43:34.440 --> 43:35.440
是不是出了问题

43:35.440 --> 43:36.440
因此呢

43:36.440 --> 43:37.440
它的逻辑错误

43:37.440 --> 43:38.440
那么只有这个ID

43:38.440 --> 43:39.440
那是比较

43:39.440 --> 43:41.440
这个ID是比较特殊的

43:41.440 --> 43:42.440
你这里可以写

43:42.440 --> 43:44.440
但其他的都不要去写

43:44.440 --> 43:45.440
不要这种混合编写

43:45.440 --> 43:46.440
你看他这里

43:46.440 --> 43:47.440
包的错误就告诉你

43:47.440 --> 43:48.440
PROCHECTION投印

43:48.440 --> 43:50.440
不能包含一个就是

43:50.440 --> 43:52.440
混合的inclusion

43:52.440 --> 43:54.440
包含exclusion

43:54.440 --> 43:55.440
移除

43:55.440 --> 43:56.440
对吧

43:56.440 --> 43:57.440
不能混合包含和移除

43:57.440 --> 43:58.440
两种逻辑在里面

43:59.440 --> 44:00.440
这就是这个投印

44:00.440 --> 44:01.440
是不是特别简单

44:02.440 --> 44:04.440
那么这里就是

44:04.440 --> 44:05.440
说完了

44:06.440 --> 44:07.440
另外这里还可以

44:07.440 --> 44:08.440
还可以这样的写

44:08.440 --> 44:09.440
比较要的时候

44:09.440 --> 44:10.440
我们还可以这样的写

44:10.440 --> 44:11.440
我还要要什么

44:11.440 --> 44:12.440
还要的是

44:13.440 --> 44:15.440
下面的Promise

44:15.440 --> 44:17.440
我只要你的省份就行了

44:18.440 --> 44:19.440
你看是不是只有省份

44:19.440 --> 44:20.440
对不对

44:20.440 --> 44:21.440
就这么简单

44:21.440 --> 44:22.440
好

44:22.440 --> 44:24.440
这是关于这个投印

44:24.440 --> 44:25.440
那么现在芒果地毕的

44:25.440 --> 44:27.440
原生产员们就讲完了

44:27.440 --> 44:28.440
学习了芒果地毕的

44:28.440 --> 44:29.440
原生产员之后

44:29.440 --> 44:30.440
那么再来看

44:30.440 --> 44:31.440
芒果实里边的产员

44:31.440 --> 44:33.440
就特别特别简单了

44:33.440 --> 44:34.440
怎么来查呢

44:35.440 --> 44:36.440
一个是FantabandID

44:36.440 --> 44:38.440
产员单条数据

44:38.440 --> 44:39.440
他单独给你做了一个

44:39.440 --> 44:40.440
按照组建来产员

44:40.440 --> 44:42.440
ID闯进去就完事了

44:43.440 --> 44:44.440
产员单条数据

44:44.440 --> 44:45.440
这里我另外再说一个

44:45.440 --> 44:46.440
还要说一个

44:46.440 --> 44:47.440
就是如果说

44:47.440 --> 44:48.440
我们这里按ID来产员的话

44:48.440 --> 44:50.440
有个地方要注意一下

44:50.440 --> 44:52.440
我之前好像有讲过的

44:52.440 --> 44:54.440
比方说我们按ID来产员

44:54.440 --> 44:55.440
就查这个ID吧

44:56.440 --> 44:59.440
我们查询ID等于什么呢

44:59.440 --> 45:00.440
等于这个

45:01.440 --> 45:02.440
你看能查出来吗

45:02.440 --> 45:03.440
你会发现查不出来

45:04.440 --> 45:06.440
我这里少写了一个括号

45:07.440 --> 45:08.440
查不出来

45:08.440 --> 45:09.440
为什么查不出来呢

45:09.440 --> 45:11.440
因为ID是什么类型

45:11.440 --> 45:12.440
ID是Object是ID类型

45:12.440 --> 45:13.440
所以说你这里

45:13.440 --> 45:14.440
要用Object是ID

45:15.440 --> 45:16.440
喊数调用一下

45:16.440 --> 45:18.440
这是我们之前是不是讲过的

45:18.440 --> 45:19.440
ID是Object类型

45:19.440 --> 45:20.440
所以现在可以查出来了

45:20.440 --> 45:22.440
这是芒果地毕原生的一边查询

45:22.440 --> 45:24.440
但是芒果实里边不需要

45:24.440 --> 45:26.440
芒果实里边还会自动帮你装

45:26.440 --> 45:27.440
你不需要进行操作

45:27.440 --> 45:28.440
好

45:28.440 --> 45:30.440
咱们再看一下芒果实里边怎么来查

45:31.440 --> 45:32.440
除了ID之外

45:32.440 --> 45:33.440
拿出这里文记

45:33.440 --> 45:34.440
记一笔

45:34.440 --> 45:35.440
以后再记吧

45:35.440 --> 45:37.440
它的查询的分为三种

45:37.440 --> 45:38.440
一种是Find by ID

45:38.440 --> 45:39.440
一种是Find 1

45:39.440 --> 45:40.440
一种是Find

45:40.440 --> 45:42.440
一般来说就用这三种查询就够了

45:42.440 --> 45:43.440
咱们来看一下吧

45:43.440 --> 45:44.440
用这个词边

45:44.440 --> 45:45.440
我们找到这个User

45:46.440 --> 45:49.400
行

45:49.400 --> 45:50.400
Test

45:51.400 --> 45:52.400
调用Test

45:53.400 --> 45:55.400
现在我们使用User

45:55.400 --> 45:57.400
使用Find by ID

45:58.400 --> 45:59.400
把ID传进去

45:59.400 --> 46:01.400
当然它可以传回调的方式

46:01.400 --> 46:02.400
在这里写个回调

46:02.400 --> 46:04.400
说Error而Result

46:04.400 --> 46:05.400
可以用这种方式

46:05.400 --> 46:07.400
也可以我们更加喜欢用这种是

46:07.400 --> 46:08.400
Arrange

46:08.400 --> 46:09.400
等待

46:09.400 --> 46:10.400
等待一个结果

46:11.400 --> 46:12.400
输出Result

46:15.090 --> 46:16.090
这边

46:16.090 --> 46:17.090
停止

46:17.090 --> 46:18.090
回到这里

46:18.090 --> 46:19.090
npm start

46:20.090 --> 46:22.530
你看是不是查出来

46:22.530 --> 46:23.530
当对象

46:23.530 --> 46:24.530
就查出来了

46:24.530 --> 46:25.530
就这么简单

46:25.530 --> 46:26.530
当然第二查询里可以写

46:27.530 --> 46:29.530
第二查询里可以写projection

46:29.530 --> 46:30.530
比方说我们这里

46:30.530 --> 46:31.530
只需要Name

46:32.530 --> 46:33.530
只需要A级

46:33.530 --> 46:34.530
写法是不是一样的

46:34.530 --> 46:35.530
对不对

46:35.530 --> 46:36.530
保存

46:36.530 --> 46:37.530
你看是不是只有A级和Name

46:37.530 --> 46:38.530
当然还带个ID

46:39.530 --> 46:40.530
这里的ID

46:40.530 --> 46:42.530
你可以不用去传ObjectsID

46:42.530 --> 46:43.530
直接传

46:43.530 --> 46:44.530
这不错

46:44.530 --> 46:45.530
它可以当地进行转换

46:45.530 --> 46:46.530
都是查询

46:46.530 --> 46:47.530
根据主键来说

46:47.530 --> 46:48.530
用查询

46:48.530 --> 46:49.530
下一个

46:49.530 --> 46:50.530
下个是Find 1

46:50.530 --> 46:51.530
查询单条

46:51.530 --> 46:52.530
这里可以给条件了

46:52.530 --> 46:54.530
按照你给的条件

46:54.530 --> 46:55.530
来查询单条数据

46:55.530 --> 46:56.530
无论你满足多少条

46:56.530 --> 46:57.530
满足一万条

46:57.530 --> 46:58.530
它也只取

46:58.530 --> 46:59.530
启动一条

46:59.530 --> 47:00.530
就相当于是取第一条

47:01.530 --> 47:02.530
后面写投影

47:02.530 --> 47:03.530
第一个写条件

47:03.530 --> 47:04.530
非常简单

47:04.530 --> 47:05.530
好 咱们来看一下这个

47:06.530 --> 47:07.530
这查询单个

47:08.530 --> 47:09.530
咱们呢

47:09.530 --> 47:11.530
用cause而result而wait

47:12.530 --> 47:13.530
user

47:13.530 --> 47:15.530
然后Find 1

47:15.530 --> 47:16.530
查询一条

47:16.530 --> 47:17.530
条件是什么呢

47:17.530 --> 47:18.530
条件是

47:19.530 --> 47:20.530
比如说我们年龄

47:21.530 --> 47:23.530
年龄要大于GT

47:23.530 --> 47:24.530
大于20岁

47:25.530 --> 47:26.530
取第一条就行了

47:27.530 --> 47:28.530
那我们来看一下吧

47:29.530 --> 47:30.530
保存

47:30.530 --> 47:31.530
让我们看一下

47:31.530 --> 47:32.530
就取出来一条数据

47:32.530 --> 47:36.530
年龄是大于20岁的

47:36.530 --> 47:37.530
年龄大于20岁的

47:37.530 --> 47:38.530
就取出来一条

47:39.530 --> 47:40.530
取出来一条

47:40.530 --> 47:41.530
为什么不是20岁呢

47:41.530 --> 47:42.530
因为没排序

47:42.530 --> 47:43.530
没排序

47:43.530 --> 47:46.530
按照存出顺序来取的

47:46.530 --> 47:47.530
取出来第一条就39岁

47:48.530 --> 47:49.530
Find 1

47:50.530 --> 47:51.530
然后战狼

47:51.530 --> 47:52.530
下面那个Find

47:52.530 --> 47:53.530
就是查询多少数据的

47:53.530 --> 47:54.530
这个时候我们

47:54.530 --> 47:55.530
想都可以想象到

47:55.530 --> 47:56.530
这个东西是不是可以

47:56.530 --> 47:57.530
经常会使用

47:57.530 --> 47:58.530
条件然后投入

47:58.530 --> 47:59.530
对吧

47:59.530 --> 48:00.530
写法是一样的

48:00.530 --> 48:01.530
查询多少数据

48:02.530 --> 48:03.530
cause而result

48:05.530 --> 48:06.530
cause而result

48:06.530 --> 48:07.530
而wait

48:07.530 --> 48:08.530
user

48:08.530 --> 48:09.530
Find

48:09.530 --> 48:10.530
他反过来就是一个数组了

48:11.530 --> 48:12.530
那么 age

48:12.530 --> 48:13.530
条件是

48:13.530 --> 48:14.530
要大于

48:14.530 --> 48:15.530
20

48:16.530 --> 48:17.530
保存

48:17.530 --> 48:18.530
你看一下

48:18.530 --> 48:19.530
找到一个数组

48:19.530 --> 48:20.530
还有150多个

48:20.530 --> 48:21.530
显示不出来了

48:21.530 --> 48:22.530
对

48:23.530 --> 48:24.530
大于20的

48:24.530 --> 48:25.530
对不对

48:25.530 --> 48:26.530
然后大于30的

48:26.530 --> 48:27.530
保存

48:28.530 --> 48:29.530
还有18个

48:29.530 --> 48:30.530
对吧

48:30.530 --> 48:31.530
稍微少一些的

48:31.530 --> 48:32.530
对吧

48:32.530 --> 48:33.530
都大于30的

48:33.530 --> 48:34.530
这就是条件

48:34.530 --> 48:35.530
条件的写法

48:35.530 --> 48:36.530
跟之前是一样的

48:36.530 --> 48:37.530
我就不要一一说了

48:37.530 --> 48:38.530
就这个对象

48:38.530 --> 48:39.530
一直一直写条件

48:39.530 --> 48:40.530
这个查询的写投印

48:40.530 --> 48:41.530
然后投印的

48:41.530 --> 48:42.530
我们可以写上

48:42.530 --> 48:43.530
一个name

48:43.530 --> 48:44.530
age

48:44.530 --> 48:45.530
保存

48:45.530 --> 48:46.530
你看一下

48:48.530 --> 48:49.530
这样子

48:49.530 --> 48:50.530
用这种方式来显示

48:50.530 --> 48:51.530
对吧

48:51.530 --> 48:52.530
都一样的

48:53.530 --> 48:54.530
然后继续看

48:55.530 --> 48:56.530
Find1和Find

48:56.530 --> 48:57.530
如果说你没有给予

48:57.530 --> 48:58.530
回调函数

48:58.530 --> 48:59.530
或者是等待

48:59.530 --> 49:00.530
就是说

49:00.530 --> 49:01.530
你这里第二参数没有

49:01.530 --> 49:02.530
传回调

49:02.530 --> 49:03.530
我们现在没有用

49:03.530 --> 49:04.530
回调函数的模式

49:04.530 --> 49:05.530
或者说你没有等待它

49:05.530 --> 49:06.530
那么这个时候

49:06.530 --> 49:07.530
它是不会

49:07.530 --> 49:08.530
真正的进行查询的

49:08.530 --> 49:09.530
它不会进行查询的

49:10.530 --> 49:11.530
那么它会给你

49:11.530 --> 49:12.530
返回一个什么呢

49:12.530 --> 49:13.530
它会给你返回一个叫

49:13.530 --> 49:14.530
create

49:14.530 --> 49:15.530
document query对象

49:15.530 --> 49:17.530
它会给你返回这个玩意

49:18.530 --> 49:19.530
那么这个对象

49:19.530 --> 49:20.530
你可以通过

49:20.530 --> 49:21.530
它进行电视调用

49:21.530 --> 49:22.530
是不是跟之前的有标

49:22.530 --> 49:23.530
有点相似

49:23.530 --> 49:24.530
电视调用进一步

49:24.530 --> 49:25.530
获取结果

49:25.530 --> 49:26.530
直到传回调

49:26.530 --> 49:27.530
等待或者调用sql

49:27.530 --> 49:28.530
才会真正的执行

49:28.530 --> 49:29.530
什么意思呢

49:29.530 --> 49:30.530
就是它后边

49:30.530 --> 49:31.530
电视里边你可以用

49:31.530 --> 49:32.530
caught

49:32.530 --> 49:33.530
得到多少条数据

49:33.530 --> 49:34.530
Name it

49:34.530 --> 49:35.530
skip

49:35.530 --> 49:36.530
sort

49:36.530 --> 49:37.530
caught 应该是最后调用

49:37.530 --> 49:38.530
对不对

49:38.530 --> 49:39.530
因为caught 最后

49:39.530 --> 49:40.530
就已经拿到结果了

49:40.530 --> 49:41.530
所以我们这里

49:41.530 --> 49:42.530
可以怎么写呢

49:42.530 --> 49:43.530
先去找一下

49:43.530 --> 49:44.530
找到结果里边

49:44.530 --> 49:45.530
我们可以分页

49:45.530 --> 49:46.530
skip

49:46.530 --> 49:47.530
然后第一页数据

49:47.530 --> 49:49.530
是不是去掉0条数据

49:49.530 --> 49:50.530
第二页

49:50.530 --> 49:51.530
去掉10条数据

49:51.530 --> 49:52.530
每页显示10条

49:52.530 --> 49:53.530
第一

49:53.530 --> 49:54.530
第二页就是去掉10条

49:54.530 --> 49:55.530
然后再取10条

49:55.530 --> 49:56.530
对不对

49:56.530 --> 49:57.530
好保存

49:57.530 --> 49:58.530
是不是可以分页

49:58.530 --> 49:59.530
你看看

49:59.530 --> 50:00.530
是不是达到10条数据

50:00.530 --> 50:01.530
可以分页

50:01.530 --> 50:02.530
没问题吧

50:02.530 --> 50:04.530
然后我们可以排序

50:04.530 --> 50:06.530
按照什么排序呢

50:06.530 --> 50:07.530
按照那个就是

50:07.530 --> 50:10.530
年龄的生序排序

50:10.530 --> 50:11.530
A级1

50:12.530 --> 50:13.530
你看

50:13.530 --> 50:15.530
是不是按照年龄的生序排序

50:15.530 --> 50:16.530
第二页的

50:16.530 --> 50:17.530
第三页的

50:17.530 --> 50:18.530
比方说

50:18.530 --> 50:20.530
排一级

50:20.530 --> 50:21.530
第二页

50:21.530 --> 50:22.530
然后呢

50:22.530 --> 50:23.530
年龄

50:23.530 --> 50:24.530
把这些东西的数字

50:24.530 --> 50:25.530
可以让用户里面传过来

50:25.530 --> 50:26.530
对吧

50:26.530 --> 50:27.530
通过地址来参数传过来

50:27.530 --> 50:28.530
然后这边呢

50:28.530 --> 50:29.530
我们可以把年龄写到这

50:29.530 --> 50:30.530
对不对

50:30.530 --> 50:31.530
那么这里写啥呢

50:31.530 --> 50:32.530
排一级捷1

50:32.530 --> 50:33.530
成年龄写

50:33.530 --> 50:35.530
分页应该很熟悉啊

50:35.530 --> 50:37.530
这是第二页对不对

50:37.530 --> 50:38.530
然后呢

50:38.530 --> 50:39.530
我们就看一下

50:39.530 --> 50:40.530
第三页

50:40.530 --> 50:41.530
第三页

50:41.530 --> 50:42.530
32

50:42.530 --> 50:43.530
33

50:43.530 --> 50:44.530
第四页

50:44.530 --> 50:45.530
对吧

50:45.530 --> 50:46.530
33

50:46.530 --> 50:47.530
对不对

50:47.530 --> 50:48.530
是不是可以分页了

50:48.530 --> 50:49.530
这就是

50:49.530 --> 50:51.530
他的这种写法

50:51.530 --> 50:52.530
跟那个有标准法

50:52.530 --> 50:53.530
是不是一样的

50:53.530 --> 50:54.530
一样的

50:54.530 --> 50:56.530
你如果要得到扣子的话

50:56.530 --> 50:58.530
扣子的话是这样的写

50:58.530 --> 51:00.530
那么得到的就是一个结果了

51:00.530 --> 51:02.530
一共

51:02.530 --> 51:04.530
这里一共就十个

51:04.530 --> 51:05.530
这种写法就跟那个

51:05.530 --> 51:06.530
有标不一样了

51:06.530 --> 51:07.530
有标里面说一个size

51:07.530 --> 51:08.530
对不对

51:08.530 --> 51:09.530
取它一共

51:09.530 --> 51:10.530
这里查清楚来的道理

51:10.530 --> 51:11.530
这里就不一样了

51:11.530 --> 51:12.530
那么如果说

51:12.530 --> 51:13.530
你要取扣子的话

51:13.530 --> 51:14.530
应该是不要前面的写法

51:14.530 --> 51:15.530
你挑过什么呢

51:15.530 --> 51:16.530
对吧

51:16.530 --> 51:17.530
排序也可以不用排了

51:17.530 --> 51:18.530
直接取扣子

51:18.530 --> 51:19.530
是吧

51:19.530 --> 51:20.530
这个是110吧

51:20.530 --> 51:21.530
这里包了一个警告

51:21.530 --> 51:22.530
他说扣子这个函数呢

51:22.530 --> 51:23.530
已经被废弃了

51:23.530 --> 51:24.530
建议你呢

51:24.530 --> 51:26.530
将来的版本可能会被移除

51:26.530 --> 51:28.530
建议你使用扣子document

51:28.530 --> 51:29.530
建议你使用这个

51:29.530 --> 51:32.530
扣子document

51:32.530 --> 51:33.530
建议你使用这个

51:33.530 --> 51:34.530
110吧

51:34.530 --> 51:35.530
现在没有帮警告了

51:35.530 --> 51:37.530
这个地方跟有标不一样

51:38.530 --> 51:39.530
好

51:39.530 --> 51:40.530
那么这就是

51:40.530 --> 51:41.530
这个里面的这种

51:41.530 --> 51:43.530
这些乱七八糟的写法

51:43.530 --> 51:44.530
说一下

51:44.530 --> 51:47.100
好

51:47.100 --> 51:48.100
最后一点

51:48.100 --> 51:49.100
我们来做一个总结

51:49.100 --> 51:50.100
就是关于这个差异点

51:50.100 --> 51:51.100
刚才我们说了一个差异点

51:51.100 --> 51:52.100
对吧

51:52.100 --> 51:53.100
刚才也不记

51:53.100 --> 51:54.100
有些人又忘了

51:54.100 --> 51:55.100
刚才说什么差异点呢

51:55.100 --> 51:56.100
说啥差异点

51:56.100 --> 51:57.100
第一个就是

51:57.100 --> 51:59.100
扣子

51:59.100 --> 52:00.100
得到的是

52:00.100 --> 52:03.100
当前结果的数量

52:03.100 --> 52:04.100
而不是整个的数量

52:04.100 --> 52:06.100
跟那个有标不一样

52:06.100 --> 52:07.100
这是第一个差异点

52:07.100 --> 52:08.100
第一个差异点呢

52:08.100 --> 52:09.100
是哪呢

52:09.100 --> 52:10.100
是在

52:10.100 --> 52:11.100
刚才在哪呢

52:12.100 --> 52:14.100
这个地方

52:14.100 --> 52:17.670
刚才说了啥差异点

52:17.670 --> 52:19.670
ID

52:20.670 --> 52:22.670
查询

52:22.670 --> 52:26.670
ID使用制服串即可

52:26.670 --> 52:28.670
制服串即可

52:28.670 --> 52:30.670
它不用使用Object ID

52:30.670 --> 52:31.670
如果说你用Object ID

52:31.670 --> 52:32.670
可不可以的

52:32.670 --> 52:33.670
当然可以

52:33.670 --> 52:34.670
比方说我们这个地方

52:34.670 --> 52:35.670
主持了

52:35.670 --> 52:36.670
比方这个地方

52:36.670 --> 52:37.670
用Object ID可怎么用

52:38.670 --> 52:39.670
用Object ID的话

52:39.670 --> 52:40.670
那么你可以把风壮一下

52:40.670 --> 52:41.670
但是你这里

52:41.670 --> 52:42.670
不能直接写Object ID

52:42.670 --> 52:43.670
你这要直接写

52:43.670 --> 52:44.670
有没有这个函数

52:44.670 --> 52:46.670
这是正宗的解释代码

52:46.670 --> 52:47.670
什么没有这个函数

52:47.670 --> 52:48.670
那么它的Object ID在哪呢

52:48.670 --> 52:49.670
在这

52:49.670 --> 52:51.670
它给你提供

52:51.670 --> 52:53.670
这个Object ID函数

52:53.670 --> 52:57.670
在Object ID

52:57.670 --> 52:59.670
在Mangus里边

52:59.670 --> 53:02.670
里面之前用过的

53:02.670 --> 53:04.670
Mangus里边

53:04.670 --> 53:05.670
有个什么的

53:05.670 --> 53:07.670
有个Taps里边有个Object ID

53:07.670 --> 53:09.670
有个这么玩

53:09.670 --> 53:10.670
也可以在这里边找

53:10.670 --> 53:11.670
都一样

53:11.670 --> 53:12.670
都是一个东西

53:12.670 --> 53:13.670
Skeema

53:13.670 --> 53:15.670
Taps里面有一个Object ID

53:15.670 --> 53:17.670
那么这样子可不可以呢

53:17.670 --> 53:18.670
也可以

53:19.670 --> 53:20.670
就包错了

53:20.670 --> 53:23.750
Symbol

53:23.750 --> 53:24.750
好玩呀

53:25.750 --> 53:27.750
这里怎么把回报错呢

53:27.750 --> 53:32.040
全空一下

53:33.040 --> 53:34.040
保存

53:34.040 --> 53:37.120
到这里看一下

53:37.120 --> 53:38.120
保存什么错

53:39.120 --> 53:40.120
因为你用Object ID

53:40.120 --> 53:42.120
不能使用这个

53:42.120 --> 53:43.120
它这个东西只能

53:43.120 --> 53:44.120
只能去定义

53:44.120 --> 53:46.120
定义这个Skeema的时候

53:46.120 --> 53:47.120
约束内行

53:47.120 --> 53:48.120
这个玩意只能约束内行

53:48.120 --> 53:49.120
你不能去使用它

53:49.120 --> 53:50.120
还给你报了错误

53:50.120 --> 53:51.120
还给你说得很明白

53:51.120 --> 53:52.120
让你去用这个

53:52.120 --> 53:53.120
好那行吧

53:53.120 --> 53:54.120
那就用这个

53:54.120 --> 53:55.120
你看

53:55.120 --> 53:56.120
是不是可以

53:56.120 --> 53:57.120
没问题

53:57.120 --> 53:58.120
这就是这里

53:58.120 --> 53:59.120
我说一下

53:59.120 --> 54:00.120
好

54:00.120 --> 54:01.120
这是这个差一点

54:02.120 --> 54:03.120
下来

54:06.780 --> 54:07.780
下一个

54:07.780 --> 54:08.780
下一个就是Project ID

54:08.780 --> 54:10.780
它支持制服串的写法

54:10.780 --> 54:11.780
啥意思呢

54:11.780 --> 54:12.780
就是你这个Project ID

54:12.780 --> 54:13.780
就在这里边

54:13.780 --> 54:14.780
我们这里是用的对象

54:14.780 --> 54:15.780
对吧

54:15.780 --> 54:16.780
它支持的是制服串写法

54:16.780 --> 54:17.780
你怎么写的更加方便一点

54:17.780 --> 54:18.780
就是Name

54:18.780 --> 54:19.780
通革A级

54:19.780 --> 54:20.780
如果要使用Name

54:20.780 --> 54:22.780
要使用11A级

54:22.780 --> 54:23.780
就这么个意思

54:23.780 --> 54:24.780
好保存

54:24.780 --> 54:25.780
你看一下吧

54:25.780 --> 54:26.780
知道是不是Name A级

54:26.780 --> 54:27.780
对吧

54:27.780 --> 54:28.780
也可以

54:28.780 --> 54:29.780
如果说你要去掉的话

54:29.780 --> 54:30.780
你用简号

54:30.780 --> 54:31.780
比方说

54:31.780 --> 54:32.780
我除了

54:32.780 --> 54:33.780
除了Archase之外

54:33.780 --> 54:34.780
我都要

54:34.780 --> 54:35.780
Archase不要

54:35.780 --> 54:36.780
Archase不要

54:36.780 --> 54:37.780
然后再来一个Nove

54:37.780 --> 54:38.780
其他我都要

54:38.780 --> 54:39.780
保存

54:39.780 --> 54:40.780
你看

54:40.780 --> 54:42.780
是不是有这么一些属性

54:42.780 --> 54:43.780
对不对

54:43.780 --> 54:44.780
还有这个

54:44.780 --> 54:45.780
两个下发线V

54:45.780 --> 54:46.780
我不要

54:47.780 --> 54:48.780
对吧

54:48.780 --> 54:49.780
所以可以这样子写

54:49.780 --> 54:50.780
没问题吧

54:50.780 --> 54:51.780
这是关于这一块

54:53.780 --> 54:54.780
好

54:54.780 --> 54:55.780
然后再继续

54:57.780 --> 54:58.780
我们看一下

54:58.780 --> 54:59.780
Sort

54:59.780 --> 55:01.780
Sort它也支持制服串写法

55:01.780 --> 55:02.780
Sort也支持

55:02.780 --> 55:03.780
比方说这里Sort

55:03.780 --> 55:04.780
我们用的是对象

55:04.780 --> 55:05.780
对吧

55:05.780 --> 55:06.780
那么你可以怎么写的

55:06.780 --> 55:07.780
你可以写上A级

55:08.780 --> 55:09.780
按照A级的生讯排序

55:10.780 --> 55:11.780
按照A级的生讯排序

55:11.780 --> 55:12.780
如果说你前面

55:12.780 --> 55:13.780
也可以写个加号

55:13.780 --> 55:14.780
一样的效果

55:14.780 --> 55:15.780
生讯排序

55:16.780 --> 55:17.780
加号

55:17.780 --> 55:18.780
不对

55:18.780 --> 55:19.780
不能写加号

55:19.780 --> 55:20.780
这就是生讯排序

55:20.780 --> 55:21.780
生讯排序

55:24.780 --> 55:26.780
Sort

55:26.780 --> 55:28.780
Sort

55:28.780 --> 55:29.780
我看一下

55:29.780 --> 55:30.780
我再清空一下

55:30.780 --> 55:32.780
我把这些乱七八糟的去掉

55:33.780 --> 55:34.780
A级

55:34.780 --> 55:36.780
好像不太对

55:36.780 --> 55:38.780
2223

55:38.780 --> 55:39.780
这个是对的

55:39.780 --> 55:40.780
按照生讯排序

55:40.780 --> 55:41.780
加号行不行

55:42.780 --> 55:43.780
写加号是不行的

55:43.780 --> 55:45.780
不能写加号

55:45.780 --> 55:46.780
2223

55:46.780 --> 55:47.780
这个是正确的

55:47.780 --> 55:48.780
第三页

55:48.780 --> 55:49.780
别的十条

55:49.780 --> 55:50.780
然后如果说你要

55:50.780 --> 55:51.780
将许排序的话

55:51.780 --> 55:52.780
用简号

55:52.780 --> 55:53.780
按照将许排序

55:53.780 --> 55:54.780
那么这是将许排序

55:54.780 --> 55:55.780
你可以用自不错的书写

55:55.780 --> 55:56.780
更加方便

55:56.780 --> 55:57.780
都是这个Sort

55:57.780 --> 55:58.780
然后接下来

55:58.780 --> 55:59.780
还有一个就是

55:59.780 --> 56:00.780
支持你关联查询

56:00.780 --> 56:02.780
尽管在芒果DB里边

56:02.780 --> 56:03.780
不是很推荐

56:03.780 --> 56:04.780
大家使用大量的关联

56:04.780 --> 56:05.780
因为像用Microsoft里边

56:05.780 --> 56:06.780
是不是有表兼的关系

56:06.780 --> 56:07.780
一对一对多

56:07.780 --> 56:08.780
那样去发达关系

56:09.780 --> 56:10.780
在芒果DB里边

56:10.780 --> 56:12.780
它的优势

56:12.780 --> 56:14.780
是存出独写大量数据

56:14.780 --> 56:16.780
它的优势不是搞关系的

56:16.780 --> 56:19.780
如果说你的集合与集合之间

56:19.780 --> 56:20.780
有很多很多

56:20.780 --> 56:21.780
复杂的关系的话

56:21.780 --> 56:22.780
你就不要用芒果DB

56:22.780 --> 56:24.780
你要用芒果DB的话

56:24.780 --> 56:26.780
就要有关系能不能有关系能

56:26.780 --> 56:27.780
但是你不要把关系

56:27.780 --> 56:28.780
搞得太复杂了

56:28.780 --> 56:29.780
搞得太多了

56:30.780 --> 56:31.780
所以芒果DB里边

56:31.780 --> 56:32.780
我看一下

56:32.780 --> 56:33.780
给大家看一下

56:33.780 --> 56:34.780
如果说有关系的话

56:34.780 --> 56:35.780
怎么来写这个关系

56:35.780 --> 56:37.780
比网站的operating

56:37.780 --> 56:39.780
和这个U字儿之间

56:39.780 --> 56:40.780
不是有关系吗

56:40.780 --> 56:41.780
对不对

56:41.780 --> 56:42.780
是不是有关系

56:42.780 --> 56:43.780
一个用户是不是有多个操作

56:43.780 --> 56:45.780
一个操作是不是对应

56:45.780 --> 56:46.780
多个用户

56:46.780 --> 56:47.780
对不对

56:47.780 --> 56:49.780
那么这个地方怎么来

56:49.780 --> 56:50.780
怎么来操作

56:50.780 --> 56:51.780
怎么来输写的

56:51.780 --> 56:53.780
这个地方要这样子来

56:53.780 --> 56:54.780
首先你在定义模型的时候

56:54.780 --> 56:55.780
我们要之前定义

56:55.780 --> 56:56.780
定义这个结构的时候

56:56.780 --> 56:58.780
我们就根本就没去考虑这一点

56:58.780 --> 57:00.780
如果说你要有关系的话

57:00.780 --> 57:01.780
在定义结构的时候

57:01.780 --> 57:02.780
你要去考虑

57:02.780 --> 57:03.780
比方说这个U字儿ID

57:03.780 --> 57:04.780
operating这个U字儿ID

57:04.780 --> 57:06.780
那么你这里要写个东西

57:06.780 --> 57:07.780
几个配置叫Rave

57:08.780 --> 57:09.780
Rave

57:09.780 --> 57:11.780
比方它的关系

57:11.780 --> 57:12.780
关系是怎么来

57:12.780 --> 57:13.780
给它取个名字

57:14.780 --> 57:15.780
关联到另外一个模型

57:15.780 --> 57:17.780
模型的名称叫做U字儿

57:18.780 --> 57:19.780
你看另外一个U字儿

57:19.780 --> 57:20.780
模型的名称是不是U字儿

57:20.780 --> 57:21.780
对吧

57:21.780 --> 57:22.780
我们这个ID是要关联到

57:22.780 --> 57:24.780
另外一个模型的U字儿

57:24.780 --> 57:26.780
它就去关联好了

57:26.780 --> 57:27.780
关联好了之后

57:27.780 --> 57:29.780
我们到index.js里边去

57:29.780 --> 57:31.780
在这里边去

57:32.780 --> 57:34.780
那么现在我们去查的时候

57:34.780 --> 57:36.780
在这里加上一个

57:36.780 --> 57:38.780
一个函数叫populate

57:39.780 --> 57:40.780
我们现在查的是

57:40.780 --> 57:41.780
另外一个表对吧

57:43.780 --> 57:44.780
注释一下

57:44.780 --> 57:49.950
现在我们去查那个operating

57:49.950 --> 57:50.950
这个表

57:50.950 --> 57:51.950
fand

57:52.950 --> 57:53.950
就随便查吧

57:53.950 --> 57:54.950
然后呢就是

57:54.950 --> 57:56.950
来一个name it吧

57:57.950 --> 57:59.950
只取一个

57:59.950 --> 58:00.950
大家看一下就行了

58:00.950 --> 58:01.950
只取一个

58:01.950 --> 58:03.950
然后呢接下来我们用populate

58:03.950 --> 58:04.950
如果说我们不写

58:04.950 --> 58:05.950
populate的话

58:05.950 --> 58:06.950
看一下吧

58:06.950 --> 58:08.950
输出 without

58:08.950 --> 58:09.950
保存

58:09.950 --> 58:11.950
你看是不是就一条

58:11.950 --> 58:12.950
一个操作对吧

58:12.950 --> 58:13.950
阅读文章

58:13.950 --> 58:15.950
那么这里是不是一个用户ID

58:15.950 --> 58:16.950
对不对

58:16.950 --> 58:17.950
那么这个ID是不是关联到

58:17.950 --> 58:18.950
另外一张表对吧

58:18.950 --> 58:19.950
U字儿表

58:19.950 --> 58:20.950
那么我们这里呢

58:20.950 --> 58:22.950
可以用populate

58:23.950 --> 58:24.950
关联到哪呢

58:24.950 --> 58:25.950
关联到U字儿

58:25.950 --> 58:27.950
关联到U字儿

58:27.950 --> 58:29.950
好保存

58:29.950 --> 58:30.950
不对不对

58:30.950 --> 58:31.950
这里写错了

58:31.950 --> 58:32.950
这里要写这个

58:32.950 --> 58:33.950
要写这个operating里边

58:33.950 --> 58:34.950
那个字段名称

58:34.950 --> 58:35.950
字段名称是U字儿ID

58:35.950 --> 58:36.950
对吧

58:36.950 --> 58:37.950
它就会自动去关联到U字儿

58:37.950 --> 58:38.950
它知道它关联到U字儿

58:38.950 --> 58:40.950
你把个名称写到这

58:40.950 --> 58:42.950
那么它就会把U字儿ID给你展开

58:42.950 --> 58:43.950
展开成一个对象

58:43.950 --> 58:44.950
对吧

58:44.950 --> 58:45.950
它会自动去帮你从U字儿表中

58:45.950 --> 58:46.950
查询出一个对象

58:46.950 --> 58:47.950
展到这

58:47.950 --> 58:48.950
而且呢

58:48.950 --> 58:49.950
这个对象里边呢

58:49.950 --> 58:50.950
信息是不是比较丰富

58:50.950 --> 58:51.950
对吧

58:51.950 --> 58:52.950
所有的用户信息都在这

58:52.950 --> 58:53.950
那么我们这里呢

58:53.950 --> 58:54.950
还可以给第二个参数

58:54.950 --> 58:56.950
就是说我们要用到哪些用户

58:56.950 --> 58:57.950
用到哪些用户信息呢

58:57.950 --> 58:59.950
我们只需要你的年龄和姓名

58:59.950 --> 59:00.950
就行了

59:00.950 --> 59:01.950
其他我不要

59:01.950 --> 59:02.950
保存

59:02.950 --> 59:03.950
那你看现在的U字儿

59:03.950 --> 59:05.950
U字儿里边是不是有A级

59:05.950 --> 59:06.950
对吧

59:06.950 --> 59:07.950
其他都没了

59:07.950 --> 59:09.950
那么如果说你用

59:09.950 --> 59:10.950
这种做法写的话

59:10.950 --> 59:12.950
我这里是根本没打算用这种做法写

59:12.950 --> 59:13.950
如果说你要用这种做法写的话

59:13.950 --> 59:15.950
我们这里建议大家的名字呢

59:15.950 --> 59:16.950
你就不用U字儿ID了

59:16.950 --> 59:18.950
名字去改取名叫U字儿

59:18.950 --> 59:19.950
对吧

59:19.950 --> 59:20.950
好另外一方面呢

59:20.950 --> 59:21.950
就是如果说你要查询

59:21.950 --> 59:22.950
用户里边所有的操作

59:22.950 --> 59:23.950
每个用户所有的操作

59:23.950 --> 59:24.950
把它形成一个数组的话

59:24.950 --> 59:25.950
然后我这里办不到

59:25.950 --> 59:27.950
因为你在定义这个结构的时候呢

59:27.950 --> 59:29.950
你要去加一个属性

59:29.950 --> 59:31.950
比方说叫做operations

59:31.950 --> 59:32.950
这个属性什么类型呢

59:32.950 --> 59:34.950
应该就是一个数组

59:34.950 --> 59:35.950
就是这个用户有哪些操作

59:35.950 --> 59:36.950
一个数组

59:36.950 --> 59:37.950
每个数组里面

59:37.950 --> 59:38.950
每一项呢

59:38.950 --> 59:43.450
一个叫做operations ID

59:43.450 --> 59:45.450
Types object ID

59:45.450 --> 59:46.450
它的每一项

59:46.450 --> 59:48.450
就应该是一个object ID

59:48.450 --> 59:50.450
然后在那边查的时候

59:50.450 --> 59:52.450
那边去查询的时候

59:52.450 --> 59:54.450
那么这里是不是

59:54.450 --> 59:57.960
每个地方应该是这个

59:57.960 --> 01:00:00.960
Type object ID

01:00:00.960 --> 01:00:02.960
就是schema

01:00:02.960 --> 01:00:04.960
Types object ID

01:00:04.960 --> 01:00:07.960
然后Rave连接到operations表

01:00:07.960 --> 01:00:08.960
连到这个表

01:00:08.960 --> 01:00:10.960
就每个operations

01:00:10.960 --> 01:00:11.960
这一个对象

01:00:11.960 --> 01:00:13.960
对象里面有Type属性

01:00:13.960 --> 01:00:15.960
Type属性是object ID

01:00:15.960 --> 01:00:16.960
只有这个属性

01:00:16.960 --> 01:00:17.960
然后每个对象

01:00:17.960 --> 01:00:18.960
它要去关联到另外一张表

01:00:18.960 --> 01:00:19.960
到时候呢

01:00:19.960 --> 01:00:21.960
我们这边查优热式的时候呢

01:00:21.960 --> 01:00:22.960
就用populate

01:00:22.960 --> 01:00:23.960
就用populate

01:00:23.960 --> 01:00:24.960
这边写啥

01:00:24.960 --> 01:00:25.960
查优热的时候

01:00:25.960 --> 01:00:27.960
查优热式就用populate

01:00:27.960 --> 01:00:28.960
这边写啥呢

01:00:28.960 --> 01:00:29.960
这边写operations

01:00:29.960 --> 01:00:30.960
这边写这个东西

01:00:30.960 --> 01:00:31.960
就行了

01:00:31.960 --> 01:00:33.960
那我们来试试一下吧

01:00:33.960 --> 01:00:34.960
优热

01:00:34.960 --> 01:00:35.960
fand

01:00:35.960 --> 01:00:36.960
就插一个嘛

01:00:36.960 --> 01:00:37.960
populate

01:00:37.960 --> 01:00:39.960
operations

01:00:39.960 --> 01:00:41.960
这边我们不要了

01:00:41.960 --> 01:00:45.270
你看一下吧

01:00:45.270 --> 01:00:46.270
保存

01:00:46.270 --> 01:00:47.270
你看一下

01:00:47.270 --> 01:00:48.270
现在operations

01:00:48.270 --> 01:00:49.270
是不是买东西

01:00:49.270 --> 01:00:50.270
空速组

01:00:50.270 --> 01:00:51.270
为什么是空速组呢

01:00:51.270 --> 01:00:52.270
是因为我这个

01:00:52.270 --> 01:00:53.270
我这数据库里面

01:00:53.270 --> 01:00:54.270
根本就没有往那个数据里面

01:00:54.270 --> 01:00:55.270
夹的东西对吧

01:00:55.270 --> 01:00:56.270
根本就没有记住

01:00:56.270 --> 01:00:57.270
所以说这个东西呢

01:00:57.270 --> 01:00:58.270
一开始在定义集合的时候呢

01:00:58.270 --> 01:00:59.270
就一定要考虑好

01:00:59.270 --> 01:01:00.270
总之呢

01:01:00.270 --> 01:01:02.270
这个关联查学

01:01:02.270 --> 01:01:03.270
我不建议大家在

01:01:03.270 --> 01:01:04.270
mango.db

01:01:04.270 --> 01:01:05.270
里面去搞这些乱巧的

01:01:05.270 --> 01:01:06.270
关联查学

01:01:06.270 --> 01:01:07.270
能不使用关联查学

01:01:07.270 --> 01:01:08.270
尽量不要使用

01:01:08.270 --> 01:01:09.270
mango.db

01:01:09.270 --> 01:01:10.270
里面是不在乎数据

01:01:10.270 --> 01:01:11.270
容预就容预了

01:01:11.270 --> 01:01:12.270
没什么关系

01:01:12.270 --> 01:01:14.270
他不在乎数据容预

01:01:14.270 --> 01:01:16.270
像白色过去特别在乎

01:01:16.270 --> 01:01:17.270
对吧

01:01:17.270 --> 01:01:18.270
我们讲了个数据库的

01:01:18.270 --> 01:01:19.270
三方式对不对

01:01:19.270 --> 01:01:20.270
重要的就是

01:01:20.270 --> 01:01:21.270
很多地方就是

01:01:21.270 --> 01:01:22.270
尽量不要有数据容预

01:01:22.270 --> 01:01:23.270
但是mango.db

01:01:23.270 --> 01:01:24.270
不在乎

01:01:24.270 --> 01:01:25.270
无所谓的

01:01:25.270 --> 01:01:26.270
多一点

01:01:26.270 --> 01:01:27.270
好

01:01:27.270 --> 01:01:29.270
那么这里是关于这个

01:01:29.270 --> 01:01:31.270
mango.db的查询

01:01:31.270 --> 01:01:32.270
我们能够

01:01:32.270 --> 01:01:33.270
平时能够用到的

01:01:33.270 --> 01:01:34.270
都跟他讲了

01:01:34.270 --> 01:01:36.270
就是关于这个地方

01:01:36.270 --> 01:01:37.270
大家下来

01:01:37.270 --> 01:01:38.270
这些每一个查询的

01:01:38.270 --> 01:01:39.270
都去练一练

01:01:39.270 --> 01:01:40.270
就随便想一些例子

01:01:40.270 --> 01:01:41.270
这里的例子也很好想的

01:01:41.270 --> 01:01:42.270
随便想一些例子

01:01:42.270 --> 01:01:43.270
就去练一练

01:01:43.270 --> 01:01:44.270
我就不给大家

01:01:44.270 --> 01:01:45.270
具体的规定作业了

01:01:45.270 --> 01:01:46.270
好

01:01:46.270 --> 01:01:47.270
长期讲完了过后

01:01:47.270 --> 01:01:48.270
后面再慢慢说

01:01:48.270 --> 01:01:49.270
修改和删除

