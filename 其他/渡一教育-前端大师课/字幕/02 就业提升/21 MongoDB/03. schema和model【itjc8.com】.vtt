WEBVTT

00:00.500 --> 00:02.500
哎呀 悲剧啊

00:03.500 --> 00:06.500
这个第三节课给大家重录一下啊

00:07.500 --> 00:09.500
因为之前呢录了第三节课

00:09.500 --> 00:11.500
录了过后呢发现了有一

00:11.500 --> 00:13.500
有一段没有接上

00:13.500 --> 00:15.500
所以说干脆把整节课给他重录了

00:16.500 --> 00:17.500
因为是重录了

00:17.500 --> 00:19.500
所以说可能

00:19.500 --> 00:21.500
因为我现在录的时间点啊

00:21.500 --> 00:23.500
就是已经把整个mongo DB就已经录完了

00:23.500 --> 00:25.500
然后重新录了这第三节课

00:25.500 --> 00:27.500
可能有一些细节地方啊

00:27.500 --> 00:29.500
跟后边的一些代码的有点接不上

00:30.500 --> 00:32.500
但是绝大部分应该能接上

00:32.500 --> 00:34.500
就有一些细节地方的接不上

00:34.500 --> 00:36.500
那么不影响

00:36.500 --> 00:38.500
因为大部分的核心功能

00:38.500 --> 00:40.500
核心代码都是一样的

00:40.500 --> 00:41.500
只是一些细节啊

00:41.500 --> 00:43.500
也地方描络换行啊

00:43.500 --> 00:45.500
比方说有一个小的配置啊没有接上

00:45.500 --> 00:47.500
给大家理解一下

00:47.500 --> 00:49.500
上节课呢前面两节课呢咱们讲了

00:49.500 --> 00:51.500
mongo DB他原生的使用

00:52.500 --> 00:54.500
那么我们现在要在loader.js

00:54.500 --> 00:56.500
里面用代码的方式来操作mongo DB了

00:56.500 --> 00:58.500
这个东西呢跟那个买收货是一样的

00:58.500 --> 01:00.500
买收货我们学了原生之后呢

01:00.500 --> 01:02.500
学收货语剧之后呢

01:02.500 --> 01:04.500
我们还是用loader.js的驱动

01:04.500 --> 01:06.500
买收货2

01:06.500 --> 01:08.500
以及呢mongo

01:08.500 --> 01:10.500
以及呢synchronize

01:10.500 --> 01:12.500
来进行对买收货的操作

01:12.500 --> 01:14.500
mongo DB也是一样

01:14.500 --> 01:16.500
mongo DB呢跟所有的数据库啊

01:16.500 --> 01:18.500
在程序里面操作呢都需要一个驱动

01:18.500 --> 01:20.500
mongo DB呢他的官方驱动

01:20.500 --> 01:22.500
他就叫做mongo DB

01:22.500 --> 01:24.500
就像买收货的官方驱动就叫做买收货

01:24.500 --> 01:26.500
是一样的

01:26.500 --> 01:28.500
这个驱动啊和网网不是很好用

01:28.500 --> 01:30.500
我们网网会使用

01:30.500 --> 01:32.500
在操作mongo DB的时候呢

01:32.500 --> 01:34.500
网网会使用mongo

01:34.500 --> 01:36.500
会使用这么一个数据库

01:36.500 --> 01:38.500
他的官网他的名言中文网

01:38.500 --> 01:40.500
会使用这个mongo作为驱动

01:40.500 --> 01:42.500
当然呢跟买收货一样

01:42.500 --> 01:44.500
mongo这个驱动呢

01:44.500 --> 01:46.500
他内部呢也去使用了官方的驱动

01:46.500 --> 01:48.500
就是mongo DB

01:48.500 --> 01:50.500
那么我们后边这些课啊

01:50.500 --> 01:52.500
基本上都是在讲mongo去使用

01:52.500 --> 01:54.500
而讲mongo的时候呢

01:54.500 --> 01:56.500
我们主要的几个块

01:56.500 --> 01:58.500
就这些课讲的

01:58.500 --> 02:00.500
创建连接和模型定义

02:00.500 --> 02:02.500
以及呢后边讲的CRUD

02:02.500 --> 02:04.500
就是生产改查的操作

02:04.500 --> 02:06.500
那么这些学习的过后呢基本差不多了

02:06.500 --> 02:08.500
就能够操作个数据库了

02:08.500 --> 02:10.500
好我们这些课呢先来讲

02:10.500 --> 02:12.500
创建连接和模型定义

02:12.500 --> 02:14.500
当然呢你首先得去安装mongo

02:14.500 --> 02:16.500
好我们来安装一下吧

02:16.500 --> 02:18.500
我们去他的官网

02:18.500 --> 02:23.150
直接去官网吧

02:23.150 --> 02:25.150
好我们这里的NPM

02:25.150 --> 02:29.170
安装

02:29.170 --> 02:31.170
安装一下mongo

02:31.170 --> 02:33.170
他内部呢去使用了这个

02:33.170 --> 02:35.170
mongo DB啊所以说我们只需要安装这个mongo

02:35.170 --> 02:37.170
就可以了

02:37.170 --> 02:39.170
我看一下

02:39.170 --> 02:41.170
应该没问题

02:41.170 --> 02:43.170
把这些之前的都删掉

02:43.170 --> 02:45.170
都删掉

02:45.170 --> 02:47.170
好然后呢我们现在去这个官网

02:47.170 --> 02:49.170
这里一个文档

02:49.170 --> 02:51.170
我们首先要搞定的就是连接

02:51.170 --> 02:53.170
我们之前跟mongo一样对吧

02:53.170 --> 02:55.170
需要创建一个连接通道那么后期的操作呢

02:55.170 --> 02:57.170
这个连接通道去完成

02:57.170 --> 02:59.170
因此呢我们首先要得

02:59.170 --> 03:01.170
首先要知道怎么去创建一个连接

03:01.170 --> 03:03.170
我们这也可以在这里能看到一个quick start

03:03.170 --> 03:05.170
就是快速开始

03:05.170 --> 03:07.170
快速开始里面他自己介绍了怎么来创建连接呢

03:07.170 --> 03:09.170
非常简单你只需要去导入

03:09.170 --> 03:11.170
mongo

03:11.170 --> 03:13.170
去导入这个mongo

03:13.170 --> 03:15.170
我们用const

03:15.170 --> 03:17.170
然后接下来要做的事情就是连接

03:17.170 --> 03:19.170
他里面一个方法叫做connect

03:19.170 --> 03:21.170
mongo connect

03:21.170 --> 03:23.170
连接

03:23.170 --> 03:25.170
这个参数呢就是一个字无串

03:25.170 --> 03:27.170
表示连接字无串

03:27.170 --> 03:29.170
他连接字无串咋写的呢就这样子写的

03:29.170 --> 03:31.170
就这样子写的

03:31.170 --> 03:33.170
后面前面跟个协议就是mongo db协议

03:33.170 --> 03:35.170
然后呢连接的主机名

03:35.170 --> 03:37.170
因为我们是本机嘛

03:37.170 --> 03:39.170
所以说我们就直接写得过host

03:39.170 --> 03:41.170
当然如果说你是远程数据会的话

03:41.170 --> 03:43.170
你写他的主机名就完事了

03:43.170 --> 03:45.170
mongo db的主机呢他的端口号呢是

03:45.170 --> 03:47.170
27017

03:47.170 --> 03:49.170
我们当时在

03:49.170 --> 03:51.170
做这个连接的时候是吧27017

03:51.170 --> 03:53.170
是这个端口号

03:53.170 --> 03:55.170
那么你这里不用去写的端口号

03:55.170 --> 03:57.170
他会自动给你使用27017的端口号

03:57.170 --> 03:59.170
那么后边写的是啥呢

03:59.170 --> 04:01.170
后边写的就是数据库的名称

04:01.170 --> 04:03.170
写的就是数据库的名称

04:03.170 --> 04:05.170
那么这个数据库的名称呢我们随便写

04:05.170 --> 04:07.170
比方说我们看

04:07.170 --> 04:09.170
我们这里呢换一个名字

04:09.170 --> 04:11.170
比方换个tes3

04:11.170 --> 04:13.170
比方说换一下名字吧换个tes3

04:13.170 --> 04:15.170
好来试一下吧

04:15.170 --> 04:17.170
现在呢我们到这个

04:17.170 --> 04:19.170
就这样子就创建好了连接了

04:19.170 --> 04:21.170
这样子就进行了连接了

04:21.170 --> 04:23.170
然后呢后边呢他有一些事件

04:23.170 --> 04:24.170
他会反

04:24.170 --> 04:26.170
他会反回一个就是

04:26.170 --> 04:27.170
得到这个

04:27.170 --> 04:29.170
后面我们就可以通过mongo

04:29.170 --> 04:31.170
扛了一个型来得到这个连接对象

04:31.170 --> 04:33.170
这得到连接对象

04:33.170 --> 04:35.170
连接对象里边呢他可以通过这个

04:35.170 --> 04:37.170
有点类似于这个event emitter

04:37.170 --> 04:39.170
对吧我们在这个门路的街市里面讲过的

04:39.170 --> 04:41.170
可以给他注册一些事件

04:41.170 --> 04:43.170
比方连接已经打开的时候

04:43.170 --> 04:45.170
你看什么事件呢就open

04:45.170 --> 04:47.170
当连接打开的时候呢

04:47.170 --> 04:49.170
我们可以运行一个函数

04:49.170 --> 04:51.170
连接

04:51.170 --> 04:53.170
e打开

04:53.170 --> 04:55.170
好保存

04:55.170 --> 04:57.170
接下来来看一下运行看一下吧

04:57.170 --> 04:59.170
load index

04:59.170 --> 05:01.170
好那么这里是不是连接e打开

05:01.170 --> 05:03.170
OK那么我们这里呢

05:03.170 --> 05:05.170
可以看到一些警告啊这些警告呢

05:05.170 --> 05:07.170
他并不影响这个连接的打开

05:07.170 --> 05:09.170
但是呢他告诉你

05:09.170 --> 05:11.170
有些东西呢已经过时了

05:11.170 --> 05:13.170
如果说你

05:13.170 --> 05:15.170
而且这些东西呢会在将来的

05:15.170 --> 05:17.170
里边啊会被移除掉

05:17.170 --> 05:19.170
所以说呢尽量呢让你解决这些警告

05:19.170 --> 05:21.170
那么这警告什么意思呢

05:21.170 --> 05:23.170
我们一个个说首先第一个警告啊

05:23.170 --> 05:25.170
第一个警告他告诉你呢

05:25.170 --> 05:27.170
这个连接制服串的解析啊

05:27.170 --> 05:29.170
这是个连接制服串对吧

05:29.170 --> 05:31.170
对这个连接制服串的解析呢过去呢

05:31.170 --> 05:33.170
用的是一些默认的方式

05:33.170 --> 05:35.170
那么现在呢

05:35.170 --> 05:37.170
新版本里边对这个连接制服串的解析呢

05:37.170 --> 05:39.170
有了新的方式那么建议呢

05:39.170 --> 05:41.170
手动了去配置他的新的方式

05:41.170 --> 05:43.170
如果说你不配置的话

05:43.170 --> 05:45.170
为什么不自动给你应用新的方式呢

05:45.170 --> 05:47.170
因为他保持兼容

05:47.170 --> 05:49.170
不然的话你猛固子

05:49.170 --> 05:51.170
以前的版本里边用了过后一升级

05:51.170 --> 05:53.170
发现以前那是出问题的

05:53.170 --> 05:55.170
所以说呢让你去手动的去指定

05:55.170 --> 05:57.170
用新的解析方式来解析这个连接制服串

05:57.170 --> 05:59.170
那么怎么来配置呢非常简单

05:59.170 --> 06:01.170
为了消除这个警告

06:01.170 --> 06:03.170
你在你第二个参数写个配置

06:03.170 --> 06:05.170
配置里面呢写上一个叫做

06:05.170 --> 06:07.170
U16 URL POSER

06:07.170 --> 06:09.170
这个东西呢其实跟那个

06:09.170 --> 06:11.170
你们以前学的Express

06:11.170 --> 06:13.170
Express里面不是有一个就是

06:13.170 --> 06:15.170
Express.url encoded对吧

06:15.170 --> 06:17.170
还记得吗那个中间键

06:17.170 --> 06:19.170
那个中间键里面说的也用了这个配置

06:19.170 --> 06:21.170
对吧他实际上就是

06:21.170 --> 06:23.170
用了一个另外一个插件

06:23.170 --> 06:25.170
那个插件来解析一个

06:25.170 --> 06:27.170
对一个制服刷进行解析

06:27.170 --> 06:29.170
好所以说我们把这个配置上就玩笑了

06:29.170 --> 06:31.170
配置上这个警告就消失了

06:31.170 --> 06:33.170
好我们来看一下吧

06:33.170 --> 06:36.540
Load index

06:36.540 --> 06:38.540
你看第一个警告就消失了对吧

06:38.540 --> 06:40.540
那么接下来还有一个警告

06:40.540 --> 06:42.540
他就是这个警告就是他过去

06:42.540 --> 06:44.540
他发现数据库

06:44.540 --> 06:46.540
以及数据库的监视

06:46.540 --> 06:48.540
监视引擎

06:48.540 --> 06:50.540
那种过去的那种方式呢已经过期了

06:50.540 --> 06:52.540
那现在呢使用了新的方式

06:52.540 --> 06:54.540
但是为了保持兼容呢

06:54.540 --> 06:56.540
他仍然是没有用纠的方式

06:56.540 --> 06:58.540
那现在呢希望你去指定一个

06:58.540 --> 07:00.540
新的方式来发现数据库

07:00.540 --> 07:02.540
来使用数据库的监视引擎

07:02.540 --> 07:04.540
好那么我们这里呢

07:04.540 --> 07:06.540
把这个东西复制一下

07:06.540 --> 07:08.540
他让你去做这个配置

07:08.540 --> 07:10.540
你不用去过去生纠

07:10.540 --> 07:12.540
你只要把配置上解决这个警告

07:12.540 --> 07:14.540
就OK了

07:14.540 --> 07:16.540
好我们来运行一下

07:16.540 --> 07:18.540
好你看是不是没有警告了

07:18.540 --> 07:20.540
连接打开

07:20.540 --> 07:22.540
那么我们通常来写数据库的时候

07:22.540 --> 07:24.540
会把这个连接啊专门来放到一个地方

07:24.540 --> 07:26.540
因为连接打一打开就完事了

07:26.540 --> 07:28.540
后边我们就不用管它了

07:28.540 --> 07:30.540
只要能够保证那个代码运行一次

07:30.540 --> 07:32.540
就可以了

07:32.540 --> 07:34.540
所以说呢我们可以把大方放到一个单独的模块里边

07:34.540 --> 07:36.540
于是呢我们在这里呢新建个文件夹吧

07:36.540 --> 07:38.540
我们在这里呢随便取一个比较那么取的models

07:38.540 --> 07:40.540
一会儿你就知道

07:40.540 --> 07:42.540
为什么要取这个名字了

07:42.540 --> 07:44.540
就是跟那个myscore的sqlnize这个数据库的处理

07:44.540 --> 07:46.540
是不是一样的

07:46.540 --> 07:48.540
sqlnize是不是也是加了一些模型

07:48.540 --> 07:50.540
对不对

07:50.540 --> 07:52.540
我们这里呢也可以认为

07:52.540 --> 07:54.540
里面会有一些模型啊一会儿才讲

07:54.540 --> 07:56.540
现在我们在这里呢新建个文件

07:56.540 --> 07:58.540
就是crease connection

07:58.540 --> 08:00.540
好我们把刚才代码

08:00.540 --> 08:02.540
复制暂停到这

08:02.540 --> 08:04.540
暂停到这

08:04.540 --> 08:06.540
在models里面新建个文件

08:06.540 --> 08:08.540
叫index.js

08:08.540 --> 08:10.540
就是我们外面去使用导入这个models的时候呢

08:10.540 --> 08:12.540
就用这个文件

08:12.540 --> 08:14.540
好那么这个文件里面呢我就做的事情非常简单

08:14.540 --> 08:18.750
我就用require

08:18.750 --> 08:20.750
crease

08:20.750 --> 08:22.750
就是我在这个文件里面呢

08:22.750 --> 08:24.750
这个模块里面导入这个模块

08:24.750 --> 08:26.750
就是目的呢就是让这个模块运行一次

08:26.750 --> 08:28.750
明白的意思吧

08:28.750 --> 08:30.750
就让这个模块运行一次来创建连接

08:30.750 --> 08:32.750
然后我们在我们的启动程序里面呢

08:32.750 --> 08:34.750
就是我们程序结构稍微控制一下

08:34.750 --> 08:36.750
我们是不是导入这个models

08:36.750 --> 08:38.750
对吧它默认就是导入这个index.js

08:38.750 --> 08:40.750
去导入它

08:40.750 --> 08:42.750
那么这就导入它的想象

08:42.750 --> 08:44.750
你导入它的话是不是就运行了它

08:44.750 --> 08:46.750
对吧就是相当导入它

08:46.750 --> 08:48.750
那么导入它的时候是不是运行了它

08:48.750 --> 08:50.750
对不对很简单

08:50.750 --> 08:52.750
那么我们先把它写成这种结构

08:52.750 --> 08:54.750
当然呢这个效果呢是完全一样的

08:54.750 --> 08:56.750
就是一样的

08:56.750 --> 08:58.750
好那么这是

08:58.750 --> 09:00.750
关于这个数据库的连接启动

09:00.750 --> 09:02.750
非常简单

09:02.750 --> 09:04.750
这就是定义数据库的模型

09:04.750 --> 09:06.750
我们还记得吗在myserco里面定义模型

09:06.750 --> 09:08.750
相当于是啥呀

09:08.750 --> 09:10.750
在myserco里面定义模型

09:10.750 --> 09:12.750
相当于是定义的是数据库的表

09:12.750 --> 09:14.750
对不对

09:14.750 --> 09:16.750
那么在mongoDB里面定义模型呢

09:16.750 --> 09:18.750
就相当于是定义数据库的集合

09:18.750 --> 09:20.750
定义的模型相当于是定义集合

09:20.750 --> 09:22.750
但是在mongo里面

09:22.750 --> 09:24.750
它当有去定义模型啊

09:24.750 --> 09:26.750
实际上它的模型呢

09:26.750 --> 09:28.750
是要根据一个东西而来

09:28.750 --> 09:30.750
这个东西叫做结构

09:30.750 --> 09:32.750
叫schema

09:32.750 --> 09:34.750
它是这样子的

09:34.750 --> 09:36.750
它是通过这个结构来定义模型的

09:36.750 --> 09:38.750
结构是什么东西呢

09:38.750 --> 09:40.750
结构它描述了

09:40.750 --> 09:42.750
描述了某种数据

09:42.750 --> 09:44.750
某种数据

09:44.750 --> 09:46.750
中有哪些字段

09:46.750 --> 09:48.750
以及呢

09:48.750 --> 09:50.750
每个字段

09:50.750 --> 09:52.750
是什么类型

09:52.750 --> 09:54.750
以及呢

09:54.750 --> 09:56.750
每个

09:56.750 --> 09:58.750
字段的约束

09:58.750 --> 10:00.750
我举个例子啊

10:00.750 --> 10:02.750
比方说我们有一个

10:02.750 --> 10:04.750
用户

10:04.750 --> 10:06.750
用户里边有哪些字段呢

10:06.750 --> 10:08.750
有密码

10:08.750 --> 10:10.750
有用户的性别

10:10.750 --> 10:12.750
那么这些呢就需要结构来定义

10:12.750 --> 10:14.750
比方说用户的

10:14.750 --> 10:16.750
性名的话

10:16.750 --> 10:18.750
我们是两个字到五个字

10:18.750 --> 10:20.750
是不是约束

10:20.750 --> 10:22.750
而且性名呢是一个制服串

10:22.750 --> 10:24.750
这些都是结构

10:24.750 --> 10:26.750
那么这个东西mongoDB

10:26.750 --> 10:28.750
里面哪有这些东西啊

10:28.750 --> 10:30.750
mongoDB随便随意

10:30.750 --> 10:32.750
你只要给我数据

10:32.750 --> 10:34.750
给我一个对象我就把存起来

10:34.750 --> 10:36.750
这我们上前两节课遇到了

10:36.750 --> 10:38.750
那他们并没有说什么

10:38.750 --> 10:40.750
你要去定义这个什么结构

10:40.750 --> 10:42.750
实际上呢mongoDB里面

10:42.750 --> 10:44.750
是有结构这个概念的

10:44.750 --> 10:46.750
只是呢他并没有做过多的强调

10:46.750 --> 10:48.750
而且呢功能比较弱

10:48.750 --> 10:50.750
因此呢mongoDB相当于是把这个结构增强了

10:50.750 --> 10:52.750
它在它内部呢给你搞出来这么一个结构

10:52.750 --> 10:54.750
这么一个东西

10:54.750 --> 10:56.750
就是mongoDB内部的东西

10:56.750 --> 10:58.750
实际上mongoDB呢

10:58.750 --> 11:00.750
它也有

11:00.750 --> 11:02.750
因此呢我们定义了结构之后

11:02.750 --> 11:04.750
我们才去定义模型

11:04.750 --> 11:06.750
它是有这么两个步骤

11:06.750 --> 11:08.750
接下来呢我们来做的事情就是定义结构了

11:08.750 --> 11:10.750
那么我们的结构呢

11:10.750 --> 11:12.750
我们接下来要做两个

11:12.750 --> 11:14.750
有两个结构

11:14.750 --> 11:16.750
一个是用户的结构

11:16.750 --> 11:18.750
一个是用户操作的结构

11:18.750 --> 11:20.750
我这个人为什么没有去举电影的例子

11:20.750 --> 11:22.750
没有去举什么新闻的例子呢

11:22.750 --> 11:24.750
如果mongoDB来存数据的话

11:24.750 --> 11:26.750
一般来说啊不会存那些

11:26.750 --> 11:28.750
带有强烈业务性质的数据

11:28.750 --> 11:30.750
一般来说存那种

11:30.750 --> 11:32.750
比较独立性比较强

11:32.750 --> 11:34.750
数据数据之间联系比较少

11:34.750 --> 11:36.750
有联系没有可能会有一点点联系

11:36.750 --> 11:38.750
但是呢相对比较独立

11:38.750 --> 11:40.750
而且呢它的数据量比较大的那种数据

11:40.750 --> 11:42.750
我们一般用mongoDB

11:42.750 --> 11:44.750
这是它的优势

11:44.750 --> 11:46.750
我们之前说过mongoDB呢

11:46.750 --> 11:48.750
它适合存出于数据关系简单

11:48.750 --> 11:50.750
没有什么负达的关系

11:50.750 --> 11:52.750
一个集合就是一个独立的数据

11:52.750 --> 11:54.750
那数据量比较大

11:54.750 --> 11:56.750
它特别适合处理这种场景

11:56.750 --> 11:58.750
因为mongoDB呢它就本身就是那种

11:58.750 --> 12:00.750
楼色口数据空嘛

12:00.750 --> 12:02.750
它处理复杂结构的数据呢

12:02.750 --> 12:04.750
不应该用它来存

12:04.750 --> 12:06.750
应该用麦色过去存

12:06.750 --> 12:08.750
而且呢它本身对大数据呢

12:08.750 --> 12:10.750
数据量大的时候呢它有

12:10.750 --> 12:12.750
非常优秀的读写性能

12:12.750 --> 12:14.750
因此呢我们一般处理这种数据

12:14.750 --> 12:16.750
所以我给他说了两种数据

12:16.750 --> 12:18.750
一种是用户的数据

12:18.750 --> 12:20.750
就是用户做了多的登录

12:20.750 --> 12:22.750
什么时候哪个用户做了登录

12:22.750 --> 12:24.750
然后用户什么时候出销的

12:24.750 --> 12:26.750
用户呢比方说浏览了一篇新闻等等等等

12:26.750 --> 12:28.750
举个例子吧

12:28.750 --> 12:30.750
那么现在呢比方说

12:30.750 --> 12:32.750
我们现在定义一个结构

12:32.750 --> 12:34.750
用户的一个结构

12:34.750 --> 12:36.750
那么结构怎么定义呢

12:36.750 --> 12:38.750
我们在这里呢看了官方文档

12:38.750 --> 12:40.750
它告诉你这个结构就是gamass

12:40.750 --> 12:42.750
它不会告诉你结构怎么定义

12:42.750 --> 12:44.750
因为我们后边呢操作的东西呢

12:44.750 --> 12:46.750
都我们要有结构

12:46.750 --> 12:48.750
我们要定义模型

12:48.750 --> 12:50.750
定义了模型过后

12:50.750 --> 12:52.750
我们后边操作的全是模型

12:52.750 --> 12:54.750
全是对针对模型定义操作

12:54.750 --> 12:56.750
好 接下来我们来看一下Skeema

12:56.750 --> 12:58.750
Skeema里面呢就表示

12:58.750 --> 13:00.750
它告诉你怎么来定义一个结构

13:00.750 --> 13:02.750
导述盲故事

13:02.750 --> 13:04.750
然后呢它里面有个故事还说Skeema

13:04.750 --> 13:06.750
你去留一个Skeema就完事了

13:06.750 --> 13:08.750
就这么简单

13:08.750 --> 13:10.750
所以说我们要做的事情

13:10.750 --> 13:12.750
我们在这里啊 新建个

13:12.750 --> 13:14.750
新建个文件

13:14.750 --> 13:16.750
那么在这边呢

13:16.750 --> 13:18.750
我们要做两件事

13:18.750 --> 13:20.750
第一件事定义User结构

13:20.750 --> 13:22.750
就User的Skeema

13:22.750 --> 13:24.750
然后呢第二件事

13:26.750 --> 13:28.750
通过UserSkeema

13:28.750 --> 13:30.750
定义模型

13:30.750 --> 13:32.750
最终要导出模型

13:32.750 --> 13:34.750
最终导出模型

13:34.750 --> 13:36.750
因为外面别人要用的话

13:36.750 --> 13:38.750
它就要通过

13:38.750 --> 13:40.750
所谓的针对数据库的针杉改查

13:40.750 --> 13:42.750
操作都要通过模型来处理

13:42.750 --> 13:44.750
就是我们要导出模型

13:44.750 --> 13:46.750
供外面使用

13:46.750 --> 13:48.750
那么模型怎么来的呢必须要先定义结构

13:48.750 --> 13:50.750
好 咱们来看一下这个过程

13:50.750 --> 13:52.750
怎么来定义结构呢 首先导入

13:52.750 --> 13:54.750
盲故事

13:54.750 --> 13:56.750
Require

13:56.750 --> 13:58.750
盲故事

13:58.750 --> 14:00.750
那么盲故事里面有一个Skeema

14:00.750 --> 14:02.750
它是一个构造函数

14:02.750 --> 14:04.750
所以说我们只需要去留一个Skeema就可以了

14:04.750 --> 14:06.750
留的时候呢它里面要传一个参数

14:06.750 --> 14:08.750
就是结构的定义

14:08.750 --> 14:10.750
结构配置

14:10.750 --> 14:12.750
Skeema的配置

14:12.750 --> 14:14.750
好 那么我们把这个

14:14.750 --> 14:16.750
总之呢 这里它就会返回一个结构

14:16.750 --> 14:18.750
返回一个结构 那么我们这里得到一个

14:18.750 --> 14:20.750
UserSkeema

14:20.750 --> 14:22.750
返回一个结构 然后最终我们模型怎么来呢

14:22.750 --> 14:24.750
模型呢就是

14:24.750 --> 14:26.750
通过这个

14:26.750 --> 14:28.750
盲故事

14:28.750 --> 14:30.750
Model

14:30.750 --> 14:32.750
那么第一个参数呢写上模型的名称

14:32.750 --> 14:34.750
名称呢你就该取个名字就行了

14:34.750 --> 14:36.750
那么这个名称呢它就会对应到

14:36.750 --> 14:38.750
数据库里面的集合

14:38.750 --> 14:40.750
所以说我们这里的写个

14:40.750 --> 14:41.750
一般来说写个大写

14:41.750 --> 14:42.750
User

14:42.750 --> 14:44.750
就是它模型的名称

14:44.750 --> 14:46.750
好 第二个参数呢就是模型对应的结构

14:46.750 --> 14:48.750
模型的对应用什么

14:48.750 --> 14:50.750
使用什么样的结构呢使用这个结构

14:50.750 --> 14:52.750
用这个结构来作为模型的结构

14:52.750 --> 14:54.750
就完成了

14:54.750 --> 14:56.750
它们就定义了一个模型

14:56.750 --> 14:58.750
好 这里呢我们只需要把这个模型导出就完成了

14:58.750 --> 14:59.750
对不对

14:59.750 --> 15:01.750
Module X Deport导出就完成了

15:01.750 --> 15:03.750
那么这样子完成了一个User

15:03.750 --> 15:05.750
结构的定义以及模型的定义

15:05.750 --> 15:07.750
就写完了

15:07.750 --> 15:09.750
那么最后呢我们为了用者方便

15:09.750 --> 15:10.750
我们在index里边呢

15:10.750 --> 15:12.750
我们可以在这里重新导出一次

15:12.750 --> 15:14.750
export

15:14.750 --> 15:15.750
叫User

15:15.750 --> 15:19.060
把这个User导出

15:19.060 --> 15:21.060
就是把一个User导出的东西呢

15:21.060 --> 15:22.060
在这里重新导出一下

15:22.060 --> 15:24.060
那么这边呢有了这样的方式的过程

15:24.060 --> 15:26.060
我们在这边就可以使用这种方式来得到用户了

15:26.060 --> 15:27.060
比方说

15:27.060 --> 15:29.060
我们可以用这种方式

15:29.060 --> 15:31.060
User 拿到User这个模型

15:31.060 --> 15:32.060
对不对

15:32.060 --> 15:34.060
Module Index里边就可以拿到这个模型了

15:34.060 --> 15:35.060
同意在这个

15:35.060 --> 15:37.060
同意的入口里面去写

15:37.060 --> 15:39.060
就这么个意思 非常简单

15:39.060 --> 15:41.060
那么现在我们注意一点点就放到这儿了

15:41.060 --> 15:43.060
放到这儿

15:43.060 --> 15:44.060
schema的配置

15:44.060 --> 15:46.060
那么schema怎么来配置呢

15:46.060 --> 15:48.060
配置的方式其实也很简单

15:48.060 --> 15:50.060
有简单的写法

15:50.060 --> 15:52.060
有只要稍微灵活更加

15:52.060 --> 15:54.060
丰富的写法

15:54.060 --> 15:56.060
首先第一东西非常简单的写法就是

15:56.060 --> 15:58.060
比方说你这个结构里边有哪些字段

15:58.060 --> 16:00.060
你就直接输写就完成了

16:00.060 --> 16:02.060
比方说我们用户里边有哪些字段呢

16:02.060 --> 16:03.060
locking ID

16:03.060 --> 16:04.060
它是一个什么类型呢

16:04.060 --> 16:06.060
它是一个stream类型

16:06.060 --> 16:07.060
就写完了对吧

16:07.060 --> 16:09.060
而且类型的写法呢

16:09.060 --> 16:10.060
还有这种写法

16:10.060 --> 16:11.060
比方说mongos

16:11.060 --> 16:13.060
它里边有一个什么taps

16:13.060 --> 16:15.060
里边一个stream

16:15.060 --> 16:17.060
这点不行

16:17.060 --> 16:19.060
taps里面有一个

16:19.060 --> 16:21.060
有些就是我们除了

16:21.060 --> 16:23.060
js类制的那些类型之外

16:23.060 --> 16:25.060
如果说有些特别的类型

16:25.060 --> 16:26.060
比方说object ID

16:26.060 --> 16:27.060
它在哪儿呢

16:27.060 --> 16:28.060
它在mongos types里边

16:28.060 --> 16:29.060
object ID

16:29.060 --> 16:30.060
它在这儿

16:30.060 --> 16:31.060
没人的意思吧

16:31.060 --> 16:33.060
总之呢我们在这里呢

16:33.060 --> 16:35.060
就可以定义字段以及字段的类型

16:35.060 --> 16:37.060
但是除了类型之外呢

16:37.060 --> 16:39.060
其实我们还是有不少的约束的

16:39.060 --> 16:40.060
还是有不少的约束

16:40.060 --> 16:42.060
比方说我们在这儿

16:42.060 --> 16:43.060
看一下这边

16:43.060 --> 16:44.060
我们在这儿呢

16:44.060 --> 16:45.060
告诉大家

16:45.060 --> 16:46.060
这个地方呢

16:46.060 --> 16:47.060
类型是一个字符串

16:47.060 --> 16:49.060
我们可以在这样子来写

16:49.060 --> 16:50.060
除了直接写个stream

16:50.060 --> 16:51.060
表上的类型之外呢

16:51.060 --> 16:53.060
我们还可以这样子写

16:53.060 --> 16:55.060
把配置为一个对象

16:55.060 --> 16:56.060
对象里边再写一下

16:56.060 --> 16:57.060
具体的配置

16:57.060 --> 16:58.060
类型是什么呢

16:58.060 --> 17:00.060
类型是字符串

17:00.060 --> 17:02.060
这个句话表示什么意思

17:02.060 --> 17:04.060
类型是字符串

17:04.060 --> 17:05.060
然后呢

17:05.060 --> 17:07.060
接下来就是写一些约束了

17:07.060 --> 17:08.060
写什么样的约束呢

17:08.060 --> 17:09.060
我们来看一下

17:09.060 --> 17:11.060
它里边有哪些约束可以写

17:13.060 --> 17:15.060
我们往下面找一找

17:17.820 --> 17:19.820
这里有个地方

17:19.820 --> 17:20.820
这是类型

17:20.820 --> 17:21.820
它支持哪些类型

17:23.820 --> 17:24.820
要找一找

17:25.820 --> 17:27.820
我写的是哪个位置

17:30.970 --> 17:31.970
这里找不到的话

17:31.970 --> 17:32.970
我们来这里找一下

17:33.970 --> 17:34.970
可能性type

17:35.970 --> 17:36.970
就是每一种类型

17:36.970 --> 17:38.970
它有可能会对应一些

17:38.970 --> 17:39.970
全局的配置

17:39.970 --> 17:41.970
以及一些特别的配置

17:41.970 --> 17:42.970
有些配置是

17:42.970 --> 17:43.970
所有类型通用的

17:43.970 --> 17:44.970
有些配置

17:44.970 --> 17:46.970
只有某一些类型才有的

17:47.970 --> 17:48.970
我们找一找

17:52.370 --> 17:53.370
在这

17:53.370 --> 17:55.370
那么就会有这么一些配置

17:55.370 --> 17:56.370
所有类型通用的

17:56.370 --> 17:57.370
都有这么一个配置

17:57.370 --> 17:58.370
我们来看第1个

17:58.370 --> 17:59.370
required

18:00.370 --> 18:01.370
咋意思呢

18:01.370 --> 18:02.370
它告诉你是一个布

18:03.370 --> 18:04.370
那么它表示什么意思

18:04.370 --> 18:05.370
它表示的是

18:05.370 --> 18:06.370
是不是这个字端

18:06.370 --> 18:08.370
是必须要填写的

18:08.370 --> 18:09.370
对吧

18:09.370 --> 18:10.370
是不是有约束

18:10.370 --> 18:11.370
那么这个东西

18:11.370 --> 18:12.370
如果说你设为处

18:12.370 --> 18:13.370
是不是表示必填

18:13.370 --> 18:14.370
如果说你不填

18:14.370 --> 18:16.370
到时候你往数据库里边加的时候

18:16.370 --> 18:17.370
它就会触发这个验证

18:17.370 --> 18:18.370
那就告诉你

18:18.370 --> 18:19.370
肯定要爆错了

18:19.370 --> 18:20.370
它就告诉你

18:20.370 --> 18:21.370
有错误发生了

18:21.370 --> 18:23.370
咱们后边讲真相感啥的时候

18:23.370 --> 18:24.370
就会讲

18:24.370 --> 18:25.370
那么这个东西表示什么意思呢

18:25.370 --> 18:26.370
表示必填

18:26.370 --> 18:27.370
那么我们在

18:27.370 --> 18:28.370
定义这个结构的时候

18:28.370 --> 18:29.370
就把它约束好

18:30.370 --> 18:31.370
由于它是一个字

18:31.370 --> 18:33.370
由于它是一个字符串

18:34.370 --> 18:35.370
由于它是一个字符串

18:35.370 --> 18:36.370
因此呢

18:36.370 --> 18:37.370
它还有一些特别的

18:37.370 --> 18:39.370
比方说

18:39.370 --> 18:41.370
就是当你去

18:41.370 --> 18:43.370
往数据库写数据的时候

18:43.370 --> 18:44.370
针对这个字端的数据

18:44.370 --> 18:46.370
它会自动把它转换成小写

18:46.370 --> 18:47.370
对应的upcase

18:47.370 --> 18:49.370
表示它会自动转换成大写

18:49.370 --> 18:51.370
tune表示的是

18:51.370 --> 18:53.370
比方说我们这里写个tune

18:53.370 --> 18:54.370
表示它意思呢

18:54.370 --> 18:55.370
表示的是

18:55.370 --> 18:59.870
我们到时候往里边加数据的时候

18:59.870 --> 19:01.870
它会自动把local id的守卫空格

19:01.870 --> 19:02.870
给你去掉

19:02.870 --> 19:03.870
就这么意思

19:03.870 --> 19:05.870
marge表示的意思

19:05.870 --> 19:06.870
你可以配置一个政策表达式

19:06.870 --> 19:09.870
它必须要满足这种表达式的要求

19:09.870 --> 19:11.870
minnance和maxnance

19:11.870 --> 19:12.870
它表示的意思呢

19:12.870 --> 19:14.870
minnance

19:14.870 --> 19:16.870
表示的是最小的

19:16.870 --> 19:17.870
最小的就是

19:17.870 --> 19:19.870
字不算长度

19:19.870 --> 19:21.870
比方说我们这里最小的写个6

19:21.870 --> 19:23.870
最大的写一个18

19:23.870 --> 19:25.870
比方写个例子

19:25.870 --> 19:26.870
那么这样子

19:26.870 --> 19:28.870
就配置差不多了

19:28.870 --> 19:29.870
除了它有什么类型之外

19:29.870 --> 19:31.870
还有一些约束

19:31.870 --> 19:33.870
除了这些约束之外

19:33.870 --> 19:35.870
还有两个东西

19:35.870 --> 19:36.870
说一下

19:36.870 --> 19:38.870
一个叫做index

19:38.870 --> 19:39.870
把色为去

19:39.870 --> 19:41.870
这个东西表示什么意思呢

19:41.870 --> 19:42.870
它表示的是

19:42.870 --> 19:45.870
将该字段

19:45.870 --> 19:47.870
设置为锁印

19:47.870 --> 19:48.870
锁印这个东西

19:48.870 --> 19:49.870
我们后边猫故事呢

19:49.870 --> 19:51.870
反正之前已经录完了

19:51.870 --> 19:53.870
这些字就开始补读的

19:53.870 --> 19:54.870
猫故事呢

19:54.870 --> 19:55.870
它里边

19:55.870 --> 19:56.870
猫故db里边

19:56.870 --> 19:57.870
它有锁印这个概念

19:57.870 --> 19:58.870
锁印的

19:58.870 --> 19:59.870
目前我就简单说一下

19:59.870 --> 20:01.870
锁印就是它用来提

20:01.870 --> 20:03.870
提高查询速度的

20:03.870 --> 20:05.870
当你把这个字段

20:05.870 --> 20:07.870
设为锁印之后呢

20:07.870 --> 20:08.870
以后你使用

20:08.870 --> 20:09.870
比方说

20:09.870 --> 20:10.870
以这个字段为条件

20:10.870 --> 20:11.870
比方说

20:11.870 --> 20:13.870
账号

20:13.870 --> 20:14.870
给一个账号

20:14.870 --> 20:15.870
查询一下

20:15.870 --> 20:17.870
这个账号的用户是谁

20:17.870 --> 20:18.870
所以以这个东西为条件

20:18.870 --> 20:19.870
当他有

20:19.870 --> 20:20.870
他会条件

20:20.870 --> 20:22.870
或者是以他进行排序

20:22.870 --> 20:23.870
的时候呢

20:23.870 --> 20:24.870
那么这个时候

20:24.870 --> 20:25.870
如果说你把它

20:25.870 --> 20:26.870
设为锁印

20:26.870 --> 20:27.870
会提高查询效率

20:27.870 --> 20:29.870
去起这么一个作用

20:29.870 --> 20:30.870
其他没有什么作用

20:30.870 --> 20:31.870
跟功能性里面什么关系

20:31.870 --> 20:32.870
我们后面

20:32.870 --> 20:33.870
大家可以来讲

20:33.870 --> 20:35.870
就是把它设置为锁印

20:35.870 --> 20:36.870
好

20:36.870 --> 20:37.870
另外一个呢

20:37.870 --> 20:38.870
锁印它并不是约束

20:38.870 --> 20:40.870
它并不是一个验证

20:40.870 --> 20:41.870
好

20:41.870 --> 20:42.870
那么接下来我们再来看

20:42.870 --> 20:44.870
还有一个配置叫做Ulic

20:44.870 --> 20:45.870
这个玩意是什么呢

20:45.870 --> 20:46.870
这个玩意是一种

20:46.870 --> 20:48.870
特殊属于锁印

20:48.870 --> 20:49.870
叫做

20:49.870 --> 20:51.870
叫做唯一锁印

20:51.870 --> 20:52.870
它也是一种锁印

20:52.870 --> 20:54.870
它有特殊属于唯一锁印

20:54.870 --> 20:56.870
表示这个数据是唯一的

20:56.870 --> 20:57.870
注意哦

20:57.870 --> 20:58.870
它不是验证

20:58.870 --> 21:00.870
这些东西才是验证

21:00.870 --> 21:01.870
这个东西不是验证

21:01.870 --> 21:03.870
因为这些东西的验证是

21:03.870 --> 21:05.870
Mangooz给你搞定的

21:05.870 --> 21:07.870
跟Mangodb没有什么关系

21:07.870 --> 21:08.870
Mangodb验不验证

21:08.870 --> 21:09.870
它不验证

21:09.870 --> 21:11.870
Mangooz才会进行验证

21:11.870 --> 21:12.870
对吧

21:12.870 --> 21:13.870
我们后面会详细的看到

21:13.870 --> 21:14.870
这个过程

21:14.870 --> 21:15.870
我们这里直接看到

21:15.870 --> 21:17.870
只是把这个定义出来

21:17.870 --> 21:18.870
好

21:18.870 --> 21:19.870
那么这是两个锁印

21:19.870 --> 21:21.870
当然这东西只写一个就行了

21:21.870 --> 21:22.870
因为它也是一种

21:22.870 --> 21:23.870
特殊的锁印

21:23.870 --> 21:25.870
所以你写了它就不用写它了

21:25.870 --> 21:27.870
这是locking id

21:27.870 --> 21:28.870
就配置完了

21:28.870 --> 21:29.870
那么接下来我们来看这个要求

21:29.870 --> 21:32.950
locking password

21:32.950 --> 21:33.950
那么一样的道理

21:33.950 --> 21:34.950
对吧

21:34.950 --> 21:38.900
我们把这个复制一下吧

21:38.900 --> 21:39.900
那么它也必填

21:39.900 --> 21:40.900
它是一个字幕创

21:40.900 --> 21:41.900
也是必填的

21:41.900 --> 21:42.900
去掉所谓空格

21:42.900 --> 21:44.900
然后也是6到18位

21:44.900 --> 21:45.900
locking password

21:45.900 --> 21:47.900
是不是写好了

21:47.900 --> 21:48.900
接下来再来

21:48.900 --> 21:49.900
Name

21:49.900 --> 21:50.900
姓名

21:50.900 --> 21:52.900
姓名也是必填的

21:52.900 --> 21:54.900
快手写一下

21:54.900 --> 21:55.900
字幕创

21:55.900 --> 21:56.900
然后必填

21:56.900 --> 21:57.900
去掉所谓空格

21:57.900 --> 21:58.900
最小长度了两位

21:58.900 --> 22:00.900
最大长度了10位

22:00.900 --> 22:01.900
就随便写一下

22:01.900 --> 22:02.900
我有可能

22:02.900 --> 22:03.900
因为这个是补路的

22:03.900 --> 22:04.900
所以说有可能

22:04.900 --> 22:05.900
会跟后面一个和

22:05.900 --> 22:06.900
这些具体的数字对不上

22:06.900 --> 22:08.900
这个都无所谓

22:08.900 --> 22:09.900
这是Name

22:09.900 --> 22:10.900
然后呢

22:12.900 --> 22:13.900
这个玩意儿呢

22:13.900 --> 22:14.900
我们又来吧

22:14.900 --> 22:15.900
这个玩意儿是什么呢

22:15.900 --> 22:16.900
这个玩意儿

22:16.900 --> 22:17.900
它是一个数组

22:17.900 --> 22:18.900
对不对

22:18.900 --> 22:20.900
所以它类型怎么写呢

22:20.900 --> 22:22.900
应该把它写为一个耳对

22:22.900 --> 22:24.900
你是不是应该把它写成一个数组

22:24.900 --> 22:25.900
对不对

22:25.900 --> 22:26.900
好

22:26.900 --> 22:27.900
那么这个数组里边

22:27.900 --> 22:28.900
它有没有约束呢

22:28.900 --> 22:29.900
它上也有约束

22:29.900 --> 22:30.900
所以比方说

22:30.900 --> 22:32.900
首先必须require

22:32.900 --> 22:34.900
require

22:34.900 --> 22:35.900
必须要填

22:35.900 --> 22:37.900
然后我们可以给它一个默认值

22:37.900 --> 22:38.900
default

22:38.900 --> 22:40.900
就是如果说你不填的话

22:40.900 --> 22:42.900
我给你一个默认值

22:42.900 --> 22:43.900
一个空数组

22:43.900 --> 22:45.900
这个表示默认值

22:45.900 --> 22:48.900
为一个空数组

22:48.900 --> 22:52.750
没问题吧

22:52.750 --> 22:53.750
默认值

22:53.750 --> 22:55.750
为一个空数组

22:56.750 --> 22:57.750
好

22:57.750 --> 22:59.750
这里是labs

22:59.750 --> 23:01.750
我们看一下吧

23:01.750 --> 23:02.750
默认值空数组

23:02.750 --> 23:04.750
应该没什么问题

23:04.750 --> 23:06.750
然后呢

23:06.750 --> 23:07.750
刚才我忘了说这个了

23:07.750 --> 23:08.750
login password

23:08.750 --> 23:09.750
login password

23:09.750 --> 23:10.750
我们这里再说一种

23:10.750 --> 23:12.750
一个配置就是select

23:12.750 --> 23:14.750
为force

23:14.750 --> 23:15.750
这是啥意思呢

23:15.750 --> 23:16.750
这个表示

23:16.750 --> 23:17.750
因为它是密码

23:17.750 --> 23:18.750
密码一般来说

23:18.750 --> 23:20.750
是不会作为查询结果的

23:20.750 --> 23:21.750
当我们把select

23:21.750 --> 23:22.750
作为force过后

23:22.750 --> 23:25.750
就是默认情况下

23:25.750 --> 23:26.750
查询时候

23:26.750 --> 23:29.750
查询用故事

23:29.750 --> 23:31.750
不会查询

23:31.750 --> 23:32.750
该制断

23:32.750 --> 23:33.750
默认情况下

23:33.750 --> 23:34.750
你不做偷渡操作

23:34.750 --> 23:36.750
那么它就不会查询这个制断

23:36.750 --> 23:38.750
这是我们是不是有效果

23:38.750 --> 23:39.750
login password

23:39.750 --> 23:41.750
一般来说是不会进入查询的

23:41.750 --> 23:43.750
那么这是

23:43.750 --> 23:44.750
这个就是爱好

23:44.750 --> 23:45.750
爱好默认是一个数组

23:45.750 --> 23:48.750
那么既然爱好这个数组里边

23:48.750 --> 23:50.750
爱好这个数组里边

23:50.750 --> 23:52.750
它不可能随便乱一些

23:52.750 --> 23:56.750
它有可能会写一些

23:56.750 --> 23:58.750
就是有一些东西

23:58.750 --> 23:59.750
它是有约束的

23:59.750 --> 24:01.750
就是数组里边只能装什么

24:01.750 --> 24:02.750
有可能会有约束

24:02.750 --> 24:03.750
那么我们看一下

24:03.750 --> 24:05.750
这种约束怎么来写

24:05.750 --> 24:08.750
找到这个

24:08.750 --> 24:09.750
找到这个约束

24:09.750 --> 24:13.510
我们看一下耳锐

24:13.510 --> 24:14.510
耳锐

24:14.510 --> 24:22.400
找一找

24:22.400 --> 24:26.350
是放哪的呢

24:26.350 --> 24:33.120
看一下耳锐

24:33.120 --> 24:35.120
看一下

24:35.120 --> 24:37.120
明白了

24:37.120 --> 24:38.120
就是说

24:38.120 --> 24:39.120
如果说这个数组里边

24:39.120 --> 24:40.120
因为这个数组

24:40.120 --> 24:41.120
咱们介绍里边的数组

24:41.120 --> 24:43.120
是很灵活的

24:43.120 --> 24:44.120
就是它数组里边

24:44.120 --> 24:46.120
可能会装一些对象

24:46.120 --> 24:49.120
可能会装一些别的东西

24:49.120 --> 24:50.120
那么数组里边

24:50.120 --> 24:51.120
每一项是怎么类型的

24:51.120 --> 24:54.120
也可以对它进一步进行约束

24:54.120 --> 24:55.120
那么怎么来约束呢

24:55.120 --> 24:58.120
你看这个地方写的

24:58.120 --> 25:00.120
它是一个数组

25:00.120 --> 25:01.120
那么我们可以用这种方式

25:01.120 --> 25:03.120
来对它数组进行约束

25:03.120 --> 25:05.120
就是我们这里可以写上一个耳锐

25:05.120 --> 25:06.120
也可以这样子写

25:06.120 --> 25:08.120
进一步对数组进行约束

25:08.120 --> 25:09.120
啥意思呢

25:09.120 --> 25:11.120
就表示这个数组里边

25:11.120 --> 25:13.120
每一项是一个制服串

25:13.120 --> 25:14.120
表示这么一个意思

25:15.120 --> 25:16.120
我还讲了

25:16.120 --> 25:17.120
有多少时间了

25:17.120 --> 25:19.120
讲了不到一周

25:19.120 --> 25:20.120
完了过后一周多一点点

25:20.120 --> 25:22.120
你看这些API我也记不住

25:22.120 --> 25:23.120
所以看着文章来吧

25:23.120 --> 25:24.120
你们忘记了

25:24.120 --> 25:25.120
是非常正常的事情

25:25.120 --> 25:27.120
这里就是表示

25:29.120 --> 25:32.120
类型是一个数组

25:32.120 --> 25:36.120
数组每一项是一个制服串

25:36.120 --> 25:37.120
有这么个意思

25:37.120 --> 25:38.120
好了

25:38.120 --> 25:39.120
这是纳布斯

25:39.120 --> 25:41.120
接下来我们继续

25:41.120 --> 25:43.120
我一下几节的看

25:44.120 --> 25:46.120
下面是一个而对子

25:46.120 --> 25:49.120
表示的是居住地址

25:49.120 --> 25:50.120
用户的居住地址

25:50.120 --> 25:52.120
那么这个居住地址

25:52.120 --> 25:53.120
你看这里

25:53.120 --> 25:54.120
居住地址

25:54.120 --> 25:55.120
我们这里是不是又是一个对象

25:55.120 --> 25:56.120
对不对

25:56.120 --> 25:57.120
所以又是个对象

25:57.120 --> 25:58.120
好

25:58.120 --> 25:59.120
那么如果说这种情况

25:59.120 --> 26:00.120
又怎么来处理呢

26:00.120 --> 26:01.120
就是它是一个对象

26:01.120 --> 26:02.120
而对子

26:04.120 --> 26:05.120
它是一个对象

26:05.120 --> 26:06.120
那么针对这个对象里边

26:06.120 --> 26:08.120
是不是有可能又有属性

26:08.120 --> 26:09.120
对不对

26:09.120 --> 26:10.120
所以有可能又有属性

26:10.120 --> 26:11.120
那么又有属性

26:11.120 --> 26:12.120
这些属性呢

26:12.120 --> 26:13.120
所以又有别墅

26:13.120 --> 26:14.120
这个属性

26:14.120 --> 26:15.120
第一个属性是一个制服串

26:15.120 --> 26:17.120
第二个属性是一个

26:17.120 --> 26:18.120
也是一个制服串

26:18.120 --> 26:20.120
那么这种情况怎么操作呢

26:20.120 --> 26:21.120
很简单

26:21.120 --> 26:23.120
这种情况你可以这样子写

26:23.120 --> 26:24.120
它的类型是什么呢

26:24.120 --> 26:26.120
类型又是一个对象

26:26.120 --> 26:28.120
这个对象里边

26:28.120 --> 26:29.120
第一个属性

26:29.120 --> 26:31.120
是不是Provance

26:31.120 --> 26:32.120
Provance是什么呢

26:32.120 --> 26:34.120
是一个制服串

26:34.120 --> 26:35.120
是一个制服串

26:35.120 --> 26:36.120
Provance可以这样子

26:36.120 --> 26:38.120
继续写别墅

26:38.120 --> 26:39.120
它的类型呢

26:39.120 --> 26:41.120
是一个制服串

26:42.120 --> 26:44.120
然后Required

26:47.120 --> 26:49.120
你可以用这种方式来写

26:51.120 --> 26:52.120
你可以这样子

26:52.120 --> 26:53.120
这种方式来写

26:53.120 --> 26:54.120
那么另外一种方式

26:54.120 --> 26:55.120
而现在你看一下这边

26:55.120 --> 26:56.120
这边的话

26:56.120 --> 26:58.120
这里用户有居住地址

26:58.120 --> 26:59.120
后边还有一个模型

26:59.120 --> 27:00.120
就是用户操作

27:00.120 --> 27:01.120
用户操作呢

27:01.120 --> 27:03.120
它也有用户在哪个地址

27:03.120 --> 27:04.120
进行操作的

27:04.120 --> 27:06.120
比方说用户的注册地址

27:06.120 --> 27:08.120
居住地址呢是成都市

27:08.120 --> 27:10.120
结果用户登陆的时候

27:10.120 --> 27:12.120
登陆在湖南登陆的

27:12.120 --> 27:13.120
是不是有可能会

27:13.120 --> 27:15.120
程序可能会提醒你

27:15.120 --> 27:16.120
异地登陆

27:16.120 --> 27:17.120
那么用户的操作呢

27:17.120 --> 27:19.120
我可能也会进入

27:19.120 --> 27:20.120
做这个操作的时候

27:20.120 --> 27:21.120
在什么地方

27:21.120 --> 27:22.120
那么两个的是不是都是地址

27:22.120 --> 27:23.120
你看两个的结构

27:23.120 --> 27:24.120
是不是一样的

27:24.120 --> 27:25.120
对不对

27:25.120 --> 27:26.120
那么这个呢

27:26.120 --> 27:27.120
我们把它叫做重复结构

27:27.120 --> 27:28.120
或者叫做纸结构

27:28.120 --> 27:29.120
这个时候呢

27:29.120 --> 27:30.120
你可以怎么做呢

27:30.120 --> 27:31.120
你可以这样写

27:31.120 --> 27:32.120
单独来写个结构

27:32.120 --> 27:33.120
我们这里新建个文件

27:33.120 --> 27:35.120
比方说该取个名字叫做

27:36.120 --> 27:37.120
Skeema

27:38.120 --> 27:39.120
单独来写一个东西

27:39.120 --> 27:40.120
那么这个地方

27:40.120 --> 27:41.120
我们来单独来订一个结构

27:41.120 --> 27:42.120
Mongus

27:46.120 --> 27:47.120
那么这边呢

27:47.120 --> 27:49.120
我们写上那个Mongus

27:50.120 --> 27:51.120
Skeema

27:51.120 --> 27:52.120
新建一个

27:52.120 --> 27:53.120
六一个Skeema

27:54.120 --> 27:55.120
然后呢

27:55.120 --> 27:56.120
一个

27:56.120 --> 27:57.120
一个而追死

27:57.120 --> 27:58.120
是不是就是一个结构

27:58.120 --> 27:59.120
对吧一个结构

27:59.120 --> 28:00.120
它里面有两个属性

28:00.120 --> 28:02.120
一个属性的是Province

28:02.120 --> 28:03.120
它的省份

28:03.120 --> 28:04.120
省份是什么呢

28:04.120 --> 28:05.120
省份的那一层

28:05.120 --> 28:06.120
是字幕创

28:07.120 --> 28:08.120
必须要连写

28:08.120 --> 28:09.120
require的

28:09.120 --> 28:10.120
require的

28:10.120 --> 28:11.120
require

28:11.120 --> 28:12.120
然后呢

28:12.120 --> 28:13.120
一个是城市

28:13.120 --> 28:14.120
city

28:14.120 --> 28:15.120
type

28:15.120 --> 28:16.120
为字幕创

28:16.120 --> 28:17.120
然后呢

28:17.120 --> 28:18.120
require的

28:18.120 --> 28:19.120
require的

28:19.120 --> 28:20.120
对吧

28:20.120 --> 28:21.120
这里是不是定义了一个结构

28:21.120 --> 28:22.120
然后呢

28:22.120 --> 28:23.120
我们把这个结构导出

28:25.120 --> 28:27.120
单独来定一个结构

28:27.120 --> 28:28.120
然后有了这个结构过后

28:28.120 --> 28:29.120
这边就可以重复的

28:29.120 --> 28:30.120
去使用这个结构了

28:30.120 --> 28:31.120
没有必要再重新定义了

28:31.120 --> 28:32.120
好那怎么写

28:32.120 --> 28:33.120
我们在这里呢

28:33.120 --> 28:35.560
写上

28:35.560 --> 28:36.560
导入

28:36.560 --> 28:37.560
adress

28:37.560 --> 28:38.560
schema

28:38.560 --> 28:39.560
require

28:40.560 --> 28:41.560
adress

28:41.560 --> 28:42.560
schema

28:42.560 --> 28:43.560
好那么这边呢

28:43.560 --> 28:44.560
我们在它的类型是什么呢

28:44.560 --> 28:45.560
这个地址的类型

28:45.560 --> 28:47.560
就是这个结构

28:48.560 --> 28:49.560
就是这个结构

28:49.560 --> 28:50.560
adress

28:50.560 --> 28:51.560
对吧

28:51.560 --> 28:52.560
把它写成纸结构

28:52.560 --> 28:53.560
然后呢这里

28:53.560 --> 28:54.560
require的

28:55.560 --> 28:56.560
必须要连写

28:57.560 --> 28:58.560
是不是完成了

28:58.560 --> 28:59.560
对不对

28:59.560 --> 29:00.560
就完成了

29:00.560 --> 29:01.560
好那么现在呢

29:01.560 --> 29:02.560
我们用户这里

29:02.560 --> 29:03.560
是不是定义完了

29:03.560 --> 29:05.560
我们再顺便看一下文档

29:05.560 --> 29:06.560
文档里面有没有

29:06.560 --> 29:07.560
还有没有说到的

29:07.560 --> 29:08.560
我们看一下

29:08.560 --> 29:10.560
以后要跟后边的课接上

29:11.560 --> 29:13.560
这是针对之不错的约束

29:14.560 --> 29:15.560
然后这边

29:15.560 --> 29:16.560
我们看一下

29:16.560 --> 29:17.560
如果说你

29:17.560 --> 29:18.560
你是一个数字的话

29:18.560 --> 29:19.560
还有约束对吧

29:19.560 --> 29:20.560
最小的数字

29:20.560 --> 29:21.560
最大的数字

29:21.560 --> 29:23.560
然后呢你是日期的话

29:23.560 --> 29:24.560
还有最小的日期

29:24.560 --> 29:25.560
最大的日期

29:25.560 --> 29:27.560
目前没有这些东西

29:27.560 --> 29:28.560
这是必填

29:28.560 --> 29:29.560
这个表示默认值

29:29.560 --> 29:30.560
这个表示查询的时候

29:30.560 --> 29:32.560
会不会默认

29:32.560 --> 29:34.560
作为查询结果

29:34.560 --> 29:35.560
你把设为forced的话

29:35.560 --> 29:37.560
就不会默认作为查询结果

29:37.560 --> 29:38.560
Validance

29:38.560 --> 29:39.560
它是一个函数

29:39.560 --> 29:41.560
它可以设置自定义验证规则

29:41.560 --> 29:42.560
它可以设置自定义

29:42.560 --> 29:43.560
也可以去这里的

29:43.560 --> 29:44.560
一个例子去看一下

29:45.560 --> 29:47.560
可以在这里去看一下

29:47.560 --> 29:48.560
你点一下

29:48.560 --> 29:49.560
进去看一下就行了

29:49.560 --> 29:50.560
自定义的规则

29:50.560 --> 29:51.560
我们也这里的

29:51.560 --> 29:52.560
用不到

29:52.560 --> 29:53.560
然后呢还有一个就是

29:53.560 --> 29:54.560
还有后边的东西

29:54.560 --> 29:55.560
我们后边还会讲

29:55.560 --> 29:56.560
盖子写出来的东西

29:56.560 --> 29:57.560
我们后边才会讲

29:57.560 --> 29:58.560
好了我们

29:58.560 --> 29:59.560
现在用户的

29:59.560 --> 30:00.560
用户的这个模型

30:00.560 --> 30:01.560
是不是定义好了

30:01.560 --> 30:02.560
对吧用户先定义

30:02.560 --> 30:03.560
一个用户的结构

30:03.560 --> 30:04.560
然后通过这个结构

30:04.560 --> 30:05.560
定义模型

30:05.560 --> 30:06.560
后边呢

30:06.560 --> 30:07.560
我们后续课程中

30:07.560 --> 30:08.560
都要通过这个模型

30:08.560 --> 30:09.560
来对它进行操作

30:09.560 --> 30:10.560
操作用户

30:10.560 --> 30:11.560
那么接下来

30:11.560 --> 30:12.560
还有一个模型

30:12.560 --> 30:13.560
就是用户的操作

30:13.560 --> 30:15.560
叫User operation

30:15.560 --> 30:19.060
或者就叫做 operation

30:19.060 --> 30:23.590
就要解释

30:23.590 --> 30:24.590
那么这边的做法

30:24.590 --> 30:25.590
是一样的

30:26.590 --> 30:27.590
把这个复制一下吧

30:27.590 --> 30:29.590
来稍微改一改

30:29.590 --> 30:30.590
蒙古的导渡性蓝

30:30.590 --> 30:31.590
然后呢

30:31.590 --> 30:32.590
这里边也要用到

30:32.590 --> 30:33.590
Dress schema

30:33.590 --> 30:34.590
也要用到这个导渡性蓝

30:34.590 --> 30:36.590
这个定义的就是

30:36.590 --> 30:38.590
Operation

30:38.590 --> 30:40.590
Operation

30:40.590 --> 30:42.590
它的结构

30:42.590 --> 30:43.590
然后呢

30:43.590 --> 30:44.590
这里的名字改一下

30:44.590 --> 30:48.590
改成Operation

30:48.590 --> 30:50.590
那么这个是个定义的 schema

30:50.590 --> 30:51.590
那它里面有哪些东西呢

30:51.590 --> 30:52.590
一个个来

30:52.590 --> 30:53.590
一个是

30:53.590 --> 30:54.590
首先就是Operation

30:54.590 --> 30:55.590
首先就是这么一个东西

30:55.590 --> 30:56.590
把下面的删掉

30:56.590 --> 30:58.590
一个个来

30:58.590 --> 30:59.590
除了住址

30:59.590 --> 31:00.590
而Dress是一样的

31:00.590 --> 31:01.590
而Dress是一样的

31:01.590 --> 31:02.590
对吧

31:02.590 --> 31:03.590
那么而Dress不变

31:03.590 --> 31:05.590
其他家人们都改一下

31:05.590 --> 31:06.590
第一个参数

31:06.590 --> 31:08.590
第一个就是Operation

31:08.590 --> 31:09.590
表示的是操作内容

31:09.590 --> 31:10.590
你做了什么样的操作

31:10.590 --> 31:12.590
这里也要改一下

31:12.590 --> 31:18.950
这里是Operation

31:18.950 --> 31:21.950
这里是Operation

31:21.950 --> 31:22.950
那么这边

31:22.950 --> 31:23.950
在Index里边

31:23.950 --> 31:26.950
我们也要导出Export

31:26.950 --> 31:28.950
Operation

31:28.950 --> 31:29.950
Require

31:30.950 --> 31:32.950
Operation

31:32.950 --> 31:33.950
那么这边呢

31:33.950 --> 31:35.950
我们回到这来

31:36.950 --> 31:37.950
好了

31:37.950 --> 31:38.950
这里改完了

31:38.950 --> 31:39.950
第一个参数

31:39.950 --> 31:40.950
第一个就是字段

31:40.950 --> 31:41.950
就是表示它的操作类型

31:41.950 --> 31:42.950
操作类型呢

31:42.950 --> 31:43.950
这里是一个登录

31:43.950 --> 31:44.950
对不对

31:44.950 --> 31:45.950
但是我们现在就遇到这么一种情况

31:45.950 --> 31:47.950
它虽然说是一个字母券

31:47.950 --> 31:48.950
但是呢

31:48.950 --> 31:49.950
它并不代表一个字母券

31:49.950 --> 31:50.950
可以属于变形

31:50.950 --> 31:51.950
然后操作类型

31:51.950 --> 31:52.950
我们定义的

31:52.950 --> 31:54.950
只有这么一些会被记录下来

31:54.950 --> 31:55.950
登录

31:55.950 --> 31:56.950
註销

31:56.950 --> 31:57.950
阅读文章

31:57.950 --> 31:58.950
还有什么呢

31:58.950 --> 31:59.950
还有就是

31:59.950 --> 32:01.950
比方说阅读文章

32:01.950 --> 32:04.950
还有添加文章

32:04.950 --> 32:05.950
就等等

32:05.950 --> 32:06.950
像这些操作

32:06.950 --> 32:07.950
我们会被记录下来

32:07.950 --> 32:08.950
其他操作我都不管的

32:08.950 --> 32:09.950
那么也就是说

32:09.950 --> 32:10.950
我一个字母券

32:10.950 --> 32:11.950
它是不是说

32:11.950 --> 32:13.950
扔记的字母券都可以

32:13.950 --> 32:14.950
那这个情况怎么办呢

32:14.950 --> 32:15.950
这种情况

32:15.950 --> 32:16.950
我们可以利用这个约束

32:16.950 --> 32:18.950
首先把它Require的写上

32:18.950 --> 32:20.950
Require的写出

32:20.950 --> 32:22.950
然后我们可以有这么一个操作叫Ener

32:22.950 --> 32:23.950
Ener是什么意思呢

32:23.950 --> 32:24.950
表示每一句

32:24.950 --> 32:26.950
如果说你学过TypeScript的话

32:26.950 --> 32:27.950
那么你应该知道

32:27.950 --> 32:28.950
每句什么意思

32:28.950 --> 32:30.950
就是一些固定的曲子中的一个

32:30.950 --> 32:32.950
你只能在固定的曲子中选一个

32:33.950 --> 32:34.950
那么我们这里的

32:34.950 --> 32:35.950
每句怎么写呢

32:35.950 --> 32:37.950
这里就可以写上一个数组

32:37.950 --> 32:38.950
告诉他

32:38.950 --> 32:40.950
请你从这个数组里边选一个

32:40.950 --> 32:41.950
哪些呢

32:41.950 --> 32:44.950
比方说登陆

32:44.950 --> 32:45.950
注销

32:45.950 --> 32:50.160
你看官方文章

32:50.160 --> 32:53.160
这里有一个

32:53.160 --> 32:54.160
Steam

32:54.160 --> 32:55.160
有个Ener

32:55.160 --> 32:56.160
对吧

32:56.160 --> 32:57.160
有个Ener

32:57.160 --> 32:58.160
就是个数组

32:58.160 --> 32:59.160
你把给他一些纸

32:59.160 --> 33:01.160
他会在这些纸中选一个

33:01.160 --> 33:02.160
就是你添加的时候

33:02.160 --> 33:03.160
如果说你

33:03.160 --> 33:05.160
设置的纸不在这些当中

33:05.160 --> 33:07.160
那么他就会包验证错误

33:07.160 --> 33:09.160
这些东西都是有助于验证的

33:09.160 --> 33:10.160
注销

33:10.160 --> 33:12.160
然后这里比方说阅读文章

33:12.160 --> 33:16.300
我也不知道我之前写了哪些

33:16.300 --> 33:18.300
我就随便写几个

33:18.300 --> 33:19.300
当然我们也可以

33:19.300 --> 33:20.300
比方说像这个东西

33:20.300 --> 33:22.300
如果说你到时候要添加的时候

33:22.300 --> 33:24.300
要在这些纸中选一个

33:24.300 --> 33:25.300
那么也可以呢

33:25.300 --> 33:26.300
把它写成一个数组

33:26.300 --> 33:28.300
把它单个来做一个模块

33:28.300 --> 33:31.300
比方说Operation

33:31.300 --> 33:33.300
我之前好像是写的这个文件

33:33.300 --> 33:34.300
就这个文件

33:34.300 --> 33:36.300
那在这里让我们把它导出

33:36.300 --> 33:37.300
Export

33:37.300 --> 33:39.300
把这个数组导出

33:39.300 --> 33:41.300
这样做的好处在于

33:41.300 --> 33:42.300
将来如果说

33:42.300 --> 33:48.300
你比方说要用户查看

33:48.300 --> 33:49.300
当前哪些操作的时候

33:49.300 --> 33:51.300
让他们选登入操作有哪些

33:51.300 --> 33:52.300
注写要刷出哪些

33:52.300 --> 33:54.300
那么把这个列表给用户的话

33:54.300 --> 33:56.300
那么我们可以出一个单独的模块里面

33:56.300 --> 33:57.300
导出来不需要重复代码

33:57.300 --> 33:59.300
当然我这里也解释不清楚

33:59.300 --> 34:00.300
总之呢

34:00.300 --> 34:02.300
这个东西你写成单独模块也行

34:02.300 --> 34:04.300
不写成单独模块也行

34:04.300 --> 34:05.300
写成单独模块

34:05.300 --> 34:08.300
因为这个数据有可能将来会用到

34:08.300 --> 34:09.300
有可能将来会用到

34:09.300 --> 34:11.300
就是我的职业习惯

34:11.300 --> 34:13.300
我会把它提成一个单独的模块

34:13.300 --> 34:15.300
避免重复代码

34:15.300 --> 34:18.300
然后你现在用口头解释的话

34:18.300 --> 34:20.300
你可能也想不到

34:20.300 --> 34:23.810
也想不到将来什么地方会用的

34:23.810 --> 34:24.810
怎么说呢

34:24.810 --> 34:26.810
比方说你想象一个页面

34:26.810 --> 34:27.810
一面上一个下达列表

34:27.810 --> 34:29.810
下达列表里边让你选择

34:29.810 --> 34:31.810
进行筛选用户的操作

34:32.810 --> 34:33.810
登入操作

34:33.810 --> 34:35.810
最近的登入操作有哪些

34:35.810 --> 34:37.810
最近的助销操作有哪些

34:37.810 --> 34:38.810
是哪个用户发出的

34:38.810 --> 34:39.810
那么一个下达列表

34:39.810 --> 34:41.810
是不是要把一个数组的数据提供给他

34:41.810 --> 34:42.810
对不对

34:42.810 --> 34:43.810
所以说而已

34:43.810 --> 34:44.810
如果职业习惯

34:44.810 --> 34:46.810
把它提成一个单独模块

34:46.810 --> 34:50.440
Operation tax

34:50.440 --> 34:51.440
那么这里是一样的

34:51.440 --> 34:52.440
对不对

34:52.440 --> 34:53.440
直接写过来

34:53.440 --> 34:54.440
Operation

34:54.440 --> 34:55.440
就配置好了

34:55.440 --> 34:56.440
接下来下一个

34:56.440 --> 35:02.380
Tank日期

35:02.380 --> 35:03.380
那么这里呢

35:03.380 --> 35:04.380
内详是什么呢

35:04.380 --> 35:05.380
内详就是

35:06.380 --> 35:07.380
内详就是

35:07.380 --> 35:08.380
日期

35:08.380 --> 35:09.380
然后呢

35:09.380 --> 35:10.380
它有没有默认值呢

35:10.380 --> 35:11.380
默认值我们可以把它

35:11.380 --> 35:12.380
认为是当前时间

35:12.380 --> 35:13.380
当前时间怎么选择没用

35:13.380 --> 35:14.380
对成了

35:15.380 --> 35:16.380
可以用这种方式

35:16.380 --> 35:18.380
这种方式咋意思呢

35:18.380 --> 35:19.380
一看

35:19.380 --> 35:20.380
Null是什么意思

35:20.380 --> 35:21.380
Null是一个

35:21.380 --> 35:22.380
是不是一个函数

35:22.380 --> 35:23.380
所以说这个Default

35:23.380 --> 35:24.380
是不是可以给它

35:24.380 --> 35:25.380
复制为一个函数

35:25.380 --> 35:27.380
这个函数的返回结果

35:28.380 --> 35:29.380
是不是就是默认值

35:29.380 --> 35:30.380
Intel的默认值

35:30.380 --> 35:32.380
是不是还可以这样的写

35:33.380 --> 35:34.380
对不对

35:36.380 --> 35:37.380
没有给它复制的时候呢

35:37.380 --> 35:38.380
我就调用这个函数

35:38.380 --> 35:39.380
把这个函数的返回结果

35:39.380 --> 35:40.380
给它复制

35:40.380 --> 35:41.380
当然你这样子写

35:41.380 --> 35:42.380
跟这样子写是不是一样的

35:42.380 --> 35:43.380
对不对

35:43.380 --> 35:44.380
这样子写是不是

35:44.380 --> 35:45.380
给它一个函数

35:45.380 --> 35:46.380
它倒是会调用这个函数

35:46.380 --> 35:47.380
调用这个函数返回结果

35:47.380 --> 35:48.380
不也是当前时间

35:48.380 --> 35:49.380
对不对

35:50.380 --> 35:51.380
下一个

35:51.380 --> 35:52.380
UserID

35:52.380 --> 35:53.380
用户的ID

35:54.380 --> 35:55.380
用户的ID

35:55.380 --> 35:56.380
它是什么类型呢

35:56.380 --> 35:57.380
我们知道

35:57.380 --> 35:58.380
它这边呢

35:58.380 --> 36:00.380
按照买收购里边的对比的话

36:00.380 --> 36:01.380
应该是一个外件

36:01.380 --> 36:02.380
对不对

36:02.380 --> 36:03.380
应该是一个外件

36:04.380 --> 36:05.380
那么这个地方

36:05.380 --> 36:06.380
UserID

36:06.380 --> 36:07.380
该怎么来处理呢

36:07.380 --> 36:08.380
我们可以使用

36:10.380 --> 36:11.380
首先它的类型是什么呢

36:11.380 --> 36:12.380
类型它一定是

36:12.380 --> 36:13.380
ObjectsID

36:13.380 --> 36:14.380
为什么呢

36:14.380 --> 36:16.380
因为它是外件嘛

36:16.380 --> 36:17.380
用户这边的

36:17.380 --> 36:19.380
用户这边的ID

36:19.380 --> 36:20.380
是不是对应到

36:20.380 --> 36:21.380
这边的UserID

36:22.380 --> 36:23.380
哪个用户做了操作

36:23.380 --> 36:24.380
那么用户这边的ID

36:24.380 --> 36:25.380
我们之前学过

36:25.380 --> 36:26.380
MangoDB

36:26.380 --> 36:27.380
是不是UserID

36:27.380 --> 36:29.380
那么UserID怎么写呢

36:29.380 --> 36:30.380
在这里我们可以使用

36:30.380 --> 36:31.380
MangoS,Tabs

36:31.380 --> 36:32.380
UserID

36:32.380 --> 36:33.380
ObjectsID

36:33.380 --> 36:34.380
你当然你不能直接写

36:34.380 --> 36:35.380
ObjectsID在这

36:35.380 --> 36:36.380
因为它没有这个函数

36:36.380 --> 36:37.380
对不对

36:37.380 --> 36:38.380
这些都是类似的函数

36:38.380 --> 36:39.380
对吧

36:39.380 --> 36:40.380
但是这个东西是没有的

36:40.380 --> 36:42.380
你可以这样子写

36:42.380 --> 36:43.380
然后呢

36:43.380 --> 36:45.380
Require的写出

36:45.380 --> 36:47.380
UserID

36:48.380 --> 36:49.380
接下来下一个

36:49.380 --> 36:50.380
extraInfo

36:50.380 --> 36:51.380
任意对象

36:51.380 --> 36:52.380
就是额外操

36:52.380 --> 36:54.380
就是操作

36:54.380 --> 36:56.380
额外的信息

36:56.380 --> 36:57.380
操作额外的信息

36:57.380 --> 36:58.380
比方说

36:58.380 --> 36:59.380
登录的时候

36:59.380 --> 37:00.380
你有什么

37:00.380 --> 37:01.380
账号密码

37:01.380 --> 37:02.380
对吧

37:02.380 --> 37:03.380
你提供了什么样的账号密码

37:03.380 --> 37:05.380
就这些都是额外的信息

37:05.380 --> 37:06.380
比方说添加文章的时候

37:06.380 --> 37:07.380
添加的文章标准是啥

37:07.380 --> 37:08.380
添加的文章内容是啥

37:08.380 --> 37:09.380
对吧

37:09.380 --> 37:10.380
那操作这个操作的时候

37:10.380 --> 37:11.380
额外的操作信息

37:11.380 --> 37:12.380
那么它的内容是什么呢

37:12.380 --> 37:14.380
它的内容可以是任意内容

37:14.380 --> 37:15.380
任意内容我们可以用

37:15.380 --> 37:16.380
MangoTabs

37:17.380 --> 37:18.380
Tabs

37:18.380 --> 37:19.380
Mixed

37:20.380 --> 37:21.380
Mixed

37:23.380 --> 37:24.380
我看一下

37:24.380 --> 37:28.840
Mixed这个内容

37:28.840 --> 37:29.840
Mixed

37:29.840 --> 37:30.840
看一下

37:30.840 --> 37:32.840
就是一个空对象就可以了

37:32.840 --> 37:33.840
给它写个空对象就可以了

37:35.840 --> 37:36.840
没问题的

37:36.840 --> 37:37.840
Tabs

37:37.840 --> 37:38.840
可以用这个

37:38.840 --> 37:40.840
它是没有智能体式

37:40.840 --> 37:43.410
写对没有

37:43.410 --> 37:45.410
哦是schemaTabs里面的

37:45.410 --> 37:46.410
它是在这

37:47.410 --> 37:49.410
MangoTabs

37:49.410 --> 37:50.410
Mixed

37:50.410 --> 37:52.410
可以是任意内容

37:53.410 --> 37:54.410
任意内容

37:54.410 --> 37:55.410
我再重申一次

37:55.410 --> 37:57.410
有可能跟后边课程里面

37:57.410 --> 37:58.410
因为是补录的

37:58.410 --> 37:59.410
跟后边课程里面

37:59.410 --> 38:00.410
可能这些地方有些对不上

38:00.410 --> 38:01.410
有些对不上

38:02.410 --> 38:03.410
但是没关系

38:03.410 --> 38:04.410
意识是一样

38:05.410 --> 38:06.410
反正每一张

38:06.410 --> 38:08.410
每一节可能它都是

38:08.410 --> 38:10.410
都是一个独立的一个分支

38:11.410 --> 38:12.410
那么这里

38:12.410 --> 38:13.410
它就这个东西

38:13.410 --> 38:14.410
就不用避选了

38:14.410 --> 38:15.410
它可以不填

38:15.410 --> 38:16.410
可以不填

38:16.410 --> 38:17.410
好下一个

38:17.410 --> 38:19.410
下一个就是而坠死的

38:19.410 --> 38:20.410
就没了

38:20.410 --> 38:21.410
好就没了

38:21.410 --> 38:22.410
那么现在是不是

38:22.410 --> 38:23.410
把operation也定义好了

38:23.410 --> 38:24.410
好现在永远定义好了

38:24.410 --> 38:25.410
operation也定义好了

38:25.410 --> 38:26.410
定义好了之后

38:26.410 --> 38:28.410
我们在index里面

38:28.410 --> 38:29.410
到时候就可以整

38:29.410 --> 38:30.410
怎么用呢

38:30.410 --> 38:31.410
就这样子用

38:31.410 --> 38:32.410
比方说

38:33.410 --> 38:34.410
要操作用户

38:34.410 --> 38:36.410
就可以导入这个用户这个模型

38:36.410 --> 38:37.410
要操作

38:37.410 --> 38:38.410
用户操作

38:38.410 --> 38:40.410
就可以导入这个operation这个模型

38:40.410 --> 38:41.410
那么通过这个模型

38:41.410 --> 38:42.410
来进行操作

38:42.410 --> 38:43.410
比方说创建用户

38:43.410 --> 38:44.410
crazy

38:44.410 --> 38:45.410
查到用户用范的

38:45.410 --> 38:46.410
就这么个意思

38:47.410 --> 38:49.410
这就是我们这几个东西

38:49.410 --> 38:50.410
把模型先定义好

38:51.410 --> 38:53.410
保证咱们来运行看一下吧

38:53.410 --> 38:54.410
load index

38:56.410 --> 38:57.410
这里有个警告

38:57.410 --> 38:58.410
这个警告

38:58.410 --> 39:00.410
我当时是在下节课解决的

39:00.410 --> 39:01.410
下节课就可以把这个警告解决

39:01.410 --> 39:02.410
下节课可以解决吧

39:02.410 --> 39:03.410
这个东西其实也很简单

39:03.410 --> 39:04.410
很简单

39:04.410 --> 39:05.410
就是说

39:05.410 --> 39:07.410
以前他在数据户里面

39:07.410 --> 39:09.410
创建索应使用这个函数

39:09.410 --> 39:10.410
在mongodb里面创建索应

39:10.410 --> 39:12.410
使用insure index这个函数

39:13.410 --> 39:15.410
后来mongodb更新到一定版本

39:15.410 --> 39:17.410
过后mongos也会随之更新

39:17.410 --> 39:19.410
mongodb现在创建索应的方式

39:19.410 --> 39:21.410
使用create index

39:21.410 --> 39:23.410
使用换了一个函数了

39:24.410 --> 39:26.410
mongos他不敢轻易地换

39:26.410 --> 39:27.410
为什么呢

39:27.410 --> 39:28.410
他要保持兼容

39:28.410 --> 39:30.410
所以说让你手动设置一下

39:30.410 --> 39:32.410
设置一下这个东西

39:35.410 --> 39:37.410
设置的方式其实很简单

39:37.410 --> 39:38.410
就在这

39:39.410 --> 39:41.410
mongos set

39:41.410 --> 39:43.410
创建链接之前

39:43.410 --> 39:45.410
我们在设置一个全局的

39:45.410 --> 39:46.410
做一个全局的设置

39:46.410 --> 39:47.410
设置这个东西叫

39:47.410 --> 39:49.410
usecreate index

39:49.410 --> 39:50.410
把设为true

39:54.410 --> 39:56.410
你看 这边没有警告了

39:57.410 --> 39:59.410
OK 那么现在完成了

39:59.410 --> 40:01.410
我们来看一下数据库

40:02.410 --> 40:03.410
点击右键

40:03.410 --> 40:05.410
刷新 你看是不是有个天色3了

40:05.410 --> 40:06.410
看了一个信里面

40:06.410 --> 40:08.410
目前只有一个use

40:08.410 --> 40:10.410
目前只有一个use

40:10.410 --> 40:12.410
那么这个operations呢

40:12.410 --> 40:13.410
operations哪来的

40:13.410 --> 40:14.410
operations我们到时候

40:14.410 --> 40:15.410
往里面加数据的时候

40:15.410 --> 40:16.410
它就会出来了

40:16.410 --> 40:18.410
这东西不用着急

40:18.410 --> 40:19.410
也不用管着

40:19.410 --> 40:20.410
为什么只有一个use

40:20.410 --> 40:21.410
为什么use出现

40:21.410 --> 40:22.410
operations没有出现

40:22.410 --> 40:23.410
不用去管这些细节

40:23.410 --> 40:24.410
到时候我们操作的时候

40:24.410 --> 40:26.410
大胆的操作没有任何问题

40:26.410 --> 40:27.410
因为mongodb

40:27.410 --> 40:29.410
这些数据实体

40:29.410 --> 40:30.410
它都是动态的

40:30.410 --> 40:31.410
当数据库是动态的

40:31.410 --> 40:33.410
像集合一次动态的

40:33.410 --> 40:34.410
我们之前也体验过

40:34.410 --> 40:35.410
对不对

40:35.410 --> 40:36.410
尽管没有这个集合

40:36.410 --> 40:37.410
我们往里边加数据

40:37.410 --> 40:38.410
往里边查数据都是没问题的

40:39.410 --> 40:41.410
好了 那么现在这一块就搞定了

40:42.410 --> 40:47.410
数据和结构和模型都搞定了

40:47.410 --> 40:49.410
OK 那么这里可能到这了

40:49.410 --> 40:50.410
我们看一下

40:51.410 --> 40:52.410
应该没有什么问题了

40:52.410 --> 40:53.410
又没有什么问题了

