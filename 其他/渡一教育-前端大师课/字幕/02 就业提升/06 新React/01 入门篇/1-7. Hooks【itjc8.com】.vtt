WEBVTT

00:00.110 --> 00:06.110
OK,从这节课开始,我们就正式进入到这个hooks

00:06.110 --> 00:10.110
也就是说这节课之后,你把这节课听完之后

00:10.110 --> 00:14.110
我们的这个,你以后的话就彻底告别内组件了

00:14.110 --> 00:18.110
我们就不会再写内组件了,全部都是函数组件

00:18.110 --> 00:21.110
然后会大量的使用这个hooks

00:21.110 --> 00:25.110
OK,我们来看一下这节课要讲的一些东西

00:25.110 --> 00:28.110
这节课的话,首先分为这三个点

00:28.110 --> 00:32.110
现在的话会对这个hooks做一个基本的这个介绍

00:32.110 --> 00:36.110
然后接下来会给大家介绍两个最重要的hook

00:36.110 --> 00:40.110
一个是useState,一个是useEffect

00:40.110 --> 00:44.110
这两个的话是react内置的这个hook

00:44.110 --> 00:48.110
当然整个react的话,它内置的hook非常多

00:48.110 --> 00:52.110
而且随着这个版本的更新,它加入的这个hook

00:52.110 --> 00:54.110
会越来越多

00:54.110 --> 00:57.110
当我们这边的话,我们作为入门篇

00:57.110 --> 01:00.110
我们就把这两个介绍了,就OK了

01:00.110 --> 01:04.110
这两个介绍了之后,这样我们就可以做一些东西出来了

01:04.110 --> 01:06.110
至于就是后面的一些hook

01:06.110 --> 01:09.110
后面的一些hook的话,其实你是有能力自己看的

01:09.110 --> 01:13.110
如果你就是对某一些hook存在这个疑问

01:13.110 --> 01:16.110
到时候我在这个就业篇

01:16.110 --> 01:20.110
就业篇的时候,我会把这部分剩下的一些hook

01:20.110 --> 01:22.110
给大家就是再过一下

01:22.110 --> 01:26.110
入门篇的话,咱们这边节约时间,咱们就不说那么多了

01:26.110 --> 01:29.110
OK,其实主要掌握这两个hook

01:29.110 --> 01:32.110
很多场景下就够这个够用的

01:32.110 --> 01:36.110
OK,但后面的话还是有一些就是常用的hook

01:36.110 --> 01:39.110
比如什么useMemo,useCallback,这些

01:39.110 --> 01:42.110
这些的话我不再入门篇介绍了

01:42.110 --> 01:45.110
还有一个就是关于这个自定义hook

01:45.110 --> 01:48.110
它除了这个官方它内置了一些hook以外

01:48.110 --> 01:51.110
它允许我们来自定义这个hook

01:51.110 --> 01:53.110
这个到时候我们也看一下

01:53.110 --> 01:56.110
OK,我们一个一个来吧

01:56.110 --> 01:59.110
首先是关于hook的介绍

01:59.110 --> 02:05.110
hook的话是react16.8新增的这个特性

02:05.110 --> 02:08.110
它最大的特点是什么呢?

02:08.110 --> 02:10.110
最大的特点是就这边

02:10.110 --> 02:13.110
它可以让你在不编写class情况下

02:13.110 --> 02:18.110
使用state以及其他的react特性

02:18.110 --> 02:20.110
这个其实是官网的介绍

02:20.110 --> 02:22.110
我是把它拿过来的,在这边

02:22.110 --> 02:26.110
它可以让你在不编写class情况下使用state

02:26.110 --> 02:29.110
以及其他的react特性

02:29.110 --> 02:31.110
这个的话其实最早指的是什么呢?

02:31.110 --> 02:33.110
指的就是这个useState

02:33.110 --> 02:35.110
因为最早的话它这个hook刚出来的时候

02:35.110 --> 02:37.110
内置的hook只有几个

02:37.110 --> 02:40.110
那最要眼的就是这个useState

02:40.110 --> 02:42.110
但现在的话这个hook就越来越多了

02:42.110 --> 02:44.110
OK,你这边你可以看一下它的这个

02:44.110 --> 02:47.110
hook的这个API索引

02:47.110 --> 02:49.110
现在就越来越多了,看到没有

02:49.110 --> 02:51.110
还在不停的增加

02:51.110 --> 02:55.110
OK,回到我们这边

02:55.110 --> 02:58.110
好,然后这里

02:58.110 --> 03:01.110
那为什么它这边要新增这个hook呢?

03:01.110 --> 03:05.110
它这边实际上是为了解决那么一些问题

03:05.110 --> 03:06.110
哪些问题?

03:06.110 --> 03:08.110
我这边罗列了这么几点

03:08.110 --> 03:09.110
这么几点的话

03:09.110 --> 03:12.110
其实也是它官网这边写的有的

03:12.110 --> 03:13.110
这边有个视频

03:13.110 --> 03:16.110
大家如果有那个大了梯子的话

03:16.110 --> 03:18.110
可以看一下这个视频

03:18.110 --> 03:20.110
这个视频呢,这个是单身

03:20.110 --> 03:21.110
我们人称单身

03:21.110 --> 03:23.110
人长的又帅

03:23.110 --> 03:25.110
长的又帅,技术又好

03:25.110 --> 03:31.110
它就是当年在19年还是20年的时候

03:31.110 --> 03:33.110
它当时就是

03:33.110 --> 03:36.110
我之前不是给大家介绍react.conf吗?

03:36.110 --> 03:37.110
19

03:37.110 --> 03:38.110
看到没有,这里

03:38.110 --> 03:40.110
react.conf 2019

03:40.110 --> 03:43.110
它当时的话就是作为一个

03:43.110 --> 03:44.110
演讲者

03:44.110 --> 03:49.110
给各个开发者介绍hooks

03:49.110 --> 03:50.110
大家可以看一下

03:50.110 --> 03:52.110
单身真的长得确实也帅

03:52.110 --> 03:53.110
又帅,技术又好

03:53.110 --> 03:55.110
它已经是我的新的偶像了

03:55.110 --> 03:57.110
OK

03:57.110 --> 03:59.110
这边是在2018是吧?

03:59.110 --> 04:01.110
这里写的,2018年

04:01.110 --> 04:03.110
2018的时候

04:03.110 --> 04:04.110
就这个

04:04.110 --> 04:07.110
它的话也是reducts的作者

04:07.110 --> 04:09.110
reducts作者也是它

04:09.110 --> 04:13.110
OK,后来的话它加入了react.conf团队

04:13.110 --> 04:15.110
现在是react

04:15.110 --> 04:19.110
就是核心开发组里面的一个成员

04:19.110 --> 04:20.110
OK

04:20.110 --> 04:23.110
它官方其实这边的话也介绍了一些

04:23.110 --> 04:24.110
就是这个动机

04:24.110 --> 04:26.110
就你看这一小节

04:26.110 --> 04:27.110
它这边其实介绍了点

04:27.110 --> 04:30.110
主见直接附用状态,逻辑很难

04:30.110 --> 04:32.110
复杂主见变得难以理解

04:32.110 --> 04:34.110
然后难以理解的class

04:34.110 --> 04:37.110
我看介绍了几点,介绍了三点

04:37.110 --> 04:39.110
来我们这边我们来看一下

04:39.110 --> 04:41.110
我这边的话挪劣了这么几点

04:41.110 --> 04:42.110
首先第一个就是

04:42.110 --> 04:45.110
告别令人疑惑的生命周期

04:45.110 --> 04:48.110
生命周期我们是不是上几个介绍过

04:48.110 --> 04:50.110
对吧,给大家介绍了

04:50.110 --> 04:51.110
生命周期的话

04:51.110 --> 04:53.110
之前大家在学习view的时候

04:53.110 --> 04:55.110
用的就是生命周期

04:55.110 --> 04:57.110
所以在这个学习react的时候

04:57.110 --> 04:59.110
生命周期的话对于你来讲

04:59.110 --> 05:01.110
其实这个东西并不是新东西

05:01.110 --> 05:03.110
你可以很快的就是吸收的

05:03.110 --> 05:05.110
那为什么这边说

05:05.110 --> 05:07.110
令人疑惑的生命周期呢

05:07.110 --> 05:09.110
它这个其实它官方举了个例子

05:09.110 --> 05:11.110
我觉得这个例子举的还可以

05:11.110 --> 05:14.110
它这个例子是在

05:14.110 --> 05:16.110
这边使用effect hook

05:16.110 --> 05:18.110
effect code我这边打开了的

05:18.110 --> 05:21.110
就在这,就在这,看到没有

05:21.110 --> 05:23.110
就你这边的话

05:23.110 --> 05:26.110
你如果使用生命周期

05:26.110 --> 05:28.110
你可能存在一种情况

05:28.110 --> 05:30.110
什么情况呢

05:30.110 --> 05:32.110
就可能的话你可能会涉及到

05:32.110 --> 05:34.110
就是两个不同的生命周期

05:34.110 --> 05:37.110
会书写相同的这个代码

05:37.110 --> 05:39.110
好,来我们这边我们来试一下

05:39.110 --> 05:41.110
我们来到这边

05:44.110 --> 05:47.110
好,我们这边的话把这些都干掉

05:47.110 --> 05:49.110
把这些都干掉

05:49.110 --> 05:51.110
然后接下来的话

05:51.110 --> 05:54.110
这边就是上级口的代码

05:54.110 --> 05:56.110
现在是一个干干净净的

05:56.110 --> 05:59.110
对吧,干干净净的这个app主键

05:59.110 --> 06:01.110
然后接下来的话

06:01.110 --> 06:03.110
我就直接把这个拿过来了

06:04.110 --> 06:05.110
直接拿过来了

06:05.110 --> 06:08.110
好,它这边的话是你点击了多少次

06:08.110 --> 06:12.490
所以你这边的话在这个constructor里面

06:12.490 --> 06:14.490
这边没有pops

06:14.490 --> 06:16.490
好,这边的话super

06:16.490 --> 06:19.490
好,接下来的话你这边需要写一个

06:19.490 --> 06:21.490
this.stat

06:21.490 --> 06:23.490
等于一个,你这边有个Count

06:23.490 --> 06:25.490
Count对应的是1

06:25.490 --> 06:27.490
ok,这撬的正式也不要了

06:27.490 --> 06:30.490
好,然后在这边你点击了多少次

06:30.490 --> 06:31.490
对吧,然后有个button

06:31.490 --> 06:34.490
button的话每次就是让这个Count加1

06:34.490 --> 06:36.490
这个的话很好理解,是吧

06:36.490 --> 06:38.490
我们这边我们来看一下

06:38.490 --> 06:41.490
ok,这边的话就是你点击了一次

06:41.490 --> 06:43.490
这边两次,三次,四次

06:43.490 --> 06:47.490
对吧,这个就是其实就是一个技术器

06:47.490 --> 06:48.490
这个没问题

06:48.490 --> 06:50.490
好,接下来的话它要做一件事情

06:50.490 --> 06:51.490
什么事情呢

06:51.490 --> 06:55.490
它期望就是修改这个标题

06:55.490 --> 06:58.490
就是你除了这边显示以外

06:58.490 --> 07:01.490
这个标题,我也期望就是这个标题

07:01.490 --> 07:04.490
显示你点击了多少次

07:04.490 --> 07:07.490
这边的话,自然而然就会涉及到在哪进行操作

07:07.490 --> 07:10.490
这个很明显是不是涉及到这个动物的操作

07:10.490 --> 07:13.490
对吧,让我们放在这个生命周期里面

07:13.490 --> 07:16.490
那生命周期里面,我们这边的话放哪个合适呢

07:16.490 --> 07:19.490
你看一下,它这边的话

07:19.490 --> 07:21.490
这边最好是一个什么

07:21.490 --> 07:23.490
did update, command

07:23.490 --> 07:26.490
component did update

07:26.490 --> 07:29.490
这个的话是不是在每次更新的时候

07:29.490 --> 07:31.490
会执行这个勾字函数

07:31.490 --> 07:33.490
对吧,执行这个勾字函数

07:33.490 --> 07:35.490
现在我们这边就直接修改

07:35.490 --> 07:38.490
document.title

07:38.490 --> 07:40.490
等于一个

07:40.490 --> 07:42.490
就是你点击了

07:42.490 --> 07:45.490
你点击了

07:45.490 --> 07:47.490
这边

07:47.490 --> 07:49.490
downer

07:49.490 --> 07:54.490
this.stat.account

07:54.490 --> 07:58.380
然后吃

07:58.380 --> 08:00.380
保存一下

08:00.380 --> 08:02.380
保存了之后,然后再来看一下刷新

08:02.380 --> 08:04.380
刷新之后,然后接下来的话

08:04.380 --> 08:06.380
我这边点击

08:06.380 --> 08:09.380
这边上,重新来,这边点击

08:09.380 --> 08:11.380
你看,你点击了两次

08:11.380 --> 08:14.380
你点击了三次,点击了四次

08:14.380 --> 08:17.380
这边的话是达到了我们想要的这个目的

08:17.380 --> 08:19.380
对不对,这点没问题

08:19.380 --> 08:21.380
但是我想要什么呢,我期望的效果是

08:21.380 --> 08:24.380
我一开始这边就是你点击了

08:24.380 --> 08:26.380
这边我们应该是从零开始

08:26.380 --> 08:28.380
从零开始

08:28.380 --> 08:30.380
也就是说这边的话一开始就是

08:30.380 --> 08:32.380
你点击了多少次

08:32.380 --> 08:34.380
那咋办呢

08:34.380 --> 08:36.380
咋办呢,我们这个update它是什么

08:36.380 --> 08:38.380
是你至少要更新一次之后

08:38.380 --> 08:40.380
对不对,你要更新一次之后

08:40.380 --> 08:42.380
你现在点击的话,你看这边

08:42.380 --> 08:44.380
它是要更新一次之后,这边才变的

08:44.380 --> 08:46.380
那咋办,那你这边自然而然

08:46.380 --> 08:48.380
你这边又会设计到一个

08:48.380 --> 08:50.380
component

08:50.380 --> 08:52.380
document

08:52.380 --> 08:54.380
这个是不是也是我们上级课介绍过的

08:54.380 --> 08:56.380
这个是在什么

08:56.380 --> 08:58.380
是在这个挂载之后

08:58.380 --> 09:00.380
对不对,它要做的事情是什么

09:00.380 --> 09:02.380
做的事情是不是也是这个

09:04.380 --> 09:06.380
对吧,好,来我们来看一下

09:06.380 --> 09:08.380
先看一下效果能不能实现

09:08.380 --> 09:10.380
效果能够实现了

09:10.380 --> 09:12.380
这边的话你点击了零次

09:12.380 --> 09:14.380
一开始这边就改变了

09:14.380 --> 09:16.380
对吧,然后接下来这边

09:16.380 --> 09:18.380
一次,两次

09:18.380 --> 09:20.380
同步的

09:20.380 --> 09:22.380
你看这个代码

09:22.380 --> 09:24.380
你看这个代码的话你就会发现

09:24.380 --> 09:26.380
是不是已经出现问题了

09:26.380 --> 09:28.380
什么问题

09:28.380 --> 09:30.380
是我们这边完全是相同的逻辑

09:30.380 --> 09:32.380
对不对,完全是相同的逻辑

09:32.380 --> 09:34.380
但是在不同的生命周期

09:34.380 --> 09:36.380
这个勾字函数里面

09:36.380 --> 09:38.380
输写了两份

09:38.380 --> 09:40.380
两份的话又是一模一样的

09:40.380 --> 09:42.380
我们这边还是一个简单的例子

09:42.380 --> 09:44.380
那倘若的话

09:44.380 --> 09:46.380
你这边如果是一个业务逻辑

09:46.380 --> 09:48.380
比较复杂的,那是不是意味着你这个

09:48.380 --> 09:50.380
就是大量的代码

09:50.380 --> 09:52.380
是不是需要重复再写一番

09:52.380 --> 09:54.380
对不对,你看这个就是以前

09:54.380 --> 09:58.380
生命周期它会存在的一个问题

09:58.380 --> 10:00.380
我们把它放到这里

10:00.380 --> 10:02.380
放到这边

10:02.380 --> 10:06.580
react

10:06.580 --> 10:08.580
OK,这里

10:08.580 --> 10:10.580
我们在这边说一下

10:10.580 --> 10:12.580
例如下面的例子

10:12.580 --> 10:16.580
例如下面的例子

10:16.580 --> 10:18.580
相同的代码

10:18.580 --> 10:22.580
在不同的生命周期中

10:22.580 --> 10:24.580
存在了两份

10:24.580 --> 10:26.580
OK,那倘若我这个业务逻辑

10:26.580 --> 10:28.580
更复杂一点

10:28.580 --> 10:30.580
那你是不是会有大量这个

10:30.580 --> 10:32.580
就大断大断重复的代码

10:32.580 --> 10:34.580
对吧,你这样子肯定是不好的

10:34.580 --> 10:36.580
OK

10:36.580 --> 10:38.580
好,然后接下来的话,下一个

10:38.580 --> 10:40.580
下一个就是告别类组建中

10:40.580 --> 10:46.580
凡人的这个Z

10:46.580 --> 10:48.580
你看,这个Z是我们之前在讲的时候

10:48.580 --> 10:50.580
我们说过,是不是只有类组建

10:50.580 --> 10:52.580
才会涉及到Z

10:52.580 --> 10:54.580
韩苏组建有没有Z

10:54.580 --> 10:56.580
韩苏组建是不是不存在Z

10:56.580 --> 10:58.580
对不对,只有类组建才存在Z

10:58.580 --> 11:00.580
那类组建里面的Z的话

11:00.580 --> 11:04.580
往往会存在一个问题

11:04.580 --> 11:06.580
我们需要解决的,就是什么

11:06.580 --> 11:08.580
是不是Z的指向,对不对

11:08.580 --> 11:12.580
在类组建中

11:12.580 --> 11:16.580
会存在什么

11:16.580 --> 11:20.580
Z的指向问题

11:20.580 --> 11:22.580
对吧,你看我们前面那个

11:22.580 --> 11:24.580
绑定事件,例如

11:24.580 --> 11:28.580
在世界处理韩苏中

11:28.580 --> 11:32.580
不能直接

11:32.580 --> 11:34.580
通过什么,通过Z

11:34.580 --> 11:36.580
获取

11:36.580 --> 11:40.580
获取主建实力

11:40.580 --> 11:48.580
需要修正Z指向

11:48.580 --> 11:50.580
我们前面在讲事件的时候

11:50.580 --> 11:52.580
是不是说过,对吧

11:52.580 --> 11:54.580
而且好几种方式

11:54.580 --> 11:56.580
你要么就把事件处理韩苏

11:56.580 --> 11:58.580
改成建筒韩苏

11:58.580 --> 12:00.580
要么绑定的时候改成建筒韩苏

12:00.580 --> 12:02.580
要么就是在constructor里面

12:02.580 --> 12:04.580
一开始通过办的

12:04.580 --> 12:06.580
绑定Z的指向

12:06.580 --> 12:08.580
对不对,那这边你就可以

12:08.580 --> 12:10.580
还有什么呢

12:10.580 --> 12:12.580
还有就是告别繁重的类组建

12:12.580 --> 12:14.580
为什么这么说

12:14.580 --> 12:16.580
为什么说这个类组建繁重

12:16.580 --> 12:18.580
你看这边

12:18.580 --> 12:22.580
我们在声明一个类组建的时候

12:22.580 --> 12:24.580
我们这边是干嘛

12:24.580 --> 12:26.580
我们这边是不是去继承了的

12:26.580 --> 12:30.580
继承谁,是不是继承react.component

12:30.580 --> 12:32.580
你能不能不继承啊

12:32.580 --> 12:34.580
能不能不继承

12:34.580 --> 12:36.580
OK,你不继承的话

12:36.580 --> 12:38.580
这就爆错了

12:38.580 --> 12:40.580
对不对

12:40.580 --> 12:42.580
有人说你这边是super嘛

12:42.580 --> 12:44.580
你这边不用这个super呢

12:44.580 --> 12:46.580
不用super

12:46.580 --> 12:48.580
你看,仍然是不是

12:48.580 --> 12:50.580
这边让你检查

12:50.580 --> 12:52.580
他肯定是有错误的

12:52.580 --> 12:54.580
OK,他就是你的类组建的话

12:54.580 --> 12:56.580
他要求你必须要去干嘛

12:56.580 --> 12:58.580
看到没有,这边

12:58.580 --> 13:00.580
but talent extend

13:00.580 --> 13:02.580
react.component

13:02.580 --> 13:04.580
你没有去继承这个类

13:04.580 --> 13:06.580
OK,所以你这边让他要求干嘛呢

13:06.580 --> 13:08.580
所以你必须要去继承

13:08.580 --> 13:10.580
继承的话,这边就意味着什么

13:10.580 --> 13:12.580
是不是你会有很多多余的东西

13:12.580 --> 13:14.580
对吧,只要学过这个面向对象

13:14.580 --> 13:16.580
编程的同学都知道

13:16.580 --> 13:18.580
继承的话,是一把

13:18.580 --> 13:20.580
什么呢

13:20.580 --> 13:22.580
双面刃

13:22.580 --> 13:24.580
对不对,你这边的话

13:24.580 --> 13:26.580
它有好处

13:26.580 --> 13:28.580
好处的话,就是你通过继承-

13:28.580 --> 13:30.580
那-上面有的这些东西

13:30.580 --> 13:32.580
你也就有了

13:32.580 --> 13:34.580
但是呢,它同时的话

13:34.580 --> 13:36.580
也会有,就是它的缺点

13:36.580 --> 13:38.580
缺点就是什么

13:38.580 --> 13:40.580
缺点的话,就是比如说

13:40.580 --> 13:42.580
你只想用负累上面的一个方法

13:42.580 --> 13:44.580
但是呢,你因为继承了负累

13:44.580 --> 13:46.580
那负累上面的所有东西

13:46.580 --> 13:48.580
你就都有了

13:48.580 --> 13:50.580
这个我们就称之为

13:50.580 --> 13:52.580
典型的这个

13:52.580 --> 13:54.580
大星星和香蕉的问题

13:54.580 --> 13:56.580
你本来的话,你只是想

13:56.580 --> 13:58.580
获取一根香蕉

13:58.580 --> 14:00.580
对吧,只是想一根香蕉

14:00.580 --> 14:02.580
结果你通过继承

14:02.580 --> 14:04.580
你获取了什么呢

14:04.580 --> 14:06.580
获取了一片森林

14:06.580 --> 14:08.580
以及一堆大星星

14:08.580 --> 14:10.580
这个是老外开的一个笑话

14:10.580 --> 14:12.580
老外很喜欢做这些比喻

14:12.580 --> 14:14.580
但想想,确实是这个道理

14:14.580 --> 14:16.580
确实是这个道理

14:16.580 --> 14:18.580
所以你这个内祖先

14:18.580 --> 14:20.580
它其实是比较繁重的

14:20.580 --> 14:22.580
它是一把双刃剪

14:22.580 --> 14:24.580
OK,那你的这个

14:24.580 --> 14:26.580
寒树祖先是不是就很干净了

14:26.580 --> 14:28.580
对不对,你寒树祖先

14:28.580 --> 14:30.580
这个寒树也不需要去继承谁

14:30.580 --> 14:32.580
不需要去继承

14:32.580 --> 14:34.580
而且其实对于咱们

14:34.580 --> 14:36.580
前端开发者

14:36.580 --> 14:38.580
这边刷信一下

14:38.580 --> 14:40.580
这边没保存

14:40.580 --> 14:42.580
其实对于咱们这个

14:42.580 --> 14:44.580
前端开发人员来讲

14:44.580 --> 14:46.580
咱们其实更加熟悉的还是什么呢

14:46.580 --> 14:48.580
还是寒树

14:48.580 --> 14:50.580
其实对于前端开发人员来讲的话

14:50.580 --> 14:52.580
其实这个整个面向对象的这种

14:52.580 --> 14:54.580
编程使用这个

14:54.580 --> 14:56.580
面向对象的方式,其实用的是比较少的

14:56.580 --> 14:58.580
一般后端的开发人员

14:58.580 --> 15:00.580
使用这个面向对象

15:00.580 --> 15:02.580
用的要多一些,前端的话因为最早

15:02.580 --> 15:04.580
这个其实又是和这个历史有关系了

15:04.580 --> 15:06.580
因为最早咱们的

15:06.580 --> 15:08.580
前端开发人员就是干嘛

15:08.580 --> 15:10.580
是不是就是写一些动态的效果

15:10.580 --> 15:12.580
对不对,所以不会

15:12.580 --> 15:14.580
涉及到什么面向对象的编程

15:14.580 --> 15:16.580
所以前端开发人员的话

15:16.580 --> 15:18.580
你去看,百分之七八十的

15:18.580 --> 15:20.580
前端人员其实都更加熟悉这个寒树

15:20.580 --> 15:22.580
你让他用什么面向对象

15:22.580 --> 15:24.580
写个内啊之类的

15:24.580 --> 15:26.580
写个什么静态方法之类的

15:26.580 --> 15:28.580
他其实是比较陌生的

15:28.580 --> 15:30.580
比较陌生的

15:30.580 --> 15:32.580
这是我罗列的这边

15:32.580 --> 15:34.580
这么这个三点

15:34.580 --> 15:36.580
但是你这边的话

15:36.580 --> 15:38.580
你可以把这个官网

15:38.580 --> 15:40.580
官网这边的话你也把它看一下

15:40.580 --> 15:42.580
官网他这边也罗列了

15:42.580 --> 15:44.580
首先在组建之间

15:44.580 --> 15:46.580
附用状态逻辑很难

15:48.580 --> 15:50.580
你如果是内组建的话

15:50.580 --> 15:52.580
你是不太方便

15:52.580 --> 15:54.580
去附用某个这个逻辑的

15:54.580 --> 15:56.580
所以为什么你看这个view3

15:56.580 --> 15:58.580
view3的话你看

15:58.580 --> 16:00.580
它其实基本也是改成了react hook的方式

16:00.580 --> 16:02.580
对不对,为什么

16:02.580 --> 16:04.580
因为它以前它的那种

16:04.580 --> 16:06.580
它那个叫什么,Option API

16:06.580 --> 16:08.580
它Option API的话

16:08.580 --> 16:10.580
它是比较难以附用这个逻辑的

16:10.580 --> 16:12.580
它Option API

16:12.580 --> 16:14.580
它如果想要附用,比如我有个组建

16:14.580 --> 16:16.580
组建里面有一段逻辑

16:16.580 --> 16:18.580
我想要就是在其他组建里面进行附用

16:18.580 --> 16:20.580
那咋办,它以前的话得通过这个mix in

16:20.580 --> 16:22.580
对不对

16:22.580 --> 16:24.580
所以说你看它到了view3

16:24.580 --> 16:26.580
之后它就改成了什么

16:26.580 --> 16:28.580
改成了composition API

16:28.580 --> 16:30.580
composition API里面

16:30.580 --> 16:32.580
最大的特点就是什么

16:32.580 --> 16:34.580
是不是一个一个函数

16:34.580 --> 16:36.580
我这样子是不是就很方便这个进行附用了

16:36.580 --> 16:38.580
对吧,但我不知道

16:38.580 --> 16:40.580
大家学这个view3秒

16:40.580 --> 16:42.580
但你view2你是学了的

16:42.580 --> 16:44.580
你仔细回忆一下你这个学view2的时候

16:44.580 --> 16:46.580
view2里面

16:46.580 --> 16:48.580
我们方法里面是不是都是

16:48.580 --> 16:50.580
那是不是都写在message里面

16:50.580 --> 16:52.580
对不对,你写在message里面

16:52.580 --> 16:54.580
你要拿给其他组建用

16:54.580 --> 16:56.580
其实是比较困难的

16:56.580 --> 16:58.580
那这边的话react早期也存在这个问题

16:58.580 --> 17:00.580
因为早期的话都是内组建

17:00.580 --> 17:02.580
内组建的话你想要

17:02.580 --> 17:04.580
附用这个状态逻辑

17:04.580 --> 17:06.580
它其实是比较困难的

17:06.580 --> 17:08.580
你早期的话你可以通过什么呢

17:08.580 --> 17:10.580
可以通过render props和

17:10.580 --> 17:12.580
高階组建

17:12.580 --> 17:14.580
这个是属于这个高级指引这个地方

17:14.580 --> 17:16.580
在这个地方

17:16.580 --> 17:18.580
这个render props这里

17:18.580 --> 17:20.580
还有这个高階组建

17:20.580 --> 17:22.580
高階组建

17:22.580 --> 17:24.580
高階组建在哪里

17:24.580 --> 17:26.580
反正也是

17:26.580 --> 17:28.580
高階组建

17:28.580 --> 17:30.580
它是属于这个高级指引这一块

17:30.580 --> 17:32.580
这一块我们在就业片

17:32.580 --> 17:34.580
我们再来介绍

17:34.580 --> 17:36.580
你早期的话你虽然可以通过

17:36.580 --> 17:38.580
这种方式

17:38.580 --> 17:40.580
但是它会很麻烦

17:40.580 --> 17:42.580
而且让你的代码难以理解

17:42.580 --> 17:44.580
第二个就是

17:44.580 --> 17:46.580
杀组建变得难以理解

17:46.580 --> 17:48.580
这个其实就是刚才我们说的那个问题

17:48.580 --> 17:50.580
看到没有

17:50.580 --> 17:52.580
就这边完全不相干的代码

17:52.580 --> 17:54.580
在同一个方法中组合在一起

17:54.580 --> 17:56.580
这个是一个

17:56.580 --> 17:58.580
这个是一个点

17:58.580 --> 18:00.580
就可能我这边的话比如说像我们刚才

18:00.580 --> 18:01.580
刚才我们这边

18:01.580 --> 18:03.580
component d的mount

18:03.580 --> 18:05.580
这是不挂载之后

18:05.580 --> 18:07.580
挂载之后我们要做的事情可能不只这一件事情

18:07.580 --> 18:09.580
可能有好几件事情

18:09.580 --> 18:11.580
好几件事情我们全部揉在哪里呢

18:11.580 --> 18:13.580
全部揉在

18:13.580 --> 18:15.580
就是这个勾字函数里面

18:15.580 --> 18:17.580
ok

18:17.580 --> 18:19.580
那你之后学了hooks之后你可以把分开

18:19.580 --> 18:21.580
可以一键一键把它分开

18:21.580 --> 18:23.580
我们后面说UserEffect

18:23.580 --> 18:25.580
我们再说

18:25.580 --> 18:27.580
还有就是我们这边

18:27.580 --> 18:29.580
就刚才说的那个问题

18:29.580 --> 18:31.580
你可能就是涉及到相同的逻辑

18:31.580 --> 18:34.580
在不同的生命周期函数里面

18:34.580 --> 18:37.580
相同的代码存在多分

18:37.580 --> 18:39.580
ok

18:39.580 --> 18:41.580
还有就是难以理解的class

18:41.580 --> 18:43.580
这个就是这个刚刚我们说的

18:43.580 --> 18:45.580
是不是this

18:45.580 --> 18:47.580
对吧

18:47.580 --> 18:49.580
早期的话它存在这么一些问题

18:49.580 --> 18:51.580
那hooks的出现

18:51.580 --> 18:53.580
它就能够解决

18:53.580 --> 18:55.580
这些问题

18:55.580 --> 18:57.580
ok这些问题的话都会得到解决

18:57.580 --> 18:59.580
我们一会讲hooks的时候

18:59.580 --> 19:01.580
大家就知道了

19:01.580 --> 19:03.580
那还有一点

19:03.580 --> 19:05.580
就是hooks的出现

19:05.580 --> 19:07.580
然后这边写的有

19:07.580 --> 19:10.580
它还有一个更加重要的信号

19:10.580 --> 19:12.580
什么信号呢

19:12.580 --> 19:14.580
那就是你整个react

19:14.580 --> 19:16.580
思想上面的转变

19:16.580 --> 19:18.580
你早期的时候整个react

19:18.580 --> 19:20.580
它主打的是什么

19:20.580 --> 19:22.580
主打的是内主键

19:22.580 --> 19:24.580
你如果就是早期你接触过

19:24.580 --> 19:26.580
早期版本的react

19:26.580 --> 19:28.580
就16.8之前的reactor

19:28.580 --> 19:30.580
你会发现它主打的就是内主键

19:30.580 --> 19:32.580
那个时候韩束主键的话

19:32.580 --> 19:34.580
基本就是展示性的

19:34.580 --> 19:36.580
我之前在介绍

19:36.580 --> 19:38.580
主键的时候我说过

19:38.580 --> 19:40.580
对吧

19:40.580 --> 19:42.580
韩束基本就是展示型的

19:42.580 --> 19:44.580
你能够通过props

19:44.580 --> 19:46.580
可以拿到一些数据

19:46.580 --> 19:48.580
你本身的话是不能持有数据的

19:48.580 --> 19:50.580
所以早期它主要是什么呢

19:50.580 --> 19:52.580
主要是面向对象的这种思想

19:52.580 --> 19:54.580
但是慢慢慢慢

19:54.580 --> 19:56.580
它这个思想就开始转变了

19:56.580 --> 19:58.580
转变为了什么呢

19:58.580 --> 20:00.580
转变为韩束是变成了思想

20:00.580 --> 20:04.580
这是思想层面的这个转变

20:04.580 --> 20:06.580
那这个面向对象的话

20:06.580 --> 20:08.580
转为这个韩束是变成

20:08.580 --> 20:10.580
它是整个这个饭式

20:10.580 --> 20:12.580
整个饭式都有这个改变

20:12.580 --> 20:14.580
这边的话可能有同学没听过

20:14.580 --> 20:16.580
编程饭式

20:16.580 --> 20:18.580
这边给大家写一下

20:18.580 --> 20:22.580
这是编程饭式

20:22.580 --> 20:24.580
编程饭式

20:24.580 --> 20:26.580
上面的转变

20:26.580 --> 20:30.580
那我们说一下我们的这个编程饭式

20:30.580 --> 20:32.580
编程饭式

20:32.580 --> 20:34.580
什么叫做编程饭式

20:34.580 --> 20:35.580
所谓编程饭式的话

20:35.580 --> 20:39.580
就是你就可以理解成编程的思想

20:39.580 --> 20:41.580
编程的思想

20:41.580 --> 20:43.580
整体来讲的话分成两大类

20:43.580 --> 20:47.580
一种叫做命令式变成

20:47.580 --> 20:49.580
命令式变成

20:49.580 --> 20:51.580
另外一种叫做什么呢

20:51.580 --> 20:55.580
另外一种叫做生命式变成

20:55.580 --> 20:57.580
生命式变成

20:57.580 --> 20:59.580
什么叫做命令式呢

20:59.580 --> 21:01.580
实际上大家就是一直以来

21:01.580 --> 21:03.580
学习的就是命令式

21:03.580 --> 21:04.580
所谓命令式

21:04.580 --> 21:07.580
主要就是告诉计算机

21:07.580 --> 21:09.580
然后接下来号

21:09.580 --> 21:12.580
就是告诉计算机怎么做

21:12.580 --> 21:14.580
计算机怎么做

21:14.580 --> 21:16.580
强调的是一个什么呢

21:16.580 --> 21:18.580
强调的是一个号

21:18.580 --> 21:20.580
然后我们需要干嘛呢

21:20.580 --> 21:22.580
我们需要给计算机指名

21:22.580 --> 21:24.580
一条一条的指令

21:24.580 --> 21:30.580
我们需要给计算机指名

21:30.580 --> 21:32.580
指名

21:32.580 --> 21:34.580
就是每一条步骤

21:34.580 --> 21:36.580
每一个步骤

21:36.580 --> 21:38.580
你第一步做什么

21:38.580 --> 21:39.580
第二步做什么

21:39.580 --> 21:40.580
第三步做什么

21:40.580 --> 21:42.580
我们都需要把它写出来

21:42.580 --> 21:43.580
写出来之后

21:43.580 --> 21:44.580
然后计算机才知道

21:44.580 --> 21:46.580
我需要这样子来做

21:46.580 --> 21:48.580
那早期大家接触的

21:48.580 --> 21:52.580
接触的就是写代码的方式

21:52.580 --> 21:54.580
都是命令式的

21:54.580 --> 21:56.580
就是你一直以来接触的

21:56.580 --> 21:57.580
都是命令式的

21:57.580 --> 21:58.580
命令式的话

21:58.580 --> 21:59.580
这边的话

21:59.580 --> 22:03.020
就是你可以分为面向过程

22:03.020 --> 22:04.020
然后还有什么呢

22:04.020 --> 22:05.020
面向对象

22:05.020 --> 22:07.020
但是无论是面向过程变成

22:07.020 --> 22:08.020
还是面向对象变成

22:08.020 --> 22:10.020
它都是属于命令式的

22:10.020 --> 22:12.020
我都需要告诉计算机

22:12.020 --> 22:15.020
每一步需要怎么做

22:15.020 --> 22:18.020
好 与这个命令式相对的就是什么呢

22:18.020 --> 22:21.020
与命令式相对的是生命式

22:21.020 --> 22:22.020
生命式的话

22:22.020 --> 22:26.100
告诉计算机我要什么

22:26.100 --> 22:28.100
我要什么

22:28.100 --> 22:30.100
强调的是什么呢

22:30.100 --> 22:33.100
强调的是一个what

22:33.100 --> 22:35.100
强调的是一个what

22:35.100 --> 22:36.100
我告诉你我想要什么

22:36.100 --> 22:37.100
然后加计算机

22:37.100 --> 22:38.100
背后的话我不用去管

22:38.100 --> 22:41.100
它是怎么实现的

22:41.100 --> 22:43.100
背后我不需要管的

22:43.100 --> 22:44.100
典型的就是什么呢

22:44.100 --> 22:47.100
典型的就是寒树式变成

22:47.100 --> 22:49.100
寒树变成就这边

22:49.100 --> 22:51.100
之前是面向对象变成

22:51.100 --> 22:53.100
面向对象变成是属于命令式的

22:53.100 --> 22:54.100
对不对

22:54.100 --> 22:56.100
你这个整个变成范式

22:56.100 --> 22:58.100
都发生了这个更改

22:58.100 --> 22:59.100
然后还有什么呢

22:59.100 --> 23:01.100
还有就是DSL

23:01.100 --> 23:04.100
DSL也是生命式变成

23:04.100 --> 23:06.100
什么叫做生命式变成

23:06.100 --> 23:08.100
什么叫DSL

23:08.100 --> 23:13.420
全身叫做领域专用语言

23:13.420 --> 23:15.420
专用语言

23:15.420 --> 23:17.420
典型的比如说大家接触的

23:17.420 --> 23:20.420
比如说CSS

23:20.420 --> 23:21.420
比如说什么呢

23:21.420 --> 23:23.420
比如你的HTML

23:23.420 --> 23:25.420
但HTML算是标记语言

23:25.420 --> 23:27.420
也算

23:27.420 --> 23:28.420
HTML CSS

23:28.420 --> 23:29.420
还有什么呢

23:29.420 --> 23:31.420
还就是我不知道大家有没有接触过这个

23:31.420 --> 23:33.420
circle

23:33.420 --> 23:34.420
circle语言

23:34.420 --> 23:37.420
这些的话都是叫做领域专用语言

23:37.420 --> 23:39.420
为什么叫领域专用语言

23:39.420 --> 23:40.420
比如你要给这个

23:40.420 --> 23:42.420
你写网页你要写样式

23:42.420 --> 23:44.420
你能不能选择其他语言

23:44.420 --> 23:45.420
它和那个

23:45.420 --> 23:47.420
和那个就是后端不一样

23:47.420 --> 23:49.420
后端比如说我想开发这个服务旗转

23:49.420 --> 23:50.420
对吧

23:50.420 --> 23:51.420
我可以选加网

23:51.420 --> 23:52.420
我可以选Note的CS

23:52.420 --> 23:53.420
我可以选Python

23:53.420 --> 23:54.420
可以选Ruby

23:54.420 --> 23:55.420
可以选Go

23:55.420 --> 23:56.420
我的选择很多

23:56.420 --> 23:58.420
所以这些语言就不叫领域专用语言

23:58.420 --> 23:59.420
而你这边的话

23:59.420 --> 24:01.420
像这个HTML CSS circle

24:01.420 --> 24:04.420
这些的话就叫做领域专用语言

24:04.420 --> 24:05.420
比如你要写样式

24:05.420 --> 24:07.420
你是不是只能选择CSS

24:07.420 --> 24:08.420
对不对

24:08.420 --> 24:11.420
你的那种预处理器不算

24:11.420 --> 24:12.420
预处理器的话

24:12.420 --> 24:13.420
你这边最终是吧

24:13.420 --> 24:15.420
还是要转换成这个CSS

24:15.420 --> 24:16.420
对吧

24:16.420 --> 24:18.420
这种就叫做领域专用语言

24:18.420 --> 24:20.420
那你想想领域专用语言

24:20.420 --> 24:21.420
你在写CSS的时候

24:21.420 --> 24:24.420
你是不是只需要声明WAT

24:24.420 --> 24:25.420
就可以了

24:25.420 --> 24:26.420
对不对

24:26.420 --> 24:27.420
声明声明

24:27.420 --> 24:29.420
它强调就强调什么了

24:29.420 --> 24:30.420
强调就这里

24:30.420 --> 24:31.420
声明

24:31.420 --> 24:32.420
什么叫做声明

24:32.420 --> 24:33.420
就我这边的话

24:33.420 --> 24:34.420
我声明一下

24:34.420 --> 24:35.420
比如说我这边的话

24:35.420 --> 24:37.420
我这边我写一个

24:37.420 --> 24:39.420
写一个P标签

24:39.420 --> 24:40.420
对吧

24:40.420 --> 24:41.420
然后接下来的话

24:41.420 --> 24:44.420
它这边Counter read

24:44.420 --> 24:45.420
Counter read

24:45.420 --> 24:46.420
你看

24:46.420 --> 24:49.420
你这边其实就是一条声明语句

24:49.420 --> 24:50.420
计算机背后

24:50.420 --> 24:51.420
其实是要做很多事情的

24:51.420 --> 24:52.420
但这些事情的话

24:52.420 --> 24:54.420
你不需要去关心的

24:54.420 --> 24:57.420
你只需要做这么一条声明

24:57.420 --> 24:58.420
这就是声明是

24:58.420 --> 25:00.420
编程的一个典型的特点

25:00.420 --> 25:01.420
我只需要做什么呢

25:01.420 --> 25:04.420
一条一条的声明

25:04.420 --> 25:06.420
那早期流行的是什么呢

25:06.420 --> 25:10.420
早期流行的是命令式编程

25:10.420 --> 25:11.420
我这边要说一下

25:11.420 --> 25:12.420
就是声明式编程

25:12.420 --> 25:17.240
其实并不是新东西

25:17.240 --> 25:25.240
声明式编程并不是新的东西

25:25.240 --> 25:28.240
它不是新的产物

25:28.240 --> 25:29.240
它是什么呢

25:29.240 --> 25:33.240
它是和命令式编程

25:33.240 --> 25:41.240
命令式编程同期出现的

25:41.240 --> 25:46.240
但是早期更加流行什么呢

25:46.240 --> 25:54.150
更加流行命令式编程

25:54.150 --> 25:55.150
为什么呢

25:55.150 --> 25:56.150
原因很简单

25:56.150 --> 25:58.150
因为命令式编程

25:58.150 --> 26:00.150
它的难度要低一些

26:00.150 --> 26:01.150
声明式编程

26:01.150 --> 26:02.150
它的难度要高一些

26:02.150 --> 26:04.150
或者说这个门槛

26:04.150 --> 26:05.150
这个门槛很低

26:05.150 --> 26:06.150
这个门槛很高

26:06.150 --> 26:07.150
为什么

26:07.150 --> 26:08.150
因为命令式编程的话

26:08.150 --> 26:10.150
你是不是你一步一步的

26:10.150 --> 26:11.150
在告诉计算机

26:11.150 --> 26:12.150
第一步做什么

26:12.150 --> 26:13.150
第二步做什么

26:13.150 --> 26:14.150
对不对

26:14.150 --> 26:15.150
那你很清楚

26:15.150 --> 26:17.150
它背后是怎么做的

26:17.150 --> 26:19.150
那这个声明式编程呢

26:19.150 --> 26:20.150
声明式编程

26:20.150 --> 26:21.150
虽然我们说了

26:21.150 --> 26:22.150
比如像这个韩苏式编程

26:22.150 --> 26:24.150
它是属于一种声明式编程

26:24.150 --> 26:25.150
感觉很爽是吧

26:25.150 --> 26:26.150
我告诉计算机我要什么

26:26.150 --> 26:28.150
它直接就跟我做了

26:28.150 --> 26:29.150
但实际上它背后

26:29.150 --> 26:33.150
还是肯定是用的是命令式

26:33.150 --> 26:34.150
对不对

26:34.150 --> 26:36.150
它背后一定是用的是命令式

26:36.150 --> 26:39.150
只不过它把具体

26:39.150 --> 26:41.150
每一步怎么做

26:41.150 --> 26:42.150
你可以把它理解为什么呢

26:42.150 --> 26:45.150
就是封装起来了

26:45.150 --> 26:46.150
理解为封装起来了

26:46.150 --> 26:48.150
比如说我举个例子

26:48.150 --> 26:49.150
比如说像咱们JS

26:49.150 --> 26:52.150
也是支持这种韩苏式编程的

26:52.150 --> 26:53.150
比如你早期的话

26:53.150 --> 26:54.150
你的便利

26:54.150 --> 26:56.150
你是不是最早你学的是什么

26:56.150 --> 26:58.150
最早你学的是否复讯环

26:58.150 --> 26:59.150
对不对

26:59.150 --> 27:00.150
我这边就不写了

27:00.150 --> 27:01.150
我就写个例子

27:01.150 --> 27:02.150
你早期的话

27:02.150 --> 27:03.150
你是不是就是用了复讯环

27:03.150 --> 27:04.150
那复讯环的话

27:04.150 --> 27:06.150
你就非常清楚

27:06.150 --> 27:07.150
它里面每一步

27:07.150 --> 27:08.150
对吧

27:08.150 --> 27:09.150
怎么怎么循环的

27:09.150 --> 27:10.150
每一步在做什么

27:10.150 --> 27:11.150
你是很清楚的

27:11.150 --> 27:12.150
但是你看

27:12.150 --> 27:14.150
我这边让我转成声明式

27:14.150 --> 27:16.150
比如我这边有个输主

27:16.150 --> 27:17.150
我还是写一下吧

27:17.150 --> 27:19.150
比如我这边有个输主

27:19.150 --> 27:20.150
12345

27:20.150 --> 27:22.150
你早期的话用命令式

27:22.150 --> 27:24.150
命令式然后加这边

27:24.150 --> 27:26.150
net i 等于 0

27:26.150 --> 27:28.150
i 小于 ar 点

27:28.150 --> 27:30.150
认识 i 加加

27:30.150 --> 27:31.150
对吧

27:31.150 --> 27:32.150
大家这里面

27:32.150 --> 27:33.150
你要做什么事情

27:33.150 --> 27:34.150
那接下来

27:34.150 --> 27:35.150
每一步的话

27:35.150 --> 27:36.150
你是清清楚楚的

27:36.150 --> 27:37.150
因为每一步是什么

27:37.150 --> 27:39.150
是你写的

27:39.150 --> 27:40.150
对吧

27:40.150 --> 27:41.150
每一步是你写的

27:41.150 --> 27:42.150
你怎么可能不知道

27:42.150 --> 27:44.150
但是你看韩苏式编程

27:44.150 --> 27:45.150
用我们这个JS

27:45.150 --> 27:46.150
也支持韩苏式编程

27:46.150 --> 27:47.150
比如说我这边便利

27:47.150 --> 27:48.150
我可以用什么

27:48.150 --> 27:51.150
我可以用这个for each

27:51.150 --> 27:52.150
对吧

27:52.150 --> 27:53.150
for each

27:53.150 --> 27:54.150
然后接下来

27:54.150 --> 27:55.150
之前老师怎么给你讲的

27:55.150 --> 27:57.150
是你这边传一个回调韩苏

27:57.150 --> 27:58.150
对吧

27:58.150 --> 27:59.150
传一个回调韩苏

27:59.150 --> 28:00.150
接下来他这边的话

28:00.150 --> 28:02.150
就是每一项他会传给

28:02.150 --> 28:03.150
这个item

28:03.150 --> 28:04.150
接下来这边

28:04.150 --> 28:05.150
你就可以

28:05.150 --> 28:06.150
这边的话

28:06.150 --> 28:08.150
你就可以做具体的事情

28:08.150 --> 28:09.150
那这边就

28:09.150 --> 28:10.150
对于你来讲

28:10.150 --> 28:11.150
就有个黑盒存在了

28:11.150 --> 28:12.150
什么叫做黑盒

28:12.150 --> 28:14.150
就这个for each

28:14.150 --> 28:15.150
for each对于你来讲

28:15.150 --> 28:16.150
就是个黑盒

28:16.150 --> 28:18.150
你不知道这个for each

28:18.150 --> 28:20.150
究竟做了什么事情

28:20.150 --> 28:21.150
对不对

28:21.150 --> 28:22.150
你并不知道

28:22.150 --> 28:23.150
说为什么早期的话

28:23.150 --> 28:25.150
这个韩苏式编程

28:25.150 --> 28:27.150
就是这个生命式编程

28:27.150 --> 28:28.150
他并不流行

28:28.150 --> 28:30.150
流行的是命令式编程

28:30.150 --> 28:31.150
原因就在这里

28:31.150 --> 28:32.150
命令式编程

28:32.150 --> 28:34.150
他的门槛要低一些

28:34.150 --> 28:35.150
生命式编程的话

28:35.150 --> 28:37.150
门槛要高一些

28:37.150 --> 28:39.150
但是随着近几年

28:39.150 --> 28:41.150
但是

28:41.150 --> 28:43.590
但是

28:43.590 --> 28:45.590
这边两个弹势了是吧

28:45.590 --> 28:46.590
但是早期

28:46.590 --> 28:48.590
不过嘛

28:48.590 --> 28:50.590
不过随着近几年

28:50.590 --> 28:52.590
这个整个

28:52.590 --> 28:54.590
整个这个什么呢

28:54.590 --> 28:56.590
整个这个

28:56.590 --> 28:58.590
这个项目工程

28:58.590 --> 29:00.590
项目工程

29:00.590 --> 29:02.590
越来越

29:02.590 --> 29:03.590
复杂

29:03.590 --> 29:04.590
然后接下来

29:04.590 --> 29:06.590
以前的这个

29:06.590 --> 29:08.590
命令式编程

29:08.590 --> 29:10.590
命令式编程

29:10.590 --> 29:12.590
就有点

29:12.590 --> 29:14.590
力不重新了

29:14.590 --> 29:15.590
OK

29:15.590 --> 29:16.590
所以

29:16.590 --> 29:18.590
所以

29:19.590 --> 29:22.590
现在慢慢开始

29:22.590 --> 29:24.590
流行

29:24.590 --> 29:26.590
这个生命式编程

29:26.590 --> 29:29.800
OK

29:29.800 --> 29:30.800
就我记得在

29:30.800 --> 29:33.800
特别是17年的时候

29:33.800 --> 29:34.800
那个时候

29:34.800 --> 29:35.800
就整个生命式编程

29:35.800 --> 29:37.800
相当相当的火

29:37.800 --> 29:38.800
OK

29:38.800 --> 29:39.800
就随着咱们整个这个

29:39.800 --> 29:40.800
项目工程

29:40.800 --> 29:41.800
越来越复杂

29:41.800 --> 29:42.800
我不可能再用

29:42.800 --> 29:43.800
以前的这种命令式编程

29:43.800 --> 29:45.800
每一步每一步

29:45.800 --> 29:46.800
然后这样我倒知道

29:46.800 --> 29:47.800
它是怎么做的

29:47.800 --> 29:48.800
OK

29:48.800 --> 29:49.800
我只需要就是

29:49.800 --> 29:51.800
生命式编程的话

29:51.800 --> 29:53.800
就可以解放

29:55.800 --> 29:56.800
就是说

29:56.800 --> 29:57.800
可以把你从一些

29:57.800 --> 29:58.800
细致末节的一些

29:58.800 --> 30:00.800
细节方面把你解放出来

30:00.800 --> 30:01.800
OK

30:01.800 --> 30:03.800
我再给大家举个例子吧

30:03.800 --> 30:05.800
就比如说命令式编程

30:05.800 --> 30:06.800
命令式编程就好比

30:06.800 --> 30:07.800
比如说你现在

30:07.800 --> 30:08.800
你要做一个

30:08.800 --> 30:10.800
做一盘回锅肉

30:10.800 --> 30:11.800
做一盘回锅肉

30:11.800 --> 30:12.800
那命令式编程的话

30:12.800 --> 30:13.800
就是你的每一个步骤

30:13.800 --> 30:15.800
你都是清清楚楚的

30:15.800 --> 30:16.800
你的这个肉

30:16.800 --> 30:17.800
对吧

30:17.800 --> 30:18.800
怎么切的

30:18.800 --> 30:20.800
一片一片把它切出来

30:20.800 --> 30:21.800
然后接下来你这边的话

30:21.800 --> 30:23.800
还有就是你怎么炒的

30:23.800 --> 30:25.800
每一步你都清清楚楚的

30:25.800 --> 30:27.800
你是整个这个料理过程

30:27.800 --> 30:28.800
你都清楚

30:28.800 --> 30:29.800
但现在的话

30:29.800 --> 30:31.800
你不再是做这个回锅肉了

30:31.800 --> 30:32.800
一盘回锅肉

30:32.800 --> 30:33.800
你可以这样子搞

30:33.800 --> 30:34.800
对不对

30:34.800 --> 30:35.800
每一个步骤

30:35.800 --> 30:37.800
都自己亲自进行把控

30:37.800 --> 30:39.800
然后接下来怎么去切

30:39.800 --> 30:40.800
怎么去炒

30:40.800 --> 30:41.800
对不对

30:41.800 --> 30:42.800
亲自把控

30:42.800 --> 30:43.800
但你现在的话

30:43.800 --> 30:44.800
你不再是做一盘回锅肉

30:44.800 --> 30:46.800
而是你整个项目变大了

30:46.800 --> 30:47.800
你要做一个什么

30:47.800 --> 30:50.800
你要做一个满汉全席了

30:50.800 --> 30:51.800
你要做一个满汉全席

30:51.800 --> 30:53.800
你还可不可能这个亲自

30:53.800 --> 30:54.800
亲密亲为

30:54.800 --> 30:55.800
没到菜的

30:55.800 --> 30:58.800
然后每一个菜都是你去切

30:58.800 --> 30:59.800
可不可能

30:59.800 --> 31:00.800
这不可能

31:00.800 --> 31:01.800
你就需要什么

31:01.800 --> 31:02.800
你需要就是有些东西

31:02.800 --> 31:03.800
现成的东西给你

31:03.800 --> 31:06.800
你只负责最后关键的部分

31:06.800 --> 31:07.800
对不对

31:07.800 --> 31:09.800
只需要负责最后关键的部分

31:09.800 --> 31:11.800
这个其实就是命令式和生命式

31:11.800 --> 31:13.800
它一个最大的区别

31:13.800 --> 31:15.800
但是最终你拿到了

31:15.800 --> 31:16.800
比如你拿到切好的肉

31:16.800 --> 31:17.800
它背后还是什么

31:17.800 --> 31:19.800
背后还是有其他人

31:19.800 --> 31:20.800
是不是一刀一刀切的

31:20.800 --> 31:23.800
它背后是不是还是用的是命令式

31:23.800 --> 31:24.800
对吧

31:24.800 --> 31:25.800
这个的话是属于

31:25.800 --> 31:27.800
这个编程饭食上面的东西了

31:27.800 --> 31:29.800
这个需要大家

31:29.800 --> 31:30.800
不是说我这边的话

31:30.800 --> 31:32.800
我这个十多分钟

31:32.800 --> 31:33.800
十多二十分钟

31:33.800 --> 31:35.800
能给大家就是给你讲清楚的

31:35.800 --> 31:38.800
这个是属于这种思想层面的

31:38.800 --> 31:41.800
思想层面的话是最难讲的

31:41.800 --> 31:42.800
这种思想层面的话需要你

31:42.800 --> 31:43.800
你就是你

31:43.800 --> 31:45.800
这两种你都接触过之后

31:45.800 --> 31:47.800
命令式你也接触过

31:47.800 --> 31:48.800
生命式你也接触过

31:48.800 --> 31:49.800
你接触过之后

31:49.800 --> 31:51.800
人有一天你慢慢自己就能够

31:51.800 --> 31:53.800
误出来的

31:53.800 --> 31:54.800
知道不

31:54.800 --> 31:56.800
这个的话我这边就不再

31:56.800 --> 31:59.800
不再做过多的讲解了

31:59.800 --> 32:00.800
接下来来

32:00.800 --> 32:02.800
我们这边

32:02.800 --> 32:03.800
继续

32:03.800 --> 32:05.800
因为它是属于

32:05.800 --> 32:07.800
不同的编程饭食了

32:07.800 --> 32:09.800
所以你这边你在学习

32:09.800 --> 32:10.800
这个Hooks的时候

32:10.800 --> 32:12.800
你会发现就是

32:12.800 --> 32:13.800
突然多了一些

32:13.800 --> 32:16.800
以前不熟悉的这个概念

32:16.800 --> 32:18.800
什么呢比我纯寒说

32:18.800 --> 32:21.800
这个你以前是听都没听过的

32:21.800 --> 32:23.800
我之前我在接触react之前

32:23.800 --> 32:25.800
我也是听都没听过

32:25.800 --> 32:26.800
包括什么呢

32:26.800 --> 32:27.800
包括副作用

32:27.800 --> 32:29.800
什么叫做纯寒说

32:29.800 --> 32:31.800
什么叫做副作用

32:31.800 --> 32:32.800
我第一次听的时候

32:32.800 --> 32:34.800
我在想这啥玩意

32:34.800 --> 32:35.800
而且我去看的时候

32:35.800 --> 32:37.800
我也发现就是

32:37.800 --> 32:40.800
这个怎么始终感觉怪怪的

32:40.800 --> 32:42.800
后来突然我才知道

32:42.800 --> 32:45.800
它是属于函数是编程里面的东西

32:45.800 --> 32:46.800
所以以前的话

32:46.800 --> 32:47.800
我接触的都是什么

32:47.800 --> 32:49.800
接触的都是命令是编程

32:49.800 --> 32:50.800
命令是编程里面

32:50.800 --> 32:52.800
就不存在这些概念

32:52.800 --> 32:53.800
知道吧

32:53.800 --> 32:54.800
不存在这些概念

32:54.800 --> 32:56.800
所以刚开始接触这些的时候

32:56.800 --> 32:58.800
确实是会觉得

32:58.800 --> 33:01.800
始终觉得有点难以理解

33:01.800 --> 33:02.800
或者说很不熟悉

33:02.800 --> 33:04.800
这个是很正常的

33:04.800 --> 33:05.800
这边包括什么

33:05.800 --> 33:06.800
纯寒说副作用

33:06.800 --> 33:07.800
科理化

33:07.800 --> 33:09.800
高阶函数

33:09.800 --> 33:10.800
科理化和高阶函数

33:10.800 --> 33:11.800
这个可能有的同学知道

33:11.800 --> 33:12.800
有的同学不知道

33:12.800 --> 33:13.800
这些概念

33:13.800 --> 33:14.800
可能有的同学是听过的

33:14.800 --> 33:16.800
对吧

33:16.800 --> 33:18.800
你如果还想就是

33:18.800 --> 33:20.800
继续来看这个面向对象

33:20.800 --> 33:22.800
和函数式编程

33:22.800 --> 33:24.800
他们有什么区别

33:24.800 --> 33:27.800
我这边给大家推荐了一篇文章

33:27.800 --> 33:28.800
这文章是我这边

33:28.800 --> 33:30.800
在谷歌里面找的

33:30.800 --> 33:31.800
当我给你们推了

33:31.800 --> 33:32.800
都是存英文的

33:32.800 --> 33:33.800
都是存英文的

33:33.800 --> 33:35.800
我这边就是强迫你们

33:35.800 --> 33:36.800
是吧

33:36.800 --> 33:37.800
慢慢养成看

33:37.800 --> 33:39.800
英文文档的习惯

33:40.800 --> 33:41.800
这个还是好像是

33:41.800 --> 33:44.800
两个女程序员写的

33:44.800 --> 33:45.800
是吧

33:45.800 --> 33:46.800
这边的话

33:46.800 --> 33:47.800
你看他的大肛

33:47.800 --> 33:49.800
这边他首先给你介绍了什么

33:49.800 --> 33:51.800
首先介绍了编程范氏

33:51.800 --> 33:53.800
你首先你要了解编程范氏

33:53.800 --> 33:54.800
知道吧

33:54.800 --> 33:55.800
然后接下来

33:55.800 --> 33:56.800
他就给你介绍了

33:56.800 --> 33:58.800
这个函数式编程

33:58.800 --> 33:59.800
我们这边叫做简称

33:59.800 --> 34:00.800
叫做fp

34:00.800 --> 34:02.800
functional programming

34:02.800 --> 34:03.800
然后接下来的话

34:03.800 --> 34:05.800
就是这个面向对象

34:05.800 --> 34:07.800
object or resented

34:07.800 --> 34:08.800
这个programming

34:08.800 --> 34:10.800
面向对象编程

34:10.800 --> 34:11.800
然后接下来

34:11.800 --> 34:12.800
他给你介绍了一下

34:12.800 --> 34:13.800
什么叫做存函数

34:13.800 --> 34:15.800
pure functions

34:15.800 --> 34:16.800
然后接下来

34:16.800 --> 34:19.800
这边是对象和内

34:19.800 --> 34:21.800
那最后就是一个比较

34:21.800 --> 34:23.800
就是你的函数式编程

34:23.800 --> 34:24.800
和这个OP编程

34:24.800 --> 34:26.800
他们的一些

34:26.800 --> 34:27.800
不同的这个地方

34:27.800 --> 34:28.800
大家下去的话

34:28.800 --> 34:29.800
可以把这篇文章

34:29.800 --> 34:31.800
把它看一下

34:31.800 --> 34:32.800
我不管

34:32.800 --> 34:33.800
不管你是

34:33.800 --> 34:34.800
把它翻译成中文也好

34:34.800 --> 34:35.800
还是一个单词

34:35.800 --> 34:37.800
一个单词去查也好

34:37.800 --> 34:38.800
你把这篇文章

34:38.800 --> 34:39.800
你把它看一下

34:39.800 --> 34:40.800
慢慢养成

34:40.800 --> 34:42.800
看这种英文文档的习惯

34:42.800 --> 34:44.800
好吧

34:44.800 --> 34:45.800
这是这篇文章

34:45.800 --> 34:47.800
他后面有个表格

34:47.800 --> 34:49.800
后面到最后

34:49.800 --> 34:50.800
到最后的时候

34:50.800 --> 34:52.800
是有一个表格的

34:52.800 --> 34:54.800
在这里

34:54.800 --> 34:56.800
他这边就具体的对比了

34:56.800 --> 34:57.800
两者之间

34:57.800 --> 34:59.800
有什么样的区别

34:59.800 --> 35:01.800
你看这边

35:01.800 --> 35:02.800
函数式编程

35:02.800 --> 35:04.800
没有副作用

35:04.800 --> 35:05.800
但你现在也不知道

35:05.800 --> 35:06.800
什么叫副作用

35:06.800 --> 35:07.800
我一会再来介绍

35:07.800 --> 35:08.800
一会再来解释

35:08.800 --> 35:10.800
大家这边OP

35:10.800 --> 35:12.800
可以有很多的副作用

35:12.800 --> 35:14.800
大家这边

35:14.800 --> 35:15.800
他最小的单元

35:15.800 --> 35:16.800
最小单元一个函数

35:16.800 --> 35:18.800
就是一个主要的单元

35:18.800 --> 35:20.800
而OP里面是什么

35:20.800 --> 35:22.800
是以对象为单元

35:22.800 --> 35:24.800
一个对象是一个单元

35:24.800 --> 35:28.800
这个就不再多说了

35:28.800 --> 35:30.800
然后最后说下

35:30.800 --> 35:31.800
就是这里

35:31.800 --> 35:32.800
关于这个hook

35:32.800 --> 35:33.800
hook的话

35:33.800 --> 35:34.800
他本质上的话

35:34.800 --> 35:37.800
就是java script函数

35:37.800 --> 35:38.800
就这边的话

35:38.800 --> 35:40.800
其实他新增的这个hook

35:40.800 --> 35:42.800
他其实一点都不神秘

35:42.800 --> 35:44.800
他在这个官网这边

35:44.800 --> 35:45.800
他写的有的

35:45.800 --> 35:46.800
又看到了单省是吧

35:46.800 --> 35:48.800
单省真的太帅了

35:48.800 --> 35:49.800
好

35:49.800 --> 35:50.800
他这边的话

35:50.800 --> 35:53.800
本质上这边是写的有

35:53.800 --> 35:55.800
看在哪里

35:55.800 --> 35:56.800
就本质这个hook的话

35:56.800 --> 35:58.800
他就是这个函数

35:58.800 --> 36:03.800
我忘了他在哪里写的了

36:03.800 --> 36:06.800
应该是在

36:06.800 --> 36:08.800
可能下一张截吧

36:08.800 --> 36:10.800
下一张截

36:10.800 --> 36:12.800
State

36:12.800 --> 36:14.800
这边就直接介绍State了

36:14.800 --> 36:15.800
算了算了

36:15.800 --> 36:16.800
回到我们这边吧

36:16.800 --> 36:19.800
他本质上就是java script函数

36:19.800 --> 36:21.800
就没有什么神秘的

36:21.800 --> 36:22.800
没有什么神秘的

36:22.800 --> 36:24.800
但是你在使用的时候

36:24.800 --> 36:27.800
他有两个额外的这个规则

36:27.800 --> 36:28.800
那两个规则呢

36:28.800 --> 36:31.800
首先的话你只能在函数最外层

36:31.800 --> 36:33.800
调用hook

36:33.800 --> 36:34.800
也就是说我们一般hook

36:34.800 --> 36:35.800
是放在哪里的

36:35.800 --> 36:38.800
是放在这个上面的

36:38.800 --> 36:39.800
我们不会把它放到

36:39.800 --> 36:41.800
这个循环条件判断

36:41.800 --> 36:43.800
这些就是指函数中

36:43.800 --> 36:44.800
为什么

36:44.800 --> 36:45.800
原因很简单

36:45.800 --> 36:46.800
我要保证

36:46.800 --> 36:48.800
每一次我函数的这个运行

36:48.800 --> 36:49.800
因为我们函数主见

36:49.800 --> 36:51.800
函数主见你更新的时候

36:51.800 --> 36:52.800
实际上是重新去

36:52.800 --> 36:54.800
执行了一遍函数

36:54.800 --> 36:55.800
对不对

36:55.800 --> 36:56.800
我要保证

36:56.800 --> 36:59.800
每一次函数执行的时候

36:59.800 --> 37:01.800
他的这个hook的执行顺序

37:01.800 --> 37:03.800
都是相同的

37:03.800 --> 37:04.800
他这个hook

37:04.800 --> 37:07.800
我们后面讲了一个就是react

37:07.800 --> 37:08.800
原码的时候

37:08.800 --> 37:09.800
大家就会知道

37:09.800 --> 37:12.800
他的hook是挂在这个fiber上面的

37:12.800 --> 37:13.800
他需要保证什么

37:13.800 --> 37:14.800
保证你每一次

37:14.800 --> 37:16.800
hook执行的这个顺序是相同的

37:16.800 --> 37:18.800
你如果放在这个循环

37:18.800 --> 37:19.800
或者条件判断语趣里面

37:19.800 --> 37:21.800
是不是可能会存在就是

37:21.800 --> 37:23.800
你hook的执行顺序不一样

37:23.800 --> 37:24.800
对不对

37:24.800 --> 37:25.800
不一样的话

37:25.800 --> 37:26.800
让我保持的这个状态

37:26.800 --> 37:28.800
可能就会出现问题

37:28.800 --> 37:29.800
OK

37:29.800 --> 37:31.800
这是首先第一点

37:31.800 --> 37:32.800
第二点的话

37:32.800 --> 37:35.800
只能在react函数主见中

37:35.800 --> 37:37.800
去调用这个hook

37:37.800 --> 37:39.800
你不要在其他函数中调用

37:39.800 --> 37:42.800
这是他两个这个规则

37:42.800 --> 37:43.800
OK

37:43.800 --> 37:45.800
这是关于这个hook

37:45.800 --> 37:47.800
一个简单的介绍

37:47.800 --> 37:48.800
好 接下来的话

37:48.800 --> 37:49.800
咱们就来学习

37:49.800 --> 37:50.800
具体的这两个

37:50.800 --> 37:52.800
一个state

37:52.800 --> 37:53.800
一个effect

37:53.800 --> 37:55.800
已经讲了40分钟了

37:55.800 --> 37:56.800
继续吧 继续

37:56.800 --> 37:58.800
咱们把整个这个讲完

37:58.800 --> 37:59.800
对吧

37:59.800 --> 38:00.800
你会发现咱们整个入门篇

38:00.800 --> 38:01.800
你看第一张

38:01.800 --> 38:03.800
第一张这个就是最后一节课了

38:03.800 --> 38:04.800
这个就最后一节课

38:04.800 --> 38:06.800
这个hook讲完之后

38:06.800 --> 38:08.800
我们的第一张就讲完了

38:08.800 --> 38:10.800
我这次入门篇

38:10.800 --> 38:11.800
入门篇

38:11.800 --> 38:13.800
我是大大的压缩了这个课程

38:13.800 --> 38:15.800
把这个课程压缩的

38:15.800 --> 38:17.800
就不会像以前那么长了

38:17.800 --> 38:18.800
OK

38:18.800 --> 38:20.800
好 我们来看一下

38:20.800 --> 38:21.800
这边的话react

38:21.800 --> 38:23.800
内置了一些实用的这个hook

38:23.800 --> 38:25.800
并且随着react版本的更新

38:25.800 --> 38:27.800
它持续在增加这个杆

38:27.800 --> 38:28.800
说过了

38:28.800 --> 38:29.800
那入门阶段的话

38:29.800 --> 38:31.800
我们来介绍两个

38:31.800 --> 38:33.800
一个的话就是最重要的

38:33.800 --> 38:35.800
我如何给这个

38:35.800 --> 38:36.800
函数组件

38:36.800 --> 38:38.800
我给它添加这个状态

38:38.800 --> 38:39.800
另外一个的话就是

38:39.800 --> 38:41.800
专门处理这个副作用的这个

38:41.800 --> 38:42.800
user effect

38:42.800 --> 38:44.800
但我一会讲这个user effect的时候

38:44.800 --> 38:45.800
我还得介绍一下

38:45.800 --> 38:46.800
什么叫做副作用

38:46.800 --> 38:47.800
因为这个是

38:47.800 --> 38:49.800
函数是变成的概念

38:50.800 --> 38:51.800
我喝口水

38:55.560 --> 38:58.560
首先的话是这个user state

38:58.560 --> 38:59.560
user state的话

38:59.560 --> 39:00.560
我这边就罗列了两个

39:00.560 --> 39:02.560
一个是基本使用

39:02.560 --> 39:04.560
第二个的话是声明多个state

39:04.560 --> 39:05.560
状态

39:05.560 --> 39:07.560
其实也是就是和官网对应着的

39:07.560 --> 39:09.560
你看这边官网有个

39:09.560 --> 39:11.560
使用state hook

39:11.560 --> 39:12.560
OK

39:12.560 --> 39:14.560
来呗 我们这边来看一下

39:14.560 --> 39:15.560
好 我们这边的话

39:15.560 --> 39:16.560
就可以告别内组件了

39:16.560 --> 39:18.560
给内组件说白白了

39:19.560 --> 39:21.560
这边二sf

39:21.560 --> 39:22.560
过来

39:22.560 --> 39:23.560
这个component

39:23.560 --> 39:24.560
我就把它删了吧

39:24.560 --> 39:26.560
这是之前的东西了

39:26.560 --> 39:27.560
干掉了

39:27.560 --> 39:29.560
那我们现在就干干净净的了

39:29.560 --> 39:30.560
干干净净的

39:30.560 --> 39:32.560
这边的话一个函数组件

39:32.560 --> 39:33.560
以后就都是它了

39:33.560 --> 39:34.560
都是它了

39:34.560 --> 39:36.560
先拿一个什么来

39:36.560 --> 39:37.560
举例呢

39:37.560 --> 39:39.560
先拿一个这个技术器

39:39.560 --> 39:41.560
技术器来举例

39:41.560 --> 39:42.560
技术器举例的话

39:42.560 --> 39:43.560
那我这边

39:43.560 --> 39:45.560
首先我这边给一个

39:45.560 --> 39:46.560
button

39:47.560 --> 39:48.560
button

39:48.560 --> 39:49.560
这边是加一

39:49.560 --> 39:50.560
对应的话

39:50.560 --> 39:52.560
这边unclick

39:52.560 --> 39:53.560
等于什么

39:53.560 --> 39:56.560
等于一个click handle

39:56.560 --> 39:57.560
对吧

39:57.560 --> 39:58.560
click handle对应

39:58.560 --> 39:59.560
这边的话是一个

39:59.560 --> 40:00.560
事件处理函数

40:00.560 --> 40:02.560
那现在我们这边一般就写在哪里

40:02.560 --> 40:04.560
就写在这个组件里面

40:04.560 --> 40:05.560
看到没有

40:05.560 --> 40:06.560
写在组件里面

40:06.560 --> 40:07.560
好 接下来

40:07.560 --> 40:08.560
我要针对什么加一

40:08.560 --> 40:09.560
这里是不是会

40:09.560 --> 40:11.560
涉及到一个状态问题

40:11.560 --> 40:13.560
以前在内组件里面

40:13.560 --> 40:14.560
你是怎么写的

40:14.560 --> 40:15.560
内组件里面

40:15.560 --> 40:17.560
你是不是通过这个state

40:17.560 --> 40:18.560
对吧

40:18.560 --> 40:19.560
通过state

40:19.560 --> 40:21.560
然后再创建一个state

40:21.560 --> 40:23.560
再加这边的话挂载

40:23.560 --> 40:24.560
就这边使用

40:24.560 --> 40:25.560
不是挂载

40:25.560 --> 40:27.560
这边就使用这个state

40:27.560 --> 40:28.560
但是在函数组件里面

40:28.560 --> 40:30.560
你没有这个state

40:30.560 --> 40:31.560
你咋办

40:31.560 --> 40:33.560
你能不能直接这样写

40:33.560 --> 40:34.560
我问一下

40:34.560 --> 40:35.560
能不能直接这样写

40:35.560 --> 40:37.560
let一个i

40:37.560 --> 40:38.560
等于一个e

40:38.560 --> 40:39.560
大家这边

40:39.560 --> 40:41.560
使用这个i

40:41.560 --> 40:42.560
使用i

40:42.560 --> 40:44.560
再加这边的话就是每次

40:44.560 --> 40:46.560
你能不能这样子写

40:46.560 --> 40:48.560
你这样子写是不好写的

40:48.560 --> 40:49.560
你这样子写的话

40:49.560 --> 40:51.560
你看这边倒不会给你爆错

40:51.560 --> 40:52.560
但是你这边的话

40:52.560 --> 40:54.560
你点加一它是没效果的

40:54.560 --> 40:55.560
为什么没效果

40:55.560 --> 40:56.560
你这边的话

40:56.560 --> 40:58.560
它每次都是什么

40:58.560 --> 40:59.560
每次是不是都是这里的话

40:59.560 --> 41:01.560
它是重新进行渲染

41:01.560 --> 41:02.560
对不对

41:02.560 --> 41:03.560
每次的话

41:03.560 --> 41:04.560
你这边的话

41:04.560 --> 41:05.560
因为你这个的话

41:05.560 --> 41:07.560
就是一个固定的一个变量而已

41:07.560 --> 41:09.560
所以它每次进来的话

41:09.560 --> 41:10.560
都是什么

41:10.560 --> 41:11.560
都是i等于e

41:11.560 --> 41:12.560
所以你这边需要

41:12.560 --> 41:13.560
设置成一个什么

41:13.560 --> 41:17.190
设置成一个状态

41:17.190 --> 41:18.190
需要把它设置成状态

41:18.190 --> 41:19.190
你这边不能

41:19.190 --> 41:21.190
就是简单是一个变量

41:21.190 --> 41:22.190
好那我们这边

41:22.190 --> 41:24.190
如何给它设置一个状态呢

41:24.190 --> 41:26.190
这边的话通过

41:26.190 --> 41:28.190
这边其实你就可以直接

41:28.190 --> 41:29.190
结构

41:29.190 --> 41:30.190
结构出来

41:30.190 --> 41:32.190
UserState

41:32.190 --> 41:33.190
这是我们学习的

41:33.190 --> 41:35.190
第一个Hook

41:35.190 --> 41:36.190
好然后在这边

41:36.190 --> 41:37.190
这边的话

41:37.190 --> 41:38.190
你就可以

41:38.190 --> 41:41.190
使用这个UserState

41:41.190 --> 41:43.190
UserState

41:43.190 --> 41:44.190
它就是一个函数

41:44.190 --> 41:45.190
看不看

41:45.190 --> 41:46.190
就是这个函数

41:46.190 --> 41:47.190
刚刚我们说过

41:47.190 --> 41:48.190
对吧

41:48.190 --> 41:49.190
好那在这边的话

41:49.190 --> 41:50.190
这个UserState

41:50.190 --> 41:51.190
你传入一个初始值

41:51.190 --> 41:53.190
比如初始值是0

41:53.190 --> 41:55.190
好再加这个函数

41:55.190 --> 41:57.190
它是有返回值的

41:57.190 --> 41:58.190
它返回值的话

41:58.190 --> 41:59.190
有两个东西

41:59.190 --> 42:01.190
我们这边可以拿一个

42:01.190 --> 42:02.190
数组来进行结构

42:02.190 --> 42:03.190
OK

42:03.190 --> 42:05.190
它返回的是一个数组

42:05.190 --> 42:06.190
那在这边

42:06.190 --> 42:07.190
你可以进行一个结构

42:07.190 --> 42:08.190
好

42:08.190 --> 42:09.190
第一个就是你这边

42:09.190 --> 42:10.190
设置的初始值

42:10.190 --> 42:11.190
我们这边拿一个这个Count

42:11.190 --> 42:12.190
来接收

42:12.190 --> 42:13.190
第二个的话

42:13.190 --> 42:15.190
第二个就是改变这个Count

42:15.190 --> 42:17.190
我如何来改变这个Count

42:17.190 --> 42:19.190
这边一般取名叫做什么呢

42:19.190 --> 42:21.190
叫做SetCount

42:21.190 --> 42:22.190
OK

42:22.190 --> 42:23.190
那回头的话

42:23.190 --> 42:24.190
你这边就可以使用什么

42:24.190 --> 42:26.190
你这边就可以使用这个Count

42:26.190 --> 42:27.190
我们先把这个注写

42:27.190 --> 42:29.190
先把这儿干掉

42:29.190 --> 42:31.190
我们来看一下

42:31.190 --> 42:32.190
首先这边

42:32.190 --> 42:34.190
这个能不能出来

42:34.190 --> 42:39.170
我们先放到一个Diway里面

42:39.170 --> 42:40.170
OK

42:40.170 --> 42:41.170
首先你看一下这边

42:41.170 --> 42:43.170
这个0是不是出来了

42:43.170 --> 42:44.170
对不对

42:44.170 --> 42:45.170
0出来了

42:45.170 --> 42:46.170
接下来我们这边点击

42:46.170 --> 42:47.170
点击的时候

42:47.170 --> 42:49.170
我们要进行一个修改

42:49.170 --> 42:51.170
我们修改这个Count

42:51.170 --> 42:52.170
修改这个Count不是说

42:52.170 --> 42:54.170
直接你这个Count加加

42:54.170 --> 42:55.170
不是这样子的

42:55.170 --> 42:56.170
OK

42:56.170 --> 42:57.170
这边的话

42:57.170 --> 42:58.170
这边它报的是这个

42:58.170 --> 42:59.170
报的是这个

42:59.170 --> 43:00.170
我们用的是

43:00.170 --> 43:01.170
你用这个也不好使

43:01.170 --> 43:02.170
OK

43:02.170 --> 43:03.170
用这个也不好使

43:03.170 --> 43:04.170
我们这边来看一下

43:04.170 --> 43:06.170
你直接这个Count加加

43:06.170 --> 43:08.170
这么也没用

43:08.170 --> 43:09.170
对不对

43:09.170 --> 43:10.170
你这边得通过什么呢

43:10.170 --> 43:11.170
得通过SetCount

43:11.170 --> 43:13.170
这SetCount就有点类似

43:13.170 --> 43:15.170
之前我们学内组件的时候

43:15.170 --> 43:16.170
那个SetState

43:16.170 --> 43:18.170
就有点类似于SetState

43:18.170 --> 43:19.170
所以你这边的话

43:19.170 --> 43:22.170
你就把这个SetCount

43:22.170 --> 43:24.170
调用这个方法

43:24.170 --> 43:25.170
调用这个方法

43:25.170 --> 43:27.170
再把Count的新的值传进去

43:27.170 --> 43:28.170
新的值

43:28.170 --> 43:31.170
我们这边是不是叫Count加加

43:31.170 --> 43:32.170
对不对

43:32.170 --> 43:34.170
那你这边加加Count

43:34.170 --> 43:35.170
通过这种方式

43:35.170 --> 43:36.170
好

43:36.170 --> 43:37.170
我们这边来看一下

43:37.170 --> 43:38.170
走

43:38.170 --> 43:39.170
是不是搞定了

43:39.170 --> 43:40.170
你看

43:40.170 --> 43:42.170
非常神奇的一件事情出现了

43:42.170 --> 43:43.170
我们这边的话

43:43.170 --> 43:44.170
让什么

43:44.170 --> 43:46.170
是让我们的函数组件

43:46.170 --> 43:49.170
也有这个状态了

43:49.170 --> 43:50.170
对吧

43:50.170 --> 43:51.170
也有状态了

43:51.170 --> 43:53.170
那自从有了这个Hook之后

43:53.170 --> 43:55.170
彻底告别内组件

43:55.170 --> 43:56.170
OK

43:56.170 --> 43:58.170
这是关于这个UserState

43:58.170 --> 44:01.170
它的一个基本的使用

44:01.170 --> 44:05.170
把这个放到笔记里面吧

44:05.170 --> 44:08.170
这个是关于这个基本使用

44:08.170 --> 44:09.170
也很简单

44:09.170 --> 44:10.170
你把这个代码

44:10.170 --> 44:12.170
稍微敲两遍

44:12.170 --> 44:13.170
你就熟悉了

44:13.170 --> 44:15.170
而且我们后面基本都是用的是

44:15.170 --> 44:16.170
不是基本

44:16.170 --> 44:19.170
我们后面用的都是这个函数组件

44:19.170 --> 44:21.170
所以你这个不可能不熟悉的

44:21.170 --> 44:23.170
知道吧

44:23.170 --> 44:24.170
好

44:24.170 --> 44:26.170
然后这是关于这个State

44:26.170 --> 44:27.170
State的话

44:27.170 --> 44:28.170
其他的话

44:28.170 --> 44:29.170
这边官网的话

44:29.170 --> 44:31.170
就没什么要说的了

44:31.170 --> 44:33.170
然后它这边有个等价

44:33.170 --> 44:35.170
等价的这个class实力

44:35.170 --> 44:36.170
你看这边它就是

44:36.170 --> 44:38.170
声明了一个State

44:38.170 --> 44:39.170
对吧

44:39.170 --> 44:41.170
大家这边通过StateState

44:41.170 --> 44:43.170
来进行这个设置

44:43.170 --> 44:44.170
OK

44:44.170 --> 44:45.170
它现在是通过什么

44:45.170 --> 44:47.170
是通过StateCount

44:47.170 --> 44:49.170
来进行设置

44:49.170 --> 44:51.170
好

44:51.170 --> 44:52.170
然后接下来的话

44:52.170 --> 44:55.170
我记得它有一个这个多个

44:55.170 --> 44:56.170
看一下

44:56.170 --> 44:58.170
它这边官网说了一下

44:58.170 --> 44:59.170
就以前的话

44:59.170 --> 45:00.170
我们喜欢叫这个函数组件

45:00.170 --> 45:02.170
称之为无状态组件

45:02.170 --> 45:03.170
但现在的话

45:03.170 --> 45:05.170
我们就不再叫无状态了

45:05.170 --> 45:06.170
你不能叫人家无状态

45:06.170 --> 45:07.170
人家有状态了

45:07.170 --> 45:08.170
对吧

45:08.170 --> 45:09.170
那现在的话就叫什么

45:09.170 --> 45:10.170
就叫函数组件

45:10.170 --> 45:11.170
OK

45:12.170 --> 45:15.170
然后户客在class内部是不起作用的

45:16.170 --> 45:17.170
好

45:17.170 --> 45:19.170
然后后面男孩介绍了一下

45:19.170 --> 45:20.170
就声明多个

45:22.170 --> 45:24.170
你下来的话可以把这边看一下

45:24.170 --> 45:26.170
就调用Ustate的时候

45:26.170 --> 45:27.170
他做了什么

45:27.170 --> 45:28.170
他需要的一些参数

45:28.170 --> 45:29.170
返回值是什么

45:29.170 --> 45:31.170
返回值其实就是一个数组了

45:31.170 --> 45:32.170
对吧

45:32.170 --> 45:33.170
好

45:33.170 --> 45:34.170
然后下面的话

45:34.170 --> 45:35.170
他说了一下就是

45:35.170 --> 45:36.170
这边是更新

45:36.170 --> 45:38.170
我记得有个声明多个

45:40.170 --> 45:41.170
你这边的话

45:41.170 --> 45:44.170
你是可以声明这个多个状态的

45:44.170 --> 45:46.170
可以声明多个状态

45:46.170 --> 45:47.170
声明多个状态的话

45:47.170 --> 45:49.170
你这边就是使用Ustate

45:49.170 --> 45:51.170
你使用多次就OK了

45:51.170 --> 45:53.170
什么多次就OK了

45:53.170 --> 45:54.170
那我们这边我们来看一下

45:54.170 --> 45:56.170
我们就看一下他这个例子吧

45:56.170 --> 45:58.170
把他这个例子看一下

45:58.170 --> 46:00.170
这边复制

46:00.170 --> 46:02.170
复制之后加这边

46:02.170 --> 46:04.170
把这儿拿过来

46:04.170 --> 46:05.170
OK

46:05.170 --> 46:07.170
这边的话这边是声明了几个

46:07.170 --> 46:09.170
是不是声明了三个

46:09.170 --> 46:11.170
对吧声明了三个

46:11.170 --> 46:12.170
声明了三个之后

46:12.170 --> 46:13.170
再加这边用一下

46:13.170 --> 46:17.250
第一个是年龄

46:17.250 --> 46:18.250
年龄

46:18.250 --> 46:20.250
年龄再加这边

46:20.250 --> 46:23.690
这个当然不是我的年龄

46:23.690 --> 46:24.690
是吧

46:24.690 --> 46:25.690
好

46:25.690 --> 46:26.690
然后接下来的话

46:26.690 --> 46:27.690
这边

46:27.690 --> 46:29.690
水果

46:29.690 --> 46:33.700
水果

46:33.700 --> 46:35.700
这边Fruit

46:35.700 --> 46:38.270
OK

46:38.270 --> 46:40.270
这边是Toodles

46:41.270 --> 46:43.270
这个是代办四项

46:44.270 --> 46:46.270
代办

46:46.270 --> 46:48.270
四项

46:48.270 --> 46:49.270
OK

46:49.270 --> 46:51.270
这边那就是应该是什么

46:51.270 --> 46:53.270
Toodles

46:53.270 --> 46:58.270
Toodles.text

46:59.270 --> 47:01.270
他是个数组是吧

47:01.270 --> 47:03.270
Toodles是第零项

47:03.270 --> 47:05.270
第零项的

47:05.270 --> 47:06.270
他拿到这个对象

47:06.270 --> 47:07.270
然后text

47:07.270 --> 47:08.270
OK

47:08.270 --> 47:10.270
把这个注释掉

47:10.270 --> 47:11.270
OK

47:11.270 --> 47:13.270
我们来看一下

47:13.270 --> 47:15.270
这边出出来了

47:15.270 --> 47:16.270
对吧

47:16.270 --> 47:17.270
然后接下来

47:17.270 --> 47:18.270
你这边click

47:18.270 --> 47:20.270
click我们这边就让这个年龄

47:20.270 --> 47:22.270
set age

47:22.270 --> 47:24.270
加加 age

47:25.270 --> 47:26.270
OK

47:28.270 --> 47:29.270
怎么回事

47:29.270 --> 47:32.270
我们这边是用的是一个Const

47:33.270 --> 47:34.270
好

47:34.270 --> 47:35.270
刷新一下

47:35.270 --> 47:36.270
OK

47:36.270 --> 47:37.270
对不对

47:37.270 --> 47:39.270
你可以使用这个多个

47:39.270 --> 47:40.270
就是UserState

47:40.270 --> 47:42.270
它是可以使用多次的

47:42.270 --> 47:43.270
它就有点类似于什么

47:43.270 --> 47:45.270
是不是有点类似于生命变量了

47:45.270 --> 47:46.270
你这种情况下

47:46.270 --> 47:47.270
你在写这个GS的时候

47:47.270 --> 47:49.270
你是不是可以生命多个变量

47:49.270 --> 47:51.270
你回一下你最早你写GS的时候

47:51.270 --> 47:52.270
对不对

47:52.270 --> 47:55.270
net一个nem等于一个解决

47:55.270 --> 47:57.270
然后接下来这边

47:58.270 --> 48:00.270
net一个比如 age

48:00.270 --> 48:01.270
等于一个18

48:01.270 --> 48:03.270
你最早最早学习这个GS的时候

48:03.270 --> 48:05.270
你是不是就是这样子来用的

48:05.270 --> 48:06.270
对不对

48:06.270 --> 48:07.270
生命一条一条的变量

48:07.270 --> 48:09.270
它这边其实就有点类似

48:09.270 --> 48:10.270
对不对

48:10.270 --> 48:11.270
有点类似于

48:11.270 --> 48:13.270
就回归到你最早的时候

48:13.270 --> 48:15.270
生命一条一条的变量

48:15.270 --> 48:16.270
只不过它这边

48:16.270 --> 48:17.270
得使用什么呢

48:17.270 --> 48:18.270
得使用UserState

48:18.270 --> 48:21.270
现在有一些其他语言里面

48:21.270 --> 48:23.270
它就干脆就干嘛呢

48:23.270 --> 48:25.270
直接就让你这样子

48:25.270 --> 48:26.270
就你生命一个状态

48:26.270 --> 48:28.270
直接就这样子写就可以了

48:28.270 --> 48:29.270
我知道的

48:29.270 --> 48:31.270
好像那个收利的点击

48:31.270 --> 48:32.270
就是这样子的

48:32.270 --> 48:34.270
甚至连这个UserState都不用

48:34.270 --> 48:35.270
你就直接这样子写

48:35.270 --> 48:36.270
直接这样子写

48:36.270 --> 48:37.270
相当于就生命了一个

48:37.270 --> 48:38.270
叫做内幕的状态

48:38.270 --> 48:40.270
它是和你的这个仕途

48:40.270 --> 48:41.270
绑定起来的

48:44.270 --> 48:45.270
当然还是这个

48:45.270 --> 48:47.270
react hooks

48:47.270 --> 48:48.270
启发了它们

48:48.270 --> 48:50.270
我之前看过那个采访

48:50.270 --> 48:52.270
就无论是这个

48:52.270 --> 48:53.270
收利的点击

48:53.270 --> 48:54.270
还是那个view3

48:54.270 --> 48:55.270
其实都是受到了

48:55.270 --> 48:57.270
这个hooks的这个启发

49:00.350 --> 49:01.350
好

49:01.350 --> 49:03.350
这是关于这个UserState

49:03.350 --> 49:05.350
这个是使用多个辩量

49:06.350 --> 49:08.350
所以说咱们这个

49:08.350 --> 49:09.350
整个react

49:09.350 --> 49:10.350
你可以看出来

49:10.350 --> 49:11.350
就你学了react

49:11.350 --> 49:13.350
再学了view1,3

49:13.350 --> 49:15.350
你这个框架你多学了几个之后

49:15.350 --> 49:16.350
你会看出

49:16.350 --> 49:18.350
谁才是这个排头兵

49:18.350 --> 49:19.350
对不对

49:20.350 --> 49:21.350
你看这个整个

49:21.350 --> 49:22.350
你看最早那个view

49:22.350 --> 49:24.350
view它是没有虚拟动物的

49:24.350 --> 49:26.350
那接下来他看到react

49:26.350 --> 49:27.350
用了虚拟动物

49:27.350 --> 49:28.350
觉得还不错是吧

49:28.350 --> 49:30.350
所以在这个view2

49:30.350 --> 49:32.350
把虚拟动物加进去了

49:32.350 --> 49:34.350
最早的话那个view3

49:34.350 --> 49:36.350
view3

49:36.350 --> 49:38.350
它那个最早的话

49:38.350 --> 49:40.350
也不是那个composition API

49:40.350 --> 49:42.350
后来的话看到这个react

49:42.350 --> 49:43.350
hooks出来

49:43.350 --> 49:44.350
发现这玩意还不错

49:44.350 --> 49:45.350
对吧

49:45.350 --> 49:46.350
后来他在这个view3里面

49:46.350 --> 49:48.350
加入了composition API

49:48.350 --> 49:50.350
说真真真真

49:50.350 --> 49:52.350
就是那种创新性的

49:52.350 --> 49:54.350
就我觉得创新性的这些改变

49:54.350 --> 49:56.350
其实主要还是react

49:56.350 --> 49:57.350
还是react

49:59.730 --> 50:03.420
这边的话221

50:03.420 --> 50:05.420
这是声明多个遍量

50:07.420 --> 50:09.420
这是关于这个user state

50:09.420 --> 50:11.420
这个没什么好说的

50:11.420 --> 50:13.420
接下来我们来看一下user effect

50:13.420 --> 50:15.420
user effect

50:15.420 --> 50:17.420
user effect的话

50:17.420 --> 50:19.420
这边的话包含这么一些点

50:19.420 --> 50:21.420
就首先这个user effect

50:21.420 --> 50:23.420
它是拿来做什么的

50:23.420 --> 50:24.420
它主要就是干嘛呢

50:24.420 --> 50:26.420
主要就是解决副作用的

50:26.420 --> 50:28.420
那这边的话就是需要给他

50:28.420 --> 50:30.420
解释一下什么叫做副作用

50:30.420 --> 50:31.420
对吧

50:31.420 --> 50:33.420
你如果就是以前一直用的是

50:33.420 --> 50:34.420
命令师从来没接触过

50:34.420 --> 50:35.420
这个函数字编程的话

50:35.420 --> 50:37.420
这个副作用对于你来讲

50:37.420 --> 50:38.420
是一个新的概念

50:39.420 --> 50:40.420
听都没听过

50:40.420 --> 50:41.420
对不对

50:41.420 --> 50:42.420
那什么叫做副作用

50:42.420 --> 50:43.420
副作用的话

50:43.420 --> 50:44.420
这边首先要介绍一个东西

50:44.420 --> 50:46.420
叫做存函数

50:48.420 --> 50:49.420
存函数

50:49.420 --> 50:51.420
什么叫做存函数

50:51.420 --> 50:53.420
我第一次听的时候我也很惊讶

50:53.420 --> 50:55.420
你如果现在是第一次听的话

50:55.420 --> 50:57.420
你可能估计会比较惊讶

50:57.420 --> 50:59.420
我第一次听的时候我也比较惊讶

50:59.420 --> 51:01.420
函数还有存不存的

51:01.420 --> 51:03.420
但是在函数的编程里面

51:03.420 --> 51:05.420
它确实就有这个概念

51:05.420 --> 51:08.420
你这个函数是否是一个存函数

51:08.420 --> 51:09.420
pure component

51:09.420 --> 51:10.420
这个function

51:11.420 --> 51:12.420
什么叫做存函数呢

51:12.420 --> 51:17.420
指的就是一个固定的值

51:18.420 --> 51:21.420
固定的值一定

51:21.420 --> 51:23.420
在你的函数中

51:23.420 --> 51:25.420
一个确切的值

51:25.420 --> 51:28.420
一个确切的值

51:28.420 --> 51:31.420
在你的函数中

51:33.420 --> 51:35.420
运行之后

51:36.420 --> 51:39.420
我想想这个该怎么表达

51:39.420 --> 51:41.420
一个确切的参数

51:41.420 --> 51:42.420
应该叫做参数

51:42.420 --> 51:44.420
一个确切的参数

51:44.420 --> 51:46.420
在你的函数中运行后

51:46.420 --> 51:52.420
就是一定能得到一个确切的值

51:55.930 --> 51:58.930
这个确切的值

51:59.930 --> 52:01.930
什么意思

52:01.930 --> 52:02.930
我给你举个例子

52:02.930 --> 52:04.930
举个例子你就明白了

52:04.930 --> 52:06.930
比如说我们这边的话有个函数

52:06.930 --> 52:07.930
function

52:07.930 --> 52:08.930
对吧

52:08.930 --> 52:09.930
function

52:09.930 --> 52:10.930
然后既然我们这边的话

52:10.930 --> 52:12.930
有一个叫做test

52:12.930 --> 52:13.930
它接收一个什么呢

52:13.930 --> 52:15.930
接收一个参数

52:15.930 --> 52:17.930
x

52:17.930 --> 52:19.930
然后既然它这边让它返回什么呢

52:19.930 --> 52:22.930
返回x乘以2

52:22.930 --> 52:23.930
ok

52:23.930 --> 52:24.930
这个函数简单吧

52:24.930 --> 52:25.930
对吧

52:25.930 --> 52:26.930
接收一个x

52:26.930 --> 52:28.930
然后返回x乘以2

52:28.930 --> 52:29.930
这个函数

52:29.930 --> 52:33.930
你放到这个函数是变成里面来讲的话

52:33.930 --> 52:36.930
这个函数就是一个存函数

52:36.930 --> 52:37.930
为什么

52:37.930 --> 52:38.930
因为你这边的话

52:38.930 --> 52:41.930
你根据你的这个值

52:41.930 --> 52:42.930
它放进来的话

52:42.930 --> 52:43.930
它的值是一定的

52:43.930 --> 52:45.930
比如我这个x

52:45.930 --> 52:49.930
x我如果我传入的这个值是2的话

52:49.930 --> 52:52.930
那它得到的最终的这个结果

52:52.930 --> 52:53.930
一定是多少

52:53.930 --> 52:54.930
一定是4

52:54.930 --> 52:57.930
所以没有什么外部能够影响它的

52:57.930 --> 52:58.930
对不对

52:58.930 --> 52:59.930
我这边呢

52:59.930 --> 53:01.930
我如果x我传入一个3

53:01.930 --> 53:03.930
那它得到的一定是什么

53:03.930 --> 53:04.930
2 3得6

53:04.930 --> 53:06.930
一定是6

53:06.930 --> 53:07.930
对不对

53:07.930 --> 53:10.930
那这样的函数我们就称之为存函数

53:10.930 --> 53:11.930
ok

53:11.930 --> 53:12.930
能够理解吧

53:12.930 --> 53:13.930
各位

53:13.930 --> 53:14.930
就我这边的话

53:14.930 --> 53:15.930
我根据我的这个参数

53:15.930 --> 53:16.930
我这边的话

53:16.930 --> 53:17.930
就可以推算出

53:17.930 --> 53:18.930
我把这个参数

53:18.930 --> 53:20.930
传入到这个函数里面之后

53:20.930 --> 53:21.930
它能够得到什么值

53:21.930 --> 53:23.930
我是能够推算出来的

53:23.930 --> 53:24.930
因为它这边

53:24.930 --> 53:25.930
让它整个运行流程

53:25.930 --> 53:26.930
它没有额外的一些东西

53:27.930 --> 53:28.930
对不对

53:28.930 --> 53:29.930
没有其他不可空的东西

53:29.930 --> 53:31.930
它的值是一定的

53:31.930 --> 53:32.930
就是你一定的行参

53:32.930 --> 53:34.930
就能够得到一定的这个值

53:34.930 --> 53:35.930
没有没有

53:35.930 --> 53:37.930
这种就叫做存函数

53:40.500 --> 53:41.500
例如

53:44.640 --> 53:46.640
例如下面的例子

53:52.380 --> 53:53.380
ok

53:53.380 --> 53:54.380
好

53:54.380 --> 53:56.380
那了解了什么是存函数之后

53:56.380 --> 53:57.380
那接下来的话

53:57.380 --> 53:59.380
那什么叫做不存的函数呢

53:59.380 --> 54:01.380
就是有副作用的函数

54:01.380 --> 54:03.380
函数里面有副作用

54:03.380 --> 54:05.380
我们就称之为这个函数是不存的

54:07.380 --> 54:13.380
如果一个函数中存在副作用

54:15.950 --> 54:18.950
那么我们就称

54:18.950 --> 54:20.950
该函数

54:20.950 --> 54:23.950
不是一个存函数

54:24.950 --> 54:26.950
那什么叫做副作用呢

54:26.950 --> 54:27.950
所谓副作用

54:28.950 --> 54:30.950
所谓副作用

54:30.950 --> 54:32.950
就是指的

54:34.950 --> 54:38.950
指的就是你函数的这个结果

54:38.950 --> 54:41.950
是不可空的

54:42.950 --> 54:43.950
不可空

54:43.950 --> 54:45.950
或者说不可预期的

54:46.950 --> 54:47.950
不可预期的

54:47.950 --> 54:48.950
ok

54:48.950 --> 54:49.950
比较像我们的存函数

54:49.950 --> 54:50.950
存函数

54:50.950 --> 54:51.950
我们敢举了这个例子

54:51.950 --> 54:53.950
你的这个结果的话

54:53.950 --> 54:55.950
是不是一定可控可预期

54:55.950 --> 54:56.950
对不对

54:56.950 --> 54:57.950
我传二他一定得到四

54:57.950 --> 54:59.950
我传三他一定得到六

54:59.950 --> 55:00.950
对不对

55:00.950 --> 55:01.950
但我这边的话

55:01.950 --> 55:03.950
我如果一个函数里面有副作用的话

55:03.950 --> 55:05.950
他的这个结果的话

55:05.950 --> 55:08.950
就可能就不如我们的预期

55:09.950 --> 55:10.950
ok

55:10.950 --> 55:12.950
那什么就是哪些是副作用的

55:12.950 --> 55:14.950
常见的副作用有

55:15.950 --> 55:18.950
常见的副作用

55:18.950 --> 55:20.950
副作用有

55:20.950 --> 55:22.950
比如说发送网络请求

55:22.950 --> 55:26.100
ok

55:26.100 --> 55:28.100
你看发送网络请求这边

55:28.100 --> 55:30.100
是不是他会存在一些

55:30.100 --> 55:32.100
不可空的这个因素

55:32.100 --> 55:33.100
对不对

55:33.100 --> 55:34.100
然后还有就是什么

55:34.100 --> 55:35.100
还有常见的

55:35.100 --> 55:38.100
添加一些监听

55:38.100 --> 55:40.100
一些这个

55:40.100 --> 55:42.100
这个事件

55:42.100 --> 55:45.100
添加一些这个监听

55:45.100 --> 55:46.100
监听

55:46.100 --> 55:49.660
监听

55:49.660 --> 55:57.960
监听的注册和取消注册

55:57.960 --> 55:58.960
或者什么呢

55:58.960 --> 56:00.960
或者这个比较手动

56:00.960 --> 56:02.960
手动修改

56:02.960 --> 56:03.960
动

56:03.960 --> 56:05.960
那这些操作

56:05.960 --> 56:07.960
还有什么包括读取文件这些

56:07.960 --> 56:09.960
读取文件

56:09.960 --> 56:10.960
当你前端的话

56:10.960 --> 56:11.960
好像不存在什么读取文件

56:11.960 --> 56:12.960
对吧

56:12.960 --> 56:14.960
除非你是放在服务器上面

56:14.960 --> 56:15.960
ok

56:15.960 --> 56:17.960
总之就是这些操作

56:17.960 --> 56:18.960
这些操作的话

56:18.960 --> 56:19.960
我们就称之为什么呢

56:19.960 --> 56:21.960
称之为副作用

56:21.960 --> 56:22.960
ok

56:22.960 --> 56:23.960
称之为副作用

56:23.960 --> 56:24.960
那这些副作用的话

56:24.960 --> 56:26.960
以前是放在哪里的

56:26.960 --> 56:27.960
以前的话

56:27.960 --> 56:28.960
我们是把这些副作用函数

56:28.960 --> 56:31.960
写在生命周期的钩子里面

56:32.960 --> 56:33.960
以前

56:33.960 --> 56:35.960
我们是将

56:36.960 --> 56:38.960
这些副作用

56:39.960 --> 56:42.960
写在生命周期

56:43.960 --> 56:44.960
钩子函数里面

56:46.960 --> 56:48.960
那么现在的话写在哪里呢

56:48.960 --> 56:49.960
现在

56:49.960 --> 56:51.960
就可以

56:51.960 --> 56:54.960
出写在UserEffect

56:56.960 --> 57:01.620
这个户口里面

57:01.620 --> 57:04.620
可以写在UserEffect里面

57:05.620 --> 57:06.620
好,来我们这边

57:06.620 --> 57:07.620
我们来看一个

57:07.620 --> 57:09.620
这个最基本的这个使用

57:10.620 --> 57:12.620
比如说我们这边

57:13.620 --> 57:15.620
我们这边的话先引入

57:15.620 --> 57:16.620
引入这个

57:18.620 --> 57:20.620
UserEffect

57:21.620 --> 57:22.620
引入它

57:22.620 --> 57:23.620
引入它之后

57:23.620 --> 57:24.620
然后这样我们就把那个

57:24.620 --> 57:26.620
把我们之前的那个例子

57:26.620 --> 57:27.620
我们来写一下

57:27.620 --> 57:28.620
我们之前那个就是

57:28.620 --> 57:30.620
改变标题那个

57:30.620 --> 57:31.620
是吧

57:31.620 --> 57:32.620
我们这边的话

57:32.620 --> 57:34.620
我们首先得有一个状态

57:34.620 --> 57:35.620
稍等

57:35.620 --> 57:37.620
我把这个稍微改一下

57:37.620 --> 57:39.620
这边我们首先有个状态

57:39.620 --> 57:41.620
Net一个Count

57:41.620 --> 57:43.620
SetCount

57:43.620 --> 57:46.620
等于一个UserState

57:47.620 --> 57:49.620
好,这边我们是0

57:51.620 --> 57:53.620
好,然后先下这边

57:53.620 --> 57:55.620
这边的话我们是

57:55.620 --> 57:57.620
就是给个DIV吧

57:59.620 --> 58:01.620
好,这里的话是次数

58:01.620 --> 58:03.620
就你点击了

58:04.620 --> 58:06.620
你点击了

58:10.620 --> 58:11.620
好,大家这边

58:11.620 --> 58:13.620
这边让它增加

58:14.620 --> 58:16.620
SetCount

58:16.620 --> 58:18.620
好,这边加加Count

58:18.620 --> 58:20.620
首先这边来写一个技术器

58:21.620 --> 58:22.620
技术器之后

58:22.620 --> 58:23.620
接下来我们这边要干嘛呢

58:23.620 --> 58:25.620
把这个伸了

58:26.620 --> 58:27.620
接下来的话

58:27.620 --> 58:28.620
我们这边

58:28.620 --> 58:30.620
我们要想实现刚才的那个

58:30.620 --> 58:32.620
刚才我们那个就是

58:32.620 --> 58:34.620
在那里

58:34.620 --> 58:35.620
在这里

58:35.620 --> 58:37.620
就改变它的这个标题

58:38.620 --> 58:40.620
它的标题你点击了多少次

58:40.620 --> 58:42.620
那接下来这个是属于一个副作用

58:42.620 --> 58:44.620
这副作用的话我们就放在哪里了

58:44.620 --> 58:46.620
我们就放在UserEffect

58:48.620 --> 58:50.620
UserEffect

58:50.620 --> 58:53.620
UserEffect它是一个函数

58:54.620 --> 58:55.620
它这个函数的话

58:55.620 --> 58:57.620
这边它就接收

58:57.620 --> 58:59.620
首先它接收的第一个函数

58:59.620 --> 59:01.620
也是一个函数

59:02.620 --> 59:03.620
也是一个函数

59:03.620 --> 59:04.620
但它一会的话

59:04.620 --> 59:06.620
还有就是第二个函数

59:06.620 --> 59:07.620
这第二个函数我们一会再说

59:07.620 --> 59:08.620
它这边首先

59:08.620 --> 59:09.620
第一个函数

59:09.620 --> 59:10.620
第一个函数它是一个函数

59:10.620 --> 59:12.620
这个函数里面写什么

59:12.620 --> 59:15.620
写你要执行的副作用

59:16.620 --> 59:17.620
输写

59:18.620 --> 59:23.620
输写你要执行的副作用

59:24.620 --> 59:25.620
它会在什么呢

59:25.620 --> 59:27.620
它会在你这边

59:27.620 --> 59:29.620
确然完之后执行

59:30.620 --> 59:33.620
会在这个渲染

59:33.620 --> 59:35.620
组件渲染

59:35.620 --> 59:38.620
完成后执行

59:38.620 --> 59:39.620
那比如说我们这边

59:39.620 --> 59:41.620
我们来简单打印一下

59:41.620 --> 59:43.620
不要这边

59:43.620 --> 59:45.620
UserEffect

59:45.620 --> 59:47.620
UserEffect

59:47.620 --> 59:49.620
那我们这边来看一下

59:49.620 --> 59:50.620
在这边

59:50.620 --> 59:51.620
你看刷新

59:51.620 --> 59:53.620
你看这边是不是执行的

59:53.620 --> 59:55.620
就有点类似于那个DiedMount

59:55.620 --> 59:56.620
对吧

59:56.620 --> 59:57.620
有点类似于DiedMount

59:57.620 --> 59:59.620
你看我这边渲染之后

59:59.620 --> 01:00:00.620
这边它执行

01:00:00.620 --> 01:00:02.620
但是和DiedMount又不一样

01:00:02.620 --> 01:00:04.620
DiedMount它只会执行几次

01:00:04.620 --> 01:00:07.620
是不是只会执行一次

01:00:08.620 --> 01:00:09.620
对吧

01:00:09.620 --> 01:00:10.620
它只会执行一次

01:00:10.620 --> 01:00:11.620
但我们这边的话

01:00:11.620 --> 01:00:12.620
你每次更新之后

01:00:12.620 --> 01:00:13.620
它都会执行

01:00:13.620 --> 01:00:14.620
比我们这边点一下

01:00:14.620 --> 01:00:15.620
你看

01:00:15.620 --> 01:00:17.620
是不是又执行了

01:00:18.620 --> 01:00:19.620
它就有点类似于

01:00:19.620 --> 01:00:22.620
以前DiedMount和DiedUpdate

01:00:22.620 --> 01:00:24.620
是不是一个合体

01:00:24.620 --> 01:00:25.620
对不对

01:00:25.620 --> 01:00:26.620
你第一次它会执行

01:00:26.620 --> 01:00:27.620
后面更新了

01:00:27.620 --> 01:00:28.620
它也会执行

01:00:29.620 --> 01:00:30.620
它也会执行

01:00:30.620 --> 01:00:31.620
OK

01:00:31.620 --> 01:00:32.620
那我们就可以把我们的

01:00:32.620 --> 01:00:34.620
刚才这句话写到哪里

01:00:34.620 --> 01:00:36.620
是不是写到它那里面

01:00:37.620 --> 01:00:38.620
对不对

01:00:38.620 --> 01:00:40.620
这边你点击了

01:00:40.620 --> 01:00:42.620
这边就直接是什么

01:00:42.620 --> 01:00:43.620
Count

01:00:44.620 --> 01:00:45.620
你点击了Count次

01:00:45.620 --> 01:00:47.620
我们这边来看一下

01:00:49.620 --> 01:00:50.620
刷新

01:00:50.620 --> 01:00:51.620
首先第一次

01:00:51.620 --> 01:00:52.620
你看这边点击了0次

01:00:52.620 --> 01:00:53.620
是不是出来了

01:00:53.620 --> 01:00:54.620
之后的话我们修改

01:00:54.620 --> 01:00:55.620
是没问题

01:00:57.620 --> 01:00:58.620
对不对

01:00:58.620 --> 01:00:59.620
没有问题

01:00:59.620 --> 01:01:00.620
你看我们这边

01:01:00.620 --> 01:01:02.620
就使用User

01:01:02.620 --> 01:01:03.620
在这里

01:01:03.620 --> 01:01:05.620
使用UserEffect

01:01:06.620 --> 01:01:07.620
来解决了

01:01:07.620 --> 01:01:09.620
我们之前的那个问题

01:01:09.620 --> 01:01:10.620
之前的什么问题

01:01:10.620 --> 01:01:12.620
是不是你相同的逻辑

01:01:12.620 --> 01:01:14.620
然后要在不同的生命周期

01:01:14.620 --> 01:01:15.620
勾字函数里面

01:01:15.620 --> 01:01:17.620
是不是书写两份

01:01:17.620 --> 01:01:18.620
对吧

01:01:18.620 --> 01:01:19.620
你看我现在使用UserEffect

01:01:19.620 --> 01:01:21.620
就完美的解决了

01:01:22.620 --> 01:01:23.620
OK

01:01:23.620 --> 01:01:25.620
把这个拿过来

01:01:25.620 --> 01:01:27.930
放到笔记里面

01:01:29.930 --> 01:01:31.930
这个是基本使用

01:01:31.930 --> 01:01:38.570
放到这里

01:01:38.570 --> 01:01:40.570
接下来UserEffect

01:01:40.570 --> 01:01:42.570
除了基本使用以外

01:01:42.570 --> 01:01:44.570
这边的话还有两个知识点

01:01:44.570 --> 01:01:45.570
大家要知道

01:01:45.570 --> 01:01:48.570
一个是执行清理工作

01:01:49.570 --> 01:01:51.570
我们说了UserEffect里面

01:01:51.570 --> 01:01:52.570
它是做什么

01:01:52.570 --> 01:01:54.570
它是做你的复作用操作

01:01:54.570 --> 01:01:55.570
那你的复作用操作

01:01:55.570 --> 01:01:56.570
除了什么

01:01:56.570 --> 01:01:57.570
除了这个就是

01:01:57.570 --> 01:01:59.570
比如像这种操作动作

01:01:59.570 --> 01:02:00.570
还有什么

01:02:00.570 --> 01:02:02.570
发送网络请求

01:02:02.570 --> 01:02:03.570
对吧

01:02:03.570 --> 01:02:04.570
还有什么

01:02:04.570 --> 01:02:05.570
还有就是你比如说

01:02:05.570 --> 01:02:06.570
你要绑定这个G17什么的

01:02:06.570 --> 01:02:08.570
是不是都应该在这

01:02:08.570 --> 01:02:09.570
对不对

01:02:09.570 --> 01:02:10.570
都应该在这

01:02:10.570 --> 01:02:11.570
让我这边的话

01:02:11.570 --> 01:02:13.570
比如说我在这个UserEffect里面

01:02:13.570 --> 01:02:15.570
我给它绑定一个G17

01:02:16.570 --> 01:02:17.570
比如说我们这边

01:02:17.570 --> 01:02:18.570
我们来看个例子

01:02:20.570 --> 01:02:22.570
比如说回到我们的代码

01:02:23.570 --> 01:02:24.570
在这里

01:02:25.570 --> 01:02:26.570
比如我们这边

01:02:26.570 --> 01:02:27.570
我们这边

01:02:27.570 --> 01:02:28.570
我们先把这个注射掉

01:02:28.570 --> 01:02:29.570
好

01:02:29.570 --> 01:02:30.570
我这边我需要干嘛呢

01:02:30.570 --> 01:02:32.570
我需要设置一个G17

01:02:32.570 --> 01:02:33.570
或者把这个删掉

01:02:33.570 --> 01:02:35.570
我在笔记里面放了吧

01:02:35.570 --> 01:02:36.570
笔记里面放了的

01:02:36.570 --> 01:02:37.570
回到这边

01:02:37.570 --> 01:02:38.570
这边我们就直接把它删掉

01:02:39.570 --> 01:02:40.570
好

01:02:40.570 --> 01:02:41.570
我在这干嘛呢

01:02:41.570 --> 01:02:42.570
我要绑一个G17

01:02:43.570 --> 01:02:44.570
SetInterval

01:02:46.570 --> 01:02:47.570
SetInterval

01:02:48.570 --> 01:02:49.570
它这边的话

01:02:49.570 --> 01:02:50.570
要做的事情很简单

01:02:51.570 --> 01:02:53.570
再加这边每个一秒来做

01:02:53.570 --> 01:02:54.570
做什么事情呢

01:02:54.570 --> 01:02:55.570
我们这边就打印一个

01:02:56.570 --> 01:02:57.570
打印一个比较Hello

01:03:00.570 --> 01:03:01.570
打印个Hello

01:03:02.570 --> 01:03:03.570
来我们来看一下

01:03:03.570 --> 01:03:04.570
这边的话

01:03:04.570 --> 01:03:05.570
当我渲染之后

01:03:05.570 --> 01:03:08.570
是不是立马会执行UserEffect

01:03:08.570 --> 01:03:09.570
然后接下来

01:03:09.570 --> 01:03:11.570
它这边是不是会绑定一个G17

01:03:11.570 --> 01:03:12.570
每个一秒输出Hello

01:03:12.570 --> 01:03:13.570
对不对

01:03:13.570 --> 01:03:14.570
好

01:03:14.570 --> 01:03:15.570
然后加这边我们来看一下

01:03:15.570 --> 01:03:16.570
刷新

01:03:17.570 --> 01:03:18.570
好

01:03:18.570 --> 01:03:19.570
这边Hello

01:03:19.570 --> 01:03:20.570
每个一秒是不是输出

01:03:20.570 --> 01:03:22.570
现在看上去是不是正常

01:03:22.570 --> 01:03:23.570
正常之后

01:03:23.570 --> 01:03:24.570
然后加我们这边

01:03:24.570 --> 01:03:25.570
我们这边我们来点击

01:03:26.570 --> 01:03:27.570
点击

01:03:27.570 --> 01:03:28.570
好你明显

01:03:28.570 --> 01:03:30.570
会发现这边的话出现问题了

01:03:31.570 --> 01:03:32.570
怎么问题

01:03:32.570 --> 01:03:33.570
感觉这个速度的话

01:03:33.570 --> 01:03:35.570
好像是不止一秒了

01:03:35.570 --> 01:03:36.570
对不对

01:03:36.570 --> 01:03:37.570
不止一秒了

01:03:37.570 --> 01:03:38.570
为什么

01:03:38.570 --> 01:03:41.570
为什么会出现这样的情况

01:03:41.570 --> 01:03:42.570
原因很简单

01:03:42.570 --> 01:03:44.570
因为我们刚才说过

01:03:44.570 --> 01:03:45.570
你这边

01:03:45.570 --> 01:03:47.570
每次重新这个函数

01:03:47.570 --> 01:03:49.570
重新执行的时候

01:03:49.570 --> 01:03:50.570
或者说重新渲染的时候

01:03:50.570 --> 01:03:52.570
这个UserEffect

01:03:52.570 --> 01:03:54.570
每次都会重新调用一次

01:03:54.570 --> 01:03:55.570
对不对

01:03:55.570 --> 01:03:56.570
那这边的话

01:03:56.570 --> 01:03:57.570
就意味着什么

01:03:57.570 --> 01:03:59.570
你这边每次调用是不是都会

01:03:59.570 --> 01:04:01.570
调用一下set interval

01:04:01.570 --> 01:04:02.570
也就是你这边的话

01:04:02.570 --> 01:04:03.570
绑定了什么呢

01:04:03.570 --> 01:04:05.570
绑定了多个及时期

01:04:06.570 --> 01:04:07.570
明白没

01:04:07.570 --> 01:04:08.570
你这边你再看一下吧

01:04:08.570 --> 01:04:10.570
这个我们最早输血的代码

01:04:10.570 --> 01:04:12.570
我们这边打印一下

01:04:13.570 --> 01:04:14.570
就打你这个

01:04:15.570 --> 01:04:16.570
重新刷新一下

01:04:16.570 --> 01:04:18.570
你看我每次点击

01:04:18.570 --> 01:04:19.570
每次点击

01:04:19.570 --> 01:04:22.570
是不是都会执行UserEffect

01:04:22.570 --> 01:04:23.570
也就是说刚才的话

01:04:23.570 --> 01:04:24.570
实际上是什么

01:04:24.570 --> 01:04:25.570
所以每次我们这边

01:04:25.570 --> 01:04:26.570
更新的话

01:04:26.570 --> 01:04:28.570
都执行了这段代码

01:04:28.570 --> 01:04:30.570
执行了这段代码的话

01:04:30.570 --> 01:04:32.570
你就会生成一个新的及时期

01:04:32.570 --> 01:04:33.570
那之前的这个及时期

01:04:33.570 --> 01:04:35.570
又没有删除

01:04:36.570 --> 01:04:37.570
对吧

01:04:37.570 --> 01:04:38.570
那怎么办呢

01:04:38.570 --> 01:04:39.570
怎么办呢

01:04:39.570 --> 01:04:40.570
它这边的话

01:04:40.570 --> 01:04:41.570
支持什么呢

01:04:41.570 --> 01:04:43.570
支持你可以返回一个函数

01:04:44.570 --> 01:04:50.570
在UserEffect中

01:04:50.570 --> 01:04:54.570
可以返回一个函数

01:04:54.570 --> 01:04:56.570
该函数

01:04:56.570 --> 01:04:58.570
我们称之为什么呢

01:04:58.570 --> 01:05:00.570
称之为清理函数

01:05:01.570 --> 01:05:02.570
为什么因为一般就是

01:05:02.570 --> 01:05:03.570
做一些清理操作

01:05:04.570 --> 01:05:05.570
一般就是

01:05:05.570 --> 01:05:08.570
做一些清理操作

01:05:09.570 --> 01:05:10.570
那这个函数

01:05:10.570 --> 01:05:11.570
什么时候执行呢

01:05:11.570 --> 01:05:12.570
注意这个函数

01:05:12.570 --> 01:05:15.570
会在下一次渲染之后

01:05:15.570 --> 01:05:17.570
然后那个就是

01:05:17.570 --> 01:05:19.570
执行副作用函数之前

01:05:20.570 --> 01:05:22.570
该函数

01:05:22.570 --> 01:05:28.570
会在下一次渲染之后

01:05:28.570 --> 01:05:36.570
但是在执行副作用操作之前执行

01:05:37.570 --> 01:05:38.570
也就是我们之前说的

01:05:38.570 --> 01:05:40.570
你这边是不是先渲染

01:05:40.570 --> 01:05:41.570
渲染了

01:05:41.570 --> 01:05:42.570
然后接下来是不是执行

01:05:42.570 --> 01:05:43.570
UserEffect

01:05:43.570 --> 01:05:44.570
执行你的副作用函数

01:05:44.570 --> 01:05:45.570
对不对

01:05:45.570 --> 01:05:47.570
那你如果返回一个新的函数的话

01:05:47.570 --> 01:05:49.570
它的执行顺序就是先渲染

01:05:49.570 --> 01:05:50.570
渲染了之后

01:05:51.570 --> 01:05:53.570
就是返回了函数

01:05:53.570 --> 01:05:55.570
然后再执行你上面的副作用

01:05:56.570 --> 01:05:57.570
好来我们这边

01:05:57.570 --> 01:05:58.570
我们可以来看一下

01:05:58.570 --> 01:06:00.570
我们这边return

01:06:00.570 --> 01:06:03.570
返回一个箭头函数

01:06:03.570 --> 01:06:05.570
大家这边console.nog

01:06:06.570 --> 01:06:07.570
清理函数

01:06:08.570 --> 01:06:10.570
清理函数执行

01:06:11.570 --> 01:06:12.570
我们在上面

01:06:12.570 --> 01:06:13.570
上面的话

01:06:13.570 --> 01:06:15.570
我们这边nog一下

01:06:16.570 --> 01:06:18.570
这边的话就是副作用函数执行

01:06:19.570 --> 01:06:23.160
OK

01:06:23.160 --> 01:06:25.160
我们来看一下这个顺序

01:06:26.160 --> 01:06:27.160
首先第一遍

01:06:27.160 --> 01:06:28.160
副作用函数执行

01:06:28.160 --> 01:06:30.160
清理函数执不执行

01:06:30.160 --> 01:06:31.160
清理函数第一次

01:06:31.160 --> 01:06:32.160
它是不会执行的

01:06:32.160 --> 01:06:34.160
接下来我们这边点击加1

01:06:34.160 --> 01:06:37.160
加1的话是不是会重新进行渲染

01:06:37.160 --> 01:06:38.160
重新进行渲染的话

01:06:38.160 --> 01:06:41.160
它这边首先会先渲染

01:06:41.160 --> 01:06:42.160
渲染了之后

01:06:42.160 --> 01:06:44.160
先执行你的清理函数

01:06:44.160 --> 01:06:45.160
把你上一次

01:06:45.160 --> 01:06:46.160
你执行副作用

01:06:46.160 --> 01:06:48.160
可能会有一些需要清理的操作

01:06:48.160 --> 01:06:50.160
先把它做了

01:06:50.160 --> 01:06:53.160
再重新执行你的副作用操作

01:06:54.160 --> 01:06:55.160
我们这边点击

01:06:56.160 --> 01:06:58.160
你看是不是先执行的

01:06:58.160 --> 01:06:59.160
清理函数

01:06:59.160 --> 01:07:01.160
再执行的是副作用函数

01:07:02.160 --> 01:07:03.160
对不对

01:07:03.160 --> 01:07:04.160
每次都是这样子的

01:07:05.160 --> 01:07:06.160
了解了这个之后

01:07:06.160 --> 01:07:08.160
我们这边就可以怎么做了

01:07:08.160 --> 01:07:10.470
了解了这个之后

01:07:10.470 --> 01:07:12.470
我们这边的话就可以干嘛

01:07:12.470 --> 01:07:14.470
你这里的话就可以

01:07:14.470 --> 01:07:15.470
比较const

01:07:16.470 --> 01:07:18.470
一个stop timer

01:07:19.470 --> 01:07:20.470
对吧

01:07:20.470 --> 01:07:21.470
你每一次

01:07:21.470 --> 01:07:22.470
你要重新渲染

01:07:22.470 --> 01:07:24.470
你要执行新的这个之前

01:07:24.470 --> 01:07:27.470
先把上一次的计时器给我干嘛

01:07:27.470 --> 01:07:29.470
先给我清空

01:07:30.470 --> 01:07:31.470
对吧

01:07:31.470 --> 01:07:32.470
先给我清空

01:07:32.470 --> 01:07:34.470
来我们来看一下

01:07:34.470 --> 01:07:35.470
问题解决秒

01:07:35.470 --> 01:07:36.470
刷新

01:07:37.470 --> 01:07:38.470
每个一秒

01:07:38.470 --> 01:07:39.470
对吧

01:07:39.470 --> 01:07:40.470
我们这边点击

01:07:40.470 --> 01:07:41.470
点击

01:07:41.470 --> 01:07:44.470
这不仍然是每个一秒

01:07:44.470 --> 01:07:45.470
对不对

01:07:45.470 --> 01:07:46.470
并没有像刚才那样子

01:07:46.470 --> 01:07:47.470
一下子就变得很快了

01:07:47.470 --> 01:07:48.470
为什么

01:07:48.470 --> 01:07:50.470
因为每次我们都是把

01:07:50.470 --> 01:07:52.470
把这个上一次的这个计时器

01:07:52.470 --> 01:07:53.470
我们是把它清除了的

01:07:53.470 --> 01:07:54.470
保证什么

01:07:54.470 --> 01:07:55.470
是保证你

01:07:55.470 --> 01:07:57.470
仅仅有一个这个计时器

01:07:59.470 --> 01:08:00.470
对不对

01:08:00.470 --> 01:08:02.470
这就是关于这个清理函数

01:08:02.470 --> 01:08:04.470
你就返回个新函数就可以了

01:08:04.470 --> 01:08:06.470
那你这里面就做一些你的

01:08:06.470 --> 01:08:07.470
清理

01:08:07.470 --> 01:08:08.470
就是清理的工作

01:08:09.470 --> 01:08:11.470
把他放到这边

01:08:13.470 --> 01:08:14.470
这是清理工作

01:08:15.470 --> 01:08:18.040
好

01:08:18.040 --> 01:08:19.040
最后一个

01:08:19.040 --> 01:08:21.040
就UserEffect

01:08:21.040 --> 01:08:22.040
最后一个

01:08:22.040 --> 01:08:23.040
需要知道的就是什么呢

01:08:23.040 --> 01:08:26.040
就是关于这个副作用的这个依赖

01:08:26.040 --> 01:08:27.040
这个也很重要

01:08:28.040 --> 01:08:29.040
这个也很重要

01:08:29.040 --> 01:08:32.040
我们说了就是目前来讲的话

01:08:32.040 --> 01:08:35.040
我们的这个副作用函数

01:08:35.040 --> 01:08:36.040
UserEffect

01:08:36.040 --> 01:08:38.040
他说你每次重新渲染了

01:08:38.040 --> 01:08:40.040
都会重新执行

01:08:40.040 --> 01:08:41.040
对不对

01:08:41.040 --> 01:08:45.460
就目前

01:08:45.460 --> 01:08:48.460
目前我们的这个

01:08:48.460 --> 01:08:50.460
副作用函数

01:08:50.460 --> 01:08:51.460
副作用函数

01:08:51.460 --> 01:08:56.460
每次重新渲染后

01:08:57.460 --> 01:08:58.460
都会什么

01:08:58.460 --> 01:09:01.460
都会重新执行

01:09:02.460 --> 01:09:03.460
对不对

01:09:03.460 --> 01:09:04.460
然后接下来

01:09:04.460 --> 01:09:05.460
有些时候我们是需要对他进行

01:09:05.460 --> 01:09:07.460
设置这个依赖的

01:09:07.460 --> 01:09:10.900
有些时候

01:09:10.900 --> 01:09:15.900
我们是需要设置依赖项的

01:09:15.900 --> 01:09:18.900
特别是就是你在发请求的时候

01:09:19.900 --> 01:09:20.900
特别是发请求的时候

01:09:20.900 --> 01:09:22.900
后面我们这个讲那个

01:09:22.900 --> 01:09:23.900
Router的时候

01:09:23.900 --> 01:09:25.900
到时候我给大家视力一下

01:09:25.900 --> 01:09:27.900
就特别是你这边是干嘛呢

01:09:27.900 --> 01:09:29.900
你这边如果是发送请求

01:09:29.900 --> 01:09:30.900
比如我们这边发送的是一个

01:09:30.900 --> 01:09:31.900
Ajax请求

01:09:32.900 --> 01:09:33.900
比如这边

01:09:35.900 --> 01:09:38.900
发送一个Ajax请求

01:09:38.900 --> 01:09:39.900
那接下来的话

01:09:39.900 --> 01:09:40.900
这边通过

01:09:43.900 --> 01:09:46.790
特别是这种

01:09:46.790 --> 01:09:48.790
他这个漂红是这个找不到

01:09:48.790 --> 01:09:50.790
我们这边只是写一个伟大码

01:09:50.790 --> 01:09:52.790
这边拿到数据了

01:09:52.790 --> 01:09:53.790
对不对

01:09:53.790 --> 01:09:54.790
这边跟我传入数据

01:09:54.790 --> 01:09:55.790
传入数据之后

01:09:55.790 --> 01:09:56.790
然后接下来的话

01:09:56.790 --> 01:09:57.790
我这边的话我干嘛呢

01:09:57.790 --> 01:09:59.790
我比如这边set count

01:09:59.790 --> 01:10:01.790
我就把这个数据进行设置

01:10:02.790 --> 01:10:03.790
进行设置的时候

01:10:03.790 --> 01:10:04.790
是不是必然意味着什么

01:10:04.790 --> 01:10:07.790
是不是意味着你这边要重新渲染

01:10:07.790 --> 01:10:08.790
因为我这边这个试图

01:10:08.790 --> 01:10:10.790
是不是依赖于这个状态

01:10:10.790 --> 01:10:11.790
对不对

01:10:11.790 --> 01:10:12.790
我这个状态更新了

01:10:12.790 --> 01:10:13.790
我试图的话要重新进行渲染

01:10:13.790 --> 01:10:14.790
重新渲染

01:10:14.790 --> 01:10:15.790
接下来

01:10:15.790 --> 01:10:16.790
恐怖的一幕发生了

01:10:16.790 --> 01:10:18.790
接下来他又会干嘛

01:10:18.790 --> 01:10:19.790
是不是又会

01:10:19.790 --> 01:10:21.790
发送请求

01:10:21.790 --> 01:10:22.790
对来发送请求的话

01:10:22.790 --> 01:10:23.790
接下来到这里

01:10:23.790 --> 01:10:24.790
他又重新渲染

01:10:24.790 --> 01:10:25.790
你这边你会发现

01:10:25.790 --> 01:10:27.790
他这边不停的在这个use effect

01:10:27.790 --> 01:10:29.790
不停的在发请求

01:10:29.790 --> 01:10:31.790
不停的在发请求

01:10:31.790 --> 01:10:32.790
所以这边的话

01:10:32.790 --> 01:10:35.790
你一定要设置这个依赖项

01:10:35.790 --> 01:10:37.790
然后如果

01:10:37.790 --> 01:10:40.790
如果想要什么呢

01:10:40.790 --> 01:10:42.790
想要这个副作用

01:10:42.790 --> 01:10:46.790
只行一次

01:10:46.790 --> 01:10:48.790
这个写在第二行嘛

01:10:49.790 --> 01:10:50.790
想要副作用

01:10:50.790 --> 01:10:52.790
只执行一次

01:10:52.790 --> 01:10:53.790
给一个什么呢

01:10:53.790 --> 01:10:55.790
传入第二

01:10:55.790 --> 01:10:56.790
传递

01:10:56.790 --> 01:10:58.790
第二个参数

01:10:58.790 --> 01:10:59.790
第二个参数

01:10:59.790 --> 01:11:02.790
为一个空数组

01:11:02.790 --> 01:11:03.790
这边设置依赖项

01:11:03.790 --> 01:11:04.790
也是传递

01:11:04.790 --> 01:11:05.790
第二个参数

01:11:05.790 --> 01:11:07.790
传递

01:11:07.790 --> 01:11:09.790
第二个参数

01:11:09.790 --> 01:11:11.790
第二个参数什么呢

01:11:11.790 --> 01:11:14.790
第二个参数

01:11:14.790 --> 01:11:17.790
为一个依赖

01:11:18.790 --> 01:11:19.790
OK

01:11:19.790 --> 01:11:21.790
好来我们来给大家演示一下

01:11:21.790 --> 01:11:24.790
首先我们这边演示什么呢

01:11:24.790 --> 01:11:25.790
先演示这个吧

01:11:25.790 --> 01:11:29.870
先演示这个依赖项吧

01:11:33.820 --> 01:11:35.820
一会来演示这个空数组

01:11:36.820 --> 01:11:38.820
先来演示这个依赖

01:11:38.820 --> 01:11:40.820
比如说我这边

01:11:40.820 --> 01:11:42.820
这边的话我写个例子

01:11:42.820 --> 01:11:44.820
比如说来到我们这边

01:11:44.820 --> 01:11:45.820
我们这边的话

01:11:45.820 --> 01:11:47.820
我们多设置几个状态

01:11:47.820 --> 01:11:49.820
这边的话Count1

01:11:49.820 --> 01:11:50.820
Count2

01:11:50.820 --> 01:11:51.820
Count3

01:11:51.820 --> 01:11:52.820
OK这边SetCount1

01:11:52.820 --> 01:11:53.820
SetCount2

01:11:53.820 --> 01:11:54.820
SetCount3

01:11:54.820 --> 01:11:55.820
OK

01:11:55.820 --> 01:11:57.820
这边的话就是Count1

01:12:00.390 --> 01:12:01.390
Count1

01:12:01.390 --> 01:12:04.390
对应的值就是Count1

01:12:04.390 --> 01:12:06.390
大家这边复制一份

01:12:07.390 --> 01:12:08.390
Count2

01:12:08.390 --> 01:12:10.390
Count3

01:12:10.390 --> 01:12:12.390
这边是Count2

01:12:12.390 --> 01:12:14.390
这边是Count2

01:12:14.390 --> 01:12:17.390
好然后下这边是Count3

01:12:17.390 --> 01:12:19.390
Count3

01:12:19.390 --> 01:12:20.390
Count3

01:12:21.390 --> 01:12:22.390
对面Count3

01:12:22.390 --> 01:12:24.390
好我们的这个button

01:12:24.390 --> 01:12:26.390
button我们就要一个就可以了

01:12:26.390 --> 01:12:27.390
就要一个

01:12:27.390 --> 01:12:28.390
一个里面

01:12:28.390 --> 01:12:29.390
然后加在这里面

01:12:29.390 --> 01:12:30.390
我们干嘛呢

01:12:30.390 --> 01:12:31.390
在这里面的话

01:12:31.390 --> 01:12:33.390
我们就把这个setCount1

01:12:33.390 --> 01:12:34.390
我们让Count1干嘛

01:12:34.390 --> 01:12:37.390
Count1进行一个增加

01:12:37.390 --> 01:12:39.390
加加这个Count1

01:12:40.390 --> 01:12:42.390
好然后

01:12:44.390 --> 01:12:45.390
我想想

01:12:45.390 --> 01:12:47.390
这边button还是得三个

01:12:47.390 --> 01:12:49.390
三个一个是把这个Count1变化

01:12:49.390 --> 01:12:51.390
一个是把Count2变化

01:12:51.390 --> 01:12:53.390
好然后我们这边的话就可以直接

01:12:53.390 --> 01:12:55.390
不需要单独写个函数

01:12:55.390 --> 01:12:57.390
我们这边呢就直接

01:12:57.390 --> 01:12:58.390
这样子来写

01:12:58.390 --> 01:13:00.390
这边呢把它变成一个箭头函数

01:13:00.390 --> 01:13:03.390
箭头函数里面这边Count1加加

01:13:03.390 --> 01:13:05.390
好然后加这边的话

01:13:05.390 --> 01:13:08.390
这里是setCount2

01:13:08.390 --> 01:13:10.390
Count2加加

01:13:11.390 --> 01:13:13.390
好然后加这边

01:13:13.390 --> 01:13:15.390
这边是setCount3

01:13:16.390 --> 01:13:18.390
把Count3加加

01:13:18.390 --> 01:13:20.390
这个就不要了

01:13:20.390 --> 01:13:22.390
好我们先来看一下效果

01:13:22.390 --> 01:13:23.390
先来看一下效果

01:13:23.390 --> 01:13:24.390
好在这里

01:13:24.390 --> 01:13:26.390
这里的话是不是就是有三个

01:13:26.390 --> 01:13:27.390
Count1,Count2,Count3

01:13:27.390 --> 01:13:29.390
这个分别是这个是添加Count1的

01:13:29.390 --> 01:13:30.390
对吧

01:13:30.390 --> 01:13:31.390
这个是Count2的

01:13:31.390 --> 01:13:32.390
这个是Count3的

01:13:32.390 --> 01:13:33.390
这个非常简单

01:13:33.390 --> 01:13:35.390
好然后接下来我们在这边

01:13:35.390 --> 01:13:36.390
这边让我们来

01:13:36.390 --> 01:13:38.390
看一下这个副作用的函数

01:13:38.390 --> 01:13:40.390
这边的话就是执行

01:13:42.390 --> 01:13:45.390
执行副作用函数

01:13:45.390 --> 01:13:47.390
好然后接下来你会发现

01:13:47.390 --> 01:13:48.390
一个现象

01:13:48.390 --> 01:13:49.390
什么现象

01:13:50.390 --> 01:13:51.390
第一次是否执行了

01:13:51.390 --> 01:13:52.390
执行完了之后

01:13:52.390 --> 01:13:53.390
然后接下来我这边

01:13:53.390 --> 01:13:55.390
我这个Count1增加

01:13:55.390 --> 01:13:57.390
Count1增加是否会执行副作用函数

01:13:57.390 --> 01:13:58.390
对不对

01:13:58.390 --> 01:13:59.390
Count2

01:13:59.390 --> 01:14:02.390
是否仍然会执行副作用函数

01:14:02.390 --> 01:14:03.390
Count3

01:14:03.390 --> 01:14:05.390
是不是也会执行副作用函数

01:14:05.390 --> 01:14:06.390
对不对

01:14:06.390 --> 01:14:09.390
你无论是添加哪一个

01:14:09.390 --> 01:14:10.390
只要我这边

01:14:10.390 --> 01:14:12.390
让我整个试图更新了

01:14:12.390 --> 01:14:13.390
我这边就会干完了

01:14:13.390 --> 01:14:16.390
就会执行副作用函数

01:14:16.390 --> 01:14:17.390
那这个的话

01:14:17.390 --> 01:14:19.390
你如果就是不能设置依赖象的话

01:14:19.390 --> 01:14:20.390
这一点是很恐怖的

01:14:20.390 --> 01:14:22.390
就会出现我刚才所说的那个现象

01:14:22.390 --> 01:14:25.390
假设我这里面是发送这个请求

01:14:25.390 --> 01:14:26.390
发送请求之后

01:14:26.390 --> 01:14:28.390
然后接下来这儿更新

01:14:28.390 --> 01:14:29.390
更新之后

01:14:29.390 --> 01:14:31.390
然后下这边立马

01:14:31.390 --> 01:14:34.390
立马这边又要执行副作用函数

01:14:34.390 --> 01:14:36.390
就变成一个无限的

01:14:36.390 --> 01:14:38.390
无限的进行一个执行

01:14:38.390 --> 01:14:39.390
OK怎么办

01:14:39.390 --> 01:14:42.390
它这边是可以设置依赖象的

01:14:42.390 --> 01:14:44.390
我比如说我只依赖于什么

01:14:44.390 --> 01:14:46.390
它是个数组

01:14:46.390 --> 01:14:49.390
我只依赖于抗特1

01:14:49.390 --> 01:14:50.390
看到没有

01:14:50.390 --> 01:14:51.390
什么意思

01:14:51.390 --> 01:14:54.390
也就是说只有抗特1变化的时候

01:14:54.390 --> 01:14:58.390
我才会重新执行副作用函数

01:14:58.390 --> 01:15:01.390
如果你是抗特2抗特3

01:15:01.390 --> 01:15:05.390
我这边不会去重新执行副作用函数

01:15:05.390 --> 01:15:07.390
来我们来看一下

01:15:07.390 --> 01:15:08.390
刷新

01:15:08.390 --> 01:15:09.390
第一次它要执行

01:15:09.390 --> 01:15:10.390
对不对

01:15:10.390 --> 01:15:12.390
要这样我点击抗特1

01:15:12.390 --> 01:15:13.390
抗特1的话

01:15:13.390 --> 01:15:15.390
它会重新执行副作用函数

01:15:15.390 --> 01:15:16.390
对吧

01:15:16.390 --> 01:15:19.390
但是你看我这边我点抗特2

01:15:19.390 --> 01:15:22.390
你看抗特2和抗特3

01:15:22.390 --> 01:15:25.390
它就不会再重新去执行副作用函数

01:15:25.390 --> 01:15:29.390
也就是它这边不会再触发UZEFACT

01:15:29.390 --> 01:15:30.390
看到没有

01:15:30.390 --> 01:15:33.390
这个的话就是设置依赖象

01:15:33.390 --> 01:15:34.390
非常重要

01:15:34.390 --> 01:15:35.390
我们后面经常就是

01:15:35.390 --> 01:15:39.700
这边会设置依赖象

01:15:39.700 --> 01:15:43.700
如果我这边只想副作用执行一次

01:15:43.700 --> 01:15:44.700
只想执行一次

01:15:44.700 --> 01:15:46.700
那这边的话很简单

01:15:46.700 --> 01:15:49.700
这边的话我就给它是一个空数组

01:15:49.700 --> 01:15:52.700
代表它不依赖于任何项目

01:15:52.700 --> 01:15:54.700
它就只执行一次

01:15:54.700 --> 01:15:56.700
一般就是我们发请求的时候

01:15:56.700 --> 01:15:58.700
我们这边就会写一个空数组

01:15:58.700 --> 01:15:59.700
对吧

01:15:59.700 --> 01:16:00.700
你发了请求之后这边更新了

01:16:00.700 --> 01:16:03.700
你这边就不要再重新执行它了

01:16:03.700 --> 01:16:05.700
我们这边我们来看一下

01:16:05.700 --> 01:16:06.700
刷新

01:16:06.700 --> 01:16:08.700
你看第一次是不这边

01:16:08.700 --> 01:16:09.700
第一次这边执行了

01:16:09.700 --> 01:16:11.700
执行了之后再加这边

01:16:11.700 --> 01:16:12.700
你看

01:16:12.700 --> 01:16:14.700
怎么随便改变

01:16:14.700 --> 01:16:16.700
这边UZEFACT

01:16:16.700 --> 01:16:18.700
副作用还说是不再执行的

01:16:18.700 --> 01:16:19.700
看到没有

01:16:19.700 --> 01:16:22.700
这边就给一个空数组

01:16:23.700 --> 01:16:27.700
把这个例子放在这里

01:16:27.700 --> 01:16:28.700
放在这

01:16:28.700 --> 01:16:31.700
这就是关于UZEFACT

01:16:31.700 --> 01:16:33.700
整个UZEFACT的话

01:16:33.700 --> 01:16:34.700
也就这些支持点了

01:16:34.700 --> 01:16:37.700
我看大家可以去看一下它的官网

01:16:37.700 --> 01:16:40.700
官网这边UZEFACT

01:16:40.700 --> 01:16:41.700
把这个官网

01:16:41.700 --> 01:16:44.700
你可以把它就是通读一遍

01:16:44.700 --> 01:16:47.700
这边无需清除的EFACT

01:16:47.700 --> 01:16:50.700
然后它这边应该是有个清除的

01:16:50.700 --> 01:16:51.700
在下面这边

01:16:51.700 --> 01:16:54.700
需要清除的EFACT

01:16:54.700 --> 01:16:58.700
然后接下来还就是依赖

01:16:58.700 --> 01:17:00.700
没有讲依赖吗

01:17:00.700 --> 01:17:01.700
应该是讲了的

01:17:01.700 --> 01:17:03.700
大家自己找一找

01:17:03.700 --> 01:17:04.700
应该是讲了的

01:17:04.700 --> 01:17:07.700
就设置这个依赖箱

01:17:07.700 --> 01:17:10.700
下去了把整个文档看一下

01:17:10.700 --> 01:17:13.700
这个文档还有点长

01:17:13.700 --> 01:17:14.700
对吧

01:17:14.700 --> 01:17:16.700
这里不是

01:17:16.700 --> 01:17:17.700
看到没有

01:17:17.700 --> 01:17:19.700
你这个第二个参数

01:17:19.700 --> 01:17:22.700
它仅在抗拆更改的时候

01:17:22.700 --> 01:17:25.700
这边才重新出发

01:17:25.700 --> 01:17:26.700
基本就这几个了

01:17:26.700 --> 01:17:28.700
其他的就没有什么了

01:17:28.700 --> 01:17:32.700
这是关于整个它内置的

01:17:32.700 --> 01:17:34.700
内置的Hook

01:17:34.700 --> 01:17:36.700
最重要的这两个UZEFACT

01:17:37.700 --> 01:17:39.700
后面我们写项目的时候

01:17:39.700 --> 01:17:42.700
我们就会大量的用到这两个Hook

01:17:42.700 --> 01:17:44.700
所以大家提前把这两个的话

01:17:44.700 --> 01:17:45.700
把它用熟

01:17:45.700 --> 01:17:47.700
你不用担心就是

01:17:47.700 --> 01:17:48.700
你现在学习了

01:17:48.700 --> 01:17:50.700
好像没有太多的例子

01:17:50.700 --> 01:17:52.700
我们从下一张开始

01:17:52.700 --> 01:17:54.700
我们下一张就是第二张了

01:17:54.700 --> 01:17:58.700
这一张就是第一张的最后一节课

01:17:58.700 --> 01:18:00.700
整个第一张就七节课

01:18:00.700 --> 01:18:01.700
对吧

01:18:01.700 --> 01:18:02.700
这个就是最后一节课

01:18:02.700 --> 01:18:03.700
大家我们从第二张开始

01:18:03.700 --> 01:18:05.700
我们讲Rotor的时候

01:18:05.700 --> 01:18:07.700
我们就会使用

01:18:07.700 --> 01:18:08.700
就会去使用

01:18:08.700 --> 01:18:12.700
我们会带着大家写一个学生管理系统

01:18:12.700 --> 01:18:14.700
到时候我们就会使用

01:18:14.700 --> 01:18:15.700
多用

01:18:15.700 --> 01:18:16.700
其实就是多用

01:18:16.700 --> 01:18:18.700
反复给大家强调

01:18:18.700 --> 01:18:19.700
这些东西就多用

01:18:19.700 --> 01:18:21.700
用多了你自然而然就熟练了

01:18:21.700 --> 01:18:22.700
对不对

01:18:22.700 --> 01:18:23.700
你不熟练只有一个原因

01:18:23.700 --> 01:18:24.700
你用少了

01:18:24.700 --> 01:18:26.700
明白没有

01:18:26.700 --> 01:18:28.700
这张还有一个

01:18:28.700 --> 01:18:31.700
还有一个就是关于这个自定Hook

01:18:31.700 --> 01:18:33.700
关于这个自定Hook

01:18:33.700 --> 01:18:35.700
这个Hook的话它本质上是什么

01:18:35.700 --> 01:18:37.700
本质上它是函数

01:18:37.700 --> 01:18:39.700
对吧

01:18:39.700 --> 01:18:40.700
本质上它是函数

01:18:40.700 --> 01:18:42.700
函数的话那这边你是可以自定义的

01:18:42.700 --> 01:18:43.700
我们来看一下

01:18:43.700 --> 01:18:46.700
除了使用官方类制的这个Hook

01:18:46.700 --> 01:18:48.700
我们还可以什么呢

01:18:48.700 --> 01:18:50.700
还可以自定义Hook

01:18:50.700 --> 01:18:51.700
那自定义Hook的话

01:18:51.700 --> 01:18:53.700
它本质上其实就是函数

01:18:53.700 --> 01:18:55.700
但是它和函数其实

01:18:55.700 --> 01:18:57.700
还是有一些区别

01:18:57.700 --> 01:18:58.700
这个的话也是就是

01:18:58.700 --> 01:19:01.700
刚开始学习这个自定义Hook

01:19:01.700 --> 01:19:03.700
就很多同学搞不清楚的一个点

01:19:03.700 --> 01:19:04.700
就这个东西

01:19:04.700 --> 01:19:06.700
究竟我这边写个函数

01:19:06.700 --> 01:19:07.700
我这个是一个普通函数

01:19:07.700 --> 01:19:09.700
还是是一个自定义Hook

01:19:09.700 --> 01:19:11.700
因为它官网说

01:19:11.700 --> 01:19:13.700
这个自定Hook本质上其实也是函数

01:19:13.700 --> 01:19:16.700
那究竟有没有一些区别呢

01:19:16.700 --> 01:19:18.700
其实还是有一些区别

01:19:18.700 --> 01:19:19.700
就是你这边

01:19:19.700 --> 01:19:21.700
你如果是自定义的Hook

01:19:21.700 --> 01:19:22.700
你这边的话

01:19:22.700 --> 01:19:23.700
你里面要用到它

01:19:23.700 --> 01:19:25.700
官方类制的一些Hook

01:19:25.700 --> 01:19:26.700
OK

01:19:26.700 --> 01:19:28.700
你这个才算是一个自定Hook

01:19:28.700 --> 01:19:29.700
如果你的这个函数里面

01:19:29.700 --> 01:19:32.700
没有用到它这个类制的这些Hook

01:19:32.700 --> 01:19:33.700
你这个的话

01:19:33.700 --> 01:19:34.700
实际上就是一个什么呢

01:19:34.700 --> 01:19:37.700
实际上就是一个普通的函数

01:19:37.700 --> 01:19:39.700
OK 就是个普通的函数

01:19:39.700 --> 01:19:40.700
你首先你要搞清楚

01:19:40.700 --> 01:19:41.700
它自定义Hook

01:19:41.700 --> 01:19:42.700
它是干什么

01:19:42.700 --> 01:19:43.700
它实际上的话

01:19:43.700 --> 01:19:45.700
是进行一个这个

01:19:45.700 --> 01:19:47.700
业务的拆分

01:19:47.700 --> 01:19:49.700
把你的这个业务拆分成

01:19:49.700 --> 01:19:51.700
一个一个小的这个函数

01:19:51.700 --> 01:19:52.700
但是这些小的函数呢

01:19:52.700 --> 01:19:56.700
它又要进行这个状态的共下

01:19:56.700 --> 01:19:57.700
所以它要求你就是

01:19:57.700 --> 01:19:58.700
你拆分出来这个函数

01:19:58.700 --> 01:20:00.700
你要进行状态的共下

01:20:00.700 --> 01:20:01.700
你这边要用到它

01:20:01.700 --> 01:20:04.700
给你提供的一些这个Hook

01:20:04.700 --> 01:20:06.700
一些勾字函数

01:20:06.700 --> 01:20:07.700
就首先第一点

01:20:07.700 --> 01:20:08.700
第二点的话就是

01:20:08.700 --> 01:20:09.700
一般就是自定Hook

01:20:09.700 --> 01:20:12.700
它是以这个U字开头的

01:20:12.700 --> 01:20:14.700
但这个的话不是一个硬性要求

01:20:14.700 --> 01:20:16.700
它不是一个硬性要求

01:20:16.700 --> 01:20:18.700
它就是向一个约定

01:20:18.700 --> 01:20:19.700
对吧 向一个约定

01:20:19.700 --> 01:20:21.700
我们这边来看个例子

01:20:21.700 --> 01:20:22.700
它官网的话

01:20:22.700 --> 01:20:24.700
这边有个例子

01:20:24.700 --> 01:20:25.700
这里自定Hook

01:20:25.700 --> 01:20:26.700
它这边的话

01:20:26.700 --> 01:20:27.700
是以一个这个

01:20:27.700 --> 01:20:30.700
聊天程序软这个主线

01:20:30.700 --> 01:20:31.700
做的这个例子

01:20:31.700 --> 01:20:33.700
大家可以把这个例子看一下

01:20:33.700 --> 01:20:36.700
或者我这边我来写个例子

01:20:36.700 --> 01:20:37.700
但我这个例子呢

01:20:37.700 --> 01:20:40.700
可能就是没有太大实际的意义

01:20:40.700 --> 01:20:41.700
就这里

01:20:41.700 --> 01:20:44.700
这里的话我们这边

01:20:44.700 --> 01:20:45.700
我们这边的话

01:20:45.700 --> 01:20:47.700
我们自定一个

01:20:47.700 --> 01:20:48.700
我们自定一个叫做

01:20:48.700 --> 01:20:50.700
它说要叫U字开头

01:20:50.700 --> 01:20:52.700
对吧 我们这边U字

01:20:52.700 --> 01:20:56.020
有MyBook

01:20:56.020 --> 01:20:58.020
MyBook.json

01:20:58.020 --> 01:21:00.020
好 然后接下来我们这边

01:21:00.020 --> 01:21:02.020
Import

01:21:02.020 --> 01:21:05.020
UserState

01:21:05.020 --> 01:21:08.020
然后From

01:21:08.020 --> 01:21:09.020
From

01:21:09.020 --> 01:21:11.020
Rect

01:21:11.020 --> 01:21:13.020
Rect

01:21:13.020 --> 01:21:14.020
好 然后接下来这边的话

01:21:14.020 --> 01:21:15.020
这个方形

01:21:15.020 --> 01:21:18.020
方形UserMyBook

01:21:18.020 --> 01:21:23.220
你看 本质上是不是就是个函数啊

01:21:23.220 --> 01:21:25.220
对不对 函数有啥区别呢

01:21:25.220 --> 01:21:27.220
区别就在于你这个函数里面

01:21:27.220 --> 01:21:30.220
有没有用到它的这个Hook

01:21:30.220 --> 01:21:32.220
就是这边要不要维持一些状态

01:21:32.220 --> 01:21:33.220
因为它本质上自定Hook

01:21:33.220 --> 01:21:35.220
其实就是你本身可以写在

01:21:35.220 --> 01:21:37.220
一个主件里面的

01:21:37.220 --> 01:21:38.220
就完全可以写在一个主件里面

01:21:38.220 --> 01:21:39.220
但是你一个主件里面

01:21:39.220 --> 01:21:41.220
可能就是有些业务逻辑太复杂了

01:21:41.220 --> 01:21:42.220
我把它拆出来

01:21:42.220 --> 01:21:44.220
本质上其实就是把它拆出来

01:21:44.220 --> 01:21:45.220
OK

01:21:45.220 --> 01:21:48.220
好 然后接下来我们这边比如说Const

01:21:48.220 --> 01:21:51.220
一个比如说BookName

01:21:51.220 --> 01:21:54.220
然后SetBookName

01:21:54.220 --> 01:21:57.220
等于一个UserState

01:21:57.220 --> 01:21:59.220
比如说这里

01:21:59.220 --> 01:22:01.220
Rect

01:22:01.220 --> 01:22:04.220
学习

01:22:04.220 --> 01:22:05.220
OK

01:22:05.220 --> 01:22:08.220
好 然后接下来我们这边直接Return

01:22:08.220 --> 01:22:10.220
把这两个方法把它Return出去

01:22:10.220 --> 01:22:12.220
其实和那个有点像

01:22:12.220 --> 01:22:15.220
和那个View3的Composition API有点像

01:22:15.220 --> 01:22:17.220
对不对 你看这边是不是有点像

01:22:17.220 --> 01:22:19.220
把这个把它返回出去

01:22:19.220 --> 01:22:20.220
BookName

01:22:20.220 --> 01:22:23.220
然后接下这边SetBookName

01:22:23.220 --> 01:22:26.220
好 大家这边它导出这个自定义的

01:22:26.220 --> 01:22:28.220
ExportDefault

01:22:28.220 --> 01:22:30.220
UseMyBook

01:22:30.220 --> 01:22:33.220
你看我这边它就导出了一个自定义的这个Hook

01:22:33.220 --> 01:22:35.220
为什么说它是一个自定义Hook

01:22:35.220 --> 01:22:37.220
而不是一个自定义函数呢

01:22:37.220 --> 01:22:40.220
因为我这边使用到了它类似的这些Hook

01:22:40.220 --> 01:22:41.220
UserState

01:22:41.220 --> 01:22:42.220
对吧

01:22:42.220 --> 01:22:44.220
好 然后接下来的话在这边

01:22:44.220 --> 01:22:47.220
在这边的话我就来导入

01:22:47.220 --> 01:22:49.220
Import

01:22:49.220 --> 01:22:52.220
UserMyBook

01:22:53.220 --> 01:22:54.220
Front

01:22:54.220 --> 01:22:56.220
当前摸到下面的这个

01:22:56.220 --> 01:22:59.220
好 然后接下来我这边Const

01:22:59.220 --> 01:23:00.220
一个

01:23:00.220 --> 01:23:02.220
这边我们导出的是一个对象

01:23:02.220 --> 01:23:03.220
所以你这边用一个这个对象

01:23:03.220 --> 01:23:04.220
结构

01:23:04.220 --> 01:23:06.220
然后BookName

01:23:06.220 --> 01:23:09.220
然后什么SetBookName

01:23:09.220 --> 01:23:13.220
等于一个UseMyBook

01:23:13.220 --> 01:23:14.220
实际上就在干嘛

01:23:14.220 --> 01:23:15.220
是不是调用这个函数

01:23:15.220 --> 01:23:17.220
对不对 调用这个函数

01:23:17.220 --> 01:23:18.220
就是享受什么

01:23:18.220 --> 01:23:20.220
享受它里面的这个状态

01:23:20.220 --> 01:23:22.220
共享它这边的这个状态

01:23:22.220 --> 01:23:24.220
它自定Hook本身就是做这个事情

01:23:24.220 --> 01:23:26.220
就是把你的业务逻辑把它拆小

01:23:26.220 --> 01:23:27.220
对不对

01:23:27.220 --> 01:23:29.220
就是有些业务逻辑是可以附用的

01:23:29.220 --> 01:23:31.220
单独的提一个Hook出来

01:23:31.220 --> 01:23:34.220
这个Hook里面我用我自己的状态

01:23:34.220 --> 01:23:37.220
好 然后接下来我这边的话

01:23:37.220 --> 01:23:39.220
这边我们把显示一下

01:23:39.220 --> 01:23:41.220
我们这边Return

01:23:41.220 --> 01:23:45.920
Return 这边DIV

01:23:45.920 --> 01:23:48.920
这边我们BookName

01:23:48.920 --> 01:23:49.920
对吧

01:23:49.920 --> 01:23:51.920
我们这边保存一下

01:23:51.920 --> 01:23:53.920
保存了之后再加这边来看一下

01:23:55.920 --> 01:23:56.920
是不是这边有了

01:23:56.920 --> 01:23:57.920
对不对

01:23:57.920 --> 01:23:58.920
我们这边让我们比如说

01:23:58.920 --> 01:24:00.920
再来设置一个输入框

01:24:00.920 --> 01:24:02.920
给我们这边Input

01:24:02.920 --> 01:24:05.680
Input

01:24:05.680 --> 01:24:07.680
我们这边设个输入框Value

01:24:07.680 --> 01:24:10.680
好 我们这边是不是要定义一个这个状态

01:24:10.680 --> 01:24:12.680
对不对 你看这边是个受控组件

01:24:12.680 --> 01:24:13.680
是个受控组件

01:24:13.680 --> 01:24:14.680
好 我们这边Const

01:24:14.680 --> 01:24:16.680
一个Value

01:24:16.680 --> 01:24:18.680
SetValue

01:24:18.680 --> 01:24:20.680
等于一个UserState

01:24:21.680 --> 01:24:23.680
一开始是空

01:24:23.680 --> 01:24:24.680
对吧

01:24:24.680 --> 01:24:25.680
好 然后接下来的话

01:24:25.680 --> 01:24:26.680
我们这边

01:24:26.680 --> 01:24:28.680
这边就是什么

01:24:28.680 --> 01:24:29.680
Value

01:24:29.680 --> 01:24:30.680
对吧

01:24:30.680 --> 01:24:32.680
好 还需要给它绑定一个什么

01:24:32.680 --> 01:24:34.680
绑定一个清计时间

01:24:34.680 --> 01:24:36.680
好 这边的话

01:24:36.680 --> 01:24:38.680
Function

01:24:38.680 --> 01:24:39.680
Change

01:24:39.680 --> 01:24:41.680
ChangeHandle

01:24:42.680 --> 01:24:45.680
这边对应的是清计Handle

01:24:45.680 --> 01:24:47.680
好 清计Handle里面

01:24:47.680 --> 01:24:49.680
把这个拿过去点

01:24:49.680 --> 01:24:50.680
清计Handle里面

01:24:50.680 --> 01:24:51.680
我们这边拿到

01:24:51.680 --> 01:24:54.680
再加这边SetValue

01:24:54.680 --> 01:24:55.680
然后把什么

01:24:55.680 --> 01:24:58.680
1点Parget点Value

01:24:58.680 --> 01:25:00.680
传进去

01:25:00.680 --> 01:25:01.680
那我这边的话

01:25:01.680 --> 01:25:03.680
我这个文本框是不是可以输入

01:25:03.680 --> 01:25:05.680
对不对 可以输入

01:25:05.680 --> 01:25:07.680
好 这边给个DLV吧

01:25:08.680 --> 01:25:09.680
给个DLV

01:25:09.680 --> 01:25:11.680
好 然后回头的话

01:25:11.680 --> 01:25:12.680
我这边再来一个什么呢

01:25:12.680 --> 01:25:14.680
我这边后面再来一个确定按钮

01:25:16.680 --> 01:25:18.680
比如说这边确定

01:25:22.460 --> 01:25:24.460
确定之后再将我这边给它

01:25:24.460 --> 01:25:26.460
绑定一个Click事件

01:25:26.460 --> 01:25:29.460
等于一个ClickHandle

01:25:31.970 --> 01:25:32.970
好 这边

01:25:32.970 --> 01:25:34.970
FunctionClickHandle

01:25:34.970 --> 01:25:35.970
这边做什么事情呢

01:25:35.970 --> 01:25:37.970
这边的话我就修改

01:25:37.970 --> 01:25:38.970
这个BookLame

01:25:38.970 --> 01:25:41.970
就直接SetBookLame

01:25:42.970 --> 01:25:43.970
对应的是什么

01:25:43.970 --> 01:25:44.970
做Value

01:25:45.970 --> 01:25:46.970
对吧

01:25:46.970 --> 01:25:47.970
Value

01:25:47.970 --> 01:25:48.970
好 来我们来看一下效果

01:25:48.970 --> 01:25:49.970
一开始

01:25:49.970 --> 01:25:50.970
一开始的话

01:25:50.970 --> 01:25:51.970
这边是React学习

01:25:51.970 --> 01:25:52.970
这个是来自于什么

01:25:52.970 --> 01:25:53.970
来自于你这个

01:25:53.970 --> 01:25:55.970
我们的这个自定义户客

01:25:55.970 --> 01:25:57.970
对吧 自定义户客你调用之后

01:25:57.970 --> 01:25:59.970
它给你返回一个这个状态值

01:25:59.970 --> 01:26:00.970
好 然后接下来

01:26:00.970 --> 01:26:01.970
我们在这边输入

01:26:01.970 --> 01:26:02.970
比如Vue

01:26:04.970 --> 01:26:05.970
Vue学习

01:26:05.970 --> 01:26:06.970
改一下

01:26:06.970 --> 01:26:07.970
OK

01:26:07.970 --> 01:26:08.970
输入之后

01:26:08.970 --> 01:26:09.970
然后我们点击确定

01:26:09.970 --> 01:26:10.970
点击确定之后

01:26:10.970 --> 01:26:11.970
它这边会做什么事情

01:26:11.970 --> 01:26:12.970
它是不是会调用你这个

01:26:12.970 --> 01:26:13.970
自定义户客

01:26:13.970 --> 01:26:15.970
这边给你返回的这个方法

01:26:16.970 --> 01:26:17.970
对吧 接下来

01:26:17.970 --> 01:26:18.970
我们把这个新的这个值

01:26:18.970 --> 01:26:19.970
传给这个方法

01:26:19.970 --> 01:26:20.970
从而改变了什么

01:26:20.970 --> 01:26:23.970
改变我们这个自定义户客

01:26:23.970 --> 01:26:25.970
它这边的一个状态值

01:26:25.970 --> 01:26:26.970
对吧

01:26:26.970 --> 01:26:28.970
好 那我们这边确定

01:26:28.970 --> 01:26:29.970
这边是不是变了

01:26:29.970 --> 01:26:30.970
看到没有

01:26:30.970 --> 01:26:32.970
这就是一个自定义户客

01:26:32.970 --> 01:26:33.970
自定义户客的话

01:26:33.970 --> 01:26:34.970
在后面的话

01:26:34.970 --> 01:26:35.970
其实用了很多的

01:26:35.970 --> 01:26:37.970
当我们要把这个业务

01:26:37.970 --> 01:26:39.970
进行一个拆分的时候

01:26:39.970 --> 01:26:41.970
我们就会用到自定义户客

01:26:41.970 --> 01:26:42.970
自定义户客的话

01:26:42.970 --> 01:26:45.970
和普通函数的区别就在这里

01:26:45.970 --> 01:26:46.970
知道吧 就在这里

01:26:46.970 --> 01:26:49.970
最开始你学习这个自定义户客

01:26:49.970 --> 01:26:51.970
你可能会有一些疑惑

01:26:51.970 --> 01:26:53.970
这玩意儿和普通函数有啥区别

01:26:53.970 --> 01:26:54.970
对不对 区别就在于

01:26:54.970 --> 01:26:57.970
你有没有用它类制的这些户客

01:26:57.970 --> 01:26:58.970
你如果使用了

01:26:58.970 --> 01:27:00.970
那你这个就也是一个自定义户客

01:27:00.970 --> 01:27:01.970
你如果没有使用

01:27:01.970 --> 01:27:03.970
你如果就是一个普普通通的

01:27:03.970 --> 01:27:04.970
对吧 你这边没有使用

01:27:04.970 --> 01:27:06.970
你这边就是一个普通的

01:27:06.970 --> 01:27:08.970
把这个注射掉

01:27:08.970 --> 01:27:10.970
OK 你这边就是一个普通

01:27:10.970 --> 01:27:12.970
这边有个对象

01:27:12.970 --> 01:27:13.970
Const

01:27:13.970 --> 01:27:15.970
比较Book

01:27:15.970 --> 01:27:17.970
BookName

01:27:17.970 --> 01:27:18.970
等于一个1

01:27:18.970 --> 01:27:20.970
随随便写

01:27:20.970 --> 01:27:23.970
Const的一个SetName

01:27:23.970 --> 01:27:25.970
等于一个2

01:27:25.970 --> 01:27:27.970
随便写

01:27:27.970 --> 01:27:28.970
这边的话就是

01:27:28.970 --> 01:27:29.970
你这边的话

01:27:29.970 --> 01:27:31.970
你就不能称之为是一个自定义户客

01:27:31.970 --> 01:27:32.970
你这个就是一个什么

01:27:32.970 --> 01:27:34.970
就是一个普普通通的函数

01:27:34.970 --> 01:27:35.970
对不对 你这边其实

01:27:35.970 --> 01:27:37.970
就导出了一个普通函数而已

01:27:37.970 --> 01:27:38.970
没有没有

01:27:38.970 --> 01:27:40.970
所以区别就在这

01:27:40.970 --> 01:27:41.970
区别就在这

01:27:41.970 --> 01:27:42.970
OK

01:27:42.970 --> 01:27:45.970
这个其实在StackOverflow上面

01:27:45.970 --> 01:27:47.970
有那个相关的讨论

01:27:47.970 --> 01:27:49.970
这边我没有放

01:27:49.970 --> 01:27:51.970
我下次我把那个链接放到这

01:27:51.970 --> 01:27:54.970
就是在StackOverflow上面

01:27:54.970 --> 01:27:56.970
也有广泛的讨论

01:27:56.970 --> 01:27:58.970
就有的很多人都分不清楚

01:27:58.970 --> 01:28:00.970
我这个自定义户客和普通函数

01:28:00.970 --> 01:28:01.970
究竟有什么区别

01:28:01.970 --> 01:28:03.970
下面你看StackOverflow下面

01:28:03.970 --> 01:28:05.970
就有很多回答

01:28:05.970 --> 01:28:06.970
究竟什么区别

01:28:06.970 --> 01:28:08.970
区别其实就是这个

01:28:08.970 --> 01:28:09.970
就这个

01:28:09.970 --> 01:28:10.970
OK

01:28:10.970 --> 01:28:15.050
把这个带网放在这里

01:28:15.050 --> 01:28:17.050
这边

01:28:17.050 --> 01:28:19.050
这边是我们的副组件

01:28:19.050 --> 01:28:21.050
对吧 这是我们的APP

01:28:21.050 --> 01:28:24.050
APP.js倉

01:28:24.050 --> 01:28:26.050
这是

01:28:26.050 --> 01:28:29.050
APP.js倉

01:28:29.050 --> 01:28:31.050
好 这个是我们的自定义户客

01:28:31.050 --> 01:28:35.050
UserMyBook

01:28:35.050 --> 01:28:41.750
UserMyBook

01:28:41.750 --> 01:28:43.750
把他放到这里

01:28:43.750 --> 01:28:46.750
OK 这是关于自定义户客

01:28:46.750 --> 01:28:49.750
好 其他的话就没什么了

01:28:49.750 --> 01:28:51.750
我们这边也讲了一个半小时了

01:28:51.750 --> 01:28:52.750
是吧

01:28:52.750 --> 01:28:55.750
相当于大学里面的一堂大课了

01:28:56.750 --> 01:28:57.750
这节课的话

01:28:57.750 --> 01:28:59.750
咱们就把整个这个户客

01:28:59.750 --> 01:29:01.750
给大家介绍完毕了

01:29:01.750 --> 01:29:02.750
这节课完了之后

01:29:02.750 --> 01:29:03.750
咱们整个第一章

01:29:03.750 --> 01:29:05.750
来我们来回顾一下

01:29:05.750 --> 01:29:06.750
这边

01:29:06.750 --> 01:29:08.750
整个这个第一章

01:29:08.750 --> 01:29:09.750
第一章的话

01:29:09.750 --> 01:29:10.750
我们也就告一段落了

01:29:10.750 --> 01:29:12.750
整个第一章其实就

01:29:12.750 --> 01:29:13.750
七节课

01:29:13.750 --> 01:29:14.750
对吧

01:29:14.750 --> 01:29:15.750
一共就七节课

01:29:15.750 --> 01:29:16.750
我回头把这个大干

01:29:16.750 --> 01:29:17.750
我把它更新一下

01:29:17.750 --> 01:29:19.750
一共也就七节课

01:29:19.750 --> 01:29:21.750
我们从下节课开始

01:29:21.750 --> 01:29:23.750
我们就正式进入到我们的第二章

01:29:23.750 --> 01:29:24.750
也就是我们现在的话

01:29:24.750 --> 01:29:26.750
这个核心概念就讲完了

01:29:26.750 --> 01:29:28.750
你回头你这边你可以看一下

01:29:28.750 --> 01:29:29.750
有人可以看一下

01:29:29.750 --> 01:29:30.750
核心概念

01:29:30.750 --> 01:29:31.750
是不是这个讲了

01:29:31.750 --> 01:29:32.750
对 这个讲了

01:29:32.750 --> 01:29:33.750
这个讲了

01:29:33.750 --> 01:29:34.750
对吧 时间处理

01:29:34.750 --> 01:29:36.750
这两个我是让你们下去自己看的

01:29:36.750 --> 01:29:37.750
这个讲了

01:29:37.750 --> 01:29:38.750
这个讲了

01:29:38.750 --> 01:29:39.750
对不对

01:29:39.750 --> 01:29:40.750
整个这个核心概念

01:29:40.750 --> 01:29:41.750
其实就已经讲完了

01:29:41.750 --> 01:29:42.750
还包含什么呢

01:29:42.750 --> 01:29:43.750
还包含这个户客

01:29:43.750 --> 01:29:45.750
户客我们这边主要讲的是什么

01:29:45.750 --> 01:29:47.750
主要讲的就这两个

01:29:47.750 --> 01:29:48.750
对吧

01:29:48.750 --> 01:29:49.750
主要是这两个

01:29:49.750 --> 01:29:50.750
剩下其他的的话

01:29:50.750 --> 01:29:51.750
我们后面再说

01:29:51.750 --> 01:29:53.750
后面有些户客

01:29:53.750 --> 01:29:54.750
我们用到了

01:29:54.750 --> 01:29:55.750
我给大家提一下

01:29:55.750 --> 01:29:57.750
有些的话放到那个就业课里面

01:29:57.750 --> 01:29:59.750
就没有必要现在就

01:29:59.750 --> 01:30:00.750
挨着再介绍

01:30:00.750 --> 01:30:02.750
有些现在介绍是没有意思的

01:30:02.750 --> 01:30:04.750
比如那个什么User

01:30:04.750 --> 01:30:05.750
现在介绍的话

01:30:05.750 --> 01:30:06.750
你也听不懂

01:30:06.750 --> 01:30:07.750
对不对

01:30:07.750 --> 01:30:08.750
那个要讲了

01:30:08.750 --> 01:30:09.750
Ridax之后你才听得懂

01:30:09.750 --> 01:30:10.750
OK

01:30:11.750 --> 01:30:13.750
好 这个是关于户客

01:30:13.750 --> 01:30:14.750
OK

01:30:14.750 --> 01:30:15.750
大家下来的话

01:30:15.750 --> 01:30:16.750
把这一张可以自己

01:30:18.750 --> 01:30:19.750
在这里

01:30:19.750 --> 01:30:20.750
大家下来的话

01:30:20.750 --> 01:30:22.750
可以把这一张自己再看一看

01:30:22.750 --> 01:30:23.750
好吧

01:30:23.750 --> 01:30:25.750
把有些代码的话自己抄一抄

01:30:25.750 --> 01:30:27.750
好 这期课就到这里

01:30:27.750 --> 01:30:28.750
再见

