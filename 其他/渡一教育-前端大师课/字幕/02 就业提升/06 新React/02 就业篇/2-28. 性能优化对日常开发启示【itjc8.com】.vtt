WEBVTT

00:00.110 --> 00:03.110
这节课的话 我们临时加一节课

00:03.110 --> 00:08.110
这节课的话叫做性能优化对日常开发的一个启示

00:08.110 --> 00:12.110
这边的话 我已经把对应的文档已经写好了

00:12.110 --> 00:14.110
带着大家来看一下

00:14.110 --> 00:18.110
来说一下就是这边我们之前学了关于性能优化

00:18.110 --> 00:20.110
它内部的性能优化策略

00:20.110 --> 00:25.110
它这个对我们日常开发会有什么样的启示

00:25.110 --> 00:31.110
在前面的话 我已经学习了react内置的性能优化的相关策略

00:31.110 --> 00:33.110
内置的话有几个

00:33.110 --> 00:35.110
内置的话是不是就两个

00:35.110 --> 00:37.110
对吧 一个是eager state

00:37.110 --> 00:40.110
一个是什么呢 一个是build out

00:40.110 --> 00:42.110
这两个的话我们都讲了的

00:42.110 --> 00:44.110
其中的话eager state

00:44.110 --> 00:49.110
这个的话要满足的条件的话 它其实是比较苛刻的

00:49.110 --> 00:52.110
对不对 所以你在开发的时候你不需要去强求

00:52.110 --> 00:55.110
那么作为我们这个作为一个react开发者

00:55.110 --> 01:01.110
我们应该干嘛呢 我们应该追求就是写出满足build out策略的这种逐渐

01:01.110 --> 01:03.110
OK

01:03.110 --> 01:06.110
好 当我们聊到这个性能优化的时候

01:06.110 --> 01:08.110
那我们经常会想到什么呢

01:08.110 --> 01:11.110
经常会想到就是使用性能优化相关的这个API

01:11.110 --> 01:14.110
比如 use memo, use callback 这些

01:14.110 --> 01:18.110
当然关于这些性能优化这个相关的这种API

01:18.110 --> 01:21.110
它背后的这个原理我们之前也说过了

01:21.110 --> 01:23.110
它背后的原理是不是其实也是为了干嘛

01:23.110 --> 01:26.110
是不是也是为了命中这个build out策略

01:26.110 --> 01:28.110
对不对 它把那个比较

01:28.110 --> 01:31.110
那个new props 和那个old props 比较

01:31.110 --> 01:34.110
改成了什么呢 改成了这个前比较

01:34.110 --> 01:40.110
对不对 让你能够更加的容易的命中这个build out策略

01:40.110 --> 01:43.110
好 但是当我们深入学习这个build out策略原理之后

01:43.110 --> 01:44.110
我们就会知道

01:44.110 --> 01:48.110
就你即使不使用这个性能优化的这个API

01:48.110 --> 01:51.110
你只要满足一定的这个条件

01:51.110 --> 01:54.110
你其实也能命中build out策略的

01:54.110 --> 01:57.110
好 比如说我们这边来看个例子

01:57.110 --> 01:59.110
你看这边有段代码

01:59.110 --> 02:02.110
这边的话首先把这段代码拿过来吧

02:02.110 --> 02:04.110
放到我们这边

02:04.110 --> 02:07.770
放到这边

02:07.770 --> 02:11.770
好 首先这边会有两个组件

02:11.770 --> 02:14.770
有两个组件 一个是挂载的这个APP

02:14.770 --> 02:17.770
一个叫做expensive come

02:17.770 --> 02:19.770
公明是以这个组件的话

02:19.770 --> 02:21.770
这个渲染是很好识的

02:21.770 --> 02:24.770
该组件

02:24.770 --> 02:31.770
该组件的渲染是非常耗时的

02:31.770 --> 02:32.770
ok

02:32.770 --> 02:34.770
好 然后接下来在APP里面

02:34.770 --> 02:36.770
APP里面我们这边有一个这个input

02:36.770 --> 02:37.770
有个输入框

02:37.770 --> 02:38.770
对吧 输入框

02:38.770 --> 02:39.770
然后接下来的话

02:39.770 --> 02:41.770
这边就APP里面

02:41.770 --> 02:44.770
自己维护了一组数据

02:45.770 --> 02:48.770
ok 就这个nam数据

02:48.770 --> 02:49.770
好 这边有个input

02:49.770 --> 02:50.770
input的话

02:50.770 --> 02:52.770
然后在这边你可以就是去修改它

02:52.770 --> 02:53.770
可以去修改它

02:53.770 --> 02:55.770
然后在这边是显示

02:55.770 --> 02:57.770
显示这个当前的这个nam是多少

02:57.770 --> 02:58.770
这个很简单

02:58.770 --> 03:00.770
对吧 这个一个input框

03:00.770 --> 03:03.770
这边调用那个upnam

03:03.770 --> 03:05.770
这个updatenam去修改

03:05.770 --> 03:06.770
修改之后

03:06.770 --> 03:08.770
然后在这边

03:08.770 --> 03:10.770
这个这边就是显示出来

03:10.770 --> 03:12.770
这边当前的这个nam是多少

03:12.770 --> 03:14.770
这边当前的这个nam是多少

03:14.770 --> 03:15.770
好 关键在于什么呢

03:15.770 --> 03:17.770
关键在于这里 同学们

03:17.770 --> 03:19.770
看一下这里

03:19.770 --> 03:21.770
这里的话我还渲染了一个什么

03:21.770 --> 03:23.770
我还渲染了一个植主键

03:23.770 --> 03:24.770
对不对

03:24.770 --> 03:25.770
这个植主键的话

03:25.770 --> 03:27.770
就是这个expansive column

03:27.770 --> 03:29.770
这个expansive column

03:29.770 --> 03:31.770
我们这边把它展开看一下

03:31.770 --> 03:33.770
它这边返回倒是返回没啥

03:33.770 --> 03:35.770
对吧 就返回一个p

03:35.770 --> 03:37.770
关键是它这边的话会有个什么

03:37.770 --> 03:40.770
这边是不是会有个耗时的这个操作

03:40.770 --> 03:41.770
对不对 我们专门写了一个while

03:41.770 --> 03:43.770
这个while的话

03:43.770 --> 03:45.770
就是模拟这种耗时的这种渲染

03:45.770 --> 03:47.770
好 那么接下来我们来看一下

03:47.770 --> 03:49.770
如果你这样子写

03:49.770 --> 03:51.770
会出现什么样的情况

03:51.770 --> 03:53.770
我们这边

03:53.770 --> 03:55.770
我们过来

03:55.770 --> 03:57.770
好 你看这边

03:57.770 --> 03:59.770
好 比如说我这边输入

03:59.770 --> 04:01.770
我输入123

04:01.770 --> 04:03.770
你看 是感觉一卡一卡的

04:03.770 --> 04:05.770
对吧 我输入456

04:05.770 --> 04:07.770
我输入789

04:07.770 --> 04:09.770
你看

04:09.770 --> 04:11.770
三一点

04:11.770 --> 04:13.770
你看 是不是始终感觉一卡一卡的

04:13.770 --> 04:15.770
对不对 包括刚才大家也看出来了

04:15.770 --> 04:17.770
所以说你这种情况下的话

04:17.770 --> 04:19.770
你这个expansive column

04:19.770 --> 04:21.770
它是一个非常耗时的这个主键

04:21.770 --> 04:23.770
如果你像这样子来写的话

04:23.770 --> 04:25.770
它是不是就会存在

04:25.770 --> 04:27.770
性能上面的这个问题

04:27.770 --> 04:29.770
对不对

04:29.770 --> 04:31.770
它就会存在性能上面的问题

04:31.770 --> 04:33.770
好 回到我们这边这个课件

04:33.770 --> 04:35.770
好 在上面的例子中

04:35.770 --> 04:37.770
APP是挂载的主键

04:37.770 --> 04:39.770
那由于这个expansive column

04:39.770 --> 04:41.770
它在Render的时候

04:41.770 --> 04:43.770
它会执行什么呢

04:43.770 --> 04:45.770
它会执行一个耗时的操作

04:45.770 --> 04:47.770
好 然后接下来你在这个

04:47.770 --> 04:49.770
Input输入框里面

04:49.770 --> 04:51.770
你输入内容的时候

04:51.770 --> 04:53.770
它就会发生什么呢

04:53.770 --> 04:55.770
就会发生明显的卡顿

04:55.770 --> 04:57.770
这个卡顿的话

04:57.770 --> 04:59.770
我们刚才是不是也看到了

04:59.770 --> 05:01.770
对不对 为什么会发生这个卡顿呢

05:01.770 --> 05:03.770
原因很简单

05:03.770 --> 05:05.770
因为你的expansive column

05:05.770 --> 05:07.770
Bailout策略

05:07.770 --> 05:09.770
对不对

05:09.770 --> 05:11.770
它没有命中

05:11.770 --> 05:13.770
你每次这边重新输入的时候

05:13.770 --> 05:15.770
它的话是不是也要重新渲染

05:15.770 --> 05:17.770
对不对

05:17.770 --> 05:19.770
每次你这边输入

05:19.770 --> 05:21.770
你这边Input要重新渲染

05:21.770 --> 05:23.770
Input的重新渲染

05:23.770 --> 05:25.770
再加这边它也要重新渲染

05:25.770 --> 05:27.770
好 那我们这边可以来研究一下

05:27.770 --> 05:29.770
为什么没有命中Bailout策略

05:29.770 --> 05:31.770
那么在这个APP主键中

05:31.770 --> 05:33.770
它会触发什么呢

05:33.770 --> 05:35.770
就这个APP主键里面

05:35.770 --> 05:37.770
它是不是会更新

05:37.770 --> 05:39.770
对不对 你这边在调用

05:39.770 --> 05:41.770
调用UpdateName来更新这个Name

05:41.770 --> 05:43.770
好 它也更新的话

05:43.770 --> 05:45.770
那你的APP肯定是不会命中Bailout策略

05:45.770 --> 05:47.770
也就是说你整个APP主键

05:47.770 --> 05:49.770
它是不是一定会重新渲染呢

05:49.770 --> 05:51.770
对不对

05:51.770 --> 05:53.770
那一定会重新渲染的话

05:53.770 --> 05:55.770
那在这个expansive column里面

05:55.770 --> 05:57.770
它去判断是否能够命中

05:57.770 --> 05:59.770
这个Bailout策略的时候

05:59.770 --> 06:01.770
它有一条

06:01.770 --> 06:03.770
叫做什么 是不是就是你的

06:03.770 --> 06:05.770
OtherProps

06:05.770 --> 06:07.770
要等于NewProps

06:07.770 --> 06:09.770
对不对 我们说这一条的话

06:09.770 --> 06:11.770
你如果你的副主键已经重新渲染了

06:11.770 --> 06:13.770
那你只主键的话

06:13.770 --> 06:15.770
这一条你不要想命中

06:15.770 --> 06:17.770
对不对 因为你副主键的话

06:17.770 --> 06:19.770
每次都是重新渲染的

06:19.770 --> 06:21.770
那那个Props一定是

06:21.770 --> 06:23.770
就是它的那个引用地址是不一样的

06:23.770 --> 06:25.770
所以你副主键如果重新渲染了

06:25.770 --> 06:27.770
只主键的话你不要想能够命中

06:27.770 --> 06:29.770
OK 说这边的话

06:29.770 --> 06:31.770
都是重新扔掉的

06:31.770 --> 06:33.770
说这个只主键

06:33.770 --> 06:35.770
这个条件它并不会满足

06:35.770 --> 06:37.770
OK

06:37.770 --> 06:39.770
好 那接下来我们为了就是

06:39.770 --> 06:41.770
使这个expansive column

06:41.770 --> 06:43.770
能够命中Bailout策略

06:43.770 --> 06:45.770
那我们怎么办呢

06:45.770 --> 06:47.770
好 我们这边的话就可以将这个NAM

06:47.770 --> 06:49.770
与NAM相关的这个仕途

06:49.770 --> 06:51.770
进行一个分离

06:51.770 --> 06:53.770
OK 我们这边呢

06:53.770 --> 06:55.770
我们单独分离一个这个input

06:55.770 --> 06:57.770
主键出来

06:57.770 --> 06:59.770
方形

06:59.770 --> 07:01.770
方形input

07:01.770 --> 07:03.770
好 然后接下来

07:03.770 --> 07:05.770
数据的维护就不再放在

07:05.770 --> 07:07.770
APP主键里面

07:07.770 --> 07:09.770
怎么样 放在这个input里面

07:09.770 --> 07:11.770
好 大家包括这一块

07:11.770 --> 07:13.770
这一块的话我们也就

07:13.770 --> 07:20.220
这边是return

07:20.220 --> 07:22.220
这边

07:22.220 --> 07:24.220
好 我们就放到这里

07:24.220 --> 07:26.220
好 然后接下来这边

07:26.220 --> 07:28.220
这边我们就使用这个input

07:28.220 --> 07:30.220
OK

07:30.220 --> 07:32.220
我们这边就使用这个input

07:32.220 --> 07:34.220
你看我们这边稍微做了些修改

07:34.220 --> 07:36.220
之前的话我们的数据是在APP里面

07:36.220 --> 07:38.220
所维护的

07:38.220 --> 07:40.220
对不对 好 然后加这边这个input和p

07:40.220 --> 07:42.220
之前都是写在APP里面的

07:42.220 --> 07:44.220
现在的话我们把这个部分

07:44.220 --> 07:46.220
单独把它提取出来

07:46.220 --> 07:48.220
单独做了一个input主键

07:48.220 --> 07:50.220
OK 好 那我们接下来

07:50.220 --> 07:52.220
我们来看一下 还卡不卡

07:52.220 --> 07:54.220
好 你看 是不是非常流畅

07:54.220 --> 07:56.220
对不对

07:56.220 --> 07:58.220
非常流畅

07:58.220 --> 08:00.220
那为什么呢

08:00.220 --> 08:02.220
为什么这么流畅呢

08:02.220 --> 08:04.220
我们这边 回到这里

08:04.220 --> 08:06.220
回到这边

08:06.220 --> 08:08.220
这边的话我们单独提取出来了一个

08:08.220 --> 08:10.220
那这边的话

08:10.220 --> 08:12.220
那你这边这个数据就没有在什么

08:12.220 --> 08:14.220
是没有在APP里面所维护了

08:14.220 --> 08:16.220
你的数据是在哪里

08:16.220 --> 08:18.220
是不是在这个input这个主键里面维护呢

08:18.220 --> 08:20.220
对不对 相当于

08:20.220 --> 08:22.220
我们就是把这个变化的部分

08:22.220 --> 08:24.220
我们和这个就是变化

08:24.220 --> 08:26.220
这个是变化的部分

08:26.220 --> 08:28.220
我们把它干嘛呢

08:28.220 --> 08:30.220
我们是把它分离开了呀

08:30.220 --> 08:32.220
对不对 分离开了

08:32.220 --> 08:34.220
来我们来看一下下面的描述

08:34.220 --> 08:36.220
在上面的代码中

08:36.220 --> 08:38.220
我们把APP这个state变化

08:38.220 --> 08:40.220
调整到了哪里

08:40.220 --> 08:42.220
调整到了这个input这个主键里面

08:42.220 --> 08:44.220
对不对 那你这个APP自然就

08:44.220 --> 08:46.220
不再存在这个state变化

08:46.220 --> 08:48.220
好 那你这个APP

08:48.220 --> 08:50.220
不存在这个state变化

08:50.220 --> 08:52.220
那你APP它就会干嘛

08:52.220 --> 08:54.220
APP这个主键是不是就可以民众

08:54.220 --> 08:56.220
对不对 因为这个APP

08:56.220 --> 08:58.220
APP再往上走的话就是那个

08:58.220 --> 09:00.220
fiberroot那个节点

09:00.220 --> 09:02.220
那个肯定是就能够民众的

09:02.220 --> 09:04.220
所以这边那APP

09:04.220 --> 09:06.220
它能够民众这个build out

09:06.220 --> 09:08.220
那你APP能够民众build out

09:08.220 --> 09:10.220
那自然而然你这个expensive come

09:10.220 --> 09:12.220
是不是也可以民众这个build out

09:12.220 --> 09:14.220
对不对 OK

09:14.220 --> 09:16.220
那回头它这边就会干嘛

09:16.220 --> 09:18.220
它民众了这个build out策略之后

09:18.220 --> 09:20.220
它就可以直接干嘛

09:20.220 --> 09:22.220
直接服用对不对

09:22.220 --> 09:24.220
直接执行耗时的这个Render

09:24.220 --> 09:26.220
你看

09:26.220 --> 09:28.220
当你掌握了就是这个

09:28.220 --> 09:30.220
它性能优化策略

09:30.220 --> 09:32.220
背后的这些东西之后

09:32.220 --> 09:34.220
有些时候即便你不使用

09:34.220 --> 09:36.220
这个性能优化的这个APP

09:36.220 --> 09:38.220
你也知道就是某些地方

09:38.220 --> 09:40.220
应该如何进行优化

09:40.220 --> 09:42.220
对不对

09:42.220 --> 09:44.220
好 然后下面的话

09:44.220 --> 09:46.220
我还举了个例子

09:46.220 --> 09:48.220
我们来看一下

09:48.220 --> 09:50.220
现在的话我们考虑另外一种情况

09:50.220 --> 09:52.220
另外一种情况是什么呢

09:52.220 --> 09:54.220
就是在如下的组建中

09:54.220 --> 09:56.220
现在的话这个DIV点title

09:56.220 --> 09:58.220
DIV的title这边有个DIV

09:58.220 --> 10:00.220
这边不再是像刚才一样了

10:00.220 --> 10:02.220
刚才这边就是一个空了

10:02.220 --> 10:04.220
现在的话这边是有个DIV

10:04.220 --> 10:06.220
它有个title属性

10:06.220 --> 10:08.220
它是依赖这个Number

10:08.220 --> 10:10.220
依赖这个Number

10:10.220 --> 10:12.220
那你这样子的话就感觉没有办法分离了

10:12.220 --> 10:14.220
对不对 我把这个例子

10:14.220 --> 10:16.220
我把他过来

10:16.220 --> 10:18.220
放到我们这边

10:18.220 --> 10:20.220
这个注释掉吧

10:20.220 --> 10:22.220
注释掉 我放到

10:22.220 --> 10:24.220
4厘2

10:24.220 --> 10:26.220
4厘2

10:26.220 --> 10:28.220
刚才那个是4厘1

10:28.220 --> 10:32.620
4厘1

10:32.620 --> 10:34.620
好 我来看一下4厘2

10:34.620 --> 10:36.620
好

10:36.620 --> 10:38.620
4厘2当中的话

10:38.620 --> 10:40.620
这边有个DIV

10:40.620 --> 10:42.620
有个DIV人家这边有个Number

10:42.620 --> 10:44.620
那接下来的话 这边的话

10:44.620 --> 10:46.620
数据是不是又重新在这个APP里面维护了

10:46.620 --> 10:48.620
对不对

10:48.620 --> 10:50.620
在这个4厘中

10:50.620 --> 10:52.620
数据

10:52.620 --> 10:54.620
重新

10:54.620 --> 10:56.620
又在什么呢 又在这个APP

10:56.620 --> 10:58.620
组建中

10:58.620 --> 11:00.620
APP组建中

11:00.620 --> 11:02.620
进行维护了

11:02.620 --> 11:04.620
而且

11:04.620 --> 11:06.620
而且还不像什么呢

11:06.620 --> 11:08.620
不像上面的例子那样

11:10.620 --> 11:12.620
就是可以分离出去

11:12.620 --> 11:16.950
可以分离出去

11:16.950 --> 11:18.950
对不对 我们上一个例子的话

11:18.950 --> 11:20.950
这边你直接把这一块直接

11:20.950 --> 11:22.950
把它分离出去 是不是单独

11:22.950 --> 11:24.950
做一个组建就可以了

11:24.950 --> 11:26.950
然后接下来你的数据的话

11:26.950 --> 11:28.950
就是在对应的这个组建里面维护

11:28.950 --> 11:30.950
但是现在的话

11:30.950 --> 11:32.950
我这边有个DIV

11:32.950 --> 11:34.950
DIV这边他也依赖这个数据

11:34.950 --> 11:36.950
说我这个数据的话

11:36.950 --> 11:38.950
就只得在这个APP里面进行这个维护

11:38.950 --> 11:40.950
但是你现在这样子写的话

11:40.950 --> 11:42.950
就又会出现刚才的问题

11:42.950 --> 11:44.950
看一下

11:44.950 --> 11:46.950
你看123

11:46.950 --> 11:48.950
是吧 一卡一卡的

11:48.950 --> 11:50.950
我先删除

11:50.950 --> 11:52.950
卡住了

11:52.950 --> 11:54.950
那接下来这种的话怎么办

11:54.950 --> 11:56.950
这种的话

11:56.950 --> 11:58.950
实际上你还是可以想办法

11:58.950 --> 12:00.950
你上面的话没办法

12:00.950 --> 12:02.950
分离那接下来你可以去干嘛

12:02.950 --> 12:04.950
你是不是可以去分离这个下面

12:04.950 --> 12:06.950
对不对 你可以把它

12:06.950 --> 12:08.950
单独的把它提出去

12:08.950 --> 12:10.950
我们这边来看一下

12:10.950 --> 12:12.950
我们这边可以干嘛呢

12:12.950 --> 12:14.950
我们这边可以通过这个

12:14.950 --> 12:16.950
组织的方式

12:16.950 --> 12:18.950
通过这个组织的方式

12:18.950 --> 12:20.950
你看我这边单独放了一个什么呢

12:20.950 --> 12:22.950
单独放了一个

12:22.950 --> 12:24.950
这边定义了一个conventer

12:24.950 --> 12:26.950
数据仍然什么呢

12:26.950 --> 12:28.950
仍然不在APP里面维护

12:28.950 --> 12:30.950
单独定了一个conventer

12:30.950 --> 12:32.950
好 然后接下来的话

12:32.950 --> 12:34.950
这个expensive

12:34.950 --> 12:36.950
这个come作为什么呢

12:36.950 --> 12:38.950
作为你的这个组织

12:38.950 --> 12:40.950
传入之后学的

12:40.950 --> 12:42.950
我们这边来进行改造

12:42.950 --> 12:49.590
比较conventer

12:49.590 --> 12:51.590
好 数据的维护的话

12:51.590 --> 12:53.590
我仍然是放到什么呢

12:53.590 --> 12:55.590
仍然是这边的话

12:55.590 --> 12:57.590
不在这里维护了

12:57.590 --> 12:59.590
占我的这边维护

12:59.590 --> 13:01.590
好 然后接下来的话

13:01.590 --> 13:03.590
我这边return

13:03.590 --> 13:05.590
我把整个这一块

13:05.590 --> 13:07.590
我就把你拿过来

13:07.590 --> 13:11.480
对吧 把这边稍微格式画一下

13:11.480 --> 13:13.480
把你拿过来

13:13.480 --> 13:15.480
拿过来之后

13:15.480 --> 13:17.480
对于你这边来讲你只需要渲染什么

13:17.480 --> 13:19.480
这个conventer

13:19.480 --> 13:21.480
这个组件就可以了

13:21.480 --> 13:23.480
对不对 你选择这个conventer这个组件

13:23.480 --> 13:25.480
然后接下来回头的话

13:25.480 --> 13:27.480
这边把这个expansive

13:27.480 --> 13:29.480
放到这中间

13:29.480 --> 13:31.480
OK 好 然后这边的话

13:31.480 --> 13:33.480
采用什么呢 采用这个chill run的方式

13:33.480 --> 13:35.480
chill run

13:35.480 --> 13:37.480
这边的话

13:37.480 --> 13:39.480
chill run

13:39.480 --> 13:41.480
是不是采用这样的方式

13:41.480 --> 13:43.480
那你看这样的方式的话

13:43.480 --> 13:45.480
仍然是在APP里面我们就把什么

13:45.480 --> 13:47.480
不存在这个state的这个

13:47.480 --> 13:49.480
变化了 对不对

13:49.480 --> 13:51.480
我们这边单独把它分离出来了

13:51.480 --> 13:53.480
好 然后这边我们来看一下

13:53.480 --> 13:57.180
是不是一样的

13:57.180 --> 13:59.180
也用画好了 对不对

13:59.180 --> 14:01.180
也OK了

14:01.180 --> 14:03.180
这边的话就是当你组件

14:03.180 --> 14:05.180
你去设计的时候 就看你如何去设计

14:05.180 --> 14:07.180
这设计的话

14:07.180 --> 14:09.180
实际上是很灵活的

14:09.180 --> 14:11.180
明白吧 OK

14:11.180 --> 14:13.180
好 然后这边来看一下

14:13.180 --> 14:15.180
这边的话我们就把它

14:15.180 --> 14:17.180
通过这个chill run的方式

14:17.180 --> 14:19.180
是不是也达到了这个分离的目的

14:19.180 --> 14:21.180
对不对

14:21.180 --> 14:23.180
回头的话你这个APP里面

14:23.180 --> 14:25.180
同样是什么 没有在维护数据了

14:25.180 --> 14:27.180
对不对 在

14:27.180 --> 14:29.180
在该

14:29.180 --> 14:31.180
APP当中

14:31.180 --> 14:33.180
就没有

14:33.180 --> 14:35.180
维护这个数据了

14:35.180 --> 14:37.180
也就

14:37.180 --> 14:39.180
不存在什么

14:39.180 --> 14:41.180
是不是state的变化

14:41.180 --> 14:43.180
对不对

14:43.180 --> 14:45.180
回头的话你这个APP它就会干嘛

14:45.180 --> 14:47.180
它就会命中这个

14:47.180 --> 14:49.180
build out策略

14:49.180 --> 14:51.180
对不对

14:51.180 --> 14:53.180
所以说这边的话总结一下

14:53.180 --> 14:55.180
不管你采用哪种方式

14:55.180 --> 14:57.180
其实我们本质就是什么呢

14:57.180 --> 14:59.180
本质就是将可变的部分

14:59.180 --> 15:01.180
加出和什么呢

15:01.180 --> 15:03.180
和不可变的部分

15:03.180 --> 15:05.180
进行一个什么呢

15:05.180 --> 15:07.180
进行一个分离

15:07.180 --> 15:09.180
对不对 然后死什么呢

15:09.180 --> 15:11.180
死这个不变的部分

15:11.180 --> 15:13.180
能够命中

15:13.180 --> 15:15.180
build out策略

15:15.180 --> 15:17.180
对吧

15:17.180 --> 15:19.180
在日常开发中即使你不使用这个

15:19.180 --> 15:21.180
性能优化API 只要你理解

15:21.180 --> 15:23.180
它什么时候能够命中这个build out策略

15:23.180 --> 15:25.180
它就是命中这个

15:25.180 --> 15:27.180
build out策略它的这个原理是什么

15:27.180 --> 15:29.180
那你接下来回头的话

15:29.180 --> 15:31.180
就可以在你的项目里面

15:31.180 --> 15:33.180
是把你的这个主键的这个整个结构

15:33.180 --> 15:35.180
是不是就是调整的更加合理一些

15:35.180 --> 15:37.180
对不对 你看我们这边的话

15:37.180 --> 15:39.180
刚才举了这个例子

15:39.180 --> 15:41.180
上面这个的话它就会存在性能的问题

15:41.180 --> 15:43.180
那接下来我们把这个结构稍微优化一下

15:43.180 --> 15:45.180
是不是就OK了

15:45.180 --> 15:47.180
对不对

15:47.180 --> 15:49.180
好 默认情况下这个fiber load

15:49.180 --> 15:51.180
要命中这个build out策略

15:51.180 --> 15:53.180
还需要什么呢 还需要old props

15:53.180 --> 15:55.180
等于这个new props

15:55.180 --> 15:57.180
那只要你这个负的这个fiber load

15:57.180 --> 15:59.180
没有命中

15:59.180 --> 16:01.180
那你的指fiber load是不是一定不会命中

16:01.180 --> 16:03.180
对不对 考虑都不需要考虑

16:03.180 --> 16:05.180
好 然后接下来的话

16:05.180 --> 16:07.180
这边

16:07.180 --> 16:09.180
我看一下后面

16:09.180 --> 16:11.180
所以说你这边的话

16:11.180 --> 16:13.180
你这边编写的时候

16:13.180 --> 16:15.180
你要编写符合性能优化条件的这个主键

16:15.180 --> 16:17.180
然后还需要什么呢

16:17.180 --> 16:19.180
还需要注意主键对应的指数的这个根结点

16:19.180 --> 16:21.180
要注意这个根结点

16:21.180 --> 16:23.180
OK

16:23.180 --> 16:25.180
好 然后如果你使用什么呢

16:25.180 --> 16:27.180
使用这个性能优化这个API

16:27.180 --> 16:29.180
它实际上就是将这个build out策略里面的这个条件

16:29.180 --> 16:31.180
把这个就是

16:31.180 --> 16:33.180
old props等于new props

16:33.180 --> 16:35.180
变成了什么

16:35.180 --> 16:37.180
钱比较

16:37.180 --> 16:39.180
对不对 这个我们之前讲过的

16:39.180 --> 16:41.180
你的这个性能优化策略器背后的话就是什么呢

16:41.180 --> 16:43.180
就是把它变成了一个钱比较

16:43.180 --> 16:45.180
对不对

16:45.180 --> 16:47.180
好 然后最后的话这边总结一下

16:47.180 --> 16:51.180
如果将性能优化比做这个治病的话

16:51.180 --> 16:53.180
那你编写这个符合

16:53.180 --> 16:55.180
性能优化条件的这个主键

16:55.180 --> 16:57.180
它就相当于是药方

16:57.180 --> 16:59.180
而这个性能优化API

16:59.180 --> 17:01.180
性能优化API它就相当于什么呢

17:01.180 --> 17:03.180
相当于这个药影子

17:03.180 --> 17:07.180
那你单纯的用这个任何一个

17:07.180 --> 17:11.180
它实际上都不能起到很好的这个疗效

17:11.180 --> 17:12.180
对不对

17:12.180 --> 17:15.180
你一定要理解就是它背后的这个原理

17:15.180 --> 17:17.180
只有足量的这个药方

17:17.180 --> 17:18.180
就你这边

17:18.180 --> 17:20.180
首先你的这个主键的这个数

17:20.180 --> 17:22.180
你要满足性能优化的这个条件

17:22.180 --> 17:23.180
再加上什么呢

17:23.180 --> 17:26.180
再加上一些就是性能优化的这个API

17:26.180 --> 17:28.180
那么这边的话才能对

17:28.180 --> 17:30.180
对于你整个应用的这个性能

17:30.180 --> 17:34.180
做出一个很好的一个这个优化

17:34.180 --> 17:35.180
好吧

17:35.180 --> 17:38.180
这就是这节课要给大家所说的

17:38.180 --> 17:39.180
关于就是我们这个

17:39.180 --> 17:41.180
之前学了这个性能优化之后

17:41.180 --> 17:43.180
那对于我们这个日常开发

17:43.180 --> 17:46.180
有一些什么样的这个启发

17:46.180 --> 17:47.180
好吧

17:47.180 --> 17:48.180
好下来的话

17:48.180 --> 17:50.180
大家可以把就这节课内容

17:50.180 --> 17:52.180
这个文档自己再看一下

17:52.180 --> 17:54.180
把这些例子的话自己跑一跑

17:54.180 --> 17:55.180
ok

17:55.180 --> 17:57.180
好这节课的话就到这里

17:57.180 --> 17:58.180
再见

