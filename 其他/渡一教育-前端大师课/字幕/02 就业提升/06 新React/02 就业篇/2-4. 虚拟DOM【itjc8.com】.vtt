WEBVTT

00:00.000 --> 00:04.100
ok 这节课的话 咱们来看一下这个啊 虚拟多么

00:04.100 --> 00:08.800
虚拟多么这个话题的话 可能算是一个脑声长弹的话题了啊

00:08.800 --> 00:13.000
可能有的同学的话 听过 有的同学的话 也没听过

00:13.000 --> 00:19.000
啊 但不管你听没听过啊 我都建议你这边的话 可以就是好好把这节课听一下

00:19.000 --> 00:22.000
因为即使有些同学呢 他可能这个听过

00:22.000 --> 00:28.000
但是他的这个认识的话 其实也是比较浮浅的啊 比较片面的 ok

00:28.000 --> 00:33.000
好 那我们来看一下这道题 这道题的话 他问的是 什么是虚拟多么

00:33.000 --> 00:38.200
他的优点有哪些 然后这边的话 写了一个标准且浅浅的这个答案

00:38.800 --> 00:46.200
虚拟多么啊 本质上就是一个普通的这个杰士对象 用于描述仕途的界面结构

00:47.600 --> 00:52.800
这个答案对不对呢 这个答案的话 其实是对的 对吧 也是一个比较标准的答案

00:53.400 --> 00:58.600
但是你这样子回答的话 你实际上啊 实际上就是你的这个答案并不出彩

00:59.600 --> 01:10.200
就不会给面试官留下这个很深的这个影响啊 说说你看我这边写的是 这是一个标准且浅浅的这个答案啊 算了答案是正确的啊 但是是一个并不出彩的这个答案

01:10.800 --> 01:16.200
ok 接下来的话 我们这几课的话 我们专门来看一下啊 究竟这个虚拟多么

01:17.000 --> 01:25.600
他这个究竟是一个什么样的这个东西 对不对啊 对他进行一个比较深入的一个了解和认识啊

01:26.400 --> 01:33.600
好 虚拟多么 虚拟多么这个概念最早是由谁提出来的呢啊 最早的话是由这个react团队提出来的

01:34.300 --> 01:42.400
所以他们在针对这个虚拟多么的这个定义上面 他们实际上是由绝对的这个话语权的 对吧啊 虚拟多么

01:43.400 --> 01:56.800
最早是由这个react团队提出来的因此react团队再对什么呢 再对这个虚拟多么

01:58.000 --> 02:02.400
虚拟多么的定义上面有绝对的话语权

02:04.600 --> 02:10.400
ok好 来我们这边呢 我们就来看一下这个react团队 他是如何来定义这个虚拟多么的

02:10.800 --> 02:15.400
好 我们这边的话把这个打开啊 这个把这个链接放到这里啊

02:16.400 --> 02:20.600
这是官方文档的这个链接 我们来看一下 他这边怎么定义的

02:21.800 --> 02:27.200
vq多么也就是我们的这个虚拟多么 vq多么它是一种编程概念

02:28.200 --> 02:32.480
在这个概念里面 ui以一种理想化的或者虚拟的

02:33.280 --> 02:40.800
这种表现形式被保存在内存中啊 回头的话你可以用一些什么呢 可以用一些比如react多么之类的酷

02:41.280 --> 02:46.000
与真实的这个多么进行一个同步啊 这个过程叫做这个协调

02:47.040 --> 02:52.960
ok 你说这边的话重点实际上是这里 他是一种什么呢 他是一种概念

02:53.760 --> 02:54.320
啊 把这个

02:55.480 --> 02:56.560
把它复制过来

02:57.560 --> 03:02.270
ok 好 把这个 把这个加粗

03:04.190 --> 03:13.270
啊 vq多么它是一种概念 也就是说换句话说 你只要什么呢 只要能够把这个多么结构描述出来

03:14.270 --> 03:22.270
那么他就是一个虚拟多么 对不对 也就是说只要我们有一种方式

03:22.350 --> 03:32.030
能够将真实多么 真实多么的程式结构描述出来

03:33.390 --> 03:37.950
描述出来啊 那么这就是一个虚拟多么

03:39.550 --> 03:45.790
对不对 哎 实际上的话应该是这么样去理解他啊 好 比如说我这边的话我换了个图

03:46.350 --> 03:55.730
稍等啊 我把这个图我把拿过来 你看这个图 ok 左边的话是一个什么呢 左边的话是一个真实的多么

03:56.370 --> 04:05.170
啊 这边的话有di v啊 h1p ur ur下面有三个粒好右边右边的话我使用一个这个现实生活中的一些物体

04:05.490 --> 04:13.650
来进行一个映射啊 比如说这个汉堡汉堡的话就代表这个di v啊这个鼠条 鼠条的话代表这个h1

04:14.050 --> 04:17.810
好 这个牛排牛排代表这个p 好 然后接下来这个

04:18.690 --> 04:24.930
啊 这个是饮料啊 代表悦儿 悦儿下面然后接下来这个三贯这个可乐啊 代表这个力

04:25.410 --> 04:31.570
你看我这边的话使用现实生活中的这种物体是不是也可以把这个堕墓的这个程式结构

04:32.290 --> 04:39.970
是把它描述出来 对不对 说只要你有这种映射关系啊 那么他就可以被称之为什么呢 就可以被称之为虚拟多么

04:40.290 --> 04:43.330
啊 说说你看我们这边的话 实际上也是可以看作是一个虚拟多么

04:43.890 --> 04:52.770
ok 你只要能够理解到这一层啊 你已经和就是其他绝大数 就是绝大多数的这个面试者已经就不一样了

04:53.410 --> 04:55.010
啊 已经就不一样了 ok

04:56.290 --> 05:02.130
好 只不过在这个代码里面我们不可能用这样的形式 对不对啊 在代码里面react

05:02.610 --> 05:08.930
这个团队他们使用的是什么呢 他们使用的是js对象啊 在react中

05:09.890 --> 05:11.090
然后react

05:11.970 --> 05:18.610
团队使用的是js对象来对这个堕墓结构

05:20.210 --> 05:28.850
进行一个描述啊 但是很多人会直接把什么呢 把这个js对象

05:29.810 --> 05:31.330
和虚拟多么

05:31.970 --> 05:32.610
化等号

05:34.210 --> 05:35.170
啊 这种理解

05:36.290 --> 05:38.690
呃 是什么呢 就是不太准确的

05:39.890 --> 05:42.210
太准确的啊 比较片面的

05:44.130 --> 05:52.050
对不对 他不太准确啊 比较片面的虚拟多么实际上他和这个js对象之间的关系 实际上你可以这么来说

05:53.090 --> 06:01.090
虚拟多么和这个js对象之间的这个关系 什么关系呢 他前者

06:02.050 --> 06:03.090
是一种思想

06:05.340 --> 06:09.020
ok 前者的话这个虚拟多么他是一种思想

06:09.740 --> 06:17.340
好 然后接下来这种思想 我实现的这种方式是不是有很多种 对不对 比如说你看我们像这个这个的话 其实也是一种实现方式

06:17.820 --> 06:24.380
啊 只要我能够把那个多么层次结构把它描述出来就行啊 说前者是一种思想而后者

06:25.500 --> 06:28.140
是一种什么呢 是一种就是思想的

06:28.940 --> 06:31.500
思想的具体实现

06:32.860 --> 06:37.340
啊 你只要把这句话能够说出来啊 这面试完直接就惊呆了

06:37.660 --> 06:43.500
因为你这个理解的话就完全就不同于其他人了 对不对 其他人的话一般说出来就是这个样子的

06:44.300 --> 06:50.380
ok 这是首先关于这个虚拟多么的这个概念啊 首先我要把这个的话 我把它讲清楚

06:51.100 --> 06:53.340
好 然后接下来的话我们来到下一个问题

06:54.460 --> 07:00.800
那就是什么呢 就是为什么需要虚拟多么 需要虚拟多么

07:02.080 --> 07:08.160
ok 为什么需要虚拟多么呢 其实你使用虚拟多么的话 实际上有两个方面的优势

07:09.440 --> 07:11.360
使用虚拟多么

07:12.240 --> 07:13.760
呃 有就主要

07:14.800 --> 07:16.240
有两个方面

07:16.960 --> 07:18.960
两个方面的优势

07:20.080 --> 07:22.880
这两个方面呢 首先第一个就是相较于

07:23.440 --> 07:25.680
多么的这个体积

07:26.960 --> 07:27.920
体积优势

07:29.440 --> 07:32.480
体积优势啊 和什么呢 和速度优势

07:33.280 --> 07:36.960
ok 第二个就是什么呢 第二个就是多平台

07:37.760 --> 07:39.760
多平台的这个渲染

07:40.560 --> 07:41.360
抽象能力

07:43.760 --> 07:48.720
ok 主要表现在这两个方面啊 好 那我们一个一个来看啊

07:49.680 --> 07:58.080
一个一个来看啊 首先第一个是这个啊 多么体积优势和速度优势啊 第二个的话是这个啊 多平台

07:58.800 --> 08:01.360
呃 渲染抽象能力啊 首先第一个

08:02.000 --> 08:08.400
相较于多么体积优势和速度优势啊 一说了这个虚拟多么的话 他就是有的同学啊

08:08.640 --> 08:12.640
他第一反应就是什么呢啊 第一反应就是快啊 虚拟多么很快嘛

08:13.280 --> 08:15.920
那你这个虚拟多么快 他究竟快在哪

08:16.800 --> 08:18.960
对不对啊 他究竟快在哪个地方

08:19.440 --> 08:23.600
那什么时候快啊 你这些东西你有没有搞清楚

08:24.320 --> 08:34.800
啊 首先的话就是我们需要明确一个点 什么点呢 就是我们这个结实层面的这个计算速度要比多么层面的这个计算要快得多

08:35.280 --> 08:39.680
啊 首先我们需要明确一个点

08:40.960 --> 08:45.280
什么呢 就是结实层面的计算速度

08:46.880 --> 08:52.720
要比这个多么层面的这个计算要快

08:54.320 --> 08:58.000
啊 为什么呢 原因有两点 首先就是你一个动物对象

08:58.560 --> 09:05.760
动物对象最终要被这个浏览器啊 就是渲染出来之前 浏览器的话 他实际上有很多工作要做的

09:07.040 --> 09:07.680
动物对象

09:09.120 --> 09:11.360
最终呃 要被

09:12.400 --> 09:16.080
浏览器渲染出来之前

09:16.880 --> 09:20.240
浏览器啊 会有什么呢 会有很多

09:21.120 --> 09:21.520
工作

09:22.320 --> 09:22.720
要做

09:23.840 --> 09:28.640
ok 这个的话实际上涉及到了这个浏览器的这个渲染原理

09:29.440 --> 09:33.440
啊 涉及到浏览器的渲染原理 这个不清楚的同学的话 可以去看一下咱们

09:34.000 --> 09:36.960
就是袁老师讲的啊 浏览器渲染原理的那个课

09:37.520 --> 09:41.360
ok 这是首先第一个 好第二个就是什么呢 第二个就是你动物

09:42.080 --> 09:46.720
动物对象上面的这个属性也非常非常多

09:49.250 --> 09:53.650
ok 相比你一个结实对象啊 动物上面的话他的那个属性太多了

09:54.130 --> 09:56.450
ok 好来我们这边让我们来看一下吧

09:57.250 --> 09:59.010
不用我们这边把这个打开

10:00.290 --> 10:03.810
我们这边我们就在这里看啊 就直接在这里控制台看

10:04.610 --> 10:07.250
好我们这边的话比如说我们创建一个div

10:07.970 --> 10:10.850
const一个div等于一个document

10:11.810 --> 10:14.210
点这个creator element

10:15.890 --> 10:19.810
creator element 那我们创建一个什么呢 创建一个div

10:22.900 --> 10:24.900
ok 那我们这边创建了个动物元素

10:25.380 --> 10:28.260
创建了个动物元素之后 然后接下来我们这边打印一下

10:28.900 --> 10:34.660
for net这个i 印这个div 这边是不是拿到他所有的这个属性

10:35.060 --> 10:37.780
对不对啊 拿到之后然后接下来我们这边打印一下

10:38.020 --> 10:39.940
console.nog

10:40.580 --> 10:42.980
然后这边让我们打印什么呢 打印这个i

10:43.700 --> 10:46.260
让我们再加一个空格啊 把它隔开

10:47.060 --> 10:47.860
啊 回车

10:48.580 --> 10:49.300
你可以看一下

10:50.100 --> 10:53.460
可以看一下啊 全是这个动物对象上面属性

10:53.700 --> 10:57.620
我们还什么都没做哦 对不对 我们还什么都没做

10:57.620 --> 11:00.900
你看他上面的话会有这么多的属性啊

11:00.900 --> 11:03.140
我们把这把这个代码 我们放到笔记里面

11:09.760 --> 11:13.120
这边 然后这边这边是打印

11:14.640 --> 11:18.720
ok 你就通过这个上面这两个代码啊 实际上你就可以看出

11:19.040 --> 11:22.480
对不对 你这个动物对象上面的属性他是非常非常多的

11:23.360 --> 11:29.600
其次就是什么呢 其次就是你操作这个杰士对象的时间和你操作动物对象的时间是完全不一样的

11:31.040 --> 11:31.520
操作

11:32.800 --> 11:40.880
操作杰士对象的时间和操作动物对象的这个时间

11:42.800 --> 11:46.000
时间是完全不一样的

11:47.040 --> 11:50.720
ok 好来我们这边呢 我们还是写个例子啊 我们这边写个例子

11:51.440 --> 11:58.140
好 这边新建个窗口吧 新建一个窗口 我这边新建一个

11:59.100 --> 12:07.020
新建一个html文件 稍等啊 我把这个放大一点

12:08.940 --> 12:13.740
ok 好 然后我们这边新建了一个html 我们这边这个script

12:14.620 --> 12:18.940
好 在这里面 这里面我们要做什么呢 首先这边console.log

12:19.660 --> 12:24.140
这边这个time 这个是什么呢 这个是g10开始

12:24.860 --> 12:30.420
g10 开始

12:30.820 --> 12:36.500
好 然后接下来这边g10结束 这边他有一个 这边不是console.log 这是console

12:37.300 --> 12:40.180
点time 这边没有没有参数

12:40.900 --> 12:42.500
好 这边呢是time-end

12:43.220 --> 12:45.540
console.time-end 这边没有参数

12:46.340 --> 12:49.060
好 一个是g10开始 一个是g10结束

12:49.940 --> 12:54.900
ok 好 然后接下来我们在这边要干嘛呢 我们这边创建一个数组

12:57.380 --> 13:01.780
创建一个数组 创建数组之后 然后接下来我们创建1000个动物对象

13:03.220 --> 13:07.940
创建呃 创建1万个嘛 1万个

13:08.740 --> 13:12.020
动物对象 对吧 我们这边for

13:12.980 --> 13:16.900
net i 等于0 i小一个1万

13:18.020 --> 13:23.780
i加加 对吧 在for形化里面我们干嘛呢 我们这边AR2.push

13:24.500 --> 13:27.540
往数组里面推入 推入一个什么呢 document

13:28.820 --> 13:32.900
点creator element 创建一个div

13:34.020 --> 13:38.420
ok 这个代码的话非常好懂 对吧 这边g10开始创建一个数组

13:38.660 --> 13:42.900
大家创建了1万个这个动物对象 推到数组里面 然后g10结束

13:43.300 --> 13:46.900
这是首先第一个 好 然后接下来的话 我们这边第二个

13:49.980 --> 13:52.780
第二个呢 我们同样这边啊g10开始

13:53.020 --> 13:55.020
然后g10结束

13:57.020 --> 14:00.780
好 然后接下来这边同样有一个这个数组啊 const

14:01.900 --> 14:03.260
const AR2

14:04.060 --> 14:09.500
等于一个数组好 然后加这边同样是for循环 net i 等于0

14:10.140 --> 14:12.780
然后i小一个1万

14:13.260 --> 14:13.820
i加加

14:14.620 --> 14:19.900
好 这个for循环干嘛呢 这个for循环的话是创建1万个

14:20.700 --> 14:21.900
这个gs对象

14:24.210 --> 14:26.210
ok好 这边AR2

14:26.930 --> 14:28.130
点push

14:29.650 --> 14:33.970
好 往里面推入一个对象啊 对象的话 我们这边比如说有个target

14:34.610 --> 14:36.050
对应他这边是一个div

14:36.610 --> 14:38.690
ok好 来我们来运行一下这个代码

14:39.490 --> 14:40.450
我们这边把它打开

14:42.370 --> 14:44.290
打开之后 然后将我们这边我们来看一下

14:45.890 --> 14:49.730
啊 这边大家可以看一下 可以明显的看到时间的这个差别

14:50.210 --> 14:55.490
对不对 你看上面上面的话 你看这个是7点几毫秒 这个是2点几毫秒啊 我们再刷新一下

14:56.610 --> 15:04.930
ok 你看这边是明显有这个差别啊 基本上的话这边上面啊 上面基本上是平均在5毫秒左右

15:06.850 --> 15:07.330
平均

15:09.090 --> 15:10.610
在5毫秒

15:12.130 --> 15:20.340
左右啊 这边下面下面的话平均平均是在什么呢 1毫秒左右

15:22.100 --> 15:26.740
ok啊 我们这边的话还是就是简简单单的就是一个单纯的这个动物对象

15:26.740 --> 15:32.820
你如果针对这个动物对象你做了更多的这个操作 那这个的话呢 这个时间的这个消耗它会更加多一些

15:33.780 --> 15:34.900
明不明啊

15:36.900 --> 15:42.020
好 那么我们现在就明确了什么呢 现在就明确了你这个就刚上我们这边所说的这句话

15:42.580 --> 15:50.500
啊 这里操作结实对象的时间啊和这个操作动物对象的时间是完全不一样的 对不对啊 结实

15:51.380 --> 15:57.140
结实层面的计算速度啊 要高于

15:58.020 --> 15:58.660
动物层面

15:59.780 --> 16:01.620
动物层面的计算速度

16:02.900 --> 16:08.340
ok 好 那这个时候的话有的同学就会存在一个问题 什么问题呢 他会问他说

16:08.900 --> 16:17.140
谢老师 虽然你这个结实层面的这个计算速度很快 对不对 但是你最终还是离不开要用这个原生动物ap去操作动物呀

16:17.620 --> 16:22.740
这个的话实际上是一个非常好的问题 说明这个同学们在思考 ok

16:24.820 --> 16:25.220
此时

16:26.020 --> 16:26.740
有一个问题

16:27.700 --> 16:33.540
什么问题呢 就是虽然使用了结实层面

16:34.340 --> 16:35.940
啊 就使用了结实对象

16:36.740 --> 16:44.340
来描述这个ui 对吧 但是最终不还是要用什么呢 要用这个

16:44.980 --> 16:47.220
原生动物ap

16:48.820 --> 16:53.940
去操作动物吗 对不对 你这个动物层面的这个计算

16:54.660 --> 16:56.340
仍然是这个避免不了的呀

16:57.300 --> 17:02.020
啊 那这个为什么这个虚拟动物会有这个优势呢 我还平白无故还多了一层

17:02.420 --> 17:09.220
对吧 我以前的话我直接就是原生动物ap去操作动物 我现在还多了一层啊 多了一层这个结实层面的这个计算

17:09.940 --> 17:11.380
这其实是一个非常好的问题

17:11.860 --> 17:17.940
啊 那我们这个虚拟动物它的优势真真真正正体就是体现在什么时候呢

17:18.580 --> 17:21.620
它实际上不是体现在第一次渲染页面的时候

17:22.180 --> 17:25.140
它真真正正体现在的时候后面更新的时候

17:25.780 --> 17:31.780
也就是你这个虚拟动物技术啊 它在第一次渲染页面的时候 它肯定要比原生动物操作要慢一些

17:32.580 --> 17:38.180
为什么 因为你多了一个这个结实层面的这个操作 对不对啊虚拟动物

17:39.140 --> 17:46.980
虚拟动物呃 在这个第一次第一次渲染页面的时候啊 并没有什么优势

17:48.100 --> 17:49.220
什么优势

17:50.260 --> 17:52.900
并没有什么优势啊 速度

17:53.860 --> 17:54.420
肯定

17:55.540 --> 18:05.100
肯定比呃 直接操作什么呢 操作原生动物ap要慢一些

18:05.980 --> 18:07.980
对不对 好 然后虚拟动物

18:08.860 --> 18:12.860
虚拟动物真正体现优势

18:14.540 --> 18:20.690
是在什么呢 是在这个更新阶段啊 为什么在更新阶段呢

18:21.090 --> 18:29.250
而根据这个react团队的这个研究啊 你在这个更新页面的时候啊 实际上你在使用这个原生动物ap进行操作的时候

18:29.730 --> 18:38.610
相比使用这个原生动物ap开发人员的话 其实更加倾向于什么呢 更加倾向于使用inner html这个 ap

18:39.170 --> 18:43.090
啊 根据react团队

18:45.170 --> 18:51.330
团队的这个研究啊 这个在更新页面的时候 更新页面时

18:52.130 --> 18:56.450
相比这个使用原生动物ap

18:58.130 --> 18:59.570
开发人员

19:00.530 --> 19:06.290
更加倾向于什么呢 倾向于使用这个inner html

19:07.090 --> 19:10.690
就你原生的那个动物ap就是什么ap 啊

19:11.090 --> 19:16.370
对吧insert before啊啊 这些这些的话 实际上你通过这种去修改这种

19:16.850 --> 19:20.610
动物结构啊 如果是这个动物节点比较少还可以

19:21.170 --> 19:28.850
但是如果你比如说你要去描述描述整个一块啊 一块这个东西 你用这种原生的这个动物ap的话 实际上是比较繁琐的

19:29.490 --> 19:35.170
对不对 说大家的话 一般其实更加倾向于使用这个inner html啊 比如说我这边我举了个例子

19:36.530 --> 19:42.990
这边大家可以看一下 比如你使用这个原生啊 这边呢 这个是原生

19:44.510 --> 19:51.550
原生的这个动物ap对不对 我这边呢 我要创建这个p 大家创建一个text node啊 大家open the child open the child

19:51.950 --> 19:55.710
好 大家更愿意用什么呢 大家更愿意其实更愿意用这个

19:58.580 --> 19:59.780
更愿意用这个

20:00.820 --> 20:04.580
对不对啊 document.body.inner html 直接这样写就可以啊

20:05.300 --> 20:08.820
对不对啊 那么此时的话 你用这个inner html

20:09.060 --> 20:13.940
这里的话 实际上就涉及到什么呢 就涉及到了两个层面的这个计算啊

20:15.300 --> 20:15.700
因此

20:17.300 --> 20:22.100
因此在使用inner html的时候

20:22.900 --> 20:28.100
就涉及到了什么呢 两个层面的计算

20:28.820 --> 20:31.300
那两个层面 一个是接式层面

20:33.140 --> 20:35.780
对不对 接式层面他要干嘛 是不是他需要解析

20:36.420 --> 20:38.580
制服串 对不对 因为你这个是个制服串啊

20:39.380 --> 20:43.380
对不对 你后面这个是个制服串 我首先的话 我这个接式层面我是不是要去解析这个制服串

20:43.860 --> 20:46.820
好 然后接下来的话需要干嘛 是不是这个动物层面

20:48.580 --> 20:54.420
需要干嘛 说创建对应对应的动物节点

20:56.900 --> 21:01.620
对不对啊 这边不应该是更新页面啊 这边就是在渲染页面上

21:02.180 --> 21:03.220
在渲染页面上

21:03.860 --> 21:08.260
对不对 那这个时候我们就可以干嘛呢 我们这个时候我们就可以加入虚拟动物来进行对比

21:09.220 --> 21:09.860
啊 接下来

21:11.300 --> 21:13.860
我们加入虚拟动物

21:14.980 --> 21:19.380
虚拟动物来进行对比 我们来看一下

21:19.940 --> 21:23.060
好 那我这边呢 我直接把这个我直接把这个表格拿过来吧

21:25.570 --> 21:27.650
好 我们来看一下啊 这边这个表格

21:28.210 --> 21:31.410
你看 嗯 第一个是使用InnerHTML

21:31.810 --> 21:36.050
InnerHTML的话 他会涉及到两个层面的计算 首先第一个是接式层面

21:36.530 --> 21:42.450
他需要解析制服串啊 第二个是什么呢 第二个是动物层面啊 创建对应的这个动物节点

21:43.010 --> 21:47.010
那如果使用什么呢 如果使用虚拟动物 是不是也是两个层面

21:47.570 --> 21:53.730
对不对 这个刚刚我们讲了的 他也是两个层面啊 首先的话你需要干嘛呢 你需要创建这个接式对象

21:54.370 --> 21:57.970
好 然后接下来的话需要干嘛呢 创建对应的这个动物节点

21:58.530 --> 22:05.490
ok 所以可以看到就是在第一次啊 在第一次就是刚开始渲染这个页面的时候 你这个虚拟动物的话

22:05.810 --> 22:07.970
其实并不能发挥这个多少的优势

22:08.770 --> 22:11.490
对不对 他实际上和你以前用这个InnerHTML一样

22:11.970 --> 22:16.850
啊 他就是也是经历了两个层面的这个计算啊 谁快谁慢这个还不一定

22:17.650 --> 22:27.170
对不对 虚拟动物真真真正这个发挥威力实际上是在更新阶段啊 这个刚刚我也说了啊 在在在在这里对吧

22:27.810 --> 22:28.450
虚拟动物

22:29.970 --> 22:38.450
虚拟动物真正发挥威力的时候是在什么呢 是在更新阶段

22:39.410 --> 22:41.490
为什么呢 因为你InnerHTML

22:42.850 --> 22:44.050
InnerHTML

22:45.250 --> 22:50.690
进行更新的时候要什么呢 要全部重新复制

22:52.210 --> 22:57.330
对不对 比如说我现在更新啊 比如说这个之前这个document.body啊 之前已经有内容了

22:57.730 --> 23:02.130
现在我要更新 更新的话我这个InnerHTML是不是也是像这样子啊 是不是重新进行复制

23:02.530 --> 23:04.130
对不对 那这意味着什么呢

23:04.770 --> 23:05.970
这意味着

23:06.930 --> 23:10.290
之前创建的这个动物节点

23:11.650 --> 23:16.050
动物节点需要什么呢 需要全部销毁掉

23:17.250 --> 23:20.210
然后重新进行

23:23.550 --> 23:25.790
重新进行创建啊 但是虚拟动物

23:26.750 --> 23:31.470
虚拟动物只需要什么呢 只需要就是更新

23:32.590 --> 23:36.190
这个最需要就是只需要更新这个必要的

23:37.070 --> 23:38.430
不要的动物节点

23:39.790 --> 23:42.110
动物节点

23:43.790 --> 23:44.190
即可

23:46.210 --> 23:51.570
ok 你可以看到在更新阶段这个虚拟动物 它的这个优势就发挥出来了

23:52.290 --> 23:54.290
啊 我们这边我还是立了一个表格

23:55.570 --> 23:57.170
把这个表格直接拿过来

23:59.090 --> 24:00.530
啊 这边你可以看一下

24:01.650 --> 24:05.010
啊 更新的时候 这边的话这个InnerHTML 因为你是重新复制嘛

24:05.490 --> 24:08.770
对不对啊 你接式层面的话 这边那就是解析制服串

24:09.170 --> 24:11.490
好 但是你这个动物计算层面呢 它是不是会有两个

24:12.050 --> 24:15.410
对不对 他首先呢 他会去销毁原来所有的动物节点

24:15.970 --> 24:20.770
然后接下来这边再去重新创建啊 所有这个对应的这个动物节点

24:21.330 --> 24:25.490
啊 那你这个量如果一旦大的话 那你这个就是性能的这个损耗

24:25.890 --> 24:27.010
是不相当的严重

24:27.650 --> 24:32.530
对不对 但是虚拟动物就不一样啊 虚拟动物的话 这边啊 首先这边创建这个接式对象

24:32.690 --> 24:38.210
大家这边呢 仔细的干嘛呢 就是最小程度的修改这个必要的动物节点

24:39.250 --> 24:43.730
看到没有 哎 整个这个虚拟动物 它的这个优势就体现出来了

24:44.610 --> 24:48.610
明白没啊 啊 所以以后的话 说到这个虚拟动物不要第一反应就是快

24:49.170 --> 24:53.090
啊 你要给别人讲清楚 究竟是什么时候快 他快在哪个地方

24:53.410 --> 24:54.370
他为什么快

24:55.170 --> 24:58.770
ok 啊 这是首先第一个啊 第一个就是我们这边

24:59.170 --> 25:02.050
相较于动物的这个体积优势和速度优势

25:02.690 --> 25:07.970
好 第二个 第二个的话 就是这个多平台抽象的这个渲染能力

25:09.970 --> 25:13.490
好 我们在前面的话 我们已经讲过了啊 就是我们整个这个

25:15.810 --> 25:22.290
就是这个框架啊 现在的话都是一个响应式的 对不对啊 都是这个就是根据状态自动更新

25:22.610 --> 25:27.890
好 你这边呢 就是总结出来的话 可以总结出一个公式 就是什么 ui 等于什么

25:28.450 --> 25:30.130
f啊 那接下来这边

25:30.850 --> 25:38.770
state 这公式我们之前是不讲过的 对不对啊 这个这个公式呢 你进一步拆分的话 可以拆分成两步啊 这个公式

25:39.970 --> 25:42.770
进一步进行拆分

25:43.970 --> 25:52.370
可以拆分成什么呢 可以拆分成两步 没两步这个之前也是讲过的啊 根据什么 根据自变量

25:53.330 --> 25:54.930
自变量的变换

25:55.650 --> 26:00.850
然后计算出什么 是计算出ui 好 第二个根据这个ui

26:02.050 --> 26:06.130
变化 然后执行什么呢 执行具体的数组环境

26:07.250 --> 26:09.170
数组环境的这个api

26:09.890 --> 26:16.850
ok 好 那接下来的话 这边第二步 第二步的话 那你这个不同的这个数组环境啊 让我这边 api 是不是不一样的

26:17.410 --> 26:22.850
对不对 让我这个虚拟多么的话 我这边的话 可以统一就是啊 计算出一个新的这个ui

26:23.010 --> 26:28.290
这个ui 只是一个什么 只是一个描述 对不对啊 就是根据这个虚拟多么

26:29.330 --> 26:34.610
虚拟多么 计算啊 虚拟多么的话 它只是什么呢 只是

26:35.650 --> 26:40.370
对什么呢 对真实ui 的一个描述

26:41.170 --> 26:46.130
然后回头根据不同的这个数组环境

26:47.090 --> 26:53.250
数组环境啊 可以什么呢 可以执行不同的这个渲染代码

26:54.690 --> 26:59.890
对不对 和这个不同的这个包进行一个这个对接啊 比如这个 举个例子

27:00.690 --> 27:02.130
啊 这边我直接拿过来啊

27:03.650 --> 27:08.530
这边大家可以看一下啊 比如浏览器 对吧 大家最熟悉的 比如这个浏览器

27:08.930 --> 27:12.690
浏览器或者note的结实 他们数组环境的话用的就是这个包

27:13.410 --> 27:18.610
react dorm 啊 如果你是lative数组环境啊 就有个reactlative

27:19.170 --> 27:22.770
啊 他的这个渲染的话 用的就是什么呢 用的就是reactlative这个包

27:23.330 --> 27:25.250
啊 如果你是canvas svg

27:26.050 --> 27:28.530
那这个呢 他使用了什么呢 使用了是react art

27:29.090 --> 27:33.890
还有什么呢 还有就是比较react test啊 这个呢是拿来做测试的

27:34.610 --> 27:40.210
对不对啊 所以说我这边的这个虚拟多么有非常好的这个多平台的这个渲染抽象能力

27:40.530 --> 27:43.330
他只是做一个这个UI的这个描述

27:44.050 --> 27:48.850
啊 然后回头的话你这个不同的这个数组环境 然后加你调这个不同的这个渲染API就可以了

27:49.570 --> 27:51.730
ok 啊 这是关于这个

27:52.690 --> 27:55.090
虚拟多么啊 为什么需要虚拟多么

27:55.570 --> 27:59.490
好 然后回头的话 接下来我们来看一下什么呢 我们来看一下这个react中

28:01.410 --> 28:03.250
react中的这个虚拟多么

28:05.630 --> 28:05.950
ok

28:07.790 --> 28:10.430
好 我们知道在react中通过什么来描述UI

28:11.150 --> 28:15.630
啊 这个之前讲过 在react里面是不是通过这个接使插来描述UI

28:16.270 --> 28:20.830
对吧 在react中通过什么呢 通过接使插

28:21.550 --> 28:23.470
来描述UI

28:24.190 --> 28:24.750
好 那这个

28:25.470 --> 28:26.030
接使插

28:26.590 --> 28:32.990
接使插的话 它最终会被转成什么呢 最终它会被转成一个叫做created element方法的这个调用

28:34.270 --> 28:36.590
接使插最终会被

28:37.310 --> 28:37.950
转为

28:38.430 --> 28:41.150
一个叫做什么呢 叫做这个created

28:42.670 --> 28:45.230
element方法的这个调用

28:45.950 --> 28:48.270
啊 然后这个调用该方法后

28:49.310 --> 28:51.390
调用该方法后

28:52.030 --> 28:52.670
就会

28:53.470 --> 28:55.630
得到虚拟多么对象

28:57.730 --> 28:59.890
ok 那我们这边我们来看一下啊

29:00.290 --> 29:02.370
我这边有张图 我把这张图拉过来

29:02.690 --> 29:06.290
好 放到这里

29:06.850 --> 29:08.210
好 这边让大家可以看一下

29:08.690 --> 29:14.610
看这里 比较左边 左边的话是我们写的这个接使插啊 比如这个是一个函数组件

29:15.090 --> 29:18.770
这个是一个class组件啊 这个就是普通的一段这个接使插

29:19.330 --> 29:24.610
你看它经过这个babel编译啊 注意这边是这个babel啊 我在babel里面截的图啊 经过

29:25.890 --> 29:27.010
经过这个babel

29:28.850 --> 29:30.530
babel编译后

29:31.250 --> 29:32.050
结果如下

29:33.170 --> 29:33.490
ok

29:34.370 --> 29:37.410
你可以看到这边啊 这边你看它调用的就是什么

29:37.570 --> 29:39.650
是不是react点create element

29:40.370 --> 29:43.650
对不对啊 这边一个div 大家这边呢是funk

29:43.970 --> 29:44.210
com

29:45.010 --> 29:47.730
这边呢是一个div啊 里面是一个class form

29:48.210 --> 29:51.010
好 然后接下来这边 这边呢是一个div 大家这边

29:51.410 --> 29:52.290
第二个是一个对象

29:53.490 --> 29:55.730
第二个是对象 对象里面是不是就是你的属性

29:55.730 --> 29:59.730
对吧 我这边id a a 这边对应对象对象id冒号 a a

30:00.450 --> 30:05.490
好 然后回头呢 这边又是嵌套它的这个指援数啊 指援数 然后接下来这边是一个

30:05.890 --> 30:12.290
bbb啊 大家这边一个hello啊 大家第二个 第二个它是这个funk com和这个class form

30:13.650 --> 30:19.490
class form 对了 ok 你最终的话是不是就编译成了什么 编译成了这个create element

30:19.490 --> 30:25.490
方法的这个调用对不对啊 这个方法一调用之后就会得到这个虚拟动物对象啊

30:25.490 --> 30:28.130
那现在我们这边来看一下啊 在原码中

30:29.330 --> 30:32.770
在原码中create element

30:33.570 --> 30:36.050
方法 啊 录像

30:37.810 --> 30:42.130
好 这个的话就是这个react的这个原码了 我就直接把它拿过来吧

30:43.570 --> 30:50.180
直接拿过来 这边大家可以看一下 好 这里

30:51.380 --> 30:56.180
啊 这边大家可以看一下 你看这边它导出function and create

30:56.180 --> 30:58.900
这个element 接收什么 是不是接收三个传说

30:59.460 --> 31:04.660
首先第一个 第一个是type type就是什么 第一type就是你这个元素的类型

31:05.380 --> 31:09.540
好 第二个 第二个config config就是你这边就是个属性的这个对象

31:10.180 --> 31:12.580
对吧 比如说我们这边 这边让我们这个属性id

31:13.140 --> 31:17.700
等于aa 回头让它在这边编译成就编译成什么 是编译成这么一个对象

31:18.340 --> 31:21.060
对 编译成这个对象这个对象里面啊 id冒好 a

31:21.620 --> 31:25.780
啊 所以这边呢 就是属性对象啊 children children 是不是就是指援数

31:26.740 --> 31:34.340
对不对 就指援数啊 好 然后接下来的话你看这边 这边呢 首先这边是const props是一个对象

31:34.820 --> 31:38.180
好 人家这边定义了一些key riff self source

31:38.740 --> 31:41.380
好 然后这样if config不等于 know

31:41.940 --> 31:47.540
什么 就是它 对不对 这个不等于 know 不等于 know 说明什么 说明有属性啊

31:48.500 --> 31:53.300
对不对 有属性 有属性 然后接下来这一段代码就是对属性进行一个处理

31:53.860 --> 31:58.340
处理完了之后 然后接下来所有的属性就会放到pops对象里面

31:59.380 --> 32:04.580
啊 你这个pops一开始是空的嘛 对不对啊 回头你的这个pops就变成什么呢 就变成这个样子了

32:05.620 --> 32:09.460
啊 变成这样子了 好 然后接下来的话 开始处理这个求论

32:10.020 --> 32:12.260
求论的话 它这边会进行一个判断

32:12.980 --> 32:16.340
啊 如果你这个求论认识是一 认识是一的话是哪种情况

32:16.980 --> 32:22.660
认识是一是这种情况啊 就这边啊 这个就只有一个什么 是不是只有一个这个

32:23.300 --> 32:26.500
文本 对不对 只有一个文本的话 它这边就直接这个

32:27.060 --> 32:32.580
啊 这个求论就等于这个就把这个求论复制给pops点求论啊 你这边对呢 就是一个

32:32.900 --> 32:39.780
文本啊 如果的话是有多个啊 比如针对这个 你看针对外称这个div而言 它的指援数是有多个

32:41.140 --> 32:45.620
对不对 有多个 有多个怎么办 有多个的话 它这边就是一个什么 它这边就是个数组

32:46.820 --> 32:51.860
可不可以通过一个数组来装啊 你这边pops点求论 它就等于一个数组

32:52.660 --> 32:57.460
好 然后后面后面这边的话这个义父这个义父呢 是添加这个默认的这个pops

32:58.020 --> 33:01.460
啊 我们之前的话在讲这个reactor的时候 它是不是可以设置这个

33:01.860 --> 33:08.340
default props啊 好像就上一张讲的吧 这就是第一张讲的啊 你这边可以设置这个默认的

33:08.580 --> 33:14.420
说它这边的话有一个义父来处理这个默认的pops啊 完事之后 然后接下来的话 这边返回

33:15.140 --> 33:17.780
返回让大家这边是reactor element

33:18.980 --> 33:21.620
啊 大家这个是是一个什么 这个也是个方法

33:22.420 --> 33:24.900
也是个函数 然后这边是传的这个参数

33:25.460 --> 33:29.300
啊 这个传数就这个参数就把什么呢 就把type key riff

33:29.780 --> 33:35.700
sale服这些传过去啊 这边这个pops props到传的就是什么 这不就已经是这个这个这个pops了

33:36.340 --> 33:41.620
对不对 就处理之后的这个pops了 传过去 传过去之后 然后接下来我们来看一下这个方法

33:41.940 --> 33:47.380
你要这个方法呢 这边啊 看它的核心啊 核心这边const element等于一个什么

33:47.540 --> 33:51.220
这等一个对象啊 最终的话这边是不返回一个对象

33:52.340 --> 33:57.220
这返回个对象 对不对 好 那这个对象啊 最终这个对象

33:57.460 --> 34:03.060
就是我们所说的虚拟多么对象啊 在上面的对这个代码中

34:05.900 --> 34:12.540
在上面的代码中啊 最终返回的 element

34:13.260 --> 34:15.740
对象啊 就是我们

34:17.100 --> 34:20.140
所说的虚拟多么对象

34:21.260 --> 34:26.140
喵喵 okay 啊 但是你要注意啊 在这个reactor官方文档中

34:26.620 --> 34:31.420
他这个官方更倾向于把这个叫做什么呢 更倾向于把这个叫做元素

34:33.340 --> 34:34.940
在这个官方文档中

34:36.940 --> 34:43.100
这个官方更倾向于将这个对象

34:44.220 --> 34:50.620
称之为什么呢 称之为reactor元素啊 因为他本身这边的话名字叫做 element嘛

34:51.180 --> 34:55.820
对不对 所以你回头的话 你在看官网的时候啊 他比如说这边的话需要传入一个

34:56.540 --> 35:01.820
这个reactor元素 那你要知道说的是什么啊 指的其实就是这个虚拟多么对象

35:02.540 --> 35:07.820
ok 好 这个就是关于这个reactor中啊reactor中的这个虚拟多么

35:09.100 --> 35:14.060
好 那回头到你再来看啊 这边这个题目 什么是虚拟多么

35:15.100 --> 35:19.980
优点有哪些 那你接下来回答的话 是不是就不止这一句话了

35:20.860 --> 35:25.900
对不对 我一开始我就说了你这边就一句话的话 你是不能够给面试官留下一个

35:25.900 --> 35:31.900
很深刻的这个印象的 对不对 这个基本上就是人云亦云啊 就大家都是这么说的

35:32.540 --> 35:36.860
好 我这边呢 我给一个这个参考答案啊 把这边的话我把他拿过来

35:40.380 --> 35:41.260
好 把他拿过来

35:43.440 --> 35:49.120
ok 好 什么是虚拟多么 虚拟多么的话 最初是由reactor团队所提出的概念

35:49.360 --> 35:52.240
他是一种什么呢 他是一种编程的思想

35:53.040 --> 35:56.160
对不对 指的是对真实ui多么的一种描述能力

35:56.800 --> 36:04.080
那虚拟多么和结实对象之间的关系 前者是思想 后者是针对这种思想的具体实现

36:05.200 --> 36:11.520
对不对 而使用虚拟多么有什么优势呢 首先第一个是相较于多么的体积和速度优势

36:12.080 --> 36:14.720
第二个是多平台渲染的抽象能力

36:15.200 --> 36:22.320
啊 再加这边你再来解释一下 什么叫做相较于多么的体积和速度优势啊 以及这个多平台渲染的抽象能力

36:22.720 --> 36:26.960
不同的这个数组 这个数组环境对应用的包是什么

36:27.520 --> 36:33.440
对不对 最后再解释一下这个reactor中 他这边的话这个虚拟多么对象是长什么样子的

36:33.840 --> 36:39.680
对不对 他是通过这个调用create element这个方法 最终会返回一个结实对象

36:40.240 --> 36:43.360
那官方的话 更加倾向于称之为reactor元素

36:44.800 --> 36:48.320
啊 这就是关于整个这个什么是虚拟多么

36:48.880 --> 36:54.240
ok 大家下去的话可以把这些课的内容自己再看一下啊 自己把它总结一下

36:54.880 --> 36:58.080
好吧 好 这些课的话就到这里啊 再见

