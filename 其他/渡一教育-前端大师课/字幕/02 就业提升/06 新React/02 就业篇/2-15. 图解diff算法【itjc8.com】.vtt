WEBVTT

00:00.000 --> 00:03.200
OK,好,我们来看一下这道面试题

00:04.200 --> 00:10.200
REG中的DIV算法有没有了解过,具体的流程是怎么样的

00:10.800 --> 00:14.800
REG的为什么不采用这个view里面的这种双端对比算法

00:15.200 --> 00:18.000
那这道面试题的话很明显就是在问这个

00:18.200 --> 00:21.000
是否了解这个REG里面的这个DIV算法了

00:21.600 --> 00:23.800
所以我们这一节课的话,我们把这个

00:24.000 --> 00:27.800
整个REG里面的这个DIV算法给同学们介绍一下

00:28.000 --> 00:30.600
OK,这些课我们会用很多图

00:30.800 --> 00:33.600
所以你看这个名字都叫做图解DIV算法

00:33.800 --> 00:38.800
会用很多这个图一步一步带着大家去理解这个REG中

00:39.000 --> 00:42.800
它这个DIV算法,它整个这个流程是什么样子的

00:43.000 --> 00:45.600
OK,好,那前面的话我们再讲了

00:45.800 --> 00:48.200
整个REG的话,它分成两大阶段

00:48.400 --> 00:51.600
一个是Render阶段,一个是Commit阶段

00:51.800 --> 00:54.600
对吧,Render阶段的话它会生成什么呢

00:54.800 --> 00:56.800
它会生成这个fiber数,对不对

00:56.800 --> 01:05.800
Render阶段会生成fiber3,就这个fiber数

01:06.000 --> 01:10.800
那所谓的这个DIV实际上就是发生在这个阶段

01:11.000 --> 01:17.800
所谓的DIV实际上就是发生在这个阶段

01:18.800 --> 01:22.800
那它这边DIV它所谓的DIV是谁和谁进行DIV呢

01:22.800 --> 01:32.800
首先这个要搞清楚,这里的DIV,这里的DIV,DIV指的是

01:33.800 --> 01:41.800
这个currentfiber,fibernode和什么呢,和js差对象

01:42.800 --> 01:46.800
什么是js差对象,就是你CreatorElement那个对象

01:47.000 --> 01:50.800
返回到react元素,你也可以称之为react元素

01:50.800 --> 01:53.800
而是这两个之间进行对比

01:54.800 --> 02:00.800
之间进行对比,然后生成什么呢

02:00.800 --> 02:04.800
生成新的这个vipfibernode

02:05.800 --> 02:09.800
怎么样吧,我把这个的话给你画重点,指的是这个

02:10.800 --> 02:12.800
首先的话一定要把这个搞清楚

02:12.800 --> 02:15.800
它这边这个DIV究竟是谁和谁在进行比

02:15.800 --> 02:19.800
比了之后,然后接下来它要一个什么样的这个结果

02:20.800 --> 02:23.800
它指的是currentfibernode

02:23.800 --> 02:27.800
这个的话就是我们之前讲那个fiber双缓冲的时候

02:27.800 --> 02:31.800
我们是不是讲过,对了,它分为currentfibertree

02:31.800 --> 02:33.800
还有一个是微波fibertree

02:33.800 --> 02:37.800
而它这边就是currentfibernode和js差对象

02:37.800 --> 02:40.800
js差对象指的就是react元素

02:40.800 --> 02:44.800
除了react以外,实际上其他的一些

02:44.800 --> 02:48.800
就是使用虚拟动物技术的前端框架

02:48.800 --> 02:50.800
实际上也有类似的流程

02:50.800 --> 02:53.800
比如view,view里面是不是也用到了这个虚拟动物

02:53.800 --> 02:55.800
对不对,只不过在view里面

02:55.800 --> 02:58.800
它把这个过程的话称之为patch

02:59.800 --> 03:03.800
就除了react以外

03:04.800 --> 03:07.800
然后其他使用到了

03:07.800 --> 03:12.800
使用到了这个虚拟动物的前端框架

03:12.800 --> 03:15.800
前端框架也会有这个类似的流程

03:16.800 --> 03:21.800
也会有类似的流程

03:21.800 --> 03:24.800
比如这个view里面

03:24.800 --> 03:29.800
view里面将这个流程称之为什么呢

03:29.800 --> 03:31.800
称之为patch

03:31.800 --> 03:33.800
称之为patch

03:33.800 --> 03:36.800
好,这个dif算法

03:36.800 --> 03:41.800
dif算法的话,它本身会带来性能上面的消耗

03:41.800 --> 03:43.800
本身是有性能上面消耗的

03:43.800 --> 03:46.800
在react文档中提到

03:46.800 --> 03:49.800
即使你采用最前沿的算法

03:49.800 --> 03:53.800
将两棵树完全地进行对比

03:53.800 --> 03:55.800
那它这个算法的复杂度

03:55.800 --> 03:58.800
也是O的N3次法

03:58.800 --> 04:02.800
其中N的话是原数的数量

04:02.800 --> 04:04.800
如果你react

04:04.800 --> 04:07.800
你使用这个算法来比较

04:07.800 --> 04:10.800
来比较一个完整的两棵树

04:10.800 --> 04:12.800
比如说这个树里面有1000个元数

04:12.800 --> 04:15.800
那它这个执行的这个计算

04:15.800 --> 04:18.800
它是属于10亿的量级范围的

04:18.800 --> 04:21.800
这个开销的话,实际上是非常昂贵的

04:21.800 --> 04:23.800
ok,我们这边记一下

04:23.800 --> 04:33.800
dif算法本身是有性能上面的消耗的

04:33.800 --> 04:36.800
首先你要明确这一点

04:36.800 --> 04:41.800
在react文档中有提到

04:41.800 --> 04:45.800
即便采用什么呢

04:45.800 --> 04:47.800
采用这个最前沿的算法

04:47.800 --> 04:50.800
最前沿的算法

04:50.800 --> 04:55.800
如果要完整的对比两棵树

04:55.800 --> 04:58.800
要完整的对比两棵树

04:58.800 --> 05:02.800
那么算法的复杂度

05:02.800 --> 05:08.880
复杂度都会达到什么呢

05:08.880 --> 05:11.880
达到这个O,然后N3次法

05:12.880 --> 05:16.880
这个的话是具体对应的那个时间复杂度

05:16.880 --> 05:18.880
就算法的时间复杂度

05:18.880 --> 05:19.880
这个你不了解的话

05:19.880 --> 05:21.880
你自己可以下去这个查一下

05:21.880 --> 05:22.880
就我们算法的话

05:22.880 --> 05:26.880
它会有一个平量的复杂度的这种考量

05:26.880 --> 05:29.880
一个是时间复杂度,一个是空间复杂度

05:29.880 --> 05:32.880
那这边让你这个算法的这个时间复杂度

05:32.880 --> 05:34.880
达到这个O的N3次法的话

05:34.880 --> 05:36.880
实际上是已经比较恐怖了

05:36.880 --> 05:40.880
ok,这边N代表的是

05:40.880 --> 05:45.880
这个元素的数量

05:45.880 --> 05:48.880
如果N为什么呢

05:48.880 --> 05:53.150
为这个1000

05:53.150 --> 05:56.150
那你这边就是要执行的计算量

05:56.150 --> 05:59.150
要执行的计算量

05:59.150 --> 06:01.150
会达到多少呢

06:01.150 --> 06:03.150
会达到这个10亿

06:03.150 --> 06:06.150
10亿量级

06:06.150 --> 06:09.150
10亿量级,这个级别

06:09.150 --> 06:12.150
ok,10亿量级的级别

06:13.150 --> 06:15.150
所以因此的话

06:15.150 --> 06:16.150
你这个开销的话

06:16.150 --> 06:18.150
实际上是非常昂贵的

06:18.150 --> 06:21.150
那为了降低这个算法的这个复杂度

06:21.150 --> 06:23.150
那react的这个递付算法

06:23.150 --> 06:25.150
它是设置了三个限制的

06:25.150 --> 06:29.150
因此为了降低

06:29.150 --> 06:34.780
为了降低算法的这个复杂度

06:34.780 --> 06:38.780
react,设置了

06:38.780 --> 06:42.780
为这个react,为这个递付算法

06:42.780 --> 06:46.780
设置了三个限制

06:46.780 --> 06:48.780
哪三个限制呢

06:48.780 --> 06:49.780
我们来看一下

06:49.780 --> 06:52.780
首先第一个,限制1

06:52.780 --> 06:56.780
这边只对同级元素进行递付

06:56.780 --> 07:05.220
只对同级元素进行递付

07:05.220 --> 07:09.220
如果你一个动物元素在前后两次更新中

07:09.220 --> 07:11.220
它跨越了这个成绩

07:11.220 --> 07:12.220
那么这个react的话

07:12.220 --> 07:15.220
它是不会去尝试附用它的

07:15.220 --> 07:24.220
如果一个动物元素在这个前后两次更新中

07:24.220 --> 07:27.220
跨越了这个成绩

07:27.220 --> 07:33.220
那么react不会尝试这个附用它

07:33.220 --> 07:36.730
这是首先第一个限制

07:36.730 --> 07:37.730
然后接下来的话

07:37.730 --> 07:41.170
第二个限制2

07:41.170 --> 07:44.170
就你两个不同类型的这个元素

07:44.170 --> 07:45.170
它会产生什么呢

07:45.170 --> 07:47.170
它会产生不同的这个数

07:47.170 --> 07:50.170
如果你比如说元素从这个DIV变成了这个P

07:50.170 --> 07:54.170
那么这个react它会销毁这个DIV

07:54.170 --> 07:56.170
以及它后面的这个子孙元素

07:56.170 --> 07:58.170
并且这个新建这个P

07:58.170 --> 08:01.170
以及P后面的子孙元素

08:01.170 --> 08:06.170
两个不同类型的元素

08:06.170 --> 08:10.170
会产生不同的数

08:10.170 --> 08:13.170
比如元素

08:13.170 --> 08:18.170
从这个DIV变成了P

08:18.170 --> 08:22.170
那么react会什么呢

08:22.170 --> 08:25.170
会直接销毁

08:25.170 --> 08:29.170
销毁DIV以及它的子孙

08:29.170 --> 08:31.170
子孙元素

08:31.170 --> 08:32.170
然后新建什么呢

08:32.170 --> 08:39.170
新建P以及P对应的子孙元素

08:39.170 --> 08:41.170
这是第二个限制

08:41.170 --> 08:43.170
好,然后第三个限制

08:43.170 --> 08:45.170
限制3

08:45.170 --> 08:47.170
开发者的话可以通过什么呢

08:47.170 --> 08:50.170
开发者可以通过key

08:50.170 --> 08:54.170
开发者可以通过key

08:54.170 --> 08:55.170
来什么呢

08:55.170 --> 08:57.170
来这个暗示

08:57.170 --> 09:01.170
哪些子元素在不同的这个渲染下

09:01.170 --> 09:03.170
能够保持稳定

09:03.170 --> 09:05.170
比如说通过key来暗示

09:05.170 --> 09:08.170
哪些子元素

09:08.170 --> 09:12.540
能够保持稳定

09:12.540 --> 09:15.540
好,比如说我们这边举个例子

09:15.540 --> 09:19.560
比如说这边更新前

09:19.560 --> 09:20.560
更新前的话

09:20.560 --> 09:21.560
我们的这个结构是什么样子呢

09:21.560 --> 09:23.560
我们的结构是这样子的

09:23.560 --> 09:25.560
把这个拿过来

09:25.560 --> 09:27.560
这边对应的是这样子的一个结构

09:27.560 --> 09:29.560
DIV,人家这边有个P

09:29.560 --> 09:30.560
有个H3

09:30.560 --> 09:32.560
P的话这边对应一个key是1

09:32.560 --> 09:35.560
然后接下来这边H3对应的key是2

09:35.560 --> 09:39.560
好,然后接下来的话更新后

09:40.560 --> 09:41.560
更新后之后

09:41.560 --> 09:43.560
然后接下来它变成什么样子呢

09:43.560 --> 09:44.560
变这个样子

09:44.560 --> 09:48.150
变这样子

09:48.150 --> 09:50.150
你可以看到这个H3的话跑到什么

09:50.150 --> 09:53.150
所以成为了DIV的第一个元素

09:53.150 --> 09:57.150
而这个P的话成为了这个DIV的第二个元素

09:57.150 --> 09:59.150
两个其实这个P和H3

09:59.150 --> 10:02.150
是不是就是进行了这个位置上面的这个互换

10:02.150 --> 10:03.150
对不对

10:03.150 --> 10:05.150
那么如果没有key

10:05.150 --> 10:09.720
如果没有key

10:09.720 --> 10:11.720
那么这个rekt

10:11.720 --> 10:13.720
它就会什么呢

10:13.720 --> 10:19.030
就会认为你这个DIV

10:19.030 --> 10:22.030
DIV的这个第一个指元素

10:22.030 --> 10:23.030
从什么呢

10:23.030 --> 10:26.030
从这个P变成了

10:26.030 --> 10:29.030
变成了这个H3

10:29.030 --> 10:32.030
然后加第二个指元素

10:32.030 --> 10:33.030
第二个指元素

10:33.030 --> 10:34.030
从什么呢

10:34.030 --> 10:38.030
从这个H3变成了这个P

10:38.030 --> 10:39.030
对不对

10:39.030 --> 10:40.030
所以它这边的话就是会干嘛呢

10:40.030 --> 10:42.030
它这边的话就会这个销毁

10:42.030 --> 10:44.030
比如把这个第一个P销毁了

10:44.030 --> 10:46.030
大家新增这个H3

10:46.030 --> 10:48.030
大家这边的话把这个H3

10:48.030 --> 10:50.030
就第二个H3也会销毁

10:50.030 --> 10:53.030
大家新增这个P

10:53.030 --> 10:56.030
因此rekt

10:56.030 --> 10:59.030
rekt就会

10:59.030 --> 11:00.030
采用什么呢

11:00.030 --> 11:04.030
采用这个限制二的这个规则

11:04.030 --> 11:05.030
什么限制二的规则

11:05.030 --> 11:06.030
就刚才这边所说的

11:06.030 --> 11:08.030
对你这边如果变成了P

11:08.030 --> 11:09.030
它就会干嘛

11:09.030 --> 11:10.030
直接销毁

11:10.030 --> 11:11.030
对销毁这个DIV

11:11.030 --> 11:13.030
以及它后面的指纯元素

11:13.030 --> 11:14.030
新建这个P

11:14.030 --> 11:15.030
以及P对应的指纯元素

11:15.030 --> 11:19.030
它这边就会采用这个限制二的这个规则

11:19.030 --> 11:21.030
但是如果你使用了P

11:21.030 --> 11:26.030
但是如果使用了这个P

11:26.030 --> 11:27.030
这个P的话

11:27.030 --> 11:28.030
它就是拿来干嘛呢

11:28.030 --> 11:30.030
它指明了这个元素

11:30.030 --> 11:33.030
更新前后的这么一个对应关系

11:33.030 --> 11:34.030
对不对

11:34.030 --> 11:36.030
你Key为1的这个P

11:36.030 --> 11:38.030
它在更新后仍然存在

11:38.030 --> 11:39.030
说这个时候它这个DOM元素

11:39.030 --> 11:41.030
它是可以附用的

11:41.030 --> 11:43.030
如果你使用了Key

11:43.030 --> 11:46.030
那么此时的这个DOM元素

11:46.030 --> 11:49.030
是可以附用的

11:49.030 --> 11:51.030
只不过什么呢

11:51.030 --> 11:53.030
只不过就是前后

11:53.030 --> 11:57.030
前后交换了位置而已

11:57.030 --> 11:58.030
对不对

11:58.030 --> 12:01.030
所以这边就是你用了Key和不用Key

12:01.030 --> 12:03.030
它之间的这个区别

12:03.030 --> 12:04.030
好

12:04.030 --> 12:05.030
然后接下来

12:05.030 --> 12:08.030
然后我们这边回头再来看这个限制一

12:08.030 --> 12:10.030
接下来

12:10.030 --> 12:14.030
我们回头再来看限制一

12:14.030 --> 12:15.030
限制一是什么

12:15.030 --> 12:19.030
只对同级元素进行这个DIF

12:19.030 --> 12:20.030
对不对

12:20.030 --> 12:22.030
不会这个跨成级

12:22.030 --> 12:23.030
好那接下来的话

12:23.030 --> 12:31.030
这边对同级元素进行这个DIF

12:31.030 --> 12:34.030
那么究竟是如何进行DIF呢

12:35.030 --> 12:40.030
实际上整个这个DIF的流程

12:40.030 --> 12:42.030
可以分成两类

12:42.030 --> 12:46.030
整个DIF的流程

12:46.030 --> 12:49.030
可以分为两大类

12:49.030 --> 12:51.030
哪两大类呢

12:51.030 --> 12:53.030
一个的话是你更新后

12:53.030 --> 12:55.030
只有一个元素

12:55.030 --> 12:57.030
更新后

12:57.030 --> 13:00.030
只有一个元素

13:00.030 --> 13:01.030
OK

13:01.030 --> 13:02.030
那么此时的话

13:02.030 --> 13:03.030
它就会根据你的这个

13:03.030 --> 13:04.030
New Child的

13:04.030 --> 13:07.030
创建对应的这个Web Fiber Load

13:07.030 --> 13:09.030
就更新后

13:09.030 --> 13:11.030
更新后只有

13:11.030 --> 13:13.030
只有

13:13.030 --> 13:15.030
这边更新后只有一个元素

13:15.030 --> 13:18.030
此时就会根据什么呢

13:18.030 --> 13:21.030
根据你的这个New Child

13:21.030 --> 13:23.030
New Child的

13:23.030 --> 13:25.030
然后创建

13:25.030 --> 13:30.030
对应的这个Web Fiber Load

13:31.030 --> 13:33.030
这边对应的流程

13:33.030 --> 13:35.030
对应的流程就是什么呢

13:35.030 --> 13:38.030
就是单节点DIF

13:38.030 --> 13:39.030
OK

13:39.030 --> 13:40.030
这个我们称为单节点

13:40.030 --> 13:41.030
还有一种情况是什么呢

13:41.030 --> 13:44.030
还有一种情况是你更新后

13:44.030 --> 13:46.030
有多个元素

13:46.030 --> 13:49.030
有多个元素

13:49.030 --> 13:51.030
那么此时

13:51.030 --> 13:52.030
就会什么呢

13:52.030 --> 13:55.030
此时就会便利

13:55.030 --> 13:58.030
便利这个New Child

13:58.030 --> 13:59.030
因为你这个多个元素呢

13:59.030 --> 14:01.030
这个New Child它肯定是个数组

14:01.030 --> 14:02.030
肯定是个数组

14:02.030 --> 14:04.030
所以便利这个New Child

14:04.030 --> 14:10.030
创建这个对应的这个Web Fiber Load

14:10.030 --> 14:15.600
以及它的兄弟元素

14:15.600 --> 14:17.600
那么此时对应的

14:17.600 --> 14:22.600
此时对应的这个流程

14:22.600 --> 14:23.600
就是什么呢

14:23.600 --> 14:25.600
就是这个多节点

14:25.600 --> 14:27.600
多节点DIF

14:27.600 --> 14:28.600
OK

14:28.600 --> 14:30.600
所以你看针对这个限制1

14:30.600 --> 14:31.600
这边的话又分为什么呢

14:31.600 --> 14:35.600
又分为单节点和多节点

14:35.600 --> 14:36.600
好那接下来的话

14:36.600 --> 14:38.600
我们就一个一个来看

14:38.600 --> 14:43.600
首先第一个的话是单节点DIF

14:43.600 --> 14:44.600
好那接下来这边还有什么呢

14:44.600 --> 14:46.600
还有就是多节点

14:46.600 --> 14:48.600
多节点DIF

14:48.600 --> 14:50.600
一个一个来

14:50.600 --> 14:52.600
首先的话是这个单节点

14:52.600 --> 14:53.600
好单节点的话

14:53.600 --> 14:54.600
刚刚我们说过了

14:54.600 --> 14:55.600
单节点的话指的是什么呢

14:55.600 --> 14:57.600
指的是新节点是单节点

14:57.600 --> 14:58.600
对不对

14:58.600 --> 15:03.600
单节点指的是新节点

15:03.600 --> 15:06.600
为单一节点

15:06.600 --> 15:08.600
但是这个就节点

15:08.600 --> 15:14.040
就就节点的这个数量

15:14.040 --> 15:17.670
是不一定的

15:17.670 --> 15:18.670
OK

15:18.670 --> 15:19.670
那你这个单节点DIF

15:19.670 --> 15:21.670
它是否能够进行这个附用

15:21.670 --> 15:23.670
它有这么一个顺序

15:23.670 --> 15:27.670
单节点DIF

15:27.670 --> 15:31.670
然后这个是否能够附用

15:31.670 --> 15:34.670
能够附用

15:34.670 --> 15:40.200
遵循以下的流程

15:40.200 --> 15:41.200
什么流程呢

15:41.200 --> 15:44.200
首先的话判断key是否相同

15:44.200 --> 15:48.200
判断key是否相同

15:48.200 --> 15:49.200
好那接下来

15:49.200 --> 15:53.200
如果这个key相同

15:53.200 --> 15:54.200
它就会干嘛呢

15:54.200 --> 15:56.200
它就会再判断

15:56.200 --> 15:59.200
再判断这个type

16:00.200 --> 16:02.200
是否相同

16:02.200 --> 16:03.200
OK

16:03.200 --> 16:08.600
好注意它这边再判断key是否相同的时候

16:08.600 --> 16:10.600
它有这么几种情况

16:10.600 --> 16:11.600
什么呢

16:11.600 --> 16:14.600
就是你如果更新前后没有设置key

16:14.600 --> 16:21.600
如果更新前后没有设置key

16:21.600 --> 16:25.600
那么key就是什么呢

16:25.600 --> 16:27.600
key就是no

16:27.600 --> 16:28.600
这个也是属于什么呢

16:28.600 --> 16:30.600
也是属于相同的情况

16:30.600 --> 16:35.600
也是属于相同的情况

16:35.600 --> 16:37.600
如果你key相同

16:37.600 --> 16:42.230
如果key相同

16:42.230 --> 16:46.230
那么就会进入

16:46.230 --> 16:50.230
就会进入到不走二

16:50.230 --> 16:51.230
好

16:51.230 --> 16:54.230
然后如果key不同

16:54.230 --> 16:57.230
如果key不同

16:57.230 --> 16:58.230
那key不同的话

16:58.230 --> 17:01.230
我们是不是就不需要再判断type

17:01.230 --> 17:02.230
对不对

17:02.230 --> 17:06.230
就不需要进入不走二

17:06.230 --> 17:10.230
无需判断type

17:10.230 --> 17:14.230
结果直接为什么呢

17:14.230 --> 17:17.230
直接为不能附用

17:17.230 --> 17:18.230
但是你注意

17:18.230 --> 17:19.230
如果它这个有兄弟节点的话

17:19.230 --> 17:22.230
它还会去便利这个兄弟节点

17:22.230 --> 17:26.230
如果有兄弟节点

17:26.230 --> 17:30.230
还会去便利

17:30.230 --> 17:34.230
兄弟节点

17:34.230 --> 17:35.230
好

17:35.230 --> 17:37.230
然后如果key相同

17:37.230 --> 17:38.230
key相同的话

17:38.230 --> 17:39.230
那接下来这边

17:39.230 --> 17:41.230
判断type是否相同

17:41.230 --> 17:44.230
如果type相同

17:44.230 --> 17:46.230
如果type相同

17:46.230 --> 17:47.230
那么就什么呢

17:47.230 --> 17:53.270
那么就附用

17:53.270 --> 17:56.270
如果type不同

17:56.270 --> 17:57.270
type不同的话

17:57.270 --> 17:59.270
但是你key又是相同的

17:59.270 --> 18:00.270
那它这边

18:00.270 --> 18:01.270
这个key相同

18:01.270 --> 18:03.270
是不是已经确定找到是刚才的一个

18:03.270 --> 18:04.270
对不对

18:04.270 --> 18:05.270
但是你type不同

18:05.270 --> 18:06.270
那说明确实是变了

18:06.270 --> 18:09.270
所以这边就是无法附用

18:09.270 --> 18:11.270
无法附用

18:11.270 --> 18:14.270
并且兄弟节点

18:14.270 --> 18:18.270
并且兄弟节点

18:18.270 --> 18:19.270
兄弟节点

18:19.270 --> 18:21.270
也一并

18:21.270 --> 18:25.270
这个标记为三处

18:25.270 --> 18:26.270
整体的流程的话

18:26.270 --> 18:29.270
大致是这个样子

18:29.270 --> 18:31.270
那我们这边我们来看一些例子

18:31.270 --> 18:35.800
比如说我更新前

18:35.800 --> 18:36.800
更新前的话

18:36.800 --> 18:41.520
我的结构是这样子的

18:41.520 --> 18:42.520
然后接下来

18:42.520 --> 18:46.470
我这边更新后

18:46.470 --> 18:48.470
更新后我的节点是这个样子的

18:48.470 --> 18:54.740
这个是不是很明显是一个单节点的地方

18:54.740 --> 18:55.740
对不对

18:55.740 --> 18:56.740
单节点的地方

18:56.740 --> 18:57.740
那这个单节点的地方的话

18:57.740 --> 18:59.740
那由于你这个

18:59.740 --> 19:00.740
这边有一个p

19:00.740 --> 19:03.740
但是他们是不没有设置这个key

19:03.740 --> 19:05.740
那key的默认值就是什么

19:05.740 --> 19:06.740
key的默认值是不是就是

19:06.740 --> 19:07.740
no

19:07.740 --> 19:09.740
说他这边的话会认为什么呢

19:09.740 --> 19:11.740
他这边会认为你前后的这个key

19:11.740 --> 19:14.740
他会被认为是这个相同的

19:14.740 --> 19:17.740
这里

19:17.740 --> 19:21.740
因为没有设置key

19:21.740 --> 19:25.740
所以会被认为

19:25.740 --> 19:28.740
这个key是相同的

19:28.740 --> 19:29.740
认为key是相同的

19:29.740 --> 19:31.740
然后接下来

19:31.740 --> 19:33.740
就会进入到什么呢

19:33.740 --> 19:36.740
进入到这个type

19:36.740 --> 19:38.740
type的这个判断

19:38.740 --> 19:40.740
那这个type的话一不一

19:40.740 --> 19:42.740
type你看第一个是利

19:42.740 --> 19:44.740
第二个是什么是不是p

19:44.740 --> 19:45.740
对不对

19:45.740 --> 19:46.740
那接下来会发现这个

19:46.740 --> 19:48.740
此时发现这个type不一样

19:48.740 --> 19:53.740
此时发现type不同

19:53.740 --> 19:55.740
那你这个type不同的话

19:55.740 --> 19:56.740
他代表什么

19:56.740 --> 19:57.740
他是不是已经代表

19:57.740 --> 19:59.740
代表就是已经找到本次

19:59.740 --> 20:02.740
更新的p所对应的这个fabre load

20:02.740 --> 20:04.740
对但由于这个type不同

20:04.740 --> 20:06.740
所以你不能附用

20:06.740 --> 20:08.740
那既然这个唯一的这个可能性

20:08.740 --> 20:09.740
都已经不能附用了

20:09.740 --> 20:10.740
那其他的这种兄弟

20:10.740 --> 20:12.740
节点的这个fabre load

20:12.740 --> 20:14.740
是不是就也就没有机会了

20:14.740 --> 20:15.740
对不对

20:15.740 --> 20:18.740
所以就都标记为删除

20:18.740 --> 20:21.740
此时发现这个type不同

20:21.740 --> 20:23.740
因此

20:23.740 --> 20:24.740
因此什么呢

20:24.740 --> 20:29.740
就是不能够附用

20:29.740 --> 20:30.740
对不对

20:30.740 --> 20:31.740
好那你这边的话

20:31.740 --> 20:33.740
既然这个唯一的可能性

20:33.740 --> 20:39.740
既然这里唯一的可能性

20:39.740 --> 20:43.740
都已经不能够附用

20:43.740 --> 20:45.740
那么会直接标记什么

20:45.740 --> 20:50.740
会直接标记这个兄弟元素

20:50.740 --> 20:53.740
就兄弟这个fabre load

20:53.740 --> 20:55.740
为什么

20:55.740 --> 20:58.740
为这个删除状态

20:58.740 --> 21:00.740
完须就要去找这个兄弟元素

21:00.740 --> 21:02.740
这不需要了

21:02.740 --> 21:03.740
就不需要了

21:03.740 --> 21:08.400
但是你这边要注意

21:08.400 --> 21:10.400
如果是key不同的

21:10.400 --> 21:11.400
你刚才的话

21:11.400 --> 21:12.400
这边是key相同

21:12.400 --> 21:13.400
对不对

21:13.400 --> 21:14.400
key相同的话

21:14.400 --> 21:15.400
既然type不同

21:15.400 --> 21:16.400
它这个不能附用

21:16.400 --> 21:17.400
那如果是key

21:17.400 --> 21:18.400
这个不同的

21:18.400 --> 21:20.400
不同的话只能代表

21:20.400 --> 21:22.400
就是你当前的这个fabre load

21:22.400 --> 21:23.400
是无法附用

21:23.400 --> 21:25.400
这边反复强调

21:25.400 --> 21:29.400
如果上面的粒子中

21:29.400 --> 21:32.400
这个key不同

21:32.400 --> 21:34.400
key不同只能代表什么呢

21:35.400 --> 21:45.400
只能代表当前的fabre load

21:45.400 --> 21:48.400
无法附用

21:48.400 --> 21:49.400
对不对

21:49.400 --> 21:57.400
因此还需要去便利这个兄弟

21:57.400 --> 22:01.400
兄弟的fabre load

22:01.400 --> 22:03.400
你如果是key相同

22:03.400 --> 22:04.400
key相同的话

22:04.400 --> 22:05.400
说明就是和之前的话

22:05.400 --> 22:07.400
是相同的一个fabre load

22:07.400 --> 22:09.400
但是你这边的type不同

22:09.400 --> 22:10.400
那你这边就没办法附用

22:10.400 --> 22:12.400
唯一的可能性都已经不能附用了

22:12.400 --> 22:14.400
那其他的兄弟fabre load

22:14.400 --> 22:16.400
直接为删除

22:16.400 --> 22:17.400
对不对

22:17.400 --> 22:19.400
但是你如果key不同

22:19.400 --> 22:20.400
不同的话

22:20.400 --> 22:22.400
只能代表当前的fabre load

22:22.400 --> 22:23.400
是不能附用的

22:23.400 --> 22:25.400
那你还需要去看一下

22:25.400 --> 22:27.400
其他兄弟的fabre load

22:27.400 --> 22:29.400
这一点的话一定要清洗

22:29.400 --> 22:31.400
这个在上面我也写了

22:31.400 --> 22:32.400
对不对

22:32.400 --> 22:33.400
key不同

22:33.400 --> 22:35.400
这边需要去便利兄弟这个节点

22:35.400 --> 22:37.400
但是你如果key相同

22:37.400 --> 22:38.400
key相同的话

22:38.400 --> 22:40.400
就是这个已经是和之前

22:40.400 --> 22:42.400
同一个fabre load

22:42.400 --> 22:43.400
对不对

22:43.400 --> 22:44.400
但是你type不同

22:44.400 --> 22:45.400
type不同就没办法附用

22:45.400 --> 22:46.400
那这个兄弟节点的话

22:46.400 --> 22:48.400
也不需要再去便利了

22:48.400 --> 22:50.400
那兄弟节点它肯定不一样

22:50.400 --> 22:51.400
肯定不一样

22:51.400 --> 22:52.400
对不对

22:52.400 --> 22:53.400
ok

22:53.400 --> 22:55.400
这是这个

22:55.400 --> 22:56.400
来接下来我们这边

22:56.400 --> 22:57.400
再来看一些例子吧

22:57.400 --> 22:59.400
下面

22:59.400 --> 23:01.400
我们再来

23:01.400 --> 23:03.400
看一些实例

23:05.400 --> 23:07.400
比较这边更新前

23:07.400 --> 23:09.400
然后更新后

23:09.400 --> 23:13.500
好这边更新前

23:13.500 --> 23:14.500
更新前是什么样子呢

23:14.500 --> 23:18.710
更新前是这样子的

23:18.710 --> 23:19.710
更新前是这样子

23:19.710 --> 23:20.710
好然后接下来

23:20.710 --> 23:22.710
这个更新后

23:22.710 --> 23:26.660
更新后的话是这个样子的

23:26.660 --> 23:27.660
ok

23:27.660 --> 23:29.660
那你这边那你没有设置key

23:29.660 --> 23:30.660
没有设置key的话

23:30.660 --> 23:31.660
他默认这个key是不是

23:31.660 --> 23:32.660
就是那

23:32.660 --> 23:33.660
对不对

23:33.660 --> 23:35.660
没有

23:35.660 --> 23:37.660
没有设置key

23:37.660 --> 23:39.660
那么可以

23:39.660 --> 23:41.660
认为

23:41.660 --> 23:43.660
这个默认这个key

23:43.660 --> 23:45.660
就是

23:45.660 --> 23:47.660
对那两个key的话是相同的

23:47.660 --> 23:49.660
两个就前后

23:49.660 --> 23:52.660
更新前后

23:52.660 --> 23:54.660
两个这个key

23:54.660 --> 23:56.660
是相同的

23:56.660 --> 23:58.660
那么接下来就干嘛

23:58.660 --> 24:00.660
就查看这个type

24:00.660 --> 24:01.660
对不对

24:01.660 --> 24:02.660
发现什么呢

24:02.660 --> 24:04.660
发现这个type

24:04.660 --> 24:05.660
不同

24:05.660 --> 24:07.660
那因此

24:07.660 --> 24:12.190
不能复用

24:12.190 --> 24:14.190
因此不能复用

24:14.190 --> 24:16.190
好然后接下来

24:16.190 --> 24:17.190
这边我们再来看一个例子

24:17.190 --> 24:21.140
就是更新前

24:21.140 --> 24:26.180
更新后

24:26.180 --> 24:27.180
更新前

24:27.180 --> 24:28.180
更新前那这边是什么样子呢

24:28.180 --> 24:30.180
这边是这个样子的

24:30.180 --> 24:32.180
这边的话他这里有key了

24:32.180 --> 24:33.180
对不对

24:33.180 --> 24:34.180
手动设置的这个key

24:34.180 --> 24:36.180
好然后这边的话是

24:36.180 --> 24:37.180
更新后

24:37.180 --> 24:39.180
更新后的话是这个样子的

24:39.180 --> 24:41.180
好大家可以思考一下

24:41.180 --> 24:42.180
这边可以思考一下

24:42.180 --> 24:44.180
就这个元素的话

24:44.180 --> 24:45.180
能不能复用

24:45.180 --> 24:46.180
你这个元素的话

24:46.180 --> 24:47.180
这边这个前后

24:47.180 --> 24:49.180
更新前后是不是key都不一样

24:49.180 --> 24:50.180
对不对

24:50.180 --> 24:51.180
更新前后

24:51.180 --> 24:54.560
更新前后key

24:54.560 --> 24:55.560
不同

24:55.560 --> 24:56.560
那你这个是吧

24:56.560 --> 24:58.560
不需要再判断type

24:58.560 --> 25:00.560
不需要再

25:00.560 --> 25:02.560
判断type

25:02.560 --> 25:04.560
他这个结果

25:04.560 --> 25:06.560
结果为什么

25:06.560 --> 25:07.560
是不能

25:07.560 --> 25:10.560
不能复用

25:10.560 --> 25:11.560
对不对

25:11.560 --> 25:13.560
好再来

25:13.560 --> 25:15.560
更新前

25:15.560 --> 25:19.900
更新后

25:19.900 --> 25:21.900
好这边来看一下

25:21.900 --> 25:23.900
好更新前的话是什么样子呢

25:23.900 --> 25:24.900
是这个样子的

25:24.900 --> 25:30.190
好然后更新后

25:30.190 --> 25:34.140
更新后的话是这个样子的

25:34.140 --> 25:38.180
好这个这个呢

25:38.180 --> 25:40.180
是不是同样是先判断key

25:40.180 --> 25:41.180
对不对

25:41.180 --> 25:42.180
你不要看到他这个type不一样了

25:42.180 --> 25:44.180
是不是叫先判断type不设

25:44.180 --> 25:46.180
你始终根据什么呢

25:46.180 --> 25:48.180
根据我们这边这个流程

25:48.180 --> 25:51.180
先判断key再判断

25:51.180 --> 25:52.180
这个type

25:52.180 --> 25:54.180
好你这边的这个key都不一样

25:54.180 --> 25:55.180
对不对

25:55.180 --> 25:56.180
key都不一样的话

25:56.180 --> 25:57.180
那这边他就是吗

25:57.180 --> 25:58.180
所以不需要再判断type

25:58.180 --> 26:01.180
和这个上面这个实际上是一样的

26:01.180 --> 26:02.180
对不对

26:02.180 --> 26:03.180
他也是这个

26:03.180 --> 26:05.180
不能复用

26:05.180 --> 26:09.330
好然后接下来下一个

26:09.330 --> 26:11.330
更新前

26:11.330 --> 26:15.790
更新后

26:15.790 --> 26:16.790
好这边更新前

26:16.790 --> 26:17.790
更新前是什么呢

26:17.790 --> 26:21.830
更新前是这个

26:21.830 --> 26:23.830
更新前是这个

26:23.830 --> 26:25.830
好更新后

26:25.830 --> 26:27.830
更新后的话是这个

26:27.830 --> 26:32.230
这边更新后

26:32.230 --> 26:34.930
更新后是这样子的

26:34.930 --> 26:35.930
好那这边呢

26:35.930 --> 26:37.930
首先判断key

26:37.930 --> 26:40.930
首先

26:40.930 --> 26:42.930
首先判断

26:42.930 --> 26:47.370
首先判断

26:47.370 --> 26:48.370
判断这个key

26:48.370 --> 26:50.370
是不是相同的

26:50.370 --> 26:51.370
对不对

26:51.370 --> 26:53.370
接下来判断什么

26:53.370 --> 26:54.370
判断type

26:54.370 --> 26:57.370
发现也是相同的

26:57.370 --> 26:58.370
那么这个的话

26:58.370 --> 27:00.370
是不是就可以复用

27:00.370 --> 27:01.370
对不对

27:01.370 --> 27:03.370
这个fiber node

27:03.370 --> 27:05.370
就能够

27:05.370 --> 27:07.370
复用

27:07.370 --> 27:08.370
对不对

27:08.370 --> 27:09.370
它这个里面

27:09.370 --> 27:10.370
里面的话

27:10.370 --> 27:12.370
这个1变成了2

27:12.370 --> 27:13.370
它这个的话只是这个

27:13.370 --> 27:15.370
求准的变化

27:15.370 --> 27:16.370
求准的变化的话

27:16.370 --> 27:17.370
你到时候把那个文本

27:17.370 --> 27:18.370
这个直接点

27:18.370 --> 27:19.370
什么更新一下就可以了

27:19.370 --> 27:20.370
对不对

27:20.370 --> 27:22.370
求准的变化

27:22.370 --> 27:24.370
求准

27:24.370 --> 27:26.370
求准是一个什么呢

27:26.370 --> 27:28.370
是一个文本节点

27:28.370 --> 27:30.370
文本节点

27:30.370 --> 27:33.370
然后将这个文本节点

27:33.370 --> 27:35.370
文本节点

27:35.370 --> 27:38.680
更新即可

27:38.680 --> 27:39.680
对不对

27:39.680 --> 27:40.680
这个的话就是关于这个

27:40.680 --> 27:42.680
单节点这个地步

27:42.680 --> 27:43.680
整体流程的话

27:43.680 --> 27:44.680
其实还是比较简单的

27:44.680 --> 27:45.680
判断这个key

27:45.680 --> 27:47.680
是否相同

27:47.680 --> 27:48.680
key相同就不同

27:48.680 --> 27:49.680
它会怎么样

27:49.680 --> 27:50.680
相同它会怎么样

27:50.680 --> 27:51.680
对吧

27:51.680 --> 27:52.680
相同进入到不择2

27:52.680 --> 27:53.680
不同

27:53.680 --> 27:54.680
不同的话就再去便利

27:54.680 --> 27:55.680
这个兄弟节点

27:55.680 --> 27:56.680
OK

27:56.680 --> 27:57.680
如果key相同

27:57.680 --> 27:58.680
key相同的话

27:58.680 --> 27:59.680
是不是表示是

27:59.680 --> 28:00.680
同一个fiber node

28:00.680 --> 28:01.680
对不对

28:01.680 --> 28:02.680
同一个fiber node

28:02.680 --> 28:03.680
然后type也相同

28:03.680 --> 28:04.680
那么就服用

28:04.680 --> 28:05.680
如果type不同

28:05.680 --> 28:06.680
type不同的话

28:06.680 --> 28:07.680
那就没办法服用

28:07.680 --> 28:09.680
并且你的这个兄弟节点

28:09.680 --> 28:11.680
也一并的就把它标记为三处

28:11.680 --> 28:13.680
它不是现在三处

28:13.680 --> 28:14.680
不是现在三处

28:14.680 --> 28:16.680
而是标记

28:16.680 --> 28:18.680
这个我们之前是不反复强调的

28:18.680 --> 28:19.680
对

28:19.680 --> 28:20.680
它会先做标记

28:20.680 --> 28:21.680
然后后面该三处的时候

28:21.680 --> 28:23.680
再同一进行一个三处

28:23.680 --> 28:24.680
OK

28:24.680 --> 28:26.680
这是关于这个单节点

28:26.680 --> 28:27.680
好

28:27.680 --> 28:28.680
那接下来

28:28.680 --> 28:30.680
看一下这个多节点

28:30.680 --> 28:31.680
多节点

28:31.680 --> 28:32.680
好

28:32.680 --> 28:34.680
所谓多节点的话指的是什么呢

28:34.680 --> 28:36.680
指的是新节点有多个

28:36.680 --> 28:39.680
所谓多节点

28:39.680 --> 28:40.680
def

28:40.680 --> 28:43.680
指的是新节点

28:43.680 --> 28:45.680
有多个

28:45.680 --> 28:46.680
OK

28:46.680 --> 28:47.680
那这边的话

28:47.680 --> 28:48.680
这个react团队

28:48.680 --> 28:49.680
他们发现

28:49.680 --> 28:51.680
就是在日常开发中

28:51.680 --> 28:53.680
节点的这个新增

28:53.680 --> 28:54.680
移动

28:54.680 --> 28:55.680
三处的这个情况

28:55.680 --> 28:57.680
实际上是比较少的

28:57.680 --> 28:58.680
往往都是什么呢

28:58.680 --> 28:59.680
往往都是针对这个节点

28:59.680 --> 29:01.680
进行一个更新操作

29:01.680 --> 29:03.680
所以基于这个理念

29:03.680 --> 29:05.680
react它这个多节点

29:05.680 --> 29:06.680
地负顺法

29:06.680 --> 29:09.680
它会这个进行这个两轮便利

29:09.680 --> 29:10.680
OK

29:10.680 --> 29:13.680
react团队发现

29:13.680 --> 29:16.680
在这个日常开发中

29:16.680 --> 29:18.680
这个对节点

29:18.680 --> 29:21.680
对节点的这个

29:21.680 --> 29:24.680
更新操作的这个情况

29:24.680 --> 29:27.680
往往要多于

29:27.680 --> 29:29.680
对这个节点

29:29.680 --> 29:32.680
节点这个新增

29:32.680 --> 29:35.680
新增三处

29:35.680 --> 29:37.680
还有就是移动

29:37.680 --> 29:38.680
OK

29:38.680 --> 29:40.680
因此

29:40.680 --> 29:42.680
在这个进行

29:42.680 --> 29:44.680
多节点

29:44.680 --> 29:46.680
地负的时候

29:46.680 --> 29:48.680
这个react

29:48.680 --> 29:50.680
react

29:50.680 --> 29:52.680
会进行什么呢

29:52.680 --> 29:54.680
进行两轮便利

29:54.680 --> 29:55.680
OK

29:55.680 --> 29:56.680
两轮便利

29:56.680 --> 29:58.680
首先第一轮

29:58.680 --> 30:00.680
首先第一轮便利

30:00.680 --> 30:01.680
第一轮便利的话

30:01.680 --> 30:02.680
它会干嘛呢

30:02.680 --> 30:03.680
它会去尝试

30:03.680 --> 30:05.680
足够的去复用节点

30:05.680 --> 30:07.680
会尝试

30:07.680 --> 30:10.680
足够

30:10.680 --> 30:13.680
足够的复用

30:13.680 --> 30:14.680
节点

30:14.680 --> 30:15.680
好

30:15.680 --> 30:17.680
然后接下来第二轮

30:17.680 --> 30:18.680
第二轮便利

30:18.680 --> 30:19.680
第二轮便利的话

30:19.680 --> 30:20.680
它会去处理什么呢

30:20.680 --> 30:22.680
会处理就是上一轮

30:22.680 --> 30:25.680
上一轮便利中

30:25.680 --> 30:30.820
没有处理完的节点

30:30.820 --> 30:31.820
OK

30:31.820 --> 30:33.820
它会是这么一个流程

30:33.820 --> 30:34.820
来我们这边

30:34.820 --> 30:35.820
让我们来看一下

30:35.820 --> 30:36.820
首先的话

30:36.820 --> 30:38.820
这边第一轮

30:38.820 --> 30:40.820
第一轮便利

30:40.820 --> 30:41.820
好

30:41.820 --> 30:42.820
然后一会儿的话

30:42.820 --> 30:46.220
会有第二轮

30:46.220 --> 30:47.220
OK

30:47.220 --> 30:48.220
好

30:48.220 --> 30:49.220
首先的话这个第一轮

30:49.220 --> 30:50.220
第一轮便利的话

30:50.220 --> 30:53.220
它会从前往后进行便利

30:53.220 --> 30:55.220
第一轮便利

30:55.220 --> 30:58.220
会从前往后

30:58.220 --> 31:01.220
一次进行便利

31:01.220 --> 31:02.220
好

31:02.220 --> 31:03.220
那这边的话存在什么呢

31:03.220 --> 31:06.220
存在三种情况

31:06.220 --> 31:07.220
哪三种情况呢

31:07.220 --> 31:10.600
我这边我直接把它拿过来

31:10.600 --> 31:13.600
大致就是这么三种情况

31:13.600 --> 31:14.600
首先第一个就是

31:14.600 --> 31:17.600
新旧止节点的key和type都相同

31:17.600 --> 31:19.600
那说明是不是可以复用

31:19.600 --> 31:20.600
对不对

31:20.600 --> 31:21.600
这个很好理解

31:21.600 --> 31:22.600
这个和刚才的单节点

31:22.600 --> 31:23.600
也是一样的

31:23.600 --> 31:24.600
对吧

31:24.600 --> 31:25.600
好

31:25.600 --> 31:26.600
然后接下来

31:26.600 --> 31:27.600
如果新旧节点key相同

31:27.600 --> 31:29.600
但是type不同

31:29.600 --> 31:31.600
注意type不同

31:31.600 --> 31:32.600
那么这个时候的话

31:32.600 --> 31:34.600
就会根据react element

31:34.600 --> 31:35.600
那就是我们的react元素

31:35.600 --> 31:37.600
或者叫做JSR对象

31:37.600 --> 31:40.600
生成一个全新的fiber

31:40.600 --> 31:41.600
好

31:41.600 --> 31:42.600
那旧的fiber的话

31:42.600 --> 31:43.600
就会被放到一个叫做

31:43.600 --> 31:44.600
这个delay system

31:44.600 --> 31:45.600
宿主里面

31:45.600 --> 31:46.600
回头的话

31:46.600 --> 31:48.600
统一进行删除

31:48.600 --> 31:49.600
但是你要注意

31:49.600 --> 31:50.600
此时的话

31:50.600 --> 31:52.600
便利并不会终止

31:53.600 --> 31:55.600
便利并不会终止

31:55.600 --> 31:57.600
它会在什么时候结束呢

31:57.600 --> 31:59.600
它会在新旧止节点

31:59.600 --> 32:02.600
key和type都不相同的时候

32:02.600 --> 32:03.600
key也不同

32:03.600 --> 32:04.600
type也不相同

32:04.600 --> 32:07.600
那接下来它这边会结束便利

32:07.600 --> 32:08.600
没有没有

32:08.600 --> 32:09.600
好

32:09.600 --> 32:10.600
来我们这边

32:10.600 --> 32:11.600
我们来做一个实力

32:11.600 --> 32:12.600
这边

32:12.600 --> 32:15.620
实力1

32:15.620 --> 32:16.620
实力1

32:16.620 --> 32:17.620
好

32:17.620 --> 32:18.620
比如说我们这边

32:18.620 --> 32:21.760
更新前

32:21.760 --> 32:23.760
更新前的这个结构的话

32:23.760 --> 32:26.710
是这个样子的

32:26.710 --> 32:27.710
OK

32:27.710 --> 32:28.710
好

32:28.710 --> 32:30.710
来我们这边来看一下

32:30.710 --> 32:31.710
这边的话

32:31.710 --> 32:33.710
首先的话是abcd

32:33.710 --> 32:36.710
对应的key也是abcd

32:36.710 --> 32:37.710
好

32:37.710 --> 32:38.710
更新后

32:38.710 --> 32:39.710
这边是abcd

32:39.710 --> 32:41.710
这边对应的也是什么呢

32:41.710 --> 32:42.710
也是abcd

32:42.710 --> 32:43.710
好

32:43.710 --> 32:45.710
那接下来我们这边要开始

32:45.710 --> 32:46.710
一张一张图

32:46.710 --> 32:47.710
放过来了

32:47.710 --> 32:48.710
好

32:48.710 --> 32:49.710
首先它便利到什么呢

32:49.710 --> 32:50.710
便利到这个A

32:50.710 --> 32:51.710
对吧

32:51.710 --> 32:52.710
便利到A

32:52.710 --> 32:53.710
这边

32:53.710 --> 32:54.710
这边

32:54.710 --> 32:55.710
这边

32:55.710 --> 32:56.710
这边

32:56.710 --> 32:57.710
便利到这个A

32:57.710 --> 32:58.710
对吧

32:58.710 --> 32:59.710
便利到A

32:59.710 --> 33:04.500
发现这个是不能够服用

33:04.500 --> 33:05.500
首先

33:05.500 --> 33:08.500
便利到这个

33:08.500 --> 33:11.500
div.key.a

33:11.500 --> 33:12.500
发现什么呢

33:12.500 --> 33:13.500
发现

33:13.500 --> 33:15.500
该

33:15.500 --> 33:17.500
这个fibernode

33:17.500 --> 33:19.500
能够

33:19.500 --> 33:21.500
服用

33:21.500 --> 33:22.500
对不对

33:22.500 --> 33:23.500
这边把图拉过来

33:23.500 --> 33:24.500
这边我就是

33:24.500 --> 33:27.500
一个一个画的图了

33:27.500 --> 33:28.500
稍等

33:34.520 --> 33:35.520
马上

33:35.520 --> 33:36.520
马上

33:36.520 --> 33:39.340
把这边重新复制一下

33:39.340 --> 33:40.340
好

33:40.340 --> 33:41.340
这里

33:41.340 --> 33:42.340
你看

33:42.340 --> 33:43.340
是不是就这样子的

33:43.340 --> 33:45.340
你注意对比是谁和谁对比

33:45.340 --> 33:46.340
这个刚才我就说了

33:46.340 --> 33:48.340
Current Fibernode

33:48.340 --> 33:51.340
就是你这边Current这个数的fibernode和什么

33:51.340 --> 33:52.340
和接式差对一下

33:52.340 --> 33:53.340
他们

33:53.340 --> 33:55.340
他和他进行对比

33:55.340 --> 33:57.340
对比之后发现能够服用

33:57.340 --> 33:58.340
那接下来这边就干嘛

33:58.340 --> 33:59.340
是不是直接服用

33:59.340 --> 34:00.340
对不对

34:00.340 --> 34:02.340
生成这个webfibernode

34:03.340 --> 34:04.340
进行连接

34:04.340 --> 34:05.340
好

34:05.340 --> 34:06.340
然后继续

34:06.340 --> 34:08.340
继续

34:08.340 --> 34:10.340
往后面走

34:11.340 --> 34:12.340
发现什么呢

34:12.340 --> 34:15.340
发现这个div.key.b

34:15.340 --> 34:17.340
是不是也能够服用

34:17.340 --> 34:21.230
也能够

34:21.230 --> 34:22.230
服用

34:22.230 --> 34:23.230
对不对

34:23.230 --> 34:25.230
这个的话是不是也就直接拿来服用

34:25.230 --> 34:27.230
对应了这个图

34:27.230 --> 34:29.230
在这边

34:29.230 --> 34:31.230
这个也能够服用

34:31.230 --> 34:33.230
因为你这边key是b

34:33.230 --> 34:35.230
type也是一样的

34:35.230 --> 34:36.230
大家这边服用

34:36.230 --> 34:38.230
通过这个alternate相连

34:38.230 --> 34:39.230
这边sablin

34:39.230 --> 34:40.230
对不对

34:40.230 --> 34:41.230
好然后接下来的话

34:41.230 --> 34:43.230
继续往后面走

34:44.230 --> 34:45.230
接下来

34:45.230 --> 34:48.230
继续往后面走

34:49.230 --> 34:50.230
来到了什么呢

34:50.230 --> 34:54.230
来到了这个div.key.e

34:54.230 --> 34:56.230
这个时候发现什么

34:56.230 --> 34:58.230
发现key不一样了

34:58.230 --> 34:59.230
对不对

34:59.230 --> 35:01.230
这个时候

35:01.230 --> 35:04.230
发现key不一样了

35:05.230 --> 35:06.230
发现key不一样了

35:06.230 --> 35:07.230
那接下来我们来看一下

35:07.230 --> 35:08.230
key不一样

35:08.230 --> 35:09.230
他这边可以干吗

35:09.230 --> 35:12.540
你这边是key相同

35:12.540 --> 35:13.540
type不相同

35:13.540 --> 35:15.540
他才会继续往后面便利

35:15.540 --> 35:16.540
你现在key已经不相同了

35:16.540 --> 35:17.540
不相同了

35:17.540 --> 35:19.540
是不是就结束第一轮便利

35:19.540 --> 35:20.540
对不对

35:20.540 --> 35:21.540
因此

35:22.540 --> 35:23.540
因此

35:23.540 --> 35:25.540
第一轮便利

35:25.540 --> 35:27.540
就结束了

35:27.540 --> 35:28.540
OK

35:28.540 --> 35:30.540
第一轮便利就结束了

35:30.540 --> 35:31.540
把这个图

35:31.540 --> 35:36.390
把他过来

35:36.390 --> 35:37.390
把他过来

35:37.390 --> 35:38.390
OK

35:38.390 --> 35:39.390
你看这边key不一样

35:39.390 --> 35:40.390
这个key是C

35:40.390 --> 35:41.390
这个key是E

35:41.390 --> 35:42.390
key不同

35:42.390 --> 35:43.390
所以结束了

35:43.390 --> 35:44.390
第一轮便利

35:44.390 --> 35:46.390
这是首先第一个例子

35:47.390 --> 35:48.390
没问题吧

35:48.390 --> 35:49.390
应该很清晰

35:49.390 --> 35:50.390
这边我们这个

35:50.390 --> 35:51.390
一个一步一步走的

35:51.390 --> 35:52.390
对不对

35:52.390 --> 35:53.390
应该是很清晰的

35:53.390 --> 35:54.390
好

35:54.390 --> 35:55.390
然后接下来

35:55.390 --> 35:56.390
这个是4.1

35:56.390 --> 35:57.390
我们接下来看个4.2

35:57.390 --> 36:01.300
4.2

36:01.300 --> 36:02.300
好

36:02.300 --> 36:03.300
4.2的话

36:03.300 --> 36:04.300
这边的话是

36:04.300 --> 36:05.300
这样子的这个结构

36:05.300 --> 36:07.300
这边更新前

36:08.300 --> 36:09.300
更新后

36:09.300 --> 36:11.300
我们首先先把这个

36:12.300 --> 36:14.300
对应了这个结构

36:14.300 --> 36:15.300
先把它写出来

36:15.300 --> 36:16.300
这边更新前

36:16.300 --> 36:17.300
对应了这个结构

36:19.300 --> 36:20.300
这个

36:20.300 --> 36:22.300
首先的话仍然是ABCD

36:22.300 --> 36:23.300
对吧

36:23.300 --> 36:24.300
好

36:24.300 --> 36:29.410
然后接下来这边更新后

36:29.410 --> 36:30.410
更新后的话

36:30.410 --> 36:31.410
你可以看到这边

36:31.410 --> 36:32.410
这边的话

36:32.410 --> 36:35.410
它是ABCD

36:35.410 --> 36:36.410
key是一样的

36:36.410 --> 36:37.410
但是什么

36:37.410 --> 36:38.410
Type不一样

36:38.410 --> 36:39.410
Type不一样的话

36:39.410 --> 36:40.410
我们刚才说了

36:40.410 --> 36:41.410
Type不一样它会干吗

36:41.410 --> 36:43.410
是不是继续

36:43.410 --> 36:45.410
变力不会终止

36:45.410 --> 36:46.410
继续往后面找

36:46.410 --> 36:47.410
对不对

36:47.410 --> 36:48.410
好

36:48.410 --> 36:49.410
来

36:49.410 --> 36:50.410
我们这边仍然是来看一下

36:50.410 --> 36:52.410
我们这边一步一步来看一下

36:52.410 --> 36:53.410
好

36:53.410 --> 36:54.410
首先前面

36:54.410 --> 36:55.410
前面的话就不说了

36:55.410 --> 36:56.410
A的话会附用

36:56.410 --> 36:57.410
B是不是也会附用

36:58.410 --> 36:59.410
对不对

36:59.410 --> 37:00.410
好

37:00.410 --> 37:01.410
那接下来

37:01.410 --> 37:02.410
首先

37:02.410 --> 37:03.410
首先和

37:03.410 --> 37:04.410
上面的

37:04.410 --> 37:05.410
一样

37:05.410 --> 37:08.410
div.key.a

37:08.410 --> 37:12.410
和div.key.b

37:12.410 --> 37:15.410
这两个fiber load

37:15.410 --> 37:19.040
这两个fiber load

37:19.040 --> 37:21.040
可以进行附用

37:21.040 --> 37:24.040
可以进行附用

37:24.040 --> 37:25.040
好

37:25.040 --> 37:27.040
然后接下来到了第三个节点

37:27.040 --> 37:29.040
接下来到了

37:29.040 --> 37:31.040
第三个节点

37:31.040 --> 37:33.040
第三个节点

37:33.040 --> 37:34.040
第三个节点的话

37:34.040 --> 37:35.040
它会发现什么

37:35.040 --> 37:38.040
它会发现这个key是相同的

37:38.040 --> 37:39.040
对不对

37:39.040 --> 37:45.040
此时会发现key是相同的

37:45.040 --> 37:46.040
但是呢

37:46.040 --> 37:49.860
太普普相同

37:49.860 --> 37:50.860
那它会怎么做呢

37:50.860 --> 37:53.860
它会把这个就的fiber load的节点

37:53.860 --> 37:58.860
放入到一个叫做delay形式的数组里面

37:58.860 --> 38:00.860
此时

38:00.860 --> 38:02.860
此时

38:02.860 --> 38:05.860
就会将

38:05.860 --> 38:10.860
对应的就的fiber load

38:10.860 --> 38:12.860
放入到

38:12.860 --> 38:14.860
放入到什么呢

38:14.860 --> 38:23.860
放入到一个叫delay形式的数组里面

38:23.860 --> 38:25.860
然后回头

38:25.860 --> 38:27.860
统一

38:27.860 --> 38:29.860
进行删除

38:29.860 --> 38:31.860
然后接下来的话

38:31.860 --> 38:32.860
根据什么呢

38:32.860 --> 38:34.860
根据

38:34.860 --> 38:38.860
这个react元素

38:38.860 --> 38:40.860
创建

38:40.860 --> 38:44.860
一个新的fiber load

38:44.860 --> 38:45.860
对吧

38:45.860 --> 38:46.860
但是

38:46.860 --> 38:48.860
此时的变力

38:48.860 --> 38:51.860
是不会结束的

38:51.860 --> 38:52.860
我们把这个图

38:52.860 --> 38:56.500
我们把它过来

38:56.500 --> 38:58.500
这边看一下

38:58.500 --> 39:00.500
你这边key是相同的

39:00.500 --> 39:01.500
对吧

39:01.500 --> 39:02.500
key是相同的

39:02.500 --> 39:03.500
key是相同的

39:03.500 --> 39:04.500
但是太普不一样

39:04.500 --> 39:05.500
这个是div

39:05.500 --> 39:06.500
那怎么办呢

39:06.500 --> 39:07.500
接下来我把这个的话

39:07.500 --> 39:10.500
我会把它放到一个叫做delay形式的数组里面

39:10.500 --> 39:12.500
回头的话统一删除

39:12.500 --> 39:13.500
然后接下来根据什么呢

39:13.500 --> 39:15.500
根据你这边这个

39:15.500 --> 39:18.500
这边这个react元素

39:18.500 --> 39:22.500
大家创建对应的这个新的fiber load

39:22.500 --> 39:24.500
好

39:24.500 --> 39:27.500
接下来继续往后面变力

39:27.500 --> 39:28.500
接下来

39:28.500 --> 39:31.500
继续往后面

39:31.500 --> 39:33.500
进行变力

39:33.500 --> 39:36.500
那变力什么时候结束呢

39:36.500 --> 39:40.500
变力什么时候结束呢

39:40.500 --> 39:42.500
两个

39:42.500 --> 39:43.500
两种情况

39:43.500 --> 39:44.500
首先第一个的话就是

39:44.500 --> 39:46.500
到末尾了

39:46.500 --> 39:48.500
到末尾了

39:48.500 --> 39:51.500
也就是说

39:51.500 --> 39:53.500
也就是说

39:53.500 --> 39:55.500
整个变力完了

39:55.500 --> 39:56.500
对不对

39:56.500 --> 39:57.500
你的变力完了

39:57.500 --> 39:58.500
那自然而然就结束了

39:58.500 --> 40:00.500
或者是什么呢

40:00.500 --> 40:04.500
或者是和这个4利1

40:04.500 --> 40:07.500
4利1相同

40:07.500 --> 40:08.500
什么呢

40:08.500 --> 40:11.500
就是发现这个key不同

40:11.500 --> 40:13.500
你发现key不同的话

40:13.500 --> 40:14.500
是不是也就结束了

40:14.500 --> 40:15.500
对不对

40:15.500 --> 40:16.500
也就结束了

40:16.500 --> 40:17.500
说这边的话

40:17.500 --> 40:19.500
我们这边继续往后面变力

40:19.500 --> 40:20.500
继续往后面变力的话

40:20.500 --> 40:21.500
它这边的话就是这个样子的

40:21.500 --> 40:25.450
这边就是这个样子的

40:25.450 --> 40:26.450
一张一张图

40:26.450 --> 40:28.450
这边一张一张图给你画出来

40:28.450 --> 40:29.450
你看这边

40:29.450 --> 40:30.450
继续往后面变力

40:30.450 --> 40:31.450
变力到这边

40:31.450 --> 40:32.450
是不是这个D

40:32.450 --> 40:33.450
对不对

40:33.450 --> 40:34.450
D的话发现

40:34.450 --> 40:35.450
key和type都是一样的

40:35.450 --> 40:36.450
是不是这个又可以服用了

40:36.450 --> 40:37.450
对吧

40:37.450 --> 40:38.450
通过alternate

40:38.450 --> 40:39.450
把它连起来

40:39.450 --> 40:40.450
这个的话就是

40:40.450 --> 40:42.450
第一轮变力

40:42.450 --> 40:43.450
ok

40:43.450 --> 40:44.450
第一轮变力

40:44.450 --> 40:45.450
逐个

40:45.450 --> 40:46.450
一个一个

40:46.450 --> 40:47.450
从前往后

40:47.450 --> 40:49.450
这个和这个比较

40:49.450 --> 40:51.450
这个和这个进行比较

40:51.450 --> 40:53.450
一个一个比较

40:53.450 --> 40:54.450
ok

40:54.450 --> 40:55.450
这是第一轮

40:55.450 --> 40:56.450
好

40:56.450 --> 40:57.450
然后接下来的话

40:57.450 --> 40:59.450
我们这边来看第二轮

40:59.450 --> 41:00.450
第二轮变力

41:00.450 --> 41:01.450
它要做些什么

41:01.450 --> 41:02.450
好

41:02.450 --> 41:03.450
如果你第一轮变力的话

41:03.450 --> 41:05.450
它被提前终止了

41:05.450 --> 41:06.450
注意

41:06.450 --> 41:08.450
如果

41:08.450 --> 41:10.450
第一轮变力

41:10.450 --> 41:13.450
被提前

41:13.450 --> 41:14.450
终止了

41:14.450 --> 41:16.450
那么意味着什么

41:16.450 --> 41:18.450
什么意味着有新的

41:18.450 --> 41:20.450
这个react元素

41:20.450 --> 41:21.450
或者这个旧的

41:21.450 --> 41:22.450
这个fabernold

41:22.450 --> 41:24.450
没有被变力完

41:24.450 --> 41:25.450
对不对

41:25.450 --> 41:28.450
那么意味着

41:28.450 --> 41:31.820
有新的

41:31.820 --> 41:33.820
有新的

41:33.820 --> 41:36.820
这个react元素

41:36.820 --> 41:39.820
以及这个旧的

41:39.820 --> 41:42.820
旧的这个fabernold

41:42.820 --> 41:45.820
没有变力完

41:45.820 --> 41:46.820
对不对

41:46.820 --> 41:47.820
比如说我这边

41:47.820 --> 41:48.820
举个例子

41:48.820 --> 41:49.820
比如说我这边变力

41:49.820 --> 41:50.820
第一个能够服用

41:50.820 --> 41:51.820
变力第二个

41:51.820 --> 41:52.820
第二个

41:52.820 --> 41:53.820
假设它就已经不一样了

41:53.820 --> 41:54.820
就不能服用了

41:54.820 --> 41:55.820
那我这边的话

41:55.820 --> 41:56.820
这个fabernold

41:56.820 --> 41:57.820
后面还剩这么多

41:57.820 --> 41:58.820
我这边

41:58.820 --> 41:59.820
叉对象

41:59.820 --> 42:00.820
也就是我们的react元素

42:00.820 --> 42:02.820
后面也剩这么多

42:02.820 --> 42:03.820
对不对

42:03.820 --> 42:04.820
没有变力完

42:06.820 --> 42:07.820
此时

42:07.820 --> 42:08.820
就会什么

42:08.820 --> 42:10.820
就会采用

42:10.820 --> 42:13.820
第二轮变力

42:13.820 --> 42:14.820
那么第二轮变力的话

42:14.820 --> 42:16.820
它会处理这么三种情况

42:16.820 --> 42:20.260
第二轮变力

42:20.260 --> 42:22.260
会处理

42:22.260 --> 42:26.260
这么三种情况

42:26.260 --> 42:27.260
哪三种情况

42:27.260 --> 42:29.260
我这边直接把它拿过来

42:30.260 --> 42:32.260
会有这么三种情况

42:32.260 --> 42:36.340
这边大家看一下

42:36.340 --> 42:38.340
首先第一个

42:38.340 --> 42:41.340
只剩下旧的直接点

42:41.340 --> 42:42.340
就你这边的话

42:42.340 --> 42:44.340
就是旧的直接点

42:44.340 --> 42:45.340
就这边

42:45.340 --> 42:46.340
这边还剩下

42:46.340 --> 42:47.340
旧的直接点

42:47.340 --> 42:48.340
还剩下

42:48.340 --> 42:49.340
那意味着什么

42:49.340 --> 42:50.340
意味着你这边的话

42:50.340 --> 42:51.340
你这个接叉对象

42:51.340 --> 42:52.340
是不是变力完了的

42:52.340 --> 42:53.340
对不对

42:53.340 --> 42:55.340
这边不应该是以及

42:55.340 --> 42:56.340
这边应该是或者

42:56.340 --> 42:57.340
或者

42:57.340 --> 42:58.340
好

42:58.340 --> 43:00.340
那你这个接叉对象

43:00.340 --> 43:01.340
变力完了的

43:01.340 --> 43:02.340
意味着这后面的

43:02.340 --> 43:04.340
是不是都是不要的

43:04.340 --> 43:05.340
对不对

43:05.340 --> 43:06.340
后面都是不要的

43:06.340 --> 43:08.340
这边它就会将旧的直接点

43:08.340 --> 43:11.340
添加到delation数组里面

43:11.340 --> 43:14.340
到时候方便统一进行删除

43:14.340 --> 43:16.340
这个实际上就是删除的情况

43:16.340 --> 43:17.340
好

43:17.340 --> 43:18.340
第二个

43:18.340 --> 43:20.340
只剩下新的接叉元素

43:20.340 --> 43:22.340
比如我这个current fiber load

43:22.340 --> 43:23.340
只有两个

43:23.340 --> 43:25.340
那加这个的话有四个

43:25.340 --> 43:26.340
那我上面的话

43:26.340 --> 43:27.340
已经变力完了

43:27.340 --> 43:28.340
变力完了

43:28.340 --> 43:29.340
但是你这边的话

43:29.340 --> 43:30.340
是不是还有剩下的

43:30.340 --> 43:33.340
就根据你新的react元素

43:33.340 --> 43:34.340
创建什么

43:34.340 --> 43:36.340
创建新的fiber load

43:36.340 --> 43:39.340
这个就是新增的情况

43:39.340 --> 43:40.340
好

43:40.340 --> 43:41.340
然后第三种

43:41.340 --> 43:44.340
第三种是新就直接点

43:44.340 --> 43:47.340
都有剩余

43:47.340 --> 43:49.340
就你这边

43:49.340 --> 43:50.340
这边也有剩余

43:50.340 --> 43:52.340
这边也有剩余

43:52.340 --> 43:53.340
那这种会干嘛呢

43:53.340 --> 43:54.340
这种的话

43:54.340 --> 43:56.340
会将剩余的fiber load

43:56.340 --> 43:59.340
放到一个map里面

44:00.340 --> 44:01.340
然后接下来

44:01.340 --> 44:04.340
变力剩余的新的接叉元素

44:04.340 --> 44:06.340
然后从map里面去找

44:06.340 --> 44:09.340
有没有能够附用的

44:09.340 --> 44:11.340
如果有的话就拿来附用

44:11.340 --> 44:14.340
这个实际上就是移动的情况

44:14.340 --> 44:15.340
如果不能找到

44:15.340 --> 44:18.340
不能找到的话就新增

44:18.340 --> 44:20.340
不能找到就新增

44:20.340 --> 44:22.340
然后如果剩余的接叉元素

44:22.340 --> 44:23.340
都变力完了

44:23.340 --> 44:24.340
这个map里面

44:24.340 --> 44:27.340
还有剩余的fiber节点

44:27.340 --> 44:30.340
那么就把这些fiber节点就干嘛呢

44:30.340 --> 44:31.340
你这个剩下的就干嘛

44:31.340 --> 44:33.340
剩下的就把它删除掉就可以了

44:33.340 --> 44:34.340
对不对

44:34.340 --> 44:35.340
ok

44:35.340 --> 44:38.340
一共就是这么三种情况

44:38.340 --> 44:40.340
好来我们一个一个来看一下

44:40.340 --> 44:41.340
首先第一个

44:41.340 --> 44:44.340
第一个的话是只剩下

44:44.340 --> 44:46.340
就

44:46.340 --> 44:49.340
就只节点

44:49.340 --> 44:50.340
就对了

44:50.340 --> 44:52.340
只节点

44:52.340 --> 44:55.340
把这三个都拿过来吗

44:55.340 --> 44:57.340
这个是只剩下

44:57.340 --> 44:59.340
只剩下这个

44:59.340 --> 45:02.340
好然后新旧都有剩余

45:02.340 --> 45:04.340
新旧都有剩余

45:04.340 --> 45:05.340
ok

45:05.340 --> 45:07.340
好来我们这边一个有来看

45:07.340 --> 45:09.340
这边的话更新前

45:09.340 --> 45:11.340
更新前

45:11.340 --> 45:13.340
更新后

45:13.340 --> 45:19.060
更新前的话你对应的这个结构

45:19.060 --> 45:22.060
是这个样子的

45:22.060 --> 45:24.060
abcd

45:24.060 --> 45:25.060
更新后

45:25.060 --> 45:28.060
更新后的话你的这个节点是这个样子的

45:28.060 --> 45:31.850
ab

45:31.850 --> 45:33.850
那你现在的话便利前面两个

45:33.850 --> 45:35.850
divk.a

45:35.850 --> 45:37.850
divk是b

45:37.850 --> 45:38.850
这两个是不是能够付用

45:38.850 --> 45:39.850
对不对

45:39.850 --> 45:40.850
能够付用完了之后

45:40.850 --> 45:42.850
然后加对于你这个新的

45:42.850 --> 45:44.850
更新后的这个ges差对象来讲

45:44.850 --> 45:46.850
是不是就已经这个便利就结束了

45:46.850 --> 45:48.850
那么它就会干嘛呢

45:48.850 --> 45:50.850
它就会将这个旧的这个节点

45:50.850 --> 45:52.850
放入到这个delay形式数组里面

45:52.850 --> 45:54.850
直接删除掉

45:55.850 --> 45:58.850
这边便利

45:58.850 --> 46:00.850
前面

46:00.850 --> 46:02.850
两个节点

46:02.850 --> 46:04.850
发现能够付用

46:04.850 --> 46:06.850
对不对

46:06.850 --> 46:08.850
此时就会

46:08.850 --> 46:10.850
付用

46:10.850 --> 46:12.850
前面的节点

46:12.850 --> 46:16.350
前面的节点

46:16.350 --> 46:18.350
好然后对于这个

46:18.350 --> 46:20.350
react

46:20.350 --> 46:22.350
元素来讲

46:22.350 --> 46:24.350
然后便利完

46:24.350 --> 46:27.730
便利完

46:27.730 --> 46:29.730
前面两个

46:29.730 --> 46:31.730
前面两个

46:31.730 --> 46:33.730
就已经什么

46:33.730 --> 46:35.730
已经便利结束了

46:35.730 --> 46:37.730
对不对

46:37.730 --> 46:39.730
因此剩下的

46:39.730 --> 46:41.730
剩下的

46:41.730 --> 46:43.730
剩下的这个fiber load

46:43.730 --> 46:45.730
fiber load

46:45.730 --> 46:47.730
就会

46:47.730 --> 46:49.730
就会被

46:49.730 --> 46:51.730
放入到什么呢

46:51.730 --> 46:53.730
放入到这个delay形式

46:55.730 --> 46:57.730
delay形式

46:57.730 --> 46:59.730
delay形式数组里面

46:59.730 --> 47:01.730
之后

47:01.730 --> 47:03.730
统一

47:03.730 --> 47:05.730
进行删除

47:05.730 --> 47:06.730
OK

47:06.730 --> 47:08.730
大致这边对应的图就是这个样子的

47:08.730 --> 47:13.060
对应的图就这样子的

47:13.060 --> 47:14.060
你看这边

47:14.060 --> 47:15.060
这边是个a对吧

47:15.060 --> 47:17.060
大家在这边发现能够付用

47:17.060 --> 47:18.060
这边付用

47:18.060 --> 47:19.060
b

47:19.060 --> 47:20.060
这边对应的这个b

47:20.060 --> 47:22.060
发现能够付用

47:22.060 --> 47:24.060
大家这边是不是就便利完了

47:24.060 --> 47:25.060
这里没了嘛

47:25.060 --> 47:27.060
没了之后那些剩下的节点

47:27.060 --> 47:29.060
就放到delay形式数组里面

47:29.060 --> 47:31.060
回头统一进行删除

47:31.060 --> 47:32.060
OK

47:32.060 --> 47:33.060
这是这种情况

47:33.060 --> 47:34.060
好

47:34.060 --> 47:35.060
然后接下来看这里

47:35.060 --> 47:37.060
这里的话是只剩下

47:37.060 --> 47:39.060
新的接叉元素

47:39.060 --> 47:41.060
也就是说这个

47:41.060 --> 47:43.060
react元素

47:43.060 --> 47:44.060
OK

47:44.060 --> 47:45.060
那这种的话

47:45.060 --> 47:46.060
这种就是什么

47:46.060 --> 47:47.060
进行新增

47:47.060 --> 47:48.060
对吧

47:48.060 --> 47:49.060
我们这边还是来看一下

47:49.060 --> 47:50.060
更新前

47:50.060 --> 47:53.890
更新后

47:53.890 --> 47:54.890
更新前是什么样子呢

47:54.890 --> 47:56.890
更新前的话是这个样子的

47:56.890 --> 48:01.100
更新前是这个样子的

48:01.100 --> 48:02.100
更新后

48:02.100 --> 48:05.600
更新后的话是这样子的

48:05.600 --> 48:11.790
那这个的话也非常好理解

48:11.790 --> 48:13.790
这个的话可以付用

48:13.790 --> 48:14.790
这个可以付用

48:14.790 --> 48:15.790
前面两个付用

48:15.790 --> 48:16.790
但是你这边的话

48:16.790 --> 48:18.790
你新的接叉对象

48:18.790 --> 48:20.790
还没有便利完

48:20.790 --> 48:21.790
还没有便利完的话

48:21.790 --> 48:22.790
这边就干嘛

48:22.790 --> 48:30.000
根据新的接叉元素

48:30.000 --> 48:32.000
或者叫做react元素

48:32.000 --> 48:33.000
react元素

48:33.000 --> 48:36.380
是不是新增

48:36.380 --> 48:38.380
新增对应的

48:38.380 --> 48:40.380
这个fiber node

48:40.380 --> 48:42.380
即可

48:42.380 --> 48:43.380
对不对

48:43.380 --> 48:44.380
这边把这个图

48:44.380 --> 48:47.380
把它过来

48:47.380 --> 48:49.380
对应的就是这个样子的

48:49.380 --> 48:50.380
首先我便利这个

48:50.380 --> 48:51.380
第一个

48:51.380 --> 48:52.380
这边

48:52.380 --> 48:53.380
发现能够付用

48:53.380 --> 48:54.380
然后再加这边

48:54.380 --> 48:55.380
第二个

48:55.380 --> 48:56.380
两个进行这个地幅比较

48:56.380 --> 48:57.380
发现能够付用

48:57.380 --> 48:58.380
好那接下来

48:58.380 --> 48:59.380
我这边是不是就完了

48:59.380 --> 49:00.380
对完了

49:00.380 --> 49:01.380
然后这样我这边

49:01.380 --> 49:02.380
后面还剩两个

49:02.380 --> 49:03.380
还剩两个就干嘛

49:03.380 --> 49:04.380
有新增的

49:04.380 --> 49:05.380
对不对

49:05.380 --> 49:06.380
有创建新的

49:06.380 --> 49:07.380
好

49:07.380 --> 49:09.380
关键是第三个

49:09.380 --> 49:12.380
就是你新就止节点

49:12.380 --> 49:14.380
都有声誉

49:14.380 --> 49:15.380
都有声誉

49:15.380 --> 49:16.380
好

49:16.380 --> 49:18.380
这边的话我们这边

49:18.380 --> 49:20.380
更新前

49:20.380 --> 49:21.380
更新后

49:21.380 --> 49:24.840
好

49:24.840 --> 49:25.840
更新前是什么样子

49:25.840 --> 49:31.140
更新前是这个样子的

49:31.140 --> 49:32.140
好

49:32.140 --> 49:33.140
然后接下来

49:33.140 --> 49:34.140
更新后

49:34.140 --> 49:35.140
更新后的话

49:35.140 --> 49:36.140
这边的话是

49:36.140 --> 49:39.860
这个样子的

49:39.860 --> 49:40.860
来看一下

49:40.860 --> 49:41.860
这边这个

49:41.860 --> 49:42.860
Q是A

49:42.860 --> 49:43.860
Q是A

49:43.860 --> 49:44.860
能够付用

49:44.860 --> 49:45.860
Q是B

49:45.860 --> 49:46.860
Q是C

49:46.860 --> 49:47.860
这边Q是C

49:47.860 --> 49:49.860
你看Q已经就不一样了

49:49.860 --> 49:50.860
对不对

49:50.860 --> 49:51.860
你这边的话

49:51.860 --> 49:52.860
这个Q不一样

49:52.860 --> 49:53.860
不一样的话

49:53.860 --> 49:54.860
第一轮便利

49:54.860 --> 49:55.860
是不是就已经就结束了

49:55.860 --> 49:56.860
对不对

49:56.860 --> 49:57.860
已经结束了

49:57.860 --> 49:58.860
然后接下来

49:58.860 --> 49:59.860
这边开始进行第二轮便利

49:59.860 --> 50:00.860
好

50:00.860 --> 50:01.860
第二轮便利

50:01.860 --> 50:06.730
这边他会干嘛

50:06.730 --> 50:07.730
首先

50:07.730 --> 50:08.730
首先

50:08.730 --> 50:10.730
会将剩余的这个

50:10.730 --> 50:13.230
旧的

50:13.230 --> 50:16.800
旧的这个fiber load

50:16.800 --> 50:18.800
放入到

50:18.800 --> 50:20.800
一个Map里面

50:20.800 --> 50:21.800
OK

50:21.800 --> 50:23.800
看这边这个图

50:23.800 --> 50:24.800
稍等

50:24.800 --> 50:28.900
他又卡住了

50:28.900 --> 50:30.900
可能图片太多了

50:31.900 --> 50:33.900
这边要重新复制一下

50:33.900 --> 50:34.900
稍等

50:34.900 --> 50:35.900
看这个图

50:39.620 --> 50:40.620
你看

50:40.620 --> 50:41.620
首先的话

50:41.620 --> 50:42.620
这边QA

50:42.620 --> 50:43.620
这个是不可以付用

50:43.620 --> 50:44.620
对不对

50:44.620 --> 50:45.620
这个直接拿来付用

50:45.620 --> 50:46.620
好

50:46.620 --> 50:47.620
那接下来到这里

50:47.620 --> 50:48.620
这里的话

50:48.620 --> 50:49.620
Q就不一样了

50:49.620 --> 50:50.620
对不对

50:50.620 --> 50:51.620
Q不一样了

50:51.620 --> 50:52.620
接下来怎么办呢

50:52.620 --> 50:53.620
接下来在第二轮便利里面

50:53.620 --> 50:55.620
他首先把这边剩下的

50:55.620 --> 50:57.620
这些旧的这个fiber节点

50:57.620 --> 51:00.620
全部放到一个Map里面

51:00.620 --> 51:01.620
好

51:01.620 --> 51:03.940
然后接下来的话

51:03.940 --> 51:04.940
接下来

51:04.940 --> 51:06.940
他会继续去便利

51:06.940 --> 51:09.940
剩余的这个JSX数组

51:09.940 --> 51:11.940
接下来会

51:11.940 --> 51:13.940
继续去便利

51:13.940 --> 51:17.940
剩下的这个JSX

51:17.940 --> 51:18.940
对象数组

51:18.940 --> 51:20.940
就是便利这边

51:20.940 --> 51:21.940
便利这边

51:21.940 --> 51:23.940
好便利的同时

51:23.940 --> 51:25.940
便利的同时

51:25.940 --> 51:26.940
从什么呢

51:26.940 --> 51:31.940
从Map里面去找

51:31.940 --> 51:35.940
有没有能够付用的

51:35.940 --> 51:36.940
OK

51:36.940 --> 51:37.940
如果有能够付用的

51:37.940 --> 51:39.940
那接下来就拿来付用

51:39.940 --> 51:40.940
对应的就是这样子的

51:40.940 --> 51:45.020
对应的大致就是这样子的

51:45.020 --> 51:46.020
好

51:46.020 --> 51:47.020
比如说我这边到这了

51:47.020 --> 51:48.020
divkissc

51:48.020 --> 51:49.020
好

51:49.020 --> 51:50.020
那这样我在这个Map

51:50.020 --> 51:51.020
你这边是有个Map吗

51:51.020 --> 51:52.020
对不对

51:52.020 --> 51:53.020
我在这边找

51:53.020 --> 51:54.020
对不对

51:54.020 --> 51:55.020
这边找到了

51:55.020 --> 51:56.020
这个进行付用

51:56.020 --> 51:57.020
好

51:57.020 --> 51:59.020
然后接下来这边divkissb

51:59.020 --> 52:00.020
是不是找到了

52:00.020 --> 52:01.020
对不对

52:01.020 --> 52:02.020
付用

52:02.020 --> 52:03.020
OK

52:03.020 --> 52:05.020
好那如果

52:05.020 --> 52:07.020
如果在这个Map里面

52:07.020 --> 52:11.020
如果在Map里面

52:11.020 --> 52:13.020
没有找到

52:13.020 --> 52:14.020
比如我这个

52:14.020 --> 52:16.020
divkiss这个e

52:16.020 --> 52:17.020
这个的话

52:17.020 --> 52:18.020
你在这个Map里面

52:18.020 --> 52:19.020
你是不是找不到的

52:19.020 --> 52:20.020
对不对

52:20.020 --> 52:21.020
那怎么办呢

52:21.020 --> 52:22.020
那就只有新增

52:22.020 --> 52:25.020
那就会新增

52:25.020 --> 52:28.020
这个fibernode

52:28.020 --> 52:29.020
OK

52:29.020 --> 52:30.020
好

52:30.020 --> 52:32.020
如果整个

52:32.020 --> 52:36.020
整个这个JSX

52:36.020 --> 52:38.020
对象输阻

52:38.020 --> 52:40.020
整个这个JSX对象输阻

52:40.020 --> 52:41.020
就是我们的

52:41.020 --> 52:42.020
Rat元素

52:42.020 --> 52:43.020
一个意思

52:43.020 --> 52:44.020
OK

52:44.020 --> 52:46.020
便利完成后

52:46.020 --> 52:48.020
便利完成后

52:48.020 --> 52:50.020
Map里面

52:50.020 --> 52:53.020
还有剩余的

52:53.020 --> 52:55.020
这个fibernode

52:55.020 --> 52:56.020
那你还有剩余的

52:56.020 --> 52:57.020
这个fibernode说明什么

52:57.020 --> 52:59.020
说明这些fibernode

52:59.020 --> 53:00.020
不能够付用的

53:00.020 --> 53:01.020
对不对

53:01.020 --> 53:07.390
说明这些fibernode

53:07.390 --> 53:08.390
说明这些fibernode

53:08.390 --> 53:12.390
是无法进行付用的

53:12.390 --> 53:13.390
那就怎么办

53:13.390 --> 53:16.390
是不是直接放入到

53:16.390 --> 53:18.390
这个delay

53:18.390 --> 53:19.390
delay是

53:19.390 --> 53:21.390
数组里面

53:21.390 --> 53:22.390
后期

53:22.390 --> 53:24.390
统一

53:24.390 --> 53:26.390
进行

53:26.390 --> 53:27.390
进行

53:27.390 --> 53:28.390
删除

53:28.390 --> 53:29.390
对不对

53:29.390 --> 53:32.390
对应的就是这边

53:32.390 --> 53:34.390
对应的就是这张图

53:34.390 --> 53:36.900
你看

53:36.900 --> 53:37.900
好

53:37.900 --> 53:38.900
这边的话

53:38.900 --> 53:39.900
divkey是C

53:39.900 --> 53:41.900
这边是不是找到了

53:41.900 --> 53:43.900
divkeyB

53:43.900 --> 53:44.900
这边是不是找到了

53:44.900 --> 53:45.900
好

53:45.900 --> 53:47.900
这边divkey是E

53:47.900 --> 53:49.900
这里面找得到吗

53:49.900 --> 53:50.900
找不到

53:50.900 --> 53:51.900
找不到我就干嘛

53:51.900 --> 53:52.900
我就新增

53:52.900 --> 53:53.900
好

53:53.900 --> 53:54.900
那接下来我整个这个

53:54.900 --> 53:55.900
接下来对向这个数组便利完了

53:55.900 --> 53:56.900
便利完了这个map里面

53:56.900 --> 53:58.900
是不是他没有备用的

53:58.900 --> 53:59.900
他没备用到

53:59.900 --> 54:00.900
回头就放到什么了

54:00.900 --> 54:02.900
就放到这个delay是数组里面

54:02.900 --> 54:03.900
后期的话

54:03.900 --> 54:05.900
统一进行删除

54:05.900 --> 54:06.900
没有

54:06.900 --> 54:07.900
好

54:07.900 --> 54:09.900
整个这个第二轮的这个流程

54:09.900 --> 54:10.900
他就是这样子的

54:10.900 --> 54:12.900
我这边用了很多的这个图

54:12.900 --> 54:14.900
用了很多的这个图

54:14.900 --> 54:15.900
OK

54:15.900 --> 54:17.900
这个是第二轮

54:17.900 --> 54:19.900
怎么样清晰了没有

54:19.900 --> 54:20.900
应该很清晰了

54:20.900 --> 54:22.900
这边这个一张一张图给你画出来

54:22.900 --> 54:24.900
他究竟是什么样子的

54:24.900 --> 54:25.900
好

54:25.900 --> 54:26.900
然后接下来

54:26.900 --> 54:27.900
最后最后我们说一下

54:27.900 --> 54:28.900
就是关于这个

54:28.900 --> 54:33.870
双端对比

54:33.870 --> 54:34.870
这边

54:34.870 --> 54:37.870
双端对比

54:37.870 --> 54:39.870
对比算法

54:39.870 --> 54:41.870
什么叫做双端

54:41.870 --> 54:42.870
这个

54:42.870 --> 54:44.870
双端对比算法呢

54:44.870 --> 54:45.870
所谓这个双端

54:45.870 --> 54:46.870
他指的是

54:46.870 --> 54:48.870
就是在新旧指节点的这个

54:48.870 --> 54:49.870
数组里面

54:49.870 --> 54:51.870
用两个指针

54:51.870 --> 54:54.870
分别指向这个头尾这个节点

54:54.870 --> 54:56.870
然后接下来这个在便利过程中

54:56.870 --> 54:58.870
你头尾指针的话

54:58.870 --> 55:00.870
不断的进行一个靠拢

55:00.870 --> 55:01.870
OK

55:01.870 --> 55:03.870
所谓双端

55:03.870 --> 55:05.870
指的是

55:05.870 --> 55:08.870
在这个新旧

55:08.870 --> 55:12.870
指节点的这个数组中

55:12.870 --> 55:14.870
各用什么呢

55:14.870 --> 55:21.360
各用两个指针

55:21.360 --> 55:23.360
两个指针

55:23.360 --> 55:24.360
指向什么呢

55:24.360 --> 55:28.060
指向头尾

55:28.060 --> 55:31.060
头尾的这个节点

55:31.060 --> 55:32.060
OK

55:32.060 --> 55:35.060
好在这个便利的过程中

55:35.060 --> 55:36.060
便利的过程中

55:36.060 --> 55:38.060
然后头尾

55:38.060 --> 55:41.500
头尾两个指针

55:41.500 --> 55:42.500
两个指针

55:42.500 --> 55:45.500
同时

55:45.500 --> 55:46.500
像什么呢

55:46.500 --> 55:50.900
像这个中间靠拢

55:50.900 --> 55:53.900
同时像这个中间靠拢

55:53.900 --> 55:56.900
这个就是所谓的这个双端对比

55:56.900 --> 55:58.900
好因此你这边的话

55:58.900 --> 56:00.900
你比如说新的这个指节点数组

56:00.900 --> 56:01.900
它有两个指针

56:01.900 --> 56:03.900
然后旧的这个指节点数组

56:03.900 --> 56:05.900
这边也有两个指针

56:05.900 --> 56:06.900
对不对

56:06.900 --> 56:08.900
所以它这边一共是四个指针

56:08.900 --> 56:09.900
因此

56:09.900 --> 56:11.900
这个在

56:11.900 --> 56:12.900
这个新

56:12.900 --> 56:14.900
指节点

56:14.900 --> 56:15.900
数组中

56:15.900 --> 56:16.900
会有什么呢

56:16.900 --> 56:17.900
会有

56:17.900 --> 56:19.900
两个

56:19.900 --> 56:21.900
两个指针

56:21.900 --> 56:23.900
假设比如说这个New

56:23.900 --> 56:24.900
Start

56:24.900 --> 56:26.900
Index

56:26.900 --> 56:27.900
和这个

56:27.900 --> 56:29.900
这个NewEnd

56:29.900 --> 56:31.900
这个Index

56:31.900 --> 56:32.900
分别

56:32.900 --> 56:36.340
分别指向

56:36.340 --> 56:37.340
这个新

56:37.340 --> 56:39.340
指节点

56:39.340 --> 56:42.340
的这个头和尾

56:42.340 --> 56:45.340
头和尾

56:45.340 --> 56:47.340
然后接下来在这个旧

56:47.340 --> 56:49.340
在这个旧

56:49.340 --> 56:50.340
指节点

56:50.340 --> 56:51.340
指节点

56:51.340 --> 56:52.340
数组中

56:52.340 --> 56:54.340
也会

56:54.340 --> 56:57.340
也会有两个指针

56:57.340 --> 56:58.340
对吧

56:58.340 --> 56:59.340
这个是old

56:59.340 --> 57:01.340
oldStart

57:01.340 --> 57:02.340
Index

57:02.340 --> 57:03.340
和这个

57:03.340 --> 57:04.340
old

57:04.340 --> 57:06.340
然后End

57:06.340 --> 57:07.340
这个Index

57:07.340 --> 57:09.340
然后分别

57:09.340 --> 57:10.340
指向什么

57:10.340 --> 57:12.340
指向这个旧

57:12.340 --> 57:15.340
旧这个指节点

57:15.340 --> 57:16.340
数组

57:16.340 --> 57:19.840
的这个头和尾

57:19.840 --> 57:20.840
这边是这样子的

57:20.840 --> 57:22.840
这边应该是指节点的

57:22.840 --> 57:23.840
数组

57:23.840 --> 57:24.840
指节点

57:24.840 --> 57:26.840
数组的头和尾

57:26.840 --> 57:28.840
你这边如果要画个图的话

57:28.840 --> 57:33.050
画出来大致就是这个样子的

57:33.050 --> 57:34.050
大致就是这样子的

57:34.050 --> 57:36.050
你这边会有一个这个old

57:36.050 --> 57:38.050
old的这个就是

57:38.050 --> 57:40.050
旧的这个指节点数组

57:40.050 --> 57:42.050
大家这边通过一个指针

57:42.050 --> 57:43.050
oldStartIndex

57:43.050 --> 57:44.050
指向他的头部

57:44.050 --> 57:46.050
这边的话指向他的尾部

57:46.050 --> 57:48.050
这边指向他的头部

57:48.050 --> 57:49.050
这边指向他的尾部

57:49.050 --> 57:50.050
对不对

57:50.050 --> 57:52.050
会有这么四个指针

57:52.050 --> 57:55.490
然后你这边的话

57:55.490 --> 57:57.490
你使用这个双端对比算法的时候

57:57.490 --> 57:59.490
你每次便利到一个节点

57:59.490 --> 58:01.490
他这边的话就会进行这么四次比较

58:01.490 --> 58:02.490
哪四次呢

58:02.490 --> 58:05.490
比如你这个旧前和这个新前

58:05.490 --> 58:07.490
这两个进行比较

58:07.490 --> 58:08.490
对不对

58:08.490 --> 58:09.490
旧后和新后

58:09.490 --> 58:11.490
这两个进行比较

58:11.490 --> 58:12.490
好

58:12.490 --> 58:13.490
旧前和新后

58:13.490 --> 58:14.490
这两个进行比较

58:14.490 --> 58:16.490
那新前和旧后

58:16.490 --> 58:17.490
进行比较

58:17.490 --> 58:19.490
所以每便利到一个节点

58:19.490 --> 58:21.490
他就会尝试这么四次比较

58:21.490 --> 58:24.490
这个的话我们把它称之为一次这个双端比较

58:24.490 --> 58:25.490
OK

58:25.490 --> 58:31.300
这边直接把这个描述拿过来

58:31.300 --> 58:33.300
直接把这个描述拿过来

58:33.300 --> 58:35.300
每便利到一个节点

58:35.300 --> 58:37.300
他就会尝试进行一次这个双端比较

58:37.300 --> 58:39.300
那双端的话这边一共是四次

58:39.300 --> 58:41.300
分别是新前和旧前

58:41.300 --> 58:42.300
对吧

58:42.300 --> 58:44.300
那新后和旧后

58:44.300 --> 58:47.300
然后这个新后和旧前

58:47.300 --> 58:49.300
人家这个新前和旧后

58:49.300 --> 58:51.300
如果匹配成功

58:51.300 --> 58:54.300
就更新双端的这个指针

58:55.300 --> 58:56.300
好

58:56.300 --> 58:58.300
然后你如果你这边新旧节点

58:58.300 --> 59:00.300
在进行比较的时候

59:00.300 --> 59:03.300
如果你比如说这个新后和旧前

59:03.300 --> 59:05.300
比较匹配成功

59:05.300 --> 59:07.300
这边你看这个新后

59:07.300 --> 59:08.300
新后和什么呢

59:08.300 --> 59:09.300
和这个旧前

59:09.300 --> 59:11.300
就他们两个匹配成功

59:11.300 --> 59:12.300
那你就需要干嘛呢

59:12.300 --> 59:15.300
你就需要把这个旧前

59:15.300 --> 59:16.300
对应的这个锻目

59:16.300 --> 59:17.300
把它放到哪里呢

59:17.300 --> 59:20.300
放到这个旧后的这个后面

59:20.300 --> 59:22.300
好放到这个旧后的这个之前

59:23.300 --> 59:25.300
如果你这个新前

59:25.300 --> 59:28.300
新前和这个旧后匹配成功

59:28.300 --> 59:29.300
那么你就需要干嘛呢

59:29.300 --> 59:32.300
你就需要把这个旧后所对应的这个锻目

59:32.300 --> 59:33.300
放到什么呢

59:33.300 --> 59:35.300
放到这个旧前的这个前面

59:35.300 --> 59:36.300
ok

59:36.300 --> 59:38.300
我这边直接把这个描述

59:38.300 --> 59:41.060
拿过来

59:41.060 --> 59:42.060
这边看一下

59:42.060 --> 59:44.060
如果新旧直接点通过什么呢

59:44.060 --> 59:46.060
比如这个新后和旧前

59:46.060 --> 59:47.060
比如这两个

59:47.060 --> 59:48.060
这两个

59:48.060 --> 59:50.060
这两个如果匹配成功

59:50.060 --> 59:51.060
那你就需要干嘛呢

59:51.060 --> 59:53.060
你就需要把这个旧前

59:53.060 --> 59:55.060
对应的这个锻目解点

59:55.060 --> 59:57.060
插入到这个旧后的这个之前

59:57.060 --> 59:58.060
插入到这个位置

59:58.060 --> 01:00:00.060
如果你这个新旧

01:00:02.060 --> 01:00:04.060
如果你这个新旧直接点

01:00:04.060 --> 01:00:06.060
这边这个通过这个新前

01:00:06.060 --> 01:00:07.060
新前和旧后

01:00:07.060 --> 01:00:09.060
这两个匹配成功

01:00:09.060 --> 01:00:10.060
那你需要把什么呢

01:00:10.060 --> 01:00:11.060
需要把这个旧后

01:00:11.060 --> 01:00:12.060
对应的这个锻目解点

01:00:12.060 --> 01:00:14.060
放到这个旧前的这个前面

01:00:14.060 --> 01:00:17.060
总之他这边就是也是一种算法

01:00:17.060 --> 01:00:18.060
ok

01:00:18.060 --> 01:00:20.060
好在这个req的圆满里面的话

01:00:20.060 --> 01:00:21.060
他在这个注释里面

01:00:21.060 --> 01:00:22.060
他实际上解释了的

01:00:23.060 --> 01:00:24.060
走吧

01:00:24.060 --> 01:00:25.060
他面试的时候经常问你req

01:00:25.060 --> 01:00:27.060
req为什么不采用view的这种

01:00:27.060 --> 01:00:28.060
双端对比算法

01:00:28.060 --> 01:00:30.060
实际上在这个req的圆满里面

01:00:30.060 --> 01:00:31.060
他解释了的

01:00:33.500 --> 01:00:34.500
实际上

01:00:34.500 --> 01:00:39.500
在这个req的这个圆满中

01:00:39.500 --> 01:00:41.500
解释了

01:00:41.500 --> 01:00:42.500
解释了

01:00:42.500 --> 01:00:47.500
为什么不使用双端def

01:00:47.500 --> 01:00:49.500
这边我们来看一下

01:00:50.500 --> 01:00:53.500
好直接把这个req这个圆满

01:00:53.500 --> 01:00:55.500
这个部分我把它拿过来

01:00:56.500 --> 01:01:00.220
这边

01:01:00.220 --> 01:01:02.220
这边他写了很大一段这个注释

01:01:02.220 --> 01:01:03.220
可不可以啊

01:01:03.220 --> 01:01:04.220
写了很大一段注释

01:01:04.220 --> 01:01:05.220
他就在解释

01:01:05.220 --> 01:01:07.220
为什么他没有用这个双端算法

01:01:07.220 --> 01:01:08.220
好

01:01:08.220 --> 01:01:10.220
这边你如果把它翻译成中文的话

01:01:10.220 --> 01:01:11.220
实际上是这样子的

01:01:11.220 --> 01:01:13.220
将上面的注释

01:01:14.220 --> 01:01:16.220
将上面的这个注释

01:01:18.220 --> 01:01:20.220
翻译成中文

01:01:21.220 --> 01:01:22.220
如下

01:01:23.220 --> 01:01:24.220
翻译出来的话

01:01:24.220 --> 01:01:25.220
大致就是这个样子的

01:01:25.220 --> 01:01:27.220
把这边这个翻译我把它拿过来

01:01:30.980 --> 01:01:34.310
这边

01:01:34.310 --> 01:01:35.310
ok

01:01:35.310 --> 01:01:36.310
就是你这边的话

01:01:36.310 --> 01:01:37.310
这个双端def需要什么呢

01:01:37.310 --> 01:01:39.310
需要向前这个查找

01:01:39.310 --> 01:01:41.310
但是呢在这个req里面

01:01:41.310 --> 01:01:43.310
req里面他每一个这个fiber load的节点

01:01:43.310 --> 01:01:46.310
他没有这个反向指征

01:01:46.310 --> 01:01:47.310
没有反向指征

01:01:47.310 --> 01:01:48.310
所以他只能什么呢

01:01:48.310 --> 01:01:50.310
只能从前往后

01:01:50.310 --> 01:01:51.310
他不能什么呢

01:01:51.310 --> 01:01:52.310
不能反过来

01:01:52.310 --> 01:01:53.310
那这个req的话

01:01:53.310 --> 01:01:54.310
他现在的话

01:01:54.310 --> 01:01:55.310
他想看一下就是

01:01:55.310 --> 01:01:56.310
目前的这种方式

01:01:56.310 --> 01:01:58.310
能够走多远

01:01:58.310 --> 01:02:00.310
如果就是他们目前这种

01:02:00.310 --> 01:02:02.310
这种这种单向的这种方式

01:02:02.310 --> 01:02:04.310
如果不理想

01:02:04.310 --> 01:02:05.310
他们会干嘛呢

01:02:05.310 --> 01:02:06.310
他们会就是再来

01:02:06.310 --> 01:02:09.310
再去考虑这个双端req

01:02:10.310 --> 01:02:11.310
这边的话

01:02:11.310 --> 01:02:13.310
req认为对于这个列表反转

01:02:13.310 --> 01:02:15.310
和需要进行双端

01:02:15.310 --> 01:02:17.310
探索的场景

01:02:17.310 --> 01:02:18.310
实际上是比较少见的

01:02:18.310 --> 01:02:20.310
所以他在这一版里面

01:02:20.310 --> 01:02:21.310
他先不对这种bender kiss

01:02:21.310 --> 01:02:23.310
做这个额外的优化

01:02:23.310 --> 01:02:25.310
他这边都写的有

01:02:25.310 --> 01:02:26.310
这边都写的有

01:02:26.310 --> 01:02:27.310
ok

01:02:27.310 --> 01:02:28.310
看一下

01:02:28.310 --> 01:02:29.310
好

01:02:29.310 --> 01:02:31.310
这就是关于整个req里面的

01:02:31.310 --> 01:02:33.310
这个地负算法

01:02:33.310 --> 01:02:35.310
这边我们这边从头到尾

01:02:35.310 --> 01:02:36.310
给大家介绍了一下

01:02:36.310 --> 01:02:38.310
用了很多张图

01:02:38.310 --> 01:02:39.310
对吧

01:02:39.310 --> 01:02:40.310
用了很多张图

01:02:40.310 --> 01:02:42.310
那叫这边这个单节点

01:02:42.310 --> 01:02:44.310
然后这边多节点

01:02:44.310 --> 01:02:45.310
对吧

01:02:45.310 --> 01:02:47.310
多节点的第一轮便利

01:02:47.310 --> 01:02:49.310
然后接下来这边

01:02:49.310 --> 01:02:51.310
这个第二轮便利

01:02:51.310 --> 01:02:53.310
应该是比较清晰的了

01:02:53.310 --> 01:02:55.310
应该是比较清晰的

01:02:55.310 --> 01:02:56.310
好

01:02:56.310 --> 01:02:58.310
最后你来答这道题

01:02:58.310 --> 01:03:00.310
req中的这个地负算法

01:03:00.310 --> 01:03:01.310
有没有了解过

01:03:01.310 --> 01:03:03.310
具体的流程是怎么样子的

01:03:03.310 --> 01:03:04.310
那你是不是就是把我们

01:03:04.310 --> 01:03:06.310
课程里面讲的东西

01:03:06.310 --> 01:03:07.310
是不是自己把它干嘛

01:03:07.310 --> 01:03:09.310
把他盖过出来就可以了

01:03:09.310 --> 01:03:10.310
对不对

01:03:10.310 --> 01:03:11.310
包括这边req

01:03:11.310 --> 01:03:12.310
为什么不采用view的

01:03:12.310 --> 01:03:14.310
这个双端对比算法

01:03:14.310 --> 01:03:15.310
实际上就是什么

01:03:15.310 --> 01:03:16.310
就这段话

01:03:16.310 --> 01:03:17.310
对不对

01:03:17.310 --> 01:03:18.310
好

01:03:18.310 --> 01:03:20.310
我这边我把这个参考单

01:03:20.310 --> 01:03:21.310
我把他拿过来

01:03:21.310 --> 01:03:26.260
把这个参考单拿过来

01:03:26.260 --> 01:03:27.260
ok

01:03:27.260 --> 01:03:28.260
比较长

01:03:28.260 --> 01:03:29.260
比较长

01:03:29.260 --> 01:03:30.260
这边整体的话

01:03:30.260 --> 01:03:31.260
他这边是

01:03:31.260 --> 01:03:35.260
整个地负分成单节点和多节点

01:03:35.260 --> 01:03:36.260
对吧

01:03:36.260 --> 01:03:37.260
单节点的话

01:03:37.260 --> 01:03:38.260
这边

01:03:38.260 --> 01:03:39.260
然后接下来多节点

01:03:39.260 --> 01:03:40.260
多节点这边

01:03:40.260 --> 01:03:42.260
第一轮便利和第二轮便利

01:03:42.260 --> 01:03:44.260
以及req

01:03:44.260 --> 01:03:47.260
不使用双端req的原因

01:03:47.260 --> 01:03:49.260
这个我就不挨在这去念了

01:03:49.260 --> 01:03:50.260
下面的话

01:03:50.260 --> 01:03:51.260
大家把这个参考单

01:03:51.260 --> 01:03:52.260
可以自己看一下

01:03:52.260 --> 01:03:53.260
看一下之后

01:03:53.260 --> 01:03:54.260
你尽量就是什么

01:03:54.260 --> 01:03:55.260
通过你自己的话

01:03:56.260 --> 01:03:58.260
这个东西你不要去背

01:03:58.260 --> 01:03:59.260
你背不住的

01:03:59.260 --> 01:04:00.260
你背不住

01:04:00.260 --> 01:04:01.260
我也背不住

01:04:01.260 --> 01:04:02.260
对不对

01:04:02.260 --> 01:04:03.260
这东西

01:04:03.260 --> 01:04:04.260
这东西就是靠理解

01:04:04.260 --> 01:04:06.260
你把他理解了之后

01:04:06.260 --> 01:04:08.260
再下凭着你的理解

01:04:08.260 --> 01:04:10.260
自己把它说出来

01:04:10.260 --> 01:04:11.260
好吧

01:04:11.260 --> 01:04:13.260
这就是关于这节课

01:04:13.260 --> 01:04:16.260
这个图解地负双法

01:04:16.260 --> 01:04:17.260
好

01:04:17.260 --> 01:04:18.260
这节课就到这里

01:04:18.260 --> 01:04:19.260
再见

