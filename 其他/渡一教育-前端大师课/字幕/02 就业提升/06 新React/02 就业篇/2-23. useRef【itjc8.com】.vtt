WEBVTT

00:00.000 --> 00:06.640
ok 这些个的话咱们继续看啊 继续往后面看 这里的话来看一下这个use rift

00:07.520 --> 00:11.440
好 这边的话有道面词题 他问你use rift是干什么的

00:12.160 --> 00:17.680
好 然后这个riff的这个工作流程是怎么样的 那什么又叫做这个riff的失控

00:18.480 --> 00:23.920
ok 好 那这边的话我们从这么四个点来讲一下啊 首先第一个就是关于这个

00:24.880 --> 00:25.520
use rift

00:26.480 --> 00:28.160
use rift

00:28.720 --> 00:30.160
啊 然后各个阶段

00:31.520 --> 00:35.360
对吧 我们有这个mount阶段 有update阶段

00:35.920 --> 00:39.440
然后接下来就是什么呢 接下来就是riff的这个工作流程

00:42.000 --> 00:44.880
好 然后接下来就是riff的失控

00:45.520 --> 00:49.920
以及什么呢 以及riff失控的这个防制

00:50.800 --> 00:54.960
就如何去防制这个riff的失控啊 我们从这四个方面来看

00:55.440 --> 01:01.570
ok 好 这边一个一个来 好 首先第一个

01:02.690 --> 01:07.650
第一个的话是关于这个riff各个阶段 我们首先先回顾一下riff吧

01:08.210 --> 01:11.730
riff的话它其实来源于英语的这个reference

01:13.090 --> 01:17.490
riff是什么呢 是英语这个reference

01:19.570 --> 01:20.610
reference

01:21.490 --> 01:24.610
啊 是这个单词 这个单词叫做什么 叫做引用的意思

01:25.570 --> 01:27.970
ok 它是这个单词的这个缩写

01:29.650 --> 01:35.170
那在这个reference中 它为什么会设计这个reference呢 啊 实际上是这个开发者

01:35.570 --> 01:41.330
早期的时候 它习惯使用这个reference 保存这个对动物元素的一个引用

01:42.610 --> 01:43.650
在这个reference中

01:45.490 --> 01:49.570
开发者可以通过什么呢 通过reference

01:50.130 --> 01:53.570
保存一个对动物的引用

01:54.370 --> 01:57.890
我们知道我们最早前段开发的时候 是不是就要去操作这个动物

01:58.610 --> 02:06.050
对不对啊 然后现在的话 这种mvvm的这个模式啊 我们不需要再去直接去操作这个动物了

02:06.050 --> 02:08.850
就操作动物的工作被谁给接管了

02:09.570 --> 02:11.650
所以被这个react这种框架

02:12.130 --> 02:13.490
接管了对不对

02:13.810 --> 02:18.210
但有些时候的话 我们有一些这个需求 仍然需要什么呢

02:18.290 --> 02:21.730
需要去真实的去操作这个动物节点

02:22.370 --> 02:25.650
那这个时候怎么办呢 这个时候就可以使用这个reference

02:26.530 --> 02:27.970
这个时候就可以使用reference

02:27.970 --> 02:30.450
reference我们之前在前面介绍过了对不对

02:31.730 --> 02:32.530
好事实上

02:33.970 --> 02:35.330
事实上这个任何

02:36.050 --> 02:45.490
任何需要被这个引用的这个数据啊 都可以什么呢 都可以保存在reference上

02:46.050 --> 02:51.250
然后在这个整个react它发展的这个过程中

02:51.250 --> 02:55.650
实际上出现过三种这个reference相关的这种引用模式

02:56.130 --> 03:03.740
在reference中出现过出现过三种

03:05.020 --> 03:07.580
这个reference引用模式

03:08.380 --> 03:11.500
哪三种呢 首先第一种是strain内心

03:13.180 --> 03:15.420
就引用的话它是一个制服串

03:15.500 --> 03:18.460
制服串啊 但这个的话现在已经不推荐使用了

03:20.060 --> 03:22.460
也不推荐使用

03:23.020 --> 03:28.140
这我们之前说过的对吧 还有什么呢 还有就是你这边reference对应的是一个什么呢

03:28.140 --> 03:31.740
对应的是个函数啊 函数内心

03:32.220 --> 03:36.220
这个我们之前也讲过了 而另外一个什么呢 另外一个对应的是一个对象

03:37.260 --> 03:39.020
对象里面有个键叫做current

03:39.500 --> 03:41.100
current上架这边对应的是什么

03:41.100 --> 03:43.340
对应的就是后面你存出的这种内心

03:43.900 --> 03:47.500
那现在目前最为推荐的是吗 最后推荐的时候就这种

03:48.460 --> 03:50.300
对了 推荐就这种啊

03:50.860 --> 03:54.060
那现在关于这个创建reference

03:55.260 --> 03:55.660
目前

03:57.580 --> 04:01.020
目前关于这个创建reference

04:01.580 --> 04:02.700
如果是内主键

04:03.740 --> 04:08.140
内主键的话推荐使用什么 是不是使用这个create

04:09.100 --> 04:10.220
create rift方法

04:11.020 --> 04:13.180
对吧 然后如果是这个函数主键

04:14.300 --> 04:18.460
然后推荐使用什么呢 使用这个use rift

04:20.700 --> 04:22.220
啊 推荐使用use rift

04:22.220 --> 04:24.460
他们创建出来的reference不就这种类型的

04:25.740 --> 04:27.580
对吧 就这种类型的啊

04:27.980 --> 04:31.900
好 那接下来我们这边重点是看什么呢 我们重点是看这个use rift

04:32.700 --> 04:34.620
use rift我们先来看一下它的用法

04:35.820 --> 04:37.180
用法如下

04:38.700 --> 04:42.140
好 这边的话首先呢 你这边调用这个use rift

04:43.100 --> 04:46.460
调用use rift 你这边可以传一个初始之性去

04:46.460 --> 04:49.260
然后回头的话 这边返回一个ref container

04:49.260 --> 04:52.140
这个ref container实际上就是什么 实际上就这个

04:53.260 --> 04:54.780
是不是这个 对不对

04:55.340 --> 04:56.780
好 然后接下来我们这边

04:57.580 --> 04:59.980
这边我们来看一下它的各个阶段啊

04:59.980 --> 05:03.340
这边呢 首先是什么呢 首先是它的这个mount阶段

05:05.950 --> 05:07.950
mount阶段

05:10.500 --> 05:12.580
一会的话看这个update阶段

05:14.670 --> 05:17.310
好 mount和update

05:18.030 --> 05:21.950
好 首先是mount mount的话调用了什么 调用的是mount rift

05:23.710 --> 05:29.070
mount阶段 调用的是什么呢 调用的是mount rift

05:30.030 --> 05:32.910
啊 对应的这个代码如下

05:34.750 --> 05:36.430
好 这边mount rift你看一下

05:37.230 --> 05:40.030
mount rift呢 整体这个代码的话实际上很简单的

05:40.590 --> 05:43.550
啊 首先呢 这边还是创建一个什么呢 创建一个这个

05:43.630 --> 05:47.310
互科对象 好 你看这边rift rift对应的就是一个什么

05:47.310 --> 05:49.870
说对应的就是这个对象 对象里面有个current

05:49.870 --> 05:52.990
current这边对应的值是什么 所以你这边传过来的这个初始值

05:53.710 --> 05:56.590
对不对 传过来初始值 然后接下来的话我这个互科点

05:57.150 --> 06:00.510
memo的state缓存的就是什么 是不是缓存的就是这个ref

06:01.390 --> 06:05.390
缓存的就是这个值 对不对啊 这边呢我们可以看到

06:05.390 --> 06:11.550
在mount阶段 在mount阶段

06:12.830 --> 06:15.070
首先调用什么呢 调用这个

06:16.590 --> 06:17.630
调用这个方法

06:18.990 --> 06:24.510
得到一个互科对象 对吧 然后接下来该互科对象

06:25.870 --> 06:30.430
该互科对象的这个啊memo的state

06:32.620 --> 06:37.820
上面 然后会这个缓存 缓存一个

06:38.460 --> 06:39.820
什么呢 缓存一个这个对象

06:40.940 --> 06:43.660
current啊 缓存一个键为

06:44.540 --> 06:50.400
稍等啊 卡住了 卡住了缓存一个键

06:51.600 --> 06:53.760
键为什么 键为这个current

06:54.960 --> 06:59.680
current的这个对象 是不是这个对象 对不对

06:59.680 --> 07:03.520
然后之后 之后向这个外部

07:04.720 --> 07:10.560
向外部返回该对象 你要追踪到他这边return ref

07:10.560 --> 07:14.720
返回的是不是就这个对象 对不对啊 这是他这个mount阶段

07:15.120 --> 07:19.040
所做的事情 好 你这边又是ref 然后拿到一个ref之后大家

07:19.040 --> 07:21.760
你就放了什么 一般是不是就是和这个主键

07:22.720 --> 07:26.320
或者和这个主键内部那个接视差 所进行一个绑定

07:27.280 --> 07:33.200
对不对啊 这是mount阶段 好 然后接下来的话 这边这个update阶段啊

07:34.640 --> 07:38.640
update阶段 调用的是什么呢 调用的是

07:40.000 --> 07:41.200
这个update ref

07:42.080 --> 07:43.760
相关代码如下

07:46.290 --> 07:49.730
好 整个这个update阶段的话 代码也非常简单

07:49.730 --> 07:52.770
它实际上就是什么呢 就是把之前的这个hook对象拿到

07:53.410 --> 07:54.050
那你看一下

07:54.850 --> 08:01.330
首先的话 拿到之前的hook对象拿到 拿到之后返回什么 返回这个hook.memo state

08:02.690 --> 08:06.050
啊 这个hook.memo state缓存的就是什么 说缓存的就是他呀

08:07.250 --> 08:10.290
是不是就是缓存的他 对不对啊 拿到这个对象

08:10.450 --> 08:14.290
这个就是update阶段所做的这个事情啊

08:15.250 --> 08:16.930
这个下面我就不写描述了啊

08:18.450 --> 08:21.890
好 除了这个user ref以外这个crate ref

08:22.210 --> 08:26.690
就你这边这个内主键 内主键我们是不是推荐使用crate ref方法来创新ref

08:27.170 --> 08:30.930
啊 这个crate ref方法的话 实际上和这个user ref

08:31.250 --> 08:36.290
他们也差不多 他也会创建就是这个相同数据结构的这个ref

08:37.090 --> 08:43.330
ok 除了这个user ref以外

08:45.570 --> 08:47.330
以外这个crate

08:48.530 --> 08:57.490
crate ref也会创建相同数据结构的这个ref

08:58.450 --> 09:03.820
啊 对应的话是这个样子的啊 把这个带完了过来

09:05.420 --> 09:10.460
对应是这样子 要是不是基本上是一样的 对不对 这边有个current啊对应一个值

09:10.620 --> 09:17.980
那返回什么呢 返回整个这个对象啊 所以他这个ref的数据结构也是一样的啊和user ref一样的

09:18.620 --> 09:22.380
ok 好 这是关于这个user ref他各个阶段

09:23.020 --> 09:26.700
好 这个看完了之后 然后接下来的话 我们来看什么呢 我们来看这个

09:27.740 --> 09:30.460
ref他的一个工作的这个流程

09:32.690 --> 09:34.610
好 我们知道就是这个ref

09:35.250 --> 09:41.650
ref他这个创建完之后 他是会挂在什么 他是不是会挂在这个比如你原生组件

09:42.050 --> 09:47.650
或者这个比较class component 所以会挂在上面对不对啊ref

09:48.930 --> 09:56.210
创建之后会挂在什么呢 会挂在这个host component

09:57.970 --> 10:10.180
或者什么呢 或者class component component上面对不对啊形成什么呢 形成这个ref props

10:11.140 --> 10:13.460
啊 比如说例如

10:15.380 --> 10:18.020
比方你看这里 我拿过来

10:20.500 --> 10:27.620
这边啊 上面的话是一个host component啊 比如用这边一个div啊 这边ref等于你创建好的这个ref

10:27.700 --> 10:32.740
那这边这个是不是就整个是一个pops啊 对不对 所以我们把它称之为这个ref props

10:33.140 --> 10:36.980
啊 这边呢也是这边是一个class component 那在这边这个ref

10:37.940 --> 10:40.660
对吧 一个ref啊 这个也是一个ref props

10:41.220 --> 10:45.460
好 所以说你整个这个ref他的工作流程实际上分成两个阶段

10:46.340 --> 10:52.750
整个ref 整个ref的工作流程

10:54.030 --> 10:58.990
分为什么呢 分为两个阶段 哪两个阶段呢 我们知道我们整个react

10:59.390 --> 11:04.750
实际上也就分成两个阶段 整个react分成哪两个阶段 一个是啊什么Render阶段

11:05.310 --> 11:09.150
对不对 另外一个是什么 另外一个什么commit阶段

11:10.430 --> 11:16.030
对不对 啊说整个这个react分成这两个阶段 在这两个阶段的话 这边的话针对这个ref

11:16.350 --> 11:17.790
有不同的这个处理

11:18.510 --> 11:21.630
面包 好在Render阶段呢 他会干嘛呢 他会标记

11:22.910 --> 11:25.310
标记这个ref flag

11:26.830 --> 11:31.470
这是Render阶段要做的事情 好 然后接下来这个commit阶段

11:32.190 --> 11:37.790
commit阶段呢 他会什么呢 他会根据所标记的这个ref flag

11:39.470 --> 11:43.870
然后执行什么呢 执行ref相关的这个操作

11:44.830 --> 11:48.430
ok 啊 整体这边我画了个图啊 整体的这个图

11:48.990 --> 11:56.000
大致就是这个样子的 大致就是这样子的啊 首先呢 这边是Render阶段

11:56.480 --> 11:58.080
那接下来这边是commit阶段

11:58.720 --> 12:02.240
我们知道Render阶段呢 他分为什么呢 分为这个begin walk和

12:02.720 --> 12:04.320
commit这个complete walk

12:04.960 --> 12:09.120
对不对 好 这边的话这个无论是begin walk还是complete walk

12:09.440 --> 12:12.720
他们这边要做的事情是什么呢 他们这边要做的是标记

12:13.760 --> 12:18.800
mark啊 上图中上图中这个markerif

12:20.560 --> 12:21.200
表示的

12:22.640 --> 12:25.280
表示的就是什么呢 就是标记

12:26.080 --> 12:26.880
这个ref

12:27.600 --> 12:30.400
ok 好 大家这边这个commit阶段

12:30.400 --> 12:34.640
commit阶段的话 他会这个执行 他会有一个这个motation值阶段

12:35.200 --> 12:39.200
这我们之前讲过的 对不对 好 在这个motation值阶段里面

12:39.200 --> 12:44.160
他这边会涉及到和这个ref相关的操作啊 这边实际上是删除啊

12:44.160 --> 12:45.200
删除之前的ref

12:45.680 --> 12:47.680
好 然后再这个layout值阶段

12:48.320 --> 12:51.360
这边会干嘛 这边会重新添加新的这个ref

12:52.000 --> 12:53.920
大致的话 这边有这么一些这个操作

12:54.640 --> 12:56.800
好 我们首先先来看这个mark

12:57.600 --> 13:00.480
啊 这边相关代码五项

13:04.530 --> 13:06.050
啊 把这个拿过来

13:09.070 --> 13:10.510
好 这边大家可以看一下

13:11.630 --> 13:16.190
他这边是如何标记ref的啊 标记ref的这边人人是使用什么

13:16.190 --> 13:19.070
是不是使用就是我们之前所讲的那种未运算

13:19.630 --> 13:22.350
对了 这边walkingprogress.flex

13:22.990 --> 13:25.630
啊 大家这边是标记这么一个这个ref

13:26.350 --> 13:29.630
ok 好 他会在什么时候呢 他有两种情况

13:30.350 --> 13:31.710
啊 有两种情况

13:34.580 --> 13:39.540
有两种情况会这个标记ref

13:40.420 --> 13:42.980
那两种呢 一种的话是你这个mounts

13:45.170 --> 13:48.130
啊 什么是mounts啊 就是你这边current等等闹的时候

13:48.690 --> 13:51.170
这说明是不是就是你现在是啊 mount阶段

13:51.810 --> 13:57.730
对不对 mount阶段 mount阶段并且什么呢 并且你的这个ref不等于空啊 并且

13:58.690 --> 14:00.530
就是你的这个ref props

14:01.170 --> 14:03.090
ref props是什么 我就这个

14:04.130 --> 14:06.850
对了 我们说了这个是不是就是这个ref props

14:07.490 --> 14:11.090
对吧 并且这个ref props不为空

14:12.290 --> 14:15.010
第二个是什么呢 第二个是这个up update

14:17.730 --> 14:22.210
update阶段 就你这边current不等于not 是不是说明就是update阶段

14:22.690 --> 14:27.650
对不对啊 并且什么呢 并且你的这个currentref不等于ref

14:28.210 --> 14:32.130
是吗 也就说明你的这个ref props是发生了变化

14:32.850 --> 14:35.970
对不对 并且ref props

14:36.770 --> 14:39.010
发生了变化

14:39.570 --> 14:43.490
啊 在这两种情况下 他会标记这个ref

14:44.210 --> 14:45.650
好标记完ref之后

14:47.250 --> 14:51.330
标记完ref之后

14:51.890 --> 14:53.970
来到了什么呢 来到了commit阶段

14:54.930 --> 14:55.650
来到了

14:56.370 --> 14:58.930
commit阶段

14:59.490 --> 15:03.730
好 commit阶段的话 接下来他会在什么呢 他会在这个motation这个止阶段

15:04.770 --> 15:06.850
啊 会在这个motation

15:08.130 --> 15:09.970
motation止阶段

15:11.570 --> 15:15.170
执行什么呢 执行这个ref的三处操作

15:17.470 --> 15:20.430
ok 因为你这边呢 你看你比如说这个update阶段

15:20.670 --> 15:22.670
你这个ref props发生变化

15:23.230 --> 15:26.590
发生变化我是不是需要把这个旧的ref是不是删除掉

15:27.310 --> 15:33.230
对不对啊 说他这边会在这个motation止阶段执行ref的三处操作啊 三处

15:34.190 --> 15:36.990
旧的旧的ref

15:37.870 --> 15:40.510
ok 对应了这个代码 在这里

15:41.310 --> 15:47.260
把他过来啊对应了这边

15:48.300 --> 15:51.660
commit notation on this effect on fiber

15:52.060 --> 15:54.700
这边有一个如果current不等于空

15:55.660 --> 16:00.060
不等于空 不等于空了 说明什么 说明是更新 对吧 更新的话再加这边干嘛呢

16:00.780 --> 16:07.260
commit detach ref把current传过去 这边他要做啥呢 他这边要做的事情实际上就是移除

16:09.180 --> 16:14.140
上面的代码中 上面的代码中这个commit

16:14.860 --> 16:18.060
detach ref啊方法

16:19.420 --> 16:22.620
要做的事情就是移除

16:23.340 --> 16:26.620
旧的ref啊 然后相关代码

16:27.260 --> 16:27.740
如下

16:29.950 --> 16:31.310
对应的代码在这里

16:35.870 --> 16:36.750
对应代码在这里

16:37.310 --> 16:41.630
ok 你看这边 这边他就是删除啊 这边他就你看这边

16:42.430 --> 16:45.310
current ref点current就让他变为这个nau

16:45.790 --> 16:51.310
对吧 三处 好 三处完成之后 然后接下来会在什么呢 会在这个nail out 止阶段

16:53.390 --> 16:54.430
三处完成后

16:56.430 --> 17:01.230
三处完成后会在什么呢 会在这个nail out

17:01.950 --> 17:02.590
止阶段

17:04.430 --> 17:08.270
干嘛呢 重新复制新的ref

17:09.310 --> 17:14.510
ok 对应的这个方法啊 对应的方法就是这个commit attach ref

17:17.120 --> 17:22.800
对应的方法就是这个commit detach

17:25.620 --> 17:32.420
哦 不是detach 是attach detach是三处attach attach ref

17:33.380 --> 17:34.500
ok

17:36.100 --> 17:39.860
commit attach ref对的 来我们这边来看一下相关的这个代码

17:42.130 --> 17:47.090
哦 这里这里首先这个啊 会在nail out 止阶段重新复制这个

17:47.810 --> 17:49.410
新的ref啊 相关

17:51.250 --> 17:52.130
代码如下

17:53.090 --> 17:55.810
啊 这边首先先把这一块代码先把他过来

17:58.620 --> 18:03.100
啊 其他的省留掉啊 你看这边 这边是不是会调用commit attach ref

18:03.820 --> 18:05.180
对不对啊 这个

18:05.900 --> 18:06.460
对应的

18:07.260 --> 18:09.020
对应的这个方法啊

18:10.060 --> 18:12.380
这个commit attach ref就是

18:13.980 --> 18:16.700
就是用来干嘛呢 用来这个

18:17.820 --> 18:19.500
重新复制

18:20.700 --> 18:22.220
新这个ref

18:23.340 --> 18:26.220
ok 相关代码如下

18:28.320 --> 18:30.240
好 把这一段把他拿过来

18:35.490 --> 18:37.810
啊 像这里 这里的话 你看这边后面

18:37.970 --> 18:43.490
然后面的话 这边是不是就重新针对这个ref ref.current 是不是重新复了新的字

18:44.370 --> 18:46.450
对不对 重新复了新的字啊

18:48.860 --> 18:52.300
他这边的话 他这个instance to use 是什么啊

18:52.300 --> 18:55.020
instance use的话 如果你是这个内组件

18:55.580 --> 18:59.180
内组件的话 他这边就是直接拿的什么 直接拿的这个state

18:59.900 --> 19:03.100
啊 通过这个state 可以拿到那个他的动物元素

19:03.580 --> 19:06.780
啊 如果你是这个原来的这个host component

19:07.180 --> 19:09.980
啊 本身就是这种原生元素 他这边呢 是会

19:10.540 --> 19:12.860
调用一个叫做get public instance

19:13.420 --> 19:16.060
最终他反正也是反回一个这个动物元素

19:16.620 --> 19:18.780
ok 啊 反正拿到这个新的引用

19:19.420 --> 19:24.860
ok 那整体的整个ref的工作流程就这样子的啊 你这边你再来看一下这张图

19:25.500 --> 19:27.580
在刃刃阶段 刃刃阶段主要要做的是

19:28.220 --> 19:30.460
是mark 对不对 进行一个标记

19:31.020 --> 19:33.660
标记完了之后 然后加在这个commit阶段

19:33.900 --> 19:36.540
commit阶段的话 这边在motation指阶段

19:37.020 --> 19:42.140
啊 把这个如果有旧的这个ref 就把它删除掉 在这个layout 指阶段

19:42.620 --> 19:45.420
然后把什么 把这个新的ref 把它挂上去

19:46.220 --> 19:50.060
对不对 ok 是关于这个ref的工作流程

19:51.580 --> 19:53.500
好 然后接下来的话 我们来看一下

19:54.220 --> 19:56.620
来看一下关于这个ref的失控

19:57.340 --> 19:58.940
那什么叫做ref的失控呢

19:59.900 --> 20:05.180
当你这个ref 因为你ref的话可以保存对这个动物元素的这个引用

20:05.980 --> 20:11.340
对不对 好 那当你这个ref 保存对这个动物元素的引用的时候

20:11.660 --> 20:12.940
它就有可能

20:13.660 --> 20:15.340
会造成ref的失控

20:16.140 --> 20:17.740
ok 把这句话记在这里

20:18.540 --> 20:19.180
当我们

20:21.300 --> 20:24.020
当我们使用ref

20:25.300 --> 20:30.020
保存什么呢 保存对动物的引用时

20:31.220 --> 20:34.260
那么就有可能会

20:34.980 --> 20:39.780
造成什么呢 会造成ref的失控

20:41.700 --> 20:43.300
那什么是ref的失控呢

20:44.580 --> 20:48.100
所谓ref的失控

20:48.740 --> 20:50.180
就是指什么呢 就是指

20:52.900 --> 20:56.500
开发者 开发者 然后通过

20:57.780 --> 21:00.020
这个ref 操作了

21:01.220 --> 21:02.500
操作了动物

21:03.220 --> 21:04.980
但是 这一行为

21:05.860 --> 21:10.500
本来应该是有什么呢 是由这个rekt

21:11.540 --> 21:12.100
接管的

21:13.220 --> 21:17.220
对不对 那现在的话 你这个开发者通过ref也在操作这个动物

21:17.540 --> 21:20.340
那rekt那边的话 他本质上他也要操作这个动物

21:20.660 --> 21:21.940
对不对 然后两者

21:23.060 --> 21:23.700
产生了

21:25.060 --> 21:28.260
两者产生了这个冲突

21:30.320 --> 21:31.280
产生了冲突

21:32.000 --> 21:32.720
这种冲突

21:34.320 --> 21:39.760
我们就称之为ref的失控

21:40.160 --> 21:41.600
对不对 失去控制了嘛

21:42.160 --> 21:44.880
对不对 你这个责任方不明确了嘛

21:45.520 --> 21:49.920
对不对 究竟是谁的责任 是rekt的责任 还是开发者的责任

21:50.400 --> 21:51.920
现在的话 你这个不明确了

21:52.960 --> 21:55.760
好 那我们这边 我们来考虑这么一段代吧

21:58.080 --> 21:58.560
考虑

21:59.600 --> 22:01.920
下面这一段代吧

22:02.400 --> 22:03.200
这一段代吧

22:06.800 --> 22:09.200
ok 好 比如说我这边 我把它拿过来

22:11.680 --> 22:13.040
好 这边 大家看一下

22:13.600 --> 22:15.840
这边的话 我创建了一个ref

22:16.480 --> 22:18.640
好 然后这个use effect

22:19.760 --> 22:21.600
这个是一个副作用对不对

22:21.600 --> 22:26.240
好 那这边呢 执行了三个操作 操作一 操作二 操作三

22:26.640 --> 22:28.320
操作一的话是进行一个fox

22:28.960 --> 22:31.920
操作二的话是get这个bounding client rekt

22:32.400 --> 22:34.960
好 操作三的话是改变他的这个宽度

22:35.680 --> 22:36.960
好 那大家思考一下

22:37.440 --> 22:39.520
上面的这个三个操作

22:40.240 --> 22:42.240
哪一个是不推荐的

22:43.760 --> 22:44.880
啊 这边有三个操作

22:45.360 --> 22:46.880
哪一个是不推荐的

22:47.680 --> 22:49.760
大家可以想一想啊 自己想一想

22:50.320 --> 22:54.960
ok 好 这边的话 实际上这三个这个操作中

22:54.960 --> 22:57.840
第三个操作是不推荐的

22:58.720 --> 23:01.440
ok 好 在上面的操作中

23:02.160 --> 23:07.920
在上面的三个操作中

23:08.800 --> 23:12.640
第三个操作是不推荐的

23:13.760 --> 23:18.240
为什么呢 因为你这个rekt他作为一个仕图层的这个框架

23:18.800 --> 23:23.120
啊 实际上他接管了这个大部分和仕图相关的这个操作

23:23.680 --> 23:29.120
他这样做的好处就是你开发者的话可以专注于你的业务上面的这个开发逻辑

23:30.080 --> 23:31.120
对不对

23:31.120 --> 23:37.920
rekt作为一个仕图层 仕图层框架

23:38.400 --> 23:43.520
啊 然后接管了什么呢 接管了大部分和这个仕图

23:45.440 --> 23:48.480
和仕图相关的操作

23:49.360 --> 23:55.600
这样开发者可以可以专注于

23:56.320 --> 23:58.960
专注于这个业务

24:00.320 --> 24:03.120
业务上面的开发逻辑

24:07.700 --> 24:10.100
开发逻辑

24:10.660 --> 24:11.220
对吧

24:11.220 --> 24:14.340
那么在你这个上面的这个三个操作中

24:14.340 --> 24:15.620
前两个操作

24:15.620 --> 24:18.180
他其实并没有被这个rekt接管

24:18.180 --> 24:20.100
啊 所以你这样子操作的话

24:20.100 --> 24:24.340
他可以百分之百的确认是这个来自于开发者的这个操作

24:24.820 --> 24:26.340
但是你的第三个操作

24:26.340 --> 24:28.820
第三个操作是改变什么 是不改变这个宽度

24:29.380 --> 24:32.580
你这个的话他其实并不能确定是开发者的行为

24:32.580 --> 24:33.860
还是rekt这个行为

24:34.980 --> 24:38.500
因为你这边的话 你这个开发者在这边改这个宽度

24:38.500 --> 24:41.540
rekt的话他也接管了这个就是修改这个宽度

24:42.420 --> 24:43.940
就接管了这个行为

24:43.940 --> 24:46.420
ok 所以这边的话是没办法确定的

24:50.340 --> 24:55.300
上面的三个操作中前面两个

24:56.260 --> 24:58.580
啊 前面两个并没有什么的

24:58.580 --> 25:01.620
并没有被这个rekt

25:02.820 --> 25:05.780
rekt接管 对吧

25:05.780 --> 25:11.140
所以当产生这样的操作时

25:12.580 --> 25:16.820
可以百分百确定是什么

25:16.820 --> 25:21.460
是来自于开发者的操作

25:22.180 --> 25:22.980
对了

25:23.300 --> 25:26.180
但是在操作三中

25:28.180 --> 25:28.900
操作三

25:30.820 --> 25:32.820
操作三中并不能确定

25:33.700 --> 25:36.020
并不能确定该操作

25:37.780 --> 25:42.820
究竟是这个rekt的行为

25:43.540 --> 25:45.620
还是开发者的行为

25:48.030 --> 25:52.350
甚至两者会产生什么

25:52.350 --> 25:53.390
产生冲突

25:54.430 --> 25:56.590
对了rekt那边也在变

25:56.590 --> 25:59.310
然后这个开发者这边也在变

25:59.310 --> 26:01.070
比如我们这边再举个例子嘛

26:01.070 --> 26:02.990
例如我们再举个例子

26:02.990 --> 26:07.150
例如我们再举一个例子

26:07.150 --> 26:09.470
好 这边的话大家看一下这个例子

26:09.470 --> 26:12.030
好吧 这边拿过来

26:12.030 --> 26:16.980
ok 看一下这个例子

26:16.980 --> 26:20.500
这个例子的话这边有两个button

26:20.500 --> 26:24.740
第一个button 第一个button 这边它是有一个这个状态

26:25.460 --> 26:27.620
一开始是q 对不对

26:27.620 --> 26:29.300
好 大家这个的话它是什么呢

26:29.300 --> 26:33.540
这个它是就是切换一日秀的这个这个增加值

26:34.260 --> 26:35.940
对切换增加值

26:35.940 --> 26:36.660
第二个是什么呢

26:36.660 --> 26:37.540
第二个是一个

26:39.300 --> 26:40.100
我看这边啊

26:40.100 --> 26:41.300
这边是通过这个reft

26:41.300 --> 26:42.980
reft是绑在这个p上面的

26:43.940 --> 26:44.900
绑在p上面的

26:44.900 --> 26:45.700
好 这边是什么呢

26:45.700 --> 26:48.900
这边是通过reft.current拿到这个动物元素

26:48.900 --> 26:51.380
拿到动物元素之后再加这边remove

26:51.380 --> 26:54.180
你看这个就是一个典型的reft失控的场景

26:55.300 --> 26:56.740
典型的reft失控的场景

26:56.740 --> 26:57.460
为什么

26:57.460 --> 27:00.500
因为我这个p是否显示

27:01.460 --> 27:04.180
它这边呢就是根据你的这个一日秀

27:04.180 --> 27:04.500
对不对

27:04.500 --> 27:06.260
你如果是q我就显示

27:06.260 --> 27:07.940
如果是force我就不显示

27:07.940 --> 27:10.980
那这个根据一日秀来决定是否显示

27:10.980 --> 27:11.940
这个是什么

27:11.940 --> 27:13.220
是不是这个react的行为

27:14.260 --> 27:14.980
对不对

27:14.980 --> 27:15.860
react的行为

27:15.860 --> 27:19.780
但是你这边这边的话是不是开发者又在手动的控制

27:19.780 --> 27:22.020
你这个元素是否显示

27:22.020 --> 27:23.620
是不是两者就冲突了

27:24.580 --> 27:24.900
对不对

27:25.780 --> 27:26.900
在上面的代码中

27:29.710 --> 27:37.870
上面的代码就是一个典型的reft失控的案例

27:39.470 --> 27:42.030
上面的这个第一个按钮

27:43.150 --> 27:46.030
第一个按钮通过什么呢

27:46.030 --> 27:51.470
通过一日秀来控制这个p

27:52.110 --> 27:52.910
是否显示

27:55.150 --> 27:56.910
这是react的行为

27:58.430 --> 27:59.070
对不对

27:59.070 --> 27:59.950
那第二个按钮

28:00.590 --> 28:03.310
第二个按钮通过什么呢

28:03.310 --> 28:07.870
通过这个reft直接拿到了p的

28:08.510 --> 28:09.230
是不是动不对象

28:10.350 --> 28:13.310
然后进行这个显引操作

28:15.660 --> 28:17.500
显引操作

28:18.940 --> 28:21.100
这个两者会产生冲突啊

28:21.100 --> 28:21.820
对不对

28:21.820 --> 28:25.500
两者会产生冲突

28:26.380 --> 28:28.540
上面的两个按钮

28:29.820 --> 28:32.540
先点击任意一个

28:33.980 --> 28:38.060
然后再点击另外一个

28:38.620 --> 28:39.260
就会什么呢

28:39.260 --> 28:39.820
就会爆错

28:41.500 --> 28:42.140
对吧

28:42.140 --> 28:44.780
比如说我先这个点击第一个按钮

28:45.260 --> 28:46.300
点击第一个按钮的话

28:46.300 --> 28:48.620
它这边这个p就已经隐藏了

28:48.620 --> 28:49.020
对不对

28:49.020 --> 28:50.060
你把这个设置成forced

28:50.060 --> 28:50.860
它就已经隐藏了

28:50.860 --> 28:51.980
那我再按第二个

28:51.980 --> 28:53.180
再按第二个的话

28:53.180 --> 28:54.860
你这边这个reft它找不到

28:54.860 --> 28:55.660
这爆错

28:55.740 --> 28:57.020
或者我先点第二个按钮

28:57.660 --> 28:59.020
就已经就先把它删除了

28:59.020 --> 29:00.140
再点第一个

29:00.140 --> 29:00.860
它也会爆错

29:01.420 --> 29:01.900
对不对

29:01.900 --> 29:04.140
这个其实就是这个reft的失控

29:04.140 --> 29:04.860
所造成的

29:05.740 --> 29:07.260
所以我们在这个开发的时候

29:07.260 --> 29:10.140
我们要尽量的避免这种reft的失控

29:10.940 --> 29:11.660
明白吧

29:11.660 --> 29:12.140
要避免

29:13.660 --> 29:17.180
那这个reft的失控如何去避免了

29:17.180 --> 29:19.180
那我们这边看下一个

29:19.180 --> 29:22.060
就是关于reft失控的防雨制

29:22.700 --> 29:23.020
OK

29:23.660 --> 29:23.900
好

29:23.900 --> 29:25.020
我们这边回顾一下

29:25.020 --> 29:26.540
这个reft它失控的本质

29:28.660 --> 29:30.820
reft失控的本质

29:31.380 --> 29:32.100
来回顾一下

29:32.660 --> 29:33.540
刚才讲了reft

29:33.540 --> 29:34.500
这个reft的失控

29:34.500 --> 29:35.220
本质是什么

29:35.860 --> 29:38.420
本质是不是由于开发者

29:38.420 --> 29:40.100
通过reft操作了这个洞

29:40.740 --> 29:41.540
对不对

29:41.540 --> 29:49.060
由于开发者通过reft操作了洞

29:50.020 --> 29:52.020
而这一行为

29:52.980 --> 29:55.460
本来应该是什么呢

29:55.540 --> 30:02.420
是由这个reft来进行这个接管的

30:03.300 --> 30:03.780
对不对

30:03.780 --> 30:06.340
然后两者之间

30:08.340 --> 30:15.220
两者之间发生了冲突而导致的

30:16.260 --> 30:16.820
因此的话

30:16.820 --> 30:18.660
我们可以从下面两个方面

30:18.660 --> 30:20.100
来进行这个防制

30:21.380 --> 30:22.980
因此我们可以

30:23.780 --> 30:30.100
从下面两个方面来进行这个防

30:32.180 --> 30:32.580
防制

30:33.620 --> 30:34.340
第一个是什么呢

30:34.340 --> 30:35.060
第一个就是防

30:38.880 --> 30:39.680
第一个就是防

30:40.400 --> 30:41.440
怎么防呢

30:41.440 --> 30:44.560
控制reft它失控的这个范围

30:45.920 --> 30:51.120
控制reft失控的这个影响范围

30:53.740 --> 30:55.580
影响范围

30:55.740 --> 31:01.660
然后使这个reft的这个失控更加容易

31:03.020 --> 31:05.020
更加容易被定位

31:05.820 --> 31:07.500
你想它两者冲突的时候

31:07.500 --> 31:09.100
其实最大的问题是什么

31:09.100 --> 31:11.260
最大的问题就是我们这个不能确定

31:11.260 --> 31:13.100
究竟是reft的行为

31:13.100 --> 31:15.660
还是这个开发者的这个行为

31:15.660 --> 31:16.460
我们是不是要去找

31:17.180 --> 31:17.820
对不对

31:17.820 --> 31:19.500
那我们这边防的话主要就是

31:20.300 --> 31:22.060
让它这个reft失控

31:22.060 --> 31:23.900
能够更加容易的被定位

31:23.980 --> 31:25.340
我们能够一下子找到

31:25.340 --> 31:27.900
究竟是哪个位置的问题

31:28.620 --> 31:30.300
第二个的话就是字

31:32.720 --> 31:33.600
怎么字呢

31:33.600 --> 31:37.680
这边就是从reft引用的这个数据结构入手

31:39.360 --> 31:46.160
从reft引用的数据结构入手

31:46.160 --> 31:46.960
然后尽力

31:48.960 --> 31:53.120
避免可能引起的失控操作

31:54.080 --> 31:57.120
好来我们一个一个来看

31:57.120 --> 31:59.200
首先我们来看这个关于这个防

32:01.280 --> 32:02.000
先看防

32:02.800 --> 32:04.080
然后一会再来看字

32:07.600 --> 32:08.960
好一个一个来

32:10.880 --> 32:12.080
好防的话

32:12.080 --> 32:14.640
我们之前是不是讲过这个高階组建

32:15.200 --> 32:15.600
对不对

32:17.280 --> 32:18.400
再上一张

32:19.120 --> 32:20.800
我们介绍过

32:21.680 --> 32:22.480
高階组建

32:25.300 --> 32:28.450
高階组建

32:29.170 --> 32:31.090
那这个高階组建内部的话

32:31.090 --> 32:34.050
它是无法直接将这个reft指向多目的

32:34.050 --> 32:34.930
大家还记不记得

32:36.690 --> 32:43.650
在高階组建内部是无法将什么呢

32:43.650 --> 32:48.690
将这个reft直接指向多目的

32:49.250 --> 32:50.130
让我们需要什么

32:50.130 --> 32:52.130
我们是不是需要这个进行reft转发

32:53.090 --> 32:57.570
我们需要进行reft的转发

32:58.370 --> 32:58.690
对不对

32:59.170 --> 33:00.610
那回顾一下

33:00.610 --> 33:02.770
就是我们之前转发用什么来转发

33:02.770 --> 33:05.810
这个通过这个它有个这个forwardreft API

33:05.810 --> 33:06.530
对不对

33:06.530 --> 33:16.770
可以通过这个forwardreft API进行一个reft的转发

33:17.410 --> 33:20.530
那你这个进行reft转发的这个操作

33:20.530 --> 33:23.810
实际上就将这个reft失控的这个范围

33:23.810 --> 33:26.290
控制在了这个单个组建内

33:26.450 --> 33:27.010
ok

33:27.010 --> 33:28.850
不会出现什么呢

33:28.850 --> 33:32.210
不会出现这个跨越成绩

33:32.210 --> 33:39.330
实际上就将这个转发的这个操作

33:39.330 --> 33:48.140
实际上就将就将reft失控的这个范围

33:48.940 --> 33:55.010
控制在了这个单个组建内

33:55.010 --> 33:55.410
ok

33:55.410 --> 33:57.010
不会出现什么呢

33:57.010 --> 33:59.410
不会出现这个跨越成绩

34:00.370 --> 34:04.850
跨越就是跨越组建的这个reft失控

34:04.850 --> 34:08.220
给了没有

34:08.220 --> 34:13.200
也就是说你用了这个forwardreft

34:13.200 --> 34:15.760
你手动在进行这个reft转发

34:15.760 --> 34:19.440
那你这边就会针对你的这个reft更加的清晰

34:19.440 --> 34:20.720
对不对

34:20.720 --> 34:24.240
所以说你这边就即便发生了这个reft失控

34:24.240 --> 34:26.480
因为是你手动转发的这个reft

34:26.480 --> 34:30.240
所以你能够更加容易的进行这个错误的这个定位

34:30.240 --> 34:30.960
ok

34:31.520 --> 34:40.480
因为是手动手动的进行reft的转发

34:40.480 --> 34:41.200
所以

34:43.200 --> 34:48.480
所以发生这个reft这个失控的时候

34:48.480 --> 34:50.080
控的时候

34:50.080 --> 34:59.120
能够更加容易的更加容易的进行错误的定位

34:59.120 --> 35:00.560
对吧

35:00.720 --> 35:02.720
因为是你手动的通过这个forward的

35:02.720 --> 35:05.040
再进行转发这个reft

35:05.040 --> 35:05.920
对不对

35:05.920 --> 35:06.640
好

35:06.640 --> 35:08.720
然后接下来我们来看一下这个字

35:08.720 --> 35:10.560
字的话主要体现在什么呢

35:10.560 --> 35:13.680
我们之前的话是不是有讲过这个use

35:13.680 --> 35:16.800
这个imperative handle这个户口

35:16.800 --> 35:17.200
对吧

35:17.200 --> 35:19.120
这个也是之前介绍过的

35:19.120 --> 35:24.560
之前我们介绍过这个use

35:24.560 --> 35:27.120
imperative

35:29.040 --> 35:30.080
imperative

35:30.640 --> 35:32.160
handle

35:32.160 --> 35:33.600
这个户口

35:33.600 --> 35:34.000
啊

35:34.000 --> 35:35.120
那他可以干嘛

35:35.120 --> 35:38.000
他可以在使用reft的时候向副主键

35:38.000 --> 35:41.280
是传递自定义引用者

35:41.280 --> 35:42.000
对吧

35:42.000 --> 35:47.600
他可以在使用这个reft时

35:49.440 --> 35:50.800
向这个副主键

35:53.010 --> 35:54.290
向副主键

35:54.290 --> 35:55.090
然后传递

35:57.090 --> 35:59.730
传递自定义的这个引用者

36:02.910 --> 36:04.750
比如说我们这边举个例子

36:04.750 --> 36:09.900
比较这边有这么一段代码

36:09.900 --> 36:10.460
比较这边

36:11.580 --> 36:13.340
那这边呢就是use

36:13.340 --> 36:14.940
imperative handle

36:14.940 --> 36:16.460
那么在上面的代码里面的话

36:16.460 --> 36:16.940
我们这边

36:18.220 --> 36:19.100
我们通过什么呢

36:19.100 --> 36:20.940
通过useimperative handle

36:20.940 --> 36:22.540
是不是去处理这个reft

36:23.340 --> 36:23.820
对不对

36:23.820 --> 36:24.460
那这里的话

36:24.460 --> 36:26.300
你就可以人为的移除

36:26.300 --> 36:29.340
可能造成这个reft失控的属性或者这个方法

36:30.380 --> 36:31.180
你外侧的话

36:31.180 --> 36:33.180
你通过这个current只能拿到什么

36:33.260 --> 36:35.420
是不是只能拿到这个东西

36:36.140 --> 36:36.460
对不对

36:37.580 --> 36:37.980
外部

36:39.660 --> 36:40.700
在上面的代码中

36:42.620 --> 36:43.100
代码

36:44.140 --> 36:45.180
代码中

36:45.180 --> 36:46.700
我们通过什么呢

36:46.700 --> 36:47.340
通过这个

36:49.490 --> 36:52.210
通过这个useimperative handle

36:52.850 --> 36:54.370
来定制了

36:56.290 --> 36:59.410
定制了这个reft所引用的内容

37:02.460 --> 37:03.180
对吧

37:03.180 --> 37:04.780
那么在外部

37:05.740 --> 37:08.060
在外部这个开发者

37:08.860 --> 37:10.540
通过这个reft

37:11.580 --> 37:12.860
只能拿到什么

37:12.860 --> 37:14.460
只能拿到

37:15.100 --> 37:16.060
是不是只能拿到这个

37:16.700 --> 37:17.340
对不对

37:17.340 --> 37:19.180
只能拿到这么一个对象

37:22.940 --> 37:23.900
只能拿到这个

37:27.330 --> 37:28.130
对不对

37:28.130 --> 37:30.770
从而的话也是避免了这个开发者

37:30.770 --> 37:32.050
获取了这个dorm之后

37:32.690 --> 37:34.290
然后执行这个一些

37:34.290 --> 37:35.890
会失控的一些这个操作

37:36.690 --> 37:37.730
这个呢就是关于这个

37:38.930 --> 37:40.450
reft失控的防核制

37:41.010 --> 37:41.650
但这个的话

37:41.650 --> 37:43.010
其实更多的话

37:43.010 --> 37:44.690
还是就是你手动的

37:46.050 --> 37:46.770
这个怎么说呢

37:46.770 --> 37:50.210
就是从一定程度上去起到一些效果

37:51.090 --> 37:52.850
你尽可能的还是就是

37:52.850 --> 37:55.250
比如应该有这个reft接管的操作

37:55.250 --> 37:57.010
就是还是应该交给这个reft

37:57.490 --> 38:00.290
就尽量避免这个dorm的操作

38:01.410 --> 38:02.050
对吧

38:02.050 --> 38:05.330
就这个操作本来是这个reft这个接管的

38:05.330 --> 38:08.530
那你就要让这个reft来进行操作

38:08.530 --> 38:09.650
你不要再像以前一样

38:09.970 --> 38:10.850
获取这个dorm

38:10.850 --> 38:13.330
再来手动的这个进行操作

38:13.330 --> 38:13.970
除非是什么

38:13.970 --> 38:15.570
除非是他这个行为

38:15.570 --> 38:17.090
这个reft他没有接管

38:18.290 --> 38:19.570
除非是reft没有接管

38:20.130 --> 38:21.250
这边的这个防核制

38:21.250 --> 38:24.530
其实只是起到一定程度上的这个效果

38:25.250 --> 38:25.570
对不对

38:27.570 --> 38:28.210
好最后的话

38:28.210 --> 38:30.210
我们来看一下这个整体解答

38:35.310 --> 38:37.550
UZRef是干什么的

38:37.550 --> 38:39.870
它的这个工作流程是怎么样的

38:39.870 --> 38:41.790
什么叫Ref的这个失控

38:42.510 --> 38:44.110
那你这边的话听了这节课之后

38:44.110 --> 38:45.790
然后上面几个问题

38:45.790 --> 38:47.390
什么都应该能够回答了

38:48.270 --> 38:49.070
对不对

38:49.070 --> 38:51.950
好我这边的话把这个参考单把他过来

38:57.580 --> 38:57.820
ok

38:58.620 --> 39:00.140
UZRef是干什么的

39:00.140 --> 39:02.780
它的主要作用就是创建这个reft

39:03.580 --> 39:07.020
然后这边可以保存一个对dorm元素的这个应用

39:08.460 --> 39:10.780
那你目前的话这个函数组件是用什么呢

39:10.780 --> 39:13.740
是用这个UZRef来创建这个reft

39:13.740 --> 39:15.260
创建出来的是什么

39:15.420 --> 39:17.340
所以创建出来就是这么一个对象

39:18.300 --> 39:18.940
对不对

39:18.940 --> 39:21.020
然后回到这个对象的话会保存在什么

39:21.020 --> 39:24.460
会保存在这个hook对象的这个memo的state

39:27.580 --> 39:29.660
好整个这个reft的工作流程

39:30.460 --> 39:35.980
它这边的话是和reft的这个工作流程是对应上的

39:36.540 --> 39:40.060
reft的工作流程分为render阶段和commit阶段

39:40.060 --> 39:41.500
所以这边的话在render阶段

39:42.780 --> 39:43.820
reft会做什么呢

39:43.900 --> 39:45.180
它会做一个标记

39:45.820 --> 39:46.460
对吧

39:46.460 --> 39:47.980
然后在commit阶段

39:47.980 --> 39:50.300
commit阶段它会根据你的这个标记

39:50.300 --> 39:52.380
是否执行这个相关的这个操作

39:52.940 --> 39:53.420
对不对

39:53.420 --> 39:54.620
比如你更新阶段

39:54.620 --> 39:57.020
更新阶段它这边reft有变化

39:57.020 --> 39:58.860
那你这边的话在commit阶段

39:58.860 --> 40:01.660
它会去移除啊首先detach

40:01.660 --> 40:03.660
移除这个joldreft

40:03.660 --> 40:05.260
大家这边attach

40:05.260 --> 40:07.100
是不是添加这个新的reft

40:08.460 --> 40:08.780
对不对

40:09.420 --> 40:11.180
好什么叫做reft的失控

40:11.180 --> 40:12.540
所谓reft的失控啊

40:12.620 --> 40:15.580
就是本质由于这个开发者通过reft

40:15.580 --> 40:17.020
操作了这个动作

40:17.020 --> 40:17.980
而这个行为的话

40:17.980 --> 40:21.340
应该是由这个reft来接管的

40:21.340 --> 40:22.300
两者干嘛

40:22.300 --> 40:24.060
两者发生了这个冲突

40:25.020 --> 40:25.340
对不对

40:26.060 --> 40:29.500
好那reft失控的防治主要体现在两个方面

40:29.500 --> 40:30.460
一个是防

40:30.460 --> 40:31.100
一个是字

40:31.740 --> 40:33.580
但是你要注意就像我刚才所说的

40:33.580 --> 40:34.940
这个的话只是就是

40:34.940 --> 40:37.020
无论是防也好还是制也好

40:37.020 --> 40:39.420
是不是就是一定程度上

40:39.420 --> 40:42.140
所以解决了这个失控的问题

40:42.220 --> 40:42.860
对不对

40:42.860 --> 40:45.020
你真真真正要想解决这个失控

40:45.020 --> 40:46.700
实际上还是应该是吗

40:46.700 --> 40:48.540
是不是就是尽量的就是

40:48.540 --> 40:51.180
只要这个行为reft它接管了的

40:51.180 --> 40:53.580
那你就应该让这个reft去负责

40:54.460 --> 40:56.940
而不是手动获取了这个动作来进行操作

40:57.820 --> 40:58.300
喵喵

40:58.940 --> 40:59.180
OK

41:00.300 --> 41:01.980
好这是关于这个

41:01.980 --> 41:03.020
usereft

41:03.020 --> 41:06.060
给大家讲了这么一些东西

41:06.060 --> 41:08.220
大家下厨了可以自己再看一下

41:08.780 --> 41:09.180
好吧

41:09.820 --> 41:11.660
好这期课的话就到这里

41:11.660 --> 41:12.220
再见

