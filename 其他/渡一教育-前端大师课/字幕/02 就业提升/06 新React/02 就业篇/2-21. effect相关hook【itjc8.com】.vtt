WEBVTT

00:00.000 --> 00:04.700
OK 这节课的话我们来看一下Effect 相关的这个户口

00:05.200 --> 00:13.000
好 这边的话有道面试题 让你说一说UseEffect和这个UseNameOutEffect这个区别

00:14.200 --> 00:18.600
那这个的话都是和这个Effect 副作用相关的

00:19.200 --> 00:25.200
所以我们这节课的话我们就来看一下整个react中 它这些就是和Effect相关的一些户口

00:26.200 --> 00:32.600
好 这边在这个react中 它定义了这个就是用于这个副作用的这种音变量的这种户口

00:33.200 --> 00:42.770
一共的话有三个 在react中用于定义这个有副作用

00:44.370 --> 00:50.970
有副作用的这个音变量的这个户口 有三个

00:51.970 --> 00:59.770
哪三个呢 首先第一个就是我们熟悉的UseEffect 对吧 好这个的话它的回调函数

01:00.770 --> 01:04.170
回调函数会在这个commit阶段

01:05.270 --> 01:08.570
然后完成后一步执行

01:10.570 --> 01:20.670
怎么样 所以它是不会注射这个试图渲染的 所以它不会注射这个试图渲染

01:24.130 --> 01:28.130
好 接下来的话是UseNailedEffect

01:29.530 --> 01:31.530
好 这个的话它这个回调函数

01:33.030 --> 01:40.030
回调函数会在什么呢 会在这个commit 会在commit阶段的这个nailed

01:41.430 --> 01:44.830
nailed指阶段 同步执行

01:45.630 --> 01:50.230
我们之前讲这个commit的时候 commit里面是不是有一个这个nailed阶段

01:50.830 --> 01:57.430
对不对 它会同步执行 而非一步 注意不是一步 上面这个它是一步 它这个的话它是同步

01:58.030 --> 02:00.030
说它一般用于什么呢 一般用于

02:02.130 --> 02:07.530
一般用于这个执行这个dome相关的操作

02:09.330 --> 02:12.030
好 除了这两个以外的话 它还有一个新增的

02:13.030 --> 02:14.030
叫做Insertion

02:15.430 --> 02:24.230
InsertionEffect 这个的话我们之前没有讲过 对不对 这个没讲过 这个的话是rect18新推出的

02:25.230 --> 02:32.240
它这个回调函数 回调函数会在什么呢 也是在commit阶段

02:33.840 --> 02:40.940
它会在commit阶段的什么呢 Mutation指阶段 然后同步执行

02:41.940 --> 02:53.540
ok 它和这个UserEffect UserNailedEffect区别在于 就是你UserInsertionEffect它执行的时候 它是没办法访问这个dome的引用的

02:55.240 --> 03:09.560
与这个UserNailedEffectUserNailedEffect的这个区别在于什么呢 在于就是使用

03:10.560 --> 03:20.560
就是执行的时候 执行的时候无法访问对这个dome的引用

03:21.560 --> 03:27.560
ok 然后这个hook的话它是专门啊 这个hook是

03:28.560 --> 03:42.560
专门为这个css然后injs这个cool 然后插入这个全局这个style而设计的

03:43.560 --> 03:51.560
style元素而设计的 就是你这边呢 你如果就是要做一些cool 比如cssinjs要做这些cool

03:52.560 --> 04:01.560
那么可能会设计到使用这个Effect 平时的话一般我们使用的更多的就是UserEffect或者UserNailedEffect

04:02.560 --> 04:10.560
这两个 ok 好 那有这么三个就是和副作用相关的这个Effect 好 那接下来的话我们来看一下什么呢

04:11.560 --> 04:16.560
我们从两个方面来看 首先第一个就是关于这个Effect它的一个数据的结构

04:16.560 --> 04:23.000
ok 好 第二个的话就是关于它的一个工作流程

04:24.000 --> 04:31.000
从这两个方面来看 好对于这三个 对于这三个这个Effect相关的hook

04:32.000 --> 04:36.000
他们的这个memoState 他采用的是同一套数据结构

04:37.000 --> 04:44.000
对于这三个这个Effect相关的hook

04:45.000 --> 04:51.000
然后hook.memoState

04:52.000 --> 04:58.000
然后共同使用同一套这个数据结构

05:00.000 --> 05:07.530
ok 好 他这边存的是什么呢 存的是这个 存的是这样子的一个对象

05:08.530 --> 05:11.530
可不可以啊 这个对象上面它有这个tug

05:12.530 --> 05:19.530
tug用来区分你是哪种Effect内心 那既然有Effect的回调函数 销毁函数 依赖项

05:20.530 --> 05:25.530
以及就是下一个Effect 注意Effect会单独形成一个环状链表

05:26.530 --> 05:29.530
这个我们一会再说 他单独会形成一个链表 ok

05:30.530 --> 05:33.530
好 这边我们一点点来看首先是关于这个tug

05:33.530 --> 05:37.350
首先是关于这个tug

05:38.350 --> 05:40.350
tug是干嘛的呢 tug的话是用来区分

05:43.350 --> 05:46.350
用来区分Effect的这个内心

05:47.350 --> 05:50.350
然后他这边对应了只有这个passive,nailt和insertion

05:51.350 --> 05:54.350
他对应了什么意思呢 你如果是passive

05:56.790 --> 05:59.790
说明你是什么呢 说明你是这个use effect

06:00.790 --> 06:02.790
你如果是这个nailt

06:05.490 --> 06:10.490
说明你这边是这个你的互可内心是这个use layout effect

06:11.490 --> 06:12.490
好 如果你是insertion

06:14.490 --> 06:18.490
那这边对应的就是这个use insertion effect

06:19.490 --> 06:20.490
首先他这边有个tug

06:21.490 --> 06:27.490
tug完了之后然后接下来这个create和这个destroy

06:28.490 --> 06:31.490
他分别指带什么的 分别指带

06:31.490 --> 06:36.490
指带Effect的这个回调函数

06:37.490 --> 06:41.490
以及这个Effect销毁函数

06:43.490 --> 06:46.490
ok 比如举个例子啊 比如你这边我们经常这样写

06:47.490 --> 06:50.490
Effect对吧 然后里面的话是一个函数

06:51.490 --> 06:53.490
函数里面的键是不是就是你执行的语诀

06:54.490 --> 06:55.490
对不对 那这个函数那就是你的什么呢

06:56.490 --> 06:57.490
这个函数就是你的这个create

06:57.490 --> 07:00.490
这个就是你的create

07:01.490 --> 07:02.490
好 然后既然你这边让你可以干嘛

07:03.490 --> 07:04.490
你是不是可以返回一个函数啊

07:05.490 --> 07:07.490
对不对 这个函数我们经常说它是销毁函数

07:08.490 --> 07:12.490
对不对 它会在下一次 下一次执行副作用之前来执行

07:13.490 --> 07:15.490
所以这个的话就是你的destroy

07:17.860 --> 07:19.860
create和destroy 这两个

07:20.860 --> 07:22.860
好 然后既然这个deep是依赖下

07:23.860 --> 07:24.860
这个就不多说了

07:25.860 --> 07:26.860
好 关键说一下这个next

07:26.860 --> 07:29.300
next是什么

07:30.300 --> 07:31.300
next的字段的话

07:32.300 --> 07:39.300
它用于当前你这个函数组件的其他Effect形成还状列表

07:40.300 --> 07:41.300
ok next的字段

07:42.300 --> 07:45.300
你会发现这个react它特别喜欢用列表

07:46.300 --> 07:47.300
它里面很多地方都在用列表

07:48.300 --> 07:49.300
好 这个字段

07:50.300 --> 07:56.300
会与什么呢 会与当前的函数组件的这个其他

07:58.300 --> 08:03.300
Effect形成什么呢 形成还状列表

08:04.300 --> 08:07.300
然后连接的方式它是一个单向还状列表

08:08.300 --> 08:15.810
连接的方式是一个单向还向列表

08:16.810 --> 08:18.810
还状 还状列表

08:19.810 --> 08:20.810
ok 比如举个例子

08:21.810 --> 08:22.810
比如说我们现在的话

08:22.810 --> 08:23.810
我们在代码里面我们这样子来写

08:24.810 --> 08:25.810
比如我们这边有个方形

08:26.810 --> 08:27.810
方形app

08:28.810 --> 08:29.810
好 然后接下来这边

08:30.810 --> 08:33.810
这边的话你use effect

08:34.810 --> 08:35.810
首先这边有个副作用

08:37.810 --> 08:40.810
这边是console.nog1

08:41.810 --> 08:44.810
好 然后回头的话你这边有一个const

08:45.810 --> 08:46.810
这边有一个num1

08:47.810 --> 08:48.810
set num1

08:49.810 --> 08:50.810
等于一个use state

08:51.810 --> 08:52.810
好 这边是0

08:53.810 --> 08:55.810
好 然后下面再来一个

08:58.820 --> 08:59.820
这边是2

09:00.820 --> 09:01.820
2 初始字也是0

09:02.820 --> 09:04.820
好 然后下面又是一个use effect

09:07.820 --> 09:08.820
这边打印这个2

09:09.820 --> 09:10.820
好 然后下面的话再来一个

09:11.820 --> 09:12.820
这个打印3

09:14.820 --> 09:16.820
ok 好 那你看我整个这个

09:16.820 --> 09:17.820
后面还有这个return

09:18.820 --> 09:19.820
return一段GSX

09:20.820 --> 09:21.820
我们就随便写着嘛

09:22.820 --> 09:25.820
比较一个DIV比较一个Hello

09:26.820 --> 09:28.820
ok 把这边改成GSX

09:29.820 --> 09:31.820
好 那现在的话这边有这么一个组件

09:32.820 --> 09:33.820
这个组件里面现在就有几个

09:34.820 --> 09:36.820
是不是就一个 两个 三个 四个 五个

09:37.820 --> 09:38.820
是不是用到了五个hook

09:39.820 --> 09:40.820
这五个hook的话他会干嘛

09:41.820 --> 09:42.820
是不是串成一个练表

09:43.820 --> 09:44.820
对不对 这我们之前说过的

09:45.820 --> 09:47.820
好 然后接下来你看他有几个effect

09:48.820 --> 09:49.820
有几个副作用

09:50.820 --> 09:52.820
这边是不是一个 两个 三个

09:53.820 --> 09:54.820
对不对 好 那么这些副作用

09:55.820 --> 09:56.820
单独什么呢

09:57.820 --> 09:59.820
单独形成一个单向的环状列表

10:00.820 --> 10:02.820
ok 这边呢如下图所示

10:04.820 --> 10:06.820
如下图 就结构啊

10:07.820 --> 10:09.820
结构如下图所示

10:10.820 --> 10:11.820
好 这边呢把这个

10:12.820 --> 10:13.820
图把它拿过来

10:17.420 --> 10:18.420
好 这边大家可以看一下

10:19.420 --> 10:21.420
你看这边首先 hook1 hook2 hook3 hook4 hook5

10:22.420 --> 10:23.420
他们之间通过什么

10:24.420 --> 10:26.420
通过next连接

10:26.420 --> 10:27.420
连接 对不对

10:28.420 --> 10:30.420
好 然后hook1 hook1让它是一个effect

10:31.420 --> 10:34.420
所以hook1的话它这个memo state存储的是一个effect

10:35.420 --> 10:36.420
好 这边呢也是存储的是一个effect

10:37.420 --> 10:38.420
这effect是什么

10:38.420 --> 10:39.420
effect就是这边我们刚才所说的

10:40.420 --> 10:41.420
这个对象

10:42.420 --> 10:43.420
这个对象 ok

10:44.420 --> 10:45.420
好 然后接下来的话

10:45.420 --> 10:46.420
这个effect对象它有个next属性

10:47.420 --> 10:49.420
next属性是不是只想下一个effect

10:50.420 --> 10:51.420
对不对 然后加这个的话

10:52.420 --> 10:54.420
next又只想下一个effect

10:54.420 --> 10:56.420
好 然后接下来这边环状

10:57.420 --> 10:59.420
连过来 对不对

11:00.420 --> 11:01.420
环状连过来

11:01.420 --> 11:02.420
它整体的这个结构

11:02.420 --> 11:03.420
是这个样子的

11:04.420 --> 11:05.420
可不可以啊

11:05.420 --> 11:07.420
我们先把这个整体的它的这个数据结构

11:08.420 --> 11:09.420
给大家说清楚

11:10.420 --> 11:11.420
好 这是关于这个effect

11:12.420 --> 11:13.420
它的一个这个结构

11:14.420 --> 11:15.420
它这边里面的每一个

11:16.420 --> 11:17.420
就你这个每一个hook

11:17.420 --> 11:19.420
它的这个memo state

11:20.420 --> 11:21.420
它存储的是这么一个对象

11:22.420 --> 11:23.420
这么一个对象

11:24.420 --> 11:25.420
这个对象里面

11:25.420 --> 11:26.420
然后加这个next

11:26.420 --> 11:27.420
会指向什么呢

11:27.420 --> 11:29.420
会指向下一个effect

11:30.420 --> 11:31.420
就指向它嘛

11:31.420 --> 11:33.420
对 会指向下一个effect

11:33.420 --> 11:35.420
它的next又会指向下一个effect

11:37.420 --> 11:39.420
好 这是关于数据结构

11:39.420 --> 11:40.420
好 然后接下来

11:40.420 --> 11:41.420
我们来看一下

11:41.420 --> 11:43.420
它的这个工作流程

11:43.420 --> 11:45.420
那整个这个工作流程的话

11:45.420 --> 11:47.420
其实可以分成三个阶段

11:48.420 --> 11:51.420
整个工作流程

11:51.420 --> 11:53.420
可以分为什么呢

11:53.420 --> 11:55.420
可以分为三个阶段

11:56.420 --> 11:57.420
哪三个阶段呢

11:57.420 --> 11:59.420
首先第一个是生命阶段

12:00.420 --> 12:01.420
好 第二个

12:01.420 --> 12:03.420
第二个是调度阶段

12:03.420 --> 12:05.420
你注意调度阶段的话

12:05.420 --> 12:08.420
是这个UserEffect独有的

12:09.420 --> 12:11.420
为什么是UserEffect独有的

12:12.420 --> 12:13.420
因为只有它是异步的

12:14.420 --> 12:15.420
另外两个是不是同步的

12:16.420 --> 12:17.420
同步的话

12:17.420 --> 12:18.420
就这边就不需要调度

12:18.420 --> 12:20.420
它是在这个commit阶段嘛

12:21.420 --> 12:23.420
UserNeyoutEffect和这个

12:23.420 --> 12:25.420
它们是不是都是在这个commit阶段

12:26.420 --> 12:28.420
对了 commit阶段同步执行

12:28.420 --> 12:29.420
所以它不需要调度

12:29.420 --> 12:32.420
而它的话是在commit阶段之后

12:33.420 --> 12:35.420
完成后让异步执行

12:35.420 --> 12:36.420
异步执行的话

12:36.420 --> 12:38.420
它这边就需要一个调度

12:39.420 --> 12:41.420
好 所以这个是UserEffect独有的

12:42.420 --> 12:43.420
好 然后接下来一个

12:43.420 --> 12:45.420
什么呢 接下来一个执行阶段

12:48.110 --> 12:49.110
执行阶段

12:49.110 --> 12:50.110
好 那接下来我们这边

12:50.110 --> 12:51.110
一个一个来看

12:51.110 --> 12:52.110
把这三个

12:52.110 --> 12:53.110
把它过来

12:56.130 --> 13:00.170
一个一个来看

13:00.170 --> 13:01.170
OK

13:01.170 --> 13:02.170
好 来我们这边

13:02.170 --> 13:04.170
我们先来看这个声明阶段

13:04.170 --> 13:05.170
好 声明阶段的话

13:05.170 --> 13:06.170
又可以分为什么呢

13:06.170 --> 13:09.170
又可以分为Mount和Update

13:10.170 --> 13:11.170
对不对

13:11.170 --> 13:12.170
这个我们之前说过了

13:13.170 --> 13:14.170
声明阶段

13:15.170 --> 13:19.170
又可以分为Mount阶段

13:20.170 --> 13:22.170
和这个Update阶段

13:23.170 --> 13:24.170
就不不是阶段

13:24.170 --> 13:25.170
就Mount

13:25.170 --> 13:27.170
Mount和Update

13:27.170 --> 13:28.170
对不对

13:28.170 --> 13:29.170
好 然后接下来

13:29.170 --> 13:30.170
我们这边来看一下

13:30.170 --> 13:31.170
首先Mount

13:32.170 --> 13:33.170
Mount的时候

13:34.170 --> 13:35.170
执行的是

13:36.170 --> 13:38.170
执行的是

13:38.170 --> 13:40.170
这个MountEffect

13:41.170 --> 13:42.170
然后这个

13:43.170 --> 13:44.170
Impair

13:44.170 --> 13:45.170
这个的话就是

13:45.170 --> 13:46.170
implement

13:47.170 --> 13:48.170
实现的那个音笔单词

13:49.170 --> 13:50.170
OK 它执行的是这个

13:51.170 --> 13:53.170
相关代码

13:53.170 --> 13:54.170
代码

13:58.950 --> 13:59.950
好 我们这边把它粘过来

13:59.950 --> 14:01.950
粘过来之后我们看一下

14:02.950 --> 14:03.950
看一下它这边在做什么

14:03.950 --> 14:05.950
首先是不是生成一个Hook对象

14:06.950 --> 14:07.950
对了 生成Hook对象之后

14:07.950 --> 14:09.950
然后加这边看你的这个依赖

14:09.950 --> 14:10.950
这边这个Deep

14:10.950 --> 14:11.950
依赖

14:11.950 --> 14:12.950
依赖是否是Unlify

14:12.950 --> 14:13.950
如果是Unlify

14:13.950 --> 14:14.950
这边就是Low

14:14.950 --> 14:15.950
否则这边就是一个依赖

14:15.950 --> 14:16.950
好 然后接下来这边

14:16.950 --> 14:18.950
这边那是修改

14:18.950 --> 14:20.950
当前Fiber的这个Flag

14:20.950 --> 14:22.950
把Flag修改了

14:22.950 --> 14:23.950
好 然后接下来

14:23.950 --> 14:26.950
这边执行了一个叫做PushEffect

14:26.950 --> 14:27.950
这PushEffect

14:27.950 --> 14:28.950
你让我这边写的有注释

14:28.950 --> 14:29.950
它是怎么呢

14:29.950 --> 14:31.950
将这个PushEffect

14:31.950 --> 14:33.950
返回的这个环状列表

14:33.950 --> 14:34.950
就整个

14:34.950 --> 14:35.950
这个函数其实主要就是

14:35.950 --> 14:37.950
生成这个环状列表的

14:37.950 --> 14:38.950
就这个

14:38.950 --> 14:40.950
相当于把它推入到环状列表

14:40.950 --> 14:41.950
OK

14:41.950 --> 14:42.950
推入到环状列表之后

14:42.950 --> 14:44.950
然后再复制给这个

14:44.950 --> 14:46.950
Hook点MemoState

14:46.950 --> 14:47.950
这个State

14:47.950 --> 14:48.950
你可以看到这边

14:48.950 --> 14:49.950
这边这个HookMemoState

14:49.950 --> 14:51.950
是不是就指向这边

14:51.950 --> 14:52.950
指向这个环状列表

14:53.950 --> 14:54.950
对不对

14:54.950 --> 14:55.950
无论是哪一个

14:55.950 --> 14:56.950
比如他

14:56.950 --> 14:58.950
他也指向这个环状列表

14:58.950 --> 14:59.950
他是不是也指向这个

14:59.950 --> 15:00.950
环状列表

15:00.950 --> 15:01.950
对不对

15:01.950 --> 15:02.950
这边

15:02.950 --> 15:04.950
在上面的代码中

15:05.950 --> 15:07.950
上面的代码中

15:09.950 --> 15:10.950
首先

15:10.950 --> 15:11.950
干嘛

15:11.950 --> 15:13.950
首先是不是生成

15:13.950 --> 15:14.950
Hook对象

15:14.950 --> 15:15.950
对不对

15:15.950 --> 15:17.950
然后接下来拿到

15:17.950 --> 15:18.950
依赖

15:18.950 --> 15:19.950
拿到依赖之后

15:19.950 --> 15:21.950
然后加这边修改

15:21.950 --> 15:23.950
Fiber的Flack

15:24.950 --> 15:25.950
然后之后

15:25.950 --> 15:29.950
将当前的Hook

15:29.950 --> 15:31.950
将当前的Effect

15:31.950 --> 15:33.950
推入到

15:33.950 --> 15:35.950
推入到环状列表

15:36.950 --> 15:38.950
环状列表

15:38.950 --> 15:39.950
对不对

15:39.950 --> 15:40.950
OK

15:40.950 --> 15:41.950
推入到环状列表之后

15:41.950 --> 15:42.950
然后接下来干嘛

15:42.950 --> 15:43.950
接下来

15:43.950 --> 15:45.950
然后Hook

15:45.950 --> 15:48.950
点MemoState

15:49.950 --> 15:51.950
MemoState

15:51.950 --> 15:53.950
然后指向

15:53.950 --> 15:55.950
改环状列表

15:56.950 --> 15:57.950
你看这边

15:57.950 --> 15:59.950
Mount就做了这个事情

15:59.950 --> 16:00.950
好

16:00.950 --> 16:02.950
然后接下来的话是这个Update

16:02.950 --> 16:06.520
Update

16:06.520 --> 16:08.520
Update的时候

16:08.520 --> 16:09.520
执行的是什么呢

16:09.520 --> 16:11.520
执行的是这个Update

16:11.520 --> 16:13.520
Update

16:13.520 --> 16:16.520
这个Effect

16:16.520 --> 16:18.520
然后这个IMPR

16:19.520 --> 16:25.390
相关代码如像

16:25.390 --> 16:26.390
我这边把它代码

16:26.390 --> 16:27.390
过来

16:33.220 --> 16:34.220
你看一下

16:34.220 --> 16:36.220
这个是Update相关的

16:36.220 --> 16:38.220
我们来看一下Update这边在做什么

16:38.220 --> 16:40.220
首先是不是先拿到之前的Hook

16:40.220 --> 16:41.220
就像拿到什么

16:41.220 --> 16:43.220
是不是拿到新的依赖像

16:43.220 --> 16:44.220
对不对

16:44.220 --> 16:45.220
拿到新的依赖像之后

16:45.220 --> 16:46.220
然后加这边

16:46.220 --> 16:47.220
首先初始化

16:47.220 --> 16:48.220
清除函数

16:48.220 --> 16:49.220
Destroy is on the back

16:49.220 --> 16:50.220
好

16:50.220 --> 16:52.220
然后加这边看你的Current Hook

16:52.220 --> 16:54.220
是否不等于空

16:54.220 --> 16:55.220
不等于空的话

16:55.220 --> 16:56.220
然后加我这边从什么呢

16:56.220 --> 16:58.220
从之前的这个Hook

16:58.220 --> 16:59.220
Memorable

16:59.220 --> 17:00.220
State

17:00.220 --> 17:01.220
拿到什么

17:01.220 --> 17:02.220
拿到之前的这个Effect

17:02.220 --> 17:03.220
这个拿到就是什么

17:03.220 --> 17:06.220
就拿到就是你这边指向的这个

17:06.220 --> 17:07.220
Effect

17:07.220 --> 17:08.220
对不对

17:08.220 --> 17:09.220
从而拿到了什么

17:09.220 --> 17:11.220
从而拿到了整个环状的表

17:11.220 --> 17:12.220
对不对

17:12.220 --> 17:13.220
好

17:13.220 --> 17:14.220
然后拿到之后

17:14.220 --> 17:15.220
然后接下来的话

17:15.220 --> 17:16.220
下一步

17:17.220 --> 17:18.220
下一步的话

17:18.220 --> 17:19.220
这边从这个

17:19.220 --> 17:21.220
这个它其实就是那个Effect对象

17:21.220 --> 17:23.220
通过这个Effect对象

17:23.220 --> 17:24.220
这边

17:24.220 --> 17:26.220
这边这个Destroy

17:26.220 --> 17:27.220
复制给它

17:27.220 --> 17:29.220
这个一会儿是要调用的

17:29.220 --> 17:30.220
好

17:30.220 --> 17:32.220
然后看你的这个依赖像

17:32.220 --> 17:34.220
依赖像是否不为空

17:34.220 --> 17:35.220
不为空之后

17:35.220 --> 17:37.220
然后加两个依赖像

17:37.220 --> 17:39.220
做一个这个比较

17:39.220 --> 17:40.220
做一个比较

17:40.220 --> 17:42.220
如果这边依赖相同

17:42.220 --> 17:43.220
依赖相同的话

17:43.220 --> 17:45.220
是不是就是依赖没有发生变化

17:45.220 --> 17:46.220
对不对

17:46.220 --> 17:47.220
没有发生变化

17:47.220 --> 17:48.220
那这个Effect

17:48.220 --> 17:49.220
是不值钱

17:49.220 --> 17:50.220
是不值钱

17:50.220 --> 17:51.220
对不对

17:51.220 --> 17:52.220
不值钱

17:52.220 --> 17:53.220
那么这边

17:53.220 --> 17:55.220
Effect打上一个这个Target

17:55.220 --> 17:57.220
互可possible的这个Target

17:57.220 --> 17:58.220
ok

17:58.220 --> 17:59.220
好

17:59.220 --> 18:00.220
然后接下来如果

18:00.220 --> 18:03.220
如果这边依赖像发生了变化

18:03.220 --> 18:05.220
发生了变化之后

18:05.220 --> 18:06.220
那接下来这边叫推入什么呢

18:06.220 --> 18:08.220
推入新的Effect

18:08.220 --> 18:09.220
怎么样

18:09.220 --> 18:10.220
通过这个PushEffect

18:10.220 --> 18:13.220
推入这个新的Effect对象

18:13.220 --> 18:15.220
然后加把它存到这个

18:15.220 --> 18:17.220
互可叠Memo的State上面

18:17.220 --> 18:18.220
ok

18:18.220 --> 18:19.220
好

18:19.220 --> 18:20.220
来我们这边来总结一下

18:20.220 --> 18:22.220
在上面的代码中

18:22.220 --> 18:26.600
上面的代码中

18:26.600 --> 18:28.600
首先

18:28.600 --> 18:29.600
从什么

18:29.600 --> 18:31.600
从这个

18:31.600 --> 18:33.600
从它上面

18:33.600 --> 18:35.600
从这个

18:35.600 --> 18:37.600
方法中

18:37.600 --> 18:39.600
拿到

18:39.600 --> 18:40.600
互可对象

18:40.600 --> 18:42.600
拿到互可对象之后

18:42.600 --> 18:43.600
然后接下来的话

18:43.600 --> 18:44.600
这边

18:44.600 --> 18:46.600
这边是拿新的依赖像

18:46.600 --> 18:47.600
这边是这个Destroy

18:47.600 --> 18:48.600
一开始

18:48.600 --> 18:49.600
它的初始只是only buy

18:49.600 --> 18:50.600
这都不管它

18:50.600 --> 18:51.600
好

18:51.600 --> 18:53.600
那再如果这个Current hook

18:53.600 --> 18:55.600
不等于空

18:55.600 --> 18:57.600
这边的话就是

18:57.600 --> 18:59.600
从这个之前

18:59.600 --> 19:01.600
之前你的Effect对象

19:01.600 --> 19:04.600
因为你这边是从Current hook.Memo的State

19:04.600 --> 19:06.600
实际上就是什么

19:06.600 --> 19:07.600
Memo的State

19:07.600 --> 19:08.600
是不是就指向Effect

19:08.600 --> 19:09.600
这Effect是什么

19:09.600 --> 19:11.600
Effect是不是

19:11.600 --> 19:13.600
这样子的一个对象

19:13.600 --> 19:14.600
对不对

19:14.600 --> 19:15.600
从这个对象上面

19:15.600 --> 19:16.600
拿到什么呢

19:16.600 --> 19:18.600
拿到Destroy

19:18.600 --> 19:20.600
拿到你的销毁函数

19:20.600 --> 19:21.600
好

19:21.600 --> 19:22.600
然后接下来这边干嘛

19:22.600 --> 19:24.600
是比较你的这个依赖像

19:24.600 --> 19:25.600
对不对

19:25.600 --> 19:27.600
拿到互可对象

19:27.600 --> 19:28.600
之后

19:28.600 --> 19:30.600
会从

19:30.600 --> 19:32.600
互可点

19:32.600 --> 19:35.600
互可点这个Memo的State

19:37.600 --> 19:38.600
拿到

19:39.600 --> 19:43.600
拿到所存储的Effect

19:43.600 --> 19:44.600
对象

19:44.600 --> 19:45.600
对不对

19:45.600 --> 19:46.600
好

19:46.600 --> 19:48.600
然后会进行

19:48.600 --> 19:50.600
这个前后

19:50.600 --> 19:52.600
依赖像

19:52.600 --> 19:55.600
依赖像

19:55.600 --> 19:57.600
依赖像的这个比较

19:57.600 --> 19:58.600
怎么比较的

19:58.600 --> 19:59.600
采用的是这个

19:59.600 --> 20:00.600
Ahook

20:00.600 --> 20:02.600
Input Equals

20:02.600 --> 20:04.600
之后会

20:04.600 --> 20:06.600
利用

20:06.600 --> 20:08.600
这个方法

20:08.600 --> 20:11.600
进行这个前后依赖像的这个比较

20:11.600 --> 20:12.600
如果依赖相同

20:12.600 --> 20:15.980
依赖它没有变化

20:15.980 --> 20:16.980
如果

20:16.980 --> 20:18.980
依赖相同

20:18.980 --> 20:19.980
那么

20:19.980 --> 20:20.980
就会什么呢

20:20.980 --> 20:23.980
就会在这个Effect

20:23.980 --> 20:24.980
上面

20:24.980 --> 20:25.980
打一个什么呢

20:25.980 --> 20:27.980
打一个Tug

20:27.980 --> 20:28.980
对不对

20:28.980 --> 20:29.980
Tug

20:29.980 --> 20:30.980
好

20:30.980 --> 20:31.980
然后加你这个组件渲染完以后

20:31.980 --> 20:37.700
它就会跳过这个Effect的执行

20:37.700 --> 20:39.700
它就会跳过这个Effect的执行

20:39.700 --> 20:40.700
OK

20:40.700 --> 20:41.700
好

20:41.700 --> 20:42.700
然后接下来这边下面

20:42.700 --> 20:44.700
如果依赖发生了变化

20:44.700 --> 20:45.700
依赖发生了变化

20:45.700 --> 20:46.700
然后它这边就会有个什么

20:46.700 --> 20:48.700
就会有一个flex

20:48.700 --> 20:49.700
就这边对应的fiber

20:49.700 --> 20:52.700
这边就会有一个flex

20:52.700 --> 20:57.700
如果依赖发生了变化

20:57.700 --> 20:58.700
那么

20:58.700 --> 21:02.700
当前的fiber

21:02.700 --> 21:04.700
fiber node

21:04.700 --> 21:06.700
就会有一个什么呢

21:06.700 --> 21:08.700
就会打上一个flex

21:08.700 --> 21:10.700
然后回头

21:10.700 --> 21:14.700
回头在commit阶段

21:14.700 --> 21:17.700
统一执行

21:17.700 --> 21:20.700
统一执行该Effect

21:20.700 --> 21:21.700
OK

21:21.700 --> 21:22.700
好

21:22.700 --> 21:23.700
然后接下来这边还有一步

21:23.700 --> 21:24.700
还有一步的话

21:24.700 --> 21:25.700
这边就是推入什么

21:25.700 --> 21:28.700
所以推入这个新的

21:28.700 --> 21:29.700
这个Effect

21:29.700 --> 21:30.700
对不对

21:30.700 --> 21:35.700
之后会推入新的Effect

21:35.700 --> 21:36.700
到这个

21:36.700 --> 21:38.700
环状列表上面

21:38.700 --> 21:42.160
对不对

21:42.160 --> 21:44.160
这边就是推入新的

21:44.160 --> 21:45.160
OK

21:45.160 --> 21:46.160
这边有这么两个方法

21:46.160 --> 21:48.160
首先一个是关于

21:48.160 --> 21:50.160
这个ar hook inputs

21:50.160 --> 21:51.160
这个equal

21:51.160 --> 21:52.160
我们来看一下

21:52.160 --> 21:56.790
这个ar hook inputs

21:56.790 --> 21:58.790
这个inputs equal

21:58.790 --> 21:59.790
相关

21:59.790 --> 22:03.170
相关代码

22:03.170 --> 22:04.170
无项

22:04.170 --> 22:06.740
OK

22:06.740 --> 22:07.740
它这边呢

22:07.740 --> 22:09.740
采用的是一个钱比较

22:09.740 --> 22:12.740
采用的是一个钱比较

22:12.740 --> 22:13.740
OK

22:13.740 --> 22:15.740
这边通过一个货循环

22:15.740 --> 22:16.740
大家这边比较什么呢

22:16.740 --> 22:17.740
比较它的每一项

22:17.740 --> 22:18.740
看到没有

22:18.740 --> 22:19.740
next

22:19.740 --> 22:20.740
deep's eye

22:20.740 --> 22:21.740
和你的pray of deep's eye

22:21.740 --> 22:22.740
两个进行比较

22:22.740 --> 22:24.740
相同这边就continue

22:24.740 --> 22:25.740
相同就continue

22:25.740 --> 22:27.740
大家有一个不同这边就干嘛

22:27.740 --> 22:28.740
是retro force

22:28.740 --> 22:30.740
如果整个货循环都跑完了

22:30.740 --> 22:32.740
相同那这边就是

22:32.740 --> 22:33.740
q

22:33.740 --> 22:34.740
一个钱比较

22:34.740 --> 22:35.740
OK

22:35.740 --> 22:36.740
另外的话

22:36.740 --> 22:37.740
还有一个方法

22:37.740 --> 22:39.740
还有一个非常重要的方法是什么呢

22:39.740 --> 22:41.740
是这个push effect

22:41.740 --> 22:45.840
我们来写一下

22:45.840 --> 22:47.840
push effect

22:47.840 --> 22:50.840
这边这个ar hook inputs equal

22:50.840 --> 22:52.840
我们这边写一下它的作用

22:52.840 --> 22:54.840
它的作用

22:54.840 --> 22:57.840
它的作用

22:57.840 --> 22:59.840
是比较

22:59.840 --> 23:01.840
两个

23:01.840 --> 23:03.840
依赖

23:03.840 --> 23:06.840
两个依赖向

23:06.840 --> 23:08.840
数组

23:08.840 --> 23:10.840
是否相同

23:10.840 --> 23:11.840
对吧

23:11.840 --> 23:14.840
采用的是钱比较

23:14.840 --> 23:15.840
OK

23:15.840 --> 23:16.840
好

23:16.840 --> 23:17.840
相关代码如下

23:17.840 --> 23:19.840
好这个push effect

23:19.840 --> 23:20.840
push effect是什么

23:20.840 --> 23:21.840
push effect的话

23:21.840 --> 23:23.840
是把当前的这个

23:23.840 --> 23:27.840
就是生成一个effect对象

23:27.840 --> 23:29.840
这个方法的作用

23:29.840 --> 23:31.840
方法的作用

23:31.840 --> 23:36.840
是生成一个effect对象

23:36.840 --> 23:39.840
然后推入到

23:39.840 --> 23:42.840
当前的这个环状

23:42.840 --> 23:44.840
就单向

23:44.840 --> 23:46.840
单向环状

23:46.840 --> 23:48.840
练表里面

23:48.840 --> 23:49.840
对不对

23:49.840 --> 23:50.840
这是它的作用

23:50.840 --> 23:54.840
相关代码如下

23:54.840 --> 23:56.840
好那我们这边来看一下

23:56.840 --> 23:58.840
我把它拿过来

23:58.840 --> 24:05.350
在这边

24:05.350 --> 24:06.350
你看它这边

24:06.350 --> 24:08.350
首先是不是就会创建这么一个effect对象

24:08.350 --> 24:10.350
和我们刚所说的这个

24:10.350 --> 24:11.350
是不是就一样的

24:11.350 --> 24:13.350
在这边

24:13.350 --> 24:14.350
创建这么一个对象

24:14.350 --> 24:15.350
对不对

24:15.350 --> 24:17.350
这个对象就是你这边对应的

24:17.350 --> 24:18.350
那接下来

24:18.350 --> 24:19.350
它要把什么呢

24:19.350 --> 24:21.350
所有的这个effect对象

24:21.350 --> 24:23.350
形成一个环状练表

24:23.350 --> 24:25.350
我们这边来看一下

24:25.350 --> 24:26.350
它这边

24:26.350 --> 24:28.350
这边整个这个代码对应的

24:28.350 --> 24:29.350
就这一块

24:29.350 --> 24:30.350
这一块

24:30.350 --> 24:32.350
如果你这个

24:32.350 --> 24:33.350
component

24:33.350 --> 24:34.350
updataq

24:34.350 --> 24:35.350
如果是空

24:35.350 --> 24:36.350
空的话说明什么呢

24:36.350 --> 24:38.350
说明你当前是

24:38.350 --> 24:40.350
第一个effect

24:40.350 --> 24:42.350
大家这边执行相应的这个步骤

24:42.350 --> 24:43.350
好 else

24:43.350 --> 24:46.350
else的话存在多个effect

24:46.350 --> 24:48.350
你当前就不是第一个

24:48.350 --> 24:50.350
那接下来我们就把你干嘛

24:50.350 --> 24:51.350
这边串联起来

24:51.350 --> 24:52.350
对不对

24:52.350 --> 24:54.350
大家这边通过一些步骤

24:54.350 --> 24:55.350
把它串联起来

24:55.350 --> 24:56.350
串联起来之后

24:56.350 --> 24:59.350
大家这边最终返回这个effect

24:59.350 --> 25:00.350
返回这个effect

25:00.350 --> 25:02.350
然后衡量就对上了

25:02.350 --> 25:03.350
和这就对上了

25:03.350 --> 25:04.350
对不对

25:04.350 --> 25:06.350
你这个hook点这个memo的state

25:06.350 --> 25:08.350
最终对应的只是effect

25:08.350 --> 25:09.350
和这个图

25:09.350 --> 25:10.350
和这个图

25:10.350 --> 25:11.350
也是对上的

25:11.350 --> 25:12.350
对不对

25:12.350 --> 25:13.350
最终对应的是一个effect

25:13.350 --> 25:15.350
这边effect label

25:15.350 --> 25:17.350
effect label又有什么

25:17.350 --> 25:18.350
又有next

25:18.350 --> 25:19.350
next

25:19.350 --> 25:21.350
然后加每一个effect

25:21.350 --> 25:22.350
是不是这样子串起来了

25:22.350 --> 25:23.350
对不对

25:23.350 --> 25:25.350
它整个这个代码

25:25.350 --> 25:28.860
是这样子的

25:28.860 --> 25:29.860
关于这个

25:29.860 --> 25:32.860
至于它这边具体的这个细节

25:32.860 --> 25:33.860
这边你自己看一下

25:33.860 --> 25:34.860
我这边写的有出事

25:34.860 --> 25:35.860
看到没有

25:35.860 --> 25:36.860
首先拿第一个

25:36.860 --> 25:37.860
拿最后一个

25:37.860 --> 25:39.860
然后改它的什么next

25:39.860 --> 25:41.860
这边反正就是和练表

25:41.860 --> 25:43.860
这个操作相关的

25:43.860 --> 25:44.860
好

25:44.860 --> 25:46.860
然后接下来我们继续

25:46.860 --> 25:49.860
这里的话有一个需要注意的地方

25:49.860 --> 25:50.860
怎么呢

25:50.860 --> 25:52.860
就是update的时候

25:52.860 --> 25:54.860
update

25:54.860 --> 25:58.230
update的时候

25:59.230 --> 26:01.230
即使什么呢

26:01.230 --> 26:03.230
即使这个effect

26:03.230 --> 26:04.230
deep

26:04.230 --> 26:07.230
然后没有变化

26:08.230 --> 26:10.230
也会什么呢

26:10.230 --> 26:11.230
也会

26:12.230 --> 26:15.230
创建对应的effect

26:15.230 --> 26:17.230
ok

26:17.230 --> 26:18.230
为什么呢

26:18.230 --> 26:19.230
因为这样子

26:19.230 --> 26:21.230
它才保证这个effect

26:21.230 --> 26:22.230
练表中的effect数量

26:22.230 --> 26:23.230
顺序

26:23.230 --> 26:24.230
它是稳定的

26:24.230 --> 26:26.230
因为这样

26:26.230 --> 26:29.230
才能够保证

26:29.230 --> 26:33.230
这个effect数量

26:33.230 --> 26:34.230
以及什么呢

26:34.230 --> 26:35.230
以及顺序

26:35.230 --> 26:37.230
是稳定的

26:37.230 --> 26:39.990
ok

26:39.990 --> 26:40.990
好

26:40.990 --> 26:41.990
你这边你可以看一下

26:41.990 --> 26:42.990
这里

26:42.990 --> 26:43.990
我这儿拿过来

26:43.990 --> 26:48.200
你可以对比一下

26:48.200 --> 26:49.200
好

26:49.200 --> 26:51.200
上面的话是deep是没有变化的

26:51.200 --> 26:54.200
它这边执行了这个push effect

26:54.200 --> 26:56.200
下面的话是deep是有变化

26:56.200 --> 26:58.200
是不是也执行了这个push effect

26:58.200 --> 26:59.200
只不过这边区别的话

26:59.200 --> 27:00.200
这边的话会有一个什么

27:00.200 --> 27:02.200
会有个这个flag

27:02.200 --> 27:03.200
对了

27:03.200 --> 27:05.200
这边是hook has effect

27:05.200 --> 27:07.200
这边就这里的区别

27:07.200 --> 27:09.200
这个你在这也看得到

27:09.200 --> 27:11.200
在刚才这里

27:11.200 --> 27:13.200
这里的话你如果进这个衣服

27:13.200 --> 27:15.200
依赖像是相同的

27:15.200 --> 27:17.200
它这边执行了这个push effect

27:17.200 --> 27:18.200
对吧

27:18.200 --> 27:19.200
你这边的话下面

27:19.200 --> 27:20.200
下面你如果进到这

27:20.200 --> 27:21.200
进到这的话

27:21.200 --> 27:22.200
这边说明这个依赖不同

27:22.200 --> 27:23.200
不同的话

27:23.200 --> 27:25.200
这边仍然是执行了push effect

27:25.200 --> 27:27.200
这点注意

27:27.200 --> 27:28.200
好

27:28.200 --> 27:30.200
这是关于生命阶段

27:30.200 --> 27:31.200
好

27:31.200 --> 27:32.200
然后接下来我们来看一下

27:32.200 --> 27:34.200
调度阶段

27:34.200 --> 27:35.200
调度阶段

27:35.200 --> 27:36.200
调度阶段的话

27:36.200 --> 27:38.200
这个阶段的话是这个UZ effect

27:38.200 --> 27:39.200
它独有的

27:39.200 --> 27:41.200
因为你这个UZ effect

27:41.200 --> 27:42.200
这个回调函数

27:42.200 --> 27:44.200
它会在commit阶段完成后

27:44.200 --> 27:46.200
异步执行

27:46.200 --> 27:48.200
因此它需要经历这个调度阶段

27:48.200 --> 27:51.220
调度

27:51.220 --> 27:56.620
调度阶段

27:56.620 --> 27:59.620
是这个UZ effect

27:59.620 --> 28:01.620
这个独有的

28:01.620 --> 28:03.620
独有的

28:03.620 --> 28:04.620
因为什么呢

28:04.620 --> 28:10.620
因为UZ effect的这个回调函数

28:10.620 --> 28:12.620
会在什么呢

28:12.620 --> 28:18.620
会在commit阶段这个完成后

28:18.620 --> 28:20.620
然后异步执行

28:20.620 --> 28:31.580
因此需要这个调度阶段

28:31.580 --> 28:35.580
在这个在commit

28:35.580 --> 28:40.580
commit阶段的这个3个指阶段

28:40.580 --> 28:43.580
开始之前

28:43.580 --> 28:44.580
然后会执行什么呢

28:44.580 --> 28:49.860
会执行如下的代码

28:49.860 --> 28:50.860
好

28:50.860 --> 28:57.020
这边把这个代码片段拿过来

28:57.020 --> 28:59.020
这边会执行如下的代码

28:59.020 --> 29:01.020
那既然它的调度在哪个位置呢

29:01.020 --> 29:03.020
调度就在这个位置

29:03.020 --> 29:06.020
你看这边是不是有一个schedule callback

29:06.020 --> 29:08.020
这个一看这个schedule callback

29:08.020 --> 29:09.020
这个就是来自于什么

29:09.020 --> 29:11.020
这个就来自于这个schedule的

29:11.020 --> 29:14.020
它这边就是对应的这个调度

29:14.020 --> 29:15.020
好在调度里面

29:15.020 --> 29:16.020
然后它这边会执行一个什么呢

29:16.020 --> 29:20.020
会执行一个叫做flash passive effects

29:20.020 --> 29:22.020
这个flash passive effects

29:22.020 --> 29:23.020
它会干嘛呢

29:23.020 --> 29:25.020
它会去执行所有的effects

29:25.020 --> 29:29.850
flash passive effects

29:29.850 --> 29:31.850
会去执行

29:31.850 --> 29:42.400
会去执行对应的effects

29:42.400 --> 29:43.400
ok

29:43.400 --> 29:46.400
对应的这个代码

29:46.400 --> 29:52.100
这边

29:52.100 --> 29:53.100
在它内部

29:53.100 --> 29:55.100
内部它就会去执行这些effects

29:55.100 --> 29:57.100
ok

29:57.100 --> 29:58.100
好

29:58.100 --> 30:00.610
另外

30:00.610 --> 30:01.610
另外

30:01.610 --> 30:02.610
由于什么呢

30:02.610 --> 30:04.610
由于这个调度

30:04.610 --> 30:07.610
调度阶段的这个存在

30:07.610 --> 30:08.610
为了什么呢

30:08.610 --> 30:10.610
为了保证

30:10.610 --> 30:13.980
下一次

30:13.980 --> 30:16.980
下一次的这个commit

30:16.980 --> 30:20.980
commit阶段执行前

30:20.980 --> 30:23.980
然后上一次

30:23.980 --> 30:27.980
上一次commit所调度的

30:27.980 --> 30:32.980
所调度的这个user effect

30:32.980 --> 30:34.980
就是都已经执行了

30:34.980 --> 30:39.980
都已经执行执行过了

30:39.980 --> 30:40.980
因此

30:40.980 --> 30:45.980
会在这个commit阶段的这个入口处

30:45.980 --> 30:47.980
入口处

30:47.980 --> 30:49.980
然后也会执行

30:49.980 --> 30:54.980
也会执行这个flash passive effects

30:54.980 --> 30:58.980
而且它这边是一个循环执行

30:58.980 --> 31:02.980
而且是一个循环执行

31:02.980 --> 31:05.980
这边把这个代码片段拿过来

31:05.980 --> 31:11.500
这边

31:11.500 --> 31:12.500
你看

31:12.500 --> 31:14.500
它这边是一个do while

31:14.500 --> 31:15.500
为什么是do while循环

31:15.500 --> 31:17.500
它这边就是要保证什么呢

31:17.500 --> 31:18.500
保证就是你这边

31:18.500 --> 31:22.500
所有的这个effects都执行了

31:22.500 --> 31:25.500
之所以

31:25.500 --> 31:31.190
之所以使用这个do while

31:31.190 --> 31:34.190
使用这个do while循环

31:34.190 --> 31:36.190
就是为了什么呢

31:36.190 --> 31:38.190
为了保证

31:38.190 --> 31:40.190
上一轮

31:40.190 --> 31:42.190
上一轮这个调度的

31:42.190 --> 31:48.720
的这个effect都执行过了

31:48.720 --> 31:49.720
明白吧

31:49.720 --> 31:50.720
OK

31:50.720 --> 31:52.720
这是关于这个调度阶段

31:52.720 --> 31:54.720
就是user effect

31:54.720 --> 31:58.720
它这边会有这么一些对应的这个操作

31:58.720 --> 31:59.720
好

31:59.720 --> 32:00.720
最后最后的话

32:00.720 --> 32:02.720
我们来看一下这个执行阶段

32:02.720 --> 32:04.720
这三个这个effect相关的

32:04.720 --> 32:06.720
这个hook的这个执行阶段

32:06.720 --> 32:09.720
它这边对应了有两个方法

32:09.720 --> 32:10.720
这三个

32:10.720 --> 32:16.720
这个effect相关的这个hook

32:16.720 --> 32:18.720
执行阶段

32:18.720 --> 32:26.120
然后有两个有两个相关的方法

32:26.120 --> 32:28.120
一个是什么呢

32:28.120 --> 32:29.120
一个的话

32:29.120 --> 32:31.120
它这个名字叫做commit hook

32:31.120 --> 32:34.120
effect least amount

32:34.120 --> 32:37.880
一个叫做这个

32:37.880 --> 32:38.880
这个方法是用来干嘛呢

32:38.880 --> 32:42.880
这个方法是用于便利这个effect链表

32:42.880 --> 32:44.880
用于便利

32:44.880 --> 32:46.880
effect链表

32:46.880 --> 32:49.880
然后一次执行什么呢

32:49.880 --> 32:54.880
执行这个effect点destroy

32:54.880 --> 32:55.880
方法

32:55.880 --> 32:56.880
OK

32:56.880 --> 32:59.880
我们这边来看一下这个干嘛片段

32:59.880 --> 33:05.430
干嘛片段的话在这边

33:05.430 --> 33:07.430
主要看这里

33:07.430 --> 33:08.430
主要看这里

33:08.430 --> 33:10.430
这里的话是不是从这个effect

33:10.430 --> 33:16.870
从effect对象上面

33:16.870 --> 33:17.870
拿到什么

33:17.870 --> 33:20.870
拿到什么这个destroy

33:20.870 --> 33:22.870
这个函数

33:22.870 --> 33:23.870
然后接下来干嘛

33:23.870 --> 33:24.870
接下来之后的话

33:24.870 --> 33:26.870
它会执行

33:26.870 --> 33:27.870
所以你现在就知道了

33:27.870 --> 33:29.870
为什么这个每次你那个

33:29.870 --> 33:31.870
就比如你这样子写

33:31.870 --> 33:33.870
在

33:33.870 --> 33:34.870
在这里

33:34.870 --> 33:35.870
每次你这样写

33:35.870 --> 33:36.870
这样写

33:36.870 --> 33:37.870
然后在下一次渲染的时候

33:37.870 --> 33:38.870
它是先执行什么

33:38.870 --> 33:40.870
是不是先执行它

33:40.870 --> 33:41.870
然后接下来再执行什么

33:41.870 --> 33:43.870
是不是再执行这个crate函数

33:43.870 --> 33:44.870
为什么

33:44.870 --> 33:46.870
这边的话它是先

33:46.870 --> 33:49.870
这边它是先执行这个destroy

33:49.870 --> 33:50.870
OK

33:50.870 --> 33:51.870
先执行destroy

33:51.870 --> 33:52.870
好

33:52.870 --> 33:53.870
然后接下来还有个方法

33:53.870 --> 33:54.870
还有一个方法的话

33:54.870 --> 33:57.950
叫做这个

33:57.950 --> 33:59.950
还有一个方法叫做这个

33:59.950 --> 34:01.950
commit hook

34:01.950 --> 34:02.950
effect list

34:02.950 --> 34:03.950
然后mount

34:03.950 --> 34:04.950
这个方法呢

34:04.950 --> 34:05.950
就是什么呢

34:05.950 --> 34:08.950
这个方法同样也是便利

34:08.950 --> 34:10.950
便利

34:10.950 --> 34:14.950
effect链表

34:14.950 --> 34:15.950
然后接下来的话

34:15.950 --> 34:17.950
一次执行什么呢

34:17.950 --> 34:21.840
执行crate方法

34:21.840 --> 34:23.840
一次执行这个crate方法

34:23.840 --> 34:25.840
OK

34:25.840 --> 34:27.840
然后你注意就是在

34:27.840 --> 34:28.840
生命阶段

34:28.840 --> 34:29.840
在生命阶段

34:29.840 --> 34:30.840
我们这边这个update

34:30.840 --> 34:31.840
这里update

34:31.840 --> 34:32.840
update的话

34:32.840 --> 34:33.840
我们根据这个dip

34:33.840 --> 34:34.840
是有没有变化

34:34.840 --> 34:36.840
我们这边不是有不同的标记吗

34:36.840 --> 34:37.840
对不对

34:37.840 --> 34:39.840
好在生命阶段

34:39.840 --> 34:41.840
生命

34:41.840 --> 34:43.840
就是生命阶段

34:43.840 --> 34:45.840
然后这个update

34:45.840 --> 34:48.840
会根据update时

34:48.840 --> 34:50.840
会根据什么呢

34:50.840 --> 34:52.840
根据这个dips

34:52.840 --> 34:53.840
就你的依赖项

34:53.840 --> 34:54.840
对吧

34:54.840 --> 34:56.840
是否变化

34:56.840 --> 34:58.840
是否变化

34:58.840 --> 34:59.840
然后打上什么

34:59.840 --> 35:01.840
是不是打上不同的这个tag

35:01.840 --> 35:04.840
打上不同的这个tag

35:04.840 --> 35:07.860
对不对

35:07.860 --> 35:09.860
我看到这边是打的tag吧

35:11.860 --> 35:13.860
这里这里是flex

35:13.860 --> 35:15.860
这是flex

35:15.860 --> 35:16.860
这边这边会有一个这个

35:16.860 --> 35:18.860
hook has effect

35:18.860 --> 35:19.860
对不对

35:19.860 --> 35:21.860
好那这边打上这个不同的tag之后

35:21.860 --> 35:22.860
然后接下来的话

35:22.860 --> 35:23.860
它这边就是

35:23.860 --> 35:26.860
如果你这边之后

35:26.860 --> 35:29.860
之后在这个执行阶段

35:29.860 --> 35:31.860
就会根据什么呢

35:31.860 --> 35:33.860
根据是否有tag

35:33.860 --> 35:36.860
是否有tag

35:36.860 --> 35:39.860
来决定是否

35:39.860 --> 35:41.860
要执行

35:41.860 --> 35:43.860
该effect

35:44.860 --> 35:46.860
比如说举个例子

35:46.860 --> 35:47.860
比如这里

35:47.860 --> 35:53.690
比如这边

35:53.690 --> 35:55.690
这边它执行这个list

35:55.690 --> 35:56.690
我们就看这个吧

35:56.690 --> 35:57.690
就看这个

35:57.690 --> 35:59.690
比如这边我们执行的是list mount

35:59.690 --> 36:00.690
然后就passive

36:00.690 --> 36:03.690
passive是否就是和use effect相关的

36:03.690 --> 36:04.690
对不对

36:04.690 --> 36:06.690
那它这边有这个 has effect

36:06.690 --> 36:07.690
这个tag

36:07.690 --> 36:08.690
说它会执行毁掉

36:08.690 --> 36:10.690
它就看你有没有这个

36:10.690 --> 36:11.690
对不对

36:11.690 --> 36:12.690
你看刚才就对应上的

36:12.690 --> 36:13.690
刚才你这边

36:13.690 --> 36:15.690
这边你如果是dips有变化

36:15.690 --> 36:17.690
它这边是否有这个

36:17.690 --> 36:18.690
as effect

36:18.690 --> 36:19.690
这边会有这个tag

36:19.690 --> 36:20.690
对不对

36:20.690 --> 36:21.690
如果没有变化

36:21.690 --> 36:22.690
没有变化

36:22.690 --> 36:23.690
它这边是没有那个tag的

36:23.690 --> 36:24.690
ok

36:24.690 --> 36:25.690
说这边在执行阶段的时候

36:25.690 --> 36:27.690
它就会根据你是否有这个tag

36:27.690 --> 36:29.690
来决定是否要执行这个

36:29.690 --> 36:30.690
effect

36:30.690 --> 36:31.690
好

36:31.690 --> 36:33.690
然后由于你这个方法是先

36:33.690 --> 36:37.510
由于这个方法

36:37.510 --> 36:38.510
由于

36:38.510 --> 36:41.510
由于这个方法

36:41.510 --> 36:44.510
会先于什么呢

36:44.510 --> 36:47.510
会先于这个

36:47.510 --> 36:49.510
mount

36:49.510 --> 36:51.510
方法

36:51.510 --> 36:52.510
然后执行

36:52.510 --> 36:53.510
就执行实际

36:53.510 --> 36:56.510
方法的这个执行

36:56.510 --> 36:58.510
实际

36:58.510 --> 37:00.510
实际实际

37:00.510 --> 37:01.510
会先于这个方法执行

37:01.510 --> 37:03.510
因此

37:03.510 --> 37:06.510
因此每次都是

37:06.510 --> 37:08.510
先执行什么呢

37:08.510 --> 37:09.510
先执行

37:09.510 --> 37:11.510
effect.destroy

37:12.510 --> 37:15.510
后才会执行

37:15.510 --> 37:18.510
effect.create

37:19.510 --> 37:20.510
对不对

37:20.510 --> 37:21.510
ok

37:21.510 --> 37:23.510
这是关于这个执行阶段

37:23.510 --> 37:24.510
好

37:24.510 --> 37:26.510
那么整个这个工作流程的话

37:26.510 --> 37:28.510
我们也带着大家过了一遍

37:28.510 --> 37:29.510
ok

37:29.510 --> 37:30.510
好

37:30.510 --> 37:31.510
来我们来看一下这个整体解答

37:31.510 --> 37:32.510
所以说

37:32.510 --> 37:33.510
use effect

37:33.510 --> 37:36.510
和use layout effect这个区别

37:36.510 --> 37:38.510
那这个use effect

37:38.510 --> 37:39.510
和use

37:39.510 --> 37:41.510
layout effect区别

37:41.510 --> 37:42.510
这个实际上在一开始

37:42.510 --> 37:43.510
这边是不是就说了

37:43.510 --> 37:44.510
对不对

37:44.510 --> 37:46.510
一个是在异部

37:46.510 --> 37:48.510
就是commit阶段完成后

37:48.510 --> 37:49.510
异部执行

37:49.510 --> 37:51.510
不会主色试图渲染

37:51.510 --> 37:52.510
一个是什么呢

37:52.510 --> 37:54.510
一个是在commit阶段

37:54.510 --> 37:56.510
它的这个layout指阶段

37:56.510 --> 37:57.510
同步执行

37:57.510 --> 37:58.510
那一般用于什么呢

37:58.510 --> 37:59.510
一般用于这个

37:59.510 --> 38:01.510
多目相关的这个操作

38:01.510 --> 38:03.510
其实这边的话就已经回答了

38:03.510 --> 38:04.510
这个题目了

38:04.510 --> 38:05.510
对不对

38:05.510 --> 38:06.510
但是你如果是面试的话

38:06.510 --> 38:07.510
你可以干嘛

38:07.510 --> 38:09.510
这可以再多说一点

38:09.510 --> 38:10.510
对不对

38:10.510 --> 38:11.510
能够多说一点就多说一点

38:11.510 --> 38:13.510
这样子能够更加出彩一些

38:14.510 --> 38:16.510
我这边的话把这个

38:16.510 --> 38:18.510
同样还是把这个参考单

38:18.510 --> 38:19.510
把它过来

38:21.510 --> 38:23.510
把它放到这里

38:25.510 --> 38:27.510
在react中用于定义

38:27.510 --> 38:29.510
副作用的音变量互可

38:29.510 --> 38:30.510
use effect

38:30.510 --> 38:31.510
use layout effect

38:31.510 --> 38:32.510
那个use insertion

38:32.510 --> 38:33.510
那个我就没有写了

38:33.510 --> 38:34.510
对吧

38:34.510 --> 38:35.510
因为人家题目问的

38:35.510 --> 38:36.510
就是这两个

38:37.510 --> 38:38.510
每一个effect

38:38.510 --> 38:39.510
会和当前的fc

38:39.510 --> 38:41.510
其他effect形成一个

38:41.510 --> 38:42.510
还装列表

38:42.510 --> 38:44.510
然后加这个use effect

38:44.510 --> 38:45.510
它的一个

38:45.510 --> 38:46.510
工作流程

38:46.510 --> 38:48.510
你可以大致的说一下

38:48.510 --> 38:49.510
对吧

38:49.510 --> 38:50.510
这个也算是区别吗

38:50.510 --> 38:51.510
对不对

38:51.510 --> 38:52.510
这算是区别算吗

38:52.510 --> 38:53.510
它这边有调度阶段吗

38:53.510 --> 38:54.510
你use layout effect

38:54.510 --> 38:55.510
没有调度阶段吗

38:55.510 --> 38:56.510
也算是区别

38:56.510 --> 38:57.510
对不对

38:57.510 --> 38:59.510
然后use layout effect

38:59.510 --> 39:00.510
它的工作流程

39:00.510 --> 39:01.510
是这样子的

39:01.510 --> 39:02.510
对吧

39:02.510 --> 39:03.510
多一个阶段

39:03.510 --> 39:04.510
为什么会多一个阶段

39:04.510 --> 39:05.510
因为它这边

39:05.510 --> 39:06.510
为什么需要调度

39:06.510 --> 39:08.510
因为它是一步执行

39:08.510 --> 39:09.510
对不对

39:09.510 --> 39:10.510
OK

39:10.510 --> 39:12.510
这是关于

39:12.510 --> 39:14.510
这个effect

39:14.510 --> 39:16.510
相关的这个hook

39:16.510 --> 39:17.510
下来的话

39:17.510 --> 39:19.510
可以把这些坑内容

39:19.510 --> 39:20.510
自己再看一下

39:20.510 --> 39:21.510
好吧

39:21.510 --> 39:23.510
这些坑的话就到这里

39:23.510 --> 39:24.510
再见

