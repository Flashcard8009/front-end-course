WEBVTT

00:00.000 --> 00:04.720
OK 这几颗的话 我们来谈一下这个fiber双缓冲

00:05.560 --> 00:12.480
这里的话有道面试题 这道面试题的话 说的是谈一谈你对req中fiber的这个理解

00:13.040 --> 00:15.080
以及什么是fiber双缓冲

00:15.960 --> 00:22.160
那么关于这个fiber的话 我们前面已经提过多次了 说这个fiber的话 它本质是一个对象

00:22.720 --> 00:27.040
这个对象的话 它是以这个练表的这种形式串起来的

00:27.680 --> 00:35.840
从而可以让你的这个计算任务可以这个中断 对吧 你如果没有这个剩余的这个时间 你就可以暂停这个

00:36.800 --> 00:43.760
更新流程 把这个主线程还给这个渲染流水线 等待这个下一个红任务 再来进行这个执行

00:44.560 --> 00:51.120
一般来讲的话 你对这个fiber理解到这个程度 这个是一个比较常规的这个程度

00:52.000 --> 00:55.520
对吧 因为正常来讲的话 这个网上的话也是这么说的

00:56.320 --> 01:02.320
好 那你这边的话 就是在回答面识题的时候啊 能不能回答的更加深入一些呢

01:03.040 --> 01:07.360
或者你能不能回答一些就是一些不同的这种间接呢

01:08.160 --> 01:14.880
对不对 ok 啊 说说我们这边的话啊 这些课的话 谢老师带着大家啊 咱们一起来看一下这个fiber

01:15.440 --> 01:19.920
顺便的话 我给大家说一下就是我对这个fiber的一个理解 ok

01:20.560 --> 01:24.000
好 那么这个fiber啊 首先关于这个对fiber的理解

01:26.300 --> 01:27.900
对fiber的理解

01:29.420 --> 01:35.260
那关于对这个fiber的理解 实际上的话 我觉得可以从三个方面啊 去理解fiber

01:36.860 --> 01:44.460
实际上 我们可以从三个啊 或者说三个维度啊 三个维度来

01:45.180 --> 01:46.380
这个理解fiber

01:48.640 --> 01:53.040
首先 第一个维度是什么呢 第一个维度的话 就是fiber的话 它是一种架构

01:54.000 --> 01:57.920
哎 称之为什么呢 称之为fiber架构

01:59.760 --> 02:02.400
ok 第二个的话fiber是一种什么呢

02:02.960 --> 02:06.080
fiber是一种数据类 这个数据类型

02:07.760 --> 02:11.680
ok 它是一种数据类型啊 然后用链表把它串联起来

02:12.320 --> 02:15.840
最后的话这个fiber它是什么呢 它是一个动态的

02:16.720 --> 02:24.380
工作单元啊 工作单元 你看这边的话 我们实际上可以从这么三个维度

02:24.700 --> 02:29.500
去理解这个fiber 好来我们一个一个来看啊 我们这边把这个

02:31.870 --> 02:37.310
好 把这个讲出 然后这边这个是一种数据类型

02:38.030 --> 02:41.230
好 然后是一个动态的工作单元

02:41.950 --> 02:45.790
好 我们一个一个来看 首先的话这个fiber的话 它是一种架构

02:46.670 --> 02:50.990
啊 这个非常好理解 在这个react v16之前

02:51.550 --> 02:54.110
使用的是什么 是不是使用的是这个stack

02:54.190 --> 03:03.630
reconcenter 对不对 在这个react v16之前使用的是

03:04.670 --> 03:10.750
使用的是这个stack stack这个reconcenter

03:12.270 --> 03:18.670
reconcenter啊 所以那个时候的这个整个react架构 被称之为stack架构

03:19.630 --> 03:28.830
因此那个时候的这个react架构被称之为这个stack架构

03:31.740 --> 03:35.420
但这个stack架构的话 它有它自身的一些这个缺陷

03:35.420 --> 03:39.100
这个的话 我们在前面几节课的话已经说过很多次了 对不对

03:39.100 --> 03:41.260
它是这种低规的啊 不能暂停的

03:41.820 --> 03:47.820
说从这个react v16开始啊 重购了整个架构 引入了什么

03:47.900 --> 03:50.060
是不是引入了fiber 对不对

03:50.060 --> 03:57.180
从这个react v16开始重购了整个架构

03:58.700 --> 04:04.460
整个架构引入了 引入了这个fiber啊

04:04.460 --> 04:10.140
因此新的这个架构也被称之为什么呢

04:10.140 --> 04:14.860
称之为fiber架构啊被称之为fiber架构

04:14.940 --> 04:20.780
然后你的那个reconcenter也变成了什么呢 变成了这个fiberreconcenter啊

04:21.820 --> 04:30.060
这边这个stack reconcenter也变成了fiberreconcenter

04:32.780 --> 04:35.980
然后你各个这个fiber load之间 他们使用什么呢

04:35.980 --> 04:40.860
他们是通过这个练表的这种方式是不是串联起来的 对不对

04:41.660 --> 04:46.140
各个fiber load啊fiber load就是你这个fiber这个节点

04:47.260 --> 04:53.260
之间通过什么呢通过练表的形式串联起来

04:54.700 --> 04:57.980
啊这一点的话在这个圆码里面也是有体现的啊

04:57.980 --> 05:01.260
我们这边呢把这个圆码这个一部分把拿过来啊

05:01.260 --> 05:02.940
实际上在这一块的话大家之前看过了

05:03.500 --> 05:07.660
就关于这个fiber load啊这个方法大家看过你看这一块

05:08.060 --> 05:12.460
这块呢他这边z点returnz点撬的z点杀不灵啊

05:12.460 --> 05:14.460
他这边呢就这些属性就是干嘛

05:14.460 --> 05:18.620
这些属性的话就是和其他的这个fiber load进行这个串联的

05:19.420 --> 05:25.100
对不对啊说我们这边首先第一层理解啊第一个唯独的理解fiber它是一种架构

05:25.900 --> 05:28.540
好第二个第二个的话就是这个fiber

05:29.980 --> 05:34.140
它是一种数据内心啊这个怎么理解呢这个其实也很好理解

05:34.620 --> 05:38.380
fiber的话它本质上也是一个什么是不是也是一个对象

05:39.420 --> 05:41.740
对不对fiber本质上

05:43.420 --> 05:51.180
本质上也是一个对象啊是什么呢是之前这个react元素

05:53.260 --> 05:58.140
是在是在之前react元素这个react元素是不是也是个对象

05:58.700 --> 06:01.820
对不对以前你使用那个stack架构的时候啊

06:01.980 --> 06:07.580
内部的话就是通过这个react元素来描述的这个dorm成织结构啊

06:07.580 --> 06:10.300
只不过现在的话是用了fiber这个对象来描述

06:10.940 --> 06:14.940
好了这个fiber这个对象的话是在之前这个react元素基础上

06:15.980 --> 06:21.650
基础上的一种升级版本对不对

06:21.970 --> 06:27.010
它是这个一种升级版本啊你这个在每一个这个fiber对象里面

06:27.330 --> 06:30.210
会包含这个react元素的内心啊

06:30.290 --> 06:34.050
然后周围连接的这个fiber load然后dorm相关信息

06:35.490 --> 06:46.210
每个fiber load对象里面会包含这个react元素的这个内心

06:47.330 --> 06:54.770
啊然后接下来周围连接连接的这个fiber load啊以及什么呢

06:55.330 --> 06:58.370
以及这个dorm相关信息

06:59.090 --> 07:02.690
对吧啊这边让我们做个从这个圆码里面

07:05.760 --> 07:07.920
从圆码里面啊我们这边我们可以看一下

07:11.150 --> 07:14.910
这边你看它里面的话有这个tag key

07:15.390 --> 07:19.550
element type那接下来这边type啊这边state load

07:19.550 --> 07:22.910
注意这个state load它就是映射这个真实的这个dorm

07:23.550 --> 07:25.310
啊它就是映射真实的dorm

07:25.550 --> 07:30.990
ok说你这边让你可以把这个fiber看作是什么啊也是一种数据内心

07:32.430 --> 07:34.990
好那最后的话就是什么呢最后就是fiber的话

07:35.310 --> 07:41.150
你可以把它看作是什么呢可以把它看作是一个动态的这个工作单元

07:42.270 --> 07:44.910
在每一个这个fiber load这个fiber load里面

07:45.390 --> 07:49.230
它会保存什么呢它会保存各种各样的这种flag

07:49.950 --> 07:52.030
啊就是还有就是这个副作用

07:52.510 --> 07:56.270
ok啊这些flag的话就表示了我这个fiber load

07:56.270 --> 08:01.150
它要执行的工作啊究竟是真还是三还是修改

08:01.870 --> 08:04.430
还是说比如更新瑞福呀副作用啊这些

08:04.830 --> 08:13.520
ok在在每个fiber load中

08:14.640 --> 08:19.680
保存了什么呢保存了这个本次这个更新中

08:20.800 --> 08:27.360
然后该react元素呃变化的数据

08:28.320 --> 08:36.640
ok还有就是还有就是要执行的工作啊比如说你这边究竟是要真

08:37.280 --> 08:40.720
还是要三还是要这个更新

08:42.480 --> 08:43.840
啊还是要这个更新

08:44.480 --> 08:52.000
ok就各种各样要执行的工作啊以及什么呢以及副作用副作用的信息

08:52.800 --> 08:57.120
ok那回头的话你这边的话在在进行这个reconcel的时候

08:57.440 --> 09:03.600
就是这个这个这个调和的时候啊reconcel在进行调和的时候我就会根据什么呢

09:03.600 --> 09:08.800
根据这些信息是不是来进行一个这个工作对不对啊

09:08.800 --> 09:12.400
所以我们可以把这个fiber一个fiber看作是一个什么呢

09:12.400 --> 09:16.800
可以看作是一个最小的动态工作单元啊

09:17.360 --> 09:20.880
那我们这边呢在这个还是这个代码里面

09:21.440 --> 09:22.480
仍然是fiber load

09:24.320 --> 09:27.120
仍然是fiber load啊你这边可以看到这边

09:27.680 --> 09:32.400
它是不是有各种各样的flex对咧那subtray flex啊

09:32.400 --> 09:35.680
然后加这个这个是要这个删除的这个我们后面会讲啊

09:35.680 --> 09:39.120
包括什么呢包括与这个调度优先级相关的啊

09:39.120 --> 09:40.960
还有就是副作用相关的

09:41.520 --> 09:47.840
ok说你这边可以把这个fiber啊理解成一个动态的这个工作单元

09:48.400 --> 09:51.840
啊说说整个这个fiber你这边你要说就是对它的理解的话

09:51.840 --> 09:55.120
实际上你可以从这么三个方面去说啊

09:55.120 --> 09:59.280
而不是说单单就说这个fiber啊也是一种ges对象啊

09:59.280 --> 10:03.520
通过这种练表的形式啊穿起来就完了对不对啊

10:03.520 --> 10:08.240
你这样子说出来的这种效果是不是明显要更好一些对不对

10:08.720 --> 10:10.320
明显要更好一些啊

10:11.360 --> 10:13.600
好然后接下来这边的话有个细节啊

10:13.600 --> 10:18.160
注意这边有个细节就是经常呃就是有这个网上啊

10:18.160 --> 10:21.760
网上的话会有一些这个人在问为什么指向这个

10:22.480 --> 10:28.990
负fiber load的制断啊叫做return而不是这个parlence啊

10:28.990 --> 10:38.350
为什么指向负fiber负fiber load的这个制断啊

10:38.350 --> 10:43.630
叫做什么呢叫做return而非什么呢而非parlence

10:46.110 --> 10:51.150
啊为什么啊你想想我们以前的话经常就是我们的负元书负元书是不是就是parlence

10:51.870 --> 10:56.510
对不对啊但是你看在这边这边它是return而不是parlence

10:56.510 --> 11:01.630
为什么呢啊这个呢实际上它在那个官方的一篇那个日字里面啊

11:01.630 --> 11:05.630
你可以去看那个官方的日子它这边啊它其实当时在写那个

11:05.630 --> 11:09.070
有一篇日字的时候它是提到了这个细节的为什么呢

11:09.070 --> 11:12.350
啊因为作为一个这个动态的这个工作单元

11:12.910 --> 11:15.070
return指的是什么呢return指的是

11:15.070 --> 11:21.310
就是你fiber执行完这个complete work后返回了一个下一个fiber load

11:21.950 --> 11:25.550
你因为你这边有个返回的这个这个动作

11:26.430 --> 11:32.270
ok说这边啊通过什么呢通过这个return来指代这个负fiber load

11:34.670 --> 11:40.510
因为作为一个动态的工作单元

11:41.310 --> 11:44.990
这个return指代

11:46.110 --> 11:48.910
指代的是fiber load

11:50.110 --> 11:54.670
执行完成后啊就是执行完这个complete

11:56.670 --> 11:59.310
执行完complete work后

12:00.670 --> 12:04.910
然后返回的下一个这个fiber load

12:06.430 --> 12:09.390
ok啊这边呢它会有一个这个返回的动作

12:10.590 --> 12:19.230
这里会有一个返回的动作啊因此通过什么呢通过这个return来指代

12:21.070 --> 12:24.430
指代这个负这个负fiber load

12:26.110 --> 12:30.190
ok这是当时它这个官网的日子里面稍微提了那么一嘴

12:31.550 --> 12:35.710
啊这是首先第一个啊我要讲的就是关于对这个fiber的一个理解

12:36.430 --> 12:44.110
好第二个就是什么呢第二个就是关于fiber双缓冲啊这个fiber双缓冲是什么意思啊我们这期可把这个也说一下啊

12:45.150 --> 12:46.990
这边的话fiber

12:48.430 --> 12:55.310
双缓冲好我们这边来看一下好这边的话这个fiber架构的这个工作原理

12:55.790 --> 13:01.310
它实际上有点类似于什么呢实际上有点类似于这个显卡的这个工作原理

13:02.030 --> 13:08.350
好我们前面的话我们讲过就是你在绘制的时候最终的话你绘制的这个产物是什么

13:08.830 --> 13:14.910
是不是一张图片对不对好然后加这张图片的话它会被发送给什么呢发送给显卡

13:15.470 --> 13:18.830
然后加显卡的话把这张图片把它显示出来

13:19.790 --> 13:26.350
那么具体来讲的话这个显卡的话它实际上包含什么呢包含这个前缓冲区和这个后缓冲区

13:26.830 --> 13:30.990
啊那对于这个刷新频率为这个60Hz的这种显示器

13:31.470 --> 13:38.830
就需要每秒钟从这个前缓冲区中读取60次图像啊然后把它显示到这个显示器上面

13:39.550 --> 13:46.110
ok 好那这个显卡它的指责是什么呢显卡它的指责就是它合成这个图像

13:46.510 --> 13:48.830
并把它写入到这个后缓冲区

13:49.470 --> 13:55.790
然后一旦你这个后缓冲区被写入了这个图像啊那么这个前后这个缓冲区它就会互换

13:56.590 --> 14:01.150
啊那这种技术的话实际上就被称之为什么呢就被称之为双缓存技术

14:02.190 --> 14:08.510
啊你想想如果没有这种双缓存技术的话对于这种需要大量计算啊才能产生这种

14:09.070 --> 14:15.550
才能产生的这种复杂图像啊那你这个的话你访问一次缓冲区的话你是很难读取到这个完整的图像的

14:16.350 --> 14:22.510
对不对啊那么作为用户的话你就会看到这个闪烁不完整的这种图像啊一点一点的显示出来

14:23.310 --> 14:31.230
啊那就是对于这种消费者和生产者供需不一致的这种场景那你这个双缓存的话就是一个非常好的这个优化手段

14:31.790 --> 14:37.310
啊那么这个fiber里面的这个双缓存这个双缓冲其实也是这个道理

14:37.950 --> 14:40.510
ok好来我们这边记一下啊记一下

14:42.110 --> 14:44.670
就fiber fiber价格

14:45.550 --> 14:49.950
中的啊fiber价格中的这个双缓冲啊双缓冲

14:50.590 --> 14:51.230
工作原理

14:52.190 --> 14:56.190
工作原理类似于什么呢类似于这个显卡

14:57.310 --> 14:58.510
显卡的工作原理

14:59.310 --> 15:00.830
ok啊显卡

15:02.270 --> 15:04.590
分为什么呢分为这个前缓冲区

15:05.710 --> 15:08.430
前缓冲区和后缓冲区

15:10.430 --> 15:10.670
后

15:12.430 --> 15:18.350
缓冲区 ok好然后接下来的话你这边的话首先这个前缓冲区前缓冲区的话他会被什么呢

15:18.350 --> 15:20.750
他会被这个就是显示图像啊

15:21.310 --> 15:21.870
就首先

15:23.870 --> 15:24.270
首先

15:25.070 --> 15:31.310
这个前缓冲区会显示什么呢会显示图像

15:32.350 --> 15:35.470
啊然后之后这个合成的

15:36.990 --> 15:39.310
合成的新的这个图像

15:41.070 --> 15:44.110
会被写入到什么呢会被写入到后缓冲区

15:45.710 --> 15:49.710
啊合成的新的图像不是说就是直接去替换前缓冲区

15:50.270 --> 15:52.990
而是干嘛呢先写入到这个后缓冲区

15:53.630 --> 15:54.510
好写入之后

15:54.510 --> 15:56.830
然后一旦你这个后缓冲区被写入

15:57.950 --> 16:00.430
一旦后缓冲区

16:01.390 --> 16:02.910
这个写入图片完毕

16:03.870 --> 16:06.750
写入图像啊完毕

16:07.150 --> 16:11.630
然后就会什么呢就会前后缓冲区

16:12.750 --> 16:13.230
进行

16:14.830 --> 16:17.550
进行一个互换啊

16:17.550 --> 16:22.590
就你之前写入了这个新的图像的这个后缓冲区变成了前缓冲区

16:22.750 --> 16:26.030
而之前的那个前缓冲区变成了这个后缓冲区

16:26.750 --> 16:27.950
ok啊这种

16:29.710 --> 16:31.470
这种将这个数据

16:32.510 --> 16:35.710
数据保存在这个缓冲区

16:36.670 --> 16:38.430
再进行什么呢再进行

16:41.790 --> 16:42.030
再

16:43.230 --> 16:46.110
再进行这个互换的这个技术

16:46.910 --> 16:51.230
就被称之为什么呢称之为双缓冲技术

16:52.990 --> 16:55.390
双缓冲技术

16:56.830 --> 17:00.030
ok你如果没有这种双缓冲技术的话你想一想啊

17:00.030 --> 17:03.790
你那种大量的这种计算啊生成的这个复杂图像啊

17:03.790 --> 17:08.510
你这边呢访问一次缓冲区那是很难读取到这个完整图像的

17:08.510 --> 17:12.430
那到时候的话你用户看到的这个图像它是一闪一闪的不完整的

17:12.990 --> 17:18.750
ok好那么这边的话这个我们这个fiber啊fiber价格的话同样用到了这个技术

17:20.190 --> 17:21.470
fiber价格

17:22.190 --> 17:25.230
同样用到了这个技术

17:25.870 --> 17:27.870
ok称之为双缓冲技术

17:28.430 --> 17:34.190
在这个fiber价格里面它同时存在什么呢同时存在这个两颗fiber tree

17:35.230 --> 17:41.020
啊在这个fiber价格中价格中

17:41.740 --> 17:46.140
同时存在两颗这个fiber tree

17:47.900 --> 17:52.780
ok好一颗的话是什么呢一颗的话是真实ui对应的这个fiber tree

17:54.060 --> 18:01.710
一颗是真实ui对应的fiber tree

18:02.910 --> 18:11.230
啊你可以类比为什么呢类比为这个钱缓冲区啊可以类比为这个显卡的这个钱

18:12.830 --> 18:16.270
钱缓冲区好另外一颗是什么呢

18:17.230 --> 18:22.030
另外一颗是在内存中构建的

18:22.990 --> 18:25.230
内存中构建的这个fiber tree

18:27.630 --> 18:34.510
你可以理解为啊可以类比为这个显卡的这个后缓冲区

18:37.150 --> 18:43.310
后缓冲区 ok那你这个数组环境啊数组环境的话就可以类比为这个显示器啊

18:43.790 --> 18:50.190
好那在这个react原码里面实际上有很多方法都是接收什么呢接收两颗fiber tree

18:50.990 --> 18:58.990
啊在这个react原码中很多方法都需要什么呢都需要接收

19:00.430 --> 19:05.550
两颗fiber tree ok比如我们这边举个例子

19:06.510 --> 19:11.150
比如你看这段代码啊比如你看这段代码把这段代码拿过来

19:12.910 --> 19:16.670
啊这边你让他这边是不是接收两个参数对不对一个current

19:17.230 --> 19:24.750
一个叫做walking progress那这个current current指的就是什么呢current指的就是这个前缓冲区的这个fiber load

19:26.670 --> 19:39.260
current current指的指的就是这个前缓冲区的这个fiber load

19:40.780 --> 19:44.380
啊那你的这个walking progress

19:47.310 --> 19:53.230
指的就是什么呢指的就是后缓冲区的这个fiber load

19:54.990 --> 20:01.710
ok那两个这个fiber load的话他会通过什么呢他会通过这个alternate属性相互进行指向

20:03.790 --> 20:04.270
两个

20:05.470 --> 20:11.630
两个fiber load会通过什么呢会通过alternate属性

20:12.670 --> 20:18.380
呃相互指向 ok啊比如我们这边

20:19.260 --> 20:27.310
这边看一下这个这个代码他这边的话类似于就这个样子的啊你这边current点alternate

20:27.870 --> 20:31.230
啊他对应的是这个walking progress这个programs

20:31.790 --> 20:35.790
而这个walking progress点这个alternate啊这边是alternate

20:37.470 --> 20:42.830
alternate他对应的是什么呢对应的是这个current

20:43.390 --> 20:46.750
啊好那接下来的话我们就从什么呢接下来我们从这个

20:47.230 --> 20:52.830
首次渲染和更新啊从这个两个角度我们来看一下他的这个fiber tree

20:53.070 --> 20:58.750
他是如何形成的啊以及这个双缓存他如何形成这个两棵树的

21:00.430 --> 21:06.510
好接下来接下来我们从什么呢从这个首次渲染

21:08.510 --> 21:12.590
首次渲染啊这个我们一般称之为什么称之为这个mount

21:13.790 --> 21:17.710
啊这个等值大家应该很熟悉啊这个你学view里面是不是也有这个mount

21:18.350 --> 21:25.310
对不对啊从首次渲染和什么呢和这个更新啊更新了他这边对应的是update

21:26.110 --> 21:27.070
啊这两个阶段

21:28.350 --> 21:33.870
这两个阶段啊来看一下fiber tree

21:35.470 --> 21:40.750
fiber tree 的这个形成以及

21:42.110 --> 21:43.870
呃双缓存机制

21:45.980 --> 21:49.020
OK好那首先的话是这个mount阶段

21:51.620 --> 21:55.140
啊这边mount阶段啊还有一个是update

21:59.230 --> 22:04.510
OK好我们首先让我们来看这个mount阶段mount阶段的话首先最顶层

22:05.150 --> 22:09.230
最顶层的这个fiber load的话他叫做fiber root node

22:09.950 --> 22:13.070
啊首先最顶层

22:14.030 --> 22:16.110
有一个fiber load

22:16.830 --> 22:22.910
有一个fiber阶点啊称之为什么呢称之为这个fiber

22:23.470 --> 22:24.590
然后root node

22:26.350 --> 22:32.110
OK那这个fiber的话他会负责一些这个他会有一些这个自己的任务啊

22:32.750 --> 22:33.870
该fiber load

22:35.710 --> 22:42.510
会有一些自己的这个任务啊比如说什么呢啊比如这么几个啊直接拿过来

22:44.350 --> 22:47.790
比如他会有这么一些任务啊比如这个current fiber tree

22:48.110 --> 22:52.270
和这个vibre fiber tree之间的这个切换啊这个current fiber tree

22:52.270 --> 22:55.150
就是什么就是你那个前缓存区的那个fiber tree

22:55.710 --> 23:01.150
而这个vibre fiber tree这个就是什么呢这个就是你那个后缓存区的这个fiber tree

23:01.150 --> 23:02.990
就是指的是这个walking programs

23:03.550 --> 23:08.590
你注意后面我们这个walking programs我们经常就会减写啊wip

23:09.150 --> 23:10.430
OKwip

23:10.910 --> 23:11.550
啊vip

23:12.830 --> 23:16.590
好还有什么呢还有就是应用中的这个过期时间啊

23:16.590 --> 23:18.830
然后应用的这个任务调度信息

23:19.390 --> 23:20.990
OK他会有这么一些工作

23:21.550 --> 23:24.750
好那么现在的话假设我们有这么一个结构啊

23:25.710 --> 23:30.350
现在假设有这么一个结构

23:32.030 --> 23:35.950
什么结构呢好首先呢这边这个html你有这么一个html

23:38.180 --> 23:42.180
啊body body下面有个div div id是root好

23:42.180 --> 23:44.180
然后接下来的话你有这么一个组件

23:45.140 --> 23:46.420
有一个app的组件

23:50.110 --> 23:54.270
有一个app的组件啊app组件然后加这边是不是进行一个挂载

23:54.750 --> 23:59.870
挂载到这个root上面好来接下来我们来分析啊他整个这个fiber tree

23:59.870 --> 24:03.310
他是怎么创建的好首先的话你执行

24:05.950 --> 24:09.710
当执行这个rektdom

24:11.230 --> 24:19.950
点这个creator root的这个时候啊会创建什么呢会创建如下的这个结构

24:21.230 --> 24:22.910
怎么样结构呢啊这个样子的

24:25.250 --> 24:29.250
大致就是这个样子的啊你首先的话有一个这个fiber root node吗

24:29.250 --> 24:32.610
这是我们刚才所说的吗这是最顶层的对不对

24:32.610 --> 24:36.690
好然后接下来这边会有一个什么呢会有个host root fiber

24:36.690 --> 24:38.530
对呢是什么呢对应就是这个div

24:39.970 --> 24:43.730
OK对呢就是这个div啊host root fiber好

24:43.730 --> 24:47.810
然后接下来这边这个current current的话他会指向什么呢

24:47.810 --> 24:52.930
指向这个根结点对不对他会指向这个根结点啊

24:53.890 --> 24:55.650
就是此时

24:57.570 --> 25:02.450
此时会有一个host root fiber

25:03.330 --> 25:11.970
啊然后接下来这个fiber root node通过什么呢通过current来指向

25:13.250 --> 25:17.940
指向这个host root fiber对不对

25:18.660 --> 25:22.580
好然后接下来的话进入到这个mount流程啊

25:23.300 --> 25:28.260
接下来进入到mount流程

25:29.460 --> 25:34.260
那这个时候的话他会基于什么呢他会基于每个react元素

25:34.260 --> 25:40.100
以深度优先的这种原则一次生成这个就是vip就是这个

25:40.100 --> 25:42.420
就是这个这个vip fiber tree

25:42.980 --> 25:48.270
OK进入mount流程啊该流程

25:49.230 --> 25:57.230
会基于每个react元素啊然后以这个深度

25:58.350 --> 26:05.680
优先的这个原则原则啊一次

26:07.200 --> 26:12.800
一次生成这个wip这个fiber node

26:13.920 --> 26:17.520
OK然后并且什么呢并且每一个

26:18.480 --> 26:24.240
并且每一个wip fiber load

26:24.240 --> 26:28.640
啊然后接下来会啊这个连接起来

26:29.760 --> 26:34.880
连接起来啊如何连接的话我们之前讲过了对不对

26:34.880 --> 26:38.720
他就是通过这种练表的形式啊一个一个连接起来

26:38.720 --> 26:43.810
好大字的话就是像这张图一样啊

26:43.810 --> 26:45.970
这边如下图所示

26:47.410 --> 26:49.010
啊大字就是像这个样子

26:50.690 --> 26:55.570
好然后接下来的话你这边生成这个wip fiber load的是啊

26:55.570 --> 27:00.370
他会附用什么呢会附用这个这个current里面的这个fiber node

27:00.370 --> 27:04.050
但是呢你现在的话你这个current里面下面有没有这个fiber load

27:04.690 --> 27:06.530
是没有你目前的话是不是只有什么

27:06.530 --> 27:09.570
是不是只有这个host root fiber对不对

27:09.570 --> 27:14.290
说目前的话就只有host root fiber和这个就这边的这个fiber tree

27:14.290 --> 27:18.370
啊这边的fiber tree我们称之为这个wip啊就wip啊

27:18.450 --> 27:22.290
wip这个fiber tree啊目前这个wip fiber tree里面

27:22.290 --> 27:26.290
就只有这个host root fiber和这边的话是连在一起的

27:26.930 --> 27:34.450
ok啊这边生成的这个wip fiber tree

27:35.890 --> 27:40.930
fiber tree里面的每一个fiber load

27:41.650 --> 27:44.770
会和什么呢会和这个current

27:45.890 --> 27:48.210
这个current fiber tree

27:49.970 --> 27:55.810
current fiber tree里面的这个fiber load

27:57.410 --> 27:58.930
进行什么呢进行关联

28:00.210 --> 28:02.530
进行关联啊关联的方式

28:03.330 --> 28:08.530
关联的方式就是通过什么呢通过这个alternate属性

28:09.410 --> 28:13.890
ok通过这个alternate属性就这个进行关联

28:13.890 --> 28:17.330
这样子的话到时候就是能够附用的它就附用对不对

28:17.330 --> 28:20.290
能够最大程度的进行这个附用这个附用

28:20.290 --> 28:28.770
啊但是目前啊但是目前这个current current fiber tree里面

28:30.700 --> 28:39.180
fiber tree里面只有什么只有一个host root fiber对吧

28:39.260 --> 28:42.060
就你一开始的话你这边是空的吗对不对

28:42.060 --> 28:43.820
这边就只有一个host嘛

28:43.820 --> 28:45.100
说这边的话就只有什么呢

28:45.100 --> 28:51.980
因此就只有这个啊因此就只有这个host root fiber

28:53.500 --> 28:56.700
啊进行了什么呢进行了alternate

28:58.460 --> 29:01.100
alternate的这个关联

29:01.820 --> 29:08.350
ok好然后接下来的话当你这个就这个

29:09.070 --> 29:11.310
啊vip fiber tree啊就这个

29:13.860 --> 29:18.180
当vip fiber tree啊生成完毕以后

29:19.460 --> 29:22.500
也就意味着什么呢也就意味着

29:23.460 --> 29:24.740
这个我们的刃刃阶段

29:26.020 --> 29:29.300
刃刃阶段完毕了还记得吧

29:29.300 --> 29:32.820
我们这个上几颗讲的那个整个渲染的流程

29:32.820 --> 29:36.820
两大阶段刃刃阶段和commit阶段对不对

29:36.820 --> 29:39.380
好你这边的这个vip fiber tree

29:39.460 --> 29:42.180
生成完毕之后啊我们这边也没有什么其他的副作用

29:42.180 --> 29:45.460
对吧理论上来讲的话你还处理这个其他的副作用之类的

29:45.460 --> 29:48.100
还有一套流程但我们这边没有其他乱七八糟的

29:48.100 --> 29:50.900
说这边的整个rander阶段它就完毕了

29:50.900 --> 29:53.380
好完毕了之后然后接下来它就会干嘛呢

29:53.380 --> 29:57.220
它就会被传递给这个rander啊此时

29:59.330 --> 30:04.050
这个fiber root node就会

30:05.730 --> 30:09.410
就会被传递给这个rander

30:11.440 --> 30:15.760
rander那这个是什么这个时候就是我们的渲染器

30:16.960 --> 30:19.440
对不对好传给这个渲染器之后

30:19.440 --> 30:21.440
然后接下来的话就是进行渲染工作

30:22.720 --> 30:27.280
接下来就是进行渲染工作

30:28.240 --> 30:30.080
好那渲染工作完成之后

30:30.080 --> 30:31.840
那接下来我们的这个浏览器里面

30:31.840 --> 30:34.480
是不是就显示了对应了ui了对不对

30:35.040 --> 30:39.840
渲染工作完毕后浏览器中

30:40.560 --> 30:45.600
就显示了显示了对应的这个ui

30:46.320 --> 30:49.600
好然后接下来的话有一个非常关键的步骤

30:49.600 --> 30:53.440
此时这个fiber root node

30:55.280 --> 31:02.160
点current就会指向啊这棵树

31:03.360 --> 31:06.640
这棵就是vipo这个vipo fiber tree

31:08.780 --> 31:10.700
它就会指向这棵树

31:10.700 --> 31:13.980
那么曾经的这个vipo fiber tree

31:16.270 --> 31:17.710
它就会干嘛呢

31:17.710 --> 31:23.310
它就会变成current fiber tree

31:24.670 --> 31:28.990
哎是不是两个互换了对不对两个就进行了互换

31:28.990 --> 31:32.030
啊而你的那个就是current fiber tree

31:32.030 --> 31:34.030
啊就这边啊这边那它就变成什么

31:34.030 --> 31:35.710
它就变成那个vipo fiber tree了

31:36.270 --> 31:39.230
ok好这边曾经的这个vipo fiber tree

31:39.230 --> 31:40.990
变成了current fiber tree

31:41.070 --> 31:42.590
啊然后完成了什么呢

31:42.590 --> 31:46.830
完成了双缓存的这个工作

31:47.550 --> 31:52.660
啊我这边有个图对应的就是这个样子的

31:53.620 --> 31:57.060
你看它的这个current之前是不指向这的对不对

31:57.060 --> 31:59.140
那现在的current就指向这个这了

31:59.700 --> 32:01.140
它现在的话那就变成什么呢

32:01.140 --> 32:03.140
它就变成这个current fiber tree了

32:03.140 --> 32:05.940
就是前缓存区的那个那个树

32:05.940 --> 32:09.940
ok啊这个是就是mount阶段

32:10.660 --> 32:14.260
好然后接下来的话这边update阶段

32:14.260 --> 32:17.060
啊比如说我们这边呢我们点击这个p

32:17.060 --> 32:20.020
啊比如这边点击p进行一个更新

32:20.020 --> 32:24.260
那你这边更新的话是不是自然而然会开启这个update流程

32:24.260 --> 32:28.510
对不对好点击p

32:28.510 --> 32:34.510
点击p元素啊会什么呢会触发更新

32:34.510 --> 32:36.190
啊这一操作

32:37.150 --> 32:42.190
这一操作就会开启update流程

32:45.870 --> 32:51.150
ok此时就会生成一颗新的

32:52.350 --> 32:56.830
一颗新的这个vip fiber tree

32:56.830 --> 33:02.770
啊流程的话和之前是一样的

33:03.810 --> 33:07.410
流程和之前是一样的

33:07.410 --> 33:10.130
啊你之前这个mount阶段的话这边是吧

33:10.210 --> 33:14.210
挨着挨着生成了一颗这个vip fiber tree

33:14.210 --> 33:15.810
对吧那你现在更新更新的话

33:15.810 --> 33:19.330
那现在它是current了啊这个vip的话只像这边了

33:19.330 --> 33:21.890
啊大家这边的话也就会和刚才一样的啊

33:21.890 --> 33:24.130
生成一颗这个vip fiber tree

33:24.130 --> 33:31.330
啊这边对应的流程是这个样子的啊对应的是这样子的

33:31.330 --> 33:35.570
大家每一个节点啊你会发现每一个这个vip fiber tree里面的

33:35.570 --> 33:39.010
每一个节点和什么呢和这个current fiber tree里面元素

33:39.010 --> 33:41.650
通过这个automate属性进行关联

33:42.450 --> 33:55.170
对不对啊新的vip fiber tree里面的每一个元素和什么呢和这个current fiber tree

33:57.090 --> 34:01.810
啊的这个每一个元素啊其实应该叫做fiber load

34:01.810 --> 34:03.490
啊每一个fiber load

34:05.570 --> 34:10.530
fiber load和这个current fiber tree里面的每一个这个fiber load

34:11.010 --> 34:17.650
通过什么呢通过automate属性进行关联

34:19.250 --> 34:24.370
对不对啊好然后接下来当你这边这个vip fiber tree

34:24.370 --> 34:28.450
啊整体这个生成完毕之后它就会经历这个同样的流程

34:29.970 --> 34:32.130
当vip fiber tree

34:33.970 --> 34:37.490
啊就这边的哈这边是就是现在呢现在是这边

34:37.490 --> 34:40.210
对不对啊当你这边的这个vip fiber tree

34:41.330 --> 34:48.770
生成完毕后生成完毕后就会什么呢就会经历

34:50.210 --> 35:00.110
和之前一样的流程一样的流程怎么流程呢就你这边这个fiber root

35:01.470 --> 35:06.670
fiber root node会被传递给什么呢传递给这个渲染器

35:07.470 --> 35:10.030
扔到哪然后进行什么进行渲染

35:10.990 --> 35:12.270
进行渲染

35:13.310 --> 35:17.790
进行渲染之后然后接下来你整个这个宿主环境里面显示了

35:18.430 --> 35:24.030
这个真实的ui是不是就是就是对应了这个数的这个结构了对不对啊此时

35:25.710 --> 35:33.950
就是宿主环境宿主环境所渲染出来的真实ui

35:35.790 --> 35:38.190
对应的就是什么呢就是左边

35:39.070 --> 35:40.590
左边这个vip fiber tree

35:41.550 --> 35:44.990
vip这个vip fiber tree

35:46.350 --> 35:55.740
所所对应的这个动物结构对不对啊那么这个时候的话这个fiber

35:56.700 --> 35:58.300
fiber root node

35:59.340 --> 36:06.580
点current就会指向什么呢就会指向左边这棵树

36:09.140 --> 36:14.900
左边这个树啊那叫右边右边的树

36:17.330 --> 36:21.730
就再一次成为了什么呢成为了

36:22.690 --> 36:24.690
新的这个vip fiber tree

36:27.950 --> 36:31.150
是不是这样子的对不对啊把这个图把它过来

36:34.480 --> 36:38.480
好你之前的话current是指的这边吗对不对然后既然我这边

36:39.120 --> 36:42.800
就我这边这边这个vip fiber tree构建完毕之后的渲染

36:42.880 --> 36:47.360
渲染了之后然后接下来我真实的这个ui渲染了是不是就这边所对应的这个结构

36:48.160 --> 36:51.840
对不对好然后加这边fiber root node就把这个current指向这边

36:52.480 --> 36:56.880
指向这边之后然加这边这棵树就是我的这个current fiber tree而这边

36:57.440 --> 37:02.000
这边的话就再次成为了什么是不是再次成为了这个vip fiber tree

37:02.880 --> 37:11.360
对不对好这个的话就是这个fiber双簧存的这个工作原理啊这个就是fiber

37:12.880 --> 37:16.480
双簧存的工作原理

37:17.040 --> 37:21.680
ok 其实就是类似于这个显卡这个前缓中区和后缓中区啊

37:22.240 --> 37:24.960
好另外有一点还需要说一下啊就另外

37:26.480 --> 37:28.480
值得一提的是

37:30.080 --> 37:37.360
什么呢就开发者的话他可以在一个页面创建多个应用的啊开发者是可以

37:37.920 --> 37:43.600
在一个页面创建多个应用的

37:44.400 --> 37:46.400
那比如啊比如下面这个

37:48.320 --> 37:54.240
比如这边啊把这个我把他过来比如像这样子

37:56.160 --> 38:01.520
啊像这样子那你看我这边这边呢我是不是创建了这个三个应用对不对

38:02.560 --> 38:07.520
啊在上面的代码中我们创建了

38:08.320 --> 38:12.720
三个应用那这三个应用的话啊此时

38:13.760 --> 38:19.920
就会存在什么呢存在三个这个fiber root node

38:20.960 --> 38:25.120
对不对啊然后以及对应这个最多

38:25.760 --> 38:33.650
多少颗数啊六颗对吧以及对应最多六颗这个fiber tree

38:37.070 --> 38:40.830
对不对因为你一个一个的话他最多对应两颗嘛对不对

38:40.910 --> 38:44.750
他这边呢就是你这边三个三个他对应六颗啊这点注意

38:45.310 --> 38:49.550
ok啊这就是关于这个fiber双缓冲啊

38:50.270 --> 38:53.070
好完了之后然后像我们这边我们来看一下这个题目啊

38:53.870 --> 38:59.310
谈一谈你对react的这个fiber的理解以及什么是fiber双缓冲

38:59.710 --> 39:05.310
那这个的话你是不是就可以回答了对吧好这边让我把这个整个这个参考单

39:05.950 --> 39:06.670
我把他过来

39:08.510 --> 39:09.710
好把他放到这里

39:11.790 --> 39:19.390
fiber的话可以从三个方面去理解啊作为一种架构作为一种数据类型啊作为这个动态的工作单元

39:20.030 --> 39:23.550
啊什么叫做fiber双缓冲呢啊他是指的在内存中

39:23.870 --> 39:28.830
这个构建两棵树啊并直接在内存中进行这个替换的这个技术

39:29.550 --> 39:33.790
啊在这个react中他有什么呢他有这个vibre fiber tree和current fiber tree

39:34.430 --> 39:38.990
通过这两棵树来实现这个相应的这个逻辑啊你这边的话把这个

39:39.470 --> 39:43.950
这个描述可以自己看一下啊然后回通了通过就是自己的话

39:44.510 --> 39:46.750
最好通过自己的话能够把它说出来

39:47.630 --> 39:54.350
好吧 okay啊这就是关于这个fiber双缓冲啊我们这些课就针对这个fiber

39:54.830 --> 40:00.670
再次做了一个这个介绍啊以及就是什么是这个fiber双缓冲啊给大家介绍了一下

40:01.390 --> 40:07.310
ok啊这就是关于这期课的这个内容啊这期课就到这里啊再见

