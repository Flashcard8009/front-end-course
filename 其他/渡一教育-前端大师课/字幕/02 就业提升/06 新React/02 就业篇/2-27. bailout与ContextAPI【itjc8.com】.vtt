WEBVTT

00:00.000 --> 00:05.000
OK 好 上节课的话 我们讲了这个build out 啊 这个优化策略

00:05.000 --> 00:09.500
好 其中我们说的 就是关于这个context这个API

00:09.500 --> 00:15.500
它的话是经过一次这个重购的 对吧 那为什么要重购它呢

00:15.500 --> 00:19.000
实际上就和这个旧版的这个context API

00:19.000 --> 00:23.500
它有存在一定的这个缺陷 有关系 OK

00:23.500 --> 00:25.500
好 主动我们这节课的话 我们就来看一下啊

00:25.500 --> 00:30.500
这边这道面识题也是在问 为什么要重购这个context API

00:30.500 --> 00:34.000
旧版的话 它这个context API有什么问题

00:34.000 --> 00:38.500
实际上就和这个build out这个策略 它有关系 OK

00:38.500 --> 00:40.500
好 我们这边一点一点来看啊

00:40.500 --> 00:42.500
好 首先的话这边context

00:43.500 --> 00:46.500
context API 经历过

00:47.500 --> 00:52.070
经历过一次这个重购

00:52.070 --> 00:57.070
重购的原因和什么呢 和这个build out

00:57.070 --> 01:00.070
build out策略行为

01:01.070 --> 01:04.070
那么旧版的话 存在一些什么样的这个缺陷呢

01:04.070 --> 01:10.070
在这个旧版 旧版的这个context API中

01:10.070 --> 01:14.070
它这个就是数据的话 它是保存在站里面的

01:14.070 --> 01:21.640
数据是保存在站 保存在站里面的

01:21.640 --> 01:25.640
然后在这个begin work的时候 它的这个context

01:25.640 --> 01:28.640
它会不断的什么呢 不断的入站

01:28.640 --> 01:31.640
然后接下来你不是有一个context consumer吗

01:31.640 --> 01:35.640
对吧 就是你这个数据的这个消费者

01:35.640 --> 01:39.640
然后它就可以通过什么呢 它就可以通过你这个context站

01:39.640 --> 01:44.640
一层一层的这个向上 找到对应的这个context value

01:44.640 --> 01:48.640
那么在这个complete work中 整个这个context

01:48.640 --> 01:57.640
它会不断的进行这个出站 在begin work中

01:57.640 --> 02:04.640
context会不断的入站 不断的入站

02:04.640 --> 02:08.640
它有一个叫做context的站 context的站

02:08.640 --> 02:11.640
就你在begin work中 它就会不断的进入到这个站

02:11.640 --> 02:16.640
进入到这个站之后 然后这意味着什么呢

02:16.640 --> 02:19.640
这意味着就是你的这个context

02:19.640 --> 02:23.640
然后consumer 就是你数据的这个消费者

02:23.640 --> 02:26.640
对不对 Context consumer

02:26.640 --> 02:32.640
可以通过什么呢 可以通过这个context站

02:32.640 --> 02:39.640
来找到对应的这个context数据

02:40.640 --> 02:46.640
好然后在这个complete work中

02:46.640 --> 02:54.640
这个context context会不断不断的出站

02:54.640 --> 02:56.640
一个入站一个出站

02:56.640 --> 03:02.640
那么这种入站出站的模式 是不是刚好就对应了这个reconcel流产

03:02.640 --> 03:06.640
对不对你reconcel流产里面 是不是有个begin work和complete work

03:06.640 --> 03:11.640
对吧begin work里面 它入站complete 它这个出站

03:11.640 --> 03:19.640
就这种模式 这种入站出站的模式

03:19.640 --> 03:24.640
刚好对应了什么呢 刚好对应了这个reconcel

03:24.640 --> 03:28.640
reconcel的这个流产

03:28.640 --> 03:33.640
以及什么呢 以及一般的这个build out策略

03:34.640 --> 03:37.640
那么这种的话 存在什么样的缺陷呢

03:37.640 --> 03:42.640
那么旧版 旧版的这个context api

03:42.640 --> 03:47.640
存在什么缺陷呢 它存在的缺陷的话 主要就是什么呢

03:47.640 --> 03:52.640
主要就是针对跳过整颗指数的这个begin work

03:52.640 --> 03:55.640
这种程度的这个build out策略

03:55.640 --> 03:57.640
我们上期课再讲这个build out的时候

03:57.640 --> 04:01.640
我们讲过就是有一种这种 后面有一种这种优化程度很高的

04:01.640 --> 04:06.640
它是什么 它是会跳过整颗指数的这个begin work的 对不对

04:06.640 --> 04:10.640
但是针对哪一种呢 针对这种

04:10.640 --> 04:17.640
就是跳过 跳过整颗指数的这个begin work

04:17.640 --> 04:25.640
然后这种程度 这种程度的这个build out策略

04:25.640 --> 04:29.640
那么被跳过的这个指数 它就不会在干嘛

04:29.640 --> 04:33.640
你看你这边这个指数 它的这个begin work都被跳过了

04:33.640 --> 04:37.640
它还有没有这个行为 还有没有这个入站的行为

04:37.640 --> 04:43.640
这就没有 对不对 被跳过 被跳过的这个指数

04:43.640 --> 04:48.640
就不会在干嘛呢 在这个精力

04:48.640 --> 04:55.640
这个context 这个入站 出站的这个过程

04:55.640 --> 05:03.640
ok 因此如果使用这个就的context api

05:03.640 --> 05:08.640
这个sign my star 如果使用就的这个context api

05:08.640 --> 05:14.640
那么即使 即使这个context 即使此时

05:14.640 --> 05:22.080
此时context 里面的数据 里面的这个数据

05:22.080 --> 05:25.080
发生了这个变化

05:26.080 --> 05:36.080
但是因为指数命中了 命中了这个build out策略

05:36.080 --> 05:41.080
被什么呢 被整颗跳过了 对不对

05:41.080 --> 05:49.080
然后所以这个指数 指数中的这个context consumer

05:49.080 --> 05:54.080
context consumer 就不会什么呢

05:54.080 --> 05:59.080
就不会这个响应更新

05:59.080 --> 06:03.080
它主要存在的就是这个问题 针对这种策略

06:03.080 --> 06:07.080
就是你跳过整颗指数begin work的这种策略

06:07.080 --> 06:11.080
它会存在问题 怎么问题呢 就是不会响应更新的问题

06:11.080 --> 06:13.080
那它为什么不会响应更新呢

06:13.080 --> 06:16.080
因为你整颗指数的这个begin work

06:16.080 --> 06:19.080
所以被跳过了 而你之前的话它是什么

06:19.080 --> 06:23.080
它之前的话在这个begin work中 它的这个context是要不断的

06:23.080 --> 06:25.080
是入站的 对不对

06:25.080 --> 06:27.080
那complete work这个context会不断的出站

06:27.080 --> 06:30.080
你连这个begin work都被跳过了

06:30.080 --> 06:34.080
那么自然而然你这个context入站出站的这个过程

06:34.080 --> 06:36.080
这就没有了 对不对

06:36.080 --> 06:40.080
说它会存在这样子的这么一个问题

06:40.080 --> 06:42.080
那比如说我们这边我们来看个实例

06:42.080 --> 06:46.080
例如有如下的代码

06:48.080 --> 06:51.080
好 比如说这边的话 我有这么一段代码

06:51.080 --> 06:53.080
这边大家可以看一下

06:53.080 --> 06:54.080
这个代码其实很简单

06:54.080 --> 06:57.080
这个代码的话 这边我把它折一下

06:57.080 --> 06:59.080
把它折一下 这边大家看一下

06:59.080 --> 07:00.080
我们一点一点来看嘛

07:00.080 --> 07:03.080
首先的话 这边有个nam provider

07:03.080 --> 07:04.080
这个是一个组件

07:04.080 --> 07:07.080
然后里面有个什么呢 里面有个middle

07:07.080 --> 07:08.080
对不对

07:08.080 --> 07:12.080
好 然后接下来这个nam provider是它

07:12.080 --> 07:14.080
它的话接收一个什么呢 接收一个这个children

07:14.080 --> 07:15.080
children就是什么

07:15.080 --> 07:17.080
children是不是就是这个middle

07:17.080 --> 07:19.080
对不对 就是这个组件

07:19.080 --> 07:21.080
middle这个组件

07:21.080 --> 07:23.080
好 那接下来我们来看一下这个nam provider

07:23.080 --> 07:25.080
nam provider做了什么

07:25.080 --> 07:26.080
在nam provider里面

07:26.080 --> 07:29.080
它这边的话是不是创建了一个数据

07:29.080 --> 07:30.080
对不对

07:30.080 --> 07:35.080
在这个nam provider

07:35.080 --> 07:38.080
providers中

07:38.080 --> 07:41.080
维护了一个数据

07:41.080 --> 07:43.080
维护了一个数据之后

07:43.080 --> 07:44.080
然后接下来这边的话

07:44.080 --> 07:45.080
使用到了这个providers

07:45.080 --> 07:47.080
providers来自于什么

07:47.080 --> 07:50.080
providers来自于这个上下文

07:50.080 --> 07:53.080
对不对 这边是创建了一个上下文

07:53.080 --> 07:58.080
创建了一个context的上下文

07:58.080 --> 08:00.080
那因此在这边 这边相当于就是

08:00.080 --> 08:03.080
把你的这个nam provider中维护的数据

08:03.080 --> 08:05.080
放入到了上下文里面

08:05.080 --> 08:06.080
对不对

08:06.080 --> 08:14.080
将这个nam数据放入到了

08:14.080 --> 08:18.960
放入到了这个上下文中

08:18.960 --> 08:19.960
对不对

08:19.960 --> 08:20.960
放入到上下文中

08:20.960 --> 08:21.960
好 然后接下来的话

08:21.960 --> 08:22.960
这边有个button

08:22.960 --> 08:23.960
button的话

08:23.960 --> 08:24.960
这边是修改这个nam

08:24.960 --> 08:26.960
然后加这边这个children

08:26.960 --> 08:27.960
children的话是这边传入的

08:27.960 --> 08:28.960
传入的是什么呢

08:28.960 --> 08:29.960
传入的是middle

08:29.960 --> 08:31.960
好 我们来看一下这个middle在做什么

08:31.960 --> 08:33.960
middle是这个中间的这个组件

08:33.960 --> 08:34.960
中间这个组件

08:34.960 --> 08:35.960
然后接下来这边

08:35.960 --> 08:36.960
这边是不是调用了这个

08:36.960 --> 08:39.960
should component update

08:39.960 --> 08:40.960
对不对

08:40.960 --> 08:43.960
我们这边的话是直接返回force

08:43.960 --> 08:48.470
直接返回force

08:48.470 --> 08:50.470
那直接返回force意味着什么

08:50.470 --> 08:51.470
是不是意味着

08:51.470 --> 08:58.470
意味着会命中这个build out策略

08:58.470 --> 08:59.470
对不对

08:59.470 --> 09:01.470
好 然后回头来这边返回这个choud

09:01.470 --> 09:02.470
choud这边就干嘛呢

09:02.470 --> 09:04.470
choud这边就从这个上下文中

09:04.470 --> 09:06.470
获取数据

09:06.470 --> 09:10.470
从context的上下文中

09:10.470 --> 09:12.470
获取数据

09:12.470 --> 09:14.470
然后渲染

09:14.470 --> 09:16.840
然后渲染

09:16.840 --> 09:18.840
整个结构的话就是这样子的

09:18.840 --> 09:19.840
也就是最终的话

09:19.840 --> 09:22.840
choud渲染的数据是来自于上下文的

09:22.840 --> 09:23.840
对不对

09:23.840 --> 09:28.840
也就是说最终这个choud

09:28.840 --> 09:31.840
choud的组件

09:31.840 --> 09:34.840
所渲染的数据

09:34.840 --> 09:38.840
不是自身组件的

09:38.840 --> 09:41.840
而是来自于什么呢

09:41.840 --> 09:43.840
来自于上下文

09:43.840 --> 09:45.840
其中

09:45.840 --> 09:48.840
其中就是它的这个副组件

09:48.840 --> 09:53.160
它的这个副组件

09:53.160 --> 09:56.160
副组件会命中什么

09:56.160 --> 09:59.160
是不是会命中build out策略

09:59.160 --> 10:00.160
对不对

10:00.160 --> 10:02.160
命中build out策略

10:02.160 --> 10:04.160
好 这个例子的话

10:04.160 --> 10:06.160
这个例子的话其实没什么

10:06.160 --> 10:07.160
这边的话大家可以看效果

10:07.160 --> 10:09.160
效果的话这边其实就是

10:09.160 --> 10:11.160
这边一个按钮

10:11.160 --> 10:13.160
这边的话我把这个放大点

10:13.160 --> 10:14.160
好 这边的话一个按钮

10:14.160 --> 10:15.160
这边还有一个数字

10:15.160 --> 10:17.160
你点击的话这边是加一

10:17.160 --> 10:18.160
看到没有 效果没什么

10:18.160 --> 10:20.160
但是你要知道这边的话

10:20.160 --> 10:21.160
这个是哪个组件

10:21.160 --> 10:24.160
这个的话是你的这个choud的组件

10:24.160 --> 10:26.160
它的数据是来自于上下文的

10:26.160 --> 10:27.160
而这个按钮

10:27.160 --> 10:29.160
按钮是来自于哪里

10:29.160 --> 10:32.160
按钮的话是来自于这个nam provider

10:32.160 --> 10:33.160
对不对

10:33.160 --> 10:34.160
也就是这边的话

10:34.160 --> 10:35.160
实际上是有一个这个

10:35.160 --> 10:36.160
组件层次关系的

10:36.160 --> 10:38.160
不是说在一个组件里面

10:38.160 --> 10:41.160
好 就是这么一个例子

10:41.160 --> 10:44.160
我把它放到笔记里面

10:44.160 --> 10:45.160
OK

10:45.160 --> 10:49.160
那么在这个上面的这个视力中

10:49.160 --> 10:53.160
在上面的视力中

10:53.160 --> 10:55.160
我们的这个APP

10:55.160 --> 10:57.160
APP是什么呢

10:57.160 --> 10:59.160
是挂在的组件

10:59.160 --> 11:00.160
对不对

11:00.160 --> 11:04.160
好 然后叫这个nam provider

11:04.160 --> 11:06.160
nam provider是什么呢

11:06.160 --> 11:09.160
是这个context

11:09.160 --> 11:12.600
然后接下来 provider

11:12.600 --> 11:15.600
这不就是你上下文的提供着

11:15.600 --> 11:18.600
上下文的提供着

11:18.600 --> 11:19.600
对不对

11:19.600 --> 11:21.600
然后这个choud

11:21.600 --> 11:22.600
choud是什么呢

11:22.600 --> 11:24.600
choud是context

11:24.600 --> 11:26.600
这个consumer

11:26.600 --> 11:28.600
就是你这个上下文

11:28.600 --> 11:31.600
上下文的消费者

11:31.600 --> 11:32.600
对不对

11:32.600 --> 11:35.600
好 然后接下来在这个APP

11:35.600 --> 11:39.600
在APP和这个choud之间

11:39.600 --> 11:41.600
有一个什么呢

11:41.600 --> 11:43.600
有一个middle

11:43.600 --> 11:46.600
然后我们在这个middle

11:46.600 --> 11:48.600
组件中

11:48.600 --> 11:50.600
直接使用了什么呢

11:50.600 --> 11:53.600
直接使用了这个性能优化

11:53.600 --> 11:55.600
APP对吧

11:55.600 --> 12:00.970
然后设置这个choud component update

12:00.970 --> 12:03.970
设置这个wayforce

12:03.970 --> 12:07.970
然后使其直接命中什么

12:07.970 --> 12:11.970
是不是直接命中这个build out策略

12:11.970 --> 12:12.970
对不对

12:12.970 --> 12:14.970
那么如果

12:14.970 --> 12:16.970
这边当这个点击

12:16.970 --> 12:18.970
当点击这个button

12:18.970 --> 12:20.970
button之后

12:20.970 --> 12:23.970
这个nam会这个增加

12:23.970 --> 12:24.970
对吧

12:24.970 --> 12:25.970
但是

12:25.970 --> 12:30.970
如果是在旧版的这个context

12:31.970 --> 12:34.970
context API中

12:34.970 --> 12:35.970
这段代码的话

12:35.970 --> 12:37.970
它是会存在缺陷的

12:37.970 --> 12:45.970
这段代码是会存在缺陷的

12:45.970 --> 12:47.970
ok 存在什么缺陷呢

12:47.970 --> 12:50.970
就是你的这个nam不会这个增加

12:50.970 --> 12:55.970
在旧版这个context API中

12:55.970 --> 12:57.970
点击

12:57.970 --> 12:58.970
应该这样说

12:58.970 --> 13:01.970
在旧版的这个context API中

13:01.970 --> 13:03.970
指数

13:03.970 --> 13:06.970
指数的这个beginwork

13:06.970 --> 13:10.970
beginwork都会被跳过

13:10.970 --> 13:11.970
对不对

13:11.970 --> 13:13.970
这意味着

13:13.970 --> 13:15.970
这意味着这个choud

13:15.970 --> 13:19.970
choud的组件的这个beginwork

13:19.970 --> 13:23.970
beginwork也会被跳过

13:23.970 --> 13:25.970
表现出来

13:25.970 --> 13:28.970
表现出来的这个现象

13:28.970 --> 13:29.970
就是什么呢

13:29.970 --> 13:33.970
就是点击button后

13:33.970 --> 13:36.970
点击button后

13:36.970 --> 13:39.970
这个nam不变

13:39.970 --> 13:40.970
对吧

13:40.970 --> 13:41.970
这就刚才所说的

13:41.970 --> 13:43.970
你这边因为都被跳过了

13:43.970 --> 13:44.970
所以指数里面

13:44.970 --> 13:46.970
它的这个context的consumer

13:46.970 --> 13:48.970
它不会相应更新

13:48.970 --> 13:49.970
在我们这个例子里面

13:49.970 --> 13:51.970
你如果使用旧版的

13:51.970 --> 13:52.970
你这边到时候

13:52.970 --> 13:53.970
就是你点击按钮的时候

13:53.970 --> 13:55.970
就你这边点击这个按钮的时候

13:55.970 --> 13:56.970
你会发现就是

13:56.970 --> 13:58.970
它得不到变化

13:58.970 --> 13:59.970
得不到变化

13:59.970 --> 14:00.970
ok

14:00.970 --> 14:01.970
新版的话

14:01.970 --> 14:03.970
主要就是修复这个问题

14:03.970 --> 14:04.970
ok

14:04.970 --> 14:05.970
那么它这个具体

14:05.970 --> 14:07.970
具体是如何修复的呢

14:07.970 --> 14:08.970
那么接下来

14:08.970 --> 14:09.970
第二个问题

14:09.970 --> 14:10.970
第一个问题就是

14:10.970 --> 14:12.970
旧版它存在什么样的缺陷

14:12.970 --> 14:13.970
这个我们刚才讲了

14:13.970 --> 14:14.970
对吧

14:14.970 --> 14:15.970
旧版这个context API

14:15.970 --> 14:16.970
存在什么缺陷

14:16.970 --> 14:17.970
主要就是和你的

14:17.970 --> 14:19.970
这个bailout策略有关系

14:19.970 --> 14:20.970
好那接下来

14:20.970 --> 14:22.970
我们来看一下新版

14:22.970 --> 14:25.970
那么新版

14:26.970 --> 14:27.970
新版

14:27.970 --> 14:28.970
打成针子了

14:28.970 --> 14:32.970
那么新版的这个context API

14:32.970 --> 14:36.970
是如何修复的呢

14:38.970 --> 14:39.970
它是如何修复的呢

14:39.970 --> 14:41.970
它这边是这个样子的

14:41.970 --> 14:42.970
它这边的话

14:42.970 --> 14:43.970
在这个beginwork

14:43.970 --> 14:47.970
进行到这个ctx provider的时候

14:47.970 --> 14:48.970
它对应的话

14:48.970 --> 14:50.970
这边会有一个这个逻辑处理

14:52.970 --> 14:54.970
当这个beginwork

14:56.970 --> 14:58.970
然后进行到

14:58.970 --> 15:00.970
这个context

15:00.970 --> 15:02.970
context provider

15:03.970 --> 15:05.970
provider的时候

15:06.970 --> 15:08.970
然后对应就是会有

15:09.970 --> 15:10.970
会

15:11.970 --> 15:15.970
会有如下的这个处理逻辑

15:17.970 --> 15:18.970
OK

15:18.970 --> 15:19.970
我们把这个代码

15:19.970 --> 15:20.970
把它过来

15:20.970 --> 15:25.330
这边

15:25.330 --> 15:26.330
你看这里

15:26.330 --> 15:27.330
这里的话

15:27.330 --> 15:28.330
它会判断什么呢

15:28.330 --> 15:29.330
它会首先

15:29.330 --> 15:31.330
它会判断你的这个

15:31.330 --> 15:32.330
context value

15:32.330 --> 15:33.330
是否有变化

15:34.330 --> 15:35.330
在上面的代码中

15:36.330 --> 15:38.330
在上面的代码中

15:38.330 --> 15:39.330
首先

15:40.330 --> 15:43.330
首先会判断

15:43.330 --> 15:45.330
context value

15:45.330 --> 15:48.330
是否有变化

15:48.330 --> 15:49.330
OK

15:49.330 --> 15:51.330
好如果没有变化

15:51.330 --> 15:52.330
它这边的话就是干嘛呢

15:52.330 --> 15:55.330
它这边就会命中这个bailout策略

15:55.330 --> 15:56.330
对吧

15:56.330 --> 15:57.330
好如果有变化

15:57.330 --> 15:58.330
有变化的话

15:58.330 --> 16:01.330
它会继续向下寻找这个consumer

16:01.330 --> 16:02.330
OK

16:02.330 --> 16:03.330
然后接下来

16:03.330 --> 16:04.330
它会做一个什么呢

16:04.330 --> 16:05.330
它会做一个标记

16:05.330 --> 16:07.330
它就和以前不一样了

16:07.330 --> 16:09.330
所以你同样是不会入占

16:09.330 --> 16:10.330
对吧

16:10.330 --> 16:12.330
它和这个就版是一样的

16:12.330 --> 16:13.330
不会入占

16:13.330 --> 16:14.330
但是呢它这边会干嘛呢

16:14.330 --> 16:15.330
这边它会

16:15.330 --> 16:17.330
就是向下寻找这个

16:17.330 --> 16:18.330
context consumer

16:18.330 --> 16:20.330
寻找这个数据的消费者

16:20.330 --> 16:22.330
然后接下来给他们做一个什么呢

16:22.330 --> 16:23.330
接下来给他们做一个标记

16:23.330 --> 16:25.330
你看这边是不是有个net

16:25.330 --> 16:26.330
对不对

16:26.330 --> 16:27.330
这边有个net

16:27.330 --> 16:29.330
它会做一个这个标记

16:29.330 --> 16:31.900
啊

16:31.900 --> 16:35.900
当这个context value

16:35.900 --> 16:37.900
发生变化时

16:37.900 --> 16:39.900
这个begin walk

16:39.900 --> 16:44.920
begin walk

16:44.920 --> 16:45.920
它会干嘛呢

16:45.920 --> 16:48.920
会从这个provider

16:48.920 --> 16:50.920
provider

16:50.920 --> 16:53.920
从provider立刻

16:53.920 --> 16:55.920
这个向下

16:55.920 --> 16:58.920
向下开启这个一次

16:58.920 --> 17:00.920
深度优先便利

17:00.920 --> 17:01.920
ok

17:01.920 --> 17:02.920
那它这个开启这个

17:02.920 --> 17:03.920
深度优先便利

17:03.920 --> 17:04.920
它的目的是什么呢

17:04.920 --> 17:07.920
目的就是为了

17:07.920 --> 17:10.920
寻找这个context

17:10.920 --> 17:13.920
context consumer

17:13.920 --> 17:14.920
ok

17:14.920 --> 17:17.920
就是寻找你这个数据的这个消费者

17:17.920 --> 17:21.920
如果一旦找到

17:21.920 --> 17:24.920
context consumer

17:24.920 --> 17:25.920
一旦找到

17:25.920 --> 17:27.920
那么就会

17:27.920 --> 17:28.920
为什么呢

17:28.920 --> 17:31.920
为对应的这个fiber node

17:31.920 --> 17:33.920
为你fiber节点

17:33.920 --> 17:35.920
这个点net上面

17:35.920 --> 17:36.920
上面

17:36.920 --> 17:38.920
附加

17:38.920 --> 17:39.920
附加一个什么呢

17:39.920 --> 17:40.920
附加一个这个

17:40.920 --> 17:42.920
undernet

17:42.920 --> 17:46.610
附加一个undernet

17:46.610 --> 17:47.610
对应的逻辑

17:47.610 --> 17:50.610
对应的相关逻辑

17:50.610 --> 17:52.610
如下

17:52.610 --> 17:55.610
把这个逻辑把拿过来

17:55.610 --> 18:02.080
在这里

18:02.080 --> 18:03.080
ok

18:03.080 --> 18:04.080
原来这边

18:04.080 --> 18:05.080
这边的话

18:05.080 --> 18:06.080
会有一个这个schedule

18:06.080 --> 18:08.080
walk on this point pass

18:08.080 --> 18:10.080
这个方法的作用就是什么呢

18:10.080 --> 18:11.080
这个方法的作用就是

18:11.080 --> 18:13.080
从这个context consumer

18:13.080 --> 18:15.080
向上便利

18:15.080 --> 18:17.080
然后一次为这个

18:17.080 --> 18:19.080
主线的这个fiber node

18:19.080 --> 18:20.080
这个choudness

18:20.080 --> 18:22.080
附加这个underness

18:22.080 --> 18:24.080
ok

18:24.080 --> 18:31.620
上面

18:31.620 --> 18:35.620
上面的这个schedule

18:35.620 --> 18:36.620
schedule

18:36.620 --> 18:37.620
walk on this point pass

18:37.620 --> 18:40.620
这个方法的作用

18:40.620 --> 18:41.620
是什么呢

18:41.620 --> 18:45.620
是从这个context consumer

18:45.620 --> 18:48.620
然后向上便利

18:48.620 --> 18:50.930
向上便利

18:50.930 --> 18:52.930
然后一次

18:52.930 --> 18:53.930
为什么呢

18:53.930 --> 18:55.930
为这个主线

18:55.930 --> 18:57.930
主线的这个fiber node

18:57.930 --> 18:59.930
然后到什么呢

18:59.930 --> 19:02.930
到这个choudness

19:02.930 --> 19:04.930
choudness

19:04.930 --> 19:06.930
然后附加

19:06.930 --> 19:12.330
附加这个underness

19:12.330 --> 19:15.330
给它加上这个ness

19:15.330 --> 19:17.330
ok

19:17.330 --> 19:18.330
好因此的话

19:18.330 --> 19:20.330
我们这边我们来总结一下

19:20.330 --> 19:24.330
因此我们来总结一下

19:24.330 --> 19:25.330
好这边呢

19:25.330 --> 19:26.330
究竟是个什么样的情况呢

19:26.330 --> 19:27.330
就是这边的话

19:27.330 --> 19:30.330
当你到这个provider的时候

19:30.330 --> 19:31.330
ok就你这边

19:31.330 --> 19:33.330
当你到这个provider的时候

19:33.330 --> 19:38.330
当这个context

19:38.330 --> 19:41.330
context value发生变化

19:41.330 --> 19:44.330
发生变化的时候

19:44.330 --> 19:46.330
然后这个begin walk

19:46.330 --> 19:48.330
begin walk

19:48.330 --> 19:50.330
从这个provider

19:50.330 --> 19:54.330
provider开始向下便利

19:54.330 --> 19:57.330
向下便利

19:57.330 --> 19:58.330
然后找到什么呢

19:58.330 --> 20:01.330
找到这个context consumer

20:01.330 --> 20:03.330
对找到这个

20:03.330 --> 20:05.330
上下文的这个消费者

20:05.330 --> 20:07.330
找到这个consumer之后

20:07.330 --> 20:13.330
然后为当前的fiber node

20:13.330 --> 20:15.330
标记一个什么

20:15.330 --> 20:19.640
标记一个这个underness

20:19.640 --> 20:20.640
对不对

20:20.640 --> 20:21.640
然后接下来再干嘛呢

20:21.640 --> 20:22.640
再往上便利

20:22.640 --> 20:27.640
再从这个context consumer

20:27.640 --> 20:30.640
向上便利

20:30.640 --> 20:31.640
向上便利然后干嘛呢

20:31.640 --> 20:32.640
向上便利

20:32.640 --> 20:36.640
然后为这个主先

20:36.640 --> 20:39.640
为主先的这个fiber node

20:39.640 --> 20:41.640
然后标记一个什么

20:41.640 --> 20:42.640
标记一个啊

20:42.640 --> 20:46.640
主先fiber node的这个childness

20:46.640 --> 20:49.640
点childness

20:49.640 --> 20:53.640
标记一个什么标记一个underness

20:53.640 --> 20:54.640
看到没有

20:54.640 --> 20:55.640
整体的流程的话

20:55.640 --> 20:57.640
实际上就是这样子的

20:57.640 --> 20:58.640
你注意就是

20:58.640 --> 21:00.640
无论是向下还是这个

21:00.640 --> 21:02.640
就是向下寻找这个consumer

21:02.640 --> 21:04.640
还是从这个consumer向上便利

21:04.640 --> 21:06.640
修改这个childness的过程

21:06.640 --> 21:08.640
它都发生在什么呢

21:08.640 --> 21:09.640
发生在这个provider的

21:09.640 --> 21:11.640
beginwork逻辑中

21:11.640 --> 21:19.640
注意无论无论是向下便利

21:19.640 --> 21:24.640
然后寻找这个context consumer

21:24.640 --> 21:25.640
还是什么呢

21:25.640 --> 21:30.640
还是从这个context consumer

21:30.640 --> 21:33.640
然后向上便利

21:33.640 --> 21:35.640
然后修改什么呢

21:35.640 --> 21:38.640
修改这个childness

21:38.640 --> 21:46.640
这个都发生在这个provider

21:46.640 --> 21:52.640
provider的这个beginwork逻辑中

21:52.640 --> 21:54.640
这一点的话要注意

21:54.640 --> 21:55.640
OK

21:55.640 --> 21:58.640
那么当你上面的这个流程完成之后

21:58.640 --> 22:00.640
即便你的这个provider

22:00.640 --> 22:03.640
命中了这个buildout策略

22:03.640 --> 22:05.640
但是由于你的这个childness

22:05.640 --> 22:07.640
就你这个东西

22:07.640 --> 22:09.640
这个东西是不是你已经做了标记了

22:09.640 --> 22:10.640
对不对

22:10.640 --> 22:12.640
说它这边就也能够

22:12.640 --> 22:14.640
正常的进行这个更新

22:14.640 --> 22:15.640
OK

22:15.640 --> 22:17.640
因此

22:17.640 --> 22:23.640
上面上上述上述的流程

22:23.640 --> 22:27.640
完成后

22:27.640 --> 22:31.640
虽然这个provider

22:31.640 --> 22:38.640
虽然这个provider命中了这个buildout策略

22:38.640 --> 22:40.640
但是由于什么呢

22:40.640 --> 22:43.640
由于流程中

22:43.640 --> 22:47.640
流程中这个childness

22:47.640 --> 22:52.470
childness已经被修改了

22:52.470 --> 22:53.470
对吧

22:53.470 --> 22:56.470
你这个childness它已经被修改了

22:56.470 --> 22:57.470
因此它就不会什么

22:57.470 --> 23:00.470
不会去命中这个跳过整颗指数

23:00.470 --> 23:04.470
因此就不会命中

23:04.470 --> 23:09.470
就是跳过整颗指数

23:09.470 --> 23:12.470
指数的这个beginwork

23:12.470 --> 23:16.970
beginwork的这个逻辑

23:16.970 --> 23:20.990
的逻辑

23:20.990 --> 23:21.990
OK

23:21.990 --> 23:22.990
相关代码

23:22.990 --> 23:24.990
相关代码如下

23:24.990 --> 23:26.990
你这边可以看一下

23:26.990 --> 23:35.610
把这个代码把它拿过来

23:36.610 --> 23:37.610
稍等

23:42.330 --> 23:44.330
马上马上我重新复制一下

23:44.330 --> 23:48.160
好 这里

23:48.160 --> 23:49.160
OK

23:49.160 --> 23:50.160
你可以看一下

23:50.160 --> 23:51.160
你看它这边的话

23:51.160 --> 23:52.160
这边是这个

23:52.160 --> 23:54.160
就你如果进入衣服

23:54.160 --> 23:55.160
你进入这个衣服

23:55.160 --> 23:56.160
这边就干嘛呢

23:56.160 --> 23:59.160
这边就是整颗指数命中这个buildout策略

23:59.160 --> 24:00.160
对不对

24:00.160 --> 24:01.160
但是你看它这边有个什么

24:01.160 --> 24:05.160
是不是increase上这个ness

24:05.160 --> 24:06.160
对不对

24:06.160 --> 24:07.160
它这边它就会去判断什么

24:07.160 --> 24:09.160
判断你的这个

24:09.160 --> 24:10.160
这个childness

24:10.160 --> 24:11.160
对不对

24:11.160 --> 24:12.160
它会根据你的这个ness

24:12.160 --> 24:13.160
做一个判断

24:13.160 --> 24:14.160
判断之后

24:14.160 --> 24:15.160
判断出来的结果

24:15.160 --> 24:16.160
这边它就不会命中这个

24:16.160 --> 24:17.160
看到没有

24:17.160 --> 24:20.160
它就是通过这种方式来解决的

24:20.160 --> 24:22.160
通过这种方式来解决的

24:22.160 --> 24:23.160
OK

24:23.160 --> 24:26.790
好 通过

24:26.790 --> 24:31.230
通过上面的这个代码

24:31.230 --> 24:33.230
我们可以看出

24:33.230 --> 24:34.230
怎么呢

24:34.230 --> 24:36.230
就是如果

24:36.230 --> 24:38.230
如果指数

24:38.230 --> 24:39.230
生数

24:39.230 --> 24:41.230
然后存在什么呢

24:41.230 --> 24:45.230
存在这个context consumer

24:45.230 --> 24:46.230
OK

24:46.230 --> 24:47.230
然后即使

24:47.230 --> 24:51.230
即使指数的这个根

24:51.230 --> 24:54.230
根这个fiber load

24:54.230 --> 24:55.230
命中了什么呢

24:55.230 --> 24:59.230
命中了这个buildout策略

24:59.230 --> 25:00.230
也不会什么呢

25:00.230 --> 25:09.230
由于存在这个childness的变化

25:09.230 --> 25:10.230
对不对

25:10.230 --> 25:11.230
你这上面的话

25:11.230 --> 25:13.230
这边会标记这个childness

25:13.230 --> 25:15.230
存在这个childness的变化

25:15.230 --> 25:16.230
就标记

25:16.230 --> 25:19.230
存在这个childness的标记

25:19.230 --> 25:20.230
因此

25:20.230 --> 25:21.230
什么呢

25:21.230 --> 25:24.230
不会完全跳过

25:24.230 --> 25:26.230
完全跳过

25:26.230 --> 25:29.230
指数的这个begin walk

25:29.230 --> 25:31.230
过程

25:31.230 --> 25:32.230
对吧

25:32.230 --> 25:35.230
所以新版的

25:35.230 --> 25:38.230
新版的这个context API

25:38.230 --> 25:40.230
能够实现什么呢

25:40.230 --> 25:42.230
能够实现更新

25:42.230 --> 25:43.230
解决了什么呢

25:43.230 --> 25:45.230
解决了旧版

25:45.230 --> 25:47.230
不能更新的问题

25:47.230 --> 25:51.230
解决了旧版context

25:52.230 --> 25:54.230
context API

25:54.230 --> 25:56.230
然后无法

25:56.230 --> 25:59.230
更新的这个问题

25:59.230 --> 26:00.230
喵喵

26:00.230 --> 26:01.230
这边的话

26:01.230 --> 26:02.230
它这个新版

26:02.230 --> 26:04.230
它是如何这个解决的

26:04.230 --> 26:05.230
这边让人家知道

26:05.230 --> 26:06.230
它主要就是通过什么

26:06.230 --> 26:08.230
主要通过这个

26:08.230 --> 26:10.230
修改这个childness

26:10.230 --> 26:11.230
对不对

26:11.230 --> 26:12.230
这边给它做一个标记

26:12.230 --> 26:14.230
然后叫你回头你这边命中的时候

26:14.230 --> 26:16.230
这边我会针对你这个net

26:16.230 --> 26:17.230
做这个判断

26:17.230 --> 26:19.230
对不对

26:19.230 --> 26:20.230
OK

26:20.230 --> 26:22.230
这是关于这个buildout策略

26:22.230 --> 26:24.230
和这个context API

26:24.230 --> 26:27.230
回头让我来看一下这个题目

26:27.230 --> 26:30.230
为什么要重构这个context API

26:30.230 --> 26:32.230
旧版的这个context API

26:32.230 --> 26:33.230
有什么问题

26:33.230 --> 26:35.230
现在回答的话就很简单了

26:35.230 --> 26:36.230
好把这边

26:36.230 --> 26:38.230
这边过来

26:38.230 --> 26:40.860
OK

26:40.860 --> 26:43.860
旧版的context API存在一些缺陷

26:43.860 --> 26:44.860
对吧

26:44.860 --> 26:46.860
那context数据是保存在站里面的

26:46.860 --> 26:48.860
beginwork它会入站

26:48.860 --> 26:51.860
然后completework它会出站

26:51.860 --> 26:54.860
而你的每一个这个数据的消费者

26:54.860 --> 26:55.860
它就可以通过什么了

26:55.860 --> 26:57.860
它就可以通过这个context站

26:57.860 --> 26:59.860
找到对的context value

26:59.860 --> 27:00.860
对不对

27:00.860 --> 27:01.860
但是你旧版

27:01.860 --> 27:02.860
旧版的话

27:02.860 --> 27:04.860
你针对这种情况

27:04.860 --> 27:07.860
针对这种跳过了整颗指数

27:07.860 --> 27:08.860
beginwork

27:08.860 --> 27:11.860
针对这种情况的这个buildout策略

27:11.860 --> 27:13.860
那你这个指数的这个consumer

27:13.860 --> 27:14.860
它就得不到什么

27:14.860 --> 27:15.860
得不到更新

27:15.860 --> 27:16.860
对不对

27:16.860 --> 27:18.860
因为你整个beginwork都跳过来

27:18.860 --> 27:19.860
对不对

27:19.860 --> 27:21.860
你都不存在这个入站出站的这个过程了

27:21.860 --> 27:22.860
那么新版

27:22.860 --> 27:24.860
新版的它会怎么做呢

27:24.860 --> 27:25.860
新版的话

27:25.860 --> 27:26.860
它会从这个 provider

27:26.860 --> 27:28.860
立刻向下开启一次

27:28.860 --> 27:30.860
这个深度优先便利

27:30.860 --> 27:33.860
找这个context的consumer

27:34.860 --> 27:35.860
找到之后

27:35.860 --> 27:38.860
然后给它对应的这个fiberloadnance

27:38.860 --> 27:40.860
附加这个undernance

27:41.860 --> 27:42.860
对不对

27:42.860 --> 27:43.860
附加了之后

27:43.860 --> 27:44.860
然后接下来你这个指数

27:44.860 --> 27:46.860
深处存在这个context

27:46.860 --> 27:48.860
因此你这个存在这个consumer

27:48.860 --> 27:49.860
它也能够什么呢

27:49.860 --> 27:51.860
也能够命中buildout

27:51.860 --> 27:53.860
这边写漏了一个

27:53.860 --> 27:55.860
为其对应的这个fiberloadnance

27:55.860 --> 27:57.860
附加这个undernance

27:57.860 --> 27:58.860
然后接下来它会干吗

27:58.860 --> 28:00.860
它是不是会有个向上边的

28:00.860 --> 28:01.860
对吧

28:01.860 --> 28:03.860
这边也把它放过来

28:03.860 --> 28:04.860
这边

28:04.860 --> 28:06.860
再从这里

28:10.200 --> 28:11.200
然后再从什么呢

28:11.200 --> 28:13.200
再从你的context consumer

28:13.200 --> 28:14.200
向上边

28:14.200 --> 28:15.200
对吧

28:15.200 --> 28:16.200
为祖先的fiberload

28:16.200 --> 28:18.200
敲的nance

28:18.200 --> 28:20.200
标记一个undernance

28:20.200 --> 28:21.200
然后回头了

28:21.200 --> 28:23.200
这边就会做一个判断

28:24.200 --> 28:25.200
好

28:25.200 --> 28:26.200
因此就是你的指数

28:26.200 --> 28:29.200
深处的context consumer

28:29.200 --> 28:30.200
即便什么呢

28:30.200 --> 28:32.200
即便你的跟fiberload

28:32.200 --> 28:34.200
并中了这个buildout策略

28:34.200 --> 28:36.200
它这边的话也就是

28:36.200 --> 28:38.200
这边它不能说

28:38.200 --> 28:40.200
因此不会完全跳过

28:40.200 --> 28:43.200
不会完全跳过指数的begin walk流程

28:43.200 --> 28:45.200
总之它这边反正数据

28:45.200 --> 28:46.200
它就会更新

28:46.200 --> 28:47.200
OK

28:47.200 --> 28:48.200
因为它这边会有个什么

28:48.200 --> 28:50.200
会有个这个chartnance的判断

28:50.200 --> 28:51.200
对不对

28:51.200 --> 28:52.200
不会

28:52.200 --> 28:54.200
我看不会完全跳过指数的

28:54.200 --> 28:55.200
begin walk流程

28:55.200 --> 28:56.200
对

28:56.200 --> 28:57.200
也算

28:57.200 --> 28:58.200
它就不会跳过了

28:58.200 --> 28:59.200
对不对

28:59.200 --> 29:00.200
OK

29:00.200 --> 29:03.200
这是关于这个buildout

29:03.200 --> 29:05.200
和这个context api

29:05.200 --> 29:07.200
我们这边把它单独拎出来

29:07.200 --> 29:09.200
给大家说了一下

29:09.200 --> 29:10.200
大家下来的话

29:10.200 --> 29:12.200
可以把这一块自己再看一下

29:12.200 --> 29:13.200
好不好

29:13.200 --> 29:15.200
这期课的话就到这里

29:15.200 --> 29:16.200
再见

