WEBVTT

00:00.180 --> 00:06.180
OK 这节课的话我们来看一下这个usecallback和usememo

00:06.180 --> 00:10.180
我们这边呢 仍然是看到面试题 这边的话他问你

00:10.180 --> 00:14.180
usecallback和usememo 它的这个区别是什么

00:14.180 --> 00:20.180
那么遇到这道面试题的话可能绝对多数同学的话就是会说一个他表面上的一个区别

00:20.180 --> 00:24.180
就usecallback他缓存这个缓存的是函数

00:24.180 --> 00:28.180
usememo的话他缓存的是这个值 对吧

00:28.180 --> 00:32.180
但其实这道面试题的话你如果可以达得更加深入一点的话

00:32.180 --> 00:38.180
你这边其实可以从他内部的这个mount阶段和这个update阶段来回答一下

00:38.180 --> 00:44.180
我们说过之前说过这个户口还是分为这个mount阶段和update阶段对不对

00:44.180 --> 00:47.180
好 那我们这边一个一个来看一下

00:47.180 --> 00:51.180
首先我们来看什么呢 来看这个usecallback

00:51.180 --> 00:56.810
好 usecallback我们首先先回顾一下他这个使用的方法

00:56.810 --> 01:02.810
usecallback用法如下

01:02.810 --> 01:08.630
好 他这边用法的话我就直接把他拿过来

01:08.630 --> 01:12.630
对应在这边 这边呢首先第一个 第一个是

01:12.630 --> 01:16.630
接收一个你要缓存的这个函数 第二个的话是依赖项

01:16.630 --> 01:21.630
对不对 好 大家这边返回一个什么呢 返回一个缓存的函数

01:21.630 --> 01:31.020
使用使用usecallback最终会得到

01:31.020 --> 01:37.020
一个缓存的 缓存的函数

01:37.020 --> 01:43.020
这个函数会在什么 所以这个函数会在这个a或者b发生变化时在雕用

01:43.020 --> 01:55.400
对不对 该函数会在a或者b发生变化时在雕用

01:55.400 --> 02:03.290
ok 这里应该不叫雕用 应该叫做在更新

02:03.290 --> 02:09.290
对吧 这个该缓存函数 该缓存函数会在a或者b

02:09.290 --> 02:14.290
a和b是什么 是你的依赖项吗 对吧 当你的这个a或者b这个依赖项

02:14.290 --> 02:23.290
或者b依赖项发生变化时在这个就是才会这个更新 对吧

02:23.290 --> 02:30.290
好 那我们这边让我们来看一下 看一下它分别的这个mount阶段以及update阶段

02:30.290 --> 02:38.290
ok 好 mount阶段 mount阶段的话 这边执行的就是什么呢 执行的就是mountcallback

02:38.290 --> 02:46.290
在mount阶段执行的就是mountcallback

02:46.290 --> 02:56.980
对吧 相关代码如下 我们这边来看一下它的这个代码 它的代码不多啊 代码不多

02:56.980 --> 03:03.980
那这边 这边的话接收一个callback啊 就你这边你要执行的这个函数以及你的依赖项

03:03.980 --> 03:07.980
好 首先的话还是什么 首先什么还是先创建一个互可对象

03:08.980 --> 03:18.980
首先还是创建一个互可对象啊 创建了互可对象之后 然后接下来的话 这边就是看你有没有这个依赖项

03:18.980 --> 03:23.980
对吧 看你是否是undefine 如果是undefine 这边就是个nau 否则就是你的依赖项

03:23.980 --> 03:28.980
好 然后接下来把它放到哪里去 放到互可的这个memored state上面

03:28.980 --> 03:34.980
啊 这个我们之前在讲那个互可原理那些课的时候我们说过 你不同类型的这个互可

03:34.980 --> 03:42.980
它的这个memored state 它存储的东西是不一样的 对不对 好 大家最终的话 返回这个callback

03:42.980 --> 03:48.980
返回这个callback 好 所以我们这边呢 我们来总结一下啊 在上面的代码中

03:48.980 --> 03:55.980
在上面的代码中 首先会调用什么 是不调用它

03:55.980 --> 04:01.980
对不对 首先调用它 得到一个互可对象

04:01.980 --> 04:07.980
得到互可对象之后 然后在互可对象上面

04:07.980 --> 04:14.980
呃 互可对象的这个memored state 上面

04:14.980 --> 04:22.980
呃 保存 保存什么呢 保存你的callback 以及依赖项目 对不对

04:22.980 --> 04:29.980
然后最后 向这个外部返回callback

04:30.980 --> 04:36.980
这个是它mount阶段所做的事情 好 然后接下来我们来看一下这个update阶段

04:36.980 --> 04:39.980
update阶段的话 这边update

04:40.980 --> 04:45.980
调用的是什么呢 调用的是updatecallback

04:45.980 --> 04:49.980
啊 然后相关代码如下

04:49.980 --> 04:55.360
好 我这边呢 把这个update的这个代码拿过来

04:56.360 --> 05:03.360
好 我这边来看一下 首先的话是这边 拿到之前的这个互可对象

05:03.360 --> 05:09.360
啊 从这个update walk in progress hook上面 拿到之前的 拿到之前之后

05:09.360 --> 05:13.360
然后接下来这边 判断一下这个新的依赖项 和之前是一样的

05:13.360 --> 05:18.360
对吧 是否是undefined 若是undefined就是now 否则就是存处你新的依赖项

05:18.360 --> 05:22.360
好 然后接下来这边 从这个hook.memored state上面

05:22.360 --> 05:27.360
拿到之前的缓冲的这个东西 也就是什么呢 也就是说这个数组

05:27.360 --> 05:32.360
是不是这个数组啊 你看这边 对不对 你之前缓冲缓冲的是个数组

05:32.360 --> 05:37.360
数组的第0项是你的callback 然后第1项是你的这个依赖项

05:37.360 --> 05:43.360
好 然后接下来的话就和什么呢 就和就是对比你的依赖项是否相同

05:43.360 --> 05:47.360
可不可以 它这边通过这个hook input equal

05:48.360 --> 05:55.360
这边看是否相同 如果相同的话就返回什么呢 返回这个prev state0

05:55.360 --> 06:00.360
prev是什么 prev state是这个数组 数组的0 是不就是这个callback

06:00.360 --> 06:06.360
也就是说直接返回之前的callback 否则干嘛呢 否则重新进行缓冲

06:06.360 --> 06:10.360
是不是重新进行缓冲 对不对啊 所以说这边

06:10.360 --> 06:25.390
在组件在组件更新阶段啊 首先拿到这个之前的hook对象

06:25.390 --> 06:34.150
拿到之后啊 接下来从什么呢 从之前的这个hook对象的什么

06:34.150 --> 06:42.150
这个memo的state上面 上面拿到之前的依赖项

06:43.150 --> 06:53.170
然后和新传入的这个依赖项 做一个对比 对吧

06:53.170 --> 07:06.170
如果相同 则返回之前的 就之前缓存的这个callback

07:06.170 --> 07:11.170
对不对啊 否则就什么呢 就重新缓冲

07:12.170 --> 07:21.170
重新缓存 返回新的callback 对不对啊 整体来讲的话 这个代码其实还是比较简单的啊

07:21.170 --> 07:29.120
关于这个usecallback 好 然后接下来我们来看一下这个usememo

07:29.120 --> 07:35.120
usememo 好 usememo的话 这边它的这个用法啊 用法如像

07:35.120 --> 07:42.120
我这边来回顾一下 它的话 其实返这个缓冲的是一个什么 是缓存的是一个值啊

07:43.120 --> 07:53.560
对不对啊 使用usememo 使用usememo缓存的是一个值 对吧

07:53.560 --> 07:58.560
它其实有点类似于什么 有点类似于那个view里面的计算属性

07:58.560 --> 08:06.560
有点类似于那个计算属性 这个值会在什么呢 会在a或者b

08:06.560 --> 08:16.560
这个发生变化的时候 然后重新进行计算 然后冰什么 冰缓存 是不这样子的

08:16.560 --> 08:21.560
对不对 好 然后接下来我们这边来看啊 首先这边mount阶段

08:21.560 --> 08:27.560
一会我们会看update阶段 还是分为这两个阶段来看

08:28.560 --> 08:32.560
好 这边首先这个mount阶段 mount阶段的话

08:33.560 --> 08:40.560
mount阶段调用的是什么呢 调用的是这个mountmemo啊 然后代码如像

08:43.580 --> 08:52.780
好 这边我把这个代码把它过来 好 这边 基本上的话 其实和之前的那个usecallback

08:52.780 --> 08:57.780
实际上是非常相似的 你不相似 我也不会放在一节课讲了 对不对

08:57.780 --> 09:01.780
之所以就是因为相似才 所以才会放到一节课里面讲啊

09:02.780 --> 09:10.780
这边的话也是 先这个创建这个hook对象 对不对 然后这边是哪一来向 然后之后然后接下来这边干嘛

09:10.780 --> 09:17.780
这边的话 直行传入的这个函数 这边你会传一个函数过来 直行 直行之后是不会得到一个值啊

09:17.780 --> 09:22.780
得到一个值之后 然后把它缓存到这个memo的state上面

09:22.780 --> 09:27.780
也就是你之前这边对应的第一项是什么 之前对应的这个第一项是一个callback

09:27.780 --> 09:33.780
现在对应的这个第一项是什么 这就是你直行函数之后得到的这个值啊 对不对

09:33.780 --> 09:42.250
基本上其实差不多的 好 我们这边来记录一下 在这个mount阶段

09:42.250 --> 09:53.250
首先会调用 当然是调用这个 调用这个方法 得到一个hook对象

09:53.250 --> 10:01.250
之后干嘛 之后直行传入的这个函数 这个传入函数是第一个函数

10:01.250 --> 10:08.250
ok 然后得到什么呢 得到计算值 得到计算值之后然后接下来将什么呢

10:08.250 --> 10:18.250
将计算值和依赖项目 然后存储到什么 存储到hook对象的

10:18.250 --> 10:27.560
这个这个memo state上面 对吧 我们之前说的不同hook 他这个缓存的值 他是不一样的啊

10:27.560 --> 10:38.560
然后最后 最后向这个外部返回什么 说返回这个计算得到的值啊

10:38.560 --> 10:44.560
对不对啊 这就是mount阶段 好 然后接下来的话看一下update阶段

10:44.560 --> 10:49.560
update阶段 然后调用的是什么呢 调用的是

10:49.560 --> 11:10.450
这个update memo 相关代码 如下 这边把这个update把它过来 啊 这里

11:10.450 --> 11:15.450
好 你看这边 这边仍然是 首先这边呢 是拦到之前的hook对象啊

11:15.450 --> 11:22.450
这个是新的依赖值 这个是通过这个prevostate 啊 拿到之前的这个依赖 对不对

11:22.450 --> 11:31.450
那通过这个prevostate1啊prevostate1就可以拿到什么 拿到这个next deeps 就是之前的这个依赖象

11:31.450 --> 11:37.450
啊 拿到之后同样是什么 同样是进行个对比 对不对啊 对比对比你这个依赖象是否相同

11:37.450 --> 11:44.450
你看一个是next deeps 一个是prevot deeps啊 就前后的依赖象是否相同 如果相同直接返回

11:44.450 --> 11:52.450
直接返回这个prevostate0 是什么 是不是就之前缓存的这个计算值啊 对不对

11:52.450 --> 11:58.450
否则就干嘛呢 否则就重新计算 对不对 就和之前的步骤一样的 重新计算啊

11:58.450 --> 12:11.180
好 所以我们这边 我们来看一下这边的步骤 这边呢 首先 首先 首先 仍然是从什么呢

12:11.180 --> 12:14.180
是从这个update

12:14.180 --> 12:30.180
update walk in progress hook上面 拿到什么呢 拿到之前的 hook对象啊 从而获取到什么呢 从而获取到之前的依赖项目

12:30.180 --> 12:39.180
对不对啊 然后和新传入的依赖项目进行一个对比

12:39.180 --> 12:57.180
啊 如果依赖 依赖项目没有变化 则返回什么 返回之前的计算值 否则就什么 就执行传入的这个函数

12:57.180 --> 13:09.180
然后重新进行这个计算 然后最后向这个外部返回什么 返回新的计算值

13:09.180 --> 13:16.180
对不对啊 这就是关于这个user memo 它的这个update阶段 ok

13:16.180 --> 13:23.180
那整个这个user callback user memo 它们的这个两个阶段的这个代码 我们基本上就把它大致的看了一下

13:23.180 --> 13:29.180
啊 整体来讲的话 实际上是比较简单的 对不对啊 回头的话 你这边你再来看这道面试题

13:29.180 --> 13:40.180
user callback 啊user memo 它们的这个区别是什么 那你这边呢 其实就不不仅仅是像之前啊 之前说的 就是之前所说的啊

13:40.180 --> 13:48.180
user callback 是缓存一个函数user memo 是缓存一个值啊 但它本质是这样子的 没错啊 本质确实是这样子的

13:48.180 --> 13:58.180
但是你现在的话 你看了它的那个mount阶段和那个update阶段 你能达到一些东西是吧 更多一些了 对不对啊 比如它会进行这个依赖的这个判断

13:58.180 --> 14:06.180
它具体怎么判断的 比如它通过这个啊 这个on hook input equal这个方法进行判断 你可以把这些说出来的

14:07.180 --> 14:13.180
啊 你可以把这些说出来的啊 比如它内部通过这个啊 hooks input equals 进行这个

14:13.180 --> 14:21.180
这个依赖是否相同的这个判断 判断完了之后 接下来又做什么 对不对啊 你可以就是说的更多一些啊

14:22.180 --> 14:26.180
好 这边呢 这个参考单啊 我把这个单我把它过来

14:30.610 --> 14:37.610
ok 这是参考单啊 在user callback 内部啊 它这边会把依赖相缓存到 hook对象的这个 memo state

14:38.610 --> 14:45.610
属性上啊 在逐渐更新的阶段 首先拿到之前的 hook对象啊 然后从之前的 hook对象的 memo

14:45.610 --> 14:53.610
这个 memo 的state 属性上面拿到之前的依赖象啊 进行一个对比 如果相同就就返回之前的这个callback

14:53.610 --> 15:04.610
否则就重新缓存 对不对 最后返回新的这个callback ok 大致就是啊 下面是这个user memo 我就不照理你了啊 基本上也差不多的 ok

15:05.610 --> 15:13.610
好 这就是关于这个user callback和user memo啊 大家下来可以自己再看一下 好不好 好 这些课就到这里啊 再见

