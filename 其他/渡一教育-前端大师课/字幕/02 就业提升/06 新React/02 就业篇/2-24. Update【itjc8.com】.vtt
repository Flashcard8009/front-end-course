WEBVTT

00:00.050 --> 00:04.050
这节课的话我们来看一下react中的这个update

00:04.050 --> 00:07.050
这里的话有一道面试题

00:07.050 --> 00:10.050
它让你说一说react中的这个update queue

00:10.050 --> 00:14.050
那这边的话要介绍这个react中的这个update queue

00:14.050 --> 00:19.050
那我们首先的话就要先来说一下关于react中的这个update

00:19.050 --> 00:25.050
好我们知道在react中的话它有许多这个触发状态更新的方法

00:25.050 --> 00:36.050
对吧在react中有许多触发状态更新的方法

00:36.050 --> 00:40.050
比如说有哪些呢比如有这么一些

00:40.050 --> 00:46.770
好把这里把它过来大致有这么一些

00:46.770 --> 00:49.770
比如说这个reactdom.createRoot

00:49.770 --> 00:55.770
好比如这里z.setState以及z.forceUpdate

00:55.770 --> 00:58.770
好然后这两个这两个的话是那个和互可相关的

00:58.770 --> 01:02.770
对吧一个是UserState一个是UserReducer

01:02.770 --> 01:08.770
这两个他们的这个dispatcher都是可以这个触发这个状态更新的

01:08.770 --> 01:12.770
那么这些方法的话虽然它这个执行的场景不一样

01:12.770 --> 01:16.770
但是呢他们其实都可以介入同样的这个更新流程

01:16.770 --> 01:18.770
为什么呢原因很简单

01:18.770 --> 01:23.770
因为他们使用的是同一种数据结构来表示的这个更新

01:23.770 --> 01:26.770
这种数据结构的话它就是update

01:26.770 --> 01:34.770
ok好虽然这些方法这个执行的这个场景

01:34.770 --> 01:37.770
会有所不同

01:37.770 --> 01:45.770
但是都可以什么呢都可以介入同样的更新流程

01:45.770 --> 01:51.770
对吧啊原因原因是因为什么呢

01:51.770 --> 01:59.770
是因为他们使用同一种数据结构来表示更新

01:59.770 --> 02:09.770
然后这种数据结构这种数据结构就是什么呢就是update

02:09.770 --> 02:13.770
ok说这些课的话我们从两个方面来讲

02:13.770 --> 02:18.770
首先第一个的话就是什么首先第一个就是update数据结构

02:18.770 --> 02:22.770
第二个是什么呢第二个就是updateQ

02:22.770 --> 02:27.770
我们从这两个方面来看ok好首先的话我们来看一下

02:27.770 --> 02:30.770
关于这个update的这个数据结构

02:30.770 --> 02:33.770
首先的话我们要理解在react中

02:33.770 --> 02:37.770
它的这个更新的话它实际上是有优先级的

02:37.770 --> 02:47.770
在react中更新实际上是存在优先级的

02:47.770 --> 02:53.770
这一点的话有点类似于什么呢有点类似于这个代码版本的这个管理工具

02:53.770 --> 03:05.770
啊这一点有一些类似于这个代码版本代码版本管理工具

03:05.770 --> 03:09.770
好比如说我们举个例子比如说你现在的话你作为

03:09.770 --> 03:15.770
就是有你开发一个软件啊你这个软件的话里面正常有abc啊

03:15.770 --> 03:18.770
去求那你一点一点的进行这个迭代

03:18.770 --> 03:23.770
那么如果你现在的话遇到了这个紧急的这个线上的这个bug

03:23.770 --> 03:28.770
你如果还要干嘛呢还要先把前面这个abc这个需求先提交

03:28.770 --> 03:33.770
提交了然后再去修改这个bug这样子的话实际上是不合理的

03:33.770 --> 03:39.770
对不对啊举个例子举个例子啊假设

03:39.770 --> 03:44.770
现在我们在开发一个软件啊

03:44.770 --> 03:50.770
当前软件处于什么呢处于正常的这个迭代中啊

03:50.770 --> 04:00.770
然后拥有什么呢拥有啊就拥有ab然后c对吧

04:00.770 --> 04:04.770
然后三个三个正常需求

04:04.770 --> 04:12.770
ok然后此时突然来了一个来了一个这个紧急

04:12.770 --> 04:22.770
紧急的这个线上bug啊那么整体流程整体流程如下

04:22.770 --> 04:26.770
ok啊我这边画一个图哈我们来看一下这个图

04:27.770 --> 04:33.770
你看比正常情况下的话你这边有这个a这个需求b这个需求c这个需求

04:33.770 --> 04:37.770
是不正常的进行迭代对不对a做完了做bb做完了做这个c

04:37.770 --> 04:42.770
但是现在的话你突然来了一个什么呢突然来了一个非常紧急的这个线上

04:42.770 --> 04:46.770
这个就是紧急的这个d啊就是线上bugd

04:46.770 --> 04:53.770
那这个时候你为了为了修复这个线上bugbugd啊

04:53.770 --> 04:59.770
然后你需要什么呢你需要先完成这个需求a

04:59.770 --> 05:11.770
然后接下来完成b然后接下来完成c啊之后才能进行这个d的这个修复修复

05:11.770 --> 05:17.770
那这样的设计合不合理合不合理这样的设计实际上是不合理对不对

05:17.770 --> 05:25.770
这样的这个设计实际上实际上是不合理的

05:25.770 --> 05:30.770
为什么呢因为你这边的话abcd算同样都是需求

05:30.770 --> 05:36.770
但是他又有一个什么这就有一个这个优先级对吧很明显的话这个d的优先级要

05:36.770 --> 05:41.770
更高一些那我们应该干嘛我们是不是应该是先修复这个线上bug

05:41.770 --> 05:49.770
对不对先修复线上bugd然后接下来再来去迭代这个正常的abc的这个需求啊

05:49.770 --> 06:00.770
说后面有了这个就是代码版本管理工具之后有了代码版本管理工具之后啊

06:01.770 --> 06:10.770
然后有紧急线上bug需要修复时可以什么呢

06:10.770 --> 06:17.770
可以先暂存当前分支的这个修改啊

06:17.770 --> 06:27.770
然后再什么呢在这个master在master分支然后修复修复这个bug

06:28.770 --> 06:36.770
bugd啊然后并什么呢并紧急上线对不对啊这边的话他这个时候的话他就变成了什么了

06:36.770 --> 06:47.340
就变成了这个样子就变成了这个样子ok你这边的话先去干嘛呢先去把这个bugd先去把它修复了

06:47.340 --> 06:54.340
修复完了之后然后接下来的话再来干嘛之后的话是不再来正常的迭代abc对不对

06:54.340 --> 07:12.340
当这个bug修复完毕后啊再什么呢在正常的正常的来迭代这个abc需求对不对

07:12.340 --> 07:23.340
那你之后迭代的话他会基于什么会基于这个d这个版本啊之后的这个迭代会基于d这个版本

07:24.340 --> 07:27.340
对不对啊就有点类似于什么呢就有点类似于这个样子

07:29.340 --> 07:37.340
有点类似于这个样子ok啊你这边修复了修复了之后之后的开发的话我就基于你这个d这个版本

07:37.340 --> 07:45.340
继续往后面进行开发啊那我们这边并发更新的这个react他实际上他也有类似的能力

07:46.340 --> 07:52.340
哎所以他这边两个很相似啊并发更新的这个react

07:54.340 --> 08:03.340
啊也拥有什么呢也拥有相似的能力什么能力呢就不同的这个update他是有优先级的

08:03.340 --> 08:15.340
不同的update是有这个不同的优先级的这个实际上我们之前在讲那个讲那个react他的一个架构的时候

08:16.340 --> 08:23.340
我们是不是就说过对不对比如说你那个input框啊一个输入框输入框的这个更新他的优先级就要比什么

08:24.340 --> 08:30.340
比你正常比如说这个loading去加载数据要比这种的优先级要高对吧为什么

08:30.340 --> 08:36.340
因为你那个input的输入框你哪怕延迟只有比如说100毫秒那你给用户的话也会感觉就是

08:36.340 --> 08:45.340
就是用户也会感觉到明显的这个延迟啊但是你如果是那种加载数据啊你哪怕就是延迟延迟那么一两秒

08:45.340 --> 08:52.340
你把那种动画做好对吧那种loading的这种动画做好哪怕延迟个一两秒用户也是可以接受的

08:53.340 --> 09:00.340
对不对啊所以说不同的这个更新啊就这边不同的这个update他是有不同的这个优先级的

09:01.340 --> 09:10.340
首先应该完成什么呢首先应该完成这个高优先级的更新啊或者说什么呢就是高优先级的这个update

09:11.340 --> 09:16.340
能够什么呢能够中断这个低优先级

09:16.340 --> 09:21.340
低优先级低优先级的这个update

09:22.340 --> 09:31.780
ok然后当这个高优先级的这个update完成更新之后

09:32.780 --> 09:35.780
然后后续的后续的低优先级

09:36.780 --> 09:41.780
低优先级更新会在什么呢会在高优先级

09:42.780 --> 09:52.780
高优先级这个update更新后的更新后的这个state的这个基础上是不再来进行更新

09:53.780 --> 10:00.780
再来进行更新就和我们上面这张图是一样的对吧你这边这个D完成这个迭代之后

10:01.780 --> 10:07.780
那之后的这个abc是不是就在你这个D的这个版本的基础上是不再往后面进行个迭代

10:08.780 --> 10:17.780
对不对啊说我们这边这个update首先他这边的话他这个新字模型的话就有点类似于啊这一点就是我看在react中存在优先级啊

10:18.780 --> 10:19.780
其新字模型

10:21.780 --> 10:29.780
其新字模型啊有一些类似于什么的有一些类似于我们这个代码版本的这个管理工具

10:30.780 --> 10:36.780
ok好然后接下来的话我们来看一下关于这个update他的一个数据结构

10:37.780 --> 10:43.780
接下来我们来看一下这个update的一个数据结构

10:47.110 --> 10:50.110
那上面我们说了就是你这边是不是有不同的这个更新方法

10:51.110 --> 10:56.110
咱们这边就上面对吧在react中有许多触发这个状态更新的这个方法

10:57.110 --> 11:02.110
那么不同的这个触发更新的方法他实际上对应了不同的组结

11:02.110 --> 11:21.490
ok在前面我们说了啊在这个react中在react中有什么呢有不同的这个触发更新的这个方法

11:22.490 --> 11:32.490
那么不同的方法不同的方法实际上对应了不同的组结啊比如说我把这边我把他过来

11:33.490 --> 11:41.990
这边大家可以看一下然后我们刚才说了啊你这个就是触发更新的方法有这么一些

11:42.990 --> 11:49.990
比较quater root this.setState this.forceUpdate啊然后还就useState和useReducer对吧

11:50.990 --> 11:53.990
好这个第一个第一个的话他对应什么呢对应的是host root

11:54.990 --> 12:00.990
host root啊第二个和第三个他对应的是什么呢对应的是这个class component

12:00.990 --> 12:06.990
那接下来useState和useReducer他们对应的是什么呢他们对应的是这个function component

12:07.990 --> 12:15.990
啊就函数组件啊为什么要说这个呢因为你不同类型的这个组件他的这个update的数据结构是不一样的

12:16.990 --> 12:29.990
ok不同的组件类型所对应的这个update的这个数据结构是不同的啊

12:30.990 --> 12:33.990
那我们首先先来看什么呢我们首先先来看这个host root

12:34.990 --> 12:40.990
host root和这个class component那这两个的话是一致的啊

12:41.990 --> 12:53.430
啊这一类组件组件所对应的这个update数据结构如下

12:54.430 --> 13:02.730
好长什么样子呢啊长这个样子把它过来啊这里

13:02.730 --> 13:09.730
你看这边呢会有一个叫做createUpdate啊有这么一个方法这个方法内部你看这边是不是就是创建一个update的一个

13:10.730 --> 13:16.730
对象啊实际上你一个update他就是一个对象了那接下来这边是不是返回这个update对象对不对

13:17.730 --> 13:23.730
好在这个update对象里面有什么呢有这个even time啊有这个name有这个target有这个payload

13:24.730 --> 13:30.730
callback callback是什么callback就是你回头你要具体触发的这个更新啊大家有next

13:30.730 --> 13:37.730
next是什么next的话它是把这个就是下一个update和当前的这个update把它串联起来

13:38.730 --> 13:47.730
连接成一个这个链表ok整个一个一个update它会连成一个链表啊那这边的这个host root和class component

13:48.730 --> 13:54.730
他们所对应的这个update数据结构就是这样子的啊这里的话要注意一下关于这个tag这个资论

13:54.730 --> 14:01.730
tag这个资论他这边对应的是这个update state对不对这个tag资论的话它是用于区分

14:02.730 --> 14:14.730
就是你这个触发更新了这个场景的啊在在上面的这个update数据结构中啊这个tag

14:15.730 --> 14:27.730
tag资论是用于是用于区分这个触发更新的这个场景的啊然后选项

14:28.730 --> 14:39.900
包括什么呢包括下面一些选项啊把他过来包含这么一些选项啊这边呢首先有一个replace state

14:40.900 --> 14:47.900
他代表什么呢代表是在这个类组件中啊你的这个生命周期函数中啊直接去改变这个state

14:48.900 --> 14:58.900
然后加这个update state这个的话是默认情况你看这边我们就是update state对不对啊就默认默认的话这个通过这个crate root

14:59.900 --> 15:07.900
或者z点set state来触发更新啊这个capture update啊他这个的话代表就是发生错误的这个情况下

15:07.900 --> 15:15.900
然后这个force update他代表的就是z点force update啊就这个你掉这个这个方法触发了这个更新

15:16.900 --> 15:24.900
ok啊这是关于这个hosted root和class component他们所对应的这个update的数据结构啊本账实际上就是个对象了

15:25.900 --> 15:32.900
对不对就是个对象好然后接下来来看一下什么呢来看一下这个function

15:32.900 --> 15:33.900
function

15:34.900 --> 15:36.900
function component

15:37.900 --> 15:42.900
function component是不是就是我们的函数组件对不对啊来看一下function component

15:43.900 --> 15:46.900
所对应的这个update

15:47.900 --> 15:48.900
数据结构

15:49.900 --> 15:54.900
稍微的话有那么一丝丝区别啊我这边把它拿过来

15:55.900 --> 15:56.900
这边

15:57.900 --> 16:03.900
有那么一丝丝区别他这边呢首先呢他这边有个action action的话实际上和刚上面的这个payload

16:04.900 --> 16:09.900
实际上是比较相似的啊这个的话就是你存在的这个更新的这个内容

16:10.900 --> 16:12.900
ok然后加这边的话还多了两个字段

16:13.900 --> 16:16.900
一个是 has eager state一个是 eager state

16:17.900 --> 16:24.900
这两个是什么呢这个两个的话实际上是和后面我们要讲的这个性能优化策略相关的

16:24.900 --> 16:29.900
啊我们后面的话会讲这个性能优化策略就他内部的啊内部的性能优化策略

16:30.900 --> 16:33.900
其中有一个就是叫做 eager state啊和这个相关的

16:34.900 --> 16:36.900
ok啊在上面的字段中

16:37.900 --> 16:45.900
在上面的啊数据结构中数据结构数据结构中有这个 has eager state

16:48.900 --> 16:50.900
和什么呢和 eager state

16:53.340 --> 16:54.340
这两个字段

16:55.340 --> 17:03.340
啊啊这两个字段的话他们和什么呢他们和后面要介绍的

17:04.340 --> 17:09.340
要介绍的这个react内部的这个性能优化策略

17:10.340 --> 17:14.340
性能优化策略啊其中的叫做这个 eager state

17:15.340 --> 17:16.340
eager state

17:18.340 --> 17:20.340
eager state策略

17:21.340 --> 17:22.340
这个相关

17:23.340 --> 17:29.340
ok这个我们后面会说啊那接下来其他的话基本上是相似的对吧这边内啊next啊

17:30.340 --> 17:34.340
在这边这个action action的话表示这个就是他要承载的这个更新

17:35.340 --> 17:38.340
ok好那接下来我们这边继续往后面

17:39.340 --> 17:44.340
那么现在的话我们已经看到了就是无论是这个内组件还是函数组件

17:45.340 --> 17:51.340
他的这个update他的这个数据结构我们已经看到了对吧啊基本上这个你函数组件

17:52.340 --> 17:57.340
数据结构是这样子的你内组件的话对应了这个update数据结构啊是这个样子的

17:58.340 --> 18:05.340
那这里面的话实际上他们共同的话有这么几个问题要考虑那几个问题呢啊首先

18:06.340 --> 18:10.340
第一个就是你这边的话你所承载的这个代码的这个内容ok

18:12.780 --> 18:17.780
在update数据结构中啊有三内

18:18.780 --> 18:28.780
有三内这个内容啊有三内这个就有三个问题吗有三个问题是需要考虑的

18:29.780 --> 18:36.780
那三个问题呢首先第一个的话就是你这边你更新所存在的

18:37.780 --> 18:41.780
所存在的这个更新内容是什么

18:42.780 --> 18:46.780
对吧好第二个第二个就是你更新的紧急程度

18:48.780 --> 18:56.780
更新的紧急程度第三个就是什么呢这个就是更新之间的这个顺序

18:57.780 --> 19:03.780
主要是这三个问题那我们来看一下像这种这种数据结构他能不能解决这三个问题呢

19:04.780 --> 19:10.780
实际上是可以的啊我们一个一个来看首先的话关于这个更新所存在的这个更新内容

19:10.780 --> 19:12.780
那这边的话就是不同的这个

19:13.780 --> 19:17.780
主键他所对应的这个update这个数据结构稍微有一些出入

19:18.780 --> 19:22.780
但是呢对于这个内组件来讲他这边的话是对应的是payload的之段

19:23.780 --> 19:26.780
如果是函数组件的话他对应的是action之段ok

19:27.780 --> 19:30.780
对应啊对于这个内组件

19:31.780 --> 19:36.780
来讲啊然后这个存在

19:37.780 --> 19:43.780
存在更新内容的字段为payload的字段

19:45.780 --> 19:48.780
啊然后对于什么呢对于函数组件来讲

19:49.780 --> 19:56.780
然后存在更新内容的这个字段为什么呢为这个action之段

19:57.780 --> 20:02.410
action之段好来我们这边来看一下例子啊把这个

20:03.410 --> 20:04.410
这样子我来看例子

20:04.410 --> 20:08.410
我来看例子这边比如说我们这边以这个内组件为例啊

20:08.410 --> 20:11.410
但包括什么包括那个host啊对于host

20:12.410 --> 20:15.410
对于host root以及

20:17.410 --> 20:21.410
以及内组件来讲他们都是什么呢都是payload的啊比如说我们这边

20:22.410 --> 20:28.000
把这里拿过来啊好比如说你这边你执行这句代码

20:29.000 --> 20:34.000
react dorm.create root啊人家这边呢把你的这个root element传进去

20:34.000 --> 20:37.000
对吧那你这边对应了这个payload这边对应的是什么呢

20:37.000 --> 20:42.000
这边就对应的是啊你这边这个组件啊对应这个组件

20:42.000 --> 20:48.000
好比如说你这边内组件内组件你这边调用res.setState啊setState

20:48.000 --> 20:52.000
这个我们是不是很就是很常用的一个是吧就是做更新的

20:52.000 --> 20:55.000
对不对让你传入什么呢传入你新的这个状态

20:55.000 --> 20:58.000
那接下来你看这边这个payload对应的就是什么对呢

20:58.000 --> 21:01.000
这边这个一个对象对象里面那么对应的一对吧

21:01.000 --> 21:06.000
对吧好如果你这边呢res.setState这里面的话是一个函数

21:06.000 --> 21:09.000
那接下来你这边对应了这个payload啊这边对应一个对象

21:09.000 --> 21:11.000
对象里面那么对应的就是一个函数

21:11.000 --> 21:15.000
比如说他使用什么是不是使用了是这个payload来承载什么

21:15.000 --> 21:19.000
是不是来承载你的这个更新对不对承载你的更新啊

21:19.000 --> 21:25.000
好如果是函数如果是函数组件的话他就不是在payload里面

21:25.000 --> 21:30.440
他是在什么呢他是在action里面他是在action里面

21:30.440 --> 21:32.440
把这拿过来

21:32.440 --> 21:38.650
ok啊比如说我这边updateNum1

21:38.650 --> 21:41.650
那这边你看他对应的什么对应的是action之段

21:41.650 --> 21:42.650
这边是1

21:42.650 --> 21:46.650
如果你这边updateNum这边他传入的是一个函数

21:46.650 --> 21:50.650
那接下来他这边action对应的是什么呢对应的是一个函数

21:50.650 --> 21:56.650
看了没有啊这是首先第一个他们如何去承载更新的这个内容

21:56.650 --> 21:59.650
啊不同的组件内心稍微有一些出入

21:59.650 --> 22:03.650
如果是host或者内组件他使用的是payload

22:03.650 --> 22:07.650
如果是这个函数组件他使用的是action

22:07.650 --> 22:11.650
好第二个就是关于你更新的这个紧急程度

22:11.650 --> 22:14.650
更新的紧急程度你看他这里面有个什么

22:14.650 --> 22:18.650
他这里是不是有个net啊是不是都有个net对不对

22:18.650 --> 22:22.650
说他的紧急程度的话是由这个net之段来表示的

22:23.650 --> 22:30.650
ok好最后一个最后一个是关于这个更新之间的这个顺序

22:30.650 --> 22:33.650
更新之间的顺序你看这个数据结构里面

22:33.650 --> 22:36.650
他有一个什么他是不是有个next对不对

22:36.650 --> 22:39.650
这边也一样是不是有个next

22:39.650 --> 22:41.650
他这个next究竟是在next的什么

22:41.650 --> 22:44.650
他next的话表示的究竟是在next的什么

22:44.650 --> 22:48.650
他next的话表示的究竟是在next的什么

22:48.650 --> 22:51.650
他这个next究竟是在next的什么

22:51.650 --> 22:55.650
他next的话表示的就是下一个update对象

22:55.650 --> 22:59.650
他通过这个next指向下一个update

22:59.650 --> 23:01.650
ok

23:01.650 --> 23:06.650
通过next这个之段

23:06.650 --> 23:11.650
通过next之段来指向什么呢

23:11.650 --> 23:14.650
指向下一个update

23:14.650 --> 23:18.650
从而形成一个列表

23:18.650 --> 23:24.280
形成一个列表

23:24.280 --> 23:28.280
ok这就是关于这个update的这个数据结构

23:28.280 --> 23:30.280
说简单的话实际上也很简单

23:30.280 --> 23:33.280
就是一个什么就是一个对象对不对

23:33.280 --> 23:37.280
说白了你每一个更新他最终他他会包装成一个这个对象

23:37.280 --> 23:41.280
对象里面有你就是具体做了一些什么样的更新

23:41.280 --> 23:45.280
大家这边你的紧急程度以及就是你和下一个更新

23:45.280 --> 23:47.280
打如何串联在一起

23:47.280 --> 23:50.280
ok这是关于这个update

23:50.280 --> 23:51.280
update介绍完了之后

23:51.280 --> 23:56.280
然后接下来我们来看关于这个updateq

23:56.280 --> 24:00.280
那我们上面上面所介绍的这个update

24:00.280 --> 24:04.280
他是计算state的这个最小单位

24:04.280 --> 24:09.280
上面所介绍的这个update

24:09.280 --> 24:11.280
是什么呢

24:11.280 --> 24:18.280
这个计算state的这个最小单位

24:18.280 --> 24:21.280
而这个updateq

24:21.280 --> 24:23.280
updateq是什么呢

24:23.280 --> 24:27.280
是由这个update

24:27.280 --> 24:31.280
组成的一个对立

24:31.280 --> 24:35.280
ok他的数据结构如下

24:35.280 --> 24:40.280
updateq的这个数据结构如下

24:41.280 --> 24:45.280
好这边这个updateq的话他的数据结构的话是这个样子

24:45.280 --> 24:48.280
他对应的也是个对象

24:48.280 --> 24:50.280
看到没有也是个对象

24:50.280 --> 24:52.280
这个对象里面有这个basestate

24:52.280 --> 24:54.280
first base update

24:54.280 --> 24:56.280
last base update

24:56.280 --> 24:58.280
以及这个shared

24:58.280 --> 25:00.280
shared里面有个喷领

25:00.280 --> 25:02.280
ok你注意你要去分开

25:02.280 --> 25:05.280
update他对应的这个结构是这个样子的

25:05.280 --> 25:07.280
大家这边updateq

25:07.280 --> 25:10.280
对应的这个数据结构是这个样子

25:10.280 --> 25:12.280
好然后这里面的话

25:12.280 --> 25:15.280
每一个这个就每个字段大致什么意思呢

25:15.280 --> 25:17.280
好这边我直接把它拿过来吧

25:17.280 --> 25:20.590
直接把它拿过来

25:20.590 --> 25:26.760
稍等啊

25:26.760 --> 25:28.760
这边我们来看一下

25:28.760 --> 25:29.760
首先第一个

25:29.760 --> 25:32.760
第一个的话是关于这个basestate

25:32.760 --> 25:34.760
bass什么意思

25:34.760 --> 25:36.760
bass是不是基础的意思

25:36.760 --> 25:37.760
对不对

25:37.760 --> 25:39.760
所以这边他就表示基础的这个状态

25:39.760 --> 25:42.760
那这个的话他就是代表这个计算

25:42.760 --> 25:45.760
最开始的这个初始的这个state

25:45.760 --> 25:47.760
你的这个update的话

25:47.760 --> 25:51.760
就是基于basestate来计算新的state

25:51.760 --> 25:53.760
他可以类比于就是我们上面那个

25:53.760 --> 25:56.760
新字模型中的这个master分子

25:56.760 --> 25:58.760
好然后接下来这边这个

25:58.760 --> 26:02.760
first base update和last base update

26:02.760 --> 26:04.760
他是指向什么呢

26:04.760 --> 26:06.760
他是指向你整个更新

26:06.760 --> 26:08.760
你更新的话最终会变成一个链表嘛

26:08.760 --> 26:10.760
对不对你最终更新的话

26:10.760 --> 26:13.760
它是会形成一个这个链表

26:13.760 --> 26:15.760
这边呢其中我们应该叫做这个链表

26:15.760 --> 26:16.760
好一点

26:16.760 --> 26:18.760
update q

26:18.760 --> 26:20.760
那我想一想

26:20.760 --> 26:23.760
这里的话改成这个链表

26:23.760 --> 26:25.760
改成链表

26:25.760 --> 26:30.610
ok 这个update q

26:30.610 --> 26:32.610
是由这个一个一个的update

26:32.610 --> 26:33.610
组成链表

26:33.610 --> 26:35.610
那既然你这边是组成了这个链表

26:35.610 --> 26:37.610
那链表的话是不是就有链表的头

26:37.610 --> 26:39.610
链表的尾部

26:39.610 --> 26:40.610
对不对好那你这边呢

26:40.610 --> 26:42.610
这个first base update

26:42.610 --> 26:44.610
他指向的就是什么呢

26:44.610 --> 26:47.610
他就指向的是链表的头部

26:47.610 --> 26:50.610
而你这个last base update

26:50.610 --> 26:51.610
他指向的是什么呢

26:51.610 --> 26:54.610
他指向的就是链表的尾部

26:54.610 --> 26:56.610
一头一尾

26:56.610 --> 26:57.610
ok

26:57.610 --> 26:58.610
好然后接下来的话

26:58.610 --> 27:00.610
这边有个share的pending

27:00.610 --> 27:02.610
share的pending是什么呢

27:02.610 --> 27:03.610
share的pending是

27:03.610 --> 27:06.610
就是你当你触发这个新的更新的时候

27:06.610 --> 27:07.610
你现在的话是不是就会有

27:07.610 --> 27:08.610
这个新的这个更新

27:08.610 --> 27:10.610
加入了这个链表里面

27:10.610 --> 27:12.610
对吧那这个share的pending

27:12.610 --> 27:14.610
他就会把你这个新

27:14.610 --> 27:16.610
产生的这个就是update

27:16.610 --> 27:20.610
组成一个单向的还状链表

27:20.610 --> 27:21.610
ok

27:21.610 --> 27:23.610
把这个加出

27:23.610 --> 27:26.610
他就会组成一个单向的还状链表

27:26.610 --> 27:29.610
那最终在这个计算这个state的时候

27:29.610 --> 27:30.610
这个还状链表的话

27:30.610 --> 27:32.610
他会被拆分

27:32.610 --> 27:33.610
拆分了之后

27:33.610 --> 27:35.610
拼接到上面的这个

27:35.610 --> 27:38.610
last base update后面

27:38.610 --> 27:39.610
然后来举个例子

27:39.610 --> 27:40.610
举个例子大家明白了

27:40.610 --> 27:42.610
这样子说的话比较抽象对吧

27:42.610 --> 27:44.610
好比如说举个例子

27:45.610 --> 27:47.610
举例说明

27:47.610 --> 27:48.610
例如

27:48.610 --> 27:51.610
当前有一个什么呢

27:51.610 --> 27:55.620
有一个fiber load

27:55.620 --> 27:57.620
当前的这个fiber load的话

27:57.620 --> 27:59.620
他刚经历完

27:59.620 --> 28:02.620
刚经历完这个commit

28:02.620 --> 28:04.620
阶段的这个渲染

28:04.620 --> 28:05.620
刚渲染完

28:05.620 --> 28:06.620
渲染完之后

28:06.620 --> 28:07.620
然后接下来

28:07.620 --> 28:11.620
该fiber load

28:11.620 --> 28:13.620
load上面

28:13.620 --> 28:15.620
然后有两个什么呢

28:15.620 --> 28:17.620
有两个就是由于

28:17.620 --> 28:19.620
优先级

28:19.620 --> 28:21.620
优先级D

28:21.620 --> 28:24.620
导致在上一轮

28:24.620 --> 28:27.620
Render阶段

28:27.620 --> 28:29.620
然后并没有

28:29.620 --> 28:33.620
被处理的这个update

28:33.620 --> 28:34.620
ok

28:34.620 --> 28:35.620
假设

28:35.620 --> 28:37.620
假设这两个

28:37.620 --> 28:39.620
这两个update

28:39.620 --> 28:41.620
分别名为什么呢

28:41.620 --> 28:44.620
分别名为这个update0

28:44.620 --> 28:46.620
就u0和什么呢

28:46.620 --> 28:49.620
和update1这边u1

28:49.620 --> 28:50.620
分别为这个

28:50.620 --> 28:51.620
那么现在的话

28:51.620 --> 28:54.620
你的这个first base update

28:54.620 --> 28:55.620
他就会干嘛呢

28:55.620 --> 28:57.620
他就会指向这个u0

28:57.620 --> 28:59.620
而你的这个last base update

28:59.620 --> 29:01.620
就会指向u1

29:01.620 --> 29:02.620
因为你就两个嘛

29:02.620 --> 29:04.620
对吧就两个

29:05.620 --> 29:06.620
那么这边的话

29:06.620 --> 29:07.620
现在的话的对应的就是

29:07.620 --> 29:08.620
这个样子

29:08.620 --> 29:11.620
把这个拿过来

29:11.620 --> 29:13.620
ok

29:13.620 --> 29:14.620
你看这边

29:14.620 --> 29:15.620
你的这个fiber

29:15.620 --> 29:16.620
fiber.updateq

29:16.620 --> 29:18.620
updateq就是这么一个对象

29:18.620 --> 29:19.620
对不对

29:19.620 --> 29:21.620
这个对象的这个first base update

29:21.620 --> 29:22.620
他就会指向什么呢

29:22.620 --> 29:23.620
指向这个u0

29:23.620 --> 29:24.620
这是上一轮

29:24.620 --> 29:26.620
上一轮因为他优先级D

29:26.620 --> 29:28.620
这个残留下来的这个更新

29:28.620 --> 29:30.620
而这个last base update

29:30.620 --> 29:31.620
这个u1

29:31.620 --> 29:33.620
对吧他就会指向这个u1

29:33.620 --> 29:35.620
然后u0和u1之间本身

29:35.620 --> 29:36.620
因为你这个是

29:36.620 --> 29:38.620
你这个是一个update

29:38.620 --> 29:39.620
对吧u0和u1

29:39.620 --> 29:40.620
他是一个update

29:40.620 --> 29:42.620
update就是什么样的这个结构

29:42.620 --> 29:44.620
所以就这样子的结构

29:44.620 --> 29:45.620
对不对

29:45.620 --> 29:46.620
好那接下来

29:46.620 --> 29:47.620
他们这边通过什么呢

29:47.620 --> 29:48.620
通过这个next

29:48.620 --> 29:50.620
u0.next等于一个u1

29:50.620 --> 29:52.620
所以把它串联起来

29:52.620 --> 29:53.620
ok

29:53.620 --> 29:55.620
好然后接下来的话

29:55.620 --> 29:56.620
就是现在

29:56.620 --> 29:57.620
现在的话

29:57.620 --> 29:58.620
那比如说在

29:58.620 --> 29:59.620
当前的这个fiber load上面

29:59.620 --> 30:02.620
我们触发了两次更新

30:02.620 --> 30:05.620
那么假设

30:05.620 --> 30:07.620
那么假设

30:07.620 --> 30:14.620
假设在当前的fiber load上面

30:14.620 --> 30:15.620
load上面

30:15.620 --> 30:22.620
我们又触发了两次更新

30:22.620 --> 30:25.620
然后分别产生了什么呢

30:25.620 --> 30:30.620
分别产生了两个update

30:30.620 --> 30:31.620
那两个update

30:31.620 --> 30:37.620
分别是这个u2和u3

30:37.620 --> 30:40.620
那么这个新的新产生的

30:40.620 --> 30:42.620
新产生的这个update

30:42.620 --> 30:44.620
就会形成一个什么呢

30:44.620 --> 30:50.620
就会形成一个环状链表

30:50.620 --> 30:51.620
明白没有

30:51.620 --> 30:53.620
它会形成一个环状的链表

30:53.620 --> 30:54.620
好然后接下来

30:54.620 --> 30:57.620
你这边这个share的pending

30:57.620 --> 30:59.620
share的pending

30:59.620 --> 31:03.620
指向这个环状链表

31:03.620 --> 31:06.060
看到没有

31:06.060 --> 31:07.060
它就会指向这个环状链表

31:07.060 --> 31:09.060
我们这边把这个图

31:09.060 --> 31:11.060
把它过来

31:11.060 --> 31:13.060
如下图所示

31:13.060 --> 31:16.060
下图所示

31:16.060 --> 31:18.060
这里

31:18.060 --> 31:19.060
看到没有

31:19.060 --> 31:21.060
这边有你的BaseUpdate

31:21.060 --> 31:22.060
BaseUpdate

31:22.060 --> 31:25.060
大家这边就是最开始的这个更新

31:25.060 --> 31:27.060
这个是不是上一轮

31:27.060 --> 31:28.060
是不是遗留下来了

31:28.060 --> 31:29.060
U0和U1

31:30.060 --> 31:32.060
FirstBaseUpdate指向U0

31:32.060 --> 31:35.060
The lastBaseUpdate指向U1

31:35.060 --> 31:37.060
U0和U1

31:37.060 --> 31:38.060
就是它们本身的话

31:38.060 --> 31:40.060
又通过这个next

31:40.060 --> 31:42.060
是不是指向

31:42.060 --> 31:43.060
这一轮的话

31:43.060 --> 31:45.060
你又产生了两个新的更新

31:45.060 --> 31:47.060
分别是u2和u3

31:47.060 --> 31:48.060
既然u2 u3

31:48.060 --> 31:50.060
它就会形成一个什么呢

31:50.060 --> 31:51.060
它就会形成一个

31:51.060 --> 31:52.060
环状链表

31:52.060 --> 31:53.060
你看它这边是不是

31:53.060 --> 31:54.060
它指向它

31:54.060 --> 31:55.060
它又指向它

31:55.060 --> 31:56.060
是环状的

31:56.060 --> 31:58.060
大家这边这个share的点pending

31:58.060 --> 32:01.060
就会指向这个环状链表

32:01.060 --> 32:02.060
看到没有

32:02.060 --> 32:03.060
你看这边

32:03.060 --> 32:04.060
触发更新之后

32:04.060 --> 32:07.060
这边它会保存到share的pending里面

32:07.060 --> 32:08.060
OK

32:08.060 --> 32:09.060
好

32:09.060 --> 32:11.060
然后完事之后

32:11.060 --> 32:15.060
之后在fiberload的BeginWalk阶段

32:17.060 --> 32:19.060
之后

32:19.060 --> 32:23.060
进入新的一轮

32:23.060 --> 32:25.060
这个Render

32:25.060 --> 32:26.060
对吧

32:26.060 --> 32:34.060
这个该fiberload的BeginWalk中

32:34.060 --> 32:37.760
这个share的pending

32:37.760 --> 32:39.760
它所指向的这个环状链表的话

32:39.760 --> 32:41.760
它就会被拆分

32:41.760 --> 32:45.760
share的点pending

32:45.760 --> 32:49.760
所指向的

32:49.760 --> 32:52.760
环状链表

32:52.760 --> 32:54.760
就会被什么呢

32:54.760 --> 32:56.760
就会被拆分

32:56.760 --> 32:58.760
它会被拆分干嘛呢

32:58.760 --> 32:59.760
被拆分了之后

32:59.760 --> 33:02.760
接到这个链表后面

33:02.760 --> 33:04.760
拆分之后

33:04.760 --> 33:06.760
拆分之后

33:06.760 --> 33:08.760
接入到什么呢

33:08.760 --> 33:10.760
接入到这个

33:10.760 --> 33:13.760
就是你的bass

33:13.760 --> 33:16.760
bassupdate链表后面

33:16.760 --> 33:21.760
bassupdate链表后面

33:21.760 --> 33:23.760
就接到这个链表后面

33:23.760 --> 33:25.760
那接下来这边就变成这个样子

33:25.760 --> 33:30.100
就变成这个样子

33:30.100 --> 33:32.100
这边有个图

33:32.100 --> 33:34.100
这边U0U1

33:34.100 --> 33:36.100
然后后面是U2U3

33:36.100 --> 33:37.100
OK

33:37.100 --> 33:38.100
它就接过来了

33:38.100 --> 33:41.100
这个就是你整个你的updateQ

33:41.100 --> 33:42.100
就形成了

33:42.100 --> 33:44.100
好了,接下来的话它就会便利什么呢

33:44.100 --> 33:47.100
便利你这个bassupdate

33:47.100 --> 33:51.100
接下来就会便利

33:51.100 --> 33:55.100
你的这个updateQ

33:55.100 --> 33:58.100
然后点bassupdate

33:58.100 --> 34:01.100
OK,你的这个bassupdate也是一个链表嘛

34:01.100 --> 34:02.100
对不对

34:02.100 --> 34:03.100
接下来的话基于什么呢

34:03.100 --> 34:05.100
基于你的这个bassupdate

34:05.100 --> 34:10.100
来计算每个符合优先级条件的这个update

34:10.100 --> 34:17.860
基于这个updateQ

34:17.860 --> 34:20.860
点这个bassupdate

34:20.860 --> 34:21.860
bassstate

34:21.860 --> 34:23.860
我们说了,这个最开始这边

34:23.860 --> 34:25.860
是不是有个bassstate

34:25.860 --> 34:28.860
对不对,这个是最开始初始的这个state

34:28.860 --> 34:29.860
基于这个

34:29.860 --> 34:33.860
基于这个bassstate来计算

34:33.860 --> 34:41.860
来计算每个符合这个优先级条件

34:41.860 --> 34:48.940
条件的这个update

34:48.940 --> 34:50.940
这个过程的话有点类似于什么呢

34:50.940 --> 34:52.940
这个过程

34:52.940 --> 34:56.940
有点类似于这个array

34:56.940 --> 35:01.940
array.potatype.reduce

35:01.940 --> 35:03.940
对吧,我首先计算

35:03.940 --> 35:04.940
第一个update

35:04.940 --> 35:07.940
再加把这个新的state合并

35:07.940 --> 35:09.940
对吧,合并了之后人家在计算第二个

35:09.940 --> 35:11.940
第二个的话,它是在什么

35:11.940 --> 35:14.940
就是在基于你这个U0的更新后的这个state

35:14.940 --> 35:16.940
对不对,再来计算U1

35:16.940 --> 35:18.940
U1更新,把那个state又更新

35:18.940 --> 35:20.940
更新了之后再来计算这个U2

35:21.940 --> 35:23.940
有点类似于这个reduce

35:23.940 --> 35:25.940
好,然后最终

35:25.940 --> 35:34.300
最终,然后计算出最终的

35:34.300 --> 35:38.300
最终计算出最新的

35:38.300 --> 35:41.300
最新的这个state

35:41.300 --> 35:49.300
然后该state被称之为什么呢

35:49.300 --> 35:52.300
这个memoredstate

35:52.300 --> 35:55.300
memoredstate

35:55.300 --> 35:57.300
看到没有,它怎么计算来的

35:57.300 --> 36:00.300
它就是通过这么一个update queue

36:00.300 --> 36:02.300
这么一个这个批量的更新

36:02.300 --> 36:05.300
批量的这边,计算过来的

36:05.300 --> 36:08.300
说说我们这边让我们总结一下

36:08.300 --> 36:13.300
因此我们总结一下

36:13.300 --> 36:18.300
整个state的这个计算流程

36:18.300 --> 36:21.300
计算流程可以分为什么呢

36:21.300 --> 36:23.300
可以分为两步

36:23.300 --> 36:26.440
可以分成两步

36:26.440 --> 36:28.440
首先第一步,第一步是什么呢

36:28.440 --> 36:32.440
第一步是将这个shared

36:34.440 --> 36:36.440
shared的这个pending

36:36.440 --> 36:41.440
说指向的这个环状链表

36:42.440 --> 36:44.440
进行拆分

36:46.440 --> 36:48.440
进行拆分,然后拼接

36:48.440 --> 36:51.440
然后并且和什么呢

36:51.440 --> 36:56.440
和这个base update进行拼接

36:56.440 --> 37:04.440
对不对,形成新的这个链表

37:04.440 --> 37:06.440
对不对,这首先第一步

37:06.440 --> 37:07.440
好,那第二步是什么呢

37:07.440 --> 37:10.440
第二步就是便利这个连接后的

37:10.440 --> 37:13.820
连接后的链表

37:13.820 --> 37:15.820
然后接下来根据什么呢

37:15.820 --> 37:17.820
根据你这个walking programs

37:17.820 --> 37:20.820
这个lens,选定这个优先级

37:20.820 --> 37:23.820
然后基于这个符合优先级条件的这个update

37:23.820 --> 37:26.820
来计算这个state

37:26.820 --> 37:30.820
对不对,根据这个wap

37:30.820 --> 37:33.820
waproot,这个render

37:33.820 --> 37:35.820
renderlens

37:35.820 --> 37:40.820
来选定优先级

37:40.820 --> 37:42.820
对不对,然后基于什么呢

37:42.820 --> 37:48.820
基于符合优先级条件的这个update

37:48.820 --> 37:52.820
来计算state

37:52.820 --> 37:55.820
对不对,整个这个update queue

37:55.820 --> 37:57.820
它这边它的这个计算的话

37:57.820 --> 37:59.820
就是这样子来计算的

37:59.820 --> 38:02.820
好,这是关于这个update queue

38:02.820 --> 38:03.820
好,接下来我们来看一下

38:03.820 --> 38:05.820
关于这个整体解答

38:05.820 --> 38:08.820
这边就是让你说一说这个update queue

38:08.820 --> 38:10.820
那你首先可以从什么呢

38:10.820 --> 38:13.820
首先可以从这个update来说起

38:13.820 --> 38:16.820
说一下这个update是什么

38:16.820 --> 38:18.820
update的这个数据结构是什么

38:18.820 --> 38:20.820
那接下来再说一下什么

38:20.820 --> 38:22.820
再说一下这个update queue

38:22.820 --> 38:24.820
它的一个数据结构

38:24.820 --> 38:25.820
对不对

38:25.820 --> 38:27.820
好,这边要把这个参考答案

38:27.820 --> 38:31.150
我把它过来

38:31.150 --> 38:36.130
把这个

38:36.130 --> 38:37.130
把这个拿过来

38:37.130 --> 38:39.130
这边一个update

38:39.130 --> 38:42.130
update是计算state的最小单位

38:42.130 --> 38:45.130
一条update queue代表由update所组成的

38:45.130 --> 38:47.130
我们这边把它改成列表吧

38:47.130 --> 38:48.130
列表

38:48.130 --> 38:50.130
里面的话有几个重要的这个属性

38:50.130 --> 38:52.130
那加这边你还可以总结一下什么呢

38:52.130 --> 38:55.130
总结一下整个state计算的流程

38:55.130 --> 38:57.130
这分成这两步

38:57.130 --> 38:58.130
对不对

38:58.130 --> 39:00.130
整个state计算流程

39:00.130 --> 39:02.130
首先的话把这个shield的

39:02.130 --> 39:05.130
shield点喷并所指向的还状列表

39:05.130 --> 39:07.130
先把它进行个拆分

39:07.130 --> 39:10.130
拼接到这个bassupdate后面

39:10.130 --> 39:12.130
形成这个新的列表

39:12.130 --> 39:14.130
之后的话便利你这个新的列表

39:14.130 --> 39:17.130
选择这个符合这个优先级条件的

39:17.130 --> 39:18.130
对不对

39:18.130 --> 39:22.130
符合优先级条件的大家来计算新的state

39:22.130 --> 39:24.130
整体来讲的话这个流程的话

39:24.130 --> 39:26.130
就是这个样子的

39:26.130 --> 39:27.130
OK

39:27.130 --> 39:31.130
这是关于react中update

39:31.130 --> 39:33.130
这个的话大家下来的话

39:33.130 --> 39:36.130
可以再把这一小节的知识再看一下

39:36.130 --> 39:37.130
好吧

39:37.130 --> 39:38.130
OK

39:38.130 --> 39:40.130
这期课就先到这里

39:40.130 --> 39:41.130
再见

