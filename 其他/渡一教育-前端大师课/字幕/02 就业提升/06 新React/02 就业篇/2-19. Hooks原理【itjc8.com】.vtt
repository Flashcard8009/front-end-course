WEBVTT

00:00.000 --> 00:04.640
OK 这些课的话 我们来看一下关于这个户客的原理

00:05.280 --> 00:11.320
好 这边的话有道面试题 它说户客的话是如何保存这个韩束组件状态的

00:11.920 --> 00:18.520
啊 以及为什么不能在这个循环条件啊 或者这个千套韩束中调用这个户客

00:19.200 --> 00:27.120
好 我们知道这个户客 户客的这个推出的话 可以让我们以前的这个韩束组件啊 拥有了这个状态的这个概念

00:27.840 --> 00:36.960
对不对啊 以前的话 这个韩束组件是没有状态的啊 有了这个户客之后 哎 我们现在这个韩束组件 它也能够就是拥有自己的这个状态了

00:37.760 --> 00:43.600
但这边的话 就是很奇怪的 就是你这个韩束组件每次都是什么 是每次都是重新执行这个韩束

00:44.320 --> 00:47.840
那它内部的这个状态究竟是如何保存的

00:48.640 --> 00:53.680
对不对啊 所说我们这几课的话 这个户客原理 我们这边就一起来看一下啊

00:54.640 --> 01:02.560
好 这几课的话会分成这么两个部分 首先第一个的话是关于这个户客啊 户客他这个内部的一个介绍

01:04.640 --> 01:12.560
内部介绍好 另外一个的话就是关于什么呢 关于整个这个户客的一个执行流程

01:13.520 --> 01:17.040
啊 我们会从这两个方面来给大家进行的介绍啊

01:17.600 --> 01:22.240
好 首先我们来看一下这个户客的这个内部 实际上在这个react中

01:22.560 --> 01:29.520
他针对这个户客 他实际上有三种策略啊 这个的话他在圆满里面被称之为这个dispatcher

01:30.480 --> 01:32.160
在这个react中

01:33.840 --> 01:35.600
针对户客

01:36.400 --> 01:38.480
有三种策略

01:40.160 --> 01:40.880
或者说

01:42.080 --> 01:46.400
或者说三种类型的dispatcher

01:47.600 --> 01:52.240
ok 哪三种呢 首先第一个的话他叫做这个啊 hooks

01:54.080 --> 01:57.680
他这边应该是大写的 hooks 然后dispatcher

01:59.200 --> 02:00.800
然后on mount

02:02.240 --> 02:09.520
ok 这是第一种 他的话他主要是负责什么呢 他主要是负责一个初始化的工作啊 你可以看到这边是on mount

02:10.240 --> 02:16.880
他负责初始化工作 然后让这个函数组建的一些这个初始化信息挂载到fiber上面

02:17.600 --> 02:17.760
啊

02:18.880 --> 02:20.720
负责初始化

02:21.440 --> 02:21.840
工作

02:22.800 --> 02:26.480
然后让什么呢 让这个函数组建的一些

02:27.840 --> 02:28.880
初始化信息

02:30.240 --> 02:33.520
挂载到哪里呢 挂载到fiber上面

02:34.560 --> 02:35.280
挂载到

02:36.320 --> 02:38.240
fiber上面

02:38.240 --> 02:41.200
ok 实际上你现在的话心理基本就大概有数了

02:41.760 --> 02:44.480
啊 他为什么能够保存 因为他挂载fiber上面的

02:44.960 --> 02:45.360
对不对

02:45.920 --> 02:51.600
ok 好 然后接下来这个函数组建啊 这个这个 hooks dispatcher on mount

02:52.080 --> 02:53.360
啊 他这边的话我把这个

02:54.320 --> 02:57.200
这个是他原码的这个代码片段啊 把拿过来

02:57.920 --> 02:59.360
拿过来 这边大家可以看一下

03:00.000 --> 03:02.720
这边看的 hooks dispatcher on mount

03:03.200 --> 03:05.040
好 这个呢是他的这个类型

03:05.520 --> 03:07.040
他用的是这个flow

03:07.760 --> 03:12.000
啊 这是他的类型 然后接下来这里面 这里面的话是这个一个对象

03:12.560 --> 03:15.200
啊 他对应的是一个对象 对象的话 然后你看这边

03:15.600 --> 03:17.120
啊 这这上面就不看了吗 你看这边

03:17.600 --> 03:18.640
use callback

03:18.960 --> 03:21.120
他对应什么呢 对于mount callback

03:21.920 --> 03:22.880
use effect

03:23.440 --> 03:24.960
对应mount effect

03:25.680 --> 03:26.560
use memo

03:26.560 --> 03:28.240
啊 对于mount memo

03:28.240 --> 03:29.440
啊 一词类推

03:29.440 --> 03:30.960
对吧 你看这边 use state

03:30.960 --> 03:32.800
对应这个mount state

03:33.440 --> 03:36.080
ok啊 首先的话他这边有一个这个 dispatcher

03:36.080 --> 03:37.600
啊 不同的这个 hook

03:38.080 --> 03:40.400
他这边对应的全部都是mount

03:41.200 --> 03:42.880
对不对啊 这是首先第一种

03:43.440 --> 03:44.240
好 第二种

03:44.400 --> 03:48.720
第二种的话叫做 hooks dispatcher on this update

03:50.480 --> 03:51.360
hooks

03:51.360 --> 03:54.880
然后 dispatcher on update

03:57.650 --> 04:00.290
ok 这个是什么呢 这个的话是你在

04:00.290 --> 04:03.010
这个函数组件进行更新的时候

04:03.730 --> 04:10.610
啊 函数组件进行更新的时候

04:11.330 --> 04:13.730
会执行该对象

04:15.840 --> 04:19.440
该对象所对应的这个方法

04:21.120 --> 04:23.840
对不对 那你这个时候更新更新的话

04:23.840 --> 04:25.600
我们干说了 你初始化的话

04:25.600 --> 04:28.400
会把一些这个信息存到这个fiber上面

04:28.400 --> 04:29.360
那么现在的话

04:29.360 --> 04:32.000
他对应的这个fiber上面是不是已经存储了

04:32.000 --> 04:34.240
这个函数组件的这个相关信息

04:34.880 --> 04:42.560
对不对啊 此时fiber上面已经存储了

04:43.520 --> 04:47.680
存储了函数组件的相关信息

04:48.720 --> 04:50.960
那么这些 hook 他要做的事情是什么呢

04:50.960 --> 04:52.800
他要做的事情就是去获取

04:53.360 --> 04:56.400
或者这个更新维护这个fiber上面的信息

04:58.880 --> 04:59.760
这些 hook

05:00.880 --> 05:05.840
需要做的就是什么呢 就是这个去获取

05:07.600 --> 05:10.480
或者更新维护

05:11.200 --> 05:13.040
这些fiber的信息

05:15.040 --> 05:18.560
OK 好 那这边同样 我把这边他的这个原码片段

05:19.040 --> 05:22.000
把他过来 把他说等啊

05:24.220 --> 05:25.900
然后这里 你看这边的话

05:25.900 --> 05:29.180
他是要做 hooks dispatcher on mount

05:29.740 --> 05:31.660
对应的也是一个 dispatcher 类型

05:31.660 --> 05:33.020
这个是他的类型

05:33.020 --> 05:34.060
好 然后你看这里

05:34.620 --> 05:35.420
use callback

05:36.060 --> 05:37.900
对应的是 update callback

05:38.620 --> 05:40.540
use context

05:40.540 --> 05:42.700
对应的是 read context

05:42.700 --> 05:46.220
大家这边use effect对应的是 update effect

05:46.220 --> 05:49.740
比如这边use state对应的是 update state

05:49.740 --> 05:52.380
你看和上面是不是就不一样了 对不对

05:52.380 --> 05:55.180
比如你执行这个use state方法

05:55.180 --> 05:57.180
同样都是use state方法

05:57.180 --> 05:59.900
他就会根据你究竟是 mount 过程

05:59.900 --> 06:01.260
还是 update 过程

06:01.260 --> 06:02.300
如果你是 mount

06:02.300 --> 06:04.540
他其实执行的是哪个呢 执行的是这个

06:05.500 --> 06:07.900
明白吧 他执行的是这个

06:07.900 --> 06:09.500
好 如果你是更新

06:09.500 --> 06:11.900
你这一次比如说是函数组建更新

06:11.900 --> 06:13.980
那么他执行的是哪个呢 他执行的是这个

06:13.980 --> 06:15.980
update state

06:15.980 --> 06:19.020
他背后对应的这个方法是不一样的

06:19.020 --> 06:21.020
是不一样的

06:21.020 --> 06:23.020
这是第二个

06:23.020 --> 06:25.020
那接下来第三个呢

06:25.020 --> 06:27.500
看一下第三个

06:27.500 --> 06:30.140
第三个的话叫做这个 context

06:31.100 --> 06:35.260
context only dispatcher

06:35.260 --> 06:41.540
好 这个的话是和这个爆错相关的

06:41.540 --> 06:50.100
这个是和这个爆错相关的

06:50.100 --> 06:51.300
什么意思呢

06:51.300 --> 06:53.700
就是他是为了防止你开发者

06:53.700 --> 06:55.700
比如在函数组建外部

06:55.700 --> 06:56.900
调用这个户口

06:56.900 --> 06:59.940
或者在户口室里面的千套调用这个户口

07:00.100 --> 07:02.500
说这个的话是一种爆错形态

07:02.500 --> 07:05.860
只要你开发者调用了这个形态下面的户口

07:05.860 --> 07:08.900
他就会抛出一个异常

07:08.900 --> 07:12.100
这是和爆错相关

07:12.100 --> 07:21.700
防止开发者在函数组建外部调用户口

07:21.700 --> 07:24.260
好 来我们这边我们来看一下

07:24.260 --> 07:27.860
他这边对应的也是有一组

07:28.820 --> 07:30.820
这边也是对应一组

07:30.820 --> 07:37.580
我把这边我把他拉过来

07:37.580 --> 07:39.020
这边你看

07:39.020 --> 07:41.420
这边use callback对应的

07:41.420 --> 07:43.820
slow in widely的hook error

07:43.820 --> 07:45.500
这边use state

07:45.500 --> 07:48.380
slow in widely的hook error

07:48.380 --> 07:48.860
对不对

07:48.860 --> 07:49.660
use rave

07:49.660 --> 07:51.660
slow in widely的hook error

07:51.660 --> 07:52.700
全部都是什么呢

07:52.700 --> 07:54.060
全部都是抛出一个什么

07:54.060 --> 07:56.380
全部都是抛出一个错误

07:56.380 --> 07:57.420
对不对

07:57.420 --> 08:01.520
那我们这边总结一下

08:01.520 --> 08:02.800
总结一下

08:04.910 --> 08:06.030
总结一下

08:06.030 --> 08:06.750
什么呢

08:06.750 --> 08:10.750
如果是在mount阶段

08:10.750 --> 08:11.790
mount阶段

08:11.790 --> 08:14.270
那么现在的话这个函数组建式进行什么

08:14.270 --> 08:16.430
是不是进行初始化

08:16.430 --> 08:21.230
函数组建式进行初始化

08:21.230 --> 08:25.790
那么此时调用的就是什么呢

08:25.790 --> 08:31.310
调用的就是mount叉叉叉对应的这个函数

08:31.310 --> 08:31.950
对不对

08:31.950 --> 08:34.190
这边基本上都是mount

08:34.190 --> 08:34.670
对不对

08:34.670 --> 08:37.230
基本上都是mount对应的这个函数

08:37.230 --> 08:37.470
好

08:37.470 --> 08:41.070
如果是update阶段

08:41.070 --> 08:42.270
update阶段

08:42.270 --> 08:45.870
那函数组建进行什么

08:45.870 --> 08:49.870
是不是进行这个状态的更新

08:49.870 --> 08:50.750
对不对

08:50.750 --> 08:52.350
调用的就是什么呢

08:52.350 --> 08:58.510
就是update叉叉叉对应的函数

08:58.510 --> 08:58.750
好

08:58.750 --> 09:02.430
如果是这个其他场景下

09:02.510 --> 09:04.510
其他场景下

09:04.510 --> 09:06.030
那其他场景下一般就是什么

09:06.030 --> 09:06.630
一般是不是就是

09:06.630 --> 09:08.430
对不对

09:08.430 --> 09:10.590
比如你在函数组建外部

09:10.590 --> 09:11.630
调用的这个户口

09:11.630 --> 09:12.590
或者户口里面

09:12.590 --> 09:14.110
切套使用这个户口

09:14.110 --> 09:15.550
那这种情况下

09:15.550 --> 09:18.990
此时调用的就是什么呢

09:18.990 --> 09:23.630
就是这个sure invalid

09:23.630 --> 09:29.700
invalid error

09:29.700 --> 09:33.410
invalid error

09:33.410 --> 09:33.970
OK

09:33.970 --> 09:35.250
你看它全部都是一样的

09:35.410 --> 09:36.050
你这边的话

09:36.050 --> 09:37.490
无论你是use callback

09:37.490 --> 09:39.250
还是use context

09:39.250 --> 09:40.130
无论是哪个

09:40.130 --> 09:41.570
是不是都是sure invalid

09:41.570 --> 09:42.850
hook error

09:42.850 --> 09:43.730
都是一样的

09:43.730 --> 09:45.250
相当于这边是同一个

09:45.250 --> 09:46.530
就只有一个

09:46.530 --> 09:47.570
OK

09:47.570 --> 09:47.810
好

09:47.810 --> 09:50.530
这是关于首先这个hook

09:50.530 --> 09:53.970
它内部对应的这么三种情况

09:53.970 --> 09:54.210
好

09:54.210 --> 09:56.290
那你这个函数组建

09:56.290 --> 09:58.210
它在进行这个render的时候

09:58.210 --> 09:59.730
它首先会根据什么呢

09:59.730 --> 10:02.370
会根据你对应的这个fiber load

10:02.370 --> 10:04.770
它会进行一个判断

10:04.850 --> 10:05.970
当fc

10:05.970 --> 10:08.370
这个fc就是指的是那个函数组建

10:08.370 --> 10:09.890
function component

10:09.890 --> 10:10.130
好

10:10.130 --> 10:13.330
当fc进入到什么呢

10:13.330 --> 10:17.250
进入到render流程的时候

10:17.250 --> 10:19.170
首先会判断什么呢

10:19.170 --> 10:23.570
首先会判断是这个初次渲染

10:25.330 --> 10:26.850
初次渲染还是什么呢

10:26.850 --> 10:28.370
还是这个更新

10:28.370 --> 10:28.690
好

10:28.690 --> 10:30.690
对应的这个代码片段是如下

10:32.450 --> 10:34.050
这边对应了这个代码片段

10:34.210 --> 10:34.770
把它拿过来

10:39.410 --> 10:40.450
你看这边

10:40.450 --> 10:43.570
如果current不等于这个nau

10:43.570 --> 10:47.170
并且current点memo的state

10:47.170 --> 10:48.050
不等于nau

10:48.050 --> 10:48.850
那说明什么呢

10:48.850 --> 10:50.610
说明是update

10:50.610 --> 10:51.890
否则的话就是什么呢

10:51.890 --> 10:53.490
否则就是mount

10:53.490 --> 10:54.370
你看它这边

10:54.370 --> 10:57.650
它在判断的是mount还是update

10:57.650 --> 10:58.530
判断完了之后

10:58.530 --> 11:00.290
它做了一件什么事情

11:00.290 --> 11:01.890
它是不是会根据你的判断

11:01.890 --> 11:03.010
给谁负责

11:03.010 --> 11:05.090
是不是给react current

11:05.090 --> 11:06.610
dispatcher点current

11:06.610 --> 11:07.570
是不是给它负责

11:08.610 --> 11:09.490
对不对

11:09.490 --> 11:10.530
如果你是mount

11:10.530 --> 11:11.490
mount对应的就是这个

11:11.490 --> 11:12.530
hook是dispatcher

11:12.530 --> 11:13.810
mount就是哪个

11:13.810 --> 11:14.770
是不是就是这个对象

11:15.730 --> 11:16.690
就是这个对象

11:16.690 --> 11:17.330
它是个对象吗

11:17.890 --> 11:18.290
对不对

11:18.290 --> 11:19.170
这玩意是个对象吗

11:19.170 --> 11:20.050
它对应就这个对象

11:20.050 --> 11:21.810
这个对象里面就是一组一组

11:21.810 --> 11:23.010
所有的比较use state

11:23.010 --> 11:24.290
对应的是mount state

11:24.290 --> 11:24.850
use ref

11:24.850 --> 11:26.290
对应的是mount ref

11:26.290 --> 11:26.450
好

11:26.450 --> 11:29.890
你如果是这个更新的话

11:29.890 --> 11:30.450
更新的话

11:30.450 --> 11:31.570
它负责的是

11:31.570 --> 11:32.290
是不是这个对象

11:33.490 --> 11:34.210
对不对

11:34.210 --> 11:35.410
这个对象

11:35.490 --> 11:36.690
所以说我们这边让我们来记一下

11:39.550 --> 11:40.270
判断了

11:42.580 --> 11:46.340
判断了是这个mount

11:47.380 --> 11:49.380
还是update

11:50.100 --> 11:50.420
之后

11:51.220 --> 11:52.020
会什么呢

11:52.020 --> 11:55.380
会给这个react current

11:55.380 --> 11:56.900
dispatcher点current

11:58.420 --> 12:01.380
负责对应的什么

12:01.380 --> 12:02.900
是不是对应的这个dispatcher

12:04.500 --> 12:05.060
对不对

12:05.060 --> 12:06.660
会负责对应的这个dispatcher

12:07.540 --> 12:07.700
好

12:07.700 --> 12:08.420
如果你这边

12:08.500 --> 12:09.140
你这个边的话

12:09.140 --> 12:10.340
你因为你给他负责了

12:10.340 --> 12:11.620
这个不同的这个上下文

12:11.620 --> 12:14.020
所以他就可以根据这个不同的上下文

12:14.020 --> 12:15.540
调用这个不同的hook

12:16.900 --> 12:18.660
因为负责了

12:19.780 --> 12:24.820
负责了不同的上下文对象

12:24.820 --> 12:27.220
因此就可以

12:27.220 --> 12:28.020
干嘛

12:28.020 --> 12:32.020
根据不同上下文对象

12:33.140 --> 12:34.100
然后调用什么

12:35.380 --> 12:36.900
调用这个不同的方法

12:39.180 --> 12:39.500
对不对

12:40.060 --> 12:41.660
比如说你这边有这个浅套的

12:42.540 --> 12:42.860
假设

12:43.980 --> 12:45.420
假设有这个浅套的

12:47.600 --> 12:48.880
有这个浅套的hook

12:51.310 --> 12:53.550
有浅套的hook

12:54.830 --> 12:56.030
比如你这边这样子写的

12:56.750 --> 12:58.270
UseEffect

13:01.420 --> 13:01.740
好

13:01.740 --> 13:03.180
然后里面你就干嘛呢

13:03.180 --> 13:04.460
里面你要UseState

13:06.300 --> 13:07.820
那这个时候的话

13:07.820 --> 13:08.940
他这边的话就会干嘛呢

13:08.940 --> 13:10.140
他这边的话就是

13:10.140 --> 13:11.580
你这种错误形式嘛

13:11.580 --> 13:12.300
错误形式的话

13:12.300 --> 13:13.020
你此时的话

13:13.100 --> 13:16.300
他的这个react current dispatcher

13:16.300 --> 13:18.620
他指向哪个呢

13:18.620 --> 13:19.180
指向这个

13:20.220 --> 13:23.020
指向context only this dispatcher

13:23.020 --> 13:23.820
那么此时的话

13:23.820 --> 13:24.700
他就会执行什么呢

13:24.700 --> 13:25.500
他就会执行这个

13:26.140 --> 13:27.980
so invite hook error

13:30.300 --> 13:35.580
那么此时的上下文对象

13:36.300 --> 13:37.980
指向哪个呢

13:37.980 --> 13:38.540
指向这个

13:39.980 --> 13:40.620
指向这个

13:42.720 --> 13:44.560
然后最终

13:44.560 --> 13:45.680
执行的

13:45.680 --> 13:46.320
就是什么呢

13:46.320 --> 13:49.360
就是这个so invite hook error

13:51.040 --> 13:53.360
然后拨出错误

13:54.800 --> 13:55.440
对

13:55.440 --> 13:56.080
拨出错误

13:57.280 --> 13:57.440
好

13:57.440 --> 13:59.680
这是首先关于这个生产策略

13:59.680 --> 14:00.640
首先先介绍一下

14:01.280 --> 14:01.520
好

14:01.520 --> 14:02.400
然后接下来的话

14:02.400 --> 14:03.040
我们来看一下

14:03.040 --> 14:04.720
关于这个hook

14:04.720 --> 14:06.160
他的一个数据结构

14:07.200 --> 14:07.760
接下来

14:08.400 --> 14:09.680
我们来看一下

14:10.240 --> 14:13.520
这个hook的一个数据结构

14:14.720 --> 14:15.360
hook的话

14:15.360 --> 14:17.040
他本身的话也是一个对象

14:17.680 --> 14:18.240
他这边的话

14:18.240 --> 14:19.520
大致是这个样子的

14:20.320 --> 14:20.480
好

14:20.480 --> 14:21.280
把这个拉过来

14:23.650 --> 14:23.810
好

14:23.810 --> 14:25.250
这边大家可以看一下

14:25.250 --> 14:25.730
你可以看到

14:25.730 --> 14:27.090
hook对应的是不是也是个对象

14:27.570 --> 14:28.690
在对象里面的话

14:28.690 --> 14:30.370
会有这么一些字段

14:30.370 --> 14:32.210
首先这个是memored

14:33.010 --> 14:34.450
这这个应该怎么念啊

14:34.450 --> 14:35.010
memored

14:35.490 --> 14:36.530
稍等我看一下啊

14:36.530 --> 14:37.490
看一下这个该怎么念

14:41.040 --> 14:42.480
这个是memored

14:42.880 --> 14:43.600
memored

14:43.600 --> 14:44.480
他这个是一个

14:46.480 --> 14:47.040
memored

14:48.400 --> 14:48.800
诶

14:50.750 --> 14:52.110
还没有这个单词

14:53.550 --> 14:54.350
memored

14:54.910 --> 14:55.390
memored

14:55.390 --> 14:57.150
他反正是那个memored的一个单词

14:57.950 --> 14:58.670
我看一下这个呢

14:59.710 --> 15:00.430
memorization

15:01.150 --> 15:02.270
memorization

15:03.070 --> 15:04.110
memorization

15:05.470 --> 15:06.590
memorization

15:06.590 --> 15:07.630
这个是memorization

15:08.190 --> 15:09.550
这个是memorization的话呢

15:09.550 --> 15:10.190
这个就是

15:10.910 --> 15:11.710
memo

15:11.710 --> 15:12.670
就叫memored state

15:12.990 --> 15:14.910
memored state

15:15.470 --> 15:16.110
这个呢就是什么呢

15:16.110 --> 15:17.710
这个就是存储它的这个状态

15:17.710 --> 15:18.910
但是你这个要注意

15:18.910 --> 15:20.590
这个的话根据这个不同的

15:21.390 --> 15:22.030
根据这个

15:23.230 --> 15:24.430
不同的这个这个

15:24.430 --> 15:25.070
hook

15:25.070 --> 15:27.070
它这个存储的这个内容是不一样的

15:27.790 --> 15:28.030
ok

15:28.590 --> 15:28.910
好

15:28.910 --> 15:29.550
然后接下来的话

15:29.550 --> 15:31.470
这个是best state

15:31.470 --> 15:33.950
这个是存储一个基础的状态

15:33.950 --> 15:35.070
然后再加这边

15:35.070 --> 15:35.710
best queue

15:36.670 --> 15:38.190
这个是一个对立

15:38.190 --> 15:39.310
然后再加这边q

15:39.310 --> 15:40.030
next

15:40.030 --> 15:40.510
这边呢

15:40.510 --> 15:42.430
会有一些比较重要的这个字段

15:43.070 --> 15:43.710
这个next

15:43.710 --> 15:45.950
这个next是连接下一个hook的

15:45.950 --> 15:47.950
你会发现了这个hook也是就是

15:47.950 --> 15:49.630
通过练表的形式

15:49.630 --> 15:50.750
练起来的

15:50.750 --> 15:51.150
ok

15:51.950 --> 15:52.270
好

15:52.270 --> 15:53.870
这边的话需要注意这个

15:54.830 --> 15:55.950
memored state

16:00.300 --> 16:02.460
这里需要注意

16:03.020 --> 16:03.740
就这个字段

16:06.990 --> 16:07.790
memored state

16:08.590 --> 16:09.390
注意这个字段

16:10.510 --> 16:10.910
ok

16:10.910 --> 16:11.630
为什么呢

16:11.630 --> 16:13.230
因为这个在这个fiber

16:13.870 --> 16:16.110
fiber对象上面也有一个这个字段

16:16.990 --> 16:17.630
因为在

16:18.510 --> 16:21.150
fiber load上面

16:21.150 --> 16:22.430
也有一个

16:23.230 --> 16:23.870
也有一个

16:24.510 --> 16:26.510
也有这么一个字段

16:28.590 --> 16:28.990
ok

16:28.990 --> 16:30.190
也有这么一个字段

16:30.190 --> 16:31.870
说经常容易搞这个搞混

16:31.870 --> 16:33.870
你去看那个react原码

16:33.870 --> 16:35.230
就经常容易被搞混

16:35.230 --> 16:35.630
为什么呢

16:35.630 --> 16:37.230
因为它很多它用的是同名的

16:37.790 --> 16:38.670
很多用的同名的

16:38.670 --> 16:39.710
但是它这个在

16:39.710 --> 16:41.310
比如说不同上下文

16:41.310 --> 16:41.870
里面

16:41.870 --> 16:43.070
它这边的话对的东西

16:43.070 --> 16:44.110
实际上是不一样的

16:45.470 --> 16:45.870
知道吧

16:46.510 --> 16:47.470
所以这边一定要注意

16:48.030 --> 16:49.710
fiber load上面也有这么一个字段

16:50.430 --> 16:51.470
然后语什么呢

16:52.430 --> 16:53.230
语互可

16:53.230 --> 16:54.030
互可我们刚说了

16:54.030 --> 16:54.990
互可是个对象吧

16:54.990 --> 16:55.470
在这里

16:56.190 --> 16:56.590
对不对

16:56.590 --> 16:57.230
语互可

16:57.950 --> 17:01.790
对象上面的这个memored state

17:03.390 --> 17:06.990
存储的东西是不一样的

17:08.110 --> 17:08.670
ok

17:08.670 --> 17:09.790
存储东西是不一样的

17:10.750 --> 17:11.230
你这个

17:13.230 --> 17:14.350
如果是fiber load

17:15.070 --> 17:16.910
fiber load

17:16.910 --> 17:18.910
点这个memored state

17:21.600 --> 17:22.720
它存储的是什么呢

17:22.720 --> 17:23.920
它存储的是这个

17:23.920 --> 17:25.760
hooks列表里面的这个

17:25.760 --> 17:26.480
第一个列表

17:27.280 --> 17:28.400
保存的是

17:29.360 --> 17:31.120
hooks列表

17:31.120 --> 17:32.160
因为我刚说过这个

17:32.160 --> 17:33.120
hook它会以什么

17:33.120 --> 17:34.560
它会以这个列表的形式

17:34.560 --> 17:35.280
是不是串起来

17:35.920 --> 17:36.400
对不对

17:36.400 --> 17:37.760
它以列表的形式

17:37.760 --> 17:39.200
这个串起来通过什么呢

17:39.200 --> 17:40.160
通过这个next

17:41.280 --> 17:42.240
通过next

17:42.240 --> 17:44.240
指向下一个这个hook

17:44.560 --> 17:46.000
那么这个fiber load

17:46.320 --> 17:47.520
memored state

17:47.520 --> 17:49.680
它保存的就是hooks列表

17:49.680 --> 17:53.680
里面的第一个列表

17:54.960 --> 17:55.840
ok

17:55.840 --> 17:56.080
好

17:56.080 --> 17:57.360
那如果是这个hook

17:58.160 --> 18:00.480
hook点memored state

18:03.410 --> 18:04.530
它保存的是什么呢

18:04.530 --> 18:05.970
它保存的就是某个

18:07.170 --> 18:08.450
某个hook

18:09.090 --> 18:10.050
自身的数据

18:11.730 --> 18:13.970
主要两个东西是不一样的

18:14.770 --> 18:15.330
而且

18:16.050 --> 18:16.930
而且

18:16.930 --> 18:19.810
不同类型的这个hook

18:20.370 --> 18:22.850
你这个hook点memored state

18:24.880 --> 18:26.960
它存储的东西也是不一样的

18:28.080 --> 18:33.120
所存储的内容也是不同的

18:34.240 --> 18:35.360
也是不同的

18:35.360 --> 18:36.400
比如说我们这边

18:36.400 --> 18:37.760
把这边我就直接把人拿过来了

18:38.640 --> 18:39.680
这边大家可以看一下

18:43.950 --> 18:44.350
这里

18:44.990 --> 18:46.990
对于这个user state来讲

18:47.550 --> 18:49.390
那它这个memored state

18:49.390 --> 18:50.590
它保存的是什么呢

18:50.670 --> 18:52.670
它保存的是state的字

18:53.790 --> 18:55.950
如果是user radiuser

18:55.950 --> 18:58.270
它这边保存的也是state的字

18:58.910 --> 19:00.910
如果是user effect

19:00.910 --> 19:01.950
它保存的是什么呢

19:01.950 --> 19:03.630
保存的是你这边callback

19:03.630 --> 19:05.790
以及你依赖的数据

19:06.350 --> 19:07.870
如果是user ref

19:07.870 --> 19:09.390
它保存的是这么一个对象

19:10.670 --> 19:11.230
怎么样

19:11.230 --> 19:12.350
保存的是这么一个对象

19:12.350 --> 19:13.310
user memo

19:13.310 --> 19:14.830
保存的是callback

19:14.830 --> 19:16.350
它这callback它是执行过的

19:17.870 --> 19:18.430
怎么样

19:18.430 --> 19:19.070
它执行过了

19:19.070 --> 19:19.790
它得到一个值

19:20.270 --> 19:22.030
我们之前学这个user memo

19:22.030 --> 19:22.990
我们说过user memo

19:22.990 --> 19:23.870
它是干嘛

19:23.870 --> 19:24.750
是缓冲一个值

19:25.390 --> 19:25.630
对吧

19:25.630 --> 19:27.550
所以它这边会把callback执行

19:27.550 --> 19:28.830
然后一起依赖

19:29.710 --> 19:29.870
好

19:29.870 --> 19:30.990
如果是user callback

19:30.990 --> 19:32.830
user callback把它保存的就是什么呢

19:32.830 --> 19:34.430
保存的就是callback本身

19:35.070 --> 19:35.870
以及依赖

19:36.510 --> 19:36.750
好

19:36.750 --> 19:37.470
然后有些

19:37.950 --> 19:38.750
有些户口的话

19:38.750 --> 19:42.110
它是不需要这个memored state

19:42.110 --> 19:43.390
这个数据的

19:43.390 --> 19:44.670
比如这个user context

19:45.390 --> 19:45.950
怎么样

19:45.950 --> 19:46.510
注意哦

19:46.510 --> 19:47.630
把这句话给你加粗

19:48.350 --> 19:50.910
它这个不同的这个户口对象

19:50.910 --> 19:52.990
它对的这个memored state

19:52.990 --> 19:55.550
它所存储的内容也是不一样的

19:55.550 --> 19:56.590
包括这边

19:56.590 --> 19:57.230
这边也是

19:57.230 --> 19:58.510
这边这个

19:58.510 --> 19:59.790
这边也要注意

19:59.790 --> 20:01.790
fiberload memo state

20:01.790 --> 20:03.310
和户口 memo state

20:03.310 --> 20:05.310
两个存储的东西是不一样的

20:06.910 --> 20:07.150
好

20:07.150 --> 20:09.950
这是关于这个户口的这么一个数据结构

20:10.750 --> 20:11.150
好

20:11.150 --> 20:11.950
那完事之后

20:11.950 --> 20:13.230
接下来我们就来看一下

20:13.230 --> 20:16.110
看一下整个这个fc

20:16.670 --> 20:18.110
它这边就是

20:18.110 --> 20:19.150
render阶段的时候

20:19.790 --> 20:22.270
它这个mount和update

20:22.270 --> 20:23.310
这个update

20:23.310 --> 20:24.830
究竟会做些什么

20:27.790 --> 20:28.110
好

20:28.110 --> 20:28.750
这里

20:28.750 --> 20:29.390
这里的话

20:29.390 --> 20:32.430
首先当这个fc进行render的时候

20:33.230 --> 20:33.790
它这边呢

20:33.790 --> 20:35.070
首先会执行一个什么呢

20:35.070 --> 20:38.350
首先它会执行一个叫做render with hooks

20:39.870 --> 20:43.710
当fc进入到

20:44.590 --> 20:46.990
进入到render阶段时

20:47.950 --> 20:50.190
首先会被什么呢

20:50.190 --> 20:53.710
会被这个render with hooks

20:54.910 --> 20:56.270
然后函数

20:56.270 --> 20:56.910
处理执行

20:58.670 --> 20:59.310
OK

20:59.310 --> 21:00.830
那我们来看一下这个代码

21:00.830 --> 21:02.270
看一下这个render with hooks

21:03.070 --> 21:04.830
看一下它的这个代码片段

21:05.390 --> 21:05.550
好

21:05.550 --> 21:06.430
这边我把它拿过来

21:10.580 --> 21:10.900
好

21:10.900 --> 21:11.940
这边大家可以看一下

21:12.820 --> 21:13.620
首先练这些

21:13.620 --> 21:14.580
先不用管它

21:14.580 --> 21:15.460
这边你看

21:15.460 --> 21:18.340
每一次执行这个函数组件之前

21:18.340 --> 21:19.140
它会干嘛呢

21:19.220 --> 21:21.140
它会先清空这个

21:21.140 --> 21:21.860
memored state

21:22.740 --> 21:24.660
这个是这个walk in programs

21:24.660 --> 21:25.300
这个是什么

21:25.300 --> 21:26.100
这个是不是就是

21:26.100 --> 21:27.460
当前的那个fiber

21:28.020 --> 21:29.700
就是相当于是这个web

21:30.260 --> 21:31.140
webfiberload

21:31.540 --> 21:32.580
webfiberload的话

21:32.580 --> 21:33.700
它就是一个fiber吧

21:33.700 --> 21:34.180
fiber的话

21:34.180 --> 21:36.180
我们刚刚说了这个memored state

21:37.220 --> 21:38.660
memored state这里

21:38.660 --> 21:39.460
存的是什么

21:39.460 --> 21:40.580
是不是存的是这个

21:40.580 --> 21:41.940
hook练表里面的第一个

21:42.500 --> 21:43.060
对

21:43.060 --> 21:43.620
第一个

21:43.620 --> 21:44.100
那这边的话

21:44.100 --> 21:45.380
它首先把它这个清空

21:46.020 --> 21:46.100
好

21:46.100 --> 21:47.140
然后接下来把这个

21:47.140 --> 21:48.580
当前这个fiber的这个

21:48.580 --> 21:49.780
update quick这个q

21:50.340 --> 21:51.860
把这个的话也清空

21:52.500 --> 21:52.820
好

21:52.820 --> 21:53.540
清空了之后

21:53.540 --> 21:54.740
然后接下来你看这边

21:55.940 --> 21:56.660
这边

21:56.660 --> 21:57.380
这边的话

21:57.380 --> 21:58.420
它就会判断什么呢

21:58.420 --> 21:59.300
它就会判断

21:59.300 --> 22:00.740
你是这个初始化

22:00.740 --> 22:02.020
还是这个更新

22:02.980 --> 22:03.460
怎么样

22:03.460 --> 22:04.660
它根据你这边

22:04.660 --> 22:05.700
这边这个current

22:06.260 --> 22:07.220
是否是这个now

22:08.580 --> 22:10.900
如果是now的话就是什么

22:10.900 --> 22:12.100
是不是就是应该是mount

22:12.100 --> 22:12.420
对了

22:12.420 --> 22:14.020
所以它这边就是mount

22:14.020 --> 22:14.740
否则就是什么呢

22:14.740 --> 22:15.780
否则就是更新

22:15.780 --> 22:16.980
你看这边就是干嘛

22:16.980 --> 22:17.700
这边是不是就是

22:18.260 --> 22:19.380
这边我们写一下

22:19.380 --> 22:20.900
这边的话就是初始化

22:22.820 --> 22:24.100
初始化

22:24.100 --> 22:26.420
这个对应的

22:26.420 --> 22:26.740
这个

22:27.860 --> 22:28.660
这个叫做什么

22:28.660 --> 22:29.460
上下文对象

22:30.180 --> 22:30.980
上下文

22:33.940 --> 22:36.180
上下文对象

22:37.140 --> 22:37.620
对了

22:37.620 --> 22:38.900
把这个上下文对象

22:38.900 --> 22:39.700
把它初始化了

22:39.700 --> 22:40.420
初始化了之后

22:40.420 --> 22:42.020
不同的这个上下文对象

22:42.020 --> 22:42.980
是不是对应

22:42.980 --> 22:44.660
一组不同的这个方法

22:45.620 --> 22:46.100
对了

22:46.100 --> 22:48.900
不同的上下文对象

22:49.540 --> 22:50.260
对应了

22:51.140 --> 22:51.700
不同的

22:52.420 --> 22:53.140
对应了一组

22:53.140 --> 22:54.820
对应了一组

22:54.820 --> 22:56.740
不同的这个方法

22:57.860 --> 22:58.740
对不对

22:58.740 --> 22:58.980
好

22:58.980 --> 22:59.940
然后接下来这边

22:59.940 --> 23:00.340
这边呢

23:00.340 --> 23:01.940
开始真正的执行

23:01.940 --> 23:03.540
这个函数组件

23:03.540 --> 23:05.140
这边通过这个component

23:05.140 --> 23:06.100
来执行

23:06.100 --> 23:06.820
但是你现在的话

23:06.820 --> 23:07.460
你这个状态

23:07.460 --> 23:07.860
状态的话

23:07.860 --> 23:09.380
它是可以通过这个fiber

23:09.380 --> 23:10.500
这边拿到的

23:10.500 --> 23:11.220
对不对

23:11.220 --> 23:11.540
好

23:11.540 --> 23:12.660
然后再这边执行

23:12.660 --> 23:13.540
执行完了之后

23:13.540 --> 23:15.620
然后再这边判断这个环境

23:15.620 --> 23:17.060
然后再这边return

23:17.060 --> 23:17.300
好

23:17.300 --> 23:17.860
你注意这边

23:17.940 --> 23:18.340
这边呢

23:18.340 --> 23:20.340
它在执行这个Felix Render

23:20.340 --> 23:22.260
Rendering Hooks的时候

23:22.260 --> 23:22.820
然后这里

23:24.020 --> 23:24.420
这里

23:24.420 --> 23:25.220
这里方法

23:25.220 --> 23:25.860
这里你看

23:25.860 --> 23:27.700
它这边有一个这个很重要的

23:27.700 --> 23:28.660
它这边干嘛

23:28.660 --> 23:29.140
这边呢

23:29.140 --> 23:31.060
它是不是就是把这个dispatcher

23:31.060 --> 23:32.020
设置为了什么

23:32.020 --> 23:34.980
是设置为了context onlyDispatcher

23:36.260 --> 23:36.900
对不对

23:36.900 --> 23:37.380
这个的话

23:37.380 --> 23:39.140
就是防止你这个hooks

23:39.140 --> 23:41.140
在函数组件外部调用

23:41.140 --> 23:42.820
或者这种嵌套的调用

23:42.820 --> 23:43.700
你如果调用的话

23:43.700 --> 23:44.740
它就会直接爆冲

23:45.780 --> 23:46.420
没有没有

23:46.500 --> 23:47.860
所以它在最后

23:47.860 --> 23:48.500
在最后

23:48.500 --> 23:48.900
最后的话

23:48.900 --> 23:50.340
它会调这个Felix

23:50.340 --> 23:51.860
Felix就是完成的意思嘛

23:51.860 --> 23:52.260
对不对

23:52.260 --> 23:53.380
完成渲染

23:53.380 --> 23:54.340
那完成渲染之后

23:54.340 --> 23:55.700
它就会把这个上下文

23:55.700 --> 23:58.180
设置为这个context onlyDispatcher

23:58.980 --> 23:59.940
看到没有

23:59.940 --> 24:00.580
OK

24:00.580 --> 24:01.140
所以我们这边呢

24:01.140 --> 24:01.860
我们来总结一下

24:03.460 --> 24:05.380
这个Render with Hooks方法

24:09.440 --> 24:10.720
Render with Hooks方法

24:11.600 --> 24:12.640
会在什么呢

24:12.640 --> 24:16.480
会在每次函数组件

24:17.840 --> 24:19.280
函数组件触发时

24:22.290 --> 24:22.930
触发时

24:24.050 --> 24:25.090
这触发时就包含什么

24:25.090 --> 24:26.530
这包含这个mount

24:26.530 --> 24:27.490
以及这个update

24:28.850 --> 24:30.530
以及update

24:31.090 --> 24:31.330
对吧

24:31.330 --> 24:32.290
无论你mount也好

24:32.290 --> 24:33.490
还是update也好

24:33.490 --> 24:36.370
它都会重新触发这个函数组件的这个渲染

24:37.170 --> 24:37.330
好

24:37.330 --> 24:38.770
每次这个函数组件触发

24:39.250 --> 24:40.450
触发到这个时候

24:40.450 --> 24:42.530
那这个该方法就会干嘛呢

24:42.530 --> 24:43.250
该方法

24:45.470 --> 24:46.910
该方法

24:46.910 --> 24:48.270
就会清空

24:52.300 --> 24:52.940
清空

24:53.500 --> 24:54.220
这个walk

24:55.180 --> 24:57.580
walk in programs

24:59.950 --> 25:00.990
的这个

25:00.990 --> 25:01.710
什么

25:01.710 --> 25:02.670
这个memo

25:03.390 --> 25:04.670
memo state

25:07.900 --> 25:10.060
以及这个update queue

25:10.940 --> 25:12.300
这个呢是更新对立

25:12.300 --> 25:14.220
这个我们后面讲那个副作用的时候会说

25:15.180 --> 25:16.700
以及update queue

25:16.700 --> 25:17.020
好

25:17.020 --> 25:17.900
然后接下来干嘛

25:18.700 --> 25:20.060
接下来判断这个组件

25:20.060 --> 25:21.980
究竟是初始化还是更新

25:21.980 --> 25:22.460
对不对

25:23.020 --> 25:24.620
接下来判断

25:25.580 --> 25:26.460
该组件

25:27.180 --> 25:30.300
究竟是初始化

25:30.300 --> 25:32.380
还是更新

25:32.380 --> 25:33.420
然后接下来判干嘛

25:33.420 --> 25:39.100
是不是负责为这个这个react current

25:39.100 --> 25:40.540
dispatcher.current

25:43.680 --> 25:48.000
负责不同的上下文对象

25:48.720 --> 25:49.360
对不对

25:49.360 --> 25:49.600
好

25:49.600 --> 25:50.640
然后再之后

25:50.640 --> 25:52.240
之后的话就是调用什么呢

25:52.800 --> 25:55.040
调用这个component方法

25:57.380 --> 25:58.660
调用component

25:59.220 --> 25:59.700
方法

26:00.260 --> 26:01.620
来执行

26:02.260 --> 26:02.980
函数组件

26:04.020 --> 26:06.980
你执行函数组件里面就是具体的这个渲染

26:07.860 --> 26:08.100
好

26:08.100 --> 26:10.260
然后组件里面所书写的这个hook

26:10.260 --> 26:11.460
它就会一次执行

26:12.900 --> 26:14.420
组件里面

26:15.300 --> 26:18.500
所书写的这个hook

26:19.300 --> 26:21.140
就会一次执行

26:22.900 --> 26:23.700
ok

26:23.700 --> 26:25.060
大致的话这个方法的话

26:25.060 --> 26:26.020
它的这个流程

26:26.500 --> 26:27.300
就是这个样子的

26:30.180 --> 26:30.500
好

26:30.500 --> 26:31.380
那接下来的话

26:31.380 --> 26:32.260
我们这边的话

26:32.260 --> 26:34.180
我们就以一个例子

26:34.180 --> 26:34.740
接下来

26:36.260 --> 26:37.220
接下来

26:37.220 --> 26:38.900
我们来以

26:40.500 --> 26:40.980
你怎么呢

26:40.980 --> 26:42.980
以这个user effect

26:42.980 --> 26:43.940
不是user effect

26:43.940 --> 26:44.660
user state

26:45.540 --> 26:45.940
回例

26:46.820 --> 26:47.780
然后看一下

26:48.420 --> 26:49.620
整个流程

26:49.620 --> 26:52.100
整个hook的执行流程

26:54.450 --> 26:55.010
ok

26:55.010 --> 26:56.050
你刚才这个

26:56.050 --> 26:57.170
刚才这个的话

26:57.170 --> 26:59.730
是无论你是这个mount

26:59.730 --> 27:01.170
还是这个update

27:01.250 --> 27:03.170
你这边只要这个函数组件

27:03.170 --> 27:05.010
只要你这个函数组件这个

27:05.730 --> 27:07.410
更新是不是就会执行

27:07.410 --> 27:08.370
你要分清楚

27:08.370 --> 27:09.170
就这个方法

27:09.170 --> 27:10.930
这个方法是只要你函数组件更新

27:10.930 --> 27:11.970
就会执行的

27:11.970 --> 27:12.530
ok

27:12.530 --> 27:13.330
在这个方法里面

27:13.330 --> 27:15.170
它这边是不是就把这个上下文对象

27:15.170 --> 27:16.210
其实最重要的就是这个

27:16.770 --> 27:18.210
是把这个上下文对象

27:18.770 --> 27:20.930
是这个指向把人明确了

27:20.930 --> 27:21.330
对不对

27:21.330 --> 27:22.050
明确了之后

27:22.050 --> 27:23.970
然后你这边它执行这个component

27:23.970 --> 27:25.890
component这边就是执行你这个

27:26.450 --> 27:28.130
函数里面的这个代码

27:28.130 --> 27:29.010
因为你函数组件

27:29.010 --> 27:30.530
本质其实对应的就是个函数嘛

27:31.170 --> 27:31.730
对不对

27:31.730 --> 27:32.770
执行里面的这个代码

27:32.770 --> 27:33.490
执行代码的话

27:33.490 --> 27:34.850
那接下来流程就会来到什么呢

27:34.850 --> 27:36.210
就会来到函数那一步

27:36.770 --> 27:37.330
ok

27:37.330 --> 27:38.530
就会来到函数那一步

27:38.530 --> 27:39.010
好

27:39.010 --> 27:39.330
好来

27:39.330 --> 27:40.450
接下来我们这边来看一下

27:41.650 --> 27:41.810
好

27:41.810 --> 27:42.690
我们这边假设

27:42.690 --> 27:45.410
假设我们这边以这个user state为例

27:45.410 --> 27:47.490
假设写了这么一个代码

27:48.130 --> 27:48.770
这边的话

27:49.170 --> 27:49.650
count

27:50.610 --> 27:52.450
然后这边是一个count

27:52.850 --> 27:55.010
然后比如说一个set count

27:57.090 --> 27:57.810
set count

27:57.810 --> 27:59.970
等于一个user state

28:02.430 --> 28:03.070
0

28:03.070 --> 28:05.310
加上我们的这个函数

28:05.310 --> 28:06.590
函数组件里面

28:06.590 --> 28:07.390
我们这这样子

28:07.390 --> 28:08.590
我们这边的话

28:08.590 --> 28:09.950
就写一个组件嘛

28:10.830 --> 28:11.470
有app

28:12.990 --> 28:13.550
对吧

28:13.550 --> 28:13.790
好

28:13.790 --> 28:14.430
这里面

28:14.430 --> 28:15.390
大家这边return

28:16.350 --> 28:18.590
return一个DIV

28:18.590 --> 28:19.710
把这个改成gsx

28:22.000 --> 28:22.400
好

28:22.400 --> 28:23.920
让大家这边的一个count

28:25.360 --> 28:26.000
大家这边

28:27.840 --> 28:28.240
click

28:30.480 --> 28:30.720
好

28:30.720 --> 28:31.520
让大家这里

28:33.900 --> 28:34.620
set count

28:36.700 --> 28:37.340
count

28:37.340 --> 28:37.740
加1

28:38.220 --> 28:38.540
ok

28:38.540 --> 28:40.460
这个就是一个最简单的组件

28:40.460 --> 28:41.100
对不对

28:41.100 --> 28:41.260
好

28:41.260 --> 28:43.100
你上面的代码执行到这一步的时候

28:43.660 --> 28:44.540
执行到这一步的时候

28:44.540 --> 28:46.540
它是不是就会去执行这个函数组件

28:46.540 --> 28:48.140
那接下来这边代码是不是就会来到这

28:48.700 --> 28:49.180
对不对

28:49.180 --> 28:50.700
一句一句的这个执行

28:50.700 --> 28:51.020
好

28:51.020 --> 28:51.500
执行的话

28:51.500 --> 28:52.620
然后接下来这边

28:52.620 --> 28:54.780
这边的话就会根据你究竟是mount

28:54.780 --> 28:56.060
还是update

28:56.060 --> 28:57.420
调用不同的函数

28:59.260 --> 28:59.820
接下来

29:00.540 --> 29:02.700
就会根据

29:02.700 --> 29:04.140
你是这个mount

29:04.700 --> 29:06.060
还是update

29:07.980 --> 29:10.940
调用不同上下文

29:12.460 --> 29:12.860
里面

29:14.140 --> 29:15.900
上下文里面

29:16.540 --> 29:19.260
所对应的方法

29:20.140 --> 29:20.620
ok

29:20.620 --> 29:21.580
你如果是mount

29:21.580 --> 29:23.260
mount调用的就是mount

29:23.260 --> 29:23.740
差差差

29:24.460 --> 29:25.260
对不对

29:25.260 --> 29:25.980
它这边的话

29:25.980 --> 29:28.140
它能不能知道你究竟是这个mount

29:28.140 --> 29:29.100
还是update

29:29.100 --> 29:29.660
能吗

29:29.660 --> 29:32.540
因为你这边你在执行这个component之前

29:32.620 --> 29:35.740
你这边是不是已经把这个上下文对象就已经就切换了

29:36.620 --> 29:37.180
对不对

29:37.180 --> 29:38.380
说它这边的话是能够

29:38.940 --> 29:41.100
这个知道你究竟是mount

29:41.100 --> 29:42.780
还是这个update

29:42.780 --> 29:44.460
它上下文已经切换好了

29:44.460 --> 29:44.860
对不对

29:44.860 --> 29:46.540
只需要执行

29:46.540 --> 29:49.020
或者说调用这个不同的上下文

29:49.020 --> 29:50.540
所对应的这个方法就可以了

29:51.820 --> 29:52.060
好

29:52.060 --> 29:53.500
那我们这边先来看什么呢

29:53.500 --> 29:54.860
先来看这个mount阶段

29:56.780 --> 29:58.540
mount阶段

29:58.540 --> 30:00.380
你这边看一下这边mount阶段

30:00.380 --> 30:01.500
回到这里上面

30:01.500 --> 30:02.300
mount阶段呢

30:02.300 --> 30:04.060
这边它实际上调用的是吗

30:04.060 --> 30:04.780
调用的是不是

30:04.780 --> 30:05.660
mount state

30:06.540 --> 30:06.940
对不对

30:07.580 --> 30:08.300
这里

30:08.300 --> 30:09.100
mount阶段

30:09.740 --> 30:12.780
调用的是mount state

30:13.420 --> 30:13.580
好

30:13.580 --> 30:15.020
调用到这个mount state

30:15.020 --> 30:16.540
我们这边来看一下相关的代码

30:17.500 --> 30:19.260
相关代码

30:19.260 --> 30:19.660
如下

30:21.340 --> 30:21.580
好

30:21.580 --> 30:23.500
这边把它这个对应的这个代码

30:23.500 --> 30:24.460
把它过来

30:27.300 --> 30:27.540
好

30:27.540 --> 30:28.740
这边来看一下

30:28.740 --> 30:31.780
它整形来讲的话分成这么几步

30:31.780 --> 30:32.500
首先第一步

30:33.140 --> 30:33.780
第一步的话

30:33.780 --> 30:36.660
这边是调用一个叫做mount hook

30:37.300 --> 30:38.500
in progress hook

30:39.220 --> 30:39.860
这个方法呢

30:39.860 --> 30:41.060
它会有一个返回值

30:41.060 --> 30:42.260
返回的是一个对象

30:42.260 --> 30:43.860
它复制给这个hook

30:43.860 --> 30:45.380
这个方法实际上是什么

30:45.380 --> 30:48.020
这个方法其实就是创建hook对象

30:50.820 --> 30:51.460
没有吧

30:51.460 --> 30:52.900
这个方法就是创建hook对象

30:52.900 --> 30:53.300
那这样子

30:53.300 --> 30:54.740
我们先看一下这个方法

30:54.740 --> 30:56.580
我在这下面

30:57.300 --> 31:04.740
上面在执行这个mount state的时候

31:04.740 --> 31:07.780
首先调用了什么

31:07.780 --> 31:10.660
调用了mount walk in progress hook

31:10.660 --> 31:14.900
该方法的作用就是什么呢

31:14.900 --> 31:18.660
就是创建一个hook对象

31:18.660 --> 31:20.820
我们刚才说了这个hook

31:20.820 --> 31:22.980
它的这个数据结构是什么样子的

31:22.980 --> 31:23.860
是不是这个样子的

31:23.860 --> 31:25.300
是这样子的

31:25.300 --> 31:25.860
对不对

31:26.020 --> 31:26.820
那这个方法

31:27.620 --> 31:28.340
这个方法的话

31:28.340 --> 31:31.300
它的作用其实像就是创建这么一个hook对象

31:31.300 --> 31:32.260
这边你可以看一下

31:35.300 --> 31:37.140
相关代码如下

31:40.100 --> 31:40.900
先把这个

31:41.860 --> 31:42.180
过来

31:46.980 --> 31:47.860
这里

31:47.860 --> 31:48.900
你看这边

31:48.900 --> 31:50.740
这边是不是有一个这个hook对象

31:52.100 --> 31:52.980
对不对

31:52.980 --> 31:53.620
hook对象

31:53.620 --> 31:56.020
那这边有这个memeral state

31:56.020 --> 31:57.780
那这个baseq

31:57.780 --> 32:00.100
base state baseqq

32:00.100 --> 32:00.820
然后next

32:01.540 --> 32:03.460
然后既然它这边的话会判断你

32:03.460 --> 32:05.700
就是当前的这个hook练表

32:05.700 --> 32:06.420
是空

32:06.420 --> 32:07.780
还是说就是不为空

32:08.580 --> 32:09.540
你如果是空

32:09.540 --> 32:10.660
空的话就说明什么呢

32:10.660 --> 32:12.900
说明你当前的hook是第一个hook

32:13.620 --> 32:14.180
对呀

32:14.180 --> 32:15.140
你最终的话注意

32:15.140 --> 32:16.580
最终这个hook

32:16.580 --> 32:19.060
它是要以练表的形式串起来的

32:21.070 --> 32:21.470
最终

32:22.270 --> 32:29.710
hook对象是要以练表形式串连起来的

32:30.830 --> 32:31.630
就像那个fiber

32:31.950 --> 32:32.350
对吧

32:33.070 --> 32:33.630
因此

32:34.910 --> 32:35.470
需要

32:37.150 --> 32:38.830
需要判断

32:38.830 --> 32:40.990
当前的这个hook

32:40.990 --> 32:44.590
是否是练表的第一个

32:45.790 --> 32:46.270
ok

32:46.270 --> 32:47.230
它这边怎么判断的

32:47.230 --> 32:48.430
它判断的是这边

32:48.430 --> 32:49.950
work in progress hook

32:50.590 --> 32:51.950
这个呢是否为空

32:52.830 --> 32:54.110
然后如果是空的话

32:54.110 --> 32:54.590
它就是什么呢

32:54.590 --> 32:55.550
它就是要投结点

32:56.510 --> 32:57.390
否则不为空

32:57.390 --> 32:57.950
不为空的话

32:57.950 --> 33:00.510
你就把它加到这个屁股后面就可以了

33:00.510 --> 33:01.230
最后就干完了

33:01.310 --> 33:03.470
最后就返回这个work in progress

33:04.910 --> 33:05.390
ok

33:05.390 --> 33:08.510
返回这个work in progress

33:08.510 --> 33:09.150
好

33:09.150 --> 33:09.870
然后接下来

33:09.870 --> 33:10.830
这边是不是就拿到

33:11.550 --> 33:11.870
对了

33:11.870 --> 33:12.670
拿到hook

33:12.670 --> 33:13.470
这边拿到hook了

33:13.470 --> 33:14.750
这个实际上是一个什么

33:14.750 --> 33:16.350
这个实际上是不是是一个练表

33:17.070 --> 33:18.350
这边的话应该是创

33:18.350 --> 33:20.670
就是拿到hook对象练表

33:22.590 --> 33:28.270
这边拿到hook对象练表

33:29.150 --> 33:29.630
对不对

33:29.630 --> 33:30.750
你这边再来看一下吧

33:30.750 --> 33:32.270
你这个是hook对象吗

33:32.990 --> 33:33.470
对不对

33:33.470 --> 33:34.270
这个是hook对象

33:34.270 --> 33:35.390
然后接下来它返回的是什么

33:35.390 --> 33:37.230
返回的是work in progress hook

33:38.750 --> 33:39.630
稍等我看一下啊

33:41.470 --> 33:42.350
对的对的

33:42.350 --> 33:43.870
这边是一个练表

33:43.870 --> 33:44.110
ok

33:44.990 --> 33:45.230
好

33:45.230 --> 33:45.870
那首先呢

33:45.870 --> 33:47.630
这边拿到这个练表

33:47.630 --> 33:48.350
拿到了之后

33:48.350 --> 33:49.150
然后接下来的话

33:49.150 --> 33:51.870
这边初始化hook的这个属性

33:51.870 --> 33:52.430
这边呢

33:52.430 --> 33:53.070
这个hook

33:53.630 --> 33:54.350
memo state

33:54.350 --> 33:54.830
等于什么呢

33:54.830 --> 33:56.510
等于hook best state

33:56.510 --> 33:57.390
然后接下来这边

33:57.390 --> 33:57.950
等于什么呢

33:57.950 --> 33:58.510
等于这个

33:59.470 --> 34:00.270
initial state

34:00.270 --> 34:00.990
initial state

34:00.990 --> 34:02.110
就是你这边传入的

34:02.750 --> 34:03.390
就你这边

34:03.390 --> 34:03.950
你这边的话

34:03.950 --> 34:04.910
掉这个use state

34:04.910 --> 34:06.830
你这边不是传一个初始值吗

34:06.830 --> 34:07.870
传一个初始值之后

34:07.870 --> 34:08.510
人家它这边

34:08.510 --> 34:09.950
复制到这个hook

34:09.950 --> 34:11.710
点这个memo state上面

34:12.430 --> 34:13.070
对不对

34:13.070 --> 34:13.390
ok

34:15.890 --> 34:16.610
好

34:16.610 --> 34:17.490
然后接下来的话

34:17.490 --> 34:18.050
这边的话

34:18.050 --> 34:19.490
设置这个q

34:20.210 --> 34:21.170
const一个q

34:21.170 --> 34:23.650
它对应的又是一个对象

34:23.650 --> 34:24.130
这个的话

34:24.130 --> 34:25.650
这个是和那个相关的

34:25.650 --> 34:28.050
就是副作用的处理相关的

34:28.050 --> 34:29.090
大家把这个q

34:29.090 --> 34:31.170
设置到hook点q上面

34:31.250 --> 34:32.450
好这个dispatch

34:32.450 --> 34:34.050
dispatch实际上就是这边

34:34.850 --> 34:36.770
就是你这边返回了这个

34:36.770 --> 34:37.250
我们这边呢

34:37.250 --> 34:39.650
比如说每次这个use state

34:39.650 --> 34:41.410
它是不是会返回一个初始值

34:41.410 --> 34:43.010
以及一个设置它的这个值

34:43.650 --> 34:43.970
对不对

34:43.970 --> 34:44.610
我们后期

34:44.610 --> 34:46.290
后期在修改这个state值的时候

34:46.290 --> 34:47.090
都是通过什么

34:47.090 --> 34:48.370
是不通过这个值

34:48.370 --> 34:49.730
就通过这个第二个

34:49.730 --> 34:51.570
返回了这个函数去修改的

34:51.570 --> 34:51.970
对不对

34:51.970 --> 34:54.050
那这边让它返回了这个dispatch

34:54.050 --> 34:55.650
就是实际上就是第二个参数

34:56.690 --> 34:58.050
就是第二个参数

34:58.050 --> 34:58.370
ok

35:01.650 --> 35:01.890
好

35:01.890 --> 35:02.930
这是关于这个

35:04.450 --> 35:05.970
关于这个mount state

35:07.090 --> 35:07.810
好来我们这边

35:07.810 --> 35:08.690
让我们来看个例子

35:09.570 --> 35:09.970
假设

35:13.170 --> 35:14.050
假设

35:14.050 --> 35:17.970
现在我们有如下的一个组件

35:19.010 --> 35:20.930
如下的一个组件

35:21.650 --> 35:22.530
这个组件里面呢

35:22.530 --> 35:24.370
它不止一个hook

35:24.370 --> 35:25.570
它用到了好几个hook

35:26.130 --> 35:27.090
好我们这边来看一下

35:29.090 --> 35:29.410
这边

35:30.050 --> 35:31.010
你看这边它用到了

35:31.010 --> 35:32.610
这边是第一个hook

35:32.610 --> 35:34.370
它用的是use state

35:34.850 --> 35:37.730
好第二个hook也是use state

35:37.730 --> 35:39.730
好第三个第三个是use ref

35:40.290 --> 35:40.690
对吧

35:40.690 --> 35:41.490
use ref

35:41.490 --> 35:42.850
好那第四个第四个呢

35:42.850 --> 35:44.370
是use effect

35:44.930 --> 35:45.890
那么这边

35:45.890 --> 35:48.770
当你这个组件进行初始化之后

35:48.770 --> 35:51.330
它就会形成一个hook的这个练表

35:52.290 --> 35:54.850
当上面

35:56.210 --> 35:58.930
上面的函数组件

35:58.930 --> 36:01.730
第一次进行初始化后

36:03.090 --> 36:03.970
初始化后

36:04.530 --> 36:08.370
就会形成一个什么呢

36:08.370 --> 36:11.810
一个hook的练表

36:12.930 --> 36:14.690
它会形成一个这个练表

36:14.690 --> 36:15.970
好这边有个图

36:16.610 --> 36:19.170
把这个图拿过来

36:20.130 --> 36:21.250
这边大家看到这个图

36:21.250 --> 36:22.130
其实就知道了

36:23.250 --> 36:24.050
它又卡住了

36:24.610 --> 36:25.010
马上

36:26.610 --> 36:28.610
把这个图拿过来

36:30.370 --> 36:32.050
OK你看

36:32.050 --> 36:32.690
大字的话

36:32.690 --> 36:33.970
这边实际上就是这个样子的

36:34.450 --> 36:36.610
首先这边会有一个fiber load

36:36.610 --> 36:38.610
这个是你fiber对应的对象

36:38.610 --> 36:40.930
好然后再这边它有一个memo state

36:41.650 --> 36:42.930
这个我们刚才说过

36:42.930 --> 36:44.930
fiber的memo state指向什么

36:44.930 --> 36:47.890
是不是指向你这个hook练表的这个

36:47.890 --> 36:48.610
第一个hook

36:49.730 --> 36:50.290
对不对

36:50.290 --> 36:51.570
指向第一个hook

36:51.570 --> 36:53.490
好再加每一个hook对象

36:54.530 --> 36:55.410
每一个hook对象

36:55.410 --> 36:56.450
它这边这个next

36:56.450 --> 36:57.970
通过这个next的属性

36:57.970 --> 36:58.770
指向什么呢

36:58.770 --> 37:00.930
指向下一个hook对象

37:01.970 --> 37:02.850
看到没有

37:02.850 --> 37:03.810
好再加你这边的话

37:03.810 --> 37:05.490
这个不同的这个hook

37:07.170 --> 37:08.610
不同的这个hook

37:08.610 --> 37:09.890
它的这个memo state

37:09.890 --> 37:12.130
它存储的内容是不是不一样的

37:12.130 --> 37:13.490
这是不是刚才也说过

37:13.490 --> 37:13.970
对了

37:13.970 --> 37:15.410
这边memo state

37:15.410 --> 37:17.730
这边memo state对应的是这个对象

37:18.450 --> 37:19.810
这边memo state对应的是

37:19.810 --> 37:22.530
这边有一个回调函数

37:22.530 --> 37:23.490
以及你的这个依赖

37:24.130 --> 37:26.690
好再加这边这个walking progress

37:26.690 --> 37:28.290
这边memo state

37:28.290 --> 37:29.090
它指向什么呢

37:29.090 --> 37:30.050
指向这个最新

37:30.690 --> 37:31.570
最新的这个hook

37:32.530 --> 37:34.050
好那我们这边

37:34.050 --> 37:34.450
这边的话

37:34.450 --> 37:35.410
它不是练表

37:35.410 --> 37:36.850
我们把这改一下

37:36.850 --> 37:38.130
这边就是拿到什么

37:38.130 --> 37:39.170
拿到这个hook对象

37:40.050 --> 37:40.610
对不对

37:40.610 --> 37:41.810
拿到这个hook对象

37:41.810 --> 37:42.850
你这边对应了什么呢

37:42.850 --> 37:44.450
对应的是始终是最新的

37:45.090 --> 37:46.450
最新的这个hook对象

37:46.450 --> 37:47.810
你执行一个hook

37:47.810 --> 37:50.290
比如我这边先代码执行到

37:50.290 --> 37:51.570
这一句的时候

37:51.570 --> 37:53.330
你这边的这个walking progress

37:53.890 --> 37:54.770
指向它

37:54.770 --> 37:56.130
好然后代码执行到

37:56.130 --> 37:57.490
这个这一句的时候

37:57.490 --> 37:59.490
然后接下来它的话就指向它

38:00.050 --> 38:00.610
对不对

38:00.770 --> 38:02.610
好然后接下来在上面这四个

38:03.250 --> 38:04.690
执行到最后一个hook的时候

38:04.690 --> 38:05.890
那最终的话这边

38:05.890 --> 38:06.530
指向它

38:07.170 --> 38:08.290
是这样子的

38:08.290 --> 38:09.090
ok

38:09.090 --> 38:10.530
好整个内部的流程

38:10.530 --> 38:11.250
是这样子的

38:11.250 --> 38:11.810
啊就是在

38:12.690 --> 38:13.410
初画的时候

38:13.970 --> 38:14.930
好然后接下来的话

38:14.930 --> 38:15.890
我们来看一下更新

38:17.570 --> 38:18.370
接下来

38:18.370 --> 38:18.930
我们来

38:19.490 --> 38:21.010
看一下更新

38:21.650 --> 38:22.370
啊

38:22.370 --> 38:23.330
然后更新的时候

38:23.970 --> 38:25.090
更新的时候

38:25.650 --> 38:25.890
会

38:27.650 --> 38:28.690
执行什么是吧

38:28.690 --> 38:29.090
update

38:29.970 --> 38:30.450
插插插

38:31.170 --> 38:31.970
对应的方法

38:33.730 --> 38:34.450
对不对

38:34.450 --> 38:34.930
啊

38:34.930 --> 38:36.930
那接下来这个相关的代码如下

38:39.520 --> 38:40.000
如下

38:41.840 --> 38:43.040
好这个update的话呢

38:43.040 --> 38:45.520
这个代码就稍微有点多

38:45.520 --> 38:45.920
啊

38:45.920 --> 38:46.880
我把它拿过来

38:47.760 --> 38:49.040
稍微有那么一点点多

38:53.630 --> 38:53.870
ok

38:54.510 --> 38:55.390
好这边的话

38:55.390 --> 38:56.270
我们来看一下

38:56.270 --> 38:57.390
啊你一块一块来看

38:58.350 --> 38:59.550
一块一块来看

38:59.550 --> 39:00.350
然后首先的话呢

39:00.350 --> 39:01.070
那这边这边呢

39:01.070 --> 39:02.190
e4 else啊

39:02.190 --> 39:03.630
判断你这个current hook

39:04.030 --> 39:05.310
啊是否为这个

39:05.870 --> 39:06.110
null

39:06.830 --> 39:08.110
啊如果是null的话说明是吧

39:08.110 --> 39:08.670
说明它是

39:09.390 --> 39:09.790
第一个

39:10.910 --> 39:11.790
对不对啊

39:11.790 --> 39:12.270
第一个

39:12.270 --> 39:13.710
它这边就拿这个第一个

39:14.190 --> 39:15.470
好否则的话就拿什么呢

39:15.470 --> 39:16.430
否则就拿下一个

39:17.070 --> 39:17.870
拿完了之后

39:17.870 --> 39:19.310
然后接下来这一块代码

39:20.190 --> 39:20.990
这块代码的话

39:20.990 --> 39:21.970
就是在更新你

39:21.970 --> 39:24.350
walking progress hook的这个指向

39:24.910 --> 39:25.790
啊这个因为我们说了

39:25.790 --> 39:26.830
这边让你每次

39:26.830 --> 39:27.710
他要指向什么

39:27.710 --> 39:28.750
是不是要指向最新的

39:29.390 --> 39:29.950
对不对

39:29.950 --> 39:31.310
每次要指向最新的

39:31.310 --> 39:32.590
说这块代码啊

39:32.590 --> 39:33.230
这块代码呢

39:33.550 --> 39:35.230
它就是在更新这个

39:35.230 --> 39:38.030
walking progress hook的这个指向

39:38.030 --> 39:39.390
啊这种的话你不用去细看

39:40.110 --> 39:40.510
知道吧

39:40.510 --> 39:42.270
注意你看原码的时候千万

39:42.270 --> 39:43.150
就第一次啊

39:43.150 --> 39:44.190
第一次看的时候

39:44.190 --> 39:46.110
千万不要陷入某一个细节

39:47.150 --> 39:48.430
不要陷入某一个细节

39:48.430 --> 39:49.790
因为它比如说某一个这个

39:50.830 --> 39:52.910
比如某一个比如这个变量啊什么的

39:52.910 --> 39:54.190
啊它可能是来自就是

39:54.190 --> 39:54.910
其他地方

39:54.910 --> 39:56.510
让你一步一步去追

39:56.510 --> 39:58.270
啊你会追得非常非常累

39:58.270 --> 39:59.550
啊到最后你就放弃了

40:00.430 --> 40:01.150
知道吧

40:01.150 --> 40:01.790
说这边呢

40:01.790 --> 40:03.070
这个看原码的时候

40:03.070 --> 40:04.430
一定就是要站在一个什么呢

40:04.430 --> 40:06.270
站在一个就是宏观的这个角度

40:06.270 --> 40:08.990
就看一下他整个这一块代码是在做什么

40:08.990 --> 40:11.070
然后理清楚他大致的这个步骤

40:11.950 --> 40:13.790
啊你清楚他大致的步骤

40:13.790 --> 40:14.110
ok

40:14.670 --> 40:15.470
好你看这一块

40:16.030 --> 40:17.470
这一块呢他就是在干嘛呢

40:17.470 --> 40:20.830
他就在更新这个walking progress hook的这个指向

40:21.390 --> 40:22.270
啊更新完了之后

40:22.270 --> 40:23.310
然后接下来这边

40:23.870 --> 40:25.790
next walk in progress hook

40:26.190 --> 40:28.910
指向的是当前要工作的这个 hook

40:28.910 --> 40:31.230
好你注意这边有一句非常关键的

40:31.790 --> 40:32.750
他会进行什么呢

40:33.070 --> 40:35.070
他会进行一个复用

40:36.510 --> 40:37.230
可不可以啊

40:37.230 --> 40:38.830
他会进行一个复用啊

40:38.830 --> 40:40.350
这边的话进行一个克龙

40:41.390 --> 40:42.350
啊完事之后呢

40:42.350 --> 40:45.390
后面后面的操作就和这个mount差不多了

40:46.110 --> 40:47.390
啊就和mount差不多了

40:47.390 --> 40:49.390
注意上面有一个非常关键的信息

40:51.950 --> 40:54.350
在上面的原码中

40:55.150 --> 40:59.390
有一个非常关键的信息

41:01.940 --> 41:04.020
什么信息呢啊就是这一句

41:08.980 --> 41:10.740
就这一句对了

41:10.740 --> 41:11.700
他会对什么

41:11.700 --> 41:14.340
他是不是会对你的这个之前的这个 hook

41:14.340 --> 41:15.780
进行一个复用

41:16.900 --> 41:17.540
对不对

41:17.540 --> 41:18.260
进行个复用

41:19.140 --> 41:19.460
啊

41:20.500 --> 41:20.900
这里

41:23.140 --> 41:24.820
这里如果这个next

41:26.980 --> 41:30.180
如果这个next walk in progress hook

41:30.740 --> 41:32.340
不为no

41:33.060 --> 41:36.420
那么就会附用什么呢

41:36.420 --> 41:38.580
附用之前的 hook

41:39.380 --> 41:40.580
ok

41:40.580 --> 41:42.740
这其实也就解释了什么

41:42.740 --> 41:44.900
解释了为什么 hook不能放在

41:44.900 --> 41:45.780
efo条件里

41:47.220 --> 41:50.820
这里其实也就解释了

41:50.820 --> 41:51.620
为什么

41:52.340 --> 41:56.980
hook不能放在这个条件

41:58.260 --> 42:00.100
或者循环

42:00.980 --> 42:01.380
语句

42:02.260 --> 42:02.580
里面

42:03.620 --> 42:04.420
为什么呢

42:04.420 --> 42:05.860
这个其实也是到面识题啊

42:06.500 --> 42:08.020
实际上也是到面识题

42:08.100 --> 42:09.460
他面识题他就会问你

42:09.460 --> 42:10.660
hook

42:10.660 --> 42:11.220
为什么

42:12.260 --> 42:16.980
为什么通常放在顶部啊

42:16.980 --> 42:17.380
而且

42:19.140 --> 42:22.180
而且不能写在什么呢

42:22.180 --> 42:27.060
不能写在条件或者循环语句里面

42:28.500 --> 42:28.900
对不对

42:28.900 --> 42:29.780
也是到面识题

42:29.780 --> 42:30.420
为什么

42:30.420 --> 42:32.740
因为你更新的过程中啊

42:32.740 --> 42:36.340
因为更新的过程中

42:36.900 --> 42:40.900
如果通过这个efo条件

42:41.700 --> 42:42.020
啊

42:42.020 --> 42:46.500
然后这个增加或者删除了这个hook

42:48.100 --> 42:50.020
那么在这个附用的时候

42:50.660 --> 42:52.980
附用的时候就会产生什么呢

42:52.980 --> 42:54.500
就会产生

42:55.060 --> 42:55.780
当前

42:56.580 --> 42:58.500
hook的这个顺序

42:59.140 --> 43:00.100
和之前

43:01.220 --> 43:03.940
hook的这个顺序不一致的问题

43:06.660 --> 43:07.380
对不对

43:07.540 --> 43:08.980
它就会产生这个问题

43:08.980 --> 43:09.460
啊

43:09.460 --> 43:11.380
那比如说我们这边举个例子啊

43:11.380 --> 43:11.780
例如

43:14.260 --> 43:15.140
例如啊

43:15.140 --> 43:19.220
我们将上面的这个代码进行修改

43:20.740 --> 43:21.780
我们改成什么样子呢

43:21.780 --> 43:22.500
改成这个样子

43:23.140 --> 43:24.020
我把这拿过来

43:27.570 --> 43:28.290
改成这个样子

43:29.170 --> 43:29.410
好

43:29.410 --> 43:30.050
改成这个样子

43:30.050 --> 43:31.170
你可以看一下啊

43:31.170 --> 43:31.650
这边的话

43:31.650 --> 43:32.610
你看第一个hook

43:33.330 --> 43:34.370
第一个hook的话

43:34.370 --> 43:36.130
你看我这边加了一个什么

43:36.130 --> 43:38.050
加了一个类似于这种判断

43:38.690 --> 43:39.090
对不对

43:39.090 --> 43:40.210
如果这个是q

43:40.210 --> 43:40.850
那我这边呢

43:40.850 --> 43:42.370
那就是这边第一个hook

43:42.370 --> 43:43.570
如果这个是false

43:43.570 --> 43:45.730
那这边这边这个hook就没有

43:45.730 --> 43:46.370
对不对

43:46.370 --> 43:47.170
那你这样子呢

43:47.170 --> 43:48.690
它实际上它就是会爆错的

43:49.570 --> 43:49.650
啊

43:49.650 --> 43:52.450
你第一次渲染的是你shulumber为q

43:53.330 --> 43:53.730
对不对

43:54.370 --> 43:54.930
第一次

43:58.190 --> 44:00.910
第一次渲染的时候

44:00.910 --> 44:01.950
你的这个shulumber

44:04.110 --> 44:05.390
shulumber啊

44:05.390 --> 44:06.670
然后为这个q

44:09.060 --> 44:09.860
为q

44:09.860 --> 44:10.900
那它就会干嘛

44:10.900 --> 44:12.900
它是不是就会渲染第一个hook

44:12.900 --> 44:13.860
对不对啊

44:13.860 --> 44:14.340
此时

44:15.300 --> 44:20.260
此时就会渲染第一个hook

44:21.540 --> 44:24.020
但有人说你这个shulumber哪来的

44:24.020 --> 44:25.620
这个是从复原数传过来的

44:26.260 --> 44:27.700
也就是我们这个组件的话

44:27.700 --> 44:28.660
接受一个这个

44:28.660 --> 44:31.060
从复原数传遞过来的这个布尔值

44:31.060 --> 44:32.260
那假设这边

44:32.260 --> 44:32.980
假设

44:34.420 --> 44:35.300
假设第一次

44:35.780 --> 44:37.140
第一次这个复

44:38.340 --> 44:38.900
复原数

44:42.030 --> 44:42.910
复原数

44:44.030 --> 44:45.390
应该叫做复组件是吧

44:46.190 --> 44:47.870
假设第一次复组件

44:47.870 --> 44:49.550
然后传递过来

44:51.980 --> 44:52.780
传递

44:53.820 --> 44:55.980
过来的这个shulumber为q

44:55.980 --> 44:57.340
那么此时就会干嘛

44:57.340 --> 44:59.820
是不是就会渲染第一个这个hook

44:59.820 --> 45:00.380
对不对

45:00.380 --> 45:01.260
那第二次

45:02.380 --> 45:04.700
第二次渲染的时候

45:05.420 --> 45:07.500
假设这个复组件

45:09.660 --> 45:10.300
传递

45:11.020 --> 45:12.620
过来的是什么呢

45:12.620 --> 45:13.420
是force

45:14.060 --> 45:17.100
那么第一个hook

45:17.180 --> 45:18.060
是不是就不会执行

45:18.940 --> 45:20.620
就不会执行

45:21.420 --> 45:23.100
那么这个逻辑的话

45:23.100 --> 45:27.980
那么逻辑就会变得如下表

45:29.020 --> 45:30.620
下表所示

45:31.260 --> 45:32.460
这边大家看一下这个表

45:33.340 --> 45:34.940
把这个表拿过来

45:38.880 --> 45:39.360
你看一下

45:40.080 --> 45:40.720
你第一次

45:41.680 --> 45:42.480
第一次的时候

45:42.480 --> 45:44.320
这边是不是就是这个useState

45:44.880 --> 45:45.520
useState

45:46.080 --> 45:47.600
因为你第三个是useRef

45:47.600 --> 45:48.400
这个不管了

45:48.480 --> 45:49.440
第一个useState

45:49.440 --> 45:50.320
useState

45:50.320 --> 45:51.200
第二次的时候

45:51.200 --> 45:52.000
这边是不是

45:52.000 --> 45:52.720
它没有啊

45:54.160 --> 45:55.040
因为它是force

45:55.040 --> 45:56.400
force它是不是不会执行

45:57.280 --> 45:58.080
不会执行的话

45:58.080 --> 45:59.600
那接下来它是不是就变成第一个

46:00.320 --> 46:00.800
对不对

46:00.800 --> 46:02.240
它变成第二个

46:02.800 --> 46:03.840
那你这边的话

46:03.840 --> 46:05.920
在复用的时候就会出问题

46:06.720 --> 46:09.520
那么此时再进行

46:10.160 --> 46:11.920
复用的时候

46:12.560 --> 46:13.920
就会跑错

46:15.120 --> 46:15.680
OK

46:15.680 --> 46:16.720
好这边画了张图

46:16.720 --> 46:17.280
大家看一下

46:21.420 --> 46:21.900
这里

46:22.780 --> 46:23.500
你看这边

46:23.500 --> 46:23.900
第二次

46:23.900 --> 46:24.460
第二次的话

46:24.460 --> 46:25.660
它是不是没有执行

46:25.660 --> 46:26.380
没有执行的话

46:26.380 --> 46:27.420
然后下你复用的话

46:27.420 --> 46:28.540
它是不是就会复用到它

46:29.420 --> 46:29.980
对不对

46:29.980 --> 46:30.780
它就会复用到它

46:30.780 --> 46:31.580
然后下它

46:31.580 --> 46:32.620
它的话就会干嘛

46:32.620 --> 46:33.820
是不是就会直接复用到它

46:34.620 --> 46:34.940
对不对

46:34.940 --> 46:35.980
它的话找到它

46:35.980 --> 46:37.180
它是不是就直接就爆错了

46:38.220 --> 46:38.700
对不对

46:38.700 --> 46:39.660
你这边你第二次

46:39.660 --> 46:41.020
第二次了就已经是什么

46:41.020 --> 46:42.460
这已经是useRef了

46:43.260 --> 46:44.380
这已经是useRef了

46:45.020 --> 46:45.500
对不对

46:45.500 --> 46:47.100
所以它这边它就会爆错了

46:48.220 --> 46:49.420
第二次复用的时候

46:51.180 --> 46:53.820
第二次复用的时候

46:54.460 --> 46:55.340
发现什么呢

46:55.340 --> 47:00.060
发现互合的类型不同

47:00.060 --> 47:02.060
你的这个useState

47:02.780 --> 47:03.340
不等于

47:05.780 --> 47:06.500
不等于什么

47:09.150 --> 47:09.950
不等于这个

47:12.270 --> 47:12.910
useRef

47:15.140 --> 47:15.780
对不对

47:15.780 --> 47:16.980
那么就会直接爆错

47:18.100 --> 47:19.460
就会直接

47:21.380 --> 47:21.780
爆错

47:22.420 --> 47:22.900
OK

47:22.900 --> 47:23.780
所以开发的时候

47:23.780 --> 47:24.740
一定要注意这个

47:24.820 --> 47:26.260
互可顺序的遗址性

47:27.540 --> 47:30.100
因此开发的时候

47:30.820 --> 47:33.220
一定要注意

47:34.020 --> 47:37.540
这个互可顺序的遗址性

47:38.580 --> 47:39.860
你也不要在这个

47:39.860 --> 47:41.380
什么这个条件啊

47:41.380 --> 47:42.100
循环啊

47:42.100 --> 47:42.900
里面去使用

47:43.380 --> 47:44.420
反正就是根据那个

47:44.420 --> 47:45.220
官方的要求

47:45.620 --> 47:46.260
走就可以了

47:46.900 --> 47:48.500
根据官方的要求走就行了

47:48.900 --> 47:49.540
原来爆错

47:49.540 --> 47:50.340
它爆的错时间

47:50.340 --> 47:51.220
就是爆的是这个

47:53.490 --> 47:54.690
这边我把这个错误

47:55.410 --> 47:55.970
结了个图

47:56.930 --> 47:57.410
你看一下

47:59.170 --> 47:59.810
warring

47:59.810 --> 48:01.810
react has detected

48:01.810 --> 48:03.330
就react 侦测到什么呢

48:03.970 --> 48:06.370
change in the order of hooks

48:06.930 --> 48:08.210
called by index

48:08.210 --> 48:09.170
就它这边呢就是

48:09.570 --> 48:10.130
检查到什么

48:10.130 --> 48:10.370
是不是

48:10.370 --> 48:11.410
in this order

48:11.410 --> 48:11.970
是不是就是你

48:11.970 --> 48:13.010
互可的这个顺序

48:13.010 --> 48:13.650
看到没有

48:13.650 --> 48:14.610
order of hooks

48:15.170 --> 48:16.370
互可的这个顺序

48:16.370 --> 48:17.250
是发生了改变

48:17.890 --> 48:18.610
对不对

48:18.610 --> 48:21.170
this will lead to bugs and errors

48:21.170 --> 48:22.370
if not fixed

48:22.370 --> 48:24.530
你如果不去这个修复的话

48:24.530 --> 48:26.450
它会导致这个bug或者这个错误

48:26.930 --> 48:27.410
看到没有

48:27.410 --> 48:28.530
它会爆这个错误

48:28.530 --> 48:29.970
而且这边这边就不一致了

48:30.450 --> 48:31.010
看到没有

48:31.010 --> 48:31.650
这边

48:31.650 --> 48:32.450
pride

48:32.450 --> 48:33.890
这个之前的这个 render

48:33.890 --> 48:34.930
它这边是 useState

48:34.930 --> 48:35.970
useState

48:35.970 --> 48:36.770
next render

48:36.770 --> 48:37.650
它这边是什么呢

48:37.650 --> 48:38.690
这边是 useState

48:38.690 --> 48:39.410
useRef

48:40.050 --> 48:40.690
看到没有

48:40.690 --> 48:41.490
它爆这个错

48:42.930 --> 48:43.170
ok

48:43.810 --> 48:43.970
好

48:43.970 --> 48:45.650
这就是关于这个互可

48:46.210 --> 48:47.810
它内部的一个介绍

48:47.810 --> 48:49.410
以及它的一个执行流程

48:49.890 --> 48:50.210
好

48:50.210 --> 48:50.610
来

48:50.610 --> 48:52.610
回头我们这边让我们把这个面识提

48:52.610 --> 48:53.730
我们这边来看一下

48:55.010 --> 48:55.490
这边

48:55.490 --> 48:57.490
互可的话是如何保存

48:58.050 --> 48:59.490
函数组件状态

48:59.490 --> 49:02.530
以及为什么不能再循环条件

49:02.530 --> 49:05.330
或者这个嵌桃函数中调用这个互可

49:05.890 --> 49:06.050
好

49:06.050 --> 49:07.650
我这边就直接把这个答案

49:07.650 --> 49:08.530
我把它过来

49:08.530 --> 49:08.770
啊

49:14.190 --> 49:14.510
ok

49:15.150 --> 49:15.630
首先的话

49:15.630 --> 49:17.390
互可它是一个对象

49:17.390 --> 49:19.710
大致的结构的话是这个样子的

49:19.710 --> 49:19.870
啊

49:19.870 --> 49:21.230
你不同的这个互可的话

49:21.230 --> 49:22.590
互可的这个memod

49:22.990 --> 49:24.510
这个memod state

49:24.510 --> 49:25.870
它保存的这个值

49:25.870 --> 49:27.230
是不一样的

49:27.230 --> 49:27.950
对不对

49:27.950 --> 49:28.190
好

49:28.270 --> 49:29.070
然后接下来的话

49:29.070 --> 49:30.430
一个这个组件

49:30.430 --> 49:31.470
一个组件的互可

49:31.470 --> 49:33.470
它会以这个练表的形式

49:33.470 --> 49:34.510
串联起来

49:34.510 --> 49:34.670
啊

49:34.670 --> 49:37.230
而这个fiber load这个memod state

49:37.230 --> 49:38.910
它保存了这个互可练表的

49:38.910 --> 49:40.110
第一个这个互可

49:41.070 --> 49:41.790
对不对

49:41.790 --> 49:42.030
好

49:42.030 --> 49:42.510
还有就是什么呢

49:42.510 --> 49:43.550
还有就是你函数组件

49:43.550 --> 49:44.350
在执行的时候

49:44.350 --> 49:45.630
首先会执行什么

49:45.630 --> 49:47.150
是不是首先会执行那个

49:47.150 --> 49:48.190
RenderWasteHook

49:48.990 --> 49:49.230
对不对

49:49.230 --> 49:50.430
RenderWasteHook

49:50.430 --> 49:51.790
它最大的作用就是什么

49:51.790 --> 49:53.790
是判断了你的这个上下文对象

49:54.830 --> 49:55.470
对不对

49:55.470 --> 49:55.630
好

49:55.630 --> 49:56.350
然后之后的话

49:56.350 --> 49:57.470
根据你是Mount

49:57.470 --> 49:58.750
还是这个Update

49:58.750 --> 50:00.670
执行这个不同的这个

50:00.670 --> 50:02.350
对应的这个方法

50:02.350 --> 50:03.550
好

50:03.550 --> 50:04.990
还有就是更新的时候

50:04.990 --> 50:07.230
它会附用之前的这个互可

50:07.230 --> 50:09.230
如果你在意负条件语系里面

50:09.230 --> 50:10.510
增加或者删除了

50:10.510 --> 50:11.550
它会导致什么

50:11.550 --> 50:13.150
会导致这个互可

50:13.150 --> 50:15.150
顺序这个不一致的问题

50:16.110 --> 50:16.910
对不对

50:16.910 --> 50:17.550
OK

50:17.550 --> 50:20.030
这就是关于整个这个

50:20.030 --> 50:20.750
互可

50:20.750 --> 50:23.070
纳指的一个原理的这个介绍

50:23.070 --> 50:24.350
好吧

50:24.350 --> 50:24.990
OK

50:24.990 --> 50:25.550
好

50:25.550 --> 50:26.910
这一块的话就到这里

50:27.070 --> 50:27.870
大家下去的话

50:27.870 --> 50:28.910
把这一小节内容

50:28.910 --> 50:30.350
可以自己再看一下

50:30.350 --> 50:30.750
好

50:30.750 --> 50:31.950
再见

