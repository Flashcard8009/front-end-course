WEBVTT

00:00.000 --> 00:06.400
这节课的话我们来看一下整个react 它的一个整体的架构

00:06.400 --> 00:09.480
我们这边的话还是从这个题目入手

00:09.480 --> 00:11.520
这边的话有道面是提

00:11.520 --> 00:14.840
你是不是有了解过这个react 架构

00:14.840 --> 00:20.220
那么新的这个fiber 架构相较于之前的这个stack 架构

00:20.220 --> 00:22.280
有什么样的这个优势

00:22.280 --> 00:24.840
我们这边来看一个标准的回答

00:24.840 --> 00:28.920
stack 架构在进行这个虚拟动物数比较的时候

00:29.120 --> 00:32.240
采用的是地规 计算的时候呢

00:32.240 --> 00:35.040
它会消耗大量的这个时间

00:35.040 --> 00:37.320
新的这个fiber 架构

00:37.320 --> 00:39.120
它采用的是链表

00:39.120 --> 00:43.320
可以实现这个时间的这个切片

00:43.320 --> 00:45.120
就是那种暂停

00:45.120 --> 00:48.800
防止这个JS 计算 占用这个过多的时间

00:48.800 --> 00:52.480
从而导致这个浏览器出现丢争的这个现象

00:52.480 --> 00:55.480
这个的话是一个标准的答案

00:55.480 --> 00:58.280
当然同样这个这个答案虽然标准

00:58.320 --> 01:00.000
但是呢 并不出彩

01:00.000 --> 01:02.720
你这边的话就是相当于一句话就答完了

01:02.720 --> 01:03.440
对不对

01:03.440 --> 01:06.560
面试的时候是尽可能的多说一些

01:06.560 --> 01:08.960
把你知道这个知道的内容

01:08.960 --> 01:11.800
能就是能够说出来的尽量多说一些

01:11.800 --> 01:12.760
OK

01:12.760 --> 01:14.040
所以我们这几颗的话

01:14.040 --> 01:16.080
然后线老师给大家讲一下

01:16.080 --> 01:19.120
就是整个react 它的一个整体架构

01:19.120 --> 01:19.600
回头的话

01:19.600 --> 01:22.360
我这边让我再来给一个这个参考答案

01:22.360 --> 01:23.920
好不好

01:23.920 --> 01:25.760
好 首先这个react

01:25.760 --> 01:27.320
react 这个架构的话

01:27.360 --> 01:28.840
它实际上可以分成什么呢

01:28.840 --> 01:33.760
可以分成这个16版本之前和16版本之后

01:33.760 --> 01:34.880
为什么这么说呢

01:34.880 --> 01:37.960
因为它是从这个15到16之后

01:37.960 --> 01:41.560
它是重构了整个架构的

01:41.560 --> 01:47.920
react v15 以及之前的这个架构

01:47.920 --> 01:49.360
称之为什么呢

01:49.360 --> 01:54.460
称之为这个stack 架构

01:54.460 --> 01:56.500
而这个从16开始

01:56.500 --> 02:00.540
从v16开始react

02:00.540 --> 02:06.910
重构了 重构了整体的这个架构

02:06.910 --> 02:10.710
新的这个架构被称之为什么呢

02:10.710 --> 02:15.600
被称之为fiber架构

02:15.600 --> 02:17.040
被称之为fiber架构

02:17.040 --> 02:22.000
那新的这个架构相比原来的架构

02:22.000 --> 02:24.240
它有一个最大的特点

02:24.240 --> 02:25.160
就是什么呢

02:25.160 --> 02:26.400
就是这里所说的

02:26.440 --> 02:28.840
可以实现这个时间切片

02:28.840 --> 02:34.480
新的架构相比旧的架构

02:34.480 --> 02:38.440
有一个最大的特点

02:38.440 --> 02:44.720
就是能够实现时间切片

02:44.720 --> 02:48.360
那这个时间切片究竟是什么

02:48.360 --> 02:49.320
对吧

02:49.320 --> 02:50.360
那以前的话

02:50.360 --> 02:52.160
你没有实现这个时间切片

02:52.160 --> 02:54.760
你这个v15之前的这个架构

02:54.760 --> 02:55.840
它有什么样的问题

02:56.320 --> 02:57.720
那新的这个架构

02:57.720 --> 03:00.000
你实现了这个时间切片之后

03:00.000 --> 03:01.560
它就解决了这个问题

03:01.560 --> 03:03.440
那它是如何解决的

03:03.440 --> 03:04.160
对不对

03:04.160 --> 03:05.080
所以我们接下来

03:05.080 --> 03:07.320
我们从这么几个点来看

03:07.320 --> 03:08.280
哪里几个点呢

03:08.280 --> 03:12.640
首先第一个就是旧架构的这个问题

03:12.640 --> 03:13.760
是什么

03:13.760 --> 03:14.080
好

03:14.080 --> 03:16.080
然后新架构

03:16.080 --> 03:20.790
新架构的这个解决思路

03:20.790 --> 03:21.590
OK

03:21.590 --> 03:21.750
好

03:21.750 --> 03:22.310
来我们这边

03:22.310 --> 03:23.390
我们一个一个来看

03:23.390 --> 03:26.710
首先第一个是关于这个旧架构

03:26.710 --> 03:28.910
旧架构

03:28.910 --> 03:31.750
旧架构的问题

03:31.750 --> 03:33.590
那这边是新架构

03:33.590 --> 03:36.910
新架构的解决思路

03:36.910 --> 03:37.870
OK

03:37.870 --> 03:40.350
我们首先来看这个旧架构

03:40.350 --> 03:41.110
我们这边的话

03:41.110 --> 03:43.470
如果打开这个react官网

03:43.470 --> 03:45.830
你会发现这个react官网里面

03:45.830 --> 03:47.910
它在这个react哲学里面

03:47.910 --> 03:50.830
里面有提到react理念是什么呢

03:50.830 --> 03:52.390
react理念是

03:52.390 --> 03:55.350
它是一个就是使用javascript

03:55.390 --> 03:58.310
构建快速响应的这个大型

03:58.310 --> 04:01.790
vibre应用程序的首选方式

04:01.790 --> 04:02.390
这句话的话

04:02.390 --> 04:03.550
你去它官网找

04:03.550 --> 04:04.510
一定有的

04:04.510 --> 04:05.430
OK

04:05.430 --> 04:06.590
react

04:06.590 --> 04:07.590
试用什么呢

04:07.590 --> 04:10.710
试用javascript

04:10.710 --> 04:11.990
javascript

04:11.990 --> 04:17.710
构建快速响应的这个大型

04:17.710 --> 04:20.510
这个vibre应用

04:20.510 --> 04:24.070
vibre应用程序的首选方式

04:25.390 --> 04:26.310
OK

04:26.310 --> 04:28.270
那么这里就有一个问题

04:28.270 --> 04:30.230
你看这边有个关键词叫做什么呢

04:30.230 --> 04:32.630
叫做快速响应

04:32.630 --> 04:33.270
对吧

04:33.270 --> 04:34.310
我们这边的话

04:34.310 --> 04:36.230
经常我们在做这种vibre应用的时候

04:36.230 --> 04:39.190
我们追求的一个终极目标是什么呢

04:39.190 --> 04:43.230
那就是能够尽可能快速的响应用户的需求

04:43.230 --> 04:45.430
页面能够快速的渲染出来

04:45.430 --> 04:47.750
用户在你的页面上面

04:47.750 --> 04:49.990
做一些交互的时候

04:49.990 --> 04:53.310
你能够快速的进行响应

04:53.310 --> 04:55.310
那么这里就有个问题

04:55.310 --> 04:56.430
就是你这边的话

04:56.430 --> 05:01.470
什么样的情况会导致你无法进行快速响应呢

05:01.470 --> 05:03.870
大家可以思考一下这个问题

05:03.870 --> 05:12.270
有哪些情况会导致我们的vibre应用

05:12.270 --> 05:15.750
无法快速响应

05:15.750 --> 05:17.510
大家思考一下

05:17.510 --> 05:18.390
那这个的话

05:18.390 --> 05:20.030
大家就是发散自己的思维

05:20.030 --> 05:22.550
大家可能就会给出很多不一样的答案

05:22.590 --> 05:23.230
有同学说

05:23.230 --> 05:26.910
比如说这个王比较卡的时候

05:26.910 --> 05:27.470
对不对

05:27.470 --> 05:29.670
网络这个速度比较慢的时候

05:29.670 --> 05:31.310
没办法快速响应

05:31.310 --> 05:34.950
家宅的这个东西比较多的时候

05:34.950 --> 05:36.670
它没办法快速响应

05:36.670 --> 05:37.270
对不对

05:37.270 --> 05:39.830
会有各种各样的这种就是场景

05:39.830 --> 05:41.550
那么总结起来

05:41.550 --> 05:44.550
实际上就是两类

05:44.550 --> 05:45.990
总结起来

05:45.990 --> 05:48.550
实际上有什么呢

05:48.670 --> 05:50.990
实际上有两大类场景

05:52.710 --> 05:53.630
会什么呢

05:53.630 --> 05:55.790
会限制快速响应

05:56.950 --> 05:59.590
或者说影响我们的快速响应

05:59.590 --> 06:00.590
第一个是什么呢

06:00.590 --> 06:01.110
第一个的话

06:01.110 --> 06:03.390
就是当你执行大量计算的时候

06:05.190 --> 06:08.430
当你需要执行大量计算

06:09.990 --> 06:10.830
或者什么呢

06:10.830 --> 06:11.870
或者这个设备

06:13.070 --> 06:17.110
设备本身的这个性能不足的时候

06:18.110 --> 06:19.150
那么这个时候的话

06:19.150 --> 06:20.670
页面就会出现什么呢

06:20.670 --> 06:23.830
页面就会出现这个调整

06:25.030 --> 06:27.870
卡顿的这个现象

06:27.870 --> 06:29.310
这个本质上

06:29.310 --> 06:32.190
这个本质上是什么呢

06:32.190 --> 06:33.430
是这个CPU

06:34.830 --> 06:36.070
就来自于

06:36.070 --> 06:41.780
本质上是来自于CPU的瓶颜

06:41.780 --> 06:42.580
对不对

06:42.580 --> 06:44.940
比如你的这个CPU更快一些

06:44.940 --> 06:45.660
那你这边的话

06:45.660 --> 06:48.060
这个调整的现象就会更少一些

06:48.060 --> 06:48.300
对吧

06:48.300 --> 06:50.620
它本质上是这个CPU的瓶颜

06:50.620 --> 06:50.820
好

06:50.820 --> 06:52.460
第二个就是什么呢

06:52.460 --> 06:55.300
第二个就是进行这个iO操作的时候

06:57.060 --> 06:58.620
进行iO操作

07:00.380 --> 07:01.180
操作的时候

07:03.300 --> 07:04.460
进行iO操作的时候

07:04.460 --> 07:06.060
可能会就是需要什么呢

07:06.060 --> 07:08.740
需要等待有数据

07:08.740 --> 07:10.980
数据返回后

07:10.980 --> 07:14.100
再进行后续的操作

07:15.700 --> 07:17.740
那么等待的过程中

07:17.740 --> 07:19.540
等待的过程中

07:21.060 --> 07:22.700
无法快速响应

07:23.900 --> 07:24.340
对吧

07:24.340 --> 07:25.940
那这种情况

07:25.940 --> 07:29.900
这种情况实际上是来自于什么呢

07:29.900 --> 07:31.060
来自于这个iO

07:32.540 --> 07:34.380
来自于iO的瓶颜

07:35.980 --> 07:36.940
OK

07:36.940 --> 07:37.900
说整体来讲的话

07:37.900 --> 07:39.140
我们这边概括起来的话

07:39.140 --> 07:41.900
就是你这边的话就有这么两个东西

07:41.900 --> 07:42.660
一个是什么呢

07:42.660 --> 07:44.380
一个是CPU瓶颜

07:44.380 --> 07:46.220
一个是iO瓶颜

07:46.220 --> 07:46.540
好

07:46.540 --> 07:48.260
那我们这边把这两个瓶颜

07:48.260 --> 07:50.740
我们单独把它拎出来看一下

07:50.740 --> 07:52.500
首先第一个是CPU瓶颜

07:54.260 --> 07:55.180
第二个是什么呢

07:55.180 --> 07:56.380
第二个是iO瓶颜

07:58.670 --> 08:00.710
iO瓶颜

08:00.710 --> 08:01.470
OK

08:01.470 --> 08:03.910
我们首先先来看CPU瓶颜

08:05.350 --> 08:06.310
平时的话

08:06.310 --> 08:08.310
比如说我们在用浏览器

08:08.310 --> 08:10.470
浏览网页的时候

08:10.470 --> 08:11.510
那这个网页的话

08:11.510 --> 08:12.790
它实际上是什么呢

08:12.790 --> 08:16.270
实际上它是一针一针画出来的

08:16.270 --> 08:17.230
它就像一个什么呢

08:17.270 --> 08:19.430
就像一个画家一样

08:19.430 --> 08:20.670
我这边放了一张图

08:22.310 --> 08:23.710
就这张图

08:23.710 --> 08:24.550
OK

08:24.550 --> 08:26.190
就平时我们在浏览网页的时候

08:27.630 --> 08:35.310
平时我们在在浏览网页的时候

08:35.310 --> 08:40.350
这张网页这张网页实际上是有什么呢

08:40.350 --> 08:43.070
是由浏览器汇制出来的

08:44.550 --> 08:45.630
就像什么呢

08:45.670 --> 08:49.270
就像一个画家画画一样

08:52.250 --> 08:54.370
一点一点画出来的

08:54.370 --> 08:57.210
但是和这个画家画画不同的是什么呢

08:57.210 --> 08:59.490
就我们网页里面经常是不是可以看到

08:59.490 --> 09:01.330
能够动起来的东西

09:01.330 --> 09:01.730
对不对

09:01.730 --> 09:03.970
比如你随便打开一个这个电上网站

09:03.970 --> 09:04.930
你会发现里面的话

09:04.930 --> 09:06.930
会有一些就是能够动起来的东西

09:06.930 --> 09:08.570
比如什么轮波图啊

09:08.570 --> 09:09.890
百叶窗啊

09:09.890 --> 09:11.290
飞舞的这种图片呀

09:12.410 --> 09:13.210
对吧

09:13.210 --> 09:16.370
那你回忆一下动画的本质是什么

09:16.370 --> 09:19.370
这个我们之前在最早讲这个CSS动画的时候

09:19.370 --> 09:20.370
我们就讲过

09:20.370 --> 09:20.610
对吧

09:20.610 --> 09:22.370
动画的本质是什么

09:22.370 --> 09:24.570
动画的本质其实就是什么

09:24.570 --> 09:26.170
是短时间内

09:26.170 --> 09:29.370
是不快速的播放多个画面

09:29.370 --> 09:30.370
对不对

09:30.370 --> 09:35.250
利用你这个人眼的视觉暂停的这种特性

09:35.250 --> 09:36.930
从而给你造成一种什么呢

09:36.930 --> 09:39.610
造成一种感觉这个画面动起来了

09:39.610 --> 09:41.170
这种效果

09:41.170 --> 09:43.770
就有点类似于以前的那种老师的那种

09:44.170 --> 09:45.970
这种焦片电影

09:45.970 --> 09:48.370
不知道大家有没有见过那种焦片电影

09:48.370 --> 09:49.370
这个方应员的话

09:49.370 --> 09:52.170
他会拿这个一大盘的这种焦片

09:52.170 --> 09:52.970
焦片上面的话

09:52.970 --> 09:54.970
他就会有一个一个的格子

09:54.970 --> 09:57.770
每个格子里面其实就是有一个画面

09:57.770 --> 09:58.570
然后回头的话

09:58.570 --> 10:01.570
你这边其实就是快速的播放那些画面

10:01.570 --> 10:02.170
回头的话

10:02.170 --> 10:04.370
感觉就是这个人物动起来了

10:04.370 --> 10:05.570
一样

10:05.570 --> 10:06.370
OK

10:06.370 --> 10:08.370
那么既然我们网页里面

10:08.370 --> 10:10.170
也有这些动起来的东西

10:10.170 --> 10:11.170
那么

10:11.170 --> 10:12.970
毕竟那么就必然

10:12.970 --> 10:13.570
什么呢

10:13.570 --> 10:15.170
必然的话是不是就是

10:15.170 --> 10:15.770
浏览器

10:15.770 --> 10:17.770
它实际上它的本质是什么

10:17.770 --> 10:18.370
本质是不是

10:18.370 --> 10:21.170
就是在不停的进行一个会质

10:21.170 --> 10:21.970
对不对

10:21.970 --> 10:23.570
我们这边记录一下

10:23.570 --> 10:28.170
平时我们所浏览的网页

10:28.170 --> 10:35.170
所浏览的网页里面往往会有一些什么

10:35.170 --> 10:35.970
动起来的

10:37.970 --> 10:39.970
动起来的东西

10:39.970 --> 10:40.970
对不对

10:40.970 --> 10:42.970
比如轮波图

10:42.970 --> 10:43.970
轮波图

10:43.970 --> 10:45.970
白液窗

10:45.970 --> 10:46.970
之类的

10:46.970 --> 10:48.970
那它的本质是什么呢

10:48.970 --> 10:49.970
本质

10:49.970 --> 10:52.970
其实就是浏览器

10:52.970 --> 10:56.970
不停的在进行会质

10:56.970 --> 10:59.970
在进行会质

10:59.970 --> 11:00.970
OK

11:00.970 --> 11:03.970
那么浏览器不停的在进行会质

11:03.970 --> 11:05.970
它的这个会质的频率是多少呢

11:05.970 --> 11:07.970
你目前的话

11:07.970 --> 11:08.970
大多数设备

11:08.970 --> 11:12.970
它这个刷新的频率都是60fps

11:12.970 --> 11:13.970
有什么意思呢

11:13.970 --> 11:17.970
一秒钟的话要会质60次

11:17.970 --> 11:19.970
那么你这么计算下来的话

11:19.970 --> 11:21.970
那这个一秒钟

11:21.970 --> 11:23.970
也就是1000毫秒

11:23.970 --> 11:24.970
大致就是什么呢

11:24.970 --> 11:27.970
大致就是16.66毫秒

11:27.970 --> 11:30.970
你就需要会质一帧

11:30.970 --> 11:35.970
目前大多数设备的这个刷新频率

11:38.790 --> 11:39.790
为多少呢

11:39.790 --> 11:41.790
为60fps

11:41.790 --> 11:43.790
你这个频率越高

11:43.790 --> 11:45.790
你的这个画面就会越流畅

11:45.790 --> 11:46.790
对不对

11:46.790 --> 11:47.790
因为你这个一秒钟里面

11:47.790 --> 11:49.790
会质的这个张数越多了

11:49.790 --> 11:53.790
60fps意味着什么呢

11:53.790 --> 11:56.790
意味着这个一秒钟

11:56.790 --> 12:00.100
一秒钟

12:00.100 --> 12:02.100
一秒钟

12:02.100 --> 12:06.100
需要会质60次

12:06.100 --> 12:08.100
那接下来你这边算一下

12:08.100 --> 12:09.100
1000毫秒

12:09.100 --> 12:11.100
一秒钟就是1000毫秒吗

12:11.100 --> 12:13.100
那你除一个60

12:13.100 --> 12:14.100
大致就等于多少呢

12:14.100 --> 12:17.100
大致就等于16.66毫秒

12:17.100 --> 12:19.100
也就是说

12:19.100 --> 12:21.100
也就是说

12:21.100 --> 12:25.100
浏览器会质一帧

12:25.100 --> 12:27.100
一帧就是一张画面

12:27.100 --> 12:28.100
会质一帧

12:28.100 --> 12:29.100
就是需要什么呢

12:29.100 --> 12:30.100
需要

12:30.100 --> 12:31.100
不是

12:31.100 --> 12:33.100
就是浏览器

12:33.100 --> 12:35.100
每隔

12:35.100 --> 12:37.100
每隔

12:37.100 --> 12:41.100
16.66毫秒

12:41.100 --> 12:43.100
就需要

12:43.100 --> 12:45.100
会质一帧

12:45.100 --> 12:46.100
对吧

12:46.100 --> 12:47.100
需要会质一帧

12:47.100 --> 12:48.100
会质一张画面

12:48.100 --> 12:50.100
没问题吧

12:50.100 --> 12:52.100
那接下来浏览器在会质

12:52.100 --> 12:53.100
每一帧的时候

12:53.100 --> 12:55.100
它实际上它要做的事情

12:55.100 --> 12:57.100
其实不仅仅是就是

12:57.100 --> 12:58.100
我会质就完事了

12:58.100 --> 13:00.100
它其实前面的话

13:00.100 --> 13:02.100
还有很多东西要做的

13:02.100 --> 13:05.100
浏览器在会质

13:05.100 --> 13:08.100
一帧这个画面的时候

13:08.100 --> 13:10.100
实际上

13:10.100 --> 13:12.100
实际上

13:12.100 --> 13:15.100
还有很多的这个事情

13:15.100 --> 13:16.100
要做

13:16.100 --> 13:18.100
那比如说我这边有张图

13:18.100 --> 13:20.100
我把这张图拿过来

13:20.100 --> 13:22.100
稍等

13:22.100 --> 13:24.100
我这张图拿过来

13:24.100 --> 13:25.100
你看一下

13:25.100 --> 13:27.100
这边是一张图

13:27.100 --> 13:28.100
你看这边的话

13:28.100 --> 13:29.100
在会质之前

13:29.100 --> 13:30.100
你看到这边

13:31.100 --> 13:32.100
对不对

13:32.100 --> 13:34.100
然后加这边处理这个样式

13:34.100 --> 13:35.100
然后加这边

13:38.100 --> 13:39.100
接下来才是

13:41.100 --> 13:42.100
这个的话实际上

13:42.100 --> 13:44.100
在袁老师的浏览器

13:44.100 --> 13:45.100
渲染原理里面

13:45.100 --> 13:47.100
都是讲过的

13:47.100 --> 13:49.100
它是整个有这么一个

13:49.100 --> 13:51.100
渲染的流水线

13:51.100 --> 13:55.100
上图中的这个任务

13:55.100 --> 13:57.100
被称之为什么呢

13:57.100 --> 13:59.100
被称之为渲染

13:59.100 --> 14:02.670
流水线

14:02.670 --> 14:04.670
流水线

14:04.670 --> 14:06.670
因为每次

14:06.670 --> 14:09.670
每次执行这个

14:09.670 --> 14:11.670
流水线的时候

14:11.670 --> 14:13.670
流水线的时候

14:13.670 --> 14:15.670
它这边大致基本上

14:15.670 --> 14:17.670
都是有这么一些任务

14:17.670 --> 14:18.670
但是不一定就是

14:18.670 --> 14:19.670
全部都要执行

14:19.670 --> 14:25.670
大致是需要如上的

14:25.670 --> 14:26.670
一些步骤

14:26.670 --> 14:29.670
但是并不是说

14:29.670 --> 14:31.670
每一次

14:31.670 --> 14:32.670
每一次

14:32.670 --> 14:34.670
所有的任务

14:34.670 --> 14:37.670
都需要全部执行

14:37.670 --> 14:42.750
比如举个例子

14:42.750 --> 14:44.750
这边直接把这

14:44.750 --> 14:45.750
这三种情况

14:45.750 --> 14:46.750
我直接把它拿过来

14:46.750 --> 14:50.900
把它放到这里

14:50.900 --> 14:52.900
比如你看这边有三种情况

14:52.900 --> 14:54.900
比如当你使用

14:54.900 --> 14:56.900
就是GS或者CSS

14:56.900 --> 14:58.900
修改动物元素的

14:58.900 --> 14:59.900
这个几何属性

14:59.900 --> 15:01.900
比如长度宽度的时候

15:01.900 --> 15:02.900
那这个时候的话

15:02.900 --> 15:05.900
就会触发完整的渲染流水线

15:05.900 --> 15:07.900
把这个加粗

15:07.900 --> 15:09.900
那这种情况

15:09.900 --> 15:11.900
我们称之为重排

15:11.900 --> 15:13.900
有些你看有些这个地方

15:13.900 --> 15:15.900
它也称之为就回流

15:15.900 --> 15:16.900
就整个流水线

15:16.900 --> 15:18.900
要完整的走一遍

15:18.900 --> 15:20.900
如果比如你在修改

15:20.900 --> 15:21.900
某些属性

15:21.900 --> 15:23.900
它不涉及到这个几何属性

15:23.900 --> 15:24.900
比如你修改的是什么呢

15:24.900 --> 15:25.900
修改的是比如说

15:25.900 --> 15:27.900
肢体颜色

15:27.900 --> 15:28.900
那么它会省略掉什么呢

15:28.900 --> 15:30.900
省略掉流水线中的

15:30.900 --> 15:32.900
layout and layer

15:32.900 --> 15:33.900
对不对

15:33.900 --> 15:34.900
这种情况我们称之为什么呢

15:34.900 --> 15:36.900
会称之为这个重汇

15:36.900 --> 15:38.900
重汇

15:38.900 --> 15:39.900
好

15:39.900 --> 15:40.900
然后当你修改

15:40.900 --> 15:42.900
不涉及重排重汇的属性

15:42.900 --> 15:44.900
比如说这个transform

15:44.900 --> 15:45.900
这种

15:45.900 --> 15:46.900
它会把什么呢

15:46.900 --> 15:47.900
它会把这个layout layer

15:47.900 --> 15:48.900
然后print

15:48.900 --> 15:50.900
包括这个print过程

15:50.900 --> 15:52.900
它都把它省略掉

15:52.900 --> 15:53.900
仅仅执行什么呢

15:53.900 --> 15:55.900
执行这个步骤

15:55.900 --> 15:57.900
composite

15:57.900 --> 15:59.900
就是合成

15:59.900 --> 16:00.900
所以这边的话

16:00.900 --> 16:01.900
整个这个就是

16:01.900 --> 16:03.900
根据你这个

16:03.900 --> 16:05.900
不同的这个操作

16:05.900 --> 16:06.900
它这边的这个流水线

16:06.900 --> 16:07.900
它所执行的这个任务

16:07.900 --> 16:09.900
它是不一样的

16:09.900 --> 16:13.270
按照这个性能高低的话

16:13.270 --> 16:16.270
按照性能高低

16:16.270 --> 16:19.270
进行排序的话

16:19.270 --> 16:21.270
排序的话

16:21.270 --> 16:23.270
那谁的性能是最高的

16:23.270 --> 16:24.270
合成

16:24.270 --> 16:25.270
对不对

16:25.270 --> 16:26.270
过了是什么

16:26.270 --> 16:28.270
过了是重汇

16:28.270 --> 16:29.270
重汇

16:29.270 --> 16:30.270
那接下来

16:30.270 --> 16:31.270
这个新能

16:31.270 --> 16:33.270
这个性能消耗最多的是什么

16:33.270 --> 16:35.270
重排

16:35.270 --> 16:36.270
对吧

16:36.270 --> 16:39.290
重排

16:39.290 --> 16:40.290
重排

16:40.290 --> 16:42.290
你这边让你还得去干吗

16:42.290 --> 16:44.290
还得去这个进行layout layer

16:44.290 --> 16:45.290
这些

16:45.290 --> 16:46.290
对吧

16:46.290 --> 16:47.290
所以这就是为什么

16:47.290 --> 16:49.290
这个CSS动画性能

16:49.290 --> 16:52.290
要优于这个GS动画性能

16:52.290 --> 16:53.290
因为你前者的话

16:53.290 --> 16:55.290
可能仅仅涉及到这个合成

16:55.290 --> 16:56.290
然后你后者的话

16:56.290 --> 17:00.290
可能会涉及到重排这个重汇

17:00.290 --> 17:02.290
然后你这边你汇制

17:02.290 --> 17:04.290
汇制的话最终的这个产物

17:04.290 --> 17:05.290
它是一张什么呢

17:05.290 --> 17:07.290
它是一张这个图片

17:07.290 --> 17:08.290
那这张图片的话

17:08.290 --> 17:10.290
它会被发送给这个显卡

17:10.290 --> 17:13.290
之后的话会显示到这个屏幕上面

17:13.290 --> 17:14.290
那么前面我们说过

17:14.290 --> 17:16.290
浏览器它这边汇制的这个频率

17:16.290 --> 17:18.290
这个频率是多少

17:18.290 --> 17:20.290
是不是16.66毫秒

17:20.290 --> 17:21.290
对不对

17:21.290 --> 17:23.290
是16.66毫秒

17:23.290 --> 17:25.290
而你执行GS

17:25.290 --> 17:27.290
与这个渲染流水线

17:27.290 --> 17:30.290
它实际上是在同一个线程上面执行的

17:30.290 --> 17:31.290
OK注意哦

17:31.290 --> 17:33.290
这边画重点

17:33.290 --> 17:35.290
前面说过

17:35.290 --> 17:39.290
浏览器汇制的频率

17:39.290 --> 17:43.290
是16.66毫秒

17:43.290 --> 17:45.290
然后一张

17:45.290 --> 17:46.290
对吧

17:46.290 --> 17:49.290
但是执行GS

17:49.290 --> 17:50.290
与什么呢

17:50.290 --> 17:53.290
与渲染流水线

17:53.290 --> 17:56.290
实际上是在什么呢

17:56.290 --> 18:01.290
是在同一个线程上面执行

18:01.290 --> 18:02.290
OK

18:02.290 --> 18:04.290
那这也就意味着

18:04.290 --> 18:07.290
也就意味着

18:07.290 --> 18:14.290
如果GS执行的时间过长

18:14.290 --> 18:15.290
那么会导致什么

18:15.290 --> 18:19.290
是不是不能够及时的渲染下一张

18:19.290 --> 18:20.290
对不对

18:20.290 --> 18:25.290
不能够及时的渲染下一张

18:25.290 --> 18:28.290
那不能够及时的渲染下一张

18:28.290 --> 18:29.290
那么就意味着什么

18:29.290 --> 18:31.290
意味着页面调整

18:31.290 --> 18:38.290
也就意味着页面调整

18:38.290 --> 18:41.290
OK那表现

18:41.290 --> 18:44.290
表现出来的这个现象

18:44.290 --> 18:45.290
就是什么呢

18:45.290 --> 18:47.290
就是页面卡顿

18:47.290 --> 18:48.290
对吧

18:48.290 --> 18:50.290
你这个让一个外行人来看的话

18:50.290 --> 18:51.290
他就会给你说

18:51.290 --> 18:53.290
哇这个页面好卡

18:53.290 --> 18:54.290
实际上专业一点

18:54.290 --> 18:55.290
叫什么调整的

18:55.290 --> 18:56.290
对不对

18:56.290 --> 18:57.290
那为什么会调整

18:57.290 --> 19:00.290
因为他没有及时的渲染出下一张

19:00.290 --> 19:02.290
那为什么没有及时的渲染出下一张

19:02.290 --> 19:06.290
有可能就是因为你GS执行的时间太长了

19:06.290 --> 19:07.290
好来接下来

19:07.290 --> 19:09.290
我们这边来看个例子

19:09.290 --> 19:13.290
这边来看一个例子

19:13.290 --> 19:17.290
这边的话是一个空白的页面

19:17.290 --> 19:18.290
我们这边的话

19:18.290 --> 19:21.290
首先这边我拿一个东西过来

19:22.290 --> 19:24.290
我把这个代码拿过来

19:24.290 --> 19:26.290
各说话一下

19:26.290 --> 19:28.290
首先这边有个button

19:28.290 --> 19:31.290
button的话这边会执行一段耗时的GS

19:31.290 --> 19:33.290
然后加这边的话有一个这个bore

19:33.290 --> 19:34.290
这bore是什么呢

19:34.290 --> 19:36.290
bore的话那是一个小球

19:36.290 --> 19:37.290
它这边的话

19:37.290 --> 19:39.290
我们使用这个css的动画

19:39.290 --> 19:40.290
我们来移动它

19:40.290 --> 19:41.290
这个例子

19:41.290 --> 19:43.290
应该很多同学看过

19:44.290 --> 19:46.290
保存一下

19:46.290 --> 19:47.290
保存了之后

19:47.290 --> 19:49.290
然后加我们这边打开一下

19:49.290 --> 19:50.290
好这边

19:50.290 --> 19:52.290
你看这个小球

19:52.290 --> 19:54.290
这边它就是一个移动

19:54.290 --> 19:55.290
移动到这

19:55.290 --> 19:56.290
然后接下来它又回来

19:56.290 --> 19:59.290
这就是一个简单的动画效果

19:59.290 --> 20:01.290
这个动画效果是使用什么呢

20:01.290 --> 20:03.290
是使用这个nift

20:03.290 --> 20:05.290
修改这个nift

20:05.290 --> 20:07.290
通过修改这个nift

20:07.290 --> 20:10.290
来实现了这个动画效果

20:10.290 --> 20:11.290
回头的话

20:11.290 --> 20:12.290
我们在这边的话

20:12.290 --> 20:14.290
我们来写一段script

20:14.290 --> 20:16.290
在script里面我们做什么呢

20:16.290 --> 20:18.290
我们做的事情很简单

20:18.290 --> 20:19.290
我们这边的话

20:19.290 --> 20:22.290
就给它执行一段耗时的这个css

20:22.290 --> 20:24.290
这边大家看一下

20:24.290 --> 20:25.290
这边这个btn

20:25.290 --> 20:27.290
btn的话然后加这边unclick

20:27.290 --> 20:29.290
然后加这边调用什么呢

20:29.290 --> 20:30.290
调用这个delay

20:30.290 --> 20:32.290
然后接下来这边主射5秒钟

20:32.290 --> 20:34.290
然后加这个delay里面也没做什么

20:34.290 --> 20:36.290
就是一个window循环

20:36.290 --> 20:38.290
对吧它就会主射5秒钟

20:38.290 --> 20:39.290
好然后加回头

20:39.290 --> 20:40.290
我们这边我们来看一下

20:40.290 --> 20:42.290
我这边重新刷新

20:42.290 --> 20:44.290
注意我现在我点击按钮

20:44.290 --> 20:46.290
你会发现这个小球卡住了

20:47.290 --> 20:49.290
对不对小球卡住了

20:49.290 --> 20:50.290
那5秒钟之后

20:50.290 --> 20:51.290
你看瞬移了

20:51.290 --> 20:52.290
是瞬移到这里

20:52.290 --> 20:54.290
对不对小球继续移动

20:54.290 --> 20:55.290
比我再来执行

20:55.290 --> 20:57.290
小球又被卡住了

20:57.290 --> 20:59.290
对不对卡住5秒钟之后

20:59.290 --> 21:00.290
然后接下来它这边

21:00.290 --> 21:02.290
对不对是不是给人的感觉

21:02.290 --> 21:03.290
是不是就是卡顿

21:03.290 --> 21:05.290
对不对那为什么会卡顿

21:05.290 --> 21:08.290
是不是就是因为我们这个js

21:08.290 --> 21:11.290
是不是js这边这个运行的这个时间

21:11.290 --> 21:13.290
是不是太长了

21:13.290 --> 21:15.290
对不对我们这边是手动

21:16.290 --> 21:18.290
因为你这个js

21:18.290 --> 21:20.290
所花费的这个时间太久了

21:20.290 --> 21:25.290
说没有办法及时的去渲染下一阵

21:26.290 --> 21:27.290
那么之前的话

21:27.290 --> 21:29.290
在这个旧的价格里面

21:29.290 --> 21:31.290
它也会出现这个问题

21:32.290 --> 21:35.290
在这个w15

21:36.290 --> 21:39.290
以及这个w15之前

21:41.600 --> 21:43.600
我们就称之为w15之前

21:43.600 --> 21:45.600
对不对w15之前

21:45.600 --> 21:48.600
包括w15就存在

21:49.600 --> 21:52.600
就存在这个问题

21:53.600 --> 21:54.600
什么问题呢

21:54.600 --> 21:58.600
js代码执行的时间

21:59.600 --> 22:01.600
时间过长

22:04.980 --> 22:05.980
那大家仔细想一想

22:05.980 --> 22:07.980
这边的话这个react

22:07.980 --> 22:09.980
它在哪个地方

22:09.980 --> 22:11.980
它所执行的这个js代码

22:11.980 --> 22:13.980
会花费很长的这个时间

22:14.980 --> 22:15.980
我们之前的话

22:15.980 --> 22:16.980
我们讲过就是上节课

22:16.980 --> 22:19.980
我们是不是讲过这个虚拟断目

22:19.980 --> 22:20.980
虚拟断目的话

22:20.980 --> 22:21.980
它本质上是什么

22:21.980 --> 22:23.980
是不是描述这个

22:23.980 --> 22:26.980
你的真实的这个断目的这个程式结构

22:26.980 --> 22:27.980
然后在react里面

22:27.980 --> 22:28.980
它使用的是什么呢

22:28.980 --> 22:30.980
使用的是这个对象

22:30.980 --> 22:31.980
对不对

22:31.980 --> 22:32.980
那你这边呢

22:32.980 --> 22:34.980
这个react它需要干嘛

22:34.980 --> 22:37.980
是不是需要去计算整颗虚拟断目

22:38.980 --> 22:39.980
对不对

22:39.980 --> 22:41.980
在react中

22:41.980 --> 22:48.980
需要去计算整颗虚拟断目

22:50.980 --> 22:53.980
那你这个计算整颗虚拟断目

22:53.980 --> 22:54.980
它虽然说是什么呢

22:54.980 --> 22:55.980
虽然说

22:55.980 --> 23:01.980
虽然说是js层面的这个计算

23:02.980 --> 23:03.980
相比什么呢

23:03.980 --> 23:05.980
相比这个动物

23:06.980 --> 23:08.980
相比这个直接操作动物

23:09.980 --> 23:12.980
直接操作动物

23:12.980 --> 23:14.980
节省了很多时间

23:14.980 --> 23:16.980
节省了很多时间

23:16.980 --> 23:25.980
但是每次重新去计算整颗这个虚拟断目

23:25.980 --> 23:27.980
虚拟断目数

23:28.980 --> 23:32.540
会造成什么呢

23:32.540 --> 23:34.540
会造成

23:34.540 --> 23:41.860
每一帧的这个节省代码的执行时间过长

23:41.860 --> 23:43.860
时间过长

23:43.860 --> 23:45.860
从而导致什么呢

23:45.860 --> 23:47.860
导致这个动画

23:48.860 --> 23:50.860
从而导致这个动画

23:50.860 --> 23:51.860
还有什么呢

23:51.860 --> 23:55.860
还有一些实时更新

23:56.860 --> 23:58.860
实时更新

23:58.860 --> 23:59.860
得不到什么呢

23:59.860 --> 24:02.860
得不到及时的响应

24:03.860 --> 24:04.860
及时的响应

24:04.860 --> 24:05.860
造成什么呢

24:05.860 --> 24:10.860
造成卡顿的视觉效果

24:12.860 --> 24:13.860
每一帧

24:13.860 --> 24:14.860
每一帧你这边的话

24:14.860 --> 24:16.860
每次那个虚拟断目数

24:16.860 --> 24:17.860
每次的话

24:17.860 --> 24:19.860
我要去做那个地幅比较

24:19.860 --> 24:22.860
比较整个虚拟断目数

24:22.860 --> 24:24.860
每一帧你这个比较的时候

24:24.860 --> 24:25.860
你这个计算的话

24:25.860 --> 24:27.860
其实是比较花时间的

24:27.860 --> 24:29.860
比较假设

24:31.860 --> 24:33.860
假设有如下的

24:33.860 --> 24:37.940
到这个断目层次结构

24:38.940 --> 24:39.940
比方说这边有个图

24:40.940 --> 24:43.940
假设有这么一个断目层次

24:43.940 --> 24:44.940
稍等啊

24:44.940 --> 24:47.950
这边卡住了

24:47.950 --> 24:49.950
假设有这么一个

24:50.950 --> 24:52.950
等一下我重新粘一下

24:54.950 --> 24:55.950
这边

24:56.950 --> 24:58.950
假设有这么一个结构

24:58.950 --> 25:00.950
这边DIV,HEP,UAL

25:00.950 --> 25:01.950
下面三个粒

25:01.950 --> 25:03.950
那么转换成

25:03.950 --> 25:05.950
那么转换成

25:05.950 --> 25:06.950
虚拟

25:06.950 --> 25:09.950
断目这个对象结构

25:09.950 --> 25:12.950
大字如下

25:12.950 --> 25:14.950
大字长什么样子呢

25:14.950 --> 25:15.950
大字是这个样子的

25:15.950 --> 25:17.950
把他拿过来

25:17.950 --> 25:19.950
大字的话是

25:19.950 --> 25:20.950
这个样子

25:24.160 --> 25:25.160
你看

25:25.160 --> 25:26.160
这边有Type

25:26.160 --> 25:28.160
Type然后加这边有Props

25:28.160 --> 25:30.160
Props然后加这边Q准

25:30.160 --> 25:32.160
Q准对应是一个数组

25:32.160 --> 25:33.160
对吧,数组下面

25:33.160 --> 25:34.160
然后加这边又是

25:34.160 --> 25:35.160
一个一个对象

25:35.160 --> 25:37.160
大家在这边Q准

25:37.160 --> 25:39.160
UAL下面Q准又对应了

25:39.160 --> 25:40.160
是一个什么

25:40.160 --> 25:41.160
又对应了是一个数组

25:41.160 --> 25:42.160
对不对

25:42.160 --> 25:44.160
他对应的结构是这样子的

25:44.160 --> 25:45.160
那你这边的话

25:45.160 --> 25:47.160
你要便利这个结构的话

25:47.160 --> 25:48.160
就只能使用什么呢

25:48.160 --> 25:50.160
就只能使用

25:50.160 --> 25:51.160
迪归

25:53.160 --> 25:54.160
在这个

25:55.160 --> 25:56.160
Direct

25:56.160 --> 25:57.160
V15

25:58.160 --> 26:00.160
V15

26:00.160 --> 26:01.160
版本

26:01.160 --> 26:02.160
之前

26:04.160 --> 26:06.160
应该叫做V16版本之前

26:07.160 --> 26:09.160
V16版本之前

26:09.160 --> 26:10.160
然后进行

26:10.160 --> 26:11.160
两颗

26:12.160 --> 26:14.160
两颗虚拟动物数

26:14.160 --> 26:18.470
数的这个对比的时候

26:18.470 --> 26:19.470
对比的时候

26:19.470 --> 26:20.470
需要

26:20.470 --> 26:22.470
涉及到什么呢

26:22.470 --> 26:24.470
涉及到便利

26:24.470 --> 26:26.470
上面的这个结构

26:27.470 --> 26:28.470
好,那我这边

26:28.470 --> 26:29.470
要便利这个

26:29.470 --> 26:30.470
上面的这个结构

26:30.470 --> 26:31.470
只能使用什么呢

26:31.470 --> 26:33.470
只能使用迪归

26:33.470 --> 26:35.470
这个时候

26:35.470 --> 26:37.470
只能使用

26:38.470 --> 26:39.470
迪归

26:39.470 --> 26:40.470
没办法

26:40.470 --> 26:41.470
对不对

26:41.470 --> 26:42.470
你这边一层一层的

26:42.470 --> 26:43.470
这边这个虚拟进去

26:43.470 --> 26:44.470
然后这样又使用迪归

26:44.470 --> 26:45.470
又进行这个便利

26:45.470 --> 26:46.470
而且这种

26:46.470 --> 26:48.470
迪归它是不能够打断的

26:48.470 --> 26:49.470
而且

26:49.470 --> 26:50.470
这种

26:50.470 --> 26:51.470
迪归

26:52.470 --> 26:54.470
是不能够

26:54.470 --> 26:55.470
打断的

26:55.470 --> 26:56.470
你没办法打断

26:56.470 --> 26:57.470
对不对

26:57.470 --> 26:58.470
我迪归

26:58.470 --> 26:59.470
这个迪归一旦开始了

26:59.470 --> 27:01.470
你是没办法打断的

27:01.470 --> 27:05.040
然后一条路走到黑

27:05.040 --> 27:06.040
走到黑

27:06.040 --> 27:08.040
从而造成了

27:08.040 --> 27:10.040
造成了

27:10.040 --> 27:11.040
接使

27:11.040 --> 27:13.040
执行时间

27:13.040 --> 27:14.040
过长

27:15.040 --> 27:17.040
这边的这个官方有张图

27:17.040 --> 27:20.040
把官方这张图把拿过来

27:20.040 --> 27:21.040
以前这种价格的话

27:21.040 --> 27:23.040
大致就有点类似于这种

27:23.040 --> 27:24.040
可能没有

27:24.040 --> 27:25.040
就一条路走到黑

27:25.040 --> 27:26.040
这边往下

27:26.040 --> 27:27.040
往下

27:27.040 --> 27:28.040
往下

27:28.040 --> 27:29.040
一点一点

27:29.040 --> 27:31.040
再回到这个上面

27:32.040 --> 27:34.040
这样的这个价格模式的话

27:34.040 --> 27:35.040
官方就称之为

27:35.040 --> 27:37.040
Stank价格模式

27:38.040 --> 27:39.040
OK

27:39.040 --> 27:40.040
因为什么呢

27:40.040 --> 27:42.040
因为采用的是

27:42.040 --> 27:43.040
迪归

27:44.040 --> 27:45.040
会什么呢

27:45.040 --> 27:47.040
会不停的

27:47.040 --> 27:49.040
不停的开启

27:50.040 --> 27:51.040
新的

27:52.040 --> 27:54.040
新的这个寒树栈

27:55.040 --> 27:56.040
对吧

27:56.040 --> 27:57.040
一栈的话就是Stank嘛

27:57.040 --> 27:58.040
所以他这边的

27:58.040 --> 27:59.040
这边的

27:59.040 --> 28:00.040
这边的

28:00.040 --> 28:01.040
这边的

28:01.040 --> 28:02.040
这边的

28:02.040 --> 28:03.040
这边的

28:03.040 --> 28:04.040
这边的

28:04.040 --> 28:05.040
这边的

28:05.040 --> 28:06.040
这边的

28:06.040 --> 28:07.040
那就是Stank嘛

28:07.040 --> 28:08.040
所以他这边的

28:08.040 --> 28:09.040
称之为这个

28:09.040 --> 28:10.040
Stank价格模式

28:10.040 --> 28:12.040
这个的话就是以前

28:12.040 --> 28:14.040
就老的架构

28:14.040 --> 28:16.040
这边应该叫做V16之前

28:16.040 --> 28:18.040
这就是之前这个

28:18.040 --> 28:19.040
V16之前

28:19.040 --> 28:20.040
这种架构

28:20.040 --> 28:22.040
它所存在的这个CPU的这个瓶颈

28:22.040 --> 28:24.040
你每一次这个进行一个

28:24.040 --> 28:26.040
虚拟动物数计算的时候

28:26.040 --> 28:27.040
这皆是

28:27.040 --> 28:29.040
太花费时间了

28:29.040 --> 28:30.040
好然后接下来

28:30.040 --> 28:32.040
以前的话这个IO瓶颈

28:32.040 --> 28:34.040
我们来开这种IO瓶颈

28:35.040 --> 28:37.040
好那这个对于前端

28:37.040 --> 28:38.040
这个

28:38.040 --> 28:40.040
对于前端这个开发来讲

28:40.040 --> 28:42.040
最主要的IO瓶颈是什么呢

28:42.040 --> 28:44.040
最主要的IO瓶颈就是网络延迟

28:44.040 --> 28:46.040
对于

28:46.040 --> 28:49.040
前端开发来讲

28:49.040 --> 28:52.040
最主要的这个IO瓶颈

28:52.040 --> 28:55.610
IO瓶颈就是什么呢

28:55.610 --> 28:57.610
就是网络延迟

28:57.610 --> 29:00.560
OK

29:01.560 --> 29:03.560
那么这里的话就存在一个问题

29:03.560 --> 29:05.560
就你这个网络延迟的话

29:05.560 --> 29:07.560
它是不是它是客观存在的

29:07.560 --> 29:08.560
对不对

29:08.560 --> 29:10.560
只要你要进行这个网络通信的话

29:10.560 --> 29:13.560
它一定会存在这种网络延迟的这种情况

29:13.560 --> 29:16.560
那么如何就是减少这个IO瓶颈

29:16.560 --> 29:19.560
对这个用户的这个影响呢

29:19.560 --> 29:21.560
这个RECT团队给出的答案是什么呢

29:21.560 --> 29:24.560
就是将人机交互的这个研究成果

29:24.560 --> 29:26.560
整合到UI里面

29:26.560 --> 29:27.560
这个什么意思

29:27.560 --> 29:29.560
我们这边来写一下

29:29.560 --> 29:32.560
就是网络延迟

29:32.560 --> 29:34.560
网络延迟是一种什么呢

29:34.560 --> 29:36.560
是一种这种客观

29:36.560 --> 29:40.560
客观存在的现象

29:40.560 --> 29:41.560
对不对

29:41.560 --> 29:45.560
那么如何减少

29:45.560 --> 29:47.560
这种现象

29:47.560 --> 29:51.060
这种现象

29:51.060 --> 29:56.060
这种现象对用户的这个影响呢

29:56.060 --> 29:59.270
影响呢

29:59.270 --> 30:02.270
然后这个RECT团队

30:02.270 --> 30:05.270
给出的答案是什么呢

30:05.270 --> 30:08.270
就是将人机交互

30:08.270 --> 30:14.270
将人机交互的这个研究成果

30:14.270 --> 30:19.270
整合到UI中

30:19.270 --> 30:20.270
这句话什么意思

30:20.270 --> 30:22.270
比如我们举个例子

30:22.270 --> 30:26.270
比如用户在进行这个文本框输入内容的时候

30:26.270 --> 30:27.270
那你这个输入对吧

30:27.270 --> 30:28.270
比如一个文本框

30:28.270 --> 30:30.270
用户在这个文本框

30:30.270 --> 30:32.270
这个聚焦到那里

30:32.270 --> 30:34.270
这样键盘进行输入

30:34.270 --> 30:35.270
那这个时候的话

30:35.270 --> 30:37.270
你这个输入用户期望什么

30:37.270 --> 30:38.270
说比如我输入一个制服

30:38.270 --> 30:40.270
然后接下来你的那个输入框

30:40.270 --> 30:42.270
是不是立马就会显示出这个制服

30:42.270 --> 30:43.270
对不对

30:43.270 --> 30:44.270
那假设

30:44.270 --> 30:46.270
比如用户在进行输入的时候

30:46.270 --> 30:47.270
比如按下去

30:47.270 --> 30:50.270
按下去了一个这个键盘上面的一个键

30:50.270 --> 30:51.270
按下去了之后

30:51.270 --> 30:52.270
然后你那个输入框

30:52.270 --> 30:54.270
半天那个就是

30:54.270 --> 30:56.270
就没有显示出来

30:56.270 --> 30:59.270
哪怕只有轻微的这种延迟

30:59.270 --> 31:01.270
那用户也会感受到什么

31:01.270 --> 31:03.270
这也会感受到卡顿

31:03.270 --> 31:05.270
是不是这个道理

31:05.270 --> 31:06.270
你仔细想一想

31:06.270 --> 31:08.270
比如你这边有个输入框

31:08.270 --> 31:10.270
输入框用户聚焦在这里

31:10.270 --> 31:11.270
用户开始输入

31:11.270 --> 31:12.270
开始输入的话

31:12.270 --> 31:14.270
哪怕只有轻微的延迟

31:14.270 --> 31:15.270
一点点延迟

31:15.270 --> 31:16.270
那用户也会感受到

31:16.270 --> 31:18.270
明显的这种卡顿

31:18.270 --> 31:20.270
但是比如说用户点击

31:20.270 --> 31:22.270
这个加载数据按钮

31:22.270 --> 31:24.270
比如我这边有个UVL

31:24.270 --> 31:26.270
UVL下面他是一个列表

31:26.270 --> 31:27.270
一条一条的

31:27.270 --> 31:28.270
一条一条的

31:28.270 --> 31:29.270
比如我这边有个按钮

31:29.270 --> 31:30.270
按钮的话是这个

31:30.270 --> 31:32.270
加载这个最新数据

31:32.270 --> 31:33.270
我点一下这个按钮

31:33.270 --> 31:34.270
点一下这个按钮之后

31:34.270 --> 31:35.270
然后接下来下面

31:35.270 --> 31:36.270
下面要加载这个数据

31:36.270 --> 31:38.270
我稍微做一些这种动画

31:38.270 --> 31:40.270
对吧稍微做一些这种动画

31:40.270 --> 31:42.270
那这个时候哪怕就是你显示

31:42.270 --> 31:44.270
就从你这个点击按钮

31:44.270 --> 31:46.270
到显示数据

31:46.270 --> 31:47.270
哪怕他loading的

31:47.270 --> 31:49.270
比如说两三秒时间

31:49.270 --> 31:50.270
这种的话

31:50.270 --> 31:53.650
用户也不会感觉到这种卡顿

31:53.650 --> 31:54.650
对不对

31:54.650 --> 31:56.650
你注意这种就是用户对

31:56.650 --> 31:58.650
这种卡顿的这种感知

31:58.650 --> 32:00.650
是不一样的

32:01.650 --> 32:06.650
用户对卡顿的感知

32:06.650 --> 32:08.650
是不一样的

32:08.650 --> 32:10.650
然后输入框

32:10.650 --> 32:12.650
哪怕只有什么呢

32:12.650 --> 32:14.650
只有轻微的延迟

32:14.650 --> 32:21.600
用户也会认为很卡

32:21.600 --> 32:22.600
对不对

32:22.600 --> 32:27.170
然后假设是加载

32:27.170 --> 32:31.170
加载一个列表

32:31.170 --> 32:35.170
哪怕loading好几秒

32:35.170 --> 32:37.170
但前提是你要做好

32:37.170 --> 32:40.170
对应的那种动画效果

32:40.170 --> 32:42.170
就什么股价框之类的

32:42.170 --> 32:44.170
你得把那些做好

32:44.170 --> 32:47.170
哪怕loading好几秒用户

32:47.170 --> 32:49.170
也不会觉得什么

32:49.170 --> 32:51.170
也不会觉得卡顿

32:51.170 --> 32:52.170
对不对

32:52.170 --> 32:53.170
你看这个的话

32:53.170 --> 32:55.170
其实就是人机交互的一些

32:55.170 --> 32:57.170
研究成果

32:57.170 --> 32:59.170
那对于react来讲

32:59.170 --> 33:02.170
你所有的东西实际上都是来自于什么

33:02.170 --> 33:05.170
是不是都是来自于自变量的变化

33:05.170 --> 33:11.800
对于react来讲

33:11.800 --> 33:13.800
所有的操作

33:13.800 --> 33:19.800
所有的操作都是来自于自变量的变化

33:19.800 --> 33:22.800
自变量的变化

33:22.800 --> 33:24.800
然后导致的什么呢

33:24.800 --> 33:27.800
导致的重新渲染

33:27.800 --> 33:28.800
对不对

33:28.800 --> 33:29.800
你想想在react里面

33:29.800 --> 33:30.800
这个输入框

33:30.800 --> 33:31.800
输入框的话

33:31.800 --> 33:33.800
它是不是一般也是那种收控组件

33:33.800 --> 33:34.800
对了

33:34.800 --> 33:35.800
收控组件

33:35.800 --> 33:37.800
然后那个就是状态是绑定了的

33:37.800 --> 33:38.800
你状态

33:38.800 --> 33:39.800
然后一改变

33:39.800 --> 33:40.800
那这样我这边

33:40.800 --> 33:41.800
我那个输入框

33:41.800 --> 33:42.800
通过重新渲染

33:42.800 --> 33:43.800
对不对

33:43.800 --> 33:45.800
那这样你看到就是我这个制服输入上去了

33:45.800 --> 33:47.800
那你这边这个夹仔列表

33:47.800 --> 33:49.800
是不是其实也是通过什么

33:49.800 --> 33:51.800
是不是通过这个状态的改变

33:51.800 --> 33:53.800
那接下获取这个新的状态

33:53.800 --> 33:54.800
对不对

33:54.800 --> 33:57.800
所有的状态都来自于这个自变量变化

33:57.800 --> 33:58.800
重新渲染

33:58.800 --> 34:00.800
那么我们只需要什么呢

34:00.800 --> 34:03.800
我们只需要

34:03.800 --> 34:04.800
针对什么呢

34:04.800 --> 34:07.800
针对不同的这个操作

34:07.800 --> 34:12.800
赋予不同的优先级

34:12.800 --> 34:15.800
优先级即可

34:15.800 --> 34:16.800
对不对

34:16.800 --> 34:17.800
具体来说的话

34:17.800 --> 34:18.800
整体来讲

34:18.800 --> 34:20.800
其实就是这三点

34:20.800 --> 34:21.800
把这三点

34:21.800 --> 34:24.430
这把拿过来

34:24.430 --> 34:25.430
OK

34:25.430 --> 34:26.430
具体来说的话

34:26.430 --> 34:27.430
主要包含这么一个

34:27.430 --> 34:29.430
这个以下三点

34:29.430 --> 34:32.430
为不同操作造成的这个自变量变化

34:32.430 --> 34:35.430
赋予不同的优先级

34:35.430 --> 34:36.430
好

34:36.430 --> 34:37.430
然后接下来

34:37.430 --> 34:38.430
所有的优先级

34:38.430 --> 34:40.430
统一进行调度

34:40.430 --> 34:44.430
优先处理最高优先级的这个更新

34:44.430 --> 34:45.430
好

34:45.430 --> 34:46.430
那接下来

34:46.430 --> 34:48.430
如果就是你更新正在进行

34:48.430 --> 34:51.430
就是你这个虚拟多么相关的这个工作

34:51.430 --> 34:52.430
更新正在进行

34:52.430 --> 34:54.430
这个时候有一个什么呢

34:54.430 --> 34:56.430
有一个更高优先级的更新产生的话

34:56.430 --> 34:58.430
中断当前的更新

34:58.430 --> 35:02.430
优先处理高优先级的更新

35:02.430 --> 35:03.430
对吧

35:03.430 --> 35:05.430
比如说我现在正在这个加载列表

35:05.430 --> 35:06.430
正在加载列表

35:06.430 --> 35:07.430
这个时候用户的话再输入

35:07.430 --> 35:09.430
那这个明显这个输入的话

35:09.430 --> 35:11.430
他的优先级是不是应该更高一些

35:11.430 --> 35:12.430
对不对

35:12.430 --> 35:15.430
优先处理这个高优先级的这个更新

35:15.430 --> 35:16.430
好

35:16.430 --> 35:17.430
那你这边的话

35:17.430 --> 35:18.430
要实现

35:18.430 --> 35:20.430
上面的这三个点

35:20.430 --> 35:22.430
要实现

35:22.430 --> 35:27.260
上面的这三个点

35:27.260 --> 35:29.260
就需要什么呢

35:29.260 --> 35:32.260
就需要react底层

35:32.260 --> 35:34.260
能够实现什么呢

35:34.260 --> 35:36.260
首先第一个

35:36.260 --> 35:38.260
就是用于

35:38.260 --> 35:41.260
调度这个优先级

35:41.260 --> 35:44.260
优先级的这个调度器

35:44.260 --> 35:46.260
你首先需要有一个调度器

35:46.260 --> 35:48.260
他能够调度优先级

35:48.260 --> 35:49.260
第二个就是什么呢

35:49.260 --> 35:52.260
第二个就是调度器

35:52.260 --> 35:56.260
对应的调度算法

35:56.260 --> 35:57.260
对吧

35:57.260 --> 35:58.260
第三个就是什么

35:58.260 --> 36:01.260
第三个就是支持

36:01.260 --> 36:03.260
支持可终断

36:03.260 --> 36:08.260
可终断的虚拟断目的实现

36:08.260 --> 36:10.260
因为我们之前说过

36:10.260 --> 36:12.260
你之前这种虚拟断目的这种结构

36:12.260 --> 36:14.260
之前我们的虚拟断目的结构

36:14.260 --> 36:15.260
是不是这样子的

36:15.260 --> 36:16.260
这样子的话

36:16.260 --> 36:17.260
它采用的是帝规的方式

36:17.260 --> 36:19.260
帝规的方式你能不能终断

36:19.260 --> 36:20.260
没办法终断

36:20.260 --> 36:21.260
对不对

36:21.260 --> 36:22.260
一条路走到黑

36:22.260 --> 36:23.260
你是没办法终断的

36:23.260 --> 36:24.260
所以我们这边

36:24.260 --> 36:25.260
要实现这些点

36:25.260 --> 36:27.260
这边你就需要底层的话

36:27.260 --> 36:29.260
能够实现这三个

36:29.260 --> 36:31.260
你需要有调度器

36:31.260 --> 36:32.260
对应的调度算法

36:32.260 --> 36:34.260
还有就是你的虚拟断目的实现

36:34.260 --> 36:35.260
你需要什么呢

36:35.260 --> 36:37.260
需要这个可以终断

36:37.260 --> 36:40.260
所以不管是解决CPU瓶颈

36:40.260 --> 36:41.260
还是IO瓶颈

36:41.260 --> 36:44.260
其实底层的诉求就是什么呢

36:44.260 --> 36:45.260
底层的诉求就是

36:45.260 --> 36:48.260
实现这个time is nice

36:48.260 --> 36:49.260
时间切片

36:49.260 --> 36:54.260
所以不管是解决

36:54.260 --> 36:57.260
这个CPU的瓶颈

36:57.260 --> 36:58.260
还是什么呢

36:58.260 --> 37:02.260
还是这个IO的瓶颈

37:02.260 --> 37:06.260
底层的诉求都是什么呢

37:06.260 --> 37:12.260
都是需要实现这个time is nice

37:12.260 --> 37:15.260
就时间切片

37:15.260 --> 37:18.260
了解了这个就价构的问题之后

37:18.260 --> 37:20.260
然后接下来我们再来看什么呢

37:20.260 --> 37:23.260
再来看这个新价构的解决思路

37:23.260 --> 37:25.260
新价构的解决思路的话

37:25.260 --> 37:27.260
我们这边还是分为两点

37:27.260 --> 37:29.260
首先第一个是什么呢

37:29.260 --> 37:34.890
第一个是解决CPU瓶颈

37:34.890 --> 37:35.890
第二个是什么呢

37:35.890 --> 37:42.460
第二个是解决IO瓶颈

37:42.460 --> 37:44.460
我们一个一个来看

37:44.460 --> 37:47.460
首先解决CPU瓶颈

37:47.460 --> 37:49.460
从react v16开始

37:49.460 --> 37:51.460
react团队的话

37:51.460 --> 37:53.460
它就正式引入了fiber的概念

37:53.460 --> 37:59.340
从react v16开始

37:59.340 --> 38:05.340
官方团队正式引入了fiber

38:05.340 --> 38:08.340
fiber的概念

38:08.340 --> 38:10.340
这fiber是什么呢

38:10.340 --> 38:14.340
它的话是一种通过链表数据结构

38:14.340 --> 38:16.340
来描述UI的方式

38:16.340 --> 38:24.340
这是一种通过链表来描述UI的

38:24.340 --> 38:26.340
这种方式

38:26.340 --> 38:28.340
本质上

38:28.340 --> 38:34.340
你也可以看作是一种虚拟动物

38:34.340 --> 38:37.340
虚拟动物的实现

38:37.340 --> 38:39.340
因为我们上节课我们讲过虚拟动物

38:39.340 --> 38:42.340
虚拟动物它本质上就是一个概念

38:42.340 --> 38:44.340
我们说过只要你有

38:44.340 --> 38:46.340
比如说某种方式

38:46.340 --> 38:49.340
能够描述我的UI的层次结构

38:49.340 --> 38:52.340
那你这种方式就是虚拟动物

38:52.340 --> 38:53.340
对不对

38:53.340 --> 38:55.340
所以fiber的话

38:55.340 --> 38:58.340
本质上你也可以把它看作是一种虚拟动物

38:58.340 --> 38:59.340
只不过它是通过什么呢

38:59.340 --> 39:02.340
它只是通过链表的这种形式来描述

39:02.340 --> 39:06.340
这边实际上官方有这个说明

39:06.340 --> 39:08.340
把这个直接复制过来

39:08.340 --> 39:12.340
这是来自于官方文档里面的说明

39:12.340 --> 39:14.340
你看一下

39:14.340 --> 39:17.340
与其将v2.0视为一种技术

39:17.340 --> 39:20.340
不如说它是一种模式

39:20.340 --> 39:23.340
它们提到它实际上是要表达不同的东西

39:23.340 --> 39:25.340
在react世界里

39:25.340 --> 39:29.340
数与v2.0通常与react元素关联在一起

39:29.340 --> 39:31.340
这个react元素我们是不是也说过了

39:31.340 --> 39:32.340
对不对

39:32.340 --> 39:34.340
我们上节课讲虚拟动物的时候

39:34.340 --> 39:36.340
我们说过crate element的方法

39:36.340 --> 39:38.340
返回了对象

39:38.340 --> 39:41.340
官方的话更倾向于叫做react元素

39:41.340 --> 39:42.340
OK

39:42.340 --> 39:45.340
因为它们都是代表了用户界面的对象

39:45.340 --> 39:46.340
对吧

39:46.340 --> 39:49.340
现在的话react也使用一个名为fibers的内部对象

39:49.340 --> 39:51.340
它本质上其实也是个对象

39:51.340 --> 39:53.340
fibers它本质上也是个对象

39:53.340 --> 39:59.340
通过这个对象来存放组建素的附加信息

39:59.340 --> 40:01.340
所以你这个的话它也可以看做什么呢

40:01.340 --> 40:05.340
也可以看做是V2.0实现的一个部分

40:05.340 --> 40:06.340
OK

40:07.340 --> 40:11.340
fibers的话它本质上它是一个对象

40:11.340 --> 40:15.340
它通过一个对象来描述一个动物节点

40:15.340 --> 40:18.340
那么它和之前的react元素

40:18.340 --> 40:21.340
这种方案有什么不同的地方呢

40:21.340 --> 40:24.340
它最大的特点就是通过练表的方式

40:24.340 --> 40:27.340
进行了一个串联

40:27.340 --> 40:30.340
通过悄的来指向指元素

40:30.340 --> 40:33.340
通过这个sabling指向兄弟元素

40:33.340 --> 40:37.340
通过return指向副元素

40:37.340 --> 40:44.340
fibers本质上也是一个对象

40:44.340 --> 40:49.340
但是和之前react元素

40:49.340 --> 40:51.340
我们也叫react元素

40:51.340 --> 40:56.340
和react元素不同的地方

40:56.340 --> 41:01.340
在于对象之间使用什么

41:01.340 --> 41:06.340
使用练表的这种结构串联起来

41:06.340 --> 41:08.340
但是这边什么是练表

41:08.340 --> 41:09.340
我这个就不解释了

41:09.340 --> 41:13.340
这个是属于学计算机的同学基础知识

41:13.340 --> 41:16.340
练表的话是属于一种数据结构

41:16.340 --> 41:18.340
你如果不清楚这个练表的话

41:18.340 --> 41:19.340
你自己下去

41:19.340 --> 41:21.340
你去了解一下什么是练表

41:21.340 --> 41:22.340
我这边就不花时间

41:22.340 --> 41:24.340
再来给你解释什么是练表了

41:24.340 --> 41:27.340
而这边它使用练表的这种结构

41:27.340 --> 41:29.340
把它串联起来

41:29.340 --> 41:33.340
那这个俏的指向什么呢

41:33.340 --> 41:36.340
指向指元素

41:36.340 --> 41:44.100
然后加这个sabling指向兄弟元素

41:44.100 --> 41:47.100
这个return指向什么呢

41:47.100 --> 41:50.930
指向副元素

41:50.930 --> 41:52.930
指向副元素

41:52.930 --> 41:55.930
比如说我们这边有这么一个结构

41:55.930 --> 41:57.930
比如这边如下图

41:57.930 --> 42:00.930
比如有这么一个结构

42:00.930 --> 42:02.930
大家来看一下

42:02.930 --> 42:03.930
不要这里

42:03.930 --> 42:05.930
我这边有个div

42:05.930 --> 42:06.930
div下面有个p

42:06.930 --> 42:07.930
就我们刚才那个吗

42:07.930 --> 42:09.930
我看刚才这个

42:09.930 --> 42:10.930
就这个

42:10.930 --> 42:11.930
比如我们这边有这么一个结构

42:11.930 --> 42:14.930
divHEPURL

42:14.930 --> 42:16.930
以前的话你通过react元素

42:16.930 --> 42:18.930
表现出来是这个样子的

42:18.930 --> 42:20.930
对不对

42:20.930 --> 42:22.930
好那你现在的话通过fiber

42:22.930 --> 42:24.930
fiber的话它这边就干嘛

42:24.930 --> 42:26.930
就给你串成一条线了

42:26.930 --> 42:27.930
看到没有

42:27.930 --> 42:28.930
它就这边练表嘛

42:28.930 --> 42:30.930
练表的话直接给你串成一条线了

42:30.930 --> 42:33.930
这边divCHAU的指向这个p

42:33.930 --> 42:35.930
psabling指向这个ur

42:35.930 --> 42:37.930
ur下面这个CHAU的

42:37.930 --> 42:39.930
lisabling Li

42:39.930 --> 42:41.930
然后加这边sabling Li

42:41.930 --> 42:42.930
那通过什么呢

42:42.930 --> 42:44.930
通过return指向它们的副元素

42:44.930 --> 42:45.930
看到没有

42:45.930 --> 42:47.930
这边通过return指向它们的副元素

42:49.930 --> 42:51.930
好那这边的话你通过这种结构

42:51.930 --> 42:53.930
通过这种练表的这种结构

42:53.930 --> 42:55.930
它有个什么样的好处呢

42:55.930 --> 42:57.930
它最大的好处就是

42:57.930 --> 43:00.930
你在进行这个整棵数计算的时候

43:00.930 --> 43:02.930
这个计算它是可以打断的

43:02.930 --> 43:07.240
使用练表

43:07.240 --> 43:09.240
这种结构

43:09.240 --> 43:10.240
这种结构

43:10.240 --> 43:14.240
有一个最大的好处

43:14.240 --> 43:19.240
就是在进行整棵数的

43:19.240 --> 43:21.240
这个对比计算时

43:21.240 --> 43:22.240
这个对比计算

43:22.240 --> 43:23.240
然后我们后面有个

43:23.240 --> 43:27.000
专门的词叫做reconcel

43:27.000 --> 43:28.000
在进行整棵数的

43:28.000 --> 43:31.000
这个对比计算时

43:31.000 --> 43:34.000
这个过程是可以

43:34.000 --> 43:37.000
被打断的

43:37.000 --> 43:38.000
OK

43:38.000 --> 43:40.000
那它什么时候打断呢

43:40.000 --> 43:41.000
什么时候打断呢

43:41.000 --> 43:42.000
很简单

43:42.000 --> 43:45.000
就是发现你一针时间不够的时候

43:45.000 --> 43:51.000
在发现一针时间已经不够

43:51.000 --> 43:53.000
已经不能够

43:53.000 --> 43:57.000
不能够在继续

43:57.000 --> 43:58.000
执行什么呢

43:58.000 --> 44:00.000
执行这个结构

44:00.000 --> 44:01.000
需要什么呢

44:01.000 --> 44:06.000
需要渲染下一针的时候

44:06.000 --> 44:14.000
这个时候就会打断

44:14.000 --> 44:16.000
结式的执行

44:16.000 --> 44:17.000
OK

44:17.000 --> 44:18.000
优先干嘛呢

44:18.000 --> 44:24.000
优先渲染下一针

44:24.000 --> 44:25.000
那之后的话

44:25.000 --> 44:26.000
你这个渲染完了之后

44:26.000 --> 44:28.000
那再接着回来

44:28.000 --> 44:29.000
完成上一次

44:29.000 --> 44:32.000
没有执行完的结式计算

44:32.000 --> 44:36.000
那就渲染完成后

44:36.000 --> 44:39.000
渲染完成后

44:39.000 --> 44:42.000
再接着回来

44:42.000 --> 44:44.000
接着回来

44:44.000 --> 44:46.000
完成上一次

44:46.000 --> 44:53.000
没有执行完的结式计算

44:53.000 --> 44:54.000
那有了这种架构之后

44:54.000 --> 44:56.000
这边官方给了一张图

44:56.000 --> 44:57.000
这边大家可以看一下

44:57.000 --> 44:59.000
它整个的话就变成这个样子

44:59.000 --> 45:02.630
整个就变这样子了

45:02.630 --> 45:05.350
再像刚才那样子了 刚才的话是不是一条路走到黑

45:06.150 --> 45:14.190
对来 执行这个JS计算啊 一条路走到黑啊 现在的话你看他这边就可以干嘛 这边让你看这边执行 然后时间不够了 对吧 回来

45:14.950 --> 45:19.910
好 回来 然后渲染下一帧 渲染下一帧 加这边又开始执行 时间不够了 又回来

45:20.630 --> 45:22.870
看到没有 非常非常的流畅

45:24.150 --> 45:30.150
那官方的话 这边还提供了一个这个stank架构和这个现在fiber架构的这个对比势力

45:31.110 --> 45:34.950
啊 官方还提供了一个

45:36.310 --> 45:36.950
这个stank

45:38.230 --> 45:41.110
stank架构和什么呢 和这个fiber

45:42.230 --> 45:48.550
fiber架构的这个对比势力啊 把这个例子的话我们这边我们可以看一下啊

45:49.750 --> 45:56.630
这边这个例子 但这个例子的话打开需要换点时间啊 我先先把这个例子我先把它放到

45:57.030 --> 46:05.380
放到我们的笔记里面啊 放到笔记里面啊 这边让我把它打开 这是

46:06.260 --> 46:13.860
fiber 第一个是fiber 第二个的话是stank 啊 但这边需要一点时间啊 我先继续往后面讲 以后我们再来看啊

46:15.700 --> 46:19.140
好像已经打开了吗 你看这个这个是fiber架构

46:20.260 --> 46:24.660
ok 你的fiber架构相当的流畅 对吧 你看这个是stank

46:24.980 --> 46:29.140
你看stank 这给人的感觉是不是就是一卡一卡的

46:30.260 --> 46:37.220
对不对 给人感觉一卡一卡的为什么会一卡一卡的啊 就是因为浏览期的话没有及时的渲染下一帧

46:38.420 --> 46:41.700
那为什么没有及时的渲染下一帧呢啊 就是因为你每次这个

46:42.580 --> 46:48.100
执行接时的时间啊 这个耗费的时间太长了 对不对 你看这个例子很明显

46:48.740 --> 46:50.020
对吧 你看这个就非常流畅

46:50.740 --> 46:50.820
啊

46:52.020 --> 46:58.660
ok 就是官方所提供的这个势力啊 好 然后接下来我们再来看一下这个原码中啊

47:00.020 --> 47:06.340
下面是rekt 原码中 这个创建这个fiber

47:06.980 --> 47:08.900
fiber对象的这个相关代码

47:11.450 --> 47:12.730
我这电脑这个风扇

47:13.930 --> 47:14.810
转的呼呼呼的

47:15.770 --> 47:18.650
把这个先关了啊 这个你们下来可以自己看一下

47:19.610 --> 47:23.210
风扇转的呼呼呼的啊 把这个也关了吧 这个也不需要了

47:24.490 --> 47:24.810
ok

47:26.410 --> 47:31.050
啊 我们把这个创建这个fiber的这个原码我们过来看一下啊

47:31.450 --> 47:37.290
好 原来这边呢有一个叫做quade fiber啊 这边是一个方形啊 接受这么一些参数

47:37.690 --> 47:43.050
好 然后接下来这边是new一个fiber node啊 创建一个fiber load的这个实力对象

47:43.450 --> 47:46.490
对吧 那核心的话这边的话就是在fiber load里面

47:46.970 --> 47:51.290
那fiber load的这边这边也很简单 然后这边呢就会有一系列的这种属性

47:51.770 --> 47:58.570
对吧 type key element type type state node之类的啊 然后接下来这边啊 关键是这里

47:59.050 --> 48:02.250
然后这边呢是return child sublin

48:02.970 --> 48:08.170
啊 你看这个的话其实就是什么 这个其实就是通过练表的形式把每一个fiber对象

48:08.730 --> 48:12.090
进行一个串联 就串联成我们刚才所讲的这种形式

48:13.050 --> 48:13.530
可不可以啊

48:14.330 --> 48:22.730
啊 这是关于这个就这边这几个属性啊 后面呢 后面的话 然后我们后面再说啊 后面有些是和hook相关的

48:23.290 --> 48:25.050
要这一块是和hook相关的

48:25.850 --> 48:28.410
然后这一块这一块的话是和副作用相关的

48:29.050 --> 48:34.810
ok啊 这是整个这个react原码中创建fiber对象的一些代码

48:36.490 --> 48:41.290
好 通过这种方式的话就可以解决我们之前所说的这个cpu的这个平仅啊

48:42.250 --> 48:43.770
好 接下来的话 我们来看一下

48:44.810 --> 48:47.050
如何解决这个io 平仅

48:48.250 --> 48:55.370
那解决io 平仅的话 我们刚说了io 平仅你要想解决他的话 现在的话我们是不是已经可以实现就是可终断的这个训练多么了

48:56.090 --> 49:00.730
这个是不是已经可以了 对不对 那现在的话我们需要有个什么呢 我们需要有个调度器

49:01.290 --> 49:06.410
啊 我们这边呢 就是不同的这种任务 我们要让他有什么呢 要让他有这个优先级

49:06.970 --> 49:10.810
啊 有个优先级的这个概念在里面啊 然后我们要进行一个调度

49:11.530 --> 49:15.450
那为了解决这个io 平仅 那从这个react 16开始

49:18.120 --> 49:21.000
从react v16

49:22.120 --> 49:26.120
开始 引入了什么呢 引入了这个scheduler

49:27.880 --> 49:30.200
这个就是什么呢 这个就是调度器

49:31.080 --> 49:35.640
他的引入的话主要是用来什么呢 主要是用来调度

49:36.360 --> 49:37.560
任务的优先级

49:40.500 --> 49:41.300
优先级

49:43.340 --> 49:47.580
ok 你在这个react v16之前

49:48.540 --> 49:53.660
v16之前 他的这个价格的话 实际上只有两个部分 一个是一个reconcenter

49:57.100 --> 49:59.100
recon 我看一下reconcel

50:00.540 --> 50:03.580
reconcenter 这个是什么呢 这个是协调器

50:05.750 --> 50:06.310
协调

50:07.990 --> 50:12.630
协调器 这协调器是干嘛的啊 这个这个的话主要就是这个vdorm的实现

50:14.310 --> 50:16.630
vdorm的实现啊 根据什么呢

50:16.710 --> 50:18.550
根据这个自变量的变化

50:19.750 --> 50:22.710
自变量的变化

50:23.350 --> 50:27.190
计算出 计算出这个ui的变化

50:28.070 --> 50:30.310
啊 然后另外一个什么呢 另外一个是render

50:31.430 --> 50:33.990
render 这个是什么呢 这个是确认器

50:35.670 --> 50:37.030
这个是负责

50:38.470 --> 50:41.750
负责将ui的变化

50:43.030 --> 50:46.150
啊 然后确认到 确认到数组环境

50:48.440 --> 50:50.040
啊 对应的是不是就是我们那两个步骤

50:50.840 --> 50:54.040
大家还记不记得 就我们那个f 我们这边之前

50:54.600 --> 50:56.040
这个什么呢 ui

50:56.840 --> 50:59.560
等于一个f 然后再这边这个state

51:00.280 --> 51:02.680
对不对 然后加这个的话是不是又可以进行一个拆分

51:03.240 --> 51:04.360
所以拆分成两步啊

51:05.240 --> 51:08.710
对不对啊 这两步的话就是

51:09.670 --> 51:15.670
这个 第一个是根据自变量 计算啊 就是根据自变量的变化 计算出ui

51:15.670 --> 51:18.470
啊 这个呢实际上对应的就是协调器 他的这个工作

51:19.430 --> 51:23.190
啊 另外一个呢是根据ui变化执行具体的数组环境的api

51:23.190 --> 51:26.310
这个其实在16之前就是这个render

51:26.950 --> 51:29.350
实际上之前的话其实就这两两大组件

51:29.750 --> 51:32.310
ok 好 然后从这个v16开始

51:33.270 --> 51:38.710
从react v16开始多了一个组件

51:40.310 --> 51:43.830
啊 这里组件不是说你平时那个react写的那个组件啊

51:43.830 --> 51:46.710
这里说了组的这个组件是向这边

51:47.190 --> 51:50.150
就架构里面的这种组件啊 多了一个组件

51:50.150 --> 51:52.470
它变成了什么呢啊 首先前面两个没变

51:53.270 --> 51:58.310
前面两个依然在啊 那加这边多了一个什么呢 多了一个scadular

52:00.810 --> 52:02.970
啊 这个就是什么呢 这个就是调度器

52:04.170 --> 52:08.570
可不可以啊 这个调度器负责干嘛呢 负责调度任务的优先级

52:10.330 --> 52:14.010
的优先级啊 高优先级

52:14.970 --> 52:22.170
高优先级的任务会什么呢 会优先进入到这个reconcenter

52:22.810 --> 52:27.450
就这个优先进入到这里面啊

52:28.090 --> 52:31.850
好 然后接下来在这个新架构里面这个reconcenter

52:31.850 --> 52:38.010
它里面的这个更新流程也从这个地规变成了这个可终段的这种循环过程

52:39.530 --> 52:44.090
新架构中啊 这个reconcenter就这个协调器

52:45.850 --> 52:52.970
的这个更新流程也从什么呢 也从之前的地规

52:54.010 --> 52:59.240
变成了什么呢 变成了可终段

53:01.080 --> 53:03.480
可终段的循环过程

53:05.080 --> 53:09.000
ok 它每次循环的时候它都会调用一个叫做should yield

53:09.560 --> 53:14.840
去判断当前的这个times nice是否有剩余的这个时间

53:15.640 --> 53:20.280
如果你没有剩余的时间了 那我们就暂停更新流程啊 这里所说的更新就是

53:21.080 --> 53:24.600
计算这个ui的变化啊 不是说的这一步啊 说的是这一步

53:25.160 --> 53:29.080
就这边这一步啊 就计算出那个虚拟多母所对应的这个ui

53:29.720 --> 53:32.760
这边更新说的是这个 就如果你时间不够了

53:33.320 --> 53:38.040
那我们就暂停去计算 对吧 暂停计算那个就是新的那个多母

53:38.040 --> 53:42.600
是什么样子的 将这个主线程还给什么呢 还给这个渲染流水线

53:43.160 --> 53:50.040
好 等待这个下一个这个红任务啊 再进行一个这个继续的这个计算就可以了

53:50.440 --> 53:52.440
啊 它对应了这个代码的话 其实就是在这里

53:54.040 --> 53:56.440
这边对应了这个代码片段 大家可以看一下

54:01.140 --> 54:03.860
这里呀 它这边呢会有一个walk loop

54:04.340 --> 54:06.500
concurrent 这边它是一个循环

54:07.140 --> 54:11.700
对 连while你walking progress不等于闹 就说明还有这个任务

54:12.260 --> 54:14.660
啊 并且什么呢 这边呢 就是这个should yield

54:15.300 --> 54:19.860
就是你时间切片还有这个剩余的时间 那我们这边呢就执行这个

54:20.420 --> 54:22.180
啊 那你这个should yield

54:22.740 --> 54:24.500
should yield这边对应了这个代码

54:25.940 --> 54:26.900
啊 我们这边来看一下

54:29.560 --> 54:33.320
这边should yield啊 这边呢就是get current time

54:33.720 --> 54:38.120
这个是什么呢 这个就是当前时间 是否大于这个过期时间

54:38.680 --> 54:43.480
啊 也就是整个这一块其实就是看什么呢 看你的这个时间是否充足

54:44.120 --> 54:45.720
对吧啊 每次循环

54:49.110 --> 54:55.190
每次循环啊 都会什么呢 都会调用这个should yield

54:56.870 --> 54:58.950
should yield的判断

54:59.750 --> 55:09.590
当前的这个时间切片 是否有这个足够的足够的剩余时间

55:10.630 --> 55:18.630
ok 啊 如果没有啊 如果没有足够的剩余时间

55:21.370 --> 55:24.490
剩余时间就什么呀 就暂停

55:25.850 --> 55:27.770
就暂停这个reconsider

55:28.730 --> 55:34.730
reconsider的这个执行啊 然后将什么呢 将主线程

55:36.410 --> 55:41.290
还 还给这个渲染流水线

55:43.130 --> 55:46.090
啊 渲染流水线啊

55:47.370 --> 55:53.190
流水 渲染流水线啊 然后接下来进行什么 是不是

55:53.190 --> 55:56.790
进行下一帧的这个渲染操作

55:58.230 --> 56:02.790
渲染操作 对不对啊 然后渲染工作完成后

56:03.990 --> 56:11.590
渲染工作完成后再什么呢 再等待下一个同任务

56:13.270 --> 56:16.230
啊 进行什么呢 进行这个后续代码的执行

56:19.690 --> 56:25.450
对吧 他通过这种方式实现一个什么呢 实现一个可终断的循环过程

56:26.090 --> 56:33.370
ok 啊 这就是关于这个新架构啊 他解决了什么问题 以及旧架构他所存在的这个问题

56:34.410 --> 56:41.370
好 回头的话 你这边来看一下这个整体解答啊 是否了解rec的架构 新的相比旧的有什么样的优势

56:41.690 --> 56:45.450
那你这边你在回答的时候 是不就可以回答的更加饱满一些

56:46.250 --> 56:50.090
对不对 啊 我这边把我的这个参考单 我把它拿过来

56:50.810 --> 56:52.330
啊

56:53.290 --> 57:04.570
啊 这个react v15啊 极其之前的架构啊 是这个样子的 对吧 这样子的话会有什么样的问题啊 这边主要是两个方面cpu的平仅和io的平仅

57:05.770 --> 57:11.450
那新的架构 他是fiber架构啊 多了一个这个组件 对不对 调度器这个组件

57:11.930 --> 57:15.210
ok 新的架构的话 然后解决了什么样的这个问题

57:15.850 --> 57:20.810
ok 可以这边的话 你整个回答的话 可以更加具体一些 更加饱满一些

57:21.530 --> 57:27.290
好吧 ok 啊 这就是关于这节课啊 给大家介绍的这个整个react

57:27.770 --> 57:31.130
他的一个整体的这个架构 大家下去的话再看一看

57:31.850 --> 57:34.890
好吧 这期课的话就到这里 再见

