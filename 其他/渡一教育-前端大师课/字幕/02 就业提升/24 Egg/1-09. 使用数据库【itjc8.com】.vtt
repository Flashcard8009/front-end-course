WEBVTT

00:00.820 --> 00:03.180
咱们说一下三层架构里边

00:03.180 --> 00:04.420
MVC讲完了

00:04.420 --> 00:05.820
业务逻辑层讲完了

00:05.820 --> 00:07.420
然后就剩下个数据访问层

00:08.020 --> 00:09.420
数据访问层呢

00:09.820 --> 00:11.420
就是跟数据库之间经营操作

00:11.420 --> 00:13.020
咱们学到数据库有哪些了

00:13.420 --> 00:14.420
有哪些数据库

00:15.220 --> 00:17.020
咱们学到有那个卖搜口

00:17.020 --> 00:17.220
对吧

00:17.220 --> 00:19.420
包括了卖搜口里边一个

00:19.620 --> 00:21.220
欧亚民框架sqlise

00:22.220 --> 00:24.220
还有什么mongotb

00:24.620 --> 00:25.020
对吧

00:25.020 --> 00:27.020
包括他的loaderges里面的

00:28.020 --> 00:28.820
一个驱动

00:28.820 --> 00:29.820
叫mongos

00:31.020 --> 00:31.820
还包括什么呢

00:31.820 --> 00:33.020
还包括radius

00:33.220 --> 00:33.820
对不对

00:34.020 --> 00:35.020
这么一些数据库

00:35.220 --> 00:36.820
他们都是用来存储数据的

00:36.820 --> 00:38.020
各有各的优势

00:38.020 --> 00:39.220
也各有各的缺陷

00:39.220 --> 00:41.020
那么这些数据库的使用

00:42.220 --> 00:44.020
并没有跟之前并没有什么区别

00:44.220 --> 00:45.020
完全一样

00:45.220 --> 00:46.020
你之前怎么用

00:46.020 --> 00:46.820
现在怎么用

00:47.620 --> 00:49.020
那么我们现在只是讲一讲

00:49.020 --> 00:49.620
这些数据库

00:49.820 --> 00:51.620
如何整合到Agg里边

00:51.620 --> 00:53.620
因为Agg他作为一个后端的

00:53.620 --> 00:55.020
一个完整的框架

00:55.020 --> 00:56.420
他肯定要考虑到数据库

00:56.420 --> 00:57.820
数据库我要整合进来

00:57.820 --> 00:59.220
那么具体整合过后

00:59.220 --> 01:00.620
你继续去使用他里边的API

01:00.620 --> 01:01.620
完全一致

01:01.620 --> 01:02.420
没有任何区别

01:03.420 --> 01:05.020
那么这边我们讲什么数据库

01:05.020 --> 01:06.020
就随便讲一个

01:06.420 --> 01:08.220
就不要去一个一个讲了

01:08.220 --> 01:09.020
没有什么意义

01:09.820 --> 01:11.820
这些文档都可以放在这了

01:11.820 --> 01:13.220
前两个是中文文档

01:13.620 --> 01:15.820
因为Agg是本身是阿里做的

01:15.820 --> 01:18.020
他肯定是提供中文文档的

01:18.220 --> 01:19.420
前两个有中文文档

01:19.620 --> 01:21.820
后边两个mongos和radius

01:21.820 --> 01:23.020
是没有中文文档的

01:23.020 --> 01:23.820
所以说我们找一个

01:23.820 --> 01:24.820
没有中文文档的讲

01:25.220 --> 01:26.620
就找一个radius

01:27.620 --> 01:28.620
找着radius讲

01:29.620 --> 01:30.220
进去过后

01:30.220 --> 01:31.820
我们可以看到他这个文档的

01:31.820 --> 01:33.020
特别特别简单

01:33.020 --> 01:33.620
他说

01:34.820 --> 01:35.820
这个radius

01:35.820 --> 01:37.620
他是基于他是个插件

01:37.620 --> 01:38.420
首先是个插件

01:38.420 --> 01:39.020
那你懂了

01:39.220 --> 01:40.220
他只要是个插件

01:40.220 --> 01:41.220
他肯定跑不掉的

01:41.220 --> 01:42.820
要在这里进行配置的

01:43.220 --> 01:44.620
然后在这里要进行配置

01:44.820 --> 01:46.620
在这里要启用这边配置

01:46.820 --> 01:47.820
他是个插件

01:47.820 --> 01:49.220
然后他基于的是一个库

01:49.220 --> 01:50.420
叫IoRadius

01:50.620 --> 01:51.820
我们当时用radius

01:51.820 --> 01:53.620
学习的时候使用的是官方库

01:53.620 --> 01:54.020
对吧

01:54.020 --> 01:56.820
那么IoRadius是一个第三方的库

01:57.020 --> 01:58.020
这个第三方的库

01:58.020 --> 01:59.220
跟官方库最大的区别

01:59.220 --> 02:00.620
就在于他支持Promise

02:01.220 --> 02:03.220
之前官方库是不是不支持Promise

02:03.220 --> 02:04.220
他支持Promise

02:04.220 --> 02:05.420
用起来简便一点

02:05.420 --> 02:06.620
其他的用法都差不多

02:07.220 --> 02:08.220
那么这是

02:08.820 --> 02:09.220
你说他说

02:09.220 --> 02:10.020
如果说API

02:10.020 --> 02:11.420
你要知道API怎么去使用的话

02:11.420 --> 02:12.620
你可以看一下这个库

02:12.620 --> 02:14.420
其实你radius有没有多少API

02:14.420 --> 02:15.420
非常非常简单

02:15.820 --> 02:16.620
那么怎么来用呢

02:16.620 --> 02:17.420
首先安装

02:18.020 --> 02:18.820
安装

02:18.820 --> 02:21.820
npmi egg radius

02:22.820 --> 02:23.620
特别特别简单

02:23.620 --> 02:24.620
别慌

02:25.220 --> 02:25.620
然后了

02:25.620 --> 02:26.820
接下来就是启用插件了

02:26.820 --> 02:27.420
对吧

02:27.420 --> 02:29.020
你没什么好说的

02:30.220 --> 02:31.020
启用插件

02:31.020 --> 02:32.220
启用radius插件

02:32.820 --> 02:33.220
然后了

02:33.220 --> 02:35.020
接下来是否要针对radius配置一下

02:36.420 --> 02:37.220
集中配置

02:37.220 --> 02:38.220
配置radius

02:38.620 --> 02:39.220
然后配置的是

02:39.220 --> 02:40.220
他怎么高水怎么配置呢

02:40.220 --> 02:41.020
就配这样配置

02:42.620 --> 02:43.220
就是

02:43.820 --> 02:45.020
他的一个客户端

02:45.020 --> 02:45.720
连接客户端

02:45.720 --> 02:47.820
连接到端口号是6379

02:47.820 --> 02:48.720
如果说你不改的话

02:48.720 --> 02:50.220
端口号默认就是6379

02:50.420 --> 02:51.820
连接到的主机名是这个

02:51.820 --> 02:52.620
又没有密码了

02:52.620 --> 02:54.220
没有密码留一个空置不串

02:54.420 --> 02:56.020
所以你这个行不能删

02:56.020 --> 02:57.820
必须要留一个空置不串

02:58.020 --> 03:01.020
db就是操作哪个数据户

03:01.020 --> 03:02.820
不是有摸证18个数据户吗

03:02.820 --> 03:03.320
对不对

03:03.320 --> 03:04.320
我们操作第一个吧

03:05.620 --> 03:06.220
我看一下

03:06.220 --> 03:07.620
现在数据户里面有没有东西

03:08.620 --> 03:09.020
radius

03:12.020 --> 03:13.020
还有这么多东西

03:13.420 --> 03:14.020
能弄掉

03:15.420 --> 03:15.820
db

03:17.420 --> 03:18.220
再来看一下

03:19.220 --> 03:19.820
OK

03:20.220 --> 03:21.220
把人家弄掉

03:21.220 --> 03:21.820
干掉

03:22.720 --> 03:23.220
好了

03:23.420 --> 03:25.020
那么现在我们就配置好了

03:25.020 --> 03:25.520
配置好了

03:26.120 --> 03:26.720
怎么用呢

03:26.720 --> 03:27.320
你往下翻

03:27.320 --> 03:28.320
这个文档往下翻

03:28.320 --> 03:29.320
下面肯定有一个U

03:29.320 --> 03:32.320
Uragy使用方式

03:32.320 --> 03:33.120
使用方式它说

03:33.120 --> 03:34.520
在控制器里边

03:34.520 --> 03:35.520
你顺便可以看一下

03:35.520 --> 03:37.520
原来控制器还可以导出一个函

03:37.520 --> 03:38.520
导出一个函数

03:38.520 --> 03:39.920
这个函数传一个App进来

03:40.720 --> 03:42.120
还可以再用这种方式

03:42.120 --> 03:43.720
那么我们之前是直接导出一个内

03:43.720 --> 03:44.120
对吧

03:44.120 --> 03:45.320
它也可以导出一个函数

03:45.320 --> 03:46.920
如果是导出的是一个普通函数的话

03:46.920 --> 03:48.520
它会运行这个函数得到这个内

03:48.520 --> 03:49.520
无所谓吧

03:49.520 --> 03:50.920
那么它这里边怎么用的呢

03:50.920 --> 03:53.520
就是它会注像App这个对象里面

03:53.520 --> 03:55.120
注入一个radius

03:55.120 --> 03:56.720
后边的使用一样了

03:56.720 --> 03:58.920
所以这些数据会都是这样子处理的

03:58.920 --> 04:00.320
无论是MySQL也好

04:00.320 --> 04:00.920
SQLize也好

04:00.920 --> 04:02.320
都是类似的处理方式

04:02.320 --> 04:03.520
就是你安装一个插线

04:03.520 --> 04:05.320
它可以注入App的一个属性

04:05.320 --> 04:06.920
然后后边的用法完全一致

04:06.920 --> 04:08.120
没有什么区别

04:08.120 --> 04:08.320
好了

04:08.320 --> 04:10.320
那么现在我们这里就完事了

04:10.320 --> 04:10.920
对吧

04:10.920 --> 04:11.720
就完事了

04:11.720 --> 04:13.720
完事了过后我们在这里也用

04:13.720 --> 04:15.320
比方说我们这里

04:15.320 --> 04:16.120
这个数据库

04:16.120 --> 04:16.720
就是这个数据库

04:16.720 --> 04:18.720
没有必要每一次都远程请求

04:18.720 --> 04:19.720
我把它缓存一下

04:19.720 --> 04:20.920
缓存到radius里边

04:20.920 --> 04:21.920
那怎么来写呢

04:21.920 --> 04:23.120
我们就可以

04:23.320 --> 04:26.120
ZAppRadius

04:26.120 --> 04:27.720
首先介绍一下

04:27.720 --> 04:28.920
我们比方一个keyz

04:28.920 --> 04:30.120
keyz用province

04:30.120 --> 04:31.320
不然在这里设置个keyz

04:31.320 --> 04:31.920
也行

04:31.920 --> 04:36.010
key province

04:36.010 --> 04:37.210
那么以为我们现在我们是

04:37.210 --> 04:38.610
直改动业务逻辑

04:38.610 --> 04:40.610
业务逻辑里面用缓存

04:40.610 --> 04:42.410
我们这里得到province

04:46.010 --> 04:47.210
所以得到province

04:47.210 --> 04:49.010
注意它这里可以用等待的

04:49.010 --> 04:50.210
因为官方是不能等待的

04:50.210 --> 04:52.010
但是它基于的是IORadius

04:52.010 --> 04:52.610
这个库

04:52.610 --> 04:53.610
这个库是可以

04:53.610 --> 04:54.810
它可以返回province

04:54.810 --> 04:55.810
也可以支持毁掉

04:55.810 --> 04:57.010
都支持

04:57.010 --> 04:58.610
然后得到这个province

04:58.610 --> 05:00.010
当然看一下有没有呢

05:00.010 --> 05:01.410
province如果说存在的话

05:01.410 --> 05:02.010
我啥都不管了

05:02.010 --> 05:03.210
直接返回这个缓存

05:03.210 --> 05:04.410
我们再打印一句吧

05:04.410 --> 05:05.210
使用了缓存

05:07.810 --> 05:09.010
然后呢

05:09.010 --> 05:10.610
当然这个是一个字无串

05:10.610 --> 05:11.610
这是个字无串

05:11.610 --> 05:12.610
那么字无串

05:12.610 --> 05:13.410
你要干嘛呢

05:13.410 --> 05:14.010
要把它

05:14.010 --> 05:15.610
因为我知道radius里面

05:15.610 --> 05:17.010
只能保存字无串

05:17.010 --> 05:18.810
我们把它转换成接成对象

05:18.810 --> 05:19.810
把接成对象

05:19.810 --> 05:21.010
返回就完事了

05:21.010 --> 05:22.010
那如果说没有缓存

05:22.010 --> 05:24.010
它没有缓存远程获取

05:24.010 --> 05:25.010
获取完了过后

05:25.010 --> 05:26.810
把这一块是不是来进行缓存

05:26.810 --> 05:27.410
来吧

05:27.410 --> 05:29.210
来进行缓存

05:29.210 --> 05:30.210
缓存的话就是

05:30.210 --> 05:35.510
Zs,app,radius,set,keyz

05:35.510 --> 05:36.810
这里边是不是要用接成

05:36.810 --> 05:38.210
把它换成字无串

05:38.210 --> 05:39.210
对象

05:40.210 --> 05:42.810
那就是说这里要不要等待它呢

05:42.810 --> 05:44.010
我觉得没有必要了

05:44.010 --> 05:45.210
等待它其实也可以

05:45.210 --> 05:46.510
但是我觉得没有必要

05:46.510 --> 05:48.010
因为这个缓存让它缓存

05:48.010 --> 05:49.010
我不用等待你

05:49.010 --> 05:50.010
你慢慢去缓存

05:50.010 --> 05:52.610
我这里马上要给客户端结果

05:52.610 --> 05:54.010
我把这个东西返回

05:54.010 --> 05:55.610
如果说你等待它的话

05:55.610 --> 05:56.410
那么比方说

05:56.410 --> 05:57.610
我举个例子

05:57.610 --> 05:58.210
比方说缓存

05:58.210 --> 06:00.410
它必定需要一段时间吗

06:00.410 --> 06:02.410
因为它是

06:02.410 --> 06:03.610
要经过radius处理

06:03.610 --> 06:05.010
毕竟需要一段时间

06:05.010 --> 06:06.410
如果说你这里去等待的话

06:06.410 --> 06:07.810
那么会影响

06:07.810 --> 06:10.210
会影响那么一点点用户的

06:10.210 --> 06:11.010
响应时间

06:11.010 --> 06:12.410
但是这个地方是没有必要

06:12.410 --> 06:13.610
就等待它的

06:13.610 --> 06:16.010
让它去慢慢缓存就行了

06:16.010 --> 06:17.210
那就是有一些跟用户

06:17.210 --> 06:18.810
看到东西无关的东西

06:18.810 --> 06:20.110
就服务性内部处理的东西

06:20.110 --> 06:21.410
我们不用等待

06:21.410 --> 06:23.810
能不能待的话就可以不用等待

06:23.810 --> 06:24.910
这里是不是必须要等待

06:24.910 --> 06:25.710
这里要获取的

06:25.710 --> 06:26.210
一不获取

06:26.210 --> 06:28.310
一不等待的话都会拿不到它的结果

06:28.310 --> 06:30.210
你都不知道它的结果有没有缓存

06:30.210 --> 06:31.210
好就写好了

06:31.210 --> 06:31.410
对吧

06:31.410 --> 06:33.110
咱们再来看一下

06:33.110 --> 06:34.410
这里npm装

06:34.410 --> 06:35.010
对

06:35.010 --> 06:37.210
运行出来

06:37.210 --> 06:39.010
你看

06:39.010 --> 06:40.210
爆错了

06:40.210 --> 06:41.410
他说他

06:41.410 --> 06:45.080
启动爆错还是

06:45.080 --> 06:46.380
哦这里配置

06:46.380 --> 06:47.580
配置这里有个问题

06:47.580 --> 06:48.680
配置这里应该是什么

06:48.680 --> 06:50.580
export

06:50.580 --> 06:51.680
他那是把它完整的

06:51.680 --> 06:52.680
封装到一个config对象

06:52.680 --> 06:54.480
最终把整个config对象导出的

06:54.480 --> 06:56.880
我这里是直接用export导出

06:56.880 --> 06:59.460
运行

06:59.460 --> 07:02.260
然后打开它

07:02.260 --> 07:03.060
出来了

07:03.060 --> 07:03.460
对吧

07:03.460 --> 07:04.860
那么现在有没有输出

07:04.860 --> 07:05.960
使用了缓存

07:05.960 --> 07:07.160
是没有使用缓存

07:07.160 --> 07:08.160
那么这一次

07:08.160 --> 07:10.060
访问是不是把数据缓存进来

07:10.060 --> 07:12.060
我们来看一下

07:12.060 --> 07:13.860
接下来我们来试一下

07:13.860 --> 07:16.060
这边我们使用

07:16.060 --> 07:17.960
ready city

07:17.960 --> 07:18.960
然后kiss

07:19.060 --> 07:19.760
看一下有没有这个

07:19.760 --> 07:20.560
哎有的

07:20.560 --> 07:21.960
我们provence得到

07:21.960 --> 07:23.460
说得到缓存的结果了

07:23.460 --> 07:24.560
对不对

07:24.560 --> 07:25.060
好

07:25.060 --> 07:26.260
然后接下来我们再刷新

07:26.260 --> 07:27.260
第二次访问的时候

07:27.260 --> 07:28.960
服务端就使用了缓存

07:28.960 --> 07:29.660
给我们的结果

07:29.660 --> 07:31.660
而没有再次去原称缓问了

07:31.660 --> 07:32.160
对吧

07:32.160 --> 07:35.160
后边都一直是使用了缓存

07:35.160 --> 07:36.960
没意思吧

07:36.960 --> 07:39.160
这是关于这个ready city

07:39.160 --> 07:40.160
它的

07:40.160 --> 07:40.560
使用

07:40.560 --> 07:41.260
当然其他的数据

07:41.260 --> 07:42.460
会是完全一个意思

07:42.460 --> 07:42.960
因为这些数据

07:42.960 --> 07:43.560
会都讲过的

07:43.560 --> 07:44.660
没有必要再一个一个

07:44.660 --> 07:45.860
全部重新讲一遍

07:45.860 --> 07:46.360
没有必要

07:46.360 --> 07:47.660
它只是用法

07:47.660 --> 07:48.560
你看这些文章

07:48.760 --> 07:49.960
你看你明白了

07:49.960 --> 07:50.160
好了

07:50.160 --> 07:51.660
这是关于这个ready city

07:51.660 --> 07:52.460
就是数据库

07:52.460 --> 07:53.460
在那个ag.js里

07:53.460 --> 07:54.160
怎么去整合

07:54.160 --> 07:54.960
其实就是个插件

07:54.960 --> 07:55.860
他把app里面

07:55.860 --> 07:57.660
注入了一个属性

