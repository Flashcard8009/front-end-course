WEBVTT

00:00.000 --> 00:01.800
这一课啊 叫做设计模式 对吧

00:01.800 --> 00:03.900
设计模式一筹 就是一个很高大上的东西啊

00:03.900 --> 00:05.600
无论是设计还是模式 对吧

00:05.600 --> 00:08.600
这两个词的时候都会让你听完以后解决的啊

00:08.600 --> 00:10.300
这个就很牛 对不对啊

00:10.300 --> 00:13.000
那这一课的当然主讲的一个老师是我

00:13.000 --> 00:15.700
我叫陈斯东 我相信很多人是知道我的啊

00:15.700 --> 00:18.100
但我相信也有一部分人可能说还不太熟悉啊

00:18.100 --> 00:21.400
这个专注于这个自己的这个世界里面

00:21.400 --> 00:23.400
专注于这个知识的海洋之中啊

00:23.400 --> 00:25.300
就没有太管我这个人他是谁啊

00:25.300 --> 00:27.200
那我做一个简单的自我介绍 对吧

00:27.200 --> 00:29.300
这个读义教育啊 帅迹讲师 对吧

00:29.300 --> 00:31.100
你没看错 对吧 是帅迹讲师啊

00:31.100 --> 00:32.900
这是我这个去年的一个照片啊

00:32.900 --> 00:36.800
最近稍微点胖了 但我决定这个从牛轮游回来以后的话

00:36.800 --> 00:39.500
我要办张健身卡 这个恢复到当年

00:39.500 --> 00:41.800
这个一身健子肉的一个状态

00:41.800 --> 00:45.600
那现任是咱们读义技术开发型公司的一个VIP啊

00:45.600 --> 00:48.200
这个VIP可以列成 不是VIP啊

00:48.200 --> 00:52.100
这个是VIP啊 副总裁啊

00:52.100 --> 00:54.300
副总裁的话 其实咱们公司没有那么大

00:54.300 --> 00:56.000
不是像同学想象的那种啊

00:56.000 --> 00:57.500
这个像阿里巴巴一样的吧

00:57.500 --> 00:59.400
一提到副总好牛逼啊

00:59.400 --> 01:01.800
咱们是一个中小型的企业啊

01:01.800 --> 01:02.600
中小型的企业的话

01:02.600 --> 01:06.800
一个VIP啊 依旧会干这些做一线的事对吧

01:06.800 --> 01:09.200
就比如说像今天我来给你们去讲课 对不对

01:09.200 --> 01:12.700
但我也挺喜欢讲课的 这个不是一个抱怨啊

01:12.700 --> 01:14.100
呃 但是呢

01:14.100 --> 01:18.600
我同时也联接另外一家公司这样的一个VIP啊

01:18.600 --> 01:21.500
这两家公司其实都是为咱们这样的一个

01:21.500 --> 01:25.400
就是基本上是有一些统一的高管团队

01:25.400 --> 01:27.500
来进行这样的一个管理啊

01:27.500 --> 01:29.500
那这是一个简单自我介绍

01:29.500 --> 01:30.200
那接下来的话

01:30.200 --> 01:34.300
我们开始正式的顾到这个课程的部分啊

01:34.300 --> 01:37.700
好 正式的顾到这个课程的部分啊

01:37.700 --> 01:39.700
那这个课程的部分啊

01:39.700 --> 01:42.100
总共分三个 总共分三个

01:42.100 --> 01:42.500
第一呢

01:42.500 --> 01:43.800
当然就是我们要讲一下

01:43.800 --> 01:45.100
什么是设定模式对吧

01:45.100 --> 01:46.800
当然设定模式这个东西啊

01:46.800 --> 01:49.400
它是必须有原则来进行这样的一个限定的

01:49.400 --> 01:51.800
那它俩是什么关系 我一会说啊

01:51.800 --> 01:54.700
那把设定模式和原则在这一课

01:54.700 --> 01:57.000
基本上给你大概的去说一说

01:57.000 --> 01:57.700
什么意思啊

01:57.700 --> 02:01.100
但咱们这一课不太会落实到正式的

02:01.100 --> 02:03.600
去来讲一个模式它怎么用

02:03.600 --> 02:08.200
咱们会用接下来的这样那个三点课的时间

02:08.200 --> 02:10.000
会讲这个每个模式啊

02:10.000 --> 02:10.900
具体怎么一回事

02:10.900 --> 02:12.200
而且落实到代码之中

02:12.200 --> 02:14.200
就在后来再拿两个课的时间呢

02:14.200 --> 02:18.400
去讲讲这样那个模式的一个真实那个应用

02:18.400 --> 02:20.300
当然我这几届设定模式的课

02:20.300 --> 02:23.500
其实主要还是给你去普及一下

02:23.500 --> 02:26.400
设计模式在前端中这样的应用

02:26.400 --> 02:28.600
比如说先告诉你有这么个东西

02:28.600 --> 02:31.600
然后再告诉你前端需要了解到哪

02:31.600 --> 02:33.600
我把一些重点给你流列出来

02:33.600 --> 02:35.400
当然我也会进行这样的一个讲解

02:35.400 --> 02:36.800
咱们到后期的VUE中啊

02:36.800 --> 02:39.600
你会发现咱会讲很多VUE站的圆码

02:39.600 --> 02:41.100
咱们VUE的这个翻轮过程中的话

02:41.100 --> 02:44.400
会把这个圆码部分也会加持去翻轮一下

02:44.400 --> 02:46.000
因为在这种高级快下转的话

02:46.000 --> 02:50.200
你会发现有很多很多这样那个模式的一个应用

02:50.200 --> 02:52.000
比如说咱们讲设计模式

02:52.000 --> 02:53.300
设计模式这个东西

02:53.300 --> 02:56.100
其实它能真正发挥的这样那个效能

02:56.100 --> 02:58.000
或者说它能真正发挥在这样的威力

02:58.000 --> 02:59.200
并不是在一些

02:59.200 --> 03:01.500
比如说简单的这样那个业务逻辑之中

03:01.500 --> 03:04.100
或者说你简单写这样那个小的一个页面

03:04.100 --> 03:05.600
然后在这样的过程中的话

03:05.600 --> 03:09.300
或者说你碰对或者说你碰见这样一种

03:09.300 --> 03:10.500
简单的业务需求的话

03:10.500 --> 03:13.000
其实你完全没有必要强行去追求

03:13.000 --> 03:15.000
然后拿设计模式去写这个代码

03:15.000 --> 03:15.800
没有必要

03:15.800 --> 03:17.800
因为简单的几行

03:17.800 --> 03:19.500
简单的你写写这样那个

03:19.500 --> 03:21.700
比如说这个几个功能就搞定的事情

03:21.700 --> 03:26.200
没有必要去增加整个业务的一个复杂的长度

03:26.200 --> 03:29.200
但是如果说你这个东西一旦变大了

03:29.200 --> 03:32.000
你需要考虑的东西多了

03:32.000 --> 03:33.800
比如说你要做一个框架去给别人用

03:33.800 --> 03:34.900
你要做一个这样的一个

03:34.900 --> 03:36.600
比如说裤去给别人用

03:36.600 --> 03:39.400
或者说你要设计一个很大的这样的一个站点

03:39.400 --> 03:41.100
或者说你升到这样的一个后台的

03:41.100 --> 03:42.700
一个很复杂的开发之中的话

03:42.700 --> 03:47.600
这个东西是你想做出一个高效的

03:47.600 --> 03:49.500
或者说是一个很稳定的一个系统

03:49.500 --> 03:50.400
或者说一个站点

03:50.400 --> 03:52.700
必不可少的一些思想

03:52.700 --> 03:54.800
当我把这一课讲完以后的话

03:54.800 --> 03:58.600
到后面这个丁老师还会重新带着你们

03:58.600 --> 04:00.200
在这个真正的框架中

04:00.200 --> 04:03.000
我去理解这个设计模式怎么来应用

04:03.000 --> 04:05.100
那大家并不说我这一课不重要

04:05.100 --> 04:06.900
我这一课其实对你们来讲的话

04:06.900 --> 04:07.900
是非常重要的

04:07.900 --> 04:10.300
因为只有你把我这一课听完以后的话

04:10.300 --> 04:12.900
你才能明白这个哥们到底是什么意思

04:12.900 --> 04:14.500
他到底有多么大的作用

04:14.500 --> 04:17.300
我在日后的编程中需要注意什么

04:17.300 --> 04:19.100
我把钱都给你开好以后的话

04:19.200 --> 04:20.200
后面你在自己走的话

04:20.200 --> 04:22.600
我相信会一定很顺畅

04:22.600 --> 04:23.600
很顺畅不一定

04:23.600 --> 04:26.300
但至少是比你自己来要顺畅很多

04:26.300 --> 04:28.600
要比一般人要怎么说呢

04:28.600 --> 04:33.100
要比一般人可能说做一两年开发的话

04:33.100 --> 04:35.500
这个就是因为这边我想说

04:35.500 --> 04:37.800
就是很多人可能说再做一两年开发

04:37.800 --> 04:39.500
做三四年开发工程中的话

04:39.500 --> 04:41.500
他始终是在一个初级工程师

04:41.500 --> 04:43.500
这样一种工作状态之中

04:43.500 --> 04:46.800
就是他不会去研究这么深的一些东西

04:46.800 --> 04:48.700
框架圆码他都不去看

04:48.700 --> 04:50.800
他只是把这些东西拿过来去用

04:50.800 --> 04:53.900
满足基本的这样一个公司的要求对吧

04:53.900 --> 04:56.700
有时候让你能把这东西做出来就可以了

04:56.700 --> 04:58.100
如果说一直这么来干活的话

04:58.100 --> 04:59.000
你是能赚到钱

04:59.000 --> 05:03.000
但是你很难有一个十足的长进和成长

05:03.000 --> 05:05.800
那咱们进阶班其实之前

05:05.800 --> 05:08.100
咱们是定位整套课程

05:08.100 --> 05:08.900
你选以后的话

05:08.900 --> 05:12.200
一定在一些城市可以找到一个很不错的一个工作

05:12.200 --> 05:16.700
但咱们现在对课程的这样一个高度和定位

05:16.800 --> 05:18.800
只能是比之前还要好的

05:18.800 --> 05:20.900
所以说咱们很多东西要不断进行翻路

05:20.900 --> 05:22.400
不断进行深化

05:22.400 --> 05:24.700
我也希望今天班的同学

05:24.700 --> 05:26.400
当你学完今天班以后的话

05:26.400 --> 05:29.400
你至少比如说在一线城市

05:29.400 --> 05:31.200
先能拿到一个很好的工作

05:31.200 --> 05:34.100
与此同时你要在一到三年可能三到五年

05:34.100 --> 05:35.500
始终保持一个比边

05:35.500 --> 05:36.800
还要高的一个竞争力

05:36.800 --> 05:39.400
那这些竞争力一方面取决什么

05:39.400 --> 05:42.000
一方面取决于你的这样的一个

05:42.000 --> 05:45.800
就是一个终身学习的一个想法和意志力

05:45.900 --> 05:50.000
在一方面就是你要需要有一些基本的素质

05:50.000 --> 05:52.900
能让你再继续上来更加的去深造

05:52.900 --> 05:55.000
就比如说设定模式这个东西

05:55.000 --> 05:58.400
或者说学习设定模式这样的一个思想

05:58.400 --> 06:01.500
再就是我们后面汇报里面去加一些

06:01.500 --> 06:03.100
比如说操作系统的课程

06:03.100 --> 06:07.000
比如说这样一些设法的课程

06:07.000 --> 06:08.100
比如说还会加一些

06:08.100 --> 06:10.100
比如说纯网络的这样一些课程

06:10.100 --> 06:12.900
这些东西都有助于营展技术这一块的话

06:12.900 --> 06:14.600
进行深化

06:14.600 --> 06:17.200
那咱课程这个三部分再回到这来

06:17.200 --> 06:19.200
我说首先讲什么是设计模式

06:19.200 --> 06:21.200
什么是原则之后的咱们再来说

06:21.200 --> 06:24.600
咱们再具体来抛弃这个设计模式怎么来用

06:24.600 --> 06:27.000
之后咱们会讲这个UML

06:27.000 --> 06:28.600
这个咱简单提的就行了

06:28.600 --> 06:31.000
它是一个图印画的一个建文语言

06:31.000 --> 06:33.600
就是你通过讲课的时候

06:33.600 --> 06:35.100
其实经常愿意去画些图

06:35.100 --> 06:37.300
因为画图更有助于理解

06:37.300 --> 06:38.700
当我们团队开发公众中的话

06:38.700 --> 06:39.700
我们要做一个项目

06:39.700 --> 06:41.100
这项目很大的情况下的话

06:41.100 --> 06:42.700
你光靠嘴说

06:42.700 --> 06:45.000
你光靠这样的一个文字去写

06:45.000 --> 06:48.600
都不够生动形象或者说简名

06:48.600 --> 06:51.600
那我们如果说能统一达成一个规范

06:51.600 --> 06:53.400
大家都认可这样一个图形语言

06:53.400 --> 06:54.000
对吧

06:54.000 --> 06:54.400
那好了

06:54.400 --> 06:56.400
那我再去抛弃这个系统的时候

06:56.400 --> 06:58.400
我再去做这个系统之前

06:58.400 --> 07:00.000
我通过这个图形

07:00.000 --> 07:02.000
我通过这样一个图形的一个建文语言

07:02.000 --> 07:03.800
把整个流程画出来

07:03.800 --> 07:05.400
把这个整个流程

07:05.400 --> 07:07.100
把这个逻辑给它跑通

07:07.100 --> 07:09.700
完之后再在每一个点上

07:09.700 --> 07:12.100
我尽可能的去细细画它

07:12.100 --> 07:13.400
那我们在编程工程中的话

07:13.400 --> 07:14.600
就按照这个图

07:14.600 --> 07:15.800
转到这样一个图

07:15.800 --> 07:18.500
就进行这样一个生动的一个花圆

07:18.500 --> 07:19.600
那UML图的话

07:19.600 --> 07:21.200
咱们会去花点时间

07:21.200 --> 07:23.300
花一点时间来简单的讲讲

07:23.300 --> 07:24.000
之后呢

07:24.000 --> 07:25.900
我们通过这个图来分析

07:25.900 --> 07:28.200
我是重构这样的摊持石

07:28.200 --> 07:30.400
这样一个小的一个项目

07:30.400 --> 07:33.200
那就是咱们这一届客的三大部分

07:33.200 --> 07:34.700
三大部分

07:34.700 --> 07:35.400
那首先

07:35.400 --> 07:36.700
首先咱来说一下

07:36.700 --> 07:41.010
什么叫做设计模式

07:41.010 --> 07:42.410
前面八弯这么长时间

07:42.410 --> 07:44.310
咱磨刀不砍材工

07:44.310 --> 07:47.310
像同学知道这个东西都没有用

07:47.310 --> 07:48.510
完之后你再来学的话

07:48.510 --> 07:52.210
你才可能说调动你这个十足的一个力量

07:52.210 --> 07:52.610
好

07:52.610 --> 07:53.510
那咱们看一下

07:53.510 --> 07:55.210
什么是设计模式

07:55.210 --> 07:56.410
那咱学它

07:56.410 --> 07:58.110
咱学它咱不能

07:59.510 --> 08:00.810
同学咱背皮

08:02.210 --> 08:04.410
这样这个咱学它

08:04.410 --> 08:07.710
咱首先要知道什么是设计模式

08:07.710 --> 08:10.110
但前人会总结出一些画

08:10.110 --> 08:10.910
这些画的话

08:10.910 --> 08:13.410
你仇仿佛很有哲理的样子

08:13.410 --> 08:16.610
但是我一般都不管这些画叫做人画

08:16.610 --> 08:17.010
因为什么

08:17.010 --> 08:18.610
因为这个东西

08:18.610 --> 08:20.210
它是给真正懂的人看的

08:20.210 --> 08:20.910
你不懂的人

08:20.910 --> 08:21.910
你看完以后的话

08:21.910 --> 08:23.310
你大概能理解这些意思

08:23.310 --> 08:24.810
但你还是不知道怎么一回事

08:24.810 --> 08:26.510
所以说这一块的话

08:26.510 --> 08:28.110
我先简单给你翻译一下

08:28.110 --> 08:29.610
我先简单给你读一下

08:29.610 --> 08:31.110
再简单给你拿生活中的例子

08:31.110 --> 08:32.410
给你翻译一下

08:32.410 --> 08:33.410
完了之后的话

08:33.410 --> 08:35.610
我们再去往下去学

08:35.610 --> 08:36.110
学完以后

08:36.110 --> 08:37.810
你在猴头来去看这句话

08:37.810 --> 08:40.110
你就能大概理解是什么意思了

08:40.110 --> 08:42.610
设计模式是一套被反复使用

08:42.610 --> 08:44.410
多数人都知道的

08:44.410 --> 08:45.610
都知晓的

08:45.610 --> 08:49.010
而且是经过分类和总结的

08:49.010 --> 08:51.810
这种代码设计经验

08:51.810 --> 08:54.210
或者说是按照它这边话来讲的话

08:54.210 --> 08:55.510
就是多数人知晓了

08:55.510 --> 08:58.310
经过分类的代码设计经验的一个总结

08:58.310 --> 08:58.910
一个意思

08:58.910 --> 09:00.310
它一个意思

09:00.310 --> 09:02.610
比如说我们拿生活中的例子来说

09:02.610 --> 09:04.110
就是我们盖房子

09:04.110 --> 09:06.210
因为我们一开始的时候

09:06.210 --> 09:08.010
你回到很多年前

09:08.010 --> 09:11.510
就是回到你还是个元人刚会直立行走的时候

09:11.510 --> 09:12.310
你觉得外面冷了

09:12.310 --> 09:13.710
你想去找个地方去躲一躲

09:13.710 --> 09:14.810
最开始在山洞

09:14.810 --> 09:15.710
后来之后的话

09:15.710 --> 09:16.510
人们会学了

09:16.510 --> 09:19.310
这个东西我可以拿个木头的支植

09:19.310 --> 09:19.710
对吧

09:19.710 --> 09:20.510
上面再盖个草

09:20.510 --> 09:21.010
对不对

09:21.010 --> 09:22.510
一个草房就出来了

09:22.510 --> 09:24.810
一开始不是我们人们在盖房子的时候

09:24.810 --> 09:26.110
在盖房子的时候

09:26.110 --> 09:27.410
当然你不可能一下子

09:27.410 --> 09:29.010
就盖出了一个摩天大楼

09:29.010 --> 09:29.310
对吧

09:29.310 --> 09:31.310
人这个东西不太现实

09:31.310 --> 09:33.910
我们都是从点点积累来

09:33.910 --> 09:35.310
那怎么办呢

09:35.310 --> 09:36.510
比如说我们一开始的时候

09:36.510 --> 09:38.210
盖个房子

09:38.210 --> 09:39.210
首先保证它是

09:39.210 --> 09:41.610
比如说在不高的情况下

09:41.610 --> 09:42.410
它可能会稳一点

09:42.410 --> 09:42.810
对不对

09:42.810 --> 09:45.010
晚上就可能会再去增加一些虚细

09:45.010 --> 09:47.810
就比如说它要能进入出一些风

09:47.810 --> 09:48.410
对吧

09:48.410 --> 09:51.210
比如说它这个里面要足够的人

09:51.210 --> 09:53.010
能容纳出很多人来的

09:53.010 --> 09:53.610
等等等等

09:53.610 --> 09:54.310
还要保暖

09:54.310 --> 09:55.810
如何如何如何

09:55.810 --> 09:56.310
那好了

09:56.310 --> 09:57.210
那比如说一开始

09:57.210 --> 09:58.610
我们在去盖楼的时候

09:58.610 --> 10:00.010
你当然很多东西你都不知道了

10:00.010 --> 10:01.610
所以说你很多时候都靠摸索

10:01.610 --> 10:02.210
对吧

10:02.210 --> 10:03.010
这是怎么盖啊

10:03.010 --> 10:04.210
你反复去试对吧

10:04.210 --> 10:05.210
这是盖完不行

10:05.210 --> 10:05.510
好了

10:05.510 --> 10:06.710
那我们换个方法它再来对吧

10:06.710 --> 10:07.410
这种话行了

10:07.410 --> 10:09.010
我们记下来对吧

10:09.010 --> 10:13.010
那那那比如说这个这个东西

10:13.010 --> 10:15.410
我们还会去进行这样的一个传递

10:15.410 --> 10:17.010
或者说是一个传承

10:17.010 --> 10:19.310
因为可能说我自己摸索完以后的话

10:19.310 --> 10:19.610
对吧

10:19.610 --> 10:19.710
好

10:19.710 --> 10:20.610
我盖完房了

10:20.610 --> 10:21.210
很自然

10:21.210 --> 10:22.010
那可能说很多人

10:22.010 --> 10:23.110
他都要去盖对不对

10:23.110 --> 10:25.010
那很多人都要去盖

10:25.010 --> 10:27.310
我我不能去一个月去帮他盖

10:27.310 --> 10:27.510
对吧

10:27.510 --> 10:28.210
怎么办呢

10:28.210 --> 10:29.610
你把这条经验分享出去

10:29.610 --> 10:30.910
那分享他出去以后的话

10:30.910 --> 10:32.610
他们也也都知道了啊

10:32.610 --> 10:33.810
我盖房子可能说

10:33.810 --> 10:35.010
比如说保暖的话

10:35.110 --> 10:36.910
他需要怎么去做对吧

10:36.910 --> 10:38.510
就比如说监控的话

10:38.510 --> 10:39.710
需要怎么去做对吧

10:39.710 --> 10:41.810
这个遮雨需要怎么去做啊

10:41.810 --> 10:43.110
那99只啊

10:43.110 --> 10:44.510
大家可能都知道这样

10:44.510 --> 10:45.810
这样一些事了啊

10:45.810 --> 10:47.710
那可能说一个这种简单的房子

10:47.710 --> 10:49.110
大家都会盖了啊

10:49.110 --> 10:49.810
而且能盖

10:49.810 --> 10:51.310
盖得还很溜对不对啊

10:51.310 --> 10:54.010
那什么随着这个需求越来越高的吧

10:54.010 --> 10:55.010
可能说是这个

10:55.010 --> 10:56.910
我们不想只限于这种盖家

10:56.910 --> 10:58.110
那个草房了

10:58.110 --> 10:59.910
可能要盖这个几层楼对吧

10:59.910 --> 11:01.410
就比如说盖一辆很层楼

11:01.410 --> 11:04.110
还要盖那种木质的结构的啊

11:04.110 --> 11:05.310
那这种情况下的话

11:05.310 --> 11:06.610
那以前的经验有没有用呢

11:06.610 --> 11:08.010
以前经验一定是有用的对吧

11:08.010 --> 11:09.110
因为以前经验的话

11:09.110 --> 11:11.710
可能放在这种复杂的需求上的话

11:11.710 --> 11:15.410
能节省你的时间啊

11:15.410 --> 11:18.410
能大大的去加快你盖这个

11:18.410 --> 11:19.610
更复杂的这个房子

11:19.610 --> 11:21.310
这样那个效率啊

11:21.310 --> 11:22.510
为什么这么说呢

11:24.510 --> 11:25.510
就是我们在

11:25.510 --> 11:27.110
其实我们在现实生活中的话

11:27.110 --> 11:29.110
有很多这样那个黑峡子

11:29.110 --> 11:30.310
有这种黑峡子什么意思

11:30.310 --> 11:32.810
就是技术当中那个黑峡子

11:32.810 --> 11:33.910
我现在可以跟你这么讲

11:33.910 --> 11:36.510
就是如果说你回到这样那个

11:36.510 --> 11:38.210
还是要回到这样那个

11:38.210 --> 11:39.510
比如说唐宋元清

11:39.510 --> 11:41.210
任何一个朝代都可以啊

11:41.210 --> 11:42.810
让你去做一部手机对吧

11:42.810 --> 11:43.910
你能做得出来吗

11:43.910 --> 11:44.610
你能做不出来

11:44.610 --> 11:44.910
因为什么

11:44.910 --> 11:46.810
因为手机这个东西太复杂了啊

11:46.810 --> 11:48.610
你需要去知道怎么去做塑料的吧

11:48.610 --> 11:50.010
怎么去做一些

11:50.010 --> 11:52.310
比如说怎么去提取一些这样那个金属啊

11:52.310 --> 11:53.910
你还要懂一些电路对吧

11:53.910 --> 11:56.410
你还要懂这个怎么来通信啊

11:56.410 --> 11:58.010
等等等等等等

11:58.010 --> 11:59.410
但如果说放到现在的话

11:59.410 --> 12:00.910
让你去造一个手机的话

12:00.910 --> 12:02.210
可不可以呢

12:02.210 --> 12:03.810
其实就完全没有那么难了

12:03.810 --> 12:06.410
比如说你想去自己做一个手机对吧

12:06.410 --> 12:08.610
你从哪从一些厂家对吧

12:08.610 --> 12:10.510
可以去定制一些壳子对吧

12:10.510 --> 12:12.410
从那去买一些主板对吧

12:12.410 --> 12:14.310
从那去买块平平对吧

12:14.310 --> 12:15.510
你看能平的平的

12:15.510 --> 12:16.110
ok

12:16.110 --> 12:18.110
你怎么把它给做成了啊

12:18.110 --> 12:19.210
那你可以理解成啊

12:19.210 --> 12:22.310
就是他是一个技术的黑峡子

12:22.310 --> 12:24.110
我们现在做一个手机

12:24.110 --> 12:26.710
再也不用从头去研究啊

12:26.710 --> 12:28.310
他到底要怎么来了啊

12:28.310 --> 12:30.810
而是我直接拿一些现成的经验

12:30.810 --> 12:32.710
或者说拿一些现成的人们

12:32.710 --> 12:35.410
就制作出来的这样的一个东西啊

12:35.410 --> 12:36.710
我们怎么拼装

12:36.710 --> 12:38.010
我们自己去利用对吧

12:38.010 --> 12:40.510
就能达成我们这样的那个目的啊

12:40.510 --> 12:41.710
那设计模式这边说了

12:41.710 --> 12:43.710
是一套反复使用多数人知晓

12:43.710 --> 12:46.410
经过分类的代码设计经验的总结

12:46.410 --> 12:50.510
那就一定是很多很多这样的一个程序员和开发者啊

12:50.510 --> 12:53.610
再面对这样的一个很多这种复杂的一个系统

12:53.610 --> 12:55.310
或者说复杂那个续续的情况下啊

12:55.310 --> 12:56.110
不断摸索

12:56.110 --> 12:57.810
不断总结出一些经验

12:57.810 --> 12:59.010
按照这些经验

12:59.010 --> 13:00.210
我们来做事的话

13:00.210 --> 13:01.910
指定是更高效的啊

13:02.010 --> 13:04.010
要说你开发起来的话

13:04.010 --> 13:05.010
比如说你在面

13:05.010 --> 13:07.010
它面对一些复杂的这个续续下的话

13:07.010 --> 13:08.910
我们用这个设计模式它来做的话

13:08.910 --> 13:11.010
一定能保持你整个系统啊

13:11.010 --> 13:12.710
更加的稳定啊

13:12.710 --> 13:15.110
更加的这样的一个高效啊

13:15.110 --> 13:15.810
当然呢

13:15.810 --> 13:19.510
这个比如说我们单独看某一块的时候的话

13:19.510 --> 13:22.310
我们去看这样的一个代码的一个质质量啊

13:22.310 --> 13:25.310
或者说一个复用性的它的偶和度对吧

13:25.310 --> 13:29.110
它的这样的一个复杂长度都是我们满意的

13:29.110 --> 13:30.410
那其实说这么多的话

13:30.410 --> 13:33.810
其实咱可以简单来说一下什么

13:33.810 --> 13:35.410
说一下就是设定模式

13:35.410 --> 13:39.210
其实它就是我们要去拿一些我们经常使用的

13:39.210 --> 13:41.810
这样一些套路去做一些事啊

13:41.810 --> 13:42.910
那这个套路的话

13:42.910 --> 13:44.810
其实嗯

13:44.810 --> 13:45.610
就是怎么说呢

13:45.610 --> 13:49.010
这些套路它都已经被钱总结好了啊

13:49.010 --> 13:50.810
我们拿了以后的话啊

13:50.810 --> 13:53.810
直接去使用它就ok了啊

13:53.810 --> 13:56.010
但其实与其说这个套路的话

13:56.010 --> 13:58.810
因为很多人他都会讲这个套路这个这个词啊

13:58.810 --> 14:02.010
因为嗯

14:02.010 --> 14:04.010
因为这里面有这样一个例子啊

14:04.010 --> 14:05.810
这个例子这个例子是什么呢

14:05.810 --> 14:09.210
就是比如说我们要举个这样一个算法

14:09.210 --> 14:11.010
那个另一个这样一个算法

14:11.010 --> 14:13.210
这样那个例子就是我们要算一加二的吧

14:13.210 --> 14:15.210
三加二等于三就是都会的吧

14:15.210 --> 14:16.610
你再算一加二加三

14:16.610 --> 14:18.410
比如说这种的六也都会的吧

14:18.410 --> 14:20.210
但你要算一加二加三加四加五

14:20.210 --> 14:22.010
一直加很多呢啊

14:22.010 --> 14:24.910
这你就我说我手算都算出来的吧啊

14:24.910 --> 14:26.610
但你算起来很麻烦

14:26.610 --> 14:28.610
但你要知道有个叫高四的大十的

14:28.610 --> 14:31.810
他在不断的去进行这样的一个总结

14:31.810 --> 14:33.810
对吧不断进行这样的一个推倒啊

14:33.810 --> 14:36.010
他最后发现出了一个公式

14:36.010 --> 14:37.410
发现出了这样的一个套路

14:37.410 --> 14:39.810
就是首相加莫相的吧啊

14:39.810 --> 14:41.410
称以相实出于二对不对

14:41.410 --> 14:44.410
这就是可以求出一加二加三加到N

14:44.410 --> 14:46.410
加到谁都可以啊

14:46.410 --> 14:49.610
他能轻松的去求出这样的一个结果

14:49.610 --> 14:51.810
你看我们如果说有这样一种套路

14:51.810 --> 14:52.610
去做事的话

14:52.610 --> 14:55.410
那往往一定是更高效更接受时间的

14:55.410 --> 14:57.210
而且他也相对来讲的话

14:57.210 --> 14:59.010
更稳定更不于出错

14:59.010 --> 15:00.610
比如说你一加二加到一千

15:00.610 --> 15:02.210
一加二加到三加到一千

15:02.210 --> 15:04.010
你手算的话

15:04.010 --> 15:05.010
加这么多相

15:05.010 --> 15:07.010
可能一定他会出错啊

15:07.010 --> 15:08.610
他出错概率可能会非常大吧

15:08.610 --> 15:10.410
他不能说你一定他会出错的吧

15:10.410 --> 15:12.210
出错概率一定会非常大

15:12.210 --> 15:13.610
他说你有了这个公式以后的话

15:13.610 --> 15:16.010
其实你算的这样一个东西并不多

15:16.010 --> 15:18.410
那最后这样的一个结果

15:18.410 --> 15:20.510
往往可能说是更准确一些

15:20.510 --> 15:21.910
那如果说我们拿一些套路啊

15:21.910 --> 15:23.510
在代码中去做一些事的话

15:23.510 --> 15:26.210
或者说在这样一个开发中去做一些事的话

15:26.210 --> 15:29.510
那一定这个效果也是大同小异的

15:29.510 --> 15:31.410
我们指定会更高效的吧

15:31.410 --> 15:36.110
让这个东西出错概率更小一些

15:36.110 --> 15:36.810
而且呢

15:36.810 --> 15:39.510
其实我刚才提到一些什么可扩展性啊

15:39.510 --> 15:42.210
可这样的一个比如说什么复杂长路啊

15:42.210 --> 15:44.510
这些东西咱们可能一会还会来说说啊

15:44.510 --> 15:45.610
这个扩展性可以理解

15:45.610 --> 15:48.010
比如说你比如说拿这个来讲嘛

15:48.010 --> 15:50.410
我现在算一加二加一加二吧

15:50.410 --> 15:53.010
一加二加三一加三加四对不对

15:53.010 --> 15:53.810
那比如说我要再加

15:53.810 --> 15:54.810
我要再加个学校

15:54.810 --> 15:57.810
比如说你加到五加到十对不对啊

15:57.810 --> 15:59.810
那即使加到一百的吧

15:59.810 --> 16:00.710
你加到一千的话

16:00.710 --> 16:01.710
我们只要有这个套路

16:01.710 --> 16:02.810
只要有这个公式的话

16:02.810 --> 16:05.010
都可以很好的帮你去挡出啊

16:05.010 --> 16:05.610
比如说这边

16:05.610 --> 16:07.110
其实有个设计模式的目的啊

16:07.110 --> 16:07.810
这个目的是什么呢

16:07.810 --> 16:08.810
这个目的就是

16:10.210 --> 16:12.010
为了代码的一个可重工性

16:12.010 --> 16:13.710
这边可以说是复用性啊

16:13.710 --> 16:16.010
就是你洗好这块代码啊

16:16.010 --> 16:19.510
这个代码我希望它能被重复用的程度

16:19.510 --> 16:21.110
好像尽可能能够高啊

16:21.110 --> 16:22.810
当然那如果说你这个整个项目中

16:22.810 --> 16:25.210
没有需求去重复利用它的话

16:25.210 --> 16:26.610
那么没有必要啊

16:26.610 --> 16:28.610
就是强行的去追求

16:28.610 --> 16:30.110
它一定要被重复使用啊

16:30.110 --> 16:31.910
但是如果你比如说

16:31.910 --> 16:32.810
呃

16:32.810 --> 16:33.810
比如说一个供控能

16:33.810 --> 16:35.910
比如说这个这个这个搜索功能

16:35.910 --> 16:37.410
可能说在一个一面里面

16:37.410 --> 16:38.710
很多地方都能上啊

16:38.710 --> 16:39.310
对吧啊

16:39.310 --> 16:41.110
那我们希望写一个这样那个函数

16:41.110 --> 16:43.410
或者写这样一个模块啊

16:43.410 --> 16:44.510
那呃

16:44.510 --> 16:45.410
他写完以后的话

16:45.410 --> 16:47.610
他可以很好的去实现

16:47.610 --> 16:50.610
任何一个地方这样的一个供控能啊

16:50.610 --> 16:53.610
或者说他在很多地方都能打到这样一个重用

16:53.610 --> 16:54.810
我们写代码的话

16:54.810 --> 16:57.410
也希望代码能打到这样一个重用性

16:57.410 --> 16:58.810
或者这样一个复用性啊

16:58.810 --> 17:01.610
那你不能说是这一个或者一个占点

17:01.610 --> 17:03.210
或者说一个这样那个页面

17:03.210 --> 17:05.310
很多地方都要到搜索了

17:05.310 --> 17:05.910
功能对吧

17:05.910 --> 17:07.410
那每个地方我都重写一遍

17:07.410 --> 17:08.410
都重写一遍啊

17:08.410 --> 17:10.110
这样很麻烦啊

17:10.110 --> 17:11.210
那当然呢

17:11.210 --> 17:12.810
有了这样那个设计模式以后

17:12.810 --> 17:13.910
其实我们还有这样一个目的

17:13.910 --> 17:16.810
这个目的就是让代码更容易被人理解啊

17:16.810 --> 17:18.310
这更容易被人理解的话

17:18.310 --> 17:19.910
我相信很多同学就不理解了

17:19.910 --> 17:25.110
因为我们比如说再不用设计模式来写代码的时候啊

17:25.110 --> 17:27.510
可能说写的方式啊

17:27.510 --> 17:30.810
这个自己在逻辑上更容易去接受

17:30.810 --> 17:32.410
但是用设计模式以后的话

17:32.410 --> 17:33.910
就是在真正路程代码中的话

17:33.910 --> 17:35.510
你会发现可能对他很绕

17:35.510 --> 17:37.410
比之前要麻烦一些啊

17:37.410 --> 17:40.510
为什么叫做更容易被人理解呢

17:40.510 --> 17:42.410
这个东西啊

17:42.410 --> 17:44.010
一会我再讲模式是什么时候啊

17:44.010 --> 17:46.310
我还要去去提一提啊

17:46.310 --> 17:48.210
因为他必须的跟

17:48.210 --> 17:49.010
我觉得啊

17:49.010 --> 17:51.210
就是他必须得跟咱现实生活中啊

17:51.210 --> 17:52.510
来一一对应

17:52.510 --> 17:53.710
否则我讲这么多的话

17:53.710 --> 17:56.510
我相信可能同学听完之后一脸懵逼啊

17:56.510 --> 17:58.210
其实这个更容易理解是什么意思

17:58.210 --> 18:00.910
就是咱们对这套规定

18:00.910 --> 18:04.410
或对这个套路都熟悉的以后的话啊

18:04.410 --> 18:06.510
那你这么来写的话啊

18:06.510 --> 18:09.710
那别人在看你这样的代码的话

18:09.710 --> 18:11.210
由于他也知道

18:11.210 --> 18:12.510
就是代码可以这么写的吧

18:12.510 --> 18:14.410
也知道这样那个套路的话

18:14.410 --> 18:16.610
那你哪都有这样的一个基础

18:16.610 --> 18:18.710
或者都有这样的一个意识的话

18:18.710 --> 18:20.610
那你来看这个东西的话

18:20.610 --> 18:21.410
那自然而然

18:21.410 --> 18:23.310
大家都心知肚明怎么一回事啊

18:23.310 --> 18:25.510
所以说这种更容易理解的话

18:25.510 --> 18:27.410
叫做被他人理解啊

18:27.410 --> 18:28.510
被他人也就是

18:28.510 --> 18:30.610
我们在进行这样一个写作开发的时候

18:30.610 --> 18:32.710
因为很多项目不可能你也写对不对

18:32.710 --> 18:34.210
你也写淘宝你可能吗

18:34.210 --> 18:36.110
啊那淘宝好多人一起去开发对不对

18:36.110 --> 18:37.010
你工那么多

18:37.010 --> 18:38.310
你写不完的啊

18:38.310 --> 18:39.910
那我在写的过程的话好了

18:39.910 --> 18:41.910
那比如说我我写了一段以后的话

18:41.910 --> 18:42.910
我要给别人用对不对

18:42.910 --> 18:45.310
或者说别人写完以后给我用啊

18:45.310 --> 18:46.910
那无论怎么样情况下的话

18:46.910 --> 18:49.410
那如果说保证带码的一个可读性

18:49.410 --> 18:50.310
更高情况下的话

18:50.310 --> 18:52.210
对整体的开发进度

18:52.210 --> 18:53.810
或开发的效率来讲的话

18:53.810 --> 18:54.810
也是更好的

18:54.810 --> 18:56.510
就是使用设计模式这个目的啊

18:56.510 --> 18:57.810
还有这一块啊

18:57.810 --> 18:59.710
当然保证带码的可靠性

18:59.710 --> 19:01.310
他也是

19:01.310 --> 19:02.910
怎么说他也是一个啊

19:02.910 --> 19:03.910
注重之重一个点嘛

19:03.910 --> 19:05.610
因为你这个项目做完以后的话

19:05.610 --> 19:07.910
啊我当然希望他运行的更稳定一些

19:07.910 --> 19:09.210
对吧别动不动就出错啊

19:09.210 --> 19:10.410
就很麻烦啊

19:10.410 --> 19:12.310
比如说正常运行的时候啊

19:12.310 --> 19:13.010
你不出错了

19:13.010 --> 19:15.110
我可能说叠带的时候加功能

19:15.110 --> 19:16.710
你出错了也很麻烦

19:16.710 --> 19:19.410
对吧说他保证带码的可靠性

19:19.410 --> 19:22.910
那设计模式是使用带码编写真正

19:22.910 --> 19:25.410
就是怎么怎么怎么说

19:25.410 --> 19:27.310
就是设计模式这个东西以后的话

19:27.310 --> 19:28.210
你用它以后的话

19:28.210 --> 19:29.610
它可以写你带码

19:29.610 --> 19:32.410
呃或者说再开发这样一个程序的话

19:32.410 --> 19:35.110
或者说再开发这样一个程序的时候

19:35.110 --> 19:36.510
能让你做这件事

19:36.510 --> 19:38.510
真正的像做一个工程一样啊

19:38.510 --> 19:40.610
真正跟他工程的话

19:40.610 --> 19:43.010
那设计模式是软件工程的即时脉络

19:43.510 --> 19:45.410
这个如同大厦结构一样

19:45.410 --> 19:46.510
其实这个东西

19:47.810 --> 19:48.410
怎么说呢

19:49.710 --> 19:50.810
是离业起来的话

19:50.810 --> 19:53.210
就是无非的就是就是

19:53.210 --> 19:54.710
我们在做一些

19:54.710 --> 19:57.310
不是我们在做开做一个该房子的事的话

19:57.310 --> 19:57.810
对吧

19:57.810 --> 19:59.710
那它只是在做一个工程

19:59.710 --> 20:01.210
那里面只能有很多

20:01.210 --> 20:03.610
比如说关于土木建筑的这样一些方式

20:03.610 --> 20:04.910
方法套路对吧

20:04.910 --> 20:07.310
那对我们这种软件工程来讲的话

20:07.310 --> 20:10.910
我们设计模式就是它这样一个方法的一个套

20:10.910 --> 20:14.210
一个就是一个你进行这样的一个开开发的一个基本的

20:14.210 --> 20:15.410
一个套路

20:15.410 --> 20:18.210
你要做出一个稳定的一个软件

20:18.210 --> 20:18.510
对吧

20:18.510 --> 20:20.810
你要做出稳定这样的一个站点啊

20:20.810 --> 20:21.910
或系统对吧

20:21.910 --> 20:23.510
你都得需要它

20:23.510 --> 20:25.510
你都得需要它这样的那个思想

20:25.510 --> 20:28.110
作为你整个开发的一个即时

20:29.810 --> 20:31.010
那这个说法也方法

20:31.010 --> 20:32.310
咱们再来看一下模式是什么

20:32.310 --> 20:32.610
对吧

20:32.610 --> 20:34.610
设计模式里面设计这个东西

20:34.610 --> 20:37.010
我相信很多同学都能从四卖一次

20:37.010 --> 20:38.610
知道怎么会对吧

20:38.610 --> 20:40.810
那模式这个东东西是啥呢

20:40.810 --> 20:42.310
先模式在我来看的话就是

20:44.510 --> 20:47.010
从生产经验和生活经验中

20:47.010 --> 20:51.010
经过抽象和生活体验出来的核心只是体系

20:51.010 --> 20:53.010
其实就是我的总结就是

20:53.010 --> 20:54.910
其实它就是一套方法论

20:54.910 --> 20:59.110
解决一类或者说一大类问题的一个方法论

20:59.110 --> 21:01.810
我们按照这种方式方法来做的话

21:01.810 --> 21:05.710
就可以很好地去解决这一些的一个问题

21:05.710 --> 21:08.910
那现在其实我可以继续再往下讲

21:08.910 --> 21:11.910
但我觉得我必须我必须得说一件事

21:11.910 --> 21:13.610
必须得说一件事

21:13.610 --> 21:16.610
因为我们讲事情模式离不开那个原则

21:16.610 --> 21:18.910
原则有时候有什么有人说不大原则

21:18.910 --> 21:22.210
说六大原则最终这个东西一样

21:22.210 --> 21:24.010
但模式有很多种

21:24.010 --> 21:31.010
这个如果说拿原则和模式来去比喻现实生活中的话

21:31.010 --> 21:35.210
那其实它这件事有一定的这样的一个关联性的

21:35.210 --> 21:36.810
那比喻现实生活中的话

21:36.810 --> 21:41.210
我可以拿一个怎么说的

21:41.210 --> 21:44.210
拿一个我们人人都知道的这样的一个例子

21:44.210 --> 21:47.210
或者人人都知道的这样的一个事来去讲讲

21:47.210 --> 21:49.310
没有拿后面的这个技术点去讲

21:49.310 --> 21:50.510
这个你不懂的技术的话

21:50.510 --> 21:52.110
我觉得你很难去理解

21:52.110 --> 21:54.510
但我拿现实生活中的这样的一个事

21:54.510 --> 21:56.010
去映射到这样一个

21:56.010 --> 21:57.610
就是说开发这种的话

21:57.610 --> 22:01.510
我觉得你应该能够想象出来

22:01.510 --> 22:03.510
它大概是怎么一回事

22:03.610 --> 22:04.810
ok 那现在啊

22:04.810 --> 22:06.910
现在我可以在这边简单给你先写一下

22:06.910 --> 22:09.910
给你写一下

22:09.910 --> 22:11.110
我们这个课

22:11.110 --> 22:12.910
大家是叫设计的同学是这个课

22:12.910 --> 22:14.310
当我们讲这个课的时候

22:14.310 --> 22:17.210
还需要提到这个原则

22:17.210 --> 22:18.610
原则这个词是什么意思啊

22:18.610 --> 22:18.910
对吧

22:18.910 --> 22:21.110
我们说做事要有原则

22:21.110 --> 22:22.810
对 最近也看了一本书

22:22.810 --> 22:25.310
这本书就叫做原则

22:25.310 --> 22:26.510
你有兴趣的话

22:26.510 --> 22:27.610
你可以去看一看

22:27.610 --> 22:31.610
里面交给你很多做人或者说做事

22:31.610 --> 22:34.810
你应该怎么去做这种

22:34.810 --> 22:36.110
在我看来的话

22:36.110 --> 22:39.710
它是塑造你这样一个

22:39.710 --> 22:42.410
比较好的意识的一本书

22:42.410 --> 22:44.910
它并不说是直接的去告诉你

22:44.910 --> 22:47.010
具体的某些事你该怎么干

22:47.010 --> 22:49.410
但是它给你提供了一套理论

22:49.410 --> 22:55.820
那我们这个讲设计模式这个概要提到这个原则

22:55.820 --> 22:58.820
这个原则其实它就是一个理论

22:58.820 --> 23:01.520
那我们这个设计模式

23:01.520 --> 23:06.320
其实就是在这个理论之下的一些具体的套路和方法

23:06.320 --> 23:08.620
那把它比较现实生活中的话

23:08.620 --> 23:10.620
你给这么想

23:10.620 --> 23:12.720
我们软件你会发现

23:12.720 --> 23:15.220
如果是面向对向的编程的话

23:15.220 --> 23:17.720
为什么要提面向对向的编程呢

23:17.720 --> 23:19.420
因为设计模式这个概念

23:19.420 --> 23:20.520
一开始的时候

23:20.520 --> 23:22.420
它并不是载前端

23:22.420 --> 23:25.420
它并不是载前端去提出来的

23:25.420 --> 23:27.520
因为前端一开始的需求没有那么复杂

23:27.520 --> 23:31.220
它是在后台去进行这样的一个演变出来的

23:31.220 --> 23:32.620
那后台开发你会知道

23:32.620 --> 23:34.620
比如说C和C++对吧

23:34.620 --> 23:36.020
或者说java对吧

23:36.020 --> 23:38.420
不是C++和java

23:38.420 --> 23:41.420
这都是面向对向变成那个语言

23:41.420 --> 23:43.020
那当然我们这个GS

23:43.020 --> 23:44.420
它好像学ES的时候

23:44.420 --> 23:46.420
你会感觉它可以面向对象

23:46.420 --> 23:48.620
它本质还是基于对象

23:48.620 --> 23:50.020
只不过在这个新规范中

23:50.020 --> 23:52.420
想把它往这个面向对象去靠拢

23:52.420 --> 23:54.620
但其实我们GS它真没有办法

23:54.620 --> 23:58.620
特别好的迎合设计模式

23:58.620 --> 24:00.020
但是呢

24:00.020 --> 24:01.420
设计模式是你们一些思想

24:01.420 --> 24:04.020
也确确实实的部分

24:04.020 --> 24:06.220
是可以用到前端的之中的

24:06.220 --> 24:07.620
就是我们也需要去讲一讲

24:07.620 --> 24:09.420
然后去提一提

24:09.420 --> 24:11.020
那我们知道这个设计模式

24:11.020 --> 24:12.820
从后台演变过来的

24:12.820 --> 24:15.620
后台还是一种面向对象的一种变成方式

24:15.620 --> 24:17.420
那在软件开发功能中的话

24:17.420 --> 24:20.420
或者说在一个这样的一个成绩开发功能中的话

24:20.420 --> 24:23.220
我们会碰到很多个对象对吧

24:23.220 --> 24:28.220
那有的时候我们再去组织一些对象之间的一个关系

24:28.220 --> 24:31.220
或者说他们一些这个去限定他们一些行为

24:31.220 --> 24:34.220
包括如何去创建这样的一些对象

24:34.220 --> 24:37.620
是我们往往要考虑的这样的一个很重要的一个问题

24:37.620 --> 24:40.220
当你把这个对象如何创建

24:40.220 --> 24:41.820
他们关系是怎么样的对吧

24:41.820 --> 24:42.820
他们行为什么样

24:42.820 --> 24:43.820
都给的协调好

24:43.820 --> 24:45.020
树立好以后

24:45.020 --> 24:46.220
那你自然而这个系统

24:46.220 --> 24:48.820
可能跑得会更稳定一些

24:48.820 --> 24:49.420
ok

24:49.420 --> 24:53.020
那你可以把这个咱们人类的社会

24:53.020 --> 24:54.620
想成一个大机器

24:54.620 --> 24:56.020
有时候想成一个大机器

24:56.820 --> 24:58.820
其实这个社会他就是把人管理好

24:58.820 --> 24:59.820
他就ok对吧

24:59.820 --> 25:02.020
那人当然人有人的行为对不对

25:02.020 --> 25:03.020
人也会怎么样

25:03.020 --> 25:05.220
比创建出来也会出生对不对

25:05.220 --> 25:07.620
还有就是这个人和人之间

25:07.620 --> 25:09.220
那有千丝万里和复杂

25:09.220 --> 25:11.020
这样一些关系对不对

25:11.020 --> 25:14.420
那当然你把这样的一些就是

25:14.420 --> 25:16.020
你把你把你把这样的一个人

25:16.020 --> 25:18.020
比如说出生的事对吧

25:18.020 --> 25:20.420
或者说是他们彼此之间

25:20.420 --> 25:21.420
这样的一个关系

25:21.420 --> 25:23.420
包括人类这样的一个行为的事

25:23.420 --> 25:24.420
都管理好

25:24.420 --> 25:29.420
这个社会他也自然而会稳定一些

25:29.420 --> 25:31.420
那这一块我想来提一提

25:31.420 --> 25:32.620
我想来提一提

25:32.620 --> 25:33.420
提一提什么呢

25:33.420 --> 25:35.420
有本书

25:35.420 --> 25:43.910
叫就是叫做菊语刀

25:43.910 --> 25:44.910
这不是技术

25:44.910 --> 25:46.110
叫菊语刀

25:46.110 --> 25:49.310
它是讲日本的一个文化的

25:49.310 --> 25:50.910
讲日本二战之前的一个文化

25:50.910 --> 25:53.310
其实它就是一个调查报告

25:53.310 --> 25:57.510
是这个叫做着名

25:57.510 --> 26:00.510
我都忘了是一个女的一个社会学家

26:00.510 --> 26:02.110
而是这个在这个

26:02.110 --> 26:03.510
美国的日本战斧以后

26:03.510 --> 26:06.310
去调查了好几百个这个日本的一个战斧

26:06.310 --> 26:08.310
去总结出来这个日本人

26:08.310 --> 26:11.110
他当时的这样的一个社会的一个形态机

26:11.110 --> 26:12.010
他们这样的一个

26:12.010 --> 26:14.310
比如说伦理刀的观念

26:14.310 --> 26:15.910
今天我又看了一本书

26:15.910 --> 26:18.510
这个菊语刀我去年看了两遍

26:18.510 --> 26:22.110
今天又看一本书叫做归训于惩罚

26:22.110 --> 26:25.110
这个东西我还没看完

26:25.110 --> 26:26.110
最近刚开始看

26:26.110 --> 26:28.110
它是一个关于哲学的时候

26:28.110 --> 26:29.710
关于哲学的时候

26:29.710 --> 26:31.110
我也建议你们看一看

26:31.110 --> 26:31.710
因为什么呢

26:31.710 --> 26:32.910
因为事情模式这个东西

26:32.910 --> 26:34.110
最后你想用好的话

26:34.110 --> 26:37.310
它还是回忆到这样的一个哲学

26:37.310 --> 26:38.710
你会觉得它很怪

26:38.710 --> 26:40.910
跟哲学有什么关系呢

26:40.910 --> 26:42.510
最后其实

26:42.510 --> 26:44.710
因为哲学这个东西

26:44.710 --> 26:47.910
往往是一种一个词叫做平衡

26:47.910 --> 26:49.310
或者叫全衡

26:53.110 --> 26:56.510
这个我可能会讲到最后的时候

26:56.510 --> 26:58.310
你会发现

26:58.310 --> 26:59.910
全衡这个东西

26:59.910 --> 27:01.910
对我们这样的一个开发

27:01.910 --> 27:03.910
或者说对我们这样的一个

27:03.910 --> 27:05.910
就是在技术方面

27:05.910 --> 27:08.310
自身价值的一个印证

27:08.310 --> 27:10.310
是很重要的一步

27:10.310 --> 27:12.710
是你很重要的这样的一个能力

27:12.710 --> 27:13.910
那这本书

27:13.910 --> 27:15.310
这本书其实

27:15.310 --> 27:17.110
他也讲了这样的一个

27:17.110 --> 27:18.510
就是讲了一个理

27:18.510 --> 27:19.310
这个理是什么呢

27:19.310 --> 27:21.910
就是法律

27:22.910 --> 27:25.910
其实并不是能

27:25.910 --> 27:28.910
就是这个法律并不是能

27:28.910 --> 27:33.910
就是很好的去规范这个社会

27:33.910 --> 27:36.910
或者说是法律

27:36.910 --> 27:39.910
它一定不是对人约束

27:39.910 --> 27:41.910
最强有力的一个手段

27:41.910 --> 27:42.910
那好了

27:42.910 --> 27:44.910
结合我提到的这本书

27:44.910 --> 27:46.910
他所讲的这样一个意思

27:46.910 --> 27:47.910
我想说什么呢

27:47.910 --> 27:48.910
我想说一个事

27:48.910 --> 27:51.910
就是这本书可以先提个问

27:51.910 --> 27:57.910
你觉得对人来说

27:57.910 --> 28:00.910
最棒的约束力是什么

28:00.910 --> 28:04.410
这一课好像是世界模式的课

28:04.410 --> 28:05.410
代码的课对吧

28:05.410 --> 28:07.410
你怎么讲到这呢对吧

28:07.410 --> 28:09.410
但这个东西确实对我后面

28:09.410 --> 28:10.410
讲的这个东西是有用的

28:10.410 --> 28:12.410
而且对你们理解原则和世界模式

28:12.410 --> 28:13.410
也是有用的

28:13.410 --> 28:15.410
所以在这本书我想提个问

28:15.410 --> 28:16.410
去提个问

28:17.410 --> 28:20.410
你觉得对人最大的约束

28:20.410 --> 28:21.410
它是什么

28:21.410 --> 28:26.350
钱

28:26.350 --> 28:27.350
你好物质

28:28.350 --> 28:30.350
是贫穷现身的想象力

28:30.350 --> 28:31.350
在这个社会上

28:31.350 --> 28:33.350
对人最大的约束力

28:33.350 --> 28:34.350
它是什么

28:37.350 --> 28:39.350
法律因为我已经提提了

28:39.350 --> 28:40.350
法律不是

28:40.350 --> 28:41.350
法律是底线

28:41.350 --> 28:42.350
法律底线

28:42.350 --> 28:43.350
你约了法律以后

28:43.350 --> 28:45.350
你就要进监狱了

28:45.350 --> 28:48.350
就像程序

28:49.350 --> 28:50.350
他出错了

28:50.350 --> 28:52.350
那他就相当于出犯法律了

28:52.350 --> 28:53.350
对吧

28:53.350 --> 28:54.350
那就运行不了了

28:54.350 --> 28:56.350
那指定啊指定不是啥

28:56.350 --> 28:57.350
指定不是

28:58.350 --> 29:00.350
指定不是这样一个法律

29:00.350 --> 29:01.350
而啥

29:01.350 --> 29:02.350
而是

29:02.350 --> 29:04.350
就是这种伦理道德

29:04.350 --> 29:06.350
你这样一个文化属性方

29:06.350 --> 29:10.350
对你这种思想的一个约束

29:10.350 --> 29:12.350
所以说

29:12.350 --> 29:14.350
从我们每个人生活在这个社会之中

29:14.350 --> 29:16.350
或者说生活在这样一个

29:18.350 --> 29:20.350
就是文明之中吧

29:20.350 --> 29:22.350
就是这个

29:22.350 --> 29:25.350
我们都会受受一种规讯

29:25.350 --> 29:26.350
或者说一种这样一个

29:26.350 --> 29:29.350
软静的无形的一种约束力

29:29.350 --> 29:31.350
这个约束力呢

29:31.350 --> 29:33.350
就会去限定那些行为

29:33.350 --> 29:34.350
所以说我想说一句话

29:34.350 --> 29:36.350
就是咱们可能说

29:36.350 --> 29:38.350
有人说肉体是灵魂的牢笼

29:38.350 --> 29:39.350
到我来看的话

29:39.350 --> 29:41.350
其实灵魂是肉体的一个牢笼

29:41.350 --> 29:42.350
你们的思想对吧

29:42.350 --> 29:44.350
来牢笼去束缚你

29:44.350 --> 29:46.350
那我们知道

29:46.350 --> 29:47.350
在我们中国社会

29:47.350 --> 29:49.350
其实讲究什么讲究的是

29:49.350 --> 29:51.350
比如说这个儒家文化

29:51.350 --> 29:53.350
什么人意理智信对不对

29:53.350 --> 29:54.350
什么人意理智信对吧

29:54.350 --> 29:56.350
我们也可以管他

29:56.350 --> 29:59.350
就是我说的不一定对啊

29:59.350 --> 30:01.350
就是人意理智信

30:01.350 --> 30:04.350
人意理智信

30:04.350 --> 30:06.350
那这也是我们

30:06.350 --> 30:08.350
就是这个

30:08.350 --> 30:09.350
我们中国人吧对吧

30:09.350 --> 30:10.350
都认可那个什么

30:10.350 --> 30:15.880
叫伦理道德对吧

30:15.880 --> 30:17.880
这个东西对吧

30:17.880 --> 30:19.880
对咱们往往其实有很大的一个

30:19.880 --> 30:21.880
思想上的一个约束

30:21.880 --> 30:23.880
你看我们都知道

30:23.880 --> 30:25.880
如果说你的这个人

30:25.880 --> 30:27.880
就是非常好

30:27.880 --> 30:28.880
人家交朋友

30:28.880 --> 30:30.880
或者那个人家相处下去的话

30:30.880 --> 30:31.880
那他指定在这里面

30:31.880 --> 30:32.880
会站他几条的吧

30:32.880 --> 30:33.880
你勾一一起对吧

30:33.880 --> 30:34.880
你人意对不对

30:34.880 --> 30:36.880
你传信对吧

30:36.880 --> 30:37.880
那当然我们整个这样的

30:37.880 --> 30:38.880
师父的文化

30:38.880 --> 30:39.880
也鼓励

30:39.880 --> 30:40.880
或说无形中对吧

30:40.880 --> 30:42.880
让你往这个方向去

30:42.880 --> 30:43.880
去走

30:43.880 --> 30:45.880
叫人意理智信对吧

30:45.880 --> 30:46.880
那

30:46.880 --> 30:47.880
在我看来

30:47.880 --> 30:48.880
在我看来

30:48.880 --> 30:51.880
这个我们设计模式的原则

30:51.880 --> 30:53.880
就等同于

30:53.880 --> 30:55.880
这种伦理道德

30:55.880 --> 31:00.250
那原则就等于伦理道德

31:00.250 --> 31:04.250
那法律呢

31:04.250 --> 31:07.270
就说

31:07.270 --> 31:08.270
法律呢

31:08.270 --> 31:10.270
等同于我们程序中的啥

31:10.270 --> 31:11.270
就是

31:11.270 --> 31:13.270
你可以理解一下对吧

31:13.270 --> 31:15.270
触碰bug的d线对吧

31:15.270 --> 31:17.270
有时候你触犯法律了

31:17.270 --> 31:18.270
你就出错了对不对

31:18.270 --> 31:20.270
那我们这个人意理智信呢

31:20.270 --> 31:21.270
相当于

31:21.270 --> 31:23.270
比如说我们这样的一个原则

31:23.270 --> 31:25.270
我们设计模式中

31:25.270 --> 31:27.270
这个设计限定

31:27.270 --> 31:29.270
设计模式用的一个原则

31:29.270 --> 31:31.270
那具体的设计模式是什么呢

31:31.270 --> 31:33.270
你可以理解成是

31:33.270 --> 31:35.270
伦理道德具体所

31:35.270 --> 31:36.270
硬设的一些事

31:36.270 --> 31:38.270
比如说

31:38.270 --> 31:39.270
我们

31:39.270 --> 31:42.270
就是卖东西

31:42.270 --> 31:43.270
对吧

31:43.270 --> 31:46.900
就是我们卖菜吧对吧

31:46.900 --> 31:47.900
不能怎么样

31:47.900 --> 31:48.900
不能

31:48.900 --> 31:50.900
这个缺筋少量

31:50.900 --> 31:51.900
对吧

31:51.900 --> 31:52.900
这样你怎么样

31:52.900 --> 31:53.900
这样你不诚信

31:53.900 --> 31:54.900
所以我们要

31:54.900 --> 31:55.900
诚实

31:55.900 --> 31:56.900
守信

31:56.900 --> 31:57.900
对吧

31:57.900 --> 31:58.900
再比如说

31:58.900 --> 31:59.900
你应该

31:59.900 --> 32:01.900
在公交车上对吧

32:01.900 --> 32:02.900
在公交车上

32:02.900 --> 32:07.130
主动

32:07.130 --> 32:08.130
让坐

32:08.130 --> 32:09.130
要什么

32:09.130 --> 32:11.130
你要遵老挨诱

32:13.130 --> 32:14.130
再比如说对吧

32:14.130 --> 32:15.130
你不能

32:15.130 --> 32:16.130
你不能

32:16.130 --> 32:18.130
站在

32:18.130 --> 32:20.130
大街街上对吧

32:20.130 --> 32:22.130
或者说你站在

32:22.130 --> 32:24.130
或者说你站在一些公共

32:24.130 --> 32:25.130
场所中对吧

32:25.130 --> 32:27.130
你破口大骂对不对

32:27.130 --> 32:29.130
你不能这样对吧

32:29.130 --> 32:30.130
应该比如说

32:30.130 --> 32:33.130
知书打理

32:33.130 --> 32:35.130
那这些东西

32:35.130 --> 32:38.130
你都可以理解成是设计模式

32:38.130 --> 32:39.130
设计模式

32:39.130 --> 32:40.130
实际上是这个原则

32:40.130 --> 32:41.130
这种理论

32:41.130 --> 32:43.130
所具体化来

32:43.130 --> 32:44.130
这些套路

32:44.130 --> 32:45.130
和一种

32:45.130 --> 32:47.130
做事的具体的方式

32:47.130 --> 32:48.130
我这么说

32:48.130 --> 32:49.130
同学是能懂吧

32:49.130 --> 32:51.130
能懂原则跟实际模式之间的关系

32:51.130 --> 32:53.130
它是啥了吧

32:53.130 --> 32:54.130
说

32:54.130 --> 32:56.130
原则可以练成是

32:56.130 --> 32:58.130
这样的一个人意理智性对吧

32:58.130 --> 32:59.130
我们去建议

32:59.130 --> 33:00.130
你要这样对不对

33:00.130 --> 33:01.130
我们在这样的一个

33:01.130 --> 33:02.130
原则的下来对吧

33:02.130 --> 33:03.130
我们有这些东西

33:03.130 --> 33:05.130
具体的一个实现对吧

33:05.130 --> 33:07.130
那这叫设计模式

33:07.130 --> 33:09.130
能懂吗同学

33:09.130 --> 33:10.130
这个还不用

33:10.130 --> 33:11.130
这个不用想吧

33:11.130 --> 33:12.130
这个

33:12.130 --> 33:14.130
给个回应同学

33:14.130 --> 33:18.810
给个回应

33:18.810 --> 33:19.810
都睡着了

33:25.700 --> 33:27.700
好像走出片场了

33:27.700 --> 33:28.700
能懂对吧

33:28.700 --> 33:29.700
OK

33:29.700 --> 33:30.700
能懂的话

33:30.700 --> 33:31.700
这个

33:31.700 --> 33:33.700
其实就是

33:33.700 --> 33:35.700
你想想对吧

33:35.700 --> 33:36.700
这个东西对你来讲

33:36.700 --> 33:37.700
重不重要

33:37.700 --> 33:38.700
咱就想想

33:38.700 --> 33:39.700
这东西对咱重不重要

33:39.700 --> 33:41.700
对咱实现是重不重对吧

33:41.700 --> 33:43.700
你想就人意理智性对吧

33:43.700 --> 33:45.700
那你想想

33:45.700 --> 33:46.700
那你是不是

33:46.700 --> 33:47.700
你身边

33:47.700 --> 33:49.700
就有很多好的朋友

33:49.700 --> 33:50.700
那可能这机会

33:50.700 --> 33:51.700
会更多的像

33:51.700 --> 33:52.700
你就靠了我们一些

33:52.700 --> 33:53.700
其实我们

33:53.700 --> 33:54.700
去提到一些

33:54.700 --> 33:56.700
大公司的一个老板

33:56.700 --> 33:57.700
我们

33:57.700 --> 33:58.700
就是你不用管

33:58.700 --> 33:59.700
外界怎么来看

33:59.700 --> 34:01.700
但至少他身边的人

34:01.700 --> 34:02.700
他能接受到

34:02.700 --> 34:03.700
能跟他勤

34:03.700 --> 34:04.700
接受的一些人

34:04.700 --> 34:05.700
对他的评价一定是

34:05.700 --> 34:06.700
他指定

34:06.700 --> 34:07.700
比如说

34:07.700 --> 34:08.700
高意思对吧

34:08.700 --> 34:09.700
或者他会

34:09.700 --> 34:10.700
他会为人

34:10.700 --> 34:11.700
对不对

34:11.700 --> 34:12.700
他说他会为人的话

34:12.700 --> 34:13.700
那指定怎么样

34:13.700 --> 34:14.700
是符合咱们这样的

34:14.700 --> 34:15.700
传统的一个

34:15.700 --> 34:16.700
倫理道德

34:16.700 --> 34:17.700
这种做法的

34:17.700 --> 34:19.700
否则他上进天两的话

34:19.700 --> 34:20.700
他身边的人

34:20.700 --> 34:21.700
只能不可能

34:21.700 --> 34:22.700
跟他在一块

34:22.700 --> 34:23.700
所以说

34:23.700 --> 34:24.700
原则

34:24.700 --> 34:25.700
什么时候呢

34:25.700 --> 34:26.700
原则

34:26.700 --> 34:27.700
他就是这样一个

34:27.700 --> 34:28.700
倫理道德

34:28.700 --> 34:30.700
他更偏向于理论的话

34:30.700 --> 34:31.700
他建议你要这么做

34:31.700 --> 34:32.700
对吧

34:32.700 --> 34:33.700
但是你模式是对他

34:33.700 --> 34:35.700
这样一个具体的一个实现

34:35.700 --> 34:37.700
但有的时候的话

34:37.700 --> 34:38.700
就是你会说

34:38.700 --> 34:39.700
那我要不要去

34:39.700 --> 34:40.700
这个

34:40.700 --> 34:41.700
具体实现这个

34:41.700 --> 34:43.700
原则呢

34:43.700 --> 34:44.700
当然你用的这些

34:44.700 --> 34:45.700
设计模式

34:45.700 --> 34:46.700
他都是怎么样

34:46.700 --> 34:47.700
去帮你实现

34:47.700 --> 34:48.700
这些原则

34:48.700 --> 34:49.700
但你有的时候

34:49.700 --> 34:50.700
可能说不用设计

34:50.700 --> 34:52.700
模式来去做的话

34:52.700 --> 34:53.700
可能也会怎么样

34:53.700 --> 34:54.700
也会去

34:55.700 --> 34:56.700
在某些程度上

34:56.700 --> 34:58.700
是符合这种原则的

34:59.700 --> 35:00.700
你就不用说

35:02.700 --> 35:03.700
你比如说我骗个人

35:03.700 --> 35:04.700
对吧

35:05.700 --> 35:06.700
骗人对不对

35:06.700 --> 35:07.700
骗人

35:07.700 --> 35:08.700
但是呢

35:08.700 --> 35:10.700
我是善意的谎言

35:10.700 --> 35:11.700
可能这个人

35:11.700 --> 35:12.700
快要死了对吧

35:12.700 --> 35:13.700
但是我不想给他

35:13.700 --> 35:14.700
死之前

35:14.700 --> 35:15.700
一个很大的这样的

35:15.700 --> 35:16.700
压力

35:16.700 --> 35:17.700
想让他再快点

35:17.700 --> 35:18.700
能活点时间对不对

35:18.700 --> 35:19.700
那怎么办呢

35:19.700 --> 35:21.700
我发出一个善意的谎言

35:21.700 --> 35:22.700
对吧

35:22.700 --> 35:23.700
那他在一定的程度上

35:23.700 --> 35:25.700
其实是符合原则的

35:25.700 --> 35:26.700
但确实

35:26.700 --> 35:27.700
比如说我们在这个

35:27.700 --> 35:28.700
设计模式中

35:28.700 --> 35:29.700
或者说

35:29.700 --> 35:30.700
我们在这样一个

35:30.700 --> 35:31.700
具体的一个

35:31.700 --> 35:33.700
这种对伦理道德

35:33.700 --> 35:35.700
实际化的一个操作之中

35:35.700 --> 35:36.700
可能没有讲到

35:36.700 --> 35:38.700
有什么善意的谎言

35:39.700 --> 35:40.700
说这一块的话

35:40.700 --> 35:42.700
你先明白这两个关系是什么

35:42.700 --> 35:43.700
它是理论基础

35:43.700 --> 35:45.700
它是一个具体的一个实现

35:45.700 --> 35:46.700
OK

35:46.700 --> 35:47.700
那对于它

35:47.700 --> 35:48.700
咱理解了以后的话

35:48.700 --> 35:49.700
咱接下来再往下来说

35:49.700 --> 35:50.700
再再往下来说

35:50.700 --> 35:52.700
实际我一往看下来说的话

35:52.700 --> 35:53.700
当然你对它的理解

35:53.700 --> 35:54.700
我相信应该是越多的

35:54.700 --> 35:56.700
那这边咱总

35:56.700 --> 35:57.700
总建一下对吧

35:57.700 --> 35:58.700
这个你可以来读一读吧

35:58.700 --> 35:59.700
就是没有这个

35:59.700 --> 36:00.700
设计模式

36:00.700 --> 36:01.700
我没有套路来做一些事的话

36:01.700 --> 36:03.700
当然没有效率对吧

36:03.700 --> 36:04.700
很笨拙

36:04.700 --> 36:05.700
成功性小吧

36:05.700 --> 36:06.700
分工性小对吧

36:06.700 --> 36:07.700
比如说

36:07.700 --> 36:09.700
复杂成功高

36:09.700 --> 36:10.700
偶和度很抬高

36:10.700 --> 36:11.700
那有的套路他做事的话

36:11.700 --> 36:12.700
可能很多问题都

36:12.700 --> 36:14.700
也是他人借了

36:14.700 --> 36:15.700
那这边的话

36:15.700 --> 36:17.700
有同学如果说

36:17.700 --> 36:18.700
想办了

36:18.700 --> 36:19.700
我能不能看一些书

36:19.700 --> 36:20.700
对吧

36:20.700 --> 36:21.700
那我跟你说书里面

36:21.700 --> 36:22.700
很多东西是

36:22.700 --> 36:24.700
不像我讲这么细的

36:24.700 --> 36:25.700
他可能就讲一下

36:25.700 --> 36:26.700
电码怎么来实现

36:26.700 --> 36:27.700
具体怎么一回事

36:27.700 --> 36:28.700
什么关系来怎么用的话

36:28.700 --> 36:29.700
可能

36:29.700 --> 36:30.700
并不会讲那么好

36:30.700 --> 36:31.700
当然如果说

36:31.700 --> 36:32.700
你想看书的话

36:32.700 --> 36:33.700
可以推荐你看一下

36:33.700 --> 36:34.700
比如说

36:34.700 --> 36:36.700
JavaScript模式

36:36.700 --> 36:38.700
JavaScript模式这本书

36:38.700 --> 36:40.700
包括JavaScript设计模式

36:40.700 --> 36:41.700
这本书

36:41.700 --> 36:42.700
你先看看这两本

36:42.700 --> 36:43.700
如果你看完以后的话

36:43.700 --> 36:44.700
你觉得都OK对吧

36:44.700 --> 36:45.700
你再来找我

36:45.700 --> 36:46.700
再来找我

36:46.700 --> 36:48.700
我可以再推荐一些他其他的

36:48.700 --> 36:50.700
那先看这两本

36:50.700 --> 36:52.700
咱先别把所有东西都买了

36:52.700 --> 36:53.700
你讲那么多以后的话

36:53.700 --> 36:54.700
对你自己信一下

36:54.700 --> 36:55.700
你也是大的

36:58.700 --> 36:59.700
那接下来的话

36:59.700 --> 37:00.700
咱们来去说说

37:00.700 --> 37:01.700
来说什么

37:01.700 --> 37:02.700
来说一下

37:02.700 --> 37:03.700
如果说我们

37:03.700 --> 37:04.700
到后面真正去讲

37:04.700 --> 37:05.700
这种模式的话

37:05.700 --> 37:06.700
都讲什么

37:08.700 --> 37:10.700
模式有很多个

37:10.700 --> 37:11.700
比如说这个什么

37:11.700 --> 37:12.700
二三种小模式

37:12.700 --> 37:13.700
四种大模式

37:13.700 --> 37:14.700
对吧

37:14.700 --> 37:15.700
前段之后

37:15.700 --> 37:16.700
不会用那么多

37:17.700 --> 37:18.700
很多什么职责恋

37:18.700 --> 37:19.700
模式

37:19.700 --> 37:20.700
对吧

37:20.700 --> 37:21.700
之类这种

37:21.700 --> 37:22.700
后段那些这种东西

37:22.700 --> 37:24.700
在前段都用不上

37:24.700 --> 37:26.700
那这里面让我去

37:26.700 --> 37:28.700
跟你去列举了

37:28.700 --> 37:30.700
基本上很多个这样一种模式

37:30.700 --> 37:31.700
但是咱

37:31.700 --> 37:32.700
在这些课中

37:32.700 --> 37:33.700
会把一些重点的

37:33.700 --> 37:34.700
拿出来去讲

37:34.700 --> 37:35.700
但并不会把所有的东西

37:35.700 --> 37:36.700
全拿来讲

37:36.700 --> 37:37.700
那这一块

37:37.700 --> 37:38.700
咱先把实际模式

37:38.700 --> 37:40.700
给它分类对吧

37:40.700 --> 37:41.700
分类

37:41.700 --> 37:42.700
实际模式

37:42.700 --> 37:44.700
都有什么那种类型

37:44.700 --> 37:46.700
首先就是这种创建型的

37:46.700 --> 37:47.700
创建型

37:47.700 --> 37:48.700
主要做的事情

37:48.700 --> 37:49.700
或者说它的一个目的上

37:49.700 --> 37:50.700
是研究

37:50.700 --> 37:52.700
如何高效果的创建对象

37:52.700 --> 37:53.700
咱们说

37:53.700 --> 37:54.700
这个对象

37:54.700 --> 37:55.700
面向对象

37:55.700 --> 37:56.700
变成

37:56.700 --> 37:57.700
就是在玩对象

37:57.700 --> 37:58.700
对吧

37:58.700 --> 37:59.700
对象如何创建

37:59.700 --> 38:00.700
这间关系是啥

38:00.700 --> 38:01.700
对吧

38:01.700 --> 38:02.700
他们这间关系是啥

38:02.700 --> 38:03.700
行为是啥

38:03.700 --> 38:04.700
这些点都很重要

38:04.700 --> 38:05.700
我们设计模式

38:05.700 --> 38:07.700
也分了很多类

38:07.700 --> 38:08.700
这些类分别

38:08.700 --> 38:10.700
都是针对于

38:10.700 --> 38:11.700
这三种

38:11.700 --> 38:12.700
它来去这样的一个

38:12.700 --> 38:14.700
来去设计的

38:14.700 --> 38:15.700
那首先

38:15.700 --> 38:16.700
就是如何来

38:16.700 --> 38:17.700
高效的创建对象

38:17.700 --> 38:19.700
那高效的创建对象的话

38:19.700 --> 38:20.700
比如说有弹力模式

38:20.700 --> 38:21.700
工厂模式

38:21.700 --> 38:23.700
抽象工厂模式

38:23.700 --> 38:24.700
等等等等等等

38:24.700 --> 38:25.700
那这个东西

38:25.700 --> 38:26.700
弹力模式

38:26.700 --> 38:27.700
什么工厂模式

38:27.700 --> 38:28.700
这几种的话

38:28.700 --> 38:29.700
咱在后面

38:29.700 --> 38:30.700
会详细的来代码

38:30.700 --> 38:31.700
去实现

38:31.700 --> 38:33.700
而且咱还会去应用一下

38:35.700 --> 38:36.700
当然很多这种

38:36.700 --> 38:37.700
其他的模式

38:37.700 --> 38:38.700
你想去看看的话

38:38.700 --> 38:39.700
你去看看说

38:39.700 --> 38:40.700
这个我相信

38:40.700 --> 38:41.700
有我的这个技术

38:41.700 --> 38:42.700
去铺垫的话

38:42.700 --> 38:43.700
你再看这些东西

38:43.700 --> 38:45.700
你想作为额外的一个扩展

38:45.700 --> 38:46.700
是没问题的

38:46.700 --> 38:47.700
那再往下来

38:47.700 --> 38:48.700
再往下来

38:48.700 --> 38:49.700
咱看这就是

38:49.700 --> 38:50.700
接下来就是

38:50.700 --> 38:51.700
这个对象

38:51.700 --> 38:52.700
如果你创建好以后

38:52.700 --> 38:53.700
如果说你知道

38:53.700 --> 38:54.700
如何来高效的创建了

38:54.700 --> 38:55.700
那是不是咱要去理解一下

38:55.700 --> 38:56.700
这个对象的

38:56.700 --> 38:57.700
结构和闭之间

38:57.700 --> 38:58.700
那个关节

38:58.700 --> 38:59.700
对吧

38:59.700 --> 39:00.700
那这个关系的话

39:00.700 --> 39:01.700
比如说

39:01.700 --> 39:02.700
就是会有一些

39:02.700 --> 39:04.700
像这种代理模式

39:04.700 --> 39:05.700
组合模式

39:05.700 --> 39:06.700
装饰模式等等

39:06.700 --> 39:08.700
通过这些模式

39:08.700 --> 39:09.700
来去解决

39:09.700 --> 39:10.700
一个对象的结构

39:10.700 --> 39:11.700
是什么样子

39:11.700 --> 39:13.700
他们之间关系是怎么样的

39:13.700 --> 39:14.700
所以说

39:14.700 --> 39:15.700
这一块的话

39:15.700 --> 39:16.700
咱也会拿出来

39:16.700 --> 39:17.700
去调几个重点

39:17.700 --> 39:18.700
前两天用得上

39:18.700 --> 39:19.700
咱就讲一讲

39:19.700 --> 39:20.700
那再来说

39:20.700 --> 39:21.700
这种行为模式

39:21.700 --> 39:22.700
比如说什么

39:22.700 --> 39:23.700
迭代器模式

39:23.700 --> 39:24.700
就是在ES6里面

39:24.700 --> 39:25.700
你们这个小胖小胖

39:25.700 --> 39:26.700
小胖去了

39:26.700 --> 39:27.700
他确实胖

39:27.700 --> 39:28.700
你们订了老师

39:28.700 --> 39:29.700
你们订了老师

39:29.700 --> 39:30.700
其实他讲过

39:30.700 --> 39:31.700
这个比如说

39:31.700 --> 39:34.700
这个叫

39:34.700 --> 39:35.700
什么

39:35.700 --> 39:37.700
ITR

39:37.700 --> 39:38.700
这个ES6里面

39:38.700 --> 39:40.700
好像是有这样的一个迭代器

39:40.700 --> 39:41.700
他其实一个

39:41.700 --> 39:42.700
本质一个思想

39:42.700 --> 39:43.700
也算是这种迭代器模式

39:43.700 --> 39:44.700
他来的

39:44.700 --> 39:46.700
那还有这种观察者模式

39:46.700 --> 39:48.700
这个载VUE的原码之中

39:48.700 --> 39:49.700
也会

39:49.700 --> 39:50.700
也会详细的去

39:50.700 --> 39:51.700
抛弃一下

39:52.700 --> 39:53.700
发布灵域

39:53.700 --> 39:55.700
发布灵域是在前面我觉得

39:56.700 --> 39:57.700
发布灵域

39:58.700 --> 39:59.700
我发布灵域

39:59.700 --> 40:00.700
我看还有没有

40:01.700 --> 40:02.700
发布灵域模式

40:02.700 --> 40:03.700
咱也在后面是要讲的

40:03.700 --> 40:05.700
再包括一些什么策略模式

40:05.700 --> 40:06.700
等等等等

40:06.700 --> 40:08.700
像这个模式的话

40:08.700 --> 40:09.700
很多种的话

40:09.700 --> 40:11.700
咱们现在是用不上的

40:12.700 --> 40:13.700
比如说整个模式的话

40:13.700 --> 40:15.700
其实分这个几类

40:15.700 --> 40:16.700
咱们会调整几类中

40:16.700 --> 40:18.700
常用的去说一说

40:18.700 --> 40:19.700
说一说

40:19.700 --> 40:20.700
咱这一刻

40:20.700 --> 40:22.700
不是来去把这个模式

40:22.700 --> 40:23.700
每个人拿出来

40:23.700 --> 40:24.700
如何来实现

40:24.700 --> 40:25.700
咱们这一刻

40:25.700 --> 40:26.700
只是来告诉你一下

40:26.700 --> 40:27.700
这个模式和原则

40:27.700 --> 40:28.700
他们之间

40:28.700 --> 40:29.700
到底是什么一种关系

40:29.700 --> 40:30.700
怎么一回事

40:30.700 --> 40:31.700
为什么要学它

40:31.700 --> 40:32.700
以及

40:32.700 --> 40:33.700
我们接下来

40:33.700 --> 40:35.700
要抛弃一下

40:35.700 --> 40:37.700
我们六大原则

40:37.700 --> 40:38.700
说学模式

40:38.700 --> 40:39.700
你要不学原则

40:39.700 --> 40:40.700
就是那些耍流氓

40:40.700 --> 40:41.700
那么

40:42.700 --> 40:43.700
就是不以结婚

40:43.700 --> 40:44.700
没目的恋爱的

40:44.700 --> 40:45.700
都叫做耍流氓

40:45.700 --> 40:46.700
对吧

40:46.700 --> 40:47.700
这个

40:47.700 --> 40:48.700
那咱来看看吧

40:48.700 --> 40:49.700
咱来看看

40:49.700 --> 40:50.700
是六大原则都有什么

40:50.700 --> 40:51.700
好

40:52.700 --> 40:53.700
OK

40:58.460 --> 40:59.460
对了

40:59.460 --> 41:00.460
这个世界生物

41:00.460 --> 41:01.460
主要还在一些

41:01.460 --> 41:02.460
就是其他原则

41:02.460 --> 41:03.460
不是吗

41:03.460 --> 41:04.460
C家家

41:04.460 --> 41:05.460
包括一些

41:05.460 --> 41:06.460
就是张二中

41:06.460 --> 41:07.460
这些后代原则

41:07.460 --> 41:08.460
会更常用一些

41:09.460 --> 41:10.460
那接下来咱往下说

41:10.460 --> 41:11.460
说这个六大原则

41:11.460 --> 41:12.460
其实我们

41:13.460 --> 41:14.460
讲这个原则

41:14.460 --> 41:16.460
这个理论是很重要的

41:17.460 --> 41:18.460
其实有

41:18.460 --> 41:19.460
就是怎么说

41:19.460 --> 41:20.460
就是这个理论

41:20.460 --> 41:21.460
如果说你搞透了以后的话

41:21.460 --> 41:23.460
你让这个理论去做事的话

41:23.460 --> 41:24.460
即使你原则

41:24.460 --> 41:25.460
不怎么会

41:25.460 --> 41:26.460
它不那么多

41:26.460 --> 41:28.460
你也能写出一些

41:28.460 --> 41:30.460
比较高效的一些弹码

41:30.460 --> 41:31.460
世界模式

41:31.460 --> 41:32.460
只是在这些理论上

41:32.460 --> 41:34.460
钱给你总结好的一些套路

41:34.460 --> 41:35.460
你有了套了以后的话

41:35.460 --> 41:36.460
可能说是你这个东西

41:36.460 --> 41:38.460
你都不用献想

41:38.460 --> 41:39.460
你是把这个套路

41:39.460 --> 41:40.460
你都已经备了

41:40.460 --> 41:41.460
对吧

41:41.460 --> 41:42.460
拿着就直接写了

41:42.460 --> 41:44.460
但是它所有的这样的一个基础

41:44.460 --> 41:46.460
它都是几个这几大原则

41:46.460 --> 41:48.460
那这几个原则的目的是啥

41:48.460 --> 41:49.460
我先来说说

41:52.460 --> 41:53.460
这几个目的

41:53.460 --> 41:54.460
我这边写的是

41:54.460 --> 41:55.460
减少偶和

41:55.460 --> 41:56.460
增加私动性

41:56.460 --> 41:58.460
降低代码的开发

41:58.460 --> 41:59.460
和为后成本

42:00.460 --> 42:01.460
其实这么说

42:01.460 --> 42:03.460
你在网上搜

42:03.460 --> 42:04.460
没问题

42:04.460 --> 42:06.460
或者说你在去问一些

42:09.460 --> 42:10.460
你在去问一些

42:10.460 --> 42:12.460
稍微懂点设计模式的人

42:12.460 --> 42:14.460
他可能也会跟你这么去说

42:14.460 --> 42:15.460
但是那我觉得

42:15.460 --> 42:16.460
这么说

42:16.460 --> 42:18.460
还不够深刻

42:18.460 --> 42:19.460
还不够深刻

42:19.460 --> 42:21.460
如果深刻点说的话

42:21.460 --> 42:24.460
设计模式的主要作用是什么

42:24.460 --> 42:26.460
我可以基本跟你这么来讲

42:26.460 --> 42:28.460
它的主要作用就是

42:28.460 --> 42:32.460
降低代码的复杂程度

42:32.460 --> 42:33.460
合理的减少

42:33.460 --> 42:34.460
偶和度

42:35.460 --> 42:37.460
复杂程度和偶和度

42:37.460 --> 42:38.460
分别会影响什么

42:38.460 --> 42:42.460
但它一定会影响这些东西

42:42.460 --> 42:43.460
就不如说

42:43.460 --> 42:44.460
可维护性

42:44.460 --> 42:46.460
它的复用性

42:46.460 --> 42:48.460
等等

42:48.460 --> 42:50.460
这一块的话

42:50.460 --> 42:51.460
我相信

42:51.460 --> 42:53.460
你可能对一些偶和性

42:53.460 --> 42:55.460
什么复用性

42:55.460 --> 42:57.460
如果说没有深刻的了解的话

42:57.460 --> 42:58.460
没关系

42:58.460 --> 43:00.460
咱可以一会来简单的说一说

43:00.460 --> 43:02.460
当然咱讲这个原则的时候

43:02.460 --> 43:04.460
也会把这个东西落实到代码之中

43:04.460 --> 43:06.460
咱给你们来看一看

43:06.460 --> 43:09.460
首先咱来简单的说一下

43:09.460 --> 43:11.460
偶和

43:11.460 --> 43:13.460
啥是偶和呢

43:13.460 --> 43:15.460
偶和关系的话

43:15.460 --> 43:16.460
在我们前面中

43:16.460 --> 43:18.460
或者在我们这样的开发中

43:18.460 --> 43:20.460
你可以简单的理解成

43:20.460 --> 43:22.460
关联性

43:22.460 --> 43:24.460
人和人之间

43:24.460 --> 43:25.460
什么叫做有关联性

43:25.460 --> 43:26.460
关联性

43:26.460 --> 43:28.460
咱俩完全是陌生人

43:28.460 --> 43:29.460
只能咱俩没有关联

43:29.460 --> 43:31.460
比如咱俩是朋友

43:31.460 --> 43:32.460
那是亲戚

43:32.460 --> 43:35.460
或者说是咱们偶然遇到了以后

43:35.460 --> 43:37.460
我受了伤

43:37.460 --> 43:38.460
你帮我一下

43:38.460 --> 43:39.460
或者你受了伤

43:39.460 --> 43:40.460
我帮你一下

43:40.460 --> 43:43.460
只要咱俩形成这样的一个联系

43:43.460 --> 43:44.460
相互动物

43:44.460 --> 43:45.460
相互影响

43:45.460 --> 43:48.460
咱们就有这样的一个偶和关系

43:48.460 --> 43:50.460
如果放到代码之中的话

43:50.460 --> 43:52.460
比如说两个函数之间

43:52.460 --> 43:53.460
这个函数的功能

43:53.460 --> 43:55.460
需要接触

43:55.460 --> 43:57.460
需要接触于另一个函数

43:57.460 --> 43:58.460
就比如说这个函数

43:58.460 --> 43:59.460
要执行功能的什么

43:59.460 --> 44:01.460
它需要接触于一个参数

44:01.460 --> 44:02.460
但这个参数

44:02.460 --> 44:03.460
是由另外一个函数

44:03.460 --> 44:05.460
经完后的一个结果

44:05.460 --> 44:06.460
发生后来的

44:06.460 --> 44:07.460
那他们之间

44:07.460 --> 44:09.460
指定是有这样的一个关联性

44:09.460 --> 44:11.460
他们指定会相互影响

44:11.460 --> 44:13.460
你再也不用说两个对象

44:13.460 --> 44:14.460
这个对象

44:14.460 --> 44:15.460
比如说有个纤维

44:15.460 --> 44:16.460
刷在它身上

44:16.460 --> 44:17.460
好了

44:17.460 --> 44:18.460
那它怎么样

44:18.460 --> 44:19.460
它进而去改变

44:19.460 --> 44:21.460
另外一个对象的一个状态

44:21.460 --> 44:22.460
那这种情况下的话

44:22.460 --> 44:25.460
他们一定也是有偶和关系的

44:25.460 --> 44:26.460
那比如说

44:26.460 --> 44:27.460
你可以列成

44:27.460 --> 44:28.460
只要这两个

44:28.460 --> 44:29.460
只要这两个对象也好

44:29.460 --> 44:30.460
还是含水

44:30.460 --> 44:31.460
对吧

44:31.460 --> 44:32.460
这种功能也好

44:32.460 --> 44:34.460
他们之间有相互的一个联系

44:34.460 --> 44:36.460
有下签的他们

44:36.460 --> 44:37.460
他们怎么样

44:37.460 --> 44:38.460
就可以理解什么

44:38.460 --> 44:40.460
是有这样的一个偶和性

44:40.460 --> 44:41.460
但这种下的话

44:41.460 --> 44:42.460
我说的是

44:42.460 --> 44:44.460
他们之间是之间的

44:44.460 --> 44:45.460
是这种

44:48.460 --> 44:50.460
如果他们之间可能

44:50.460 --> 44:51.460
都只是

44:51.460 --> 44:52.460
比如说是

44:52.460 --> 44:54.460
在抽象层面上

44:54.460 --> 44:55.460
有这种关系的话

44:55.460 --> 44:57.460
他们并不叫做偶和

44:57.460 --> 44:58.460
这种抽象

44:58.460 --> 44:59.460
这种关系

44:59.460 --> 45:00.460
就比如说

45:00.460 --> 45:01.460
我这个对象

45:01.460 --> 45:03.460
行为出发了以后

45:03.460 --> 45:05.460
它去改变了

45:05.460 --> 45:06.460
比如说一个

45:06.460 --> 45:08.460
全局的一个变量

45:08.460 --> 45:10.460
那这个变量

45:10.460 --> 45:11.460
我们可以管的

45:11.460 --> 45:12.460
叫做状态行吗

45:12.460 --> 45:14.460
那我另外一个对象

45:14.460 --> 45:15.460
它在监控这个状态

45:15.460 --> 45:17.460
是否发生改变

45:17.460 --> 45:18.460
状态变了以后的话

45:18.460 --> 45:19.460
我这个B对象

45:19.460 --> 45:20.460
它也会变

45:20.460 --> 45:21.460
那这样的话

45:21.460 --> 45:22.460
其实他们之间是有

45:22.460 --> 45:24.460
这种拐弯的

45:24.460 --> 45:25.460
或者说这种抽象的

45:25.460 --> 45:26.460
一个关系在的

45:26.460 --> 45:27.460
那他们之间叫偶和吗

45:27.460 --> 45:29.460
他们不叫做偶和

45:29.460 --> 45:30.460
这个我再讲

45:30.460 --> 45:31.460
这个依赖道之原则的时候

45:31.460 --> 45:32.460
我们还不来说一说

45:32.460 --> 45:33.460
来说一说

45:33.460 --> 45:34.460
就是只有这两个

45:34.460 --> 45:35.460
比如说对象

45:35.460 --> 45:36.460
然后方法对吧

45:36.460 --> 45:37.460
他们之间产生联系

45:37.460 --> 45:39.460
我们才叫做偶和

45:39.460 --> 45:40.460
好

45:40.460 --> 45:41.460
那偶和

45:41.460 --> 45:43.460
是偶和的危害性的

45:43.460 --> 45:44.460
当然除了偶和度以外

45:44.460 --> 45:45.460
还有这种

45:45.460 --> 45:46.460
还有个词叫做复杂度

45:46.460 --> 45:47.460
复杂度什么意思呢

45:47.460 --> 45:48.460
这个东西

45:48.460 --> 45:49.460
这个

45:49.460 --> 45:51.460
你可以这么来理解

45:51.460 --> 45:52.460
就是

45:53.460 --> 45:54.460
我写的

45:54.460 --> 45:55.460
我一面里面

45:55.460 --> 45:57.460
可能说碰到一个功能

45:57.460 --> 45:58.460
这个功能是啥呢

45:58.460 --> 45:59.460
要接收数据

45:59.460 --> 46:00.460
对吧

46:00.460 --> 46:02.460
反正重来渲染这样的一个页面

46:02.460 --> 46:03.460
并且

46:03.460 --> 46:05.460
可能说是这个

46:05.460 --> 46:08.460
这个里面还设计到了一些

46:08.460 --> 46:10.460
离线缓存

46:10.460 --> 46:11.460
或者说是这样的一个

46:11.460 --> 46:13.460
从这个本地缓存中

46:13.460 --> 46:14.460
去取数据

46:14.460 --> 46:15.460
对吧

46:15.460 --> 46:17.460
来进行这样的一个展示

46:17.460 --> 46:18.460
那OK

46:18.460 --> 46:19.460
那不是说

46:19.460 --> 46:21.460
我们细化一下

46:21.460 --> 46:23.460
这我刚才所说的这些东西的话

46:23.460 --> 46:24.460
其实它里面

46:24.460 --> 46:25.460
可以拆分成很多功能

46:25.460 --> 46:26.460
就比如说

46:26.460 --> 46:28.460
它后期数据可以是个功能

46:28.460 --> 46:30.460
因为它要根据数据来渲染

46:30.460 --> 46:31.460
这个

46:31.460 --> 46:33.460
根据数据来渲染它页面的话

46:33.460 --> 46:34.460
可能说

46:34.460 --> 46:35.460
它要有方法来后期数据

46:35.460 --> 46:36.460
对不对

46:36.460 --> 46:37.460
但是说它这个

46:37.460 --> 46:38.460
后期数据可以是一个功能

46:38.460 --> 46:39.460
对吧

46:39.460 --> 46:40.460
那这个渲染

46:40.460 --> 46:41.460
这个数据可以担当

46:41.460 --> 46:42.460
它的担当是个功能

46:42.460 --> 46:43.460
那可能说是这个

46:43.460 --> 46:44.460
它

46:44.460 --> 46:45.460
并跟这个

46:45.460 --> 46:46.460
去缓存

46:46.460 --> 46:47.460
或者说缓存数据可能

46:47.460 --> 46:48.460
它也是个功能

46:48.460 --> 46:50.460
那你把这个所有的东西

46:50.460 --> 46:51.460
拿到一个地方去写的话

46:51.460 --> 46:53.460
不过写成一个寒兽

46:53.460 --> 46:54.460
那这寒兽的复杂程度

46:54.460 --> 46:55.460
一定是比较高的

46:55.460 --> 46:56.460
单码质量

46:56.460 --> 46:57.460
它就不是非常高的

46:57.460 --> 46:58.460
那这一块的话

46:58.460 --> 47:00.460
其实就是我想说

47:00.460 --> 47:02.460
复杂度和偶和度的话

47:02.460 --> 47:04.460
它对于我们这种开发中

47:04.460 --> 47:05.460
是存在一个危害性的

47:05.460 --> 47:08.460
那当复杂这个程度

47:08.460 --> 47:09.460
一个代码

47:09.460 --> 47:10.460
或者说一个功能的复杂程度

47:10.460 --> 47:11.460
特别高的情况下

47:11.460 --> 47:12.460
或者说一个对象

47:12.460 --> 47:13.460
复杂程度很高的情况下的话

47:13.460 --> 47:14.460
这个你的代码质量

47:14.460 --> 47:15.460
一定不会特别高

47:15.460 --> 47:16.460
一定是低的

47:16.460 --> 47:19.460
那复杂程度一旦高了以后的话

47:19.460 --> 47:20.460
可维护性就差

47:20.460 --> 47:21.460
可维护性就差

47:21.460 --> 47:22.460
你可怎么来理解呢

47:22.460 --> 47:23.460
就是你要改一个东西

47:23.460 --> 47:25.460
你要是修改一个东西

47:25.460 --> 47:26.460
你能载着一堆代码

47:26.460 --> 47:27.460
逻辑中去找

47:27.460 --> 47:29.460
你找又找好它很长时间

47:29.460 --> 47:30.460
那一个效率的自然然

47:30.460 --> 47:32.460
它能被更好的

47:32.460 --> 47:33.460
维护的这样的一个性能

47:33.460 --> 47:35.460
它就更差的

47:35.460 --> 47:36.460
而且你看我刚才

47:36.460 --> 47:37.460
在描述的时候

47:37.460 --> 47:38.460
我把所有的功能

47:38.460 --> 47:40.460
全部挤到一起去写

47:40.460 --> 47:41.460
写成一个寒兽

47:41.460 --> 47:43.460
那复杂程度一定非常差

47:43.460 --> 47:44.460
你就比如说

47:44.460 --> 47:45.460
我在这个页面之中

47:45.460 --> 47:46.460
又有另外一个地方

47:46.460 --> 47:47.460
需要

47:47.460 --> 47:48.460
又有这个

47:48.460 --> 47:50.460
获取数据的一个功能了

47:50.460 --> 47:52.460
那我没有办法怎么样

47:52.460 --> 47:54.460
我没有办法说是

47:54.460 --> 47:55.460
不再去写

47:55.460 --> 47:56.460
写一个对不对

47:56.460 --> 47:57.460
那你会说

47:57.460 --> 47:58.460
你看我之前

47:58.460 --> 48:00.460
不在这个大的雜偶的特工

48:00.460 --> 48:03.460
就是大的这种雜偶的一个功能

48:03.460 --> 48:04.460
就是大的这样的一个

48:04.460 --> 48:05.460
整体的一个功能里面

48:05.460 --> 48:06.460
不是写了这样的一个

48:06.460 --> 48:07.460
比如说

48:07.460 --> 48:08.460
能获取数据的一个特工能吗

48:08.460 --> 48:09.460
那不好意思

48:09.460 --> 48:10.460
你写的时候

48:10.460 --> 48:11.460
你没有给它抽象

48:11.460 --> 48:12.460
从一个真正的

48:12.460 --> 48:13.460
一个单独的方法

48:13.460 --> 48:15.460
或者单独的一个对象

48:15.460 --> 48:16.460
去使用它

48:16.460 --> 48:17.460
你只能怎么样

48:17.460 --> 48:18.460
你只能肯抽谁

48:18.460 --> 48:20.460
肯抽为在付的付出是一遍

48:20.460 --> 48:21.460
那你要说

48:21.460 --> 48:22.460
这个东西其实没有达到复权性

48:22.460 --> 48:23.460
你代码就出现了

48:23.460 --> 48:25.460
这样的荣誉度

48:25.460 --> 48:26.460
这个东西先听我说

48:26.460 --> 48:27.460
一会我会写个东西

48:27.460 --> 48:28.460
让你们去看一看

48:28.460 --> 48:29.460
当然同样

48:29.460 --> 48:31.460
也不容易扩展

48:31.460 --> 48:32.460
你新加一个功能

48:32.460 --> 48:33.460
你怎么去加

48:33.460 --> 48:34.460
对吧

48:34.460 --> 48:35.460
你还在里面去写吗

48:35.460 --> 48:36.460
对吧

48:36.460 --> 48:37.460
你还在里面写的话

48:37.460 --> 48:38.460
我的天啊对吧

48:38.460 --> 48:39.460
你本来

48:39.460 --> 48:40.460
这个东西

48:40.460 --> 48:41.460
它很复杂了

48:41.460 --> 48:42.460
你还要输以出来

48:42.460 --> 48:43.460
这样的一个逻辑

48:43.460 --> 48:44.460
在外面去添加

48:44.460 --> 48:45.460
那这样的话

48:45.460 --> 48:46.460
比如说

48:46.460 --> 48:48.460
当你复杂程度高了以后的话

48:48.460 --> 48:49.460
对你这几个

48:49.460 --> 48:51.460
都是有很大的影响的

48:51.460 --> 48:52.460
所以说

48:52.460 --> 48:53.460
我们在后面说

48:53.460 --> 48:55.460
我们在开发过程中

48:55.460 --> 48:57.460
首先你要做的事什么事呢

48:57.460 --> 48:59.460
就要降低复杂度

48:59.460 --> 49:02.460
降低功能的一个复杂度

49:02.460 --> 49:03.460
当然

49:03.460 --> 49:04.460
当然

49:04.460 --> 49:06.460
我们在对一个项目进行优化的时候

49:06.460 --> 49:07.460
比如说这个项目

49:07.460 --> 49:08.460
别人自换以后的话

49:08.460 --> 49:09.460
还发现效率不高

49:09.460 --> 49:10.460
不好对不对

49:10.460 --> 49:11.460
让你去优化的话

49:11.460 --> 49:13.460
你要做的电源设施啥呢

49:13.460 --> 49:14.460
就是降低层的复杂度

49:14.460 --> 49:15.460
当然

49:15.460 --> 49:16.460
如何来降低呢

49:16.460 --> 49:19.460
有几个原则来负责做这样的事

49:19.460 --> 49:20.460
一会来跟你说一说

49:20.460 --> 49:21.460
好

49:21.460 --> 49:23.460
再往这来

49:23.460 --> 49:25.460
再往这来就是偶和度

49:25.460 --> 49:26.460
偶和度这个东西

49:26.460 --> 49:28.460
我们经常会听到一个东西

49:28.460 --> 49:30.460
叫做高内距低偶和

49:30.460 --> 49:31.460
那高内距低偶和

49:31.460 --> 49:32.460
那你会说

49:32.460 --> 49:33.460
我们想追求低偶和

49:33.460 --> 49:34.460
那不偶和行不行

49:34.460 --> 49:36.460
不偶和是不可能的

49:36.460 --> 49:37.460
你别想了

49:37.460 --> 49:38.460
比如说你做一个功能

49:38.460 --> 49:40.460
或者是你做一个这样的网易

49:40.460 --> 49:42.460
做一个大型的一个站点

49:42.460 --> 49:43.460
好了

49:43.460 --> 49:45.460
你写了很多很多这样的那个函数

49:45.460 --> 49:47.460
或者是你创造了很多很多这样的一个对象

49:47.460 --> 49:48.460
他们都有自己的功能对吧

49:48.460 --> 49:50.460
但这些功能

49:50.460 --> 49:51.460
只要他们之间

49:51.460 --> 49:53.460
有这样一种传染的关系

49:53.460 --> 49:54.460
或者说彼此之间

49:54.460 --> 49:56.460
依赖的一个关系

49:56.460 --> 49:58.460
那它就会有偶和度

49:58.460 --> 49:59.460
偶因为偶和

49:59.460 --> 50:01.460
它就是这样一种关联性

50:01.460 --> 50:02.460
你想象一下

50:02.460 --> 50:03.460
如果这些对象

50:03.460 --> 50:05.460
这些功能彼此都没有关联的话

50:05.460 --> 50:07.460
他们怎么可能一起

50:07.460 --> 50:09.460
把这个页面

50:09.460 --> 50:10.460
给的去运转起来

50:10.460 --> 50:12.460
所以说不偶和

50:12.460 --> 50:13.460
是不可能的

50:13.460 --> 50:15.460
所以你也不要追求你代码写的

50:15.460 --> 50:16.460
不偶和

50:16.460 --> 50:17.460
一点偶和都没有

50:17.460 --> 50:18.460
不可能

50:18.460 --> 50:20.460
要说在一定条件下

50:20.460 --> 50:21.460
只要是低偶和的话

50:21.460 --> 50:22.460
就合理

50:22.460 --> 50:23.460
就可以

50:23.460 --> 50:25.460
那如果说这个偶和度

50:25.460 --> 50:26.460
过高的情况下的话

50:26.460 --> 50:28.460
它确实

50:28.460 --> 50:31.460
确实是依旧有好的附用性了

50:31.460 --> 50:33.460
因为什么意思呢

50:33.460 --> 50:35.460
比如说

50:35.460 --> 50:36.460
就是不

50:36.460 --> 50:37.460
是这样的

50:37.460 --> 50:38.460
偶和度

50:38.460 --> 50:40.460
它如果过高的情况下的话

50:40.460 --> 50:43.460
就不容易去维护的

50:43.460 --> 50:44.460
但是

50:44.460 --> 50:46.460
它是依旧可以有附用性的

50:46.460 --> 50:47.460
而且怎么样

50:47.460 --> 50:49.460
而且是有扩展性的

50:49.460 --> 50:50.460
不能说是好的

50:50.460 --> 50:52.460
它是有的

50:52.460 --> 50:54.460
而且也不怎么烂

50:54.460 --> 50:55.460
因为什么呢

50:55.460 --> 50:56.460
因为你看

50:56.460 --> 50:57.460
偶和度高什么

50:57.460 --> 50:59.460
偶和度高就这么一点

50:59.460 --> 51:02.460
这么有很多个单独功能的

51:02.460 --> 51:03.460
对象

51:03.460 --> 51:04.460
方法

51:04.460 --> 51:06.460
单独的对象和方法

51:06.460 --> 51:07.460
那证明是

51:07.460 --> 51:09.460
你没有把一大堆功能

51:09.460 --> 51:11.460
全砸到一起去写

51:11.460 --> 51:12.460
是吧

51:12.460 --> 51:13.460
那

51:13.460 --> 51:15.460
如果是这种情况下的话

51:15.460 --> 51:16.460
那这些功能

51:16.460 --> 51:18.460
它都是单独的这种一个

51:18.460 --> 51:20.460
而不是砸到一起的话

51:20.460 --> 51:21.460
它必然的这种附用性

51:21.460 --> 51:22.460
会更好

51:22.460 --> 51:23.460
会更好一些

51:23.460 --> 51:25.460
那你在扩展的时候

51:25.460 --> 51:27.460
你不用砸一大坨

51:27.460 --> 51:30.460
这种结合的一个功能的代码之中

51:30.460 --> 51:31.460
再去梳理逻辑

51:31.460 --> 51:33.460
再去添加

51:33.460 --> 51:35.460
而只是单独再去写功能

51:35.460 --> 51:37.460
那当然的扩展性

51:37.460 --> 51:38.460
是比这种

51:38.460 --> 51:40.460
是在一定情况下

51:40.460 --> 51:41.460
它还是挺不错的

51:41.460 --> 51:42.460
它不会像这种

51:42.460 --> 51:44.460
有时候负大程度高了

51:44.460 --> 51:45.460
它高了以后的话

51:45.460 --> 51:47.460
它不易扩展

51:47.460 --> 51:49.460
比如说这一块

51:49.460 --> 51:52.460
这一块的总结很重要

51:52.460 --> 51:53.460
这一块的东西

51:53.460 --> 51:55.460
它往往体现出来

51:55.460 --> 51:57.460
一个人是否对设计模式

51:57.460 --> 51:58.460
有深刻的理解

51:58.460 --> 51:59.460
而这些东西

51:59.460 --> 52:00.460
你去往上搜

52:00.460 --> 52:01.460
去各种地方搜的话

52:01.460 --> 52:02.460
你都是搜不到的

52:02.460 --> 52:04.460
因为它是无总结的

52:04.460 --> 52:08.460
但这一块

52:08.460 --> 52:09.460
你想能深入的理解的话

52:09.460 --> 52:10.460
我后面把原则讲完

52:10.460 --> 52:12.460
然后给你一个一个去画个图

52:12.460 --> 52:14.460
你也不用太恐惧

52:14.460 --> 52:15.460
我看讲到这

52:15.460 --> 52:17.460
还有多少同学他在听

52:17.460 --> 52:18.460
还有39人

52:18.460 --> 52:19.460
不错

52:19.460 --> 52:20.460
挺好

52:20.460 --> 52:22.460
接下来

52:22.460 --> 52:23.460
我要说一下

52:23.460 --> 52:24.460
你在正常开工中

52:24.460 --> 52:27.460
如果你学完设计模式以后

52:27.460 --> 52:29.460
那我到底要怎么来开发呢

52:29.460 --> 52:31.460
那我怎么要去优化

52:31.460 --> 52:33.460
别人的一些项目呢

52:33.460 --> 52:36.460
好 咱们来看一下

52:36.460 --> 52:37.460
过去

52:37.460 --> 52:38.460
稍等我一会

52:38.460 --> 52:39.460
我喝点水

52:39.460 --> 52:40.460
稍微能渴

52:40.460 --> 52:44.410
你这也没停

52:44.410 --> 52:46.410
好了

52:46.410 --> 52:47.410
好

52:47.410 --> 52:48.410
那接下来

52:48.410 --> 52:49.410
咱们马上说

52:49.410 --> 52:51.410
咱们8888

52:51.410 --> 52:52.410
这都比比糟

52:52.410 --> 52:53.410
这么长时间

52:53.410 --> 52:54.410
那我们好了

52:54.410 --> 52:55.410
我们落实到真正开发工中的话

52:55.410 --> 52:57.410
我们到底要怎么办

52:57.410 --> 52:59.410
我们在正常的开发的时候

52:59.410 --> 53:02.410
我们一定要秉承一个原则

53:02.410 --> 53:04.410
就是尽可能的先降低复杂度

53:04.410 --> 53:07.410
之后再降低偶合度

53:07.410 --> 53:08.410
但我跟你说

53:08.410 --> 53:11.410
你在降低复杂度的时候

53:11.410 --> 53:13.410
你是靠什么来降低呢

53:13.410 --> 53:16.410
一定是靠增加偶合度来降低的

53:16.410 --> 53:18.410
基本很多时候它是这样的

53:18.410 --> 53:19.410
不是百分之百的

53:19.410 --> 53:21.410
除非你这个东西裸一些

53:21.410 --> 53:22.410
特别烂

53:22.410 --> 53:23.410
导致它很复杂

53:23.410 --> 53:24.410
那好

53:24.410 --> 53:25.410
OK 那你把这些裸

53:25.410 --> 53:26.410
一梳理梳理

53:26.410 --> 53:27.410
或者说你通过一些

53:27.410 --> 53:28.410
稍微牛奶的算法

53:28.410 --> 53:29.410
算法来梳理梳理

53:29.410 --> 53:31.410
降低这样的一个代表的复杂度

53:31.410 --> 53:33.410
否则很大一部分程度

53:33.410 --> 53:36.410
我们都是去通过增加偶合度

53:36.410 --> 53:38.410
来去擬补这样的那个复杂度

53:38.410 --> 53:39.410
那我们这个

53:39.410 --> 53:41.410
后面讲的这个六大原则中

53:41.410 --> 53:43.410
单一职责原则

53:43.410 --> 53:45.410
开闭原则

53:45.410 --> 53:46.410
理事代换原则

53:46.410 --> 53:47.410
这没有我打错了

53:47.410 --> 53:49.410
打俩原则

53:49.410 --> 53:52.410
这些原则的主要作用

53:52.410 --> 53:55.410
是用来降低复杂度的

53:55.410 --> 53:57.410
但降低完复杂度

53:57.410 --> 53:59.410
它是用增加偶合度

53:59.410 --> 54:00.410
这种东西来牺牲

54:00.410 --> 54:01.410
所换来的

54:02.410 --> 54:03.410
那有些人说了

54:03.410 --> 54:04.410
那好了

54:04.410 --> 54:05.410
那我去首先

54:05.410 --> 54:07.410
打掉它的复杂度

54:07.410 --> 54:08.410
偶合度它上下来了

54:08.410 --> 54:09.410
那如果太偶合

54:09.410 --> 54:11.410
那偶合度它也不好

54:11.410 --> 54:12.410
那怎么办呢

54:12.410 --> 54:15.410
那接下来会有一些原则

54:15.410 --> 54:16.410
但是这里面

54:16.410 --> 54:17.410
咱们的词叫做

54:17.410 --> 54:18.410
迪米德法则

54:18.410 --> 54:21.410
但它也叫做最小之道原则

54:21.410 --> 54:22.410
这个东西

54:22.410 --> 54:24.410
是用来减少偶合度的

54:24.410 --> 54:25.410
偶合度

54:27.410 --> 54:29.410
是用来减少偶合度的

54:29.410 --> 54:32.410
那它只是用来减少偶合度

54:32.410 --> 54:33.410
那减少的话

54:33.410 --> 54:35.410
它并不能说是

54:35.410 --> 54:36.410
比如说是

54:36.410 --> 54:37.410
尽可能的去把一些

54:37.410 --> 54:39.410
可以消除的偶合

54:39.410 --> 54:41.410
给它消除

54:41.410 --> 54:42.410
那如果说你想

54:42.410 --> 54:44.410
消除一些偶合的话

54:44.410 --> 54:45.410
怎么办呢

54:45.410 --> 54:46.410
有个东西叫做

54:46.410 --> 54:47.410
依赖道治原则

54:47.410 --> 54:50.410
它是真正能消除偶合的

54:50.410 --> 54:51.410
那当然有一头人会想

54:51.410 --> 54:52.410
它会歪歪

54:52.410 --> 54:53.410
怎么来歪歪呢

54:53.410 --> 54:55.410
说那我就用这个

54:55.410 --> 54:56.410
依赖道治原则

54:56.410 --> 54:58.410
来直接把这种偶合

54:58.410 --> 54:59.410
全干没不就行了吗

54:59.410 --> 55:01.410
能告你不可能

55:01.410 --> 55:02.410
不可能

55:02.410 --> 55:04.410
因为很多情况下的话

55:04.410 --> 55:05.410
我们是没有办法

55:05.410 --> 55:07.410
把依赖道治原则

55:07.410 --> 55:09.410
职务到这样的一个开发之中

55:09.410 --> 55:10.410
有的时候

55:10.410 --> 55:11.410
它俩可能

55:11.410 --> 55:13.410
它俩就需要直接去接触

55:13.410 --> 55:14.410
直接去对碰

55:14.410 --> 55:15.410
消除才是最高的

55:15.410 --> 55:17.410
你强行去用它的话

55:17.410 --> 55:18.410
做这个效能

55:18.410 --> 55:19.410
也不是非常好

55:19.410 --> 55:20.410
那我想到这的话

55:20.410 --> 55:21.410
有同学走了

55:21.410 --> 55:22.410
但我不希望

55:22.410 --> 55:23.410
接下来有同学走

55:23.410 --> 55:25.410
如果你停得很费劲的情况下的话

55:25.410 --> 55:27.410
我也建议你先使劲停一停

55:27.410 --> 55:28.410
时间停一停

55:28.410 --> 55:30.410
因为你通过直播课的话

55:30.410 --> 55:31.410
先跟我的思路

55:31.410 --> 55:32.410
跟你我这样那个流程

55:32.410 --> 55:34.410
走了一遍以后的话

55:34.410 --> 55:36.410
即使你只通了10%

55:36.410 --> 55:37.410
5%

55:37.410 --> 55:40.410
那对于你在看路播的时候

55:40.410 --> 55:41.410
你也一样

55:41.410 --> 55:43.410
是有这个很大的一个意出的

55:43.410 --> 55:44.410
况且你在直播课上的话

55:44.410 --> 55:46.410
你还可以跟对

55:46.410 --> 55:47.410
还可以根据你这个

55:47.410 --> 55:49.410
看到它的实施反馈

55:49.410 --> 55:51.410
跟这种实施反馈去提一些问

55:51.410 --> 55:52.410
那自然而然的话

55:52.410 --> 55:53.410
会比看路播要好很多

55:53.410 --> 55:54.410
什么是道治原则

55:54.410 --> 55:55.410
依赖道治原则

55:55.410 --> 55:56.410
这个东西咱一会儿说

55:56.410 --> 55:57.410
咱接下来

55:57.410 --> 55:59.410
对咱这东西

55:59.410 --> 56:00.410
我只是告诉你

56:00.410 --> 56:01.410
有这么个东西

56:01.410 --> 56:03.410
咱接下来就讲这些原则

56:03.410 --> 56:04.410
讲这些原则以后的话

56:04.410 --> 56:05.410
咱会反过头来

56:05.410 --> 56:06.410
再来去示威说

56:06.410 --> 56:07.410
再来去示威说

56:07.410 --> 56:08.410
而且我还画一个图

56:08.410 --> 56:09.410
会画一个图

56:09.410 --> 56:10.410
不要急

56:10.410 --> 56:12.410
我们在学习的过程中的话

56:12.410 --> 56:14.410
这里面我要跟你说一下

56:14.410 --> 56:15.410
我们首先

56:15.410 --> 56:17.410
这样我觉得

56:17.410 --> 56:19.410
这个什么叫做正体

56:19.410 --> 56:20.410
什么叫做正体

56:20.410 --> 56:21.410
这个东西

56:21.410 --> 56:22.410
我来给你解释一下

56:22.410 --> 56:24.410
我前面讲的这些东西

56:24.410 --> 56:25.410
都很重要

56:25.410 --> 56:28.410
我很多同学他在学工中的话

56:28.410 --> 56:30.410
他想直接就扑到代码上

56:30.410 --> 56:32.410
直接就扑到所谓的

56:32.410 --> 56:34.410
他想的那种重要的地方上

56:34.410 --> 56:37.410
但其实这东西都是一种误区

56:37.410 --> 56:39.410
就比如说

56:39.410 --> 56:41.410
我们单独来看一下

56:41.410 --> 56:43.410
什么能体现出你的开发经验呢

56:43.410 --> 56:44.410
并不说的是

56:44.410 --> 56:47.410
你把代码只量起得多么高

56:47.410 --> 56:49.410
这不叫做你真正的一个

56:49.410 --> 56:50.410
能体验出你开发经验

56:50.410 --> 56:52.410
能体验出你高价的这个地

56:52.410 --> 56:53.410
什么时候能体验出

56:53.410 --> 56:55.410
你是有高价实

56:55.410 --> 56:59.410
你体验出你很小的开发经验

56:59.410 --> 57:02.410
那是你是否能在一种复杂的情况下

57:02.410 --> 57:04.410
能达到一种尽力的平衡

57:04.410 --> 57:06.410
尽力的权衡

57:06.410 --> 57:08.410
这样才能体验出你这样的价值

57:08.410 --> 57:09.410
所以我们你要知道

57:09.410 --> 57:10.410
有的时候

57:10.410 --> 57:11.410
我们在想一个问题的时候的话

57:11.410 --> 57:13.410
可能觉得这个是他重要的

57:13.410 --> 57:15.410
但其实他并不是他重要的

57:15.410 --> 57:17.410
他并不是这个重要的那个

57:17.410 --> 57:19.410
我前面讲的这些东西

57:19.410 --> 57:20.410
如果你都不懂的话

57:20.410 --> 57:22.410
我们直接干到原则上的话

57:22.410 --> 57:24.410
你听都不知道为什么听

57:24.410 --> 57:26.410
都不知道他怎么用

57:26.410 --> 57:28.410
都不知道他为什么用

57:28.410 --> 57:30.410
那自然而然的话

57:30.410 --> 57:32.410
你在使用他的话

57:32.410 --> 57:34.410
也不会深刻到哪去

57:34.410 --> 57:36.410
所以说我希望

57:36.410 --> 57:38.410
同学们按照我这个流程走

57:38.410 --> 57:40.410
磨刀补砍材工

57:40.410 --> 57:42.410
学习的时候先耐下心来

57:42.410 --> 57:43.410
一点一点平

57:43.410 --> 57:44.410
一点一点

57:44.410 --> 57:46.410
先把这个脑海中大的问号

57:46.410 --> 57:48.410
先放哪

57:48.410 --> 57:49.410
把大的问号

57:49.410 --> 57:51.410
在后面路系解决以后的话

57:51.410 --> 57:54.410
我们来接下来开始去解决一些小的问号

57:54.410 --> 57:55.410
那我上来

57:55.410 --> 57:56.410
那我上来

57:56.410 --> 57:57.410
我做的这么多事

57:57.410 --> 57:59.410
都是来解决一个大的问号

57:59.410 --> 58:00.410
什么问号呢

58:00.410 --> 58:02.410
就是原则

58:02.410 --> 58:03.410
模式是什么

58:03.410 --> 58:05.410
原则是什么

58:05.410 --> 58:07.410
设计模式和原则之间的关系

58:07.410 --> 58:08.410
它是什么

58:08.410 --> 58:09.410
对吧

58:09.410 --> 58:10.410
那好了

58:10.410 --> 58:11.410
那这些东西具体来说

58:11.410 --> 58:12.410
对吧

58:12.410 --> 58:14.410
在大方向上应该怎么用

58:14.410 --> 58:17.410
那这些问号全打消以后的话

58:17.410 --> 58:18.410
接下来

58:18.410 --> 58:19.410
我们要做的事

58:19.410 --> 58:20.410
就是

58:20.410 --> 58:23.410
来一个一个的讲象

58:23.410 --> 58:25.410
这个原则是什么意思

58:25.410 --> 58:27.410
这一课就是一个纯理论课

58:27.410 --> 58:28.410
基本上

58:28.410 --> 58:30.410
不太会有太多的一个代码

58:30.410 --> 58:32.410
那这些理论的话

58:32.410 --> 58:33.410
就会有助于你后面

58:33.410 --> 58:34.410
对很多东西的理解

58:34.410 --> 58:35.410
好了

58:35.410 --> 58:37.410
那接下来再来看这了

58:37.410 --> 58:44.670
单一职责原则

58:44.670 --> 58:47.670
单一职责原则

58:47.670 --> 58:48.670
那单一

58:48.670 --> 58:49.670
我先来讲

58:49.670 --> 58:50.670
每个原则的时候

58:50.670 --> 58:52.670
都会拿一个生活上的例子

58:52.670 --> 58:53.670
给你举一举

58:53.670 --> 58:56.670
你可以去想象一下

58:56.670 --> 58:57.670
但我也会在这边

58:57.670 --> 58:59.670
部分原则会拿着代码

58:59.670 --> 59:01.670
去实现一下

59:01.670 --> 59:02.670
首先来看这

59:02.670 --> 59:03.670
单一职责原则

59:03.670 --> 59:06.670
单一职责原则什么意思呢

59:06.670 --> 59:08.670
这东西也很好理解

59:08.670 --> 59:09.670
比如说我们

59:09.670 --> 59:10.670
一个方法

59:10.670 --> 59:12.670
经常只做一件事

59:12.670 --> 59:13.670
或者说

59:13.670 --> 59:14.670
一个对象

59:14.670 --> 59:16.670
经常它只去完成一类功能

59:16.670 --> 59:18.670
那比如说我们在

59:18.670 --> 59:19.670
比如说

59:19.670 --> 59:21.670
我们再去写个功能的时候

59:21.670 --> 59:24.670
比如说他既有请求数据的功能

59:24.670 --> 59:25.670
又能对这个数据

59:25.670 --> 59:26.670
进行这个渲染

59:26.670 --> 59:28.670
把它变到这样的一个

59:28.670 --> 59:29.670
页面上面去的话

59:29.670 --> 59:31.670
那这就不符合单一职责

59:31.670 --> 59:33.670
因为这样的一个含书

59:33.670 --> 59:34.670
它怎么样

59:34.670 --> 59:36.670
它有两个功能

59:36.670 --> 59:37.670
那你想想

59:37.670 --> 59:40.670
如果说你吃饭和上厕所的话

59:40.670 --> 59:42.670
都是用同一个地方来做的话

59:42.670 --> 59:43.670
来解决的话

59:43.670 --> 59:45.670
那这一定不够好

59:45.670 --> 59:48.670
那单一职责原则

59:48.670 --> 59:49.670
就是它是让你这样

59:49.670 --> 59:51.670
它是让你写这个逻辑

59:51.670 --> 59:53.670
或者说它是让你这样写功能的时候

59:53.670 --> 59:56.670
尽可能的变得力度化

59:56.670 --> 59:58.670
力度变得更小一点

59:58.670 --> 01:00:00.670
那每个功能它只干一件事

01:00:00.670 --> 01:00:01.670
只干一件事的话

01:00:01.670 --> 01:00:02.670
好了

01:00:02.670 --> 01:00:03.670
那你想想

01:00:03.670 --> 01:00:04.670
回到这

01:00:04.670 --> 01:00:05.670
回到这

01:00:05.670 --> 01:00:06.670
回到这

01:00:06.670 --> 01:00:08.670
我说利用单一职责原则

01:00:08.670 --> 01:00:10.670
来降低这个复杂度

01:00:10.670 --> 01:00:12.670
为什么能降低复杂度呢

01:00:12.670 --> 01:00:13.670
你想想

01:00:13.670 --> 01:00:15.670
如果说我写这个含书

01:00:15.670 --> 01:00:17.670
不按单一职责原则来做的话

01:00:17.670 --> 01:00:18.670
那我这个含书是不是

01:00:18.670 --> 01:00:20.670
两个功能砸到一起

01:00:20.670 --> 01:00:21.670
相对来讲

01:00:21.670 --> 01:00:23.670
是不是一定它复杂一些

01:00:23.670 --> 01:00:25.670
那我们如果说按照这个原则来做事的话

01:00:25.670 --> 01:00:27.670
我们就一定不会这么写

01:00:27.670 --> 01:00:28.670
对不对

01:00:28.670 --> 01:00:29.670
比如说这个代码已经这么写了

01:00:29.670 --> 01:00:31.670
那你知道这个世纪原则的情况下的话

01:00:31.670 --> 01:00:32.670
你要优化它

01:00:32.670 --> 01:00:34.670
首先你要怎么样

01:00:34.670 --> 01:00:36.670
你是不是要把这样的一个复杂度降低

01:00:36.670 --> 01:00:38.670
你降低的话可以秉承什么

01:00:38.670 --> 01:00:43.670
是不是可以秉承这样一个单一职责原则

01:00:43.670 --> 01:00:45.670
然后每个含书只做一件事

01:00:45.670 --> 01:00:48.670
首先把它的复杂从什么样给它降起来

01:00:48.670 --> 01:00:49.670
对吧

01:00:49.670 --> 01:00:50.670
那你降了以后的话

01:00:50.670 --> 01:00:53.670
你是不是这个从一个含书

01:00:53.670 --> 01:00:55.670
或从一个功能变成两个功能

01:00:55.670 --> 01:00:58.670
这样功能必须的形成一定关联

01:00:58.670 --> 01:01:00.670
才能把整个的一个大功能

01:01:00.670 --> 01:01:02.670
怎么样去稳定的运行出来

01:01:02.670 --> 01:01:03.670
那是不是从而

01:01:03.670 --> 01:01:05.670
它是拿这个偶和度对吧

01:01:05.670 --> 01:01:07.670
拿偶和度牺牲偶和度的代价

01:01:07.670 --> 01:01:10.670
来降低这个含书的复杂度了

01:01:10.670 --> 01:01:11.670
那咱们可以写个代码

01:01:11.670 --> 01:01:13.670
咱来去看一看

01:01:16.110 --> 01:01:17.110
好

01:01:17.110 --> 01:01:18.110
那比如说

01:01:18.110 --> 01:01:19.110
还能拿刚才那个事情

01:01:19.110 --> 01:01:20.110
咱举个例子

01:01:20.110 --> 01:01:21.110
我方认一下

01:01:21.110 --> 01:01:22.110
方认

01:01:22.110 --> 01:01:23.110
方认

01:01:23.110 --> 01:01:24.110
比如方认一个view

01:01:24.110 --> 01:01:25.110
view

01:01:25.110 --> 01:01:26.110
简单写个这个

01:01:26.110 --> 01:01:28.110
简单的来写一下

01:01:28.110 --> 01:01:29.110
那个鲁力代码

01:01:29.110 --> 01:01:30.110
比如说这个view有个功能

01:01:30.110 --> 01:01:31.110
什么功能呢

01:01:31.110 --> 01:01:33.110
这两个得写到上面去

01:01:33.110 --> 01:01:34.110
可撞S一下

01:01:36.110 --> 01:01:38.110
在这比如说有DIV

01:01:38.110 --> 01:01:39.110
比如说它有DIV

01:01:39.110 --> 01:01:42.110
那这个DIV你比如说

01:01:42.110 --> 01:01:43.110
别DIV了

01:01:44.110 --> 01:01:45.110
有

01:01:47.110 --> 01:01:49.110
那咱就拿这个东西来举例子

01:01:49.110 --> 01:01:51.110
我去打开一个

01:01:51.110 --> 01:01:52.110
这个东西

01:01:53.110 --> 01:01:54.110
比如说这个东西

01:01:54.110 --> 01:01:55.110
对吧

01:01:55.110 --> 01:01:56.110
它是一条一条

01:01:56.110 --> 01:01:58.110
这样的一个数据

01:01:58.110 --> 01:01:59.110
对吧

01:01:59.110 --> 01:02:00.110
通过数据可撞

01:02:00.110 --> 01:02:01.110
说它方式

01:02:01.110 --> 01:02:02.110
把这一条一条的东西

01:02:02.110 --> 01:02:03.110
给它展示出来

01:02:03.110 --> 01:02:04.110
如果咱看这里面

01:02:04.110 --> 01:02:05.110
代码的话

01:02:05.110 --> 01:02:06.110
我跟你去抽一眼

01:02:06.110 --> 01:02:09.110
它就是一个

01:02:09.110 --> 01:02:10.110
由数组

01:02:10.110 --> 01:02:12.110
去选出来的一些

01:02:12.110 --> 01:02:13.110
样式

01:02:13.110 --> 01:02:14.110
看这

01:02:14.110 --> 01:02:15.110
看这

01:02:15.110 --> 01:02:16.110
可能说撕一下

01:02:16.110 --> 01:02:17.110
把它查掉一下

01:02:17.110 --> 01:02:18.110
把它查掉一下

01:02:18.110 --> 01:02:19.110
好

01:02:19.110 --> 01:02:22.190
OK

01:02:23.190 --> 01:02:24.190
这是个数据

01:02:24.190 --> 01:02:25.190
这个数据是个数组

01:02:25.190 --> 01:02:26.190
数据没有很多个元素

01:02:26.190 --> 01:02:27.190
对不对

01:02:27.190 --> 01:02:28.190
OK

01:02:28.190 --> 01:02:29.190
这是个数据

01:02:29.190 --> 01:02:30.190
咱们看这个东西

01:02:30.190 --> 01:02:31.190
它是由一条一条数据

01:02:31.190 --> 01:02:32.190
怎么样

01:02:32.190 --> 01:02:34.190
来去经过可刷的方式

01:02:34.190 --> 01:02:35.190
把它展现到这里面去的

01:02:35.190 --> 01:02:36.190
对吧

01:02:36.190 --> 01:02:37.190
那怎么来展现的话

01:02:37.190 --> 01:02:38.190
咱们这个数据

01:02:38.190 --> 01:02:39.190
可中应该是有讲解

01:02:39.190 --> 01:02:40.190
如果你忘了

01:02:40.190 --> 01:02:41.190
你可以你回去看一看

01:02:41.190 --> 01:02:42.190
OK

01:02:42.190 --> 01:02:43.190
那我要做什么事

01:02:43.190 --> 01:02:45.190
假定这个数据

01:02:45.190 --> 01:02:46.190
它可能说是需要

01:02:46.190 --> 01:02:47.190
你通过这个服务器

01:02:47.190 --> 01:02:49.190
通过这个网络请求的方式

01:02:49.190 --> 01:02:50.190
请求过来对吧

01:02:50.190 --> 01:02:51.190
那情况以后的话

01:02:51.190 --> 01:02:52.190
你需要把它渲染到

01:02:52.190 --> 01:02:54.190
或者说给它变到这个

01:02:54.190 --> 01:02:55.190
UL里面去

01:02:55.190 --> 01:02:57.190
变到UL里面去

01:02:57.190 --> 01:02:59.190
那我在这里面写个方法

01:02:59.190 --> 01:03:00.190
这方法叫做Wheel方法

01:03:00.190 --> 01:03:01.190
这个Wheel方法的话

01:03:01.190 --> 01:03:02.190
我希望

01:03:02.190 --> 01:03:04.190
它能接受一个UL

01:03:04.190 --> 01:03:05.190
作为一个参数

01:03:05.190 --> 01:03:07.190
这个参数可以决定

01:03:07.190 --> 01:03:08.190
这个内部的功能

01:03:08.190 --> 01:03:10.190
是从哪个UL里面

01:03:10.190 --> 01:03:11.190
来回去数据

01:03:11.190 --> 01:03:12.190
当然

01:03:12.190 --> 01:03:14.190
比如说它可以接受一个Date

01:03:14.190 --> 01:03:15.190
这个Date的什么意思呢

01:03:15.190 --> 01:03:17.190
就是你在访问这个请

01:03:17.190 --> 01:03:18.190
你在通过这个接口

01:03:18.190 --> 01:03:19.190
访问它的话

01:03:19.190 --> 01:03:21.190
你需要传递什么那个数据

01:03:21.190 --> 01:03:22.190
如果需要传递的话

01:03:22.190 --> 01:03:24.190
那把它当作一个参数

01:03:24.190 --> 01:03:25.190
一传就可以了

01:03:25.190 --> 01:03:26.190
那再后来就是

01:03:26.190 --> 01:03:27.190
我再让它接受个Dom

01:03:27.190 --> 01:03:28.190
就是Dom什么意思

01:03:28.190 --> 01:03:29.190
就是这个数据

01:03:29.190 --> 01:03:30.190
请求回来以后的话

01:03:30.190 --> 01:03:31.190
选到那

01:03:31.190 --> 01:03:32.190
但是这一块的话

01:03:32.190 --> 01:03:33.190
我们不是真正的

01:03:33.190 --> 01:03:34.190
去来进行这样的

01:03:34.190 --> 01:03:35.190
这个功能的实现

01:03:35.190 --> 01:03:37.190
我来去通过一种

01:03:37.190 --> 01:03:38.190
怎么说呢

01:03:38.190 --> 01:03:40.190
算是伪带码吧

01:03:40.190 --> 01:03:41.190
对吧

01:03:41.190 --> 01:03:42.190
来咱们来不正经的

01:03:42.190 --> 01:03:43.190
去写一写

01:03:43.190 --> 01:03:44.190
但是接下来

01:03:44.190 --> 01:03:46.190
也希望你能跟着我来

01:03:46.190 --> 01:03:47.190
去对这个带码

01:03:47.190 --> 01:03:49.190
产生一些的思考

01:03:49.190 --> 01:03:50.190
也考验一下

01:03:50.190 --> 01:03:51.190
大家这个阅读带码的一个能力

01:03:51.190 --> 01:03:53.190
如果说你能像写带码

01:03:53.190 --> 01:03:54.190
像写问扰扰对不对

01:03:54.190 --> 01:03:55.190
你写每句话的话

01:03:55.190 --> 01:03:56.190
你的逻辑基本上

01:03:56.190 --> 01:03:58.190
它都是顺畅的

01:03:58.190 --> 01:04:01.190
它都是能实施去通透的

01:04:01.190 --> 01:04:02.190
我觉得你在写

01:04:02.190 --> 01:04:03.190
一般的这样的一个

01:04:03.190 --> 01:04:04.190
诱逻辑和功能的时候

01:04:04.190 --> 01:04:05.190
应该没什么大问题了

01:04:05.190 --> 01:04:06.190
好

01:04:06.190 --> 01:04:07.190
那咱来看一下

01:04:07.190 --> 01:04:08.190
现在我假如

01:04:08.190 --> 01:04:10.190
从Doubler这个东西

01:04:10.190 --> 01:04:11.190
是GQR对吧

01:04:11.190 --> 01:04:12.190
我假如呢

01:04:12.190 --> 01:04:13.190
已经引入了它GQR

01:04:13.190 --> 01:04:15.190
我从Doubler.ax的方式

01:04:15.190 --> 01:04:16.190
来去访问数据

01:04:16.190 --> 01:04:17.190
那访问数据的话

01:04:17.190 --> 01:04:18.190
ok

01:04:18.190 --> 01:04:19.190
那有一个参数

01:04:19.190 --> 01:04:20.190
叫Ur2

01:04:20.190 --> 01:04:21.190
我把这个参数放到这边来

01:04:21.190 --> 01:04:22.190
那我再来一个data对吧

01:04:22.190 --> 01:04:24.190
data也是放到这边来

01:04:24.190 --> 01:04:25.190
传到这样的数据

01:04:25.190 --> 01:04:27.190
那这个ax里面

01:04:27.190 --> 01:04:28.190
一定有个方法

01:04:28.190 --> 01:04:29.190
叫sense的方法

01:04:29.190 --> 01:04:30.190
那这个方法的话

01:04:30.190 --> 01:04:31.190
咱们再下面

01:04:31.190 --> 01:04:32.190
方法里面

01:04:32.190 --> 01:04:33.190
如果一旦调生物的话

01:04:33.190 --> 01:04:34.190
它会不会出发

01:04:34.190 --> 01:04:35.190
对吧

01:04:35.190 --> 01:04:36.190
出发以后这种数据

01:04:36.190 --> 01:04:37.190
数据会往里面传

01:04:37.190 --> 01:04:39.190
那我在外界调用的时候的话

01:04:39.190 --> 01:04:40.190
我一定是这么来调用的

01:04:40.190 --> 01:04:41.190
那没有一只行

01:04:41.190 --> 01:04:42.190
可能说我这里的一个参数

01:04:42.190 --> 01:04:44.190
传递一个接口的Url对吧

01:04:44.190 --> 01:04:45.190
第二个参数

01:04:45.190 --> 01:04:46.190
比如说传递一下

01:04:46.190 --> 01:04:48.190
我要获取第几节的数据对吧

01:04:48.190 --> 01:04:49.190
第三个参数可能

01:04:49.190 --> 01:04:50.190
传递Url对不对

01:04:50.190 --> 01:04:51.190
来告诉你这个数据

01:04:51.190 --> 01:04:53.190
要在哪个里面去更新的

01:04:53.190 --> 01:04:55.190
那一旦调生它以后的话

01:04:55.190 --> 01:04:56.190
它就会执行对吧

01:04:56.190 --> 01:04:58.190
它一旦执行完以后呢

01:04:58.190 --> 01:04:59.190
好了

01:04:59.190 --> 01:05:01.190
它数据返回成功以后的话

01:05:01.190 --> 01:05:02.190
数据返回成功以后的话

01:05:02.190 --> 01:05:03.190
就会执行它

01:05:03.190 --> 01:05:05.190
那它一旦被执行以后

01:05:05.190 --> 01:05:06.190
那咱来看一下

01:05:06.190 --> 01:05:07.190
我在这里面要做一件事情

01:05:07.190 --> 01:05:09.190
比如说把这个json

01:05:09.190 --> 01:05:11.190
假如它返回的是一个zochart

01:05:11.190 --> 01:05:12.190
zochart那我问一个Url

01:05:12.190 --> 01:05:16.190
我通过这个json.paras对吧

01:05:16.190 --> 01:05:19.190
我把它先转成一个数组

01:05:19.190 --> 01:05:21.190
那个数组转出完以后

01:05:21.190 --> 01:05:23.190
这个数组转完以后的话

01:05:23.190 --> 01:05:25.190
我通过Url.forEach

01:05:25.190 --> 01:05:26.190
比如说forEach

01:05:26.190 --> 01:05:29.140
来去

01:05:29.140 --> 01:05:30.140
等会儿

01:05:31.140 --> 01:05:32.140
喝

01:05:32.140 --> 01:05:33.140
喝

01:05:34.140 --> 01:05:38.880
好

01:05:39.880 --> 01:05:40.880
来去呢

01:05:40.880 --> 01:05:43.880
不断去生成这样的一些zochart

01:05:43.880 --> 01:05:45.880
那怎么来生成呢

01:05:45.880 --> 01:05:46.880
比如说我在这

01:05:46.880 --> 01:05:47.880
我给html strd吧

01:05:47.880 --> 01:05:49.880
它是一个空的zochart

01:05:49.880 --> 01:05:50.880
那我们知道

01:05:50.880 --> 01:05:51.880
你在喝酒完以后

01:05:51.880 --> 01:05:52.880
这个数据它可能是这样的对吧

01:05:52.880 --> 01:05:55.880
那么通过这个Url.forEach以后

01:05:55.880 --> 01:05:57.880
实际上是把每个这样的一个数据

01:05:57.880 --> 01:05:58.880
都拿出来对不对

01:05:58.880 --> 01:05:59.880
都拿出来

01:05:59.880 --> 01:06:00.880
拿出来以后怎么办呢

01:06:00.880 --> 01:06:03.880
就我在这我html strd吧

01:06:03.880 --> 01:06:05.880
让它加等于什么加等于

01:06:05.880 --> 01:06:06.880
OK

01:06:06.880 --> 01:06:10.260
这填一个li

01:06:10.260 --> 01:06:11.260
对吧

01:06:11.260 --> 01:06:12.260
进行zochart一个拼接

01:06:12.260 --> 01:06:13.260
进行zochart一个拼接

01:06:13.260 --> 01:06:15.260
我只填li

01:06:15.260 --> 01:06:16.260
填li

01:06:16.260 --> 01:06:17.260
但是这我也得填zochart

01:06:17.260 --> 01:06:18.260
我的填zochart

01:06:19.260 --> 01:06:20.260
好

01:06:20.260 --> 01:06:21.260
直接填zochart

01:06:21.260 --> 01:06:23.760
好

01:06:23.760 --> 01:06:24.760
这是个li

01:06:24.760 --> 01:06:25.760
好

01:06:25.760 --> 01:06:26.760
那在这的话

01:06:26.760 --> 01:06:27.760
我拿到这个er1.name

01:06:27.760 --> 01:06:29.760
我只显示个name就行了

01:06:29.760 --> 01:06:30.760
比如说这么做

01:06:30.760 --> 01:06:31.760
那是不是我在这

01:06:31.760 --> 01:06:32.760
通过一个循环

01:06:32.760 --> 01:06:34.760
会把每个对象里面这个name

01:06:34.760 --> 01:06:35.760
都放到一个li之中

01:06:35.760 --> 01:06:37.760
并且每一圈循环中

01:06:37.760 --> 01:06:39.760
都会把这个上一个html str

01:06:39.760 --> 01:06:40.760
对吧

01:06:40.760 --> 01:06:42.760
那个zochart跟这次的相拼接

01:06:42.760 --> 01:06:43.760
那拼到最后有货的话

01:06:43.760 --> 01:06:44.760
那就是很多个li

01:06:44.760 --> 01:06:45.760
对吧

01:06:45.760 --> 01:06:47.760
拼上一个downzochart的

01:06:47.760 --> 01:06:49.760
最后把这个down的

01:06:49.760 --> 01:06:51.760
int hml

01:06:53.760 --> 01:06:56.760
让它等于一个html str

01:06:56.760 --> 01:06:57.760
当你这么等完以后

01:06:57.760 --> 01:06:58.760
你会发现一点

01:06:58.760 --> 01:06:59.760
发现什么呢

01:06:59.760 --> 01:07:01.760
发现其实我这么来写

01:07:01.760 --> 01:07:02.760
这个代码的话

01:07:02.760 --> 01:07:03.760
它就是两个功能

01:07:03.760 --> 01:07:04.760
它就是两个功能

01:07:04.760 --> 01:07:05.760
接到一体了

01:07:05.760 --> 01:07:06.760
什么功能呢

01:07:06.760 --> 01:07:08.760
首先它既有

01:07:08.760 --> 01:07:14.440
获取数据的功能

01:07:14.440 --> 01:07:15.440
对吧

01:07:15.440 --> 01:07:16.440
阿甲克斯对不对

01:07:16.440 --> 01:07:17.440
还有什么呢

01:07:17.440 --> 01:07:25.360
还有这个渲染数据的功能

01:07:25.360 --> 01:07:26.360
那个时候就说

01:07:26.360 --> 01:07:27.360
那我就这么写行不行

01:07:27.360 --> 01:07:28.360
没问题

01:07:28.360 --> 01:07:30.360
就我们学完设计模式的时候

01:07:30.360 --> 01:07:31.360
也不是要求你在

01:07:31.360 --> 01:07:32.360
任何一种开发情况下

01:07:32.360 --> 01:07:34.360
都使用设计模式

01:07:34.360 --> 01:07:36.360
因为你一旦使用它以后的话

01:07:36.360 --> 01:07:37.360
代码一定会变得

01:07:37.360 --> 01:07:39.360
至少代码量上

01:07:39.360 --> 01:07:40.360
会变得可能说

01:07:40.360 --> 01:07:41.360
在一定程度上

01:07:41.360 --> 01:07:43.360
它会比你这么写

01:07:43.360 --> 01:07:44.360
它要多

01:07:44.360 --> 01:07:45.360
因为你现在功能

01:07:45.360 --> 01:07:47.360
只是非常少了一些功能对不对

01:07:47.360 --> 01:07:48.360
非常少了一些功能的话

01:07:48.360 --> 01:07:49.360
你可以抬手就写

01:07:49.360 --> 01:07:51.360
就比如说你是一个万家对吧

01:07:51.360 --> 01:07:52.360
你抬手就能干一个墙

01:07:52.360 --> 01:07:53.360
这没问题

01:07:53.360 --> 01:07:55.360
因为你抬手你就干一个墙的话

01:07:55.360 --> 01:07:57.360
你不用那个太复杂的这种

01:07:57.360 --> 01:07:58.360
这种色录

01:07:58.360 --> 01:07:59.360
但如果说

01:07:59.360 --> 01:08:00.360
需要你去干一个房子的话

01:08:00.360 --> 01:08:02.360
那你就不能那么来做了

01:08:02.360 --> 01:08:03.360
比如你干房子的话

01:08:03.360 --> 01:08:04.360
可能说

01:08:04.360 --> 01:08:05.360
你能有这个乘重墙

01:08:05.360 --> 01:08:06.360
那有粮

01:08:06.360 --> 01:08:08.360
哪个地方是主卧

01:08:08.360 --> 01:08:09.360
哪个地方是自卧对不对

01:08:09.360 --> 01:08:11.360
那这种情况变得复杂以后的话

01:08:11.360 --> 01:08:13.360
你就必须用套路它来去做了

01:08:14.360 --> 01:08:16.360
但这种小功能的情况下的话

01:08:16.360 --> 01:08:18.360
其实你没有必要强行去追求实际模式

01:08:18.360 --> 01:08:19.360
但在这一块的话

01:08:19.360 --> 01:08:21.360
我们为了去演示一下对吧

01:08:21.360 --> 01:08:23.360
好了那现在我来说一下

01:08:23.360 --> 01:08:24.360
好

01:08:24.360 --> 01:08:25.360
因为你这个功能

01:08:25.360 --> 01:08:27.360
确实是两个功能进行这样的一个叠加

01:08:27.360 --> 01:08:31.360
它确实没有符合单一职责原则

01:08:31.360 --> 01:08:33.360
所以说它的复杂度的话

01:08:33.360 --> 01:08:34.360
可能在咱们看来

01:08:34.360 --> 01:08:35.360
会高一些对不对

01:08:35.360 --> 01:08:36.360
会高一些

01:08:36.360 --> 01:08:38.360
那高一些带来这样的一些问题

01:08:38.360 --> 01:08:39.360
它都有什么呢

01:08:39.360 --> 01:08:40.360
比如说我现在

01:08:40.360 --> 01:08:42.360
我现在要再加功能

01:08:42.360 --> 01:08:43.360
再加功能的话

01:08:43.360 --> 01:08:45.360
好了那现在加什么功能呢

01:08:45.360 --> 01:08:47.360
我来加一个就是

01:08:47.360 --> 01:08:49.360
页面第一次打开的时候

01:08:49.360 --> 01:08:51.360
页面第一次打开的时候

01:08:51.360 --> 01:08:54.360
它先从这个缓存里面去获取数据

01:08:54.360 --> 01:08:56.360
比如说咱们

01:08:56.360 --> 01:08:59.360
要在这个local storage里面

01:08:59.360 --> 01:09:01.360
做数据的一个缓存

01:09:01.360 --> 01:09:02.360
它先从这里面获取数据

01:09:02.360 --> 01:09:04.360
那如果说这里面有数据的话

01:09:04.360 --> 01:09:06.360
它就从缓存中来取数据

01:09:06.360 --> 01:09:07.360
没有的话怎么办呢

01:09:07.360 --> 01:09:09.360
它就从网络中来获取数据

01:09:09.360 --> 01:09:11.360
那这是它这个第一次打开以后

01:09:11.360 --> 01:09:12.360
一定要用它它就这么做

01:09:12.360 --> 01:09:14.360
那如果把这个功能也加到你们去的话

01:09:14.360 --> 01:09:17.360
那好了我们不按单一职责原则来做

01:09:17.360 --> 01:09:19.360
不按单一职责原则它来做的话

01:09:19.360 --> 01:09:21.360
我是不是要做一个判断对不对

01:09:21.360 --> 01:09:24.360
但你判断的话至少你得先这么来

01:09:24.360 --> 01:09:27.360
就是一旦你或许玩这个数据的话

01:09:27.360 --> 01:09:28.360
你应该怎么做呢

01:09:28.360 --> 01:09:30.360
应该缓存数据对不对

01:09:30.360 --> 01:09:32.360
那缓存数据其实这也是个功能对不对

01:09:32.360 --> 01:09:35.360
缓存数据那local storage

01:09:37.360 --> 01:09:38.360
local storage

01:09:39.360 --> 01:09:44.360
比如说有个叫做set item

01:09:44.360 --> 01:09:45.360
set item对吧

01:09:45.360 --> 01:09:46.360
好在这比如说

01:09:46.360 --> 01:09:48.360
数据类型叫做list类型对吧

01:09:48.360 --> 01:09:50.360
我来说把这个json当数据放到里面来

01:09:50.360 --> 01:09:52.360
缓存数据

01:09:52.360 --> 01:09:54.360
这也是个功能对吧

01:09:54.360 --> 01:09:56.360
那随着我越写越往里面加功能

01:09:56.360 --> 01:09:59.360
它自然而整个代码的复杂程度

01:09:59.360 --> 01:10:00.360
它就越高对吧

01:10:00.360 --> 01:10:01.360
功能

01:10:01.360 --> 01:10:03.360
好那当然我在

01:10:03.360 --> 01:10:05.360
不是说我在这边之前说对吧

01:10:05.360 --> 01:10:07.360
让它有取缓存的功能

01:10:07.360 --> 01:10:10.360
那说如果说这个页面第一次执行的时候

01:10:10.360 --> 01:10:12.360
那它只能怎么样

01:10:12.360 --> 01:10:13.360
它只能先判断一下

01:10:13.360 --> 01:10:15.360
你当前这个缓存中

01:10:15.360 --> 01:10:17.360
是否有这样的一个数据

01:10:17.360 --> 01:10:21.360
如果你有这个数据的话怎么办呢

01:10:21.360 --> 01:10:22.360
你有数据的话

01:10:22.360 --> 01:10:25.360
我自然而要去取一下对吧

01:10:25.360 --> 01:10:26.360
我通过它来获取一下

01:10:26.360 --> 01:10:28.360
如果发现你不微空的情况下的话

01:10:28.360 --> 01:10:29.360
好那我要这么做对吧

01:10:29.360 --> 01:10:33.360
我json.prse paris prse

01:10:34.360 --> 01:10:36.360
啊把插一取啊

01:10:36.360 --> 01:10:38.360
取完以后

01:10:38.360 --> 01:10:39.360
好了

01:10:39.360 --> 01:10:40.360
你会发现一下

01:10:40.360 --> 01:10:42.360
我是不是也要去渲染对不对

01:10:42.360 --> 01:10:43.360
也要去渲染对吧

01:10:43.360 --> 01:10:44.360
好也要去渲染的话

01:10:44.360 --> 01:10:45.360
OK

01:10:45.360 --> 01:10:46.360
我现在是不是都这么去写啊

01:10:46.360 --> 01:10:48.360
把插肯州C一下对不对

01:10:48.360 --> 01:10:49.360
为了接受时间对吧

01:10:49.360 --> 01:10:51.360
我肯州C我肯州V

01:10:51.360 --> 01:10:52.360
我来这么去写对不对

01:10:52.360 --> 01:10:53.360
但你发现

01:10:53.360 --> 01:10:55.360
你不按单一指责员来做的话对吧

01:10:55.360 --> 01:10:58.360
你没有尽可能的把这个功能拆分来的话

01:10:58.360 --> 01:11:01.360
你发现这种时候代码的容移度也出来了对吧

01:11:01.360 --> 01:11:04.360
代码的容移度也出来了

01:11:04.360 --> 01:11:07.360
这个东西跟这东西是不是一样的对不对

01:11:07.360 --> 01:11:09.360
它也是一样的吧

01:11:09.360 --> 01:11:11.360
OK那现在的话确实

01:11:11.360 --> 01:11:13.360
代码其实写到这的话

01:11:13.360 --> 01:11:16.360
它这个复杂程度一定没有这么高对不对

01:11:16.360 --> 01:11:17.360
你这么写的话

01:11:17.360 --> 01:11:19.360
你一定能读得明白对吧

01:11:19.360 --> 01:11:20.360
但你今天能读得明白

01:11:20.360 --> 01:11:21.360
你明天能吗对吧

01:11:21.360 --> 01:11:23.360
你能读明白别人能吗对吧

01:11:23.360 --> 01:11:25.360
但你想再加一些功能的话

01:11:25.360 --> 01:11:27.360
那是不是你还要尽可能的

01:11:27.360 --> 01:11:29.360
把这一大坨读明白以后你再加

01:11:29.360 --> 01:11:31.360
那当然你这个维护的成本

01:11:31.360 --> 01:11:33.360
是不是自然而然就高了一些

01:11:33.360 --> 01:11:35.360
而且你这个复用率是不是就低了一些

01:11:35.360 --> 01:11:36.360
你看

01:11:36.360 --> 01:11:38.360
这本来它可以抽成一个功能对吧

01:11:38.360 --> 01:11:40.360
抽成一个含住来复用的对吧

01:11:40.360 --> 01:11:41.360
但是怎么样呢

01:11:41.360 --> 01:11:42.360
你就重新写一遍对吧

01:11:42.360 --> 01:11:44.360
那你说这个功能没有达到复用

01:11:44.360 --> 01:11:46.360
那你来看一下这啊

01:11:46.360 --> 01:11:47.360
这

01:11:48.360 --> 01:11:49.360
如果复杂度高的话

01:11:49.360 --> 01:11:50.360
怎么样

01:11:50.360 --> 01:11:51.360
可维护性差的

01:11:51.360 --> 01:11:53.360
那你说别人再去帮你去维护他

01:11:53.360 --> 01:11:54.360
帮你修改的时候

01:11:54.360 --> 01:11:56.360
可读性非常低对吧

01:11:56.360 --> 01:11:58.360
那你想去维护一下的话

01:11:58.360 --> 01:11:59.360
读明白对不对

01:11:59.360 --> 01:12:00.360
那自然而然的话

01:12:00.360 --> 01:12:01.360
他维护性他一定是比较差的

01:12:01.360 --> 01:12:02.360
而且呢

01:12:02.360 --> 01:12:04.360
你复用性一定他是很差的对吧

01:12:04.360 --> 01:12:05.360
你看咱们这

01:12:05.360 --> 01:12:06.360
咱们说说说

01:12:06.360 --> 01:12:08.360
咱们都说那么对吧

01:12:08.360 --> 01:12:10.360
你这东西容易度他都

01:12:10.360 --> 01:12:11.360
他出来了

01:12:11.360 --> 01:12:12.360
你自然而然的话

01:12:12.360 --> 01:12:13.360
你没有办法去

01:12:13.360 --> 01:12:14.360
很好的去

01:12:14.360 --> 01:12:16.360
高效的重复利用这个功能

01:12:16.360 --> 01:12:18.360
那除此之外的话

01:12:18.360 --> 01:12:19.360
不易扩展

01:12:19.360 --> 01:12:20.360
不易扩展是什么意思呢

01:12:20.360 --> 01:12:21.360
好

01:12:21.360 --> 01:12:23.360
这个人现在你要再加点东西对吧

01:12:23.360 --> 01:12:24.360
再加什么呢

01:12:24.360 --> 01:12:25.360
比如说你再加

01:12:25.360 --> 01:12:26.360
就个按钮

01:12:26.360 --> 01:12:27.360
就按钮

01:12:28.360 --> 01:12:30.360
比如说一旦你这点击按钮对吧

01:12:30.360 --> 01:12:32.360
一旦点击按钮了

01:12:32.360 --> 01:12:33.360
你要怎么样呢

01:12:33.360 --> 01:12:34.360
你要去

01:12:35.360 --> 01:12:36.360
从网络

01:12:36.360 --> 01:12:38.360
就是从网络中

01:12:38.360 --> 01:12:40.360
真正的去获取数据

01:12:40.360 --> 01:12:41.360
从网络中

01:12:41.360 --> 01:12:42.360
真正的去获取数据

01:12:42.360 --> 01:12:44.360
对这一块的话我没有写

01:12:44.360 --> 01:12:46.360
这一块的话我到哪个 else

01:12:46.360 --> 01:12:47.360
来个备论

01:12:47.360 --> 01:12:48.360
抱歉

01:12:48.360 --> 01:12:49.360
咱们再回到这

01:12:49.360 --> 01:12:50.360
回到这的话

01:12:50.360 --> 01:12:51.360
咱把这个逻辑

01:12:51.360 --> 01:12:52.360
再简单去梳理一下

01:12:52.360 --> 01:12:53.360
再简单去梳理一下

01:12:53.360 --> 01:12:55.360
如果洗到这你懵了

01:12:55.360 --> 01:12:56.360
就是也挺好的

01:12:56.360 --> 01:12:57.360
因为咱以为

01:12:57.360 --> 01:12:59.360
这不是一种好的写法对吧

01:12:59.360 --> 01:13:00.360
你懵

01:13:00.360 --> 01:13:01.360
那就证明这种写法

01:13:01.360 --> 01:13:02.360
它不

01:13:02.360 --> 01:13:04.360
它不足够好对不对

01:13:04.360 --> 01:13:06.360
你的可读性它也没那么强

01:13:06.360 --> 01:13:07.360
那好OK那咱这样

01:13:07.360 --> 01:13:09.360
咱为了能让你再明白一下的话

01:13:09.360 --> 01:13:11.360
再把这东西再来重新梳理一下对吧

01:13:11.360 --> 01:13:13.360
要说这个页面你打开以后的话

01:13:13.360 --> 01:13:14.360
它会怎么样

01:13:14.360 --> 01:13:15.360
它一定会调一次它对吧

01:13:15.360 --> 01:13:16.360
调一次它的话

01:13:16.360 --> 01:13:17.360
我们的需求是这样

01:13:17.360 --> 01:13:18.360
那第一次的话

01:13:18.360 --> 01:13:19.360
它一定要怎么样

01:13:19.360 --> 01:13:21.360
一定要从网络中来获取数据对吧

01:13:21.360 --> 01:13:22.360
网络中有数据的话

01:13:22.360 --> 01:13:23.360
大家能怎么样

01:13:23.360 --> 01:13:25.360
它就进到A5判断之中

01:13:25.360 --> 01:13:27.360
把数据取出来对吧

01:13:27.360 --> 01:13:29.360
取出来以后给它转成数组

01:13:29.360 --> 01:13:30.360
再去渲染

01:13:30.360 --> 01:13:33.360
那如果说没有数据的话

01:13:33.360 --> 01:13:34.360
那证明说你一次都没有

01:13:34.360 --> 01:13:35.360
通过网络请求来

01:13:35.360 --> 01:13:37.360
那自然而然我要

01:13:37.360 --> 01:13:38.360
通过它对吧

01:13:38.360 --> 01:13:40.360
通过它网络请求把数据

01:13:40.360 --> 01:13:41.360
请回来对吧

01:13:42.360 --> 01:13:43.360
给它取回来

01:13:43.360 --> 01:13:44.360
取回来之后再渲染

01:13:44.360 --> 01:13:45.360
渲染之后呢

01:13:45.360 --> 01:13:46.360
当然你要给它再缓存对吧

01:13:46.360 --> 01:13:49.360
方便你下次再取它的时候

01:13:49.360 --> 01:13:51.360
或者说你下次再打开页面的时候

01:13:51.360 --> 01:13:53.360
它从缓存中把数据给取一取

01:13:53.360 --> 01:13:55.360
当然我这里面再增添一个按钮

01:13:55.360 --> 01:13:57.360
你不能说每次打开的时候

01:13:57.360 --> 01:13:59.360
就是只有第一次的时候怎么样

01:13:59.360 --> 01:14:02.360
它先取这样的一个网络的数据

01:14:02.360 --> 01:14:03.360
而之后的话

01:14:03.360 --> 01:14:05.360
每次打开都从这个缓存中取

01:14:05.360 --> 01:14:06.360
你给这个按钮

01:14:06.360 --> 01:14:07.360
这个按钮的话

01:14:07.360 --> 01:14:08.360
能让它对吧

01:14:08.360 --> 01:14:10.360
从这个缓存中

01:14:10.360 --> 01:14:13.360
能让它从网络中直接获取数据

01:14:13.360 --> 01:14:14.360
那如果是这样的情况下

01:14:14.360 --> 01:14:15.360
再来看

01:14:15.360 --> 01:14:16.360
我现在是不是要给这个button

01:14:16.360 --> 01:14:17.360
来绑定个实践

01:14:18.360 --> 01:14:19.360
我现在oncling一下

01:14:19.360 --> 01:14:20.360
oncling一下

01:14:20.360 --> 01:14:21.360
那到这的话

01:14:21.360 --> 01:14:23.360
当你绑定完实践以后

01:14:23.360 --> 01:14:25.360
比如说我vio来执行了

01:14:25.360 --> 01:14:26.360
g1

01:14:27.360 --> 01:14:28.360
g1它

01:14:29.360 --> 01:14:31.360
我现在是配置

01:14:31.360 --> 01:14:33.360
配置等于2

01:14:33.360 --> 01:14:35.360
这来个ur

01:14:35.360 --> 01:14:37.360
这是来个ur

01:14:37.360 --> 01:14:38.360
那你这么g1以后的话

01:14:38.360 --> 01:14:39.360
你会发现

01:14:39.360 --> 01:14:40.360
我没有把这个功能里面

01:14:40.360 --> 01:14:42.360
进行这样的一个新增

01:14:42.360 --> 01:14:43.360
它还依旧怎么样

01:14:43.360 --> 01:14:44.360
依旧是取缓存

01:14:44.360 --> 01:14:45.360
因为这个缓存中

01:14:45.360 --> 01:14:46.360
确实是有数据的

01:14:46.360 --> 01:14:47.360
那由于说

01:14:47.360 --> 01:14:49.360
我想达成我的功能

01:14:49.360 --> 01:14:50.360
想点击按钮

01:14:50.360 --> 01:14:52.360
就可以从网络中获取数据

01:14:52.360 --> 01:14:53.360
那我势必要怎么样

01:14:53.360 --> 01:14:54.360
在这里面再改一改

01:14:54.360 --> 01:14:55.360
怎么再改呢

01:14:55.360 --> 01:14:56.360
那好了你会发现

01:14:56.360 --> 01:14:58.360
那我就再增加一个flag

01:14:58.360 --> 01:14:59.360
对吧

01:14:59.360 --> 01:15:00.360
flag什么意思呢

01:15:00.360 --> 01:15:02.360
如果flag是出的情况下的话

01:15:02.360 --> 01:15:04.360
我自己来规定对吧

01:15:04.360 --> 01:15:06.360
如果flag是出的情况下的话

01:15:06.360 --> 01:15:08.360
我就希望它从网络取

01:15:08.360 --> 01:15:09.360
对吧

01:15:09.360 --> 01:15:10.360
如果不是出的情况下的话

01:15:10.360 --> 01:15:12.360
它就从这儿取对不对

01:15:12.360 --> 01:15:13.360
那我可以怎么做

01:15:13.360 --> 01:15:14.360
我可以怎么做

01:15:14.360 --> 01:15:15.360
你可以发现

01:15:15.360 --> 01:15:16.360
单独增加这一个功能情况下的话

01:15:16.360 --> 01:15:21.360
整个这样的一个逻辑

01:15:21.360 --> 01:15:23.360
可能变得又复杂一点

01:15:23.360 --> 01:15:25.360
那你再进行这样的一个扩展

01:15:25.360 --> 01:15:27.360
去添加的时候

01:15:27.360 --> 01:15:29.360
难度系数应更高

01:15:29.360 --> 01:15:30.360
又更高了一些对吧

01:15:30.360 --> 01:15:33.360
它不易去进行这样的一个扩展

01:15:33.360 --> 01:15:35.360
而且一旦逻辑它更复杂以后的话

01:15:35.360 --> 01:15:36.360
就容易它出错

01:15:36.360 --> 01:15:38.360
别人堵起来也费劲

01:15:38.360 --> 01:15:39.360
现在咱看一下

01:15:39.360 --> 01:15:41.360
如果你想能达到这样的需求

01:15:41.360 --> 01:15:42.360
你觉得应该怎么做

01:15:42.360 --> 01:15:43.360
来拖去

01:15:43.360 --> 01:15:44.360
来拖去

01:15:46.360 --> 01:15:48.360
跟你平时的话就比较像对吧

01:15:48.360 --> 01:15:49.360
跟你比较像的话

01:15:49.360 --> 01:15:51.360
证明你平时写的就不对对不对

01:15:51.360 --> 01:15:54.890
来看一下

01:15:56.890 --> 01:15:58.890
那你这么写代码的话

01:15:58.890 --> 01:15:59.890
你可以

01:15:59.890 --> 01:16:01.890
我说可以完成你这样的一个

01:16:01.890 --> 01:16:08.150
可以完成你基本开发的需求

01:16:08.150 --> 01:16:10.150
但指定不是一个好的代码

01:16:10.150 --> 01:16:11.150
对吧

01:16:11.150 --> 01:16:12.150
现在就说

01:16:12.150 --> 01:16:13.150
如果你想这么来搞的话

01:16:13.150 --> 01:16:14.150
你怎么办

01:16:16.150 --> 01:16:17.150
第一天写的

01:16:17.150 --> 01:16:18.150
第二天就看不懂对吧

01:16:18.150 --> 01:16:19.150
不仅你看不懂

01:16:20.150 --> 01:16:22.150
你说你不维护这个项目

01:16:22.150 --> 01:16:23.150
以后交给别人他来去

01:16:23.150 --> 01:16:24.150
维护对吧

01:16:24.150 --> 01:16:25.150
别人杀你的心

01:16:25.150 --> 01:16:26.150
这都有了

01:16:26.150 --> 01:16:27.150
你居然这么来写对吧

01:16:29.150 --> 01:16:30.150
来看一下

01:16:30.150 --> 01:16:32.150
如果说让你来添加的话

01:16:32.150 --> 01:16:34.150
按照我这个逻辑来对吧

01:16:34.150 --> 01:16:36.150
按照我这个逻辑来

01:16:36.150 --> 01:16:39.150
怎么来维护呢对吧

01:16:39.150 --> 01:16:41.150
那指定是你个代码

01:16:41.150 --> 01:16:42.150
结构

01:16:42.150 --> 01:16:44.150
这个逻辑包括这样的关系

01:16:44.150 --> 01:16:45.150
数据的更好一些

01:16:45.150 --> 01:16:46.150
才方便你维护了

01:16:46.150 --> 01:16:47.150
对不对

01:16:47.150 --> 01:16:48.150
咱讲的不就是这个吗

01:16:48.150 --> 01:16:51.150
咱讲的就是按照原则来去做这些事

01:16:51.150 --> 01:16:53.150
咱先不按原则去来做事情

01:16:53.150 --> 01:16:54.150
咱人性一次行不行

01:16:54.150 --> 01:16:56.150
我就说这样一个蓄佑对吧

01:16:56.150 --> 01:16:57.150
点你按钮

01:16:57.150 --> 01:17:01.150
第一次在执行的时候

01:17:01.150 --> 01:17:04.150
当你刷新页面的时候对吧

01:17:04.150 --> 01:17:05.150
他先整他对吧

01:17:05.150 --> 01:17:07.150
那我们说让他就是

01:17:07.150 --> 01:17:09.150
第一次在刷新页面

01:17:09.150 --> 01:17:11.150
或者说他一进页面的时候

01:17:11.150 --> 01:17:12.150
他要先取缓存

01:17:12.150 --> 01:17:14.150
缓存没有的话才走网络

01:17:14.150 --> 01:17:15.150
但走网络以后的话

01:17:15.150 --> 01:17:17.150
他会把数据缓存出来

01:17:17.150 --> 01:17:19.150
你第二次再刷新的时候

01:17:19.150 --> 01:17:20.150
他怎么样了

01:17:20.150 --> 01:17:22.150
你看缓存说有数据

01:17:22.150 --> 01:17:23.150
他就要取缓存了对不对

01:17:23.150 --> 01:17:24.150
但是这个时候

01:17:24.150 --> 01:17:25.150
如果当我点按钮的时候

01:17:25.150 --> 01:17:27.150
我还希望他怎么样

01:17:27.150 --> 01:17:28.150
从这边去取

01:17:28.150 --> 01:17:30.150
是不是我要在这里面增加一个flag对吧

01:17:30.150 --> 01:17:33.150
因为这个因素和变量多了

01:17:33.150 --> 01:17:34.150
那我怎么办呢

01:17:34.150 --> 01:17:35.150
就增加一个flag对吧

01:17:35.150 --> 01:17:37.150
这个flag一旦多了

01:17:37.150 --> 01:17:38.150
那我是说这里面的东西

01:17:38.150 --> 01:17:39.150
已经变得复杂了

01:17:39.150 --> 01:17:41.150
因为你这个参数多了

01:17:41.150 --> 01:17:44.150
那当然你要处理的参数就多了对吧

01:17:44.150 --> 01:17:46.150
那你要处理的参数

01:17:46.150 --> 01:17:47.150
参数多了

01:17:47.150 --> 01:17:50.150
那指定是你这个逻辑会变得比之前

01:17:50.150 --> 01:17:51.150
要更复杂一些

01:17:51.150 --> 01:17:52.150
那我可以在这这么做

01:17:52.150 --> 01:17:53.150
好吧

01:17:53.150 --> 01:17:56.150
那flag去判断一下

01:17:56.150 --> 01:17:58.150
比如说你点这个按钮对吧

01:17:58.150 --> 01:17:59.150
边点了

01:17:59.150 --> 01:18:00.150
点完以后

01:18:00.150 --> 01:18:02.150
就说你传个参数是一个处吧

01:18:02.150 --> 01:18:03.150
是个处吧

01:18:03.150 --> 01:18:04.150
如果是处情况下好了

01:18:04.150 --> 01:18:07.150
即使你有缓存数据能取得出来

01:18:07.150 --> 01:18:09.150
它是处的吧

01:18:09.150 --> 01:18:12.460
但怎么样

01:18:12.460 --> 01:18:16.770
即使它是处的话

01:18:16.770 --> 01:18:18.770
我在这给flag取个非对吧

01:18:18.770 --> 01:18:20.770
非处是一个false对吧

01:18:20.770 --> 01:18:22.770
你看你点按钮你传出对吧

01:18:22.770 --> 01:18:24.770
好了你现在取个非对吧

01:18:24.770 --> 01:18:27.770
那它也不会进到这个判断中去取缓存

01:18:27.770 --> 01:18:28.770
而是怎么样

01:18:28.770 --> 01:18:30.770
而是在这里

01:18:30.770 --> 01:18:32.770
而是在这里去走网络去取了

01:18:32.770 --> 01:18:33.770
对吧去取取了

01:18:33.770 --> 01:18:34.770
变着急

01:18:34.770 --> 01:18:37.770
现在咱们把这些东西再来加加对吧

01:18:37.770 --> 01:18:38.770
还没完

01:18:38.770 --> 01:18:40.770
比如说过两天去又它们变了对吧

01:18:40.770 --> 01:18:41.770
怎么变变了

01:18:41.770 --> 01:18:43.770
所以这回你取缓存的数据

01:18:43.770 --> 01:18:45.770
你取缓存的数据

01:18:45.770 --> 01:18:47.770
我不让你显示li

01:18:47.770 --> 01:18:51.770
我让你显示he

01:18:51.770 --> 01:18:52.770
h1

01:18:52.770 --> 01:18:54.770
那是不是害得再回去去改一改

01:18:54.770 --> 01:18:56.770
是吧害得再改一改

01:18:56.770 --> 01:18:58.770
你是不是害得回去去读代码

01:18:58.770 --> 01:18:59.770
对吧

01:18:59.770 --> 01:19:01.770
那比如说再加功能对吧

01:19:01.770 --> 01:19:04.770
你又增添了离些缓存应用对吧

01:19:04.770 --> 01:19:06.770
离些缓存应用是什么意思

01:19:06.770 --> 01:19:09.770
就是如果没网的情况下对吧

01:19:09.770 --> 01:19:11.770
你点按钮也不知道是

01:19:11.770 --> 01:19:13.770
你点按钮

01:19:14.770 --> 01:19:16.770
不是说现在已经很恶心人对吧

01:19:16.770 --> 01:19:17.770
不是说你再增加

01:19:17.770 --> 01:19:18.770
增加什么增加说

01:19:18.770 --> 01:19:21.770
现在如果它是离线缓存

01:19:21.770 --> 01:19:23.770
是离线缓存的时候

01:19:23.770 --> 01:19:24.770
不是这样

01:19:24.770 --> 01:19:26.770
不是说是你离线的情况下的话

01:19:26.770 --> 01:19:29.770
你就必须从缓存中取

01:19:29.770 --> 01:19:31.770
如果不取的话你就谈一个乱

01:19:31.770 --> 01:19:32.770
当然了

01:19:32.770 --> 01:19:33.770
如果说你再线

01:19:33.770 --> 01:19:35.770
你有网的情况下对不对

01:19:35.770 --> 01:19:36.770
你不是离线情况下

01:19:36.770 --> 01:19:37.770
有网情况下的话对吧

01:19:37.770 --> 01:19:38.770
你点它

01:19:38.770 --> 01:19:39.770
它才怎么样

01:19:39.770 --> 01:19:41.770
它才走网络对吧

01:19:41.770 --> 01:19:43.770
那在这边你是不是还要再增添

01:19:43.770 --> 01:19:44.770
叛乱

01:19:44.770 --> 01:19:46.770
叛乱当前是否离线

01:19:46.770 --> 01:19:48.770
叛乱什么就是那个叫

01:19:48.770 --> 01:19:50.770
navigator对吧

01:19:50.770 --> 01:19:52.770
vi.tv对吧

01:19:52.770 --> 01:19:59.860
online

01:19:59.860 --> 01:20:00.860
online

01:20:00.860 --> 01:20:01.860
是吧同学

01:20:03.860 --> 01:20:04.860
来同学

01:20:04.860 --> 01:20:05.860
给个灰烟

01:20:05.860 --> 01:20:07.860
你之前在写的码的时候

01:20:07.860 --> 01:20:09.860
有没有同学这么写过

01:20:09.860 --> 01:20:12.880
来请问一下

01:20:12.880 --> 01:20:13.880
写过的同学

01:20:13.880 --> 01:20:14.880
举个手

01:20:14.880 --> 01:20:16.880
就是大致这么写对吧

01:20:16.880 --> 01:20:18.880
把一些逻辑全房里面写对不对

01:20:18.880 --> 01:20:19.880
写过的同学

01:20:19.880 --> 01:20:20.880
别害羞

01:20:20.880 --> 01:20:22.880
写一

01:20:22.880 --> 01:20:23.880
放一

01:20:23.880 --> 01:20:24.880
我来看看

01:20:24.880 --> 01:20:36.100
你看是不是还是有很多同学都这么写

01:20:36.100 --> 01:20:37.100
对吧

01:20:37.100 --> 01:20:38.100
那像

01:20:38.100 --> 01:20:39.100
当你这么写完以后的话

01:20:39.100 --> 01:20:40.100
我那个去对不对

01:20:40.100 --> 01:20:42.100
你要修改一下

01:20:42.100 --> 01:20:43.100
你要修改一下

01:20:43.100 --> 01:20:45.100
你修改一下

01:20:45.100 --> 01:20:46.100
从头到尾读不读

01:20:46.100 --> 01:20:48.100
刚才复杂存中高了以后的话

01:20:48.100 --> 01:20:49.100
你就可能欠一发

01:20:49.100 --> 01:20:51.100
而动全身对不对

01:20:51.100 --> 01:20:52.100
维护一定不好维护

01:20:52.100 --> 01:20:53.100
你读都不好读

01:20:53.100 --> 01:20:54.100
你改也不好带

01:20:55.100 --> 01:20:56.100
你更别谈服用性了

01:20:56.100 --> 01:20:57.100
所以说

01:20:57.100 --> 01:20:58.100
这一块

01:20:58.100 --> 01:20:59.100
以后

01:20:59.100 --> 01:21:00.100
我讲完实际模式

01:21:00.100 --> 01:21:02.100
如果你再这么写代码的话

01:21:02.100 --> 01:21:04.100
你就别说我教过你行不行

01:21:04.100 --> 01:21:05.100
你就是直接说

01:21:05.100 --> 01:21:07.100
你是你邓哥教的来学生

01:21:07.100 --> 01:21:08.100
你别说是我教的

01:21:16.240 --> 01:21:17.240
所以说怎么办

01:21:17.240 --> 01:21:18.240
说怎么办

01:21:18.240 --> 01:21:19.240
单一

01:21:19.240 --> 01:21:20.240
或者说

01:21:20.240 --> 01:21:21.240
这些原理

01:21:21.240 --> 01:21:23.240
这些原理

01:21:23.240 --> 01:21:24.240
就是告诉你们

01:21:24.240 --> 01:21:26.240
做事尽量不要这么做

01:21:27.240 --> 01:21:28.240
咱们还没有讲到

01:21:28.240 --> 01:21:29.240
实际模式最快

01:21:29.240 --> 01:21:30.240
对不对

01:21:30.240 --> 01:21:31.240
咱们只是说

01:21:31.240 --> 01:21:32.240
现在告诉你

01:21:32.240 --> 01:21:34.240
我们要单一职责

01:21:34.240 --> 01:21:35.240
我们要把这些功能

01:21:35.240 --> 01:21:36.240
尽可能的拆分

01:21:36.240 --> 01:21:37.240
对不对

01:21:37.240 --> 01:21:38.240
那我们没有学到

01:21:38.240 --> 01:21:39.240
实际模式的话

01:21:39.240 --> 01:21:40.240
我们是也可以按照

01:21:40.240 --> 01:21:41.240
这个原理去

01:21:41.240 --> 01:21:42.240
他去做事

01:21:42.240 --> 01:21:43.240
是吧

01:21:43.240 --> 01:21:44.240
那我是这样的

01:21:44.240 --> 01:21:45.240
如果是这样的情况下的话

01:21:45.240 --> 01:21:46.240
好

01:21:46.240 --> 01:21:47.240
咱来看看

01:21:47.240 --> 01:21:49.240
我们如何把它拆分

01:21:49.240 --> 01:21:51.240
如何把它拆分

01:21:51.240 --> 01:21:52.240
来看一下

01:21:52.240 --> 01:21:54.240
不是说我现在

01:21:54.240 --> 01:21:55.240
按照

01:21:55.240 --> 01:21:56.240
现在是按照

01:21:56.240 --> 01:21:57.240
单一

01:21:57.240 --> 01:21:58.240
职责

01:21:59.240 --> 01:22:00.240
原责

01:22:02.240 --> 01:22:03.240
很像一个喊来说

01:22:03.240 --> 01:22:04.240
对吧

01:22:04.240 --> 01:22:05.240
一个功能只做一件事

01:22:05.240 --> 01:22:06.240
那比如说我现在

01:22:07.240 --> 01:22:08.240
我写

01:22:08.240 --> 01:22:09.240
按照对象的方式

01:22:09.240 --> 01:22:10.240
我来写行吧

01:22:10.240 --> 01:22:11.240
我这个方式

01:22:11.240 --> 01:22:12.240
方式

01:22:16.240 --> 01:22:17.240
方式

01:22:17.240 --> 01:22:18.240
方式的一个

01:22:18.240 --> 01:22:19.240
比如说叫做

01:22:19.240 --> 01:22:20.240
get date

01:22:25.560 --> 01:22:27.560
叫get date

01:22:27.560 --> 01:22:28.560
这边

01:22:28.560 --> 01:22:29.560
我写个构造

01:22:29.560 --> 01:22:30.560
含书的方式

01:22:30.560 --> 01:22:31.560
我来去做行吧

01:22:31.560 --> 01:22:32.560
写个构造的

01:22:32.560 --> 01:22:33.560
含书的方式

01:22:33.560 --> 01:22:34.560
我们来先做一做

01:22:34.560 --> 01:22:36.560
那这个首先是一个

01:22:36.560 --> 01:22:37.560
get date

01:22:37.560 --> 01:22:38.560
那构造含书的话

01:22:38.560 --> 01:22:39.560
我希望是个大写

01:22:40.560 --> 01:22:41.560
get date

01:22:41.560 --> 01:22:42.560
但它需要往里面

01:22:42.560 --> 01:22:43.560
传几个参数

01:22:43.560 --> 01:22:44.560
比如一个参数

01:22:44.560 --> 01:22:45.560
叫做

01:22:45.560 --> 01:22:46.560
这个

01:22:46.560 --> 01:22:47.560
call

01:22:48.560 --> 01:22:49.560
back

01:22:49.560 --> 01:22:50.560
callbackary

01:22:51.560 --> 01:22:52.560
回调数

01:22:53.560 --> 01:22:55.560
当它执行完以后

01:22:55.560 --> 01:22:57.560
它执行完以后的话

01:22:57.560 --> 01:22:58.560
它数据获取到了

01:22:58.560 --> 01:22:59.560
但获取到以后

01:22:59.560 --> 01:23:00.560
它一定怎么样

01:23:00.560 --> 01:23:02.560
它一定要跟别人行程一定

01:23:02.560 --> 01:23:03.560
关联

01:23:03.560 --> 01:23:04.560
把数据定给别人

01:23:04.560 --> 01:23:05.560
让别人去用

01:23:05.560 --> 01:23:06.560
虽然说是

01:23:06.560 --> 01:23:07.560
我们按照单一职责

01:23:07.560 --> 01:23:08.560
去做事

01:23:08.560 --> 01:23:09.560
我们这样地

01:23:09.560 --> 01:23:10.560
我们要怎么样

01:23:10.560 --> 01:23:11.560
我们要把原来

01:23:11.560 --> 01:23:13.560
这么复杂的含书

01:23:13.560 --> 01:23:14.560
给它拆开

01:23:14.560 --> 01:23:16.560
来降低它的复杂度

01:23:16.560 --> 01:23:17.560
咱们说了

01:23:17.560 --> 01:23:18.560
拆开以后的话

01:23:18.560 --> 01:23:20.560
它的偶和度就会升高

01:23:20.560 --> 01:23:21.560
我们要它偶和度来弥补

01:23:21.560 --> 01:23:23.560
为什么要它偶和度来弥补

01:23:23.560 --> 01:23:24.560
因为偶和度

01:23:24.560 --> 01:23:25.560
就是它一种关联性

01:23:25.560 --> 01:23:26.560
如果说你把

01:23:26.560 --> 01:23:27.560
几个共同圈拆开以后的话

01:23:27.560 --> 01:23:29.560
他们之间彼此一点关联都没有了

01:23:29.560 --> 01:23:30.560
那可能

01:23:30.560 --> 01:23:33.560
整个东西还能再去运转

01:23:33.560 --> 01:23:35.560
我们一定程度上

01:23:35.560 --> 01:23:37.560
是拿增加偶和来去弥补

01:23:37.560 --> 01:23:39.560
这样的复杂度

01:23:39.560 --> 01:23:41.560
这也是我们优化也好

01:23:41.560 --> 01:23:42.560
开发也好的话

01:23:42.560 --> 01:23:45.560
首先要去干这件事情

01:23:45.560 --> 01:23:46.560
复杂度的话

01:23:46.560 --> 01:23:48.560
是咱最不想要好的

01:23:48.560 --> 01:23:49.560
降低复杂度的话

01:23:49.560 --> 01:23:51.560
能从代码的算法上

01:23:51.560 --> 01:23:52.560
或者说

01:23:52.560 --> 01:23:53.560
能从这个好的鲁国地上

01:23:53.560 --> 01:23:54.560
去降低

01:23:54.560 --> 01:23:56.560
就尽量从这种方式来降低

01:23:56.560 --> 01:23:57.560
如果不行的话

01:23:57.560 --> 01:23:58.560
对吧

01:23:58.560 --> 01:23:59.560
我们要怎么办

01:23:59.560 --> 01:24:00.560
按照这种原则的方式来看看

01:24:00.560 --> 01:24:02.560
是否有没有按照原则

01:24:02.560 --> 01:24:03.560
他在这做

01:24:03.560 --> 01:24:04.560
没有的话

01:24:04.560 --> 01:24:05.560
按原则的方式来降低

01:24:05.560 --> 01:24:06.560
但你降低完以后的话

01:24:06.560 --> 01:24:07.560
必然而然会怎么样

01:24:07.560 --> 01:24:09.560
增加偶和

01:24:09.560 --> 01:24:10.560
怎么增加偶和的话

01:24:10.560 --> 01:24:11.560
咱们来看一下

01:24:11.560 --> 01:24:12.560
比如说

01:24:12.560 --> 01:24:13.560
我们在这

01:24:13.560 --> 01:24:15.560
这方式一个方法叫做

01:24:15.560 --> 01:24:17.560
软的方法

01:24:17.560 --> 01:24:18.560
软的方法

01:24:18.560 --> 01:24:19.560
这个软的方法

01:24:19.560 --> 01:24:20.560
能干什么事呢

01:24:20.560 --> 01:24:23.560
它能根据数据来进行虚现然

01:24:23.560 --> 01:24:24.560
和

01:24:24.560 --> 01:24:27.060
等会儿啊

01:24:27.060 --> 01:24:28.060
和

01:24:28.060 --> 01:24:29.060
和

01:24:29.060 --> 01:24:30.060
和

01:24:30.060 --> 01:24:32.060
没

01:24:32.060 --> 01:24:33.060
好

01:24:33.060 --> 01:24:34.060
没

01:24:34.060 --> 01:24:39.640
没

01:24:39.640 --> 01:24:40.640
shit

01:24:40.640 --> 01:24:41.640
等会儿了

01:24:41.640 --> 01:24:44.200
好

01:24:44.200 --> 01:24:45.200
老人醋

01:24:45.200 --> 01:24:46.200
好

01:24:46.200 --> 01:24:47.200
软的

01:24:47.200 --> 01:24:48.200
它叫做

01:24:48.200 --> 01:24:55.830
虚然

01:24:55.830 --> 01:24:56.830
虚然

01:24:56.830 --> 01:24:57.830
那再来一个

01:24:57.830 --> 01:24:58.830
比如说叫做一个缓存

01:24:58.830 --> 01:24:59.830
先把叫做缓存

01:25:00.830 --> 01:25:01.830
缓存

01:25:01.830 --> 01:25:02.830
叫做一个catch

01:25:02.830 --> 01:25:10.390
好

01:25:10.390 --> 01:25:11.390
根据数据

01:25:11.390 --> 01:25:12.390
虚然

01:25:12.390 --> 01:25:13.390
它叫做缓存数据

01:25:14.390 --> 01:25:17.280
换

01:25:17.280 --> 01:25:18.280
存

01:25:18.280 --> 01:25:19.280
数据

01:25:19.280 --> 01:25:20.280
OK

01:25:20.280 --> 01:25:21.280
那接下来

01:25:21.280 --> 01:25:22.280
咱们来看看

01:25:22.280 --> 01:25:24.280
这些东西必然然要形成

01:25:24.280 --> 01:25:25.280
怎么样

01:25:25.280 --> 01:25:26.280
形成关联

01:25:26.280 --> 01:25:27.280
那有关联就有我和

01:25:27.280 --> 01:25:28.280
对吧

01:25:28.280 --> 01:25:29.280
我恩兮不得

01:25:29.280 --> 01:25:30.280
但是不好是

01:25:30.280 --> 01:25:31.280
我问了他很多次

01:25:31.280 --> 01:25:33.280
这反正有点小问题

01:25:33.280 --> 01:25:34.280
那

01:25:34.280 --> 01:25:36.280
这些东西

01:25:36.280 --> 01:25:37.280
那指定

01:25:37.280 --> 01:25:38.280
我给他拆开来写了

01:25:38.280 --> 01:25:39.280
但是

01:25:39.280 --> 01:25:40.280
他们必须怎么样

01:25:40.280 --> 01:25:41.280
有相应的关联

01:25:41.280 --> 01:25:42.280
才能怎么样

01:25:42.280 --> 01:25:43.280
把这整个逻辑

01:25:43.280 --> 01:25:44.280
把整个共同

01:25:44.280 --> 01:25:46.280
是说你看以前是

01:25:46.280 --> 01:25:47.280
没有和对吧

01:25:47.280 --> 01:25:48.280
一个函数就搞定了

01:25:48.280 --> 01:25:50.280
那复杂程度高对吧

01:25:50.280 --> 01:25:51.280
但拆开来怎么样

01:25:51.280 --> 01:25:52.280
降低复杂度

01:25:52.280 --> 01:25:53.280
现在怎么样

01:25:53.280 --> 01:25:54.280
偶和度高对不对

01:25:54.280 --> 01:25:55.280
他们因为他们有关联的

01:25:55.280 --> 01:25:56.280
这样的一个

01:25:56.280 --> 01:25:57.280
就是

01:25:57.280 --> 01:25:58.280
彼此之间这种

01:25:58.280 --> 01:26:00.280
关联的这样的一个

01:26:00.280 --> 01:26:01.280
这种

01:26:01.280 --> 01:26:02.280
这种这样的一个

01:26:02.280 --> 01:26:04.280
数量他多了一些对吧

01:26:04.280 --> 01:26:05.280
那当然偶和度

01:26:05.280 --> 01:26:06.280
他一定是高的

01:26:06.280 --> 01:26:07.280
那咱来看

01:26:07.280 --> 01:26:08.280
怎么来具体是使用的吧

01:26:08.280 --> 01:26:09.280
怎么来具体使用的话

01:26:09.280 --> 01:26:10.280
咱们再往这边去

01:26:10.280 --> 01:26:12.280
往上它具体的一个功能

01:26:12.280 --> 01:26:13.280
那

01:26:14.280 --> 01:26:15.280
说首先我要这么做

01:26:15.280 --> 01:26:16.280
首先我希望

01:26:16.280 --> 01:26:17.280
通过一个

01:26:17.280 --> 01:26:18.280
叫做OG

01:26:18.280 --> 01:26:19.280
我一个OG

01:26:19.280 --> 01:26:20.280
通过New Guide的方式

01:26:20.280 --> 01:26:21.280
来做一件事

01:26:21.280 --> 01:26:22.280
New Guide我希望

01:26:22.280 --> 01:26:26.650
它传一个参数

01:26:26.650 --> 01:26:27.650
传参

01:26:27.650 --> 01:26:28.650
那传什么参数

01:26:28.650 --> 01:26:29.650
我来传一下

01:26:29.650 --> 01:26:31.650
这个OR

01:26:31.650 --> 01:26:33.650
和catch data

01:26:33.650 --> 01:26:35.650
这个所传辆的对象

01:26:35.650 --> 01:26:36.650
因为我希望

01:26:36.650 --> 01:26:37.650
让它俩

01:26:37.650 --> 01:26:40.650
你们有个方法叫做

01:26:40.650 --> 01:26:42.650
叫做什么

01:26:42.650 --> 01:26:46.990
叫做度方法

01:26:47.990 --> 01:26:48.990
度方法

01:26:48.990 --> 01:26:49.990
它们也是

01:26:49.990 --> 01:26:50.990
度方法

01:26:50.990 --> 01:26:56.160
度方法

01:26:56.160 --> 01:26:57.160
那这方法有什么用呢

01:26:57.160 --> 01:26:59.160
比如说它能根据

01:26:59.160 --> 01:27:00.160
这个数据

01:27:00.160 --> 01:27:01.160
具体怎么样

01:27:01.160 --> 01:27:02.160
来去真正的

01:27:02.160 --> 01:27:04.160
进行渲染

01:27:04.160 --> 01:27:05.160
它我就直接

01:27:05.160 --> 01:27:07.160
catch data

01:27:08.160 --> 01:27:09.160
catch data

01:27:09.160 --> 01:27:10.160
保存一下

01:27:10.160 --> 01:27:11.160
那我来

01:27:11.160 --> 01:27:13.160
就直接在这这么写了

01:27:13.160 --> 01:27:14.160
OK

01:27:14.160 --> 01:27:16.160
那当然

01:27:16.160 --> 01:27:17.160
这一块

01:27:17.160 --> 01:27:20.160
我要写的DOM

01:27:20.160 --> 01:27:21.160
写个DOM

01:27:21.160 --> 01:27:22.160
这可以这么来写

01:27:22.160 --> 01:27:24.160
来写个this.dom

01:27:26.160 --> 01:27:27.160
那这又是啥呢

01:27:27.160 --> 01:27:28.160
现在

01:27:28.160 --> 01:27:29.160
现在我通过一个

01:27:29.160 --> 01:27:31.160
OR的方式来OR一下

01:27:31.160 --> 01:27:32.160
我通过New的方式

01:27:32.160 --> 01:27:34.160
来去Renderize

01:27:34.160 --> 01:27:35.160
R-E-N-D-E-R

01:27:35.160 --> 01:27:36.160
我通过

01:27:36.160 --> 01:27:38.160
在工作还是你们去传一个参数

01:27:38.160 --> 01:27:39.160
传一个DOM

01:27:39.160 --> 01:27:40.160
传UR

01:27:40.160 --> 01:27:41.160
让它在这里面

01:27:41.160 --> 01:27:42.160
先记录一下

01:27:42.160 --> 01:27:43.160
这个this.dom

01:27:43.160 --> 01:27:44.160
是UR对吧

01:27:44.160 --> 01:27:45.160
那我在真正的去在

01:27:45.160 --> 01:27:46.160
比如说在某个地方

01:27:46.160 --> 01:27:47.160
UR

01:27:47.160 --> 01:27:48.160
Render的时候

01:27:48.160 --> 01:27:49.160
Render的时候

01:27:49.160 --> 01:27:51.160
去

01:27:51.160 --> 01:27:52.160
点肚的时候

01:27:52.160 --> 01:27:54.160
点肚的时候去一执行

01:27:54.160 --> 01:27:56.160
就让它怎么样

01:27:56.160 --> 01:27:57.160
首先传数据对吧

01:27:57.160 --> 01:27:58.160
就让它在这里面

01:27:58.160 --> 01:28:01.160
把数据全部都生成这样的一个字幕创

01:28:01.160 --> 01:28:02.160
并且

01:28:02.160 --> 01:28:04.160
把这个this.dom

01:28:04.160 --> 01:28:05.160
也把它in an HTML

01:28:05.160 --> 01:28:07.160
给它灌成这样的字幕创

01:28:07.160 --> 01:28:08.160
也就是说

01:28:08.160 --> 01:28:10.160
我现在通过New Render的方式

01:28:10.160 --> 01:28:11.160
创建出这个对象

01:28:11.160 --> 01:28:12.160
这个对象天生

01:28:12.160 --> 01:28:13.160
它就知道

01:28:13.160 --> 01:28:14.160
我要对它

01:28:14.160 --> 01:28:15.160
进行怎么样

01:28:15.160 --> 01:28:16.160
渲染

01:28:16.160 --> 01:28:17.160
是吧

01:28:17.160 --> 01:28:18.160
那好

01:28:18.160 --> 01:28:19.160
那现在

01:28:19.160 --> 01:28:20.160
比如说

01:28:20.160 --> 01:28:21.160
我在创建这个

01:28:21.160 --> 01:28:23.160
在创建这个getDate的时候

01:28:23.160 --> 01:28:25.160
我就往里面放个数组

01:28:25.160 --> 01:28:26.160
这个数组

01:28:26.160 --> 01:28:27.160
首先放UR

01:28:27.160 --> 01:28:29.160
但其次

01:28:29.160 --> 01:28:30.160
我再放一个

01:28:30.160 --> 01:28:32.160
OcatchDate

01:28:32.160 --> 01:28:33.160
OcatchDate

01:28:33.160 --> 01:28:35.160
就是叫oc

01:28:35.160 --> 01:28:37.160
但oc我还没有写

01:28:37.160 --> 01:28:38.160
oc我还没有写

01:28:38.160 --> 01:28:39.160
咱假装已经写完了

01:28:39.160 --> 01:28:40.160
并且这个功能

01:28:40.160 --> 01:28:41.160
也能完成

01:28:41.160 --> 01:28:43.160
缓存的功能对吧

01:28:43.160 --> 01:28:44.160
那在这的话

01:28:44.160 --> 01:28:45.160
我要怎么办

01:28:45.160 --> 01:28:46.160
我要怎么办

01:28:46.160 --> 01:28:47.160
其实也很简单

01:28:47.160 --> 01:28:48.160
首先

01:28:48.160 --> 01:28:49.160
比如说我给它一个

01:28:49.160 --> 01:28:50.160
方法叫做this

01:28:50.160 --> 01:28:52.160
一个getDate的方法

01:28:52.160 --> 01:28:54.160
g

01:28:54.160 --> 01:28:56.160
date

01:28:56.160 --> 01:28:57.160
或者它也叫做

01:28:57.160 --> 01:28:58.160
gdate

01:28:58.160 --> 01:28:59.160
好

01:28:59.160 --> 01:29:00.160
那它的一个方式

01:29:00.160 --> 01:29:01.160
等于一个方式

01:29:01.160 --> 01:29:02.160
那在这的话

01:29:02.160 --> 01:29:03.160
比如说我希望

01:29:03.160 --> 01:29:04.160
让它可以接受

01:29:04.160 --> 01:29:05.160
产生数url

01:29:05.160 --> 01:29:06.160
pai

01:29:06.160 --> 01:29:07.160
md吧

01:29:07.160 --> 01:29:08.160
那它这里面

01:29:08.160 --> 01:29:09.160
自然而然会用这个

01:29:09.160 --> 01:29:10.160
阿迦克斯的方式

01:29:10.160 --> 01:29:11.160
来获取数据

01:29:11.160 --> 01:29:13.160
那我它来个url

01:29:13.160 --> 01:29:15.600
url

01:29:15.600 --> 01:29:16.600
那这里面来个date

01:29:16.600 --> 01:29:18.600
叫做一个pi

01:29:18.600 --> 01:29:19.600
md吧

01:29:19.600 --> 01:29:20.600
好

01:29:20.600 --> 01:29:21.600
再来个succes

01:29:21.600 --> 01:29:22.600
来个function

01:29:24.600 --> 01:29:25.600
那这里面需要一个

01:29:25.600 --> 01:29:26.600
json

01:29:26.600 --> 01:29:27.600
对吧

01:29:27.600 --> 01:29:28.600
需要一个json

01:29:28.600 --> 01:29:29.600
那好了

01:29:29.600 --> 01:29:30.600
那当这个数据

01:29:30.600 --> 01:29:31.600
成功了以后的话

01:29:31.600 --> 01:29:32.600
怎么办呢

01:29:32.600 --> 01:29:33.600
咱们说callbackarrim

01:29:33.600 --> 01:29:34.600
对不对

01:29:34.600 --> 01:29:35.600
我在真正去创建

01:29:35.600 --> 01:29:36.600
这个对象的时候

01:29:36.600 --> 01:29:37.600
一开始我就传了

01:29:37.600 --> 01:29:38.600
他们两个

01:29:38.600 --> 01:29:39.600
就对

01:29:39.600 --> 01:29:40.600
一开始的时候

01:29:40.600 --> 01:29:41.600
我就传了这个数据

01:29:41.600 --> 01:29:42.600
有这个or和oc

01:29:42.600 --> 01:29:43.600
两个对象

01:29:43.600 --> 01:29:44.600
你们的

01:29:44.600 --> 01:29:45.600
那你要知道我在外界

01:29:45.600 --> 01:29:47.600
真正的去获取数据

01:29:47.600 --> 01:29:48.600
数据的时候

01:29:48.600 --> 01:29:49.600
其实也是希望

01:29:49.600 --> 01:29:51.600
有一些过程发生

01:29:51.600 --> 01:29:52.600
比如说

01:29:52.600 --> 01:29:53.600
相当去渲染数据

01:29:53.600 --> 01:29:55.600
相当去缓存数据

01:29:55.600 --> 01:29:57.600
这是一系列的一个动作

01:29:57.600 --> 01:29:58.600
那当这个数据

01:29:58.600 --> 01:29:59.600
给我以后

01:29:59.600 --> 01:30:00.600
我可以怎么办

01:30:00.600 --> 01:30:01.600
我可以这样

01:30:01.600 --> 01:30:02.600
我可以通过这个

01:30:03.600 --> 01:30:05.600
叫做callbackarrim

01:30:05.600 --> 01:30:06.600
对吧

01:30:06.600 --> 01:30:07.600
通过for each的方式

01:30:07.600 --> 01:30:08.600
把它全部拿出来

01:30:08.600 --> 01:30:09.600
便利一下

01:30:09.600 --> 01:30:10.600
便利

01:30:10.600 --> 01:30:11.600
那便利之后

01:30:11.600 --> 01:30:12.600
你要知道

01:30:12.600 --> 01:30:13.600
这个每个arE

01:30:13.600 --> 01:30:15.600
都是内部的一个对象

01:30:15.600 --> 01:30:16.600
这个对象的话

01:30:16.600 --> 01:30:18.600
我通过arE的方式点渡

01:30:18.600 --> 01:30:20.600
把这个js也传进去

01:30:20.600 --> 01:30:21.600
传进去

01:30:21.600 --> 01:30:23.600
让他们相当去干

01:30:23.600 --> 01:30:24.600
他们应该去干那些事

01:30:24.600 --> 01:30:25.600
对吧

01:30:25.600 --> 01:30:26.600
就比如说or要怎么办

01:30:26.600 --> 01:30:28.600
要渲染数据对吧

01:30:28.600 --> 01:30:30.600
那这个catchdata

01:30:30.600 --> 01:30:31.600
就oc

01:30:31.600 --> 01:30:32.600
要去在这里面

01:30:32.600 --> 01:30:33.600
整个缓存数据

01:30:33.600 --> 01:30:34.600
那缓存数据的话

01:30:34.600 --> 01:30:35.600
我确实没有去

01:30:35.600 --> 01:30:37.600
实现这个功能对不对

01:30:37.600 --> 01:30:38.600
那接下来的话

01:30:38.600 --> 01:30:39.600
我们可以来实现这个功能

01:30:39.600 --> 01:30:40.600
缓存数据

01:30:40.600 --> 01:30:41.600
缓存数据的话

01:30:41.600 --> 01:30:42.600
其实就是一句话

01:30:42.600 --> 01:30:43.600
它就是一句话

01:30:43.600 --> 01:30:45.600
通过local storage

01:30:45.600 --> 01:30:47.600
点set item

01:30:47.600 --> 01:30:48.600
把这个list

01:30:48.600 --> 01:30:49.600
放在那边来

01:30:49.600 --> 01:30:50.600
这边

01:30:50.600 --> 01:30:51.600
这一边

01:30:51.600 --> 01:30:52.600
其实我可以让它

01:30:52.600 --> 01:30:53.600
接受一个变量

01:30:53.600 --> 01:30:54.600
就是tap

01:30:54.600 --> 01:30:56.600
因为缓存数据的时候

01:30:56.600 --> 01:30:58.600
是用哈其的方式来缓存

01:30:58.600 --> 01:30:59.600
对吧

01:30:59.600 --> 01:31:00.600
那数据的名字是啥

01:31:00.600 --> 01:31:01.600
对吧

01:31:01.600 --> 01:31:02.600
可以传tap

01:31:02.600 --> 01:31:03.600
那数据的这个值

01:31:03.600 --> 01:31:04.600
比如说

01:31:04.600 --> 01:31:05.600
它来接受

01:31:05.600 --> 01:31:06.600
data

01:31:06.600 --> 01:31:08.600
就传data

01:31:08.600 --> 01:31:09.600
那我让它呢

01:31:09.600 --> 01:31:11.600
实现

01:31:11.600 --> 01:31:13.600
tap

01:31:13.600 --> 01:31:15.600
或者说我干脆就不这么办了

01:31:15.600 --> 01:31:16.600
我直接

01:31:16.600 --> 01:31:18.600
在这来传tap

01:31:18.600 --> 01:31:20.600
它就相当于是个B包的英文对不对

01:31:20.600 --> 01:31:21.600
好

01:31:21.600 --> 01:31:22.600
那我比如说在这

01:31:22.600 --> 01:31:23.600
我也有一个OC

01:31:23.600 --> 01:31:24.600
等于什么呢

01:31:24.600 --> 01:31:28.800
等于一个new catch date

01:31:28.800 --> 01:31:30.800
在这来个tap

01:31:30.800 --> 01:31:31.800
在这来个tap

01:31:31.800 --> 01:31:33.800
那有这个tap了

01:31:33.800 --> 01:31:35.800
那也就是说

01:31:35.800 --> 01:31:37.800
我这个OC对象

01:31:37.800 --> 01:31:38.800
如果一旦掉点度

01:31:38.800 --> 01:31:39.800
先把里面传数据的话

01:31:39.800 --> 01:31:41.800
它就一定会通过

01:31:41.800 --> 01:31:44.800
local storage.setatum

01:31:44.800 --> 01:31:47.800
去怎么样缓存此类型的一个数据

01:31:47.800 --> 01:31:48.800
但这一块的话

01:31:48.800 --> 01:31:49.800
我传什么呢

01:31:49.800 --> 01:31:50.800
传list

01:31:50.800 --> 01:31:51.800
传list

01:31:51.800 --> 01:31:52.800
也就是说

01:31:52.800 --> 01:31:53.800
这个OC对象

01:31:53.800 --> 01:31:55.800
只要掉用度来缓存数据的话

01:31:55.800 --> 01:31:56.800
它这个属性

01:31:56.800 --> 01:31:58.800
它这样一个名

01:31:58.800 --> 01:31:59.800
或者说它这样一个key值

01:31:59.800 --> 01:32:01.800
都是这个list

01:32:01.800 --> 01:32:03.800
the list对象的一个数据

01:32:03.800 --> 01:32:04.800
那咱可以看一下

01:32:04.800 --> 01:32:06.800
如果一旦我这个OG

01:32:06.800 --> 01:32:07.800
比如说

01:32:07.800 --> 01:32:09.800
我去掉了这个getting的方法

01:32:09.800 --> 01:32:11.800
并且把里面传了这两个参数

01:32:11.800 --> 01:32:12.800
传完以后的话

01:32:12.800 --> 01:32:13.800
好数据一旦返回

01:32:13.800 --> 01:32:15.800
它里面去执行它

01:32:15.800 --> 01:32:17.800
把这样一个OC

01:32:17.800 --> 01:32:19.800
它把这样一个OR和OC

01:32:19.800 --> 01:32:21.800
全拿出来一度

01:32:21.800 --> 01:32:22.800
并且传数据

01:32:22.800 --> 01:32:23.800
那OR会怎么办呢

01:32:23.800 --> 01:32:25.800
OR就会去调用它

01:32:25.800 --> 01:32:27.800
真正去渲染数据

01:32:27.800 --> 01:32:28.800
渲染到哪呢

01:32:28.800 --> 01:32:29.800
渲染到一开始

01:32:29.800 --> 01:32:31.800
传入到这个UIL之中

01:32:31.800 --> 01:32:33.800
这其实你也可以不用

01:32:33.800 --> 01:32:35.800
this.dom

01:32:35.800 --> 01:32:37.800
你可以在这直接到

01:32:37.800 --> 01:32:38.800
是吧

01:32:38.800 --> 01:32:39.800
当然

01:32:39.800 --> 01:32:40.800
这个里面

01:32:40.800 --> 01:32:41.800
这个里面

01:32:41.800 --> 01:32:42.800
也会相当去执行

01:32:42.800 --> 01:32:44.800
执行什么执行这个度对吧

01:32:44.800 --> 01:32:45.800
这个度的话

01:32:45.800 --> 01:32:46.800
也会缓存这个数据

01:32:46.800 --> 01:32:48.800
但这个可能缓存数据

01:32:48.800 --> 01:32:49.800
这个功能的话

01:32:49.800 --> 01:32:51.800
我还给它另外一个方法

01:32:51.800 --> 01:32:53.800
叫做一个getting

01:32:53.800 --> 01:32:56.800
叫做一个IT

01:32:56.800 --> 01:32:58.800
叫IT

01:32:58.800 --> 01:33:00.800
CHE

01:33:00.800 --> 01:33:01.800
比如说这个方法

01:33:01.800 --> 01:33:03.800
这个方法可以直接

01:33:03.800 --> 01:33:04.800
这个

01:33:04.800 --> 01:33:06.800
local storage

01:33:06.800 --> 01:33:08.800
来去返回这样的数据

01:33:08.800 --> 01:33:09.800
我在这return一下

01:33:09.800 --> 01:33:10.800
好

01:33:10.800 --> 01:33:12.800
get一个

01:33:12.800 --> 01:33:13.800
item

01:33:13.800 --> 01:33:14.800
我这儿呢

01:33:14.800 --> 01:33:15.800
给你传一个

01:33:15.800 --> 01:33:16.800
这是韩手那个tap

01:33:16.800 --> 01:33:18.800
直接返回这个数据

01:33:18.800 --> 01:33:19.800
直接返回这个数据

01:33:19.800 --> 01:33:21.800
那现在咱看一下

01:33:21.800 --> 01:33:22.800
我把这个功能

01:33:22.800 --> 01:33:24.800
确实全拆开来写了

01:33:24.800 --> 01:33:25.800
看好了

01:33:25.800 --> 01:33:27.800
这个获取数据

01:33:27.800 --> 01:33:28.800
有获取数据这个功能对不对

01:33:28.800 --> 01:33:30.800
数据线有数据线的功能

01:33:30.800 --> 01:33:32.800
缓存数据有缓存数据的功能

01:33:32.800 --> 01:33:33.800
对吧

01:33:33.800 --> 01:33:35.800
这三个全部都拆开来了

01:33:35.800 --> 01:33:36.800
当你拆开来以后的话

01:33:36.800 --> 01:33:37.800
你会发现他们之间

01:33:37.800 --> 01:33:39.800
必然而然是有这样的一个关联性的

01:33:39.800 --> 01:33:41.800
那必然而然会有这样的一个偶和度的

01:33:41.800 --> 01:33:43.800
偶和度实力会比之前

01:33:43.800 --> 01:33:45.800
之前要大很多

01:33:45.800 --> 01:33:48.800
要比之前大很多的话

01:33:48.800 --> 01:33:49.800
那好了

01:33:49.800 --> 01:33:52.800
我们用这样的偶和度来换来这样的一个

01:33:52.800 --> 01:33:54.800
我们用这样的一个偶和度

01:33:54.800 --> 01:33:56.800
来换来这样的一个复杂度

01:33:56.800 --> 01:33:57.800
一个降低

01:33:57.800 --> 01:33:59.800
必然而然我们需要有更好的

01:33:59.800 --> 01:34:01.800
这种效果展现出来

01:34:01.800 --> 01:34:03.800
那什么效果来展现出来呢

01:34:03.800 --> 01:34:05.800
比如说我现在把这三功能

01:34:05.800 --> 01:34:06.800
写完以后的话

01:34:06.800 --> 01:34:07.800
我要陆续添加我那个功能

01:34:07.800 --> 01:34:08.800
什么功能呢

01:34:08.800 --> 01:34:09.800
就比如说

01:34:09.800 --> 01:34:12.800
如果是离线的情况下

01:34:12.800 --> 01:34:14.800
这样

01:34:14.800 --> 01:34:15.800
好

01:34:15.800 --> 01:34:24.310
如果是离线的情况下

01:34:24.310 --> 01:34:31.310
我们直接取缓存数据

01:34:31.310 --> 01:34:34.260
好

01:34:34.260 --> 01:34:39.260
如果是离线情况下直接取缓存数据

01:34:39.260 --> 01:34:46.020
并且点击按钮

01:34:46.020 --> 01:34:53.020
也不通过网络或取数据

01:34:53.020 --> 01:34:54.020
因为没有意义

01:34:54.020 --> 01:34:56.020
离线就是没有网的时候

01:34:56.020 --> 01:34:59.020
我不离线

01:34:59.020 --> 01:35:01.020
如果不离线情况下的话

01:35:01.020 --> 01:35:02.020
当然

01:35:02.020 --> 01:35:03.020
第一次执行

01:35:03.020 --> 01:35:10.020
上来就应该通过缓存或取数据

01:35:10.020 --> 01:35:13.020
当然前提是缓存中有数据

01:35:13.020 --> 01:35:15.020
但如果说你点按钮

01:35:15.020 --> 01:35:17.020
点击按钮

01:35:17.020 --> 01:35:22.020
通过网络或取数据

01:35:22.020 --> 01:35:24.020
这个东西离线不离线

01:35:24.020 --> 01:35:26.020
又是我新增的一个功能

01:35:26.020 --> 01:35:27.020
可能产品经理

01:35:27.020 --> 01:35:29.020
新增添一个需求

01:35:29.020 --> 01:35:32.020
按照以前的方讯来写

01:35:32.020 --> 01:35:34.020
再加的话很惹心

01:35:34.020 --> 01:35:36.020
现在比如说

01:35:36.020 --> 01:35:38.020
这三个东西拆开来写

01:35:38.020 --> 01:35:39.020
我完全可以这么做

01:35:39.020 --> 01:35:43.020
比如说我F一下

01:35:43.020 --> 01:35:47.020
我们判断一下NameGator

01:35:47.020 --> 01:35:50.020
对我新录制的Bomb

01:35:50.020 --> 01:35:52.020
我重新发路了

01:35:52.020 --> 01:35:54.020
如果说有朋友没有听过的话

01:35:54.020 --> 01:35:55.020
你可以去听一听

01:35:55.020 --> 01:35:57.020
如果这个online

01:35:57.020 --> 01:35:59.020
比如说是

01:35:59.020 --> 01:36:01.020
online

01:36:01.020 --> 01:36:03.020
咱来看一下我现在这个online是啥

01:36:03.020 --> 01:36:06.020
online是代表

01:36:06.020 --> 01:36:09.020
当前是否处于拖机状态

01:36:09.020 --> 01:36:10.020
拖机是什么意思

01:36:10.020 --> 01:36:12.020
NameGatorOnline

01:36:12.020 --> 01:36:13.020
看好了

01:36:13.020 --> 01:36:14.020
现在是处理吧

01:36:14.020 --> 01:36:16.020
证明你在线

01:36:16.020 --> 01:36:18.020
你就不是处于拖机状态

01:36:18.020 --> 01:36:20.020
要说如果你在线情况下

01:36:20.020 --> 01:36:21.020
这写的

01:36:21.020 --> 01:36:24.020
如果是在线就是不离线

01:36:24.020 --> 01:36:26.020
不离线

01:36:26.020 --> 01:36:29.020
下面就是离线

01:36:34.790 --> 01:36:36.790
离线

01:36:36.790 --> 01:36:37.790
如果你不离线

01:36:37.790 --> 01:36:38.790
的话

01:36:38.790 --> 01:36:39.790
我要怎么样

01:36:39.790 --> 01:36:42.790
我要直接的去判断一下

01:36:42.790 --> 01:36:44.910
你这个o

01:36:44.910 --> 01:36:45.790
ok看好了

01:36:45.790 --> 01:36:47.790
这个功能我直接拿过来就

01:36:47.790 --> 01:36:49.790
叫做return对吧

01:36:49.790 --> 01:36:50.790
catchdate对不对

01:36:50.790 --> 01:36:51.790
我看一下你有没有蓄意的

01:36:51.790 --> 01:36:52.790
如果有怎么办

01:36:52.790 --> 01:36:53.790
如果有的话

01:36:53.790 --> 01:36:55.150
我就直接掉开

01:36:56.790 --> 01:36:58.790
用or的杜方法

01:36:58.790 --> 01:36:59.790
杜方法

01:36:59.790 --> 01:37:00.790
我就往里面直接

01:37:00.790 --> 01:37:03.090
往里面直接帮你一船就行了

01:37:05.370 --> 01:37:05.890
是吧

01:37:05.890 --> 01:37:06.650
直接一船

01:37:06.650 --> 01:37:09.470
但如果说是你没有的话怎么办呢

01:37:09.730 --> 01:37:10.730
否则对吧

01:37:10.990 --> 01:37:12.030
否则没有的话

01:37:12.790 --> 01:37:14.070
是如果你没有数据的话

01:37:14.070 --> 01:37:15.610
那我当然是不是要通过这个

01:37:15.870 --> 01:37:16.890
OG对吧

01:37:17.150 --> 01:37:17.650
点

01:37:18.170 --> 01:37:18.930
get date

01:37:19.190 --> 01:37:19.970
直接去

01:37:20.210 --> 01:37:20.730
获取

01:37:20.990 --> 01:37:23.550
数据并且相应的一系列东西

01:37:23.790 --> 01:37:24.830
就全出来了

01:37:24.830 --> 01:37:26.610
就全出来出来了

01:37:26.870 --> 01:37:27.890
那当然

01:37:28.150 --> 01:37:28.910
如果说是

01:37:29.170 --> 01:37:29.430
好了

01:37:29.690 --> 01:37:31.230
你离线的情况下对吧

01:37:31.230 --> 01:37:33.010
你离线情况下你要怎么做呢

01:37:33.270 --> 01:37:34.050
你离线情况下的话

01:37:34.310 --> 01:37:36.350
你还是需要去判断一下

01:37:38.390 --> 01:37:38.910
这哥们儿

01:37:40.450 --> 01:37:41.210
有没有数据

01:37:41.470 --> 01:37:43.010
有没有数据

01:37:43.510 --> 01:37:45.810
那好了如果有数据的话

01:37:46.070 --> 01:37:46.590
你要这么做

01:37:47.610 --> 01:37:49.410
但没有数数据

01:37:49.670 --> 01:37:50.430
可能说是

01:37:50.950 --> 01:37:51.710
离线

01:37:52.230 --> 01:37:52.990
没有数据

01:37:53.750 --> 01:37:54.790
你要可能这么做

01:37:54.790 --> 01:37:56.070
但你可以发现我这么写的话

01:37:56.310 --> 01:37:57.850
这个逻辑可能说是

01:37:58.110 --> 01:37:59.390
这重复一些对吧

01:37:59.590 --> 01:38:02.670
那你可以怎么办啊你可以上来先去判断一下

01:38:02.930 --> 01:38:04.470
这个东西缓存中

01:38:04.710 --> 01:38:05.750
到底有没有数据

01:38:06.010 --> 01:38:07.270
你不这么做对吧

01:38:07.530 --> 01:38:08.050
那好了

01:38:08.310 --> 01:38:08.810
这个

01:38:09.570 --> 01:38:11.110
好了刚才我这么写

01:38:11.370 --> 01:38:12.910
是不是变得很复杂对吧

01:38:13.170 --> 01:38:13.930
变得很复杂

01:38:14.190 --> 01:38:14.950
复杂度多了对不对

01:38:15.210 --> 01:38:15.990
复杂度多了

01:38:16.250 --> 01:38:18.290
那就是我所说的情况

01:38:18.550 --> 01:38:19.570
你不通过这种

01:38:19.830 --> 01:38:22.370
原则的方式能不能降低这种复杂度呢

01:38:22.630 --> 01:38:23.410
也可以对吧

01:38:23.670 --> 01:38:25.190
改变的逻辑就行了对不对

01:38:25.450 --> 01:38:26.470
现在的逻辑啊

01:38:26.730 --> 01:38:28.010
什么离线不离线

01:38:28.270 --> 01:38:29.290
用这种方式来做的话

01:38:29.550 --> 01:38:31.950
你会发现他会重复的去判断

01:38:32.210 --> 01:38:33.490
是否有没有数据对吧

01:38:33.750 --> 01:38:34.510
那现在怎么办呢

01:38:34.770 --> 01:38:35.270
现在好了

01:38:35.530 --> 01:38:37.330
我不管这个逻辑他来做了对吧

01:38:37.590 --> 01:38:38.610
现在咱来通过

01:38:38.870 --> 01:38:40.150
这种方式来做

01:38:40.390 --> 01:38:42.190
我先判断你有没有缓存数据对吧

01:38:42.450 --> 01:38:43.990
如果你有缓存数据怎么办呢

01:38:45.270 --> 01:38:47.050
我直接判断你是不是

01:38:47.310 --> 01:38:48.070
离线对吧

01:38:48.330 --> 01:38:50.130
如果你再线的情况下

01:38:52.840 --> 01:38:54.120
如果你离线行吗

01:38:54.380 --> 01:38:55.400
如果你离线的话

01:38:55.660 --> 01:38:56.680
我势必要

01:38:56.940 --> 01:38:57.960
从怎么样

01:38:58.220 --> 01:38:59.500
从网络中获取数据对吧

01:38:59.760 --> 01:39:00.520
否则呢

01:39:01.500 --> 01:39:04.300
否则就直接拿这个数据

01:39:04.560 --> 01:39:07.380
拿你这样的一个缓存中来获取数据对吧

01:39:07.900 --> 01:39:09.700
那如果说你这个

01:39:09.940 --> 01:39:11.740
缓存中根本就没有数据情况下的话

01:39:12.000 --> 01:39:13.260
那你这个势必要

01:39:13.520 --> 01:39:16.340
从网络中获取数据了谁也不保持了对吧

01:39:16.600 --> 01:39:17.380
这样的逻辑怎么样

01:39:17.880 --> 01:39:18.380
就变得

01:39:19.160 --> 01:39:20.180
跟以前不一样对吧

01:39:20.440 --> 01:39:22.740
那自然而然这个复杂度只能是没之前高的

01:39:23.000 --> 01:39:24.020
因为之前我都没有写完

01:39:24.280 --> 01:39:26.080
明显就比站板量的多很多很多

01:39:26.340 --> 01:39:26.840
而且呢

01:39:27.100 --> 01:39:28.900
会出现一种重复的判断

01:39:29.140 --> 01:39:30.420
最后我再加一个按钮

01:39:30.980 --> 01:39:32.520
obt

01:39:32.780 --> 01:39:33.800
按钮的话也很简单的

01:39:34.060 --> 01:39:35.340
我在点击的时候怎么办呢

01:39:35.600 --> 01:39:36.360
onk link

01:39:40.490 --> 01:39:42.030
我势必要这么做

01:39:42.290 --> 01:39:43.350
我直接通过

01:39:43.610 --> 01:39:44.070
get data对吧

01:39:44.330 --> 01:39:45.610
能往里面去传一些参啊

01:39:45.870 --> 01:39:46.630
比如说这个

01:39:46.890 --> 01:39:47.410
啊这个

01:39:47.670 --> 01:39:48.170
路径下对吧

01:39:48.430 --> 01:39:49.970
完了就往这个新的这个

01:39:50.730 --> 01:39:52.270
传个新的参数来获取数据

01:39:52.530 --> 01:39:53.550
那整个这东西

01:39:53.810 --> 01:39:54.570
就搞定了

01:39:54.830 --> 01:39:56.870
由于你把这东西拆开了对吧

01:39:57.130 --> 01:39:59.170
虽然说你增加了这样一种啥

01:39:59.430 --> 01:40:00.210
这样一种偶和度

01:40:00.450 --> 01:40:01.990
但确实降低了的复杂度

01:40:02.190 --> 01:40:03.730
你再去互惨需求的时候

01:40:03.990 --> 01:40:05.270
就更容易写了啊

01:40:05.530 --> 01:40:06.030
比如说

01:40:06.550 --> 01:40:08.350
当你去降低复杂度以后的话

01:40:08.610 --> 01:40:09.110
自然而然怎么样

01:40:09.370 --> 01:40:11.150
这个代码质量变得高了一些对吧

01:40:11.410 --> 01:40:12.070
复用性呢

01:40:12.330 --> 01:40:12.690
啊

01:40:12.950 --> 01:40:14.990
他的可快染性呢变得更好一些

01:40:15.250 --> 01:40:16.270
而且复用性呢

01:40:16.530 --> 01:40:17.810
指定变得更好了

01:40:18.070 --> 01:40:19.090
你就想象一下啊

01:40:19.350 --> 01:40:19.850
比如说

01:40:20.110 --> 01:40:20.630
呃

01:40:20.890 --> 01:40:21.390
如果我

01:40:21.650 --> 01:40:24.470
另外一个地方可能说也需要去选数据的话

01:40:24.730 --> 01:40:25.490
我可以怎么做

01:40:25.750 --> 01:40:26.270
我是不是可以

01:40:26.770 --> 01:40:28.810
呃通过new render对吧

01:40:29.070 --> 01:40:30.050
再去怎么样

01:40:30.310 --> 01:40:31.130
就通过new render

01:40:31.330 --> 01:40:32.610
再去新用一个对象

01:40:32.870 --> 01:40:34.710
往里面去传不同的一个

01:40:34.970 --> 01:40:35.470
啊

01:40:35.730 --> 01:40:36.750
同样呢

01:40:37.010 --> 01:40:38.550
这个我想再去获取

01:40:38.810 --> 01:40:39.330
就是

01:40:39.590 --> 01:40:40.350
不是我想去

01:40:40.610 --> 01:40:42.130
获取数据以后啊对吧

01:40:42.390 --> 01:40:43.930
通过其他这个功能

01:40:44.190 --> 01:40:45.970
进行相应的处理的话

01:40:46.230 --> 01:40:48.030
你是不是可以再去new get data一下

01:40:48.290 --> 01:40:48.530
啊

01:40:48.790 --> 01:40:49.570
那这样

01:40:49.810 --> 01:40:50.590
是不是保证了

01:40:50.850 --> 01:40:51.350
这个门

01:40:51.610 --> 01:40:53.150
和这个门的一个复用性啊

01:40:53.410 --> 01:40:54.430
所以说当你这么去

01:40:54.690 --> 01:40:56.730
按照这个单一职责来写代码的时候

01:40:56.990 --> 01:40:58.270
是不是比之前好很多啊

01:40:58.530 --> 01:40:58.770
啊

01:40:59.030 --> 01:41:01.070
所以到现在为止的话是能看得懂吗

01:41:04.250 --> 01:41:04.770
啊

01:41:05.270 --> 01:41:06.550
给个声音同学啊

01:41:08.850 --> 01:41:13.210
是吧知道单一职责原则到到底是什么意思了对吧

01:41:13.470 --> 01:41:14.490
知道这个原则怎么用的对不对

01:41:14.750 --> 01:41:15.770
知道我们一开始

01:41:16.030 --> 01:41:17.050
倒摇怎么做啊

01:41:17.310 --> 01:41:17.810
对吧

01:41:21.750 --> 01:41:23.030
降低偶和度

01:41:23.290 --> 01:41:23.810
呃

01:41:24.070 --> 01:41:26.110
降低复杂度和降低

01:41:26.370 --> 01:41:27.890
偶和度吧其实这个

01:41:28.410 --> 01:41:28.930
我们

01:41:29.690 --> 01:41:30.450
在后面

01:41:30.710 --> 01:41:33.290
组件化这样那个开发功能中的话

01:41:33.530 --> 01:41:34.570
他就是一种

01:41:35.290 --> 01:41:38.870
符合这种方式的一种开发的一个思想和这样的一个

01:41:39.130 --> 01:41:39.650
理由程

01:41:39.910 --> 01:41:40.910
单模块化的话

01:41:41.170 --> 01:41:41.690
更是

01:41:42.450 --> 01:41:42.970
啊

01:41:43.230 --> 01:41:43.730
所以说

01:41:43.990 --> 01:41:44.510
呃

01:41:45.030 --> 01:41:51.670
你听的什么一些很多高大上级的词和一种造法的话他最后都离不开这些底层的一些思想和理论啊

01:41:51.930 --> 01:41:53.470
说这些东西他很重要吗啊

01:41:54.230 --> 01:41:57.810
OK那这个同学咱要知道的话我这些课的话我估计还才能

01:41:58.070 --> 01:41:59.350
是个讲到12点就要考

01:42:01.390 --> 01:42:03.710
讲到12点就讲到12点吧啊

01:42:04.110 --> 01:42:04.990
接下来啊

01:42:05.250 --> 01:42:05.750
接下来

01:42:06.010 --> 01:42:06.530
哎呀

01:42:08.870 --> 01:42:09.370
哎呀

01:42:10.150 --> 01:42:10.910
怎么搞的

01:42:12.190 --> 01:42:13.990
啊这样吧咱们看他了啊

01:42:14.750 --> 01:42:18.070
接下来啊接下来我们讲第二个原则我们讲第二个原则

01:42:18.330 --> 01:42:19.090
第二个原则

01:42:19.350 --> 01:42:19.870
好

01:42:20.130 --> 01:42:24.730
讲第二个原则的话再来看呀咱第二个原则叫做什么叫做

01:42:25.490 --> 01:42:26.270
开闭原则啊

01:42:26.530 --> 01:42:29.590
开闭原则的话咱就不写代码了之后的话咱们会

01:42:29.850 --> 01:42:31.390
用到时候再说一说啊

01:42:31.650 --> 01:42:35.470
那这块啊如果说你这个读故啊或者你听过咱们那个

01:42:35.730 --> 01:42:40.090
这块有马克的话其实你多多少少的话能对这个开闭原则有点理解啊

01:42:40.850 --> 01:42:44.190
什么叫做开闭原则首先首先看好了

01:42:44.450 --> 01:42:45.730
一个转件实体啊

01:42:45.990 --> 01:42:46.750
比如说如类

01:42:47.010 --> 01:42:47.770
或者说不扩

01:42:48.030 --> 01:42:48.790
寒树啊

01:42:49.050 --> 01:42:52.630
应该对外开放啊应该对外开放

01:42:53.150 --> 01:42:55.190
对修改啊对扩展开放

01:42:55.450 --> 01:42:58.510
对修改关闭啊为什么要对修改关闭呢

01:42:58.770 --> 01:43:00.830
比如说一个写一个对象里吧里面好多属性

01:43:01.090 --> 01:43:04.150
你这个通过点的方式直接就随便改了

01:43:04.870 --> 01:43:08.970
那不是你能看他能改就别那整个这样的一个里面的内部功能啊

01:43:09.730 --> 01:43:10.370
轻易的

01:43:10.630 --> 01:43:13.830
首先轻的别别改了啊那就很容易混乱

01:43:14.090 --> 01:43:17.670
而且你但改了以后的话由于很多东西可能说是都能改的

01:43:17.930 --> 01:43:21.770
这样让人都会去依赖的对吧你但依赖以后的话自然而然

01:43:22.530 --> 01:43:24.070
啊比如说你这个

01:43:24.590 --> 01:43:29.450
这个地方被一个东西改了的吧导致其他地方也出问题了啊所以说

01:43:29.710 --> 01:43:33.810
如果说你对啊如果说你这个对修改啊不关闭的情况下的话

01:43:34.050 --> 01:43:38.930
你会更难的去维护啊更难的去保证这样的一个比较高的一个质量啊

01:43:39.430 --> 01:43:42.270
那对外扩展是什么意思呢对外扩展的话就是

01:43:42.770 --> 01:43:44.310
呃你可以理解成

01:43:45.590 --> 01:43:47.630
就是比如说我要在里面对这个

01:43:48.150 --> 01:43:54.030
这个对修改关闭的话我还有我还有同学体论下啊必包的吧必包它就是这样的

01:43:54.290 --> 01:44:00.190
你怎么能对外这个修改是关闭的啊对外修改是关闭的话

01:44:00.690 --> 01:44:02.230
那很简单的吧

01:44:02.690 --> 01:44:09.610
必包比如说私有化的吧你咱们就改不了他但你想改怎么办呢啊你给他提供一个结构改不就行了吗啊

01:44:09.870 --> 01:44:12.170
这里面你来好好地给我回忆一下

01:44:12.430 --> 01:44:15.750
这query的这个东西啊这query你又要知道

01:44:16.270 --> 01:44:23.050
它是个GS cool的呗这个东西写完以后要给别人用的啊那比如在用的过程中的话你想啊他里面虽然说很多方法一般都还带码

01:44:23.310 --> 01:44:29.830
他也没办法去保证没有办法去保证所有的方法都符合你的业务逻辑啊可能很多方法的话

01:44:29.990 --> 01:44:38.270
你依旧还是需要怎么样自己去写的对吧但你可能是这个方法他这边没有但你很常用你怎么办呢你可以通过

01:44:38.530 --> 01:44:45.950
这query所提供的s3的方法帮你去扩展这个东西啊要说你可以把这个方法加到里面去啊

01:44:46.210 --> 01:44:52.870
那你可以通过你添加完了这样的一个这query啊平凡的去调用的去操作的那很明显

01:44:53.130 --> 01:44:57.210
这query他对那修改是关闭的因为他整个就是个大臂包的吧

01:44:57.410 --> 01:45:02.030
你想改的除非你把码里面去改了对吧他没给你听这样的一个接口你根本就改不了的

01:45:02.290 --> 01:45:07.030
那他对外修改啊是开放里面他他这个s10的方法你知道

01:45:07.290 --> 01:45:12.010
这个s10的方法的话就允许你去怎么样这个的新增一些东西啊

01:45:12.270 --> 01:45:15.590
那开闭我说开闭原则的核心是啥啊我说

01:45:15.850 --> 01:45:19.690
开闭原则的核心是专注于这样的一个扩展

01:45:20.450 --> 01:45:27.170
啊说他希望你在写单码的时候啊能给就是你在写单码的时候啊你要把

01:45:27.410 --> 01:45:33.810
凭着你的经验去预测到哪些地方可能会频繁的发生改变和新增啊

01:45:34.070 --> 01:45:38.690
那真的于这些地方的话对吧你知道他一定会怎么样会去啊

01:45:38.950 --> 01:45:43.810
比如说在未来会往里去加一些东西啊那你在写他的公众的话啊

01:45:45.090 --> 01:45:47.370
你在写他的公众的话啊你要去

01:45:48.150 --> 01:45:54.290
时刻去保持这样的一个警惕啊他需要对外界扩展是开放的

01:45:54.510 --> 01:46:00.830
你要给他比如说你针针对于这样一个这块的话你要给他预测一个这个s10的接口方便别怎么样

01:46:01.250 --> 01:46:09.130
去给他进行这个新增啊那其实针对于其他语言中啊针对于其他语言中啊我们开闭原则啊

01:46:09.890 --> 01:46:17.570
如何去对外扩展呢扩展的显示什么样子呢啊多数的时候是继承啊不是这个附类他已经有一个功能对不对

01:46:17.810 --> 01:46:22.850
这个功能不足以满足的需求啊我想去新增一些功能怎么办呢我不去改这个附类

01:46:23.070 --> 01:46:28.030
我去怎么样我去哎拿一个子类继承他把他的方法都继承过来对吧

01:46:28.250 --> 01:46:30.090
当时我在新加一些东西

01:46:31.010 --> 01:46:39.330
啊当然呢这么做完全没问题啊这么做完全没问题没问题啊但这块他并不是这样一个标准意义上的继承我们建设中

01:46:39.970 --> 01:46:48.530
这个用期继承的时候是有但没有那么多对吧啊尤其这块的话他也不是严格的一个面向对象的一个编程对吧他没有说是一个

01:46:49.010 --> 01:46:55.610
类合类之间有这样的一些父子的一些关系啊你通过s time你只是在圆形上去加上一些东西啊

01:46:55.970 --> 01:47:02.090
但是呢他确实是符合这样的一个思想的他给你预留出来这个接口方便你去进行这样的一个

01:47:02.490 --> 01:47:08.610
扩展啊那这你在你后续开发功能的话这也是一个很大的一个经验性的一个问题啊

01:47:09.010 --> 01:47:12.850
那开闭原则咱说他的最后的指向是啊最后的指向是

01:47:13.810 --> 01:47:19.690
啊就是你在开发功能的话对一些可能经常会变动的一些地方对吧会新增的一些地方啊

01:47:20.010 --> 01:47:28.970
你要时刻保持警惕给他预留出来一个借口是吧方便他能啊方便其他人对吧能把里面去添加一些东西啊

01:47:29.490 --> 01:47:35.370
那他是让你有这样一个思想啊他让你有这样一个思想那有了这个思想以后啊咱来看一下啊

01:47:35.850 --> 01:47:36.090
就是

01:47:37.130 --> 01:47:38.650
前面在开发流程

01:47:39.290 --> 01:47:44.530
说我们说这复杂程度很高下的话我们利用开闭原原则可以降低复杂度

01:47:45.690 --> 01:47:49.650
降低复杂度可以吧复杂度啊为什么降低复杂度呢你想想啊

01:47:50.410 --> 01:47:55.050
啊那你降低复杂度以后自然会怎么样会降低偶和度对不对啊

01:47:55.810 --> 01:48:02.610
好了如果说啊如果说你要新增跟功能啊你不按开闭原则来的话对吧你直接往里面加了对吧

01:48:02.770 --> 01:48:03.890
你给你修改的原则

01:48:04.530 --> 01:48:13.370
其实是既不符合单一质则原原则对吧那可能他可能是既不符合单一质则原则又不符这样的开闭原则

01:48:13.370 --> 01:48:16.970
因为你在原有的这样的功能中去修改这样的一个单码了啊

01:48:17.450 --> 01:48:17.690
那

01:48:19.250 --> 01:48:23.650
那怎么办啊他说你可以在原有的就上去吧我就继承对吧我继承以后的话ok

01:48:24.250 --> 01:48:29.970
那当然我不在里面加那这样的一个里面的复杂度他没有那么高对吧他不会说是像您三里面加

01:48:30.850 --> 01:48:37.890
二那么高那你记成了以后的话你是新增添一个功能对吧你新增添一个这样的一个对象新增添一个东西

01:48:38.210 --> 01:48:41.170
那我和度怎么怎么样他也会高又高一些

01:48:41.530 --> 01:48:49.170
就说当你通过开闭原则来降低复杂度的时候同样他也会降低这样的一个他也会增添这样的一个偶和度啊偶和度听了

01:48:49.570 --> 01:48:57.170
那也有特别说啊那我学了开闭原则以后是不是我在改东西的时候啊我就永远都不要把我之前写好的东西给他改

01:48:57.890 --> 01:49:08.370
那也不可能啊这是不可能的啊为什么呢因为你不可能保证你之前写那个东西一点毛病都没有啊因为我们在写代码的时候经常是那种啊

01:49:08.810 --> 01:49:19.050
写完对吧重构推翻的吧写完重构推翻啊那怎么能保证说你尽可能的少的一个改动啊在维护上成本变得低点呢

01:49:19.330 --> 01:49:23.690
那就是你尽可能的去符合这些原则去做些事情啊

01:49:23.970 --> 01:49:33.570
但是呢你尽可能符合这些原则去做事的话也不能保证你百分之百就是对的啊这就好比啊我最后讲完原则的时候我要说一句话啊说一句话

01:49:35.050 --> 01:49:45.370
就是就是比如说我们都希望在考试中考100分对不对啊但是你真正能考100分的时候他没那么多对吧啊而且你想你要考100分的话

01:49:45.970 --> 01:49:55.810
你需要付出的时间成本也是比较高的啊那你习花仗这个时间成本去做些事的话啊你们不如可以说是追求一些他其他的事啊

01:49:56.050 --> 01:49:59.450
但这一块的话一会我还要再去说一说啊现在只是告一件事啊

01:50:00.290 --> 01:50:09.850
我们要按照这个原则去做事啊但不要说就是有了这些原则以后的话对吧啊我就在任何一个地方都不打破这个原则

01:50:09.850 --> 01:50:13.650
这也是不可能的啊啊ok 恳到这个开闭原则啊

01:50:13.810 --> 01:50:19.770
但基本上已经说完了因为开闭原则在后面碰到代码中咱还会去讲咱会去讲啊

01:50:20.490 --> 01:50:27.850
那你要知道一点开闭原则的核心是什么是针对于啊扩展这种思想啊你要有扩展这种思想

01:50:28.490 --> 01:50:32.290
那理事带换原则是什么意思呢理事带换原则是就是

01:50:33.290 --> 01:50:36.890
咱们讲开闭原则的时候说是可以通过继承的方式来扩展

01:50:37.530 --> 01:50:46.650
对不对啊那理事带换原则他所真的就是保证你啊在继承通过继承的方式来扩展的时候啊

01:50:47.090 --> 01:50:48.090
不出错啊

01:50:48.530 --> 01:50:53.450
有时候他这里面限定的条件是啊就是任何积累可以出现的地方

01:50:53.770 --> 01:51:01.450
子类一定可以出现通俗来讲就是子类可以扩展负责功能但不能修改负责原有的功能

01:51:01.530 --> 01:51:03.130
这也很好理解就比如说你这样

01:51:03.610 --> 01:51:08.890
这个例子咱就布局了咱换个例子啊比如说你的爷爷要给你留下了一笔遗产对吧

01:51:08.890 --> 01:51:15.930
遗产非常多的钱对吧啊啊但是这个例子可能不太好啊这个咱可以列成邓哥行吧比如说邓哥的啊

01:51:16.250 --> 01:51:22.650
远方亲近吧啊远方亲近啊给他留下了一笔遗产对吧这个遗产呢可能说是给邓哥的这个

01:51:23.170 --> 01:51:31.050
父亲啊啊比如说是他他俩有这样的一个直接类提升关系但邓哥的父亲啊这个可能突然也出了事了

01:51:31.450 --> 01:51:33.450
不能借上这笔遗产对吧那怎么办呢

01:51:33.690 --> 01:51:39.050
OK那指令是让你邓哥提升而出对不对啊但是你要知道如果说你邓哥

01:51:39.930 --> 01:51:48.410
他不能或说在法律上怎么样他不能去提升这笔遗产的话那指令这个东西会出问题的这笔遗产啊他给谁呢对吧

01:51:48.970 --> 01:51:57.370
那我们在开发工作的话精神会碰到这种情况啊比如说我那个负类啊功能不够多了对吧那怎么办呢啊我拿了一个子类去扩展他对吧

01:51:57.530 --> 01:52:00.730
那你快完以后的话OK比如说你把这个原有的负类功能给他

01:52:01.370 --> 01:52:11.930
改变对不对比如说他约有的这个功能啊你在子类的时候你给你给他改了的吧好了那拿这个原有负类啊去操作的地方啊你用把子类放进去啊

01:52:12.250 --> 01:52:23.210
那自然自然而然由于你可能说你改了这种原有的这个负质功能啊导致啊这个业务上或者说这个还缓解上出了这样的一个问题啊

01:52:23.530 --> 01:52:27.690
那这种情况下是不允许的啊所以说理事带上原则啥呢是

01:52:28.890 --> 01:52:35.690
啊在你扩展的时候啊他要保证你能可以通过继承的方式稳稳的进行这样的一个

01:52:36.330 --> 01:52:47.290
扩展啊那但理事带上原则往往考验的就是你对一些类的关系的一个世界的能力啊这块我拿代码给你写写啊你来体验体验啊你来体验体验

01:52:48.250 --> 01:52:55.050
呃比如说在这啊我先给你写一个叫做我看一下我先给你写一个呃比如说举行吗

01:52:55.050 --> 01:53:03.210
好吧啊举行啊啊 function叫做一个 i e c啊t n j e t n j e t n j e好在这呢

01:53:03.930 --> 01:53:12.730
在这我daster west等于一个零啊我daster hat h h e i h t r 等于一个零啊再来啊不是daster

01:53:13.130 --> 01:53:19.690
这是一个a set of bits比如说这个举行啊有个方法叫实质宽度行吧实质宽度啊这个宽度呢

01:53:19.690 --> 01:53:24.090
啊实质完以后他会让自己宽度等于这个啊等于你传过来参数这个west

01:53:26.910 --> 01:53:31.870
啊那除了实质宽度以外的话我实必还要让他再来一个实质高度

01:53:35.530 --> 01:53:39.690
实质高度啊那这个叫做h e i j h t对吧这个叫做

01:53:40.410 --> 01:53:44.810
h e i j h t等会啊叫做h e i j h t

01:53:45.770 --> 01:53:52.090
好那除此之外的话我再给他来一个方法叫做daster get west

01:53:54.920 --> 01:54:01.800
get west get west等于一个function啊那他是直接把这样的一个宽度给你返回

01:54:01.800 --> 01:54:06.440
行吧很多给你返回那再来一个叫做一个daster get hat

01:54:08.360 --> 01:54:12.360
等于一个function等于一个function我最后返回跟daster hat

01:54:12.920 --> 01:54:19.640
ok那这个举行这个类啊是我给的设计出来对吧给的是设计出来下面带码

01:54:19.640 --> 01:54:24.750
我给的注释一下注释一下注释好注释

01:54:26.430 --> 01:54:31.790
防止干扰我对吧啊好他写完以后的话比如说我再来一个function我再来一个

01:54:31.790 --> 01:54:35.950
子类啊比如说这个子类呢是我自己来给他规定的一个关系啊

01:54:35.950 --> 01:54:39.390
啊方式一个square他是一个方块正方形对吧那

01:54:40.350 --> 01:54:47.870
啊我们都知道这个啊方块跟举行之间是可以有这样那个比如说我规定吧

01:54:47.870 --> 01:54:54.430
哈我规定其实我们在这样那个正常人的一个思考过程中的话可能也会啊

01:54:54.430 --> 01:54:58.750
把他俩想成是一种关系对吧因为说这个方块正方形对吧

01:54:58.750 --> 01:55:02.830
他也是属于举行的一类对不对啊那好了那我就既然我报道这样

01:55:02.830 --> 01:55:07.390
那个理论对吧那我就让他实现一种继承的关系行不行我就new i c什么

01:55:07.870 --> 01:55:12.910
t le对吧好了那我这个方块我这个方块是不是势必要怎么样势必要

01:55:14.430 --> 01:55:18.110
有这个set advice对吧啊有这个方法啊方法啊我就实现他方法

01:55:18.110 --> 01:55:21.950
那我不实现他的方法的时候呢不是这样我给他自己加方法对吧

01:55:21.950 --> 01:55:25.790
我不给他加的方法呢那他当然就是使用他叠的对不对啊

01:55:25.790 --> 01:55:30.190
那我在写这个方法的时候你看一下再看一下我在使用这个方法的时候

01:55:30.190 --> 01:55:34.830
我干你这件事情啊呃因为我这个是方块对吧那方块的话

01:55:34.910 --> 01:55:36.510
是不是要框架是一直是一样的

01:55:36.510 --> 01:55:37.470
那我说this wise

01:55:37.470 --> 01:55:41.390
等于wise啊我让他的this height对吧 height

01:55:43.230 --> 01:55:46.030
h e i ght啊好了

01:55:46.030 --> 01:55:49.950
但是wise啊也有点wise啊因为你在设置宽度宽度的时候

01:55:49.950 --> 01:55:52.670
你要的框架一点是一模一样的对不对啊但是同样的话

01:55:52.670 --> 01:55:56.190
再来个set height对吧set head你在设置高度的时候呢

01:55:56.190 --> 01:55:58.030
好我就可以直接这样我就可以直接

01:55:59.310 --> 01:56:01.150
h e i oh ght

01:56:02.110 --> 01:56:07.630
通过this set wise啊来进行啊同样还是让你框架一样啊

01:56:07.630 --> 01:56:12.030
那这些符合方块的一个这个特性啊但你会发现啊

01:56:12.030 --> 01:56:16.190
我在设置这个类关系关系的时候确实让他实现这种继承关系对吧

01:56:16.190 --> 01:56:19.310
但我在实现这个哎紫块的一个功能的时候

01:56:19.310 --> 01:56:23.710
你会发现其实哎我是又怎么样我是又重写他的他的对吧

01:56:23.710 --> 01:56:26.430
并且把这个负累的这个功能给改了啊

01:56:26.430 --> 01:56:30.670
那改完以后的话他就很有可能因为你这个类的关系设计不当

01:56:30.670 --> 01:56:35.630
加上你改了这个东西啊就违违了理事带换原则

01:56:35.630 --> 01:56:39.550
那咱们看一下我现在写一个方法这个方法叫做一个resets

01:56:39.550 --> 01:56:43.550
方法啊假如我这个负累啊我这个负累这个对象啊

01:56:43.550 --> 01:56:48.110
他原先载这个方法他原先载这个函数中啊去使用啊

01:56:48.110 --> 01:56:52.510
就比如说我现在通过一个or一个or等于一个new

01:56:52.510 --> 01:56:58.190
re c 挺脚一挺脚一挺脚一啊我去

01:56:59.150 --> 01:57:04.190
通过desets ys来设计一个宽度就是200什么200啊

01:57:04.190 --> 01:57:08.590
举行的话可以是宽高是不一样的set hat就是100啊

01:57:08.590 --> 01:57:13.070
好比如说我把这个or啊传进去啊

01:57:13.070 --> 01:57:16.350
当刚才说传进去我这写个o吧这写的o啊

01:57:16.350 --> 01:57:18.510
我们在最后掉这个resets的时候啊

01:57:18.510 --> 01:57:20.830
i s i zi i s i zi

01:57:20.830 --> 01:57:25.950
我传进去啊我传进以后那这个里面具体要实现什么功能呢啊

01:57:26.030 --> 01:57:28.670
就他只做一件事情他只做一件事情啊

01:57:28.670 --> 01:57:34.030
他这些就是啊不断的去把这个高度加加成什么样的

01:57:34.030 --> 01:57:40.110
啊加成这个高度啊大于等于宽度啊就停止

01:57:40.110 --> 01:57:42.190
行吧但有的宽度就停止

01:57:42.190 --> 01:57:46.190
那我这边再写这个功能的时候就是O点啊get hat

01:57:46.190 --> 01:57:49.310
我先来判断一下你这个举行的这个高度啊

01:57:49.310 --> 01:57:53.550
是否有这个大于这个宽度对吧

01:57:53.550 --> 01:57:57.470
但是如果说你这个小于等于宽度的话啊

01:57:57.470 --> 01:58:02.110
我就怎么样我就让你O的set hat

01:58:02.110 --> 01:58:07.470
那等于O的get West加一个e啊

01:58:07.470 --> 01:58:10.990
又说这什么意思呢就是我这个resets这个功能啊

01:58:10.990 --> 01:58:13.550
就是当你这样传进来以后的话去看一下对吧

01:58:13.550 --> 01:58:15.310
看一下你的高度是否小于等于他对吧

01:58:15.310 --> 01:58:20.990
如果小于等于他的话我就把我就把你这个宽度啊去负给他

01:58:21.230 --> 01:58:24.030
把你这个宽度去负给他啊

01:58:24.030 --> 01:58:26.750
但是负给他以后的话那他自然怎么样

01:58:26.750 --> 01:58:28.990
他自然就应该比他大对吧

01:58:28.990 --> 01:58:30.190
当他比他大以后的话

01:58:30.190 --> 01:58:32.670
是不是就应该去跳出循环就完事了对不对

01:58:32.670 --> 01:58:36.190
啊那比如说我这个resets这个功能他就是这样的啊

01:58:36.190 --> 01:58:38.590
那我传OR的时候再来看一下啊

01:58:38.590 --> 01:58:41.310
再从理论上来推的推老一下看有没有问题

01:58:41.310 --> 01:58:44.670
传OR的时候首先OR的宽度200高100对不对

01:58:44.670 --> 01:58:46.190
100小于等于他吗

01:58:46.190 --> 01:58:48.030
100小于等于200是一定的了

01:58:48.030 --> 01:58:50.750
我通过set hat来试着他的一个高度

01:58:50.830 --> 01:58:51.870
那高度等于多少呢

01:58:51.870 --> 01:58:53.870
高度等于200加1201

01:58:53.870 --> 01:58:55.070
20001好了

01:58:55.070 --> 01:58:57.630
下次再判断的时候他的高度变成201了

01:58:57.630 --> 01:58:59.150
小于等于他们不小于等于

01:58:59.150 --> 01:59:00.270
OK跳出循环

01:59:00.270 --> 01:59:01.870
那他就一定可以在这输出OR

01:59:04.330 --> 01:59:05.450
那输出说OR

01:59:05.450 --> 01:59:06.730
那咱看行不行啊

01:59:06.730 --> 01:59:08.330
我刷新一下现在啊对吧

01:59:08.330 --> 01:59:10.250
在这我open in default browser一下

01:59:10.250 --> 01:59:11.370
我刷新一次

01:59:11.370 --> 01:59:11.930
看一眼

01:59:12.650 --> 01:59:14.410
可受啊刚我爆了个错对吧

01:59:14.410 --> 01:59:16.330
刚我是25行爆了个错

01:59:16.330 --> 01:59:19.130
那咱来看一下25行爆了什么样的错误啊

01:59:19.130 --> 01:59:20.730
25行啊这是

01:59:21.610 --> 01:59:22.330
产生错的吧

01:59:22.330 --> 01:59:23.290
就是一个YS啊

01:59:23.290 --> 01:59:24.090
保存一次

01:59:24.090 --> 01:59:24.810
来再刷新一下

01:59:24.810 --> 01:59:25.530
看一眼啊

01:59:25.530 --> 01:59:27.050
OR能输出OR的吧

01:59:27.050 --> 01:59:29.530
那咱看一下这个OR输出以后

01:59:29.530 --> 01:59:31.210
你会发现他的宽高怎么样

01:59:31.210 --> 01:59:34.010
都变了200和20001对不对

01:59:34.010 --> 01:59:35.610
那到这的话应该没问题啊

01:59:36.650 --> 01:59:37.770
如果来看一下

01:59:38.330 --> 01:59:38.650
如果

01:59:40.490 --> 01:59:40.970
如果

01:59:44.540 --> 01:59:46.220
如果现在我不用这个OR的吧

01:59:46.220 --> 01:59:46.780
我不用OR

01:59:46.780 --> 01:59:47.260
我用啥呢

01:59:47.260 --> 01:59:48.460
我用这个OG

01:59:48.460 --> 01:59:49.660
OG呢咱看一下

01:59:50.140 --> 01:59:52.060
OG就是OS

01:59:52.620 --> 01:59:53.260
OS

01:59:53.260 --> 01:59:54.860
那OS是它的一个子类的吧

01:59:54.860 --> 01:59:56.700
那我New一个这个square吧

01:59:56.700 --> 01:59:57.900
New一个square

01:59:57.900 --> 01:59:58.860
New square后的话

01:59:58.860 --> 01:59:59.660
现在我这么做

01:59:59.660 --> 02:00:00.300
现在我这么做

02:00:01.180 --> 02:00:02.460
我OS啊

02:00:02.460 --> 02:00:02.780
第二

02:00:03.820 --> 02:00:04.460
SET

02:00:04.460 --> 02:00:05.020
OS

02:00:05.020 --> 02:00:05.660
SETOS以后

02:00:05.660 --> 02:00:07.260
我直接传个200行吗

02:00:07.260 --> 02:00:08.140
传个200

02:00:08.140 --> 02:00:09.740
那当然我OG的SET

02:00:09.740 --> 02:00:11.260
HIT我也传个200对吧

02:00:11.260 --> 02:00:13.420
那咱自然宽高一定都是200

02:00:13.420 --> 02:00:14.220
那现在啊

02:00:14.220 --> 02:00:15.020
现在很好了

02:00:15.020 --> 02:00:16.220
我来传这个OS

02:00:16.220 --> 02:00:17.180
我来传这个OS

02:00:17.180 --> 02:00:19.340
咱来看一下会有什么样的反应

02:00:19.340 --> 02:00:20.460
会有什么样的反应

02:00:20.460 --> 02:00:21.420
刷新一次

02:00:21.580 --> 02:00:22.380
咱不说嘛

02:00:22.380 --> 02:00:23.740
那个理事条原则说

02:00:23.740 --> 02:00:24.380
子类啊

02:00:24.380 --> 02:00:25.260
附类在的地方子类

02:00:25.260 --> 02:00:26.700
一定要可以在

02:00:26.700 --> 02:00:27.180
对吧

02:00:27.180 --> 02:00:28.380
那现在看它

02:00:28.380 --> 02:00:28.860
刷新一次

02:00:28.860 --> 02:00:29.820
你会发现现在

02:00:29.820 --> 02:00:31.420
这一直在转圈圈

02:00:31.420 --> 02:00:33.020
它永远都不会停下来

02:00:33.020 --> 02:00:33.820
死去亡了

02:00:33.820 --> 02:00:35.180
比如说程序出问题了

02:00:35.180 --> 02:00:36.220
爆错

02:00:36.220 --> 02:00:37.180
它们没爆错对吧

02:00:37.180 --> 02:00:38.620
但是它卡住了

02:00:38.620 --> 02:00:41.020
可能最后导致整个程序的崩溃对吧

02:00:41.020 --> 02:00:41.580
那

02:00:41.580 --> 02:00:43.820
也就是说你不管理事带换原则去做的话

02:00:43.820 --> 02:00:43.980
对吧

02:00:43.980 --> 02:00:45.420
那你在通过这种子类

02:00:45.420 --> 02:00:45.900
比如说

02:00:45.900 --> 02:00:48.300
你想通过这个square来扩展它的时候

02:00:48.300 --> 02:00:50.460
你会发现的出问题了对吧

02:00:50.620 --> 02:00:51.820
原来的这个附类

02:00:51.820 --> 02:00:53.180
载着可以很好的使用对吧

02:00:53.180 --> 02:00:54.940
那你通过os来扩展它

02:00:54.940 --> 02:00:56.380
现在你用它来贴换它的话

02:00:56.380 --> 02:00:57.340
你会发现现在

02:00:57.340 --> 02:00:58.220
OK出问题了

02:00:58.220 --> 02:01:01.340
那理事带换原则的这样的一个目的

02:01:01.340 --> 02:01:03.420
就是让你在这个扩展的时候

02:01:03.420 --> 02:01:03.980
尽量

02:01:04.860 --> 02:01:05.420
怎么

02:01:05.420 --> 02:01:06.700
就是让你尽量的

02:01:06.700 --> 02:01:08.700
能去通过扩展的方式

02:01:09.900 --> 02:01:11.500
来去降低它这样的一个复杂度

02:01:11.500 --> 02:01:11.900
对吧

02:01:11.900 --> 02:01:13.740
保证它可以

02:01:13.740 --> 02:01:14.700
去扩展

02:01:15.980 --> 02:01:16.620
那

02:01:17.820 --> 02:01:20.140
当然这个里面为什么会不好使呢

02:01:20.140 --> 02:01:21.420
简单你看一下

02:01:21.420 --> 02:01:23.420
我这个os来设置宽度的时候

02:01:23.420 --> 02:01:25.100
它同时会设置宽高

02:01:25.100 --> 02:01:25.660
对吧

02:01:25.660 --> 02:01:25.900
好

02:01:25.900 --> 02:01:26.780
那你说宽

02:01:26.780 --> 02:01:28.460
就是无论你设置高度也好

02:01:28.460 --> 02:01:29.420
还是宽度也好

02:01:29.420 --> 02:01:31.500
它都会怎么样去走它

02:01:31.500 --> 02:01:32.300
走它的话

02:01:32.300 --> 02:01:33.660
会让这个宽高

02:01:33.660 --> 02:01:37.420
会让这个宽度和高度必须是使用相等的

02:01:37.420 --> 02:01:37.660
对吧

02:01:37.660 --> 02:01:39.020
没有其他情况

02:01:39.020 --> 02:01:40.860
那好把os一传双眼后的话

02:01:40.860 --> 02:01:41.980
它来判断

02:01:41.980 --> 02:01:43.740
这个head是不小于等于它吗

02:01:43.740 --> 02:01:44.620
一开始都是200

02:01:44.620 --> 02:01:44.860
对吧

02:01:44.860 --> 02:01:46.300
一定小于等于它对吧

02:01:46.300 --> 02:01:46.460
好

02:01:46.460 --> 02:01:48.060
那现在我设置高度

02:01:48.060 --> 02:01:49.820
不让高度等于它的宽度加1

02:01:49.980 --> 02:01:50.540
知道吧

02:01:50.540 --> 02:01:51.100
是201

02:01:51.100 --> 02:01:51.900
201 ok

02:01:51.900 --> 02:01:53.340
再复制给它以后的话

02:01:53.340 --> 02:01:54.380
逗send head

02:01:54.380 --> 02:01:55.420
send head你看好了

02:01:55.420 --> 02:01:57.180
它还是会变换这个宽度对吧

02:01:57.180 --> 02:01:58.620
还是会变换宽度以后的话

02:01:58.620 --> 02:01:59.900
201又复给它俩

02:01:59.900 --> 02:02:01.180
它俩还是相等的

02:02:01.180 --> 02:02:03.340
于是红的这个东西就一直喜欢

02:02:03.340 --> 02:02:04.300
死军还对吧

02:02:04.300 --> 02:02:05.500
死军还

02:02:05.500 --> 02:02:05.900
死军还

02:02:05.900 --> 02:02:07.980
那这是一个经典的一个例子

02:02:07.980 --> 02:02:09.740
也是它能反映出来对吧

02:02:09.740 --> 02:02:12.140
你不按理事带换原则去做事的话

02:02:12.140 --> 02:02:16.380
确实会出现一些困扰上的一些问题

02:02:16.380 --> 02:02:19.260
有时候它考验的是你这个带马式的一个

02:02:19.580 --> 02:02:22.220
这个类关系之间的一个设计的一个能力

02:02:23.100 --> 02:02:23.420
ok

02:02:24.860 --> 02:02:27.020
这是理事带换原则对吧

02:02:27.020 --> 02:02:27.260
好

02:02:28.860 --> 02:02:29.340
有点累

02:02:30.380 --> 02:02:30.780
有累

02:02:30.780 --> 02:02:31.180
好

02:02:31.180 --> 02:02:31.420
这样

02:02:33.180 --> 02:02:33.500
再来

02:02:33.500 --> 02:02:33.660
好

02:02:33.660 --> 02:02:34.780
这样再来

02:02:34.780 --> 02:02:35.260
再来

02:02:35.260 --> 02:02:35.420
好

02:02:35.420 --> 02:02:35.980
再来

02:02:35.980 --> 02:02:36.540
不着急

02:02:36.540 --> 02:02:36.700
好

02:02:36.700 --> 02:02:37.100
不着急

02:02:37.100 --> 02:02:37.740
再来

02:02:37.740 --> 02:02:38.940
再咱咱看一下

02:02:38.940 --> 02:02:39.580
咱看一下这个

02:02:40.700 --> 02:02:42.140
依赖道治原则

02:02:42.140 --> 02:02:43.180
依赖道治原则

02:02:44.220 --> 02:02:45.580
讲依赖道治原则之前的话

02:02:45.580 --> 02:02:47.180
我先来说一下这个最后一个

02:02:47.180 --> 02:02:47.660
这个

02:02:47.660 --> 02:02:49.340
叫做接口分离原则

02:02:49.340 --> 02:02:51.260
在前段中什么叫接口分离原则

02:02:51.260 --> 02:02:51.980
你给想象一下

02:02:52.540 --> 02:02:52.940
比如说

02:02:54.300 --> 02:02:55.740
我们写作业对吧

02:02:55.740 --> 02:02:56.620
我们写作业

02:02:57.020 --> 02:02:57.580
如果说

02:02:57.580 --> 02:02:59.180
你说写写作业的话

02:02:59.180 --> 02:03:01.100
比如很难能明白什么意思的吧

02:03:01.100 --> 02:03:01.660
而且说

02:03:01.660 --> 02:03:02.780
比如说你自己想啊

02:03:02.780 --> 02:03:03.500
我要写作业

02:03:03.500 --> 02:03:04.300
但你作业很多

02:03:04.300 --> 02:03:05.420
它很多对不对

02:03:05.420 --> 02:03:06.540
也没有清晰化的话

02:03:06.540 --> 02:03:07.100
你可能

02:03:07.100 --> 02:03:07.900
这回写作业

02:03:07.900 --> 02:03:08.380
这回写作业

02:03:08.380 --> 02:03:09.180
这回写作业对吧

02:03:09.180 --> 02:03:09.900
你写写写的话

02:03:09.900 --> 02:03:11.180
你写很乱了对不对

02:03:11.820 --> 02:03:12.700
那怎么办呢

02:03:12.700 --> 02:03:15.500
我们尽量把这个写作业这个事情给它拆分

02:03:15.500 --> 02:03:15.900
拆分

02:03:15.900 --> 02:03:16.860
我要写数学作业

02:03:16.940 --> 02:03:17.580
写英语作业

02:03:17.580 --> 02:03:18.620
写语文作业对吧

02:03:19.180 --> 02:03:20.620
那当它拆分以后的话

02:03:20.620 --> 02:03:21.740
当它自然而然这种

02:03:21.740 --> 02:03:23.580
偶和度就降低了

02:03:23.580 --> 02:03:23.900
对吧

02:03:23.900 --> 02:03:25.020
太凶难解偶

02:03:25.020 --> 02:03:26.460
原来做的事情都放在一起

02:03:26.460 --> 02:03:26.940
对不对

02:03:26.940 --> 02:03:27.180
好

02:03:27.180 --> 02:03:28.060
写作业可以作业

02:03:28.060 --> 02:03:28.780
它放在一起了

02:03:28.780 --> 02:03:29.500
现在也不是了

02:03:29.500 --> 02:03:30.220
现在要怎么样

02:03:30.220 --> 02:03:32.060
拆分来写不同的作业

02:03:32.620 --> 02:03:33.180
那这个

02:03:34.620 --> 02:03:36.540
比如说在前段应用中

02:03:36.540 --> 02:03:37.660
你给这么来想

02:03:37.660 --> 02:03:39.020
我发送一个请求

02:03:39.020 --> 02:03:40.780
比如说这个请求

02:03:40.780 --> 02:03:42.060
请求的是一个U.N

02:03:42.060 --> 02:03:42.860
这个U.N呢

02:03:43.740 --> 02:03:45.020
它有几个功能

02:03:45.020 --> 02:03:45.820
什么功能就是

02:03:46.140 --> 02:03:50.940
你既能去通过pulse的方式

02:03:50.940 --> 02:03:52.220
去增添

02:03:52.220 --> 02:03:54.780
和在这个数据库里面

02:03:54.780 --> 02:03:56.060
去增添一些数据

02:03:56.060 --> 02:03:57.340
又能通过一种

02:03:57.340 --> 02:03:59.900
又能通过这样的一些参数

02:03:59.900 --> 02:04:02.220
也要求它去通过这个接口来

02:04:02.220 --> 02:04:03.740
删除一些数据

02:04:03.740 --> 02:04:04.460
而且还能改

02:04:04.460 --> 02:04:05.260
而且还能查

02:04:05.260 --> 02:04:05.580
对吧

02:04:05.580 --> 02:04:06.540
要说这个接口

02:04:06.540 --> 02:04:08.460
把很多功能全实现了

02:04:08.460 --> 02:04:09.420
就拿一个接口来

02:04:09.420 --> 02:04:10.060
对吧

02:04:10.060 --> 02:04:11.260
那如果你这么做以后的话

02:04:11.260 --> 02:04:11.820
你想象一下

02:04:11.820 --> 02:04:13.340
这个接口能实现这么多功能

02:04:13.340 --> 02:04:14.380
那它必然而然

02:04:14.380 --> 02:04:15.500
可能需要去接受

02:04:15.820 --> 02:04:17.260
更多种参数

02:04:17.260 --> 02:04:19.660
那需要接受更多种参数的话

02:04:19.660 --> 02:04:21.900
那这个接口在实现功能的时候

02:04:21.900 --> 02:04:23.180
它就这个复杂度

02:04:23.180 --> 02:04:25.260
当然它会去提升很多

02:04:25.900 --> 02:04:27.260
而且你要知道一点

02:04:27.260 --> 02:04:29.580
当这个接口一旦崩了以后的话

02:04:29.580 --> 02:04:30.620
一旦出错以后

02:04:31.420 --> 02:04:32.940
一旦你不能用了

02:04:32.940 --> 02:04:33.100
对吧

02:04:33.100 --> 02:04:33.980
一旦你不能用了

02:04:33.980 --> 02:04:35.660
那你的增山改查

02:04:35.660 --> 02:04:37.340
这几个功能都不能使用了

02:04:37.900 --> 02:04:39.980
它的不稳定性也是非常强的

02:04:39.980 --> 02:04:40.620
所以说

02:04:40.620 --> 02:04:41.340
我们可以怎么办

02:04:41.340 --> 02:04:42.380
我们可以把这种

02:04:42.380 --> 02:04:44.220
网络的接口

02:04:44.300 --> 02:04:45.500
增山改查

02:04:45.500 --> 02:04:45.740
对吧

02:04:45.740 --> 02:04:46.140
你可以怎么样

02:04:46.140 --> 02:04:47.980
你可以分成这多个

02:04:47.980 --> 02:04:49.420
比如说增是一个对吧

02:04:49.420 --> 02:04:50.140
山是一个

02:04:50.780 --> 02:04:51.420
比如这个

02:04:51.420 --> 02:04:52.860
这个查是一个

02:04:52.860 --> 02:04:54.220
改是一个对吧

02:04:54.220 --> 02:04:55.980
那当你某个接口崩了以后

02:04:55.980 --> 02:04:56.780
能自然而然的话

02:04:56.780 --> 02:04:58.220
不影响到其他的对吧

02:04:58.220 --> 02:04:59.980
就比如说你山的接口没了对吧

02:04:59.980 --> 02:05:01.020
但至少用户

02:05:01.020 --> 02:05:02.140
还能通过查的接口

02:05:02.140 --> 02:05:03.500
把数据查过来

02:05:03.500 --> 02:05:04.140
来展示出来

02:05:04.140 --> 02:05:05.340
你可以去看的

02:05:05.340 --> 02:05:07.260
它叫接口分离原则

02:05:07.260 --> 02:05:08.620
接口分离原则

02:05:08.620 --> 02:05:09.020
OK

02:05:09.020 --> 02:05:10.300
那它作为咱们这样的一个

02:05:10.300 --> 02:05:10.940
第二个原则

02:05:10.940 --> 02:05:11.980
再来去说一说

02:05:11.980 --> 02:05:13.260
在前面的一些应用

02:05:13.260 --> 02:05:14.140
现在这种应用

02:05:14.140 --> 02:05:15.660
那基本在应用的功能中的话

02:05:15.660 --> 02:05:17.500
也不太由你去操作

02:05:17.500 --> 02:05:19.020
因为接口之后来才来给你的

02:05:19.020 --> 02:05:20.220
那你学到note的时候

02:05:20.220 --> 02:05:21.340
你可以自己来去写一些

02:05:21.340 --> 02:05:22.940
那咱们往前来说

02:05:22.940 --> 02:05:26.780
咱们前面三个原则全搞定了

02:05:26.780 --> 02:05:28.140
这三个原则

02:05:28.140 --> 02:05:29.340
它都是怎么样

02:05:29.340 --> 02:05:30.620
在开发流程中的话

02:05:30.620 --> 02:05:32.620
可以降低电码复杂度

02:05:32.620 --> 02:05:34.220
那降低电码复杂度以后怎么样

02:05:34.220 --> 02:05:36.460
会去提高这样的一个鸿合度

02:05:36.460 --> 02:05:37.340
那接下来

02:05:37.340 --> 02:05:38.940
接下来我们来说一下这样的一个

02:05:41.020 --> 02:05:42.300
叫做这个

02:05:42.300 --> 02:05:43.420
迪米特法则

02:05:43.420 --> 02:05:45.340
把他给他给出s一下

02:05:45.340 --> 02:05:47.820
放到这个一代到处原则的前面

02:05:47.820 --> 02:05:48.780
比较好一点

02:05:48.780 --> 02:05:50.540
这是写一个4

02:05:50.540 --> 02:05:51.980
这写一个4

02:05:51.980 --> 02:05:53.740
这是我搞了一个5

02:05:53.740 --> 02:05:54.780
这搞了一个5

02:05:54.780 --> 02:05:55.900
好

02:05:55.900 --> 02:05:57.740
那这个迪米特法则

02:05:57.740 --> 02:05:58.060
什么意思

02:05:58.060 --> 02:05:59.980
叫做最小知道原则

02:05:59.980 --> 02:06:01.500
那最小知道原则则的话

02:06:01.500 --> 02:06:03.340
就是这边说一个接口

02:06:03.340 --> 02:06:04.220
和一个方法

02:06:04.220 --> 02:06:06.540
我们尽量它传入的参数越少越好

02:06:06.540 --> 02:06:07.020
对吧

02:06:07.020 --> 02:06:08.940
那它降低有何度的同时

02:06:08.940 --> 02:06:10.140
也会其实有一个时候

02:06:10.140 --> 02:06:12.220
会降低复杂度

02:06:12.220 --> 02:06:13.140
那为什么这么做呢

02:06:13.140 --> 02:06:14.740
咱拿现实生活中来想的话

02:06:14.740 --> 02:06:16.340
比如说如果是个点赞片的话

02:06:16.340 --> 02:06:18.220
你和你同伙都是间谍

02:06:18.220 --> 02:06:19.380
说你俩会让人知道

02:06:19.380 --> 02:06:20.620
还是他不知道好

02:06:20.620 --> 02:06:21.940
如果会让人知道情况下的话

02:06:21.940 --> 02:06:22.860
比如说他出事了

02:06:22.860 --> 02:06:24.780
他可能会通过言行逼供

02:06:24.780 --> 02:06:25.860
把你给捅出来

02:06:25.860 --> 02:06:26.700
那你也出事了

02:06:26.700 --> 02:06:27.180
对吧

02:06:27.180 --> 02:06:28.540
那自然而言的话

02:06:28.540 --> 02:06:29.980
比如说以前可能说

02:06:29.980 --> 02:06:31.500
这个他有事

02:06:31.500 --> 02:06:32.460
你俩会让人不知道的话

02:06:32.460 --> 02:06:33.620
一条线全都挂了

02:06:33.620 --> 02:06:34.060
对吧

02:06:34.060 --> 02:06:35.820
那现在你俩会让他知道情况下的话

02:06:35.820 --> 02:06:36.780
可能说是两条线

02:06:36.780 --> 02:06:37.780
他全都挂了

02:06:37.780 --> 02:06:39.020
那么为了降低

02:06:39.020 --> 02:06:40.340
最少一个伤害的话

02:06:40.340 --> 02:06:41.060
辞职死

02:06:41.060 --> 02:06:42.180
就一条线来人

02:06:42.180 --> 02:06:42.900
我们怎么样

02:06:42.900 --> 02:06:44.180
要最小知道

02:06:44.180 --> 02:06:45.580
最好你的互相都不知道

02:06:45.580 --> 02:06:47.100
那你说这个方法

02:06:47.100 --> 02:06:50.180
对象形成的这样的一个关联

02:06:50.180 --> 02:06:52.180
当然是越少越好

02:06:52.180 --> 02:06:52.620
对吧

02:06:52.620 --> 02:06:54.900
但是如果说关联

02:06:54.900 --> 02:06:55.260
对吧

02:06:55.260 --> 02:06:56.860
少不了情况下的话

02:06:56.860 --> 02:06:57.660
我们怎么办呢

02:06:57.660 --> 02:06:59.060
我们在形成关联的时候

02:06:59.060 --> 02:07:01.700
希望他们彼此之间传令的参数

02:07:01.700 --> 02:07:03.260
越少越好

02:07:03.260 --> 02:07:04.220
越少越好

02:07:04.220 --> 02:07:05.100
你想象一下

02:07:05.100 --> 02:07:06.780
比如说我一个函数的功能

02:07:06.780 --> 02:07:09.140
他可能需要依赖于10个函数

02:07:09.140 --> 02:07:10.460
这样的一个功能

02:07:10.460 --> 02:07:11.940
或者10个这样的一个函数

02:07:11.940 --> 02:07:13.020
这个马上这样的一个

02:07:13.020 --> 02:07:14.980
只往里面传参数的话

02:07:14.980 --> 02:07:16.340
那就很麻烦

02:07:16.340 --> 02:07:17.380
首先

02:07:17.380 --> 02:07:19.540
我这哥们的复杂度一定不会逼

02:07:19.540 --> 02:07:20.060
因为怎么样

02:07:20.060 --> 02:07:21.060
因为你参数多的话

02:07:21.060 --> 02:07:22.940
你要处理这么多参数

02:07:22.940 --> 02:07:23.940
你这里面的判断

02:07:23.940 --> 02:07:26.140
分析逻辑就会非常复杂

02:07:26.140 --> 02:07:27.260
其次

02:07:27.260 --> 02:07:28.860
因为发发现

02:07:28.860 --> 02:07:31.260
他这个出粗的概率也非常大

02:07:31.260 --> 02:07:33.340
而且你可维护的概率

02:07:33.340 --> 02:07:35.420
你可维护的这样一个

02:07:35.420 --> 02:07:37.300
就是可维护性的话

02:07:37.300 --> 02:07:38.700
他也会非常低

02:07:38.700 --> 02:07:40.260
就比如说10个东西

02:07:40.260 --> 02:07:41.620
如果有一个他出问题

02:07:41.620 --> 02:07:42.620
有一个要修改

02:07:42.620 --> 02:07:44.140
一个出错了

02:07:44.140 --> 02:07:46.900
他都会影响到你这个

02:07:46.900 --> 02:07:48.860
比如说依赖于10个的这些方法

02:07:48.860 --> 02:07:50.820
或者这样的一个对象

02:07:50.820 --> 02:07:54.500
会出现这种比较恶心的一些的问题

02:07:54.500 --> 02:07:54.820
所以说

02:07:54.820 --> 02:07:57.020
丁明他法则要求什么呢

02:07:57.020 --> 02:07:59.060
要求就是你在写一个方法的时候

02:07:59.060 --> 02:07:59.740
这个方法

02:07:59.740 --> 02:08:01.820
他不可能不跟别人形成关联

02:08:01.820 --> 02:08:02.420
对吧

02:08:02.420 --> 02:08:05.540
他不可能不接受一些参数

02:08:05.540 --> 02:08:05.940
那好了

02:08:05.940 --> 02:08:07.660
那你在实验参数怎么办呢

02:08:07.660 --> 02:08:10.700
你让他接受参数的这样的一个个数

02:08:10.700 --> 02:08:12.340
越少就越好

02:08:12.340 --> 02:08:13.700
那咱看一下开发流程

02:08:13.700 --> 02:08:14.180
开发流程

02:08:14.180 --> 02:08:14.780
开发流程什么呢

02:08:14.780 --> 02:08:17.620
就是我们当我们通过这些东西

02:08:17.620 --> 02:08:19.780
把这样的一个复杂度降低了

02:08:19.780 --> 02:08:20.380
降低以后

02:08:20.380 --> 02:08:22.300
我们可以通过迪米特法则

02:08:22.300 --> 02:08:25.580
尽量减少偶和度

02:08:25.580 --> 02:08:26.820
这样减少偶和度

02:08:26.820 --> 02:08:28.020
那同学说

02:08:28.020 --> 02:08:30.180
同学之前对偶和度的理解是啥呢

02:08:30.180 --> 02:08:33.420
就是这个A和B的吧

02:08:33.420 --> 02:08:34.780
只要他俩有关系

02:08:34.780 --> 02:08:36.700
他就是偶和对吧

02:08:36.700 --> 02:08:37.900
他俩没关系的话

02:08:37.900 --> 02:08:39.060
就是不偶和对不对

02:08:39.060 --> 02:08:40.260
那不是说我们之前想的

02:08:40.260 --> 02:08:41.740
减少偶和度是啥呢

02:08:41.740 --> 02:08:44.820
就是这个比如说A、B、C、D

02:08:44.820 --> 02:08:45.340
对吧

02:08:45.340 --> 02:08:47.260
最好他们就是A和B脸

02:08:47.260 --> 02:08:47.980
B和C脸

02:08:47.980 --> 02:08:49.060
C和D脸对不对

02:08:49.060 --> 02:08:52.380
那不要说这种A和B、D、C全都脸

02:08:52.380 --> 02:08:54.660
C和B、D、C全都脸对吧

02:08:54.660 --> 02:08:55.060
那之后

02:08:55.060 --> 02:08:56.820
D和A、B、C全都脸

02:08:56.820 --> 02:08:58.540
他不要这样

02:08:58.540 --> 02:08:59.500
他不要这样

02:08:59.500 --> 02:09:02.660
因为不是是这样的

02:09:02.660 --> 02:09:04.140
我们之前可能想是这样

02:09:04.140 --> 02:09:05.780
就是我们降低偶和度是啥呢

02:09:05.780 --> 02:09:08.820
是比如说这个A和B和C和D

02:09:09.300 --> 02:09:11.220
比如说你最好只分成四块

02:09:11.220 --> 02:09:12.820
A和B和C和D

02:09:12.820 --> 02:09:13.380
对吧

02:09:13.380 --> 02:09:13.900
一脸的话

02:09:13.900 --> 02:09:15.220
今晚就要看事

02:09:15.220 --> 02:09:16.340
你再多个D

02:09:16.340 --> 02:09:17.020
你再多个E

02:09:17.020 --> 02:09:17.740
再多个F

02:09:17.740 --> 02:09:18.980
再多个什么

02:09:18.980 --> 02:09:19.740
这一对吧

02:09:19.740 --> 02:09:20.500
你多这么多的话

02:09:20.500 --> 02:09:22.460
那自然这个脸就更多了

02:09:22.460 --> 02:09:23.700
偶和度也更多

02:09:23.700 --> 02:09:24.300
对不对

02:09:24.300 --> 02:09:25.500
我们之前可能会想

02:09:25.500 --> 02:09:27.380
我们降低偶和度是什么意思呢

02:09:27.380 --> 02:09:28.740
是尽可能的

02:09:28.740 --> 02:09:31.340
让这些脸各数变得少

02:09:31.340 --> 02:09:33.100
脸各数变得少

02:09:33.100 --> 02:09:36.460
比如说我不要就是有这些什么

02:09:36.460 --> 02:09:37.700
只有A、B、C就好

02:09:37.820 --> 02:09:40.060
不要有什么D、E、F什么对吧

02:09:40.060 --> 02:09:41.020
因为你再有了以后的话

02:09:41.020 --> 02:09:42.100
这个下身指定就多了

02:09:42.100 --> 02:09:43.020
对吧

02:09:43.020 --> 02:09:44.580
但是基本上法则

02:09:44.580 --> 02:09:46.180
这种减少偶和度

02:09:46.180 --> 02:09:47.300
他有的时候

02:09:47.300 --> 02:09:50.340
并不是说让这个什么D、C、F

02:09:50.340 --> 02:09:52.820
让这个什么D、E、F变得少

02:09:52.820 --> 02:09:54.420
他可以保留D、F

02:09:54.420 --> 02:09:55.420
但是他让什么

02:09:55.420 --> 02:09:58.940
他让你这种关系变得不那么复杂一些

02:09:58.940 --> 02:10:01.980
就是你这个A只和B脸就OK了

02:10:01.980 --> 02:10:05.140
你不要说这个A跟B、C、D、E全都脸

02:10:05.140 --> 02:10:05.900
那这一块的话

02:10:05.900 --> 02:10:06.820
我可以给你画个图

02:10:06.860 --> 02:10:07.380
来画图

02:10:07.380 --> 02:10:09.100
咱俩去详细的去理解一下

02:10:09.100 --> 02:10:09.940
MSP、NT

02:10:09.940 --> 02:10:11.620
PINCH

02:10:11.620 --> 02:10:12.540
比如说现在

02:10:15.280 --> 02:10:15.920
比如说这样

02:10:15.920 --> 02:10:17.600
比如说你写的代码

02:10:19.400 --> 02:10:20.840
说你写的代码

02:10:20.840 --> 02:10:21.760
你写的代码

02:10:21.760 --> 02:10:22.600
比如说一大坨

02:10:22.600 --> 02:10:23.120
对吧

02:10:23.120 --> 02:10:23.960
没有这里面

02:10:26.520 --> 02:10:27.520
比如说写的一大坨

02:10:27.520 --> 02:10:27.800
对吧

02:10:29.480 --> 02:10:30.480
就画很多很多线

02:10:30.480 --> 02:10:30.680
对吧

02:10:30.680 --> 02:10:31.120
一大坨

02:10:40.600 --> 02:10:41.200
一大坨

02:10:42.000 --> 02:10:42.320
好

02:10:42.320 --> 02:10:43.000
是吗

02:10:43.000 --> 02:10:43.600
那怎么办呢

02:10:43.600 --> 02:10:44.080
对吧

02:10:44.080 --> 02:10:45.560
这画层度非常高

02:10:45.560 --> 02:10:46.040
好了

02:10:46.320 --> 02:10:47.160
比如说首先

02:10:47.160 --> 02:10:47.600
对吧

02:10:47.600 --> 02:10:48.280
你通过这种

02:10:50.120 --> 02:10:50.640
等一下

02:10:58.260 --> 02:10:58.860
那

02:11:00.060 --> 02:11:00.660
首先

02:11:00.660 --> 02:11:01.500
首先

02:11:01.500 --> 02:11:02.140
你通过

02:11:02.140 --> 02:11:04.780
比如说单一指责原则

02:11:04.780 --> 02:11:06.580
和那些比如说开B原则

02:11:06.580 --> 02:11:08.300
什么理事代换原则

02:11:08.300 --> 02:11:08.780
对吧

02:11:08.780 --> 02:11:09.420
把这么一大坨

02:11:09.420 --> 02:11:09.940
对吧

02:11:09.940 --> 02:11:12.570
尽量的

02:11:12.570 --> 02:11:14.090
比如说拆成几块

02:11:14.090 --> 02:11:14.570
对吧

02:11:14.570 --> 02:11:16.050
拆成几块

02:11:16.050 --> 02:11:17.770
比如说现在拆完之后

02:11:17.770 --> 02:11:18.570
有四个四块

02:11:18.570 --> 02:11:19.570
有A

02:11:19.570 --> 02:11:21.930
有什么B

02:11:21.930 --> 02:11:23.050
有C

02:11:23.090 --> 02:11:24.210
有D

02:11:24.210 --> 02:11:25.170
那咱可以写一写

02:11:25.170 --> 02:11:26.370
比如说这

02:11:26.370 --> 02:11:27.130
A

02:11:27.130 --> 02:11:27.690
这

02:11:27.690 --> 02:11:28.850
是一个B

02:11:28.850 --> 02:11:30.490
这是一个C

02:11:30.490 --> 02:11:31.930
这是一个B

02:11:31.930 --> 02:11:32.450
好了

02:11:32.450 --> 02:11:33.010
那

02:11:33.010 --> 02:11:35.050
Hand滿足用功能的实现

02:11:35.050 --> 02:11:36.770
他们之间必然会有怎样

02:11:36.770 --> 02:11:38.090
必然会有这样的一个

02:11:38.090 --> 02:11:38.930
偶和度

02:11:38.930 --> 02:11:40.410
必然会有这样的一个关联

02:11:40.410 --> 02:11:41.370
或者是一种依赖

02:11:41.370 --> 02:11:42.170
行吧

02:11:42.170 --> 02:11:42.410
好

02:11:42.410 --> 02:11:43.290
它俩之间

02:11:43.290 --> 02:11:44.090
比如说有

02:11:44.090 --> 02:11:45.090
它俩之间

02:11:45.090 --> 02:11:45.810
比如说有

02:11:45.810 --> 02:11:46.610
它俩之间

02:11:46.610 --> 02:11:47.090
比如说有

02:11:47.090 --> 02:11:47.490
对不对

02:11:48.690 --> 02:11:49.210
OK

02:11:49.210 --> 02:11:49.930
我们之前讲

02:11:49.930 --> 02:11:50.490
说

02:11:52.490 --> 02:11:54.170
这个偶和度是想

02:11:54.170 --> 02:11:55.010
就是

02:11:55.010 --> 02:11:56.090
如果偶和度越低

02:11:56.090 --> 02:11:57.410
可能这个块就越少

02:11:57.410 --> 02:11:57.810
对吧

02:11:57.810 --> 02:11:58.250
它越少

02:11:58.250 --> 02:11:58.970
比如说这个没有

02:11:58.970 --> 02:11:59.690
没有C

02:11:59.690 --> 02:12:00.690
没有C以后的话

02:12:00.690 --> 02:12:01.890
可能是A和B

02:12:01.890 --> 02:12:03.730
和ABD相连

02:12:03.730 --> 02:12:03.970
对吧

02:12:03.970 --> 02:12:04.690
三个下

02:12:04.690 --> 02:12:05.610
那三个下的话

02:12:05.610 --> 02:12:06.370
自然而然

02:12:06.370 --> 02:12:06.850
偶和度

02:12:06.850 --> 02:12:07.210
它就低

02:12:07.210 --> 02:12:08.010
对不对

02:12:08.010 --> 02:12:08.490
但有的时候

02:12:08.490 --> 02:12:09.730
可能它并不只这样了

02:12:09.730 --> 02:12:11.850
你知道吗

02:12:11.850 --> 02:12:12.250
就比如说

02:12:12.250 --> 02:12:14.850
我们想真正实现这个功能的时候

02:12:14.850 --> 02:12:15.730
它可能这个A

02:12:15.730 --> 02:12:16.650
不仅跟AB相连

02:12:16.650 --> 02:12:18.410
可能还跟这个C相连

02:12:18.410 --> 02:12:19.810
对吧

02:12:19.810 --> 02:12:21.090
那比如说C呢

02:12:21.090 --> 02:12:21.810
可能这个B呢

02:12:21.810 --> 02:12:23.770
还跟D相连

02:12:23.770 --> 02:12:24.690
对吧

02:12:24.690 --> 02:12:26.290
可能这个人们还有一个什么

02:12:26.290 --> 02:12:26.610
还有一个

02:12:26.610 --> 02:12:27.810
这个

02:12:27.810 --> 02:12:29.010
还有个E

02:12:29.010 --> 02:12:29.730
还有个E

02:12:32.170 --> 02:12:33.970
比如说我通过这个开B原则

02:12:33.970 --> 02:12:35.290
什么这个理事单位原则

02:12:35.290 --> 02:12:37.290
理事单位原则的话

02:12:37.290 --> 02:12:39.050
咱里面去增了一个E对不对

02:12:39.050 --> 02:12:40.210
又增了一块对吧

02:12:40.210 --> 02:12:40.450
好了

02:12:40.450 --> 02:12:41.090
那比如说

02:12:41.090 --> 02:12:43.090
这个里面

02:12:43.090 --> 02:12:44.290
A和E也相连

02:12:44.290 --> 02:12:45.770
这个D和E也相连

02:12:45.770 --> 02:12:47.170
B和E也相连

02:12:47.170 --> 02:12:48.410
C和E也相连对吧

02:12:48.410 --> 02:12:48.850
OK

02:12:48.850 --> 02:12:50.290
那现在你会发现

02:12:50.290 --> 02:12:51.850
这个偶合度啊

02:12:51.850 --> 02:12:53.330
是不是变得比之前又复杂了

02:12:53.330 --> 02:12:54.450
现在你可以列成

02:12:54.450 --> 02:12:56.050
这个偶度它就是这么多线

02:12:56.050 --> 02:12:57.410
这个线越多

02:12:57.410 --> 02:12:59.370
就偶合度就越高了

02:12:59.370 --> 02:13:00.850
但之前我们想

02:13:00.850 --> 02:13:02.570
这种降低偶合度的时候

02:13:02.570 --> 02:13:04.610
就是不去增加这个E对吧

02:13:04.610 --> 02:13:06.450
或者说是让这种块

02:13:06.450 --> 02:13:08.050
什么abcd这种块

02:13:08.050 --> 02:13:09.010
越少对吧

02:13:09.010 --> 02:13:10.050
它们可能形成的线

02:13:10.050 --> 02:13:11.370
就一定会越少对吧

02:13:11.370 --> 02:13:12.850
那这是通过什么

02:13:12.850 --> 02:13:14.850
这是通过

02:13:14.850 --> 02:13:15.650
我们说

02:13:15.650 --> 02:13:18.130
这个就是

02:13:18.130 --> 02:13:19.010
这是通过

02:13:19.010 --> 02:13:21.290
我们不让这种功能这个块

02:13:21.290 --> 02:13:25.170
不让这种功能对象的各数增多对吧

02:13:25.170 --> 02:13:27.210
从而达到偶合度不要那么高

02:13:27.210 --> 02:13:28.450
但有的时候

02:13:28.450 --> 02:13:29.530
有的时候这个块

02:13:29.530 --> 02:13:31.610
它必须的增多

02:13:31.610 --> 02:13:34.170
你没有办法让它变得那么少

02:13:34.170 --> 02:13:35.010
那怎么办

02:13:35.010 --> 02:13:36.810
那怎么去降低偶合度

02:13:36.810 --> 02:13:37.370
那这个时候

02:13:37.370 --> 02:13:38.810
迪米特法则对吧

02:13:38.810 --> 02:13:41.250
他说提到的事情就有用了对吧

02:13:41.250 --> 02:13:43.330
叫做最小之道原则

02:13:43.330 --> 02:13:44.330
也叫迪米特法则

02:13:44.330 --> 02:13:45.290
它要求是什么

02:13:45.290 --> 02:13:46.850
是参数越少越小

02:13:46.850 --> 02:13:48.010
越少越好

02:13:48.010 --> 02:13:49.850
依赖越少越好

02:13:49.850 --> 02:13:52.210
也有时候我可以尽量的

02:13:52.210 --> 02:13:53.370
比如说让这个A

02:13:53.370 --> 02:13:55.410
它在完成它拥有的功能的时候

02:13:55.410 --> 02:13:56.410
你别去

02:13:56.410 --> 02:13:57.650
又跟B是吧

02:13:57.650 --> 02:13:59.090
相连性跟C相连

02:13:59.090 --> 02:13:59.730
又跟D相连

02:13:59.730 --> 02:14:00.730
又跟E相连

02:14:00.730 --> 02:14:01.890
比如说你这个A

02:14:01.890 --> 02:14:04.250
可以只跟这个A

02:14:04.250 --> 02:14:05.730
只跟这个B和D相连

02:14:05.730 --> 02:14:07.450
就能完成它的功能的话

02:14:07.450 --> 02:14:08.850
那完全可以怎么样

02:14:08.850 --> 02:14:12.210
完全可以把这种E和这样的一种D

02:14:12.210 --> 02:14:12.890
对吧

02:14:12.890 --> 02:14:14.250
全部去掉

02:14:14.250 --> 02:14:14.650
D

02:14:14.650 --> 02:14:16.250
E和D全部去掉

02:14:16.250 --> 02:14:17.690
E和D全部去掉

02:14:17.690 --> 02:14:19.290
所以我尽量的

02:14:19.290 --> 02:14:21.210
把一些没有必要的这种参数

02:14:21.210 --> 02:14:22.330
就不帮你来传了

02:14:22.330 --> 02:14:23.170
行吧

02:14:23.170 --> 02:14:23.890
那我可以

02:14:23.890 --> 02:14:24.370
充耳的话

02:14:24.370 --> 02:14:25.010
你不帮你来传的话

02:14:25.010 --> 02:14:26.370
当然A的这个辅负达度的话

02:14:26.370 --> 02:14:27.690
它也相当低

02:14:27.690 --> 02:14:28.610
实际模式这个东西

02:14:28.610 --> 02:14:29.890
它都是环环相扣的

02:14:29.890 --> 02:14:31.930
彼此之间互相去影响的

02:14:31.930 --> 02:14:34.450
没有完全的区境让你割裂

02:14:34.450 --> 02:14:36.770
那有时候可能说了

02:14:36.770 --> 02:14:39.130
比如说现在和B和D对吧

02:14:39.130 --> 02:14:42.850
比如说现在是这个B和D

02:14:42.850 --> 02:14:44.250
比如说现在这个B和D

02:14:44.250 --> 02:14:48.250
有它就是它俩是看起来没有办法

02:14:48.250 --> 02:14:52.050
再去把这种关联性给它去掉的情况下的话

02:14:52.050 --> 02:14:54.290
那自然而然的话

02:14:54.290 --> 02:14:57.290
它这个A指定是跟它俩是有这样的一种

02:14:57.290 --> 02:14:59.490
偶和的一个关系对吧

02:14:59.490 --> 02:15:01.010
但是有的时候

02:15:01.010 --> 02:15:02.610
有的时候可能

02:15:02.610 --> 02:15:03.970
比如说像这个C

02:15:03.970 --> 02:15:05.250
像这个C

02:15:05.250 --> 02:15:08.290
现在虽然说它跟很多线在相连对吧

02:15:08.290 --> 02:15:09.930
可能说它通过Dmm的法则

02:15:09.930 --> 02:15:12.730
可以把这个A和E相去掉对吧

02:15:12.730 --> 02:15:15.810
E有这个B和D这样的一个偶和性

02:15:15.810 --> 02:15:20.130
那它可能说是连B和D这种偶和性

02:15:20.130 --> 02:15:23.770
也可以通过另外一种方式给它消除

02:15:23.770 --> 02:15:25.570
那这种另外一种方式

02:15:25.570 --> 02:15:26.570
消除的话

02:15:26.570 --> 02:15:28.490
它就符合另外一种原则

02:15:28.490 --> 02:15:30.730
叫做依赖道治原则

02:15:30.730 --> 02:15:31.930
依赖道治原则

02:15:31.930 --> 02:15:34.650
依赖道治原则在里面思想我来说一下

02:15:34.650 --> 02:15:36.930
最后我画一个总图

02:15:36.930 --> 02:15:39.330
我在这里面把这个东西在天下道里面去

02:15:39.330 --> 02:15:40.250
天下道里面去以后的话

02:15:40.250 --> 02:15:42.570
我们再进行重新的一次理解

02:15:42.570 --> 02:15:44.050
依赖道治原则什么意思呢

02:15:44.050 --> 02:15:44.690
再说一下

02:15:44.690 --> 02:15:46.730
叫做最常用的原则

02:15:46.730 --> 02:15:48.970
它是最常用的原则依赖接口

02:15:48.970 --> 02:15:49.530
不依赖方法

02:15:49.530 --> 02:15:52.090
要说我们在进行这样的一个变成中

02:15:52.090 --> 02:15:54.650
那算是我们GS没有这种接口的概念

02:15:54.650 --> 02:15:55.970
那你可以理解一下

02:15:55.970 --> 02:15:59.530
比如说在照这个语言中

02:15:59.530 --> 02:16:00.530
这个接口什么意思

02:16:00.530 --> 02:16:01.370
是定一个方法

02:16:01.370 --> 02:16:02.050
这个名字

02:16:02.050 --> 02:16:03.530
但它不学实现距离功能

02:16:03.530 --> 02:16:08.570
此类再去继承这样的一个方法的时候的话

02:16:08.570 --> 02:16:11.730
比如说它可以去实现一个接口对吧

02:16:11.730 --> 02:16:13.730
它很多个字类的

02:16:13.730 --> 02:16:16.650
它很多这样的一个它子类的话

02:16:16.650 --> 02:16:18.130
我都去实现这样的接口

02:16:18.130 --> 02:16:20.130
这个接口只是有个名字而已

02:16:20.130 --> 02:16:21.770
具体先的功能

02:16:21.770 --> 02:16:22.570
怎么办

02:16:22.570 --> 02:16:24.770
由我每个字类来具体来完成

02:16:24.770 --> 02:16:26.410
也就是说我们每个字类再去完成

02:16:26.410 --> 02:16:27.690
它自己功能的时候

02:16:27.690 --> 02:16:30.970
它不去依赖与这个附类

02:16:30.970 --> 02:16:32.890
它具体这样的一个方法的实现

02:16:32.890 --> 02:16:33.490
而方法

02:16:33.490 --> 02:16:35.850
而附近只去提供一个接口的名字

02:16:35.850 --> 02:16:37.530
词类来去实现

02:16:37.530 --> 02:16:38.730
就比如说我要吃饭对吧

02:16:38.730 --> 02:16:39.290
OK

02:16:39.290 --> 02:16:40.570
我要吃饭

02:16:40.570 --> 02:16:42.570
如果说

02:16:42.570 --> 02:16:43.690
我把这个附附迪

02:16:43.690 --> 02:16:45.690
把这个吃饭那个动作写得太死了

02:16:45.690 --> 02:16:47.530
就说吃鲍鱼对吧

02:16:47.530 --> 02:16:49.250
或者说吃方面面

02:16:49.250 --> 02:16:50.490
那子类在继承的时候

02:16:50.490 --> 02:16:52.610
它只能吃鲍鱼吃方面

02:16:52.610 --> 02:16:53.450
你要修改的话

02:16:53.450 --> 02:16:56.530
你看你不可能会不符合其他的一个原则对吧

02:16:56.530 --> 02:16:57.410
那怎么办

02:16:57.410 --> 02:16:59.330
那我再去继承它功能中的话

02:16:59.330 --> 02:17:00.610
尽量去依赖接口

02:17:00.610 --> 02:17:03.050
或者说面向这个接口它来去做

02:17:03.050 --> 02:17:04.210
那怎么向接口呢

02:17:04.210 --> 02:17:07.210
比如说附迪他指定你吃这个动作对吧

02:17:07.210 --> 02:17:08.650
接口就相当于一个动作

02:17:08.650 --> 02:17:10.170
那子类来实现的时候

02:17:10.170 --> 02:17:10.890
OK

02:17:10.890 --> 02:17:12.410
比如说有不同的子类的吧

02:17:12.410 --> 02:17:13.370
有有钱的子类

02:17:13.370 --> 02:17:14.730
有没有钱的子类对吧

02:17:14.730 --> 02:17:15.170
那好了

02:17:15.170 --> 02:17:16.330
有钱子类可以说

02:17:16.330 --> 02:17:17.250
我吃鲍鱼对吧

02:17:17.250 --> 02:17:19.450
没钱子类可以说吃方面面对不对

02:17:19.450 --> 02:17:20.050
那这样的话

02:17:20.050 --> 02:17:22.730
可是我们之前从一个依赖于这个聚集的方法

02:17:22.730 --> 02:17:24.490
到依赖于这种接口

02:17:24.490 --> 02:17:25.930
它其实就是一种依赖

02:17:25.930 --> 02:17:28.450
它其实就是一种依赖道志

02:17:28.450 --> 02:17:30.010
在钱的应用中

02:17:30.010 --> 02:17:31.330
其实你可以列成什么呢

02:17:31.330 --> 02:17:35.010
就是比如说A和B之间有关系对吧

02:17:35.010 --> 02:17:37.170
它有这个依赖的关系

02:17:37.170 --> 02:17:38.010
那好了

02:17:38.010 --> 02:17:41.210
我们想依赖道志怎么办呢

02:17:41.210 --> 02:17:44.410
我们可以让它们依赖状态

02:17:44.410 --> 02:17:46.850
可以说这个状态是个全局变量对吧

02:17:46.850 --> 02:17:47.450
OK

02:17:47.450 --> 02:17:48.250
依赖状态

02:17:48.250 --> 02:17:49.530
依赖这个全局变量以后的话

02:17:49.530 --> 02:17:50.570
让这个A和B之间

02:17:50.570 --> 02:17:52.090
它俩没有直接的一个作用

02:17:52.090 --> 02:17:54.770
没有直接的一个关系

02:17:54.770 --> 02:17:57.570
那当比如说对象和对象之间

02:17:57.570 --> 02:17:59.970
比如说有相互影响之间的相互影响

02:17:59.970 --> 02:18:01.250
或者说这个方法和方法之间

02:18:01.250 --> 02:18:02.650
有相互影响的话

02:18:02.650 --> 02:18:03.890
这叫偶和

02:18:03.890 --> 02:18:05.810
但是如果说是一个对象和对象

02:18:05.810 --> 02:18:07.250
或者方法和方法

02:18:07.290 --> 02:18:11.050
他们都是跟某个具体的变量

02:18:11.050 --> 02:18:13.970
或者说跟某个具体的一个值

02:18:13.970 --> 02:18:15.770
来形成这样一个作用的话

02:18:15.770 --> 02:18:17.770
那这种程度就不叫偶和

02:18:17.770 --> 02:18:18.610
你可以列成

02:18:18.610 --> 02:18:21.170
比如说我们两个人之间互相交流对不对

02:18:21.170 --> 02:18:22.090
他都是人对吧

02:18:22.090 --> 02:18:23.250
都会列成是一个对象

02:18:23.250 --> 02:18:24.770
我们直接说话

02:18:24.770 --> 02:18:26.850
这叫做咱们有偶和的一个关系

02:18:26.850 --> 02:18:27.890
但是如果说

02:18:27.890 --> 02:18:31.090
如果说我们不去直接说话了

02:18:31.090 --> 02:18:32.290
我们写在纸上对吧

02:18:32.290 --> 02:18:34.770
我们都对纸进行一个改变

02:18:34.770 --> 02:18:35.850
那这个时候我们都怎么样

02:18:35.850 --> 02:18:37.570
我们都去依赖用这个纸了

02:18:37.570 --> 02:18:39.490
那这种东西叫做依赖道质

02:18:39.490 --> 02:18:40.930
那我们都依赖纸的情况下的话

02:18:40.930 --> 02:18:43.250
我们就不叫偶和了

02:18:43.250 --> 02:18:45.490
那这个概念在哪应用呢

02:18:45.490 --> 02:18:48.010
在VUE中的VUEX

02:18:48.010 --> 02:18:50.490
但什么样的这样的一个模式

02:18:50.490 --> 02:18:54.210
能去实现这个依赖道质呢

02:18:54.210 --> 02:18:57.290
最常见的它就是这种发布订阅模式

02:18:57.290 --> 02:18:58.330
我来跟你说一下

02:18:58.330 --> 02:18:59.730
再来看一看

02:18:59.730 --> 02:19:00.890
比如说这个A和B

02:19:00.890 --> 02:19:01.570
比如说A和B

02:19:01.570 --> 02:19:03.690
现在给你来个A

02:19:03.690 --> 02:19:04.730
来个A

02:19:04.730 --> 02:19:05.690
比如说这个A

02:19:05.690 --> 02:19:07.330
这个A的隔门是个对象

02:19:07.330 --> 02:19:12.510
是个对象

02:19:12.510 --> 02:19:13.830
比如说它上有些事件

02:19:13.830 --> 02:19:14.750
比如说事件

02:19:14.750 --> 02:19:16.190
咱说一发生

02:19:16.190 --> 02:19:17.950
一发生以后的话好了

02:19:17.950 --> 02:19:18.870
他干一件事情

02:19:18.870 --> 02:19:19.670
什么事呢

02:19:19.670 --> 02:19:20.910
这还有个B

02:19:20.910 --> 02:19:22.230
这还有个B

02:19:22.230 --> 02:19:23.470
这个B

02:19:23.470 --> 02:19:27.270
这个B对对象可能最后

02:19:27.270 --> 02:19:28.750
它有一些功能

02:19:28.750 --> 02:19:33.870
或者说它会最后决定页面里面

02:19:33.870 --> 02:19:35.190
显示什么

02:19:35.190 --> 02:19:37.950
页面里面显示什么

02:19:37.990 --> 02:19:40.030
我这个B不这么写

02:19:40.030 --> 02:19:42.110
这学教一下

02:19:42.110 --> 02:19:45.450
比如说这样

02:19:45.450 --> 02:19:47.010
这

02:19:47.010 --> 02:19:49.570
这是个B

02:19:49.570 --> 02:19:52.050
是个B

02:19:52.050 --> 02:19:54.090
我这来着它

02:19:54.090 --> 02:19:55.690
来着它

02:19:55.690 --> 02:19:57.810
B最后决定于这个页面

02:19:57.810 --> 02:19:59.090
怎么来去显示呢

02:19:59.090 --> 02:20:00.410
那它写上是个页面

02:20:00.410 --> 02:20:02.450
对吧

02:20:02.450 --> 02:20:04.010
页面

02:20:04.010 --> 02:20:06.930
那这个A是个对象

02:20:06.930 --> 02:20:07.890
当一个行为

02:20:07.930 --> 02:20:08.890
比如说B

02:20:08.890 --> 02:20:10.290
放在它身上以后

02:20:10.290 --> 02:20:10.650
对吧

02:20:10.650 --> 02:20:12.170
OK

02:20:12.170 --> 02:20:14.530
比如说我们不知道原则去做事的话

02:20:14.530 --> 02:20:15.850
我可能怎么办呢

02:20:15.850 --> 02:20:19.090
它可能说是行为放在它身上以后的话

02:20:19.090 --> 02:20:20.130
它上那些

02:20:20.130 --> 02:20:21.850
比如说这个状态

02:20:21.850 --> 02:20:23.890
或者是一些数据发生改变以后

02:20:23.890 --> 02:20:26.770
它直接就拿到这个B

02:20:26.770 --> 02:20:27.730
或者直接拿到这个B

02:20:27.730 --> 02:20:28.170
这个B

02:20:28.170 --> 02:20:30.250
这个根本可能说也是个对象

02:20:30.250 --> 02:20:30.810
对吧

02:20:30.810 --> 02:20:31.490
也是个对象

02:20:31.490 --> 02:20:34.090
我这来写一下

02:20:34.090 --> 02:20:35.530
它之前

02:20:35.530 --> 02:20:37.850
比如说是直接就拿到这个B

02:20:37.850 --> 02:20:40.610
去修改B门的功能

02:20:40.610 --> 02:20:45.250
比如说把B门这些数据状态发生一些变化

02:20:45.250 --> 02:20:45.690
对吧

02:20:45.690 --> 02:20:49.930
它在A里面就直接操作这个B了

02:20:49.930 --> 02:20:50.770
操作这个B以后

02:20:50.770 --> 02:20:51.290
B是变了

02:20:51.290 --> 02:20:54.610
最后导致页面发生一些变化

02:20:54.610 --> 02:20:55.450
这样好不好呢

02:20:55.450 --> 02:20:56.570
首先一定是不好的

02:20:56.570 --> 02:20:58.490
因为它不符合开闭原则

02:20:58.490 --> 02:21:00.690
也不太符合单一职责原则

02:21:00.690 --> 02:21:04.690
它去增加了代码的一个复杂程度

02:21:04.690 --> 02:21:06.010
A就跟A的事对吧

02:21:06.010 --> 02:21:07.850
我就操作你B一些东西

02:21:07.850 --> 02:21:09.770
要与我合干对吧

02:21:09.770 --> 02:21:11.130
凭什么我要就这么做

02:21:11.130 --> 02:21:11.810
凭什么我要

02:21:11.810 --> 02:21:13.970
凭什么投稿去这么做

02:21:13.970 --> 02:21:17.610
那当然如果说现在

02:21:17.610 --> 02:21:21.530
比如说A只跟这个B来进行这样的一个直接操作

02:21:21.530 --> 02:21:24.210
而且A也只是

02:21:24.210 --> 02:21:25.090
就是怎么说呢

02:21:25.090 --> 02:21:29.730
是A它不去去操作其他的

02:21:29.730 --> 02:21:32.690
或者说它以后优势就中了

02:21:32.730 --> 02:21:35.370
我们不去要求A去操作什么C和D的话

02:21:35.370 --> 02:21:38.250
你这么写也其实是无所谓的

02:21:38.250 --> 02:21:40.410
因为毕竟代码它就这么多

02:21:40.410 --> 02:21:41.330
也没关系

02:21:41.330 --> 02:21:43.130
风险吸收它也没有那么大

02:21:43.130 --> 02:21:44.210
但是如果说

02:21:44.210 --> 02:21:45.090
如果说你这样

02:21:45.090 --> 02:21:46.850
如果说当你这里面又来一个

02:21:46.850 --> 02:21:48.250
比如说就来个C的吧

02:21:48.250 --> 02:21:50.690
可能说这个行为发生在这个A身上的话

02:21:50.690 --> 02:21:51.970
现在不仅又改什么

02:21:51.970 --> 02:21:54.170
不仅又改这个B了

02:21:54.170 --> 02:21:55.370
B应该B了

02:21:55.370 --> 02:22:02.120
它这个C这个门它也跟着变

02:22:02.120 --> 02:22:03.920
它也跟着变

02:22:03.920 --> 02:22:05.720
比如说这里面它再去

02:22:05.720 --> 02:22:07.520
它又去拿到这个C对吧

02:22:07.520 --> 02:22:10.280
想到它又去操作这个C

02:22:10.280 --> 02:22:13.960
C可能说也把这个数据通过它的改变

02:22:13.960 --> 02:22:16.560
A去在A在自己里面去操作C

02:22:16.560 --> 02:22:18.240
把C的数据发生这样的一个变化

02:22:18.240 --> 02:22:21.440
它导致这个页面也发生一些的一个变化

02:22:21.440 --> 02:22:22.600
那这样的话好了

02:22:22.600 --> 02:22:24.520
是不是又增加这样的一个复杂度

02:22:24.520 --> 02:22:25.760
还是那句话对吧

02:22:25.760 --> 02:22:27.320
于我和安对不对

02:22:27.320 --> 02:22:28.200
那怎么办呢

02:22:28.200 --> 02:22:29.240
怎么办

02:22:29.240 --> 02:22:32.840
首先这个不仅复杂度增加了

02:22:32.880 --> 02:22:36.320
如果吸引的同学对我之前讲的这个东西

02:22:36.320 --> 02:22:37.680
如果你注意听的情况下的话

02:22:37.680 --> 02:22:39.440
你还会发现一件事情

02:22:39.440 --> 02:22:43.720
我在拿在A对象里面去操作或修改这个B和C

02:22:43.720 --> 02:22:44.800
它也不符合什么

02:22:44.800 --> 02:22:52.270
也不符合这个开B原则

02:22:52.270 --> 02:22:54.110
不符合开B原则

02:22:54.110 --> 02:22:55.670
那当然的话对吧

02:22:55.670 --> 02:23:01.550
那这个复杂程度相应的也会去增加对不对

02:23:01.550 --> 02:23:02.870
那怎么办啊

02:23:02.870 --> 02:23:03.550
怎么办

02:23:03.550 --> 02:23:04.630
它不符合开B原则

02:23:04.630 --> 02:23:07.070
那我先让它符合开B原则

02:23:07.110 --> 02:23:08.030
怎么符合开B原则

02:23:08.030 --> 02:23:09.390
比如说它有个接口对吧

02:23:09.390 --> 02:23:12.790
这个接口提供这一种调用

02:23:12.790 --> 02:23:15.430
就是这个接口就是它给外界

02:23:15.430 --> 02:23:17.350
外界可以拿这个接口直接去用

02:23:17.350 --> 02:23:18.310
用完以后的话

02:23:18.310 --> 02:23:21.230
可以去让它内部发生这样的

02:23:21.230 --> 02:23:22.430
一系列的一个变化

02:23:22.430 --> 02:23:23.590
发生一系列的一个变化

02:23:25.270 --> 02:23:26.950
比如说这个发生一些的变化

02:23:32.740 --> 02:23:33.940
比如这发生一些变化

02:23:37.910 --> 02:23:38.750
OK

02:23:38.750 --> 02:23:41.150
那我在这里面

02:23:41.150 --> 02:23:44.110
我就不去直接拿到这个B去修改它了

02:23:44.110 --> 02:23:45.070
而是怎么样

02:23:45.070 --> 02:23:47.550
而是拿到这个B对象去调用它

02:23:47.550 --> 02:23:47.830
对吧

02:23:47.830 --> 02:23:50.230
去调用去调用

02:23:50.230 --> 02:23:52.790
但是其实即使你这么去调用的话

02:23:52.790 --> 02:23:54.670
即使你这么去调用的话

02:23:54.670 --> 02:23:56.430
它也一样怎么样

02:23:56.430 --> 02:23:58.190
是在A里面去做的

02:23:58.190 --> 02:23:59.950
那在A里面去做小项的话

02:23:59.950 --> 02:24:03.590
你会发现的他们之间还是有偶和的

02:24:03.590 --> 02:24:04.270
对吧

02:24:04.270 --> 02:24:05.510
还是有偶和的

02:24:05.510 --> 02:24:07.950
而且换句话来讲的话

02:24:07.950 --> 02:24:08.590
对吧

02:24:08.590 --> 02:24:11.350
其实这个我为什么要去这里面去调用

02:24:11.350 --> 02:24:12.630
你B和C对吧

02:24:12.630 --> 02:24:14.830
跟A对于A来讲的话

02:24:14.830 --> 02:24:17.790
我凭什么要在里面去调用你们

02:24:17.790 --> 02:24:19.310
换句话说与我合干

02:24:19.310 --> 02:24:19.790
对吧

02:24:19.790 --> 02:24:22.350
但其实这种与我合干的概念

02:24:22.350 --> 02:24:25.390
我们平常在开发中是不注意的

02:24:25.390 --> 02:24:27.150
就比如说在这

02:24:27.150 --> 02:24:28.430
在这该的D的时候

02:24:28.430 --> 02:24:30.070
你会传这个callback array

02:24:30.070 --> 02:24:30.630
对不对

02:24:30.630 --> 02:24:32.110
你会往里面传它俩了

02:24:32.110 --> 02:24:32.590
对吧

02:24:32.590 --> 02:24:34.870
那当然它俩是有这样的一个偶和度的

02:24:34.870 --> 02:24:35.830
那一般情况下

02:24:35.830 --> 02:24:37.070
我们是不去管的

02:24:37.070 --> 02:24:38.110
我们是不去管的

02:24:38.110 --> 02:24:40.030
如果说我们懂了依赖

02:24:40.030 --> 02:24:41.350
导致原则以后的话

02:24:41.390 --> 02:24:42.910
我们可不可以去改变它呢

02:24:42.910 --> 02:24:44.630
可以怎么来改变

02:24:44.630 --> 02:24:45.630
咱来看一下

02:24:45.630 --> 02:24:47.510
比如说当行为出发到A

02:24:47.510 --> 02:24:49.430
当发生在A身上以后的话

02:24:49.430 --> 02:24:50.670
A我就不去怎么样

02:24:50.670 --> 02:24:53.670
我去不去管你这些东西了

02:24:53.670 --> 02:24:55.030
而怎么办呢

02:24:55.030 --> 02:24:59.230
比如说我这个全局有一个状态的一个

02:24:59.230 --> 02:25:01.710
管理对象或者我全局的变量

02:25:01.710 --> 02:25:02.710
对吧

02:25:02.710 --> 02:25:03.590
状态

02:25:03.590 --> 02:25:05.270
那当我这个东西

02:25:05.270 --> 02:25:07.190
当我这个行为发生在A身上以后的话

02:25:07.190 --> 02:25:08.590
我只去怎么样

02:25:08.590 --> 02:25:10.950
我只去修改一下这个全局变量

02:25:10.950 --> 02:25:12.350
这个状态

02:25:12.350 --> 02:25:14.550
那我这个B和C怎么办呢

02:25:14.550 --> 02:25:16.790
我B和C也不去

02:25:18.510 --> 02:25:20.910
我B和C也不让这个A去调用我了

02:25:20.910 --> 02:25:21.470
而怎么办

02:25:21.470 --> 02:25:25.310
我B和C直接去监听你状态的一个变化

02:25:25.310 --> 02:25:27.590
如果状态一旦发生变化以后的话

02:25:27.590 --> 02:25:29.710
我B和C让它自己调用自己

02:25:29.710 --> 02:25:31.230
让它自己发生改变

02:25:31.230 --> 02:25:32.190
改变完以后的话

02:25:32.190 --> 02:25:34.310
去影响这个页面

02:25:34.310 --> 02:25:35.910
那这样的话你会发现

02:25:35.910 --> 02:25:39.550
咱把这个A C和AB这个线给它去掉了

02:25:39.550 --> 02:25:40.670
去掉以后的话

02:25:40.710 --> 02:25:42.990
是把这个偶盒给消除了

02:25:42.990 --> 02:25:43.870
那有存在说

02:25:43.870 --> 02:25:45.510
这不就多了两条线吗

02:25:45.510 --> 02:25:46.590
这不叫偶盒吗

02:25:46.590 --> 02:25:47.510
这不叫偶盒

02:25:47.510 --> 02:25:48.550
我跟你说

02:25:48.550 --> 02:25:49.070
功能

02:25:49.070 --> 02:25:49.670
功能之间

02:25:49.670 --> 02:25:50.550
对象对象之间

02:25:50.550 --> 02:25:51.310
对吧

02:25:51.310 --> 02:25:54.150
但对象也是需要有一些功能的

02:25:54.150 --> 02:25:55.790
他们之间互相去操作

02:25:55.790 --> 02:25:57.070
互相去调用

02:25:57.070 --> 02:25:59.230
这个才叫做偶盒

02:25:59.230 --> 02:26:00.190
才有这样的一个

02:26:01.190 --> 02:26:02.310
就是

02:26:02.310 --> 02:26:03.950
如果说他们之间这种

02:26:03.950 --> 02:26:04.790
比如说B C

02:26:04.790 --> 02:26:05.390
我再来个D

02:26:05.390 --> 02:26:06.070
我再来个E对吧

02:26:06.070 --> 02:26:08.910
他们之间这种跟A的关系

02:26:08.910 --> 02:26:11.070
在这种增加的话

02:26:11.070 --> 02:26:12.910
才要去提高这样的一个偶盒度

02:26:12.910 --> 02:26:14.550
但我们A B C

02:26:14.550 --> 02:26:17.710
他们分别都依赖于某一个这种状态

02:26:17.710 --> 02:26:19.430
或是某一个这样的一个变量的话

02:26:19.430 --> 02:26:21.510
某一个权娱这样的一个足的话

02:26:21.510 --> 02:26:23.830
这不叫做偶盒

02:26:23.830 --> 02:26:27.710
他们只是有一个相应的一个关系

02:26:27.710 --> 02:26:29.710
有这样的一个相应的一个关系

02:26:29.710 --> 02:26:32.110
其实这个东西

02:26:32.110 --> 02:26:34.150
它在我们VVX中

02:26:34.150 --> 02:26:35.030
如果说我们后面

02:26:35.030 --> 02:26:35.910
在反过程中的话

02:26:35.910 --> 02:26:37.470
讲到VVX中的圆满的话

02:26:37.470 --> 02:26:39.110
你可以去看看

02:26:39.110 --> 02:26:40.110
这个东西

02:26:40.110 --> 02:26:43.670
就是在我们这种数据管理

02:26:43.670 --> 02:26:45.990
这样的一种框架中会经常的使用

02:26:45.990 --> 02:26:47.070
不仅是VVX

02:26:47.070 --> 02:26:48.270
包括Redust

02:26:48.270 --> 02:26:49.470
才是这么干的

02:26:49.470 --> 02:26:50.350
因为发现上

02:26:50.350 --> 02:26:52.510
这些对象都不依赖于彼此

02:26:52.510 --> 02:26:53.230
而是依赖什么

02:26:53.230 --> 02:26:54.750
是依赖于这样的一个状态

02:26:54.750 --> 02:26:56.950
它叫做依赖道志

02:26:56.950 --> 02:26:58.350
依赖道志

02:26:58.350 --> 02:27:01.110
那我们为什么要这么去销销出偶盒

02:27:01.110 --> 02:27:02.110
我们为什么

02:27:02.110 --> 02:27:04.550
去把他们之间的这种

02:27:04.550 --> 02:27:06.470
就是调用或说这样的一种关系

02:27:06.470 --> 02:27:07.910
一改再改

02:27:07.910 --> 02:27:09.030
这边我再来提一提

02:27:09.030 --> 02:27:10.790
我再来提一提

02:27:10.790 --> 02:27:13.590
就是我这边给你画个图

02:27:13.590 --> 02:27:17.910
这个图可以跟你很好地去生动

02:27:17.910 --> 02:27:19.670
去描述一下

02:27:19.670 --> 02:27:24.820
这个一个风险系数

02:27:24.820 --> 02:27:26.100
风险

02:27:26.100 --> 02:27:28.460
风险

02:27:28.460 --> 02:27:31.220
这叫做偶盒度

02:27:31.220 --> 02:27:33.700
偶盒度

02:27:33.700 --> 02:27:35.540
也有说

02:27:35.540 --> 02:27:37.620
我们之前可能说是想

02:27:37.620 --> 02:27:39.620
这个偶盒度越高

02:27:39.620 --> 02:27:40.620
风险越高

02:27:40.620 --> 02:27:42.620
它应该是这种

02:27:42.620 --> 02:27:45.860
它应该是这种正相关的

02:27:45.860 --> 02:27:47.140
一个直线的形式

02:27:47.140 --> 02:27:49.180
去一点一点去往上走

02:27:49.180 --> 02:27:49.660
但我告诉你

02:27:49.660 --> 02:27:50.740
其实它不是这样的

02:27:50.740 --> 02:27:51.700
它是什么样的

02:27:51.700 --> 02:27:57.200
它其实是这样的

02:27:57.200 --> 02:27:58.960
它其实是这样的

02:28:08.980 --> 02:28:10.100
等会

02:28:11.460 --> 02:28:12.500
我们可能以为是这样的

02:28:12.500 --> 02:28:13.380
对不对

02:28:13.380 --> 02:28:14.380
以为是这样的

02:28:14.380 --> 02:28:15.660
但其实它不是这样的

02:28:15.660 --> 02:28:16.740
它什么样的

02:28:17.780 --> 02:28:21.640
它是这样的

02:28:21.640 --> 02:28:22.280
它是

02:28:22.280 --> 02:28:23.040
当你比如说

02:28:23.040 --> 02:28:24.560
偶盒度

02:28:24.560 --> 02:28:25.840
一个的时候

02:28:25.840 --> 02:28:26.960
风险系数

02:28:26.960 --> 02:28:27.440
这样

02:28:27.440 --> 02:28:28.000
偶盒度

02:28:28.000 --> 02:28:28.840
一个的时候

02:28:28.840 --> 02:28:30.120
风险系数好了

02:28:30.120 --> 02:28:30.760
还没这么高

02:28:30.760 --> 02:28:31.080
对吧

02:28:31.080 --> 02:28:32.480
上上到还很平

02:28:32.480 --> 02:28:33.240
平缓

02:28:33.240 --> 02:28:35.080
当两个的时候

02:28:35.080 --> 02:28:38.320
可能说已经接近于拐点了

02:28:38.320 --> 02:28:40.360
当偶盒度再增加三个的时候

02:28:40.360 --> 02:28:40.960
你会发现

02:28:40.960 --> 02:28:43.440
它突然就皱扔了

02:28:43.440 --> 02:28:44.720
这个东西

02:28:44.720 --> 02:28:45.760
在开发工中

02:28:45.760 --> 02:28:47.840
它也确实是这样的

02:28:47.880 --> 02:28:50.120
比如说当你偶盒这样的东西

02:28:50.120 --> 02:28:52.160
比如说一个对象跟三个

02:28:52.160 --> 02:28:53.640
包括三个以上

02:28:53.640 --> 02:28:56.200
这样那种对对象方法去偶盒的时候

02:28:56.200 --> 02:28:58.640
它的风险其实会特别的大

02:28:58.640 --> 02:28:59.360
这个东西

02:28:59.360 --> 02:28:59.960
我跟你说

02:28:59.960 --> 02:29:03.080
叫做开发经验

02:29:03.080 --> 02:29:04.640
我们有的时候

02:29:04.640 --> 02:29:07.440
在进行真正的一个项目的开发工作的时候

02:29:07.440 --> 02:29:09.320
我们往往怎么样

02:29:09.320 --> 02:29:11.440
要去全衡一件事情

02:29:11.440 --> 02:29:12.240
全衡

02:29:12.240 --> 02:29:14.680
就是要去提高一些偶盒度

02:29:14.680 --> 02:29:16.320
来降的一些复杂度

02:29:16.320 --> 02:29:16.840
对吧

02:29:16.840 --> 02:29:19.080
但是这个偶盒度提高到多少

02:29:19.080 --> 02:29:20.800
来降的这个复杂度呢

02:29:20.800 --> 02:29:23.360
我们要有这样一种风险的把控

02:29:23.360 --> 02:29:25.160
风险的把控一方面

02:29:25.160 --> 02:29:27.320
是这种比如说整个的系统

02:29:27.320 --> 02:29:29.520
一个未来的一个可扩展性

02:29:29.520 --> 02:29:30.440
可维护性

02:29:30.440 --> 02:29:30.640
对吧

02:29:30.640 --> 02:29:32.720
包括一些这样的一个

02:29:32.720 --> 02:29:36.160
比如说就是这样一个

02:29:36.160 --> 02:29:38.520
就是一个风险的这样的一个系数

02:29:38.520 --> 02:29:40.760
还有一方面更重要的一点

02:29:40.760 --> 02:29:43.520
就是一个时间成本

02:29:43.520 --> 02:29:44.840
你想象一下

02:29:44.840 --> 02:29:48.040
比如说我们不用这种依赖道之原则

02:29:48.040 --> 02:29:50.840
或说我不去写一个vuex

02:29:50.840 --> 02:29:53.680
来去管理我这样的一个关系

02:29:53.680 --> 02:29:55.280
来管理这样的一个状态

02:29:55.280 --> 02:29:56.520
我直接去

02:29:56.520 --> 02:29:56.680
对吧

02:29:56.680 --> 02:29:57.880
让A跟这个

02:29:57.880 --> 02:29:59.000
让A里面去调用C

02:29:59.000 --> 02:29:59.560
去调用B

02:29:59.560 --> 02:29:59.840
对吧

02:29:59.840 --> 02:30:01.680
E就可以实验这个功能

02:30:01.680 --> 02:30:02.440
这是没问题的

02:30:02.440 --> 02:30:02.960
对吧

02:30:02.960 --> 02:30:05.320
但是

02:30:05.320 --> 02:30:08.680
如果说你这个对象再去增添一个

02:30:08.680 --> 02:30:10.440
再去增添一个敷衍迅速高了

02:30:10.440 --> 02:30:10.920
对吧

02:30:10.920 --> 02:30:13.240
当你敷衍迅速高了以后

02:30:13.280 --> 02:30:15.360
你是不是需要考虑一下

02:30:15.360 --> 02:30:16.160
考虑什么

02:30:16.160 --> 02:30:17.280
考虑一下

02:30:17.280 --> 02:30:19.520
未来这个需求会不会再增加

02:30:19.520 --> 02:30:20.000
对吧

02:30:20.000 --> 02:30:21.040
如果再增加的话

02:30:21.040 --> 02:30:22.480
可能说是

02:30:22.480 --> 02:30:24.240
它会增加个五六个的情况下的话

02:30:24.240 --> 02:30:25.720
你是不是要考虑一下

02:30:25.720 --> 02:30:28.720
我这个时候应该去尝试花点时间

02:30:28.720 --> 02:30:29.200
对吧

02:30:29.200 --> 02:30:31.560
花点时间去开发一下

02:30:31.560 --> 02:30:33.160
比如说类似于vuex这样的功能

02:30:33.160 --> 02:30:33.760
对吧

02:30:33.760 --> 02:30:36.400
去防止我这样的一个吻合度变得特别高

02:30:36.400 --> 02:30:40.320
来降低我这样的一个风险的一个迅速

02:30:40.320 --> 02:30:42.200
当然

02:30:42.200 --> 02:30:43.920
如果说你这个功能

02:30:43.920 --> 02:30:46.760
它就是到B到C就OK了

02:30:46.760 --> 02:30:47.000
对吧

02:30:47.000 --> 02:30:47.480
好

02:30:47.480 --> 02:30:49.320
那你说你再花那么多时间

02:30:49.320 --> 02:30:49.600
对吧

02:30:49.600 --> 02:30:50.600
去搞一个它

02:30:50.600 --> 02:30:51.960
去搞一个vuex的吧

02:30:51.960 --> 02:30:52.920
比如说

02:30:52.920 --> 02:30:55.000
你现在写完只有vuex的时候

02:30:55.000 --> 02:30:56.400
你写完这种关系

02:30:56.400 --> 02:30:58.120
那A直接去调用vuex的时候

02:30:58.120 --> 02:31:01.720
可能大概需要花实际实验的时间

02:31:01.720 --> 02:31:02.720
去来搞

02:31:02.720 --> 02:31:04.240
实验实验就能很好地去上个线

02:31:04.240 --> 02:31:06.240
而且后面这个需求不再去扩展了

02:31:06.240 --> 02:31:07.560
那ok

02:31:07.560 --> 02:31:10.080
那如果说你再去写个它的话

02:31:10.080 --> 02:31:12.760
可能还需要去花费加你一个月的时间

02:31:12.760 --> 02:31:14.120
那你有必要去写吗

02:31:14.120 --> 02:31:15.200
你其实是没有必要的

02:31:15.200 --> 02:31:16.120
因为你都知道了

02:31:16.120 --> 02:31:17.280
这个东西不会再加了

02:31:17.280 --> 02:31:17.800
对吧

02:31:17.800 --> 02:31:19.040
你再去花一些实验的话

02:31:19.040 --> 02:31:20.560
其实是些图楼

02:31:20.560 --> 02:31:21.880
因为没有必要

02:31:21.880 --> 02:31:23.680
但是如果说你知道这个东西

02:31:23.680 --> 02:31:24.520
我们先上架

02:31:24.520 --> 02:31:26.400
只是上架第一版本

02:31:26.400 --> 02:31:27.760
B和C对吧

02:31:27.760 --> 02:31:28.520
后面还怎么样

02:31:28.520 --> 02:31:30.320
还需要它再往后面去关联

02:31:30.320 --> 02:31:31.160
关联很多

02:31:31.160 --> 02:31:32.160
新增很多的话

02:31:32.160 --> 02:31:34.160
那这个时候你就要考虑一下

02:31:34.160 --> 02:31:35.280
如果你不写它的话

02:31:35.280 --> 02:31:36.880
后面风险就特别大

02:31:36.880 --> 02:31:38.560
很多时候你在写写的话

02:31:38.640 --> 02:31:41.800
你会导致整个这个系统推倒去成功

02:31:41.800 --> 02:31:44.120
那这个时候你是要去花点时间

02:31:44.120 --> 02:31:46.240
去搞一下这么个东西

02:31:46.240 --> 02:31:47.920
来去解决你这样一个

02:31:47.920 --> 02:31:50.400
偶和度过高的一个问题

02:31:50.400 --> 02:31:52.440
也就是说

02:31:52.440 --> 02:31:55.280
我们刚刚才所讲的这一下

02:31:55.280 --> 02:31:56.600
如果说总结一下

02:31:56.600 --> 02:31:57.440
这是心得

02:31:57.440 --> 02:31:58.080
心得

02:31:58.080 --> 02:32:00.240
就是代码的质量的高低

02:32:00.240 --> 02:32:02.000
有的时候是素质这样的一个

02:32:02.000 --> 02:32:04.560
就是体现出你变成这个素质

02:32:04.560 --> 02:32:06.400
但有的时候我们学会全衡

02:32:06.400 --> 02:32:06.760
对吧

02:32:06.800 --> 02:32:08.120
学会全衡直到

02:32:08.120 --> 02:32:09.880
它才能体现出你的开发经验

02:32:09.880 --> 02:32:11.200
你知道我什么时候

02:32:11.200 --> 02:32:12.480
应该花多少时间

02:32:12.480 --> 02:32:14.400
去做多少事

02:32:14.400 --> 02:32:17.000
这个时候才是你的最佳的开发经验

02:32:17.000 --> 02:32:18.520
那如果说你代团队也好

02:32:18.520 --> 02:32:20.000
如果说是你要真正

02:32:20.000 --> 02:32:22.320
指导一批人去做事也好

02:32:22.320 --> 02:32:24.320
你要学好的事情就是全衡

02:32:24.320 --> 02:32:25.880
就是全衡

02:32:25.880 --> 02:32:28.200
但我们刚才画那么多堆图

02:32:28.200 --> 02:32:29.040
这么多堆图的话

02:32:29.040 --> 02:32:30.520
其实你可以总结一下

02:32:30.520 --> 02:32:31.560
就是代码

02:32:31.560 --> 02:32:33.120
比如说你写的是一坨乱码

02:32:33.120 --> 02:32:33.560
对吧

02:32:33.560 --> 02:32:35.200
我们可以靠单一开闭

02:32:35.200 --> 02:32:36.480
理是这样一种原则

02:32:36.480 --> 02:32:38.600
把它分成很多这种块

02:32:38.600 --> 02:32:40.760
比如说把它分成很多这样的功能

02:32:40.760 --> 02:32:42.880
但这些功能一代分多了以后的话

02:32:42.880 --> 02:32:44.120
必然怎么样

02:32:44.120 --> 02:32:47.400
可能会形成这种很多的偶和关系

02:32:47.400 --> 02:32:50.160
首先分成块就块多了

02:32:50.160 --> 02:32:54.440
那这个出现线的这种多数

02:32:54.440 --> 02:32:56.760
就是你这个线变得多的这种概率

02:32:56.760 --> 02:32:58.440
就会增大对吧

02:32:58.440 --> 02:32:59.160
那好了

02:32:59.160 --> 02:33:00.080
那这个变得

02:33:00.080 --> 02:33:02.760
如果说是你再不去按照这种

02:33:02.760 --> 02:33:03.640
迪米特法则

02:33:03.640 --> 02:33:07.400
或者说最最小知道原则去做事的话

02:33:07.400 --> 02:33:08.280
对吧

02:33:08.280 --> 02:33:09.800
你可能说一个这个块

02:33:09.800 --> 02:33:11.640
会跟很多个线相连

02:33:11.640 --> 02:33:12.200
那这样的话

02:33:12.200 --> 02:33:14.480
偶和度可能说又极具的去增加了

02:33:14.480 --> 02:33:16.720
所以说我们要按照这种迪米特法则

02:33:16.720 --> 02:33:17.960
这种最好知道原则

02:33:17.960 --> 02:33:19.720
去把这个偶和度尽可能的降低

02:33:19.720 --> 02:33:21.360
你别让这一个对象

02:33:21.360 --> 02:33:23.800
跟那么多残属性这样的一个关联

02:33:23.800 --> 02:33:25.920
但通过迪米特法则去弱化

02:33:25.920 --> 02:33:27.400
这样那种偶和度的话

02:33:27.400 --> 02:33:29.920
之后我们可不可以再去尝试

02:33:29.920 --> 02:33:31.520
消灭一些偶和度呢

02:33:31.520 --> 02:33:32.120
可以

02:33:32.120 --> 02:33:35.720
最后的大招就是依赖道治原则

02:33:35.720 --> 02:33:37.160
依赖道治原则

02:33:38.440 --> 02:33:39.480
就这个门

02:33:39.480 --> 02:33:40.720
依赖道治

02:33:40.720 --> 02:33:42.680
就说这么多原则

02:33:42.680 --> 02:33:45.560
它只是一些理论一种方式

02:33:45.560 --> 02:33:47.400
当然我们最后想去实验它的话

02:33:47.400 --> 02:33:50.000
还是需要一些设计模式它来去做

02:33:50.000 --> 02:33:52.040
但你要今天要知道一下

02:33:52.040 --> 02:33:53.760
这么多原则它要干什么事

02:33:53.760 --> 02:33:56.720
它要干的事就是降低复杂度

02:33:56.720 --> 02:33:58.760
也尽量降低偶和度

02:33:58.760 --> 02:33:59.680
那这种原则

02:33:59.680 --> 02:34:02.440
它们都是针对于干什么事的

02:34:02.440 --> 02:34:04.880
你要明白

02:34:04.880 --> 02:34:06.240
当然听到这里后

02:34:06.240 --> 02:34:10.300
相信很多图片是不是都蒙圈了

02:34:13.740 --> 02:34:14.820
谁点

02:34:17.420 --> 02:34:19.060
你讲就讲那么多实验

02:34:19.060 --> 02:34:22.540
今天东西其实很抽象

02:34:22.540 --> 02:34:24.700
你要回去尽量去多看看

02:34:24.700 --> 02:34:25.980
去多看看

02:34:25.980 --> 02:34:27.740
实际模式这东西谁讲都不好讲

02:34:27.740 --> 02:34:28.260
实实话

02:34:28.260 --> 02:34:29.700
谁讲都不好讲

02:34:29.700 --> 02:34:30.580
它在你用笔

02:34:30.580 --> 02:34:32.020
你要不要讲的话

02:34:32.020 --> 02:34:32.740
也很难

02:34:32.740 --> 02:34:36.180
因为它毕竟很多这种抽象的概念

02:34:36.180 --> 02:34:38.340
去帮人们去植入给大家的话

02:34:38.340 --> 02:34:40.740
去挂给大家脑子里的话

02:34:40.740 --> 02:34:43.420
那需要很强的这种前期的开发

02:34:43.420 --> 02:34:44.540
一个机电

02:34:44.540 --> 02:34:47.820
当然你也需要一个比较强的表达

02:34:47.820 --> 02:34:50.100
和抽象的一个能力

02:34:50.100 --> 02:34:52.580
所以说我也并不说是能把这课

02:34:52.580 --> 02:34:54.420
讲到多么的特别的好

02:34:54.420 --> 02:34:57.260
但我觉得我讲的这个东西是很实用的

02:34:57.260 --> 02:34:59.420
我希望你能回去多听几遍

02:34:59.420 --> 02:35:01.140
好好去感受一下

02:35:01.140 --> 02:35:02.100
那最后这一块的话

02:35:02.100 --> 02:35:05.340
我想说一下就是

02:35:05.340 --> 02:35:10.700
我想说一下就是跟心得来总结说一个东西

02:35:10.700 --> 02:35:14.580
就是我们知道原则是理论的

02:35:14.580 --> 02:35:16.340
我们这个模式在理论上

02:35:16.340 --> 02:35:18.340
去形成这个具体的方式

02:35:18.340 --> 02:35:21.500
那如果说我们都希望

02:35:21.500 --> 02:35:22.700
考试考100分

02:35:22.700 --> 02:35:24.660
我也建议你考100分

02:35:24.660 --> 02:35:26.340
但你会想一件事情

02:35:26.340 --> 02:35:28.260
如果说不可能我还要去玩

02:35:28.260 --> 02:35:30.100
比如说你的父母

02:35:30.100 --> 02:35:33.260
他就不要求也没有科目科考100分

02:35:33.260 --> 02:35:35.900
完了之后你自己也不想当那种

02:35:35.900 --> 02:35:38.460
就是特别扭的一个学霸

02:35:38.460 --> 02:35:40.100
达到优秀就可以了

02:35:40.100 --> 02:35:41.780
你想要花点时间去锻炼

02:35:41.780 --> 02:35:43.020
去教你朋友

02:35:43.020 --> 02:35:43.580
是不是

02:35:43.580 --> 02:35:45.180
你的价值观可能他就是这样的

02:35:45.180 --> 02:35:46.900
你的需求他也是这样的

02:35:46.900 --> 02:35:49.580
那比如说你想考90分的话

02:35:49.580 --> 02:35:53.420
你想能说你一天花三小时学习就可以了

02:35:53.420 --> 02:35:54.540
但想考100分的话

02:35:54.540 --> 02:35:56.020
可能一天花六点

02:35:56.020 --> 02:35:57.140
增了一倍

02:35:57.180 --> 02:35:58.580
那这个时候你要怎么样

02:35:58.580 --> 02:36:00.380
你要打到一种权衡

02:36:00.380 --> 02:36:01.180
对不对

02:36:01.180 --> 02:36:02.660
要根据不同的需求

02:36:02.660 --> 02:36:04.300
根据不同的这种情况

02:36:04.300 --> 02:36:05.620
去做这样的事

02:36:05.620 --> 02:36:08.780
那么学原则学模式的话

02:36:08.780 --> 02:36:11.020
前期我一定是希望你能多去

02:36:11.020 --> 02:36:11.740
怎么怎么的

02:36:11.740 --> 02:36:13.340
多去可以的去练习一下

02:36:13.340 --> 02:36:15.620
但是你真正落实到

02:36:15.620 --> 02:36:17.740
到工作以后今天开发的时候

02:36:17.740 --> 02:36:19.260
你真的没有必要

02:36:19.260 --> 02:36:20.660
写一些小动用

02:36:20.660 --> 02:36:21.500
写一些这样的

02:36:21.500 --> 02:36:23.140
比如说写一个活动页

02:36:23.140 --> 02:36:26.060
你都去把实力模式去帮你去干

02:36:26.100 --> 02:36:29.180
这样你可以这么去写

02:36:29.180 --> 02:36:30.780
但你会花很多时间

02:36:30.780 --> 02:36:34.140
你会让外人

02:36:34.140 --> 02:36:35.980
可能让不同的人会觉得

02:36:35.980 --> 02:36:37.140
你看别人对吧

02:36:37.140 --> 02:36:38.820
这个一天找的

02:36:38.820 --> 02:36:40.940
你花四五天的时间

02:36:40.940 --> 02:36:42.420
还有没有必要

02:36:42.420 --> 02:36:45.220
有的时候可能说是你在公司中

02:36:45.220 --> 02:36:47.260
你面对的一些人

02:36:47.260 --> 02:36:49.420
或者说能影响你生前的人

02:36:49.420 --> 02:36:51.940
他也未必完全的就懂

02:36:51.940 --> 02:36:54.700
或者说他也不会去

02:36:54.700 --> 02:36:55.980
就是完全的图到

02:36:55.980 --> 02:36:57.900
这个你写的代码之中

02:36:57.900 --> 02:36:59.700
他看你写代码到底好不好

02:36:59.700 --> 02:37:01.260
有的时候他也要去全行一些事情

02:37:01.260 --> 02:37:01.700
对吧

02:37:01.700 --> 02:37:02.660
他可能说他有迹效

02:37:02.660 --> 02:37:03.940
他有这样指标去压扰着

02:37:03.940 --> 02:37:04.380
对吧

02:37:04.380 --> 02:37:06.380
他可能说上线越快越好

02:37:06.380 --> 02:37:07.580
但你图这个代码

02:37:07.580 --> 02:37:08.300
我要指尖高

02:37:08.300 --> 02:37:08.740
对吧

02:37:08.740 --> 02:37:10.300
我一定要写到什么样的

02:37:10.300 --> 02:37:12.540
我一定是这种极客精神

02:37:12.540 --> 02:37:14.180
但有的时候往往会得不常识

02:37:14.180 --> 02:37:16.300
OK

02:37:16.300 --> 02:37:18.020
比如说咱们学模式的话

02:37:18.020 --> 02:37:19.540
就是要学到一种这种

02:37:19.540 --> 02:37:21.180
就是前期要刻意去练习

02:37:21.180 --> 02:37:21.780
要理解的

02:37:21.780 --> 02:37:22.300
对吧

02:37:22.300 --> 02:37:23.900
要会使用它

02:37:23.900 --> 02:37:26.100
那就是咱们

02:37:26.100 --> 02:37:27.260
虽然说不会把所有的模式

02:37:27.260 --> 02:37:28.620
全部都讲过

02:37:28.620 --> 02:37:30.740
但是我希望当我讲完以后的话

02:37:30.740 --> 02:37:34.420
你能自己不外的再去补充充

02:37:34.420 --> 02:37:35.740
再去去看看

02:37:35.740 --> 02:37:37.620
就是说咱们可能体系有

02:37:37.620 --> 02:37:39.620
如何去看一些框架原码

02:37:39.620 --> 02:37:41.380
去抛写这样的一些设定模式

02:37:41.380 --> 02:37:43.620
但我依旧希望你能花些时间

02:37:43.620 --> 02:37:46.700
多去读一读别人好的写的一些东西

02:37:46.700 --> 02:37:48.100
那比如说最基本的

02:37:48.100 --> 02:37:49.620
WES原码

02:37:49.620 --> 02:37:50.420
Retreat

02:37:50.420 --> 02:37:51.820
特略特略特略大使原码

02:37:51.820 --> 02:37:52.780
比如说这些东西

02:37:52.780 --> 02:37:54.420
你应该去看一看的

02:37:54.420 --> 02:37:55.860
当然最后这些课

02:37:55.860 --> 02:37:58.580
最后这些课

02:37:58.580 --> 02:38:01.220
这些课咱们那个引用哈含的一句话

02:38:01.220 --> 02:38:01.580
对吧

02:38:01.580 --> 02:38:03.340
就叫做听过很多道理

02:38:03.340 --> 02:38:05.460
依然骨跑这一声

02:38:05.460 --> 02:38:07.300
要说虽然这个我讲了很多

02:38:07.300 --> 02:38:07.740
对吧

02:38:07.740 --> 02:38:09.420
但你真正能听一句

02:38:09.420 --> 02:38:11.380
真正能应用的话

02:38:11.380 --> 02:38:12.820
这个能用的好的话

02:38:12.820 --> 02:38:14.020
我相信也为弊

02:38:14.020 --> 02:38:15.180
这个也为弊

02:38:15.180 --> 02:38:15.900
那怎么办呢

02:38:15.900 --> 02:38:16.420
对吧

02:38:16.420 --> 02:38:17.140
怎么办

02:38:17.140 --> 02:38:20.700
需要你去想达到执行合一的话

02:38:20.700 --> 02:38:21.340
挺难

02:38:21.340 --> 02:38:23.020
首先你要知做够多

02:38:23.020 --> 02:38:23.860
知合一的话

02:38:23.860 --> 02:38:26.620
一方面就是你要知道的做够多

02:38:26.620 --> 02:38:27.100
对吧

02:38:27.100 --> 02:38:28.900
你要有一定的这种知识储备

02:38:28.900 --> 02:38:31.620
你要有这样一个思想层面的一个高度

02:38:31.620 --> 02:38:32.260
那行呢

02:38:32.260 --> 02:38:34.780
就是你要把这个东西渐行

02:38:34.780 --> 02:38:36.860
你要不断的去刻意的去练习

02:38:36.860 --> 02:38:38.060
去尝试

02:38:38.060 --> 02:38:41.340
你才能把这个东西把你知融到你的行动之中

02:38:41.340 --> 02:38:43.340
要知行合一

02:38:43.340 --> 02:38:45.940
但咱们后面这个频道也在翻课中的话

02:38:45.940 --> 02:38:46.860
是丁老师讲的

02:38:46.860 --> 02:38:48.140
当然丁老师

02:38:48.140 --> 02:38:51.580
之前在林维说明去讲这个课的时候的话

02:38:51.580 --> 02:38:52.780
讲得很仓促吧

02:38:52.780 --> 02:38:54.660
可能这个纸张没有那么高

02:38:54.660 --> 02:38:56.340
但这个翻课中的话

02:38:56.340 --> 02:38:57.260
无论从内容

02:38:57.260 --> 02:38:59.500
还从讲的这个风格才来讲的话

02:38:59.500 --> 02:39:01.740
也会比之前要比以前要强很多很多

02:39:01.740 --> 02:39:03.180
所以说这一块的话

02:39:03.180 --> 02:39:04.540
同学不用太担心

02:39:04.540 --> 02:39:07.580
你进行期待就可以

02:39:07.580 --> 02:39:09.260
但是最后讲维尼

02:39:09.260 --> 02:39:11.820
讲维尼这种原码的时候

02:39:11.820 --> 02:39:14.540
它也会抛弃整个这样的一个过程

02:39:14.540 --> 02:39:16.020
那它里面一定会有模式

02:39:16.020 --> 02:39:17.340
这样一些东西

02:39:17.340 --> 02:39:18.980
我们前期就铺垫了这么多

02:39:18.980 --> 02:39:20.780
我也希望你喜欢这个东西的话

02:39:20.780 --> 02:39:22.540
你额外去拓展一下

02:39:22.540 --> 02:39:24.140
到时候再听那个课的时候

02:39:24.140 --> 02:39:25.540
希望你能得心应收

02:39:29.620 --> 02:39:30.660
OK

02:39:30.660 --> 02:39:31.580
咱这样

02:39:31.580 --> 02:39:34.740
咱今天讲的稍微有点多

02:39:34.740 --> 02:39:34.980
对吧

02:39:34.980 --> 02:39:36.300
稍微有点多

02:39:36.300 --> 02:39:37.500
一下讲个三个点

02:39:37.500 --> 02:39:38.620
讲了三个点

02:39:38.620 --> 02:39:40.260
别人给同学都听累了

02:39:40.260 --> 02:39:41.380
咱这样

02:39:41.380 --> 02:39:45.060
咱今天咱就先到这怎么样

02:39:45.100 --> 02:39:46.540
等那个下一个的话

02:39:46.540 --> 02:39:49.060
我们把每个模式单独抽出来

02:39:49.060 --> 02:39:50.220
落实到代码之中

02:39:52.140 --> 02:39:59.080
可以吧同学

02:39:59.080 --> 02:40:00.800
同学给个回音

02:40:04.800 --> 02:40:05.720
你是可以同学

02:40:05.720 --> 02:40:06.680
但我要同学的话

02:40:06.680 --> 02:40:12.090
我估计我就奖废了

02:40:12.090 --> 02:40:12.450
好

02:40:12.450 --> 02:40:13.890
饿了就回去吃点东西

02:40:13.890 --> 02:40:14.890
饿了回去吃点东西

02:40:21.520 --> 02:40:25.250
再见了同学

02:40:25.250 --> 02:40:34.250
再见了

02:40:34.250 --> 02:40:34.930
再见

