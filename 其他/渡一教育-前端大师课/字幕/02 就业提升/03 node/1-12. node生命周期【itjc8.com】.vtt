WEBVTT

00:00.000 --> 00:03.600
这节课呢 我主要用 ppt 来讲简

00:03.600 --> 00:09.000
然后在这个叉曼的里面呢 给大家记一些笔记 记一些笔记

00:09.000 --> 00:14.450
最后我们学习的是露的生命周期

00:14.450 --> 00:19.450
如果说换一句话来说的话 也叫做露的的事件循环

00:19.450 --> 00:27.950
首先你要听这节课啊 你首先得把那个之前咱们在耶诗六的时候给他讲的那个事件循环了

00:27.950 --> 00:31.850
你那个东西你得搞清楚啊 我们这节课是建立在他的基础上的

00:31.850 --> 00:42.350
因为露的生命周期啊 他比那个流烂器呢 相比的话是有一些变化的啊 是有一些差异的

00:42.350 --> 00:49.350
因此呢 我们在使用那个露的的时候呢 有一些地方的还要注意 而且呢 他还提供了一些特别的 API

00:49.350 --> 00:54.350
因为我们露的毕竟是跟操作系统打摇刀 所以说他的事件循环呢 相对复杂一些

00:54.350 --> 00:59.850
好 咱们来看一下啊 实际上我们这节课很简单 就是把浙江楚图理解清楚

01:00.350 --> 01:06.550
浙江楚图理解清楚了 OK 那露的这个事件循环呢 你就搞清楚了

01:07.850 --> 01:16.850
这里我还要说一句 就是露的事件循环啊 跟我们平时的写代码关系大不大呢 就是会不会影响我们写代码呢

01:17.450 --> 01:23.650
会影响那么一点点 但是呢 影响的不是很大啊 影响的不是特别特别大

01:24.250 --> 01:34.450
他主要的是影响你的面试题 他面试题里边比较爱出这个事件循环的题啊 以后呢 我们看两道面试题啊 我在网上收了两道 以后我们可以看一下

01:36.450 --> 01:44.050
而且而且我再再多说一句啊 就是露的事件循环的话 他在不同的操作系统上还有一些细微的差异

01:44.850 --> 01:48.850
那么这些细微的差异呢 设计到了东西非常深 他设计到操作系统了

01:49.850 --> 01:55.450
这些东西呢 我们就不再过分了啊 我们这些东西也不会出面试题的啊 也面试完了 他也自己也不知道

01:55.850 --> 02:02.450
所以说呢 我们这里呢 就点到技职啊 我们把平时面试题里边容易出现的问题呢 给他讲清楚

02:03.650 --> 02:09.850
好 那么这里边呢 我就省略到很多东西了啊 什么直行站呀 是吧 还有什么load的那个

02:10.650 --> 02:16.650
其他线程对吧 我们知道浏览器是不是有多多个线程 只不过我们解释的执行线程只有一个对吧

02:17.250 --> 02:19.090
但是浏览器实际上是有多个线程的

02:19.650 --> 02:27.250
load也是一样load里边实际上也是有多个线程的啊 只不过呢 我们平时用了节词呢 执行节词的线程只有一个啊 他是这个

02:28.090 --> 02:34.770
因此呢 我们呢 就不用去考虑其他线程了啊 我们就在节词的主线程里边来看一下他的运作方式

02:35.650 --> 02:42.650
那么他首先怎么运行的 首先运行的是这个我们程序刚启动的时候呢 是运行的是这个妹啊 祖函术

02:43.050 --> 02:54.810
也不是祖函术啊 运行的那个就是我们的那个启动入口入口那个文件啊 把它代码了 去全局上下文的代码了 拿出来运行啊 这就是这个一开始他运行的方式

02:56.170 --> 03:01.770
然后呢 这个这个运行完了过后呢 他这个时候要检查是否要进入事件循环

03:02.970 --> 03:06.930
他怎么来检查呢 他就检查别的线程里边 还有没有一些

03:07.490 --> 03:15.810
其他的事情啊 我还没有处理 或者说还有没有不仅不一定是别的线程 还有没有别的任务我还没有玩

03:16.850 --> 03:22.050
比方说一个技师器 比方说我正在读文件对吧 文件还没有读完 那么像这些事情有没有结束

03:22.530 --> 03:29.970
如果说还没有结束的话 虽然说我们祖函术运行完了 但是呢 他要进入事件循环来运行别的东西

03:30.690 --> 03:35.930
啊 那么事件循环的运行的过程呢 就是走一圈又回来 看一下还有没有结束

03:36.410 --> 03:42.250
没有结束 我们又走一圈 又回来 还有没有结束 还有没有别的事情 那又走一圈 又回来

03:42.570 --> 03:46.890
对吧 他就是整体上就这样的运行方式 如果说所有的东西都没了

03:47.330 --> 03:53.130
都没有任何事情可以做了 也没有任何事情可以等待了 那么我就结束了 整个程序又结束

03:54.050 --> 03:59.450
所以说当我们来看到以前咱们写这个代码的时候啊 set time out 比方说

04:00.410 --> 04:06.890
我们这里呢 给一个5秒钟 我们这里输出一个set time out 我们这里呢 输出一个hello

04:08.450 --> 04:09.970
保存 然后呢 我们这里运行

04:11.530 --> 04:19.530
运行了哈喽离开 是不是没有结束 对吧 等了5秒钟之后 他输出了set time out 对吧 大家都能够理解 那他到底是怎么回程的 就是这样子

04:20.530 --> 04:29.050
一开始运行我们的就是入口 入口我们就是全球上下文吗 就运行他 对吧 运行他 那么这个东西是不是交给了啊 雕度现成 对吧

04:29.290 --> 04:32.290
交给了事件计时的现成 他帮帮我们计时5秒钟

04:32.930 --> 04:39.730
好 5秒钟之后是把这个函数推向事件对列 对吧 那么由于他正在计时 由于他目前有东西正在计时

04:40.130 --> 04:46.330
所以说到了这的时候呢 他发现我这些的不能结束 我现在程序不能结束 我得等 对吧

04:47.130 --> 04:49.290
等 等完了过后了 然后呢 再

04:50.250 --> 04:53.290
没有任何事情可以做了 再结束啊 整体上是这么运行的

04:54.010 --> 05:04.930
那么现在呢 我们要进入他具体的过程来看一下 他事件循环的时候 到底经过了哪些事情 这个比浏览器要复杂一些啊 中间这两个先不暂时不用管啊 中间这两个我们以后再说

05:05.770 --> 05:07.610
我先看这个就是这个圈圈

05:08.770 --> 05:17.770
那么在事件每一次事件循环的时候呢 我们把每一次的事件循环啊 叫做一次循环 或者是一次轮循 或者是一次tick

05:18.770 --> 05:24.850
啊 都可以 总之我们把它叫做一次循环嘛 那么一次循环的时候呢 他要经过六个阶段

05:25.330 --> 05:33.970
分别叫做tamers 啊 这些字看不清楚 因为他不重要 不是我们这些课要讲的内容啊 他跟我们的操作系统呢 有很大关系了啊 我们这些东西就不用不用考虑了

05:34.450 --> 05:41.170
他第一个阶段的tamers 第二阶段的是pending callback 第三个阶段是adult 第四个阶段pull 第五个阶段check 第六个阶段close

05:42.130 --> 05:43.850
啊 主要是经过这么一些阶段

05:44.850 --> 05:51.890
那么在这些阶段里面呢 我们要重点的关注tamers pull check 其他阶段我们不用管啊 面试体不会考的

05:52.690 --> 05:58.210
那么我们现在看一下他第一个 每一个阶段是什么意思呢 每一个阶段呢 他会维护一个对立

05:58.930 --> 06:04.170
啊 会维护一个事件对列 你可以把这里的每一个阶段这个圈啊 想象成一个事件对列

06:05.250 --> 06:11.130
哎 这就跟我们之前的浏览器是不是不一样了 浏览器是不是只有一个事件对列 对吧 最多两个嘛 一个红队的一个微对列嘛

06:11.170 --> 06:13.810
对不对 但是在loads里面

06:14.610 --> 06:22.130
他全这些对立啊 他有很多的对立 他这里有六个对立 我们只需要关注其中三个就可以了啊 他有六个对立

06:22.890 --> 06:24.850
那么只只有那么我们关注这三个

06:26.530 --> 06:34.810
那么一个对立他到达过后呢 他干嘛呢 他查看一下这个对立里面有没有东西 有没有他这里边放的是什么呢 放的就是我们的回调函数

06:35.570 --> 06:40.130
啊 有没有回调函数 如果说有的话就一次拿出来执行 把执行空

06:41.010 --> 06:46.370
执行完了过后进入下一个对立 又来再进入下一个对立 他是用这种方式来执行的

06:47.290 --> 06:49.890
那么我们来看一下这个代码怎么的理解呢 他就这样子

06:50.850 --> 06:55.770
我们一开始输出了哈喽对吧 然后呢 现在有计时 有计时是不是

06:56.410 --> 06:56.730
就进

06:57.810 --> 07:02.770
是不是就进入了事件循环 对吧 还在循环循环等五秒钟啊 循环五秒钟完了过后

07:03.050 --> 07:08.290
到了这 是不是这里边就有一个东西了 太门是什么 太门是就是计时器什么set

07:08.890 --> 07:13.090
timeout啊 set interval啊 他的回调函数就会进入这个对立

07:13.770 --> 07:17.450
那么到了这个对立过后 这里边是不是有一个函数了 是不是有这么一个函数

07:17.970 --> 07:23.650
那么他就会把这个对立清空啊 他就会把这个对立拿出来 这里边的函数拿出来执行

07:24.210 --> 07:31.250
好 执行完了过后又进入下个对立 方向这些对立都没有东西了 OK 那么再还有没有了没有了 没有了就结束了

07:32.130 --> 07:33.050
对吧 这是timeouts

07:34.530 --> 07:40.370
没问题吧 好 那么timeouts过后了 这两个不用管啊 然后我们到了这个破这个阶段

07:40.810 --> 07:47.770
就是我们这里清空了之后 这个阶段 这个就像干嘛呢 这个就像是这样子的 这个阶段他执行的是我们这里

07:48.970 --> 07:50.690
就笔记啊 timeouts阶段

07:51.690 --> 07:55.490
这个阶段干嘛呢 他是存放那个

07:56.530 --> 08:05.530
计时器啊 计时器就set timeouts set interval啊 这一计时器的回调函数啊 回调函数 这是他这个对立

08:06.530 --> 08:13.210
好 那么下一个对立呢 我们就看一下破 破这个对立是非常非常重要的一个对立 他叫做轮寻对立

08:13.530 --> 08:21.810
这个对立他会干嘛呢 他首先看他这个对立里面会存放什么样的回调函数呢 他这样子

08:22.610 --> 08:28.450
除了timeouts 除了timeouts和checks

08:29.690 --> 08:34.530
和checks 就除了这两个对立之外的啊 绝大部分

08:36.610 --> 08:41.090
绝大部分回调都会放入该对立

08:41.770 --> 08:46.530
啊 都会放入这个对立 绝大部分回调都会放入 比方说 比如啊 比如

08:47.890 --> 08:50.570
文件内文件的读取

08:51.290 --> 08:58.770
对吧 文件的内容读取是不是个回调 对不对 回调函数啊 我们用promise 他也是回调函数的意思 我们他只是语法给你改变了一下啊

08:59.770 --> 09:02.050
文件的读取还有什么呢 监听

09:02.730 --> 09:09.850
拥护请求啊 拥护请求的时候到哪是有个回调函数 对不对 那么这些回调函数呢 他都会进入这个对立

09:10.370 --> 09:14.810
不要一个拥护请求来了 我们之前是不是写过这样的代码 对不对 啊 什么 agdp

09:16.490 --> 09:21.890
agdp craze server啊 那么这里呢 是不是写了这么一个东西

09:22.850 --> 09:30.610
啊 对不对 那么这是不是回调函数 当一个拥护请求来的时候 是不是运行这个回调函数 那么这个回调函数进入哪个对立 他是一步的 他就会进入

09:31.370 --> 09:36.490
啊 这个对立 破我对立 好 那么这个破我对立啊 他到底是怎么运行的呢

09:36.690 --> 09:42.410
他的运作方式呢 是这样子的啊 咱们看一下破我对立比较重要的 非常重要的对立啊 运作方式

09:43.330 --> 09:55.890
他是这样子的 如果破终有回调啊 有回调函数 需要你执行的 那么首先要一次执行啊 一次执行回调啊 直到清空对立

09:57.010 --> 09:57.690
把对立清空

09:59.250 --> 10:01.250
对吧 这是他这种情况

10:02.250 --> 10:07.730
那如果说破终没有回调的话啊 如果

10:09.570 --> 10:19.050
破终他没有回调 因为已经是空的了 那么这个社会怎么样了 他会等待啊 等待其他对立

10:19.850 --> 10:29.250
啊 就是终出现回调啊 如果说其他对立中出现了回调 如果说其他就是还有等待的事情啊 其他东西 其他对立里边已经出现了回调

10:29.610 --> 10:36.650
那么结束该对 就是该该阶段啊 进入下一阶段

10:37.610 --> 10:46.890
那意思吧 如果说其他对立中没有回调了 就是我自己没有其他对立也没有 都在等都在等 那么这个时候啊 如果其他对立

10:47.770 --> 10:49.010
也没有回调

10:50.090 --> 10:57.730
那么这个时候呢 就持续等待啊 持续等待 直到出现回调为止

10:59.530 --> 11:04.570
直到出现回调为止 别的意思吧 那么这是破终对立他的运作方式

11:05.210 --> 11:08.610
那我们怎么来理解这个东西呢 咱们来看一下 我们这样理解

11:10.450 --> 11:15.730
就还是这个例子啊 还是这个例子 那我们来看一下啊 在这个例子里边呢

11:16.770 --> 11:18.130
我们他到底是怎么运行的

11:19.570 --> 11:27.770
就在首先我们输出这个哈喽对吧 输出这个哈喽呢 这个地方呢 是要在等了五秒钟之后才会运行这个函数

11:28.730 --> 11:35.170
那么也就是说 我们这把这个函数干定命个名字嘛 这样子呢 我们方便解释一件啊 F1

11:36.250 --> 11:39.010
再取个名字啊 有个这么一个函数啊 F1

11:39.770 --> 11:47.690
那么这个F1是要等五秒钟之后运行 对吧 那么这个视线循环启动 那么这个时候有没有F1 没有 对吧 那么进入下一个阶段

11:48.690 --> 11:49.890
好 抛下那有没有什么

11:51.330 --> 11:57.130
函数啊 有没有什么回调函数 没有读文件吧 也没有监听什么请求 所以抛里边也没有任何函数

11:57.530 --> 11:59.570
那么这个时候怎么办呢 他就在那里等着

12:00.490 --> 12:03.570
等啊 那么一直在等还不会往后边运行的啊 他就一直在等

12:04.130 --> 12:08.810
轮迅嘛 就反正还去问有没有有没有有没有啊 如果说没有的话就一直等

12:09.450 --> 12:14.690
等到什么时候呢 等到五秒钟之后 那么F1他出现在了这个队的里边

12:16.290 --> 12:18.730
F1他出现在了这个队里边 F1

12:20.090 --> 12:26.370
这个时候 那么破阶段结束 然后呢进入check进入他进入他进入他 那么是不是运行这个

12:26.850 --> 12:31.530
运行这个timers 对吧 F1 对不对 那么就把这个函数输出了

12:31.850 --> 12:38.250
好 运行完F1过后又是不是又进破了 那么这个时候呢 他发现已经没有任何值得我等待的东西了 是吧

12:38.290 --> 12:43.730
没有任何计时期了 也没有任何什么请求监听了 这些东西没有任何等待了 他就立即结束了

12:44.170 --> 12:50.010
check 然后呢 为这个志愿球员还要继续吗 不继续了 不继续 我们就over 成训结束

12:51.130 --> 12:55.050
你可以再多听几次啊 往上的解释 好 然后呢 我们再来个例子啊

12:57.130 --> 13:01.370
比方说 我们现在呢 导入一个ttp模块嘛

13:02.050 --> 13:03.370
adp create

13:04.490 --> 13:07.600
require adp

13:08.720 --> 13:10.520
adp create server

13:11.480 --> 13:12.200
require

13:13.360 --> 13:15.760
对吧 然后我们这里输出 输出

13:17.720 --> 13:18.400
request

13:19.280 --> 13:23.040
一啊 有一个就是有一个adp on this

13:23.640 --> 13:24.880
额面还得到server啊

13:26.360 --> 13:26.720
server

13:29.380 --> 13:31.860
啊 我不会运行啊 我们只是来解释一下一个现象

13:31.860 --> 13:33.220
lesson 9527

13:34.580 --> 13:40.860
因为我现在也拿来去写剧手代码了 那么这个是不是在监听用户请求 监听9527端口

13:41.300 --> 13:46.700
对吧 那么同时呢 5秒钟之后会会得到这个seton帽子 那么这个东西又怎么来解释呢

13:47.220 --> 13:52.420
同样的又来一次 先运行我们的入口 入口模块 入口的运行的时候

13:52.420 --> 13:58.220
他的他的那个就是全球上下文 是不是没什么东西 对吧 没什么东西 就冲进来一个这个东西嘛

13:58.620 --> 14:03.780
对不对 好 那么这句话是不是在监听9527端口 对不对 好 接下来接下来

14:04.180 --> 14:10.300
到达了什么 到达了这个事件循环 他会 他还想 现在有没有值得我等待的东西呢 好像有

14:10.820 --> 14:16.180
一个是技时器 一个是用户请求 对吧 有值得有值得我等待的东西 那么他先看有没有

14:16.900 --> 14:21.900
现在有没有技时器的回调了 没有 没有技时器的回调 对吧 没有技时器的回调 他就进入pull

14:22.340 --> 14:25.380
pull看一下 有没有用户请求过来呀 现在是不是也没有用户请求过来

14:25.860 --> 14:30.060
对不对 好 也没有用户请求过来 是不是他就在这等着了 卡着了

14:30.940 --> 14:35.660
他就不会再继续运行了 知道吧 他就一直在那里卡着 他也要等 就这个地方他就等

14:36.220 --> 14:41.900
等什么时候呢 等有一个有一个就是回掉 到达这些队力的时候 他就再结束

14:42.580 --> 14:49.300
继续循环 那么最先到达的是谁 最先到达是五秒钟过后f1来了 对吧 f1这个函数来了 于是呢

14:49.860 --> 14:55.140
在这里他就出现了一个f1函数 f1函数过后他就结束这个阶段了 运行切个时间段 运行

14:55.540 --> 15:01.140
又看 还又没有等待呢 有对吧 我们还有个这个是这个就是队里都还没有清空 那肯定要运行

15:02.660 --> 15:08.700
运行这个f1是不是输出了 输出了结果 输出了他 对不对 好 输出了他 输出了他过后呢 我们继续

15:09.460 --> 15:17.420
又回到pull 好 又到pull过后 那么pull是不是又要等看 还有没有 就是我现在队列有没有清空 我队列有没有清空呢 这个队列

15:18.660 --> 15:25.540
已经清空了 对吧 目前没有任何可以执行的东西了 现在但是有没有需要等待的呢 还是有需要等待的 需要等待谁

15:25.820 --> 15:32.460
是不是需要等待用户的请求 我来监听酒屋的习惯客在等待用户请求 对吧 那么从此以后就一直在这里卡着了

15:33.220 --> 15:39.740
他就不动了 就一直在这里卡着 除非你其他队列里面有内容 但其他队列现在这个单码也不可能有内容了 对吧

15:40.380 --> 15:50.100
现在就等用户请求了 所以说我们的就停在这个地方 我们单码就一直停在这个地方 等等用户请求 用户只要用户请求一来 是不是就运行这个函数

15:50.860 --> 15:57.580
对不对 是不是运行这个函数 输出了这个贵魁神印 运行这个函数过后 那么运行完这个函数

15:57.980 --> 16:03.660
这个函数是不是还是在这个队列当中 运行完这个函数过后 那说是这个又清空了

16:04.260 --> 16:08.340
因为这个函数是加到这个队列的 对吧 这个队列又清空了 清空过后还又在这里等

16:09.700 --> 16:14.820
直到什么时候呢 直到等的时间足够长 连操作系统都受不了了

16:15.420 --> 16:22.900
我这里给大家顺便说一句 漏的GS的底层呢 使用的是这个库 这是一个C语言 C++语言写的库

16:23.900 --> 16:30.140
这个库 这个库呢是操作的是主要使用来操作底层操作系统的 它封装了底层操作系统的接口

16:30.620 --> 16:36.900
那么 操作系统呢 它是因为我们的实现循环 实际上是这个库在写的 是用它来写的

16:37.740 --> 16:43.740
因此呢 它这个东西可能等待了足够的时间 操作系统都受不了了 那么这个时候呢

16:44.100 --> 16:49.220
算了 我们再来一次循环吧 它又又转一圈 又转一圈 又回到这 反正还是要等

16:49.780 --> 16:55.020
总之在这阶段一直卡住 对吧 除了说我们平时像什么开发一个漏的服务器

16:55.700 --> 17:00.660
卡顿的时间 不是卡顿的时间 应该说等待的时间最长的是在这个这个阶段

17:01.140 --> 17:08.100
这个破口阶段 它一直在等 等文件读取 等什么的 等那个用户的请求到达 主要是在考虑这个阶段

17:08.460 --> 17:10.260
因此我们如果说运行这个代码的话

17:14.960 --> 17:20.400
运行这个代码的话 你看一下 是不是就一直卡住 它不会运行 它卡在哪 它是不是就卡在这

17:21.040 --> 17:22.320
对不对 它程序结束不了

17:23.720 --> 17:25.600
ok 那么这是关于这个

17:27.160 --> 17:29.840
好 咱们再来 再来一个例子

17:31.080 --> 17:40.130
呃 再来什么例子呢 嗯 我们再来这么一个例子吧 这里呢 我们使用

17:41.570 --> 17:47.370
10毫秒啊 10毫秒 然后呢 这边呢 我去读一个文件吧

17:48.370 --> 17:56.770
required啊 fs 后来我们这里用200毫秒吧 我们这里呢 去读一个文件

17:58.210 --> 18:04.890
fs raid 5啊 我这里用最传统的方式啊 用回调韩说方式方方便来分析啊 读哪个文件呢

18:05.730 --> 18:08.610
我这就拿这些 绝对入进了啊 就读那个index的jess嘛

18:09.890 --> 18:15.890
就是文件啊 error 啊data这是文件的数据 对吧 我们这里呢 还可以写上一个编码啊有天赋钢吧

18:16.890 --> 18:25.210
好 那么我们这里呢 输出啊 这个data啊 我不输出了啊 不输出了 我们这里干嘛呢 把文件读出来过后

18:26.570 --> 18:33.810
我干嘛呢 我这里呢 去运行一段程序啊 让他 让这个代码呢 去卡顿个

18:34.690 --> 18:37.250
300毫秒 我怎么来做 我用这样的方式

18:38.370 --> 18:39.970
start uh dead

18:40.970 --> 18:41.450
no

18:42.370 --> 18:52.130
是不是得到当 当前的时间啊 当前的时间说 然后我写个外国循环 只要我的时间没有超过啊 减去start 没有超过300毫秒

18:52.610 --> 18:59.570
那么我就一直在这循环 就在死循环 对吧啊 他只要除非在这就是这个代码 必须要给我运行300毫秒

19:00.010 --> 19:06.570
运行300毫秒过后 我干嘛呢 我才去输出啊 不用输出了啊 我就输出一个那个

19:07.370 --> 19:11.850
我把这个写到这 read file啊 是不是写到这

19:13.130 --> 19:20.690
我们这里在运行的read file 然后呢 我等待300毫秒 等待300毫秒完了过后 我才结束啊 我这个函数才结束

19:21.290 --> 19:27.290
好 那么然后这边呢 这边我做这么一件事 我一开始的时间啊 一开始一个start

19:28.290 --> 19:35.170
dead no 那么这边呢 我输出一下 我这一边运行了多少时间啊 就是多少时间过后我才运行到这

19:35.810 --> 19:40.650
减去start 好 咱们来看一下啊 这个函数就很有意思 非常有代表性

19:41.410 --> 19:43.930
这个地方是不是200毫秒之后要运行这个函数

19:44.770 --> 19:49.610
对吧 那么我们来看一下这个函数运行的时候 真的是经过了200毫秒吗 你看我们从

19:50.010 --> 19:56.210
从这个函数运行开始我记记个时 对吧 然后这个真正的运行到这句话的时候呢 我把当前时间去减去他的

19:56.530 --> 20:02.730
之前的时间 是不是 就是我等到底具体等了多久 对吧 具体等了多久 我们是不是可以得到了

20:03.250 --> 20:07.080
好 咱们来看一下啊 运行

20:09.320 --> 20:15.520
多少时间 是不是等了500多毫秒 他不是200毫秒吗 为什么等了500多毫秒 那我们怎么来解释 我们又来啊

20:16.200 --> 20:21.160
首先呢 我们执行全军产员 没东西对吧 没东西 然后直接问 有没有东西要等待啊 有

20:21.760 --> 20:27.080
那么首先请问他 有没有什么技时器要我运行的 有没有什么技时器要我运行的

20:27.960 --> 20:33.320
发现了 有没有 根本就没有 对吧 目前还等200毫秒嘛 这个时候肯定还没有到200毫秒

20:33.600 --> 20:41.480
那么这个时候技时器是空的 那么进入轮巡 好到这个阶段 这个阶段他是不是要看一下这个这个时候有没有回掉在这里边

20:41.880 --> 20:47.080
是没有 对吧 因为我这个读文件还是要一段时间的 不是瞬间读出来的 读文件还是比较慢的啊

20:47.880 --> 20:54.240
比方说有读个20毫秒 30毫秒左右啊 总之呢 他要等 那么这个时候呢 是不是他也是空的

20:55.280 --> 20:56.200
好 这个时候就蒙了

20:57.200 --> 21:03.680
这些队列里面全都是空的啊 而且呢 我也没什么事可以做 于是卡在卡在这了 他在这里不断的轮巡

21:04.120 --> 21:06.720
有没有事啊 有没有事啊 有没有事啊 现在这里轮巡

21:07.680 --> 21:11.480
好 这个时候呢 文件终于读出来了 那么他就会把这个函数

21:12.160 --> 21:15.200
这个函数 我们还是用个函数嘛 方形啊 F2

21:15.960 --> 21:19.760
那么他就会把这个F2啊 放到这个 放到这个队列里面 F2

21:20.720 --> 21:23.680
就进入到这个队里 好 那么这个时候他是不是执行 F2

21:24.400 --> 21:31.000
好 F2 的执行过程中啊 他就输出了什么 read file 对吧 所以说我们这里可以看到啊 输出了 read file

21:31.520 --> 21:37.480
好 read file 输出了过后 那么这里是不是卡了三百毫秒 在这卡的这三百毫秒当中

21:38.120 --> 21:42.880
在卡的过程中 是不是 F1 就出现了 F1 就进入这个队列了 但是呢 这里是不是很忙

21:44.000 --> 21:50.120
对不对 是不是非常非常忙 我这里现在事情还没做完啊 那么这个时候 我把 好不容易把 F2运行完了

21:50.280 --> 21:53.080
运行的时间就远远超过了200毫秒 有300多毫秒了

21:53.720 --> 21:56.200
运行完了 那么这个时候 这个是不是又清空了

21:56.960 --> 22:04.520
好 清空了之后他又回到 刚才我一个队列里面有没有呢 没有了 没有了 过后呢 我看一下别的队列有没有呢 别的队列好像这个东西有

22:05.320 --> 22:12.040
我这个阶段结束 然后运行他 运行他 运行 然后看一下肯定还有东西 对吧 运行F1 所以说他实际的等待时间

22:13.200 --> 22:16.720
可能会超过啊 可能会超过那个就是

22:17.720 --> 22:24.400
这里的时间 就是他真正 真正等待的时间 好 这是这个例子啊 复制一下

22:25.520 --> 22:31.800
好 接下来我们来说下一个阶段 下一个阶段叫做check 这阶段干嘛的呢 几个笔记啊

22:34.150 --> 22:37.350
这是检查阶段啊 check

22:38.670 --> 22:39.510
检查阶段

22:40.670 --> 22:41.590
检查阶段

22:42.030 --> 22:47.590
好 那么这个阶段呢 他会做什么事呢 这个阶段会啊 就是使用

22:48.750 --> 22:50.310
set immediate

22:52.070 --> 22:53.990
media

22:55.950 --> 23:01.070
呃的回调 会直接进入这个队列

23:02.590 --> 23:08.510
这个函数是不是没见过 是吧 set immediate 你可以把它想象成为什么呢 这个set immediate

23:09.150 --> 23:13.990
可以把它想象成为就是set timeout0 但是实际上是不一样的啊

23:14.630 --> 23:21.080
你可以把它想象成set timeout0 这里是特别容易出面的 你可以把它想象成这个

23:24.140 --> 23:27.380
就这两个差不多 感觉上差不多啊 那么set immediate就是

23:28.180 --> 23:33.740
我这个函数一定是异步的 这个毫无疑问啊 他到世界队列里边去了 对吧 他一定是异步的 但是呢

23:34.460 --> 23:34.940
呃

23:36.780 --> 23:38.900
但是呢 他他的这个

23:39.700 --> 23:48.220
进入的队列啊 跟这个set timeout0不一样 set timeout0进入的队列是哪个队列 是这个队列 对吧 那么set immediate成了进入是这个队列

23:48.780 --> 23:52.660
他为什么要分成两个队列呢 这里呢 给大家多说一句吧

23:53.260 --> 23:58.700
嗯 不用去过于深究啊 他这个是怎么回事啊 是因为timeout这个队列啊 他是怎么回事呢

23:59.340 --> 24:02.140
他是每一次到了个timeout队列的时候

24:03.340 --> 24:06.540
他是怎么来检查 他是不是回 他是有没有回掉的

24:07.340 --> 24:09.380
他是检查那个计时器现成

24:10.180 --> 24:14.500
一个计时器一个计时器拿出来看 来判断当前时间

24:15.140 --> 24:23.380
就是之前开始计时的时间 到当前时间 经过的时间 有没有到达计时期的时间 他是一个一个拿出来检查的

24:23.940 --> 24:28.540
好 如果说检查通过了 他 而且呢 他队列里边还会排序啊 计时器

24:28.780 --> 24:33.140
他那个时间 还会根据这个时间排序 他发现那个时间到达了过后呢

24:33.900 --> 24:36.780
他就会把拿出 把个回掉函数拿出来 进行执行

24:37.540 --> 24:45.580
就这是真实的情况啊 不过呢 我们平时讲的时候呢 对于前端开发者来说 对于我们平时讲的时候呢 一般就是 他是一个队列啊 你把

24:45.980 --> 24:50.460
你把那个就是回掉函数放到一个队列里边去 实际上真实的情况下是

24:50.940 --> 24:55.300
这个队列根本就没有什么队列啊 是真实的情况是到这里过后呢 他是用一个

24:55.660 --> 24:58.740
运算啊 也可以把他想象成一个循环 这都是用C语言写的啊

24:59.220 --> 25:02.780
可以把他想象成一个循环 去检查每一个计时器 时间有没有到达

25:03.620 --> 25:07.300
这是Tembers 而切可这里就简单了多 他没有什么检查

25:07.740 --> 25:14.740
他真的是一个队列 这个地方是真的是一个队列啊 就是我们一旦调用这个set immediate 他就直接把这个函数扔到这个队列里边去了

25:15.380 --> 25:17.220
没有什么计时器 也没有什么现成

25:17.820 --> 25:23.180
对吧 所以说他的效率呢 虽然说他的效果上给那个set time out成的差不多啊

25:23.540 --> 25:25.420
肯定还是有区别 我们一会会就会说区别

25:27.340 --> 25:27.740
跟这个的

25:28.500 --> 25:34.100
效果上感觉差不多 但他的效率要比他高的很多 为什么呢 因为他进入了这个队列啊

25:35.180 --> 25:42.940
每一次事件循环的时候 他会有一个计时器 一个计时器拿出来看 而且呢 要进行运算 看时间到没到 要检查 对吧 他有运算的时间

25:43.500 --> 25:44.620
还有什么呢 还有那个就是

25:46.860 --> 25:52.580
还有计时器的现成 对不对 都会耗费一些时间的 而这个就太简单了 直接

25:53.180 --> 25:56.620
你可以把它想成这个东西是个数组 直接把它扑起到这个数组里面去了

25:57.740 --> 26:04.860
因此他的运算时间很少的 我们来看一下吧 给大家看一下 具体的一个例子就看明白了啊 比方说我们随便写个函数啊 test

26:06.580 --> 26:10.580
哎 我给大家来个什么例子呢 比方说我这里呢 有一个变量啊 i 等于0

26:11.980 --> 26:14.300
这个函数呢 我做这么一件事啊

26:17.880 --> 26:19.680
i加加

26:22.320 --> 26:24.920
判断一下 i 是不是小于1000

26:26.400 --> 26:34.160
如果说他小于1000的话 我就重新调入这个函数 就低规嘛 对吧 我一定要大于1000才行

26:34.720 --> 26:41.160
大于1000我就结束了 我就函数就不动了 如果说他小于1000的话 我就用一个state timeout

26:44.130 --> 26:44.330
0

26:45.250 --> 26:55.120
然后把个test函数传进去 能看懂吗 这单吗 是不是 我运辑的test 是不是一开始肯定是从一开始嘛 对吧 加一

26:55.480 --> 27:02.600
一是小于1000的 所以说我0秒之后 是不是加入到这个set timeout对列 对吧 然后呢 就是set timeout加进去

27:03.120 --> 27:09.600
好 又运行这个set 又运行这个test函数 对吧 那么又加加 然后呢 是不是又运行这个set timeout

27:10.200 --> 27:12.920
对不对 好 咱们看一下整个的执行时间是多少

27:14.520 --> 27:17.280
整个的执行时间 好 这里呢 我们使用一个start吧

27:18.680 --> 27:18.960
start

27:19.960 --> 27:26.440
然后 date now 我们会用那个console console time

27:28.040 --> 27:31.600
时间开始 然后呢时间停滞在这儿啊 else

27:32.920 --> 27:41.240
time end time end 就是当他到达1000的时候 那我就看一不及时结束 当他到达1000的时候就及时结束

27:41.840 --> 27:45.640
原来是吧 好 那咱们来看一下啊 他会运行多少时间

27:48.720 --> 27:53.560
运行到一秒多的吧 一千七百多毫秒 为什么运行这么久呢

27:55.160 --> 28:02.360
为什么不就是一颗韩束反复调用 才调用1000次就会运行这么久 这是为什么呢 咱们来看一下 干什么呢 理解

28:03.040 --> 28:08.400
首先是我们的主韩束运行 主韩束运行 运行没什么东西可以运行的 对吧 哦 有东西啊

28:08.720 --> 28:14.480
这个运行这个test函数 这个test函数 挨加加对吧 运行 然后是不是小于小过后是不是开了个计时器

28:15.200 --> 28:21.520
开了个计时器 是不是一个test 对吧 有个test 是不是这个时候领庙过后 是不是开了个计时器

28:22.160 --> 28:26.480
你至少知道开了个计时器嘛 对吧 这里开了个计时器嘛

28:28.480 --> 28:35.680
计时器是不是开了个计时器 这个计时器完了过后是不是要运行test 对不对 那么这个时候很简单还没发运行啊 因为我们现在还在组

28:36.000 --> 28:39.920
还在那个就是组韩束 还不是组韩束 还在那个拳句上划文

28:40.640 --> 28:44.120
好 那么运那么这里呢 要等领庙过后运行它 对不对

28:44.600 --> 28:48.280
那么现在是不是运行完了 运行完了过后是不是进入那个event loop

28:49.680 --> 28:56.240
是不是进入实验循环 好 实验循环一检查 有没有计时器有 那么这个时候还会把个计时器看一下个时间到没到

28:57.200 --> 29:05.320
哎 由于是领庙的吧 很有可能就已经到了啊 很有可能就已经到了就已经到了的时候 它会怎么样了 它会运行这个计时器函数

29:05.800 --> 29:11.560
一运行的时候 是不是又运行test 对吧 又运行test 是不是又开了个计时器 对不对

29:12.280 --> 29:21.920
啊 又往县城里边加那个计时器要等待计时吗 这个计时器没了 对吧 没了好 然后呢 事件循环啊 这里边到了到了破的时候发现 又有计时器了 那么我结束破

29:22.240 --> 29:29.880
然后又回到这 那么这个时候是不是又要重新运算一次 通过时间去运算一次 运算一下当前时间 减去这个计时

29:29.960 --> 29:37.640
就是目前的时间啊 就之前的计时时间 然后减去这个计时器的时间 然后看一下有没有到达 有到达 然后又拿出来运行

29:38.120 --> 29:39.480
就是他为什么运行这么久

29:40.520 --> 29:49.560
就是因为他有一个时间的运算 看一下这个计时器有没有到达时间 他不是直接运行这个函数的 他首先要判断这个时间有没有到达 因此呢 他运行了这么久

29:50.120 --> 29:53.720
我们现在只需要把它改成set immediate 你看一下

29:55.400 --> 30:01.220
看一下这个时间 只有4秒多 4毫秒多 是不是快了很多

30:01.940 --> 30:08.700
为什么 因为这个东西根本就不存在计时器 根本就没有计时器存在 对吧 因为他是直接加到这个队列的

30:09.100 --> 30:18.940
直接把它加到这个队列的 所以说他的运算速度是非常快 他就是一块 你可以把你想要那个数组 只送到数组里面夹一下 对不对 那么他到了个数组的时候 就就运行就完成了

30:19.660 --> 30:22.140
好 那么这里是关于这个效率上的差别啊

30:23.500 --> 30:24.860
呃 然后我们再说一个点

30:26.220 --> 30:28.380
但如果说啊 这有面试题来了

30:29.900 --> 30:30.460
set timeout

30:31.740 --> 30:34.220
我们这里输出啊set timeout

30:36.540 --> 30:36.780
0

30:37.740 --> 30:38.780
set immediate

30:41.930 --> 30:42.250
输出

30:45.120 --> 30:46.960
这东西他输出的顺序是什么呢

30:49.900 --> 30:56.780
感觉上 按照这个图的话 感觉上好像是他输出那个set timeout对吧 然后再输出这个check对吧 再输出这个set immediate

30:57.980 --> 30:59.420
实际上呢 这里是不一定的

31:01.180 --> 31:06.620
为什么是不一定的呢 是因为这个set timeout啊 他这个地方呢 他是取不到0的

31:07.100 --> 31:09.020
至少都是1 1毫秒

31:09.660 --> 31:14.780
那么就有可能会出现一个情况 就是我这个时候呢 可能计算机稍微卡了一下

31:15.500 --> 31:15.740
啊

31:16.380 --> 31:24.540
从我们计时开始 到那个从我们组上就从这个全球商场完计时开始对吧 到我们这个事件循环到这里检查的时候就已经过了

31:25.260 --> 31:29.900
已经就是还没有到1毫秒啊 就是我们现在的机会运行速度很快 还没有到1毫秒

31:30.220 --> 31:33.980
还没有到1毫秒 这里是不是有空的 对吧 检查通不过 检查这个计时器通不过

31:34.460 --> 31:38.380
啊 还没到时间 可能是零点几毫秒对吧 几微秒几辣秒

31:38.620 --> 31:44.220
那么还没有到这个 是不是没东西 没东西的话 是不是运行破了 破了的话 看到这个emedia程式肯定有东西的

31:44.460 --> 31:50.540
因为执行这句话的时候 它就已经加到这了 所以它是肯定有东西的 于是呢 它就执行到它对吧 执行到它

31:50.940 --> 31:54.940
啊 它执行完了过后啊 又看 现在现在有东西了 对吧 有东西了 然后执行它

31:55.340 --> 32:00.380
对不对 这是一种情况 还有一种情况呢 就是这个1毫秒了 我们现在机会你比较卡 稍微卡了一下

32:00.700 --> 32:05.020
到了这的时候 是不是1毫秒已经过了 那么就可能先运行它 再运行它

32:05.660 --> 32:09.580
明白的意思吧 所以说到这个时候呢 我们来看一下啊 都有可能的

32:09.980 --> 32:12.780
多运行几次啊 你看是不是都有可能

32:13.740 --> 32:17.660
这个是说不准的 对吧 是说不准的 好 那么这是

32:18.700 --> 32:24.140
这个这种情况 等等我把它写成连式一样的啊 再看一下吧

32:25.420 --> 32:35.420
这个东西说不准的啊 这emedia程啊 这个说不准啊 这个东西取决于当时的计算机的运行环境 以前的计算机当时的运行速度

32:37.180 --> 32:40.540
好 这是这道题啊 还有一道题

32:41.260 --> 32:42.780
还有一道题在哪呢 在这儿

32:43.820 --> 32:46.140
在这儿 我们把它换一下啊 这是个面试题

32:46.540 --> 32:47.340
解释

32:48.860 --> 32:52.780
那么请问你这种情况下 它又怎么输出呢

32:53.580 --> 32:57.200
咱们来吕吕吕啊

32:57.920 --> 33:04.160
我们到了实现循环 然后首先进Thomas有没有东西 他们是哪有东西啊 现在连这个文件都还没有读出来 对吧

33:04.160 --> 33:07.520
Thomas更加没有计时器了 计时器都没有 肯定没东西

33:07.520 --> 33:10.640
然后进入这儿 对吧 这里一看我是空的啊 我啥都没有

33:10.720 --> 33:16.160
其他对立也没有 那我等着呗 等着啊 等着个文件读出来 对吧

33:16.800 --> 33:21.920
好 那么这个文件是不是好不容易读出来了 那么这里这个对立里面是不是有东西了 有什么东西 是不是有这个函数

33:22.480 --> 33:24.240
开始那么现在就开始运行这个函数了

33:24.880 --> 33:30.640
好 运行这个函数的过程中 是不是往set timeout啊 这里相当于是写了一个零啊 相当于是写了一个零

33:31.280 --> 33:36.800
那么我就是0秒过后加就开一个计时器啊 开一个计时器0秒过后往这个对立里面放一个对吧

33:37.200 --> 33:41.360
那么计时器开了 另外一个先程就开一个计时器 往这个对立里面放

33:42.080 --> 33:47.520
好 那么同时你立即往这个对立里面加一个东西 那么加了什么呢 加了一个就是

33:48.720 --> 33:50.960
输出二 对吧 那么就用二来表示吧

33:52.000 --> 33:56.640
就输出二 那么假设我们的计算机运行速度非常快 零秒过后马上

33:57.280 --> 34:02.480
一毫秒马上就加了一个一了 那么像这种情况 是不是这两个都有值的 这两个对立

34:03.200 --> 34:06.720
不管啊 只要两个 只要有对立有值 我这个阶段是不是立即结束

34:07.520 --> 34:10.720
阶段立即结束 结束往下过 是不是一定是先运行check

34:11.760 --> 34:18.480
对吧 是不是一定是先运行这个check 所以说他一定先输出二 然后再下一次循环的时候输出一 然后最后又卡在这

34:19.440 --> 34:23.440
没有意思吧 说这个东西就不存在 如果说你这样子写的话 就不存在有任何的

34:24.000 --> 34:25.200
呃 不一样了

34:25.840 --> 34:26.320
面试

34:26.800 --> 34:30.720
看一下 他一定是而已 无论运行多少次 他一定是而已

34:31.280 --> 34:36.640
啊 不可能出现一二的 像这个这种情况也不一样了啊 说这些东西呢必须要建立在你理解

34:37.120 --> 34:41.680
漏的解释啊 他的事件循环了 基础上啊 与他的生命周期的基础上

34:42.880 --> 34:45.040
啊 这是这个切割阶段 对吧

34:46.000 --> 34:49.840
好 那么接下来呢 我再解释 这两个是什么东西 这两个又是对立

34:50.080 --> 34:50.880
也是对立

34:51.440 --> 34:56.000
我们如果说用红任务和微任务来说的话 刚才说的这些对立全是红任务

34:56.880 --> 35:00.160
这些东西全是微任务 这有两个微任务对立

35:00.400 --> 35:02.240
一个是next to tick 一个是promise

35:02.720 --> 35:07.200
这两个对立里边也是放 他不再去 他不是事件循环的一部分

35:07.840 --> 35:10.960
他也不 他也没有什么额外的现成去做他

35:11.200 --> 35:13.200
他这两个不会开启额外的现成的啊

35:13.440 --> 35:16.800
那有时候说我在promise里边去发生一个网络请求

35:17.040 --> 35:20.880
那是网络请求开启的额外现成 跟这个东西本身没有关系

35:21.920 --> 35:24.800
所以说这个东西呢 他我们把它叫做微对立 就是微对立什么意思

35:24.880 --> 35:28.880
微对立什么意思 就是希望马上执行的 立即最快的速度执行

35:29.680 --> 35:31.920
希望他用立即最快的速度在执行

35:32.480 --> 35:36.320
那么这两个对立还有一个优先级 优先级最高的是next to tick

35:36.560 --> 35:40.400
就是说如果说这两个对立都有东西的话 先执行那个是tick再执行promise

35:41.200 --> 35:42.960
好 那么怎么来跟这个事件循环

35:44.000 --> 35:45.840
弄在一起呢 他是这样子的

35:46.400 --> 35:48.880
每一次就是事件循环的时候

35:52.860 --> 35:53.500
事件

35:54.220 --> 35:54.780
循环

35:55.340 --> 35:55.580
每

35:56.540 --> 35:58.140
每往前

36:00.700 --> 36:06.060
推进一步 他不是推进一个阶段 就是你要打算执行一个回调之前 你可以这样理解

36:08.140 --> 36:13.500
事件循环中每次打算执行一个回调之前

36:14.780 --> 36:16.060
首先检查

36:17.340 --> 36:19.900
必须要先清空

36:21.180 --> 36:22.460
next tick

36:23.740 --> 36:25.020
和promise对立

36:26.060 --> 36:27.580
必须要先清空这两个对立

36:28.060 --> 36:28.860
就这么个意思

36:29.900 --> 36:30.780
那什么意思呢

36:31.420 --> 36:32.140
那里看一下

36:33.740 --> 36:37.260
咱们这里又这样子写啊 我这个地方

36:39.100 --> 36:41.660
比方我们这样子写啊 set immediate

36:43.800 --> 36:44.680
输出一个

36:45.880 --> 36:46.360
1

36:47.160 --> 36:51.800
然后呢再用一个 next tick next tick怎么来调用呢 是这样子process next tick

36:52.120 --> 36:54.120
他这里没有直接写个回调就完事了

36:54.120 --> 36:55.960
这个是 tick 输出一个 2

36:56.440 --> 36:58.840
那么这个这个地方呢 输出一个3

37:00.600 --> 37:01.480
啊 输出一个3

37:02.280 --> 37:03.800
啊 然后呢 就是 promise

37:04.840 --> 37:05.480
啊 zin

37:11.280 --> 37:12.720
啊 输出一个4

37:13.760 --> 37:17.360
啊 然后这里边呢 再来一个 process next tick

37:18.960 --> 37:19.680
输出一个5

37:20.400 --> 37:22.560
啊 这里边呢 再来一个 process tick tick

37:23.680 --> 37:26.160
输出一个6

37:27.040 --> 37:29.120
好 问你他输出啥

37:31.950 --> 37:33.150
来吧 我们来分析一下啊

37:33.150 --> 37:35.550
这个东西一定是先输出的 对吧 这是同步

37:35.550 --> 37:38.270
同步运算的啊 他一定是先输出的 所以说一定输出3

37:39.870 --> 37:42.990
那么接下来 我们来看一下 next tick 的对立

37:42.990 --> 37:44.430
就这个对立里面有哪些东西

37:45.230 --> 37:48.270
啊 你看啊 运行这个 immediate 的对立是不是有个1

37:48.910 --> 37:50.910
啊 immediate对立 这个对立里面是不是有个1

37:51.470 --> 37:54.350
好 然后呢 next tick 对立里面是不是要输出一个2

37:55.230 --> 37:57.630
对吧 next tick 对立要输出一个2

37:57.630 --> 37:58.910
但是现在还没有运行对吧

37:58.910 --> 38:00.430
那么这句话自然还没有运行

38:00.510 --> 38:02.190
所以说这个6 不存在的啊

38:02.190 --> 38:03.870
那么现在要等待输出一个2

38:04.270 --> 38:05.550
然后呢接下来 promise

38:06.350 --> 38:07.150
promise result

38:10.590 --> 38:12.270
promise 他立即完成的 promise

38:12.270 --> 38:13.470
这个是不是一个一步的 对吧

38:13.470 --> 38:14.750
他进入 promise 对立

38:14.750 --> 38:15.710
那么要输出一个4

38:17.470 --> 38:18.750
对不对 是吧 输出一个4

38:19.470 --> 38:21.550
好 接下来开始进入事件循环了

38:22.110 --> 38:24.750
事件循环为每次往前推进任何一步

38:24.750 --> 38:27.070
他做的任何一个事情 执行一个回调也好

38:27.070 --> 38:28.750
进入下个阶段也好

38:28.750 --> 38:30.990
首先要做的事情检查这两个对立

38:31.070 --> 38:32.350
一定要把这两个对立清空

38:32.990 --> 38:34.270
因此是不是先输出2

38:34.270 --> 38:35.870
而且他的优先级比较高 对吧

38:35.870 --> 38:36.990
先要把他清空

38:36.990 --> 38:38.110
他是不是先输出2

38:38.110 --> 38:39.390
于是呢我们这里先输出2

38:40.590 --> 38:42.590
好 2 输出完了过后 你看啊

38:42.590 --> 38:43.630
2 一输出完了过后

38:43.630 --> 38:45.630
是不是又往这个 next tick 对立里面

38:45.630 --> 38:47.070
又加了一项 加了一项几

38:47.070 --> 38:47.790
加了一项6

38:48.670 --> 38:49.950
对吧 又加了一项6

38:49.950 --> 38:51.390
那是不是又得输出6了

38:51.390 --> 38:52.750
对吧 所以说2过了 剩6

38:53.550 --> 38:54.750
好 6 一输出完了过后

38:54.750 --> 38:56.830
那个stick 对立是不是清空了

38:57.310 --> 38:58.030
是不是没东西了

38:58.430 --> 39:00.270
那个stick 没东西了嘛 对不对

39:01.230 --> 39:02.670
没东西了过后呢

39:02.670 --> 39:04.350
然后接下来运行什么

39:04.350 --> 39:05.870
运行 promise 的 zin 对吧

39:05.870 --> 39:07.150
输出一个什么 输出一个4

39:08.510 --> 39:09.550
这个4输出了

39:09.550 --> 39:11.630
输出过后他又往一个 next tick 里面加了一项

39:11.630 --> 39:12.430
对吧 加了一项5

39:14.030 --> 39:14.830
所以加了一项5

39:16.030 --> 39:16.430
对不对

39:16.990 --> 39:18.670
这个4 到是输出完了

39:18.670 --> 39:19.550
这个东西又出来了

39:19.550 --> 39:21.230
对吧 又必须要先运行那个 next tick

39:21.230 --> 39:22.590
那个 tick 优先级最高

39:22.590 --> 39:25.230
他要立即尽快地输出执行

39:25.230 --> 39:26.350
好 那么现在又输出5

39:27.310 --> 39:28.510
好 那么5 又输出完了

39:28.510 --> 39:30.030
那这两个对立真的是清空了

39:30.830 --> 39:31.950
真的是清空了 对吧

39:31.950 --> 39:33.950
那么清空完了过后再进入这个阶段

39:33.950 --> 39:36.350
没东西 到破绝段没东西 对吧

39:36.350 --> 39:37.230
在这个东西有 对吧

39:37.230 --> 39:38.670
破绝段结束 到 tick

39:38.670 --> 39:39.790
tick 阶段是不是有个东西

39:39.790 --> 39:40.510
输出1

39:40.510 --> 39:43.630
那么他顺序一定是 326451

39:47.560 --> 39:50.920
load index 326451 对吧

39:50.920 --> 39:52.840
要用这种方式来解题

39:54.040 --> 39:55.000
那么我这里说一下

39:56.280 --> 39:57.640
他为什么搞出来这么多

39:58.520 --> 39:59.640
他为什么搞出来这么多

40:00.280 --> 40:01.080
他是这样子的

40:02.440 --> 40:04.840
首先呢 最早的时候呢 load index

40:04.840 --> 40:07.000
他发现了我要有一个东西啊

40:07.000 --> 40:09.320
我能够让他尽快的去执行异步

40:09.320 --> 40:11.240
而且要尽量的效率高

40:11.800 --> 40:13.400
所以说他首先做出来这么一关呀

40:13.400 --> 40:14.200
set immediate

40:14.920 --> 40:16.840
他就想象成这个set immediate

40:16.840 --> 40:18.760
他在这个破在这个阶段之后

40:19.240 --> 40:20.520
在这个轮型阶段之后

40:20.520 --> 40:22.200
那么轮型阶段他卡的时间比较长

40:22.200 --> 40:22.680
对吧

40:22.680 --> 40:23.880
那么我把它放到之后

40:23.880 --> 40:25.480
是不是执行的速度最快啊

40:25.480 --> 40:26.760
就他这边一卡完了

40:26.760 --> 40:28.200
比方说这边没东西了

40:28.200 --> 40:30.200
突然对的里面有东西

40:30.200 --> 40:31.880
是不是首先会遇到他 对吧

40:31.960 --> 40:33.400
那么尽快的执行他这个东西

40:33.960 --> 40:36.840
而且他的效率是比这个set hat0要高的

40:36.840 --> 40:37.960
所以他首先想到的

40:37.960 --> 40:39.480
想到的是做出来这么一个玩意

40:39.480 --> 40:40.520
他给他命的名字呢

40:40.520 --> 40:41.400
叫做immediate

40:42.120 --> 40:43.320
后来呢发现呢

40:43.320 --> 40:44.920
这个东西还是不行

40:44.920 --> 40:46.440
他还是不能尽快执行

40:46.840 --> 40:48.520
比方说我这个破里

40:48.520 --> 40:49.560
比较突然出现了

40:49.560 --> 40:51.240
我要读了100个文件对吧

40:51.720 --> 40:54.120
差不多有可能50个文件的同时读完了

40:54.120 --> 40:55.480
那么这个地方是不是要坚决

40:55.480 --> 40:56.680
这50个文件的读去

40:57.480 --> 40:58.200
要处理

40:58.200 --> 41:01.080
而处理的过程中又要经过很长的过程

41:01.160 --> 41:02.760
那么这个就一直得不到执行

41:03.400 --> 41:05.480
然后他又想了一个

41:05.480 --> 41:06.680
他发现一个浏览器

41:06.680 --> 41:08.280
浏览器不是一个唯一对列吗

41:08.840 --> 41:10.200
那个时候还没有promise

41:10.200 --> 41:11.720
浏览器不是一个唯一对列吗

41:12.280 --> 41:13.640
哎呀 我这个node怎么没有呢

41:14.120 --> 41:15.160
但是呢这个时候呢

41:15.160 --> 41:16.520
他就遇到一个问题

41:17.080 --> 41:18.920
我倒是可以搞一个唯一对列出来

41:18.920 --> 41:20.520
但是个名字不好命名的

41:21.640 --> 41:23.240
因为他之前也把这个名字用了

41:23.240 --> 41:23.720
对吧

41:23.720 --> 41:24.600
他set immediate

41:24.600 --> 41:25.960
他又想做这个事

41:25.960 --> 41:28.680
我想这个函数呢立即去把他运行了

41:28.760 --> 41:29.640
但是呢

41:29.640 --> 41:31.240
当时他没有去搞唯一对列

41:31.240 --> 41:32.680
后来加了唯一对列过后发现

41:33.320 --> 41:35.800
哎呦自己之前想错了

41:35.800 --> 41:39.880
我才把应该把这个名字命名给那个stake

41:39.880 --> 41:40.920
但是他现在不能改了

41:41.640 --> 41:42.200
你知道啊

41:42.200 --> 41:44.680
一改的话很多的程序都出问题

41:44.680 --> 41:45.560
所以他不能改了

41:45.560 --> 41:46.600
他只能给你换一个名字

41:46.600 --> 41:47.640
换成那个stake

41:47.640 --> 41:48.440
换成这个名字

41:48.440 --> 41:49.160
他就是这么来的

41:49.720 --> 41:51.160
所以说能够尽快的

41:51.160 --> 41:52.760
最快的速度来执行的

41:53.640 --> 41:54.520
一步的就是

41:55.480 --> 41:56.840
尽快就能够做到

41:56.840 --> 41:58.440
尽快来执行的一步函数

41:58.440 --> 41:59.480
那就是那个stake

41:59.480 --> 42:00.520
没有比他更快的了

42:01.160 --> 42:02.040
做任何一件

42:02.040 --> 42:02.760
就是事件循环的

42:02.760 --> 42:04.280
做任何一件事情之前

42:04.280 --> 42:05.480
都要检查他

42:05.480 --> 42:06.920
只要执行任何一个回到函数之前

42:06.920 --> 42:07.560
都要检查他

42:08.840 --> 42:09.960
你看这意思吧

42:09.960 --> 42:11.240
其事是promise

42:11.240 --> 42:12.600
其事才是check

42:12.600 --> 42:13.400
七个在破了之后

42:14.040 --> 42:15.240
它是这么一种逻辑啊

42:15.240 --> 42:15.640
在里面

42:17.400 --> 42:18.840
那么这是我们这几课

42:18.840 --> 42:20.280
讲的这个事件循环

42:20.280 --> 42:20.600
最后呢

42:20.600 --> 42:21.800
我们来看一下这个面试题二

42:21.800 --> 42:22.600
这个面试题二呢

42:22.600 --> 42:23.800
网上也比较多对吧

42:23.800 --> 42:24.760
我们来分析一下

42:24.760 --> 42:26.040
看一下我们用这几课的支持呢

42:26.040 --> 42:27.000
就很容易把解开了

42:29.320 --> 42:29.800
来看一下吧

42:29.800 --> 42:31.000
我们怎么来捋这个东西

42:31.000 --> 42:32.280
这个东西其实也很好捋

42:33.880 --> 42:34.520
首先呢

42:34.520 --> 42:35.640
有这么一个函数对吧

42:35.640 --> 42:36.520
但没有执行

42:36.520 --> 42:37.080
他没有调整他

42:37.080 --> 42:37.880
我就不看了

42:37.880 --> 42:38.920
这个函数没有调整他

42:38.920 --> 42:39.240
不看了

42:39.240 --> 42:41.000
然后肯定是要先运行这个

42:41.000 --> 42:42.200
这是毫无疑问的

42:42.200 --> 42:42.680
先运行

42:42.680 --> 42:43.320
先输出这个

42:44.040 --> 42:44.440
然后呢

42:44.440 --> 42:46.040
这里有个saytimeout0

42:46.040 --> 42:47.400
这里有一个这个东西对吧

42:47.400 --> 42:48.120
那么也就是说

42:48.120 --> 42:49.000
timers对列

42:49.640 --> 42:51.320
timers对列是不是有这么一个东西

42:51.960 --> 42:52.600
timers对列

42:53.560 --> 42:54.280
他就会

42:54.280 --> 42:55.400
0秒过后

42:55.400 --> 42:57.000
0秒过后是不是会输出这么一个东西

42:57.640 --> 42:58.360
0秒过后

42:58.520 --> 42:59.080
会输出他

43:00.920 --> 43:01.320
然后呢

43:01.320 --> 43:02.360
又加了一个

43:02.360 --> 43:03.160
3

43:03.160 --> 43:04.360
3毫秒过后是不是会输出他

43:06.520 --> 43:07.960
3毫秒过后是不是会输出他

43:09.560 --> 43:10.520
对不对

43:10.520 --> 43:11.000
又来啊

43:12.040 --> 43:13.080
一面这个对列

43:13.080 --> 43:14.040
就切个是对列

43:14.040 --> 43:15.080
那么是不是会输出他

43:16.680 --> 43:17.400
切个是对列

43:18.600 --> 43:19.480
以后要注定的时候

43:19.480 --> 43:21.240
不要在脑袋里面想要想云的

43:21.240 --> 43:22.680
一定要把信用这种方式

43:22.680 --> 43:23.480
把它写出来

43:23.480 --> 43:24.440
或者画个头都行

43:25.080 --> 43:26.280
切个是对列是不是有他了

43:26.280 --> 43:27.320
肯定有他了对吧

43:27.400 --> 43:29.000
但timers对列不一定有他

43:29.000 --> 43:30.520
timers对列不一定有这两个

43:30.520 --> 43:31.480
因为他要等0秒

43:32.120 --> 43:33.000
前面写一个吧

43:33.000 --> 43:33.800
0秒过后

43:33.800 --> 43:34.520
0秒过后

43:35.080 --> 43:36.600
0秒过后就是1秒过后

43:36.600 --> 43:37.240
1毫秒过后

43:37.240 --> 43:37.880
最小为1

43:38.520 --> 43:39.320
3毫秒过后

43:40.600 --> 43:41.400
有这个东西

43:41.400 --> 43:42.520
进入timers对列

43:44.280 --> 43:44.920
然后呢

43:44.920 --> 43:47.080
是process next take

43:47.080 --> 43:47.400
对吧

43:47.400 --> 43:48.120
next take

43:48.120 --> 43:48.440
好了

43:48.440 --> 43:50.600
那么就是这个世界循环之外了

43:51.640 --> 43:52.360
next takes

43:53.400 --> 43:54.200
有个什么呢

43:54.200 --> 43:54.920
有个next take

43:56.520 --> 43:56.920
对吧

43:57.400 --> 43:57.880
然后呢

43:57.880 --> 43:59.320
现在运行而sync1

43:59.320 --> 43:59.640
来吧

43:59.640 --> 44:00.440
而sync1运行

44:00.440 --> 44:01.560
那么这个是同步代码

44:01.560 --> 44:01.720
对吧

44:01.720 --> 44:02.360
这个毫不疑问

44:02.360 --> 44:03.720
同步代码的马上就运行

44:04.280 --> 44:04.440
好

44:04.440 --> 44:05.240
那么这要等待

44:05.240 --> 44:06.280
等待后边是不是在

44:06.280 --> 44:07.800
相当于是在任后边了

44:07.800 --> 44:09.960
任后边的是不是相当于是promise对列

44:09.960 --> 44:10.360
对吧

44:10.360 --> 44:11.960
promises对列

44:12.840 --> 44:13.560
那么这里边

44:14.360 --> 44:15.240
他有这个东西

44:15.240 --> 44:15.800
要等着他

44:16.280 --> 44:17.080
是不是要等他

44:17.080 --> 44:17.240
好

44:17.240 --> 44:18.920
那么现在把这个喊说运行完了

44:18.920 --> 44:19.800
这个喊说运行完了过后

44:19.800 --> 44:20.840
又是六一个promise

44:20.840 --> 44:21.720
那么这个是同步代码

44:21.720 --> 44:21.960
对吧

44:21.960 --> 44:23.000
同步代码马上要运行

44:23.000 --> 44:23.880
那个毫问的

44:24.600 --> 44:25.480
这都是毫无疑问的

44:26.360 --> 44:27.000
promise2

44:28.360 --> 44:28.760
是吧

44:28.760 --> 44:29.320
要运行

44:29.320 --> 44:30.040
运行过后

44:30.040 --> 44:31.480
他已经把它变成以绝了

44:31.480 --> 44:31.720
对吧

44:31.720 --> 44:32.280
完成了

44:32.280 --> 44:34.040
然后任这里边是不是进入

44:34.040 --> 44:34.920
promise对列

44:34.920 --> 44:35.160
对吧

44:35.160 --> 44:35.720
promise3

44:37.080 --> 44:38.200
promise3

44:38.200 --> 44:38.520
对不对

44:39.640 --> 44:40.360
哦这里

44:40.360 --> 44:41.720
还要运行个sync2

44:41.720 --> 44:43.160
然后这里还要运行个sync2

44:43.800 --> 44:45.000
这里在start了之后

44:45.000 --> 44:46.200
还要运行个sync2

44:46.760 --> 44:47.640
sync2

44:48.120 --> 44:48.760
这里忘了

44:50.200 --> 44:50.440
好

44:51.400 --> 44:51.880
没问题吧

44:52.760 --> 44:53.000
好

44:53.000 --> 44:53.640
那么现在呢

44:54.680 --> 44:55.240
讲完了了

44:55.240 --> 44:56.600
promise3了对吧

44:56.600 --> 44:57.880
这里进入这个promise对列

44:57.880 --> 44:58.600
然后最后呢

44:58.600 --> 45:00.360
同步代码输出scripts end

45:01.560 --> 45:02.040
是吧

45:02.040 --> 45:02.920
就是说是这样子

45:02.920 --> 45:03.160
好

45:03.160 --> 45:04.920
同步现在是不是同步代码执行完了

45:04.920 --> 45:06.120
接下来查看对列了

45:06.120 --> 45:07.800
接下来进入世界循环了

45:07.800 --> 45:08.920
世界循环先检查它

45:08.920 --> 45:09.720
先把它清空

45:09.720 --> 45:10.440
这毫无疑问的

45:11.000 --> 45:11.800
它要清空

45:11.800 --> 45:12.520
它清空了

45:13.240 --> 45:13.960
然后干嘛呢

45:13.960 --> 45:15.080
然后把promise清空

45:16.040 --> 45:17.240
promise要清空

45:17.240 --> 45:18.680
promise清空了

45:18.680 --> 45:19.720
那么最后几个

45:20.520 --> 45:21.720
那么现在是不是可以往

45:21.720 --> 45:22.680
走世界循环了

45:22.760 --> 45:24.120
times对列拿出来看

45:24.120 --> 45:24.920
那么这个时候呢

45:24.920 --> 45:25.960
就有一些分歧了

45:25.960 --> 45:26.520
这个东西

45:26.520 --> 45:29.080
这个面子情况是没有绝对准确答案的

45:29.080 --> 45:30.520
我不知道这个面子观出题

45:30.520 --> 45:32.520
出题的面子观可能自己都没有搞清楚

45:33.080 --> 45:34.680
这个地方是没有准确答案的

45:35.160 --> 45:36.920
因为这里说不准了

45:37.320 --> 45:38.840
鬼知道它这个1毫秒倒没倒

45:38.840 --> 45:41.000
因为不知道这个程序有没有运行1毫秒

45:41.000 --> 45:42.840
有时候说说这么多应该运行的

45:42.840 --> 45:43.160
不一定

45:43.800 --> 45:44.360
不一定的

45:44.840 --> 45:46.120
所以说这里呢就说不准了

45:46.600 --> 45:49.000
那如果说你觉得它已经过了3毫秒了

45:49.000 --> 45:50.440
那么这两个东西吃不到对列了

45:51.320 --> 45:53.560
后面就应该是0

45:54.600 --> 45:54.920
3

45:56.840 --> 45:57.640
set immediate

45:57.640 --> 45:58.040
对吧

45:58.040 --> 45:58.760
就应该是这个

45:59.320 --> 45:59.960
对不对

45:59.960 --> 46:00.920
但是如果说这里呢

46:00.920 --> 46:01.960
还没有告1毫秒

46:01.960 --> 46:02.760
那么是不是1

46:02.760 --> 46:03.720
set immediate在前

46:03.720 --> 46:04.440
这说不准的

46:04.440 --> 46:06.120
也有可能在中间

46:06.120 --> 46:06.280
对吧

46:06.280 --> 46:07.000
这都说不准的

46:07.000 --> 46:07.640
这三个数据

46:08.680 --> 46:10.120
零比一定在3前面

46:10.120 --> 46:11.080
这是一定的

46:11.080 --> 46:11.400
但是呢

46:11.400 --> 46:12.360
这个东西不知道在哪

46:12.360 --> 46:13.480
这个东西不知道在哪

46:13.480 --> 46:14.120
有可能在这

46:15.320 --> 46:15.960
也有可能在这

46:16.760 --> 46:17.480
也有可能在这

46:17.480 --> 46:18.360
说不准的

46:18.920 --> 46:20.280
不知道这个程序运行的数字间

46:20.360 --> 46:21.720
说后三个是说不准的

46:21.720 --> 46:22.600
前面是一定的

46:23.240 --> 46:24.040
那咱们来看一下

46:26.250 --> 46:27.050
面是第2

46:31.450 --> 46:31.770
好

46:31.770 --> 46:32.410
我们来看一下

46:32.570 --> 46:34.010
我们的结果这么准确

46:35.290 --> 46:35.930
stars

46:35.930 --> 46:36.410
a single e

46:36.410 --> 46:36.890
stars

46:36.890 --> 46:37.770
a single r

46:37.770 --> 46:38.410
promise e

46:38.410 --> 46:39.210
promise r

46:39.210 --> 46:40.170
scripts and

46:40.170 --> 46:40.810
next take

46:41.290 --> 46:42.010
a single e

46:42.010 --> 46:42.330
and

46:42.970 --> 46:43.770
promise 3

46:44.330 --> 46:45.370
set timeout to 0

46:45.370 --> 46:45.850
3

46:46.010 --> 46:46.490
images

46:46.490 --> 46:46.810
对吧

46:46.810 --> 46:47.610
我现在运气好了

46:47.610 --> 46:47.930
对吧

46:47.930 --> 46:49.050
images在最后

46:49.050 --> 46:49.770
那这不一定的

46:49.770 --> 46:51.130
这个images它不一定的

46:51.690 --> 46:52.250
多来几次

46:53.850 --> 46:55.050
只是我们这个代码呢

46:55.130 --> 46:56.250
可能运行的时间

46:56.890 --> 46:57.850
运行的时间呢

46:58.410 --> 47:00.250
比较稍微稍微慢一点

47:00.570 --> 47:01.210
稍微慢一点

47:01.210 --> 47:01.610
有三

47:01.610 --> 47:03.290
就是你至少有三毫秒了

47:03.930 --> 47:05.050
至少有这个输出的时间

47:05.050 --> 47:05.930
至少有三毫秒了

47:05.930 --> 47:07.450
所以说我们这里的看到最后的

47:07.450 --> 47:08.570
但是实际上是不一定的

47:08.570 --> 47:10.250
这个还跟机器的配置有关

47:10.250 --> 47:11.610
不能说百分之百确定

47:11.610 --> 47:12.970
我的电脑上百分之百确定

47:12.970 --> 47:14.570
都不能在别的电脑上百分之百确定

47:14.570 --> 47:14.810
对吧

47:15.610 --> 47:17.210
最后只有这几个实际上是不一定的

47:18.010 --> 47:18.250
OK

47:18.250 --> 47:19.850
那么这里就是整个的

47:20.730 --> 47:22.410
事件循环的

47:22.410 --> 47:23.930
漏的事件循环的知识

47:23.930 --> 47:24.890
把这些东西掌握了

47:24.890 --> 47:26.570
你做面试题就肯定是没问题了

47:26.570 --> 47:27.050
好吧

47:27.050 --> 47:28.570
这是关于最结构的东西

47:29.290 --> 47:30.490
主要是个破综阶段

47:30.490 --> 47:31.370
要理解清楚

