WEBVTT

00:00.500 --> 00:03.500
好 这节课咱们来说一说这个net 模块

00:04.500 --> 00:11.500
嗯 为什么讲这个模块呢 嗯 这个模块呢 其实里面以后的工作中呢 不是那么容易遇到啊 也不太会使用

00:12.500 --> 00:21.700
嗯 主要的目的是为了我们下节课讲 attp 模块啊 这是我们的主要目的 而且呢 通过讲这个net 模块呢

00:23.300 --> 00:29.060
你可以可以对以前的网络请求啊 特别是 attp 请求有一个更加深刻的认识

00:29.860 --> 00:33.300
好 咱们来看一下啊 所以我们来回顾一下 attp 请求

00:34.500 --> 00:42.420
怎么请求呢 它分成两种模式对吧 一个是普通模式就是最传统的版本啊 我们来看一下 传统的版本是怎么样子的

00:43.940 --> 00:53.500
咱们的客户端去请求服务器 对吧 然后两两个就不要我要我要找你帮忙了 对吧 你要给我一些东西 那么这个时候呢 他们之间要建议连接

00:54.220 --> 01:01.340
那建议连接之前会进行三次握手 对吧 你在吗 我在 你在吗 我也在

01:02.220 --> 01:14.420
会进行三次握手 那么这三次握手完了过后连接就建立了 建立了连接之后 那么这个时候呢 客户端采许发送一个请求到服务器 服务器给客户端完成一个享用

01:15.220 --> 01:28.500
然后完成了享用之后 通过四次 应该叫四次挥手啊 我这里写错了啊 你们自己知道就行了 通过四次挥手 那么就把连接关闭了 对吧 这是我们最传统的这种模式

01:29.740 --> 01:38.900
我们平时用阿尼克斯请求向服务器发送什么消息头啊 发送那个消息体在哪里 是不是在这里 对吧 都已经完成了三次握手了

01:39.460 --> 01:51.420
啊啊 流量器在内部帮你完成了三次握手啊 已经把这个事情给你做了 你不用管了 实际上是操作系统做了啊 操作系统就已经帮你做了 你不用管这个三次握手 四次挥手 你只你要关心的只是去

01:51.980 --> 01:55.580
请求他 然后呢 他完成享用 然后自动的连接关闭

01:56.620 --> 01:57.500
好 这是这种模式

01:58.380 --> 02:05.220
还有一种模式呢 叫长连接模式 长连接模式是什么呢 长连接模式是这样子 我给大家随便请求一个网验

02:07.920 --> 02:13.120
600度吧 咱们来看一下吧 长连接模式是怎么回事 我们看一下这拳刷新一下

02:14.800 --> 02:24.080
你看啊 我们请求这个页面的时候会产生很多很多的请求 对吧 因为这个页面有很多的图片啊 事业这些啊 介事支援都需要去请求 产生很多的请求

02:24.840 --> 02:32.840
那如果说用这种模式啊 用一开始这种模式 那么我们请求一个页面 是不是有很多次握手以及挥手 对吧

02:33.360 --> 02:39.520
那么这样子呢 会造成那个响应时间的降低啊 会浪费这个传输

02:40.640 --> 02:48.000
那么我们就完全可以这样子 在一个非常短的时间内 我能不能就共用一个请求呢

02:48.720 --> 02:52.880
可以的 你看一下 我们请求百度的时候 我们客户端给他传了一个什么呢

02:53.680 --> 02:54.360
看一下客户端

02:55.360 --> 03:02.760
所以给他传了一个抗旅行消息头 那个消息头放哪的 是放这的 对吧 放这个请求里边的 对吧 请求的时候 给他传一个

03:02.960 --> 03:08.560
消息头过去 好 那么他这边给你想应了解 就是keep your life keep your life什么意思呢 就表示

03:08.960 --> 03:15.160
我希望啊 服务器你不要那么忙着去挂这个电话 你可以把每一次请求就是你喊一声

03:15.960 --> 03:22.680
啊 就是床房建议连接之后 你喊一声他给你回忆去 你喊一声回忆去 喊一声就是请求回忆去就是响应

03:24.600 --> 03:27.720
那么这个kiss不来为什么意思呢 就是客户端告诉服务器

03:28.360 --> 03:37.720
你你不要那么快的挂电话 你先别忙 你再听一会我也可能还有话说 对吧 我还有话说 你不要着急挂 不然的话服务器刷一下就挂了

03:38.880 --> 03:46.560
因此呢 给他传这么一个connection keep alive 什么意思吧 好 然后呢 服务器这边啊 risk months这边这边服务器这边呢

03:47.600 --> 03:57.240
他给他回了一个啊 他说我不挂 你放心 我不挂 我也给你传一个connection keep alive啊 这都这些都需要服务器来处理的 那么服务器怎么处理 我们今天就会说

03:57.720 --> 04:09.960
你就看到今天听到这些客户 你就知道了啊 我原来这个东西是需要服务器处理的 如果说服务器不管他 我直接挂电话 那双方就挂了啊 客户端那边没有响应了 对吧 他直接挂了 要重新要重新拨打号码了

04:10.960 --> 04:17.920
但是服务器呢 一般来说啊 绝大部分服务器可以说99.9%服务器 他只要能看到看到这个消息头之后

04:18.360 --> 04:24.480
他都不会挂电话啊 他会等一会 等一会你那边确实没有什么话说了 服务器就把电话挂了

04:25.320 --> 04:33.280
还有一种情况呢 就是客户端等了服务器那边等了一会 服务器什么都没给我了 客户端就把电话挂了 客户端或者客户端发现了

04:34.080 --> 04:44.040
我确实没有什么东西要跟你说了 没有什么说的了 那客户端这里主动挂了 主动挂电话呢 有可能是客户端发出的 也有可能是服务器发出的 都有可能的

04:44.960 --> 04:52.000
好 那么这种情况呢 就是常链接 keep alive 传一个消息头过去 那么有常链接模式呢 是下面这个模式

04:53.000 --> 04:59.200
就是我们还是一样啊 三次握手 四次挥手啊 都一样 这个挥手就是挂电话啊 握手呢就是建立连接不好

05:00.160 --> 05:09.440
那么中间这个部分呢 就是传输数据了 各种数据传输 那么这里这个过程呢 由于是常链接模式 客户端就可以请求多次啊 在同一个连接里边

05:10.000 --> 05:16.680
请求页面 给了我页面 页面里边有很多图片 用同样的请求去请求图片 然后再得到响应

05:17.160 --> 05:24.320
要你说 这些事情呢 都是操作系统和流量器帮你处理好的 你都不用管啊 你就每次用 每次去请求就完事了

05:25.080 --> 05:27.960
对吧 这是我们之前学的atb请求

05:29.240 --> 05:31.000
好 那么现在呢 我们来看一下啊

05:32.280 --> 05:39.560
我们这几个要学的内存模块是在干什么 其实我们这里呢 都还没有完全画出atb请求里边的东西

05:40.520 --> 05:47.400
啊 其实我只画了个简单的减图 因为我们知道atb请求呢 是建立在哪呢 建立在tcp ip协议上的 对吧

05:47.400 --> 05:50.680
atb协议是建立在tcp ip 就是这种传输性协议上的

05:51.160 --> 05:58.040
那么在这个协议之上呢 这个其实三次握手和四次挥手 是不是tcp ip协议啊 是这个协议搞定的事情

05:58.760 --> 06:05.480
atb请求只是说 我这一部分请求我该怎么来发数据 我的数据格式是什么 是这么个意思啊 这么个意思

06:05.960 --> 06:07.480
好 那么这里让我们来看一下

06:08.360 --> 06:14.600
回到这里 我们内存模块能干嘛 我们这一块学的内存模块 内存模干嘛 那时候就是一个通信模块

06:15.000 --> 06:22.200
它可以传输数据的啊 利用它呢 我们可以实现两种功能 一种是进城间的通信叫ipc

06:23.000 --> 06:28.520
啊 那么这个进城间的东西是怎么了 因为我们知道操作系统上面运行的时候呢 会产生很多的进程

06:29.080 --> 06:35.400
那么一个微信一个qq 这些呢 都是进城 对吧 进城之间要通信的 进城间我都是说

06:35.800 --> 06:42.920
他的资源呢 是隔离的 是独立的啊 互不干擾 但是他们以之间也可以通信 只要满足某种协议也可以通信

06:43.160 --> 06:45.720
那么他们之间通信方式呢 他的协议叫做ipc

06:47.160 --> 06:51.160
嗯 只不过了 这个东西了解一下就行了啊 我们毕竟不是后端开发员员

06:51.720 --> 06:56.680
这个东西是后端开发员员要学的啊 我们不用去学啊 前端呢 不用去搞定这个事啊

06:57.000 --> 06:59.480
前端我们要学的重点是网络通信

07:00.120 --> 07:05.960
就是建立在tcp ip 协议上的进行通信 当然这个最常见的协议是吗 就是 addp

07:06.840 --> 07:14.040
那么这几个我们用那种模块呢 他实际上是tcp ip 就是比比比那个 addp 更加底层的一个协议

07:14.760 --> 07:18.040
他就怎么呢 建立连接 三次三次握手 连接过后

07:18.840 --> 07:25.880
呃 两双方都可以互传数据 我的客户端可以发送任意格式的数据到服务器

07:27.080 --> 07:31.080
服务器呢 也可以主动的发送任意数据到客户端

07:31.960 --> 07:38.680
这个双方是畅同的 就相当于是两者之间建立了一个通道 双方都可以互发数据的 这个东西跟 addp 协议就不一样

07:39.480 --> 07:44.760
addp 协议是不是我请求完了你想应 对吧 下一次要通信是不是我又得从请求开始

07:45.960 --> 07:52.600
哎 tcp ip 协议不是哦 tcp ip 协议是我请求我给了你数据啊通过通道我给了你数据

07:53.320 --> 07:54.120
你可以不回握

07:54.840 --> 08:03.720
也可以呢 过一段时间再回握也可以回握两次对吧 那这个 addp 协议是不是专办不到对吧 服务器不会响应两次对吧 一次请求响应一次

08:03.880 --> 08:06.520
你就请求响应一次 长连接的无非就是说

08:07.320 --> 08:12.280
我就共用一个连接啊 少一次握手 少少一点握手 少一点挥手

08:13.000 --> 08:17.320
只是其中一个作用 但是呢始终都是一次请求一次连接 就是他们

08:18.040 --> 08:26.120
之前是还要就是商量了 商量好了是用这种方式来进行交互的啊 但是 tcp ip 协议他不管这个东西你可以发任何数据给我

08:26.600 --> 08:33.160
我也可以回任何数据给你 我什么时候想回力就回力 想回力多少次就回力多少次啊 你什么时候想给我发就给我发

08:33.880 --> 08:39.160
除非有一方挂了电话啊 比方客户端那边把电话一挂啊服务器啊你挂了我就挂了呗

08:40.120 --> 08:46.840
或者是服务器那边主动把电话一挂那客户端那边啊你挂了我就挂了呗啊就这么个意思啊 事实挥手挂了过了专门你把电话挂了

08:47.800 --> 08:52.600
好 这是内存模块啊 他能够实现最比较底层的啊 tcp ip 协议

08:53.400 --> 08:57.960
好 那咱们来看一下啊 首先看一下我们的怎么来创建一个客户端 什么客户端

08:58.840 --> 09:03.160
就是我在load里边主动去发送一个请求到一个服务器

09:04.120 --> 09:08.200
啊 就是客户端 那客户端怎么创建的 非常简单啊 咱们这里写一下

09:09.560 --> 09:10.760
首先导入这个内存模块

09:13.210 --> 09:22.330
啊 导入这个内存模块 然后呢 这里边通过这个函数啊 通过这个函数就能够创建一个客户端啊 咱们把它复制一下啊

09:23.050 --> 09:25.930
那是create connection 创建一个连接

09:26.730 --> 09:34.890
第一个呢 他要写个配置对象啊 第二个呢 是一个监听函数 监听函数就是我们完成连接之后啊 他要做的事情

09:35.210 --> 09:38.650
那我们这里的先不管这个监听嘛 我们第一个呢 又写个配置对象

09:39.450 --> 09:43.290
这个配置对象写什么呢 这里边有两个重要的配置 一个是host

09:44.090 --> 09:52.090
就是你要连接到的主机啊 比方说我们这里连接到哪呢 咱们杜伊克堂啊 杜伊克雕QQ雕康 试试这个地址啊

09:52.890 --> 09:54.650
看一下啊 看一下试过这个地址

09:56.250 --> 09:56.650
删心

09:57.930 --> 10:02.170
哎 不是 是这个地址啊 是这个地址啊 咱们复制一下啊

10:02.890 --> 10:08.490
你注意啊 你这里就不要写协议了 因为我们现在使用的是tcp ip啊 只要双方能连接就行了

10:08.810 --> 10:13.130
连接完了过后我只要我能够喘给你任何东西啊 你也可以给我回复任何东西

10:13.690 --> 10:17.050
不一定是怎么消息头消息题 无所谓 你给我回个hollowade都可以

10:18.330 --> 10:22.250
那么这里呢 我们跟连接到这个主机 然后还有一个配置呢 就是port

10:23.530 --> 10:28.250
就是短口号 别说短口号不就是默认80吗 那是attp协议

10:28.890 --> 10:33.050
不是tcp ip协议 aptp协议tcp ip协议里面 短口号你不写了就没有

10:33.610 --> 10:36.170
那是肯定不行的啊 那么咱们给大家写上80

10:36.810 --> 10:42.970
80短口 那么这样子呢 我就创建了好了一个连接啊 我们在这里呢 后边写上一个毁掉函数

10:43.610 --> 10:46.330
表示连接成功啊 连接成功

10:47.450 --> 10:52.330
保存啊 接下来我们来看一下啊 我们来运行看一下 load index

10:53.290 --> 11:00.490
这么连接成功 对吧 说明了我们这个请求是不是发送到服务器了 双方跟服务器之间建立连接了

11:02.090 --> 11:04.810
好 那么这个时候呢 我们这里停止啊

11:06.570 --> 11:12.810
好 那么这个时候呢 我们在这 它会返回一个对象啊 这个函数呢 它会返回一个对象 这个对象是什么呢

11:12.890 --> 11:14.730
这个对象呢 我们通常把它叫做socket

11:15.530 --> 11:17.610
啊 这个socket就是什么玩意呢 咱们来看一下

11:18.970 --> 11:22.170
socket啊 这个socket是什么东西呢 socket呢 你可以认为

11:22.490 --> 11:28.170
它就是一个特殊的文件 是操作系统里面特殊的一个文件

11:28.970 --> 11:34.570
我们知道文件里面我们是不是可以通过流来读取它 通过流向文件里面写入内容

11:35.210 --> 11:37.210
只不过呢 这个文件呢比较特殊

11:38.170 --> 11:39.850
怎么个特殊法呢 它是

11:40.570 --> 11:46.010
负责向网络端口 就是我们的那个网卡输送内容

11:46.730 --> 11:55.370
当我们跟远程主机建立好连接之后呢 在我们这一端 就是我们这是客户端 对吧 在客户端这边跟远程主机建立好连接

11:55.690 --> 12:02.650
远程主机那边呢 怎么处理的 那是他的事 跟我们没关系 反正我这里呢就建立好连接之后 我会得到一个小文件啊 叫socket

12:03.610 --> 12:05.530
我往这个文件里面写内容

12:06.330 --> 12:10.810
哎 那么它就会把这个内容呢 通过这个连接 传输到远程主机

12:11.690 --> 12:17.210
同样的 远程主机给我们回了一个内容 我一通过可以读这个文件 能够读到远程

12:17.690 --> 12:22.730
主机给我回的内容 都是一个非常特殊的文件啊 他跟远 他跟网卡是关联在一起的

12:23.450 --> 12:26.330
对吧 所以说呢 通过这个特点 我们也知道

12:26.890 --> 12:31.290
这个socket啊 在我们load里面应该就表现为一个双公流 什么叫双公流

12:31.610 --> 12:35.770
可以往里面写内容 写内容 它就它就通过这个连接发动到远程主机了 对吧

12:36.330 --> 12:41.290
也可以通过远程 也可以读内容 读内容是什么 就远程主机给我们内容过后 你可以通过读

12:41.530 --> 12:47.930
读这个流把它读出来 在load里面它是个对象 实际上它是跟某一个socket的文件连接在一起的

12:49.050 --> 12:55.290
所以说我们通过像流写入内容 发送数据 监听流的内容 获取数据 对吧 就这么简单

12:55.850 --> 13:01.210
就这么简单 好 因此呢 后续的操作啊 我们就跟流是一样的操作了

13:01.690 --> 13:05.130
所以我们之前为什么要学习流呢 对不对 咱们来看一下啊

13:06.090 --> 13:12.970
服务器给我们响应什么结果呢 咱们来看一下 首先我们要向服务器 我们来吧sockets

13:13.530 --> 13:19.610
嗯 对吧 我们这个是个流嘛 读去流里边是不是有一个什么data对吧

13:20.170 --> 13:26.010
创歌 咱们来输出一下啊 这个创歌是个二镜子啊 to stream 把它转换成UTF-8

13:27.050 --> 13:32.410
好 我们来看一下服务器给我们什么内容呢 这是大家前面写个字不说啊

13:33.130 --> 13:37.290
来自服务器的消息 看他给我们什么东西

13:38.810 --> 13:43.370
运行 延成功 因为发现服务器没有给我任何东西

13:44.330 --> 13:47.770
这是怎么回事呢 我们再回过一下 adb 协议

13:48.730 --> 13:54.970
adb 协议 双方 双方三次握手完了过后 那么这里不用去管三次握手啊 他内部自动完成的

13:55.930 --> 14:01.610
三次握手完了过后 adb 协议里边 是不是要等客户多安给服务器发送消息啊 发送请求

14:02.010 --> 14:08.810
对吧 这个我们只是建立连接 连接通道建立的 但是呢客户多安并没有给服务器发送任何请求

14:09.610 --> 14:11.690
明白的意思吧 因此呢

14:12.730 --> 14:17.530
所以说了这个 这个服务器也不会给我们回应任何消息

14:18.170 --> 14:19.370
啊 所以说这个地方呢

14:20.730 --> 14:24.090
嗯 他不会来自服务器有任何消息给我们发过来

14:25.050 --> 14:31.050
因此我们要怎么办呢 我们是不是要往这个榴里边写入一些内容 对吧 咱们来往榴里边写入一些内容

14:32.810 --> 14:41.610
啊 right 往里边写入 写入什么呢 可以是一个字不串啊 也可以是呢一个buffer啊 就是UTF8二位

14:41.850 --> 14:43.930
好 那么这里呢 我们可以使用个字不串嘛

14:45.050 --> 14:52.810
相服务器写入个啥呢 写入一个你好啊 我们向腾讯的这个课堂这个服务器给他发一个消息你好

14:53.770 --> 14:57.690
好 来吧 我们看服务器怎么回我 你直接把服务器搞懵逼了

14:59.370 --> 14:59.530
啊

15:01.450 --> 15:03.450
来来来 这服务器的消息是这个

15:04.090 --> 15:10.730
看没 是不是这个 这个是啥啊 这个就是我们的atb协议规定的消息格式

15:11.610 --> 15:15.050
他根本想用了个啥呀 400 by the request

15:15.530 --> 15:19.770
这个是不是 这是不是要请求 呃 想用行 这是不是想用头

15:20.250 --> 15:27.450
这个是不是想应题 对吧 哎 通过这个例子是不是可以非常非常完整的看到服务器给我们想应的

15:27.610 --> 15:29.690
其实就是这么一个字不串

15:30.490 --> 15:33.450
就是这么一个字不串啊 没有什么特别的

15:34.410 --> 15:36.090
因此只是我们平时用什么一些

15:36.730 --> 15:42.890
接query啊 啊一个小时啊 这些东西 他把他把这个字不说解析完了 变成一个一个对象

15:42.970 --> 15:47.130
然后然后帮你进行操作啊 实际上就本质就是一个字不说服务器给我想应这个

15:47.850 --> 15:50.810
那服务器为什么给我想一个400 by the request呢

15:51.290 --> 15:56.090
因为我们给他发的字不串 是不是一个atma字不串 是不是一个那个

15:56.730 --> 15:59.850
ttp协 满足actp协议的字不串 不是

16:01.290 --> 16:04.650
actp协议的字不串是什么呢 是不是有这么一个

16:05.850 --> 16:09.370
请求行 对吧 请求行完了过后是什么呢

16:10.090 --> 16:14.570
啊 换行注意啊 这里不要用antf见了啊 不然多了空格 他识别不了的换行

16:15.050 --> 16:18.730
然后呢 就是啊 请求头 对吧 请求

16:19.530 --> 16:27.130
头 然后呢 换两行 对吧 然后呢 这是请求体啊get请求就没有请求体 对吧 请求体

16:28.090 --> 16:34.330
对不对 那么我问大家那么这是 这才是一个正确的adp协议的格式 但是我刚才发了

16:34.330 --> 16:36.970
你是一个理好 是不是一个正确的adp协议

16:37.450 --> 16:42.410
格式 不是 那么不是的话服务器完全理解不了 他就告诉你by the request

16:43.050 --> 16:49.850
这是一个错误的请求啊 这个请求是有问题的 一个请求根本就识别不了的 不是adp协议

16:50.250 --> 16:55.850
因为毕竟我们发了这个服务器呢 他是他是只能认adp协议的啊 不认其他协议

16:56.890 --> 17:01.530
那如果说有些东西就想了 那我们问大家一个问题啊 如果说有个服务器他不是

17:01.930 --> 17:04.490
adp协议 他就是一个普通的adp协议

17:05.370 --> 17:07.370
那么他这个能不能认识我们的D号

17:08.010 --> 17:10.410
那就肯定可以认识了啊 肯定可以认识了

17:10.730 --> 17:17.370
只不过能勿使那服务器销连接建立的 我消息也发过去了 他他不就他不管你啊 说这个请求格式有问题

17:17.770 --> 17:22.810
就是我们通过今天这节课啊 咱们把adp协议好好梳理一下

17:24.170 --> 17:26.490
好 那么这里呢 我再问大家一个问题

17:27.930 --> 17:33.130
主要这个问题非常非常考验你的基本功以及对你对网络通信的理解

17:33.850 --> 17:36.650
我 我这个地方

17:37.290 --> 17:40.490
怎么来表示get车请求和posed的请求呢

17:42.650 --> 17:45.130
哎 你们平时用x小时 用废起api

17:45.850 --> 17:52.170
用那个什么rgx不都可以写get车请求啊 什么method的啊get车请求posed请求

17:52.730 --> 17:53.930
怎么来表示呢 你们猜

17:54.570 --> 17:55.290
怎么来表示

17:56.730 --> 18:03.290
啊 有人肯定会想 应该是这个socket车里边有一个method的啊 有这么一个属性来表示get车

18:04.250 --> 18:05.690
posed 是这样吗

18:06.410 --> 18:06.890
不是的

18:07.850 --> 18:13.130
get和posed是tattp协议搞出来的 不是tcpip协议的

18:14.170 --> 18:17.370
是attp协议 在attpip协议之上

18:18.250 --> 18:21.610
说我在发送消息的时候啊

18:22.650 --> 18:26.650
还记得吗 我们看打开posedman 随便找一个 比如说我们就这个

18:27.210 --> 18:30.490
读一 这里不是有get吗 pocket请求posed请求对吧

18:30.890 --> 18:34.650
posedman大家可以安装一下啊 我不知道大家有没有安装posedman

18:35.450 --> 18:38.890
你们去那个百度里面去收一下posedman

18:39.130 --> 18:44.490
它是专门的用来测试啊 就是发送一个请求到任何服务器 并且拿到服务器的响应结果

18:44.810 --> 18:48.250
只是这么一个工具 非常好用的啊 去下载一下 非常好用啊

18:48.490 --> 18:51.930
网上有很多教程啊 没有什么好教程可以讲的啊 就是

18:52.570 --> 18:56.090
这里写地址啊 这里写你的请求方法啊 这里可以加header

18:57.050 --> 19:03.130
可以写body 对吧 可以写地址栏参数啊 体败率都可以写 非常简单的啊 咱们网个度1

19:03.930 --> 19:09.450
地儿edu 地儿q 地儿qq 地儿con 去发送一个消息 send

19:10.810 --> 19:15.130
啊 你看一下 我们这里点一下code 看一下我们的请求 我们的get在哪

19:16.330 --> 19:21.770
get是不是在请求行里边啊 因此呢 真实的最底层的情况是这样子的

19:22.090 --> 19:26.330
我给他发送这个连接间谍好了之后 我们可以互相传输消息了 对吧

19:26.490 --> 19:31.290
那么服务器等着我 等着我聊干嘛啊 因为是atcp协议嘛 所以说他不会主动给我们传的

19:31.530 --> 19:36.490
实际上他是可以给我们主动传的 但他不会只有主动给我们传 因为他是在attp协议下面

19:36.970 --> 19:40.330
而attp ip 协议下面是可以互传的 我们再来好好看一下这个图啊

19:41.770 --> 19:49.210
一定要搞清楚啊 就是我们连接一旦建立过后 随便谁 客户端可以主动给服务器传 服务器可以主动给客户端传 传多次都可以

19:50.170 --> 19:58.010
但是这是attp ip协议 但是attp协议就不是这样子了 attp协议就是只能说你给我传一个 我给你想一个 我就等着你

19:58.490 --> 20:02.250
你给我传一个 我给想一个 这是另外一个协议 他建立在attp ip协议之上

20:02.970 --> 20:12.010
明白了意思吧 就好被你们打电话 打电话的 电话一接通 是不是tcp ip协议 谁都可以说 抢着说 说连着说 对吧

20:12.970 --> 20:18.890
哎 后来双方就觉得这样说太乱了啊 我们能不能再规定一下 规定一下就是

20:19.770 --> 20:26.650
你那边说一句 我给你回一句啊 你问我答嘛 问的就是客户端 答的就是服务器对吧 回答回答问题的就是服务器

20:27.210 --> 20:30.890
那个提问的就是客户端 客户的服务器跟客户 那我们能不能这样子

20:31.690 --> 20:34.250
你问我答好 我就不说话了

20:35.450 --> 20:40.970
一会儿没说话我就快把电话挂了 一会儿呢 你又给我给我 又一个能够打电话过来 又是他问我答

20:41.450 --> 20:46.250
对吧 这是这就是attb协议 对吧 所以说attb协议建立在tcp协议之上

20:46.730 --> 20:50.490
因此呢 我们在tcp协议里面如何来表示attb协议的get请求呢

20:51.210 --> 20:54.250
请求行里面啊 你看 请求行

20:55.370 --> 21:02.730
请求行里面不是有三个信息吗 一个是请求方法 一个是请求的路径对吧 六句我们就行跟路径啊 后面我们协议的版本1.1

21:03.770 --> 21:08.810
好了 那后面的请求头呢 请求头就可以是任何东西啊 比方说我们可以写个host

21:09.290 --> 21:14.970
啊 我们请求的主机是这个主机啊 该表示一下 服务器呢 他能够 他就能够收到啊

21:16.410 --> 21:21.130
你请求我这个服务器 请求的主机名 是不是我要希望的主机名呢 他就可以收到这个消息

21:21.370 --> 21:26.810
当然啊 这里边可是不是可以写各种样的请求头 对不对 还有什么connecting啊什么

21:27.930 --> 21:31.370
keep life 对吧 各种各样的请求的是不是都可以写

21:32.090 --> 21:36.330
好 那么这里呢 我就不说了啊 好 请求头写完了过后 后面就是请求体

21:37.050 --> 21:42.010
啊 请求体 这次有没有能不能有请求体的 当然能有啊 tcb ip 协议的谁规定是不能有请求体的

21:42.410 --> 21:46.330
包括 adcb 协议 他也是可以有请求体的 对吧 只不过我们一般呢

21:46.810 --> 21:51.850
他不传请求体 但是呢 你不传请求体是一回事 你这个两个换行是必须要有的

21:52.570 --> 21:56.010
两个换行是请求头 到请求体之间的

21:56.650 --> 21:59.850
间隔啊 如果说没有间隔的话 一个请求是有问题的

22:00.730 --> 22:02.650
啊 比方说我这里不写不写两个

22:03.210 --> 22:04.090
啊 咱们来看一下

22:06.500 --> 22:10.810
呃 这边 index

22:11.690 --> 22:13.530
也成功 是不是出问题了

22:14.250 --> 22:20.570
为什么 为什么他说服务器没有给我响应 服务器还要等着等什么呢 等着我把请求体给他对吧

22:21.290 --> 22:25.930
啊 请求体没有了 服务器一直等的 一直等啊 就一直等不到结果

22:26.490 --> 22:31.530
啊 他认为这个请求没完 所以说呢 你一定要把请求体给上啊 给要上 给上过后呢

22:32.010 --> 22:34.410
这 这一部分啊 再说一次 这一部分才是 adcb

22:35.130 --> 22:39.770
前面都是 tcp ip  adp 规定了他传输了模式和传输了内容格式

22:40.170 --> 22:47.770
什么叫模式 就是你说一句 我打一句啊 然后就挂了 或者说我不挂 我再用一会儿的个连接 你再说一句 我再打一句

22:47.930 --> 22:50.250
这就是 这是模式 那么格式就是这个

22:50.730 --> 22:55.290
消息内容的格式啊 这一部分 adcp 实际上 tcp ip 这里传任何东西都可以

22:56.330 --> 22:59.930
啊 那么这里呢 我们给他花两行啊 表示我的请求体没有 啥都没有

23:00.650 --> 23:01.850
啊 接下来我们再看啊

23:02.090 --> 23:05.290
看服务器给我们的响应结果 note index

23:06.490 --> 23:12.170
你看服务器给我们响应了什么东西 你看一下啊 是不是一个完整的一天的文档 对不对

23:13.290 --> 23:13.450
哎

23:16.650 --> 23:23.770
啊 这里呢 来自服务器上的消息啊 你看 这是不是服务器响应的请求行 这整个就是个支付创嘛 响应的请求行

23:24.250 --> 23:31.050
然后呢 响应时间啊 消息内行啊 消息长度啊 扛了一个型 对吧 122

23:31.290 --> 23:34.730
他是应净式的啊 还有这些东西 对吧 响应头 然后呢 响应

23:35.290 --> 23:38.730
消息体 消息体是不是这一东西 这就是最原始最原始的格式

23:39.770 --> 23:47.610
啊 当然了 这这就是一个 这就是个通过 let 这个模块发送一个请求 对吧 我们创建一个请求 向服务器发送请求

23:48.090 --> 23:51.930
然后呢 我们这里当然在这里也可以监听啊 电话的刮断

23:53.130 --> 23:56.330
什么就是close啊啊 就是

23:57.530 --> 24:03.030
这个是什么呢 这个是结束了啊 结束了

24:04.150 --> 24:09.110
啊 当然这个right呢 我们也可以写个right end来这里啊 我们这里就写个最结束了啊 保存

24:12.940 --> 24:22.460
再来啊 运行 那么现在有没有结束 现在没有结束 为什么呢 现在都没有刮断电话

24:23.100 --> 24:28.300
那里是吧 都没有刮断电话 服务器那边也没有刮断啊 服务器那边不会轻易刮断的

24:28.780 --> 24:33.180
啊 不会轻易刮断的 他除非他非常非常忙 他可能会把之前的东西刮断啊

24:33.660 --> 24:39.100
主要是很多时候呢 刮断呢 主要是在客户端刮断的啊 客户端会刮断刮这个电话

24:39.740 --> 24:43.180
那么这里客户端有没有刮断电话 是没有啊 没有的话 那么

24:43.900 --> 24:47.900
没有的话 那么这还没有关闭 说客户端一般是怎么刮断的呢 一般是这样子

24:48.300 --> 24:53.260
我们收到服务器的消息结果之后 如果不是常链接 那么客户端这里就会调用

24:54.620 --> 24:56.620
close

24:58.860 --> 25:04.300
把这个把刮断 结束这个socket 那么这里刮断服务器那边也会也会自动刮断

25:04.940 --> 25:12.470
好 咱们来看一下 现在这个情况 你看是不是结束了 对吧 那么连接就断开了

25:13.430 --> 25:20.070
他就断开了 大家可以发现一个问题没有 什么问题 你看这个消息啊 服务器的消息是不是没有传送完

25:21.910 --> 25:27.350
对不对 这个服务器消息一看 明显后边还有啊 还有内容啊 对不对 那是为什么呢

25:27.830 --> 25:32.310
这根本我们以前学到流的知识有关系 因为流是不是一块一块的传的

25:32.790 --> 25:38.950
对吧 他不是说一下子把全部东西给脸 这样子他撑不住的啊 我们流是一块一块的传的

25:39.190 --> 25:42.950
所以说这一块呢 他可能消息是传不完的

25:44.070 --> 25:50.150
明白吧 他可能一块传不完 还要多传几块 那到底几块可以传完了 这就是个问题了

25:50.790 --> 25:55.350
到底几块可以传完 我什么时候知道他传完了呢 问题是

25:56.710 --> 25:59.350
那么这个时候怎么判定的 看着

26:00.710 --> 26:11.380
往上找 哎 往上找 继续往上找 你看服务器的响应结果 你看到没

26:12.340 --> 26:14.980
content lens

26:16.020 --> 26:17.700
60358

26:18.660 --> 26:21.300
这个消息头是来干嘛的

26:22.180 --> 26:24.900
他是干嘛的 他就是来告诉你

26:25.460 --> 26:28.980
因为请求头你只用那么一点点的吧 请求头肯定是可以传说完的

26:29.780 --> 26:35.540
请求头你一开始接受到请求头的时候 你是不是可以用制服出来分割解析等等的操作 对吧

26:35.940 --> 26:40.660
好来分割解析完了过后 是不是就可以拿到这个东西 这东西告诉你什么了 告诉你

26:41.540 --> 26:44.580
这个消息体的总制结束

26:45.380 --> 26:48.820
那你就不断接收 不断接收 不断接收 直到你接受到

26:50.020 --> 26:51.020
就是接受到这个

26:51.940 --> 26:58.340
大语等于这个制结束的时候 是不是就结束了 表示接受完了 对吧 没有东西可以接受了 接受完了 那么客户端就把关闭

26:58.980 --> 27:04.340
是这么个意思 所以说这个东西 请求 你说这个请求头这个东西有用没 肯定是有用的

27:05.060 --> 27:08.820
不然的话还没有告诉我这个东西的话 我就麻烦了 我不知道什么时候是个头

27:09.540 --> 27:11.620
这个消息我要到底要接受多久 我也不知道

27:12.740 --> 27:17.460
那么这个地方怎么来写了 大家有兴趣的话 可以自己写 算了 我给大家写一下吧

27:19.060 --> 27:21.140
那这里怎么玩呢 我们需要写个辅助函数

27:24.180 --> 27:24.900
pose header

27:25.780 --> 27:29.700
pose header 我要把这个header拿出来 返回一个对象

27:30.900 --> 27:37.460
咱们来吧 给我一个 给我一个就是整个整个的返回内容 返回内容

27:37.780 --> 27:41.940
response 将返回的 将响应制服串

27:42.820 --> 27:48.980
提炼出响应制服串的消息

27:49.860 --> 27:51.860
头和消息体

27:52.900 --> 27:57.700
对吧 我们提炼出响应制服串的消息头和消息体 那么这里呢 我就pose response

27:58.420 --> 28:05.540
response 好 那么我们这里怎么提炼呢 我们首先把这个response啊 按照什么来分割 按照第一个

28:06.340 --> 28:12.340
第一个 两换行来分割 对吧 我们就说 我们这里怎么办呢 我们可以用response

28:15.140 --> 28:16.340
用什么的index

28:18.660 --> 28:23.940
gn 是不是换两行 通过这个东西来分割 对吧 那么得到这个index

28:24.740 --> 28:26.980
index 好 咱们来输出一下这个index

28:28.340 --> 28:33.140
pose response 我们这里得到这个response

28:36.950 --> 28:42.870
这东西呢 就是发生逻辑肯定是可以做的 对不对 那么就剩下就是逻辑思维的问题了啊 给我们没有什么新知识

28:43.830 --> 28:45.590
pose response

28:46.390 --> 28:51.990
response 加进去 这里呢 我们把response输出啊 先暂时不输出嘛

28:53.590 --> 28:59.110
好 接下来 我们看看 好 你看一下 是不是有多个

28:59.670 --> 29:06.550
哎 是不是他 为什么这里出发了多次 因为他传送的 传送的东西要分几块 对吧 分成好几块

29:07.030 --> 29:13.910
分成好几块来来做 那么这里呢 我们只需要取第一个就行了 对不对 这只需要取第一个 好 第一个

29:15.190 --> 29:21.350
第一个的话 我们取出来的话 是一个index index呢 那么我们是不是取前面一部分作为什么

29:21.670 --> 29:28.230
响应头 后边这一部分呢 作为响应题 对不对 好 那么我们把头的部分取出来

29:28.950 --> 29:32.470
header head 头的部分呢 来自哪呢 response

29:33.590 --> 29:35.270
substitute

29:35.350 --> 29:36.230
str

29:37.670 --> 29:45.350
substitute 这样子 好 开始呢 就从零开始 end 结束的时候呢 就是结束 到index结束

29:46.150 --> 29:53.430
对不对 是不是到这样 好 然后呢 再来 body呢 body就是response substitute

29:56.150 --> 30:03.110
从index 加一开始 对吧 应该用两个换行加二嘛 加二开始 然后呢

30:03.590 --> 30:07.510
到结束 到结束 是不是 body 我们把 head 输出出来

30:08.390 --> 30:12.310
看一下啊 把 head 输出来 然后呢 再把 body 输出来

30:16.620 --> 30:23.180
啊 再得到 body 好 那么这里呢 因为它分成几次来传 对吧 有可能后续的传练过程中也有两个换行

30:23.420 --> 30:29.100
它也会出现两个换行 为了避免这个问题呢 我们只有在第一次的时候来做这个事 对吧

30:29.500 --> 30:34.220
只有在第一次的时候来做这个事 所以说呢 我们这里呢 可以用一个变量来判断一下

30:35.500 --> 30:38.860
呃 用一个变量啊 叫做

30:41.820 --> 30:45.820
is first 是不是第一次接收这个数据 默认为出

30:47.020 --> 30:54.060
好 那么这边我们判断 如果说第一次啊 is first 接收这个东西 如果是第一次接收的时候 我们再进行 post

30:55.020 --> 30:57.340
啊 再进行 post 是吧

30:59.100 --> 31:03.820
再进行解析啊 如果说不是第一次的话 我就不管了 那么这个是不是只运行是

31:04.460 --> 31:09.590
好 咱们来看一下 你看 想

31:12.950 --> 31:17.660
太多了 太多了 好 看着

31:19.820 --> 31:27.580
连接成功 然后呢 我们输出了 是不是输出了 head 对不对 是不是输出了什么 body 对不对

31:28.060 --> 31:35.020
哎 咱们再来看啊 我们这里的前面加上一个 head 嘛 head啊 body 的话太多了啊 我就把解去一下 body

31:35.980 --> 31:37.980
解去一下啊 sub stream 呃

31:38.780 --> 31:42.220
一到一百啊 稍微解去一下

31:43.420 --> 31:46.380
啊 这些东西啊 等下不不应该在客厂说 不然的话

31:48.220 --> 31:50.700
太多了啊 太多了啊 那么现在我们看

31:53.260 --> 31:54.620
来自服务局的消息

31:56.620 --> 32:01.420
等一下啊 哦 这里还有还有件事没做啊 还有件事没做 这里要把 is first 设为 force

32:02.380 --> 32:05.260
第一次处理完了过后 那么我们要把 is 为 force

32:07.500 --> 32:13.180
好 那么后边你看 是不是 head 部分 这一部分 对吧 是不是达到了

32:13.740 --> 32:17.340
然后呢 body 部分 是不是这一部分 是不是达到了 对不对

32:17.980 --> 32:21.420
好 那么 body 我先不管啊 我先搞定 head

32:22.220 --> 32:25.500
啊 我先搞定 head 这一部分 head 这一部分呢

32:26.060 --> 32:30.460
我们要怎么怎么来怎么来做呢 我们要把第一行去掉 对吧 是不是按换行

32:30.700 --> 32:34.540
按照换行来分割 对不对 是不是按换行来分割

32:34.860 --> 32:38.780
因此呢 我把这个 head 呢 再进一分割分割成 head part

32:39.740 --> 32:40.860
head split

32:42.140 --> 32:46.780
按照换行来进一分割 就不可以分割成很多很多的部分啊 咱们来看一下

32:48.300 --> 32:48.940
再来运行

32:50.940 --> 32:56.380
啊 你看 是不是分割成一个数组 对不对啊 他这个还有还有一个刚儿啊 还可以刚儿

32:56.460 --> 33:02.300
我们把刚儿去掉吧 刚儿是回车啊 回车的回车的进 那么把这个刚儿 把这里刚儿加上也行

33:03.340 --> 33:10.010
刚儿加上也行 刚儿 刚恩 好 现在你看

33:11.210 --> 33:18.260
哎 怎么还有个刚儿啊 split啊 这个是 split 刚儿 刚恩

33:22.120 --> 33:26.920
好 你看 是不是分割出来了 对不对 就分割出来这么一个这么这么一部分的人啊

33:27.320 --> 33:30.920
啊 body 呢 前面有两个换行啊 两个换行 无所谓吧 无所谓 来 放在这吧

33:31.480 --> 33:36.840
好 那么现在呢 我们只需要取这个数组里边后边的这一部分 是不是完事了

33:37.240 --> 33:40.360
来吧 我们后边就可以这样子来玩 head parts

33:40.840 --> 33:46.760
然后呢snaps 是分割数组 从下表为一开始分割结束 所以分割成一个

33:47.160 --> 33:51.880
就是除了 除了第一个请求行之外的部分 对吧 那么每一个部分是不是个建制队

33:52.360 --> 33:56.920
对吧 每一个部分是一个建制队 那么建制队怎么弄呢 建制队的话我们就可以用map

33:57.480 --> 34:01.640
每一个部分是一个制服串嘛 对吧 一个制服串呢 我们可以把个制服串呢

34:02.600 --> 34:03.720
变成一个

34:05.160 --> 34:08.600
对象嘛 把它变成一个对象 我看一下啊

34:09.400 --> 34:16.680
或者变成一个就有两项的数组啊 我觉得不应该讲这个啊 把他讲复杂了 其实这个我们把逻辑说清楚就够了

34:17.240 --> 34:25.080
啊 如果说你对这一块不感兴趣的话啊 那么你可以把直接把这一段挑过 其实逻辑上来说就已经可以做了 对吧 只剩了要写些代嘛

34:25.800 --> 34:29.320
啊 怎么弄呢 就把分割成两个部分啊 str split

34:30.040 --> 34:33.000
什么 冒号 对不对啊 分割成冒号

34:33.480 --> 34:38.040
分割成冒号过后是不是又是一个数组 然后呢 这个数组前面可能有空格啊 我们把空格去掉

34:38.920 --> 34:41.480
map呢 在s啊 s 掉去

34:43.580 --> 34:45.580
ok 那么现在我们看一下这个

34:47.180 --> 34:47.500
呃

34:48.940 --> 34:49.340
header

34:50.060 --> 34:50.460
二位

34:52.140 --> 35:00.740
然后看一下这个数组啊 你看 是不是我把这个head数组里边每分成

35:00.980 --> 35:06.580
分成每一项又是一个数组 这个数组的第一项是什么呢 第一项是这个 第二项呢是他的指 对吧 第一项是

35:07.300 --> 35:10.020
响应头的键 第二项是响应头的指 其实我们attp

35:10.740 --> 35:15.620
写他就内部帮我们处理了这件事 好 最后呢 我们把他搞成一个对象啊 搞成一个对象

35:16.180 --> 35:17.220
呃 就是什么对象呢

35:17.700 --> 35:18.900
呃 head

35:20.100 --> 35:21.060
header

35:21.140 --> 35:26.420
对象 这个对象呢 他有一些很多属性啊 属性从哪里来呢 就从这个数组里边来

35:26.660 --> 35:28.900
这个数组里边属性怎么来 那么我可以用reduce吧

35:29.460 --> 35:29.860
header

35:30.580 --> 35:31.860
reduce

35:33.460 --> 35:36.820
把拍片一下 呃 这边 a b

35:38.260 --> 35:41.060
默认值 默认值就给他一个对象啊 给他一个对象

35:42.660 --> 35:47.140
然后呢 这边对象传过来了对吧 传过来了过后呢 这个 a 我们的

35:48.020 --> 35:48.820
的那个什么呢

35:49.620 --> 35:54.660
这个对象里边的属性名 属性名就用b的第一项 对吧 用这个数组里边

35:55.060 --> 35:57.620
用这个数组里边的d一下 作为他的属性名

35:58.100 --> 36:01.540
然后呢 属性值呢 用b的第二项啊 第二项

36:02.020 --> 36:04.900
对吧 那么这里呢 得到了一个什么 得到了一个对象

36:06.100 --> 36:06.740
啊 header

36:08.260 --> 36:12.100
header 总之呢 你肯定是可以处理的 你不用这种方式 你用别的方式总之可以处理

36:13.540 --> 36:15.540
管理有什么样的方式都无所谓

36:17.140 --> 36:18.580
怎么了 他说他

36:19.140 --> 36:20.980
counter says property

36:21.780 --> 36:23.380
content type of undefend

36:24.500 --> 36:25.620
of undefend

36:27.540 --> 36:28.420
他说什么意思

36:30.260 --> 36:35.900
他说这个a啊 他说这个a是undefend

36:36.940 --> 36:41.100
怎么可能是undefend的呢 他不用默认值吗 我说出这个a

36:45.130 --> 36:49.210
第一个是 哦 没返回 没有返回啊 返回这个a

36:52.740 --> 36:53.540
好 现在我们来看

36:54.740 --> 36:56.980
好 你看 是不是得到一个header对象了

36:57.620 --> 37:01.860
对不对 header对象 你看 属性名 属性值 属性名 属性值

37:02.180 --> 37:05.140
对吧 好 body呢 body我们也放到header里边

37:05.700 --> 37:07.860
也放到一个对象里边 body

37:10.060 --> 37:14.700
body也放到对象里边 body就很简单了 body就直接是这个对吧

37:14.940 --> 37:17.340
我们把他一开始的空白制服给他去掉

37:17.740 --> 37:20.540
去掉一开始的空白制服 咱们来看一下 body

37:21.260 --> 37:22.700
tune start

37:23.660 --> 37:25.340
对吧 tune start

37:25.900 --> 37:28.140
那把去掉一开始的空白制服 看一下

37:29.980 --> 37:34.540
啊 body你看 空白制服怎么把那个去掉了 把这个监控号怎么去掉了

37:36.300 --> 37:39.420
监控号不能去掉了啊 监控号是一开始就没有吗

37:42.860 --> 37:44.300
啊监控号一开始有啊

37:45.180 --> 37:46.380
啊 那我们这样吧

37:47.180 --> 37:51.180
去掉他前面有两 他前面主要是这个 body前面有两个杠儿杠恩

37:51.420 --> 37:53.740
啊 这里一个杠儿杠恩 这里又有杠儿杠恩

37:54.700 --> 37:56.940
啊 body前面有这么几个好几个

37:57.660 --> 38:00.460
呃 咱们把一开始的

38:02.780 --> 38:04.140
不对啊 我再看一下啊

38:04.700 --> 38:07.740
再看一下那个一面上 我们去一面上去去一下

38:09.580 --> 38:11.660
哎 我是这么该讲这个 把时间搞长了

38:13.260 --> 38:14.940
在一面上去去去掉一下啊

38:20.860 --> 38:22.220
这里 换行

38:22.860 --> 38:23.340
换行

38:25.020 --> 38:28.220
这个东西啊 这个制服刷 然后呢tune start

38:30.740 --> 38:31.940
对啊 他没问题的啊

38:32.660 --> 38:34.900
他为什么会把那个监控号给我去掉呢

38:35.220 --> 38:36.260
这个奇了怪了

38:36.660 --> 38:37.700
tune start

38:38.980 --> 38:41.940
哦哦 这里这里就不能不能再sake了啊 不能再sake

38:42.260 --> 38:42.580
0

38:43.300 --> 38:44.340
啊 从0开始

38:45.300 --> 38:48.100
啊 后边其实我可以不要了 对吧 后边我可以不要了

38:48.500 --> 38:49.940
啊 我放着吧 先暂时放着

38:53.260 --> 38:53.740
看一下

38:55.100 --> 38:57.580
好 那么这里呢 你看 哎 这里咱们

38:58.140 --> 38:58.540
呃

38:59.260 --> 39:00.540
是不是在这 对吧 没问题

39:00.780 --> 39:02.140
好 那么 body我们就也知道了

39:02.220 --> 39:03.500
body来自于哪呢 来自于这

39:04.380 --> 39:04.940
你看着啊

39:05.580 --> 39:07.260
我们现在呢就可以反回一个对象

39:07.500 --> 39:08.700
这个对象里边一个header

39:09.260 --> 39:12.060
啊 一个body body来自于哪来自于这个

39:14.730 --> 39:16.410
是吧 我们是不是可以反回这么一个对象

39:16.970 --> 39:17.290
对不对

39:17.850 --> 39:20.250
好 那么我们在外面啊 写上一个变量

39:20.810 --> 39:22.330
呃 receive

39:22.890 --> 39:23.450
receive

39:24.650 --> 39:26.650
我们得到了东西啊 得到了东西

39:27.130 --> 39:28.330
那么如果一开始呢

39:28.650 --> 39:31.450
ease first的时候啊 我们或者就不要这个ease first了

39:31.690 --> 39:33.050
啊 如果说receive没有值

39:33.130 --> 39:35.450
是不是一开始第一次接收 对吧 第一次接收

39:35.850 --> 39:37.930
第一次接收的时候呢 我们pose response

39:38.090 --> 39:40.330
然后呢 他反回了对象呢 复制给这个receive

39:40.490 --> 39:41.370
对吧 给它复制

39:41.610 --> 39:43.130
复制过后是不是后面就有值了

39:43.290 --> 39:44.570
后面就不用再重新重新

39:45.210 --> 39:46.730
解析了啊 后面我们

39:46.890 --> 39:49.290
因为我们这里会接收 都接收很多次对吧

39:49.450 --> 39:52.010
会接收很多次 那么到底接收多少次呢

39:52.490 --> 39:54.890
到底要接收多少次呢 我们用这样的方式来看

39:56.330 --> 39:58.490
receive过后呢 我们来判断一下

39:59.050 --> 40:02.010
我们的那个content type啊 content lens

40:02.410 --> 40:03.770
是不是已经达到了

40:04.730 --> 40:07.450
就是content lens啊 我们的body里边的lens

40:07.450 --> 40:08.650
是不是已经达到了这个lens

40:08.650 --> 40:10.330
达到了说明是不是我们接收完了

40:10.570 --> 40:12.330
因此我们可以写个函数来判断一下

40:13.210 --> 40:13.930
is over

40:14.810 --> 40:15.610
你给我一个什么呢

40:15.850 --> 40:18.090
你不用给我了 我们就用这个receive来判断

40:19.290 --> 40:21.770
我们用这个receive它不里边不是个header属性吗

40:21.850 --> 40:27.370
里边不是一个属性名字叫做content lens

40:27.530 --> 40:28.650
对吧 是不是有这么一个东西

40:29.530 --> 40:30.650
content lens

40:32.570 --> 40:34.090
content lens就在这儿

40:34.810 --> 40:40.440
好 咱们把它转换成数字content lens

40:41.480 --> 40:44.360
这是我们要接收的消息体的总字结束

40:45.000 --> 40:48.680
需要接收的消息体的总

40:50.040 --> 40:51.720
总字结束

40:52.280 --> 40:54.520
对吧 我们要接收这么多字节

40:56.360 --> 40:58.520
好 那么现在呢我们要判断

40:58.520 --> 40:59.960
就是我们来输出一下

40:59.960 --> 41:02.040
输出一下content lens

41:03.000 --> 41:04.120
输出总字结束

41:04.120 --> 41:05.000
把它去掉

41:06.680 --> 41:08.120
输 is over

41:10.440 --> 41:11.400
是不是接收结束了

41:12.920 --> 41:14.760
你看 是不是总字结束得到了

41:14.760 --> 41:15.320
对吧

41:15.320 --> 41:17.480
然后呢我们目前的字结束

41:17.480 --> 41:19.400
目前接收到的字结束

41:19.400 --> 41:21.000
current

41:22.280 --> 41:23.240
curreceived

41:24.280 --> 41:27.240
received lens

41:28.040 --> 41:29.880
目前接收到的字结束是多少呢

41:29.880 --> 41:31.000
是不是来自于这个

41:31.560 --> 41:33.560
received对象里边的body

41:33.960 --> 41:34.360
对吧

41:34.360 --> 41:35.640
body 我们用一个buffer

41:36.200 --> 41:37.880
buffer from

41:40.310 --> 41:41.990
默认点码是UTF-8

41:43.190 --> 41:44.390
然后呢它里边有一个属性

41:44.390 --> 41:45.990
叫做byte lens

41:45.990 --> 41:46.550
对不对

41:46.550 --> 41:48.310
目前接收到的字结束

41:48.310 --> 41:49.430
一个是总字结束

41:50.390 --> 41:50.790
lens

41:53.270 --> 41:55.830
一个是目前接收到的字结束

41:55.830 --> 41:58.150
received lens

41:59.190 --> 41:59.910
好 保存

42:02.140 --> 42:02.540
看一下

42:03.500 --> 42:03.980
你看

42:03.980 --> 42:04.940
总字结束是这么多

42:04.940 --> 42:06.460
目前接收到的字结束是这么多

42:06.460 --> 42:07.100
对吧

42:07.180 --> 42:08.300
那么现在呢就是

42:08.300 --> 42:10.300
如果说我的总字结束

42:10.300 --> 42:12.380
我目前接收到了大于等于了它

42:14.220 --> 42:15.580
如果说 我们反悔什么的

42:15.580 --> 42:17.580
就是如果说我们目前接收到的字结束

42:17.580 --> 42:18.780
大于了总的字结束

42:20.300 --> 42:22.380
那么是不是就表示it's over了

42:22.380 --> 42:24.380
好 因此呢我这里怎么来

42:24.380 --> 42:25.740
我判断一下

42:25.740 --> 42:27.260
只要一字over

42:27.260 --> 42:28.300
只要还没有结束

42:29.260 --> 42:30.540
只要你还没有结束

42:30.540 --> 42:31.500
还没有结束干嘛呢

42:31.500 --> 42:32.380
我就把received

42:33.100 --> 42:34.620
the body

42:38.310 --> 42:39.030
看一下

42:39.030 --> 42:40.870
else

42:42.150 --> 42:43.030
如果说你

42:43.030 --> 42:44.230
我没有结束

42:44.230 --> 42:46.870
有可能一开始就结束了

42:46.870 --> 42:49.670
如果说已经结束了

42:49.670 --> 42:51.670
如果说没有结束

42:51.670 --> 42:53.350
我想一想

42:53.350 --> 42:56.310
没有结束的话

42:56.310 --> 42:58.310
我就应该怎么办呢

42:58.310 --> 43:00.310
我就应该把body

43:00.310 --> 43:01.350
拼接进去

43:01.350 --> 43:01.910
对吧

43:01.910 --> 43:02.870
但是呢

43:02.870 --> 43:04.150
这边

43:04.150 --> 43:04.870
这是第一次

43:04.870 --> 43:06.310
还要考虑第一次

43:06.310 --> 43:07.670
应该在这里写

43:07.670 --> 43:10.230
如果说是第一次的话

43:10.230 --> 43:11.750
第一次我这里判断一下

43:11.750 --> 43:13.110
它这么一个逻辑

43:13.110 --> 43:14.550
如果说第一次就结束了

43:14.550 --> 43:16.070
第一次结束了就是socket

43:16.070 --> 43:17.270
to end

43:17.270 --> 43:19.110
return 结束了

43:19.110 --> 43:21.270
结束了 结束方法

43:21.270 --> 43:23.830
第一次接收就结束了

43:23.830 --> 43:25.590
那如果说第一次接收没有结束了

43:25.590 --> 43:27.830
就是后续的接收过程

43:27.830 --> 43:29.670
后续的接收过程呢

43:29.830 --> 43:33.030
等一下 我留一下

43:33.030 --> 43:34.150
这里的逻辑

43:34.150 --> 43:38.630
如果说这是第一次打出事

43:38.630 --> 43:41.430
第一次我怎么把自己倒晕了

43:41.430 --> 43:43.270
第一次

43:43.270 --> 43:46.150
我们解析成一个对象

43:46.150 --> 43:48.070
如果解析完了过

43:48.070 --> 43:49.430
就已经结束了

43:49.430 --> 43:51.350
那么就肯定是结束

43:51.350 --> 43:51.830
对吧

43:51.830 --> 43:52.950
没有问题

43:52.950 --> 43:57.350
如果说第一次还没有结束

43:58.310 --> 44:00.870
第一次还没有结束

44:00.870 --> 44:02.310
我们也不能做任何事情

44:02.310 --> 44:03.750
因为这是第一次

44:03.750 --> 44:04.710
第一次还没有结束

44:04.710 --> 44:06.150
我们也不能做任何事情

44:06.150 --> 44:07.110
如果说第一次结束了

44:07.110 --> 44:07.830
我们就end

44:07.830 --> 44:09.110
如果说第一次没有结束

44:09.110 --> 44:10.390
我们也不能做任何事情

44:10.390 --> 44:11.110
因为第一次

44:11.110 --> 44:12.550
我们把事情已经做完了

44:12.550 --> 44:13.430
解析成一个对象了

44:15.430 --> 44:19.510
然后如果说不是第一次

44:19.510 --> 44:20.950
那么后面就是不是第一次了

44:20.950 --> 44:21.910
不是第一次的话

44:21.910 --> 44:22.950
那么我们首先看一下

44:22.950 --> 44:25.190
目前有没有结束

44:25.190 --> 44:26.950
is over

44:27.110 --> 44:28.630
或者我们后面看

44:28.630 --> 44:31.350
我们先把body拼接到receive里面去

44:31.350 --> 44:33.110
body拼接进去

44:33.110 --> 44:33.750
拼接什么呢

44:33.750 --> 44:35.350
chunk

44:35.350 --> 44:37.910
拼接这个response

44:37.910 --> 44:39.190
后面拼接一下

44:39.190 --> 44:40.150
然后拼接完了过

44:40.150 --> 44:41.350
再看一下有没有结束

44:41.350 --> 44:42.950
如果结束了

44:42.950 --> 44:43.830
socket end

44:43.830 --> 44:44.710
没有结束

44:44.710 --> 44:45.830
那么没有结束的话

44:45.830 --> 44:46.710
那么继续

44:46.710 --> 44:47.830
对吧

44:47.830 --> 44:49.510
那么先让我们再来看一下

44:49.510 --> 44:51.590
能不能接受完成了

44:53.110 --> 44:55.670
最后我们在socket end这个位置

44:55.670 --> 44:57.190
在end的时候

44:57.190 --> 44:58.710
sockets

44:58.710 --> 44:59.590
on close的时候

44:59.590 --> 45:00.950
我们在close的时候

45:00.950 --> 45:01.750
输出一下

45:01.750 --> 45:03.750
输出一下receive的body

45:03.750 --> 45:06.310
receive的body

45:06.310 --> 45:08.630
看一下现在能不能接受

45:08.630 --> 45:11.350
接受完整

45:11.350 --> 45:13.110
你看是现在是不是接受完整了

45:13.110 --> 45:13.750
对不对

45:13.750 --> 45:17.270
就把整个完整的atm就接受出来了

45:17.270 --> 45:17.990
你看

45:17.990 --> 45:19.270
最终多了一个字节

45:19.270 --> 45:19.510
对吧

45:19.510 --> 45:21.990
可能某一个结尾制服没有算

45:21.990 --> 45:23.670
那么最终我们接受到这个字节

45:23.670 --> 45:24.950
接受到一定让字节过后

45:25.030 --> 45:26.150
它会等于这个字

45:26.150 --> 45:27.670
那么就接受结束了

45:27.670 --> 45:31.030
这就是它真实的atvp请求协议

45:31.030 --> 45:32.150
它什么时候决定

45:32.150 --> 45:33.030
要关闭的

45:33.030 --> 45:35.750
还有通过这个content的内容来算

45:35.750 --> 45:36.870
我是真不该讲这个

45:36.870 --> 45:38.070
怎么讲这么多了

45:38.070 --> 45:39.030
不过好处在于什么了

45:39.030 --> 45:40.550
好处在于

45:40.550 --> 45:42.310
这是路博客

45:42.310 --> 45:43.110
也无所谓

45:43.110 --> 45:44.950
多一点就多一点

45:44.950 --> 45:45.270
好

45:45.270 --> 45:49.110
现在我们把客户端就讲完了

45:49.110 --> 45:50.070
其实很简单

45:50.070 --> 45:51.670
就是我们作为一个客户端

45:51.670 --> 45:54.070
看下面这个图算的

45:54.790 --> 45:55.270
sockage

45:57.270 --> 45:58.790
其实我们的客户端就是

45:58.790 --> 45:59.990
我们建立一个sockage端

45:59.990 --> 46:01.270
建立年纪过产生一个sockage

46:01.270 --> 46:02.870
然后跟服务器不断地发消息

46:02.870 --> 46:04.470
服务器跟我们回消息

46:04.470 --> 46:05.830
因为我们用的是atv协议

46:05.830 --> 46:08.230
服务器我们目前我也找不到一个服务器

46:08.230 --> 46:11.110
支持tcpib协议的

46:11.110 --> 46:12.230
只支持tcpib协议的

46:12.230 --> 46:13.270
没到到

46:13.270 --> 46:15.590
所以说我这里就直接用atv协议

46:15.590 --> 46:18.950
模拟atv协议跟远程服务器已经交互

46:20.550 --> 46:22.470
这是客户端这一块

46:22.470 --> 46:23.350
那么服务器呢

46:24.470 --> 46:27.190
但是它不仅可以创建一个客户端

46:27.190 --> 46:28.950
它可以创建一个服务器

46:28.950 --> 46:30.630
咱们来看一下服务器

46:30.630 --> 46:33.110
就是我们现在自己是服务器了

46:33.110 --> 46:34.550
别人是客户端的

46:34.550 --> 46:35.270
咱们来看一下

46:36.710 --> 46:39.670
这里我们client把保存一下

46:41.350 --> 46:42.710
这边我们现在用服务器

46:46.580 --> 46:48.420
服务器的方法它是这样子

46:49.860 --> 46:50.500
不能关了

46:50.500 --> 46:50.980
不能关

46:52.180 --> 46:52.580
可以了

46:55.050 --> 46:57.370
服务器的方法它是create server

46:57.530 --> 46:58.650
来创建这么一个服务器

47:00.090 --> 47:01.050
不需要给产数

47:01.050 --> 47:01.850
它就是一个服务器

47:01.850 --> 47:03.690
这里面其实有一个listener

47:03.690 --> 47:04.490
一个监听函数

47:04.490 --> 47:05.770
表示服务器是否创建

47:06.650 --> 47:07.210
服务器呢

47:07.210 --> 47:08.650
因为它要监听一个端口

47:08.650 --> 47:09.210
对吧

47:09.210 --> 47:09.930
那么这里呢

47:09.930 --> 47:10.890
反回的不是socket

47:10.890 --> 47:12.010
反回的是一个server对象

47:12.650 --> 47:13.130
它反回的

47:13.690 --> 47:15.770
它反回的是这么一个server对象

47:17.050 --> 47:18.010
我把这个拿过来

47:18.010 --> 47:19.450
切来切去也挺烦

47:23.130 --> 47:24.650
这是一个server对象

47:24.650 --> 47:26.330
那么server对象里面提供了一些方法

47:26.330 --> 47:27.370
一个是listen

47:27.450 --> 47:28.490
表示我的服务器呢

47:28.490 --> 47:30.090
去监听某一个端口

47:30.090 --> 47:31.930
那么等待客户端能连接

47:31.930 --> 47:32.490
listen

47:32.490 --> 47:33.850
listen不要说我们9527吗

47:35.610 --> 47:39.530
服务器监听端口

47:40.250 --> 47:41.210
某个端口

47:41.210 --> 47:43.450
就是9527端口

47:44.890 --> 47:45.050
好

47:45.050 --> 47:45.850
咱们来运行看一下

47:48.070 --> 47:48.310
你看

47:49.270 --> 47:50.390
所以就已经搞定了

47:51.270 --> 47:52.790
你看这个程序没有结束

47:52.790 --> 47:53.670
你发现没

47:53.670 --> 47:54.470
为什么没有结束

47:54.470 --> 47:55.510
因为服务器在等着

47:56.230 --> 47:56.870
卡住了

47:56.870 --> 47:57.910
服务器等着

47:57.910 --> 47:58.630
等什么呢

47:59.270 --> 48:01.750
等那个客户端给我发一个请求过来

48:01.750 --> 48:02.150
对吧

48:02.150 --> 48:03.190
就是发通连接

48:03.190 --> 48:05.110
我们双方来监听连接来通话

48:05.110 --> 48:06.310
如果说服务器就结束了

48:06.310 --> 48:07.110
后边怎么来

48:07.110 --> 48:08.150
怎么来监听连接呢

48:08.150 --> 48:09.350
所以说服务器它不会结束的

48:10.230 --> 48:10.390
好

48:10.390 --> 48:10.630
OK

48:10.630 --> 48:11.590
这是我们监听

48:11.590 --> 48:12.390
开始监听过后

48:12.390 --> 48:13.190
它就不会结束了

48:13.750 --> 48:13.910
好

48:13.910 --> 48:14.950
这样我们再看

48:14.950 --> 48:15.430
还有什么呢

48:15.430 --> 48:17.270
还有这么一些事件

48:17.270 --> 48:18.790
一个事件是listen

48:19.510 --> 48:20.310
什么意思呢

48:20.310 --> 48:21.270
表示的是

48:21.270 --> 48:23.430
当服务器完成监听过后

48:23.430 --> 48:25.990
就是开始来监听这个端口之后呢

48:25.990 --> 48:27.030
它触发的时间

48:27.110 --> 48:28.950
我们通常的就是一般做一些提示性

48:28.950 --> 48:30.870
一些日子记录这些东西

48:30.870 --> 48:31.350
比方说

48:33.510 --> 48:33.990
server

48:35.190 --> 48:35.590
listen

48:37.830 --> 48:38.470
9527

48:39.430 --> 48:41.350
服务器在9527端口之上进行监听

48:41.990 --> 48:42.390
来吧

48:42.390 --> 48:43.030
我们来试一下

48:43.990 --> 48:44.470
你看一下

48:44.470 --> 48:45.750
是不是这个事件就出发了

48:46.710 --> 48:47.830
还有没有别的事件呢

48:47.830 --> 48:49.590
还有还有这个connection事件

48:49.590 --> 48:50.470
这个是比较重要的

48:51.590 --> 48:52.710
connection事件

48:52.710 --> 48:53.510
这个什么事件呢

48:53.510 --> 48:54.630
这个是表示

48:54.630 --> 48:55.750
有一个客户端

48:55.830 --> 48:57.270
已经连到我服务器了

48:57.270 --> 48:58.230
双方通话了

48:58.230 --> 49:00.630
正在已经建立好连接了

49:01.350 --> 49:02.470
那么后续呢

49:02.470 --> 49:04.470
它这里后续的处理函数中

49:04.470 --> 49:05.670
有一个参数叫sockets

49:06.870 --> 49:07.270
表示什么呢

49:07.270 --> 49:09.830
因为服务器端跟客户端通话

49:09.830 --> 49:11.430
也需要一个sockets

49:11.430 --> 49:12.230
也需要个文件

49:12.230 --> 49:12.950
那个文件呢

49:12.950 --> 49:13.750
往里边写的一种

49:13.750 --> 49:14.390
它就发送到

49:15.030 --> 49:15.350
看图

49:17.350 --> 49:19.190
之前的那个客户端这里

49:19.830 --> 49:21.430
服务器那边也需要个sockets

49:21.430 --> 49:24.710
sockets也是跟那个客户端进行交互的

49:24.710 --> 49:25.510
所以说这边呢

49:25.590 --> 49:27.030
它会产生一个sockets

49:27.030 --> 49:27.590
我们这里呢

49:27.590 --> 49:28.150
输出一句话

49:29.430 --> 49:34.950
有客户端连接到服务器

49:37.030 --> 49:37.350
好

49:37.350 --> 49:38.070
咱们来看一下

49:38.070 --> 49:38.710
咱们来看一下

49:39.990 --> 49:40.470
这里呢

49:40.470 --> 49:40.950
我们停止

49:42.230 --> 49:43.190
load index

49:43.990 --> 49:44.230
好

49:44.230 --> 49:44.710
现在呢

49:45.350 --> 49:46.950
现在为什么没有输出这句话

49:46.950 --> 49:48.390
有客户端连接过来吗

49:48.390 --> 49:49.270
是不是还是没有

49:49.990 --> 49:50.470
没有

49:50.470 --> 49:51.030
那么现在呢

49:51.030 --> 49:53.030
我们这样子来打开浏览器

49:54.310 --> 49:55.110
浏览器客户端

49:55.430 --> 49:57.190
localhost9527

49:57.990 --> 49:58.470
一回车

49:59.110 --> 49:59.910
浏览器这边卡

49:59.910 --> 50:00.790
让它卡

50:00.790 --> 50:01.830
我们来看一下

50:01.830 --> 50:02.790
是不是有连接进来了

50:03.590 --> 50:04.390
有些同学问

50:04.390 --> 50:05.990
为什么有两次连接呢

50:05.990 --> 50:06.790
是这个样子的

50:07.910 --> 50:09.190
浏览器也好了

50:09.190 --> 50:10.950
包括PoseMan也好了

50:10.950 --> 50:12.390
它在最开始的时候

50:12.390 --> 50:13.590
跟服务器连接的时候

50:13.590 --> 50:15.190
它会发送一个测试连接

50:15.190 --> 50:16.470
测试跟服务器有没有连通

50:17.190 --> 50:18.390
所以说这里的服务器

50:18.390 --> 50:19.830
产生了两个连接

50:19.830 --> 50:21.270
然后测试连接连通了过后了

50:21.270 --> 50:22.150
后续的请求

50:22.150 --> 50:24.070
再使用后续的连接来进行操作

50:24.790 --> 50:25.910
它是用这么一种模式

50:26.550 --> 50:27.350
我们这里不管它

50:27.350 --> 50:29.190
总之是不是有客户端连接到服务器了

50:29.750 --> 50:30.070
对不对

50:30.630 --> 50:31.910
那么这个地方

50:32.470 --> 50:33.750
大家需要理清楚的就是

50:34.230 --> 50:34.550
这里

50:36.070 --> 50:37.670
当某个连接到来的时候

50:37.670 --> 50:38.550
它会出发这个事件

50:39.110 --> 50:39.830
而且呢

50:39.830 --> 50:41.350
这个事件的监听函数

50:41.350 --> 50:42.230
会得到一个sockage

50:42.230 --> 50:43.510
那么这个东西怎么能理解呢

50:43.510 --> 50:44.310
你看一下这张图

50:44.310 --> 50:45.030
我给大家解释一下

50:48.310 --> 50:49.110
用这个mockdown

50:49.110 --> 50:50.070
用这个Xman的

50:50.070 --> 50:50.870
不太好的地方就是

50:51.590 --> 50:53.110
不太好控制

50:54.070 --> 50:55.350
我们这是个服务器

50:55.350 --> 50:56.630
在监听哪个端口

50:56.630 --> 50:58.150
监听9527端口

50:59.190 --> 51:00.310
可能有很多的客户端

51:00.310 --> 51:01.590
都要连接我

51:01.590 --> 51:02.630
比方一个扭烂机器

51:02.630 --> 51:03.510
就是一个客户端

51:03.510 --> 51:03.990
对吧

51:03.990 --> 51:04.950
有很多的客户端

51:04.950 --> 51:05.750
都要连接我

51:05.750 --> 51:06.310
而且呢

51:06.310 --> 51:07.750
有可能一个客户端

51:07.750 --> 51:09.190
可能会产生多个连接

51:09.190 --> 51:09.910
因为我们知道

51:09.910 --> 51:10.710
ACP请求

51:10.710 --> 51:12.630
如果说你不使用场连接的话

51:12.630 --> 51:13.590
那么会导致

51:13.590 --> 51:14.790
就是你连过来

51:15.270 --> 51:16.790
响应就给断开了

51:17.590 --> 51:18.230
然后呢

51:18.230 --> 51:19.030
你下一次再连

51:19.030 --> 51:19.670
就要重新

51:19.670 --> 51:20.950
发送连接

51:20.950 --> 51:22.230
一个新的连接

51:22.230 --> 51:23.510
如果说你使用场连接

51:23.510 --> 51:24.790
有一段时间没有操作的话

51:24.790 --> 51:25.830
也会断开

51:25.830 --> 51:27.350
所以说他可能会有多个连接

51:27.350 --> 51:28.630
就说一个客户端

51:28.630 --> 51:29.670
请求服务器

51:29.670 --> 51:31.190
请求这个端口

51:31.190 --> 51:32.470
服务器一看

51:32.470 --> 51:33.750
有请求进来了

51:33.750 --> 51:34.790
那怎么办呢

51:34.790 --> 51:35.270
你看

51:35.270 --> 51:36.310
这个绿色的箭头

51:36.310 --> 51:37.590
是不是产生一个sockage

51:37.590 --> 51:38.870
服务器那边

51:38.870 --> 51:40.150
也会产生一个sockage

51:40.150 --> 51:41.430
当然扭烂机那边

51:41.430 --> 51:42.710
也会自动的产生一个sockage

51:42.710 --> 51:43.990
只不过我们平时

51:43.990 --> 51:44.230
也带忙了

51:44.230 --> 51:45.270
不用这样子写

51:45.270 --> 51:46.310
然后呢

51:46.310 --> 51:47.830
双方是不可以交互数据了

51:47.830 --> 51:49.110
怎么交互数据

51:49.110 --> 51:50.390
请求过来

51:50.390 --> 51:51.670
然后呢

51:51.670 --> 51:52.950
响应过去

51:52.950 --> 51:54.230
断开

51:54.230 --> 51:55.510
断开服务器这边就消灰了

51:55.510 --> 51:56.790
如果说场连接的话

51:56.790 --> 51:58.070
等一会儿才断开

51:58.070 --> 51:59.350
这样的意思吧

51:59.350 --> 52:00.630
好如果说

52:00.630 --> 52:01.910
这个时候呢又有一个

52:01.910 --> 52:04.470
这个时候就这个扭烂机

52:04.470 --> 52:05.750
都还没有完成

52:05.750 --> 52:07.030
那么这个扭烂机又产生

52:07.030 --> 52:08.310
又来请求他

52:08.310 --> 52:09.590
是不是又来触发这个事件

52:09.590 --> 52:10.870
又产生一个新的sockage

52:10.870 --> 52:12.150
跟这个扭烂机交互

52:12.150 --> 52:13.430
你可以把服务器

52:13.430 --> 52:14.710
想象成什么呢

52:14.710 --> 52:17.270
想象成你们打拨打了一个400电话

52:17.270 --> 52:18.550
是不是有很多的客服人员

52:19.270 --> 52:20.390
你是客服端吗

52:20.390 --> 52:21.510
你这边只有一个sockage

52:21.510 --> 52:23.110
就是你自己

52:23.110 --> 52:25.990
而服务器那边是不是有很多的接线人员

52:25.990 --> 52:26.470
对吧

52:26.470 --> 52:27.830
你去打个电话过去

52:27.830 --> 52:29.430
他马上给你分配一个接线人员

52:29.430 --> 52:30.790
来给你对接

52:30.790 --> 52:32.550
这就是服务器端的sockage

52:32.550 --> 52:35.110
也就是服务器端可能会产生多个sockage

52:35.110 --> 52:37.910
每一次连接过来都会产生一个sockage

52:37.910 --> 52:39.510
表演的意思吧

52:39.510 --> 52:42.070
好了那个sockage里边使用方式有一样的

52:42.070 --> 52:44.230
你往里边写东西

52:44.230 --> 52:47.430
就相当于是发生了响应到客服端

52:47.430 --> 52:49.590
你读东西就相当于是读请求

52:49.590 --> 52:50.470
对不对

52:50.470 --> 52:52.150
那咱们来看一下这个sockage

52:52.150 --> 52:53.590
给他注册一些事件

52:53.590 --> 52:55.990
sockage的一个事件是unclose

52:55.990 --> 53:01.030
我们这里输出连接关闭了

53:01.030 --> 53:02.790
连接关闭了

53:02.790 --> 53:07.670
然后我们这里停止

53:07.670 --> 53:09.110
你看

53:09.110 --> 53:11.270
一开始见到

53:11.270 --> 53:12.550
是n的吗

53:12.550 --> 53:13.510
ok

53:13.510 --> 53:14.790
unn的

53:14.790 --> 53:18.620
unn的

53:19.340 --> 53:21.260
这么三个

53:21.260 --> 53:23.260
这么有三个

53:23.260 --> 53:26.660
再来

53:26.660 --> 53:28.180
我改的是什么呢

53:28.180 --> 53:29.940
有客服端连接到服务器

53:29.940 --> 53:31.140
这个

53:31.140 --> 53:32.500
哦 这边是一直在刷新啊

53:32.500 --> 53:33.220
一直在连

53:33.220 --> 53:33.700
他连不上

53:33.700 --> 53:35.140
他就会一直重视

53:35.140 --> 53:37.540
好 再来刷新

53:37.540 --> 53:40.180
是不是有两个连接到服务器了

53:40.180 --> 53:41.060
有连接到服务器了

53:41.060 --> 53:43.540
哎 为什么没有close呢

53:43.540 --> 53:44.100
哦 对对对

53:44.100 --> 53:45.140
现在还没发口语

53:45.140 --> 53:46.580
因为这边他还没有挂电话

53:46.580 --> 53:46.820
对吧

53:46.820 --> 53:48.980
这边服务器一直没给他东西

53:48.980 --> 53:50.260
他到时候发了数据到服务器了

53:50.340 --> 53:51.620
但是服务器一直没给他的东西

53:51.620 --> 53:53.540
所以说他一直没有挂电话

53:53.540 --> 53:55.140
因此连接是没有关闭的

53:55.140 --> 53:55.380
对吧

53:55.380 --> 53:56.180
连接测试不通

53:56.180 --> 53:57.220
没有关闭

53:57.220 --> 53:57.860
好 那么现在呢

53:57.860 --> 53:59.380
我们再给他加上这个时间

53:59.380 --> 54:01.700
socket on data

54:01.700 --> 54:02.260
我们来看一下

54:02.260 --> 54:03.460
客服端传接服务器的

54:03.460 --> 54:04.740
到底是什么玩意

54:04.740 --> 54:05.540
我们输出一下

54:05.540 --> 54:08.820
tronk tostune

54:08.820 --> 54:11.460
utf-8

54:11.460 --> 54:13.300
收到连接之后呢

54:13.300 --> 54:15.940
服务器就unn的了

54:15.940 --> 54:17.380
服务器就unn的

54:17.380 --> 54:18.660
socket

54:18.660 --> 54:19.860
unn的

54:20.820 --> 54:22.660
服务器主动断坎

54:23.700 --> 54:25.940
或者是服务器该写一些东西吧

54:25.940 --> 54:27.220
写一些东西

54:27.220 --> 54:28.420
socket

54:28.420 --> 54:29.220
right

54:30.500 --> 54:31.700
我给他完成响应嘛

54:31.700 --> 54:32.980
要写一些东西

54:32.980 --> 54:33.700
写什么东西呢

54:33.700 --> 54:34.740
写一句话嘛

54:35.460 --> 54:35.860
你好

54:38.570 --> 54:39.770
好 那咱们来看一下

54:44.340 --> 54:45.460
load index

54:47.220 --> 54:48.260
你看啊

54:48.260 --> 54:50.180
现在呢我们用浏览器嘛

54:50.180 --> 54:50.500
刷新

54:51.860 --> 54:52.180
你看

54:52.900 --> 54:56.180
是不是就有收到了浏览器的响应

54:56.820 --> 54:57.620
对吧

54:57.620 --> 54:58.500
浏览器的请求

54:59.060 --> 54:59.620
请求行

55:00.340 --> 55:01.300
请求头

55:01.300 --> 55:02.420
那么这里有两个换行

55:02.420 --> 55:02.580
对吧

55:02.580 --> 55:03.380
后边是请求体

55:03.380 --> 55:04.580
请求体没有了

55:04.580 --> 55:04.900
对吧

55:05.940 --> 55:06.420
好

55:06.420 --> 55:07.540
那么这个时候呢

55:07.540 --> 55:10.260
我给他给浏览器响应了一个理好

55:10.260 --> 55:12.020
为什么浏览器显示不出来了

55:13.700 --> 55:14.980
是不是因为这个东西

55:14.980 --> 55:15.860
它不符合

55:16.500 --> 55:17.380
attp的

55:18.180 --> 55:19.220
协议的结构

55:19.220 --> 55:19.620
对吧

55:19.620 --> 55:21.140
它的内容格式不一样

55:21.220 --> 55:22.100
不一致

55:22.100 --> 55:22.740
有问题

55:23.220 --> 55:25.540
那么它的内容结构应该是什么样子呢

55:25.540 --> 55:26.820
你随便去请求一个网页

55:26.820 --> 55:27.380
你都可以看到

55:27.380 --> 55:29.060
它的内容格式应该是什么样子

55:29.060 --> 55:29.780
比方说有百度

55:31.380 --> 55:32.180
咱们看一下内出

55:33.060 --> 55:33.540
刷新

55:33.540 --> 55:35.700
你看这个百度

55:35.700 --> 55:36.340
你看它响应

55:37.220 --> 55:38.180
我们看view source

55:39.220 --> 55:41.060
这才是一个正确的响应的

55:42.180 --> 55:43.620
响应的结构对吧

55:44.900 --> 55:45.700
是不是这样子

55:45.700 --> 55:46.580
我们复制一下

55:46.580 --> 55:47.140
暂停过来

55:47.780 --> 55:48.660
这才是一个正确的

55:48.660 --> 55:49.060
注意啊

55:49.060 --> 55:49.940
前面不能有空格

55:50.900 --> 55:52.100
这才是一个正确的

55:52.100 --> 55:52.900
前面是协议

55:52.900 --> 55:54.500
后边是响应消息码

55:54.500 --> 55:55.140
对不对

55:55.140 --> 55:56.260
那么后边是响应头

55:56.740 --> 55:57.220
响应头

55:57.220 --> 55:57.780
然后响应头

55:57.780 --> 55:58.660
那我难得写了

55:58.660 --> 55:59.460
难得写了

55:59.460 --> 56:00.740
这东西也没什么好写的

56:01.300 --> 56:02.100
content

56:02.100 --> 56:02.740
也不用写了

56:02.740 --> 56:03.460
不用写了

56:03.460 --> 56:04.900
然后那响应题呢

56:04.900 --> 56:06.340
换两行对不对

56:06.340 --> 56:07.860
是不是这里书写响应题

56:07.860 --> 56:08.580
然后响应题

56:08.580 --> 56:09.380
里边可以写啥呢

56:09.380 --> 56:09.940
啥都可以写

56:09.940 --> 56:11.060
比方说你写个ATM字

56:11.060 --> 56:11.860
这个东西都可以写

56:13.540 --> 56:14.020
你好啊

56:15.300 --> 56:15.780
对不对

56:15.780 --> 56:16.500
那么这个是不是

56:16.500 --> 56:17.540
来自于服务的响应

56:18.500 --> 56:18.740
好

56:18.740 --> 56:19.700
接下来我们来再看一下

56:22.200 --> 56:22.600
停止

56:24.600 --> 56:24.920
刷新

56:25.640 --> 56:26.280
就拿到了

56:26.280 --> 56:27.240
我们看一下原代吧

56:30.940 --> 56:31.420
等一下啊

56:34.220 --> 56:35.580
倒是拿到结果了

56:35.580 --> 56:35.980
对吧

56:35.980 --> 56:36.780
拿到结果了

56:38.380 --> 56:39.100
拿到结果了

56:39.100 --> 56:40.460
他他认为

56:40.460 --> 56:41.340
他这个认为

56:41.340 --> 56:42.700
他服务器还有东西

56:42.700 --> 56:44.140
他认为服务器还有东西

56:44.140 --> 56:45.580
还有东西没有传输过来

56:45.580 --> 56:45.980
所以说呢

56:45.980 --> 56:47.420
我们这里最好了

56:47.420 --> 56:47.980
N等一下

56:49.020 --> 56:49.500
N等一下

56:50.140 --> 56:50.620
Socus

56:53.500 --> 56:54.540
Socus

56:54.540 --> 56:55.260
End

56:55.260 --> 56:56.300
就是我写完了

56:56.300 --> 56:56.460
啊

56:56.460 --> 56:57.020
我写完了

56:57.740 --> 56:58.060
好

56:58.060 --> 56:58.460
保存

57:00.220 --> 57:01.180
这里我们再刷新

57:03.260 --> 57:03.580
怎么

57:07.720 --> 57:08.280
看一下

57:08.280 --> 57:09.000
出了什么问题

57:10.840 --> 57:12.360
Red after end

57:12.360 --> 57:13.320
哦

57:13.320 --> 57:14.360
我这个地方呢

57:14.360 --> 57:15.720
我这个地方呢

57:15.720 --> 57:16.920
写了一次过后啊

57:17.480 --> 57:19.160
我这个地方写了一次过后

57:21.320 --> 57:22.680
导致一个结果就是

57:22.680 --> 57:24.360
因为这个写需要一段时间

57:24.840 --> 57:26.920
可能在时间没有完之前

57:26.920 --> 57:28.120
还没有写完

57:28.120 --> 57:29.400
我就已经end了

57:29.400 --> 57:30.520
我就已经end了

57:30.520 --> 57:31.320
那么这个地方呢

57:31.320 --> 57:32.360
我们这样子吧

57:32.360 --> 57:33.000
我们这样子

57:33.960 --> 57:34.600
我们把

57:34.600 --> 57:35.160
放到这

57:35.160 --> 57:35.800
放到这

57:37.800 --> 57:38.360
我看一下

57:38.360 --> 57:40.440
我这个end写出来了

57:40.440 --> 57:40.840
不是

57:40.840 --> 57:41.640
还不是这个原因

57:42.200 --> 57:43.160
我看一下

57:43.160 --> 57:44.360
我这个end写出来了

57:44.360 --> 57:45.240
应该再写到这

57:45.240 --> 57:45.880
应该写到这

57:45.880 --> 57:46.520
这才没问题

57:47.640 --> 57:48.200
再来

57:50.300 --> 57:50.700
好

57:50.700 --> 57:51.020
刷新

57:51.660 --> 57:52.300
你看

57:52.300 --> 57:53.900
是不是拿到一个完整的网页了

57:53.900 --> 57:54.620
刷新

57:54.700 --> 57:56.620
是不是拿到这个完整的网页了

57:56.620 --> 57:56.860
啊

57:56.860 --> 57:57.660
它是这么玩的

57:58.300 --> 57:59.260
原来的意思吧

57:59.260 --> 58:00.220
它这么玩

58:00.220 --> 58:00.380
好

58:00.380 --> 58:01.260
比方说我们给

58:01.260 --> 58:02.700
服务器给它响应的一个

58:02.700 --> 58:03.820
响应头给它写个

58:03.820 --> 58:05.500
什么content type

58:06.940 --> 58:07.340
text

58:10.780 --> 58:11.100
play

58:12.140 --> 58:12.780
哦你看一下

58:12.780 --> 58:13.820
如果说我这样子写了

58:16.890 --> 58:17.210
刷新

58:18.090 --> 58:18.810
你看

58:18.810 --> 58:20.010
特别成这个样子的

58:20.010 --> 58:20.650
所以说

58:20.650 --> 58:21.130
我们知道

58:21.130 --> 58:22.970
科普端浏览器是在干嘛

58:22.970 --> 58:23.850
服务器很简单

58:23.850 --> 58:25.210
服务器就该响应这个

58:25.210 --> 58:26.090
浏览器一看

58:26.570 --> 58:27.610
服务器给我说了

58:28.570 --> 58:29.530
那个大哥给我说了

58:29.530 --> 58:30.490
我给你想应的东西

58:30.490 --> 58:32.010
那就是后面我给你想应的东西

58:32.010 --> 58:33.370
是一个纯文本

58:33.370 --> 58:35.210
那我就把当成纯文本来显示

58:35.210 --> 58:35.610
对吧

58:35.610 --> 58:36.890
我还是可以这样玩

58:36.890 --> 58:37.530
我给它响应

58:37.930 --> 58:39.050
我给它响应的是什么

58:39.050 --> 58:39.610
mg

58:40.890 --> 58:41.530
jpg

58:42.890 --> 58:44.090
但是这个是不是图片

58:44.090 --> 58:45.050
肯定是不是图片

58:45.050 --> 58:46.090
肯定不是图片

58:46.090 --> 58:47.050
那我来看一下吧

58:51.050 --> 58:51.370
这里呢

58:51.370 --> 58:52.090
我们来看

58:52.090 --> 58:52.490
刷新

58:53.370 --> 58:54.970
它就把它当成图片显示

58:54.970 --> 58:55.530
哎有的人说

58:56.170 --> 58:57.690
那我能不能给它想一个图片呢

58:57.690 --> 58:58.250
当然可以

58:58.250 --> 58:58.570
你看

58:58.970 --> 58:59.610
这样子来玩

59:00.570 --> 59:01.370
找一张图片吧

59:06.810 --> 59:07.290
27

59:09.960 --> 59:10.440
找一张

59:11.160 --> 59:11.720
就在那吧

59:12.520 --> 59:14.040
我们把图片复制一下

59:15.000 --> 59:16.200
复制到保存起来

59:17.240 --> 59:18.040
这里呢

59:18.040 --> 59:18.600
27

59:20.600 --> 59:22.360
加到我们的工程里面去

59:23.160 --> 59:23.880
然后这里呢

59:23.880 --> 59:25.880
我们只需要把这个图片内容读出来

59:25.880 --> 59:26.200
对吧

59:26.200 --> 59:28.200
这个图片内容读出来是一个buffer

59:28.200 --> 59:29.640
把这个图片内容读出来就行了

59:30.360 --> 59:30.760
来吧

59:30.760 --> 59:31.480
我们把它读出来

59:32.440 --> 59:33.000
这里边呢

59:33.000 --> 59:34.600
我们就可以导入这个fs模块

59:36.600 --> 59:37.000
require

59:39.000 --> 59:39.480
fs

59:40.600 --> 59:41.000
来吧

59:41.640 --> 59:42.520
我们这边呢

59:42.520 --> 59:44.680
收到了客户端的数据

59:44.680 --> 59:45.960
客户端的请求收到了

59:46.760 --> 59:47.640
收到了这个请求

59:49.480 --> 59:50.120
把这个注释掉

59:50.120 --> 59:51.720
总之我们这里收到了请求了

59:51.720 --> 59:52.280
收到了请求

59:52.280 --> 59:53.320
我说啥都不管了

59:53.320 --> 59:54.920
我就给它把图片内容读出来

59:54.920 --> 59:56.040
然后给它响应

59:56.040 --> 59:56.840
怎么来读呢

59:56.840 --> 59:57.400
fs

59:57.400 --> 59:58.120
对吧

59:58.120 --> 59:59.160
readfile

01:00:00.440 --> 01:00:01.000
promise

01:00:02.200 --> 01:00:03.240
promise

01:00:03.240 --> 01:00:04.040
readfile

01:00:04.840 --> 01:00:05.560
是不是读

01:00:05.560 --> 01:00:06.360
读内容

01:00:06.360 --> 01:00:07.080
对吧

01:00:07.080 --> 01:00:08.440
读的话

01:00:08.440 --> 01:00:10.120
我们把它得到这个

01:00:10.760 --> 01:00:13.000
得到当前目录下面的

01:00:13.000 --> 01:00:13.960
用这个吧

01:00:13.960 --> 01:00:15.080
用那个pass

01:00:17.640 --> 01:00:19.160
把之前的学生拿过来用一下

01:00:20.520 --> 01:00:20.920
pass

01:00:23.460 --> 01:00:23.860
好

01:00:23.860 --> 01:00:24.500
这边呢

01:00:24.500 --> 01:00:25.220
我们用pass

01:00:25.780 --> 01:00:26.260
result

01:00:27.220 --> 01:00:28.420
drl

01:00:28.420 --> 01:00:30.180
然后drl鞋杠

01:00:30.180 --> 01:00:30.900
27

01:00:30.900 --> 01:00:31.620
叫jpg

01:00:34.120 --> 01:00:35.080
这是我们的file

01:00:37.880 --> 01:00:39.400
我们要响应的时候

01:00:39.400 --> 01:00:40.440
这里用ersync

01:00:40.440 --> 01:00:41.480
把它变成一步函数

01:00:42.200 --> 01:00:43.640
我们等待它读取

01:00:43.640 --> 01:00:44.280
读取什么呢

01:00:44.280 --> 01:00:45.080
读取这个文件

01:00:45.880 --> 01:00:46.920
读取这个图片文件

01:00:49.320 --> 01:00:49.880
对不对

01:00:49.880 --> 01:00:50.520
读取它

01:00:51.880 --> 01:00:52.120
好

01:00:52.120 --> 01:00:54.440
读取它读完了之后

01:00:54.440 --> 01:00:55.800
读完了之后

01:00:55.800 --> 01:00:57.480
那么它会得到一个文件的内容

01:00:57.480 --> 01:00:58.120
也就是buffer

01:00:58.680 --> 01:00:59.000
buffer

01:01:00.760 --> 01:01:02.760
图片的内容

01:01:02.760 --> 01:01:04.360
那么这个buffer拿到之后

01:01:04.360 --> 01:01:05.800
拿到之后我们干嘛呢

01:01:05.880 --> 01:01:07.880
我们把前面的东西变成一个buffer

01:01:07.880 --> 01:01:08.600
对吧

01:01:08.600 --> 01:01:10.120
把前面的东西变成一个buffer

01:01:10.120 --> 01:01:10.760
就这一部分

01:01:11.960 --> 01:01:13.000
到这个换行

01:01:13.000 --> 01:01:13.720
这一部分

01:01:13.720 --> 01:01:14.600
把它变成一个buffer

01:01:15.720 --> 01:01:18.040
就是headbuffer

01:01:19.160 --> 01:01:20.040
这个是bodybuffer

01:01:20.600 --> 01:01:21.240
bodybuffer

01:01:22.040 --> 01:01:22.840
这是headbuffer

01:01:23.400 --> 01:01:24.680
那么bodybuffer呢

01:01:24.680 --> 01:01:25.560
来自于buffer

01:01:26.360 --> 01:01:26.680
from

01:01:28.120 --> 01:01:28.920
来自于哪呢

01:01:28.920 --> 01:01:29.720
来自于这个字幕上

01:01:32.680 --> 01:01:34.120
把前面的空格要去掉

01:01:34.120 --> 01:01:34.520
注意

01:01:35.320 --> 01:01:35.720
好了

01:01:35.720 --> 01:01:36.920
我们把这个地方搞定

01:01:37.640 --> 01:01:38.760
把它变成buffer

01:01:38.760 --> 01:01:39.560
UTF-8

01:01:41.400 --> 01:01:42.040
UTF-8

01:01:42.680 --> 01:01:42.920
好

01:01:42.920 --> 01:01:44.040
bodybuffer呢

01:01:44.040 --> 01:01:44.760
是为了带这个

01:01:44.760 --> 01:01:46.440
我们把两个buffer拼接起来

01:01:47.080 --> 01:01:48.520
咱们就这样的拼接

01:01:49.480 --> 01:01:49.880
buffer

01:01:51.400 --> 01:01:51.960
concrete

01:01:52.760 --> 01:01:53.560
一个数组

01:01:53.560 --> 01:01:55.560
把我们拼接的buffer放到数组里边

01:01:55.560 --> 01:01:56.440
一个是headbuffer

01:01:56.440 --> 01:01:57.240
先拼接它

01:01:57.240 --> 01:01:58.520
再拼接bodybuffer

01:01:58.520 --> 01:01:58.920
对吧

01:01:58.920 --> 01:01:59.880
得到一个新的buffer

01:02:01.320 --> 01:02:01.720
result

01:02:02.760 --> 01:02:03.160
最后呢

01:02:03.160 --> 01:02:04.280
我们把个result数出

01:02:04.920 --> 01:02:05.960
就通过这些例子

01:02:06.360 --> 01:02:06.920
告诉大家

01:02:06.920 --> 01:02:08.840
怎么去完成伏辑的响应

01:02:08.840 --> 01:02:11.480
顺便服辑一下之前的ut

01:02:11.480 --> 01:02:12.520
utp的指示

01:02:13.960 --> 01:02:14.360
好

01:02:14.360 --> 01:02:15.400
这里写好了

01:02:15.400 --> 01:02:16.520
然后有些地方呢

01:02:16.520 --> 01:02:17.880
你要注意一下

01:02:17.880 --> 01:02:19.080
像这些空格啊

01:02:19.080 --> 01:02:20.840
这些地方全都去掉啊

01:02:20.840 --> 01:02:22.840
中间不能有任何的一些乱七八糟的事

01:02:22.840 --> 01:02:23.400
不然的话

01:02:23.400 --> 01:02:23.800
他到时候

01:02:24.360 --> 01:02:25.320
那边解析不了

01:02:26.360 --> 01:02:26.600
好

01:02:26.600 --> 01:02:27.880
看一下有没有问题

01:02:28.440 --> 01:02:28.600
好

01:02:28.600 --> 01:02:29.320
没问题了

01:02:29.320 --> 01:02:30.360
应该是没问题了

01:02:30.360 --> 01:02:30.920
咱们运行

01:02:32.360 --> 01:02:32.600
好

01:02:32.680 --> 01:02:33.480
这边刷新

01:02:33.960 --> 01:02:34.440
你看

01:02:34.440 --> 01:02:35.400
是不是得到图片了

01:02:36.520 --> 01:02:37.080
对吧

01:02:37.080 --> 01:02:39.160
所以说我们平时想象的服务器

01:02:39.160 --> 01:02:39.960
那边怎么玩的

01:02:39.960 --> 01:02:40.920
就是这样子玩的

01:02:40.920 --> 01:02:42.520
不过我们现在写的很底层

01:02:42.520 --> 01:02:44.200
这样子写非常非常的麻烦

01:02:44.200 --> 01:02:44.680
对不对

01:02:44.680 --> 01:02:47.960
如果说我们要写一个addb服务器

01:02:47.960 --> 01:02:48.920
这么麻烦的话

01:02:49.880 --> 01:02:52.520
那我们要搭一个服务器太难了

01:02:52.520 --> 01:02:54.760
还不说出了一些业务逻辑问题

01:02:54.760 --> 01:02:57.240
光是搭一个服务器都这么麻烦

01:02:57.240 --> 01:02:58.200
所以说我们一般呢

01:02:58.200 --> 01:03:00.920
不会去用这个net模块来搭服务器

01:03:00.920 --> 01:03:02.440
但是通过一个net模块呢

01:03:02.520 --> 01:03:03.640
大家可以知道

01:03:03.640 --> 01:03:05.880
咱们的GDP原认一次这么回事

01:03:05.880 --> 01:03:08.040
就是一个请求格式的问题

01:03:08.040 --> 01:03:08.520
对吧

01:03:08.520 --> 01:03:10.600
已经连接谁在断开的问题

01:03:10.600 --> 01:03:12.200
谁在挂电话的问题

01:03:12.200 --> 01:03:13.880
过去的atcpip协议呢

01:03:13.880 --> 01:03:15.880
他不会轻易挂电话的

01:03:15.880 --> 01:03:16.840
那么atpip协议呢

01:03:16.840 --> 01:03:18.280
还会给你挂电话

01:03:18.280 --> 01:03:20.200
还会给你把电话挂掉

01:03:20.200 --> 01:03:22.280
每一次都是重新建立一个连接

01:03:22.280 --> 01:03:22.840
对吧

01:03:23.480 --> 01:03:24.840
已经来到请求格式

01:03:24.840 --> 01:03:25.720
大概是这个样子

01:03:26.360 --> 01:03:26.840
好

01:03:26.840 --> 01:03:28.040
我们这几颗学到过后呢

01:03:28.040 --> 01:03:29.320
你就对atb协议呢

01:03:29.320 --> 01:03:31.160
有了更深刻的理解了

01:03:31.160 --> 01:03:32.280
然后我们下节课呢

01:03:32.280 --> 01:03:33.800
就看atp模块

01:03:33.800 --> 01:03:36.680
可以怎么来更加轻松的来创建一个服务器

01:03:37.240 --> 01:03:37.480
好

01:03:37.480 --> 01:03:38.600
这是这节课的理解

