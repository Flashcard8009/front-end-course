WEBVTT

00:00.110 --> 00:04.110
好 这一刻来学习身份认证的最后一个知识

00:04.110 --> 00:05.110
就是GWT

00:06.110 --> 00:09.110
我现在是越来越喜欢去写这个文档了

00:09.110 --> 00:10.110
为什么呢

00:11.110 --> 00:14.110
就是很多在视频里边说不清楚的很多东西

00:14.110 --> 00:17.110
通过这个图文并冒的方式就可以解释得很清楚

00:17.110 --> 00:20.110
而且在写文档的过程中我可以反复的推销

00:20.110 --> 00:22.110
讲解的顺序 怎么去讲解

00:22.110 --> 00:23.110
这样子呢 大家好理解一点

00:23.110 --> 00:25.110
另外写文档有一个好处就在于

00:25.110 --> 00:26.110
有些同学想我啰嗦

00:26.110 --> 00:28.110
我也确实知道自己啰嗦

00:29.110 --> 00:31.110
这样子同学呢 他就可以直接看文档

00:31.110 --> 00:32.110
看文档是最快的 对吧

00:32.110 --> 00:36.110
让大家养成看文档的习惯 也挺好的

00:36.110 --> 00:39.110
所以说我这里就用文档的方式给大家表达吧

00:39.110 --> 00:42.110
好 这里我把拖进来

00:44.110 --> 00:45.110
当里边去

00:45.110 --> 00:46.110
好 咱们来看一下

00:47.110 --> 00:51.110
我们大致了解一下GWT它为什么会出现

00:51.110 --> 00:53.110
是主要的原因是有两个

00:53.110 --> 00:56.110
其实最重要的原因就是前后端分离了

00:56.110 --> 00:58.110
很多东西放到前端去完成了

00:58.110 --> 00:59.110
对吧

00:59.110 --> 01:01.110
而前端的大前端的环境

01:01.110 --> 01:03.110
现在是越来越丰富了

01:03.110 --> 01:06.110
比如说移动端 平板 桌面应用

01:06.110 --> 01:08.110
都算是前端的那种了

01:08.110 --> 01:09.110
所以说呢

01:09.110 --> 01:10.110
那么就会遇到一个问题

01:10.110 --> 01:13.110
我们就可能会建立一个数理中心

01:13.110 --> 01:15.110
这个数理中心可能会处理

01:15.110 --> 01:17.110
来自于各种端的这么一个请求

01:17.110 --> 01:19.110
给各种端提供服务

01:19.110 --> 01:21.110
数理中心一般是后端建立的

01:21.110 --> 01:22.110
我们前端一般不用管

01:22.110 --> 01:24.110
但是我们学这个loader接式

01:24.110 --> 01:26.110
要考虑一下服务器

01:26.110 --> 01:28.110
毕竟是我们学的服务器

01:28.110 --> 01:30.110
我们学loader接式的目的是

01:30.110 --> 01:32.110
其实倒不是真的让里面的公司

01:32.110 --> 01:33.110
里面去开发服务器

01:33.110 --> 01:35.110
这种情况很少很少

01:35.110 --> 01:36.110
主要是你要理解后端

01:36.110 --> 01:38.110
因为后端能理解前端

01:38.110 --> 01:41.110
前端很少的前端能够理解后端

01:41.110 --> 01:43.110
所以说为了方便以后

01:43.110 --> 01:45.110
跟同时远近交流

01:45.110 --> 01:48.110
所以说还是要理解后端一些东西

01:48.110 --> 01:50.110
那么学做数理中心的建立

01:50.110 --> 01:51.110
越来越多的公司

01:51.110 --> 01:53.110
会创建一个中心服务器

01:53.110 --> 01:55.110
不予各种产品线

01:55.110 --> 01:57.110
比方说咱们qq

01:57.110 --> 01:58.110
就是腾讯

01:58.110 --> 01:59.110
腾讯是不是有很多产品线

01:59.110 --> 02:01.110
腾讯客厂算一个吧

02:01.110 --> 02:02.110
qq 微信

02:02.110 --> 02:04.110
空间还有邮箱

02:04.110 --> 02:05.110
是不是有很多产品线

02:05.110 --> 02:06.110
对不对

02:06.110 --> 02:07.110
不同的产品线

02:07.110 --> 02:08.110
可能有不同的中端

02:08.110 --> 02:10.110
不同的中端应用

02:10.110 --> 02:12.110
那么我们可能会提供一个

02:12.110 --> 02:13.110
中心服务器来服务

02:13.110 --> 02:15.110
这些不同的产品线

02:15.110 --> 02:17.110
那么既然这个中心服务器

02:17.110 --> 02:19.110
还要为各种中端来提供支持

02:19.110 --> 02:21.110
所以说

02:21.110 --> 02:23.110
它就不能假设中端

02:23.110 --> 02:24.110
就一定是浏览器

02:24.110 --> 02:26.110
比方说我们之前用什么QQ

02:26.110 --> 02:27.110
用QQ来存处

02:27.110 --> 02:28.110
在QQ里边去做文章

02:28.110 --> 02:29.110
只有浏览器才有QQ

02:29.110 --> 02:31.110
像什么平凡的英雄

02:31.110 --> 02:32.110
根本就没有QQ

02:32.110 --> 02:33.110
像桌面的英雄

02:33.110 --> 02:34.110
更加不存在那么QQ了

02:36.110 --> 02:37.110
实际上还是有

02:37.110 --> 02:38.110
还有这种情况

02:38.110 --> 02:39.110
不同的产品线

02:39.110 --> 02:40.110
它通常有自己的服务器

02:40.110 --> 02:42.110
比方说咱们的空间

02:42.110 --> 02:43.110
可能QQ空间

02:43.110 --> 02:45.110
可能有个服务器

02:45.110 --> 02:47.110
有相当可能有个服务器

02:47.110 --> 02:49.110
但是这些服务器

02:49.110 --> 02:50.110
他们为自己的产品

02:50.110 --> 02:51.110
提供支持

02:51.110 --> 02:52.110
但是一般来说

02:52.110 --> 02:54.110
同一家公司的不同产品

02:54.110 --> 02:56.110
它一般还是会建立一个中心服务器

02:56.110 --> 02:58.110
因为这些不同的产品之间

02:58.110 --> 03:00.110
肯定有一些数据是共享的

03:00.110 --> 03:01.110
然后空间里边

03:01.110 --> 03:03.110
是不是可以通过QQ来登录

03:03.110 --> 03:04.110
对不对

03:04.110 --> 03:05.110
微信是不是也可以

03:05.110 --> 03:07.110
微信好像一开始好像是可以

03:07.110 --> 03:08.110
一开始微信出来的时候

03:08.110 --> 03:09.110
是可以用QQ登录的

03:09.110 --> 03:10.110
对不对

03:10.110 --> 03:11.110
所以说

03:11.110 --> 03:14.110
他们有共同的数据共享

03:14.110 --> 03:15.110
所以说还是要提供

03:15.110 --> 03:17.110
一些中心服务器

03:17.110 --> 03:18.110
因此中心服务器

03:18.110 --> 03:20.110
这种在我们现代的

03:20.110 --> 03:21.110
特别是大公司里边

03:21.110 --> 03:22.110
是非常常见的

03:22.110 --> 03:24.110
它为各种设备提供支持

03:24.110 --> 03:26.110
中心服务器至少

03:26.110 --> 03:27.110
它会承担一个功能

03:27.110 --> 03:29.110
就是认证和授权

03:29.110 --> 03:30.110
比方登录

03:30.110 --> 03:32.110
我们用同一个登录线

03:32.110 --> 03:33.110
就单点登录

03:33.110 --> 03:35.110
同一个服务器来进行登录

03:35.110 --> 03:36.110
那么各种设备

03:36.110 --> 03:37.110
它会发动消息到中心服务器

03:37.110 --> 03:38.110
然后中心服务器

03:38.110 --> 03:40.110
响应一个身份定牌

03:40.110 --> 03:41.110
我们之前科学原理

03:41.110 --> 03:42.110
是不是讲过的

03:42.110 --> 03:43.110
对不对

03:43.110 --> 03:45.110
那么这个解构出来过后

03:45.110 --> 03:46.110
它就出现一个问题

03:46.110 --> 03:47.110
它们之间

03:47.110 --> 03:49.110
还能不能使用传统的

03:49.110 --> 03:51.110
这种Cookie传递定牌的信息

03:51.110 --> 03:52.110
能不能呢

03:52.110 --> 03:54.110
其实还是可以的

03:54.110 --> 03:55.110
只是

03:55.110 --> 03:56.110
你看

03:56.110 --> 03:57.110
浏览器肯定是可以的

03:57.110 --> 03:58.110
对吧

03:58.110 --> 03:59.110
因为浏览器里边有Cookie

03:59.110 --> 04:00.110
那么其他设备

04:00.110 --> 04:01.110
能不能使用Cookie

04:01.110 --> 04:02.110
其实还是可以

04:02.110 --> 04:03.110
因为Cookie的本质

04:03.110 --> 04:04.110
它无非就是

04:04.110 --> 04:05.110
在传输的过程中

04:05.110 --> 04:06.110
一个消息头而已

04:06.110 --> 04:07.110
对不对

04:07.110 --> 04:09.110
你们回忆一下Cookie

04:09.110 --> 04:10.110
Cookie的时候

04:10.110 --> 04:11.110
是不是服务器

04:11.110 --> 04:12.110
不管它怎么来的

04:12.110 --> 04:13.110
服务器它给我

04:13.110 --> 04:14.110
用了一个消息头

04:14.110 --> 04:15.110
就SetCookie

04:15.110 --> 04:16.110
一段数据

04:16.110 --> 04:18.110
只不过浏览器

04:18.110 --> 04:19.110
对这个消息头

04:19.110 --> 04:20.110
它有特殊处理

04:20.110 --> 04:21.110
它自动的把它

04:21.110 --> 04:22.110
加到了一个Cookie里边去了

04:22.110 --> 04:23.110
对吧

04:23.110 --> 04:24.110
那么其他设备里边

04:24.110 --> 04:25.110
你可以手动处理

04:25.110 --> 04:26.110
对不对

04:26.110 --> 04:27.110
开发者可以手动处理

04:27.110 --> 04:28.110
读取这个响应头

04:28.110 --> 04:29.110
然后我手动

04:29.110 --> 04:31.110
把它保存到另外一个地方

04:31.110 --> 04:32.110
对不对

04:32.110 --> 04:33.110
只不过

04:33.110 --> 04:34.110
它不是一种

04:34.110 --> 04:35.110
很好的标准

04:35.110 --> 04:37.110
你这样子的处理起来

04:37.110 --> 04:38.110
看上去

04:38.110 --> 04:39.110
就不像是浏览器里边

04:39.110 --> 04:40.110
出来的

04:40.110 --> 04:41.110
对不对

04:41.110 --> 04:42.110
而且还涉及到

04:42.110 --> 04:43.110
一些安全性的问题

04:43.110 --> 04:44.110
因为必须要去

04:44.110 --> 04:45.110
浏览器里边

04:45.110 --> 04:46.110
是不是有安全机制

04:46.110 --> 04:47.110
比方说什么

04:47.110 --> 04:48.110
不允许用介事

04:48.110 --> 04:49.110
来读取Cookie

04:49.110 --> 04:50.110
对吧

04:50.110 --> 04:51.110
如果设置了ADP Only

04:51.110 --> 04:52.110
或者说

04:52.110 --> 04:53.110
浏览器

04:53.110 --> 04:54.110
它在请求服务器的时候

04:54.110 --> 04:55.110
它只会发送

04:55.110 --> 04:57.110
跟这个匹配的Cookie

04:57.110 --> 04:58.110
对不对

04:58.110 --> 04:59.110
所以有些安全机制

04:59.110 --> 05:00.110
那其他设备是没有的

05:00.110 --> 05:02.110
你要需要去手动处理

05:02.110 --> 05:03.110
对不对

05:03.110 --> 05:04.110
因此

05:04.110 --> 05:05.110
基于这些原因

05:05.110 --> 05:06.110
用Cookie

05:06.110 --> 05:07.110
肯定可以

05:07.110 --> 05:08.110
但是不是很合适

05:08.110 --> 05:09.110
所以说

05:09.110 --> 05:10.110
JWT就出现了

05:10.110 --> 05:11.110
JWT出现

05:11.110 --> 05:12.110
它就是为了

05:12.110 --> 05:13.110
解决这个问题的

05:13.110 --> 05:14.110
用一套统一的规范

05:14.110 --> 05:16.110
无论什么样的中端设备

05:16.110 --> 05:17.110
我都可以用

05:17.110 --> 05:19.110
同样的规范来进行处理

05:19.110 --> 05:20.110
好

05:20.110 --> 05:21.110
我们来看一下JWT

05:21.110 --> 05:23.110
它是全称

05:23.110 --> 05:25.110
叫做JSON Web Token

05:25.110 --> 05:26.110
这东西怎么翻译

05:26.110 --> 05:27.110
我也不知道怎么翻译

05:27.110 --> 05:28.110
我就强行把它翻译成

05:28.110 --> 05:30.110
JSON格式的互联网令牌

05:30.110 --> 05:31.110
其实它强行翻译的

05:31.110 --> 05:32.110
确实

05:32.110 --> 05:33.110
手动

05:33.110 --> 05:34.110
这个emoji表情

05:34.110 --> 05:35.110
这个东西

05:35.110 --> 05:36.110
说一下

05:36.110 --> 05:37.110
这个emoji表情

05:37.110 --> 05:38.110
我确实觉得

05:38.110 --> 05:39.110
没有那个

05:39.110 --> 05:41.110
微信表情那么丰富

05:41.110 --> 05:42.110
就是有些感情

05:42.110 --> 05:43.110
表达不了

05:43.110 --> 05:44.110
比方说

05:44.110 --> 05:45.110
特别想打一个手动狗头

05:45.110 --> 05:46.110
但是打不出来

05:46.110 --> 05:48.110
emoji表情里面没有

05:48.110 --> 05:49.110
就是这么一个意思

05:49.110 --> 05:50.110
它强行翻译

05:50.110 --> 05:51.110
不好翻译

05:51.110 --> 05:52.110
它总之叫JWT

05:52.110 --> 05:53.110
就是一个

05:53.110 --> 05:54.110
JSON格式的

05:54.110 --> 05:56.110
在互联网传输的

05:56.110 --> 05:57.110
一个令牌

05:57.110 --> 05:58.110
所以说

05:58.110 --> 05:59.110
JSON它本质

05:59.110 --> 06:01.110
就是一个令牌

06:01.110 --> 06:02.110
它要解决的问题

06:02.110 --> 06:04.110
就是为各种中端设备

06:04.110 --> 06:06.110
提供统一的

06:06.110 --> 06:08.110
安全的令牌格式

06:08.110 --> 06:10.110
那么JSONJWT

06:10.110 --> 06:12.110
它只是一个令牌而已

06:12.110 --> 06:13.110
所以说你可以把它

06:13.110 --> 06:14.110
储存到cookie里面

06:14.110 --> 06:15.110
也可以把它存储到

06:15.110 --> 06:16.110
locust storage

06:16.110 --> 06:17.110
它没有任何限制

06:17.110 --> 06:19.110
同样的对于传输

06:19.110 --> 06:20.110
它也没有限制

06:20.110 --> 06:21.110
比方你怎么去传输

06:21.110 --> 06:23.110
这个JWT

06:23.110 --> 06:24.110
你可以把它放到

06:24.110 --> 06:25.110
消息头里面

06:25.110 --> 06:26.110
也可以把它放到

06:26.110 --> 06:27.110
消息体里面

06:27.110 --> 06:28.110
随便你放哪

06:28.110 --> 06:29.110
都无所谓

06:29.110 --> 06:30.110
它没有限制你

06:30.110 --> 06:31.110
一般来说的话

06:31.110 --> 06:32.110
我们会把它

06:32.110 --> 06:33.110
放到消息头里面

06:33.110 --> 06:34.110
但这不是一定的

06:34.110 --> 06:35.110
比方说

06:35.110 --> 06:36.110
当我们登入成功之后

06:36.110 --> 06:37.110
服务器给客户端

06:37.110 --> 06:38.110
响应一个JWT

06:38.110 --> 06:39.110
响应这种格式

06:39.110 --> 06:40.110
你可以在cookie里面

06:40.110 --> 06:42.110
给把令牌给它

06:42.110 --> 06:43.110
可不可以也可以

06:43.110 --> 06:45.110
你可以在authorization里面

06:45.110 --> 06:46.110
单独来建一个

06:46.110 --> 06:47.110
响应头随便取个名字

06:47.110 --> 06:49.110
比方说authorization表示授权

06:49.110 --> 06:51.110
给它个JWT令牌

06:51.110 --> 06:52.110
都可以

06:52.110 --> 06:54.110
或者是能在消息体里面

06:54.110 --> 06:55.110
给它响应一个JWT令牌

06:55.110 --> 06:56.110
都行

06:56.110 --> 06:57.110
它没有限制你

06:57.110 --> 06:58.110
怎么去响应

06:58.110 --> 07:00.110
我看到网上有些文章说

07:00.110 --> 07:02.110
那个使用了JWT过后

07:02.110 --> 07:05.110
它就不能使用cookie了

07:05.110 --> 07:07.110
这完全是两码事了

07:07.110 --> 07:08.110
完全跟cookie没有什么关系

07:08.110 --> 07:10.110
它只是一个传输格式而已

07:10.110 --> 07:12.110
你挨把它放到哪儿

07:12.110 --> 07:13.110
就放到哪儿

07:13.110 --> 07:14.110
所以说JWT令牌

07:14.110 --> 07:15.110
它可以出现在

07:15.110 --> 07:16.110
响应的任何地方

07:16.110 --> 07:18.110
客户端服务器自行约定就行了

07:18.110 --> 07:20.110
你们自行约定

07:20.110 --> 07:22.110
当然它也可以出现在

07:22.110 --> 07:23.110
响应的多个地方

07:23.110 --> 07:25.110
比方说你同时出现行不行

07:25.110 --> 07:26.110
也可以

07:26.110 --> 07:27.110
比方说你这样子做

07:27.110 --> 07:28.110
就是为了什么

07:28.110 --> 07:29.110
一是为了

07:29.110 --> 07:30.110
照顾一下浏览器

07:30.110 --> 07:31.110
浏览器用cookie

07:31.110 --> 07:32.110
肯定是非常方便的

07:32.110 --> 07:34.110
它会自动给你发送

07:34.110 --> 07:35.110
非常方便

07:35.110 --> 07:36.110
另外也可以照顾一下

07:36.110 --> 07:37.110
其他设备

07:37.110 --> 07:38.110
都可以照顾一下

07:38.110 --> 07:39.110
所以说

07:39.110 --> 07:42.110
这个东西不用去强行规定

07:42.110 --> 07:44.110
它也可以出现在多个地方

07:44.110 --> 07:45.110
总之当客户端

07:45.110 --> 07:46.110
可以拿到这个令牌

07:46.110 --> 07:48.110
无论你用什么方式

07:48.110 --> 07:50.110
客户端一定可以拿到这个令牌

07:50.110 --> 07:51.110
拿到这个令牌过后

07:51.110 --> 07:52.110
它要做的只有一件事

07:52.110 --> 07:53.110
就存出它

07:53.110 --> 07:55.110
至于怎么去存出

07:55.110 --> 07:56.110
无所谓的

07:56.110 --> 07:57.110
比方说你是

07:57.110 --> 07:59.110
移动端手机

07:59.110 --> 08:00.110
那么你存出的时候

08:00.110 --> 08:01.110
可以存出一个手机文件

08:01.110 --> 08:03.110
把它存出到缓存里边

08:03.110 --> 08:05.110
或者是你是一个桌面

08:05.110 --> 08:06.110
应用

08:06.110 --> 08:07.110
你可以把它存出到

08:07.110 --> 08:09.110
电脑的操作系统的文件里边

08:09.110 --> 08:11.110
或者是你是浏览器应用

08:11.110 --> 08:12.110
那么你存出到

08:12.110 --> 08:13.110
loc storage

08:13.110 --> 08:14.110
或者是cookie里边都可以

08:14.110 --> 08:16.110
它没有限制的

08:16.110 --> 08:18.110
当后续请求发生的时候

08:18.110 --> 08:19.110
客户端只需要做一件事

08:19.110 --> 08:21.110
就是把这个令牌

08:21.110 --> 08:23.110
作为请求的一部分

08:23.110 --> 08:24.110
发送到服务器

08:24.110 --> 08:25.110
那么至于

08:25.110 --> 08:26.110
怎么样把它作为

08:26.110 --> 08:27.110
请求的一部分发送到服务器

08:27.110 --> 08:28.110
它也没有规定

08:28.110 --> 08:29.110
只不过

08:29.110 --> 08:31.110
我们通常情况下

08:31.110 --> 08:33.110
会使用这种格式

08:33.110 --> 08:34.110
加一个请求头

08:34.110 --> 08:35.110
authorization

08:35.110 --> 08:37.110
然后加一个barrier

08:37.110 --> 08:38.110
barrier

08:38.110 --> 08:39.110
不要这么意思

08:39.110 --> 08:41.110
表示那个附带的意思

08:41.110 --> 08:42.110
就是承诞

08:42.110 --> 08:43.110
顺便搭一个东西

08:43.110 --> 08:44.110
搭一个什么

08:44.110 --> 08:46.110
GW令牌

08:46.110 --> 08:47.110
这种格式实际上

08:47.110 --> 08:49.110
是一个ostude格式

08:49.110 --> 08:50.110
这种ostude

08:50.110 --> 08:51.110
我们

08:51.110 --> 08:52.110
路德杰斯不做讲解

08:52.110 --> 08:53.110
我们在那个

08:53.110 --> 08:54.110
就是第三方接口

08:54.110 --> 08:55.110
当时一个客

08:55.110 --> 08:56.110
我看

08:56.110 --> 08:57.110
现在好像咱们还没有

08:57.110 --> 08:58.110
对不对

08:58.110 --> 08:59.110
估计吧

08:59.110 --> 09:00.110
后边

09:00.110 --> 09:01.110
还是得我来录

09:01.110 --> 09:02.110
这个客

09:02.110 --> 09:03.110
哎呀

09:03.110 --> 09:04.110
这个事情太多了

09:04.110 --> 09:05.110
后边还要录

09:05.110 --> 09:06.110
移动端还要录这个

09:06.110 --> 09:07.110
到时候规划一下吧

09:07.110 --> 09:08.110
看你呢

09:08.110 --> 09:09.110
首先录哪一个

09:09.110 --> 09:11.110
到时候我来录吧

09:11.110 --> 09:12.110
这个客

09:12.110 --> 09:13.110
就是跟什么微信登录

09:13.110 --> 09:14.110
QQ登录

09:14.110 --> 09:15.110
就是

09:15.110 --> 09:16.110
转账

09:16.110 --> 09:17.110
对吧

09:17.110 --> 09:18.110
付款

09:18.110 --> 09:19.110
还有什么

09:19.110 --> 09:20.110
发送邮件

09:20.110 --> 09:21.110
发送短信

09:21.110 --> 09:22.110
对吧

09:22.110 --> 09:23.110
这些都要用

09:23.110 --> 09:24.110
到底三方接口

09:24.110 --> 09:25.110
包括什么

09:25.110 --> 09:26.110
人工智能客服

09:26.110 --> 09:27.110
这些东西

09:27.110 --> 09:28.110
到时候再说吧

09:28.110 --> 09:30.110
这又是一个双

09:30.110 --> 09:31.110
好

09:31.110 --> 09:32.110
那么这样一来呢

09:32.110 --> 09:33.110
服务器呢

09:33.110 --> 09:34.110
他就能够收到这个零牌了

09:34.110 --> 09:35.110
对吧

09:35.110 --> 09:36.110
因为客服端发过来了

09:36.110 --> 09:37.110
那么通过对令牌的验证

09:37.110 --> 09:38.110
就可以知道

09:38.110 --> 09:39.110
这个令牌是否有效

09:39.110 --> 09:40.110
整个交互过程

09:40.110 --> 09:41.110
是非常简单的

09:41.110 --> 09:42.110
我们来看一下吧

09:42.110 --> 09:43.110
他跟那个QQ差不多

09:43.110 --> 09:44.110
就是你任何一个客服端

09:44.110 --> 09:45.110
请求过来了

09:45.110 --> 09:46.110
登录嘛

09:46.110 --> 09:47.110
请求过来了

09:47.110 --> 09:48.110
然后呢

09:48.110 --> 09:49.110
服务器一验证

09:49.110 --> 09:50.110
登录成功

09:50.110 --> 09:51.110
于是呢

09:51.110 --> 09:52.110
我就给你通过某一种模式

09:52.110 --> 09:54.110
给你生成一个JWT

09:54.110 --> 09:55.110
令牌

09:55.110 --> 09:56.110
然后通过某一种方式

09:56.110 --> 09:57.110
来传给你

09:57.110 --> 09:59.110
客服端拿到一个JWT

09:59.110 --> 10:00.110
然后就保存起来

10:00.110 --> 10:01.110
好

10:01.110 --> 10:02.110
那么后续的请求里边呢

10:02.110 --> 10:03.110
客服端这边

10:03.110 --> 10:04.110
不是保存了令牌吗

10:04.110 --> 10:05.110
对吧

10:05.110 --> 10:06.110
他就把令牌给我带过来

10:06.110 --> 10:07.110
好

10:07.110 --> 10:08.110
带过来之后呢

10:08.110 --> 10:09.110
服务器这边

10:09.110 --> 10:10.110
他就把这个令牌验证

10:10.110 --> 10:11.110
看一下行不行

10:11.110 --> 10:12.110
这个令牌是不正确的

10:12.110 --> 10:13.110
好

10:13.110 --> 10:14.110
验证完了过后呢

10:14.110 --> 10:15.110
就完成响应

10:15.110 --> 10:16.110
如果验证通过了

10:16.110 --> 10:17.110
就完成正常响应

10:17.110 --> 10:18.110
就完事了

10:18.110 --> 10:19.110
验证不通过

10:19.110 --> 10:20.110
你看一下怎么来

10:20.110 --> 10:21.110
给他一个错误消息

10:21.110 --> 10:22.110
就完事了

10:22.110 --> 10:23.110
整个过程是非常简单的

10:23.110 --> 10:24.110
好

10:24.110 --> 10:25.110
那么这里就把这个

10:25.110 --> 10:26.110
令牌的交互就说完了

10:26.110 --> 10:27.110
接下来我们来说

10:27.110 --> 10:28.110
令牌的组成

10:28.110 --> 10:29.110
就这个JWT令牌

10:29.110 --> 10:30.110
到底是一个什么样的格式

10:30.110 --> 10:31.110
其实他就规定了

10:31.110 --> 10:32.110
它是什么样的格式

10:32.110 --> 10:34.110
其他就没了

10:34.110 --> 10:35.110
就是它是一个规范

10:35.110 --> 10:37.110
它规定了它是什么样的格式

10:37.110 --> 10:38.110
至于你用什么样的枯

10:38.110 --> 10:39.110
把它这个格式造出来

10:39.110 --> 10:40.110
随便你

10:40.110 --> 10:41.110
只要你满足我的规范就行了

10:41.110 --> 10:42.110
它的令牌呢

10:42.110 --> 10:43.110
它是有三个部分组成

10:43.110 --> 10:44.110
一个是header

10:44.110 --> 10:45.110
一个是payload

10:45.110 --> 10:46.110
一个是signature

10:47.110 --> 10:48.110
header部分呢

10:48.110 --> 10:49.110
是令牌的头部

10:49.110 --> 10:50.110
它主要记住了

10:50.110 --> 10:51.110
令牌的内情和签名算法

10:51.110 --> 10:52.110
我们这里一会再说

10:52.110 --> 10:53.110
payload呢

10:53.110 --> 10:54.110
payload是令牌的负荷

10:54.110 --> 10:56.110
就是有点类似 with redox

10:56.110 --> 10:57.110
里边的payload

10:57.110 --> 10:59.110
就比如说是负债信息

10:59.110 --> 11:00.110
表示令牌的主体信息

11:00.110 --> 11:03.110
就是主要的数据在这里边

11:03.110 --> 11:04.110
第三部分是signature

11:04.110 --> 11:06.110
表示令牌签名

11:06.110 --> 11:07.110
它主要是为了安全性

11:07.110 --> 11:09.110
保证安全性的

11:09.110 --> 11:10.110
这三个部分组合起来

11:10.110 --> 11:11.110
它的完整格式就是

11:11.110 --> 11:12.110
header

11:12.110 --> 11:13.110
第二

11:13.110 --> 11:14.110
payload

11:14.110 --> 11:15.110
第二signature

11:15.110 --> 11:16.110
没了

11:16.110 --> 11:17.110
比方说

11:17.110 --> 11:18.110
一个完整的JWT令牌的话

11:18.110 --> 11:20.110
应该差不多是这种格式

11:20.110 --> 11:21.110
header

11:21.110 --> 11:22.110
第二

11:22.110 --> 11:23.110
你看

11:23.110 --> 11:24.110
payload

11:24.110 --> 11:25.110
第二

11:25.110 --> 11:26.110
然后signature

11:26.110 --> 11:27.110
后边一个底

11:27.110 --> 11:29.110
就这么一种格式

11:29.110 --> 11:30.110
没了意思吧

11:30.110 --> 11:33.110
这是关于这个令牌

11:33.110 --> 11:35.110
JWT令牌

11:35.110 --> 11:36.110
这是这一部分

11:36.110 --> 11:37.110
好

11:37.110 --> 11:38.110
接下来我们对

11:38.110 --> 11:40.110
分别对这三个部分的

11:40.110 --> 11:41.110
作出讲解

11:41.110 --> 11:42.110
看每一个部分到底是啥

11:42.110 --> 11:44.110
首先让我们看header

11:44.110 --> 11:45.110
header

11:45.110 --> 11:48.110
它叫做令牌的头部

11:48.110 --> 11:49.110
它就记住了

11:49.110 --> 11:51.110
整个令牌的内情和签名算法

11:51.110 --> 11:52.110
一般来说header

11:52.110 --> 11:54.110
我们不会去改动它

11:54.110 --> 11:55.110
一般就是这个东西

11:55.110 --> 11:56.110
就这个东西

11:56.110 --> 11:57.110
是一个阶层对象

11:57.110 --> 11:59.110
那么这个阶层对象里面

11:59.110 --> 12:00.110
不是有两个属性吗

12:00.110 --> 12:01.110
第一个属性叫做

12:01.110 --> 12:02.110
这个东西叫啥呢

12:02.110 --> 12:03.110
它是个简器

12:03.110 --> 12:05.110
叫算法单词的简器

12:05.110 --> 12:07.110
算法单词叫啥呢

12:07.110 --> 12:08.110
我查一下

12:08.110 --> 12:12.900
算法

12:12.900 --> 12:14.900
算法

12:14.900 --> 12:15.900
叫做

12:15.900 --> 12:16.900
这个东西咋读啊

12:16.900 --> 12:17.900
这个

12:17.900 --> 12:21.530
看一下它多

12:21.530 --> 12:23.530
algorithm

12:24.530 --> 12:25.530
algorithm

12:25.530 --> 12:26.530
就是个算法

12:26.530 --> 12:27.530
算法的意思

12:27.530 --> 12:29.530
那么这个提供一个算法

12:29.530 --> 12:30.530
这个算法啥意思呢

12:30.530 --> 12:31.530
是个加密算法

12:31.530 --> 12:33.530
这个加密算法用来做什么呢

12:33.530 --> 12:35.530
它是为第三部分服务的

12:35.530 --> 12:37.530
也就是第三部分它要进行加密

12:37.530 --> 12:39.530
它到时候加密的时候

12:39.530 --> 12:40.530
要用什么样的加密算法

12:40.530 --> 12:42.530
就在这里给它指定

12:42.530 --> 12:44.530
那么这个地方指定的时候

12:44.530 --> 12:46.530
一般来说我们会写两种

12:46.530 --> 12:47.530
一个是

12:47.530 --> 12:48.530
HS256

12:48.530 --> 12:49.530
这个算法

12:49.530 --> 12:51.530
它指的是一个对象加密算法

12:51.530 --> 12:53.530
这个对象加密算法就是

12:53.530 --> 12:55.530
我们之前讲过对象加密

12:55.530 --> 12:57.530
就是用一个密钥进行加密

12:57.530 --> 12:59.530
用同一个密钥进行解密

12:59.530 --> 13:01.530
就对象加密

13:01.530 --> 13:03.530
如果说你指定另外一种

13:03.530 --> 13:05.530
另外一种有的时候也会用

13:05.530 --> 13:06.530
就是HS256

13:06.530 --> 13:08.530
它是用一种非对象的加密算法

13:08.530 --> 13:10.530
用私钥加密公钥解密

13:10.530 --> 13:12.530
就是两种算法的意思

13:12.530 --> 13:14.530
那么第二个属性的叫Type

13:14.530 --> 13:15.530
类型

13:15.530 --> 13:17.530
就整个另外一种类型

13:17.530 --> 13:19.530
固定写JWT就行了

13:19.530 --> 13:20.530
它只是一种格式

13:20.530 --> 13:21.530
那么这个header

13:21.530 --> 13:22.530
那有些人就说了

13:22.530 --> 13:23.530
这个header

13:23.530 --> 13:24.530
它不是个对象

13:24.530 --> 13:25.530
为什么这里是变成这个玩意

13:25.530 --> 13:26.530
对吧

13:26.530 --> 13:27.530
那怎么回事呢

13:27.530 --> 13:28.530
它是这样子的

13:28.530 --> 13:30.530
它的header的生成

13:30.530 --> 13:32.530
是把这个header部分

13:32.530 --> 13:34.530
使用BS64 URL编码

13:34.530 --> 13:36.530
我简单说一下

13:36.530 --> 13:37.530
这个东西是一种算法

13:37.530 --> 13:38.530
它不是什么加密

13:38.530 --> 13:40.530
它就是一种编码算法而已

13:40.530 --> 13:42.530
它是这样子

13:42.530 --> 13:43.530
BS64 URL

13:43.530 --> 13:44.530
它不是个加密算法

13:44.530 --> 13:45.530
它是一种编码方式

13:45.530 --> 13:48.530
它是在BS64算法的基础上

13:48.530 --> 13:50.530
对三个特殊制服

13:50.530 --> 13:52.530
做出特殊处理

13:52.530 --> 13:54.530
那么这个BS64算法

13:54.530 --> 13:55.530
又是什么算法呢

13:55.530 --> 13:57.530
BS64它是使用64个

13:57.530 --> 13:59.530
可打印制服

13:59.530 --> 14:01.530
来表示一个二净值数据

14:01.530 --> 14:02.530
具体的做法

14:02.530 --> 14:03.530
你直接看一下

14:03.530 --> 14:04.530
百多百克就行了

14:04.530 --> 14:05.530
也不用看

14:05.530 --> 14:06.530
了解一下就行了

14:06.530 --> 14:09.530
就是相当于是一个64净值

14:09.530 --> 14:10.530
比方说我们这个

14:10.530 --> 14:12.530
节省格式的对象

14:12.530 --> 14:13.530
不就是一个制服窗吗

14:13.530 --> 14:14.530
对吧

14:14.530 --> 14:15.530
你把这个制服窗

14:15.530 --> 14:16.530
先转成U贴服8

14:16.530 --> 14:18.530
那是不是用U贴服8

14:18.530 --> 14:19.530
把它转成一个二净值的

14:19.530 --> 14:20.530
对吧

14:20.530 --> 14:21.530
就是一个buffer数据

14:21.530 --> 14:23.530
然后对这个二净值的buffer数据

14:23.530 --> 14:25.530
再进行BS64编码

14:25.530 --> 14:26.530
然后呢

14:26.530 --> 14:28.530
就得到了一个制服窗了

14:28.530 --> 14:30.530
那么BS64这个制服窗里边

14:30.530 --> 14:32.530
可能有三个特殊符号

14:32.530 --> 14:34.530
就加等于和写纲

14:34.530 --> 14:36.530
有这三个特殊符号

14:36.530 --> 14:37.530
而这三个特殊符号

14:37.530 --> 14:39.530
因为这个JWT

14:39.530 --> 14:40.530
它的想法是

14:40.530 --> 14:42.530
将来这个JWT

14:42.530 --> 14:43.530
也可以再放到一个

14:43.530 --> 14:44.530
地址男参数里边

14:44.530 --> 14:46.530
给它传过去

14:46.530 --> 14:47.530
有意思吧

14:47.530 --> 14:48.530
它不仅仅是可以放到

14:48.530 --> 14:49.530
那个请求头里边

14:49.530 --> 14:50.530
你可以放到任何地方

14:50.530 --> 14:51.530
你可以放到地址男参数

14:51.530 --> 14:52.530
就query里边

14:52.530 --> 14:53.530
给它传过去也行

14:53.530 --> 14:54.530
而放到query里边

14:54.530 --> 14:55.530
是不是要设计到

14:55.530 --> 14:56.530
一些特殊符制服

14:56.530 --> 14:57.530
对吧

14:57.530 --> 14:58.530
因此呢

14:58.530 --> 14:59.530
它对这些BS64

14:59.530 --> 15:00.530
加密出来的特殊制服

15:00.530 --> 15:01.530
进行处理

15:01.530 --> 15:02.530
比方加号

15:02.530 --> 15:03.530
等号写纲

15:03.530 --> 15:04.530
来进行特殊处理

15:04.530 --> 15:05.530
它会把加号的变

15:05.530 --> 15:06.530
给它去掉

15:06.530 --> 15:07.530
然后

15:07.530 --> 15:08.530
它会把等号去掉

15:08.530 --> 15:10.530
加号了变成减号

15:10.530 --> 15:12.530
然后它写纲了变成下滑线

15:12.530 --> 15:13.530
它会做这么一种处理

15:13.530 --> 15:14.530
就这么个意思

15:15.530 --> 15:16.530
那么浏览器里边

15:16.530 --> 15:17.530
因为我们load里边

15:17.530 --> 15:18.530
还没有提供

15:18.530 --> 15:19.530
浏览器里边提供了

15:19.530 --> 15:20.530
这个B2A函数

15:20.530 --> 15:21.530
这个B2A函数

15:21.530 --> 15:22.530
还可以转弯

15:22.530 --> 15:23.530
完成这个操作

15:23.530 --> 15:24.530
比方说

15:24.530 --> 15:25.530
你在浏览器里边

15:25.530 --> 15:26.530
你可以自己去试一下

15:26.530 --> 15:27.530
调用这个函数

15:27.530 --> 15:28.530
你把这个东西

15:28.530 --> 15:29.530
你把我的对象

15:29.530 --> 15:30.530
接时对象

15:30.530 --> 15:32.530
转换成接成格式

15:32.530 --> 15:33.530
转换成接成格式的支部串

15:33.530 --> 15:34.530
然后把这个支部串

15:34.530 --> 15:36.530
使用B2A这个方式

15:36.530 --> 15:37.530
就得到一个BS64的编码

15:37.530 --> 15:39.530
当然这个不是BS64U

15:39.530 --> 15:40.530
是BS64编码

15:40.530 --> 15:41.530
不过呢

15:41.530 --> 15:42.530
这里巧了

15:42.530 --> 15:44.530
刚好就没有这个加号减号

15:44.530 --> 15:45.530
所以说不会出问题

15:45.530 --> 15:46.530
就这么个意思

15:46.530 --> 15:47.530
就这么个意思

15:47.530 --> 15:48.530
当然我们

15:48.530 --> 15:50.530
正儿把紧要在服务器操作的时候

15:50.530 --> 15:52.530
肯定不会用浏览器里边的函数

15:53.530 --> 15:54.530
那么同样的浏览器

15:54.530 --> 15:55.530
要去解码的话

15:55.530 --> 15:56.530
就用A2B

15:56.530 --> 15:57.530
这个函数形解码

15:57.530 --> 15:59.530
比方说编码出来过后是这个

15:59.530 --> 16:01.530
那么我们用A2B来解码

16:01.530 --> 16:02.530
解码过后是不是得到这个支部串

16:02.530 --> 16:04.530
看一下吧

16:04.530 --> 16:05.530
很简单

16:05.530 --> 16:06.530
复制一下

16:09.100 --> 16:16.020
看一下

16:16.020 --> 16:17.020
你看

16:17.020 --> 16:18.020
解码出来不就是一个

16:18.020 --> 16:19.020
结成支部串吗

16:19.020 --> 16:20.020
对不对

16:20.020 --> 16:21.020
解码出来就是这个样子

16:21.020 --> 16:22.020
就这么简单

16:22.020 --> 16:23.020
这是这一部分

16:23.020 --> 16:24.020
非常简单

16:25.020 --> 16:26.020
我再说一下

16:26.020 --> 16:27.020
漏了解释里面

16:27.020 --> 16:28.020
是美后的两个喊说

16:28.020 --> 16:29.020
不要再漏了解释

16:29.020 --> 16:30.020
来去试了

16:30.020 --> 16:31.020
这是浏览器提供的API

16:31.020 --> 16:32.020
漏了解释

16:32.020 --> 16:33.020
如果说你肯定是可以的

16:33.020 --> 16:34.020
不说漏了解释

16:34.020 --> 16:35.020
就做不到

16:35.020 --> 16:36.020
那肯定要做到

16:36.020 --> 16:37.020
对吧

16:37.020 --> 16:38.020
因为我们这些编码

16:38.020 --> 16:39.020
都是服务器做的

16:39.020 --> 16:40.020
这GWT的另排的建议

16:40.020 --> 16:41.020
是服务器做的

16:41.020 --> 16:42.020
漏了解释里面

16:42.020 --> 16:43.020
肯定要做的

16:43.020 --> 16:44.020
就手写

16:44.020 --> 16:46.020
要么就可以使用第三方库

16:46.020 --> 16:47.020
有两个第三方库

16:47.020 --> 16:48.020
叫一个是A2B

16:48.020 --> 16:49.020
一个是B2A

16:49.020 --> 16:50.020
第三方库安装一下

16:50.020 --> 16:51.020
NPM去搜一下

16:51.020 --> 16:52.020
很简单

16:52.020 --> 16:53.020
就可以搞定了

16:53.020 --> 16:54.020
这是这个

16:55.020 --> 16:56.020
第二部分

16:56.020 --> 16:57.020
另排的第二部分

16:57.020 --> 16:58.020
这一部分是

16:58.020 --> 16:59.020
GWT的主体信息

16:59.020 --> 17:01.020
它仍然是一个结成对象

17:01.020 --> 17:03.020
它可以包含什么内容呢

17:03.020 --> 17:04.020
规范里面说

17:04.020 --> 17:05.020
它建议你

17:05.020 --> 17:07.020
可以包含这么一些内容

17:07.020 --> 17:08.020
但是这些内容

17:08.020 --> 17:09.020
全部都是可选的

17:09.020 --> 17:11.020
没有一个是必选的

17:11.020 --> 17:12.020
不是说必须要填

17:12.020 --> 17:14.020
没有必须要填

17:14.020 --> 17:15.020
甚至你可以填

17:15.020 --> 17:16.020
填到什么都不用

17:16.020 --> 17:17.020
这个属性名都可以

17:17.020 --> 17:19.020
都可以换别的属性名

17:19.020 --> 17:20.020
它只是一种规范而已

17:20.020 --> 17:23.020
不是说你强行要求

17:23.020 --> 17:25.020
所以它这里规范是什么意思呢

17:25.020 --> 17:26.020
它就是说

17:26.020 --> 17:27.020
我给你设置了

17:27.020 --> 17:29.020
如果说你有这么一些属性的话

17:29.020 --> 17:31.020
最好按照这种方式来设置

17:31.020 --> 17:32.020
比方说SS表示什么

17:32.020 --> 17:33.020
发行者

17:33.020 --> 17:35.020
就是说这个GWT

17:35.020 --> 17:36.020
是谁发布的

17:36.020 --> 17:38.020
比方可以写公式的名字

17:38.020 --> 17:39.020
对吧

17:39.020 --> 17:40.020
可以写产品的名字

17:40.020 --> 17:41.020
可以写服务的名字

17:41.020 --> 17:42.020
可以写

17:42.020 --> 17:43.020
表示你是个人开发者

17:43.020 --> 17:44.020
做了网站

17:44.020 --> 17:45.020
那么就可以写个人的名字

17:45.020 --> 17:47.020
随便你写不写都无所谓

17:47.020 --> 17:48.020
那么这个写的

17:48.020 --> 17:49.020
有什么用没什么用

17:49.020 --> 17:50.020
这个东西就是一种

17:50.020 --> 17:52.020
消息格式的规范对吧

17:52.020 --> 17:53.020
你随便怎么写写的

17:53.020 --> 17:54.020
晚了过后最后

17:54.020 --> 17:56.020
还是要你自己来解析

17:56.020 --> 17:57.020
所以说

17:57.020 --> 17:58.020
这个东西写啥都无所谓的

17:58.020 --> 17:59.020
IAT

17:59.020 --> 18:00.020
这个表示的是

18:00.020 --> 18:02.020
GWT的发放时间

18:02.020 --> 18:03.020
一般来说

18:03.020 --> 18:05.020
我们可以写个时间戳在这

18:05.020 --> 18:06.020
就是GWT的令牌

18:06.020 --> 18:08.020
是什么时候生存的

18:08.020 --> 18:10.020
Expire表示的是

18:10.020 --> 18:12.020
GWT的到期时间

18:12.020 --> 18:13.020
就是GWT

18:13.020 --> 18:14.020
Token

18:14.020 --> 18:15.020
令牌什么时候过期

18:15.020 --> 18:18.020
一般来说也是写个时间戳

18:18.020 --> 18:21.020
这个是主题

18:21.020 --> 18:23.020
GWT用来干嘛的

18:23.020 --> 18:25.020
用来身份认真的

18:25.020 --> 18:26.020
或者是用来

18:26.020 --> 18:29.020
做权限认真的

18:29.020 --> 18:30.020
到底干嘛的

18:30.020 --> 18:31.020
我也不知道干嘛的

18:31.020 --> 18:33.020
你认为GWT

18:33.020 --> 18:34.020
你办法出来是干嘛的

18:34.020 --> 18:35.020
你给它写上

18:35.020 --> 18:36.020
当然你不写也无所谓

18:36.020 --> 18:37.020
这些都无所谓的

18:37.020 --> 18:38.020
这个叫audience

18:38.020 --> 18:39.020
audience表示的是听众

18:39.020 --> 18:40.020
就是收听的人

18:40.020 --> 18:41.020
就是到底

18:41.020 --> 18:43.020
这个GWT是发送给谁

18:43.020 --> 18:44.020
哪个中端的

18:44.020 --> 18:45.020
你可以写中端的类型

18:45.020 --> 18:46.020
不要发送给手机的

18:46.020 --> 18:47.020
发送给平板的

18:47.020 --> 18:49.020
或者是你就可以写个用户

18:49.020 --> 18:50.020
发送给用户的

18:50.020 --> 18:52.020
可以不写无所谓的

18:52.020 --> 18:54.020
然后就是

18:54.020 --> 18:56.020
NBF一个时间点

18:56.020 --> 18:58.020
就是在这个时间点之前

18:58.020 --> 19:00.020
这个令牌是不可用的

19:00.020 --> 19:02.020
那么你可以写个时间戳

19:02.020 --> 19:03.020
这个时间戳到来之前

19:03.020 --> 19:04.020
这个令牌是不能用的

19:04.020 --> 19:06.020
你是不能用这个令牌的

19:06.020 --> 19:07.020
就是令牌

19:07.020 --> 19:08.020
后来客户员保存了令牌

19:08.020 --> 19:09.020
你给我发过来

19:09.020 --> 19:10.020
但是时间点没到

19:10.020 --> 19:11.020
我看一下时间点没到

19:11.020 --> 19:12.020
我看我也不给你用

19:12.020 --> 19:13.020
就这么个意思

19:13.020 --> 19:14.020
当然了这个东西

19:14.020 --> 19:16.020
你得后续的验证

19:16.020 --> 19:18.020
到底给不给他用

19:18.020 --> 19:19.020
听众是不是匹配

19:19.020 --> 19:20.020
这些东西

19:20.020 --> 19:22.020
全部要你自己手动写单

19:22.020 --> 19:23.020
验证

19:23.020 --> 19:24.020
当然你可以利用

19:24.020 --> 19:25.020
一些第三方户

19:25.020 --> 19:26.020
咱们下节课讲

19:26.020 --> 19:27.020
所以说这些东西

19:27.020 --> 19:28.020
反正都是你自己搞定

19:28.020 --> 19:29.020
所以说你随便写

19:29.020 --> 19:31.020
当然你如果说

19:31.020 --> 19:32.020
比方说你要做个主题

19:32.020 --> 19:33.020
当然我还是推荐你

19:33.020 --> 19:34.020
是用官方的格式

19:34.020 --> 19:36.020
官方给要求的格式

19:36.020 --> 19:37.020
最后一个

19:37.020 --> 19:39.020
就是JWT的唯一编号

19:39.020 --> 19:40.020
这个东西是为了

19:40.020 --> 19:41.020
防止重放攻击的

19:41.020 --> 19:42.020
在我们这里根本就不到

19:42.020 --> 19:43.020
什么叫重放攻击

19:43.020 --> 19:45.020
就在某些场景下边

19:45.020 --> 19:47.020
用户的使用了

19:47.020 --> 19:48.020
用户的使用了

19:48.020 --> 19:50.020
之前的一些令牌

19:50.020 --> 19:52.020
之前的令牌早就不用了

19:52.020 --> 19:54.020
伏击重新给他办法的令牌

19:54.020 --> 19:55.020
但是他把之前的令牌

19:55.020 --> 19:56.020
通过某种方式保留下来

19:56.020 --> 19:57.020
比方说

19:57.020 --> 19:58.020
我们在论坛里边

19:58.020 --> 20:00.020
有发铁发铁加积分

20:00.020 --> 20:01.020
对不对

20:01.020 --> 20:03.020
他有可能在把那个积分

20:03.020 --> 20:04.020
你目前有多少积分

20:04.020 --> 20:05.020
给你放到JWT里面

20:05.020 --> 20:06.020
有可能

20:06.020 --> 20:08.020
当然对看伏击怎么做的

20:08.020 --> 20:09.020
他有可能把这个积分的数据

20:09.020 --> 20:11.020
放到JWT里边

20:11.020 --> 20:13.020
他信任JWT的数据

20:13.020 --> 20:15.020
那么JWT就是你只要

20:15.020 --> 20:16.020
那个就是

20:16.020 --> 20:18.020
改动了积分过后

20:18.020 --> 20:20.020
他会给你颁发一个新的JWT

20:20.020 --> 20:22.020
改动用户数据

20:22.020 --> 20:23.020
但是有些用户

20:23.020 --> 20:25.020
他可能把之前的JWT

20:25.020 --> 20:27.020
保存了下来

20:27.020 --> 20:28.020
整个JWT保存了下来

20:28.020 --> 20:29.020
然后呢

20:29.020 --> 20:30.020
后来他自己手中的

20:30.020 --> 20:31.020
把JWT给你发送到伏击

20:31.020 --> 20:33.020
伏击他还认了

20:33.020 --> 20:34.020
他还傻

20:34.020 --> 20:35.020
还认了

20:35.020 --> 20:36.020
这些数据户也认了

20:36.020 --> 20:37.020
业务罗利城也认了

20:37.020 --> 20:38.020
然后导致了

20:38.020 --> 20:39.020
这些数据产能互问的

20:39.020 --> 20:40.020
对不对

20:40.020 --> 20:41.020
那么可以在这里呢

20:41.020 --> 20:42.020
使用唯一编号

20:42.020 --> 20:43.020
每一次发行的JWT

20:43.020 --> 20:45.020
还是都有一个唯一的ID

20:45.020 --> 20:46.020
通过这个东西来进行控制

20:46.020 --> 20:48.020
当然这个东西光靠JWT

20:48.020 --> 20:49.020
一个东西还控制不了

20:49.020 --> 20:50.020
对吧

20:50.020 --> 20:51.020
还要做一些额外的处理

20:51.020 --> 20:52.020
这个东西

20:52.020 --> 20:53.020
了解了解就行了

20:53.020 --> 20:54.020
因为我们不用去

20:54.020 --> 20:55.020
设计到那么深入

20:55.020 --> 20:56.020
我们这里呢

20:56.020 --> 20:57.020
也用不到

20:57.020 --> 20:58.020
对不对

20:58.020 --> 20:59.020
对我们这个系统来说

20:59.020 --> 21:00.020
不存在这个问题的

21:00.020 --> 21:02.020
这是这个

21:02.020 --> 21:03.020
了解一下就行

21:03.020 --> 21:04.020
重放攻击

21:04.020 --> 21:06.020
像这些存后段的内容

21:06.020 --> 21:07.020
我们就了解就行了

21:07.020 --> 21:08.020
好

21:08.020 --> 21:09.020
但是到现在看了半天

21:09.020 --> 21:11.020
好像没有我要写入的数据

21:11.020 --> 21:12.020
你要写入什么数据

21:12.020 --> 21:13.020
比方说我们登入成功之后

21:13.020 --> 21:15.020
我们把拥护信息写入进去

21:15.020 --> 21:18.020
JWT令牌比方拥护ID

21:18.020 --> 21:19.020
拥护的账号

21:19.020 --> 21:20.020
密码就算了

21:20.020 --> 21:21.020
密码不要发送给K5

21:21.020 --> 21:23.020
这东西怎么写呢

21:23.020 --> 21:24.020
很简单

21:24.020 --> 21:25.020
因为它只是一个

21:25.020 --> 21:27.020
接受对象而已

21:27.020 --> 21:28.020
你可以往对象里边

21:28.020 --> 21:29.020
加入任何想要的

21:29.020 --> 21:30.020
加入的内容

21:30.020 --> 21:31.020
比方说

21:31.020 --> 21:32.020
下面那个接受对象

21:32.020 --> 21:34.020
这正常是一个有效的配合的

21:34.020 --> 21:35.020
你看

21:35.020 --> 21:36.020
随便加一个属性

21:36.020 --> 21:37.020
互报

21:37.020 --> 21:38.020
也可以加一个满足要求的属性

21:38.020 --> 21:39.020
ID对吧

21:39.020 --> 21:40.020
创建时间

21:40.020 --> 21:41.020
一个时间戳

21:41.020 --> 21:43.020
这正常是一个合法的

21:43.020 --> 21:45.020
有效的JWT

21:45.020 --> 21:46.020
这个时间戳是秒

21:46.020 --> 21:48.020
1970年到现在的秒数

21:48.020 --> 21:49.020
对吧

21:49.020 --> 21:50.020
没问题的

21:50.020 --> 21:51.020
你可以加任何数量

21:51.020 --> 21:53.020
任何属性名

21:53.020 --> 21:55.020
任何理想要加的属性

21:55.020 --> 21:56.020
你可以在属性里面

21:56.020 --> 21:57.020
进行嵌套

21:57.020 --> 21:58.020
嵌套数组

21:58.020 --> 21:59.020
嵌套支付串

21:59.020 --> 22:00.020
随便你

22:01.020 --> 22:02.020
那么这个东西

22:02.020 --> 22:04.020
就是一个合法的配合的

22:04.020 --> 22:05.020
其他东西我不写了

22:05.020 --> 22:06.020
对我来说

22:06.020 --> 22:07.020
没什么关系

22:07.020 --> 22:08.020
我就不写了

22:08.020 --> 22:09.020
那么这一部分

22:09.020 --> 22:10.020
怎么来生成最终的结果呢

22:10.020 --> 22:12.020
也是跟Header是一样的

22:12.020 --> 22:14.020
把这个接受对象

22:14.020 --> 22:16.020
转换成

22:16.020 --> 22:18.020
BS64UIUB

22:18.020 --> 22:19.020
你看

22:19.020 --> 22:20.020
就这样子

22:20.020 --> 22:21.020
就完事了

22:21.020 --> 22:22.020
这就是这一部分

22:22.020 --> 22:23.020
对吧

22:23.020 --> 22:24.020
Header配合的

22:24.020 --> 22:25.020
注意

22:25.020 --> 22:26.020
这两部分

22:26.020 --> 22:27.020
实际上传输的时候

22:27.020 --> 22:28.020
是不是加密的

22:28.020 --> 22:29.020
加密

22:29.020 --> 22:30.020
没有加密

22:30.020 --> 22:31.020
几乎算是

22:31.020 --> 22:33.020
明文传输了

22:33.020 --> 22:35.020
它跟明文传输有啥区别呢

22:35.020 --> 22:36.020
只是客户端那边

22:36.020 --> 22:38.020
要多做一件事

22:38.020 --> 22:40.020
就是去调用一下A2B

22:40.020 --> 22:42.020
把它解出来

22:42.020 --> 22:43.020
不需要任何必要

22:43.020 --> 22:44.020
直接解出来了

22:44.020 --> 22:46.020
基本上是明文传输

22:46.020 --> 22:48.020
它做BS64UIUB

22:48.020 --> 22:50.020
主要是目的呢

22:50.020 --> 22:51.020
是方便在瀏覽期

22:51.020 --> 22:52.020
地址栏里边传输

22:52.020 --> 22:53.020
以及在消息头

22:53.020 --> 22:54.020
因为消息头里边

22:54.020 --> 22:55.020
是不能用很多特殊制服的

22:55.020 --> 22:56.020
比方这里还写了中文

22:56.020 --> 22:57.020
是不能在消息头里面

22:57.020 --> 22:58.020
出现的

22:58.020 --> 22:59.020
消息头里面只能出现

22:59.020 --> 23:00.020
ASK制服

23:00.020 --> 23:01.020
它是为了方便传输

23:01.020 --> 23:03.020
用BS64UIUB

23:03.020 --> 23:04.020
它是为了方便传输

23:04.020 --> 23:05.020
跟加密安全

23:05.020 --> 23:06.020
没有一毛钱的关系

23:06.020 --> 23:08.020
但是它其实也无所谓

23:08.020 --> 23:10.020
因为用户登陆成功了

23:10.020 --> 23:11.020
你不让它看用户

23:11.020 --> 23:12.020
自己的用户信息吗

23:12.020 --> 23:13.020
它不看它在页面上

23:13.020 --> 23:14.020
都能得到

23:14.020 --> 23:16.020
还不要说自己解密出来

23:16.020 --> 23:17.020
你只要不

23:17.020 --> 23:19.020
不给它敏感信息就行了

23:19.020 --> 23:20.020
它自己的信息

23:20.020 --> 23:21.020
可以给它

23:21.020 --> 23:22.020
它都登陆成功了

23:22.020 --> 23:23.020
不给它

23:23.020 --> 23:24.020
有什么问题呢

23:24.020 --> 23:25.020
可以给它

23:25.020 --> 23:26.020
甚至有些网站

23:26.020 --> 23:27.020
有些网站那里

23:27.020 --> 23:28.020
不登陆都可以看到别人的信息

23:28.020 --> 23:29.020
比方说QQ

23:29.020 --> 23:31.020
QQ好像不行

23:31.020 --> 23:33.020
比方说微博吧

23:33.020 --> 23:34.020
微博你是不是可以

23:34.020 --> 23:35.020
进入好的各种页面

23:35.020 --> 23:36.020
你不用登陆

23:36.020 --> 23:37.020
就可以看到它的信息

23:37.020 --> 23:38.020
对不对

23:38.020 --> 23:39.020
你需要登陆吗

23:39.020 --> 23:40.020
也可以看到别人的信息

23:40.020 --> 23:41.020
对吧

23:41.020 --> 23:42.020
这些信息本身

23:42.020 --> 23:43.020
你只要不是敏感的信息

23:43.020 --> 23:44.020
就大胆地往客不断传

23:44.020 --> 23:45.020
无所谓的

23:45.020 --> 23:47.020
关键是第三部分

23:47.020 --> 23:50.780
这一部分是GWT的签名

23:50.780 --> 23:51.780
正是它的存在

23:51.780 --> 23:53.780
保证了整个GWT

23:53.780 --> 23:54.780
不被串开

23:54.780 --> 23:55.780
我们真正要防止的

23:55.780 --> 23:57.780
不是说它不能看

23:57.780 --> 23:58.780
如果说真的

23:58.780 --> 23:59.780
需要它不能看的话

23:59.780 --> 24:00.780
你对整个GWT

24:00.780 --> 24:03.780
再来一次对成加密就完事了

24:03.780 --> 24:04.780
我们要做的

24:04.780 --> 24:05.780
其实真的要做的是

24:05.780 --> 24:08.780
不要被改了

24:08.780 --> 24:09.780
我服务器给你发的东西

24:09.780 --> 24:11.780
一定是正确的

24:11.780 --> 24:12.780
但是你改了之后

24:12.780 --> 24:13.780
就麻烦了

24:13.780 --> 24:14.780
就不正确了

24:14.780 --> 24:16.780
你再给它发到服务器

24:16.780 --> 24:17.780
服务器到底能不能相信

24:17.780 --> 24:18.780
它就是个问题了

24:18.780 --> 24:19.780
我怎么来知道

24:19.780 --> 24:21.780
它有没有被改过

24:21.780 --> 24:22.780
就是不能被串改

24:22.780 --> 24:23.780
还有什么

24:23.780 --> 24:24.780
不能被伪造

24:24.780 --> 24:25.780
怎么叫伪造呢

24:25.780 --> 24:26.780
我都没有给你令牌

24:26.780 --> 24:27.780
你给我造了一个假令牌

24:27.780 --> 24:28.780
出来给我

24:28.780 --> 24:29.780
对吧

24:29.780 --> 24:30.780
我们主要的

24:30.780 --> 24:32.780
是要防止这两个情况出现

24:32.780 --> 24:34.780
而不是防止这个信息

24:34.780 --> 24:35.780
被查看

24:35.780 --> 24:36.780
他都登入成功了

24:36.780 --> 24:37.780
你信息怎么不能被查看呢

24:37.780 --> 24:38.780
他的页面

24:38.780 --> 24:39.780
你不用给他

24:39.780 --> 24:40.780
你不用让他查看

24:40.780 --> 24:41.780
他在页面上

24:41.780 --> 24:42.780
都能看到自己的信息

24:42.780 --> 24:43.780
对吧

24:43.780 --> 24:44.780
他还不要说去

24:44.780 --> 24:45.780
把它解析出来了

24:45.780 --> 24:46.780
所以我们要主要防的是

24:46.780 --> 24:47.780
伪造和串改

24:47.780 --> 24:48.780
那么这一部分

24:48.780 --> 24:50.780
就是在防这个东西的

24:50.780 --> 24:51.780
它怎么做的呢

24:51.780 --> 24:52.780
它很简单

24:52.780 --> 24:53.780
非常简单

24:54.780 --> 24:56.780
你前边的头部不是指定的

24:56.780 --> 24:57.780
黑的部分不是指定的

24:57.780 --> 24:58.780
一个算法吗

24:58.780 --> 24:59.780
加密算法

24:59.780 --> 25:00.780
比方这个

25:00.780 --> 25:01.780
你前面两部分

25:01.780 --> 25:03.780
不是生存出来了吗

25:03.780 --> 25:04.780
不是这个吗

25:04.780 --> 25:05.780
对不对

25:05.780 --> 25:06.780
OK

25:06.780 --> 25:07.780
那么第三部分

25:07.780 --> 25:09.780
就是利用你这个算法

25:09.780 --> 25:11.780
然后对前边这两个部分

25:11.780 --> 25:13.780
评计的结果

25:13.780 --> 25:16.780
然后再来进行一次

25:16.780 --> 25:18.780
就是用这个算法

25:18.780 --> 25:20.780
再进行一次加密

25:20.780 --> 25:22.780
当然你要指定个必要

25:22.780 --> 25:24.780
这是对成加密

25:24.780 --> 25:26.780
你只需要自定一个

25:26.780 --> 25:27.780
对成必要就行了

25:27.780 --> 25:29.780
如果说是非对成加密的话

25:29.780 --> 25:31.780
那你要定一个公要

25:31.780 --> 25:32.780
定一个私要

25:32.780 --> 25:33.780
用私要加密公要解密

25:33.780 --> 25:34.780
对不对

25:34.780 --> 25:36.780
你还要说是这么个意思

25:36.780 --> 25:37.780
所以说

25:37.780 --> 25:38.780
这里就是

25:38.780 --> 25:40.780
在这个部分是加密过后的

25:40.780 --> 25:41.780
比方说我这里的

25:41.780 --> 25:42.780
使用个对成算法

25:42.780 --> 25:43.780
我这里只是个伟代

25:43.780 --> 25:44.780
并没有这个函数

25:44.780 --> 25:45.780
使用这个算法

25:45.780 --> 25:46.780
总之使用那个算法

25:46.780 --> 25:47.780
然后把这个字无串

25:47.780 --> 25:48.780
前面这个字无串

25:48.780 --> 25:50.780
再加上一个密要

25:50.780 --> 25:51.780
进行加密

25:51.780 --> 25:52.780
得到一个加密的结果

25:52.780 --> 25:53.780
对吧

25:53.780 --> 25:54.780
就这么个意思

25:54.780 --> 25:55.780
得到一个加密的结果

25:55.780 --> 25:56.780
好

25:56.780 --> 25:57.780
那么最终

25:57.780 --> 25:58.780
把这个三部分的

25:58.780 --> 25:59.780
组合在一起

25:59.780 --> 26:00.780
就形成了一个

26:00.780 --> 26:01.780
完整的GWT的

26:01.780 --> 26:02.780
你看

26:02.780 --> 26:03.780
第一部分的Header

26:03.780 --> 26:04.780
第二部分的Pelo

26:04.780 --> 26:05.780
第三部分加密的结果

26:05.780 --> 26:06.780
我们把它这个

26:06.780 --> 26:07.780
第三部分的叫做签名

26:07.780 --> 26:09.780
数字签名

26:09.780 --> 26:10.780
好了

26:10.780 --> 26:12.780
由于有第三部分存在

26:12.780 --> 26:14.780
它是无法伪造签名的

26:14.780 --> 26:15.780
为什么

26:15.780 --> 26:16.780
它怎么伪造

26:16.780 --> 26:17.780
你告诉我

26:17.780 --> 26:18.780
它可以伪造Header

26:18.780 --> 26:19.780
可以伪造

26:19.780 --> 26:20.780
它只是个

26:20.780 --> 26:21.780
编码而已

26:21.780 --> 26:22.780
可以伪造Pelo的

26:22.780 --> 26:23.780
对吧

26:23.780 --> 26:24.780
自己去构建一个

26:24.780 --> 26:25.780
结成对象之一

26:25.780 --> 26:26.780
把Base-60签名

26:26.780 --> 26:27.780
Base-60编码就完事了

26:27.780 --> 26:28.780
对吧

26:28.780 --> 26:29.780
第三部分咋办

26:29.780 --> 26:30.780
你告诉我咋办

26:30.780 --> 26:32.780
第三部分

26:32.780 --> 26:33.780
你现在

26:33.780 --> 26:34.780
以算法之道

26:34.780 --> 26:35.780
算法你所谓的

26:35.780 --> 26:36.780
都是公开的

26:36.780 --> 26:37.780
算法怎么去算的

26:37.780 --> 26:38.780
可以用很多

26:38.780 --> 26:39.780
第三方库

26:39.780 --> 26:40.780
就可以完成

26:40.780 --> 26:41.780
用一个算法

26:41.780 --> 26:42.780
然后对前面

26:42.780 --> 26:43.780
两部分加密

26:43.780 --> 26:44.780
那是密要

26:44.780 --> 26:45.780
你不知道密要

26:45.780 --> 26:46.780
密要是放到服务器上的

26:46.780 --> 26:47.780
对不对

26:47.780 --> 26:48.780
这整个这个过程

26:48.780 --> 26:49.780
是服务器完成的

26:49.780 --> 26:50.780
它拿不到密要

26:50.780 --> 26:51.780
因此它自己

26:51.780 --> 26:52.780
随便指定个密要加密的话

26:52.780 --> 26:53.780
那么服务器是不认的

26:53.780 --> 26:55.780
因为服务器到时候要解密

26:55.780 --> 26:56.780
解密的话

26:56.780 --> 26:57.780
解密出来看你不对

26:57.780 --> 26:58.780
对不对

26:58.780 --> 26:59.780
所以说

26:59.780 --> 27:00.780
它拿不到密要

27:00.780 --> 27:01.780
它就无法伪造这个签名

27:01.780 --> 27:02.780
就是因为

27:02.780 --> 27:03.780
第三部分存在

27:03.780 --> 27:05.780
就这么个意思

27:05.780 --> 27:06.780
那么现在

27:06.780 --> 27:07.780
它不能伪造了

27:07.780 --> 27:08.780
那怎么来保证

27:08.780 --> 27:10.780
不被穿改呢

27:10.780 --> 27:11.780
就是什么意思

27:11.780 --> 27:12.780
就是某个用户

27:12.780 --> 27:13.780
都成功了

27:13.780 --> 27:14.780
拿到一个令牌

27:14.780 --> 27:15.780
对吧

27:15.780 --> 27:16.780
它看一看

27:16.780 --> 27:17.780
把Pelo的一解码

27:17.780 --> 27:18.780
出来看

27:18.780 --> 27:19.780
怎么才一百块钱

27:19.780 --> 27:20.780
快要穷死了

27:20.780 --> 27:21.780
对吧

27:21.780 --> 27:22.780
然后后面给它添四个零

27:22.780 --> 27:23.780
所以就伪造了

27:23.780 --> 27:24.780
对吧

27:24.780 --> 27:25.780
前面

27:25.780 --> 27:26.780
pelo不动

27:26.780 --> 27:27.780
签名也不动

27:27.780 --> 27:28.780
我把这个中间部分

27:28.780 --> 27:29.780
给你伪造过

27:29.780 --> 27:30.780
再重新发给你

27:30.780 --> 27:31.780
那服务器不就扔了吗

27:31.780 --> 27:33.780
那么怎么来搞定伪造呢

27:33.780 --> 27:34.780
我们的看要看

27:34.780 --> 27:36.780
令牌的验证了

27:36.780 --> 27:37.780
我们这里

27:37.780 --> 27:38.780
再过一下整个流程

27:38.780 --> 27:39.780
客户端安请求服务器

27:39.780 --> 27:40.780
服务器当中成功

27:40.780 --> 27:41.780
给它一个令牌

27:41.780 --> 27:42.780
令牌保存下来

27:42.780 --> 27:43.780
然后客户端

27:43.780 --> 27:44.780
再把个令牌传过去

27:44.780 --> 27:45.780
服务器要验证令牌了

27:45.780 --> 27:46.780
怎么验证呢

27:46.780 --> 27:47.780
首先服务器

27:47.780 --> 27:48.780
这个验证

27:48.780 --> 27:49.780
首先这个服务器要验证

27:49.780 --> 27:50.780
这个令牌是不是被

27:50.780 --> 27:51.780
篡改过

27:51.780 --> 27:52.780
当这些验证都需要

27:52.780 --> 27:53.780
手动验证

27:53.780 --> 27:55.780
验证方式非常简单

27:55.780 --> 27:56.780
你的令牌

27:56.780 --> 27:57.780
不是有header吗

27:57.780 --> 27:58.780
不有pelo的吗

27:58.780 --> 27:59.780
对不对

27:59.780 --> 28:00.780
这些都是名文传输的

28:00.780 --> 28:01.780
对不对

28:01.780 --> 28:02.780
好那行

28:02.780 --> 28:04.780
我再把这个header

28:04.780 --> 28:05.780
pelo的

28:05.780 --> 28:06.780
把这个header的东西

28:06.780 --> 28:07.780
读出来

28:07.780 --> 28:08.780
读出什么呢

28:08.780 --> 28:09.780
读出那个算法

28:09.780 --> 28:10.780
算法类型

28:10.780 --> 28:11.780
然后pelo的方式

28:11.780 --> 28:13.780
pelo的东西

28:13.780 --> 28:14.780
也读出来

28:14.780 --> 28:15.780
总之呢

28:15.780 --> 28:16.780
我们把这两个东西

28:16.780 --> 28:17.780
加起来

28:17.780 --> 28:18.780
用同样的密钥

28:18.780 --> 28:19.780
和加密算法

28:19.780 --> 28:20.780
是不是再重新加密一次

28:20.780 --> 28:22.780
再重新加密一次

28:22.780 --> 28:23.780
是不是又得到

28:23.780 --> 28:25.780
一个新的signature

28:25.780 --> 28:27.780
你看啊

28:27.780 --> 28:28.780
我传入了一个jwt

28:28.780 --> 28:29.780
是不是有一个header

28:29.780 --> 28:30.780
pelo的signature

28:30.780 --> 28:31.780
对吧

28:31.780 --> 28:32.780
好我把这两部分

28:32.780 --> 28:33.780
读出来

28:33.780 --> 28:34.780
是不是到这儿

28:34.780 --> 28:35.780
然后呢

28:35.780 --> 28:36.780
用之前

28:36.780 --> 28:37.780
之前服务器的

28:37.780 --> 28:38.780
加密的密钥

28:38.780 --> 28:39.780
用我们的密钥

28:39.780 --> 28:40.780
然后呢

28:40.780 --> 28:41.780
再来一次算法加密

28:41.780 --> 28:42.780
是不是得到

28:42.780 --> 28:43.780
一个新的signature

28:43.780 --> 28:44.780
对吧

28:44.780 --> 28:45.780
把这两部分加密

28:45.780 --> 28:46.780
得到新的signature

28:46.780 --> 28:47.780
对比一下

28:47.780 --> 28:49.780
这两个是不是一致的

28:49.780 --> 28:50.780
是不是有验证呢

28:50.780 --> 28:51.780
你想啊

28:51.780 --> 28:53.780
如果说他把这一部分

28:53.780 --> 28:54.780
给我改了

28:54.780 --> 28:56.780
那我得到了新的signature

28:56.780 --> 28:57.780
是不是一定跟原来的

28:57.780 --> 28:58.780
不一样

28:58.780 --> 28:59.780
对不对

28:59.780 --> 29:00.780
一定是不一样的

29:00.780 --> 29:02.780
bass610编码过后

29:02.780 --> 29:03.780
一定是不一样的

29:03.780 --> 29:04.780
不一样的话

29:04.780 --> 29:06.780
那这两个就不相等

29:06.780 --> 29:07.780
不相等

29:07.780 --> 29:08.780
说明肯定被串开过了

29:08.780 --> 29:10.780
某个地方肯定被串开过了

29:10.780 --> 29:11.780
对吧

29:11.780 --> 29:12.780
那就没办法了

29:12.780 --> 29:14.780
他是可以通过这种方式来进行

29:14.780 --> 29:15.780
创改

29:15.780 --> 29:16.780
防治创改

29:16.780 --> 29:18.780
因为服务器验证就通不过

29:18.780 --> 29:19.780
当然创改通过

29:19.780 --> 29:21.780
就是验证是否被创改

29:21.780 --> 29:22.780
通过之后

29:22.780 --> 29:23.780
服务器可以做一些其他验证

29:23.780 --> 29:24.780
都是要手动验证的

29:24.780 --> 29:26.780
比方说这个

29:26.780 --> 29:28.780
Pedro的里边有没有传过去时间

29:28.780 --> 29:29.780
那么有没有过期

29:29.780 --> 29:30.780
就是之前服务器办法的时候

29:30.780 --> 29:31.780
有没有加过期时间

29:31.780 --> 29:32.780
现在有没有过期

29:32.780 --> 29:33.780
对吧

29:33.780 --> 29:34.780
你的听众是否满足要求

29:34.780 --> 29:35.780
对吧

29:35.780 --> 29:36.780
这些东西是情况而定了

29:36.780 --> 29:37.780
你要验证的

29:37.780 --> 29:38.780
全是手动验证

29:38.780 --> 29:39.780
没有哪个服务器

29:39.780 --> 29:40.780
会给你自动验证的

29:40.780 --> 29:41.780
你自己去手动验

29:41.780 --> 29:42.780
所以说之前

29:42.780 --> 29:43.780
我说Pedro的时候

29:43.780 --> 29:44.780
我说无所谓

29:44.780 --> 29:46.780
就是因为全是要自己手动验做

29:46.780 --> 29:47.780
它的功能要实现

29:47.780 --> 29:48.780
全要你自己手验代码

29:48.780 --> 29:49.780
所以说

29:49.780 --> 29:51.780
你要什么样的格式随便你

29:51.780 --> 29:52.780
那么当然你可以

29:52.780 --> 29:53.780
接触一些第三方库来完成

29:53.780 --> 29:54.780
比方说我们下一个

29:54.780 --> 29:55.780
要讲一个第三方库

29:55.780 --> 29:57.780
所以我们总结一下

29:57.780 --> 29:58.780
GWT的特点

29:58.780 --> 29:59.780
就是本质上

29:59.780 --> 30:00.780
就是一个令牌格式

30:00.780 --> 30:02.780
它和中端设备无关

30:02.780 --> 30:04.780
手机 油辆器 平板

30:04.780 --> 30:05.780
无所谓

30:05.780 --> 30:08.780
同样跟服务器无关

30:08.780 --> 30:09.780
比方说

30:09.780 --> 30:10.780
这个服务器

30:10.780 --> 30:11.780
还有什么漏着接式服务器

30:11.780 --> 30:12.780
无所谓

30:12.780 --> 30:14.780
你只要按这种方式给我弄就行了

30:14.780 --> 30:15.780
甚至跟传输无关

30:15.780 --> 30:17.780
你把它放到消息头

30:17.780 --> 30:18.780
请求的时候

30:18.780 --> 30:19.780
把它放到地子栏参数

30:19.780 --> 30:20.780
无所谓

30:20.780 --> 30:22.780
它只是规范了令牌的格式

30:22.780 --> 30:24.780
这个令牌是怎么做5成的

30:24.780 --> 30:25.780
就没了

30:25.780 --> 30:27.780
它其实很单纯的

30:27.780 --> 30:28.780
它有三部分

30:28.780 --> 30:29.780
主持人Header

30:29.780 --> 30:30.780
Pedro的Secretary

30:30.780 --> 30:31.780
主体性应该Pedro的

30:31.780 --> 30:33.780
它难以被创改和伪造

30:33.780 --> 30:35.780
这是因为有第三部分

30:35.780 --> 30:36.780
Secretary的存在

30:36.780 --> 30:37.780
没了

30:37.780 --> 30:38.780
这就是GWT的原理

30:38.780 --> 30:40.780
把这个原理搞清楚了过后

30:40.780 --> 30:41.780
我们再来可能

30:41.780 --> 30:42.780
再来携带

30:42.780 --> 30:43.780
后面我估计

30:43.780 --> 30:45.780
我们完成整个

30:45.780 --> 30:47.780
登陆和正常一看

30:47.780 --> 30:48.780
登陆和正常不简单的

30:48.780 --> 30:49.780
很多人同学认为

30:49.780 --> 30:50.780
登陆简单

30:50.780 --> 30:51.780
登陆绝对不简单的

30:51.780 --> 30:54.780
我们把后面两节课

30:54.780 --> 30:55.780
作为一个案例

30:55.780 --> 30:56.780
把登陆说完

30:56.780 --> 30:57.780
就用GWT来做

30:57.780 --> 30:58.780
包括服务器

30:58.780 --> 30:59.780
包括客户端

30:59.780 --> 31:01.780
客户端我打算用5U来做

31:01.780 --> 31:02.780
不然的话

31:02.780 --> 31:03.780
后面也没有机会

31:03.780 --> 31:04.780
去接触这个东西

31:04.780 --> 31:06.780
我不知道你们学没学过5U

31:06.780 --> 31:07.780
现在

31:07.780 --> 31:08.780
没有学过5U的话

31:08.780 --> 31:09.780
那么将来

31:09.780 --> 31:10.780
学完了5U再回过头

31:10.780 --> 31:12.780
来听5U的一块的课

31:12.780 --> 31:13.780
再加上两节课

31:13.780 --> 31:15.780
一个是服务器的GWT的处理

31:15.780 --> 31:17.780
一个是客户端的GWT处理

31:17.780 --> 31:18.780
咱们后面两节课

31:18.780 --> 31:19.780
再来相信两件

