WEBVTT

00:00.180 --> 00:03.780
这节后来我们来说一下这个客户端缓存

00:03.780 --> 00:09.280
缓存的言语我这里已经做成了一个玛格汉文件

00:09.280 --> 00:10.480
我们来看一下

00:10.480 --> 00:14.800
不好 这里把这个打开

00:14.800 --> 00:18.000
实际上我们讲这个缓存的话

00:18.000 --> 00:20.000
讲的是客户端缓存

00:20.000 --> 00:23.000
因为我们平时说缓存的话缓存有两种

00:23.000 --> 00:25.000
一种是客户端缓存

00:25.000 --> 00:27.000
一种是服务器缓存

00:27.000 --> 00:30.000
服务器缓存的不在我们这里的讨论范围之列

00:30.500 --> 00:33.500
服务器缓存的跟GDP协议没有什么关系

00:33.500 --> 00:35.500
它是用一些服务器技术做的

00:35.500 --> 00:36.500
其实说白了

00:36.500 --> 00:38.500
那个原理就是

00:38.500 --> 00:40.500
说你来一个请求对吧

00:40.500 --> 00:43.500
那我是不是要从数据库里边去读一些数据

00:43.500 --> 00:45.500
那频繁的去操作数据库啊

00:45.500 --> 00:49.500
操作文件是不是会增加这个时间对不对

00:49.500 --> 00:52.500
因为我们知道磁盘的读取速度是很慢的

00:52.500 --> 00:55.500
所以说呢服务器缓存的它的原理很简单

00:55.500 --> 00:57.500
就是把我们一些经常要用的数据呢

00:57.500 --> 01:01.500
保存到某一个读取比较快速的地方

01:01.500 --> 01:04.500
比方说保存到内存里边

01:04.500 --> 01:08.500
比方说保存到一个就是SSD硬盘

01:08.500 --> 01:10.500
一个普通文件里边等等等等

01:10.500 --> 01:12.000
通过一些技术手段

01:12.000 --> 01:15.000
把保存到一个能够读取速度很快的地方

01:15.000 --> 01:16.500
那么当用服请求的时候

01:16.500 --> 01:18.000
我们直接从这个地方读取

01:18.000 --> 01:19.500
然后扔给它就完成了

01:19.500 --> 01:22.000
所以跟GDP协议啊没有什么关系

01:22.000 --> 01:24.000
我们这些可能是要跟

01:24.000 --> 01:25.500
说的是客户端缓存

01:25.500 --> 01:28.000
客户端缓存是跟ADB协议是有关系的

01:28.000 --> 01:30.000
因为客户端是什么

01:30.000 --> 01:31.500
就是浏览器嘛

01:31.500 --> 01:33.000
浏览器它要不要缓存

01:33.000 --> 01:34.500
怎么缓存缓存的过期时间

01:34.500 --> 01:36.000
还有很多的因素

01:36.000 --> 01:38.500
那么这些东西他要靠谁来告诉他

01:38.500 --> 01:40.000
是靠服务器来告诉他

01:40.000 --> 01:41.000
那么服务器怎么告诉他

01:41.000 --> 01:43.000
只能通过ADB协议

01:43.000 --> 01:45.000
因为客户端和服务器之间

01:45.000 --> 01:47.000
它只能通过ADB协议来传输

01:47.000 --> 01:48.000
对不对

01:48.000 --> 01:49.500
好 那么我们这一篇

01:49.500 --> 01:51.500
这就是这一块我们只是套论

01:51.500 --> 01:52.500
客户端缓存

01:52.500 --> 01:54.000
那关于服务器缓存的话

01:54.000 --> 01:55.000
那有机会再说吧

01:55.000 --> 01:56.500
什么用Redis

01:56.500 --> 01:57.500
用Memcatch

01:57.500 --> 01:58.500
这些都行

01:58.500 --> 02:00.000
好 那么一个来

02:00.000 --> 02:02.000
首先是客户端缓存

02:02.000 --> 02:05.000
就是将他就是客户端

02:05.000 --> 02:07.500
把某一次的响应结果

02:07.500 --> 02:09.000
保存到客户端

02:09.000 --> 02:10.500
不要浏览器里边

02:10.500 --> 02:12.000
而后续的请求

02:12.000 --> 02:14.000
只需要从缓存中读习即可

02:14.000 --> 02:15.500
那么这样子就极大降低了

02:15.500 --> 02:17.000
服务器的处理压力

02:17.000 --> 02:18.000
比方说客户端缓存

02:18.000 --> 02:19.000
我们下一个图

02:19.000 --> 02:20.500
给大家看一下它的原理

02:20.500 --> 02:22.500
就是说咱们客户端

02:22.500 --> 02:24.000
首先第一次请求

02:24.000 --> 02:25.000
一开始没有缓存

02:25.000 --> 02:26.500
第一次请求服务器

02:26.500 --> 02:27.500
服务器处理完了过后

02:27.500 --> 02:28.500
给它一个响应

02:28.500 --> 02:29.500
那响应是不是一个结果

02:29.500 --> 02:30.500
一个消息体

02:30.500 --> 02:32.500
那么客户端的浏览器

02:32.500 --> 02:34.000
它就把这个响应结果

02:34.000 --> 02:35.500
保存到缓存里边

02:35.500 --> 02:36.500
保存到本地

02:36.500 --> 02:38.000
然后后续请求

02:38.000 --> 02:40.500
就不发送到请求到服务器了

02:40.500 --> 02:42.500
而是从缓存里边读取

02:42.500 --> 02:44.500
就这么简单

02:44.500 --> 02:46.000
这是非常简单的原理

02:46.000 --> 02:47.500
但是后边我们看到

02:47.500 --> 02:48.500
有很多细节

02:48.500 --> 02:50.000
在细节的时候

02:50.000 --> 02:51.500
我们再详细说

02:51.500 --> 02:52.500
不一定是这个样子

02:52.500 --> 02:54.000
我们简单的话一下

02:54.000 --> 02:55.500
应该差不多是这个样子

02:55.500 --> 02:57.000
那么这里就涉及到

02:57.000 --> 02:58.000
很多很多的问题了

02:58.000 --> 02:59.000
比方说

02:59.000 --> 03:00.500
要不要加入到缓存

03:00.500 --> 03:01.500
不是说所有的请求

03:01.500 --> 03:03.000
响应结果都要加入到缓存

03:03.000 --> 03:04.000
要不要加入到缓存

03:04.000 --> 03:05.000
是不是要告诉它

03:05.000 --> 03:05.500
对不对

03:05.500 --> 03:07.000
缓存的时间是多久了

03:07.000 --> 03:08.500
是不是也要告诉它

03:08.500 --> 03:10.000
那么资源有改动的时候

03:10.000 --> 03:12.500
客户端如何来更新这个缓存

03:12.500 --> 03:15.000
是不是也需要通过一种协议

03:15.000 --> 03:17.500
来完成这个操作

03:17.500 --> 03:19.500
那么这些就涉及到协议了

03:19.500 --> 03:20.500
就是你要清楚

03:20.500 --> 03:23.500
这些事情里边关于缓存的协议

03:23.500 --> 03:25.500
那么一个看

03:25.500 --> 03:26.500
我们从两个方面来说

03:26.500 --> 03:29.000
一个是来自于服务器的缓存指令

03:29.000 --> 03:29.500
什么意思呢

03:29.500 --> 03:30.500
就在这里

03:30.500 --> 03:31.500
请求过后服务器

03:31.500 --> 03:32.500
不是给它一个响应吗

03:32.500 --> 03:33.500
这个响应里边

03:33.500 --> 03:34.500
它就会带一些指令

03:34.500 --> 03:35.500
我告诉你

03:35.500 --> 03:36.500
你给我缓存起来

03:36.500 --> 03:37.500
就这么个意思

03:37.500 --> 03:38.500
咱们来看一下

03:38.500 --> 03:39.500
来自服务器的缓存指令

03:39.500 --> 03:41.500
当客户端发出用Gate请求

03:41.500 --> 03:42.500
到服务器

03:42.500 --> 03:43.500
咱们其实缓存的

03:43.500 --> 03:44.500
绝大部分时候

03:44.500 --> 03:46.500
都是跟Gate请求相关的

03:46.500 --> 03:47.500
Pose请求

03:47.500 --> 03:49.500
这些东西一般不缓存的

03:49.500 --> 03:51.500
服务器可能有以下的内情活动

03:51.500 --> 03:53.500
不要让你请求这个资源

03:53.500 --> 03:54.500
我很少去改动它

03:54.500 --> 03:56.500
比方说一篇文章

03:56.500 --> 03:57.500
我写好了发布了

03:57.500 --> 03:58.500
就基本上不改的

03:58.500 --> 03:59.500
对吧

03:59.500 --> 04:00.500
那你请求的这个资源

04:00.500 --> 04:01.500
我很少会改动

04:01.500 --> 04:02.500
干脆你把它缓存起来

04:02.500 --> 04:03.500
得了

04:03.500 --> 04:05.500
以后不要来烦我了

04:05.500 --> 04:06.500
服务器就想告诉客户端

04:06.500 --> 04:07.500
这么一个消息

04:07.500 --> 04:09.500
这么一个结果

04:09.500 --> 04:10.500
那么为了表达

04:10.500 --> 04:11.500
这个美好的冤枉的服务器

04:11.500 --> 04:12.500
他怎么来告诉客户端呢

04:12.500 --> 04:14.500
他就在响应头里边

04:14.500 --> 04:15.500
加入下面的那种

04:15.500 --> 04:16.500
如果闲我说了

04:16.500 --> 04:17.500
如果说的话

04:17.500 --> 04:18.500
你直接去看那个文章

04:18.500 --> 04:19.500
我已经写的很详细了

04:19.500 --> 04:21.500
这一刻就是讲这个文章

04:21.500 --> 04:22.500
你看一下

04:22.500 --> 04:24.500
这里有一个响应头

04:24.500 --> 04:25.500
响应头里边

04:25.500 --> 04:26.500
是否包含了这么一些信息

04:26.500 --> 04:27.500
Catch Control

04:27.500 --> 04:28.500
E-Tag

04:28.500 --> 04:29.500
Dead

04:29.500 --> 04:30.500
Not Multified

04:30.500 --> 04:31.500
那么这些东西

04:31.500 --> 04:32.500
这有什么意义呢

04:32.500 --> 04:33.500
它就表达了

04:33.500 --> 04:34.500
我们详细的描述了

04:34.500 --> 04:37.500
服务器的缓存指令

04:37.500 --> 04:38.500
那就是说

04:38.500 --> 04:40.500
我希望你缓存

04:40.500 --> 04:42.500
那么我同样告诉你一些信息吧

04:42.500 --> 04:43.500
那么这些信息

04:43.500 --> 04:45.500
就全部在这些响应头里边

04:45.500 --> 04:46.500
我们一个个看吧

04:46.500 --> 04:47.500
首先是Catch Control

04:47.500 --> 04:48.500
最重要的

04:48.500 --> 04:49.500
表示缓存控制

04:49.500 --> 04:51.500
而且缓存指令

04:51.500 --> 04:52.500
那么这里边

04:52.500 --> 04:54.500
我们写了一个配置叫Max Age

04:54.500 --> 04:55.500
3600

04:55.500 --> 04:56.500
Max Age呢

04:56.500 --> 04:58.500
我们以前学Cookie的时候学过

04:58.500 --> 04:59.500
对不对

04:59.500 --> 05:00.500
Max Age什么意思

05:00.500 --> 05:03.500
就是相对过期时间

05:03.500 --> 05:06.500
就是从现在这一刻起

05:06.500 --> 05:08.500
3600秒之后

05:08.500 --> 05:10.500
这个缓存了就失效了

05:10.500 --> 05:11.500
就这么个意思

05:11.500 --> 05:12.500
3600秒内

05:12.500 --> 05:14.500
那么就缓存是有效的

05:14.500 --> 05:15.500
就这么个意思

05:15.500 --> 05:16.500
这个E-Tag呢

05:16.500 --> 05:18.500
E-Tag是一个

05:18.500 --> 05:20.500
唯一的编码的字不串

05:20.500 --> 05:22.500
它相当于是给这个资源编号

05:22.500 --> 05:23.500
你请求一个页面

05:23.500 --> 05:25.500
请求一个GS

05:25.500 --> 05:26.500
那么服务器给这个资源

05:26.500 --> 05:27.500
编一个号

05:27.500 --> 05:30.500
编一个号过后

05:30.500 --> 05:31.500
后边有用

05:31.500 --> 05:33.500
后边这个E-Tag是有用的

05:33.500 --> 05:34.500
通常情况下

05:34.500 --> 05:35.500
服务器会怎么来编号呢

05:35.500 --> 05:37.500
它会根据这个资源的内容

05:37.500 --> 05:39.500
比方说我想印一个消息体

05:39.500 --> 05:40.500
一个页面嘛

05:40.500 --> 05:41.500
一个页面是不是个ATM文档

05:41.500 --> 05:42.500
那么它会根据这个

05:42.500 --> 05:45.500
ATM文档的内容来生成一个编号

05:45.500 --> 05:46.500
那么也就是说

05:46.500 --> 05:47.500
内容一变动

05:47.500 --> 05:48.500
那个编号就会变

05:48.500 --> 05:49.500
就有点像

05:49.500 --> 05:50.500
WePack里边的哈希

05:50.500 --> 05:51.500
有点这个意思

05:51.500 --> 05:53.500
那么这个东西呢

05:53.500 --> 05:55.500
它不是说必须要用什么编码方式

05:55.500 --> 05:57.500
你随便什么编码方式都行

05:57.500 --> 05:58.500
总之呢

05:58.500 --> 05:59.500
这个E-Tag就表示

05:59.500 --> 06:00.500
我内容是相关的

06:00.500 --> 06:01.500
内容一变

06:01.500 --> 06:02.500
那个E-Tag就会变

06:02.500 --> 06:04.500
这是一个编号

06:04.500 --> 06:05.500
好

06:05.500 --> 06:06.500
这次呢是告诉

06:06.500 --> 06:08.500
是服务器的告诉客户端

06:08.500 --> 06:11.500
我目前想印你这个消息的时间

06:11.500 --> 06:12.500
它为什么要告诉这个呢

06:12.500 --> 06:14.500
因为客户端的时间

06:14.500 --> 06:15.500
是不是有可能不一样

06:15.500 --> 06:16.500
你的电脑的时间

06:16.500 --> 06:18.500
你是自己可以随便调的

06:18.500 --> 06:19.500
但是我们要以谁为准

06:19.500 --> 06:21.500
是不是要以服务器的时间为准

06:21.500 --> 06:22.500
对吧

06:22.500 --> 06:24.500
你说三千六百秒过后过期

06:24.500 --> 06:26.500
那以哪个时间为准

06:26.500 --> 06:27.500
三千六百秒过期的

06:27.500 --> 06:28.500
所以要以这个时间

06:28.500 --> 06:30.500
而不是你本地的时间

06:30.500 --> 06:31.500
那么我给你小印的

06:31.500 --> 06:32.500
这个资源的服务器时间呢

06:32.500 --> 06:34.500
是隔离微制时间

06:34.500 --> 06:35.500
GMT吧

06:35.500 --> 06:37.500
是这个时间

06:37.500 --> 06:38.500
那是Modified

06:38.500 --> 06:39.500
这什么意思呢

06:39.500 --> 06:40.500
服务器告诉客户端

06:40.500 --> 06:41.500
我这个资源的

06:41.500 --> 06:43.500
上一次的修改时间是什么

06:43.500 --> 06:45.500
比方说上一次是个时间是昨天

06:45.500 --> 06:47.500
你现在请求的是今天

06:47.500 --> 06:49.500
把这些信息全部告诉你

06:49.500 --> 06:51.500
你爱怎么操作怎么操作

06:51.500 --> 06:52.500
反正我把这些

06:52.500 --> 06:53.500
详细的信息该怎么去缓存

06:53.500 --> 06:54.500
然后这些相关的信息

06:54.500 --> 06:56.500
全部告诉你

06:56.500 --> 06:57.500
那么这个美好的愿望呢

06:57.500 --> 06:58.500
它就通过这个想用头呢

06:58.500 --> 06:59.500
就传给客户端了

06:59.500 --> 07:01.500
关键是这个

07:01.500 --> 07:03.500
如果客户端是其他应用程序

07:03.500 --> 07:04.500
比方说你是移动端

07:04.500 --> 07:06.500
或者是你是PC

07:06.500 --> 07:08.500
他可能你都不理你

07:08.500 --> 07:09.500
你这个东西

07:09.500 --> 07:10.500
他也看不懂

07:10.500 --> 07:11.500
要操作的话

07:11.500 --> 07:14.500
也是你开发者自行去操作

07:14.500 --> 07:16.500
他不会缓存任何东西

07:16.500 --> 07:17.500
但是呢

07:17.500 --> 07:19.500
如果说客户端臭巧

07:19.500 --> 07:20.500
是一个浏览器

07:20.500 --> 07:21.500
因为浏览器呢

07:21.500 --> 07:23.500
跟服务器两个人呢

07:23.500 --> 07:25.500
就配合的一直比较好

07:25.500 --> 07:26.500
对不对

07:26.500 --> 07:27.500
所以说呢

07:27.500 --> 07:28.500
浏览器呢

07:28.500 --> 07:29.500
他如果说看到了服务器

07:29.500 --> 07:30.500
有这么一个响应头

07:30.500 --> 07:31.500
他会怎么办呢

07:31.500 --> 07:33.500
他我们马上去做一些事

07:33.500 --> 07:34.500
做什么事呢

07:34.500 --> 07:35.500
就是把它缓存起来

07:35.500 --> 07:36.500
他把这一次的

07:36.500 --> 07:37.500
请求得到了响应题呢

07:37.500 --> 07:39.500
缓存到本地文件中

07:39.500 --> 07:40.500
每一个浏览器

07:40.500 --> 07:41.500
他都有一种方式

07:41.500 --> 07:43.500
总之肯定用文件保存起来

07:43.500 --> 07:45.500
谷歌浏览器也是一样

07:45.500 --> 07:47.500
你看我们谷歌浏览器

07:47.500 --> 07:48.500
不是有一个设置吗

07:48.500 --> 07:49.500
对不对

07:49.500 --> 07:51.500
他清空缓存

07:51.500 --> 07:52.500
我看一下在哪里

07:52.500 --> 07:53.500
清除浏览数据

07:53.500 --> 07:55.500
清除浏览数据的时候呢

07:55.500 --> 07:57.500
他就有一个清除缓存

07:57.500 --> 07:59.500
他有个清除缓存

07:59.500 --> 08:01.500
缓存的图片和文件

08:01.500 --> 08:02.500
对不对

08:02.500 --> 08:03.500
他有这么一个东西

08:03.500 --> 08:04.500
可以清除缓存

08:04.500 --> 08:05.500
就这么个意思

08:05.500 --> 08:07.500
他把这个

08:07.500 --> 08:09.500
就是想用题

08:09.500 --> 08:11.500
保存到本地文件里边

08:11.500 --> 08:13.500
并且做一些标记

08:13.500 --> 08:14.500
首先你这个是

08:14.500 --> 08:15.500
请求的请求方法

08:15.500 --> 08:16.500
和请求路径是啥

08:16.500 --> 08:17.500
什么叫请求方法

08:17.500 --> 08:18.500
和请求路径呢

08:18.500 --> 08:19.500
就是你请求

08:19.500 --> 08:20.500
头里边的东西

08:20.500 --> 08:22.500
比方说我们访问百度

08:22.500 --> 08:25.500
我们看一下这个检查

08:25.500 --> 08:28.500
到这个network里面去

08:28.500 --> 08:30.500
访问百度

08:30.500 --> 08:32.500
等一下

08:32.500 --> 08:33.500
你看百度这个页面

08:33.500 --> 08:35.500
他各里的给的

08:35.500 --> 08:36.500
我们请求的时候

08:36.500 --> 08:38.500
是不是这个

08:38.500 --> 08:40.500
请求

08:40.500 --> 08:43.500
那就是想用了

08:43.500 --> 08:44.500
请求

08:44.500 --> 08:45.500
你看

08:45.500 --> 08:46.500
这个是不是那个

08:46.500 --> 08:48.500
就是请求方法

08:48.500 --> 08:49.500
这个是不是请求路径

08:49.500 --> 08:50.500
比方说我们再来

08:50.500 --> 08:52.500
说出一个

08:52.500 --> 08:57.280
说出一个漏的接识

08:57.280 --> 08:58.280
刷新识

08:58.280 --> 08:59.280
漏了接识

08:59.280 --> 09:00.280
你看一下

09:00.280 --> 09:02.280
我们的请求头

09:02.280 --> 09:03.280
请求方法

09:03.280 --> 09:04.280
后面是不是请求路径

09:04.280 --> 09:05.280
很长一串

09:05.280 --> 09:06.280
是不是请求路径

09:06.280 --> 09:07.280
对不对

09:07.280 --> 09:08.280
那么这些呢

09:08.280 --> 09:09.280
就是把这两个东西

09:09.280 --> 09:10.280
要标记一下

09:10.280 --> 09:11.280
就是我请求

09:11.280 --> 09:12.280
什么样的方法

09:12.280 --> 09:13.280
和请求什么样的路径

09:13.280 --> 09:14.280
缓存了什么样的东西

09:14.280 --> 09:15.280
然后还标记什么呢

09:15.280 --> 09:17.280
缓存的过期时间

09:17.280 --> 09:18.280
3600秒

09:18.280 --> 09:19.280
然后还要标记什么呢

09:19.280 --> 09:21.280
还要标记的就是

09:21.280 --> 09:23.280
就是这些东西

09:23.280 --> 09:25.280
服务器的响应时间

09:25.280 --> 09:27.280
然后服务器给予的

09:27.280 --> 09:28.280
资源变耗券

09:28.280 --> 09:29.280
全部把标记下来

09:29.280 --> 09:30.280
然后上一次修改时间

09:30.280 --> 09:31.280
全部把标记下来

09:31.280 --> 09:32.280
那么这一次

09:32.280 --> 09:33.280
基础就非常重要了

09:33.280 --> 09:34.280
因为后边

09:34.280 --> 09:36.280
我们要不要使用本地缓存

09:36.280 --> 09:39.280
就取决于这些基础

09:39.280 --> 09:40.280
比方说我们这里

09:40.280 --> 09:41.280
你看啊这个原理图

09:41.280 --> 09:42.280
请求服务器

09:42.280 --> 09:44.280
服务器处理啊请求

09:44.280 --> 09:45.280
然后给我一个200 ok

09:45.280 --> 09:46.280
对吧

09:46.280 --> 09:47.280
然后呢给我这么一些东西

09:47.280 --> 09:48.280
看没

09:48.280 --> 09:49.280
给我这么一些东西

09:49.280 --> 09:50.280
然后呢我把它

09:50.280 --> 09:51.280
把这东西呢

09:51.280 --> 09:52.280
加入到缓存里面

09:52.280 --> 09:53.280
流烂器就加入到缓存里面

09:53.280 --> 09:54.280
同时呢

09:54.280 --> 09:55.280
你如果说是页面啊

09:55.280 --> 09:56.280
或者是介石啊

09:56.280 --> 09:57.280
流烂器还要直循会渲染

09:57.280 --> 09:59.280
同时把它加入到缓存里面

09:59.280 --> 10:00.280
那么缓存里面

10:00.280 --> 10:02.280
他就记住这些东西

10:02.280 --> 10:03.280
到缓存中了

10:03.280 --> 10:04.280
没有意思

10:04.280 --> 10:05.280
好这是第1个

10:05.280 --> 10:07.280
来自服务器的缓存指令

10:07.280 --> 10:08.280
好第2个呢

10:08.280 --> 10:11.280
是来自于客户端的缓存指令

10:11.280 --> 10:12.280
就是我们下一次请求

10:12.280 --> 10:14.280
后续请求的时候呢

10:14.280 --> 10:15.280
客户端

10:15.280 --> 10:16.280
他应该是通过什么样的逻辑

10:16.280 --> 10:17.280
来进行操作

10:17.280 --> 10:18.280
比方说

10:18.280 --> 10:19.280
当我们客户端

10:19.280 --> 10:21.280
准备再一次去请求

10:21.280 --> 10:23.280
这个index的介石的时候

10:23.280 --> 10:24.280
比方说之前

10:24.280 --> 10:26.280
我们请求的是个index介石

10:26.280 --> 10:27.280
那么后续客户端

10:27.280 --> 10:28.280
再去请求他的时候

10:28.280 --> 10:29.280
同样是盖着请求

10:29.280 --> 10:30.280
那么这个时候呢

10:30.280 --> 10:31.280
流烂器就想

10:31.280 --> 10:32.280
哎我要的东西

10:32.280 --> 10:34.280
是不是之前缓存过呢

10:34.280 --> 10:35.280
如果说有缓存的话

10:35.280 --> 10:37.280
我能不能去直接使用缓存呢

10:37.280 --> 10:39.280
对不对他就会有一个决策过程

10:39.280 --> 10:40.280
那么这个决策过程呢

10:40.280 --> 10:43.280
我们把它通常称之为缓存策略

10:43.280 --> 10:45.280
那么客户端呢

10:45.280 --> 10:47.280
去缓存中如何去寻找

10:47.280 --> 10:48.280
有缓存的资源呢

10:48.280 --> 10:49.280
到底要不要用缓存

10:49.280 --> 10:50.280
那么他整一个过程呢

10:50.280 --> 10:51.280
他是这样子

10:51.280 --> 10:52.280
主要分为两步

10:52.280 --> 10:53.280
第一步呢

10:53.280 --> 10:55.280
是判断缓存里面呢

10:55.280 --> 10:56.280
是不是有

10:56.280 --> 10:58.280
匹配的请求方法

10:58.280 --> 10:59.280
和请求路径

10:59.280 --> 11:00.280
你不是用盖着请求

11:00.280 --> 11:01.280
去请求他吗

11:01.280 --> 11:03.280
那么有没有这匹配的方法

11:03.280 --> 11:05.280
你看之前我们是不是记录过了

11:06.280 --> 11:07.280
记录过了

11:07.280 --> 11:08.280
那么有没有这样的匹配方法

11:08.280 --> 11:09.280
和匹配的路径

11:09.280 --> 11:10.280
如果说有的话

11:10.280 --> 11:11.280
那我怎么样怎么样

11:11.280 --> 11:12.280
如果说没有的话

11:12.280 --> 11:13.280
又怎么样怎么样

11:13.280 --> 11:14.280
如果有的话

11:14.280 --> 11:16.280
这个缓存资源是不是还有效呢

11:16.280 --> 11:17.280
过期没有呢

11:17.280 --> 11:18.280
对不对

11:18.280 --> 11:19.280
那么这两个验证呢

11:19.280 --> 11:20.280
就会导致流烂器呢

11:20.280 --> 11:21.280
产生不同的行为

11:21.280 --> 11:22.280
比方说啊

11:22.280 --> 11:24.280
咱们这下面是一个流程图

11:24.280 --> 11:25.280
决策图

11:25.280 --> 11:26.280
如果说我去请求

11:26.280 --> 11:28.280
盖着请求请求这个地址

11:28.280 --> 11:29.280
我们首先看一下

11:29.280 --> 11:31.280
请求方法和请求路径

11:31.280 --> 11:32.280
有没有匹配的缓存

11:32.280 --> 11:33.280
如果说没有的话

11:33.280 --> 11:35.280
那就是一个普通请求

11:35.280 --> 11:36.280
发到服务器

11:36.280 --> 11:37.280
普普通通请求

11:37.280 --> 11:38.280
跟之前的请求没有什么区别

11:38.280 --> 11:39.280
跟那个之前的第1次

11:39.280 --> 11:40.280
一个请求没有什么区别

11:40.280 --> 11:41.280
所以说服务器

11:41.280 --> 11:42.280
肯定会老老实实

11:42.280 --> 11:43.280
给我们返回一个200ok

11:43.280 --> 11:45.280
然后一个完整的消息体

11:45.280 --> 11:46.280
对不对

11:46.280 --> 11:47.280
该缓存就缓存

11:47.280 --> 11:48.280
好

11:48.280 --> 11:50.280
如果说他有缓存

11:50.280 --> 11:51.280
那么我要判断

11:51.280 --> 11:52.280
缓存是不是有效

11:52.280 --> 11:54.280
如果说缓存有效的话

11:54.280 --> 11:55.280
那么就不会请求服务器

11:55.280 --> 11:57.280
直接使用缓存

11:57.280 --> 11:59.280
如果说缓存无效

11:59.280 --> 12:01.280
那么就请求服务器

12:02.280 --> 12:04.280
是一个带缓存的请求

12:04.280 --> 12:07.280
我们把它叫做缓存确诊请求

12:08.280 --> 12:09.280
它不是说

12:09.280 --> 12:11.280
不是说又是一个普通请求

12:11.280 --> 12:12.280
不是一个普通请求

12:12.280 --> 12:13.280
咱们再想想看

12:13.280 --> 12:14.280
下面一个样图

12:14.280 --> 12:15.280
如果说没有缓存

12:15.280 --> 12:17.280
那么我就是普通请求

12:17.280 --> 12:18.280
普通请求

12:18.280 --> 12:19.280
它自然返回一个200ok

12:19.280 --> 12:20.280
然后我把缓存下来

12:20.280 --> 12:21.280
缓存下来过后

12:21.280 --> 12:22.280
那么后续请求

12:22.280 --> 12:23.280
如果说发现有缓存

12:23.280 --> 12:25.280
缓存没有过期

12:25.280 --> 12:26.280
你看缓存有效期

12:26.280 --> 12:27.280
它没有过期

12:27.280 --> 12:28.280
那我直接从缓存里面

12:28.280 --> 12:29.280
读结果

12:29.280 --> 12:30.280
就这么一个逻辑

12:30.280 --> 12:32.280
好 如果说缓存过期了

12:32.280 --> 12:33.280
那么我就是

12:33.280 --> 12:35.280
一个不是一个普通请求了

12:35.280 --> 12:36.280
是一个带缓存的请求

12:36.280 --> 12:38.280
去请求服务器

12:38.280 --> 12:40.280
因为是缓存失效了

12:40.280 --> 12:42.280
那么我们再详细点说

12:42.280 --> 12:44.280
要验证

12:44.280 --> 12:45.280
是否匹配的缓存

12:45.280 --> 12:46.280
其实非常简单

12:46.280 --> 12:47.280
只用get的方法

12:47.280 --> 12:49.280
和录信区匹配就完事了

12:49.280 --> 12:50.280
如果没有的话

12:50.280 --> 12:51.280
那么这个就是

12:51.280 --> 12:52.280
跟第一次请求服务器

12:52.280 --> 12:53.280
是一样

12:53.280 --> 12:54.280
就是普通请求没什么好说的

12:54.280 --> 12:56.280
关键是在于缓存

12:56.280 --> 12:57.280
是否有效

12:57.280 --> 12:58.280
就在这

12:58.280 --> 12:59.280
这个地方的逻辑

12:59.280 --> 13:00.280
缓存是不是有效

13:00.280 --> 13:01.280
有效的话

13:01.280 --> 13:02.280
其实也很简单

13:02.280 --> 13:03.280
直接从缓存里边读

13:03.280 --> 13:04.280
对吧

13:05.280 --> 13:06.280
那么

13:06.280 --> 13:07.280
它怎么来判断

13:07.280 --> 13:08.280
是不是有效了

13:08.280 --> 13:09.280
它的判断方式是

13:09.280 --> 13:10.280
我们之前不是标记过

13:10.280 --> 13:12.280
一个服务器的响应时间吗

13:12.280 --> 13:13.280
对不对

13:13.280 --> 13:14.280
缓存的时候

13:14.280 --> 13:15.280
就是标记我服务器的响应时间

13:15.280 --> 13:16.280
对吧

13:16.280 --> 13:17.280
好

13:17.280 --> 13:18.280
那么怎么来判断

13:18.280 --> 13:19.280
缓存是不是有效了

13:19.280 --> 13:20.280
它就会用这个时间

13:20.280 --> 13:21.280
加上这个max edge

13:21.280 --> 13:22.280
加上3600秒

13:22.280 --> 13:24.280
是不是得到一个新的日期

13:24.280 --> 13:25.280
一个新的过期时间

13:25.280 --> 13:27.280
比方说我一个小时前

13:27.280 --> 13:28.280
一个小时前缓存的

13:28.280 --> 13:29.280
那么

13:29.280 --> 13:30.280
那么一个小时前

13:30.280 --> 13:31.280
服务器给我了一个时间

13:31.280 --> 13:32.280
然后那服务器的

13:32.280 --> 13:33.280
告诉你缓存两个小时

13:33.280 --> 13:34.280
那我说

13:34.280 --> 13:35.280
之前服务器的响应时间

13:35.280 --> 13:37.280
加上那个

13:37.280 --> 13:39.280
那个max edge

13:39.280 --> 13:40.280
是吧

13:40.280 --> 13:41.280
两个小时的max edge

13:41.280 --> 13:43.280
那么我们看一下过期时间

13:43.280 --> 13:45.280
看一下过期时间倒不倒

13:45.280 --> 13:47.280
如果说过期时间

13:47.280 --> 13:49.280
小于

13:49.280 --> 13:50.280
我这个写错了是吧

13:50.280 --> 13:51.280
过期时间

13:51.280 --> 13:53.280
是否

13:53.280 --> 13:55.280
大雨当前时间

13:55.280 --> 13:57.280
大雨当前时间

13:57.280 --> 13:58.280
过期时间还没到

13:58.280 --> 13:59.280
还没到的话

13:59.280 --> 14:01.280
那么表示缓存还没有过期

14:01.280 --> 14:02.280
仍然有效

14:02.280 --> 14:03.280
如果说过

14:03.280 --> 14:05.280
如果说那个过期时间

14:05.280 --> 14:06.280
是小于

14:06.280 --> 14:07.280
当前时间

14:07.280 --> 14:08.280
表示缓存失效了

14:08.280 --> 14:09.280
对不对

14:09.280 --> 14:10.280
那么下面我分成

14:10.280 --> 14:11.280
两个情况来说

14:11.280 --> 14:12.280
一个是缓存有效

14:12.280 --> 14:13.280
一个是缓存无效

14:13.280 --> 14:14.280
过期时间还没到

14:14.280 --> 14:15.280
过期时间

14:15.280 --> 14:16.280
如果说没到的话

14:16.280 --> 14:17.280
那么浏览器

14:17.280 --> 14:18.280
发现缓存有效时

14:18.280 --> 14:19.280
这个时候

14:19.280 --> 14:20.280
它完全不会去

14:20.280 --> 14:21.280
请求服务器

14:21.280 --> 14:23.280
直接使用缓存的结果

14:23.280 --> 14:24.280
就可以了

14:24.280 --> 14:26.280
这个时候

14:26.280 --> 14:27.280
让开网络

14:27.280 --> 14:28.280
你都会发现

14:28.280 --> 14:29.280
这个资源真的是可以用的

14:29.280 --> 14:30.280
没了意思吧

14:30.280 --> 14:31.280
这种情况

14:31.280 --> 14:33.280
会极大的降低服务器的压力

14:33.280 --> 14:35.280
有些网站

14:35.280 --> 14:36.280
它对那种

14:36.280 --> 14:38.280
请求压力特别大

14:38.280 --> 14:39.280
那么特别大的时候

14:39.280 --> 14:41.280
它也不愿意去增加

14:41.280 --> 14:42.280
服务器的成本

14:42.280 --> 14:45.280
不用去增加服务器

14:45.280 --> 14:46.280
那么这种时候

14:46.280 --> 14:47.280
就有一些变态

14:47.280 --> 14:48.280
非常变态的

14:48.280 --> 14:49.280
就是

14:49.280 --> 14:51.280
效率上的要求

14:51.280 --> 14:52.280
因此

14:52.280 --> 14:53.280
我们这里

14:53.280 --> 14:54.280
就可以用这种

14:55.280 --> 14:56.280
这种模式

14:56.280 --> 14:57.280
缓存的那种模式

14:57.280 --> 14:58.280
它就不会去请求服务器了

14:58.280 --> 14:59.280
根本就不会请求

14:59.280 --> 15:01.280
咱们还是把讲完的

15:01.280 --> 15:03.280
再举例子吧

15:03.280 --> 15:05.280
看下一个

15:05.280 --> 15:09.280
下一个是缓存无效

15:09.280 --> 15:11.280
就说缓存已经过期了

15:11.280 --> 15:12.280
那么这个时候

15:12.280 --> 15:14.280
客户端干干嘛呢

15:14.280 --> 15:15.280
它不是说

15:15.280 --> 15:16.280
把缓存删掉

15:16.280 --> 15:17.280
它不会这么做

15:17.280 --> 15:18.280
Cookie就是直接

15:18.280 --> 15:19.280
把Cookie给它删了

15:19.280 --> 15:21.280
这个缓存不会

15:21.280 --> 15:22.280
它还是

15:22.280 --> 15:24.280
它会去重新问一下服务器

15:24.280 --> 15:26.280
说我这个缓存

15:26.280 --> 15:27.280
我这边过期了

15:27.280 --> 15:29.280
你只想给我那个过期时间嘛

15:29.280 --> 15:30.280
但是真实情况那边

15:30.280 --> 15:32.280
到底过没过期呢

15:32.280 --> 15:33.280
因为有可能

15:33.280 --> 15:34.280
它会有一种字面

15:34.280 --> 15:35.280
比方说

15:35.280 --> 15:36.280
有一篇文章

15:36.280 --> 15:37.280
服务器它也不能确定

15:37.280 --> 15:38.280
这个文章什么时候

15:38.280 --> 15:39.280
被修改对吧

15:39.280 --> 15:40.280
它也确定不了

15:40.280 --> 15:41.280
我说你先缓存个

15:41.280 --> 15:42.280
一天

15:42.280 --> 15:43.280
一天过后再来问我

15:43.280 --> 15:44.280
我看一下

15:44.280 --> 15:45.280
一天过后

15:45.280 --> 15:46.280
有没有更新

15:46.280 --> 15:47.280
那就这么个意思

15:47.280 --> 15:48.280
说服务

15:48.280 --> 15:49.280
它就会再去问一下服务器

15:49.280 --> 15:50.280
有没有更新

15:50.280 --> 15:52.280
这叫缓存确认

15:52.280 --> 15:53.280
它会发一个请求

15:53.280 --> 15:55.280
叫缓存确认

15:55.280 --> 15:56.280
那么怎么来发一个

15:56.280 --> 15:57.280
缓存确认的请求呢

15:57.280 --> 15:58.280
它这样子

15:58.280 --> 15:59.280
请求的时候

15:59.280 --> 16:00.280
客户端

16:00.280 --> 16:02.280
你不用自己手动写

16:02.280 --> 16:04.280
浏览机会自己给你搞定

16:04.280 --> 16:06.280
当它发现缓存过期的时候

16:06.280 --> 16:08.280
请求的是同一个资源

16:08.280 --> 16:09.280
于是它会加入

16:09.280 --> 16:11.280
这样的请求头

16:11.280 --> 16:14.280
if modified since

16:14.280 --> 16:15.280
就说这个东西说什么呢

16:15.280 --> 16:16.280
这个东西就是

16:16.280 --> 16:17.280
文件的

16:17.280 --> 16:19.280
上一次的修改日期

16:19.280 --> 16:21.280
之前我们缓存的时候

16:21.280 --> 16:22.280
记录了

16:22.280 --> 16:23.280
记录了就是缓存的

16:23.280 --> 16:25.280
缓存资源的修改日期

16:25.280 --> 16:27.280
不一定是文件

16:27.280 --> 16:29.280
修改日期

16:29.280 --> 16:30.280
那么服务器告诉我了

16:30.280 --> 16:32.280
那我这里再把日期

16:32.280 --> 16:33.280
带给服务器

16:33.280 --> 16:34.280
然后顺便

16:34.280 --> 16:35.280
我再把这个东西带过去

16:35.280 --> 16:37.280
之前你不是给了我一个

16:37.280 --> 16:38.280
编号吗

16:38.280 --> 16:39.280
我把编号再带给你

16:39.280 --> 16:40.280
那么服务器

16:40.280 --> 16:41.280
根据这两个信息

16:41.280 --> 16:42.280
来判断

16:42.280 --> 16:43.280
你看这个东西

16:43.280 --> 16:44.280
是不是过期了

16:44.280 --> 16:46.280
比方说服务器判断

16:46.280 --> 16:47.280
这个东西怎么判断

16:47.280 --> 16:48.280
它就判断

16:48.280 --> 16:50.280
比方说我这里是一个文件

16:50.280 --> 16:51.280
这个文件的

16:51.280 --> 16:52.280
上一次修改日期

16:52.280 --> 16:53.280
是这个日期

16:53.280 --> 16:54.280
但是这个日期之后

16:54.280 --> 16:55.280
发现这个文件又更改了

16:55.280 --> 16:56.280
说明这个缓存

16:56.280 --> 16:58.280
那确实就无效了

16:58.280 --> 16:59.280
对不对

16:59.280 --> 17:00.280
如果说服务器

17:00.280 --> 17:02.280
你也可以根据这个来判断

17:02.280 --> 17:04.280
看一下这个文件的编号

17:04.280 --> 17:05.280
编号过后

17:05.280 --> 17:06.280
是不是一样的

17:06.280 --> 17:07.280
如果说不一样的话

17:07.280 --> 17:08.280
那肯定是有改动

17:08.280 --> 17:10.280
服务器根据这两个东西

17:10.280 --> 17:12.280
可以进行判断的

17:12.280 --> 17:13.280
那么这样子

17:13.280 --> 17:15.280
你看这个一个是修改日期

17:15.280 --> 17:16.280
一个是编号

17:16.280 --> 17:17.280
这样子的服务器

17:19.280 --> 17:21.660
服务器可以判断了

17:21.660 --> 17:23.660
那么服务器到底判断哪一个

17:23.660 --> 17:24.660
这说不准的

17:25.660 --> 17:27.660
大部分服务器都可以自动判断

17:27.660 --> 17:28.660
不用你手写带

17:28.660 --> 17:29.660
他可以自动判断的

17:29.660 --> 17:30.660
如果他发现

17:30.660 --> 17:32.660
请求头里边有这两个东西

17:32.660 --> 17:33.660
他会自动判断

17:33.660 --> 17:35.660
有的服务器判断的是

17:35.660 --> 17:36.660
这个

17:36.660 --> 17:38.660
有的服务器判断的是这个

17:38.660 --> 17:40.660
这个玩意实际上是比较早的

17:40.660 --> 17:42.660
这个玩意是比较新的

17:42.660 --> 17:43.660
这个是1.0的

17:43.660 --> 17:45.660
ATP1.0协议的

17:45.660 --> 17:47.660
这个是1.1协议的

17:49.660 --> 17:51.660
现在大部分服务器

17:51.660 --> 17:53.660
你如果说传了这个

17:53.660 --> 17:55.660
那我就直接判断这个就完事了

17:55.660 --> 17:57.660
Experience服务器

17:57.660 --> 17:58.660
他就只判断这个

17:58.660 --> 17:59.660
如果说你传了这个

17:59.660 --> 18:00.660
如果说你没传的话

18:00.660 --> 18:01.660
我就判断这个

18:01.660 --> 18:02.660
如果说都没传

18:02.660 --> 18:03.660
那就是个普通请求了

18:03.660 --> 18:04.660
我给你返回

18:04.660 --> 18:05.660
两百OK

18:05.660 --> 18:06.660
那么这个问题他就跑给服务器了

18:06.660 --> 18:07.660
服务器

18:07.660 --> 18:08.660
他就会产生两种情况

18:08.660 --> 18:10.660
一种是缓存已经失效

18:10.660 --> 18:12.660
缓存仍然有效

18:12.660 --> 18:14.660
如果说缓存已经失效了

18:14.660 --> 18:15.660
那么非常简单的

18:15.660 --> 18:17.660
服务器给予一个正常的响应

18:17.660 --> 18:18.660
怎么知道正常的响应呢

18:18.660 --> 18:20.660
就是响应两百

18:20.660 --> 18:22.660
带一个响应体

18:22.660 --> 18:24.660
同时附带上新的缓存指令

18:24.660 --> 18:25.660
如果说需要缓存的话

18:25.660 --> 18:27.660
给他一个新的缓存指令

18:27.660 --> 18:28.660
OK那么可武端

18:28.660 --> 18:30.660
那就把缓存更新就完事了

18:30.660 --> 18:33.660
那如果说缓存仍然有效

18:33.660 --> 18:35.660
而服务器他就会

18:35.660 --> 18:36.660
怎么样了

18:36.660 --> 18:38.660
他就会用一种极其简单的方式

18:38.660 --> 18:40.660
告诉可武端

18:40.660 --> 18:41.660
怎么方式呢

18:41.660 --> 18:43.660
就是给他一个响应

18:44.660 --> 18:45.660
304

18:45.660 --> 18:47.660
304叫做large modified

18:47.660 --> 18:50.660
如果说你学了网络编程

18:50.660 --> 18:51.660
就是网络通信

18:51.660 --> 18:53.660
那你应该知道304

18:53.660 --> 18:55.660
而且不给他响应体

18:55.660 --> 18:56.660
你看一下不给他响应体

18:56.660 --> 18:57.660
为什么不给他

18:57.660 --> 18:58.660
因为你都缓存了

18:58.660 --> 18:59.660
你说了你缓存了

18:59.660 --> 19:00.660
你给我发的消息头

19:00.660 --> 19:01.660
里边你说了你缓存了

19:01.660 --> 19:03.660
那你缓存了我给你什么消息体呢

19:03.660 --> 19:06.660
这样子可以减少传输量

19:06.660 --> 19:07.660
对不对

19:07.660 --> 19:08.660
不给你消息体了

19:08.660 --> 19:09.660
我就给你响应头

19:09.660 --> 19:11.660
你自己去搞定吧

19:11.660 --> 19:12.660
然后那响应头上

19:12.660 --> 19:13.660
附带上新的缓存指令

19:13.660 --> 19:15.660
说你再给我缓存一天

19:15.660 --> 19:16.660
再给我缓存两天

19:16.660 --> 19:18.660
那么可不断就更新了

19:18.660 --> 19:19.660
就这么个意思

19:19.660 --> 19:21.660
那么这个完整的交付过程就是这样子

19:21.660 --> 19:23.660
首先如果说没有缓存

19:23.660 --> 19:24.660
普通琴球

19:24.660 --> 19:26.660
服务器给他一个缓存指令

19:26.660 --> 19:27.660
然后200 OK

19:27.660 --> 19:29.660
就加入到缓存

19:29.660 --> 19:31.660
后续琴球就直接从缓存里边读

19:31.660 --> 19:34.660
如果说过期了

19:34.660 --> 19:35.660
过期要怎么办呢

19:35.660 --> 19:37.660
发一个缓存确诊琴球

19:37.660 --> 19:40.660
就是再加一个消息头

19:40.660 --> 19:41.660
就这两个

19:41.660 --> 19:42.660
然后的服务器去验证

19:42.660 --> 19:43.660
到底有没有过期

19:43.660 --> 19:44.660
如果说

19:44.660 --> 19:46.660
他如果说过期了

19:46.660 --> 19:47.660
那你缓存还是缓存200 OK

19:47.660 --> 19:48.660
加上缓存指令

19:48.660 --> 19:50.660
更新缓存对吧

19:50.660 --> 19:51.660
如果说他没有过期

19:51.660 --> 19:53.660
缓存的是304

19:53.660 --> 19:55.660
然后带上一个缓存指令

19:55.660 --> 19:56.660
客户端这边说

19:56.660 --> 19:58.660
304一看到304就明白了

19:58.660 --> 19:59.660
那你不用说了

19:59.660 --> 20:01.660
我还是使用之前的缓存

20:01.660 --> 20:02.660
之前的缓存没有3

20:02.660 --> 20:03.660
还在用

20:03.660 --> 20:05.660
然后同时延长缓存的有消息

20:05.660 --> 20:07.660
后续琴球又从缓存里边读

20:07.660 --> 20:09.660
这就是缓存的

20:09.660 --> 20:10.660
这种模式

20:10.660 --> 20:11.660
你看这种模式下来

20:11.660 --> 20:13.660
是不是节省了很多的琴球

20:13.660 --> 20:14.660
并且呢

20:14.660 --> 20:15.660
即便是有琴球

20:15.660 --> 20:16.660
很有可能的

20:16.660 --> 20:18.660
他不会传输响应体

20:18.660 --> 20:20.660
所以大幅度的提高了效率

20:20.660 --> 20:22.660
这是我们的基本概念

20:22.660 --> 20:24.660
我们讲完了再举例子

20:24.660 --> 20:26.660
后边是一些细节

20:26.660 --> 20:27.660
我们一个个说吧

20:27.660 --> 20:29.660
开启康处

20:29.660 --> 20:31.660
这个东西呢

20:31.660 --> 20:33.660
是服务器向客户端

20:33.660 --> 20:35.660
想用的一个消息头

20:35.660 --> 20:36.660
其实客户端也可以

20:36.660 --> 20:37.660
发动琴球的时候

20:37.660 --> 20:38.660
也可以发动这个东西

20:38.660 --> 20:40.660
只不过通常情况下

20:40.660 --> 20:41.660
这个网页是服务端

20:41.660 --> 20:42.660
给客户端发动的

20:42.660 --> 20:44.660
它提供一个max age

20:44.660 --> 20:45.660
由于指定缓存的时间

20:45.660 --> 20:47.660
实际上它还可以取多个字

20:47.660 --> 20:48.660
看有点像什么

20:48.660 --> 20:49.660
cokey

20:49.660 --> 20:50.660
它可以取多个字的

20:50.660 --> 20:52.660
public private

20:52.660 --> 20:54.660
这个是指示

20:54.660 --> 20:55.660
服务器说

20:55.660 --> 20:57.660
我这个资源是公开的

20:57.660 --> 20:59.660
所有人都可以黄问

20:59.660 --> 21:01.660
每个人看到的东西都是一样的

21:01.660 --> 21:03.660
private什么意思呢

21:03.660 --> 21:05.660
就是我这个资源是私有的

21:05.660 --> 21:07.660
每个人看到的可能不一样

21:07.660 --> 21:09.660
那么这两个东西有什么意义呢

21:09.660 --> 21:10.660
没有什么意义

21:10.660 --> 21:12.660
对于浏览器而言

21:12.660 --> 21:15.660
这两个东西随便都一样

21:15.660 --> 21:17.660
因为浏览器它不区分这个东西

21:17.660 --> 21:20.660
但是我们这个协议

21:20.660 --> 21:21.660
它是这样子的

21:21.660 --> 21:24.660
它不是说你不用我就不给你发

21:24.660 --> 21:25.660
我也不知道你用不用

21:25.660 --> 21:27.660
我也不确定你到底是浏览器

21:27.660 --> 21:28.660
还是一个什么玩意

21:28.660 --> 21:29.660
我也不知道

21:29.660 --> 21:31.660
所以说我把我自己的情况

21:31.660 --> 21:32.660
给你说清楚

21:32.660 --> 21:34.660
这些信息你要用就用

21:34.660 --> 21:35.660
不用拉倒

21:35.660 --> 21:36.660
它是这么个意思

21:36.660 --> 21:39.660
这两个东西对于一些服务器

21:39.660 --> 21:41.660
就是加购的话会有用

21:41.660 --> 21:42.660
比方说

21:42.660 --> 21:44.660
比方说这种情况

21:44.660 --> 21:48.550
就是客户端

21:48.550 --> 21:50.550
请求的是什么呢

21:50.550 --> 21:52.550
请求的不是直接请求服务器

21:52.550 --> 21:54.550
请求的是一个缓存服务器

21:54.550 --> 21:57.550
缓存服务器再去请求漏的服务器

21:57.550 --> 22:00.550
如果说这种结构的话可能有用

22:00.550 --> 22:02.550
缓存服务器你可以编写代码

22:02.550 --> 22:04.550
如果说这边服务器给你发送的是

22:04.550 --> 22:05.550
一个public

22:05.550 --> 22:07.550
那我就缓存

22:07.550 --> 22:09.550
如果说privates的话

22:09.550 --> 22:11.550
那如果说privates的话

22:11.550 --> 22:13.550
privates就只能给客户端缓存

22:13.550 --> 22:15.550
如果说public的话我就缓存到这

22:15.550 --> 22:17.550
就是这么个意思

22:17.550 --> 22:19.550
他就说把这些信息提供给你

22:19.550 --> 22:20.550
你爱怎么用

22:20.550 --> 22:22.860
怎么用

22:22.860 --> 22:23.860
就这一块

22:23.860 --> 22:25.860
这边再继续

22:25.860 --> 22:27.860
然后locatch这个指令

22:27.860 --> 22:29.860
这是高出客户端

22:29.860 --> 22:30.860
你可以缓存

22:30.860 --> 22:31.860
你缓存没问题

22:31.860 --> 22:32.860
你继续缓存就行了

22:32.860 --> 22:34.860
但是你不能直接使用它

22:34.860 --> 22:35.860
就是你缓存下来了

22:35.860 --> 22:36.860
尽管你没有过去

22:37.860 --> 22:39.860
你每一次请求都必须要

22:39.860 --> 22:41.860
是一个缓存确诊请求

22:41.860 --> 22:43.860
去问一下服务器

22:43.860 --> 22:44.860
有没有过去

22:44.860 --> 22:45.860
哪怕你这边没有过去

22:45.860 --> 22:46.860
你都要去问服务器

22:46.860 --> 22:48.860
服务器说有没有过去

22:48.860 --> 22:49.860
那么这种情况

22:49.860 --> 22:50.860
一般适用于什么

22:50.860 --> 22:51.860
一般适用于就是

22:51.860 --> 22:53.860
变更的比较平凡的资源

22:55.860 --> 22:57.860
资源变更的比较平凡

22:57.860 --> 22:58.860
所以说

22:58.860 --> 22:59.860
如果说你缓存到客户端

22:59.860 --> 23:00.860
可能也缓存一个小时

23:00.860 --> 23:01.860
那这一个小时

23:01.860 --> 23:02.860
可能别人变了很多次了

23:02.860 --> 23:04.860
你这边看不到这个变化

23:04.860 --> 23:06.860
所以说你每一次去问服务器

23:06.860 --> 23:07.860
你没有再带一个缓存确诊

23:07.860 --> 23:09.860
你又没有更新

23:09.860 --> 23:10.860
没有更新的话

23:10.860 --> 23:11.860
我就直接使用缓存

23:11.860 --> 23:13.860
你不要给我发消息提了

23:13.860 --> 23:14.860
就这么个意思

23:15.860 --> 23:16.860
虽然说我缓存

23:16.860 --> 23:18.860
但是不使用这个缓存

23:20.860 --> 23:22.860
那么这个low storm

23:22.860 --> 23:23.860
这上面有点像蓝

23:23.860 --> 23:24.860
有点像就是

23:25.860 --> 23:26.860
咱们国家的

23:27.860 --> 23:29.860
核武器的限制

23:30.860 --> 23:32.860
我有核武器

23:32.860 --> 23:34.860
但是我保证我不使用它

23:34.860 --> 23:35.860
就这么个意思

23:36.860 --> 23:37.860
no storm

23:37.860 --> 23:38.860
高速客户端

23:38.860 --> 23:40.860
这个东西就比较狠了

23:40.860 --> 23:41.860
高速客户端

23:41.860 --> 23:42.860
不要做任何的缓存

23:42.860 --> 23:43.860
你根本就不要把它存下来

23:43.860 --> 23:45.860
每一次请求都是正常请求

23:45.860 --> 23:46.860
每一次响应都是正常响应

23:47.860 --> 23:48.860
就这么个意思

23:48.860 --> 23:49.860
no storm

23:49.860 --> 23:50.860
这种情况用的比较少

23:50.860 --> 23:51.860
我们一般

23:51.860 --> 23:52.860
如果说比较更新的

23:52.860 --> 23:53.860
比较平凡的资源

23:53.860 --> 23:54.860
我们用的都开启够了

23:54.860 --> 23:55.860
Mac 7呢

23:55.860 --> 23:56.860
不再该出了

23:56.860 --> 23:57.860
原理是吧

23:57.860 --> 23:59.860
那么这个是

23:59.860 --> 24:00.860
这个细节

24:00.860 --> 24:01.860
Expire

24:01.860 --> 24:04.860
这个是1.0版本的一个协议

24:04.860 --> 24:05.860
就是

24:05.860 --> 24:07.860
以前的不是通过Mac 7

24:07.860 --> 24:09.860
来指定缓存的时间的

24:09.860 --> 24:10.860
是通过这个Expire

24:10.860 --> 24:12.860
Expire它指定一个日期

24:12.860 --> 24:14.860
就在这个日期之前

24:14.860 --> 24:15.860
没有过期

24:15.860 --> 24:16.860
指的是这么一个意思

24:16.860 --> 24:17.860
你缓存吧

24:17.860 --> 24:18.860
你缓存在这个日期之后就过期了

24:18.860 --> 24:19.860
就这么个意思

24:20.860 --> 24:21.860
现在都是通过Mac 7

24:21.860 --> 24:22.860
来记录了

24:22.860 --> 24:23.860
这是比较早的版本了

24:23.860 --> 24:24.860
好 下一个

24:24.860 --> 24:26.860
记录缓存时的有效期

24:27.860 --> 24:28.860
因为浏览期

24:28.860 --> 24:30.860
它会按照福气的响应头的要求

24:30.860 --> 24:32.860
自动的把缓存记录到本地文件

24:32.860 --> 24:33.860
然后呢

24:33.860 --> 24:34.860
设置相关的信息

24:34.860 --> 24:37.860
那么这个缓存的有效期呢

24:37.860 --> 24:38.860
就非常关键

24:38.860 --> 24:39.860
因为这个有效期就决定了

24:39.860 --> 24:40.860
这个缓存还是不是有效的

24:40.860 --> 24:42.860
我要不要重新发送一个确诊请求

24:42.860 --> 24:43.860
确诊缓存的请求

24:44.860 --> 24:46.860
那么这个有效期怎么来确定呢

24:46.860 --> 24:48.860
当收到福气一个缓存指令

24:48.860 --> 24:49.860
那我要把它处下来了

24:49.860 --> 24:50.860
对吧

24:50.860 --> 24:51.860
那么我怎么来去确定这个有效期呢

24:51.860 --> 24:52.860
它是这样子

24:52.860 --> 24:54.860
收到了福气的响应过后

24:54.860 --> 24:55.860
先判断有没有Mac 7

24:55.860 --> 24:56.860
Mac 7

24:56.860 --> 24:57.860
有没有

24:57.860 --> 24:58.860
如果说有的话

24:58.860 --> 24:59.860
那我就读这个电池之段

24:59.860 --> 25:01.860
如果说电池之段也有

25:01.860 --> 25:03.860
那么过期时间就很容易确定了

25:03.860 --> 25:05.860
就是日期加上这个Mac 7

25:05.860 --> 25:06.860
对吧

25:06.860 --> 25:07.860
如果电池之段没有的话

25:07.860 --> 25:08.860
那么就是浏览期的当前时间

25:08.860 --> 25:10.860
而且不是福气的当前时间

25:10.860 --> 25:11.860
这个东西是福气给你的

25:11.860 --> 25:13.860
那么就用浏览期的当前时间

25:13.860 --> 25:14.860
加上Mac 7

25:14.860 --> 25:16.860
来作为过期时间

25:16.860 --> 25:18.860
如果说你Mac 7都没有给我的话

25:18.860 --> 25:19.860
那么我就看一下

25:19.860 --> 25:21.860
有没有NAS Modified之段

25:21.860 --> 25:23.860
有没有这个东西

25:23.860 --> 25:24.860
如果说这个东西也没有的话

25:24.860 --> 25:25.860
那么就不缓存了

25:25.860 --> 25:27.860
当然这个其实还有个细节

25:27.860 --> 25:29.860
就是判断有没有Xperia

25:29.860 --> 25:31.860
这是一个比较早期的协议

25:31.860 --> 25:32.860
就不说了

25:32.860 --> 25:34.860
那如果说这两个东西都没有

25:34.860 --> 25:36.860
那它怎么来确定

25:36.860 --> 25:37.860
就这个有

25:37.860 --> 25:38.860
这个没有

25:38.860 --> 25:39.860
这个东西有

25:39.860 --> 25:40.860
那它怎么来确定缓存时间呢

25:40.860 --> 25:42.860
它这样子确定的

25:42.860 --> 25:43.860
这个比较怪

25:43.860 --> 25:45.860
总之它就用这种方式来确定的

25:45.860 --> 25:46.860
它是把当前时间

25:46.860 --> 25:48.860
减去NAS Modified

25:48.860 --> 25:50.860
得到一个秒数

25:50.860 --> 25:52.860
把这个秒数处于10

25:52.860 --> 25:53.860
作为Mac 7

25:53.860 --> 25:55.860
了解一下就行了

25:55.860 --> 25:57.860
那么

25:57.860 --> 25:58.860
比方说

25:58.860 --> 25:59.860
如果说你Mac 7呢

25:59.860 --> 26:00.860
设置的是0

26:00.860 --> 26:01.860
那么表示这个缓存了吗

26:01.860 --> 26:02.860
我存下来了

26:02.860 --> 26:03.860
存是存下来了

26:03.860 --> 26:05.860
但是缓存立即过期了

26:05.860 --> 26:06.860
那立即过期过后

26:06.860 --> 26:08.860
你看后续

26:08.860 --> 26:09.860
再用这个缓存的时候

26:09.860 --> 26:10.860
能不能用

26:10.860 --> 26:11.860
它不能用了

26:11.860 --> 26:12.860
已经过期了

26:12.860 --> 26:13.860
所以说是不是要发送

26:13.860 --> 26:14.860
请求到服务器

26:14.860 --> 26:15.860
确认这个缓存有没有过期

26:15.860 --> 26:16.860
对吧

26:16.860 --> 26:17.860
因此

26:17.860 --> 26:18.860
下面这两种协议

26:18.860 --> 26:19.860
效果是一样的

26:19.860 --> 26:20.860
就是Mac 7等于0

26:20.860 --> 26:22.860
和Locatch

26:22.860 --> 26:23.860
是一样的

26:23.860 --> 26:24.860
Locatch也是

26:24.860 --> 26:25.860
我缓存了

26:25.860 --> 26:26.860
但是我不用它

26:26.860 --> 26:27.860
是不是一样的

26:27.860 --> 26:28.860
下一个

26:28.860 --> 26:30.860
Programma

26:30.860 --> 26:31.860
这个是什么东西

26:31.860 --> 26:33.860
它是1.0的消息头

26:33.860 --> 26:34.860
这个消息头

26:34.860 --> 26:35.860
一般出现在请求里面

26:35.860 --> 26:36.860
是向服务器表达

26:36.860 --> 26:38.860
不要考虑任何缓存

26:38.860 --> 26:40.860
给我一个正常结果

26:40.860 --> 26:41.860
在1.0

26:41.860 --> 26:42.860
1.1的版本中

26:42.860 --> 26:43.860
如果说

26:43.860 --> 26:44.860
你要实现这样的效果

26:44.860 --> 26:45.860
你可以在请求中

26:45.860 --> 26:46.860
加入Catch Control

26:46.860 --> 26:47.860
Locatch

26:47.860 --> 26:48.860
来实现同样的效果

26:48.860 --> 26:49.860
但是以前的版本

26:49.860 --> 26:51.860
是用Programma

26:51.860 --> 26:52.860
你看一下

26:52.860 --> 26:54.860
如果说你在访问网站的时候

26:54.860 --> 26:55.860
访问网站的时候

26:55.860 --> 26:56.860
你勾选了这个

26:56.860 --> 26:58.860
就是Disabled Catch

26:58.860 --> 27:00.860
就勾选了浏览器的这个东西

27:00.860 --> 27:02.860
那么它后续浏览器发送的请求

27:02.860 --> 27:04.860
就一般用于调试

27:04.860 --> 27:05.860
就不希望看到缓存

27:05.860 --> 27:08.860
那么在浏览器的请求的时候

27:08.860 --> 27:09.860
它请求里边

27:09.860 --> 27:10.860
它就会加上这个

27:10.860 --> 27:11.860
Catch Control

27:11.860 --> 27:12.860
Locatch

27:12.860 --> 27:13.860
Catch Control

27:13.860 --> 27:14.860
Locatch

27:14.860 --> 27:15.860
以及Programma

27:15.860 --> 27:16.860
Locatch

27:16.860 --> 27:17.860
对吧

27:17.860 --> 27:18.860
因为我也不知道服务器

27:18.860 --> 27:19.860
到底支持什么样的协议

27:19.860 --> 27:20.860
所以我把两个字

27:20.860 --> 27:21.860
那么服务器一看

27:21.860 --> 27:22.860
你不想

27:22.860 --> 27:24.860
不想要服务器使用那个缓存

27:24.860 --> 27:25.860
那么

27:25.860 --> 27:26.860
注意啊

27:26.860 --> 27:27.860
这个地方不是

27:27.860 --> 27:28.860
刚才我们讲的Locatch

27:28.860 --> 27:30.860
是服务器想一个客户端的

27:30.860 --> 27:31.860
这是客户端发送给服务器的

27:31.860 --> 27:32.860
表示告诉服务器

27:32.860 --> 27:34.860
我不要给我任何缓存确认

27:34.860 --> 27:36.860
你直接给我一个正常的结果

27:36.860 --> 27:38.860
给我带消息体200ok就行了

27:38.860 --> 27:40.860
以后我们再演示

27:41.860 --> 27:42.860
最后一个说一下

27:42.860 --> 27:44.860
就是我们平时

27:44.860 --> 27:46.860
对于缓存的一些

27:46.860 --> 27:47.860
处理

27:47.860 --> 27:50.860
主要是跟之前的wepack来联系一下

27:50.860 --> 27:52.860
因为我们是这样子

27:52.860 --> 27:55.860
就是我们比方说有一个页面

27:55.860 --> 27:57.860
我们开发单页应用程序

27:57.860 --> 27:58.860
开发单页应用程序的时候

27:58.860 --> 28:01.860
有页面一般就只有一个

28:01.860 --> 28:02.860
对吧

28:02.860 --> 28:03.860
一边只有一个

28:03.860 --> 28:05.860
就我们有一个页面

28:05.860 --> 28:06.860
一边有很多的GS

28:06.860 --> 28:08.860
1.GS

28:08.860 --> 28:10.860
2.GS

28:10.860 --> 28:12.860
然后3.GS

28:12.860 --> 28:13.860
还有CSS

28:13.860 --> 28:14.860
1.CSS

28:14.860 --> 28:16.860
2.CSS

28:16.860 --> 28:17.860
3.CSS

28:17.860 --> 28:18.860
这东西要不要缓存

28:18.860 --> 28:19.860
这东西最好缓存

28:19.860 --> 28:20.860
最好缓存

28:20.860 --> 28:22.860
因为基本上比较稳固的

28:22.860 --> 28:23.860
比较稳定的

28:23.860 --> 28:24.860
就把它缓存下来

28:24.860 --> 28:25.860
但是那就会遇到一个问题

28:25.860 --> 28:27.860
它如果说更新了怎么办

28:27.860 --> 28:28.860
比方说我服务器

28:28.860 --> 28:29.860
把1.GS更新了

28:29.860 --> 28:30.860
但是李克文还是用了

28:30.860 --> 28:31.860
这个原来的缓存

28:31.860 --> 28:32.860
对吧

28:32.860 --> 28:33.860
他看不到更新的结果

28:33.860 --> 28:34.860
那么这个东西怎么办

28:34.860 --> 28:35.860
这个东西是不是

28:35.860 --> 28:36.860
就遇到一些问题

28:36.860 --> 28:37.860
那么这个时候

28:37.860 --> 28:38.860
我们就可以用

28:38.860 --> 28:40.860
传统的方式怎么做的呢

28:40.860 --> 28:41.860
传统的方式是

28:41.860 --> 28:42.860
我们页面去引用

28:42.860 --> 28:43.860
这些GS的时候

28:43.860 --> 28:44.860
给他一个

28:44.860 --> 28:45.860
给他一个就是参

28:45.860 --> 28:46.860
数

28:46.860 --> 28:47.860
比方说V

28:47.860 --> 28:48.860
1.0

28:48.860 --> 28:49.860
1.0

28:49.860 --> 28:50.860
这样的版本

28:50.860 --> 28:51.860
一个版本号

28:51.860 --> 28:52.860
给他个版本号

28:52.860 --> 28:53.860
如果说

28:53.860 --> 28:55.860
就是我们页面不要缓存

28:55.860 --> 28:56.860
或者说

28:56.860 --> 28:57.860
页面不要去长期缓存

28:57.860 --> 28:58.860
就是

28:58.860 --> 28:59.860
可以用都开启的那种方式

28:59.860 --> 29:01.860
就是每一次请求服务器

29:01.860 --> 29:02.860
都去用一个确认

29:02.860 --> 29:04.860
确认到底缓存有没有过期

29:04.860 --> 29:06.860
就是页面一定要保持实实性

29:06.860 --> 29:07.860
就服务器那边更新了

29:07.860 --> 29:08.860
你这边也要更新

29:08.860 --> 29:09.860
页面我们一般不缓存

29:09.860 --> 29:12.860
不用那种就是长期的缓存

29:12.860 --> 29:14.860
然后这些文件可以长期缓存

29:14.860 --> 29:16.860
可以不要缓存2天

29:16.860 --> 29:17.860
缓存3天

29:17.860 --> 29:18.860
缓存4天

29:18.860 --> 29:19.860
缓存1周都可以

29:19.860 --> 29:21.860
让他尽量使用本地的消息

29:21.860 --> 29:22.860
不要去请求服务器了

29:22.860 --> 29:23.860
因为我们知道

29:23.860 --> 29:24.860
单页应用程序

29:24.860 --> 29:25.860
打包出来的GS

29:25.860 --> 29:26.860
CS还是比较大的

29:26.860 --> 29:27.860
对不对

29:27.860 --> 29:28.860
比如叫View

29:28.860 --> 29:29.860
React

29:29.860 --> 29:30.860
或者是你使用那些

29:30.860 --> 29:32.860
Element UI的这种框架

29:32.860 --> 29:34.860
那么你缓存的GS

29:34.860 --> 29:35.860
还是比较大的

29:35.860 --> 29:38.860
可能有一两百KB

29:38.860 --> 29:39.860
因此你把它缓存到

29:39.860 --> 29:40.860
科普端是最好的

29:40.860 --> 29:41.860
不要去请求服务器了

29:41.860 --> 29:42.860
不要传输了

29:42.860 --> 29:44.860
但是我如果说服务器更新了

29:44.860 --> 29:45.860
更新了怎么办

29:45.860 --> 29:47.860
服务器就更新页面上的引用

29:47.860 --> 29:50.860
比方说这个东西更新成这个

29:50.860 --> 29:51.860
更新了引用过后

29:51.860 --> 29:52.860
由于页面没有缓存

29:52.860 --> 29:53.860
那么于是

29:53.860 --> 29:54.860
请求的路性是不是变了

29:54.860 --> 29:56.860
它无法命中缓存

29:56.860 --> 29:58.860
因此会重新去请求服务器

29:58.860 --> 29:59.860
重新缓存

29:59.860 --> 30:00.860
就这么个意思

30:00.860 --> 30:01.860
但是这是过去的做法

30:01.860 --> 30:03.860
那么现在的最好的

30:03.860 --> 30:04.860
比较好的方案

30:04.860 --> 30:05.860
是使用这个

30:07.860 --> 30:08.860
现在比较好的方案

30:08.860 --> 30:09.860
是使用哈希

30:09.860 --> 30:10.860
你看我们的WePack里边

30:10.860 --> 30:11.860
是不是

30:11.860 --> 30:13.860
通常用哈希的方式来定义介绍

30:13.860 --> 30:15.860
像那个ViewRx

30:15.860 --> 30:16.860
都是用这种方式对不对

30:16.860 --> 30:18.860
要文件变了过后

30:18.860 --> 30:19.860
我就用哈希值也变化

30:19.860 --> 30:21.860
哈希值也变化

30:21.860 --> 30:23.860
这是过去的方式

30:23.860 --> 30:24.860
这过去的方式

30:24.860 --> 30:25.860
然后现在的方式

30:25.860 --> 30:26.860
就是把它使用个哈希值

30:26.860 --> 30:28.860
就不用加这个东西了

30:28.860 --> 30:30.860
这是关于这个

30:30.860 --> 30:32.860
如何来就是使用版本号

30:32.860 --> 30:34.860
或者是哈希来解决缓存

30:34.860 --> 30:37.860
就是没有更新的问题

30:37.860 --> 30:38.860
好 最后呢

30:38.860 --> 30:40.860
我们在总结之前

30:40.860 --> 30:42.860
我们来演示一下效果

30:42.860 --> 30:44.860
实际上咱们的Express

30:44.860 --> 30:46.860
它已经帮你搞定了

30:46.860 --> 30:47.860
就是你什么大码都不用写

30:47.860 --> 30:48.860
已经帮你搞定了

30:48.860 --> 30:49.860
咱们来看一下了

30:49.860 --> 30:51.860
我们把运行出来

30:51.860 --> 30:52.860
NPM Start

30:52.860 --> 30:56.620
好 运行出来了

30:56.620 --> 30:57.620
然后我们到浏览器里边

30:57.620 --> 30:58.620
去请求一下我们的页面

30:58.620 --> 31:00.620
我们刚才把页面控制一下吧

31:00.620 --> 31:02.620
我们的页面是啥样子

31:02.620 --> 31:04.620
页面就是啥样子

31:04.620 --> 31:06.620
换一个吧

31:06.620 --> 31:08.620
把这个玩的玩器把它玩一下

31:09.620 --> 31:11.620
这个E

31:11.620 --> 31:13.620
这是

31:13.620 --> 31:14.620
Hello

31:14.620 --> 31:15.620
我们随便写一个吧

31:15.620 --> 31:17.620
然后呢 引用一个GS

31:17.620 --> 31:19.620
1.GSS

31:19.620 --> 31:21.620
再引用一个CSS

31:21.620 --> 31:23.620
1.CSS

31:23.620 --> 31:24.620
那行了

31:24.620 --> 31:26.620
那咱们这里来用一个另一个

31:26.620 --> 31:28.620
去引用这个1.CSS

31:28.620 --> 31:30.620
这边呢 去引用这个

31:31.620 --> 31:33.620
去引用这个script

31:34.620 --> 31:35.620
src

31:35.620 --> 31:36.620
1.CSS

31:37.620 --> 31:39.620
咱们静态页面就这么几个

31:39.620 --> 31:41.620
好 接下来我们来看一下浮器

31:41.620 --> 31:43.620
右键检查

31:43.620 --> 31:45.620
这里看一下网络通信

31:45.620 --> 31:47.620
接下来我们刷新

31:51.620 --> 31:53.620
这个东西这也请求失败

31:53.620 --> 31:54.620
不然了

31:54.620 --> 31:55.620
我们来看一下这三个东西

31:55.620 --> 31:56.620
是不是得到的结果了

31:56.620 --> 31:57.620
对不对

31:57.620 --> 31:59.620
好 咱们来看一下Local Host

31:59.620 --> 32:01.620
Local Host看浮器给我们的响应结果

32:01.620 --> 32:02.620
你看

32:02.620 --> 32:04.620
是不是自动给你加上一个Cache Control

32:05.620 --> 32:06.620
对不对

32:06.620 --> 32:08.620
是不是加了这个东西

32:08.620 --> 32:09.620
没问题吧

32:09.620 --> 32:10.620
然后呢

32:10.620 --> 32:11.620
那么这样子呢

32:11.620 --> 32:12.620
是不是客户端那边

32:12.620 --> 32:14.620
他有没有缓存有缓存

32:14.620 --> 32:16.620
那是缓存立即过期了

32:16.620 --> 32:17.620
是不是立即过期了

32:17.620 --> 32:18.620
对不对

32:18.620 --> 32:19.620
好 然后呢

32:19.620 --> 32:20.620
我们看一下1.CSS

32:20.620 --> 32:21.620
也是一样浮器给我了一个

32:21.620 --> 32:22.620
mxc-a-g0

32:22.620 --> 32:23.620
就是浮器的默认方式

32:23.620 --> 32:24.620
mxc-a-g0

32:24.620 --> 32:25.620
而且复杂了e-tag

32:25.620 --> 32:26.620
这些那是modified

32:26.620 --> 32:27.620
对吧

32:27.620 --> 32:29.620
那些modified都给你复杂过来了

32:29.620 --> 32:30.620
那么这里的吗

32:30.620 --> 32:31.620
那是modified呢

32:31.620 --> 32:32.620
它就是咱们文件

32:32.620 --> 32:33.620
因为我们这里

32:34.620 --> 32:35.620
那么文件的

32:36.620 --> 32:37.620
上映词修改日期

32:38.620 --> 32:39.620
就这么个意思

32:39.620 --> 32:40.620
好

32:40.620 --> 32:41.620
然后呢

32:41.620 --> 32:42.620
我们这里写好了过后

32:42.620 --> 32:43.620
接下来我们再来请求

32:43.620 --> 32:44.620
注意看

32:44.620 --> 32:45.620
现在都是200对不对

32:45.620 --> 32:46.620
因为第一次请求

32:46.620 --> 32:47.620
没有缓存

32:47.620 --> 32:48.620
好 接下来我们这里

32:50.620 --> 32:51.620
你看一下

32:52.620 --> 32:54.620
我的央视怎么回的

32:54.620 --> 32:55.620
央视

32:56.620 --> 32:58.620
1711

32:58.620 --> 32:59.620
再来一次

32:59.620 --> 33:03.250
1711

33:03.250 --> 33:05.630
我们先看这个吧

33:05.630 --> 33:06.630
先看这个

33:06.630 --> 33:07.630
localhost

33:07.630 --> 33:08.630
localhost你看复杂的响应结果

33:08.630 --> 33:10.630
是不是304modified

33:10.630 --> 33:12.630
实际上这一次发送响应

33:12.630 --> 33:14.630
它是没有给力消息体的

33:14.630 --> 33:15.630
也就是说

33:15.630 --> 33:16.630
这里可以看到消息体

33:16.630 --> 33:17.630
这里看到的消息体

33:17.630 --> 33:19.630
实际上是本地的缓存的

33:19.630 --> 33:20.630
它没有给力消息体

33:20.630 --> 33:22.630
304是不给力消息体的

33:22.630 --> 33:23.630
没了意思吧

33:23.630 --> 33:24.630
那么这里呢

33:24.630 --> 33:25.630
它就是给力的

33:25.630 --> 33:26.630
就是304

33:26.630 --> 33:27.630
不要复杂说

33:27.630 --> 33:28.630
因为这一次请求你看

33:28.630 --> 33:29.630
是不是

33:29.630 --> 33:30.630
因为我本地有缓存

33:30.630 --> 33:31.630
只剩立即过期了

33:31.630 --> 33:32.630
立即过期怎么办

33:32.630 --> 33:33.630
是不是要发生一个

33:33.630 --> 33:35.630
缓存确认请求

33:35.630 --> 33:36.630
给它带上一个什么

33:36.630 --> 33:37.630
ifmodifiedsins

33:37.630 --> 33:39.630
带上一个ifnonmarch

33:39.630 --> 33:40.630
把这个id

33:40.630 --> 33:42.630
就是编号带过去

33:42.630 --> 33:43.630
复杂看这个编号

33:43.630 --> 33:44.630
这个编号一般是

33:44.630 --> 33:45.630
根据内容来定的

33:45.630 --> 33:46.630
内容一变

33:46.630 --> 33:47.630
这个编号就会变

33:47.630 --> 33:48.630
那么变

33:48.630 --> 33:49.630
复杂发现

33:49.630 --> 33:50.630
这个编号没变

33:50.630 --> 33:51.630
复杂怎么发现的

33:51.630 --> 33:52.630
它是这样子

33:52.630 --> 33:53.630
它还是会正常的

33:53.630 --> 33:54.630
经过复杂的处理

33:54.630 --> 33:55.630
就这些东西还是会处理

33:55.630 --> 33:57.630
它是不是把文件读出来

33:57.630 --> 33:58.630
作为消息体

33:58.630 --> 33:59.630
把文件的内容读出来

33:59.630 --> 34:00.630
作为消息体

34:00.630 --> 34:01.630
那么它这个东西

34:01.630 --> 34:02.630
会自动判断

34:02.630 --> 34:03.630
如果说这个内容

34:03.630 --> 34:05.630
消息体里边的内容

34:05.630 --> 34:07.630
那么把它进行编码

34:07.630 --> 34:08.630
编码过后

34:08.630 --> 34:09.630
跟这个就是

34:09.630 --> 34:11.630
请求里边的这个编码

34:11.630 --> 34:12.630
是一致的

34:12.630 --> 34:13.630
说明说

34:13.630 --> 34:14.630
这个缓存确没有变

34:14.630 --> 34:15.630
就没有变

34:15.630 --> 34:16.630
Express会自动处理

34:16.630 --> 34:17.630
Express它怎么处理的

34:17.630 --> 34:20.630
就是给你自己写了个中间件

34:20.630 --> 34:23.630
每一次快要响应的时候

34:23.630 --> 34:25.630
它把你的消息体读出来

34:25.630 --> 34:27.630
把这个消息体进行编码

34:27.630 --> 34:28.630
变成这个样子

34:28.630 --> 34:29.630
然后去对比你的

34:29.630 --> 34:31.630
请求里边的这个东西

34:31.630 --> 34:32.630
如果说对比上了

34:32.630 --> 34:34.630
那就是三零四

34:34.630 --> 34:35.630
符句是这样子操作的

34:35.630 --> 34:36.630
没了意思吧

34:36.630 --> 34:38.630
你看GS是不是也是一样

34:38.630 --> 34:39.630
对吧

34:39.630 --> 34:41.630
SGS上为什么不行了

34:41.630 --> 34:42.630
SSS

34:44.630 --> 34:45.630
E-Tag

34:45.630 --> 34:47.630
我们看一下E-Tag

34:47.630 --> 34:51.630
E-Tag是没问题的

34:51.630 --> 34:55.630
E-Tag是没问题的

34:55.630 --> 34:56.630
这个什么

34:56.630 --> 34:58.630
E-Fmd-5sense

34:58.630 --> 35:00.630
这个也是没问题的

35:01.630 --> 35:04.630
这个SSS上为什么不可以搞定

35:04.630 --> 35:06.630
我也不知道这是什么逻辑

35:06.630 --> 35:08.630
没事一会我们可以手动处理的

35:08.630 --> 35:09.630
可以干预的

35:09.630 --> 35:10.630
干预它的过程

35:10.630 --> 35:11.630
这是这种情况

35:11.630 --> 35:12.630
那我们这种情况

35:12.630 --> 35:14.630
显然可能不是很满足我们的要求

35:14.630 --> 35:15.630
因为我们觉得

35:15.630 --> 35:18.630
这个SSS这个GS

35:18.630 --> 35:20.630
你不要这样子搞

35:20.630 --> 35:21.630
你直接让它缓存

35:21.630 --> 35:22.630
科普专业选择

35:22.630 --> 35:24.630
不要给我麦斯A级等于0

35:24.630 --> 35:26.630
你不要给我这个东西

35:26.630 --> 35:28.630
为什么不出现

35:29.630 --> 35:33.320
你不要给我麦斯A级等于0

35:33.320 --> 35:34.320
你给我缓存两天

35:34.320 --> 35:35.320
两天三天都行

35:35.320 --> 35:37.320
或者缓存一个小时都行

35:37.320 --> 35:39.320
那么这个东西怎么办呢

35:39.320 --> 35:41.320
我们就可以自己干预它的过程

35:41.320 --> 35:43.320
比方说对于静态资源

35:43.320 --> 35:44.320
对于静态资源的话

35:44.320 --> 35:45.320
我们怎么干预的

35:45.320 --> 35:46.320
我看一下

35:46.320 --> 35:48.320
来查一下Express的

35:48.320 --> 35:53.040
找到这个就是

35:53.040 --> 35:55.040
我们其实又是干预静态资源的缓存

35:55.040 --> 35:56.040
因为我们特别是

35:56.040 --> 35:58.040
对于单业应用程序

35:58.040 --> 35:59.040
打包是不是打包到这

35:59.040 --> 36:00.040
对不对

36:00.040 --> 36:01.040
GS特别大

36:01.040 --> 36:02.040
特别大

36:02.040 --> 36:04.040
我们就可以把它缓存下来

36:04.040 --> 36:07.040
找到这个APS手册

36:09.040 --> 36:10.040
Expression

36:10.040 --> 36:11.040
Static

36:11.040 --> 36:12.040
它这里肯定有说

36:12.040 --> 36:13.040
你看这E-Type

36:13.040 --> 36:16.040
E-Type怎么来处理

36:16.040 --> 36:19.040
要不要开启E-Type

36:19.040 --> 36:21.040
这什么

36:21.040 --> 36:23.040
就是要不要开启E-Type

36:23.040 --> 36:24.040
就这么个意思

36:24.040 --> 36:25.040
这里看麦克斯A级

36:25.040 --> 36:27.040
是不是可以配置这个东西

36:27.040 --> 36:29.040
那咱们来配置一下吧

36:30.040 --> 36:33.800
配置一下这个麦克斯A级

36:33.800 --> 36:35.800
Static在这边

36:35.800 --> 36:37.800
我们可以传第二参数

36:37.800 --> 36:39.800
第二参数是Option

36:39.800 --> 36:42.440
配置

36:42.440 --> 36:43.440
我们配置一下什么

36:43.440 --> 36:45.440
配置一下麦克斯A级

36:45.440 --> 36:47.440
那么这里呢

36:47.440 --> 36:49.440
它让你配置的是毫秒

36:49.440 --> 36:50.440
Mini-Second是毫秒

36:50.440 --> 36:51.440
但是那实际上

36:51.440 --> 36:52.440
它是有效的是秒

36:52.440 --> 36:53.440
对不对

36:53.440 --> 36:54.440
那么没关系

36:54.440 --> 36:55.440
它说配置毫秒就配置毫秒

36:55.440 --> 36:56.440
它会给你自动转换成秒

36:56.440 --> 36:58.440
那么毫秒一个小时

36:58.440 --> 36:59.440
3600秒一个小时

36:59.440 --> 37:01.440
乘以1000

37:01.440 --> 37:03.440
不就是毫秒数吗

37:03.440 --> 37:04.440
保存

37:04.440 --> 37:05.440
咱们来看一下

37:05.440 --> 37:07.440
现在我们刷新

37:09.440 --> 37:10.440
我们看一下这边

37:10.440 --> 37:11.440
麦克斯A级3600了

37:11.440 --> 37:13.440
然后CSS3600了

37:13.440 --> 37:14.440
1.json3600了

37:14.440 --> 37:16.440
那么现在是不是本地有缓存了

37:16.440 --> 37:17.440
对不对

37:17.440 --> 37:19.440
接下来我们再来看

37:19.440 --> 37:21.440
点击右键

37:21.440 --> 37:22.440
点查

37:23.440 --> 37:25.440
现在我们去访问这个地址

37:25.440 --> 37:27.440
你看一下这里边

37:27.440 --> 37:28.440
后边有没有请求发生

37:28.440 --> 37:30.440
没有请求发生

37:31.440 --> 37:32.440
不对啊

37:32.440 --> 37:33.440
这不200吗

37:33.440 --> 37:34.440
应该是有请求发生

37:34.440 --> 37:35.440
对不对

37:35.440 --> 37:36.440
为什么说没有请求发生

37:36.440 --> 37:37.440
你看这里

37:37.440 --> 37:38.440
它一个什么

37:38.440 --> 37:39.440
DiskTag

37:39.440 --> 37:43.440
就是使用的是磁盘上的缓存资源

37:43.440 --> 37:45.440
使用的是磁盘的缓存资源

37:45.440 --> 37:46.440
这个时候服务器有没有收到请求

37:46.440 --> 37:48.440
根本就没有收到请求

37:48.440 --> 37:50.440
我怎么来验证这一点呢

37:50.440 --> 37:51.440
你这么凭什么说

37:51.440 --> 37:52.440
服务器没有收到请求了

37:52.440 --> 37:53.440
那么我们看

37:53.440 --> 37:54.440
最早的中间键在哪

37:54.440 --> 37:56.440
最早的中间键是不是在

37:56.440 --> 37:58.440
ImageProtect

37:58.440 --> 37:59.440
对不对

37:59.440 --> 38:00.440
好

38:00.440 --> 38:01.440
我们在这里

38:01.440 --> 38:03.440
我看一下在哪

38:03.440 --> 38:05.440
Roads

38:05.440 --> 38:06.440
Image

38:06.440 --> 38:08.440
我们之前做过那个

38:08.440 --> 38:09.440
就这个东西

38:09.440 --> 38:10.440
打个断点

38:10.440 --> 38:11.440
然后我们运行起来

38:11.440 --> 38:13.440
看一下有没有运行到断点

38:13.440 --> 38:14.440
好

38:14.440 --> 38:15.440
接下来

38:17.440 --> 38:18.440
放心

38:18.440 --> 38:19.440
这里是运行的

38:19.440 --> 38:20.440
因为我这里就不能用这种方式

38:20.440 --> 38:21.440
因为

38:21.440 --> 38:22.440
这里是怎么回事

38:22.440 --> 38:23.440
因为浏览器它有这么一个处理

38:23.440 --> 38:24.440
就针对页面来说

38:24.440 --> 38:26.440
如果说你在浏览器地址里边

38:26.440 --> 38:27.440
一回车

38:27.440 --> 38:28.440
那么表示刷新

38:28.440 --> 38:29.440
表示刷新

38:29.440 --> 38:30.440
就请求同一个页面的话

38:30.440 --> 38:31.440
就是刷新

38:31.440 --> 38:32.440
刷新的话

38:32.440 --> 38:33.440
它会

38:33.440 --> 38:34.440
不使用缓存

38:34.440 --> 38:37.440
而带一个缓存确诊请求过去

38:37.440 --> 38:38.440
好

38:38.440 --> 38:39.440
那么其实你可以看到

38:39.440 --> 38:40.440
就算运行的话

38:40.440 --> 38:41.440
它是不是只运行了一次

38:41.440 --> 38:42.440
只有这个请求

38:42.440 --> 38:43.440
会发生到服务器

38:43.440 --> 38:44.440
对吧

38:44.440 --> 38:45.440
运行了一次

38:45.440 --> 38:46.440
服务器给了304

38:46.440 --> 38:47.440
但是这两个请求

38:47.440 --> 38:48.440
有没有发生到服务器

38:48.440 --> 38:49.440
没有对吧

38:49.440 --> 38:50.440
这两个也是请求

38:50.440 --> 38:51.440
但也没有到服务器

38:51.440 --> 38:52.440
我们用这种方式好

38:52.440 --> 38:53.440
好一点

38:53.440 --> 38:54.440
看得更加清楚一点

38:54.440 --> 38:55.440
右键检查

38:56.440 --> 38:59.440
这样子新开一个

38:59.440 --> 39:00.440
你看服务器是不是

39:00.440 --> 39:01.440
没有受到请求

39:01.440 --> 39:02.440
对吧

39:02.440 --> 39:03.440
完全没有受到请求

39:03.440 --> 39:04.440
所以说这样子

39:04.440 --> 39:05.440
服务器的压力会变得很少

39:05.440 --> 39:06.440
那么这样子

39:06.440 --> 39:07.440
一个小时过后

39:07.440 --> 39:09.440
才会真正的去请求服务器

39:09.440 --> 39:11.440
去确认一下缓存有没有过去

39:11.440 --> 39:13.440
但是这种做法

39:13.440 --> 39:14.440
有一个不好的地方

39:14.440 --> 39:15.440
就是它把页面

39:15.440 --> 39:16.440
它也是

39:16.440 --> 39:18.440
给你用这种方式来缓存下来

39:18.440 --> 39:19.440
这样子不好的

39:19.440 --> 39:21.440
因为我们知道页面的最好

39:21.440 --> 39:22.440
我们刚才说了

39:22.440 --> 39:23.440
页面的最好的做法

39:23.440 --> 39:26.440
就是不要缓存

39:26.440 --> 39:27.440
或者就是用个

39:27.440 --> 39:29.440
low catch的这种缓存方式

39:29.440 --> 39:31.440
而不要使用就是长期缓存

39:31.440 --> 39:33.440
而这些CSS GS的资源

39:33.440 --> 39:34.440
可以使用

39:34.440 --> 39:35.440
因为为什么呢

39:35.440 --> 39:36.440
因为页面中

39:36.440 --> 39:37.440
去引用了这些东西

39:37.440 --> 39:38.440
好来吧

39:38.440 --> 39:39.440
那我们这里

39:39.440 --> 39:40.440
稍微处理一下

39:40.440 --> 39:41.440
怎么处理呢

39:41.440 --> 39:42.440
这里我们刚刚看一下

39:42.440 --> 39:43.440
这个文档

39:43.440 --> 39:44.440
这个文档

39:44.440 --> 39:45.440
它就没有针对

39:45.440 --> 39:46.440
这种情况进行处理了

39:46.440 --> 39:47.440
它就没有

39:47.440 --> 39:48.440
这种情况进行处理了

39:48.440 --> 39:49.440
因此呢

39:49.440 --> 39:52.880
我看一下

39:53.880 --> 39:57.700
我看一下

39:59.700 --> 40:00.700
我们这样子

40:00.700 --> 40:01.700
去搜索这种东西

40:01.700 --> 40:02.700
set headers

40:02.700 --> 40:04.700
因为我们知道缓存指令了

40:04.700 --> 40:05.700
它无非就是一个

40:05.700 --> 40:06.700
消息头嘛

40:06.700 --> 40:07.700
对不对

40:07.700 --> 40:08.700
所以说我们这里

40:08.700 --> 40:09.700
去配置一个消息头

40:09.700 --> 40:10.700
set headers

40:10.700 --> 40:11.700
它是个函数

40:11.700 --> 40:12.700
你看一下

40:12.700 --> 40:13.700
它告诉你

40:13.700 --> 40:14.700
set headers

40:14.700 --> 40:15.700
它实际上是个函数

40:15.700 --> 40:16.700
第一个参数

40:16.700 --> 40:17.700
是响应对象

40:17.700 --> 40:18.700
express的响应对象

40:18.700 --> 40:19.700
第一个参数

40:19.700 --> 40:20.700
你请

40:20.700 --> 40:21.700
就是我们的资源路径

40:21.700 --> 40:22.700
第三个参数

40:22.700 --> 40:24.700
在静态文件的状态

40:24.700 --> 40:25.700
你根据这三个东西

40:25.700 --> 40:26.700
去控制消息头

40:26.700 --> 40:27.700
那么我们这里

40:27.700 --> 40:28.700
来控制一下

40:28.700 --> 40:29.700
比方说我们这里

40:29.700 --> 40:30.700
就可以用这种方式

40:32.700 --> 40:33.700
在这边

40:33.700 --> 40:35.700
我们就不去设置

40:35.700 --> 40:36.700
这个max age

40:36.700 --> 40:37.700
就不去设置它了

40:37.700 --> 40:38.700
我们在这里

40:38.700 --> 40:40.700
去设置这个set headers

40:40.700 --> 40:43.330
去设置它

40:43.330 --> 40:44.330
然后三个参数

40:44.330 --> 40:45.330
对吧

40:45.330 --> 40:46.330
pass

40:46.330 --> 40:47.330
然后什么呢

40:47.330 --> 40:48.330
set

40:48.330 --> 40:49.330
set horses

40:49.330 --> 40:52.090
可以不要了

40:52.090 --> 40:53.090
好了

40:53.090 --> 40:54.090
就这样子设置

40:54.090 --> 40:55.090
这样设置过后

40:55.090 --> 40:56.090
我们只需要看一下

40:56.090 --> 40:58.090
它是不是一个页面

40:58.090 --> 41:00.090
如果说是页面的话

41:00.090 --> 41:01.090
我就不要去控制它了

41:01.090 --> 41:02.090
那就不用控制它了

41:02.090 --> 41:03.090
换句话说

41:03.090 --> 41:05.090
如果说它不是页面的话

41:05.090 --> 41:06.090
那么我才需要缓存

41:06.090 --> 41:07.090
对吧

41:07.090 --> 41:08.090
包括图片

41:08.090 --> 41:09.090
技能式

41:09.090 --> 41:10.090
CSS

41:10.090 --> 41:11.090
字体

41:11.090 --> 41:12.090
这些文件我需要缓存

41:12.090 --> 41:13.090
就是我判断一下

41:13.090 --> 41:14.090
判断一下这个pass

41:14.090 --> 41:15.090
是不是n之位

41:17.090 --> 41:18.090
delete秒

41:18.090 --> 41:19.090
如果它不是

41:19.090 --> 41:20.090
不是的话

41:20.090 --> 41:21.090
是不是需要缓存

41:21.090 --> 41:22.090
那么这个时候

41:22.090 --> 41:23.090
才需要缓存

41:23.090 --> 41:24.090
我去set head

41:24.090 --> 41:26.090
去设置缓投

41:26.090 --> 41:28.090
就是catch

41:28.090 --> 41:29.090
console

41:30.090 --> 41:31.090
设置为多少呢

41:31.090 --> 41:33.090
这就要去写上max age

41:34.090 --> 41:35.090
等于什么呢

41:35.090 --> 41:37.090
等于我们再评计一下吧

41:37.090 --> 41:38.090
3600秒

41:38.090 --> 41:39.090
缓存1

41:39.090 --> 41:40.090
缓存1个小时

41:40.090 --> 41:41.090
实际上我们平时缓存的话

41:41.090 --> 41:43.090
一般就是永久缓存

41:43.090 --> 41:44.090
从要永久缓存的

41:44.090 --> 41:45.090
永久缓存

41:45.090 --> 41:46.090
我们这里就可以写一个

41:46.090 --> 41:47.090
非常非常大的数字

41:47.090 --> 41:48.090
非常非常大的数字

41:48.090 --> 41:50.090
比较说缓存1年

41:50.090 --> 41:51.090
这是一个小时

41:51.090 --> 41:52.090
每天24个小时

41:52.090 --> 41:53.090
365天

41:53.090 --> 41:54.090
缓存1年

41:55.090 --> 41:57.090
或者是缓存100年

41:57.090 --> 41:58.090
都可以

41:59.090 --> 42:00.090
好 这样子

42:00.090 --> 42:01.090
这样子写了过后

42:01.090 --> 42:02.090
我们来看

42:04.660 --> 42:05.660
刷新

42:06.660 --> 42:08.660
现在可以了

42:08.660 --> 42:09.660
现在可以了

42:09.660 --> 42:10.660
刷新

42:10.660 --> 42:11.660
因为我们这里刷新的过后

42:11.660 --> 42:13.660
页面是不会使用缓存的

42:14.660 --> 42:15.660
那么现在我们看到

42:15.660 --> 42:17.660
页面这里的max age的运营

42:17.660 --> 42:18.660
然后js是不是

42:18.660 --> 42:20.660
js怎么是这样的

42:20.660 --> 42:22.660
js还是用了之前的缓存结果

42:22.660 --> 42:24.660
我们这里把之前的缓存删一下

42:24.660 --> 42:26.660
之前的缓存clear

42:26.660 --> 42:27.660
browser catch

42:27.660 --> 42:29.660
清除流暗器缓存

42:29.660 --> 42:30.660
好 再来刷新

42:30.660 --> 42:33.680
好 你看

42:33.680 --> 42:34.680
现在说两半

42:34.680 --> 42:35.680
都是两半 对吧

42:35.680 --> 42:37.680
页面是max age的运营

42:37.680 --> 42:38.680
页面我们没控制

42:38.680 --> 42:39.680
css

42:39.680 --> 42:40.680
你看 等于这么多

42:40.680 --> 42:42.680
js100x age等于这么久

42:43.680 --> 42:44.680
所以缓存很久

42:44.680 --> 42:45.680
那么之后

42:45.680 --> 42:46.680
css的js除非扣装

42:46.680 --> 42:47.680
自己把它清除掉

42:47.680 --> 42:48.680
否则的话

42:48.680 --> 42:49.680
它就一直使用的是缓存

42:50.680 --> 42:52.680
但是页面一直是使用的是最新的

42:52.680 --> 42:53.680
对吧

42:53.680 --> 42:54.680
页面一直是使用

42:54.680 --> 42:55.680
每次要询问服务器

42:55.680 --> 42:56.680
有没有改动

42:56.680 --> 42:57.680
那么如果说服务器改动了呢

42:57.680 --> 42:58.680
改动了页面呢

42:58.680 --> 43:00.680
比方说我这里呢

43:00.680 --> 43:01.680
改成 你好

43:01.680 --> 43:02.680
改动了页面呢

43:02.680 --> 43:03.680
那么你看一下

43:03.680 --> 43:05.680
下一次的请求结果

43:05.680 --> 43:06.680
刷新

43:06.680 --> 43:08.680
你看 是不是反省200了

43:08.680 --> 43:09.680
我们来看一下这个请求

43:09.680 --> 43:11.680
请求的时候仍然会询问服务器

43:11.680 --> 43:12.680
看一下

43:12.680 --> 43:14.680
这个etc编没编的

43:14.680 --> 43:15.680
服务器看这个etc

43:15.680 --> 43:16.680
是编的 你看

43:16.680 --> 43:17.680
变成2580了

43:17.680 --> 43:19.680
这里以前是afl0

43:19.680 --> 43:20.680
对吧

43:20.680 --> 43:21.680
etc是编的

43:21.680 --> 43:22.680
编了过后

43:22.680 --> 43:23.680
一太可

43:23.680 --> 43:24.680
那种变了一太可有变了

43:24.680 --> 43:25.680
变了过后

43:25.680 --> 43:26.680
说明这个缓存

43:26.680 --> 43:27.680
肯定有问题了

43:27.680 --> 43:28.680
服务器重新给你发动一个缓存指令

43:28.680 --> 43:30.680
同时给你是200

43:30.680 --> 43:31.680
ok 不是304的

43:31.680 --> 43:32.680
那么客户端一看

43:32.680 --> 43:34.680
原来缓存已经失销了

43:34.680 --> 43:35.680
所以说我就把缓存更新

43:35.680 --> 43:37.680
就这么个意思

43:37.680 --> 43:38.680
那么后续呢

43:38.680 --> 43:40.680
后续又是304

43:40.680 --> 43:41.680
又是304

43:41.680 --> 43:42.680
就这么个意思

43:42.680 --> 43:43.680
好好去想想这个逻辑

43:43.680 --> 43:44.680
然后这两个逻辑

43:44.680 --> 43:45.680
是不是一直没变

43:45.680 --> 43:48.680
一直使用的是本地的缓存

43:48.680 --> 43:49.680
这里有个memory开启

43:49.680 --> 43:50.680
一个desk开启

43:50.680 --> 43:51.680
差不多啊

43:51.680 --> 43:53.680
本支都是存到那个磁盘上的

43:53.680 --> 43:54.680
就是有些呢

43:54.680 --> 43:55.680
他觉得缓温磁盘

43:55.680 --> 43:56.680
本地缓温磁盘也比较慢吧

43:56.680 --> 43:57.680
对吧

43:57.680 --> 43:58.680
缓温硬盘都是比较慢的

43:58.680 --> 43:59.680
所以说呢

43:59.680 --> 44:00.680
他有的是比较常用的

44:00.680 --> 44:01.680
或者比较小的

44:01.680 --> 44:02.680
他自己瀏覽器自己有策略的

44:02.680 --> 44:04.680
他会把它堵到内存

44:04.680 --> 44:06.680
直接内存里面使用

44:06.680 --> 44:08.680
好 这是关于这一块

44:08.680 --> 44:09.680
那么有些人说

44:09.680 --> 44:10.680
如果说我更新到GSE

44:10.680 --> 44:11.680
更新CSS怎么办了

44:11.680 --> 44:12.680
比方说

44:12.680 --> 44:14.680
那么就是我们之前的做法了

44:14.680 --> 44:15.680
我们一般更新使用

44:15.680 --> 44:16.680
webpack的更新

44:16.680 --> 44:17.680
对不对

44:17.680 --> 44:18.680
更新到CSS过后

44:19.680 --> 44:20.680
是不是变了

44:20.680 --> 44:21.680
哈希

44:22.680 --> 44:23.680
他的哈希是不是变了

44:25.680 --> 44:26.680
对不对

44:26.680 --> 44:27.680
好 那么这里呢

44:27.680 --> 44:29.680
页面上的引用是不是要变

44:29.680 --> 44:30.680
变成怎么了

44:31.680 --> 44:32.680
1.

44:32.680 --> 44:33.680
变这个对吧

44:33.680 --> 44:35.680
然后这边的引用是不是要变

44:35.680 --> 44:36.680
你回一下webpack

44:39.680 --> 44:43.400
好 这个东西是不是变了

44:43.400 --> 44:45.400
好 那么这两个变了过后

44:45.400 --> 44:46.400
页面是不是变了

44:46.400 --> 44:47.400
页面变了过后

44:47.400 --> 44:48.400
页面是不是

44:48.400 --> 44:50.400
因为页面一直在读取服务器

44:50.400 --> 44:51.400
对不对

44:51.400 --> 44:52.400
那么页面变了

44:52.400 --> 44:53.400
是不是拿到的引用地址

44:53.400 --> 44:54.400
不一样了

44:54.400 --> 44:55.400
引用地址不一样了

44:55.400 --> 44:56.400
是不是缓存无法命中了

44:56.400 --> 44:57.400
对吧

44:57.400 --> 44:58.400
你看看

44:58.400 --> 44:59.400
是不是重新读了

44:59.400 --> 45:00.400
对吧 这个

45:00.400 --> 45:01.400
就是这样的技术

45:02.400 --> 45:03.400
好 这是关于这个缓存

45:03.400 --> 45:04.400
我要说的东西

45:04.400 --> 45:05.400
那么最后呢

45:05.400 --> 45:06.400
我们把总结一下

45:06.400 --> 45:07.400
总结的时候

45:07.400 --> 45:08.400
我通过两个视角

45:08.400 --> 45:10.400
来看这个缓存

45:11.400 --> 45:12.400
好 第一个视角

45:12.400 --> 45:13.400
就是服务器的视角

45:14.400 --> 45:15.400
服务器它是怎么样的

45:15.400 --> 45:16.400
一种思维方式呢

45:16.400 --> 45:17.400
它还不知道客户端是它

45:17.400 --> 45:18.400
也不知道客户端是浏览器

45:18.400 --> 45:19.400
还是什么别的玩意

45:19.400 --> 45:20.400
无所谓

45:20.400 --> 45:22.400
你只要给我发送一个没有

45:22.400 --> 45:24.400
你只要发送一个普通请求

45:24.400 --> 45:25.400
什么叫普通请求

45:25.400 --> 45:27.400
就是没有带缓存指令的

45:27.400 --> 45:29.400
就没有这两个东西

45:30.400 --> 45:31.400
没有这两个

45:31.400 --> 45:32.400
对吧

45:32.400 --> 45:33.400
那么就是个普通请求

45:33.400 --> 45:35.400
如果说你给我发一个普通请求的话

45:35.400 --> 45:36.400
那我简单对吧

45:36.400 --> 45:37.400
我该缓存的

45:37.400 --> 45:38.400
就给你发送缓存指令

45:38.400 --> 45:40.400
反正总之给你想定的是200

45:40.400 --> 45:41.400
OK 这是毫无疑问的

45:41.400 --> 45:43.400
然后给它一些缓存指令

45:43.400 --> 45:44.400
如果说服务器有些

45:44.400 --> 45:45.400
服务器它不想给你缓存指令

45:45.400 --> 45:46.400
不要说你自己控制了

45:46.400 --> 45:47.400
不给缓存指令

45:47.400 --> 45:48.400
那就不给了

45:48.400 --> 45:50.400
好 如果说你给我发的是一个

45:50.400 --> 45:51.400
确认请求

45:51.400 --> 45:54.400
带一个缓存确认请求的

45:54.400 --> 45:56.400
就带有缓存指令的请求

45:56.400 --> 45:57.400
那么这个时候我要验证

45:57.400 --> 45:58.400
服务器呢

45:58.400 --> 46:00.400
很多服务器都会自行处理

46:00.400 --> 46:01.400
不要说Express服务器

46:01.400 --> 46:02.400
它都会自行处理

46:02.400 --> 46:03.400
它会验证

46:03.400 --> 46:06.400
就是我给你想用的消息体

46:06.400 --> 46:08.400
把它进行编码过后

46:08.400 --> 46:09.400
那个E-Type

46:09.400 --> 46:11.400
跟你上给我发过来

46:11.400 --> 46:12.400
这个东西是不是一致的

46:13.400 --> 46:14.400
如果说不一致的话

46:14.400 --> 46:15.400
那一定是200 OK

46:15.400 --> 46:16.400
那如果说一致的话

46:16.400 --> 46:17.400
我就给你304

46:18.400 --> 46:19.400
就不给你消息体了

46:19.400 --> 46:21.400
你继续使用缓存就完事了

46:21.400 --> 46:22.400
对吧

46:22.400 --> 46:23.400
这服务器视角

46:23.400 --> 46:25.400
然后那浏览器视角

46:25.400 --> 46:26.400
浏览器视角呢

46:26.400 --> 46:28.400
就是它首先我要请求

46:28.400 --> 46:29.400
请求的时候我要看一看

46:29.400 --> 46:31.400
以前我们不是问过一个题吗

46:31.400 --> 46:32.400
经典的一道题

46:32.400 --> 46:36.400
就是浏览器在地址南苏地址过后

46:36.400 --> 46:38.400
那么会发生什么事

46:38.400 --> 46:40.400
你是不是可以把缓存加上

46:40.400 --> 46:41.400
发动请求的时候

46:41.400 --> 46:43.400
还要看检查一下缓存

46:43.400 --> 46:44.400
有没有缓存

46:44.400 --> 46:45.400
没有缓存

46:45.400 --> 46:46.400
我就是普通请求了

46:46.400 --> 46:47.400
如果说有缓存的话

46:47.400 --> 46:48.400
怎么样了

46:48.400 --> 46:49.400
我就去请求服务器的时候

46:49.400 --> 46:50.400
就带缓存请求

46:50.400 --> 46:53.400
就带缓存缓存缓存指令

46:53.400 --> 46:55.400
如果说缓存还有效

46:55.400 --> 46:56.400
那就不请求服务器了

46:56.400 --> 46:57.400
直接用缓存

46:57.400 --> 46:59.400
就这么个意思

46:59.400 --> 47:01.400
这是浏览器视角

47:02.400 --> 47:05.400
浏览器受到服务器响应的时候

47:05.400 --> 47:07.400
它会根据缓存的指令

47:07.400 --> 47:08.400
进行处理

47:08.400 --> 47:10.400
然后说服务器给我响应的是200 OK

47:10.400 --> 47:12.400
给了我一些缓存指令

47:12.400 --> 47:13.400
那我如果说

47:13.400 --> 47:14.400
我就看一下有没有缓存

47:14.400 --> 47:15.400
那有缓存的更新

47:15.400 --> 47:16.400
它没有缓存去添加

47:16.400 --> 47:19.400
如果说服务器给我的是304

47:19.400 --> 47:21.400
给了我一些缓存指令

47:21.400 --> 47:24.400
那么浏览器就直接使用缓存里边的

47:24.400 --> 47:26.400
继续使用缓存里边的内容

47:26.400 --> 47:31.400
然后同时更新缓存的一些信息

47:31.400 --> 47:32.400
就是浏览器的视角

47:32.400 --> 47:34.400
总之浏览器和服务器

47:34.400 --> 47:36.400
就是通过这个ATB协议

47:36.400 --> 47:38.400
这个缓存协议进行交付

