WEBVTT

00:01.140 --> 00:04.140
这一刻咱们开始来讲这个跨域

00:04.140 --> 00:06.540
跨域我们分为两节课

00:06.540 --> 00:10.060
实际上你们以前在学科普端那一块的时候

00:10.060 --> 00:12.140
比方说学接跨域的时候

00:12.140 --> 00:14.540
应该是接触过跨域

00:14.540 --> 00:18.140
还包括网络通信的时候也接触过跨域

00:18.140 --> 00:21.540
跨域是浏览器搞出来的一些东西

00:21.540 --> 00:24.540
如果说脱离到浏览器环境根本就不存在这个问题

00:24.540 --> 00:28.140
是浏览器搞出来一个东西叫做同源策略

00:28.140 --> 00:30.140
它是为了安全

00:30.740 --> 00:31.940
它什么样子呢

00:31.940 --> 00:34.740
首先搞清楚什么叫同源我简单再回归一下

00:34.740 --> 00:40.740
就是说你当前的页面和你请求资源的地址

00:40.740 --> 00:43.140
就当前页面不是有个地址吗

00:43.140 --> 00:45.540
请求的资源是不是有个地址

00:45.540 --> 00:50.940
这两个地址协议端口主机名必须要完全相同

00:50.940 --> 00:52.540
才叫同源

00:52.540 --> 00:54.540
凡是两个地址同源的话

00:54.540 --> 00:58.940
浏览器认为一切都是ok的都是同一家人

00:58.940 --> 01:02.340
所以说呢也不会出现什么样的限制

01:02.340 --> 01:05.740
就比如我再次相信的举个例子啊就比方说

01:05.740 --> 01:07.740
你的页面地址

01:07.740 --> 01:12.340
页面地址是这个啊比方说是这个

01:12.340 --> 01:16.340
呃3w啊这个

01:16.340 --> 01:17.540
这是你的页面地址

01:17.540 --> 01:21.140
然后呢你请求的资源地址

01:21.140 --> 01:22.940
怎么样请求地址比方RF是请求

01:22.940 --> 01:27.540
说一个资源地址啊请求的资源地址呢是这个

01:27.940 --> 01:29.540
1.edu

01:33.540 --> 01:35.140
随便写个吧

01:35.140 --> 01:37.140
啊 API 啥啥啥啥

01:37.140 --> 01:38.420
那么这两个地址

01:38.420 --> 01:41.540
外面叫看重头叫遵守同源策略

01:41.540 --> 01:43.340
有没有同源呢就没有同源

01:43.340 --> 01:44.740
他主机名不一样

01:44.740 --> 01:46.340
对不对是不是主机名不一样

01:46.340 --> 01:47.340
不同源啊

01:47.340 --> 01:48.940
如果说那个地址里边呢

01:48.940 --> 01:50.540
如果说啊这种情况

01:50.540 --> 01:55.570
呃比方说还是这个地址

01:55.570 --> 01:56.970
啊但是端口变了

01:56.970 --> 02:01.570
那么这个东西算不上同员呢 他也不算同员

02:01.570 --> 02:07.970
只要协议 主机民和端口任何一个不一样

02:07.970 --> 02:09.770
那么都不叫同员

02:09.770 --> 02:14.770
只有同员的时候呢 浏览器才认为 这是非常安全的

02:14.770 --> 02:18.570
都是同一家人 数据和页面都是来自于同一家 认为是安全的

02:18.570 --> 02:20.370
那么这个时候还不会进行限制

02:20.370 --> 02:25.370
如果说不同员的话 那么浏览器不允许地使用非同员的数据

02:25.970 --> 02:29.970
就不允许地用了 那么这就会造成一些问题 造成跨越问题

02:29.970 --> 02:34.170
比方说我们举个例子啊 到我们现在这个工程里边去

02:35.770 --> 02:36.570
我们把运行出来

02:37.370 --> 02:43.970
start 然后页面上呢 我们把改一下啊 页面上改一下 这都是之前的页面嘛 我们把删掉

02:46.570 --> 02:50.970
然后呢 这个节词里边呢 我们写上这么一句话 比方说我们就直接去请求啊

02:51.970 --> 02:54.570
请求哪个地址呢 a d d p localhost

02:55.770 --> 02:56.970
啊 5008

02:57.970 --> 03:05.170
然后呢 api student 去请求这个地址啊 然后呢 z 得到把解析成接证格式

03:05.970 --> 03:11.370
接证啊 然后呢再 z 得到服务器的响应结果 输出响应结果

03:11.770 --> 03:17.570
好 个说话一下啊 好 接下来呢 我们直接到浏览器里边去访问这个啊 localhost 5008

03:18.570 --> 03:25.170
去访问啊 右键检查 看一下控制台里边有没有输出呢 是不是有输出 没问题 为什么现在没问题呢 因为是同源的

03:26.270 --> 03:32.270
我们的一面地址是不是这个 我们请求的地址 你看一下 是不是协议

03:33.270 --> 03:36.470
主机民端口号跟我们的一面地址是不是完全一样

03:37.070 --> 03:45.070
对不对 那么就现在同源的 因此没有任何问题 那如果说不同源的 我们现在一面我们这样子来运行啊 我们这样子到那个在这里边

03:45.270 --> 03:52.070
只先用这个双击 这种方式来运行 那就肯定不行了 你看 现在他是不是可以报一个错

03:52.670 --> 03:58.070
对不对 高速的什么呢 高速里不满足同源策略 就是这个问题啊 就跨预了

03:58.570 --> 04:05.670
为什么不一样呢 你看协议 这个协议是 file 协议啊 直接读的文件协议 协议都不一样 对不对 主机民都没有主机民 对不对

04:06.270 --> 04:11.270
那个也不一样啊 端口号呢也不一样 对不对啊 当然呢 如果说你用那个

04:11.870 --> 04:12.870
你用这个方式啊

04:13.770 --> 04:17.470
用那个 open with live server 这种方式也是遇到同样的问题

04:18.370 --> 04:23.670
啊 所以遇到同样的问题 端口号是不是不一样 对不对啊 主机民是不是不一样 对不对

04:24.070 --> 04:28.470
所以也遇到同样的问题啊 我在那个文件里面打开跟这种方式都是遇到同样的问题 就是跨预了

04:29.310 --> 04:34.750
好 那么这个问题怎么解决呢 就是有的时候啊 咱们的服务器可能有很多个

04:35.550 --> 04:42.750
有一个专门在处理 API 的服务器 我们可能啊 有些大的项目里边 我们可能呢 在另一个客户端啊

04:43.550 --> 04:47.950
去访问那个就是我们的 API 服务器 就是我们可能会形成这么一个结构

04:49.150 --> 04:52.350
就是我们的服务器呢 可能有两个 一个是静态资源服务器

04:53.150 --> 04:58.350
当然我们现在弄在一起的 对不对 像中小型项目都可以直接弄在一起 一个是静态资源服务器

04:59.150 --> 05:04.750
一个是 API 服务器 那么两个服务器可能是不一样的 静态资源的服务器呢

05:04.750 --> 05:09.150
比方说我们要获取那个 index 的ATM 页面呢 我们可能是在这个地址

05:10.750 --> 05:14.950
我们的 index 的ATM 页面可能是在这个地址 比方说Do1.com

05:16.350 --> 05:21.950
那么 API 服务器的地址呢 可能是ATP API Do1.com

05:22.350 --> 05:25.950
那么在这个页面上要去请求这个 API 是不是就遇到跨预问题

05:26.350 --> 05:32.150
如果说我们是服务器是这样的分布的话 都是我们自家人 但是呢 遇到这么一个跨预问题的

05:32.750 --> 05:37.550
或者是 API 服务器我们重新注册了一个域名 叫做Do1 API.com

05:38.550 --> 05:43.150
有可能会出现这种情况 那么遇到这种情况的时候呢 是不是就遇到了跨预问题

05:43.750 --> 05:50.550
那么这个问题呢 如果怎么解决呢 因为现在问题就是浏览其他 认为我们不是一家人 那么我们得让他知道我们是一家人

05:50.750 --> 05:53.750
那么解决的方式呢 有两种 一种呢 是那个

05:54.350 --> 06:01.550
节省P 这是一种比较古老的方式啊 也就是我们这几颗讲的方式 因为以前呢 确实没有办法 只能用这种方式

06:01.950 --> 06:04.150
那么现在呢 我们一般都使用CLRS

06:04.950 --> 06:11.150
下节课我们来讲 这一课那么节省P呢 因为以后呢 你们到公司里面 万一遇到一些老的项目 可能还在使用节省P

06:11.550 --> 06:14.150
包括你们接跨预里面的跨预 是不是就用节省P来做的

06:14.750 --> 06:21.350
对不对 无论是哪一种方式 他都需要客户端和服务器双方配合才能完成

06:21.750 --> 06:24.750
光靠一边努力是不行的 所以你们之前接触的跨预啊

06:25.750 --> 06:26.150
都是

06:27.350 --> 06:34.750
只搞定了一半 就是客户端的一半 服务器那边呢 是以别人帮你搞定的 所以我们现在学到服务器这一块 我们要知道服务器怎么来处理

06:35.150 --> 06:40.350
好 我们这一块来看节省P这种方式啊 这种方式呢 已经比较古老了啊 新的项目一般不会用的这种方式

06:40.950 --> 06:44.350
但是我们只需要了解一下就行了 他就分为两步

06:45.150 --> 06:51.950
第一步呢 由于你的阿迦克斯请求啊 是现在遇到的跨预问题 然后我就不是用阿迦克斯请求了

06:52.150 --> 06:56.450
所以说节省P这种方式跟阿迦克斯没有任何关系 他根本就不用用的不是阿迦克斯请求

06:57.050 --> 07:01.650
那他怎么做的呢 他是生成一个script的元素来访问数据接口

07:02.350 --> 07:06.650
他是用这种方式 也就是什么意思呢 他是比方说我们要请求一个地址

07:07.050 --> 07:14.650
他是在页面上给你生成一个script元素 在这个元素里边呢 去请求我们想要请求的地址

07:15.450 --> 07:24.750
Localhost 5008 API什么的student 他是用这种方式 那么我们来看一下这种方式能不能请求到服务器呢

07:25.950 --> 07:26.250
注视了

07:28.150 --> 07:31.850
保存 我们看一下这种方式能不能请求到服务器啊 这边我们刷新

07:32.850 --> 07:36.650
啊 他这里呢 说跨预了 一个警告啊 没关系

07:37.650 --> 07:43.850
没关系啊 我们到服务器这边来 找到这个roads api啊这个student 打个观点

07:45.050 --> 07:49.650
我们上一课不是学了观点条子吗 运行一下 看他有没有运行到这啊 接下来我们来刷新

07:51.050 --> 07:56.650
是不是运行到这了 是不是请求过来了 对不对 而且给他响应了一个结果 那么这种方式呢

07:57.350 --> 08:01.050
为什么是可以的呢 为什么这样的运行跨运呢 你想啊 你平时读图片

08:02.050 --> 08:04.730
读一张图片 是不是可以读别的网站的图片

08:05.610 --> 08:11.250
你读css 是不是可以读别的网站的css 你读jss 是不是可以用一些cdn上面的jss

08:11.650 --> 08:19.290
对不对 是不是别的网站的 那么这些东西都是跨预啊 都没有问题啊 所以说像jss啊 这些资源文件他是允许跨预的 是没有问题的

08:20.050 --> 08:29.050
那么现在的问题是 我怎么样把这个数据拿到 现在是关键 因为这个地方返回了 是不是一个jss吗 我们这个地方返回了 是不是jss吗

08:29.450 --> 08:35.650
它不是一个jss代码 对吧 是不是jss 肯定不是 它返回的是一个接胜格式的数据 它不是一个jss代码

08:36.090 --> 08:43.850
因此一个代码的运行呢 肯定要出问题的啊 这个代码运行啊 肯定要出问题的 他没有他没办法正常的去运行这个jss代码

08:44.370 --> 08:50.130
那么现在的怎么又怎么办呢 我们需要让他返回的是一个jss代码就可以了

08:51.050 --> 08:57.370
那怎么样让他返回是一个 就是让这个地址返回是一个jss代码呢 我们就需要在这个地址的服务器去做文章了 就在这儿

08:57.730 --> 09:00.370
啊 我们把这个以前的包装这个函数的给他去掉

09:01.490 --> 09:06.970
不要在这里啊 这个这个接口呢 我们允许跨域 那怎么办呢 我们这里是不是得到所谓的学生数据了

09:08.490 --> 09:10.770
所谓的学生数据 对不对 啊 这个是不是个对象

09:11.850 --> 09:16.930
啊 这个玩意是不是个对象 是一个对象吗 咱们把这个对象呢 把它变成一个制服串

09:17.930 --> 09:20.370
可不可以 当然可以啊 咱们把它变成了制服串

09:20.930 --> 09:21.930
jss205

09:22.890 --> 09:23.450
result

09:24.570 --> 09:28.690
把它变成一个制服串 啊 返回的是什么呢 返回的就是一个接上格式的制服串

09:31.250 --> 09:36.770
反而就是接上格式的制服串 然后呢 我们把这个接上格式的制服串呢 包装一下啊

09:38.330 --> 09:40.090
包装一下 script

09:42.580 --> 09:44.580
啊 给他写上这么一个callback

09:45.740 --> 09:53.340
啊 接上 把这个拼接进来 好 咱们来看一下啊 它生成出来的制服串到底是什么呀啊 最后呢 我们

09:53.700 --> 09:54.540
把它响应过去

09:55.300 --> 09:58.700
jss 先不到就响应吧 我们把这个地方打个断点

09:59.660 --> 10:04.900
保存啊 打断点 好 那么接下来 那么这里运行啊 调试

10:06.820 --> 10:08.300
其实你if就可以了啊

10:09.420 --> 10:11.860
好 那么现在呢 我们再来刷新

10:13.580 --> 10:16.500
好 接下来我们来看一下这个下一步

10:18.260 --> 10:21.820
好 你看一下这scripps 你看 得到是这么一个制服串对不对

10:22.380 --> 10:27.340
所以想用这么一个制服串callback 是不是要调用一个函数 函数里边是传了一个对象进去

10:28.340 --> 10:33.700
对吧 传 传一个对象进去 然后函数调用结束 那么这个东西是不是一个有效的介石代码

10:34.620 --> 10:38.820
你看一下吧 它就是一个有效的介石代码 我们把它复制一下 张听到我们那个介石里边

10:40.140 --> 10:46.540
啊 你看一下 格式化一下 你看 是不是就是个有效的介石代码 callback 某一个 把一个对象传进去了 对不对 一个对象质面量

10:47.140 --> 10:52.020
对吧 那么现在呢 我们只需要把这东西响应给 响应给个客户端就行了 怎么来响应呢

10:52.700 --> 10:54.060
我们可以用这种方式 转开

10:55.540 --> 11:03.140
啊 我们就可以用race啊 首先给他设置一个消息头 因为他是一个介石格式 要告诉客户端 这是我这是介石啊 叫做content

11:03.580 --> 11:06.060
type 我就不再是一个接生格式了 我是什么呢

11:06.740 --> 11:07.460
application

11:11.030 --> 11:11.630
java script

11:12.430 --> 11:17.830
啊 这是我的一个响应头 然后呢 我把的响应体是什么呢 send script 把这个字不算 发动过去

11:19.310 --> 11:21.710
好 我把服务器改成这样子了 接下来我们再来看

11:23.190 --> 11:26.590
这里我们刷新 刷新过后来我们看一下student

11:27.350 --> 11:34.430
他服务器的响应结果 你看 响应结果是不是一个调用一个函数 对不对 调用一个函数 那么我们看一下console 这边

11:35.030 --> 11:39.190
他发现什么问题 他说callback is not defined 说明啥呀

11:39.790 --> 11:48.390
他说你不是在调用一个函数吗 你这请求他得到一个介石代码 对不对 他执行这个介石代码 那么这个介石代码一执行 你看一下这个执行会不会出 会不会出问题

11:50.030 --> 11:53.230
这个地方执行 他要调用一个函数 对不对 callback 这个函数来调用他

11:53.870 --> 12:00.390
这就是一段介石代码 也不要想多了 服务器给我一个段介石代码 那么这个段介石代码是不是要调用一个callback函数

12:00.950 --> 12:08.190
那么这个函数是不是没有啊 是不是没有这个函数 那自然就出问题了 那么也就是说我们这里呢 要准备好一个函数就行了

12:08.870 --> 12:16.030
callback 要准备好一个函数 那么函数是不是有个参数data 对吧 他要传一个参数进来 那么这个参数拿到过后呢 输出data

12:17.030 --> 12:24.390
啊 保存 你看一下 现在没问题了 刷新 你看控制台里边 这不打印出来的一个头头 对吧 这不打印出来的这个

12:25.470 --> 12:32.350
服务器的详细结果 就是用这种方式来跨越 当然这种方式跨越了 我们目前是熟悉的 对吧 是直接写死的这类的

12:32.670 --> 12:38.230
我们当然也可以把它封装成一个 封装成一个函数 比方说我们这里可以封装成一个函数啊

12:40.110 --> 12:43.030
啊 我们封装一个吧 封装一个就是方形

12:43.470 --> 12:46.630
嗯 就是getdata

12:48.350 --> 12:50.350
我就会去叫做接生辟吧 啊 接生辟

12:51.430 --> 12:55.190
然后呢 我们这边呢 你给我传递一个url地址

12:56.750 --> 13:03.430
然后呢 你给我传递一个回调函数的名称啊 我们或者先不着急写回调函数的名称吧

13:03.910 --> 13:10.710
我们就直接传递这个url地址 那我怎么办呢 我来这里呢 去要做什么事情 我就不是用什么飞起啊 这个事情求了

13:11.030 --> 13:18.070
我是要在页面上去生成一个script元素 对不对 好 我们这里呢 document啊 写一个就是

13:19.270 --> 13:19.750
script

13:22.950 --> 13:29.180
document create element 生成一个script元素

13:31.980 --> 13:36.220
然后呢 给这个元素的src地址 是不是定给他这个url

13:36.940 --> 13:44.140
然后把这个元素加到哪去 是不是加到了个document body append child 是吧 加到这里去

13:45.020 --> 13:50.780
对不对 是不是加到这里去 啊 加到这里去过后啊 我们还甚至呢还可以给他一个

13:52.860 --> 13:59.580
id或者是什么玩意儿 我们就先我想想啊 就这样吧 就这样吧 咱们咱们把这个script元素加进去

14:00.060 --> 14:07.500
好 加进去了过后呢 那么这个script元素是不是就直接到页面上去了 跟刚才的一样 对吧 把这个url地址直接到生成的页面上去了

14:07.500 --> 14:12.300
他就会请求这个url地址 然后拿到一段接代码 接代码是不是温运行这个callback函数

14:12.460 --> 14:16.780
callback函数就是我们最终拿到服务系的结果过后要执行的函数

14:17.340 --> 14:21.980
没意思吧 好 咱们来看一下啊 这样子写行不行 我们这里呢 去调用啊 节省p

14:23.180 --> 14:27.580
去请求我们的ttp啊 localhost 5008

14:28.940 --> 14:32.780
啊 去请求这个地址 好 来吧 我们刷新

14:34.300 --> 14:39.500
哎 到这里出了问题 我看一下啊 哦 这里还没有写完 对吧

14:40.220 --> 14:42.540
API student

14:44.060 --> 14:48.060
好 刷新 好 你看是不是仍然可以拿到这个数据 对吧

14:48.780 --> 14:55.820
啊 只不过呢这个script元素是不是没有删除 对吧 它一直在这儿啊 我们用完了过后呢 可以把这个script元素删除掉

14:56.060 --> 15:03.740
啊 我们可以给这个script元素呢 加一些 加一个加一个啥呢 我可以给他做一个实践 我看一下啊

15:04.620 --> 15:11.660
script元素啊 unload 当家在完成过后啊 应该是这个时间啊 我看一下

15:14.600 --> 15:21.480
刷新啊 对了的 那么我在这个时候呢 把script元素加干掉啊 叫什么呢 叫remove

15:22.920 --> 15:23.400
干掉

15:24.280 --> 15:30.440
好 刷新 你看我们数据是不是拿到了啊 而且呢这个script元素是不是删除掉了 对吧 保持得看干净

15:31.160 --> 15:36.680
就这么回事啊 就这么回事 无论呢这个就是结款里面的还可以配置这个函数的名称 对不对

15:37.080 --> 15:43.320
是不是可以配置这个函数的名称啊 就是这些东西呢 我们就拿来去封装了啊 就接生平大概就是这么一个意思啊

15:43.640 --> 15:47.800
因为这个东西呢 已经是很老招牙的一种方式了啊 因为他有很多的问题

15:48.120 --> 15:51.560
那么我们后边的重点学习steo rs 这个东西我们作为了解就行了

15:51.880 --> 15:57.160
接生平还有个两个最严重的学习 一个学习是他会严重的影响服务器的正常响应格式

15:57.560 --> 16:02.120
你看服务器现在这个steo rs 这个响应格式是不是变了 变成这种格式了

16:02.920 --> 16:07.240
对不对 那如果说我们要一个正常的响应格式啊 有的时候他没有跨越了

16:07.400 --> 16:13.480
那我要一个正常的响应格式是不是有麻烦 对吧 我要根据不同的情况 到底给他返回接生平的格式还是给他返回一个正常格式

16:13.640 --> 16:20.120
对服务器造成很大的麻烦啊 第二个呢 是那个他只能使用概册请求 因为为什么只能使用概册请求呢

16:20.280 --> 16:24.680
因为这个玩意儿 生成的script元素他只是发动概册请求 他不会发动pose请求的

16:25.640 --> 16:30.200
所以说让pose请求 你还办不到 对不对 这种事情还办不到 他只能用概册请求

16:30.520 --> 16:34.440
因此呢 这种跨越方式呢 是已经非常古老的跨越方式啊 有很多的学县

16:34.760 --> 16:41.160
咱们这节课简单的了解一下接生p 因为你们毕竟以前在接credit的时候用过 对吧 我们还是了解一下

16:41.480 --> 16:46.760
那么下节课我们讲一个终点的跨越方式叫seo rs 内容比较多 我们这节课先到这里

