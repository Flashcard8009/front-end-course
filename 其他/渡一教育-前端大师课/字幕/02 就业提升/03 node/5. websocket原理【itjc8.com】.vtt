WEBVTT

00:00.620 --> 00:04.420
这个章节咱们做一些补充的知识

00:04.420 --> 00:08.620
这些补充的知识当中有一些是扩展课程

00:08.620 --> 00:12.620
就是你们以后可能用的不太多 或者是不这么用的

00:12.620 --> 00:17.620
另外一些是之前就忘记得讲的

00:17.620 --> 00:20.620
后段东西太多了 也记不得很清楚

00:20.620 --> 00:24.620
反正给它补充吧 我详细了一些给它补充在这个章节里面

00:24.620 --> 00:29.620
前面这几页课 我们要讲一个东西叫做web socket

00:30.620 --> 00:35.620
这个玩意儿我也不知道应不应该把它作为扩展课程

00:35.620 --> 00:38.620
还是听一下吧 还是听一下

00:38.620 --> 00:41.620
因为以后有可能会用到

00:41.620 --> 00:44.620
那么我们来说一下web socket

00:44.620 --> 00:50.620
首先说它为什么有可能会有用

00:50.620 --> 00:53.620
那么我们首先要说到这个东西

00:53.620 --> 00:59.060
首先要说到这个socket 什么叫socket

00:59.060 --> 01:04.060
它其实倒不是一个什么协议

01:04.060 --> 01:09.060
它是一个抽象程 就在网络中是一个抽象程

01:09.060 --> 01:14.060
一般来说我们任何一个计算机语言要进行网络通信的话

01:14.060 --> 01:19.060
那么基本上是通过socket这样的一个抽象程来进行通信的

01:19.060 --> 01:23.060
它的协议的话 它是基于TCP IP协议的

01:23.060 --> 01:25.060
就是说它是怎么回事呢

01:25.060 --> 01:28.060
它就很简单 就是客户端

01:29.060 --> 01:31.060
连接服务器

01:31.060 --> 01:35.060
连接服务器是不是有一个就是TCP IP协议

01:35.060 --> 01:38.060
通过这个协议 连接服务器 当然也可以通过其他协议

01:38.060 --> 01:43.630
连接服务器 连接了过后了是不是建立了连接通道

01:43.630 --> 01:46.630
就三次握手

01:46.630 --> 01:52.070
然后建立了连接通道

01:52.070 --> 01:56.070
那么通过这个通道 双方就可以发送消息了

01:56.070 --> 02:00.070
那么无论是客户端 客户端和服务器

02:00.070 --> 02:04.070
通过socket接口发送消息

02:04.070 --> 02:07.070
这个东西我们在哪里学过呢 在第一章

02:07.070 --> 02:10.070
第一章我们不是讲了那个net 对不对

02:10.070 --> 02:13.070
net那个类似模块

02:13.070 --> 02:15.070
那么它里面就提供了socket接口 对不对

02:15.070 --> 02:17.070
我们可以通过这个留的读取方式

02:17.070 --> 02:21.070
socket往里面写东西 就是发送到另一端

02:21.070 --> 02:25.070
通过监听这个数据就是接收消息 对不对

02:25.070 --> 02:28.070
那么它就通过这个socket 它是个抽象接口

02:28.070 --> 02:33.070
它就是一个接口来发送消息和接收消息

02:33.070 --> 02:35.070
对吧 双方就开始这样互发

02:35.070 --> 02:41.070
谁 任何人在任何时刻都可以主动的向对方发送消息

02:41.070 --> 02:44.070
任何一端

02:44.070 --> 02:54.070
一端在任何时候都可以向另一端发送消息

02:54.070 --> 02:57.070
发送任何消息 当时我们也试过了 对不对

02:57.070 --> 03:00.070
发送一个字不算 发送一个数字 发送一个对象

03:00.070 --> 03:02.070
发送一个随便什么玩意儿都可以

03:02.070 --> 03:05.070
它没有限制消息的格式

03:05.070 --> 03:09.070
那么最后有一端

03:09.070 --> 03:12.070
有一端断开了

03:12.070 --> 03:16.070
通道断开 通道消费

03:16.070 --> 03:18.070
就一个连接通道就消费了

03:18.070 --> 03:19.070
那么在第二步的时候

03:19.070 --> 03:22.070
他们可以直接可以发送无限次数的消息

03:22.070 --> 03:24.070
也可以接受无限次数的消息

03:24.070 --> 03:26.070
这是socket

03:26.070 --> 03:27.070
好 然后呢

03:27.070 --> 03:30.070
我们后来又学到什么Aggdb 对不对

03:30.070 --> 03:33.070
Aggdb实际上是建立在socket基础上的

03:33.070 --> 03:35.070
它又是怎么为上的 它是这样子

03:35.070 --> 03:38.070
客户端 连接服务器

03:38.070 --> 03:41.070
然后还是tcpip

03:41.070 --> 03:43.070
还是通过这个协议 连接服务器

03:43.070 --> 03:44.070
就第一步是一样的

03:44.070 --> 03:46.070
还是有什么三次墨手

03:46.070 --> 03:49.070
三次墨手是发生在tcpip的 对不对

03:49.070 --> 03:51.070
建立了连接通道

03:51.070 --> 03:54.070
我们把叫可靠连接吗 连接通道

03:54.070 --> 03:56.070
好 这样连接通道过后呢

03:56.070 --> 03:57.070
接下来干嘛呢

03:57.070 --> 03:59.070
接下来就是第二步发生的不一样

03:59.070 --> 04:00.070
socket者是什么呢

04:00.070 --> 04:02.070
socket者是无限双方在的无限传输

04:02.070 --> 04:03.070
对不对

04:03.070 --> 04:04.070
Aggdb不是

04:04.070 --> 04:06.070
Aggdb它怎么回事呢

04:06.070 --> 04:07.070
它是客户端

04:07.070 --> 04:11.070
客户端发送一个

04:11.070 --> 04:14.070
Aggdp格式的消息

04:14.070 --> 04:15.070
什么叫Aggdp格式的消息

04:15.070 --> 04:17.070
就是带消息头

04:17.070 --> 04:18.070
然后带消息体

04:18.070 --> 04:20.070
一看是格式是不是有要求

04:20.070 --> 04:22.070
而且是客户端主动发出消息

04:22.070 --> 04:24.070
通过这个连接通道

04:24.070 --> 04:25.070
主动发出消息

04:25.070 --> 04:28.070
然后服务器想应

04:28.070 --> 04:31.070
Aggdp格式的消息

04:31.070 --> 04:33.070
这是Aggdb协议

04:33.070 --> 04:34.070
格式的消息

04:34.070 --> 04:37.070
那么这个也是带消息头和消息体

04:37.070 --> 04:38.070
一样的意思吧

04:38.070 --> 04:40.070
然后完了过后

04:40.070 --> 04:42.070
这一次看客户端发送一个消息

04:42.070 --> 04:44.070
估计想应一个消息

04:44.070 --> 04:46.070
然后通告端开

04:46.070 --> 04:48.070
客户端断开

04:48.070 --> 04:51.070
或服务器断开连接

04:51.070 --> 04:53.070
断开通道

04:53.070 --> 04:55.070
通道消费

04:55.070 --> 04:56.070
那么下一次

04:56.070 --> 04:58.070
如果说还要发送请求的话

04:58.070 --> 04:59.070
那么是不是又来

04:59.070 --> 05:00.070
又来建立三次握手连接

05:00.070 --> 05:01.070
连接建议号

05:01.070 --> 05:03.070
又来客户端主动发送一个消息

05:03.070 --> 05:05.070
然后服务器主动想应一个消息

05:05.070 --> 05:06.070
看没有

05:06.070 --> 05:08.070
这就是第二步的区别

05:08.070 --> 05:09.070
那有些同学说

05:09.070 --> 05:10.070
Aggdp不是支持

05:10.070 --> 05:12.070
常链接吗

05:12.070 --> 05:14.070
就是发送的请求头

05:14.070 --> 05:16.070
消息头里边带了一个

05:16.070 --> 05:17.070
Connection

05:17.070 --> 05:18.070
KeepLive

05:18.070 --> 05:20.070
随便访问一个网站

05:20.070 --> 05:24.790
找到这个网络

05:24.790 --> 05:26.790
刷新一样

05:26.790 --> 05:27.790
随便找个

05:27.790 --> 05:29.790
你看

05:29.790 --> 05:31.790
Connection KeepLive

05:31.790 --> 05:33.790
那么这个玩意有什么用呢

05:33.790 --> 05:34.790
好像说

05:34.790 --> 05:35.790
我们反复用那个通道

05:35.790 --> 05:36.790
是这样子的

05:36.790 --> 05:37.790
反复用那个通道

05:37.790 --> 05:38.790
就是说

05:38.790 --> 05:39.790
如果说带了这个东西的话

05:39.790 --> 05:40.790
服务器只要认

05:40.790 --> 05:41.790
关键是服务器要认

05:41.790 --> 05:43.790
一般服务器都会认的

05:43.790 --> 05:44.790
那么认到过后

05:44.790 --> 05:45.790
还是这样子

05:45.790 --> 05:47.790
第一步不变

05:47.790 --> 05:48.790
我们请求一个网页

05:48.790 --> 05:49.790
建立了链接通道

05:49.790 --> 05:50.790
但是

05:50.790 --> 05:51.790
链接通道过后了

05:51.790 --> 05:52.790
客户端发送一个

05:52.790 --> 05:53.790
Aggdp格式的消息

05:53.790 --> 05:54.790
这个消息头里边

05:54.790 --> 05:55.790
带了一个什么呢

05:55.790 --> 05:56.790
带了一个KeepLive

05:56.790 --> 05:57.790
那么这个时候

05:57.790 --> 05:58.790
服务器想应一个消息

05:58.790 --> 06:00.790
这个时候双方不着急断开

06:00.790 --> 06:02.790
不着急进行自己散步

06:02.790 --> 06:03.790
然后等着

06:03.790 --> 06:04.790
如果短时间内

06:04.790 --> 06:06.790
客户端又要发送一个消息

06:06.790 --> 06:08.790
那么使用同样的链接通道

06:08.790 --> 06:09.790
就这么个意思

06:09.790 --> 06:11.790
但是它的模式是没有改变的

06:11.790 --> 06:13.790
模式就是客户端主动发送

06:13.790 --> 06:14.790
服务器主

06:14.790 --> 06:16.790
客户端主动服务器被动

06:16.790 --> 06:18.790
最终了客户端开

06:18.790 --> 06:19.790
一般是浏览器

06:19.790 --> 06:20.790
看了一会

06:20.790 --> 06:21.790
看了一会发现

06:21.790 --> 06:23.790
我认为确实没什么东西可以请求了

06:23.790 --> 06:24.790
我就把链断开了

06:24.790 --> 06:25.790
然后服务器

06:25.790 --> 06:26.790
自然一断出的话

06:26.790 --> 06:28.790
两方双方都会断开

06:28.790 --> 06:30.790
一断的话双方都会断

06:30.790 --> 06:31.790
它这么一回事

06:31.790 --> 06:32.790
这是Aggdp

06:32.790 --> 06:34.790
那里看Aggdp跟Sockets有什么区别

06:34.790 --> 06:36.790
区别就大了在哪

06:36.790 --> 06:40.790
Aggdp是不是很快就会销毁

06:40.790 --> 06:43.790
如果说不是那个长�接

06:43.790 --> 06:44.790
不是那个tplive

06:44.790 --> 06:45.790
不是这个玩意的话

06:45.790 --> 06:46.790
那么它发送一次消息

06:46.790 --> 06:48.790
响应一次消息就直接断开了

06:48.790 --> 06:49.790
如果说长链接的话

06:49.790 --> 06:51.790
那么就算是发动消息

06:51.790 --> 06:54.790
这边响应也会很快断开

06:54.790 --> 06:55.790
一般来说

06:55.790 --> 06:58.790
就十来秒钟就会断开

06:58.790 --> 07:00.790
用不了多久

07:00.790 --> 07:01.790
很快就断开了

07:01.790 --> 07:02.790
而且它Aggdp的

07:02.790 --> 07:03.790
还还有就是

07:03.790 --> 07:05.790
它对消息的格式是不是有限制

07:05.790 --> 07:06.790
消息头消息踢

07:06.790 --> 07:07.790
Sockets是没有限制

07:07.790 --> 07:09.790
随便的发扎都可以

07:09.790 --> 07:11.790
也通道建立过随便的发扎

07:11.790 --> 07:12.790
然后还有什么区别呢

07:12.790 --> 07:13.790
还有Aggdp

07:13.790 --> 07:16.790
它是一个就是客户端主动的

07:16.790 --> 07:17.790
Sockets无所谓

07:17.790 --> 07:18.790
Sockets建立连接过后

07:18.790 --> 07:20.790
服务器可以主动给我发

07:20.790 --> 07:21.790
然后我也可以给主动给服务器发

07:21.790 --> 07:22.790
发多次

07:22.790 --> 07:23.790
服务器可以不响应

07:23.790 --> 07:24.790
也没有什么响应

07:24.790 --> 07:26.790
响应那个概念都没有了

07:26.790 --> 07:27.790
就是发消息

07:27.790 --> 07:28.790
给它发一个

07:28.790 --> 07:29.790
那边给我发一个

07:29.790 --> 07:30.790
任何事都可以

07:30.790 --> 07:32.790
这就是这两个区别

07:32.790 --> 07:33.790
然后我们再来说

07:33.790 --> 07:36.790
Aggdp它的问题

07:36.790 --> 07:37.790
问题在哪呢

07:37.790 --> 07:39.790
问题就在于

07:39.790 --> 07:41.790
如果说我们对某一些

07:41.790 --> 07:43.790
消息的实时性

07:43.790 --> 07:45.790
要求比较高

07:45.790 --> 07:46.790
比方说你打开一个网页

07:46.790 --> 07:48.790
相信大家头脑里面想象

07:48.790 --> 07:49.790
打开一个网页

07:49.790 --> 07:50.790
那个网页上显示了啥

07:50.790 --> 07:52.790
显示的是股票

07:52.790 --> 07:53.790
股票的信息

07:53.790 --> 07:54.790
是不是

07:54.790 --> 07:57.790
时时刻刻股票在变动

07:57.790 --> 07:59.790
那么关于实时消息

07:59.790 --> 08:00.790
我们说一下

08:00.790 --> 08:01.790
实时消息的问题

08:01.790 --> 08:04.790
实时性的问题

08:04.790 --> 08:06.790
比方说你访问一个网页

08:06.790 --> 08:09.790
它那边股票使用很快就会变动

08:09.790 --> 08:11.790
那如果说你Aggdp协议

08:11.790 --> 08:13.790
股票的信息变动

08:13.790 --> 08:14.790
是在服务器变动的

08:14.790 --> 08:15.790
对不对

08:15.790 --> 08:17.790
客户端不知道服务器有没有变动

08:17.790 --> 08:20.790
那么Aggdp它的问题在哪呢

08:20.790 --> 08:21.790
问题在于

08:21.790 --> 08:23.790
它每一次交互

08:23.790 --> 08:24.790
都是客户端发起的

08:24.790 --> 08:26.790
但是客户端根本就不知道

08:26.790 --> 08:28.790
服务器有数据变动了

08:28.790 --> 08:29.790
服务器倒是知道数据变动了

08:29.790 --> 08:31.790
但是它没法主动发生给客户端

08:31.790 --> 08:32.790
对吧

08:32.790 --> 08:35.790
我们把它叫做服务器推

08:35.790 --> 08:36.790
推的技术

08:36.790 --> 08:38.790
就是服务器主动把消息推给客户端

08:38.790 --> 08:39.790
那么这东西

08:39.790 --> 08:41.790
你看Aggdp协议是不是很麻烦

08:41.790 --> 08:43.790
那么遇到这种实施性的问题

08:43.790 --> 08:44.790
Aggdp怎么解决呢

08:44.790 --> 08:45.790
怎么解决呢

08:45.790 --> 08:47.790
它有这么几种解决办法

08:47.790 --> 08:49.790
第一种叫轮巡

08:49.790 --> 08:50.790
什么叫轮巡呢

08:50.790 --> 08:51.790
轮巡就很简单

08:51.790 --> 08:53.790
我在客户端写个记者识

08:53.790 --> 08:54.790
用个什么CS-interval

08:54.790 --> 08:57.790
一秒钟向服务器发送一个请求

08:57.790 --> 08:58.790
消息变变变

08:58.790 --> 08:59.790
服务器说没变

08:59.790 --> 09:01.790
再过一秒钟一来

09:01.790 --> 09:02.790
消息变变变

09:02.790 --> 09:03.790
就是数据变变变

09:03.790 --> 09:04.790
服务器说没变

09:04.790 --> 09:05.790
第三次又来

09:05.790 --> 09:06.790
消息数据变变变

09:06.790 --> 09:07.790
服务器说

09:08.790 --> 09:09.790
那客户端介绍什么

09:09.790 --> 09:10.790
拿到新的数据

09:10.790 --> 09:11.790
用阿迦克斯请求

09:11.790 --> 09:12.790
轮巡

09:12.790 --> 09:14.790
拿到新的数据是不是更新界面

09:14.790 --> 09:15.790
对吧

09:15.790 --> 09:16.790
这是用轮巡的方式

09:16.790 --> 09:18.790
轮巡的方式会造成什么问题呢

09:18.790 --> 09:19.790
它会造成就是

09:19.790 --> 09:21.790
很多无用的询问

09:21.790 --> 09:22.790
因为服务器

09:22.790 --> 09:24.790
服务器可能没有变

09:24.790 --> 09:25.790
但是客户端不知道

09:25.790 --> 09:26.790
它只能一个个去问

09:26.790 --> 09:27.790
造成了很多的

09:27.790 --> 09:29.790
没有必要的连接

09:29.790 --> 09:30.790
每一次你看

09:30.790 --> 09:31.790
每一次请求服务器

09:31.790 --> 09:32.790
是不是都要建立连接

09:32.790 --> 09:33.790
然后来这个玩意儿

09:33.790 --> 09:34.790
然后断开

09:34.790 --> 09:35.790
对吧

09:35.790 --> 09:36.790
下一个过一秒钟

09:36.790 --> 09:37.790
又来

09:37.790 --> 09:38.790
又重新来一次

09:38.790 --> 09:39.790
对不对

09:39.790 --> 09:40.790
就是轮巡的方式

09:40.790 --> 09:41.790
这种方式

09:41.790 --> 09:42.790
很早的时候

09:42.790 --> 09:43.790
没办法

09:43.790 --> 09:45.790
用这种方式也有

09:45.790 --> 09:47.790
第二种是常链接

09:48.790 --> 09:50.790
常链接

09:50.790 --> 09:52.790
常链接是什么呢

09:52.790 --> 09:53.790
常链接是这样子

09:53.790 --> 09:54.790
就是我请求的时候

09:54.790 --> 09:55.790
带这么一个东西

09:55.790 --> 09:57.790
带这个Keeper Live

09:57.790 --> 09:58.790
Keeper Live只要一带过去

09:58.790 --> 10:00.790
只要一带过去

10:01.790 --> 10:02.790
只要带过去的话

10:02.790 --> 10:03.790
服务器它那边

10:03.790 --> 10:05.790
不会主动给你断开的

10:05.790 --> 10:06.790
它如果说

10:06.790 --> 10:07.790
没有完成想应的话

10:07.790 --> 10:09.790
它不会主动给你断开

10:09.790 --> 10:10.790
那么常链接的话

10:10.790 --> 10:12.790
而且浏览器的话

10:12.790 --> 10:13.790
它发现你请求的时候

10:13.790 --> 10:15.790
有这个消息头

10:15.790 --> 10:17.790
只要服务器那边不想应

10:17.790 --> 10:19.790
那么它也不会断开

10:19.790 --> 10:20.790
那么常链接

10:20.790 --> 10:21.790
就是说

10:21.790 --> 10:22.790
我举个例子

10:22.790 --> 10:23.790
我都是客户端

10:23.790 --> 10:24.790
我问服务器

10:24.790 --> 10:25.790
消息变变变

10:25.790 --> 10:26.790
服务器不更生

10:26.790 --> 10:28.790
它不给你想应

10:28.790 --> 10:29.790
那么客户端那边

10:29.790 --> 10:30.790
是不是一直等着

10:30.790 --> 10:31.790
一个阿迦克斯请求

10:31.790 --> 10:32.790
一直等

10:32.790 --> 10:33.790
它就不用去

10:33.790 --> 10:35.790
就一直等一直等一直等

10:35.790 --> 10:36.790
然后服务器那边

10:36.790 --> 10:37.790
有一天

10:37.790 --> 10:38.790
突然发现

10:38.790 --> 10:40.790
就是我们在第二步去卡住了

10:40.790 --> 10:41.790
服务器不给你想应

10:41.790 --> 10:42.790
就我们请求过去了

10:42.790 --> 10:44.790
服务器不给你想应

10:44.790 --> 10:45.790
一直不给你想应

10:45.790 --> 10:47.790
直到有一天服务器的数据变了

10:47.790 --> 10:49.790
才把之前那个想应给力

10:49.790 --> 10:51.790
这是常链接的模式

10:51.790 --> 10:52.790
那么这边

10:52.790 --> 10:53.790
然后客户端收到消息

10:53.790 --> 10:55.790
然后更新界面再断开

10:55.790 --> 10:56.790
然后客户端马上又来

10:56.790 --> 10:58.790
又来发出一个常�接

10:58.790 --> 11:00.790
又继续询问服务器

11:00.790 --> 11:01.790
现在又变变

11:01.790 --> 11:02.790
刚刚说服务器

11:02.790 --> 11:04.790
刚刚说我数据变了

11:04.790 --> 11:06.790
然后客户端马上又问他

11:06.790 --> 11:07.790
数据变变变

11:07.790 --> 11:09.790
然后服务器一说又卡着

11:09.790 --> 11:10.790
又等待

11:10.790 --> 11:11.790
等待等待等待等待

11:11.790 --> 11:12.790
等待完了过后

11:12.790 --> 11:14.790
那么告诉客户端

11:14.790 --> 11:16.790
就是数据变了

11:16.790 --> 11:18.790
客户端又更新数据

11:18.790 --> 11:19.790
更新数据

11:19.790 --> 11:21.790
然后又来发起这个东西

11:21.790 --> 11:22.790
常链接的

11:22.790 --> 11:23.790
它常为什么叫常链接

11:23.790 --> 11:24.790
它是卡在第二步

11:24.790 --> 11:26.790
服务器不给你想应

11:26.790 --> 11:27.790
客户端那边

11:27.790 --> 11:28.790
因为你带下这个东西

11:28.790 --> 11:29.790
带这个东西

11:29.790 --> 11:31.790
客户端只要没有收到想应

11:31.790 --> 11:32.790
客户端是不会断开的

11:32.790 --> 11:34.790
这是常链接这个模式

11:34.790 --> 11:36.790
当然也有可能会遇到一些

11:36.790 --> 11:37.790
其他情况

11:37.790 --> 11:39.790
比如说我突然不知道

11:39.790 --> 11:40.790
什么原因

11:40.790 --> 11:41.790
就是客户端断开了

11:41.790 --> 11:42.790
那么断开了过后

11:42.790 --> 11:44.790
客户端又会主动发送

11:44.790 --> 11:45.790
就这个意思

11:45.790 --> 11:46.790
常链接到要比轮旋

11:46.790 --> 11:47.790
要稍微好一点

11:47.790 --> 11:48.790
要稍微好一点

11:48.790 --> 11:49.790
但是呢

11:49.790 --> 11:50.790
对于服务器而言

11:50.790 --> 11:51.790
也不是很好

11:51.790 --> 11:52.790
因为什么呢

11:52.790 --> 11:53.790
一般来说

11:53.790 --> 11:54.790
常链接是要开进程的

11:54.790 --> 11:56.790
开线程至少开线程的

11:56.790 --> 11:58.790
这个线程会一直处于主色

11:58.790 --> 11:59.790
状态

11:59.790 --> 12:00.790
服务器的线程

12:00.790 --> 12:01.790
可以做

12:01.790 --> 12:02.790
直到数据变了

12:02.790 --> 12:03.790
我才重新启动这个线程

12:03.790 --> 12:05.790
然后给客户端认东西

12:05.790 --> 12:06.790
而且呢

12:06.790 --> 12:07.790
在程序设计上呢

12:07.790 --> 12:09.790
也不是那么好设计

12:09.790 --> 12:11.790
程序设计上也会遇到很多问题

12:11.790 --> 12:12.790
当然呢

12:12.790 --> 12:13.790
它也

12:13.790 --> 12:14.790
相比轮旋来稍微好一点

12:14.790 --> 12:15.790
毕竟连接的次数少了

12:15.790 --> 12:16.790
对吧

12:16.790 --> 12:17.790
轮旋来的太夸张了

12:17.790 --> 12:20.790
但是常链接还是会有连接次数

12:20.790 --> 12:21.790
额外的连接次数

12:21.790 --> 12:22.790
因为服务器

12:22.790 --> 12:24.790
因为我要始终询问服务器

12:24.790 --> 12:25.790
它变明变

12:25.790 --> 12:26.790
哪怕

12:26.790 --> 12:27.790
刚刚给我一个新的消息

12:27.790 --> 12:28.790
我又要从头开始

12:28.790 --> 12:29.790
马上要问服务器

12:29.790 --> 12:30.790
因为不知道服务器什么时候变

12:30.790 --> 12:31.790
马上要去问它

12:31.790 --> 12:32.790
变没变

12:32.790 --> 12:33.790
而且要把之前的

12:33.790 --> 12:35.790
我得到的消息告诉服务器

12:35.790 --> 12:36.790
或者是一个编号

12:36.790 --> 12:37.790
什么样子的东西

12:37.790 --> 12:38.790
告诉服务器

12:38.790 --> 12:39.790
服务器能够判断

12:39.790 --> 12:41.790
你这个问的东西

12:41.790 --> 12:42.790
我这个数据

12:42.790 --> 12:43.790
跟你的数据是不是一样的

12:43.790 --> 12:45.790
不一样就表示变

12:45.790 --> 12:46.790
都是常链接的模式

12:46.790 --> 12:48.790
这两种模式都不是很好

12:48.790 --> 12:49.790
于是呢

12:49.790 --> 12:51.790
AT5出来之后呢

12:51.790 --> 12:52.790
它

12:52.790 --> 12:54.790
搞出来一个API

12:54.790 --> 12:55.790
同时搞出来一个协议

12:55.790 --> 12:57.790
叫做WebSocket协议

12:57.790 --> 12:58.790
协议其实很早

12:58.790 --> 12:59.790
早于AT5

12:59.790 --> 13:01.790
只是当时没有

13:01.790 --> 13:03.790
客户上的支持嘛

13:03.790 --> 13:05.790
后来AT5过后呢

13:05.790 --> 13:06.790
就出来了一个

13:06.790 --> 13:08.790
基于WebSocket的协议

13:08.790 --> 13:09.790
API

13:09.790 --> 13:10.790
然后来搞定这个事

13:10.790 --> 13:12.790
实际上浏览器

13:12.790 --> 13:15.790
就Socket协议浏览器

13:15.790 --> 13:16.790
本身是支持的

13:16.790 --> 13:17.790
但是你不能用

13:17.790 --> 13:18.790
浏览器不给你提供接口

13:18.790 --> 13:19.790
它没有对这个东西

13:19.790 --> 13:20.790
自动处理的接口

13:20.790 --> 13:22.790
所以说你没法用它

13:22.790 --> 13:24.790
你开发者是没法用它的

13:24.790 --> 13:26.790
所以后来搞出一个WebSocket

13:26.790 --> 13:28.790
它就是建立在Socket协议

13:28.790 --> 13:29.790
这个也不是协议

13:29.790 --> 13:31.790
建立在这个东西基础上的

13:31.790 --> 13:35.360
咱们来看一下WebSocket

13:35.360 --> 13:38.360
WebSocket专门来解决有什么问题呢

13:38.360 --> 13:45.360
专门用于解决实实传输的问题

13:45.360 --> 13:46.360
刚才说了一个股票

13:46.360 --> 13:47.360
对吧

13:47.360 --> 13:48.360
其实还有很多情况

13:48.360 --> 13:50.360
比方说你的网页上

13:50.360 --> 13:52.360
网页上有个未读消息

13:52.360 --> 13:54.360
你真正的浏览网页

13:54.360 --> 13:56.360
突然弹出一个未读消息

13:56.360 --> 13:57.360
对吧

13:57.360 --> 13:59.360
未读消息如果说不需要实时的

13:59.360 --> 14:00.360
那么你可以用轮巡

14:00.360 --> 14:01.360
或者是长链接都可以

14:01.360 --> 14:03.360
比方说我一分钟轮巡

14:03.360 --> 14:05.360
是浮览器温一下浮览器

14:05.360 --> 14:06.360
一分钟还是行

14:06.360 --> 14:07.360
浮览器压力也不大

14:07.360 --> 14:09.360
温一下浮览器有没有新消息

14:09.360 --> 14:11.360
或者是用长链接

14:11.360 --> 14:13.360
温一下浮览器新消息就推过来

14:13.360 --> 14:14.360
但是呢

14:14.360 --> 14:16.360
如果说对实实性要求很高

14:16.360 --> 14:18.360
如果说马上有新消息

14:18.360 --> 14:19.360
马上要告诉我

14:19.360 --> 14:21.360
那么这两个模式都不是很合适

14:21.360 --> 14:23.360
那么最好的就是用WebSocket

14:23.360 --> 14:25.360
或者是比方说聊天

14:25.360 --> 14:27.360
应该是最起常见的实时常计

14:27.360 --> 14:28.360
我发送一个消息

14:28.360 --> 14:30.360
我不能让它等几秒才收到

14:30.360 --> 14:31.360
尽量尽快的收到消息

14:31.360 --> 14:32.360
那么这个时候

14:32.360 --> 14:33.360
在网页上聊天

14:33.360 --> 14:36.360
用WebSocket解决实时传输的问题

14:36.360 --> 14:38.360
那么这个东西它怎么解决的

14:38.360 --> 14:39.360
它是这样子

14:39.360 --> 14:41.360
第一步

14:41.360 --> 14:43.360
刻骨端一样的

14:43.360 --> 14:44.360
你看这三个东西

14:44.360 --> 14:45.360
第一步都是一样的

14:45.360 --> 14:46.360
建立连接

14:46.360 --> 14:47.360
同道必须要有

14:47.360 --> 14:48.360
没有同道的话

14:48.360 --> 14:49.360
哪去发送消息呢

14:49.360 --> 14:51.360
好 第二步

14:51.360 --> 14:52.360
第二步就不一样了

14:52.360 --> 14:54.360
刻骨端要主动

14:54.360 --> 15:00.360
发送一个atdp格式的消息

15:00.360 --> 15:01.360
这个消息

15:01.360 --> 15:02.360
它不是说用户制定的

15:02.360 --> 15:05.740
它是一个特殊格式

15:05.740 --> 15:06.740
特殊格式

15:06.740 --> 15:11.740
它叫做乘之为atdp握手

15:11.740 --> 15:12.740
你看我们之前有三次握手了

15:12.740 --> 15:14.740
它是tcpit协议的

15:14.740 --> 15:15.740
那么这一次

15:15.740 --> 15:17.740
我刻骨端要问

15:17.740 --> 15:18.740
跟服务器之间

15:18.740 --> 15:19.740
还要用一次握手

15:19.740 --> 15:20.740
那么这个握手

15:20.740 --> 15:21.740
表示什么意思呢

15:21.740 --> 15:23.740
表示说

15:23.740 --> 15:24.740
我是一个刻骨端

15:24.740 --> 15:27.740
我现在的连接通道已经建立了

15:27.740 --> 15:28.740
但是我不打算

15:28.740 --> 15:31.740
用传统的atdp协议给你通信

15:31.740 --> 15:34.740
那么我想问一下你

15:34.740 --> 15:35.740
你这个服务器

15:35.740 --> 15:37.740
能不能支持websocket

15:37.740 --> 15:38.740
就这么个意思

15:38.740 --> 15:39.740
那么但是我不确定

15:39.740 --> 15:41.740
你支不支持websocket

15:41.740 --> 15:42.740
所以说我只能给你发送

15:42.740 --> 15:44.740
一个atdp协议的格式的

15:44.740 --> 15:45.740
就带消息头

15:45.740 --> 15:46.740
带消息体的格式

15:46.740 --> 15:47.740
那么这个格式

15:47.740 --> 15:48.740
它只有消息头

15:48.740 --> 15:49.740
没有消息体

15:49.740 --> 15:50.740
通过一个消息头

15:50.740 --> 15:51.740
告诉服务器

15:51.740 --> 15:52.740
我现在想

15:52.740 --> 15:53.740
跟你进行websocket的通信

15:53.740 --> 15:55.740
那么我通过atdp协议的

15:55.740 --> 15:56.740
消息头告诉你

15:56.740 --> 15:57.740
那么你那边

15:57.740 --> 15:58.740
行不行你告诉我一声

15:58.740 --> 15:59.740
行的话我就开始

15:59.740 --> 16:00.740
行不行

16:00.740 --> 16:01.740
拉倒断开断了

16:01.740 --> 16:02.740
对吧

16:02.740 --> 16:03.740
那么这里

16:03.740 --> 16:04.740
称之为atdp握手

16:04.740 --> 16:05.740
那么这个时候

16:05.740 --> 16:06.740
发生一个atp格式的

16:06.740 --> 16:08.740
消息特殊格式

16:08.740 --> 16:09.740
然后服务器

16:09.740 --> 16:11.740
也想用

16:11.740 --> 16:14.740
一个atdp格式的消息

16:14.740 --> 16:15.740
也是一个特殊格式

16:15.740 --> 16:17.740
我们一会来讲这个特殊格式

16:18.740 --> 16:20.740
那么这个是称之为atdp握手

16:20.740 --> 16:21.740
如果说服务器

16:21.740 --> 16:22.740
不支持的话

16:22.740 --> 16:23.740
他们就给它想赢一个

16:23.740 --> 16:24.740
那个格式不满

16:24.740 --> 16:25.740
主要要求的都行

16:25.740 --> 16:27.740
那么客户上就知道了

16:27.740 --> 16:28.740
你不行

16:28.740 --> 16:29.740
你无法支持websocket

16:29.740 --> 16:30.740
所以websocket

16:30.740 --> 16:31.740
跟soccer的区别

16:31.740 --> 16:32.740
是不是多了这一步

16:32.740 --> 16:34.740
soccer建议连接过后就随便了

16:34.740 --> 16:35.740
就可以直接来玩了

16:35.740 --> 16:36.740
但是websocket

16:36.740 --> 16:37.740
还有这么一个东西

16:37.740 --> 16:38.740
双方要约定一下

16:38.740 --> 16:39.740
看知不知道是websocket

16:40.740 --> 16:41.740
好那么这是

16:41.740 --> 16:42.740
第二个区别

16:42.740 --> 16:43.740
好然后

16:43.740 --> 16:45.740
服务器就握手完成了

16:45.740 --> 16:46.740
握手完成了过后

16:46.740 --> 16:48.740
那么双方

16:50.740 --> 16:51.740
都不要断开

16:51.740 --> 16:52.740
也不一定

16:52.740 --> 16:54.740
如果说我没有什么可以通信的

16:54.740 --> 16:55.740
我就断开了

16:55.740 --> 16:57.740
那么第三步就是

16:57.740 --> 16:58.740
双方自由通信

16:59.740 --> 17:01.740
双方自由通信

17:01.740 --> 17:03.740
通信格式

17:03.740 --> 17:11.740
有按照websocket的要求进行

17:11.740 --> 17:13.740
就双方可以自由通信的

17:13.740 --> 17:14.740
服务器可以主动发送消息

17:14.740 --> 17:15.740
给客户端

17:15.740 --> 17:17.740
客户端也可以主动发送消息给服务器

17:17.740 --> 17:19.740
那么这个时候就没有atdp

17:19.740 --> 17:21.740
格式的限制了

17:21.740 --> 17:22.740
这个时候就没有限制了

17:22.740 --> 17:24.740
但是有websocket的格式限制

17:24.740 --> 17:26.740
按照他的要求进行

17:26.740 --> 17:27.740
那么你看

17:27.740 --> 17:29.740
那么最后就是任何一方断开

17:29.740 --> 17:31.740
后面就是一样的

17:31.740 --> 17:32.740
有一方断开了

17:32.740 --> 17:33.740
通道交汇

17:34.740 --> 17:36.740
好那么我们对比这个websocket

17:36.740 --> 17:38.740
跟atdp协议有什么区别

17:38.740 --> 17:39.740
区别在于

17:40.740 --> 17:41.740
websocket是不是

17:41.740 --> 17:43.740
一旦握手完成

17:43.740 --> 17:45.740
握手的时候是用atdp协议握手的

17:45.740 --> 17:47.740
完成一旦握手完成

17:47.740 --> 17:49.740
一旦握手完成是不是自由发送了

17:49.740 --> 17:51.740
他没有要求客户端主动发送

17:51.740 --> 17:53.740
服务器可以主动发送消息给客户端

17:53.740 --> 17:55.740
对不对

17:55.740 --> 17:57.740
这是跟atdp协议的区别

17:57.740 --> 17:59.740
那跟socket的这个东西的区别呢

17:59.740 --> 18:01.740
websocket首先是

18:01.740 --> 18:02.740
他本身干战上有区别

18:02.740 --> 18:03.740
websocket是协议

18:03.740 --> 18:04.740
这个玩意不是协议

18:04.740 --> 18:05.740
这个玩意是一个抽象程

18:05.740 --> 18:06.740
一个接口

18:06.740 --> 18:07.740
抽象接口

18:08.740 --> 18:09.740
他们还有什么区别呢

18:09.740 --> 18:10.740
就是说socket的这种方式呢

18:10.740 --> 18:11.740
他可以

18:11.740 --> 18:12.740
就是在第二步的时候

18:12.740 --> 18:13.740
年纪渐量过后

18:13.740 --> 18:14.740
就直接发送消息了

18:14.740 --> 18:16.740
websocket是不是有一次握手

18:16.740 --> 18:17.740
对吧

18:17.740 --> 18:18.740
还有什么呢

18:18.740 --> 18:19.740
socket这个东西

18:19.740 --> 18:20.740
他发送的消息格式是没有任何限制的

18:20.740 --> 18:22.740
websocket是有格式限制的

18:22.740 --> 18:24.740
他要按照他的要求进行

18:24.740 --> 18:25.740
不过他的限制比较复杂

18:25.740 --> 18:26.740
以后我们提一句就行了

18:26.740 --> 18:28.740
他就是websocket

18:28.740 --> 18:29.740
好了

18:29.740 --> 18:30.740
那么我们知道websocket之后

18:30.740 --> 18:32.740
我们可以来

18:32.740 --> 18:34.740
写一些证

18:34.740 --> 18:35.740
其实我们平时

18:35.740 --> 18:36.740
如果说真的要在项目里面

18:36.740 --> 18:37.740
使用websocket

18:37.740 --> 18:38.740
我们一定会用第三张库

18:38.740 --> 18:39.740
这是毫无疑问的

18:39.740 --> 18:40.740
如果说

18:40.740 --> 18:41.740
因为你手写websocket的话

18:41.740 --> 18:42.740
是非常麻烦

18:42.740 --> 18:43.740
非常非常麻烦

18:43.740 --> 18:45.740
当我这里在这一颗讲原理的

18:45.740 --> 18:47.740
我给大家写一下

18:47.740 --> 18:48.740
给大家写一下

18:48.740 --> 18:50.740
写个意思就行了

18:50.740 --> 18:56.880
比方说我在这里呢

18:56.880 --> 18:58.880
我看一下我按到什么东西

18:58.880 --> 19:01.880
这个不要

19:01.880 --> 19:02.880
那么现在呢

19:02.880 --> 19:03.880
我按到这个express

19:03.880 --> 19:05.880
其实express也可以不要

19:05.880 --> 19:07.880
这个东西没什么关系

19:07.880 --> 19:08.880
没什么关系

19:08.880 --> 19:10.880
loadman保留吧

19:10.880 --> 19:11.880
那么我们这里呢

19:11.880 --> 19:12.880
可以这样子

19:12.880 --> 19:13.880
我这里呢

19:13.880 --> 19:17.900
建议一个静态页面

19:18.900 --> 19:20.900
我们看一下客户端

19:20.900 --> 19:22.900
客户端怎么来发送一个

19:22.900 --> 19:23.900
socket的消息

19:23.900 --> 19:24.900
因为我们看到一个原理

19:24.900 --> 19:26.900
这个原理的话是

19:26.900 --> 19:28.900
首先是客户端连接服务器

19:28.900 --> 19:30.900
还是连接的话

19:30.900 --> 19:32.900
肯定是要客户端主动连接服务器

19:32.900 --> 19:34.900
这个连接必须要这样子

19:34.900 --> 19:35.900
那么我们这里呢

19:35.900 --> 19:37.900
怎么来连接服务器呢

19:37.900 --> 19:38.900
实际上ATM5之后呢

19:38.900 --> 19:39.900
它给你提供了

19:39.900 --> 19:41.900
客户端这边就浏览器的这一端

19:41.900 --> 19:42.900
它本身就给你提供了接口

19:42.900 --> 19:43.900
就叫做websocket的接口

19:43.900 --> 19:45.900
就叫做websocket的接口

19:45.900 --> 19:46.900
咱们来看一下吧

19:46.900 --> 19:48.900
怎么来写客户端的咱们

19:48.900 --> 19:49.900
客户端

19:49.900 --> 19:50.900
就是浏览器

19:51.900 --> 19:52.900
浏览器

19:53.900 --> 19:54.900
websocket

19:55.900 --> 19:56.900
那怎么写呢

19:56.900 --> 19:57.900
我们这里呢

19:57.900 --> 20:01.100
首先建议一个

20:01.100 --> 20:02.100
另一个

20:02.100 --> 20:04.100
叫websocket

20:04.100 --> 20:05.100
另一个

20:05.100 --> 20:06.100
这里连接地址

20:06.100 --> 20:07.100
连接地址呢

20:07.100 --> 20:08.100
我们就约定好了

20:08.100 --> 20:09.100
连接地址

20:09.100 --> 20:10.100
我们写意呢

20:10.100 --> 20:12.100
一般就是WS

20:12.100 --> 20:14.100
WS就是websocket的写意

20:14.100 --> 20:15.100
表示websocket的写意

20:15.100 --> 20:16.100
我们之前的ATTP

20:16.100 --> 20:17.100
WSS呢

20:17.100 --> 20:18.100
就是外面套了一个

20:18.100 --> 20:19.100
SSL传输写意

20:19.100 --> 20:22.100
就是跟ATTP-S那一式

20:22.100 --> 20:24.100
回忆一下ATTP-S嘛

20:24.100 --> 20:26.100
就跟这个东西要加密传输

20:26.100 --> 20:27.100
其他都没上

20:27.100 --> 20:28.100
我们这里呢

20:28.100 --> 20:30.100
没法加密传输

20:30.100 --> 20:32.100
我们这里localhost

20:32.100 --> 20:33.100
比方说

20:33.100 --> 20:34.100
还是5008吗

20:34.100 --> 20:36.100
还是5008

20:36.100 --> 20:37.100
我们到这儿

20:37.100 --> 20:38.100
好

20:38.100 --> 20:39.100
那么这样子呢

20:39.100 --> 20:41.100
是不是就连接就发脱去了

20:41.100 --> 20:44.100
这其实就连接就发脱去了

20:44.100 --> 20:45.100
就是这句话呢

20:45.100 --> 20:48.100
就是创建一个websocket

20:48.100 --> 20:49.100
就代码上的意思呢

20:49.100 --> 20:51.100
就是创建一个websocket

20:51.100 --> 20:55.100
同时发送连接

20:55.100 --> 20:58.100
连接到服务器

20:58.100 --> 21:00.100
就在这儿发送连接到服务器

21:00.100 --> 21:02.100
他这句话

21:02.100 --> 21:03.100
好像会完成两件事

21:03.100 --> 21:05.100
第一件事三次握手

21:05.100 --> 21:06.100
通道建议

21:06.100 --> 21:07.100
第二件事就是这个东西

21:07.100 --> 21:09.100
他也会主动给你发过去

21:09.100 --> 21:10.100
主动给你发过去

21:10.100 --> 21:11.100
总之

21:11.100 --> 21:12.100
发送到服务器

21:13.100 --> 21:15.100
这边他就会提供很多事件

21:15.100 --> 21:16.100
如果说你要关闭的话

21:16.100 --> 21:17.100
你就调用close

21:17.100 --> 21:19.100
就是客户端主动关闭

21:19.100 --> 21:25.100
这是客户端主动断开连接

21:25.100 --> 21:26.100
当然也如果说

21:26.100 --> 21:27.100
你需要断开的话断开

21:27.100 --> 21:28.100
也不需要断开

21:28.100 --> 21:29.100
你不要断开

21:29.100 --> 21:30.100
就这么个意思

21:30.100 --> 21:31.100
那么这里呢

21:31.100 --> 21:33.100
它里边有很多事件

21:33.100 --> 21:38.480
叫做open

21:38.480 --> 21:41.480
unopen

21:42.480 --> 21:43.480
unopen

21:43.480 --> 21:44.480
他也可以用这种方式

21:44.480 --> 21:45.480
add一本是nissan的

21:45.480 --> 21:46.480
这里open

21:46.480 --> 21:47.480
都一样

21:47.480 --> 21:49.480
他也可以用unopen

21:49.480 --> 21:53.480
就是当连接被打开时

21:53.480 --> 21:57.480
连接已建立

21:57.480 --> 21:58.480
那么这个事件

21:58.480 --> 21:59.480
是什么时候发生的呢

21:59.480 --> 22:01.480
它是这个时候发生

22:01.480 --> 22:02.480
三次握手完成

22:02.480 --> 22:03.480
客户端发送了一个消息

22:03.480 --> 22:04.480
到服务器

22:04.480 --> 22:05.480
一个特殊格式的消息

22:05.480 --> 22:06.480
到服务器

22:06.480 --> 22:07.480
服务器也响应了

22:07.480 --> 22:08.480
一个特殊格式的消息

22:08.480 --> 22:09.480
那么这个完成了

22:09.480 --> 22:10.480
就是这个握手

22:10.480 --> 22:11.480
attp握手完成

22:11.480 --> 22:13.480
attp握手完成过后

22:13.480 --> 22:15.480
出发这个事件

22:15.480 --> 22:19.480
这是attp握手完成

22:19.480 --> 22:21.480
那么连接建立

22:21.480 --> 22:23.480
然后wshunclose

22:23.480 --> 22:24.480
这个玩意是什么呢

22:24.480 --> 22:27.480
就是有任何一帮主动完毕

22:27.480 --> 22:31.480
通道完毕

22:31.480 --> 22:32.480
这是这个

22:32.480 --> 22:34.480
那么中间这个过程

22:34.480 --> 22:36.480
如何来给服务器发送消息

22:36.480 --> 22:38.480
如何来收到服务器的消息呢

22:39.480 --> 22:40.480
onmessage

22:40.480 --> 22:42.480
这个玩意是收到服务器消息

22:42.480 --> 22:43.480
这里有个事件参数

22:43.480 --> 22:44.480
e

22:44.480 --> 22:45.480
e里边有个什么呢

22:45.480 --> 22:47.480
有一个data

22:47.480 --> 22:48.480
好像叫data

22:48.480 --> 22:50.480
我查一下文章吧

22:50.480 --> 22:51.480
我还真忘了

22:52.480 --> 22:53.480
看一下吧

22:53.480 --> 22:54.480
web

22:54.480 --> 22:55.480
sockets

22:55.480 --> 22:56.480
mdn

22:56.480 --> 22:58.480
将这些东西也接口就忘了

22:58.480 --> 22:59.480
没事

22:59.480 --> 23:00.480
你把原理记住

23:00.480 --> 23:01.480
接口忘了

23:03.480 --> 23:04.480
点这个

23:04.480 --> 23:05.480
看一下吧

23:05.480 --> 23:07.480
肯定有时间的吧

23:07.480 --> 23:08.480
onmessage

23:08.480 --> 23:09.480
onmessage

23:09.480 --> 23:11.480
e

23:11.480 --> 23:13.480
他们给你说

23:13.480 --> 23:15.860
他们又给你说

23:15.860 --> 23:16.860
message

23:16.860 --> 23:18.860
要有一个e

23:18.860 --> 23:21.810
message

23:21.810 --> 23:22.810
这个对象

23:22.810 --> 23:23.810
这个对象

23:23.810 --> 23:24.810
data

23:24.810 --> 23:25.810
data

23:25.810 --> 23:27.810
那么就是收到了数据

23:27.810 --> 23:32.310
来自服务器的数据

23:33.310 --> 23:34.310
一点data

23:34.310 --> 23:38.620
这是可以从服务器收数据

23:38.620 --> 23:39.620
就用这个时间

23:39.620 --> 23:40.620
我再说一次

23:40.620 --> 23:41.620
这些课本就体验一下

23:41.620 --> 23:42.620
以后我们真正去写

23:42.620 --> 23:43.620
我也不收据的话

23:43.620 --> 23:44.620
一定是用第三方库

23:45.620 --> 23:46.620
这是这个

23:46.620 --> 23:48.620
如果主动发送数据到服务器

23:48.620 --> 23:49.620
如何主动发送

23:49.620 --> 23:50.620
比方说这里写个按钮

23:53.620 --> 23:56.620
发送数据到服务器

23:56.620 --> 23:57.620
比方说我们这里

23:58.620 --> 23:59.620
注册时间

23:59.620 --> 24:00.620
document

24:02.620 --> 24:03.620
onclick

24:03.620 --> 24:04.620
点击按钮的时候

24:04.620 --> 24:05.620
我们发送一个数据到服务器

24:05.620 --> 24:06.620
怎么发送的

24:06.620 --> 24:07.620
非常简单

24:08.620 --> 24:09.620
就是数据

24:09.620 --> 24:10.620
数据可以是

24:10.620 --> 24:11.620
data

24:11.620 --> 24:12.620
array buffer

24:14.620 --> 24:15.620
array buffer view

24:15.620 --> 24:16.620
这些能够见过的对不对

24:16.620 --> 24:17.620
那么我们这里

24:17.620 --> 24:18.620
send发送一个

24:18.620 --> 24:19.620
比方说发送一个

24:20.620 --> 24:21.620
发送到服务器

24:22.620 --> 24:23.620
这就是客户端的鞋

24:23.620 --> 24:24.620
你看客户端是不是完成了

24:24.620 --> 24:25.620
对吧

24:25.620 --> 24:26.620
打开的时候有些时候可以干

24:26.620 --> 24:28.620
关闭的时候有些时候可以干

24:28.620 --> 24:29.620
然后我们可以主动关闭

24:29.620 --> 24:30.620
某些时候

24:30.620 --> 24:31.620
我们觉得没有必要跟服务器

24:31.620 --> 24:33.620
同心就关闭了

24:33.620 --> 24:35.620
然后来自服务器的销

24:35.620 --> 24:36.620
服务器给我发出奥鞋

24:36.620 --> 24:38.620
我就可以在这个回掉函数里面收到

24:38.620 --> 24:40.620
当然我也可以主动发销器给服务器

24:40.620 --> 24:41.620
对吧

24:41.620 --> 24:42.620
客户端是不是完成了

24:42.620 --> 24:43.620
然后我们再来写服务器

24:43.620 --> 24:44.620
好

24:44.620 --> 24:45.620
再来写服务器的时候

24:45.620 --> 24:46.620
我们可以用

24:46.620 --> 24:47.620
怎么来写呢

24:47.620 --> 24:48.620
可以用类似模块来写吧

24:48.620 --> 24:49.620
好吧

24:49.620 --> 24:50.620
我们可以用类似模块来写

24:51.620 --> 24:52.620
类似

24:52.620 --> 24:53.620
quare

24:53.620 --> 24:54.620
类似

24:54.620 --> 24:55.620
还清的吗

24:55.620 --> 24:56.620
我都一点忘了

24:57.620 --> 24:58.620
crease

24:59.620 --> 25:01.620
创建一个服务器

25:01.620 --> 25:02.620
这里有个lesson

25:02.620 --> 25:03.620
lesson的过后有socket

25:03.620 --> 25:04.620
对吧

25:05.620 --> 25:06.620
类似我们一看

25:06.620 --> 25:07.620
我们之前做的

25:07.620 --> 25:09.620
就是这个地方的时候

25:09.620 --> 25:10.620
socket的时候

25:10.620 --> 25:11.620
是不是就是用类

25:11.620 --> 25:12.620
你看啊

25:12.620 --> 25:13.620
这个socket的东西

25:13.620 --> 25:14.620
抽象接口

25:14.620 --> 25:16.620
你看是不是理论上可以做任何事情

25:16.620 --> 25:18.620
什么可以用它来搭一个ttp服务器

25:18.620 --> 25:19.620
对吧

25:19.620 --> 25:20.620
因为ttp服务器还是用的是

25:20.620 --> 25:22.620
本底层还是用的是个socket

25:22.620 --> 25:24.620
还是用的这个抽象接口

25:24.620 --> 25:25.620
为了socket什么事

25:25.620 --> 25:26.620
也可以用它来搭

25:26.620 --> 25:27.620
对吧

25:27.620 --> 25:28.620
它就是在传输消息的

25:28.620 --> 25:29.620
对不对

25:29.620 --> 25:30.620
只不过消息口是有要求而已

25:30.620 --> 25:31.620
好

25:31.620 --> 25:32.620
那么我们这里

25:32.620 --> 25:33.620
crease server

25:33.620 --> 25:36.830
得到一个server

25:36.830 --> 25:37.830
server

25:38.830 --> 25:39.830
就是什么

25:39.830 --> 25:40.830
lesson

25:40.830 --> 25:41.830
5008

25:42.830 --> 25:43.830
5008

25:44.830 --> 25:45.830
好

25:45.830 --> 25:47.830
那么只要客户端给我发一个消息过来

25:47.830 --> 25:49.830
是不是就运行这个毁掉函数

25:49.830 --> 25:50.830
对不对

25:50.830 --> 25:51.830
发一个连接过来

25:51.830 --> 25:53.830
客户端只要有个连接过来

25:53.830 --> 25:54.830
有客户端

25:54.830 --> 26:01.300
就收到客户端的连接

26:02.300 --> 26:03.300
客户端连接过来

26:03.300 --> 26:04.300
是不是会运行这个

26:04.300 --> 26:05.300
对不对

26:05.300 --> 26:06.300
好

26:06.300 --> 26:07.300
咱们这里打开一个中端

26:11.210 --> 26:12.210
好

26:12.210 --> 26:13.210
那么现在呢

26:13.210 --> 26:15.210
我们这里的npm

26:15.210 --> 26:16.210
start

26:17.210 --> 26:18.210
好你看

26:18.210 --> 26:20.210
现在我们一个服务器运行起来了

26:20.210 --> 26:21.210
那么客户端那边

26:21.210 --> 26:22.210
我就直接用这个

26:22.210 --> 26:23.210
level 12

26:23.210 --> 26:24.210
vscode的插件发文了

26:24.210 --> 26:25.210
就在另一个域里面发文

26:26.210 --> 26:27.210
你看一下

26:28.210 --> 26:29.210
我们这边肯定

26:30.210 --> 26:31.210
看一下这边

26:31.210 --> 26:32.210
是不是收到客户端连接了

26:32.210 --> 26:33.210
对吧

26:33.210 --> 26:34.210
为什么有客户端连接

26:34.210 --> 26:35.210
因为这个地方

26:35.210 --> 26:36.210
客户端的这个地方

26:37.210 --> 26:38.210
就这个玩意

26:38.210 --> 26:39.210
是不是给我发个连接过来

26:39.210 --> 26:40.210
再对比这个原地

26:41.210 --> 26:42.210
我们这里客户端

26:42.210 --> 26:43.210
调用这个函数的时候

26:43.210 --> 26:44.210
是不是要首先电一个tcp 按机

26:44.210 --> 26:45.210
30握手

26:45.210 --> 26:46.210
现在30握手已经完成了

26:46.210 --> 26:47.210
那么客户端那边给我发了一个

26:47.210 --> 26:48.210
tdp格式的消息

26:48.210 --> 26:49.210
对吧

26:49.210 --> 26:50.210
是个特殊格式的消息

26:50.210 --> 26:51.210
但是服务器呢

26:51.210 --> 26:52.210
这有干想意吗

26:52.210 --> 26:53.210
没有干想意任何东西

26:53.210 --> 26:54.210
所以说

26:54.210 --> 26:55.210
现在客户端那边

26:55.210 --> 26:56.210
就一直在那里撒等

26:56.210 --> 26:57.210
你看一下那次我可能

26:57.210 --> 26:58.210
说你刷新一次

26:59.210 --> 27:00.210
你看这个

27:00.210 --> 27:01.210
我们这里

27:02.210 --> 27:03.210
我们把ws打开

27:03.210 --> 27:04.210
这是vscode的协议

27:06.210 --> 27:07.210
下面这个是哪呢

27:07.210 --> 27:09.210
下面这个是个调试工具

27:09.210 --> 27:10.210
这个vscode跟我们讲的

27:10.210 --> 27:11.210
不用管

27:11.210 --> 27:12.210
那么这个

27:12.210 --> 27:13.210
六合号式

27:13.210 --> 27:14.210
这是我们发的

27:14.210 --> 27:15.210
对不对

27:15.210 --> 27:16.210
你看一下

27:16.210 --> 27:17.210
发了一个什么过去

27:17.210 --> 27:18.210
是不是发了一个

27:18.210 --> 27:19.210
普通的tdp请求过去

27:19.210 --> 27:20.210
对吧

27:20.210 --> 27:21.210
你看是不是有消息头

27:21.210 --> 27:22.210
这个时候是什么时候

27:22.210 --> 27:23.210
这个时候就在这

27:24.210 --> 27:25.210
发了一个tdp

27:25.210 --> 27:26.210
30握手建立的

27:26.210 --> 27:28.210
然后tdp消息格式

27:28.210 --> 27:29.210
特殊的可消息格式发过去了

27:29.210 --> 27:30.210
我们来看一下

27:30.210 --> 27:31.210
特殊消息格式

27:31.210 --> 27:32.210
它怎么

27:32.210 --> 27:33.210
为什么不是一个普

27:33.210 --> 27:34.210
跟普通的tdp格式

27:34.210 --> 27:35.210
有什么区别呢

27:35.210 --> 27:36.210
第一

27:36.210 --> 27:37.210
它没有消息体

27:37.210 --> 27:38.210
对不对

27:38.210 --> 27:39.210
而且它是个介绍请求

27:39.210 --> 27:41.210
它没有消息体

27:41.210 --> 27:42.210
然后呢

27:42.210 --> 27:43.210
它里边多了一个东西

27:44.210 --> 27:45.210
叫upgrade

27:45.210 --> 27:46.210
叫做connection

27:46.210 --> 27:47.210
连接方式

27:47.210 --> 27:49.210
把它变成upgrade的升级版

27:50.210 --> 27:51.210
升到什么版本呢

27:51.210 --> 27:52.210
upgrade的

27:52.210 --> 27:53.210
升到websocket的版本

27:54.210 --> 27:55.210
就把这个

27:55.210 --> 27:56.210
就这两个消息非常关键

27:56.210 --> 27:57.210
把这两个消息

27:57.210 --> 27:58.210
到底带给服务器

27:58.210 --> 27:59.210
服务器看

27:59.210 --> 28:00.210
原来你想给我建立

28:00.210 --> 28:01.210
socket的连接

28:01.210 --> 28:02.210
就这么个意思

28:03.210 --> 28:04.210
明白吧

28:04.210 --> 28:05.210
那么我们这个服务器

28:05.210 --> 28:06.210
就假设都是socket的连接

28:07.210 --> 28:08.210
好那么服务器

28:08.210 --> 28:09.210
这边是不是该响应了

28:09.210 --> 28:10.210
不然的话

28:10.210 --> 28:11.210
一直在那里

28:11.210 --> 28:12.210
你看这些的状态

28:12.210 --> 28:13.210
pending

28:13.210 --> 28:14.210
一直在挂起

28:14.210 --> 28:15.210
等待服务器

28:15.210 --> 28:16.210
服务器到底值不值得

28:16.210 --> 28:17.210
你告诉我一声吗

28:17.210 --> 28:18.210
对不对

28:18.210 --> 28:19.210
那么这里的服务器要响应了

28:20.210 --> 28:21.210
响应了

28:21.210 --> 28:22.210
那么服务器怎么响应呢

28:23.210 --> 28:24.210
首先呢

28:24.210 --> 28:25.210
我们来看一下

28:25.210 --> 28:26.210
收到客户端连接过后

28:26.210 --> 28:27.210
我们这里可以用socket

28:27.210 --> 28:28.210
我们

28:28.210 --> 28:29.210
因为它是个流

28:29.210 --> 28:30.210
我们是不是可以读到

28:30.210 --> 28:32.210
读到客户端的消息

28:32.210 --> 28:34.210
那么这一次呢

28:34.210 --> 28:35.210
我们就读一次

28:35.210 --> 28:36.210
开始读一次

28:36.210 --> 28:37.210
为什么读一次呢

28:37.210 --> 28:38.210
因为这个

28:38.210 --> 28:41.210
这个消息是比较特殊的

28:41.210 --> 28:42.210
就是连接过后

28:42.210 --> 28:43.210
马上就建立

28:43.210 --> 28:44.210
连接过后就马上就发

28:44.210 --> 28:45.210
发一次就完事了

28:45.210 --> 28:47.210
所以我们读一次就完事了

28:48.210 --> 28:49.210
好那么这边

28:49.210 --> 28:50.210
我们读什么

28:50.210 --> 28:51.210
data实现

28:51.210 --> 28:52.210
data实现

28:52.210 --> 28:53.210
那么后边

28:53.210 --> 28:55.210
是不是有数据

28:55.210 --> 28:56.210
对不对

28:56.210 --> 28:58.210
我们把它创可

28:59.210 --> 29:00.210
我们输出一下这个创可

29:00.210 --> 29:03.210
把它转成UTF-8

29:03.210 --> 29:04.210
你看一下

29:05.210 --> 29:07.210
我们这里再来刷新

29:07.210 --> 29:09.210
刷新你看服务器

29:09.210 --> 29:10.210
服务器收到了

29:10.210 --> 29:12.210
收到了数据说这个数据

29:12.210 --> 29:14.210
这个数据说就是请求投

29:14.210 --> 29:15.210
换了两行

29:15.210 --> 29:16.210
换了两行请求体是空的

29:16.210 --> 29:17.210
对不对

29:17.210 --> 29:18.210
就ATB协议发过来了

29:18.210 --> 29:19.210
盖着请求

29:19.210 --> 29:21.210
请求的是这个跟路径

29:21.210 --> 29:22.210
然后了这个玩意

29:22.210 --> 29:23.210
对不对

29:23.210 --> 29:25.210
那么这里边有

29:25.210 --> 29:27.210
一个是叫做

29:27.210 --> 29:28.210
我们干脆把它

29:28.210 --> 29:30.210
要不然把它转成对象

29:30.210 --> 29:32.210
要不然把它转成对象

29:32.210 --> 29:33.210
要不然的话这个东西

29:33.210 --> 29:34.210
看起来太不好看了

29:34.210 --> 29:35.210
我们来转一下吧

29:35.210 --> 29:36.210
这是一个置物串吧

29:36.210 --> 29:37.210
对不对

29:37.210 --> 29:38.210
这是Headers

29:38.210 --> 29:40.210
这是一个Message

29:40.210 --> 29:43.900
从客户端来的

29:43.900 --> 29:44.900
ADP

29:44.900 --> 29:45.900
ADP

29:45.900 --> 29:47.900
ADP content

29:47.900 --> 29:48.900
整个ADP内容

29:48.900 --> 29:49.900
我们来转一下

29:50.900 --> 29:51.900
置物串split

29:51.900 --> 29:52.900
首先按照一个

29:52.900 --> 29:53.900
GangR,GangN

29:53.900 --> 29:54.900
分割就分割成多行了

29:54.900 --> 29:55.900
对吧

29:55.900 --> 29:57.900
分割过后了

29:57.900 --> 29:58.900
看一下

29:58.900 --> 29:59.900
那么就是

29:59.900 --> 30:00.900
每一行

30:00.900 --> 30:02.900
是一个数据的一项

30:02.900 --> 30:03.900
对不对

30:04.900 --> 30:05.900
咱们去

30:06.900 --> 30:07.900
去掉数据的第一项

30:07.900 --> 30:08.900
好吧

30:08.900 --> 30:09.900
我们去掉数据的第一项

30:09.900 --> 30:10.900
我们这里用个

30:10.900 --> 30:11.900
遍量保存一下

30:12.900 --> 30:13.900
part

30:14.900 --> 30:16.900
然后我们去掉数据的第一项

30:16.900 --> 30:17.900
parts

30:17.900 --> 30:18.900
shift

30:21.220 --> 30:22.220
去掉了第一项

30:22.220 --> 30:23.220
过后

30:23.220 --> 30:25.220
后边还有两个空行

30:25.220 --> 30:26.220
我们把空行

30:26.220 --> 30:27.220
然后再去掉

30:28.220 --> 30:29.220
filter

30:30.220 --> 30:31.220
这些东西就是

30:31.220 --> 30:33.220
按照数据的操作来做吧

30:35.220 --> 30:36.220
把空行

30:36.220 --> 30:37.220
空行的话

30:37.220 --> 30:38.220
就是我们只保留

30:38.220 --> 30:39.220
部位空的行

30:39.220 --> 30:40.220
然后

30:40.220 --> 30:41.220
再按

30:41.220 --> 30:42.220
把每一个

30:42.220 --> 30:44.220
再分割一下

30:45.220 --> 30:46.220
再

30:46.220 --> 30:47.220
看怎么弄

30:49.220 --> 30:50.220
把每一个

30:50.220 --> 30:51.220
变成

30:51.220 --> 30:52.220
每一行

30:52.220 --> 30:53.220
又变成一个数据

30:53.220 --> 30:55.220
每一行又变成个数据

30:55.220 --> 30:56.220
然后用map

30:57.220 --> 30:58.220
把每一行

30:58.220 --> 30:59.220
按照帽号来分割

30:59.220 --> 31:00.220
split

31:01.220 --> 31:02.220
split

31:02.220 --> 31:03.220
你们自取搞定吧

31:03.220 --> 31:04.220
反正就是这么个意思

31:05.220 --> 31:07.220
按照帽号来分割

31:07.220 --> 31:08.220
分割完了过后

31:08.220 --> 31:09.220
又是一个数据

31:09.220 --> 31:10.220
有两项

31:10.220 --> 31:11.220
把这个数据的两项的

31:11.220 --> 31:13.220
守卫空格去掉

31:14.220 --> 31:15.220
然后再用map

31:16.220 --> 31:18.220
把守卫空格去掉

31:18.220 --> 31:19.220
去

31:20.220 --> 31:21.220
OK

31:21.220 --> 31:22.220
然后看一下

31:22.220 --> 31:23.220
目前是什么样子

31:24.220 --> 31:25.220
parts

31:26.220 --> 31:28.220
看一下目前是什么样子

31:28.220 --> 31:29.220
输出parts

31:31.220 --> 31:32.220
好了

31:32.220 --> 31:33.220
我们这里呢

31:33.220 --> 31:34.220
进攻

31:34.220 --> 31:35.220
刷新

31:36.220 --> 31:37.220
这边

31:37.220 --> 31:38.220
诶

31:39.220 --> 31:41.220
怎么只有两个空行呢

31:41.220 --> 31:42.220
哎呀

31:43.220 --> 31:44.220
不尾空

31:44.220 --> 31:46.220
我们只保留了一些不尾空的

31:46.220 --> 31:48.220
然后我先把这个

31:48.220 --> 31:49.220
这个去掉

31:49.220 --> 31:52.660
看哪里出了问题

31:52.660 --> 31:53.660
刷新

31:54.660 --> 31:56.660
怎么还是只有两个呢

31:57.660 --> 31:58.660
split

31:59.660 --> 32:01.660
然后我把这个

32:01.660 --> 32:02.660
这个这一行也去掉

32:02.660 --> 32:03.660
我看一下吧

32:03.660 --> 32:05.660
我写的应该是没问题

32:05.660 --> 32:07.660
应该是前面有出了问题

32:07.660 --> 32:08.660
刷新

32:09.660 --> 32:11.660
分割成这个数据

32:11.660 --> 32:12.660
然后呢

32:12.660 --> 32:13.660
filter应该是出问题了

32:13.660 --> 32:14.660
是吧

32:14.660 --> 32:15.660
filter

32:15.660 --> 32:16.660
filter

32:16.660 --> 32:17.660
我不尾空

32:17.660 --> 32:18.660
都要这样

32:19.660 --> 32:20.660
哦

32:20.660 --> 32:21.660
不尾空应该是这个

32:21.660 --> 32:22.660
啊

32:22.660 --> 32:23.660
不尾空应该是这个

32:23.660 --> 32:24.660
好

32:24.660 --> 32:25.660
再来啊

32:25.660 --> 32:26.660
好

32:26.660 --> 32:27.660
刷新

32:27.660 --> 32:28.660
这边

32:28.660 --> 32:29.660
好

32:29.660 --> 32:30.660
你看分割成这样子了

32:30.660 --> 32:31.660
看到没

32:31.660 --> 32:33.660
输主里面每一项又是个输主

32:33.660 --> 32:34.660
输主的

32:35.660 --> 32:36.660
host

32:36.660 --> 32:37.660
哦

32:37.660 --> 32:41.660
我只分我只按照第1个冒号来分割

32:41.660 --> 32:42.660
是吧

32:42.660 --> 32:43.660
哎呦

32:43.660 --> 32:44.660
不能不能按冒号分割

32:44.660 --> 32:45.660
因为他有可能多个冒号

32:45.660 --> 32:47.660
我们要得到第1个冒号

32:47.660 --> 32:49.660
index

32:49.660 --> 32:51.660
我们这里写一个写一个

32:51.660 --> 32:52.660
写这样的写吧

32:52.660 --> 32:54.660
就看怎么弄吧

32:54.660 --> 32:55.660
反正总之呢

32:55.660 --> 32:56.660
把它搞定就行了

32:56.660 --> 32:57.660
冒号的位置

32:57.660 --> 32:58.660
啊

32:58.660 --> 32:59.660
冒号的位置

32:59.660 --> 33:00.660
然后呢

33:00.660 --> 33:01.660
我得到一个输主

33:01.660 --> 33:02.660
为他

33:03.660 --> 33:04.660
输主

33:04.660 --> 33:06.660
s sub stream

33:07.660 --> 33:08.660
呃

33:08.660 --> 33:11.660
0开始取到多少呢

33:11.660 --> 33:12.660
长度为

33:12.660 --> 33:13.660
i

33:13.660 --> 33:18.220
然后第二呢是sub stream

33:18.220 --> 33:19.220
从

33:19.220 --> 33:20.220
i开始

33:20.220 --> 33:22.220
长就取完

33:22.220 --> 33:23.220
好

33:23.220 --> 33:24.220
保存啊

33:24.220 --> 33:25.220
咱们又来看

33:25.220 --> 33:26.220
反正一下要试嘛

33:26.220 --> 33:28.220
我们回版动去了就完事了

33:28.220 --> 33:29.220
看一下啊

33:29.220 --> 33:30.220
host

33:30.220 --> 33:31.220
呃多了一个冒号

33:31.220 --> 33:32.220
对吧

33:32.220 --> 33:33.220
多了一个冒号

33:33.220 --> 33:34.220
呃

33:34.220 --> 33:36.220
我们用i加1啊

33:36.220 --> 33:38.220
i加1取出来

33:38.220 --> 33:39.220
然后呢

33:39.220 --> 33:40.220
去掉这位空格

33:41.220 --> 33:42.220
好再来

33:44.220 --> 33:45.220
刷新

33:46.220 --> 33:47.220
看一下啊

33:47.220 --> 33:48.220
应该是没问题了

33:48.220 --> 33:49.220
说没问题了

33:50.220 --> 33:51.220
看一下啊

33:51.220 --> 33:52.220
那么变成那个

33:52.220 --> 33:53.220
输主啊

33:53.220 --> 33:54.220
输主的每项有两项

33:54.220 --> 33:55.220
然后呢

33:55.220 --> 33:56.220
把这个玩意呢

33:56.220 --> 33:57.220
再把它变成对象

33:58.220 --> 33:59.220
把变成对象

33:59.220 --> 34:00.220
就是headers

34:00.220 --> 34:01.220
啊

34:01.220 --> 34:02.220
headers

34:02.220 --> 34:03.220
从那个objects

34:03.220 --> 34:04.220
from

34:04.220 --> 34:05.220
诶

34:05.220 --> 34:06.220
我记得有一个接口啊

34:06.220 --> 34:07.220
我看一下

34:08.220 --> 34:09.220
objects

34:09.220 --> 34:10.220
from

34:11.220 --> 34:12.220
entress

34:12.220 --> 34:13.220
啊

34:13.220 --> 34:14.220
fromentress

34:14.220 --> 34:15.220
就这个

34:15.220 --> 34:16.220
这个接口

34:16.220 --> 34:17.220
它把这种格式呢

34:17.220 --> 34:18.220
它可以表现

34:18.220 --> 34:19.220
这种变成对象

34:19.220 --> 34:21.220
part

34:21.220 --> 34:22.220
好

34:22.220 --> 34:23.220
咱们来看一下headers

34:23.220 --> 34:24.220
变成对象过后

34:24.220 --> 34:25.220
已经是什么样子

34:27.540 --> 34:28.540
刷新

34:28.540 --> 34:29.540
刷新

34:30.540 --> 34:31.540
看一下这边

34:31.540 --> 34:32.540
好没问题了

34:32.540 --> 34:33.540
对吧

34:33.540 --> 34:34.540
就把它headers

34:34.540 --> 34:35.540
全部取出来了

34:35.540 --> 34:36.540
好取出来了过后呢

34:36.540 --> 34:37.540
接下来

34:37.540 --> 34:38.540
我们把这个headers

34:38.540 --> 34:39.540
取出来过后

34:39.540 --> 34:40.540
接下来我们要响应了

34:40.540 --> 34:41.540
响应

34:42.540 --> 34:43.540
好

34:43.540 --> 34:44.540
响应的时候怎么响应呢

34:44.540 --> 34:45.540
我要回到这

34:45.540 --> 34:46.540
服务器要响应一个

34:46.540 --> 34:48.540
特殊格式的atp消息

34:48.540 --> 34:49.540
那么这个消息格式

34:49.540 --> 34:50.540
是什么样的消息格式呢

34:50.540 --> 34:51.540
我再给大家记住了一下

34:51.540 --> 34:52.540
啊

34:52.540 --> 34:53.540
ATP握手的时候

34:53.540 --> 34:54.540
它的响应

34:54.540 --> 34:55.540
它响应的消息头里边

34:55.540 --> 34:57.540
要包含这几个东西

34:57.540 --> 34:58.540
包含这几个东西

34:58.540 --> 34:59.540
好

34:59.540 --> 35:00.540
那么这几个东西

35:00.540 --> 35:01.540
当然了

35:01.540 --> 35:02.540
第一行是响应行

35:02.540 --> 35:03.540
我们来响应吧

35:03.540 --> 35:04.540
现在响应

35:04.540 --> 35:06.540
响应的话就是socket write

35:06.540 --> 35:07.540
对吧

35:07.540 --> 35:08.540
write

35:08.540 --> 35:09.540
往里边写东西

35:09.540 --> 35:11.540
我们用一个模板字幕创码

35:11.540 --> 35:12.540
第一行是啥呢

35:12.540 --> 35:14.540
第一行是

35:14.540 --> 35:16.540
消息码

35:16.540 --> 35:17.540
第一行是消息码

35:17.540 --> 35:19.540
这个就和那个

35:19.540 --> 35:21.540
状态码

35:21.540 --> 35:22.540
就是状态码

35:22.540 --> 35:24.540
这个ws个状态码

35:24.540 --> 35:25.540
我看一下啊

35:25.540 --> 35:27.540
试我看一下

35:27.540 --> 35:28.540
就这个

35:28.540 --> 35:29.540
直接把复制一下

35:29.540 --> 35:30.540
这是第一行

35:30.540 --> 35:31.540
啊

35:31.540 --> 35:32.540
就是如果说这个ws

35:32.540 --> 35:33.540
就是web

35:33.540 --> 35:34.540
socket的协议呢

35:34.540 --> 35:35.540
它是这样的

35:35.540 --> 35:36.540
它呢

35:36.540 --> 35:37.540
它也是

35:37.540 --> 35:38.540
这个握手阶段呢

35:38.540 --> 35:39.540
是基于attp的

35:39.540 --> 35:40.540
啊

35:40.540 --> 35:41.540
然后呢

35:41.540 --> 35:42.540
它如果说

35:42.540 --> 35:43.540
表示我OK了

35:43.540 --> 35:44.540
服务器我可以给你进行

35:44.540 --> 35:45.540
socket的通信

35:45.540 --> 35:46.540
那么就响应101

35:46.540 --> 35:47.540
不是200了啊

35:47.540 --> 35:48.540
101表示什么意思呢

35:48.540 --> 35:49.540
表示切换协议

35:49.540 --> 35:50.540
啊

35:50.540 --> 35:51.540
后边的协

35:51.540 --> 35:52.540
后边我们交通了

35:52.540 --> 35:53.540
就切换到另外一个协议

35:53.540 --> 35:54.540
就是switching pertocos

35:54.540 --> 35:55.540
啊

35:55.540 --> 35:56.540
表示切换协议

35:56.540 --> 35:57.540
好了吗

35:57.540 --> 35:58.540
啊

35:58.540 --> 35:59.540
这里不能不能

35:59.540 --> 36:00.540
前面不能出现空格啊

36:00.540 --> 36:01.540
响应头呢

36:01.540 --> 36:02.540
我们刚才看到了啊

36:02.540 --> 36:03.540
有这么三个

36:03.540 --> 36:06.910
啊有这么三个响应头

36:06.910 --> 36:07.910
啊

36:07.910 --> 36:08.910
只差响应头

36:08.910 --> 36:09.910
然后呢

36:09.910 --> 36:10.910
响应体呢

36:10.910 --> 36:11.910
对吧

36:11.910 --> 36:12.910
表示响应体

36:12.910 --> 36:13.910
就是我们要写的内容

36:13.910 --> 36:14.910
对不对

36:14.910 --> 36:15.910
那么这个地方呢

36:15.910 --> 36:16.910
我们关键是这

36:16.910 --> 36:17.910
这两个是固定的啊

36:17.910 --> 36:18.910
就是我们服务器说

36:18.910 --> 36:19.910
啊

36:19.910 --> 36:20.910
我们的协议呢

36:20.910 --> 36:21.910
要切换

36:21.910 --> 36:22.910
切换成连接的方式呢

36:22.910 --> 36:23.910
变成

36:23.910 --> 36:24.910
升级的

36:24.910 --> 36:25.910
升级的方式

36:25.910 --> 36:26.910
升级成什么呢

36:26.910 --> 36:27.910
升级成websocket

36:27.910 --> 36:28.910
这要写啥呢

36:28.910 --> 36:29.910
这位置是这样子

36:29.910 --> 36:30.910
客户端那边呢

36:30.910 --> 36:31.910
给我传了一个key过来

36:31.910 --> 36:33.910
啊是浏览器自动生成的

36:33.910 --> 36:34.910
一个随机的key

36:34.910 --> 36:35.910
那么这个key过来呢

36:35.910 --> 36:36.910
服务器呢

36:36.910 --> 36:37.910
要

36:37.910 --> 36:39.910
要要返还给他一个key

36:39.910 --> 36:40.910
返还的key呢

36:40.910 --> 36:42.910
是根据这个key来生成的

36:42.910 --> 36:43.910
啊就服务器给他个key呢

36:43.910 --> 36:44.910
是根据这个东西来生成的

36:44.910 --> 36:45.910
这样子表示说

36:45.910 --> 36:46.910
服务器

36:46.910 --> 36:47.910
哎我知道你客户端

36:47.910 --> 36:48.910
想要进行收费的通信

36:48.910 --> 36:49.910
而且呢

36:49.910 --> 36:50.910
也告诉过了一个随机数

36:50.910 --> 36:51.910
我又给你

36:51.910 --> 36:52.910
返还一个

36:52.910 --> 36:53.910
返还了一个

36:53.910 --> 36:54.910
就是制服串

36:54.910 --> 36:55.910
那么这样子呢

36:55.910 --> 36:56.910
我们双方啊

36:57.910 --> 36:58.910
我说一个普通的服务器

36:58.910 --> 36:59.910
肯定不会给你的

36:59.910 --> 37:00.910
对不对

37:00.910 --> 37:01.910
所以说呢

37:01.910 --> 37:02.910
通过这种方式呢

37:02.910 --> 37:03.910
就双方约定好

37:03.910 --> 37:04.910
哎我们可以进行通信了

37:04.910 --> 37:05.910
是这么个意思

37:05.910 --> 37:06.910
好那么这个通过

37:06.910 --> 37:07.910
要对这个key行处理

37:07.910 --> 37:09.910
那么这个这个地方key写啥呢

37:09.910 --> 37:10.910
啊表示服务器

37:10.910 --> 37:11.910
我接受这个啊

37:11.910 --> 37:12.910
我也没收key这

37:12.910 --> 37:13.910
那么key写啥呢

37:13.910 --> 37:14.910
他是一个算法

37:14.910 --> 37:15.910
怎么来算呢

37:15.910 --> 37:18.910
他是对这个传入的那个key啊

37:18.910 --> 37:20.910
进行哈西加密

37:20.910 --> 37:22.910
啊加密的方式呢

37:22.910 --> 37:23.910
是用sha

37:23.910 --> 37:25.910
一这种方式来进行哈西加密

37:25.910 --> 37:27.910
然后呢再拼接一个固定的制服串

37:27.910 --> 37:28.910
制服串是固定的啊

37:28.910 --> 37:29.910
没有什么意义

37:29.910 --> 37:30.910
就是一个固定的

37:30.910 --> 37:31.910
这是个悠悠id啊

37:31.910 --> 37:33.910
全球唯一边吧

37:33.910 --> 37:34.910
固定的

37:34.910 --> 37:35.910
然后呢再对他进行

37:35.910 --> 37:36.910
bass六十边吧

37:36.910 --> 37:37.910
啊如果用load.js

37:37.910 --> 37:38.910
实现的话我这里

37:38.910 --> 37:39.910
已经给他写出来了

37:39.910 --> 37:43.610
就这样子写

37:43.610 --> 37:45.610
啊得到一个哈西啊

37:45.610 --> 37:47.610
得到一个就是哈西加密方式

37:47.610 --> 37:49.610
加密方式为sha1

37:49.610 --> 37:51.610
得到一个这么这么这么一个加密方式

37:51.610 --> 37:53.610
然后呢加密的内容呢

37:53.610 --> 37:55.610
就是这个东西来自于哪呢

37:55.610 --> 37:56.610
来自于headers

37:57.610 --> 37:59.610
headers的这个

37:59.610 --> 38:00.610
刚才看到啥

38:00.610 --> 38:03.610
就是这个想请求头里边来自于这

38:05.610 --> 38:07.610
然后拼接上一个固定的制服串

38:07.610 --> 38:09.610
啊然后进行加密

38:09.610 --> 38:10.610
加密完了过后呢

38:10.610 --> 38:12.610
bass六十边吧

38:12.610 --> 38:13.610
得到这个key

38:15.610 --> 38:16.610
把这个key给他

38:17.610 --> 38:18.610
就完了

38:18.610 --> 38:19.610
就完了

38:19.610 --> 38:20.610
我这里要拼接一下

38:23.110 --> 38:24.110
好这样子写完了过后呢

38:24.110 --> 38:26.110
得去表示服务器呢

38:26.110 --> 38:27.110
我接受

38:27.110 --> 38:29.110
然后呢我们有sockets end

38:29.110 --> 38:30.110
sockets不能end

38:30.110 --> 38:31.110
不能end

38:31.110 --> 38:32.110
我们该写过去就行了

38:32.110 --> 38:33.110
好保存

38:33.110 --> 38:34.110
咱们来看一下啊

38:34.110 --> 38:35.110
现在呢我们刷新

38:36.110 --> 38:37.110
现在看都够好走

38:37.110 --> 38:38.110
是不是不是pending的

38:38.110 --> 38:40.110
对吧不是pending状态了

38:40.110 --> 38:41.110
说明了啥吗

38:41.110 --> 38:42.110
说明了服务器那边

38:42.110 --> 38:43.110
是不是给我响应了个正确结果

38:43.110 --> 38:44.110
双方的

38:44.110 --> 38:46.110
双方这一步就完成了

38:46.110 --> 38:47.110
这一步是完成了

38:47.110 --> 38:48.110
这一步晚上过后我们看

38:48.110 --> 38:49.110
控制台是否连接已建立

38:49.110 --> 38:50.110
是已经打印出来了

38:50.110 --> 38:52.110
对吧表示open的啊

38:52.110 --> 38:53.110
客户端这里

38:53.110 --> 38:54.110
刚才写了的

38:54.110 --> 38:56.110
握手完成连接已建立

38:56.110 --> 38:57.110
好那么现在有没有关闭

38:57.110 --> 38:58.110
没有任何人关闭

38:58.110 --> 39:00.110
那么通道就一直建立

39:00.110 --> 39:01.110
一直放在这

39:01.110 --> 39:03.110
那么这个时候任何人

39:03.110 --> 39:04.110
浏览器也好服务器也好

39:04.110 --> 39:05.110
都有权利

39:05.110 --> 39:07.110
主动的向对方发动消息

39:07.110 --> 39:09.110
发动任何消息都可以

39:09.110 --> 39:10.110
发动一次两次

39:10.110 --> 39:12.110
一百次都可以

39:12.110 --> 39:13.110
那边呢也可以根据

39:13.110 --> 39:15.110
要根据情况来进行想

39:15.110 --> 39:17.110
进行回应

39:17.110 --> 39:18.110
也可以不回应

39:18.110 --> 39:19.110
就这么回事

39:19.110 --> 39:20.110
我们现在呢

39:20.110 --> 39:21.110
我们来看一下啊

39:21.110 --> 39:22.110
这个我们通过这个w s

39:22.110 --> 39:24.110
来这里看一下点开

39:24.110 --> 39:25.110
然后呢现在我们发送

39:25.110 --> 39:27.110
发送服务器点击发送

39:27.110 --> 39:28.110
我们看那个message

39:28.110 --> 39:29.110
你看是发了一个123过去

39:29.110 --> 39:30.110
对吧

39:30.110 --> 39:31.110
再发送一个是发了一个123过去

39:31.110 --> 39:33.110
就这么个意思啊就这么个意思

39:33.110 --> 39:35.110
那么这个123服务器能收到吗

39:35.110 --> 39:36.110
当然可以收到

39:36.110 --> 39:37.110
当然可以收到

39:37.110 --> 39:38.110
我们来看一下服务器

39:38.110 --> 39:40.550
怎么来收到这个消息

39:40.550 --> 39:42.550
好服务器要收到这个消息的话

39:42.550 --> 39:43.550
我们这里呢就是

39:43.550 --> 39:44.550
这个这个地方

39:44.550 --> 39:45.550
是不是已经建立连接了

39:45.550 --> 39:47.550
对吧已经建立连接了

39:47.550 --> 39:48.550
那么后续呢

39:48.550 --> 39:49.550
后续后续呢

39:49.550 --> 39:50.550
我们在这里啊

39:50.550 --> 39:52.550
注册一个时间啊

39:52.550 --> 39:53.550
data

39:53.550 --> 39:56.550
当后续的后续的数据到来之后

39:56.550 --> 39:58.550
那么我们这里呢

39:59.550 --> 40:03.890
把这个数据打印出来

40:03.890 --> 40:04.890
好来吧

40:04.890 --> 40:05.890
我们输出这个创改

40:06.890 --> 40:07.890
好保存

40:07.890 --> 40:08.890
接下来我们来这里边

40:08.890 --> 40:10.890
我们要到服务器把这个清空

40:10.890 --> 40:11.890
接下来我们发送消息到服务器

40:11.890 --> 40:13.890
发送发送发送发送几次了

40:16.390 --> 40:17.390
数据呢

40:18.390 --> 40:19.390
我看一下啊

40:20.390 --> 40:21.390
我这里呢

40:22.390 --> 40:27.220
注册了一个data时间

40:29.850 --> 40:30.850
这个地方

40:31.850 --> 40:34.850
为什么没有那个打印出来了

40:35.850 --> 40:37.850
我的保存重新一下

40:37.850 --> 40:40.670
发送消息

40:43.880 --> 40:45.880
现在又现在又变成喷叮了

40:45.880 --> 40:46.880
现在出问题了啊

40:46.880 --> 40:49.880
他这里101啊对了嘛

40:50.880 --> 40:51.880
对了啊

40:52.880 --> 40:54.880
好现在可以了啊发送发送

40:54.880 --> 40:55.880
你看是不是消息发过来了

40:55.880 --> 40:57.880
对吧只不过是个buffer

40:57.880 --> 40:58.880
好那么这个buffer

40:58.880 --> 40:59.880
就有点奇怪对不对

40:59.880 --> 41:01.880
我们明明给的是一个123

41:01.880 --> 41:03.880
123怎么又这么多数据出来了

41:03.880 --> 41:04.880
而且每次发送的都是123

41:04.880 --> 41:06.880
为什么还不一样啊

41:06.880 --> 41:08.880
这个有点奇怪对不对啊

41:08.880 --> 41:09.880
每次都是123

41:09.880 --> 41:10.880
为什么还不一样

41:11.880 --> 41:12.880
是这样子

41:12.880 --> 41:14.880
我们看一下刚才说的

41:14.880 --> 41:15.880
双方自由通信

41:15.880 --> 41:16.880
通信的格式呢

41:16.880 --> 41:18.880
要按照web收取他的要求

41:18.880 --> 41:21.880
那么他这里边要求还是蛮多的

41:21.880 --> 41:22.880
他是要针对的是

41:22.880 --> 41:24.880
二进之未来进行要求的

41:24.880 --> 41:25.880
因为呢web收取的

41:25.880 --> 41:26.880
他是这样子想的

41:26.880 --> 41:27.880
因为你的消息呢

41:27.880 --> 41:28.880
这个数量呢

41:28.880 --> 41:29.880
我也没有做限制

41:29.880 --> 41:30.880
如果说你发送有比较大的消息呢

41:30.880 --> 41:31.880
我肯定要切片啊

41:31.880 --> 41:33.880
切成一帧一帧的格式

41:33.880 --> 41:35.880
一帧一块数据一帧一块数据

41:35.880 --> 41:37.880
这样一块一块发送过去

41:37.880 --> 41:39.880
那么发送到服务器的时候呢

41:39.880 --> 41:41.880
这个顺序不是一定的啊

41:41.880 --> 41:42.880
有可能第一帧的数据呢

41:42.880 --> 41:43.880
跑到第三次发送了啊

41:43.880 --> 41:44.880
他不一定的顺序

41:44.880 --> 41:45.880
所以说呢

41:45.880 --> 41:46.880
每一帧的数据呢

41:46.880 --> 41:47.880
我要高速服务器

41:47.880 --> 41:48.880
这一帧的数据

41:48.880 --> 41:49.880
第一位啊

41:49.880 --> 41:51.880
就是我这一共有多少数据

41:51.880 --> 41:52.880
然后呢

41:52.880 --> 41:53.880
这是第几帧

41:53.880 --> 41:54.880
然后呢

41:54.880 --> 41:55.880
这是不是最后一帧等等等等啊

41:55.880 --> 41:57.880
这就这么一些元数据呢

41:57.880 --> 41:58.880
要附带到消息里面啊

41:58.880 --> 41:59.880
每一帧的消息里面

41:59.880 --> 42:00.880
都要附带这个元数据

42:00.880 --> 42:02.880
这是Web收取者要求的格式啊

42:02.880 --> 42:03.880
他就不像收取者

42:03.880 --> 42:04.880
收取者无所谓

42:04.880 --> 42:05.880
我才无所谓

42:05.880 --> 42:06.880
我管理的那么多

42:06.880 --> 42:07.880
你随便来

42:07.880 --> 42:08.880
但是呢

42:08.880 --> 42:09.880
Web收取者他是有要求的

42:09.880 --> 42:10.880
这个要求还比较复杂

42:10.880 --> 42:12.880
还要在二镜子里面去解析

42:12.880 --> 42:13.880
那么这个解析过程呢

42:13.880 --> 42:14.880
我就不写了

42:14.880 --> 42:15.880
这个太麻烦了

42:15.880 --> 42:16.880
我们一般是使用第三方库

42:16.880 --> 42:17.880
但是我们可以看到啊

42:17.880 --> 42:18.880
这一边

42:18.880 --> 42:19.880
消息呢

42:19.880 --> 42:20.880
实际上是已经收到了

42:20.880 --> 42:21.880
就这么的意思啊

42:21.880 --> 42:23.880
这就是双方建立连接

42:23.880 --> 42:24.880
双方建立连接

42:24.880 --> 42:25.880
OK

42:25.880 --> 42:26.880
那么这是关于

42:26.880 --> 42:28.880
这个Web收取者的原理

42:28.880 --> 42:29.880
我们就讲到这

42:29.880 --> 42:30.880
好 下面可能来讲一个

42:30.880 --> 42:32.880
第三方库来使用这个Web收取者

42:32.880 --> 42:34.880
因为我们用Web收取者的话

42:34.880 --> 42:35.880
一般不会自己去手写

42:35.880 --> 42:37.880
好吧 这是关于这一块啊

