WEBVTT

00:01.970 --> 00:03.970
这些课呢 咱们来聊一聊这个

00:03.970 --> 00:05.970
OIM

00:05.970 --> 00:08.970
先做一个简介啊 这些课我们只是做一个简介

00:08.970 --> 00:10.970
下期课我们再去 后续的课程

00:10.970 --> 00:12.970
因为我们这一张主要学习的是OIM

00:12.970 --> 00:16.970
因为如果说你直接去使用那个驱动程序的话

00:16.970 --> 00:19.970
嗯 会有一些问题啊 倒不是什么大问题

00:19.970 --> 00:21.970
如果说小的项目的话 无所谓

00:21.970 --> 00:23.970
但是稍微上一点大的项目 但是呢

00:23.970 --> 00:26.970
我给大家说一下 稍微上一点工程的项目呢

00:26.970 --> 00:28.970
就应该是前后端分离了

00:28.970 --> 00:30.970
就是数据库里可以 不用管了

00:30.970 --> 00:34.970
因此Secretize和OIM对于前端来说

00:34.970 --> 00:36.970
很尴尬

00:36.970 --> 00:38.970
OIM是个好东西 首先知道

00:38.970 --> 00:42.970
但是对于前端来说呢 是有一点 这个位置是有点尴尬的

00:42.970 --> 00:46.970
因为说如果说前端来搞定一些

00:46.970 --> 00:49.970
比较大型的 或者是中型的数据库的话

00:49.970 --> 00:51.970
一般不会出现这种情况

00:51.970 --> 00:53.970
但是小的数据库的话

00:53.970 --> 00:55.970
可不可以用OIM呢 也可以用

00:55.970 --> 00:57.970
不是说不能用 也可以用

00:57.970 --> 00:59.970
而且呢 也有很多的好处

00:59.970 --> 01:01.970
但是呢 小的工程里面呢

01:01.970 --> 01:04.970
使用MySQL迅速程序呢 也完全扣了

01:04.970 --> 01:06.970
它有一点尴尬 但是呢

01:06.970 --> 01:08.970
为了你们以后着想

01:08.970 --> 01:11.970
为了你们以后的第一 熟悉后端

01:11.970 --> 01:13.970
他们是怎么来操纵数据库的

01:13.970 --> 01:15.970
这是第一个 让你们更加理解

01:15.970 --> 01:17.970
后端是怎么去操作的

01:17.970 --> 01:20.970
第二个点呢 江南的前端的位置呢

01:20.970 --> 01:22.970
可能要承担的东西呢 可能会越来越多

01:22.970 --> 01:25.970
包括了对一些业务的数据库的管理

01:25.970 --> 01:27.970
可能也需要前端来承担

01:27.970 --> 01:30.970
将来说不准的 因为前端现在发展得很快

01:30.970 --> 01:31.970
所以说这个Secretize呢

01:31.970 --> 01:32.970
这个OIM呢

01:32.970 --> 01:34.970
我还是没有把它做为扩展课程

01:34.970 --> 01:35.970
大家听一听吧

01:35.970 --> 01:37.970
能理解多少就尽量理解

01:37.970 --> 01:39.970
我们后边呢 也会利用这个OIM来

01:39.970 --> 01:41.970
就是做一些安逸的时候呢

01:41.970 --> 01:42.970
也会利用这个OIM来做

01:42.970 --> 01:44.970
毕竟呢 它比那个MySQL呢

01:44.970 --> 01:46.970
要 功能要强大太多了

01:46.970 --> 01:49.970
好 咱们来首先介绍一下OIM

01:49.970 --> 01:51.970
这个OIM呢 它什么东西呢

01:51.970 --> 01:55.970
它叫做Object Relation Mapping

01:55.970 --> 01:57.970
什么意思 对象关系映射

01:57.970 --> 01:59.970
叫做OIM

01:59.970 --> 02:01.970
什么叫关系映射呢

02:01.970 --> 02:02.970
对象我们知道的吧

02:02.970 --> 02:04.970
我们无论是加瓦语言也好

02:04.970 --> 02:06.970
cshop语言也好 还是什么其他语言

02:06.970 --> 02:08.970
还有包括我们的这个介石

02:08.970 --> 02:09.970
都有对象

02:09.970 --> 02:10.970
对不对

02:10.970 --> 02:11.970
咱们的数据库里边

02:11.970 --> 02:13.970
一行 是不是就相当一个对象

02:13.970 --> 02:15.970
咱们来看一下吧

02:15.970 --> 02:16.970
数据库里边一行

02:16.970 --> 02:18.970
其实就相当于是一个对象

02:18.970 --> 02:20.970
你看吧 这一行

02:20.970 --> 02:21.970
这一行说相当于是个对象

02:21.970 --> 02:23.970
对象的属性ID等于Name等于

02:24.970 --> 02:25.970
对不对

02:25.970 --> 02:26.970
就相当于是一个对象

02:26.970 --> 02:28.970
那么这个对象关系映射

02:28.970 --> 02:30.970
映射到哪呢

02:30.970 --> 02:32.970
是映射到那个数据库里边去

02:32.970 --> 02:33.970
对不对

02:33.970 --> 02:34.970
它就映射到数据库里边去

02:34.970 --> 02:36.970
这就是对象关系映射

02:36.970 --> 02:37.970
非常非常简单

02:37.970 --> 02:40.970
这是关于这个OIM的含义

02:40.970 --> 02:42.970
第二点是

02:42.970 --> 02:44.970
OIM框架它可以做什么呢

02:44.970 --> 02:46.970
它可以把我们程序中的对象

02:46.970 --> 02:47.970
比方说GS对象

02:47.970 --> 02:50.970
它可以跟数据库里边的表来进行关联

02:50.970 --> 02:52.970
比方说咱们程序里边一个对象

02:52.970 --> 02:53.970
一个公司对象

02:53.970 --> 02:54.970
有事的属性

02:54.970 --> 02:55.970
那么它就会自动的

02:55.970 --> 02:58.970
去跟这个公司表来进行关联

02:58.970 --> 03:00.970
那么它是有能够起到这么一个作用

03:00.970 --> 03:02.970
就是关系映射

03:02.970 --> 03:03.970
它又有什么具体的用法呢

03:03.970 --> 03:04.970
就是说

03:04.970 --> 03:06.970
OIM框架它可以做的是

03:06.970 --> 03:10.970
隐藏具体的数据库的底层实现

03:10.970 --> 03:12.970
让开发者是用同样的数据库操作

03:12.970 --> 03:14.970
解可完成不同的数据库操作

03:14.970 --> 03:15.970
这个到底是什么意思呢

03:15.970 --> 03:16.970
有点抽象

03:16.970 --> 03:18.970
我们来看一张图

03:18.970 --> 03:20.970
看这张图

03:20.970 --> 03:21.970
就说有的时候

03:21.970 --> 03:23.970
我们刚 之前是连接的是买射口

03:23.970 --> 03:24.970
对吧

03:24.970 --> 03:25.970
来操作这个买射口

03:25.970 --> 03:27.970
实际上到以后有可能会出现这么一种情况

03:27.970 --> 03:29.970
将来突然你的项目经理

03:29.970 --> 03:31.970
或者是万二的产品经理

03:31.970 --> 03:32.970
它突然告诉你

03:32.970 --> 03:35.970
我们不想使用买射口数据库了

03:35.970 --> 03:37.970
这个产品经理一般不会这样说

03:37.970 --> 03:38.970
项目经理说

03:38.970 --> 03:39.970
我们要换一个数据库

03:39.970 --> 03:41.970
可能要换成这个mongerDB

03:41.970 --> 03:42.970
那么这个玩意

03:42.970 --> 03:44.970
这个两个数据库是完全不一样的

03:44.970 --> 03:45.970
对不对

03:45.970 --> 03:46.970
那你这一换

03:46.970 --> 03:47.970
能不能换呢

03:47.970 --> 03:49.970
你数据库倒是可以换

03:49.970 --> 03:50.970
通过一些工具

03:50.970 --> 03:52.970
或者一些数据库自带的一些东西

03:52.970 --> 03:54.970
可以把它导出到另外一个数据库

03:54.970 --> 03:55.970
把数据格式化一下

03:55.970 --> 03:57.970
导出到另外一个数据库

03:57.970 --> 03:59.970
这个数据库倒是能够操作

03:59.970 --> 04:01.970
但是你的程序就完蛋了

04:01.970 --> 04:02.970
为什么呢

04:02.970 --> 04:03.970
因为以前我们的程序

04:03.970 --> 04:04.970
是直接操作数据库的

04:04.970 --> 04:05.970
其实是什么

04:05.970 --> 04:06.970
其实是射口语句

04:06.970 --> 04:07.970
不好意思

04:07.970 --> 04:08.970
mongerDB

04:08.970 --> 04:10.970
它完全不支持射口语句

04:10.970 --> 04:12.970
我们学的射口语句完全没用

04:12.970 --> 04:14.970
而且它的驱动也不一样

04:14.970 --> 04:16.970
买射口的驱动是买射口二

04:16.970 --> 04:17.970
对不对

04:18.970 --> 04:20.970
它驱动也完全不一样

04:20.970 --> 04:21.970
你的大一码是不是要改

04:21.970 --> 04:23.970
很多很多的东西

04:23.970 --> 04:24.970
很多地方都要改

04:24.970 --> 04:26.970
这个是灾难性的后果

04:26.970 --> 04:27.970
前移数据库

04:27.970 --> 04:29.970
如果说你没有ORM框架的话

04:29.970 --> 04:31.970
一定是灾难性的后果

04:31.970 --> 04:33.970
但是有了ORM框架之后

04:33.970 --> 04:35.970
会有一个什么效果呢

04:35.970 --> 04:36.970
ORM框架

04:36.970 --> 04:37.970
它就帮我们去管理

04:37.970 --> 04:38.970
各种数据库

04:38.970 --> 04:39.970
比方说你告诉我

04:39.970 --> 04:41.970
我的数据在买射口里边

04:41.970 --> 04:43.970
他去买射口进行关联

04:43.970 --> 04:44.970
你告诉他

04:44.970 --> 04:46.970
我的数据在mongerDB里边

04:46.970 --> 04:47.970
关联

04:47.970 --> 04:48.970
然后呢

04:48.970 --> 04:50.970
很多大部分的ORM框架

04:50.970 --> 04:52.970
它都支持很多很多常见的数据库

04:52.970 --> 04:54.970
你只需要通过一个简单的配置

04:54.970 --> 04:56.970
告诉他我们的数据在哪

04:56.970 --> 04:57.970
他都会自动去连接

04:57.970 --> 04:59.970
相应的数据库

04:59.970 --> 05:01.970
而我们在操作数据的时候

05:01.970 --> 05:04.970
完全不使用射口语句

05:04.970 --> 05:05.970
而使用ORM框架

05:05.970 --> 05:07.970
给我们提供了统一的API接口

05:07.970 --> 05:09.970
也就是无论对哪一个数据库的操作

05:09.970 --> 05:11.970
都完全一样的

05:11.970 --> 05:12.970
这样的好数据在于什么呢

05:12.970 --> 05:15.970
好处我们之后学到mongerDB

05:16.970 --> 05:17.970
学到之后

05:17.970 --> 05:18.970
学到之后呢

05:18.970 --> 05:20.970
我们基本上代码就不用改了

05:20.970 --> 05:21.970
代码不用改了

05:21.970 --> 05:22.970
你把数据拿过去

05:22.970 --> 05:23.970
或者说直接就用这个东西

05:23.970 --> 05:24.970
我们代码该怎么写

05:24.970 --> 05:25.970
还怎么写

05:25.970 --> 05:26.970
因为它是统一的API接口

05:26.970 --> 05:27.970
对吧

05:27.970 --> 05:28.970
可能有点差异

05:28.970 --> 05:29.970
就是差异很小很小

05:29.970 --> 05:31.970
大部分都是一样的

05:31.970 --> 05:32.970
所以说这就对我们开发者来说

05:32.970 --> 05:33.970
很多好处

05:33.970 --> 05:34.970
而且ORM框架

05:34.970 --> 05:36.970
它不需要使用射口语句

05:36.970 --> 05:37.970
它会怎么样呢

05:37.970 --> 05:38.970
它会根据具体的调用方式

05:38.970 --> 05:40.970
你怎么去调这个接口呢

05:40.970 --> 05:41.970
你需要查什么数据

05:41.970 --> 05:43.970
用它的接口去给它指定

05:43.970 --> 05:44.970
然后呢

05:44.970 --> 05:45.970
它可以生成

05:45.970 --> 05:46.970
如果说麦克斯口

05:46.970 --> 05:47.970
它就会生成射口语句

05:47.970 --> 05:48.970
对吧

05:48.970 --> 05:49.970
像这些东西都会生成

05:49.970 --> 05:50.970
为不同的数据库

05:50.970 --> 05:51.970
生成不同的射口语句

05:51.970 --> 05:52.970
因为射口语句

05:52.970 --> 05:53.970
在不同的数据库里边

05:53.970 --> 05:55.970
也有多少的有些差异

05:55.970 --> 05:57.970
如果说你生都是个数据库

05:57.970 --> 05:59.970
没有射口语句的数据库

05:59.970 --> 06:01.970
那么它会生成相应的接口

06:01.970 --> 06:03.970
去搞定这个数据库

06:03.970 --> 06:04.970
因此

06:04.970 --> 06:05.970
我们只需要去学习

06:05.970 --> 06:07.970
ORM框架提供的统一接口就行了

06:07.970 --> 06:08.970
那么以后的操作

06:08.970 --> 06:09.970
是任何数据库

06:09.970 --> 06:10.970
都是完全一样的

06:10.970 --> 06:11.970
这是ORM框架

06:11.970 --> 06:13.970
我们带来的开发上的改变

06:13.970 --> 06:14.970
它的优势呢

06:14.970 --> 06:15.970
主要体现在这三个方面

06:15.970 --> 06:16.970
一个呢是开发者

06:16.970 --> 06:17.970
不用关心数据库了

06:17.970 --> 06:19.970
非常利于数据库的迁移

06:19.970 --> 06:20.970
技术选型

06:20.970 --> 06:22.970
都完全不影响我们的鞋带嘛

06:22.970 --> 06:23.970
仅关心什么

06:23.970 --> 06:24.970
仅关心我们程序里边的

06:24.970 --> 06:26.970
解释对象就可以了

06:26.970 --> 06:27.970
第二个呢是

06:27.970 --> 06:29.970
它可以轻易的完成数据库遗址

06:29.970 --> 06:30.970
就是我们数据库

06:30.970 --> 06:31.970
一个数据库倒另一个数据库

06:31.970 --> 06:32.970
基本上代码不用变

06:32.970 --> 06:33.970
对不对

06:33.970 --> 06:34.970
还有呢就是

06:34.970 --> 06:35.970
如果说

06:35.970 --> 06:37.970
我们要做一些复杂查询

06:37.970 --> 06:39.970
那么我们可能会面临

06:39.970 --> 06:40.970
一个很麻烦的事情

06:41.970 --> 06:42.970
什么意思呢

06:42.970 --> 06:43.970
我给大家举个例子

06:43.970 --> 06:45.970
比方说

06:45.970 --> 06:47.970
咱们要去做这么一个查询

06:47.970 --> 06:49.970
根据

06:49.970 --> 06:50.970
姓名

06:50.970 --> 06:52.970
年龄

06:52.970 --> 06:54.970
还有什么呢

06:54.970 --> 06:57.970
还有就是姓别

06:57.970 --> 06:58.970
查询

06:58.970 --> 06:59.970
员工

06:59.970 --> 07:00.970
比方说我们要做这么一件事

07:00.970 --> 07:01.970
那么我们可能会写下

07:01.970 --> 07:02.970
一个相应函数

07:02.970 --> 07:03.970
这个函数呢

07:03.970 --> 07:07.470
我们这样子写吧

07:07.470 --> 07:09.470
我们可能会写下

07:09.470 --> 07:10.470
一个相应函数

07:10.470 --> 07:11.470
方个型

07:11.470 --> 07:12.470
比方说Test

07:13.470 --> 07:14.470
你根据我的

07:14.470 --> 07:15.470
根据姓名

07:15.470 --> 07:16.470
根据年龄

07:16.470 --> 07:17.470
根据姓别

07:17.470 --> 07:18.470
来查询员工

07:18.470 --> 07:19.470
对吧

07:19.470 --> 07:20.470
那么我们要满足这三个条件

07:20.470 --> 07:21.470
那你的社科语句怎么写呢

07:21.470 --> 07:22.470
就很麻烦了

07:22.470 --> 07:23.470
比如说

07:23.470 --> 07:24.470
这有什么麻烦的

07:24.470 --> 07:25.470
我们直接写一个社科语句

07:25.470 --> 07:26.470
完事了

07:26.470 --> 07:27.470
很简单对不对

07:27.470 --> 07:28.470
有什么麻烦的

07:28.470 --> 07:29.470
比方说我们是那个是

07:29.470 --> 07:31.470
信号 from employee

07:31.470 --> 07:33.470
We're name

07:33.470 --> 07:34.470
等于什么

07:34.470 --> 07:35.470
等于这个name

07:35.470 --> 07:36.470
对吧

07:36.470 --> 07:37.470
and age

07:37.470 --> 07:39.470
等于什么

07:39.470 --> 07:41.470
等于什么

07:41.470 --> 07:42.470
这个是等于什么

07:42.470 --> 07:43.470
社科语句很简单

07:43.470 --> 07:44.470
为什么说麻烦呢

07:44.470 --> 07:45.470
你想一想

07:45.470 --> 07:47.470
还有一个问题没有解决

07:47.470 --> 07:50.470
这些条件是可以不用指定的

07:50.470 --> 07:51.470
比方说 age不用指定

07:51.470 --> 07:53.470
如果说 age 为 ond 犯的

07:53.470 --> 07:55.470
age 为 ond 犯的不用指定的话

07:55.470 --> 07:57.470
OK 我就没有这个条件了

07:57.470 --> 07:58.470
没什么意思吧

07:58.470 --> 08:00.470
我这个社科语句就不写了

08:00.470 --> 08:01.470
就没有这个条件了

08:01.470 --> 08:03.470
那这个事情麻烦了

08:03.470 --> 08:04.470
这个事情

08:04.470 --> 08:05.470
这个事情以前的怎么做呢

08:05.470 --> 08:06.470
你看着

08:06.470 --> 08:07.470
以前我们在这样做

08:07.470 --> 08:09.470
我这个Weir

08:09.470 --> 08:11.470
后边啥都不写

08:11.470 --> 08:13.470
我后边去ausu 写什么

08:13.470 --> 08:14.470
写一些判断

08:14.470 --> 08:15.470
if

08:15.470 --> 08:17.470
有没有name给我传进来

08:17.470 --> 08:18.470
如果说有传进来的话

08:18.470 --> 08:20.470
我这个社科评接一段

08:20.470 --> 08:21.470
这样用name

08:21.470 --> 08:23.470
懂这个意思就行了

08:23.470 --> 08:24.470
社科评接一段

08:24.470 --> 08:25.470
评接什么呢

08:25.470 --> 08:26.470
评接

08:26.470 --> 08:27.470
我们写个空格

08:27.470 --> 08:31.470
评接 and name

08:31.470 --> 08:32.470
等于问号

08:32.470 --> 08:33.470
对不对

08:33.470 --> 08:34.470
是不是要评接这个东西

08:34.470 --> 08:36.470
那为什么前面要跟个and

08:36.470 --> 08:38.470
因为你如果说你不跟

08:38.470 --> 08:39.470
如果说你不跟的话

08:39.470 --> 08:40.470
有点麻烦

08:40.470 --> 08:41.470
如果说再判断

08:41.470 --> 08:42.470
a级有值吗

08:42.470 --> 08:43.470
a级有值的话

08:43.470 --> 08:45.470
是不是我要评接

08:45.470 --> 08:47.470
评接这个a级的问号

08:47.470 --> 08:48.470
这个a级前面

08:48.470 --> 08:49.470
要不要有and呢

08:49.470 --> 08:50.470
有时候a级前面

08:50.470 --> 08:51.470
应该有and

08:51.470 --> 08:52.470
那么a级前面有and的话

08:52.470 --> 08:53.470
那如果说name

08:53.470 --> 08:54.470
他没有判断成功呢

08:54.470 --> 08:55.470
name没有传

08:55.470 --> 08:56.470
那怎么办

08:56.470 --> 08:57.470
那个and是不是直接

08:57.470 --> 08:58.470
评接到这儿来了

08:58.470 --> 08:59.470
是不是这个语法又错误了

08:59.470 --> 09:01.470
所以我们以前在这样子写

09:01.470 --> 09:02.470
先写一个

09:02.470 --> 09:03.470
随便写一个

09:03.470 --> 09:04.470
写一个衡动式

09:04.470 --> 09:05.470
然后后边

09:05.470 --> 09:07.470
每一个都评接and

09:07.470 --> 09:08.470
每一个都评接

09:08.470 --> 09:09.470
然后用这种模式来写

09:09.470 --> 09:10.470
segs

09:10.470 --> 09:12.470
就是特别特别恶心

09:12.470 --> 09:14.470
segs是不是不等于

09:14.470 --> 09:15.470
undefend

09:15.470 --> 09:16.470
然后呢

09:16.470 --> 09:17.470
如果是的话

09:17.470 --> 09:19.470
我们又评接segs

09:19.470 --> 09:20.470
就是and

09:20.470 --> 09:21.470
通革and segs

09:21.470 --> 09:22.470
等于问号

09:22.470 --> 09:23.470
那么这些判断的是

09:23.470 --> 09:25.470
应该都是不等于undefend

09:25.470 --> 09:27.470
a级

09:27.470 --> 09:28.470
name

09:28.470 --> 09:29.470
对吧

09:29.470 --> 09:30.470
我们是不是要这样子写

09:30.470 --> 09:31.470
特别特别麻烦

09:31.470 --> 09:32.470
这样子评接出来

09:32.470 --> 09:34.470
它格式才是正确的

09:34.470 --> 09:36.470
而且它不仅如此

09:36.470 --> 09:37.470
那这个问号

09:37.470 --> 09:38.470
到时候我们要去

09:38.470 --> 09:39.470
运行的时候

09:39.470 --> 09:40.470
比方说connecting

09:40.470 --> 09:41.470
或者是po

09:41.470 --> 09:43.470
然后xq

09:43.470 --> 09:44.470
要去运行的时候

09:44.470 --> 09:45.470
segs

09:45.470 --> 09:46.470
那么这个地方

09:46.470 --> 09:48.470
要传多少个参数呢

09:48.470 --> 09:49.470
又不一定了对吧

09:49.470 --> 09:50.470
是不是又不一定了

09:50.470 --> 09:51.470
那么这个时候

09:51.470 --> 09:52.470
你还在怎么样呢

09:52.470 --> 09:53.470
还得去写个数组

09:53.470 --> 09:54.470
params

09:54.470 --> 09:55.470
一个数组

09:55.470 --> 09:56.470
那么这个数组

09:56.470 --> 09:57.470
n有值的时候

09:57.470 --> 09:58.470
往这个数组里边

09:58.470 --> 09:59.470
加一下push

09:59.470 --> 10:00.470
n

10:00.470 --> 10:01.470
就特别麻烦

10:02.470 --> 10:03.470
push

10:03.470 --> 10:04.470
然后这里是

10:04.470 --> 10:05.470
push

10:05.470 --> 10:06.470
对不对

10:06.470 --> 10:07.470
然后呢

10:07.470 --> 10:08.470
这边是

10:08.470 --> 10:09.470
push

10:09.470 --> 10:10.470
那个

10:10.470 --> 10:11.470
segs

10:11.470 --> 10:12.470
对不对

10:12.470 --> 10:13.470
是不是特别麻烦

10:13.470 --> 10:14.470
然后呢

10:14.470 --> 10:15.470
把这个params传进去

10:15.470 --> 10:16.470
懂了这个意思吗

10:16.470 --> 10:17.470
就说你以前

10:17.470 --> 10:18.470
你要做这个模后啥

10:18.470 --> 10:19.470
就要去凭借这个语句

10:19.470 --> 10:20.470
特别麻烦

10:20.470 --> 10:22.470
有了这个orm之后呢

10:22.470 --> 10:24.470
它这些问题都可以解决了

10:24.470 --> 10:25.470
可以

10:25.470 --> 10:26.470
而且呢

10:26.470 --> 10:27.470
它会根据

10:27.470 --> 10:28.470
它不是说

10:28.470 --> 10:29.470
它把所有的数据

10:29.470 --> 10:30.470
全部查到的一存里边

10:30.470 --> 10:31.470
然后再再进行筛选

10:31.470 --> 10:32.470
不是的

10:32.470 --> 10:33.470
而且它根据你的

10:33.470 --> 10:34.470
使用的API

10:34.470 --> 10:35.470
你自动的去生成

10:35.470 --> 10:36.470
稍后语句

10:36.470 --> 10:37.470
你要哪些数据

10:37.470 --> 10:38.470
给你查那一点点

10:38.470 --> 10:39.470
这样子的

10:39.470 --> 10:40.470
最大限度的避免了

10:40.470 --> 10:42.470
内存空间的占用

10:42.470 --> 10:43.470
因为我们知道

10:43.470 --> 10:44.470
数据我们在哪里

10:44.470 --> 10:45.470
在硬盘上对不对

10:45.470 --> 10:47.470
硬盘可以存的数据很多

10:47.470 --> 10:48.470
但是内存里边

10:48.470 --> 10:49.470
能放的数据

10:49.470 --> 10:50.470
内存的资源是很吃紧的

10:50.470 --> 10:51.470
每个程序都要

10:51.470 --> 10:52.470
争夺内存资源

10:52.470 --> 10:53.470
所以说我们内存里边

10:53.470 --> 10:54.470
要尽量的少

10:54.470 --> 10:55.470
查的东西尽量的少

10:55.470 --> 10:57.470
不要让我只查

10:58.470 --> 10:59.470
第一页的

10:59.470 --> 11:00.470
每页显示10条

11:00.470 --> 11:02.470
第一页的男员工

11:02.470 --> 11:03.470
然后是不是

11:03.470 --> 11:04.470
10条数据

11:04.470 --> 11:05.470
他会根据你的

11:05.470 --> 11:06.470
API的调用

11:06.470 --> 11:07.470
自动生成稍后语句

11:07.470 --> 11:08.470
就非常的智能

11:08.470 --> 11:10.470
这是OIM他的作用

11:10.470 --> 11:11.470
我们后边学习的

11:11.470 --> 11:12.470
具体的用的时候

11:12.470 --> 11:13.470
我们就知道了

11:13.470 --> 11:15.470
这是关于这一个

11:15.470 --> 11:16.470
下一个是

11:16.470 --> 11:17.470
我们Note东东的

11:17.470 --> 11:18.470
OIM到底是用啥

11:18.470 --> 11:19.470
我们Note里面的

11:19.470 --> 11:21.470
OIM主要是有两个框架

11:21.470 --> 11:22.470
目前主要是有

11:22.470 --> 11:23.470
两个

11:23.470 --> 11:24.470
一个是Securize

11:24.470 --> 11:25.470
就是我们这

11:25.470 --> 11:26.470
后边要学习的

11:26.470 --> 11:27.470
一个是Type OIM

11:27.470 --> 11:28.470
那么这两个东西

11:28.470 --> 11:29.470
是怎么样子的

11:29.470 --> 11:30.470
就是这个东西

11:30.470 --> 11:32.470
它可以支持介石

11:32.470 --> 11:33.470
也可以支持TS

11:33.470 --> 11:35.470
还有TypeScripts

11:35.470 --> 11:37.470
因为我们TypeScripts

11:37.470 --> 11:38.470
这个门客

11:38.470 --> 11:39.470
它是一个选修客

11:39.470 --> 11:40.470
本来就是选修客

11:40.470 --> 11:41.470
所以说我们

11:41.470 --> 11:43.470
讲的时候还是用介石来讲

11:43.470 --> 11:44.470
如果说你对TS

11:44.470 --> 11:45.470
怎么去

11:45.470 --> 11:46.470
TS使用它有兴趣的话

11:46.470 --> 11:47.470
我会给大家介绍一下

11:47.470 --> 11:48.470
从哪儿去看

11:48.470 --> 11:49.470
其实也很简单

11:49.470 --> 11:51.470
它是用注解的方式

11:51.470 --> 11:52.470
来定义模型的

11:52.470 --> 11:53.470
我们之后会慢慢说

11:54.470 --> 11:55.470
看一下他的官方网站

11:56.470 --> 11:57.470
第一次HUB上面

11:57.470 --> 11:58.470
这不是官方网站

11:58.470 --> 12:00.470
这是民间的一个中文网

12:00.470 --> 12:01.470
一个中文

12:01.470 --> 12:02.470
中文的文档

12:04.470 --> 12:05.470
咱们去看一下

12:06.470 --> 12:07.470
它的关于TypeScripts

12:08.470 --> 12:09.470
你看

12:09.470 --> 12:10.470
专门有一张

12:10.470 --> 12:11.470
来介绍TypeScripts

12:11.470 --> 12:12.470
TS

12:12.470 --> 12:14.470
怎么样去跟Secretize结合

12:15.470 --> 12:16.470
其实

12:16.470 --> 12:17.470
绝大部分的写法都是一样的

12:17.470 --> 12:18.470
就是有一些小的地方

12:18.470 --> 12:19.470
大家注意一下就行了

12:19.470 --> 12:20.470
如果说有兴趣的话

12:20.470 --> 12:21.470
可以去看一下

12:21.470 --> 12:22.470
我们讲的话还是用介石

12:23.470 --> 12:25.470
这个框架

12:25.470 --> 12:26.470
它是比较成熟的

12:26.470 --> 12:27.470
它是相当成熟的一个框架

12:28.470 --> 12:29.470
因为毕竟出现了这么久了

12:29.470 --> 12:30.470
它出现的时间比较早

12:31.470 --> 12:32.470
而Type OIM

12:32.470 --> 12:34.470
它是只支持TS

12:35.470 --> 12:36.470
只支持TSU

12:37.470 --> 12:39.470
它跟TS结合的比较好

12:39.470 --> 12:41.470
但是它不是很成熟

12:41.470 --> 12:42.470
不成熟

12:42.470 --> 12:44.470
我之前都用过这个玩意儿

12:44.470 --> 12:45.470
用过这个玩意儿

12:45.470 --> 12:46.470
我还确实有些地方

12:47.470 --> 12:48.470
很有代感性

12:48.470 --> 12:49.470
所以我们使用

12:49.470 --> 12:51.470
肯定是使用一个比较成熟的

12:51.470 --> 12:52.470
前端的本来就是

12:52.470 --> 12:53.470
不成熟的东西

12:53.470 --> 12:54.470
就本来就多

12:54.470 --> 12:55.470
有成熟的就尽量使用成熟的

12:55.470 --> 12:56.470
我们使用Secretize

12:57.470 --> 12:58.470
OK

12:58.470 --> 12:59.470
这是关于

12:59.470 --> 13:00.470
Secretize

13:00.470 --> 13:01.470
Secretize到底是个什么东西

13:01.470 --> 13:02.470
它就是一个OIM框架

13:02.470 --> 13:03.470
每一门技术

13:03.470 --> 13:04.470
它都有OIM框架

13:04.470 --> 13:05.470
就Csharp语言

13:05.470 --> 13:06.470
加把语言都有

13:06.470 --> 13:08.470
做一个简单的介绍

13:08.470 --> 13:09.470
那么下一个开始

13:09.470 --> 13:10.470
我们就一次来学习Secretize

13:10.470 --> 13:11.470
可以做什么

13:11.470 --> 13:13.470
顺便我们来做一些案例

13:13.470 --> 13:15.470
做一些数据库的应用的案例

13:15.470 --> 13:16.470
我们来看一下

13:16.470 --> 13:18.470
它里边有哪些非常强大的功能

13:19.470 --> 13:20.470
我们这里可以介绍到这里

