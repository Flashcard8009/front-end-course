WEBVTT

00:00.560 --> 00:03.840
那么咱们来把这个文件留讲完

00:03.840 --> 00:07.640
上节课我们讲了这个读取流RedStream

00:07.640 --> 00:10.240
那么还有一个叫做RedStream

00:10.240 --> 00:12.240
就是我们写入流

00:12.240 --> 00:14.440
好 咱们来看一下 咱们来创建写入流

00:14.440 --> 00:17.600
我把上节课的代码来复制一下

00:17.600 --> 00:21.400
再放一个RedStream

00:21.400 --> 00:27.440
好 这边代码我把这些东西都给它去掉吧

00:27.720 --> 00:30.720
咱们来看一下 如何来创建一个写入流

00:30.720 --> 00:33.720
比方说文件 我就给它放到这儿吧

00:33.720 --> 00:35.320
放到这个目录下面

00:35.320 --> 00:37.320
文件的路径放到这儿

00:37.320 --> 00:40.520
就是写入流 ABC吧 还是同一个文件

00:40.520 --> 00:41.640
然后怎么来创建呢?

00:41.640 --> 00:44.520
FS CreateRedStream

00:44.520 --> 00:47.280
第一个还是写上文件的路径

00:47.280 --> 00:48.920
第二个还是写配置

00:48.920 --> 00:54.720
好 咱们来看一下写入流里边的配置

00:54.800 --> 00:58.800
它配置的时候有这么一个配置叫Flex

00:58.800 --> 01:00.000
这个东西我们以前用过

01:00.000 --> 01:03.800
在这个上节就是文件IO里我们是不是用过

01:03.800 --> 01:06.400
Flex里边比方说你写个W

01:06.400 --> 01:08.200
就表示覆盖文件 对吧

01:08.200 --> 01:11.200
如果说文件以前有内容的话就会被覆盖

01:11.200 --> 01:13.800
如果你写A 就是Append

01:13.800 --> 01:15.920
表示诸一家 就这么个意思

01:15.920 --> 01:18.200
就Flex 知道就行了

01:18.200 --> 01:20.200
实际上读取的时候也有Flex

01:20.200 --> 01:22.920
只不过我们通常在写入文件的时候

01:22.920 --> 01:24.880
才会放入Flex

01:24.880 --> 01:28.960
接下来编码方式 一样的编码方式Encode

01:28.960 --> 01:30.920
这个编码方式 如果说你是now

01:30.920 --> 01:32.920
那么写入的时候 你要写入什么呢?

01:32.920 --> 01:35.000
写入那个buffer

01:35.000 --> 01:36.960
它默认的是UTF-8

01:36.960 --> 01:39.120
UTF-8就是说你写的

01:39.120 --> 01:42.840
因为我们写文件的时候写的是一个一个的字节

01:42.840 --> 01:47.040
那么它就会把字节转换成

01:47.040 --> 01:49.760
我们写的时候你就可以写制服串

01:49.760 --> 01:53.040
它就会把制服串用UTF-8的这种编码

01:53.040 --> 01:55.600
转换成二进制的字节

01:55.600 --> 01:57.600
就这么个意思

01:57.600 --> 01:59.600
好 这是关于它的编码

01:59.600 --> 02:01.720
一般我们在写的时候可以写制服串

02:01.720 --> 02:04.480
也可以写一些直接写字节都可以

02:04.480 --> 02:05.840
咱们再看看

02:05.840 --> 02:07.440
骑士字节 指的是什么呢?

02:07.440 --> 02:09.200
就是我写入这个文件的时候

02:09.200 --> 02:11.840
从哪儿 第几个字节开始写入

02:11.840 --> 02:13.160
就这么个意思

02:13.160 --> 02:15.480
然后 high-water mark

02:15.480 --> 02:16.880
那跟上面是一样的

02:16.880 --> 02:19.520
不过这个东西它是准确的表达了

02:19.520 --> 02:21.240
你要写入的字节数

02:21.240 --> 02:22.440
它跟编码就没关系了

02:22.440 --> 02:24.360
比方说我们这里设置一下

02:24.360 --> 02:25.640
我给它解释一下

02:25.640 --> 02:28.360
high-water mark

02:28.360 --> 02:32.440
比方说我们这里设为二

02:32.440 --> 02:34.920
那么这个时候大家看一下

02:34.920 --> 02:36.840
如果说我写一个A

02:36.840 --> 02:37.800
它会怎么样呢?

02:37.800 --> 02:40.960
它会用UTF-8的编码方式

02:40.960 --> 02:43.480
把它编码成一个数字

02:43.480 --> 02:45.240
会把它编码成一个数字

02:45.240 --> 02:47.080
这个A占一个字节

02:47.080 --> 02:48.680
它的数字是90

02:48.680 --> 02:49.880
多少 95还是90

02:49.880 --> 02:51.320
我一点忘了

02:51.320 --> 02:52.200
那么现在呢

02:52.200 --> 02:54.280
这是一个字节

02:54.280 --> 02:57.520
那么这个地方让你最多能够写入两个字节

02:57.520 --> 02:59.760
一次最多能写入两个字节

02:59.760 --> 03:01.400
那么这里是满足要求的

03:01.400 --> 03:01.560
对吧

03:01.560 --> 03:02.600
就可以写入

03:02.600 --> 03:06.960
比方说你写的是一个中文

03:06.960 --> 03:08.880
那么按照UTF-8的话

03:08.880 --> 03:10.560
它是三个字节

03:10.560 --> 03:11.720
一个数字

03:11.720 --> 03:13.120
一个字节 两个字节

03:13.120 --> 03:14.520
16进字来表示的话

03:14.520 --> 03:16.360
它得到的是三个字节

03:16.360 --> 03:18.480
三个字节 我们这里最多只能写入两个

03:18.480 --> 03:18.800
对吧

03:18.800 --> 03:20.200
是不是最多只能写入两个

03:20.200 --> 03:20.480
OK

03:20.480 --> 03:22.280
那么这个时候就一次写不下

03:22.280 --> 03:23.320
就这么个意思

03:23.320 --> 03:26.600
它是表示的是一次能够写入的字节数

03:26.600 --> 03:28.920
这是关于它的Options

03:28.920 --> 03:30.000
它反回的是什么呢?

03:30.000 --> 03:32.080
反回的自然是一个RideStream

03:32.080 --> 03:32.920
一个流

03:32.920 --> 03:34.840
那么这个流它是继承至

03:34.840 --> 03:38.680
Stream那个cool里边的Retable负累

03:38.680 --> 03:38.960
好

03:38.960 --> 03:39.800
咱们来看一下

03:39.800 --> 03:42.200
这个流它反回了对象里边

03:42.200 --> 03:44.600
有哪些东西可以用

03:44.680 --> 03:46.520
WS

03:46.520 --> 03:47.880
写入流

03:47.880 --> 03:49.280
哪些东西可以用呢?

03:49.280 --> 03:50.600
一个是它的事件名

03:50.600 --> 03:51.640
就是注册事件

03:51.640 --> 03:52.640
像写入流的话

03:52.640 --> 03:54.000
它也有事件

03:54.000 --> 03:54.960
它有这三个事件

03:54.960 --> 03:55.520
不用说了吧

03:55.520 --> 03:56.480
一个是打开

03:56.480 --> 03:59.080
一个是Error

03:59.080 --> 04:00.600
就是表示包错

04:00.600 --> 04:01.920
包错的时候出发的事件

04:01.920 --> 04:03.040
一个是Close

04:03.040 --> 04:04.360
关闭的时候出发的事件

04:04.360 --> 04:07.360
它默认是自动关闭的

04:07.360 --> 04:07.840
当然

04:07.840 --> 04:10.320
如果说你设置了这个

04:10.320 --> 04:12.960
什么Out to Close

04:12.960 --> 04:14.480
如果说你设置了这个

04:15.120 --> 04:16.280
它默认就是出

04:16.280 --> 04:17.560
如果你设置为它为出的话

04:17.560 --> 04:19.120
它就会自动关闭

04:19.120 --> 04:20.200
这是它三个事件

04:20.200 --> 04:22.680
这个东西我们都不用再重复说了

04:22.680 --> 04:23.440
咱们来看一下

04:23.440 --> 04:24.280
另外两个方法

04:24.280 --> 04:27.040
这是读取流里边没有的方法

04:27.040 --> 04:29.080
一个是Ride

04:29.080 --> 04:31.440
我们要写入的时候

04:31.440 --> 04:34.120
我们把它换成WS

04:34.120 --> 04:39.080
要写入的时候

04:39.080 --> 04:40.800
我们要调文它的Ride方法

04:40.800 --> 04:42.160
往里边写入

04:42.160 --> 04:43.280
这个里边data传

04:43.720 --> 04:46.160
这个data传的是字符串

04:46.160 --> 04:47.600
或者是buffer

04:47.600 --> 04:49.680
它可以寫入一组数据

04:49.680 --> 04:52.640
咱们这里的Ride

04:52.640 --> 04:54.040
来写入一组数据

04:54.040 --> 04:56.360
比方说我们写入一个A

04:56.360 --> 04:57.760
看一下吧

04:57.760 --> 04:58.400
写入一个A

04:58.400 --> 05:02.380
我们来运行

05:02.380 --> 05:06.820
power show load index

05:06.820 --> 05:07.820
运行完成了

05:07.820 --> 05:07.980
好

05:07.980 --> 05:08.620
接下来我们来看一下

05:08.620 --> 05:10.180
这里是不是多了一个abc文件

05:10.180 --> 05:10.580
对吧

05:10.580 --> 05:12.020
那这里是有了一个A

05:12.020 --> 05:12.900
就这么简单

05:12.900 --> 05:14.220
是不是特别简单

05:14.260 --> 05:16.260
这里就是如何去写入

05:16.260 --> 05:17.660
我这里要说一下

05:17.660 --> 05:19.700
它会返回一个布尔兹

05:19.700 --> 05:21.420
因为它会返回一个结果

05:21.420 --> 05:22.420
返回什么结果呢

05:22.420 --> 05:23.740
我们来接受一下

05:23.740 --> 05:25.860
flag

05:25.860 --> 05:26.820
this constant

05:26.820 --> 05:30.460
这个地方稍微有点点绕

05:30.460 --> 05:33.020
大家要特别注意

05:33.020 --> 05:34.660
我们这里输出一下flag

05:34.660 --> 05:36.780
它返回的是一个布尔兹

05:36.780 --> 05:38.620
你看它这里输出的是true

05:38.620 --> 05:41.340
那么这个布尔兹是什么意思呢

05:41.340 --> 05:42.980
这样看一下

05:43.020 --> 05:45.820
它如果说返回的是true的话

05:45.820 --> 05:50.660
表示你写入通道没有被填满

05:50.660 --> 05:52.260
表示接下来的数据

05:52.260 --> 05:55.460
可以直接写入无需排队

05:55.460 --> 05:56.420
这说的啥意思啊

05:56.420 --> 05:57.740
这个给大家看一张图

05:59.420 --> 06:01.060
放大一点

06:01.060 --> 06:02.820
当我们雕用这个route

06:02.820 --> 06:04.380
方法往里边写东西的时候

06:04.380 --> 06:06.180
这里是不是要写的内容

06:06.180 --> 06:08.780
这里是不是每一次写入的字节数

06:08.780 --> 06:09.340
对吧

06:09.340 --> 06:10.580
那么这个内容是一个字节

06:10.580 --> 06:10.780
对吧

06:10.780 --> 06:13.900
这里一次可以写入两个字节

06:13.900 --> 06:17.220
那么如果说你写入的东西

06:17.220 --> 06:18.460
它是通过一个通道

06:18.460 --> 06:18.660
对吧

06:18.660 --> 06:21.220
我们你可以想象成内存

06:21.220 --> 06:23.860
到那个磁盘之间有一个通道

06:23.860 --> 06:25.500
但是实际上不是这样子

06:25.500 --> 06:27.100
实际上内存要到写到磁盘

06:27.100 --> 06:27.860
还有很多东西

06:27.860 --> 06:30.100
比如说CPU要参与

06:30.100 --> 06:32.500
还有这个磁盘的驱动程序也要参与

06:32.500 --> 06:34.980
但是我们可以简单的把个模型简化

06:34.980 --> 06:39.220
想象成磁盘和我们的内存里边

06:39.220 --> 06:40.660
有一个通道

06:40.660 --> 06:42.780
如果说你写入的东西

06:42.780 --> 06:45.580
这个通道能够装入的东西是多少呢

06:45.580 --> 06:48.380
就是你这里设置的两个字节

06:48.380 --> 06:49.900
当然默认是16个字节

06:49.900 --> 06:51.260
默认是16KB

06:51.260 --> 06:52.620
它默认是这个字

06:52.620 --> 06:54.940
1024是16KB很大了

06:54.940 --> 06:58.380
我们这里为了测试就写两个字节

06:58.380 --> 07:01.020
如果说你这一次写入

07:01.020 --> 07:03.820
它能够把这个通道塞满

07:03.820 --> 07:04.740
只要能够塞满

07:04.740 --> 07:07.540
当然就大于等于这个通道能装

07:07.540 --> 07:08.300
装下的数量

07:08.300 --> 07:10.580
它就会返回force

07:10.580 --> 07:12.460
如果说你写入的东西

07:12.460 --> 07:14.460
它没有把这个通道塞满

07:14.460 --> 07:15.140
说明什么呢

07:15.140 --> 07:17.020
你看看这个地方

07:17.020 --> 07:18.180
我这里划了一个虚线

07:18.180 --> 07:19.060
表示什么意思

07:19.060 --> 07:22.100
就是下一次写入的时候

07:22.100 --> 07:23.380
因为这个写入的过程

07:23.380 --> 07:25.340
是比内存处理要慢得多的

07:25.340 --> 07:26.220
我们之前说过

07:26.220 --> 07:29.580
磁盘对数据的处理要慢很多很多

07:29.580 --> 07:31.660
跟内存是远远没法比的

07:31.660 --> 07:34.380
那么如果说你这一句话调用完了

07:34.380 --> 07:37.060
我如果说我在下一句话再调用

07:37.060 --> 07:40.340
RiseB

07:40.380 --> 07:42.540
那么这个B是不是可以比较说一开始

07:42.540 --> 07:43.700
比较说这里是3

07:43.700 --> 07:45.460
我这里一开始写入A,B

07:45.460 --> 07:47.460
那么下一个我再写入一个C

07:47.460 --> 07:49.620
那你看内存的处理速度非常非常快

07:49.620 --> 07:51.060
这是内存里边的运行的代码

07:51.060 --> 07:52.580
它这个东西扔到哪去了

07:52.580 --> 07:54.420
它是不是扔到这个流利边去了

07:54.420 --> 07:54.660
对吧

07:54.660 --> 07:55.780
我们一次要写入3

07:55.780 --> 07:56.620
可以写入3KB

07:56.620 --> 07:57.980
但是我现在写入了几个

07:57.980 --> 07:59.220
现在写入了两个

07:59.220 --> 08:00.140
就表示说

08:00.140 --> 08:01.100
它返回了一个处理

08:01.100 --> 08:01.740
表示说

08:01.740 --> 08:04.260
如果说你下一次再写入

08:04.260 --> 08:05.860
下一次写入的时候

08:05.860 --> 08:08.460
你不用排队了

08:08.460 --> 08:09.860
你直接会加进来

08:09.860 --> 08:11.180
继续往后面写

08:11.180 --> 08:12.100
就这么个意思

08:12.100 --> 08:12.900
明白吧

08:12.900 --> 08:14.660
就是这里还空了一个位置

08:14.660 --> 08:15.060
对吧

08:15.060 --> 08:16.380
可以直接拿出来写

08:16.380 --> 08:18.380
这就是它返回Q的意思

08:18.380 --> 08:20.620
那如果说你这里写的是A,B,C

08:20.620 --> 08:23.060
它返回的是Q还是Force

08:23.060 --> 08:24.060
你想一想

08:24.060 --> 08:26.180
我这里是三个字节

08:26.180 --> 08:27.220
那就是Force

08:27.220 --> 08:29.540
它就表示下一次你再写的时候

08:29.540 --> 08:30.500
你就写不进去了

08:30.500 --> 08:31.260
因为这个满了

08:31.260 --> 08:32.300
要排队

08:32.300 --> 08:33.020
在哪里排队

08:33.020 --> 08:34.700
在内存里边排队

08:34.700 --> 08:37.100
内存里面等着排号队

08:37.140 --> 08:39.140
那么我们等着下一次再写

08:39.140 --> 08:39.740
看一下吧

08:39.740 --> 08:41.740
那么我们这里写入A,B,C

08:43.060 --> 08:44.620
你看返回的是不是Force

08:44.620 --> 08:45.180
对吧

08:45.180 --> 08:47.100
那如果说我这里写个中文呢

08:48.580 --> 08:50.100
中文返回什么呢

08:51.100 --> 08:52.460
想一想返回什么呢

08:52.460 --> 08:53.300
排字返回Force

08:53.300 --> 08:53.980
因为什么呢

08:53.980 --> 08:56.100
UTF-8是一个什么样的

08:56.100 --> 08:57.020
就是电码

08:57.020 --> 08:57.860
就是中文的话

08:57.860 --> 08:58.940
它是三个字节

08:58.940 --> 08:59.460
对吧

08:59.460 --> 09:00.300
那中文一写

09:00.300 --> 09:01.100
是不是把排满了

09:01.100 --> 09:01.820
三个字节

09:01.820 --> 09:02.660
三个字节排满了

09:02.660 --> 09:04.180
下一次就没有办法

09:04.180 --> 09:05.100
就必须排队了

09:05.100 --> 09:05.460
对吧

09:05.460 --> 09:07.700
它就没有办法直接写入进去了

09:07.700 --> 09:08.540
就这么个意思

09:08.540 --> 09:09.420
它要排队了

09:09.420 --> 09:10.660
排队过后怎么办呢

09:10.660 --> 09:12.620
它会自动慢慢写入

09:12.620 --> 09:14.340
比方说你排号队

09:14.340 --> 09:15.020
后面过后了

09:15.020 --> 09:16.340
它就把这一部分写完了

09:16.340 --> 09:17.380
因为磁盘很慢

09:17.380 --> 09:18.460
理事中要记住

09:18.460 --> 09:20.260
内存排队是非常非常快的

09:20.260 --> 09:21.700
一下子排了很多人

09:21.700 --> 09:22.260
然后呢

09:22.260 --> 09:23.220
磁盘很慢

09:23.220 --> 09:26.180
然后慢慢慢慢给它写入进去

09:26.180 --> 09:26.860
按照这个堆疊

09:26.860 --> 09:28.780
它内部会自动进行处理

09:28.780 --> 09:29.700
没有这意思吧

09:29.700 --> 09:30.180
ok

09:30.180 --> 09:32.740
这就是它这个flag是什么意思

09:32.740 --> 09:34.540
如果说我这里是四个字节

09:34.540 --> 09:35.220
那写个中文

09:35.220 --> 09:36.700
它就返回处了

09:36.700 --> 09:37.180
你看

09:37.180 --> 09:38.340
就这么个道理

09:38.340 --> 09:40.140
这是关于这个flag是什么意思

09:40.140 --> 09:41.380
一样搞清楚

09:41.380 --> 09:41.660
好

09:41.660 --> 09:43.020
如果说返回force

09:43.020 --> 09:43.980
表示什么意思呢

09:43.980 --> 09:46.820
表示的是目前的通道已经满了

09:46.820 --> 09:48.300
它已经装满了

09:48.300 --> 09:49.500
以后边写的

09:49.500 --> 09:50.820
你看这张图

09:50.820 --> 09:51.860
它不仅自己满了

09:51.860 --> 09:53.060
而且已经有排队了

09:53.060 --> 09:53.660
对吧

09:53.660 --> 09:54.940
哪怕这个时候没有排队

09:54.940 --> 09:56.300
它返回的也是force

09:56.300 --> 09:58.460
表示下一次你写东东西的时候

09:58.460 --> 09:59.460
必须要排队了

09:59.460 --> 10:00.100
它在哪里排

10:00.100 --> 10:01.180
在内存里边排

10:01.180 --> 10:02.260
它在内部呢

10:02.260 --> 10:04.460
会维护一个对电

10:04.500 --> 10:05.460
你可以把理解回忆

10:05.460 --> 10:06.580
就是一个数组

10:06.580 --> 10:07.420
往里面排

10:07.420 --> 10:07.740
对吧

10:07.740 --> 10:08.740
要写的东西

10:08.740 --> 10:09.940
它就把东西放到内存里面

10:09.940 --> 10:10.740
让你排

10:10.740 --> 10:12.380
就这么个意思

10:12.380 --> 10:13.060
那么比方说

10:13.060 --> 10:15.420
我们这里每一次写了过后

10:15.420 --> 10:18.100
我们再把输出一下

10:18.100 --> 10:19.340
多写几次

10:22.340 --> 10:25.980
复制

10:25.980 --> 10:28.140
我们这里就写一个A

10:29.900 --> 10:31.060
这里写都写A吗

10:31.060 --> 10:31.980
都写A

10:35.620 --> 10:35.820
好

10:35.820 --> 10:36.700
咱们来看一下

10:37.660 --> 10:39.700
来体会一下这个过程

10:41.500 --> 10:42.420
你看

10:42.420 --> 10:44.460
我们这里是三个字节对吧

10:44.460 --> 10:45.420
第一是写个A

10:45.420 --> 10:46.460
因为它磁盘触

10:46.460 --> 10:47.460
始终要记住

10:47.460 --> 10:49.580
磁盘的处理速度是很慢的

10:49.580 --> 10:50.300
非常非常慢

10:50.300 --> 10:52.020
就像一个

10:52.020 --> 10:53.140
你们可以这样理解

10:53.140 --> 10:54.660
你们平时有的时候

10:54.660 --> 10:56.620
搞什么超市里面搞活动

10:56.620 --> 10:56.860
对吧

10:56.860 --> 10:58.380
很多人涌入超市

10:58.380 --> 11:00.020
在超市里边各屋的人

11:00.020 --> 11:01.380
就是磁盘了

11:01.380 --> 11:01.660
对吧

11:01.660 --> 11:03.300
它很慢的处理

11:03.300 --> 11:04.340
然后外一边的人

11:04.340 --> 11:05.460
就是内存

11:05.460 --> 11:06.380
丰庸而至

11:06.420 --> 11:07.300
所以说

11:07.300 --> 11:10.020
超市可能撑不住这么多数据

11:10.020 --> 11:11.420
它在慢慢一个一个来

11:11.420 --> 11:12.620
等里边的人出来了

11:12.620 --> 11:13.460
后边的人进去

11:13.460 --> 11:14.980
但是磁盘它也不会出来

11:14.980 --> 11:16.060
不太恰当的例子

11:16.060 --> 11:17.220
就这么个意思

11:17.220 --> 11:18.300
那么你可以看到

11:18.300 --> 11:19.820
这里前两次

11:19.820 --> 11:22.300
磁盘的就是内存处理的速度非常快

11:22.300 --> 11:23.580
代码运行速度非常快

11:23.580 --> 11:24.180
前两次

11:24.180 --> 11:26.660
所以一下就写了两个A进去

11:26.660 --> 11:29.060
这两个也排到哪去了

11:29.060 --> 11:29.740
你看

11:29.740 --> 11:31.500
第一次排一个A

11:31.500 --> 11:33.220
第一次排一个A

11:33.220 --> 11:34.540
是不是排了一个字节在这

11:34.540 --> 11:35.740
排了一个字节

11:35.820 --> 11:36.740
还有两个

11:36.740 --> 11:37.740
还有两个控制

11:37.740 --> 11:39.860
这个时候磁盘还没有反应过来

11:39.860 --> 11:42.340
然后你马上又来了一个

11:42.340 --> 11:43.940
马上又来了一个

11:43.940 --> 11:45.260
又来了一个过后

11:45.260 --> 11:47.260
是不是第二次也返回出

11:47.260 --> 11:48.100
你看第一个字节

11:48.100 --> 11:48.780
磁盘第一个字节

11:48.780 --> 11:50.100
都还没来得及写进去

11:50.100 --> 11:51.620
然后第二个字节又来了

11:51.620 --> 11:52.900
那么这个时候还是没砍满

11:52.900 --> 11:53.420
还是没砍满

11:53.420 --> 11:55.060
它还是返回出

11:55.060 --> 11:57.060
然后第三个字节又来了

11:57.060 --> 11:58.620
那么这个时候第三个字节来了过后

11:58.620 --> 12:00.540
这个磁盘都还没有反应过来

12:00.540 --> 12:01.180
磁盘的速度

12:01.180 --> 12:02.700
你不知道它什么时候写完

12:02.700 --> 12:04.060
反应的速度很慢

12:04.060 --> 12:05.260
那么这个时候

12:05.300 --> 12:06.220
第三个字排过来了

12:06.220 --> 12:07.380
第三个排过来是不是扎满了

12:07.380 --> 12:08.420
扎满了就返回Force了

12:08.420 --> 12:10.420
所以说第三个呢返回的是Force

12:10.420 --> 12:12.260
那么后边来了全部要排队了

12:12.260 --> 12:13.980
在这里边全部排队了

12:13.980 --> 12:15.500
就这么个意思

12:15.500 --> 12:17.420
这就是它的写入方式

12:17.420 --> 12:20.860
当然它最终肯定是会把它完全写完的

12:20.860 --> 12:23.940
那么这里就会产生一个问题

12:23.940 --> 12:25.220
什么问题呢

12:25.220 --> 12:26.500
就是被押问题

12:26.500 --> 12:27.500
什么叫被押

12:27.500 --> 12:30.260
你看看由于我们的程序的运行速度

12:30.260 --> 12:32.340
非常非常之快

12:32.340 --> 12:34.900
那么如果说你在这里

12:34.940 --> 12:36.940
比方说你来了这么一个东西

12:36.940 --> 12:37.940
你写了一个循环

12:37.940 --> 12:39.420
或者就用一个Force循环

12:42.060 --> 12:42.780
Force循环

12:44.340 --> 12:46.700
我要写多少个字节呢

12:46.700 --> 12:50.180
我就写个一百兆吧

12:51.020 --> 12:52.460
反正我这个东西一把去掉了

12:52.460 --> 12:53.340
在Gitre

12:53.340 --> 12:55.300
在Gitre一个路里边把去掉了

12:55.300 --> 12:56.980
我写个实兆吧

12:56.980 --> 12:58.980
实兆也不要太夸张了

12:58.980 --> 13:01.380
从零开始

13:01.380 --> 13:03.620
小于实兆是多少呢

13:03.620 --> 13:06.500
一个字节是1024KB

13:06.500 --> 13:08.580
每个KB

13:09.860 --> 13:11.980
一个字节是1024KB

13:11.980 --> 13:16.660
每个一兆是1024KB

13:18.140 --> 13:20.020
一KB是1024KB

13:20.020 --> 13:23.020
一兆是1024KB

13:23.020 --> 13:24.940
然后实兆成一实

13:24.940 --> 13:27.500
咱们来循环这么多次

13:27.500 --> 13:29.620
每次就写一个字节

13:30.340 --> 13:31.780
每次就写一个字节

13:31.980 --> 13:33.820
这个时间肯定是很长的

13:33.820 --> 13:35.060
那么我们每一次

13:35.060 --> 13:36.500
WS write

13:36.500 --> 13:38.220
我这里不能把它返回来说

13:38.220 --> 13:39.940
那肯定是他一次只能写三个字节

13:39.940 --> 13:40.420
对吧

13:40.420 --> 13:42.180
那么我们一次直写一个字节

13:42.180 --> 13:42.620
一个字节

13:42.620 --> 13:44.220
我们写实兆的数据

13:44.220 --> 13:45.500
到这个文件里边

13:45.500 --> 13:47.900
那么实兆的数据写啥呢

13:47.900 --> 13:48.980
就随便写

13:48.980 --> 13:50.100
随便写

13:50.100 --> 13:53.140
我们来一个写个啥吧

13:53.140 --> 13:54.220
就写一个A

13:54.220 --> 13:56.180
好吧就写一个A

13:56.180 --> 13:58.060
那么我们这里写一个buffer

13:58.060 --> 14:00.260
fromA

14:00.260 --> 14:01.540
对写一个字节

14:01.620 --> 14:03.500
或者我们这里也就是一个字节

14:03.500 --> 14:04.580
对吧写一个A

14:05.580 --> 14:07.300
那么理想一下

14:07.300 --> 14:11.700
这样子的结果是不是会导致排队

14:11.700 --> 14:13.580
是不是一定会导致排队

14:13.580 --> 14:14.340
对不对

14:14.340 --> 14:17.520
咱们来写一下

14:17.520 --> 14:19.080
你看现在卡住了

14:19.080 --> 14:21.520
它会有大量的排队在这里

14:21.520 --> 14:22.600
然后排队会越来越多

14:22.600 --> 14:23.960
因为尺碟的处理速度很慢

14:23.960 --> 14:25.080
它一次只能写一点点

14:25.080 --> 14:26.520
一次一点点

14:26.520 --> 14:27.560
那么很慢的就出写

14:27.560 --> 14:29.360
但是内存速度非常非常快

14:29.360 --> 14:31.000
导致了大量的排队

14:31.000 --> 14:32.120
那么就表示

14:32.160 --> 14:33.680
这个通道后边

14:33.680 --> 14:35.560
是不是给它很大的压力

14:35.560 --> 14:36.760
就像水管一样

14:36.760 --> 14:38.040
这个水管要爆炸了

14:38.040 --> 14:39.120
后边的压力太大了

14:39.120 --> 14:41.200
我们把它称之为被压问题

14:41.200 --> 14:42.400
它产生了被压

14:42.400 --> 14:44.600
就是内存里面积压了太多的数据

14:44.600 --> 14:46.680
而硬盘它写不过来

14:46.680 --> 14:48.680
那么这会导致一个什么样的问题呢

14:48.680 --> 14:50.080
因为内存是有限的

14:50.080 --> 14:51.600
内存的资源是非常保贵的

14:51.600 --> 14:53.040
你看它还没写完

14:53.040 --> 14:54.880
内存的资源是很保贵的

14:54.880 --> 14:58.080
那么会导致它占用的内存非常非常高

14:58.080 --> 15:00.040
就全部积压在内存里面

15:00.040 --> 15:01.360
它会导致这样的问题

15:01.400 --> 15:03.480
那么这就把它叫做被压问题

15:03.480 --> 15:04.520
别人的意思吧

15:04.520 --> 15:06.720
好 那么我们在特别是在写入流的

15:06.720 --> 15:07.720
写东西的时候

15:07.720 --> 15:10.960
由于我们是从内存到硬盘

15:10.960 --> 15:14.680
因此我们内存一定要注意这个被压问题

15:14.680 --> 15:16.960
那么这个被压问题怎么解决呢

15:16.960 --> 15:18.800
其实非常简单

15:18.800 --> 15:20.840
好 写完了

15:20.840 --> 15:22.640
这个文件已经特别夸张了

15:22.640 --> 15:24.040
这个文件已经特别夸张了

15:24.040 --> 15:27.160
我们看一下吧 资源管理器里面

15:27.160 --> 15:28.240
看一下

15:28.240 --> 15:30.200
实兆了 对吧 大小实兆

15:31.160 --> 15:32.960
那么这个问题怎么来解决呢

15:32.960 --> 15:34.240
我们换一个名字

15:34.240 --> 15:35.400
这个文件保留在这儿

15:35.400 --> 15:36.520
我们以后还要用的

15:39.560 --> 15:40.560
ABC2嘛

15:42.680 --> 15:44.480
怎么来解决这个问题呢

15:44.480 --> 15:48.000
我们就可以利用它返回的这个东西

15:48.000 --> 15:49.520
我们可以利用它返回的

15:51.960 --> 15:54.160
它返回的这个flag

15:54.160 --> 15:55.400
那么它为True的时候

15:55.400 --> 15:57.120
表示的是我写的没问题 对吧

15:57.120 --> 15:58.720
还可以往里面写

15:58.760 --> 16:00.320
它返回的force表示

16:00.320 --> 16:02.680
别写了 等一会吧

16:02.680 --> 16:04.440
你摘往里面写就要排队了 对吧

16:04.440 --> 16:05.120
它返回的force

16:05.120 --> 16:06.800
是不是表示后边要排队了

16:06.800 --> 16:07.400
后边要排队

16:07.400 --> 16:09.120
我是不是可以不用着急写了

16:09.120 --> 16:12.480
等一会 等它可以写的时候

16:12.480 --> 16:13.600
我再来写

16:13.600 --> 16:14.480
好 那么这个代码

16:14.480 --> 16:17.120
我们重新来设计一下

16:17.120 --> 16:18.040
这里怎么写呢

16:18.040 --> 16:21.600
我们还是ABC嘛

16:21.600 --> 16:22.280
ABC

16:22.280 --> 16:24.000
那么把文件重新覆盖掉

16:24.000 --> 16:26.160
把它删除掉 把它重新覆盖掉

16:26.160 --> 16:27.760
好 这里我们专门来写个函数

16:29.240 --> 16:32.520
well

16:32.520 --> 16:34.160
那边一个方形

16:34.160 --> 16:36.920
write 写这么一个函数

16:36.920 --> 16:40.000
这里呢 我定一个全句变量i

16:40.000 --> 16:43.480
表示呢 我现在写到多少了

16:43.480 --> 16:45.640
那么这个函数里边我怎么写呢

16:45.640 --> 16:48.720
我是不是一次就写一个write

16:48.720 --> 16:49.480
A 对吧

16:49.480 --> 16:50.920
我们一次就写一个

16:50.920 --> 16:52.400
它会返回一个什么呢

16:52.400 --> 16:54.680
它会返回一个flag

16:54.680 --> 16:56.400
表示下一次

16:56.440 --> 16:58.640
就是写入A

16:58.640 --> 17:00.400
得到下一次

17:02.320 --> 17:04.480
还能不能直接写

17:05.600 --> 17:06.560
对吧

17:06.560 --> 17:08.440
好 如果说下一次还能直接写

17:08.440 --> 17:10.200
是不是我们又写入一个A

17:10.200 --> 17:10.400
对吧

17:10.400 --> 17:13.000
所以说我们这里可以用个Y有循环

17:13.000 --> 17:14.800
我们一共要写多少字节呢

17:14.800 --> 17:17.320
一共要写入这么多的字节

17:18.280 --> 17:18.600
对吧

17:18.600 --> 17:19.520
我们是不是一次要写

17:19.520 --> 17:20.680
一共要写入这么多字节

17:20.680 --> 17:22.440
你只要小微它就行了

17:22.440 --> 17:23.800
并且呢

17:23.800 --> 17:26.080
flag我们提前面来

17:26.120 --> 17:29.010
flag

17:29.010 --> 17:30.530
q 一开始为q

17:30.530 --> 17:32.010
表示一开始最开始的时候

17:32.010 --> 17:33.410
肯定是可以写的对吧

17:33.410 --> 17:35.050
最开始肯定是可以写的

17:35.050 --> 17:37.010
如果说你可以写

17:37.010 --> 17:38.530
OK

17:38.530 --> 17:40.130
那么我就写

17:40.130 --> 17:41.090
写了之后呢

17:41.090 --> 17:44.210
我还要把哀佳佳看一下一个代码

17:44.210 --> 17:45.730
那么我这里就不是这样子写了

17:45.730 --> 17:48.170
我们write

17:48.170 --> 17:48.930
你看一下

17:51.330 --> 17:53.770
我们写的方法是什么呢

17:53.770 --> 17:56.170
一直写

17:56.170 --> 18:00.810
直到到达上线

18:00.810 --> 18:04.210
或无法再写入

18:04.210 --> 18:05.490
再直接写入

18:05.490 --> 18:06.170
需要排队了

18:06.170 --> 18:07.570
无法再直接写入

18:07.570 --> 18:09.290
那么这个时候我就不写了

18:09.290 --> 18:10.810
有了这个方法存在的时候

18:10.810 --> 18:12.490
我们是不是可以解决被押问题

18:12.490 --> 18:13.690
你看

18:13.690 --> 18:14.970
一开始是可以写的

18:14.970 --> 18:16.410
我们写小于它

18:16.410 --> 18:17.970
小于它是可以写的

18:17.970 --> 18:19.210
可以写

18:19.210 --> 18:20.730
然后并且一开始为q

18:20.730 --> 18:21.330
那么就可以写

18:21.330 --> 18:23.050
我就写一次写一次

18:23.050 --> 18:24.290
它返回为q

18:24.290 --> 18:25.850
表示还可以写

18:25.890 --> 18:26.650
还没满

18:26.650 --> 18:28.050
这个通道还有三个

18:28.050 --> 18:29.130
我们还只写了一个

18:29.130 --> 18:29.730
还没满

18:29.730 --> 18:30.810
是不是又进入判断

18:30.810 --> 18:31.570
哀佳佳了

18:31.570 --> 18:33.410
那么下一次还是没得到到达容量

18:33.410 --> 18:34.450
是不是还可以写

18:34.450 --> 18:35.770
我又写一个

18:35.770 --> 18:36.490
那写了两个了

18:36.490 --> 18:37.730
还可以写

18:37.730 --> 18:38.210
还可以写

18:38.210 --> 18:39.610
我看没到达容量

18:39.610 --> 18:40.210
还可以写

18:40.210 --> 18:41.130
那我又写一个

18:41.130 --> 18:41.850
写了三个了

18:41.850 --> 18:42.610
是不是不能再写了

18:42.610 --> 18:43.890
再写就要排队了

18:43.890 --> 18:44.570
所以说

18:44.570 --> 18:46.330
这个时候判断不成功了

18:46.330 --> 18:48.410
就结束循环了

18:48.410 --> 18:49.930
那么现在请问一下

18:49.930 --> 18:52.250
我这样子做的话

18:52.250 --> 18:54.810
会在这个文件里面写出几个

18:54.850 --> 18:58.320
会写入几个

18:58.320 --> 18:59.160
想一想

18:59.160 --> 18:59.800
好好想一想

18:59.800 --> 19:01.360
会写出几个

19:01.360 --> 19:02.120
咱们来看一下

19:02.120 --> 19:03.960
你们想的是不正确的

19:03.960 --> 19:04.840
瞬间又运行完了

19:04.840 --> 19:06.000
他写入了几个呢

19:06.000 --> 19:07.560
他只写入了三个

19:07.560 --> 19:08.960
因为三个写了之后

19:08.960 --> 19:10.680
是不是就不行了

19:10.680 --> 19:11.440
没办法再写

19:11.440 --> 19:12.520
再写就排队了

19:12.520 --> 19:13.320
再写就要排队了

19:13.320 --> 19:15.000
所以说不能再写了

19:15.000 --> 19:16.600
那么让硬盘处理一会

19:16.600 --> 19:17.960
让子弹飞一会

19:17.960 --> 19:18.760
那么因此

19:18.760 --> 19:19.200
他飞一会

19:19.200 --> 19:20.600
我后续没有操作了

19:20.600 --> 19:21.200
你看到没

19:21.200 --> 19:22.920
我后续是不是没有操作了

19:22.920 --> 19:23.760
没有操作了

19:23.760 --> 19:25.800
然后这个时候就不再写入了

19:25.840 --> 19:27.280
最终的只写了三个

19:28.480 --> 19:30.880
那么我们如何能达到写个实兆

19:30.880 --> 19:33.120
又不造成被压问题呢

19:33.120 --> 19:34.840
这个时候就要知道

19:34.840 --> 19:37.600
它里边还有一个事件

19:37.600 --> 19:39.320
当我们调入rider的时候

19:39.320 --> 19:41.720
它会有可能会造成排队

19:43.160 --> 19:44.040
那么排队过后

19:44.040 --> 19:46.440
它会有一个事件触发

19:46.440 --> 19:48.920
就是当我们写入对列清空时

19:48.920 --> 19:50.280
会触发运事件

19:50.280 --> 19:51.560
什么意思

19:51.560 --> 19:52.600
就说你不是排队吗

19:52.600 --> 19:53.080
对吧

19:53.080 --> 19:54.280
好排队我就不要写了

19:54.360 --> 19:54.800
不要写了

19:54.800 --> 19:55.240
等一会

19:56.360 --> 19:57.640
等什么

19:57.640 --> 19:59.080
等你这个通道清空

19:59.080 --> 20:00.600
我对列全部没东西了

20:00.600 --> 20:02.040
通道又清空了

20:02.040 --> 20:02.800
表示迟判

20:02.800 --> 20:04.240
我终于处理完了

20:04.240 --> 20:05.200
处理完了过后

20:05.200 --> 20:06.600
表示你现在可以不用排队

20:06.600 --> 20:07.960
就接着来写了

20:07.960 --> 20:09.000
那么这个时候

20:09.000 --> 20:11.160
它会触发一个事件叫做俊

20:11.160 --> 20:11.920
俊什么意思

20:11.920 --> 20:13.720
干河干枯

20:13.720 --> 20:14.320
干枯什么意思

20:14.320 --> 20:15.040
就排完了

20:15.040 --> 20:15.800
谁排完了

20:15.800 --> 20:16.840
我已经处理完了

20:16.840 --> 20:18.760
它会触发这个事件

20:18.760 --> 20:19.400
这个事件注意

20:19.400 --> 20:21.200
它不是写一次就触发一次

20:21.200 --> 20:23.720
它是等我这个通道清空之后

20:23.760 --> 20:26.400
表示马可以直接再写入了

20:26.400 --> 20:27.680
是不是就可以触发这个事件

20:27.680 --> 20:27.880
好

20:27.880 --> 20:29.360
咱们来看一下

20:29.360 --> 20:30.960
我们这里这里注册一个事件

20:30.960 --> 20:35.720
俊

20:35.720 --> 20:37.000
输出

20:37.000 --> 20:39.320
可以再一次写入了

20:39.320 --> 20:39.880
你看一下

20:39.880 --> 20:41.080
这个事件它会怎么触发

20:42.720 --> 20:43.480
对不对

20:43.480 --> 20:44.800
是不是只触发了一次

20:44.800 --> 20:45.040
对吧

20:45.040 --> 20:45.920
我们写了几次

20:45.920 --> 20:47.040
我们写了三次

20:47.040 --> 20:48.640
但它只触发了一次

20:48.640 --> 20:49.360
对吧

20:49.360 --> 20:49.880
为什么呢

20:49.880 --> 20:52.400
因为只触发了这一次过后

20:52.400 --> 20:53.880
是不是就把它清空了

20:53.880 --> 20:54.120
对吧

20:54.120 --> 20:54.920
他们写了三次

20:54.920 --> 20:56.240
三次可以一起写入到硬盘

20:56.240 --> 20:57.520
因为我们这里是3

20:57.520 --> 20:59.520
三个东西一起写入到硬盘

20:59.520 --> 21:01.040
但我们一般不会用这么小

21:01.040 --> 21:03.200
一般是16kb就差不多

21:03.200 --> 21:04.680
我们写了三次过后

21:04.680 --> 21:07.520
它就会就是送到硬盘里边

21:07.520 --> 21:08.840
送到硬盘里边过后了

21:08.840 --> 21:10.160
那么对立清空了

21:10.160 --> 21:11.440
清空过后就排干了

21:11.440 --> 21:12.760
排干过后它就会触发这个军

21:14.640 --> 21:15.240
原来的意思吧

21:16.520 --> 21:19.880
那如果说我只写入两个字节

21:19.880 --> 21:21.880
你看一下这个军会不会触发呢

21:23.120 --> 21:23.960
写一下

21:23.960 --> 21:25.120
是不是不会触发

21:25.120 --> 21:25.600
对吧

21:25.640 --> 21:26.480
是不是不会触发

21:26.480 --> 21:27.760
一开始它就是空弦的

21:27.760 --> 21:28.160
对吧

21:28.160 --> 21:29.440
它一直是可以写东西的

21:29.440 --> 21:30.680
它是什么时候触发

21:30.680 --> 21:33.360
就是通道排满了

21:33.360 --> 21:35.760
就是绿色的通道排满了

21:35.760 --> 21:36.520
排满了过后

21:36.520 --> 21:38.000
它把清空过后才会触发

21:38.000 --> 21:38.640
你没有排满

21:38.640 --> 21:39.880
它是不会触发的

21:39.880 --> 21:40.320
没有排满

21:40.320 --> 21:42.040
你表示还可以直接往里面整

21:42.040 --> 21:42.320
对吧

21:42.320 --> 21:43.600
它不会触发

21:43.600 --> 21:45.880
它这么个意思搞清楚

21:45.880 --> 21:47.800
那么现在我们有了这么一个事件

21:47.800 --> 21:49.440
已经了这种模式过后了

21:49.440 --> 21:52.240
我们再要写入十兆的数据

21:52.240 --> 21:53.440
该怎么写呢

21:53.440 --> 21:54.000
就这样呗

21:56.600 --> 21:57.840
是不是这样子写

21:58.840 --> 22:00.480
对掉那个方法

22:00.480 --> 22:01.160
对吧

22:01.160 --> 22:02.240
我一开始写

22:02.240 --> 22:03.520
写到底不能写为止

22:03.520 --> 22:04.120
不能写用的

22:04.120 --> 22:04.920
你是处理一会吧

22:04.920 --> 22:05.480
不管了

22:05.480 --> 22:06.440
我去做后边的事情

22:06.440 --> 22:07.200
因为都是一步的

22:07.200 --> 22:08.520
我去做后边的事情

22:08.520 --> 22:10.440
好等你那边处理完了过后

22:10.440 --> 22:11.880
我再接着写吧

22:11.880 --> 22:12.840
接着写一些

22:12.840 --> 22:14.320
写些是不是又写不动了

22:14.320 --> 22:14.560
对吧

22:14.560 --> 22:15.520
写着写着又写不动了

22:15.520 --> 22:16.480
因为它又继续运行

22:16.480 --> 22:18.720
又写了三个又写不动了

22:18.720 --> 22:19.760
写不动了过后

22:19.760 --> 22:20.880
是不是又等着

22:20.880 --> 22:21.320
对吧

22:21.320 --> 22:22.040
又等着

22:22.040 --> 22:23.000
等着过后

22:23.000 --> 22:24.760
一会它写完了过后又触发

22:24.760 --> 22:26.240
这个时间又运行这个函数

22:26.240 --> 22:26.520
对吧

22:26.520 --> 22:27.320
又来写吧

22:27.320 --> 22:28.040
又来写

22:28.040 --> 22:29.600
一写又写了几个

22:29.600 --> 22:30.600
又写不了了

22:30.600 --> 22:31.840
等着等完了过后

22:32.840 --> 22:33.280
写完了

22:33.280 --> 22:34.760
它又触发这个时间

22:34.760 --> 22:36.480
所以这个时间就会多次被触发

22:36.480 --> 22:37.280
然后一次写一段

22:37.280 --> 22:39.160
也是一次写几个

22:39.160 --> 22:39.880
一次写几个

22:39.880 --> 22:41.360
最终的把这个时招写完

22:42.160 --> 22:42.920
这样的意思

22:42.920 --> 22:43.120
好

22:43.120 --> 22:44.000
咱们来看一下

22:44.000 --> 22:45.120
这个它就不会造成被压

22:46.320 --> 22:46.760
没保存

22:48.560 --> 22:49.640
它就不会造成被压问题

22:49.640 --> 22:50.720
但是运行的速度

22:50.720 --> 22:52.360
肯定还是要运行很久

22:52.360 --> 22:53.440
但是它内存占用

22:53.440 --> 22:54.760
就不会有个之前那么高了

22:54.760 --> 22:56.080
之前内存占用太高了

22:56.080 --> 22:57.280
因为它会排队

22:57.280 --> 22:58.560
会排很多的队

22:58.560 --> 23:00.840
我这里停止吧

23:00.840 --> 23:01.960
停止

23:01.960 --> 23:02.640
我看一下这里

23:02.640 --> 23:03.440
已经写了不少了

23:04.760 --> 23:06.800
我们这里还是换成16KB

23:07.440 --> 23:08.560
16KB

23:08.560 --> 23:09.160
1024

23:10.240 --> 23:14.080
一次可以多写一点

23:14.080 --> 23:14.840
让它写吧

23:14.840 --> 23:17.520
那么这里我们就写了一个很大的文件

23:17.520 --> 23:19.240
就是它占用内存为时招

23:19.240 --> 23:20.480
这个文件我们一会还要用

23:21.800 --> 23:23.920
这就是关于这一块的东西

23:23.920 --> 23:25.040
这个Rite方法

23:25.680 --> 23:26.640
另外一个我说一下

23:26.640 --> 23:27.200
就是end

23:27.200 --> 23:28.160
end表示什么意思

23:28.160 --> 23:29.200
我不再写了

23:29.200 --> 23:30.000
我不要写了

23:30.000 --> 23:31.040
我写完了

23:31.040 --> 23:32.120
全部写完之后

23:32.320 --> 23:33.760
你雕用一次end方法

23:33.760 --> 23:34.680
手动雕用

23:34.680 --> 23:35.680
雕用一次end方法

23:35.680 --> 23:36.560
因为你不手动雕用

23:36.560 --> 23:37.760
它跟悶不知道你写完没有

23:37.760 --> 23:38.640
后续要不要写

23:38.640 --> 23:40.000
要不要关闭文件

23:40.000 --> 23:41.480
你当你雕用这个方法的时候

23:41.480 --> 23:43.040
它就会自动关闭文件

23:43.920 --> 23:45.200
当然自动关闭文件

23:45.200 --> 23:46.800
当你还要取决一个配置

23:46.800 --> 23:47.840
out to close

23:47.840 --> 23:50.240
默认就是一般不用去改它

23:51.240 --> 23:52.360
它表示我写完了

23:52.360 --> 23:54.000
里面有一个可选参数

23:54.000 --> 23:54.800
这可选参数

23:54.800 --> 23:56.080
它表示你最后一次的写入

23:56.080 --> 23:56.720
可以是支付创

23:56.720 --> 23:57.720
也可以是buffer

23:57.720 --> 23:59.920
你要用的话就可以加传进去

23:59.920 --> 24:00.080
好

24:00.080 --> 24:02.320
这是关于写完了

24:02.320 --> 24:03.840
那么又写了一个实照了出来

24:03.840 --> 24:04.880
对吧

24:04.880 --> 24:06.320
好

24:06.320 --> 24:06.600
OK

24:06.600 --> 24:10.840
那么这里是这个GIM

24:10.840 --> 24:12.200
GIM

24:12.200 --> 24:13.840
那么现在我们把这个代码

24:13.840 --> 24:14.640
复制一下

24:14.640 --> 24:16.600
这是手动

24:16.600 --> 24:19.280
Rite

24:19.280 --> 24:19.440
好

24:19.440 --> 24:20.920
接下来我们再来一个例子

24:20.920 --> 24:25.330
现在我们要做这么一件事

24:25.330 --> 24:26.410
怎么说呢

24:26.450 --> 24:28.770
我要把这个文件读出来

24:28.770 --> 24:32.450
复制到一个abc2.txt里边

24:32.450 --> 24:33.370
我要做这么一件事

24:33.370 --> 24:34.930
我要把这个文件那种读出来

24:34.930 --> 24:38.810
复制到abc2.txt

24:38.810 --> 24:40.090
咱们来看一下

24:40.090 --> 24:42.690
有哪些做法

24:42.690 --> 24:44.370
主要的做法有两种

24:44.370 --> 24:46.970
一种就是用最传统的方式

24:46.970 --> 24:47.970
什么方式呢

24:47.970 --> 24:52.010
fsredfile

24:52.010 --> 24:53.690
甚至还可以用

24:53.690 --> 24:55.850
就是方式1

24:55.970 --> 24:59.510
master1

24:59.510 --> 25:00.750
把这个拿过来

25:00.750 --> 25:02.590
这是我原来的文件

25:02.590 --> 25:04.110
就是from

25:04.110 --> 25:05.230
这是我新的文件

25:05.230 --> 25:09.230
to pass row dn20

25:09.230 --> 25:10.270
然后第二鞋杠

25:10.270 --> 25:13.790
temp abc2.txt

25:13.790 --> 25:16.030
这是第一种方式

25:16.030 --> 25:17.550
方式1

25:17.550 --> 25:18.430
我怎么做呢

25:18.430 --> 25:20.390
我把原来的文件读出来

25:20.390 --> 25:23.910
就是用fs promise

25:23.910 --> 25:25.910
redfile

25:25.950 --> 25:28.550
把这个文件读出来

25:28.550 --> 25:29.670
await

25:29.670 --> 25:32.350
打一个sync

25:32.350 --> 25:34.110
是不是得到文件内容

25:34.110 --> 25:35.030
文件内容

25:35.030 --> 25:36.310
然后把这个文件内容

25:36.310 --> 25:38.870
写到另一个文件里边去

25:38.870 --> 25:41.390
然后也是redfile

25:41.390 --> 25:42.030
to

25:42.030 --> 25:43.030
是不是写进去

25:43.030 --> 25:43.270
对吧

25:43.270 --> 25:44.790
我们用await

25:44.790 --> 25:46.270
写进去

25:46.270 --> 25:47.510
const

25:47.510 --> 25:52.060
这里我们使用

25:52.060 --> 25:53.540
不用了

25:53.540 --> 25:54.020
写

25:54.020 --> 25:55.100
它没有返回结果

25:55.100 --> 25:57.500
然后我们输出

25:57.500 --> 26:00.780
复制完成

26:00.780 --> 26:02.820
就把文件内容复制一遍

26:02.820 --> 26:03.140
对吧

26:03.140 --> 26:03.620
没问题吧

26:03.620 --> 26:04.860
to还有一个content

26:04.860 --> 26:06.740
content

26:06.740 --> 26:08.180
加进去

26:08.180 --> 26:08.340
好

26:08.340 --> 26:09.180
我们来看一下

26:09.180 --> 26:12.460
如果说用这种方式来写的话

26:12.460 --> 26:14.660
首先我们都不说内存占用了

26:14.660 --> 26:16.540
内存占用是非常恐怖的

26:16.540 --> 26:16.980
为什么

26:16.980 --> 26:18.820
它会把这个内容全部读出来

26:18.820 --> 26:19.260
读到内存

26:19.260 --> 26:19.420
对吧

26:19.420 --> 26:20.140
一共有10兆

26:20.140 --> 26:21.620
是不是全部读到内存

26:21.620 --> 26:22.340
对不对

26:22.340 --> 26:23.500
读到内存过后

26:23.500 --> 26:25.140
再一起把内存里面的数据

26:25.140 --> 26:26.180
全部羈押

26:26.180 --> 26:28.300
塞到另一个硬盘

26:28.300 --> 26:30.580
尺盘的文件里面去

26:30.580 --> 26:32.700
内存占用是非常夸张的

26:32.700 --> 26:34.220
咱们来看一下它的效率

26:34.220 --> 26:36.580
我们这里用一个console

26:36.580 --> 26:39.420
end time start

26:39.420 --> 26:41.140
time end time

26:41.140 --> 26:42.180
加一个下辆

26:42.180 --> 26:46.980
就是复制方式一

26:46.980 --> 26:48.220
我们这里

26:48.220 --> 26:49.540
console

26:49.540 --> 26:50.900
time end

26:50.900 --> 26:51.940
就是方式一

26:51.940 --> 26:52.940
看一下方式一

26:52.980 --> 26:55.900
它的就是会经过的时间

26:55.900 --> 26:58.060
mesure的一

26:58.060 --> 26:59.460
保存

26:59.460 --> 27:02.300
印象

27:02.300 --> 27:03.740
方式一用了多少时间

27:03.740 --> 27:05.260
用了98毫秒

27:05.260 --> 27:05.540
对吧

27:05.540 --> 27:06.420
用了98毫秒

27:06.420 --> 27:07.900
同样还可以

27:07.900 --> 27:08.260
对吧

27:08.260 --> 27:10.500
但它占用的内存是比较高的

27:10.500 --> 27:12.260
占用的内存是比较高的

27:12.260 --> 27:12.500
好

27:12.500 --> 27:13.620
咱们来看一下

27:13.620 --> 27:15.340
另一个

27:15.340 --> 27:17.220
方式二

27:17.220 --> 27:17.780
方式二

27:17.780 --> 27:19.700
最好的做法是怎么写呢

27:19.700 --> 27:23.260
mesure二

27:23.300 --> 27:26.820
同样的把前面的复制一下

27:26.820 --> 27:27.860
两个文件

27:27.860 --> 27:32.430
方式二是这样子

27:32.430 --> 27:33.750
复制完成

27:33.750 --> 27:34.150
它是这样子

27:34.150 --> 27:35.990
它不是把它读到内存

27:35.990 --> 27:38.510
是我用两个流

27:38.510 --> 27:40.350
一个是我们读取流

27:40.350 --> 27:41.310
我们上一课学过的

27:41.310 --> 27:42.630
就是一点一点的读

27:42.630 --> 27:43.870
读一点写一点

27:43.870 --> 27:44.910
读一点写一点

27:44.910 --> 27:45.150
对吧

27:45.150 --> 27:46.230
是不是用这种方式

27:46.230 --> 27:47.910
更加的节约内存

27:47.910 --> 27:49.030
咱们来看一下

27:49.030 --> 27:51.390
fs read

27:51.390 --> 27:52.990
create

27:52.990 --> 27:55.270
readstream

27:55.270 --> 27:56.270
create

27:56.470 --> 27:57.590
readstream

27:57.590 --> 27:59.270
把front传进去

27:59.270 --> 27:59.910
配置

27:59.910 --> 28:01.190
我们一次读多少

28:01.190 --> 28:02.750
一次就让它读默认的

28:02.750 --> 28:04.590
一次让它读默认的

28:04.590 --> 28:05.630
读一些buffer出来

28:05.630 --> 28:05.830
对吧

28:05.830 --> 28:06.830
读一些buffer

28:06.830 --> 28:07.190
好

28:07.190 --> 28:08.230
那么front

28:08.230 --> 28:09.590
我们这里产生一个什么呢

28:09.590 --> 28:11.270
产生一个写入

28:11.270 --> 28:13.070
就是读取流

28:13.070 --> 28:13.310
好

28:13.310 --> 28:13.870
读取流的时候

28:13.870 --> 28:15.070
我们是不是可以开始读取

28:15.070 --> 28:16.750
你看一下一个代码该怎么写

28:16.750 --> 28:17.790
on

28:17.790 --> 28:19.310
什么data

28:19.310 --> 28:21.270
当每读取到一些数据的时候

28:21.270 --> 28:22.350
这里是不是个buffer

28:22.350 --> 28:22.590
对吧

28:22.590 --> 28:23.310
得到一个buffer

28:23.310 --> 28:25.350
因为我们不用字无创

28:25.350 --> 28:26.230
就用buffer就够了

28:26.230 --> 28:27.070
因为我们只是复制

28:27.070 --> 28:28.590
又不用得到其他东西

28:28.590 --> 28:31.070
那么当我们得到数据过后

28:31.070 --> 28:35.310
读到一部分数据

28:35.310 --> 28:36.390
读到一部分数据干嘛

28:36.390 --> 28:37.670
是不是我们要写到

28:37.670 --> 28:38.950
把这个数据写到哪去

28:38.950 --> 28:41.510
写到abc2里面去

28:41.510 --> 28:43.830
怎么把abc2删除掉

28:43.830 --> 28:45.230
我们这里呢

28:45.230 --> 28:49.030
这里还要产生一个写入流

28:49.030 --> 28:49.910
create

28:49.910 --> 28:51.710
readstream

28:51.710 --> 28:53.030
2

28:53.030 --> 28:54.030
读一部分数据

28:54.030 --> 28:54.950
然后干嘛呢

28:54.950 --> 28:57.590
然后我要把它写到

28:57.590 --> 28:59.190
ws

28:59.190 --> 29:00.990
write

29:00.990 --> 29:01.870
写到哪去

29:01.870 --> 29:04.550
写到这个写入流里面去

29:04.550 --> 29:05.670
创科

29:05.670 --> 29:07.070
好写入过后呢

29:07.070 --> 29:08.870
他如果说读一点写一点

29:08.870 --> 29:09.590
读一点写一点

29:09.590 --> 29:10.910
就是因为他读取的速度

29:10.910 --> 29:12.430
可能被写入的速度快

29:12.430 --> 29:14.550
是不是有可能会造成什么

29:14.550 --> 29:15.990
造成被压

29:15.990 --> 29:16.190
对吧

29:16.190 --> 29:17.590
他读取的速度有可能会快

29:17.590 --> 29:19.390
或者说读取的东西呢

29:19.390 --> 29:21.070
他一次读出来64kb

29:21.070 --> 29:22.030
那么他写入的一次

29:22.030 --> 29:22.710
只能写入16

29:22.710 --> 29:23.950
是不是会造成被压

29:23.990 --> 29:25.070
如果说你这样做的话

29:25.070 --> 29:25.430
因此呢

29:25.430 --> 29:27.710
我们通常会在这里加上一个flag

29:29.830 --> 29:31.510
如果说flag为true

29:31.510 --> 29:34.150
表示下一次写入

29:34.150 --> 29:38.270
表示下一次写入会造成

29:38.270 --> 29:38.910
造成什么呢

29:38.910 --> 29:40.270
造成被压

29:40.270 --> 29:41.150
对吧

29:41.150 --> 29:43.550
flagway force

29:43.550 --> 29:45.070
他表示

29:45.070 --> 29:47.510
下一次写入会造成被压

29:47.510 --> 29:49.150
是不是这个道理

29:49.150 --> 29:50.270
好好捋一捋

29:50.270 --> 29:52.310
他读的时候是不是一块一块读

29:52.310 --> 29:52.990
一次读一块

29:53.030 --> 29:54.030
一次读一块

29:54.030 --> 29:54.870
不停的读

29:54.870 --> 29:56.430
那么读出来过后

29:56.430 --> 29:57.550
如果说返回为force

29:57.550 --> 29:58.710
表示他下一次

29:58.710 --> 29:59.630
要写入就要排队了

29:59.630 --> 30:00.470
会造成被压

30:00.470 --> 30:01.910
那么这个时候是不是应该停止

30:01.910 --> 30:02.910
不要再读了

30:02.910 --> 30:04.070
你读那么快干嘛呢

30:04.070 --> 30:05.190
我现在都写不过来了

30:05.190 --> 30:06.310
是不是不要再读了

30:06.310 --> 30:07.430
那么这个时候

30:07.430 --> 30:09.590
我们把这个data

30:09.590 --> 30:10.270
把这个flag

30:11.790 --> 30:14.070
把这个rs

30:14.070 --> 30:16.110
post停止

30:16.110 --> 30:17.790
暂停读去

30:17.790 --> 30:19.110
就不要再读了

30:19.110 --> 30:21.030
那么让他写一会

30:21.030 --> 30:21.270
好

30:21.270 --> 30:22.590
他写完了过后

30:22.630 --> 30:24.390
是不是会触发一个事件

30:24.390 --> 30:25.550
王俊

30:25.550 --> 30:27.150
是不是会触发一个事件

30:27.150 --> 30:28.190
当这个事件触发

30:28.190 --> 30:29.910
是不是又可以继续写了

30:29.910 --> 30:30.630
对吧

30:30.630 --> 30:33.390
表示可以继续写了

30:33.390 --> 30:33.670
对不对

30:33.670 --> 30:35.830
是不是可以继续写了

30:35.830 --> 30:37.150
那么可以继续写的时候

30:37.150 --> 30:38.150
干嘛呢

30:38.150 --> 30:39.310
如果他可以继续写

30:39.310 --> 30:41.390
是不是我们又让读取恢复

30:41.390 --> 30:42.190
rs

30:42.190 --> 30:43.390
re宿

30:43.390 --> 30:44.790
注意这种模式

30:44.790 --> 30:45.030
好

30:45.030 --> 30:45.950
再来读一下

30:45.950 --> 30:46.910
读不断不断的读

30:46.910 --> 30:47.670
一次读一块

30:47.670 --> 30:47.790
好

30:47.790 --> 30:48.710
你又写呗

30:48.710 --> 30:48.870
好

30:48.870 --> 30:49.790
如果说你返回为force

30:49.790 --> 30:50.590
表示

30:50.590 --> 30:51.670
被压可能会产生的

30:51.710 --> 30:53.390
让他写

30:53.390 --> 30:55.110
然后他写一会

30:55.110 --> 30:56.310
那么这个时候就我们就暂停了

30:56.310 --> 30:56.990
暂停读取了

30:56.990 --> 30:57.550
对吧

30:57.550 --> 30:58.550
他写了过程中

30:58.550 --> 30:59.390
然后呢

30:59.390 --> 31:00.190
写完了过后

31:00.190 --> 31:01.790
又可以继续恢复读取了

31:01.790 --> 31:01.950
好

31:01.950 --> 31:03.550
一读是不是又造成被压

31:03.550 --> 31:04.630
又停止

31:04.630 --> 31:05.550
然后呢

31:05.550 --> 31:07.150
写完了过后又恢复

31:07.150 --> 31:07.510
对吧

31:07.510 --> 31:09.150
他就这样子不断的处理

31:09.150 --> 31:09.750
知道吧

31:09.750 --> 31:10.670
内容写完

31:10.670 --> 31:12.790
什么时候我们表示内容写完了呢

31:12.790 --> 31:13.790
是不是读完了

31:13.790 --> 31:15.270
读完了rs on

31:15.270 --> 31:16.630
什么end

31:16.630 --> 31:16.950
对吧

31:18.750 --> 31:19.910
rs on close

31:19.910 --> 31:20.390
对吧

31:20.390 --> 31:21.150
是不是读完了

31:21.150 --> 31:22.710
读完了他会自动关闭吗

31:22.710 --> 31:23.630
当读完的时候

31:23.630 --> 31:26.150
是不是表示写完了

31:26.150 --> 31:26.870
对不对

31:26.870 --> 31:27.870
是不是写完了

31:27.870 --> 31:28.070
好

31:28.070 --> 31:28.790
写完了之后

31:28.790 --> 31:30.030
我们把统计代码放这儿

31:31.310 --> 31:32.830
写完了之后干嘛

31:32.830 --> 31:33.550
写完了之后

31:33.550 --> 31:36.430
是不是ws end关闭

31:37.750 --> 31:39.150
关闭写入流

31:40.670 --> 31:42.190
你看一下是不是这个逻辑

31:42.190 --> 31:42.350
好

31:42.350 --> 31:43.230
咱们来看方式二

31:45.230 --> 31:46.430
运行

31:46.430 --> 31:47.150
方式二呢

31:47.150 --> 31:48.030
时间上

31:48.030 --> 31:48.910
这里看出来了

31:48.910 --> 31:51.550
好像也没有少多少

31:51.550 --> 31:51.990
对吧

31:51.990 --> 31:53.710
但是它空间的占用

31:53.710 --> 31:55.270
要少了很多很多

31:56.390 --> 31:57.830
这还是方式一是吧

31:57.830 --> 32:00.660
方式二

32:00.660 --> 32:02.220
方式二时间还少了很多

32:02.220 --> 32:02.620
对吧

32:02.620 --> 32:04.020
时间还是少了很多的

32:04.020 --> 32:06.540
而且它不仅是时间少了很多

32:06.540 --> 32:08.460
而且空间占用

32:08.460 --> 32:11.380
是少的时间是非常非常多的

32:11.380 --> 32:12.700
空间占用是非常多的

32:12.700 --> 32:13.340
原来说

32:13.340 --> 32:13.700
那不对

32:13.700 --> 32:14.820
刚才为什么等那么久

32:14.820 --> 32:15.260
写入

32:15.260 --> 32:16.260
刚才等的久了

32:16.260 --> 32:17.660
主要是这里有死循环

32:17.660 --> 32:19.100
主要是这里有死循环

32:19.100 --> 32:20.820
因为我们数据没有准备充分

32:20.820 --> 32:21.340
对吧

32:21.340 --> 32:23.220
我们是通过一个循环

32:23.220 --> 32:24.180
不断的一个字节

32:24.180 --> 32:25.180
一个字节去准备数据

32:25.180 --> 32:26.900
所以说时间主要是花在这

32:27.620 --> 32:29.220
那么可以看到不仅时间少了

32:29.220 --> 32:31.420
而且它占用了内存空间

32:31.420 --> 32:32.540
大家可以想象得到

32:32.540 --> 32:33.500
非常少

32:33.500 --> 32:35.140
一次最多占用的话和内存空间

32:35.140 --> 32:36.900
一次最多占用了这个一个创可

32:36.900 --> 32:37.140
对吧

32:37.140 --> 32:38.300
一个创可64K比

32:38.300 --> 32:39.260
最多占用64K比

32:39.260 --> 32:39.900
写完了过后

32:39.900 --> 32:40.700
由于不管了

32:40.700 --> 32:41.820
我又下一次读一个创可

32:41.820 --> 32:43.380
一块一块写

32:43.380 --> 32:45.420
因此真正的复制文件

32:45.420 --> 32:47.420
传输大文件的内容

32:47.500 --> 32:49.300
我们肯定要使用流

32:49.300 --> 32:51.180
而不能使用这种传统方式

32:51.180 --> 32:53.340
全部都得到内存受不了的

32:53.340 --> 32:54.540
这里也通过这个例子

32:54.540 --> 32:55.420
能告诉大家

32:55.420 --> 32:56.380
有的时候

32:56.380 --> 32:57.420
因为你们学到现在

32:57.420 --> 32:58.620
应该有这么一个概念

32:58.620 --> 32:59.580
就是我们程序

32:59.580 --> 33:01.500
并不是说代码写得多

33:01.500 --> 33:02.580
它运行效率就低

33:02.580 --> 33:05.300
这是一个非常非常重复的概念

33:05.300 --> 33:07.700
很多时候我们要解决效率问题

33:07.700 --> 33:09.220
需要大量的代码

33:09.220 --> 33:11.500
代我们效率问题是怎么产生的

33:11.500 --> 33:12.260
运行效率问题

33:12.260 --> 33:14.060
它一定是执行的东西多

33:14.060 --> 33:15.260
执行的速度慢

33:15.260 --> 33:16.660
而不是你写的东西多

33:16.660 --> 33:17.300
对吧

33:17.300 --> 33:18.020
你们知道

33:18.020 --> 33:18.860
一个循环

33:18.860 --> 33:20.420
一看我们这里

33:20.420 --> 33:21.780
这个代码少吧

33:21.780 --> 33:22.740
是不是很少

33:22.740 --> 33:23.740
这个代码效率高吗

33:23.740 --> 33:24.420
肯定很低

33:24.420 --> 33:25.740
都要循环这么多次

33:25.740 --> 33:27.340
它指的是执行时间

33:27.340 --> 33:30.580
而不是那个

33:30.580 --> 33:32.820
而不是那个我们代码写的数量

33:32.820 --> 33:34.260
写的数量跟那个运行时间

33:34.260 --> 33:36.460
是没有直接关系的

33:36.460 --> 33:38.300
这是关于这个复制文件

33:38.300 --> 33:39.060
它这种方式

33:39.060 --> 33:40.180
把它复制一下

33:40.180 --> 33:41.860
这个方式教会

33:41.860 --> 33:43.300
合逼

33:43.300 --> 33:45.460
好 最后来我说一下

33:45.500 --> 33:48.220
这个方式二了

33:48.220 --> 33:50.780
实际上还有一种简单做法

33:50.780 --> 33:53.140
什么简单做法呢

33:53.140 --> 33:54.220
看着

33:54.220 --> 33:55.420
就是这一段代码

33:55.420 --> 33:57.340
它其实呢

33:57.340 --> 34:00.100
读取流已经帮你做好了

34:00.100 --> 34:01.020
我们在读取

34:01.020 --> 34:02.980
反而是一个读取流里边

34:02.980 --> 34:04.540
只要它是一个读取流

34:04.540 --> 34:05.660
不管它是什么读取流

34:05.660 --> 34:06.340
文件读取流

34:06.340 --> 34:07.620
还是别的读取流也好

34:07.620 --> 34:08.380
它都有

34:08.380 --> 34:09.820
像我们这两节课

34:09.820 --> 34:12.900
它探讨的都是通用的流的做法

34:12.900 --> 34:14.740
我们这里只不过以文件为载体

34:14.740 --> 34:16.100
来给大家讲解

34:16.100 --> 34:18.140
读取流里边有个方法叫pipe

34:18.140 --> 34:18.580
什么意思

34:18.580 --> 34:20.140
管道

34:20.140 --> 34:21.620
后边里边又传一个参数

34:21.620 --> 34:22.260
传什么呢

34:22.260 --> 34:23.900
传WS

34:23.900 --> 34:25.580
就是Wrights Jun

34:25.580 --> 34:27.540
就是把读取流这个管道

34:27.540 --> 34:30.740
跟我们的写入流接起来

34:30.740 --> 34:32.500
什么叫做接起来

34:32.500 --> 34:33.940
什么叫做接起来

34:33.940 --> 34:35.580
就是这里的代码

34:35.580 --> 34:37.220
这个东西就叫做接起来

34:37.220 --> 34:38.780
读一块写一块

34:38.780 --> 34:40.260
产生被押停止

34:40.260 --> 34:42.940
然后写完了恢复

34:42.940 --> 34:44.260
读完了结束

34:44.380 --> 34:45.740
这就是串起来

34:45.740 --> 34:47.060
它这个函数里面

34:47.060 --> 34:48.300
其实就是这个代码

34:48.300 --> 34:49.140
邦也写了

34:49.140 --> 34:51.020
也不用自己手写了

34:51.020 --> 34:52.540
因此我们通常

34:52.540 --> 34:55.620
如果说要把一个读取流

34:55.620 --> 34:58.500
读的东西写到另一个地方

34:58.500 --> 34:59.420
然后写到网卡

34:59.420 --> 35:01.020
或者是写到内存

35:01.020 --> 35:02.940
或者是写到硬盘

35:02.940 --> 35:04.900
那么就可以把它用管道串起来

35:04.900 --> 35:06.420
一读我写

35:06.420 --> 35:07.780
管道连起来

35:07.780 --> 35:09.460
我们之前看一下个图

35:09.540 --> 35:11.940
之前我们说那个就是

35:11.940 --> 35:15.180
读取流的时候

35:15.180 --> 35:17.460
不是讲过那么一个

35:17.460 --> 35:18.620
有张图啊

35:18.620 --> 35:20.380
我记得

35:20.380 --> 35:22.540
我记得流里边有张图

35:22.540 --> 35:24.580
找一找

35:24.580 --> 35:27.860
就是数据读出来

35:27.860 --> 35:29.820
文件流

35:29.820 --> 35:31.220
就是数据

35:31.220 --> 35:33.060
从硬盘读到什么

35:33.060 --> 35:34.100
读到内存

35:34.100 --> 35:36.180
然后它一部分一部分读

35:36.180 --> 35:36.900
读一块

35:36.900 --> 35:38.180
然后再把它串起来

35:38.180 --> 35:40.180
再把它串到这个流里边

35:40.180 --> 35:41.940
你们懂我这个意思

35:41.940 --> 35:44.900
这里

35:44.900 --> 35:46.780
再把它串到这个流里边

35:46.780 --> 35:48.460
再把它串到这个流里边

35:48.460 --> 35:49.700
当然为了解决被压了

35:49.700 --> 35:52.540
你还要去做我们之前做的这个处理

35:52.540 --> 35:52.820
OK

35:52.820 --> 35:54.220
那么这是pipel函数

35:54.220 --> 35:55.060
我们来看一下吧

35:55.060 --> 36:00.710
我们这里来给它做一个笔记

36:00.710 --> 36:01.910
pipel

36:01.910 --> 36:04.470
它可以把可读流连接到可写流

36:04.470 --> 36:05.270
它返回什么呢

36:05.270 --> 36:06.310
返回参数的值

36:06.310 --> 36:08.790
它返回的就是WS

36:08.790 --> 36:11.030
返回的就是WS

36:11.030 --> 36:13.630
那么该方法可以解决被压问题

36:13.630 --> 36:14.910
它自动帮你处理的

36:14.910 --> 36:17.310
当然你也可以在这里边去注册一些事件

36:17.310 --> 36:18.790
当它读完了之后

36:18.790 --> 36:20.310
RAS

36:20.310 --> 36:21.990
读完了之后

36:21.990 --> 36:25.940
close

36:25.940 --> 36:30.500
我们这里可以输出方式2

36:30.500 --> 36:32.900
time end

36:32.900 --> 36:35.020
好 咱们来看一下吧

36:35.020 --> 36:37.060
运行

36:37.060 --> 36:38.860
好 读出来了

36:38.860 --> 36:40.380
那么这里就写出进去了

36:40.380 --> 36:41.500
像我是完全一样的

36:41.540 --> 36:42.420
不然我们把它删了

36:44.780 --> 36:46.300
删了

36:46.300 --> 36:47.260
运行

36:47.260 --> 36:47.820
厉害

36:47.820 --> 36:49.500
所以完全一样的效果

36:49.500 --> 36:49.740
OK

36:49.740 --> 36:52.780
那么这是关于pipel

36:52.780 --> 36:53.460
好了

36:53.460 --> 36:56.380
那么我们文件流这一部分的东西就讲完了

36:56.380 --> 36:57.500
大家下来做一个练习

36:57.500 --> 36:58.220
练习怎么了

36:58.220 --> 36:59.940
就是做这么一个文件复制

36:59.940 --> 37:01.980
大文件的复制

37:01.980 --> 37:02.700
你可以想象

37:02.700 --> 37:04.140
一个几个G的文件

37:04.140 --> 37:05.140
几百兆的文件

37:05.140 --> 37:06.580
如果说你全部把它读到那一传

37:06.580 --> 37:07.940
是非常恐怖的

37:07.940 --> 37:08.980
那么我们可以用这种方式

37:08.980 --> 37:10.260
当然小文件的话无所谓

37:10.260 --> 37:11.660
不要只有几k比它无所谓

37:11.660 --> 37:12.820
你全部读到那一传再写过去

37:12.820 --> 37:13.700
都无所谓的

37:13.700 --> 37:16.660
但大文件最好不要这样做

37:16.660 --> 37:17.020
好

37:17.020 --> 37:20.460
这是关于刘这一块的知识

37:20.460 --> 37:22.340
有了刘这一块知识的过后

37:22.340 --> 37:24.580
我们后边讲服务器搭建

37:24.580 --> 37:26.180
以及服务器的各种处理

37:26.180 --> 37:27.540
就比较好讲了

37:27.540 --> 37:27.820
好

37:27.820 --> 37:28.860
这是关于这一块

