WEBVTT

00:00.620 --> 00:04.620
好 大家看到咱们来讲那个sacrlize的查询

00:05.620 --> 00:11.620
嗯 这一部分讲了之后呢sacrlize基本上就没啥了啊 就是核心的东西我们就讲完了

00:12.620 --> 00:17.620
嗯 但是呢sacrlize呢还有很多很多东西啊 大家有兴趣的话可以去看他的这个文档啊

00:17.620 --> 00:20.620
这个文档呢也是一个民间中文网 做的还是不错的

00:21.620 --> 00:25.620
所以这个网站的这个文档呢大家应该看得懂啊 所以说像查询这一块东西也很多

00:26.620 --> 00:32.620
包括这一张这一个章节 包括这个预先夹载啊 叫预夹载啊 这些都可以去看一下

00:33.620 --> 00:38.620
嗯 其实呢我觉得现在也没有必要看啊 就是将来你们在公司里面如果说啊

00:39.620 --> 00:43.620
你们要用到数据库 像这种级率都比较小 如果说你们要用到数据库

00:44.620 --> 00:48.620
而且呢要去做一些比较复杂的查询 我可能就可以去看一下啊 这几个章节

00:49.620 --> 00:53.620
咱们这一课呢就讲一讲他的查询里面的我们最常见的 就是如果说用到数据库

00:53.620 --> 00:56.620
最常见的一些查询方式 主要是分为这么几个啊

00:57.620 --> 00:59.620
一个是单个查询单个数据 咱们来举个例子吧

01:01.620 --> 01:05.620
比方说最常见的是什么呢 最常见就是登录啊 登录哪个表呢 就是我们儿德命这个表

01:06.620 --> 01:08.620
我们管理员这个表不是有一些数据吗

01:09.620 --> 01:14.620
对吧 那么这些数据呢我们要做登录 所以说我们要提供一个方法去查询这些数据

01:15.620 --> 01:19.620
登录其实就是一个查询 那怎么办呢 我们在service里面啊 之前我们打了三成架构

01:19.620 --> 01:26.620
三成架构 这不是服务场 对不对 咱们到service 儿德命service里面去写上这么一个查询啊 一个sport导出

01:28.620 --> 01:32.620
然后呢 这里是locking方形 是一个异步的方形

01:33.620 --> 01:38.620
登录的肯定要传给我一个账号一个密码 对吧 登录要传给我一个账号密码

01:39.620 --> 01:45.620
好 那么传个账号密码过后怎么在登录呢 我就可以使用这个模型啊 儿的命就上面的啊 这个儿的命模型

01:46.620 --> 01:52.620
看呗 使用这个模型啊 然后呢 它里边有个方法叫做fand 所有的模型都有这个方法

01:53.620 --> 02:00.620
fand1 查一个 只查一个数据 其实呢 它就是给你使用了这么一个东西 叫limit01

02:01.620 --> 02:03.620
它就使用了这么一个东西 它说查一个啊

02:04.620 --> 02:11.620
fand1 那里边写啥呢 里边写的是查询的一些配置 就是你怎么去查 你查哪些东西 查的条件是啥

02:11.620 --> 02:20.620
那我们我们这里的肯定是查所有的 就是满足账号密码要求的整条数据啊 整条纪录 那么我们这里的只需要给一个条件就行了

02:21.620 --> 02:26.620
那么这里条件的是通过ware属性来进行配置 就是我们之前的删除啊 修改是不是都用过的 对不对

02:27.620 --> 02:35.620
那么ware属性里边可以给很多条件 它们的关系呢 是并且关系 就是要满足locking id啊 这一列要等于什么呢 等于我们的参数

02:36.620 --> 02:42.620
我们完全可以使用es6 如果说写全的话 应该是这样子写 对吧 等我们这里可以使用es6的这种数写属性

02:43.620 --> 02:50.620
locking password 那么这样子是不是查询条件 对不对 我们查询一个管理员 列locking id等于这个

02:51.620 --> 02:57.620
locking password等于这个 对吧 然后查出来 当然它是一个异部的 查出来我们可以等待一下 等待然后得到一个result

02:59.620 --> 03:03.620
result 好 咱们来可以看一下啊 我们把这个result输出吗

03:04.620 --> 03:06.620
我们把它返回吗

03:07.620 --> 03:14.620
return 而result 返回 好 咱们要因这个事里边去试一下啊 因这个事这个东西我们就注射掉了啊 要注射掉了

03:15.620 --> 03:21.620
好 我们这里呢 把这个清空 好 接下来我们导入

03:22.620 --> 03:30.620
然后呢 导入这个services 然后呢 我们这里去调用他的locking

03:31.620 --> 03:42.620
账号传进去 我们看一下账号是啥呀 账号一个bcd一个abc对吧 账号bcd密码abc 我们来传进去啊 账号bcd密码abc

03:43.620 --> 03:49.620
好 那么传进去我们z 当它完成之后呢 我们能达到一个结果啊 我们把结果输出就完了

03:50.620 --> 03:54.620
主要是观察一下它的收口语剧啊 然后我们来查询是note index

03:56.620 --> 04:00.620
好 你看是不是查询出来了结果了 对吧 你看它升等的收口语剧啊 是不是查询所有的页

04:01.620 --> 04:05.620
查询完了过后一个ware条件 ware条件这个东西要自动加的啊 就是每个被删除

04:06.620 --> 04:13.620
然后呢 条件是aradmin lockin id 等于bcd啊 lockin password 等于abc 所以查出来了 对就查出来了啊 就这么简单

04:14.620 --> 04:20.620
那么最后呢 给你先指一看 里面是1 是不是只查一条 对吧 它省略了那个0啊 就挑过0 只查一条

04:21.620 --> 04:27.620
好 那么这里就查出来了 对不对 查出来过后呢 它是一个什么sacrifice实力 就叫做模型实力

04:28.620 --> 04:34.620
那么这个实力是不是可以用我们之前学的知识啊 用这个实力去改动里面的属性啊 是不是然后点c5方法

04:35.620 --> 04:41.620
是不是就可以重新更新了 对不对 只不过呢 更多的时候呢 我们一般不用这个实力啊 把它转换成节省的一个普通的

04:41.620 --> 04:48.620
一个品面对象啊 我们以后再做 那如果说 如果说我这里呢密码写错了呢 密码写错了 我们来看一下

04:51.260 --> 04:56.260
在查询 你看是不是得到是now 对不对 得到就是now 那就查不出来 查询一条嘛 对不对

04:57.260 --> 05:04.260
好 然后呢 我们这里呢 还有一种情况啊 就是如果说的密码是大写了 大写能不能查出来了

05:05.260 --> 05:10.260
让我知道啊 我们的mysocal是不缺分大小写的啊 你看 他说还是可以查出来 对不对

05:10.260 --> 05:15.260
那如果说你想账号 因为我们绝大部分时候 确实在查询的时候是不用缺分大小写的

05:16.260 --> 05:23.260
但是有些特殊情况下呢 我们是需要缺分大小写的 那么这种情况下怎么办呢 我们可以简单的处理一下啊 也特别简单

05:24.260 --> 05:28.260
一种有两种方案 一种方案呢 是直接改动mysocal 把mysocal改为可以缺分大小写

05:29.260 --> 05:35.260
啊 就是这个这种方法你可以去摆度一下啊 是改动某一个列 它的数据格式内形啊 把它改成二净之格式

05:36.260 --> 05:42.260
因为不管是制符 还是什么东西数据 它变成二净之格式过后 大小写肯定是不一样的啊

05:43.260 --> 05:47.260
大家可以去改也可以去摆度一下 但是我们更多的时候呢 是用这种方式 这种方式更加简单一点

05:48.260 --> 05:53.260
就是我们查了 查了过后 我们在这里写一下JS的逻辑 在JS里边进行判断

05:54.260 --> 06:00.260
好 判断一下啊 result 是不是存在 首先判断是不是存在 如果说存在的话 我们继续判断一下

06:01.260 --> 06:06.260
result的locking id 因为我们都知道JS是缺分大小写的 对吧 那我们判断一下 是不等于locking id

06:07.260 --> 06:13.260
然后呢 result 的什么locking password 啊 password 是不是等于locking password

06:14.260 --> 06:19.260
对吧 如果说存在啊 就表示查出来了 查出来过后 我们进一步判断 它帐号密码是不是相等 那么是不是缺分大小写了

06:20.260 --> 06:27.260
如果都相等的话 我们就返回result to json 把转换成一个平面格式 否则的话 我们就返回什么了 返回 now

06:28.260 --> 06:35.260
对吧 我们可以在JS里面稍微控制一下就完事了 稍微控制一下就完事了 好 接下来我们再来看啊 现在我们变大小写来查 查询

06:36.260 --> 06:46.820
应该是不是闹了 对吧 变大写过后就变成闹了 好 然后再来啊 我们如果说给一个abc 啊 正常的查询呢 咱们来看一下啊 运行

06:47.820 --> 06:55.820
你看 是不是得到这么一个平面对象 对吧 一个普普通通的平面对象 就完事了啊 就非常简单啊 这是查询单个数据啊 是不是很简单

06:55.820 --> 07:09.220
说很简单 然后这个啊 按照组件来查询单个数据 他也是查单个 他是按照组件来查 那么这个东西怎么来怎么来写呢 其实也很简单啊 就当然你可以完全可以用这个 对吧 无非就是把缓上id嘛 按照组件来查

07:09.820 --> 07:19.820
我们这里呢 再来搞出一个 呃 这些东西你们下来都要做的啊 添加一个管理员 呃 呃 呃 不是 get 额的命 by id

07:20.820 --> 07:23.820
get 额的命 by id a sync 方形

07:24.820 --> 07:27.820
好 给我一个id 我来帮你查一个管理员

07:29.320 --> 07:36.720
懂了意思吧 给我一个id 我来帮你查一个管理员 那么这个地方呢 我们怎么来写呢 我们就完全就可以使用他的另一个函数啊 额的命

07:36.820 --> 07:45.220
你不要一个fand by pk primary t 把id 喘进去完事了啊 就这就查出来了啊 得到一个结果 对不对 result

07:46.220 --> 07:53.020
但我们同样的啊 把它转换成平面对象 如果说result有值怎么样呢 我就把它return 而result 抽接生

07:55.220 --> 08:03.620
呃 然后啊 发挥到 这就是根据组件来去查询一个数据 好 咱们来试一下吧 把这组设掉

08:05.020 --> 08:11.620
啊 额的命 so 然后呢 呃 get 额的命 by id 啊 然后呢 给他一个e吧 z

08:12.620 --> 08:17.620
输出啊 保存 见了没 见了没运行一下

08:19.220 --> 08:27.620
你看 是不是可以查出来了 对吧 这条数据 没问题吧 这是咱们这个根据组件查询 都非常非常简单啊 接下来我们再来看啊

08:28.420 --> 08:36.620
查询多个数据 就是用fand or 还是一样给条件 然后查多个数据完事了 他查出来是一个数据 咱们比方说到哪去了 到这个

08:37.620 --> 08:44.620
嗯 学生啊 学生这里来做一个多条件 就是查询多个export

08:45.620 --> 08:50.420
fand student 或者是get student

08:52.220 --> 09:00.620
一步的方法啊 现在先不给参数吧 先不给参数 然后那我们先查询所有的学生 他的数据有点大啊 数据有点大

09:01.620 --> 09:08.620
我们还是给 算了 我们就查吧 直接查一个所有的学生 来吧 我们怎么查呢 就使用student这个模型

09:11.380 --> 09:21.380
使用student这个模型 然后里边一个fand or 对吧 进行查询 那么里边是可以给条件的 如果说你不给条件的话 怎么样了 他就查询所有的

09:22.380 --> 09:29.380
他查询所有的 咱们这里写上一个student results 查询所有

09:31.380 --> 09:37.380
那么我们这里直接返回 因为他是一个数组啊 注意啊 他返回的是一个数组 所以说我们这里用节省格式化一下

09:38.380 --> 09:44.380
student results 把格式化一下 保存 咱们来试一下啊 这边我们就复制一下

09:46.950 --> 09:58.580
我们这里呢 就require 改一下啊 service is student service 这边呢 改一下名字 改成stew serve

09:59.580 --> 10:05.580
好 来吧 still serve getstudent zr 输出

10:07.580 --> 10:21.030
好 咱们照这个控材里面看一下 这有点卡了 对吧 有点卡了 你看 是卡了吗

10:23.030 --> 10:27.030
不是卡了啊 不是卡了 是我这边怎么回事 我看呀

10:28.030 --> 10:37.030
到student service 里面我们getstudent 然后呢 jason shrinkify 然后把他 这里面用await 对不对

10:38.030 --> 10:42.030
不然他得到的是什么 does promise 再来一次

10:43.030 --> 10:48.030
你看 是不是得到一个数组 你看没有 是不是一个数组 他里面有很多的学生对象 对吧

10:48.030 --> 10:51.030
但是更多的时候呢 我们一般不会查这么多数据出来

10:52.030 --> 10:57.030
除非我可以确定说这个表里边的数据呢 本身就不多 比方说管理员 管理员一般不多的

10:58.030 --> 11:01.030
就是一个公司内部的管理员使用的 虽然这个数据是很少的

11:02.030 --> 11:07.030
但是像学生这种啊 什么书籍这种呢 我们一般来说 不会查所有的数据

11:08.030 --> 11:12.030
我们一般来说会做什么呢 会做分业查询 没了意思吧 我会做分业查询

11:13.030 --> 11:16.030
那么怎么来做分业查询呢 比方说啊 你要给我两个参数

11:17.030 --> 11:21.030
一个是配级 业码 第级业 我们这里用1

11:22.030 --> 11:26.030
那么另一个参数呢 是limit 我们用默认值嘛 一个10

11:27.030 --> 11:30.030
默认为第一页 每页显示效 当然你可以给我传递别的参数

11:31.030 --> 11:36.030
那么我们知道在搜扣语句里面做分业是很简单的 就是一个limit 啊 前面挑和多少多少

11:37.030 --> 11:42.030
然后呢 去取多少多少 对吧 那么我们翻到or里面也可以做这种事情 只不过我们写的不是搜扣语句了

11:43.030 --> 11:47.030
那么我们看一下官方文章是怎么说的呢 他这里呢 有一个就是模型查询基础

11:49.030 --> 11:56.030
当然一开始的不熟悉的同学都可以看 挨在这看 我这里呢就直接搜索了 他就一个叫做offset

11:57.030 --> 12:05.030
对 限制和分业 你看 一个limit 一个offset offset就表示挑过 limit就表示取多少条 对吧 就特别简单

12:05.030 --> 12:13.030
咱们回到一个offset offset就挑过多少 跟以前我们写的搜扣里面的limit的第一个问号位置

12:14.030 --> 12:19.030
第一个位置是不是就是挑过多少 挑过多少 那么这里我们怎么写

12:20.030 --> 12:28.030
是不是我们今天讲过的 就是配级-1 诚意什么的 诚意limit 对不对 是不是诚意这个字

12:29.030 --> 12:37.030
然后limit呢 就是我们取多少呢 取就是limit 当然为了 如果说我害怕别人给我传一个字不错进来

12:38.030 --> 12:45.030
害怕别人给我传一个字不错进来 那我这里呢 可以用这种方式 用个夹号 在前面把它强行变成数字 对吧 好 那么就写完了

12:46.030 --> 12:56.370
对不对 我们来看试一下啊 现在呢我们运行 你看 是不是就只差了一页 对吧 只差了第一页 每页以前是十条下修兰

12:56.370 --> 13:03.370
我们看一下第一个数据 是不是下修兰 下修兰到什么 罗秀英 咱们到台北开省去看一下

13:04.370 --> 13:15.370
student 下修兰一共多少条呢 1 2 3 4 5 6 7 8 9 10啊 罗秀英没问题吧 那么就查出来十条数据了

13:16.370 --> 13:24.370
对吧 非常简单 好 那么我们继续来看啊 这里边呢 因为我们做分页的时候呢 往往还需要一个什么数据呢 还需要一个就是总数

13:25.370 --> 13:32.370
对不对 是不是学生的总数 那么学生的总数我们怎么来得到了啊 你看啊 这个地方呢 我们得到的是什么呢 得到的是学生的数数

13:33.370 --> 13:38.370
对不对 data 是我们得到的是学生数数 然后还有一个学生的总数 学生总数我们怎么来得到了

13:38.370 --> 13:47.370
我们可以用这段来查询 student called 对不对 called 那么这里边也可以写啊 也可以写各种条件啊 条件来限制

13:48.370 --> 13:57.370
如果说你没有写任何条件的话 就是查整个表的总数 await 等待 那么我们得到 called 就偷偷总数

13:58.370 --> 14:04.370
接下来我们把这两个数据呢 拼装一下 然后返回 一个是偷偷 一个是data 是不是我们查了两个东西

14:04.370 --> 14:06.370
是不是我们查了两个东西 好 保存啊 等一下我们看一下

14:10.370 --> 14:16.370
进行 你看 是不是得到一个偷偷是一个什么data 是对不对 没问题吧

14:17.370 --> 14:20.370
啊 这个地方呢 这个地方返回的是那个啊 返回的是一个制服串

14:21.370 --> 14:28.370
啊 他返回的是一个制服串啊 返回了制服串的话 我们这里呢 其实返回制服串也无所谓 我们这里再把它转换成为接剩

14:29.370 --> 14:37.370
poss 这把转换成为一个普通数组 这样的目的啊 是为了把它得到一个平面对象啊 主要的目的是为了得到一个平面对象

14:38.370 --> 14:45.370
因为他 因为他这里返回的是一个普通数组啊 这个普通数组呢 他是没有图接剩的啊 他是没有图接剩的一个方法的

14:46.370 --> 14:54.370
所以说呢 我们这里呢 把这里的先把它转成转成制服串啊 然后呢 转成接剩制服串 然后呢 再把它转换成普通的对象

14:55.370 --> 14:57.370
好 这样我们再看一下 现在就没问题了

14:58.370 --> 15:05.370
好 厉害 是不是查出来了 总数有521个学生 然后呢 这边来学生的有地业的学生有这么一些 对不对

15:06.370 --> 15:11.370
好 除了这种方式之外呢 其实买就是这个sacrifices呢 还给你提供的一种方式 这种方式呢

15:12.370 --> 15:21.370
更加符合 更加方便一点 我们来看一下这种 他给你提供的方式啊 他提供方式就是有一个方法啊 我记得在这

15:22.370 --> 15:30.370
在这个查照器里边 其中一个方法呢 叫做fand and cause all 就这个方法

15:31.370 --> 15:36.370
这个方法呢 他就会 他一边查分业数据 一边呢来查总数

15:37.370 --> 15:44.370
你看 就是这个方法 他就非常贴心的啊 给你准备了 因为我们知道分业这个 这个场景经常都会这样做

15:45.370 --> 15:49.370
一个是查猛夜的数据 这个数据量比较大 我不可能全部查出来

15:49.370 --> 15:57.370
不然的话 内存占用太高了 为什么要分业 就其实就是 原因不是说为了拥固看着体验好一点

15:58.370 --> 16:03.370
这是其中一个原因 更重要的原因是服务器那边找不住 如果说你全部数据查出来 比方说几百万条数据全部查出来

16:04.370 --> 16:10.370
他包了内存 服务器是扛不住的 而且传输的量也太大了 所以我们希望传输一点点 只查一点点

16:11.370 --> 16:14.370
你下一次要看更多的东西呢 你点一个分业 然后我们再去帮你查一点点

16:15.370 --> 16:22.370
一般是用这种模式 一下子可以查出来 也看不完 对不对 那么分业的时候经常都会遇到查一个数据 然后查一个种数

16:23.370 --> 16:31.370
对吧 因为我们前段要分业嘛 所以说要把这个数据给他查出去 那么怎么查呢 我们也可以是用刚才的那种做法分开来查 也可以使用他的这种方式

16:32.370 --> 16:37.370
就是一个Find and call to all 那么他会进行 他就会帮你来做这个事情

16:38.370 --> 16:42.370
其实他就是这两个方法的组合 咱们来试一下吧 试一下就知道了

16:42.370 --> 16:51.370
Find and call to all 那么这边呢 我们第几页呢还是一样的啊 我们这边还是可以写offset limits 是完全一样的

16:52.370 --> 16:57.370
只不过呢 他在call to all 在进行call to的時候 就在进行查数量的时候 他直接忽略掉这两个东西

16:58.370 --> 17:05.370
包括ware ware在查的时候呢 call to all是会不会忽略ware的 咱们来看一下吧 我们先看地址

17:05.370 --> 17:11.370
好 这边是一样的写法配几减1乘以limit 好 下面呢是limit

17:12.370 --> 17:19.370
limit 好 那么这里呢await 等待 然后呢返回results

17:21.370 --> 17:26.370
好 我们在这 在这里就直接返回吧 返回results 好 咱们来看一下

17:29.320 --> 17:35.320
运行 你看一下啊 咱们这里是不是一个code 对不对 那么查出来是不是一个一个的数据

17:35.320 --> 17:42.320
数据 对不对 一个数据 只不过这个数据里边的东西呢 他用的是 用的这个属性名的叫Rose

17:42.320 --> 17:47.320
当然那里可以完全返回另一个对象 然后把属性名的改一下 对吧 这个东西你随便随意的

17:47.320 --> 17:53.320
而且那个Rose里边是不是一个模型的实例 如果说你把他想把他转换成平面对象的话 咱们来转一转

17:54.320 --> 18:00.320
返回的时候呢 我就另外给他返回一个total 等于什么呢 等于results的code

18:01.320 --> 18:06.320
然后呢 还有个什么datas 我给他返回的是什么呢 返回的是name is

18:08.320 --> 18:12.320
反回的是json pose

18:13.320 --> 18:16.320
然后json stringy fit

18:17.320 --> 18:24.320
然后是results里边的Rose 对吧 自己控制一下就完事了 咱们再来看

18:25.320 --> 18:31.320
运行 你看数据出来了 跟之前的效果是完全一样 你看它是运行的 是不是两个搜索语剧 对不对

18:31.320 --> 18:35.320
说运行的一个code搜索语剧 一个查询的搜索语剧 对吧

18:35.320 --> 18:43.320
好 OK 这是咱们的这个分业查询 那么在分业查询的时候呢 往往我们可能还会写一些条件

18:43.320 --> 18:48.320
写一些条件 这个东西我们就直接删了 你知道这个东西就行了 非常简单

18:49.320 --> 18:56.320
算了 还是留在这吧 咱们这可能会给一些条件 比方说我们要去查询学生的

18:56.320 --> 19:01.320
查啥呢 学生的性别嘛 比方说我们要查询学生的性别

19:01.320 --> 19:06.320
好 后边给一个sex 性别呢 我认为如果说你给的是-1

19:06.320 --> 19:12.320
如果说你给的是-1 我就认为 我就不查性别了 无所谓男的女的我都要

19:12.320 --> 19:18.320
如果说你给的是-1 那么我 或者是这样吧

19:18.320 --> 19:23.320
这个是 我这样 你给的是undefined 或者是now 只要你没有给数据

19:23.320 --> 19:29.320
算了 你们零的话判断出来也是没有给数据 还是用-1吧

19:29.320 --> 19:35.320
我们还是用-1 如果说你给的是-1 那么我表示我不按照性别查询

19:35.320 --> 19:41.320
就像目前这样子查 对吧 如果说你给的是-1 或者是给的是-2

19:41.320 --> 19:46.320
或者是给的是-4 因为他是布尔嘛 对不对 那么我就按照你的性别来查询

19:46.320 --> 19:51.320
那这个东西怎么办了 这个东西是不是要写威尔 你看这种怎么来操作

19:51.320 --> 19:56.320
是不是要写威尔 威尔条件 好 威尔条件的时候呢

19:56.320 --> 20:02.320
比方说我给他传了性别 那就简单了 我就sex

20:02.320 --> 20:08.320
我们这边是不是写了sex 是sex 那么sex 我把条件传进去就完事了 对不对

20:08.320 --> 20:12.320
好 那咱们试一下啊 到这个index里边来

20:12.320 --> 20:18.320
我们就一开始就用第一页 每页10条 然后传一个sex进去 我要查男生

20:18.320 --> 20:22.320
保存 我们来看一下这个有什么样的变化面

20:22.320 --> 20:28.320
你看啊 偷偷他非常智能的 知道你现在是在查

20:28.320 --> 20:33.320
男生的就是数据 因此我第一页的数据肯定是只有男生的

20:33.320 --> 20:37.320
是没有女生的 咱们看一下数据库 你看这个女生是不是没了

20:37.320 --> 20:42.320
诸品是男生 是不是有 诸品是男生 是不是有 对不对

20:42.320 --> 20:48.320
sex 为q 另外呢 同样的种树他查到就不是所有学生的种树了

20:48.320 --> 20:52.320
而查的是只是什么 只是男生的种树 明白了意思吧

20:52.320 --> 20:57.320
这是非常非常符合逻辑的 你想一想在页面上做查询的时候

20:57.320 --> 21:01.320
你下边要分页 是不是对 比方给了个查询条件

21:01.320 --> 21:06.320
是查所有的男生 那是不是只是对男生来进行分页

21:06.320 --> 21:10.320
对吧 我们只是要对男生 所以说我们只需要得到男生的种树

21:10.320 --> 21:12.320
而不是得到所有的种树 是非常符合逻辑的

21:12.320 --> 21:14.320
这个时候我们就不需要所有的种树了

21:14.320 --> 21:17.320
那有时候说 我就要所有的种树怎么办 拿自己去查呗

21:17.320 --> 21:21.320
用扣子方法 对吧 自己去查 这是一般我们都不需要

21:21.320 --> 21:23.320
我从来还没遇到过这种情况

21:23.320 --> 21:26.320
我们给了条件过后 它的扣成就是它是无数

21:26.320 --> 21:30.320
它是按照这个条件来固定的种树 这是关于这个

21:30.320 --> 21:34.320
那现在不对啊 那如果说我不给这个条件的话

21:34.320 --> 21:38.320
那是不是就出问题了 那我应该是查所有的性别 对不对

21:38.320 --> 21:41.320
是不是应该要查所有的性别 你看啊

21:41.320 --> 21:44.320
是不是要查所有的性别 那么现在呢

21:44.320 --> 21:47.320
它查的是什么 查的是性别等于负一的 所以说没有数据

21:47.320 --> 21:49.320
看到没 那么这个种情况怎么办呢

21:49.320 --> 21:52.320
这种情况其实我们用GS来控制一下就完事了

21:52.320 --> 21:55.320
你看这里Sex呢 我们就完全在查询之前啊

21:55.320 --> 21:58.320
就可以控制一下我们的条件

21:58.320 --> 22:01.320
康迪欣 我们的条件 我们用一个对象

22:01.320 --> 22:04.320
因为条件最终就是个对象嘛 对不对 条件就是一个对象

22:04.320 --> 22:07.320
我们说用个对象 最后我们把这个条件写到这儿来

22:07.320 --> 22:09.320
我们再先把这个条件给它组装好

22:09.320 --> 22:14.320
来吧 我们一个个判断 如果说Sex不等于负一

22:14.320 --> 22:16.320
不等于负一 表示什么意思呢

22:16.320 --> 22:19.320
表示的是我要按照Sex来查询 要按照性别来查询

22:19.320 --> 22:22.320
那怎么办呢 我就用康迪欣

22:22.320 --> 22:24.320
加一个属性嘛 对不对 我说就加一个属性嘛

22:24.320 --> 22:26.320
Sex等于什么呢 等于Sex

22:26.320 --> 22:29.320
其实这里能力还可以写得更加严谨一点

22:29.320 --> 22:32.320
怎么样 因为它Sex呢 有可能传一个1 有可能传一个0

22:32.320 --> 22:34.320
有可能传一个2 有可能传一个3 对吧

22:34.320 --> 22:37.320
那么这些 如果说传2传3的话 是不是要出问题

22:37.320 --> 22:40.320
或者是传一个制服 制服出来的紧难

22:40.320 --> 22:42.320
那是不是要出问题 为了避免这种情况

22:42.320 --> 22:45.320
你可以用这种方式 强行把它转成布尔雷行

22:45.320 --> 22:47.320
对吧 先用个感叹号 取反

22:47.320 --> 22:50.320
取反是不是布尔雷行 但是布尔雷行就取反了

22:50.320 --> 22:53.320
然后再用一个 再取反 是不是就把它转成布尔雷行了

22:53.320 --> 22:55.320
这种方式就非常好了

22:55.320 --> 22:56.320
然后咱们再看一下

22:56.320 --> 22:59.320
现在我们运行 你看 现在目前就是查所有的学生

22:59.320 --> 23:01.320
521个

23:01.320 --> 23:03.320
然后我们现在再回到英德的手里边来

23:03.320 --> 23:06.320
我们给它写一个 比方写一个男生

23:06.320 --> 23:10.320
男 因为写的制服串 写的制服串也可以查

23:10.320 --> 23:12.320
它就转成处了 对吧

23:12.320 --> 23:14.320
所谓的男生

23:14.320 --> 23:16.320
对吧 是不是所有的男生就查出来了

23:16.320 --> 23:18.320
如果说要查女生的话

23:18.320 --> 23:20.320
女生的话就可以给个空制服串

23:20.320 --> 23:22.320
空制服串是不是判定为Force

23:22.320 --> 23:24.320
对吧 我就按照 从这里过去

23:24.320 --> 23:26.320
按照去和Force来查询

23:26.320 --> 23:28.320
那么现在是不是得到的是女生

23:28.320 --> 23:30.320
女生的姓名和那个

23:30.320 --> 23:33.320
男生的姓名 这个是随机的

23:33.320 --> 23:35.320
我们反正都是测试书记 无所谓

23:35.320 --> 23:37.320
不用去太久 委屈就业这个

23:37.320 --> 23:39.320
这是关于性别查询

23:39.320 --> 23:41.320
那么如果说我们将来

23:41.320 --> 23:44.320
在这 我们可能还有更多的条件

23:44.320 --> 23:47.320
那怎么办呢 比方说我们还有学生的姓名

23:47.320 --> 23:49.320
我们还要按照学生的姓名来查询

23:49.320 --> 23:51.320
学生的姓名

23:51.320 --> 23:53.320
那个姓名呢 如果说你给

23:53.320 --> 23:55.320
默认是一个空制服串

23:55.320 --> 23:57.320
如果说你给的是空制服串的话

23:57.320 --> 23:59.320
那我就不管了 那我就不管了

23:59.320 --> 24:01.320
那如果说你不是给的空制服串的话

24:01.320 --> 24:03.320
那么我还要按照姓名来查询

24:03.320 --> 24:05.320
那怎么办呢 我们再来判断

24:05.320 --> 24:07.320
如果说Name 有值

24:07.320 --> 24:09.320
是不是我要按照Name来查询

24:09.320 --> 24:11.320
按照Name等于什么呢

24:11.320 --> 24:13.320
Name 对不对

24:13.320 --> 24:15.320
那么现在我们在这里

24:15.320 --> 24:17.320
在坑林已经放在这了

24:17.320 --> 24:18.320
然后我们再来看

24:18.320 --> 24:20.320
如果说不写姓名的话

24:20.320 --> 24:23.320
那么我们肯定是查询的所有的男生

24:23.320 --> 24:26.320
那查询的所有的学生

24:26.320 --> 24:28.320
那如果说写了姓名的话

24:28.320 --> 24:31.320
比方说 我看一下有什么姓名

24:31.320 --> 24:35.270
就这个 翻译吧

24:35.270 --> 24:37.270
这是男生还是女生

24:37.270 --> 24:39.270
这是女生

24:39.270 --> 24:40.270
这是女生

24:40.270 --> 24:43.650
下修男

24:43.650 --> 24:48.920
这个女生就老老实实写成Force了

24:48.920 --> 24:51.920
保存 下载运行

24:52.920 --> 24:54.920
你看啊 是不是就只查出来一个

24:54.920 --> 24:55.920
对不对

24:55.920 --> 24:56.920
我们查的是什么

24:56.920 --> 25:00.920
女生 名字叫下修男的女生

25:00.920 --> 25:01.920
对吧

25:01.920 --> 25:02.920
那更多的时候呢

25:02.920 --> 25:04.920
我们还可能会遇到这样的场景

25:04.920 --> 25:05.920
就是我们这里呢

25:05.920 --> 25:06.920
希望是模糊查询

25:06.920 --> 25:08.920
而不是一个精确匹配

25:08.920 --> 25:10.920
那这个东西怎么办呢

25:10.920 --> 25:11.920
肯定不能用搜索语句

25:11.920 --> 25:12.920
这个没有搜索语句

25:12.920 --> 25:14.920
它全是用API的形式给你搞定的

25:14.920 --> 25:15.920
那么我们可以看一下

25:15.920 --> 25:17.920
它里面的查询 模型查询

25:17.920 --> 25:18.920
它这里边

25:18.920 --> 25:20.920
详细的说的每一种查询方式

25:20.920 --> 25:22.920
说的非常非常详细

25:22.920 --> 25:23.920
这里边 你看啊

25:23.920 --> 25:25.920
它说Sacrifice里面

25:25.920 --> 25:27.920
给你提供了一个叫做OP

25:27.920 --> 25:29.920
叫operator 叫做操作服务

25:29.920 --> 25:30.920
因为我们知道这个

25:30.920 --> 25:32.920
搜索里面是不是有操作服务

25:32.920 --> 25:33.920
对不对

25:33.920 --> 25:34.920
等于大鱼 小鱼等于

25:34.920 --> 25:37.920
鱼 这些东西 between 这些东西

25:37.920 --> 25:38.920
对吧

25:38.920 --> 25:39.920
像这些操作服务

25:39.920 --> 25:40.920
都给你提供了

25:40.920 --> 25:41.920
你可以去仔细看一下

25:41.920 --> 25:42.920
闻到我们不一一讲解的

25:42.920 --> 25:43.920
我们这里说一下模护查询

25:43.920 --> 25:45.920
我们再把 把它导入进来

25:45.920 --> 25:46.920
require

25:46.920 --> 25:47.920
sacrifice

25:47.920 --> 25:48.920
它说API的形式

25:48.920 --> 25:51.920
来模拟操作服的OP

25:51.920 --> 25:53.920
那么这个操作服怎么用呢

25:53.920 --> 25:54.920
这操作服务里边

25:54.920 --> 25:56.920
给你提供了很多种方式

25:56.920 --> 25:57.920
比方说它这里

25:57.920 --> 25:58.920
下面给你写了

25:58.920 --> 26:00.920
NIKE是怎么意思呢

26:00.920 --> 26:01.920
NIKE

26:01.920 --> 26:02.920
NIKE就是

26:02.920 --> 26:03.920
一个百分号开头

26:03.920 --> 26:04.920
查询后边的东西

26:04.920 --> 26:05.920
对吧

26:05.920 --> 26:06.920
notNIKE呢

26:06.920 --> 26:07.920
比方说notNIKE

26:07.920 --> 26:08.920
notNIKE

26:08.920 --> 26:09.920
这样子写

26:09.920 --> 26:10.920
notNIKE我们好像没讲过

26:10.920 --> 26:11.920
对吧

26:11.920 --> 26:12.920
就是不包含

26:12.920 --> 26:13.920
就不包含的意思

26:13.920 --> 26:14.920
不包含的意思

26:14.920 --> 26:15.920
那NIKE

26:15.920 --> 26:16.920
后边是不是可以写

26:16.920 --> 26:17.920
两个百分号

26:17.920 --> 26:18.920
两个百分号写到后边

26:18.920 --> 26:19.920
对不对

26:19.920 --> 26:20.920
所以说这里非常简单

26:20.920 --> 26:21.920
咱们这个可以怎么写呢

26:21.920 --> 26:22.920
这个NAME

26:22.920 --> 26:24.920
这个NAME这里呢

26:24.920 --> 26:25.920
它来自于一个

26:25.920 --> 26:27.920
要来自于一个操作

26:27.920 --> 26:28.920
这个操作是一个对象

26:28.920 --> 26:30.920
就相当于是个VIR

26:30.920 --> 26:31.920
里边有一个SEX

26:31.920 --> 26:32.920
就相当于

26:32.920 --> 26:33.920
这个VIR相当于是什么呢

26:33.920 --> 26:34.920
相当于是这样子

26:34.920 --> 26:35.920
一个SEX等于

26:35.920 --> 26:37.920
然后NAME等于一个对象

26:37.920 --> 26:39.920
对象里边进行操作

26:39.920 --> 26:40.920
懂这个意思吗

26:40.920 --> 26:41.920
这个东西是介石技术

26:41.920 --> 26:42.920
你们只可以自己看一下

26:42.920 --> 26:43.920
总之就把个对象

26:43.920 --> 26:45.920
交给这个VIR

26:45.920 --> 26:46.920
这个东西就是VIR

26:46.920 --> 26:47.920
对吧

26:47.920 --> 26:49.920
或者我们就把它写成VIR吧

26:49.920 --> 26:51.920
就把它写成VIR

26:51.920 --> 26:52.920
这样子呢

26:52.920 --> 26:53.920
你们看着

26:53.920 --> 26:54.920
更加好理解的

26:54.920 --> 26:56.920
对吧

26:56.920 --> 26:57.920
好 那么这个VIR呢

26:57.920 --> 26:58.920
我们这个NAME里边呢

26:58.920 --> 27:00.920
它就是可以用这个OP

27:00.920 --> 27:02.920
你看这里

27:02.920 --> 27:04.920
OPNIKE

27:04.920 --> 27:05.920
对吧

27:05.920 --> 27:06.920
NIKE

27:06.920 --> 27:08.920
好 咱们把它复制一下

27:08.920 --> 27:09.920
好 后边写上什么呢

27:09.920 --> 27:11.920
写上我们的就是

27:11.920 --> 27:13.920
我们用模板制作出来吧

27:13.920 --> 27:14.920
两个百分号

27:14.920 --> 27:15.920
这里边写上什么

27:15.920 --> 27:17.920
写上NAME

27:17.920 --> 27:19.920
这就是模糊查询的

27:19.920 --> 27:20.920
对不对

27:20.920 --> 27:21.920
好 比方说吧

27:21.920 --> 27:22.920
咱们来查一个

27:22.920 --> 27:24.920
查一个

27:24.920 --> 27:27.920
包含那个秀的

27:27.920 --> 27:31.870
包含秀的女生

27:31.870 --> 27:32.870
你看

27:32.870 --> 27:33.870
所以都包含秀

27:33.870 --> 27:34.870
这些女生都包含秀

27:34.870 --> 27:35.870
一共有34个这样

27:35.870 --> 27:36.870
这样的查询条件

27:36.870 --> 27:38.870
一共得到了34个这样的结果

27:38.870 --> 27:39.870
对不对

27:39.870 --> 27:41.870
那么这就是它的查询方式

27:41.870 --> 27:42.870
很简单

27:42.870 --> 27:44.870
这是查询所有

27:44.870 --> 27:46.870
这里我们就讲完了

27:46.870 --> 27:48.870
这个就是查询所有

27:48.870 --> 27:50.870
就是查询多个数据

27:50.870 --> 27:52.870
就用这种方式来进行查询

27:52.870 --> 27:53.870
我们平时用的最多的

27:53.870 --> 27:55.870
也就是这个了

27:55.870 --> 27:57.870
当然这里边查询条件里边

27:57.870 --> 27:59.870
还有什么货者

27:59.870 --> 28:00.870
在什么之中

28:00.870 --> 28:02.870
在什么两个数据之间

28:02.870 --> 28:03.870
或者小于等于

28:03.870 --> 28:04.870
大于等于

28:04.870 --> 28:05.870
去看一下文档

28:05.870 --> 28:07.870
通过这个操作服务里边有很多的

28:07.870 --> 28:08.870
类似的用法

28:08.870 --> 28:09.870
很简单

28:09.870 --> 28:10.870
你看

28:10.870 --> 28:11.870
给两个条件

28:11.870 --> 28:12.870
一列A等于5

28:12.870 --> 28:14.870
或者是B等于6

28:14.870 --> 28:16.870
B这一列等于6

28:16.870 --> 28:17.870
那么都可以

28:17.870 --> 28:18.870
这个条件

28:18.870 --> 28:20.870
咱们通过自由的组合

28:20.870 --> 28:22.870
可以组合出很多的查询条件出来

28:22.870 --> 28:24.870
这是Secret Nice

28:24.870 --> 28:26.870
那么现在我们看

28:26.870 --> 28:28.870
数量

28:28.870 --> 28:30.870
包含关系

28:30.870 --> 28:31.870
还有这个

28:31.870 --> 28:32.870
还有这个东西

28:32.870 --> 28:33.870
我说一下

28:33.870 --> 28:35.870
有的时候查询出来的数据

28:35.870 --> 28:37.870
我特别是在查列表的时候

28:37.870 --> 28:38.870
我一般

28:38.870 --> 28:40.870
可能不希望查太多的数据

28:40.870 --> 28:41.870
什么意思

28:41.870 --> 28:42.870
比如说

28:42.870 --> 28:44.870
我查一个文章列表

28:44.870 --> 28:46.870
每页10条文章

28:46.870 --> 28:48.870
我查一个文章列表

28:48.870 --> 28:49.870
我需不需要把

28:49.870 --> 28:51.870
每一篇文章的那一种

28:51.870 --> 28:52.870
查出来

28:52.870 --> 28:53.870
列表

28:53.870 --> 28:55.870
你们想像网页上

28:55.870 --> 28:57.870
你们看到一个文章列表的时候

28:57.870 --> 28:58.870
它往往是没有

28:58.870 --> 28:59.870
文章那种的

28:59.870 --> 29:01.870
它只是一个文章的简介

29:01.870 --> 29:03.870
这种太多了

29:03.870 --> 29:04.870
哪怕我虽然说

29:04.870 --> 29:05.870
我只查了10条文章

29:05.870 --> 29:06.870
但是文章

29:06.870 --> 29:07.870
如果说每一条文章

29:07.870 --> 29:08.870
都包含那种的话

29:08.870 --> 29:09.870
查询的量还是太大了

29:09.870 --> 29:10.870
这样的网络传输的东西

29:10.870 --> 29:11.870
又太多了

29:11.870 --> 29:12.870
而别人根本就用不到

29:12.870 --> 29:14.870
用不到这些数据

29:14.870 --> 29:15.870
我们往往只有

29:15.870 --> 29:17.870
才在查一篇文章的时候

29:17.870 --> 29:18.870
才会把它的完整的

29:18.870 --> 29:20.870
详细的全部查出来

29:20.870 --> 29:21.870
所以说

29:21.870 --> 29:22.870
我们在查一个列表的时候

29:22.870 --> 29:24.870
有可能会遇到一个情况就是

29:24.870 --> 29:25.870
我有些东西不要

29:25.870 --> 29:26.870
我不想要

29:26.870 --> 29:27.870
那么这个东西怎么办

29:27.870 --> 29:29.870
这种事情怎么办

29:29.870 --> 29:30.870
那么这种事情

29:30.870 --> 29:31.870
它这里边说了

29:31.870 --> 29:33.870
利用这个叫做

29:33.870 --> 29:35.870
叫做啥来着

29:35.870 --> 29:36.870
想不起来了

29:36.870 --> 29:37.870
我看一下吧

29:37.870 --> 29:38.870
叫做这个

29:38.870 --> 29:39.870
Altribute

29:39.870 --> 29:40.870
Altribute

29:40.870 --> 29:41.870
那么在这里边

29:41.870 --> 29:43.870
你自己写上

29:43.870 --> 29:44.870
你要查询的

29:44.870 --> 29:45.870
要查询哪些

29:45.870 --> 29:47.870
模型里边的哪些字段

29:47.870 --> 29:48.870
比方说

29:48.870 --> 29:49.870
咱们举个例子

29:49.870 --> 29:51.870
现在学生这里

29:51.870 --> 29:53.870
我可能不想查那么多

29:53.870 --> 29:55.870
我们就可以用Altribute

29:55.870 --> 29:56.870
来限制一下

29:56.870 --> 29:57.870
我不想查那么多

29:57.870 --> 29:59.870
我只想查什么呢

29:59.870 --> 30:00.870
我看一下

30:00.870 --> 30:01.870
我只想查

30:01.870 --> 30:02.870
我只想查

30:02.870 --> 30:03.870
id姓名

30:03.870 --> 30:05.870
Birthday Sext

30:05.870 --> 30:06.870
其他不要了

30:06.870 --> 30:07.870
那么我就写上

30:07.870 --> 30:08.870
id都特别简单

30:08.870 --> 30:10.870
姓名

30:10.870 --> 30:12.870
sext

30:12.870 --> 30:14.870
Birthday

30:14.870 --> 30:16.870
其他不要了

30:16.870 --> 30:20.020
咱们来看一下

30:20.020 --> 30:22.020
运行

30:22.020 --> 30:23.020
抱错了

30:23.020 --> 30:25.020
你看看

30:25.020 --> 30:26.020
它说

30:28.020 --> 30:29.020
Birthday写错了

30:29.020 --> 30:30.020
Birthday肯定写错了

30:30.020 --> 30:31.020
我看一下

30:31.020 --> 30:32.020
这边

30:32.020 --> 30:35.330
我之前写的啥

30:35.330 --> 30:37.330
学生

30:37.330 --> 30:39.330
Birthday

30:41.330 --> 30:43.330
我怎么写成这个名字呢

30:43.330 --> 30:44.330
算了

30:44.330 --> 30:45.330
就这样吧

30:45.330 --> 30:47.330
就这样吧

30:47.330 --> 30:49.330
咱们把这个地方

30:49.330 --> 30:51.330
拿过来

30:51.330 --> 30:53.330
写成这个Birthday

30:53.330 --> 30:56.900
之前写错了

30:56.900 --> 30:59.270
好

30:59.270 --> 31:00.270
再来

31:00.270 --> 31:01.270
运行

31:01.270 --> 31:03.270
就查出来了

31:03.270 --> 31:05.270
Birthday

31:05.270 --> 31:06.270
那么

31:06.270 --> 31:08.270
是不是就只查了这些数据

31:08.270 --> 31:09.270
对不对

31:09.270 --> 31:10.270
你看一下

31:10.270 --> 31:11.270
它是那个时候

31:11.270 --> 31:13.270
是不是就只查了这些数据

31:13.270 --> 31:14.270
好

31:14.270 --> 31:15.270
那么这里是

31:15.270 --> 31:17.270
它的这种查询方式

31:17.270 --> 31:18.270
然后看一下

31:18.270 --> 31:19.270
还有什么没说的

31:19.270 --> 31:20.270
对

31:20.270 --> 31:21.270
还有一个包含关系

31:21.270 --> 31:22.270
就是我们查学生的时候

31:22.270 --> 31:23.270
还有可能会

31:23.270 --> 31:24.270
想查这个学生

31:24.270 --> 31:26.270
所属的班级信息

31:26.270 --> 31:27.270
那么这个时候

31:27.270 --> 31:28.270
我们就可以使用Include

31:28.270 --> 31:29.270
那么它文档在哪呢

31:29.270 --> 31:30.270
在这

31:30.270 --> 31:32.270
叫做御佳展

31:32.270 --> 31:33.270
叫御佳展

31:34.270 --> 31:35.270
那么这个时候

31:35.270 --> 31:36.270
它会自动来帮你

31:36.270 --> 31:37.270
进行连表查询

31:37.270 --> 31:38.270
只要你两个表是

31:38.270 --> 31:39.270
设置的关系的

31:39.270 --> 31:40.270
我们之前已经设置过了

31:40.270 --> 31:41.270
对吧

31:41.270 --> 31:42.270
在index的介石里面

31:42.270 --> 31:43.270
是不是已经把关系

31:43.270 --> 31:44.270
已经设置过了

31:44.270 --> 31:45.270
来看一下吧

31:45.270 --> 31:46.270
人类型

31:46.270 --> 31:47.270
你看是不是设置过了

31:47.270 --> 31:48.270
这个关系

31:48.270 --> 31:49.270
好关系设置好了之后呢

31:49.270 --> 31:50.270
只要的是两个表

31:50.270 --> 31:51.270
是有关系的

31:51.270 --> 31:52.270
那么它会自动

31:52.270 --> 31:53.270
帮你生成连表查询

31:53.270 --> 31:55.270
只要你做很少量

31:55.270 --> 31:57.270
很少量的配置就行了

31:57.270 --> 31:58.270
那么怎么配置呢

31:58.270 --> 31:59.270
就是告诉他

31:59.270 --> 32:00.270
比方说

32:00.270 --> 32:03.270
咱们在查询的时候

32:06.270 --> 32:07.270
在哪里

32:07.270 --> 32:10.160
我找一找

32:10.160 --> 32:12.160
咱们在查询

32:12.160 --> 32:13.160
就在这

32:13.160 --> 32:15.160
include

32:15.160 --> 32:16.160
包含猛尼

32:16.160 --> 32:17.160
另外一个数据

32:17.160 --> 32:18.160
那么它就会自动进行关联

32:18.160 --> 32:19.160
比方说吧

32:19.160 --> 32:20.160
咱们这里呢

32:20.160 --> 32:21.160
导入

32:21.160 --> 32:23.160
我们还要关联班级

32:23.160 --> 32:24.160
require

32:26.160 --> 32:27.160
models

32:27.160 --> 32:28.160
把我上进目录

32:29.160 --> 32:30.160
models

32:32.160 --> 32:33.160
然后class

32:33.160 --> 32:34.160
关联班级

32:34.160 --> 32:36.160
然后在这边查的时候

32:36.160 --> 32:37.160
我们顺便

32:37.160 --> 32:38.160
还要让他去查一下

32:38.160 --> 32:39.160
这个配置

32:39.160 --> 32:40.160
没有顺序要求

32:40.160 --> 32:42.160
就是include

32:42.160 --> 32:43.160
包含

32:43.160 --> 32:44.160
包含什么呢

32:44.160 --> 32:45.160
还要包含class

32:45.160 --> 32:47.160
还要包含班级

32:47.160 --> 32:48.160
因为它目前只有

32:48.160 --> 32:49.160
一个关系

32:49.160 --> 32:50.160
所以说你数据里面

32:50.160 --> 32:51.160
直接一个

32:51.160 --> 32:52.160
如果说

32:52.160 --> 32:53.160
这个还关联到

32:53.160 --> 32:54.160
其他表的话

32:54.160 --> 32:55.160
你还可以用include

32:55.160 --> 32:56.160
包含

32:56.160 --> 32:57.160
咱们来看一下吧

32:57.160 --> 32:58.160
这个非常神奇的

33:00.160 --> 33:01.160
你看

33:01.160 --> 33:02.160
class是一个object

33:02.160 --> 33:03.160
对吧

33:03.160 --> 33:04.160
class是一个object

33:04.160 --> 33:05.160
这里主要是看不见

33:05.160 --> 33:06.160
看不到了

33:06.160 --> 33:07.160
是因为我这里

33:07.160 --> 33:09.160
是把它那个

33:10.160 --> 33:12.160
我们这里打印一下吧

33:12.160 --> 33:13.160
打印一下

33:13.160 --> 33:14.160
就可以看得清楚了

33:16.160 --> 33:18.160
因为它这里边看不到了

33:18.160 --> 33:19.160
我看一下

33:19.160 --> 33:21.160
我用dl打印呢

33:21.160 --> 33:22.160
dl打印

33:22.160 --> 33:23.160
能不能看

33:23.160 --> 33:26.180
控制台看得到

33:26.180 --> 33:27.180
还是看不到

33:27.180 --> 33:28.180
还是看不到

33:28.180 --> 33:29.180
我们这里呢

33:29.180 --> 33:30.180
这样吧

33:30.180 --> 33:32.180
找到第一个班级的class

33:34.180 --> 33:35.180
第二

33:36.180 --> 33:37.180
来吧

33:37.180 --> 33:38.180
打印一下

33:38.180 --> 33:39.180
包错了

33:40.180 --> 33:41.180
cannot read the property

33:41.180 --> 33:43.180
class of undefend

33:43.180 --> 33:44.180
R.dl

33:44.180 --> 33:45.180
什么的

33:45.180 --> 33:46.180
第二个data

33:46.180 --> 33:47.180
我们的数据在这

33:47.180 --> 33:50.870
这个就不像浏览器那样子

33:50.870 --> 33:51.870
浏览器也是很方便的

33:51.870 --> 33:52.870
你看得到

33:52.870 --> 33:53.870
是不是可以看得到

33:53.870 --> 33:54.870
对象是在的

33:54.870 --> 33:55.870
放心

33:55.870 --> 33:56.870
对象是绝对在的

33:56.870 --> 33:57.870
只是个控制台

33:57.870 --> 33:58.870
没给显示出来而已

33:58.870 --> 33:59.870
那么它就这样子的

33:59.870 --> 34:00.870
就把每一个班级信息

34:00.870 --> 34:02.870
是不是就全部打印出来了

34:02.870 --> 34:03.870
对不对

34:03.870 --> 34:05.870
每个班级信息就打印出来了

34:05.870 --> 34:06.870
OK

34:06.870 --> 34:07.870
那么这就是包含关系

34:07.870 --> 34:08.870
当然你如果说

34:08.870 --> 34:09.870
你查班级的时候

34:09.870 --> 34:10.870
把学生包含进来

34:10.870 --> 34:11.870
那么每个班级

34:11.870 --> 34:12.870
包含了一个学生数据

34:12.870 --> 34:13.870
这非常智能的

34:13.870 --> 34:14.870
它会自动帮你来

34:14.870 --> 34:16.870
处理这些问题

34:16.870 --> 34:17.870
这样的意思吧

34:17.870 --> 34:18.870
好

34:18.870 --> 34:19.870
那么这里呢

34:19.870 --> 34:21.870
就没有啥了

34:21.870 --> 34:22.870
就没有啥了

34:22.870 --> 34:24.870
没有啥了

34:24.870 --> 34:25.870
好

34:25.870 --> 34:26.870
那么我们这就是

34:26.870 --> 34:28.870
我们最基本的一些查询

34:28.870 --> 34:29.870
我们可以通过这些查询

34:29.870 --> 34:31.870
能够满足你前端开发

34:31.870 --> 34:35.870
里面用到数据库的90%以上的

34:35.870 --> 34:37.870
场景都可以覆盖掉了

34:37.870 --> 34:38.870
遇到一些特殊场景的话

34:38.870 --> 34:39.870
你可以去看一下文档

34:39.870 --> 34:41.870
这个文档也蛮简单的

34:41.870 --> 34:42.870
好

34:42.870 --> 34:43.870
这是关于查询

34:43.870 --> 34:44.870
那么接下来

34:44.870 --> 34:45.870
我告诉大家

34:45.870 --> 34:46.870
你们下来过后

34:46.870 --> 34:47.870
要做一个练习

34:47.870 --> 34:48.870
就是Elderly

34:48.870 --> 34:50.870
要把这两个做了

34:50.870 --> 34:51.870
登录

34:51.870 --> 34:53.870
和得到根据ID

34:53.870 --> 34:54.870
得到管理员

34:54.870 --> 34:56.870
还要得到所有的管理员

34:56.870 --> 34:57.870
好

34:57.870 --> 34:58.870
学生这里得到单个学生

34:58.870 --> 34:59.870
根据ID

34:59.870 --> 35:00.870
得到单个学生

35:00.870 --> 35:02.870
得到分业来得到学生

35:02.870 --> 35:03.870
多了意思吧

35:03.870 --> 35:04.870
然后呢班级这里呢

35:04.870 --> 35:05.870
得到所有班级

35:05.870 --> 35:06.870
因为班级不需要分业

35:06.870 --> 35:07.870
太少了

35:07.870 --> 35:08.870
这个数据

35:08.870 --> 35:09.870
也不多

35:09.870 --> 35:10.870
我们什么时候要去

35:10.870 --> 35:11.870
需要分业

35:11.870 --> 35:13.870
是那种上百上千

35:13.870 --> 35:14.870
几万上万

35:14.870 --> 35:16.870
上千万这种级别数据

35:16.870 --> 35:17.870
才需要分业

35:17.870 --> 35:18.870
像几十条数据

35:18.870 --> 35:20.870
都不用去分业了

35:20.870 --> 35:21.870
班级我就查询

35:21.870 --> 35:22.870
所有的班级

35:22.870 --> 35:23.870
以及根据ID

35:23.870 --> 35:24.870
再查一个班级

35:24.870 --> 35:25.870
然后数据这里

35:25.870 --> 35:26.870
是要分业的

35:26.870 --> 35:28.870
还可以根据

35:28.870 --> 35:29.870
书明来查询

35:29.870 --> 35:30.870
对吧

35:30.870 --> 35:31.870
书明作者来进行查询

35:31.870 --> 35:32.870
书明和作者

35:32.870 --> 35:34.870
还可以是一个货者的关系

35:34.870 --> 35:35.870
不要让我查个关键字

35:35.870 --> 35:36.870
这个关键字

35:36.870 --> 35:37.870
可以出现在书

35:37.870 --> 35:38.870
书明里边

35:38.870 --> 35:39.870
也可以出现在作者里边

35:39.870 --> 35:40.870
是一个货者的关系

35:40.870 --> 35:41.870
大家可以自行

35:41.870 --> 35:42.870
去查一下文档

35:42.870 --> 35:43.870
看怎么来做

35:43.870 --> 35:44.870
这个代码我做好过后

35:44.870 --> 35:45.870
我会提交到

35:45.870 --> 35:46.870
这个github里边

35:46.870 --> 35:48.870
就提交到这个圆码里边

35:48.870 --> 35:49.870
大家自己下去做一下

35:49.870 --> 35:50.870
每一个就是

35:50.870 --> 35:51.870
每一个模型

35:51.870 --> 35:52.870
你至少要有

35:52.870 --> 35:53.870
这么两种查询

35:53.870 --> 35:54.870
一个是查一个

35:54.870 --> 35:56.870
一个是查多个

35:56.870 --> 35:57.870
至少要有这两种

35:57.870 --> 35:58.870
然后书明里边

35:58.870 --> 35:59.870
多了一个功能

35:59.870 --> 36:00.870
就是脑顶

36:00.870 --> 36:01.870
登录

36:01.870 --> 36:02.870
好了

36:02.870 --> 36:03.870
去把它完成

36:03.870 --> 36:04.870
这是关于查询这一块

36:04.870 --> 36:05.870
咱们要讲的东西

