WEBVTT

00:00.690 --> 00:04.690
文件这一块还没有完全结束

00:04.690 --> 00:07.690
还有一个非常非常重要的概念

00:07.690 --> 00:10.690
这个概念它不仅是跟文件有关

00:10.690 --> 00:12.690
而且将来我们学一个漏的

00:12.690 --> 00:13.690
最重要的是什么呢

00:13.690 --> 00:14.690
是要搭一个服务器

00:14.690 --> 00:16.690
还跟服务器有关系

00:16.690 --> 00:17.690
这什么概念呢

00:17.690 --> 00:18.690
就是流的概念

00:18.690 --> 00:20.690
那么在学习流的时候

00:20.690 --> 00:22.690
我们必须要先学习文件

00:22.690 --> 00:23.690
学习文件之后

00:23.690 --> 00:25.690
我们才有一个载体

00:25.690 --> 00:26.690
我才能一讲

00:26.690 --> 00:28.690
具体是一个什么样的效果

00:28.690 --> 00:29.690
不然的话

00:29.690 --> 00:32.690
其实流是跟文件没有直接关系的

00:32.690 --> 00:34.690
它是没有直接关系的

00:34.690 --> 00:36.690
它是一个抽象的概念

00:36.690 --> 00:38.690
但是如果说你不学文件的话

00:38.690 --> 00:39.690
你直接去学这个流的话

00:39.690 --> 00:41.690
就是纸上坦冰了

00:41.690 --> 00:43.690
没法给你写的爱吧

00:43.690 --> 00:44.690
所以我们学了文件之后

00:44.690 --> 00:47.690
把这个流的概念给它讲了

00:47.690 --> 00:50.690
那么我们这一块讲文件流

00:50.690 --> 00:52.690
文件流是流的一种

00:52.690 --> 00:54.690
为什么需要文件流呢

00:54.690 --> 00:56.690
给它举个例子

00:56.690 --> 00:58.690
比方说我们读文件

00:58.690 --> 01:00.690
那个文件呢

01:00.690 --> 01:02.690
它不是一个文本文件

01:02.690 --> 01:04.690
可能是一张图片

01:04.690 --> 01:06.690
那个图片有多大呢

01:06.690 --> 01:07.690
有几百兆

01:07.690 --> 01:09.690
你们有没有见过几百兆的图片

01:09.690 --> 01:10.690
有没有

01:10.690 --> 01:13.690
如果说你用一些高像素的手机

01:13.690 --> 01:16.690
或者是也高像素的数码相机

01:16.690 --> 01:17.690
拍出来的照片

01:17.690 --> 01:19.690
它的数据就很大

01:19.690 --> 01:20.690
不光是几百兆

01:20.690 --> 01:22.690
还有那种一些科学的

01:22.690 --> 01:25.690
就是一些科学实验室里边的一些

01:25.690 --> 01:26.690
相片

01:26.690 --> 01:28.690
那么它的可能是几百异像素

01:28.690 --> 01:30.690
那么这个东西拍出来的文件

01:30.690 --> 01:31.690
就非常非常大了

01:31.690 --> 01:33.690
可能几个G

01:33.690 --> 01:35.690
或者说我们有一篇小说

01:35.690 --> 01:36.690
就普通文字

01:36.690 --> 01:37.690
那么一线小说

01:37.690 --> 01:39.690
如果放到一个文本文件里边

01:39.690 --> 01:40.690
它也非常大

01:40.690 --> 01:42.690
可能几百兆

01:42.690 --> 01:43.690
那么像这种文件

01:43.690 --> 01:46.690
如果说按照我们以前的读取方式

01:46.690 --> 01:48.690
以前读取方式是什么呢

01:48.690 --> 01:49.690
就是read

01:49.690 --> 01:50.690
我们上节课学了咋

01:50.690 --> 01:52.690
就是那个

01:52.690 --> 01:54.690
FS模块里边

01:54.690 --> 01:55.690
read file

01:55.690 --> 01:56.690
所以用这种方式来读

01:56.690 --> 01:58.690
用这种方式来读可不可以呢

01:58.690 --> 01:59.690
可以

01:59.690 --> 02:01.690
但是导致的结果是什么呢

02:01.690 --> 02:03.690
我们的文件是放到尺盘上的

02:03.690 --> 02:05.690
放到硬盘上的

02:05.690 --> 02:07.690
那么硬盘上是可以持就化的

02:07.690 --> 02:08.690
硬盘的空间很大的

02:08.690 --> 02:10.690
像几个G的文件无所谓的

02:10.690 --> 02:11.690
放进去就行了

02:11.690 --> 02:14.690
但是那一存的空间是非常有限的

02:14.690 --> 02:16.690
又特别是服务器

02:16.690 --> 02:18.690
你们以后去买服务器就知道了

02:18.690 --> 02:20.690
服务器是蛮贵的

02:20.690 --> 02:22.690
服务器的内存空间是没有那么大的

02:22.690 --> 02:23.690
像我买了个服务器

02:23.690 --> 02:25.690
一年给一千多块钱

02:25.690 --> 02:27.690
就一个G的内存

02:27.690 --> 02:29.690
而且操作系统还要占用一部分内存

02:29.690 --> 02:32.690
有给你的内存可能只有几百兆了

02:32.690 --> 02:33.690
没有多少内存了

02:33.690 --> 02:34.690
那么这个时候

02:34.690 --> 02:36.690
如果说你用原来的方式去读

02:36.690 --> 02:37.690
那吓死人了

02:37.690 --> 02:41.690
你要把所有的东西全部要读到内存

02:41.690 --> 02:42.690
我们之前的读法就是

02:42.690 --> 02:43.690
把所有东西全部拿到内存

02:43.690 --> 02:45.690
然后供你的操作

02:45.690 --> 02:46.690
比方说你读一个buffer

02:46.690 --> 02:47.690
我们之前看到过

02:47.690 --> 02:49.690
读一个很小很小的图片

02:49.690 --> 02:50.690
读出来多少了

02:50.690 --> 02:51.690
一万多个字节

02:51.690 --> 02:52.690
对吧

02:52.690 --> 02:53.690
全部放到内存里边

02:53.690 --> 02:54.690
那稍微夸张一点的文件

02:54.690 --> 02:56.690
一读出来就非常吓人了

02:56.690 --> 02:57.690
对不对

02:57.690 --> 02:58.690
那么这个时候

02:58.690 --> 03:00.690
我们就不希望他一下子

03:00.690 --> 03:02.690
把所有东西全部读出来

03:02.690 --> 03:04.690
我们希望他一点一点的读

03:04.690 --> 03:05.690
那么一点一点的读

03:05.690 --> 03:08.690
这种做法就是流的做法

03:08.690 --> 03:09.690
那么我们首先看

03:09.690 --> 03:11.690
什么是流

03:11.690 --> 03:12.690
流是什么意思呢

03:12.690 --> 03:14.690
流的指的是数据的流动

03:14.690 --> 03:16.690
就是数据从一个地方

03:16.690 --> 03:18.690
慢慢的一点一点的

03:18.690 --> 03:19.690
流到另一个地方

03:19.690 --> 03:20.690
不是说一下子

03:20.690 --> 03:21.690
全部过来了

03:21.690 --> 03:22.690
全部过来了吃不消的

03:22.690 --> 03:24.690
就像你们到超市里面

03:24.690 --> 03:25.690
排队的时候

03:25.690 --> 03:26.690
不是一下子挤

03:26.690 --> 03:27.690
把门框的挤烂

03:27.690 --> 03:29.690
然后跑到超市里面去买东西

03:29.690 --> 03:31.690
不是这几天疫情吗

03:31.690 --> 03:34.690
欧洲很多超市商场都在抢

03:34.690 --> 03:35.690
对吧

03:35.690 --> 03:36.690
在抢货

03:36.690 --> 03:38.690
一下子涌进商场那边吃不消的

03:38.690 --> 03:40.690
所以说我们希望排队

03:40.690 --> 03:42.690
一点一点的流动

03:42.690 --> 03:43.690
那么这就是流

03:43.690 --> 03:44.690
它是一个抽象的概念

03:44.690 --> 03:45.690
它并不是说

03:45.690 --> 03:46.690
一定要一次文件

03:46.690 --> 03:47.690
任何东西都可以

03:47.690 --> 03:49.690
这里有张图片你看一下吧

03:49.690 --> 03:50.690
就是指的是

03:50.690 --> 03:52.690
数据从一个地方

03:52.690 --> 03:53.690
通过

03:53.690 --> 03:55.690
有点像一个管道一样

03:55.690 --> 03:56.690
慢慢的流到别的地方

03:56.690 --> 03:58.690
那么这个流动的过程

03:58.690 --> 03:59.690
就叫做流

03:59.690 --> 04:00.690
就叫做流

04:00.690 --> 04:01.690
流的特点就是

04:01.690 --> 04:02.690
一点一点的过来

04:02.690 --> 04:04.690
不要刷一下子全部过来

04:04.690 --> 04:05.690
我用一点

04:05.690 --> 04:06.690
拿一点

04:06.690 --> 04:07.690
用一点

04:07.690 --> 04:08.690
拿一点

04:08.690 --> 04:09.690
是这么个意识

04:09.690 --> 04:10.690
这就是流的概念

04:10.690 --> 04:11.690
当然它的

04:11.690 --> 04:12.690
这个东西

04:12.690 --> 04:13.690
它指的是

04:13.690 --> 04:15.690
从一个地方流到另一个地方

04:15.690 --> 04:16.690
对吧

04:16.690 --> 04:17.690
但是它

04:17.690 --> 04:18.690
两个地方是不一定的

04:18.690 --> 04:19.690
比方说你可以从

04:19.690 --> 04:20.690
内存

04:20.690 --> 04:21.690
流到

04:21.690 --> 04:22.690
硬盘

04:22.690 --> 04:24.690
也可以是

04:24.690 --> 04:25.690
硬盘里边的数据

04:25.690 --> 04:26.690
流到内存

04:26.690 --> 04:27.690
也可以是网卡

04:27.690 --> 04:28.690
就是从网卡

04:28.690 --> 04:29.690
接收到的数据

04:29.690 --> 04:30.690
流到内存里边

04:30.690 --> 04:31.690
因为我们知道

04:31.690 --> 04:32.690
CPU只能操作内存

04:32.690 --> 04:33.690
它不能操作别的东西

04:33.690 --> 04:34.690
总之要到内存

04:34.690 --> 04:36.690
我才能操作

04:36.690 --> 04:38.690
或者是我们内存里边的东西

04:38.690 --> 04:39.690
流向网卡

04:39.690 --> 04:40.690
对吧

04:40.690 --> 04:42.690
它可以是不同的戒指

04:42.690 --> 04:43.690
它不是一定的

04:43.690 --> 04:46.690
总之这种方式叫做流

04:46.690 --> 04:47.690
然后我们可以看到

04:47.690 --> 04:48.690
流是从一个地方

04:48.690 --> 04:49.690
流到另一个地方

04:49.690 --> 04:50.690
那么流

04:50.690 --> 04:52.690
它有个特点就是它有方向

04:52.690 --> 04:53.690
不同的语言里边

04:53.690 --> 04:55.690
它这个方向的含义不一样

04:55.690 --> 04:56.690
比方说加把语

04:56.690 --> 04:57.690
语言里边就是

04:57.690 --> 04:58.690
什么输入流输出流

04:58.690 --> 04:59.690
对吧

04:59.690 --> 05:00.690
那么我们在

05:00.690 --> 05:01.690
no.js的概念里边

05:01.690 --> 05:03.690
把它分为这么三种

05:03.690 --> 05:04.690
一种是可读流

05:04.690 --> 05:05.690
可写流

05:05.690 --> 05:06.690
以及双功流

05:06.690 --> 05:07.690
那么我们一个个看

05:07.690 --> 05:09.690
什么叫可读流呢

05:09.690 --> 05:10.690
它的名字叫做

05:10.690 --> 05:11.690
readable

05:14.060 --> 05:16.060
可写流呢

05:16.060 --> 05:17.060
叫做

05:17.060 --> 05:19.060
readable

05:19.060 --> 05:20.060
双功流呢

05:20.060 --> 05:21.060
双功流的单词

05:21.060 --> 05:22.060
我还真忘了

05:22.060 --> 05:23.060
我可以查一下

05:23.060 --> 05:24.060
查一下那个

05:24.060 --> 05:26.060
乐乐结实的观望

05:26.060 --> 05:27.060
那么可读流是什么意思呢

05:27.060 --> 05:28.060
它指的是

05:28.060 --> 05:31.060
数据从源头流向内存

05:31.060 --> 05:32.060
就叫做可读流

05:32.060 --> 05:33.060
比方说我们

05:33.060 --> 05:35.060
文件可读流是什么意思

05:35.060 --> 05:36.060
就是从文件里边

05:36.060 --> 05:38.060
在磁盘里边的文件数据

05:38.060 --> 05:39.060
缓慢的

05:39.060 --> 05:40.060
一点一点

05:40.060 --> 05:41.060
一部分一部分的

05:42.060 --> 05:43.060
流向内存

05:43.060 --> 05:44.060
就是可读流

05:45.060 --> 05:46.060
什么叫可写流呢

05:46.060 --> 05:47.060
就是数据

05:47.060 --> 05:49.060
从内存流向源头

05:49.060 --> 05:50.060
比方说我们内存里边

05:50.060 --> 05:52.060
要往文件里边写东西

05:52.060 --> 05:53.060
那么就是

05:53.060 --> 05:54.060
我们构建一些

05:54.060 --> 05:55.060
不要内存里边的数据

05:55.060 --> 05:57.060
然后一部分一部分的

05:57.060 --> 05:58.060
往内存里边

05:58.060 --> 05:59.060
往那个文件里边装

05:59.060 --> 06:00.060
就要做可写流

06:00.060 --> 06:01.060
当然呢

06:01.060 --> 06:02.060
网卡也是一样

06:02.060 --> 06:03.060
从网卡里边的数据

06:03.060 --> 06:05.060
一部分一部分读出来

06:05.060 --> 06:07.060
那么这就是可读流

06:07.060 --> 06:08.060
从我内存里边的数据

06:08.060 --> 06:09.060
写向网卡

06:09.060 --> 06:10.060
我们相当于是享用

06:10.060 --> 06:11.060
对吧

06:11.060 --> 06:12.060
就是可写流

06:12.060 --> 06:13.060
流是有方向的

06:13.060 --> 06:15.060
分为可读可写

06:15.060 --> 06:16.060
那么什么叫双功流呢

06:16.060 --> 06:17.060
就是这个流

06:17.060 --> 06:19.060
它既可写又可读

06:19.060 --> 06:20.060
实际上双功流呢

06:20.060 --> 06:22.060
它本身并不是一个流的内想

06:22.060 --> 06:24.060
它是把可读流和可写流

06:24.060 --> 06:26.060
封装成一个完整的对象

06:26.060 --> 06:27.060
它里边既有可写流

06:27.060 --> 06:28.060
也有可读流

06:28.060 --> 06:30.060
它是自己构建出来的

06:30.060 --> 06:31.060
双功流呢

06:31.060 --> 06:32.060
我们可能

06:32.060 --> 06:33.060
我们可能最重要的是

06:33.060 --> 06:35.060
要讲这个可读流和可写流

06:35.060 --> 06:36.060
双功流呢

06:36.060 --> 06:37.060
我们遇到就说吧

06:37.060 --> 06:38.060
遇不到就算了

06:38.060 --> 06:39.060
流了

06:39.060 --> 06:40.060
不太会自己写流

06:40.060 --> 06:42.060
流了个概念其实还蛮复杂的

06:42.060 --> 06:45.060
我们不太会去自己写流

06:45.060 --> 06:46.060
我们会怎么样用呢

06:46.060 --> 06:48.060
就是我们一般来说

06:48.060 --> 06:49.060
读文件的时候

06:49.060 --> 06:51.060
写文件的时候

06:51.060 --> 06:52.060
接受请求的时候

06:52.060 --> 06:53.060
享用的时候

06:53.060 --> 06:54.060
我们这个时候呢

06:54.060 --> 06:56.060
可能会用到可读流和可写流

06:56.060 --> 06:57.060
双功流

06:57.060 --> 06:58.060
如果说我们

06:58.060 --> 06:59.060
我讲在讲

06:59.060 --> 07:00.060
因为我也

07:00.060 --> 07:01.060
背课也没有背到那么远

07:01.060 --> 07:02.060
如果说我讲讲了

07:02.060 --> 07:03.060
觉得可行

07:03.060 --> 07:04.060
会用到

07:04.060 --> 07:05.060
我就给大家讲一讲

07:05.060 --> 07:06.060
这个东西呢

07:06.060 --> 07:07.060
你周围了解就行了

07:07.060 --> 07:08.060
这个综合

07:08.060 --> 07:09.060
我们看一下吧

07:09.060 --> 07:11.060
双功流的单词还是把它写出来

07:11.060 --> 07:13.060
找一个里面

07:13.060 --> 07:14.060
Stream

07:14.060 --> 07:15.060
Stream

07:15.060 --> 07:17.060
在这

07:17.060 --> 07:19.060
Type of stream

07:19.060 --> 07:21.060
就这个

07:21.060 --> 07:23.060
下面还有一种流

07:23.060 --> 07:24.060
叫Transform

07:24.060 --> 07:25.060
我们就完全遇不到了

07:25.060 --> 07:26.060
Transform这个流呢

07:26.060 --> 07:29.060
它是双功流的一种变种

07:29.060 --> 07:31.060
我们就看一下双功流

07:31.060 --> 07:32.060
打个标志就行了

07:32.060 --> 07:33.060
它其实就是把

07:33.060 --> 07:35.060
可写流和可读流

07:35.060 --> 07:36.060
混在一起

07:36.060 --> 07:38.060
这是关于流的一些基本概念

07:38.060 --> 07:40.060
那么为什么需要流呢

07:40.060 --> 07:41.060
主要是

07:41.060 --> 07:42.060
我们刚才都讲了

07:42.060 --> 07:43.060
主要是有两个原因

07:43.060 --> 07:45.060
一个是

07:45.060 --> 07:47.060
其他的戒指和内存的

07:47.060 --> 07:49.060
数据规模不一致

07:49.060 --> 07:51.060
说的好像很高大上的样子

07:51.060 --> 07:53.060
我们可以简单来说就是

07:53.060 --> 07:55.060
它的空间大小不一致

07:55.060 --> 07:57.060
磁盘里边可以装很多的数据

07:57.060 --> 07:59.060
但内存里边可以装的数据很少

07:59.060 --> 08:01.060
内存比较小

08:01.060 --> 08:02.060
所以说

08:02.060 --> 08:03.060
我们要读一个大数据的话

08:03.060 --> 08:05.060
我们不可能把磁盘里边

08:05.060 --> 08:07.060
所有数据一下子打到内存里边吃不消

08:07.060 --> 08:09.060
只能一部分一部分通过流动

08:09.060 --> 08:11.060
一部分拿一部分用一部分

08:11.060 --> 08:13.060
拿一部分用一部分

08:13.060 --> 08:14.060
那个用具体怎么用

08:14.060 --> 08:15.060
那就随便离了

08:15.060 --> 08:16.060
你可以把它保存起来

08:16.060 --> 08:18.060
也可以把它输出到屏幕

08:18.060 --> 08:19.060
无所谓的

08:19.060 --> 08:20.060
看你怎么去用

08:20.060 --> 08:21.060
总之它读的时候

08:21.060 --> 08:23.060
还有一部分一部分拿出来

08:23.060 --> 08:24.060
数据规模不一致

08:24.060 --> 08:26.060
导致了我们需要流

08:26.060 --> 08:27.060
第二种是

08:27.060 --> 08:29.060
处理能力不一致

08:29.060 --> 08:30.060
因为我们知道内存里边

08:30.060 --> 08:32.060
处理速度是非常非常快的

08:32.060 --> 08:33.060
而一些其他戒指

08:33.060 --> 08:34.060
比如说像网卡

08:34.060 --> 08:35.060
还有网络传输

08:35.060 --> 08:37.060
以及硬盘

08:37.060 --> 08:38.060
它有一个传输

08:38.060 --> 08:41.060
以前那个就是机械硬盘

08:41.060 --> 08:43.060
现在是SSD

08:43.060 --> 08:45.060
叫啥

08:45.060 --> 08:47.060
就是SSD硬盘

08:47.060 --> 08:48.060
那么

08:48.060 --> 08:49.060
但是无论是什么硬盘

08:49.060 --> 08:50.060
它的速度

08:50.060 --> 08:52.060
肯定是没法跟内存相比的

08:52.060 --> 08:54.060
因此它速度有快慢

08:54.060 --> 08:55.060
我们内存

08:55.060 --> 08:56.060
如果说内存数据

08:56.060 --> 08:57.060
一下子全部交给硬盘

08:57.060 --> 08:58.060
它又吃不消了

08:58.060 --> 09:00.060
它虽然空间大

09:00.060 --> 09:02.060
但是处理的速度太慢了

09:02.060 --> 09:03.060
它一下子处理这么多出去

09:03.060 --> 09:05.060
硬盘就可能会

09:05.060 --> 09:06.060
高速的转动

09:06.060 --> 09:07.060
没法做其他事情

09:07.060 --> 09:08.060
会导致卡顿

09:08.060 --> 09:10.060
因此我们可能希望

09:10.060 --> 09:11.060
比方说

09:11.060 --> 09:12.060
我给大家举个极端的例子

09:12.060 --> 09:14.060
我们内存可能装了下

09:14.060 --> 09:15.060
就一个G的

09:15.060 --> 09:16.060
现在我们服务器很好

09:16.060 --> 09:18.060
一个G数据能装下

09:18.060 --> 09:20.060
我现在把一个G的数据

09:20.060 --> 09:21.060
全部往内存里面塞

09:21.060 --> 09:23.060
我硬盘里面塞

09:23.060 --> 09:24.060
硬盘可能需要

09:24.060 --> 09:25.060
多少呢

09:25.060 --> 09:27.060
需要5秒钟

09:27.060 --> 09:29.060
才能装了下我们的数据

09:29.060 --> 09:31.060
才能装完我们的数据

09:31.060 --> 09:32.060
5秒钟

09:32.060 --> 09:33.060
它其他事情干不了

09:33.060 --> 09:34.060
其他事情全部很卡

09:34.060 --> 09:35.060
因为我们的服务器

09:35.060 --> 09:36.060
要做很多很多事情的

09:36.060 --> 09:39.060
都要跟硬盘打交道

09:39.060 --> 09:40.060
那么这个时候硬盘的

09:40.060 --> 09:41.060
其他事情的

09:41.060 --> 09:42.060
就响应速度很慢

09:42.060 --> 09:43.060
就影响了其他地方

09:43.060 --> 09:44.060
所以说我们可以

09:44.060 --> 09:45.060
存的时候慢慢点

09:45.060 --> 09:46.060
不要那么着急

09:46.060 --> 09:47.060
一点一点来

09:47.060 --> 09:48.060
给一点存一点

09:48.060 --> 09:49.060
你去做忙一些别的事情

09:49.060 --> 09:51.060
我再慢慢再给一点

09:51.060 --> 09:53.060
可以用这种方式来处理

09:53.060 --> 09:54.060
这就是

09:54.060 --> 09:56.060
因为处理能力不一致

09:56.060 --> 09:57.060
所以说我们也需要留

09:57.060 --> 09:58.060
来缓慢的

09:58.060 --> 10:00.060
一部分一部分的来处理

10:00.060 --> 10:01.060
就这么个意思

10:01.060 --> 10:02.060
好 接下来我们来看

10:02.060 --> 10:04.060
这节课我们学习的文件流

10:04.060 --> 10:05.060
好 留这个概念

10:05.060 --> 10:06.060
我给他说一下

10:06.060 --> 10:08.060
它是在note.js里面

10:08.060 --> 10:10.060
它是有这么一个模块

10:10.060 --> 10:12.060
这个了解一下就行了

10:12.060 --> 10:13.060
叫做stune

10:13.060 --> 10:14.060
有这么一个模块

10:14.060 --> 10:15.060
这个模块里面

10:15.060 --> 10:19.060
它提供了这么两个内

10:19.060 --> 10:20.060
一个叫readable

10:20.060 --> 10:22.060
一个叫writeable

10:22.060 --> 10:23.060
提供了这么两个内

10:23.060 --> 10:24.060
这两个内里面

10:24.060 --> 10:26.060
它提供了一些公共的

10:26.060 --> 10:27.060
就是你凡是

10:27.060 --> 10:28.060
你是一个流

10:28.060 --> 10:30.060
不管你是一个什么

10:30.060 --> 10:31.060
网络流

10:31.060 --> 10:33.060
或者是还是一个文件流

10:33.060 --> 10:35.060
你都应该去继承这两个东西

10:35.060 --> 10:36.060
这两个内

10:36.060 --> 10:37.060
readable表示可读流

10:37.060 --> 10:39.060
readable表示可写流

10:39.060 --> 10:40.060
于是这些流了

10:40.060 --> 10:41.060
就有一些共同的行为

10:41.060 --> 10:43.060
因为它是继承关系

10:43.060 --> 10:44.060
所以它有一些

10:44.060 --> 10:45.060
附内里面的共同的方法

10:45.060 --> 10:47.060
共同的属性

10:47.060 --> 10:48.060
所以我们这节课

10:48.060 --> 10:50.060
学的流里面的很多的方法

10:50.060 --> 10:51.060
很多的属性都是公用的

10:51.060 --> 10:52.060
将来我们遇到了别的流

10:52.060 --> 10:54.060
它也是这样一套做法

10:54.060 --> 10:56.060
所以我们通过文件流了

10:56.060 --> 10:58.060
来见证这些东西

10:58.060 --> 10:59.060
ok

10:59.060 --> 11:00.060
我们再回到这儿

11:00.060 --> 11:01.060
我们文件流了

11:01.060 --> 11:02.060
这节课讲不完

11:02.060 --> 11:04.060
这个东西内容还是蛮多的

11:04.060 --> 11:05.060
文件流了

11:05.060 --> 11:06.060
什么叫文件流

11:06.060 --> 11:07.060
就是指的是

11:07.060 --> 11:09.060
内存数据和持盘数据之间的流动

11:09.060 --> 11:10.060
对吧

11:10.060 --> 11:13.060
数据从持盘文件

11:13.060 --> 11:14.060
一张图片

11:14.060 --> 11:15.060
一张那个

11:15.060 --> 11:16.060
一个小说

11:16.060 --> 11:17.060
文本文档

11:17.060 --> 11:18.060
然后呢

11:18.060 --> 11:20.060
读去到内存

11:20.060 --> 11:21.060
就是可读流

11:21.060 --> 11:23.060
文件可读流

11:23.060 --> 11:24.060
如果说我们

11:24.060 --> 11:26.060
内存里边的东西

11:26.060 --> 11:27.060
要做一些数据

11:27.060 --> 11:28.060
往文件里边写

11:28.060 --> 11:30.060
那么就叫做可写流

11:30.060 --> 11:31.060
文件可写流

11:31.060 --> 11:32.060
就这么个意思

11:32.060 --> 11:33.060
好

11:33.060 --> 11:34.060
那么文件流

11:34.060 --> 11:35.060
这就是文件流的概念

11:35.060 --> 11:37.060
然后文件流怎么来的呢

11:37.060 --> 11:38.060
怎么来创建的呢

11:38.060 --> 11:39.060
我们这节课

11:39.060 --> 11:40.060
只讲一个

11:40.060 --> 11:42.060
就是文件可读流

11:42.060 --> 11:45.060
那么怎么来创建一个文件可读流呢

11:45.060 --> 11:46.060
通过fs这个模块

11:46.060 --> 11:47.060
我们上节课学的

11:47.060 --> 11:48.060
里面一个函数叫

11:48.060 --> 11:50.060
create red stream

11:50.060 --> 11:51.060
表示

11:51.060 --> 11:53.060
创建一个可以读的流

11:54.060 --> 11:55.060
这就是

11:55.060 --> 11:57.060
创建一个文件可读流

11:57.060 --> 11:58.060
用于读取文件内容

11:58.060 --> 12:00.060
咱们来写一下

12:00.060 --> 12:02.060
fs

12:02.060 --> 12:04.060
require

12:04.060 --> 12:06.060
fs

12:06.060 --> 12:08.060
fscraze red stream

12:08.060 --> 12:10.060
这里边有什么参数呢

12:10.060 --> 12:11.060
这里边有两个参数

12:11.060 --> 12:12.060
一个是pass

12:12.060 --> 12:14.060
表示读取的文件路径

12:14.060 --> 12:16.060
这里要读哪个文件

12:16.060 --> 12:17.060
这个文件路径

12:17.060 --> 12:19.060
我这里就随便写个文件

12:19.060 --> 12:21.060
比方说一个文本文件

12:22.060 --> 12:24.060
abc

12:24.060 --> 12:26.060
我们就假设这个文件内容很多

12:26.060 --> 12:27.060
那就假设了一种很多

12:27.060 --> 12:28.060
然后呢

12:28.060 --> 12:29.060
我们把个流学学玩了过

12:29.060 --> 12:30.060
给大家讲一个例子

12:30.060 --> 12:31.060
你看一下

12:31.060 --> 12:32.060
流的唯利就知道了

12:32.060 --> 12:33.060
我们这里

12:33.060 --> 12:34.060
这节课

12:34.060 --> 12:36.060
因为只涉及到可读流

12:36.060 --> 12:37.060
所以说我们这里

12:37.060 --> 12:39.060
这里还做不出一个明显的例子

12:39.060 --> 12:41.060
比方说我们这里写一个abc

12:42.060 --> 12:44.060
那么这是create stream

12:45.060 --> 12:46.060
那么这里边有没有参数呢

12:46.060 --> 12:47.060
第一个参数就是pass

12:47.060 --> 12:49.060
读取的文件路径

12:49.060 --> 12:50.060
这个路径

12:50.060 --> 12:51.060
是不是还是我们上铁合学的

12:51.060 --> 12:53.060
我们一般都会用什么

12:53.060 --> 12:54.060
用一个决定路径

12:54.060 --> 12:56.760
pass

12:56.760 --> 12:57.760
来吧

12:57.760 --> 13:00.070
filing

13:00.070 --> 13:02.070
passresult

13:02.070 --> 13:03.070
di2

13:03.070 --> 13:04.070
然后呢

13:04.070 --> 13:05.070
abc

13:05.070 --> 13:06.070
txt

13:06.070 --> 13:07.070
这个不解释了

13:07.070 --> 13:09.070
filing 传进去

13:09.070 --> 13:11.070
这是我们要读的文件

13:12.070 --> 13:13.070
文件路径

13:13.070 --> 13:14.070
然后第二个参数

13:14.070 --> 13:15.070
可写可不写

13:15.070 --> 13:16.070
这个参数是配置

13:16.070 --> 13:18.070
以后你们要学会看API

13:18.070 --> 13:19.070
反正加这个东西的话

13:19.070 --> 13:20.070
就是配一个配置

13:20.070 --> 13:22.070
就是可选的

13:22.070 --> 13:23.070
不写的话

13:23.070 --> 13:24.070
很多有默认值的

13:24.070 --> 13:25.070
然后配置里面有哪些呢

13:25.070 --> 13:27.070
配置里面东西还是蛮多的

13:27.070 --> 13:29.070
我给大家简单的说几个

13:29.070 --> 13:30.070
我们常用的

13:30.070 --> 13:31.070
可能会用到的

13:31.070 --> 13:33.070
一个是incoding

13:33.070 --> 13:34.070
incoding

13:34.070 --> 13:35.070
这个配置指的是什么呢

13:35.070 --> 13:36.070
编码

13:36.070 --> 13:38.070
如果说你不指定这个东西的话

13:38.070 --> 13:40.070
如果说你指定为low的话

13:40.070 --> 13:41.070
那么到时候读的时候呢

13:41.070 --> 13:43.070
读出来就是一个一个的buffer

13:43.070 --> 13:44.070
buffer把读出来

13:44.070 --> 13:46.070
如果说你指定了编码的话

13:46.070 --> 13:47.070
它读出来就是支付串

13:47.070 --> 13:49.070
它就把编码给你转换了

13:49.070 --> 13:50.070
对吧

13:50.070 --> 13:51.070
这是一个incoding

13:51.070 --> 13:53.070
它默认就是low

13:53.070 --> 13:55.070
how stars end

13:55.070 --> 13:56.070
表示歧视字节

13:56.070 --> 13:57.070
就是说我可以不怕读完

13:57.070 --> 13:59.070
我比方说从第二个字节

13:59.070 --> 14:00.070
开始读

14:00.070 --> 14:01.070
读到第三个字节

14:01.070 --> 14:03.070
后边我都不管了

14:03.070 --> 14:04.070
就这么个意思

14:04.070 --> 14:06.070
对吧

14:06.070 --> 14:08.070
那么比方说从第二个读到第三个

14:08.070 --> 14:09.070
后边我不管了

14:09.070 --> 14:10.070
不管了

14:10.070 --> 14:11.070
这就是我们可以指定

14:11.070 --> 14:12.070
它读的范围

14:12.070 --> 14:14.070
当然我们一般来说

14:14.070 --> 14:15.070
都是要把全部读出来

14:15.070 --> 14:16.070
如果说你要指定的话

14:16.070 --> 14:17.070
就可以通过这两个再指定

14:17.070 --> 14:18.070
两个都是数字

14:18.070 --> 14:19.070
好

14:19.070 --> 14:22.070
最后一个是high water mark

14:22.070 --> 14:24.070
这个东西还蛮重要的

14:24.070 --> 14:25.070
这个东西是指的是

14:25.070 --> 14:27.070
每一次读的数量

14:27.070 --> 14:30.070
比方说它默认值是64 kb

14:30.070 --> 14:31.070
1020

14:31.070 --> 14:32.070
它等于这个

14:32.070 --> 14:36.070
它每一次读64 kb的数量

14:36.070 --> 14:37.070
那么这个表示的是什么

14:37.070 --> 14:40.070
读的字节数

14:40.070 --> 14:41.070
但是它不一定是字节数

14:41.070 --> 14:43.070
比方说把它写成一个1

14:43.070 --> 14:44.070
那么这个时候是什么意思呢

14:44.070 --> 14:47.070
它还要取决于你incoding的值

14:47.070 --> 14:49.070
比方说你incoding有值

14:49.070 --> 14:50.070
有天赋8

14:50.070 --> 14:51.070
有天赋干吧

14:51.070 --> 14:52.070
我们知道它读汉字的时候

14:52.070 --> 14:54.070
把汉字当成三个字节

14:54.070 --> 14:55.070
那么这个时候的1

14:55.070 --> 14:58.070
就表示的是一个字符

14:58.070 --> 15:00.070
一个文字字符

15:00.070 --> 15:02.070
如果说你要incoding为辣的话

15:02.070 --> 15:04.070
那么这个1就表示一个字节

15:04.070 --> 15:06.070
所以说这个地方

15:06.070 --> 15:07.070
是有一点区别的

15:07.070 --> 15:09.070
它还是有区别的

15:09.070 --> 15:11.070
它会受到这个东西的影响

15:11.070 --> 15:14.070
那么这里我们就把这个

15:14.070 --> 15:15.070
这个地方写好

15:15.070 --> 15:16.070
写好之后

15:16.070 --> 15:18.070
文字里它会返回一个什么呢

15:18.070 --> 15:20.070
它会返回一个stream对象

15:20.070 --> 15:22.070
叫什么对象呢

15:22.070 --> 15:25.070
叫做readstream对象

15:25.070 --> 15:27.070
它是一个readable值内

15:27.070 --> 15:28.070
我们刚才解释了

15:28.070 --> 15:29.070
我们所有的流都是

15:29.070 --> 15:32.070
继承至stream那个cool里面的readable

15:32.070 --> 15:33.070
或者是readable

15:33.070 --> 15:34.070
都是继承于这两个

15:34.070 --> 15:37.070
所以它也是继承于readable的值内

15:37.070 --> 15:38.070
因此readable里面有的东西

15:38.070 --> 15:40.070
它全部都有

15:40.070 --> 15:41.070
咱们来展开看一下

15:41.070 --> 15:43.070
它里面有什么东西呢

15:43.070 --> 15:44.070
还有两个方法

15:44.070 --> 15:45.070
我们一会再说

15:45.070 --> 15:46.070
它里面最重要的是

15:46.070 --> 15:48.070
它里面加了很多事件

15:48.070 --> 15:50.070
就是它里面会触发很多事件

15:50.070 --> 15:52.070
这些事件呢

15:52.070 --> 15:53.070
你可以通过

15:53.070 --> 15:54.070
就像我们动物事件的样子

15:54.070 --> 15:55.070
去注册事件

15:55.070 --> 15:56.070
怎么注册呢

15:56.070 --> 15:58.070
就是通过这个readstream

15:58.070 --> 15:59.070
里面一个on

15:59.070 --> 16:01.070
这个函数

16:01.070 --> 16:03.070
那么这里边有两个函数

16:03.070 --> 16:04.070
一个是事件名

16:04.070 --> 16:06.070
一个是处理函数

16:06.070 --> 16:07.070
就是相当于这样的写

16:07.070 --> 16:08.070
就有点一些类似于add

16:08.070 --> 16:09.070
invent.nationer

16:09.070 --> 16:11.070
那么on

16:11.070 --> 16:13.070
事件名

16:13.070 --> 16:16.070
然后后边是处理函数

16:16.070 --> 16:17.070
就这么个意思

16:17.070 --> 16:19.070
那么这个事件名

16:19.070 --> 16:21.070
有哪些事件我们可以处理呢

16:21.070 --> 16:22.070
一个来

16:22.070 --> 16:24.070
有一个open事件

16:24.070 --> 16:25.070
open事件是什么意思呢

16:25.070 --> 16:27.070
表示文件打开事件

16:27.070 --> 16:29.070
如果说文件被打开了

16:29.070 --> 16:30.070
它就会触发这个事件

16:30.070 --> 16:32.070
比方说我们这里加一个open事件

16:32.070 --> 16:33.070
我们这里输出一句

16:33.070 --> 16:35.070
文件被打开了

16:35.070 --> 16:37.070
文件被打开了

16:37.070 --> 16:39.070
咱们来看一下

16:39.070 --> 16:41.070
这句话会不会输出

16:42.070 --> 16:43.070
no index

16:43.070 --> 16:45.070
你看是不是文件被打开了

16:45.070 --> 16:47.070
对吧 非常简单

16:47.070 --> 16:48.070
好 接下来我们再看

16:48.070 --> 16:49.070
还有一个error事件

16:49.070 --> 16:50.070
error事件是什么呢

16:50.070 --> 16:52.070
就是表示的是文件

16:52.070 --> 16:54.070
文件被那个

16:54.070 --> 16:56.070
就是读文件的时候出了问题

16:56.070 --> 16:58.070
一般是文件什么不存在的时候

16:58.070 --> 17:00.070
会出现这个问题

17:00.070 --> 17:03.070
出错了

17:03.070 --> 17:04.070
比方说我们这里

17:04.070 --> 17:07.070
写一个不存在的路径

17:07.070 --> 17:09.070
你行 是不是出发了这个事件

17:09.070 --> 17:10.070
出错了

17:10.070 --> 17:11.070
它没发读了

17:11.070 --> 17:12.070
OK

17:12.070 --> 17:13.070
那么没有错误的话

17:13.070 --> 17:14.070
它就不会出发

17:14.070 --> 17:15.070
它就有一系列事件

17:15.070 --> 17:16.070
当发生这个事件的时候

17:16.070 --> 17:17.070
它就会出发

17:17.070 --> 17:18.070
对吧

17:18.070 --> 17:19.070
因为我们读的过程中

17:19.070 --> 17:20.070
它一点点传输

17:20.070 --> 17:22.070
总有可能会出问题的

17:22.070 --> 17:24.070
好 那么现在是close

17:24.070 --> 17:27.070
close表示文件关闭后出发

17:27.070 --> 17:29.070
close这个事件

17:29.070 --> 17:31.070
复制一下

17:31.070 --> 17:32.070
close

17:32.070 --> 17:33.070
文件关闭

17:33.070 --> 17:34.070
就是你文件用完了

17:34.070 --> 17:35.070
你总得关闭吧

17:35.070 --> 17:36.070
对吧

17:36.070 --> 17:38.070
文件关闭时出发

17:38.070 --> 17:39.070
那么文件什么时候关闭呢

17:39.070 --> 17:41.070
它是有这么一个规则

17:41.070 --> 17:43.070
第一种关闭方式是可以

17:43.070 --> 17:44.070
你读完了过后

17:44.070 --> 17:45.070
你自己手动关闭

17:45.070 --> 17:47.070
RS叫close

17:47.070 --> 17:49.070
叫close

17:49.070 --> 17:50.070
你手动关闭

17:50.070 --> 17:52.070
手动关闭它就会出发这个事件

17:52.070 --> 17:53.070
好 咱们来看一下

17:53.070 --> 17:54.070
文件打开了

17:54.070 --> 17:55.070
文件关闭了

17:55.070 --> 17:56.070
对吧

17:56.070 --> 17:57.070
文件关闭了

17:57.070 --> 17:58.070
那么这个时候

17:58.070 --> 17:59.070
它就会出发这个close的事件

17:59.070 --> 18:01.070
如果说你没有手动关闭的话

18:01.070 --> 18:03.070
它有可能会自动关闭

18:03.070 --> 18:05.070
什么情况下会自动关闭呢

18:05.070 --> 18:07.070
它是要把文件读完了过后

18:07.070 --> 18:08.070
它就会自动关闭

18:08.070 --> 18:10.070
那么现在我们来看一下

18:10.070 --> 18:11.070
它会不会出发关闭呢

18:11.070 --> 18:12.070
它不会出发

18:12.070 --> 18:13.070
为什么呢

18:13.070 --> 18:14.070
因为它根本就没有读文件

18:14.070 --> 18:16.070
为什么没有读文件呢

18:16.070 --> 18:17.070
我们一会就知道了

18:17.070 --> 18:18.070
它现在只是把文件打开

18:18.070 --> 18:19.070
它没有去读它

18:19.070 --> 18:21.070
就有点类似于你把技术边打开了

18:21.070 --> 18:22.070
但是你眼睛闭上

18:22.070 --> 18:23.070
我不看

18:23.070 --> 18:24.070
我不听

18:24.070 --> 18:25.070
讽论三连吗

18:25.070 --> 18:26.070
那么这个时候

18:26.070 --> 18:27.070
它是不会关闭的

18:27.070 --> 18:28.070
因为它读都没读

18:30.070 --> 18:32.070
那么如果说它读完了

18:32.070 --> 18:33.070
如果说它真的读完了

18:33.070 --> 18:34.070
它就会自动关闭

18:34.070 --> 18:36.070
但是它取决于一个配置

18:36.070 --> 18:38.070
就是你必须要把这个东西配置上

18:38.070 --> 18:40.070
当然你不配置也可以

18:40.070 --> 18:41.070
不配置它就默认值

18:41.070 --> 18:42.070
就是它取决于这个配置

18:42.070 --> 18:43.070
all to close

18:43.070 --> 18:45.070
它默认为去

18:45.070 --> 18:46.070
表示什么呢

18:46.070 --> 18:47.070
读啊

18:47.070 --> 18:48.070
这个东西表示的是

18:48.070 --> 18:50.070
读完后会自动关闭

18:50.070 --> 18:52.070
当然你如果说你不读的话

18:52.070 --> 18:53.070
它就不会关闭了

18:53.070 --> 18:54.070
读完后会自动关闭

18:54.070 --> 18:56.070
所以我们一般都会把它打开

18:56.070 --> 18:59.070
因为避免了文件打开过后

18:59.070 --> 19:00.070
就有点类似于什么呢

19:00.070 --> 19:01.070
如果说不关闭的话

19:01.070 --> 19:02.070
就有点类似于开的

19:02.070 --> 19:03.070
到时候

19:03.070 --> 19:05.070
每一次读都会开一个新的

19:05.070 --> 19:06.070
技术本的窗口来读它

19:06.070 --> 19:08.070
有点类似于这个

19:08.070 --> 19:10.070
但是过程中肯定不会开什么技术本

19:10.070 --> 19:12.070
就有点类似于把这个文件占用了

19:12.070 --> 19:13.070
占用了它读

19:13.070 --> 19:14.070
读它的时候

19:14.070 --> 19:16.070
占用过后它又会遇到一个问题

19:16.070 --> 19:18.070
就是删除文件

19:18.070 --> 19:19.070
它删除不了了

19:19.070 --> 19:21.070
这里我说一下顺便说一下

19:21.070 --> 19:23.070
上节课我好像没有说到那个删除文件

19:23.070 --> 19:25.070
删除文件用那个onlink

19:25.070 --> 19:26.070
你们可以自己去查一下

19:26.070 --> 19:28.070
删除文件用FSonlink

19:28.070 --> 19:29.070
非常简单

19:29.070 --> 19:31.070
传一个文件路径就行了

19:31.070 --> 19:32.070
就可以删除掉了

19:33.070 --> 19:35.070
你们可以去查一查

19:35.070 --> 19:36.070
非常简单的

19:36.070 --> 19:38.070
这里说到哪儿了

19:38.070 --> 19:39.070
你看又打擦了

19:39.070 --> 19:40.070
就是关闭

19:40.070 --> 19:42.070
如果说你配置为处的话

19:42.070 --> 19:44.070
读完之后会自动关闭

19:44.070 --> 19:45.070
默认直接为处

19:45.070 --> 19:46.070
默认为处

19:46.070 --> 19:48.070
一般来说我们不会把它设置为force

19:48.070 --> 19:50.070
也不会去改动它

19:50.070 --> 19:52.070
这样子保证每次读完之后

19:52.070 --> 19:53.070
文件要关闭

19:53.070 --> 19:54.070
如果说你不关闭的话

19:54.070 --> 19:55.070
那么到时候删

19:55.070 --> 19:56.070
可能就删不掉

19:56.070 --> 19:58.070
因为有东西正在读它

19:58.070 --> 19:59.070
正在占用它

19:59.070 --> 20:00.070
也可能删不掉

20:00.070 --> 20:01.070
所以说大家要注意

20:01.070 --> 20:03.070
读完之后要把它关闭

20:03.070 --> 20:05.070
如果说你绝对不保险的话

20:05.070 --> 20:06.070
你最后来读完之后

20:06.070 --> 20:07.070
RAS Close

20:07.070 --> 20:08.070
但是不用

20:08.070 --> 20:09.070
你只要读了过后

20:09.070 --> 20:11.070
你只要使用了Rate

20:11.070 --> 20:13.070
那么它肯定要关闭的

20:15.070 --> 20:16.070
那么这个时候

20:16.070 --> 20:18.070
就是三个时间了

20:18.070 --> 20:19.070
让我们看第四个

20:19.070 --> 20:20.070
这就就是

20:20.070 --> 20:23.070
获取流里边的数据的时间

20:23.070 --> 20:24.070
data

20:24.070 --> 20:26.770
就这个时间

20:26.770 --> 20:28.770
当你注册了这个时间过后

20:28.770 --> 20:29.770
它是什么意思呢

20:29.770 --> 20:31.770
因为我们流知道

20:32.770 --> 20:34.770
它是一部分一部分读

20:34.770 --> 20:36.770
一部分一部分读数据

20:36.770 --> 20:37.770
它一点一点的读

20:37.770 --> 20:38.770
一块一块的读

20:38.770 --> 20:39.770
那么每读一块

20:39.770 --> 20:41.770
它就会触发一次这个时间

20:41.770 --> 20:42.770
因为这个时间会反复触发

20:42.770 --> 20:43.770
它不像这几个

20:43.770 --> 20:45.770
前面几个是不是只触发一次就完事了

20:45.770 --> 20:47.770
它这个玩意会反复的

20:47.770 --> 20:48.770
反复的触发

20:48.770 --> 20:49.770
每一次触发的时候

20:49.770 --> 20:50.770
会给你带一个参数

20:50.770 --> 20:51.770
就读一块的时候

20:51.770 --> 20:52.770
它会给你带一个参数

20:52.770 --> 20:53.770
这个参数名字呢

20:53.770 --> 20:54.770
你随便写

20:54.770 --> 20:55.770
我们通常用一个创

20:55.770 --> 20:57.770
表示读了一部分的

20:57.770 --> 20:59.770
读到了一部分

20:59.770 --> 21:02.770
就读到了一部分数据

21:02.770 --> 21:03.770
那数据是什么呢

21:03.770 --> 21:04.770
创

21:04.770 --> 21:06.770
它读了这么一部分数据

21:06.770 --> 21:07.770
那么这个data

21:07.770 --> 21:08.770
就是这个时间

21:08.770 --> 21:09.770
那么这个时间

21:09.770 --> 21:10.770
还有一个

21:10.770 --> 21:11.770
还有一个特别的有意思的点

21:11.770 --> 21:12.770
就是

21:12.770 --> 21:13.770
这个时间

21:13.770 --> 21:15.770
只要你注册了过后

21:15.770 --> 21:16.770
才会真正开始读去

21:16.770 --> 21:17.770
就是如果说你

21:17.770 --> 21:18.770
不注册这个时间

21:18.770 --> 21:19.770
它是不会读的

21:19.770 --> 21:20.770
没什么意思吧

21:20.770 --> 21:21.770
它不会读的

21:21.770 --> 21:23.770
只有你注册了过后

21:23.770 --> 21:25.770
它才会去读

21:25.770 --> 21:26.770
开始来读

21:26.770 --> 21:27.770
就注册的时间

21:27.770 --> 21:28.770
它就开始读了

21:28.770 --> 21:30.770
没读了一部分数据

21:30.770 --> 21:31.770
它就触犯一次这个时间

21:31.770 --> 21:32.770
那么

21:32.770 --> 21:33.770
每次读多少呢

21:33.770 --> 21:34.770
就是不是取决于这个

21:34.770 --> 21:35.770
你写的是E

21:35.770 --> 21:36.770
又是UTF-8

21:36.770 --> 21:37.770
是不是每次读一个文字

21:37.770 --> 21:38.770
对吧

21:38.770 --> 21:39.770
每次读一个文字

21:39.770 --> 21:40.770
就这么个意思

21:40.770 --> 21:41.770
好来吧

21:41.770 --> 21:42.770
我们来看一下

21:42.770 --> 21:43.770
这里呢

21:43.770 --> 21:45.770
我们清空

21:45.770 --> 21:46.770
运行

21:46.770 --> 21:47.770
你看是不是

21:47.770 --> 21:48.770
读出来了

21:48.770 --> 21:49.770
一次读一部分

21:49.770 --> 21:50.770
现在我们目前

21:50.770 --> 21:51.770
读了一次读一个文字

21:51.770 --> 21:52.770
abcdef

21:52.770 --> 21:53.770
对不对

21:53.770 --> 21:54.770
那里边如果说有中文呢

21:54.770 --> 21:56.770
不要说前面加个读意

21:56.770 --> 21:57.770
有中文呢

21:58.770 --> 21:59.770
是不是一次读一个文字

21:59.770 --> 22:00.770
读一

22:00.770 --> 22:01.770
对吧

22:01.770 --> 22:02.770
因为我们这个时候

22:02.770 --> 22:03.770
是因为我们设置了编码

22:03.770 --> 22:04.770
UTF-8

22:04.770 --> 22:05.770
如果说我们没有设置编码

22:05.770 --> 22:07.770
它每次读一个字节

22:07.770 --> 22:08.770
你看一下

22:08.770 --> 22:09.770
现在每次读的是一个什么

22:09.770 --> 22:11.770
它就不是知不错了

22:11.770 --> 22:13.770
所以读的是一个buffer

22:13.770 --> 22:14.770
是不是明显多了一些

22:14.770 --> 22:15.770
你看一下

22:15.770 --> 22:17.770
刚才12345678

22:17.770 --> 22:18.770
现在读到多少

22:18.770 --> 22:23.770
12345678941112

22:23.770 --> 22:24.770
12个

22:24.770 --> 22:25.770
为什么

22:25.770 --> 22:27.770
因为一个汉字占三个字节

22:27.770 --> 22:29.770
它要分三次才能读出来

22:29.770 --> 22:31.770
但是一般情况下

22:31.770 --> 22:32.770
你们不太可能

22:32.770 --> 22:33.770
每次读一个字节

22:33.770 --> 22:35.770
这样子也太解约用水了

22:35.770 --> 22:36.770
你们把这个

22:36.770 --> 22:38.770
刘就可以想象成一个水管

22:38.770 --> 22:39.770
你把个水管开的太小了

22:39.770 --> 22:41.770
每次刘一点点出来

22:41.770 --> 22:43.770
这个时候也太夸张了

22:43.770 --> 22:44.770
一下子刷

22:45.770 --> 22:46.770
比方说用一个就是

22:46.770 --> 22:48.770
下水管道这样的刘出来

22:48.770 --> 22:49.770
太夸张了

22:49.770 --> 22:50.770
但是也不能太小

22:50.770 --> 22:51.770
我们通常就是

22:51.770 --> 22:53.770
它的默认者就是64kb

22:53.770 --> 22:55.770
64x1024

22:55.770 --> 22:56.770
这样子也差不多

22:56.770 --> 22:59.770
当然也可以根据需要自己去调整

22:59.770 --> 23:00.770
这就是

23:00.770 --> 23:01.770
它不断的去读

23:01.770 --> 23:02.770
不断的去读

23:02.770 --> 23:03.770
一点点刘出来

23:03.770 --> 23:05.770
每次读的就是一个创作

23:05.770 --> 23:06.770
那么这样子

23:06.770 --> 23:07.770
其实内存用的

23:07.770 --> 23:08.770
用的空间就很少

23:08.770 --> 23:09.770
你看

23:09.770 --> 23:10.770
如果说整个文件

23:10.770 --> 23:11.770
整个文件有多少kb

23:11.770 --> 23:12.770
12kb

23:12.770 --> 23:13.770
对吧

23:13.770 --> 23:14.770
12个字节

23:14.770 --> 23:15.770
12个字节的话

23:15.770 --> 23:16.770
你看我们

23:16.770 --> 23:17.770
如果说全部一起读出来的话

23:17.770 --> 23:19.770
那么我们内存就占12个字节

23:19.770 --> 23:20.770
肯定要占的

23:20.770 --> 23:21.770
因为全部要读出来

23:21.770 --> 23:22.770
要放到内存里面

23:22.770 --> 23:23.770
再量不是内存

23:23.770 --> 23:25.770
但是你这个东西来读的话

23:25.770 --> 23:26.770
每一次是不是读一部分

23:26.770 --> 23:28.770
每一次只读一个字节

23:28.770 --> 23:29.770
所以一个字节

23:29.770 --> 23:30.770
用完了

23:30.770 --> 23:31.770
我就把输出了

23:31.770 --> 23:32.770
用完了就算了

23:32.770 --> 23:33.770
用完了就算了

23:33.770 --> 23:34.770
下一次就读新的

23:34.770 --> 23:35.770
我又没把保存下来

23:35.770 --> 23:36.770
当然你可不可以保存

23:36.770 --> 23:37.770
当然可以保存

23:37.770 --> 23:38.770
你也可以把它保存下来

23:38.770 --> 23:39.770
对吧

23:39.770 --> 23:40.770
保存到一个输出里面

23:40.770 --> 23:41.770
或者是拼接到一个支付串里面

23:41.770 --> 23:42.770
随便你

23:42.770 --> 23:43.770
你也可以把它保存

23:43.770 --> 23:44.770
但是保存过后

23:44.770 --> 23:45.770
就全部到内存了

23:45.770 --> 23:48.770
就看你自己怎么去处理

23:48.770 --> 23:50.770
这就是关于这个data

23:50.770 --> 23:54.770
这个就是时间

23:54.770 --> 23:55.770
然后还有这个时间

23:55.770 --> 23:56.770
end

23:56.770 --> 23:57.770
end是什么时间呢

23:57.770 --> 24:00.770
就读完之后

24:00.770 --> 24:01.770
来看一下

24:01.770 --> 24:02.770
刚才我们有了data过后

24:02.770 --> 24:03.770
你看是不是文件关闭了

24:03.770 --> 24:04.770
因为它会自动关闭

24:04.770 --> 24:05.770
对吧

24:05.770 --> 24:06.770
只要它读了

24:06.770 --> 24:07.770
读完了之后会自动关闭

24:07.770 --> 24:08.770
end是什么时间呢

24:08.770 --> 24:11.340
就读完了

24:11.340 --> 24:15.340
全部数据读取完毕

24:15.340 --> 24:16.340
那么这个时候

24:16.340 --> 24:18.340
它就会关闭了

24:18.340 --> 24:19.340
你看

24:19.340 --> 24:20.340
全部数据读取完毕

24:20.340 --> 24:21.340
先触发end

24:21.340 --> 24:22.340
再触发close

24:22.340 --> 24:23.340
OK

24:23.340 --> 24:24.340
那么这就是关于它的读

24:24.340 --> 24:26.340
我们还是把一个Utl

24:26.340 --> 24:28.340
加上

24:28.340 --> 24:29.340
那么这个时候

24:29.340 --> 24:30.340
是不是实现了

24:30.340 --> 24:33.340
一部分一部分读数据

24:33.340 --> 24:34.340
那么如果说

24:34.340 --> 24:35.340
我要读到

24:35.340 --> 24:36.340
得到它完整的数据

24:36.340 --> 24:39.340
我要得到它完整的数据怎么办呢

24:39.340 --> 24:40.340
首先你要搞清楚这个概念

24:40.340 --> 24:41.340
如果说

24:41.340 --> 24:42.340
你真的需要得到

24:42.340 --> 24:43.340
它完整的数据

24:43.340 --> 24:44.340
你还不如用read file

24:44.340 --> 24:45.340
因为read file

24:45.340 --> 24:46.340
就是得到完整的数据

24:46.340 --> 24:47.340
全部到内存

24:47.340 --> 24:48.340
对吧

24:48.340 --> 24:49.340
全部到内存里面

24:49.340 --> 24:50.340
你用这个流干嘛呢

24:50.340 --> 24:52.340
流就是读一部分

24:52.340 --> 24:53.340
用一部分就是扔了

24:53.340 --> 24:54.340
再读一部分

24:54.340 --> 24:55.340
用一部分就扔了

24:55.340 --> 24:57.340
这样子能保持内存

24:57.340 --> 24:59.340
比较占用的比较少

24:59.340 --> 25:01.340
如果说你要全部弄出来的话

25:01.340 --> 25:02.340
你还不如用read file

25:02.340 --> 25:03.340
但是我这里还是给大家说一下

25:03.340 --> 25:05.340
如果说真的要用留着的方式

25:05.340 --> 25:06.340
得到全部的数据的话

25:06.340 --> 25:07.340
这个还不简单

25:07.340 --> 25:09.340
你定一个权娟变量

25:09.340 --> 25:11.340
定一个权娟变量

25:11.340 --> 25:13.340
每读一部分

25:13.340 --> 25:15.340
是不是应该拼接上

25:15.340 --> 25:17.340
每读一部分拼接上

25:17.340 --> 25:18.340
最后读完了

25:18.340 --> 25:20.340
读完了过后就把它打印出来

25:20.340 --> 25:21.340
对吧

25:21.340 --> 25:22.340
你看一下

25:22.340 --> 25:25.340
我们看一下吧

25:25.340 --> 25:26.340
你看

25:26.340 --> 25:27.340
全部读完了是不是全部读出来了

25:27.340 --> 25:28.340
拼接上了

25:28.340 --> 25:29.340
但是这样子

25:29.340 --> 25:30.340
我再说一次

25:30.340 --> 25:32.340
这样子就没必要用留了

25:32.340 --> 25:34.340
这样子用留有什么意义呢

25:34.340 --> 25:35.340
这样子一来的话

25:35.340 --> 25:36.340
就怕所有的数据

25:36.340 --> 25:38.340
全部都是保存到内存的

25:38.340 --> 25:39.340
变量嘛

25:39.340 --> 25:40.340
变量就是内存

25:40.340 --> 25:41.340
对不对

25:41.340 --> 25:42.340
那么这里我给大家说一下

25:42.340 --> 25:44.340
我们通常的真耳八经

25:44.340 --> 25:45.340
用留的时候

25:45.340 --> 25:47.340
就是拿一部分用完就真

25:47.340 --> 25:49.340
它这个我们知道有垃圾回收嘛

25:49.340 --> 25:50.340
对吧

25:50.340 --> 25:52.340
这东西如果说你不怕保存下来的话

25:52.340 --> 25:53.340
那么它就永远找不到了

25:53.340 --> 25:54.340
找不到的话

25:54.340 --> 25:55.340
这个窗口就找不到了

25:55.340 --> 25:56.340
它只是个熊餐嘛

25:56.340 --> 25:57.340
就会把它回收掉

25:57.340 --> 25:58.340
OK

25:58.340 --> 25:59.340
这是关于这一个

25:59.340 --> 26:01.340
这一块的一些常见的事件

26:01.340 --> 26:03.340
那么这些事件里面呢

26:03.340 --> 26:04.340
其实还有两个

26:04.340 --> 26:05.340
我要说

26:05.340 --> 26:06.340
一个是

26:06.340 --> 26:08.340
它里面还提供了两个方法

26:08.340 --> 26:09.340
我们可能会用到的

26:09.340 --> 26:10.340
一个是

26:11.340 --> 26:12.340
RS

26:12.340 --> 26:13.340
第二

26:13.340 --> 26:15.340
POSE

26:16.340 --> 26:17.340
这个是什么呢

26:17.340 --> 26:18.340
暂停

26:18.340 --> 26:20.340
暂停读取

26:20.340 --> 26:21.340
暂停读取

26:21.340 --> 26:22.340
还有一个是RS

26:22.340 --> 26:24.340
Resume

26:24.340 --> 26:25.340
这个表示什么意思呢

26:25.340 --> 26:27.340
恢复读取

26:28.340 --> 26:29.340
恢复读取

26:30.340 --> 26:31.340
读取

26:31.340 --> 26:32.340
那么这个地方

26:32.340 --> 26:34.340
当你调用这个方法的时候

26:34.340 --> 26:36.340
当你调用它的时候

26:36.340 --> 26:38.340
会导致

26:38.340 --> 26:41.340
会触发POSE时间

26:41.340 --> 26:43.340
会触发POSE时间

26:43.340 --> 26:44.340
恢复读取的时候

26:44.340 --> 26:46.340
会触发

26:47.340 --> 26:50.340
会触发Resume

26:50.340 --> 26:51.340
时间

26:51.340 --> 26:53.340
又触发Resume时间

26:53.340 --> 26:54.340
这就是这里

26:54.340 --> 26:55.340
两个时间

26:55.340 --> 26:56.340
好,咱们来看一下吧

26:56.340 --> 26:57.340
比方说

26:57.340 --> 26:59.340
每读到一部分数据的时候

26:59.340 --> 27:00.340
我们怎么办呢

27:00.340 --> 27:02.340
我们就暂停一下

27:02.340 --> 27:04.340
POSE

27:04.340 --> 27:05.340
暂停

27:07.780 --> 27:08.780
好,那么这个时候

27:08.780 --> 27:10.780
还会触发POSE时间

27:12.780 --> 27:13.780
那么这个时候

27:13.780 --> 27:14.780
我们输出

27:16.780 --> 27:17.780
暂停了

27:17.780 --> 27:18.780
暂停了

27:18.780 --> 27:19.780
保存,我们来看一下

27:20.780 --> 27:21.780
运行

27:21.780 --> 27:23.780
是不是只读了一次过后就暂停了

27:23.780 --> 27:24.780
对吧

27:24.780 --> 27:25.780
说明这个时间

27:25.780 --> 27:26.780
这个时间被触发了

27:26.780 --> 27:27.780
是不是这个时间被触发了

27:27.780 --> 27:28.780
POSE

27:28.780 --> 27:29.780
对不对

27:29.780 --> 27:30.780
那么POSE触发了过后

27:30.780 --> 27:31.780
暂停了过后

27:31.780 --> 27:32.780
我又干嘛呢

27:32.780 --> 27:33.780
我等一秒钟

27:34.780 --> 27:35.780
我等一秒钟过后

27:35.780 --> 27:36.780
我再恢复

27:36.780 --> 27:37.780
就是我一点一点

27:37.780 --> 27:38.780
对吧

27:38.780 --> 27:39.780
我有一点累

27:39.780 --> 27:40.780
我休息一秒钟

27:40.780 --> 27:41.780
休息一秒钟

27:41.780 --> 27:42.780
然后再恢复

27:42.780 --> 27:44.780
RS

27:45.780 --> 27:46.780
对吧

27:46.780 --> 27:47.780
再恢复

27:47.780 --> 27:50.090
看一下

27:50.090 --> 27:52.090
都一一看暂停了

27:52.090 --> 27:53.090
恢复

27:53.090 --> 27:54.090
你看没有

27:54.090 --> 27:55.090
能看懂吗

27:55.090 --> 27:56.090
能不能看懂这个

27:56.090 --> 27:58.460
能不能看懂

27:58.460 --> 28:00.460
我一恢复的话

28:00.460 --> 28:01.460
你看

28:01.460 --> 28:02.460
我一恢复的话

28:02.460 --> 28:03.460
是不是就

28:03.460 --> 28:04.460
又继续读

28:04.460 --> 28:05.460
读了过后

28:05.460 --> 28:06.460
它是不是又暂停

28:06.460 --> 28:07.460
暂停过后

28:07.460 --> 28:08.460
又触发POSE

28:08.460 --> 28:09.460
POSE暂停了过后

28:09.460 --> 28:10.460
又恢复

28:10.460 --> 28:11.460
对吧

28:11.460 --> 28:12.460
那么它同时

28:12.460 --> 28:13.460
会触发回复时间

28:13.460 --> 28:14.460
RESU

28:14.460 --> 28:15.460
回复的时候

28:15.460 --> 28:16.460
你要干吗

28:16.460 --> 28:17.460
回复的时候

28:17.460 --> 28:18.460
是没什么可干的

28:18.460 --> 28:19.460
恢复了

28:20.460 --> 28:21.460
恢复了

28:21.460 --> 28:23.460
恢复了

28:24.460 --> 28:25.460
保存

28:25.460 --> 28:26.460
看一下

28:26.460 --> 28:27.460
暂停

28:27.460 --> 28:28.460
恢复了

28:28.460 --> 28:29.460
对吧

28:29.460 --> 28:30.460
暂停

28:30.460 --> 28:31.460
恢复了

28:31.460 --> 28:32.460
恢复了

28:34.460 --> 28:35.460
OK

28:35.460 --> 28:36.460
那么这样子

28:36.460 --> 28:37.460
就把它读完了

28:37.460 --> 28:38.460
OK

28:38.460 --> 28:39.460
这就是它整个的

28:39.460 --> 28:40.460
事件体系

28:40.460 --> 28:41.460
当然如果说

28:41.460 --> 28:42.460
你用那个buffer

28:42.460 --> 28:43.460
也是一样

28:43.460 --> 28:44.460
那么这里就没有什么

28:44.460 --> 28:45.460
好多说的了

28:45.460 --> 28:46.460
这是关于整个

28:46.460 --> 28:47.460
流的使用

28:47.460 --> 28:48.460
其实流的话

28:48.460 --> 28:49.460
你还要生挖的话

28:49.460 --> 28:50.460
还是有不少东西

28:50.460 --> 28:52.460
但是我们这个课

28:52.460 --> 28:53.460
给大家说了

28:53.460 --> 28:54.460
作为前端

28:54.460 --> 28:56.460
我们要有节制

28:56.460 --> 28:57.460
要注意身体健康

28:57.460 --> 28:59.460
不要当着后端来学了

28:59.460 --> 29:01.460
流的东西还不少

29:01.460 --> 29:02.460
后端是要把

29:02.460 --> 29:03.460
流要研究很深的

29:03.460 --> 29:04.460
OK

29:04.460 --> 29:05.460
那么这里

29:05.460 --> 29:06.460
我们就把文件

29:06.460 --> 29:08.460
流的读取部分

29:08.460 --> 29:09.460
搞定了

29:09.460 --> 29:10.460
只是搞定了

29:10.460 --> 29:11.460
读取文件

29:11.460 --> 29:12.460
创建一个文件

29:12.460 --> 29:13.460
读取流

29:13.460 --> 29:15.460
从使用角度来说的话

29:15.460 --> 29:16.460
现在除了可以

29:16.460 --> 29:17.460
节约一点内存之外

29:17.460 --> 29:18.460
比方输出到屏幕

29:18.460 --> 29:20.460
除了节约点内存之外

29:20.460 --> 29:21.460
还没有这么特别

29:21.460 --> 29:22.460
大的明显的意义

29:22.460 --> 29:23.460
我们后边

29:23.460 --> 29:25.460
学了可写流过后

29:25.460 --> 29:26.460
来综合来一下

29:26.460 --> 29:27.460
我们就明白了

29:27.460 --> 29:28.460
它的意义在哪

29:28.460 --> 29:29.460
好

29:29.460 --> 29:30.460
咱们下一课来讲

29:30.460 --> 29:31.460
可写流

