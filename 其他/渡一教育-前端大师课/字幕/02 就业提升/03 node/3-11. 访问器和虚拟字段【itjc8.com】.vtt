WEBVTT

00:00.050 --> 00:02.690
这些课呢讲一个小知识啊

00:02.690 --> 00:04.370
就是那个secretize

00:04.370 --> 00:06.850
secretize呢我都认为讲的差不多了

00:06.850 --> 00:08.050
我们想一想

00:08.050 --> 00:09.490
好像还有点遗漏啊

00:09.490 --> 00:10.450
我来讲一讲

00:10.450 --> 00:12.770
一个是访问器核序理之段

00:12.770 --> 00:13.890
这种东西什么呢

00:13.890 --> 00:14.930
非常简单啊

00:14.930 --> 00:16.210
几分钟就说完了

00:16.210 --> 00:17.650
比方说吧

00:17.650 --> 00:19.250
我们这里呢

00:19.250 --> 00:21.250
打印一下这个学

00:21.250 --> 00:22.770
把这个学生找出来

00:22.770 --> 00:25.970
找个get就念

00:25.970 --> 00:27.170
找一些学生

00:27.170 --> 00:29.570
分页那些让他用摸认值吧

00:30.130 --> 00:32.130
把这个results

00:32.130 --> 00:34.130
打印出来

00:34.130 --> 00:36.130
看一下吧

00:36.130 --> 00:38.130
好 接下来我们到这个中端里边去

00:38.130 --> 00:40.130
位置

00:40.130 --> 00:42.130
就在中端中打开

00:42.130 --> 00:44.930
好 然后呢我们使用那个load

00:44.930 --> 00:46.930
用这个运行一下

00:46.930 --> 00:48.930
啊

00:48.930 --> 00:50.930
啊 怎么呢

00:50.930 --> 00:52.930
on the one column

00:52.930 --> 00:54.930
位置的列students

00:54.930 --> 00:56.930
Burst Daddy

00:57.410 --> 01:01.410
说明我们那个services还没改干净的

01:01.410 --> 01:03.410
找一找

01:03.410 --> 01:05.410
Burst Daddy

01:05.410 --> 01:07.410
在这

01:07.410 --> 01:09.410
把这个改一下

01:09.410 --> 01:11.410
Burst Day

01:11.410 --> 01:13.410
然后呢 这边来

01:13.410 --> 01:15.410
再来一次

01:15.410 --> 01:17.410
打印出来了过后呢

01:17.410 --> 01:19.410
我们看到这个Burst Day

01:19.410 --> 01:21.410
它这个格式啊

01:21.410 --> 01:23.410
它变成一个字无创

01:23.410 --> 01:25.410
它是一个日期对象

01:25.410 --> 01:27.410
发过后呢变成这个样子了

01:27.410 --> 01:29.410
这个样子呢

01:29.410 --> 01:31.410
它倒是一个标准的表示方式

01:31.410 --> 01:33.410
可能呢

01:33.410 --> 01:35.410
我们需要的格式呢

01:35.410 --> 01:37.410
我们想变一变

01:37.410 --> 01:39.410
不想用这种格式

01:39.410 --> 01:41.410
这种格式呢可能操作起来呢

01:41.410 --> 01:43.410
也有一些麻烦

01:43.410 --> 01:45.410
其实这个东西

01:45.410 --> 01:47.410
给日期的话用什么样的格式最好了

01:47.410 --> 01:49.410
最好的格式

01:49.410 --> 01:51.410
我们可以使用那个

01:51.410 --> 01:53.410
可以使用那个就是

01:53.410 --> 01:55.410
模型里边去

01:55.410 --> 01:57.410
找到这个student

01:57.410 --> 01:59.410
找到这个services

01:59.410 --> 02:01.410
这个东西呢

02:01.410 --> 02:03.410
它给我的是一个日期

02:03.410 --> 02:05.410
是一个日期对象

02:05.410 --> 02:07.410
我希望把它表示成为一个时间戳

02:07.410 --> 02:09.410
但是我又不想去

02:09.410 --> 02:11.410
改动数据户

02:11.410 --> 02:13.410
那么这个时候怎么办呢

02:13.410 --> 02:15.410
我们就可以利用访问器

02:15.410 --> 02:17.410
什么访问器呢 就这个

02:17.410 --> 02:19.410
里边写一个giz

02:19.410 --> 02:21.410
里面都学过那个obj

02:21.410 --> 02:23.410
giz访问器

02:23.410 --> 02:25.410
也就是说我不影响数据库里表保存内容

02:25.410 --> 02:27.410
但是呢

02:27.410 --> 02:29.410
我希望我在获取这个属性的时候

02:29.410 --> 02:31.410
你给我的是一个时间戳

02:31.410 --> 02:33.410
我把它转换一下

02:33.410 --> 02:35.410
自动转换一下

02:35.410 --> 02:37.410
那么这个东西怎么写呢

02:37.410 --> 02:39.410
直接返回就完了

02:39.410 --> 02:41.410
返回怎么呢 返回一个时间戳

02:41.410 --> 02:43.410
就是你把它原来的

02:43.410 --> 02:45.410
date对象

02:45.410 --> 02:47.410
把它变成一个时间戳

02:47.410 --> 02:49.410
这个东西怎么来做呢

02:49.410 --> 02:51.410
对象嘛 对不对

02:51.410 --> 02:53.410
那么我们就可以使用

02:53.410 --> 02:55.410
首先要得到原来的对象

02:55.410 --> 02:57.410
它是一个对象

02:57.410 --> 02:59.410
那怎么来得到了

02:59.410 --> 03:01.410
你不能用这种方式来得到

03:01.410 --> 03:03.410
你不能用这种方式

03:03.410 --> 03:05.410
因为这种方式就循环引用了

03:05.410 --> 03:07.410
你这里调用giz

03:07.410 --> 03:09.410
它又要调用giz就循环了

03:09.410 --> 03:11.410
所以它给你提供了另外一种方式

03:11.410 --> 03:13.410
叫做giz data value

03:13.410 --> 03:15.410
给你提供这么一个函数

03:15.410 --> 03:17.410
这个giz

03:17.410 --> 03:19.410
模型定义的对象

03:19.410 --> 03:21.410
那么这个giz data value

03:21.410 --> 03:23.410
我们这里边写上一个字不算

03:23.410 --> 03:25.410
哪个字段的值

03:25.410 --> 03:27.410
把这个字段的值拿出来

03:27.410 --> 03:29.410
是不是一个data对象

03:29.410 --> 03:31.410
那么这个data对象

03:31.410 --> 03:33.410
我们把它转换成时间戳

03:33.410 --> 03:35.410
怎么转换

03:35.410 --> 03:37.410
那么我们把这个写上

03:37.410 --> 03:39.410
好 这个写上过后

03:39.410 --> 03:41.410
我们再来运行

03:41.410 --> 03:43.410
运行

03:43.410 --> 03:45.410
你看Bird state是不是时间戳了

03:45.410 --> 03:47.410
就这么简单

03:47.410 --> 03:49.410
这里就是一个访问器

03:49.410 --> 03:51.410
访问器不仅是有可以是giz

03:51.410 --> 03:53.410
也可以是set

03:53.410 --> 03:55.410
set的时候就是你给它复制的时候

03:55.410 --> 03:57.410
你给这个Bird state复制的时候

03:57.410 --> 03:59.410
那么它会把它转换成为那个

03:59.410 --> 04:01.410
就是

04:01.410 --> 04:03.410
转换成为那个

04:03.410 --> 04:05.410
根据你的

04:05.410 --> 04:07.410
它会经过这个giz set寒数

04:07.410 --> 04:09.410
然后进行转换

04:09.410 --> 04:11.410
但是前提条件

04:11.410 --> 04:13.410
你不能是一个普通的平面对象

04:13.410 --> 04:15.410
你像这样子我们去添加

04:15.410 --> 04:17.410
是一个普通的对象

04:17.410 --> 04:19.410
给这个Bird state复制它不会甩立的

04:19.410 --> 04:21.410
它是这个模型实力

04:21.410 --> 04:23.410
知道什么叫模型实力吧

04:23.410 --> 04:25.410
我刚才讲过

04:25.410 --> 04:27.410
就是你通过secret nice crazy

04:27.410 --> 04:29.410
或者是secret nice giz的时候

04:29.410 --> 04:31.410
得到的对象

04:31.410 --> 04:33.410
你再给它重新复制的时候

04:33.410 --> 04:35.410
它会经过这个set

04:35.410 --> 04:37.410
但是我们这里就严实不了了

04:37.410 --> 04:39.410
这里没有模型实力

04:39.410 --> 04:41.410
这都是得到的平面对象

04:41.410 --> 04:43.410
这是一个访问器

04:43.410 --> 04:45.410
访问器分为get set

04:45.410 --> 04:47.410
我们用了最多的get

04:47.410 --> 04:49.410
就是给它重新改一下数据

04:49.410 --> 04:51.410
然后得到它的效果结果

04:51.410 --> 04:53.410
另外一个就是虚拟属性

04:53.410 --> 04:55.410
什么叫虚拟之断

04:55.410 --> 04:57.410
虚拟之断什么意思呢

04:57.410 --> 04:59.410
就是我们有一些东西

04:59.410 --> 05:01.410
不想存在数据库里边

05:01.410 --> 05:03.410
我们是根据数据库里边的东西算出来的

05:03.410 --> 05:05.410
就有点像5u里边的computed

05:05.410 --> 05:07.410
就是计算属性

05:07.410 --> 05:09.410
那么这个东西是怎么做呢

05:09.410 --> 05:11.410
你看一下

05:11.410 --> 05:13.410
这个东西我有点忘了

05:13.410 --> 05:15.410
看一下secret nice

05:15.410 --> 05:17.410
这东西

05:17.410 --> 05:19.410
预示部就查这个app文档

05:19.410 --> 05:21.410
找一找找到这个

05:21.410 --> 05:23.410
虚拟之断

05:23.410 --> 05:26.980
虚拟之断

05:26.980 --> 05:28.980
虚拟之断它说

05:28.980 --> 05:30.980
它是在那个获取

05:30.980 --> 05:32.980
从数据库中获取模型的时候

05:32.980 --> 05:34.980
来自动填充了一个字段

05:34.980 --> 05:36.980
那么这个字段它并不存在于数据库中

05:36.980 --> 05:38.980
比方说一个用户的first name

05:38.980 --> 05:40.980
和last name的属性

05:40.980 --> 05:42.980
那么这个

05:42.980 --> 05:44.980
可以写一个虚拟之断

05:44.980 --> 05:46.980
这两个东西是存在数据库里边的

05:46.980 --> 05:48.980
而这个东西是

05:48.980 --> 05:50.980
只是一个虚拟之断

05:50.980 --> 05:52.980
只是用来获取的

05:52.980 --> 05:54.980
它怎么来写呢就是一个type

05:54.980 --> 05:56.980
类型是detapes,virtual

05:56.980 --> 05:58.980
virtual什么意思就是虚拟的

05:58.980 --> 06:00.980
所以说你要写一个虚拟属性的话

06:00.980 --> 06:02.980
非常简单

06:02.980 --> 06:04.980
比方说我们这里写个什么虚拟属性呢

06:04.980 --> 06:06.980
我们写个ag

06:06.980 --> 06:08.980
通过Burst也算出来

06:08.980 --> 06:10.980
我们这里写上type

06:10.980 --> 06:12.980
detapes,virtual

06:12.980 --> 06:14.980
写上这么一个虚拟属性

06:14.980 --> 06:16.980
然后我们可以配合仿问器来使用

06:16.980 --> 06:18.980
不要介绍

06:18.980 --> 06:20.980
当我们得到联令的时候

06:20.980 --> 06:22.980
我们要经过通过Burst来计算联令

06:22.980 --> 06:24.980
那怎么来计算呢

06:24.980 --> 06:26.980
我们是不是可以用moment

06:26.980 --> 06:28.980
moment require

06:28.980 --> 06:30.980
moment

06:30.980 --> 06:32.980
来吧

06:32.980 --> 06:34.980
你可以去看一下moment的文档

06:34.980 --> 06:36.980
他告诉你联令呢

06:36.980 --> 06:38.980
你可以这样来算

06:38.980 --> 06:40.980
他倒是没有说直接算联令

06:40.980 --> 06:42.980
就是你可以通过两个日期的

06:42.980 --> 06:44.980
年份的差异来算联令

06:44.980 --> 06:46.980
那么我们来算一下

06:46.980 --> 06:48.980
就可以通过moment

06:48.980 --> 06:50.980
得到当前UTC的时间

06:50.980 --> 06:52.980
得到当前UTC的时间

06:52.980 --> 06:54.980
然后呢

06:54.980 --> 06:56.980
这是第一个

06:56.980 --> 06:58.980
这是当前时间

06:58.980 --> 07:02.740
另外一个是它的Burst

07:02.740 --> 07:04.740
Burst我们也把它算成moment

07:04.740 --> 07:06.740
就是Burst

07:06.740 --> 07:08.740
通过moment

07:08.740 --> 07:10.740
UTC

07:10.740 --> 07:12.740
Z是Burst

07:12.740 --> 07:14.740
那么这样子的是不是取出这个Burst

07:14.740 --> 07:16.740
对吧 是不是取出这个

07:16.740 --> 07:18.740
通过这个get的仿问器

07:18.740 --> 07:20.740
取出这个Burst

07:20.740 --> 07:22.740
好 那么两个算出来过后

07:22.740 --> 07:24.740
那么得到两个时间之间的差异

07:24.740 --> 07:26.740
怎么来得到差异呢

07:26.740 --> 07:28.740
我们就可以通过当前时间

07:28.740 --> 07:30.740
去减去

07:30.740 --> 07:32.740
去减去Burst

07:32.740 --> 07:34.740
得到连这一部分

07:34.740 --> 07:36.740
得到连这一部分差异

07:36.740 --> 07:38.740
得到两个日期的

07:38.740 --> 07:40.740
年份的差异

07:40.740 --> 07:42.740
得到这么一个部分的差异

07:42.740 --> 07:44.740
那么这个差异呢

07:44.740 --> 07:46.740
它可能是一个小数点

07:46.740 --> 07:48.740
相隔了1.5年

07:48.740 --> 07:50.740
它可能是一个有带小数的

07:50.740 --> 07:52.740
那么它会直接去掉小数

07:52.740 --> 07:54.740
它会直接去掉小数

07:54.740 --> 07:56.740
OK 那么这里呢

07:56.740 --> 07:58.740
我们就可以得到

07:58.740 --> 08:00.740
直接返回了

08:00.740 --> 08:02.740
这就是个年龄

08:02.740 --> 08:04.740
好 写好了之后呢

08:04.740 --> 08:09.140
我们在这边看一下

08:09.140 --> 08:11.140
A级是没有出来是吧

08:11.140 --> 08:13.140
A级没有出来

08:13.140 --> 08:15.140
没有出来的原因呢

08:15.140 --> 08:17.140
应该是那个

08:17.140 --> 08:19.140
这个地方呢 没有

08:19.140 --> 08:21.140
没有序列化

08:21.140 --> 08:23.140
它在Jason Stundefy的时候呢

08:23.140 --> 08:25.140
没有序列化 我们来看一下吧

08:25.140 --> 08:27.140
这边我们得到了

08:27.140 --> 08:29.140
得到了很多的学生

08:29.140 --> 08:31.140
我们比方说打印第1个学生

08:31.140 --> 08:33.140
Rose

08:33.140 --> 08:35.140
第1个学生

08:35.140 --> 08:37.140
第2A级 实际上是有的

08:37.140 --> 08:42.820
打印一下吧

08:42.820 --> 08:44.820
找到 看上面

08:44.820 --> 08:46.820
你看 是不是21 实际上是有的

08:46.820 --> 08:48.820
但是在节省序列化的时候呢

08:48.820 --> 08:50.820
它没有出现

08:50.820 --> 08:52.820
那么这个问题呢 怎么来去解决呢

08:52.820 --> 08:54.820
我们首先看一下这个吧

08:54.820 --> 08:56.820
首先看一下这个

08:56.820 --> 08:58.820
这个地方 我们把它推节省

08:58.820 --> 09:03.150
这个地方 我们用推节省的方式

09:03.150 --> 09:05.150
给它进行序列化

09:05.150 --> 09:07.150
看一下 这上面

09:07.150 --> 09:09.150
没有序列化出来是吧

09:09.150 --> 09:11.150
所以说这个字段呢 好像是不支持序列化的

09:11.150 --> 09:13.150
我们先把它解决一下

09:13.150 --> 09:15.150
应该是

09:15.150 --> 09:17.150
在这里加上一个six

09:17.150 --> 09:19.150
应该就可以了

09:19.150 --> 09:21.150
加上一个A级

09:21.150 --> 09:23.150
试一下吧

09:23.150 --> 09:27.490
再试一下啊

09:27.490 --> 09:29.490
你看 是不是就可以了

09:29.490 --> 09:31.490
A级加上了

09:31.490 --> 09:33.490
那么这样子呢 通过这个字段呢

09:33.490 --> 09:35.490
就可以得到它的年龄了

09:35.490 --> 09:37.490
有的时候呢

09:37.490 --> 09:39.490
我们得到一些通过计算出来的东西的时候

09:39.490 --> 09:41.490
那就非常有用

09:41.490 --> 09:43.490
这些课咱们补充一个小的支持

