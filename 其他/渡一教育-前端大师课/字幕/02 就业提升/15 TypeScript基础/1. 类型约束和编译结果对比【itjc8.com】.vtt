WEBVTT

00:00.000 --> 00:04.600
Hello 大家好 我是独一教育 微博前段讲师 袁晋

00:04.860 --> 00:07.420
这一课 咱们继续来学习TS

00:07.940 --> 00:11.520
这一课 作为我们TS真正开始写代码的第一节课

00:11.780 --> 00:13.060
我们来了解一下

00:13.320 --> 00:18.940
关于TS里边如何来去进行基本的类型约束

00:19.200 --> 00:21.500
就是做一些最基本的操作 如何来去做

00:22.280 --> 00:26.120
这些份内容比较多 时间会比较长

00:26.380 --> 00:27.400
不过大家放心

00:27.720 --> 00:30.480
每一块的知识都非常非常简单

00:30.980 --> 00:33.800
然后呢 我这里再一次重申一下

00:34.320 --> 00:37.120
TypeScript 也就是TS是一个

00:37.640 --> 00:39.180
可选的

00:39.680 --> 00:42.000
精态的类型系统

00:42.500 --> 00:44.300
一定要搞清楚这个点

00:44.800 --> 00:46.600
就是说我们他这个系统啊

00:46.860 --> 00:47.880
是可选的

00:48.140 --> 00:51.200
就是你可以用它里面的这些东西

00:51.460 --> 00:54.540
也可以像之前我在第一节课演示那样子

00:55.000 --> 00:55.780
你就代码不改

00:56.040 --> 00:57.820
直接把GS改成TS

00:58.080 --> 01:00.380
也可以获得很多很多的检查

01:00.640 --> 01:02.680
只不过呢 你学习了这些

01:02.940 --> 01:05.500
他丰富的类型系统 你学习了之后呢

01:05.760 --> 01:07.800
你可以获得更多的类型检查

01:08.060 --> 01:09.860
让你的代码更加稳健

01:10.120 --> 01:11.640
所以说这里的每一块知识

01:11.900 --> 01:13.440
本节课是一道每一块知识

01:13.700 --> 01:14.720
都是可选的

01:14.980 --> 01:17.520
说大家不要有什么样的心理压力啊

01:17.780 --> 01:20.600
多学一点 尽量去理解 尽量去学习

01:20.860 --> 01:21.880
对你们肯定是有好处的

01:22.600 --> 01:24.400
好 本节课的第一个点呢

01:24.640 --> 01:26.180
我们首先来讲一讲

01:26.440 --> 01:28.240
如何进行类型约束

01:29.000 --> 01:31.560
如何进行类型约束

01:31.820 --> 01:32.840
接下来讲一下这个点

01:33.360 --> 01:34.120
以及呢

01:34.380 --> 01:36.760
类型约束完了过后我们要进行编译

01:37.000 --> 01:39.760
编译的结果和我们的原代码的差异

01:40.000 --> 01:41.800
以及我们这样子的秘密码

01:42.560 --> 01:43.600
两个 分成两个

01:44.880 --> 01:47.680
原代码和编译结果的差异

01:48.960 --> 01:50.880
好 我们先搞清楚这两个点

01:51.800 --> 01:54.800
好 第一个点如何来进行类型约束呢

01:55.040 --> 01:56.200
非常非常简单

01:56.960 --> 01:58.360
类型约束可以约束啥

01:58.760 --> 01:59.800
可以约束变量

02:00.960 --> 02:02.360
变量还可以约束啥

02:02.600 --> 02:04.920
还可以约束函数的参数

02:05.320 --> 02:08.640
还可以约束函数的返回值

02:09.200 --> 02:11.520
通常类型约束也就是约束这些东西

02:11.760 --> 02:14.000
约束变量约束一个参数

02:14.280 --> 02:15.680
约束返回值

02:16.200 --> 02:19.360
有了约束过后我们才能进行类型检查

02:19.760 --> 02:20.280
怎么理解呢

02:20.880 --> 02:22.880
就说我们在定义变量的时候

02:23.000 --> 02:25.200
定义函数的时候就先告诉他

02:25.200 --> 02:26.600
这个函数参数什么类型

02:26.720 --> 02:27.800
这个变量什么类型

02:27.960 --> 02:29.320
函数的返回值是什么类型

02:29.560 --> 02:31.440
然后后面再用的时候

02:31.720 --> 02:33.560
就他就会进行类型检查

02:33.680 --> 02:35.360
看你是不是满足要求的

02:36.320 --> 02:37.240
怎么进行约束呢

02:37.280 --> 02:38.160
非常简单

02:38.600 --> 02:39.520
仅需要

02:40.760 --> 02:41.600
再变量

02:42.160 --> 02:44.520
函数参数 函数的返回值

02:44.720 --> 02:45.320
位置

02:46.560 --> 02:48.360
这个位置加上

02:48.880 --> 02:49.600
这么一个代码

02:49.920 --> 02:50.560
冒号

02:50.920 --> 02:53.160
冒号 后表写上类型

02:53.400 --> 02:53.920
就完了

02:54.240 --> 02:55.120
就这么简单

02:55.160 --> 02:56.160
咱们来看一下

02:56.640 --> 02:58.400
这里一个代码我们随便写吧

02:58.600 --> 03:00.080
比方说写这么一个函数

03:00.320 --> 03:00.960
写这么一个变量

03:01.440 --> 03:02.080
这个变量

03:02.240 --> 03:03.880
这个变量是一个name

03:04.160 --> 03:04.840
是个name

03:05.200 --> 03:06.600
表示的是用户的姓名

03:06.840 --> 03:08.640
那么你在定义变量的时候

03:08.640 --> 03:10.240
是不是就非常清楚

03:10.280 --> 03:11.520
这个变量是什么类型

03:12.040 --> 03:12.880
不非常清楚

03:13.320 --> 03:14.400
我们定义这么一个变量

03:14.400 --> 03:15.520
我们肯定知道

03:15.800 --> 03:17.640
这个name属性的应该什么类型

03:17.760 --> 03:18.720
应该是一个

03:18.920 --> 03:19.600
制服串

03:19.800 --> 03:20.840
应该是个制服串类型

03:20.840 --> 03:22.520
我们就这样子给他进行约束

03:22.520 --> 03:23.120
就完了

03:23.360 --> 03:25.120
变量后边加上一个冒号

03:25.360 --> 03:26.240
然后一个类型

03:26.680 --> 03:27.600
注意这个类型

03:27.640 --> 03:29.280
s是小写的不是大写的

03:29.520 --> 03:30.680
这是类型名称

03:30.920 --> 03:32.640
表示他是一个制服串

03:33.360 --> 03:33.880
OK

03:33.880 --> 03:35.960
我们后面给他进行复制的时候

03:36.160 --> 03:38.120
那么你现在复制为

03:38.360 --> 03:39.000
一个数字

03:39.000 --> 03:40.320
你看他会爆错

03:40.440 --> 03:42.520
他说不能将一个数字

03:42.520 --> 03:44.200
复制为类型制服串

03:44.360 --> 03:45.000
他就会爆错

03:45.000 --> 03:45.920
马上就提示你

03:45.920 --> 03:47.160
赶快修改这样的代码

03:47.160 --> 03:48.120
这样代码不成的

03:48.200 --> 03:49.960
你必须要改成一个制服串的代码

03:50.520 --> 03:51.120
明白吧

03:51.120 --> 03:52.920
这就是对变量的类型约束

03:52.920 --> 03:54.040
非常简单

03:54.480 --> 03:54.880
OK

03:54.880 --> 03:56.040
咱们再看下面这个

03:56.320 --> 03:57.640
我写一个函数

03:58.280 --> 04:00.040
这个函数比方说求合

04:00.760 --> 04:01.960
求合上

04:02.360 --> 04:04.120
有两个参数A和B

04:04.440 --> 04:06.240
有两个这么两个参数

04:06.480 --> 04:07.360
这两个参数

04:07.800 --> 04:09.720
对他们进行相加

04:09.720 --> 04:11.480
反回相加的结果

04:12.080 --> 04:12.400
好

04:12.400 --> 04:14.600
这里的函数是没有进行约束的

04:14.600 --> 04:16.240
没有进行约束可不可以

04:16.360 --> 04:17.640
没有任何问题

04:17.960 --> 04:20.800
TS是一个可选的类型系统

04:21.240 --> 04:22.280
那么能不能约束

04:22.280 --> 04:23.320
肯定是可以约束

04:23.320 --> 04:24.600
比方说这个参数A

04:24.840 --> 04:26.160
我可以对他进行约束

04:26.160 --> 04:27.000
约束啥呢

04:27.080 --> 04:28.080
约束为number

04:28.680 --> 04:30.360
相加必须得是数字

04:30.480 --> 04:32.120
B也约束为number

04:32.480 --> 04:34.760
两个数相加A和B必须是数字

04:35.240 --> 04:36.440
然后反回值

04:36.600 --> 04:38.280
反回值也是一个number

04:38.800 --> 04:40.160
反回值就写到这里

04:40.400 --> 04:42.600
写到这个参数的右扩号

04:42.600 --> 04:44.040
后边加上个冒号

04:44.040 --> 04:45.640
表示这个函数的反回值

04:45.640 --> 04:46.520
是一个number

04:47.160 --> 04:47.400
好

04:47.400 --> 04:48.760
咱们来调一个这个函数

04:48.760 --> 04:49.240
试一下

04:50.760 --> 04:51.560
调一个函数

04:51.560 --> 04:53.200
然后我们这里给一个字不错

04:53.200 --> 04:53.760
你看

04:54.200 --> 04:55.000
说要抱错

04:55.040 --> 04:55.600
对不对

04:55.640 --> 04:56.360
要抱错

04:56.680 --> 04:56.920
好

04:56.920 --> 04:57.360
我们这里

04:57.920 --> 04:58.920
把它改成数字

04:59.080 --> 05:00.000
这里就没问题了

05:00.240 --> 05:01.400
这里也需要改成数字

05:01.640 --> 05:03.560
这样子我们在写代码的过程中

05:03.560 --> 05:04.600
后续写代码的时候

05:04.920 --> 05:07.720
就会获得很多这样的类型检查

05:08.440 --> 05:10.280
你看代码好像是增多了

05:10.400 --> 05:11.960
增多了多少也不多

05:11.960 --> 05:14.200
就是每个参数后边写了一个类型

05:14.320 --> 05:16.480
函数的反回值后边写了一个类型

05:16.680 --> 05:18.080
就写了这么简单的代码

05:18.080 --> 05:20.200
而且这个写起来是非常好写的

05:20.360 --> 05:22.960
因为你定议这个函数的时候

05:23.400 --> 05:24.120
你想

05:24.120 --> 05:25.320
你在写这个函数

05:25.320 --> 05:28.160
是不是非常清楚它的参数是什么类型的

05:28.360 --> 05:31.120
说都不用你去脚心脑子去想

05:31.120 --> 05:32.040
非常非常简单

05:32.040 --> 05:33.720
你知道它是个数字写上

05:33.840 --> 05:34.600
数字写上

05:34.600 --> 05:36.440
反回值知道是个数字写上

05:36.440 --> 05:37.280
就完事了

05:37.520 --> 05:40.280
那么后边无论多少次去调用这个函数

05:40.320 --> 05:42.200
你都可以放心的去调用

05:42.240 --> 05:44.160
因为你只要一调用错了

05:44.160 --> 05:46.120
它马上就会提示你这理由问题

05:46.320 --> 05:48.840
就不用等到运行的过程中再去提示了

05:50.000 --> 05:52.560
再比方说这个函数它有反回值对吧

05:52.560 --> 05:55.160
我可以把这个函数的反回值

05:55.160 --> 05:56.600
负值给一个变量

05:56.960 --> 05:59.560
比方说我给它负值给一个变量

05:59.560 --> 06:00.080
NUM

06:00.360 --> 06:01.800
给这个变量约束一下

06:02.440 --> 06:03.640
是一个NUMBER的类型

06:03.840 --> 06:06.000
你看它能够正常完成负值

06:06.200 --> 06:06.760
为什么

06:06.760 --> 06:09.400
因为这个函数反回的就是一个NUMBER

06:09.440 --> 06:10.360
就是一个数字

06:10.360 --> 06:10.960
你看看

06:11.280 --> 06:11.680
ok

06:11.680 --> 06:12.520
那这里呢

06:13.200 --> 06:14.720
这个变量也是一个数字

06:14.760 --> 06:16.200
类型是匹配的

06:16.200 --> 06:16.800
因此呢

06:16.800 --> 06:17.840
可以完成负值

06:18.520 --> 06:19.560
那如果这个变量

06:19.560 --> 06:20.720
我该写成字符串

06:21.080 --> 06:22.120
马上就爆错了

06:22.120 --> 06:22.800
他告诉你

06:22.880 --> 06:24.160
我就不知道你要干嘛了

06:24.160 --> 06:25.680
这个函数反回的是一个数字

06:25.680 --> 06:27.200
但是你这个变量是一个字符串

06:27.720 --> 06:31.000
你没有办法把一个数字负值给一个字符串

06:31.320 --> 06:32.120
你来这个意思吧

06:32.760 --> 06:33.040
ok

06:33.040 --> 06:34.800
这就是类型检查

06:34.800 --> 06:35.960
在接式里面是做不到的

06:35.960 --> 06:39.280
但是TS里面就可以很轻松的做到类型的检查

06:40.200 --> 06:40.520
好

06:40.520 --> 06:41.320
不仅如此

06:41.360 --> 06:44.640
其实类型检查还给我们带来了很多的好处

06:45.280 --> 06:46.600
带来了很多的好处

06:46.840 --> 06:47.560
比方说

06:48.720 --> 06:50.160
像这里这个函数

06:50.880 --> 06:52.480
我们写的这个sum这个函数

06:52.480 --> 06:53.880
这里在调用这个函数

06:54.040 --> 06:55.120
在GS里面

06:55.120 --> 06:57.480
它是不能确定你这个地方

06:57.720 --> 06:59.600
调用的就一定是函数

06:59.600 --> 07:00.640
它不能确定的

07:00.640 --> 07:01.280
为什么呢

07:01.280 --> 07:02.800
因为在GS代码里边

07:02.800 --> 07:04.080
这个函数啊

07:04.240 --> 07:05.760
这个东西是可以改的

07:05.760 --> 07:06.600
它是可以改的

07:06.600 --> 07:07.320
比方说

07:07.880 --> 07:09.560
在GS里面可以出现这样的代码

07:09.800 --> 07:11.280
是可以出现这样的代码的

07:11.720 --> 07:13.200
因为它可能被更改

07:13.200 --> 07:14.440
它可能被更改

07:14.560 --> 07:17.040
因此它不能确定你这里的函数

07:17.040 --> 07:18.120
就一定是这个函数

07:18.120 --> 07:19.120
它无法确定的

07:19.560 --> 07:21.920
但是在TS里面是绝对不行的

07:21.920 --> 07:23.560
你怎么能这样子呢

07:23.560 --> 07:24.720
你不知道玩我吗

07:24.720 --> 07:26.320
你这里一开始写的是函数

07:26.320 --> 07:28.160
后面把它变变成一个数字

07:28.160 --> 07:29.080
那肯定不行

07:29.080 --> 07:29.920
肯定不行

07:29.920 --> 07:31.560
然后上是一个函数

07:31.560 --> 07:33.520
你不能把它复制为另外的东西

07:34.440 --> 07:35.000
好

07:35.000 --> 07:35.880
那么这个时候

07:37.000 --> 07:40.120
由于TS它知道这个地方

07:40.520 --> 07:42.680
跟这个地方是同一个东西

07:42.760 --> 07:44.800
于是就出现一个神奇的效果

07:44.800 --> 07:47.560
当我们要修改这个函数的名字的时候

07:47.560 --> 07:49.640
我们只需要找到这个函数的名字

07:49.640 --> 07:51.840
然后按一下键盘的F2

07:51.840 --> 07:53.880
按一下键盘的F2

07:53.880 --> 07:54.680
好

07:54.680 --> 07:56.680
表示重新给它命名

07:56.680 --> 07:58.440
或者是点击右键

07:58.440 --> 07:59.520
点击右键

07:59.520 --> 08:01.440
这里一个从命名符号

08:01.440 --> 08:01.680
你看

08:01.680 --> 08:02.920
快捷键F2

08:02.920 --> 08:04.000
点击一下

08:04.000 --> 08:06.680
我们这里把它改成ADD试一下

08:06.680 --> 08:08.680
ADD一回车

08:08.680 --> 08:09.480
你看

08:09.480 --> 08:10.560
这里改了

08:10.560 --> 08:12.080
这里也跟着改了

08:12.280 --> 08:13.720
为什么能达到这样的效果

08:13.720 --> 08:16.880
因为在TS里面有严格的类型检查

08:16.880 --> 08:19.560
它知道这个地方用的就是函数

08:19.560 --> 08:23.560
因此当我们去使用这个函数的时候

08:23.560 --> 08:25.480
它知道这里就用的是它

08:25.480 --> 08:27.640
那么它们两个之间是有联系的

08:27.640 --> 08:28.920
当我改动它的时候

08:28.920 --> 08:30.320
它也会跟着改变

08:31.560 --> 08:32.920
而且不仅如此

08:32.920 --> 08:35.480
假设咱们这个函数写到另外一个文件里面了

08:35.480 --> 08:38.080
我们现在还没有学习TS里面的魔幻化

08:38.080 --> 08:39.320
我们之后学校再说吧

08:39.320 --> 08:40.680
我们这里先假设

08:40.720 --> 08:42.760
假设它是写到另外一个文件里面了

08:42.760 --> 08:44.840
我们在这里使用这个函数

08:44.840 --> 08:45.160
你看

08:45.160 --> 08:46.520
仍然可以知道这个函数的

08:46.520 --> 08:47.480
函数什么类型

08:47.480 --> 08:48.920
反挥值什么类型

08:48.920 --> 08:49.960
不仅如此

08:49.960 --> 08:51.880
我们点击下这个函数

08:51.880 --> 08:56.160
按一下键盘的F12

08:56.160 --> 08:57.920
或者是点击右键

08:57.920 --> 08:59.080
点击右键

08:59.080 --> 09:01.120
这里一个转到定义

09:01.120 --> 09:02.320
转到定义

09:02.320 --> 09:03.240
点一下

09:03.240 --> 09:03.680
你看

09:03.680 --> 09:06.440
它就可以挑到这个函数所在的位置

09:06.440 --> 09:08.480
因为两者之间是建立了联系的

09:08.520 --> 09:10.720
它有严格的类型检查

09:10.720 --> 09:11.920
这就是类型检查

09:11.920 --> 09:14.480
给我们带来的一些额外的好处

09:14.480 --> 09:14.720
OK

09:14.720 --> 09:16.560
这是关于如何对函数

09:16.560 --> 09:19.400
如何对一个变量进行类型的约束

09:20.960 --> 09:21.240
好

09:21.240 --> 09:22.920
在进行类型约束的时候

09:22.920 --> 09:26.360
其实还有一个点

09:26.360 --> 09:29.600
为了让我们尽量的可以少写一些代码

09:29.600 --> 09:31.640
TS有这么一个功能

09:31.640 --> 09:35.720
TS可以在很多场景中

09:36.720 --> 09:40.200
可以完成类型推到

09:40.200 --> 09:41.440
类型推到

09:41.440 --> 09:42.680
什么叫类型推到

09:42.680 --> 09:44.760
它可以非常智能的发现

09:44.760 --> 09:46.840
你这个东西是什么样的类型

09:46.840 --> 09:49.080
比方说给它举个例子

09:49.080 --> 09:50.840
看一下这里的函数

09:50.840 --> 09:54.480
我把这个返回类型约束给它去掉了

09:54.480 --> 09:56.320
把这个人给它去掉

09:56.320 --> 09:58.040
我们指着这个函数看一下

09:58.040 --> 10:00.480
它返回的是什么类型

10:00.480 --> 10:02.760
它认为返回的还是Number类型

10:02.760 --> 10:04.520
它怎么知道的

10:04.560 --> 10:06.320
因为它很智能的发现

10:06.320 --> 10:07.680
你这个数字是Number

10:07.680 --> 10:09.040
你这个数字是Number

10:09.040 --> 10:09.320
好

10:09.320 --> 10:10.440
这两个都是Number

10:10.440 --> 10:12.960
那么两个相加的结果是不是也是Number

10:12.960 --> 10:13.960
也是Number

10:13.960 --> 10:15.800
Number把这个Number返回

10:15.800 --> 10:18.240
那么返回结果一定还是Number

10:18.240 --> 10:20.600
它可以非常智能的推倒出

10:20.600 --> 10:22.640
在很多场景下面都可以推倒出

10:22.640 --> 10:24.040
它是一个什么样的类型

10:24.040 --> 10:26.680
你看它推倒出这是一个Number类型

10:26.680 --> 10:29.360
因此我们在第九行的时候

10:29.360 --> 10:32.160
我们还可以把这个地方也省略

10:32.160 --> 10:33.600
这个地方也省略

10:33.680 --> 10:34.480
你看一下

10:34.480 --> 10:37.080
我们指着这个变量Number

10:37.080 --> 10:38.880
它也知道它是Number类型

10:38.880 --> 10:40.000
它怎么知道的

10:40.000 --> 10:41.720
因为它知道这个Number

10:41.720 --> 10:43.680
它在复制的是什么

10:43.680 --> 10:45.400
复制的是一个函数

10:45.400 --> 10:48.480
TS在每个地方都有类型检查

10:48.480 --> 10:50.080
每个地方都有类型检查

10:50.080 --> 10:52.480
它检查出来这个函数得到了结果

10:52.480 --> 10:53.360
是一个Number

10:53.360 --> 10:55.440
你把一个数字复制给这个变量

10:55.440 --> 10:57.240
那么这个变量自然就是Number

10:57.240 --> 10:58.720
这就是类型推倒

10:58.720 --> 11:00.160
因此一个单码就更加简洁了

11:00.160 --> 11:01.280
你看看

11:01.280 --> 11:03.520
咱们只需要在参数位置

11:03.520 --> 11:06.040
加上了两个检查就完事了

11:06.040 --> 11:07.800
当然这是这个场景

11:07.800 --> 11:09.480
再比方说

11:09.480 --> 11:12.000
刚才的定一个变量Name

11:12.000 --> 11:13.960
直接给它复制一个字符串

11:13.960 --> 11:15.640
复制一个字符串

11:15.640 --> 11:19.080
那么我们看一下这个Name什么类型

11:19.080 --> 11:21.040
实际它推倒出来了

11:21.040 --> 11:22.720
因为你给它直接复制一个字符串

11:22.720 --> 11:23.720
这是个字符串

11:23.720 --> 11:24.680
你复制给这个变量

11:24.680 --> 11:25.880
说明了这个变量

11:25.880 --> 11:28.120
可以接收一个字符串类型

11:28.120 --> 11:29.880
没有任何问题的

11:29.880 --> 11:31.320
因此在很多场景下面

11:31.360 --> 11:33.640
甚至我们都不用去手动书写

11:33.640 --> 11:35.440
这样的类型约书了

11:35.440 --> 11:36.640
都不用手动书写了

11:36.640 --> 11:39.280
那么它可以利用它的类型推倒

11:39.280 --> 11:41.240
让它自动推倒出来

11:41.240 --> 11:43.520
这个时候就有一个疑问了

11:43.520 --> 11:46.400
我怎么知道它什么时候能推到成功

11:46.400 --> 11:48.240
什么时候不能推到成功了

11:48.240 --> 11:49.600
我怎么知道呢

11:49.600 --> 11:50.920
这个问题

11:50.920 --> 11:53.520
告诉大家一个小技巧

11:53.520 --> 11:56.200
当我们看到这个东西的时候

11:56.200 --> 11:58.720
比方说 age 年龄

11:58.720 --> 12:00.440
有的时候我们看到一个变量

12:00.480 --> 12:02.200
或者是参数

12:02.200 --> 12:04.480
或者是函数的返回之位置

12:04.480 --> 12:05.520
它出现了三个底

12:05.520 --> 12:06.800
你看到没

12:06.800 --> 12:07.840
三个底

12:07.840 --> 12:09.240
你看这个仔细看

12:09.240 --> 12:10.320
age 下面有三个底

12:10.320 --> 12:11.880
我把它放大一点

12:11.880 --> 12:12.640
看到没

12:12.640 --> 12:14.400
这个 age 变量下面有三个底

12:14.400 --> 12:15.520
这三个底就是

12:15.520 --> 12:17.360
你可以把它当成一个警告

12:17.360 --> 12:19.640
表示它这个变量没有推倒出来

12:19.640 --> 12:20.920
它到底是一个什么样的类型

12:20.920 --> 12:22.400
它没有推倒出来

12:22.400 --> 12:23.280
没有推倒出来

12:23.280 --> 12:25.240
它是什么类型啊

12:25.240 --> 12:26.720
如果它推倒不出来的话

12:26.720 --> 12:28.920
它把它作为 any 类型

12:28.960 --> 12:31.280
any 类型是什么意思

12:31.280 --> 12:34.080
any 类型

12:34.080 --> 12:36.160
表示任意类型

12:36.160 --> 12:37.440
表示任意类型

12:37.440 --> 12:40.360
该类型

12:40.360 --> 12:42.840
对该类型

12:42.840 --> 12:46.200
TS 不进行类型检查

12:46.200 --> 12:47.960
它不是不会检查的

12:47.960 --> 12:49.480
是不会作为任何检查的

12:49.480 --> 12:50.440
对于这个类型

12:50.440 --> 12:53.640
因此它包了类似于警告这么一个东西

12:53.640 --> 12:54.440
它让你小心

12:54.440 --> 12:55.600
我这里我办不到了

12:55.600 --> 12:57.200
我确实无法知道它什么类型

12:57.200 --> 12:58.360
让你小心一点

12:58.360 --> 13:00.160
那么看到这种情况下的话

13:00.160 --> 13:02.960
你自己手动约束一下

13:02.960 --> 13:04.120
如果没看到这个东西

13:04.120 --> 13:06.080
它一般都是能够推倒出来的

13:06.080 --> 13:07.280
明白了

13:07.280 --> 13:08.280
这里再说一点

13:08.280 --> 13:09.560
就是刚才

13:09.560 --> 13:11.280
name 这个变量

13:11.280 --> 13:13.480
你给它复制为一个制服串过后

13:13.480 --> 13:14.720
我们现在再看

13:14.720 --> 13:16.360
给它复制为一个制服串过后

13:16.360 --> 13:18.920
我们现在想把 name 变成一个数字

13:18.920 --> 13:20.000
行不行

13:20.000 --> 13:21.400
还是不行

13:21.400 --> 13:22.280
推倒出来的类型

13:22.280 --> 13:24.400
跟我们自己手动约束的类型

13:24.400 --> 13:26.840
是完全一样的效果

13:26.920 --> 13:28.560
它既然推到出来是个制服串

13:28.560 --> 13:30.000
它就必须要是一个制服串

13:31.560 --> 13:32.120
说到之后

13:32.120 --> 13:33.360
我想到一个东西

13:33.360 --> 13:35.600
我就多说几句吧

13:36.560 --> 13:38.920
就是我看到了很多同学的

13:38.920 --> 13:40.960
一个常犯的一个错误

13:40.960 --> 13:41.560
比方说

13:43.080 --> 13:43.840
电话号码

13:44.920 --> 13:47.440
缝 电话号码

13:47.440 --> 13:49.480
它应该是一个什么样的类型

13:49.480 --> 13:53.240
你觉得电话号码手机号码手机号

13:53.240 --> 13:55.840
手机号应该是一个什么样的类型

13:55.880 --> 13:56.560
两个选项

13:56.560 --> 13:57.960
一个是制服串

13:57.960 --> 13:59.400
一个是数字

13:59.400 --> 14:00.680
它应该是什么呢

14:00.680 --> 14:01.440
你觉得应该是什么

14:03.320 --> 14:05.880
有些同学之前发现很多问题就是

14:05.880 --> 14:08.560
他会把手机号认为是一个数字

14:08.560 --> 14:09.440
他分不清楚什么

14:09.440 --> 14:10.680
应该是什么情况下

14:10.680 --> 14:11.720
应该是制服串

14:11.720 --> 14:13.760
什么情况下应该是数字

14:13.760 --> 14:15.040
那么数字的话

14:15.040 --> 14:16.520
就意味着这个手机号

14:16.520 --> 14:19.440
得怎样出现得这样子出现

14:19.440 --> 14:21.000
得这样子出现

14:21.000 --> 14:21.800
手机号

14:21.800 --> 14:23.960
当这样出现倒是没有什么问题

14:23.960 --> 14:25.160
没有什么问题

14:25.200 --> 14:26.040
只不过呢

14:26.040 --> 14:27.680
从逻辑上来讲

14:27.680 --> 14:28.680
手机号

14:28.680 --> 14:30.200
它不应该是一个数字

14:30.200 --> 14:32.000
而应该是一个制服串

14:32.000 --> 14:34.120
为什么我们如何来判断

14:34.120 --> 14:37.240
它某个东西是制服串还是数字类型

14:37.240 --> 14:39.160
因为以前学介石的时候

14:39.160 --> 14:40.120
无所谓

14:40.120 --> 14:41.080
可以变吗

14:41.080 --> 14:41.960
他要么是制服串

14:41.960 --> 14:43.840
以后是数字都可以变化的

14:43.840 --> 14:45.880
但是在TS里面

14:45.880 --> 14:47.680
由于它有严格的类型检查

14:47.680 --> 14:48.680
你就必须要知道

14:48.680 --> 14:50.080
在某些场景下面

14:50.080 --> 14:50.920
像这些东西

14:50.920 --> 14:52.920
它应该是数字还是制服串

14:52.920 --> 14:54.200
告诉大家一个小技巧

14:54.280 --> 14:55.080
小技巧

14:56.760 --> 14:57.640
小技巧

14:57.640 --> 14:59.520
如何判断

14:59.520 --> 15:03.040
如何区分制服串和数字

15:04.680 --> 15:05.520
问题这样说吧

15:05.520 --> 15:08.480
如何区分数字制服串和数字

15:08.480 --> 15:09.880
像手机号这种

15:09.880 --> 15:11.320
就是一个数字制服串

15:11.320 --> 15:13.200
我们怎么知道它是数字制服串

15:13.200 --> 15:14.440
关键看什么

15:14.440 --> 15:16.000
关键看

15:16.000 --> 15:17.320
怎么读

15:17.320 --> 15:18.560
它怎么去读它

15:18.560 --> 15:20.320
如果按照

15:21.320 --> 15:24.960
如果按照数字的方式

15:24.960 --> 15:26.480
读去

15:26.480 --> 15:29.080
朗读

15:29.080 --> 15:31.080
则为数字

15:31.080 --> 15:32.880
如果

15:32.880 --> 15:34.880
否则

15:34.880 --> 15:36.720
为制服串

15:36.720 --> 15:38.120
什么意思

15:38.120 --> 15:39.920
我们要判断手机号

15:39.920 --> 15:41.440
是数字还是制服串

15:41.440 --> 15:43.360
关键是看怎么去朗读它

15:43.360 --> 15:44.160
你怎么读

15:44.160 --> 15:44.960
你怎么读

15:44.960 --> 15:45.800
怎么读的

15:45.800 --> 15:48.520
读的是1334444

15:48.520 --> 15:49.720
是个5

15:49.760 --> 15:50.200
对吧

15:50.200 --> 15:51.760
你是这种读法

15:51.760 --> 15:53.840
这不是数字的读法

15:53.840 --> 15:54.720
数字的读法

15:54.720 --> 15:56.080
看怎么读

15:56.080 --> 15:56.840
给大家看一下

15:56.840 --> 15:57.360
数字的读法

15:57.360 --> 15:58.720
怎么去读手机号

15:58.720 --> 16:00.200
数字的读法是这样子的

16:00.200 --> 16:01.960
133亿

16:01.960 --> 16:04.960
4444万

16:04.960 --> 16:07.000
5555

16:07.000 --> 16:08.920
这才是数字的读法

16:08.920 --> 16:10.680
你看数字是不是这样读的

16:10.680 --> 16:12.520
因此手机号会不会这样读

16:12.520 --> 16:13.320
不会

16:13.320 --> 16:15.240
所以说手机号

16:15.240 --> 16:18.120
应该是一个制服串

16:18.160 --> 16:19.000
同样道理

16:19.000 --> 16:20.240
身份证号

16:20.240 --> 16:21.000
学号

16:21.000 --> 16:21.680
这些东西

16:21.680 --> 16:22.720
你们自行去推到

16:22.720 --> 16:24.400
它应该是数字还是制服串

16:24.400 --> 16:26.280
都应该是制服串

16:26.280 --> 16:27.920
把这个点说一下

16:27.920 --> 16:30.880
因为这个点是经常发生错误的

16:30.880 --> 16:32.760
当然这里可以不写内询

16:32.760 --> 16:34.600
让它完成推导

16:34.600 --> 16:37.600
这是关于内询推导

16:37.600 --> 16:39.080
如何进行内询约束

16:39.080 --> 16:41.000
最简单最简单的方式

16:41.000 --> 16:42.360
其实没了

16:42.360 --> 16:43.320
没什么东西

16:43.320 --> 16:44.400
就这么简单

16:44.400 --> 16:45.200
加上个冒号

16:45.200 --> 16:47.400
加上个内询就完事了

16:47.440 --> 16:49.240
有了内询推导之后

16:49.240 --> 16:50.400
你看整个代码里边

16:50.400 --> 16:51.720
除了这些注释之外

16:51.720 --> 16:52.960
除了这些注释之外

16:54.600 --> 16:55.720
除了注释之外

16:55.720 --> 16:58.560
我们内询约束也就发生在这里了

16:58.560 --> 16:59.480
你看很多地方

16:59.480 --> 17:00.680
它都可以推导出来

17:00.680 --> 17:02.120
很多地方都可以推导出来

17:02.120 --> 17:03.400
不用你手工去写

17:04.080 --> 17:05.200
有了内询推导之后

17:05.200 --> 17:06.200
我们后边写代码了

17:06.200 --> 17:07.520
就非常稳坚了

17:07.520 --> 17:08.680
咱们接下来看一看

17:08.680 --> 17:09.600
下面这个问题

17:10.600 --> 17:13.480
原代码和编译结果的差异

17:13.480 --> 17:14.800
就是它会进行编译

17:14.880 --> 17:18.400
如果我们知道TS是介石的超级

17:18.400 --> 17:19.680
它可以进行编译的

17:19.680 --> 17:21.200
会编译成为介石

17:21.200 --> 17:23.160
那么编译完成之后

17:23.160 --> 17:25.520
编译的结果是什么样子的呢

17:25.520 --> 17:27.160
咱们来看一下吧

17:27.160 --> 17:28.240
看了再说

17:28.240 --> 17:32.000
我们TSC完成编译

17:32.000 --> 17:33.200
看一下

17:33.200 --> 17:34.600
看一下编译结果

17:34.600 --> 17:36.640
我这里分屏

17:36.640 --> 17:38.320
我分一个屏

17:38.320 --> 17:40.400
这里分个屏

17:40.400 --> 17:42.600
这边

17:42.600 --> 17:43.080
OK

17:43.080 --> 17:44.600
左边是我们的TS代码

17:44.680 --> 17:45.960
右边是我们的介石代码

17:45.960 --> 17:47.360
你对比一下

17:47.360 --> 17:48.640
对比一下

17:48.640 --> 17:50.600
你会很快的发现

17:50.600 --> 17:51.920
啥都没变

17:51.920 --> 17:53.320
就变了一个东西

17:53.320 --> 17:55.400
我们的内询约束是不是没了

17:55.400 --> 17:56.000
对不对

17:56.000 --> 17:58.600
内询约束在介石代码里面就消失了

17:58.600 --> 17:59.640
因为介石代码里面

17:59.640 --> 18:01.080
它没有内询约束

18:01.080 --> 18:02.200
就这个点

18:02.200 --> 18:03.720
我们的TS多的是什么

18:03.720 --> 18:05.400
多的就是内询系统

18:05.400 --> 18:06.440
我们学习的是什么

18:06.440 --> 18:07.520
学习的就是

18:07.520 --> 18:09.680
如何在各种场景下面

18:09.680 --> 18:12.160
对内询进行完善的约束

18:12.160 --> 18:13.320
你可不可以不约束

18:13.320 --> 18:14.440
可以不约束

18:14.480 --> 18:16.480
它不是强制要求可选的

18:16.480 --> 18:18.000
但是如果你要约束的话

18:18.000 --> 18:19.040
在各种场景下面

18:19.040 --> 18:19.920
该怎么去约束

18:19.920 --> 18:21.400
这是我们学习的东西

18:21.400 --> 18:22.440
编译结果里面

18:22.440 --> 18:24.160
是没有任何的内询约束的

18:24.160 --> 18:26.440
这再一次反复的强调

18:26.440 --> 18:28.080
再一次说明

18:28.080 --> 18:29.480
运行的过程中

18:29.480 --> 18:31.280
有没有TS代码

18:31.280 --> 18:33.600
完全没有

18:33.600 --> 18:35.600
运行的过程中就是个介石代码

18:35.600 --> 18:38.000
TS代码的内询检查是静态的

18:38.000 --> 18:39.200
为什么要静态的

18:39.200 --> 18:41.280
如果我这里写错了

18:41.280 --> 18:42.760
如果我这里写错了

18:42.760 --> 18:43.960
它不让我通过编译

18:43.960 --> 18:44.840
它不能让我编译

18:44.840 --> 18:45.640
它说这里有错误

18:45.640 --> 18:47.880
你得把错误解决过后

18:47.880 --> 18:50.480
我才会把它编译成为介石

18:50.480 --> 18:51.720
它是这么一回事

18:51.720 --> 18:54.040
所以说

18:54.040 --> 18:55.920
这就再一次解释了

18:55.920 --> 18:58.480
我们之前那句话

18:58.480 --> 19:02.800
TS是一个可选的静态的内询系统

19:02.800 --> 19:05.520
一定要反复的去理解这句话

19:05.520 --> 19:07.800
我们可以看到原代码

19:07.800 --> 19:13.640
编译结果中

19:13.800 --> 19:17.400
没有内询约书信息

19:17.400 --> 19:18.640
这个信息丢失了

19:18.640 --> 19:21.680
也就是说TS它是静态的

19:21.680 --> 19:23.400
它只在编译中生效

19:23.400 --> 19:26.480
编译完成过后就没它什么事了

19:26.480 --> 19:28.320
好了这是关于第一部分

19:28.320 --> 19:31.280
咱们具体的讲各种内询之前

19:31.280 --> 19:34.000
我们先看一下如何来进行简单的操作

