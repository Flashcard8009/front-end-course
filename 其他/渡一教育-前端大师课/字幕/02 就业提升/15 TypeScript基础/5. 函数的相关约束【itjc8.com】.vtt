WEBVTT

00:00.560 --> 00:03.560
OK 怎么样啊 还行吧

00:03.560 --> 00:08.560
东西有点多啊 但是每一块东西呢都很简单啊 非常非常简单

00:09.560 --> 00:14.560
好 咱们再了解一下关于函数的类型约束之后呢 我们就来做一个练习

00:15.560 --> 00:22.560
这一块呢 我们了解一下 函数的相关约束

00:23.560 --> 00:27.560
这里呢 我举一个例子啊 先还是从一个例子出发

00:28.560 --> 00:34.560
比方说 我这里有个函数 这个函数呢 我们给他取个名字叫康败

00:35.560 --> 00:40.560
联合 把组合起来 组合啥呢 组合两个参数

00:41.560 --> 00:46.560
一个参数呢 他可能是数字 也可能是一个制服串

00:47.560 --> 00:52.560
第二个参数呢 有可能是一个数字 也有可能是一个制服串

00:53.560 --> 00:57.560
返回的结果呢 有可能是一个数字 有可能是一个制服串

00:58.560 --> 01:02.560
我到底要干嘛啊 我要做的事情很简单 我要做的事情

01:03.560 --> 01:07.560
如果这两个是数字 两个相加返回

01:08.560 --> 01:12.560
如果这两个是制服串 制服串拼接过后返回

01:13.560 --> 01:18.560
我要做这么一件事情 如果两个数 这样子吧 两个数字相乘返回

01:18.560 --> 01:20.560
两个是制服串 拼接 返回

01:21.560 --> 01:23.560
于是呢 我这里面需要判断

01:24.560 --> 01:30.560
如果type A 等于了什么number

01:31.560 --> 01:38.560
等于number 并且type B 等于了number 两个都是数字

01:39.560 --> 01:46.560
都是数字怎么样呢 return A乘一B 当然返回的 你看内形保护

01:47.560 --> 01:54.560
内形保护 我通过type of判断之后呢 在判断里边 我们就知道了 他明确了他的内形 A和B都是数字

01:55.560 --> 01:59.560
好 那么这种情况下返回一个数字 两个强乘

02:00.560 --> 02:06.560
然后lcf type A 如果是一个制服串

02:07.560 --> 02:12.560
并且B B 也有可能是一个制服串

02:12.560 --> 02:18.560
如果两个都是制服串的话 我们把两个制服串拼接返回

02:19.560 --> 02:23.560
你看 现在这两个都是制服串 是可以拼接的 拼接过后进行返回

02:24.560 --> 02:29.560
好 现在还在爆错 有可能返回一个数字 有可能返回一个制服串 为什么还要爆错

02:30.560 --> 02:37.560
他说 函数缺少结束返回语句 返回内形不包括undefend 啥意思

02:38.560 --> 02:43.560
就是说函数 他说他有可能这个衣服判断进不了

02:44.560 --> 02:51.560
这个lcf也进不了 有没有这种可能 有没有这种可能 有的对吧 有这种可能 他万一给我这样传递呢

02:52.560 --> 02:57.560
A 传一个数字 B 传一个制服串了 这种情况我是不考虑的 我这个函数不考虑这种情况

02:58.560 --> 03:01.560
那么我怎么办呢 我只能爆错了 我只能爆错了

03:02.560 --> 03:09.560
就这里就不太好处理了 使用6error爆错了 就随便写吧

03:10.560 --> 03:18.560
A和B必须是相同的内相 来提示个错误 我们写好函数

03:19.560 --> 03:23.560
那么这个函数写好了之后 这个函数写到倒是没什么问题

03:24.560 --> 03:30.560
但是我们之后雕用的时候就会出问题 因为雕用的时候我们就可能会乱去传递

03:31.560 --> 03:39.560
第一个传一个数字 第二个传一个制服串 我们可能会去这样传递 当然你会觉得谁啊 谁这么神经病啊

03:40.560 --> 03:47.560
有可能当我们代码写的很多很多了 这只是我们整个系统里面 一万个函数里面的其中一个函数

03:48.560 --> 03:52.560
你很难清楚你脑袋是不是写婚了 这个地方写的一个这个东西 脑袋就写婚了

03:53.560 --> 03:57.560
这个地方传个数字 这个地方传个制服串 当然你看到这个东西还觉得很奇怪

03:57.560 --> 04:06.560
那如果这个地方是来自于其他的函数雕用的 比方说get some number 有可能这个函数反过来是一个制服串了

04:07.560 --> 04:12.560
你还能非常的清楚这里有问题吗 你又不能清楚了啊 有很难清楚这里出现的问题

04:13.560 --> 04:19.560
因此我们来雕用这个函数 最好的做法是什么 最好的做法是告诉他

04:20.560 --> 04:29.560
我这里要么全部都是数字 要么全部都是制服串 如果这里全部都是数字的话 返回的结果也是数字

04:30.560 --> 04:36.560
如果这里全部都是制服串的话 返回的结果也是制服串 我们要把这个信息要告诉他

04:37.560 --> 04:43.560
要把这个信息要扔出来 把这个信息扔出来之后呢 到时候我们雕用这个函数就不会出问题了

04:43.560 --> 04:50.560
你这样传递他要报错的 他要报错的 并且呢 我们现在这个信息是丢失的 比方说我这里的变量

04:51.560 --> 04:58.560
变量realt 指着这个变量他什么类型 他要么是制服串 要么是number 怎么会这样子呢

04:59.560 --> 05:04.560
如果我这里传了两个数字 你想一想 传了两个数字按照逻辑来说 按照逻辑来说

05:05.560 --> 05:08.560
这个realt应该什么类型 我这里传两个数字

05:09.560 --> 05:14.560
从逻辑上来讲 是不是一定是number类型 他怎么给我推断出这个玩意了

05:15.560 --> 05:19.560
这个玩意后面的不好用了 真的很难用了 因为后面我明明知道他是一个number类型

05:20.560 --> 05:25.560
但是我不能使用number类型里面的东西 因为他现在不能确定他是制服串还是number

05:26.560 --> 05:30.560
他只能提取什么 只能提取制服串和number公有的函数 就是这两个函数

05:31.560 --> 05:33.560
number和制服串都有函数 他只能这样子处理

05:34.560 --> 05:43.560
我们现在写这个函数的时候 有些信息丢失掉了 什么信息 就是这些参数和返回值组合的信息丢失掉了

05:44.560 --> 05:50.560
当他两个是number 返回的结果一定是number 当他两个是制服串 返回的结果一定是制服串

05:51.560 --> 05:54.560
并且只有这两种情况 没有其他情况了 我们把这个信息丢失掉了

05:55.560 --> 06:04.560
那么这个信息怎么给他加上了 我们可以在函数上边 在这里单独去写函数的声明

06:05.560 --> 06:09.560
只写声明就行了 不写函数题 方个形 康败

06:10.560 --> 06:17.560
第1个参数number 第2个参数number 返回的类型number

06:18.560 --> 06:21.560
我们这里甚至可以打上一个注释 我们先不打注释

06:21.560 --> 06:26.560
然后再写一个 你看我直接分号结束了 没有写函数的函数题

06:27.560 --> 06:35.560
然后这里 康败 同名 A 制服串 B 制服串 返回的结果 制服串 看一下

06:36.560 --> 06:44.560
我现在相当于是高速的TS 我这里有个函数 这个函数只能有两种情况

06:45.560 --> 06:50.560
只能有两种情况 这两种情况分别是什么情况 我会明确的告诉你

06:51.560 --> 06:56.560
第1种情况 两个数字返回一个数字 第2种情况 两个制服串返回一个制服串

06:57.560 --> 07:04.560
看没 我明确的告诉TS 这里有只有这么两种情况 这里我先来框住这一部分

07:05.560 --> 07:10.560
就是函数重占 使用同一个函数名称来约束这个函数调用的几种情况

07:10.560 --> 07:15.560
把它约束好 约束好了之后咱们再来看 再来看

07:16.560 --> 07:23.560
当我进行函数调用的时候 当我在这里使用康败来进行函数调用的时候 你看

07:24.560 --> 07:28.560
这里出现了一个翻页 第1种情况 第2种情况 第1种情况

07:30.560 --> 07:36.560
这里 打出来 第1种情况 第2种情况 第1种情况 第2种情况

07:37.560 --> 07:44.560
好 第1种情况 两个都是数字 route 一定是数字 看没 一定是数字

07:45.560 --> 07:51.560
如果两个都是制服串 如果两个都是制服串 那么 route 就制服串

07:52.560 --> 07:58.560
它就能非常清楚的知道 调用了几种情况了 并且我们这里能不能传一个数字传一个制服串了

07:59.560 --> 08:03.560
不行 不行 它告诉你 只有这两种情况没有其他情况了

08:03.560 --> 08:11.560
那么这个信息传递给了TS 就能在后边后续的过程中完成对内行更加精细的检查

08:12.560 --> 08:16.560
如果你没有这种情况的话 你是很难完成的 这就是函数重战

08:17.560 --> 08:32.560
第一个 函数重战 就是在函数实现之前对函数调用的多种情况进行声明

08:33.560 --> 08:36.560
这就是函数重战 那么这个声明可能有一个 可能有多个

08:37.560 --> 08:43.560
当然你甚至可以在每一个声明上面写上注释 写上注释

08:44.560 --> 08:50.560
告诉他这个地方是得到A 乘异B的结果

08:51.560 --> 08:59.870
第二个 这个是得到A和B拼接的结果

09:00.870 --> 09:03.870
可以给每一个声明写上这个注释

09:04.870 --> 09:08.870
ok 那么这里呢 比方说你传两个数字 我们指着他 你看一下

09:09.870 --> 09:12.870
指着他 他使用的就是第一种重战 第一个重战

09:13.870 --> 09:15.870
如果你使用的是两个字母串

09:17.870 --> 09:24.380
这样子写吧 这里 你看 第一个重战 第二个重战

09:25.380 --> 09:30.380
我使用两个字母串 它会非常智能的知道 你现在在使用第二个重战

09:31.380 --> 09:33.380
每一个函数可以有多个重战

09:34.380 --> 09:38.380
这是第一个 关于函数的约束的 第一个就是函数的重战

09:39.380 --> 09:44.380
好 第二个是可选参数 可选参数

09:45.380 --> 09:54.380
这个啥意思呢 就是可以在某些参数名后加上问号

09:55.380 --> 10:00.380
表示该参数可以不用传递 是可以不用传递的

10:01.380 --> 10:05.380
咱们来写个例子 几个简单的例子 注释量

10:06.380 --> 10:10.380
当然我顺便说一下 这些东西都是告诉TS的

10:11.380 --> 10:14.380
编译结果里面不会存在的 编译结果里面没有这个东西

10:15.380 --> 10:17.380
我这里把注释量

10:18.380 --> 10:20.380
好 下面 我们写上这么一个代码

10:21.380 --> 10:25.380
举个啥例子呢 这个例子没有啥实际意义

10:26.380 --> 10:28.380
纯粹是在说明这个语法

10:35.380 --> 10:38.380
我希望完成这么一个效果 什么效果呢 就是说

10:39.380 --> 10:41.380
这个函数 它要传三个数字进来

10:42.380 --> 10:47.380
如果你传了两个参数 如果你只传两个数字 我就把两个数字相加

10:48.380 --> 10:50.380
如果你传了三个数字 我就把三个数字相加

10:51.380 --> 10:54.380
也就是说第三个是可以不用传递的

10:55.380 --> 10:57.380
我如何来告诉他第三个不用传递呢

10:58.380 --> 11:01.380
如果你不特加说明的话 调用函数的时候你只能传三个

11:02.380 --> 11:04.380
你不可能只传两个的 TS的时候很严格的

11:05.380 --> 11:09.380
他不允许你参数数量不匹配 他必须要让你参数数量完全匹配

11:10.380 --> 11:13.380
因此像这种情况不行 于是我假设

11:14.380 --> 11:18.380
第三个参数我是可以不用传递的 那么我可以给参数名后面加三个问号

11:19.380 --> 11:22.380
表示这里是个可选参数 你看 现在不抱错了

11:22.380 --> 11:27.380
传两个参数可以传三个参数 也没问题

11:28.380 --> 11:32.380
他就不抱错了 现在我们用鼠标指着这个C看一下

11:33.380 --> 11:37.380
什么类型 Number或者是Number

11:38.380 --> 11:40.380
想一想 符不符合逻辑

11:41.380 --> 11:45.380
是不符合逻辑的 你不传递 不传递的时候就是Number

11:46.380 --> 11:50.380
传递的时候就是Number 就这么回事 就是可选参数 可以不传递

11:51.380 --> 11:58.380
那么这里怎么判断的 判断呗 如果C有值 如果C有值 返回A加B加C

11:59.380 --> 12:02.380
那么C你看 通过这种方式他也能够进行类型保护

12:03.380 --> 12:07.380
通过这种方式也能够进行类型保护 他本来是类型是Number或者是Number

12:08.380 --> 12:12.380
但是经过这么一判断 Number的话一定到不了110行

12:13.380 --> 12:16.380
单码只要运行到110行 他一定是Number

12:17.380 --> 12:19.380
所以说C他能推断出来 准确的类型是Number

12:20.380 --> 12:25.380
好 AOS AOS的话返回的是A加B 就写完了

12:26.380 --> 12:28.380
明白这意思吧 这是可选参数 可选参数

12:29.380 --> 12:33.380
当然有可选参数 还有一个东西是默认参数 还有一个东西是默认参数

12:34.380 --> 12:38.380
默认参数的话跟介石就一样了 就是这个地方

12:39.380 --> 12:45.380
可以跟他付这个默认值0 那么这里我们可以直接返回A加B加C

12:46.380 --> 12:47.380
没问题 没问题

12:47.380 --> 12:52.380
当我们去指责这个函数的时候 你看一下 他会把它翻译成啥呢

12:53.380 --> 12:57.380
指责这个函数 看一下 我们给他写了默认参数过后

12:58.380 --> 13:03.380
他自动给你加了一个问号 什么意思啊 默认参数是不是可选的

13:04.380 --> 13:07.380
就相当于是可以不传递的 所以默认参数一定是可选参数

13:08.380 --> 13:12.380
只不过默认参数呢 他不一定为Nd犯 因为我给他付了默认值

13:13.380 --> 13:16.380
他是Nd犯的时候 他就会使用默认值

13:17.380 --> 13:21.380
OK 这是关于可选参数 关于可选参数

13:23.380 --> 13:29.380
另外一点就是稍加说明一下 其实这个点不说明大家应该也能推倒出来

13:30.380 --> 13:35.380
就是说可选参数能不能是第一个呢

13:36.380 --> 13:41.380
能不能是第一个呢 你想一想这个道理 想一想这个逻辑道理 好好想一想

13:42.380 --> 13:47.380
可选参数能不能是前边 能不能出现在前边 不行

13:48.380 --> 13:50.380
那你想一想为什么不行呢 他没道理啊

13:51.380 --> 13:54.380
如果你第一个是可选参数 你说第一个是可以不用传递的

13:55.380 --> 13:59.380
但是我调入函数的时候 我传递的参数 第一个是不是始终要传递的

14:00.380 --> 14:02.380
你有三个参数 我至少得传两个吧

14:03.380 --> 14:06.380
我传两个参数的时候 第一个传给他谁 就传给他了

14:07.380 --> 14:10.380
那有什么意义呢 我还得传三个 我还得传三个 那有什么意义呢

14:11.380 --> 14:18.380
这是写是没有任何意义的啊 因此呢 他要求你可选参数是不能出现在前边的

14:19.380 --> 14:24.380
只能出现在末尾 可选参数只能出现在末尾 你可以有多个可选参数没问题

14:25.380 --> 14:30.380
比方说B可选 C也可选 多个可选没问题 但是一定要是末尾

14:31.380 --> 14:35.380
一定要是末尾 不然的话没有什么意义 因此呢 可选参数注意一下

14:35.380 --> 14:41.380
可选参数必须在参数列表的末尾

14:44.140 --> 14:50.140
好了 韩束讲完了 那么本节课所有的知识部分就讲完了

14:51.140 --> 14:56.140
东西有点多 但是呢 实际上是不复杂 始终记住 TS是一个可选的

14:57.140 --> 15:03.140
内静态内循系统 真是因为他可选的 你不用有那么大的压力

15:03.140 --> 15:08.140
你能记多少 我们在项目中就使用多少 慢慢的用着用着 熟悉了过后

15:09.140 --> 15:14.140
项目里边想加入更多的内形检查 那么你再去翻这个视频里面的相应的地方

15:15.140 --> 15:18.140
进行对他进行内形约束 他是可选的 不要有太大的压力

15:19.140 --> 15:24.140
很多人学这个 TS 就感觉快要英勇就义一样 怎么这么的东西啊

15:25.140 --> 15:27.140
他是可选的 急什么呢 不用害怕

15:28.140 --> 15:35.140
ok 那么这里会讲完之后呢 我们马上来做一个练习 来巩固一下这一刻的相关知识

15:36.140 --> 15:40.140
咱们这个小节先到这 我们下个小节做一些练习

