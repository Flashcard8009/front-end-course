WEBVTT

00:00.750 --> 00:04.750
好 在这个部分里边 我们来看一下TES

00:04.750 --> 00:10.750
它有什么样的特点 以及它是如何来解决我们之前提到的这些问题的

00:10.750 --> 00:16.750
根据官方的定义的话 它说TypeScript就是TES

00:16.750 --> 00:20.750
是一个什么呢 是介石的超级

00:20.750 --> 00:24.750
我们先把它的就是这句话写出来 慢慢来解释

00:25.750 --> 00:33.750
是一个可选的静态的类型系统

00:33.750 --> 00:39.750
好 这句话呢 实际上就把TES它的特点 以它的优势

00:39.750 --> 00:43.750
给它解释的非常清楚了 好 我们一个个一个来看

00:43.750 --> 00:47.750
首先看这两个字 超级 什么叫超级呢

00:47.750 --> 00:52.750
比方说我们平时说的 超级 我们先解释一下

00:52.750 --> 00:55.750
我们平时说的什么整数 对吧 整数

00:55.750 --> 00:59.750
还有一个就是正整数 正整数

00:59.750 --> 01:02.750
那么整数里边其实是包含正整数的

01:02.750 --> 01:09.750
因此我们可以认为整数是正整数的超级

01:09.750 --> 01:12.750
超级就是这个意思 它是数学里边的一个概念

01:12.750 --> 01:16.750
那么也就是说TES是介石的超级

01:16.750 --> 01:21.750
也就是说TES是包含了介石语言的所有功能

01:21.750 --> 01:25.750
这里有一张图 给大家看一下 给大家看一下这张图

01:29.750 --> 01:33.750
好 这张图 这张图里边就可以看得很清楚了

01:33.750 --> 01:38.750
我们的ES6 之前学的ES6 它是一个2015年的标准

01:38.750 --> 01:42.750
那么它是ES5的超级 因为它包含了ES5的功能

01:42.750 --> 01:46.750
然后在它基础上新增加了一些东西 就变成了ES6

01:46.750 --> 01:51.750
而TES是介石的超级 那么是所有ES版本的超级

01:51.750 --> 01:56.750
ES里边有的东西它一定有 那么它另外增加了一些东西

01:56.750 --> 02:01.750
这就是TES 所以说我们之前写的介石代码

02:01.750 --> 02:05.750
能不能直接在TES里面运行 没有任何问题

02:05.750 --> 02:08.750
没有任何问题 因为它是超级

02:08.750 --> 02:14.750
所以说TES我们学习TES并不是要学习一门全新的语言

02:14.750 --> 02:19.750
这样子的 我们使用的语言还是以前的介石语言

02:19.750 --> 02:24.750
语言本身的循环 变量定义 还是以前的东西

02:24.750 --> 02:29.750
只不过我们学习的是什么 学习的是除了以前的介石知识之外

02:29.750 --> 02:33.750
它新增加的东西在里面 我们学习的是这一部分

02:33.750 --> 02:36.750
OK 这一部分它增加的是什么东西呢

02:36.750 --> 02:38.750
它到底增加了什么玩意儿呢

02:38.750 --> 02:45.130
它增加的是一个内形系统

02:45.130 --> 02:47.130
我们看这个内形系统

02:47.130 --> 02:56.130
什么叫内形系统 就是对代码中所有的标志符

02:56.130 --> 03:02.130
哪些标志符 变量 函数 参数 返回值

03:02.130 --> 03:07.130
对这些东西进行内形检查

03:07.130 --> 03:08.130
什么叫内形检查

03:08.130 --> 03:12.130
以这个变量是一个数字内形 是一个Number

03:12.130 --> 03:14.130
那你就不能是一个字符圈

03:14.130 --> 03:17.130
你该复制字符圈的时候我要爆出 就是这么种内形检查

03:17.130 --> 03:20.130
包括你这个对象 对象里面有哪些属性

03:20.130 --> 03:22.130
每个属性是什么内形

03:22.130 --> 03:24.130
那么你一开始要明确的标注好

03:24.130 --> 03:26.130
标注好了之后 你后边使用的时候

03:26.130 --> 03:29.130
我会检查一下你之前的内形 给你写代

03:29.130 --> 03:32.130
给你复制的内形 是不是一样的

03:32.130 --> 03:33.130
这就是一个内形系统

03:33.130 --> 03:37.130
因此TS在介石基础上增加的是什么

03:37.130 --> 03:41.130
增加的是内形的检查 增加的是这么一部分

03:41.130 --> 03:44.130
就是大家看那个图 我再次拿出来的图

03:44.130 --> 03:46.130
把这个一定要理解清楚

03:46.130 --> 03:48.130
蓝色的部分 它增加的这一部分

03:48.130 --> 03:50.130
实际上就是它的内形系统

03:50.130 --> 03:52.130
而我们学习TS 学习的是啥呢

03:52.130 --> 03:55.130
学习的就是它增加的这块内形系统

03:55.130 --> 03:58.130
该怎么去用它 该怎么去玩它

03:58.130 --> 04:01.130
所以说咱们TS学习

04:01.130 --> 04:03.130
不是说学习一本全新的语言

04:03.130 --> 04:04.130
不要有心理压力

04:04.130 --> 04:07.130
它还是使用的是以前的介石语言的语法

04:07.130 --> 04:11.130
只不过呢 给它基础上增加了内形的系统

04:11.130 --> 04:14.130
可以帮助我们及时的排错

04:14.130 --> 04:16.130
可以帮助我们及时的排错

04:16.130 --> 04:20.130
这是关于TS最核心的这个特点

04:20.130 --> 04:23.130
它是介石的超级 并且它增加的是内形系统

04:23.130 --> 04:26.130
这也会导致我们在

04:26.130 --> 04:29.130
给大家交出这个课程的时候呢

04:29.130 --> 04:31.130
有些同学就是老实在想

04:31.130 --> 04:33.130
咱们学了TS过后

04:33.130 --> 04:37.130
是不是能够做出一些以前介石没有的效果

04:37.130 --> 04:39.130
以前介石玩不成的功能

04:39.130 --> 04:40.130
现在我们可以完成了

04:40.130 --> 04:42.130
不会的 不可能的

04:42.130 --> 04:47.130
因为TS它本身没有增加什么功能性的东西

04:47.130 --> 04:49.130
它没有增加功能

04:49.130 --> 04:50.130
而是做了什么呢

04:50.130 --> 04:53.130
而是做了增加了一些内形检查

04:53.130 --> 04:56.130
因此咱们在学习TS的过程中

04:56.130 --> 04:58.130
很多时候 甚至我打一把都不会运行出来

04:58.130 --> 04:59.130
运行都不会运行

04:59.130 --> 05:00.130
我就告诉你

05:00.130 --> 05:03.130
这样子写代码 能不能通过它的内形检查

05:03.130 --> 05:05.130
它怎么去约束某一个东西的内形

05:05.130 --> 05:06.130
怎么去告诉这个变量

05:06.130 --> 05:07.130
你是一个什么内形

05:07.130 --> 05:08.130
怎么去告诉这个函数

05:08.130 --> 05:10.130
反回是什么内形

05:10.130 --> 05:11.130
主要是学习这些东西

05:11.130 --> 05:14.130
很多时候我都不会把代码运行出来

05:14.130 --> 05:18.130
所以大家心里面要有这么一个感觉

05:18.130 --> 05:19.130
这么一个概念

05:19.130 --> 05:20.130
我们学习TS

05:20.130 --> 05:22.130
不是说要去学习

05:22.130 --> 05:24.130
一些玩不成的功能

05:24.130 --> 05:25.130
现在可以完成的

05:25.130 --> 05:26.130
其实介石玩不成什么功能的

05:26.130 --> 05:27.130
都可以完成

05:27.130 --> 05:30.130
只是说完成了过程中的经常容易出错

05:30.130 --> 05:32.130
而TS解决的是这些错误的问题

05:32.130 --> 05:36.130
它能够极大的减少我们的调错时间

05:36.130 --> 05:38.130
你使用了TS过后

05:38.130 --> 05:39.130
你会发现

05:39.130 --> 05:43.130
很多以前经常发生的错误在TS里面

05:43.130 --> 05:44.130
几乎是不存在了

05:44.130 --> 05:45.130
根本就看不到了

05:45.130 --> 05:48.130
因为它有一个完整的内形系统

05:48.130 --> 05:50.130
这是关于这两个点

05:50.130 --> 05:53.130
这两个点是关于TS最核心的两个点

05:53.130 --> 05:55.130
好 接下来再看这一部分

05:55.130 --> 05:59.130
可选择和静态的

05:59.130 --> 06:01.130
可选择是什么意思呢

06:01.130 --> 06:02.130
顾名思义

06:02.130 --> 06:04.130
就是它的内形检查

06:04.130 --> 06:05.130
内形系统

06:05.130 --> 06:06.130
你可以用

06:06.130 --> 06:08.130
也可以不用

06:08.130 --> 06:09.130
是可以不用它的

06:09.130 --> 06:12.130
很多同学在学习TS的时候

06:12.130 --> 06:13.130
老是说

06:13.130 --> 06:15.130
这里面怎么这么多东西

06:15.130 --> 06:16.130
感觉好难

06:16.130 --> 06:17.130
这里面

06:17.130 --> 06:18.130
你忘了

06:18.130 --> 06:19.130
它是可选的

06:19.130 --> 06:21.130
它没有强制要求你写

06:21.130 --> 06:22.130
你可以不写

06:22.130 --> 06:24.130
你可以不进行检查

06:24.130 --> 06:25.130
那你写了

06:25.130 --> 06:26.130
可以

06:26.130 --> 06:27.130
你只要你写了

06:27.130 --> 06:29.130
只要你使用了它的内形检查

06:29.130 --> 06:31.130
使用了它的内形系统

06:31.130 --> 06:34.130
那么你就可以获得更多的

06:34.130 --> 06:36.130
约束在写代码的时候

06:36.130 --> 06:38.130
就更不容易犯错

06:38.130 --> 06:39.130
但是你可以不用

06:39.130 --> 06:40.130
如果你觉得

06:40.130 --> 06:42.130
我写的更加费时间还不如调错

06:42.130 --> 06:43.130
OK 那就不用

06:43.130 --> 06:44.130
不用

06:44.130 --> 06:46.130
比方说一些小的项目里边

06:46.130 --> 06:48.130
可能代码的量的话

06:48.130 --> 06:51.130
只涉及到一万行左右的代码量

06:51.130 --> 06:52.130
不会太多的代码量

06:52.130 --> 06:53.130
一些小的项目里边

06:53.130 --> 06:54.130
那么你觉得

06:54.130 --> 06:55.130
我的能力很强

06:55.130 --> 06:57.130
我可以控制这一万行的代码

06:57.130 --> 06:59.130
我的每一个地方都记得住

06:59.130 --> 07:00.130
对吧

07:00.130 --> 07:02.130
咱们学习前端的开发者

07:02.130 --> 07:03.130
最强的是什么

07:03.130 --> 07:05.130
最强的就是记忆力了

07:05.130 --> 07:06.130
为什么这样说

07:06.130 --> 07:07.130
因为每一个函数

07:07.130 --> 07:08.130
它在编辑期里面

07:08.130 --> 07:10.130
很多时候都没有智能提示

07:10.130 --> 07:11.130
没有提示的

07:11.130 --> 07:13.130
你要全凭手敲

07:13.130 --> 07:14.130
一个字母一个字母

07:14.130 --> 07:16.130
把它的函数名字干敲出来

07:16.130 --> 07:18.130
它有几个参数全靠记忆

07:18.130 --> 07:20.130
如果你忘了怎么办

07:20.130 --> 07:21.130
去查API文档

07:21.130 --> 07:22.130
打开网页

07:22.130 --> 07:25.130
把API文档拿出来一个个查

07:25.130 --> 07:26.130
看每个参数是什么意思

07:26.130 --> 07:28.130
每个参数是什么类型

07:28.130 --> 07:30.130
那么前端开发者也真的不容易

07:30.130 --> 07:31.130
全靠记忆力

07:31.130 --> 07:32.130
全靠查文档

07:32.130 --> 07:33.130
所以说

07:33.130 --> 07:36.130
经常你现在公司里边的时候

07:36.130 --> 07:38.130
看到开发前端的

07:38.130 --> 07:40.130
整个浏览器

07:40.130 --> 07:42.130
全部标签已经写满了

07:42.130 --> 07:43.130
整个浏览器

07:43.130 --> 07:45.130
标签已经全部写满了

07:45.130 --> 07:47.130
就是每个标签里边

07:47.130 --> 07:48.130
浏览器标签里边

07:48.130 --> 07:51.130
都是一篇API文档

07:51.130 --> 07:53.130
去查各种各样的库的使用

07:53.130 --> 07:54.130
因此

07:54.130 --> 07:55.130
如果你觉得这个OK

07:55.130 --> 07:56.130
我已经习惯了

07:56.130 --> 07:57.130
那可以

07:57.130 --> 07:58.130
你使用TS的时候

07:58.130 --> 07:59.130
不用它的类型系统

07:59.130 --> 08:01.130
就用GS一样的

08:01.130 --> 08:03.130
所以TS学习的曲线

08:03.130 --> 08:05.130
是非常非常平滑的

08:05.130 --> 08:08.130
学习曲线非常平滑

08:08.130 --> 08:09.130
因为你可以不用

08:09.130 --> 08:11.130
它跟人家的东西你可以不用的

08:11.130 --> 08:13.130
但是我讲课的时候肯定会用的

08:13.130 --> 08:15.130
不然我讲它干嘛呢

08:15.130 --> 08:16.130
所以说我讲课的时候会用

08:16.130 --> 08:17.130
但是你心里面要知道

08:17.130 --> 08:18.130
它是可选的

08:18.130 --> 08:19.130
是可以不用的

08:19.130 --> 08:21.130
再给大家看个例子

08:21.130 --> 08:22.130
刚才

08:22.130 --> 08:24.130
我们写的GS代码对吧

08:24.130 --> 08:25.130
有这些乱七八糟的错误

08:25.130 --> 08:27.130
我现在只需要做一件事

08:27.130 --> 08:29.130
代码一行不动

08:29.130 --> 08:30.130
我一行不动的代码

08:30.130 --> 08:32.130
就是普通的GS代码

08:32.130 --> 08:34.130
我把这个文件的后罪名

08:34.130 --> 08:35.130
改一下

08:35.130 --> 08:37.130
改成TS

08:37.130 --> 08:39.130
改成TS

08:39.130 --> 08:41.130
我只做了一件事情

08:41.130 --> 08:42.130
什么事情其他事情

08:42.130 --> 08:43.130
我都没有做

08:43.130 --> 08:44.130
你看一下

08:44.130 --> 08:46.130
是不是错误就出来了

08:46.130 --> 08:47.130
他告诉你

08:47.130 --> 08:49.130
他找不到GS user name

08:49.130 --> 08:50.130
他说

08:50.130 --> 08:51.130
甚至他非常智能的说

08:51.130 --> 08:53.130
你是不是要用这个函数名

08:53.130 --> 08:55.130
是不是要用这个函数名

08:55.130 --> 08:56.130
快速修复

08:56.130 --> 08:58.130
将拼写改为GS user name

08:58.130 --> 09:00.130
你说舒不舒服

09:00.130 --> 09:02.130
然后你看这个辩量名

09:02.130 --> 09:05.130
他说找不到MI NEMA

09:05.130 --> 09:06.130
一写代码写到这的时候

09:06.130 --> 09:08.130
你不用等到运行

09:08.130 --> 09:09.130
不用等到运行

09:09.130 --> 09:11.130
马上更改错误

09:11.130 --> 09:12.130
MI name

09:12.130 --> 09:14.130
他提示你

09:14.130 --> 09:15.130
他说

09:15.130 --> 09:16.130
你这个MI name

09:16.130 --> 09:17.130
他提示咋

09:17.130 --> 09:18.130
他提示咋

09:18.130 --> 09:19.130
他说

09:19.130 --> 09:20.130
你现在这个MI name的类型

09:20.130 --> 09:22.130
它有可能是字无串

09:22.130 --> 09:24.130
有可能是number

09:24.130 --> 09:26.130
如果是一个number的话

09:26.130 --> 09:28.130
它不存在这个split

09:28.130 --> 09:29.130
这个函数

09:29.130 --> 09:31.130
这个函数是不存在的

09:31.130 --> 09:32.130
他通过这个提示

09:32.130 --> 09:33.130
是不是马上就明白了

09:33.130 --> 09:34.130
原来确实是这样子

09:34.130 --> 09:35.130
这个函数

09:35.130 --> 09:36.130
你看指着这个函数

09:36.130 --> 09:37.130
它反回的是

09:37.130 --> 09:38.130
要么反回一个字无串

09:38.130 --> 09:40.130
要么反回一个数字

09:40.130 --> 09:41.130
所以他马上就明白了

09:41.130 --> 09:42.130
原来这里

09:42.130 --> 09:44.130
我是要做一个判断

09:45.130 --> 09:46.130
对吧

09:48.130 --> 09:49.130
是不是等于咋了

09:49.130 --> 09:50.130
你看有提示

09:50.130 --> 09:52.130
这里都不需要你手东去输写

09:52.130 --> 09:53.130
是不是等于

09:53.130 --> 09:55.130
字无串呢

09:55.130 --> 09:57.130
如果是一个字无串的话

09:57.130 --> 09:58.130
我再来去做这个事情

09:58.130 --> 09:59.130
你看判断过后

09:59.130 --> 10:00.130
他这里就不爆错了

10:00.130 --> 10:01.130
他知道字无串里面

10:01.130 --> 10:02.130
有split函数

10:03.130 --> 10:04.130
然后这里又爆错了

10:04.130 --> 10:05.130
爆错好不好

10:05.130 --> 10:06.130
是不是好事

10:06.130 --> 10:08.130
包括实际上是好事

10:08.130 --> 10:10.130
不是说爆错不是好事

10:10.130 --> 10:12.130
你这些弹码早晚得爆错了

10:12.130 --> 10:13.130
你在

10:13.130 --> 10:14.130
GS里面

10:14.130 --> 10:15.130
是什么时候爆错

10:15.130 --> 10:16.130
是在运行的时候

10:16.130 --> 10:17.130
这些爆错了

10:17.130 --> 10:18.130
马上就爆错了

10:18.130 --> 10:19.130
那么马上让你修复错误

10:19.130 --> 10:21.130
避免埋下隐患

10:21.130 --> 10:22.130
然后这里

10:22.130 --> 10:23.130
他又在提示你

10:23.130 --> 10:25.130
你这个函数我确实找不到

10:25.130 --> 10:27.130
你是不是指着这个函数呢

10:27.130 --> 10:28.130
to uppercase

10:28.130 --> 10:29.130
OK

10:29.130 --> 10:30.130
我试确实试

10:30.130 --> 10:31.130
你说的太对了

10:31.130 --> 10:32.130
好下面又告诉你

10:32.130 --> 10:34.130
subsdream这个函数没有

10:34.130 --> 10:35.130
你是不是用了这个函数呢

10:35.130 --> 10:36.130
快速修复

10:36.130 --> 10:37.130
改为这个函数

10:37.130 --> 10:39.130
整个弹码

10:39.130 --> 10:40.130
现在是不是全部正确了

10:40.130 --> 10:42.130
当你想运行出来的时候

10:42.130 --> 10:44.130
还会不会存在刚才的问题

10:44.130 --> 10:45.130
就不会存在刚才的问题的

10:45.130 --> 10:46.130
明白了

10:46.130 --> 10:47.130
所以说

10:47.130 --> 10:49.130
TS你看我改动了啥呢

10:49.130 --> 10:50.130
我啥都没改动

10:50.130 --> 10:52.130
这里面我内行检查

10:52.130 --> 10:54.130
内行系统的指使一个没有用

10:54.130 --> 10:56.130
在这样的情况下

10:56.130 --> 10:59.130
他都比我们的GS代码

10:59.130 --> 11:01.130
就是纯粹的GS后维这个文件

11:01.130 --> 11:03.130
要好太多太多了

11:03.130 --> 11:05.130
都已经可以帮助我们

11:05.130 --> 11:07.130
减少很多很多的错误了

11:07.130 --> 11:09.130
所以说我实在想不通

11:09.130 --> 11:11.130
TS这个东西

11:11.130 --> 11:12.130
为什么不能用

11:12.130 --> 11:14.130
而且呢他本来是GS的超级

11:14.130 --> 11:16.130
GS能写的代码他都能写

11:16.130 --> 11:18.130
因此呢他兼容各种环境

11:18.130 --> 11:20.130
什么漏的环境

11:20.130 --> 11:21.130
浏览器环境

11:21.130 --> 11:23.130
加上兼容各种框架react

11:23.130 --> 11:25.130
什么angela

11:25.130 --> 11:26.130
什么vue

11:26.130 --> 11:27.130
当然angela全都是用TS

11:27.130 --> 11:29.130
他要强制要求你使用TS

11:29.130 --> 11:30.130
所以说

11:30.130 --> 11:32.130
以前GS能做的事情他都能做

11:32.130 --> 11:34.130
并且他加上了内行检查

11:34.130 --> 11:35.130
更加不容易犯出

11:35.130 --> 11:37.130
更加具有生产力

11:37.130 --> 11:39.130
所以说没有任何理由

11:40.130 --> 11:42.130
OK 这是这么一个体验

11:42.130 --> 11:43.130
可选的

11:43.130 --> 11:45.130
这里全是GS代码

11:45.130 --> 11:47.130
但是已经比之前的纯

11:47.130 --> 11:49.130
GS文件能够获得更多的优势了

11:50.130 --> 11:52.130
好 这是关于可选的

11:52.130 --> 11:54.130
下面是静态的

11:56.130 --> 11:57.130
静态的

11:57.130 --> 11:59.130
什么叫做静态的呢

11:59.130 --> 12:01.130
这涉及到TS代码

12:01.130 --> 12:03.130
它的执行过程

12:03.130 --> 12:04.130
就是你执行它的时候

12:04.130 --> 12:06.130
它要分为两步

12:06.130 --> 12:08.130
我们之前说GS代码

12:08.130 --> 12:09.130
是解释型的

12:09.130 --> 12:10.130
对吧

12:10.130 --> 12:11.130
它是直接把你的代码

12:11.130 --> 12:12.130
直接拿去运行

12:12.130 --> 12:14.130
但是TS不是不一样

12:14.130 --> 12:16.130
因为TS里面会增加一些

12:16.130 --> 12:18.130
特殊的语法来进行内行检查

12:18.130 --> 12:20.130
但是这里我没有增加

12:20.130 --> 12:21.130
特殊语法

12:21.130 --> 12:22.130
我这里随便写一个吧

12:22.130 --> 12:24.130
随便写一个

12:24.130 --> 12:26.130
比方说我这里写个帽号

12:26.130 --> 12:28.130
这是TS语法

12:28.130 --> 12:29.130
GS没有的

12:29.130 --> 12:32.130
我写stream on the phone

12:32.130 --> 12:34.130
打开解释一下吧

12:34.130 --> 12:36.130
不是on the phone

12:37.130 --> 12:38.130
打开解释一下

12:38.130 --> 12:39.130
什么意思呢

12:39.130 --> 12:41.130
表示的是标注一下

12:41.130 --> 12:43.130
这个函数它的返回内行

12:43.130 --> 12:44.130
要么是一个制服串

12:44.130 --> 12:46.130
要么是一个Lumber

12:46.130 --> 12:48.130
很符合逻辑吧

12:48.130 --> 12:49.130
也很好阅读

12:49.130 --> 12:50.130
很好理解

12:50.130 --> 12:52.130
这一块代码是TS代码

12:52.130 --> 12:54.130
GS里面有没有这个东西

12:54.130 --> 12:55.130
没有

12:55.130 --> 12:57.130
GS是没有这个东西的

12:57.130 --> 12:59.130
所以说呢

12:59.130 --> 13:00.130
你要直接执行这个代码

13:00.130 --> 13:02.130
是执行不了的

13:02.130 --> 13:03.130
直接执行这个代码

13:03.130 --> 13:04.130
是要爆错的

13:04.130 --> 13:05.130
我们看一下

13:05.130 --> 13:08.820
我们直接漏的去执行

13:08.820 --> 13:10.820
这个index.ts

13:10.820 --> 13:12.820
它说要爆错的

13:12.820 --> 13:14.820
它说无法识别这里的制服

13:14.820 --> 13:15.820
帽号这什么东西

13:15.820 --> 13:16.820
它不认识

13:16.820 --> 13:18.820
在浏览器环境里边

13:18.820 --> 13:20.820
在漏的环境里边

13:20.820 --> 13:21.820
它都有这个问题

13:21.820 --> 13:23.820
它无法直接识别TS代码

13:23.820 --> 13:25.820
这我们记一下

13:25.820 --> 13:31.140
无论是浏览器环境

13:31.140 --> 13:33.140
还是漏的环境

13:33.140 --> 13:37.140
无法直接识别TS代码

13:37.140 --> 13:39.140
所以说怎么办呢

13:39.140 --> 13:40.140
那么这种做法

13:40.140 --> 13:42.140
不是一地之间的

13:42.140 --> 13:47.140
以前你们在学习Bible的时候

13:47.140 --> 13:49.140
Bible做语法转换的

13:49.140 --> 13:51.140
它可以把ES-6的语法

13:51.140 --> 13:53.140
转换成ES-5的语法

13:53.140 --> 13:55.140
有些就版本浏览器

13:55.140 --> 13:57.140
它不能识别ES-6的语法

13:57.140 --> 13:58.140
怎么办

13:58.140 --> 13:59.140
用一个Bible

13:59.140 --> 14:04.140
把ES-6转换成ES-5

14:04.140 --> 14:06.140
那么在TS里面

14:06.140 --> 14:07.140
也是一样

14:07.140 --> 14:08.140
浏览器漏的

14:08.140 --> 14:10.140
它没办法识别TS代码

14:10.140 --> 14:12.140
所以说我们需要一个东西

14:12.140 --> 14:14.140
把它进行转换

14:14.140 --> 14:16.140
这个转换的东西是什么呢

14:16.140 --> 14:18.140
叫做TSC

14:18.140 --> 14:19.140
叫做TSC

14:19.140 --> 14:21.140
我们后边搭建环境的时候

14:21.140 --> 14:22.140
就会安装这个东西

14:22.140 --> 14:25.140
它可以把TS代码

14:25.140 --> 14:28.140
转换成ES

14:28.140 --> 14:30.140
转换成GS代码

14:30.140 --> 14:32.140
我们用ES代表示

14:32.140 --> 14:33.140
这个东西是什么呢

14:33.140 --> 14:34.140
实际上这个东西

14:34.140 --> 14:40.140
它叫做TS编译器

14:40.140 --> 14:42.140
它会去完成一次转换

14:42.140 --> 14:43.140
转换之后

14:43.140 --> 14:46.140
转换成普通的GS代码之后

14:46.140 --> 14:47.140
就可以运行了

14:47.140 --> 14:49.140
因为它是一个普通的GS代码

14:49.140 --> 14:51.140
进行转换

14:51.140 --> 14:52.140
我们来转换试一下吧

14:52.140 --> 14:54.140
这一刻是概述和体验

14:54.140 --> 14:56.140
我们来转换一下试一下

14:56.140 --> 14:58.140
因为我这里已经按到TSC了

14:58.140 --> 15:01.140
我们就直接转换TSC

15:01.140 --> 15:02.140
然后呢

15:02.140 --> 15:04.140
index.ts

15:06.140 --> 15:07.140
稍等片刻

15:07.140 --> 15:09.140
那么它就转换出来了

15:09.140 --> 15:10.140
这个GS的

15:10.140 --> 15:11.140
这个GS转换出来了

15:11.140 --> 15:12.140
过后你看

15:13.140 --> 15:14.140
刚才这个内形

15:14.140 --> 15:16.140
这里的内形约束就没了

15:16.140 --> 15:17.140
现在报处不用管

15:17.140 --> 15:18.140
我们后面会解释

15:19.140 --> 15:20.140
这里

15:20.140 --> 15:22.140
它的内形约束就没了

15:22.140 --> 15:23.140
因此

15:23.140 --> 15:24.140
所以说

15:24.140 --> 15:27.140
我们的TS用的是非常非常方便的

15:27.140 --> 15:29.140
我们只需要写好TS代码

15:29.140 --> 15:31.140
使用这个TSC来进行转换

15:31.140 --> 15:32.140
转换的介式

15:32.140 --> 15:34.140
就可以正常执行了

15:34.140 --> 15:36.140
什么叫做静态的

15:36.140 --> 15:37.140
静态的意思就是

15:37.140 --> 15:39.140
在运行之前

15:39.140 --> 15:41.140
在运行之前

15:41.140 --> 15:42.140
静态的含义就是

15:42.140 --> 15:44.140
在运行之前

15:44.140 --> 15:46.140
在运行之前干嘛呢

15:46.140 --> 15:48.140
在做这个转换

15:48.140 --> 15:50.140
在这个转换的过程中

15:50.140 --> 15:51.140
发现错误

15:51.140 --> 15:54.140
所以静态的含义就是

15:54.140 --> 15:56.140
静态的含义就是

15:56.140 --> 15:57.140
错误

15:57.140 --> 15:58.140
是

15:58.140 --> 15:59.140
就是内形检查

15:59.140 --> 16:01.140
应该说内形检查

16:01.140 --> 16:03.140
静态的内形检查

16:03.140 --> 16:04.140
上面

16:04.140 --> 16:06.140
静态的内形系统

16:06.140 --> 16:08.140
就是在做静态的内形检查

16:08.140 --> 16:11.140
内形检查发生的时间点

16:11.140 --> 16:14.640
发生的时间

16:14.640 --> 16:17.640
在边义的时候

16:17.640 --> 16:18.640
是在边义的时候

16:18.640 --> 16:20.640
而不是

16:20.640 --> 16:23.640
而非运行时

16:23.640 --> 16:25.640
而不是在运行的时候

16:25.640 --> 16:26.640
是在边义的时候

16:26.640 --> 16:28.640
进行内形检查的

16:28.640 --> 16:30.640
因此它的检查的时间点

16:30.640 --> 16:31.640
是非常提前的

16:31.640 --> 16:32.640
这就解决了

16:32.640 --> 16:33.640
我们之前说的

16:33.640 --> 16:35.640
GS这个解释型语言的问题

16:35.640 --> 16:36.640
它是直接把代码拿去运行的

16:36.640 --> 16:38.640
那么现在在运行之前

16:38.640 --> 16:39.640
有一个边义过程

16:39.640 --> 16:40.640
在边义的时候

16:40.640 --> 16:42.640
来进行内形检查

16:42.640 --> 16:44.640
因此咱们学习TS

16:44.640 --> 16:46.640
还要记住这么一个原则

16:46.640 --> 16:48.640
一旦你的代码运行出来了

16:48.640 --> 16:51.640
说明你在内形检

16:51.640 --> 16:52.640
你的内形检查

16:52.640 --> 16:53.640
已经通过了

16:53.640 --> 16:54.640
而运行的时候

16:54.640 --> 16:56.640
运行的是哪个代码

16:56.640 --> 16:58.640
运行的是GS代码

16:58.640 --> 17:00.640
而不是TS

17:00.640 --> 17:02.640
运行的是GS代码

17:02.640 --> 17:05.640
因此GS在运行的过程中

17:05.640 --> 17:07.640
发生了什么问题

17:07.640 --> 17:11.640
那么是无法用TS来解决的

17:11.640 --> 17:13.640
就是TS它是不拆运运行的

17:13.640 --> 17:14.640
这些内形检查

17:14.640 --> 17:16.640
它在运行过程中是失效的

17:16.640 --> 17:17.640
我们刚才就看到了

17:17.640 --> 17:19.640
边义出来的结果里边

17:19.640 --> 17:20.640
是没有这个东西的

17:20.640 --> 17:22.640
所以这个一定要理解清楚

17:22.640 --> 17:24.640
最好把记一下

17:24.640 --> 17:27.640
TS不参与

17:27.640 --> 17:32.640
任何运行时的内形检查

17:32.640 --> 17:33.640
它不参与的

17:33.640 --> 17:34.640
因为运行的时候

17:34.640 --> 17:35.640
已经是GS了

17:35.640 --> 17:36.640
它已经没有TS了

17:36.640 --> 17:39.640
把这个地方理解清楚

17:39.640 --> 17:42.640
这是关于TS这么一些特点

17:42.640 --> 17:44.640
它是一个介石的超级

17:44.640 --> 17:46.640
是一个可选的

17:46.640 --> 17:48.640
你可以用可以不用

17:48.640 --> 17:50.640
它的可选的静态的

17:50.640 --> 17:54.640
在运行之前进行内形检查

17:54.640 --> 17:58.640
都是关于TS最核心的一些特点

17:58.640 --> 17:59.640
OK

17:59.640 --> 18:01.640
我们了解了TS能做什么

18:01.640 --> 18:02.640
它怎么去解决

18:02.640 --> 18:03.640
这些问题的

18:03.640 --> 18:04.640
了解它的核心特点

18:04.640 --> 18:06.640
最后接下来

18:06.640 --> 18:07.640
我们了解一下

18:07.640 --> 18:12.640
关于TS的一些常识

18:12.640 --> 18:14.640
TS的常识

18:14.640 --> 18:18.640
就是它的历史 版本这些常识

18:18.640 --> 18:19.640
我们提几个点就行了

18:19.640 --> 18:23.640
它出现在2012年发布

18:23.640 --> 18:27.640
它是2012年发布的一个语言

18:27.640 --> 18:29.640
当时它是哪个公司发布的呢

18:29.640 --> 18:32.640
是微软公司

18:32.640 --> 18:33.640
当时是微软公司

18:33.640 --> 18:36.640
大家知道是一个全球很大的企业了

18:36.640 --> 18:38.640
它里边有很多很多的部门

18:38.640 --> 18:41.640
当时它里边是有一些外包

18:41.640 --> 18:43.640
微软它也做外包项目的

18:43.640 --> 18:45.640
就是别的公司

18:45.640 --> 18:46.640
它需要做一些项目

18:46.640 --> 18:47.640
或者政府部门

18:47.640 --> 18:48.640
或者是银行里边

18:48.640 --> 18:50.640
要做一些项目的时候

18:50.640 --> 18:52.640
微软可能会去竞标

18:52.640 --> 18:53.640
可以去接着一些项目

18:53.640 --> 18:55.640
拿到这些项目的时候

18:55.640 --> 18:56.640
有一些前端的项目

18:56.640 --> 18:58.640
可能比较复杂

18:58.640 --> 19:00.640
它当时用介石语言书写起来

19:00.640 --> 19:01.640
就非常非常地痛苦

19:01.640 --> 19:02.640
因为经常会出问题

19:02.640 --> 19:04.640
大量的时间耗费在了

19:04.640 --> 19:06.640
条错上面

19:06.640 --> 19:07.640
于是呢

19:07.640 --> 19:10.640
他们公司内部就打算

19:10.640 --> 19:12.640
去开发一套新的语言出来

19:12.640 --> 19:14.640
这套语言要能够完全

19:14.640 --> 19:16.640
当时定位的时候就是定位了

19:16.640 --> 19:19.640
这个语言要能够完全的兼容解释

19:19.640 --> 19:21.640
并且要解决那些

19:21.640 --> 19:23.640
凡人的类型问题

19:23.640 --> 19:24.640
所以说

19:24.640 --> 19:26.640
他们内部开始确定一个项目

19:26.640 --> 19:27.640
来开发这个语言

19:27.640 --> 19:29.640
那么谁来负责呢

19:29.640 --> 19:32.640
是一个人叫做Anders

19:32.640 --> 19:33.640
我们可以看一下

19:33.640 --> 19:37.620
这是个老头

19:37.620 --> 19:39.620
可以看一下这个人

19:39.620 --> 19:41.620
Anders

19:41.620 --> 19:42.620
就这个

19:42.620 --> 19:45.620
Anders Helsingberg

19:45.620 --> 19:47.620
Anders Helsingberg

19:47.620 --> 19:48.620
就这个人

19:48.620 --> 19:50.620
就这个老头

19:50.620 --> 19:53.620
他来负责

19:53.620 --> 19:57.620
负责开发TES这个项目

19:57.620 --> 19:59.620
那么在内部完成之后

19:59.620 --> 20:00.620
最后决定

20:00.620 --> 20:02.620
把这个项目公开出来

20:02.620 --> 20:03.620
开源

20:03.620 --> 20:04.620
开源

20:04.620 --> 20:06.620
开源出来

20:06.620 --> 20:07.620
然后呢

20:07.620 --> 20:09.620
共所有的全世界所有的

20:09.620 --> 20:11.620
开发者都可以去使用

20:11.620 --> 20:12.620
是2012年发布的

20:12.620 --> 20:13.620
那么大家回忆一下

20:13.620 --> 20:14.620
2012年

20:14.620 --> 20:16.620
我们ES-6

20:16.620 --> 20:18.620
出现的时间点是多少

20:18.620 --> 20:20.620
ES-6的出现的时间

20:20.620 --> 20:22.620
我们说ES-6

20:22.620 --> 20:24.620
ES-6这个版本呢

20:24.620 --> 20:26.620
它的正确叫法叫做

20:26.620 --> 20:28.620
ES-2015

20:28.620 --> 20:30.620
因为在ES-6出来的时候

20:30.620 --> 20:31.620
官方就已经说了

20:31.620 --> 20:32.620
后边的版本号

20:32.620 --> 20:34.620
全用年份来作为版本号

20:34.620 --> 20:36.620
它每年都会有一个提案出来

20:36.620 --> 20:37.620
因此我们习惯上

20:37.620 --> 20:38.620
叫ES-6

20:38.620 --> 20:39.620
实际上它的正确叫法

20:39.620 --> 20:40.620
叫ES-2015

20:40.620 --> 20:42.620
它是2015年

20:42.620 --> 20:43.620
出现的

20:43.620 --> 20:45.620
因此2012年这个时候

20:45.620 --> 20:46.620
还没有ES-6

20:46.620 --> 20:48.620
那个时候还没有模块化

20:48.620 --> 20:50.620
还没有内彩关键制

20:50.620 --> 20:51.620
还没有const

20:51.620 --> 20:53.620
还没有这些东西的时候

20:53.620 --> 20:54.620
那么那个时候

20:54.620 --> 20:55.620
你想一想

20:55.620 --> 20:56.620
JS开发者的多劳火

20:56.620 --> 20:57.620
多痛苦

20:57.620 --> 20:59.620
所以说微软

20:59.620 --> 21:01.620
他们让Anders Hassenberg

21:01.620 --> 21:03.620
来负责这个TS项目

21:03.620 --> 21:04.620
那么最终完成之后

21:04.620 --> 21:06.620
2012年发布了

21:06.620 --> 21:07.620
这个项目是开源的

21:07.620 --> 21:08.620
在github上面

21:08.620 --> 21:09.620
可以找到它的元代嘛

21:09.620 --> 21:10.620
并且呢

21:11.620 --> 21:13.620
它是拥抱标准的

21:13.620 --> 21:14.620
什么意思

21:14.620 --> 21:15.620
拥抱的是什么标准

21:15.620 --> 21:17.620
拥抱的是ES标准

21:17.620 --> 21:18.620
就是说

21:18.620 --> 21:20.620
如果以后ES标准发生了变化

21:20.620 --> 21:21.620
发现跟他的语法

21:21.620 --> 21:23.620
跟ES标准的语法不匹配了

21:23.620 --> 21:25.620
他会更改他的语法

21:25.620 --> 21:28.620
来适应新的ES标准

21:28.620 --> 21:29.620
对于微软来说

21:29.620 --> 21:30.620
这是很难得的

21:30.620 --> 21:31.620
因为一直以来

21:31.620 --> 21:32.620
微软一直是以行业

21:32.620 --> 21:34.620
老大哥的身份

21:34.620 --> 21:35.620
行业老大哥的身份

21:35.620 --> 21:37.620
来就是

21:37.620 --> 21:39.620
规定制定行业标准

21:39.620 --> 21:40.620
应该是什么样

21:40.620 --> 21:41.620
应该是什么样

21:41.620 --> 21:42.620
我说了算

21:42.620 --> 21:43.620
所以说呢

21:43.620 --> 21:45.620
它有这样子一种开放的心态

21:45.620 --> 21:46.620
实际上是非常难得的

21:46.620 --> 21:47.620
最近这几年

21:47.620 --> 21:49.620
微软出了确实不少的好东西

21:49.620 --> 21:50.620
像vscode

21:50.620 --> 21:52.620
像ts都是非常好的东西

21:53.620 --> 21:55.620
好 这是关于ts的一些厂市

21:55.620 --> 21:57.620
目前的版本

21:58.620 --> 22:00.620
目前的版本是3.4

22:00.620 --> 22:01.620
目前的版本3.4

22:01.620 --> 22:03.620
就是我们讲视频这一块的时候

22:03.620 --> 22:04.620
版本是3.4

22:04.620 --> 22:06.620
它的官方网站

22:06.620 --> 22:07.620
官网

22:07.620 --> 22:08.620
看一下

22:08.620 --> 22:10.620
官网地址是这里

22:12.620 --> 22:14.620
TypeScript.org

22:14.620 --> 22:16.620
把它复制一下

22:16.620 --> 22:17.620
就这个地址

22:17.620 --> 22:19.620
TypeScript.log

22:19.620 --> 22:20.620
这个是log的意思

22:20.620 --> 22:21.620
点org

22:21.620 --> 22:23.620
那么这个官网里边

22:23.620 --> 22:24.620
它有它最新的

22:24.620 --> 22:26.620
最全的文档说明

22:26.620 --> 22:27.620
点这个document

22:27.620 --> 22:28.620
下边

22:28.620 --> 22:29.620
这边

22:29.620 --> 22:30.620
这个handbook

22:30.620 --> 22:31.620
就是手册

22:31.620 --> 22:32.620
手册里面

22:32.620 --> 22:34.620
就可以看到它所有的说明

22:34.620 --> 22:36.620
这里是全英文的

22:36.620 --> 22:37.620
有些朋友觉得很牢火

22:37.620 --> 22:38.620
牢火的话

22:38.620 --> 22:40.620
它有个中文的网站

22:40.620 --> 22:42.620
一个中文的网站

22:42.620 --> 22:46.620
叫做ts.cn

22:46.620 --> 22:47.620
这个网站

22:47.620 --> 22:48.620
这个网站是中文的

22:48.620 --> 22:49.620
不过这个网站

22:49.620 --> 22:51.620
它的版本有点滋后

22:51.620 --> 22:54.620
好像翻线的翻译到了3.1版本

22:54.620 --> 22:55.620
这就说一下吧

22:55.620 --> 22:56.620
它有个中文网

22:56.620 --> 22:59.990
中文网

22:59.990 --> 23:00.990
这个中文网

23:00.990 --> 23:02.990
它翻线的翻译到了3.1版本

23:02.990 --> 23:03.990
版本有点滋后

23:03.990 --> 23:04.990
但是它要先进来清楚

23:04.990 --> 23:06.990
这是个人做的

23:06.990 --> 23:08.990
这是个人翻译的

23:08.990 --> 23:10.990
不是官方翻译

23:10.990 --> 23:11.990
不是官方翻译

23:11.990 --> 23:12.990
是个人翻译的

23:12.990 --> 23:13.990
现在这个网站里面

23:13.990 --> 23:14.990
还有一些广告

23:14.990 --> 23:15.990
这个网站

23:15.990 --> 23:16.990
我去看了一下

23:16.990 --> 23:17.990
它的文档看了一下

23:17.990 --> 23:19.990
有一些地方有翻译的错误

23:19.990 --> 23:21.990
所以说我建议

23:21.990 --> 23:22.990
英文

23:22.990 --> 23:24.990
过关的同学尽量的去看

23:24.990 --> 23:25.990
英文文档

23:25.990 --> 23:26.990
这是最准确

23:26.990 --> 23:28.990
最新的文档

23:28.990 --> 23:29.990
如果你看

23:29.990 --> 23:31.990
因为确实确实太牢火

23:31.990 --> 23:32.990
太慢了

23:32.990 --> 23:34.990
而你有没有那么多时间的话

23:34.990 --> 23:36.990
可以去看一下这个中文网

23:36.990 --> 23:39.990
90%以上都没什么错误

23:39.990 --> 23:41.990
但是有这个地方是有错误的

23:41.990 --> 23:43.990
我大概看了一下没看完

23:43.990 --> 23:44.990
这是关于

23:44.990 --> 23:46.990
TS的一些尝试

23:46.990 --> 23:48.990
这里刚才我

23:48.990 --> 23:50.990
还有一个点

23:50.990 --> 23:52.990
我要补充一下

23:52.990 --> 23:55.990
就是使用了TS

23:55.990 --> 23:57.990
当你使用了一段时间之后

23:57.990 --> 23:59.990
你会发现一个现象

23:59.990 --> 24:04.560
我把这一部分叫做

24:04.560 --> 24:09.380
额外的惊喜

24:09.380 --> 24:11.380
TS它本身的定位

24:11.380 --> 24:14.380
它的定位就是一个类型检查系统

24:14.380 --> 24:16.380
它里边学习的所有的知识

24:16.380 --> 24:19.380
都是跟类型检查相关的

24:19.380 --> 24:21.380
那么我们在使用

24:21.380 --> 24:22.380
它的类型检查的时候

24:22.380 --> 24:24.380
目的本来只是单纯的

24:24.380 --> 24:27.380
来检查那些介石里边

24:27.380 --> 24:28.380
发现不了的

24:28.380 --> 24:30.380
很难发现的一些错误

24:30.380 --> 24:31.380
希望它在编译期间

24:31.380 --> 24:33.380
不要等到运行的时候

24:33.380 --> 24:35.380
尽快的提示我们这里有错误

24:35.380 --> 24:38.380
减少我们的开发中的营严化

24:38.380 --> 24:39.380
而降低

24:39.380 --> 24:42.380
同时减少我们的开发时间

24:42.380 --> 24:43.380
调试时间

24:43.380 --> 24:45.380
可以缩短项目的成本

24:45.380 --> 24:46.380
我们的目的本来

24:46.380 --> 24:47.380
是很单纯的

24:47.380 --> 24:48.380
是这样子的

24:48.380 --> 24:49.380
这样子其实已经非常不错了

24:49.380 --> 24:52.380
缩减时间就已经是很了不起了

24:52.380 --> 24:53.380
那么我们会

24:53.380 --> 24:54.380
但是我们会从中

24:54.380 --> 24:56.380
获得一些额外的惊喜

24:56.380 --> 24:59.380
当我们发现有了类型检查之后

24:59.380 --> 25:02.380
有了类型检查之后

25:02.380 --> 25:04.380
它增强了一个东西

25:04.380 --> 25:05.380
它就增强了

25:05.380 --> 25:07.380
无形中增强了

25:07.380 --> 25:11.380
面向对象的开发

25:11.380 --> 25:12.380
这什么意思呢

25:12.380 --> 25:14.380
面向对象大家有可能

25:14.380 --> 25:15.380
应该都听说过吧

25:15.380 --> 25:17.380
都听说过就是类就是对象

25:17.380 --> 25:18.380
对吧

25:18.380 --> 25:19.380
我们写介石的时候

25:19.380 --> 25:20.380
有没有类

25:20.380 --> 25:21.380
有没有对象

25:21.380 --> 25:23.380
介石中也有类和对象

25:23.380 --> 25:24.380
对吧

25:24.380 --> 25:30.380
介石中也有类和对象

25:30.380 --> 25:31.380
这两个东西都有

25:31.380 --> 25:33.380
我们写react的时候

25:33.380 --> 25:35.380
类组件

25:35.380 --> 25:36.380
已经我们写了一个类

25:36.380 --> 25:37.380
创演它的对象

25:37.380 --> 25:39.380
或者是我们直接用两个大括号

25:39.380 --> 25:41.380
写一个字面两个对象

25:41.380 --> 25:43.380
介石里面也有类和对象

25:43.380 --> 25:45.380
所以说介石本身

25:45.380 --> 25:49.380
也支持面向对象开发

25:49.380 --> 25:55.380
但是由于介石缺少了类型检查

25:55.380 --> 25:57.380
它的面向对象开发

25:57.380 --> 25:59.380
是会遇到很多问题的

25:59.380 --> 26:00.380
它不是说不能开发

26:00.380 --> 26:01.380
不是说不能

26:01.380 --> 26:03.380
它是会遇到很多问题的

26:03.380 --> 26:05.380
那么这些问题我就不展开讲了

26:05.380 --> 26:06.380
你现在知道

26:06.380 --> 26:07.380
它会遇到很多问题就行了

26:07.380 --> 26:09.380
其实像我们使用介石

26:09.380 --> 26:11.380
有多少时间我问大家

26:11.380 --> 26:13.380
有多少时间你们会自己去写一个类

26:13.380 --> 26:16.380
除了react之外

26:16.380 --> 26:18.380
react没办法吗

26:18.380 --> 26:20.380
他要求你写一个类

26:20.380 --> 26:22.380
除了在写react组件的时候

26:22.380 --> 26:23.380
你会写类

26:23.380 --> 26:25.380
其他的时候你会不会写类

26:25.380 --> 26:27.380
我觉得应该是很少

26:27.380 --> 26:28.380
应该是很少

26:28.380 --> 26:29.380
你直接就有函数搞定了

26:29.380 --> 26:30.380
对吧

26:30.380 --> 26:32.380
什么事情写一个函数导出来

26:32.380 --> 26:33.380
或者是我写两个大块号

26:33.380 --> 26:35.380
大块号里面去写一些函数

26:35.380 --> 26:36.380
导出一个对象

26:36.380 --> 26:38.380
你很少去写类

26:38.380 --> 26:40.380
因为我们在使用介石开发的时候

26:40.380 --> 26:42.380
很少使用面向对象的方式

26:42.380 --> 26:44.380
来进行开发

26:44.380 --> 26:45.380
面向对象是什么

26:45.380 --> 26:47.380
是一种思维模式

26:47.380 --> 26:48.380
它告诉你

26:48.380 --> 26:50.380
你要完成一个功能

26:50.380 --> 26:52.380
应该用一种什么样的思维方式

26:52.380 --> 26:54.380
作为切入点

26:54.380 --> 26:56.380
来进行分析

26:56.380 --> 26:58.380
它讲究的是一种思维模式

26:58.380 --> 26:59.380
而不是具体的代码

26:59.380 --> 27:01.380
使用介石原理的时候

27:01.380 --> 27:04.380
我们很少使用这种思维模式

27:04.380 --> 27:07.380
一方面是作为前端开发

27:07.380 --> 27:09.380
前端开发人员

27:09.380 --> 27:11.380
不太习惯使用面向对象的思维模式

27:11.380 --> 27:12.380
第二种

27:12.380 --> 27:14.380
不喜欢的根本原因

27:14.380 --> 27:17.380
是因为介石虽然支持面向对象

27:17.380 --> 27:18.380
但是

27:18.380 --> 27:20.380
它没有类型检查

27:20.380 --> 27:22.380
很多面向对象里面的

27:22.380 --> 27:24.380
很多东西它玩不转

27:24.380 --> 27:27.380
而现在有了类型检查

27:27.380 --> 27:30.380
它就增强了面向对象的开发

27:30.380 --> 27:34.380
介石没有类型检查

27:34.380 --> 27:40.380
很多面向对象的场景

27:40.380 --> 27:42.380
实现起来

27:42.380 --> 27:43.380
有诸多问题

27:43.380 --> 27:45.380
应该这样说

27:45.380 --> 27:47.380
但是现在有了类型检查过后

27:47.380 --> 27:49.380
有了类型检查过后

27:49.380 --> 27:51.380
它增强了面向对象的开发

27:51.380 --> 27:55.380
现在使用了TS后

27:55.380 --> 27:57.380
使用TS后

27:57.380 --> 28:01.380
可以编写出

28:01.380 --> 28:05.380
完善的面向对象代码

28:05.380 --> 28:06.380
对象代码

28:06.380 --> 28:07.380
因为我们知道

28:07.380 --> 28:10.380
面向对象是一个很古老的思想了

28:10.380 --> 28:12.380
20多年前 30多年前了

28:12.380 --> 28:14.380
是一种很古老的思想了

28:14.380 --> 28:18.380
这种思想经过了这么多年的沉淀

28:18.380 --> 28:20.380
它已经形成了在某些场景下

28:20.380 --> 28:24.380
比如说我要完成一个全线管理

28:24.380 --> 28:26.380
我要完成某一些功能的时候

28:26.380 --> 28:29.380
它已经形成了一些成熟的解决方案

28:29.380 --> 28:31.380
有些成熟的模式可以用

28:31.380 --> 28:33.380
但是由于介石以前没有类型检查

28:33.380 --> 28:35.380
这些模式它玩不转

28:35.380 --> 28:37.380
我现在有很多问题

28:37.380 --> 28:39.380
但是现在有了类型检查之后

28:39.380 --> 28:42.380
那么这些东西统统可以使用了

28:42.380 --> 28:45.380
但是现在有了类型检查之后

28:45.380 --> 28:48.380
那么这些东西统统可以使用了

28:48.380 --> 28:50.380
统统可以使用了

28:50.380 --> 28:53.380
所以说这是我们TS给大家大家的额外惊喜

28:53.380 --> 28:57.380
当然本门客我们不会涉及到

28:57.380 --> 28:59.380
可能会涉及到一点点一丢丢

28:59.380 --> 29:02.380
不会涉及到太多的关于面向对象的东西

29:02.380 --> 29:05.380
因为那是一套思想讲起来的不太容易

29:05.380 --> 29:07.380
你们可能觉得挺甜薯一样

29:07.380 --> 29:08.380
不过没关系

29:08.380 --> 29:12.380
我们就使用它的关于对错误的检查

29:12.380 --> 29:14.380
就已经非常非常不错了

29:14.380 --> 29:18.380
大幅度降低我们的调时时间

29:18.380 --> 29:19.380
OK

29:19.380 --> 29:21.380
这里我们这里就讲解了一下

29:21.380 --> 29:24.380
关于TS的概述

29:24.380 --> 29:26.380
它是如何来解决问题的

29:26.380 --> 29:28.380
我们介石开发中遇到了什么问题

29:28.380 --> 29:30.380
那么它又是如何来解决的

29:30.380 --> 29:32.380
好了那么这节课就到这里了

29:32.380 --> 29:33.380
那么下节课呢

29:33.380 --> 29:36.380
就开始来搭建TS的开发环境了

29:36.380 --> 29:39.380
来具体的学习TS如何去完成开发

29:39.380 --> 29:40.380
OK

29:40.380 --> 29:41.380
这一课就到这里了

29:41.380 --> 29:42.380
拜拜

