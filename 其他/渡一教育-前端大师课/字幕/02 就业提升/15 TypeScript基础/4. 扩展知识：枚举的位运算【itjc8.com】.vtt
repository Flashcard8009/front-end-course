WEBVTT

00:00.620 --> 00:04.620
OK 这里呢 我给大家补充一个扩展姿势

00:04.620 --> 00:07.620
这一个部分 给大家补充一个扩展姿势

00:07.620 --> 00:10.620
这个姿势你不学的话 不影响后边的学习

00:10.620 --> 00:14.620
那你知道之后呢 你可以对自己的姿势面做一个扩展

00:14.620 --> 00:16.620
以后呢 遇到了类似的场景呢

00:16.620 --> 00:19.620
你可以用一种非常优雅的方式进行处理

00:19.620 --> 00:24.620
就是未美举 或者叫做美举的未运算

00:24.620 --> 00:26.620
美举的未运算

00:26.620 --> 00:28.620
这个主要是针对的是什么呢

00:28.620 --> 00:30.620
针对的数字美举

00:30.620 --> 00:34.620
就是不是支付串 支付串没法玩这个东西

00:34.620 --> 00:35.620
只能是数字美举

00:35.620 --> 00:38.620
是什么意思呢 是这么一种场景

00:38.620 --> 00:41.620
给大家举个例子 比方说这里有一个美举

00:41.620 --> 00:45.620
这个美举呢 我们把它叫做permission

00:45.620 --> 00:50.620
权限 可能是对一个文件有什么样的操作权限

00:50.620 --> 00:53.620
对一个资源有什么样的操作权限

00:53.620 --> 00:56.620
我们这里呢 使用数字美举来进行约束

00:56.620 --> 00:59.620
权限它总有一些固定的曲子 对吧

00:59.620 --> 01:01.620
它不能超出一定的范围

01:01.620 --> 01:03.620
因此呢 我们认为对一个资源

01:03.620 --> 01:05.620
可能会有这么一些权限

01:05.620 --> 01:07.620
可读的 red

01:07.620 --> 01:10.620
可写的 right

01:10.620 --> 01:13.620
可以创建一个资源的权限 create

01:13.620 --> 01:17.620
可以删除一个资源的权限 delete

01:17.620 --> 01:21.620
OK 我们认为权限呢 分为这么四种

01:21.620 --> 01:25.620
这样子写呢 其实就已经把这个美举写好了

01:25.620 --> 01:28.620
但是呢 现在有一个问题 什么问题呢

01:28.620 --> 01:33.620
就是有的时候呢 我们需要对这些权限进行组合

01:33.620 --> 01:36.620
比方说 对某一个资源 对这个文件吧

01:36.620 --> 01:39.620
对这个文件呢 我可以删除它

01:39.620 --> 01:42.620
我也可以改写它

01:42.620 --> 01:45.620
但是呢 我不能去创建一个新文件

01:45.620 --> 01:47.620
比方说 举个例子

01:47.620 --> 01:50.620
再比方说 对某一个资源 我可以读它

01:50.620 --> 01:52.620
并且呢 可以改它

01:52.620 --> 01:55.620
可以重新写 就是 right

01:55.620 --> 01:57.620
可以修改权限 可以改它

01:57.620 --> 01:59.620
但是呢 我不能删除它

01:59.620 --> 02:01.620
比方说 我有这么一些基本权限

02:01.620 --> 02:05.620
这些基本权限 可以组合成为新的权限

02:05.620 --> 02:08.620
那么我们如何才能完成组合呢

02:08.620 --> 02:11.620
当然我们可以一次把这个组合的权限也写到下边

02:11.620 --> 02:15.620
比方说 red and right

02:15.620 --> 02:17.620
对吧 可以读 可以写

02:17.620 --> 02:21.620
也可以写成 red and right

02:22.620 --> 02:23.620
懂我意思吧

02:23.620 --> 02:26.620
然后还可以写成 我不写了

02:26.620 --> 02:28.620
我不想写了 你没想写吗

02:28.620 --> 02:31.620
这个组合写有多少种 有多少种

02:31.620 --> 02:34.620
四个 四个进行组合有多少种

02:34.620 --> 02:36.620
是不是A44 对吧

02:36.620 --> 02:38.620
A44 咱们数学排列组合的知识

02:38.620 --> 02:40.620
那么这个数量是非常大的

02:40.620 --> 02:43.620
因此呢 如果我们直接输写在这儿的话

02:43.620 --> 02:45.620
会非常非常的不方便

02:45.620 --> 02:47.620
而且呢 将来我如果删了一个字段

02:47.620 --> 02:49.620
或者是加了两三个字段

02:49.620 --> 02:51.620
那么组合写就更多了

02:51.620 --> 02:53.620
那这个时候怎么处理呢

02:53.620 --> 02:57.620
这里我们可以使用一种非常非常巧妙的处理办法

02:57.620 --> 02:58.620
可以这样做

02:58.620 --> 03:01.620
我们先把 red 复制为1

03:01.620 --> 03:04.620
把 right 呢 复制为2

03:04.620 --> 03:07.620
把 create 呢 复制为4

03:07.620 --> 03:09.620
把 delete 复制为8

03:09.620 --> 03:12.620
大家看一下这些数字有什么样的特点

03:12.620 --> 03:14.620
它们有什么样的特点

03:14.620 --> 03:15.620
什么样的特点

03:15.620 --> 03:18.620
好像是后边这个是前面这个的两倍对吧

03:18.620 --> 03:20.620
我们换句话说

03:20.620 --> 03:24.620
它是二的零次方

03:24.620 --> 03:26.620
这个呢 是二的

03:26.620 --> 03:27.620
多少次方啊

03:27.620 --> 03:29.620
一次方

03:29.620 --> 03:32.620
这个呢 是二的 二次方

03:32.620 --> 03:35.620
这个呢 是二的 三次方

03:35.620 --> 03:37.620
能发现规律吗

03:37.620 --> 03:40.620
它们全是二的 n 次方

03:40.620 --> 03:43.620
那么如果是遇到这么一种数字

03:43.620 --> 03:45.620
你马上就应该反映过来

03:45.620 --> 03:47.620
换成二净字的话

03:47.620 --> 03:50.620
它们在其中的一位是一

03:50.620 --> 03:52.620
其他的位置全是零

03:52.620 --> 03:54.620
如果某一个数字它满足这样的特点

03:54.620 --> 03:56.620
它二净字一定是这样子

03:56.620 --> 03:58.620
那么它的二净字是什么呢

03:58.620 --> 04:01.620
我们都知道二净字就是由零一组成的数字

04:01.620 --> 04:04.620
一的二净字是零零零一

04:04.620 --> 04:08.620
二的二净字呢 是零零一零

04:08.620 --> 04:11.620
四的二净字呢 是零一零零

04:11.620 --> 04:14.620
八的二净字是零零零

04:14.620 --> 04:16.620
大家发现没有

04:16.620 --> 04:18.620
它们的二净字上面

04:18.620 --> 04:20.620
通过这个一

04:20.620 --> 04:22.620
通过二净字的某个位置上

04:22.620 --> 04:26.620
是否有一来标志着它是否有这个权限

04:26.620 --> 04:28.620
比方说这个位置上有一

04:28.620 --> 04:30.620
说明你可读的权限

04:30.620 --> 04:31.620
这个位置上有一

04:31.620 --> 04:33.620
说明你有可写的权限

04:33.620 --> 04:37.620
这个位置上有一表示你有创建权限

04:37.620 --> 04:40.620
这个位置上有一表示你有删除权限

04:40.620 --> 04:41.620
我们可以通过这样的

04:41.620 --> 04:43.620
二净字位上的标识

04:43.620 --> 04:46.620
来标示它的权限位

04:46.620 --> 04:49.620
那比方说我有这么一个数字

04:49.620 --> 04:51.620
这个数字不管是多少吧

04:51.620 --> 04:54.620
比方说三吧 比方说三这个数字

04:54.620 --> 04:56.620
三这个数字换算成二净字

04:56.620 --> 04:59.620
应该是多少 零零一一

04:59.620 --> 05:01.620
对不对 零零一一

05:01.620 --> 05:03.620
那么你觉得这个

05:03.620 --> 05:04.620
应该有什么样的权限呢

05:04.620 --> 05:06.620
对应这里的权限标

05:06.620 --> 05:08.620
应该有什么样的权限

05:08.620 --> 05:11.620
说是可读的又可写的

05:11.620 --> 05:13.620
对吧 就可以有这么两个权限

05:13.620 --> 05:18.620
因此我们可以通过这些基本权限

05:18.620 --> 05:21.620
来组合成为一种新的权限

05:21.620 --> 05:24.620
怎么来进行组合呢

05:24.620 --> 05:27.620
我们一个个说

05:27.620 --> 05:31.620
第一个 如何组合权限

05:31.620 --> 05:33.620
如何组合权限

05:33.620 --> 05:34.620
如何组合呢

05:34.620 --> 05:37.620
比方说我要组合可读的权限

05:37.620 --> 05:39.620
和可写的权限

05:39.620 --> 05:40.620
组合这两个权限

05:40.620 --> 05:42.620
我应该怎么来写代码呢

05:42.620 --> 05:44.620
非常简单 这么写

05:44.620 --> 05:48.620
比方说P 这个辨量

05:48.620 --> 05:51.620
然后通过Permission.read

05:51.620 --> 05:53.620
你不是可读的权限吗

05:53.620 --> 05:57.620
然后加一个速限

05:57.620 --> 05:58.620
然后Permission

05:58.620 --> 06:00.620
我先写了再解释

06:00.620 --> 06:01.620
Write

06:01.620 --> 06:03.620
这就是权限的组合

06:03.620 --> 06:06.620
把可读的权限跟可写的权限

06:06.620 --> 06:08.620
两者进行组合

06:08.620 --> 06:10.620
中间这个东西是啥呢

06:10.620 --> 06:11.620
注意啊

06:11.620 --> 06:12.620
中间这个东西

06:12.620 --> 06:15.620
不是我们之前学TS的联合类型

06:15.620 --> 06:17.620
这里写的是不是类型

06:17.620 --> 06:18.620
是不是类型

06:18.620 --> 06:19.620
不是哦

06:19.620 --> 06:21.620
这里写的是具体的纸

06:21.620 --> 06:23.620
写的是具体的纸

06:23.620 --> 06:24.620
它是要参与运行的

06:24.620 --> 06:26.620
我们之前的联合类型

06:26.620 --> 06:27.620
是写到哪儿的

06:27.620 --> 06:28.620
是写到这里的对吧

06:28.620 --> 06:30.620
冒号后表才写的是类型

06:30.620 --> 06:31.620
是写到这个位置的

06:31.620 --> 06:33.620
这个位置写的是联合类型

06:33.620 --> 06:35.620
而这里是要参与执行的

06:35.620 --> 06:37.620
这个速限不是联合类型

06:37.620 --> 06:39.620
这个速限是啥呢

06:39.620 --> 06:41.620
这个速限叫做未运算

06:41.620 --> 06:46.940
这个地方使用未运算

06:46.940 --> 06:47.940
未运算

06:47.940 --> 06:49.940
这个是什么未运算的

06:49.940 --> 06:50.940
未运算有很多种

06:50.940 --> 06:51.940
什么叫做未运算

06:51.940 --> 06:53.940
我们把记一个笔记吧

06:53.940 --> 06:55.940
什么叫做未运算

06:55.940 --> 06:57.940
未运算指的是

06:57.940 --> 06:59.940
两个数字

06:59.940 --> 07:01.940
换算成

07:01.940 --> 07:04.940
换算成二进字后

07:04.940 --> 07:07.940
进行的运算

07:08.940 --> 07:09.940
它是指的是

07:09.940 --> 07:11.940
把两个数字换算成二进字后

07:11.940 --> 07:13.940
按照二进字的每一位

07:13.940 --> 07:14.940
来进行的运算

07:14.940 --> 07:15.940
叫做未运算

07:15.940 --> 07:17.940
未运算有很多种

07:17.940 --> 07:19.940
这个是其中一种

07:19.940 --> 07:24.940
这个运算叫做或运算

07:24.940 --> 07:26.940
它是未运算中的一种

07:26.940 --> 07:28.940
或运算的规则是什么呢

07:28.940 --> 07:29.940
指的是

07:29.940 --> 07:31.940
把两个数字来进行比较

07:31.940 --> 07:33.940
他们的二进字来进行比较

07:33.940 --> 07:35.940
第一个数字

07:35.940 --> 07:36.940
可读的

07:36.940 --> 07:37.940
那么数字是多少

07:37.940 --> 07:38.940
一

07:38.940 --> 07:39.940
二进字是多少

07:39.940 --> 07:41.940
零零零一

07:41.940 --> 07:42.940
好

07:42.940 --> 07:43.940
第二个数字是多少

07:43.940 --> 07:45.940
写对吧

07:45.940 --> 07:47.940
那么就是零零一零

07:47.940 --> 07:48.940
这是两个数字

07:48.940 --> 07:49.940
换算成为的

07:49.940 --> 07:50.940
二进字

07:50.940 --> 07:51.940
可读

07:51.940 --> 07:53.940
然后这两个数字呢

07:53.940 --> 07:54.940
使用什么

07:54.940 --> 07:55.940
或运算

07:55.940 --> 07:56.940
什么叫做或运算

07:56.940 --> 07:58.940
就是把两个数字

07:58.940 --> 08:01.940
来进行每一位一次比较

08:01.940 --> 08:03.940
每一位一位一位的进行比较

08:03.940 --> 08:05.940
如果

08:05.940 --> 08:07.940
有一位是一

08:07.940 --> 08:08.940
结果就是一

08:08.940 --> 08:10.940
否则的话就是零

08:10.940 --> 08:12.940
你可以把一想象成真

08:12.940 --> 08:13.940
零想象成假

08:13.940 --> 08:14.940
那么

08:14.940 --> 08:16.940
两个之间进行或者运算

08:16.940 --> 08:18.940
只要有一个为真

08:18.940 --> 08:19.940
那么就为真

08:19.940 --> 08:20.940
这样子想就明白了

08:20.940 --> 08:21.940
比方说这里

08:21.940 --> 08:22.940
一零

08:22.940 --> 08:23.940
结果是啥

08:23.940 --> 08:25.940
我们从这里开始看吧

08:25.940 --> 08:26.940
零零

08:26.940 --> 08:27.940
假假

08:27.940 --> 08:28.940
为假

08:28.940 --> 08:29.940
零零

08:29.940 --> 08:30.940
这一位

08:30.940 --> 08:31.940
和这一位

08:31.940 --> 08:32.940
零零

08:32.940 --> 08:33.940
还是零

08:33.940 --> 08:35.940
零一

08:35.940 --> 08:36.940
只要有一位为真

08:36.940 --> 08:37.940
那么结果就是真

08:37.940 --> 08:38.940
一

08:38.940 --> 08:39.940
这里是一零

08:39.940 --> 08:40.940
结果就是真

08:40.940 --> 08:41.940
一看

08:42.940 --> 08:44.940
通过或运算运算的结果

08:44.940 --> 08:47.940
是不是就把两个权限组合起来了

08:47.940 --> 08:49.940
这两个位置都有异了

08:49.940 --> 08:50.940
看到没

08:50.940 --> 08:51.940
ok 这就是

08:51.940 --> 08:53.940
如何来组合一个权限

08:53.940 --> 08:54.940
当然这是两个组合

08:54.940 --> 08:56.940
三个组合是不是一样的

08:56.940 --> 08:58.940
一次在后面写呗

08:58.940 --> 08:59.940
彭明信

08:59.940 --> 09:00.940
比方说彭明信

09:00.940 --> 09:01.940
然后呢

09:02.940 --> 09:03.940
再组合一个权限

09:03.940 --> 09:04.940
或者是

09:04.940 --> 09:06.940
我们这里组合完成之后

09:06.940 --> 09:07.940
后续呢

09:07.940 --> 09:09.940
我再给他添加权限

09:10.940 --> 09:12.940
在之前的权限基础上

09:12.940 --> 09:13.940
再去组合一个

09:13.940 --> 09:14.940
彭明信的

09:14.940 --> 09:16.940
是一样的道理

09:16.940 --> 09:17.940
你自己就想

09:17.940 --> 09:18.940
一定是一样的道理

09:18.940 --> 09:21.940
这是如何来组合一个权限

09:21.940 --> 09:22.940
好

09:23.940 --> 09:24.940
这一步完成之后

09:24.940 --> 09:25.940
我们第二步

09:25.940 --> 09:26.940
再看一下

09:26.940 --> 09:27.940
看还有哪些操作

09:28.940 --> 09:30.940
如何判断

09:30.940 --> 09:34.940
是否拥有某个权限

09:34.940 --> 09:35.940
如何来判断

09:35.940 --> 09:36.940
比方说我现在得到了

09:36.940 --> 09:37.940
一个变量P

09:37.940 --> 09:38.940
它里面呢

09:38.940 --> 09:39.940
它是个美剧

09:39.940 --> 09:40.940
它是个美剧

09:40.940 --> 09:42.940
我们可以约束一下

09:42.940 --> 09:43.940
约束一下

09:44.940 --> 09:45.940
彭明信

09:45.940 --> 09:46.940
不约束的话

09:46.940 --> 09:47.940
他莫认为Lumber

09:47.940 --> 09:49.940
因为这个算出来是一个数字

09:49.940 --> 09:50.940
可以约束一下

09:50.940 --> 09:51.940
约束为美剧

09:51.940 --> 09:52.940
其实是一样的

09:52.940 --> 09:53.940
因为数字美剧

09:53.940 --> 09:54.940
我们都知道

09:54.940 --> 09:55.940
可以复制为其他数字

09:55.940 --> 09:56.940
都是没问题的

09:57.940 --> 09:59.940
好 这里呢

09:59.940 --> 10:00.940
我把它约束为美剧

10:00.940 --> 10:02.940
P当然不约束也没事

10:02.940 --> 10:03.940
现在呢

10:03.940 --> 10:05.940
我要判断这个变量P里边

10:05.940 --> 10:07.940
是不是包含某一种权限

10:07.940 --> 10:08.940
因为有的时候呢

10:08.940 --> 10:10.940
代码运行到这

10:10.940 --> 10:11.940
这个变量的值呢

10:11.940 --> 10:12.940
可能来自于一个函数

10:12.940 --> 10:13.940
我不太清楚

10:13.940 --> 10:14.940
它的值是什么

10:14.940 --> 10:15.940
我想判断一下

10:15.940 --> 10:17.940
它是不是对某个资源

10:17.940 --> 10:18.940
拥有某种权限

10:18.940 --> 10:20.940
该如何来判断

10:20.940 --> 10:21.940
好 这里呢

10:21.940 --> 10:22.940
我写这么一个函数

10:22.940 --> 10:23.940
方可信

10:23.940 --> 10:25.940
该取个名字吧

10:25.940 --> 10:27.940
Hash Permission

10:27.940 --> 10:30.940
是不是拥有某个权限

10:30.940 --> 10:31.940
这个函数呢

10:31.940 --> 10:33.940
需要给我两个参数

10:33.940 --> 10:34.940
第一个参数

10:34.940 --> 10:36.940
你要判断的目标

10:36.940 --> 10:37.940
比方说

10:37.940 --> 10:38.940
以后呢

10:38.940 --> 10:39.940
我要判断这个变量P

10:39.940 --> 10:41.940
那么就把这个变量P传过来

10:41.940 --> 10:42.940
因此

10:42.940 --> 10:43.940
第一个参数什么类型

10:43.940 --> 10:44.940
啥类型

10:44.940 --> 10:46.940
是不是 Permission

10:46.940 --> 10:48.940
我目前的权限

10:48.940 --> 10:51.940
这是我们判断的目标

10:51.940 --> 10:53.940
然后呢

10:53.940 --> 10:54.940
第二参数

10:54.940 --> 10:55.940
第二参数

10:55.940 --> 10:56.940
我们判断的是

10:56.940 --> 10:58.940
拥有哪个权限吗

10:58.940 --> 11:00.940
我们就用变量P

11:00.940 --> 11:01.940
就用这个

11:01.940 --> 11:02.940
或者是P

11:02.940 --> 11:03.940
都行

11:03.940 --> 11:04.940
Permission

11:04.940 --> 11:06.940
我这里判断的是啥

11:06.940 --> 11:08.940
判断的是这个里边

11:08.940 --> 11:10.940
包覆包含

11:10.940 --> 11:11.940
这个玩意

11:11.940 --> 11:12.940
以后呢

11:12.940 --> 11:13.940
我就会把P传进来

11:13.940 --> 11:15.940
传到第一个参数

11:15.940 --> 11:17.940
把我要判断的权限

11:17.940 --> 11:18.940
传到这来

11:18.940 --> 11:19.940
比方说

11:19.940 --> 11:21.940
我以后可以这样调用

11:21.940 --> 11:22.940
Hash Permission

11:22.940 --> 11:24.940
我看一下这个变量P里边

11:24.940 --> 11:27.940
是不是拥有可读的权限

11:27.940 --> 11:28.940
Permission

11:28.940 --> 11:29.940
第二参数

11:29.940 --> 11:30.940
比方说

11:30.940 --> 11:32.940
这里我判断

11:32.940 --> 11:34.940
变量P

11:34.940 --> 11:36.940
是否拥有

11:36.940 --> 11:38.940
可读权限

11:38.940 --> 11:39.940
我就会这样子来传递

11:39.940 --> 11:41.940
明白这个意思吧

11:41.940 --> 11:43.940
我们先把参数写好

11:43.940 --> 11:44.940
接下来再说

11:44.940 --> 11:45.940
这个杭数

11:45.940 --> 11:47.940
该怎么来写

11:47.940 --> 11:48.940
该怎么来写

11:48.940 --> 11:50.940
该是如何来书写这个杭数

11:50.940 --> 11:52.940
那么我们现在要判断的是

11:52.940 --> 11:54.940
这个权限里边

11:54.940 --> 11:55.940
是不是包含这个

11:55.940 --> 11:57.940
我们这里举个例子

11:57.940 --> 11:58.940
举个例子

11:58.940 --> 11:59.940
比方说

11:59.940 --> 12:00.940
比方说

12:00.940 --> 12:02.940
我们的这个地方

12:02.940 --> 12:05.940
它的值是0011

12:05.940 --> 12:06.940
比方说

12:06.940 --> 12:09.940
我要判断的目标的值

12:09.940 --> 12:10.940
是什么多少呢

12:10.940 --> 12:12.940
比方说我要判断可读权限

12:12.940 --> 12:14.940
判断的是001

12:14.940 --> 12:16.940
判断的是这个东西

12:16.940 --> 12:17.940
其实我要判断啥

12:17.940 --> 12:20.940
我就要判断这个位置上

12:20.940 --> 12:21.940
是不是有1

12:21.940 --> 12:22.940
对不对

12:22.940 --> 12:24.940
如果是可写的权限的话

12:24.940 --> 12:25.940
我要判断的是

12:25.940 --> 12:26.940
这个位置上

12:26.940 --> 12:28.940
是不是有1

12:28.940 --> 12:29.940
这个地方

12:29.940 --> 12:30.940
我们可以这样子写

12:30.940 --> 12:31.940
可以这样子写

12:31.940 --> 12:32.940
大家看一下

12:32.940 --> 12:34.940
我直接返回一个结果

12:34.940 --> 12:35.940
没有那么复杂

12:35.940 --> 12:37.940
非常简单

12:37.940 --> 12:39.940
top it

12:39.940 --> 12:41.940
and符号

12:41.940 --> 12:42.940
per

12:42.940 --> 12:44.940
两个扩起来

12:44.940 --> 12:46.940
两个扩起来过后

12:46.940 --> 12:49.940
看是否跟这个东西相同

12:49.940 --> 12:51.940
好 这里有点运算

12:51.940 --> 12:52.940
这干嘛呢

12:52.940 --> 12:54.940
这是我们俩理一理

12:54.940 --> 12:57.940
这个符号写一个的时候

12:57.940 --> 12:59.940
它表示的也是一个位运算

12:59.940 --> 13:01.940
它叫做且运算

13:01.940 --> 13:03.940
且运算

13:03.940 --> 13:05.940
什么叫做且运算

13:05.940 --> 13:08.940
就是一位一位进行比较

13:08.940 --> 13:11.940
发现只要必须要有

13:11.940 --> 13:13.940
两个都是1的时候

13:13.940 --> 13:14.940
结果才是1

13:14.940 --> 13:16.940
其他的时候就是0

13:16.940 --> 13:17.940
跟我们那个

13:17.940 --> 13:19.940
并且运算差不多

13:19.940 --> 13:20.940
对吧

13:20.940 --> 13:22.940
真真为真 其他为假

13:22.940 --> 13:23.940
那么你想一想

13:23.940 --> 13:25.940
如果这两个美举

13:25.940 --> 13:26.940
这两个数字

13:26.940 --> 13:28.940
进行且运算过后

13:28.940 --> 13:29.940
结果是多少

13:29.940 --> 13:31.940
是不是0010

13:31.940 --> 13:32.940
对不对

13:32.940 --> 13:34.940
就把那些有差异的位置

13:34.940 --> 13:36.940
就全部给你取消掉了

13:36.940 --> 13:37.940
只保留

13:37.940 --> 13:39.940
两个都是1的那个位置

13:39.940 --> 13:41.940
而第二个美举

13:41.940 --> 13:42.940
我们显然知道

13:42.940 --> 13:44.940
它只有一个位置上是1

13:44.940 --> 13:45.940
因此呢

13:45.940 --> 13:47.940
这个且运算过后

13:47.940 --> 13:50.940
如果你刚好跟它自身相等

13:50.940 --> 13:51.940
通过这个且运算

13:51.940 --> 13:53.940
如果你刚好跟它自身相等

13:53.940 --> 13:55.940
说明你这个位置上

13:55.940 --> 13:57.940
你一定是1

13:57.940 --> 13:58.940
其他的位置我不管

13:58.940 --> 13:59.940
其他的位置我不管你

13:59.940 --> 14:00.940
我只需要知道

14:00.940 --> 14:01.940
你这个位置上

14:01.940 --> 14:02.940
是不是1就行了

14:02.940 --> 14:04.940
如果你通过且运算

14:04.940 --> 14:07.940
跟它本身的结果是相同的

14:07.940 --> 14:09.940
那么你这个位置上

14:09.940 --> 14:10.940
一定有相应的权限

14:10.940 --> 14:11.940
一定是1

14:11.940 --> 14:13.940
所以我们通过这个表达式

14:13.940 --> 14:14.940
就可以判断出来

14:14.940 --> 14:16.940
是否拥有某个权限

14:16.940 --> 14:17.940
ok

14:17.940 --> 14:18.940
它反回了什么

14:18.940 --> 14:19.940
反回了是个布尔

14:19.940 --> 14:20.940
你看这个函数推断出来

14:20.940 --> 14:21.940
是个布尔

14:21.940 --> 14:23.940
好这里呢

14:23.940 --> 14:24.940
我们把输出啊

14:24.940 --> 14:25.940
看一下

14:25.940 --> 14:27.940
我们之前组合的这个权限

14:27.940 --> 14:29.940
是不是拥有可读权限呢

14:29.940 --> 14:31.940
咱们来看一下

14:31.940 --> 14:33.940
保存一下

14:33.940 --> 14:34.940
np装

14:34.940 --> 14:36.940
对

14:36.940 --> 14:38.940
看一下结果

14:38.940 --> 14:41.940
去表示我拥有这个权限

14:41.940 --> 14:42.940
拥有可读的权限

14:42.940 --> 14:44.940
我再来判断一下

14:44.940 --> 14:46.940
你是否拥有可写的权限呢

14:46.940 --> 14:48.940
保存一下看一下

14:48.940 --> 14:50.940
去

14:50.940 --> 14:51.940
还是拥有这个权限

14:51.940 --> 14:52.940
因为我们之前组合过的

14:52.940 --> 14:54.940
你看之后

14:54.940 --> 14:56.940
组合过可读可写

14:56.940 --> 14:58.940
好现在我去继续判断

14:58.940 --> 15:00.940
判断你是否拥有crate的权限呢

15:00.940 --> 15:02.940
保存

15:02.940 --> 15:03.940
forced的

15:03.940 --> 15:04.940
没有这个权限

15:04.940 --> 15:05.940
你看看

15:05.940 --> 15:06.940
这个函数就可以通过这种方式

15:06.940 --> 15:09.940
来判断是否拥有某个权限

15:09.940 --> 15:11.940
比方delete

15:12.940 --> 15:13.940
好这里

15:13.940 --> 15:15.940
forced

15:15.940 --> 15:17.940
好这是第2个

15:17.940 --> 15:18.940
常用操作啊

15:18.940 --> 15:20.940
如何判断是否拥有

15:20.940 --> 15:22.940
某个位置的值

15:22.940 --> 15:24.940
好第3个操作

15:24.940 --> 15:26.940
我们可以添加权限

15:26.940 --> 15:28.940
我们之前的添加权限

15:28.940 --> 15:29.940
就是使用这种方式

15:29.940 --> 15:30.940
一起组合

15:30.940 --> 15:32.940
也可以判断是否拥有某个权限

15:32.940 --> 15:35.940
还有第3部也是个常见操作

15:35.940 --> 15:37.940
如何

15:37.940 --> 15:39.940
如何删除

15:39.940 --> 15:41.940
某个权限

15:41.940 --> 15:44.940
如何来删除某个权限

15:44.940 --> 15:46.940
那么怎么删除呢

15:46.940 --> 15:47.940
比方说

15:47.940 --> 15:49.940
比方说我们还是写个函数吧

15:49.940 --> 15:51.940
就是不用函数了

15:51.940 --> 15:52.940
不用函数

15:52.940 --> 15:55.940
我们比方说这么一个变量屁

15:55.940 --> 15:57.940
它里面不是有权限了吗

15:57.940 --> 15:59.940
我想把它的某个权限给它删了

15:59.940 --> 16:01.940
怎么删了给它重新复制

16:01.940 --> 16:04.940
把它之前的权限拿出来

16:04.940 --> 16:07.940
然后使用这个符号

16:07.940 --> 16:08.940
我一会再解释

16:08.940 --> 16:11.940
把你要删除的权限写后边

16:11.940 --> 16:12.940
很明显

16:12.940 --> 16:15.940
比方说我要把可写的权限给它删掉

16:15.940 --> 16:17.940
那么通过这个表达式

16:17.940 --> 16:19.940
就可以完成对权限的删除

16:19.940 --> 16:21.940
怎么回事呢

16:21.940 --> 16:23.940
它也是一个微云算

16:23.940 --> 16:26.940
这个微云算叫做异货

16:26.940 --> 16:27.940
异货

16:27.940 --> 16:28.940
好

16:28.940 --> 16:29.940
我们把这两个数字拿出来

16:29.940 --> 16:32.940
它之前是0011

16:32.940 --> 16:37.940
然后现在我要删除的权限是0010

16:37.940 --> 16:41.940
对两个二净字进行微云算

16:41.940 --> 16:42.940
使用什么云算

16:42.940 --> 16:43.940
使用异货

16:43.940 --> 16:45.940
异货的意思表示

16:45.940 --> 16:51.940
两个位置只要相同取0不同取1

16:51.940 --> 16:52.940
就这个意思

16:52.940 --> 16:53.940
很奇怪对吧

16:53.940 --> 16:54.940
它是这么一种云算

16:54.940 --> 16:57.940
相同取0不同取1

16:57.940 --> 16:58.940
管理是什么相同

16:58.940 --> 16:59.940
只要你相同就取0

16:59.940 --> 17:02.940
因此你会发现00

17:02.940 --> 17:03.940
对吧

17:03.940 --> 17:04.940
前两位两个都是0

17:04.940 --> 17:06.940
第三位两个都是1

17:06.940 --> 17:07.940
相同还是取0

17:07.940 --> 17:10.940
最后一位不同取1

17:10.940 --> 17:11.940
你看

17:11.940 --> 17:13.940
通过这种方式

17:13.940 --> 17:16.940
是不是把这一位就给它删掉了

17:16.940 --> 17:17.940
删掉了

17:17.940 --> 17:18.940
好 删掉之后

17:18.940 --> 17:19.940
我们再来看

17:19.940 --> 17:21.940
再来看通过这个东西来判断一下

17:21.940 --> 17:23.940
你是不是还拥有

17:23.940 --> 17:24.940
可写权限

17:27.940 --> 17:28.940
保存

17:28.940 --> 17:29.940
咱们来看一下

17:29.940 --> 17:30.940
你看

17:30.940 --> 17:31.940
去掉之后

17:31.940 --> 17:33.940
得到结果就是FORCE了

17:33.940 --> 17:35.940
删掉了可写的权限

17:35.940 --> 17:36.940
OK

17:36.940 --> 17:37.940
这是关于

17:37.940 --> 17:39.940
每一句的

17:39.940 --> 17:40.940
未运算

17:40.940 --> 17:41.940
未运算

17:41.940 --> 17:43.940
其实咱们前端会不会遇到这些

17:43.940 --> 17:45.940
因为这些场景

17:45.940 --> 17:47.940
说不好有可能会遇到

17:47.940 --> 17:49.940
如果你将来遇到了这么一种

17:49.940 --> 17:51.940
比方说权限验证这种场景

17:51.940 --> 17:54.940
你可以使用这种未运算的方式

17:54.940 --> 17:55.940
来进行处理

17:55.940 --> 17:57.940
这种处理非常非常优雅

17:57.940 --> 17:58.940
而且

17:58.940 --> 18:00.940
极度具有扩展性

18:00.940 --> 18:01.940
这里呢

18:01.940 --> 18:03.940
给他补充一个就是扩展姿势

18:03.940 --> 18:04.940
了解一下就行了

