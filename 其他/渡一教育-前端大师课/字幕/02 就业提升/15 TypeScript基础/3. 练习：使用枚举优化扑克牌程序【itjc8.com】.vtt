WEBVTT

00:00.500 --> 00:03.060
OK 咱们学习完美剧之后呢

00:03.060 --> 00:05.100
把之前的那个

00:05.620 --> 00:08.440
铺刻牌那个练习呢 改造一下啊

00:08.700 --> 00:09.720
我们使用git

00:09.980 --> 00:10.740
check out

00:11.000 --> 00:15.100
把之前的这个练习Priktis

00:15.600 --> 00:17.140
这个叫做poker

00:17.400 --> 00:18.940
切换到铺刻牌

00:19.700 --> 00:21.500
然后呢 我们看一下之前的代码

00:22.000 --> 00:25.080
好 这是我们之前的代码 现在我们对它进行一下改造

00:25.840 --> 00:30.200
首先呢 是这里的颜色啊 颜色这里呢 我们把它做成美剧

00:30.500 --> 00:32.300
OK 我们这里呢 写个美剧

00:32.800 --> 00:33.560
银的

00:34.340 --> 00:34.840
color

00:35.100 --> 00:37.660
明智不变 把它做成一个美剧

00:37.920 --> 00:40.480
这里有四个字啊 有四个字

00:40.740 --> 00:43.820
OK 那么这里呢 红桃 红桃是heart

00:44.320 --> 00:46.880
heart 我给它复制一个字幕创 就这关呀

00:47.140 --> 00:47.900
复制过来

00:49.700 --> 00:51.240
然后是黑桃

00:51.500 --> 00:52.000
完了

00:52.520 --> 00:53.540
单词记不住

00:54.060 --> 00:54.560
查一下呗

00:55.580 --> 00:56.100
查一下

00:56.360 --> 00:57.640
铺刻牌

00:58.140 --> 00:59.420
铺刻牌英文

01:00.700 --> 01:01.480
全头英文 OK

01:01.980 --> 01:03.020
黑桃是spade

01:03.280 --> 01:04.040
spade

01:04.800 --> 01:05.820
就这里写一下啊

01:06.080 --> 01:06.840
spade

01:08.640 --> 01:15.560
这是黑桃 黑桃的话把这个复制过来啊 我们现在呢 有了逻辑名字 有了真实的字把它区分开

01:16.320 --> 01:20.680
以后呢 我们要改变它的真实的字的话就非常方便了啊 梅花

01:21.440 --> 01:22.200
梅花

01:22.980 --> 01:23.480
这个

01:24.000 --> 01:24.520
写过来

01:25.280 --> 01:27.600
然后是 最后一个是

01:27.840 --> 01:28.360
diamond

01:28.600 --> 01:29.120
方块

01:29.880 --> 01:30.400
方块

01:31.480 --> 01:32.560
方块 写过来

01:33.520 --> 01:36.640
好 我们首先把铺刻牌的花色

01:36.900 --> 01:38.960
改变成梅菊的字

01:39.460 --> 01:41.000
接下来呢 还有这个东西

01:41.260 --> 01:44.320
这个东西呢 我们其实也可以把它做成梅菊

01:44.580 --> 01:45.600
那来吧 来做吧

01:46.120 --> 01:47.400
这个是mark

01:48.420 --> 01:49.180
就是

01:49.440 --> 01:51.480
牌上面的排面 排面纸

01:52.000 --> 01:56.600
把它做成梅菊 因为它不可 如果它是一个数字的话 取之范围有一点广

01:56.860 --> 01:59.160
它可能会取到小数 可能会取到富数

01:59.360 --> 02:00.640
就造成了

02:00.900 --> 02:02.440
有可能出错的几率

02:02.940 --> 02:05.260
那么咱们把它做成梅菊的话是不可能出错的

02:05.520 --> 02:07.820
ok 这里呢 我们使用

02:08.080 --> 02:09.360
那就这样子的 来呗

02:12.160 --> 02:12.680
a

02:13.200 --> 02:13.700
a

02:14.480 --> 02:15.240
就是a

02:15.760 --> 02:17.040
就是1

02:17.540 --> 02:18.060
2

02:18.320 --> 02:19.080
2

02:19.340 --> 02:19.840
2

02:20.100 --> 02:20.880
有用2

02:22.660 --> 02:24.200
2 来表示2

02:24.720 --> 02:27.280
为什么要用制服窗呢 为什么不用数字呢

02:27.440 --> 02:32.300
是因为有些的 有些牌上面它可能显示的不是数字 比方说勾框K

02:32.560 --> 02:34.660
以及这个尖 对吧

02:34.920 --> 02:37.460
它显示的不是数字 所以说我们统一使用制服窗

02:37.720 --> 02:38.240
3

02:38.760 --> 02:39.260
3

02:39.520 --> 02:40.800
这是个体力活啊

02:41.060 --> 02:41.560
4

02:42.080 --> 02:42.580
4

02:43.360 --> 02:44.380
5

02:45.160 --> 02:45.660
5

02:46.180 --> 02:47.460
然后6

02:47.720 --> 02:48.480
6

02:49.260 --> 02:49.760
7

02:50.020 --> 02:50.520
7

02:51.300 --> 02:51.800
7

02:52.320 --> 02:53.860
然后8

02:54.880 --> 02:55.380
8

02:55.860 --> 02:56.780
然后9

02:56.980 --> 02:57.480
9

02:59.080 --> 02:59.580
9

02:59.820 --> 03:00.380
10

03:00.480 --> 03:00.980
10

03:01.740 --> 03:02.240
10

03:03.620 --> 03:07.020
勾框K的英文 我不太清楚啊 那就11吧

03:07.620 --> 03:08.120
11

03:09.420 --> 03:09.920
j

03:10.580 --> 03:11.080
框

03:11.260 --> 03:11.820
12

03:12.420 --> 03:12.920
12

03:14.180 --> 03:14.860
12

03:16.060 --> 03:16.860
12

03:17.360 --> 03:17.860
ok

03:19.160 --> 03:19.660
框

03:20.460 --> 03:20.960
k

03:21.420 --> 03:22.860
k我知道啊 是k

03:23.660 --> 03:24.420
k

03:25.260 --> 03:29.900
ok 那么就十三张牌啊 把它做成一个美举 那么下面呢 我们使用mark

03:30.260 --> 03:32.420
来约束一下这个属性

03:33.180 --> 03:41.020
好完成这两个操作之后呢 现在呢 我们一张牌里边呢 使用了两个美举对他们的属性呢 进行了约束

03:41.820 --> 03:44.220
然后接下来我们改造一下后边的函数

03:45.380 --> 03:47.260
首先是创建一副铺个牌

03:47.900 --> 03:52.460
创建铺个牌的时候呢 之前我是使用一个循环 从1循环到13

03:52.900 --> 03:58.500
那么现在呢 我不再使用这种方式了 用什么方式呢 我现在换一种方式啊 我把这里

03:59.540 --> 04:01.300
删掉吧 从1换一种方式

04:01.860 --> 04:05.380
我用什么方式呢 我现在由于写了每一句 我们知道每一句

04:05.900 --> 04:10.060
他是会参与编译的 他会到编译结果里边形成一个对象

04:10.620 --> 04:16.900
因此呢 我可以把这个东西循环出来 把他的每一个属性值啊依次循环出来

04:17.500 --> 04:23.420
ok 我们来循环试一下啊 循环试一下 这里呢 我们使用objects the values

04:24.180 --> 04:26.180
然后找到这个每一句 mark

04:27.140 --> 04:30.980
把排面的值所有的属性值 因为我知道这里面的

04:31.820 --> 04:36.100
这个逻辑名称或会形成属性的名字

04:36.660 --> 04:41.060
然后呢 这里的真实的值呢 会形成属性的值 所以说我们这里

04:41.540 --> 04:47.220
通过 values 把他的所有的属性值呢 找到啊 这里我们保存一下啊 max

04:48.300 --> 04:50.380
好 现在我们使用循环 four of

04:52.100 --> 04:58.180
循环 m marks 好 我们来试一下啊 先别管那么多 我们先输出这个 m 试一下

04:58.420 --> 05:03.460
看是否能够把这些值全部循环出来 好 下面这个函数包错 我们先把注射掉

05:04.580 --> 05:10.140
好 先把注射掉 然后下面我们这个函数注射掉啊 好 我们运行一下

05:10.660 --> 05:17.860
np wrong 对 看一下是否能够把这些排面的值啊 全部输出出来 ok 全部输出来了

05:18.740 --> 05:28.460
啊 没问题 好 没问题之后呢 那么咱们继续写 这里呢 我循环了所有的排面啊 循环了所有的排面 每个排面下面呢 有四种花色

05:28.820 --> 05:30.020
我们再去循环花色

05:31.100 --> 05:36.860
ok 我们这里是用 four of 还是一样的啊 通过之前先通过

05:37.660 --> 05:43.420
呃 我先写到后面吧 object the value 是来得到所有的花色

05:43.980 --> 05:49.020
color 然后把它保存到一个变量 colors 里面啊 保存这个变量里面

05:49.740 --> 05:54.700
好 然后呢 这里我们同样的道理去循环这个变量 c colors

05:55.860 --> 06:02.340
好 写个千套的循环 y 成循环呢 循环的是排面 里程循环呢 循环的是花色

06:02.820 --> 06:12.180
接下来 有了排面 有了花色 我们就可以创建一个啊 一个铺盖排对象 把它加入到这个数组里面 好 咱们来写一下啊

06:13.740 --> 06:22.900
通过dake push 往数组里面加一下 加一个对象 这个对象里面需要使用color 来作为排的花色

06:23.220 --> 06:27.300
color 是什么呢 c 然后还要使用什么呢 还要使用mark

06:28.180 --> 06:35.620
是n ok 把这两个东西加入到啊 这个对象 作为这个对象的属性 加入进去

06:36.580 --> 06:39.140
好 这里呢 有一个细节 我要需要说一下

06:40.100 --> 06:48.020
它这里的类型是怎么匹配出来的 我这里要说明白一下 我们用鼠标指的这个c看一下它什么类型

06:48.740 --> 06:56.100
什么类型 nd 对吧 这个m 什么类型 nd 好 我们知道 n 类型呢 是不经过类型检查的

06:56.260 --> 07:01.460
它会直接复制啊 直接完成复制 不经过类型检查 它可以复制给任意类型

07:02.260 --> 07:10.100
那么它为什么是个n呢 我们看c怎么来的c是循环这个数组来的 这个数组 我们看一下

07:10.740 --> 07:17.380
是一个n的数组 并且这个marks 它也是一个n的数组 哎 这是怎么回事呢

07:18.100 --> 07:25.380
其实我们之前的课程呢 有提到过这一点 因为通过这个objects values 通过这个函数啊

07:25.940 --> 07:32.900
它它便利出来的属性值 它并不知道啊 它无法预先知道这个属性值是什么类型

07:33.060 --> 07:36.580
它并不知道 它需要在运行的过程中才能知道

07:37.140 --> 07:45.620
但是在运行的时候 贴时早就不存在了 贴时是精彩类型检查系统啊 到了运行的时候呢 已经不存在类型检查了

07:46.180 --> 07:50.180
只能在写代码的时候完成类型检查 而写这个代码的时候

07:50.900 --> 07:56.260
这个var就是这个函数 它是不知道这个对象的属性里边有哪些啊 是什么类型

07:56.580 --> 08:00.340
因此它只能返回一个n的数组 这里我解释一下啊

08:01.140 --> 08:07.540
好 这是关于这一块如何来创建一个铺客牌 把它稍微改造了一下 改造之后呢 有个什么样的好处呢

08:08.180 --> 08:15.060
好处在于啊 我们现在是动态的来生成一副铺客牌 而不再像之前那样子把它写死了

08:15.780 --> 08:21.620
那么接下来的好处在于 我们将来如果要改变这个花色 比方这里我要把它变成

08:22.420 --> 08:25.700
红心 变成这两个字只需要改动这一个地方

08:26.180 --> 08:32.340
剩下的事情全部一样啊 后边的数据就全部一致了 因为后边我要么是动态的循环他的纸

08:32.820 --> 08:35.060
要么呢 是使用的逻辑名称

08:35.700 --> 08:42.180
不会再使用这个真实的纸了 因此真实的纸整个应用程序里边只会出现在这一个地方

08:42.580 --> 08:44.980
我们可以大胆的在这里完成修改

08:46.020 --> 08:49.700
ok 这里我们把改造完了 接下来下面这个函数就是输出

08:51.540 --> 08:55.060
好 输出这个函数现在变得简单了 我们循环

08:55.700 --> 09:00.660
循环啥 循环这个牌组对吧 这个牌组里边有颜色

09:01.380 --> 09:09.700
在直接拼接上这个牌的什么mark 直接拼接上 因为这里面的数据就已经写好了 你看没有

09:10.260 --> 09:19.540
这里面的数据就已经写好了 所以说我只需要把它读出来颜色 花色 拼接上 数字完了 不需要下面这一大堆的判断啊 不需要了

09:20.900 --> 09:26.340
ok 我们这里就完成了啊 整个函数就清爽清爽了非常多

09:27.060 --> 09:32.260
好 保存一下啊 这里把注释取消 保存一下 我们看一下啊 这里结果

09:32.980 --> 09:36.820
仍然是完成了一样的效果 但是整个应用程序呢 现在呢

09:37.300 --> 09:45.700
一式代码变得更少了 另外呢 我们以后要更改这里的具体内容时候 我就可以非常轻松的完成更改

09:46.180 --> 09:50.740
比方说这里的哎 我到时候想把它换成一我只需要改这一个地方 它就变成一了

09:51.460 --> 09:54.740
ok 你们这个意思吧 好 这就是我们把这个

09:55.620 --> 10:00.740
之前的练习啊 做一下修改把它改成没去 下来呢 大家也自己去把它做一遍

10:01.700 --> 10:07.700
ok 那么咱们的没去这一块呢 就讲到这里了啊 那么这第二部分我还是把记一下吧

10:08.580 --> 10:11.860
使用没去改造程序

10:13.220 --> 10:19.540
好 没去这一块就讲完了 后边呢 还有一个小节 那个小节呢 是作为一个扩展知识 你不看的话

10:19.860 --> 10:27.940
不会影响到后边的学习 那么你看了之后呢 可以对自己的知识面的做一个扩展 可以去了解一下啊 后边我们会讲一个未没去

10:27.940 --> 10:31.620
ok 那么咱们这一块呢 到这里了 拜拜

