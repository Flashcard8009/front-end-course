WEBVTT

00:01.140 --> 00:04.140
大家好 我是主义教育外部前段讲师袁晋

00:04.140 --> 00:07.140
这一课 咱们继续来学习TS

00:07.140 --> 00:11.140
在这一课里边 咱们要接触两个非常非常重要的概念

00:11.140 --> 00:16.140
一个是接口 一个是内雄兼容性

00:16.140 --> 00:20.140
首先我们一个个说 其实咱们之前学习的东西呢

00:20.140 --> 00:22.140
已经能解决很多问题了

00:22.140 --> 00:28.140
但是呢 有些写法呢 并不是在TS里边的常见写法

00:29.140 --> 00:34.140
我们可能要为未来做准备 把它换成更加合适的写法

00:34.140 --> 00:37.140
首先我们接口这一部分呢 说的就是这个问题

00:37.140 --> 00:40.140
然后另外一部分呢 是内雄兼容性

00:40.140 --> 00:44.140
这一部分呢 是讲的是 在TS里边

00:44.140 --> 00:49.140
它怎么来判断两个类型是不是兼容的

00:49.140 --> 00:52.140
当你把一个数据复制给另一个数据的时候

00:52.140 --> 00:54.140
他们两个类型是不是匹配的

00:54.140 --> 00:57.140
它是如何来进行判定的 这是这一部分的知识

00:57.140 --> 01:00.140
首先我们说的一个部分 就是关于接口

01:00.140 --> 01:04.140
它是一个扩展类型 咱们再来回顾一下

01:04.140 --> 01:07.140
之前我们说过 扩展类型有哪些

01:07.140 --> 01:09.140
我再来回顾一下 扩展类型

01:09.140 --> 01:12.140
什么是扩展类型 就是你自己做的类型

01:12.140 --> 01:15.140
就是TS里边基本类型不够用了

01:15.140 --> 01:17.140
你需要自己去做一个类型

01:17.140 --> 01:20.140
那么这种类型呢 有哪些呢 有类型别名

01:20.140 --> 01:22.140
是不是学过了 你自己命名一个类型

01:22.140 --> 01:25.140
然后有美举 它来解决什么问题的

01:25.140 --> 01:29.140
用来解决在某一个范围内进行取值的问题

01:29.140 --> 01:31.140
其实类型别名也可以做到

01:31.140 --> 01:34.140
只不过它有一些问题 当时咱们讲

01:34.140 --> 01:38.140
美举那个章节的时候 我们特别的提到了这一点

01:38.140 --> 01:42.140
然后呢 就是今天咱们要学习的接口

01:42.140 --> 01:45.140
还有之后 我们还要学习到一个类

01:45.140 --> 01:47.140
一共就这么一些扩展类型

01:47.140 --> 01:52.140
好 我们首先说接口 它来做什么用的

01:52.140 --> 01:56.140
接口呢 这个词呢 其实在

01:56.140 --> 02:01.140
计算机领域里边 很多场景下面都有这个词 对吧

02:01.140 --> 02:03.140
就比方说 我们现实生活中

02:03.140 --> 02:06.140
我们有个笔记板 笔记表上面有什么

02:06.140 --> 02:10.140
有USB接口 对吧 有电源接口

02:10.140 --> 02:13.140
还有什么呢 什么高清线接口 对吧

02:13.140 --> 02:15.140
这是现实生活中的接口

02:15.140 --> 02:19.140
比方说 我们在做前端开发的时候

02:19.140 --> 02:22.140
很多时候 我们说 我们学习了一个包

02:22.140 --> 02:26.140
学习了一个裤 比方说 这个裤

02:26.140 --> 02:29.140
那么我们忘了它里面有哪些函数了

02:29.140 --> 02:32.140
每个函数呢 有哪些参数我忘了

02:32.140 --> 02:34.140
怎么办呢 去查官方文档 对吧

02:34.140 --> 02:37.140
我们凭是怎么说的 查阅

02:37.140 --> 02:41.140
查阅 官方的接口文档

02:41.140 --> 02:43.140
我们是不是这样说的 对不对

02:43.140 --> 02:45.140
还有呢 有的时候呢

02:45.140 --> 02:47.140
我们在公司里边做开发

02:47.140 --> 02:49.140
我们做前端开发

02:49.140 --> 02:53.140
我们需要从后端去调一个就是

02:53.140 --> 02:56.140
去访问一个地址 访问一个后端的地址

02:56.140 --> 02:57.140
那么我们会怎么说

02:57.140 --> 03:00.140
我们会说 调用一个后台的接口

03:00.140 --> 03:02.140
对吧 调用一个后台的接口

03:02.140 --> 03:04.140
意思就是 我去访问一个地址

03:04.140 --> 03:07.140
比方说用gass或者是poser来请求

03:07.140 --> 03:09.140
给他发送一些参数

03:09.140 --> 03:11.140
然后他回馈给我一些数据

03:11.140 --> 03:13.140
调用后台接口

03:13.140 --> 03:16.140
其实接口这个程在咱们现实生活中

03:16.140 --> 03:18.140
非常非常的常见

03:18.140 --> 03:21.140
在我们的type scripts里面

03:21.140 --> 03:25.140
就ts里面 它的接口是什么含义呢

03:25.140 --> 03:30.140
它表示的是 用于约束内

03:30.140 --> 03:35.140
对象含书的契约

03:35.140 --> 03:38.140
也就是说 接口它有约束的作用

03:38.140 --> 03:40.140
约束谁呢 约束内

03:40.140 --> 03:43.140
内大家都知道 在gass里面有内

03:43.140 --> 03:46.140
就是比方说我们写react程序的时候

03:46.140 --> 03:48.140
它是不是使用的是内 对吧

03:48.140 --> 03:50.140
我们叫做内组接

03:50.140 --> 03:52.140
然后还可以约束对象

03:52.140 --> 03:54.140
一个普通的对象也可以约束

03:54.140 --> 03:56.140
还可以去约束一个含书

03:56.140 --> 03:58.140
因此呢 ts里面的接口的作用

03:58.140 --> 04:00.140
是来做约束的

04:00.140 --> 04:02.140
那么这个契约怎么理解呢

04:02.140 --> 04:06.140
契约呢 你可以把它看成一个标准

04:06.140 --> 04:09.140
其实咱们平时说的接口 说的是啥

04:09.140 --> 04:11.140
说的其实就是标准

04:11.140 --> 04:13.140
五个就是标准两个字

04:13.140 --> 04:16.140
比方说咱们笔记本上 电源接口

04:16.140 --> 04:19.140
那么这个接口呢 肯定要满足某一种标准

04:19.140 --> 04:21.140
做出来的 你不能乱做

04:21.140 --> 04:24.140
因为咱们市面上的电源接口

04:24.140 --> 04:27.140
回忆一下吧 想一想

04:27.140 --> 04:29.140
咱们市面上的笔记本里边

04:29.140 --> 04:32.140
电源接口是不是就那么几种

04:32.140 --> 04:34.140
就那么几种电源接口的标准

04:34.140 --> 04:37.140
所以说 有的时候呢 我的笔记本没电了

04:37.140 --> 04:39.140
那再带那个充电器

04:39.140 --> 04:41.140
我可以去借一下

04:41.140 --> 04:43.140
借一下别人的充电器

04:43.140 --> 04:45.140
只要他的充电器啊 他满足的

04:45.140 --> 04:47.140
跟我那个电脑是同一套标准

04:47.140 --> 04:49.140
那么我就可以使用他的充电器

04:49.140 --> 04:51.140
对不对 包括我们的手机上

04:51.140 --> 04:53.140
什么Type-C

04:53.140 --> 04:55.140
什么以前的苹果

04:55.140 --> 04:58.140
苹果 以前老苹果的那种充电器

04:58.140 --> 05:00.140
那个接口 或者是呢

05:00.140 --> 05:02.140
安卓的充电器的接口

05:02.140 --> 05:04.140
他们都是要满足各种各样的标准

05:04.140 --> 05:06.140
包括我们的USB接口 对吧

05:06.140 --> 05:08.140
也是要满足各种标准

05:08.140 --> 05:10.140
他的孔到底有多宽 有多高

05:10.140 --> 05:12.140
有几根铜线 每根铜线

05:12.140 --> 05:14.140
这段距离是多少 铜线有多宽

05:14.140 --> 05:16.140
这些都是有标准的

05:16.140 --> 05:19.140
其实接口说的是啥 说的就是标准

05:19.140 --> 05:21.140
包括我们前端

05:21.140 --> 05:23.140
做填灯开发的时候

05:23.140 --> 05:25.140
去采用一些官方文档

05:25.140 --> 05:26.140
官方文档其实就是他们自己

05:26.140 --> 05:28.140
定的一个标准

05:28.140 --> 05:30.140
我有哪些函数 这个函数里面呢

05:30.140 --> 05:32.140
函数名字叫什么

05:37.110 --> 05:40.110
函数的参数有哪些参数

05:40.110 --> 05:43.110
参数是什么类型 参数是什么意思

05:43.110 --> 05:45.110
返回的结果

05:54.010 --> 05:56.010
返回的结果又是什么意思

05:56.010 --> 05:58.010
等等等等 这些其实是啥

05:58.010 --> 06:00.010
这些其实就是标准

06:00.010 --> 06:02.010
再比方说咱们

06:02.010 --> 06:04.010
写前端程序的时候

06:04.010 --> 06:07.010
要用阿加克斯去调用后台的接口

06:07.010 --> 06:10.010
说的是什么 我请求什么地址

06:10.010 --> 06:12.010
我应该用什么样的方法来请求

06:12.010 --> 06:14.010
get has posed

06:14.010 --> 06:16.010
我应该传递哪些参数

06:16.010 --> 06:18.010
哪些参数是必须要传递的

06:18.010 --> 06:20.010
哪些参数是可以不传递的

06:20.010 --> 06:21.010
它的默认值就是多少

06:21.010 --> 06:23.010
每个参数是什么意思

06:23.010 --> 06:26.010
然后服务器那边返回了结果之后

06:26.010 --> 06:29.010
那个结果又是什么样的类型格式

06:29.010 --> 06:32.010
其实这些全部都是标准

06:32.010 --> 06:35.010
只不过以前咱们在开发程序的时候

06:35.010 --> 06:37.010
标准是一种什么形式呢

06:37.010 --> 06:39.010
它的形式是文档

06:39.010 --> 06:42.010
标准的形式

06:42.010 --> 06:45.010
或者叫做契约的形式

06:45.010 --> 06:47.010
契约是什么

06:47.010 --> 06:49.010
就是必须要满足的标准

06:49.010 --> 06:51.010
必须要满足的标准

06:51.010 --> 06:53.010
你必须得这么干

06:53.010 --> 06:55.010
它的形式呢

06:55.010 --> 06:56.010
大致有两种

06:56.010 --> 06:58.010
一种是文档式的

06:58.010 --> 07:00.010
这其实是

07:00.010 --> 07:02.010
我们以前开发程序的时候

07:02.010 --> 07:04.010
都使用的是这种方式

07:04.010 --> 07:06.010
文档式的 我把它成文

07:06.010 --> 07:08.010
比如说我写了一些

07:08.010 --> 07:09.010
后端的接口

07:09.010 --> 07:11.010
写了一些后端的就是

07:11.010 --> 07:13.010
APN访问地址

07:13.010 --> 07:14.010
那么其实呢

07:14.010 --> 07:16.010
我要让前端去调用的时候

07:16.010 --> 07:18.010
我不知道我防止前端

07:18.010 --> 07:20.010
错误的去使用这个接口

07:20.010 --> 07:22.010
因此我会把它写成文档

07:22.010 --> 07:23.010
对吧

07:23.010 --> 07:25.010
而实际上在公司里面是这样子的

07:25.010 --> 07:27.010
就是在公司里面

07:27.010 --> 07:29.010
在前端开发人员

07:29.010 --> 07:31.010
和后端开发人员

07:31.010 --> 07:33.010
他们做开发之前

07:33.010 --> 07:36.010
项目经理或者是技术总监

07:36.010 --> 07:38.010
他会把我们整个

07:38.010 --> 07:41.010
前后端交互的这个接口

07:41.010 --> 07:43.010
先把它写成文档

07:43.010 --> 07:45.010
就是有哪些请求例子

07:45.010 --> 07:46.010
每个请求例子

07:46.010 --> 07:48.010
有可以使用什么样的

07:48.010 --> 07:49.010
请求方法

07:49.010 --> 07:50.010
get还是post

07:50.010 --> 07:51.010
还是其他的

07:51.010 --> 07:52.010
每个请求例子

07:52.010 --> 07:54.010
要哪些参数要传递

07:54.010 --> 07:55.010
那么反过来是什么东西

07:55.010 --> 07:57.010
这些东西在开发之前

07:57.010 --> 07:59.010
就形成文档

07:59.010 --> 08:01.010
我们把它叫做API文档

08:01.010 --> 08:02.010
API文档

08:02.010 --> 08:04.010
那么形成文档之后

08:04.010 --> 08:06.010
双方再去做开发

08:06.010 --> 08:08.010
大家都按照这个标准

08:08.010 --> 08:10.010
按照这个契约去做开发

08:10.010 --> 08:11.010
就不会出问题

08:11.010 --> 08:13.010
因为两方约束的

08:13.010 --> 08:15.010
准讯的标准都是一样的

08:15.010 --> 08:19.010
但是文档作为契约

08:19.010 --> 08:21.010
用文档作为标准的话

08:21.010 --> 08:22.010
实际上是一个

08:22.010 --> 08:23.010
比较弱的标准

08:23.010 --> 08:25.010
这是一个弱标准

08:25.010 --> 08:27.010
为什么

08:27.010 --> 08:29.010
为什么是弱标准

08:29.010 --> 08:31.010
因为他写了文档

08:31.010 --> 08:32.010
我写单码的时候

08:32.010 --> 08:34.010
有可能写错

08:34.010 --> 08:36.010
我有可能没有去遵守这个文档

08:36.010 --> 08:39.010
这是经常发生的事

08:39.010 --> 08:41.010
你们去调用后台接口的时候

08:41.010 --> 08:43.010
其实你们写过那么多程序

08:43.010 --> 08:44.010
去调用后台接口的时候

08:44.010 --> 08:46.010
那你有敢不敢保证

08:46.010 --> 08:49.010
从来没有一次调用后台接口

08:49.010 --> 08:50.010
出问题的

08:50.010 --> 08:51.010
没有出问题的

08:51.010 --> 08:52.010
从来没有出过问题

08:52.010 --> 08:54.010
你能不能保证

08:54.010 --> 08:55.010
肯定是不能保证的

08:55.010 --> 08:56.010
一定出了问题

08:56.010 --> 08:58.010
像我以前写戒指开发的时候

08:58.010 --> 09:00.010
经常都是出问题

09:00.010 --> 09:02.010
就是API稳当

09:02.010 --> 09:03.010
它是一个弱标准

09:03.010 --> 09:04.010
我写单码的时候

09:04.010 --> 09:05.010
就算我写错了

09:05.010 --> 09:07.010
没有任何人可以提示我

09:07.010 --> 09:09.010
我这里东西写错了

09:09.010 --> 09:10.010
不应该这样子写

09:10.010 --> 09:11.010
这个不满足接口标准

09:11.010 --> 09:13.010
不满足标准文档

09:13.010 --> 09:15.010
我只有在运行出来过后

09:15.010 --> 09:16.010
我才发现

09:16.010 --> 09:18.010
原来这个地方确实写错了

09:18.010 --> 09:19.010
确实写错了

09:19.010 --> 09:20.010
明白这个意思吗

09:20.010 --> 09:21.010
所以说

09:21.010 --> 09:22.010
API稳当

09:22.010 --> 09:24.010
它是一个弱标准

09:24.010 --> 09:25.010
它是标准

09:25.010 --> 09:26.010
但是它是个弱标准

09:26.010 --> 09:28.010
还有一种方式

09:29.010 --> 09:30.010
代码

09:30.010 --> 09:32.010
使用代码进行约束

09:33.010 --> 09:35.010
在代码层面进行约束

09:35.010 --> 09:37.010
这种就是一个强标准

09:37.010 --> 09:40.010
就是如果你写了一些错误的东西

09:40.010 --> 09:42.010
编辑器

09:42.010 --> 09:44.010
应用程序马上就提示你

09:44.010 --> 09:45.010
你这个地方有问题

09:45.010 --> 09:46.010
不能这样子写

09:46.010 --> 09:48.010
然后你把修改成正确的格式

09:48.010 --> 09:49.010
这是一种强标准

09:49.010 --> 09:51.010
你必须要遵守的

09:51.010 --> 09:52.010
那么代码里面

09:52.010 --> 09:53.010
如何来进行约束呢

09:53.010 --> 09:54.010
其实

09:54.010 --> 09:55.010
咱们在后端开发的时候

09:55.010 --> 09:57.010
经常就会有这样的约束

09:57.010 --> 09:58.010
使用的是什么

09:58.010 --> 09:59.010
使用的就是接口

09:59.010 --> 10:02.010
这个接口叫做interface

10:02.010 --> 10:03.010
比方说java

10:03.010 --> 10:04.010
比方说set up

10:04.010 --> 10:05.010
这些应用程序

10:06.010 --> 10:07.010
它里面都有这个东西

10:07.010 --> 10:08.010
interface

10:08.010 --> 10:09.010
它就是专门来约束

10:09.010 --> 10:11.010
来定义标准

10:11.010 --> 10:12.010
定义契约的

10:12.010 --> 10:14.010
在项目开发之前

10:14.010 --> 10:16.010
技术总监或者项目经理

10:16.010 --> 10:17.010
他会把一些接口

10:17.010 --> 10:19.010
一些特别重要的接口

10:19.010 --> 10:21.010
用代码的形式给你开发好

10:21.010 --> 10:22.010
甚至有可能

10:22.010 --> 10:25.010
它都不写文档了

10:25.010 --> 10:26.010
它都不写文档了

10:26.010 --> 10:28.010
把注释打到接口上面

10:28.010 --> 10:29.010
那么有了这个接口过后

10:29.010 --> 10:30.010
它就是一个强标准

10:30.010 --> 10:31.010
那么其他的代码

10:31.010 --> 10:33.010
必须按照这个接口来

10:33.010 --> 10:34.010
你不按照这个来

10:34.010 --> 10:35.010
它直接就出错了

10:35.010 --> 10:36.010
你一点点有差异的话

10:36.010 --> 10:37.010
它都要包裹

10:37.010 --> 10:38.010
因此

10:38.010 --> 10:40.010
这种标准是一个强标准

10:40.010 --> 10:41.010
不是说

10:41.010 --> 10:42.010
我有可能写错

10:42.010 --> 10:43.010
不可能写错的

10:43.010 --> 10:44.010
你写错了过后

10:44.010 --> 10:45.010
你运行不起来

10:45.010 --> 10:46.010
也不可能说

10:46.010 --> 10:47.010
我不去满足它

10:47.010 --> 10:48.010
那不满足它的话

10:48.010 --> 10:50.010
代码是写不出来的

10:50.010 --> 10:51.010
明白这个意思吗

10:51.010 --> 10:52.010
所以说

10:52.010 --> 10:53.010
更好的约束

10:53.010 --> 10:55.010
更好的标准制定形式

10:55.010 --> 10:56.010
用代码的形式

10:56.010 --> 10:58.010
而不是用APN稳当的形式

10:58.010 --> 11:00.010
APN稳当的约束性

11:00.010 --> 11:01.010
要好一点

11:01.010 --> 11:02.010
要好一点

11:02.010 --> 11:04.010
但它的约束力太弱了

11:04.010 --> 11:08.010
这是关于这个接口的概念

