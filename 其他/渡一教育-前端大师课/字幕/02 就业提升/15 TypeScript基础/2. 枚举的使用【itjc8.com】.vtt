WEBVTT

00:00.750 --> 00:04.330
好 我们来看每一句是如何来解决这个问题的

00:04.590 --> 00:05.610
每一句

00:05.870 --> 00:10.470
它是一个自定义的内容 是一个扩展内容 就是你自己做出来的内容

00:10.730 --> 00:12.770
那么这个内容如何来输写呢

00:13.030 --> 00:15.850
就是如何定义一个每一句

00:16.110 --> 00:19.190
如何定义呢 定的方式非常非常简单

00:19.430 --> 00:20.470
是这样定义的

00:21.230 --> 00:23.270
通过音乐关键字

00:23.530 --> 00:26.610
这个音乐就表示的是每一句 表示每一句的意思

00:26.810 --> 00:30.710
然后这里写上每一句的名称 每一句名

00:30.970 --> 00:34.030
你该取个名字 这个名字就相当于是什么

00:34.290 --> 00:38.390
是这里的名字 相当于可以把这样子认为 比方说性别就该取个名字

00:39.150 --> 00:39.650
好

00:39.910 --> 00:43.770
那么某一个东西 表示他某一个东西有一个取之范围

00:44.030 --> 00:46.330
取之范围写到哪呢 写到这里边

00:46.590 --> 00:47.850
每一个取之

00:48.110 --> 00:51.190
就是一行 每一个取之就一行 当然你可以不换行

00:51.450 --> 00:52.470
用斗号进行分割

00:52.730 --> 00:53.750
可以直接输写

00:54.250 --> 00:56.310
好 这里叫做每一句自断

00:56.810 --> 00:58.090
每一句自断

00:58.350 --> 01:00.150
每一句自断 一斗号

01:00.650 --> 01:02.190
每一句自断 二斗号

01:02.450 --> 01:03.730
这里

01:04.490 --> 01:05.010
只

01:06.030 --> 01:06.810
只一

01:07.570 --> 01:08.850
只二

01:11.150 --> 01:12.690
好 后面我不写了

01:12.950 --> 01:14.230
这就是每一句的定义方式

01:15.770 --> 01:17.550
好 我们再来解释一下

01:17.810 --> 01:20.890
比方说以性别为例 我们把这个代码复制过去

01:22.410 --> 01:23.690
以性别为例

01:23.950 --> 01:25.490
每一句名写啥呢

01:25.750 --> 01:26.510
就是性别

01:26.770 --> 01:28.230
我们把这个键点写过来

01:29.130 --> 01:30.390
这个键点写过来

01:30.650 --> 01:31.630
表示性别

01:32.190 --> 01:33.990
每一句自断是啥意思呢

01:34.250 --> 01:35.270
就表示的是

01:35.530 --> 01:36.790
这里面有哪些

01:37.050 --> 01:39.350
哪些取之 你性别有哪些取之呢

01:39.610 --> 01:41.150
要么一个男 要么一个女 对吧

01:41.670 --> 01:43.710
好 这里有一个问题就是

01:43.970 --> 01:45.250
为什么会出现两个东西

01:45.770 --> 01:47.550
一个自断名 一个自断值

01:47.810 --> 01:50.370
左边是自断名 就像属性名一样

01:50.630 --> 01:52.930
右边是值 为什么会出现两个东西

01:53.190 --> 01:54.730
就是我们刚才说的

01:55.230 --> 01:56.510
逻辑含义

01:56.630 --> 01:59.010
和真实的值 它把它分开了

01:59.630 --> 02:02.310
左边是自断名 就表示的是逻辑含义

02:02.550 --> 02:04.910
逻辑含义只有一个 以随便用什么单词来写

02:05.150 --> 02:06.350
没有

02:06.990 --> 02:07.830
表示男

02:08.350 --> 02:09.430
右边的值呢

02:10.030 --> 02:10.890
一个字不错

02:11.150 --> 02:11.910
男

02:12.310 --> 02:14.630
逻辑含义和真实的值

02:15.390 --> 02:16.070
非没有

02:16.330 --> 02:17.550
表示的是女

02:17.830 --> 02:18.590
值呢

02:19.030 --> 02:20.110
字不错女

02:21.390 --> 02:22.310
这就是个没句

02:22.550 --> 02:23.190
把写完了

02:23.710 --> 02:25.190
好 写了没句之后呢

02:25.210 --> 02:27.330
我就不再使用内雄别名了

02:27.570 --> 02:29.250
就不再使用下面的内雄别名了

02:29.510 --> 02:30.510
直接使用没句

02:30.770 --> 02:32.050
你看 仍然可以限制

02:33.090 --> 02:35.130
但是使用了没句之后

02:35.370 --> 02:36.930
之后的复辞呢

02:37.170 --> 02:40.610
它就不能再使用真实的值来完成复辞了

02:40.850 --> 02:42.050
虽然你可以看

02:42.290 --> 02:43.770
可以给它复辞为难 但是不行

02:44.010 --> 02:45.570
不能让你用这种方式来写

02:45.830 --> 02:48.450
就是避免出现这样的问题

02:48.690 --> 02:51.250
真实的值一旦修改会产生大量的修改

02:51.510 --> 02:52.890
它为了避免这样的问题出现

02:53.110 --> 02:55.830
因此不允许复辞为真实的值

02:56.070 --> 02:57.230
而应该怎么来复辞呢

02:57.470 --> 02:58.670
应该用这种写法

02:59.510 --> 03:00.710
没句的名字

03:00.950 --> 03:02.070
你看这个图标

03:02.310 --> 03:03.590
这个图标就表示的是没句

03:04.110 --> 03:05.750
没句的名字 第二

03:06.510 --> 03:07.010
没有

03:07.750 --> 03:09.030
表示复辞为难

03:09.550 --> 03:11.270
使用的是逻辑含义

03:11.790 --> 03:14.230
一个东西的逻辑含义是不会变化的

03:14.470 --> 03:15.310
你说性别

03:15.550 --> 03:17.430
男和女她的逻辑含义会变吗

03:17.830 --> 03:19.110
逻辑含义是不会变的

03:19.670 --> 03:20.990
但它真实的值

03:21.970 --> 03:23.010
会产生变化

03:23.250 --> 03:24.010
比方说

03:24.770 --> 03:26.050
把含书书说掉

03:26.310 --> 03:29.390
这里我们输出这个性别看一下输出的结果是什么

03:29.650 --> 03:31.690
其实输出的结果就是它的真实的值

03:32.210 --> 03:34.770
复辞的时候实际上复辞为真实的值

03:35.010 --> 03:37.070
这里实际上复辞的是制服串蓝

03:37.330 --> 03:38.850
这里复辞的是制服串驴

03:39.110 --> 03:41.690
但是我们写的时候不能用真实的值

03:41.930 --> 03:43.970
必须要用逻辑名称

03:44.230 --> 03:45.770
要用逻辑名称来输写

03:46.290 --> 03:48.090
好我们来输出这个变量间调

03:48.330 --> 03:49.090
输出这个变量

03:49.310 --> 03:49.950
我们来看一下

03:50.210 --> 03:51.110
输出的结果是什么

03:51.870 --> 03:52.930
这里npn

03:53.190 --> 03:53.670
wrong

03:53.910 --> 03:54.410
点

03:56.690 --> 03:57.450
好看一下

03:57.970 --> 03:58.850
好你看到了

03:59.110 --> 04:01.570
它输出的结果是它的真实的值

04:01.810 --> 04:03.090
输出了真实的值

04:03.610 --> 04:05.410
因此我们知道每一句

04:05.650 --> 04:06.690
复辞的时候

04:06.930 --> 04:09.490
实际上复辞的为它真实的去值

04:09.750 --> 04:12.810
但是使用的时候使用的是逻辑名称

04:13.330 --> 04:14.090
好处在哪

04:14.610 --> 04:15.130
好处在哪

04:15.370 --> 04:15.890
你想一想

04:16.410 --> 04:18.210
将来我要改成先生

04:18.450 --> 04:20.250
是不是改以一个地方就够了

04:20.470 --> 04:21.510
或者是帅哥

04:21.750 --> 04:22.510
帅哥

04:23.030 --> 04:24.030
美女

04:24.310 --> 04:26.350
OK咱们来看一下结果

04:27.110 --> 04:28.910
你看就输出了美女了

04:29.170 --> 04:30.710
其他地方我一个不用动

04:30.950 --> 04:32.750
这就是他把逻辑名称

04:33.010 --> 04:35.050
和真实的取值分开的好处

04:35.310 --> 04:37.870
我们后边使用的时候全是使用逻辑名称

04:38.890 --> 04:40.170
当然说到这呢

04:41.190 --> 04:43.750
总有同学会问

04:44.010 --> 04:46.310
那如果逻辑名称改了怎么办

04:47.350 --> 04:47.850
好吧

04:48.050 --> 04:49.210
虽然逻辑名称

04:49.450 --> 04:50.910
我们经常是不会改的

04:51.150 --> 04:53.210
因为逻辑行业是固定的是不会改的

04:53.450 --> 04:55.210
那如果你要改逻辑名称怎么办

04:55.990 --> 04:57.710
F2重够

04:58.290 --> 04:59.210
比方说

04:59.790 --> 05:01.410
你要把它改成手这么大些吧

05:01.650 --> 05:02.010
没有

05:02.390 --> 05:02.910
回车

05:04.190 --> 05:04.910
全部改完了

05:05.150 --> 05:05.710
好这里

05:06.150 --> 05:06.950
手这么大些吧

05:07.210 --> 05:07.710
肺没有

05:08.410 --> 05:08.910
干完了

05:09.510 --> 05:10.590
是不是也很简单

05:11.090 --> 05:12.110
好这就是每一句

05:12.390 --> 05:12.890
他的

05:13.150 --> 05:13.910
第一个好处

05:14.950 --> 05:16.210
第二个好处在哪呢

05:16.650 --> 05:17.610
第二个好处

05:18.050 --> 05:19.450
在于每一句

05:19.710 --> 05:22.150
参与他是会参与编译的

05:22.650 --> 05:23.950
编译完成过后

05:24.210 --> 05:26.450
他会出现在编译结果里边

05:26.710 --> 05:27.650
这就很恐怖了

05:29.550 --> 05:30.150
每一句

05:31.450 --> 05:32.650
会出现在

05:33.250 --> 05:35.850
出现在编译结果中

05:36.950 --> 05:40.250
那么编译结果中GS代码里边怎么会有每一句呢

05:40.650 --> 05:42.650
在GS代码里边他不是每一句

05:44.950 --> 05:46.950
编译结果中

05:47.850 --> 05:49.130
表现为

05:49.650 --> 05:50.150
对象

05:50.410 --> 05:51.690
他是一个对象

05:51.950 --> 05:54.750
我们来看一下编译结果会怕编译成什么样子

05:55.270 --> 05:56.550
好咱们来编译一下

06:00.800 --> 06:02.600
通过tsc来完成编译

06:04.400 --> 06:06.700
编译完成咱们看一下编译结果

06:07.460 --> 06:08.740
看一下编译结果

06:10.280 --> 06:14.120
由于我们这里使用了中文他会把它进行Ulicor的编码

06:14.380 --> 06:17.700
那你可以这样认为吧这个编码的结果就是

06:17.960 --> 06:18.460
帅哥

06:18.720 --> 06:19.500
这个编码的结果

06:19.740 --> 06:20.260
就是每一句

06:20.520 --> 06:22.560
他会进行Ulicor的编码不用管他

06:22.820 --> 06:23.840
咱们来看一下这段代码

06:25.120 --> 06:26.400
这个代码在做什么事呢我们来

06:26.660 --> 06:27.440
大概看一下

06:28.200 --> 06:28.840
他订了个变量

06:29.100 --> 06:29.600
Gender

06:30.500 --> 06:31.100
然后呢

06:31.360 --> 06:32.300
这个Gender没有复制

06:32.560 --> 06:33.840
没有复制undefine嘛对不对

06:34.600 --> 06:35.100
好

06:35.360 --> 06:36.400
这个时候呢他做了

06:36.640 --> 06:38.940
把这个变量作为一个函数的参数

06:39.200 --> 06:40.240
传过去你看

06:40.480 --> 06:42.540
这里再调用一个函数前面是一个函数

06:43.300 --> 06:43.820
然后呢

06:44.580 --> 06:45.360
前面是一个函数

06:45.600 --> 06:46.880
这里是函数的参数

06:47.480 --> 06:49.640
他把这个变量作为参数传过去

06:49.900 --> 06:50.920
他说这样子写的

06:51.180 --> 06:52.980
如果这个变量没有值

06:53.240 --> 06:54.260
如果没有值

06:54.520 --> 06:57.080
就给这个变量复制为一个空的对象

06:57.580 --> 06:58.620
你看是不是变成对象了

06:59.120 --> 06:59.620
好

06:59.880 --> 07:02.200
传过去过后呢这边就变成了一个对象了

07:02.700 --> 07:03.980
然后做了什么事情呢

07:04.240 --> 07:06.540
把这个Gender就是对应到这边的这个Gender

07:07.060 --> 07:08.580
代码里边做了这么一件事情

07:09.100 --> 07:10.120
给他的Mail

07:10.380 --> 07:11.160
你看这个Mail是啥

07:12.440 --> 07:13.460
逻辑名称

07:13.720 --> 07:16.280
把Mail作为属性名

07:17.000 --> 07:17.700
给这个对象

07:17.960 --> 07:19.140
复制这个属性

07:19.400 --> 07:20.840
复制为帅哥

07:21.100 --> 07:22.440
给这个对象的这个属性

07:22.680 --> 07:23.640
复制为美女

07:23.900 --> 07:25.080
说了半天

07:25.340 --> 07:26.480
他做了啥事呢

07:26.740 --> 07:28.020
他就得到这么一个对象

07:30.300 --> 07:31.340
得到这么一个对象

07:32.100 --> 07:35.440
这里Mail为帅哥

07:36.700 --> 07:40.040
FailMail为美女

07:40.800 --> 07:41.840
他得到这么一个对象

07:42.340 --> 07:44.280
因此每一句我们发现

07:44.480 --> 07:46.280
它是会参与到编译的

07:46.540 --> 07:48.580
它会在编译结果中出现

07:49.340 --> 07:49.880
于是呢

07:50.640 --> 07:52.280
我们就可以做这件事情了

07:53.080 --> 07:55.240
我们要打印出目前的性别

07:56.000 --> 07:56.520
Print

07:57.280 --> 07:57.800
写个函数

07:58.180 --> 07:58.640
方形

07:59.080 --> 08:00.440
PrintGender

08:01.280 --> 08:04.140
打印出目前我们系统中使用了性别的名称

08:05.140 --> 08:05.980
那么怎么打印呢

08:06.780 --> 08:07.920
你把它当成一个对象

08:08.180 --> 08:08.840
这是属性

08:09.080 --> 08:09.780
这是属性值

08:10.040 --> 08:10.480
属性名

08:10.600 --> 08:11.080
属性值

08:11.720 --> 08:12.380
还不简单吗

08:13.180 --> 08:13.980
Object

08:14.480 --> 08:15.280
Values

08:15.780 --> 08:17.480
然后每一句传进来

08:17.780 --> 08:18.280
Gender

08:18.680 --> 08:19.280
传进来

08:19.780 --> 08:20.780
得到一个

08:21.780 --> 08:24.580
就是属性值的数组

08:24.980 --> 08:26.180
得到一个属性值的数组

08:26.380 --> 08:27.680
然后循环这个数组

08:28.780 --> 08:29.380
for each

08:29.580 --> 08:30.380
循环这个数组

08:30.680 --> 08:33.580
每次循环打印出结果就行了

08:35.880 --> 08:36.880
咱们看一下

08:37.880 --> 08:39.580
PrintGender

08:40.180 --> 08:40.880
打印出来

08:41.880 --> 08:42.980
OK看一下

08:44.180 --> 08:45.780
我把前面那个删了

08:46.280 --> 08:46.980
前面那个

08:47.280 --> 08:48.280
这个删掉

08:51.080 --> 08:51.680
Zoom

08:51.880 --> 08:52.380
定了

08:55.000 --> 08:55.900
好看一下啊

08:57.000 --> 08:57.500
你看

08:58.200 --> 09:01.500
可以动态的在运行的过程中把它打印出来

09:01.700 --> 09:03.800
之所以能这样做是因为每一句

09:03.900 --> 09:05.000
它会参与编译

09:05.100 --> 09:07.100
它会形成编译结果中的对象

09:07.300 --> 09:11.200
而以前的类型别名是不会参与编译的

09:11.800 --> 09:13.500
编译结果中它就直接消失了

09:14.000 --> 09:16.700
因此我们如果要在运行的过程中

09:17.100 --> 09:19.700
要使用没使用没句的话

09:19.900 --> 09:21.500
使用了一个取之范围的话

09:21.600 --> 09:23.100
那么需要使用没句

09:23.400 --> 09:26.900
另外如果我们需要把逻辑名称逻辑含义

09:26.900 --> 09:28.200
和真实的只分开

09:28.400 --> 09:31.400
以防止未来会出现的修改的时候

09:31.500 --> 09:33.000
我们应该选择没句

09:33.700 --> 09:35.100
实际上不用纠结

09:35.400 --> 09:36.600
你不用去纠结这些

09:36.900 --> 09:39.800
只要是取之范围你都可以用没句

09:39.800 --> 09:41.000
用没句准没错

09:41.300 --> 09:42.700
就没错就完事了

09:42.800 --> 09:44.200
你不用去纠结这个东西

09:45.000 --> 09:48.600
这是关于没句的最基本的用法

09:48.800 --> 09:50.900
我们这里讲了没句的基本用法

09:51.500 --> 09:53.100
好接下来我们再看一下

09:53.100 --> 09:55.900
没句这里面一些细节的规则

09:57.500 --> 09:58.600
没句的规则

09:59.300 --> 10:00.700
这里一个个说一下

10:01.600 --> 10:07.700
没句的只可以是字符创或数字

10:08.800 --> 10:09.400
啥意思

10:09.900 --> 10:11.000
就是没句的字

10:11.000 --> 10:13.000
应该这样说没句的自断字

10:14.500 --> 10:15.300
自断字

10:15.700 --> 10:18.000
没句是有一个一个的自断组成的

10:18.000 --> 10:19.400
你看一个自断

10:19.400 --> 10:22.000
一个自断通过这样的方式在组成的

10:22.400 --> 10:24.500
因此的没句的自断的只

10:24.500 --> 10:27.900
只能使用字符创或者是数字

10:27.900 --> 10:29.400
还是可以使用数字的

10:29.800 --> 10:30.500
比方说

10:31.200 --> 10:31.900
比方说

10:32.400 --> 10:36.300
我们这里使用一个level等级

10:36.300 --> 10:37.500
对吧等级

10:37.600 --> 10:39.500
等级也不能随便取之

10:39.600 --> 10:41.900
比方说咱们系统里边一共就只有三级

10:41.900 --> 10:42.700
一共取个5

10:42.700 --> 10:43.800
一共取个1.3

10:43.800 --> 10:44.700
这是什么东西的

10:45.600 --> 10:49.100
level1比方说level1给它取之为一个数字

10:49.100 --> 10:52.400
一级level2取之为一个数字

10:52.400 --> 10:55.100
二级level3取之为一个数字

10:55.800 --> 10:56.400
三级

10:56.700 --> 10:58.800
我们同样达到了范围约束的目的

10:59.900 --> 11:03.700
那么我们比方说有一个LL这个变量

11:04.600 --> 11:05.700
L这个变量呢

11:06.100 --> 11:08.000
给它约束为level

11:08.100 --> 11:09.000
它是个等级

11:09.500 --> 11:11.100
负值的时候怎么负值呢

11:11.200 --> 11:13.400
负值的时候就用这种方式来负值

11:13.600 --> 11:14.400
level1

11:14.400 --> 11:16.300
你看第一等级为1

11:17.300 --> 11:21.200
也可以给它负值为level level2

11:21.200 --> 11:21.900
等级为2

11:21.900 --> 11:23.500
你看使用的都是逻辑名称

11:23.800 --> 11:25.100
使用的都是逻辑名称

11:25.700 --> 11:26.100
ok

11:26.200 --> 11:30.400
这是没句可以是数字也可以是字符创

11:30.700 --> 11:31.600
也可以是字符创

11:32.100 --> 11:32.700
字符创呢

11:32.700 --> 11:34.300
刚才我们已经看到过了

11:34.300 --> 11:35.400
已经严实过了

11:35.900 --> 11:39.000
数字这一块有一些细节呢

11:39.200 --> 11:41.300
大家需要注意啊需要注意

11:42.100 --> 11:42.300
好

11:42.300 --> 11:43.500
我们看一下数字

11:45.300 --> 11:48.200
我们把字段值为数字的没据呢

11:48.200 --> 11:49.700
我们把它叫做数字没据

11:50.800 --> 11:51.500
数字没据

11:51.500 --> 11:54.100
还有一些特点有些比较独特的特点

11:55.000 --> 11:56.900
第一个数字没据

11:58.100 --> 11:59.800
的值

12:00.700 --> 12:02.400
会自动自征

12:03.900 --> 12:04.800
这是什么意思

12:05.500 --> 12:06.500
给大家看一下这边

12:08.200 --> 12:10.000
现在的字这个字段有三个

12:10.300 --> 12:13.900
1 2 3有三个分别负责为123

12:14.600 --> 12:16.900
那我可不可以第二个不负责呢

12:17.000 --> 12:18.200
我可以不负责的

12:18.900 --> 12:20.100
这样子可以不负责的

12:20.700 --> 12:22.100
那么这个结果是什么呢

12:22.100 --> 12:23.500
我们来打印一下这个L

12:24.100 --> 12:25.700
它现在等级是二级

12:26.000 --> 12:27.500
我们来看一下它的值是多少

12:27.500 --> 12:28.200
打印出来

12:29.500 --> 12:30.600
打印出来结果会为2

12:30.700 --> 12:32.100
看到没结果为2

12:32.600 --> 12:35.200
也就是说现在它的没据值

12:35.800 --> 12:37.800
这个东西它的值等于2

12:38.100 --> 12:38.800
怎么来的

12:39.300 --> 12:41.600
它是根据上一个数字自征的

12:42.100 --> 12:43.700
那么同样道理这个值是多少

12:44.100 --> 12:44.900
是不是就是3

12:46.400 --> 12:48.800
那如果你第一个都不负责呢

12:49.300 --> 12:50.800
第一个都不负责会怎么样了

12:51.500 --> 12:53.100
咱们来看一下结果

12:53.400 --> 12:53.900
保存

12:56.200 --> 12:57.400
它的显色结果是1

12:58.000 --> 12:59.900
现在2级为1

12:59.900 --> 13:01.200
那么1级为多少

13:01.800 --> 13:03.000
想一想1级为多少

13:03.200 --> 13:04.200
那是不是用0

13:04.800 --> 13:06.200
你看你指着它的时候

13:06.200 --> 13:07.100
它就会提示你

13:07.300 --> 13:08.100
这里等于0

13:08.600 --> 13:09.800
你不负责的时候

13:09.800 --> 13:11.000
第一个级就是0

13:11.000 --> 13:12.200
后边一次自征

13:12.600 --> 13:13.900
如果你给第一个负责

13:13.900 --> 13:14.700
负责为1

13:14.700 --> 13:16.100
那么后边就是2和3

13:16.200 --> 13:17.200
第一个负责为2

13:17.200 --> 13:18.200
后面就是3和4

13:18.600 --> 13:19.400
原来这个意思

13:19.600 --> 13:20.800
它会自动自征

13:21.100 --> 13:22.800
只是数字没据有这个特点

13:22.800 --> 13:24.200
治不错怎么自征的

13:24.300 --> 13:24.900
没法自征

13:25.800 --> 13:28.300
这是关于数字没据的这个特点

13:29.200 --> 13:29.800
下一个

13:31.960 --> 13:33.260
数字没据

13:34.960 --> 13:36.160
数字没据

13:37.060 --> 13:37.860
你再这样说

13:37.960 --> 13:41.460
被数字没据约束的变量

13:42.660 --> 13:45.560
可以直接负责为数字

13:45.860 --> 13:47.360
是可以的没问题的

13:47.760 --> 13:49.760
被数字没据约束的变量

13:49.960 --> 13:51.960
可以直接负责为数字

13:52.360 --> 13:53.160
就是这里

13:53.360 --> 13:54.660
我可以直接这样子写

13:55.260 --> 13:55.660
1

13:56.760 --> 13:56.960
2

13:56.960 --> 13:58.060
你看它不报仇的

13:58.860 --> 14:02.160
这就可能会导致一些问题了

14:02.660 --> 14:05.560
因为你现在又在使用真实的字了

14:05.860 --> 14:07.460
又在使用真实的字了

14:07.560 --> 14:09.760
因此它可能会导致一些问题

14:10.360 --> 14:11.760
我建议大家呢

14:12.160 --> 14:13.660
不管你用什么样的没据

14:13.760 --> 14:15.260
制服刷是不可能这样做的

14:15.260 --> 14:17.260
制服刷它不能让你这样做

14:17.360 --> 14:18.360
但是数字可以

14:18.560 --> 14:20.260
为什么数字能让你这样做呢

14:20.860 --> 14:23.360
咱们这节课后边有一个扩展姿势

14:23.560 --> 14:25.460
关于未没据的扩展姿势

14:25.560 --> 14:26.860
大家可以去看一下

14:27.160 --> 14:28.260
看了之后你就明白了

14:28.260 --> 14:31.360
它为什么要让数字没据允许你这样做

14:32.160 --> 14:33.860
总之它现在允许你这样做了

14:33.860 --> 14:34.360
但是呢

14:34.360 --> 14:36.260
我不建议大家这样去做

14:36.560 --> 14:37.860
不要这样去做

14:37.960 --> 14:39.360
这样做非常容易导致问题

14:39.360 --> 14:41.360
因为你又在使用真实的字了

14:41.760 --> 14:43.560
除非有个场景

14:43.560 --> 14:44.860
你要使用未没据

14:44.860 --> 14:45.960
但是未没据的话

14:46.060 --> 14:47.360
一般也不会这样子写

14:47.660 --> 14:48.660
也不会这样子写

14:48.860 --> 14:51.560
总之你尽量自己避免这种写法

14:51.660 --> 14:53.260
尽量使用逻辑名称

14:53.760 --> 14:54.860
这里我给大家说清楚

14:54.860 --> 14:55.660
关于这一点

14:56.960 --> 14:57.360
好

14:57.360 --> 14:58.260
我们再来看

14:59.260 --> 15:00.760
数字没据还一个特点

15:01.560 --> 15:06.160
数字没据的编译结果

15:07.160 --> 15:08.360
这里该怎么来记呢

15:08.560 --> 15:09.660
我签这样的记吧

15:09.860 --> 15:13.260
和制服串没据有差异

15:13.360 --> 15:14.160
什么差异呢

15:14.160 --> 15:15.760
我们来看编译结果就明白了

15:15.760 --> 15:17.660
我这里确实不太好记这个笔记

15:18.160 --> 15:19.160
给大家看一下啊

15:20.860 --> 15:23.160
看一下数字没据它编译的结果是啥

15:26.470 --> 15:27.370
NPM

15:27.370 --> 15:29.070
二倍TSC

15:30.670 --> 15:31.670
好完成编译

15:32.570 --> 15:33.270
咱们来看一下

15:33.270 --> 15:34.770
这个代码不是很好理解

15:35.070 --> 15:35.870
看一下这个代码

15:37.870 --> 15:39.070
直接看一下这个代码

15:40.270 --> 15:43.370
属性名NV1属性值0

15:43.370 --> 15:45.570
但是又把这个0作为属性

15:45.770 --> 15:46.970
又把这个0作为属性

15:46.970 --> 15:48.770
又给它复制为NV1

15:49.170 --> 15:50.270
给它复制为这个值

15:50.570 --> 15:51.870
相当于是啥呢

15:51.970 --> 15:53.670
相当于这里产生了这么一个对象

15:54.270 --> 15:55.770
这个没据出来是这么一个对象

15:55.970 --> 15:57.770
数字没据才会出现这个特点

15:57.770 --> 15:58.970
制服出来不会出现了

15:59.670 --> 16:00.570
出现这么一个对象

16:01.570 --> 16:03.070
NV1

16:03.670 --> 16:05.570
它的值是0

16:06.370 --> 16:08.870
NV2它的值是1

16:09.470 --> 16:11.870
NV3它的值是2

16:12.170 --> 16:13.170
还没完

16:13.470 --> 16:17.470
然后属性名为0的属性

16:17.470 --> 16:19.070
属性名为0的属性

16:19.070 --> 16:20.870
它的值是NV1

16:21.770 --> 16:24.070
然后属性名为1的属性

16:24.570 --> 16:26.170
它的NV值是2

16:26.870 --> 16:27.670
明白这个意思吧

16:27.970 --> 16:29.270
属性名为2的属性

16:29.370 --> 16:30.470
NV值为3

16:31.470 --> 16:32.970
对数字没据这一块

16:33.070 --> 16:34.770
它会有这样的一个特殊处理

16:35.270 --> 16:36.070
所以说这一块

16:36.270 --> 16:37.670
跟我们的制服出来不一样

16:37.770 --> 16:39.970
因此如果你将来要去循环

16:40.070 --> 16:42.870
要去便利一个数字没据的话

16:42.870 --> 16:43.970
你要考虑到这一点

16:44.570 --> 16:45.670
你得考虑到这一点

16:46.370 --> 16:46.770
OK

16:46.770 --> 16:49.970
这是关于没据数字没据这一块

16:50.270 --> 16:50.770
这一块

16:50.970 --> 16:52.470
平时我们用没据的时候

16:52.670 --> 16:53.870
给大家说一下这个规则

16:54.470 --> 16:55.270
最佳实践

16:58.020 --> 16:58.620
实践

16:59.120 --> 17:01.620
其实我们去讲这些语法的时候

17:02.320 --> 17:03.420
我个人觉得

17:03.420 --> 17:04.720
语法不是很重要

17:04.720 --> 17:06.720
重要的是我们要知道怎么去用它

17:08.020 --> 17:09.220
最佳实践

17:09.920 --> 17:11.420
怎么去用使用没据

17:11.920 --> 17:12.620
首先

17:13.020 --> 17:14.220
要做这么一个保证

17:15.220 --> 17:18.820
尽量不要在一个没据中

17:19.620 --> 17:21.320
一个没据中

17:22.220 --> 17:23.020
出现

17:23.520 --> 17:28.690
就既出现制服错的制断

17:29.390 --> 17:32.190
又出现数字制断

17:32.390 --> 17:34.690
这种情况我开发了这么多年没见过

17:34.990 --> 17:36.090
我没见过这种情况

17:36.390 --> 17:38.090
因此你不要去做这件事情

17:38.290 --> 17:39.790
不要在一个没据里边

17:39.990 --> 17:41.190
又出现制服错

17:41.190 --> 17:41.990
又出现数字

17:41.990 --> 17:44.290
比如说你这里复制为一个制服错

17:44.690 --> 17:45.490
制服错一

17:45.490 --> 17:47.690
这里复制一个数字二

17:48.090 --> 17:49.490
不要去做这件事情

17:49.790 --> 17:51.290
不要去做这种这种事情

17:51.290 --> 17:52.790
这种事情很容易导致错误

17:54.090 --> 17:55.090
好这是第1个

17:56.090 --> 17:57.190
第2个

17:58.690 --> 18:00.690
给没据

18:02.890 --> 18:04.090
使用没据时

18:04.090 --> 18:04.890
应该这样说

18:05.190 --> 18:06.790
使用没据时

18:07.890 --> 18:13.690
尽量使用没据制断的名称

18:14.090 --> 18:17.590
而不使用真实的字

18:18.090 --> 18:19.990
不要去直接使用真实的字

18:19.990 --> 18:20.990
原因是什么

18:21.790 --> 18:22.690
原因就是这里

18:23.390 --> 18:25.690
把逻辑含义和真实的字

18:25.890 --> 18:26.790
要区分开

18:27.790 --> 18:28.590
就是用的时候

18:28.590 --> 18:30.290
尽量使用没据制断的名称

18:30.590 --> 18:32.190
刚才我们写了这么一个东西

18:32.190 --> 18:32.990
比方说

18:34.290 --> 18:34.990
比方说含书

18:34.990 --> 18:36.390
给大家看一下含书

18:36.790 --> 18:37.890
电池油热室

18:37.890 --> 18:38.990
根据一个等级

18:39.590 --> 18:40.590
根据一个等级

18:41.190 --> 18:41.890
就是level

18:42.190 --> 18:44.190
根据一个等级来返回一些用户

18:44.590 --> 18:46.490
比方说你要调用这个含书的时候

18:47.490 --> 18:48.690
不要直接传个一

18:48.690 --> 18:49.890
不要直接传个二

18:49.890 --> 18:50.790
应该传什么

18:50.790 --> 18:52.190
应该传level

18:52.490 --> 18:54.290
通过这种逻辑名称传过去

18:54.690 --> 18:55.990
通过这种方式传过去

18:56.690 --> 18:57.690
效果是一样的

18:57.690 --> 19:00.290
但是你避免了去写书写真实的字

19:01.190 --> 19:03.090
ok 这是关于这个点

19:04.090 --> 19:05.490
ok 没据这一块

19:05.490 --> 19:08.090
其实东西不是很多

19:08.290 --> 19:08.990
不是很多

19:09.190 --> 19:10.290
那么就讲到这了

19:10.390 --> 19:11.990
你要知道没据它为什么出现

19:11.990 --> 19:13.390
它解决了什么样的问题

19:13.490 --> 19:14.590
主要是这两个问题

19:14.890 --> 19:16.090
反正我建议大家呢

19:16.390 --> 19:17.690
能使用没据的地方

19:17.690 --> 19:19.090
就尽量使用没据

19:19.090 --> 19:20.390
而不要去使用

19:20.990 --> 19:22.790
之前学习的内形别名

19:22.990 --> 19:25.190
因为内形别名那两个问题它逃不掉

19:25.990 --> 19:27.490
ok 当然有的情况下

19:27.490 --> 19:30.790
你可能只是在很少很少某一个局部使用的话

19:30.890 --> 19:32.590
可以使用内形别名没问题

19:32.690 --> 19:33.290
但是呢

19:33.290 --> 19:34.790
如果你要大面积使用的时候

19:34.890 --> 19:36.890
不建议你使用内形别名

19:36.890 --> 19:38.390
我要选择使用没据

19:38.590 --> 19:39.190
你看看

19:39.190 --> 19:40.790
我们虽然之前有内形别名

19:40.790 --> 19:42.190
它内形别名是有问题的

19:42.190 --> 19:42.590
因此呢

19:42.590 --> 19:44.090
我们会有相应的内形呢

19:44.190 --> 19:45.490
来解决这样的问题

19:46.390 --> 19:46.790
好了

19:46.790 --> 19:49.290
这是关于没据这一块东西啊

19:50.090 --> 19:50.590
接下来呢

19:50.590 --> 19:52.590
我们来还是把上捷客

19:52.990 --> 19:54.490
做的那个铺客牌

19:54.490 --> 19:56.490
那个小练习来改造一下

19:56.690 --> 19:58.190
把该改成没据的地方呢

19:58.190 --> 19:59.490
把它换成没据

19:59.790 --> 20:01.490
ok 我们接下来来进行改造

