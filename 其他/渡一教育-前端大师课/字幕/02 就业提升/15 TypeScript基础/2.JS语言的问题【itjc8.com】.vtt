WEBVTT

00:00.880 --> 00:05.740
相信大家都有很多的关于介石的开发经验

00:06.000 --> 00:11.640
那么在开发介石的时候我们或多或少会遇到一些常见的问题

00:12.140 --> 00:14.440
这里我给大家看一段介石代码

00:14.700 --> 00:15.980
就是用纯介石写的

00:16.240 --> 00:17.260
一个很短的代码

00:17.780 --> 00:19.820
我们来看一下这段代码有哪些问题

00:20.840 --> 00:21.620
首先

00:21.880 --> 00:22.380
这里

00:22.640 --> 00:24.440
我们有个函数给自由者列

00:24.700 --> 00:26.740
表示得到用户的姓名

00:27.000 --> 00:29.540
假设这个函数它会发送一个网络请求

00:29.540 --> 00:32.100
它的真实的意识是发送一个网络请求

00:32.360 --> 00:33.640
然后得到用户的姓名

00:33.900 --> 00:37.220
这里我为了模拟就用一个随机数来代替

00:37.980 --> 00:39.020
我写了一个随机数

00:39.260 --> 00:41.320
这个随机数如果小于的0.5

00:41.580 --> 00:42.600
我就给它返回一个字幕刷

00:42.860 --> 00:45.920
就返回一个假设得到的用户姓名是约定

00:46.180 --> 00:47.200
OK 给它返回

00:47.980 --> 00:50.520
接下来如果进不了这个判断

00:50.780 --> 00:54.120
随机数大于等于的0.5我就假设网络不通

00:54.380 --> 00:57.700
或者是请求地址有问题我就给你返回一个404

00:58.160 --> 00:59.960
就这么一个函数很简单的

01:00.720 --> 01:04.820
接下来我去雕用这个函数来得到用户的名字

01:05.080 --> 01:06.100
得到用户的名字

01:06.360 --> 01:08.400
得到名字之后我要做这么一个处理

01:08.660 --> 01:10.700
就是把它的每一个单词的

01:10.960 --> 01:12.500
手字母大体

01:13.260 --> 01:15.560
这个具体的过程其实不重要

01:15.820 --> 01:17.620
我们主要是来照错误我怎么做的呢

01:17.880 --> 01:19.660
我首先用空格来分割

01:19.920 --> 01:22.480
因为单词之间我认为是用空格分割的

01:22.740 --> 01:24.280
所以说我先把整个字幕刷呢

01:24.540 --> 01:27.360
用空格来分割成一个一个的数组

01:28.260 --> 01:30.340
分割完成之后得到了一个数组

01:30.580 --> 01:32.780
然后我再用filter来过滤

01:33.040 --> 01:33.840
过滤啥呢

01:34.100 --> 01:36.600
只保留那些有数据的字幕券

01:36.860 --> 01:39.440
我用这种方式来保留那些有数据的字幕券

01:39.680 --> 01:40.460
那就防止了什么呢

01:40.720 --> 01:42.500
防止了有多个连续的空格

01:42.760 --> 01:45.560
分割出来的字幕券有些字幕券就是空的

01:46.540 --> 01:49.420
然后过滤完成之后我再用map来映射

01:49.920 --> 01:52.480
把过滤的结果就是这个数组

01:53.500 --> 01:54.780
然后进行映射

01:55.140 --> 01:55.920
怎么映射呢

01:56.180 --> 01:57.780
就是把每一个字幕券拿到

01:58.040 --> 01:59.340
这边每一个字幕券拿到

01:59.600 --> 02:01.080
把字幕券的手字幕

02:01.640 --> 02:02.420
变成大写

02:02.920 --> 02:04.820
然后再拼接上字幕券

02:05.080 --> 02:06.000
剩余的部分

02:06.520 --> 02:08.300
好得到了一个新的数组

02:08.560 --> 02:11.380
新的数组里边每一个单词手字幕就是大写的了

02:12.140 --> 02:12.800
最后呢

02:13.060 --> 02:14.960
我用一个字幕券的函数交印

02:15.480 --> 02:18.540
把用空格把这个字幕券连接起来

02:19.040 --> 02:20.240
好最后复制给迈连

02:20.840 --> 02:21.940
好这就是整个代码

02:22.380 --> 02:24.300
流程好像没有什么问题对吧

02:24.980 --> 02:28.400
ok 那么大家看一下这个代码里边有哪些错误

02:28.680 --> 02:29.860
我既然在这样问

02:30.360 --> 02:31.640
是不是他里面一定有错误

02:31.900 --> 02:33.140
他里面是一定有错误的

02:33.380 --> 02:34.300
有哪些错误呢

02:35.480 --> 02:39.080
我们的仔细找一找会发现这个地方函数明显错了

02:39.840 --> 02:40.600
这里是

02:41.120 --> 02:42.640
大写我写成了小写

02:43.420 --> 02:44.200
真不真实

02:44.700 --> 02:46.740
你们敢是不是有点感同身受

02:47.000 --> 02:48.540
这样的错误是经常犯的你们

02:49.300 --> 02:50.080
然后呢这里

02:51.620 --> 02:52.380
我再看啊

02:52.640 --> 02:54.300
这个地方

02:54.980 --> 02:55.740
这个变量

02:56.000 --> 02:57.280
这个变量的名字

02:57.540 --> 02:59.280
应该是my name我写成了

02:59.540 --> 03:00.220
N1

03:00.880 --> 03:01.900
M a

03:02.160 --> 03:03.940
应该是N a m e对吧

03:04.200 --> 03:06.400
这也是你们经常犯错的地方

03:06.660 --> 03:10.340
一个字母写错了或者一个字母少写了写反了

03:10.600 --> 03:12.400
大写变成了小写小写变成了大写

03:12.660 --> 03:13.680
代表上就这里

03:14.700 --> 03:16.360
将一个字幕券转换成

03:16.620 --> 03:17.260
大写

03:17.760 --> 03:18.800
to upcase

03:19.300 --> 03:20.080
是不是有问题

03:20.580 --> 03:22.120
有没有问题这个函数

03:23.160 --> 03:24.280
U是不是应该大写

03:24.480 --> 03:25.760
C是不是应该大写

03:26.020 --> 03:27.820
也是同样的问题

03:28.080 --> 03:29.100
这个substream

03:29.600 --> 03:32.160
s是不是应该小写我这里写成大写了

03:32.940 --> 03:34.980
我们可以把这些错误呢

03:35.240 --> 03:38.820
统称为一个什么样的错误在我们开发中统称为一个

03:39.080 --> 03:42.400
就是命名错误啊或者叫做不是命名错误啊

03:42.660 --> 03:43.180
应该是

03:43.440 --> 03:47.780
书写的错误的名称使用了错误的成员他没有这个函数

03:48.040 --> 03:49.580
但是我去使用了这个函数

03:49.840 --> 03:51.120
我函数的名字写错了

03:51.600 --> 03:52.400
好我们看到

03:52.660 --> 03:56.500
GS开发中有一个非常非常常见的错误

03:57.520 --> 03:58.540
GS中的问题

04:00.950 --> 04:02.230
开发中的问题

04:02.490 --> 04:04.010
咱们总结一下

04:04.270 --> 04:07.350
GS开发里面我们会放一些哪些常见的错误

04:07.610 --> 04:09.910
第一个错误就是使用了

04:11.950 --> 04:13.230
不存在的

04:14.510 --> 04:15.270
变量

04:16.050 --> 04:16.810
函数

04:18.090 --> 04:19.110
或成员

04:19.890 --> 04:21.430
像刚才那几个错误

04:22.950 --> 04:28.330
像刚才那几个错误其实都是一个类型

04:28.590 --> 04:29.350
就是你看

04:29.610 --> 04:30.630
这里MyName

04:30.890 --> 04:32.690
没有这个成员没有这个变量哦

04:32.950 --> 04:35.750
这里GateUserName没有这个函数

04:36.270 --> 04:37.290
像这个

04:37.550 --> 04:39.590
ToUpCase是没有这个成员的

04:39.850 --> 04:41.390
Substream是没有这个成员的

04:41.650 --> 04:43.690
这个错误使用了是

04:43.950 --> 04:46.510
不存在的变量函数过成员

04:46.770 --> 04:48.810
像这个东西太多太多了

04:49.010 --> 04:50.550
我们的名字写错了

04:50.810 --> 04:52.090
或者是字母写反了

04:52.350 --> 04:54.130
大写变成了小写小写变成了大写

04:54.390 --> 04:56.190
这些都有可能会导致这个错误

04:57.210 --> 04:59.010
然后这个错误还会发生在什么时候呢

04:59.270 --> 05:00.790
还会发生在React里边

05:01.310 --> 05:03.870
在React里边我们写一个组件的时候

05:04.130 --> 05:04.890
比方说

05:05.150 --> 05:07.190
在React里面我们写个组件

05:12.420 --> 05:14.720
在React里面我们写个组件的时候呢

05:14.980 --> 05:17.020
写完了之后我们去用这个组件

05:17.280 --> 05:18.040
比方说

05:18.300 --> 05:19.580
我们这样子使用

05:19.840 --> 05:21.380
MyComponent

05:21.580 --> 05:22.740
使用这个组件

05:23.500 --> 05:26.460
使用这个组件的时候呢这个组件里边要传一些

05:26.960 --> 05:28.500
传一些属性对吧

05:28.760 --> 05:30.300
这个属性比方说

05:30.560 --> 05:32.600
有一个属性叫做Name

05:32.860 --> 05:33.620
Name属性

05:33.880 --> 05:34.640
那么你这里

05:35.160 --> 05:36.440
你肯定忘了

05:36.700 --> 05:37.720
十字八就会忘

05:37.980 --> 05:40.540
这个组件里面那个Name到底是怎么写的

05:40.800 --> 05:42.080
有可能是MyName

05:42.320 --> 05:43.860
有可能是N大写

05:44.120 --> 05:44.880
有可能是N小写

05:45.140 --> 05:46.420
怎么写的你可能忘了

05:46.680 --> 05:48.720
所以说这里就非常容易出错

05:48.980 --> 05:50.520
有的时候你可能自己写错了

05:50.720 --> 05:52.520
这样子写错了

05:52.780 --> 05:56.620
这也是使用了一个不存在的成员的名字

05:56.880 --> 05:58.660
那么这是第一类的错误

05:58.920 --> 06:01.480
使用了不存在的辨量还输回成员

06:02.260 --> 06:05.820
好再看第二类的错误也是非常非常长间的

06:06.560 --> 06:08.140
第二类的错误是什么呢

06:08.900 --> 06:09.940
大家看这个代码

06:10.700 --> 06:11.720
这个代码里边

06:11.980 --> 06:13.000
这个代码里边

06:13.260 --> 06:14.540
我们会看到

06:14.780 --> 06:19.140
会看到仔细分析这里还有一个隐藏的很深的错误

06:19.860 --> 06:20.880
就是也不算太深了

06:21.140 --> 06:22.420
仔细分析可以分析的出来

06:23.180 --> 06:24.220
这个辨量

06:24.480 --> 06:26.000
他一定是一个制服串吗

06:26.520 --> 06:27.800
他是不是一定是一个制服串

06:28.060 --> 06:28.820
好好想一想

06:30.100 --> 06:30.860
是不是不一定

06:31.380 --> 06:33.160
他的字他的类型呢

06:33.420 --> 06:34.960
他有可能是一个制服串

06:35.480 --> 06:37.260
有可能是一个数字

06:37.520 --> 06:41.360
那你这里凭什么就把它当成一定是一个制服串来处理的

06:41.620 --> 06:44.700
你看这些函数是不是一定是制服串里面的

06:44.960 --> 06:46.740
他一定是制服串里面的函数

06:47.000 --> 06:48.280
但是他有可能是数字

06:48.500 --> 06:49.560
数字有没有这些东西

06:49.820 --> 06:50.320
就没有

06:50.840 --> 06:54.420
所以说第二个问题也是经常发生的一个问题

06:54.680 --> 06:55.440
就是什么呢

06:55.700 --> 06:56.480
就是

06:57.500 --> 06:58.260
第二个问题

06:59.800 --> 07:00.560
类型

07:01.340 --> 07:01.840
错误

07:02.100 --> 07:03.120
类型错误

07:03.640 --> 07:04.920
什么类型错误呢

07:05.180 --> 07:05.680
就是

07:06.460 --> 07:06.960
把

07:07.740 --> 07:10.040
一个不确定的类型

07:11.840 --> 07:12.600
当做

07:12.860 --> 07:13.360
一个

07:13.620 --> 07:15.160
确定的类型处理

07:15.620 --> 07:19.200
这是在介石里面也是经常经常发生的一个错误

07:19.460 --> 07:21.760
把不确定的类型你看这里是不确定的

07:22.020 --> 07:24.320
他有可能是制服串有可能是数字

07:24.580 --> 07:26.900
但是呢你把它当成了一个确定的类型

07:27.140 --> 07:28.420
制服串来进行处理

07:28.680 --> 07:30.220
那么这个肯定要出问题的

07:30.720 --> 07:32.260
如果出问题其实还好

07:32.520 --> 07:34.320
出问题就来提醒你的代码有隐患

07:34.560 --> 07:35.600
让你赶快更改了

07:36.100 --> 07:37.640
那如果不出问题的话

07:37.900 --> 07:39.680
这个隐患就会埋得非常非常深

07:39.940 --> 07:40.960
等你到

07:41.220 --> 07:42.000
开发了

07:42.240 --> 07:43.280
就上线了之后

07:43.580 --> 07:45.280
然后再去

07:45.540 --> 07:47.580
发现这个问题的时候再来进行调试的时候

07:47.840 --> 07:49.640
就会非常非常花时间

07:50.400 --> 07:51.180
好这是

07:51.680 --> 07:52.440
第二个问题

07:53.220 --> 07:54.500
然后咱们再看

07:54.760 --> 07:55.520
第三个问题

07:55.780 --> 07:57.820
第三个问题呢我这里没有写到

07:58.080 --> 07:59.880
那么这里这个代码里边没有发现

08:00.140 --> 08:02.940
但是也是一个非常非常常见的问题

08:03.200 --> 08:05.240
是一个什么问题呢我一说大家就明白了

08:05.760 --> 08:07.300
你使用了

08:07.800 --> 08:09.860
你在再使用

08:10.320 --> 08:11.860
鸭或

08:12.120 --> 08:14.420
undefine的成员

08:15.180 --> 08:17.620
你在使用这个鸭或者undefine的成员

08:18.020 --> 08:19.020
就举个例子吧

08:19.280 --> 08:19.960
比方说

08:20.560 --> 08:21.420
比方说

08:21.680 --> 08:23.380
我这里的我先把代码注释掉

08:24.660 --> 08:25.760
我有一个变量

08:26.020 --> 08:26.880
这里有个变量

08:28.260 --> 08:30.360
呃随便写吧就一个a

08:31.580 --> 08:32.680
或者是ob系

08:33.120 --> 08:35.820
啊这个变量呢给他复制为undefine

08:36.680 --> 08:39.520
然后呢我调用这个变量的一个成员

08:39.720 --> 08:40.620
啊我们输出

08:40.880 --> 08:43.820
输出这个ob界的lame这个属性

08:44.080 --> 08:45.520
啊咱们来输出试一下

08:46.280 --> 08:47.140
输出试一下

08:47.420 --> 08:48.680
load index

08:48.940 --> 08:49.580
介绍

08:50.140 --> 08:51.640
就是一下你看一样

08:52.080 --> 08:53.040
爆了一个什么错

08:53.280 --> 08:56.240
这个错误应该是大家经常看见的错误

08:56.240 --> 09:00.080
特别是在浏览器环境里边或者是load 环境里边都会经常看见

09:00.420 --> 09:01.280
cannot

09:01.940 --> 09:02.640
property

09:03.020 --> 09:04.520
name of undefined

09:05.080 --> 09:08.840
他说你要尝试着从一个undefined的东西里面去读他的属性

09:08.900 --> 09:09.700
lame属性

09:09.960 --> 09:12.940
读不到啊读不到undefined他没有任何成员

09:13.040 --> 09:14.700
包括load也是一样的

09:15.400 --> 09:16.760
那么这样的东西呢

09:17.240 --> 09:20.160
为什么会发生这样的错误呢你说这样什么不是很傻吗

09:20.440 --> 09:22.600
其实大家如果啊

09:22.860 --> 09:26.560
有足够的开发介绍的经验你就明白我说的什么意思了

09:26.960 --> 09:28.760
这个错误是经常发生的

09:28.960 --> 09:31.260
因为在现实的开发中

09:31.560 --> 09:35.200
实际上这个ob界他的数据不是直接这样子复制的

09:35.300 --> 09:36.800
他不是直接这样子复制的

09:36.820 --> 09:39.420
他怎么复制的他可能是调用一个函数来的

09:39.820 --> 09:42.820
那个函数也不知道什么原因又去调用了其他函数

09:43.060 --> 09:46.700
而其他函数又去调用了其他函数这样子层层嵌套过去

09:47.100 --> 09:49.000
那么这个函数返回的结果

09:49.200 --> 09:50.800
就有可能是undefined

09:51.100 --> 09:52.500
就有可能是undefined

09:52.620 --> 09:56.100
但是呢你这里不知道你还以为他返回了一个正常的结果

09:56.100 --> 09:58.100
于是你去使用就发现有问题了

09:58.900 --> 10:02.500
这个错误呢其实大家应该见得非常非常多了啊

10:02.700 --> 10:06.300
有一个网站我记得什么网站名字我忘了啊

10:06.500 --> 10:09.000
那个网站的他统计了2018年

10:09.400 --> 10:13.800
就是前端开发前10名的错误排名前10的错误

10:14.000 --> 10:16.400
排名第1个就是这个错误

10:17.200 --> 10:20.800
这是在前端开发过程中遇到了最多的错误

10:21.000 --> 10:23.000
你使用一个undefined里面的东西

10:23.300 --> 10:25.100
这也是一个经常遇到的错误

10:26.100 --> 10:29.000
好了我们会发现在介石的开发中

10:30.200 --> 10:33.800
有很会出现很多很多这样类似的错误

10:33.900 --> 10:35.900
那你觉得这些这些错误

10:36.200 --> 10:38.100
应不应该犯这个错误呢

10:38.100 --> 10:40.500
就是我们开发者应不应该去犯这个错误呢

10:41.200 --> 10:42.600
肯定是不应该犯的

10:42.700 --> 10:44.500
但是我们能不能避免了

10:45.400 --> 10:46.400
没法避免

10:46.600 --> 10:49.000
因为我们是人我们不是机器

10:49.000 --> 10:50.500
我们是我们不是神

10:50.500 --> 10:52.200
我们一定会犯错的啊

10:52.200 --> 10:52.900
包括我

10:53.000 --> 10:56.200
我在给你们讲说过很多有的时候的办法也会写错

10:56.200 --> 10:58.100
这是非常非常正常的一件事

10:58.400 --> 11:00.300
只要是人他就一定会犯错

11:00.600 --> 11:03.700
所以说我们不能把经历在用在什么

11:03.700 --> 11:06.900
用在去如何去调教一个人让他不去犯错

11:06.900 --> 11:07.700
这不可能的

11:07.700 --> 11:08.700
他一定会犯错的

11:09.000 --> 11:10.700
大写变成了小写啊

11:10.900 --> 11:12.700
字母写反了写错了

11:12.900 --> 11:15.300
像我们写这个是代码的时候

11:15.300 --> 11:16.300
一个不小心啊

11:16.300 --> 11:17.800
我没有考虑的很周全

11:18.100 --> 11:19.300
因为我们现在目标

11:19.300 --> 11:21.700
目光可能是在关注某一块的功能

11:21.700 --> 11:22.900
关注那一块的功能

11:23.200 --> 11:24.800
他就我就忘记了这个函数

11:24.800 --> 11:26.200
他可能会返回undefined

11:26.400 --> 11:28.200
他可能会得得到一个undefined

11:28.500 --> 11:29.000
因此呢

11:29.000 --> 11:29.900
我就可能会犯

11:30.100 --> 11:31.300
类似于这样的错误

11:31.900 --> 11:33.100
人是无法避免

11:33.100 --> 11:35.100
无法避免人去犯错的

11:35.300 --> 11:37.100
那么我们应该做的是什么呢

11:37.200 --> 11:39.100
应该做的是我写错了

11:39.500 --> 11:40.600
我们既然在做开发

11:40.600 --> 11:42.600
用了很多先进的开发工具

11:42.800 --> 11:45.000
你开发工具能不能提示我一下

11:45.300 --> 11:47.100
我这个名字写错了这么明显

11:47.100 --> 11:48.600
你干嘛不提示我呢

11:48.700 --> 11:49.900
你干嘛不提示我这里

11:50.000 --> 11:51.100
这个n写错了呢

11:51.400 --> 11:53.000
我这个地方那么明显的错误你

11:53.000 --> 11:54.200
为什么不提示我呢

11:54.500 --> 11:57.100
我这个变量他可能是数字

11:57.200 --> 11:58.200
可能是支付串

11:58.200 --> 11:59.700
你干嘛不提示我一下

11:59.800 --> 12:01.500
你这里不能这样子随便用了

12:01.800 --> 12:03.000
他为什么不能提示你

12:03.300 --> 12:05.000
js他做不到

12:05.200 --> 12:06.800
他没有办法提示你

12:07.200 --> 12:09.200
那么接下来我们要讨论的问题就是

12:10.600 --> 12:12.400
js说的有点沉重

12:12.400 --> 12:14.000
js的原罪

12:16.230 --> 12:17.430
js的原罪是什么

12:17.430 --> 12:19.430
就是他与生俱来的一些特点

12:19.430 --> 12:21.430
导致的他做不到这些事情

12:21.830 --> 12:24.030
我们都知道js这个语言啊

12:24.030 --> 12:26.430
你如果了解的js的历史过后

12:26.430 --> 12:27.130
你会知道

12:27.430 --> 12:28.430
js这个语言

12:28.430 --> 12:30.630
他开发周期就两周

12:30.930 --> 12:32.530
是一个两周时间

12:32.530 --> 12:34.330
赶工赶出来的一个语言

12:34.930 --> 12:36.630
他的出发点

12:36.830 --> 12:41.230
绝对不是为了去设计一个大型的应用程序

12:41.530 --> 12:42.930
他当时是为了做什么了

12:42.930 --> 12:45.630
为了做浏览器中的一些小的效果

12:45.730 --> 12:46.730
所以js

12:48.130 --> 12:49.530
js天生

12:50.430 --> 12:54.330
这语言本身的特性

12:54.930 --> 12:57.130
决定了该语言

12:57.430 --> 12:58.330
无法

12:59.330 --> 13:00.630
无法适应

13:01.330 --> 13:02.930
大规大型的

13:03.430 --> 13:05.030
复杂的项目

13:05.530 --> 13:07.630
这个语言本身的特性决定了这一点

13:07.730 --> 13:09.530
因为这个语言设计之初

13:09.530 --> 13:12.630
他就不是为大型复杂的项目来准备的

13:12.630 --> 13:15.230
他是为了做去做一些浏览器的小效果

13:15.230 --> 13:17.030
比方说什么幻能片啊

13:17.530 --> 13:18.930
文字滚动啊

13:19.330 --> 13:21.430
之类的一些小的效果出来的

13:21.630 --> 13:24.230
所以说他不是为了做大型的复杂的项目

13:24.470 --> 13:26.530
而在大型的复杂的项目里边

13:26.530 --> 13:29.130
你可以想象把这个复杂度

13:29.530 --> 13:30.530
把这个复杂度

13:30.930 --> 13:32.730
扩张一百倍

13:33.330 --> 13:34.730
或者是一千倍啊

13:35.130 --> 13:37.930
那么会有无数的这样的函数出现

13:38.130 --> 13:40.230
什么gass user name啊

13:40.430 --> 13:42.830
gass class name啊

13:42.930 --> 13:45.630
gass course name啊各层movie name啊之类的

13:45.630 --> 13:47.930
有大一堆这样的类似的函数出现

13:48.430 --> 13:51.030
一向我们只写了这么几行代码

13:51.430 --> 13:53.730
都有可能会造成这些错误

13:54.230 --> 13:56.330
那如果有一千个函数

13:56.730 --> 13:59.130
有一万个函数有10万个函数

13:59.530 --> 14:02.230
要需要调用每个函数还有参数

14:02.530 --> 14:03.830
参数的还是个对象

14:04.030 --> 14:04.930
对象里面呢

14:04.930 --> 14:06.330
还有各种各样的属性

14:06.330 --> 14:07.430
他还有回调

14:07.630 --> 14:09.530
回调呢又有参数

14:09.630 --> 14:11.130
回调又有反回类型

14:11.330 --> 14:12.930
等等等等等等

14:13.330 --> 14:14.230
我们怎么办

14:14.630 --> 14:17.230
面对这么庞大的一个应用程序

14:17.230 --> 14:18.630
有这么多的函数

14:18.630 --> 14:19.530
我们需要去

14:20.530 --> 14:22.130
处理那么这个时候呢

14:22.130 --> 14:25.630
就无形中增加了我们出错的几率

14:26.530 --> 14:30.730
所以说在介石在介石语言里边

14:30.930 --> 14:32.330
他就遇到了这个问题

14:32.730 --> 14:33.730
而介石语言

14:33.830 --> 14:35.530
他很难解决这个问题

14:36.130 --> 14:37.630
为什么他难以解决呢

14:37.630 --> 14:39.130
为什么他不能提示错误了

14:39.530 --> 14:42.230
因为他这个语言本身有两个特点

14:42.530 --> 14:44.230
第一个是弱类型

14:45.730 --> 14:46.530
弱类型

14:47.430 --> 14:48.630
什么叫做弱类型

14:49.230 --> 14:50.230
弱类型的话

14:50.230 --> 14:51.430
就指的是啊

14:52.330 --> 14:53.030
某个

14:54.130 --> 14:54.630
辨量

14:55.530 --> 14:56.330
某个辨量

14:57.030 --> 14:58.830
可以随时

14:59.730 --> 15:00.830
更换类型

15:01.830 --> 15:02.530
更换

15:03.830 --> 15:04.430
类型

15:04.730 --> 15:07.830
某个辨量在介石里面是可以随时更换类型的

15:08.030 --> 15:09.430
在有些语言里面不行的啊

15:09.430 --> 15:10.530
比方说像加把

15:10.830 --> 15:12.230
比方说像c下铺

15:12.430 --> 15:14.730
像这些语言他是强类型的语言

15:14.730 --> 15:16.230
他是不能随便更换类型的

15:16.430 --> 15:17.930
但是在介石里面是可以的

15:18.230 --> 15:19.230
啊给他看一下了

15:19.630 --> 15:20.630
随便看一下各代嘛

15:22.230 --> 15:22.930
比方说

15:23.430 --> 15:24.930
啊我这里定义了

15:25.030 --> 15:26.530
又是一个啊

15:27.130 --> 15:29.530
你们经常你们经常会遇到了一个错误

15:30.030 --> 15:31.830
我定了一个辨量宽度

15:33.830 --> 15:36.430
宽度我给他复制为500

15:37.430 --> 15:38.330
复制为500

15:38.930 --> 15:41.530
过了以后呢我也不知道为什么啊

15:41.530 --> 15:44.330
我莫名其妙的啊中间可能写了一大堆代吗

15:44.430 --> 15:45.430
我后来就忘了

15:45.530 --> 15:47.630
我要给这个宽度重新复制的时候呢

15:47.630 --> 15:49.130
我就复制为了这个东西

15:49.530 --> 15:50.530
500个相处

15:51.530 --> 15:52.030
好

15:52.730 --> 15:53.830
又写了一大堆代嘛

15:54.630 --> 15:56.130
到某一个地方的时候呢

15:56.130 --> 15:58.330
我可能去啊用document

15:59.130 --> 16:01.130
get element by id

16:01.130 --> 16:02.530
我要设差的宽度

16:03.330 --> 16:04.030
style

16:04.230 --> 16:05.430
the weights的时候

16:05.430 --> 16:06.830
给他设置的时候

16:07.830 --> 16:09.030
我脑袋里面就蒙了

16:09.230 --> 16:09.730
哎

16:10.130 --> 16:13.130
我之前设置的是数字还是制服错呢

16:13.730 --> 16:14.830
啊如果你还没

16:14.930 --> 16:16.530
如果你没有去想到的话

16:16.530 --> 16:18.130
你肯定直接直接写了

16:18.130 --> 16:19.430
如果你想到了还好说

16:19.430 --> 16:20.730
你往回去看一下啊

16:20.830 --> 16:22.530
回头去看一下你是复制的是啥

16:22.730 --> 16:23.730
如果你没有想到的话

16:23.730 --> 16:24.430
你就直接来了

16:24.430 --> 16:25.630
嗯我应该是数字

16:25.630 --> 16:27.530
所以我一次加上px

16:27.530 --> 16:28.330
你那里看

16:28.330 --> 16:29.630
这个程序要不要出错

16:30.030 --> 16:31.130
所以一定会出错

16:31.430 --> 16:32.430
一定会出错

16:32.930 --> 16:33.730
你看这里呢

16:33.730 --> 16:34.630
原来是数字

16:34.730 --> 16:35.930
这里变成了制服错了

16:35.930 --> 16:38.130
那么拼接解就是500px

16:38.130 --> 16:39.830
px那肯定要出错了

16:39.930 --> 16:41.330
但是你当时发现不了

16:41.730 --> 16:44.030
因为这个隐患是什么时候埋下的

16:44.230 --> 16:45.730
不是在这里埋下的

16:45.830 --> 16:47.630
这里解错了真的不惯理

16:47.730 --> 16:48.730
一点都不惯理

16:48.830 --> 16:50.330
是哪里埋下的个隐患

16:50.430 --> 16:51.330
是在这

16:51.830 --> 16:53.930
是在这里埋下这个隐患的

16:54.530 --> 16:56.430
这个明明是一个数字宽度

16:56.430 --> 16:58.130
我一开始定义这个变量的时候

16:58.130 --> 16:59.230
我就想好了

16:59.430 --> 17:00.730
给他设置的一个数字

17:00.830 --> 17:02.730
莫名其妙的不知道怎么回事

17:02.830 --> 17:03.930
我后面脑袋修得了

17:03.930 --> 17:04.830
我就给他设置了

17:04.830 --> 17:05.930
变成一个制服错了

17:06.330 --> 17:07.930
解是他会不会爆错

17:08.130 --> 17:09.230
他不会爆错的

17:09.430 --> 17:11.130
解是在这里他是不会爆错的

17:11.130 --> 17:12.530
他认为没问题啊

17:12.630 --> 17:14.130
我是一个弱类型语言

17:14.430 --> 17:15.530
你给我复制数字

17:15.530 --> 17:16.530
然后变成制服错

17:16.530 --> 17:17.430
不要说制服错了

17:17.430 --> 17:18.630
你变成一个对象都行

17:18.830 --> 17:20.330
所以说他不会爆错的

17:20.730 --> 17:21.730
那么其实

17:21.830 --> 17:23.230
正是因为如此

17:23.230 --> 17:25.330
在写第16航代码的时候

17:25.630 --> 17:27.930
就已经埋下了隐患

17:28.030 --> 17:29.930
这个隐患什么时候爆发

17:30.130 --> 17:31.430
不知道就埋了一颗雷

17:32.730 --> 17:34.230
我们说在这里埋了一颗雷

17:34.530 --> 17:35.430
这个雷要什么时候爆

17:35.430 --> 17:36.030
我不知道

17:36.230 --> 17:37.230
但是总会要爆的

17:37.330 --> 17:38.330
总有一天要爆的

17:38.530 --> 17:40.030
他早一点爆还好

17:40.030 --> 17:40.730
早一点爆的话

17:40.730 --> 17:42.030
我们还能早的

17:42.230 --> 17:43.130
尽早的知道

17:43.230 --> 17:44.930
我们这里是有隐患有问题的

17:45.130 --> 17:47.130
如果他拖到很后边才爆

17:47.230 --> 17:48.230
跟其他的系统

17:48.230 --> 17:49.730
跟其他的寒宿连着爆

17:50.130 --> 17:52.030
那就是一排雷爆了

17:52.330 --> 17:53.630
那么你到时候要调错

17:53.630 --> 17:55.030
我就很麻烦很麻烦了

17:55.630 --> 17:57.130
OK 这是关于这个点

17:57.330 --> 17:59.030
关于他是个弱类型的语言的

17:59.330 --> 18:00.830
弱类型的这个语言的特点

18:00.830 --> 18:01.930
导致了这些问题

18:02.330 --> 18:04.330
实际上我们在实际的开发中

18:04.330 --> 18:05.230
你想一想

18:06.330 --> 18:07.330
一个变量

18:07.930 --> 18:09.230
在定义完了之后

18:09.230 --> 18:10.830
能够确定他是怎么类型

18:10.830 --> 18:12.130
他是一个数字类型

18:12.630 --> 18:14.130
在实际的开发中

18:14.430 --> 18:16.630
我们需不需要他更换类型

18:16.930 --> 18:17.630
需不需要

18:18.430 --> 18:20.030
实际上绝大部分时候

18:20.030 --> 18:22.230
可以说99%的时候

18:22.430 --> 18:24.630
都是不需要去更换他的类型的

18:24.630 --> 18:25.630
更换他干嘛呢

18:25.630 --> 18:27.630
宽度我说好了就是一个数字

18:27.830 --> 18:29.130
他干嘛要变成个制服串呢

18:29.130 --> 18:30.030
没这个必要

18:30.330 --> 18:31.330
所以说很多时候

18:31.330 --> 18:33.230
我们是不需要有这个功能的

18:33.330 --> 18:35.730
但是介石已经给我们提供这个功能了

18:35.730 --> 18:37.730
所以说他没法给我们检查出

18:37.730 --> 18:38.430
那里有错误

18:38.430 --> 18:39.730
他认为那里是正常的

18:39.930 --> 18:40.830
明白这个意思吗

18:41.630 --> 18:44.130
好 这是这个弱类型的一个特点

18:44.130 --> 18:46.230
还有就是我们刚才这个代码

18:46.430 --> 18:47.330
刚才一个代码

18:48.330 --> 18:49.130
这个代码里边

18:49.130 --> 18:50.430
其实也是弱类型

18:50.430 --> 18:52.230
语言了这种不严格性

18:52.230 --> 18:53.630
不严谨性导致的

18:54.130 --> 18:55.930
他这个函数名这么明显的错误

18:55.930 --> 18:57.030
他为什么提示不出来

18:57.230 --> 18:58.430
他为什么提示不出来

18:59.630 --> 19:01.130
你想一想有没有这种可能

19:01.530 --> 19:04.030
你这个介石是在浏览器里面执行的

19:04.930 --> 19:07.830
而浏览器呢引用了其他的介石

19:08.430 --> 19:10.930
有没有可能其他的介石里边

19:11.430 --> 19:13.930
其他的介石里边有这么一个函数

19:14.030 --> 19:14.830
有没有可能呢

19:15.430 --> 19:16.430
是有可能的

19:16.830 --> 19:18.530
其他的介石里面有这个函数

19:18.730 --> 19:19.630
所以说他这里

19:19.930 --> 19:22.430
他不能确定其他介石里面有没有这个函数

19:22.430 --> 19:23.730
因此他不敢爆出

19:23.930 --> 19:25.830
不敢爆出万一其他介石里面有

19:26.030 --> 19:27.230
那爆出你怎么办了

19:27.230 --> 19:28.430
你又不知道该怎么办了

19:28.730 --> 19:30.030
所以说他不敢爆出

19:30.730 --> 19:31.930
而且这里也是一样

19:31.930 --> 19:33.930
有没有可能其他介石里面有这个

19:34.130 --> 19:35.030
相同的名字

19:35.030 --> 19:37.130
就是Mynema

19:37.330 --> 19:39.430
这个变量是一个全局变量

19:39.430 --> 19:40.030
有没有可能呢

19:40.030 --> 19:41.030
这是有可能的

19:41.230 --> 19:42.330
说他不敢爆出

19:42.630 --> 19:43.430
不敢爆出

19:44.130 --> 19:45.130
因此呢

19:45.330 --> 19:48.130
还有这里就是这里他有有可能是支付串

19:48.330 --> 19:49.730
有可能是数字

19:50.030 --> 19:51.430
他为什么不能提示你呢

19:51.430 --> 19:52.730
你这里是要进行判断

19:52.730 --> 19:53.830
为什么不提示你呢

19:54.130 --> 19:57.130
因为他觉得他不清楚这个东西

19:57.430 --> 19:59.730
他中途因为把它变成一个支付串

19:59.830 --> 20:02.130
他不能确定不能确定有这一点

20:02.230 --> 20:03.230
有可能的前面

20:03.430 --> 20:05.430
有可能在这个地方写了这么一个语句

20:05.530 --> 20:07.330
Myne等于啥啥啥啥

20:07.530 --> 20:08.630
把它变成一个支付串

20:08.630 --> 20:09.730
因为他是弱类型

20:10.030 --> 20:11.630
他是可以改变类型的

20:12.230 --> 20:13.730
所以说他这里不敢爆出

20:14.130 --> 20:16.230
这都是弱类型带来的特点

20:16.430 --> 20:17.930
第一个弱类型

20:18.430 --> 20:19.130
某个变量

20:19.330 --> 20:20.630
他可以随时变换类型

20:20.630 --> 20:22.330
导致了很多很多这样的问题

20:22.530 --> 20:23.730
而实际开发中呢

20:23.830 --> 20:26.430
我们是不太需要去改变一个东西的类型的

20:27.830 --> 20:28.930
还有下一个问题

20:29.530 --> 20:31.130
他是解释型的

20:31.630 --> 20:33.530
介石语言他是解释型的

20:33.530 --> 20:34.530
什么叫解释型

20:35.230 --> 20:37.430
就是说我们写的代码啊

20:37.730 --> 20:40.030
最重要执行他是怎么执行的呢

20:40.230 --> 20:42.230
他是看一段执行一段

20:42.230 --> 20:43.630
看一段执行一段

20:44.030 --> 20:45.130
拿出来就马上执行

20:45.130 --> 20:46.330
拿出来就马上执行

20:47.030 --> 20:48.630
他是这么种执行方式

20:48.730 --> 20:50.530
这就导致了一个问题

20:51.430 --> 20:52.630
我们写的代码

20:52.930 --> 20:55.430
必须要运行出来

20:55.830 --> 20:57.730
才能知道我们错误在哪

20:58.230 --> 20:59.030
你想一想

20:59.130 --> 21:01.830
介石语言写的东西是不是这样子

21:02.430 --> 21:05.430
我们一定要把这个代码运行到流量器

21:05.530 --> 21:07.430
运行到服务器上面去

21:07.430 --> 21:08.530
我才知道哦

21:08.530 --> 21:09.230
这个地方有错

21:09.230 --> 21:09.830
他包了一个错

21:09.830 --> 21:11.530
我们再去慢慢去查到错误

21:11.930 --> 21:14.230
而不是我们在编写代码的时候

21:14.230 --> 21:15.230
给我们查找错误

21:15.530 --> 21:17.130
他的错误发生时间点

21:17.530 --> 21:20.730
就是错误发生的时间

21:21.930 --> 21:23.630
是在运行时

21:25.970 --> 21:28.970
是要在运行的时候才能发现这个错误

21:29.070 --> 21:31.070
为什么只能在运行的时候发现错误

21:31.270 --> 21:32.870
因为他是解释型的语言

21:32.970 --> 21:34.870
我写的代码他就直接拿去运行了

21:34.870 --> 21:36.570
他不会经过任何其他过程

21:36.970 --> 21:37.670
我们知道

21:37.870 --> 21:38.770
像加曼呀

21:38.770 --> 21:40.270
像C.Carpia这样这些语言

21:40.270 --> 21:41.770
他是编意型的啊

21:41.870 --> 21:43.870
编意型的他中间还有一个过程叫编译

21:44.170 --> 21:46.270
编译有可能成功有可能不成功

21:46.570 --> 21:48.370
但是呢解释型的语言不一样

21:48.370 --> 21:50.070
你写的代码不管你啥写的

21:50.270 --> 21:52.370
你只要与法正确就行啊

21:52.470 --> 21:53.670
你不要在这里啊

21:53.670 --> 21:55.470
不要在这里写些乱七八糟的东西啊

21:55.670 --> 21:57.170
你只要与法正确就行

21:57.170 --> 21:58.370
我管你其他的东西

21:58.470 --> 22:00.170
不管啊有错误不管了

22:00.170 --> 22:01.170
我直接拿去运行

22:01.270 --> 22:03.170
运行的过程中我再去发现错误

22:03.870 --> 22:06.370
所以说就把这个错误的发现时间

22:06.370 --> 22:07.970
推得很很靠后

22:08.170 --> 22:09.970
你要运行过后才知道错误

22:10.170 --> 22:12.370
那么比方说有些同学呢写代码了

22:12.370 --> 22:13.970
可能写了一百多行

22:13.970 --> 22:15.170
才去运行一次

22:15.370 --> 22:17.870
那么前边很早很早埋下的错误

22:18.470 --> 22:20.070
你在编写代码的过程中

22:20.170 --> 22:21.170
你就很难发现

22:21.470 --> 22:22.770
你一定要转到他

22:22.970 --> 22:23.970
运行出来过后

22:24.070 --> 22:26.770
从浏览器或者是从路德GS

22:26.770 --> 22:28.970
啊民理行里边给你提示的错误过后

22:29.070 --> 22:30.470
再去一行一行啊

22:30.470 --> 22:32.070
逐一去排查这些错误

22:32.370 --> 22:33.870
啊排查完了一个运行

22:33.870 --> 22:34.970
又发现了其他错误

22:34.970 --> 22:35.870
然后又排查

22:35.970 --> 22:37.170
然后再运行又错了

22:37.170 --> 22:37.870
又排查

22:38.270 --> 22:41.370
用这种方式耗费了我们开发者

22:41.570 --> 22:43.570
大量的时间和精力

22:44.070 --> 22:46.170
像这些错误应不应该出现的

22:46.270 --> 22:47.870
我们人无法避免

22:47.870 --> 22:49.870
但是实际上可以通过一些

22:49.870 --> 22:53.170
啊通过这个语言本身来避免这些问题

22:53.370 --> 22:54.370
但是GS

22:54.570 --> 22:57.670
由于这个GS设计上的原罪啊

22:57.670 --> 23:00.170
他无法能够避免这些问题

23:00.170 --> 23:00.970
他避免不了

23:01.370 --> 23:03.170
所以说给我们开发造成了很多问题

23:03.370 --> 23:05.270
因此呢在前端

23:05.970 --> 23:07.370
前端开发中

23:08.370 --> 23:09.370
在前端开发中

23:10.370 --> 23:11.870
大部分的时间

23:12.670 --> 23:14.570
都是在排除

23:15.870 --> 23:17.970
好好回忆一下你们开发

23:18.170 --> 23:18.970
react

23:19.370 --> 23:20.370
开发view

23:21.270 --> 23:23.670
你们在整个开发周期里边

23:23.770 --> 23:26.370
真的有那么多时间是在分析代码

23:26.870 --> 23:28.570
是在编写代码吗

23:29.170 --> 23:30.470
其实你们好好想想

23:30.470 --> 23:31.570
我不会骗你们的

23:31.570 --> 23:33.570
你们自己应该心里面清楚

23:33.870 --> 23:36.470
很多时候在解决那些乱七八糟

23:36.470 --> 23:37.670
莫名其妙的错误

23:37.870 --> 23:39.370
啊这地方又怎么又爆错了

23:39.370 --> 23:41.470
找来找去哦哦字母写错了

23:41.870 --> 23:43.770
好多时候都是在做这件事情

23:43.870 --> 23:46.570
这件事情对我们开发有没有意义呢

23:46.770 --> 23:47.770
没有啥意义啊

23:47.870 --> 23:49.470
他不能使我们学到新东西

23:49.470 --> 23:52.470
不能使我们整个开发者进步啊

23:53.070 --> 23:55.370
并且呢他对整个项目的业务逻辑

23:55.370 --> 23:56.470
也没有什么意义

23:56.670 --> 23:59.170
把时间大量的时间浪费掉这些东西上面了

23:59.370 --> 24:00.970
而且越复杂的系统

24:01.170 --> 24:02.870
这个时间浪费的就越多

24:02.870 --> 24:03.870
占比就越大

24:04.270 --> 24:05.770
是非常非常恐怖的

24:05.870 --> 24:08.470
所以说千万不要小瞧这么几个不起眼的错误

24:08.770 --> 24:10.970
他会占用我们很多很多的时间

24:11.370 --> 24:13.370
而在公司里边时间是什么

24:14.070 --> 24:15.670
时间就是成本啊

24:15.970 --> 24:17.270
公司里边要给你们发工资啊

24:17.270 --> 24:18.370
要给你们付钱的

24:18.670 --> 24:20.570
占用你用花了那么多时间

24:20.570 --> 24:22.470
去调试这些莫名其妙的错误

24:22.670 --> 24:23.570
老板急不急

24:23.670 --> 24:24.770
项目经理急不急

24:24.770 --> 24:25.770
他一定急死了

24:26.370 --> 24:27.970
因此呢这个时候呢

24:28.070 --> 24:29.470
需要有一个东西出来

24:29.570 --> 24:30.970
能不能把这个东西解决了

24:30.970 --> 24:31.870
谁来解决一下

24:31.870 --> 24:32.870
这个太麻烦了

24:33.070 --> 24:34.970
而且在越旁大的系统里面

24:34.970 --> 24:36.370
这个问题就越严重

24:36.470 --> 24:37.470
那就越严重

24:37.870 --> 24:39.770
所以说这个时候

24:39.970 --> 24:41.470
TS出来了啊

24:41.470 --> 24:42.770
就是TypeScript

24:42.970 --> 24:45.970
TypeScript就能解决这些问题啊

24:47.270 --> 24:48.970
所以说我们的了解了

24:48.970 --> 24:51.370
介石里边发生了问题之后呢

24:51.470 --> 24:53.770
你就知道TypeScript来做什么了啊

24:53.870 --> 24:55.170
TypeScript是门语言

24:55.170 --> 24:56.270
他简称

24:57.670 --> 24:58.370
简称

24:58.670 --> 24:59.670
我们先问一下

25:00.270 --> 25:01.670
简称TS

25:01.870 --> 25:02.970
TS语言

25:03.170 --> 25:05.170
他就可以解决这些问题

25:05.270 --> 25:06.970
他可以极大的缩减

25:07.170 --> 25:08.970
我们的项目开发周期

25:09.070 --> 25:11.170
把这个项目开发的时间缩短了

25:11.670 --> 25:13.170
不要小小做几个东西

25:13.270 --> 25:15.470
会占用很多很多时间的开发中

25:15.670 --> 25:17.870
那么TS可以缩短这个时间

25:17.870 --> 25:18.870
比方说这个时间

25:18.970 --> 25:20.170
在超大型项目里边

25:20.170 --> 25:21.170
附大项目里边

25:21.470 --> 25:23.470
越谷谷刚才说的越附大的项目

25:24.270 --> 25:25.870
越大型的项目

25:25.870 --> 25:27.370
这个时间占比就越高

25:27.470 --> 25:28.870
比方说一个大型项目里边

25:28.870 --> 25:30.370
这个时间占了40%

25:30.770 --> 25:32.170
那你使用TS过后了

25:32.170 --> 25:33.970
你可以缩减40%的时间

25:34.070 --> 25:35.370
那你觉得公司里面要不要用

25:35.370 --> 25:36.270
他一定要上

25:36.870 --> 25:37.970
如果一个东西

25:38.170 --> 25:39.170
一个技术

25:39.270 --> 25:41.170
他能够帮助你缩减成本

25:41.370 --> 25:42.370
缩减开发成本

25:42.370 --> 25:43.270
就是时间吗

25:43.570 --> 25:44.470
时间就是成本

25:44.570 --> 25:47.070
他如果能够帮你缩减成本的话

25:47.270 --> 25:48.770
那么如果能够缩减像这样子

25:48.770 --> 25:49.970
40%的成本

25:50.170 --> 25:51.570
那管他里面是啥

25:51.570 --> 25:53.370
管他里面学习的逞难度有多高

25:53.370 --> 25:54.270
上直接上

25:54.970 --> 25:55.970
这个太恐怖了

25:56.070 --> 25:58.670
这样的花费这样的时间去搞定错误

25:58.670 --> 25:59.470
太恐怖了

25:59.570 --> 26:01.470
所以说我们为什么要学TS

26:01.670 --> 26:05.270
实际上是为了我们能够提高我们的开发效率

26:05.270 --> 26:07.370
能够缩减我们的项目周期

26:07.570 --> 26:10.970
能够少犯一些这些莫名其妙的错误

26:11.570 --> 26:11.970
好吧

26:11.970 --> 26:13.970
我们就TS他做什么事情

26:14.170 --> 26:15.070
我们把讲清楚

26:15.070 --> 26:16.170
ok 那么

26:16.570 --> 26:17.170
接下来呢

26:17.170 --> 26:19.070
我就来看一下TS

26:19.170 --> 26:20.370
他的一些特点

26:20.370 --> 26:20.970
以及呢

26:21.070 --> 26:23.170
他是如何来解决这些错误的

