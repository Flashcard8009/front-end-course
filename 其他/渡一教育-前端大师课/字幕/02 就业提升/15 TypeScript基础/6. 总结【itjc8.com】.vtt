WEBVTT

00:00.620 --> 00:06.620
好的 到咱们基础部分 贴室的基础部分就到此结束了

00:06.620 --> 00:11.920
这里呢 对我们基础部分的所有知识呢 来做一个总结和梳理

00:11.920 --> 00:14.120
这一部分呢 我们来做个总结

00:14.120 --> 00:18.120
首先呢 就是咱们在第1节课的时候

00:18.120 --> 00:22.120
也是后边的课程中反复提到的这么一句话

00:22.120 --> 00:26.120
就是TypeScript啊 大家学习起来不要有那么大的压力

00:26.620 --> 00:33.120
这个东西呢 它是一个可选的静态的内详系统

00:33.120 --> 00:38.120
首先为什么需要内详系统 内详系统

00:38.120 --> 00:42.120
现在大家学了那么多的知识了 大家能不能回答这个问题呢

00:42.120 --> 00:50.120
为什么需要内详系统 为什么需要内详系统

00:51.120 --> 00:56.120
为什么需要呢 是因为你要构建一个大中型应用

00:56.120 --> 01:02.120
要构建大型应用 构建大型的应用

01:02.120 --> 01:11.120
它就会涉及到很多的函数和接口 会涉及大量的函数和接口

01:11.120 --> 01:17.120
如果没有内询检查 如果没有内询检查

01:17.120 --> 01:22.120
会导致一个什么结果呢 我们就必须要去丰富各种各样的文档

01:22.120 --> 01:25.120
但是文档它没有强的约束力

01:25.120 --> 01:28.120
就是你可以按照文档来写 也可以不按照文档来写

01:28.120 --> 01:32.120
或者说 我一般不会不按照文档来写

01:32.120 --> 01:36.120
只是说有的时候我写错了 或者是恍惚了 或者是没有记住

01:36.120 --> 01:39.120
这都可能会造成一些隐患

01:39.120 --> 01:43.120
内询的接口越多 函数越多 参数越多

01:43.120 --> 01:46.120
那么这种隐患就会越来越多

01:46.120 --> 01:56.120
而会导致大量的调试时间会造成 会产生大量的调试成本

01:56.120 --> 02:00.120
就是我们会去调试一些低级的错误

02:00.120 --> 02:04.120
比方说明智写错了 比方说该传毁的毁掉的时候

02:04.120 --> 02:07.120
没有传 或者说传了毁掉 但是参数有不对

02:07.120 --> 02:11.120
像这些调试成本会非常非常高

02:11.120 --> 02:16.120
因此只有一个强制 有具有强约束力的内询系统

02:16.120 --> 02:20.120
才能降低这样的成本 才没用那么的去依赖文档

02:20.120 --> 02:24.120
因为单码上的约束肯定是要比文档要强得多

02:24.120 --> 02:26.120
这就是为什么需要内询系统

02:26.120 --> 02:31.120
因此JS这个语言 它的设计支出并不是用来构建大型应用的

02:31.120 --> 02:35.120
它设计支出就是为了实现网页上的一些小效果

02:35.120 --> 02:39.120
不过现在的JS已经是破绽没结了

02:39.120 --> 02:42.120
它要能够去构建大型的应用

02:42.120 --> 02:45.120
因为我们前端的环境越来越复杂

02:45.120 --> 02:51.120
开发的项目越来越复杂 应用的规模越来越大

02:51.120 --> 02:53.120
所以说为什么需要内询系统 就是这个原因

02:53.120 --> 03:01.120
内询系统可以降低调试成本 从而降低开发成本

03:01.120 --> 03:04.120
因为调试它是开发的一部分 对吧

03:04.120 --> 03:08.120
从而降低开发成本 这是为什么需要内询系统

03:08.120 --> 03:11.120
那么什么是可选的呢

03:11.120 --> 03:13.120
可选的我反复强调过

03:13.120 --> 03:20.120
因为JS是JS的超级

03:20.120 --> 03:22.120
JS的所有功能它都支持

03:22.120 --> 03:26.120
并且它并没有说你JS没有的功能

03:26.120 --> 03:29.120
我一定要去给你做一些特别的功能出来

03:29.120 --> 03:30.120
它没有这个意思

03:30.120 --> 03:32.120
它是完全遵照JS标准的

03:32.120 --> 03:36.120
只是在这个标准基础上 增加了内询系统

03:36.120 --> 03:38.120
所以它是JS的超级

03:38.120 --> 03:45.120
JS的所有功能的所有功能都能够在TES中使用

03:45.120 --> 03:50.120
增加的部分是内询系统

03:50.120 --> 03:53.120
它增加了内询的检查

03:53.120 --> 03:56.120
因此它并且它是可选的

03:56.120 --> 03:57.120
既然是可选的话

03:57.120 --> 03:59.120
我们在我们的开发过程中

03:59.120 --> 04:01.120
是可以用也可以不用

04:01.120 --> 04:02.120
它并不会改变

04:02.120 --> 04:05.120
并没有说强制要求里

04:05.120 --> 04:07.120
一定要改变之前的开发方式

04:07.120 --> 04:09.120
并没有这样的强制性

04:09.120 --> 04:12.120
但是这里有一说一

04:12.120 --> 04:17.120
有的时候TES跟别的一些框架结合的时候

04:17.120 --> 04:21.120
相应的框架会要求里对开发方式

04:21.120 --> 04:23.120
特别是某些地方做出一些改变

04:23.120 --> 04:25.120
比方说咱们这个项目里边

04:25.120 --> 04:26.120
使用的是什么

04:26.120 --> 04:28.120
使用的是React对吧

04:28.120 --> 04:31.120
React里边它就有了一些强制性的要求

04:31.120 --> 04:33.120
为了避免出问题

04:33.120 --> 04:34.120
或者说为了少出问题

04:34.120 --> 04:36.120
它有了这么一些强制性的要求

04:36.120 --> 04:37.120
比方说这

04:40.120 --> 04:41.120
这一个内组件

04:41.120 --> 04:42.120
内组件里边

04:42.120 --> 04:44.120
如果你不去做这个约束

04:44.120 --> 04:47.120
如果你在这里不做这个约束的话

04:47.120 --> 04:48.120
那么

04:48.120 --> 04:50.120
可不可以

04:50.120 --> 04:51.120
可以

04:51.120 --> 04:52.120
可以没有什么问题

04:52.120 --> 04:54.120
但是这样子一来了

04:54.120 --> 04:56.120
下面有个地方爆错了

04:56.120 --> 04:58.120
咱们来看一下哪个地方爆错了

04:58.120 --> 05:00.120
我们看一下

05:00.120 --> 05:01.120
在哪个地方

05:01.120 --> 05:02.120
在这里

05:02.120 --> 05:06.780
大家看一下

05:06.780 --> 05:09.780
由于你这里没有传递

05:09.780 --> 05:11.780
没有传递内想

05:11.780 --> 05:12.780
状态的内想

05:12.780 --> 05:13.780
因此

05:13.780 --> 05:15.780
你在使用状态的时候

05:15.780 --> 05:16.780
你看我们得到之前的状态

05:16.780 --> 05:18.780
它就不知道这个状态里面有这个属性

05:18.780 --> 05:19.780
它就不知道

05:19.780 --> 05:20.780
所以说这里要爆错

05:20.780 --> 05:22.780
它认为状态是一个空的

05:22.780 --> 05:25.780
你看它认为状态是一个空的对象

05:25.780 --> 05:26.780
一个空的对象

05:26.780 --> 05:28.780
那么有的时候会产生这样的问题

05:28.780 --> 05:29.780
也就是说这里

05:29.780 --> 05:31.780
也不是说完全

05:31.780 --> 05:33.780
特别是跟某些框架结合的时候

05:33.780 --> 05:35.780
也不是说完全是可选的

05:35.780 --> 05:36.780
你完全不用它

05:36.780 --> 05:37.780
那也不行

05:37.780 --> 05:38.780
因为这些框架

05:38.780 --> 05:40.780
它是这样子思考的

05:40.780 --> 05:42.780
你既然都使用了TS了

05:42.780 --> 05:44.780
那为什么不去使用它里面的一些

05:44.780 --> 05:45.780
特别好的东西

05:45.780 --> 05:46.780
为什么不去用呢

05:46.780 --> 05:48.780
因此它会在部分的地方

05:48.780 --> 05:50.780
对你进行一些强制性的要求

05:50.780 --> 05:51.780
比方说在React里面

05:51.780 --> 05:53.780
其实它并没有说强制要求

05:53.780 --> 05:55.780
但是实际上我们的开发过程中

05:55.780 --> 05:57.780
它会要求你对这个State

05:57.780 --> 06:00.780
或者是对这个Props进行一下约束

06:00.780 --> 06:01.780
OK

06:01.780 --> 06:03.780
但是实质上TS本身

06:03.780 --> 06:05.780
这个语言本身它是可选的

06:05.780 --> 06:07.780
它的理念是可选的

06:07.780 --> 06:10.780
并没有强制要求你做任何的事情

06:10.780 --> 06:12.780
OK 这是关于

06:12.780 --> 06:14.780
这个可选的这个概念

06:14.780 --> 06:16.780
下一个

06:16.780 --> 06:18.780
是静态的

06:19.780 --> 06:20.780
静态的

06:20.780 --> 06:21.780
我们知道TS

06:21.780 --> 06:23.780
它写的代码是需要经过

06:23.780 --> 06:24.780
编译的 对吧

06:24.780 --> 06:26.780
我们的TS代码

06:26.780 --> 06:28.780
需要经过编译

06:28.780 --> 06:29.780
编译

06:29.780 --> 06:31.780
那么形成最终的

06:31.780 --> 06:33.780
GS代码

06:33.780 --> 06:35.780
那么它的类型检查

06:35.780 --> 06:36.780
在哪个部分产生呢

06:36.780 --> 06:37.780
是在这个位置

06:37.780 --> 06:39.780
这个位置产生类型检查

06:39.780 --> 06:41.780
在我们写好TS代码过后

06:41.780 --> 06:43.780
在编译的时候

06:43.780 --> 06:45.780
来产生类型检查

06:45.780 --> 06:47.780
而不是在运行的过程中

06:47.780 --> 06:48.780
这是什么

06:48.780 --> 06:50.780
运行的是GS代码

06:50.780 --> 06:51.780
运行的是它

06:51.780 --> 06:52.780
而它运行的时候

06:52.780 --> 06:53.780
所有的类型检查

06:53.780 --> 06:54.780
全部已经消失了

06:54.780 --> 06:55.780
它不像一些

06:55.780 --> 06:56.780
后端语言

06:56.780 --> 06:57.780
比方说加瓦

06:57.780 --> 06:58.780
比方说SeaShop

06:58.780 --> 06:59.780
像这些语言

06:59.780 --> 07:00.780
它在运行的过程中

07:00.780 --> 07:02.780
仍然有类型检查

07:02.780 --> 07:03.780
但是呢

07:03.780 --> 07:05.780
TS里边它没有

07:05.780 --> 07:06.780
它在运行的过程中

07:06.780 --> 07:08.780
已经不存在了类型检查了

07:08.780 --> 07:09.780
它是在编译的时候

07:09.780 --> 07:11.780
产生类型检查

07:11.780 --> 07:13.780
这是关于什么叫做静态的

07:13.780 --> 07:14.780
把这个

07:14.780 --> 07:16.780
核心的点理解清楚

07:16.780 --> 07:17.780
TypeScript

07:17.780 --> 07:19.780
它到底能够做什么事情

07:19.780 --> 07:20.780
OK

07:20.780 --> 07:21.780
然后呢

07:21.780 --> 07:23.780
我们后边学习了一系列

07:23.780 --> 07:25.780
一系列关于TypeScript

07:25.780 --> 07:27.780
去如何来约束类型

07:27.780 --> 07:29.780
下面我们学习的是

07:29.780 --> 07:31.780
如何约束类型

07:31.780 --> 07:33.780
如何约束类型

07:33.780 --> 07:34.780
那么约束类型的时候呢

07:34.780 --> 07:35.780
实际上

07:35.780 --> 07:38.780
我们打上一个这个碗

07:38.780 --> 07:40.780
打上一个标题

07:40.780 --> 07:42.780
这个是概念

07:42.780 --> 07:44.780
这个概念部分

07:44.780 --> 07:45.780
好

07:45.780 --> 07:46.780
是这个点

07:46.780 --> 07:48.780
如何约束类型

07:48.780 --> 07:49.780
约束类型呢

07:49.780 --> 07:50.780
我们往往会约束这么几个点

07:50.780 --> 07:51.780
一个是变量

07:51.780 --> 07:53.780
一个是参数

07:53.780 --> 07:56.780
一个是寒数的返回值

07:56.780 --> 07:58.780
我们往往会约束这么几个点

07:58.780 --> 07:59.780
对变量进行约束

07:59.780 --> 08:01.780
对参数进行约束

08:01.780 --> 08:03.780
对寒数的返回值进行约束

08:03.780 --> 08:04.780
其实包括我们

08:04.780 --> 08:06.780
在境界部分的学学东西

08:06.780 --> 08:08.780
也逃不过这么几个地方

08:09.780 --> 08:11.780
只是在约束的时候呢

08:11.780 --> 08:13.780
有很多的约束方式

08:13.780 --> 08:14.780
我们通常呢

08:14.780 --> 08:15.780
分为这么几种

08:15.780 --> 08:17.780
一个是基本类型

08:17.780 --> 08:18.780
基本类型约束

08:18.780 --> 08:19.780
就是约束一个变量

08:19.780 --> 08:21.780
参数啊寒数的返回值

08:21.780 --> 08:22.780
它是一个基本类型

08:22.780 --> 08:23.780
比方说什么布尔

08:23.780 --> 08:24.780
啊

08:24.780 --> 08:25.780
Number啊

08:25.780 --> 08:26.780
师傅串啊

08:26.780 --> 08:27.780
这些基本类型

08:27.780 --> 08:28.780
就是结石里边

08:28.780 --> 08:29.780
它有的类型

08:29.780 --> 08:30.780
什么Object车

08:30.780 --> 08:31.780
一个普通对象

08:31.780 --> 08:32.780
以前的宿主

08:32.780 --> 08:33.780
宿主

08:33.780 --> 08:34.780
而为

08:34.780 --> 08:35.780
这些都是基本类型的约束

08:35.780 --> 08:36.780
包括了

08:36.780 --> 08:37.780
也讲到了

08:37.780 --> 08:38.780
里边有一些

08:38.780 --> 08:40.780
结石里面

08:40.780 --> 08:41.780
不怎么出现的类型

08:41.780 --> 08:42.780
或者是结石里面

08:42.780 --> 08:43.780
什么里没有的类型

08:43.780 --> 08:44.780
比方说Void

08:44.780 --> 08:45.780
Void呢

08:45.780 --> 08:46.780
它在结石里面有

08:46.780 --> 08:47.780
但它不是一个类型

08:47.780 --> 08:48.780
Void它不是一个类型

08:48.780 --> 08:49.780
它是集算一个表达式

08:49.780 --> 08:50.780
返回 onDefine

08:50.780 --> 08:52.780
无论这个表达式的结果是什么

08:52.780 --> 08:54.780
返回一定是 onDefine

08:54.780 --> 08:55.780
然后呢

08:55.780 --> 08:56.780
还有

08:56.780 --> 08:57.780
但是在TS里面Void的

08:57.780 --> 08:58.780
表示什么

08:58.780 --> 08:59.780
表示类型

08:59.780 --> 09:00.780
它约束的是类型

09:00.780 --> 09:01.780
它比方说

09:01.780 --> 09:02.780
我通常用于

09:02.780 --> 09:03.780
寒数的返回值

09:03.780 --> 09:04.780
没有返回值

09:04.780 --> 09:06.780
我们把它叫做Void

09:06.780 --> 09:07.780
没有返回值

09:07.780 --> 09:08.780
还有就是Never

09:08.780 --> 09:09.780
Never呢

09:09.780 --> 09:10.780
往往也是约束

09:10.780 --> 09:12.780
寒数的返回值的

09:12.780 --> 09:13.780
它表示什么意思呢

09:13.780 --> 09:14.780
表示这个寒数

09:14.780 --> 09:15.780
永远不会结束

09:15.780 --> 09:17.780
永远不会有终点

09:17.780 --> 09:18.780
比方说这个寒数

09:18.780 --> 09:19.780
它一定拨出一个错误

09:19.780 --> 09:20.780
或者说

09:20.780 --> 09:21.780
这个寒数

09:21.780 --> 09:22.780
它一定会有一个死循环

09:22.780 --> 09:23.780
永远不会结束的死循环

09:23.780 --> 09:25.780
那么就是Never类型

09:25.780 --> 09:26.780
这是一些

09:26.780 --> 09:28.780
咱们在学习TS的过程中

09:28.780 --> 09:29.780
使用了一些基本的类型

09:29.780 --> 09:30.780
对 还有两个

09:30.780 --> 09:31.780
还有一个

09:31.780 --> 09:33.780
空道和onDefine

09:33.780 --> 09:35.780
还有这么两个类型

09:35.780 --> 09:36.780
这两个类型呢

09:36.780 --> 09:38.780
它是所有类型的纸类型

09:38.780 --> 09:39.780
默认情况下

09:39.780 --> 09:40.780
这两个类型

09:40.780 --> 09:41.780
都是可以

09:41.780 --> 09:42.780
复制给其他类型的

09:42.780 --> 09:43.780
但是呢

09:43.780 --> 09:44.780
我们通常

09:44.780 --> 09:45.780
不希望这样做

09:45.780 --> 09:46.780
那么如果你希望

09:46.780 --> 09:48.780
更加严格的类型检查

09:48.780 --> 09:49.780
怎么办呢

09:49.780 --> 09:50.780
阳动做法

09:50.780 --> 09:51.780
现在我们知道了

09:51.780 --> 09:52.780
第一种做法就是

09:52.780 --> 09:53.780
把这个strict

09:53.780 --> 09:54.780
设为去

09:54.780 --> 09:55.780
这是更加严格

09:55.780 --> 09:56.780
对所有东西都去

09:56.780 --> 09:57.780
进行严格检查

09:57.780 --> 09:58.780
另外一种做法

09:58.780 --> 10:00.780
是单独去设置它

10:00.780 --> 10:01.780
strict

10:01.780 --> 10:02.780
now

10:02.780 --> 10:03.780
这个设为处

10:03.780 --> 10:04.780
那么就单独对

10:04.780 --> 10:05.780
nl类型

10:05.780 --> 10:06.780
和onDefine类型

10:06.780 --> 10:07.780
进行检查

10:07.780 --> 10:08.780
那么设为去过后

10:08.780 --> 10:10.780
onDefine和nl

10:10.780 --> 10:11.780
只能复制给

10:11.780 --> 10:12.780
他们自己的类型

10:12.780 --> 10:14.780
不能复制给其他类型了

10:14.780 --> 10:16.780
这是关于基本类型的点

10:16.780 --> 10:17.780
但是有了基本类型

10:17.780 --> 10:18.780
肯定是不够用的

10:18.780 --> 10:19.780
肯定是不够用的

10:19.780 --> 10:20.780
因此呢

10:20.780 --> 10:22.780
又做了一些扩展类型

10:22.780 --> 10:24.780
扩展类型

10:24.780 --> 10:26.780
扩展的类型里面就很多了

10:26.780 --> 10:27.780
其实也就四种

10:27.780 --> 10:29.780
一个是类型别名

10:29.780 --> 10:31.780
这是我们最开始讲的

10:31.780 --> 10:32.780
给一些类型

10:32.780 --> 10:34.780
给一些类型取个别名

10:34.780 --> 10:35.780
取个名字

10:35.780 --> 10:36.780
类型别名

10:36.780 --> 10:38.780
然后还有

10:38.780 --> 10:40.780
每句

10:40.780 --> 10:41.780
接口

10:41.780 --> 10:42.780
类

10:42.780 --> 10:44.780
这些都属于扩展类型

10:44.780 --> 10:46.780
就是以有的类型不够用了

10:46.780 --> 10:48.780
我们要产生一些新的类型

10:48.780 --> 10:49.780
这个类型

10:49.780 --> 10:51.780
都能够给它定一个名字

10:51.780 --> 10:52.780
你看这四个东西

10:52.780 --> 10:54.780
他们都有一个共同的特点

10:54.780 --> 10:55.780
就是可以取名字

10:55.780 --> 10:56.780
对吧

10:56.780 --> 10:57.780
就可以取名字

10:57.780 --> 10:59.780
那么他们之间有没有区别呢

10:59.780 --> 11:00.780
有区别

11:00.780 --> 11:02.780
比方从编译结构上来分的话

11:02.780 --> 11:04.780
类型别名

11:05.780 --> 11:06.780
和接口

11:06.780 --> 11:09.780
是不产生编译结构的

11:09.780 --> 11:12.780
它的编译结构里面是看不见的

11:12.780 --> 11:14.780
看不见任何的编译结构

11:14.780 --> 11:15.780
这是类型别名的特点

11:15.780 --> 11:17.780
然后呢

11:17.780 --> 11:19.780
每句

11:19.780 --> 11:21.780
每句和类

11:21.780 --> 11:23.780
会产生编译结构

11:23.780 --> 11:24.780
为什么呢

11:24.780 --> 11:25.780
每句这一块呢

11:25.780 --> 11:27.780
它是为了让你能够动态的

11:27.780 --> 11:29.780
读去它里面的所有的字段

11:29.780 --> 11:31.780
因此它产生的结构是什么

11:31.780 --> 11:32.780
产生的结构生类

11:32.780 --> 11:33.780
每句产生的结构是类

11:33.780 --> 11:34.780
而不是类

11:34.780 --> 11:35.780
是对象

11:35.780 --> 11:36.780
每句产生的结构

11:36.780 --> 11:37.780
经过编译

11:37.780 --> 11:39.780
产生的结构是什么

11:39.780 --> 11:40.780
是对象

11:40.780 --> 11:41.780
都是每句

11:41.780 --> 11:42.780
那么类呢

11:42.780 --> 11:44.780
因为GS里面本来就有类

11:44.780 --> 11:46.780
所以说我们TS里面写的类

11:46.780 --> 11:48.780
TS里面写的类

11:48.780 --> 11:49.780
产生的结构呢

11:49.780 --> 11:50.780
就是GS的类

11:50.780 --> 11:51.780
并没有什么区别

11:51.780 --> 11:52.780
当然

11:52.780 --> 11:53.780
这个还看你什么

11:53.780 --> 11:54.780
还看你的

11:54.780 --> 11:56.780
编译结构的标准

11:56.780 --> 11:58.780
你编译结构标准是ES6的话

11:58.780 --> 11:59.780
它就会给你产生一个类

11:59.780 --> 12:00.780
因为ES6过后

12:00.780 --> 12:01.780
它已经支持类了

12:01.780 --> 12:02.780
如果你的编译结构

12:02.780 --> 12:04.780
是ES6版本以下的话

12:04.780 --> 12:06.780
它会给你产生相应的构造函数

12:06.780 --> 12:08.780
总之GS里面

12:08.780 --> 12:09.780
它本身是支持类的

12:09.780 --> 12:11.780
所以说你TS的类

12:11.780 --> 12:13.780
它会产生到GS里面

12:13.780 --> 12:14.780
只不过类这里

12:14.780 --> 12:15.780
它会多一些

12:15.780 --> 12:16.780
TS中的类

12:16.780 --> 12:18.780
它会多一些能力

12:18.780 --> 12:19.780
比方说

12:19.780 --> 12:20.780
多了什么

12:20.780 --> 12:22.780
多了属性列表

12:22.780 --> 12:23.780
属性列表

12:23.780 --> 12:24.780
我们以前在GS里面

12:24.780 --> 12:25.780
属性是写到哪了

12:25.780 --> 12:27.780
写到构造函数里面了

12:27.780 --> 12:28.780
在构造函数里面

12:28.780 --> 12:30.780
动态的去给它生成一些属性

12:31.780 --> 12:32.780
刚刚创建的时候

12:32.780 --> 12:33.780
没有任何属性

12:33.780 --> 12:35.780
我们通过Z10.属性描

12:35.780 --> 12:36.780
给它复制

12:36.780 --> 12:38.780
就产生了一系列的属性

12:38.780 --> 12:39.780
但是TS里面

12:39.780 --> 12:40.780
它要求比较严格

12:40.780 --> 12:41.780
有哪些属性

12:41.780 --> 12:42.780
它必须要先罗列出来

12:42.780 --> 12:44.780
所以说TS里面

12:44.780 --> 12:45.780
它有个属性列表

12:45.780 --> 12:46.780
当然

12:46.780 --> 12:47.780
它属性里面

12:47.780 --> 12:49.780
多了一个访问修饰符

12:49.780 --> 12:51.780
或者叫做修饰符

12:51.780 --> 12:52.780
修饰符

12:52.780 --> 12:53.780
修饰符里面

12:53.780 --> 12:54.780
它分为两种

12:54.780 --> 12:56.780
我们目前学过两种

12:56.780 --> 12:57.780
一个是Red only

12:57.780 --> 12:59.780
Red only的范围用的很广

12:59.780 --> 13:01.780
它不仅仅是可以修饰

13:01.780 --> 13:02.780
内的属性

13:02.780 --> 13:03.780
可以修饰

13:03.780 --> 13:04.780
还可以修什么

13:04.780 --> 13:05.780
还可以修饰其他地方

13:05.780 --> 13:06.780
比方说

13:06.780 --> 13:08.780
一个字面亮对象

13:08.780 --> 13:09.780
它里面的属性

13:09.780 --> 13:11.780
也可以把它修饰成Red only

13:11.780 --> 13:13.780
比方说修饰一个数组

13:13.780 --> 13:14.780
数组是Red only

13:14.780 --> 13:15.780
那么这个数组

13:15.780 --> 13:16.780
内容里面

13:16.780 --> 13:17.780
它所有东西

13:17.780 --> 13:19.780
所有可变化的函数都不能使用了

13:19.780 --> 13:21.780
我们之前演示过了对吧

13:21.780 --> 13:22.780
这是Red only

13:22.780 --> 13:24.780
那么还有一种修饰符

13:24.780 --> 13:26.780
就是访问修饰符

13:26.780 --> 13:27.780
那么有哪些

13:27.780 --> 13:28.780
我们之前说过的

13:28.780 --> 13:31.780
有public表示公开的

13:31.780 --> 13:32.780
除了内知警

13:32.780 --> 13:34.780
其他的代码都可以访问

13:34.780 --> 13:36.780
默认就是公开的

13:36.780 --> 13:38.780
然后还有私有的

13:38.780 --> 13:40.780
只有内里边可以访问

13:40.780 --> 13:41.780
外边是不能访问的

13:41.780 --> 13:43.780
还有一个是protected

13:43.780 --> 13:44.780
protected

13:44.780 --> 13:45.780
我们现在还没有讲

13:45.780 --> 13:47.780
咱们在境界部分

13:47.780 --> 13:48.780
再去详细的说

13:48.780 --> 13:50.780
多了这么一些东西

13:50.780 --> 13:52.780
其实像我们当时讲内的时候

13:52.780 --> 13:54.780
还讲到了什么访问器

13:54.780 --> 13:55.780
还讲到访问器

13:55.780 --> 13:57.780
像访问器这个东西

13:57.780 --> 13:59.780
这是介石里本来就有的

13:59.780 --> 14:00.780
本来就有的

14:00.780 --> 14:01.780
所以说

14:01.780 --> 14:03.780
它也不是TSC的东西

14:03.780 --> 14:05.780
OK 这是关于扩展内容

14:05.780 --> 14:06.780
扩展内容

14:06.780 --> 14:07.780
只有两个东西

14:07.780 --> 14:08.780
会产生变因结果

14:08.780 --> 14:09.780
就是每一句和内

14:09.780 --> 14:11.780
内形别名和接口

14:11.780 --> 14:13.780
不产生变因结果

14:13.780 --> 14:15.780
那么关于内形别名和接口的区别

14:15.780 --> 14:16.780
我们在境界部分

14:16.780 --> 14:18.780
会详细的说

14:18.780 --> 14:19.780
那么现在

14:19.780 --> 14:21.780
你可以认为它没有区别

14:21.780 --> 14:23.780
或者说认为它区别不大

14:23.780 --> 14:25.780
你现在在基础部分

14:25.780 --> 14:27.780
你愿意使用接口

14:27.780 --> 14:28.780
就使用接口

14:28.780 --> 14:30.780
愿意使用别名就使用别名

14:30.780 --> 14:31.780
随便你

14:31.780 --> 14:32.780
这个无所谓的

14:32.780 --> 14:33.780
其实我个人习惯的话

14:33.780 --> 14:35.780
比较喜欢写这个接口

14:35.780 --> 14:36.780
看个人习惯

14:36.780 --> 14:37.780
但是在境界部分

14:37.780 --> 14:39.780
我们讲了之后就区别了

14:39.780 --> 14:40.780
好 这是关于

14:40.780 --> 14:42.780
如何进行内形约束

14:42.780 --> 14:44.780
以及它的一些内想

14:44.780 --> 14:45.780
约束的内想

14:45.780 --> 14:46.780
其实这也就是

14:46.780 --> 14:48.780
咱们学习TS的核心了

14:48.780 --> 14:50.780
我们学习TS学习到啥

14:50.780 --> 14:52.780
学习无非就是各种各样的内想

14:52.780 --> 14:53.780
我怎么去约束它

14:53.780 --> 14:54.780
我可以使用什么样的内想

14:54.780 --> 14:55.780
去约束它

14:55.780 --> 14:56.780
如果我要自定义的话

14:56.780 --> 14:58.780
我选择什么样的自定义内想

14:58.780 --> 14:59.780
去约束它

14:59.780 --> 15:00.780
比方说像这个美举

15:00.780 --> 15:01.780
美举用来约束啥的

15:01.780 --> 15:03.780
约束一个范围的曲子

15:03.780 --> 15:04.780
对吧

15:04.780 --> 15:05.780
约束一个范围的曲子

15:05.780 --> 15:07.780
它可以在某一个范围内

15:07.780 --> 15:08.780
取其中某一个值

15:08.780 --> 15:10.780
比方说咱们这个

15:10.780 --> 15:11.780
基础里面

15:11.780 --> 15:12.780
美举约束的是啥呢

15:12.780 --> 15:13.780
游戏状态

15:13.780 --> 15:15.780
是不是只有这四选一

15:15.780 --> 15:16.780
对不对

15:16.780 --> 15:17.780
四选一

15:17.780 --> 15:18.780
没有别的值的

15:18.780 --> 15:19.780
那么这种情况下

15:19.780 --> 15:20.780
就可以使用美举

15:20.780 --> 15:21.780
再比方说

15:21.780 --> 15:22.780
像这个

15:22.780 --> 15:24.780
一个旗子的内想

15:24.780 --> 15:25.780
没有旗子

15:25.780 --> 15:26.780
红方旗子

15:26.780 --> 15:27.780
黑方旗子

15:27.780 --> 15:28.780
只能三选一

15:28.780 --> 15:29.780
那我们可以使用美举

15:29.780 --> 15:31.780
它约束的是一个范围

15:31.780 --> 15:33.780
当然你可以使用内想别名

15:33.780 --> 15:34.780
也可以搞定

15:34.780 --> 15:35.780
其实内想别名的话

15:35.780 --> 15:37.780
它通用性更好

15:37.780 --> 15:39.780
几乎是可以搞定很多事情

15:39.780 --> 15:40.780
只不过

15:40.780 --> 15:41.780
它每一方面事情

15:41.780 --> 15:43.780
做的没有那么完善

15:43.780 --> 15:44.780
内想别名

15:44.780 --> 15:45.780
当时我们在讲美举的时候

15:45.780 --> 15:47.780
也给它做了一些对比

15:47.780 --> 15:48.780
内想别名

15:48.780 --> 15:50.780
它的什么不足

15:50.780 --> 15:52.780
它把真实的值

15:52.780 --> 15:54.780
和逻辑名称分开了

15:54.780 --> 15:56.780
你看美举里边

15:56.780 --> 15:58.780
这里真实的值是啥

15:58.780 --> 15:59.780
真实的值是0对吧

15:59.780 --> 16:01.780
真实的值是0

16:01.780 --> 16:03.780
浪只是逻辑意识

16:03.780 --> 16:04.780
逻辑含义

16:04.780 --> 16:05.780
真实的取值是啥

16:05.780 --> 16:06.780
其实并不重要

16:06.780 --> 16:08.780
逻辑含义不变就行了

16:08.780 --> 16:10.780
因此在自面量内想里边

16:10.780 --> 16:12.780
如果使用内想别名

16:12.780 --> 16:14.780
做自面量的联合内想的话

16:14.780 --> 16:16.780
那么就会导致这个问题

16:16.780 --> 16:18.780
真实的名称和逻辑名称

16:18.780 --> 16:20.780
逻辑名称重叠了

16:20.780 --> 16:22.780
当我们要去修改真实的值的时候

16:22.780 --> 16:23.780
它也跟着

16:23.780 --> 16:25.780
会把逻辑名称也修改了

16:25.780 --> 16:26.780
这会导致很多问题

16:26.780 --> 16:27.780
还有一个问题

16:27.780 --> 16:29.780
就是内想别名里边

16:29.780 --> 16:31.780
它是不参与别意的

16:31.780 --> 16:33.780
如果你要动态的读取有哪些

16:33.780 --> 16:36.780
我们取值范围有哪些就读不出来了

16:36.780 --> 16:38.780
这个点注意一下

16:40.780 --> 16:41.780
对了

16:41.780 --> 16:42.780
之前说的既然说到这

16:42.780 --> 16:44.780
还有两个东西对吧

16:44.780 --> 16:45.780
它不属于基本内想

16:45.780 --> 16:47.780
但是我们也经常用

16:47.780 --> 16:49.780
说像自面量内想

16:49.780 --> 16:50.780
自面量内想

16:50.780 --> 16:52.780
我们直接给它一个自面量

16:52.780 --> 16:53.780
给它一个字幕串

16:53.780 --> 16:55.780
比方说我们之前写代码的时候

16:55.780 --> 16:56.780
不这样写吗

16:56.780 --> 16:58.780
一个变量

16:58.780 --> 16:59.780
剪刀

16:59.780 --> 17:01.780
拿个自面量

17:01.780 --> 17:02.780
蓝

17:02.780 --> 17:03.780
或者是自面量

17:03.780 --> 17:04.780
女

17:04.780 --> 17:05.780
对吧

17:05.780 --> 17:06.780
我们之前是这样写的

17:06.780 --> 17:07.780
那么表示

17:07.780 --> 17:08.780
这个变量

17:08.780 --> 17:09.780
它要么取之为蓝

17:09.780 --> 17:10.780
要么取之为女

17:10.780 --> 17:12.780
你看这两个内想

17:12.780 --> 17:13.780
这两个内想

17:13.780 --> 17:15.780
就是自面量内想

17:15.780 --> 17:17.780
它不是说直接把它

17:17.780 --> 17:19.780
作为自幕串内想

17:19.780 --> 17:20.780
它是自面量

17:20.780 --> 17:22.780
它只能取之为这个

17:22.780 --> 17:24.780
或取之为这个

17:24.780 --> 17:26.780
中间使用了一个联合内想

17:26.780 --> 17:28.780
也就是它不能取之为

17:28.780 --> 17:29.780
其他的自幕串

17:29.780 --> 17:30.780
这是自面量内想

17:30.780 --> 17:32.780
和自面量内想

17:32.780 --> 17:33.780
很多时候

17:33.780 --> 17:37.780
会配合联合内想

17:37.780 --> 17:38.780
使用

17:38.780 --> 17:40.780
达到类似于

17:40.780 --> 17:42.780
没举的效果

17:42.780 --> 17:44.780
当然也只是类似

17:44.780 --> 17:46.780
当然没举的效果

17:46.780 --> 17:47.780
肯定要比它强得多

17:47.780 --> 17:49.780
因为没举是专门来做

17:49.780 --> 17:50.780
范围取之的

17:50.780 --> 17:52.780
某个范围里取一个之

17:52.780 --> 17:53.780
这是自面量内想

17:53.780 --> 17:54.780
当然自面量内想

17:54.780 --> 17:55.780
还有一些其他的用法

17:55.780 --> 17:57.780
比方说对象自面量

17:57.780 --> 17:58.780
对象自面量也是一些

17:58.780 --> 17:59.780
常见的用法

17:59.780 --> 18:00.780
对象自面量

18:00.780 --> 18:02.780
可以更加

18:02.780 --> 18:04.780
细化的约束

18:04.780 --> 18:06.780
一个对象

18:06.780 --> 18:08.780
当你使用内想别名的时候

18:08.780 --> 18:09.780
往往使用的就是

18:09.780 --> 18:11.780
对象自面量

18:11.780 --> 18:12.780
然后咱们之前有些代码

18:12.780 --> 18:13.780
怎么写的

18:13.780 --> 18:16.410
这样写的

18:16.410 --> 18:17.410
就Type

18:17.410 --> 18:19.410
比方说有一个User

18:19.410 --> 18:21.410
约束一个User

18:21.410 --> 18:23.410
然后它里面Name属性

18:23.410 --> 18:26.410
必须为A级

18:26.410 --> 18:27.410
必须为Number

18:27.410 --> 18:28.410
这就是一个自面量内想

18:28.410 --> 18:30.410
一个对象自面量

18:30.410 --> 18:31.410
对象自面量

18:31.410 --> 18:32.410
还约束它

18:32.410 --> 18:33.410
你的姓名

18:33.410 --> 18:34.410
有这么两个属性

18:34.410 --> 18:36.410
姓名必须是支付串

18:36.410 --> 18:38.410
年龄必须是Number

18:39.410 --> 18:41.410
这是关于内想的约束

18:41.410 --> 18:42.410
内想的约束

18:42.410 --> 18:43.410
在内想约束

18:43.410 --> 18:44.410
约束后边

18:44.410 --> 18:46.410
有一个东西

18:46.410 --> 18:48.410
我专门拿了一节课的时间来讲

18:48.410 --> 18:50.410
就是关于反想

18:51.410 --> 18:52.410
反想这么东西

18:52.410 --> 18:53.410
它处理的是什么问题的

18:53.410 --> 18:55.410
解决的是什么问题的

18:55.410 --> 18:57.410
它是解除

18:57.410 --> 19:01.410
某个功能和内想的

19:01.410 --> 19:02.410
偶和

19:02.410 --> 19:04.410
这说的高大上一点

19:04.410 --> 19:05.410
这个话说的比较高大上

19:05.410 --> 19:06.410
但是实际上

19:06.410 --> 19:07.410
我们心里面知道

19:07.410 --> 19:08.410
它怎么意识就行了

19:08.410 --> 19:10.410
就是我们开发一个功能的时候

19:10.410 --> 19:12.410
可能需要用到某个内想

19:12.410 --> 19:13.410
但是呢

19:13.410 --> 19:15.410
我们具体写单码的过程中

19:15.410 --> 19:17.410
跟这个内想好像没有什么关系

19:18.410 --> 19:19.410
偶和什么意思

19:19.410 --> 19:20.410
偶和就是联系

19:20.410 --> 19:22.410
要把这个关系要断开

19:22.410 --> 19:24.410
那么就其实就要使用反想

19:24.410 --> 19:26.410
这个说到其实还是比较抽象

19:26.410 --> 19:27.410
还是比较抽象

19:27.410 --> 19:30.410
那我们利用我们之前说的那个

19:30.410 --> 19:31.410
当时我们内想内做

19:31.410 --> 19:32.410
不是做了一个练习吗

19:32.410 --> 19:33.410
对吧

19:33.410 --> 19:34.410
我们看一下那个练习

19:34.410 --> 19:35.410
我们随便建一个文件

19:35.410 --> 19:36.410
Test

19:36.410 --> 19:37.410
Test

19:37.410 --> 19:38.410
随便建个文件

19:38.410 --> 19:39.410
那么来

19:39.410 --> 19:41.410
稍微的写下伟大吧

19:41.410 --> 19:43.410
当时我们做了一个class内

19:43.410 --> 19:44.410
对吧

19:44.410 --> 19:45.410
给他做了一个名字

19:45.410 --> 19:46.410
叫做dexing而已

19:46.410 --> 19:48.410
就是我们的字点

19:48.410 --> 19:49.410
倒出了

19:49.410 --> 19:50.410
当然我现在肯定不会

19:50.410 --> 19:51.410
把代码重新写一遍

19:51.410 --> 19:53.410
只是大概说一下

19:53.410 --> 19:54.410
就这个字点里边

19:54.410 --> 19:56.410
我们要保存它的所有的件

19:56.410 --> 19:57.410
所谓的件

19:57.410 --> 19:59.410
它是一个竖竹

19:59.410 --> 20:00.410
Test

20:00.410 --> 20:02.410
是一个竖竹

20:02.410 --> 20:03.410
把约束一下

20:03.410 --> 20:04.410
然后呢

20:04.410 --> 20:06.410
只莫认为空竖竹吧

20:06.410 --> 20:08.410
然后它的只

20:08.410 --> 20:09.410
Values

20:09.410 --> 20:10.410
它也是一个竖竹

20:10.410 --> 20:11.410
一个保存件

20:11.410 --> 20:12.410
一个保存值

20:12.410 --> 20:13.410
对吧

20:13.410 --> 20:14.410
然后呢

20:14.410 --> 20:15.410
这里面有些函数

20:15.410 --> 20:16.410
对不对

20:16.410 --> 20:17.410
有些函数添加一个件

20:17.410 --> 20:19.410
或者是设置一个件

20:19.410 --> 20:20.410
key

20:20.410 --> 20:21.410
n

20:21.410 --> 20:22.410
z

20:22.410 --> 20:23.410
n

20:24.410 --> 20:26.410
如果你不做约束的话

20:26.410 --> 20:27.410
如果不做约束的话

20:27.410 --> 20:28.410
可以全部n

20:28.410 --> 20:30.410
当然这就失去了

20:30.410 --> 20:31.410
内型检查的好处

20:31.410 --> 20:32.410
比方说这里

20:32.410 --> 20:33.410
明面是一个

20:33.410 --> 20:34.410
字不算数组

20:34.410 --> 20:35.410
但是你这里传那个数字

20:35.410 --> 20:36.410
它就检查不到

20:36.410 --> 20:37.410
因为它不知道

20:37.410 --> 20:39.410
这两个地方有关系

20:39.410 --> 20:40.410
因此呢

20:40.410 --> 20:41.410
也就说我们操作一个字点的时候

20:41.410 --> 20:43.410
实际上是需要两个内型的

20:43.410 --> 20:44.410
需要两个内型

20:44.410 --> 20:45.410
需要哪两个内型呢

20:45.410 --> 20:47.410
一个是件的内型

20:47.410 --> 20:48.410
一个是值的内型

20:48.410 --> 20:49.410
但是呢

20:49.410 --> 20:50.410
我又不是很care

20:50.410 --> 20:51.410
我又不是很关心

20:51.410 --> 20:53.410
你件到底是什么内型

20:53.410 --> 20:55.410
你的值到底是什么内型

20:55.410 --> 20:56.410
我只是

20:56.410 --> 20:58.410
希望值到有两个内型就行了

20:58.410 --> 20:59.410
懂这个意思吗

20:59.410 --> 21:01.410
这个好好去理解一下

21:01.410 --> 21:04.410
就是说我在开发这个字点的过程中

21:04.410 --> 21:06.410
管理这个key是什么内型

21:06.410 --> 21:08.410
管理这个值是什么内型

21:08.410 --> 21:09.410
内型的代码都是一样的

21:09.410 --> 21:10.410
你想这个道理啊

21:10.410 --> 21:11.410
写的过程

21:11.410 --> 21:12.410
当时我们写这个内的代码

21:12.410 --> 21:13.410
无论它是什么内型

21:13.410 --> 21:14.410
写的代码是不是一样的

21:14.410 --> 21:15.410
对不对

21:16.410 --> 21:17.410
某个功能

21:17.410 --> 21:19.410
就是我要实现一个字点的功能

21:19.410 --> 21:22.410
跟内型之间它有联系

21:22.410 --> 21:23.410
有联系

21:23.410 --> 21:25.410
但是如果我这里把定时的

21:25.410 --> 21:26.410
实讯

21:26.410 --> 21:28.410
定时的为number的话

21:28.410 --> 21:30.410
那么它就无法变化了

21:30.410 --> 21:31.410
它就把它依赖死了

21:31.410 --> 21:32.410
它以后呢

21:32.410 --> 21:33.410
这个字点

21:33.410 --> 21:34.410
它只能依赖一字幅串

21:34.410 --> 21:35.410
和数字

21:35.410 --> 21:37.410
它就没办法去适应

21:37.410 --> 21:38.410
其他内型了

21:38.410 --> 21:39.410
但是这个具体的内型

21:39.410 --> 21:41.410
跟我们的功能写的代码

21:41.410 --> 21:43.410
就不会有影响

21:43.410 --> 21:45.410
但是我又同时又需要的两个内型

21:45.410 --> 21:46.410
好好体会一下

21:46.410 --> 21:48.410
因此呢

21:48.410 --> 21:50.410
为了解除

21:50.410 --> 21:52.410
这个功能跟内型之间的

21:52.410 --> 21:53.410
这种联系把它断开

21:53.410 --> 21:55.410
我们只需要两个变量就行了

21:55.410 --> 21:57.410
这两个变量分别来代表

21:57.410 --> 21:59.410
建的内型和直的内型

21:59.410 --> 22:01.410
代表它的内型就行了

22:01.410 --> 22:02.410
具体的用的时候

22:02.410 --> 22:04.410
给我传一个内型进来就行了

22:04.410 --> 22:06.410
我反正实现代码的时候

22:06.410 --> 22:08.410
也不care你到底是什么内型

22:08.410 --> 22:10.410
但是我又需要这两个内型

22:10.410 --> 22:12.410
就好好去理解一下吧

22:12.410 --> 22:14.410
OK那么这里呢

22:14.410 --> 22:16.410
KV对吧

22:16.410 --> 22:18.410
这里内型就把关联起来了

22:18.410 --> 22:20.410
通过这个变量K就把关联起来了

22:20.410 --> 22:21.410
那么到时候用的时候呢

22:21.410 --> 22:22.410
就可以去使

22:22.410 --> 22:24.410
给它传递具体的内型

22:24.410 --> 22:25.410
OK

22:25.410 --> 22:27.410
这是关于翻译上这一块

22:27.410 --> 22:29.410
翻译上这一块

22:29.410 --> 22:30.410
好后边呢

22:30.410 --> 22:31.410
我们在技术部分呢

22:31.410 --> 22:33.410
还讲到了一个特别特别重要的一个

22:33.410 --> 22:35.410
就是内型兼容性

22:35.410 --> 22:37.410
内型兼容性

22:37.410 --> 22:39.410
当时呢我们通过

22:39.410 --> 22:41.410
这么一个东西展开的

22:41.410 --> 22:43.410
就是压子变形法

22:43.410 --> 22:46.720
分辨

22:46.720 --> 22:47.720
压子变形法

22:47.720 --> 22:48.720
什么意思呢

22:48.720 --> 22:50.720
或者叫做指结构

22:50.720 --> 22:52.720
指结构

22:52.720 --> 22:53.720
分辨

22:53.720 --> 22:55.720
字不好好打啊

22:55.720 --> 22:57.720
变形法

22:57.720 --> 22:59.720
当时我们是这样说的

22:59.720 --> 23:00.720
我头上给大家听了一下

23:00.720 --> 23:02.720
这个压子叫对吧

23:02.720 --> 23:04.720
就这个

23:04.720 --> 23:05.720
说的怎么意思呢

23:05.720 --> 23:06.720
就是说

23:06.720 --> 23:07.720
很多时候呢

23:07.720 --> 23:08.720
我们去看待一个东西

23:08.720 --> 23:10.720
它是不是满足要求的时候呢

23:10.720 --> 23:11.720
我们并不是很care

23:11.720 --> 23:13.720
它到底是一个什么东西

23:13.720 --> 23:15.720
它只要具有某些特征就行了

23:15.720 --> 23:17.720
比方说我这个系统里边

23:17.720 --> 23:19.720
我们系统是怎么看待一只压子的

23:19.720 --> 23:20.720
可能它只需要看待

23:20.720 --> 23:21.720
它能不能呱呱叫

23:21.720 --> 23:22.720
呱呱叫

23:22.720 --> 23:23.720
不是呱呱叫

23:23.720 --> 23:24.720
呱呱叫

23:24.720 --> 23:25.720
能不能游泳

23:25.720 --> 23:27.720
只要满足这两个特征

23:27.720 --> 23:29.720
我就认为它是一只压子

23:29.720 --> 23:31.720
而不用去关心它具体是什么东西

23:31.720 --> 23:32.720
其实这种方式呢

23:32.720 --> 23:34.720
在某一些语言里面

23:34.720 --> 23:35.720
它使用的就是这种方式

23:35.720 --> 23:36.720
来分辨内形

23:36.720 --> 23:37.720
在TS里面

23:37.720 --> 23:38.720
它使用的就是这种

23:38.720 --> 23:41.720
它是根据它的特征来进行分辨的

23:41.720 --> 23:44.720
而不是根据它的含义

23:44.720 --> 23:45.720
比方说我是人

23:45.720 --> 23:46.720
我的含义是一个人

23:46.720 --> 23:47.720
我怎么能是压子呢

23:47.720 --> 23:48.720
但是我只要能呱呱叫

23:48.720 --> 23:49.720
我会游泳

23:49.720 --> 23:50.720
就可以把我看待压子

23:50.720 --> 23:51.720
看成压子

23:51.720 --> 23:53.720
根据我的特征来进行分辨的

23:53.720 --> 23:55.720
当然这个

23:55.720 --> 23:57.720
这个为什么会形成

23:57.720 --> 23:59.720
这样的一种分辨内形的方式

23:59.720 --> 24:01.720
它的成因是比较复杂的

24:01.720 --> 24:03.720
它跟那个

24:03.720 --> 24:06.720
TS是静态化的内形检查

24:06.720 --> 24:07.720
是有关系的

24:07.720 --> 24:08.720
并且还给我们

24:08.720 --> 24:09.720
以前使用GS

24:09.720 --> 24:11.720
做开发的时候

24:11.720 --> 24:12.720
一些开发习惯有关系

24:12.720 --> 24:13.720
因此呢

24:13.720 --> 24:15.720
它微软经过再上的考虑

24:15.720 --> 24:17.720
最终选择了这种

24:17.720 --> 24:19.720
分辨内形的方式

24:19.720 --> 24:20.720
实际上的内形兼容性

24:20.720 --> 24:21.720
这一块

24:21.720 --> 24:23.720
我们在书写TS代码的时候

24:23.720 --> 24:25.720
最好的内形兼容性是什么

24:25.720 --> 24:27.720
就是你感觉不到它的存在

24:27.720 --> 24:29.720
你感觉一切都是自然发生的

24:29.720 --> 24:30.720
而TS呢

24:30.720 --> 24:32.720
其实就给我们的是这种感觉

24:32.720 --> 24:34.720
就算我当时不讲内形兼容性

24:34.720 --> 24:35.720
为什么要讲

24:35.720 --> 24:37.720
是因为面试的时候容易问到

24:37.720 --> 24:38.720
特别容易问到

24:38.720 --> 24:40.720
所以说我这里把它讲了

24:40.720 --> 24:41.720
而且呢

24:41.720 --> 24:42.720
对大家理解TS呢

24:42.720 --> 24:44.720
也非常有好处

24:44.720 --> 24:46.720
提高大家那一种

24:46.720 --> 24:47.720
就是什么

24:47.720 --> 24:48.720
视野

24:48.720 --> 24:50.720
扩张一下视野也非常有好处

24:50.720 --> 24:51.720
当时呢

24:51.720 --> 24:53.720
我们是举了三个地方对吧

24:53.720 --> 24:54.720
一个是基本内形

24:54.720 --> 24:55.720
基本内形的话

24:55.720 --> 24:56.720
就必须要完全匹配了

24:56.720 --> 24:58.720
你都基本内形的还能再拆分吗

24:58.720 --> 25:00.720
必须要完全匹配

25:00.720 --> 25:02.720
然后呢是对象内形

25:02.720 --> 25:03.720
对象内形

25:03.720 --> 25:04.720
对象内形之间匹配的

25:04.720 --> 25:06.720
使用的是压纸边形化

25:06.720 --> 25:07.720
但是这里大家要注意啊

25:07.720 --> 25:09.720
有个地方会有更严格的检查

25:09.720 --> 25:11.720
但是我们也举了个例子

25:11.720 --> 25:12.720
就是

25:12.720 --> 25:14.720
字面量对象

25:14.720 --> 25:16.720
直接传递

25:16.720 --> 25:18.720
直接传递的时候

25:18.720 --> 25:20.720
是

25:20.720 --> 25:22.720
会有更严格的

25:22.720 --> 25:24.720
内形检查

25:24.720 --> 25:26.720
那个时候就不能让你

25:26.720 --> 25:27.720
多出一些属性

25:27.720 --> 25:29.720
因为他认为你都直接传递了

25:29.720 --> 25:31.720
你那边就是要求你有这个内形

25:31.720 --> 25:32.720
你这个时候是直接起来

25:32.720 --> 25:33.720
字面量对象

25:33.720 --> 25:34.720
是自己招出来的对象

25:34.720 --> 25:35.720
那没有必要

25:35.720 --> 25:36.720
不匹配啊

25:36.720 --> 25:38.720
不匹配有什么意义呢

25:38.720 --> 25:39.720
那是不是纯道乱吗

25:39.720 --> 25:40.720
所以说他认为

25:40.720 --> 25:41.720
这个地方是没有必要去

25:41.720 --> 25:42.720
不去匹配的

25:42.720 --> 25:43.720
因此呢

25:43.720 --> 25:45.720
还有更严格的内形检查

25:45.720 --> 25:46.720
如果你这个对象是来自于

25:46.720 --> 25:47.720
其他函数调用的

25:47.720 --> 25:48.720
或者是来自于一个辩量

25:48.720 --> 25:50.720
他认为这个辩量的值

25:50.720 --> 25:51.720
你是不好控制的

25:51.720 --> 25:52.720
因为你可能是掉了

25:52.720 --> 25:53.720
其他函

25:53.720 --> 25:54.720
那么他这个时候的

25:54.720 --> 25:55.720
使用压制变形法

25:55.720 --> 25:56.720
原来对于什么

25:56.720 --> 25:57.720
它是一模森数数率的

25:57.720 --> 25:58.720
而另外一个呢

25:58.720 --> 25:59.720
就是关于函数

25:59.720 --> 26:01.720
函数内形的匹配

26:01.720 --> 26:03.720
函数内形的匹配呢

26:03.720 --> 26:05.720
一切都无必自然就完了

26:05.720 --> 26:06.720
一切无必自然

26:06.720 --> 26:08.720
就是说参数

26:08.720 --> 26:09.720
参数数量

26:09.720 --> 26:10.720
可以少

26:10.720 --> 26:12.720
但不可以多

26:12.720 --> 26:13.720
不可以多

26:13.720 --> 26:15.720
很多时候都产生

26:15.720 --> 26:17.720
都产生在毁掉函数那一块

26:17.720 --> 26:19.720
他要求毁掉函数有两个参数

26:19.720 --> 26:20.720
你可不可以写一个

26:20.720 --> 26:21.720
可以写一个

26:21.720 --> 26:22.720
没问题

26:23.720 --> 26:24.720
你给我两个参数

26:24.720 --> 26:25.720
但是我用不到两个

26:25.720 --> 26:26.720
我只需要用一个

26:26.720 --> 26:27.720
可不可以呢

26:27.720 --> 26:28.720
当然没问题

26:28.720 --> 26:29.720
但是你不能多你多了

26:29.720 --> 26:30.720
有什么意义呢

26:30.720 --> 26:31.720
他也不可能比方说

26:31.720 --> 26:33.720
他只有两个参数

26:33.720 --> 26:34.720
毁掉函数

26:34.720 --> 26:35.720
要求你传两个参数

26:35.720 --> 26:37.720
一个一个给我传三个参数

26:37.720 --> 26:38.720
那第三个参数

26:38.720 --> 26:39.720
是不是一定是安里凡

26:39.720 --> 26:40.720
那有什么意义呢

26:40.720 --> 26:41.720
没有任何意义

26:41.720 --> 26:43.720
所以说他不予去读

26:43.720 --> 26:45.720
返回只这一块呢

26:45.720 --> 26:48.720
要求返回必须返回

26:48.720 --> 26:49.720
这个没什么好说的

26:49.720 --> 26:50.720
他让你返回

26:50.720 --> 26:51.720
说明他要用这个东西

26:51.720 --> 26:52.720
你不返回他怎么用了

26:52.720 --> 26:54.720
他就必须要返回

26:54.720 --> 26:55.720
不要求返回

26:55.720 --> 26:57.720
就是返回是弱的

26:57.720 --> 26:58.720
他反正不用

26:58.720 --> 26:59.720
你随意

26:59.720 --> 27:00.720
当时我就这样说了

27:00.720 --> 27:01.720
你随意

27:01.720 --> 27:02.720
所以说这里呢

27:02.720 --> 27:04.720
是经过生死属虑的

27:04.720 --> 27:07.720
按照我们以前介绍的那种开发习惯

27:07.720 --> 27:09.720
不打破我们的开发习惯

27:09.720 --> 27:12.720
并且同时给你加上内询简畅

27:12.720 --> 27:13.720
这是关于内询

27:13.720 --> 27:15.720
他的兼容性这一块

27:15.720 --> 27:17.720
当然还顺

27:17.720 --> 27:18.720
这些我们基础部分

27:18.720 --> 27:19.720
还说到了一些

27:19.720 --> 27:20.720
细致漠结的东西

27:20.720 --> 27:23.720
比方说还有什么内询断言

27:23.720 --> 27:24.720
对不对

27:24.720 --> 27:25.720
内询断言

27:25.720 --> 27:26.720
断言

27:26.720 --> 27:28.720
就是有的时候了

27:28.720 --> 27:31.720
开发者非常清楚某个东西的内想

27:31.720 --> 27:35.720
开发者非常清楚

27:35.720 --> 27:39.720
清楚某个东西的内想

27:39.720 --> 27:42.720
但是TS

27:42.720 --> 27:43.720
难以分辨

27:43.720 --> 27:45.720
他分辨不出来

27:45.720 --> 27:46.720
分辨不出来这种内想

27:46.720 --> 27:47.720
那么这个时候

27:47.720 --> 27:49.720
开发者可以手动地指定内想

27:49.720 --> 27:54.720
开发者可以通过内想断言

27:54.720 --> 27:56.720
高速TS

27:56.720 --> 28:00.720
这里的确切内想是什么

28:00.720 --> 28:03.720
其实这个点经常发生在哪呢

28:03.720 --> 28:07.720
经常发生在阿加克斯请求

28:07.720 --> 28:09.720
比方说给他一个例子吧

28:09.720 --> 28:11.720
比方就这吧

28:11.720 --> 28:15.720
假设这里有这么一个

28:15.720 --> 28:18.720
我们要从服务器去请求

28:18.720 --> 28:20.720
得到一系列的用户对象

28:20.720 --> 28:22.720
那么服务器返回的结果

28:22.720 --> 28:24.720
是这么一个内想

28:24.720 --> 28:25.720
用interface电影一下

28:25.720 --> 28:26.720
优热

28:26.720 --> 28:28.720
服务器返回的是包含了

28:28.720 --> 28:30.720
优热的ID是一个制服圈

28:30.720 --> 28:33.720
然后用户的帐号

28:33.720 --> 28:35.720
逻辑ID是一个制服圈

28:35.720 --> 28:37.720
用户的密码逻辑Password

28:37.720 --> 28:38.720
是一个制服圈

28:38.720 --> 28:39.720
他又爆出了

28:39.720 --> 28:41.720
他必须要求我们这里是模块

28:41.720 --> 28:44.720
到处吧

28:44.720 --> 28:46.720
那么这里有个函数

28:46.720 --> 28:48.720
比如说有个函数叫fetch

28:48.720 --> 28:50.720
或者叫request

28:50.720 --> 28:52.720
请求

28:52.720 --> 28:54.720
给我我去请求所谓的用户

28:54.720 --> 28:56.720
或者叫getusers

28:56.720 --> 28:58.720
请求所谓的用户

28:58.720 --> 28:59.720
那么请求的时候

28:59.720 --> 29:01.720
我们调用函调用fetch对吧

29:01.720 --> 29:04.720
传一个UI比方说随便写

29:04.720 --> 29:05.720
请求用户

29:05.720 --> 29:07.720
请求用户过后

29:07.720 --> 29:09.720
得到一个结果

29:09.720 --> 29:11.720
服务器的响应过后

29:11.720 --> 29:13.720
我把它节省格式化

29:13.720 --> 29:15.720
得到节省格式

29:15.720 --> 29:18.720
是得到服务器的消息体中

29:18.720 --> 29:19.720
把服务器的消息体

29:19.720 --> 29:21.720
进行节省解析

29:21.720 --> 29:22.720
这也是个异部的

29:22.720 --> 29:25.720
然后继续使用Z

29:26.720 --> 29:28.720
得到服务器最终的

29:28.720 --> 29:30.720
节省格式的结果

29:30.720 --> 29:32.720
那么这个节省啥类型呢

29:32.720 --> 29:33.720
节省是N里

29:33.720 --> 29:35.720
他为什么不能知道

29:35.720 --> 29:38.720
我们服务器返回的是用户呢

29:38.720 --> 29:39.720
他又不是神仙

29:39.720 --> 29:40.720
他怎么可能知道

29:40.720 --> 29:41.720
他又没发

29:41.720 --> 29:42.720
这里没有运行

29:42.720 --> 29:43.720
他并没有运行

29:43.720 --> 29:44.720
这是在开发过程中

29:44.720 --> 29:45.720
他怎么知道这个结果

29:45.720 --> 29:47.720
会返回一个用户呢

29:47.720 --> 29:48.720
他怎么知道返回的

29:48.720 --> 29:49.720
就是这个类型呢

29:49.720 --> 29:50.720
他不知道

29:50.720 --> 29:52.720
但是我们是不是非常清楚

29:52.720 --> 29:53.720
因为我们这边

29:53.720 --> 29:55.720
跟服务器之间交互

29:55.720 --> 29:57.720
有约束的

29:57.720 --> 29:59.720
跟后端是有交流

29:59.720 --> 30:00.720
是有约束的

30:00.720 --> 30:01.720
我们非常清楚

30:01.720 --> 30:02.720
这里就是一个用户

30:02.720 --> 30:03.720
因此呢

30:03.720 --> 30:05.720
我们可以使用类型断言

30:05.720 --> 30:06.720
高速TS

30:06.720 --> 30:07.720
就在这里

30:07.720 --> 30:08.720
你需要把哪里断言

30:08.720 --> 30:09.720
成什么个类型

30:09.720 --> 30:10.720
你就要哪里写

30:10.720 --> 30:11.720
在这个位置

30:11.720 --> 30:12.720
我们直接写上

30:12.720 --> 30:13.720
U字

30:13.720 --> 30:15.720
直接写上个2字U字

30:15.720 --> 30:16.720
把它扩一下

30:16.720 --> 30:17.720
扩起来

30:19.720 --> 30:20.720
不对

30:20.720 --> 30:21.720
怎么来到这里写

30:21.720 --> 30:22.720
这里是参数位置

30:22.720 --> 30:23.720
要这里写

30:23.720 --> 30:24.720
这里写

30:24.720 --> 30:25.720
比方说

30:25.720 --> 30:26.720
我们再定个辩量吧

30:26.720 --> 30:27.720
U

30:27.720 --> 30:28.720
接上20U字

30:30.720 --> 30:31.720
那么

30:31.720 --> 30:32.720
现在看这个辩量U

30:32.720 --> 30:33.720
看这个辩量U

30:33.720 --> 30:34.720
是不是就是U的类型

30:34.720 --> 30:36.720
就是我们非常清楚

30:36.720 --> 30:37.720
我们非常清楚

30:37.720 --> 30:38.720
这里呢

30:38.720 --> 30:39.720
就是一个用户

30:39.720 --> 30:41.720
它就是一个用户

30:41.720 --> 30:42.720
因为我们

30:42.720 --> 30:43.720
可以去访问这个解口区

30:43.720 --> 30:44.720
试一下

30:44.720 --> 30:45.720
但是TS

30:45.720 --> 30:46.720
它没法去试

30:46.720 --> 30:47.720
它不知道

30:47.720 --> 30:48.720
它能推断出来

30:48.720 --> 30:49.720
只能是N你

30:49.720 --> 30:50.720
像有些时候

30:50.720 --> 30:51.720
TS它推断不出来

30:51.720 --> 30:52.720
它已经进入了

30:52.720 --> 30:53.720
它推断不出来

30:53.720 --> 30:54.720
那么我们可以手动的

30:54.720 --> 30:55.720
告诉它

30:55.720 --> 30:57.720
这里确实是某个类型

30:57.720 --> 30:58.720
当然你不要

30:58.720 --> 30:59.720
太过于依赖

30:59.720 --> 31:00.720
类型断言

31:00.720 --> 31:01.720
有的时候

31:01.720 --> 31:02.720
你自己还没有TS聪明

31:02.720 --> 31:03.720
你还没有TS信心

31:03.720 --> 31:05.720
这是常有的事

31:05.720 --> 31:06.720
TS它的类型简单

31:06.720 --> 31:08.720
是具有强制性的

31:08.720 --> 31:09.720
而且是非常

31:09.720 --> 31:10.720
比较的完善的

31:10.720 --> 31:11.720
因此有很多时候

31:11.720 --> 31:13.720
你不要去太过于依赖它

31:13.720 --> 31:14.720
不要说

31:14.720 --> 31:15.720
这里包错了

31:15.720 --> 31:16.720
我马上使用类型断言

31:16.720 --> 31:17.720
那样子的话

31:17.720 --> 31:18.720
反而非常危险

31:18.720 --> 31:19.720
你用类型断言的时候

31:19.720 --> 31:20.720
要考虑清楚

31:20.720 --> 31:21.720
这里确实我

31:21.720 --> 31:23.720
特别清楚它是什么类型

31:23.720 --> 31:24.720
再去进行断言

31:24.720 --> 31:25.720
这样子

31:25.720 --> 31:26.720
TS

31:26.720 --> 31:27.720
就会按照我们

31:27.720 --> 31:28.720
书写的类型

31:28.720 --> 31:30.720
来进行检查

31:30.720 --> 31:31.720
它就知道这个东西

31:31.720 --> 31:32.720
是有点类型

31:32.720 --> 31:33.720
明白我的意思吗

31:33.720 --> 31:34.720
类型断言

31:34.720 --> 31:35.720
可以用这种写法

31:35.720 --> 31:36.720
也可以使用

31:36.720 --> 31:37.720
两个检扩号

31:37.720 --> 31:39.720
检扩号这种写法

31:39.720 --> 31:40.720
都行

31:40.720 --> 31:41.720
只不过检扩号

31:41.720 --> 31:42.720
在react里面

31:42.720 --> 31:43.720
就这样少写了

31:43.720 --> 31:44.720
因为在react里面

31:44.720 --> 31:46.720
它会认为的是GSX

31:47.720 --> 31:49.720
都是关于类型的断言

31:50.720 --> 31:52.720
其实还有啥呢

31:52.720 --> 31:53.720
可能还有一些细致模拟的东西

31:53.720 --> 31:55.720
我这里没有去总结到

31:55.720 --> 31:56.720
其实都没关系

31:56.720 --> 31:57.720
我们后边用到的时候

31:57.720 --> 31:58.720
自然会

31:58.720 --> 31:59.720
帮它回忆起来的

31:59.720 --> 32:01.720
我们每一个

32:01.720 --> 32:02.720
小的章节里面

32:02.720 --> 32:04.720
都有相应的练习

32:04.720 --> 32:05.720
都是对每一块的知识

32:05.720 --> 32:06.720
进行的巩固的

32:07.720 --> 32:08.720
好了

32:08.720 --> 32:09.720
那么基础部分

32:09.720 --> 32:10.720
我们学习完了

32:10.720 --> 32:11.720
那TS

32:11.720 --> 32:12.720
还有什么东西呢

32:12.720 --> 32:14.720
其实还有不少的东西

32:14.720 --> 32:15.720
再说一次

32:15.720 --> 32:17.720
TS是一个可选的类型系统

32:17.720 --> 32:19.720
如果你只是学习

32:19.720 --> 32:20.720
这个TS

32:20.720 --> 32:22.720
只是做自于自论

32:22.720 --> 32:23.720
自己学的玩

32:23.720 --> 32:25.720
那么我建议了

32:25.720 --> 32:26.720
一种快乐的学习方式

32:26.720 --> 32:28.720
不要学的那么痛苦

32:28.720 --> 32:29.720
你学了一些

32:29.720 --> 32:30.720
你听了

32:30.720 --> 32:32.720
你能够理解的内容之后

32:32.720 --> 32:34.720
你就去写代码的时候

32:34.720 --> 32:35.720
你就尽量的

32:35.720 --> 32:37.720
尽自己最大的努力

32:37.720 --> 32:38.720
把这些类型的

32:38.720 --> 32:39.720
给它约束起来

32:39.720 --> 32:40.720
你写着代码

32:40.720 --> 32:41.720
你写着写着呢

32:41.720 --> 32:42.720
你会发现

32:42.720 --> 32:43.720
有些特殊的地方

32:43.720 --> 32:45.720
这种地方我该怎么去约束呢

32:45.720 --> 32:46.720
我可不可以不约束呢

32:46.720 --> 32:47.720
可以

32:47.720 --> 32:48.720
它是可选的

32:48.720 --> 32:49.720
你不用那么大的压力

32:49.720 --> 32:51.720
那就不约束呗

32:51.720 --> 32:53.720
但是你慢慢的写着

32:53.720 --> 32:54.720
然后我总想把它约束一下

32:54.720 --> 32:55.720
因为我觉得

32:55.720 --> 32:56.720
其他地方约束了

32:56.720 --> 32:57.720
过后代码质量

32:57.720 --> 32:58.720
确实提高了不少

32:58.720 --> 32:59.720
我想把它约束一下

32:59.720 --> 33:01.720
那如果你想的话

33:01.720 --> 33:02.720
还有一些东西

33:02.720 --> 33:04.720
需要在进阶部分学习

33:04.720 --> 33:05.720
如果你只是

33:05.720 --> 33:06.720
本身是公司的员工了

33:06.720 --> 33:07.720
已经进入到公司了

33:07.720 --> 33:09.720
你们开发的是一个大型项目

33:09.720 --> 33:10.720
纳美的说

33:10.720 --> 33:11.720
进阶部分你必须要学习

33:11.720 --> 33:14.720
因为如果有一个地方

33:14.720 --> 33:16.720
或者是有少量的地方

33:16.720 --> 33:17.720
没有内存检查的话

33:17.720 --> 33:19.720
这个系统它就有隐患

33:19.720 --> 33:20.720
就可能会发生

33:20.720 --> 33:22.720
很多的代码书写错误

33:22.720 --> 33:24.720
而这些错误呢

33:24.720 --> 33:27.720
还甚至有可能是检查不出来的

33:27.720 --> 33:28.720
如果完全靠测试

33:28.720 --> 33:29.720
能够把这些错误

33:29.720 --> 33:30.720
全部解决的话

33:30.720 --> 33:31.720
那这个世界上的软件

33:31.720 --> 33:33.720
它不会有bug了

33:33.720 --> 33:34.720
所以测试也不能解决

33:34.720 --> 33:35.720
所有的问题

33:36.720 --> 33:37.720
因此呢

33:37.720 --> 33:38.720
我们为了避免以后

33:38.720 --> 33:40.720
造成了更多的麻烦

33:40.720 --> 33:42.720
我们在最开始写代码的时候

33:42.720 --> 33:43.720
就把方便面面的类型

33:43.720 --> 33:45.720
跟它约束起来

33:45.720 --> 33:47.720
而面对一些特殊的情况

33:47.720 --> 33:49.720
或者是一些负担的系统的时候

33:49.720 --> 33:50.720
我们又该怎么去做

33:50.720 --> 33:51.720
一些类型的约束

33:51.720 --> 33:53.720
那么我们在进阶部分的

33:53.720 --> 33:55.720
会讲更多的东西

33:55.720 --> 33:56.720
好了

33:56.720 --> 33:57.720
那么我们到此

33:57.720 --> 33:59.720
就技术部分就结束了

33:59.720 --> 34:00.720
如果技术部分

34:00.720 --> 34:02.720
你还有任何的疑问的话

34:02.720 --> 34:03.720
可以来问我

34:03.720 --> 34:04.720
也可以去看一下

34:04.720 --> 34:06.720
这视频里面相应的章节

34:06.720 --> 34:07.720
把多看几遍

34:07.720 --> 34:08.720
每个章节

34:08.720 --> 34:09.720
其实我觉得我讲的

34:09.720 --> 34:11.720
已经是比较清楚的了

34:12.720 --> 34:13.720
好

34:13.720 --> 34:14.720
那么之后呢

34:14.720 --> 34:15.720
我们就开始进入

34:15.720 --> 34:16.720
进阶部分的学习了

34:16.720 --> 34:17.720
好

34:17.720 --> 34:18.720
技术部分就到这里了

34:18.720 --> 34:19.720
拜拜

