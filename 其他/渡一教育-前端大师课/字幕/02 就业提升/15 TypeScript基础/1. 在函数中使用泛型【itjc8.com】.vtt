WEBVTT

00:00.880 --> 00:03.960
大家好 我是杜亦教育 微博前段讲师 袁晋

00:04.560 --> 00:09.600
我们之前学习了很多关于类型约束的知识了

00:09.920 --> 00:13.560
那么基础部分 还剩下最后一个就是翻译

00:14.200 --> 00:17.680
为什么还需要翻译这个东西呢 它到底是一个什么玩意儿

00:17.680 --> 00:19.640
它来解决一个什么样的问题

00:20.280 --> 00:23.640
其实咱们之前的学习的东西里边

00:23.640 --> 00:26.680
我是有意的回避了一些问题

00:26.680 --> 00:30.840
但是这些问题在咱们开发中是经常遇见的

00:31.800 --> 00:34.680
如果你使用了类型约束 你就会发现这样的问题

00:35.120 --> 00:36.040
咱们来举个例子

00:37.040 --> 00:40.240
比方说 这里呢 有一个函数

00:41.880 --> 00:45.520
这个函数做什么呢 其实咱们上节课也写过类似的代码

00:46.240 --> 00:51.600
take 拿几个 从数组中取它前几项的

00:52.280 --> 00:54.240
指返回一个新的数组

00:55.320 --> 00:55.720
take

00:56.600 --> 00:58.920
take什么呢 就take吧 就take 这个函数

00:59.880 --> 01:02.840
它要传一个东西进来 传一个数组进来

01:03.640 --> 01:06.600
好 这个函数要做什么呢 这是一个数组

01:07.000 --> 01:09.840
我们先用js来写 先不管ts

01:09.840 --> 01:11.240
我们就用纯js来写

01:11.920 --> 01:16.440
这是一个数组 我要从这个数组中取出前n项

01:17.440 --> 01:18.000
还有一个n

01:18.880 --> 01:21.600
我们要从这个数组中取出前面的n项

01:22.040 --> 01:23.200
当然我先要判断一下

01:24.160 --> 01:30.560
如果这个n大约等于了数组的长度

01:30.560 --> 01:33.840
那你把这个数组取完呗 现在没有任何智能提示

01:33.840 --> 01:35.760
因为它不知道这个地方是个数组

01:36.440 --> 01:37.760
我直接把这个数组返回了

01:37.760 --> 01:39.120
直接把这个数组返回

01:39.640 --> 01:42.760
如果你要取得数字 取得像数

01:43.200 --> 01:46.320
是这个数组的长度 大约等于这个数组的长度

01:46.320 --> 01:48.040
直接返回这个数组 没什么好说的

01:49.040 --> 01:51.040
然后其他情况呢

01:51.040 --> 01:54.040
其他情况我们就可以使用循环了 对吧

01:54.040 --> 01:55.040
使用循环了

01:56.040 --> 01:58.040
ok 我们这里新建一个数组

01:58.040 --> 01:59.040
新建一个数组

02:01.860 --> 02:03.860
就是维绕着

02:04.860 --> 02:05.860
新建这么一个数组

02:05.860 --> 02:10.860
然后循环 循环啥呢 循环几次呢

02:10.860 --> 02:13.860
n是多少就循环多少次 对吧

02:13.860 --> 02:15.860
所以说这里我们写n

02:16.860 --> 02:17.860
ok

02:17.860 --> 02:19.860
这里每循环一次

02:19.860 --> 02:21.860
我们从这个数组里边怎么样

02:22.860 --> 02:25.860
天加一项 天加一项啥呢

02:25.860 --> 02:28.860
天加一项 原来的数组这一项

02:28.860 --> 02:30.860
把原来的数组这一项加进去

02:30.860 --> 02:31.860
它现在爆错了

02:31.860 --> 02:34.860
爆错的原因是因为它推断出来

02:34.860 --> 02:36.860
你这个数组是一个never类型的数组

02:36.860 --> 02:37.860
它是这样推断的

02:37.860 --> 02:39.860
就你没有给它进行限制

02:39.860 --> 02:41.860
你直接给它负责一个空数组

02:41.860 --> 02:42.860
表啥意思呢

02:42.860 --> 02:44.860
就表示了这个东西永远只能为空数组

02:44.860 --> 02:46.860
它不能为任何其他东西

02:46.860 --> 02:48.860
它永远只能是空数组

02:48.860 --> 02:50.860
那么这里我们稍微改一下

02:50.860 --> 02:52.860
把它改成n定 改成n定

02:52.860 --> 02:53.860
先改了再说

02:55.860 --> 02:56.860
我们这里是个数组

02:56.860 --> 02:58.860
然后循环n次

02:58.860 --> 03:00.860
每次循环从原来的数组里边

03:00.860 --> 03:03.860
把这一项取出来 加到新数组里边

03:03.860 --> 03:06.860
最后我们把新数组返回

03:06.860 --> 03:07.860
新数组返回

03:07.860 --> 03:08.860
就做完了 对吧

03:08.860 --> 03:10.860
我们来试一下 先试一下这个函数

03:11.860 --> 03:14.860
这里得到一个新数组 6AR

03:14.860 --> 03:16.860
然后通过tag

03:16.860 --> 03:18.860
给它一个数组 随便给一些吧

03:22.780 --> 03:24.780
然后取它前两项

03:24.780 --> 03:26.780
我们通过这个例子也会发现

03:26.780 --> 03:29.780
尽管我们没有进行任何的内形约束

03:29.780 --> 03:31.780
你看它其实已经做得很好了

03:31.780 --> 03:33.780
就这个东西就已经很够用了

03:33.780 --> 03:35.780
我只穿一个参数的时候要抱错

03:35.780 --> 03:37.780
这已经在提醒我们了 对吧

03:37.780 --> 03:41.780
其实TS不是强制要求里必须要使用

03:41.780 --> 03:43.780
它的每一个内形检查

03:43.780 --> 03:44.780
你可以不使用

03:44.780 --> 03:46.780
它是个可选的内形系统

03:46.780 --> 03:47.780
已经可以捅它里面

03:47.780 --> 03:49.780
获取到很多有用的东西了

03:49.780 --> 03:51.780
我们输出6AR

03:52.780 --> 03:55.780
来 运行一下npm装

03:55.780 --> 03:59.980
我觉得前几项 前两项是吧

03:59.980 --> 04:01.980
你看三合四取出来了

04:01.980 --> 04:04.980
这个单碼写的当然没什么问题

04:04.980 --> 04:07.980
但是目前我们没有给它加上

04:07.980 --> 04:09.980
任何的内形约束

04:09.980 --> 04:11.980
所以说TS的优势

04:11.980 --> 04:13.980
有没有发挥 肯定有发挥

04:13.980 --> 04:15.980
比方这个函数 它必须要有两个参数

04:15.980 --> 04:17.980
但是没有发挥到那么多

04:17.980 --> 04:19.980
很多地方没有智能提示

04:19.980 --> 04:22.980
而且一些函数的名字我可能会写错

04:22.980 --> 04:24.980
会导致一些隐患

04:24.980 --> 04:26.980
那么下面既然在学这个TS

04:26.980 --> 04:28.980
我们还是想把它做得完善一点

04:28.980 --> 04:31.980
想给它们加上内形约束

04:31.980 --> 04:33.980
来吧 一个个来呗

04:33.980 --> 04:34.980
首先这个n

04:34.980 --> 04:35.980
先看这个n

04:35.980 --> 04:37.980
取这个数组的前几项

04:37.980 --> 04:39.980
那么n应该是什么内形

04:39.980 --> 04:41.980
n应该是啥内形

04:41.980 --> 04:43.980
是不是个number内形 对不对

04:43.980 --> 04:44.980
n是一个number内形

04:44.980 --> 04:46.980
先把这个东西约束好

04:47.980 --> 04:49.980
问题就来了

04:49.980 --> 04:51.980
这个碗要咋办

04:51.980 --> 04:52.980
这个东西咋办

04:52.980 --> 04:53.980
这是个数组

04:53.980 --> 04:55.980
但是我能不能确定

04:55.980 --> 04:57.980
它一定是一个number内形的数组

04:57.980 --> 04:59.980
能不能确定

04:59.980 --> 05:00.980
你觉得能不能确定

05:00.980 --> 05:02.980
它是一个number内形的数组

05:02.980 --> 05:03.980
是不是不敢确定

05:03.980 --> 05:05.980
它有可能是字无串

05:05.980 --> 05:08.980
比方说我取这个字无串的数组

05:16.280 --> 05:18.280
取这个字无串的数组

05:18.280 --> 05:19.280
前面的两项

05:19.280 --> 05:20.280
可不可以

05:20.280 --> 05:22.280
逻辑上是说得通的 对不对

05:22.280 --> 05:24.280
还有是一个对象的数组也可以

05:24.280 --> 05:26.280
比方说上年课咱们做个卡牌

05:26.280 --> 05:28.280
不是取它前面几项吗 对不对

05:28.280 --> 05:29.280
所以说

05:29.280 --> 05:31.280
这里都是说得通的

05:31.280 --> 05:32.280
都是说得通的

05:32.280 --> 05:33.280
那怎么办呢

05:33.280 --> 05:34.280
咋办呢

05:34.280 --> 05:36.280
那这里我写啥呢

05:36.280 --> 05:37.280
我写啥呢

05:37.280 --> 05:38.280
写啥好像都不行

05:38.280 --> 05:39.280
我不能在这里

05:39.280 --> 05:41.280
预先的知道

05:41.280 --> 05:43.280
它将来各种各样的情况

05:43.280 --> 05:45.280
这个情况太多了

05:45.280 --> 05:46.280
它可能是个对象

05:46.280 --> 05:47.280
那对象的情况就无数种

05:47.280 --> 05:49.280
那可能是一个number

05:49.280 --> 05:51.280
可能是个是军字无串

05:51.280 --> 05:53.280
那我这个函数内行该咋写呢

05:53.280 --> 05:56.280
我不得不在这里写上一个n0

05:56.280 --> 05:58.280
它是一个n0内行的数组

05:58.280 --> 05:59.280
任何内行都可以

05:59.280 --> 06:01.280
这样的写好像差不多了

06:01.280 --> 06:02.280
差不多了

06:02.280 --> 06:04.280
那么这一块呢

06:04.280 --> 06:06.280
也是一个n0内行的数组

06:06.280 --> 06:07.280
我们的新数组

06:07.280 --> 06:09.280
仍然是一个n0内行的数组

06:09.280 --> 06:11.280
好 返回的内行呢

06:11.280 --> 06:13.280
也是一个n0内行的数组

06:13.280 --> 06:15.280
返回的也是一个n0内行的数组

06:15.280 --> 06:17.280
其实现在已经做了很多限制了

06:17.280 --> 06:18.280
首先

06:18.280 --> 06:20.280
第一个参数必须是数组

06:20.280 --> 06:21.280
不管每一项是什么

06:21.280 --> 06:23.280
它必须是一个数组

06:23.280 --> 06:24.280
第二个参数呢

06:24.280 --> 06:25.280
第二个参数

06:25.280 --> 06:27.280
那么它是一个数字

06:27.280 --> 06:28.280
这个已经限制好了

06:28.280 --> 06:31.280
返回的结果也是一个数组

06:31.280 --> 06:33.280
其实已经做了很多限制了

06:33.280 --> 06:35.280
但是大家如果你细心观察

06:35.280 --> 06:38.280
你会发现丢失了一些信息

06:38.280 --> 06:41.280
丢失了什么信息呢

06:41.280 --> 06:43.280
丢失了什么信息呢

06:43.280 --> 06:45.280
它丢失了这么一个信息

06:45.280 --> 06:47.280
就是这里的n0

06:47.280 --> 06:49.280
不管将来传的是啥

06:49.280 --> 06:51.280
跟这里的n0

06:51.280 --> 06:52.280
跟这里的n0

06:52.280 --> 06:54.280
它的内行一定要相同

06:54.280 --> 06:56.280
大家想想是不是这个逻辑

06:56.280 --> 06:58.280
我如果传进来的是一个

06:58.280 --> 06:59.280
制服串的数组

06:59.280 --> 07:01.280
那这里是制服串

07:01.280 --> 07:03.280
好 这里是不是也应该是制服串

07:03.280 --> 07:05.280
从这个数组里面取它前几项

07:05.280 --> 07:07.280
那么是不是也应该是制服串

07:07.280 --> 07:09.280
好 这个新数组

07:09.280 --> 07:10.280
我们代码书写过程中

07:10.280 --> 07:11.280
这个新数组

07:11.280 --> 07:13.280
是不是也应该是一个制服串的数组

07:13.280 --> 07:14.280
来装结果的

07:14.280 --> 07:15.280
对吧

07:15.280 --> 07:17.280
但它这个信息丢失掉了

07:17.280 --> 07:19.280
它现在并不知道

07:19.280 --> 07:21.280
我们这里

07:21.280 --> 07:22.280
这里每一项

07:22.280 --> 07:24.280
就是这三个东西是一个东西

07:24.280 --> 07:26.280
这三个n0是一个东西

07:26.280 --> 07:27.280
它并不知道

07:27.280 --> 07:28.280
不知道这个信息

07:28.280 --> 07:29.280
会导致一个什么样的结果呢

07:29.280 --> 07:30.280
当然

07:30.280 --> 07:31.280
如果你代码写的

07:31.280 --> 07:33.280
如果没有什么拼写错误

07:33.280 --> 07:34.280
这些东西

07:34.280 --> 07:35.280
那么没有什么影响

07:35.280 --> 07:36.280
它不影响运行的

07:36.280 --> 07:38.280
内行检查的不影响运行的

07:38.280 --> 07:39.280
你看

07:39.280 --> 07:40.280
结果还是正确的

07:40.280 --> 07:41.280
但是呢

07:41.280 --> 07:43.280
我们后边就得不到内行检查了

07:43.280 --> 07:44.280
因为它返回的结果

07:44.280 --> 07:46.280
你看是一个n0的数组

07:46.280 --> 07:48.280
但是我们明明传递给它的是一个

07:48.280 --> 07:49.280
制服串的数组

07:49.280 --> 07:50.280
它返回的也应该是一个

07:50.280 --> 07:51.280
制服串的数组

07:51.280 --> 07:52.280
那么我们在循环

07:52.280 --> 07:53.280
这个新的数组的时候

07:53.280 --> 07:55.280
佛意起来循环的时候

07:55.280 --> 07:56.280
它就不知道

07:56.280 --> 07:58.280
这里每一项是一个制服串

07:58.280 --> 08:00.280
它就不知道了

08:00.280 --> 08:01.280
不知道

08:01.280 --> 08:02.280
它认为是n0

08:02.280 --> 08:03.280
这个信息丢失掉了

08:03.280 --> 08:04.280
我给它传的是

08:04.280 --> 08:05.280
每一项是制服串

08:05.280 --> 08:06.280
比方说它给它传

08:06.280 --> 08:07.280
每一项是个数字

08:07.280 --> 08:09.280
每一项是个数字

08:09.280 --> 08:10.280
它知道的结果

08:10.280 --> 08:11.280
应该是一个数字的数组

08:11.280 --> 08:12.280
但它不知道

08:12.280 --> 08:13.280
它不知道

08:13.280 --> 08:14.280
它认为得到的结果

08:14.280 --> 08:15.280
还是n0

08:15.280 --> 08:16.280
每一项还是n0

08:16.280 --> 08:18.280
我们丢失的是什么信息

08:18.280 --> 08:21.280
说一下

08:21.280 --> 08:23.280
有时

08:23.280 --> 08:26.280
书写某个函数是

08:26.280 --> 08:32.280
会丢失一些内行信息

08:32.280 --> 08:34.280
这些内行信是什么呢

08:34.280 --> 08:38.280
多个位置的内行

08:39.280 --> 08:41.280
保持一致

08:41.280 --> 08:46.910
或有关联的信息

08:46.910 --> 08:48.910
就是有些地方的内行

08:48.910 --> 08:49.910
虽然用的是n0

08:49.910 --> 08:50.910
但他们之间的内行

08:50.910 --> 08:51.910
是有一定关联的

08:51.910 --> 08:52.910
比方说这种情况

08:52.910 --> 08:53.910
它就是一致的

08:53.910 --> 08:54.910
对吧

08:54.910 --> 08:55.910
一致的

08:55.910 --> 08:56.910
或者是有某一些

08:56.910 --> 08:57.910
关联的情况

08:57.910 --> 08:58.910
那么这种情况

08:58.910 --> 08:59.910
这种信息

08:59.910 --> 09:00.910
它丢失掉了

09:00.910 --> 09:02.910
如何来解决

09:02.910 --> 09:03.910
这个丢失掉的信息

09:03.910 --> 09:05.910
只能依靠犯行

09:06.910 --> 09:08.910
那么什么叫做犯行呢

09:09.910 --> 09:11.910
我先给大家下个定义

09:11.910 --> 09:14.670
犯行

09:14.670 --> 09:17.670
犯行是指

09:17.670 --> 09:21.670
附属于

09:21.670 --> 09:22.670
函数

09:22.670 --> 09:23.670
或者是内

09:23.670 --> 09:24.670
或者是

09:24.670 --> 09:25.670
接口

09:25.670 --> 09:26.670
或者是匿名

09:26.670 --> 09:28.670
内行别名

09:28.670 --> 09:29.670
这些都是扩展内行

09:29.670 --> 09:30.670
对吧

09:30.670 --> 09:32.670
它附属在这些内行之上

09:32.670 --> 09:35.670
之上的内行

09:35.670 --> 09:36.670
这就是犯行

09:36.670 --> 09:37.670
那么犯行

09:37.670 --> 09:38.670
为什么要去附属

09:38.670 --> 09:39.670
在上面之上呢

09:39.670 --> 09:41.670
是因为这些内啊

09:41.670 --> 09:42.670
这些接口

09:42.670 --> 09:43.670
这些内行别名

09:43.670 --> 09:44.670
或者是函数

09:44.670 --> 09:45.670
我们先看函数吧

09:45.670 --> 09:47.670
有些函数在操作过程中

09:47.670 --> 09:49.670
它需要一些内行

09:49.670 --> 09:50.670
但它不知道

09:50.670 --> 09:51.670
这个内行是啥

09:51.670 --> 09:52.670
比方说这种情况

09:52.670 --> 09:53.670
我要

09:53.670 --> 09:54.670
我要得到

09:54.670 --> 09:56.670
我要处理一个数组

09:56.670 --> 09:57.670
但是呢

09:57.670 --> 09:58.670
我不知道这个数组

09:58.670 --> 09:59.670
是什么内行

09:59.670 --> 10:00.670
什么内行的数组

10:00.670 --> 10:01.670
但是无所谓

10:01.670 --> 10:03.670
我整个处理过程

10:03.670 --> 10:04.670
都是一样的处理方式

10:04.670 --> 10:05.670
不管你是一样的

10:05.670 --> 10:06.670
什么样的内行的数组

10:06.670 --> 10:07.670
比方说这里

10:07.670 --> 10:08.670
这种情况可多了

10:08.670 --> 10:09.670
我要对数组排序

10:09.670 --> 10:11.670
对数组排序的时候

10:11.670 --> 10:12.670
我需不需要知道

10:12.670 --> 10:13.670
你是什么内行的数组

10:13.670 --> 10:14.670
不需要知道

10:14.670 --> 10:15.670
你只需要

10:15.670 --> 10:16.670
只需要告诉我

10:16.670 --> 10:17.670
怎么比较大小就行了

10:17.670 --> 10:18.670
怎么比较大小

10:18.670 --> 10:19.670
我就知道该怎么排序了

10:19.670 --> 10:20.670
因此呢

10:20.670 --> 10:21.670
有的时候

10:21.670 --> 10:23.670
我去实现代码的时候呢

10:23.670 --> 10:24.670
跟内行无关

10:24.670 --> 10:26.670
但是我约束内行的时候呢

10:26.670 --> 10:28.670
我需要这个内行信息

10:28.670 --> 10:29.670
这个时候

10:29.670 --> 10:31.670
就需要使用犯行了

10:31.670 --> 10:32.670
OK

10:32.670 --> 10:33.670
我们先把这个犯行

10:33.670 --> 10:34.670
我们先把这个

10:34.670 --> 10:35.670
遇到了问题

10:35.670 --> 10:36.670
先抛出来

10:36.670 --> 10:38.670
这里的内行关联的信息

10:38.670 --> 10:39.670
丢失掉了

10:39.670 --> 10:40.670
那么犯行来解决

10:40.670 --> 10:41.670
什么样的问题

10:41.670 --> 10:42.670
它是指的是

10:42.670 --> 10:43.670
附属于某一个

10:43.670 --> 10:44.670
寒树的内行

10:44.670 --> 10:45.670
就是我书写这个寒树的时候

10:45.670 --> 10:47.670
我可以给他附加一个内行

10:47.670 --> 10:48.670
那么这个内行呢

10:48.670 --> 10:49.670
就可以来表示出

10:49.670 --> 10:50.670
这个位置

10:50.670 --> 10:51.670
这个位置

10:51.670 --> 10:52.670
这个位置是一致的了

10:52.670 --> 10:54.670
如果你现在听着有点晕

10:54.670 --> 10:55.670
如果你觉得有点晕

10:55.670 --> 10:56.670
还不知道我来说什么

10:56.670 --> 10:57.670
那么接下来

10:57.670 --> 10:58.670
我们来讲一讲

10:58.670 --> 11:00.670
内行该如何来书写

11:00.670 --> 11:01.670
如何来使用

11:01.670 --> 11:02.670
你马上就明白了

11:02.670 --> 11:03.670
好

11:03.670 --> 11:04.670
我们看一下

11:04.670 --> 11:06.670
在寒树中

11:06.670 --> 11:07.670
首先看第1个

11:07.670 --> 11:09.670
在寒树中使用犯行

11:09.670 --> 11:11.670
该怎么来使用

11:11.670 --> 11:12.670
非常简单

11:12.670 --> 11:15.670
你只需要在寒树名之后

11:15.670 --> 11:18.670
在寒树名之后

11:18.670 --> 11:20.670
写上

11:20.670 --> 11:21.670
写上啥呢

11:21.670 --> 11:26.710
写上这种东西

11:26.710 --> 11:27.710
两个监扩号

11:27.710 --> 11:28.710
里边写上

11:28.710 --> 11:30.710
犯行名称

11:30.710 --> 11:31.710
你可能还不太清楚

11:31.710 --> 11:32.710
这个中心是啥

11:32.710 --> 11:33.710
那我们写一下

11:33.710 --> 11:34.710
再来解释

11:34.710 --> 11:36.710
我在寒树名之后

11:36.710 --> 11:38.710
写上两个监扩号

11:38.710 --> 11:40.710
这个监扩号里面

11:40.710 --> 11:41.710
随便取一个名字

11:41.710 --> 11:43.710
跟我有一个内行

11:43.710 --> 11:45.710
会附属到这个寒树上面来

11:45.710 --> 11:46.710
我们比较take

11:46.710 --> 11:47.710
take表示什么

11:47.710 --> 11:49.710
取一个书组的前几项

11:49.710 --> 11:51.710
取一个什么内行的

11:51.710 --> 11:52.710
书组前几项

11:52.710 --> 11:53.710
那么这个内行

11:53.710 --> 11:54.710
给他取一个名称

11:54.710 --> 11:55.710
随便取不取

11:55.710 --> 11:56.710
这就是犯行

11:56.710 --> 11:57.710
这里面写的东西就是犯行

11:57.710 --> 12:00.710
我们通常会取一个大写的t

12:00.710 --> 12:02.710
通常会取一个名称

12:02.710 --> 12:03.710
叫大写的t

12:03.710 --> 12:04.710
这个t是什么

12:04.710 --> 12:05.710
这个t表示的是一个内行

12:05.710 --> 12:07.710
编译结果里面没有

12:07.710 --> 12:09.710
编译结果里面啥都没有

12:09.710 --> 12:11.710
这个t表示一个内行

12:11.710 --> 12:13.710
就是我要调用这个寒树

12:13.710 --> 12:15.710
需要知道一个内行

12:15.710 --> 12:16.710
这个内行就是

12:16.710 --> 12:18.710
书组的每一项的内行

12:18.710 --> 12:20.710
这就是一个犯行寒树

12:20.710 --> 12:21.710
就规定完了

12:21.710 --> 12:23.710
好 接下来

12:23.710 --> 12:24.710
我们就来写一下

12:24.710 --> 12:26.710
看一下后面的内行

12:26.710 --> 12:27.710
比方说

12:27.710 --> 12:29.710
到时候咱们调用这个寒树的时候

12:29.710 --> 12:30.710
会怎么调用呢

12:30.710 --> 12:33.710
比方说我们可以这样调用

12:33.710 --> 12:34.710
take

12:34.710 --> 12:36.710
我们把具体的内行

12:36.710 --> 12:37.710
给它传进去

12:37.710 --> 12:38.710
你看它有个t

12:38.710 --> 12:39.710
有个t

12:39.710 --> 12:40.710
我们把具体的内行

12:40.710 --> 12:41.710
给它传进去

12:41.710 --> 12:44.710
比方说传一个stune

12:44.710 --> 12:46.710
全一个stune表示什么意思

12:46.710 --> 12:48.710
表示告诉寒树

12:48.710 --> 12:50.710
你操作的树主

12:50.710 --> 12:52.710
是一个制服串的内行

12:52.710 --> 12:53.710
然后再调用寒树

12:53.710 --> 12:55.710
明白这个意思吗

12:55.710 --> 12:56.710
调用寒树

12:56.710 --> 12:57.710
并且告诉他

12:57.710 --> 12:58.710
你操作的内行

12:58.710 --> 12:59.710
是一个制服串的内行

12:59.710 --> 13:00.710
这样子

13:00.710 --> 13:01.710
相当于是把制服串

13:01.710 --> 13:03.710
就传给了这个t了

13:03.710 --> 13:04.710
相当于这个

13:04.710 --> 13:05.710
相当于是啥

13:05.710 --> 13:06.710
这是一个内行的变量

13:06.710 --> 13:08.710
是一个内行的变量

13:08.710 --> 13:09.710
好

13:09.710 --> 13:10.710
然后比方说

13:10.710 --> 13:12.710
我在我要操作的是一个

13:12.710 --> 13:13.710
数字的树主

13:13.710 --> 13:14.710
我就可以要传一个number

13:14.710 --> 13:16.710
明白这个意思吗

13:16.710 --> 13:18.710
就把这个number传给这个t了

13:18.710 --> 13:19.710
所以说

13:19.710 --> 13:20.710
在写寒树的时候

13:20.710 --> 13:21.710
我不知道是什么内行

13:21.710 --> 13:23.710
我随便用一个东西来代替

13:23.710 --> 13:24.710
表示这个寒树

13:24.710 --> 13:25.710
肯定要一副

13:25.710 --> 13:27.710
肯定要有一个一副

13:27.710 --> 13:28.710
一副于一个内行

13:28.710 --> 13:29.710
或者说

13:29.710 --> 13:31.710
这个内行一副于这个寒树

13:31.710 --> 13:32.710
应该这么说

13:32.710 --> 13:33.710
这个内行

13:33.710 --> 13:35.710
一副于这个寒树

13:35.710 --> 13:36.710
而这个内行

13:36.710 --> 13:38.710
只有在雕用寒树的时候

13:38.710 --> 13:39.710
才能确定

13:39.710 --> 13:40.710
书写这个寒树的时候

13:40.710 --> 13:42.710
定义这个寒树的时候

13:42.710 --> 13:43.710
我无法确定

13:43.710 --> 13:45.710
它是什么样的内行

13:45.710 --> 13:46.710
OK

13:46.710 --> 13:47.710
我们先用一个t来表示

13:47.710 --> 13:48.710
这个寒树

13:48.710 --> 13:49.710
操作的树主

13:49.710 --> 13:50.710
每一项是个内行t

13:50.710 --> 13:51.710
什么内行

13:51.710 --> 13:52.710
雕用的时候传给它

13:52.710 --> 13:54.710
接下来我们再继续看

13:54.710 --> 13:56.710
现在已经高速了

13:56.710 --> 13:57.710
这个寒树

13:57.710 --> 13:59.710
树主的每一项是个内行t

13:59.710 --> 14:01.710
那这里应该写啥

14:01.710 --> 14:02.710
是不是内行t

14:02.710 --> 14:04.710
返回的结果应该写啥

14:04.710 --> 14:05.710
内行t

14:05.710 --> 14:07.710
这里写啥

14:07.710 --> 14:08.710
内行t

14:08.710 --> 14:10.710
你看一下现在信息

14:10.710 --> 14:11.710
是不是一致的

14:11.710 --> 14:13.710
我甭管这个东西

14:13.710 --> 14:14.710
是啥内行

14:14.710 --> 14:15.710
甭管它是啥

14:15.710 --> 14:16.710
是字不错

14:16.710 --> 14:17.710
是数字

14:17.710 --> 14:18.710
是一个对象的数主

14:18.710 --> 14:19.710
无所谓

14:19.710 --> 14:21.710
你只要给我这个内行

14:21.710 --> 14:22.710
那么只要你

14:22.710 --> 14:23.710
这里的内行确定了

14:23.710 --> 14:24.710
我这里的内行

14:24.710 --> 14:25.710
就一定是一致的

14:25.710 --> 14:26.710
这里内行确定

14:26.710 --> 14:27.710
这里的内行确定

14:27.710 --> 14:29.710
这里的内行确定

14:29.710 --> 14:30.710
那么就把这个

14:30.710 --> 14:31.710
丢失的信息

14:31.710 --> 14:32.710
给它着不回来了

14:33.710 --> 14:34.710
丢失的信息是什么

14:34.710 --> 14:35.710
之前不知道

14:35.710 --> 14:36.710
这个地方的内行

14:36.710 --> 14:37.710
跟这个地方的内行

14:37.710 --> 14:38.710
是一样的

14:38.710 --> 14:39.710
它并不知道

14:39.710 --> 14:40.710
它现在知道了

14:40.710 --> 14:41.710
它们使用的是

14:41.710 --> 14:42.710
同一个内行变量

14:42.710 --> 14:43.710
你可以这样理解

14:43.710 --> 14:44.710
翻译相当于是

14:44.710 --> 14:45.710
一个内行变量

14:45.710 --> 14:46.710
这样理解

14:46.710 --> 14:48.710
每个地方的内行

14:48.710 --> 14:49.710
都是一致的

14:49.710 --> 14:50.710
你可以这样去理解

14:54.710 --> 14:56.710
翻译相当于是

14:56.710 --> 14:58.710
一个内行变量

14:58.710 --> 15:01.710
在定义时

15:01.710 --> 15:02.710
定义函数的时候

15:02.710 --> 15:04.710
在定义时

15:04.710 --> 15:06.710
无法预先知道

15:06.710 --> 15:08.710
具体的内行

15:09.710 --> 15:10.710
那么可以用这个变量

15:10.710 --> 15:11.710
来代替

15:11.710 --> 15:13.710
可以用该变量

15:13.710 --> 15:14.710
来代替

15:15.710 --> 15:17.710
只有到运行时

15:17.710 --> 15:19.710
或者叫雕用时

15:19.710 --> 15:20.710
雕用时的

15:21.710 --> 15:22.710
才能确定

15:23.710 --> 15:24.710
它的内行

15:24.710 --> 15:25.710
这就是个翻译

15:26.710 --> 15:27.710
有了翻译之后

15:27.710 --> 15:28.710
我们可以获得

15:28.710 --> 15:30.710
更加一致的内行检查

15:30.710 --> 15:31.710
大家再看一下

15:31.710 --> 15:33.710
神奇的事情发生了

15:33.710 --> 15:35.710
当我雕用这个函数的时候

15:35.710 --> 15:36.710
给它内行的翻译

15:36.710 --> 15:38.710
传了一个Number

15:38.710 --> 15:39.710
传了个Number

15:39.710 --> 15:40.710
那就意味着啥呢

15:40.710 --> 15:42.710
我们看一下函数的提示

15:43.710 --> 15:44.710
第一个参数

15:44.710 --> 15:45.710
它要求你是个Number的数主

15:45.710 --> 15:46.710
看到没

15:46.710 --> 15:47.710
T就变成了Number了

15:48.710 --> 15:49.710
然后呢

15:49.710 --> 15:50.710
这个没有什么好说的

15:50.710 --> 15:51.710
返回的值

15:51.710 --> 15:52.710
也是一个Number的内行

15:52.710 --> 15:53.710
看到没

15:53.710 --> 15:54.710
好,来呗

15:55.710 --> 15:56.710
把这个地方复制一下

15:56.710 --> 15:57.710
这个地方复制一下

15:58.710 --> 15:59.710
这个地方

16:00.710 --> 16:01.710
复制一下

16:01.710 --> 16:02.710
返回的结果

16:02.710 --> 16:03.710
你看一下

16:03.710 --> 16:04.710
它什么内行

16:04.710 --> 16:05.710
返回的结果

16:05.710 --> 16:06.710
Ridout

16:07.710 --> 16:08.710
你看一下Ridout什么内行

16:08.710 --> 16:09.710
Number的数主

16:09.710 --> 16:10.710
这就一致了

16:10.710 --> 16:11.710
这就一致了

16:11.710 --> 16:12.710
我这里该复制为Number

16:12.710 --> 16:13.710
它就知道了

16:13.710 --> 16:14.710
这一项必须是Number

16:14.710 --> 16:15.710
如果你这里

16:15.710 --> 16:16.710
该传一个致乎串

16:16.710 --> 16:17.710
那不行

16:17.710 --> 16:18.710
它要报错了

16:19.710 --> 16:20.710
它要报错了

16:20.710 --> 16:21.710
它必须是个Number的数主

16:22.710 --> 16:23.710
好,比方说

16:23.710 --> 16:24.710
这里是一个致乎串

16:24.710 --> 16:25.710
Stream

16:26.710 --> 16:27.710
那么这里每一项

16:27.710 --> 16:28.710
也必须是一个致乎串

16:28.710 --> 16:29.710
返回的结果

16:29.710 --> 16:31.710
是一个致乎串的数主

16:31.710 --> 16:32.710
那比方说

16:32.710 --> 16:33.710
这里是一个

16:34.710 --> 16:35.710
R不解册

16:35.710 --> 16:36.710
那么返回的结果

16:36.710 --> 16:37.710
是一个对象的数主

16:37.710 --> 16:39.710
当然这里还可以写啥

16:39.710 --> 16:40.710
各种写法都可以

16:40.710 --> 16:41.710
比方说接口

16:41.710 --> 16:42.710
你写个接口

16:42.710 --> 16:43.710
那么比方说

16:43.710 --> 16:44.710
你写一个

16:44.710 --> 16:45.710
内行别名

16:45.710 --> 16:47.710
你写个每一句都可以

16:47.710 --> 16:48.710
没有任何问题

16:49.710 --> 16:50.710
懂了吗

16:50.710 --> 16:51.710
这就是发行在

16:51.710 --> 16:52.710
调用的时候

16:52.710 --> 16:53.710
才能确定

16:53.710 --> 16:54.710
其实TS

16:54.710 --> 16:56.710
还可以做一些工作

16:56.710 --> 16:57.710
能够让我们

16:57.710 --> 16:59.710
编写代码的更加的轻松

16:59.710 --> 17:00.710
比方说

17:00.710 --> 17:01.710
我们这里

17:01.710 --> 17:02.710
不写这个发行

17:02.710 --> 17:03.710
可不可以呢

17:05.710 --> 17:06.710
它不报错

17:06.710 --> 17:07.710
不报错的话

17:07.710 --> 17:08.710
我们看一下Routes的值

17:09.710 --> 17:10.710
Number的数主

17:10.710 --> 17:12.710
你看逻辑是不是正确的

17:12.710 --> 17:13.710
我给它传了

17:13.710 --> 17:14.710
一个Number的数主

17:14.710 --> 17:15.710
它返回了

17:15.710 --> 17:16.710
一个Number的数主

17:16.710 --> 17:17.710
对上了

17:17.710 --> 17:18.710
对吧

17:18.710 --> 17:19.710
那这是怎么回上呢

17:19.710 --> 17:20.710
它是使用了

17:20.710 --> 17:21.710
内行的推导

17:21.710 --> 17:22.710
我们只能

17:22.710 --> 17:23.710
看一下

17:23.710 --> 17:24.710
它推导出来

17:24.710 --> 17:26.710
由于你第一个参数

17:26.710 --> 17:28.710
传了一个数字的数主

17:28.710 --> 17:29.710
传了一个Number的数主

17:29.710 --> 17:30.710
因此

17:30.710 --> 17:31.710
它认为

17:31.710 --> 17:32.710
它一对应

17:32.710 --> 17:33.710
发现

17:33.710 --> 17:34.710
虽然你没有告诉我

17:34.710 --> 17:35.710
这个地方T是什么类型

17:35.710 --> 17:36.710
但是你告诉了它

17:36.710 --> 17:37.710
它是一个Number

17:37.710 --> 17:38.710
那么这几个地方是一致的

17:38.710 --> 17:39.710
所以说

17:39.710 --> 17:40.710
这个地方

17:40.710 --> 17:41.710
也应该是Number

17:41.710 --> 17:42.710
它推导出来了

17:42.710 --> 17:43.710
因此

17:43.710 --> 17:44.710
翻译

17:46.710 --> 17:47.710
TS

17:48.710 --> 17:49.710
会

17:49.710 --> 17:51.710
很多时候

17:52.710 --> 17:53.710
TS

17:53.710 --> 17:55.710
会智能的

17:55.710 --> 17:59.600
智能的

17:59.600 --> 18:00.600
根据

18:00.600 --> 18:01.600
传递的参数

18:01.600 --> 18:03.600
根据传递的参数

18:03.600 --> 18:05.600
推导出

18:05.600 --> 18:06.600
翻译型的

18:06.600 --> 18:08.600
具体内行

18:09.600 --> 18:10.600
但是前提条件

18:10.600 --> 18:12.600
也是参数使用了

18:12.600 --> 18:13.600
翻译型才行

18:13.600 --> 18:14.600
参数使用了

18:14.600 --> 18:15.600
翻译型才行

18:15.600 --> 18:16.600
那如果你参数不使用

18:16.600 --> 18:17.600
翻译型

18:17.600 --> 18:18.600
使用N内行

18:18.600 --> 18:19.600
它能推导出来吗

18:19.600 --> 18:21.600
它能推导出Number吗

18:21.600 --> 18:22.600
推导不出来

18:22.600 --> 18:23.600
相当于

18:23.600 --> 18:24.600
啥都没有写

18:24.600 --> 18:25.600
啥都没有写的翻译呢

18:25.600 --> 18:26.600
它默认为

18:26.600 --> 18:28.600
一个空对象翻译

18:28.600 --> 18:29.600
如果你这个T

18:29.600 --> 18:30.600
啥都没有写的话

18:30.600 --> 18:31.600
没有给它的话

18:31.600 --> 18:33.600
它默认为空对象

18:33.600 --> 18:34.600
空对象

18:34.600 --> 18:35.600
这里

18:35.600 --> 18:36.600
我们把记忆笔吧

18:37.600 --> 18:38.600
如果

18:39.600 --> 18:41.600
无法完成推导

18:41.600 --> 18:43.600
如果无法完成推导

18:43.600 --> 18:44.600
并且

18:44.600 --> 18:45.600
又

18:45.600 --> 18:47.600
没有传递

18:47.600 --> 18:48.600
具体的内行

18:48.600 --> 18:50.600
没有告诉它具体的内行

18:50.600 --> 18:51.600
默认

18:51.600 --> 18:52.600
为

18:52.600 --> 18:53.600
空对象

18:53.600 --> 18:55.600
默认为空对象内行

18:55.600 --> 18:56.600
因为空对象内行

18:56.600 --> 18:57.600
兼容性是最好的

18:57.600 --> 18:59.600
我们知道压纸变形法

18:59.600 --> 19:00.600
空对象没有任何特征

19:00.600 --> 19:02.600
你任何对象都可以复制给它

19:02.600 --> 19:03.600
OK

19:03.600 --> 19:05.600
就是默认为空对象内行

19:05.600 --> 19:06.600
这是

19:06.600 --> 19:07.600
关于这一块

19:07.600 --> 19:08.600
当然你其实

19:08.600 --> 19:09.600
还有种

19:09.600 --> 19:10.600
还有种书写方式

19:10.600 --> 19:11.600
就是给它复默认知

19:11.600 --> 19:12.600
复默认知

19:12.600 --> 19:14.600
如果你不给它传内行的话

19:14.600 --> 19:15.600
它默认为什么内行

19:15.600 --> 19:16.600
比方说

19:16.600 --> 19:17.600
这里

19:17.600 --> 19:18.600
不给它传内行的话

19:18.600 --> 19:20.600
默认为Number内行

19:20.600 --> 19:21.600
这样子写

19:21.600 --> 19:23.600
这是给翻译形的复默认知

19:23.600 --> 19:25.600
没有给它传内行的时候

19:25.600 --> 19:27.600
它默认是Number内行

19:27.600 --> 19:28.600
那么你看一下

19:28.600 --> 19:29.600
反复的结果就是Number内行

19:29.600 --> 19:30.600
没有给它传递

19:30.600 --> 19:31.600
它又没推到出来

19:31.600 --> 19:33.600
那么默认就是Number内行

19:33.600 --> 19:35.600
这是使用翻译默认知

19:35.600 --> 19:36.600
不过这种写法

19:36.600 --> 19:37.600
比较的少见

19:37.600 --> 19:38.600
比较的少见

19:38.600 --> 19:39.600
大家了解一下就行了

19:39.600 --> 19:41.600
还是记一笔吧

19:42.600 --> 19:44.600
翻译形

19:44.600 --> 19:46.600
可以设置默认知

19:46.600 --> 19:47.600
就是没有

19:47.600 --> 19:48.600
没法完成推导

19:48.600 --> 19:51.600
你又没有给它传具体的内行的时候

19:51.600 --> 19:53.600
它的默认知是什么

19:53.600 --> 19:55.600
它的默认是什么内行

19:55.600 --> 19:56.600
这样做法很少

19:56.600 --> 19:57.600
把它改过来

19:57.600 --> 19:58.600
好

19:58.600 --> 19:59.600
通过这个例子

19:59.600 --> 20:00.600
我们就能了解

20:00.600 --> 20:01.600
翻译形能做什么事

20:01.600 --> 20:02.600
就是在书写一些

20:02.600 --> 20:03.600
函数的时候

20:03.600 --> 20:05.600
我们函数的实现

20:05.600 --> 20:06.600
我们知道怎么书写

20:06.600 --> 20:07.600
但它少了一些内行信息

20:07.600 --> 20:09.600
我们可以通过翻译形

20:09.600 --> 20:11.600
来约束它的内行信息

20:11.600 --> 20:12.600
至少可以达到

20:12.600 --> 20:13.600
传递这么一个信息

20:13.600 --> 20:14.600
某些地方

20:14.600 --> 20:15.600
它的内行是有关联的

20:15.600 --> 20:16.600
这个地方的内行

20:16.600 --> 20:17.600
这个地方

20:18.600 --> 20:19.600
这个地方

20:19.600 --> 20:20.600
它的内行是有关联的

20:20.600 --> 20:21.600
可以传递出这么一个信息

20:21.600 --> 20:23.600
那么调用的时候

20:23.600 --> 20:25.600
只要有一个地方内行确定的

20:25.600 --> 20:27.600
其他地方全部都确定下来了

20:27.600 --> 20:28.600
这就是关于

20:28.600 --> 20:31.600
翻译形如何在函数里面去使用

20:31.600 --> 20:32.600
当然翻译形

20:32.600 --> 20:34.600
它不仅仅可以在函数里面使用

20:34.600 --> 20:35.600
它在内

20:35.600 --> 20:37.600
接口内行别名上都可以使用

20:37.600 --> 20:38.600
好

20:38.600 --> 20:39.600
我们先了解在函数里面

20:39.600 --> 20:40.600
怎么去使用翻译形

20:40.600 --> 20:41.600
那么接下来

20:41.600 --> 20:42.600
再来看一下

20:42.600 --> 20:43.600
在其他的位置

20:43.600 --> 20:45.600
该怎么去使用翻译形

