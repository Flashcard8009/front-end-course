WEBVTT

00:00.430 --> 00:02.430
OK 欢迎回来

00:02.430 --> 00:06.430
这些课的话我们来聊一聊这个RN的这个架构

00:06.430 --> 00:10.430
RN的架构然后既然这边我做了一个PPT

00:10.430 --> 00:12.430
那我们这边我们来一起来看一下

00:12.430 --> 00:14.430
这边就从这开始播放吧

00:14.430 --> 00:16.430
OK 好首先

00:16.430 --> 00:18.430
首先的话我们这边这个RN

00:18.430 --> 00:22.430
RN的话我们是使用这个RECT的这个语法

00:22.430 --> 00:24.430
来书写这个组件

00:24.430 --> 00:26.430
那最终我们所书写的这些组件

00:26.430 --> 00:30.430
最终的话会被映射为原生平台的这个组件

00:30.430 --> 00:34.430
这个的话其实在我们一开始的时候我们就介绍过的

00:34.430 --> 00:38.430
对不对啊你看当时的话是放了一张这样子的图

00:38.430 --> 00:40.430
啊你这边的话你在写的时候你用的是什么呢

00:40.430 --> 00:42.430
你用的是RN里面

00:42.430 --> 00:44.430
它给你提供的比如什么view啊

00:44.430 --> 00:48.430
text啊image啊用的是这些组件

00:48.430 --> 00:50.430
那回头的话这些组件就会被映射为

00:50.430 --> 00:54.430
这个原生平台所对应的这些组件

00:54.430 --> 00:58.430
对吧就这一点的话我们是知道的

00:58.430 --> 01:00.430
啊这里还放了一张图

01:00.430 --> 01:04.430
这张图的话应该是之前在那个文档里面也放过的

01:04.430 --> 01:06.430
这里的话也是一个意思

01:06.430 --> 01:08.430
就这边我的一些组件

01:08.430 --> 01:10.430
最终的话会被映射到这个原生平台

01:10.430 --> 01:12.430
原生平台的一些组件

01:12.430 --> 01:14.430
OK

01:14.430 --> 01:18.430
好那接下来的话我们这边我们来思考一个问题

01:18.430 --> 01:22.430
什么问题呢就我们写的代码是什么代码

01:22.430 --> 01:24.430
我们写的代码

01:24.430 --> 01:26.430
我们写的代码是不是JS代码

01:26.430 --> 01:30.430
对不对啊有东西说我写的是react对你用的是react的语法

01:30.430 --> 01:34.430
但是最终的话你其实实际上就是这个JS代码

01:34.430 --> 01:38.430
啊但这个JS代码里面会有这个react里面的一些东西

01:38.430 --> 01:40.430
比如JSX呀之类的对吧

01:40.430 --> 01:44.430
那你这边的话既然是JS代码

01:44.430 --> 01:46.430
那我要执行JS代码

01:46.430 --> 01:48.430
那必然的话需要一个什么东西

01:49.430 --> 01:52.430
是不是得需要一个JS引擎啊

01:52.430 --> 01:55.430
对不对我需要把我的JS代码

01:55.430 --> 01:58.430
放到JS引擎里面去执行

01:58.430 --> 01:59.430
那执行完了之后

01:59.430 --> 02:02.430
然后接下来我们最终我们要形成一个什么

02:02.430 --> 02:05.430
是不是要形成一个映射的关系

02:05.430 --> 02:09.430
那既然要这个既然要形成一个这个映射的关系

02:09.430 --> 02:10.430
那这里的话就是他执

02:10.430 --> 02:15.430
就是这个JS引擎在执行完了这个JS代码之后

02:15.430 --> 02:20.430
我就希望他执行完之后生成一些扣的

02:20.430 --> 02:21.430
生成一些代码

02:21.430 --> 02:24.430
那这些代码的话最终可以映射到什么呢

02:24.430 --> 02:28.430
映射到这个原生的这个平台组件

02:28.430 --> 02:30.430
OK那我们这边呢

02:30.430 --> 02:33.430
虽然就是还没有讲这个他具体的这个架构

02:33.430 --> 02:35.430
但是我们这边呢

02:35.430 --> 02:37.430
其实可以做一种猜想

02:37.430 --> 02:38.430
可以做一种猜想

02:38.430 --> 02:39.430
他这边大致的话

02:39.430 --> 02:41.430
应该是有这么一个流程

02:41.430 --> 02:43.430
因为我写的是JS代码

02:43.430 --> 02:46.430
对不对那必然的话是需要有一个什么

02:46.430 --> 02:48.430
JS引擎对不对

02:48.430 --> 02:50.430
那接下来我要做映射

02:50.430 --> 02:51.430
我要做映射的话

02:51.430 --> 02:53.430
让我这边你不能光执行我这个代码

02:53.430 --> 02:55.430
那你这边还要生成一些新的代码

02:55.430 --> 02:56.430
这些代码

02:56.430 --> 02:59.430
然后和这个原生平台组件之间

02:59.430 --> 03:02.430
有这么一个映射的这个关系

03:02.430 --> 03:04.430
OK好那我们这边

03:04.430 --> 03:07.430
我们来看一下这个RN的这个架构示意图

03:07.430 --> 03:09.430
那实际上他的这个架构示意图的话

03:09.430 --> 03:12.430
其实就是我们刚才所猜想的这个样子

03:13.430 --> 03:14.430
你看一下

03:14.430 --> 03:17.430
这边分成就是这么三个部分

03:17.430 --> 03:19.430
首先的话这边

03:19.430 --> 03:22.430
这边的话是叫做javascript side

03:22.430 --> 03:24.430
那javascript side这边就有什么呢

03:24.430 --> 03:26.430
这边就是有这个首先

03:26.430 --> 03:29.430
首先的话这里就是有这个JS engine

03:29.430 --> 03:31.430
是不是就是JS引擎

03:31.430 --> 03:33.430
JS引擎负责什么

03:33.430 --> 03:36.430
是负责解析你的JS代码

03:36.430 --> 03:37.430
以及什么呢

03:37.430 --> 03:38.430
以及这个react

03:38.430 --> 03:39.430
因为你写的话

03:39.430 --> 03:42.430
它还会存在一些react 语法在里面

03:42.430 --> 03:44.430
比如这个JSX这些

03:44.430 --> 03:47.430
对吧首先这是一块

03:47.430 --> 03:49.430
好然后接下来这有一块

03:49.430 --> 03:51.430
看着最下面

03:51.430 --> 03:53.430
最下面这个lative

03:53.430 --> 03:57.430
lative的话就是指的是原生平台

03:57.430 --> 03:58.430
指的就是原生平台

03:58.430 --> 03:59.430
那原生平台的话

03:59.430 --> 04:00.430
这边又分为两个部分

04:00.430 --> 04:01.430
首先的话

04:01.430 --> 04:03.430
这边的这个lative modules

04:03.430 --> 04:07.430
那他指的就是原生平台的一些模块

04:07.430 --> 04:09.430
原生平台的一些模块

04:09.430 --> 04:10.430
然后接下来的话

04:10.430 --> 04:13.430
这边这边的话有一个shadow node

04:13.430 --> 04:14.430
这个shadow node是什么呢

04:14.430 --> 04:17.430
这shadow node其实很好理解

04:17.430 --> 04:21.430
大家在学过这个react的话是的这个时候

04:21.430 --> 04:24.430
是不当时学过一个这个叫做虚拟多摩

04:24.430 --> 04:26.430
对吧我通过这个虚拟多摩

04:26.430 --> 04:28.430
然后接下来后面的话

04:28.430 --> 04:30.430
这个在更新这个页面的时候

04:30.430 --> 04:31.430
它速度更快一些

04:31.430 --> 04:34.430
那么在我们的这个lative这里面

04:34.430 --> 04:36.430
他这边的话也会有一个

04:36.430 --> 04:40.430
叫做这个shadow node

04:40.430 --> 04:42.430
就是这个阴影节点

04:42.430 --> 04:44.430
这个的话就类似于什么呢

04:44.430 --> 04:46.430
类似于这个虚拟多摩

04:46.430 --> 04:49.430
ok 类似于虚拟多摩

04:49.430 --> 04:52.430
好那接下来中间这一块

04:52.430 --> 04:55.430
中间这一块这边的话叫做bridge

04:55.430 --> 04:56.430
bridge什么意思

04:56.430 --> 04:57.430
bridge的话

04:57.430 --> 04:59.430
它这个英语翻译成中文

04:59.430 --> 05:01.430
是不是叫做桥

05:01.430 --> 05:02.430
对不对桥

05:02.430 --> 05:03.430
那它这边的话

05:03.430 --> 05:06.430
这是充当一个桥粮的这个作用

05:06.430 --> 05:07.430
它负责什么呢

05:07.430 --> 05:08.430
就是我们刚说了

05:08.430 --> 05:10.430
你这边执行完了之后

05:10.430 --> 05:11.430
你这边的话是

05:11.430 --> 05:13.430
应该是要生成一些代码的

05:13.430 --> 05:14.430
好这些代码的话

05:14.430 --> 05:16.430
通过这个bridge

05:16.430 --> 05:17.430
好然后接下来的话

05:17.430 --> 05:20.430
把它送到这个lative这边

05:20.430 --> 05:24.430
ok 它起起一个这个桥粮的这个作用

05:24.430 --> 05:25.430
然后回头的话

05:25.430 --> 05:26.430
这边让它生成的代码

05:26.430 --> 05:28.430
传到这个lative里面之后

05:28.430 --> 05:30.430
然后接下来再生成什么呢

05:30.430 --> 05:32.430
再生成这个shadow

05:32.430 --> 05:33.430
load

05:33.430 --> 05:35.430
就这个阴影节点数

05:35.430 --> 05:36.430
那接下来最终的话

05:36.430 --> 05:38.430
再根据你的阴影节点数

05:38.430 --> 05:41.430
生成这个最终的这个UI

05:41.430 --> 05:43.430
ok

05:43.430 --> 05:46.430
然后还有一点我们可以看出的

05:46.430 --> 05:47.430
是什么呢

05:47.430 --> 05:49.430
就是我们这边就是这边

05:49.430 --> 05:50.430
javascript side

05:50.430 --> 05:52.430
我这边生成代码之后

05:52.430 --> 05:54.430
我要传递给这个lative这边

05:54.430 --> 05:56.430
它是必须得通过什么

05:56.430 --> 05:58.430
是必须得通过这个bridge

05:58.430 --> 05:59.430
对吧

05:59.430 --> 06:00.430
它两个就好像

06:00.430 --> 06:02.430
就好比两个孤立的这个岛屿

06:02.430 --> 06:03.430
这个是一个岛屿

06:03.430 --> 06:04.430
这个是一个岛屿

06:04.430 --> 06:06.430
那既然我们之间要进行通信

06:06.430 --> 06:07.430
那怎么办呢

06:07.430 --> 06:09.430
我们之间架一座桥

06:09.430 --> 06:10.430
对不对

06:10.430 --> 06:11.430
从这个bridge这个桥上

06:11.430 --> 06:13.430
我把这个数据传递给你

06:13.430 --> 06:14.430
ok

06:14.430 --> 06:16.430
你看这边这边还有一张图

06:16.430 --> 06:18.430
这里

06:18.430 --> 06:20.430
这里的话会有一个这个communication

06:20.430 --> 06:21.430
rn

06:21.430 --> 06:23.430
你看它这边的这个架构

06:23.430 --> 06:25.430
它这边就是javascript

06:25.430 --> 06:27.430
javascript

06:27.430 --> 06:28.430
那既然它会传递什么

06:28.430 --> 06:30.430
它会传递javascript

06:30.430 --> 06:31.430
它实际上的话

06:31.430 --> 06:33.430
它最终生成的是一个javascript

06:33.430 --> 06:34.430
javascript之后

06:34.430 --> 06:36.430
然后传递给这个bridge

06:36.430 --> 06:38.430
传递给bridge之后

06:38.430 --> 06:39.430
再把这个javascript

06:39.430 --> 06:40.430
传递给什么呢

06:40.430 --> 06:42.430
传递给这个lative

06:42.430 --> 06:43.430
serriness

06:43.430 --> 06:46.430
就是原生的这个县城

06:46.430 --> 06:48.430
那么我们这边的话

06:48.430 --> 06:49.430
我们可以来看一下

06:49.430 --> 06:51.430
就是在这个架构下面

06:51.430 --> 06:53.430
整体的一个流程

06:53.430 --> 06:55.430
但是在讲这个流程之前的话

06:55.430 --> 06:57.430
我们需要先解释一些

06:57.430 --> 06:58.430
基本的这个概念

06:58.430 --> 06:59.430
所以我们这边的话

06:59.430 --> 07:00.430
我们先来看一些

07:00.430 --> 07:02.430
比较基础的这个概念

07:02.430 --> 07:03.430
首先第一个概念

07:03.430 --> 07:05.430
叫做UIMelager

07:05.430 --> 07:07.430
这UIMelager它是在哪一侧呢

07:07.430 --> 07:09.430
它是在lative五侧

07:09.430 --> 07:11.430
就是我们刚才所看到

07:11.430 --> 07:12.430
这边这个架构

07:12.430 --> 07:14.430
就是它是在这一侧

07:14.430 --> 07:15.430
看到没有

07:15.430 --> 07:16.430
在这一侧

07:16.430 --> 07:18.430
这个UIMelager

07:18.430 --> 07:19.430
好

07:19.430 --> 07:20.430
这个UIMelager

07:20.430 --> 07:21.430
它是什么呢

07:21.430 --> 07:23.430
它是在这个iOS

07:23.430 --> 07:24.430
和这个Android

07:24.430 --> 07:26.430
里面主要运行的这个县城

07:26.430 --> 07:28.430
只有它有这个权限

07:28.430 --> 07:31.430
可以修改客户端的这个UI

07:31.430 --> 07:33.430
也就是这个UIMelager

07:33.430 --> 07:34.430
它有这个权限

07:34.430 --> 07:36.430
也提供了各种各样的这个方法

07:36.430 --> 07:38.430
通过这个UIMelager

07:38.430 --> 07:39.430
调用它的方法

07:39.430 --> 07:40.430
那接下来就可以什么呢

07:40.430 --> 07:43.430
修改你最终这个客户端的UI

07:43.430 --> 07:45.430
你可以把它理解成就是dorm

07:45.430 --> 07:46.430
对吧

07:46.430 --> 07:48.430
就是浏览器业的这个dorm

07:48.430 --> 07:50.430
最终你通过这个操作这个dorm

07:50.430 --> 07:53.430
那接下来决定了你在浏览器里面

07:53.430 --> 07:55.430
呈现了这个页面

07:55.430 --> 07:56.430
对吧

07:56.430 --> 07:58.430
这是UIMelager

07:58.430 --> 07:59.430
好

07:59.430 --> 08:01.430
接下这个js

08:01.430 --> 08:02.430
js县城

08:02.430 --> 08:03.430
那js县城的话

08:03.430 --> 08:06.430
它是运行打包好后的这个

08:06.430 --> 08:08.430
main.bundle.js

08:08.430 --> 08:09.430
就是我们最终的话

08:09.430 --> 08:10.430
我们写完了

08:10.430 --> 08:12.430
我们是会进行一个文件的打包

08:12.430 --> 08:13.430
对吧

08:13.430 --> 08:15.430
打包之后打包成这个js文件

08:15.430 --> 08:16.430
好

08:16.430 --> 08:17.430
接下来这个文件是有什么呢

08:17.430 --> 08:18.430
是有这个js

08:18.430 --> 08:20.430
也就是说我们刚才说的哪一端

08:20.430 --> 08:22.430
我们刚才说的是不是这一端

08:22.430 --> 08:23.430
对不对

08:23.430 --> 08:25.430
这一端来进行执行

08:26.430 --> 08:27.430
OK

08:27.430 --> 08:29.430
这个文件就就这个文件

08:29.430 --> 08:31.430
然后包含了就是你rn里面

08:31.430 --> 08:33.430
所有的业务逻辑行为

08:33.430 --> 08:35.430
和你用到的一些组件

08:35.430 --> 08:36.430
好

08:36.430 --> 08:39.430
接下来还有一个这个shadow node tree

08:39.430 --> 08:41.430
这个就是那个阴影

08:41.430 --> 08:42.430
阴影节点数

08:42.430 --> 08:44.430
这个的话你就把它理解成什么呢

08:44.430 --> 08:47.430
就把它理解成这个虚拟dorm就可以了

08:47.430 --> 08:48.430
但是那虚拟dorm它是什么

08:48.430 --> 08:50.430
是不是在这个浏览器

08:50.430 --> 08:52.430
浏览器端的这个概念

08:52.430 --> 08:53.430
对不对

08:53.430 --> 08:54.430
你虚拟dorm嘛

08:54.430 --> 08:55.430
dorm节点嘛

08:55.430 --> 08:56.430
对吧

08:56.430 --> 08:58.430
通过接使对象来描述这个

08:58.430 --> 08:59.430
dorm节点

08:59.430 --> 09:01.430
这叫做虚拟dorm

09:01.430 --> 09:03.430
但是你在这个手机端

09:03.430 --> 09:05.430
手机端那没有这些dorm节点对不对

09:05.430 --> 09:06.430
没有什么div

09:06.430 --> 09:08.430
没有这个什么p标签对吧

09:08.430 --> 09:09.430
span标签没有这些

09:09.430 --> 09:10.430
有的只是什么

09:10.430 --> 09:12.430
这有的只是一个一个的组件

09:12.430 --> 09:13.430
对吧

09:13.430 --> 09:15.430
那这个shadow node tree

09:15.430 --> 09:17.430
就这个阴影节点数

09:17.430 --> 09:18.430
它就是什么呢

09:18.430 --> 09:20.430
它其实就是通过这个接使

09:20.430 --> 09:22.430
对象去描述什么呢

09:22.430 --> 09:25.430
描述你这个组件

09:25.430 --> 09:28.430
组件和组件之间的关系就是组件数

09:28.430 --> 09:29.430
就是组件数

09:29.430 --> 09:31.430
所以你就可以把它理解为

09:31.430 --> 09:34.430
这个手机端的这个虚拟dorm

09:35.430 --> 09:37.430
还有一个是优感

09:37.430 --> 09:40.430
优感的话这个可能大家第一次听

09:40.430 --> 09:41.430
这个是用来计算什么呢

09:41.430 --> 09:44.430
这个是用来计算你的布局的

09:44.430 --> 09:45.430
计算布局的

09:45.430 --> 09:47.430
它是facebook写的一个这个

09:47.430 --> 09:49.430
这个c的这个引擎

09:49.430 --> 09:51.430
就我们知道我们在写rn的时候

09:51.430 --> 09:53.430
我们布局我们用的是什么

09:53.430 --> 09:55.430
所以用的是flex

09:55.430 --> 09:57.430
这个flexbox

09:57.430 --> 09:59.430
对吧弹性和布局

09:59.430 --> 10:01.430
但是那个弹性和布局呢

10:01.430 --> 10:04.430
它又怎么说呢

10:04.430 --> 10:07.430
就是它与以法虽然和我们这个

10:07.430 --> 10:10.430
css里面是相似的对吧

10:10.430 --> 10:13.430
和css里面的这个弹性和只是相似的

10:13.430 --> 10:16.430
但它不是说就是直接把css的那一套

10:16.430 --> 10:18.430
直接就拿过来就可以了

10:18.430 --> 10:20.430
它这边呢实际上是什么呢

10:20.430 --> 10:22.430
实际上是rn的话

10:22.430 --> 10:25.430
它需要就是你可以用这个flexbox

10:25.430 --> 10:27.430
似的这个语法来写

10:27.430 --> 10:29.430
来写的话然后接下来我这边的话

10:29.430 --> 10:31.430
自己有一个这个引擎

10:31.430 --> 10:33.430
要来实现你的这个弹性和布局

10:33.430 --> 10:36.430
也就是它把这个复杀性隐藏了

10:36.430 --> 10:38.430
对于这个开发者来讲

10:38.430 --> 10:40.430
我只需要用这个弹性和的这个

10:40.430 --> 10:41.430
语法来写就可以了

10:41.430 --> 10:42.430
但是背后的话

10:42.430 --> 10:43.430
这个就非是不可

10:43.430 --> 10:44.430
它在背后

10:44.430 --> 10:47.430
它这边是花了这个大量的那个力气的

10:47.430 --> 10:50.430
对吧自己写了一个这个YOGA这个引擎

10:50.430 --> 10:51.430
最终的话

10:51.430 --> 10:53.430
它可以把你写的这个弹性和

10:53.430 --> 10:55.430
你写的这些语法

10:55.430 --> 10:57.430
正常的这个把它布局把它布出来

10:57.430 --> 11:00.430
并且和这个css的这个弹性和的布局

11:00.430 --> 11:02.430
效果是一样的

11:02.430 --> 11:04.430
OK这是这个YOGA

11:04.430 --> 11:08.430
OK了解了这个这些基础概念之后

11:08.430 --> 11:10.430
然后接下来我们再来看

11:10.430 --> 11:12.430
再来看就是我们这个价格下面

11:12.430 --> 11:14.430
一个整体的流程

11:14.430 --> 11:17.430
你看我这边把那个图放在这的

11:17.430 --> 11:19.430
大家可以再回过一下这个图

11:19.430 --> 11:21.430
OK那首先第一步

11:21.430 --> 11:22.430
第一步的话用户的话

11:22.430 --> 11:24.430
它先点击这个APP图标

11:24.430 --> 11:26.430
对吧我要打开这个应用了

11:26.430 --> 11:28.430
好点击这个APP图标之后

11:28.430 --> 11:29.430
好首先的话是什么呢

11:29.430 --> 11:32.430
首先是这个UIMelider这个线程

11:32.430 --> 11:34.430
就是哪一端

11:34.430 --> 11:35.430
就这一端

11:35.430 --> 11:37.430
这一端对吧

11:37.430 --> 11:38.430
而这一端的话

11:38.430 --> 11:40.430
它会去夹载这个所有的

11:40.430 --> 11:43.430
native cool和这个native 组件

11:43.430 --> 11:45.430
比如这些什么text 啊

11:45.430 --> 11:47.430
button 啊image 啊这些

11:47.430 --> 11:48.430
它会去夹载

11:48.430 --> 11:50.430
而夹载完了之后

11:50.430 --> 11:51.430
然后下一步

11:51.430 --> 11:53.430
下一步它就会告诉这个

11:53.430 --> 11:54.430
jess 线程

11:54.430 --> 11:56.430
就是我这边的话

11:56.430 --> 11:57.430
已经准备好了

11:57.430 --> 11:58.430
你那边的话

11:58.430 --> 12:00.430
可以开始来夹载你的这个

12:00.430 --> 12:02.430
main.bundle.jess了

12:02.430 --> 12:03.430
那这边的话

12:03.430 --> 12:05.430
它通过什么来进行通信

12:05.430 --> 12:07.430
通过这个bridge

12:07.430 --> 12:08.430
对了我这边呢

12:08.430 --> 12:09.430
先发消息给bridge

12:09.430 --> 12:11.430
那bridge再发消息给什么

12:11.430 --> 12:13.430
给这个javascript

12:13.430 --> 12:15.430
这边对了给jess 线程

12:15.430 --> 12:17.430
这边呢就是开始夹载

12:17.430 --> 12:19.430
我们所写的

12:19.430 --> 12:21.430
自己写的这个业务逻辑

12:21.430 --> 12:23.430
OK开始夹载

12:23.430 --> 12:24.430
夹载完了之后

12:24.430 --> 12:25.430
然后接下来

12:25.430 --> 12:27.430
jess 车再通过这个bridge

12:27.430 --> 12:29.430
发送一条

12:29.430 --> 12:31.430
这个一条这个jesson消息

12:31.430 --> 12:33.430
它始终传递的是jesson

12:33.430 --> 12:35.430
我们刚才是不是有个图

12:35.430 --> 12:37.430
对吧始终传递的是这个jesson

12:37.430 --> 12:39.430
它这边通过这个bridge

12:39.430 --> 12:40.430
传过来

12:40.430 --> 12:41.430
然后接下来告诉什么呢

12:41.430 --> 12:42.430
告诉这个lative

12:42.430 --> 12:43.430
就原生平台

12:43.430 --> 12:47.430
你如何来创建这个UI

12:47.430 --> 12:48.430
这里有个点

12:48.430 --> 12:49.430
有个点就是这边

12:49.430 --> 12:51.430
所有的这个通信

12:51.430 --> 12:53.430
它是异步的

12:53.430 --> 12:54.430
OK

12:54.430 --> 12:55.430
它是异步的

12:55.430 --> 12:57.430
并且是这个打包发送的

12:57.430 --> 12:58.430
它主要是为了避免这个

12:58.430 --> 13:00.430
组设这个UI

13:00.430 --> 13:01.430
OK

13:01.430 --> 13:03.430
好 接下来再下一步

13:03.430 --> 13:04.430
再下一步的话

13:04.430 --> 13:06.430
这个shadow这个线程

13:06.430 --> 13:08.430
这个线程就这边

13:08.430 --> 13:09.430
这个shadow load

13:09.430 --> 13:10.430
它这个线程

13:10.430 --> 13:12.430
它最先拿到这个消息

13:12.430 --> 13:13.430
拿到消息之后

13:13.430 --> 13:14.430
然后接下来它开始来

13:14.430 --> 13:16.430
创建这个UI数

13:16.430 --> 13:18.430
也就是我们刚才所说的那个

13:18.430 --> 13:20.430
shadow load tree

13:20.430 --> 13:22.430
就是那个

13:22.430 --> 13:23.430
阴影节点数

13:23.430 --> 13:25.430
这个在它官方也有

13:25.430 --> 13:28.430
官方在这边

13:28.430 --> 13:30.430
等一下我退一下

13:30.430 --> 13:32.430
官方的话在这边

13:32.430 --> 13:34.430
你这边大家可以看一下

13:34.430 --> 13:35.430
这个阴影节点数

13:35.430 --> 13:37.430
其实就和那个虚拟动物是

13:37.430 --> 13:38.430
差不多的

13:38.430 --> 13:40.430
在这里

13:40.430 --> 13:41.430
可不可以吗

13:41.430 --> 13:42.430
这边react and let him

13:42.430 --> 13:43.430
可不可以

13:43.430 --> 13:45.430
你看这张图吧

13:45.430 --> 13:47.430
看下面有个修改的

13:47.430 --> 13:48.430
有个修改的

13:48.430 --> 13:50.430
我看是在哪里

13:50.430 --> 13:52.430
update

13:52.430 --> 13:54.430
就这个

13:54.430 --> 13:55.430
就这个

13:55.430 --> 13:56.430
这边出来没有

13:56.430 --> 13:57.430
你看这边

13:57.430 --> 13:58.430
可不可以

13:58.430 --> 14:00.430
它这边就是会有一个

14:00.430 --> 14:02.430
阴影节点数

14:02.430 --> 14:04.430
这个是我们写的

14:04.430 --> 14:06.430
我们这边写的什么view

14:06.430 --> 14:08.430
这边我们用一个一个组件

14:08.430 --> 14:09.430
写了之后它会被

14:09.430 --> 14:11.430
映射为一个阴影节点数

14:11.430 --> 14:14.430
就类似于虚拟动物

14:14.430 --> 14:16.430
再根据虚拟动物

14:16.430 --> 14:17.430
最终创建什么呢

14:17.430 --> 14:19.430
就是真实的这个仕途

14:19.430 --> 14:21.430
真实的这个UI

14:21.430 --> 14:23.430
OK

14:23.430 --> 14:27.130
回到我们这边

14:27.130 --> 14:29.130
这边第几步了

14:29.130 --> 14:31.130
这边这个虾斗现成

14:31.130 --> 14:33.130
拿到这个消息

14:33.130 --> 14:36.130
然后创建UI数

14:36.130 --> 14:38.130
就是这个虾斗

14:38.130 --> 14:40.130
虾斗这个节点数

14:40.130 --> 14:41.130
下一步

14:41.130 --> 14:42.130
下一步的话就是使用什么呢

14:42.130 --> 14:44.130
使用这个yoga

14:44.130 --> 14:46.130
使用yoga布局引擎

14:46.130 --> 14:48.130
去获取所有基于

14:48.130 --> 14:50.130
flex样式的布局

14:50.130 --> 14:52.130
最终把它转换为

14:52.130 --> 14:55.130
原生平台的宽高

14:55.130 --> 14:56.130
建居的

14:56.130 --> 14:58.130
你注意就是在RN里面

14:58.130 --> 15:00.130
布局它用的是这个yoga

15:00.130 --> 15:02.130
用的是这个

15:02.130 --> 15:04.130
用的是这个来实现什么呢

15:04.130 --> 15:06.130
实现flex

15:06.130 --> 15:08.130
接下来最后

15:08.130 --> 15:10.130
最后的话就是再调用UI

15:10.130 --> 15:11.130
manager

15:11.130 --> 15:12.130
因为我们刚才说过了

15:12.130 --> 15:14.130
只有什么呀

15:14.130 --> 15:16.130
只有UI manager

15:16.130 --> 15:18.130
只有它有权限可以修改

15:18.130 --> 15:20.130
客户端的UI

15:20.130 --> 15:22.130
所以你一切工作

15:22.130 --> 15:23.130
准备好之后

15:23.130 --> 15:25.130
最终还是UI manager

15:25.130 --> 15:27.130
它去执行一些操作

15:27.130 --> 15:29.130
最终把这个仕图

15:29.130 --> 15:31.130
绘制到这个屏幕上面

15:31.130 --> 15:33.130
OK

15:33.130 --> 15:34.130
你看这个的话就是这个

15:34.130 --> 15:35.130
整个RN

15:35.130 --> 15:37.130
它的一个架构

15:37.130 --> 15:40.130
在这个架构下的一个流程

15:40.130 --> 15:41.130
这个架构的话

15:41.130 --> 15:43.130
我们来看一下它的这个优点

15:43.130 --> 15:44.130
优点的话

15:44.130 --> 15:46.130
首先第1个就是UI不会主色

15:46.130 --> 15:47.130
因为我们刚才说过

15:47.130 --> 15:49.130
它这个发送这个接身的时候

15:49.130 --> 15:50.130
它都是什么

15:50.130 --> 15:51.130
都是一步的

15:51.130 --> 15:52.130
对吧

15:52.130 --> 15:53.130
还记得吧

15:53.130 --> 15:54.130
刚才这里

15:54.130 --> 15:55.130
在哪

15:55.130 --> 15:56.130
这里

15:56.130 --> 15:58.130
它的这个通行都是一步的

15:58.130 --> 15:59.130
对不对

15:59.130 --> 16:01.130
避免了这个主色UI

16:01.130 --> 16:04.130
首先的话UI不会被主色

16:04.130 --> 16:05.130
第二个

16:05.130 --> 16:08.130
不需要写LAT5车的代码

16:08.130 --> 16:10.130
这个大家是深有感受的

16:10.130 --> 16:12.130
就我们写的其实就是什么

16:12.130 --> 16:14.130
就是JS代码

16:14.130 --> 16:15.130
我们需不需要关心

16:15.130 --> 16:19.130
安卓里面的代码是这么写的

16:19.130 --> 16:21.130
或者iOS里面的代码是这么写的

16:21.130 --> 16:22.130
不需要

16:22.130 --> 16:23.130
对不对

16:23.130 --> 16:25.130
我们完全不需要管LAT5车的代码

16:25.130 --> 16:27.130
我们只需要写什么呢

16:27.130 --> 16:28.130
只需要写就是我们这边

16:28.130 --> 16:30.130
JS这边的

16:30.130 --> 16:31.130
对吧

16:31.130 --> 16:32.130
好然后接下来

16:32.130 --> 16:35.130
性能的话更加接近这个LAT5

16:35.130 --> 16:36.130
因为你最终的话

16:36.130 --> 16:39.130
你是会被硬设为这个原生平台的

16:39.130 --> 16:40.130
这个主键

16:40.130 --> 16:41.130
对吧

16:41.130 --> 16:43.130
就你的这个代码会被做一个硬设

16:43.130 --> 16:46.130
硬设成这个原生平台的

16:46.130 --> 16:48.130
好然后下一个

16:48.130 --> 16:50.130
整个流程是完整的

16:50.130 --> 16:52.130
开发者的话不需要去控制

16:52.130 --> 16:53.130
并且完全了解它

16:53.130 --> 16:54.130
就整个它的这个架构

16:54.130 --> 16:56.130
它给你封装好了

16:56.130 --> 16:58.130
你只需要用你的这个JS代码

16:58.130 --> 17:01.130
就是JS你去写这个代码就可以了

17:01.130 --> 17:03.130
OK这是整体这个架构

17:03.130 --> 17:05.130
它的一个优点

17:05.130 --> 17:08.130
那这个架构他有没有缺点呢

17:08.130 --> 17:09.130
他也有缺点

17:09.130 --> 17:11.130
如果他没有缺点的话

17:11.130 --> 17:12.130
他这个一直用这个架构了

17:12.130 --> 17:14.130
这个其实是以前的架构

17:14.130 --> 17:16.130
他现在架构是改了的

17:16.130 --> 17:17.130
架构是改了的

17:17.130 --> 17:19.130
我们来看他的这个缺点

17:19.130 --> 17:21.130
缺点是什么呢

17:21.130 --> 17:23.130
首先的话你有两个不同的领域

17:23.130 --> 17:26.130
一个是JS一个是LATV

17:26.130 --> 17:27.130
大家还记得吧

17:27.130 --> 17:29.130
就我们刚才那个架构图

17:29.130 --> 17:31.130
上边是这个JS

17:31.130 --> 17:33.130
下边是LATV

17:33.130 --> 17:36.130
两者之间通过什么来进行通信

17:36.130 --> 17:38.130
通过那个Bread

17:38.130 --> 17:39.130
对不对

17:39.130 --> 17:41.130
通过Bread来进行通信

17:41.130 --> 17:43.130
所以这里有句话叫做

17:43.130 --> 17:46.130
他们彼此之间并不能真正的相互感知

17:46.130 --> 17:50.130
也不能共享这个相同的这个内存

17:51.130 --> 17:53.130
我这边让我这个JS做了改变

17:53.130 --> 17:54.130
做了什么改变之后

17:54.130 --> 17:55.130
那既然我都要干嘛呢

17:55.130 --> 17:58.130
都要就是重新生成这个新的这个JS

17:58.130 --> 18:02.130
然后接下来通过这个Bread发送给LATV

18:03.130 --> 18:04.130
那这样子的话

18:04.130 --> 18:06.130
他其实就是意味着什么呢

18:06.130 --> 18:09.130
意味着他的这个效率会比较低

18:10.130 --> 18:14.130
他们之间的通信是基于Bread的异部通信

18:14.130 --> 18:16.130
然后意味着并不能保证

18:16.130 --> 18:19.130
这个数据百分之百即时到达另一侧

18:19.130 --> 18:20.130
他是异部的

18:20.130 --> 18:21.130
这刚才也说了

18:22.130 --> 18:23.130
好然后下一个

18:23.130 --> 18:26.130
传输大数据非常慢

18:26.130 --> 18:29.130
所有在这个JS和LATV之间

18:29.130 --> 18:32.130
传输的数据都是一次新的这个负责

18:32.130 --> 18:35.130
OK因为他们这个内存不能共享吗

18:35.130 --> 18:36.130
不能共享的话

18:36.130 --> 18:38.130
那我这边就是每次的话我都需要干嘛

18:38.130 --> 18:40.130
我这边我要传就是比如我JS端

18:40.130 --> 18:43.130
要传这个数据给这个LATV端

18:43.130 --> 18:44.130
那意味着什么呢

18:44.130 --> 18:47.130
意味着我这边的话要把我的数据负责一份

18:47.130 --> 18:48.130
对不对

18:48.130 --> 18:50.130
再通过Bread级传输给你

18:51.130 --> 18:54.130
下一个无法同步的更新UI

18:54.130 --> 18:57.130
比如说我这边就是有一个Flatlist

18:57.130 --> 18:59.130
他的这个数据量很大的时候

18:59.130 --> 19:01.130
那你这个不停的滑动的话

19:01.130 --> 19:02.130
他可能会干嘛呢

19:02.130 --> 19:04.130
可能就是会发生这个闪烁

19:04.130 --> 19:06.130
因为你是异部的嘛

19:06.130 --> 19:07.130
对不对你滑到最下面的话

19:07.130 --> 19:09.130
有可能这个数据他还没过来

19:10.130 --> 19:11.130
还没过来

19:12.130 --> 19:15.130
那最后一个RN代码仓库太大了

19:15.130 --> 19:17.130
他有一个Bread级在里面

19:17.130 --> 19:18.130
那个Bread级的话

19:18.130 --> 19:19.130
然后那个挺大的

19:19.130 --> 19:22.130
那导致这个库更重

19:22.130 --> 19:26.130
然后这个修复发布也更慢

19:26.130 --> 19:29.130
可以看到就是整体就是以前就了这个架构

19:29.130 --> 19:32.130
它是存在这么一些这个缺点的

19:32.130 --> 19:34.130
不是说完全没有缺点

19:34.130 --> 19:35.130
所以后面啊

19:35.130 --> 19:37.130
后面的话这个RN官方

19:37.130 --> 19:39.130
那就把他们的这个架构

19:39.130 --> 19:41.130
进行了一个修改

19:41.130 --> 19:44.130
那我们来看一下这个新的这个架构示意图

19:45.130 --> 19:46.130
你看

19:46.130 --> 19:49.130
这边的话这个架构示意图就变成这个样子了

19:50.130 --> 19:52.130
感觉有些东西变了

19:52.130 --> 19:53.130
对吧

19:53.130 --> 19:54.130
但具体变了哪里的话

19:54.130 --> 19:57.130
好像一时半会说不上没关系

19:57.130 --> 19:59.130
这边的话我把这个两张图

19:59.130 --> 20:01.130
我把它放出来

20:01.130 --> 20:03.130
你这边的话可以做一个对比

20:03.130 --> 20:06.130
你这会你可以把那个视频暂停吗

20:06.130 --> 20:09.130
暂停了让你对比一下哪些部分

20:09.130 --> 20:10.130
发生了变化

20:10.130 --> 20:11.130
OK

20:12.130 --> 20:13.130
那我们这边我们可以看到

20:13.130 --> 20:15.130
明显的看到首先的话这个Bread

20:16.130 --> 20:17.130
Bread还在不在

20:18.130 --> 20:19.130
Bread是不是就不在了

20:19.130 --> 20:21.130
取而代之的是什么

20:21.130 --> 20:23.130
取而代之的是这个JSI

20:23.130 --> 20:24.130
对吧

20:24.130 --> 20:25.130
上面是没有变化的

20:25.130 --> 20:27.130
上面以前是这边

20:27.130 --> 20:29.130
这个Javascript side的这边

20:29.130 --> 20:30.130
JS引擎React

20:30.130 --> 20:32.130
这边是没有变化的

20:32.130 --> 20:33.130
Bread没了

20:33.130 --> 20:35.130
Bread变成了这个JSI

20:35.130 --> 20:36.130
对吧

20:36.130 --> 20:38.130
下面的话这个原生平台

20:38.130 --> 20:39.130
原生平台的话

20:39.130 --> 20:41.130
以前的话这边这个Lative Modules

20:41.130 --> 20:43.130
变成了什么呢

20:43.130 --> 20:46.130
变成了这个Tuber Modules

20:46.130 --> 20:48.130
Tuber Modules

20:48.130 --> 20:50.130
然后接下来这边会有一个什么呢

20:50.130 --> 20:51.130
会有个Fabric

20:51.130 --> 20:53.130
这就是他那个官网

20:53.130 --> 20:57.130
写的这个新的这个渲染引擎

20:57.130 --> 20:58.130
然后还有一个什么呢

20:58.130 --> 21:01.130
还有一个是这个CodeGin

21:01.130 --> 21:02.130
CodeGin

21:02.130 --> 21:03.130
OK

21:03.130 --> 21:05.130
那整体的变化的主要就是

21:05.130 --> 21:07.130
其中在这一块

21:07.130 --> 21:09.130
可不可以坐在这一块

21:09.130 --> 21:10.130
好那我们这边

21:10.130 --> 21:11.130
我们来一块一块来看

21:11.130 --> 21:14.130
首先的话这边一些新的概念

21:14.130 --> 21:16.130
首先的话是这个JSI

21:16.130 --> 21:18.130
就这个东西

21:18.130 --> 21:20.130
就这个东西

21:20.130 --> 21:21.130
这个东西是什么呢

21:21.130 --> 21:26.130
这个东西全称叫做Javascript interface

21:26.130 --> 21:29.130
它是用这个C++写的一个框架

21:29.130 --> 21:31.130
它的作用是什么呢

21:31.130 --> 21:33.130
它的作用的话就是你JS对象

21:33.130 --> 21:36.130
可以直接获得Lative

21:36.130 --> 21:38.130
端的这个对象的这个引用

21:38.130 --> 21:40.130
并且调用它的方法

21:40.130 --> 21:41.130
什么意思

21:41.130 --> 21:42.130
什么意思

21:42.130 --> 21:43.130
就以前啊你这边

21:43.130 --> 21:45.130
你这边写了之后

21:45.130 --> 21:46.130
比如我这边改了之后

21:46.130 --> 21:47.130
然后这样我这边干嘛

21:47.130 --> 21:49.130
所以我要先给这个Bread

21:49.130 --> 21:50.130
对不对

21:50.130 --> 21:51.130
我要生成这个接生

21:51.130 --> 21:52.130
要传递接生给它

21:52.130 --> 21:53.130
然后接下来它在干嘛

21:53.130 --> 21:57.130
它是不是在传给这个原生平台

21:57.130 --> 21:58.130
对不对

21:58.130 --> 21:59.130
它是个桥梁嘛

21:59.130 --> 22:00.130
我们刚才说了

22:00.130 --> 22:01.130
但现在的架构的话

22:01.130 --> 22:03.130
它是一个这个接口

22:03.130 --> 22:05.130
一个接口相当于什么呢

22:05.130 --> 22:07.130
你这边通过这个JS

22:07.130 --> 22:08.130
直接可以什么呢

22:08.130 --> 22:11.130
直接可以拿到原生的一些对象

22:11.130 --> 22:15.130
并且调用它这里面的一些方法

22:15.130 --> 22:16.130
看到没有

22:16.130 --> 22:18.130
我不需要再像以前一样

22:18.130 --> 22:20.130
通过这个Bread传接生给你

22:20.130 --> 22:23.130
Bread就把这个接生传给Lative

22:23.130 --> 22:25.130
这样子传内存又不共享

22:25.130 --> 22:26.130
对吧

22:26.130 --> 22:27.130
每次传我都需要复制一份

22:27.130 --> 22:28.130
那我现在干嘛呢

22:28.130 --> 22:30.130
我现在我直接

22:30.130 --> 22:34.130
调用你这边对象里面的这个方法

22:34.130 --> 22:35.130
看到没有

22:35.130 --> 22:36.130
就通过这个接口

22:36.130 --> 22:37.130
它是提供了一个接口

22:37.130 --> 22:39.130
通过我这边调用你的这个接口

22:39.130 --> 22:41.130
那这边的话就直接

22:41.130 --> 22:43.130
类似于就直接调用

22:43.130 --> 22:45.130
这边你这个对象的这个方法

22:45.130 --> 22:46.130
OK

22:47.130 --> 22:48.130
好

22:48.130 --> 22:50.130
然后将不再需要通过这个Bread

22:50.130 --> 22:54.130
传输序略化的这个接生

22:54.130 --> 22:55.130
刚才是不是说过了

22:55.130 --> 22:56.130
对不对

22:56.130 --> 22:59.130
允许这个Lative对象被导出成JS对象

22:59.130 --> 23:00.130
就我这边

23:00.130 --> 23:01.130
我这边的这个对象

23:01.130 --> 23:03.130
可以导成这个JS对象

23:03.130 --> 23:04.130
这边的反过来JS对象

23:04.130 --> 23:05.130
也可以导成什么呢

23:05.130 --> 23:07.130
导成这个就是原生的对象

23:07.130 --> 23:08.130
看到没有

23:08.130 --> 23:09.130
OK

23:10.130 --> 23:11.130
好

23:11.130 --> 23:12.130
然后这个JSi的话

23:12.130 --> 23:15.130
它还支持其他的这个JS引擎

23:15.130 --> 23:16.130
它这边不是说写死了

23:16.130 --> 23:18.130
它是一套接口

23:18.130 --> 23:21.130
你只要符合我这个接口的都可以

23:21.130 --> 23:22.130
对吧

23:22.130 --> 23:23.130
所以它可以支持其他的这个引擎

23:23.130 --> 23:25.130
比如说我谷歌的V8引擎

23:25.130 --> 23:28.130
或者这个微软的这个JS引擎

23:28.130 --> 23:29.130
都可以

23:30.130 --> 23:31.130
好

23:31.130 --> 23:35.130
应该允许现成之间的这个同步相互执行

23:35.130 --> 23:37.130
是不是就解决了刚才的那个问题

23:37.130 --> 23:39.130
对不对

23:39.130 --> 23:42.130
然后还有就是JSi的话

23:42.130 --> 23:44.130
它是用C++写的

23:44.130 --> 23:45.130
如果你以后

23:45.130 --> 23:46.130
你要针对这个电视呀

23:46.130 --> 23:47.130
手表啊

23:47.130 --> 23:49.130
这些系统这个系统

23:49.130 --> 23:51.130
这个遗址的话也非常方便

23:51.130 --> 23:53.130
这是首先它的第一个

23:53.130 --> 23:54.130
非常重要的

23:54.130 --> 23:57.130
最最重要的就是这个JSi

23:57.130 --> 23:58.130
好

23:58.130 --> 23:59.130
第二个

23:59.130 --> 24:01.130
第二个的话就是这个fabric

24:01.130 --> 24:03.130
fabric就是这一块

24:04.130 --> 24:05.130
这个是怎么呢

24:05.130 --> 24:07.130
这个是它新的这个渲染系统

24:07.130 --> 24:09.130
它就是用来取代

24:09.130 --> 24:11.130
之前的这个UI Manager的

24:11.130 --> 24:12.130
我们之前说过

24:12.130 --> 24:14.130
就是你要改变这个UI

24:14.130 --> 24:16.130
是不是通过这个什么

24:16.130 --> 24:18.130
只能通过UI Manager

24:18.130 --> 24:19.130
对吧

24:19.130 --> 24:20.130
那以前这个UI Manager

24:20.130 --> 24:21.130
它是怎么改的呢

24:21.130 --> 24:22.130
我们来看一下

24:22.130 --> 24:24.130
以前的这个UI Manager

24:24.130 --> 24:25.130
首先的话

24:25.130 --> 24:27.130
你这个wrapped执行你的代码

24:27.130 --> 24:31.130
在JS里面创建一个react element tree

24:31.130 --> 24:33.130
然后接下来的话

24:33.130 --> 24:34.130
基于这棵树

24:34.130 --> 24:36.130
那你的这个渲染器

24:36.130 --> 24:38.130
会在C++中

24:38.130 --> 24:39.130
创建一个什么呢

24:39.130 --> 24:41.130
创建一个react shadow tree

24:41.130 --> 24:43.130
这就是我们刚所说的这个阴影树

24:43.130 --> 24:44.130
对吧

24:44.130 --> 24:45.130
然后接下来的话

24:45.130 --> 24:47.130
你这个UI Manager

24:47.130 --> 24:48.130
再根据什么呢

24:48.130 --> 24:50.130
根据你的这个shadow tree

24:50.130 --> 24:54.130
来计算这个UI元素的这个位置

24:54.130 --> 24:55.130
基本上呢

24:55.130 --> 24:57.130
Fabric其实也是这样子的

24:57.130 --> 24:59.130
但是它有一些小小的变化

24:59.130 --> 25:00.130
主要在哪里呢

25:00.130 --> 25:01.130
就是你看之前

25:01.130 --> 25:03.130
之前比如说你这个UI Manager

25:03.130 --> 25:04.130
比如说这边

25:04.130 --> 25:06.130
一旦这个布局完成

25:06.130 --> 25:07.130
这个shadow tree

25:07.130 --> 25:10.130
就会被转换为由这个元身元素

25:10.130 --> 25:14.130
组成了这个元身仕途这个树

25:14.130 --> 25:15.130
就是你这个

25:15.130 --> 25:16.130
你这个是虚拟的吗

25:16.130 --> 25:17.130
对吧

25:17.130 --> 25:18.130
类似于这个虚拟动物

25:18.130 --> 25:20.130
最终它会构建一个什么呢

25:20.130 --> 25:22.130
构建一个元身仕途的这个

25:22.130 --> 25:23.130
组建的这个树

25:23.130 --> 25:24.130
但是呢

25:24.130 --> 25:25.130
它有一个缺点

25:25.130 --> 25:28.130
就是之前的这个县城之间的这个通信

25:28.130 --> 25:32.130
每次都是发生在Bread上面的

25:32.130 --> 25:33.130
那意味着什么呢

25:33.130 --> 25:36.130
意味着就是消耗时间

25:36.130 --> 25:37.130
对吧

25:37.130 --> 25:39.130
你每次你都需要在这个

25:39.130 --> 25:40.130
这个传输

25:40.130 --> 25:42.130
还有就是这个数据的这个复制上面

25:42.130 --> 25:44.130
你要消耗这个大量的这个时间

25:44.130 --> 25:46.130
通过这个接受

25:46.130 --> 25:47.130
把它传遞过去

25:47.130 --> 25:48.130
好

25:48.130 --> 25:50.130
那接下来新的这个fabric

25:50.130 --> 25:51.130
它其实就是什么

25:51.130 --> 25:53.130
它其实就是基于这个gsi

25:53.130 --> 25:54.130
因为刚刚我们讲了

25:54.130 --> 25:55.130
这个通过gsi

25:55.130 --> 25:56.130
我这一测

25:56.130 --> 25:59.130
是不是可以直接调用你这一测

25:59.130 --> 26:01.130
是不是这个对象的这个方法

26:01.130 --> 26:02.130
对不对

26:02.130 --> 26:03.130
说这边的这个gsi

26:03.130 --> 26:06.130
可以直接调用lative的这个方法

26:06.130 --> 26:08.130
它其中就包含了什么呢

26:08.130 --> 26:11.130
包含了ui方法

26:11.130 --> 26:14.130
所以这个gsi和这个ui县城

26:14.130 --> 26:15.130
可以同步执行

26:15.130 --> 26:18.130
那它的这个效率就更高了一些

26:18.130 --> 26:19.130
但它背后的话

26:19.130 --> 26:20.130
其实还是什么

26:20.130 --> 26:23.130
还是就是这边的话就是要创建这个

26:23.130 --> 26:24.130
阴影树

26:24.130 --> 26:26.130
然后再根据这个阴影树来

26:26.130 --> 26:28.130
计算这个ui元素的位置

26:28.130 --> 26:29.130
这些是没变的

26:29.130 --> 26:30.130
这些是没变的

26:30.130 --> 26:31.130
主要就是什么呢

26:31.130 --> 26:32.130
主要就是通信的方式

26:32.130 --> 26:35.130
以前我是需要先拿给这个bridge

26:35.130 --> 26:37.130
bridge再传给lative

26:37.130 --> 26:40.130
现在我这边我直接调用什么呢

26:40.130 --> 26:43.130
直接调用你的这个

26:43.130 --> 26:46.130
这个就是ui相关的这个方法

26:46.130 --> 26:47.130
看没有

26:47.130 --> 26:49.130
这是这个fabric

26:49.130 --> 26:51.130
然后接下来还有什么呢

26:51.130 --> 26:53.130
还就是这一块

26:53.130 --> 26:55.130
tubal models

26:55.130 --> 26:57.130
tubal models其实就是什么呢

26:57.130 --> 27:00.130
就是针对以前这个lative models

27:00.130 --> 27:03.130
针对这一块的一个增强

27:03.130 --> 27:04.130
我们来看一下

27:04.130 --> 27:05.130
tubal models

27:05.130 --> 27:08.130
就是在之前的这个架构中

27:08.130 --> 27:11.130
gsi使用的是lative models

27:11.130 --> 27:13.130
就原生的一些模块

27:13.130 --> 27:14.130
比如什么南芽呀

27:14.130 --> 27:15.130
地理位置呀

27:15.130 --> 27:16.130
文件存储呀

27:16.130 --> 27:18.130
那这些模块的话

27:18.130 --> 27:20.130
它在应用程序

27:20.130 --> 27:22.130
打开之前

27:22.130 --> 27:26.130
就必须要进行这个初始化

27:26.130 --> 27:28.130
那这里就会有一个问题

27:28.130 --> 27:30.130
就可能就是我的这个应用压根

27:30.130 --> 27:32.130
就没用到你这个模块

27:32.130 --> 27:33.130
对不对

27:33.130 --> 27:34.130
没用到你这个模块

27:34.130 --> 27:35.130
但是你这边的话

27:35.130 --> 27:36.130
还是要求我

27:36.130 --> 27:39.130
启动之前先进行一个初始化

27:39.130 --> 27:40.130
那这个tubal models

27:40.130 --> 27:42.130
他就是基本就是对这个lative models

27:42.130 --> 27:45.130
他进行了一个增强

27:45.130 --> 27:46.130
OK

27:46.130 --> 27:47.130
那现在的话

27:47.130 --> 27:50.130
gsi能够持有这些模块的这个应用

27:50.130 --> 27:52.130
所以说这个gsi代码

27:52.130 --> 27:53.130
可以在紧

27:53.130 --> 27:55.130
就是紧在需要的时候

27:55.130 --> 27:58.130
才夹在这个对应的这个模块

27:58.130 --> 28:00.130
这也大大的这个缩短了

28:00.130 --> 28:04.130
这个你这个RN他启动的一个时间

28:04.130 --> 28:05.130
对吧

28:05.130 --> 28:07.130
这是tubal models

28:07.130 --> 28:09.130
最后最后的话就是这一块了

28:09.130 --> 28:10.130
对不对

28:10.130 --> 28:11.130
这个code-in

28:11.130 --> 28:13.130
这个code-in是什么呢

28:13.130 --> 28:14.130
我们来看一下

28:14.130 --> 28:16.130
就我们刚才讲的这个fabric

28:16.130 --> 28:19.130
以及这个tubal models

28:19.130 --> 28:21.130
这些东西它都是通过什么呢

28:21.130 --> 28:23.130
都是通过这个gsi

28:23.130 --> 28:25.130
实际上都是通过这个gsi

28:25.130 --> 28:26.130
让我什么呢

28:26.130 --> 28:27.130
让我这个gsi

28:27.130 --> 28:30.130
能够直接调用这个lative

28:30.130 --> 28:32.130
对象的这个方法

28:32.130 --> 28:34.130
但是这里存在一个问题

28:34.130 --> 28:35.130
什么问题呢

28:35.130 --> 28:36.130
就是我这边的话

28:36.130 --> 28:37.130
我的这个gsi

28:37.130 --> 28:39.130
它是一个动态的语言

28:39.130 --> 28:40.130
而我这个gsi

28:40.130 --> 28:41.130
就这个接口

28:41.130 --> 28:42.130
它是什么呢

28:42.130 --> 28:44.130
它是这个C++的

28:45.130 --> 28:46.130
它是静态的

28:46.130 --> 28:47.130
那静态的话

28:47.130 --> 28:48.130
大家都知道

28:48.130 --> 28:50.130
我这边一旦比如说我参数

28:50.130 --> 28:52.130
传递的这个不一样

28:52.130 --> 28:53.130
比如人家要求是三个参数

28:53.130 --> 28:55.130
我只传了两个参数

28:55.130 --> 28:57.130
那这边它是不是就会爆错

28:57.130 --> 28:58.130
对不对

28:58.130 --> 28:59.130
就会爆错的

28:59.130 --> 29:00.130
所以这个code-in的话

29:00.130 --> 29:02.130
它其实是一个什么呢

29:02.130 --> 29:05.130
它是一个静态类型检查器

29:05.130 --> 29:08.130
静态类型检查器

29:09.130 --> 29:10.130
它会去检查什么呢

29:10.130 --> 29:11.130
它会去检查

29:11.130 --> 29:13.130
就是你这边的这个javascript

29:13.130 --> 29:14.130
比如你这个javascript

29:14.130 --> 29:15.130
比如说你这边的话

29:15.130 --> 29:16.130
就是调用

29:16.130 --> 29:18.130
不符合这个要求的话

29:18.130 --> 29:19.130
它会自动的什么呢

29:19.130 --> 29:21.130
自动的去修补

29:21.130 --> 29:22.130
OK

29:22.130 --> 29:23.130
所以你看这边

29:23.130 --> 29:24.130
code-in的话

29:24.130 --> 29:26.130
它使用类型

29:26.130 --> 29:29.130
这个类型确定后的javascript

29:29.130 --> 29:30.130
就你这边的话

29:30.130 --> 29:32.130
它会自动对你的javascript

29:32.130 --> 29:34.130
进行一个类型检查

29:34.130 --> 29:35.130
并且自动的话

29:35.130 --> 29:36.130
进行一些修复

29:36.130 --> 29:37.130
那接下来

29:37.130 --> 29:38.130
确定之后

29:38.130 --> 29:39.130
再去调用什么呢

29:39.130 --> 29:41.130
再去调用这个gsi

29:41.130 --> 29:44.130
所提供给这个出播model

29:44.130 --> 29:45.130
这个fabric

29:45.130 --> 29:47.130
提供了这些接口

29:47.130 --> 29:48.130
OK

29:48.130 --> 29:49.130
好

29:49.130 --> 29:51.130
那了解了这些新的概念之后

29:51.130 --> 29:52.130
然后接下来我们这下

29:52.130 --> 29:53.130
最后

29:53.130 --> 29:54.130
我们再来看一下

29:54.130 --> 29:55.130
这个新架构下面

29:55.130 --> 29:58.130
整体的一个这个流程

29:58.130 --> 29:59.130
那首先第一步

29:59.130 --> 30:00.130
那第一步呢

30:00.130 --> 30:02.130
就还是用户点击这个app图标

30:02.130 --> 30:03.130
对吧

30:03.130 --> 30:04.130
好

30:04.130 --> 30:06.130
然后接下来通过这个fabric

30:06.130 --> 30:09.130
fabric来夹载这个leto

30:09.130 --> 30:10.130
这边

30:10.130 --> 30:11.130
OK

30:11.130 --> 30:12.130
夹载完了之后

30:12.130 --> 30:14.130
然后接下来的话

30:14.130 --> 30:15.130
通知什么呢

30:15.130 --> 30:17.130
通知这个gsi线程

30:17.130 --> 30:18.130
告诉他

30:18.130 --> 30:20.130
我这边的话准备好了

30:20.130 --> 30:21.130
但是注意一下

30:21.130 --> 30:23.130
你这边就不再是通过这个bridge

30:23.130 --> 30:24.130
传递这个数据

30:24.130 --> 30:26.130
然后再传递一个数据了

30:26.130 --> 30:28.130
这边它是直接调用这边

30:28.130 --> 30:31.130
调用你这个gsi端的一些方法

30:31.130 --> 30:33.130
表示我这边就是letiv端

30:33.130 --> 30:34.130
已经准备好了

30:34.130 --> 30:36.130
你那边的话可以开始夹载了

30:36.130 --> 30:37.130
好

30:37.130 --> 30:38.130
然后接下来的话这个gsi

30:38.130 --> 30:39.130
gsi的话

30:39.130 --> 30:41.130
这个letiv函数

30:41.130 --> 30:42.130
它这个引用

30:42.130 --> 30:44.130
然后直接调用什么呢

30:44.130 --> 30:45.130
调用fabric

30:45.130 --> 30:48.130
调用它的一些这个UI方法

30:48.130 --> 30:49.130
这边的话就是同时的话

30:49.130 --> 30:51.130
它会创建一个这个

30:51.130 --> 30:53.130
shadow little tree

30:53.130 --> 30:55.130
就是你的那个就是引引数

30:55.130 --> 30:57.130
引引数

30:57.130 --> 30:59.130
好

30:59.130 --> 31:01.130
后面的步骤其实差不多的

31:01.130 --> 31:04.130
后面的话就是这个yoga

31:04.130 --> 31:06.130
然后开始进行这个

31:06.130 --> 31:07.130
布局的这个计算

31:07.130 --> 31:09.130
然后把你写的这个flex布局

31:09.130 --> 31:11.130
转成这个中端的布局

31:11.130 --> 31:13.130
最终的话是这个fabric

31:13.130 --> 31:14.130
执行操作

31:14.130 --> 31:15.130
显示这个UI

31:15.130 --> 31:17.130
其实核心就是什么

31:17.130 --> 31:18.130
核心是不是就是

31:18.130 --> 31:20.130
没有了这个bridge

31:20.130 --> 31:21.130
对不对

31:21.130 --> 31:22.130
我圈的是后面这张图

31:22.130 --> 31:24.130
就后面这个模糊的这个图

31:24.130 --> 31:26.130
就是没有这个bridge

31:26.130 --> 31:27.130
对很多东西的话

31:27.130 --> 31:28.130
就是直接干嘛

31:28.130 --> 31:30.130
你这边gsi准备好了之后

31:30.130 --> 31:31.130
你是不是直接来调用

31:31.130 --> 31:33.130
我这边给你提供了这个接口

31:33.130 --> 31:34.130
你这边直接调用就可以了

31:34.130 --> 31:36.130
我不需要再像以前一样

31:36.130 --> 31:39.130
我这边还需要你就是这个接声

31:39.130 --> 31:41.130
传给这个bridge

31:41.130 --> 31:43.130
bridge让再传给这个内提文

31:43.130 --> 31:46.130
主要这个价格的变化就在这里

31:46.130 --> 31:47.130
ok

31:47.130 --> 31:49.130
这就是一个宏观上面的

31:49.130 --> 31:51.130
这个rn的一个价格

31:51.130 --> 31:54.130
大家的话可以把这看一下

31:54.130 --> 31:57.130
做一个了解

31:57.130 --> 31:59.130
然后这边

31:59.130 --> 32:01.130
关于他这边的话

32:01.130 --> 32:02.130
他这边其实主要

32:02.130 --> 32:05.130
他就是讲fabric

32:05.130 --> 32:08.130
就他这个新的这个渲染引进

32:08.130 --> 32:10.130
但你这边你刚才把那个

32:10.130 --> 32:11.130
宏观上面的这个rn价格

32:11.130 --> 32:12.130
听了之后

32:12.130 --> 32:13.130
那你就知道

32:13.130 --> 32:14.130
这个fabric

32:14.130 --> 32:16.130
它是属于哪一块了

32:16.130 --> 32:17.130
对不对

32:17.130 --> 32:18.130
就这个概念你就有了

32:18.130 --> 32:20.130
它是属于哪一块你就知道了

32:20.130 --> 32:21.130
关于这一块

32:21.130 --> 32:22.130
这一块的话

32:22.130 --> 32:23.130
我刚才说了

32:23.130 --> 32:25.130
我这边就把它翻译出来了

32:25.130 --> 32:26.130
这一块大家下来的话

32:26.130 --> 32:28.130
自己看一下

32:28.130 --> 32:29.130
其实主要是什么呢

32:29.130 --> 32:31.130
主要是第二个

32:31.130 --> 32:32.130
主要是第二个

32:32.130 --> 32:34.130
这个渲染提交挂载

32:34.130 --> 32:35.130
你看这边

32:35.130 --> 32:36.130
他告诉你就是

32:36.130 --> 32:37.130
我们看那个吗

32:37.130 --> 32:38.130
看我翻译的吗

32:38.130 --> 32:40.130
这边

32:40.130 --> 32:41.130
主要就是第二个

32:41.130 --> 32:43.130
把第二篇文档可以看一下

32:43.130 --> 32:44.130
这边他主要就是什么呢

32:44.130 --> 32:45.130
主要就是你这个

32:45.130 --> 32:46.130
比较初始的时候

32:46.130 --> 32:48.130
他是如何渲染的

32:48.130 --> 32:50.130
那你状态更新的时候

32:50.130 --> 32:51.130
他是如何渲染的

32:51.130 --> 32:53.130
他都包含这个三个阶段

32:53.130 --> 32:56.130
就是渲染提交挂载

32:56.130 --> 32:57.130
对吧

32:57.130 --> 32:58.130
他这边呢其实就都包含什么呢

32:58.130 --> 32:59.130
包含这边

32:59.130 --> 33:00.130
要生成这个

33:00.130 --> 33:02.130
shadowload的这个tree

33:02.130 --> 33:03.130
就是这个阴影树

33:03.130 --> 33:05.130
阴影树生成了之后

33:05.130 --> 33:06.130
接下来这边提交

33:06.130 --> 33:08.130
然后进行这个不举计算

33:08.130 --> 33:09.130
计算完了之后

33:09.130 --> 33:10.130
然后接下来的话

33:10.130 --> 33:12.130
后面就是挂载

33:12.130 --> 33:13.130
挂载的话

33:13.130 --> 33:14.130
然后生成这个

33:14.130 --> 33:16.130
就是这个原生的这个仕途

33:16.130 --> 33:19.130
最终生成这个原生的这个仕途

33:19.130 --> 33:20.130
OK

33:20.130 --> 33:21.130
这边大家可以把这个

33:21.130 --> 33:23.130
第二个文档看一下

33:23.130 --> 33:26.130
这就是关于整个RN的这个架构

33:26.130 --> 33:28.130
给大家介绍了一下

33:28.130 --> 33:29.130
这边大家的话

33:29.130 --> 33:31.130
对RN的这个架构

33:31.130 --> 33:32.130
做一个这个了解

33:32.130 --> 33:34.130
别人说到的时候

33:34.130 --> 33:36.130
然后你可以简单的可以说出来

33:36.130 --> 33:37.130
对吧

33:37.130 --> 33:38.130
OK

33:38.130 --> 33:40.130
这期课就先到这里

33:40.130 --> 33:41.130
再见

