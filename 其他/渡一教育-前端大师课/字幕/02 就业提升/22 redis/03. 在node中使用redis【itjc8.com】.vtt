WEBVTT

00:00.500 --> 00:03.860
来说一下Load里面去使用Redis

00:03.860 --> 00:07.020
其实套路都差不多 你看到没

00:07.020 --> 00:11.180
咱们学习Mysuckle 学习MongoDB

00:11.180 --> 00:14.620
先学习原声 先用讲解概念 然后原声

00:14.620 --> 00:16.820
然后Load里面就不会去使用

00:16.820 --> 00:19.620
使用的时候肯定是要创建连接

00:19.620 --> 00:21.300
哪个数据库不创建连接

00:21.300 --> 00:22.820
肯定是要创建一个连接

00:22.820 --> 00:24.820
然后通过连接去操作数据库

00:24.820 --> 00:28.300
而且操作的方式跟数据库提供的方式都差不多

00:28.940 --> 00:29.940
所以说咱们学技术了

00:29.940 --> 00:32.540
其实并没有大家想象那么困难

00:32.540 --> 00:35.300
你们学到现在第二阶段了 对吧

00:35.300 --> 00:38.340
其实你会发现技术很多地方都相通的

00:38.340 --> 00:41.140
你学了其中一个 表述一个你学了一个

00:41.140 --> 00:42.380
你再学习别的

00:42.380 --> 00:46.100
尽管它跟第一个可能出入比较大

00:46.100 --> 00:48.100
但是也没有那么复杂了

00:48.100 --> 00:49.100
因为套路都差不多

00:49.100 --> 00:51.620
而且跟你平时在生活中

00:51.620 --> 00:55.300
第一次追女孩子是有点困难 对不对

00:55.300 --> 00:56.420
没有经验

00:56.420 --> 00:58.420
后边是不是就比较简单了

00:58.420 --> 01:00.420
就这么个道理

01:00.420 --> 01:01.420
终点说一下

01:01.420 --> 01:04.420
那么在note里面使用Redis直接使用它官方的库就行了

01:04.420 --> 01:06.420
官方库就已经够了 完全够用了

01:06.420 --> 01:08.420
所以说我们首先就直接安装

01:08.420 --> 01:10.420
叫做Redis

01:10.420 --> 01:12.420
直接安装

01:12.420 --> 01:15.420
Redis就是官方的库

01:15.420 --> 01:17.420
安装完了

01:17.420 --> 01:18.420
安装完了怎么去使用呢

01:18.420 --> 01:19.420
创建连接

01:19.420 --> 01:20.420
保存

01:20.420 --> 01:22.420
我们这里

01:22.420 --> 01:24.420
新建一个index的介绍

01:25.420 --> 01:27.420
创建连接

01:27.420 --> 01:28.420
那么创建连接的时候

01:28.420 --> 01:30.420
这里有些参数可以填也可以不填

01:30.420 --> 01:32.420
比方说第一个主机名

01:32.420 --> 01:34.420
主机名它默认就是本机

01:34.420 --> 01:35.420
如果说你要连接远程的话

01:35.420 --> 01:37.420
你就写远程的主机名

01:37.420 --> 01:39.420
默认本机的话你可以不填

01:39.420 --> 01:41.420
端可号如果说你没有改动的话

01:41.420 --> 01:43.420
也可以不填一般不会去改动

01:43.420 --> 01:44.420
然后password

01:44.420 --> 01:46.420
如果说你的数据库有认证的话

01:46.420 --> 01:48.420
那么你把密码写字

01:48.420 --> 01:49.420
如果说没有认证的话

01:49.420 --> 01:50.420
没有认证不填就完了

01:50.420 --> 01:53.420
就算完了就创建了一个连接

01:53.420 --> 01:54.420
它得到一个对象

01:54.420 --> 01:55.420
其实就是一个客户端对象

01:55.420 --> 01:56.420
那么我们使用这个连接

01:56.420 --> 01:58.420
去操作这个数据库

01:58.420 --> 01:59.420
好了那么接下来怎么玩呢

01:59.420 --> 02:01.420
接下来玩的方式呢跟那个

02:01.420 --> 02:03.420
我们之前说了个原生的方式

02:03.420 --> 02:04.420
就差不多了

02:04.420 --> 02:05.420
就把它变成了函数

02:05.420 --> 02:07.420
之前我们说原生方式里边

02:07.420 --> 02:09.420
设置支付串怎么设置

02:09.420 --> 02:10.420
怎么设置

02:10.420 --> 02:11.420
是不是用那个

02:11.420 --> 02:12.420
用那个

02:13.420 --> 02:14.420
set

02:14.420 --> 02:15.420
对不对

02:15.420 --> 02:16.420
那么这里就变成一个set函数

02:16.420 --> 02:18.420
那么当时set的时候呢

02:18.420 --> 02:19.420
是不是要设置两个东西

02:19.420 --> 02:21.420
一个key 一个value

02:21.420 --> 02:22.420
对不对

02:22.420 --> 02:23.420
设置这边

02:28.420 --> 02:29.420
那么就完事了

02:29.420 --> 02:30.420
那么独非呢

02:30.420 --> 02:31.420
它就在这里呢

02:31.420 --> 02:32.420
有个毁掉函数

02:32.420 --> 02:33.420
因为它是异部的

02:33.420 --> 02:34.420
它有个毁掉函数

02:34.420 --> 02:35.420
那么这个毁掉函数呢

02:35.420 --> 02:37.420
它的那个做法呢

02:37.420 --> 02:39.420
就是load的那种方式的毁掉函数

02:39.420 --> 02:40.420
错误前置

02:40.420 --> 02:41.420
然后呢

02:41.420 --> 02:42.420
结果呢

02:42.420 --> 02:44.420
结果放到第二个参数

02:45.420 --> 02:47.420
我们直接输出一下replay

02:47.420 --> 02:48.420
行了

02:48.420 --> 02:49.420
那就完事了

02:49.420 --> 02:50.420
就完事了

02:50.420 --> 02:51.420
好 咱们来试一下吧

02:52.420 --> 02:53.420
这个index

02:54.420 --> 02:55.420
你看它可以输出什么

02:55.420 --> 02:56.420
输出ok

02:56.420 --> 02:57.420
ok是什么意思

02:57.420 --> 02:58.420
就表示

02:58.420 --> 02:59.420
缓存成功了

02:59.420 --> 03:00.420
对吧

03:00.420 --> 03:01.420
你把它加到radius里面成功了

03:01.420 --> 03:02.420
就这么简单

03:02.420 --> 03:03.420
然后呢

03:03.420 --> 03:04.420
接下来我们来看一下

03:04.420 --> 03:05.420
那如何取出来

03:05.420 --> 03:06.420
client

03:06.420 --> 03:07.420
get

03:07.420 --> 03:08.420
get是不是要填一个key

03:08.420 --> 03:09.420
对不对

03:09.420 --> 03:10.420
key is name

03:10.420 --> 03:12.420
好 那么第二个参数就是毁掉函数

03:12.420 --> 03:13.420
错误前置

03:13.420 --> 03:14.420
replay

03:15.420 --> 03:16.420
然后呢输出

03:16.420 --> 03:17.420
输出什么呢

03:17.420 --> 03:18.420
输出这个replay

03:19.420 --> 03:20.420
特别简单

03:20.420 --> 03:22.420
让我们看一下load index

03:23.420 --> 03:24.420
成功

03:24.420 --> 03:26.420
当然还有些别的函数

03:26.420 --> 03:28.420
跟那个元算是对应的

03:28.420 --> 03:29.420
比方说你看这里

03:29.420 --> 03:30.420
hset

03:30.420 --> 03:31.420
hget

03:31.420 --> 03:32.420
get all

03:32.420 --> 03:33.420
对不对

03:33.420 --> 03:34.420
还有什么

03:34.420 --> 03:35.420
生那个是

03:35.420 --> 03:36.420
一样的

03:36.420 --> 03:37.420
一样的

03:37.420 --> 03:38.420
还有什么呢

03:38.420 --> 03:39.420
还有那个就是

03:39.420 --> 03:40.420
key is

03:40.420 --> 03:41.420
对吧

03:41.420 --> 03:42.420
这都是可以的

03:42.420 --> 03:43.420
没问题

03:43.420 --> 03:44.420
那你们自己可以

03:44.420 --> 03:45.420
可以至于试一下

03:45.420 --> 03:46.420
然后呢

03:46.420 --> 03:47.420
我接下来要说一点

03:47.420 --> 03:48.420
就是这个玩意

03:48.420 --> 03:49.420
它目前

03:49.420 --> 03:51.420
目前还是三点几版本

03:51.420 --> 03:52.420
它说呢

03:52.420 --> 03:53.420
将来呢

03:53.420 --> 03:54.420
在四个版本里边呢

03:54.420 --> 03:55.420
会支持promise

03:55.420 --> 03:56.420
也就是它目前

03:56.420 --> 03:57.420
还不支持promise

03:57.420 --> 03:58.420
你只能使用毁掉

03:58.420 --> 03:59.420
那如果说

03:59.420 --> 04:00.420
你想用promise怎么办呢

04:00.420 --> 04:01.420
我这里顺便说一下

04:01.420 --> 04:02.420
因为我想起来呢

04:02.420 --> 04:04.420
以前讲load index的时候

04:04.420 --> 04:05.420
讲过一个cool

04:05.420 --> 04:06.420
就是不是一个cool

04:06.420 --> 04:07.420
就是一个

04:07.420 --> 04:09.420
内置模块

04:10.420 --> 04:11.420
叫啥呢

04:11.420 --> 04:13.420
叫那个ut

04:13.420 --> 04:14.420
还记得吗

04:14.420 --> 04:15.420
可能可能都忘了

04:15.420 --> 04:16.420
忘了也没关系

04:16.420 --> 04:17.420
我这里说一下吧

04:17.420 --> 04:18.420
ut是那个load index

04:18.420 --> 04:19.420
里面内置的一个cool

04:19.420 --> 04:21.420
它提供了一些工具函数

04:21.420 --> 04:22.420
其中一个工具函数

04:22.420 --> 04:24.420
叫做promise

04:24.420 --> 04:25.420
这个玩意呢

04:25.420 --> 04:26.420
我们当时

04:26.420 --> 04:27.420
当时我觉得呢

04:27.420 --> 04:28.420
这个玩意我应该在load index

04:28.420 --> 04:29.420
讲课的过程中

04:29.420 --> 04:30.420
应该用得到

04:30.420 --> 04:31.420
结果呢

04:31.420 --> 04:32.420
我发现讲课的过程中

04:32.420 --> 04:33.420
发现很多cool

04:33.420 --> 04:34.420
它都更新了

04:34.420 --> 04:35.420
它都支持promise的

04:35.420 --> 04:36.420
就是说

04:36.420 --> 04:37.420
结果导致呢

04:37.420 --> 04:38.420
我在load index里面

04:38.420 --> 04:40.420
就没有用到这个玩意

04:40.420 --> 04:41.420
那么这里呢

04:41.420 --> 04:42.420
就顺便可以用了

04:42.420 --> 04:43.420
这个玩意有什么用呢

04:43.420 --> 04:44.420
这个玩意主要就是用于

04:44.420 --> 04:47.420
把这些处理毁掉模式的函数

04:47.420 --> 04:49.420
把它变成promise

04:49.420 --> 04:51.420
因为load index出来的时候

04:51.420 --> 04:53.420
还没有这个promise

04:53.420 --> 04:55.420
后来呢

04:55.420 --> 04:56.420
promise出来了

04:56.420 --> 04:58.420
load index它也不甘心

04:58.420 --> 04:59.420
那这个时候怎么办呢

04:59.420 --> 05:00.420
它也不可能说

05:00.420 --> 05:02.420
把毁掉全部变成promise

05:02.420 --> 05:03.420
因为这样子一变的话

05:03.420 --> 05:05.420
很多以前的东西

05:05.420 --> 05:06.420
结果就不兼容了

05:06.420 --> 05:08.420
以前的写到工程

05:08.420 --> 05:09.420
load index一更新

05:09.420 --> 05:10.420
那就全部爆错了

05:10.420 --> 05:11.420
它不能改

05:11.420 --> 05:13.420
还得保持毁掉

05:13.420 --> 05:14.420
因此呢怎么办呢

05:14.420 --> 05:15.420
很多函数

05:15.420 --> 05:16.420
它就很多一些第三方cool

05:16.420 --> 05:18.420
它既保持毁掉

05:18.420 --> 05:20.420
同时又支持promise

05:20.420 --> 05:21.420
就你不写毁掉的话

05:21.420 --> 05:22.420
它就返回的是promise

05:22.420 --> 05:24.420
它用两种都支持

05:24.420 --> 05:26.420
它是用这种模式来处理的

05:26.420 --> 05:27.420
但是呢

05:27.420 --> 05:28.420
某一些cool呢

05:28.420 --> 05:29.420
它还不支持

05:29.420 --> 05:30.420
它只支持毁掉

05:30.420 --> 05:31.420
但是我们之前讲

05:31.420 --> 05:32.420
load index的时候呢

05:32.420 --> 05:33.420
发现很多cool

05:33.420 --> 05:34.420
它都同时支持promise和毁掉了

05:34.420 --> 05:35.420
但是呢

05:35.420 --> 05:36.420
现在我们在load index里面

05:36.420 --> 05:37.420
正好遇到了

05:37.420 --> 05:38.420
它这个东西

05:38.420 --> 05:39.420
这个函数是不是只支持毁掉

05:39.420 --> 05:40.420
它不支持promise

05:40.420 --> 05:41.420
那怎么办呢

05:41.420 --> 05:42.420
就可以利用这个工具

05:42.420 --> 05:44.420
来进行转换

05:44.420 --> 05:45.420
我们可以这样子

05:45.420 --> 05:46.420
promise fee

05:46.420 --> 05:48.420
你给它一个函数

05:48.420 --> 05:50.420
这个函数是不是只支持毁掉

05:50.420 --> 05:51.420
对不对

05:51.420 --> 05:52.420
它只支持毁掉

05:52.420 --> 05:53.420
那么这个时候呢

05:53.420 --> 05:55.420
你把这个函数传进去

05:55.420 --> 05:56.420
它会把这个函数呢

05:56.420 --> 05:58.420
转换成promise的模式

05:58.420 --> 05:59.420
给你返回

05:59.420 --> 06:01.420
我记得当时好像我还写过

06:01.420 --> 06:02.420
它的原码的

06:02.420 --> 06:03.420
这个很简单

06:03.420 --> 06:05.420
本质并不复杂

06:05.420 --> 06:06.420
那么现在呢

06:06.420 --> 06:07.420
我们它会返回一个新的函数

06:07.420 --> 06:08.420
你得到就行了

06:08.420 --> 06:10.420
比方说get而sync

06:10.420 --> 06:11.420
得到这个函数

06:11.420 --> 06:12.420
那么后边

06:12.420 --> 06:13.420
我们要得到的时候

06:13.420 --> 06:14.420
就用get而sync

06:14.420 --> 06:15.420
比方说这里呢

06:15.420 --> 06:16.420
get

06:16.420 --> 06:17.420
那么这个时候

06:17.420 --> 06:18.420
它就返回的是一个promise

06:18.420 --> 06:19.420
看没

06:19.420 --> 06:20.420
返回的是个promise

06:20.420 --> 06:21.420
那么我们用z

06:21.420 --> 06:22.420
当然你可以用在

06:22.420 --> 06:24.420
esc的sync而位置都行

06:24.420 --> 06:26.420
你们懂得replay

06:26.420 --> 06:28.420
输出

06:28.420 --> 06:29.420
replay

06:29.420 --> 06:30.420
咱们来看一下

06:30.420 --> 06:31.420
这样子行不行

06:31.420 --> 06:32.420
保存

06:32.420 --> 06:34.420
现在都得赢这个数

06:34.420 --> 06:35.420
那么这个时候

06:35.420 --> 06:36.420
它爆错了

06:36.420 --> 06:37.420
它爆错了是怎么回事呢

06:37.420 --> 06:38.420
它这样子

06:38.420 --> 06:39.420
就是

06:39.420 --> 06:40.420
因为现在爆错了

06:40.420 --> 06:41.420
它是不是转换成功了

06:41.420 --> 06:42.420
肯定转换成功了

06:42.420 --> 06:44.420
这是一个promise的函数

06:44.420 --> 06:45.420
传参数

06:45.420 --> 06:46.420
它可以返回一个promise

06:46.420 --> 06:47.420
但是为什么会爆错呢

06:47.420 --> 06:49.420
是因为在这个函数的执行过程中

06:49.420 --> 06:50.420
因为调用这个函数

06:50.420 --> 06:52.420
实际上最终执行的是这个函数

06:52.420 --> 06:54.420
那么在这个函数执行过程中

06:54.420 --> 06:56.420
它会用到z

06:56.420 --> 06:57.420
它会用到z

06:57.420 --> 06:58.420
但是这里的z

06:58.420 --> 06:59.420
是不是出问题了

06:59.420 --> 07:01.420
因为我们现在是直接调用这个函数

07:01.420 --> 07:03.420
之前是不是用这种方式来调用

07:03.420 --> 07:04.420
那么调用这个函数的过程中

07:04.420 --> 07:06.420
是不是z指向的是client

07:06.420 --> 07:07.420
但是现在呢

07:07.420 --> 07:08.420
我们直接用个函数

07:08.420 --> 07:09.420
z指向谁

07:09.420 --> 07:10.420
指向的就是全区了

07:10.420 --> 07:11.420
对不对

07:11.420 --> 07:12.420
那怎么办呢

07:12.420 --> 07:13.420
那么就很简单

07:13.420 --> 07:14.420
我得到这个函数过后

07:14.420 --> 07:15.420
我对这个函数

07:15.420 --> 07:17.420
再进行绑定z

07:17.420 --> 07:18.420
绑定什么

07:18.420 --> 07:19.420
把z绑定成什么

07:19.420 --> 07:20.420
client

07:20.420 --> 07:22.420
然后得到一个新函数

07:22.420 --> 07:23.420
那么先调用这个函数

07:23.420 --> 07:24.420
一定是z

07:24.420 --> 07:26.420
里边的z一定指向的是client

07:26.420 --> 07:28.420
把这个地方处理一下

07:29.420 --> 07:30.420
你看

07:30.420 --> 07:31.420
是不是得到了

07:31.420 --> 07:33.420
这就是处理技巧

07:33.420 --> 07:34.420
当然

07:34.420 --> 07:35.420
如果说

07:35.420 --> 07:36.420
你们看这个视频的时候

07:36.420 --> 07:37.420
你们安装的radius

07:37.420 --> 07:39.420
它本身就是4G而版本

07:39.420 --> 07:40.420
4开始的版本以上

07:40.420 --> 07:41.420
那就ok了

07:41.420 --> 07:42.420
它就肯定是已经支持了

07:42.420 --> 07:43.420
promise

07:43.420 --> 07:44.420
它就是它官方说的

07:44.420 --> 07:45.420
如果它没有实现

07:45.420 --> 07:46.420
不要怪我

07:46.420 --> 07:47.420
跟我没关系

07:47.420 --> 07:48.420
我先贴心责任

07:48.420 --> 07:49.420
这官方自己说的

07:49.420 --> 07:50.420
那么这就是

07:50.420 --> 07:51.420
radius里面

07:51.420 --> 07:52.420
在load.get里面

07:52.420 --> 07:53.420
如何使用radius

07:53.420 --> 07:54.420
特别简单

07:54.420 --> 07:55.420
其他没啥了

07:55.420 --> 07:56.420
我们下期可能

07:56.420 --> 07:57.420
来说一下

