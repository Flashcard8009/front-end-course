WEBVTT

00:00.880 --> 00:03.880
大家好 我是杜依教育 微博前程响师 袁晋

00:04.880 --> 00:11.880
我们的TS只剩下两张了 一个是我们这一张的内情演算

00:11.880 --> 00:14.880
一个是我们下一张的声明文件

00:14.880 --> 00:18.880
其实最核心的内容 我们前边已经讲完了

00:18.880 --> 00:21.880
但是这一张也蛮重要的

00:21.880 --> 00:25.880
因为有一些场景下边 我们确实不好处理

00:25.880 --> 00:27.880
可能要用到这一张的东西

00:27.880 --> 00:30.880
而这一张的东西又特别的巧妙

00:30.880 --> 00:34.880
大家学习的过程中应该能够体会到了

00:34.880 --> 00:39.880
我们这一张叫做内情演算

00:39.880 --> 00:42.880
就是这一张的名字是我自己想的

00:42.880 --> 00:46.880
因为我想来想去也不知道该给这一张取的什么名字

00:46.880 --> 00:48.880
所以给它取个名字叫内情演算

00:49.880 --> 00:50.880
什么意思呢

00:50.880 --> 00:56.880
就是说能够根据已知的信息

00:56.880 --> 01:00.880
计算出新的内情

01:00.880 --> 01:03.880
这一张讲的就是这么一个东西

01:03.880 --> 01:07.880
根据已知信息 这个已知信息有可能是一个内情

01:07.880 --> 01:09.880
也有可能是一个对象

01:09.880 --> 01:12.880
也有可能是一个函数 也有可能是一个内

01:12.880 --> 01:16.880
总之根据已知的信息来计算出一个新的内情

01:16.880 --> 01:21.880
有的时候会给我们开发带来很多很多的方便

01:21.880 --> 01:24.880
我们首先第一节课

01:24.880 --> 01:28.880
咱们这一张的第一个小节讲这么一个东西

01:28.880 --> 01:32.880
三个关键字

01:32.880 --> 01:35.880
这三个关键字的分别是Type

01:35.880 --> 01:37.880
见过了是吧

01:37.880 --> 01:41.880
Type 但是跟大家学习的介石里面的Type

01:41.880 --> 01:43.880
那是不一样的

01:44.880 --> 01:47.880
这个关键字超级强大

01:47.880 --> 01:49.880
还有关键字是印

01:49.880 --> 01:51.880
好 我们一个个说吧

01:51.880 --> 01:53.880
首先是Type

01:53.880 --> 01:57.880
Type在GS里面本来就有

01:57.880 --> 01:59.880
本来就有这么一个关键字

01:59.880 --> 02:02.880
它表示的是取一个

02:02.880 --> 02:05.880
得到一个变量 得到一个数据的内想

02:05.880 --> 02:07.880
得到一个数据的内想

02:07.880 --> 02:10.880
在TS里面它也有这个关键字

02:10.880 --> 02:12.880
就是该在内想声明的位置

02:12.880 --> 02:14.880
也可以写这么一个Type

02:14.880 --> 02:16.880
而我们这里说的Type

02:16.880 --> 02:20.880
指的是TS中的Type

02:20.880 --> 02:23.880
指的是TS中的Type

02:23.880 --> 02:28.880
书写的位置在内想约束的位置

02:28.880 --> 02:32.880
书写的位置在内想约束的位置上

02:32.880 --> 02:37.510
当然如果你是正常的书写的话

02:37.510 --> 02:39.510
那跟TS里面是一样的

02:39.510 --> 02:42.510
就比方说我这里订一个变量

02:42.510 --> 02:45.510
订一个变量 随便给它写个字吧

02:45.510 --> 02:46.510
字不算吧 对吧

02:46.510 --> 02:49.510
然后输出呢 输出上的Type

02:49.510 --> 02:51.510
Type A

02:51.510 --> 02:54.510
那这个Type不是我们要讲的Type

02:54.510 --> 02:58.510
这个Type是GS里面本来就有的

02:58.510 --> 03:00.510
这个关键字 它表示取一个变量的

03:00.510 --> 03:03.510
取一个变量的内想

03:03.510 --> 03:06.510
而我们这里说的Type

03:06.510 --> 03:09.510
指的是你书写的位置

03:09.510 --> 03:12.510
在内想约束的位置上面

03:12.510 --> 03:13.510
比方说什么情况呢

03:13.510 --> 03:15.510
我给大家随便写一个吧

03:15.510 --> 03:17.510
随便写一个B

03:17.510 --> 03:19.510
你看这里是不是要内想约束 对吧

03:19.510 --> 03:21.510
约束B的内想

03:21.510 --> 03:24.510
我们这里Type A

03:24.510 --> 03:26.510
我们说的Type指的是这个东西

03:26.510 --> 03:28.510
指的是这个东西

03:28.510 --> 03:30.510
明白我这个意思吗

03:30.510 --> 03:32.510
指的是这个东西Type A

03:32.510 --> 03:33.510
指的是这个位置

03:33.510 --> 03:35.510
在内想约束的位置

03:35.510 --> 03:36.510
我们要写Type

03:36.510 --> 03:38.510
因为GS是不可能这样写的

03:38.510 --> 03:41.510
因此TS给这个位置的Type

03:41.510 --> 03:43.510
赋予了新的含义

03:43.510 --> 03:44.510
什么含义呢

03:44.510 --> 03:46.510
其实意思跟GS差不多

03:46.510 --> 03:50.510
给GS差不多表示

03:50.510 --> 03:52.510
表示它意思表示

03:52.510 --> 03:58.510
获取某个数据的内想

03:58.510 --> 04:01.510
表示获取某个数据的内想

04:01.510 --> 04:03.510
这个数据它之前是什么内想

04:04.510 --> 04:06.510
好 这样做有什么好处呢

04:06.510 --> 04:07.510
比方说

04:07.510 --> 04:09.510
这里的A

04:09.510 --> 04:11.510
你看这个A推断出来是什么内想

04:11.510 --> 04:12.510
什么内想

04:12.510 --> 04:14.510
它是个字面量内想 对吧

04:14.510 --> 04:15.510
字面量内想

04:15.510 --> 04:17.510
如果我希望

04:17.510 --> 04:19.510
比方说我又有个变量B

04:19.510 --> 04:21.510
我希望B的指呢

04:21.510 --> 04:22.510
就是B的内想

04:22.510 --> 04:24.510
要跟A的内想要保持一致

04:24.510 --> 04:26.510
一定要保持一致

04:26.510 --> 04:27.510
我现在的可能

04:27.510 --> 04:29.510
我不太清楚A是什么内想

04:29.510 --> 04:30.510
有可能呢

04:30.510 --> 04:32.510
一个A可能是从别的地方得到的

04:32.510 --> 04:33.510
我不太清楚

04:33.510 --> 04:35.510
这个A是什么内想

04:35.510 --> 04:36.510
没关系

04:36.510 --> 04:38.510
A是什么内想

04:38.510 --> 04:40.510
B就应该是什么内想

04:40.510 --> 04:42.510
让A的内想跟B的内想保持一致

04:42.510 --> 04:44.510
那A现在是字面量内想

04:44.510 --> 04:46.510
ASDFF

04:46.510 --> 04:47.510
那么B的内想呢

04:47.510 --> 04:49.510
也必须要是这个字面量内想

04:49.510 --> 04:50.510
就这么简单

04:50.510 --> 04:51.510
很好理解 对吧

04:51.510 --> 04:52.510
非常好理解

04:52.510 --> 04:54.510
好 那么比方说

04:54.510 --> 04:55.510
比方说A这里呢

04:55.510 --> 04:56.510
我给它限制一下

04:56.510 --> 04:58.510
是这个字符串内想

04:58.510 --> 04:59.510
那么这里B呢

04:59.510 --> 05:01.510
你看它也是字符串

05:01.510 --> 05:03.510
我这里就不用去改这个代码了

05:03.510 --> 05:04.510
只需要跟

05:04.510 --> 05:06.510
让某个辨量它的内想呢

05:06.510 --> 05:07.510
跟A的内想保持一致

05:07.510 --> 05:09.510
我们就可以使用这个关键词

05:09.510 --> 05:10.510
Type

05:10.510 --> 05:13.510
推导出A的内想是什么

05:13.510 --> 05:15.510
这是关于这个关键词

05:15.510 --> 05:17.510
非常非常简单

05:17.510 --> 05:19.510
关于这个Type呢

05:19.510 --> 05:20.510
还有一种就是情况

05:20.510 --> 05:22.510
大家要注意

05:22.510 --> 05:23.510
就是

05:23.510 --> 05:25.510
当

05:25.510 --> 05:28.510
当Type

05:28.510 --> 05:30.510
作用于

05:30.510 --> 05:31.510
作用于什么呢

05:31.510 --> 05:34.510
作用于内的时候

05:34.510 --> 05:38.510
表示得到的内想

05:38.510 --> 05:40.510
是该内的

05:40.510 --> 05:43.510
构造函数

05:43.510 --> 05:44.510
啥意思

05:44.510 --> 05:45.510
这是啥意思

05:45.510 --> 05:47.510
好 举个例子吧

05:47.510 --> 05:48.510
举个例子

05:48.510 --> 05:49.510
比方说

05:49.510 --> 05:52.510
我们有这么一个内

05:52.510 --> 05:53.510
U字

05:53.510 --> 05:54.510
又来了

05:54.510 --> 05:55.510
U字的这个内

05:55.510 --> 05:56.510
随便给它写属性吧

05:56.510 --> 05:57.510
随便给

05:57.510 --> 05:58.510
随便给

05:59.510 --> 06:00.510
罗锦帕斯沃尔的

06:00.510 --> 06:01.510
随便给

06:02.510 --> 06:03.510
好 现在呢

06:03.510 --> 06:04.510
假设

06:04.510 --> 06:05.510
假设我们有这么一个

06:05.510 --> 06:06.510
奇怪的需求

06:06.510 --> 06:08.510
也甭管这个需求是怎么来的

06:08.510 --> 06:10.510
我就是强行给你做出来了

06:10.510 --> 06:13.510
有一个函数

06:13.510 --> 06:15.510
叫做创建一个用户

06:15.510 --> 06:17.510
并且这个函数呢

06:17.510 --> 06:19.510
它还让你必须要给我传递一个

06:19.510 --> 06:21.510
传递一个内进来

06:21.510 --> 06:23.510
就是用户内传递进来

06:23.510 --> 06:24.510
然后我来帮你

06:24.510 --> 06:26.510
创建这么一个

06:26.510 --> 06:27.510
用户内向

06:27.510 --> 06:29.510
因此它返回的是什么呢

06:29.510 --> 06:31.510
返回的是一个用户对象

06:31.510 --> 06:33.510
返回的是一个用户对象

06:33.510 --> 06:34.510
要传一个什么参数呢

06:34.510 --> 06:37.510
要传递一个内的名字进来

06:37.510 --> 06:39.510
把内名传进来

06:39.510 --> 06:40.510
好 到时候呢

06:40.510 --> 06:41.510
我怎么来创建用户呢

06:41.510 --> 06:42.510
我就这样创建

06:42.510 --> 06:44.510
new cls

06:44.510 --> 06:45.510
比方说

06:45.510 --> 06:47.510
有这么一个函数

06:48.510 --> 06:49.510
好 那我希望

06:49.510 --> 06:51.510
它怎么来调用这个函数呢

06:51.510 --> 06:53.510
我希望这样来调用

06:53.510 --> 06:54.510
new

06:54.510 --> 06:56.510
create user

06:56.510 --> 06:58.510
通过传一个用户

06:58.510 --> 06:59.510
你看 现在传的

06:59.510 --> 07:00.510
不是一个用户对象

07:00.510 --> 07:02.510
要把一个用户的内

07:02.510 --> 07:04.510
传过去

07:04.510 --> 07:05.510
来创建这么一个函数

07:05.510 --> 07:06.510
当然这个创建的结果呢

07:06.510 --> 07:08.510
就是一个用户对象

07:08.510 --> 07:10.510
好 现在呢

07:10.510 --> 07:11.510
我们来看一下

07:11.510 --> 07:13.510
问题在于这个参数

07:13.510 --> 07:15.510
该怎么来约束

07:15.510 --> 07:17.510
这里写啥

07:17.510 --> 07:19.510
这里写啥

07:19.510 --> 07:21.510
如果要实现这个目的

07:21.510 --> 07:22.510
你先别管

07:22.510 --> 07:23.510
为什么要实现

07:23.510 --> 07:24.510
我就要实现

07:24.510 --> 07:25.510
我就要实现

07:25.510 --> 07:27.510
那你怎么来约束这个参数

07:28.510 --> 07:30.510
好 有些同学呢

07:30.510 --> 07:31.510
可能会马上想到

07:31.510 --> 07:33.510
这里约束为啥呢

07:33.510 --> 07:35.510
约束为优热

07:35.510 --> 07:37.510
发现不对

07:37.510 --> 07:40.510
不对 会产生两个问题

07:40.510 --> 07:42.510
第一个问题

07:42.510 --> 07:44.510
你会发现参数不匹配的

07:44.510 --> 07:46.510
参数不匹配

07:46.510 --> 07:48.510
为什么参数不匹配呢

07:48.510 --> 07:50.510
你想象这个道理

07:50.510 --> 07:51.510
我们比方说

07:51.510 --> 07:52.510
反回类型

07:52.510 --> 07:53.510
我们就给的是优热 对吧

07:53.510 --> 07:55.510
当我们把类型

07:55.510 --> 07:57.510
约束为优热之后呢

07:57.510 --> 07:59.510
表达的意思是什么

07:59.510 --> 08:01.510
表达的意思是

08:01.510 --> 08:03.510
这里有一个用户的对象

08:03.510 --> 08:05.510
而不是用户

08:05.510 --> 08:07.510
这个类本身

08:07.510 --> 08:08.510
指的是用户对象

08:08.510 --> 08:10.510
而不是类本身

08:10.510 --> 08:12.510
明白这个意思吗

08:12.510 --> 08:14.510
大家搞清楚这两个区别

08:14.510 --> 08:16.510
优热和溜优热

08:16.510 --> 08:18.510
他们两个的区别

08:18.510 --> 08:20.510
这个是用户对象

08:20.510 --> 08:22.510
这个是用户的类

08:22.510 --> 08:23.510
一个构造函数

08:23.510 --> 08:25.510
这个玩意儿是一个构造函数

08:25.510 --> 08:26.510
而这个玩意儿呢

08:26.510 --> 08:27.510
是通过构造函数

08:27.510 --> 08:28.510
创建的对象

08:28.510 --> 08:31.510
当你把类型约束为优热的时候

08:31.510 --> 08:32.510
指的是这个玩意儿

08:32.510 --> 08:33.510
指的是一个对象

08:33.510 --> 08:35.510
你看比方说我这里

08:35.510 --> 08:36.510
另一个优热团进去

08:36.510 --> 08:38.510
你看 这里就匹配了

08:38.510 --> 08:39.510
这里就不报戳了

08:39.510 --> 08:41.510
明白这个意思吗

08:41.510 --> 08:43.510
那如果我要要求

08:43.510 --> 08:45.510
传一个类进去 咋办了

08:45.510 --> 08:47.510
而且还必须是用户的类

08:47.510 --> 08:48.510
咋办了

08:48.510 --> 08:50.510
你看这里就报戳了

08:50.510 --> 08:52.510
你让你传一个用户对象进来

08:52.510 --> 08:53.510
结果你传了一个类进来

08:53.510 --> 08:54.510
就出了问题

08:54.510 --> 08:55.510
哪边出了问题

08:55.510 --> 08:56.510
是不是这里出了问题

08:56.510 --> 08:58.510
我们这里本来就希望

08:58.510 --> 09:00.510
他给我一个类而不是对象

09:00.510 --> 09:02.510
的第一个问题

09:02.510 --> 09:04.510
第二个问题 你想啊

09:04.510 --> 09:06.510
既然是一个对象

09:06.510 --> 09:08.510
能这样子使用吗

09:08.510 --> 09:10.510
CLS是一个用户对象

09:10.510 --> 09:12.510
你能去创建

09:12.510 --> 09:14.510
根据对象来创建一个对象吗

09:14.510 --> 09:15.510
肯定不行

09:15.510 --> 09:17.510
那么这里必须是一个构造函数

09:17.510 --> 09:19.510
好 那么再想

09:20.510 --> 09:22.510
好 有些同学呢

09:22.510 --> 09:24.510
可能又会想到另外一个

09:24.510 --> 09:26.510
另外一种方式 就是我们

09:26.510 --> 09:28.510
上一张的时候

09:28.510 --> 09:30.510
讲过的一种方式 对吧

09:30.510 --> 09:32.510
用构造函数约数

09:32.510 --> 09:34.510
6

09:34.510 --> 09:36.510
6

09:36.510 --> 09:38.510
用这种构造函数约数

09:38.510 --> 09:39.510
可不可以

09:39.510 --> 09:41.510
可以 没有问题

09:41.510 --> 09:43.510
你看现在不是就没问题了吗

09:43.510 --> 09:44.510
我这里反回的是U2

09:44.510 --> 09:46.510
表示这个构造函数创建之后

09:46.510 --> 09:48.510
得到了是一个用户

09:48.510 --> 09:50.510
没有问题

09:50.510 --> 09:52.510
这样做是可以的

09:52.510 --> 09:53.510
那么这里呢

09:53.510 --> 09:55.510
我再给大家说一种做法

09:55.510 --> 09:57.510
再给大家说一种做法

09:57.510 --> 09:59.510
什么做法呢

09:59.510 --> 10:01.510
就是在这里写上这么一个东西

10:01.510 --> 10:04.510
Type user

10:04.510 --> 10:06.510
写上这个东西就行了

10:06.510 --> 10:07.510
这啥意思

10:07.510 --> 10:09.510
就是我们刚才做笔记的时候

10:09.510 --> 10:11.510
说了这个点

10:11.510 --> 10:15.510
当Type作用于内的时候

10:15.510 --> 10:17.510
Type作用于内的时候

10:17.510 --> 10:19.510
那么表示的内形

10:19.510 --> 10:21.510
这个内形是啥意思呢

10:21.510 --> 10:23.510
计算出来的内形

10:23.510 --> 10:25.510
就是内的构造函数

10:25.510 --> 10:27.510
就表示的是

10:27.510 --> 10:29.510
这里的内形是这个内的构造函数

10:29.510 --> 10:31.510
你说这个内本身

10:31.510 --> 10:33.510
就是这个意思

10:33.510 --> 10:35.510
非常简单

10:35.510 --> 10:37.510
因为如果你直接书写这个内的话

10:37.510 --> 10:39.510
表示的内形是这个内的对象

10:39.510 --> 10:41.510
而不是内本身

10:41.510 --> 10:43.510
如果你使用Type的话

10:43.510 --> 10:45.510
就表示的是它的本身

10:45.510 --> 10:47.510
好,我们再看一个例子

10:47.510 --> 10:49.510
比方说

10:49.510 --> 10:51.510
这里有个辨量

10:51.510 --> 10:53.510
U,U一个U字

10:53.510 --> 10:55.510
创建个用户

10:55.510 --> 10:57.510
好,然后呢

10:57.510 --> 10:59.510
我们来看一下

10:59.510 --> 11:01.510
再进行一个辨量

11:01.510 --> 11:03.510
U2等于U

11:03.510 --> 11:05.510
我们看一下U2推断出来什么内象

11:05.510 --> 11:07.510
U2推断出来是U字的内象

11:07.510 --> 11:09.510
没问题吧,因为它是个对象

11:09.510 --> 11:11.510
它复制过后是个对象

11:11.510 --> 11:13.510
因此推断出来是一个U字的内象

11:13.510 --> 11:15.510
如果我是这样子写的代码

11:15.510 --> 11:17.510
A等于

11:17.510 --> 11:19.510
直接把U字的复制给它

11:19.510 --> 11:21.510
直接把U字的复制给它

11:21.510 --> 11:23.510
那一看A什么内象

11:23.510 --> 11:25.510
看到没

11:25.510 --> 11:27.510
A什么内象

11:27.510 --> 11:29.510
是不是就是U字的构造函数

11:29.510 --> 11:31.510
对吧,那么之后呢

11:31.510 --> 11:33.510
我就可以6一个A来创建一个用户

11:33.510 --> 11:35.510
你看,创建之后返回的是用户

11:35.510 --> 11:37.510
看到没

11:37.510 --> 11:39.510
我们了解一下这个Type关键字

11:39.510 --> 11:41.510
就是有的时候

11:41.510 --> 11:43.510
你要把一个辨量

11:43.510 --> 11:45.510
把一个参数

11:45.510 --> 11:47.510
约束成为一个啥呢

11:47.510 --> 11:49.510
约束成为一个构造函数的话

11:49.510 --> 11:51.510
可以使用Type关键字

11:51.510 --> 11:53.510
也可以使用我们之前

11:53.510 --> 11:55.510
学习过的New那种方式

11:55.510 --> 11:57.510
来进行约束

11:57.510 --> 11:59.510
这是关于第1个关键字

11:59.510 --> 12:01.510
Type

12:01.510 --> 12:03.510
我们看第2个关键字

12:03.510 --> 12:05.510
第2个关键字特别特别有意思

12:05.510 --> 12:07.510
这个东西

12:07.510 --> 12:09.510
是我们本账

12:09.510 --> 12:11.510
进行内形与演算的关键

12:11.510 --> 12:13.510
非常核心的一个关键字

12:13.510 --> 12:15.510
叫做PO

12:15.510 --> 12:17.510
它这个关键字

12:17.510 --> 12:19.510
可以作用于

12:19.510 --> 12:21.510
作用于很多东西

12:21.510 --> 12:23.510
可以作用于啥呢

12:23.510 --> 12:25.510
可以作用于

12:25.510 --> 12:27.510
内

12:27.510 --> 12:29.510
接口

12:29.510 --> 12:31.510
内形别名

12:31.510 --> 12:33.510
都可以作用

12:33.510 --> 12:35.510
用于做什么事情呢

12:35.510 --> 12:37.510
用于获取

12:37.510 --> 12:39.510
内形

12:39.510 --> 12:41.510
中的所有

12:41.510 --> 12:43.510
成员名

12:43.510 --> 12:45.510
组成的

12:45.510 --> 12:47.510
组成的联合内形

12:47.510 --> 12:49.510
这句话好长

12:49.510 --> 12:51.510
都不知道在说啥

12:51.510 --> 12:53.510
举个例子吧

12:53.510 --> 12:55.510
比方说

12:55.510 --> 12:57.510
比方说

12:57.510 --> 12:59.510
我们有这么一个接口

12:59.510 --> 13:01.510
先说接口吧

13:01.510 --> 13:03.510
其实都一样

13:03.510 --> 13:05.510
有点

13:05.510 --> 13:07.510
翻了翻去用户

13:07.510 --> 13:09.510
用户的账号

13:09.510 --> 13:11.510
用户的密码

13:11.510 --> 13:13.510
用户的年龄

13:13.510 --> 13:15.510
用户的年龄

13:15.510 --> 13:17.510
比方说

13:17.510 --> 13:19.510
下面我写上这么一个函数

13:19.510 --> 13:21.510
这个函数也很怪

13:21.510 --> 13:23.510
封管为什么这样写

13:23.510 --> 13:25.510
我们就写这么一个函数

13:25.510 --> 13:27.510
比方说

13:27.510 --> 13:29.510
打印

13:29.510 --> 13:31.510
用户的某一个属性

13:31.510 --> 13:33.510
user property

13:33.510 --> 13:35.510
打印用户的一个属性

13:35.510 --> 13:37.510
打印用户的一个属性

13:37.510 --> 13:39.510
好,这个怎么做呢

13:39.510 --> 13:41.510
我们设计一下这个函数

13:41.510 --> 13:43.510
翻翻内形,不用管翻翻内形

13:43.510 --> 13:45.510
你要打印用户的属性

13:45.510 --> 13:47.510
你得告诉我一个用户对象吧

13:47.510 --> 13:49.510
这个没什么好说的

13:49.510 --> 13:51.510
你得告诉我一个用户对象

13:51.510 --> 13:53.510
然后你还得告诉我一个啥呢

13:53.510 --> 13:55.510
还得告诉我这个用户的属性名

13:55.510 --> 13:57.510
你要打印哪个属性

13:57.510 --> 13:59.510
你把这个属性名要告诉我

13:59.510 --> 14:01.510
OK,那么

14:01.510 --> 14:03.510
这里我们可以使用一个prop

14:03.510 --> 14:05.510
表示属性的名字

14:05.510 --> 14:07.510
属性的名字啥类型呢

14:07.510 --> 14:09.510
属性的名字啥类型

14:09.510 --> 14:11.510
是不是个字幕串

14:11.510 --> 14:13.510
属性还能是别的玩意吗

14:13.510 --> 14:15.510
属性的名字

14:15.510 --> 14:17.510
只能是个字幕串

14:17.510 --> 14:19.510
好,那么这个函数实现起来

14:19.510 --> 14:21.510
非常简单,当然这个函数

14:21.510 --> 14:23.510
也可以做很多事情的,比方说

14:23.510 --> 14:25.510
看一下目前的环境

14:25.510 --> 14:27.510
如果是浏览器环境的话

14:27.510 --> 14:29.510
我就把它输出到页面上

14:30.510 --> 14:32.510
等等等等可以做很多事

14:32.510 --> 14:35.510
那假设我们现在就做一个简单的算

14:35.510 --> 14:37.510
直接把它输出到控制台

14:37.510 --> 14:39.510
好,取这个OBG对象

14:39.510 --> 14:41.510
哪个属性

14:41.510 --> 14:43.510
是不是通过锁引

14:43.510 --> 14:45.510
来取出PROP这个属性

14:45.510 --> 14:47.510
对吧

14:47.510 --> 14:49.510
那么它现在爆错

14:49.510 --> 14:51.510
它现在为啥爆错呢

14:51.510 --> 14:53.510
因为它不能确定

14:53.510 --> 14:55.510
你这里的参数值

14:55.510 --> 14:57.510
它里面的值

14:57.510 --> 14:59.510
一定是

14:59.510 --> 15:01.510
这三个值当中的一个

15:01.510 --> 15:03.510
逻辑上来说

15:03.510 --> 15:05.510
这里的属性值

15:05.510 --> 15:07.510
这里的属性

15:07.510 --> 15:09.510
这里的参数的值

15:09.510 --> 15:11.510
它表示的是什么意思

15:11.510 --> 15:13.510
表示的是拥护的属性名

15:13.510 --> 15:15.510
而属性名

15:15.510 --> 15:17.510
拥护的属性名只有这三个

15:17.510 --> 15:19.510
那你是不是应该怎么写

15:19.510 --> 15:21.510
应该争取的写法是不是

15:21.510 --> 15:23.510
应该是联合类型啊

15:23.510 --> 15:25.510
login ID,login password

15:25.510 --> 15:27.510
你取这三个中的一个

15:27.510 --> 15:29.510
你不能取的别的东西了

15:29.510 --> 15:31.510
你如果给我一个什么ABC123

15:31.510 --> 15:33.510
那我怎么取的这个属性

15:33.510 --> 15:35.510
它肯定取不出来

15:35.510 --> 15:37.510
所以它这里爆错是正确的

15:37.510 --> 15:39.510
这里爆错是正确的

15:39.510 --> 15:41.510
因为它确实不知道

15:41.510 --> 15:43.510
你这里这个玩意儿

15:43.510 --> 15:45.510
它会得到一个什么结果

15:45.510 --> 15:47.510
它也不知道这个东西

15:47.510 --> 15:49.510
会得到一个什么结果

15:49.510 --> 15:51.510
所以说呢,这里应该怎么写呢

15:51.510 --> 15:53.510
应该正确的写法

15:53.510 --> 15:55.510
然后是login password

15:55.510 --> 15:57.510
然后是ABC

15:57.510 --> 15:59.510
你看现在就不爆错了

15:59.510 --> 16:01.510
现在就不爆错了

16:01.510 --> 16:03.510
因为,为啥呢

16:03.510 --> 16:05.510
因为我给力的属性名

16:05.510 --> 16:07.510
我给力的属性名

16:07.510 --> 16:09.510
一定是这三个中的一个

16:09.510 --> 16:11.510
一定是这三个中的一个

16:11.510 --> 16:13.510
这三个是不是有效的属性名

16:13.510 --> 16:15.510
对吧,都是有效的属性名

16:15.510 --> 16:17.510
所以说我这里这样子呢,就没什么问题了

16:17.510 --> 16:19.510
那么到时候呢,我要打印这个用户的属性的时候呢

16:19.510 --> 16:21.510
我传一个用户对象进去

16:21.510 --> 16:23.510
我传一个用户对象进去

16:23.510 --> 16:25.510
我这里随便传一个吧

16:25.510 --> 16:27.510
U

16:27.510 --> 16:29.510
限制为U2

16:29.510 --> 16:31.510
复辞login ID

16:31.510 --> 16:33.510
login ID

16:33.510 --> 16:35.510
打随便写

16:35.510 --> 16:37.510
然后是login password

16:37.510 --> 16:39.510
随便写

16:39.510 --> 16:41.510
然后是年龄A级

16:41.510 --> 16:43.510
随便写

16:43.510 --> 16:45.510
好,有这么个用户对象

16:45.510 --> 16:47.510
你再帮我打印一下,打印一下年龄

16:47.510 --> 16:49.510
你看

16:49.510 --> 16:51.510
这三个属性就写过来

16:51.510 --> 16:53.510
这个没什么问题

16:53.510 --> 16:55.510
我们现在我只是在通过这个例子

16:55.510 --> 16:57.510
告诉大家,如果遇到这么一种情况

16:57.510 --> 16:59.510
就是有些参数

16:59.510 --> 17:01.510
或者是有些电量

17:01.510 --> 17:03.510
他的曲子呢,应该是

17:03.510 --> 17:05.510
某一个内形的所有的

17:05.510 --> 17:07.510
自断的值

17:07.510 --> 17:09.510
他的曲子范围,应该是某一个内形的

17:09.510 --> 17:11.510
当中的自断的

17:11.510 --> 17:13.510
所有自断当中的一个

17:13.510 --> 17:15.510
这个有点糟,我再来一次

17:15.510 --> 17:17.510
他的内形

17:17.510 --> 17:19.510
这个某个内形

17:19.510 --> 17:21.510
所有自断当中的

17:21.510 --> 17:23.510
一个

17:23.510 --> 17:25.510
因此我这里使用了一个自幅串的

17:25.510 --> 17:27.510
字面量的联合力小

17:27.510 --> 17:29.510
但是这样子写呢

17:29.510 --> 17:31.510
不太好

17:31.510 --> 17:33.510
为什么不太好呢

17:33.510 --> 17:35.510
你想啊

17:35.510 --> 17:37.510
如果这个内形发生了变动

17:37.510 --> 17:39.510
不说别的了,我就把这个i变大去

17:39.510 --> 17:41.510
你要是不

17:41.510 --> 17:43.510
马上就爆错了,马上出问题了

17:43.510 --> 17:45.510
或者说我们

17:45.510 --> 17:47.510
按F2吧,按F2

17:47.510 --> 17:49.510
来进行这样子

17:49.510 --> 17:51.510
来重命名

17:51.510 --> 17:53.510
这样重命名过后,这里能不能重命名

17:53.510 --> 17:55.510
不能,因为他并不知道

17:55.510 --> 17:57.510
这个东西,取的

17:57.510 --> 17:59.510
就是这个内形的自断

17:59.510 --> 18:01.510
他并不知道,我们是写实的

18:01.510 --> 18:03.510
那比方说有一天,我们要增加

18:03.510 --> 18:05.510
增加内形,PID

18:05.510 --> 18:07.510
加一个

18:07.510 --> 18:09.510
那比方说,我们有一天要增加

18:09.510 --> 18:11.510
比方说增加

18:11.510 --> 18:13.510
间谍,性别

18:13.510 --> 18:15.510
难

18:15.510 --> 18:17.510
或者是

18:17.510 --> 18:19.510
增加了一些自断,或者是

18:19.510 --> 18:21.510
减少了一些自断

18:21.510 --> 18:23.510
或者是修改了自断

18:23.510 --> 18:25.510
是不是都会导致这里出问题

18:25.510 --> 18:27.510
因此呢,我们这里的

18:27.510 --> 18:29.510
更加希望的是啥呢

18:29.510 --> 18:31.510
你帮我算一算

18:31.510 --> 18:33.510
你来帮我计算一下

18:33.510 --> 18:35.510
根据什么来算呢

18:35.510 --> 18:37.510
就来算出这个内形里面

18:37.510 --> 18:39.510
有哪些自断,有哪些成绿

18:39.510 --> 18:41.510
那么怎么来算

18:42.510 --> 18:44.510
它可以作用云内

18:44.510 --> 18:46.510
接口,或者是内形别名

18:46.510 --> 18:48.510
用于获取其他内形中的

18:48.510 --> 18:50.510
所有成员名

18:50.510 --> 18:52.510
组成的

18:52.510 --> 18:54.510
联合内形

18:54.510 --> 18:55.510
明白这个意思吗

18:55.510 --> 18:57.510
如果你看到这个例子的话

18:57.510 --> 18:59.510
再来想这句话,就明白了

18:59.510 --> 19:01.510
它来获取其他内形

19:01.510 --> 19:03.510
中的所有

19:03.510 --> 19:05.510
成员名

19:05.510 --> 19:07.510
组成的联合内形

19:07.510 --> 19:09.510
扎写

19:10.510 --> 19:12.510
然后加上

19:13.510 --> 19:15.510
好,我们现在再用

19:15.510 --> 19:17.510
鼠标指责这个Prop

19:18.510 --> 19:20.510
看一下

19:20.510 --> 19:21.510
你看一下

19:21.510 --> 19:23.510
这是它算出来的结果

19:23.510 --> 19:25.510
我们这一张讲的是什么

19:25.510 --> 19:27.510
讲的是内形的演算

19:27.510 --> 19:29.510
讲的是内形的演算

19:29.510 --> 19:31.510
那么通过这个演算,你就明白了

19:31.510 --> 19:33.510
原来这么回事

19:33.510 --> 19:35.510
你就明白

19:35.510 --> 19:37.510
这里是怎么来处理的了

19:37.510 --> 19:39.510
它得到的是什么

19:39.510 --> 19:41.510
得到的是U字里边

19:41.510 --> 19:43.510
所有的成员名

19:43.510 --> 19:45.510
以及

19:45.510 --> 19:47.510
把它的成员名拿出来

19:47.510 --> 19:49.510
形成的联合内形

19:49.510 --> 19:51.510
而且这个东西是动态的

19:51.510 --> 19:53.510
也就是说,如果我这里把删掉

19:53.510 --> 19:55.510
这当然不用改

19:55.510 --> 19:57.510
你看,就变成这样子了

19:57.510 --> 19:59.510
它是动态读的

19:59.510 --> 20:01.510
这就是它的好处

20:01.510 --> 20:03.510
这个关键字非常强大

20:03.510 --> 20:05.510
它可以动态的去读

20:05.510 --> 20:07.510
形成联合内形

20:07.510 --> 20:09.510
形成联合内形

20:09.510 --> 20:11.510
OK,我们就通过这个东西

20:11.510 --> 20:13.510
通过这个东西

20:13.510 --> 20:15.510
来取出

20:15.510 --> 20:17.510
某些内形里边的成员

20:17.510 --> 20:19.510
这是K2不关键字

20:19.510 --> 20:21.510
后边我们很多地方

20:21.510 --> 20:23.510
都会用到这个关键字,K2

20:23.510 --> 20:25.510
好,最后

20:25.510 --> 20:27.510
来说这个关键字

20:29.510 --> 20:31.510
这个关键字表示什么意思呢

20:31.510 --> 20:33.510
它往往和K2不来进行联用

20:33.510 --> 20:35.510
该关键字

20:35.510 --> 20:37.510
往往和K2

20:37.510 --> 20:39.510
联用

20:39.510 --> 20:41.510
限制

20:41.510 --> 20:45.270
限制

20:45.270 --> 20:47.270
限制

20:47.270 --> 20:49.270
某个

20:49.270 --> 20:51.270
锁印

20:51.270 --> 20:53.270
它用来限制某个锁印

20:53.270 --> 20:55.270
内形的

20:55.270 --> 20:57.270
取直

20:57.270 --> 20:59.270
范围

20:59.270 --> 21:01.270
它做这么一件事

21:01.270 --> 21:03.270
锁印内形的锁印器

21:03.270 --> 21:05.270
好,我们再来一下

21:05.270 --> 21:07.270
比方说

21:07.270 --> 21:09.270
比方说吧

21:09.270 --> 21:11.270
我们这里呢

21:11.270 --> 21:13.270
好,比方说

21:13.270 --> 21:15.270
我们这里再写一个

21:15.270 --> 21:17.270
内雄别名

21:17.270 --> 21:19.270
给它写个名字

21:19.270 --> 21:21.270
叫做OB件

21:21.270 --> 21:23.270
就OB件

21:23.270 --> 21:25.270
就这样子写

21:25.270 --> 21:27.270
那它是个啥玩意儿呢

21:27.270 --> 21:29.270
它是一个带着锁印器的内形

21:29.270 --> 21:31.270
带一个锁印器的内形

21:31.270 --> 21:33.270
比方说,我们给它写个锁印器

21:33.270 --> 21:35.270
我们以前写过锁印器的

21:35.270 --> 21:37.270
这里有点热,大家要注意听

21:37.270 --> 21:39.270
这里是属性名

21:39.270 --> 21:41.270
属性名的话,我们用一个东西来表示

21:41.270 --> 21:43.270
比方说一个P来表示

21:43.270 --> 21:45.270
好,对这个属性名

21:45.270 --> 21:47.270
做一个它约束

21:47.270 --> 21:49.270
属性名得是一个字部串

21:49.270 --> 21:51.270
然后属性的值呢

21:51.270 --> 21:53.270
也得是一个字部串

21:53.270 --> 21:55.270
就写了这么一个内情别名出来

21:55.270 --> 21:57.270
这个内情别名约束的是啥呢

21:57.270 --> 21:59.270
它约束了一个非常

21:59.270 --> 22:01.270
非常宽泛的一个约束

22:01.270 --> 22:03.270
非常非常宽泛的一个约束

22:03.270 --> 22:05.270
比方说有一个对象

22:05.270 --> 22:07.270
它是OB件的内情

22:07.270 --> 22:09.270
先给它复制一个空对象

22:09.270 --> 22:11.270
然后后边

22:11.270 --> 22:13.270
我们可以给它加一些属性

22:13.270 --> 22:15.270
可不可以加,当然可以加

22:15.270 --> 22:17.270
为什么现在可以加属性

22:17.270 --> 22:19.270
以前不行的

22:19.270 --> 22:21.270
为什么现在可以加属性

22:21.270 --> 22:23.270
可以加属性的原因是因为

22:23.270 --> 22:25.270
我这里写的锁印器

22:25.270 --> 22:27.270
只要你匹配你的属性名字

22:27.270 --> 22:29.270
只要是个字部串,总为我匹配上了

22:29.270 --> 22:31.270
属性除了字部串

22:31.270 --> 22:33.270
还能是啥呢

22:33.270 --> 22:35.270
你属性可以是个字部串

22:35.270 --> 22:37.270
只要我匹配上了,那么没问题

22:37.270 --> 22:39.270
你只要复制的也是个字部串

22:39.270 --> 22:41.270
就OK,就是锁印器的好处

22:41.270 --> 22:43.270
只要有了锁印器过后

22:43.270 --> 22:45.270
我们可以通过这种方式给它加一些属性

22:45.270 --> 22:47.270
给它加一些属性

22:47.270 --> 22:49.270
好,但是呢

22:49.270 --> 22:51.270
但是呢,我觉得这样子的做呢

22:51.270 --> 22:53.270
太过于宽泛了

22:53.270 --> 22:55.270
太过于宽泛了

22:55.270 --> 22:57.270
我想呢把这个属性呢

22:57.270 --> 22:59.270
约束一下

22:59.270 --> 23:01.270
这个属性再进一步约束一下

23:01.270 --> 23:03.270
它不光是一个字部串

23:03.270 --> 23:05.270
而且呢,应该是

23:05.270 --> 23:07.270
它只有这么一些属性

23:07.270 --> 23:09.270
比方说login id

23:11.270 --> 23:13.270
有这么一个属性

23:13.270 --> 23:15.270
login id,然后呢

23:15.270 --> 23:17.270
有login password

23:19.270 --> 23:21.270
login password

23:21.270 --> 23:23.270
然后呢,有什么

23:23.270 --> 23:25.270
有A级

23:25.270 --> 23:27.270
它只能在这三个属性中取一个

23:27.270 --> 23:29.270
你可以加属性,但是加的话

23:29.270 --> 23:31.270
也不能乱加,加IPC啥意思呢

23:31.270 --> 23:33.270
一个加这三个当中的一个

23:33.270 --> 23:35.270
我想进行这样的约束

23:35.270 --> 23:37.270
那么在锁印器里边

23:37.270 --> 23:39.270
如何来进行这样的约束呢

23:39.270 --> 23:41.270
很简单

23:41.270 --> 23:43.270
把这个冒号变成印

23:43.270 --> 23:45.270
就完事了

23:45.270 --> 23:47.270
这样子呢,我就对这个锁印器

23:47.270 --> 23:49.270
它的属性名进行了约束

23:49.270 --> 23:51.270
你只要是在三个当中的一个

23:51.270 --> 23:53.270
都没有问题,都没有任何问题

23:53.270 --> 23:55.270
那么我允许你使用这些属性

23:55.270 --> 23:57.270
但是其他属性就不要来了

23:57.270 --> 23:59.270
其他的属性就不要来了

23:59.270 --> 24:01.270
于是呢,这种写法

24:01.270 --> 24:03.270
其实这样子写了之后

24:03.270 --> 24:05.270
就相当于是啥呢

24:05.270 --> 24:07.270
就相当于是我写了这么一个代码

24:07.270 --> 24:09.270
login id

24:09.270 --> 24:11.270
字符串

24:11.270 --> 24:13.270
login password

24:13.270 --> 24:15.270
字符串

24:15.270 --> 24:17.270
然后A级字符串

24:17.270 --> 24:19.270
我就相当于写了这个代码

24:19.270 --> 24:21.270
就上面这个代码呢

24:21.270 --> 24:23.270
跟下面一个代码效果是一样的

24:23.270 --> 24:25.270
效果是一样的

24:25.270 --> 24:27.270
好,我们来看一下上面这个代码

24:27.270 --> 24:29.270
于是呢,这里看爆错了

24:29.270 --> 24:31.270
这个油爆错了,它缺少了属性

24:31.270 --> 24:33.270
对吧,它缺少了属性

24:33.270 --> 24:35.270
好,那么我们这里可以使用

24:35.270 --> 24:37.270
login id

24:37.270 --> 24:39.270
这里加符串

24:39.270 --> 24:41.270
login password的符串

24:41.270 --> 24:43.270
这下没有问题了

24:43.270 --> 24:45.270
主要是让大家看一下这种写法

24:45.270 --> 24:47.270
这个硬的关键字,它的写法

24:47.270 --> 24:49.270
OK,那就没有什么问题了

24:49.270 --> 24:51.270
对吧

24:51.270 --> 24:53.270
好,然后呢,我们再来看

24:53.270 --> 24:55.270
再来看

24:55.270 --> 24:57.270
这里,你看这三个属性

24:57.270 --> 24:59.270
是不是跟这个油热的属性是一样的

24:59.270 --> 25:01.270
对不对

25:01.270 --> 25:03.270
我们之前不是学过这么一个玩意吗

25:03.270 --> 25:05.270
TO

25:05.270 --> 25:07.270
这个东西可以得到啥

25:07.270 --> 25:09.270
可以得到某一个类型的

25:09.270 --> 25:11.270
所有成员

25:11.270 --> 25:13.270
组成的联合类型

25:13.270 --> 25:15.270
一瞬联合类型这一块

25:15.270 --> 25:17.270
可以替换一下

25:17.270 --> 25:19.270
替换成啥

25:19.270 --> 25:21.270
替换成油热

25:21.270 --> 25:23.270
我这样子一操作,你看

25:23.270 --> 25:25.270
我做了一件什么事了

25:25.270 --> 25:27.270
大家发现了没

25:27.270 --> 25:29.270
我做了一件什么事

25:29.270 --> 25:31.270
我把这个油热这个类型的

25:31.270 --> 25:33.270
所有的属性名

25:33.270 --> 25:35.270
全部拿过来了

25:35.270 --> 25:37.270
然后把每一个属性的类型

25:37.270 --> 25:39.270
改成了制服串

25:39.270 --> 25:41.270
我做了这么一件事

25:41.270 --> 25:43.270
你看一下是不是这样子

25:43.270 --> 25:45.270
这个类型是跟着变的

25:45.270 --> 25:47.270
比如说还加了什么身份证号

25:47.270 --> 25:49.270
还加了什么就是

25:49.270 --> 25:51.270
创建日期

25:51.270 --> 25:53.270
加了一个创建日期

25:53.270 --> 25:55.270
我这个类型是不是跟着变的

25:55.270 --> 25:57.270
欧币界的类型是不是跟着变的

25:57.270 --> 25:59.270
所有东西全是制服串

25:59.270 --> 26:01.270
因此我这个类型

26:01.270 --> 26:03.270
可以打上一个注释

26:03.270 --> 26:05.270
这就是类型演算

26:05.270 --> 26:07.270
明白这张解我们要讲什么了吗

26:07.270 --> 26:09.270
我们这个张解就是

26:09.270 --> 26:11.270
如何根据已有的类型

26:11.270 --> 26:13.270
搞出一个新的类型出来

26:13.270 --> 26:15.270
这个就是将

26:15.270 --> 26:19.270
油热的所有属性

26:19.270 --> 26:25.270
只类型变成制服串

26:25.270 --> 26:27.270
变成制服串

26:27.270 --> 26:29.270
得到一个新类型

26:29.270 --> 26:31.270
得到一个新类型

26:31.270 --> 26:33.270
新类型就是欧币界

26:33.270 --> 26:35.270
或者我们该换个名字

26:35.270 --> 26:39.270
叫做油热施军

26:39.270 --> 26:41.270
通过这个类型

26:41.270 --> 26:43.270
我跟它油热的属性完全一样

26:43.270 --> 26:45.270
但是所有的属性值变成了制服串

26:45.270 --> 26:47.270
可以得到这么一个神奇的效果

26:47.270 --> 26:49.270
可以得到这么一个神奇的效果

26:49.270 --> 26:51.270
那么我们可以继续开发

26:51.270 --> 26:53.270
这里面玩的事情可多了

26:53.270 --> 26:55.270
我们比方说

26:55.270 --> 26:57.270
我们还可以这样做

26:57.270 --> 26:59.270
比如说

26:59.270 --> 27:01.270
再写欧币界

27:01.270 --> 27:03.270
再写欧币界

27:03.270 --> 27:05.270
我们现在不改它的类型

27:05.270 --> 27:07.270
我们现在不改它的类型

27:07.270 --> 27:09.270
属性原来是什么类型

27:09.270 --> 27:11.270
现在还是什么类型

27:11.270 --> 27:13.270
不改类型

27:13.270 --> 27:15.270
这里我不能写是不错的

27:15.270 --> 27:17.270
这里我可以写什么

27:17.270 --> 27:19.270
我可以这么写

27:19.270 --> 27:21.270
油热

27:21.270 --> 27:23.270
这就神奇了

27:23.270 --> 27:25.270
我们来看一下

27:25.270 --> 27:27.270
你这个完全不是属性吗

27:27.270 --> 27:29.270
对吧

27:29.270 --> 27:31.270
你是一次从油热里边

27:31.270 --> 27:33.270
把它的制断语全部拿出来

27:33.270 --> 27:35.270
login ID

27:35.270 --> 27:37.270
pid create date

27:37.270 --> 27:39.270
那么每一个属性是什么类型

27:39.270 --> 27:41.270
你油热

27:41.270 --> 27:43.270
里面通过属性去取

27:43.270 --> 27:45.270
取出来是什么类型

27:45.270 --> 27:47.270
那么目前的这个东西

27:47.270 --> 27:49.270
跟油热的所有的东西就全部都印起来了

27:49.270 --> 27:51.270
属性名完全一致

27:51.270 --> 27:53.270
属性的值的类型完全一致

27:53.270 --> 27:55.270
注意

27:55.270 --> 27:57.270
这个不是可以运行的代码

27:57.270 --> 27:59.270
这里只是类型

27:59.270 --> 28:01.270
只是在处理类型

28:01.270 --> 28:03.270
你看这是类型别名

28:03.270 --> 28:05.270
是不参与运行的

28:05.270 --> 28:07.270
编译结果里面是没有的

28:07.270 --> 28:09.270
好我们可以试一下

28:09.270 --> 28:11.270
创建一个用户

28:11.270 --> 28:13.270
我们看一下

28:13.270 --> 28:15.270
这个用户里边有什么login ID

28:15.270 --> 28:17.270
看制服串

28:17.270 --> 28:19.270
制服串的类型

28:19.270 --> 28:21.270
然后A级你看

28:21.270 --> 28:23.270
number的类型

28:23.270 --> 28:25.270
为什么是number

28:25.270 --> 28:27.270
因为当我们输写A级的时候

28:27.270 --> 28:29.270
相当于是把A级复制给了p

28:29.270 --> 28:31.270
那么这个p是A级

28:31.270 --> 28:33.270
取出来是number

28:33.270 --> 28:35.270
取出来是number

28:35.270 --> 28:37.270
这个邪法有点怪

28:37.270 --> 28:39.270
但是你是可以理解的

28:39.270 --> 28:41.270
通我解释的话你是可以理解的

28:41.270 --> 28:43.270
前面表示属性的名字

28:43.270 --> 28:45.270
全部来自于用户

28:45.270 --> 28:47.270
属性的类型

28:47.270 --> 28:49.270
也是来自于用户的

28:49.270 --> 28:51.270
通过属性名去取他的类型

28:53.270 --> 28:55.270
于是我们还可以玩出这个东西

28:55.270 --> 28:58.840
我发现

28:58.840 --> 29:00.840
这个类型里边有很多

29:00.840 --> 29:02.840
制断很多成员

29:02.840 --> 29:04.840
我想把这些成员

29:04.840 --> 29:06.840
其他的都不变

29:06.840 --> 29:08.840
属性名不变

29:08.840 --> 29:10.840
属性的类型不变

29:10.840 --> 29:12.840
不变都不变

29:12.840 --> 29:14.840
我只是要把它做成什么呢

29:14.840 --> 29:16.840
全部做成止读的

29:16.840 --> 29:18.840
前边

29:18.840 --> 29:20.840
我给它加上一个read only

29:20.840 --> 29:22.840
全部做成止读的

29:22.840 --> 29:24.840
好我们这里

29:24.840 --> 29:26.840
再取个名字

29:26.840 --> 29:28.840
user read only

29:28.840 --> 29:30.840
你看一下

29:30.840 --> 29:32.840
我们短短的体行代

29:32.840 --> 29:34.840
就做出了一个新的类型

29:34.840 --> 29:36.840
这个新的类型是根据原来类型算出来的

29:36.840 --> 29:38.840
把原来的类型

29:38.840 --> 29:40.840
稍做了一下改变

29:40.840 --> 29:42.840
把每一个属性改成了read only

29:42.840 --> 29:44.840
那么我们来试一下

29:44.840 --> 29:46.840
user read only

29:48.840 --> 29:50.840
给它付一些纸

29:50.840 --> 29:52.840
不需要那么多属性

29:52.840 --> 29:54.840
就两个属性就行了

29:54.840 --> 29:56.840
再测试一下

29:56.840 --> 29:58.840
其实我指着它已经看到了

29:58.840 --> 30:00.840
指着它已经看到这个结果了

30:00.840 --> 30:02.840
就是这两个属性

30:02.840 --> 30:04.840
前面给它加上read only

30:04.840 --> 30:06.840
算出来就是这样子

30:06.840 --> 30:08.840
这就是类型的演算

30:08.840 --> 30:10.840
好我们来看一下

30:10.840 --> 30:12.840
login id负责

30:12.840 --> 30:14.840
然后给login password负责

30:14.840 --> 30:16.840
负完之后

30:16.840 --> 30:18.840
我们想去修改它

30:18.840 --> 30:20.840
你看一下

30:20.840 --> 30:22.840
你看是不是不能改

30:22.840 --> 30:24.840
因为它是read only的

30:24.840 --> 30:26.840
我们就可以根据以之类型

30:26.840 --> 30:28.840
来演算出一些新的类型

30:30.840 --> 30:32.840
当然不仅可以使用read only

30:32.840 --> 30:34.840
我们还可以做很多的事

30:34.840 --> 30:36.840
做什么事呢

30:36.840 --> 30:38.840
比如user

30:38.840 --> 30:40.840
partial

30:40.840 --> 30:42.840
表示什么意思

30:42.840 --> 30:44.840
表示所有的属性

30:44.840 --> 30:46.840
把它变成可选的

30:46.840 --> 30:48.840
变成可选属性

30:48.840 --> 30:50.840
变成可选属性

30:50.840 --> 30:52.840
加上一个问号

30:52.840 --> 30:54.840
所有的属性都是可选的

30:54.840 --> 30:56.840
现在

30:56.840 --> 30:58.840
我可以写一个属性

30:58.840 --> 31:00.840
也没有什么问题了

31:00.840 --> 31:02.840
我们只要看一下

31:02.840 --> 31:04.840
相当于是把之前的东西

31:04.840 --> 31:06.840
就加上了一个属性

31:06.840 --> 31:08.840
每个成员加上了一个问号

31:08.840 --> 31:10.840
开不开心

31:10.840 --> 31:12.840
经目惊喜

31:12.840 --> 31:14.840
通过这种巧妙的方式

31:14.840 --> 31:16.840
可以对以之的类型来进行运算

31:16.840 --> 31:18.840
好有些人说

31:18.840 --> 31:20.840
你这个东西也不是很方便

31:20.840 --> 31:22.840
没看出来有什么方便的

31:22.840 --> 31:24.840
因为

31:24.840 --> 31:26.840
你这里只能处理user

31:26.840 --> 31:28.840
那如果我一些其他类型

31:28.840 --> 31:30.840
我还有文章

31:30.840 --> 31:32.840
interface

31:32.840 --> 31:34.840
article

31:34.840 --> 31:36.840
文章类型里面有标题

31:36.840 --> 31:38.840
有发布日期

31:38.840 --> 31:40.840
文章里面也有一些类型

31:40.840 --> 31:42.840
那如果我要处理文章

31:42.840 --> 31:44.840
把文章里面全部变成指读

31:44.840 --> 31:46.840
或者说把文章里面全部变成可选

31:46.840 --> 31:48.840
怎么做呢

31:48.840 --> 31:50.840
我又得去写一遍

31:50.840 --> 31:52.840
那这个时候

31:52.840 --> 31:54.840
我们就可以用这个东西

31:54.840 --> 31:56.840
放小

31:56.840 --> 31:58.840
放小

31:58.840 --> 32:00.840
OK你给我一个类型

32:00.840 --> 32:02.840
我管你给我的是啥

32:02.840 --> 32:04.840
我把这个类型里面的所有成员

32:04.840 --> 32:06.840
读出来

32:06.840 --> 32:08.840
我把这个类型里面所有的成员

32:08.840 --> 32:10.840
读出来

32:10.840 --> 32:12.840
然后每个成员的类型

32:12.840 --> 32:14.840
跟原来的类型保持一致

32:14.840 --> 32:16.840
跟原来的类型保持一致

32:16.840 --> 32:18.840
跟原来的类型保持一致

32:18.840 --> 32:20.840
名字

32:20.840 --> 32:22.840
改一下

32:22.840 --> 32:24.840
改一下

32:24.840 --> 32:26.840
好那现在看一下

32:26.840 --> 32:28.840
通用了

32:28.840 --> 32:30.840
通用了

32:30.840 --> 32:32.840
不得了了

32:32.840 --> 32:34.840
parsho user

32:34.840 --> 32:36.840
那么我们看一下

32:36.840 --> 32:38.840
parsho user

32:38.840 --> 32:40.840
这里我们指着

32:40.840 --> 32:42.840
看不出来了

32:42.840 --> 32:44.840
但是呢我们可以想象得到

32:44.840 --> 32:46.840
这个东西得到的是什么

32:46.840 --> 32:48.840
得到的是用户这个类型

32:48.840 --> 32:50.840
它里面所有东西可选

32:50.840 --> 32:52.840
所有东西可选

32:52.840 --> 32:54.840
locking id

32:54.840 --> 32:56.840
locking password 都是可选的

32:56.840 --> 32:58.840
好同样的道理

32:58.840 --> 33:00.840
我们给它一个read only

33:00.840 --> 33:02.840
read only

33:02.840 --> 33:04.840
然后加上这么一个范形

33:04.840 --> 33:06.840
加上一个范形

33:06.840 --> 33:08.840
好这里变成t

33:08.840 --> 33:10.840
好你看

33:10.840 --> 33:12.840
那么我们比方说

33:12.840 --> 33:14.840
read only

33:14.840 --> 33:16.840
那么表示我可以通过

33:16.840 --> 33:18.840
它来得到一个新的类型

33:18.840 --> 33:20.200
就是跟

33:20.200 --> 33:22.200
用户完全一致

33:22.200 --> 33:24.200
只不过呢它的所有的属性

33:24.200 --> 33:26.200
变成止读的了

33:26.200 --> 33:28.200
变成止读的了

33:28.200 --> 33:30.200
好我们这里复制一下

33:30.200 --> 33:32.200
locking password

33:32.200 --> 33:34.200
复制一下那么后边呢我要跟它复制

33:34.200 --> 33:36.200
就要报处了

33:36.200 --> 33:38.200
就要报处了因为它是止读的

33:38.200 --> 33:40.200
原来这个意思吗

33:40.200 --> 33:42.200
我们可以通过以致的类型

33:42.200 --> 33:44.200
而且是通用的看到没

33:44.200 --> 33:46.200
加了范形过后就通用了

33:46.200 --> 33:48.200
好同样的道理

33:48.200 --> 33:50.200
我这个这个地方也是一样

33:50.200 --> 33:52.200
也是一样

33:52.200 --> 33:54.200
好是g

33:54.200 --> 33:56.200
把一个类型的所有

33:56.200 --> 33:58.200
字段全部变成致不错

33:58.200 --> 34:00.200
t

34:00.200 --> 34:02.200
这边变成t

34:02.200 --> 34:04.200
完事了

34:04.200 --> 34:06.200
这样子一来呢我甭管你是个啥玩意

34:06.200 --> 34:08.200
你到我通过这个东西一言算得到的结果

34:08.200 --> 34:10.200
所有的属性全部变成致不错了

34:10.200 --> 34:12.200
可以试一下呗

34:12.200 --> 34:14.200
可以试一下

34:14.200 --> 34:16.200
然后这里使用article

34:18.200 --> 34:20.200
那么文章里边

34:20.200 --> 34:22.200
不是有什么title对吧

34:22.200 --> 34:24.200
致不错

34:24.200 --> 34:26.200
然后呢发布日期

34:26.200 --> 34:28.200
你看发布日期本来是日期内形的

34:28.200 --> 34:30.200
本来是日期内形的

34:30.200 --> 34:32.200
但是现在呢变成了致不错

34:32.200 --> 34:34.200
本来是日期内形的

34:34.200 --> 34:36.200
通过这个演算得到的新的内形

34:36.200 --> 34:38.200
就变成了致不错

34:38.200 --> 34:40.200
我们就可以通过这种方式

34:40.200 --> 34:42.200
ql

34:42.200 --> 34:44.200
配合

34:44.200 --> 34:46.200
再配合锁印器

34:46.200 --> 34:48.200
再配合这种格式的代码

34:48.200 --> 34:50.200
就可以达到很丰富的内形演算的效果

34:52.200 --> 34:54.200
我们这一个章节

34:54.200 --> 34:56.200
其实说了就是这个东西

34:56.200 --> 34:58.200
如何来根据已知的内形来得到一个新的内形

34:58.200 --> 35:00.200
那你能不能自己手写代码

35:00.200 --> 35:02.200
来做一个新的内形呢

35:02.200 --> 35:04.200
可以只是麻烦

35:04.200 --> 35:06.200
比方说像这些地方

35:06.200 --> 35:08.200
是不是也可以去写一遍那些内形

35:08.200 --> 35:10.200
自己把手写一遍

35:10.200 --> 35:12.200
可不可以 当然可以 只是麻烦

35:12.200 --> 35:14.200
所以说它提供了这么一种这些方式

35:14.200 --> 35:16.200
来帮助我们去制作新的内形

35:18.200 --> 35:20.200
OK 这是关于印度关键制和ql5进行联用

35:20.200 --> 35:22.200
通常是在锁印器的位置

35:22.200 --> 35:24.200
来进行联用

35:24.200 --> 35:26.200
通过这节课呢

35:26.200 --> 35:28.200
其实大家也可以想象得到

35:28.200 --> 35:30.200
我们这一张是在想啥

35:30.200 --> 35:32.200
就是来讲的是一些

35:32.200 --> 35:34.200
需要进行演算的地方

35:34.200 --> 35:36.200
我们有一些内形

35:36.200 --> 35:38.200
我们需要把它算一下

35:38.200 --> 35:40.200
来得到一个新的内形

35:40.200 --> 35:42.200
OK 这是关于我们这一块的

35:42.200 --> 35:44.200
知识

35:44.200 --> 35:46.200
ql5的关键制

35:46.200 --> 35:48.200
一定要好好去理解

35:48.200 --> 35:50.200
好了 那么

35:50.200 --> 35:52.200
这里可以到差不多了

35:52.200 --> 35:54.200
我们这一张其实东西并不多

35:54.200 --> 35:56.200
我们后边会一直来讲解

35:56.200 --> 35:58.200
其实在TS里边

35:58.200 --> 36:00.200
这些东西它已经硬的做了

36:00.200 --> 36:02.200
不少了这些东西了

36:02.200 --> 36:04.200
已经做了好多内形演算的

36:06.200 --> 36:08.200
通过可以进行内形演算的别名

36:08.200 --> 36:10.200
你看我们这里是自己做的

36:10.200 --> 36:12.200
这里是自己做的

36:12.200 --> 36:14.200
其实TS已经给你做了不少了

36:14.200 --> 36:16.200
因此我们后边还要学习一些

36:16.200 --> 36:18.200
TS已经给你做好的一些东西

36:18.200 --> 36:20.200
用它们可以非常方便的

36:20.200 --> 36:22.200
来进行内形演算

36:22.200 --> 36:24.200
内形演算的本质

36:24.200 --> 36:26.200
大部分时候都是使用这个关键制

36:26.200 --> 36:28.200
ql5 因为这个关键制

36:28.200 --> 36:30.200
可以得到根据一个

36:30.200 --> 36:32.200
已知的内形得到它里边的

36:32.200 --> 36:34.200
一些成员

36:34.200 --> 36:36.200
我们得到成员之后呢

36:36.200 --> 36:38.200
我们就可以进一步来进行演算了

36:38.200 --> 36:40.200
好了 那么本节课呢

36:40.200 --> 36:42.200
学校这么三个关键制

36:42.200 --> 36:44.200
下去好好理解

36:44.200 --> 36:46.200
这三个关键制它们各自的作用

36:46.200 --> 36:48.200
特别是后面两个关键制

36:48.200 --> 36:50.200
用的非常频繁

36:50.200 --> 36:52.200
就是在我们这一张用的很频繁

36:52.200 --> 36:54.200
好了 那么这里可以到这了

36:54.200 --> 36:56.200
拜拜

