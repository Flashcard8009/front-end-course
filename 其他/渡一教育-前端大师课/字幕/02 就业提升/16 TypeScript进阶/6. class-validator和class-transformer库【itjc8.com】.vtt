WEBVTT

00:01.010 --> 00:07.150
上节课呢 我们介绍了这么一个酷叫reflect metadata 这么一个酷

00:07.670 --> 00:10.490
这节课我们再继续介绍两个酷

00:11.250 --> 00:15.850
这两个酷分别叫做class validator

00:16.630 --> 00:19.690
听这个名字就知道是做验证的对吧

00:19.950 --> 00:24.050
然后和另外一个class transform

00:24.310 --> 00:25.590
transformer

00:26.110 --> 00:27.130
介绍这么两个酷

00:27.390 --> 00:32.250
这两个酷也是我个人非常非常喜欢的这两个酷

00:32.510 --> 00:38.390
在做ts开发的时候用这两个酷可以帮助我们解决很多很多的问题

00:39.150 --> 00:42.490
我们来首先说这么一个酷class validator这个酷

00:42.990 --> 00:44.010
我们来看一下

00:44.270 --> 00:48.370
只是简单介绍这两节课 这节课只是简单介绍

00:48.630 --> 00:51.710
并不会涉及到太多的跟这个酷的

00:51.970 --> 00:54.010
使用相关的东西 有没有电网

00:54.730 --> 01:02.050
因为这两个酷它里面东西很多 非常非常多

01:02.310 --> 01:06.910
我只是抛砖隐喻 给大家说一下这两个酷的主要功能是做什么

01:07.430 --> 01:11.010
至于具体的使用的话 大家可以去读它的官方文档

01:11.790 --> 01:12.810
class validator

01:13.570 --> 01:14.850
看一下啊

01:15.370 --> 01:20.490
这个酷它顾名示意是做验证的 你看一下它的功能非常非常多 功能很强大

01:21.210 --> 01:25.050
做什么验证呢 它的做法就是在内意上边

01:25.310 --> 01:29.150
你看像这种方式 在内意上边给它加一些验证规则

01:29.910 --> 01:31.710
加了验证规则之后

01:31.970 --> 01:36.050
然后后边就使用validator 它提供了一个函数validator

01:36.310 --> 01:39.390
然后对这个整个内的对象进行一个验证

01:39.890 --> 01:43.230
如果出现错误的话 它会把错误的消息给你返回

01:43.990 --> 01:47.070
也就是相当于是我们之前做这么一个

01:47.370 --> 01:51.290
就是这种方式 做了一个功用的函数 通用的函数

01:51.550 --> 01:55.210
print obj 那么它也是做了一个通用的函数validator

01:55.970 --> 01:57.010
好 我们来试一下啊

01:57.510 --> 02:00.090
我们首先安装它 安装这个酷

02:01.090 --> 02:01.930
这里停止

02:03.930 --> 02:04.430
停止

02:05.450 --> 02:07.450
这里我们先安装

02:07.710 --> 02:11.610
ya,add,class,validator

02:11.850 --> 02:15.170
其实这两个酷呢 它们都是基于一个前提 基于什么前提呢

02:15.390 --> 02:19.510
就是要安装我们上节课学习的reflect metadata

02:19.710 --> 02:21.310
需要先安装那个酷

02:21.570 --> 02:23.870
如果你没有安装的话 需要先安装一下

02:24.650 --> 02:27.470
然后安装好了之后我们就可以使用它了

02:27.710 --> 02:28.590
就可以使用它了

02:28.750 --> 02:30.270
我们把这个index清空

02:30.530 --> 02:33.350
使用之前你首先得装这么一件事

02:33.590 --> 02:36.870
你首先得把metadatareflect

02:37.710 --> 02:40.510
metadata 把导入进来 先把导入进来

02:40.770 --> 02:43.070
因为这两个酷都是依赖这个东西的

02:43.790 --> 02:46.850
好 导入进来之后了我们就可以使用这个酷了

02:47.130 --> 02:49.170
比方说我们有这么一个用户

02:49.930 --> 02:50.970
有这么一个用户

02:51.210 --> 02:53.250
用户里边呢

02:53.510 --> 02:54.490
我们看一下啊

02:54.750 --> 02:55.810
用户里边

02:57.090 --> 02:58.890
我们给它写两个属性吧

02:59.150 --> 02:59.930
一个是

03:00.430 --> 03:00.950
帐号

03:01.710 --> 03:02.490
致富串

03:02.990 --> 03:04.770
一个是密码

03:05.550 --> 03:06.330
致富串

03:06.570 --> 03:08.370
比方说用户要注册

03:08.370 --> 03:09.910
比方说这样子

03:10.170 --> 03:11.170
注册用户

03:11.950 --> 03:13.550
有账号要填密码

03:13.550 --> 03:14.450
要填账号

03:14.450 --> 03:15.470
然后还要填什么呢

03:15.470 --> 03:16.590
还要填年龄

03:18.750 --> 03:20.610
还要填性别

03:20.610 --> 03:21.470
肩带

03:22.590 --> 03:23.350
它是

03:23.910 --> 03:24.550
蓝

03:24.910 --> 03:25.710
或者是

03:28.390 --> 03:29.710
要填这么一些数据

03:30.590 --> 03:31.710
好了 那么现在呢

03:31.710 --> 03:35.310
我给他们这些属性加一些验证规则

03:35.470 --> 03:35.950
注意

03:36.110 --> 03:37.630
这些验证规则

03:37.630 --> 03:39.910
它会影响到运行的时候

03:40.290 --> 03:42.130
像我们之前做那个

03:42.850 --> 03:43.810
TS的时候

03:43.810 --> 03:45.810
全所有的什么内行

03:46.130 --> 03:47.730
推断了内行

03:47.970 --> 03:48.730
约束啊

03:48.730 --> 03:50.010
内行检查啊

03:50.010 --> 03:51.930
全都是编译的事态

03:52.330 --> 03:54.210
只有在写代码的时候

03:54.210 --> 03:55.130
我们才有效

03:55.530 --> 03:56.850
而我们现在呢

03:56.850 --> 03:58.610
是要在运行的过程中

03:58.610 --> 03:59.210
我们要看

03:59.210 --> 04:00.730
要对它进行验证

04:00.970 --> 04:01.970
那么这个时候呢

04:02.050 --> 04:04.330
TS的内行检查就全部失效了

04:04.650 --> 04:06.730
这个时候我们就可以一脱与这个库

04:07.010 --> 04:07.410
啊

04:07.410 --> 04:08.010
因为我们知道

04:08.030 --> 04:10.430
原数据它是会参与运行的

04:10.590 --> 04:11.270
所以说这个库呢

04:11.270 --> 04:12.870
它是一脱与原数据的

04:13.150 --> 04:14.990
因此它可以在运行的过程中

04:14.990 --> 04:15.750
它会作用

04:16.350 --> 04:17.710
好 具体怎么用呢

04:17.710 --> 04:21.470
这个内里边给你提供了大量的一些验证规则啊

04:21.550 --> 04:22.230
比方说

04:22.950 --> 04:23.990
我们可以这样子写

04:24.350 --> 04:26.270
首先写个非空验证啊

04:26.270 --> 04:27.270
你不能维空

04:27.710 --> 04:28.910
那么这个非空验证呢

04:28.910 --> 04:29.910
我们可以这样子写

04:30.430 --> 04:31.110
Is

04:31.870 --> 04:32.470
Not

04:34.150 --> 04:35.190
IsNot

04:35.470 --> 04:36.110
Empty

04:37.090 --> 04:39.090
写这么一个东西

04:39.090 --> 04:40.330
好 把他导入进来啊

04:40.650 --> 04:41.450
导入进来

04:41.450 --> 04:42.650
这里我们手动导入啊

04:43.250 --> 04:44.450
手动导入

04:44.450 --> 04:46.930
从这个class-validator里边

04:47.170 --> 04:50.770
把这个IsNotEmpty导入进来

04:50.770 --> 04:51.730
把我这里写错了

04:51.730 --> 04:52.650
手这么大写

04:54.650 --> 04:55.170
好

04:55.650 --> 04:56.450
导入这个库

04:56.690 --> 04:58.610
然后把这个函数导入进来

04:58.770 --> 04:59.770
其实它是一个啥

04:59.890 --> 05:01.730
它就是产生一个装饰器

05:01.930 --> 05:03.530
产生一个装饰器的函数

05:04.010 --> 05:04.490
好

05:04.950 --> 05:06.630
我们写好这个装饰器过后呢

05:06.630 --> 05:07.950
我们来试着做一下

05:07.950 --> 05:09.670
试着写一下

05:09.670 --> 05:11.470
看他如何来进行验证的

05:12.710 --> 05:14.230
产生一个表单

05:14.230 --> 05:14.870
Post

05:15.670 --> 05:18.670
留一个注册用户对象

05:19.830 --> 05:20.870
然后来验证他

05:20.990 --> 05:21.630
怎么验证

05:21.630 --> 05:22.950
他里边给你提供了一个函数

05:22.950 --> 05:23.790
叫Validator

05:25.030 --> 05:25.950
你看这个函数

05:27.110 --> 05:28.990
这个函数里边传一个参数

05:28.990 --> 05:29.990
就传你的对象

05:29.990 --> 05:31.790
你要验证的对象扔进去

05:32.590 --> 05:32.830
好

05:32.830 --> 05:33.870
如果这个对象

05:34.090 --> 05:35.370
他所属的内

05:35.370 --> 05:36.890
里边有这些验证规则

05:36.890 --> 05:38.050
他就会触犯验证

05:39.010 --> 05:40.210
验证结束过后

05:40.210 --> 05:42.050
注意这个东西是一个异步的

05:42.050 --> 05:43.290
是一个异步的

05:43.410 --> 05:44.330
他反过来是啥呢

05:44.330 --> 05:45.450
看一下他反过来是啥

05:45.570 --> 05:46.770
反过来是一个Promise

05:46.770 --> 05:47.290
看看

05:47.610 --> 05:48.610
他是个异步的

05:48.610 --> 05:50.970
因此你这里要用异步的方式来编程

05:50.970 --> 05:51.610
直接

05:52.410 --> 05:52.970
好

05:53.370 --> 05:55.210
验证结束之后呢

05:55.210 --> 05:57.570
我们可以得到一些验证错误

05:58.850 --> 06:01.010
我们这里把这个验证错误输出

06:01.490 --> 06:03.050
把这些验证错误输出

06:03.190 --> 06:04.110
看一下有没有错误

06:04.110 --> 06:05.550
保存看一下

06:06.830 --> 06:08.710
我们轻轻轻软

06:08.710 --> 06:09.190
对

06:11.840 --> 06:12.200
看一下

06:14.200 --> 06:16.880
你看他这里得到了一个验证错误

06:16.880 --> 06:17.840
什么错误呢

06:18.480 --> 06:19.200
是一个对象

06:20.120 --> 06:21.840
这个错误本身是一个输足

06:22.520 --> 06:23.640
本身是一个输足

06:24.200 --> 06:26.160
输足里边有一个对象

06:26.160 --> 06:29.480
说明了有一个地方验证出了问题

06:30.440 --> 06:30.680
好

06:30.680 --> 06:32.600
这个对象里边记录了一些东西

06:33.160 --> 06:34.120
一个是Target

06:34.700 --> 06:37.220
表示的是验证的目标对象

06:37.780 --> 06:39.100
验证的目标对象是啥呢

06:39.100 --> 06:40.300
是就是这个Post

06:41.100 --> 06:42.260
他这里面有记录

06:42.260 --> 06:43.300
记录了这个Post

06:43.900 --> 06:45.220
就是你这个对象

06:45.220 --> 06:45.940
验证的对象

06:46.580 --> 06:50.180
然后Values表示了你验证的属性值

06:51.180 --> 06:52.980
你这个错误验证的哪个属性呢

06:52.980 --> 06:55.340
验证的是属性是login ID

06:56.140 --> 06:57.220
验证的属性值呢

06:57.220 --> 06:58.100
是undefined

06:58.900 --> 06:59.100
好

06:59.100 --> 07:00.460
切要准我们不用管

07:00.460 --> 07:02.740
下面是个Constance

07:02.740 --> 07:03.940
constance

07:04.140 --> 07:06.180
表示约束哪个约束出了问题

07:06.700 --> 07:07.780
哪个规则出了问题

07:08.260 --> 07:08.740
这个规则

07:09.460 --> 07:10.660
is not empty

07:11.380 --> 07:12.500
这个规则出了问题

07:12.500 --> 07:13.540
出了什么问题呢

07:13.540 --> 07:15.460
他要求你不能维空

07:15.460 --> 07:17.180
但是你现在没有给他复制

07:17.180 --> 07:18.180
所以说出了问题

07:18.740 --> 07:20.500
于是他给你一个错误消息

07:20.500 --> 07:22.260
这个错误消息是默认的错误消息

07:23.540 --> 07:27.740
他表示login ID应该不能维空

07:27.740 --> 07:28.820
就表示这个错误消息

07:31.020 --> 07:31.220
好

07:31.220 --> 07:33.140
那么这里我们可以手动的

07:33.140 --> 07:35.220
还可以手动的给他一个错误消息

07:35.280 --> 07:36.440
就在这个验证规则这里

07:36.920 --> 07:38.400
给他加一个配置对象

07:39.080 --> 07:41.360
配置对象里边在写上面设计

07:41.360 --> 07:42.520
表示错误消息

07:43.280 --> 07:44.640
比方说给他写个

07:45.600 --> 07:46.600
错误消息就是

07:46.600 --> 07:47.600
如果验证失败

07:47.600 --> 07:48.640
他的错误消息就是

07:49.240 --> 07:51.600
账号不可以维空

07:52.760 --> 07:54.000
或者是账号必须填写

07:54.520 --> 07:56.120
保存再重新验证一次

07:57.320 --> 07:58.800
你看现在的错误消息

07:58.800 --> 07:59.800
我们就得到了

07:59.800 --> 08:00.600
这个错误消息了

08:01.760 --> 08:03.800
那如果验证通过了

08:03.820 --> 08:05.900
比方说我这里给这个对象

08:05.900 --> 08:07.580
设置好了一个login ID

08:08.300 --> 08:09.580
设置好了一个login ID

08:09.580 --> 08:10.780
然后给他一个字母串

08:11.100 --> 08:11.980
随便给他一个字母串

08:12.380 --> 08:12.780
保存

08:14.380 --> 08:15.980
验证通过你看得到了

08:15.980 --> 08:16.820
就是一个空数组

08:17.580 --> 08:18.860
所以说我们验证之后

08:18.860 --> 08:20.380
可以根据这个Aerous

08:20.980 --> 08:23.500
来得到他的相应的信息

08:23.500 --> 08:25.340
到底验证有没有通过

08:25.940 --> 08:27.220
如果有错误的话

08:27.220 --> 08:28.700
有哪些错误信息

08:29.260 --> 08:30.020
我们就可以得到了

08:31.020 --> 08:31.900
好再比方说

08:32.880 --> 08:33.920
我这里加了一个规则

08:33.920 --> 08:34.400
对吧

08:34.400 --> 08:35.960
我们还可以继续加规则

08:36.760 --> 08:38.360
比方说还可以加这么一个规则

08:38.880 --> 08:39.520
叫做

08:40.920 --> 08:42.280
LinLens

08:43.840 --> 08:45.640
这个字母串的最小长度

08:46.040 --> 08:46.760
最小长度

08:46.760 --> 08:47.600
然后我给他一个5

08:48.560 --> 08:51.040
表示账号必须至少有5个字符

08:51.680 --> 08:53.400
如果有出现错误的话

08:53.400 --> 08:55.280
我们这里就给个错误消息

08:55.720 --> 08:57.320
账号必须是

08:57.960 --> 09:00.760
必须至少有5个字符

09:02.360 --> 09:03.120
好同样的道理

09:03.120 --> 09:04.840
我们还可以给他一个Match

09:05.640 --> 09:06.680
MatchLens

09:07.680 --> 09:09.760
最长的账号了12个字符

09:10.280 --> 09:11.400
给他的错误消息

09:12.600 --> 09:16.200
账号最多12个字符

09:17.560 --> 09:20.040
你看我们现在就加了三个验证规则

09:20.680 --> 09:22.200
那么现在我们再验证试一下

09:22.200 --> 09:23.080
验证试一下

09:23.080 --> 09:23.880
我啥都不写

09:24.600 --> 09:25.080
啥都不写

09:25.080 --> 09:25.800
我们来试一下

09:27.840 --> 09:31.520
你看同一个字段出现了三个错误

09:31.920 --> 09:34.040
一个是账号最多12个字符

09:35.160 --> 09:36.440
账号必须至少有5个字符

09:36.440 --> 09:37.280
账号不可以维护

09:37.280 --> 09:38.600
你看三个错误都出现了

09:39.000 --> 09:40.680
都没有通过通过这个验证

09:41.520 --> 09:42.240
好再来啊

09:42.800 --> 09:45.480
我们如果在这里写上了两个字符

09:46.800 --> 09:48.240
写上两个字符保存一下

09:49.600 --> 09:51.560
好你看现在的只有一个错误

09:51.560 --> 09:53.240
账号必须至少有5个字符

09:54.360 --> 09:54.960
明白了吗

09:54.960 --> 09:56.280
这就是他的验证方式

09:57.280 --> 09:59.800
每一个大的就是每一个属性的

09:59.800 --> 10:00.840
他会对应一个对象

10:01.620 --> 10:02.340
一个对象里边

10:02.340 --> 10:03.940
他可能包含多个错误

10:03.940 --> 10:05.140
当然你根据需要

10:05.140 --> 10:06.980
根据需要去取这些错误信息

10:06.980 --> 10:08.220
把它输出就完事了

10:09.420 --> 10:11.180
这是个验证规则

10:11.180 --> 10:12.900
好当然我们其他的属性

10:12.900 --> 10:15.340
也可以实现类似的效果

10:15.340 --> 10:15.940
其他的属性

10:15.940 --> 10:17.380
我们再来写一个

10:18.220 --> 10:19.900
比方说年龄吧

10:19.900 --> 10:21.620
年龄年龄的话

10:21.620 --> 10:23.260
最小值我们可以用命

10:24.500 --> 10:28.340
最小值的话只能是您给他个错误消息

10:28.340 --> 10:33.840
没关系年龄的最小值是零

10:35.040 --> 10:36.840
只能大于等于零

10:36.840 --> 10:38.440
然后最大值呢

10:38.440 --> 10:38.840
最大值

10:41.040 --> 10:43.840
max最大值一百

10:44.760 --> 10:45.520
给他个错误消息

10:46.640 --> 10:49.360
年龄的最大值是一百

10:51.040 --> 10:52.480
大家能体会到这个

10:52.480 --> 10:54.480
这种验证方式的差异吗

10:54.480 --> 10:56.320
这种验证的好处在于什么呢

10:56.320 --> 10:57.960
我编写这个内的时候

10:58.720 --> 11:01.560
他的每一个属性有什么样的验证规则

11:01.560 --> 11:05.320
我就可以可以用这个库给他配置进去

11:05.320 --> 11:06.280
然后之后呢

11:06.280 --> 11:07.840
直接通过validate

11:07.840 --> 11:09.360
就可以实现验证了

11:09.360 --> 11:10.960
而不需要自己在外表

11:10.960 --> 11:13.000
再去手动的去写代嘛

11:13.000 --> 11:15.720
去配置有哪些地方进行验证

11:15.720 --> 11:17.560
我们直接在写这个属性的时候

11:17.560 --> 11:19.360
就可以把验证规则配置好

11:19.360 --> 11:21.280
那么这个对象无论用在什么地方

11:21.280 --> 11:22.880
我们都可以去触发他的验证

11:23.820 --> 11:26.660
这里我们可以看一下

11:26.660 --> 11:28.020
这个结果

11:29.460 --> 11:31.940
比较说A级给他复制为复一

11:31.940 --> 11:33.180
给他复制为复一

11:33.180 --> 11:33.700
我们看一下

11:34.860 --> 11:36.580
你看现在有两个对象了

11:36.580 --> 11:39.180
表示这里有两个属性出了问题

11:39.180 --> 11:40.060
第一个属性出了问题

11:40.060 --> 11:41.740
账号要有五个字符

11:41.740 --> 11:43.940
第二个属性的又出了问题

11:43.940 --> 11:45.300
年龄的最小只能是零

11:46.380 --> 11:47.820
这明白这个意思吧

11:47.820 --> 11:49.580
就是关于这个库的使用

11:49.580 --> 11:50.980
非常非常简单

11:51.000 --> 11:53.600
但是他里面还有很多很多东西了

11:53.600 --> 11:56.600
比方说什么验证游乡

11:56.600 --> 11:58.240
验证日期

11:58.240 --> 12:00.320
是不是一个日期等等等等

12:00.320 --> 12:02.080
还可以进行制定验证

12:02.080 --> 12:04.240
还可以进行验证规则分组

12:04.240 --> 12:05.520
他的功能很强大

12:05.520 --> 12:08.040
大家可以下来去看一下这个文档

12:08.040 --> 12:09.840
如果你觉得英文太老火的话

12:09.840 --> 12:11.280
你可以百度去搜一下

12:11.280 --> 12:12.640
看有没有相关的博客

12:12.640 --> 12:14.880
因为我们这一刻呢

12:14.880 --> 12:18.160
我们这个章节是讲的是那个

12:18.180 --> 12:21.180
装饰器并不是说去讲这个库

12:21.180 --> 12:22.980
关于这个库的使用的话

12:22.980 --> 12:24.060
我们看以后

12:24.060 --> 12:26.140
后边我们会做一些项目

12:26.140 --> 12:27.420
做一些项目实战

12:27.420 --> 12:29.340
做项目实战的时候会用到这个库

12:29.340 --> 12:30.980
他的关于跟他更多的功能

12:30.980 --> 12:31.940
我们用到了再说吧

12:33.100 --> 12:35.540
这是关于这么一个库

12:35.540 --> 12:36.820
这是做验证的

12:36.820 --> 12:37.460
做验证的

12:38.460 --> 12:39.580
然后另外一个库呢

12:39.580 --> 12:40.940
我要说一下

12:40.940 --> 12:42.340
另外一个库呢

12:42.340 --> 12:45.140
是跟这个库是同一个公司开发的

12:45.140 --> 12:46.740
他的名字叫做

12:46.760 --> 12:48.280
他们相当于是兄弟姐妹

12:48.280 --> 12:50.640
叫做Chance Former

12:53.400 --> 12:54.600
就这个库

12:54.600 --> 12:55.280
给大家介绍一下

12:56.600 --> 12:59.080
这个库是用来做什么的呢

12:59.080 --> 13:02.280
他可以把一个平面对象

13:02.280 --> 13:05.840
转换成一个类的对象

13:05.840 --> 13:07.080
啥意思

13:07.080 --> 13:08.360
我们来举个例子

13:08.360 --> 13:10.120
大家就明白了

13:10.120 --> 13:12.440
这官方文档里边也说到这种情况

13:13.680 --> 13:14.520
比方说

13:14.520 --> 13:17.920
我从服务器去取一些数据的时候

13:18.660 --> 13:20.060
服务器有个数组

13:20.060 --> 13:23.420
我们请求服务器的相应地址能够取到的数据

13:23.420 --> 13:25.420
那么我们现在就做一下吧

13:25.420 --> 13:29.020
我们去访问这么一个网站叫MyJason.com

13:29.020 --> 13:30.420
访问一下这个网站

13:30.420 --> 13:33.020
这个网站可以模拟一些服务器的数据

13:33.020 --> 13:35.020
我们把这个数据放过来

13:35.020 --> 13:36.860
这是我们的数据

13:36.860 --> 13:38.900
然后我这里点保存

13:38.900 --> 13:39.900
保存一下

13:40.900 --> 13:41.900
保存好了

13:41.900 --> 13:42.900
保存好了

13:42.900 --> 13:43.900
过来他告诉你

13:43.900 --> 13:45.700
你只要去请求这个地址

13:45.760 --> 13:47.840
你只要去请求这个地址

13:47.840 --> 13:49.680
你就能得到这个数据

13:49.680 --> 13:51.840
他是用来做一些接胜格式的数据

13:51.840 --> 13:52.800
测试的

13:52.800 --> 13:53.440
做一些测试的

13:53.440 --> 13:54.880
我们来请求一下

13:54.880 --> 13:55.440
你看

13:55.440 --> 13:55.880
请求过后

13:55.880 --> 13:58.240
我们就得到这样的数据了

13:58.240 --> 14:00.000
那么现在我们假设

14:00.000 --> 14:02.340
在客户端这边去请求这个地址

14:02.340 --> 14:04.000
来得到数据

14:04.000 --> 14:07.240
我们这里把之前的代码就注释掉了

14:07.240 --> 14:09.640
这里代码注释掉了

14:09.640 --> 14:12.280
这里我们安装一个X尺

14:12.280 --> 14:15.400
X尺这个困境给大家很熟悉吧

14:15.500 --> 14:16.500
安装一下

14:18.500 --> 14:19.700
安装好了过后

14:19.700 --> 14:22.300
我们让X尺去请求这个地址

14:22.300 --> 14:23.800
X尺

14:23.800 --> 14:25.300
到入境来

14:25.300 --> 14:26.300
Input

14:26.300 --> 14:27.300
X尺

14:29.300 --> 14:30.300
到入境来

14:30.300 --> 14:32.300
然后通过他去请求服务器

14:32.300 --> 14:33.300
请求什么地址

14:33.300 --> 14:34.300
就请求这个地址

14:34.300 --> 14:36.300
刚才这个地址

14:36.300 --> 14:37.300
好

14:37.300 --> 14:38.300
请求他过后

14:38.300 --> 14:39.300
是不是能得到服务器的返回结果

14:39.300 --> 14:40.300
对吧

14:40.300 --> 14:41.300
得到一个一个的对象

14:41.300 --> 14:42.300
得到一个一个的对象

14:42.300 --> 14:44.300
我们来拿到这个对象

14:44.400 --> 14:45.400
它是异步的

14:45.400 --> 14:46.400
我们可以用Zin

14:47.400 --> 14:49.000
服务器的返回结果

14:49.000 --> 14:51.800
然后取出服务器的消息体

14:51.800 --> 14:53.000
响应体

14:53.000 --> 14:54.000
data

14:54.000 --> 14:56.700
然后再点Zin

14:56.700 --> 14:58.800
继续来得到服务器的data

14:58.800 --> 15:00.000
就数据

15:00.000 --> 15:01.200
我们把这个数据输出

15:01.200 --> 15:02.200
看一下

15:02.200 --> 15:04.000
把这个数据输出

15:04.000 --> 15:05.600
保存一下

15:05.600 --> 15:07.200
这里运行npnz

15:08.700 --> 15:09.200
对

15:10.500 --> 15:12.100
看一下服务器的返回结果

15:12.100 --> 15:13.800
能不能得到

15:13.900 --> 15:15.100
拿到了

15:15.100 --> 15:17.100
这是服务器的返回结果

15:17.100 --> 15:18.300
是一个数组

15:18.300 --> 15:20.700
数组里面装了一个一个的对象

15:20.700 --> 15:21.400
注意

15:21.400 --> 15:22.900
这些对象

15:22.900 --> 15:25.500
我们把它叫做平面对象

15:25.500 --> 15:27.100
什么叫平面对象

15:27.100 --> 15:29.300
叫做Paint Objects

15:29.300 --> 15:34.300
叫这个Paint Objects

15:34.300 --> 15:35.500
什么叫平面对象

15:35.500 --> 15:37.100
我们在书写单码的时候

15:37.100 --> 15:39.100
直接使用两个大扩号

15:39.100 --> 15:39.900
来书写的对象

15:39.900 --> 15:41.300
就是一个平面对象

15:41.300 --> 15:42.400
就这么简单

15:42.400 --> 15:43.600
直接通过两个大扩号

15:43.600 --> 15:44.600
来书写的对象

15:44.600 --> 15:46.300
比方说ID

15:46.300 --> 15:49.700
比方说first name

15:49.700 --> 15:50.400
通过这种方式

15:50.400 --> 15:51.400
来书写的对象

15:51.400 --> 15:52.800
就是平面对象

15:52.800 --> 15:55.500
我们通过远程的阿迦克斯请求

15:55.500 --> 15:56.600
来得到的对象

15:56.600 --> 15:59.100
其实就是一个平面对象

15:59.100 --> 16:01.600
那么拿到这个平面对象过后

16:01.600 --> 16:02.400
比方说

16:02.400 --> 16:03.800
咱们的系统里边

16:03.800 --> 16:05.300
还有一个内

16:05.300 --> 16:07.200
还有一个内

16:07.200 --> 16:10.700
这里我们写一个class

16:10.700 --> 16:12.200
user是user

16:12.200 --> 16:13.000
user

16:13.100 --> 16:15.800
对到他写一下

16:15.800 --> 16:16.700
他有这么一些属性

16:16.700 --> 16:18.400
ID number

16:18.400 --> 16:22.100
然后有first name

16:22.100 --> 16:23.900
然后是致富串

16:23.900 --> 16:27.900
然后是last name

16:27.900 --> 16:29.100
致富串

16:29.100 --> 16:32.000
然后还有什么A级

16:32.000 --> 16:33.400
是number

16:33.400 --> 16:34.700
有这么一些属性

16:34.700 --> 16:36.800
那你看跟这个对象是不对应的

16:36.800 --> 16:37.400
对吧

16:37.400 --> 16:39.300
那么他这里面还有一些方法

16:39.300 --> 16:41.100
他这个文档里面也说到了

16:41.100 --> 16:41.700
他这里面

16:41.700 --> 16:43.400
还有可能会出现一些方法

16:43.400 --> 16:45.700
比方说get name这个方法

16:45.700 --> 16:46.800
还有这个方法

16:46.800 --> 16:47.900
is adult

16:47.900 --> 16:49.100
是不是成年人

16:49.100 --> 16:51.200
有这么两个方法

16:51.200 --> 16:52.400
好看一下

16:52.400 --> 16:53.700
get name

16:53.700 --> 16:55.100
是不是

16:55.100 --> 16:57.200
是不是得到他的全名

16:57.200 --> 16:57.900
first name

16:57.900 --> 16:59.700
拼接上那是name

16:59.700 --> 17:00.900
然后这个函数呢

17:00.900 --> 17:03.700
这个方法是判断得到一个布尔

17:03.700 --> 17:05.900
就是他是不是成年人

17:05.900 --> 17:07.500
有这么两个方法

17:07.500 --> 17:07.900
好

17:07.900 --> 17:10.900
那么现在问大家一个问题

17:11.000 --> 17:13.200
我这里拿到这个对象之后

17:13.200 --> 17:14.800
拿到这个对象之后

17:14.800 --> 17:16.400
我可以循环他对吧

17:16.400 --> 17:17.500
可以循环

17:17.500 --> 17:18.700
他是一个用户的宿主

17:18.700 --> 17:19.300
对吧

17:19.300 --> 17:20.500
他是一个用户的宿主

17:20.500 --> 17:21.800
我可以循环他

17:21.800 --> 17:24.500
好进行for all 循环

17:24.500 --> 17:27.600
循环这个宿主

17:27.600 --> 17:29.200
他这里肯定是一个用户的

17:29.200 --> 17:31.300
用户的用户的宿主

17:31.300 --> 17:31.800
对吧

17:31.800 --> 17:33.300
我们之前看到了看到结果了

17:33.300 --> 17:34.400
是一个用户的宿主

17:34.400 --> 17:35.500
循环他

17:35.500 --> 17:37.200
那么请问大家一个问题

17:37.200 --> 17:38.800
我这里能不能通过

17:39.000 --> 17:40.700
丢去调用get name

17:41.400 --> 17:42.200
你觉得能不能

17:43.200 --> 17:44.800
肯定是不行

17:44.800 --> 17:45.800
对吧

17:45.800 --> 17:47.500
我们服务器返回的对象里面

17:47.500 --> 17:49.300
哪有这个属性啊

17:49.300 --> 17:50.200
哪有这个get name

17:50.200 --> 17:50.900
这个函数啊

17:50.900 --> 17:52.100
你看他爆错了

17:52.100 --> 17:53.700
他根本没有这个东西

17:53.700 --> 17:54.700
服务器返回的东西

17:54.700 --> 17:56.200
那就是这个玩意

17:56.200 --> 17:57.100
就是这个玩意

17:57.100 --> 17:58.300
他没有这么get name

17:58.300 --> 17:59.000
这个函数

17:59.000 --> 17:59.700
没有的

17:59.700 --> 18:00.900
他是个品面对象

18:00.900 --> 18:01.900
只有数据

18:01.900 --> 18:03.000
不存在方法

18:04.100 --> 18:04.300
好

18:04.300 --> 18:06.300
那么这个时候怎么办呢

18:06.300 --> 18:07.700
比方说我们这里啊

18:07.700 --> 18:09.700
我肯能够百分之百确定

18:09.700 --> 18:11.400
他得到了就是用户对象

18:11.400 --> 18:11.800
因此呢

18:11.800 --> 18:13.700
我们甚至还可以在这里进行约束

18:14.600 --> 18:15.500
在这里约束一下

18:15.500 --> 18:17.200
这个U2是什么类型呢

18:17.200 --> 18:19.300
是一个用户对象的宿主

18:19.300 --> 18:20.900
是一个用户对象的宿主

18:20.900 --> 18:22.900
那么这样子以约束的看一下

18:22.900 --> 18:25.400
我这里有点get name

18:25.400 --> 18:27.200
他是不是可以调用了

18:27.200 --> 18:29.800
但是运行出来真的能调用吗

18:29.800 --> 18:30.800
你想一想

18:30.800 --> 18:33.300
运行出来真的能调用吗

18:33.300 --> 18:35.000
是不是还是不行

18:35.000 --> 18:36.900
你不是说你在编译的时候

18:36.900 --> 18:38.000
告诉ts

18:38.800 --> 18:39.700
他是一个用户对象

18:39.700 --> 18:41.200
他就真的是一个用户对象了

18:41.200 --> 18:42.600
没有那么神奇

18:42.600 --> 18:44.800
ts是不参与运行的

18:44.800 --> 18:46.600
在运行出来之后呢

18:46.600 --> 18:48.100
他也就是一个品面对象

18:49.200 --> 18:49.600
好

18:49.600 --> 18:51.700
如果这个时候

18:51.700 --> 18:53.600
我希望把这个用户

18:53.600 --> 18:56.800
把这个品面对象真真正正的

18:56.800 --> 18:58.800
转换成一个用户的对象

18:59.600 --> 19:01.400
就需要使用这个库

19:01.400 --> 19:03.600
这个库就来做这么个事

19:03.600 --> 19:05.200
他可以把一个品面对象

19:05.200 --> 19:07.200
转换成一个内的对象

19:07.200 --> 19:09.000
因为内里边还有一些方法

19:09.000 --> 19:10.400
还有一些成员

19:10.400 --> 19:11.600
所以说我们需要

19:11.600 --> 19:14.500
有的时候需要完成这么一个转换

19:15.500 --> 19:16.000
因此呢

19:16.000 --> 19:17.400
这里怎么完成呢

19:17.400 --> 19:23.920
你首先要安装这个库

19:23.920 --> 19:25.120
安装那个库啊

19:25.120 --> 19:29.920
首先用ya add plus transformer

19:29.920 --> 19:30.820
transformer

19:30.820 --> 19:31.720
transformer怎么意思

19:31.720 --> 19:32.520
就变形

19:32.520 --> 19:33.520
变化

19:33.520 --> 19:35.320
transformer就是变化者

19:35.320 --> 19:36.920
安装这么一个库

19:36.920 --> 19:39.020
好安装完成之后啊

19:39.020 --> 19:41.520
这个库同样的啊

19:41.520 --> 19:43.120
同样的他要依赖这个

19:43.120 --> 19:44.320
reflag 整个铁套

19:44.320 --> 19:45.520
只不过我们只不过呢

19:45.520 --> 19:46.920
我们现在还没有去使用

19:46.920 --> 19:48.020
他的装饰器

19:48.020 --> 19:49.120
还没有去使用而已

19:50.220 --> 19:52.420
好现在我们在这里

19:52.420 --> 19:53.720
就可以使用一个函数

19:53.720 --> 19:54.820
来完成转换了

19:54.820 --> 19:56.420
非常非常简单

19:56.420 --> 19:57.420
这个函数怎么写呢

20:00.020 --> 20:01.420
得到一个用户

20:01.420 --> 20:04.420
就是叫做plane plane

20:04.420 --> 20:05.620
这又没有智能提示

20:05.620 --> 20:07.120
我这里导致吧

20:07.120 --> 20:10.520
input from

20:10.520 --> 20:12.720
这个是class transformer

20:12.720 --> 20:13.820
他里边提供了一个函数

20:13.820 --> 20:16.620
叫做plane to class

20:16.620 --> 20:18.720
把一个平面对象

20:18.720 --> 20:20.820
转换成一个内的对象

20:20.820 --> 20:22.420
就这么简单

20:22.420 --> 20:23.320
好我们来试一下

20:24.520 --> 20:26.020
plane to class

20:27.420 --> 20:28.820
好第一个参数

20:28.820 --> 20:29.420
第一个参数

20:29.420 --> 20:31.920
你指的是你要转换的内

20:31.920 --> 20:33.720
转换成什么内的对象

20:34.720 --> 20:36.720
我要转换成优热的对象

20:36.720 --> 20:38.120
好第二个参数

20:38.120 --> 20:40.020
就是你的平面对象

20:40.020 --> 20:41.920
一般我你的平面对象告诉我

20:41.920 --> 20:43.420
平面对象就是这个什么

20:43.420 --> 20:44.720
就是个u

20:44.720 --> 20:47.540
就是个u

20:47.540 --> 20:49.040
好这样子一转换之后呢

20:49.040 --> 20:51.640
我们用鼠标指的这个优热看一下

20:51.640 --> 20:54.340
你看他推断出来是优热

20:54.340 --> 20:56.040
是一个用户对象的

20:56.040 --> 20:59.540
并且这里是真真正正的用户对象

20:59.540 --> 21:01.140
而不是一个平面对象的

21:01.140 --> 21:02.740
他其实这个u啊

21:02.740 --> 21:04.640
他实际上是一个平面对象

21:04.640 --> 21:06.340
我们现在已经把个平面对象呢

21:06.340 --> 21:09.140
转换成真正的用户对象了

21:09.140 --> 21:11.240
好我们现在再去输出这个user

21:11.240 --> 21:12.240
get a name

21:12.240 --> 21:15.640
看一下能不能输出了npm

21:17.440 --> 21:20.280
看一下啊

21:20.280 --> 21:24.180
你看他这个函数已经有这个函数了

21:24.180 --> 21:25.280
不仅有这个函数

21:25.280 --> 21:27.480
还有了这个内里边的

21:27.480 --> 21:29.180
ease adult

21:29.180 --> 21:30.480
运行实态

21:30.480 --> 21:33.480
我们也可以把它转换成那个对象了

21:34.480 --> 21:35.380
force true

21:35.380 --> 21:36.580
只有第二个是成年人

21:36.580 --> 21:37.780
对吧

21:37.780 --> 21:39.080
我们通过这种方式呢

21:39.080 --> 21:40.980
来完成平面对象

21:40.980 --> 21:44.280
对什么内的对象的转换

21:44.280 --> 21:44.780
啊当然了

21:44.780 --> 21:46.280
他可以转换一个对象

21:46.280 --> 21:47.680
也可以转换一个对象的数组

21:47.680 --> 21:48.880
也是可以的啊

21:48.880 --> 21:50.080
比方说这里啊

21:50.080 --> 21:51.880
比方说我这里不进行限制啊

21:51.880 --> 21:52.680
不进行限制

21:52.680 --> 21:53.780
我们在这里

21:53.780 --> 21:55.880
重新给这个u是负责

21:55.880 --> 21:58.680
play to class

21:58.680 --> 21:59.380
转换用户

21:59.380 --> 22:00.680
把它转换用户的对象

22:00.680 --> 22:02.280
给他一个数组啊

22:02.280 --> 22:03.680
也可以给他一个数组

22:03.680 --> 22:05.280
那么比方说不给他负责啊

22:05.280 --> 22:05.980
不给他负责

22:05.980 --> 22:07.580
不给他进行约束

22:07.580 --> 22:08.980
他就是个平面对象

22:08.980 --> 22:09.980
然后把它转换的数组

22:09.980 --> 22:10.380
你看

22:11.980 --> 22:13.480
这样转换之后啊

22:13.480 --> 22:14.680
这样转换之后

22:14.680 --> 22:16.380
那么返回的是怎么了

22:16.380 --> 22:18.080
返回的是一个用户的数组

22:18.080 --> 22:18.880
看没

22:18.880 --> 22:20.480
返回的是一个用户的数组

22:20.480 --> 22:20.580
好

22:20.580 --> 22:22.780
那你这里可以给他

22:22.780 --> 22:24.280
用个新的辨量吧

22:24.280 --> 22:25.680
us

22:25.680 --> 22:27.680
你看这个新的辨量

22:27.680 --> 22:29.380
就是一个用户的数组

22:29.380 --> 22:29.880
好

22:29.880 --> 22:30.680
那么这里

22:30.780 --> 22:31.780
我们去循环这个数组

22:33.680 --> 22:34.080
u

22:35.080 --> 22:35.380
u

22:36.280 --> 22:36.980
你看这样子

22:36.980 --> 22:40.180
不仅是内形检查没有出问题

22:40.180 --> 22:41.480
不仅是内形检查不出问题

22:41.480 --> 22:44.080
而且运行的过程中也不出问题

22:44.080 --> 22:44.680
明白了

22:44.680 --> 22:45.980
是用通过这种方式

22:45.980 --> 22:48.180
可以把一个平面对象

22:48.180 --> 22:50.180
转换成内的对象

22:51.280 --> 22:52.180
不仅如此

22:52.180 --> 22:53.680
他在转换的时候呢

22:53.680 --> 22:55.880
还会给你帮你出去做一些

22:55.880 --> 22:58.280
内形的内形的转换

22:58.280 --> 22:58.880
比方说

22:59.880 --> 23:01.280
这个服务器的地址呢

23:01.280 --> 23:02.780
我稍微改一下啊

23:02.780 --> 23:03.480
稍微改一下

23:03.480 --> 23:05.280
比方说这个年龄啊

23:05.280 --> 23:06.380
服务器那边啊

23:06.380 --> 23:07.780
假设返回的是

23:08.580 --> 23:09.880
假设返回的是

23:09.880 --> 23:10.980
我们重新来一个啊

23:11.780 --> 23:12.680
creation留节省

23:14.880 --> 23:17.680
重新写一个服务器那边年龄这里呢

23:17.680 --> 23:19.680
返回的是一个制服串啊

23:20.780 --> 23:23.080
年龄这里返回的是一个制服串

23:23.080 --> 23:23.480
但是呢

23:23.480 --> 23:26.780
我们清楚的知道他是一个数字啊

23:26.780 --> 23:28.180
比方说服务器那边

23:28.280 --> 23:29.580
他写的是一个制服串

23:29.580 --> 23:31.380
但是我们知道他肯定是一个数字

23:31.380 --> 23:32.180
希望呢

23:32.180 --> 23:33.980
把它转换到对象里边来了

23:33.980 --> 23:35.980
他把它变成数字啊

23:35.980 --> 23:37.380
比方说有这么一个要求

23:37.380 --> 23:38.880
好现在呢我们保存一下啊

23:40.480 --> 23:42.180
请我看一下请求地址

23:42.180 --> 23:43.280
就请求这个地址

23:44.980 --> 23:46.980
好我们请求这个地址啊

23:46.980 --> 23:47.980
复制一下

23:47.980 --> 23:48.980
然后呢

23:48.980 --> 23:50.880
我们这里去请求这个地址

23:50.880 --> 23:51.580
新的地址

23:52.780 --> 23:54.180
然后我们这里看一下

23:54.180 --> 23:55.680
用户转换之后啊

23:55.680 --> 23:57.080
目前转换之后

23:57.080 --> 23:58.280
转换他内的对象之后

23:58.780 --> 23:59.080
Type

24:00.380 --> 24:02.580
U点A级

24:02.580 --> 24:04.480
然后再把U点A级输出

24:04.480 --> 24:06.280
看一下用户的年龄

24:06.280 --> 24:07.280
是不是一个制服串

24:08.380 --> 24:08.680
你看

24:09.380 --> 24:11.180
虽然我们得到了正确的数据

24:11.180 --> 24:11.880
但是呢

24:11.880 --> 24:12.880
他是一个制服串

24:13.680 --> 24:14.680
好在这个时候呢

24:14.680 --> 24:15.580
有同学家问了

24:16.580 --> 24:18.380
哎不是不对啊

24:18.380 --> 24:19.480
ts里边

24:20.280 --> 24:21.580
ts里边

24:21.580 --> 24:23.780
他不是有内形元素吗

24:23.780 --> 24:24.680
内形的元素

24:24.680 --> 24:26.480
他他是一个数字啊

24:26.480 --> 24:28.180
但是你这里拿到的是一个制服串

24:28.180 --> 24:30.380
怎么会怎么可能会出现这种情况呢

24:30.980 --> 24:31.880
那你想想为什么

24:33.780 --> 24:36.480
因为ts的内形检查

24:36.480 --> 24:38.580
只是在编译时

24:39.280 --> 24:41.480
我们写代码的时候有内形检查

24:41.780 --> 24:42.680
他这个时候还

24:42.680 --> 24:44.580
写代码的时候都还认为他是个Lumber

24:44.980 --> 24:47.280
但是真正的运行出来之后

24:47.280 --> 24:48.480
还有没有内形检查

24:48.880 --> 24:49.680
早就没了

24:49.680 --> 24:51.480
那个时候是纯粹的GS代码

24:51.980 --> 24:53.780
所以说在运行的时代下面

24:53.880 --> 24:55.780
我们是得不到那个内形检查的

24:56.880 --> 24:57.580
而且呢

24:57.580 --> 24:59.080
这个元数据啊

24:59.080 --> 25:00.980
就是就是这个这个库啊

25:00.980 --> 25:02.280
他也不知道你这个东西

25:02.280 --> 25:03.380
就在运行的过程中

25:03.380 --> 25:06.180
他也不知道你这个玩意儿就是一个数字

25:06.280 --> 25:07.180
他也不知道

25:08.180 --> 25:09.780
那么这个时候怎么办呢

25:10.180 --> 25:11.180
这个时候咋办呢

25:11.580 --> 25:15.680
你就必须要通过元数据来告诉他

25:15.780 --> 25:18.380
这个玩意儿就是一个数字啊

25:18.380 --> 25:19.580
就是一个数字

25:19.580 --> 25:22.680
你转换的时候麻烦你把它转换成数字

25:23.280 --> 25:24.980
你必须要通过元数据告诉他

25:24.980 --> 25:28.280
因为只有元数据才能在运行时出现

25:29.280 --> 25:31.680
只有元数据才出现在运行的时代

25:31.880 --> 25:33.280
如果是呃

25:33.280 --> 25:34.780
像这些内形变数

25:35.080 --> 25:37.280
他运行的时候是消失的是没有的

25:37.880 --> 25:38.280
因此呢

25:38.280 --> 25:40.880
这里可以通过元数据来告诉他

25:40.880 --> 25:42.280
这个地方就是一个数字

25:42.280 --> 25:43.380
你转换的时候

25:43.680 --> 25:44.980
帮我把它转换成数字

25:45.880 --> 25:46.780
好我们来告诉他

25:47.080 --> 25:48.480
好怎么告诉他呢

25:48.580 --> 25:50.380
其实就是加一个啊

25:50.880 --> 25:53.680
就是装饰器啊装饰器

25:53.780 --> 25:55.380
这装饰器的名字叫做type

25:56.380 --> 25:57.680
啊type装饰器

25:58.580 --> 26:00.180
啊你看搞定了啊type

26:00.780 --> 26:03.080
这个装饰器呢是一个函数啊

26:03.180 --> 26:04.880
这个函数返回一个装饰器

26:05.280 --> 26:06.580
就是他本身呢他不是装饰器

26:06.580 --> 26:07.880
他返回的是一个装饰器

26:08.280 --> 26:09.380
要用这个函数

26:09.380 --> 26:10.980
这个函数里面咋写呢

26:11.380 --> 26:14.080
写法了很简单啊写法很简单

26:14.480 --> 26:15.280
就这样子写

26:15.780 --> 26:16.680
那就这样子写

26:17.580 --> 26:19.680
传入的是啊传入的是啥

26:19.680 --> 26:21.680
传入的是一个函数

26:21.880 --> 26:24.380
这个函数的返回的返回的类型

26:24.780 --> 26:26.280
这个函数返回的类型

26:26.580 --> 26:27.080
就是

26:27.980 --> 26:29.580
表示运行的时候

26:29.880 --> 26:30.880
这个地方的类型

26:31.580 --> 26:33.580
啊就是这里写的代码呢

26:33.580 --> 26:35.280
他运行的时候是消失的啊

26:35.280 --> 26:36.280
是会消失的

26:36.580 --> 26:37.780
那么像这个代码呢

26:37.780 --> 26:39.280
实在会参与运行的

26:39.580 --> 26:41.580
给他附加一个元数据信息

26:41.680 --> 26:42.580
告诉这个

26:42.980 --> 26:44.680
告诉这个class transformer

26:44.880 --> 26:46.580
啊这个东西本来也是他提供的

26:46.880 --> 26:49.580
告诉他我这个地方的属性呢

26:49.980 --> 26:51.580
得到的类型呢是number

26:51.580 --> 26:52.880
注意这个n是大写的

26:53.080 --> 26:54.780
这里为什么不能写小写的n

26:55.180 --> 26:56.780
因为在gs代码里边

26:56.780 --> 26:57.980
这个东西是不存在的

26:58.380 --> 27:00.280
你gs代码什么时候写过这个玩意了

27:00.880 --> 27:02.480
为什么ts里面能写

27:02.680 --> 27:04.680
因为是ts给你加的新语法

27:04.880 --> 27:07.280
这些语法呢会在编译的时候消失

27:07.480 --> 27:08.680
编译过后就没有了

27:09.080 --> 27:11.780
在gs里面啊这个number

27:11.780 --> 27:13.480
大写的n表示构造函数

27:13.680 --> 27:15.380
一个数字的构造函数

27:16.380 --> 27:17.380
好写好了之后呢

27:17.380 --> 27:18.480
我们再保存啊

27:18.580 --> 27:20.180
我们再看看他重新运行

27:20.280 --> 27:22.180
npn的状态重新运行

27:23.080 --> 27:23.880
来看一下

27:24.280 --> 27:25.980
现在能不能完成转换看一下啊

27:26.480 --> 27:27.880
你看现在是不是转换过来了

27:28.080 --> 27:28.980
转换成number了

27:29.680 --> 27:32.280
啊也就是说我们在转换的时候呢

27:32.280 --> 27:34.680
可以跟手动的去指定一下

27:34.880 --> 27:36.280
某些属性的类型

27:36.380 --> 27:37.480
那么他在转换的时候呢

27:37.480 --> 27:39.480
会按照这个类型来进行转换

27:40.180 --> 27:43.080
好这是关于这个库啊

27:43.580 --> 27:44.780
transformer这个库

27:44.980 --> 27:46.080
他其实也蛮有用的

27:46.080 --> 27:47.780
我们后边去做一些

27:48.380 --> 27:50.080
做特别是做服务器开发啊

27:50.080 --> 27:52.980
做露的结石搭建服务器的时候呢

27:53.380 --> 27:55.280
这个库呢用的还蛮多的啊

27:55.980 --> 27:57.380
还非常好用

27:58.180 --> 27:59.080
啊因此呢

27:59.180 --> 28:00.680
这个库呢有了这个库过后啊

28:00.680 --> 28:02.180
我们就可以把一些品面对象

28:02.180 --> 28:04.580
转换成我们希望的类的对象了

28:04.780 --> 28:05.980
那么你想啊

28:06.380 --> 28:07.780
在配合之前的

28:08.180 --> 28:09.680
在配合之前的验证

28:09.880 --> 28:11.580
你想一想如果是一个品面对象

28:11.580 --> 28:12.480
能不能验证

28:12.980 --> 28:13.880
肯定是不能验证

28:13.880 --> 28:15.180
他必须要是这个类的对象

28:15.180 --> 28:16.480
才能进行验证对吧

28:16.580 --> 28:17.680
那么我们拿到这个

28:17.680 --> 28:19.280
把它转换成类的对象之后

28:19.280 --> 28:21.180
我们还可以触划他的验证功了

28:21.380 --> 28:22.480
就可以配合起来使用

28:22.480 --> 28:23.380
就非常的方便

28:24.080 --> 28:25.980
啊给大家先介绍这两个库啊

28:25.980 --> 28:27.280
这两个库后面我们做

28:27.580 --> 28:29.380
项目实战的时候都会用的

28:29.680 --> 28:32.680
class validator和class transformer

28:33.680 --> 28:36.280
ok啊虽然我们没有对这两个库做

28:36.480 --> 28:37.880
过多的去讲解

28:37.880 --> 28:38.580
因为

28:38.980 --> 28:40.480
他里面的东西实在太多了

28:40.480 --> 28:41.480
实在太多了

28:41.580 --> 28:43.280
有兴趣的同学呢可以去看一下

28:43.480 --> 28:45.380
但是他基本使用也就这么一些

28:45.580 --> 28:46.780
基本使用就这么一些

28:47.280 --> 28:48.580
如果以后开发的时候

28:48.580 --> 28:49.980
要用到这两个库的时候

28:50.080 --> 28:50.880
大胆去用

28:51.080 --> 28:53.280
大胆的去用这两个库做的都是不错的

28:54.280 --> 28:56.380
用的过程中如果出现了什么问题的话

28:56.380 --> 28:58.080
可以去参与一下他的官方文档

28:58.780 --> 28:59.480
ok啊

28:59.680 --> 29:00.980
那么这两节课

29:00.980 --> 29:02.280
我们这节课和上节课呢

29:02.280 --> 29:04.580
都介绍了一些第三方的库

29:04.980 --> 29:06.080
好那么下节课呢

29:06.080 --> 29:07.380
我们来继续来学习

29:07.780 --> 29:09.380
装饰器的一些东西

29:09.780 --> 29:11.380
好那么这一课呢到这里了啊

29:11.680 --> 29:12.180
拜拜

