WEBVTT

00:00.820 --> 00:08.820
这些课呢 我们利用之前学过的内装饰器以及成员装饰器来做这么一个练习

00:08.820 --> 00:18.820
做什么练习呢 我们来做一个内和属性的描述装饰器

00:18.820 --> 00:21.820
这啥意思呢 我解释一下啊

00:21.820 --> 00:24.820
就是说有的时候呢 我书写了一个内

00:24.820 --> 00:28.820
比方说我这里书写了一个内 一个用户内吧

00:28.820 --> 00:36.820
用户内里边有一些属性 比方说用户的帐号 用户的密码 用户的密码

00:36.820 --> 00:43.820
我一会呢 我希望呢 我能够输出一个用户 把这个用户的信息呢打印出来

00:43.820 --> 00:48.820
那么到时候呢 我会提供一个函数啊 比方说我创建了一个用户之后呢

00:48.820 --> 00:52.820
创建一个用户之后 我希望把这个用户的信息打印出来print

00:52.820 --> 00:57.820
我希望有这么一个函数啊 这个函数我现在还没有写啊 还没有写

00:57.820 --> 01:03.820
不要说print OB界 打印一个对象 然后呢 打一个对象传进去

01:03.820 --> 01:11.820
这个函数能够帮助我们用一种格式非常友好的方式呢 把这个对象打印出来

01:11.820 --> 01:16.820
那么打印的时候呢 我希望打印出这么一种格式啊 比方说这个用户内

01:16.820 --> 01:21.820
我希望他打印出这么一种格式 就是 这是一个用户 用户

01:21.820 --> 01:28.820
然后呢 他的账号 账号是啥啥啥 就属性值 然后密码 密码是啥啥啥

01:28.820 --> 01:34.820
我希望用这种格式把他打印出来 那么 如果要完成这样的格式的话

01:34.820 --> 01:40.820
我们就有个前提条件 什么前提条件呢 我就希望呢 需要把这个用户啊

01:40.820 --> 01:46.820
给这个用户内呢 给他一些附加的信息 因为现在这个程序呢

01:46.820 --> 01:51.820
他并不知道 这个内他的名字叫做用户 他并不知道 我希望通过

01:51.820 --> 01:57.820
就是装饰器给他附加这么一个信息 告诉他这是一个用户

01:57.820 --> 02:05.820
那么于是呢 我会在上面写一个装饰器 比方说这里 我给大家描述 class descriptor

02:05.820 --> 02:11.820
描述 这是一个用户 这是一个用户 那么这里呢

02:11.820 --> 02:18.820
我希望也是一样的啊 希望有一个属性的装饰器来描述 这是一个这是一个

02:19.820 --> 02:25.820
账号 给他一些附加信息 然后这里呢 我希望用个装饰器

02:25.820 --> 02:31.820
descript然后这里是密码 就是我到时候完成这个开发之后啊

02:31.820 --> 02:36.820
我们要实现的功能就是这样的功能啊 通过这些装饰器来描述之后呢

02:36.820 --> 02:39.820
我们就可以通过这个函数 把这个用户打印出来

02:39.820 --> 02:43.820
那就非常的非常的舒服了以后 我要打印一个对象的话

02:43.820 --> 02:47.820
我只需要把它装饰器给他加上 其他的事情我不用管了

02:47.820 --> 02:51.820
也就是说我们现在要开发什么装饰器 开发这两个装饰器

02:51.820 --> 02:56.820
然后外加一个这个函数 我们要把开发出来

02:56.820 --> 02:59.820
好 开发出来过后就通用了啊 我们只需要开发一次

02:59.820 --> 03:03.820
不管他有多复杂 我们只需要做这么一次开发

03:03.820 --> 03:07.820
开发之后所有的内都可以通过这样的方式来进行描述

03:07.820 --> 03:10.820
然后统一有一个打印方法 把它打印出来

03:10.820 --> 03:14.820
好 那么这个时候呢 我们 专门来建一个文件吧

03:14.820 --> 03:19.820
来写这些装饰器啊 比方说我们这个文件的名字就叫做descript

03:19.820 --> 03:24.820
啊 描述 专门描述内的信息啊 描述

03:24.820 --> 03:28.820
呃 就是属性的信息啊 通过这种方式

03:28.820 --> 03:31.820
呃 给他设置一些装饰器

03:31.820 --> 03:36.820
首先我们来写一个内装饰器啊 它的名字叫做class descriptor

03:36.820 --> 03:39.820
啊 这么一个装饰器 那么我们可以看到

03:39.820 --> 03:43.820
我希望到时候用的时候呢 是吧 它当成一个函数

03:43.820 --> 03:47.820
调用的方式 也就是说 这里应该是一个啥呢

03:47.820 --> 03:51.820
应该是一个装饰器的工厂

03:51.820 --> 03:55.820
你看我是在调用函数嘛 对吧 把函数的反回结果

03:55.820 --> 03:59.820
当成装饰器 因此呢 这里应该是一个装饰器工厂

03:59.820 --> 04:05.820
好 根据我们之前所学 我们这里呢 要实现这么一个装饰器

04:05.820 --> 04:12.820
export 啊 它导出一个函数啊 函数的名字叫做class descriptor

04:12.820 --> 04:17.820
啊 这个函数呢 由于它是修饰内的啊 它用来装饰内的

04:17.820 --> 04:20.820
因此它有几个参数 回忆一下

04:20.820 --> 04:23.820
如果要装饰一个内 它有几个参数的

04:23.820 --> 04:26.820
啊 有几个参数 是不是只有一个参数

04:26.820 --> 04:30.820
但是你不要忘记了 这里是一个装饰器的工厂

04:30.820 --> 04:35.820
这里是一个装饰器的工厂 不是说这个函数本身是装饰器

04:35.820 --> 04:40.820
而指的是这个函数的反回结果 是一个装饰器

04:40.820 --> 04:43.820
要理解清楚啊 它反回的结果 是一个装饰器

04:43.820 --> 04:48.820
反回的结果 target 就是我们的装饰的目标

04:48.820 --> 04:51.820
装饰的目标这个内啊 这个内

04:51.820 --> 04:54.820
OK 我们这里呢 给它修饰成为

04:54.820 --> 04:57.820
其实这里随便了啊 这里随便我们修饰成n里嘛

04:57.820 --> 05:00.820
或者把它修饰成一个内都可以啊 都可以

05:00.820 --> 05:03.820
我们把它修饰成一个方式 也行 也行

05:03.820 --> 05:07.820
总之呢 它是一个内 它会传一个内径来

05:07.820 --> 05:10.820
好 那么这个函数本身它有什么参数呢

05:10.820 --> 05:13.820
根据我们之前 希望的

05:13.820 --> 05:16.820
它有要传入一个制服串来告诉我这个内的意识

05:16.820 --> 05:19.820
表示的是用户

05:19.820 --> 05:22.820
因此我们现在只关注这个内啊 内装饰器

05:22.820 --> 05:25.820
有一个制服串的参数 表示这个内的信息

05:25.820 --> 05:28.820
OK 那么这个 这个地方呢 我们给它写上

05:28.820 --> 05:32.820
叫做

05:32.820 --> 05:35.820
descripted

05:35.820 --> 05:37.820
描述信息 是一个制服串

05:37.820 --> 05:40.820
好 我们就把这个内的装饰器就写好了

05:40.820 --> 05:43.820
它的格式至少写好了 对吧 好 我们这边

05:43.820 --> 05:46.820
导入啊 快速修复 导入

05:46.820 --> 05:49.820
导入进来看 这里就不报错了

05:49.820 --> 05:52.820
好 这个地方也是一样啊 属性的装饰器也是一样

05:52.820 --> 05:55.820
我希望呢 这里要导出一个函数

05:55.820 --> 05:58.820
把同样的道理啊 我们就直接写了

05:58.820 --> 06:01.820
这边 把这个名字复制过来

06:01.820 --> 06:04.820
这里呢 也需要给我一个描述

06:04.820 --> 06:07.820
这个属性是什么意思啊 要告诉

06:07.820 --> 06:10.820
然后呢 我返回一个装饰器

06:10.820 --> 06:13.820
属性的装饰器呢 我们之前写过对吧

06:13.820 --> 06:16.820
它这两个参数 第一个参数呢是

06:16.820 --> 06:19.820
如果它是一个 如果它是

06:19.820 --> 06:22.820
一个静态的属性的话 第一个参数是

06:22.820 --> 06:25.820
够早函数 如果它是一个实力的属性的话

06:25.820 --> 06:28.820
第一个参数是一个 什么呢 是一个

06:28.820 --> 06:31.820
圆形 对吧 好 第二个参数呢

06:31.820 --> 06:34.820
表示属性的名称 属性的名称

06:34.820 --> 06:37.820
或者叫做proper name 属性的名称是一个制服串

06:37.820 --> 06:40.820
好 这个属性的装饰器 我就写好了

06:40.820 --> 06:43.820
好 这边来啊 把它导入进来

06:44.820 --> 06:47.820
好 属性的装饰器也有了 那么最后呢

06:47.820 --> 06:50.820
最后就是打印一个对象 我们需要

06:50.820 --> 06:53.820
导出这么一个函数 好 最后我们导出一个

06:53.820 --> 06:56.820
函数 放个写 放个写

06:57.820 --> 07:00.820
叫做print print obj

07:01.820 --> 07:03.820
你告诉我一个对象啊 只要它

07:03.820 --> 07:05.820
是一个对象就行 我管它是什么对象

07:05.820 --> 07:07.820
我能 我能够把它打印出来

07:07.820 --> 07:09.820
我能够把对象的信息打印出来

07:09.820 --> 07:11.820
好 我就做这么一件事啊

07:12.820 --> 07:15.820
ok 那么这里呢 我们把它修复一下

07:15.820 --> 07:17.820
print obj

07:17.820 --> 07:19.820
看一下print obj

07:19.820 --> 07:21.820
把它写错了啊

07:21.820 --> 07:23.820
这里 导入进来

07:23.820 --> 07:26.820
好 我首先让这个代码不爆错

07:26.820 --> 07:28.820
让它不爆错

07:28.820 --> 07:31.820
好了 我们再说一次我最后希望做啥

07:31.820 --> 07:34.820
就是以后呢 我有了这些东西之后

07:34.820 --> 07:36.820
假设这些东西已经写好了

07:36.820 --> 07:38.820
写好了之后呢 我们要打印一个对象

07:38.820 --> 07:40.820
就非常非常方便了

07:40.820 --> 07:43.820
可以用装饰器来描述这些属性

07:43.820 --> 07:46.820
是什么含义 这个内是一个什么样的含义

07:46.820 --> 07:49.820
然后呢 只要描述清楚之后

07:49.820 --> 07:52.820
我到时候任何对象我都可以把它

07:52.820 --> 07:55.820
用这种格式把它打印出来

07:55.820 --> 07:57.820
以后呢 我们来测试一些东西的时候

07:57.820 --> 07:59.820
或者是我们要在控制台显示的时候

07:59.820 --> 08:01.820
看着就非常舒服了

08:01.820 --> 08:03.820
假设我们有这么一个功能啊

08:03.820 --> 08:05.820
好 那么接下来就是实现

08:05.820 --> 08:07.820
具体怎么去实现的问题

08:07.820 --> 08:10.820
比方说这个装饰器这个

08:10.820 --> 08:13.820
这个含书里边它返回了一个装饰器

08:13.820 --> 08:15.820
这个东西才是装饰器啊 要搞清楚

08:15.820 --> 08:18.820
这个呢只是产生装饰器的含书

08:18.820 --> 08:20.820
这个玩意儿才是装饰器

08:20.820 --> 08:21.820
我们首先要知道

08:21.820 --> 08:23.820
这个装饰器是啥时候运行的

08:23.820 --> 08:25.820
什么时候运行啊

08:25.820 --> 08:27.820
是不是内定也完了之后

08:27.820 --> 08:28.820
它就会运行

08:28.820 --> 08:30.820
就会运行这个装饰器的含书

08:30.820 --> 08:32.820
就会运行这个含书

08:32.820 --> 08:34.820
那么运行含书的时候呢

08:34.820 --> 08:36.820
它不是传了一个描述信息过来吗

08:36.820 --> 08:39.820
关于这个内是一个什么样的信息

08:39.820 --> 08:40.820
有哪些信息

08:40.820 --> 08:42.820
或是传的东西过来的吗

08:42.820 --> 08:44.820
那么我就可以把这个信息呢

08:44.820 --> 08:46.820
保存到哪呢

08:46.820 --> 08:49.820
比方说我们把这个信息保存到

08:49.820 --> 08:54.820
保存到该内的原形中

08:54.820 --> 08:56.820
好 我们可以把这个信息保存到

08:56.820 --> 08:58.820
该内的原形中

08:58.820 --> 09:00.820
好 我们这里呢就可以这样做

09:00.820 --> 09:02.820
Target

09:02.820 --> 09:04.820
Target是啥

09:04.820 --> 09:06.820
是不是这个内 对不对

09:06.820 --> 09:08.820
是这个内吧

09:08.820 --> 09:10.820
就是会把这个内传过来

09:10.820 --> 09:12.820
不管它装饰的是什么内都无所谓

09:12.820 --> 09:13.820
它总之是一个内

09:13.820 --> 09:15.820
它会把这个内传过来

09:15.820 --> 09:17.820
那么我们找到内的Prototype

09:17.820 --> 09:19.820
Prototype是啥意思

09:19.820 --> 09:20.820
说原形 对吧

09:20.820 --> 09:23.820
我们在这个原形里边

09:23.820 --> 09:24.820
在这个原形里边

09:24.820 --> 09:26.820
给它加一个属性

09:26.820 --> 09:28.820
这个属性的名字我给它写的

09:28.820 --> 09:29.820
比较特殊一点

09:29.820 --> 09:30.820
要写个特殊的名字

09:30.820 --> 09:32.820
比方说以多少开头吧

09:32.820 --> 09:33.820
以多少开头

09:33.820 --> 09:34.820
表示的是

09:34.820 --> 09:36.820
这是一个特殊的属性

09:36.820 --> 09:37.820
我给它动态加进去了

09:37.820 --> 09:39.820
那么这个属性的名字呢

09:39.820 --> 09:41.820
叫做比方说

09:50.820 --> 09:53.820
内的描述信息是什么呢

09:53.820 --> 09:54.820
我给它复制为啥呢

09:54.820 --> 09:56.820
就复制为这个植物串

09:56.820 --> 09:58.820
就复制为这个植物串

09:58.820 --> 10:00.820
你看一下我这样做了之后

10:00.820 --> 10:01.820
我这样子操作了之后

10:01.820 --> 10:03.820
有一个什么好处呢

10:03.820 --> 10:04.820
有个什么好处呢

10:04.820 --> 10:07.820
我们现在每一个对象里边

10:07.820 --> 10:09.820
每一个内的对象里边

10:09.820 --> 10:10.820
它都会由于

10:10.820 --> 10:12.820
它加到原形里边的属性

10:12.820 --> 10:15.820
因此每一个内的对象里边

10:15.820 --> 10:17.820
它都有这么一个属性了

10:17.820 --> 10:19.820
表示内的描述信息

10:19.820 --> 10:20.820
我们来试一下

10:20.820 --> 10:24.820
我们这里先直接输出

10:24.820 --> 10:25.820
直接输出

10:25.820 --> 10:27.820
我们在这个函数里面输出

10:27.820 --> 10:29.820
你看我把对象传进来了

10:29.820 --> 10:30.820
把对象传进来了

10:30.820 --> 10:32.820
我们到这个函数里边

10:32.820 --> 10:33.820
到这个函数里边

10:33.820 --> 10:34.820
打印出来

10:34.820 --> 10:36.820
这个对象的obj

10:36.820 --> 10:37.820
它的什么呢

10:37.820 --> 10:39.820
它的class

10:39.820 --> 10:40.820
descript

10:40.820 --> 10:42.820
打印出来它这个东西

10:42.820 --> 10:44.820
那么这里它要爆出

10:44.820 --> 10:45.820
因为Object里面

10:45.820 --> 10:46.820
它没有这个东西

10:46.820 --> 10:48.820
其实这里我们可以写成nd

10:48.820 --> 10:50.820
其实可以写成nd

10:50.820 --> 10:52.820
当然也可以手动的

10:52.820 --> 10:53.820
把它转换成nd

10:53.820 --> 10:54.820
都行

10:54.820 --> 10:57.820
现在我们来试一下

10:57.820 --> 10:59.820
看一下能不能正常的打印出来

11:00.820 --> 11:01.820
你看

11:01.820 --> 11:02.820
已经打印出来了

11:02.820 --> 11:03.820
对吧

11:03.820 --> 11:04.820
用户

11:04.820 --> 11:05.820
用户信息是不是打印出来了

11:05.820 --> 11:06.820
它描述为用户

11:06.820 --> 11:08.820
当时我们打印这个内的时候

11:08.820 --> 11:09.820
打印这个对象的时候

11:09.820 --> 11:10.820
我们就知道了

11:10.820 --> 11:11.820
这个对象里边

11:11.820 --> 11:14.820
它的内表示的是用户

11:14.820 --> 11:15.820
就输出出来了

11:15.820 --> 11:16.820
好

11:16.820 --> 11:18.820
我们来继续看

11:18.820 --> 11:20.820
然后是属性

11:20.820 --> 11:23.820
属性装饰器

11:23.820 --> 11:26.820
它内里边有很多很多的属性

11:26.820 --> 11:28.820
每一次给这些属性

11:28.820 --> 11:30.820
使用装饰器的话

11:30.820 --> 11:32.820
使用的是属性装饰器的话

11:32.820 --> 11:34.820
它都会运行这个函数

11:34.820 --> 11:36.820
都会运行这个函数

11:36.820 --> 11:38.820
那么属性里的

11:38.820 --> 11:39.820
内只有一个对吧

11:39.820 --> 11:40.820
内只有一个

11:40.820 --> 11:42.820
属性它有多个

11:42.820 --> 11:44.820
就同一个内里边

11:44.820 --> 11:46.820
它可能会包含多个属性

11:46.820 --> 11:47.820
那么这个时候

11:47.820 --> 11:49.820
我要保存哪些信息呢

11:49.820 --> 11:51.820
方便我们后边读取

11:51.820 --> 11:53.820
我们应该保存哪些信息呢

11:53.820 --> 11:54.820
我们可以把这种

11:54.820 --> 11:56.820
这么一种格式的数据

11:57.820 --> 11:59.820
把拉动格式的数据

11:59.820 --> 12:01.820
我们可以把这个数据

12:01.820 --> 12:03.820
每一个属性

12:03.820 --> 12:05.820
每一个属性的装饰器

12:05.820 --> 12:07.820
我都给它保存这么一个信息

12:07.820 --> 12:08.820
保存一个对象

12:08.820 --> 12:11.820
这个对象一个是属性的名字

12:11.820 --> 12:14.820
属性的名字是一个制服串

12:14.820 --> 12:16.820
然后属性的

12:16.820 --> 12:18.820
属性的什么

12:18.820 --> 12:20.820
属性的描述

12:20.820 --> 12:21.820
description

12:21.820 --> 12:23.820
也是一个制服串

12:23.820 --> 12:25.820
也是一个制服串

12:25.820 --> 12:26.820
把这样的格式

12:26.820 --> 12:28.820
一个对象保存进去

12:28.820 --> 12:30.820
把这个对象保存进去

12:30.820 --> 12:31.820
那你想啊

12:31.820 --> 12:33.820
我们这个内里边

12:33.820 --> 12:35.820
它有多个属性

12:35.820 --> 12:36.820
那也就是说

12:36.820 --> 12:37.820
一个属性的

12:37.820 --> 12:39.820
我就有这么一个对象

12:39.820 --> 12:40.820
就对应这么一个对象

12:40.820 --> 12:41.820
一个属性

12:41.820 --> 12:42.820
对应这么一个对象

12:42.820 --> 12:43.820
这属性名

12:43.820 --> 12:45.820
这是属性的描述信息

12:45.820 --> 12:46.820
描述信息在哪

12:46.820 --> 12:47.820
是不是在这

12:47.820 --> 12:48.820
对不对

12:48.820 --> 12:50.820
它是通过制服串

12:50.820 --> 12:52.820
把这个描述信息

12:52.820 --> 12:54.820
传过来了

12:54.820 --> 12:55.820
描述信息

12:55.820 --> 12:56.820
我们可以得到

12:56.820 --> 12:57.820
属性名

12:57.820 --> 12:58.820
可不可以得到

12:58.820 --> 13:00.820
属性名

13:00.820 --> 13:02.820
这里是修饰的属性

13:02.820 --> 13:04.820
那么它运行装饰期的时候

13:04.820 --> 13:07.820
它就会把属性名字传过来

13:07.820 --> 13:08.820
属性名

13:08.820 --> 13:10.820
我们也能得到

13:10.820 --> 13:11.820
我们知道属性名

13:11.820 --> 13:13.820
也知道属性的描述信息

13:13.820 --> 13:14.820
有些同学说

13:14.820 --> 13:17.820
那这里要不要保存属性的值

13:17.820 --> 13:19.820
那就想一想逻辑

13:19.820 --> 13:21.820
这里能不能保存属性的值

13:21.820 --> 13:22.820
首先你说

13:22.820 --> 13:24.820
过去到属性的值

13:24.820 --> 13:26.820
想一想

13:26.820 --> 13:30.820
这个地方能不能保存属性值呢

13:30.820 --> 13:32.820
肯定是不可能的

13:32.820 --> 13:34.820
为什么呢

13:34.820 --> 13:37.820
如果我不创建对象

13:37.820 --> 13:39.820
有没有属性值

13:39.820 --> 13:40.820
这些属性值是

13:40.820 --> 13:42.820
附着在对象上面的

13:42.820 --> 13:43.820
我现在可能一个对象

13:43.820 --> 13:44.820
都没有产生

13:44.820 --> 13:45.820
它有没有属性值

13:45.820 --> 13:46.820
没有属性

13:46.820 --> 13:47.820
没有对象的时候

13:47.820 --> 13:50.820
这个装饰器会不会运行

13:50.820 --> 13:51.820
装饰器会不会运行

13:51.820 --> 13:52.820
想一想

13:52.820 --> 13:54.820
我们之前学过的愈法知识

13:54.820 --> 13:55.820
会运行

13:55.820 --> 13:56.820
对吧

13:56.820 --> 13:59.820
这些装饰器跟对象没有任何关系

13:59.820 --> 14:01.820
它是定义好内之后

14:01.820 --> 14:03.820
马上就会运行这些装饰器

14:03.820 --> 14:05.820
所以说运行装饰器的时候

14:05.820 --> 14:06.820
哪有对象

14:06.820 --> 14:07.820
都没有对象

14:07.820 --> 14:08.820
对象都还没有出来

14:08.820 --> 14:10.820
而且将来会出来哪些对象

14:10.820 --> 14:11.820
你也不知道

14:11.820 --> 14:12.820
你也不知道

14:12.820 --> 14:13.820
所以说呢

14:13.820 --> 14:14.820
这里呢

14:14.820 --> 14:15.820
实际上是

14:15.820 --> 14:17.820
没有属性值的

14:17.820 --> 14:18.820
没有属性值

14:18.820 --> 14:20.820
OK

14:20.820 --> 14:21.820
那么这里呢

14:21.820 --> 14:23.820
我们得到了属性名

14:23.820 --> 14:24.820
得到了属性的描述

14:24.820 --> 14:25.820
好

14:25.820 --> 14:27.820
我把它保存到哪呢

14:27.820 --> 14:29.820
还是

14:29.820 --> 14:33.820
把所有的属性

14:33.820 --> 14:36.820
信息保存到

14:36.820 --> 14:39.820
该类的圆形中

14:39.820 --> 14:40.820
我们在圆形中

14:40.820 --> 14:42.820
可以建立这么一个数组

14:42.820 --> 14:43.820
这个数组呢

14:43.820 --> 14:46.820
就可以保存各种各样的信息了

14:46.820 --> 14:48.820
就可以保存各样

14:48.820 --> 14:50.820
属性的信息

14:50.820 --> 14:51.820
好

14:51.820 --> 14:52.820
首先呢

14:52.820 --> 14:53.820
我们

14:53.820 --> 14:54.820
我也不知道这个函数

14:54.820 --> 14:56.820
它运行的时候

14:56.820 --> 14:57.820
它圆形上

14:57.820 --> 14:58.820
有没有这个数组

14:58.820 --> 14:59.820
我也不知道

14:59.820 --> 15:01.820
所以说我先按判断

15:01.820 --> 15:03.820
首先判断圆形上边

15:03.820 --> 15:05.820
有没有这个数组

15:05.820 --> 15:07.820
有没有这个属性的数组

15:07.820 --> 15:08.820
怎么来判断呢

15:08.820 --> 15:10.820
我们这个参数

15:10.820 --> 15:13.820
这是属性的装饰器

15:13.820 --> 15:14.820
因此呢

15:14.820 --> 15:15.820
这个参数呢

15:15.820 --> 15:17.820
它里边

15:18.820 --> 15:19.820
它是不是就是

15:19.820 --> 15:22.820
这个类的圆形

15:22.820 --> 15:23.820
对不对

15:23.820 --> 15:25.820
我们之前讲属性装饰器的时候说过

15:25.820 --> 15:27.820
这个玩意就是类的圆形

15:27.820 --> 15:28.820
因此呢

15:28.820 --> 15:29.820
我要判断的是啥

15:29.820 --> 15:31.820
判断的是这个圆形里边

15:31.820 --> 15:33.820
有没有这个属性

15:33.820 --> 15:34.820
给它取一个属性名字吧

15:34.820 --> 15:35.820
比方说

15:35.820 --> 15:38.820
propdescriptions

15:38.820 --> 15:39.820
加上个s

15:39.820 --> 15:41.820
因为它属性有很多

15:41.820 --> 15:42.820
看这个类的圆形上面

15:42.820 --> 15:44.820
有没有这个属性

15:44.820 --> 15:46.820
如果有的话

15:46.820 --> 15:49.820
如果有这个属性的话

15:49.820 --> 15:50.820
那么

15:50.820 --> 15:52.820
我就认为它是一个数组

15:52.820 --> 15:54.820
因为之前肯定给它付过值

15:54.820 --> 15:56.820
如果没有这个属性的话

15:56.820 --> 15:57.820
我就给它付一个值

15:57.820 --> 15:59.820
付一个什么值呢

15:59.820 --> 16:02.820
给它付值为一个数组

16:02.820 --> 16:03.820
如果没有这个属性的话

16:03.820 --> 16:05.820
我就给它付值为一个数组

16:05.820 --> 16:06.820
就玩笑了

16:06.820 --> 16:07.820
好

16:07.820 --> 16:08.820
现在呢

16:08.820 --> 16:09.820
我在这里

16:09.820 --> 16:10.820
我在这里

16:10.820 --> 16:11.820
写了这个判断

16:11.820 --> 16:12.820
它如果没有这个属性

16:12.820 --> 16:13.820
圆形上面没有这个东西

16:13.820 --> 16:15.820
跟之前一样

16:16.820 --> 16:17.820
之前为什么不判断它

16:17.820 --> 16:18.820
因为类

16:18.820 --> 16:19.820
它只会

16:19.820 --> 16:21.820
对同一个类只会修饰一次

16:21.820 --> 16:23.820
这个装饰器只会修饰一次

16:23.820 --> 16:25.820
直接付值就完事了

16:25.820 --> 16:26.820
但是属性这里

16:26.820 --> 16:28.820
它可能会有多个属性

16:28.820 --> 16:30.820
反复的去调用这个函数

16:30.820 --> 16:31.820
一个属性要调用一次

16:31.820 --> 16:32.820
而它们都修饰的是

16:32.820 --> 16:34.820
同一个类的东西

16:34.820 --> 16:35.820
因此我判断一下

16:35.820 --> 16:36.820
这个类里边

16:36.820 --> 16:39.820
它的圆形上面

16:39.820 --> 16:41.820
有没有这个属性

16:41.820 --> 16:42.820
如果有的话

16:42.820 --> 16:44.820
如果有这个属性的话

16:44.820 --> 16:45.820
我怎么样了

16:45.820 --> 16:47.820
如果没有的话

16:47.820 --> 16:48.820
我就给它创建吧

16:48.820 --> 16:49.820
如果有的话

16:49.820 --> 16:50.820
我就往这个属性

16:50.820 --> 16:51.820
它是一个数组

16:51.820 --> 16:52.820
我就往这个数组里面

16:52.820 --> 16:54.820
添加一下

16:54.820 --> 16:55.820
添加一下啥

16:55.820 --> 16:57.820
添加一个对象

16:57.820 --> 16:59.820
添加什么对象

16:59.820 --> 17:01.820
一个是属性的名字

17:01.820 --> 17:02.820
proper name

17:02.820 --> 17:04.820
一个是属性的

17:04.820 --> 17:06.820
描述discreption

17:06.820 --> 17:07.820
我就把这个东西

17:07.820 --> 17:08.820
添加进去

17:08.820 --> 17:09.820
好

17:09.820 --> 17:10.820
这样子我就完成了

17:10.820 --> 17:12.820
属性的装饰器

17:12.820 --> 17:13.820
好

17:13.820 --> 17:15.820
经过这个属性的装饰器过后

17:15.820 --> 17:16.820
我们再来看一下

17:16.820 --> 17:17.820
再来看一下

17:17.820 --> 17:18.820
我们到时候

17:18.820 --> 17:19.820
打印这个对象的时候

17:19.820 --> 17:20.820
之前呢

17:20.820 --> 17:21.820
我们打印了

17:21.820 --> 17:23.820
内的信息

17:23.820 --> 17:24.820
然后我们再打印

17:24.820 --> 17:25.820
属性的信息

17:25.820 --> 17:26.820
proper description

17:26.820 --> 17:27.820
包穿

17:27.820 --> 17:28.820
我们来看一下

17:28.820 --> 17:30.820
打印出来是什么

17:30.820 --> 17:31.820
你看

17:31.820 --> 17:32.820
就打印出来

17:32.820 --> 17:33.820
这个数组看到没

17:33.820 --> 17:34.820
当我们打印

17:34.820 --> 17:35.820
这个对象的时候

17:35.820 --> 17:36.820
当我们打印

17:36.820 --> 17:37.820
这个对象的时候

17:37.820 --> 17:38.820
我就能得到啥

17:38.820 --> 17:39.820
这个对象的

17:39.820 --> 17:41.820
内的装饰器

17:41.820 --> 17:43.820
就内的装饰器的

17:43.820 --> 17:44.820
就是个名称

17:44.820 --> 17:46.820
装饰器的这个描述

17:46.820 --> 17:47.820
然后呢

17:47.820 --> 17:48.820
能够得到所有的属性

17:48.820 --> 17:49.820
它的描述

17:49.820 --> 17:51.820
就能得到了

17:51.820 --> 17:52.820
好

17:52.820 --> 17:53.820
得到了这些信息过后

17:53.820 --> 17:54.820
你看

17:54.820 --> 17:56.820
其实这就是原数据

17:56.820 --> 17:58.820
用来描述数据的数据

17:58.820 --> 18:00.820
类似一个数据

18:00.820 --> 18:01.820
描述它

18:01.820 --> 18:02.820
属性是数据

18:02.820 --> 18:03.820
描述它

18:03.820 --> 18:05.820
用来描述数据的数据

18:05.820 --> 18:06.820
那么到时候用的时候

18:06.820 --> 18:08.820
就可以把这些信息读出来

18:08.820 --> 18:10.820
就把这些信息读出来了

18:10.820 --> 18:11.820
好

18:11.820 --> 18:12.820
读出来之后

18:12.820 --> 18:14.820
我们最后来实现这个函数

18:14.820 --> 18:16.820
读出来之后

18:16.820 --> 18:17.820
第一个

18:17.820 --> 18:19.820
内的名称很简单

18:19.820 --> 18:20.820
内的名称很简单

18:20.820 --> 18:22.820
这里我们要这样子来做

18:22.820 --> 18:23.820
做个判断

18:23.820 --> 18:24.820
首先看一下

18:24.820 --> 18:26.820
它有没有这个属性

18:26.820 --> 18:27.820
有没有这个属性

18:27.820 --> 18:28.820
有可能没有

18:28.820 --> 18:29.820
凭什么说

18:29.820 --> 18:30.820
就一定有了

18:30.820 --> 18:32.820
有可能是没有的

18:32.820 --> 18:33.820
比方说

18:33.820 --> 18:34.820
什么情况下没有

18:34.820 --> 18:35.820
什么情况下没有

18:35.820 --> 18:37.820
是不是这里不写就没有

18:37.820 --> 18:38.820
对不对

18:38.820 --> 18:39.820
这里不写是不是没有

18:39.820 --> 18:41.820
因此它是有可能没有的

18:41.820 --> 18:42.820
有可能没有的

18:42.820 --> 18:43.820
你不能假设

18:43.820 --> 18:45.820
它一定有这个东西

18:45.820 --> 18:47.820
如果有的话

18:47.820 --> 18:48.820
那么很简单

18:48.820 --> 18:50.820
我直接输出

18:50.820 --> 18:52.820
l 如果没有的话

18:52.820 --> 18:54.820
那么我们输出啥呢

18:54.820 --> 18:55.820
我们输出啥呢

18:55.820 --> 18:57.820
如果没有的话

18:57.820 --> 18:58.820
我们输出啥

18:58.820 --> 19:01.820
我们可以直接输出

19:01.820 --> 19:02.820
输出啥呢

19:02.820 --> 19:04.820
这个内的名称

19:04.820 --> 19:07.820
直接输出这个内的名称

19:07.820 --> 19:09.820
这个内的名称怎么输出

19:09.820 --> 19:10.820
这是介石的知识

19:10.820 --> 19:12.820
来考号大家

19:12.820 --> 19:14.820
我们得到一个对象

19:14.820 --> 19:15.820
得到这个内的对象

19:15.820 --> 19:17.820
如何根据这个对象来输出

19:17.820 --> 19:19.820
这个内的名称呢

19:19.820 --> 19:21.820
这是哪个内的对象

19:21.820 --> 19:23.820
怎么来输出

19:23.820 --> 19:24.820
这不知道

19:24.820 --> 19:25.820
怎么输出呢

19:25.820 --> 19:27.820
我们就输出

19:27.820 --> 19:29.820
这个对象的啥呢

19:29.820 --> 19:32.820
这个对象的原型

19:32.820 --> 19:33.820
原型上面

19:33.820 --> 19:35.820
不是有一个属性

19:35.820 --> 19:36.820
叫做constructor

19:37.820 --> 19:39.820
表示构造器对吧

19:39.820 --> 19:41.820
这个东西的构造器

19:41.820 --> 19:44.820
找到这个对象的构造器

19:44.820 --> 19:45.820
这个构造器里面

19:45.820 --> 19:47.820
还不是个函数吗

19:47.820 --> 19:49.820
输出它的名字

19:49.820 --> 19:50.820
好 我们来试一下

19:50.820 --> 19:52.820
这一部分的代码

19:52.820 --> 19:54.820
这个代码是介石的知识

19:54.820 --> 19:56.820
介石关于原型的知识

19:56.820 --> 19:58.820
好 我们这里呢

19:58.820 --> 20:00.820
大家注释

20:00.820 --> 20:02.820
这里是输出

20:02.820 --> 20:05.820
内的名字

20:05.820 --> 20:06.820
如果有

20:06.820 --> 20:07.820
之前如果描述了的话

20:07.820 --> 20:09.820
我就输出描述的名字

20:09.820 --> 20:10.820
如果没有描述的话

20:10.820 --> 20:11.820
我就输出

20:11.820 --> 20:13.820
内原本的名字

20:13.820 --> 20:15.820
好 咱们来试一下

20:15.820 --> 20:16.820
包穿

20:16.820 --> 20:17.820
好

20:17.820 --> 20:19.820
输出了用户

20:19.820 --> 20:20.820
然后我们这里

20:20.820 --> 20:21.820
把注释了

20:21.820 --> 20:23.820
包穿

20:23.820 --> 20:25.820
好 这里包错了

20:25.820 --> 20:27.820
我这里代码写的有问题

20:27.820 --> 20:29.820
objproto

20:29.820 --> 20:31.820
这里写错了

20:31.820 --> 20:33.820
这里写错了

20:33.820 --> 20:34.820
不是proto的态度

20:34.820 --> 20:36.820
应该是隐释原型

20:36.820 --> 20:38.820
隐释原型

20:38.820 --> 20:39.820
proto

20:39.820 --> 20:41.820
好 包穿

20:41.820 --> 20:43.820
有字

20:43.820 --> 20:45.820
当然也可以用这种方式来得到

20:45.820 --> 20:48.820
通过隐释原型能够得到啥

20:48.820 --> 20:51.820
隐释原型指向的是

20:51.820 --> 20:54.820
勾造函数的原型

20:54.820 --> 20:55.820
就这个代码

20:55.820 --> 20:56.820
这个表达是

20:56.820 --> 20:57.820
我们得到了的是啥

20:57.820 --> 20:58.820
得到了的是

20:58.820 --> 21:00.820
勾造函数的原型

21:00.820 --> 21:01.820
而原型里边

21:01.820 --> 21:03.820
它有个constructor属性

21:03.820 --> 21:04.820
表示它的勾造函数

21:04.820 --> 21:06.820
就是内本身

21:06.820 --> 21:08.820
就是函数的名字

21:08.820 --> 21:10.820
当然也可以使用这种方式

21:10.820 --> 21:14.820
objproto type

21:14.820 --> 21:17.820
得到一个对象的

21:17.820 --> 21:20.820
得到一个对象的原型

21:20.820 --> 21:22.820
得到一个对象的原型

21:22.820 --> 21:23.820
然后通过原型

21:23.820 --> 21:24.820
去找到constructor

21:24.820 --> 21:25.820
找到内

21:25.820 --> 21:27.820
也是一样的效果

21:27.820 --> 21:29.820
得到了还是优质

21:29.820 --> 21:30.820
得到了还是优质

21:31.820 --> 21:33.820
我们可以通过这种方式

21:33.820 --> 21:36.820
来输出一个内的名字

21:36.820 --> 21:38.820
接下来是输出属性

21:38.820 --> 21:40.820
输出属性的话

21:40.820 --> 21:41.820
我们这里

21:41.820 --> 21:43.820
不是

21:43.820 --> 21:44.820
我们可以判断一下

21:44.820 --> 21:45.820
对吧

21:45.820 --> 21:48.820
这个obj里边

21:48.820 --> 21:50.820
有没有什么

21:50.820 --> 21:52.820
proper description

21:52.820 --> 21:54.820
有没有这个属性

21:54.820 --> 21:56.820
就是有没有这个属性

21:56.820 --> 21:58.820
如果没有说明什么

21:59.820 --> 22:01.820
我先说没有吧

22:01.820 --> 22:04.820
如果没有说明啥

22:04.820 --> 22:06.820
如果没有这个属性

22:06.820 --> 22:09.820
说明了内里边

22:09.820 --> 22:10.820
就是对象

22:10.820 --> 22:12.820
它所在的内里边

22:12.820 --> 22:14.820
没有任何属性

22:14.820 --> 22:15.820
加了这个修饰器

22:15.820 --> 22:16.820
就像这样子

22:16.820 --> 22:18.820
什么都没加

22:18.820 --> 22:20.820
如果是这种情况

22:20.820 --> 22:21.820
什么都没加

22:21.820 --> 22:22.820
没加怎么办

22:22.820 --> 22:23.820
没加的话

22:23.820 --> 22:25.820
我先建立一个空速组

22:25.820 --> 22:27.820
方便后面处理

22:27.820 --> 22:29.820
总之经过这么一段代码

22:29.820 --> 22:31.820
一定有这个属性值的

22:31.820 --> 22:32.820
对吧

22:32.820 --> 22:34.820
经过30到32毫的代码

22:34.820 --> 22:36.820
它就一定有这个属性值的

22:36.820 --> 22:37.820
有可能它是一个空速组

22:37.820 --> 22:39.820
那无所谓

22:39.820 --> 22:40.820
好了

22:40.820 --> 22:41.820
到了第33行

22:41.820 --> 22:42.820
我们要做啥呢

22:42.820 --> 22:44.820
我们要输出

22:44.820 --> 22:48.820
所有的属性值

22:48.820 --> 22:51.820
所有的属性描述

22:51.820 --> 22:53.820
和属性值

22:53.820 --> 22:55.820
我们要输出这个东西

22:56.820 --> 22:58.820
那么输出的时候

22:58.820 --> 23:00.820
按照我们以前的做法

23:00.820 --> 23:02.820
会怎么输出呢

23:02.820 --> 23:04.820
是不是有个缝印循环

23:04.820 --> 23:05.820
循环啥

23:05.820 --> 23:06.820
循环OB界

23:06.820 --> 23:09.820
缝印循环去循环OB界

23:09.820 --> 23:11.820
循环就行了

23:11.820 --> 23:14.820
循环OB界的时候

23:14.820 --> 23:16.820
我们就可以怎么办了

23:16.820 --> 23:17.820
每次循环

23:17.820 --> 23:19.820
你看这个是不是属性的名称

23:19.820 --> 23:22.820
我们得到了属性的名称

23:22.820 --> 23:24.820
现在我们得到属性

23:24.820 --> 23:26.820
名称过后

23:26.820 --> 23:28.820
但是我们要的不是属性名

23:28.820 --> 23:29.820
要的是啥

23:29.820 --> 23:32.820
要的是属性的描述

23:32.820 --> 23:33.820
要的是属

23:33.820 --> 23:34.820
这个东西

23:34.820 --> 23:36.820
要的是属性描述

23:36.820 --> 23:38.820
而属性描述存在哪的

23:38.820 --> 23:41.820
是不是存在这个东西里面的

23:41.820 --> 23:42.820
这个东西里面的

23:42.820 --> 23:43.820
是不是存在属性的描述的

23:43.820 --> 23:44.820
它是个数组

23:44.820 --> 23:45.820
我们之前打印出来

23:45.820 --> 23:46.820
看过的对吧

23:46.820 --> 23:48.820
它是个什么东西呢

23:48.820 --> 23:49.820
它是一个数组

23:49.820 --> 23:50.820
就这个数组

23:50.820 --> 23:52.820
我们要从这个数组里边

23:52.820 --> 23:54.820
通过属性的名称

23:54.820 --> 23:57.820
去找到属性的描述

23:57.820 --> 23:58.820
能理解吧

23:58.820 --> 24:01.820
我们的属性名称在T里边

24:01.820 --> 24:03.820
我们这里打印出来看一下吧

24:03.820 --> 24:05.820
这是个FORING循环

24:05.820 --> 24:06.820
大家应该

24:06.820 --> 24:07.820
都是很基础的指示

24:07.820 --> 24:08.820
应该都清楚

24:08.820 --> 24:10.820
你看

24:10.820 --> 24:11.820
属性的名称

24:11.820 --> 24:13.820
属性的名称

24:13.820 --> 24:15.820
当然这两个属性

24:15.820 --> 24:16.820
当然这两个属性是在哪里呢

24:16.820 --> 24:18.820
是在圆形上面

24:18.820 --> 24:19.820
是在圆形上面

24:19.820 --> 24:20.820
现在也把它打印出来了

24:20.820 --> 24:22.820
就把圆形上面的东西

24:22.820 --> 24:23.820
也打印出来了

24:23.820 --> 24:24.820
所以说这里呢

24:24.820 --> 24:26.820
其实可以判断一下

24:26.820 --> 24:28.820
其实可以判断一下

24:28.820 --> 24:29.820
FORING

24:31.820 --> 24:33.820
通过这种方式来判断一下

24:33.820 --> 24:34.820
判断这个属性

24:34.820 --> 24:35.820
是不是对象

24:35.820 --> 24:36.820
原本有的属性

24:36.820 --> 24:38.820
而不是在圆形上面

24:38.820 --> 24:39.820
我们要判断的是啥

24:39.820 --> 24:40.820
判断的是

24:40.820 --> 24:41.820
这个属性

24:41.820 --> 24:43.820
是不是对象的属性

24:43.820 --> 24:45.820
而不是在圆形上的属性

24:45.820 --> 24:46.820
通过这种方式判断

24:46.820 --> 24:48.820
HAS OWM PROPERTY

24:48.820 --> 24:49.820
是不是自己拥有的属性

24:49.820 --> 24:50.820
把属性临传进去

24:50.820 --> 24:51.820
好

24:51.820 --> 24:53.820
这样子我们要打印出来

24:53.820 --> 24:55.820
HAS OWM PROPERTY

24:57.820 --> 24:58.820
打印出来看一下

25:00.820 --> 25:01.820
打印出来过后

25:01.820 --> 25:03.820
你会发现一个属性都没有

25:03.820 --> 25:05.820
怎么回事呢

25:05.820 --> 25:06.820
怎么会一个属性都没有呢

25:06.820 --> 25:08.820
这里不是写了两个属性吗

25:08.820 --> 25:10.820
这里是这个原因

25:10.820 --> 25:12.820
因为你没有给这两个属性复职

25:12.820 --> 25:14.820
你没有给这两个属性复职

25:14.820 --> 25:16.820
那么这两个属性是undefined

25:16.820 --> 25:17.820
打印不出来

25:17.820 --> 25:19.820
它重新从来没复过职

25:19.820 --> 25:21.820
这里我们可以给它复一下职吧

25:21.820 --> 25:23.820
LOGIN ID

25:23.820 --> 25:25.820
比如说ABC

25:25.820 --> 25:27.820
U的LOGIN PASSWARE

25:27.820 --> 25:28.820
123

25:28.820 --> 25:29.820
保存

25:31.820 --> 25:32.820
你看

25:32.820 --> 25:34.820
LOGIN ID和LOGIN PASSWARE

25:34.820 --> 25:35.820
是不是打印出来了

25:35.820 --> 25:36.820
OK

25:36.820 --> 25:37.820
这个东西就打印出来了

25:37.820 --> 25:38.820
好

25:38.820 --> 25:39.820
打印出来了

25:39.820 --> 25:40.820
我们现在知道了

25:40.820 --> 25:41.820
我们现在也就是说

25:41.820 --> 25:42.820
我们现在在遍地

25:42.820 --> 25:44.820
它的每一个属性

25:44.820 --> 25:46.820
这个属性必须要是

25:46.820 --> 25:47.820
像自己的属性

25:47.820 --> 25:48.820
而不能是圆形上的属性

25:48.820 --> 25:50.820
你看这个属性是在圆形上面

25:50.820 --> 25:52.820
我们要把这种东西排除掉

25:52.820 --> 25:53.820
好

25:53.820 --> 25:54.820
现在我们得到了

25:54.820 --> 25:56.820
每一个属性的名字

25:56.820 --> 25:58.820
属性的名字拿到了

25:58.820 --> 25:59.820
我们要拿到了

25:59.820 --> 26:00.820
但是我们要拿到的

26:00.820 --> 26:01.820
不是属性名

26:01.820 --> 26:02.820
而是什么呢

26:02.820 --> 26:04.820
而是属性的描述

26:04.820 --> 26:06.820
从这个数组里面去拿

26:06.820 --> 26:07.820
对不对

26:07.820 --> 26:09.820
从这个数组里面去拿

26:09.820 --> 26:10.820
好

26:10.820 --> 26:11.820
来呗

26:11.820 --> 26:12.820
我们从这个数组

26:12.820 --> 26:14.820
OBGPROP

26:14.820 --> 26:15.820
description

26:15.820 --> 26:16.820
这个数组里面

26:16.820 --> 26:18.820
通过函数Find

26:18.820 --> 26:20.820
去找

26:20.820 --> 26:21.820
找什么呢

26:21.820 --> 26:22.820
一个一个找

26:22.820 --> 26:23.820
一个个找

26:23.820 --> 26:25.820
找到

26:25.820 --> 26:26.820
它的什么呢

26:26.820 --> 26:27.820
proper name

26:27.820 --> 26:29.820
从这个数组里面的proper name

26:29.820 --> 26:33.820
等于这个key的东西

26:33.820 --> 26:35.820
去找这个东西

26:35.820 --> 26:36.820
OK

26:36.820 --> 26:40.320
我们去找这个东西

26:41.320 --> 26:43.320
它说它有隐私的n内形

26:43.320 --> 26:45.320
n内形就n内形

26:45.320 --> 26:46.320
n内形就n内形

26:46.320 --> 26:48.320
我们拿上一个

26:48.320 --> 26:53.900
这样子

26:53.900 --> 26:54.900
本来就是n内形

26:54.900 --> 26:55.900
因为我们现在

26:55.900 --> 26:58.900
在这一块没有进行内形检查

26:58.900 --> 26:59.900
好去找

26:59.900 --> 27:00.900
找到过后呢

27:00.900 --> 27:02.900
我们得到一个就是

27:02.900 --> 27:04.900
对象

27:04.900 --> 27:06.900
prop

27:06.900 --> 27:07.900
得到这么一个对象

27:07.900 --> 27:09.900
也就是这个对象

27:09.900 --> 27:10.900
如果找到了

27:10.900 --> 27:11.900
它就会有这个对象

27:11.900 --> 27:13.900
那么接下来有两种情况

27:13.900 --> 27:16.900
一种情况是找到了这个对象

27:16.900 --> 27:19.900
一种情况是没有找到这个对象

27:20.900 --> 27:22.900
好我们依次来分别处理吧

27:22.900 --> 27:24.900
如果找到这个对象

27:24.900 --> 27:25.900
那就好办了

27:25.900 --> 27:26.900
我输出啥呢

27:26.900 --> 27:28.900
前面加一个斜杠剃

27:28.900 --> 27:30.900
表示字表服

27:30.900 --> 27:32.900
有几个空格

27:32.900 --> 27:33.900
加上一个斜杠剃

27:33.900 --> 27:35.900
然后呢就输出啥呢

27:35.900 --> 27:36.900
我们这样子吧

27:36.900 --> 27:37.900
斜杠剃

27:37.900 --> 27:39.900
就输出

27:39.900 --> 27:41.900
这个属性的描述

27:41.900 --> 27:43.900
description

27:43.900 --> 27:44.900
description

27:44.900 --> 27:46.900
然后呢加上一个冒号

27:46.900 --> 27:48.900
再输出这个属性的值

27:48.900 --> 27:50.900
属性的值是啥

27:50.900 --> 27:52.900
属性的值是啥

27:52.900 --> 27:54.900
这是以前的知识

27:54.900 --> 27:55.900
不要做晕了

27:55.900 --> 27:56.900
这个对象

27:56.900 --> 27:57.900
通过对象

27:57.900 --> 27:59.900
找到这个属性的值

27:59.900 --> 28:00.900
对吧

28:00.900 --> 28:01.900
通过这种属性表达式

28:01.900 --> 28:03.900
来找到这个属性的值

28:03.900 --> 28:05.900
好这是有这个

28:05.900 --> 28:06.900
有这个的情况

28:06.900 --> 28:08.900
好我们来看一下保存

28:08.900 --> 28:12.270
你看现在是不是已经输出出来了

28:12.270 --> 28:14.270
用户

28:14.270 --> 28:16.270
账号

28:16.270 --> 28:18.270
好我们再看另外一个情况

28:18.270 --> 28:20.270
没有这个描述服

28:20.270 --> 28:22.270
没有这个装饰器

28:22.270 --> 28:24.270
你看没个装饰器的话

28:24.270 --> 28:26.270
这个属性是输出不了的

28:26.270 --> 28:27.270
那么如果

28:27.270 --> 28:29.270
如果你希望没有装饰器的话

28:29.270 --> 28:31.270
你进行默认处理

28:31.270 --> 28:32.270
处理什么呢

28:32.270 --> 28:34.270
就是这个属性的

28:34.270 --> 28:36.270
本来的名称

28:36.270 --> 28:37.270
那好吧

28:37.270 --> 28:39.270
就把这个描述

28:39.270 --> 28:41.270
设置为key

28:41.270 --> 28:43.270
就是个属性原本的名称

28:43.270 --> 28:46.650
保存看一下

28:46.650 --> 28:48.650
就是如果没有这个装饰器的话

28:48.650 --> 28:49.650
就是属性原本的名称

28:49.650 --> 28:51.650
诺金帕斯文

28:51.650 --> 28:52.650
好了

28:52.650 --> 28:54.650
我们写好这个装饰器

28:54.650 --> 28:55.650
其实功能就写完了

28:55.650 --> 28:57.650
来看一下这个代码

28:57.650 --> 28:58.650
这好好看一下这个代码

28:58.650 --> 29:00.650
其实就是在装饰器里边

29:00.650 --> 29:01.650
把这些信息

29:01.650 --> 29:03.650
这些元数据

29:03.650 --> 29:04.650
就是附加的数据

29:04.650 --> 29:06.650
记录下来

29:06.650 --> 29:07.650
然后打印的时候呢

29:07.650 --> 29:09.650
我们再把这些信息取出来

29:09.650 --> 29:11.650
来进行使用

29:11.650 --> 29:13.650
好有了这个装饰器过后

29:13.650 --> 29:14.650
这个代码永远只写一次

29:14.650 --> 29:16.650
一共就不到50行的代码

29:16.650 --> 29:18.650
我写完之后呢

29:18.650 --> 29:21.650
后边就非常非常方便了

29:21.650 --> 29:22.650
你看啊

29:22.650 --> 29:23.650
这是一个内对吧

29:23.650 --> 29:24.650
这是一个属性

29:24.650 --> 29:26.650
我们就可以通过这种方式

29:26.650 --> 29:28.650
通过这种方式来输出

29:28.650 --> 29:29.650
这个属性

29:29.650 --> 29:31.650
这个对象的格式

29:31.650 --> 29:33.650
这对象的格式又打印出来了

29:33.650 --> 29:35.650
好我们也可以怎么样呢

29:35.650 --> 29:37.650
也可以放到其他内里边

29:37.650 --> 29:38.650
其他内里边

29:38.650 --> 29:39.650
比方说

29:39.650 --> 29:41.650
我们有一个文章内

29:41.650 --> 29:43.650
article

29:43.650 --> 29:45.650
一个文章内

29:45.650 --> 29:47.650
这个文章内呢

29:47.650 --> 29:49.650
我们也给他去写一些

29:49.650 --> 30:30.720
装饰器啊

30:30.720 --> 30:32.720
我们首先书写一个属性

30:32.720 --> 30:34.720
文章的标题

30:34.720 --> 30:36.720
使用属性装饰器

30:36.720 --> 30:38.720
prob descriptor

30:38.720 --> 30:39.720
表示标题

30:39.720 --> 30:40.720
然后呢

30:40.720 --> 30:42.720
输出一个

30:42.720 --> 30:43.720
content

30:43.720 --> 30:45.720
文章的内容

30:45.720 --> 30:47.720
prob descriptor

30:47.720 --> 30:49.720
内容

30:49.720 --> 30:51.720
好我们再来一个

30:51.720 --> 30:53.720
再来一个日期吧

30:53.720 --> 30:55.720
日期

30:55.720 --> 30:57.720
内容是日期

30:57.720 --> 30:59.720
我们之前还没有对日期

30:59.720 --> 31:01.720
作为约束对吧

31:01.720 --> 31:02.720
日期

31:02.720 --> 31:03.720
好然后呢

31:03.720 --> 31:04.720
这边

31:04.720 --> 31:06.720
内上面描述

31:06.720 --> 31:08.720
class descriptor

31:08.720 --> 31:10.720
这是一篇文章

31:10.720 --> 31:12.720
好我们只做这么简单的事情

31:12.720 --> 31:14.720
那么之后呢

31:14.720 --> 31:16.720
我创建好一篇文章之后

31:16.720 --> 31:17.720
article

31:17.720 --> 31:19.720
创建好一篇文章之后

31:19.720 --> 31:20.720
比方说给他一些

31:20.720 --> 31:21.720
各个属性负责

31:21.720 --> 31:23.720
文章的标题

31:23.720 --> 31:25.720
什么什么什么

31:25.720 --> 31:27.720
然后文章的内容

31:27.720 --> 31:29.720
什么什么什么

31:29.720 --> 31:31.720
然后文章的日期

31:31.720 --> 31:32.720
desk

31:32.720 --> 31:34.720
不要负责当前日期

31:34.720 --> 31:38.030
好当前日期

31:38.030 --> 31:40.030
好之后我们要把文章打印出来

31:40.030 --> 31:42.030
你看现在是不是很方便了

31:42.030 --> 31:44.030
print objar

31:44.030 --> 31:46.030
打印

31:46.030 --> 31:48.030
看一下

31:48.030 --> 31:50.030
你看这文章的信息打印出来了

31:50.030 --> 31:52.030
那比我们之前

31:52.030 --> 31:54.030
去手动的去写console

31:54.030 --> 31:56.030
log是不是舒服太多了

31:56.030 --> 31:58.030
这就是装饰器的好处

31:58.030 --> 31:59.030
就是有一些事情呢

31:59.030 --> 32:01.030
我们需要依赖于啥呢

32:01.030 --> 32:03.030
依赖于一些额外的信息

32:03.030 --> 32:04.030
那么我们可以通过装饰器

32:04.030 --> 32:06.030
把这些信息给加上

32:06.030 --> 32:08.030
有了这些额外的信息过后

32:08.030 --> 32:10.030
我们就可以写很多的通用函数

32:10.030 --> 32:12.030
来去处理一些问题

32:12.030 --> 32:14.030
当然这是打印

32:14.030 --> 32:16.030
当然如果你要做

32:16.030 --> 32:18.030
你要做那个验证

32:18.030 --> 32:20.030
属性值的验证

32:20.030 --> 32:22.030
等等等等

32:22.030 --> 32:24.030
其实都可以做

32:24.030 --> 32:26.030
OK我们这里就学习了这么

32:26.030 --> 32:28.030
而且做了一个练习

32:28.030 --> 32:30.030
做一个练习就是

32:30.030 --> 32:32.030
对内和属性进行描述

32:32.030 --> 32:34.030
给它加一些额外的信息

32:34.030 --> 32:35.030
希望通过这个历史呢

32:35.030 --> 32:37.030
大家能够体会到

32:37.030 --> 32:39.030
使用装饰器给我们开发出来的方便

32:39.030 --> 32:41.030
有了这些额外的信息

32:41.030 --> 32:43.030
我们很多的通用函数就可以写了

32:43.030 --> 32:45.030
以前很多的通用函数

32:45.030 --> 32:47.030
比方通用的验证函数

32:47.030 --> 32:49.030
通用就是真的是通用

32:49.030 --> 32:51.030
的东西都可以用它来进行验证

32:51.030 --> 32:53.030
那么通用的验证函数

32:53.030 --> 32:55.030
像这些东西以前做不了

32:55.030 --> 32:56.030
为什么做不了呢

32:56.030 --> 32:58.030
因为我不知道验证规则

32:58.030 --> 32:59.030
那么现在有了装饰器

32:59.030 --> 33:00.030
我就可以用装饰器

33:00.030 --> 33:02.030
来表述它的规则

33:02.030 --> 33:03.030
明白这个意思吗

33:03.030 --> 33:05.030
OK这是关于这一课

33:05.030 --> 33:06.030
做了一个练习

33:06.030 --> 33:07.030
大家下来去吧

33:07.030 --> 33:08.030
做一遍

33:08.030 --> 33:09.030
一定要做一遍

33:09.030 --> 33:10.030
做一遍过后

33:10.030 --> 33:11.030
就大概能理解

33:11.030 --> 33:13.030
这个装饰器是一个怎么回事

33:13.030 --> 33:14.030
好吧

33:14.030 --> 33:15.030
OK那么这里

33:15.030 --> 33:16.030
可以到这里了

33:16.030 --> 33:17.030
拜拜

