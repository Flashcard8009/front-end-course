WEBVTT

00:00.000 --> 00:03.580
好 接下来呢 咱们来开始做这个游戏

00:04.080 --> 00:07.160
做这个游戏之前呢 这是游戏开发

00:07.680 --> 00:14.840
做这个游戏之前呢 有几个原则 我希望这几个原则呢 大家在心里边 要根深蒂固的去

00:15.100 --> 00:17.160
植入到你们的心里边去

00:17.660 --> 00:20.220
一个原则呢 是叫做单一指能原则

00:21.000 --> 00:23.800
单一指能原则

00:24.320 --> 00:28.680
这个说的是什么意思呢 说的是每个内 我们

00:29.000 --> 00:33.040
我们这里呢 由于使用面向对象的方式开发 会写很多很多的内

00:33.300 --> 00:34.320
每个内

00:34.560 --> 00:35.340
只做

00:35.840 --> 00:36.880
只做

00:37.380 --> 00:38.160
跟他

00:38.660 --> 00:39.940
相关的

00:40.200 --> 00:41.220
一件事

00:41.480 --> 00:44.300
每个内只需要完成他自己的事情就行了

00:44.560 --> 00:46.080
不要去管别人的事情

00:46.340 --> 00:47.880
不管他关心的 你不要去管

00:48.400 --> 00:52.740
其实咱们在学习react的时候 学习5u的时候 做组件 对吧

00:53.000 --> 00:56.840
也是沿用的这种思想 你看react里面是不是内组件 对吧

00:57.040 --> 01:01.660
一个组件呢 他只关心这个组件有关的事情 组件内部的一些事情

01:02.420 --> 01:05.240
外表怎么去使用他 你不要去管 跟你没有关系

01:05.760 --> 01:07.800
单一指能原则 很好理解吧

01:09.340 --> 01:12.920
就是你不要去考虑太多的事情 不然的话整个系统会变得非常非常复杂

01:13.680 --> 01:14.960
第二个呢 是开闭原则

01:15.740 --> 01:16.760
开闭原则

01:17.280 --> 01:22.900
什么是开闭原则呢 指的是 系统中的内

01:23.420 --> 01:24.960
就是咱们写的一个人内

01:25.920 --> 01:29.120
应该对扩展

01:30.120 --> 01:33.280
开放 对修改关闭

01:34.000 --> 01:38.880
什么意思 就是我们写的内 比方说将来要植入一些功能的时候呢

01:39.200 --> 01:41.560
我们应该不要去修改这个内的代码

01:42.040 --> 01:48.160
尽量 只能说尽量这样做 不能说你完全不能去修改内 那也不对

01:48.560 --> 01:49.680
应该是尽量的

01:50.440 --> 01:53.880
对扩展 增加功能的时候呢 我们应该去增加代码

01:54.440 --> 02:01.280
就是不要去修改这个内本身的代码 而去增加一些内 增加一些实现来去做扩展功能

02:01.800 --> 02:03.080
而不应该去修改

02:03.520 --> 02:04.360
就说的是这个意思

02:04.840 --> 02:09.560
就说咱们在闲内的时候啊 就应该考虑到将来的一些某些情况

02:10.280 --> 02:14.440
如果将来有一些扩展的功能的话 我应该如何来去操作

02:14.840 --> 02:20.760
尽量的让他不要去修改这个内本身 而去应该去增加一个文件 增加一个内

02:21.120 --> 02:23.320
或者是增加一些功能

02:23.680 --> 02:27.840
在其他的地方去携带 应该对扩展开放 对修改关闭

02:28.400 --> 02:33.360
好 这是这两个原则啊 这两个原则会贯穿咱们整个系统的开发

02:34.680 --> 02:38.440
然后呢 基于这两个原则呢 我这里呢 就是

02:39.680 --> 02:40.120
基于

02:41.920 --> 02:46.280
以上两个原则 我们这里呢会使用一种模式

02:48.240 --> 02:50.520
系统中 系统中

02:51.400 --> 02:59.640
使用如下模式 什么模式呢 这也是我非常喜欢的一个模式啊 叫做我把它叫做数据

03:00.920 --> 03:06.600
界面分离模式 就是其实这个模式 大家已经见到非常非常多了

03:07.240 --> 03:09.320
什么情况下呢 就是react

03:10.040 --> 03:18.040
react里面他其实就是使用了这个模式 你只关心数据就行了 界面怎么展示呢 界面怎么展示你单独来写

03:18.440 --> 03:21.000
咱们在react里面不是使用

03:21.800 --> 03:28.160
使用的是什么 展示组件和容器组件 对吧 那么展示组件的只关心显示

03:28.680 --> 03:33.960
一把数据告诉我 我就给你显示出来 只关心显示 容器组件的只关心数据

03:34.600 --> 03:38.440
那么容器组件的数据呢 我们往往比方说可以提到redux里面 对不对

03:38.840 --> 03:43.960
那其实我们以前使用过这么一些原则 就是数据是数据 界面是界面

03:44.600 --> 03:49.880
为什么要分离 分离的好处在于将来界面要变化 数据可以不动

03:50.520 --> 03:54.680
只要你数据逻辑没变 那么数据不动 界面只需要变就行了

03:55.720 --> 04:01.080
然后呢 如果界面不变 我的数据改变的话 我只需要动数据的一块就行了

04:01.720 --> 04:06.680
所以说咱们整个开发的过程中呢 会贯穿这么一个原则啊 就就贯穿这么一个就是模式

04:07.240 --> 04:12.360
数据和界面的分离模式 咱们在开发内的时候 比方说我们开发一个俄罗斯方块的内

04:13.240 --> 04:20.120
这个内里边呢 我可能只关心它的数据变化 数据逻辑而不太关心 它的界面显示出来什么样子

04:20.600 --> 04:25.400
我们专门去写一个内来搞定界面的事情 我们会基于这么一个原则来写单吧

04:26.280 --> 04:31.240
好 那么这节课呢 我们会怎么写呢 写啥呢 这节课我们看一下这个游戏啊

04:32.360 --> 04:39.080
我拿到这个游戏过后呢 这个游戏呢 他有本身的一个流程啊 就是开始一个新游戏 什么暂停呀 这些功能

04:39.400 --> 04:42.040
我都不着急去做 这些呢不是我们的重点

04:42.600 --> 04:48.280
我先看这个游戏里边 我看到的是啥呢 我看到的是一个一个的小方块

04:49.000 --> 04:49.640
就这个东西

04:50.760 --> 04:52.920
一个一个的小方块啊 就这个东西

04:53.720 --> 04:59.720
我认为俄罗斯方块它是由一个一个的小方块组成的 所以说这节课呢 咱们来开发一个内

05:00.520 --> 05:04.120
什么内 就是一个小方块的内啊 就是这么一个小方块的内

05:05.000 --> 05:06.680
好 我们先在代码里边

05:08.680 --> 05:09.240
暂停啊

05:10.200 --> 05:14.520
在代码里边 我们在src目录下边呢 去新建一个文件夹

05:14.920 --> 05:18.040
这个文件夹呢 给他取个名字 比方说取名就叫做

05:20.280 --> 05:20.840
antities

05:21.480 --> 05:22.280
或者叫做core

05:23.000 --> 05:28.200
核心数据内啊 这里面呢 全是处理数据的跟数据相关的

05:28.680 --> 05:31.320
什么界面怎么展示 我完全不管

05:31.640 --> 05:36.920
根本就不考虑界面怎么展示 考虑的只有数据和数据之间的变化逻辑

05:37.880 --> 05:42.840
这个文件夹里边呢 我们给他新建一个文件啊 叫做square

05:44.360 --> 05:44.760
ts

05:45.240 --> 05:51.080
比方他意思呢 表示的是一个小方块啊 导出一个内 class square

05:51.800 --> 05:53.800
这个内表示的是一个小方块

05:55.000 --> 05:55.560
小方块

05:55.960 --> 05:59.000
就是咱们系统中游戏里边最基础的一个单元

05:59.800 --> 06:04.840
好 我们新建了一个内过后 你看我的思维啊 我先看到的是一个最小的单元

06:05.400 --> 06:08.520
最小绣小的功能 那么这个我们看到了个小方块

06:09.080 --> 06:16.520
好 我把这个小方块建立了成一个内之后呢 我首先想的是这个内里边会有哪些属性

06:17.320 --> 06:18.200
会有哪些属性

06:19.480 --> 06:21.320
有什么样的属性呢 小方块

06:22.840 --> 06:25.480
好 有人可能看到了啊 这个小方块有什么属性

06:25.880 --> 06:30.280
一个是小方块的颜色 对不对 每个小方块它有颜色的

06:30.760 --> 06:33.080
还有什么样的属性呢 还有它的坐标

06:33.720 --> 06:37.720
对不对 还有小方块的坐标啊 就是它位于什么位置

06:38.440 --> 06:43.000
那么于是呢 这里呢 我们可以写很轻松的可以写出这么三个属性

06:43.400 --> 06:47.880
一个是坐标 坐标当然包括 x 坐标和 y 坐标

06:49.320 --> 06:52.280
一个是坐标 一个是什么呢 小方块的颜色

06:52.920 --> 06:55.480
卡了 卡了的话我用实践 写出这么三个属性

06:56.680 --> 06:59.960
但是大家注意一点 我这里说的坐标

07:00.920 --> 07:04.600
它指的是什么意思呢 如果你把这个坐标当成了

07:05.560 --> 07:10.040
这个div 外面是个div这个div的left值和top值

07:10.040 --> 07:14.600
如果你当成了这个 那么你就意味着你犯了这个错误了

07:15.480 --> 07:17.240
你没有把数据和界面分离

07:17.880 --> 07:20.200
我们这里写的东西跟界面有没有关系

07:20.520 --> 07:23.240
跟它显示出来的东西 怎么去显示有没有关系

07:23.480 --> 07:27.480
它显示到div里面 显示到我们的本地窗口里面

07:27.560 --> 07:30.200
一个本地的应用程序 或者显示到手机上

07:30.920 --> 07:33.240
我不care 我一点都不care它显示到哪

07:33.720 --> 07:38.360
所以说这里的坐标呢 指的跟相数啊跟什么百分比啊

07:38.360 --> 07:42.120
那些没有任何关系 这里的坐标指的是逻辑坐标

07:43.720 --> 07:47.640
逻辑坐标 x 这里是逻辑坐标

07:48.840 --> 07:53.960
逻辑坐标关 什么叫做逻辑坐标 我给大家画个图啊

07:54.680 --> 07:56.600
我这里打开一个画图 给大家画个图

07:57.160 --> 08:01.400
比方说我认为我的游戏面板 我甭管它是用什么div啊还是

08:02.040 --> 08:06.520
什么东西实现了 我无所谓 你总共有个面板吧 对吧 我的游戏面板

08:07.320 --> 08:09.160
有可能你去用控制台 无所谓

08:09.800 --> 08:14.120
这个面板呢 你会分成一个一个的小格子 因为这是俄罗斯方块的核心 对吧

08:14.680 --> 08:20.600
你会分成一个一个的小格子 我就不画那么多了啊我就不画那么多了 画几个有一个意识就行了

08:21.320 --> 08:24.040
画一下吧

08:25.160 --> 08:29.240
快说画一下啊 因为分成一个一个的小格子 比方说现在我们分成的就是

08:29.880 --> 08:36.760
几成几呢 1 2 3 4 5 6 7 8啊 有8列有多少了每一列

08:37.240 --> 08:42.360
有多少行呢 1 2 3 4 5 6啊 就是8乘以6的小格子 当然这个格子的

08:43.000 --> 08:48.680
这个面板的尺寸是可以变的 我的坐标啥意思 我的坐标是每一个小格子的坐标

08:49.080 --> 08:51.000
就是这里是0啊 就这里

08:51.960 --> 08:57.800
这样的话啊 这里是横 这里这里的坐标是横坐标是0

08:58.920 --> 08:59.800
重坐标是0

09:00.520 --> 09:05.480
然后这里的坐标呢 是横坐标是1 重坐标是0 懂我这个意思吧

09:05.960 --> 09:11.800
这里横坐标是2 重坐标是0 那么这个位置呢 就是横坐标是2 重坐标是1

09:12.520 --> 09:20.760
我是这叫逻辑坐标 跟这个真实的相处子没有任何关系啊 跟相处子之间没有任何关系 我们现在不要去考虑界面

09:21.320 --> 09:25.400
考虑的是这种逻辑啊逻辑含义 明白这个意思吗

09:26.200 --> 09:30.680
ok啊 那么咱们呢 我们这里指的是逻辑坐标 一定要搞清楚

09:31.720 --> 09:37.880
好 我们写了这三个属性 那想一想还有没有其他属性呢 就是我写了一个内的时候 我首先会思考他的属性

09:38.840 --> 09:44.920
好 想了想去好像也没有什么属性了啊 什么变形啊 以自动移动啊 跟你没关系

09:45.480 --> 09:50.680
你现在就考虑个小方块 这个小方块他有坐标有颜色 完事了

09:51.800 --> 09:53.240
好 写好了之后呢

09:54.200 --> 09:59.880
写好了之后 那么这里呢 我跟大家说一个 我还有一个代码书写的习惯

10:00.600 --> 10:03.480
在c sharp 也好 还是加把也好

10:04.440 --> 10:10.840
这些传统的面向对象语言里边呢 在书写一个内的时候呢 往往有这么一种书写习惯

10:13.240 --> 10:18.280
传统后端语言啊 传统面向对象语言

10:19.960 --> 10:21.800
面向对象语言

10:22.520 --> 10:37.400
书写内的属性时 往往会进行如下操作 什么操作呢 第一步 所有的属性全部私有化

10:38.520 --> 10:43.240
不允许外边的人 外面的代码去访问到 直接访问到这个内的属性

10:43.720 --> 10:48.920
所有的属性全部私有化 注意 我这里说的是全部 对 说的就是全部

10:49.640 --> 10:57.240
第二步 使用公开的方法 提供对属性的访问

10:59.260 --> 11:03.020
无论是加把还是c sharp 他们都有这么一个就是书写习惯

11:03.660 --> 11:06.940
把所有的属性全部私有化 为什么不让外面的访问

11:07.980 --> 11:10.220
为什么不让外面的访问 你想想这个道理

11:11.100 --> 11:16.940
因为有的时候呢 你外边访问的时候 访问这个属性的时候 可能会有些属性是不能

11:17.260 --> 11:21.580
是只能自己内部进行处理的 你不希望外面访问到 这是一部分

11:21.980 --> 11:27.100
另外一部分呢 如果你希望外面能访问的属性 我希望能够进行控制

11:27.260 --> 11:31.820
你跟他复职的时候 我可能要做一些事情 要做一些判断或者是要做一些额外的事情

11:32.220 --> 11:38.460
你得到他的职的时候呢 我可能要经过一些处理等等等等 你甭管现在有没有这个处理

11:39.020 --> 11:46.380
你把这样事情做了 江南你要做处理的时候你就很简单了 你就不用去到处改代嘛

11:47.260 --> 11:54.220
那么这里有哪些写法呢 加瓦里面的写法是这样子写的 先不用管冒错 因为那些人没有出事话不用管这个

11:55.340 --> 12:01.740
加瓦的解法是这样子的 当然私有属性的话 私有属性全部加下法宪啊 这是个命名习惯

12:02.540 --> 12:03.820
私有的属性全部加下法宪

12:04.620 --> 12:09.820
好 加瓦里面是这样子写的 比方说这个x这个属性啊 x这个属性

12:10.220 --> 12:15.100
那么加瓦呢 加瓦好像里面 加瓦的习惯里面不加下法宪 加瓦还是这样子写的

12:15.580 --> 12:19.980
啊 属性全部私有法过后对x呢 我提供一个公共的方法啊 当然

12:20.700 --> 12:24.940
在ts里面你不写这个东西 默认就是公共的 对吧 getx

12:26.220 --> 12:29.740
return this x 然后再写一个函数

12:30.700 --> 12:35.660
set x 设置x的值 把值传进来 然后return

12:36.540 --> 12:40.460
x 等于1 当然这里要限制一下啊 来吧

12:41.420 --> 12:46.220
啊 这是加瓦里面的写法啊 csharp里面的写法呢 它是使用访问器

12:46.860 --> 12:50.460
就看自己书写习惯了啊 无所谓的 都一样一样的意思

12:51.340 --> 12:57.420
csharp里面的写法使用的是访问器啊 然后这里才成x 而return是什么下法宪x

12:57.900 --> 13:04.060
好 这里呢set x 访问器我们学过的 对吧 学过的啊 那么这个这个地方让他自己推到就行了

13:05.980 --> 13:09.980
加瓦里面使用的是啊 就是函数

13:10.620 --> 13:15.020
普通的函数 那么csharp里面的使用的是访问器 看各自的习惯

13:15.420 --> 13:19.820
都可以啊 都可以 本质上没有什么区别 总之让他得到属性值

13:20.380 --> 13:25.900
和设置属性值的时候 要经过一个函数来处理 而不是直接访问属性值

13:27.020 --> 13:28.940
ok啊 我把这个地方解释清楚

13:30.380 --> 13:35.180
好 写到这的时候呢 就是我们不着急啊 慢一点写 写那么慢一点稳一点

13:36.140 --> 13:38.140
好 这里的时候呢 我们发现这里有坐标

13:39.100 --> 13:41.820
x 坐标和 y 坐标 这个地方有一个经验

13:42.860 --> 13:47.660
就是坐标这个东西啊 你会发现咱们在系统里边到处都会用的

13:48.220 --> 13:51.660
啊 一会我们把这个方块的组合 他也有坐标 对吧 也有坐标

13:51.900 --> 13:55.340
我们可以想象的到咱们的游戏里边可能到处都要用到坐标

13:55.820 --> 14:02.620
那么坐标里边还一定包含一个横坐标 一定包含一个重坐标 还一定有这么一个关系

14:03.260 --> 14:05.580
咱们系统里边坐标一定是一个横坐标一个重坐标

14:06.060 --> 14:09.340
注意 我们说的坐标始终记住啊 是逻辑坐标

14:09.900 --> 14:13.740
逻辑坐标而不是真实的在DHV里面坐标 现在不要去想见面

14:14.780 --> 14:21.820
好 假设我们的游戏里边有很多地方都要用到坐标 那么这个地方呢 我们就可以把这个坐标啊

14:22.380 --> 14:27.980
专门的来做成一个类型啊 专门的来做成一个类型啊 这是个公共类型

14:28.380 --> 14:33.740
好 这个公共类型呢 我们可以写到哪呢 可以写到啊 在这里面建立一个文件吧

14:34.220 --> 14:37.340
来取名为common 啊 或叫做taps

14:38.220 --> 14:43.340
taps 啊 写这么一个文件 这个文件里边呢 导出一个类型

14:44.220 --> 14:51.420
这个类型我就可以用什么 类型别名或者是接口都可以做啊 比方说用接口吧 用接口

14:51.900 --> 14:58.460
好 给他取个名字叫point 表示一个坐标 坐标里边呢 必须要包含两个属性 一个是x

14:59.420 --> 15:00.780
啊 一个是y

15:01.900 --> 15:03.260
啊 一个是x 一个是y

15:04.460 --> 15:09.820
好 有了这么一个类型过后呢 那么这里小方块的坐标我就可以怎么写呢 我就可以这样子写

15:11.820 --> 15:13.180
啊 下法线point

15:13.900 --> 15:18.780
point 然后呢 类型是什么 类型是point 把内向导入进来

15:20.140 --> 15:26.940
好 导入进来过后呢 同样的道理 你要设置坐标啊 你要得到坐标应该使用啊 访问器也得到

15:27.900 --> 15:33.420
通过访问器也得到坐标 你要设置坐标呢 也可以设置 不是不让你设置啊 可以设置

15:33.740 --> 15:36.940
设置坐标呢 你要通过访问器来设置point

15:37.900 --> 15:39.500
这也是point

15:43.300 --> 15:47.380
明白这个意思吗 好 这样子写了过后 按照经验

15:47.860 --> 15:50.260
我们知道这一块呢 有可能会出现隐患

15:50.980 --> 15:53.140
什么隐患啊 什么隐患

15:53.860 --> 15:59.780
大家看一下 有可能会发生这么一件事 你看现在我们的考虑问题就考虑的是非常非常全面了啊

16:00.340 --> 16:04.580
因为我们现在要想到我们在开发一个特别特别大型的一个系统

16:04.820 --> 16:08.420
我这个代码不知道会被哪些人用 他们用的时候会不会出问题

16:09.300 --> 16:12.900
有可能会遇到这么一种情况 我去设置坐标的时候 你看

16:13.460 --> 16:17.780
我去给他复制的时候 是不是就一定啊 就一定会经过一个函数 对不对

16:18.100 --> 16:21.460
会经过一个函数 这个没有什么问题 会经过一个函数

16:21.860 --> 16:24.500
但是我能不能绕开这个函数给他复制呢

16:25.300 --> 16:28.980
实际上是可以的 实际上是可以的 怎么做的

16:29.860 --> 16:30.980
第二 x

16:31.940 --> 16:36.180
你看这样子 我给他x复制 给他y复制 是不是绕开了这个函数

16:37.620 --> 16:40.900
绕开了这个函数 我只有直接对这个属性复制的时候

16:41.220 --> 16:46.660
那么才会经过这个函数 通过这样的复制是不是绕开了函数 我们我们又不能得到控制了

16:47.300 --> 16:50.260
那么这里怎么办呢 这里有很多种办法

16:51.460 --> 16:54.420
其中能够想到了有两种 第一种办法

16:55.540 --> 16:56.580
你把这个point

16:57.540 --> 16:58.980
做成一个内

16:59.700 --> 17:01.940
这个内里面呢 在继续用这种方式来控制

17:02.260 --> 17:06.180
这个内里面不是有x和y 是个两个属性吗 对x和y的复制呢

17:06.500 --> 17:09.540
你也进行控制 也进行控制 这是第一种办法

17:10.100 --> 17:13.780
第二种办法就很简单 你把这个x和y 加上一个瑞的 only

17:15.060 --> 17:15.540
止读的

17:16.660 --> 17:19.220
想复制没门 止读的

17:19.780 --> 17:24.580
你只能出函数字话 你要么就复制一个整个对象 你不可能给他更改这两个属性的

17:25.060 --> 17:29.140
变成了止读 变成止读之后你看一下 我们之后对point的复制

17:29.780 --> 17:34.580
是不是只能这样子复制的 我给他复制一个新座标x的座标为多少 比方说

17:35.700 --> 17:39.140
y的座标为多少为4 我只能用这种方式复制的

17:39.300 --> 17:44.180
你看了没 这种方式一复制复制过来的时候是不是会经过一个函数 我们就能控制了

17:44.660 --> 17:47.620
明白吧 这一切的目的都是为了达到

17:48.180 --> 17:51.620
我这个内里边的属性要得到我自身的严格控制

17:52.100 --> 17:57.620
不能让别人随意的操作 虽然现在我没有对他进行任何的控制 我只是简单的返回值

17:57.940 --> 18:04.100
简单的设置值 但是将来我一旦希望对他进行控制的时候 我可以非常轻松的进行处理

18:05.140 --> 18:06.980
我就不用改其他代码了 其他代码不变

18:07.700 --> 18:08.340
明白这个意思吗

18:09.140 --> 18:11.780
OK 我们这里有个数据写官啊 大家注意啊

18:12.180 --> 18:15.780
好 这里呢 我已经写了一个point了 再写个color啊 把color也写上

18:16.660 --> 18:17.060
颜色

18:17.700 --> 18:19.220
好 比方说颜色啊 这一块

18:20.180 --> 18:23.060
颜色一个小方块的颜色他有没有可能会变化

18:24.100 --> 18:30.020
啊 有没有可能会变化 在我们目前的这个系统中 会发现这个小方块的颜色是不能变化的

18:30.500 --> 18:34.820
那么不能变化的话 既然他不能变化 你看我会怎么做呢

18:35.540 --> 18:38.660
我会怎么做 我就只写个gather 不写set

18:41.380 --> 18:43.940
我就只写个gather 而不去写这个set

18:44.180 --> 18:44.900
明白这个意思吗

18:45.860 --> 18:50.500
OK啊 把这个地方说明白 比方说这里 你看我就做出了一个指读的属性

18:51.460 --> 18:54.260
我创建一个小方块啊 一个小方块的对象

18:55.220 --> 18:58.500
以前的gather是能玩这些事情吗 玩不了

18:58.980 --> 19:02.820
所以说里面学习前段的时候谁会 哪会听到这些东西啊 听不到的

19:02.820 --> 19:05.860
因为以前的gather是玩不了这些东西 但现在可以玩了

19:06.340 --> 19:10.980
有了ts可以玩了 那他现在就得到了严格的控制 你不可能负责

19:11.540 --> 19:14.500
那么现在呢 我们就认为这个内非常的安全

19:15.620 --> 19:21.140
你随便怎么搞 随便怎么搞 都会经过我的控制 我始终对这个内保有控制权

19:22.340 --> 19:27.060
好 写好这个内过后了 现在包两个错误啊 都是没有出使值 对吧 没有出使值

19:27.380 --> 19:31.940
那我现在认为呢 你要创建一个小方块 你得把你得把这个

19:32.420 --> 19:37.860
什么 作标给我 把颜色给我 对吧 OK 那么我们这里可以写个勾到函数

19:39.220 --> 19:41.780
public constrater 当然你不写public也是一样

19:42.500 --> 19:45.220
public constrater 这里面呢 你要告诉我什么

19:45.940 --> 19:51.220
我们就可以通过这种简写属性啊 就是勾到函数面的属性列表来进行书写

19:51.460 --> 19:55.060
public 还有什么private 下发写color

19:56.340 --> 19:57.860
stream

19:59.460 --> 20:03.060
通过这种简写来生成这么两个私有属性

20:03.940 --> 20:10.180
所以说以后我们写内的时候 我会按照面向对象的这种操作习惯 把所有的内

20:10.660 --> 20:16.900
私有化 全部私有化 所有的属性全部私有化 扔出来的全是方法 全是返回器和方法

20:18.020 --> 20:21.780
好 现在呢 我们写好了这么一个小方块的内

20:22.900 --> 20:27.140
接下来的问题是啊 我先测试一下吧 测试用一下

20:27.700 --> 20:31.220
好 我在index里面测试一下啊 index里面去导入这个小方块

20:32.260 --> 20:38.820
sqnu一个square啊 要传入什么呢 你不传行不行啊 ts有严格类型检查 你不可能不传的

20:39.220 --> 20:42.340
第一个坐标 坐标的话就比方说你啊你

20:43.060 --> 20:48.660
一个坐标嘛 对不对啊 然后呢颜色啊颜色该传什么呢 比方说随便传一个吧 红色

20:50.740 --> 20:55.460
这写的是啥呀 一个手啊 你看一下我有没有可能导致

20:56.180 --> 20:59.140
导去犯错误 有没有可能犯错误 我想

21:00.020 --> 21:02.260
当然不存 使用不存在的属性是不可能的 对吧

21:03.060 --> 21:08.100
破引者x负责行吗 不行 那不行的话怎么办呢 我自然会想办法

21:08.420 --> 21:12.660
哦 你这样子不行 他为什么不行 我只能看一下啊 就是假设别人在使用你的代码

21:13.140 --> 21:17.380
别人在使用你的代码的时候 他就会发现这样做是有问题的啊 你不用去靠喊

21:17.620 --> 21:21.460
你不用去靠文档 他马上就发现问题了 他说x是指读的

21:22.020 --> 21:26.180
那咋办呢 那咋办呢 他就跑来问你啊 你这个东西能不能收成不

21:27.860 --> 21:30.900
不能指读啊 可以干负责 你说不行 你自己想办法

21:31.300 --> 21:33.940
那想来想去怎么办 只能给他整个负责

21:34.660 --> 21:38.340
而他整个负责的时候是不是经过了一个函数 我在函数里面就可以控制

21:38.740 --> 21:44.500
啊 就可以对他进行控制 要外面是使用始终是保证外面的使用不会乱使用一定是安全的

21:44.980 --> 21:45.700
比如他这个意思吗

21:47.060 --> 21:48.980
好 接下来我要说的是显示

21:49.780 --> 21:56.180
怎么去把显示出来啊 当然现在显示呢 我们这节这个小节啊还不还没有涉及到显示到页面上

21:56.820 --> 21:58.100
怎么把他显示出来呢

21:58.900 --> 22:00.020
注意我刚才说的

22:00.340 --> 22:04.180
我们这里呢会使用数据界面分离模式

22:04.820 --> 22:06.900
就是我这个方块里边

22:07.140 --> 22:12.820
他如何去做显示跟他没有任何关系 他只控制控制数据

22:13.300 --> 22:21.780
那么但是呢 这里边呢 他这里边呢 他知道一件事 就是什么时候我需要进行显示

22:22.020 --> 22:25.380
什么时候我需要进行显示 他知道这么一件事

22:25.860 --> 22:28.180
就他不知道怎么显示 他显示到控制台

22:28.260 --> 22:37.140
还是显示到手机上还是显示到这个窗体上还是显示到页面上 他并不知道怎么显示他不知道

22:37.380 --> 22:39.700
我们再记一笔吧 把他梳理一下

22:40.980 --> 22:47.380
这是我们今天的这个第一个小节啊 开发小方块

22:48.660 --> 22:53.780
这个小方块里的一个特点啊小方块的一个特点

22:54.500 --> 22:58.660
就是他能处理自己的数据 他是处理数据的

22:59.540 --> 23:02.900
知道什么时候需要显示

23:03.460 --> 23:05.140
他知道什么时候需要显示

23:05.780 --> 23:06.900
但不知道

23:08.020 --> 23:08.980
但不知道

23:10.260 --> 23:11.860
呃 怎么显示

23:12.500 --> 23:13.700
他有这么一个问题

23:14.980 --> 23:17.300
什么时候需要显示呢 这个很清楚

23:17.700 --> 23:19.380
就跟咱们学习的无忧是一样的

23:19.940 --> 23:21.140
你数据变了

23:21.620 --> 23:23.300
你数据变了是不是要显示

23:24.260 --> 23:26.020
你这个坐标变了是不是要显示

23:27.380 --> 23:30.500
对不对 好在这里应该完成显示功了

23:32.020 --> 23:35.940
完成显示就要重新渲染一次嘛 对吧 就跟伍佑和reactor一样

23:36.100 --> 23:38.500
我数据变化了 你看你在设置坐标嘛

23:38.660 --> 23:41.060
他的坐标变化了 你是不是要该重新显示呢

23:41.140 --> 23:42.420
这里要完成显示

23:42.420 --> 23:45.620
但是呢 我现在是不知道该怎么显示 我显示到控制台

23:45.940 --> 23:48.980
还是显示到页面上 你千万不能在这里面去写什么

23:49.220 --> 23:53.540
去写什么Jquery代码啊 去写什么控制台代码跟显示相关的代码

23:53.860 --> 23:54.500
不要去写

23:55.620 --> 23:59.860
这里该怎么显示呢 我们可以使用一种非常高级的办法

24:01.220 --> 24:04.900
怎么办法呢 就是在这个内里边啊 再给他加一个东西

24:05.460 --> 24:06.900
就是显示者

24:07.540 --> 24:09.140
因为这里呢 我们需要一个属性

24:09.860 --> 24:12.180
属性显示者

24:12.580 --> 24:16.580
他专门来负责完成显示 我不来管理这个事情

24:16.980 --> 24:19.140
你只需要你来帮我完成显示就行了

24:19.780 --> 24:23.540
好 那么既然写到属性这一块呢 我们需要对这个显示者

24:24.100 --> 24:25.780
需要判断一下他什么类型呢

24:26.500 --> 24:30.500
你这个显示者是志无穿吗 肯定不是 是数字吗 肯定不是

24:30.900 --> 24:32.740
那你这个显示者到底是什么东西呢

24:33.140 --> 24:40.020
我们可以用一个接口来完成这样的一个约束 约束一下显示者应该是一个什么东西

24:40.740 --> 24:42.580
好 我这里可以再导出一个接口

24:42.900 --> 24:45.860
也是破车 在这个公共内心里边导出个接口

24:46.500 --> 24:49.940
给他取个名字啊 叫做IvU

24:50.820 --> 24:52.420
IvU 表示显示者

24:52.980 --> 24:53.940
这个显示者呢

24:55.540 --> 24:59.700
我们给他认为他只要是一个显示者啊 或者是IvU2

25:01.380 --> 25:02.500
表示是一个显示者

25:03.700 --> 25:09.300
这个显示者里边他有这么一些成员 你至少得有两个函数 一个函数是秀

25:10.900 --> 25:13.860
把它显示出来 我就不管你是怎么实现的了啊

25:14.260 --> 25:16.900
不管你是怎么实现 你总之也要把它显示出来

25:17.620 --> 25:19.060
第二个函数呢 是remove

25:19.620 --> 25:21.540
移除掉 就是不再显示

25:21.860 --> 25:24.660
不再显示 你至少得用这么两个函数

25:25.060 --> 25:26.820
这是使用接口的形式

25:27.460 --> 25:32.020
能不能把它做成一个内呢 也可以啊 也可以 就看你自己怎么去弄了啊

25:32.420 --> 25:37.060
也可以 做成内也行 做成接口也可以啊 我这里比方说就使用接口吧

25:37.780 --> 25:40.100
好 使用接口的话 我该打个注释啊

25:40.500 --> 25:42.340
这个函数表示显示

25:42.900 --> 25:45.220
就是做显示 你去显示吧 我管你怎么显示的

25:45.700 --> 25:50.740
这个函数表示移除 就是不再显示的 移除 不再显示

25:52.580 --> 25:53.380
不再显示

25:54.020 --> 26:00.820
OK 我就给它设置通过这么一个IvU2这个接口来约束它能不能进行显示

26:01.060 --> 26:03.460
能不能进行显示 怎么能进行显示

26:04.340 --> 26:08.500
好 这样子做了之后呢 你看我这里边就可以这样来处理

26:08.820 --> 26:12.100
我写个属性 当然属性全部为private

26:12.820 --> 26:14.100
好 给它取个名字

26:14.340 --> 26:17.140
v2显示者

26:17.460 --> 26:21.540
v2什么意思啊 就仕途对吧 仕途v2呢 就是处理仕途的人

26:22.100 --> 26:25.060
好 那一型呢 就是IvU2

26:26.180 --> 26:29.220
这个呢 我可以给它做成一个可选的啊 可选的一个属性

26:29.460 --> 26:33.380
你可以设置 可以不设置 设置到过后呢 我就有显示者了

26:33.620 --> 26:36.180
没有设置呢 我就没有显示的 我就不显示

26:36.500 --> 26:39.700
对不对 是可以做这么一个设置啊 做成个可选属性

26:40.660 --> 26:45.060
那么有了这个属性之后呢 我们还是同样的啊 给它做一个访问器

26:45.860 --> 26:47.060
public get

26:47.380 --> 26:50.260
你会发现现在我们代码写的就比较多了 对吧

26:50.500 --> 26:55.220
相比以前的代码的话会多一些 但是我们现在代码写的非常非常稳

26:56.180 --> 27:00.420
v2 return this v2

27:02.180 --> 27:06.020
啊 这里public set v2

27:06.740 --> 27:11.940
v2 return this v2

27:13.540 --> 27:15.540
好了 我们写好了两个访问器

27:15.860 --> 27:21.460
那么之后呢 给它复制也可以给它复制也可以读取这个显示者啊 到底是谁 谁在做显示

27:22.260 --> 27:24.980
好了 有了显示者过后呢 你看咱们后边

27:25.380 --> 27:28.340
当我要去完成显示的时候 就咱们这个内啊

27:28.580 --> 27:33.780
它知道什么时候完成显示 什么时候呢 就当作标发生变化的时候是不是要完成显示

27:34.100 --> 27:39.540
对不对 这个时候要完成显示 完成显示的时候呢 我做什么呢 我做啥呢

27:40.820 --> 27:43.300
调用啊 找到这个v2

27:44.100 --> 27:45.300
啊 看一下它是不是

27:46.100 --> 27:49.220
看一下啊 可以在这里判断一下 判断一下它有没有值

27:49.780 --> 27:53.540
如果有值的话啊 就表示它有一个显示者 怎么办呢

27:55.540 --> 27:58.420
显示出来 把它显示出来 就是这么一件事

27:59.060 --> 28:00.340
明白这个意思了吗

28:00.500 --> 28:08.420
ok 那么现在呢 我们整个程序呢 它的逻辑含义啊 就跟以前我们学习过的这个rex就很相似了

28:09.300 --> 28:14.980
rex里边 我们在使用它的时候 我们当时还记得吗 我们使用了两个库

28:15.220 --> 28:17.060
一个是rex 一个是rex动

28:17.940 --> 28:20.820
为什么它要把它分成两个 不把它做成一个呢

28:21.700 --> 28:24.500
因为rex处理的是核心的逻辑

28:25.220 --> 28:29.460
它跟界面没关系的 它处理的是响应式啊 我怎么来

28:30.500 --> 28:37.380
就是生成虚的动物数 怎么来进行对比 处理的是这些逻辑而具体的显示是交给这个库的

28:38.020 --> 28:44.020
那么也就意味着我在核心逻辑保持不变的情况下 我的显示是可以替换掉的

28:44.580 --> 28:48.420
比方说这个东西可不可以替换成rex native呢

28:49.460 --> 28:54.260
学过没有这个东西啊 这是手机端应用的开发啊 开发手机端手机端应用的时候

28:54.660 --> 28:56.180
那么可以把它替换成这个东西

28:56.900 --> 29:00.500
这个东西是显示到页面上的 这个东西是显示到手机上的 你看没有

29:00.980 --> 29:04.420
核心逻辑可以保持不变 那么咱们这里的也是一样

29:05.460 --> 29:12.180
我们在处理这个问题的时候 具体怎么显示 交给你去完成 我不管 你只要设置了它我就可以完成显示了

29:13.460 --> 29:17.780
好 你看到吗 这个代码啊 好好去理解一下啊 好好去理解一下这个代码

29:18.660 --> 29:20.260
再过一遍啊

29:21.620 --> 29:26.420
好 这个代码写好了之后呢 咱们再去测试一下 你看我们去怎么去用它

29:27.460 --> 29:28.820
我创建了这么一个square

29:29.460 --> 29:33.940
好 这个square里边怎么显示呢 我可以这样子来处理

29:34.900 --> 29:38.660
给他设置一个5u2 给他复制一个5u2

29:39.300 --> 29:40.260
他应该复制为什么

29:41.060 --> 29:46.020
我们指着他看 他应该复制为要么是undefine 要么是一个实现一个接口的东西

29:46.180 --> 29:48.500
i5u2 实现这么一个接口的东西

29:49.060 --> 29:55.140
ok 来吧 那么实现这个接口呢 我就可以写个内啊 或者是一个对象啊 直接约束为这个接口也行

29:55.860 --> 30:00.820
比方说写个内吧 给他取个名字 叫square 就是方块的控制台

30:01.780 --> 30:03.940
5u2 控制台显示内

30:05.060 --> 30:10.900
他去实现 你看接口叫做契约 什么叫契约 有强约束力

30:11.620 --> 30:16.740
那么现在呢 你要做一个显示 对吧 应该你要做一个显示 ok 那么我就

30:17.940 --> 30:19.540
把这个东西实现接口

30:20.020 --> 30:24.100
我就去写这么一个内 让他去实现这个接口 那么他就完成显示对不对

30:24.900 --> 30:28.980
好 这里面有两个函数你必须要 你两个方法必须要实现怎么显示

30:29.620 --> 30:33.220
好 怎么移除对不对 有两个东西必须要实现

30:33.540 --> 30:36.740
那么怎么去实现呢 比方说这里我要显示一个小方块

30:37.060 --> 30:39.460
那么显示小方块的时候 你是不是要告诉我一个

30:40.180 --> 30:43.620
方块对象啊 你是不是要告诉我一个方块对象 对不对

30:44.260 --> 30:48.660
好 那么你怎么来告诉我这个方块对象呢 你可以通过构造函数来告诉我

30:48.980 --> 30:53.700
你可以通过构造函数来告诉我这个方块对象 当然呢 你也可以有很多 这有很多种做法啊

30:54.100 --> 31:00.100
有很多种做法 比方说你可以通过构造函数来告诉我也可以通过传递参数来告诉我

31:00.980 --> 31:06.900
都行都行 那么传递参数的话 你需要改一下这个接口的这里的签名啊 这里要加个参数

31:07.860 --> 31:11.460
好 那么这里呢 我通过构造函数来告诉我吧 比方说这里

31:12.660 --> 31:14.660
constructor

31:15.300 --> 31:21.540
好 这里呢 我写这么一个属性 私有的啊 属性都是私有的啊 你给我一个什么呢 给我一个方块对象

31:22.660 --> 31:25.380
square square方块对象

31:27.420 --> 31:33.420
啊 一只要给我一个方块对象我是不是就能显示的 怎么显示 我这里控制台吗 我就显示出啥呢

31:33.900 --> 31:35.900
显示出 res square 点

31:37.260 --> 31:42.780
point 显示出来 然后再显示 res square 点 怎么呢

31:43.500 --> 31:48.060
颜色显示出来 我就把这两个显示控制台就完事了 显示控制台就完事了

31:48.460 --> 31:52.380
好 咱们来看一下啊 怎么来用啊 咱们写了好这么一个显示的内

31:52.860 --> 32:00.460
那么就由他来负责进行显示 好 我这里呢 就给他这个显示者负责为啥呢 负责为六一个square

32:00.940 --> 32:07.260
console 512 啊 要传个对象进去 传哪个呢 就把这个我要显示这个方块传进去

32:08.140 --> 32:14.860
要显示这个方块 好传进去过后呢 咱们来看一下啊 来看一下啊 我们这里呢

32:16.780 --> 32:25.020
改变他的坐标啊 改变他的坐标啊 x 等于5 y 等于6 看一下能不能完成显示啊 老存一下

32:26.940 --> 32:28.620
啊 看一下能不能完成显示

32:30.940 --> 32:39.580
啊 这里我们 npm 不是 npm 装啊 这个应该使用是 npm 装

32:40.060 --> 32:43.660
dev 在浏览器中打开 咱们来看一下啊

32:45.340 --> 32:50.890
打开这浏览器 现在我们只看控制台啊

32:52.570 --> 32:57.130
啊 你看是不是显示出来了 现在显示到控制台里边了啊 在刷新式 你看

32:57.610 --> 33:00.970
我们当我们改变坐标的时候 他就显示到控制台里边了 看到没

33:01.770 --> 33:06.010
好 有些同学说可能说啊 你当你这里我一开始要完成显示怎么办呢

33:06.330 --> 33:13.370
那还不简单吗啊 你创建对象之后呢 你设置好了5u2 那么先显示一次呗 对不对 可以使用5u2秀

33:13.930 --> 33:16.410
先显示一次啊 保存一下

33:18.010 --> 33:21.770
啊 你看一开始的结果也显示出来了啊 然后这个东西也显示出来了

33:22.410 --> 33:26.410
好 比如我们后边改变坐标 每一次改变坐标他都会导致他重新显示

33:26.890 --> 33:31.850
好 当然呢 这里呢 这是一种做法啊 不管你用什么样的做法啊

33:32.810 --> 33:38.650
他的原理和思路都是一样的 这样为什么要这样子写 因为这个显示是可以变化的

33:38.970 --> 33:44.730
将来我们要显示到页面上 我问大家一个问题 将来我要显示到页面上 我们需不需要去动这个呢

33:45.610 --> 33:48.170
动这个也需不需要去动 所以不需要

33:48.890 --> 33:53.770
完全不需要去动这个东西 完全是不需要的 那么我们动谁呢

33:54.490 --> 33:59.050
动谁呢 我们只需要去添加一个内啊 添加一个功能

33:59.370 --> 34:04.490
然后呢 把它作为显示者 负责给他就行了 比方说我们要要显示到页面上 我们再写个内

34:04.730 --> 34:09.130
专门做页面上显示的 OK 那么再给他负责 负责完了过后

34:09.370 --> 34:14.170
那边的功能不够了 然后我们再写一个页面上 然后我们再写一个页面上

34:14.490 --> 34:19.930
OK 那么再给他负责 负责完了过后 那边的功能不变 那边的功能是不变的

34:20.410 --> 34:25.930
明白这个意思了吗 因此呢 这里的好处在什么呢 好处在于我们之前说的

34:27.050 --> 34:34.330
开闭原则 对扩展开放 扩展功能我们要做新的显示到 显示到手机端 显示到页面上

34:34.810 --> 34:38.090
那么我们去加新的内就行了 对修改关闭

34:38.810 --> 34:42.330
不用去修改这个内 这个内的功能已经做好了不变了

34:42.970 --> 34:49.530
对吧 其实这里的做法有很多啊 比如说我这个属性是不是一定要写到构造函数里面呢 不一定啊 不一定

34:49.850 --> 34:52.730
比方说我这里 我可以完全不写到构造函数里面

34:53.290 --> 34:58.250
我写到外边也是一样的 不是说必须要用什么样的做法 我可以不写构造函数啊 其实我也不太

34:59.370 --> 35:06.090
特别太喜欢写构造函数啊 我也写这种做写法也是非常常见的 你给他复制默认值呗 比方说

35:07.530 --> 35:10.090
point 给他复制默认值啊 默认值

35:11.050 --> 35:11.530
x

35:12.490 --> 35:16.090
x 不要说0 默认值 x和y都是0

35:17.450 --> 35:21.450
然后呢 卡的呢 给他复制一个默认值啊 复制一个默认值以控制武创

35:22.010 --> 35:26.010
等等等等 都可以啊 都可以 总之呢 你

35:26.570 --> 35:30.650
那么这边 这边没有构造函数了过后呢 这边就可以用这种方式了

35:31.210 --> 35:38.330
创建一个对象 然后给他复制一个维吾尔啊 那么之后呢 先不做 先不做显示 之后每次给他做标复制

35:38.570 --> 35:40.330
他都会重新选择 重新显示

35:41.610 --> 35:48.010
重新选择 重新显示 当然他现在没有颜色啊 没有颜色啊 当然如果你这样做了过后 你颜色是不是要

35:48.410 --> 35:57.050
要去设置一下啊 对不对 你颜色这里要把它设置一个防蚊器 总之要做法很多啊 但是核心的思路呢 都是完全一样的

35:57.530 --> 36:03.770
核心的思路是完全一样的 这里呢 我把颜色给他加上吧 就看你自己啊 这些做法其实无所谓的

36:04.090 --> 36:09.050
这是不是很重要 重要的是这种模式 这种思考问题的方式

36:10.890 --> 36:19.670
啊 这是好 那么我们形成这个样子啊 其实用刚才够早喊说野熊野熊了 没有什么问题的

36:20.630 --> 36:24.230
好 大家看一下这个代码啊 我把快速这样子浏乱一遍

36:25.110 --> 36:28.390
看一下这个代码 然后再看一下我们的公共内容

36:28.950 --> 36:32.790
看一下这个代码 好再看一下这边的 赢那个时候测试的代码

36:33.590 --> 36:39.590
那咱们看一下啊 下来过后这个小节结束了 这个小节结束过后呢 大家下来

36:40.150 --> 36:42.710
好好去体会一下这种开发思路

36:43.590 --> 36:49.430
啊 这当然这里remove没写啊 没有写 因为我们下个小节就要开始写这个实现了

36:50.070 --> 36:57.190
开始写这个显示者啊 下个小节开始写了 因此呢 这里呢 大家好好去体会一下啊 体会一下这一块的开发思路

36:57.910 --> 36:58.950
好 下来过后

36:59.590 --> 37:05.990
把这个代码完成啊 你可以 你说甚至可以把这个代码抄一遍 但是抄的过程中 你要去思考

37:06.310 --> 37:09.190
为什么我要这样子写 这样子写到底有什么样的好处

37:09.990 --> 37:15.590
好吧 ok 我们开发这一课 我们开发完了这么一个小方块 这么一个核心的内 并且呢

37:16.070 --> 37:18.710
可以把它显示出来啊 可以把它显示出来

37:20.070 --> 37:23.510
好 那么这可以到这里了啊 下节课我们来开发

37:23.510 --> 37:28.070
对小方块的页面显示者把它显示到页面上

