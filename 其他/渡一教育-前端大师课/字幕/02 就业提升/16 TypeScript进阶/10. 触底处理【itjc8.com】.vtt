WEBVTT

00:01.200 --> 00:06.060
咱们这个游戏已经进入到了尾声

00:06.320 --> 00:08.360
所以大家一定要坚持

00:08.620 --> 00:15.020
可能大家游戏同学呢学到这一块就感觉已经非常非常难了 特别是上级可开发游戏类啊

00:15.280 --> 00:18.600
开发旋转功能啊就觉得已经非常非常难了

00:18.860 --> 00:20.140
其实这些难度啊

00:20.920 --> 00:27.060
我觉得大部分是这个游戏本身带过来的难度而不是面向对象带过来的难度

00:27.560 --> 00:30.380
而面向对象的实际上是降低了它的难度

00:30.840 --> 00:33.700
咱们把这个游戏坚持做完

00:33.960 --> 00:36.780
做完过后呢我拿一些课来进行总结

00:37.300 --> 00:39.080
就是说我们做这个游戏啊

00:39.340 --> 00:42.420
我们开发用这种开发方式做出来的游戏

00:42.680 --> 00:46.260
质量是非常非常高的不光是能够把效果实现

00:46.520 --> 00:53.680
而且呢它将来一旦功能发生了变化或者是见面发生了变化以后我们要把它放到手机端

00:53.940 --> 00:54.960
要把它放到

00:55.220 --> 00:59.820
或者是用rex来实现用vue来实现都是非常非常好歉意的

01:00.280 --> 01:01.300
所以说我们

01:01.560 --> 01:04.900
通过开发这个游戏着重探讨的是

01:05.660 --> 01:06.680
开发方式

01:06.940 --> 01:08.220
而不是这个游戏本身

01:08.740 --> 01:13.340
有些难度呢是这个游戏本身带过来的你用什么样的方式都解决不了这种难度

01:13.600 --> 01:15.380
本身难度是解决不了的

01:15.640 --> 01:17.440
而且呢用面向对象的话

01:17.700 --> 01:20.500
反而容易降低他的难度而不是增加他的难度

01:20.760 --> 01:25.620
大家可以下来可以去尝试一下啊如果你有时间有兴趣的话

01:26.140 --> 01:29.720
你用以前的方式来书写我看你去怎么去书写的代码

01:29.820 --> 01:32.120
而且要保证他能够在各种环境下试用

01:32.380 --> 01:33.920
那你怎么去书写这个代码

01:35.700 --> 01:37.240
我们这里啊这节课

01:37.760 --> 01:39.800
我们之后在总结的时候再好好说吧

01:40.060 --> 01:44.920
这节课呢我们来继续来开发这个游戏其实已经东西已经不多了

01:45.180 --> 01:48.760
现在我们要做什么呢现在我们看一下现在目前的效果

01:49.020 --> 01:52.340
就是这个方块到了底部之后呢

01:52.600 --> 01:54.920
他还有一些问题我们开始

01:55.680 --> 01:59.260
到了底部过后他有个什么问题呢他没有切换

01:59.460 --> 02:00.740
下个方块出不来

02:01.000 --> 02:04.080
他是这么一个问题啊下一个方块出不来

02:04.340 --> 02:06.120
那么这个问题怎么解决呢

02:06.380 --> 02:10.980
包括啊什么胜负判断啊消除啊这些问题啊

02:11.240 --> 02:12.020
我们

02:12.280 --> 02:15.080
统一把它叫做触底触理

02:16.620 --> 02:17.140
触底

02:18.660 --> 02:19.700
接触的触

02:21.220 --> 02:22.240
接触的触

02:22.500 --> 02:23.020
触底

02:23.280 --> 02:26.600
我的普通话不是很标准大家应该能感觉的

02:27.060 --> 02:30.440
就是我第一节课就应该说的我的普通话也就这样了大家

02:30.700 --> 02:31.720
讲究了听吧

02:32.240 --> 02:38.120
至少呢你能够听得懂我在说什么但是呢普通话不是很标准啊我是成都人

02:38.380 --> 02:39.660
所以说

02:39.920 --> 02:40.680
给大家掏好歉啊

02:40.940 --> 02:44.260
不好意思这确实是我的问题但是我也确实改不了我也不想改

02:45.540 --> 02:47.340
就这么回事大家就

02:48.100 --> 02:49.380
按照这个听吧啊

02:49.640 --> 02:50.400
触底触底

02:53.970 --> 02:57.290
这个触底是什么意思呢就是方块什么叫触底

02:59.590 --> 03:00.110
触

03:00.370 --> 03:00.870
底

03:01.130 --> 03:06.250
就是当前方块我们要当前方块就是玩家可以控制这个方块

03:06.510 --> 03:08.030
啊当前方块

03:09.070 --> 03:09.570
啊

03:10.590 --> 03:11.370
到达

03:12.130 --> 03:13.670
到达最底部

03:13.930 --> 03:15.210
这个最底部啊

03:15.470 --> 03:18.530
他不一定是见面的最底部

03:19.050 --> 03:22.630
他有可能下面已经有方块了他也没法继续往下了对吧

03:22.890 --> 03:24.930
那么都是触底啊都是触底

03:25.450 --> 03:25.950
好

03:26.150 --> 03:29.490
那么我们先思考一个问题什么时候

03:30.250 --> 03:32.050
可能发生触底

03:32.810 --> 03:34.610
什么情况下可能会发生触底

03:35.130 --> 03:35.890
接触到底部

03:36.650 --> 03:37.430
什么情况下呢

03:38.190 --> 03:39.210
两种情况

03:39.970 --> 03:41.010
情况一

03:42.290 --> 03:45.370
自动下落啊慢慢的自动下落

03:45.610 --> 03:48.170
当达到一个点的时候就可能发生触底

03:48.930 --> 03:49.970
情况二

03:51.250 --> 03:53.290
玩家控制下落

03:53.550 --> 03:55.090
就是玩家手动控制他下落

03:55.390 --> 03:56.830
他也可能会发生触底

03:57.090 --> 03:59.390
也就是说触底这个行为啊

03:59.650 --> 04:03.230
发生的时间点一定是在下落这个阶段

04:03.990 --> 04:06.310
那么什么时候下落了自动他会有下落

04:06.570 --> 04:08.110
玩家控制会有下落

04:08.870 --> 04:11.430
从单一把里面反应的话那么就是这里

04:12.190 --> 04:14.230
当前方块自由下落

04:14.750 --> 04:17.310
那么这个方这个方块里面你看在这里

04:18.070 --> 04:19.870
移动当前这个方块

04:20.390 --> 04:21.670
往下移动一格

04:21.930 --> 04:23.710
那么这个时候是不是有可能触底

04:23.970 --> 04:24.470
对不对

04:24.930 --> 04:27.490
什么时候处理我们可以清晰的判断出来

04:27.750 --> 04:29.530
因为这个函数他返回了一个啥呢

04:30.050 --> 04:33.130
返回个布尔表示是否能往下移动

04:33.650 --> 04:36.210
如果这个返回的结果为force

04:36.970 --> 04:40.030
如果返回结果为force就是不能往下移动了

04:40.290 --> 04:41.570
那么这个时候是不是触底了

04:42.330 --> 04:43.110
啊触底了

04:44.390 --> 04:48.490
还有一种情况就是在玩家手动控制他下落的时候

04:48.750 --> 04:50.530
所以也有这种情况啊

04:50.790 --> 04:51.810
move directly

04:52.070 --> 04:53.090
move directly

04:53.350 --> 04:53.850
往下落

04:54.470 --> 04:56.510
直接下落过后是不是一定触底

04:56.770 --> 04:59.330
如果你是直接往下落的话啊落到最底部

04:59.590 --> 05:00.870
那么是不是一定触底了

05:01.390 --> 05:02.650
好所以说这个地方了

05:02.910 --> 05:04.210
这个地方也会产生触底

05:05.230 --> 05:08.030
如果你这里是一步一步往下落的话跟这里一样

05:08.290 --> 05:09.070
进行判断一下

05:09.330 --> 05:10.850
看是否能继续往下移动

05:12.130 --> 05:14.430
那么这里如果是直接move directly

05:14.690 --> 05:16.990
直接落到最底部那么他肯定是触底了

05:17.510 --> 05:19.550
这里两个位置都会产生触底

05:20.330 --> 05:22.890
好这是第一个问题解决了什么时候发生触底

05:23.870 --> 05:24.630
第二个问题

05:25.150 --> 05:26.170
触底之后

05:26.690 --> 05:27.450
做什么

05:28.470 --> 05:30.530
像你编写函数的时候呢

05:30.790 --> 05:32.050
所以通过这个练习啊

05:32.310 --> 05:34.370
大家可以训练很多的逻辑思维

05:35.390 --> 05:40.510
啊触底之后我们之前分析了什么时候触底就是什么时候去调用函数对不对

05:40.770 --> 05:43.070
其实这个地方我们就来说说的是什么了

05:43.330 --> 05:44.350
什么时候

05:44.610 --> 05:45.870
调用函数的问题

05:46.910 --> 05:48.710
好触底之后做什么是什么

05:48.950 --> 05:49.710
函数

05:50.710 --> 05:54.530
如何编写的问题

05:56.570 --> 06:00.930
好触底之后做什么呢我们首先写这么一个函数啊先把这个函数写出来

06:02.210 --> 06:03.490
private

06:03.750 --> 06:05.530
给他取个名字吧

06:05.790 --> 06:06.570
hit bottom

06:07.330 --> 06:08.090
hit bottom

06:08.350 --> 06:10.650
触底了触底之后的操作

06:11.930 --> 06:14.490
触底之后的操作

06:15.770 --> 06:18.850
ok那么这里触底那么肯定是要调用这个函数啊

06:19.310 --> 06:20.430
hit bottom

06:20.690 --> 06:24.430
触底之后的操作那么这上面也有触底我肯定是调用这个函数

06:24.690 --> 06:26.230
this hit bottom

06:26.990 --> 06:29.810
好触底之后有哪些事情要做了

06:30.830 --> 06:34.410
首先我们最容易想到的一个事情啊是什么事情了

06:34.930 --> 06:40.570
第一件事情就是或者不排序吧不排序我们之后再说顺序的问题

06:41.070 --> 06:46.210
触底之后我们首先可以非常容易想的就是切换方块对不对

06:46.470 --> 06:47.730
方块切换

06:48.190 --> 06:50.030
那么切换方块是不是很简单

06:50.290 --> 06:55.410
你看之前为什么把这些打散把这些函数全部写成一个一个的小函数

06:55.670 --> 07:00.010
就是为了实现这样的方式目标啊我一定要你玩算了啊switch

07:00.270 --> 07:00.790
terrors

07:01.550 --> 07:03.590
切换方块你去切换吧我不玩了啊

07:04.110 --> 07:05.390
好咱们来试一下啊

07:06.430 --> 07:07.190
开始

07:08.470 --> 07:14.350
然后这里左左左下啊你看是不是对不对啊右

07:18.710 --> 07:19.230
下

07:19.730 --> 07:20.230
你看

07:20.490 --> 07:21.010
说是

07:21.270 --> 07:23.310
呃然后右右前转

07:23.570 --> 07:24.090
右

07:24.350 --> 07:24.850
下

07:25.370 --> 07:30.990
是不是触底过后就就已经实现了啊这个切换方块就完事了把下一个方块又拿过来对不对

07:31.250 --> 07:33.810
把下个方块拿过来但是你看发现问题没啊

07:34.070 --> 07:35.090
发现问题没啊

07:36.370 --> 07:38.170
他现在的触底啊

07:38.670 --> 07:39.950
他现在的触底

07:40.210 --> 07:42.010
有一个什么样的问题呢

07:42.770 --> 07:45.070
再看啊让他慢慢下落让他看吧

07:46.050 --> 07:48.610
让他慢慢下落你看吧

07:49.630 --> 07:52.950
他一个什么样的问题呢他忽略了之前的

07:53.210 --> 07:57.570
已经存在的东西对不对他已经忽略了之前已经存在的方块

07:57.830 --> 08:01.910
并且呢他移动也没有判也没有判断之前之前的方块

08:02.170 --> 08:03.830
就是之前的我们这里

08:04.090 --> 08:07.290
terrors入里边他这个函数这个核心函数

08:07.550 --> 08:11.130
判断是否能移动你看其他的移动都是根据这个函数来判断的

08:11.850 --> 08:14.210
这个函数里边他并没有判断

08:14.470 --> 08:17.790
当前已存在的方块他只判断了这个

08:19.050 --> 08:22.910
方块的形状啊以及移动了目标位置

08:23.170 --> 08:24.950
他并没有他并不知道

08:25.210 --> 08:27.510
目前已经有了哪些方块

08:28.030 --> 08:29.810
不能进行从不能重叠

08:30.070 --> 08:31.610
他们并没有进行这样的判断

08:32.630 --> 08:34.170
那么这里是要两个问题

08:35.710 --> 08:37.750
切换方块然后另外

08:38.210 --> 08:39.230
就是要两个问题

08:39.490 --> 08:40.770
为产生了新的问题了

08:41.530 --> 08:42.310
新的问题

08:43.590 --> 08:44.870
什么新的问题呢两个

08:45.130 --> 08:45.650
第一个问题

08:47.720 --> 08:48.240
当

08:49.000 --> 08:50.280
当处底后

08:50.540 --> 08:51.760
当处底后

08:52.580 --> 08:54.120
如何保存

08:55.400 --> 08:56.920
以落下的方块

08:57.700 --> 08:58.720
以落下的方块

08:59.240 --> 09:00.000
这第一个问题

09:00.520 --> 09:02.040
就是这个方块已经落下来了

09:02.320 --> 09:04.560
那么这个方块需要保存起来啊

09:04.820 --> 09:06.920
为什么要保存起来呢是因为第二个问题

09:07.180 --> 09:08.460
需要处理第二个问题

09:09.280 --> 09:10.200
如何

09:10.540 --> 09:11.320
根据

09:11.580 --> 09:13.620
以保存的方块

09:14.380 --> 09:15.160
判断

09:15.680 --> 09:17.960
当前方块是否

09:18.220 --> 09:19.000
可以

09:19.520 --> 09:20.020
移动

09:21.560 --> 09:24.640
当处底过后首先要把落下的方块保存起来

09:25.140 --> 09:29.240
为什么要保存起来呢是因为到时候要判断是否可以移动的时候

09:29.500 --> 09:33.600
我要参照目前已经有哪些落下的方块而进行参照

09:34.100 --> 09:37.680
如果我没有保存下来的话我根本就不知道哪些方块落下来了

09:37.880 --> 09:39.160
有哪些方块

09:39.420 --> 09:41.480
已经在下面了

09:41.740 --> 09:43.260
那么我就没办法判断

09:43.520 --> 09:44.800
是否移动

09:45.060 --> 09:46.340
因此现在的移动

09:46.600 --> 09:48.380
现在的移动一看全是重叠在一起的

09:48.640 --> 09:50.680
因为他不知道这些方块已经存在了

09:51.460 --> 09:54.780
要解决第二个问题首先要解决第一个问题

09:55.040 --> 09:57.340
要如何保存以落下的方块

09:57.600 --> 09:58.380
什么时候保存

09:58.640 --> 10:00.160
肯定是处底后保存

10:00.420 --> 10:03.740
保存以落下的方块

10:05.020 --> 10:06.820
好看一下怎么保存

10:07.780 --> 10:08.560
首先到这边

10:09.340 --> 10:11.280
保存的方式其实很简单

10:11.540 --> 10:14.460
我们在这个游戏内里边加一个属箱

10:14.720 --> 10:15.740
加一个属箱

10:16.000 --> 10:17.520
这属箱打个注释

10:17.780 --> 10:21.100
表示当前游戏中

10:21.360 --> 10:24.180
已存在的方块

10:25.460 --> 10:27.000
那它肯定是个数组对不对

10:27.260 --> 10:28.020
它肯定是一个数组

10:28.280 --> 10:31.100
好我们就用一个数组来保存

10:31.360 --> 10:32.360
square

10:32.620 --> 10:34.420
square应该是一个this是吧

10:34.680 --> 10:35.960
表示已存在的

10:36.420 --> 10:37.440
它的类型是啥呢

10:37.700 --> 10:38.980
是一个square的数组

10:39.740 --> 10:41.040
就是一个小方块的数组

10:41.540 --> 10:44.360
为什么不用这个玩意

10:45.120 --> 10:48.720
这个玩意只是在移动过程中才有意义理想象的道理

10:49.480 --> 10:50.360
它移动

10:50.620 --> 10:51.780
是不一起移动的

10:52.300 --> 10:52.800
它

10:53.580 --> 10:54.600
就是什么

10:54.860 --> 10:55.880
叫什么旋转

10:56.140 --> 10:57.920
旋转是不是也是

10:58.180 --> 10:59.200
是一个整体

10:59.460 --> 11:01.520
但它一旦落下来过后

11:02.540 --> 11:03.820
整体还有没有意义

11:04.080 --> 11:04.840
没有任何意义

11:04.960 --> 11:06.840
落下来过后之后还要消除对吧

11:07.100 --> 11:08.120
还把整体打散

11:08.380 --> 11:10.160
所以说这里最好使用

11:10.420 --> 11:12.720
把它变成一个小方块的数组

11:12.980 --> 11:15.800
就表示当前游戏中已经存在的小方块

11:16.060 --> 11:17.340
就已经在底部的小方块

11:18.100 --> 11:19.020
好这个数组

11:19.280 --> 11:21.180
可以一开始给它复制为一个

11:21.700 --> 11:22.700
除纸

11:22.960 --> 11:23.740
一个空的数组

11:25.020 --> 11:25.520
OK

11:26.040 --> 11:27.320
好然后呢

11:28.080 --> 11:29.120
然后呢

11:29.380 --> 11:30.140
我们现在

11:30.900 --> 11:32.180
到这边来

11:34.400 --> 11:35.680
现在再看这个触底

11:35.900 --> 11:36.960
触底过后

11:37.220 --> 11:39.520
在切换这个方块之前

11:40.040 --> 11:41.560
在切换这个方块之前

11:41.820 --> 11:45.920
是不是要先把当前那个方块已经到了底部的这个方块

11:46.440 --> 11:47.960
把它的一些小方块

11:48.220 --> 11:49.760
夹到这个数组里面来

11:50.020 --> 11:50.520
对不对

11:50.780 --> 11:52.320
把它夹个数组的存起来

11:52.580 --> 11:53.600
因为将来我们要用它

11:53.860 --> 11:55.400
用它来判断能不能移动

11:56.160 --> 11:56.920
所以说这里呢

11:57.440 --> 11:57.960
在

11:58.220 --> 12:01.280
切换方块之前我们首先做这么一件事

12:02.040 --> 12:03.320
什么事呢就是

12:03.780 --> 12:06.340
将当前的

12:07.380 --> 12:08.660
俄罗斯方块

12:09.420 --> 12:12.220
把打散打成一个个小方块

12:13.260 --> 12:15.300
包含的小方块

12:17.100 --> 12:18.380
加入到

12:18.640 --> 12:21.200
已存在的方块数

12:22.460 --> 12:23.240
组织

12:24.000 --> 12:24.780
做这么一件事

12:25.300 --> 12:26.560
然后再是

12:26.820 --> 12:28.100
然后再是

12:28.620 --> 12:29.380
切换

12:29.640 --> 12:30.660
切换方块

12:31.640 --> 12:34.960
好那么这一步怎么做呢这一步其实也非常非常简单

12:35.480 --> 12:36.500
这不是个数组吗

12:37.780 --> 12:38.300
怎么

12:38.560 --> 12:39.200
exists

12:40.080 --> 12:40.840
这里还是

12:41.100 --> 12:42.080
用那个下滑线吧

12:42.340 --> 12:43.160
夹个下滑线

12:44.440 --> 12:45.200
夹个下滑线

12:45.720 --> 12:46.480
好这里

12:46.740 --> 12:48.440
已存在这个方块

12:48.700 --> 12:50.320
push对吧数组连push

12:50.580 --> 12:52.360
好然后当前

12:52.620 --> 12:53.860
当前这个方块是什么呢

12:54.120 --> 12:54.940
Curteris

12:55.200 --> 12:56.480
它也不是一个属性吗

12:57.240 --> 12:58.000
什么属性

12:58.260 --> 12:58.960
Curteris

12:59.200 --> 13:00.320
如果它不为空的话

13:01.040 --> 13:02.400
它触底到肯定不为空吧

13:02.660 --> 13:03.680
不然它怎么触底的呢

13:05.480 --> 13:06.240
那么

13:06.760 --> 13:08.540
把这个空去掉

13:08.800 --> 13:10.840
把这个square是它不是个数组吗你看

13:11.100 --> 13:13.920
这个square它不是个数组吗把这个数组的东西

13:14.180 --> 13:15.720
夹到这个数组里面去

13:15.980 --> 13:17.000
当然这里要用什么

13:17.260 --> 13:18.520
要用展开运双斧

13:18.780 --> 13:19.820
把这个数组展开

13:20.580 --> 13:22.880
好这是一种方式这方式太多了这里

13:23.140 --> 13:25.440
或者是给它重新复制

13:25.700 --> 13:27.480
重新复制复制为什么呢

13:27.700 --> 13:29.340
它之前的数组

13:29.600 --> 13:30.500
Concrete

13:30.760 --> 13:32.720
拼接上什么

13:33.580 --> 13:35.360
Curteris

13:35.620 --> 13:38.440
然后它的squares

13:38.700 --> 13:40.240
所以它都一样都行

13:40.740 --> 13:41.360
总之呢

13:41.600 --> 13:43.040
也要把这个数组内容改变

13:44.080 --> 13:46.120
好都是第一个问题解决了

13:46.380 --> 13:47.480
改变这个

13:47.740 --> 13:49.960
保存引落下的方块这个问题解决了

13:50.720 --> 13:52.640
那么保存引落下方块解决过后

13:52.900 --> 13:54.060
我们要这里要处理的

13:54.320 --> 13:55.760
要改变以前这个函数

13:56.000 --> 13:56.620
叫这个函数

13:57.840 --> 14:00.420
这个函数判断是否能移动

14:00.680 --> 14:03.720
除了判断边界之外

14:03.960 --> 14:05.360
还要判断一个东西

14:05.620 --> 14:08.700
要根据已存在的方块来进行判断

14:09.460 --> 14:10.060
因此呢

14:10.500 --> 14:12.540
它还需要第三个参数

14:13.060 --> 14:15.380
根据已存在的方块

14:15.620 --> 14:16.380
exists

14:17.920 --> 14:18.680
什么类型

14:18.940 --> 14:19.960
一个方块的数组

14:20.720 --> 14:22.260
之前已存在的一些方块

14:22.520 --> 14:23.280
我现在给你

14:23.800 --> 14:26.360
那么你啊除了判断边界之外

14:26.800 --> 14:27.840
还要判断啥呢

14:28.240 --> 14:30.920
还要判断啊就边界如果没有判断没有通过

14:31.160 --> 14:33.940
如果有有超出边界的那么返回forced

14:34.200 --> 14:35.800
好这下面还要判断

14:36.560 --> 14:37.440
要判断

14:38.040 --> 14:39.040
是否

14:40.140 --> 14:40.640
与

14:41.560 --> 14:44.480
啊已有的方块

14:45.000 --> 14:46.160
有重点

14:47.040 --> 14:48.160
啊有重点

14:48.680 --> 14:49.720
是否有重点

14:50.600 --> 14:51.640
那么怎么判断呢

14:52.400 --> 14:54.040
这里是不是已经有个数组了

14:54.440 --> 14:56.040
这个数组里边是不是有很多方块

14:56.080 --> 14:57.720
每个方块有个坐标对不对

14:58.480 --> 14:59.060
好

14:59.320 --> 15:02.760
知啊这里呢我们之前已经计算出来了

15:03.160 --> 15:05.080
如果把它移动到目标位置

15:05.600 --> 15:07.640
如果把中心点移动到目标位置

15:08.080 --> 15:10.840
每一个方块的坐标我们也得到了对吧

15:11.360 --> 15:14.680
如果把这个形状的方块移动到这个位置那么

15:15.440 --> 15:18.760
最后的结果是这个方块它的每个点的坐标也得到了

15:19.280 --> 15:21.960
那么这一个已存在的方块也有了

15:22.720 --> 15:24.600
是不是一个牵套的护循环就完事了

15:25.120 --> 15:25.800
就完事了

15:26.240 --> 15:27.280
我们这里来呗

15:27.780 --> 15:31.880
target square points把当前这个方块

15:32.140 --> 15:33.920
假设它移动到了目标位置

15:34.960 --> 15:37.520
那么移动过后呢它产生一系列的坐标

15:37.780 --> 15:39.820
那么这个坐标我们去循环它

15:40.080 --> 15:45.200
看一下没这个形状啊到了目标位置过后啊就比方说这个形状

15:47.760 --> 15:50.560
这个形状要把它移动到哪了移动到这来

15:50.820 --> 15:55.960
到了目标位置过后然后这些每一个小方块是有坐标啊循环这每一个小方块

15:56.480 --> 15:57.520
循环的是这个方块

15:58.040 --> 15:59.960
循环的是每一个小方块比方这一块

16:00.220 --> 16:02.360
循环它每一个小方块到了目标过后

16:06.120 --> 16:07.640
到了目标过后

16:15.200 --> 16:17.480
好把每一个坐标拿出来看一下

16:17.760 --> 16:19.280
看一下这个坐标

16:20.560 --> 16:23.120
在这个数组中是否存在

16:23.380 --> 16:25.560
这个数组里面是很多小方块

16:25.760 --> 16:29.320
那么小方每个小方块就有个坐标那么看一下这个坐标

16:29.860 --> 16:32.160
在这个数组里面是否存在

16:32.680 --> 16:33.720
怎么判断了

16:34.220 --> 16:35.640
怎么判断是否存在了

16:36.160 --> 16:37.640
其实怎么判断

16:37.900 --> 16:38.840
就判断啥呢

16:39.080 --> 16:40.100
就判断Zs

16:40.360 --> 16:41.640
不是Zs

16:42.400 --> 16:49.000
这个数组里面是否有某一个满足条件的啊是不是有满足条件的一个

16:49.320 --> 16:50.860
一个数组的一项

16:52.640 --> 16:55.200
每一个小方块啊它得到是每一个小方块

16:55.400 --> 17:00.020
每一个小方块的point x是不是等于p.x

17:00.520 --> 17:05.400
并且sq.point.y是不是等于p.y

17:05.920 --> 17:06.920
就判断这个东西

17:07.680 --> 17:12.040
好如果这个表达式的结果为True说明了什么

17:13.320 --> 17:14.040
说明了啥

17:14.800 --> 17:17.160
说明了这个东西

17:17.680 --> 17:18.840
这个东西

17:19.080 --> 17:21.520
是不是在它里面有存在的

17:22.040 --> 17:23.480
是不是在它里面有存在的

17:23.960 --> 17:25.520
对不对那么是不是有重叠

17:26.040 --> 17:26.800
最有重叠

17:27.060 --> 17:31.920
因此呢这里我其实可以不用放一起了啊用上直接在这里直接用上就行了

17:32.700 --> 17:33.720
直接用上就行了

17:34.480 --> 17:36.040
你看一下我们这里判断的是啥

17:38.080 --> 17:38.600
判断的是啥

17:39.100 --> 17:40.120
再来理一下啊

17:40.880 --> 17:46.520
这个代码有点长啊如果你这里的代码实在很难理解的话你就写啥就写千头的货循环

17:47.040 --> 17:52.160
那肯定是没问题了那肯定能理解我这里是难得去写了啊难得去写都签到的货循环了

17:52.640 --> 17:54.920
总之呢我这里判断的是啥呢

17:55.180 --> 17:59.020
判断的是如果我这个方块

17:59.800 --> 18:01.080
就这个方块啊

18:01.580 --> 18:04.660
到达了目标位置过后他有一系列的坐标

18:05.160 --> 18:08.760
看一下这个坐标中是否存在啥呢

18:09.520 --> 18:11.060
存在某一个坐标

18:12.340 --> 18:13.880
跟这些坐标重叠了

18:14.640 --> 18:17.200
是不是看看一下这个这种情况有没有发生

18:17.960 --> 18:19.240
如果他为True

18:20.000 --> 18:21.040
如果他为True

18:21.760 --> 18:23.040
那这里我把他变成列字吧

18:26.260 --> 18:28.580
如果他为True说明了啥

18:29.080 --> 18:29.860
说明了

18:30.380 --> 18:32.780
哎这里不行啊这多个关键字啊

18:33.540 --> 18:39.060
如果他为True说明了啥呢这个好去理一下啊如果你这里看不懂的话你就直接写千头的货循环

18:39.580 --> 18:44.780
两个数组里边有没有相同的像你去签到货循环去搞定也可以

18:45.580 --> 18:50.660
如果这个为True说明了存在这么一个坐标有重叠有重叠那能不能移动

18:51.300 --> 18:52.540
return false不能移动

18:53.500 --> 18:54.020
就完了

18:54.780 --> 18:56.060
就写完了啊这个地方

18:57.080 --> 18:59.900
好你看一下ts的好处一下凸显出来了

19:00.420 --> 19:04.500
我们改动了这个函数那我现在告诉你如果你用的是js

19:05.540 --> 19:07.060
你这个函数用的是js写的

19:07.320 --> 19:10.140
js能不能写内可以能不能写standic可以

19:10.660 --> 19:12.180
那你用js写了过后

19:12.700 --> 19:16.020
你知道这个函数改了过后会涉及到多少改动吗

19:16.280 --> 19:17.060
你知不知道

19:18.080 --> 19:20.900
你敢不敢改这个函数给他加一个参数你敢不敢

19:21.620 --> 19:25.460
你肯定是不敢的因为你这个函数改了很多地方的调用这个函数

19:25.720 --> 19:27.760
你鬼知道哪些地方要改

19:28.280 --> 19:29.560
但是ts不一样

19:30.060 --> 19:31.860
你看提示的明明白白

19:32.120 --> 19:33.140
哪些地方要改

19:33.400 --> 19:34.940
包戳了已经看到没有

19:35.200 --> 19:36.980
他现在有三个参数了

19:37.500 --> 19:41.340
有三个参数哪些地方的调用你看是谁人这里出错了

19:42.100 --> 19:43.900
之前旋转的时候

19:44.400 --> 19:45.420
旋转的时候

19:45.680 --> 19:50.040
要判断是不是能旋转是不是能旋转新的形状给你

19:50.240 --> 19:51.280
中心点给你

19:51.540 --> 19:52.560
是不是能旋转

19:52.820 --> 19:55.360
因为旋转他也有可能会导致重叠对吧

19:55.620 --> 19:58.700
旋转也有可能导致重叠这个是合理的这是没有任何问题的

19:59.460 --> 20:00.220
因此呢

20:00.480 --> 20:02.540
这个旋转的时候是不是也出了问题

20:02.800 --> 20:04.320
你是不是要告诉我啥

20:04.580 --> 20:07.660
我旋转的时候呢你也得告诉我以存在的

20:08.420 --> 20:09.460
以存在的方块

20:09.700 --> 20:12.020
因为旋转他也有可能会导致重叠

20:12.520 --> 20:16.360
旋转有可能会出边界超出边界他也有可能当然也有可能

20:16.620 --> 20:17.140
导致重叠

20:17.360 --> 20:20.240
所以说旋转的时候你也得把这个东西告诉我

20:20.680 --> 20:22.280
那么这里我就处理一下

20:23.760 --> 20:26.560
好同样的道理还有哪个地方出了问题呢

20:27.840 --> 20:29.880
还有这个地方也出了问题

20:30.660 --> 20:32.960
那你移动的时候是不是也得告诉我

20:34.240 --> 20:36.800
也得告诉我目前已存在的

20:37.060 --> 20:38.080
已存在的

20:38.340 --> 20:38.840
一个ZS

20:40.640 --> 20:41.400
已存在的

20:42.440 --> 20:42.960
square

20:43.200 --> 20:43.720
输出

20:44.440 --> 20:45.040
当然了

20:45.300 --> 20:46.340
上面有两个重在

20:46.600 --> 20:48.020
重在这里也要处理

20:48.280 --> 20:48.980
也要处理

20:50.020 --> 20:50.580
都处理一下

20:51.100 --> 20:53.140
好那么这里就有这个参数了

20:53.900 --> 20:58.020
这是这里的处理方式

20:59.020 --> 21:01.860
我们到时候移动的时候也要判断

21:02.100 --> 21:03.140
是不是能移动

21:03.380 --> 21:04.140
是不是能移动

21:04.920 --> 21:07.220
好这里还报了错了还有错误

21:07.480 --> 21:09.660
那么这里目的时候你看

21:09.940 --> 21:13.220
你看这些连串的问题他就会不断的提示你

21:13.420 --> 21:14.420
哪些地方需要更改

21:14.660 --> 21:16.000
你改了这个函数签名过后

21:17.000 --> 21:19.320
那么这里移动的时候我们这里调的是什么

21:19.580 --> 21:21.880
重在把移动目标位置

21:22.140 --> 21:24.440
移动的时候是不是也要把ZS传过去

21:25.200 --> 21:25.720
对不对

21:26.220 --> 21:29.820
这是低规调用又重新调用至极把目标位置

21:30.080 --> 21:31.200
这是方向的情况

21:31.460 --> 21:33.140
按照某种方向来移动

21:33.400 --> 21:34.680
那么把目标位置传过去

21:34.940 --> 21:36.480
把目前已存在的传过去

21:38.000 --> 21:40.560
好了那么这里还有一个错误我们要依次更改

21:41.280 --> 21:42.300
你看看在哪

21:48.280 --> 21:49.320
应该是没有错误了吧

21:49.820 --> 21:50.600
应该是没有了

21:51.360 --> 21:51.880
为什么还会

21:52.140 --> 21:52.640
这里

21:52.900 --> 21:54.680
这里也出现问题

21:54.940 --> 21:57.240
那么直接移动是不是也要传给这个东西过来

21:57.500 --> 22:00.060
你看这些我们容易忘记的地方

22:00.820 --> 22:03.520
在TS里边就会详细的给你提醒

22:03.780 --> 22:04.320
提醒你

22:04.580 --> 22:05.700
要更改这样的错误

22:06.720 --> 22:09.540
好这边改了这边该不改改肯定应该改

22:10.060 --> 22:12.260
改了之后呢你看这边肯定是没问题了

22:12.420 --> 22:13.540
因为他没有提示

22:13.800 --> 22:15.080
他有错误的话还会提示你的

22:16.100 --> 22:17.640
好这边改了之后

22:17.900 --> 22:19.180
我们再到这边来看

22:19.680 --> 22:20.720
这边也爆错了

22:20.960 --> 22:24.040
有很多位置爆错了那没事只有五个位置改

22:24.300 --> 22:25.580
我们一个个来改

22:26.860 --> 22:28.140
好直接往下移动

22:28.640 --> 22:31.460
移动的时候是不是要传个东西过去

22:32.740 --> 22:34.540
传过去把这个数组传过去

22:34.800 --> 22:36.320
好第一个地方改了

22:36.840 --> 22:38.620
然后我们接着来

22:39.140 --> 22:40.940
太好了是他这个地方

22:41.660 --> 22:45.760
没有很明显的提示你他那个错误在哪

22:46.020 --> 22:46.780
这个不太舒服

22:47.540 --> 22:48.580
这里再传一个

22:50.360 --> 22:52.660
就把当前已存在的方块给你

22:53.440 --> 22:55.220
看一下啊还有哪些地方

22:55.480 --> 22:56.000
这个地方

22:59.580 --> 23:01.620
这个爆错其实不是坏事

23:01.880 --> 23:02.900
这一定是好事

23:03.160 --> 23:04.960
如果他不爆错还真的是恐怖

23:05.220 --> 23:07.520
你到哪里去改了根本不知道在哪里去改

23:08.280 --> 23:10.080
好悬状的时候也要告诉他

23:10.940 --> 23:11.700
一个ZS

23:12.980 --> 23:14.520
还有一个地方

23:16.060 --> 23:18.620
自动往下落

23:20.160 --> 23:23.220
好了这样你改了过后你看一下现在再看一下

23:23.740 --> 23:25.280
就完了我们再看一下

23:25.780 --> 23:26.300
往下

23:27.060 --> 23:27.580
往下

23:27.840 --> 23:28.600
看到没

23:29.380 --> 23:30.400
啊下

23:31.680 --> 23:32.700
你看是不是可以

23:33.220 --> 23:33.980
叠起来了

23:34.740 --> 23:35.260
你看

23:35.780 --> 23:36.280
往下

23:39.360 --> 23:40.640
然后旋转

23:41.660 --> 23:43.700
这裏抓不了了啊因为

23:46.780 --> 23:48.060
你看是不是可以叠起来了

23:48.320 --> 23:49.600
就可以叠起来了

23:50.360 --> 23:51.380
ok这就是

23:51.640 --> 23:53.640
这一块的处理

23:53.900 --> 23:54.720
对这一块的处理

23:55.220 --> 23:56.000
就是叠

23:56.260 --> 23:58.560
就是我们现在改搞定了两个功能了

23:58.820 --> 23:59.840
一个是

24:00.100 --> 24:00.860
切换方块

24:01.120 --> 24:01.880
能切换了

24:02.140 --> 24:03.160
出底过后能切换

24:03.420 --> 24:05.220
并且保存了引落下来方块

24:05.480 --> 24:07.000
每一次下落过后我就把

24:07.260 --> 24:08.800
方块下落过后我就把他打散

24:09.520 --> 24:11.360
方块一下落我就把他打散

24:11.620 --> 24:13.400
你看这里开始啊

24:13.660 --> 24:14.420
一往下落

24:14.680 --> 24:18.780
我其实看上去是个方块其实一变成了四个小方块了把他保存在宿主里边

24:19.300 --> 24:19.820
好这边

24:20.320 --> 24:20.840
下落

24:21.100 --> 24:23.140
他又变成了四个小方块加到宿主里边了

24:23.400 --> 24:25.960
下落他又变成了四个小方块加到宿主里边了

24:26.460 --> 24:29.020
好到时候移动的时候呢每一次移动都要判断

24:29.280 --> 24:31.840
根据当前面板的宽高

24:32.100 --> 24:33.640
这个在配置里边可以读去

24:33.900 --> 24:34.660
以及呢

24:35.160 --> 24:35.680
根据什么呢

24:35.940 --> 24:36.700
根据

24:37.160 --> 24:38.960
以存在的方块我判断

24:39.460 --> 24:40.500
是否能够移动

24:41.260 --> 24:43.820
ok啊这是出底过后了这两个处理

24:44.340 --> 24:46.640
那么出底过后还有什么事情要做呢

24:47.160 --> 24:48.420
还有什么事情要做

24:49.200 --> 24:50.220
你看一下

24:50.480 --> 24:51.240
继续玩呗

24:51.760 --> 24:52.520
开始

24:52.780 --> 24:56.120
下下下下是不是游戏该结束了

24:56.620 --> 24:57.640
游戏该结束了

24:57.900 --> 25:03.020
因此呢就是胜负判断啊不是要胜负判断了游戏是否结束的判断

25:03.280 --> 25:05.060
游戏是否结束的判断

25:06.040 --> 25:07.060
好第一个就是

25:07.820 --> 25:10.640
游戏是否结束

25:10.900 --> 25:11.680
这样的判断

25:12.180 --> 25:13.060
还一个是什么呢

25:13.320 --> 25:14.480
还一个是要消除

25:15.520 --> 25:17.560
消除方块的处理

25:17.820 --> 25:20.380
因为出底过后他有可能会消除的比方说

25:22.680 --> 25:23.180
这种

25:24.460 --> 25:26.520
我这玩的不是很好啊

25:27.280 --> 25:29.840
我先用数要操作不是很好操作

25:30.360 --> 25:30.860
下

25:31.640 --> 25:32.140
右

25:32.920 --> 25:33.680
好下

25:33.940 --> 25:34.720
好这里

25:35.360 --> 25:37.160
那么我们是不是要该消除一下

25:37.420 --> 25:37.760
对不对

25:38.020 --> 25:39.620
消除的处理

25:39.880 --> 25:40.980
对消除的处理

25:41.240 --> 25:42.440
还有这两个处理

25:42.700 --> 25:44.480
那么这两个处理大家思考一下

25:44.740 --> 25:46.020
本节课呢不再设计

25:46.280 --> 25:48.060
本节课的这个小节不再设计

25:48.320 --> 25:49.340
可以去思考一下

25:49.600 --> 25:50.880
已经进入维生了

25:51.400 --> 25:53.440
那么这节课呢就到走了啊

25:53.700 --> 25:56.520
我们下节课呢来说如何来消除方块

