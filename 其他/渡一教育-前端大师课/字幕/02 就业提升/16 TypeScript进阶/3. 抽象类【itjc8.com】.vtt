WEBVTT

00:00.560 --> 00:04.360
好了 咱们这一课继续面向对象的学习

00:04.360 --> 00:07.760
这一课呢 咱们讲一个东西叫做抽象内

00:07.760 --> 00:11.060
这个概念啊 你们以前在GS里边

00:11.060 --> 00:13.560
GS里边有内对吧 但是没有这么一个概念

00:13.560 --> 00:15.060
抽象内是没有的

00:15.060 --> 00:18.460
所以说为什么说GS它支持面向对象

00:18.460 --> 00:20.560
但是我们平常写代码的话

00:20.560 --> 00:23.060
不太会去写这种面向对象的代码

00:23.060 --> 00:24.760
就因为它很多东西啊

00:24.760 --> 00:27.560
用者很不舒服 少了一些东西

00:27.560 --> 00:30.460
好 我们来看一下抽象内是一个什么样的概念

00:30.660 --> 00:34.260
这里呢 我这几课的例子啊 以中国象棋为例

00:34.260 --> 00:38.460
这个地方呢 我以前做了一个中国象棋的这么一个小游戏

00:38.460 --> 00:43.460
不过呢 大家有可能不太了解中国象棋的规则

00:43.460 --> 00:46.960
没关系啊 没关系 完全不影响的

00:46.960 --> 00:48.460
就咱们讲课的过程中

00:48.460 --> 00:51.760
你不了解这些每个棋子的规则都不影响的啊

00:51.760 --> 00:54.960
我们来看一下 我们只是来书写一下它的内结构就行了

00:54.960 --> 00:57.460
只是把这个我们要讲的概念讲清楚就行了

00:57.960 --> 00:59.460
好 这个象棋里边呢

00:59.460 --> 01:02.460
我们可以看到有很多很多的棋子啊

01:02.460 --> 01:05.460
有不同的棋子在这个棋盘里边

01:05.460 --> 01:07.460
我们这里呢 就可以做一个内

01:07.460 --> 01:10.460
就是所有的棋子呢 都去继承一个附内

01:10.460 --> 01:12.960
就是CHESS 表示一个棋子

01:12.960 --> 01:15.960
OK 我们可以先写这么一个内结构出来

01:15.960 --> 01:17.460
啊 这里 比方说

01:17.460 --> 01:19.460
以中国象棋为例啊

01:20.460 --> 01:23.460
首先我们讲的是 为什么需要抽象内

01:23.460 --> 01:25.960
为什么需要抽象内

01:25.960 --> 01:27.960
那么以中国象棋为例的话

01:27.960 --> 01:28.960
我们这里画一个图

01:30.960 --> 01:32.960
然后这里呢 这样子写

01:35.960 --> 01:37.960
这里我画一个图啊

01:37.960 --> 01:41.960
这里呢 我们比方说有个内叫CHESS棋子

01:41.960 --> 01:44.960
所有的棋子呢 都去继承这个附内

01:44.960 --> 01:47.960
因为所有的棋子呢 都有一些共同的特征

01:47.960 --> 01:49.960
比方说坐标啊

01:49.960 --> 01:51.960
比方说移动啊之类的东西

01:51.960 --> 01:53.960
移动方法啊之类的东西

01:53.960 --> 01:54.960
它都有特征的

01:54.960 --> 01:56.960
所以说我们其他棋子去继承它

01:56.960 --> 01:58.960
比方说我们的马 对吧

01:58.960 --> 02:00.960
我这里刚去用这个 用中文吧

02:00.960 --> 02:01.960
棋子

02:02.960 --> 02:03.960
比方说马

02:03.960 --> 02:05.960
马是一个棋子

02:05.960 --> 02:06.960
大家看一下啊

02:06.960 --> 02:08.960
这个马 它是一个棋子 对吧

02:08.960 --> 02:11.960
还有什么砲啊 竹啊这些东西

02:11.960 --> 02:12.960
都是棋子

02:12.960 --> 02:14.960
马去继承棋子

02:14.960 --> 02:16.960
然后棋子呢 还有一些其他籽的

02:16.960 --> 02:18.960
我就不写完了啊 我就写一部分就行了

02:19.960 --> 02:21.960
比方说冰

02:21.960 --> 02:22.960
它也是一个棋子

02:22.960 --> 02:25.960
它们这些东西呢 都是棋子的籽类

02:25.960 --> 02:26.960
再来一个吧

02:26.960 --> 02:32.770
比方说泡

02:32.770 --> 02:34.770
好 我们来看一下啊

02:34.770 --> 02:36.770
形成这么一种继承结构

02:38.770 --> 02:41.770
具体的棋子呢 都是这些棋子的籽类

02:41.770 --> 02:44.770
好 我如果按照这样的结构去

02:44.770 --> 02:47.770
创建一个类的话 写单码的话

02:47.770 --> 02:49.770
我们就会写成这么一种格式

02:49.770 --> 02:50.770
什么格式呢

02:50.770 --> 02:52.770
就是这里啊 写个单码

02:52.770 --> 02:54.770
class chess 表示一个棋子内

02:54.770 --> 02:56.770
里面啥都不写 这个不重要

02:56.770 --> 02:58.770
我们来把那个内结构写出来

02:58.770 --> 03:00.770
Horse 这是码

03:00.770 --> 03:02.770
码应该去做什么呢 继承棋子

03:02.770 --> 03:04.770
对吧 继承棋子

03:04.770 --> 03:06.770
好 继续啊

03:06.770 --> 03:09.770
class 然后是泡

03:09.770 --> 03:11.770
泡咋写呢

03:11.770 --> 03:13.770
就泡泡泡吧

03:13.770 --> 03:14.770
意思是天子

03:14.770 --> 03:16.770
也是继承棋子

03:16.770 --> 03:17.770
然后是冰

03:17.770 --> 03:19.770
sojour

03:19.770 --> 03:21.770
sojour

03:21.770 --> 03:22.770
怎么写的

03:22.770 --> 03:23.770
sojour

03:24.770 --> 03:25.770
是这样写的吗

03:25.770 --> 03:27.770
sojour

03:27.770 --> 03:29.770
好 这个啊

03:29.770 --> 03:30.770
这是冰

03:30.770 --> 03:33.770
然后也去继承棋子

03:33.770 --> 03:35.770
还有很多棋子的啊

03:35.770 --> 03:37.770
我就不一再去写了

03:37.770 --> 03:40.770
那么形成了这么一种内结构之后呢

03:40.770 --> 03:42.770
咱们来看一个问题

03:42.770 --> 03:44.770
什么问题呢

03:44.770 --> 03:46.770
就是咱们有的时候呢

03:46.770 --> 03:48.770
创建对象是可以根据内来创建对象的

03:48.770 --> 03:51.770
对吧 比方说我要创建一个码

03:51.770 --> 03:53.770
就是New一个Horse

03:53.770 --> 03:54.770
对吧 对不对

03:54.770 --> 03:56.770
然后我要创建一个泡的话

03:56.770 --> 03:58.770
就是New一个泡

03:58.770 --> 04:00.770
然后我要创建一个冰的话

04:00.770 --> 04:02.770
就是New一个sojour

04:02.770 --> 04:04.770
这些都没有任何问题

04:04.770 --> 04:05.770
但是呢

04:05.770 --> 04:07.770
这个代码里边有一个隐患

04:07.770 --> 04:09.770
什么隐患呢

04:09.770 --> 04:10.770
代码一写多了

04:10.770 --> 04:15.140
你可能就不小心去做了这么一件事

04:15.140 --> 04:17.140
创建了一个Chase

04:17.140 --> 04:19.140
你看一下这个合理吗

04:19.140 --> 04:21.140
这个合理吗

04:21.140 --> 04:23.140
不太合理哦

04:23.140 --> 04:26.140
你看我们的这个游戏里边

04:26.140 --> 04:28.140
有具体各种各样的棋子

04:28.140 --> 04:33.140
但是游戏里边存不存在棋子这个对象

04:33.140 --> 04:36.140
存不存在棋子这个对象

04:36.140 --> 04:37.140
能懂我意思吗

04:37.140 --> 04:39.140
就是我们这个游戏里边存在

04:39.140 --> 04:42.140
居存在码存在泡存在冰

04:42.140 --> 04:43.140
这些东西都存在

04:43.140 --> 04:46.140
但是实际上是不存在棋子这个东西的

04:46.140 --> 04:49.140
棋子它只是一个抽象的概念

04:49.140 --> 04:51.140
这些东西都是棋子

04:51.140 --> 04:52.140
他们是具体的东西

04:52.140 --> 04:54.140
我们可以去创建一个具体的东西

04:54.140 --> 04:57.140
而不应该去创建一个棋子的对象

04:57.140 --> 04:58.140
有没有意思吗

04:58.140 --> 05:01.140
那你说创造一个棋子它的规则是啥呢

05:01.140 --> 05:02.140
有没有这样的说法

05:02.140 --> 05:04.140
就是我问你中国乡棋

05:04.140 --> 05:07.140
某个棋的规则是啥一共描述一下

05:07.140 --> 05:08.140
你怎么描述呢

05:08.140 --> 05:10.140
因为我都没告诉你是啥棋子

05:10.140 --> 05:11.140
你怎么知道规则呢

05:11.140 --> 05:13.140
所以说这个是抽象概念

05:13.140 --> 05:16.140
抽象概念的话是不应该能够创建对象的

05:16.140 --> 05:18.140
但是以前在介石里边

05:18.140 --> 05:20.140
办不到你没有办法控制

05:20.140 --> 05:22.140
它要创建对象就创建了

05:22.140 --> 05:23.140
你怎么样呢

05:23.140 --> 05:24.140
你把它瞪着

05:24.140 --> 05:25.140
你没有任何办法

05:25.140 --> 05:28.140
但是在到TS里边就可以有办法了

05:28.140 --> 05:31.140
TS里边我只需要做一件事

05:31.140 --> 05:34.140
这个东西它就不能创建对象了

05:34.140 --> 05:36.140
只需要在这个内前边

05:36.140 --> 05:38.140
给它加上一个关键字叫做IBSJECT

05:39.140 --> 05:40.140
啥意思

05:40.140 --> 05:43.140
表示这个内它是一个抽象内

05:43.140 --> 05:44.140
它只是一个抽象概念

05:44.140 --> 05:47.140
它只是把一些子内的共有的东西

05:47.140 --> 05:48.140
提到了腹内里边

05:48.140 --> 05:50.140
它只是来解决一些重复的代码

05:50.140 --> 05:53.140
而并不产生实际的意义

05:53.140 --> 05:55.140
它知道它是一个棋子

05:55.140 --> 05:56.140
棋子里面共有的东西

05:56.140 --> 05:57.140
它把放到这里边

05:57.140 --> 05:59.140
但是你是不能创建它的对象的

05:59.140 --> 06:01.140
因此我把它写成IBSJECT

06:02.140 --> 06:04.140
那么把它变成一个抽象内锅后

06:04.140 --> 06:05.140
你看一下

06:05.140 --> 06:06.140
马上就爆出来了

06:06.140 --> 06:07.140
它告诉你

06:07.140 --> 06:10.140
无法去创建一个抽象内的实力

06:10.140 --> 06:11.140
什么叫实力

06:11.140 --> 06:12.140
实力就是对象

06:12.140 --> 06:13.140
就对象的意思

06:13.140 --> 06:16.140
你没有办法创建一个抽象内的对象

06:17.140 --> 06:18.140
所以说

06:18.140 --> 06:20.140
为什么需要抽象内

06:20.140 --> 06:21.140
很简单

06:21.140 --> 06:23.140
就是在咱们这个结构里边

06:23.140 --> 06:24.140
你看

06:24.140 --> 06:25.140
这个棋子

06:25.140 --> 06:26.140
我们要创建对象的时候

06:26.140 --> 06:27.140
创建的是具体的对象

06:27.140 --> 06:29.140
具体的棋子的对象

06:29.140 --> 06:31.140
而不应该去创建这个概念的对象

06:31.140 --> 06:32.140
所以说

06:32.140 --> 06:33.140
我们在这里

06:33.140 --> 06:34.140
给它记一笔

06:34.140 --> 06:36.140
为什么需要抽象内

06:36.140 --> 06:37.140
有时

06:38.140 --> 06:41.140
某个内只表示

06:41.140 --> 06:43.140
一个抽象概念

06:44.140 --> 06:47.140
主要用于提取

06:47.140 --> 06:50.140
子内共有的成员

06:50.140 --> 06:52.140
就它有可能有些子内

06:52.140 --> 06:53.140
这些子内共有的成员

06:53.140 --> 06:54.140
把它提到附在里边

06:54.140 --> 06:56.140
它本身只是一个抽象的概念

06:58.140 --> 07:03.140
而不能直接创建

07:03.140 --> 07:04.140
它的对象

07:04.140 --> 07:05.140
也就是说

07:05.140 --> 07:06.140
它是一个抽象概念

07:06.140 --> 07:08.140
你是不能直接去创建它的对象的

07:08.140 --> 07:09.140
你要创建的是

07:09.140 --> 07:11.140
应该是它子内的对象

07:11.140 --> 07:12.140
所以说

07:14.140 --> 07:15.140
该内

07:16.140 --> 07:18.140
可以作为抽象内

07:18.140 --> 07:20.140
在面向对象的语言里边

07:20.140 --> 07:21.140
什么加碼

07:21.140 --> 07:22.140
谁下不去语言里边

07:22.140 --> 07:24.140
抽象内都是存在的

07:24.140 --> 07:25.140
都有这么一个概念

07:25.140 --> 07:26.140
但是到了解释

07:26.140 --> 07:27.140
目前还没有

07:27.140 --> 07:28.140
官方标准还没有

07:28.140 --> 07:29.140
于是

07:29.140 --> 07:31.140
TS把它补充完整了

07:31.140 --> 07:32.140
在TS里边

07:32.140 --> 07:33.140
你只需要

07:33.140 --> 07:35.140
给它加上这么一个关键字

07:35.140 --> 07:37.140
给内前面加上一个关键字

07:37.140 --> 07:38.140
AppStrand

07:38.140 --> 07:39.140
这关键字的意思

07:39.140 --> 07:40.140
这个单词

07:40.140 --> 07:42.140
其实这个单词的意思

07:42.140 --> 07:44.140
就是抽象的意思

07:44.140 --> 07:46.140
就表示内是一个抽象内

07:46.140 --> 07:48.140
抽象内是不能创建对象的

07:48.140 --> 07:50.140
我们再记一笔

07:51.140 --> 07:53.140
给内前面

07:53.140 --> 07:57.140
加上关键字AppStrand

07:58.140 --> 07:59.140
表示

07:59.140 --> 08:03.140
该内是一个抽象内

08:03.140 --> 08:05.140
抽象内

08:05.140 --> 08:06.140
不可以

08:06.140 --> 08:09.140
创建对象

08:09.140 --> 08:10.140
应该是这样说

08:10.140 --> 08:12.140
不可以创建

08:12.140 --> 08:14.140
一个抽象内的对象

08:14.140 --> 08:16.140
其实抽象内

08:16.140 --> 08:17.140
说完了

08:17.140 --> 08:18.140
它有什么作用

08:18.140 --> 08:19.140
它主要是为了

08:19.140 --> 08:20.140
继承的

08:20.140 --> 08:22.140
让其他的指内

08:22.140 --> 08:23.140
去继承它

08:23.140 --> 08:24.140
不能创建一个

08:24.140 --> 08:26.140
抽象内的对象

08:26.140 --> 08:28.140
这就是抽象内最基本的概念

08:28.140 --> 08:29.140
为什么需要抽象内

08:29.140 --> 08:30.140
因为有的时候

08:30.140 --> 08:31.140
有些内

08:31.140 --> 08:34.140
只是提取了一些公有的成员

08:34.140 --> 08:35.140
它表示一个抽象概念

08:35.140 --> 08:37.140
你是不能创建它的对象的

08:37.140 --> 08:38.140
如果没有这个

08:38.140 --> 08:39.140
分割的约束

08:39.140 --> 08:40.140
行不行

08:40.140 --> 08:41.140
如果不写行不行

08:41.140 --> 08:43.140
那你只能寄希望于

08:43.140 --> 08:44.140
以后不要犯错

08:44.140 --> 08:45.140
就像我们以前说的

08:45.140 --> 08:46.140
靠什么

08:46.140 --> 08:47.140
靠诸施

08:47.140 --> 08:48.140
靠文档

08:48.140 --> 08:49.140
靠记忆力

08:49.140 --> 08:50.140
不要去犯这个错误

08:50.140 --> 08:51.140
当然

08:51.140 --> 08:54.140
这样的约束是非常弱的

08:54.140 --> 08:56.140
没有强约束

08:56.140 --> 08:58.140
就是你就算犯了错

08:58.140 --> 08:59.140
它也不会告诉你出问题的

08:59.140 --> 09:00.140
但是

09:00.140 --> 09:02.140
如果你用代码的格式

09:02.140 --> 09:03.140
就写这么一个关键字

09:03.140 --> 09:04.140
你就马上可以告诉他

09:04.140 --> 09:06.140
你想创建都不行

09:06.140 --> 09:07.140
哪怕你写错了都不行

09:07.140 --> 09:08.140
我会马上提示你

09:08.140 --> 09:09.140
明白这个意思吗

09:09.140 --> 09:10.140
就是不写的话

09:10.140 --> 09:11.140
也行

09:11.140 --> 09:12.140
那就靠记忆力

09:12.140 --> 09:13.140
靠文档

09:13.140 --> 09:14.140
靠诸施

09:14.140 --> 09:15.140
这些弱约束

09:15.140 --> 09:17.140
如果你要进行强约束的话

09:17.140 --> 09:19.140
只需要去写这个关键字

09:19.140 --> 09:20.140
你写的这个关键字

09:20.140 --> 09:21.140
你甚至可以不用写文档了

09:21.140 --> 09:22.140
你去创建没

09:22.140 --> 09:23.140
创建马上就会提示你

09:23.140 --> 09:24.140
不能创建

09:24.140 --> 09:25.140
所以说我们更加需要的是

09:25.140 --> 09:27.140
这种强约束

09:27.140 --> 09:29.140
我们在面向对象开发中

09:29.140 --> 09:30.140
会写很多很多的内

09:30.140 --> 09:31.140
那么这些内

09:31.140 --> 09:32.140
如果没有强约束的话

09:32.140 --> 09:35.140
就非常非常容易出错

09:35.140 --> 09:36.140
好

09:36.140 --> 09:37.140
最基本能改的

09:37.140 --> 09:39.140
非常简单

09:39.140 --> 09:42.140
了解了这个抽象内之后

09:42.140 --> 09:43.140
除了它这个抽象内

09:43.140 --> 09:45.140
不能创建对象之外

09:45.140 --> 09:47.140
它其实还有一些特点

09:47.140 --> 09:49.140
我们接下来再来看

09:49.140 --> 09:54.140
这一部分我们把它取名为抽象成员

09:54.140 --> 09:55.140
比方说

09:55.140 --> 09:56.140
我举个例子

09:56.140 --> 09:57.140
我一个个说

09:57.140 --> 09:58.140
首先我认为

09:58.140 --> 10:00.140
所有的旗子

10:00.140 --> 10:01.140
都有一个坐标

10:01.140 --> 10:03.140
都有一个坐标

10:03.140 --> 10:04.140
X坐标

10:04.140 --> 10:05.140
Number

10:05.140 --> 10:07.140
Y坐标

10:07.140 --> 10:08.140
Number

10:08.140 --> 10:09.140
坐标随便给吧

10:09.140 --> 10:10.140
随便给

10:10.140 --> 10:12.140
随便给个字

10:12.140 --> 10:13.140
然后呢

10:13.140 --> 10:14.140
其中还有个属性

10:14.140 --> 10:16.140
叫做旗子的名称

10:16.140 --> 10:18.140
旗子的名称

10:18.140 --> 10:20.140
Name这个属象

10:20.140 --> 10:21.140
是一个字乌串

10:21.140 --> 10:23.140
是一个旗子的名称

10:23.140 --> 10:24.140
好

10:24.140 --> 10:26.140
我们去关注一下这个属象

10:26.140 --> 10:27.140
Name这个属象

10:27.140 --> 10:29.140
如果我要给它副默认知

10:29.140 --> 10:30.140
旗子的名称

10:30.140 --> 10:32.140
首先能不能变

10:32.140 --> 10:33.140
能不能变

10:34.140 --> 10:35.140
那里看一下

10:35.140 --> 10:37.140
这是一个旗子对象

10:37.140 --> 10:38.140
这个旗子对象

10:38.140 --> 10:40.140
它的名字能不能变

10:40.140 --> 10:41.140
虽然没有玩过中国香旗

10:41.140 --> 10:43.140
但是你感觉到

10:43.140 --> 10:45.140
感觉到这个东西怎么能变呢

10:45.140 --> 10:47.140
你最多就消失了

10:47.140 --> 10:48.140
最多就消失了

10:48.140 --> 10:49.140
我爸吃了

10:49.140 --> 10:50.140
他就都消失了

10:50.140 --> 10:52.140
他到死都没有变

10:52.140 --> 10:53.140
变化过他的名称

10:53.140 --> 10:54.140
他的名字怎么能变呢

10:54.140 --> 10:56.140
说名字是不能变的

10:56.140 --> 10:58.140
因此我给名字加上一个Red only

10:58.140 --> 10:59.140
Red only

10:59.140 --> 11:01.140
这些都是一些小问题

11:01.140 --> 11:03.140
不是我们这些可能主要那种

11:03.140 --> 11:05.140
我们想到的就加上吧

11:05.140 --> 11:07.140
这个名字不能变

11:07.140 --> 11:09.140
那么名字它一定有一个确定的值

11:09.140 --> 11:10.140
对不对

11:10.140 --> 11:11.140
无论什么旗子

11:11.140 --> 11:13.140
它的名字一定是确定的

11:13.140 --> 11:15.140
一定有一个确定的值

11:15.140 --> 11:17.140
但是你想一想

11:17.140 --> 11:19.140
我们在附内里边

11:19.140 --> 11:20.140
我只知道

11:20.140 --> 11:21.140
每一个旗子

11:21.140 --> 11:23.140
它有名字的这个属象

11:23.140 --> 11:25.140
但是我在这里

11:25.140 --> 11:27.140
能不能知道它的值是啥

11:27.140 --> 11:29.140
这个值是啥我怎么知道呢

11:29.140 --> 11:31.140
它有可能是马有可能是炮

11:31.140 --> 11:32.140
有可能是

11:32.140 --> 11:34.140
居有可能是冰

11:34.140 --> 11:36.140
我不知道它的名字是啥

11:36.140 --> 11:38.140
那么这个时候怎么办呢

11:38.140 --> 11:40.140
我就没法复制了这个字后

11:40.140 --> 11:41.140
我就没有办法复制了

11:41.140 --> 11:42.140
明白这个意思吗

11:42.140 --> 11:44.140
我这里就没办法复出值

11:44.140 --> 11:46.140
不管是在这里复出值也好

11:46.140 --> 11:47.140
还是在

11:47.140 --> 11:50.140
够道函数里边给它复出值也好

11:50.140 --> 11:53.140
我都没有办法给它进行复制

11:53.140 --> 11:55.140
所以说这个地方我就写不了

11:55.140 --> 11:56.140
这个单法写不了

11:56.140 --> 11:58.140
我只能最多只能给它一个空置

11:58.140 --> 12:00.140
因为我确实也不知道

12:00.140 --> 12:01.140
在复列里边

12:01.140 --> 12:03.140
我不知道它的旗子名字叫啥

12:03.140 --> 12:06.140
那么换另外一个问题

12:06.140 --> 12:08.140
在纸内里边

12:08.140 --> 12:10.140
能不能清楚它的名字是啥

12:10.140 --> 12:11.140
比方说这个纸内

12:11.140 --> 12:12.140
Horse

12:12.140 --> 12:14.140
这是啥这是马

12:14.140 --> 12:15.140
那么在这个旗子里边

12:15.140 --> 12:17.140
能不能清楚它的名字是啥

12:17.140 --> 12:18.140
这就非常清楚了

12:18.140 --> 12:21.140
就非常清楚它的名字是啥了

12:21.140 --> 12:22.140
于是呢

12:22.140 --> 12:24.140
现在我们需要这么一个东西

12:24.140 --> 12:26.140
需要这么一个东西

12:26.140 --> 12:27.140
就是

12:27.140 --> 12:29.140
复内中

12:29.140 --> 12:31.140
复内中

12:31.140 --> 12:35.140
可能有些成员

12:35.140 --> 12:40.140
可能知道有些成员是必须存在的

12:40.140 --> 12:42.140
但是

12:42.140 --> 12:43.140
不知道什么

12:43.140 --> 12:46.140
不知道该成员的值

12:46.140 --> 12:47.140
或实现

12:47.140 --> 12:49.140
如果成员是方法的话

12:49.140 --> 12:51.140
就是知道有某一个方法是存在的

12:51.140 --> 12:53.140
以后我们就会举方法的例子

12:53.140 --> 12:54.140
我们先看值吧

12:54.140 --> 12:59.140
但是不知道这个成员的值是什么

12:59.140 --> 13:01.140
不知道这个值是什么

13:01.140 --> 13:02.140
因此

13:02.140 --> 13:04.140
需要有一种强约数

13:04.140 --> 13:08.140
需要有一种强约数

13:08.140 --> 13:14.140
让基层该内的纸内

13:14.140 --> 13:18.140
必须要实现该成员

13:18.140 --> 13:20.140
必须要去实现这个成员

13:20.140 --> 13:22.140
这就是一种强约数

13:22.140 --> 13:23.140
当然

13:23.140 --> 13:24.140
不用强约数行不行

13:24.140 --> 13:25.140
也行吧

13:25.140 --> 13:26.140
就像我们之前说的

13:26.140 --> 13:27.140
文档呗

13:27.140 --> 13:28.140
注释呗

13:28.140 --> 13:29.140
交流主要靠口

13:29.140 --> 13:30.140
靠记忆力

13:30.140 --> 13:32.140
这种弱约数也可以

13:32.140 --> 13:33.140
但既然有了强约数

13:33.140 --> 13:35.140
那为什么不用强约数

13:35.140 --> 13:37.140
弱约数还要造成更多的麻烦

13:37.140 --> 13:39.140
我要写文档写注释

13:39.140 --> 13:40.140
还要

13:40.140 --> 13:42.140
甚至有些公司把它写成一个

13:42.140 --> 13:44.140
就是公司的规范

13:44.140 --> 13:46.140
公司的规范

13:46.140 --> 13:48.140
或者是把它形成规章制度

13:48.140 --> 13:49.140
你要写代码的时候

13:49.140 --> 13:51.140
应该怎么去写

13:51.140 --> 13:53.140
还不如就写点代码

13:53.140 --> 13:55.140
给它加成一种强约数

13:55.140 --> 13:56.140
让它必须这样去做

13:56.140 --> 13:57.140
不这样做就爆错

13:57.140 --> 13:59.140
那么现在我们看一下

13:59.140 --> 14:02.140
纸内没有去给它这个内面属性复制

14:02.140 --> 14:03.140
没有给这个内面属性复制

14:03.140 --> 14:04.140
它爆不爆错

14:04.140 --> 14:05.140
有没有爆错

14:05.140 --> 14:06.140
肯定没有爆错

14:06.140 --> 14:07.140
也就是说

14:07.140 --> 14:10.140
现在是没有强约数的

14:10.140 --> 14:12.140
没有这个强约数

14:12.140 --> 14:14.140
没有说你一定要把它

14:14.140 --> 14:15.140
给它设置

14:15.140 --> 14:16.140
给它设置纸

14:16.140 --> 14:18.140
你一定要去处理一下

14:18.140 --> 14:19.140
这个内面属性

14:19.140 --> 14:20.140
并没有这样子的要求

14:20.140 --> 14:21.140
那么怎么办呢

14:21.140 --> 14:23.140
怎么来进行强约数呢

14:23.140 --> 14:25.140
非常简单

14:25.140 --> 14:26.140
这里

14:26.140 --> 14:27.140
这是个内面属性

14:27.140 --> 14:29.140
我附内只知道这个东西存在

14:29.140 --> 14:31.140
但是不知道它的值是什么

14:31.140 --> 14:33.140
怎么办

14:33.140 --> 14:35.140
让纸内必须要去

14:35.140 --> 14:37.140
实现这个内面属性

14:37.140 --> 14:38.140
因此呢

14:38.140 --> 14:40.140
遇到这种场景

14:40.140 --> 14:42.140
我只需要

14:42.140 --> 14:44.140
在这个属性前边

14:44.140 --> 14:46.140
加上一个关键字

14:48.140 --> 14:49.140
加上一个关键字

14:49.140 --> 14:51.140
表示这个属性

14:51.140 --> 14:53.140
也是抽象的

14:53.140 --> 14:55.140
咱们记一笔

14:55.140 --> 14:56.140
这个抽象成员是什么

14:56.140 --> 14:58.140
就是属性或者是方法

14:58.140 --> 15:01.140
它也可能是抽象的

15:01.140 --> 15:03.140
抽象内中

15:03.140 --> 15:05.140
可以有

15:05.140 --> 15:07.140
抽象成员

15:07.140 --> 15:09.140
注意前提条件

15:09.140 --> 15:11.140
抽象成员只能出现在

15:11.140 --> 15:13.140
抽象内里边

15:13.140 --> 15:14.140
你在一个普通的里边

15:14.140 --> 15:15.140
你不能写抽象成员

15:15.140 --> 15:17.140
比方说这是个普通的内

15:17.140 --> 15:18.140
普通的内

15:18.140 --> 15:20.140
为什么不能写抽象成员

15:20.140 --> 15:21.140
为什么不能写

15:21.140 --> 15:23.140
因为我要创建这个内的对象

15:23.140 --> 15:25.140
我是有可能直接创建

15:25.140 --> 15:26.140
这个内的对象的

15:26.140 --> 15:27.140
那它纸内有没有实现

15:27.140 --> 15:28.140
那怎么办

15:28.140 --> 15:29.140
那这个东西是啥

15:29.140 --> 15:30.140
对不对

15:30.140 --> 15:31.140
是不是这个道理

15:31.140 --> 15:33.140
如果你直接一个普通内的话

15:33.140 --> 15:35.140
我可以溜一个切实

15:35.140 --> 15:36.140
那么它这个属性

15:36.140 --> 15:37.140
怎么办

15:37.140 --> 15:39.140
它必须要让纸内实现的

15:39.140 --> 15:40.140
它自己有没有实现

15:40.140 --> 15:41.140
所以说

15:41.140 --> 15:43.140
抽象成员必须

15:43.140 --> 15:45.140
出现在抽象内里边

15:45.140 --> 15:47.140
抽象内中可以有抽象成员

15:47.140 --> 15:49.140
这些成员

15:49.140 --> 15:51.140
这些抽象成员

15:51.140 --> 15:53.140
必须占

15:53.140 --> 15:54.140
这是强越数

15:54.140 --> 15:56.140
纸内中实现

15:56.140 --> 15:58.140
就是我附内只知道

15:58.140 --> 15:59.140
它存在

15:59.140 --> 16:00.140
但是呢

16:00.140 --> 16:01.140
我不知道它怎么去实现

16:01.140 --> 16:02.140
特别是一些方法

16:02.140 --> 16:04.140
当然包括属性纸

16:04.140 --> 16:05.140
那么你纸内的时候

16:05.140 --> 16:06.140
那就必须要去实现了

16:06.140 --> 16:07.140
好

16:07.140 --> 16:08.140
怎么实现呢

16:08.140 --> 16:09.140
你看一下

16:09.140 --> 16:10.140
下面三个纸内全部冒错了

16:10.140 --> 16:12.140
它说附内里边有抽象

16:12.140 --> 16:13.140
有抽象成员

16:13.140 --> 16:14.140
但是呢

16:14.140 --> 16:15.140
你纸内

16:15.140 --> 16:16.140
没有去实现

16:16.140 --> 16:17.140
那么怎么实现呢

16:17.140 --> 16:19.140
我们可以指着这个错误

16:19.140 --> 16:21.140
这里一个快速修复

16:21.140 --> 16:23.140
它告诉你错误的原因

16:23.140 --> 16:25.140
它说非抽象内

16:25.140 --> 16:27.140
这个是非抽象内

16:27.140 --> 16:29.140
必须要去实现

16:29.140 --> 16:30.140
切实

16:30.140 --> 16:32.140
就是抽象内里边的成员

16:32.140 --> 16:33.140
它有个抽象成员

16:33.140 --> 16:35.140
什么样实现

16:35.140 --> 16:37.140
其实你就是把它写一遍

16:37.140 --> 16:39.140
你就是把它写一遍

16:39.140 --> 16:40.140
写一遍的时候

16:40.140 --> 16:41.140
还要求你复职

16:41.140 --> 16:42.140
复职呗

16:42.140 --> 16:43.140
这个地方就是麻

16:43.140 --> 16:44.140
对吧

16:44.140 --> 16:45.140
当然你也可以在

16:45.140 --> 16:47.140
够道函数里面复职也行

16:47.140 --> 16:48.140
够道函数里面复职也行

16:48.140 --> 16:50.140
也可以指着这个错误

16:50.140 --> 16:52.140
点快速修复

16:52.140 --> 16:53.140
这里

16:53.140 --> 16:54.140
实现

16:54.140 --> 16:57.140
以继承的抽象内

16:57.140 --> 16:58.140
好

16:58.140 --> 16:59.140
点一下

16:59.140 --> 17:00.140
你看

17:00.140 --> 17:01.140
它这里告诉你

17:01.140 --> 17:03.140
你要去实现这个属像

17:03.140 --> 17:05.140
需要去实现这个属像

17:05.140 --> 17:06.140
写呗

17:06.140 --> 17:07.140
这个是

17:07.140 --> 17:08.140
泡

17:08.140 --> 17:10.140
这个地方

17:10.140 --> 17:11.140
当然这个地方

17:11.140 --> 17:12.140
也可以在够道函数里面

17:12.140 --> 17:13.140
是一样的

17:13.140 --> 17:15.140
总之你要去把它实现

17:15.140 --> 17:16.140
复职不知道该怎么办

17:16.140 --> 17:18.140
你就需要把它实现

17:18.140 --> 17:19.140
只得在够道函数里面

17:19.140 --> 17:21.140
第一行必须要调用修复

17:21.140 --> 17:22.140
你看现在不调用

17:22.140 --> 17:23.140
还要包错的

17:23.140 --> 17:25.140
以前在GS里面还不会提示你

17:25.140 --> 17:27.140
但是现在在TS里面

17:27.140 --> 17:28.140
如果你够道函数

17:28.140 --> 17:29.140
只得在够道函数里面

17:29.140 --> 17:31.140
没有去手动调用复职的够道函数

17:31.140 --> 17:32.140
它是要包错的

17:32.140 --> 17:34.140
this.name

17:34.140 --> 17:37.650
等于泡

17:37.650 --> 17:39.650
这是也是一种方式

17:39.650 --> 17:41.650
还有一种实现方式呢

17:41.650 --> 17:42.650
还有一种实现方式呢

17:42.650 --> 17:44.650
就是使用我们之前讲的访问器

17:44.650 --> 17:45.650
因为访问器呢

17:45.650 --> 17:46.650
它也是属性

17:46.650 --> 17:47.650
对吧

17:47.650 --> 17:48.650
它也是属性

17:48.650 --> 17:50.650
比方说get

17:50.650 --> 17:52.650
这是个访问器

17:52.650 --> 17:53.650
返回

17:53.650 --> 17:55.650
返回的支付串

17:55.650 --> 17:56.650
这是bin

17:56.650 --> 17:57.650
对吧

17:57.650 --> 17:58.650
bin

17:58.650 --> 17:59.650
这几种实现方式都可以

17:59.650 --> 18:01.650
就关于属性这一块

18:01.650 --> 18:02.650
这几种实现方式都可以

18:02.650 --> 18:03.650
大家可以看一下

18:03.650 --> 18:05.650
这三种实现方式可以

18:05.650 --> 18:07.650
锐的 only 这个修复是可以省略的

18:07.650 --> 18:09.650
锐的 only 修复是可以不要的

18:09.650 --> 18:12.650
是可以把更改修复的

18:12.650 --> 18:14.650
我们知道修复全线这一块

18:14.650 --> 18:15.650
是可以更改的

18:15.650 --> 18:16.650
纸类是可以更改的

18:16.650 --> 18:18.650
但是我不太建议大家去更改

18:18.650 --> 18:20.650
我不太建议大家更改

18:20.650 --> 18:21.650
锐的 only

18:21.650 --> 18:22.650
因为毕竟在这种场景下面

18:22.650 --> 18:23.650
对吧

18:23.650 --> 18:25.650
名字它确实是指读的

18:25.650 --> 18:26.650
确实是指读的

18:26.650 --> 18:28.650
那下面这个怎么办呢

18:28.650 --> 18:29.650
下面这个我没有写

18:29.650 --> 18:30.650
set 访问器

18:30.650 --> 18:31.650
你看到没

18:31.650 --> 18:33.650
我只写了一个get访问器

18:33.650 --> 18:34.650
没有写set 访问器

18:34.650 --> 18:36.650
因此它本身就是指读的

18:36.650 --> 18:38.650
本身就是指读的

18:38.650 --> 18:40.650
大家看到在这么个场景下面

18:40.650 --> 18:42.650
附内里面有一个旗子

18:42.650 --> 18:45.650
旗子的名称我只知道有这么一个成员

18:45.650 --> 18:47.650
但是我不知道这个成员

18:47.650 --> 18:49.650
该如何来控制他的指示什么

18:49.650 --> 18:51.650
我不知道因此需要指内去实现

18:51.650 --> 18:53.650
而且这是一个强约术理

18:53.650 --> 18:55.650
你必须要去实现的

18:55.650 --> 18:56.650
你不能省略的

18:56.650 --> 18:57.650
必须要去实现

18:57.650 --> 18:59.650
就可以通过这种方式来完成了

18:59.650 --> 19:01.650
那么下面实现了过后了

19:01.650 --> 19:03.650
每一个旗子就有自己的名称了

19:03.650 --> 19:04.650
咱们来打印一下

19:04.650 --> 19:06.650
这个也没什么好看的

19:07.650 --> 19:09.650
把内结构搞清楚

19:12.650 --> 19:13.650
来看一下

19:14.650 --> 19:15.650
打印出来了

19:15.650 --> 19:17.650
每个具体的旗子的字内

19:17.650 --> 19:19.650
就有这个东西了

19:20.650 --> 19:24.650
这是咱们的抽象的属性

19:25.650 --> 19:26.650
除了属性之外

19:26.650 --> 19:28.650
其实还有方法

19:28.650 --> 19:29.650
还有抽象方法

19:30.650 --> 19:34.650
比方说有一个旗子移动的方法

19:34.650 --> 19:35.650
一个旗子移动的方法

19:35.650 --> 19:37.650
比方说叫物物

19:37.650 --> 19:38.650
这么一个方法

19:39.650 --> 19:42.650
你想是不是所有的旗子都能移动

19:43.650 --> 19:44.650
在中国乡旗里边

19:44.650 --> 19:46.650
所有的旗子都能移动

19:46.650 --> 19:47.650
都能移动

19:47.650 --> 19:48.650
不过移动的规则不一样

19:48.650 --> 19:49.650
比方说冰

19:49.650 --> 19:50.650
它不能跑这儿

19:50.650 --> 19:52.650
这个冰只能跑这儿

19:53.650 --> 19:54.650
然后抛的话

19:54.650 --> 19:55.650
它不能这样的鞋子跑

19:55.650 --> 19:56.650
也不行

19:56.650 --> 19:57.650
它可以直线跑

19:57.650 --> 19:58.650
跑这儿

19:58.650 --> 19:59.650
没问题

19:59.650 --> 20:00.650
香的话

20:00.650 --> 20:01.650
它不能直线跑

20:01.650 --> 20:03.650
香不能直线跑

20:03.650 --> 20:04.650
香只能

20:05.650 --> 20:06.650
香叫它

20:06.650 --> 20:07.650
香叫它非甜

20:07.650 --> 20:08.650
对吧

20:08.650 --> 20:09.650
只能非甜字

20:09.650 --> 20:10.650
甜字

20:10.650 --> 20:11.650
就是每个旗子

20:11.650 --> 20:13.650
还有自己的移动规则

20:13.650 --> 20:14.650
因此我这里

20:14.650 --> 20:16.650
但是每个旗子都能移动

20:16.650 --> 20:17.650
都能移动

20:17.650 --> 20:18.650
这是真的

20:18.650 --> 20:19.650
所有的旗子都能移动

20:19.650 --> 20:21.650
我们把这个名字叫目

20:21.650 --> 20:22.650
移动的时候

20:22.650 --> 20:24.650
你要给我一个目标

20:24.650 --> 20:25.650
目标的坐标

20:25.650 --> 20:27.650
比方说目标的X坐标

20:27.650 --> 20:28.650
你要移动到哪

20:28.650 --> 20:31.650
我要从当前的位置移动到这个位置

20:31.650 --> 20:32.650
比方说

20:32.650 --> 20:33.650
目标的X坐标

20:33.650 --> 20:35.650
其实这个东西也应该

20:35.650 --> 20:37.650
其实也可以把它做成抽象了

20:37.650 --> 20:38.650
对吧

20:38.650 --> 20:39.650
每个旗子

20:39.650 --> 20:40.650
它的出生的位置

20:40.650 --> 20:41.650
出死的位置是不一样的

20:41.650 --> 20:42.650
是不一样的

20:42.650 --> 20:43.650
所以这个地方

20:43.650 --> 20:44.650
也可以把它做成抽象的

20:44.650 --> 20:45.650
这个懒得弄了

20:45.650 --> 20:47.650
一个意思就行了

20:47.650 --> 20:50.650
目标的Y坐标

20:50.650 --> 20:52.650
就是你告诉我

20:52.650 --> 20:54.650
我要把这个旗子移动到哪去

20:54.650 --> 20:56.650
移动到哪去

20:56.650 --> 20:58.650
那么我请问大家

20:58.650 --> 21:00.650
这个地方能携带吗

21:00.650 --> 21:01.650
想一想

21:01.650 --> 21:03.650
如果一定要让你写的话

21:03.650 --> 21:05.650
一杂写

21:05.650 --> 21:07.650
一个问题的始终解决不了

21:07.650 --> 21:09.650
什么问题呢

21:09.650 --> 21:10.650
就是说

21:10.650 --> 21:12.650
我这个单码写到哪的

21:12.650 --> 21:13.650
写到这个旗子

21:13.650 --> 21:15.650
这个对象内里边的

21:15.650 --> 21:16.650
这个内里边

21:16.650 --> 21:18.650
它是它们的负物内

21:18.650 --> 21:19.650
所有的旗子

21:19.650 --> 21:20.650
我确实知道

21:20.650 --> 21:21.650
都有这么一个成员

21:21.650 --> 21:22.650
就是移动

21:22.650 --> 21:24.650
都能够引起移动

21:24.650 --> 21:25.650
当然返回一个布尔吧

21:25.650 --> 21:27.650
返回一个布尔

21:27.650 --> 21:28.650
返回布尔表示

21:28.650 --> 21:29.650
是否移动成功

21:29.650 --> 21:30.650
它有些情况是

21:30.650 --> 21:31.650
为者

21:31.650 --> 21:32.650
有些情况是

21:32.650 --> 21:33.650
目标位置

21:33.650 --> 21:35.650
已经有了一个旗子了

21:35.650 --> 21:36.650
也不能移动

21:36.650 --> 21:38.650
总之它有一个移动

21:38.650 --> 21:40.650
释放成功返回一个布尔

21:40.650 --> 21:42.650
关键是这里单码我没发写

21:42.650 --> 21:44.650
我这个是旗子的负类

21:44.650 --> 21:46.650
这个负类里边

21:46.650 --> 21:48.650
我怎么知道是什么旗子呢

21:48.650 --> 21:50.650
不同的旗子它规则不一样

21:50.650 --> 21:52.650
不同的旗子规则都不一样

21:52.650 --> 21:54.650
我怎么知道这个地方

21:54.650 --> 21:56.650
移动的到底是啥旗子呢

21:56.650 --> 21:58.650
所以这个单码我是没发写的

21:59.650 --> 22:01.650
这又出现这种情况了

22:01.650 --> 22:05.650
负类中可能知道有些成员是必须存在的

22:05.650 --> 22:07.650
切实里边你只要是个旗子

22:07.650 --> 22:08.650
你就能移动

22:08.650 --> 22:11.650
这肯定是我知道这个东西存在

22:11.650 --> 22:12.650
但是呢

22:12.650 --> 22:14.650
我不知道这个成员的值

22:14.650 --> 22:16.650
或实现的方法就是实现

22:16.650 --> 22:18.650
对方法体

22:18.650 --> 22:21.650
我不知道这个方法的实现是什么

22:21.650 --> 22:22.650
你看这里

22:22.650 --> 22:24.650
我知道这个成员存在

22:24.650 --> 22:25.650
但是我不知道怎么去实现它

22:25.650 --> 22:27.650
因为这里的情况太多了

22:27.650 --> 22:29.650
负类实现不了

22:29.650 --> 22:31.650
需要让纸内去实现

22:31.650 --> 22:33.650
纸内去实现这个方法

22:33.650 --> 22:34.650
怎么办

22:34.650 --> 22:35.650
怎么办

22:35.650 --> 22:37.650
做抽象

22:37.650 --> 22:39.650
直接结束不要写方法体

22:39.650 --> 22:40.650
方法体不写

22:40.650 --> 22:41.650
直接结束

22:41.650 --> 22:43.650
前面加上一个abstract

22:44.650 --> 22:46.650
表示是抽象方法

22:46.650 --> 22:49.650
其实咱们在使用abstract的时候

22:49.650 --> 22:51.650
抽象方法用的是最多的

22:51.650 --> 22:52.650
最多的

22:52.650 --> 22:54.650
就是我知道有一些动作

22:54.650 --> 22:55.650
有一些行为

22:55.650 --> 22:56.650
但是呢

22:56.650 --> 22:58.650
我不知道这个行为怎么去处理

22:58.650 --> 22:59.650
但是纸内非常清楚

22:59.650 --> 23:01.650
你看具体的题子

23:01.650 --> 23:02.650
马

23:02.650 --> 23:03.650
它非常清楚怎么移动

23:03.650 --> 23:04.650
马走日

23:04.650 --> 23:05.650
对吧

23:05.650 --> 23:06.650
马

23:06.650 --> 23:07.650
它能走

23:07.650 --> 23:08.650
它能走这个

23:08.650 --> 23:09.650
走日

23:09.650 --> 23:10.650
日之

23:10.650 --> 23:12.650
这里也是马可以走日

23:12.650 --> 23:13.650
包括这个马

23:13.650 --> 23:14.650
也可以这样走

23:14.650 --> 23:15.650
然后炮

23:15.650 --> 23:16.650
炮走横线

23:16.650 --> 23:18.650
炮走横线

23:19.650 --> 23:20.650
这样子都可以

23:20.650 --> 23:21.650
炮还可以这样子

23:22.650 --> 23:23.650
这样子

23:23.650 --> 23:24.650
随便写

23:25.650 --> 23:28.730
这样子

23:29.730 --> 23:30.730
这样子

23:30.730 --> 23:31.730
你看吃掉

23:31.730 --> 23:32.730
炮还可以

23:32.730 --> 23:33.730
吃旗子的时候

23:33.730 --> 23:35.730
还可以隔一个旗子去吃

23:35.730 --> 23:36.730
总之有些乱七八糟的规则

23:36.730 --> 23:38.730
我们不去研究这些规则

23:38.730 --> 23:40.730
这些规则我们不去研究

23:40.730 --> 23:41.730
我们只是说

23:42.730 --> 23:43.730
只是说啥呢

23:43.730 --> 23:44.730
只是说那个

23:44.730 --> 23:46.730
每个旗子有自己的规则

23:46.730 --> 23:47.730
它的规则是不一样的

23:47.730 --> 23:48.730
这些规则

23:48.730 --> 23:49.730
在具体的旗子里边

23:49.730 --> 23:50.730
是非常清楚的

23:50.730 --> 23:52.730
但是在腹内里边是不清楚的

23:52.730 --> 23:53.730
因为它不知道

23:53.730 --> 23:54.730
到底是哪一个旗子

23:54.730 --> 23:56.730
因此我把这个方法

23:56.730 --> 23:59.730
做成了一个抽象方法

23:59.730 --> 24:01.730
你看做成抽象方法之后

24:01.730 --> 24:02.730
你看这些纸内

24:02.730 --> 24:04.730
全部又爆错了

24:04.730 --> 24:06.730
这就是强约书

24:06.730 --> 24:07.730
强约书

24:07.730 --> 24:09.730
你既然有这个东西

24:09.730 --> 24:11.730
那你就必须要去实现

24:11.730 --> 24:13.730
我们又来想啊

24:13.730 --> 24:14.730
逻辑

24:14.730 --> 24:15.730
全是

24:15.730 --> 24:16.730
你不要去背这些

24:16.730 --> 24:17.730
死背这些规则

24:17.730 --> 24:19.730
背规则的话很恼火的

24:19.730 --> 24:20.730
你要去理解

24:20.730 --> 24:21.730
它为什么这样做

24:21.730 --> 24:23.730
为什么你这样去处理

24:23.730 --> 24:25.730
凭什么抽象方法

24:25.730 --> 24:27.730
你指的就必须要实现

24:27.730 --> 24:29.730
必须要去实现这个抽象方法

24:29.730 --> 24:31.730
凭什么了

24:31.730 --> 24:33.730
你想这个道理

24:33.730 --> 24:34.730
如果你不实现

24:34.730 --> 24:37.730
如果允许你不实现的话

24:37.730 --> 24:39.730
马是不是旗子

24:39.730 --> 24:40.730
炮是不是旗子

24:40.730 --> 24:42.730
冰是不是旗子

24:42.730 --> 24:44.730
那么旗子里面有个成员

24:44.730 --> 24:45.730
共有的成员

24:45.730 --> 24:46.730
移动

24:46.730 --> 24:48.730
那我可以去调用移动方法哦

24:48.730 --> 24:50.730
移动呗

24:50.730 --> 24:51.730
移动目标位置

24:51.730 --> 24:52.730
随便写个

24:52.730 --> 24:54.730
随便写个目标位置

24:54.730 --> 24:55.730
发挥一个布尔

24:55.730 --> 24:56.730
那如果你不实现的话

24:56.730 --> 24:57.730
这个方法

24:57.730 --> 24:58.730
它怎么调用了

24:58.730 --> 24:59.730
复内又没有实现

24:59.730 --> 25:01.730
复内它确实不知道怎么实现

25:01.730 --> 25:02.730
复内也不可能直接

25:02.730 --> 25:04.730
创建复内的对象

25:04.730 --> 25:05.730
所以说

25:05.730 --> 25:06.730
所以说这里也解释到

25:06.730 --> 25:08.730
为什么抽象成员

25:08.730 --> 25:10.730
必须要出现在抽象那一种

25:10.730 --> 25:11.730
如果它不

25:11.730 --> 25:12.730
如果是一个普通类里面

25:12.730 --> 25:13.730
出现抽象成员

25:13.730 --> 25:14.730
你想一下这个道理

25:14.730 --> 25:16.730
如果是一个普通类里面

25:16.730 --> 25:17.730
出现了抽象成员

25:17.730 --> 25:18.730
那我可以创建它的对象

25:18.730 --> 25:19.730
那我可以调用

25:19.730 --> 25:20.730
说我怎么调用了

25:20.730 --> 25:21.730
它都没有实现

25:21.730 --> 25:22.730
我怎么调用了

25:22.730 --> 25:23.730
是没法调用

25:23.730 --> 25:25.730
因此抽象成员里边

25:25.730 --> 25:28.730
抽象成员必须出现在抽象那一种

25:28.730 --> 25:30.730
而指内为什么要实现

25:30.730 --> 25:32.730
如果你指内都不去实现的话

25:32.730 --> 25:34.730
那我是这里调用的话

25:34.730 --> 25:35.730
那怎么调用了

25:35.730 --> 25:36.730
怎么调用了

25:36.730 --> 25:37.730
没法调用

25:37.730 --> 25:38.730
它没有实现

25:38.730 --> 25:39.730
它有可能没实现

25:39.730 --> 25:40.730
所以说没法调用

25:40.730 --> 25:41.730
就会出现隐患

25:41.730 --> 25:43.730
因此还要求你指内

25:43.730 --> 25:45.730
必须要去实现抽象成员

25:45.730 --> 25:48.730
所以一切按照逻辑去想

25:48.730 --> 25:51.730
千万不要去实际用背

25:51.730 --> 25:53.730
你背不住的这规则太多了

25:53.730 --> 25:54.730
再比方说

25:54.730 --> 25:56.730
还有规则我都没给大家讲

25:56.730 --> 25:58.730
那大家自己想

25:58.730 --> 25:59.730
大家自己想

25:59.730 --> 26:00.730
如果我

26:00.730 --> 26:01.730
来吧 想一下

26:01.730 --> 26:03.730
按照逻辑来想一下

26:03.730 --> 26:04.730
假设

26:04.730 --> 26:05.730
随便我做个假设

26:05.730 --> 26:07.730
假设这是一个抽象内

26:07.730 --> 26:10.730
这个指内也是一个抽象内

26:10.730 --> 26:12.730
那么你想一想

26:12.730 --> 26:14.730
它可不可以不实现

26:14.730 --> 26:16.730
附内的抽象方法

26:16.730 --> 26:19.730
可不可以不实现

26:19.730 --> 26:20.730
你想那个道理

26:20.730 --> 26:22.730
其实你已经看到结果了

26:22.730 --> 26:23.730
对吧

26:23.730 --> 26:24.730
已经看到结果了

26:24.730 --> 26:25.730
可不可以不实现

26:25.730 --> 26:26.730
我可以不实现

26:26.730 --> 26:28.730
这个满足逻辑

26:28.730 --> 26:29.730
逻辑是通的

26:29.730 --> 26:31.730
因为你这个也是抽象内

26:31.730 --> 26:33.730
它也不可能创建对象

26:33.730 --> 26:34.730
对吧

26:34.730 --> 26:35.730
你不可能去创建它的对象的

26:35.730 --> 26:36.730
所以说

26:36.730 --> 26:38.730
可以允许你这里面没有实现

26:38.730 --> 26:40.730
让它的指内再去实现

26:40.730 --> 26:42.730
我这边可以再加一些抽象方法

26:42.730 --> 26:43.730
那么你指

26:43.730 --> 26:44.730
它的指内

26:44.730 --> 26:46.730
就要把它的抽象方法实现

26:46.730 --> 26:48.730
也要把它的附内的抽象方法

26:48.730 --> 26:49.730
全部实现

26:49.730 --> 26:51.730
当然它这里面也可以实现

26:51.730 --> 26:52.730
总之什么时候实现

26:52.730 --> 26:54.730
你知道怎么实现你就实现

26:54.730 --> 26:55.730
你不知道怎么实现

26:55.730 --> 26:57.730
你就不要去实现

26:57.730 --> 26:58.730
跟你没有什么关系

26:58.730 --> 27:00.730
需要指内去实现的

27:00.730 --> 27:02.730
原来这个意思吧

27:02.730 --> 27:03.730
这就是

27:03.730 --> 27:04.730
这个好好理一下

27:04.730 --> 27:06.730
这一切都是根据逻辑来出发的

27:06.730 --> 27:07.730
就是面向对象

27:07.730 --> 27:09.730
它是非常贴合

27:09.730 --> 27:11.730
现实逻辑的

27:11.730 --> 27:13.730
我们来实现一下

27:13.730 --> 27:15.730
这个码

27:15.730 --> 27:17.730
点击实现

27:17.730 --> 27:19.730
实现这个方法

27:19.730 --> 27:21.730
自己给你列出来

27:21.730 --> 27:22.730
比方说

27:22.730 --> 27:24.730
假设我就直接移动成功

27:26.730 --> 27:28.730
把当前的坐标改变

27:30.730 --> 27:32.730
把当前的坐标改变

27:32.730 --> 27:34.730
然后输出一个

27:34.730 --> 27:36.730
输出一个

27:36.730 --> 27:38.730
移动成功

27:39.730 --> 27:41.730
假设移动成功

27:41.730 --> 27:43.730
发挥一个处

27:44.730 --> 27:45.730
好然后了

27:45.730 --> 27:47.730
下边我们复制一下

27:47.730 --> 27:48.730
复制一下

27:48.730 --> 27:54.510
这里也是一样实现

27:54.510 --> 27:56.510
实现这个移动成功

27:56.510 --> 27:57.510
发挥处

27:57.510 --> 27:59.510
这个应该是输出

27:59.510 --> 28:02.510
码移动成功

28:02.510 --> 28:05.510
这个是砲移动成功

28:05.510 --> 28:08.820
这个下边

28:08.820 --> 28:10.820
实现

28:11.820 --> 28:13.820
这个是冰移动成功

28:13.820 --> 28:15.820
就随便写一个

28:15.820 --> 28:16.820
写完了之后

28:16.820 --> 28:17.820
现在就不报错了

28:17.820 --> 28:18.820
因为它的纸内

28:18.820 --> 28:19.820
都去实现了

28:19.820 --> 28:20.820
它所谓的抽象成员

28:20.820 --> 28:22.820
内面的抽象成员

28:22.820 --> 28:23.820
实现了

28:23.820 --> 28:24.820
这个抽象方法

28:24.820 --> 28:25.820
实现了都实现了

28:25.820 --> 28:26.820
OK了

28:26.820 --> 28:27.820
那现在就不报错了

28:27.820 --> 28:28.820
不报错了

28:28.820 --> 28:29.820
那么我们把这些旗子

28:29.820 --> 28:31.820
随便移动一下吧

28:31.820 --> 28:32.820
现在都写了

28:32.820 --> 28:34.820
不移动也不好意思

28:34.820 --> 28:36.820
随便移动一下

28:39.820 --> 28:40.820
随便写

28:40.820 --> 28:42.820
现在都是假的

28:42.820 --> 28:45.820
就是直接都是移动成功的

28:45.820 --> 28:46.820
再来看一下

28:46.820 --> 28:48.820
就移动成功了

28:48.820 --> 28:49.820
那么使用的是

28:49.820 --> 28:51.820
纸内它的实现的方法

28:51.820 --> 28:54.820
这是关于抽象成员这一块

28:54.820 --> 28:56.820
抽象成员这一块

28:56.820 --> 28:57.820
注意的是

28:57.820 --> 29:00.820
抽象成员只能出现在抽象内中

29:00.820 --> 29:02.820
为什么要出现抽象内

29:02.820 --> 29:03.820
是因为有些内

29:03.820 --> 29:05.820
我们确实不允许它创建对象

29:05.820 --> 29:06.820
没有什么意义

29:06.820 --> 29:08.820
防止它犯这种错误

29:08.820 --> 29:09.820
我们可以使用

29:09.820 --> 29:10.820
abstract

29:10.820 --> 29:11.820
强约数

29:11.820 --> 29:13.820
不能去创建对象

29:13.820 --> 29:14.820
那么在抽象内里边

29:14.820 --> 29:15.820
有一些成员

29:15.820 --> 29:17.820
因为它已经高度抽象了

29:17.820 --> 29:19.820
这个内它是高度抽象的

29:19.820 --> 29:20.820
它是抽象出来的概念

29:20.820 --> 29:21.820
旗子

29:21.820 --> 29:24.820
这个世界上并没有旗子这个东西

29:24.820 --> 29:26.820
旗子是一个抽象概念

29:26.820 --> 29:27.820
有的是什么

29:27.820 --> 29:28.820
有的是马

29:28.820 --> 29:29.820
橘

29:29.820 --> 29:30.820
炮

29:30.820 --> 29:31.820
兵

29:31.820 --> 29:32.820
有的是这些东西

29:32.820 --> 29:33.820
并不存在这个抽象概念

29:33.820 --> 29:34.820
所以说

29:34.820 --> 29:35.820
它不能创建对象

29:35.820 --> 29:36.820
并且由于它高度抽象

29:36.820 --> 29:38.820
它里面的有些成员

29:38.820 --> 29:40.820
它是不知道怎么去实现的

29:40.820 --> 29:41.820
它并不知道

29:41.820 --> 29:43.820
需要去指内去实现

29:43.820 --> 29:45.820
那么如何来进行强约数呢

29:45.820 --> 29:46.820
就是使用抽象成员

29:46.820 --> 29:49.820
在成员前边加上一个

29:49.820 --> 29:50.820
protected

29:50.820 --> 29:53.260
好

29:53.260 --> 29:54.260
其实讲到这

29:54.260 --> 29:56.260
我们这个抽象内这一块

29:56.260 --> 29:58.260
解释就结束了

29:58.260 --> 29:59.260
但是既然

29:59.260 --> 30:01.260
我们要说到面向对象思想

30:01.260 --> 30:03.260
我还是希望给大家

30:03.260 --> 30:05.260
多扩展一些东西

30:05.260 --> 30:06.260
所以说

30:06.260 --> 30:07.260
你可以看到

30:07.260 --> 30:08.260
我们

30:08.260 --> 30:10.260
目前我录视频的时候

30:10.260 --> 30:11.260
以后我说不准

30:11.260 --> 30:12.260
目前我录视频的时候

30:12.260 --> 30:14.260
网上的所有的TS教程

30:14.260 --> 30:16.260
你可以去对比一下

30:16.260 --> 30:18.260
应该是没有一个TS教程

30:18.260 --> 30:19.260
能够有

30:19.260 --> 30:21.260
咱们杜仪学院的TS教程

30:21.260 --> 30:23.260
讲得那么深的

30:23.260 --> 30:25.260
讲的东西确实很多

30:25.260 --> 30:26.260
我其实也不希望

30:26.260 --> 30:27.260
把它讲得太深了

30:27.260 --> 30:28.260
但是呢

30:28.260 --> 30:29.260
既然在用TS

30:29.260 --> 30:31.260
它肯定要用到大型项目里边

30:31.260 --> 30:33.260
大型的复杂的项目里边

30:33.260 --> 30:35.260
去使用TS

30:35.260 --> 30:36.260
你

30:36.260 --> 30:38.260
或多或少都会接触到这些东西

30:38.260 --> 30:39.260
都会接触到

30:39.260 --> 30:41.260
所以说你看

30:41.260 --> 30:42.260
你要学习TS

30:42.260 --> 30:43.260
肯定是为了应付大型项目的

30:43.260 --> 30:44.260
对吧

30:44.260 --> 30:45.260
目前来看

30:45.260 --> 30:46.260
主要是为了应付大型项目

30:46.260 --> 30:48.260
因此你这个

30:48.260 --> 30:50.260
你要学习很多面向对象的

30:50.260 --> 30:51.260
相关的知识

30:51.260 --> 30:52.260
因此我在这里

30:52.260 --> 30:53.260
既然在讲TS

30:53.260 --> 30:56.260
我会尽量的把这些东西补充尽量

30:56.260 --> 30:58.260
我给大家讲一种设计模式

31:01.260 --> 31:04.260
设计模式

31:04.260 --> 31:05.260
其中一种设计模式

31:05.260 --> 31:06.260
设计模式太多了

31:06.260 --> 31:07.260
有很多很多种

31:07.260 --> 31:08.260
设计模式

31:08.260 --> 31:09.260
也是对初学者

31:09.260 --> 31:11.260
学习有点牢火的地方

31:11.260 --> 31:13.260
但是我尽量把它讲简单一点

31:13.260 --> 31:14.260
我不会讲完的

31:14.260 --> 31:15.260
放心

31:15.260 --> 31:16.260
不会讲完的

31:16.260 --> 31:17.260
我讲这么其中

31:17.260 --> 31:18.260
有的时候遇到了

31:18.260 --> 31:19.260
一些常见的一些模式

31:19.260 --> 31:21.260
我会来讲一讲

31:21.260 --> 31:23.260
这里是讲的模式叫模板模式

31:25.260 --> 31:27.260
首先什么叫模式呢

31:27.260 --> 31:29.260
什么叫做设计模式

31:29.260 --> 31:32.260
就是面对一些

31:32.260 --> 31:37.260
常见的功能场景

31:37.260 --> 31:39.260
有些常见的功能场景

31:39.260 --> 31:41.260
也要用代码去实现一些

31:41.260 --> 31:43.260
常见的功能场景的时候

31:43.260 --> 31:47.260
有一些固定的

31:47.260 --> 31:52.260
经过多连检验

31:52.260 --> 31:57.260
多连实践的成熟方法

31:57.260 --> 32:00.260
就叫做

32:00.260 --> 32:02.260
应该这些方法

32:02.260 --> 32:05.260
称之为设计模式

32:05.260 --> 32:06.260
我这里是自己用

32:06.260 --> 32:08.260
语言组织的一个中间

32:08.260 --> 32:09.260
就表示这是

32:09.260 --> 32:11.260
我们在用面向对象

32:11.260 --> 32:13.260
去开发一些功能的时候

32:13.260 --> 32:16.260
遇到了一些常见的一些问题

32:16.260 --> 32:17.260
那么这些问题

32:17.260 --> 32:18.260
我们觉得不太好处理

32:18.260 --> 32:19.260
于是我们进行摸索

32:19.260 --> 32:21.260
经过一

32:21.260 --> 32:23.260
很多很多的程序而

32:23.260 --> 32:25.260
很多很多的开发者

32:25.260 --> 32:26.260
慢慢去摸索

32:26.260 --> 32:27.260
慢慢的呢

32:27.260 --> 32:28.260
就会发现

32:28.260 --> 32:29.260
我们解决这种方式

32:29.260 --> 32:31.260
有一种非常巧妙的方法

32:31.260 --> 32:33.260
可以把这个问题得以解决

32:33.260 --> 32:34.260
那么后来把这些方法

32:34.260 --> 32:35.260
总结出来就形成了

32:35.260 --> 32:37.260
一套固定的模式

32:37.260 --> 32:39.260
那么这就是设计模式

32:39.260 --> 32:40.260
设计模式有很多

32:40.260 --> 32:42.260
我这里给大家介绍一种

32:42.260 --> 32:43.260
叫模板模式

32:43.260 --> 32:44.260
它是用来解决

32:44.260 --> 32:45.260
什么问题呢

32:45.260 --> 32:47.260
大家看一下这个问题

32:47.260 --> 32:48.260
其实我觉得

32:48.260 --> 32:49.260
讲面向对象的

32:49.260 --> 32:51.260
这些思维的时候

32:51.260 --> 32:52.260
用这个中位象

32:52.260 --> 32:54.260
其实蛮好的

32:54.260 --> 32:55.260
只是有些同学

32:55.260 --> 32:57.260
不太知道它的规则

32:57.260 --> 32:59.260
好这里看一下

32:59.260 --> 33:01.260
我们关注移动

33:01.260 --> 33:03.260
移动这里

33:03.260 --> 33:05.260
你会发现

33:05.260 --> 33:07.260
无论是马的移动

33:07.260 --> 33:08.260
炮的移动

33:08.260 --> 33:10.260
还是兵的移动

33:10.260 --> 33:11.260
他们都可能会产生

33:11.260 --> 33:13.260
一些共同的代码

33:13.260 --> 33:14.260
对不对

33:14.260 --> 33:15.260
它有可能会产生

33:15.260 --> 33:16.260
一些共同的代码

33:16.260 --> 33:18.260
现在大家心态放轻松

33:18.260 --> 33:20.260
这里在讲设计模式

33:20.260 --> 33:21.260
不要用了

33:21.260 --> 33:23.260
可以当做一种

33:23.260 --> 33:24.260
开拓视野的东西

33:24.260 --> 33:25.260
如果你实在学不懂的话

33:25.260 --> 33:26.260
也没关系

33:26.260 --> 33:28.260
我会尽量的把讲清楚

33:29.260 --> 33:31.260
这里有个移动方法

33:31.260 --> 33:32.260
这个移动方法

33:32.260 --> 33:34.260
它里面可能会有一些

33:34.260 --> 33:35.260
重塑代码

33:35.260 --> 33:36.260
就举个例子

33:36.260 --> 33:38.260
比方说马的移动

33:38.260 --> 33:40.260
它判断哪些东西

33:40.260 --> 33:41.260
你移动的目标

33:41.260 --> 33:43.260
不能跑到棋盘外面去了

33:43.260 --> 33:44.260
你不能这个是复苏

33:44.260 --> 33:46.260
你不能这个是复苏

33:46.260 --> 33:48.260
你不能这个是以前一万

33:48.260 --> 33:50.260
你不能跑到棋盘外面去了

33:50.260 --> 33:52.260
所以说我们有第一个判断

33:52.260 --> 33:53.260
第一个判断

33:53.260 --> 33:54.260
我们直接输出

33:54.260 --> 33:55.260
我们要经过哪些处理

33:55.260 --> 33:56.260
当然我这里

33:56.260 --> 33:57.260
不会挨在这写代

33:57.260 --> 34:01.260
我只是把这个逻辑给大家打印出来

34:01.260 --> 34:02.260
第一步

34:02.260 --> 34:04.260
判断边界判断

34:05.260 --> 34:06.260
边界判断

34:06.260 --> 34:08.260
要做边界的判断

34:08.260 --> 34:10.260
就是说我要判断一下

34:10.260 --> 34:12.260
这个东西和这个东西

34:12.260 --> 34:13.260
是不是跑到棋盘外边去了

34:13.260 --> 34:16.260
如果跑到棋盘外边去了的话

34:16.260 --> 34:17.260
直接失败

34:17.260 --> 34:18.260
这个移动不成功

34:18.260 --> 34:20.260
还有什么要判断的

34:21.260 --> 34:23.260
还有什么要判断的

34:24.260 --> 34:25.260
第二个判断

34:26.260 --> 34:27.260
就是

34:28.260 --> 34:29.260
什么

34:30.260 --> 34:32.260
目标位置

34:33.260 --> 34:35.260
是否有

34:35.260 --> 34:37.260
几方棋子

34:38.260 --> 34:39.260
你想一想

34:39.260 --> 34:40.260
比方说

34:41.260 --> 34:42.260
这个G

34:42.260 --> 34:43.260
这个G

34:43.260 --> 34:44.260
我要移动

34:44.260 --> 34:46.260
G这个棋子是可以走直线的

34:46.260 --> 34:48.260
但是能跑这来吗

34:48.260 --> 34:50.260
G能不能跑这来

34:50.260 --> 34:51.260
跑不过来

34:51.260 --> 34:53.260
因为这个位置有几方棋子

34:53.260 --> 34:54.260
把挡住了

34:54.260 --> 34:55.260
跑不过来

34:56.260 --> 34:57.260
所以说这个地方

34:57.260 --> 34:59.260
还要做这个判断

34:59.260 --> 35:00.260
你随便什么棋子

35:00.260 --> 35:02.260
你不能跑到自己的棋子上面去

35:02.260 --> 35:04.260
目标位置是否有几方棋子

35:05.260 --> 35:06.260
有这么一个判断

35:06.260 --> 35:07.260
假设吧

35:07.260 --> 35:09.260
就做了这么两个判断

35:09.260 --> 35:10.260
做了这么两个判断

35:10.260 --> 35:11.260
然后再来一个

35:12.260 --> 35:13.260
第三个

35:15.260 --> 35:18.260
棋子移动规则判断

35:18.260 --> 35:19.260
就是

35:19.260 --> 35:20.260
走日

35:20.260 --> 35:22.260
跑走直线

35:22.260 --> 35:23.260
然后呢

35:23.260 --> 35:24.260
兵呢

35:24.260 --> 35:25.260
走一格

35:25.260 --> 35:27.260
兵只能一格一格走

35:27.260 --> 35:29.260
就是移动规则进行判断

35:30.260 --> 35:31.260
假设咱们经过

35:31.260 --> 35:32.260
其实还有一些判断的

35:32.260 --> 35:34.260
假设经过这么三个判断

35:35.260 --> 35:36.260
如果是三个判断

35:36.260 --> 35:37.260
任何一个判断不满足

35:37.260 --> 35:38.260
直接结束

35:38.260 --> 35:39.260
返回一个force

35:39.260 --> 35:41.260
如果全部满足的话

35:41.260 --> 35:43.260
那么完成移动

35:44.260 --> 35:45.260
也就是说

35:46.260 --> 35:47.260
说啥呢

35:47.260 --> 35:48.260
咱们这个

35:48.260 --> 35:49.260
代码呀

35:49.260 --> 35:51.260
它是有一种模式的

35:51.260 --> 35:52.260
看到没

35:53.260 --> 35:55.260
无论你是哪个棋子

35:55.260 --> 35:56.260
你的代码

35:56.260 --> 35:58.260
都是有一种模式的

35:59.260 --> 36:00.260
看到没

36:00.260 --> 36:02.260
每个代码都有一种模式

36:02.260 --> 36:03.260
都有这种模式

36:03.260 --> 36:04.260
那么这里面

36:04.260 --> 36:05.260
你想一想

36:05.260 --> 36:06.260
是不是出现了重复代码

36:06.260 --> 36:08.260
这个地方是不是重复的

36:08.260 --> 36:10.260
所有的棋子

36:10.260 --> 36:11.260
甭管理是啥棋子

36:11.260 --> 36:12.260
一边界判断的

36:12.260 --> 36:13.260
规则是一样的

36:14.260 --> 36:15.260
你目标位置

36:15.260 --> 36:16.260
是否有几方棋子

36:16.260 --> 36:17.260
这个规则是一样的

36:17.260 --> 36:19.260
你看全是重复的代码

36:19.260 --> 36:20.260
然后呢

36:20.260 --> 36:21.260
就这个地方不同

36:21.260 --> 36:22.260
就第三步不同

36:22.260 --> 36:24.260
因为每个棋子的规则不一样

36:24.260 --> 36:26.260
就第三个地方不同

36:26.260 --> 36:27.260
然后后边

36:27.260 --> 36:28.260
是不是也是一样的

36:28.260 --> 36:29.260
如果成功了

36:29.260 --> 36:30.260
如果移动成功

36:30.260 --> 36:31.260
那么复制

36:31.260 --> 36:32.260
复制完了返回处

36:32.260 --> 36:34.260
这个是不是也是一样的

36:34.260 --> 36:35.260
对不对

36:35.260 --> 36:36.260
还是一样的

36:36.260 --> 36:38.260
那么我们分析一下

36:39.260 --> 36:40.260
每一个子内的

36:40.260 --> 36:42.260
这个木武方法

36:43.260 --> 36:44.260
他们

36:44.260 --> 36:45.260
这两个代码一样

36:45.260 --> 36:46.260
当然这两行

36:46.260 --> 36:47.260
不是两行

36:47.260 --> 36:48.260
真实的情况下

36:48.260 --> 36:49.260
这里肯定是大量的代码

36:49.260 --> 36:50.260
它不是两行

36:50.260 --> 36:51.260
就搞定的

36:51.260 --> 36:53.260
这一块代码一样

36:53.260 --> 36:54.260
对不对

36:56.260 --> 36:59.260
那么我们如何来提取重复代码呢

37:00.260 --> 37:01.260
怎么来提取呢

37:03.260 --> 37:04.260
有些同学呢

37:04.260 --> 37:05.260
可能非常聪明

37:05.260 --> 37:06.260
怎么想呢

37:06.260 --> 37:07.260
他可能会这样子写

37:08.260 --> 37:10.260
在复列里边呢

37:10.260 --> 37:12.260
我把一些相同的代码

37:12.260 --> 37:13.260
帮到复列里边

37:13.260 --> 37:15.260
因为复列的所有的资源

37:15.260 --> 37:17.260
所有的成员子内都可以使用

37:17.260 --> 37:18.260
都可以使用

37:18.260 --> 37:19.260
把它放到复列里边

37:19.260 --> 37:20.260
比方说

37:20.260 --> 37:21.260
这些成员呢

37:21.260 --> 37:24.260
也是帮助子内去实现木武方法的

37:24.260 --> 37:26.260
因此我用Protected

37:26.260 --> 37:29.260
我不必把它做成公共的

37:29.260 --> 37:30.260
公共的不太好

37:30.260 --> 37:31.260
因为外边的话

37:31.260 --> 37:33.260
不需要去外边的调用

37:33.260 --> 37:34.260
不需要外边的人来调用

37:34.260 --> 37:36.260
只是在实现这个移动的时候

37:36.260 --> 37:38.260
我需要一些辅助的方法

37:38.260 --> 37:39.260
边界判断

37:41.260 --> 37:43.260
Is outside

37:43.260 --> 37:44.260
是不是跑到外边去了

37:45.260 --> 37:47.260
假设有这么一个函数

37:50.260 --> 37:52.260
反回一个布尔

37:52.260 --> 37:54.260
我这里随便写吧

37:54.260 --> 37:55.260
随便写

37:55.260 --> 37:56.260
是不是跑到外边去了

37:56.260 --> 37:58.260
有这么一个辅助函数

37:58.260 --> 38:00.260
这我们输出

38:00.260 --> 38:01.260
边界判断

38:02.260 --> 38:03.260
边界判断在这

38:03.260 --> 38:05.260
然后再写个函数

38:08.260 --> 38:09.260
目标位置

38:09.260 --> 38:10.260
Target

38:11.260 --> 38:12.260
还是

38:15.260 --> 38:17.260
几方旗子

38:17.260 --> 38:19.260
几方旗子怎么说

38:19.260 --> 38:21.260
就是盟友怎么说

38:27.260 --> 38:29.260
我实在不知道这单词该怎么写

38:29.260 --> 38:32.260
反回一个布尔

38:32.260 --> 38:34.260
这里我输出

38:35.260 --> 38:36.260
输这个

38:38.260 --> 38:39.260
反回Force

38:40.260 --> 38:42.260
假设这个函数

38:42.260 --> 38:43.260
做边界判断的

38:43.260 --> 38:44.260
反回一个布尔

38:44.260 --> 38:45.260
这个函数

38:45.260 --> 38:46.260
判断目标位置

38:46.260 --> 38:47.260
是否有几方旗子

38:47.260 --> 38:48.260
肯定不止一行呆

38:48.260 --> 38:49.260
有很多的

38:50.260 --> 38:51.260
然后这两个函数

38:51.260 --> 38:53.260
都把它设置成为Protected

38:53.260 --> 38:55.260
表示只能

38:55.260 --> 38:56.260
只内调用

38:56.260 --> 38:57.260
外边是不能调用的

38:57.260 --> 38:58.260
这也非常合理

38:58.260 --> 38:59.260
这两个函数

38:59.260 --> 39:01.260
是来辅助实现这个东西的

39:01.260 --> 39:02.260
不希望外边

39:02.260 --> 39:03.260
能够访问到

39:05.260 --> 39:06.260
如果能移动成功的时候

39:06.260 --> 39:08.260
又来一个辅助函数

39:08.260 --> 39:09.260
又来一个辅助函数

39:09.260 --> 39:10.260
就这个

39:10.260 --> 39:12.260
完成移动

39:13.260 --> 39:14.260
Felix

39:15.260 --> 39:16.260
Move

39:16.260 --> 39:17.260
完成移动

39:17.260 --> 39:18.260
当然其实这些函数

39:18.260 --> 39:19.260
都有参数的

39:19.260 --> 39:20.260
都要把参数传过来

39:20.260 --> 39:22.260
都要把Target X

39:22.260 --> 39:23.260
Target Y

39:23.260 --> 39:24.260
传过来的

39:25.260 --> 39:26.260
完成移动

39:26.260 --> 39:28.260
这个就不返回了吧

39:28.260 --> 39:29.260
不返回了

39:29.260 --> 39:31.640
OK

39:31.640 --> 39:33.950
完成

39:33.950 --> 39:34.950
这里把它传过来

39:34.950 --> 39:35.950
传过来

39:35.950 --> 39:40.310
好了

39:40.310 --> 39:41.310
我现在写了

39:41.310 --> 39:42.310
三个函数

39:42.310 --> 39:43.310
到附内底边

39:43.310 --> 39:44.310
那你想一想

39:44.310 --> 39:45.310
指内是不是轻松多了

39:45.310 --> 39:46.310
指内

39:46.310 --> 39:48.310
我就没必要写这句话了

39:48.310 --> 39:49.310
怎么办

39:49.310 --> 39:50.310
调用这个函数

39:50.310 --> 39:52.310
我也没有必要去写这句话了

39:52.310 --> 39:53.310
怎么办

39:53.310 --> 39:54.310
调用这个函数

39:54.310 --> 39:56.310
解决了重复代码的问题

39:56.310 --> 39:57.310
然后这个代码

39:57.310 --> 39:58.310
也不用写了

39:58.310 --> 39:59.310
调用这个函数

40:00.310 --> 40:01.310
那么问题

40:01.310 --> 40:03.310
好像得到解决了

40:03.310 --> 40:05.310
但是这种情况下

40:05.310 --> 40:07.310
问题真的解决了吗

40:07.310 --> 40:08.310
当然我这样问

40:08.310 --> 40:09.310
肯定是没有解决

40:09.310 --> 40:11.310
为什么没有解决呢

40:11.310 --> 40:12.310
他还会遇到

40:12.310 --> 40:14.310
这么两个问题

40:14.310 --> 40:15.310
这两个问题

40:15.310 --> 40:16.310
第一个问题

40:16.310 --> 40:17.310
还不算太严重

40:17.310 --> 40:20.940
什么问题呢

40:20.940 --> 40:23.940
重复的调用

40:23.940 --> 40:27.580
重复的调用

40:27.580 --> 40:28.580
就什么意思

40:28.580 --> 40:29.580
就这里

40:29.580 --> 40:30.580
前面两句话

40:30.580 --> 40:31.580
是不是一定要调用

40:31.580 --> 40:32.580
这两个函数

40:32.580 --> 40:33.580
对不对

40:33.580 --> 40:34.580
这两个地方

40:34.580 --> 40:35.580
一定要调用这两个函数

40:35.580 --> 40:36.580
is outside

40:36.580 --> 40:37.580
和

40:37.580 --> 40:38.580
这个玩意儿

40:38.580 --> 40:39.580
一定要调用它

40:40.580 --> 40:42.580
函数的调用是重复的

40:42.580 --> 40:43.580
你看这里要调用两次

40:43.580 --> 40:44.580
这个地方

40:44.580 --> 40:45.580
我又要去写两次调用

40:45.580 --> 40:47.580
我又要去写两次调用

40:47.580 --> 40:48.580
对吧

40:48.580 --> 40:49.580
我调用函数的代码

40:49.580 --> 40:51.580
我还是在重复

40:51.580 --> 40:52.580
当然这个重复

40:52.580 --> 40:53.580
已经很少了

40:53.580 --> 40:54.580
已经很少了

40:54.580 --> 40:55.580
但是还是在重复

40:55.580 --> 40:57.580
那么你觉得这个重复

40:57.580 --> 40:58.580
会有什么问题

40:58.580 --> 41:00.580
会有什么问题呢

41:00.580 --> 41:02.580
当然不太可能写错

41:02.580 --> 41:05.580
因为TSS有类型检查的

41:05.580 --> 41:06.580
它不太可能会写错

41:06.580 --> 41:07.580
写错了

41:07.580 --> 41:08.580
它会马上提示你

41:08.580 --> 41:10.580
它会有什么问题呢

41:10.580 --> 41:13.580
这里既然在重复调用

41:13.580 --> 41:15.580
它最可怕的是啥呢

41:15.580 --> 41:16.580
最可怕的是

41:16.580 --> 41:18.580
不是代码书写的

41:19.580 --> 41:20.580
次数变多了

41:20.580 --> 41:21.580
一个是凡数

41:21.580 --> 41:22.580
一个当然是凡数

41:22.580 --> 41:24.580
最严重的问题是

41:24.580 --> 41:27.580
我就可能把顺序写错了

41:27.580 --> 41:29.580
有可能写错顺序

41:29.580 --> 41:30.580
当然在这种情况下

41:30.580 --> 41:32.580
写错顺序好像还没事

41:32.580 --> 41:33.580
那你如果把这个函数

41:33.580 --> 41:35.580
也调用写成这样的顺序了呢

41:35.580 --> 41:36.580
你把这个函数

41:36.580 --> 41:37.580
写到前面来呢

41:37.580 --> 41:39.580
是不是要出问题了

41:39.580 --> 41:40.580
对不对

41:40.580 --> 41:42.580
那这个东西谁能检查得到

41:42.580 --> 41:43.580
你告诉我

41:43.580 --> 41:44.580
这个东西谁能检查得到

41:44.580 --> 41:45.580
他怎么知道

41:45.580 --> 41:46.580
这个东西不能前面调用

41:46.580 --> 41:48.580
所以说他就会出现这样的问题

41:48.580 --> 41:50.580
有可能顺序我写错了

41:50.580 --> 41:52.580
这是第1个问题

41:52.580 --> 41:53.580
第1个问题

41:53.580 --> 41:55.580
第2个问题

41:55.580 --> 41:57.580
就是我刚才说的

41:57.580 --> 42:00.580
调用的顺序

42:00.580 --> 42:02.580
和

42:02.580 --> 42:04.580
调用的方式

42:04.580 --> 42:06.580
你调用什么叫调用的方式

42:06.580 --> 42:08.580
就是调用它的一个返回结果

42:08.580 --> 42:09.580
我这个返回结果

42:09.580 --> 42:10.580
接下来又怎么处理

42:10.580 --> 42:11.580
比方说

42:11.580 --> 42:12.580
边界判断为真

42:12.580 --> 42:14.580
继续怎么处理

42:14.580 --> 42:15.580
边界判断为假

42:15.580 --> 42:16.580
我又怎么处理

42:16.580 --> 42:17.580
它只为真

42:17.580 --> 42:18.580
怎么处理

42:18.580 --> 42:19.580
它为假怎么处理

42:19.580 --> 42:20.580
这些每一个旗帜

42:20.580 --> 42:21.580
处理方式是一样的

42:21.580 --> 42:22.580
边界判断为真

42:22.580 --> 42:23.580
那我继续判断呗

42:23.580 --> 42:25.580
边界判断为假

42:25.580 --> 42:27.580
我就返回Force

42:27.580 --> 42:28.580
那么也就是说

42:28.580 --> 42:30.580
调用的顺序和方式

42:30.580 --> 42:32.580
没有强约束

42:32.580 --> 42:34.580
它没有强制的约束力

42:34.580 --> 42:36.580
就是你随便怎么调用都可以

42:36.580 --> 42:39.580
这才是它跟最严重的问题

42:39.580 --> 42:41.580
特别是复杂的情况下

42:41.580 --> 42:43.580
代码一复杂了

42:43.580 --> 42:45.580
你的调用可能要乱来了

42:45.580 --> 42:47.580
各种旗帜写了那么多

42:47.580 --> 42:48.580
代码一写多

42:48.580 --> 42:49.580
我就脑袋已经懵了

42:49.580 --> 42:50.580
这个时候我本来

42:50.580 --> 42:52.580
自己的旗帜的规则就已经够复杂了

42:52.580 --> 42:54.580
我还要去想这个调用顺序

42:54.580 --> 42:56.580
我脑袋一定懵了

42:56.580 --> 42:59.580
所以说这个顺序也很麻烦

42:59.580 --> 43:01.580
那么这个时候

43:01.580 --> 43:03.580
有东西就是主出现了

43:03.580 --> 43:05.580
模板模式

43:05.580 --> 43:07.580
有了这个模式过后

43:07.580 --> 43:08.580
我会告诉大家

43:08.580 --> 43:09.580
爽势力

43:09.580 --> 43:10.580
真的是爽势力

43:10.580 --> 43:12.580
你不用去记着这些顺序

43:12.580 --> 43:14.580
你啥都不用管

43:14.580 --> 43:16.580
你只内去就管自己的事情就行了

43:16.580 --> 43:18.580
那咱们来看一下

43:18.580 --> 43:20.580
只内做了啥

43:20.580 --> 43:22.580
只内做了啥

43:22.580 --> 43:24.580
唯一的不同是什么

43:24.580 --> 43:26.580
旗子的移动规则判断

43:26.580 --> 43:28.580
这个东西是不一样的

43:28.580 --> 43:29.580
对不对

43:29.580 --> 43:31.580
只内就这个东西不一样

43:31.580 --> 43:33.580
其他的是不是完全一样的

43:33.580 --> 43:35.580
其他的过程是完全一样的

43:35.580 --> 43:37.580
就这个地方不一样

43:37.580 --> 43:38.580
于是

43:38.580 --> 43:39.580
大家看

43:40.580 --> 43:42.580
我把这个删掉

43:42.580 --> 43:46.980
不再是

43:47.980 --> 43:49.980
它不再是抽象的了

43:49.980 --> 43:51.980
也就是说我发现

43:51.980 --> 43:54.980
复列我还是知道怎么写的

43:54.980 --> 43:55.980
怎么写

43:55.980 --> 43:56.980
首先

43:56.980 --> 43:58.980
第一步

43:58.980 --> 44:00.980
边界判断

44:00.980 --> 44:02.980
如果边界判断为假

44:02.980 --> 44:03.980
那么直接返回force

44:03.980 --> 44:04.980
不要移动了

44:04.980 --> 44:05.980
管理是啥旗子

44:05.980 --> 44:06.980
你边界判断是一样的

44:06.980 --> 44:08.980
直接写到目的

44:08.980 --> 44:09.980
直接写到目的

44:09.980 --> 44:12.980
然后下边

44:12.980 --> 44:14.980
目标位置是否有旗子的

44:14.980 --> 44:15.980
进行判断

44:15.980 --> 44:17.980
如果目标位置有旗子了

44:17.980 --> 44:18.980
当然我这里是模拟

44:18.980 --> 44:19.980
你听我讲就行了

44:19.980 --> 44:21.980
我不会真正的去写这单吧

44:21.980 --> 44:22.980
太多了

44:22.980 --> 44:24.980
目标位置是不是有旗子的

44:24.980 --> 44:26.980
如果没有旗子的话

44:26.980 --> 44:27.980
就继续判断

44:27.980 --> 44:28.980
如果有旗子的话

44:28.980 --> 44:29.980
直接返回force

44:29.980 --> 44:30.980
好

44:30.980 --> 44:32.980
到了第三步问题来了

44:32.980 --> 44:33.980
规则

44:33.980 --> 44:35.980
规则判断

44:35.980 --> 44:36.980
规则判断

44:36.980 --> 44:38.980
我这里是不是不知道

44:38.980 --> 44:39.980
对不对

44:39.980 --> 44:40.980
我规则判断是不是不知道

44:40.980 --> 44:41.980
在复列里面不知道

44:41.980 --> 44:42.980
OK

44:42.980 --> 44:43.980
复列里面不知道

44:43.980 --> 44:44.980
我怎么做

44:44.980 --> 44:47.980
给它做成一个抽象方法

44:47.980 --> 44:49.980
AppsJets

44:49.980 --> 44:50.980
入

44:53.980 --> 44:54.980
你要移动到目标位置

44:54.980 --> 44:56.980
看是不是满足规则

44:56.980 --> 45:00.350
写这么一个抽象方法

45:00.350 --> 45:01.350
那这个抽象方法

45:01.350 --> 45:02.350
还可以约束一下

45:02.350 --> 45:07.350
约束为Protected

45:07.350 --> 45:08.350
约束为Protected

45:08.350 --> 45:09.350
返回个布

45:12.050 --> 45:13.050
你告诉我

45:13.050 --> 45:14.050
我现在复列里面

45:14.050 --> 45:15.050
确实不知道该怎么去实现

45:15.050 --> 45:16.050
但是

45:16.050 --> 45:18.050
我肯定有这么个东西

45:18.050 --> 45:19.050
每个旗子都有个规则

45:19.050 --> 45:21.050
怎么会有没有规则呢

45:21.050 --> 45:23.050
这个规则

45:23.050 --> 45:25.050
到底能不能移动到目标位置

45:25.050 --> 45:26.050
你只需要告诉我

45:26.050 --> 45:28.050
这个规则是不是满足就行了

45:28.050 --> 45:29.050
好

45:29.050 --> 45:30.050
我介绍这里

45:30.050 --> 45:31.050
我就接下来继续判断

45:31.050 --> 45:32.050
就调用什么呢

45:32.050 --> 45:34.050
调用入

45:34.050 --> 45:36.050
我一调用入这个函数

45:36.050 --> 45:38.050
这个入入函数

45:38.050 --> 45:39.050
现在没有实现

45:39.050 --> 45:41.050
但是指内里面一定会实现

45:41.050 --> 45:42.050
所以我这里

45:42.050 --> 45:44.050
真正在运行这个单码的时候

45:44.050 --> 45:46.050
也一定实现了

45:46.050 --> 45:48.050
一定实现了这个函数了

45:48.050 --> 45:50.050
因为到时候创建的是指内的对象

45:50.050 --> 45:52.050
指内还一定实现了这个函数

45:52.050 --> 45:53.050
所以这个函数一定

45:53.050 --> 45:54.050
到时候是实现了的

45:54.050 --> 45:55.050
好

45:55.050 --> 45:57.050
如果规则判断成功

45:57.050 --> 45:58.050
我就返回处

45:58.050 --> 45:59.050
返回处

45:59.050 --> 46:00.050
我就怎么样了

46:00.050 --> 46:03.050
ZX等于Target

46:03.050 --> 46:06.050
TargetXZY等于TargetY

46:06.050 --> 46:08.050
然后返回处

46:08.050 --> 46:10.050
最后来返回处

46:10.050 --> 46:13.000
你看一下

46:13.000 --> 46:14.000
这个Mu

46:14.000 --> 46:16.000
它逻辑是不是正确的

46:16.000 --> 46:19.000
整个逻辑线是完全清晰的

46:19.000 --> 46:20.000
这个东西是啥

46:20.000 --> 46:22.000
这个东西就是模板

46:22.000 --> 46:24.000
就是我要去做一件事情

46:24.000 --> 46:26.000
它整个的流程

46:26.000 --> 46:29.000
这个流程所有的指内完全一样

46:29.000 --> 46:31.000
这就是模板

46:31.000 --> 46:32.000
我们把它记一下

46:32.000 --> 46:34.000
什么叫模板模式

46:34.000 --> 46:37.630
模板模式

46:38.630 --> 46:41.630
附内中

46:41.630 --> 46:43.630
应该这样说

46:43.630 --> 46:47.630
所有的指内

46:47.630 --> 46:50.630
有些方法

46:50.630 --> 46:53.630
所有的指内

46:53.630 --> 46:55.630
实现的流程

46:55.630 --> 46:57.630
完全一致

46:57.630 --> 47:00.070
你看这里

47:00.070 --> 47:01.070
移动

47:01.070 --> 47:02.070
先边界判断

47:02.070 --> 47:03.070
再判断目标位置

47:03.070 --> 47:05.070
再判断规则

47:05.070 --> 47:07.070
最后根据规则的情况

47:07.070 --> 47:09.070
复制改变当前的坐标

47:09.070 --> 47:11.070
或者是返回Force

47:11.070 --> 47:14.070
整个流程是完全一致的

47:14.070 --> 47:16.070
只是

47:16.070 --> 47:20.070
流程中的某个步骤

47:20.070 --> 47:24.070
的具体实现不一致

47:24.070 --> 47:25.070
你看这个流程里边

47:25.070 --> 47:27.070
哪个地方不一致

47:27.070 --> 47:28.070
规则这里

47:28.070 --> 47:30.070
只有在某一个步骤里边

47:30.070 --> 47:32.070
某一个方法的具体实现

47:32.070 --> 47:33.070
不一致

47:33.070 --> 47:34.070
它的方法签名都是一样的

47:34.070 --> 47:35.070
参数一样

47:35.070 --> 47:36.070
返回的类型一样

47:36.070 --> 47:38.070
只是这个方法的实现不一样

47:38.070 --> 47:40.070
那么这个时候

47:40.070 --> 47:44.070
可以将

47:44.070 --> 47:49.070
该方法提取到复内

47:49.070 --> 47:54.070
在复内中完成整个流程的实现

47:54.070 --> 47:55.070
指内就不需要去做了

47:55.070 --> 47:57.070
全部都用复内来做

47:57.070 --> 48:00.070
遇到

48:00.070 --> 48:04.070
实现不一致的方法时

48:04.070 --> 48:05.070
遇到这种方法

48:05.070 --> 48:07.070
遇到这个东西的时候

48:07.070 --> 48:08.070
它每个指内不一样

48:08.070 --> 48:10.070
遇到这个时候的时候

48:10.070 --> 48:12.070
实现不一致的方法时

48:12.070 --> 48:16.070
将该方法做成抽象方法

48:16.070 --> 48:18.070
做的抽象方法

48:18.070 --> 48:20.070
你看一下抽象方法

48:20.070 --> 48:22.070
还有约束力的

48:22.070 --> 48:23.070
删掉

48:23.070 --> 48:25.070
删掉

48:25.070 --> 48:27.070
删掉

48:27.070 --> 48:30.070
抽象方法是具有约束力的

48:30.070 --> 48:33.070
我当我去继承一个旗子的时候

48:33.070 --> 48:35.070
他马上就会提示我

48:35.070 --> 48:36.070
我要做什么事

48:36.070 --> 48:40.280
我要去实现他的抽象方法

48:40.280 --> 48:41.280
也就是说

48:41.280 --> 48:44.280
我现在指内的任务

48:44.280 --> 48:46.280
非常非常的明确

48:46.280 --> 48:48.280
我一个马这个旗内

48:48.280 --> 48:50.280
只需要去做什么事

48:50.280 --> 48:52.280
只需要去实现马的规则就完了

48:52.280 --> 48:54.280
剩下的事情我管都不管

48:54.280 --> 48:55.280
我管你咋移动的

48:55.280 --> 48:57.280
移动的行为

48:57.280 --> 48:58.280
复内已经给你做好了

48:58.280 --> 49:01.280
你只需要把它缺失的环节给它补上

49:01.280 --> 49:03.280
哪个环节就是规则

49:03.280 --> 49:04.280
你就判断

49:04.280 --> 49:05.280
不要去判断环节

49:05.280 --> 49:06.280
不要去判断目标位置

49:06.280 --> 49:07.280
有没有旗子

49:07.280 --> 49:08.280
那些东西全部给你做好了

49:08.280 --> 49:10.280
你就判断一下存规则

49:10.280 --> 49:11.280
我这个马

49:11.280 --> 49:13.280
能不能从当前位置移动到这

49:13.280 --> 49:14.280
就判断个存规则就行了

49:14.280 --> 49:16.280
返回处或者是force

49:16.280 --> 49:19.280
这里也是一样

49:19.280 --> 49:20.280
返回处或者是force

49:20.280 --> 49:22.280
这里比方说我就返回处

49:22.280 --> 49:24.280
有返回处

49:24.280 --> 49:27.280
这里我就返回force

49:27.280 --> 49:30.280
比方说随便冰的话

49:30.280 --> 49:33.280
我这里冰的话返回处

49:33.280 --> 49:36.280
就随便写

49:36.280 --> 49:37.280
复内这里

49:37.280 --> 49:38.280
如果移动成功的话

49:38.280 --> 49:39.280
我再输出一下

49:39.280 --> 49:44.300
Zest

49:44.300 --> 49:48.300
Zest.net移动成功

49:48.300 --> 49:51.860
来看一下

49:51.860 --> 49:52.860
整个过程

49:52.860 --> 49:55.860
复内里边解决了流程的问题

49:55.860 --> 49:57.860
所有的流程都是一样的

49:57.860 --> 49:59.860
只是某一个环节不一样

49:59.860 --> 50:01.860
那么让紫内去实现那些环节就完事了

50:01.860 --> 50:02.860
其他的事情不要理管

50:02.860 --> 50:04.860
你只需要去实现环节

50:04.860 --> 50:06.860
那么咱们运行一下

50:06.860 --> 50:11.500
你会发现每一次移动

50:11.500 --> 50:13.500
每一次移动他都有伤

50:13.500 --> 50:15.500
他都有前面两个判断都是进行了的

50:15.500 --> 50:16.500
而且这个顺序

50:16.500 --> 50:18.500
你现在需不需要你考虑顺序

50:18.500 --> 50:20.500
完全不需要你考虑顺序

50:20.500 --> 50:22.500
顺序只有在复内里边完成

50:22.500 --> 50:24.500
跟你没有关系

50:24.500 --> 50:25.500
你也控制不了

50:25.500 --> 50:27.500
你只能控制这个规则

50:27.500 --> 50:30.500
你看第二个没有移动成功

50:30.500 --> 50:32.500
第三个冰移动成功

50:33.500 --> 50:35.500
好这样子开发了过后

50:35.500 --> 50:36.500
有很多的好处

50:36.500 --> 50:37.500
一个是刚才我们说到的好处

50:37.500 --> 50:39.500
还有一个好处就是

50:39.500 --> 50:41.500
你这个内写的

50:41.500 --> 50:43.500
比方说已经写了两年了

50:43.500 --> 50:44.500
写了两年了

50:44.500 --> 50:46.500
现在我继续写这个程序

50:46.500 --> 50:48.500
两年前我写了一半

50:48.500 --> 50:50.500
我也忘了当时怎么写的了

50:50.500 --> 50:51.500
我也忘了

50:51.500 --> 50:53.500
然后我现在想把这个程序写完

50:53.500 --> 50:55.500
就在模拟什么

50:55.500 --> 50:56.500
团队写作

50:56.500 --> 50:57.500
这是别人写的

50:57.500 --> 50:58.500
不是你自己写的

50:58.500 --> 51:00.500
这是别人写的

51:00.500 --> 51:02.500
或者说模拟什么

51:02.500 --> 51:03.500
你自己代码量非常大

51:03.500 --> 51:04.500
系统非常复杂的时候

51:04.500 --> 51:05.500
写了很多东西

51:05.500 --> 51:06.500
你忘了这个东西

51:06.500 --> 51:08.500
到底该怎么用了

51:08.500 --> 51:09.500
你隐隐约约

51:09.500 --> 51:11.500
只记得一个东西

51:11.500 --> 51:12.500
记得啥呢

51:12.500 --> 51:14.500
记得我要是一个棋子的话

51:14.500 --> 51:16.500
我就要去继承浅士

51:16.500 --> 51:17.500
你只记得这个

51:17.500 --> 51:18.500
其他我全部忘完了

51:18.500 --> 51:20.500
没关系

51:20.500 --> 51:23.500
这什么叫强约数就好在这

51:23.500 --> 51:26.500
比方说咱们是

51:26.500 --> 51:27.500
要做一个棋子

51:27.500 --> 51:29.500
这个棋子是

51:30.500 --> 51:32.500
将

51:33.500 --> 51:34.500
这个棋子

51:34.500 --> 51:35.500
我只记得一个点

51:35.500 --> 51:37.500
就是这个棋子要去继承

51:37.500 --> 51:38.500
继承谁

51:38.500 --> 51:39.500
继承浅士

51:39.500 --> 51:41.500
其他我什么都忘完了

51:41.500 --> 51:43.500
什么叫强约数

51:43.500 --> 51:44.500
马上报处

51:44.500 --> 51:45.500
提示你

51:45.500 --> 51:49.060
赶快实现抽象

51:50.060 --> 51:52.060
赶快实现

51:52.060 --> 51:53.060
好

51:53.060 --> 51:54.060
一实现我就明白了

51:54.060 --> 51:56.060
原来我这个内要做啥

51:56.060 --> 51:57.060
要把内文属性

51:57.060 --> 51:58.060
有个棋子的名字

51:58.060 --> 51:59.060
我明白了

51:59.060 --> 52:02.060
就是棋子名字叫做将

52:03.060 --> 52:05.060
这个地方是

52:05.060 --> 52:07.060
设置棋子的规则

52:07.060 --> 52:09.060
同学们

52:09.060 --> 52:10.060
我只需要做这两件事

52:10.060 --> 52:11.060
就完了

52:11.060 --> 52:13.060
我就不需要做任何其他事了

52:13.060 --> 52:14.060
其他事我不用

52:14.060 --> 52:15.060
脚心脑子去想

52:15.060 --> 52:17.060
你还有什么事情要做吗

52:17.060 --> 52:18.060
我是不是忘了

52:18.060 --> 52:19.060
什么事情

52:19.060 --> 52:20.060
完全不用去考虑

52:20.060 --> 52:22.060
这就是叫强约数

52:22.060 --> 52:24.060
通过强约数

52:24.060 --> 52:25.060
你只需要去满足

52:25.060 --> 52:26.060
让他不报错就行了

52:26.060 --> 52:27.060
你要做的所有事情

52:27.060 --> 52:29.060
就是让他不报错

52:29.060 --> 52:31.060
或者是很多工具都会帮助你

52:31.060 --> 52:33.060
进行代码的修复

52:33.060 --> 52:34.060
修复代码过后

52:34.060 --> 52:35.060
他不报错了

52:35.060 --> 52:36.060
你要做的是

52:36.060 --> 52:38.060
把这东西实现

52:38.060 --> 52:39.060
就像

52:39.060 --> 52:40.060
你拿到一个东西

52:40.060 --> 52:41.060
你不知道要做什么的时候

52:41.060 --> 52:42.060
他可以抽了两道题

52:42.060 --> 52:43.060
这个东西

52:43.060 --> 52:44.060
这个题把它完成

52:44.060 --> 52:45.060
这个题把它完成

52:45.060 --> 52:47.060
整个地就完成了

52:47.060 --> 52:48.060
看到没有

52:48.060 --> 52:49.060
能体会到吗

52:49.060 --> 52:50.060
这就是

52:50.060 --> 52:52.060
这种方式的好处

52:52.060 --> 52:54.060
跟以前全凭记忆力

52:54.060 --> 52:56.060
全凭脑袋里面去想

52:56.060 --> 52:58.060
这些文档去调用那些函数

52:58.060 --> 53:00.060
是完全两码事

53:00.060 --> 53:01.060
是完全两码事

53:01.060 --> 53:02.060
这就是抽象里面

53:02.060 --> 53:03.060
抽象成员的好处

53:03.060 --> 53:06.060
它具有强制的约数力

53:07.060 --> 53:08.060
OK

53:08.060 --> 53:09.060
我希望

53:09.060 --> 53:11.060
我花这么多时间去讲这些东西

53:11.060 --> 53:14.060
希望大家对大家的思维上

53:14.060 --> 53:15.060
对想法上

53:15.060 --> 53:17.060
有所触动

53:17.060 --> 53:18.060
能够理解到

53:18.060 --> 53:19.060
这些东西

53:19.060 --> 53:20.060
它的好处在哪里

53:20.060 --> 53:22.060
为什么要去这样去设计

53:22.060 --> 53:24.060
当然一开始的时候

53:24.060 --> 53:25.060
并不是

53:25.060 --> 53:26.060
大家要求的

53:26.060 --> 53:27.060
不会有那么高

53:27.060 --> 53:28.060
不会说大家能够

53:28.060 --> 53:29.060
灵活自如的运用

53:29.060 --> 53:30.060
但是你至少能够

53:30.060 --> 53:32.060
感觉到那么一点点

53:32.060 --> 53:34.060
有那么一点的感觉

53:34.060 --> 53:36.060
慢慢的你就会爱上它了

53:36.060 --> 53:37.060
OK

53:37.060 --> 53:38.060
好

53:38.060 --> 53:39.060
那么这里看了

53:39.060 --> 53:40.060
咱们就讲到这里了

53:40.060 --> 53:41.060
下去呢

53:41.060 --> 53:42.060
好好去练一下这个场景

53:42.060 --> 53:44.060
你不一定把它运行出来

53:44.060 --> 53:45.060
但是呢

53:45.060 --> 53:46.060
练一下

53:46.060 --> 53:47.060
写一下

53:47.060 --> 53:48.060
体会一下这种代码

53:48.060 --> 53:49.060
OK

53:49.060 --> 53:50.060
那么这里看

53:50.060 --> 53:51.060
就到这里了

53:51.060 --> 53:52.060
拜拜

