WEBVTT

00:00.820 --> 00:06.460
上一节课呢 我们自己开发了这么一个装饰器

00:06.460 --> 00:12.860
就是用来描述属性啊 描述内的一些信息 开发了这么一个装饰器

00:12.860 --> 00:20.020
这个装饰器的美中不足的一个点啊 就在于 我们把它的元数据信息啊

00:20.020 --> 00:25.660
什么叫元数据信息 我们再解释一遍 就是这个内里边 这个属性里边

00:25.820 --> 00:30.780
它的一些额外的描述 这些都是元数据 就是对数据的描述

00:31.940 --> 00:39.620
我们把元数据信息放到哪的呢 我们是放到圆熊上面的 你看 我们只把这些信息全部放到圆熊上面的

00:40.220 --> 00:45.420
这样子做呢 不是太好 因为这样子的话会导致圆熊的污染

00:46.180 --> 00:50.420
就圆熊里边的东西呢 本来应该保持纯净的 不应该对它产生污染

00:51.420 --> 00:54.700
那我应该怎么做呢 正确的做法是把这些东西

00:55.380 --> 01:01.940
保存到外边去啊 保存到外边 比方说这里 我建立一个数组啊 建立一个对象或者是数组

01:03.580 --> 01:10.540
metadata 建立一个对象或者是数组 或者是一个什么的set都可以啊 都可以

01:12.990 --> 01:17.070
set 啊 创建一个set啊 应该是map 对吧 map

01:17.750 --> 01:22.710
创建这么一些数据结构来保存元数据信息 就专门放一个地方来保存

01:23.430 --> 01:27.270
当然 这样子我们手动开发的话啊 会有一些麻烦

01:27.750 --> 01:34.550
因此呢 这结构呢 我给大家介绍一个库啊 一个第三方库 他专门来做这个事儿 这个库的名字叫做

01:35.870 --> 01:36.790
refnet

01:37.710 --> 01:41.790
refnet meta data 啊 介绍这么一个库

01:42.430 --> 01:48.230
这个库呢 就是专门来保存啊该库的作用式啊 作用

01:49.870 --> 01:51.910
就是保存元数据

01:52.830 --> 01:58.510
他专门专门来帮我们维护一个内或者是一个属性的元数据

01:59.190 --> 02:04.750
ok 我们这一块呢 就来看一下这个库怎么去使用他 好 我们首先呢 找到

02:05.510 --> 02:06.110
这个n片

02:06.950 --> 02:12.910
通过搜索其实你就可以非常轻松的啊 搜出这个库叫refnet

02:13.510 --> 02:17.030
metadata 这么一个库 你看这个库呢 用的还蛮多的

02:17.750 --> 02:27.230
周下载量呢 有110多万对吧 用的还是蛮多的 很多的第三方库啊 其实很多的跟那个元数据相关的库

02:27.590 --> 02:31.390
基本上都要用到啊 这个基础库叫refnet meta data

02:32.110 --> 02:36.510
好 那这个库怎么去使用了 使用起来非常简单 首先我们安装他

02:37.230 --> 02:40.750
首先安装他 你可以用npm安装也可以使用啊

02:41.630 --> 02:47.150
cnpm 也可以使用呀都可以啊都可以 并且呢安装了你应该使用就是

02:48.190 --> 02:51.630
运行依赖安装 因为他在运行的时候也需要用到他

02:52.430 --> 02:54.350
所以说我们安装一下啊 首先安装一下

02:56.590 --> 02:57.070
停止了

02:57.310 --> 03:00.910
我们这里就使用呀来安装吧 add

03:02.110 --> 03:04.830
refnet meta data

03:06.110 --> 03:13.920
好 安装一下啊 安装之后了 我们让他安装安装之后了 我们看一下这个库怎么去使用

03:14.560 --> 03:17.280
使用起来非常非常简单 你看一下

03:18.480 --> 03:23.200
这个库里边他提供了一个全局的啊 一个全局的

03:23.760 --> 03:27.520
应该叫这个东西叫做对象啊 一个全局对象叫做refnet

03:28.480 --> 03:30.800
啊 这个全局对象呢就相当于是console啊

03:31.440 --> 03:35.280
window啊document啊这些可以全局使用的对象reflect

03:36.080 --> 03:40.640
好 这个对象里边有个数项啊 其实是一个方法啊 meta data

03:41.200 --> 03:46.400
这个方法呢 调用之后他会返回一个装饰器啊 会返回一个装饰器

03:47.120 --> 03:49.280
那么这个方法里边要传两个参数

03:49.840 --> 03:51.840
一个是件一个是值

03:52.560 --> 03:57.520
你就可以把你的元数据信息呢 通过对应的件对应的值保存起来

03:58.480 --> 04:02.480
将来呢 我们可以通过他的相应的api来进行获取

04:03.200 --> 04:08.560
他用法就那么简单 非常非常简单 我们知道这个东西他返回的就是一个装饰器就完事了

04:09.120 --> 04:12.080
好 我们来试一下啊 来试一下 这里安装完成了

04:12.640 --> 04:15.840
哎 这里有问题啊 有问题 我看一下

04:16.800 --> 04:25.280
他找不到 他说 我这个网络没有连上啊 网络没连上啊 我这里有网好像啊 网这里没有打开

04:25.840 --> 04:33.840
网打开啊 稍等一下啊 我这里没有连网啊 我再重新重新来一次啊

04:34.560 --> 04:36.480
安装一次啊 安装完了

04:37.920 --> 04:38.800
好 安装完成

04:39.440 --> 04:42.320
然后呢 现在呢 我们来用一下啊 看怎么来用

04:43.040 --> 04:44.240
用法非常简单

04:44.960 --> 04:46.800
我们这里先把之前的注释掉

04:47.600 --> 04:51.280
要使用这个库的话 首先要把导入进来

04:51.680 --> 04:57.280
导入的方式 他不产生 他不给你返回任何东西 他没有给你导出任何东西

04:57.520 --> 05:02.800
他就是全局的给你注入了一些对象 所以导入的时候呢 直接导入即可

05:03.040 --> 05:06.000
就refleg 直接导入即可

05:06.240 --> 05:08.800
其实像这个代码呢 你只需要运行一次就行了

05:08.800 --> 05:11.760
只要你运行一次 那么剩下的事情了

05:11.920 --> 05:18.640
他就是把这个库呢 就啊 相当于就是已经安装了啊 他给你提供了一些全局的对象

05:19.840 --> 05:23.200
好 导入之后呢 我就可以使用了啊 比方说我这里建立一个内A

05:24.000 --> 05:24.880
建立一个内A

05:25.440 --> 05:27.200
然后呢 我这里写个属性啊

05:27.760 --> 05:28.560
pia op1

05:29.120 --> 05:30.640
这个属性 随便写一个属性

05:31.360 --> 05:35.440
然后呢 写这个内A呢 我就给他可以用这种方式啊

05:35.840 --> 05:36.560
refleg

05:37.440 --> 05:39.200
第二 meta data

05:39.760 --> 05:41.280
给他附加一些原数据

05:42.240 --> 05:46.480
他要传两个参数 第一个参数是T值 第二参数是value值

05:46.880 --> 05:51.280
第三个参数是T值 为什么要传T呢 因为他有可能有很多的原数据

05:52.000 --> 05:53.280
啊 就同一个

05:53.520 --> 05:55.200
同一个成员上边

05:55.840 --> 05:58.400
比方说内上边 他有可能有很多的原数据

05:58.640 --> 06:02.000
因此呢 我们要到时要取的时候呢 要根据T值来取

06:02.240 --> 06:03.520
看你要取什么原数据

06:04.160 --> 06:08.000
好 这个T呢 可以是支付串 可以是任何东西啊 比方说给他个支付串吧

06:08.880 --> 06:11.200
给他个值

06:11.760 --> 06:13.040
值的话 就是

06:13.800 --> 06:16.120
一个内 一个内 随便给吧

06:16.360 --> 06:19.440
值也可以是任何类型 你可以保存任何东西进去

06:19.700 --> 06:20.720
啊 这是原数据

06:20.980 --> 06:22.240
T值是A

06:22.500 --> 06:25.600
值呢 随便 随便是什么样的一个值都可以

06:25.840 --> 06:29.920
原数据嘛 他不限制你是什么样的值 你可以是个对象 可以是个数组

06:30.180 --> 06:31.200
也可以是一个支付串

06:32.000 --> 06:34.160
你看这里 两个参数都是A

06:34.800 --> 06:35.840
可以是任何东西

06:36.600 --> 06:38.400
好 属性啊 我们也是一样啊

06:38.640 --> 06:39.400
refleg

06:41.620 --> 06:43.420
好 第二 Metadata

06:44.180 --> 06:48.540
好 给他一个原数据信息 比方说PROP

06:49.820 --> 06:51.100
呃 这是

06:52.620 --> 06:54.420
T值呢 这是

06:54.940 --> 06:55.700
一个属性

06:56.460 --> 07:03.380
好 我们来看一下啊 我能不能把他相应的这些数据 给他保存的数据 通过T值

07:03.900 --> 07:05.940
把它取出来 看一下能不能取出来

07:07.220 --> 07:10.300
好 这里呢 我们通过这个对象 建立一个

07:10.500 --> 07:12.820
给着对象 建立给他的对象

07:13.580 --> 07:15.100
然后我们来取一下试一下

07:15.620 --> 07:19.580
呃 我们都通过这个文档了 可以看出啊 他下面有API怎么来取

07:19.980 --> 07:22.740
取的话 有可以可以使用这个函数

07:23.300 --> 07:24.580
get Metadata

07:25.340 --> 07:30.220
啊 他有两个重在 就是有两种调用方式 我们一个个来吧

07:30.980 --> 07:33.540
好 首先呢 我们可以通过refleg

07:34.580 --> 07:36.100
get Metadata

07:37.100 --> 07:42.100
要传入什么呢 可以有两个重在啊 第一个重在 传入keyz

07:42.980 --> 07:49.860
就是你要取原数据啊 有个东西 某个东西上面的原数据可能很多啊 可能加了很多的原数据啊

07:49.860 --> 07:54.140
你要根据get去取相应的原数据 那么我们比方说 这里传一个a

07:55.340 --> 08:03.460
取原数据 好 第二个参数呢 是什么呢 指的是你要取得哪个对象啊 你要取得哪个对象

08:04.460 --> 08:07.460
就把这个a 这个对象传进去 或者把它叫做ob界了

08:08.820 --> 08:14.900
把这对象传进去 好 通过这个方式 他取的是什么呢 附着在

08:15.860 --> 08:18.420
这个对象的内上边的

08:19.380 --> 08:23.380
坚名为a的原数据啊 比方说这里还有很多的原数据

08:24.340 --> 08:33.140
还有很多啊 比方说a1 a2啊 这个随便写啊 这个随便写 写了很多的原数据 那么这个这个代码取出的是啥呢

08:33.500 --> 08:37.820
取出的是这个东西 明白这个意思吗 啊 取出的是这个东西

08:39.220 --> 08:47.180
好 为什么他要传第二参数 为什么不能直接把它取出来了 为什么不能直接取出来 因为你要告诉他 你这个原数据是附着在

08:47.540 --> 08:55.380
属性上面的还是说附着在内上面的 他不知道啊 如果你不告诉他对象的话 那比方说有另外一个内

08:57.540 --> 08:58.300
有另外一个内

08:59.300 --> 09:07.020
比方说内b 那他里面也有这个a啊 也有这个a对吧 所以说你必须要告诉他对象是谁啊 对象是谁

09:07.340 --> 09:17.220
那么如果你只传一个对象进来的话 那么他取的是内上面的原数据信息啊 找到这个内上面所谓的原数据 然后通过这个气质呢 把它取出来

09:17.740 --> 09:24.300
好 返回的结果 我们直接输出吧 直接输出 看他返回的结果是啥 输出的结果是啥 好 保存一下

09:25.260 --> 09:29.320
啊 我们来运行一下啊 npn 组装

09:33.890 --> 09:38.290
哎 啊 啊 这里有个有个地方有问题啊

09:39.650 --> 09:47.690
哦 这里的取的 哦 这取这里的a的话啊 取这个内上面的原数据的话 你要传一个内名进去啊 要把内名传进去

09:49.250 --> 09:57.690
啊 这里是取出出来啊 我刚才传的是对象的 对吧 不对啊 应该传内名啊 因为是附着在内上面的原数据啊 你要传内名进去

09:58.290 --> 10:03.410
把内传进去 好 当然呢 你也可以通过对象来得到内名 对吧 通过对象的是什么啊

10:05.730 --> 10:06.690
albjets

10:06.690 --> 10:15.890
jets prototype 得到它的原型 得到这个内对象的原型 然后呢 再通过原型得到它的构造函数constructor

10:19.040 --> 10:25.000
也是一样的啊 也可以取出来 也可以直接把这个内名传进去 如果你确定知道内名的话 那么也可以把内名直接传进去

10:26.000 --> 10:31.160
好 你看到啊 我们这里的就通过这个函数来得到了它的原数据信息

10:32.280 --> 10:38.520
好 我们继续啊 那么这些属性呢 属性的原数据信息呢 怎么来得到呢 我们来看一下

10:39.480 --> 10:44.600
比方说我们要得到这个属性的原数据信息 好 我们直接输出啊

10:46.360 --> 10:54.200
可以通过rave net 它里面有getmet data 好 使用另外一个存在 首先把气质传进去

10:55.880 --> 11:00.440
是这个气质 然后属性 然后对象呢obj

11:01.240 --> 11:04.280
属性的名字呢 三个参数plt1

11:05.440 --> 11:11.760
通过这种方式就可以得到某一个成员的 你看 得到某一个成员的原数据信息

11:12.280 --> 11:15.040
你保存的是什么 读出来就是什么

11:15.880 --> 11:16.480
原来的意思吧

11:17.440 --> 11:25.680
ok啊 我们这里呢 就可以通过啊metadata来附加原数据信息 通过getmetadata来得到原数据信息

11:26.520 --> 11:35.360
而其实属性这里呢 也可以用跟那一样的建名 啊一样的名字 哎没没问题的啊 都是没问题的 因为他们调用的方式不一样

11:36.160 --> 11:38.480
那这里要用哎啊 保存一下 你看一看

11:39.440 --> 11:46.400
啊 你看 是一样的 因为他这里调用方式不一样 你这里取的是内的原数据 你这里取的是属性的原数据

11:46.560 --> 11:47.320
那是不一样的

11:48.680 --> 11:55.600
好了 有了这个东西过后了 我们之前写的这个装饰器啊 其实就可以感谢一下 不要去污染

11:56.280 --> 12:03.280
不要去污染全局变样了 不要去污染全局 不是全局变了 不要去污染这个员形

12:04.080 --> 12:10.400
而把这些数把这些信息呢 保存到哪呢 保存到原数据上边 好 我们这里首先把导入进来

12:11.360 --> 12:11.920
input

12:12.800 --> 12:15.200
reflat 没他对他啊 导入进来

12:16.200 --> 12:20.920
好 那么这里面 这里边呢 我们就可以去使用这个reflect 版beta data

12:22.040 --> 12:25.600
好 怎么用呢 其实非常非常简单啊 非常非常简单

12:26.280 --> 12:30.520
怎么用 我们这里呢 可以用这种方式来处理啊 用这种方式来处理

12:33.200 --> 12:33.480
这里

12:34.480 --> 12:42.880
直接返回啥呢 比方说内的这个 内的这个装饰器 直接返回reflat的meta data

12:43.360 --> 12:48.560
直接返回这个 为什么可以直接返回 为什么 你看一下之前的代码

12:50.900 --> 12:55.060
这个东西是不是本身就是装饰器 这个函数调整的结果 对不对

12:56.300 --> 13:00.060
这个函数调整的结果 本身就是装饰器啊 本身就是装饰器

13:00.620 --> 13:06.900
因此呢 我们这里直接返回 调用这个函数 返回一个装饰器就行了啊 返回一个装饰器就完事了

13:07.740 --> 13:12.220
好 那么我们去设置他的元数据啊 设置他什么元数据呢 给他一个key子

13:12.700 --> 13:17.580
比方说这里呢 我们是用在做什么 在做 呃 描述对吧 我们给他个key子

13:18.100 --> 13:22.180
我们统一使用一个key子吧 统一使用一个key子啊 就是

13:23.500 --> 13:26.860
descript 啊 使用这个key子 统一使用他

13:27.100 --> 13:34.380
啊 把这个key传进去 保存的数据是什么呢 descript 啊 就是你传惯了这个这个参数

13:35.100 --> 13:40.060
啊 你看一下 我们再来理一下啊 这里有点糟 我们再来好好理一下 把这个注释掉

13:41.260 --> 13:41.980
啊 上面来拿开

13:43.380 --> 13:47.980
啊 你看这 class decrepter 把这个元数据信息传过去

13:48.540 --> 13:56.060
啊 把元数据信息传过去 那么这边呢 我就把这个信息保存到哪呢 保存到元数据里边 你看现在就没有产生污染

13:56.460 --> 14:00.620
没有污染他的呃 就是元息链啊 没有污染他的元息属性

14:02.100 --> 14:07.300
好 然后下面属性描述也是一样的道理啊 也是一样的道理

14:08.180 --> 14:12.780
属性描述的时候 我们也是用这种方式啊 也可以用这种方式

14:13.580 --> 14:21.180
直接扔过去完事了 直接扔过去完事了 所以说这两个其实可以合并啊 因为这样的事情就可以交回他来完成了

14:21.500 --> 14:28.900
他知道这个元数据附加到属性上面的还是附加到内上面的 他非常清楚啊 还非常清楚 就交给他来完成就行了

14:29.420 --> 14:32.060
因此这两个函数甚至我们可以把合并成一个函数

14:33.100 --> 14:39.660
就一个 description description 就完事了 连这个都不要了 你看一下子简单就简单了很多

14:40.340 --> 14:48.180
好 我们到这边来 你看我们这里就可以直接使用的descript 它既可以描述属像也可以描述内啊 都可以

14:48.820 --> 15:00.410
啊 都可以 okay 保存一下啊 这边保存一下啊 这里把它导入进来啊 点击这里添加啊 把导入进来

15:01.450 --> 15:08.170
啊 这个删除了啊 okay 你看我现在就只需要一个一个装饰器就行了 description 啊 剩下的事情呢

15:08.650 --> 15:15.850
装饰器真正的装饰器由它来产生啊 这只是个工厂来得到装饰器的装饰器由它来产生

15:16.250 --> 15:21.930
它的非常清楚 你这个东西描述的是内还是属性啊 它会给你进行处理 你不用管

15:23.290 --> 15:29.770
好 那么剩下的时候 我们要输出内的名字来吧 来输出内的名字 其实我们判断的是啥

15:30.490 --> 15:35.290
判断的是这个内啊 判断的是这个内有没有

15:36.170 --> 15:43.530
相应的元数据啊 有没有key 等于这个东西的元数据 有没有给他加一元数据 有的话我就把元数据读出来

15:43.690 --> 15:47.450
然后输出 如果没有的话 那么我就不输出 就这么简单

15:48.330 --> 15:56.090
所以说 这里呢 我怎么来判断了 怎么来判断啊 它其实这个里面给提供了一个函数啊 一个api 你看一下啊 这个

15:56.570 --> 16:04.730
highest math data 是不是拥有某个元数据啊 是不是有某一个元数据 好 那么这里我就可以通过这两方式来判断

16:06.650 --> 16:08.650
reflagd reflagd

16:09.610 --> 16:13.450
highest meta data 有没有相应的元数据

16:14.090 --> 16:19.610
看谁上面有没有呢 看内上面有没有啊 内怎么来获取啊 其实我们在这里

16:21.050 --> 16:23.290
这里可以进个辩量吧 把那个内获取到啊

16:23.930 --> 16:28.490
constrator 就是constrator啊 这个内的构造函数 我们通过这个代码

16:29.050 --> 16:35.850
把这个内的名字获取到啊 就内的这个内本身获取到 好 我们把这个内扔进来啊 扔进来

16:36.570 --> 16:40.170
然后呢 哦 这keyz扔进来 然后呢 把这个内扔进来

16:40.810 --> 16:44.650
啊 像之前那种做法一样啊 这里放个内啊 这里放个内 像这里

16:46.010 --> 16:49.770
啊 跟这里的做法一样 把这个keyz放进来啊 把这个

16:50.650 --> 16:56.170
内放进来 我们可以得到这个内上面keyz为这个keyz的元数据 看有没有

16:56.890 --> 17:02.570
如果有的话啊 我说说啥 有的话我就直接把这个东西得到输出就完成了 对吧

17:03.290 --> 17:07.450
我就直接把得到啊keyzmetata得到它的元数据 输出

17:07.930 --> 17:13.370
就是它的描述信息 你看我们之前是不是把描述信息保存下来的 对不对 我们把输出就完成了

17:14.090 --> 17:20.090
好 如果没有这个内 内上面没有这个元数据信息呢 我们就像之前那种做法啊 把这个内名输出

17:20.970 --> 17:22.170
输出这个内的内名

17:23.530 --> 17:31.530
ok 这是关于内这一块啊 内这一块 那么现在呢 下边属性这一块啊 不需要输主了啊 不需要输主了

17:32.250 --> 17:34.730
好 属性这一块呢 我们在循环的时候

17:36.090 --> 17:42.360
啊 直接在这来 在这来啊 我们直接通过这个

17:45.320 --> 17:47.880
high smet data 直接通过它

17:48.840 --> 17:53.240
来判断一下这个属性上边 这里不用了 不要再干嘛了

17:53.800 --> 17:58.920
判断这个属性上边有没有相应的元数据 好 把元数据的T放进去

17:59.800 --> 18:04.680
把我的对象放进去obj 把属性的名字放进去

18:05.400 --> 18:10.280
看一下这个属性 这个对象的这个属性上面 有没有这个keyz的元数据

18:10.920 --> 18:15.320
如果有的话 怎么办 直接输出啊 直接输出这个元数据

18:16.120 --> 18:18.440
reflat get metadata

18:19.960 --> 18:21.960
keyz传进去 对象传进去

18:22.680 --> 18:27.480
啊 这个keyz好像重复了 对吧 这里写个k吧 写个k

18:28.280 --> 18:29.800
啊 就是外面的keyz重复了

18:30.920 --> 18:32.520
好 这里呢 我们放

18:33.160 --> 18:37.080
这个k啊 k 就是属性名啊 属性名

18:37.640 --> 18:44.760
放进去 对象放进去 要取得元数据的key放进去 我就可以 如果有的话 我就把这个元数据拿到

18:45.880 --> 18:48.040
好 如果没有的话啊 这里是k

18:48.760 --> 18:55.080
如果没有的话 那么我们就直接输出啊 这个属性的名字啊 然后呢 这个属性的字

18:55.640 --> 18:56.280
直接输出

18:57.000 --> 19:01.240
你看现在的代码就简洁了 非常非常多了 就简洁了很多了 就代码

19:01.560 --> 19:04.520
因为我们有这个koo帮我们来保存元数据

19:05.400 --> 19:08.360
好了 写好之后我们再测试一下啊 测试一下

19:09.960 --> 19:12.280
你看 依然可以正确的输出结果

19:13.000 --> 19:18.360
啊 同时呢 现在呢 我就没有圆形的污染了啊 没有污染它的圆形

19:18.920 --> 19:19.640
明白这个意思吗

19:20.440 --> 19:23.480
ok啊 那么我们现在我们学习了这么一个

19:24.200 --> 19:28.920
这么一个koo 叫refernet meta data这个koo 这个koo说什么是用用处的

19:29.240 --> 19:31.800
很简单 它就来帮我们保存元数据的

19:32.360 --> 19:35.960
它这个函数呢 本身得到调用之后 反回的就是一个装饰器

19:36.520 --> 19:41.640
所以说 在我们的自定义的工厂里边 是可以直接反回这个东西的 把它当成一个装饰器

19:42.760 --> 19:47.880
那么它附加的元数据信息呢 它可以附加到内上边 也可以附加到属性上边

19:48.280 --> 19:49.880
所以说我们可以做一些通用的东西

19:51.320 --> 19:53.880
好 最后 最后呢 这里我说一个细节

19:55.080 --> 19:55.880
就是这个keyz

19:57.320 --> 20:02.200
这个keyz呢 在做不同功能的元数据的时候 比方说这个功能

20:02.680 --> 20:06.680
这个元数据呢 我们做的是什么元数据呢 是来描述啊 用一个字符串

20:07.000 --> 20:10.760
来描述一个内的名字来描述一个属性的含义

20:11.320 --> 20:12.600
是一个字符串来描述的

20:13.240 --> 20:16.440
那么做这个功能的时候呢 我们使用了一个统一的keyz

20:17.560 --> 20:24.600
这里keyz一定要注意 千万千万要避免跟其他元数据产生冲突

20:25.400 --> 20:30.840
比方说我们将来还会写一些元数据 比方说做验证 验证的话也会加一些元数据

20:31.240 --> 20:34.280
那么验证的元数据的keyz呢 你可以用Validator

20:34.920 --> 20:39.480
或者是以后呢 我们还可能会加一些元数据 它又有可能有不同的keyz

20:39.960 --> 20:41.960
这个keyz一定不能有冲突

20:42.680 --> 20:44.680
但是现在我用的是字符串

20:45.240 --> 20:48.840
字符串是不是有可能会相等 对不对 有可能会有冲突

20:49.720 --> 20:55.560
那么用什么内形才能保证万无一失 绝对不可能有冲突呢

20:56.040 --> 21:00.120
用什么内形呢 我给大家介绍一个内形 叫做symbol

21:02.860 --> 21:05.980
通过symbol来产生一个数据

21:06.620 --> 21:08.620
通过for这个函数来产生一个数据

21:09.100 --> 21:11.100
descript

21:11.340 --> 21:16.540
如果你之前学解释的时候 接触过symbol 那你一定知道这一块表示什么意思

21:17.260 --> 21:20.620
如果你不知道的话 我大概解释一下

21:21.180 --> 21:24.060
symbol里边提供了一个方法 叫for方法

21:24.620 --> 21:26.300
for方法里边可以传一个字符串

21:27.100 --> 21:30.860
整个这个函数返回的是啥呢 返回的是一个symbol对象

21:32.220 --> 21:34.620
返回的是一个symbol对象 这个对象

21:35.260 --> 21:37.020
整个系统中一定唯一

21:37.740 --> 21:38.380
一定唯一

21:39.020 --> 21:45.020
如果你将来一不小心 你创建了这么 又去创建了这么一个东西 那对不起 这两个对象是不一样的

21:46.620 --> 21:51.740
这两个对象是不一样的啊 你给大家可以至于去输出判断一下 看一下是不是得到的结果 是不是

21:52.460 --> 21:53.900
force 我们来输出吧

21:55.020 --> 21:57.260
他是否 t 是不是等于q2

21:58.220 --> 21:59.340
我们看一下

22:00.700 --> 22:06.780
他都不让你比较了 他不让你比较了 他说你这个你这个比较永远会返回force

22:07.260 --> 22:08.060
永远会返回

22:08.620 --> 22:11.980
返回force 为什么 因为symbol他表示符号

22:12.460 --> 22:18.060
通过这个for函数创建了symbol对象 一定是唯一的 每一次标准谈都是个唯一对象

22:18.700 --> 22:23.420
因此呢 我们可以用他的唯一性来避免跟其他的t值产生冲突

22:23.900 --> 22:29.580
那么这里的t呢 我就用了不是支付串啊 用的是symbol对象啊 因为我们知道key值是可以

22:30.380 --> 22:31.020
任何内容

22:31.660 --> 22:32.540
不一定是支付串

22:33.660 --> 22:38.540
好了 那么现在的效果是一样啊 并且他避免了产生冲突啊key值产生冲突

22:39.500 --> 22:41.340
ok 这里我顺便说一下这个问题

22:42.220 --> 22:47.260
好了 那么这里可能就差不多了啊 这里可就介绍了一下这个库的使用 这个库非常非常简单

22:47.500 --> 22:54.300
他的API也很少啊 什么hash metadata 那么判断是不是有这个元数据

22:54.620 --> 23:00.780
把key值扔过去 把你判断的目标扔过去啊 如果要判断属性的话 是吧 属性的名字扔过去

23:01.580 --> 23:03.340
那么这个判断的是判断啊

23:04.140 --> 23:07.500
自己这个对象以及原型链上面的所有的东西

23:08.700 --> 23:13.100
好 那么下面这个的孩子onmetadata判断的是什么呢 判断的是

23:13.500 --> 23:14.860
某个对象以及他的

23:15.660 --> 23:25.100
你就他本身的东西不包含原型和原型链啊 你看没有多少东西啊 没有多少东西 你可以自己看一下啊 这个是三处原数据可以自己看一下

23:26.060 --> 23:30.300
ok 这是这节课我们讲的内容 介绍这么一个库 这个库是一个基础库

23:31.260 --> 23:36.860
就说有一些第三方库 他们都要用到这个库 因此呢有必要对他进行加调解

23:37.740 --> 23:40.700
好了 那么这里可能东西呢就到这了啊 拜拜

