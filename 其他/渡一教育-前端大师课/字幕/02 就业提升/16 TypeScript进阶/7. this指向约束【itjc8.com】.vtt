WEBVTT

00:00.880 --> 00:04.200
大家好 我是多一教育维吾尔前掌讲师 元静

00:04.460 --> 00:09.580
这些课咱们继续来学习深入理解内核接口

00:10.100 --> 00:14.700
其实是已经到了尾声了 对吧 咱们核心的知识其实就在前边

00:14.960 --> 00:19.060
连向对象概述 继承 抽象 静态 接口

00:19.560 --> 00:23.660
后边这个索印器 Zs 呢 都算是一些补充的知识了

00:24.440 --> 00:25.960
好 咱们既然讲到这来了

00:26.220 --> 00:29.540
讲到这个对象 对象里边经常要使用到Zs

00:29.740 --> 00:31.340
那么我们就来谈一谈啊

00:31.840 --> 00:33.900
关于前端开发里边的人

00:34.400 --> 00:37.220
这个非常非常烦人的一个东西就是Zs

00:37.980 --> 00:39.020
真的是很烦人

00:40.040 --> 00:41.320
这里有篇文章

00:41.580 --> 00:44.380
这篇文章里边说到了在介石里边

00:44.900 --> 00:47.460
关于Zs的指向他有哪些情况

00:47.980 --> 00:49.500
他到底发生了什么事

00:49.760 --> 00:51.300
为什么会这样去指向

00:52.060 --> 00:53.340
这里的都谈到这个问题

00:53.860 --> 00:55.140
这篇文章写得非常非常好

00:55.660 --> 00:57.700
所以一篇很早期的文章了啊 你看

00:57.960 --> 00:59.240
2011年写的

00:59.740 --> 01:02.060
这篇Zs的指向问题呢由来已久

01:02.300 --> 01:05.640
好多好多年了 从GS诞成之初到现场

01:05.900 --> 01:07.680
就一直遗留了这个问题

01:08.200 --> 01:12.040
这也是为什么说在GS不适合

01:12.300 --> 01:15.360
这个语言本身不适合大型项目的开发

01:15.620 --> 01:17.160
那么现在呢就必须要去

01:17.420 --> 01:18.680
要解决这个问题了

01:18.940 --> 01:21.760
怎么解决呢 在TS里面有他的一种方案

01:22.520 --> 01:24.580
这里面这篇文章就说到这个点啊

01:25.100 --> 01:27.140
关于这个点呢 大家可以去看一下这个文章

01:27.400 --> 01:28.420
这个文章写得非常好

01:28.620 --> 01:32.220
我看有没有时间吧 有时间的话我把它翻译一遍啊

01:33.740 --> 01:35.540
好 我这里就简单的说一下啊

01:35.800 --> 01:38.600
简单的说一下这个篇文章里面提到了一些东西

01:38.860 --> 01:39.900
就是我这里总结一下吧

01:40.160 --> 01:41.180
在GS中

01:42.460 --> 01:43.480
在GS中

01:43.980 --> 01:46.800
Zs指向的几种情况

01:47.580 --> 01:48.340
几种情况

01:49.100 --> 01:52.380
拿几种情况呢 首先大家要明确 要明确一点

01:52.940 --> 01:53.700
明确什么

01:53.980 --> 01:56.540
就是大部分时候

01:57.220 --> 01:59.100
Zs的指向

01:59.620 --> 02:01.140
取决于

02:01.900 --> 02:03.700
函数的调用方式

02:04.980 --> 02:07.040
它取决于函数的调用方式

02:07.540 --> 02:08.300
因此呢

02:08.560 --> 02:11.900
Zs的指向不是在你编写函数的时候

02:12.160 --> 02:12.660
确定的

02:12.920 --> 02:15.220
而是在函数调用的时候确定的

02:15.480 --> 02:17.540
你怎么去调用这个函数就确定了

02:17.780 --> 02:20.340
这个函数里边它的Zs是指向什么

02:20.860 --> 02:22.660
当然Zs只能写到函数里面 对吧

02:22.900 --> 02:24.180
它也不可能在其他地方出现

02:25.160 --> 02:26.940
好 这里面呢 我们就来

02:27.200 --> 02:28.740
总结一下 归纳一下

02:29.000 --> 02:30.780
Zs的指向有哪些情况呢

02:31.300 --> 02:33.100
如果直接调用函数

02:33.860 --> 02:35.660
直接调用函数

02:35.920 --> 02:37.700
我们把它叫做全局调用

02:37.960 --> 02:38.980
全局调用

02:39.740 --> 02:42.060
就是一个函数名称两个小货号

02:42.300 --> 02:44.100
里面写函数 这个是全局调用

02:44.620 --> 02:46.400
如果是直接调用函数的话

02:46.660 --> 02:49.220
Zs指向全局对象

02:49.980 --> 02:50.500
或

02:50.760 --> 02:51.520
on defense

02:52.500 --> 02:54.280
这里的凉重情况

02:54.540 --> 02:56.860
如果你是直接调用函数就像这样子

02:57.100 --> 02:58.900
某个函数插插插直接调用

02:59.400 --> 03:00.440
这样子的方式的话

03:00.700 --> 03:02.740
这个函数里边的Zs

03:03.000 --> 03:04.220
它指向的是全局对象

03:04.480 --> 03:07.340
如果是浏览器的话 那么就是温的对象

03:07.600 --> 03:09.640
如果是漏的阶矢 那么就是

03:09.900 --> 03:11.180
Global对象

03:11.440 --> 03:12.980
对吧 总之是全局对象

03:13.740 --> 03:16.060
那么这什么时候指向on defense呢

03:16.300 --> 03:18.100
如果你启用了严格模式

03:18.360 --> 03:19.120
启用

03:19.640 --> 03:20.660
严格模式

03:21.620 --> 03:25.300
那么这一块呢 它指向的就是on defense

03:26.080 --> 03:28.640
好 这是关于地种情况啊 这种调用方式

03:29.140 --> 03:30.940
第二种情况呢 是如果

03:31.200 --> 03:32.100
使用

03:32.680 --> 03:33.500
对象

03:33.760 --> 03:35.140
这种这种表达是

03:35.560 --> 03:36.320
对象

03:36.580 --> 03:37.080
第二

03:37.340 --> 03:38.360
然后函数

03:38.620 --> 03:39.400
就是方法

03:39.660 --> 03:41.020
通常呢 我们把

03:41.440 --> 03:43.500
写到对象里边的函数呢 叫做方法

03:43.740 --> 03:44.780
只是那种教法的不同

03:45.780 --> 03:47.840
如果使用这种方式调用的话

03:48.100 --> 03:48.600
啊

03:48.860 --> 03:49.380
调用

03:49.880 --> 03:52.660
这Race指向的是谁呢 指向

03:52.920 --> 03:53.900
对象本身

03:54.540 --> 03:55.220
这个时候呢

03:55.720 --> 03:56.760
指向的是对象本身

03:57.020 --> 03:57.520
啊

03:58.280 --> 03:59.580
好 你就说通过这种方式

03:59.840 --> 04:00.860
一个obj

04:01.120 --> 04:02.140
比方说user

04:02.400 --> 04:02.900
点

04:03.160 --> 04:03.660
a

04:04.180 --> 04:04.940
user 点

04:05.200 --> 04:05.460
c

04:05.720 --> 04:06.480
c hello

04:06.740 --> 04:09.040
通过这种方式来调用函数 就调用方法

04:09.300 --> 04:12.120
那么这个方法里边的Race呢 指向的是这个对象本身

04:12.380 --> 04:13.140
是谁在调用它

04:14.420 --> 04:16.720
好 还有一个 还有一个情况就是事件

04:17.500 --> 04:18.520
如果

04:19.580 --> 04:21.120
是dom4件

04:21.380 --> 04:22.660
dom4件的

04:22.920 --> 04:23.940
处理函数

04:24.460 --> 04:27.520
那么这个函数是谁调用的呢 是浏览器给你调用的

04:27.780 --> 04:30.080
就当某件事情 比方说按钮点击

04:30.340 --> 04:32.900
或者是鼠标移入 或者是聚焦 怎么样怎么样

04:33.420 --> 04:35.340
当某一件事情发生的时候

04:35.600 --> 04:36.340
浏览器

04:36.600 --> 04:37.140
会去

04:37.400 --> 04:38.960
调用你给他传递的

04:39.220 --> 04:39.820
这个函数

04:40.320 --> 04:43.140
那么他调用的时候呢 他做了一件特殊的事情

04:43.400 --> 04:45.700
就是把Race呢 进行了一种绑定

04:45.960 --> 04:46.980
保证你的Race

04:47.240 --> 04:48.000
就是Race

04:48.500 --> 04:49.360
指向的是谁呢

04:49.620 --> 04:50.260
指向

04:50.760 --> 04:52.820
事件处理对象

04:53.580 --> 04:54.860
事件处理对象

04:55.620 --> 04:57.420
这是这一种情况

04:57.940 --> 05:00.240
这是在调用的时候常见了这么三种情况

05:00.500 --> 05:03.300
那么还有没有特殊的情况 还有一些特殊的情况

05:03.820 --> 05:04.860
特殊情况

05:05.860 --> 05:06.900
特殊情况是什么呢

05:07.160 --> 05:09.140
就是第一个是箭头函数

05:09.700 --> 05:10.980
箭头函数

05:11.240 --> 05:13.300
如果你使用了箭头函数的话

05:13.560 --> 05:16.620
Race是在函数声名时

05:17.400 --> 05:19.160
函数声名时

05:20.680 --> 05:21.960
确定指向

05:22.460 --> 05:24.000
而不是在函数调用的时候

05:24.500 --> 05:26.040
绝大部分时候呢

05:26.300 --> 05:27.080
Race的指向呢

05:27.320 --> 05:29.120
都是在函数调用的时候才能确定

05:29.380 --> 05:30.920
而使用箭头函数

05:31.160 --> 05:34.480
在写这个函数的位置 他就把Race的指向确定下来了

05:35.000 --> 05:37.320
在声名的时候确定指向

05:37.560 --> 05:38.080
指向谁呢

05:38.340 --> 05:38.840
指向

05:39.360 --> 05:40.640
函数位置

05:40.880 --> 05:42.680
所在位置的Race

05:43.440 --> 05:44.640
这个函数写到什么位置的

05:44.880 --> 05:46.520
那么这个Race就指向谁

05:47.600 --> 05:48.760
好 这是这种情况

05:49.020 --> 05:49.640
然后呢

05:49.900 --> 05:50.920
还有什么使用

05:51.180 --> 05:53.740
使用什么band

05:54.000 --> 05:55.280
apply

05:55.540 --> 05:57.320
core这些函数

05:57.580 --> 05:58.600
使用这些函数

05:58.860 --> 06:00.660
绑定手动

06:01.160 --> 06:03.160
绑定Race对象

06:03.720 --> 06:05.520
就是你手动的去给他指定

06:05.780 --> 06:07.320
Race对象是什么

06:07.560 --> 06:08.600
Race指向谁

06:09.100 --> 06:10.380
好 这是在介石里面

06:10.640 --> 06:12.000
这些乱七八糟的

06:12.240 --> 06:13.440
Race指向问题

06:13.960 --> 06:15.000
由于这些

06:15.460 --> 06:16.500
很多这种

06:17.260 --> 06:19.560
Race的指向的各种情况出现

06:20.060 --> 06:21.620
就会导致咱们写单码的时候呢

06:21.860 --> 06:22.460
一不小心

06:22.900 --> 06:23.540
就忘记了

06:23.780 --> 06:25.460
这个函数里面Race可能会出问题

06:25.700 --> 06:29.300
就会经常会犯一些Race指向性的错误

06:29.800 --> 06:30.820
那么这些呢

06:31.080 --> 06:31.860
既然

06:32.100 --> 06:34.140
在介石里面出现了这些常见的错误

06:34.400 --> 06:38.500
而ts这个语言的本身就是为了解决这个错误而生的

06:38.760 --> 06:39.540
所以说呢

06:39.780 --> 06:42.860
在ts他号称是一个完善的类型检查系统

06:43.100 --> 06:44.900
他就必须要处理这个问题

06:45.460 --> 06:46.500
那么怎么处理呢

06:46.740 --> 06:48.020
实际上你这样子来想

06:48.420 --> 06:51.100
如果让你是微软的高层

06:51.620 --> 06:54.940
让你来定一个方案来解决这个问题

06:55.180 --> 06:56.980
是真的不好解决

06:57.240 --> 06:58.140
因为啥呢

06:58.380 --> 06:59.780
你是介石的超级

07:00.060 --> 07:02.100
你不能说我在ts里面

07:02.360 --> 07:06.200
Race就进行非常非常严格的要求

07:06.460 --> 07:09.780
我在写ts的时候

07:10.040 --> 07:11.580
该使用对象调用的

07:11.820 --> 07:12.860
就必须要使用对象调用

07:13.100 --> 07:13.880
我就不能直接调用

07:14.340 --> 07:16.020
这样子太严格了也不行

07:16.260 --> 07:17.160
因为他要保证

07:17.420 --> 07:20.260
他还要保持介石的灵活性

07:20.500 --> 07:23.820
他不能强行改变你的写代码的方式

07:24.340 --> 07:26.380
所以说这个问题就很难解决

07:26.640 --> 07:28.680
你又要保证灵活性

07:28.940 --> 07:33.540
又要能够尽量的让介石不至于出错

07:33.800 --> 07:34.460
就很麻烦

07:34.700 --> 07:36.100
这是两个其实是矛盾的

07:36.360 --> 07:37.900
这两种情况实际上是矛盾的

07:38.420 --> 07:39.940
因此呢在现阶段

07:40.200 --> 07:43.780
ts呢还不是没有一种非常非常好的

07:43.940 --> 07:44.840
一种解决办法

07:45.100 --> 07:46.300
但他提供了一种解决办法

07:46.560 --> 07:47.320
这个解决办法呢

07:48.580 --> 07:49.720
已经非常不错了

07:49.980 --> 07:51.120
这种解决方法已经非常不错了

07:51.380 --> 07:52.540
我个人觉得

07:52.800 --> 07:54.580
他能想到这个点也非常不错了

07:54.840 --> 07:56.640
但是呢没有特别特别完善的

07:56.900 --> 07:57.340
不像

07:57.600 --> 07:59.020
后端语言什么加瓦呀

07:59.260 --> 07:59.660
c sharp

07:59.920 --> 08:01.860
那里面对Race要求之严格

08:02.120 --> 08:03.540
只有一种情况没有别的情况

08:03.800 --> 08:04.580
就是当前对象

08:05.320 --> 08:06.020
但是呢在

08:06.280 --> 08:08.660
ts里边他要保证介石的灵活性

08:08.920 --> 08:11.740
他不能把他灵活性这个特点给取消掉了

08:12.000 --> 08:12.620
所以说呢

08:12.820 --> 08:14.120
这个事情呢就很矛盾了

08:14.620 --> 08:17.260
那么今天呢我们就在学一学在ts里边啊

08:17.520 --> 08:18.760
如何来控制

08:21.860 --> 08:23.000
ts中的

08:24.560 --> 08:25.400
ts中的

08:27.460 --> 08:28.700
好这里我举个例子吧

08:28.960 --> 08:29.600
举个例子啊

08:30.260 --> 08:32.820
这里呢比方说有一个拥护对象啊

08:33.060 --> 08:34.100
咱们也经常这样子写

08:34.360 --> 08:35.660
就是一个对象字面量

08:35.900 --> 08:36.660
直接书写的

08:37.400 --> 08:38.160
一个姓名

08:38.720 --> 08:39.360
随便写啊

08:39.600 --> 08:40.260
一个年龄

08:40.600 --> 08:41.020
随便写

08:41.300 --> 08:42.560
然后呢有一个

08:42.960 --> 08:43.700
c hello

08:43.960 --> 08:44.860
这么一个方法

08:45.560 --> 08:46.760
这个方法里边做什么呢

08:47.000 --> 08:48.400
像这个代码咱们以前

08:48.660 --> 08:51.600
刚刚特别是大家刚刚学习介石的时候经常写对吧

08:52.200 --> 08:52.700
name

08:53.200 --> 08:54.600
啊再输出

08:55.100 --> 08:56.100
this is your age

08:56.400 --> 08:57.700
大家会发现一个现象

08:58.160 --> 09:00.000
就是刚才我打这个

09:00.600 --> 09:02.900
代码的时候他没有提示

09:03.460 --> 09:06.160
他在这种情况下是没有提示的啊

09:06.400 --> 09:07.200
怎么回事呢

09:07.560 --> 09:10.100
咱们去用鼠标指的这个Race看一下

09:10.660 --> 09:11.600
这个Race为啥

09:12.100 --> 09:12.900
这个Race为啥

09:13.300 --> 09:14.860
他推断出来是and

09:15.560 --> 09:16.760
哇这就很奇怪了

09:17.260 --> 09:19.060
为什么能是and呢这里

09:19.360 --> 09:21.260
他不应该是整个这个对象吗

09:21.560 --> 09:23.860
啊为什么他把他推断出来是and

09:24.660 --> 09:25.160
啊

09:25.560 --> 09:26.460
这里呢

09:26.560 --> 09:29.160
他有他有可能是这样子考虑的啊

09:29.260 --> 09:31.760
他具体怎么考虑的我怎么知道我也不知道啊

09:31.760 --> 09:33.260
我也不是微软内部的人员

09:33.960 --> 09:35.760
啊我不知道他怎么考虑的这里

09:36.060 --> 09:38.560
他可能是怕你发发生这样的错误

09:39.160 --> 09:40.560
就是说你这个函数啊

09:40.560 --> 09:42.260
你这个对象里边这个函数啊

09:42.360 --> 09:44.360
你有可能是这样调用的

09:45.360 --> 09:46.260
大家看一下啊

09:46.560 --> 09:48.660
你当然如果你直接通过U来调用

09:48.660 --> 09:50.260
那没有什么没有任何问题

09:50.260 --> 09:51.760
这个Race指向的是谁呢

09:51.960 --> 09:53.360
指向的是这个整个对象

09:53.960 --> 09:55.660
指向的是整个对象对吧

09:56.060 --> 09:58.560
就对象本身因为你通过U来调用的啊

09:58.560 --> 10:00.360
我们知道刚才的笔记里边说过

10:00.460 --> 10:03.560
如果只如果使用对象点方法来调用的话

10:03.560 --> 10:05.460
那么Race呢指向的是对象本身

10:05.560 --> 10:08.160
好那这里面Race指向对象本身没有什么问题

10:09.060 --> 10:11.960
好那如果你不是通过这种方式调用的

10:12.460 --> 10:13.960
那你通过这种方式调用的

10:14.960 --> 10:18.960
好然后这个时候呢

10:19.460 --> 10:20.660
我们通过这种方式调用

10:21.160 --> 10:22.660
这种方式调用的话

10:22.760 --> 10:25.160
Race还指向的是这个对象吗

10:25.960 --> 10:27.060
还指向的是他吗

10:27.860 --> 10:28.860
就不是了对吧

10:28.960 --> 10:30.060
那指向的是谁呢

10:30.260 --> 10:31.460
咱们刚才说过的

10:32.260 --> 10:33.760
这个时候他Race啊

10:33.860 --> 10:36.360
他就指向的是全局对象

10:36.360 --> 10:36.960
为什么

10:36.960 --> 10:39.160
因为我是直接调用的函数

10:39.660 --> 10:40.960
叫做全局调用

10:41.160 --> 10:42.260
因此呢这个Race呢

10:42.260 --> 10:43.760
指向的是全局对象

10:44.060 --> 10:45.360
咱们再运行出来看一下啊

10:46.460 --> 10:47.260
这里np

10:47.260 --> 10:47.760
wrong

10:51.010 --> 10:51.710
运行出来啊

10:52.010 --> 10:53.410
你看两个都是undefined

10:53.710 --> 10:55.110
表示全局对象里边呢

10:55.110 --> 10:56.310
是没有这个Race

10:56.510 --> 10:57.510
是没有这个Race

10:58.210 --> 10:59.410
没有这个属性的啊

10:59.410 --> 10:59.710
np

10:59.710 --> 11:00.810
二级这两个属性

11:01.110 --> 11:02.910
好比方说这里再打印出Race

11:02.910 --> 11:04.310
看一个Race是啥玩意儿

11:04.510 --> 11:05.710
我们就打印出Type O

11:06.310 --> 11:07.010
Type O

11:07.610 --> 11:08.410
Type of Race

11:08.410 --> 11:09.610
看它是什么东西啊

11:10.210 --> 11:10.810
保存一下

11:12.510 --> 11:14.010
这里看到的是一个OB结构车

11:14.110 --> 11:14.770
我们这样打

11:15.110 --> 11:16.310
就直接把Type O自己打印出来

11:16.310 --> 11:17.310
因为它东西太多了

11:17.310 --> 11:18.910
打印出来有点眼花了乱

11:19.510 --> 11:20.610
好打印出来了啊

11:21.010 --> 11:22.510
我们看到后边两个是undefined

11:22.910 --> 11:24.010
前面那个是啥呢

11:24.310 --> 11:26.110
前面那个肯定不是我们那个用户对象

11:26.110 --> 11:26.510
对不对

11:26.610 --> 11:27.510
肯定不是用户对象

11:27.510 --> 11:28.810
你看那一大堆东西

11:28.810 --> 11:29.710
这个是啥这个

11:30.310 --> 11:31.510
大家应该是见过的

11:32.310 --> 11:33.310
我再往上拿一点

11:35.010 --> 11:35.610
是啥啊

11:35.810 --> 11:37.110
这个东西是globo

11:37.410 --> 11:39.010
咱们现在是low的环境

11:39.110 --> 11:39.810
因此呢

11:39.810 --> 11:42.610
这里是low的环境里边的globo对象

11:43.310 --> 11:44.010
明白了吧

11:44.310 --> 11:45.610
所以说这个Race的指向呢

11:45.610 --> 11:47.110
它有可能会出问题的

11:47.210 --> 11:49.410
因此它这里不敢武断的

11:50.010 --> 11:52.510
说这里是Race一定是指向这个有点

11:52.610 --> 11:53.710
它不敢这样子说

11:53.910 --> 11:55.110
因为这个Race的指向

11:55.110 --> 11:56.810
它是有可能出问题的啊

11:56.910 --> 11:57.910
有可能出问题的

11:57.910 --> 11:59.110
你如果用这种方式

11:59.510 --> 12:00.410
就有可能出问题

12:00.510 --> 12:01.210
其实这里

12:01.810 --> 12:03.510
我都能体会到TS

12:03.510 --> 12:04.710
TS TypeScript

12:04.710 --> 12:06.910
微軟在做这个东西的时候它的纠结

12:07.510 --> 12:09.810
因为它到底要不要让这个Race

12:09.810 --> 12:11.210
它其实可以做这样做的

12:11.310 --> 12:12.810
可以让这个Race推断出来

12:12.810 --> 12:13.510
就是这个东西

12:13.510 --> 12:14.510
它可以这样做的

12:14.810 --> 12:16.110
它要不要这样去做

12:16.510 --> 12:17.410
它真的很纠结

12:17.410 --> 12:18.810
其实你它如果在这里

12:18.810 --> 12:20.410
把Race指向为这个东西

12:20.510 --> 12:21.510
我觉得也说得通

12:21.510 --> 12:22.210
也没问题

12:22.210 --> 12:23.910
因为我们通常调问这个函数

12:23.910 --> 12:25.410
都是通过这么方式来调用的

12:25.610 --> 12:26.210
直接you

12:26.710 --> 12:27.310
share hello

12:27.610 --> 12:30.210
而很少人再把它保存到一个变量里边

12:30.410 --> 12:32.610
但它有可能会保存到变量里边

12:32.610 --> 12:34.110
所以这里它咬拜不定

12:34.210 --> 12:35.210
我能感受得到

12:35.710 --> 12:36.510
那比方说

12:36.910 --> 12:38.210
为什么这样子说呢

12:38.210 --> 12:39.510
因为你看一下这个例子

12:40.310 --> 12:41.810
我书写一个内的时候

12:42.410 --> 12:44.110
如果我把这个用户书写成一个内

12:44.810 --> 12:46.610
这个内里边我提供了

12:46.810 --> 12:47.810
一个两个书像

12:47.810 --> 12:48.810
一个年龄

12:49.610 --> 12:50.510
一个年龄

12:52.210 --> 12:52.610
这里

12:54.110 --> 12:54.810
这样写吧

12:55.010 --> 12:55.710
constructor

12:56.010 --> 12:56.910
constructor

12:58.010 --> 12:59.310
然后这里这样子

12:59.710 --> 13:01.610
public name stream

13:02.210 --> 13:04.810
然后public age stream

13:06.010 --> 13:07.210
有这么一个用户

13:07.310 --> 13:10.910
这个用户内里边提供了一个函数方法

13:11.910 --> 13:12.410
share hello

13:12.410 --> 13:14.210
是一模一样的做法

13:14.610 --> 13:15.910
我们把z打印出来

13:16.210 --> 13:18.510
然后打印出z的name

13:18.510 --> 13:19.910
你看现在就有智能提示的

13:20.310 --> 13:23.510
它现在就能推断出内里边的z

13:23.710 --> 13:24.510
指向的是啥

13:24.710 --> 13:26.310
指向的是这个用户对象本身

13:26.710 --> 13:27.910
指向的是这个东西

13:27.910 --> 13:28.910
用户对象本身

13:29.110 --> 13:30.910
它这里没有显示得很清楚

13:31.010 --> 13:32.710
但是我们可以通过一个智能提示

13:32.910 --> 13:33.710
就已经看出来

13:34.110 --> 13:35.710
它把z推断为什么呢

13:35.710 --> 13:37.110
推断为用户对象本身

13:38.210 --> 13:40.310
那么咱们来使用这个对象

13:40.310 --> 13:41.010
试一下

13:42.010 --> 13:43.710
正常的使用方式我就不掩饰了

13:43.710 --> 13:45.310
正常的使用方式没什么好说的

13:46.610 --> 13:47.410
这就是number

13:49.010 --> 13:51.810
我们来看一下不正常的使用方式

13:52.110 --> 13:53.110
那我就这样做

13:53.510 --> 13:54.510
又像刚才那样子

13:54.510 --> 13:56.510
share hello

13:57.610 --> 13:58.310
share hello

14:00.110 --> 14:00.910
有点share hello

14:01.110 --> 14:02.710
那么现在的z

14:02.910 --> 14:04.710
我当我去调用z的时候

14:05.710 --> 14:06.710
现在的z

14:07.010 --> 14:07.910
为什么爆错

14:08.210 --> 14:09.010
这里

14:09.410 --> 14:10.710
多写个颇号

14:11.410 --> 14:12.410
大家想一想

14:12.610 --> 14:13.610
现在的z

14:14.210 --> 14:15.410
指向的是啥

14:15.910 --> 14:19.610
指向的还是这个对象本身吗

14:20.110 --> 14:21.010
那肯定不是了

14:21.010 --> 14:21.410
对吧

14:21.610 --> 14:22.510
这个时候它的z

14:22.510 --> 14:24.610
已经不指向对象本身了

14:24.810 --> 14:26.210
已经不指向对象本身了

14:26.310 --> 14:27.810
那么现在会怎么样了

14:28.010 --> 14:29.010
现在会怎么样了

14:29.010 --> 14:29.810
咱们来看一下

14:30.210 --> 14:31.410
现在它输出的结果

14:31.610 --> 14:32.510
它会爆错的

14:33.010 --> 14:33.910
它会爆错的

14:34.710 --> 14:35.710
你看它说

14:35.810 --> 14:37.610
你无法去读取啥了

14:37.810 --> 14:39.210
无法去读取

14:39.910 --> 14:41.210
undefine里面的

14:41.410 --> 14:42.410
这个属性内

14:42.810 --> 14:44.410
undefine里面没有这个属性内

14:44.710 --> 14:45.610
那现在的z

14:45.610 --> 14:46.310
指向谁呢

14:46.410 --> 14:47.410
指向的是undefine

14:47.710 --> 14:49.610
有些朋友可能就觉得很奇怪

14:49.610 --> 14:51.410
为什么会指向undefine呢

14:51.510 --> 14:52.610
它为什么不是

14:52.810 --> 14:54.210
指向的权局辩量呢

14:54.210 --> 14:55.010
咱们说过

14:55.010 --> 14:56.110
直接调用函数呢

14:56.110 --> 14:57.810
z是指向的权局辩量

14:58.010 --> 14:59.810
那么这个时候是特殊情况

15:00.010 --> 15:01.410
这是以前的介石的知识

15:01.410 --> 15:02.610
跟t是没有什么关系

15:02.910 --> 15:04.110
这是介石的知识

15:04.310 --> 15:05.410
介石里面什么会说

15:05.410 --> 15:07.010
它这里现在就是怎么回事

15:07.610 --> 15:08.810
那么在介石里边

15:08.810 --> 15:10.610
如果你使用es6的语法

15:10.610 --> 15:11.710
输写这个内的话

15:12.210 --> 15:14.210
那么它会对内里边的z

15:14.210 --> 15:15.410
进行控制

15:15.610 --> 15:16.510
进行控制

15:16.610 --> 15:17.510
怎么控制呢

15:17.510 --> 15:19.910
就是说你如果直接调用对象的话

15:19.910 --> 15:21.510
那么在内里边

15:21.710 --> 15:23.110
z就指向了undefine

15:23.310 --> 15:24.210
实际上

15:24.810 --> 15:26.010
它内里边的代码

15:26.210 --> 15:27.710
它使用了严格模式

15:28.610 --> 15:30.310
它默认就使用了严格模式

15:30.310 --> 15:32.010
它必须要使用严格模式

15:32.310 --> 15:33.410
所以说这里面的z

15:33.410 --> 15:34.510
指向的都是undefine的

15:34.710 --> 15:35.910
如果你直接调用的话

15:36.410 --> 15:37.410
这个你是控制不了的

15:37.410 --> 15:38.310
es6里边

15:38.510 --> 15:39.710
内里边的语法

15:39.910 --> 15:41.310
都是使用的是严格模式

15:41.310 --> 15:42.610
因此它z是指向了

15:43.010 --> 15:43.610
全球调用

15:43.610 --> 15:44.810
z是指向的是undefine

15:45.710 --> 15:46.210
好

15:46.510 --> 15:48.210
这是关于这么一个点

15:48.210 --> 15:49.610
那么这个点的话

15:49.910 --> 15:51.410
我们就现在又回到ts

15:51.410 --> 15:52.610
你看它多不牢火

15:52.610 --> 15:53.310
多丢解

15:53.910 --> 15:55.610
那这个时候也就是说

15:56.010 --> 15:57.310
严格来说

15:58.010 --> 16:01.410
在内里边使用在写的一些函数的时候

16:01.810 --> 16:03.010
那么这个z是不是

16:03.010 --> 16:04.410
还是有可能出问题

16:04.910 --> 16:05.510
对不对

16:06.110 --> 16:07.710
还是有可能出问题啊

16:07.910 --> 16:10.410
你鬼才知道你到时候怎么去调用这个函数

16:10.710 --> 16:11.610
你如果正常调用

16:11.610 --> 16:12.510
那没有什么问题

16:12.710 --> 16:14.010
那z是指向的就是

16:14.410 --> 16:16.110
当前这个由着对下

16:16.610 --> 16:19.110
如果你没有正常调用

16:19.110 --> 16:19.810
像我这种

16:20.310 --> 16:21.110
这种方式

16:21.510 --> 16:22.710
那么用这种方式调用的话

16:22.710 --> 16:24.010
z是指向还是出问题

16:24.210 --> 16:24.910
也就是说

16:25.210 --> 16:26.710
如果我来做这个ts

16:26.710 --> 16:28.510
我来进行内形检查的话

16:28.510 --> 16:29.710
我来做这个决策的话

16:29.710 --> 16:30.510
我也很纠结

16:31.310 --> 16:31.910
我这个z

16:31.910 --> 16:34.210
我到底应该把它推断成n内形了

16:34.610 --> 16:37.310
还是说把它推断成用户对象内形了

16:37.610 --> 16:38.910
就很纠结这个问题

16:39.310 --> 16:41.410
如果我把它推断成用户对象的

16:41.710 --> 16:42.310
这种

16:43.010 --> 16:43.910
这个内形的话

16:44.710 --> 16:46.310
你看咱们讲讲这个课

16:46.410 --> 16:46.810
对吧

16:47.110 --> 16:48.010
讲的多细

16:48.110 --> 16:49.350
我说甚至在踩车

16:49.350 --> 16:51.410
为了让他做这个语言的想法了

16:52.210 --> 16:53.810
就是我们要搞清楚一个技术

16:53.810 --> 16:54.910
就特别像我

16:54.910 --> 16:57.010
我这个人特点就是我要搞清楚一个

16:57.010 --> 16:58.310
我要去学习一个东西

16:58.310 --> 16:59.710
我一定要把它搞得非常清楚

16:59.810 --> 17:03.110
就是我会站在他这个设计者的角度去思考这个问题

17:03.510 --> 17:05.910
尽管了可能有的时候有些出入啊

17:06.010 --> 17:06.310
但是呢

17:06.310 --> 17:07.410
我觉得绝大部分的时候

17:07.410 --> 17:08.510
你通过这样的思考

17:08.710 --> 17:10.710
你会对这个技术有很深入的了解

17:11.710 --> 17:12.110
好

17:13.010 --> 17:13.410
这里呢

17:13.410 --> 17:15.010
如果我是在做这个决策的话

17:15.010 --> 17:15.610
我就很纠结

17:15.610 --> 17:18.110
如果我把它设置成为用户对象

17:18.510 --> 17:19.710
那我写单码很方便

17:19.710 --> 17:22.510
有完整的就是内形推导啊

17:22.610 --> 17:24.610
有完整的就是智能提示

17:24.910 --> 17:25.710
就很舒服

17:26.310 --> 17:27.910
如果但是那有隐患

17:28.010 --> 17:29.610
因为我无法防止

17:29.610 --> 17:30.810
他用这种方式来调用

17:31.710 --> 17:32.010
好

17:32.010 --> 17:33.110
第二个问题呢

17:33.210 --> 17:35.110
就是说如果把它推断成N内形

17:35.110 --> 17:36.210
就像前面这样子

17:36.910 --> 17:37.510
前面这样子

17:37.510 --> 17:39.110
我就是把它推断成N内形

17:41.410 --> 17:42.210
看前边啊

17:44.080 --> 17:44.780
看前边

17:44.980 --> 17:46.180
我把这个这里呢

17:46.180 --> 17:47.580
推断成N内形

17:47.780 --> 17:49.480
那么为什么推断N内形呢

17:49.480 --> 17:51.080
因为就像这样子啊

17:51.080 --> 17:53.080
就像刚才我做决策的一块

17:53.280 --> 17:54.980
如果把它推断成N内形的话

17:54.980 --> 17:56.080
好处在于什么呢

17:56.180 --> 17:57.380
好处在于呢

17:58.280 --> 18:00.280
我可以适应各种情况啊

18:00.280 --> 18:01.780
各种情况我都考虑到了

18:01.980 --> 18:02.580
我并且呢

18:02.580 --> 18:04.480
我在这里点不出来对吧

18:04.780 --> 18:07.280
你这里通过智能提示点不出来

18:07.380 --> 18:08.780
点不出来有没有好处

18:09.180 --> 18:09.880
有没有好处

18:09.880 --> 18:11.480
他没有智能提示有没有好处

18:12.380 --> 18:13.380
大家可能觉得没有

18:13.380 --> 18:14.880
不能没有智能提示

18:15.080 --> 18:16.080
没有好处啊

18:16.180 --> 18:17.480
学习单码很不舒服啊

18:17.980 --> 18:18.680
但是注意

18:19.080 --> 18:21.180
没有智能提示说明什么

18:21.680 --> 18:24.380
他在他就在告诉你你这个Z

18:24.880 --> 18:26.580
你这个Z是N内

18:27.080 --> 18:27.980
是N内

18:28.580 --> 18:29.380
明白这意思吗

18:29.480 --> 18:31.180
他就在这样子告诉你这个N内

18:31.180 --> 18:32.280
你这里要小心

18:32.380 --> 18:33.980
因为你不清楚这个东西

18:33.980 --> 18:35.180
他是怎么调用的

18:36.080 --> 18:36.980
ok好

18:36.980 --> 18:38.980
这是关于我纠结的两个点啊

18:38.980 --> 18:40.980
就是说我把它设置为N内

18:40.980 --> 18:42.280
有N内内形的好处

18:42.580 --> 18:44.980
我把它设置为用户内形了

18:45.180 --> 18:46.780
就是对象本身的内形了

18:46.980 --> 18:48.780
有对有这种方式的好处

18:48.880 --> 18:50.580
两种方式我只能选一种

18:50.980 --> 18:54.480
我只能说目前T也是默认的做法了

18:54.880 --> 18:57.580
是在对象字面量里边啊

18:57.580 --> 18:59.380
在对象字面量里边

18:59.580 --> 19:00.780
他里边的Z呢

19:00.780 --> 19:02.180
他可以推断出来是N内

19:02.580 --> 19:03.980
而在内里边的话

19:04.080 --> 19:04.880
他认为啊

19:04.880 --> 19:06.380
他是这样的考虑的估计

19:06.580 --> 19:07.680
他说我这个

19:08.080 --> 19:09.580
内里边呢他的Z

19:09.680 --> 19:11.680
Z因为我内里面内的对象啊

19:11.680 --> 19:12.980
通常都是直接

19:13.080 --> 19:14.680
通过对象来调整方法的

19:14.880 --> 19:16.480
不太会用这种方式来做

19:16.980 --> 19:18.380
不太会用这种方式来做

19:18.680 --> 19:20.780
因为你都在使用ES6的内了

19:20.980 --> 19:23.680
那么你自然会按照你的规则来写

19:23.780 --> 19:24.480
因此呢

19:24.780 --> 19:26.180
他Z的推倒出来啊

19:26.180 --> 19:27.580
认为不太会出问题

19:27.580 --> 19:30.080
所以说他把推倒出来是用户对象

19:30.180 --> 19:32.180
而你使用对象字面量的话

19:32.380 --> 19:33.880
这种方式来写的话啊

19:34.080 --> 19:37.180
就表示你还是出一种很早期的写法

19:37.180 --> 19:38.280
那么早些写法呢

19:38.580 --> 19:39.880
你可能用起来就乱起来

19:39.880 --> 19:40.580
糟糕的用法

19:40.880 --> 19:41.780
因此呢这里呢

19:41.980 --> 19:43.180
可以推倒出来是N你

19:43.280 --> 19:45.080
当然这种推倒方式未来

19:45.580 --> 19:46.880
很有可能会变啊

19:47.080 --> 19:48.080
很有可能会变

19:48.480 --> 19:49.580
会有变化啊

19:49.580 --> 19:50.980
因为这种两者

19:51.180 --> 19:52.080
各有各的好处

19:52.380 --> 19:54.280
你说不好哪种一定是对的

19:54.480 --> 19:56.480
他怎么推倒一定是对的说不好

19:56.580 --> 19:58.180
因此呢未来有可能会变

19:59.180 --> 20:01.080
好这里呢我们再看一个例子啊

20:01.180 --> 20:02.880
比方说我们以前写代码的时候

20:02.880 --> 20:04.280
还有可能写出这样的代码

20:05.080 --> 20:06.680
就以前接是太灵活了

20:06.880 --> 20:07.380
他的呢

20:07.580 --> 20:09.380
他的函数呢是一等公里

20:09.580 --> 20:10.880
所以他太灵活了

20:11.280 --> 20:13.280
方可行啊比方说

20:13.880 --> 20:16.080
谁哈喽我把这个函数写外边

20:16.880 --> 20:18.180
我把这个函数写外边

20:19.180 --> 20:19.680
好

20:19.880 --> 20:20.980
你看这里他怎么一个

20:20.980 --> 20:22.580
让他怎么去推到这个Z是

20:22.580 --> 20:24.480
你告诉他怎么去推到这个Z是

20:24.680 --> 20:26.880
啊这里呢我把这个谁哈喽扔过来

20:27.480 --> 20:28.780
我把这个函数扔过来

20:28.980 --> 20:29.380
啊

20:29.780 --> 20:31.180
那如果我直接调用函数

20:31.180 --> 20:32.280
是不是正确的Z

20:33.080 --> 20:33.780
你想想啊

20:33.980 --> 20:35.080
我直接调用这个函数

20:35.080 --> 20:36.480
you do say hello

20:36.880 --> 20:38.680
调用这个实际上就调用啥

20:38.980 --> 20:40.280
调用这个函数对吧

20:40.380 --> 20:41.980
虽然我们函数写的时候呢

20:41.980 --> 20:43.380
没有写到对象里边

20:43.880 --> 20:44.680
但是呢

20:44.880 --> 20:46.280
我们调用的时候

20:47.180 --> 20:49.480
是通过对象再调用这个函数

20:49.880 --> 20:51.280
因此呢这个函数里面Z呢

20:51.280 --> 20:52.980
指向的是用户

20:53.880 --> 20:54.980
保存看一下吧

20:55.980 --> 20:57.380
好来看啊

20:57.780 --> 20:58.680
反回来结果

20:58.980 --> 21:00.480
你看得到是用户对象

21:00.680 --> 21:01.680
然后用户的姓名

21:01.680 --> 21:02.480
用户的年龄

21:02.780 --> 21:03.680
没有什么问题

21:04.080 --> 21:05.980
当然如果你这样子写函数的话

21:05.980 --> 21:07.980
他Z是指向是不是更加不明确了

21:08.280 --> 21:09.980
故意才知道这个函数用了什么地方

21:10.180 --> 21:12.180
他就没有办法去推到这个Z是内向

21:12.280 --> 21:13.980
像这种情况他一定是N你

21:14.180 --> 21:14.880
他一定是N你

21:14.880 --> 21:15.880
他都不用纠结了

21:15.880 --> 21:16.880
他肯定是N你

21:17.780 --> 21:18.780
好有的时候呢

21:18.780 --> 21:20.480
我们在一个函数里边

21:20.480 --> 21:22.180
使用Z是的话啊

21:22.180 --> 21:23.680
当然还包括很多情况了

21:23.780 --> 21:25.280
包括什么高阶函数

21:25.280 --> 21:26.780
函数里边返回函数

21:26.780 --> 21:27.980
那么返回那个函数里边的

21:27.980 --> 21:28.880
这些是就指向啥的

21:28.880 --> 21:30.380
就说不清楚了这些问题

21:31.080 --> 21:31.980
所以说呢

21:32.480 --> 21:35.580
为了避免啊为了减少这样的错误了

21:35.580 --> 21:38.180
ts呢可以提供了一个选项啊

21:38.180 --> 21:39.180
一个选项

21:39.180 --> 21:40.780
就是在编译时候的选项

21:40.980 --> 21:42.780
这个选项的名字呢叫做

21:44.580 --> 21:45.080
no

21:46.180 --> 21:46.980
implicit

21:47.180 --> 21:49.080
implicit比较是隐私的意思

21:49.080 --> 21:51.280
表示函序啊隐私的意思

21:51.880 --> 21:52.780
好把设为2

21:53.080 --> 21:54.480
这个配置是什么意思

21:54.480 --> 21:55.580
咱们把它记一笔啊

21:56.580 --> 21:57.680
首先配置啊

21:58.580 --> 21:59.080
配置

21:59.680 --> 22:00.280
这个玩意啊

22:01.080 --> 22:01.680
为粗

22:02.280 --> 22:02.980
表示什么呢

22:03.480 --> 22:08.180
表示不允许出现隐私的

22:09.480 --> 22:11.180
这隐私的

22:11.880 --> 22:13.380
呃这样说啊

22:13.680 --> 22:15.180
不允许热视

22:15.980 --> 22:18.080
隐私的指向

22:18.580 --> 22:19.080
n

22:19.880 --> 22:22.080
啊不允许热视的内情了

22:22.880 --> 22:24.380
推断出来是n你啊

22:24.380 --> 22:25.980
你可以手动给他指定为n你

22:25.980 --> 22:27.780
但是不允许推断出来是n你

22:27.980 --> 22:28.780
原来的意思吗

22:29.180 --> 22:30.780
好这样子设置了过后呢

22:30.780 --> 22:31.480
你看一下

22:32.780 --> 22:33.880
这种情况就爆脱了

22:34.380 --> 22:35.780
这种情况就爆脱了啊

22:35.780 --> 22:37.280
他觉得这个东西太危险了

22:37.280 --> 22:38.780
你这样子做太危险了

22:38.780 --> 22:40.480
实在是真的是实在是太危险了

22:40.480 --> 22:41.480
我说的都害怕

22:41.780 --> 22:43.180
你想你写这个喊说你怕不怕

22:43.180 --> 22:44.280
我反正非常害怕

22:44.580 --> 22:45.380
那我这样调问呢

22:45.380 --> 22:47.280
是不是这事要出问题啊

22:47.280 --> 22:48.780
他这事实际上太怪了

22:48.780 --> 22:49.980
情况太多了

22:50.380 --> 22:51.180
像这种邪法

22:51.480 --> 22:51.980
因此呢

22:51.980 --> 22:53.480
他不允许你这样做啊

22:53.480 --> 22:54.580
不允许你这样做

22:54.580 --> 22:55.880
当你把这个配置开启过后

22:55.880 --> 22:56.780
他就会爆错

22:58.080 --> 22:59.380
好这个时候呢

22:59.380 --> 23:01.180
我们就要想一种办法

23:01.680 --> 23:04.780
能不能我在书写函数的时候

23:05.080 --> 23:06.080
因为我定义

23:06.080 --> 23:07.580
像天使里边啊

23:07.580 --> 23:09.580
我们在最开始说的内情

23:09.580 --> 23:11.580
约束的时候就说过这个问题

23:12.280 --> 23:13.180
其实啊

23:13.380 --> 23:15.680
你在定义一个东西的时候

23:15.880 --> 23:18.880
你是非常清楚他的各种情况的

23:18.980 --> 23:21.080
他会在什么情况下去使用

23:21.180 --> 23:22.380
你是非常清楚的

23:22.980 --> 23:24.580
比方说这里是一样

23:24.980 --> 23:27.580
我在写函数的时候假设啊

23:27.980 --> 23:29.780
我在写这个函数的时候

23:29.980 --> 23:32.780
我就可以非常清楚的知道

23:32.980 --> 23:36.180
这里边的是一定指向谁

23:36.380 --> 23:38.180
一定指向一个用户对象

23:38.880 --> 23:40.480
一定指向一个用户对象

23:40.780 --> 23:41.980
比方说咱们一个接口

23:44.550 --> 23:45.250
i u 这

23:47.850 --> 23:50.050
这里有接口有姓名

23:51.050 --> 23:53.350
年龄年龄

23:54.350 --> 23:54.850
这里

23:56.050 --> 23:56.650
number

23:57.450 --> 23:59.050
有一个 say hello

23:59.750 --> 24:00.550
有一个函数

24:00.850 --> 24:01.850
发挥尾部位的

24:02.250 --> 24:03.650
假设我们有这么一个接口

24:04.650 --> 24:05.350
然后这里呢

24:05.350 --> 24:06.950
我这里使用这个接口啊

24:07.250 --> 24:08.150
使用这个接口

24:10.130 --> 24:10.930
i u 这

24:11.430 --> 24:12.330
使用这个接口

24:12.630 --> 24:13.430
就比方说

24:13.630 --> 24:15.430
现在呢咱们接口里面下面

24:15.430 --> 24:16.230
下面先不管啊

24:16.230 --> 24:16.930
先不管

24:17.430 --> 24:19.130
咱们先看这上面的接口

24:19.430 --> 24:21.030
这个接口里面有个函数

24:21.330 --> 24:22.430
这个函数呢

24:22.430 --> 24:23.530
我在定义的时候呢

24:23.530 --> 24:26.930
我觉得这个函数有可能里面会使用到 z 是

24:27.230 --> 24:28.830
有可能会使用到 z 是

24:29.330 --> 24:30.830
那么我希望的是

24:31.330 --> 24:32.630
这里面的 z 是呢

24:32.730 --> 24:35.030
他一定是指向的某一个类型

24:35.430 --> 24:37.030
我们这里可以声明的

24:37.030 --> 24:38.130
在ts 里边

24:38.330 --> 24:40.630
允许你在书写函数的时候

24:40.830 --> 24:42.430
来声明函数的时候

24:42.730 --> 24:45.030
声明这个函数中 z 的指向

24:47.260 --> 24:48.260
在ts 中

24:49.260 --> 24:49.960
允许

24:50.460 --> 24:52.560
在书写函数时

24:53.460 --> 24:54.260
声明

24:54.760 --> 24:55.660
手动声明

24:55.660 --> 24:56.760
不要让他自动推断了

24:57.060 --> 24:58.160
手动声明

24:58.460 --> 25:01.460
该函数中 z 的指向

25:01.660 --> 25:03.160
z 到底指向的是谁

25:03.860 --> 25:05.760
好你一旦声明过后

25:06.460 --> 25:09.260
所有的后续步骤全部获得

25:09.260 --> 25:10.460
严格的类型检查

25:10.760 --> 25:12.060
严格的去检查z

25:12.660 --> 25:13.460
怎么声明

25:13.660 --> 25:14.960
声明非常简单

25:15.460 --> 25:16.660
声明的做法就是

25:17.960 --> 25:21.060
将z 作为函数的

25:21.560 --> 25:22.660
第一个函数

25:24.260 --> 25:24.860
怎么声明

25:24.860 --> 25:25.560
这样子声明

25:27.470 --> 25:28.970
这里写上个z

25:30.070 --> 25:31.370
然后加上冒号

25:31.670 --> 25:32.370
冒号是啥

25:32.670 --> 25:33.870
类型约束对吧

25:33.970 --> 25:34.970
约束一下

25:35.070 --> 25:36.370
你这个z 是指向谁

25:36.470 --> 25:39.070
指向的百分之百一定是一个

25:39.070 --> 25:39.670
按油热

25:39.970 --> 25:41.070
一定是个用户对象

25:41.970 --> 25:42.770
指向是他

25:42.870 --> 25:44.170
指向的是自己的对象

25:45.070 --> 25:46.970
好了你现在声明了过后

25:46.970 --> 25:48.170
咱们再来看一下啊

25:48.170 --> 25:49.370
这个函数里边

25:50.870 --> 25:52.070
console log

25:52.570 --> 25:53.870
z 点

25:54.170 --> 25:55.170
你看是不是出来了

25:55.470 --> 25:56.270
z 点

25:56.370 --> 25:56.970
a 级

25:57.770 --> 25:58.270
你看呀

25:58.270 --> 25:58.970
这个z

25:59.870 --> 26:01.470
声明出来是按油热

26:01.670 --> 26:02.270
看到没

26:02.970 --> 26:05.070
好通过这样的声明呢

26:05.470 --> 26:07.570
我们一是可以获得智能提示

26:07.570 --> 26:08.670
这个没什么好说的

26:09.270 --> 26:10.070
第二呢

26:10.270 --> 26:11.370
你还会发现

26:11.870 --> 26:13.470
我如果这样子来用

26:15.470 --> 26:15.870
谁

26:18.180 --> 26:18.580
谁

26:19.880 --> 26:21.080
通过这样交融的时候

26:21.080 --> 26:21.680
他就会发

26:21.680 --> 26:22.380
他就会发现

26:22.380 --> 26:23.680
马上发现我出问题

26:24.080 --> 26:24.980
因为你说好了

26:24.980 --> 26:27.580
这个函数里面 z 指向的一定是

26:28.380 --> 26:29.380
当前用户啊

26:29.380 --> 26:30.380
质量的用户

26:30.380 --> 26:32.580
那如果你通过这种方式来调用的话

26:32.580 --> 26:33.980
那么z 指向不明

26:34.980 --> 26:35.980
z 指向不明

26:35.980 --> 26:37.080
这里我写错了啊

26:37.580 --> 26:38.780
这里多两个括号

26:38.980 --> 26:39.980
他一样会爆错

26:39.980 --> 26:40.980
错误不一样了

26:40.980 --> 26:41.580
他说

26:41.780 --> 26:42.680
这个z

26:43.180 --> 26:45.480
这里这里的上下吻中的z

26:45.480 --> 26:46.780
是无法分配给

26:46.980 --> 26:47.780
按油热的

26:48.080 --> 26:48.680
按油热的

26:48.680 --> 26:50.380
因为他的z 必须要指向按油热

26:50.380 --> 26:51.580
但是你这里的指向

26:51.580 --> 26:52.880
他不是按油热

26:52.980 --> 26:53.780
因此他爆错

26:54.180 --> 26:55.580
这样子有房子的你

26:55.680 --> 26:56.780
在操作

26:56.780 --> 26:58.780
在去写后续的代码的时候

26:58.780 --> 27:00.480
z 的指向混乱的问题

27:00.680 --> 27:01.780
因为你约定好了

27:01.780 --> 27:03.580
你这个z 指向一定要指向按油热

27:04.480 --> 27:06.780
我们可以通过这种方式来约定

27:07.080 --> 27:08.380
在函数声明的时候

27:08.380 --> 27:09.880
来约定z 的指向

27:10.780 --> 27:12.780
当然这是一个看上去是一个参数

27:12.780 --> 27:13.380
对吧

27:13.880 --> 27:16.280
那他实际上是不是参数啊

27:16.580 --> 27:17.980
实际上不是参数啊

27:17.980 --> 27:20.180
他得找一个位置来写这个代码

27:20.280 --> 27:21.480
他不是参数的啊

27:21.980 --> 27:23.680
我们来可以编译一下看一下的

27:25.880 --> 27:26.980
这里我停止

27:29.580 --> 27:31.480
npnrb

27:32.580 --> 27:33.380
编译看一下

27:33.380 --> 27:34.480
看一下编译的结果

27:36.580 --> 27:37.180
编译结果

27:37.180 --> 27:38.380
编译结果里面有东西吗

27:38.680 --> 27:39.380
啥东西都没有

27:39.380 --> 27:39.780
对吧

27:39.880 --> 27:40.980
他不是参数啊

27:41.080 --> 27:43.180
他只是写到了第一个参数的位置

27:43.380 --> 27:45.180
通过这种特殊的语法

27:45.180 --> 27:46.680
通过这种特殊的语法

27:46.680 --> 27:49.780
那么来约定这个函数中z 的指向

27:50.280 --> 27:51.980
如果你还有其他参数的话

27:51.980 --> 27:52.780
你就一次写

27:52.980 --> 27:53.880
你就一次写后

27:53.880 --> 27:54.980
前后来后面的参数

27:54.980 --> 27:56.180
那比方说这样的写法

27:56.380 --> 27:57.680
这个还是有几个参数呢

27:58.180 --> 27:59.380
这个还是不是两个参数

27:59.380 --> 28:00.380
只有这两个参数

28:00.380 --> 28:01.780
前面是约定的z

28:01.780 --> 28:02.780
z 的指向

28:03.580 --> 28:05.380
好我说一下关于这个问题啊

28:05.580 --> 28:07.880
那么下面内的做法呢是一样的啊

28:08.280 --> 28:11.180
就是如果你在开发一些项目的时候

28:12.380 --> 28:14.680
有些地方z 经常错

28:14.780 --> 28:15.580
经常出问题

28:15.580 --> 28:17.180
当然如果平时不怎么出问题

28:17.180 --> 28:18.080
就不用管他了

28:18.380 --> 28:20.180
如果是经常z 出问题

28:20.680 --> 28:22.080
在貼士里面有办法

28:22.380 --> 28:23.480
可以通过这种方式

28:23.880 --> 28:25.780
强行让z 指向某个东西

28:26.280 --> 28:27.880
好那么下面这个也是一样啊

28:28.080 --> 28:29.180
在 say hello 里边

28:29.780 --> 28:31.280
其实这里呢一般不会出问题

28:31.280 --> 28:32.480
你都在使用类的

28:32.480 --> 28:34.080
对吧你当然会正确的调用

28:34.180 --> 28:35.280
但是我们到了公司

28:35.280 --> 28:36.580
比方说到了公司一发现

28:36.680 --> 28:37.580
总有一些小白

28:37.580 --> 28:39.180
还会用乱七八糟的调用方式

28:39.180 --> 28:40.180
就这么方式来调用

28:40.580 --> 28:42.180
啊你跟他说说了多少次

28:42.280 --> 28:42.980
他都不听

28:43.080 --> 28:43.880
那怎么办呢

28:44.180 --> 28:45.280
啊怎么办啊

28:45.280 --> 28:46.180
你当上你可以

28:46.480 --> 28:47.580
罚他钱对吧

28:47.780 --> 28:48.380
罚款

28:48.580 --> 28:50.480
但是这也不是个长久的办法

28:50.480 --> 28:51.280
那后面呢

28:51.380 --> 28:52.480
还是会容易出错的

28:52.480 --> 28:54.780
他不是强约数强约数是什么

28:54.980 --> 28:56.480
你压隔就犯不了这个错

28:56.980 --> 28:58.780
好那么你可以做一个简单的事情

28:58.980 --> 29:00.580
在这里约定一下z

29:00.580 --> 29:01.880
我看你以后怎么犯错

29:02.980 --> 29:03.480
z为啥

29:03.480 --> 29:04.080
维修这

29:04.580 --> 29:05.980
你看他能雕吗

29:06.080 --> 29:07.080
根本就不能雕用了

29:07.580 --> 29:08.680
这样就是强约数

29:09.180 --> 29:11.080
只需要写简单这么一句话就行了

29:11.980 --> 29:13.280
如果以后在项目中

29:13.380 --> 29:14.880
你会发现啊团队开发的时候

29:14.880 --> 29:16.680
经常有些地方z指向出问题

29:16.880 --> 29:17.880
就使用这种方式

29:18.080 --> 29:19.380
在函数声明的时候

29:19.380 --> 29:21.780
第一个参数约定z的指向

29:22.680 --> 29:23.180
好了吧

29:23.680 --> 29:25.680
这是关于z这一块的设施

29:25.680 --> 29:26.580
就非常非常简单

29:26.580 --> 29:27.980
最终就说明这个道理就行了

29:28.480 --> 29:29.580
在最后再记一笔

29:30.780 --> 29:33.180
该参数只是

29:33.880 --> 29:36.880
只用于约数z

29:37.280 --> 29:40.680
并不是真正的参数

29:41.080 --> 29:42.880
也不会出现在

29:43.780 --> 29:44.780
编译结构中

29:46.780 --> 29:48.180
编译结构里面也会出现的

29:49.080 --> 29:49.280
好了

29:49.280 --> 29:51.780
这是关于ts里边的z

29:51.880 --> 29:53.380
因为ts的z是太混乱了

29:53.380 --> 29:55.480
因此ts作为类型检查系统

29:55.580 --> 29:56.980
还必须要搞定这个问题

29:58.280 --> 29:58.780
OK

29:59.480 --> 30:00.180
至此啊

30:00.780 --> 30:01.580
咱们就把

30:02.280 --> 30:05.080
内和接口的所有东西就学完了啊

30:05.680 --> 30:07.280
有些同学在问这个东西是啥

30:07.680 --> 30:08.980
这个东西是马克档里面的

30:09.580 --> 30:10.580
是马克档里面的

30:13.580 --> 30:15.780
就这里在越南的时候啊

30:17.680 --> 30:19.380
在越南的时候这里不是个目录吗

30:19.380 --> 30:20.980
对吧toc目录

30:21.080 --> 30:21.480
你看

30:22.180 --> 30:22.880
这是目录

30:23.780 --> 30:26.180
目录目录里面会忽略掉这个

30:26.380 --> 30:27.580
会忽略到这个标题

30:27.880 --> 30:30.180
目录里面是会忽略这个标题的

30:30.380 --> 30:32.080
因为这个标题就是整个文章的标题

30:32.080 --> 30:33.880
我希望他不要出现在目录里面

30:34.180 --> 30:34.980
就是这个意思

30:35.980 --> 30:36.380
啊

30:37.080 --> 30:37.580
然后至此呢

30:37.580 --> 30:39.780
我们学完了所有的内和接口啊

30:39.780 --> 30:40.880
这块的知识

30:41.080 --> 30:42.880
那么其实这一部分呢

30:42.880 --> 30:45.080
一部分是讲的是语法啊

30:45.280 --> 30:45.780
一部分呢

30:45.780 --> 30:47.380
还讲了一些思想

30:47.380 --> 30:50.080
特别是在继承啊抽象啊静态

30:50.580 --> 30:51.480
接口这一部分呢

30:51.480 --> 30:53.280
讲了很多的面向对象思想

30:53.380 --> 30:54.880
但我没有讲的太深啊

30:54.880 --> 30:57.180
因为毕竟咱们学的前端啊

30:57.380 --> 30:58.580
面向对象思想的一块呢

30:58.580 --> 30:59.680
我们要有接触

30:59.680 --> 31:01.880
但是不要过现在还不到

31:02.080 --> 31:03.880
深入去了解的时候

31:04.180 --> 31:04.980
那么接下来呢

31:04.980 --> 31:07.080
我们会做一个小游戏

31:07.380 --> 31:08.480
通过这个小游戏呢

31:08.480 --> 31:10.380
来锻炼我们的一些

31:10.880 --> 31:12.280
面向对象的思维

31:12.780 --> 31:15.480
大家可能在看的后面那个项目的时候呢

31:15.480 --> 31:15.880
会

31:16.680 --> 31:18.580
我相信回答大家会有诸多的疑问

31:18.680 --> 31:20.580
就是为什么代码会显成这样子啊

31:20.680 --> 31:22.980
为什么不用那种邪法之类的疑问

31:23.080 --> 31:23.880
没关系啊

31:24.080 --> 31:26.080
你通过去看这个项目

31:26.080 --> 31:27.380
或者是跟着我去

31:27.480 --> 31:29.780
一定要尽量的去跟着我去敲

31:29.980 --> 31:31.080
整个这个项目

31:31.080 --> 31:32.280
通过这个过程呢

31:32.280 --> 31:33.480
你能体会到

31:33.580 --> 31:36.480
一些你以前从来没有体会到的一些东西

31:36.780 --> 31:38.380
就是你会发现哇

31:38.380 --> 31:40.580
原来这个世界上代码还有这种邪法

31:40.780 --> 31:42.080
还有这种熟悉方式

31:42.280 --> 31:44.380
这是前段开发者很缺乏的东西啊

31:44.380 --> 31:44.980
我希望

31:45.280 --> 31:47.880
既然ts带来了这么一些新的理念

31:47.980 --> 31:48.780
我可以

31:48.980 --> 31:51.080
我希望大家去接触一下这些理念

31:51.080 --> 31:52.280
对大家是有好处的

31:52.280 --> 31:53.580
你看其他的教程里边

31:53.780 --> 31:56.280
t是教程里边都很少有讲到的这些东西

31:56.280 --> 31:56.780
是吧

31:57.180 --> 31:58.580
ok那么咱们

31:59.280 --> 32:01.280
这一张节呢就到此结束了啊

32:01.580 --> 32:03.880
我们下一个章节就是一个项目实战

32:03.980 --> 32:06.280
用这个章节的知识来完成一个

32:06.580 --> 32:07.280
游戏项目

32:07.580 --> 32:09.580
ok那么这个章节到到了啊

32:09.880 --> 32:10.380
拜拜

