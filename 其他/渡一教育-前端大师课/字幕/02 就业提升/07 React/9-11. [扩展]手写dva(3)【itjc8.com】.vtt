WEBVTT

00:00.750 --> 00:05.190
好 这是最后一次最后一节课的手写dba了

00:05.790 --> 00:08.830
其实后边还有啊 因为我们还没有讲那个dba中间键

00:09.550 --> 00:11.390
嗯 中间键很简单啊

00:12.270 --> 00:14.510
接下来我们就来写这个dba的配置

00:15.390 --> 00:18.870
因为我们在使用dba的时候 这里是不是可以传一个配置对象

00:19.190 --> 00:22.950
对吧 可以做很多的配置 比方说有哪些配置呢 我们看一下dba的API

00:23.670 --> 00:26.550
这里的配置不是有这么一些吗 history 对吧 我们可以配置

00:27.030 --> 00:33.510
之前我们不是写了history的配置吧 对吧 history的配置呢 我们都写好了啊 还记得吗 我们当时是这样子写的 你看呀

00:34.070 --> 00:40.950
我这里呢 有一个get options 对吧 得到配置 那么如果说你history没有传递的话 我就给你创建一个hardy history

00:41.270 --> 00:46.630
但是如果你传递的话 我就使用你传递的history 比方说我们这里 给他传递一个history进去

00:47.110 --> 00:47.350
from

00:48.670 --> 00:49.670
哪呢 就是

00:50.950 --> 00:51.430
history

00:52.150 --> 00:55.110
这里使用 create browser history

00:55.830 --> 00:58.310
好 ok 我们这里传递一个history

00:58.790 --> 01:00.310
we create a browser history

01:01.430 --> 01:04.870
好 保存 你看一下 那么我们现在呢

01:05.910 --> 01:11.830
刷新 那你看是不是用的是browser history的 对吧 就不用了用的不是卡西的啊用的是browser history

01:12.790 --> 01:20.070
啊 这个很简单啊 然后呢 后边呢 还有一些配置 我们按下来说啊 其实也不难了 如果关键难得再上一个课

01:20.550 --> 01:24.150
难得再上一个课 上一个课如果你学动了的话 那么就不难了啊

01:25.110 --> 01:28.070
咱们来看一下还有哪些配置呢 还有就是initial state

01:28.790 --> 01:34.950
这个表示的是默认状态 对吧 默认状态 比方说我们把一个conter给他设置为123

01:35.430 --> 01:38.230
啊 默认状态 但现在肯定没有生效啊 肯定没有生效

01:38.790 --> 01:42.950
那么这个默认状态有什么 起什么作用呢 我们这里还是在配置这里

01:43.350 --> 01:46.870
啊 我们给他设置一下默认状态啊 initial state

01:47.430 --> 01:52.470
那么看一下你的传递的initial state有没有值 如果说你没有值的话啊

01:52.630 --> 01:56.790
如果说你传递的initial state啊 等于undefined的话

01:58.230 --> 02:03.990
没有值啊 如果说你没有值怎么办呢 我就给你使用啊 一个空对象

02:04.710 --> 02:10.070
否则的话 我就使用你这个值啊 否则的话我就使用你这个值 我们做做一个三目运算服

02:10.390 --> 02:15.350
哎 有些东西说 那你这里为什么没有写两个货者呢啊 因为他有可能是你

02:15.590 --> 02:21.030
你能是不是状态 对吧 你能他判定也为假 所以说要考虑这些啊 我们用个三目运算服

02:21.910 --> 02:25.110
好了 那么现在呢 我们把这个默认状态就设置好了

02:25.830 --> 02:29.030
好 那么接下来呢 我们在创建仓库的时候

02:29.750 --> 02:32.630
哪里 我们找一找啊 在创建仓库的时候

02:33.350 --> 02:38.070
啊 得到一个仓库 创建仓库的时候是不是可以加默认状态 咱们就把那个op形式

02:38.310 --> 02:47.400
啊 再换个行吗 把这个op形式 第二什么啊 initial state 所加进来对不对 把默认状态加进来就完成了

02:47.800 --> 02:51.400
好 保存 咱们看一下啊 一开始是不是123对吧

02:51.880 --> 02:56.680
就这么简单啊 如果说你没有配置状态 那么一开始就是用的是0

02:57.960 --> 03:01.560
好 这是关于这个默认状态啊 好 接下来再看啊

03:02.200 --> 03:07.160
这都很简单 然后on error 就当发生错误的时候要运行到函数

03:07.960 --> 03:16.440
on error 我们这里可以输出 error 啊 然后呢他还会还会给你传递一个dispatch 啊 两个都会给你传递过来

03:16.760 --> 03:18.280
啊 一个 error 一个dispatch

03:19.560 --> 03:26.600
我们这里换个行输出嘛啊dispatch touch 我们这里输出 error 点message

03:28.440 --> 03:34.120
好 那么这个函数什么时候运行的 我们这里也也这么写一个啊 也这么写一个options

03:35.320 --> 03:42.200
好 这里边我们写上这么一个on error啊 on error 这么一个函数 如果说你obts啊

03:42.200 --> 03:47.160
on error 你够传递没 如果说你没有传递的话 我就给你一个空函数啊 啥都没运行

03:47.400 --> 03:55.480
啊 给你一个空函数啊 我也在拎啊 我这里扩起来啊 扩起来啊 给你一个空函数

03:57.080 --> 04:00.280
啊 就这样子啊 on error 给给他个空函数就完事了

04:00.760 --> 04:06.760
好 然后我们什么时候要运行这个 是不是发生错误的时候 哪个地方会发生错误 是不是副作用这里

04:07.240 --> 04:13.240
啊 有的有的有的有的有的发生错误了 有的有的一般不会发生错误啊 一般是在副作用这里发生错误

04:13.480 --> 04:17.080
好 我们找到副作用这里的代码 我们来看一下哪个地方在处理副作用

04:17.720 --> 04:26.920
啊 我们这里呢 是在get made aware 这里啊 ron saga 对吧 ron saga 这里是不是在这里处理副作用的 对不对

04:27.480 --> 04:34.520
哎 是不是在这里处理副作用的啊 然后呢每一次哎 我看一下啊 ron啊 在这里 ron啊 ron

04:35.800 --> 04:41.560
在这里运行 saga 的时候 那么有这里这里边呢有每一个就是有这么一个

04:42.360 --> 04:47.000
啊 运行的这么一个函数 对不对 那么这个函数中间可能会发生错误啊

04:47.000 --> 04:49.400
它可能会发生错误 所以我们在这里呢用一个揣开器

04:50.520 --> 04:55.640
啊 在这里用一个揣开器 看一下你这里没有发生错误啊 开启

04:57.960 --> 05:07.660
啊 error 啊好 当你发生错误的时候我干嘛呢 是不是判断一下啊 不用判断的啊 options 点 on error 运行它就行了

05:07.900 --> 05:14.300
把 error 传进去 然后呢再传一个dispatch dispatch 来自于哪 是不是来自于仓库里边dispatch啊 对不对

05:14.620 --> 05:19.980
哎 来自于仓库里边dispatch 好 那么这个地方怎么来得到仓库呢 问题是

05:20.540 --> 05:23.820
我看一下啊 这个地方怎么来得到仓库呢

05:24.700 --> 05:32.220
嗯 ron saga 啊 咱们直接把个仓库传进去吧 作为参数传进去 我们之前写过这么个 ron saga 函数

05:33.740 --> 05:39.340
把仓库传进去 好 那么这里边呢 我们就可以直接啊 直接来得到仓库了

05:39.820 --> 05:45.500
啊 得到仓库对象 就是得到这个dispatch store 点dispatch 啊 传进去完事

05:46.620 --> 05:48.860
好 保存 然后呢 我们在那个

05:50.060 --> 05:57.660
模型里边 抛出一个错误 抛出一个错误 试一下啊 比方说我们这里sync increase 这里 抛出一个错误啊 new error

05:58.860 --> 06:01.900
错误 测试 好 保存

06:02.300 --> 06:04.380
现在呢 我们一步加

06:05.980 --> 06:11.660
啊 你看是不是运行到那个on error了 对不对 运行到错误了啊 就这么个意思啊 就这么个意思

06:12.460 --> 06:14.860
好 这是这一块啊 这一块

06:16.860 --> 06:23.820
嗯 然后我们继续啊 继续 嗯 还有什么呢 还有什么配置呢啊 我们这里把注射掉了啊

06:24.540 --> 06:27.260
呃 看一下这边啊 on accuracy

06:28.220 --> 06:31.900
on accuracy 什么意思呢 就是给他加中间键啊 给他加一些中间键

06:32.380 --> 06:35.180
on accuracy 里边是不是可以传一个传一个就是

06:35.900 --> 06:40.540
一个中间键或者是多个中间键的数组 对不对 传中间键啊 传中间键

06:40.940 --> 06:43.500
好 最后我们这里写这么一个中间键吧 local

06:46.220 --> 06:50.540
我们中间键怎么写的store uh next 还有什么

06:51.180 --> 06:55.020
还有action 啊 然后呢 这里我们输出一下啊

06:55.580 --> 07:00.310
老状态 然后这里是用那个store

07:01.110 --> 07:06.550
叫get state 好 这里呢 我们输出输出一个action

07:08.070 --> 07:11.990
action 好 那么这里呢 是action

07:13.190 --> 07:15.030
好 再输出新状态

07:16.950 --> 07:19.270
好 这里呢 是store get state

07:20.070 --> 07:25.990
好 然后呢 最后输出一个空空行对吧 我们写上这么一个中间键

07:25.990 --> 07:29.990
好 这个中间键呢 可以这样传递啊 也可以呢 直接写一个

07:30.950 --> 07:34.230
传递都行啊 都行 那么在第八里面怎么来操作呢

07:34.230 --> 07:37.670
其实就是在得到中间键啊 就是我们现在的配置写好

07:37.670 --> 07:40.470
好 配置这里呢 就是on accuracy

07:41.750 --> 07:46.150
好 如果说你传递了啊 on accuracy 那么我就使用你传递的

07:46.150 --> 07:48.310
如果说你没 如果说你没有传递

07:49.190 --> 07:53.110
或者说我们这里做个判断嘛 做个判断也行 再进一步判断一下

07:54.230 --> 07:57.190
如果说你这个opts on action

07:59.030 --> 08:04.070
如果说你有值 有值的话分为两种情况 一种呢 他是一个数组

08:04.070 --> 08:08.710
array is opts on action

08:08.710 --> 08:14.710
如果 如果说你是一个数组 那么我就往opts里边加一个数项 on action

08:14.710 --> 08:17.430
加这么一个数项 就等于什么 就等于你这个数组

08:19.270 --> 08:22.630
如果说你不是数组的话 我就把你放到数组里边

08:22.630 --> 08:26.550
这个很简单 我总之呢 最后一定要得到一个数组

08:26.550 --> 08:30.070
如果你不是数组的话 我就把你放到一个数组里边 on action

08:30.070 --> 08:33.350
对吧 给你放进去 好 这他有值的情况

08:33.350 --> 08:37.430
他没有值的情况 那么我就直接给你一个空数组

08:39.270 --> 08:42.310
就这么三种情况 你看到了啊

08:42.310 --> 08:47.830
注意中了 就是说这个属性呢 这个属性 on action这个属性里边一定是个数组

08:48.070 --> 08:52.950
然后呢 我们在那个得到中间键的时候啊 得到中间键的时候

08:52.950 --> 08:58.470
那么除了有 除了有这么一些中间键之外啊 除了有这么一些中间键之外啊

08:58.470 --> 09:00.230
我们这里写这么一个中间键数组嘛啊

09:02.150 --> 09:04.150
这里写这么一个中间键数组medals

09:05.990 --> 09:08.230
有这么两个啊 有点这么两个中间键

09:08.230 --> 09:11.030
好 那么现在呢 还要把那个中间键加上 对不对

09:11.030 --> 09:15.670
还要把那个opts形式啊opts形式叫on action这个中间键

09:15.670 --> 09:19.830
这里边 这个数组里边存放了中间键加上 展开 对吧

09:19.830 --> 09:21.030
就把这个medals传过来

09:23.430 --> 09:25.110
当然你可以直接在这里写也行

09:26.310 --> 09:30.550
对吧 好 这就加上中间键了 特别特别简单啊 保存你看一下

09:31.190 --> 09:34.230
哎 他说什么medalware is not a function

09:36.630 --> 09:41.190
哦 这里 我们这里呢 要把这个这个地方替换啊

09:42.230 --> 09:47.370
medals 在这里替换

09:48.330 --> 09:56.100
在这里替换到这 这样子啊 这样子把中间键放进去就完事了

09:56.660 --> 10:01.060
好 看一下吧 这刷新 这里还说 还有错误

10:01.060 --> 10:04.180
他说medalware is not a function 就这里边有一些中

10:04.820 --> 10:05.780
中间键呢

10:07.620 --> 10:12.180
哦 他的中间键要展开啊 速度展开 他是一个一个写进去了啊 展开

10:13.060 --> 10:16.580
好 你看 是不是中间键就加进去了 对吧 中间键就加进去了

10:17.540 --> 10:23.860
看呗 哎 好 这里再来一步加啊 一步减 一步加 一步减

10:25.140 --> 10:30.740
好 哎 哎 加减没用了啊 加减没用了 看一下加减为什么没用了

10:31.300 --> 10:37.940
啊 出发的一个行道是正常的啊 加减没用了 counter 里边 为什么加减没用了呢

10:38.820 --> 10:42.180
啊 这里输出一下啊 看哪个地方又把之前影响到了

10:43.140 --> 10:50.500
嗯 加啊 没有触发这个没有触发这个 increase 是吧啊 那之前那个 reducer 里边出问题了啊

10:51.060 --> 10:55.620
之前的 reducer reducer 里边出问题了 我看一下啊

10:56.820 --> 11:00.660
哪个地方 reducer 还为什么会出问题 我们看一下这个仓库

11:02.340 --> 11:06.740
仓库里边这些东西都加进去了 对不对 这些东西都都是加进去了

11:07.380 --> 11:11.540
那为什么 reducer 会出问题 是这里 我看一下是不是这里刚才

11:11.620 --> 11:18.660
我们写那个 uh initial 这里是出到了影响啊 加

11:19.460 --> 11:26.540
哎 这里出了问题 我看一下啊 看一下怎么回事啊 为什么这里会出问题

11:27.500 --> 11:29.980
嗯 我们这里 combine reducer

11:32.460 --> 11:35.500
嗯 这里这里使用了 combine reducers

11:36.940 --> 11:40.220
reducers uh root reducer obj

11:42.140 --> 11:43.820
啊 然后 gets extra

11:44.700 --> 11:55.000
reducers 哎 这里为什么会出问题啊 咱们输出一下 输出这个 root reducer obj 啊 之前都是好好的

11:56.920 --> 12:03.720
输出一下 counter 他是一个函数 对吧 他是一个这么一个函数 然后这个函数展开看一下

12:04.680 --> 12:11.530
我拉过来看一下 counter 是一个 reducer 函数

12:12.010 --> 12:17.770
那么这个 reducer 函数里边呢 他做了一个判断啊 他的内想呢 是不是能找到

12:18.490 --> 12:25.450
就是 counter reducer 里边 这个内想他只能找到他对应的内想 如果能找到对应的内想的话 就会去运行

12:25.850 --> 12:32.250
啊 就会去运行 那么在这个函数里边 这个函数应该是得到执行的啊 这个函数应该是得到执行的

12:32.890 --> 12:38.840
咱们来看一下吧 嗯 这个函数啊 就是这个函数应该得到执行的

12:39.400 --> 12:43.560
执行的 啊 把这个 x 点 一个新点 type

12:44.760 --> 12:51.140
打出来看一下啊 然后呢 我们这里点啊 点这个加

12:52.180 --> 12:56.020
哎 点加过后这个函数没有执行 连这个函数都没有执行

12:57.460 --> 13:00.900
这个函数是无论如何都要执行的啊 因为它是一个

13:02.660 --> 13:08.620
为什么连这个函数都没有执行的 那他执行到谁呢 我看一下

13:10.540 --> 13:12.380
router reducer obj

13:13.740 --> 13:17.420
我先把这个去掉 看是不是这个东西有没有对他进行产生的影响

13:18.380 --> 13:20.060
我先把这个extra去掉

13:21.740 --> 13:23.900
也没有也没有 那就不是他的影响

13:25.740 --> 13:30.780
哦 这里要调试一下了 哦 我们这里要看一下这这里是怎么回事 我们在这里打个地bug

13:32.380 --> 13:36.780
看一下这个getstone这里出了问题 嗯 这里得到一个对象

13:37.900 --> 13:41.660
然后呢 这里运行还所有的模型

13:42.620 --> 13:44.380
啊 拿到一个obj

13:46.680 --> 13:50.440
啊 这个对象里边啊 有了一个counter counter里面有个obj

13:52.200 --> 13:54.440
这里在没法没法拖动吗

13:55.240 --> 13:59.640
啊 不能拖动啊 那么这里呢 他得到的是一个reducer

14:01.320 --> 14:02.760
好得到的是一个reducer

14:03.320 --> 14:07.320
好 然后呢 我们再进 再来 又得到一个reducer 两个reducer了啊

14:07.800 --> 14:10.600
然后我们这里使用一个reducer obj

14:10.600 --> 14:12.000
把这个东西展开

14:12.000 --> 14:12.700
这个东西展开

14:12.700 --> 14:14.600
那么他得到这么一个东西

14:14.600 --> 14:15.800
这是没问题的吧

14:15.800 --> 14:17.400
这个应该是没问题的

14:17.400 --> 14:21.100
这是每一个属性对应的Reducer

14:21.100 --> 14:23.300
然后我们使用CombineReducer

14:23.300 --> 14:24.600
是把它进行合并

14:24.600 --> 14:27.200
合并过后来创建仓库

14:27.200 --> 14:29.000
来创建这么一个仓库

14:29.000 --> 14:31.600
然后我们去运行Saga

14:31.600 --> 14:33.000
运行Saga

14:34.500 --> 14:37.200
跟运行Saga应该没有什么关系吧

14:38.200 --> 14:41.200
这里跟运行Saga应该是没有什么关系吧

14:41.200 --> 14:42.200
这里

14:44.200 --> 14:45.200
应该是没有关系吧

14:45.200 --> 14:47.800
Saga还不会影响到这啊

14:47.800 --> 14:48.500
保存啊

14:48.500 --> 14:50.400
我们看一下到底是怎么回事

14:50.400 --> 14:52.200
然后这里点加

14:52.200 --> 14:52.800
还是不行

14:52.800 --> 14:56.000
也就是跟运行Saga是没有什么关系的

14:56.000 --> 14:58.200
那应该是一个很白痴的问题

14:58.200 --> 15:00.800
我感觉自己遇到一个很白痴的问题

15:00.800 --> 15:02.400
就是一个很小很小的地方

15:02.400 --> 15:02.900
我写错了

15:02.900 --> 15:05.900
因为整体上我是没有写错的

15:06.000 --> 15:11.200
这里合并了最后的一个对象

15:11.200 --> 15:14.200
合并成了一个跟的Reducer

15:14.200 --> 15:18.570
合并了一个跟的Reducer

15:18.570 --> 15:20.070
那我们这样子

15:20.070 --> 15:25.610
我们做一个最白痴的一个例子

15:25.610 --> 15:26.610
这样子

15:26.610 --> 15:27.710
来测试嘛

15:27.710 --> 15:29.110
要调试这个代码

15:29.110 --> 15:30.910
入水Reducer

15:30.910 --> 15:32.810
我们直接把入水Reducer传进来

15:32.810 --> 15:33.310
对吧

15:33.310 --> 15:34.710
我们这里先不用传

15:34.710 --> 15:35.810
先直接传一个函数

15:35.810 --> 15:36.810
我看这个X

15:36.810 --> 15:38.110
连直接这样子写

15:38.110 --> 15:40.210
看能不能执行

15:40.310 --> 15:43.110
Reducer执行了

15:43.110 --> 15:44.810
这是个跟Reducer

15:44.810 --> 15:46.010
反回的是什么呢

15:46.010 --> 15:47.610
反回的是一个123

15:47.610 --> 15:51.500
就随便反回一个

15:51.500 --> 15:54.700
这里不用低八个了

15:54.700 --> 15:56.100
看一下

15:56.100 --> 15:57.100
Reducer执行了

15:57.100 --> 15:58.200
加

15:58.200 --> 16:01.200
哇连这个都没有执行啊

16:01.200 --> 16:02.800
连这个跟Reducer都没有执行

16:02.800 --> 16:05.760
你看到没

16:05.760 --> 16:07.860
哇连这个都没有执行

16:07.860 --> 16:09.560
那就有点恐怖了

16:09.560 --> 16:11.160
那是谁吧

16:11.160 --> 16:11.860
谁

16:11.860 --> 16:12.860
我这里Dispatch了

16:12.860 --> 16:13.760
肯定是Dispatch了

16:13.760 --> 16:15.160
这个毫无疑问

16:15.160 --> 16:17.160
肯定是Dispatch了

16:17.160 --> 16:19.160
那一定是有一个某个中间键

16:19.160 --> 16:20.660
没有往后边交

16:20.660 --> 16:23.160
没有往后边移交

16:23.160 --> 16:24.160
一定是有一个中间键

16:24.160 --> 16:24.760
没有往

16:24.760 --> 16:26.360
没有把他往后边移交

16:26.360 --> 16:27.560
是不是我由于这里

16:27.560 --> 16:29.560
我的行动导致到了呢

16:29.560 --> 16:31.960
看一下

16:31.960 --> 16:33.460
扣的犯

16:33.460 --> 16:34.660
这是什么

16:34.660 --> 16:38.060
扣的犯的RotorReducer

16:38.060 --> 16:39.460
instead3

16:39.460 --> 16:47.530
it must be mounted under rotor

16:47.630 --> 16:50.520
这样子

16:50.520 --> 16:53.720
我把RotorReducer放着

16:53.720 --> 16:54.220
看一下

16:54.220 --> 16:55.620
现在

16:55.620 --> 16:56.420
这样

16:56.420 --> 16:57.320
哦是这个

16:57.320 --> 16:58.520
是这个东西导致的

16:58.520 --> 16:59.420
on X

16:59.420 --> 17:00.920
on X这里我哪里写错了

17:00.920 --> 17:02.220
我看一下

17:02.220 --> 17:04.020
我哪里写错了

17:04.020 --> 17:06.220
on X

17:06.220 --> 17:07.820
on X我始终给他

17:07.820 --> 17:11.020
始终保证给他的是一个数组

17:11.020 --> 17:12.520
如果说他是一个数组的话

17:12.520 --> 17:14.520
我就直接复制给他一个数组

17:14.520 --> 17:16.520
我们这里输出一下

17:16.520 --> 17:19.220
Option是on X

17:19.220 --> 17:22.320
输出一下这个数组

17:22.320 --> 17:23.320
是一个中间键

17:23.320 --> 17:24.320
没问题

17:24.320 --> 17:26.120
数组里面存放了一个中间键

17:26.120 --> 17:26.520
然后呢

17:26.520 --> 17:28.320
我们在应用中间键的时候

17:28.320 --> 17:31.320
就是get middleware的时候

17:31.320 --> 17:32.120
我们看一下

17:32.120 --> 17:33.320
get middleware的时候

17:33.320 --> 17:34.920
我们把这个medalware呢

17:34.920 --> 17:36.520
放到一个数组里边

17:36.520 --> 17:37.920
首先有这么一个medalware

17:37.920 --> 17:39.720
然后有这么一个saga medalware

17:39.720 --> 17:40.020
然后呢

17:40.020 --> 17:42.320
我们把Options里边的on action

17:42.320 --> 17:44.020
这个数组里边展开放这

17:44.020 --> 17:45.520
然后我们自己输出

17:45.520 --> 17:47.520
medals

17:47.520 --> 17:48.120
输出

17:48.220 --> 17:49.920
他应该得到的是一个数组

17:49.920 --> 17:50.420
对吧

17:50.420 --> 17:51.620
是一个数组

17:51.620 --> 17:52.620
没问题

17:52.620 --> 17:53.120
然后呢

17:53.120 --> 17:55.320
我们去应用这个中间键

17:55.320 --> 17:56.620
应用这个中间键

17:56.620 --> 17:58.620
apply middleware

17:58.620 --> 17:59.920
apply middleware

17:59.920 --> 18:00.320
然后呢

18:00.320 --> 18:03.120
把这个中间键放进去

18:03.120 --> 18:04.920
没问题啊

18:04.920 --> 18:05.720
有什么问题呢

18:05.720 --> 18:07.120
这里

18:07.120 --> 18:10.510
没问题啊

18:10.510 --> 18:13.110
那为什么又加不了了呢

18:13.110 --> 18:13.810
就加不了了

18:13.810 --> 18:15.810
你看到没

18:15.810 --> 18:16.610
好奇怪啊

18:16.610 --> 18:17.710
这个

18:17.710 --> 18:19.110
我就加了一个node

18:19.110 --> 18:21.410
哦

18:21.410 --> 18:22.110
明白了

18:22.110 --> 18:22.210
明白了

18:22.210 --> 18:22.810
我的天啊

18:22.810 --> 18:24.710
这种进犯者的低级错误啊

18:24.710 --> 18:26.110
进犯者的低级错误

18:26.110 --> 18:26.310
好

18:26.310 --> 18:28.210
那么这里是不是还在往下移交啊

18:28.210 --> 18:28.610
兄弟

18:28.610 --> 18:30.310
我这天啊

18:30.310 --> 18:31.710
还在往下移交啊

18:31.710 --> 18:32.310
不然的话

18:32.310 --> 18:33.910
后边的是不是执行不了了

18:33.910 --> 18:35.710
后边的就是原来的reducer

18:35.710 --> 18:36.910
是不是执行不了了

18:36.910 --> 18:37.110
对吧

18:37.110 --> 18:39.710
还在往后移交啊

18:39.710 --> 18:40.710
好这里加

18:40.710 --> 18:41.710
我的天啊

18:41.710 --> 18:43.310
就这个问题啊

18:43.310 --> 18:45.610
好这里是

18:45.610 --> 18:47.210
哎这里状态

18:47.210 --> 18:48.410
先得先移交

18:48.410 --> 18:48.910
对吧

18:48.910 --> 18:49.410
先移交

18:49.410 --> 18:51.810
好

18:51.810 --> 18:52.610
ok

18:52.610 --> 18:53.710
那现在没问题了啊

18:53.710 --> 18:55.310
没问题了

18:55.310 --> 18:55.510
好

18:55.510 --> 18:56.210
这是这一块

18:56.210 --> 18:57.810
我的天

18:57.810 --> 18:58.310
然后呢

18:58.310 --> 18:59.510
instance change

18:59.510 --> 19:02.010
就当状态发生变化的时候呢

19:02.010 --> 19:03.910
它要运行的函数啊

19:03.910 --> 19:05.410
当状态发生变化的时候

19:05.410 --> 19:06.610
要运行的函数

19:06.610 --> 19:07.310
那么这个配置

19:07.310 --> 19:10.080
我们放在这啊

19:10.080 --> 19:11.880
当状态发生变化的时候

19:11.880 --> 19:12.880
要运行的函数

19:12.880 --> 19:14.480
你会得到一个新的状态

19:14.480 --> 19:14.880
对吧

19:14.880 --> 19:16.280
会得到一个新的状态

19:16.280 --> 19:16.980
ok

19:16.980 --> 19:18.180
那么就是这么个函数

19:18.180 --> 19:19.380
哪里要干嘛啊

19:19.380 --> 19:21.580
你自己自己写啊

19:21.580 --> 19:22.980
要干嘛你自己写

19:22.980 --> 19:25.180
好就这么个函数

19:25.180 --> 19:26.180
比方说我们就这里

19:26.180 --> 19:28.480
就输出一个状态嘛

19:28.480 --> 19:30.580
就输出的状态啊

19:30.580 --> 19:31.980
比较 counter

19:31.980 --> 19:32.180
啊

19:32.180 --> 19:33.480
这个中间厌不要了

19:33.480 --> 19:34.980
这个不要了

19:34.980 --> 19:36.380
这个不要了

19:36.380 --> 19:38.580
就输出了新的新的数字啊

19:38.580 --> 19:40.480
状态里边新的数字啊

19:40.480 --> 19:42.380
那么这个函数什么时候执行呢

19:42.380 --> 19:42.780
你想啊

19:42.780 --> 19:43.780
状态发生改变

19:43.780 --> 19:45.380
是不是 reducer 再执行

19:45.380 --> 19:45.580
对吧

19:45.580 --> 19:47.680
reducer 它会导致状态发生变化

19:47.680 --> 19:48.380
对吧

19:48.380 --> 19:50.680
所以说我们这里呢

19:50.680 --> 19:51.580
只需要啊

19:51.580 --> 19:53.080
只需要找到找到这

19:53.080 --> 19:53.580
找到我们

19:53.580 --> 19:54.880
这就是第一把里边

19:54.880 --> 19:57.180
我们触发 reducer 的时候

19:57.180 --> 19:59.880
那么哪个地方在合并 reducer 是在这

19:59.880 --> 20:01.380
get reducer 对吧

20:01.380 --> 20:02.380
get reducer

20:02.380 --> 20:03.280
get reducer 在哪

20:03.280 --> 20:05.080
看一下前面我们的写的函数

20:05.080 --> 20:06.080
get reducer

20:06.080 --> 20:06.880
那么这里呢

20:06.880 --> 20:08.780
是不是在产生一个 reducer 函数

20:08.780 --> 20:09.380
对吧

20:09.380 --> 20:10.980
在产生一个 reducer 函数

20:10.980 --> 20:12.580
那么我们当我们得

20:12.580 --> 20:13.680
当我们去运用

20:13.680 --> 20:16.980
运行了他之前的那个 reducer 之后

20:17.080 --> 20:20.780
运行了他之前的这个 reducer 之后

20:20.780 --> 20:22.780
我们是不是要去触发这个东西

20:22.780 --> 20:23.180
对吧

20:23.180 --> 20:24.380
所以说我们带 option 是里边

20:24.380 --> 20:26.280
首先写上这么一个东西啊

20:26.280 --> 20:27.280
写上这么一个东西

20:27.280 --> 20:28.280
option 是里面

20:28.280 --> 20:31.880
就是 on state change

20:31.880 --> 20:33.280
如果说你给我传递了

20:33.280 --> 20:34.580
那我就使用你传递的

20:34.580 --> 20:35.880
如果说你没有传递的话

20:35.880 --> 20:38.880
我就使用一个空函数

20:38.880 --> 20:41.080
啥都没有干的空函数

20:41.080 --> 20:41.980
就做这么一件事

20:41.980 --> 20:45.300
把扩起来

20:45.300 --> 20:46.800
好了就写好了

20:46.800 --> 20:48.100
好那么这里

20:48.100 --> 20:49.500
当我们去触发

20:49.500 --> 20:51.900
当我就是我们得到的 reducer 函数的时候

20:51.900 --> 20:54.000
去运行这个 reducer 函数的时候

20:54.000 --> 20:55.400
运行了之后

20:55.400 --> 20:56.800
我们是不是要触发一次

20:56.800 --> 20:57.400
对吧

20:57.400 --> 20:59.300
我们这是运行的 new state

20:59.300 --> 21:01.000
得到一个 new state

21:01.000 --> 21:01.400
然后呢

21:01.400 --> 21:01.900
我们最后呢

21:01.900 --> 21:03.500
会把这个 new state 返回

21:03.500 --> 21:04.400
运行 reducer 嘛

21:04.400 --> 21:06.300
得到一个新的状态返回

21:06.300 --> 21:06.800
然后呢

21:06.800 --> 21:08.700
我们这里是不是要去运行一下

21:08.700 --> 21:10.800
运行一下 on state change

21:10.800 --> 21:12.400
是在这吗

21:12.400 --> 21:13.500
是不是在这

21:13.500 --> 21:14.500
不是在这啊

21:14.500 --> 21:15.200
不是在这

21:15.200 --> 21:16.800
因为你容易想到的话

21:16.800 --> 21:18.000
可能会写到这

21:18.000 --> 21:18.400
但是呢

21:18.400 --> 21:19.600
实际上是不是在这的

21:19.600 --> 21:21.000
为什么说不是在这的

21:21.000 --> 21:22.400
因为这里只是其中

21:22.400 --> 21:24.000
某一个模型的

21:24.000 --> 21:25.500
某一个 reducer

21:25.500 --> 21:28.000
说这里特别特别绕啊

21:28.000 --> 21:29.800
没有一两年那个工作经验的话

21:29.800 --> 21:31.900
是根本啃不下来这个代码的

21:31.900 --> 21:32.600
嗯

21:32.600 --> 21:34.800
就是这里的这里的 reducer 要搞清楚

21:34.800 --> 21:37.100
它是关联到某一个模型的啊

21:37.100 --> 21:39.100
是关联到某一个模型的

21:39.100 --> 21:41.600
那么我们是要在根的 reducer

21:41.600 --> 21:43.400
就是入车 reducer

21:43.400 --> 21:44.200
运行之后

21:44.200 --> 21:45.200
要运行这个函数

21:45.200 --> 21:46.200
而不是在这

21:46.200 --> 21:47.400
如果说你写到这的话

21:47.400 --> 21:49.800
那么会导致你一次状态变化

21:49.800 --> 21:51.400
那么这个函数会运行很多次

21:51.400 --> 21:52.400
因为一次状态变化

21:52.400 --> 21:55.000
他首先交给跟入车 reducer

21:55.000 --> 21:55.700
入车 reducer

21:55.700 --> 21:57.500
就把它分发到其他的 reducer

21:57.500 --> 21:58.300
那么每一个 reducer

21:58.300 --> 22:00.100
他都会运行那个函数的

22:00.100 --> 22:01.600
所以说你要放到哪呢

22:01.600 --> 22:03.300
要放到这

22:03.300 --> 22:04.800
就是创建仓库的时候

22:04.800 --> 22:06.200
不得到入车 reducer

22:06.200 --> 22:07.900
对吧得到入车 reducer

22:07.900 --> 22:08.300
哎

22:08.300 --> 22:09.700
我把这个入车 reducer

22:09.700 --> 22:12.100
再重新改造一下啊

22:12.100 --> 22:13.100
改造一下

22:13.100 --> 22:13.900
我们这里呢

22:13.900 --> 22:17.100
先用个变量叫 all 的 reducer

22:17.100 --> 22:19.000
等于什么入车 reducer

22:20.000 --> 22:22.680
啊啊

22:22.680 --> 22:24.680
那么先把它把之前的 reducer

22:24.680 --> 22:26.080
入车 reducer 保存起来

22:26.080 --> 22:26.880
然后呢

22:26.880 --> 22:29.480
重新给入车 reducer 复制啊

22:29.480 --> 22:31.180
重新复制

22:31.180 --> 22:32.680
复制为新的一个函数

22:32.680 --> 22:34.680
state 啊 action

22:34.680 --> 22:37.380
对吧复制为一个新的函数

22:37.380 --> 22:38.180
原来的意思吧

22:38.180 --> 22:39.480
复制为一个新的函数

22:39.480 --> 22:41.380
复制为新的函数之后

22:41.380 --> 22:42.580
我们在这里边

22:42.580 --> 22:45.180
先去调用 all 的 reducer

22:45.180 --> 22:47.480
得到一个新的状态 new state

22:48.380 --> 22:50.380
调用这个 all 的 reducer

22:50.380 --> 22:51.380
把 state 传进去

22:51.380 --> 22:52.280
x 传进去

22:52.280 --> 22:54.380
得到一个新的状态啊

22:54.380 --> 22:54.980
然后呢

22:54.980 --> 22:55.880
我们再判断

22:55.880 --> 22:57.580
all 形式

22:57.580 --> 22:58.280
不用判断了啊

22:58.280 --> 22:59.980
直接调用 on state change

22:59.980 --> 23:01.780
因为它有默认值吗

23:01.780 --> 23:02.180
然后呢

23:02.180 --> 23:04.080
把新的状态传进去

23:04.080 --> 23:05.080
去调用这个

23:05.080 --> 23:07.980
然后我们再把这个新的状态返回

23:07.980 --> 23:09.380
对吧啊

23:09.380 --> 23:10.380
就是

23:10.380 --> 23:11.980
封装了

23:11.980 --> 23:12.880
什么封装了

23:12.880 --> 23:15.180
就是新的

23:15.180 --> 23:17.380
就是封装了 on state

23:18.380 --> 23:21.380
签级的 reducer

23:21.380 --> 23:22.880
重新封装一下

23:22.880 --> 23:24.380
然后再传进去

23:24.380 --> 23:24.680
好

23:24.680 --> 23:25.180
那么现在呢

23:25.180 --> 23:26.080
我们就可以得到

23:26.080 --> 23:27.480
每一次状态变化

23:27.480 --> 23:28.680
是不是可以得到新的状态了

23:28.680 --> 23:29.580
对吧

23:29.580 --> 23:29.980
你看

23:29.980 --> 23:31.980
是不是可以得到新的状态了

23:31.980 --> 23:33.180
对不对

23:33.180 --> 23:34.680
加

23:34.680 --> 23:35.680
看没

23:35.680 --> 23:35.980
好

23:35.980 --> 23:36.880
这是这个啊

23:36.880 --> 23:37.780
这个配置

23:37.780 --> 23:39.380
再看下一个

23:39.380 --> 23:40.380
on reducer

23:40.380 --> 23:43.580
那么就是对 reducer 进行封装

23:43.580 --> 23:46.780
就对 reducer 重新进行封装

23:47.280 --> 23:47.980
那么这里呢

23:47.980 --> 23:49.780
我们就写上

23:49.780 --> 23:52.780
on reducer

23:52.780 --> 23:53.980
你给我传递

23:53.980 --> 23:54.780
之前咱们写的

23:54.780 --> 23:56.780
一个传递的 reducer 进来

23:56.780 --> 23:57.180
然后呢

23:57.180 --> 23:59.280
我给你返回一个新的 reducer

23:59.280 --> 23:59.980
对吧

23:59.980 --> 24:01.780
返回一个新的 reducer

24:03.780 --> 24:04.280
action

24:06.280 --> 24:06.580
好

24:06.580 --> 24:07.180
那么这里呢

24:07.180 --> 24:08.580
我们输出

24:08.580 --> 24:09.980
什么呢

24:09.980 --> 24:14.580
就是新 reducer

24:14.580 --> 24:15.580
执行

24:15.580 --> 24:17.580
即将执行

24:17.580 --> 24:18.580
然后呢

24:18.580 --> 24:21.580
我们再返回这个 reducer 的调用结果

24:21.580 --> 24:23.580
对吧

24:23.580 --> 24:24.580
好

24:24.580 --> 24:26.580
这里是可以封装一个 reducer

24:26.580 --> 24:27.580
那么这一块呢

24:27.580 --> 24:28.580
写到哪呢

24:28.580 --> 24:29.580
这个配置

24:29.580 --> 24:30.080
好

24:30.080 --> 24:30.580
咱们呢

24:30.580 --> 24:31.580
还在这里啊

24:31.580 --> 24:32.580
还在这里

24:32.580 --> 24:34.580
写上这么一个默认配置啊

24:34.580 --> 24:35.580
on reducer

24:35.580 --> 24:37.580
你给我传递没有

24:37.580 --> 24:38.580
on reducer

24:38.580 --> 24:39.580
如果你给我传递了

24:39.580 --> 24:40.580
我就用你的

24:40.580 --> 24:41.580
没有传递的话

24:41.580 --> 24:43.580
我就给你一个空的函数

24:44.580 --> 24:45.580
好

24:45.580 --> 24:46.580
然后呢

24:46.580 --> 24:47.580
我们写到哪呢

24:47.580 --> 24:48.580
是不是这个时候才会写到

24:48.580 --> 24:49.580
刚才的get reducer 这里

24:49.580 --> 24:50.580
对吧

24:50.580 --> 24:52.580
这个时候才会写到get reducer 这里

24:52.580 --> 24:54.580
那么get reducer 这里不是一个 reducer 函数吗

24:54.580 --> 24:55.580
对不对

24:55.580 --> 24:57.580
有这么一个 reducer 函数

24:57.580 --> 24:58.580
好

24:58.580 --> 25:00.580
那么这个函数呢

25:00.580 --> 25:01.580
它里面会调用啥

25:01.580 --> 25:03.580
调用就是我们对应的

25:03.580 --> 25:05.580
那个模型里面对应写的 reducer 函数

25:05.580 --> 25:06.580
那么这个时候呢

25:06.580 --> 25:09.580
我会把这个函数来进行封装一下

25:09.580 --> 25:11.580
会对它进行封装一下

25:11.580 --> 25:13.580
就这么个意思

25:13.580 --> 25:15.580
然后呢

25:15.580 --> 25:16.580
不对不对不对

25:16.580 --> 25:17.580
不好意思啊

25:17.580 --> 25:18.580
不好意思

25:18.580 --> 25:20.580
这里封装的还是跟 reducer

25:20.580 --> 25:22.580
这里封装的还是跟 reducer

25:22.580 --> 25:24.580
还是这

25:24.580 --> 25:25.580
封装的还是这

25:25.580 --> 25:27.580
现在还要进一步封装

25:27.580 --> 25:31.580
进一步封装

25:31.580 --> 25:33.580
封装就是 un reducer

25:33.580 --> 25:34.580
就是你配置到这个东西

25:34.580 --> 25:36.580
那么我要进一步进一步封装

25:36.580 --> 25:37.580
好

25:37.580 --> 25:39.580
来吧

25:39.580 --> 25:41.580
这里

25:41.580 --> 25:43.580
这里默认字不能这样子写

25:43.580 --> 25:44.580
不能这样子写

25:44.580 --> 25:46.580
默认字得这样子写

25:46.580 --> 25:47.580
默认字得这样子写

25:47.580 --> 25:49.580
你给我一个 reducer

25:49.580 --> 25:50.580
然后呢

25:50.580 --> 25:53.580
我给你返回一个新的 reducer 函数

25:53.580 --> 25:54.580
一个新

25:54.580 --> 25:56.580
一个新的 reducer 函数

25:56.580 --> 25:57.580
这个新的 reducer 函数呢

25:57.580 --> 25:58.580
其实啥都没做

25:58.580 --> 25:59.580
啥都没做

25:59.580 --> 26:02.580
就是把原来 reducer 调用一次就完事了

26:02.580 --> 26:03.580
这是它默认的情况

26:03.580 --> 26:04.580
啥都没做

26:04.580 --> 26:06.580
把原来 reducer 调用一次

26:06.580 --> 26:07.580
又给我一个 reducer

26:07.580 --> 26:08.580
原来 reducer 函数

26:08.580 --> 26:10.580
我给你返回一个新的函数

26:10.580 --> 26:11.580
就是个 reducer

26:11.580 --> 26:12.580
它就是原封不动的

26:12.580 --> 26:13.580
把原来 reducer 调用一下

26:13.580 --> 26:14.580
返回就完事了

26:14.580 --> 26:16.580
这是它默认字

26:16.580 --> 26:18.580
那么这里呢

26:18.580 --> 26:20.580
进一步封装 reducer 怎么写呢

26:20.580 --> 26:21.580
怎么写

26:21.580 --> 26:22.580
是不是一样的道理

26:22.580 --> 26:24.580
先用 old reducer

26:24.580 --> 26:26.580
然后把它保存到

26:26.580 --> 26:28.580
保存一下新的 reducer

26:28.580 --> 26:30.580
然后再重新给入是 reducer 复制

26:30.580 --> 26:31.580
再重新复制为一个函数

26:31.580 --> 26:33.580
封装两成

26:33.580 --> 26:36.580
那么这个时候干嘛呢

26:36.580 --> 26:38.580
是不是返回的是

26:39.580 --> 26:40.580
第二

26:40.580 --> 26:42.580
un reducer

26:42.580 --> 26:43.580
对吧

26:43.580 --> 26:45.580
调用这个函数

26:45.580 --> 26:47.580
得到一个新的 reducer

26:49.580 --> 26:52.580
这个 root reducer 应该等于

26:52.580 --> 26:53.580
应该等于这个

26:53.580 --> 26:54.580
调用这个函数

26:54.580 --> 26:56.580
得到一个新的 reducer

26:56.580 --> 26:57.580
调用这个函数

26:57.580 --> 26:58.580
得到新的 reducer

26:58.580 --> 27:00.580
那么传什么进去

27:00.580 --> 27:01.580
是不是传一个

27:01.580 --> 27:03.580
传一个啥

27:03.580 --> 27:04.580
这里我们重新

27:04.580 --> 27:05.580
不用这句话了

27:05.580 --> 27:07.580
直接这样写就行了

27:07.580 --> 27:08.580
传一个啥

27:08.580 --> 27:10.580
传一个原来的 reducer 进去

27:10.580 --> 27:11.580
对吧

27:11.580 --> 27:13.580
是不是传一个原来的 reducer 进去

27:13.580 --> 27:14.580
对吧

27:14.580 --> 27:15.580
哦 不行

27:15.580 --> 27:16.580
还是有这句话

27:16.580 --> 27:18.580
还得把原来的 reducer 传进去

27:18.580 --> 27:20.580
原来的 reducer 传进去

27:20.580 --> 27:21.580
那么重新给它复制

27:21.580 --> 27:23.580
复制为一个新的 reducer

27:23.580 --> 27:25.580
这是 un reducer

27:25.580 --> 27:26.580
特别特别绕

27:26.580 --> 27:27.580
特别特别绕

27:27.580 --> 27:29.580
好 咱们看一下吧

27:29.580 --> 27:31.580
哎 这也说什么

27:31.580 --> 27:32.580
这是无限地归了是吧

27:32.580 --> 27:34.580
它说无限地归了

27:34.580 --> 27:36.580
我们把原来的 reducer 传进去

27:37.580 --> 27:39.580
原来的 reducer 传进去

27:39.580 --> 27:40.580
然后呢 复制给

27:40.580 --> 27:43.580
把整个这个调用的结果呢

27:43.580 --> 27:45.580
复制给新的 reducer

27:45.580 --> 27:47.580
新的 reducer

27:47.580 --> 27:49.580
那么我们把新的 reducer 放过来

27:49.580 --> 27:50.580
看一下

27:50.580 --> 27:52.580
它为什么会说无限地归呢

27:56.460 --> 27:57.460
看一下啊

27:57.460 --> 28:00.460
那么这个 un reducer 运行的时候

28:00.460 --> 28:03.460
它返回的是一个新的函数

28:03.460 --> 28:05.460
这个新的函数运行的是

28:05.460 --> 28:08.460
原来的 reducer

28:08.460 --> 28:10.460
运行的是原来的 reducer

28:10.460 --> 28:12.460
它并不是新的 reducer

28:12.460 --> 28:14.460
它并不是新的 reducer

28:14.460 --> 28:15.460
我这里传递的是

28:15.460 --> 28:16.460
原来的 reducer

28:16.460 --> 28:18.460
就这个 reducer

28:18.460 --> 28:20.460
就是前面复制的 reducer

28:20.460 --> 28:22.460
它为什么会说无限地归

28:22.460 --> 28:24.460
好 咱们这个对打个断点

28:24.460 --> 28:25.460
看它是怎么回事

28:25.460 --> 28:29.290
再打个断点

28:29.290 --> 28:32.790
看它为什么会无限地归

28:33.790 --> 28:34.790
这里

28:34.790 --> 28:36.790
运行到的 reducer

28:37.790 --> 28:39.790
下一步

28:39.790 --> 28:40.790
输出即将执行

28:40.790 --> 28:41.790
没问题

28:41.790 --> 28:42.790
这都没问题

28:42.790 --> 28:44.790
然后再运行这个 reducer

28:44.790 --> 28:46.790
进去运行

28:46.790 --> 28:47.790
那么运行到这

28:47.790 --> 28:49.790
我的 reducer

28:51.790 --> 28:53.790
这个又指向这了

28:53.790 --> 28:55.790
这个又指向这了

28:55.790 --> 28:56.790
因为它之前有个变量

28:56.790 --> 28:58.790
变量名同名了

28:58.790 --> 28:59.790
我知道了

29:03.170 --> 29:04.170
不是这里写的原因

29:04.170 --> 29:05.170
是因为这里

29:05.170 --> 29:07.170
同名了

29:07.170 --> 29:08.170
那么我们这里写个

29:08.170 --> 29:10.170
old reducer 2

29:11.170 --> 29:13.170
old reducer 2

29:14.170 --> 29:16.170
保重信心

29:16.170 --> 29:17.170
现在没问题了

29:17.170 --> 29:20.170
那么每一次 reducer 执行过后了

29:20.170 --> 29:21.170
执行的时候

29:21.170 --> 29:23.170
它都会执行到这

29:23.170 --> 29:24.170
都会到执行到这

29:24.170 --> 29:26.170
好 这是这个配置

29:26.170 --> 29:27.170
on reducer

29:27.170 --> 29:29.170
特别特别壮

29:31.170 --> 29:33.170
好 这一块写完了

29:33.170 --> 29:34.170
好 下一个

29:34.170 --> 29:36.170
下一个是 on effect

29:36.170 --> 29:37.170
那么这个配置

29:37.170 --> 29:39.170
这个配置就是

29:39.170 --> 29:40.170
当时我说了

29:40.170 --> 29:42.170
这个配置里面是不是有四个参数

29:42.170 --> 29:44.170
哪四个参数

29:44.170 --> 29:45.170
回忆一下

29:45.170 --> 29:47.170
原来的 effect 参数

29:48.170 --> 29:49.170
然后

29:49.170 --> 29:51.170
saga effect

29:51.170 --> 29:54.170
所有的 saga 里面的 effect 全都传进来

29:54.170 --> 29:55.170
然后

29:55.170 --> 29:57.170
还有什么 model

29:57.170 --> 29:58.170
模型

29:58.170 --> 29:59.170
还有什么

29:59.170 --> 30:01.170
还有是不是就那个

30:01.170 --> 30:03.170
action type

30:03.170 --> 30:05.170
它有这么四个参数

30:05.170 --> 30:06.170
要返回啥呢

30:06.170 --> 30:08.170
返回的是一个

30:08.170 --> 30:10.170
generator 方形

30:10.170 --> 30:12.170
generator 方形

30:12.170 --> 30:13.170
就是当每当那个 action

30:13.170 --> 30:16.170
对应的 action 内形触发的时候

30:16.170 --> 30:18.170
当对应的 action 内形触发的时候

30:18.170 --> 30:20.170
要执行的生成器

30:20.170 --> 30:21.170
你返回来是这么一个东西

30:21.170 --> 30:22.170
它这里只有一个 action

30:22.170 --> 30:23.170
对吧

30:23.170 --> 30:25.170
你返回来是这么一个东西

30:25.170 --> 30:27.170
那么这里边我们以前怎么写的

30:27.170 --> 30:28.170
我们就是这样写的

30:28.170 --> 30:29.170
副作用

30:29.170 --> 30:31.170
即将产生

30:31.170 --> 30:33.170
然后我们怎么写

30:33.170 --> 30:35.170
yield effect

30:35.170 --> 30:37.170
对吧

30:37.170 --> 30:39.170
effect 执行这个 effect

30:39.170 --> 30:41.170
白云传进去 完手了

30:41.170 --> 30:43.170
这就是我们之前的写法

30:43.170 --> 30:45.170
好 那我们来写下这个

30:45.170 --> 30:48.170
这个副作用是在哪里处理的呢

30:48.170 --> 30:50.170
能够听懂这一块的东西

30:50.170 --> 30:52.170
真的是不多

30:52.170 --> 30:53.170
很正常

30:53.170 --> 30:55.170
因为这个我特别特别的照

30:55.170 --> 30:58.170
你得有很深的程序功力才行

30:58.170 --> 31:02.170
这里边我们找到刚才那一块

31:02.170 --> 31:05.170
就是处理那个副作用的一块

31:05.170 --> 31:07.170
应该在 middleware 这里

31:07.170 --> 31:09.170
处理副作用这一块

31:09.170 --> 31:12.170
就让 saga 这里

31:12.170 --> 31:14.170
这里

31:14.170 --> 31:17.170
这里边我们当时是写了这么一个函数

31:17.170 --> 31:20.170
就是每当某一个 action 内形发生的时候

31:20.170 --> 31:22.170
它就运行这个函数

31:22.170 --> 31:25.170
好 那么这个函数可以进一步封装

31:25.170 --> 31:30.170
该函数可以被进一步封装

31:30.170 --> 31:32.170
可以被进一步封装

31:32.170 --> 31:34.170
好 封装成啥呢

31:34.170 --> 31:36.170
可以被进一步封装成啥呢

31:36.170 --> 31:38.170
那么怎么来封装成啥

31:38.170 --> 31:40.170
我们这里写 写上就是

31:40.170 --> 31:43.170
当然前面有个配置 配置还在写

31:43.170 --> 31:45.170
还在把配置写好

31:45.170 --> 31:48.170
就是那個 on effect

31:48.170 --> 31:50.170
on effect

31:50.170 --> 31:52.170
对 on effect

31:52.170 --> 31:54.170
OBTS

31:54.170 --> 31:56.170
算了 我都不写这个配置了

31:56.170 --> 31:58.170
这个配置我下面判断吧

31:58.170 --> 32:00.170
下面可以判断

32:00.170 --> 32:03.170
如果说 OBS

32:03.170 --> 32:06.170
它里面有个 on effect

32:06.170 --> 32:07.170
有这么一个属性

32:07.170 --> 32:09.170
如果说它有这么一个配置的话

32:09.170 --> 32:11.170
那么我怎么办呢

32:11.170 --> 32:13.170
我要把这个函数进一步封装

32:13.170 --> 32:16.170
进一步封装 产生一个新的函数

32:16.170 --> 32:17.170
产生一个新的函数

32:17.170 --> 32:21.990
好 我们这里的用个变量

32:21.990 --> 32:22.990
O的 func

32:22.990 --> 32:24.990
O的 effect

32:24.990 --> 32:25.990
O的 effect

32:25.990 --> 32:27.990
等于什么 func

32:27.990 --> 32:29.990
然后 func

32:29.990 --> 32:30.990
要重新给它复制

32:30.990 --> 32:32.990
重新给它复制为一个新的函数

32:32.990 --> 32:33.990
什么函数呢

32:33.990 --> 32:35.990
就是去调问这个函数

32:35.990 --> 32:37.990
on effect

32:37.990 --> 32:38.990
调问这个函数

32:38.990 --> 32:39.990
是不是要传四个函数

32:39.990 --> 32:41.990
第一个 effect

32:41.990 --> 32:43.990
是不是要传进去

32:43.990 --> 32:44.990
off effect 是不是要传进去

32:44.990 --> 32:45.990
off effect

32:45.990 --> 32:47.990
就是原来的 O的 effect

32:47.990 --> 32:49.990
就是原来的 effect 函数

32:49.990 --> 32:50.990
第二个是什么

32:50.990 --> 32:51.990
saga effect

32:51.990 --> 32:52.990
这个很简单

32:52.990 --> 32:53.990
saga effect

32:53.990 --> 32:54.990
是不是我们之前都有

32:54.990 --> 32:56.990
saga effect

32:56.990 --> 32:57.990
第三个是模型

32:57.990 --> 32:59.990
模型在哪呢

32:59.990 --> 33:00.990
模型在哪呢

33:00.990 --> 33:01.990
一看前面的循环

33:01.990 --> 33:03.990
一看前面的循环

33:03.990 --> 33:05.990
循环里面有

33:05.990 --> 33:08.990
循环里面我没有把模型装进去

33:08.990 --> 33:10.990
对吧 没有把模型装进去

33:10.990 --> 33:12.990
行 我把模型装进去有完事了

33:12.990 --> 33:13.990
摩托

33:13.990 --> 33:15.990
把这个模型也装进去

33:15.990 --> 33:17.990
这个数组里面就保存了模型了

33:17.990 --> 33:18.990
对吧

33:18.990 --> 33:21.990
那么第三个参数的是模型

33:21.990 --> 33:23.990
第三个参数的是Action的内形

33:23.990 --> 33:24.990
Action的内形好说

33:24.990 --> 33:25.990
那么就是Action.Type

33:25.990 --> 33:26.990
对吧

33:26.990 --> 33:27.990
Action.Type

33:29.990 --> 33:31.990
Action的内形

33:31.990 --> 33:32.990
Action的

33:32.990 --> 33:33.990
是Item里面

33:33.990 --> 33:34.990
Item里面

33:34.990 --> 33:36.990
Item.Action

33:37.990 --> 33:39.990
Item.Type

33:39.990 --> 33:42.620
Type

33:42.620 --> 33:43.620
对吧 传进去

33:43.620 --> 33:45.620
好 那么得到一个新的

33:45.620 --> 33:48.620
新的就是新的处理函数

33:48.620 --> 33:51.620
咱们把这个新的处理函数放进来

33:51.620 --> 33:53.620
放进来就完事了

33:53.620 --> 33:54.620
完成

33:54.620 --> 33:55.620
保存 你看一下

33:56.620 --> 33:58.620
那么现在让我们点易不佳

33:59.620 --> 34:01.620
易不佳

34:03.940 --> 34:06.940
易不佳的话有点问题

34:06.940 --> 34:07.940
易不佳有点问题

34:07.940 --> 34:09.940
它这个而废个成的没有

34:09.940 --> 34:11.940
没有执行

34:11.940 --> 34:13.940
咱们的这个东西没有执行

34:13.940 --> 34:15.940
咱们输出一下

34:15.940 --> 34:16.940
这里输出来没用 是吧

34:16.940 --> 34:18.940
我们看一下这个函数有没有执行

34:18.940 --> 34:22.440
这个函数肯定有执行的

34:22.440 --> 34:24.440
这个函数都没有执行

34:24.440 --> 34:25.440
这个函数都没有执行

34:25.440 --> 34:27.440
咱们又要来调了

34:28.440 --> 34:29.440
这里怎么回事呢

34:29.440 --> 34:32.440
这里我们take average在这

34:32.440 --> 34:34.440
take average在这

34:36.440 --> 34:38.440
然后的话

34:39.440 --> 34:40.440
这个funk

34:41.440 --> 34:42.440
funk在这

34:43.440 --> 34:45.440
options on effect

34:45.440 --> 34:47.440
好 我们这里输出一下

34:47.440 --> 34:50.440
输出一下options on effect

34:51.440 --> 34:53.440
on effect 保存

34:54.440 --> 34:56.440
on defined 明白了

34:56.440 --> 34:57.440
是我在这里的问题

34:57.440 --> 34:59.440
是我这里的问题

35:00.440 --> 35:02.440
是我这里的问题

35:04.440 --> 35:06.440
哪呢 在这

35:06.440 --> 35:07.440
我的还是在写一句

35:07.440 --> 35:08.440
我的写一句话

35:08.440 --> 35:11.440
就是on effect

35:11.440 --> 35:12.440
等于什么呢

35:12.440 --> 35:14.440
等于options on effect

35:14.440 --> 35:15.440
哪怕它没有传递

35:15.440 --> 35:17.440
我要有这么一个属性

35:17.440 --> 35:18.440
也得有这么一个属性

35:18.440 --> 35:20.440
哪怕它没有传递

35:20.440 --> 35:21.440
我也得有

35:21.440 --> 35:22.440
把它复职

35:22.440 --> 35:24.440
保存

35:24.440 --> 35:25.440
好 这里我们看一下

35:25.440 --> 35:26.440
一步加

35:26.440 --> 35:28.440
你看 副作用即将产生

35:28.440 --> 35:29.440
对吧

35:29.440 --> 35:30.440
完事了

35:31.440 --> 35:34.440
好 这就是关于on effect

35:34.440 --> 35:37.010
下一个

35:39.010 --> 35:40.010
extra reducers

35:40.010 --> 35:42.010
就是一些额外的 reducers

35:42.010 --> 35:43.010
你可以写到这

35:45.010 --> 35:46.010
extra reducers

35:46.010 --> 35:47.010
比方说这里

35:47.010 --> 35:49.010
可以写一些额外的 reducers

35:49.010 --> 35:51.010
abc

35:51.010 --> 35:52.010
比方说

35:53.010 --> 35:55.010
我们写一些额外的 reducers

35:55.010 --> 35:58.010
state

36:01.010 --> 36:03.010
123

36:03.010 --> 36:04.010
extra

36:04.010 --> 36:06.010
反回的是state

36:06.010 --> 36:07.010
abc

36:07.010 --> 36:08.010
多写一个 reducer

36:08.010 --> 36:09.010
那么这些 reducer

36:09.010 --> 36:10.010
是不是就可以合并到

36:10.010 --> 36:12.010
跟 reducer 里面去

36:12.010 --> 36:13.010
对吧

36:13.010 --> 36:14.010
这些 reducer 它会合并到

36:14.010 --> 36:15.010
跟 reducer 里面去

36:15.010 --> 36:16.010
那么

36:17.010 --> 36:18.010
我们可以在这个函数里边

36:18.010 --> 36:20.010
这个函数不就在做这个事吗

36:20.010 --> 36:21.010
对不对

36:21.010 --> 36:22.010
就在做这个事

36:22.010 --> 36:23.010
所以说我们在

36:23.010 --> 36:24.010
options 里面

36:24.010 --> 36:25.010
的话

36:25.010 --> 36:26.010
就是

36:26.010 --> 36:27.010
名字叫做

36:27.010 --> 36:28.010
配置名字叫做

36:28.010 --> 36:29.010
extra reducers

36:29.010 --> 36:30.010
看一下你

36:30.010 --> 36:31.010
有没有值

36:31.010 --> 36:32.010
如果说你

36:32.010 --> 36:33.010
你没有值的话

36:33.010 --> 36:34.010
给你一个空对象

36:35.010 --> 36:37.010
这是extra reducers的配置

36:37.010 --> 36:38.010
那么在这边

36:38.010 --> 36:39.010
我是不是把对象展开

36:39.010 --> 36:40.010
放着就完事了

36:40.010 --> 36:41.010
options

36:42.010 --> 36:43.010
extra reducers

36:43.010 --> 36:44.010
展开放着就完事了

36:44.010 --> 36:45.010
就这么简单

36:45.010 --> 36:47.010
保存你看一下

36:48.010 --> 36:49.010
那么现在我们的

36:49.010 --> 36:51.010
这个状态里边

36:51.010 --> 36:52.010
你看是不是有这个值的

36:52.010 --> 36:53.010
对吧

36:53.010 --> 36:54.010
就这么个值的

36:56.010 --> 36:58.010
这就是extra reducers

36:58.010 --> 36:59.010
它这里的写法

37:01.010 --> 37:02.010
然后呢

37:02.010 --> 37:03.010
还有什么

37:05.010 --> 37:07.010
extra enhancers

37:07.010 --> 37:08.010
就是增强

37:08.010 --> 37:09.010
就是这个东西其实就是

37:09.010 --> 37:10.010
它给你传递一个

37:10.010 --> 37:12.010
创建仓库的函数

37:12.010 --> 37:13.010
它给你传递一个

37:13.010 --> 37:15.010
创建仓库的函数

37:15.010 --> 37:17.010
然后你返回一个函数

37:17.010 --> 37:18.010
返回这么一个新的函数

37:18.010 --> 37:19.010
这个新的函数

37:19.010 --> 37:20.010
用来创建仓库

37:20.010 --> 37:21.010
就这么个意思

37:21.010 --> 37:22.010
就这么个意思

37:22.010 --> 37:24.010
比方说我们返回这么一个函数

37:25.010 --> 37:26.010
accus

37:27.010 --> 37:28.010
就是

37:28.010 --> 37:30.010
即将

37:30.010 --> 37:31.010
创建仓库

37:32.010 --> 37:33.010
仓库

37:33.010 --> 37:34.010
然后呢

37:34.010 --> 37:35.010
我们这里返回的是什么了

37:35.010 --> 37:36.010
返回的是create stone

37:36.010 --> 37:37.010
就调用它原来的

37:37.010 --> 37:38.010
创建仓库

37:38.010 --> 37:39.010
把参数传进去

37:39.010 --> 37:41.010
这就这么个意思

37:41.010 --> 37:42.010
这个东西倒是

37:42.010 --> 37:43.010
我们没有什么用

37:43.010 --> 37:44.010
但是呢

37:44.010 --> 37:45.010
我们可以把它实现

37:45.010 --> 37:46.010
怎么实现呢

37:46.010 --> 37:48.010
首先在配置这里写一个

37:49.010 --> 37:51.010
extra enhancers

37:53.010 --> 37:55.010
如果说你给我传递的

37:55.010 --> 37:56.010
那就是用你传递的

37:56.010 --> 37:57.010
如果说你没有传递

37:57.010 --> 37:58.010
我就是一个空数组

37:59.010 --> 38:00.010
这个东西实现

38:00.010 --> 38:02.010
也特别特别绕了

38:02.010 --> 38:03.010
它要用到

38:03.010 --> 38:05.010
就跟我们之前那个compose

38:05.010 --> 38:06.010
是一样的

38:06.010 --> 38:07.010
跟以前我们讲的

38:07.010 --> 38:09.010
就是rotor redux

38:09.010 --> 38:10.010
就是redux的时候

38:10.010 --> 38:12.010
分析redux原码的时候

38:13.010 --> 38:15.010
那个compose寒数是一样的

38:15.010 --> 38:17.010
它是一个累计的合并

38:18.010 --> 38:19.010
也就是说我们之后

38:19.010 --> 38:20.010
创建仓库

38:20.010 --> 38:25.010
就不再直接用

38:25.010 --> 38:26.010
而怎么来创建呢

38:26.010 --> 38:28.010
我们要得到一个新的寒数

38:28.010 --> 38:30.010
这个就是new crazy stone

38:31.010 --> 38:33.010
要用这个新的寒数来创建仓库

38:34.010 --> 38:36.010
那么这个新的寒数怎么来的呢

38:36.010 --> 38:37.010
问题是

38:37.010 --> 38:38.010
它是这样来的

38:38.010 --> 38:39.010
来自于options里边

38:39.010 --> 38:41.010
extra enhancers

38:42.010 --> 38:44.010
然后这里用一个reduce

38:44.010 --> 38:45.010
因为它是个数组

38:45.010 --> 38:47.010
数组是不是有reduce

38:47.010 --> 38:49.010
reduce是用累计

38:49.010 --> 38:51.010
这里特别造

38:51.010 --> 38:53.010
这里没有非常深厚的成品工地

38:53.010 --> 38:55.010
根本就听不懂这个玩意

38:55.010 --> 38:57.010
它的默认值是crazy stone

38:57.010 --> 38:58.010
什么意思呢

38:58.010 --> 38:59.010
就是做累计

38:59.010 --> 39:02.010
先把crazy stone传给fne

39:02.010 --> 39:04.010
先把它传给fne

39:04.010 --> 39:05.010
就是我们的窗户创建函数

39:05.010 --> 39:07.010
就到fne

39:07.010 --> 39:09.010
然后我要返回一个新的

39:09.010 --> 39:10.010
窗户创建函数

39:10.010 --> 39:12.010
那么新的窗户创建函数

39:12.010 --> 39:13.010
哪来了

39:13.010 --> 39:15.010
利用这个数组里边的fn2

39:16.010 --> 39:18.010
返回这个数组的fn2

39:18.010 --> 39:21.010
始终把数组后移向

39:21.010 --> 39:22.010
调用了结果

39:22.010 --> 39:24.010
作为新的窗户创建函数

39:24.010 --> 39:25.010
始终把这个数组

39:25.010 --> 39:28.010
后移向这个函数的返回结果

39:28.010 --> 39:30.010
作为新的窗户创建函数

39:30.010 --> 39:32.010
然后再累计到fne里边

39:32.010 --> 39:34.010
把fne传进去

39:34.010 --> 39:35.010
对吧

39:35.010 --> 39:37.010
实际上是这么写的

39:37.010 --> 39:38.010
就完了

39:38.010 --> 39:39.010
就写完了

39:39.010 --> 39:40.010
虽然单码不多

39:40.010 --> 39:41.010
但是特别造

39:41.010 --> 39:42.010
都是一个累计

39:42.010 --> 39:44.010
跟锐大格式里边的compose

39:44.010 --> 39:46.010
是一样的

39:46.010 --> 39:50.010
就是我始终把数组后边的那一项

39:50.010 --> 39:52.010
调用数组后边的那一项

39:52.010 --> 39:54.010
始终是先超中的调用数组

39:54.010 --> 39:55.010
后边的那一项

39:55.010 --> 39:57.010
把前边那一项的结果

39:57.010 --> 39:59.010
给你传进去

39:59.010 --> 40:01.010
明白这个意思吗

40:01.010 --> 40:02.010
然后你看

40:02.010 --> 40:03.010
你看比方数组只有一项

40:03.010 --> 40:04.010
一项的话

40:04.010 --> 40:06.010
就是原来传进了一个quate stone

40:06.010 --> 40:08.010
然后我返回一个新的quate stone

40:08.010 --> 40:09.010
那么最终就返回到

40:09.010 --> 40:10.010
保留在这了

40:10.010 --> 40:11.010
如果数组有两项

40:11.010 --> 40:13.010
那么第一次返回了quate stone

40:13.010 --> 40:15.010
第一次返回了quate stone

40:15.010 --> 40:16.010
又要传进去

40:16.010 --> 40:18.010
像后边那个函数

40:18.010 --> 40:19.010
后边那个函数

40:19.010 --> 40:20.010
那么后边的函数

40:20.010 --> 40:21.010
又要重新一个封装一次

40:21.010 --> 40:23.010
就这么个意思

40:23.010 --> 40:24.010
保存

40:24.010 --> 40:26.010
那里看一下

40:26.010 --> 40:28.010
即将创建仓库是不会运行的

40:28.010 --> 40:29.010
对吧

40:29.010 --> 40:30.010
那么至此

40:30.010 --> 40:32.010
咱们的dba原码

40:32.010 --> 40:34.010
就全部分析完了

40:34.010 --> 40:35.010
我们现在实现了

40:35.010 --> 40:36.010
dba里面的所有功能

40:36.010 --> 40:37.010
全部都实现了

40:37.010 --> 40:38.010
但是还是有一些

40:38.010 --> 40:39.010
细致默契的东西

40:39.010 --> 40:40.010
我们没有去做考虑

40:40.010 --> 40:41.010
比方说什么验证

40:41.010 --> 40:43.010
一些错误的参数判断

40:43.010 --> 40:44.010
这些东西

40:44.010 --> 40:46.010
但是主要的核心功能

40:46.010 --> 40:47.010
全部实现了

40:47.010 --> 40:49.010
而且都可能正常运行

40:49.010 --> 40:50.010
说分析原码

40:50.010 --> 40:51.010
其实这一块

40:51.010 --> 40:53.010
不是为了与分析原码

40:53.010 --> 40:54.010
而去分析原码

40:54.010 --> 40:55.010
而是要通过原码

40:55.010 --> 40:57.010
去理解那些底层

40:57.010 --> 40:58.010
是怎么写的

40:58.010 --> 40:59.010
所以大家可以

40:59.010 --> 41:01.010
至少可以体会到这一点

41:01.010 --> 41:03.010
底层真的不好写

41:03.010 --> 41:04.010
真的不好写

41:04.010 --> 41:05.010
没有深厚的程序工地

41:05.010 --> 41:07.010
是写不出来的

41:07.010 --> 41:08.010
这也是我们课程里面

41:08.010 --> 41:10.010
为什么要去加这些原码分析

41:10.010 --> 41:12.010
而且把它做的就是扩展课程

41:12.010 --> 41:13.010
我不希望初学者

41:13.010 --> 41:14.010
能够去听这些东西

41:14.010 --> 41:16.010
会把初学者吓跑的

41:16.010 --> 41:17.010
真的吧

41:17.010 --> 41:18.010
要把你吓坏了

41:18.010 --> 41:20.010
但是你如果工作了一两年

41:20.010 --> 41:22.010
你对那些表层的东西

41:22.010 --> 41:24.010
都已经理解得非常透彻了

41:24.010 --> 41:26.010
表示也应用得非常熟练了

41:26.010 --> 41:28.010
不说理解的透彻吧

41:28.010 --> 41:29.010
至少应用得非常熟练了

41:29.010 --> 41:31.010
那么你可能想追求更深的东西

41:31.010 --> 41:33.010
那么这些就是更深的东西

41:33.010 --> 41:35.010
原码分析

41:35.010 --> 41:36.010
好吧

41:36.010 --> 41:37.010
那么支持了

41:37.010 --> 41:38.010
底棒的原码就分析到这了

41:38.010 --> 41:40.010
后边还有个底棒中间键

41:40.010 --> 41:41.010
中间键的原码

41:41.010 --> 41:42.010
就特别简单了

41:42.010 --> 41:44.010
如果说你能够真正的

41:44.010 --> 41:45.010
我觉得能够真正的把这些原码

41:45.010 --> 41:47.010
全部伺候的同学肯定不多

41:47.010 --> 41:48.010
肯定很少

41:48.010 --> 41:50.010
能够理解多少理解多少吧

41:50.010 --> 41:52.010
这个东西反正对你们没有坏处的

41:52.010 --> 41:55.010
你要说全部理解对你们有多少

41:55.010 --> 41:57.010
一下子可以让你们

41:57.010 --> 41:58.010
薪水待遇提高多少呢

41:58.010 --> 41:59.010
我觉得也不至于

41:59.010 --> 42:01.010
但是你可以让你对技术的理解

42:01.010 --> 42:03.010
深度产生一个质德变化

42:03.010 --> 42:04.010
这是一个

42:04.010 --> 42:06.010
这个质德变化是慢慢发生的

42:06.010 --> 42:08.010
是常年累月积累

42:08.010 --> 42:09.010
过后发生的

42:09.010 --> 42:11.010
当真正完成质德变化的时候

42:11.010 --> 42:13.010
你当然可以真正的去

42:13.010 --> 42:15.010
开发一个底层的应用的

42:15.010 --> 42:16.010
底层的框架

42:16.010 --> 42:17.010
底层的模块的时候

42:17.010 --> 42:19.010
你会发现你的待遇

42:19.010 --> 42:20.010
称称称就往上涨了

42:20.010 --> 42:23.010
因为以前的普通的开发

42:23.010 --> 42:26.010
普通的开发者肯定是两把手

42:26.010 --> 42:27.010
好吧

42:27.010 --> 42:29.010
这是关于地瓦的原码部分

