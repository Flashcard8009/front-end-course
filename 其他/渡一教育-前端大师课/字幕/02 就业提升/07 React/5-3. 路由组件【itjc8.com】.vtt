WEBVTT

00:01.010 --> 00:08.610
好 这节课咱们就开始正式的来学习rexrotor里边的代码知识了

00:08.610 --> 00:10.210
就它里边的API

00:10.210 --> 00:12.210
反而是一道API的东西呢

00:12.210 --> 00:15.010
我确实我个人觉得的话都非常简单

00:15.010 --> 00:19.810
真正的复杂的是它的原理

00:19.810 --> 00:23.010
说API东西其实是非常简单的

00:23.010 --> 00:25.810
有了上一节课的知识作为基础之后

00:25.810 --> 00:28.010
学习这一部分就非常轻松了

00:29.010 --> 00:39.010
在rexrotor中 它给我们提供了两个非常非常实用的组件

00:39.010 --> 00:42.010
当然我们后边还会学习更多的组件

00:42.010 --> 00:44.010
因为它是基于rex来写的

00:44.010 --> 00:48.010
所以说它肯定是用组件的方式来给我们提供的功能

00:48.010 --> 00:55.010
两个实用的组件为我们提供了两个重要组件

00:55.010 --> 00:57.010
我们要实现路由

00:57.010 --> 01:01.010
就是根据地址来完成不同的组件显示

01:01.010 --> 01:03.010
我们都会用到它提供的这两个组件

01:03.010 --> 01:08.010
第一个组件叫做rotor组件

01:08.010 --> 01:11.010
另外一个组件叫做rot组件

01:11.010 --> 01:13.010
你看这两个单词非常相同 非常相似

01:13.010 --> 01:17.010
一个是rotor 叫做路由器

01:17.010 --> 01:20.010
你要真让我翻译我也不知道怎么翻译

01:20.010 --> 01:21.010
就把它叫做路由器

01:21.010 --> 01:24.010
跟我们现实生活用路由器的两把事

01:24.010 --> 01:27.010
rot就把它叫做路由

01:27.010 --> 01:29.010
不用去纠结这个玩意

01:29.010 --> 01:32.010
我们把它叫做rotor组件和rot组件

01:32.010 --> 01:34.010
对我们提供的这两个

01:34.010 --> 01:35.010
我们一个个来说

01:35.010 --> 01:38.010
首先是说rotor组件

01:38.010 --> 01:41.010
如果说单读使用这个组件

01:41.010 --> 01:43.010
或者说单读使用这个组件的话

01:43.010 --> 01:44.010
没啥用

01:44.010 --> 01:46.010
他们两个是组合起来使用的

01:46.010 --> 01:48.010
我们一个个说先说rotor组件

01:48.010 --> 01:50.010
它用于做什么呢

01:50.010 --> 01:52.010
它不做任何显示

01:52.010 --> 01:56.320
任何展示 它本身不做任何展示

01:58.320 --> 02:03.320
仅提供路由模式配置

02:03.320 --> 02:06.320
就是你用的是哈西模式

02:06.320 --> 02:07.320
我们上几课学的

02:07.320 --> 02:09.320
还是用的是history模式

02:09.320 --> 02:10.320
对吧

02:10.320 --> 02:12.320
仅提供这两种

02:12.320 --> 02:14.320
只提供路由模式配置

02:14.320 --> 02:17.320
另外呢

02:17.320 --> 02:20.320
另外该组件

02:20.320 --> 02:24.320
会产生一个上下文

02:24.320 --> 02:26.320
我们之前学过rex上下文

02:26.320 --> 02:28.320
它会产生一个上下文

02:28.320 --> 02:33.320
上下文中会提供一些使用的

02:33.320 --> 02:37.320
使用的对象和方法

02:37.320 --> 02:44.320
共其他相关组件使用

02:44.320 --> 02:45.320
它会有这么一个特点

02:45.320 --> 02:46.320
它会提供一个上下文

02:46.320 --> 02:48.320
这才是它最重要的东西

02:48.320 --> 02:49.320
那么

02:49.320 --> 02:50.320
上下文呢

02:50.320 --> 02:51.320
它里面存了一些数据

02:51.320 --> 02:52.320
一些方法

02:52.320 --> 02:55.320
那么会提供给其他的组件来使用

02:55.320 --> 02:57.320
主要是做这么一个目的

02:57.320 --> 02:59.320
这是关于rotor组件

02:59.320 --> 03:00.320
rotor组件呢

03:00.320 --> 03:03.320
其实在rex rotor里边

03:03.320 --> 03:05.320
它给我们提供了两种

03:05.320 --> 03:07.320
一种呢是

03:07.320 --> 03:09.320
叫做哈西rotor

03:09.320 --> 03:11.320
顾名思义

03:11.320 --> 03:17.320
该组件的使用哈西模式

03:17.320 --> 03:22.320
哈西模式匹配

03:22.320 --> 03:24.320
使用哈西模式进行匹配

03:24.320 --> 03:26.320
另外一个组件呢

03:26.320 --> 03:29.320
叫做browser rotor

03:29.320 --> 03:30.320
这个组件呢

03:30.320 --> 03:33.320
该组件使用

03:33.320 --> 03:35.320
叫做

03:35.320 --> 03:37.320
它使用什么

03:37.320 --> 03:43.320
使用history browser history

03:43.320 --> 03:44.320
模式匹配

03:44.320 --> 03:47.320
就它会提供了这么两个组件

03:47.320 --> 03:48.320
这个两个组件呢

03:48.320 --> 03:50.320
它分别使用两种模式

03:50.320 --> 03:51.320
ok 咱们来看一下吧

03:51.320 --> 03:52.320
看一下啊

03:52.320 --> 03:53.320
这里呢

03:53.320 --> 03:55.320
我们导入 import

03:55.320 --> 03:56.320
从哪里导入呢

03:56.320 --> 03:57.320
我们安装那个

03:57.320 --> 03:59.320
cool叫做rex

03:59.320 --> 04:00.320
rotor dome

04:00.320 --> 04:01.320
对不对

04:01.320 --> 04:02.320
从这个cool里边导入什么呢

04:02.320 --> 04:05.320
比方说咱们导入一个哈西rotor

04:05.320 --> 04:07.320
哈西rotor

04:07.320 --> 04:08.320
导入这么个东西

04:08.320 --> 04:09.320
然后呢

04:09.320 --> 04:11.320
我们把这个组件呢

04:11.320 --> 04:12.320
套在哪呢

04:12.320 --> 04:13.320
放在哪呢

04:13.320 --> 04:14.320
一般情况下啊

04:14.320 --> 04:15.320
我们把这个组件呢

04:15.320 --> 04:18.320
放到跟组件里边

04:18.320 --> 04:21.320
就说通常情况下

04:21.320 --> 04:24.320
通常情况下

04:24.320 --> 04:26.320
rotor 组件

04:26.320 --> 04:27.320
只有一个啊

04:27.320 --> 04:31.320
只有一个

04:31.320 --> 04:33.320
将该组件

04:33.320 --> 04:36.320
包裹整个

04:36.320 --> 04:37.320
页面

04:37.320 --> 04:39.320
把整个页面包裹起来

04:39.320 --> 04:40.320
就像那有这个div

04:40.320 --> 04:41.320
一个容器一样

04:41.320 --> 04:42.320
那么这里呢

04:42.320 --> 04:43.320
还要提供上下纹

04:43.320 --> 04:45.320
如果说你不把它提升的

04:45.320 --> 04:46.320
很高的级别的话

04:46.320 --> 04:47.320
那么后边

04:47.320 --> 04:48.320
如果使用了

04:48.320 --> 04:50.320
这个路由的其他组件的话

04:50.320 --> 04:51.320
它或许不到上上下纹

04:51.320 --> 04:52.320
那肯定要出问题

04:52.320 --> 04:53.320
说说我们一般的情况下呢

04:53.320 --> 04:54.320
反正它就不做显示

04:54.320 --> 04:55.320
无所谓嘛

04:55.320 --> 04:58.320
我们就把它提到最顶部

04:58.320 --> 04:59.320
提到这

04:59.320 --> 05:03.320
哈西rotor

05:03.320 --> 05:04.320
好

05:04.320 --> 05:05.320
这里呢

05:05.320 --> 05:06.320
里边写上

05:06.320 --> 05:07.320
随便写个啊

05:07.320 --> 05:08.320
这个写不写的无所谓

05:08.320 --> 05:09.320
好

05:09.320 --> 05:10.320
咱们来看一下吧

05:10.320 --> 05:11.320
哈西rotor

05:12.320 --> 05:13.320
这里

05:13.320 --> 05:14.320
你看到没

05:14.320 --> 05:15.320
当我们使用了哈西rotor之后呢

05:15.320 --> 05:17.320
由于它使用的是哈西模式

05:17.320 --> 05:19.320
你看那个地址是不是发生变化了

05:19.320 --> 05:21.320
你看那个地址

05:21.320 --> 05:22.320
它变成这个地址

05:22.320 --> 05:24.320
它为什么加那个锦号

05:24.320 --> 05:25.320
因为它使用的是哈西

05:25.320 --> 05:26.320
对吧

05:26.320 --> 05:27.320
它使用的是哈西

05:27.320 --> 05:28.320
那么哈

05:28.320 --> 05:29.320
使用哈西的时候呢

05:29.320 --> 05:30.320
你

05:30.320 --> 05:31.320
它读的是什么

05:31.320 --> 05:32.320
哈西后

05:32.320 --> 05:33.320
就是哈西的指

05:33.320 --> 05:34.320
就锦号后边的指

05:34.320 --> 05:35.320
用锦号后边的指

05:35.320 --> 05:37.320
来决定要显示哪个组件

05:37.320 --> 05:38.320
当然我们现在还没有配置

05:38.320 --> 05:39.320
怎么来显示

05:39.320 --> 05:41.320
怎么根据不同的地址来显示组件

05:41.320 --> 05:42.320
还没有配置

05:42.320 --> 05:43.320
以后我们再配置

05:43.320 --> 05:44.320
但是你会发现

05:44.320 --> 05:45.320
它已经出现了哈西了

05:45.320 --> 05:46.320
对吧

05:46.320 --> 05:47.320
所以说使用了哈西组件过后呢

05:47.320 --> 05:48.320
它一定会出现哈西

05:48.320 --> 05:50.320
因为它前面的指对它来说

05:50.320 --> 05:51.320
不重要

05:51.320 --> 05:52.320
一点都不重要

05:52.320 --> 05:53.320
重要的是哈西后边的指

05:53.320 --> 05:55.320
重要的是哈西

05:55.320 --> 05:56.320
因为前面路径这里

05:56.320 --> 05:57.320
随便咋写

05:57.320 --> 05:58.320
不重要

05:58.320 --> 05:59.320
跟我们没啥关系

05:59.320 --> 06:00.320
它重要的是哈西后边的指

06:00.320 --> 06:02.320
就是它会出现这个哈西

06:02.320 --> 06:04.320
这就是哈西模式

06:04.320 --> 06:05.320
看到没

06:05.320 --> 06:06.320
然后我们再看一下

06:06.320 --> 06:08.320
这个rex这个节点

06:08.320 --> 06:10.320
我们的根节点app里边

06:10.320 --> 06:11.320
它有个哈西rotor

06:11.320 --> 06:12.320
对吧

06:12.320 --> 06:13.320
我们刚才使用了那个玩意儿

06:13.320 --> 06:14.320
那个组件

06:14.320 --> 06:15.320
那么哈西rotor里边

06:15.320 --> 06:16.320
我们再展开

06:16.320 --> 06:18.320
它是不是使用了一个rotor组件

06:18.320 --> 06:21.320
这个哈西rotor是谁给我们的呢

06:21.320 --> 06:23.320
这个哈西rotor是这个裤

06:23.320 --> 06:25.320
rexrotor dom这个裤给我们的

06:25.320 --> 06:27.320
那么这个rotor组件

06:27.320 --> 06:28.320
是谁给我们的呢

06:28.320 --> 06:29.320
这个rotor组件

06:29.320 --> 06:30.320
是这个

06:30.320 --> 06:31.320
我们之前说过

06:31.320 --> 06:32.320
一个核心裤

06:32.320 --> 06:33.320
对吧

06:33.320 --> 06:34.320
rexrotor这个核心裤

06:34.320 --> 06:35.320
是这个核心裤给我们的

06:35.320 --> 06:37.320
那么这个核心裤

06:37.320 --> 06:39.320
真正的实现了提供上下文的功能

06:39.320 --> 06:41.320
真正实现了这个功能

06:41.320 --> 06:42.320
我们展开一下

06:42.320 --> 06:43.320
你看一下

06:43.320 --> 06:44.320
是不是提供了一个上下文

06:44.320 --> 06:45.320
对吧

06:45.320 --> 06:46.320
它自己创建的一个上下文

06:46.320 --> 06:47.320
叫做rotor

06:47.320 --> 06:49.320
rotor里边有个什么provider

06:49.320 --> 06:50.320
provider

06:50.320 --> 06:51.320
就是

06:51.320 --> 06:53.320
上下文的一个提供程序

06:53.320 --> 06:54.320
那么这上下文里边

06:54.320 --> 06:55.320
是一个value

06:55.320 --> 06:56.320
对吧

06:56.320 --> 06:57.320
一个value

06:57.320 --> 06:58.320
value里边

06:58.320 --> 06:59.320
是不是上下文的值

06:59.320 --> 07:00.320
对不对

07:00.320 --> 07:01.320
这个上下文

07:01.320 --> 07:02.320
我们是访问不到的

07:02.320 --> 07:03.320
它是给你诗诱化的

07:03.320 --> 07:04.320
我们访问不到的

07:04.320 --> 07:05.320
但是它的一些

07:05.320 --> 07:06.320
后面的组件

07:06.320 --> 07:08.320
就是我们学习rexrotor里边

07:08.320 --> 07:09.320
它提供了很多组件

07:09.320 --> 07:10.320
很多组件

07:10.320 --> 07:11.320
它都会用到的上下文

07:11.320 --> 07:12.320
它内部会使用

07:12.320 --> 07:14.320
我们是不能让我们直接访问的

07:14.320 --> 07:16.320
那么它这里边提供了一些

07:16.320 --> 07:17.320
使用的东西

07:17.320 --> 07:18.320
非常使用的东西

07:18.320 --> 07:19.320
有些对象

07:19.320 --> 07:20.320
history对象

07:20.320 --> 07:21.320
当然这个history对象

07:21.320 --> 07:22.320
跟我们

07:22.320 --> 07:23.320
之前看到那个

07:23.320 --> 07:25.320
原生的GS里边的history

07:25.320 --> 07:27.320
是有区别的

07:27.320 --> 07:28.320
是有区别的

07:28.320 --> 07:29.320
我们这里只是说

07:29.320 --> 07:30.320
有这个对象

07:30.320 --> 07:31.320
它给你自己做了个对象

07:31.320 --> 07:32.320
还有一个location

07:32.320 --> 07:33.320
location跟我们

07:33.320 --> 07:35.320
学习原生的GS里边的location

07:35.320 --> 07:36.320
location也是有区别的

07:36.320 --> 07:37.320
不一样的

07:37.320 --> 07:38.320
它重新给你封装了

07:38.320 --> 07:40.320
只不过名字叫这个名字

07:40.320 --> 07:42.320
那么还有个什么march

07:42.320 --> 07:43.320
march

07:43.320 --> 07:44.320
我们后边会挨在的说

07:44.320 --> 07:46.320
这里边上下文的数据

07:46.320 --> 07:47.320
怎么来获取

07:47.320 --> 07:49.320
以及怎么来使用

07:49.320 --> 07:51.320
现在我们只需要知道

07:51.320 --> 07:53.320
它给我们提供了一个上下文

07:53.320 --> 07:54.320
这个上下文里边

07:54.320 --> 07:56.320
提供了一些非常重要的信息

07:56.320 --> 07:57.320
这些信息

07:57.320 --> 07:58.320
后边它做了很多组件

07:58.320 --> 07:59.320
那么后续的组件

07:59.320 --> 08:01.320
要使用这些上下文的信息

08:01.320 --> 08:02.320
对吧

08:02.320 --> 08:04.320
我们之前好像做过类似的东西

08:04.320 --> 08:06.320
说表达那一块

08:06.320 --> 08:07.320
我们就用到了

08:07.320 --> 08:09.320
这种上下文的方式

08:09.320 --> 08:11.320
就形成了这么一种结构了

08:11.320 --> 08:12.320
其实我们评价开发的时候

08:12.320 --> 08:14.320
也不用太过于

08:14.320 --> 08:17.320
关心它的结构是什么样子

08:17.320 --> 08:18.320
但是我们实际上

08:18.320 --> 08:19.320
实际心里面要知道

08:19.320 --> 08:21.320
它给你提供了一个上下文

08:21.320 --> 08:23.320
这是这个组件做的事情

08:23.320 --> 08:25.320
所以说这个rotor组件

08:25.320 --> 08:27.320
它要么就是哈希rotor

08:27.320 --> 08:29.320
要么就是brotherrotor

08:29.320 --> 08:30.320
只有可能是这种

08:30.320 --> 08:31.320
或者是这种

08:31.320 --> 08:33.320
我们刚才看到了哈希rotor

08:33.320 --> 08:34.320
我们之前也说

08:34.320 --> 08:35.320
哈希rotor

08:35.320 --> 08:36.320
我们在实际开发中

08:36.320 --> 08:37.320
可能用的不多

08:37.320 --> 08:40.320
除非对兼容性要求非常高的地方

08:40.320 --> 08:42.320
我们会用哈希rotor

08:42.320 --> 08:43.320
绝大部分时候

08:43.320 --> 08:44.320
我们用的是什么呢

08:44.320 --> 08:46.320
browserrotor

08:46.320 --> 08:48.320
用的是这个

08:48.320 --> 08:49.320
browserrotor

08:49.320 --> 08:50.320
保存

08:50.320 --> 08:52.320
你看其实是一样的

08:52.320 --> 08:54.320
只是模式有区别而已

08:54.320 --> 08:56.320
其实最终的结构是一样的

08:56.320 --> 08:58.320
最终的结构都是一样

08:58.320 --> 09:00.320
这个结构也是完全一样

09:00.320 --> 09:01.320
那么现在

09:01.320 --> 09:02.320
它用的就不是哈希了

09:02.320 --> 09:04.320
跟哈希没有啥关系了

09:04.320 --> 09:06.320
你看现在是不是没有给你加上哈希

09:06.320 --> 09:08.320
没有加上哈希吧

09:08.320 --> 09:11.320
它是用什么匹配

09:11.320 --> 09:13.320
是不是用路径来匹配

09:13.320 --> 09:14.320
用路径来匹配的

09:14.320 --> 09:15.320
所以说它不需要哈希

09:15.320 --> 09:16.320
但是你加了哈希

09:16.320 --> 09:18.320
对它来说没有什么关系

09:18.320 --> 09:20.320
跟它没有任何关系

09:20.320 --> 09:21.320
好

09:21.320 --> 09:22.320
很多时候我们

09:22.320 --> 09:24.320
为了方便书写

09:24.320 --> 09:26.320
或者说有一种习惯

09:26.320 --> 09:27.320
习惯上

09:27.320 --> 09:29.320
会给它命一个别名

09:30.320 --> 09:31.320
命个别名

09:31.320 --> 09:33.320
把它命名成rotor

09:33.320 --> 09:34.320
它这

09:34.320 --> 09:35.320
又啥区别呢

09:35.320 --> 09:36.320
是不是没区别

09:36.320 --> 09:37.320
没有任何区别

09:37.320 --> 09:39.320
只是给它命个别名而已

09:39.320 --> 09:40.320
那么它到时候元素结构里面

09:40.320 --> 09:42.320
还是使用的browserrotor

09:42.320 --> 09:44.320
跟它的组件名是一样的

09:44.320 --> 09:45.320
这是关于

09:45.320 --> 09:47.320
rotor组件

09:47.320 --> 09:48.320
rotor组件

09:48.320 --> 09:49.320
它有两种

09:49.320 --> 09:50.320
一号是哈希rotor

09:50.320 --> 09:51.320
M是browserrotor

09:51.320 --> 09:52.320
它的主要作用

09:52.320 --> 09:55.320
只是用来提供一个上下文

09:55.320 --> 09:56.320
用不同的组件

09:56.320 --> 09:58.320
它用的是不同的模式

09:58.320 --> 09:59.320
这是rotor组件

09:59.320 --> 10:00.320
接下来

10:00.320 --> 10:01.320
终点是在这个组件

10:01.320 --> 10:03.320
rotor组件其实没啥说的

10:03.320 --> 10:04.320
它里面还有一些属性

10:04.320 --> 10:06.320
我们将来遇到的时候再说

10:06.320 --> 10:07.320
现在终点是在这个属性

10:07.320 --> 10:08.320
这个组件

10:08.320 --> 10:09.320
rotor组件

10:09.320 --> 10:11.320
这个组件才是核心

10:11.320 --> 10:12.320
但是呢

10:12.320 --> 10:14.320
如果说没有rotor组件

10:14.320 --> 10:16.320
作为给它的上下文

10:16.320 --> 10:17.320
提供支持的话

10:17.320 --> 10:18.320
那么后边的这个组件

10:18.320 --> 10:19.320
肯定用的没法用

10:19.320 --> 10:22.320
所以说我们必须得有一个rotor组件

10:22.320 --> 10:24.320
必须得有这么一个玩意儿

10:24.320 --> 10:25.320
然后再说

10:25.320 --> 10:26.320
后边的组件

10:26.320 --> 10:27.320
rotor组件

10:27.320 --> 10:29.320
这个组件用做什么呢

10:29.320 --> 10:33.320
它是根据不同的地址

10:33.320 --> 10:36.320
展示不同的组件

10:36.320 --> 10:39.320
这个地址到底来自于哈希

10:39.320 --> 10:42.320
还是来自于路径

10:42.320 --> 10:44.320
比方说我们一个地址

10:44.320 --> 10:47.320
abc

10:47.320 --> 10:49.320
它到底是来自于这一部分

10:49.320 --> 10:52.320
还是说来自于这一部分

10:52.320 --> 10:54.320
那就取决于什么

10:54.320 --> 10:57.320
取决于这个rotor组件

10:57.320 --> 10:59.320
它到底是browser rotor

10:59.320 --> 11:00.320
还是哈希rotor

11:00.320 --> 11:01.320
对吧

11:01.320 --> 11:02.320
所以说这个东西提供一个

11:02.320 --> 11:03.320
上下文的支持

11:03.320 --> 11:05.320
相当于是个整个环境的配置

11:05.320 --> 11:07.320
那么具体到每一个

11:07.320 --> 11:08.320
每一个地方

11:08.320 --> 11:09.320
根据不同的地址

11:09.320 --> 11:11.320
展示不同的组件的话

11:11.320 --> 11:13.320
那么要用到这个rotor组件

11:13.320 --> 11:14.320
好

11:14.320 --> 11:16.320
那么这个组件怎么去使用呢

11:16.320 --> 11:18.320
大家看一下代码

11:18.320 --> 11:20.320
我们再导入一个组件

11:20.320 --> 11:21.320
在这里边

11:21.320 --> 11:23.320
又提供了一个rotor组件

11:23.320 --> 11:24.320
好

11:24.320 --> 11:25.320
这个组件

11:25.320 --> 11:26.320
我们比方说

11:26.320 --> 11:27.320
写个例子

11:27.320 --> 11:29.320
这里边

11:29.320 --> 11:32.320
我们写上一个function

11:32.320 --> 11:34.320
a

11:34.320 --> 11:36.320
返回

11:36.320 --> 11:38.320
这是组件a

11:38.320 --> 11:40.630
好

11:40.630 --> 11:43.630
function b

11:43.630 --> 11:45.630
这是组件

11:45.630 --> 11:47.630
组件b

11:47.630 --> 11:50.630
然后再来一个function c

11:50.630 --> 11:52.630
return h

11:52.630 --> 11:54.630
这是组件c

11:54.630 --> 11:55.630
OK

11:55.630 --> 11:57.630
我们这里写了三个组件

11:57.630 --> 11:58.630
接下来我们要做什么呢

11:58.630 --> 12:02.630
我们希望访问这个地址的时候

12:02.630 --> 12:03.630
访问什么地址呢

12:03.630 --> 12:04.630
访问斜纲

12:04.630 --> 12:07.630
根部路下面的

12:07.630 --> 12:09.630
访问这个地址的时候

12:09.630 --> 12:11.630
显示这个组件

12:11.630 --> 12:16.900
访问这个地址的时候

12:16.900 --> 12:17.900
访问这个地址的时候

12:17.900 --> 12:18.900
显示b组件

12:18.900 --> 12:19.900
好

12:19.900 --> 12:20.900
然后访问

12:20.900 --> 12:21.900
这个地址的时候

12:21.900 --> 12:22.900
显示c组件

12:22.900 --> 12:24.900
比方说我们现在要做这么一件事

12:24.900 --> 12:25.900
那怎么在做呢

12:25.900 --> 12:28.900
我们就要依托于这个组件了

12:28.900 --> 12:30.900
这个组件它是这样子写的

12:30.900 --> 12:34.900
就是wrote

12:34.900 --> 12:36.900
然后这个组件里边

12:36.900 --> 12:39.900
有这么两个重要属性

12:39.900 --> 12:43.900
一个是重要属性

12:43.900 --> 12:46.900
一个是pass

12:46.900 --> 12:49.900
就是匹配的路径

12:49.900 --> 12:51.900
你要匹配哪一个路径

12:51.900 --> 12:54.900
第二个是component

12:54.900 --> 12:57.900
就是匹配成功后

12:57.900 --> 12:59.900
要显示的组件

12:59.900 --> 13:01.900
完了 没了

13:01.900 --> 13:04.900
这就是你要做的事情

13:04.900 --> 13:05.900
一个是什么呢

13:05.900 --> 13:09.900
一个是pass路径

13:09.900 --> 13:11.900
路径的话

13:11.900 --> 13:12.900
我们这里写上它了

13:12.900 --> 13:13.900
比方说我们要访问

13:13.900 --> 13:16.900
这个地址的时候

13:16.900 --> 13:17.900
匹配什么组件呢

13:17.900 --> 13:20.900
匹配component

13:21.900 --> 13:23.900
对 component

13:23.900 --> 13:24.900
匹配什么呢

13:24.900 --> 13:25.900
匹配给它一个组件

13:25.900 --> 13:27.900
哪个组件 是不是a组件

13:27.900 --> 13:29.900
对吧 把组件给它传进去

13:29.900 --> 13:30.900
OK

13:30.900 --> 13:31.900
那么当我们访问

13:31.900 --> 13:32.900
这个邪杠a的时候

13:32.900 --> 13:34.900
是不是访问到a组件

13:34.900 --> 13:37.900
保存看一下

13:37.900 --> 13:39.900
于是这里邪杠a

13:39.900 --> 13:40.900
我们访问一下

13:40.900 --> 13:41.900
这个太小了

13:41.900 --> 13:43.900
大家能不能看得清楚

13:43.900 --> 13:44.900
因为我这里

13:44.900 --> 13:47.900
确实不知道该怎么把地址哪放的

13:47.900 --> 13:48.900
我们当我们访问邪杠a的时候

13:48.900 --> 13:50.900
一回车

13:50.900 --> 13:52.900
看一下是不是显色组件a

13:52.900 --> 13:53.900
对吧

13:53.900 --> 13:54.900
是不是显色组件a

13:54.900 --> 13:55.900
就这么简单

13:55.900 --> 13:57.900
我们看一下它的整个write结构

13:57.900 --> 13:58.900
write结构

13:58.900 --> 13:59.900
rot里边

13:59.900 --> 14:00.900
你看这个rot

14:00.900 --> 14:01.900
是一个pass

14:01.900 --> 14:02.900
对吧 给它配置了的

14:02.900 --> 14:03.900
配置了pass的

14:03.900 --> 14:05.900
然后它里边是不是用到上下文

14:05.900 --> 14:06.900
看到没有

14:06.900 --> 14:07.900
rotor什么

14:07.900 --> 14:08.900
consumer

14:08.900 --> 14:09.900
对不对

14:09.900 --> 14:10.900
是不是用了

14:10.900 --> 14:11.900
它在使用上下文里边的东西

14:11.900 --> 14:13.900
说明它肯定用到了上下文

14:13.900 --> 14:15.900
对吧 用到了上下文

14:15.900 --> 14:16.900
好

14:16.900 --> 14:18.900
它又给你掏了一个rotor

14:18.900 --> 14:19.900
rotor provider

14:19.900 --> 14:20.900
这个东西

14:20.900 --> 14:21.900
我们不用管

14:21.900 --> 14:22.900
因为这个上下文

14:22.900 --> 14:24.900
我们是没法直接使用的

14:24.900 --> 14:25.900
因为我们要使用上下文

14:25.900 --> 14:27.900
我们知道必须要获取上下文对象

14:27.900 --> 14:28.900
但是我们没有获取到

14:28.900 --> 14:29.900
所以说

14:29.900 --> 14:30.900
我们这里的

14:30.900 --> 14:31.900
不管它

14:31.900 --> 14:32.900
我们只需要知道

14:32.900 --> 14:34.900
它有提供了这么上下文就行了

14:34.900 --> 14:36.900
最终我们显色这个组件a

14:36.900 --> 14:37.900
对吧

14:37.900 --> 14:38.900
它给掏了很深的一个层次

14:38.900 --> 14:39.900
我觉得

14:39.900 --> 14:40.900
后面

14:40.900 --> 14:42.900
这个write rotor

14:42.900 --> 14:43.900
可能会

14:43.900 --> 14:45.900
我觉得它可能会更新

14:45.900 --> 14:47.900
现在不是后可出来了吗

14:47.900 --> 14:49.900
后可出来了过后

14:49.900 --> 14:51.900
它的结构可以减化很多

14:51.900 --> 14:53.900
它可能会有受更新

14:53.900 --> 14:55.900
我们现在不管它

14:55.900 --> 14:56.900
总之

14:56.900 --> 14:58.900
现在它匹配到这个地址过后

14:58.900 --> 14:59.900
它就会显色组件a

14:59.900 --> 15:00.900
就这么简单

15:00.900 --> 15:01.900
如果说

15:01.900 --> 15:02.900
我们在这里

15:02.900 --> 15:03.900
再写

15:04.900 --> 15:05.900
再写

15:05.900 --> 15:06.900
那么如果说这里写个b

15:06.900 --> 15:07.900
这里写个b

15:07.900 --> 15:08.900
对吧

15:08.900 --> 15:09.900
是不是根据不同的地址

15:09.900 --> 15:10.900
展示不同的组件

15:10.900 --> 15:11.900
对不对

15:11.900 --> 15:12.900
保存

15:12.900 --> 15:13.900
你看一下

15:14.900 --> 15:15.900
现在

15:15.900 --> 15:17.900
由于现在我们访问的是地址

15:17.900 --> 15:18.900
对不对

15:18.900 --> 15:19.900
所以说

15:19.900 --> 15:20.900
得到的结果是啥呢

15:20.900 --> 15:21.900
得到的结果就是

15:21.900 --> 15:22.900
组件a

15:22.900 --> 15:23.900
组件b

15:23.900 --> 15:24.900
对吧

15:24.900 --> 15:26.900
那么由于它是不是没匹配上

15:26.900 --> 15:27.900
于是这个组件

15:27.900 --> 15:28.900
它就是一个普通的组件

15:28.900 --> 15:29.900
给你写好的

15:29.900 --> 15:30.900
当这个组件

15:30.900 --> 15:32.900
没有匹配上这个地址的时候

15:32.900 --> 15:33.900
它就可以想象

15:33.900 --> 15:34.900
它在render里边

15:34.900 --> 15:35.900
那个函数里边

15:35.900 --> 15:36.900
给你返回个啥

15:36.900 --> 15:37.900
返回个nau

15:37.900 --> 15:38.900
如果它说

15:38.900 --> 15:39.900
它没有匹配上的话

15:39.900 --> 15:40.900
它就给你返回个nau

15:40.900 --> 15:41.900
比方说

15:41.900 --> 15:42.900
假設举个地址

15:42.900 --> 15:43.900
举个例子

15:43.900 --> 15:44.900
虽然说我们现在还不

15:44.900 --> 15:45.900
彻底到它的原

15:45.900 --> 15:46.900
那么比方说

15:46.900 --> 15:48.900
这个class

15:48.900 --> 15:49.900
这个rotor组件

15:49.900 --> 15:51.900
它类似于这样子写的

15:51.900 --> 15:53.900
你可以这样子想象吧

15:53.900 --> 15:55.900
我写个伟代

15:55.900 --> 15:57.900
你可以认为它是这样子写的

15:57.900 --> 15:59.900
render

15:59.900 --> 16:00.900
判断

16:00.900 --> 16:03.900
是否匹配

16:03.900 --> 16:04.900
匹配啥

16:04.900 --> 16:05.900
匹配这个z

16:05.900 --> 16:07.900
probs.pass

16:07.900 --> 16:08.900
对吧

16:08.900 --> 16:09.900
这个pass是否匹配

16:09.900 --> 16:10.900
如果匹配了过后

16:10.900 --> 16:11.900
返回啥

16:11.900 --> 16:12.900
返回啥

16:12.900 --> 16:14.900
是不是返回

16:14.900 --> 16:16.900
属性里边的component

16:16.900 --> 16:17.900
对吧

16:17.900 --> 16:19.900
我们拿到

16:19.900 --> 16:21.900
从属性里边解构

16:21.900 --> 16:22.900
解构

16:22.900 --> 16:24.900
或者就重新那边量

16:24.900 --> 16:25.900
有得了

16:25.900 --> 16:26.900
comp

16:26.900 --> 16:27.900
从哪个地方拿到

16:27.900 --> 16:28.900
z

16:28.900 --> 16:29.900
probs

16:29.900 --> 16:30.900
component

16:30.900 --> 16:31.900
从个地方拿到

16:31.900 --> 16:32.900
拿到之后

16:32.900 --> 16:33.900
返回什么了

16:33.900 --> 16:34.900
返回comp

16:34.900 --> 16:35.900
对吧

16:35.900 --> 16:37.900
它就这样子写

16:37.900 --> 16:38.900
好

16:38.900 --> 16:39.900
如果说没有匹配的话

16:39.900 --> 16:40.900
返回nau

16:40.900 --> 16:41.900
就这样子认为

16:41.900 --> 16:42.900
肉扯逐渐

16:42.900 --> 16:43.900
你可以认为肉扯逐渐

16:43.900 --> 16:44.900
就是这样子写的

16:44.900 --> 16:46.900
非常简单

16:46.900 --> 16:47.900
到时候宣展的时候

16:47.900 --> 16:48.900
宣展它的时候

16:48.900 --> 16:49.900
如果说它匹配了

16:49.900 --> 16:50.900
它就宣展这个逐渐

16:50.900 --> 16:51.900
它就宣展出来就完事了

16:51.900 --> 16:52.900
在宣展它的时候

16:52.900 --> 16:53.900
它没有匹配

16:53.900 --> 16:54.900
它没有匹配

16:54.900 --> 16:55.900
它早就没宣展

16:55.900 --> 16:56.900
宣展它的时候

16:56.900 --> 16:57.900
它早就没匹配

16:57.900 --> 16:58.900
它早就没宣展

16:58.900 --> 16:59.900
就这么简单

16:59.900 --> 17:00.900
完了

17:00.900 --> 17:01.900
没了

17:01.900 --> 17:02.900
能不要对意思

17:02.900 --> 17:03.900
没问题吧

17:03.900 --> 17:04.900
好

17:04.900 --> 17:05.900
接下来再看一下

17:05.900 --> 17:06.900
如果说

17:06.900 --> 17:07.900
我们访问的是

17:07.900 --> 17:08.900
地址b

17:08.900 --> 17:09.900
你看一下

17:09.900 --> 17:10.900
访问地址c

17:10.900 --> 17:11.900
就是谁逐渐

17:12.900 --> 17:13.900
那如果说我们地址

17:13.900 --> 17:14.900
啥都没写了

17:14.900 --> 17:15.900
又不是a

17:15.900 --> 17:16.900
又不是b

17:16.900 --> 17:17.900
又不是c

17:17.900 --> 17:18.900
啥都没显示

17:18.900 --> 17:19.900
它没有匹配

17:19.900 --> 17:20.900
它自然没发宣展

17:20.900 --> 17:22.900
没有匹配就没发宣展

17:22.900 --> 17:23.900
对不对

17:23.900 --> 17:24.900
这就完事了

17:24.900 --> 17:25.900
就这么简单

17:25.900 --> 17:27.900
就这么简单

17:27.900 --> 17:28.900
明白这个意思吧

17:28.900 --> 17:30.900
应该明白这个意思

17:30.900 --> 17:31.900
它并不复杂

17:31.900 --> 17:33.900
就是肉扯逐渐

17:33.900 --> 17:34.900
好

17:34.900 --> 17:35.900
那如果说

17:35.900 --> 17:36.900
看一下能不能区分大小写

17:36.900 --> 17:38.900
如果说大写的a

17:38.900 --> 17:39.900
是不是也能匹配

17:39.900 --> 17:40.900
对吧

17:40.900 --> 17:41.900
也能匹配的

17:41.900 --> 17:42.900
没问题吧

17:42.900 --> 17:43.900
好

17:43.900 --> 17:45.900
我们这里把它记一笔

17:45.900 --> 17:46.900
记一笔

17:46.900 --> 17:47.900
就是匹配的路径

17:47.900 --> 17:49.900
默认情况下

17:49.900 --> 17:51.900
默认情况下

17:52.900 --> 17:57.410
不区分大小写

17:57.410 --> 18:00.410
区分大小写

18:00.410 --> 18:03.410
那如果说你要区分大小写

18:03.410 --> 18:04.410
这种情况

18:04.410 --> 18:05.410
几乎是不太可能遇到的

18:05.410 --> 18:06.410
一般来说

18:06.410 --> 18:07.410
我们地址

18:07.410 --> 18:08.410
就是不区分大小写的

18:08.410 --> 18:09.410
如果说

18:09.410 --> 18:10.410
区分大小写的话

18:10.410 --> 18:11.410
可以

18:11.410 --> 18:12.410
可以设置

18:12.410 --> 18:15.410
深色体股

18:15.410 --> 18:17.410
深色体股表示敏感的

18:17.410 --> 18:18.410
大小写敏感的

18:18.410 --> 18:19.410
深色体股

18:19.410 --> 18:20.410
属性

18:20.410 --> 18:22.410
微粗

18:22.410 --> 18:25.410
来区分大小写

18:25.410 --> 18:27.410
比方说

18:27.410 --> 18:28.410
我们这里

18:28.410 --> 18:30.410
给它加上一个属性

18:30.410 --> 18:34.410
深色体股

18:34.410 --> 18:35.410
把它设置为粗

18:35.410 --> 18:36.410
看一下

18:36.410 --> 18:38.410
保存

18:38.410 --> 18:39.410
你看

18:39.410 --> 18:40.410
我们现在访问的是大写的A

18:40.410 --> 18:41.410
那是不是没有显示的

18:41.410 --> 18:42.410
没有任何东西显示

18:42.410 --> 18:44.410
说明它区分大小写

18:44.410 --> 18:45.410
如果是小写的A

18:45.410 --> 18:46.410
那就可以显示的

18:46.410 --> 18:47.410
当然

18:47.410 --> 18:49.410
由于它是一个布尔属性

18:49.410 --> 18:50.410
我们可以直接这样子写

18:50.410 --> 18:51.410
对吧

18:51.410 --> 18:52.410
直接这样子写

18:52.410 --> 18:53.410
我们以前讲过了

18:53.410 --> 18:54.410
那么也是一样

18:56.410 --> 18:57.410
没问题吧

18:57.410 --> 18:59.410
这是关于

18:59.410 --> 19:01.410
Rowt这个组建

19:03.410 --> 19:05.410
有了这个组建之后

19:05.410 --> 19:07.410
咱们就可以

19:07.410 --> 19:09.410
举不同的地址

19:09.410 --> 19:12.410
来展示不同的组建了

19:12.410 --> 19:13.410
但是

19:13.410 --> 19:14.410
这里

19:14.410 --> 19:16.410
在某些场景下

19:16.410 --> 19:19.410
可能还会遇到一些问题

19:19.410 --> 19:20.410
什么问题

19:20.410 --> 19:21.410
比方说

19:21.410 --> 19:23.410
举个地址

19:23.410 --> 19:24.410
如果说

19:24.410 --> 19:26.410
我这个

19:26.410 --> 19:27.410
组建A

19:27.410 --> 19:29.410
它的地址是斜杠A

19:29.410 --> 19:30.410
然后

19:30.410 --> 19:31.410
组建B

19:31.410 --> 19:32.410
它是这样的地址

19:32.410 --> 19:33.410
斜杠A

19:33.410 --> 19:34.410
斜杠B

19:34.410 --> 19:35.410
组建C

19:35.410 --> 19:36.410
它是斜杠A

19:36.410 --> 19:37.410
斜杠C

19:37.410 --> 19:38.410
来看一下

19:38.410 --> 19:39.410
这样子

19:39.410 --> 19:41.410
它会导致一个什么样的结果

19:41.410 --> 19:43.410
如果是这样的规则的话

19:43.410 --> 19:44.410
接下来

19:44.410 --> 19:45.410
我们来看一下

19:45.410 --> 19:47.410
斜杠A

19:47.410 --> 19:48.410
斜杠B

19:48.410 --> 19:49.410
斜杠C

19:49.410 --> 19:50.410
斜杠A

19:50.410 --> 19:51.410
斜杠B

19:51.410 --> 19:52.410
这个斜杠A

19:52.410 --> 19:53.410
斜杠C

19:53.410 --> 19:55.410
比方说是这样的地址

19:55.410 --> 19:56.410
保存

19:56.410 --> 19:57.410
咱们来看一下

19:57.410 --> 19:58.410
当我们访问

19:58.410 --> 19:59.410
斜杠A的时候

19:59.410 --> 20:00.410
没有任何问题

20:00.410 --> 20:01.410
显示的是A组建

20:01.410 --> 20:02.410
为什么

20:02.410 --> 20:03.410
因为只有A组建

20:03.410 --> 20:04.410
才能匹配这个地址

20:04.410 --> 20:05.410
C组建没有匹配上

20:05.410 --> 20:06.410
好

20:06.410 --> 20:07.410
那如果说

20:07.410 --> 20:08.410
我访问的是斜杠A

20:08.410 --> 20:09.410
斜杠B

20:09.410 --> 20:11.410
大家看一下

20:11.410 --> 20:13.410
它两个组建都显示的

20:13.410 --> 20:14.410
也就是说

20:14.410 --> 20:15.410
它的匹配规则

20:15.410 --> 20:16.410
它的匹配规则

20:16.410 --> 20:17.410
跟我们想象的

20:17.410 --> 20:18.410
可能不太一样

20:18.410 --> 20:20.410
它并不是精确匹配

20:20.410 --> 20:22.410
比方说这个组建

20:22.410 --> 20:23.410
这个配置

20:23.410 --> 20:24.410
我们拍视里面

20:24.410 --> 20:25.410
写到一个斜杠A

20:25.410 --> 20:26.410
那么表示什么

20:26.410 --> 20:27.410
只要这个路径

20:27.410 --> 20:29.410
也以斜杠A

20:29.410 --> 20:31.410
这一个

20:31.410 --> 20:32.410
这一个断

20:32.410 --> 20:33.410
开始

20:33.410 --> 20:35.410
这个路径开始

20:35.410 --> 20:36.410
那么我们通常说

20:36.410 --> 20:38.410
这个路径表示的是目录

20:38.410 --> 20:41.410
访问的是跟目录下面的A这个目录

20:41.410 --> 20:43.410
你只要访问的是这个目录

20:43.410 --> 20:45.410
不管后边有多少东西

20:45.410 --> 20:47.410
那么我都能匹配上

20:47.410 --> 20:48.410
那么斜杠B

20:48.410 --> 20:49.410
它什么意思呢

20:49.410 --> 20:50.410
它表示的是

20:50.410 --> 20:52.410
我只要我的访问路径目录

20:52.410 --> 20:53.410
是A

20:53.410 --> 20:55.410
是访问跟目录下面的A这个目录

20:55.410 --> 20:58.410
然后访问了A下面的B这个目录

20:58.410 --> 20:59.410
只要访问这个

20:59.410 --> 21:00.410
只要是满足这个目录的

21:00.410 --> 21:02.410
我都能匹配上

21:02.410 --> 21:03.410
所以说现在的

21:03.410 --> 21:05.410
这两个是不是都匹配了

21:05.410 --> 21:08.410
于是那两个组建都渲染出来了

21:08.410 --> 21:12.410
如果说我在这种路径规则下

21:12.410 --> 21:14.410
仍然要实现

21:14.410 --> 21:16.410
只显示一个组建的话

21:16.410 --> 21:18.410
那么是不是

21:18.410 --> 21:20.410
我们得让它精确匹配

21:20.410 --> 21:21.410
对不对

21:21.410 --> 21:22.410
得让它精确匹配

21:22.410 --> 21:23.410
由于你这里匹配规则

21:23.410 --> 21:25.410
不能太模糊

21:25.410 --> 21:28.410
所以说我们这里记一笔

21:29.410 --> 21:30.410
这里分开说

21:30.410 --> 21:33.720
这是大小写的情况

21:33.720 --> 21:36.720
另外一个都是在说匹配

21:36.720 --> 21:38.720
另外一个情况就是说

21:38.720 --> 21:41.720
默认情况下

21:41.720 --> 21:46.720
直匹配初始目录

21:46.720 --> 21:48.720
它的目录结构直匹配初始目录

21:48.720 --> 21:50.720
只要初始目录满足要求

21:50.720 --> 21:52.720
我就算匹配

21:52.720 --> 21:55.720
如果要精确匹配

21:55.720 --> 21:57.720
如果要精确匹配

21:57.720 --> 21:59.720
配置

21:59.720 --> 22:00.720
叫做

22:00.720 --> 22:02.720
一个z

22:02.720 --> 22:03.720
一个z

22:03.720 --> 22:04.720
一个z表示

22:04.720 --> 22:05.720
确定的

22:05.720 --> 22:06.720
精确的

22:06.720 --> 22:08.720
配置一个z属性

22:08.720 --> 22:10.720
为初

22:10.720 --> 22:12.720
我们看一下

22:12.720 --> 22:13.720
这里我们只需要

22:13.720 --> 22:14.720
给它加上一个z

22:14.720 --> 22:15.720
因为它是布尔属性

22:15.720 --> 22:16.720
对吧

22:16.720 --> 22:17.720
你写了就表示

22:17.720 --> 22:18.720
这个属性只为初了

22:18.720 --> 22:20.720
那么这里写上一个z

22:20.720 --> 22:21.720
这样子一来

22:21.720 --> 22:22.720
保存

22:22.720 --> 22:23.720
你看一下

22:23.720 --> 22:24.720
是不是现在

22:24.720 --> 22:25.720
直匹配到组建b

22:25.720 --> 22:26.720
对吧

22:26.720 --> 22:28.720
直匹配到的组建b

22:28.720 --> 22:30.720
因为现在是精确匹配

22:30.720 --> 22:32.720
你光是以初始目录

22:32.720 --> 22:33.720
写缸a

22:33.720 --> 22:34.720
不行

22:34.720 --> 22:36.720
必须是精确的

22:36.720 --> 22:37.720
精确你只读的是

22:37.720 --> 22:38.720
这个目录

22:38.720 --> 22:39.720
没有读其他目录

22:39.720 --> 22:40.720
OK

22:40.720 --> 22:41.720
那么我可以匹配上

22:41.720 --> 22:43.720
就表示精确匹配了

22:43.720 --> 22:45.720
你看这意思吗

22:45.720 --> 22:47.720
这是关于精确匹配

22:47.720 --> 22:48.720
说到这儿

22:48.720 --> 22:49.720
我再顺便说一下

22:49.720 --> 22:51.720
如果说不是精确匹配的话

22:51.720 --> 22:54.720
那么这里呢

22:54.720 --> 22:55.720
电视题的话

22:55.720 --> 22:57.720
我倒是没有遇到过

22:57.720 --> 22:59.720
不过有些的时候

22:59.720 --> 23:01.720
大伙可能理解了

23:01.720 --> 23:03.720
有所偏差导致写单码的时候

23:03.720 --> 23:05.720
出了一些小小的问题

23:05.720 --> 23:06.720
就是说如果说

23:06.720 --> 23:08.720
不是精确匹配的话

23:08.720 --> 23:10.720
那么这里大家注意个点

23:10.720 --> 23:11.720
那如果我访问的是a

23:11.720 --> 23:12.720
那没问题

23:12.720 --> 23:13.720
匹配组建a

23:13.720 --> 23:15.720
那如果我访问的是abc

23:15.720 --> 23:17.720
能不能匹配组建a

23:17.720 --> 23:18.720
不行

23:18.720 --> 23:19.720
这个是匹配不上的

23:19.720 --> 23:21.720
因为它看的是目录

23:21.720 --> 23:22.720
它必须要是

23:22.720 --> 23:23.720
跟目录下面的a

23:23.720 --> 23:24.720
目录

23:24.720 --> 23:26.720
那你现在访问的是什么

23:26.720 --> 23:27.720
跟目录下面的abc

23:27.720 --> 23:28.720
这个目录

23:28.720 --> 23:29.720
那是不行的

23:29.720 --> 23:30.720
你可以说

23:30.720 --> 23:31.720
访问a目录

23:31.720 --> 23:32.720
下面的东西是可以的

23:32.720 --> 23:33.720
是可以的

23:33.720 --> 23:34.720
是能匹配的

23:34.720 --> 23:35.720
但是你访问

23:35.720 --> 23:36.720
另外一个目录

23:36.720 --> 23:37.720
虽然说名字

23:37.720 --> 23:38.720
是以这个名字开头的

23:38.720 --> 23:39.720
但是目录不一样

23:39.720 --> 23:40.720
那是不行的

23:40.720 --> 23:42.720
你可以把它想象成

23:42.720 --> 23:43.720
它会进行分割

23:43.720 --> 23:45.720
用斜杠分割成很多段

23:45.720 --> 23:47.720
只要第1个

23:47.720 --> 23:48.720
前面的初始的几个目录

23:48.720 --> 23:49.720
是一样的

23:49.720 --> 23:50.720
就行了

23:50.720 --> 23:51.720
你看这意思吧

23:51.720 --> 23:52.720
这是关于

23:52.720 --> 23:54.720
这个它的匹配的一些

23:54.720 --> 23:56.720
细节规则

23:56.720 --> 23:57.720
好

23:57.720 --> 23:58.720
另外一个情况

23:58.720 --> 23:59.720
就是说

23:59.720 --> 24:00.720
如果

24:00.720 --> 24:03.720
如果不写pass

24:03.720 --> 24:06.720
如果不写pass

24:06.720 --> 24:08.720
则会匹配

24:08.720 --> 24:10.720
任意路径

24:10.720 --> 24:12.720
任意路径

24:12.720 --> 24:13.720
当然如果你是哈西的话

24:13.720 --> 24:14.720
那就匹配哈西

24:14.720 --> 24:15.720
后边的写的路径

24:15.720 --> 24:16.720
如果你不是哈西的话

24:16.720 --> 24:17.720
那就匹配的是

24:17.720 --> 24:19.720
真实的路径

24:19.720 --> 24:20.720
如果你不写pass的话

24:20.720 --> 24:21.720
任何路径

24:21.720 --> 24:22.720
它都能匹配

24:22.720 --> 24:24.720
比方说我们这里

24:24.720 --> 24:25.720
逐渐C

24:25.720 --> 24:27.720
比方说逐渐C

24:27.720 --> 24:30.720
要匹配任意路径

24:30.720 --> 24:31.720
无论情况

24:31.720 --> 24:32.720
什么情况

24:32.720 --> 24:34.720
我都要显示逐渐C

24:34.720 --> 24:36.720
任意路径

24:36.720 --> 24:37.720
那么这里呢

24:37.720 --> 24:38.720
pass

24:38.720 --> 24:39.720
我们这几颗先讲知识

24:39.720 --> 24:40.720
还不说应用

24:40.720 --> 24:41.720
下一颗我们做一个小的demo

24:41.720 --> 24:42.720
好

24:42.720 --> 24:43.720
那么我们不写pass就完事了

24:43.720 --> 24:44.720
保存

24:44.720 --> 24:45.720
你看一下

24:45.720 --> 24:47.720
是不是一定匹配到逐渐C

24:47.720 --> 24:48.720
对吧

24:48.720 --> 24:49.720
一定匹配到逐渐C

24:49.720 --> 24:50.720
有些同学说

24:50.720 --> 24:51.720
那我这个

24:51.720 --> 24:52.720
你直接写个逐渐C

24:52.720 --> 24:53.720
在这里播完了吗

24:53.720 --> 24:54.720
当然可以

24:54.720 --> 24:55.720
当然可以

24:55.720 --> 24:57.720
只不过肉车这个组件

24:57.720 --> 24:59.720
如果你用了这个组件的话

24:59.720 --> 25:01.720
它还会有一些额外的操作

25:01.720 --> 25:02.720
我们后边会说

25:02.720 --> 25:03.720
后面的课程会说

25:03.720 --> 25:04.720
它会往这个

25:04.720 --> 25:06.720
你传的组件里边注入一些属性

25:06.720 --> 25:08.720
自动注入一些属性

25:08.720 --> 25:09.720
当然

25:09.720 --> 25:10.720
如果你说你

25:10.720 --> 25:11.720
如果你不需要这些属性的话

25:11.720 --> 25:12.720
直接写个组件C在这里

25:12.720 --> 25:13.720
没有任何问题

25:13.720 --> 25:14.720
没有任何问题

25:14.720 --> 25:15.720
这目前的情况下讲

25:15.720 --> 25:16.720
没有任何问题

25:16.720 --> 25:17.720
你看无论是谁

25:17.720 --> 25:18.720
什么样的路径

25:18.720 --> 25:20.720
它一定会匹配到逐渐C

25:20.720 --> 25:21.720
比方说跟目录

25:21.720 --> 25:22.720
对吧

25:22.720 --> 25:23.720
一定匹配到逐渐C

25:23.720 --> 25:25.720
哪怕B

25:26.720 --> 25:27.720
A

25:27.720 --> 25:28.720
B

25:28.720 --> 25:30.720
是不是一定匹配到逐渐C

25:30.720 --> 25:31.720
对吧

25:31.720 --> 25:32.720
A和B

25:32.720 --> 25:33.720
A组件它不是精确匹配

25:33.720 --> 25:34.720
所以它匹配上了

25:34.720 --> 25:35.720
B组件

25:35.720 --> 25:36.720
它的路径

25:36.720 --> 25:37.720
本来就是AB

25:37.720 --> 25:38.720
它也能匹配A组件

25:38.720 --> 25:39.720
B组件

25:39.720 --> 25:40.720
那么后边再写一些

25:40.720 --> 25:41.720
无所谓

25:41.720 --> 25:42.720
它也能匹配B组件

25:42.720 --> 25:43.720
因为不是精确的

25:43.720 --> 25:44.720
谁组件

25:44.720 --> 25:45.720
无论什么路径都能匹配

25:45.720 --> 25:46.720
对吧

25:46.720 --> 25:47.720
所以说

25:47.720 --> 25:48.720
不要想浪然的

25:48.720 --> 25:50.720
认为它是互斥的

25:50.720 --> 25:51.720
它们不是互斥的

25:51.720 --> 25:53.720
因为它们I2的宣然

25:53.720 --> 25:54.720
无非就是一个普通组件

25:54.720 --> 25:55.720
咱们之前也写过这样的代码

25:55.720 --> 25:56.720
对吧

25:56.720 --> 25:57.720
无非就是一个普通组件

25:57.720 --> 25:58.720
宣然这个组件的时候

25:58.720 --> 26:00.720
你匹配到过后就宣然

26:00.720 --> 26:01.720
没有匹配就不宣然

26:01.720 --> 26:02.720
对不对

26:02.720 --> 26:03.720
没有匹配就不宣然

26:03.720 --> 26:05.720
就这么个意思

26:05.720 --> 26:07.720
这是关于这个细节规则

26:09.720 --> 26:12.720
然后现在还有这么一种情况

26:12.720 --> 26:13.720
就是说

26:13.720 --> 26:14.720
我有的时候

26:14.720 --> 26:16.720
你甭管我有没有精确匹配

26:16.720 --> 26:18.720
这不管你的事

26:18.720 --> 26:20.720
我希望

26:20.720 --> 26:21.720
就是说

26:21.720 --> 26:23.720
我这里边的路径

26:23.720 --> 26:25.720
只要匹配到了一个

26:25.720 --> 26:27.720
我只要匹配到了一个

26:27.720 --> 26:29.720
那么我就不要再匹配了

26:29.720 --> 26:31.720
就不要再匹配其他的了

26:31.720 --> 26:34.720
那么这个情况下又怎么做呢

26:34.720 --> 26:35.720
这种情况下

26:35.720 --> 26:38.720
需要一个新的组件

26:38.720 --> 26:40.720
新的组件

26:40.720 --> 26:42.720
这个组件叫做Switch

26:42.720 --> 26:44.720
这叫做开关

26:45.720 --> 26:47.720
这个Switch组件

26:47.720 --> 26:49.720
那么这个组件什么意思呢

26:49.720 --> 26:51.720
写到

26:51.720 --> 26:54.720
写到Switch

26:54.720 --> 26:56.720
组件

26:56.720 --> 26:59.720
中的肉彻组件

26:59.720 --> 27:00.720
如果说你的组件

27:00.720 --> 27:02.720
是写到Switch组件中的

27:02.720 --> 27:04.720
那么这样的组件

27:04.720 --> 27:06.720
当匹配到

27:06.720 --> 27:09.720
第一个肉彻后

27:09.720 --> 27:13.720
会立即停止匹配

27:13.720 --> 27:15.720
就这么一个组件

27:15.720 --> 27:17.720
接下来咱们来用一下

27:17.720 --> 27:19.720
复制

27:19.720 --> 27:21.720
接下来我们看一下

27:21.720 --> 27:24.720
这里边我们写上一个

27:24.720 --> 27:26.720
Switch组件

27:26.720 --> 27:28.720
这个组件怎么用呢

27:28.720 --> 27:31.720
你只需要用它

27:31.720 --> 27:34.720
把肉彻组件包起来

27:34.720 --> 27:37.720
把肉彻组件包起来

27:37.720 --> 27:39.720
就完事了

27:39.720 --> 27:41.720
包穿你看一下

27:42.720 --> 27:44.720
现在你看一下

27:44.720 --> 27:46.720
我们访问的地址是什么

27:46.720 --> 27:47.720
访问的地址是

27:47.720 --> 27:49.720
写杠A写杠B

27:49.720 --> 27:51.720
访问的是这个地址

27:51.720 --> 27:53.720
这个地址拿到过后

27:53.720 --> 27:55.720
这个地址拿到过后

27:55.720 --> 27:57.720
它开始匹配

27:57.720 --> 27:59.720
如果说匹配到它

27:59.720 --> 28:00.720
它有没有匹配

28:00.720 --> 28:01.720
是不是匹配到了

28:01.720 --> 28:02.720
它不是精确匹配吗

28:02.720 --> 28:04.720
它匹配到了

28:04.720 --> 28:06.720
匹配到了之后

28:06.720 --> 28:08.720
它就由于Switch这个作用

28:08.720 --> 28:09.720
它的存在

28:09.720 --> 28:11.720
后边就不会再进行匹配了

28:11.720 --> 28:13.720
就这么个意思

28:13.720 --> 28:15.720
它就会导致它不再进行匹配了

28:15.720 --> 28:17.720
那我们看一下这个

28:17.720 --> 28:18.720
这个结构图

28:18.720 --> 28:20.720
这个组件结构

28:20.720 --> 28:22.720
这里

28:22.720 --> 28:25.720
加了一个Switch

28:25.720 --> 28:27.720
那么它里边

28:27.720 --> 28:28.720
它会去读去什么

28:28.720 --> 28:30.720
读去它的区域准

28:30.720 --> 28:31.720
它会去读去区域准

28:31.720 --> 28:33.720
区域准是不是个数组

28:33.720 --> 28:35.720
一个组件1

28:35.720 --> 28:37.720
组件2 组件3

28:37.720 --> 28:38.720
它会去读去它的数组

28:38.720 --> 28:40.720
那么读去它的数组之后

28:40.720 --> 28:42.720
然后它会去循环这个数组

28:42.720 --> 28:44.720
看一下哪个组件是匹配到了

28:44.720 --> 28:46.720
如果说匹配到了过后

28:46.720 --> 28:48.720
就直接选择那个组件

28:48.720 --> 28:50.720
它就不会再往后继续进行匹配了

28:50.720 --> 28:52.720
就这么简单

28:52.720 --> 28:54.720
这是它的Switch这个组件

28:54.720 --> 28:56.720
它的匹配方式

28:56.720 --> 28:58.720
它只要有一个匹配

28:58.720 --> 29:01.720
那么就可以匹配了

29:01.720 --> 29:03.720
那么我们可以利用这一点

29:03.720 --> 29:05.720
来实现一个什么样的效果

29:05.720 --> 29:07.720
来实现这么一个效果

29:07.720 --> 29:10.720
就是404的效果

29:10.720 --> 29:12.720
比方说C组件

29:12.720 --> 29:15.720
我们跟它说找不到页面

29:15.720 --> 29:17.720
找不到页面

29:17.720 --> 29:19.720
比方说我们这里写这么一个东西

29:19.720 --> 29:21.720
那么这样子可以实现一个什么效果呢

29:21.720 --> 29:24.720
就是说由于Switch的存在

29:24.720 --> 29:26.720
只要前面能匹配

29:26.720 --> 29:28.720
是不是就一定是渲染它的组件

29:28.720 --> 29:29.720
对吧

29:29.720 --> 29:30.720
比方说它匹配到了A

29:30.720 --> 29:31.720
就渲染A的组件

29:31.720 --> 29:34.720
现在是不是不可能匹配到B

29:34.720 --> 29:35.720
B是不是不可能匹配到

29:35.720 --> 29:36.720
对不对

29:36.720 --> 29:38.720
因为B这个路径能匹配的话

29:38.720 --> 29:39.720
A一定能匹配

29:39.720 --> 29:40.720
因为它不是精确的

29:40.720 --> 29:41.720
对吧

29:41.720 --> 29:42.720
不是精确匹配的

29:42.720 --> 29:43.720
它一定能匹配

29:43.720 --> 29:44.720
那么它匹配到了的话

29:44.720 --> 29:45.720
那么它就渲染出来了

29:45.720 --> 29:46.720
就不会管B了

29:46.720 --> 29:47.720
好

29:47.720 --> 29:48.720
如果说

29:48.720 --> 29:50.720
当然你可以加上那个精确匹配

29:50.720 --> 29:51.720
跟距离自己的情况

29:51.720 --> 29:52.720
加上精确匹配

29:52.720 --> 29:53.720
加上精确匹配过后

29:53.720 --> 29:55.720
那么现在是不是渲染组件B了

29:55.720 --> 29:57.720
有没有渲染组件C没有

29:57.720 --> 29:58.720
因为组件C

29:58.720 --> 30:00.720
虽然说它能匹配任何路径

30:00.720 --> 30:02.720
但是由于已经匹配B了

30:02.720 --> 30:05.720
说由于Switch的这个功能的存在

30:05.720 --> 30:07.720
它会导致后续的匹配不再进行了

30:07.720 --> 30:08.720
明白这个意思吗

30:08.720 --> 30:09.720
好

30:09.720 --> 30:10.720
于是呢

30:10.720 --> 30:11.720
现在呢

30:11.720 --> 30:12.720
现在

30:12.720 --> 30:14.720
我们如果说访问一个

30:14.720 --> 30:15.720
不存在的路径

30:16.720 --> 30:17.720
是不是显示找不到

30:17.720 --> 30:18.720
找不到页面了

30:18.720 --> 30:19.720
为什么

30:19.720 --> 30:20.720
因为前面都不能匹配

30:20.720 --> 30:21.720
都不能匹配

30:21.720 --> 30:22.720
是不是弄到最后一个

30:22.720 --> 30:23.720
最后一个

30:23.720 --> 30:24.720
就可以匹配任何东西了

30:24.720 --> 30:26.720
那么最后一个来兜底

30:26.720 --> 30:28.720
它能够把前面匹配

30:28.720 --> 30:30.720
如果前面都匹配不到

30:30.720 --> 30:31.720
匹配到这儿

30:31.720 --> 30:33.720
于是我就直接匹配任何路径渲染出来

30:33.720 --> 30:35.720
那么就是一个找不到页面的

30:35.720 --> 30:36.720
这种

30:36.720 --> 30:38.720
一种情况

30:38.720 --> 30:39.720
看没

30:39.720 --> 30:41.720
当然我们现在都还没有用什么元素

30:41.720 --> 30:42.720
A元素来跳转页面

30:42.720 --> 30:43.720
都还没有去这样做

30:43.720 --> 30:44.720
不过呢

30:44.720 --> 30:45.720
我们现在呢

30:45.720 --> 30:47.720
已经可以用通过不同的地址

30:47.720 --> 30:48.720
来匹配不同的组件了

30:48.720 --> 30:50.720
你看用法非常非常简单

30:50.720 --> 30:51.720
非常简单

30:52.720 --> 30:54.720
这是关于这个Switch

30:55.720 --> 30:56.720
好 接下来我要说个点

30:56.720 --> 30:58.720
就是关于这个Switch组件

30:58.720 --> 30:59.720
有一个特殊的要求

30:59.720 --> 31:01.720
因为它的实现原理

31:01.720 --> 31:03.720
我们刚才看到过

31:03.720 --> 31:05.720
实现原理是

31:05.720 --> 31:07.720
这个Switch组件

31:07.720 --> 31:08.720
它不是一个qo军吗

31:08.720 --> 31:09.720
对吧

31:09.720 --> 31:10.720
它的直组件

31:10.720 --> 31:12.720
它会循环这个数组

31:12.720 --> 31:13.720
循环它的所有直组件

31:13.720 --> 31:15.720
然后IcI的去看一下

31:15.720 --> 31:16.720
每个组件有没有匹配

31:16.720 --> 31:17.720
如果有匹配的话

31:17.720 --> 31:19.720
把组件对应的

31:19.720 --> 31:20.720
这个组件

31:20.720 --> 31:21.720
这个Rose的对应的组件

31:21.720 --> 31:22.720
给它渲染出来

31:22.720 --> 31:23.720
它就停止了

31:23.720 --> 31:25.720
就不再进行匹配了

31:25.720 --> 31:27.720
因为它的这种特殊原理

31:27.720 --> 31:29.720
所以说它要求

31:30.720 --> 31:31.720
它的指元数

31:31.720 --> 31:33.720
它必须是Rote

31:33.720 --> 31:35.720
但是后面我们还会学一个

31:35.720 --> 31:36.720
Red Direct的组件

31:36.720 --> 31:38.720
那个组件我们后面再说

31:38.720 --> 31:40.720
那么目前我们学习到的知识

31:40.720 --> 31:41.720
它只能要求是Rote

31:41.720 --> 31:43.720
你不能在这里边给我写

31:43.720 --> 31:44.720
什么乱七八糟的东西

31:44.720 --> 31:45.720
比方说你给我写一个

31:45.720 --> 31:47.720
什么DV这些东西

31:47.720 --> 31:48.720
就不要来了

31:48.720 --> 31:49.720
保存你看一下

31:49.720 --> 31:50.720
那么这个时候

31:52.720 --> 31:53.720
到时现在没有爆错

31:53.720 --> 31:54.720
没有爆错是因为

31:54.720 --> 31:56.720
我们现在匹配到时候就停止了

31:56.720 --> 31:58.720
如果说我们匹配另外一个东西

31:58.720 --> 32:00.720
当它循环的时候

32:00.720 --> 32:01.720
循环到这个DIV

32:01.720 --> 32:02.720
它就蒙逼了

32:02.720 --> 32:03.720
它不知道该干嘛了

32:03.720 --> 32:05.720
因为它的做法是什么了

32:05.720 --> 32:07.720
它要循环这个数组

32:07.720 --> 32:10.720
结果你第二个组件给我传的是一个DIV

32:10.720 --> 32:11.720
你看比较个DIV

32:11.720 --> 32:14.720
这个DIV它不是一个Rote组件

32:15.720 --> 32:16.720
这个DV怎么匹配了

32:16.720 --> 32:19.720
这个DV它怎么去匹配路径了

32:19.720 --> 32:20.720
没法匹配路径

32:20.720 --> 32:22.720
你必须是一个Rote组件

32:22.720 --> 32:24.720
才能去匹配对应的路径

32:24.720 --> 32:26.720
所以说会导致它爆错

32:26.720 --> 32:28.720
这里会导致爆错

32:28.720 --> 32:29.720
它说什么呢

32:29.720 --> 32:32.720
它说说来大堆

32:32.720 --> 32:36.720
它说你不能去react

32:36.720 --> 32:38.720
不能识别

32:38.720 --> 32:42.720
computed march probe

32:42.720 --> 32:44.720
on a dome element

32:44.720 --> 32:47.720
它不能在一个dome的react元素中

32:47.720 --> 32:49.720
去识别这个东西

32:49.720 --> 32:50.720
这个东西

32:50.720 --> 32:51.720
我们可以认为是Rote组件

32:51.720 --> 32:53.720
它带有的属性

32:53.720 --> 32:54.720
我们不用去关心

32:54.720 --> 32:57.720
目前不用去关心它的内部史前代

32:57.720 --> 32:59.720
我们只知道Rote组件里面

32:59.720 --> 33:00.720
它有这么一个属性

33:00.720 --> 33:02.720
但是一个dome元素里面是没有的

33:02.720 --> 33:05.720
因此它会爆错

33:05.720 --> 33:07.720
所以说你这里面只能写

33:07.720 --> 33:10.720
植入件里面只能写Rote

33:10.720 --> 33:11.720
只能写Rote

33:11.720 --> 33:12.720
它不能写其他东西

33:12.720 --> 33:14.720
大家记一笔

33:14.720 --> 33:18.720
由于SWC组件

33:18.720 --> 33:21.720
会循环所有的

33:21.720 --> 33:24.720
所有植元素

33:24.720 --> 33:29.720
然后让每一个植元素

33:29.720 --> 33:32.720
去完成匹配

33:32.720 --> 33:35.720
若匹配到

33:35.720 --> 33:41.720
则渲然对应的组件

33:41.720 --> 33:43.720
然后停止循环

33:43.720 --> 33:47.160
这是它的实现原理

33:47.160 --> 33:52.160
因此不能在

33:53.160 --> 33:56.160
SWC的植元素中

33:56.160 --> 34:02.160
使用除Rote外的其他组件

34:02.160 --> 34:03.160
是不能使用其他组件的

34:03.160 --> 34:05.160
只能使用Rote组件

34:05.160 --> 34:07.160
这跟它实现原理的关系

34:07.160 --> 34:10.160
这是关于SWC组件

34:10.160 --> 34:11.160
接下来

34:11.160 --> 34:12.160
因为这些知识都比较多

34:12.160 --> 34:13.160
比较凌散

34:13.160 --> 34:15.160
现在我要说的另外一个问题就是

34:15.160 --> 34:17.160
是关于这个Rote组件

34:17.160 --> 34:18.160
这个Rote组件本身

34:18.160 --> 34:21.160
这个Rote组件要说回到这了

34:21.160 --> 34:22.160
Rote组件

34:22.160 --> 34:23.160
它是这样子

34:23.160 --> 34:26.160
Rote组件可以写到

34:26.160 --> 34:30.160
写到任意的地方

34:30.160 --> 34:33.160
只要保证

34:33.160 --> 34:37.160
它是Rotor组件的

34:37.160 --> 34:39.160
后代元素就行了

34:39.160 --> 34:40.160
不一定是指元素

34:40.160 --> 34:42.160
它的后代元素也行

34:42.160 --> 34:43.160
Rote这个组件

34:43.160 --> 34:44.160
因为它的功能很简单

34:44.160 --> 34:46.160
它就是根据地址来去

34:46.160 --> 34:47.160
进行匹配就完事了

34:47.160 --> 34:48.160
匹配到了

34:48.160 --> 34:49.160
我就选择对应的元素

34:49.160 --> 34:50.160
它的功能很简单

34:50.160 --> 34:51.160
哪怕你比方说

34:51.160 --> 34:53.160
你把这个Rote组件

34:53.160 --> 34:54.160
又写到

34:54.160 --> 34:55.160
比方说吧

34:55.160 --> 34:57.160
没有写到这个C里边

34:57.160 --> 34:58.160
可不可以

34:58.160 --> 34:59.160
可以没问题的

34:59.160 --> 35:00.160
你又写到这

35:00.160 --> 35:01.160
可不可以

35:01.160 --> 35:03.160
格式化了

35:03.160 --> 35:04.160
代码格式化没了

35:04.160 --> 35:05.160
写到这里边

35:05.160 --> 35:06.160
可不可以

35:06.160 --> 35:08.160
可以随便写到哪

35:08.160 --> 35:09.160
那么比方说

35:09.160 --> 35:10.160
这里边又要去匹配啥

35:10.160 --> 35:13.160
又要去匹配ABC

35:13.160 --> 35:15.160
匹配ABC的时候

35:15.160 --> 35:16.160
我渲染啥呢

35:16.160 --> 35:19.160
我渲染ComponentD

35:19.160 --> 35:20.160
D嘛

35:20.160 --> 35:24.470
渲染一个ComponentD

35:24.470 --> 35:26.470
D组件

35:26.470 --> 35:27.470
比方说

35:27.470 --> 35:28.470
有这么种情况

35:28.470 --> 35:29.470
我渲染ComponentD

35:29.470 --> 35:30.470
可不可以

35:30.470 --> 35:31.470
可以

35:31.470 --> 35:33.470
那么我们看一下这个代码

35:33.470 --> 35:34.470
保存

35:34.470 --> 35:35.470
现在呢

35:35.470 --> 35:36.470
是不是找不到页面

35:36.470 --> 35:37.470
我访问这个地址

35:37.470 --> 35:38.470
是不是找不到页面

35:38.470 --> 35:39.470
为什么找不到页面

35:39.470 --> 35:40.470
是因为这个组件

35:40.470 --> 35:41.470
你看从上到下进

35:41.470 --> 35:42.470
渲染

35:42.470 --> 35:43.470
渲染到Switch的时候

35:43.470 --> 35:44.470
还在这看

35:44.470 --> 35:45.470
前面两个都没有匹配

35:45.470 --> 35:47.470
那前面两个啥都没有显示

35:47.470 --> 35:48.470
就匹配到它

35:48.470 --> 35:49.470
匹配到它的话

35:49.470 --> 35:50.470
它是不是显示一个东西

35:50.470 --> 35:51.470
对吧

35:51.470 --> 35:52.470
它显示一个东西

35:52.470 --> 35:53.470
就是组件C

35:53.470 --> 35:54.470
组件C里边

35:54.470 --> 35:55.470
它是不是找不到页面

35:55.470 --> 35:56.470
然后组件C里边

35:56.470 --> 35:57.470
是不是又要渲染它

35:57.470 --> 35:58.470
渲染它的时候

35:58.470 --> 35:59.470
是不是又要进行匹配

35:59.470 --> 36:00.470
看一下地址是不是

36:00.470 --> 36:01.470
匹钢ABC

36:01.470 --> 36:02.470
那现在地址

36:02.470 --> 36:03.470
是不是匹钢ABC

36:03.470 --> 36:04.470
不是

36:04.470 --> 36:05.470
所以说这个地方

36:05.470 --> 36:06.470
它啥都没渲染

36:06.470 --> 36:07.470
那如果说

36:07.470 --> 36:08.470
我们访问的地址

36:08.470 --> 36:09.470
就是ABC

36:09.470 --> 36:10.470
你看是不是

36:10.470 --> 36:11.470
匹渲染到这

36:11.470 --> 36:12.470
这又渲染到这

36:12.470 --> 36:13.470
对吧

36:13.470 --> 36:14.470
没问题吧

36:14.470 --> 36:15.470
好

36:15.470 --> 36:16.470
那么这里

36:16.470 --> 36:17.470
它给你报了一个警告

36:17.470 --> 36:19.470
我们来看一下这个警告

36:19.470 --> 36:21.470
这个警告很简单

36:21.470 --> 36:22.470
它说什么

36:22.470 --> 36:25.470
它说HE不能

36:25.470 --> 36:27.470
作为一个HE的指援数

36:27.470 --> 36:28.470
这跟我们的

36:28.470 --> 36:29.470
什么路由类型没关系

36:29.470 --> 36:30.470
因为你这里的

36:30.470 --> 36:31.470
显示出来过后

36:31.470 --> 36:32.470
是不是HE元素

36:32.470 --> 36:34.470
HE元素怎么掏到

36:34.470 --> 36:35.470
HE元素里边了

36:35.470 --> 36:36.470
对不对

36:36.470 --> 36:37.470
是这个原因

36:37.470 --> 36:38.470
把变成四边

36:38.470 --> 36:39.470
你看一下

36:39.470 --> 36:40.470
那是不是一个

36:40.470 --> 36:41.470
地组件就出来了

36:41.470 --> 36:42.470
对不对

36:42.470 --> 36:43.470
非常简单

36:43.470 --> 36:44.470
就是说肉车组件

36:44.470 --> 36:45.470
你不要局限于说

36:45.470 --> 36:47.470
我只能写到这个app里边

36:47.470 --> 36:48.470
这个肉车组件

36:48.470 --> 36:49.470
可以写到任何地方

36:49.470 --> 36:50.470
你只要保证

36:50.470 --> 36:51.470
它是它的后代元素

36:51.470 --> 36:52.470
能够保证

36:52.470 --> 36:54.470
它能够读到上下文就行了

36:54.470 --> 36:56.470
那么它就可以写到任何地方

36:56.470 --> 36:57.470
只要匹配了

36:57.470 --> 36:58.470
它就显示

36:58.470 --> 36:59.470
不匹配就不显示

36:59.470 --> 37:00.470
它的用法

37:00.470 --> 37:01.470
是非常非常灵活的

37:01.470 --> 37:03.470
这是个肉车组件

37:03.470 --> 37:04.470
好

37:04.470 --> 37:05.470
这一刻再说一个点

37:05.470 --> 37:06.470
再说一个点

37:06.470 --> 37:07.470
我们把基本功能说完

37:07.470 --> 37:09.470
然后就差不多了

37:09.470 --> 37:11.470
基本功能说完就差不多了

37:11.470 --> 37:12.470
再说一个点

37:12.470 --> 37:13.470
就是说

37:13.470 --> 37:15.470
这个肉车组件

37:15.470 --> 37:17.470
它还可以写指元素

37:19.470 --> 37:20.470
写这个指元素

37:20.470 --> 37:22.470
这个指元素

37:22.470 --> 37:24.470
有两种写法

37:24.470 --> 37:26.470
一种是传递

37:26.470 --> 37:30.470
一个传递reaction元素

37:30.470 --> 37:31.470
如果说你这个

37:31.470 --> 37:34.470
切尔举里面传递reaction元素的话

37:34.470 --> 37:36.470
会怎么样呢

37:36.470 --> 37:38.470
无论

37:38.470 --> 37:40.470
是否匹配

37:40.470 --> 37:41.470
如果说

37:41.470 --> 37:43.470
渲染到这个肉车组件

37:43.470 --> 37:45.470
它无论说它是否匹配

37:45.470 --> 37:49.470
一定会显示切尔举

37:49.470 --> 37:51.470
一定会显示切尔举

37:51.470 --> 37:52.470
好

37:52.470 --> 37:53.470
咱们来看一下这个例子

37:53.470 --> 37:55.470
我们这就复制一下

37:55.470 --> 37:56.470
复制一下

37:56.470 --> 37:58.470
虽然这个用的不是很多

37:58.470 --> 38:00.470
我们来可以看一下

38:00.470 --> 38:02.470
比方说

38:02.470 --> 38:03.470
我们这里

38:03.470 --> 38:05.470
不用这个示威器

38:05.470 --> 38:06.470
不用这个示威

38:06.470 --> 38:07.470
我就用这个示威器

38:07.470 --> 38:09.470
不用不用

38:09.470 --> 38:10.470
跟这个示威器

38:10.470 --> 38:11.470
什么关系

38:11.470 --> 38:12.470
反正比方说

38:12.470 --> 38:14.470
我们在匹配A的时候

38:14.470 --> 38:16.470
在匹配A的时候

38:16.470 --> 38:17.470
无论这个A

38:17.470 --> 38:18.470
我们给它怎么来保证

38:18.470 --> 38:19.470
什么精确匹配

38:19.470 --> 38:20.470
不精确匹配

38:20.470 --> 38:22.470
无论说它怎么样

38:22.470 --> 38:24.470
能不能实现匹配

38:24.470 --> 38:26.470
它一定会渲染这里的指

38:26.470 --> 38:28.470
这里的切尔举

38:28.470 --> 38:30.470
比方说我们这里写上一个

38:30.470 --> 38:32.470
H2

38:32.470 --> 38:34.470
或者说写上一个H1

38:34.470 --> 38:36.470
给它一个style

38:36.470 --> 38:37.470
color

38:37.470 --> 38:38.470
red

38:38.470 --> 38:39.470
红色

38:39.470 --> 38:41.470
这里边写上一个

38:41.470 --> 38:43.470
必定

38:43.470 --> 38:45.470
会看到的内容

38:45.470 --> 38:47.470
只要它完成

38:47.470 --> 38:48.470
对A的匹配

38:48.470 --> 38:50.470
它一定会看到这个内容

38:50.470 --> 38:52.470
保存

38:52.470 --> 38:54.470
你看一下

38:54.470 --> 38:55.470
A准确是不是显示出来了

38:55.470 --> 38:57.470
你看我的地址是啥

38:57.470 --> 38:58.470
是不是ABC

38:58.470 --> 39:00.470
ABC它这里是精确匹配

39:00.470 --> 39:01.470
它是不是一定匹配不到A

39:01.470 --> 39:02.470
对吧

39:02.470 --> 39:03.470
一定匹配不到这个东西

39:03.470 --> 39:05.470
但是不管你有没有匹配到

39:05.470 --> 39:07.470
我一定会渲染这个东西

39:07.470 --> 39:09.470
不管你这个切尔举写了多少

39:09.470 --> 39:11.470
写了多少什么东西

39:11.470 --> 39:12.470
无所谓

39:12.470 --> 39:14.470
只要我匹配到了A

39:14.470 --> 39:16.470
只要我匹配

39:16.470 --> 39:18.470
就是我进行了对A的匹配

39:18.470 --> 39:20.470
那么我只要发现它有切尔举

39:20.470 --> 39:22.470
无论如何都会渲染

39:22.470 --> 39:23.470
无论如何都会渲染

39:23.470 --> 39:24.470
那么你看一下

39:24.470 --> 39:25.470
是不是会忽略掉

39:25.470 --> 39:27.470
这个component的属性

39:27.470 --> 39:29.470
这个属性是不是会被忽略掉

39:29.470 --> 39:31.470
并且

39:31.470 --> 39:33.470
会忽略

39:33.470 --> 39:35.470
component属性

39:35.470 --> 39:37.470
这个属性就会被忽略

39:37.470 --> 39:38.470
明白这个意思吗

39:38.470 --> 39:40.470
这是个签准

39:40.470 --> 39:42.470
没问题吧

39:42.470 --> 39:44.470
这东西我们用的比较少

39:44.470 --> 39:45.470
比较少

39:45.470 --> 39:46.470
了解一下就行了

39:46.470 --> 39:48.470
另外一种方式是

39:48.470 --> 39:50.470
签准的是一个函数

39:50.470 --> 39:53.470
传递一个函数

39:53.470 --> 39:56.470
该函数有

39:56.470 --> 39:59.470
有多个参数

39:59.470 --> 40:02.470
这些参数来自于

40:02.470 --> 40:04.470
上下文

40:04.470 --> 40:05.470
来自于上下文

40:05.470 --> 40:08.470
关于具体这些参数是啥呢

40:08.470 --> 40:10.470
咱们以后再说

40:10.470 --> 40:11.470
以后再说

40:11.470 --> 40:13.470
就是关于上下文那边的东西

40:13.470 --> 40:14.470
我们以后再说

40:14.470 --> 40:15.470
那么这参数来自于上下文

40:15.470 --> 40:18.470
反正我现在肯定是不会用的

40:18.470 --> 40:21.470
该函数返回

40:21.470 --> 40:24.470
一个返回react元素

40:24.470 --> 40:26.470
返回react元素

40:26.470 --> 40:30.470
则

40:30.470 --> 40:35.470
一定会显示返回的元素

40:35.470 --> 40:38.470
并且忽略

40:38.470 --> 40:40.470
component属性

40:40.470 --> 40:41.470
是一样的

40:41.470 --> 40:43.470
一开始是直接传递元素

40:43.470 --> 40:45.470
另外一种就是直接干写个函数

40:45.470 --> 40:46.470
这个函数返回的元素

40:46.470 --> 40:48.470
它会进行显示

40:48.470 --> 40:50.470
咱们来看一下这个

40:50.470 --> 40:52.470
再复制一下吧

40:52.470 --> 40:53.470
这里为什么有个警告

40:53.470 --> 40:56.470
这里没用了是吧

40:56.470 --> 40:59.910
这里没用

40:59.910 --> 41:03.910
如果说我这里写的是一个函数

41:03.910 --> 41:05.910
写的是一个函数

41:05.910 --> 41:07.910
这个函数返回的

41:07.910 --> 41:08.910
是这么一个东西

41:08.910 --> 41:10.910
但是函数返回必须有个根结点

41:10.910 --> 41:11.910
必须有个根结点

41:11.910 --> 41:13.910
DIV

41:13.910 --> 41:14.910
如果是这种情况的话

41:14.910 --> 41:16.910
是一样的

41:16.910 --> 41:17.910
保存

41:17.910 --> 41:18.910
你看一下

41:18.910 --> 41:19.910
这个内容它无论怎么样

41:19.910 --> 41:21.910
它都会显示

41:21.910 --> 41:22.910
只要你开始

41:22.910 --> 41:24.910
只要你渲染了这个肉

41:24.910 --> 41:26.910
它就会显示

41:26.910 --> 41:28.910
它就会显示

41:28.910 --> 41:32.910
如果说我这里加了Switch

41:32.910 --> 41:34.910
如果说我加了Switch主线

41:34.910 --> 41:36.910
又会怎么样

41:36.910 --> 41:38.910
Switch主线

41:38.910 --> 41:42.350
Switch

41:42.350 --> 41:43.350
没有

41:43.350 --> 41:45.350
没有整体式

41:45.350 --> 41:47.350
好烦

41:47.350 --> 41:49.350
加那个Switch主线

41:49.350 --> 41:50.350
包起来

41:50.350 --> 41:51.350
好

41:51.350 --> 41:52.350
如果说这种情况

41:52.350 --> 41:54.350
我们把这个A主线写下来

41:54.350 --> 41:55.350
看着

41:55.350 --> 41:57.350
那如果说这种情况

41:57.350 --> 41:58.350
比方说

41:58.350 --> 42:00.350
我们访问的是ABC

42:00.350 --> 42:01.350
ABC

42:01.350 --> 42:02.350
那你看一下

42:02.350 --> 42:05.350
是不是没有渲染到这个主线

42:05.350 --> 42:06.350
对吧

42:06.350 --> 42:08.350
因为现在的匹配是谁在进行的

42:08.350 --> 42:09.350
是Switch进行的

42:09.350 --> 42:11.350
并不是它自身进行的

42:11.350 --> 42:12.350
是Switch在进行

42:12.350 --> 42:13.350
所以说

42:13.350 --> 42:14.350
现在它就

42:14.350 --> 42:16.350
它就实现不了了

42:16.350 --> 42:17.350
它就实现不了了

42:17.350 --> 42:19.350
因为它根本就没有决定

42:19.350 --> 42:21.350
要渲染这个肉的主线

42:21.350 --> 42:22.350
这个主线

42:22.350 --> 42:23.350
除非要渲染的时候

42:23.350 --> 42:24.350
它在不管是

42:24.350 --> 42:25.350
有没有匹配

42:25.350 --> 42:27.350
然后我都要去渲染这个东西

42:27.350 --> 42:28.350
现在渲染的能力

42:28.350 --> 42:30.350
渲染的权力是交给它了

42:30.350 --> 42:31.350
是它在处理

42:31.350 --> 42:32.350
所以说放到Switch里面

42:32.350 --> 42:33.350
是无效的

42:33.350 --> 42:34.350
注意这个细节

42:34.350 --> 42:35.350
不过

42:35.350 --> 42:37.350
这个东西我们平时也没这么用

42:37.350 --> 42:38.350
也没这么用

42:38.350 --> 42:40.350
说了解一下就行了

42:40.350 --> 42:42.350
这是关于

42:42.350 --> 42:44.350
这么一个点

42:44.350 --> 42:45.350
好就没了

42:45.350 --> 42:46.350
知识部分

42:46.350 --> 42:48.350
到此结束

42:48.350 --> 42:49.350
到此结束

42:49.350 --> 42:50.350
咱们这一块讲了一些基本的东西

42:50.350 --> 42:52.350
当然还有更多的东西

42:52.350 --> 42:53.350
我们后续再多讲解

42:53.350 --> 42:54.350
这些可能

42:54.350 --> 42:56.350
就讲这些基本东西

42:56.350 --> 42:57.350
讲完了之后

42:57.350 --> 42:58.350
咱们下节课

42:58.350 --> 43:00.350
来做这么一个demo

43:00.350 --> 43:02.350
做这么一个小练习

43:02.350 --> 43:04.350
这是关于

43:04.350 --> 43:05.350
这讲了三个主件

43:05.350 --> 43:06.350
Rotor

43:06.350 --> 43:07.350
这个主人很简单

43:07.350 --> 43:09.350
就是来选择模式

43:09.350 --> 43:11.350
以及他会提供一个上下文

43:11.350 --> 43:12.350
这个上下文会被

43:12.350 --> 43:13.350
后续的主件所使用

43:13.350 --> 43:14.350
另外一个

43:14.350 --> 43:15.350
那是肉车主件

43:15.350 --> 43:16.350
它就是真正的来

43:16.350 --> 43:17.350
根据不同的地址

43:17.350 --> 43:19.350
展示不同的主件的

43:19.350 --> 43:21.350
然后一个Switch主件

43:21.350 --> 43:22.350
它相当于是个开关主件

43:22.350 --> 43:25.350
它可以有权利来控制

43:25.350 --> 43:26.350
控制什么呢

43:26.350 --> 43:28.350
就是只要有一个主件匹配到

43:28.350 --> 43:29.350
后续的主件

43:29.350 --> 43:30.350
都不再匹配

43:30.350 --> 43:31.350
OK就没了

43:31.350 --> 43:32.350
好

43:32.350 --> 43:33.350
这是关于这几颗的东西

