WEBVTT

00:01.070 --> 00:04.070
下一个东西

00:04.070 --> 00:08.070
callback hook

00:08.070 --> 00:10.070
这个勾字函数

00:10.070 --> 00:13.070
这个勾字函数 当然按照我们的习惯

00:13.070 --> 00:15.070
我们讲这个callback hook的时候

00:15.070 --> 00:17.070
一会我们用的函数名字叫什么

00:17.070 --> 00:19.070
函数名 它自然就一拆下

00:19.070 --> 00:22.070
Use callback

00:22.070 --> 00:25.070
这个hook函数用来做什么事情呢

00:25.070 --> 00:30.070
它是用于得到一个固定引用值的

00:30.070 --> 00:32.070
函数

00:32.070 --> 00:39.070
通常用于用它进行性能优化

00:39.070 --> 00:42.070
什么意思呢

00:42.070 --> 00:45.070
这样子吧

00:45.070 --> 00:47.070
我给大家举个例子

00:47.070 --> 00:49.070
比方到这边

00:49.070 --> 00:52.070
这里有这么一个内主键

00:52.070 --> 00:54.070
class

00:54.070 --> 00:56.070
有什么要问的

00:56.070 --> 00:58.070
原老师你不是讲那个hook

00:59.070 --> 01:01.070
为什么现在还要去举什么内主键的例子呢

01:01.070 --> 01:03.070
实际上是这样子

01:03.070 --> 01:05.070
咱们之前已经说过了

01:05.070 --> 01:08.070
react反复的声明

01:08.070 --> 01:10.070
就是说

01:10.070 --> 01:16.070
它现在并没有任何取消内主键的计划

01:16.070 --> 01:19.070
它没有去规划要做什么取消内主键

01:19.070 --> 01:23.070
虽然说 hook理论上确实可以替代内主键

01:23.070 --> 01:25.070
但是它不打算取消内主键

01:25.070 --> 01:26.070
为什么呢

01:26.070 --> 01:28.070
如果它要取消内主键的话

01:28.070 --> 01:31.070
全世界所有用react的公司要封掉

01:31.070 --> 01:33.070
你想啊

01:33.070 --> 01:35.070
react现在经过了这么多年了

01:35.070 --> 01:38.070
已经产生了大量的内主键了

01:38.070 --> 01:40.070
因为 hook 它毕竟是一个很新的东西

01:40.070 --> 01:42.070
大家还没有反应过来

01:42.070 --> 01:43.070
结果你刷一下

01:43.070 --> 01:45.070
把内主键直接给我去掉了

01:45.070 --> 01:46.070
那这些公司怎么办

01:46.070 --> 01:48.070
他们还活不活

01:48.070 --> 01:49.070
比方一个公司

01:49.070 --> 01:51.070
它写了好几万个内主键

01:51.070 --> 01:53.070
你要它怎么活

01:53.070 --> 01:55.070
一些公司专门来做主键的公司

01:55.070 --> 01:56.070
它写了很多内主键

01:56.070 --> 01:58.070
让它这么活

01:58.070 --> 01:59.070
对吧

01:59.070 --> 02:01.070
所以说内公司它要去改造

02:01.070 --> 02:03.070
把内主键改造成 hook

02:03.070 --> 02:05.070
成本太过于高昂了

02:05.070 --> 02:06.070
所以说react

02:06.070 --> 02:09.070
它的官方文档里面说到 hook 的时候

02:09.070 --> 02:10.070
反复强调

02:10.070 --> 02:12.070
hook 真的你们不要担心

02:12.070 --> 02:13.070
不要害怕

02:13.070 --> 02:15.070
我绝对不会伤害你们的

02:15.070 --> 02:17.070
hook 这个东西是一个见尽式的东西

02:17.070 --> 02:20.070
就是说你可以慢慢的转换成 hook

02:20.070 --> 02:21.070
我们从来不也有说

02:21.070 --> 02:23.070
我要去取消内主键

02:23.070 --> 02:25.070
而且你们之前用内主键

02:25.070 --> 02:26.070
用的很熟悉的

02:26.070 --> 02:28.070
不愿意用 hook 随便用

02:28.070 --> 02:29.070
内主键随便用

02:29.070 --> 02:30.070
不会有任何问题

02:30.070 --> 02:32.070
完全支持

02:32.070 --> 02:34.070
所以说你们以后

02:34.070 --> 02:36.070
到了公司里面

02:36.070 --> 02:38.070
它不会说

02:38.070 --> 02:40.070
有了 hook 这个新东西之后

02:40.070 --> 02:41.070
就一定要转成 hook

02:41.070 --> 02:42.070
虽然我个人觉得

02:42.070 --> 02:44.070
hook 它用起来的

02:44.070 --> 02:46.070
肯定要比内主键舒服了很多

02:46.070 --> 02:48.070
但是公司它不一定选择

02:48.070 --> 02:50.070
使用 hook

02:50.070 --> 02:52.070
为什么呢

02:52.070 --> 02:54.070
这给大家想一个题外话吧

02:54.070 --> 02:56.070
就是选择什么样的

02:56.070 --> 02:58.070
公司选择什么样的技术

02:58.070 --> 03:00.070
它看到了不是说

03:00.070 --> 03:02.070
这个技术本身好不好

03:02.070 --> 03:04.070
那这样的想法

03:04.070 --> 03:06.070
我就觉得如果真的是一个

03:06.070 --> 03:07.070
比较要技术总监

03:07.070 --> 03:08.070
或者是架构师

03:08.070 --> 03:09.070
级别的人

03:09.070 --> 03:11.070
那么它在选择这个技术的时候

03:11.070 --> 03:13.070
它真的是 no b

03:13.070 --> 03:14.070
绝对是 no b

03:14.070 --> 03:15.070
它如果用这个技术

03:15.070 --> 03:16.070
本身的好坏来判断

03:16.070 --> 03:18.070
这个技术该不该去使用的话

03:18.070 --> 03:20.070
应该正确的做法

03:20.070 --> 03:22.070
正确的实度应该是用什么来判断

03:22.070 --> 03:24.070
要不要有选择哪个技术

03:24.070 --> 03:25.070
怎么来判断

03:25.070 --> 03:27.070
钱啊

03:27.070 --> 03:28.070
公司在干嘛的

03:28.070 --> 03:29.070
公司赚钱的啊

03:29.070 --> 03:31.070
你要给公司节约成本啊

03:31.070 --> 03:32.070
要看钱

03:32.070 --> 03:34.070
一切都是看钱的

03:34.070 --> 03:35.070
比方说我一个技术来了

03:35.070 --> 03:36.070
一个新技术来了

03:36.070 --> 03:37.070
我决定下一个项目

03:37.070 --> 03:38.070
要不要上那个新技术

03:38.070 --> 03:39.070
我要算什么

03:39.070 --> 03:40.070
比方说我以前在公司里面

03:40.070 --> 03:41.070
做技术总监

03:41.070 --> 03:42.070
我要算什么

03:42.070 --> 03:43.070
我要算成本

03:43.070 --> 03:45.070
我们公司里面

03:45.070 --> 03:46.070
我们的员工

03:46.070 --> 03:47.070
我的下属

03:47.070 --> 03:48.070
我要非常了解

03:48.070 --> 03:49.070
他们学习一个新东西

03:49.070 --> 03:51.070
需要经过多少时间

03:51.070 --> 03:52.070
大概是下来

03:52.070 --> 03:53.070
我要给他们培训

03:53.070 --> 03:54.070
我需要花多少时间

03:54.070 --> 03:56.070
他们要花多少时间

03:56.070 --> 03:58.070
然后他们从那个

03:58.070 --> 03:59.070
能够知道怎么用

03:59.070 --> 04:00.070
到彻底的掌握它

04:00.070 --> 04:01.070
需要花多少时间

04:01.070 --> 04:02.070
我全部要算出来

04:02.070 --> 04:03.070
算出来之后

04:03.070 --> 04:04.070
我们再算成本

04:04.070 --> 04:05.070
这中间的公司

04:05.070 --> 04:06.070
得损失多少

04:06.070 --> 04:07.070
那么这个损失

04:07.070 --> 04:08.070
我们将来用这个技术

04:08.070 --> 04:10.070
它能不能弥补这个损失

04:10.070 --> 04:11.070
而且这个技术

04:11.070 --> 04:12.070
它成不成熟

04:12.070 --> 04:13.070
它有没有坑

04:13.070 --> 04:14.070
如果说

04:14.070 --> 04:15.070
它有坑的话

04:15.070 --> 04:16.070
或者说

04:16.070 --> 04:17.070
如果它有不确定

04:17.070 --> 04:18.070
有没有坑的话

04:18.070 --> 04:19.070
那么这都是风险

04:19.070 --> 04:20.070
这些都可能会

04:20.070 --> 04:22.070
直接导致工资损失

04:22.070 --> 04:23.070
所以说我不会

04:23.070 --> 04:24.070
而且还要考虑的

04:24.070 --> 04:25.070
它跟先有的系统

04:25.070 --> 04:26.070
能不能有

04:26.070 --> 04:27.070
能不能有好的结合

04:27.070 --> 04:28.070
如果说

04:28.070 --> 04:29.070
它能有好的结合的话

04:29.070 --> 04:30.070
还要好一点

04:30.070 --> 04:31.070
那如果说

04:31.070 --> 04:32.070
我用了它那个东西

04:32.070 --> 04:33.070
导致整个系统

04:33.070 --> 04:34.070
要全部赶

04:34.070 --> 04:35.070
那我疯了

04:35.070 --> 04:36.070
我是吃饱了

04:36.070 --> 04:37.070
没事干嘛

04:37.070 --> 04:38.070
如果自己玩技术的话

04:38.070 --> 04:39.070
可以

04:39.070 --> 04:40.070
做得玩嘛

04:40.070 --> 04:41.070
对不对

04:41.070 --> 04:42.070
那如果说

04:42.070 --> 04:43.070
我是要在公司里面

04:43.070 --> 04:45.070
我绝对不敢上这种技术

04:46.070 --> 04:47.070
比方说cshap

04:47.070 --> 04:48.070
聊点题外话嘛

04:48.070 --> 04:50.070
我特别喜欢cshap这门语言

04:50.070 --> 04:51.070
我已经

04:51.070 --> 04:52.070
以前的课程里面

04:52.070 --> 04:54.070
我反复的告诉大家

04:54.070 --> 04:55.070
我都非常喜欢这种语言

04:55.070 --> 04:56.070
但是语言真的是

04:56.070 --> 04:58.070
涉及的非常非常优雅

04:58.070 --> 04:59.070
但是公司里面

04:59.070 --> 05:00.070
你让我选择

05:00.070 --> 05:01.070
我绝对不会选择cshap

05:01.070 --> 05:02.070
因为它的生态环境很差

05:02.070 --> 05:04.070
生态环境没有佳瓦好

05:04.070 --> 05:05.070
佳瓦这个语言本身

05:05.070 --> 05:06.070
肯定是

05:06.070 --> 05:07.070
从语言特性上来说

05:07.070 --> 05:08.070
是比不上cshap的

05:08.070 --> 05:10.070
你随便去问

05:10.070 --> 05:11.070
那些只要结束了佳瓦

05:11.070 --> 05:12.070
和cshap的人

05:12.070 --> 05:13.070
你随便去问

05:13.070 --> 05:14.070
他一定会这样的回答你

05:14.070 --> 05:15.070
正确的

05:15.070 --> 05:16.070
没问题的

05:16.070 --> 05:17.070
但是为什么要选择佳瓦

05:17.070 --> 05:19.070
生态环境好啊

05:19.070 --> 05:20.070
它可以减少我的开发成本

05:20.070 --> 05:21.070
它有很多现成的东西

05:21.070 --> 05:24.070
而且非常非常成熟的社区

05:24.070 --> 05:26.070
所以说我一定会选择佳瓦

05:26.070 --> 05:27.070
所以大家

05:28.070 --> 05:30.070
当然你们现在是初学者

05:30.070 --> 05:33.070
将来你们会发展到更高的职位

05:33.070 --> 05:34.070
那么你考虑问题

05:34.070 --> 05:35.070
不要总限于技术

05:35.070 --> 05:36.070
总局限于技术

05:36.070 --> 05:38.070
要去从更高的角度

05:38.070 --> 05:40.070
从公社角度去考虑这个问题

05:40.070 --> 05:41.070
所以有些技术呢

05:41.070 --> 05:43.070
确实从技术层面来讲

05:43.070 --> 05:44.070
比方的户口这一个

05:44.070 --> 05:45.070
从技术层面来讲

05:45.070 --> 05:46.070
我肯定很喜欢它

05:46.070 --> 05:47.070
但是你要说

05:47.070 --> 05:48.070
我一个项目里边

05:48.070 --> 05:49.070
我全部要用户口

05:49.070 --> 05:50.070
我绝对不敢

05:51.070 --> 05:52.070
因为他之前写的

05:52.070 --> 05:53.070
很多类组件怎么办

05:53.070 --> 05:54.070
是不是要改造

05:54.070 --> 05:55.070
要改造那些类组件

05:55.070 --> 05:56.070
我打扮

05:57.070 --> 05:58.070
这个层面有多高

05:58.070 --> 05:59.070
很吓人的

05:59.070 --> 06:00.070
而且公司里边

06:00.070 --> 06:01.070
很多员工呢

06:01.070 --> 06:02.070
可能对户口呢

06:02.070 --> 06:03.070
一直半解

06:03.070 --> 06:04.070
或者是有些听过

06:04.070 --> 06:05.070
有些听都没听说过

06:05.070 --> 06:07.070
那怎么来沟通

06:07.070 --> 06:09.070
怎么来协调

06:10.070 --> 06:11.070
那要不要培训

06:11.070 --> 06:12.070
这些全是钱

06:12.070 --> 06:13.070
那考虑到这个东西

06:13.070 --> 06:14.070
我要犹豫了

06:15.070 --> 06:16.070
我可能会说

06:16.070 --> 06:17.070
户口的东西呢

06:17.070 --> 06:18.070
你们可以用了

06:18.070 --> 06:19.070
我批准你们用

06:20.070 --> 06:21.070
批准你们用

06:21.070 --> 06:22.070
你们有能力的去用

06:22.070 --> 06:23.070
我会找个时间

06:23.070 --> 06:24.070
周末吧

06:24.070 --> 06:25.070
比方说晚上

06:25.070 --> 06:26.070
我给大家做一些培训

06:26.070 --> 06:27.070
愿意听的话

06:27.070 --> 06:28.070
来听

06:28.070 --> 06:29.070
当然这些是

06:29.070 --> 06:30.070
关面谈话的话

06:30.070 --> 06:31.070
肯定都必须要来听的

06:34.070 --> 06:35.070
总之你们按用就用

06:35.070 --> 06:36.070
但是呢

06:36.070 --> 06:37.070
我不改造以前的系统

06:37.070 --> 06:38.070
因为这个户口

06:38.070 --> 06:39.070
可能本身就是建计式的

06:39.070 --> 06:40.070
而且react

06:40.070 --> 06:41.070
反不强调这一点

06:41.070 --> 06:42.070
他就怕这些公司

06:42.070 --> 06:44.070
看到一个户口行动性出来了

06:44.070 --> 06:45.070
我就特别担心

06:45.070 --> 06:46.070
内组件是不是要去

06:46.070 --> 06:47.070
取消了

06:47.070 --> 06:48.070
给他们吃一个定性碗

06:48.070 --> 06:49.070
内组件

06:49.070 --> 06:50.070
依然存在

06:50.070 --> 06:51.070
大胆的用

06:52.070 --> 06:53.070
户口呢

06:53.070 --> 06:54.070
以有能力的话

06:54.070 --> 06:55.070
公司有能力的话

06:55.070 --> 06:56.070
就尽量用

06:56.070 --> 06:57.070
没有能力的话

06:57.070 --> 06:58.070
无所谓

06:58.070 --> 06:59.070
直接用内组件

06:59.070 --> 07:00.070
放心

07:00.070 --> 07:01.070
放心

07:01.070 --> 07:02.070
现在没有任何计划

07:02.070 --> 07:03.070
要取消内组件

07:03.070 --> 07:05.070
这才是正确的做法

07:05.070 --> 07:06.070
所以说呢

07:06.070 --> 07:07.070
你们以后呢

07:07.070 --> 07:08.070
有可能有些公司呢

07:08.070 --> 07:09.070
他会用hook

07:09.070 --> 07:11.070
会允许你们用hook

07:11.070 --> 07:12.070
有些公司甚至

07:12.070 --> 07:13.070
根本就不允许

07:13.070 --> 07:15.070
因为他可能

07:15.070 --> 07:17.070
要保证这个代码容易阅读

07:17.070 --> 07:18.070
因为有些公司里面

07:18.070 --> 07:20.070
要进行交互的

07:20.070 --> 07:21.070
一切代码的

07:21.070 --> 07:22.070
可能别人要看的

07:22.070 --> 07:23.070
他为了便于

07:23.070 --> 07:24.070
这个代码阅读呢

07:24.070 --> 07:25.070
有可能别人

07:25.070 --> 07:26.070
不会这个hook

07:26.070 --> 07:27.070
他要求你不能用hook

07:27.070 --> 07:28.070
必须要用内组件

07:28.070 --> 07:29.070
也有可能

07:29.070 --> 07:30.070
如果说公司允许你用的话

07:30.070 --> 07:32.070
那么十字八九

07:32.070 --> 07:33.070
他会跟内组件

07:33.070 --> 07:34.070
连着用

07:34.070 --> 07:35.070
系统里面

07:35.070 --> 07:36.070
既有内组件

07:36.070 --> 07:38.070
既有韩束组件里面

07:38.070 --> 07:39.070
使用hook

07:39.070 --> 07:40.070
没有这意思吧

07:40.070 --> 07:41.070
讲一些题外话

07:42.070 --> 07:43.070
那么这个场景里面

07:43.070 --> 07:44.070
就是一个

07:44.070 --> 07:45.070
韩束组件

07:45.070 --> 07:46.070
和内组件

07:46.070 --> 07:47.070
混折用的情况

07:48.070 --> 07:49.070
比方说

07:50.070 --> 07:51.070
这里有这么一个内组件

07:53.070 --> 07:54.070
有啥意义呢

07:54.070 --> 07:55.070
我觉得没啥意义

07:55.070 --> 07:57.070
就是取这么个例子

07:57.070 --> 07:59.070
这个他不但是一个内组件

07:59.070 --> 08:01.070
还是经过优化过后的

08:01.070 --> 08:02.070
一个存组件

08:02.070 --> 08:03.070
对吧

08:03.070 --> 08:04.070
就说你跟他的属性

08:04.070 --> 08:05.070
他支撑的状态

08:05.070 --> 08:06.070
只要他进行前辟交过后

08:06.070 --> 08:08.070
发现没有发生变化

08:08.070 --> 08:09.070
那么他的组件

08:09.070 --> 08:10.070
他就不会刷新

08:10.070 --> 08:12.070
这是我们之前学过的存组件

08:12.070 --> 08:13.070
好Render

08:13.070 --> 08:14.070
然后他只需要

08:14.070 --> 08:15.070
他只需要属性

08:15.070 --> 08:16.070
他没有状态

08:17.070 --> 08:18.070
返回一个啥呢

08:18.070 --> 08:19.070
返回一个div

08:20.070 --> 08:22.070
div里面写上一个啥

08:22.070 --> 08:24.070
你给我传一个属性进来

08:24.070 --> 08:26.070
我把属性里面的tags

08:26.070 --> 08:27.070
给你显示出来

08:28.070 --> 08:30.070
另外这里有个按钮

08:31.070 --> 08:32.070
这个按钮

08:32.070 --> 08:34.070
是改变文本

08:35.070 --> 08:37.070
点击这个按钮干嘛呢

08:37.070 --> 08:39.070
我想要改变这个文本

08:39.070 --> 08:40.070
但是只是我想

08:40.070 --> 08:41.070
因为这个文本数据

08:41.070 --> 08:42.070
不是我的

08:42.070 --> 08:43.070
我没有权力改变

08:43.070 --> 08:45.070
所以说我只能触发事件

08:45.070 --> 08:47.070
当点击这个按钮的时候

08:47.070 --> 08:48.070
我只能触发事件

08:48.070 --> 08:50.070
你需要把这个事件传给我

08:51.070 --> 08:52.070
这个组件就这么简单

08:52.070 --> 08:54.070
你给我一个文本

08:54.070 --> 08:55.070
然后再告诉我

08:55.070 --> 08:57.070
点了按钮过后要干啥

08:57.070 --> 08:58.070
就行了

08:58.070 --> 08:59.070
其他的我不管了

08:59.070 --> 09:00.070
我把这个文本传

09:00.070 --> 09:02.070
就是显示出来

09:02.070 --> 09:03.070
然后点这个按钮之后

09:03.070 --> 09:04.070
要做什么事情

09:04.070 --> 09:06.070
掉入你给我传递的函数

09:06.070 --> 09:07.070
就完了

09:08.070 --> 09:10.070
为了方便说明这个问题

09:10.070 --> 09:12.070
我在这里打印一个东西

09:12.070 --> 09:14.070
tags这个主线Render

09:14.070 --> 09:15.070
它渲染了

09:16.070 --> 09:18.070
大家看一下

09:18.070 --> 09:19.070
tags这个主线

09:20.070 --> 09:21.070
保存

09:22.070 --> 09:23.070
你看一下这个主线

09:23.070 --> 09:24.070
一开始就渲染了

09:24.070 --> 09:26.070
tags Render

09:26.070 --> 09:27.070
一开始渲染了

09:27.070 --> 09:28.070
没问题吧

09:29.070 --> 09:31.070
那么接下来是这样子

09:31.070 --> 09:33.070
我们要主要这么一个操作出来

09:33.070 --> 09:35.070
这个App里面有一个状态

09:39.070 --> 09:40.070
有什么状态呢

09:40.070 --> 09:41.070
我想想

09:42.070 --> 09:43.070
有什么状态呢

09:43.070 --> 09:44.070
就这样吧

09:46.070 --> 09:47.070
UseState

09:48.070 --> 09:50.070
我给它一个制服创

09:51.070 --> 09:52.070
给它一个制服创

09:52.070 --> 09:53.070
UseState

09:55.070 --> 09:56.070
这么一个制服创

09:57.070 --> 09:59.580
代码端

10:00.580 --> 10:01.580
State

10:02.580 --> 10:03.580
就是TST

10:05.580 --> 10:07.580
默认文本是ABC

10:08.580 --> 10:09.580
这是它的默认文本

10:11.580 --> 10:12.580
接下来

10:12.580 --> 10:13.580
我们在tags里面

10:13.580 --> 10:15.580
它不是需要一个文本吗

10:15.580 --> 10:17.580
我给力这个文本

10:17.580 --> 10:18.580
我把文本给力

10:20.580 --> 10:21.580
然后

10:22.580 --> 10:23.580
你这里

10:23.580 --> 10:25.580
不是有一个unclick吗

10:25.580 --> 10:26.580
对不对

10:26.580 --> 10:27.580
或者说

10:27.580 --> 10:29.580
天天我们使用一个123

10:29.580 --> 10:30.580
123

10:31.580 --> 10:33.580
就随便来吧

10:33.580 --> 10:34.580
然后点击

10:34.580 --> 10:36.580
你不是一个点击事件吗

10:36.580 --> 10:38.580
当点击事件发生的时候

10:38.580 --> 10:39.580
我干嘛呢

10:40.580 --> 10:42.580
我重新设置状态

10:42.580 --> 10:43.580
Set TST

10:44.580 --> 10:45.580
设置为什么呢

10:45.580 --> 10:47.580
设置为一个随机数吗

10:47.580 --> 10:48.580
随便来

10:48.580 --> 10:49.580
随便来

10:50.580 --> 10:52.580
我们为了看到效果

10:52.580 --> 10:53.580
在这里再输出一个

10:53.580 --> 10:55.580
输出一个App Render

10:55.580 --> 10:57.580
这个组件Render

10:57.580 --> 10:58.580
重旋转

10:59.580 --> 11:00.580
你看啊

11:00.580 --> 11:01.580
这个组件如果重旋转的话

11:01.580 --> 11:02.580
会输出Test Render

11:02.580 --> 11:03.580
这个组件重旋转的话

11:03.580 --> 11:04.580
会输出App Render

11:04.580 --> 11:06.580
保存咱们看一下

11:06.580 --> 11:09.020
为什么

11:09.020 --> 11:10.020
我这里说一下

11:10.020 --> 11:11.020
它为什么会旋转两次呢

11:11.020 --> 11:13.020
它不是说旋转两两次

11:13.020 --> 11:15.020
是因为这个玩意

11:15.020 --> 11:17.020
这个玩意

11:17.020 --> 11:19.020
你这个调试工具的原因

11:19.020 --> 11:22.020
这个调试工具你只要选中哪个组件

11:22.020 --> 11:23.020
然后在选中哪个组件的时候

11:23.020 --> 11:25.020
它都会导致它重新旋转

11:25.020 --> 11:26.020
你看它又旋转了几次

11:26.020 --> 11:27.020
对吧

11:27.020 --> 11:29.020
它会把这个跟组件重新旋转

11:30.020 --> 11:31.020
算了吧

11:31.020 --> 11:33.020
我这里换一个组件

11:33.020 --> 11:34.020
大家容易搞成混淆

11:34.020 --> 11:36.020
是个调试工具的原因

11:36.020 --> 11:37.020
以后发布了之后

11:37.020 --> 11:39.020
就不会有这个问题了

11:39.020 --> 11:41.020
Parent

11:41.020 --> 11:43.020
这是副组件

11:43.020 --> 11:44.020
副组件

11:44.020 --> 11:49.180
然后我们把这个副字过来

11:49.180 --> 11:50.180
Parent

11:50.180 --> 11:52.180
这是Parent Render

11:52.180 --> 11:54.180
这里呢

11:54.180 --> 11:55.180
取消掉

11:55.180 --> 11:57.180
这个直线是Parent

11:58.180 --> 11:59.180
OK

11:59.180 --> 12:01.180
写了这么种结构

12:01.180 --> 12:02.180
好

12:02.180 --> 12:03.180
看一下

12:03.180 --> 12:04.180
Parent RenderTest Render

12:04.180 --> 12:05.180
没问题吧

12:06.180 --> 12:07.180
接下来

12:07.180 --> 12:09.180
我们来点击这个组件里面的按钮

12:09.180 --> 12:11.180
点击按钮会导致什么情况

12:11.180 --> 12:14.180
会导致是不是运行这个函数

12:14.180 --> 12:15.180
运行这个函数

12:15.180 --> 12:17.180
是不是得到一个水击数重新生成文本

12:17.180 --> 12:19.180
那么这个文本是不跟之前的不一样了

12:19.180 --> 12:21.180
不一样会导致什么

12:21.180 --> 12:23.180
会导致这个组件是不是要重新运行

12:23.180 --> 12:24.180
这个函数是不是要重新运行

12:24.180 --> 12:26.180
是不是它要运行这个重新旋转

12:26.180 --> 12:27.180
对吧

12:27.180 --> 12:28.180
重新旋转过后

12:28.180 --> 12:29.180
得到了新的状态

12:29.180 --> 12:31.180
新的状态是不是个水击数的值

12:31.180 --> 12:34.180
然后再把水击数的值传给它

12:35.180 --> 12:37.180
也导致它的属性发生了变化

12:37.180 --> 12:38.180
它的属性发生了变化

12:38.180 --> 12:39.180
是不是它要重新旋转

12:39.180 --> 12:40.180
这个没什么好说的

12:40.180 --> 12:42.180
这个都是以前的很基础的知识的

12:42.180 --> 12:43.180
看一下

12:43.180 --> 12:44.180
点击

12:44.180 --> 12:45.180
你看是不是两个都要重新旋转

12:45.180 --> 12:46.180
再点击

12:46.180 --> 12:47.180
是不是两个都重新旋转

12:47.180 --> 12:48.180
再点击重新旋转

12:49.180 --> 12:50.180
没问题吧

12:50.180 --> 12:51.180
接下来

12:51.180 --> 12:52.180
让我们来看另外一个

12:53.180 --> 12:54.180
很奇怪的现象

12:55.180 --> 12:56.180
我这里

12:56.180 --> 12:58.180
给它设置为123

12:59.180 --> 13:00.180
是不是跟原来的值一样

13:02.180 --> 13:03.180
是不是跟原来的值一样

13:04.180 --> 13:05.180
接下来我们看一下

13:05.180 --> 13:06.180
你们能不能分析出

13:06.180 --> 13:08.180
它现在我点击之后

13:08.180 --> 13:09.180
这里会输出什么

13:10.180 --> 13:12.180
利用以前学过的知识

13:12.180 --> 13:14.180
点击之后这里会输出什么

13:15.180 --> 13:16.180
会输出什么

13:17.180 --> 13:18.180
啥都没输出

13:19.180 --> 13:21.180
为什么啥都没输出

13:21.180 --> 13:23.180
现在比方说选择题

13:23.180 --> 13:24.180
那么我问你

13:24.180 --> 13:25.180
为什么啥都没输出

13:25.180 --> 13:27.180
是因为它重新

13:27.180 --> 13:28.180
它一个选择题是

13:28.180 --> 13:30.180
它没有重新旋转

13:30.180 --> 13:32.180
另外一个选择题是

13:32.180 --> 13:33.180
另外一个选项是

13:33.180 --> 13:34.180
它没有重新旋转

13:35.180 --> 13:36.180
好像都有道理

13:37.180 --> 13:38.180
它没有重新旋转

13:38.180 --> 13:39.180
为什么呢

13:39.180 --> 13:40.180
因为它是一个存住键

13:40.180 --> 13:41.180
属性只没有发生变化

13:41.180 --> 13:42.180
它不会导致重新旋转

13:43.180 --> 13:44.180
是这样吗

13:45.180 --> 13:46.180
是这样吗

13:46.180 --> 13:47.180
如果真的是这样的话

13:47.180 --> 13:49.180
那这句话是不是应该输出

13:49.180 --> 13:50.180
为啥这句话也没有输出

13:51.180 --> 13:52.180
为什么

13:52.180 --> 13:53.180
我讲过的

13:53.180 --> 13:54.180
不要全部扔给我了

13:55.180 --> 13:56.180
讲过的

13:56.180 --> 13:57.180
这个set-t

13:58.180 --> 13:59.180
这个设置状态这个函数

14:00.180 --> 14:01.180
它是不是要比较

14:01.180 --> 14:02.180
当前你传的状态

14:03.180 --> 14:04.180
跟它之前的状态

14:04.180 --> 14:05.180
用objects

14:05.180 --> 14:06.180
一直来比较

14:06.180 --> 14:07.180
是不是相等的

14:07.180 --> 14:08.180
如果相等

14:08.180 --> 14:09.180
是不是不会导致触发

14:09.180 --> 14:10.180
它本身的旋转

14:10.180 --> 14:12.180
它本身的旋转都没有触发

14:12.180 --> 14:13.180
跟它有没有关系

14:13.180 --> 14:15.180
是没有任何关系

14:15.180 --> 14:16.180
对吧

14:16.180 --> 14:17.180
跟它没有任何关系

14:17.180 --> 14:19.180
它本身的状态都没有触发

14:19.180 --> 14:20.180
明白这个意思吗

14:21.180 --> 14:22.180
明白这个意思吗

14:23.180 --> 14:24.180
是不是

14:24.180 --> 14:25.180
不会导致它

14:25.180 --> 14:27.180
所以它本身都没有重新旋转

14:27.180 --> 14:29.180
它自然不会重新旋转了

14:30.180 --> 14:31.180
所以说是这么一种情况

14:31.180 --> 14:32.180
是这么一种情况

14:33.180 --> 14:34.180
好

14:34.180 --> 14:35.180
那么接下来

14:35.180 --> 14:37.180
我们再来看一下

14:37.180 --> 14:39.180
假设这个组件里边

14:39.180 --> 14:41.180
它不仅仅有这个组件

14:41.180 --> 14:42.180
还有一个组件

14:43.180 --> 14:45.180
事情就变得非常有趣起来

14:45.180 --> 14:50.930
它还有一个组件

14:50.930 --> 14:51.930
这个组件是一个文本框

14:52.930 --> 14:53.930
一个文本框

14:54.930 --> 14:55.930
这个文本框

14:56.930 --> 14:57.930
是一个number

14:57.930 --> 14:58.930
是一个number

14:59.930 --> 15:00.930
接下来我们看一下

15:01.930 --> 15:02.930
我们又加一个状态

15:02.930 --> 15:04.930
我们知道状态可以有很多的

15:06.930 --> 15:08.930
number n

15:10.930 --> 15:11.930
这里呢

15:11.930 --> 15:12.930
use that

15:13.930 --> 15:14.930
从零开始

15:14.930 --> 15:15.930
从零开始

15:15.930 --> 15:16.930
那么把它变成个受控组件

15:17.930 --> 15:19.930
value等于n

15:20.930 --> 15:21.930
set

15:21.930 --> 15:22.930
不

15:22.930 --> 15:26.070
unchange

15:26.070 --> 15:27.070
change

15:27.070 --> 15:28.070
等于啥呢

15:28.070 --> 15:29.070
e

15:29.070 --> 15:30.070
当变化的时候

15:30.070 --> 15:31.070
我们set n

15:31.070 --> 15:33.070
然后把它pose int

15:34.070 --> 15:35.070
pose int

15:35.070 --> 15:37.070
e.target.value

15:37.070 --> 15:38.070
这个没什么好说的

15:39.070 --> 15:40.070
好

15:40.070 --> 15:41.070
再看一下

15:41.070 --> 15:42.070
保存

15:43.070 --> 15:44.070
一开始没问题吧

15:44.070 --> 15:45.070
副组件圈的

15:45.070 --> 15:46.070
植入件圈的

15:46.070 --> 15:47.070
没问题吧

15:47.070 --> 15:48.070
好 接下来

15:48.070 --> 15:50.070
点这个文本是不是没用

15:50.070 --> 15:51.070
因为

15:51.070 --> 15:52.070
它前后两个字是一样的

15:52.070 --> 15:53.070
对不对

15:53.070 --> 15:54.070
前后两个字是一样的

15:54.070 --> 15:55.070
所以说不会重新圈的

15:55.070 --> 15:56.070
点这个东西没用

15:57.070 --> 15:59.070
关键是点

15:59.070 --> 16:00.070
等等

16:00.070 --> 16:01.070
等等

16:03.070 --> 16:04.070
但是我们现在点这个

16:05.070 --> 16:06.070
哇

16:06.070 --> 16:08.070
事情就发生问题了

16:08.070 --> 16:10.070
点这个东西

16:10.070 --> 16:11.070
你看一下

16:11.070 --> 16:12.070
是不是

16:12.070 --> 16:13.070
这个值不一样了

16:13.070 --> 16:14.070
跟之前的n

16:14.070 --> 16:16.070
跟之前的n的值不一样了

16:16.070 --> 16:18.070
不一样的话

16:18.070 --> 16:20.070
这个组件重新宣展有没有问题

16:20.070 --> 16:22.070
这个组件是不是应该重新宣展

16:22.070 --> 16:23.070
对吧

16:23.070 --> 16:25.070
它要重新宣展没问题

16:25.070 --> 16:26.070
但是为什么

16:26.070 --> 16:28.070
它也跟着重新宣展呢

16:28.070 --> 16:30.070
它的数据有没有变化

16:30.070 --> 16:31.070
你看

16:31.070 --> 16:33.070
它的数据有跟它一啥关系呢

16:33.070 --> 16:35.070
它数据没有变化

16:36.070 --> 16:37.070
而且

16:37.070 --> 16:38.070
如果说

16:38.070 --> 16:39.070
如果说它是一个普通组件

16:39.070 --> 16:40.070
那肯定要重新宣展

16:40.070 --> 16:41.070
这个没问题

16:41.070 --> 16:42.070
但是如果

16:42.070 --> 16:44.070
它是一个存组件

16:44.070 --> 16:46.070
存组件会进行比较的

16:46.070 --> 16:47.070
你之前给它属性值

16:47.070 --> 16:48.070
跟现在的属性值

16:48.070 --> 16:49.070
是不是一致的

16:49.070 --> 16:50.070
如果一致

16:50.070 --> 16:51.070
我就不会重新宣展

16:51.070 --> 16:52.070
对吧

16:52.070 --> 16:53.070
这是存组件它有优化的

16:53.070 --> 16:55.070
那为什么它也跟着重新宣展呢

16:55.070 --> 16:57.070
什么问题呢

16:57.070 --> 16:58.070
它这么多时间告诉大家

16:58.070 --> 17:00.070
给大家解释

17:00.070 --> 17:01.070
就是因为

17:01.070 --> 17:02.070
我希望每一个知识点

17:02.070 --> 17:05.070
希望大家搞清楚

17:05.070 --> 17:06.070
不要学一半

17:06.070 --> 17:07.070
有这么一个印象

17:07.070 --> 17:08.070
没有什么意义

17:08.070 --> 17:10.070
要把搞清楚

17:10.070 --> 17:12.070
那现在为什么它要重新宣展

17:12.070 --> 17:13.070
你看一下

17:13.070 --> 17:14.070
你千万不要认为

17:14.070 --> 17:15.070
这是什么八个呀

17:15.070 --> 17:16.070
什么新知识

17:16.070 --> 17:17.070
没有任何新知识

17:17.070 --> 17:18.070
它是个存组件

17:18.070 --> 17:20.070
它一定会进行前比较

17:20.070 --> 17:22.070
那为什么没有重新宣展呢

17:22.070 --> 17:23.070
首先我们来判断

17:23.070 --> 17:24.070
这个属性值有没有变化

17:24.070 --> 17:26.070
是不是一定没有变化

17:26.070 --> 17:27.070
这两个制服车

17:27.070 --> 17:28.070
两个制服车比较

17:28.070 --> 17:29.070
一比较肯定是相等的

17:29.070 --> 17:30.070
对吧

17:30.070 --> 17:31.070
而且显示出来也是一样的

17:31.070 --> 17:32.070
一二三

17:32.070 --> 17:33.070
一直都没变

17:33.070 --> 17:34.070
说这个属性一定没问题

17:34.070 --> 17:35.070
那么所以说

17:35.070 --> 17:37.070
排除掉这个属性值的变化的话

17:37.070 --> 17:38.070
只有一种可能

17:38.070 --> 17:40.070
就这个属性值发生了变化

17:40.070 --> 17:41.070
而实际上

17:41.070 --> 17:42.070
你看就知道了

17:42.070 --> 17:43.070
确实

17:43.070 --> 17:45.070
是这个属性值发生了变化

17:45.070 --> 17:46.070
为什么

17:46.070 --> 17:47.070
因为每一次运行

17:47.070 --> 17:48.070
这个函数的时候

17:48.070 --> 17:51.070
是不是创建了一个新的函数

17:51.070 --> 17:52.070
一个新的函数

17:52.070 --> 17:54.070
是不是一个新的地址

17:54.070 --> 17:56.070
函数是对象

17:56.070 --> 17:57.070
一个新的地址

17:57.070 --> 17:58.070
是不是跟之前的地址

17:58.070 --> 17:59.070
就不一样了

17:59.070 --> 18:00.070
结果它的功能完全一样

18:00.070 --> 18:02.070
但它地址不一样

18:02.070 --> 18:04.070
甭管这里写的是一二三

18:04.070 --> 18:07.070
还是Mesh点Random

18:07.070 --> 18:09.070
Mesh原来Random是一样的

18:09.070 --> 18:11.070
你看我没有点这个按钮

18:11.070 --> 18:12.070
我点到这个关卡卡的时候

18:12.070 --> 18:14.070
为什么它要重新宣传

18:14.070 --> 18:17.070
就是因为这个函数的地址变了

18:17.070 --> 18:19.070
大概做什么

18:19.070 --> 18:22.070
函数的地址

18:22.070 --> 18:23.070
每次渲染

18:23.070 --> 18:26.070
都发生了变化

18:26.070 --> 18:29.070
导致了直主键

18:29.070 --> 18:32.070
跟着重新宣传

18:32.070 --> 18:35.070
若直主键

18:35.070 --> 18:39.070
是经过优化的逐渐

18:39.070 --> 18:41.070
这导致了

18:41.070 --> 18:42.070
这可能

18:42.070 --> 18:43.070
因为这个优化

18:43.070 --> 18:45.070
可能是pure component

18:45.070 --> 18:46.070
也可能自己写的优化

18:46.070 --> 18:47.070
所以说要用可能

18:47.070 --> 18:48.070
因为你自己写的优化

18:48.070 --> 18:50.070
我就不知道你咋写的了

18:50.070 --> 18:52.070
这可能

18:52.070 --> 18:54.070
导致优化失效

18:54.070 --> 18:56.070
这是个问题

18:56.070 --> 19:00.070
Rx官方他想的非常非常细

19:00.070 --> 19:01.070
那么这个问题既然出现了

19:01.070 --> 19:02.070
我把它复制一下

19:02.070 --> 19:03.070
既然出现了

19:03.070 --> 19:05.070
怎么来解决这个问题呢

19:05.070 --> 19:06.070
我就必须

19:06.070 --> 19:07.070
是不是必须要保证那个地址一致

19:07.070 --> 19:09.070
你还能怎么办呢

19:09.070 --> 19:10.070
你还能怎么办

19:10.070 --> 19:12.070
是不是必须要保证那个地址一致

19:12.070 --> 19:13.070
对吧

19:13.070 --> 19:15.070
要保证那个地址一致

19:15.070 --> 19:17.070
那这个地址咋一致呢

19:17.070 --> 19:18.070
你告诉我咋一致呢

19:18.070 --> 19:19.070
这个地址

19:19.070 --> 19:22.070
比如说我写的外面行不行

19:22.070 --> 19:25.070
我把这个函数写外面

19:25.070 --> 19:27.070
就是handle

19:27.070 --> 19:29.070
写的外面当然地址是一个地址

19:29.070 --> 19:31.070
handle什么click

19:31.070 --> 19:32.070
handleclick

19:32.070 --> 19:33.070
写外面吧

19:33.070 --> 19:34.070
把这个函数

19:34.070 --> 19:35.070
然后呢

19:35.070 --> 19:36.070
这个函数里面调用这个

19:36.070 --> 19:37.070
对吧

19:37.070 --> 19:38.070
然后呢

19:38.070 --> 19:40.070
把这个函数写过来

19:40.070 --> 19:41.070
handleclick

19:41.070 --> 19:42.070
你写过来

19:42.070 --> 19:44.070
我发现这个set 贴梯哪来呢

19:44.070 --> 19:45.070
你告诉我

19:45.070 --> 19:46.070
从哪里去得到这个玩意

19:46.070 --> 19:48.070
有同学说参数

19:48.070 --> 19:50.070
你把set 贴梯充的参数传给我

19:50.070 --> 19:52.070
那怎么来传呢

19:52.070 --> 19:54.070
如果说你学read

19:54.070 --> 19:56.070
学到现在你给我写这个函数

19:56.070 --> 19:58.070
我叫冒火了

19:58.070 --> 20:00.070
然后这样子写我就冒火了

20:00.070 --> 20:01.070
read里面能不能这样子写

20:01.070 --> 20:02.070
vue里面是可以

20:02.070 --> 20:04.070
read里面是绝对不能这样写的

20:04.070 --> 20:06.070
很多人都在抨击这个vue里面

20:06.070 --> 20:08.070
它这种函数写的非常不不要准

20:08.070 --> 20:09.070
一会呢也函数调用

20:09.070 --> 20:11.070
以后呢又传的是函数本身

20:11.070 --> 20:12.070
不要这样

20:12.070 --> 20:13.070
不能这样写

20:13.070 --> 20:14.070
read这里

20:14.070 --> 20:15.070
它只有一个统一的做法

20:15.070 --> 20:16.070
传函数

20:16.070 --> 20:17.070
那你这样做是什么意思

20:17.070 --> 20:18.070
是调用这个函数

20:18.070 --> 20:20.070
把这个函数的返回结果

20:20.070 --> 20:22.070
作为这个属性值

20:22.070 --> 20:23.070
那肯定不行啊

20:23.070 --> 20:24.070
那这里怎么弄呢

20:24.070 --> 20:26.070
搞了半天发现没法了

20:26.070 --> 20:27.070
除非你这样子

20:27.070 --> 20:28.070
你这样子是可以的

20:28.070 --> 20:29.070
band

20:29.070 --> 20:31.070
band now

20:31.070 --> 20:32.070
band now

20:32.070 --> 20:33.070
然后把这个set 贴梯

20:33.070 --> 20:35.070
作为参数传过来

20:35.070 --> 20:36.070
对吧 用band

20:36.070 --> 20:37.070
band会返回一个新的函数嘛

20:37.070 --> 20:38.070
对不对

20:38.070 --> 20:40.070
那但是这样子有用吗

20:40.070 --> 20:41.070
有用吗

20:41.070 --> 20:42.070
是不是还要跟着宣展

20:42.070 --> 20:43.070
为什么

20:43.070 --> 20:44.070
为什么要跟着宣展

20:44.070 --> 20:46.070
是因为这个band 这个函数

20:46.070 --> 20:48.070
它也会返回一个新的函数

20:48.070 --> 20:50.070
然后你就抓狂了

20:50.070 --> 20:51.070
你真的就抓狂了

20:51.070 --> 20:52.070
也不知道该怎么办了

20:52.070 --> 20:54.070
你会发现用什么办法都不行了

20:54.070 --> 20:55.070
于是呢

20:55.070 --> 20:56.070
如果挨个城呢

20:56.070 --> 20:58.070
它给你了一个出路

20:58.070 --> 21:00.070
不然的话你真的要疯掉了

21:00.070 --> 21:02.070
它给你一个什么出路呢

21:02.070 --> 21:05.070
它可以让你用这个

21:05.070 --> 21:06.070
一个勾字函数

21:06.070 --> 21:09.070
叫做use callback

21:09.070 --> 21:12.070
这个函数它是这么一个特点

21:14.070 --> 21:15.070
做个笔记啊

21:16.070 --> 21:18.070
关于这个use callback

21:19.070 --> 21:20.070
是大写吗

21:20.070 --> 21:21.070
必是不大写

21:22.070 --> 21:23.070
use call

21:23.070 --> 21:24.070
不是大写

21:25.070 --> 21:26.070
这个函数

21:26.070 --> 21:27.070
它怎么用

21:29.580 --> 21:33.580
该函数有两个函数

21:34.580 --> 21:35.580
哪两个函数呢

21:35.580 --> 21:37.580
第一个函数

21:37.580 --> 21:39.580
是一个函数

21:42.580 --> 21:44.580
use callback

21:44.580 --> 21:45.580
这个勾字函数

21:45.580 --> 21:48.580
会固定该函数的引用

21:51.580 --> 21:56.580
只要依赖项没有发生变化

21:56.580 --> 21:59.580
只要你的依赖项没有发生变化

21:59.580 --> 22:03.580
则会保持

22:03.580 --> 22:05.580
则会保持

22:05.580 --> 22:08.580
之前函数的地址

22:08.580 --> 22:09.580
则会

22:09.580 --> 22:11.580
则始终返回

22:11.580 --> 22:12.580
这样说吧

22:13.580 --> 22:15.580
则始终返回

22:15.580 --> 22:17.580
之前函数的地址

22:17.580 --> 22:19.580
第二个产生的是一个数组

22:20.580 --> 22:22.580
记录依赖项

22:22.580 --> 22:24.580
跟那个effect是差不多的

22:24.580 --> 22:25.580
依赖项

22:25.580 --> 22:26.580
依赖项变化的时候

22:26.580 --> 22:28.580
它会用新的函数地址

22:28.580 --> 22:30.580
否则的话始终用之前的函数地址

22:31.580 --> 22:33.580
因为这个函数它返回

22:33.580 --> 22:35.580
该函数返回

22:36.580 --> 22:41.580
就是引用相对固定的函数地址

22:43.580 --> 22:45.580
我举个例子就明白了

22:45.580 --> 22:47.580
这个u是callback

22:47.580 --> 22:48.580
它第一个参数传达

22:48.580 --> 22:49.580
是传函数

22:49.580 --> 22:51.580
这个函数是啥

22:51.580 --> 22:53.580
这个函数就是我们刚才写的

22:53.580 --> 22:56.580
刚才写的set tst

22:56.580 --> 22:58.580
mess.redem

22:58.580 --> 23:00.580
写的就是这个玩意

23:00.580 --> 23:01.580
第二个参数传达

23:01.580 --> 23:03.580
传依赖项

23:03.580 --> 23:05.580
比方说我们就用这个依赖项

23:05.580 --> 23:07.580
这个依赖项是空数

23:07.580 --> 23:08.580
它不依赖任何东西

23:08.580 --> 23:10.580
这个函数返回啥

23:10.580 --> 23:12.580
返回的就是一个函数

23:12.580 --> 23:14.580
返回的就是一个函数地址

23:14.580 --> 23:16.580
函数地址就是函数

23:16.580 --> 23:18.580
就是函数

23:18.580 --> 23:20.580
看着它是什么回事

23:20.580 --> 23:22.580
它第一次调用Parent的时候

23:22.580 --> 23:24.580
第一次运行Parent的时候

23:24.580 --> 23:26.580
那么你给它传那个函数进去

23:26.580 --> 23:28.580
那么这个时候

23:28.580 --> 23:30.580
它会直接把这个函数的地址给理

23:30.580 --> 23:33.580
它会直接把这个函数本身给理

23:33.580 --> 23:35.580
返回出来

23:35.580 --> 23:37.580
然后下一次在运行的时候

23:37.580 --> 23:39.580
它判断它会判断依赖项有没有变

23:39.580 --> 23:41.580
比方说你这里写的空数主

23:41.580 --> 23:43.580
它不依赖任何东西

23:43.580 --> 23:45.580
那么这个依赖项它没有变化

23:45.580 --> 23:47.580
没有变化

23:47.580 --> 23:49.580
也虽然说给它传了一个新函数进去

23:49.580 --> 23:51.580
但是它仍然会返回之前的引用

23:51.580 --> 23:53.580
它会保证引用不变

23:53.580 --> 23:55.580
相对固定

23:55.580 --> 23:57.580
除非说你这个依赖项发生变化了

23:57.580 --> 23:59.580
那么它会用新的函数地址给你返回

23:59.580 --> 24:01.580
就这么个意识

24:01.580 --> 24:03.580
跟Fx的差不多一个依赖项变化的时候

24:03.580 --> 24:04.580
做什么

24:04.580 --> 24:06.580
依赖项没变化会做什么

24:06.580 --> 24:08.580
它主要是在固定函数的引用地址的

24:08.580 --> 24:09.580
引用是一样的

24:09.580 --> 24:11.580
那么这样的进展就不会出问题了

24:11.580 --> 24:12.580
保存

24:12.580 --> 24:13.580
你看一下

24:13.580 --> 24:14.580
我这里改变

24:14.580 --> 24:15.580
它只选择了Parent

24:15.580 --> 24:18.580
因为直逐渐它传的函数地址是一样的

24:18.580 --> 24:19.580
这个属性值

24:19.580 --> 24:21.580
这个当然也是一样

24:21.580 --> 24:23.580
所以说它只逐渐没有重新宣传

24:23.580 --> 24:24.580
因为它经过优化了

24:24.580 --> 24:26.580
它就可以沿用直逐渐的优化

24:26.580 --> 24:27.580
明白我的意思吗

24:27.580 --> 24:28.580
当然如果你改变这个

24:28.580 --> 24:29.580
当然它都重新宣传

24:29.580 --> 24:30.580
这个没什么好说的

24:30.580 --> 24:31.580
它属性变了

24:31.580 --> 24:32.580
要重新宣传

24:32.580 --> 24:33.580
但是你动这个

24:33.580 --> 24:34.580
是没有发生变化的

24:34.580 --> 24:35.580
看没

24:35.580 --> 24:37.580
就这个玩意还没有别的用处

24:37.580 --> 24:38.580
它就是说

24:38.580 --> 24:40.580
来固定一个函数引用地址

24:40.580 --> 24:42.580
来解决有的时候解决一些问题

24:42.580 --> 24:44.580
反而是我们以后发现了

24:44.580 --> 24:46.580
在用Hook的时候

24:46.580 --> 24:47.580
特别在函数组建里面

24:47.580 --> 24:48.580
用Hook的时候

24:48.580 --> 24:50.580
发现了有些依赖箱

24:50.580 --> 24:51.580
或者是比方说Effect

24:51.580 --> 24:52.580
我们之前的副作用函数

24:52.580 --> 24:53.580
它不是有依赖箱吗

24:53.580 --> 24:55.580
有的是要依赖一个函数本身

24:55.580 --> 24:57.580
那如果函数引用地址发生了变化

24:57.580 --> 24:59.580
也会导致依赖箱发生变化

24:59.580 --> 25:01.580
就总之有的是有一些问题

25:01.580 --> 25:04.580
它是由于函数的不同地址导致的

25:04.580 --> 25:06.580
我们就可以使用Callback

25:06.580 --> 25:08.580
来固定这个引用地址

25:08.580 --> 25:10.580
不然的话你找不到别的办法来做

25:10.580 --> 25:13.580
这就是它的作用

25:13.580 --> 25:16.580
来固定一个函数的引用地址的

25:16.580 --> 25:18.580
只要依赖箱没有发生变化

25:18.580 --> 25:21.580
那么就使用之前的地址

25:21.580 --> 25:22.580
而不再去新建函数了

25:22.580 --> 25:24.580
尽管说你这一句话

25:24.580 --> 25:25.580
肯定是新建的函数

25:25.580 --> 25:27.580
但是它不会

25:27.580 --> 25:29.580
它会忽略掉新的函数

25:29.580 --> 25:31.580
而使用之前的函数

25:31.580 --> 25:32.580
只要依赖箱没发生变化

25:32.580 --> 25:34.580
当然依赖箱如果发生了变化

25:34.580 --> 25:36.580
那就不一样

25:36.580 --> 25:37.580
比方说

25:37.580 --> 25:38.580
我们这里

25:38.580 --> 25:41.580
其实是E每次点了过后加E

25:41.580 --> 25:42.580
每次点了过加E

25:42.580 --> 25:45.580
那么setsTST

25:45.580 --> 25:47.580
TST

25:47.580 --> 25:49.580
这里是什么写什么

25:49.580 --> 25:52.580
加E

25:52.580 --> 25:53.580
没问题

25:53.580 --> 25:54.580
TST加E

25:54.580 --> 25:56.580
那么这里

25:56.580 --> 25:57.580
一代箱是不是要改了

25:57.580 --> 25:58.580
是要改成一个TST

25:58.580 --> 26:00.580
TST发生变化了

26:00.580 --> 26:01.580
它可以变

26:01.580 --> 26:03.580
一TST都变了过后

26:03.580 --> 26:05.580
一TST都变了

26:05.580 --> 26:06.580
它也可以变

26:06.580 --> 26:08.580
你反正都要重新宣展

26:08.580 --> 26:10.580
那么它依赖了这个东西

26:10.580 --> 26:11.580
它依赖了这个东西

26:11.580 --> 26:12.580
那么就可以这样子写了

26:12.580 --> 26:14.580
保存

26:14.580 --> 26:15.580
那么你看一下

26:15.580 --> 26:17.580
改变文本

26:17.580 --> 26:18.580
都没问题

26:18.580 --> 26:19.580
这里就不会变化了

26:19.580 --> 26:20.580
因为这样子

26:20.580 --> 26:22.580
TST没发生变化

26:22.580 --> 26:23.580
TST没发生变化

26:23.580 --> 26:25.580
那么函数引用也没有发生变化

26:25.580 --> 26:27.580
就这么个意思

26:27.580 --> 26:29.580
它是来固定函数引用的

26:29.580 --> 26:31.580
就是这么一个

26:31.580 --> 26:32.580
固可函数

26:32.580 --> 26:33.580
callback

