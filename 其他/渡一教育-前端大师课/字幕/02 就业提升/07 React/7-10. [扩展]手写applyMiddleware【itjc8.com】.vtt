WEBVTT

00:00.430 --> 00:04.430
来吧 我们就熟悉一个Apply Mid-Ware

00:04.430 --> 00:06.430
就是这里

00:06.430 --> 00:09.430
我们之前不是用Apply Mid-Ware对吧

00:09.430 --> 00:12.430
用它来应用我们的中间键

00:12.430 --> 00:14.430
Apply Mid-Ware

00:14.430 --> 00:17.430
熟悉的话你就必须要用这种方式了

00:17.430 --> 00:20.430
因为用创建Creative Stone这种方式

00:20.430 --> 00:23.430
其实它本质上也会调用这种方式

00:23.430 --> 00:24.430
我们到时候会写

00:24.430 --> 00:27.430
最终我们得把这个方法写出来

00:27.430 --> 00:28.430
Apply Mid-Ware

00:28.430 --> 00:31.430
那么它就是一层一层返回

00:31.430 --> 00:33.430
固定了很多的参数

00:33.430 --> 00:35.430
这里我们在一位大课室里边去新建个文件

00:35.430 --> 00:39.430
给它取个名字就叫做Apply Mid-Ware

00:39.430 --> 00:41.430
叫解释

00:41.430 --> 00:43.430
那么这里边是不是导出一个

00:43.430 --> 00:44.430
导出一个什么

00:44.430 --> 00:45.430
导出一个方法

00:45.430 --> 00:47.430
方个形

00:47.430 --> 00:49.430
默认导出一个完事了

00:49.430 --> 00:51.430
那么这里我们还是按照惯例

00:51.430 --> 00:53.430
我们在这里重新导出

00:55.430 --> 00:57.430
Apply Mid-Ware

00:57.430 --> 00:59.430
咱们把这里重新导出

00:59.430 --> 01:00.430
好了

01:00.430 --> 01:01.430
行了

01:01.430 --> 01:03.430
那现在我们就专心来写这个方法

01:03.430 --> 01:06.430
我们在这边

01:06.430 --> 01:07.430
在这边

01:07.430 --> 01:09.430
我们这里还是把之前的复制一下

01:09.430 --> 01:11.430
这里

01:11.430 --> 01:14.430
我们把这两个函数保留吧

01:14.430 --> 01:15.430
我把这个去掉

01:15.430 --> 01:16.430
把这两个函数打出来

01:16.430 --> 01:17.430
因为

01:17.430 --> 01:18.430
因为下面这样子写法

01:18.430 --> 01:20.430
大家稍微容易理解一点

01:20.430 --> 01:22.430
这样子层次很清楚返回了哪些函数

01:22.430 --> 01:23.430
上面一个写法写得简单

01:23.430 --> 01:25.430
但是看着不是很好看

01:25.430 --> 01:27.430
应用中间键就这种方式

01:27.430 --> 01:28.430
咱们来写这个

01:29.430 --> 01:30.430
首先第一个

01:30.430 --> 01:32.430
它这个函数里边有参数

01:32.430 --> 01:33.430
这个参数是什么呢

01:33.430 --> 01:34.430
就是中间键

01:34.430 --> 01:36.430
你有哪些中间键

01:36.430 --> 01:37.430
你可以给我

01:37.430 --> 01:38.430
给我就行了

01:38.430 --> 01:39.430
所以这里还这

01:39.430 --> 01:41.430
我们要用我们自己的Ridax

01:43.430 --> 01:44.430
没问题吧

01:44.430 --> 01:45.430
自己的Ridax

01:45.430 --> 01:47.430
那么现在肯定要出问题

01:47.430 --> 01:49.430
因为我们现在这个函数都还没写好

01:49.430 --> 01:51.430
肯定要出问题

01:51.430 --> 01:52.430
你看一下吧

01:53.430 --> 01:55.430
肯定还没写好

01:55.430 --> 01:56.430
你看

01:56.430 --> 01:58.430
肯定要出问题

01:58.430 --> 01:59.430
不着急

01:59.430 --> 02:00.430
慢慢来

02:00.430 --> 02:01.430
好

02:01.430 --> 02:02.430
首先到这边

02:02.430 --> 02:04.430
把这个右边删除了

02:04.430 --> 02:05.430
对到这个写

02:05.430 --> 02:06.430
你看一下

02:06.430 --> 02:08.430
它首先第一层函数

02:08.430 --> 02:09.430
第一层函数的话

02:09.430 --> 02:10.430
它会有多个参数

02:10.430 --> 02:11.430
对吧

02:11.430 --> 02:12.430
那到底有几个参数呢

02:12.430 --> 02:14.430
那取决于你中间键有多少个

02:14.430 --> 02:16.430
所以说到底有几个参数

02:16.430 --> 02:17.430
我也不知道

02:17.430 --> 02:18.430
我也不知道

02:18.430 --> 02:19.430
所以说你这个函数

02:19.430 --> 02:20.430
它有多少参数

02:20.430 --> 02:21.430
我们就用这种方式

02:22.430 --> 02:26.430
medals

02:26.430 --> 02:27.430
这个参数就表示

02:27.430 --> 02:28.430
所有的中间键

02:28.430 --> 02:29.430
咱们用个圣语的参数

02:29.430 --> 02:31.430
把这个参数展开

02:31.430 --> 02:34.430
所有的中间键

02:34.430 --> 02:37.430
那么就是注册中间键函数

02:37.430 --> 02:38.430
这个函数是用来注册中间键的

02:38.430 --> 02:40.430
不然medalware

02:40.430 --> 02:41.430
好 那么这个函数

02:41.430 --> 02:42.430
我们之前分析过

02:42.430 --> 02:43.430
这个函数是不是

02:43.430 --> 02:44.430
要返回一个新的函数

02:44.430 --> 02:45.430
这个新的函数

02:45.430 --> 02:46.430
要接受一个什么参数

02:46.430 --> 02:48.430
就是创建仓库的参数

02:48.430 --> 02:49.430
所以说这里要返回啥呢

02:49.430 --> 02:50.430
是不是要返回一个函数

02:51.430 --> 02:52.430
这个函数要干嘛

02:52.430 --> 02:55.430
是不是要接受一个create stone

02:55.430 --> 02:57.430
就是创建仓库的函数

02:57.430 --> 02:58.430
创建仓库的函数

02:58.430 --> 03:00.430
因为这个中间键的话

03:00.430 --> 03:01.430
它就是这个函数的话

03:01.430 --> 03:02.430
而planned middleware的函数

03:02.430 --> 03:03.430
它并不知道

03:03.430 --> 03:04.430
这个仓库是怎么创建的

03:04.430 --> 03:05.430
它跟create stone

03:05.430 --> 03:07.430
这个函数是没有关系的

03:07.430 --> 03:08.430
它们是独立的

03:08.430 --> 03:09.430
所以说它不知道

03:09.430 --> 03:10.430
怎么来创建仓库

03:10.430 --> 03:11.430
OK 你给我一个函数

03:11.430 --> 03:12.430
用来创建仓库

03:12.430 --> 03:14.430
好 这里打个注是

03:15.430 --> 03:19.430
给我创建仓库的函数

03:20.430 --> 03:23.430
那么给我创建仓库函数过后

03:23.430 --> 03:25.430
我是不是要创建仓库了

03:25.430 --> 03:26.430
那么我相当于

03:26.430 --> 03:27.430
这里还要返回一个函数

03:27.430 --> 03:28.430
这个函数用来干嘛的

03:28.430 --> 03:30.430
用来创建仓库的

03:30.430 --> 03:31.430
那创建仓库的话

03:31.430 --> 03:33.430
你是不是要给我一些参数

03:33.430 --> 03:34.430
对不对

03:34.430 --> 03:36.430
你是不是都得给我一些参数

03:36.430 --> 03:37.430
我才能创建仓库

03:37.430 --> 03:38.430
不然我怎么创建仓库呢

03:38.430 --> 03:39.430
对不对

03:39.430 --> 03:41.430
你得给我拿两个参数

03:41.430 --> 03:43.430
是不是至少得给我

03:43.430 --> 03:45.430
reducer得给我吧

03:45.430 --> 03:46.430
还有什么

03:46.430 --> 03:48.430
还有就是default

03:48.430 --> 03:50.430
default state

03:50.430 --> 03:52.430
默认状态的给我吧

03:55.430 --> 03:57.430
下面这个函数

03:57.430 --> 03:59.430
下面的函数

03:59.430 --> 04:02.430
函数用于创建仓库

04:02.430 --> 04:04.430
用于创建仓库

04:04.430 --> 04:05.430
传递的参数是什么呢

04:05.430 --> 04:06.430
传递的参数就是

04:06.430 --> 04:08.430
我们就打个注是

04:08.430 --> 04:10.430
reducer表示的是

04:10.430 --> 04:11.430
就是reducer

04:11.430 --> 04:12.430
这个没什么好说的

04:12.430 --> 04:13.430
这没什么好说的东西

04:13.430 --> 04:14.430
reducer就是reducer

04:14.430 --> 04:16.430
default state就是默认的状态

04:16.430 --> 04:17.430
那你看一下

04:17.430 --> 04:19.430
这样的结构是不是出来了

04:19.430 --> 04:20.430
对于这面而言

04:20.430 --> 04:21.430
这个结构是不是出来了

04:21.430 --> 04:22.430
你给我什么中间间

04:22.430 --> 04:23.430
那么运行的是啥

04:23.430 --> 04:24.430
运行的是这个函数

04:24.430 --> 04:25.430
我给你返回的是啥

04:25.430 --> 04:27.430
返回的是这个函数

04:27.430 --> 04:29.430
这个函数用来

04:29.430 --> 04:31.430
用来得到创建仓库的函数

04:31.430 --> 04:32.430
用来得到创建仓库的函数

04:32.430 --> 04:33.430
那你看一下

04:33.430 --> 04:35.430
你把这个创建仓库的函数给我

04:35.430 --> 04:36.430
这样子的一调用的话

04:36.430 --> 04:38.430
还会又会得到一个函数

04:38.430 --> 04:39.430
就是来创建仓库的

04:39.430 --> 04:40.430
具体创建仓库的函数

04:40.430 --> 04:41.430
就会得到这个函数

04:41.430 --> 04:43.430
我们现在框住的一部分

04:43.430 --> 04:44.430
就是

04:44.430 --> 04:45.430
我们把它分开

04:45.430 --> 04:46.430
分成两个部分

04:46.430 --> 04:47.430
分个屏

04:47.430 --> 04:48.430
分个屏

04:50.430 --> 04:51.430
现在我们框住这一部分

04:51.430 --> 04:52.430
就相当于是这

04:53.430 --> 04:54.430
就相当于是这一部分

04:55.430 --> 04:56.430
从这

04:56.430 --> 04:57.430
到这

04:58.430 --> 04:59.430
就这一部分

04:59.430 --> 05:00.430
就这一部分

05:00.430 --> 05:01.430
我们现在调用这一部分

05:01.430 --> 05:02.430
就得到的是这个函数

05:02.430 --> 05:03.430
一层一层过来的

05:03.430 --> 05:04.430
再来一次

05:04.430 --> 05:05.430
我们调用这个函数

05:05.430 --> 05:07.430
调用这个地方

05:07.430 --> 05:08.430
这是得到什么

05:08.430 --> 05:09.430
中间间

05:09.430 --> 05:10.430
得到的是这个函数

05:11.430 --> 05:12.430
得到的是这个函数

05:12.430 --> 05:13.430
你看对应的

05:13.430 --> 05:15.430
那么如果说

05:15.430 --> 05:16.430
我们这个换个行

05:16.430 --> 05:17.430
换个行

05:17.430 --> 05:21.410
看得清楚一点

05:21.410 --> 05:23.410
虽然要报个警告

05:25.410 --> 05:26.410
没关系

05:26.410 --> 05:27.410
我们先分析一下

05:27.410 --> 05:29.410
就是这一部分

05:29.410 --> 05:30.410
这一部分

05:30.410 --> 05:31.410
得到的是这个函数

05:31.410 --> 05:32.410
这边的函数

05:32.410 --> 05:34.410
这一部分得到了的是

05:34.410 --> 05:35.410
这个函数

05:35.410 --> 05:36.410
这个函数

05:36.410 --> 05:37.410
看没

05:37.410 --> 05:38.410
然后再调用这个

05:38.410 --> 05:39.410
再调用这个

05:39.410 --> 05:40.410
是不是得到这个

05:40.410 --> 05:41.410
再运行这个函数

05:41.410 --> 05:42.410
对吧

05:42.410 --> 05:43.410
就充电仓库

05:43.410 --> 05:44.410
就这么回事

05:45.410 --> 05:46.410
放回去

05:47.410 --> 05:48.410
好

05:48.410 --> 05:49.410
那么现在我们来

05:49.410 --> 05:50.410
在这边来

05:50.410 --> 05:52.410
这边怎么写呢

05:52.410 --> 05:53.410
这边怎么写呢

05:53.410 --> 05:54.410
我们之前分析过

05:54.410 --> 05:55.410
中间间用来干嘛的呢

05:55.410 --> 05:56.410
中间间就是

05:56.410 --> 05:57.410
帮我们来创建了一个仓库

05:57.410 --> 05:59.410
帮我们来创建了一个仓库

05:59.410 --> 06:00.410
constStore

06:01.410 --> 06:02.410
创建了一个仓库

06:02.410 --> 06:03.410
这个仓库

06:03.410 --> 06:04.410
我们就使用什么来创建

06:04.410 --> 06:06.410
是不是一个传递的函数

06:06.410 --> 06:07.410
来创建一个仓库

06:07.410 --> 06:08.410
createStore

06:08.410 --> 06:09.410
创建仓库

06:09.410 --> 06:10.410
给它什么呢

06:10.410 --> 06:11.410
给它reducer

06:11.410 --> 06:12.410
给它default state

06:12.410 --> 06:13.410
把这两个都给它

06:13.410 --> 06:14.410
创建仓库

06:16.410 --> 06:17.410
创建仓库

06:17.410 --> 06:19.410
创建仓库完了之后

06:19.410 --> 06:20.410
我们是不是要

06:21.410 --> 06:23.410
给它更换dispatch

06:23.410 --> 06:25.410
要更换那个仓库里边dispatch

06:25.410 --> 06:27.410
这里我们写上这么一个辩量

06:27.410 --> 06:28.410
dispatch

06:29.410 --> 06:30.410
这个辩量

06:30.410 --> 06:31.410
这个辩量一开始没有值

06:31.410 --> 06:32.410
或者说

06:32.410 --> 06:34.410
一开始给它的一个默认函数

06:34.410 --> 06:35.410
官方的元代码里边

06:35.410 --> 06:37.410
给它的是一个默认函数

06:37.410 --> 06:38.410
dispatch

06:39.410 --> 06:40.410
给它一个默认函数

06:40.410 --> 06:42.410
这个默认函数作为一件事

06:42.410 --> 06:43.410
这个默认函数非常简单

06:43.410 --> 06:44.410
就作为一件事

06:44.410 --> 06:45.410
就是抛出一个错误

06:45.410 --> 06:48.410
因为一开始是不能使用这个函数的

06:48.410 --> 06:49.410
一开始是不能使用这个函数的

06:49.410 --> 06:51.410
所以一开始给它抛出一个错误

06:53.410 --> 06:56.410
目前还不能使用dispatch

06:56.410 --> 06:58.410
因为一开始没有值

06:58.410 --> 06:59.410
一开始没有值

06:59.410 --> 07:00.410
还不能使用它

07:00.410 --> 07:03.410
那么这个辩量是最终会有值

07:03.410 --> 07:04.410
最终会有值

07:04.410 --> 07:06.410
给dispatch

07:06.410 --> 07:07.410
复制

07:07.410 --> 07:09.410
最终给它复制

07:09.410 --> 07:11.410
复完值过后

07:11.410 --> 07:13.410
最后我们返回

07:13.410 --> 07:14.410
返回啥呢

07:14.410 --> 07:16.410
返回把这个stone展开

07:16.410 --> 07:17.410
把stone原

07:17.410 --> 07:18.410
对象原有的东西展开

07:18.410 --> 07:20.410
然后把dispatch覆盖掉

07:20.410 --> 07:21.410
对吧

07:21.410 --> 07:22.410
就用这种方式来返回

07:22.410 --> 07:23.410
你看

07:23.410 --> 07:25.410
这就是整个的函数结构

07:25.410 --> 07:27.410
我给了你

07:27.410 --> 07:29.410
我给了你一个dispatch

07:29.410 --> 07:31.410
我给你设置了一个dispatch函数

07:31.410 --> 07:32.410
目前一开始没有值

07:32.410 --> 07:33.410
官方的协访是一开始

07:33.410 --> 07:34.410
让你不要去调用它

07:34.410 --> 07:36.410
为了防止你乱调用它

07:36.410 --> 07:37.410
因为一开始没有值

07:37.410 --> 07:39.410
那么现在最终是给dispatch复制

07:39.410 --> 07:40.410
复完值过后

07:40.410 --> 07:42.410
把dispatch放这

07:42.410 --> 07:43.410
那么现在就是

07:43.410 --> 07:44.410
主要关心的是这一部分

07:44.410 --> 07:46.410
如何给dispatch复制

07:46.410 --> 07:48.410
就是这一部分

07:48.410 --> 07:50.410
其实最终我们就是要

07:50.410 --> 07:51.410
给dispatch复制

07:51.410 --> 07:53.410
把给dispatch复完值过后

07:53.410 --> 07:55.410
就把最后的dispatch

07:55.410 --> 07:57.410
就是替换掉stone里面的dispatch

07:57.410 --> 07:58.410
怎么替换的

07:58.410 --> 07:59.410
就是这种方式来替换的

07:59.410 --> 08:00.410
把stone展开

08:00.410 --> 08:02.410
它不是用这种方式

08:02.410 --> 08:04.410
它不是用这种方式

08:04.410 --> 08:05.410
等于dispatch

08:05.410 --> 08:06.410
它没有用这种方式

08:06.410 --> 08:08.410
为什么没有用这种方式呢

08:08.410 --> 08:09.410
因为它是寒树式编程

08:09.410 --> 08:11.410
寒树式编程里面的理念是

08:11.410 --> 08:13.410
不要去改变原用对象

08:13.410 --> 08:14.410
它没有用这种方式

08:14.410 --> 08:15.410
它是直接反复一个新的对象

08:15.410 --> 08:17.410
把stone里面的原样东西展开

08:17.410 --> 08:19.410
然后给它一个新的dispatch复改掉

08:19.410 --> 08:21.410
总归你最终

08:21.410 --> 08:22.410
最终反复的东西

08:22.410 --> 08:23.410
其实跟stone长得一模一样

08:23.410 --> 08:25.410
你看把stone展开了嘛

08:25.410 --> 08:26.410
长得一模一样

08:26.410 --> 08:27.410
就是复改了它的dispatch

08:27.410 --> 08:29.410
最终还是会形成这样的效果

08:29.410 --> 08:30.410
就是你给我的stone里面

08:30.410 --> 08:32.410
dispatch已经被更改了

08:32.410 --> 08:33.410
已经被更改了

08:33.410 --> 08:34.410
那么现在的过程就是

08:34.410 --> 08:36.410
我们要搞定的是

08:36.410 --> 08:38.410
给这个辨量复制

08:38.410 --> 08:40.410
因为这个辨量有了正确的值过后

08:40.410 --> 08:41.410
我们自然而然

08:41.410 --> 08:43.410
就会形成最终的效果

08:43.410 --> 08:46.410
把这个值覆盖到stone里面的值

08:46.410 --> 08:48.410
那么关键是怎么复制呢

08:48.410 --> 08:49.410
按照我们之前的研究

08:49.410 --> 08:51.410
是不是你给我注上了很多东间键

08:51.410 --> 08:53.410
我要去调用这些东间键

08:53.410 --> 08:55.410
然后把dispatch传给你

08:55.410 --> 08:56.410
然后一个个传

08:56.410 --> 08:57.410
每一个都会得到一个dispatch

08:57.410 --> 08:58.410
然后最终

08:58.410 --> 09:00.410
我们会得到一个最终的dispatch

09:00.410 --> 09:02.410
咱们就是用这种方式来做的

09:02.410 --> 09:05.410
怎么来做呢

09:05.410 --> 09:06.410
首先呢我们这里medalware

09:06.410 --> 09:08.410
我们要知道medalware是啥

09:08.410 --> 09:09.410
你连medalware是啥

09:09.410 --> 09:11.410
都不知道你肯定是写不出来

09:11.410 --> 09:12.410
medalware是不是一个一个的函数

09:12.410 --> 09:13.410
对吧一个一个的函数

09:13.410 --> 09:15.410
这个函数调用过后

09:15.410 --> 09:17.410
是不是会返回一个dispatch

09:17.410 --> 09:18.410
创建函数对吧

09:18.410 --> 09:20.410
medalware我们可以简单的说

09:20.410 --> 09:21.410
medalware是啥

09:21.410 --> 09:22.410
medalware的本质

09:22.410 --> 09:26.410
medalware的本质

09:26.410 --> 09:29.410
是一个雕用后

09:29.410 --> 09:31.410
可以得到什么

09:31.410 --> 09:33.410
可以得到就是

09:33.410 --> 09:36.410
雕用后可以得到

09:36.410 --> 09:37.410
dispatch

09:37.410 --> 09:40.410
创建函数的函数

09:40.410 --> 09:42.410
也就是我们再分解一下这句话

09:42.410 --> 09:43.410
medalware是啥呢

09:43.410 --> 09:45.410
一个一个中间键就是一个函数

09:45.410 --> 09:46.410
这个函数用来干嘛的呢

09:46.410 --> 09:48.410
雕用之后可以得到一个dispatch

09:48.410 --> 09:49.410
创建函数

09:49.410 --> 09:50.410
这个玩意儿

09:50.410 --> 09:51.410
你看一下

09:51.410 --> 09:52.410
我们现在框住的一部分

09:52.410 --> 09:53.410
这个玩意儿就是个dispatch

09:53.410 --> 09:54.410
创建函数

09:54.410 --> 09:55.410
你看这个整体

09:55.410 --> 09:56.410
这个东西就是个dispatch

09:56.410 --> 09:57.410
创建函数

09:57.410 --> 09:58.410
你雕用的这个中间

09:58.410 --> 09:59.410
它就会得到一个dispatch

09:59.410 --> 10:00.410
创建函数

10:00.410 --> 10:01.410
那么dispatch

10:01.410 --> 10:02.410
创建函数就是这个东西

10:02.410 --> 10:03.410
就这个东西

10:03.410 --> 10:04.410
你把dispatch给它

10:04.410 --> 10:05.410
它给了一个dispatch

10:05.410 --> 10:06.410
你把dispatch给它

10:06.410 --> 10:07.410
它给了一个dispatch

10:07.410 --> 10:08.410
就这个东西

10:08.410 --> 10:09.410
所以说我们第一步呢

10:09.410 --> 10:12.410
是需要去雕用这些中间键函数

10:12.410 --> 10:14.410
来得到一个一个的dispatch

10:14.410 --> 10:15.410
创建函数

10:15.410 --> 10:16.410
咱们这一块呢

10:16.410 --> 10:18.410
我们可以使用这个模式

10:18.410 --> 10:20.410
叫做

10:20.410 --> 10:22.410
直接重新给这个参数复制

10:22.410 --> 10:24.410
重新给参数复制

10:24.410 --> 10:27.410
或者说我们写个变量也行

10:27.410 --> 10:28.410
写个变量也行

10:28.410 --> 10:30.410
表示dispatch

10:30.410 --> 10:32.410
producer

10:32.410 --> 10:36.410
就是dispatch创建函数

10:36.410 --> 10:38.410
当然是一个数组

10:38.410 --> 10:39.410
是一个数组

10:39.410 --> 10:42.410
就是根据中间键数组

10:42.410 --> 10:44.410
你看这个参数是不是数组

10:44.410 --> 10:45.410
展开过后的数组

10:45.410 --> 10:47.410
那么根据中间键数组

10:47.410 --> 10:50.410
得到一个dispatch

10:50.410 --> 10:54.410
创建函数的数组

10:54.410 --> 10:55.410
也就是我们这里要干嘛

10:55.410 --> 10:56.410
我们这里你给我的

10:56.410 --> 10:58.410
不是一个一个的中间键吗

10:58.410 --> 11:00.410
不好意思

11:00.410 --> 11:02.410
不好意思

11:02.410 --> 11:04.410
那么我们给他的是一个一个的中间键

11:04.410 --> 11:06.410
但是中间键本身

11:06.410 --> 11:08.410
本身是没有多少的意义的

11:08.410 --> 11:09.410
我们需要的是什么

11:09.410 --> 11:10.410
需要是中间键

11:10.410 --> 11:12.410
返回的dispatch创建函数

11:12.410 --> 11:13.410
这才是我们需要的东西

11:13.410 --> 11:14.410
到时候我会

11:14.410 --> 11:16.410
把dispatch传给他一个一个的雕用

11:16.410 --> 11:17.410
所以说我们需要得到

11:17.410 --> 11:18.410
中间键里边的东西

11:18.410 --> 11:19.410
因此怎么办呢

11:19.410 --> 11:20.410
我现在拿到的是一个

11:20.410 --> 11:21.410
中间键的数组

11:21.410 --> 11:22.410
比方说那个1 那个2

11:22.410 --> 11:23.410
是这么一个数组

11:23.410 --> 11:24.410
我们现在是不是要运行

11:24.410 --> 11:26.410
这个数组里面每一个函数

11:26.410 --> 11:28.410
把每一个函数的返回结果

11:28.410 --> 11:31.410
作为新的数组

11:31.410 --> 11:32.410
是这个意思吧

11:32.410 --> 11:33.410
就我们这里

11:33.410 --> 11:34.410
数组里面是什么

11:34.410 --> 11:36.410
是log1

11:36.410 --> 11:38.410
log2

11:38.410 --> 11:39.410
是这么一个数组

11:39.410 --> 11:40.410
我们要想把它

11:40.410 --> 11:42.410
想把它变成一个新的数组

11:42.410 --> 11:43.410
这个新的数组是什么

11:43.410 --> 11:45.410
dispatch

11:45.410 --> 11:47.410
创建函数

11:47.410 --> 11:49.410
函数1

11:49.410 --> 11:50.410
dispatch

11:50.410 --> 11:53.410
创建函数2

11:53.410 --> 11:54.410
对不对

11:54.410 --> 11:55.410
是不是要得到这个东西

11:55.410 --> 11:56.410
把log1里边的创建函数

11:56.410 --> 11:57.410
拿出来

11:57.410 --> 11:58.410
log2的创建函数拿出来

11:58.410 --> 11:59.410
那么我们这里

11:59.410 --> 12:01.410
可以用map来进行映射

12:01.410 --> 12:03.410
怎么映射呢

12:03.410 --> 12:04.410
就说这里

12:04.410 --> 12:05.410
我们这样子写

12:05.410 --> 12:06.410
middle wires

12:06.410 --> 12:07.410
这是你给我的中间键

12:07.410 --> 12:10.410
我们用map

12:10.410 --> 12:11.410
然后呢

12:11.410 --> 12:12.410
映射成怎么呢

12:12.410 --> 12:13.410
雕用这个中间键

12:13.410 --> 12:14.410
对吧

12:14.410 --> 12:15.410
雕用这个中间键

12:15.410 --> 12:16.410
你看一下

12:16.410 --> 12:17.410
雕用这个中间键

12:17.410 --> 12:18.410
是不是就可以拿到这个

12:18.410 --> 12:19.410
函数的返回的结果了

12:19.410 --> 12:20.410
对吧

12:20.410 --> 12:21.410
把每一个中间键

12:21.410 --> 12:22.410
去雕用

12:22.410 --> 12:23.410
2是不是可以拿到

12:23.410 --> 12:24.410
这个创建函数

12:24.410 --> 12:25.410
你看一下

12:25.410 --> 12:26.410
雕用log1是不是拿到

12:26.410 --> 12:27.410
这个创建函数

12:27.410 --> 12:28.410
雕用log2是不是拿到

12:28.410 --> 12:29.410
这个创建函数

12:29.410 --> 12:30.410
对吧

12:30.410 --> 12:31.410
我们就要有

12:31.410 --> 12:32.410
实行这么一个东西

12:32.410 --> 12:33.410
那么雕的时候

12:33.410 --> 12:34.410
是不是要传叉

12:34.410 --> 12:35.410
对不对

12:35.410 --> 12:36.410
是不是要传叉

12:36.410 --> 12:37.410
把这个

12:37.410 --> 12:38.410
把这个雕用的返回结果

12:38.410 --> 12:39.410
作为一个新的数组的

12:39.410 --> 12:40.410
每一项值

12:40.410 --> 12:41.410
那么是不是要传叉

12:41.410 --> 12:42.410
传叉传的

12:42.410 --> 12:43.410
是不是传一个stone

12:43.410 --> 12:44.410
当然你这里

12:44.410 --> 12:45.410
你不要把这个

12:45.410 --> 12:46.410
这个stone传进去

12:46.410 --> 12:47.410
因为我们之前分析过

12:47.410 --> 12:48.410
这个stone里边

12:48.410 --> 12:49.410
它有很多东西

12:49.410 --> 12:50.410
但是我们只需要

12:50.410 --> 12:51.410
给它两个东西

12:51.410 --> 12:52.410
可以写个变量

12:52.410 --> 12:53.410
把这个stone分解出来

12:53.410 --> 12:54.410
只需要给它一个

12:54.410 --> 12:55.410
getState和dispatch

12:55.410 --> 12:56.410
只需要给它

12:56.410 --> 12:57.410
这两个东西就行了

12:57.410 --> 12:58.410
好

12:58.410 --> 12:59.410
咱们把它分解出来

13:00.410 --> 13:01.410
就给它取个名字

13:01.410 --> 13:02.410
叫simpleStone

13:02.410 --> 13:03.410
分解出来

13:04.410 --> 13:05.410
那么我们只需要

13:05.410 --> 13:06.410
stone里面的getState

13:07.410 --> 13:08.410
getState

13:09.410 --> 13:11.410
来自于stone的getState

13:12.410 --> 13:13.410
然后dispatch

13:14.410 --> 13:15.410
来自于stone的

13:16.410 --> 13:17.410
dispatch

13:18.410 --> 13:19.410
对吧

13:19.410 --> 13:20.410
我们只需要给它

13:21.410 --> 13:22.410
simpleStone传过去

13:22.410 --> 13:23.410
能不能在这里

13:23.410 --> 13:24.410
直接写字面量对象

13:24.410 --> 13:25.410
给它这样子写了

13:25.410 --> 13:26.410
也可以

13:26.410 --> 13:27.410
只不过这样子的话

13:27.410 --> 13:28.410
每一个中间键

13:28.410 --> 13:29.410
它会得到不同的对象

13:29.410 --> 13:30.410
因为它每一次

13:30.410 --> 13:31.410
都是个新键的对象

13:31.410 --> 13:32.410
那没有必要

13:32.410 --> 13:33.410
我们这里建一个对象就行了

13:34.410 --> 13:36.410
那么把这个对象传过去

13:36.410 --> 13:37.410
这样子

13:37.410 --> 13:38.410
硬射

13:38.410 --> 13:39.410
是不是硬射出来这么一个数字

13:39.410 --> 13:40.410
创建函数的数字

13:40.410 --> 13:41.410
于是就形成这么一种结构了

13:41.410 --> 13:42.410
对吧

13:42.410 --> 13:43.410
这是个数字

13:43.410 --> 13:44.410
中间键1 中间键2 中间键3

13:44.410 --> 13:45.410
它们每一个的创建函数

13:45.410 --> 13:46.410
就形成这么一个数字了

13:47.410 --> 13:48.410
那么写下来的问题就是

13:50.410 --> 13:52.410
我要反向的去调用

13:52.410 --> 13:53.410
这个数组的方法

13:53.410 --> 13:54.410
你看现在数组里面

13:54.410 --> 13:55.410
不是每一个

13:55.410 --> 13:56.410
都是一个方法吗

13:56.410 --> 13:57.410
对不对

13:57.410 --> 13:58.410
你看一下

13:58.410 --> 13:59.410
再看一下

13:59.410 --> 14:00.410
它拿到的是这个函数

14:00.410 --> 14:01.410
数组里面

14:01.410 --> 14:02.410
第一象是这个

14:02.410 --> 14:03.410
第二象是这个

14:03.410 --> 14:04.410
那我们现在干嘛呢

14:04.410 --> 14:06.410
我们现在就要反着调用

14:06.410 --> 14:08.410
先调用最后一个

14:08.410 --> 14:10.410
把原色的第四趴起传进去

14:10.410 --> 14:12.410
得到一个新的第四趴起

14:12.410 --> 14:13.410
然后再调用这个

14:13.410 --> 14:14.410
把原色的第四趴起

14:14.410 --> 14:16.410
把下一个第四趴起传进去

14:16.410 --> 14:17.410
再调用

14:17.410 --> 14:18.410
再得到一个新的第四趴起

14:18.410 --> 14:19.410
对吧

14:20.410 --> 14:21.410
那么这个过程呢

14:21.410 --> 14:22.410
其实从

14:22.410 --> 14:24.410
就是数组里面有很多函数

14:24.410 --> 14:26.410
有很多函数

14:26.410 --> 14:27.410
然后呢

14:27.410 --> 14:29.410
我们把这些函数组合起来

14:29.410 --> 14:31.410
把这些函数组合起来

14:31.410 --> 14:32.410
得到一个新的函数

14:32.410 --> 14:33.410
那么这个过程呢

14:33.410 --> 14:35.410
叫做compose

14:35.410 --> 14:36.410
这个东西

14:36.410 --> 14:37.410
这是函数是编程里面的

14:37.410 --> 14:38.410
一个概念

14:38.410 --> 14:39.410
compose

14:39.410 --> 14:41.410
叫做函数组合

14:41.410 --> 14:43.410
函数组合

14:43.410 --> 14:45.410
函数组合

14:45.410 --> 14:46.410
函数组合

14:46.410 --> 14:47.410
它指的就是什么意思呢

14:47.410 --> 14:49.410
将一个

14:49.410 --> 14:53.410
将一个数组中的函数

14:53.410 --> 14:55.410
进行组合

14:55.410 --> 14:59.410
形成一个新的函数

14:59.410 --> 15:01.410
该函数

15:01.410 --> 15:03.410
调用时

15:03.410 --> 15:08.410
实际上是调用的是反

15:08.410 --> 15:10.410
该函数调用的时候

15:10.410 --> 15:13.410
实际上是反向

15:13.410 --> 15:14.410
调用

15:14.410 --> 15:17.410
之前组合的函数

15:17.410 --> 15:18.410
啥意思呢

15:18.410 --> 15:19.410
这个特别特别绕

15:19.410 --> 15:20.410
特别特别绕

15:20.410 --> 15:21.410
什么意思呢

15:21.410 --> 15:22.410
我给大家画个图

15:23.410 --> 15:24.410
函数是编程

15:24.410 --> 15:25.410
所以说大家

15:27.410 --> 15:28.410
所以说现在市面上

15:28.410 --> 15:29.410
特别是前端刊发

15:29.410 --> 15:30.410
虽然说函数

15:30.410 --> 15:31.410
就编程在很多领域

15:31.410 --> 15:32.410
就是前端的

15:32.410 --> 15:33.410
很多场地下都用到了

15:33.410 --> 15:34.410
但是

15:34.410 --> 15:35.410
很少有公司要求你

15:35.410 --> 15:37.410
汇函数是编程

15:37.410 --> 15:38.410
太难了

15:38.410 --> 15:39.410
真的是太难了

15:40.410 --> 15:41.410
你看一下这里

15:41.410 --> 15:42.410
比方说是一个一个的函数

15:42.410 --> 15:43.410
比方说这里是

15:43.410 --> 15:44.410
三个函数

15:44.410 --> 15:46.410
是三个函数

15:46.410 --> 15:47.410
我现在要干嘛

15:47.410 --> 15:49.410
这是函数一

15:49.410 --> 15:50.410
它放在一个数组里边

15:50.410 --> 15:51.410
这是函数一

15:51.410 --> 15:52.410
这是第一个函数

15:52.410 --> 15:54.410
这是函数二

15:54.410 --> 15:55.410
这是第二个函数

15:55.410 --> 15:57.410
这是函数三

15:57.410 --> 15:58.410
函数三

15:58.410 --> 15:59.410
这是第三个函数

15:59.410 --> 16:00.410
那么我现在要做的

16:00.410 --> 16:01.410
事情是什么呢

16:01.410 --> 16:02.410
把这三个函数

16:02.410 --> 16:03.410
进行组合

16:03.410 --> 16:05.410
什么叫组合

16:05.410 --> 16:08.410
就是我要形成一个新的函数

16:08.410 --> 16:13.040
我要形成一个新的函数

16:13.040 --> 16:14.040
这个外面的框框

16:14.040 --> 16:15.040
就表示一个新的函数

16:15.040 --> 16:17.040
形成一个新的函数

16:17.040 --> 16:21.040
只要你去调用新的函数

16:21.040 --> 16:23.040
你把你传立了一个参数

16:24.040 --> 16:25.040
传立了一个参数进去

16:27.040 --> 16:29.040
你传立了一个参数进去

16:29.040 --> 16:30.040
那么

16:30.040 --> 16:31.040
这是参数

16:31.040 --> 16:34.670
传立了一个参数进去

16:34.670 --> 16:35.670
参数

16:36.670 --> 16:40.430
你传立了一个参数进去

16:41.430 --> 16:42.430
这是新的函数

16:42.430 --> 16:43.430
大框框是个新的函数

16:43.430 --> 16:44.430
得到了一个新的函数

16:44.430 --> 16:45.430
那么你传立一个参数进去

16:45.430 --> 16:53.830
传一个参数进去 他里边会怎么做呢 他会把参数 参数传给谁啊 内部 他实现内部 他会把参数传给他

16:55.510 --> 16:56.550
他会把参数传给他

16:57.750 --> 17:03.510
然后呢 他是不是运行个结果 运行个返回值 好 运行个返回值 然后呢 再把返回值

17:04.550 --> 17:10.950
再把返回值传给他 然后呢 再把就是把返回值作为参数传给韩数二 再把韩数二的返回值作为参

17:11.510 --> 17:14.710
作为参数传给韩数一 再把韩数一的返回值作为

17:15.430 --> 17:17.670
结果返回 作为结果返回

17:21.100 --> 17:25.980
返回 这是不是就是我们想要的 对不对 这是不是就是我们想要的 你看一下这里

17:27.100 --> 17:36.140
我要把这些中 这些创建韩数封装成一个韩数 只要我把stone的dspot给他 那么他会一次把参数给他 他会返回一个结果 然后给他

17:36.540 --> 17:41.500
然后他会返回一个结果 然后给他 他会返回一个结果 我们把返回结果拿到对吧 我们就是要要这个效果

17:42.060 --> 17:45.420
把它组装成一个新的韩数 那么这个组装的过程叫做compose

17:45.980 --> 17:47.260
compose 就是韩数组合

17:48.060 --> 17:48.780
啊 韩数组合

17:49.660 --> 18:00.300
形成一个新的韩数 那么这个玩意呢 是韩数是编程里边的概念 那这里呢 我们就写这么一个啊 为了实现这样的效果啊 为了实现这样的效果 我们这里这里呢 就写这么一个compose韩数

18:01.100 --> 18:03.980
compose点介绍啊 也可以把它写到uq里边啊

18:04.940 --> 18:09.740
实际上呢 如果大个10里边他可以导出了这么一个东西啊 只不过呢 我们平时不怎么用得到而已

18:10.060 --> 18:13.420
实际上如果大个10给导出了这个玩意呢 他可以导出了

18:13.980 --> 18:14.460
compose

18:17.180 --> 18:25.660
就这么一个韩数 那么它是主要来实现韩数组合的 它根据大个指实际上没有没有什么关联啊 它主要是韩数是编程里面概念啊 compose

18:26.380 --> 18:27.020
好意思

18:28.220 --> 18:30.060
compose这么一个韩数 这个韩

18:30.860 --> 18:31.500
方可行啊

18:33.980 --> 18:39.980
好 这个韩数呢 你给我传很多的韩数进来啊 你给我传很多的韩数进来

18:40.940 --> 18:48.380
把韩数全部传给我 就像这样子 现在我们把问题分解到这了啊 就是你给我很多的韩数啊 你给我很多的韩数

18:49.020 --> 18:52.940
一个数组 然后呢 我要做的事情就是把这个韩数呢

18:53.660 --> 18:59.500
把这个韩数呢 组合起来形成一个新的韩数 也就是说这个compose里边呢 它要返回一个新的韩数

19:00.540 --> 19:01.180
新的韩数

19:03.530 --> 19:10.650
这个新的韩数呢 它可能会接收 接收多少个参数的也不知道 对吧 也不知道要接收多少个参数 总之呢 它会接收参数

19:11.690 --> 19:17.290
它会接收参数 那会它 它会把这个参数传给谁呢 它会把这个参数传给

19:18.330 --> 19:25.690
啊 这个这个数组里边的最后一个韩数 对吧 从最后一个韩数开始 然后呢 把调用最后一个韩数吧 最后一个韩数得到了结果呢

19:26.330 --> 19:29.610
得到了结果呢 又传给啊 就是韩数二啊 韩数一

19:30.090 --> 19:32.810
好 根据这样的逻辑呢 我们就可以在这里 这样的鞋带嘛

19:33.850 --> 19:39.690
就是你调用韩数给我参数对吧 那我把这个参数怎么来处理呢 怎么来处理这个参数呢 OK 我这样子来处理

19:40.650 --> 19:43.450
我呢 这样子 我把这个就是

19:44.330 --> 19:48.330
啊 在这个韩数里边 当你调用这个韩数的时候 我这里先 这样吧

19:48.890 --> 19:54.730
我因为这里特别绕啊 我们这先说一下怎么用 怎么用这个compose 我们先抛开这个什么apply middleware的

19:55.050 --> 19:57.610
抛开这个东西 我们来先说一下怎么用啊 怎么用

19:58.170 --> 20:03.290
啊 这边呢 我们先把这个stone里边的所有东西 这里copy一下啊copy一下

20:03.690 --> 20:08.330
把这个stone里边的所有东西先去掉 我们这里只导入compose啊compose

20:11.260 --> 20:12.540
就导入那个

20:13.660 --> 20:16.060
导入上面那个目录的 所以大概是里面的

20:16.860 --> 20:17.740
这是compose

20:19.020 --> 20:21.100
测试一下啊compose测试一下

20:21.660 --> 20:26.300
好 到compose里边来 我们看一下到时候怎么用啊 比方说咱们这里呢 有两个

20:26.860 --> 20:28.780
韩数啊 两个韩数

20:29.260 --> 20:31.820
这个韩数是funk1啊funk1

20:33.500 --> 20:37.180
他这里呢 要给我一个参数n啊 给我一个参数n

20:37.580 --> 20:40.780
我返回呢 这是n乘以2啊 n乘以2

20:41.980 --> 20:45.020
然后呢 我们再写一个韩数funk2

20:45.740 --> 20:46.220
方可行

20:47.180 --> 20:48.060
funk2

20:48.540 --> 20:55.340
然后呢 再给我一个参数也是一个n 我这里呢 返回的是n加n

20:55.980 --> 21:00.860
好 那么接下来呢 我们要用这个compose这个韩数 把它组合起来

21:01.260 --> 21:03.420
放可1传进去 放可2传进去

21:03.820 --> 21:05.820
好 于是呢 他会返回一个新的韩数

21:06.700 --> 21:07.340
新的韩数

21:08.220 --> 21:08.620
funk

21:09.180 --> 21:13.020
当我们调用这个新的韩数的时候呢 他怎么调用呢 比方说给他传了一个3

21:13.420 --> 21:18.380
他怎么调用呢 他先调用 他应该是先调用funk2 把3传到funk2里面去

21:19.580 --> 21:20.140
然后呢

21:20.940 --> 21:22.780
就是返回个3加3等于6

21:22.940 --> 21:26.780
然后再把6传到funk1里面去 再得到2乘以6等于12

21:26.860 --> 21:28.860
于是呢 这里应该得到啊 得到12

21:29.420 --> 21:30.380
啊 应该得到12

21:31.340 --> 21:33.660
这不是就是我们这种模式 对吧 韩数组合

21:33.900 --> 21:35.340
那么关键是这里边怎么写的

21:35.740 --> 21:38.540
这里边怎么写的 那么这个3对应啥 是不是对应这里的参数

21:39.100 --> 21:42.540
对应你这里的参数 他也不知道你参数有多少个 对吧 对应这里的参数

21:43.180 --> 21:43.900
没问题吧

21:44.700 --> 21:46.140
好 然后呢

21:46.700 --> 21:53.420
啊 你说这个参数应该是只有一个的啊 应该是只有一个的啊 其实

21:53.900 --> 21:56.300
这个地方也无所谓吧 也无所谓

21:56.380 --> 21:57.980
那么放在这吧

21:58.860 --> 22:01.260
看着啊 那怎么来做了这里 这一块

22:01.900 --> 22:03.820
我们比方说 我们这里

22:04.220 --> 22:08.860
韩数的数组在这 对吧 这是我们雕用的这个funk韩数得到了参数在这

22:09.340 --> 22:12.220
好 那么现在我们怎么做呢 是不是导则循环

22:12.700 --> 22:15.980
这个韩数数组 对吧 导则循环

22:16.620 --> 22:17.500
好 4

22:18.300 --> 22:21.420
i等于啥呢 i等于funk's length 解1

22:21.500 --> 22:25.910
然后呢 i大于等于0

22:26.470 --> 22:30.710
然后i简简 对吧 导则循环 导则循环的这个数组

22:31.510 --> 22:34.390
所以每循环意思可以拿到一个韩数啊 对不对

22:34.390 --> 22:36.150
每循环意思可以拿到一个韩数

22:36.630 --> 22:37.430
funk's

22:38.070 --> 22:39.590
每循环意思拿到一个韩数

22:40.390 --> 22:41.590
然后呢

22:42.310 --> 22:44.630
然后呢 是不是要雕用这个韩数

22:45.190 --> 22:46.470
那么这里参数传啥

22:47.110 --> 22:48.230
然后呢

22:48.310 --> 22:50.550
然后呢 是不是要雕用这个韩数

22:51.110 --> 22:52.310
那么这里参数传啥

22:53.750 --> 22:54.950
参数传啥 你告诉我

22:55.430 --> 22:57.590
参数传啥 是不是传这个参数呢

22:57.990 --> 22:58.870
那不一定哦

22:58.870 --> 23:02.870
因为我这里呢是一个形成一个数组了啊 形成一个数组了

23:02.870 --> 23:06.230
你只有第一个就最后一个韩数才会接收原式参数

23:06.230 --> 23:07.750
才会接收这个原式参数

23:07.750 --> 23:09.910
其他的时候呢 韩数接收的是什么呢

23:10.710 --> 23:13.830
其他的时候 韩数是不是接收的是上一个韩数返回的参数

23:13.830 --> 23:16.950
对吧 所以说我们这里要用个变量来记录一下啊

23:17.910 --> 23:19.750
nast上一个参数

23:20.310 --> 23:21.190
上一个参数

23:21.190 --> 23:22.950
一开始的上一个参数就等于这个

23:22.950 --> 23:23.990
等于原式参数

23:25.110 --> 23:29.190
记录上一个韩数返回的值

23:29.590 --> 23:32.070
那么这个返回的值

23:32.630 --> 23:34.070
应该说nast return嘛

23:34.070 --> 23:35.270
nast return

23:35.270 --> 23:36.550
上一个韩数返回的值

23:36.950 --> 23:38.230
那么它将作为

23:38.950 --> 23:42.390
它将作为下一个韩数的参数

23:42.950 --> 23:44.230
是这个意思吧 是个逻辑吧

23:44.790 --> 23:46.710
一开始的它这个上一个韩数返回值

23:46.710 --> 23:47.830
一开始没有调用韩数嘛

23:47.830 --> 23:48.790
它自然没有返回值

23:48.790 --> 23:50.390
那么我们一开始让它等于这个参数

23:51.110 --> 23:52.790
所以说我们这里传入什么呢

23:55.350 --> 23:56.150
传入这个

23:56.150 --> 23:56.710
传入这个

23:59.270 --> 24:00.070
nast return

24:00.070 --> 24:01.030
nast return

24:01.030 --> 24:02.310
传入这个玩意儿

24:02.310 --> 24:03.270
传入这个玩意儿

24:03.750 --> 24:04.070
对吧

24:05.430 --> 24:05.910
没问题吧

24:06.950 --> 24:08.630
一开始传入这么一个玩意儿

24:08.630 --> 24:10.230
但是呢 这一开始是一个数组啊

24:10.710 --> 24:11.910
这一开始是一个数组

24:13.830 --> 24:14.710
我想一想啊

24:14.710 --> 24:15.270
我想一想

24:15.750 --> 24:17.590
这里我们用单参嘛

24:17.590 --> 24:18.870
还是用单参算的

24:18.870 --> 24:20.070
因为这种邪法的话

24:20.950 --> 24:21.590
我想一想

24:21.590 --> 24:23.670
因为大家好理解的邪法

24:24.310 --> 24:26.390
这样子我就刚才在这里判断一下嘛

24:26.390 --> 24:28.310
如果说i等于

24:28.310 --> 24:28.790
functs

24:29.350 --> 24:30.310
delince

24:30.310 --> 24:30.870
-1

24:30.870 --> 24:32.070
这样子大家好理解点啊

24:32.070 --> 24:32.870
主要是好理解点

24:32.870 --> 24:33.990
一会我们会减化

24:33.990 --> 24:34.550
不着急啊

24:34.550 --> 24:35.670
一会会会减化

24:35.670 --> 24:36.950
那么一开始的这个东西是

24:37.510 --> 24:38.230
等于 now

24:38.230 --> 24:39.350
一开始没东西

24:39.350 --> 24:40.630
上一个韩数返回值

24:40.630 --> 24:41.190
一开始没有

24:41.190 --> 24:42.390
因为还没有调用任何韩数

24:42.390 --> 24:43.190
所以说一开始没有

24:43.670 --> 24:44.790
好那么如果说

24:44.870 --> 24:45.990
是最后一个韩数的话

24:45.990 --> 24:46.950
我怎么调用它

24:46.950 --> 24:48.070
我是这样调用

24:49.190 --> 24:51.670
把这个原式的参数给你传过去

24:51.670 --> 24:53.350
原式的参数给你传过去

24:53.350 --> 24:54.230
那么是不是得到一个

24:54.230 --> 24:55.110
not return了

24:55.110 --> 24:57.270
对吧得到一个上一次返回的结果

24:57.270 --> 24:58.710
上一次返回的结果

24:58.710 --> 24:59.750
就得到这么一个值了

25:00.630 --> 25:01.270
对不对

25:01.510 --> 25:02.310
是这个意思吧

25:02.310 --> 25:03.270
好 else

25:03.270 --> 25:04.950
如果说它不是最后一个韩数

25:04.950 --> 25:06.950
这是最数组的

25:07.350 --> 25:09.110
数组最后一项

25:09.430 --> 25:10.470
数组最后一项

25:10.470 --> 25:11.990
如果它不是数组的最后一项

25:11.990 --> 25:13.430
那么你调用这个韩数的时候

25:13.510 --> 25:15.430
是不是要把上一次的返回结果

25:15.430 --> 25:16.950
上一次的返回结果

25:16.950 --> 25:18.550
作为参数传到这里边来

25:18.550 --> 25:18.950
对吧

25:18.950 --> 25:19.670
传到这里边来

25:19.670 --> 25:21.350
然后又得到一个返回结果

25:21.350 --> 25:22.950
又得到一个返回结果

25:22.950 --> 25:24.550
你看是不是形成这么一种结构了

25:24.550 --> 25:25.590
好好看一下

25:26.790 --> 25:28.150
我这里再看一下

25:28.150 --> 25:30.390
我这里把方可1 方可2 传进去

25:30.390 --> 25:31.270
让它进行组合

25:31.270 --> 25:32.710
它会给我们一个新的韩数

25:33.270 --> 25:35.110
它会给我们一个新的韩数

25:35.670 --> 25:35.990
好

25:35.990 --> 25:37.510
然后当我们去调用新的韩数的时候

25:37.510 --> 25:38.470
把参数传进去

25:38.470 --> 25:39.350
它会怎么做呢

25:39.350 --> 25:40.550
它会循环

25:40.950 --> 25:41.830
循环这个

25:42.870 --> 25:43.990
循环这个就是

25:44.710 --> 25:45.350
韩数数组

25:45.350 --> 25:46.470
从最后一个开始

25:46.470 --> 25:47.430
先调用最后一个

25:47.430 --> 25:47.910
最后一个的话

25:47.910 --> 25:49.350
就把原式参数传进去

25:49.350 --> 25:50.230
你看吧

25:50.230 --> 25:51.590
就把原式参数传进去

25:51.590 --> 25:52.310
最后一个

25:52.310 --> 25:53.510
然后得到一个返回结果

25:54.150 --> 25:55.510
得到一个返回结果保存起来

25:56.070 --> 25:57.110
那么后边如果说

25:57.110 --> 25:58.630
不是最后一个韩数调用的话

25:58.630 --> 25:59.990
那就把上一次的返回结果

25:59.990 --> 26:01.190
作为参数传进去

26:01.190 --> 26:02.070
又得到一个返回结果

26:02.070 --> 26:03.430
又更新这个返回结果

26:03.430 --> 26:03.910
对吧

26:03.910 --> 26:05.750
那么这样子循环结束之后

26:05.750 --> 26:06.870
那么这个返回结果

26:08.870 --> 26:10.070
循环结束之后

26:10.150 --> 26:11.270
那么这个返回结果

26:11.270 --> 26:12.470
是不是就是那时的return

26:12.870 --> 26:13.350
对不对

26:13.350 --> 26:14.070
那时的return

26:14.630 --> 26:14.870
好

26:14.870 --> 26:15.590
咱们来看一下

26:15.590 --> 26:17.350
看一下输出的是不是12

26:17.350 --> 26:17.830
保存

26:18.630 --> 26:19.670
点击右键检查

26:20.230 --> 26:20.630
输出了

26:20.630 --> 26:20.950
你看一下

26:20.950 --> 26:21.670
是不是12

26:21.670 --> 26:22.070
对不对

26:22.070 --> 26:23.510
是不是把韩数组合起来了

26:23.510 --> 26:24.870
它实际上是调用了两个韩数

26:24.870 --> 26:25.990
我们这里看一下吧

26:25.990 --> 26:26.950
这里

26:26.950 --> 26:27.590
这里

26:27.590 --> 26:28.310
方可

26:28.310 --> 26:29.270
这里输出

26:29.270 --> 26:31.910
方可2被调用了

26:31.910 --> 26:33.430
被调用了

26:33.430 --> 26:35.670
得到了N的值拿过来

26:35.670 --> 26:36.790
然后这里复制一下

26:37.670 --> 26:39.110
方可1被调用了

26:39.110 --> 26:39.910
N的值拿过来

26:39.990 --> 26:40.630
保存看一下

26:41.190 --> 26:42.230
方可2先被调用

26:42.230 --> 26:43.590
传了个原式参数3

26:43.590 --> 26:45.030
然后它返回的结果是6

26:45.030 --> 26:46.310
然后把6作为参数

26:46.310 --> 26:47.430
传到方可1里面

26:47.430 --> 26:48.470
对不对

26:48.470 --> 26:49.670
就完成了

26:49.670 --> 26:50.630
就形成了这么多结构了

26:51.270 --> 26:53.270
当然这里有些特殊情况

26:53.270 --> 26:54.390
你可以考虑进去

26:54.390 --> 26:56.150
比方说这里不是要传一个数组吗

26:56.150 --> 26:57.030
那如果说

26:57.030 --> 26:58.950
如果说你传的数组长度为0

27:00.150 --> 27:00.870
长度为0

27:02.150 --> 27:03.270
你要够组合的

27:03.270 --> 27:04.870
组合的韩数长度为0

27:04.870 --> 27:06.470
就是你够传一个空数组进来

27:06.470 --> 27:07.270
啥都没够传递

27:07.270 --> 27:08.710
那个数组长度是不是0

27:08.710 --> 27:09.190
对吧

27:09.270 --> 27:10.390
那这个时候干嘛了

27:10.950 --> 27:11.990
这个时候干嘛了

27:11.990 --> 27:13.190
我给你返回一个韩数

27:13.190 --> 27:14.550
我还是给你返回一个韩数

27:14.550 --> 27:15.990
始终是要返回一个韩数的

27:15.990 --> 27:17.270
这个韩数就比较简单

27:17.270 --> 27:18.470
你给我传什么参数

27:21.350 --> 27:22.550
你给我传什么参数

27:23.110 --> 27:24.390
我就给你返回什么参数

27:25.590 --> 27:26.710
我就给你返回什么参数

27:27.190 --> 27:28.070
对吧

27:28.070 --> 27:31.590
如果没有要组合的韩数

27:31.590 --> 27:33.590
则返回的韩数

27:33.590 --> 27:35.030
远峰不动的

27:35.670 --> 27:36.550
返回参数

27:36.950 --> 27:37.350
对吧

27:37.350 --> 27:38.390
你给我传什么参数

27:38.470 --> 27:39.590
我给你返回什么参数

27:39.590 --> 27:40.230
就这么简单

27:41.190 --> 27:43.030
这是这种情况

27:43.030 --> 27:44.150
这种情况

27:45.750 --> 27:46.070
好

27:46.070 --> 27:47.190
那么Else

27:47.990 --> 27:48.950
Elseif

27:48.950 --> 27:51.030
如果说你的方式

27:51.030 --> 27:52.230
要处理一下特殊情况

27:52.230 --> 27:53.030
等于1

27:53.030 --> 27:54.230
就是说如果组合

27:54.790 --> 27:57.990
就是要组合的韩数只有一个

27:58.630 --> 27:59.110
只有一个

27:59.110 --> 27:59.750
什么意思呢

27:59.750 --> 28:00.710
又在这种情况下

28:00.710 --> 28:01.670
这里只有一个韩数

28:03.350 --> 28:03.990
只有一个韩数

28:04.550 --> 28:05.750
那只有一个韩数的话

28:05.750 --> 28:07.350
是不是就是把这个韩数本身返回

28:07.350 --> 28:07.750
对吧

28:07.830 --> 28:08.550
你给我什么参数

28:08.550 --> 28:09.510
我给你什么返回值

28:09.510 --> 28:09.830
对不对

28:10.310 --> 28:11.430
那如果只有一个韩数的话

28:11.430 --> 28:12.710
是不是就是把参数给他

28:12.710 --> 28:14.310
然后把他的返回值返回

28:14.310 --> 28:14.550
对吧

28:14.550 --> 28:15.430
就很简单

28:15.430 --> 28:16.150
所以说如果说

28:16.150 --> 28:17.350
只有一个韩数的情况下

28:17.910 --> 28:19.510
咱们就特别简单

28:19.510 --> 28:20.310
是返回什么了

28:20.310 --> 28:21.590
就把这个韩数本身返回

28:23.190 --> 28:24.230
就是个数组里面

28:24.230 --> 28:25.670
那唯一的人一个韩数返回

28:25.670 --> 28:26.390
你给我什么参数

28:26.390 --> 28:27.750
我就返回什么值

28:27.750 --> 28:29.510
就是把他的韩数的返回值返回

28:30.070 --> 28:32.310
只是两种特殊情况处理一下

28:32.310 --> 28:33.990
那么正常的就是有多个韩数的情况

28:33.990 --> 28:34.710
多个韩数的情况

28:34.710 --> 28:36.310
我们就正常的方式来进行组合

28:36.470 --> 28:37.350
返回一个新的韩数

28:38.950 --> 28:40.230
实际上了这一块代码

28:40.230 --> 28:41.590
如果说你能理解这一块代码

28:41.590 --> 28:43.110
就已经非常非常不错了

28:43.110 --> 28:44.390
就已经非常非常不错了

28:44.950 --> 28:46.230
那如果说你能理解

28:46.230 --> 28:48.390
我下面写的这个代码

28:48.390 --> 28:51.030
那就真的特别特别厉害了

28:53.300 --> 28:54.260
你看着我什么写

28:54.820 --> 28:56.100
我用这种方式来写

28:56.100 --> 28:56.500
Funce

28:57.540 --> 28:58.100
Reduce

28:58.900 --> 28:59.540
Reduce

29:00.420 --> 29:01.140
A

29:01.140 --> 29:01.460
B

29:02.660 --> 29:03.620
返回什么了

29:03.620 --> 29:04.100
返回

29:05.780 --> 29:06.260
Accuse

29:08.900 --> 29:10.980
返回的是A

29:11.700 --> 29:12.820
雕用B

29:18.440 --> 29:18.920
完了

29:18.920 --> 29:20.040
就已经写完了

29:20.040 --> 29:20.840
已经写完了

29:20.840 --> 29:21.640
保存你看一下吧

29:21.640 --> 29:22.520
看一下最终的结果

29:23.240 --> 29:23.880
是不是一样的

29:24.360 --> 29:25.160
就已经写完了

29:25.960 --> 29:26.760
这是啥呀

29:26.760 --> 29:27.480
这个是啥呀

29:28.040 --> 29:29.160
Reduce这个见过没

29:29.880 --> 29:31.000
我尽量解释

29:31.000 --> 29:31.880
实在听不懂

29:31.880 --> 29:33.560
你知道会下面那种写法

29:33.960 --> 29:35.080
下面的写法代码多一点

29:35.080 --> 29:35.960
那是好理解一点

29:35.960 --> 29:37.240
这东西不是那么好理解

29:38.440 --> 29:39.400
Reduce是什么

29:39.400 --> 29:40.520
Reduce是累计

29:41.000 --> 29:41.560
累计

29:41.560 --> 29:42.360
那么这个累计

29:42.360 --> 29:43.080
我们有的时候

29:43.080 --> 29:44.520
可以用它来做什么

29:44.520 --> 29:46.120
就是求和

29:46.120 --> 29:46.920
一个数

29:46.920 --> 29:47.720
一个数组求

29:47.720 --> 29:49.080
对一个数组求和

29:49.080 --> 29:50.520
比方这个东西是一个数字数组

29:50.520 --> 29:51.640
对它进行求和

29:51.640 --> 29:53.160
或者是求急

29:53.160 --> 29:54.040
对不对

29:54.040 --> 29:56.360
比方说咱们有这么一个数组

29:57.880 --> 29:58.280
二位

29:59.160 --> 29:59.880
有这么一个数组

29:59.880 --> 30:00.440
随便写吧

30:00.440 --> 30:01.000
三五七

30:01.640 --> 30:02.760
然后我们对它求和

30:03.320 --> 30:04.120
怎么求和呢

30:05.320 --> 30:06.040
怎么求和呢

30:06.040 --> 30:06.440
就是说

30:07.400 --> 30:08.760
这里我们调了它的Reduce

30:09.240 --> 30:09.720
Reduce

30:10.600 --> 30:12.360
Reduce你不要要传一个函数进去

30:12.360 --> 30:13.800
要传一个函数进去

30:13.800 --> 30:15.080
这个函数呢

30:15.080 --> 30:16.280
有两个参数

30:16.280 --> 30:17.080
A和B

30:18.120 --> 30:18.840
返回的是什么呢

30:18.840 --> 30:20.200
我们当时返回的是A加B

30:20.200 --> 30:20.680
对吧

30:20.680 --> 30:22.120
这样子就可以求和了

30:22.120 --> 30:23.080
咱们来看一下吧

30:23.080 --> 30:24.120
我们来梳理一下

30:24.120 --> 30:25.080
Reduce

30:26.280 --> 30:27.560
看它是怎么做运作的

30:28.280 --> 30:29.960
这里不能换个名字

30:29.960 --> 30:30.520
R嘛

30:31.480 --> 30:31.960
看一下

30:33.240 --> 30:34.760
求和就是15嘛

30:34.760 --> 30:36.520
求和就是15

30:36.520 --> 30:37.480
3加5

30:37.480 --> 30:38.680
8加7是15

30:38.680 --> 30:39.720
那么它怎么运作的呢

30:39.720 --> 30:40.440
它是这样子

30:44.140 --> 30:44.540
好

30:45.420 --> 30:47.100
它一共有三五七

30:47.100 --> 30:47.580
对吧

30:47.580 --> 30:48.540
有三项

30:49.100 --> 30:49.260
好

30:49.260 --> 30:49.980
那么手

30:49.980 --> 30:51.180
它里边刚传了一个函数

30:51.180 --> 30:52.140
这个函数有两个参数

30:52.140 --> 30:52.860
有一个返回值

30:52.860 --> 30:53.260
对吧

30:53.260 --> 30:54.300
那么它怎么来做的

30:54.300 --> 30:55.180
做这件事情的呢

30:55.180 --> 30:55.740
它这样子

30:56.380 --> 30:58.460
它首先拿到这个数组的前两项

30:59.340 --> 31:00.460
所以说你这里呢

31:00.460 --> 31:01.180
当一个Reduce

31:01.820 --> 31:03.180
Reduce可以有默认值

31:03.180 --> 31:04.620
但是我这里没有传默认值

31:04.940 --> 31:05.820
就在第二个参数

31:05.820 --> 31:07.100
第二个参数可以传默认值

31:07.100 --> 31:08.300
如果说没有传默认值的话

31:08.300 --> 31:10.940
它必须要求数组至少得有两项

31:10.940 --> 31:12.380
所以说前面为什么要判断了

31:12.460 --> 31:13.660
如果有零项怎么办

31:13.660 --> 31:14.940
一个有一项怎么办

31:14.940 --> 31:17.100
那么后面就是数组有两项的情况

31:17.100 --> 31:19.180
要求它数组有两项

31:19.180 --> 31:20.540
如果说有两项的话

31:20.540 --> 31:22.700
它首先运行第一次运行函数

31:22.700 --> 31:24.700
它首先把三合五传进去

31:25.500 --> 31:26.860
三合五传进去

31:26.860 --> 31:28.540
你返回的结果是啥

31:28.540 --> 31:29.500
你返回的结果

31:30.060 --> 31:32.300
返回的结果是不是一个A加B

31:32.300 --> 31:33.020
A加B是多少

31:33.020 --> 31:33.500
是8

31:34.620 --> 31:34.860
好

31:34.860 --> 31:35.740
第二次

31:35.740 --> 31:37.260
它就把第一次返回的结果

31:37.260 --> 31:38.780
作为第一个参数

31:38.780 --> 31:39.660
又传进来

31:39.660 --> 31:41.100
把8传进来

31:41.180 --> 31:43.820
把下一项7传进来

31:44.540 --> 31:45.820
然后返回的结果是啥

31:45.820 --> 31:46.460
实物

31:46.940 --> 31:48.140
发现后面没有了

31:48.140 --> 31:50.060
它就把这个实物整个返回

31:50.380 --> 31:51.980
它就这么一个逻辑

31:52.540 --> 31:53.420
再来梳理一下

31:53.420 --> 31:54.700
你们自己再来梳理一下

31:54.700 --> 31:55.900
反复想想这个逻辑

31:55.900 --> 31:58.140
那如果有四项多一项

31:58.140 --> 31:59.100
3578

31:59.340 --> 32:00.460
那么它就这样子

32:01.660 --> 32:03.180
首先把前两项拿出来

32:03.180 --> 32:04.540
三合五拿出来

32:04.540 --> 32:05.340
得到一个8

32:05.900 --> 32:06.940
得到这么一个8

32:08.380 --> 32:10.460
那么现在再把8作为第一个参数

32:11.420 --> 32:13.580
下一次交用这个喊数的第一个参数

32:13.580 --> 32:15.420
然后把下一项作为第二个参数

32:15.420 --> 32:16.060
7拿进来

32:16.060 --> 32:17.500
返回一个结果实物

32:17.500 --> 32:18.540
然后下一次呢

32:18.540 --> 32:19.580
发现还有东西对吧

32:19.580 --> 32:20.380
数组里边还有东西

32:20.380 --> 32:21.820
就把实物拿进来

32:21.820 --> 32:23.660
然后把下一项8拿进来

32:23.660 --> 32:24.380
得到什么

32:24.380 --> 32:24.860
23

32:25.420 --> 32:25.820
好

32:25.820 --> 32:26.620
没有下一项了

32:26.620 --> 32:27.500
它就把23返回

32:28.380 --> 32:29.100
看是不是23

32:29.820 --> 32:30.700
对不对

32:30.700 --> 32:32.300
它就是这种处理模式

32:33.260 --> 32:34.540
那么回到我们这边来

32:36.300 --> 32:36.860
你看一下

32:37.420 --> 32:39.100
我们这里处理的模式是啥呢

32:41.820 --> 32:42.300
现在呢

32:42.300 --> 32:43.500
我给它两个funk

32:45.820 --> 32:46.460
funk1

32:49.140 --> 32:50.500
我们用f1嘛

32:50.500 --> 32:51.220
fn1

32:52.260 --> 32:53.060
fn2

32:54.020 --> 32:54.740
fn3

32:55.460 --> 32:56.100
fn4

32:57.700 --> 32:58.740
我们先说两个吧

32:58.740 --> 32:59.460
先说两个

32:59.460 --> 33:00.500
就简单的场景

33:00.500 --> 33:00.980
你看一下

33:01.860 --> 33:02.340
首先呢

33:02.340 --> 33:03.780
我跟数组里边有两项

33:03.780 --> 33:04.260
对吧

33:04.260 --> 33:05.700
数组里边有两项

33:05.700 --> 33:06.020
好

33:06.020 --> 33:07.220
那么这里边传两个喊数

33:07.220 --> 33:07.860
a和b

33:07.860 --> 33:09.460
a和b是不是fn1

33:10.580 --> 33:11.300
到什么

33:11.300 --> 33:12.340
fn2

33:12.420 --> 33:13.220
对不对

33:13.220 --> 33:14.900
它返回的是一个啥呢

33:14.900 --> 33:16.740
是不是返回的是一个新的喊数

33:17.780 --> 33:18.820
返回的不是一个值

33:18.820 --> 33:20.420
返回的是一个新的喊数

33:20.420 --> 33:21.620
这个新的喊数是这样的

33:23.140 --> 33:23.780
是这样的

33:23.780 --> 33:25.140
那么这里的a和b是啥

33:25.140 --> 33:26.660
a和b是fn1

33:27.780 --> 33:28.420
fn2

33:28.980 --> 33:29.620
对吧

33:29.620 --> 33:30.740
这是新的喊数

33:30.740 --> 33:32.500
你看一下这个反回的新的喊数

33:32.500 --> 33:33.460
如果说只有两项

33:33.460 --> 33:34.100
后面没了

33:34.100 --> 33:35.300
它就直接把这个返回了

33:35.300 --> 33:35.700
对吧

33:35.700 --> 33:37.700
它reduce就直接把这个返回了

33:37.700 --> 33:39.860
那么这就是我们最终返回的喊数

33:39.860 --> 33:40.500
那你看一下

33:40.580 --> 33:42.500
到时候你给它传一个数字进去

33:42.500 --> 33:43.860
不要说传了个3进去

33:43.860 --> 33:46.020
它是不是把3先传给f2

33:46.020 --> 33:47.220
就是第二个喊数

33:47.220 --> 33:49.380
来把第二个喊数的返回结果

33:49.380 --> 33:51.140
再传给fn1

33:51.140 --> 33:51.860
对吧

33:51.860 --> 33:52.980
你看是不是这个模式

33:52.980 --> 33:54.500
不要说到时候调问的时候

33:54.500 --> 33:56.100
调问的时候是怎么放可3

33:56.100 --> 33:56.500
对吧

33:56.500 --> 33:57.060
对吧

33:57.060 --> 33:58.180
我们拿到这个东西

33:58.180 --> 33:59.060
拿到这个喊放可

33:59.060 --> 33:59.780
就是这个玩意儿

33:59.780 --> 34:01.060
因为它只有两项

34:01.060 --> 34:01.300
对吧

34:01.300 --> 34:01.860
只有两项

34:01.860 --> 34:02.740
拿到就是这个玩意儿

34:03.540 --> 34:04.180
就这个喊数

34:05.220 --> 34:05.460
好

34:05.460 --> 34:06.580
那么它怎么做的呢

34:06.580 --> 34:07.540
传了一个3进去

34:07.540 --> 34:09.060
传一个3进去就是相当于是3

34:10.020 --> 34:10.660
3

34:10.660 --> 34:12.900
那么fn1调用fn2

34:12.900 --> 34:13.700
把3传进去

34:13.700 --> 34:13.940
对吧

34:13.940 --> 34:14.660
就像那个是这个

34:15.300 --> 34:16.340
fn把3传进去

34:16.340 --> 34:17.060
把它的返回结果

34:17.060 --> 34:18.260
作为参数值

34:20.260 --> 34:21.220
放到它的参数里面

34:22.180 --> 34:23.220
就形成这么一种结构了

34:24.260 --> 34:24.980
明白的意思吧

34:24.980 --> 34:26.100
那如果说有三项

34:26.100 --> 34:26.660
四项呢

34:26.660 --> 34:27.700
比方说有三项

34:27.700 --> 34:28.980
我们描述三项就完事了

34:30.180 --> 34:31.220
有三项呢

34:31.220 --> 34:32.740
那么是不是有把这个喊数

34:32.740 --> 34:33.620
作为第一个参数

34:34.580 --> 34:35.060
你想想

34:35.620 --> 34:36.820
把这个喊数作为第一个参数

34:37.540 --> 34:37.940
然后呢

34:37.940 --> 34:40.020
把fn3作为第二个参数

34:40.020 --> 34:40.420
返回

34:41.540 --> 34:42.260
返回什么呢

34:42.260 --> 34:43.300
是不是又返回一个喊数

34:44.420 --> 34:46.740
它就是一层一层牵套进去了

34:46.740 --> 34:47.940
又返回一个喊数

34:47.940 --> 34:48.500
ab

34:49.300 --> 34:50.260
现在s是它

34:50.260 --> 34:51.140
s不是它

34:51.140 --> 34:51.700
对不对

34:51.700 --> 34:52.180
s它

34:52.820 --> 34:53.620
就这个喊数

34:53.620 --> 34:54.900
去调用这个喊数

34:55.460 --> 34:56.260
比方说这个东西

34:56.900 --> 34:57.700
我们这个东西就

34:58.420 --> 34:59.380
给它取个名字吧

34:59.380 --> 35:00.180
取个名字c嘛

35:00.180 --> 35:00.660
不然的话

35:00.660 --> 35:01.460
我是真的

35:01.460 --> 35:02.740
真的不好那个

35:02.740 --> 35:03.620
不好说

35:03.620 --> 35:04.180
c

35:04.180 --> 35:05.220
那么是不是c

35:06.180 --> 35:07.220
调用啊

35:07.220 --> 35:08.180
fn3

35:08.180 --> 35:09.220
然后调用

35:09.220 --> 35:09.940
返回了这个

35:11.540 --> 35:12.020
accus

35:13.300 --> 35:15.220
就是c调用

35:15.220 --> 35:16.420
fn3

35:16.420 --> 35:16.820
调用

35:17.540 --> 35:17.940
accus

35:19.060 --> 35:19.220
好

35:19.220 --> 35:19.780
你看一下

35:19.780 --> 35:20.500
这样的一包装

35:20.500 --> 35:21.300
咱们来看一下啊

35:22.340 --> 35:22.980
现在呢

35:22.980 --> 35:23.380
到时候

35:23.380 --> 35:24.180
一月只有三项吧

35:24.180 --> 35:25.460
它就把这个东西返回了

35:25.460 --> 35:26.980
这个东西就是我们最多的喊数

35:26.980 --> 35:27.940
好最多的喊数

35:27.940 --> 35:30.020
我们这里传一个参数三进去

35:30.020 --> 35:31.140
是不是相当于是这里是

35:31.140 --> 35:31.780
传了一个三

35:32.260 --> 35:33.300
把这个提出来

35:33.300 --> 35:33.780
提出来

35:36.520 --> 35:37.800
这里是不是传了一个三

35:37.800 --> 35:38.520
对不对

35:38.520 --> 35:39.400
传了个三

35:39.400 --> 35:39.640
好

35:39.640 --> 35:41.000
那么这边就是个三

35:41.000 --> 35:42.840
那么是不是先调用fn3

35:43.400 --> 35:44.840
把它的返回结果

35:44.840 --> 35:46.520
作为参数传到c里边

35:46.520 --> 35:48.280
作为参数传到c里边

35:48.280 --> 35:49.400
那么c是啥

35:49.400 --> 35:50.440
c是不是这个玩意儿

35:50.440 --> 35:51.080
对吧

35:51.080 --> 35:51.320
好

35:51.320 --> 35:53.000
那么把它作为参数传进去

35:53.000 --> 35:53.240
好

35:53.240 --> 35:54.440
传进去过后呢

35:54.440 --> 35:55.400
c又是啥

35:55.400 --> 35:57.800
c又把它的参数又传给fn2

35:57.800 --> 35:58.360
对吧

35:58.360 --> 35:59.640
又然后再传给fn1

35:59.640 --> 36:01.720
是不是调用顺序是先调用fn3

36:01.720 --> 36:03.160
再调用什么fn2

36:03.160 --> 36:04.280
再调用fn1

36:04.280 --> 36:04.920
看到没有

36:05.080 --> 36:06.840
这是函数的组合

36:06.840 --> 36:08.360
你可以使用reduce的方式

36:08.360 --> 36:09.400
一句话写出来

36:11.400 --> 36:13.720
就是再用那个更高的一个程式

36:13.720 --> 36:14.760
理解就是

36:14.760 --> 36:16.520
先调用后边的函数

36:16.520 --> 36:18.840
因为我们之前看那个就是

36:18.840 --> 36:19.480
看那个就是

36:20.840 --> 36:21.800
求和

36:21.800 --> 36:23.160
求和这里

36:23.160 --> 36:23.480
对吧

36:23.480 --> 36:25.400
那么b是不是始终是后边的

36:25.400 --> 36:27.720
两个相对应的话

36:27.720 --> 36:29.640
b一定是后边的这个东西

36:29.640 --> 36:31.720
始终说我返回那个函数

36:31.720 --> 36:33.320
我返回了那个新函数里边

36:33.400 --> 36:35.240
始终是先调用后边的

36:35.240 --> 36:37.320
先调用后边的函数

36:37.320 --> 36:38.600
返回那个新函数里边

36:38.600 --> 36:40.360
先调用后边的函数

36:40.360 --> 36:41.720
然后再把后边的函数

36:41.720 --> 36:42.520
返回的结果

36:42.520 --> 36:43.560
再去

36:43.560 --> 36:46.280
作为参数传到前面的函数里边去

36:46.280 --> 36:47.480
形成这么一个新的函数

36:49.800 --> 36:51.560
那么如果新的函数再传到下一项的话

36:51.560 --> 36:52.920
也是先调用后边的

36:52.920 --> 36:54.360
就这么个意思

36:54.360 --> 36:55.560
这东西尽量理解吧

36:55.560 --> 36:56.360
如果实在理解不了

36:56.360 --> 36:58.120
因为函数识编程本来就难理解

36:58.120 --> 36:59.320
如果实在理解不了的话

36:59.320 --> 37:00.440
那么就用看这个

37:01.560 --> 37:02.360
为什么我告诉大家

37:02.360 --> 37:04.280
为什么函数识编程难理解

37:04.280 --> 37:05.880
因为我在很多时候

37:05.880 --> 37:07.720
公开直播课里边也说过

37:07.720 --> 37:08.840
函数识编程

37:08.840 --> 37:12.360
函数识编程

37:13.160 --> 37:15.160
它是属于声明式

37:15.960 --> 37:17.160
声明式编程

37:18.040 --> 37:19.240
像咱们介石图

37:19.240 --> 37:21.080
平时用的什么循环

37:21.080 --> 37:22.120
那些往前把老的东西

37:22.120 --> 37:23.400
什么辨量那些东西

37:23.400 --> 37:25.640
都属于是命令式编程

37:25.640 --> 37:26.280
命令式编程

37:26.280 --> 37:27.560
我们要去分析它的内存

37:27.560 --> 37:27.960
对吧

37:27.960 --> 37:29.080
这个辨量的值是什么

37:29.080 --> 37:29.640
每一个步骤

37:29.640 --> 37:31.000
每一个步骤辨量的值是什么

37:31.000 --> 37:32.280
但是声明式编程不用

37:32.600 --> 37:34.280
声明式编程只在乎逻辑

37:34.280 --> 37:36.280
你的逻辑是不是合理的

37:36.280 --> 37:36.920
是不是对的

37:36.920 --> 37:38.760
我不在乎它怎么去实现的

37:38.760 --> 37:40.680
不在乎它的运行过程是什么样子

37:40.680 --> 37:42.120
这是声明式编程的特点

37:42.120 --> 37:44.360
像ATV和CSS它就是一个声明式编程

37:45.240 --> 37:46.440
声明式编程

37:46.440 --> 37:48.520
那么你知道一个CSS写的过后

37:48.520 --> 37:49.480
它经过了哪些事吗

37:49.480 --> 37:50.600
怎么变成一个红色的吗

37:50.600 --> 37:51.560
你不用去管

37:51.560 --> 37:52.280
跟你没关系

37:52.280 --> 37:53.960
你只需要知道我要干嘛

37:53.960 --> 37:55.240
我做的事情是不是正确的

37:57.000 --> 37:58.360
就是声明式编程关心的是

37:59.320 --> 37:59.880
做什么

37:59.880 --> 38:01.560
我要做什么事情

38:01.640 --> 38:04.200
而命运式编程做的关心的是我要怎么做

38:04.920 --> 38:05.880
声明式编程我就说

38:05.880 --> 38:07.080
我告诉他我要干嘛

38:07.080 --> 38:07.480
我要干嘛

38:07.480 --> 38:08.440
我要组合这些函数

38:08.440 --> 38:09.720
我先调到后边了

38:09.720 --> 38:10.680
然后再调到前面了

38:11.240 --> 38:12.280
这就是我要做的事情

38:15.080 --> 38:15.960
所以说大家

38:15.960 --> 38:17.960
如果带到命运式编程的思维模式

38:17.960 --> 38:19.720
去理解声明式编程的东西的话

38:19.720 --> 38:22.120
肯定是不是那么好理解

38:22.120 --> 38:24.680
总之这两种方式你只需要知道一个就行了

38:25.560 --> 38:26.200
行了

38:26.200 --> 38:28.600
那现在我们就把compose这个函数写出来了

38:29.560 --> 38:30.120
好了

38:30.120 --> 38:31.960
有了这个compose这个函数的帮忙

38:32.840 --> 38:35.960
我这里不是有很多的dispatch创建函数吗

38:35.960 --> 38:37.000
我要导测调用

38:37.640 --> 38:39.560
是不是我就可以利用compose函数了

38:40.040 --> 38:40.760
对吧

38:40.760 --> 38:41.720
我就导入进来

38:42.440 --> 38:43.400
把这个compose

38:44.360 --> 38:45.000
from

38:45.960 --> 38:46.760
compose

38:46.760 --> 38:47.560
导入进来

38:48.440 --> 38:50.200
那么利用这个compose函数

38:51.000 --> 38:52.360
帮我们去组合一下

38:52.360 --> 38:52.680
这些

38:53.160 --> 38:54.360
帮我们去组合一下

38:54.360 --> 38:54.920
哎

38:54.920 --> 38:56.200
把计算器打开干嘛

38:56.200 --> 38:57.320
帮我们去组合一下这个

38:58.680 --> 38:59.320
这些函数

38:59.320 --> 39:00.440
组合成一个新的函数

39:00.440 --> 39:01.320
这个框框

39:01.320 --> 39:02.600
组合成一个新的函数

39:02.600 --> 39:03.160
好

39:03.160 --> 39:04.840
那么就是组合完了过后

39:06.520 --> 39:06.760
哦

39:06.760 --> 39:07.480
当然要展开

39:07.480 --> 39:08.760
这个数主要展开

39:08.760 --> 39:11.000
组合完了过后就会形成一个新的函数

39:12.040 --> 39:13.160
新的函数

39:13.160 --> 39:13.480
就是

39:14.120 --> 39:15.160
那个变量接受一下嘛

39:15.800 --> 39:17.880
就是dispatch

39:18.680 --> 39:20.200
producer

39:20.200 --> 39:20.840
没有加s

39:21.640 --> 39:23.000
组成一个新的函数

39:23.000 --> 39:23.640
那么现在呢

39:23.640 --> 39:25.240
我们去调用这个新的函数

39:25.240 --> 39:27.160
是不是就可以拿到最终的dispatch了

39:27.160 --> 39:27.640
对吧

39:27.720 --> 39:28.680
那么这些函数干嘛

39:28.680 --> 39:30.040
这些函数就是传入一个dispatch

39:30.040 --> 39:31.320
它给了一个新的dispatch

39:31.320 --> 39:32.040
传入一个dispatch

39:32.040 --> 39:33.320
给了一个新的dispatch

39:33.320 --> 39:33.560
好

39:33.560 --> 39:34.840
那么我们把组合起来过后

39:34.840 --> 39:35.480
我只需要把

39:36.040 --> 39:37.240
原式的dispatch给它

39:37.240 --> 39:37.960
它就会返回

39:37.960 --> 39:39.960
最终返回一个新的dispatch

39:39.960 --> 39:40.680
就像这样子

39:40.680 --> 39:42.120
我拿原式的dispatch给它

39:42.120 --> 39:43.960
然后最终它会返回一个新的dispatch

39:44.760 --> 39:44.840
好

39:44.840 --> 39:45.160
于是呢

39:45.160 --> 39:46.200
我这里就调用这个

39:48.820 --> 39:50.180
把原式的dispatch给它

39:50.180 --> 39:50.580
怎么给它

39:50.580 --> 39:51.620
Stone第二dispatch

39:51.620 --> 39:52.100
对吧

39:52.100 --> 39:53.460
把原式的dispatch给它

39:53.460 --> 39:54.500
然后拿到这个变量

39:55.060 --> 39:56.420
给这个变量负责

39:56.500 --> 39:58.020
最终的目的是给这个变量负责

39:58.020 --> 39:59.540
拿到这个新的dispatch

39:59.540 --> 39:59.860
对吧

40:00.580 --> 40:01.060
就这样子

40:01.060 --> 40:01.620
就完了

40:01.620 --> 40:02.020
就没了

40:03.060 --> 40:04.580
就用了把这个新的dispatch

40:04.580 --> 40:05.380
覆盖进去

40:05.380 --> 40:06.900
覆盖到新的对象里面

40:06.900 --> 40:09.060
当然这里也可以省略到一个步骤

40:09.060 --> 40:10.980
这个地方多一个变量没什么意义

40:10.980 --> 40:12.180
我直接在这里直接调用了

40:12.180 --> 40:12.740
对吧

40:12.740 --> 40:13.780
dispatch也可以

40:14.580 --> 40:15.460
也可以

40:15.460 --> 40:16.340
那么这里直接负责

40:18.740 --> 40:19.140
也可以

40:20.100 --> 40:21.300
所以说你看这个代码

40:21.300 --> 40:21.940
没有几行

40:21.940 --> 40:22.900
真的没有几行

40:22.900 --> 40:24.980
就这么短短几就写完了

40:24.980 --> 40:26.180
而PlanetMiddleware就写完了

40:27.140 --> 40:28.500
是真的可以了吗

40:28.500 --> 40:29.220
真的可以了吗

40:29.220 --> 40:30.180
咱们来试一下吧

40:30.180 --> 40:31.540
把原来的负责一下

40:31.540 --> 40:32.180
暂停过来

40:33.220 --> 40:33.620
保存

40:35.460 --> 40:36.180
是不是真的可以了

40:36.180 --> 40:37.220
中间键是不是应用进去了

40:38.660 --> 40:39.140
你看一下

40:39.140 --> 40:40.740
ApplanetMiddleware是不是应用进去了

40:40.740 --> 40:41.220
就没了

40:42.100 --> 40:43.140
好好的体会一下

40:43.140 --> 40:43.780
代码不多

40:43.780 --> 40:44.180
但是呢

40:44.820 --> 40:45.780
特别特别绕

40:45.780 --> 40:46.020
好

40:46.020 --> 40:46.340
最后呢

40:46.340 --> 40:47.620
我们来更改一下Stone

40:48.260 --> 40:48.900
这个仓库

40:49.460 --> 40:51.780
这个仓库里边也可以使用ApplanetMiddleware

40:52.500 --> 40:53.140
也可以使用

40:54.580 --> 40:55.780
也可以使用ApplanetMiddleware

40:56.500 --> 40:56.900
于是呢

40:56.900 --> 40:58.100
我们再更新一下

40:58.100 --> 40:58.980
我们以前的仓库

40:58.980 --> 40:59.700
仓库的代码

41:00.260 --> 41:00.980
仓库代码呢

41:00.980 --> 41:01.860
里边呢

41:02.900 --> 41:03.460
是这样子

41:04.500 --> 41:05.220
仓库代码呢

41:05.220 --> 41:06.420
它可以有两个参数

41:06.420 --> 41:07.380
也可以有三个参数

41:07.380 --> 41:07.620
对吧

41:07.620 --> 41:08.260
都可以有

41:08.900 --> 41:09.220
那么

41:10.100 --> 41:11.060
如果说

41:11.060 --> 41:12.580
如果说它这里写的是

41:13.140 --> 41:14.100
就还有个参数

41:14.100 --> 41:14.660
还有一个参数

41:14.660 --> 41:16.100
我们给它取一个就是

41:18.180 --> 41:18.900
Ihamst

41:20.500 --> 41:21.060
Ihamst

41:21.860 --> 41:23.300
官方好像用这个名字

41:23.300 --> 41:24.100
用的是这个名字

41:24.100 --> 41:25.380
这个名字要增强的意思

41:25.460 --> 41:26.500
增强功能的意思

41:28.660 --> 41:28.980
对

41:28.980 --> 41:29.620
增强的意思

41:30.100 --> 41:31.860
好那么这个参数

41:31.860 --> 41:32.340
什么意思呢

41:32.340 --> 41:32.820
打个注射

41:34.020 --> 41:42.100
Ihamst表示ApplanetMiddleware返回的函数

41:42.100 --> 41:42.580
你看一下

41:42.580 --> 41:43.860
到时候我们调用的时候

41:44.180 --> 41:46.020
你看这里传的是不是ApplanetMiddleware

41:46.020 --> 41:46.660
把这个函

41:46.660 --> 41:47.380
调用这个函数

41:47.380 --> 41:48.500
它返回的函数

41:48.500 --> 41:49.300
返回什么函数

41:49.300 --> 41:50.020
就返回了这个

41:50.420 --> 41:50.740
对吧

41:50.740 --> 41:51.540
返回了这个函数

41:52.500 --> 41:53.940
把它返回的函数

41:54.660 --> 41:55.140
放到这

41:55.540 --> 41:57.140
不是ApplanetMiddleware本身

41:57.140 --> 41:57.700
是吧

41:57.700 --> 41:59.140
调用ApplanetMiddleware之后

41:59.140 --> 41:59.940
返回的函数

41:59.940 --> 42:00.340
放到这

42:01.380 --> 42:02.820
那么现在的问题是

42:02.820 --> 42:04.820
我怎么知道这个Ihamst

42:05.460 --> 42:06.980
我怎么知道这个Ihamst

42:07.620 --> 42:08.340
它的就是

42:09.140 --> 42:10.180
它的各种情况了

42:10.180 --> 42:10.820
就是说

42:10.820 --> 42:12.020
因为有可能我调的时候

42:12.020 --> 42:13.060
只传了两个参数对吧

42:13.620 --> 42:14.580
不要说Applanet

42:14.580 --> 42:15.620
就是CrisisDone

42:15.620 --> 42:16.820
里面它只传了两个参数

42:17.300 --> 42:18.820
一个是Reducer

42:18.820 --> 42:20.020
一个是中间键

42:20.580 --> 42:21.460
只传两个参数

42:21.460 --> 42:22.100
那么也就是说

42:22.100 --> 42:22.740
这个Ihamst

42:22.740 --> 42:23.860
还跑到第二个参数去了

42:24.580 --> 42:25.380
如果说你传了

42:25.380 --> 42:26.900
默认这个状态的话

42:26.900 --> 42:28.020
它就是第三个参数

42:28.020 --> 42:29.620
所以这个地方要进行分析

42:30.340 --> 42:31.140
分析啥呢

42:31.140 --> 42:32.580
我们这里来梳理一下

42:32.580 --> 42:33.540
梳理一下这个分析

42:34.580 --> 42:35.540
分析啥呢

42:35.540 --> 42:35.940
就是说

42:35.940 --> 42:37.940
如果说你这个CrisisDone

42:37.940 --> 42:39.220
是这样调用的

42:39.220 --> 42:40.660
前面是一个Reducer

42:40.660 --> 42:43.380
后边是ApplanetMiddleware

42:49.140 --> 42:50.180
如果你是这样调用的

42:50.740 --> 42:52.260
那如果你是这样调用的话

42:52.340 --> 42:53.300
我们就认为

42:56.100 --> 42:58.900
你传到第二个参数是Ihamst

42:58.900 --> 43:00.020
那么我们分析出来的结果

43:00.020 --> 43:00.740
就是Reducer

43:00.740 --> 43:02.020
第一个参数不用管

43:02.020 --> 43:03.060
那么我们分析出来的结果

43:03.060 --> 43:04.020
就是第二个参数

43:05.300 --> 43:09.220
就是第二参数DefaultState

43:09.220 --> 43:10.180
就是一个Ihamst

43:10.900 --> 43:11.540
Ihamst

43:12.580 --> 43:14.100
等于第二个参数对吧

43:14.660 --> 43:17.300
它的就是那个

43:18.500 --> 43:20.180
那个就是增强

43:20.180 --> 43:21.380
就是ApplanetMiddleware

43:21.460 --> 43:22.420
它返回了东西

43:22.420 --> 43:23.220
返回了东西

43:23.940 --> 43:25.220
ApplanetMiddleware返回了东西

43:25.220 --> 43:26.500
那么就是第二个参数

43:27.140 --> 43:27.780
然后呢

43:27.780 --> 43:29.940
它的默认值是不是你没有传递

43:29.940 --> 43:30.340
对吧

43:30.340 --> 43:31.860
我认为你没有传递默认值

43:31.860 --> 43:32.900
那么为undefined

43:32.900 --> 43:33.300
对吧

43:33.300 --> 43:34.500
这是我们要分析出来的结果

43:35.060 --> 43:36.100
要形成这么一种结构

43:36.820 --> 43:37.060
好

43:37.060 --> 43:38.500
如果说你是这样的传递的

43:39.140 --> 43:40.180
就看你怎么传递

43:40.740 --> 43:41.860
第二个是默认值

43:41.860 --> 43:42.660
默认值

43:43.300 --> 43:44.420
那么这种情况下呢

43:44.420 --> 43:46.100
那Ihamst就保持不变

43:46.100 --> 43:46.900
保持不变

43:47.380 --> 43:48.020
就完事了

43:48.580 --> 43:48.980
对不对

43:49.540 --> 43:50.740
咱们就用这种方式来分析

43:50.740 --> 43:52.420
所以说这里分析其实也很简单

43:52.420 --> 43:54.020
就是判断一下第二个参数

43:54.820 --> 43:57.140
当然官方的代码里边

43:57.140 --> 43:58.020
它分析的更多一点

43:58.020 --> 43:59.780
它判断就是你的参数格式

44:00.260 --> 44:02.020
如果说两个都传了两个

44:02.020 --> 44:02.820
函数进来也不行

44:02.820 --> 44:03.620
它给你报错

44:03.620 --> 44:04.980
官方可能考虑多一点

44:04.980 --> 44:06.900
我们这里就是用最简单的模式的话

44:07.700 --> 44:09.380
那么就考虑就这两种情况

44:09.380 --> 44:11.140
就这两种情况就行了

44:11.140 --> 44:13.140
那么我们只需要判断第二个参数

44:13.140 --> 44:14.100
是不是函数就行了

44:15.380 --> 44:17.060
如果说第二参数是函数的话

44:17.060 --> 44:18.100
那么要干嘛呢

44:18.100 --> 44:19.780
Ihamst等于第二个参数

44:20.900 --> 44:21.460
第二参数

44:23.220 --> 44:24.260
第二参数是函数

44:25.380 --> 44:26.340
第二个参数

44:26.820 --> 44:33.060
第二个参数是应用中间键的函数返回值

44:33.940 --> 44:35.460
返回值自然也是个函数

44:35.460 --> 44:35.700
对不对

44:35.700 --> 44:36.580
我们这样写过的

44:37.220 --> 44:38.340
返回值就是这个函数

44:38.340 --> 44:38.740
对吧

44:38.740 --> 44:39.380
就是这个函数

44:42.020 --> 44:44.500
然后要把default state

44:44.500 --> 44:45.780
把它视为undefined

44:45.780 --> 44:47.220
就是默认值它就没有了

44:47.220 --> 44:48.100
没有默认值了

44:48.900 --> 44:49.540
没有默认值

44:49.540 --> 44:50.420
因为你是这样

44:51.380 --> 44:52.180
你是这样的传递的

44:52.740 --> 44:53.380
你是这样的传递的

44:53.380 --> 44:54.500
它自然没有默认值了

44:55.300 --> 44:56.340
那么这种情况下

44:56.340 --> 44:57.300
那就没什么好说的

44:57.300 --> 44:58.020
它都是对应的

44:59.060 --> 45:00.980
那么这样子做个处理

45:00.980 --> 45:01.940
处理完了过后

45:01.940 --> 45:03.140
最后我们来判断

45:03.140 --> 45:05.300
Type of Ihamst

45:05.300 --> 45:09.860
是不是等于什么方形

45:09.860 --> 45:11.220
是不是等于一个函数

45:11.220 --> 45:12.660
就是说如果说它是第二个坛数

45:12.660 --> 45:13.460
我们已经处理过了

45:13.460 --> 45:14.260
它一定是函数

45:15.060 --> 45:16.260
但是如果是第三个坛数

45:16.660 --> 45:17.540
还有些其他情况

45:18.500 --> 45:20.980
那么我们要判断一下

45:20.980 --> 45:23.060
你这个Ihamst是不是函数

45:23.060 --> 45:24.500
如果是函数的话

45:25.540 --> 45:28.340
我就进入Apply

45:29.380 --> 45:29.860
medal

45:30.740 --> 45:33.940
medalware的处理逻辑

45:34.500 --> 45:36.260
而不是进入后边的处理逻辑的

45:37.220 --> 45:38.740
不是进入后边的处理逻辑

45:38.740 --> 45:39.780
而是进入什么

45:39.780 --> 45:41.780
Apply middleware的处理逻辑

45:41.780 --> 45:44.580
也就是说这里我们要返回的是什么了

45:44.580 --> 45:46.420
返回的是Apply

45:47.220 --> 45:48.100
Apply middleware

45:49.860 --> 45:51.540
要返回的是这个增强函数

45:51.540 --> 45:52.660
这个增强函数

45:52.660 --> 45:54.900
是不是就是Apply middleware的返回的东西

45:54.900 --> 45:55.700
这个增强函数

45:55.700 --> 45:57.300
你看一下是不是就这个函数

45:57.300 --> 45:58.980
那么这个函数是不是我们要调用它

45:58.980 --> 46:00.580
调用把quizstone传进去

46:00.580 --> 46:01.620
把这些参数传进去

46:01.620 --> 46:02.180
对吧

46:02.180 --> 46:04.820
好我们把Ihamst

46:04.820 --> 46:06.580
把quizstone传进去

46:06.580 --> 46:08.020
quizstone是不是当前这个函数

46:08.020 --> 46:09.700
当前这个函数不就是quizstone

46:09.700 --> 46:10.580
我们给它个名字

46:11.700 --> 46:12.660
不就是这个函数吗

46:12.660 --> 46:14.500
好我们把这个函数传进去

46:14.580 --> 46:18.180
然后再把reducer

46:18.180 --> 46:20.660
再把default state

46:20.660 --> 46:23.060
这东西都传进去

46:23.060 --> 46:25.220
那么通过Apply middleware

46:25.220 --> 46:28.740
通过Apply middleware来完成仓库的创建

46:28.740 --> 46:30.900
而不再通过后边的方式了

46:30.900 --> 46:32.900
不再通过后边的方式了

46:32.900 --> 46:34.420
通过它来完成创建

46:34.420 --> 46:37.220
就是在这里加上这么一段代码就完成了

46:37.220 --> 46:40.100
好那么这样子一写了过后

46:40.100 --> 46:41.300
那么方式1

46:41.300 --> 46:43.500
你看一下方式1也能用了

46:43.500 --> 46:44.900
爆出来

46:44.900 --> 46:46.100
你看是不是也能用了

46:46.100 --> 46:47.300
对吧

46:47.300 --> 46:49.420
这就是Apply middleware它的书写方式

46:49.420 --> 46:51.660
已经对quizstone的进行改造

46:51.660 --> 46:52.340
没有多好代码

46:52.340 --> 46:54.820
就是特别特别绕

46:54.820 --> 46:56.300
所以为什么是扩展课程的

46:56.300 --> 46:58.820
扩展课程是给那些有经历

46:58.820 --> 47:01.300
有兴趣的同学准备的

47:03.700 --> 47:05.500
因为这个学习

47:05.500 --> 47:07.500
你得承认首先你得承认

47:07.500 --> 47:08.980
有个正确的认知

47:08.980 --> 47:09.980
就是这个学习

47:09.980 --> 47:13.020
肯定每一个人的学习能力是不一样的

47:13.780 --> 47:16.020
虽然说这样说起来好像有点不公平

47:16.020 --> 47:17.860
但是事实如此

47:17.860 --> 47:20.060
每个人他的成长环境

47:20.060 --> 47:22.780
家庭教育学校教育

47:22.780 --> 47:24.580
智慧接触的人都不一样

47:24.580 --> 47:26.700
养成的习惯也不一样

47:26.700 --> 47:28.340
他的思维模式也不一样

47:28.340 --> 47:30.100
肯定是有差异的

47:30.100 --> 47:32.100
但是虽然说有差异

47:32.100 --> 47:34.340
但是每个人最终他都能学懂

47:34.340 --> 47:37.140
只是花了时间多少而已

47:37.140 --> 47:37.940
那这个没办法

47:37.940 --> 47:39.500
这个这是一个现实的问题

47:39.500 --> 47:40.620
大家得承认

47:40.620 --> 47:41.300
包括我

47:41.300 --> 47:42.740
我一直说我不是给大家签讯

47:42.740 --> 47:44.060
我真的不是给大家签讯

47:44.060 --> 47:46.500
我真的是挺笨的

47:46.500 --> 47:47.540
我学习起来了

47:47.540 --> 47:48.940
可能比有些同学而言

47:48.940 --> 47:52.100
要花更多的时间

47:52.100 --> 47:53.060
那没办法

47:53.060 --> 47:54.940
但是我现在还不是学到这些这样子

47:54.940 --> 47:56.660
我记住大家听了那么久

47:56.660 --> 47:57.820
还熊吧

47:57.820 --> 47:59.020
还熊吧

47:59.020 --> 48:01.660
所以说大家也不用去太害怕这个东西

48:01.660 --> 48:02.780
你哪怕现在不懂

48:02.780 --> 48:03.860
他这个货场课什么

48:03.860 --> 48:05.220
哪怕你现在不懂

48:05.220 --> 48:06.220
没事就来想一想

48:06.220 --> 48:07.420
没事就来看一看

48:07.420 --> 48:08.180
慢慢慢慢的

48:08.180 --> 48:09.660
你终究会理解的

48:09.660 --> 48:10.140
放心

48:10.140 --> 48:11.660
我可以负责任的告诉大家

48:11.700 --> 48:13.660
终究会理解的

48:13.660 --> 48:14.220
好吧

48:14.220 --> 48:14.660
OK

48:14.660 --> 48:15.260
那就是这里

48:15.260 --> 48:16.620
这里就是Chris Stone

48:16.620 --> 48:17.900
这个函数还要说的事情

48:19.860 --> 48:20.740
没了

48:20.740 --> 48:22.060
那咱们这一张就结束了

48:22.060 --> 48:23.220
Redux这一张就结束了

48:23.220 --> 48:25.820
我们把Redux所有功能全部讲完了

48:25.820 --> 48:26.580
全部讲完了

48:26.580 --> 48:29.300
并且功能全部用手续代码的形式写出来了

48:29.300 --> 48:30.100
大家可以发现

48:30.100 --> 48:31.700
Redux其实没有多少代码

48:31.700 --> 48:33.300
它跟Redux Router相比的话

48:33.300 --> 48:35.220
它代码量少很多

48:35.220 --> 48:36.220
没有多少代码

48:36.220 --> 48:38.860
但是它里面有非常非常精妙的处理

48:38.860 --> 48:40.260
来帮助你去管理数据

48:41.700 --> 48:42.980
那么下一张呢我们讲什么呢

48:42.980 --> 48:45.260
下一张我们还不着急进入Redux

48:45.260 --> 48:48.460
Redux结合是一个非常非常自然的一个过程

48:48.460 --> 48:49.860
就是很多同学学习的时候

48:49.860 --> 48:50.940
一旦看不到界面

48:50.940 --> 48:52.420
他心里面就感觉不舒服

48:52.420 --> 48:53.900
感觉没有意思

48:53.900 --> 48:54.900
实际上程序

48:54.900 --> 48:56.740
你真正去理解程序的话

48:56.740 --> 48:58.540
理解的程序真正入了门的话

48:58.540 --> 49:00.260
你会发现根本不在

49:00.260 --> 49:01.500
不在乎界面

49:01.500 --> 49:02.500
界面是什么样子

49:02.500 --> 49:03.620
其实很简单的

49:03.620 --> 49:06.020
真正麻烦的是数据和逻辑处理

49:06.020 --> 49:07.700
这才是程序最核心的地方

49:07.700 --> 49:10.380
所以说咱们下一张还不着急进入Redux

49:10.500 --> 49:14.740
我们先去了解一些第三方的中间键

49:14.740 --> 49:15.740
因为这里学习了中间键

49:16.260 --> 49:17.540
了解一些第三方的中间键

49:17.540 --> 49:19.780
他们来解决Redux里边

49:19.780 --> 49:21.740
有些没有处理的问题

49:21.740 --> 49:23.300
因为Redux它不为了保持纯粹

49:23.300 --> 49:25.140
它只处理很少很少的东西

49:25.140 --> 49:25.860
像什么副作用

49:25.860 --> 49:27.220
大家可是请求到那里写到哪

49:27.220 --> 49:28.540
你说没地方写

49:28.540 --> 49:29.980
那么这些东西该怎么来处理

49:29.980 --> 49:30.900
有些第三方库

49:30.900 --> 49:33.180
它通过中间键的形式给你搞定的

49:33.180 --> 49:35.380
咱们下一张主要是研究中间键

49:35.380 --> 49:38.900
而中间键里面研究的终点就是副作用

49:38.900 --> 49:40.260
你的副作用代码该怎么写

49:40.300 --> 49:41.100
写到哪

49:41.100 --> 49:42.380
主要是研究这个东西

49:42.380 --> 49:43.140
好吧

49:43.140 --> 49:43.860
ok

49:43.860 --> 49:46.940
咱们这几个这一张也就到这里了

49:46.940 --> 49:49.340
下来大家还是如果听到这个扩展课程的话

49:49.340 --> 49:51.140
下来还是写一下去体会一下

49:51.140 --> 49:51.660
好吧

