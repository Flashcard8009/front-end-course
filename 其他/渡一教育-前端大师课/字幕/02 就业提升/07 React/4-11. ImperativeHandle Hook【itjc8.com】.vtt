WEBVTT

00:00.560 --> 00:03.560
来吧 又是一个hook

00:03.560 --> 00:10.560
这个叫做imperative handle hook

00:10.560 --> 00:13.560
哎呦 我的天啊 这个英语单词啊 真的是

00:13.560 --> 00:17.560
我发誓 算了 我不发誓

00:17.560 --> 00:20.560
每次要发誓 做什么事情的话

00:20.560 --> 00:22.560
不完成就是狗

00:22.560 --> 00:25.560
结果呢 什么屏东的狗都当过了

00:25.560 --> 00:27.560
算了 算了 不发誓了

00:28.560 --> 00:29.560
就这个玩意儿

00:29.560 --> 00:31.560
这个玩意儿呢 很少见啊

00:31.560 --> 00:33.560
在我们开发过程中非常非常少见

00:33.560 --> 00:35.560
这个玩意儿用来做什么呢

00:35.560 --> 00:38.560
我用文字的话还真不是很好

00:38.560 --> 00:40.560
给大家说清楚啊

00:40.560 --> 00:42.560
嗯 这里

00:42.560 --> 00:44.560
给大家举个例子

00:44.560 --> 00:46.560
比方说呢 是这么一种情况

00:46.560 --> 00:49.560
咱们以前呢 不是使用ref嘛

00:49.560 --> 00:51.560
对吧 不是使用ref嘛

00:51.560 --> 00:55.560
我们之前呢 写过这么一种类似的例子吧

00:56.560 --> 00:58.560
时间已经稍微有点久远了

00:58.560 --> 01:00.560
我不太记得清楚了啊

01:00.560 --> 01:03.560
总之 我当时写过这么一个类似的例子

01:03.560 --> 01:07.560
好像是 对 好像就是那个轮波图那里

01:07.560 --> 01:09.560
轮波图那里我们用到了ref 对吧

01:09.560 --> 01:11.560
当时我们用的是类组件

01:11.560 --> 01:13.560
比方说吧 我们这里写这么一个类组件

01:13.560 --> 01:16.560
is tens react

01:16.560 --> 01:18.560
就是类组件呢

01:18.560 --> 01:19.560
它可以完成这样的功能

01:19.560 --> 01:21.560
但是韩式组件呢 它不行

01:21.560 --> 01:23.560
那么我们看韩式组件怎么在做

01:23.560 --> 01:25.560
就类组件里边呢

01:25.560 --> 01:28.560
我们Render的话就随便哪一个呗

01:28.560 --> 01:30.560
随便哪一个Render啊

01:30.560 --> 01:32.560
Render的话return

01:32.560 --> 01:34.560
返回一个 返回一个啥玩意儿呢

01:34.560 --> 01:36.560
返回一个he

01:36.560 --> 01:38.560
test component

01:38.560 --> 01:40.560
就返回这么一个东西

01:40.560 --> 01:43.560
然后在app里边的去使用这个玩意儿

01:44.560 --> 01:46.560
去使用这个组件

01:46.560 --> 01:48.560
咱们把它运行出来吧

01:51.580 --> 01:52.580
运行出来

01:52.580 --> 01:53.580
我要干嘛呢

01:53.580 --> 01:55.580
就是这个test这个组件里边呢

01:55.580 --> 01:57.580
它可能呢 提供了一些方法

01:57.580 --> 01:59.580
比方说提供了一个方法

01:59.580 --> 02:01.580
叫做method

02:01.580 --> 02:03.580
提供了这么一个方法

02:03.580 --> 02:05.580
这个方法呢

02:05.580 --> 02:07.580
我们就测试一下吧

02:07.580 --> 02:09.580
因为这个地方确实用的太少太少了

02:09.580 --> 02:11.580
所以我们测试一下就行了

02:11.580 --> 02:12.580
那么这里呢

02:12.580 --> 02:16.580
就是test method code

02:16.580 --> 02:18.580
表示这个韩数里边的

02:18.580 --> 02:20.580
method的方法呢 被调用了

02:20.580 --> 02:21.580
就说这么一句话

02:21.580 --> 02:23.580
那么现在呢 我要做这么一件事情

02:23.580 --> 02:25.580
就是这个app组件里边呢

02:25.580 --> 02:27.580
它不是使用了这个test组件吗

02:27.580 --> 02:28.580
对吧

02:28.580 --> 02:29.580
然后呢

02:29.580 --> 02:31.580
我希望 app组件下面的一个按钮

02:31.580 --> 02:33.580
点击

02:33.580 --> 02:35.580
调用

02:35.580 --> 02:36.580
test

02:36.580 --> 02:37.580
组件的

02:37.580 --> 02:38.580
method的

02:38.580 --> 02:39.580
方法

02:39.580 --> 02:41.580
调用这个test组件的method的方法

02:41.580 --> 02:43.580
就这么一个意思

02:43.580 --> 02:44.580
就是有的时候呢

02:44.580 --> 02:46.580
我们可能像直接去调用

02:46.580 --> 02:48.580
某一个组件里面的某一个方法

02:48.580 --> 02:50.580
可能像做这么一件事情

02:50.580 --> 02:52.580
那么这件事情呢 实际上

02:52.580 --> 02:54.580
实际上最好别这样做

02:54.580 --> 02:56.580
因为我当时还特别强调了

02:56.580 --> 02:57.580
ref这个东西呢

02:57.580 --> 03:00.580
它会打破这个reactor的这种结构

03:00.580 --> 03:01.580
reactor的结构呢

03:01.580 --> 03:04.580
它是不希望你直接用命令式的方式

03:04.580 --> 03:06.580
来操作组件里面的东西

03:06.580 --> 03:08.580
就是什么叫命令式的方式

03:08.580 --> 03:09.580
就是说我这里呢

03:09.580 --> 03:11.580
调用某一个对象的韩数

03:11.580 --> 03:12.580
某一个组件是个对象吧

03:12.580 --> 03:14.580
当然调用它的一个对象的韩数

03:14.580 --> 03:15.580
这就是命令式的方式

03:15.580 --> 03:16.580
在reactor里面

03:16.580 --> 03:18.580
它不希望你去这样做

03:18.580 --> 03:20.580
所以说呢ref这种方式呢

03:20.580 --> 03:21.580
尽量少用

03:21.580 --> 03:22.580
但是有的时候呢

03:22.580 --> 03:24.580
可能你没办法啊

03:24.580 --> 03:26.580
你必须得用这种方式

03:26.580 --> 03:27.580
这种情况很少很少

03:27.580 --> 03:29.580
如果说你遇到了这种情况

03:29.580 --> 03:30.580
要点击过和调用那个

03:30.580 --> 03:31.580
组件里面的方法的话

03:31.580 --> 03:32.580
当时我们怎么做的

03:32.580 --> 03:33.580
是不是给它一个ref啊

03:33.580 --> 03:34.580
对不对

03:34.580 --> 03:35.580
当时呢

03:35.580 --> 03:36.580
我们是给它一个ref

03:36.580 --> 03:37.580
对不对

03:37.580 --> 03:38.580
咱们给它一个ref嘛

03:38.580 --> 03:39.580
那么现在

03:39.580 --> 03:40.580
根据我们学过的

03:40.580 --> 03:41.580
什么use-ref对吧

03:41.580 --> 03:42.580
我们就当然也可以用什么

03:42.580 --> 03:44.580
rex-crease-ref对不对

03:44.580 --> 03:45.580
以前我们这样子用的

03:45.580 --> 03:46.580
当然我们现在用了

03:46.580 --> 03:48.580
有了这个use-ref之后呢

03:48.580 --> 03:49.580
更好

03:49.580 --> 03:51.580
它更加效率更加高

03:51.580 --> 03:53.580
因为它能够保证

03:53.580 --> 03:55.580
产生了是唯一的一个对象

03:55.580 --> 03:57.580
咱们就用这个嘛

03:57.580 --> 03:58.580
其实是一样的

03:58.580 --> 03:59.580
效果是完全一样的

03:59.580 --> 04:00.580
use-ref

04:00.580 --> 04:02.580
那么这里是不是产生了一个ref

04:02.580 --> 04:03.580
对吧

04:03.580 --> 04:04.580
我们这里

04:04.580 --> 04:05.580
接受一下

04:05.580 --> 04:07.580
test-ref

04:07.580 --> 04:08.580
产生这么一个东西

04:08.580 --> 04:09.580
好 放进来

04:09.580 --> 04:11.580
因为它是个内组件嘛

04:11.580 --> 04:12.580
内组件是不是可以

04:12.580 --> 04:13.580
可以直接加ref

04:13.580 --> 04:14.580
对吧

04:14.580 --> 04:15.580
内组件是可以直接加的

04:15.580 --> 04:16.580
好 接下来呢

04:16.580 --> 04:17.580
我们在这里

04:20.580 --> 04:22.580
I'm sorry

04:22.580 --> 04:24.580
好 点击这个按钮的时候呢

04:24.580 --> 04:25.580
我们干嘛呢

04:25.580 --> 04:27.580
我们是不是拿到这个ref

04:27.580 --> 04:28.580
拿到这个ref

04:28.580 --> 04:29.580
它的current

04:29.580 --> 04:30.580
是不是拿到这个

04:30.580 --> 04:32.580
内组件的对象

04:32.580 --> 04:33.580
对吧

04:33.580 --> 04:34.580
拿到这个内组件的对象

04:34.580 --> 04:35.580
好 然后对象里边

04:35.580 --> 04:36.580
是不是有这个方法

04:36.580 --> 04:37.580
没事的

04:37.580 --> 04:38.580
就这样的调用就完事了

04:38.580 --> 04:40.580
保存着看一下吧

04:41.580 --> 04:42.580
点击

04:42.580 --> 04:43.580
你看一下

04:43.580 --> 04:44.580
这方法被调用了

04:44.580 --> 04:45.580
对不对

04:45.580 --> 04:47.580
就是这么一个意思

04:47.580 --> 04:48.580
有的时候

04:48.580 --> 04:49.580
我们可能需要实现

04:49.580 --> 04:51.580
类似这么一个功能

04:51.580 --> 04:53.580
待会看一下这个代码

04:54.580 --> 04:56.580
那么现在我要说明一个

04:56.580 --> 04:57.580
什么问题呢

04:57.580 --> 04:58.580
就是说

04:58.580 --> 05:00.580
如果说

05:00.580 --> 05:01.580
这个玩意儿

05:01.580 --> 05:03.580
它不是一个内组件

05:03.580 --> 05:05.580
它而是一个函数组件

05:05.580 --> 05:06.580
那应该怎么做呢

05:06.580 --> 05:07.580
因为

05:07.580 --> 05:09.580
后可这个东西出来之后呢

05:09.580 --> 05:10.580
就是

05:10.580 --> 05:12.580
它希望

05:12.580 --> 05:15.580
作为内组件的一种替代品

05:15.580 --> 05:17.580
就是你不用去书写内组件了

05:17.580 --> 05:19.580
你可以直接书写hook

05:19.580 --> 05:21.580
当然内组件它目前还是肯定是支持的

05:21.580 --> 05:23.580
而且没有任何取向内组件的计划

05:23.580 --> 05:25.580
这我们之前说明的

05:25.580 --> 05:26.580
这里篮文比方说

05:26.580 --> 05:27.580
给它复制一下

05:27.580 --> 05:29.580
现在篮文把它变成函数组件

05:29.580 --> 05:30.580
看一下

05:30.580 --> 05:32.580
把这个task变成函数组件

05:32.580 --> 05:34.580
那么发现就有些区别了

05:35.580 --> 05:37.580
然后函数组件里面直接反回这个

05:37.580 --> 05:39.580
函数组件要减结很多

05:39.580 --> 05:40.580
你看一下是不是这样子

05:40.580 --> 05:41.580
对不对

05:41.580 --> 05:42.580
变成函数组件

05:42.580 --> 05:44.580
那么现在问题在哪呢

05:44.580 --> 05:45.580
它由于是个函数

05:45.580 --> 05:46.580
函数

05:46.580 --> 05:48.580
首先这个函数组件

05:48.580 --> 05:50.580
它能不能加rave

05:50.580 --> 05:52.580
它能不能加rave保存

05:52.580 --> 05:53.580
所以加不了

05:53.580 --> 05:54.580
对不对

05:54.580 --> 05:55.580
我们之前说过

05:55.580 --> 05:56.580
反复强调过

05:56.580 --> 05:57.580
这个函数组件

05:57.580 --> 05:59.580
你是不能使用函数组件

05:59.580 --> 06:00.580
是给它加rave的

06:00.580 --> 06:01.580
有什么意义

06:01.580 --> 06:02.580
它是个函数

06:02.580 --> 06:03.580
你要干嘛

06:03.580 --> 06:05.580
它里面又不存在什么实力方法

06:05.580 --> 06:06.580
这些东西

06:06.580 --> 06:07.580
要干嘛

06:07.580 --> 06:08.580
我也不知道你要干嘛

06:08.580 --> 06:10.580
所以说了函数组件

06:10.580 --> 06:11.580
是不能加rave的

06:11.580 --> 06:12.580
是不能加rave的

06:12.580 --> 06:14.580
但是我们当时也说过

06:14.580 --> 06:16.580
有一种方式叫做rave转发

06:16.580 --> 06:17.580
还记得吗

06:17.580 --> 06:19.580
很多人都忘完了

06:19.580 --> 06:21.580
有一种方式叫做rave转发

06:21.580 --> 06:22.580
就是什么意思呢

06:22.580 --> 06:24.580
在reactor里面

06:24.580 --> 06:25.580
它有这么一个东西

06:25.580 --> 06:26.580
reactor

06:26.580 --> 06:28.580
forward rave

06:28.580 --> 06:30.580
有这么一个rave转发方法

06:30.580 --> 06:32.580
你给它一个组件

06:32.580 --> 06:34.580
给它一个特色组件

06:34.580 --> 06:35.580
一个函数组件

06:35.580 --> 06:37.580
它实际上会给你包装一个

06:37.580 --> 06:39.580
反回的是一个内组件

06:39.580 --> 06:41.580
因为只有内组件才能使用rave

06:41.580 --> 06:43.580
才能在内组件

06:43.580 --> 06:45.580
才能在里面使用rave

06:45.580 --> 06:47.580
以及动物元素

06:47.580 --> 06:48.580
才能使用rave

06:48.580 --> 06:50.580
这里可以把包装一下

06:50.580 --> 06:52.580
相当于这个东西是一个高階

06:52.580 --> 06:53.580
高階组件

06:53.580 --> 06:54.580
你给它一个组件

06:54.580 --> 06:55.580
它反回一个组件

06:55.580 --> 06:57.580
这个组件你随便

06:57.580 --> 06:58.580
你可以再用这个特色

06:58.580 --> 06:59.580
重新接受一下

06:59.580 --> 07:00.580
给它复制

07:00.580 --> 07:01.580
都可以

07:01.580 --> 07:02.580
这样子做也行

07:05.580 --> 07:06.580
对吧

07:06.580 --> 07:07.580
但是它这样子

07:07.580 --> 07:08.580
它建议你不要这样做

07:08.580 --> 07:10.580
让你尽量用另外一个变量

07:10.580 --> 07:11.580
行吧

07:11.580 --> 07:12.580
来吧

07:12.580 --> 07:13.580
用另外一个变量

07:16.580 --> 07:17.580
Test

07:17.580 --> 07:18.580
Test Wifre

07:19.580 --> 07:20.580
比方有这么一个组件

07:20.580 --> 07:22.580
然后我们把这个组件

07:22.580 --> 07:23.580
用进来

07:23.580 --> 07:24.580
这个组件

07:24.580 --> 07:25.580
那么这个组件

07:25.580 --> 07:26.580
它肯定是一个内组件

07:26.580 --> 07:28.580
它反回的是一个新的组件

07:28.580 --> 07:29.580
新的组件肯定是个内组件

07:29.580 --> 07:30.580
才能使用rave

07:30.580 --> 07:31.580
那么现在的保存

07:31.580 --> 07:32.580
你看一下

07:32.580 --> 07:33.580
就不爆错了

07:33.580 --> 07:34.580
于是现在

07:34.580 --> 07:35.580
它是这样子

07:35.580 --> 07:37.580
当你使用内组件的时候

07:37.580 --> 07:39.580
给它传了一个rave进去

07:39.580 --> 07:40.580
它会怎么样呢

07:40.580 --> 07:42.580
它会把这个rave

07:42.580 --> 07:43.580
作为参数

07:44.580 --> 07:46.580
传到你包装的这个组件里边去

07:47.580 --> 07:48.580
于是这里

07:48.580 --> 07:49.580
第2参数probs

07:49.580 --> 07:50.580
第2参数是不是rave

07:50.580 --> 07:51.580
我们之前讲过

07:51.580 --> 07:52.580
都是讲过的

07:53.580 --> 07:55.580
然后我们当时来讲的是什么

07:55.580 --> 07:56.580
这个rave

07:56.580 --> 07:58.580
你可以任意处理

07:58.580 --> 07:59.580
随意处理

07:59.580 --> 08:00.580
这个rave

08:00.580 --> 08:01.580
你随便怎么处理都可以

08:01.580 --> 08:02.580
这个rave

08:02.580 --> 08:03.580
你可以把它加到一个

08:03.580 --> 08:04.580
这个组件里面

08:04.580 --> 08:05.580
动物元素里面

08:05.580 --> 08:06.580
你想打处理

08:06.580 --> 08:07.580
比方说

08:07.580 --> 08:08.580
加到这

08:08.580 --> 08:09.580
对吧

08:09.580 --> 08:10.580
加到这

08:10.580 --> 08:11.580
那么这样子一来

08:11.580 --> 08:12.580
这边得到了rave值

08:12.580 --> 08:13.580
这个rave值

08:13.580 --> 08:14.580
我们输出一下

08:15.580 --> 08:17.580
这边得到了rave值

08:17.580 --> 08:18.580
tessa rave

08:18.580 --> 08:19.580
corrent

08:19.580 --> 08:21.580
那么是不是这个he元素

08:21.580 --> 08:22.580
对吧

08:22.580 --> 08:23.580
点击一看是不是

08:23.580 --> 08:24.580
he元素

08:24.580 --> 08:25.580
对吧

08:25.580 --> 08:26.580
通过rave转发

08:26.580 --> 08:27.580
我这里rave传给你

08:27.580 --> 08:28.580
就像属性一样

08:28.580 --> 08:29.580
把rave传给你

08:29.580 --> 08:30.580
然后你

08:30.580 --> 08:32.580
通过这个包装器

08:32.580 --> 08:33.580
把rave的值

08:33.580 --> 08:35.580
传递给了这个函数

08:35.580 --> 08:36.580
你爱咋处理咋处理

08:36.580 --> 08:37.580
这就是个对象而已

08:37.580 --> 08:39.580
爱咋处理咋处理

08:39.580 --> 08:40.580
就这么个意思

08:40.580 --> 08:41.580
就这么个意思

08:41.580 --> 08:43.580
那么现在呢

08:43.580 --> 08:44.580
我们要做的事情

08:44.580 --> 08:45.580
不是说把它放到一个

08:45.580 --> 08:46.580
什么he元素上

08:46.580 --> 08:48.580
我要实现这么一个功能

08:48.580 --> 08:49.580
到时候还要能够

08:49.580 --> 08:50.580
调用mesc的方法

08:50.580 --> 08:52.580
到时候还要能够这样子写

08:54.580 --> 08:55.580
那这个东西怎么办的

08:55.580 --> 08:56.580
这个东西

08:56.580 --> 08:57.580
这个东西咋办的

08:57.580 --> 08:58.580
这没法处理啊

08:58.580 --> 08:59.580
这个玩意这个东西

08:59.580 --> 09:01.580
它怎么去调用mesc的方法呢

09:01.580 --> 09:02.580
对不对

09:02.580 --> 09:03.580
怎么处理呢

09:03.580 --> 09:04.580
没法处理的

09:04.580 --> 09:05.580
因为它是一个函数

09:05.580 --> 09:06.580
对吧

09:06.580 --> 09:07.580
所以说呢

09:07.580 --> 09:09.580
这个玩意就派上用场了

09:09.580 --> 09:12.580
叫做imperative handle hook

09:12.580 --> 09:14.580
那么它对你的函数

09:14.580 --> 09:15.580
函数

09:15.580 --> 09:17.580
自然而然就是什么

09:17.580 --> 09:22.580
use imperative handle hook

09:22.580 --> 09:24.580
这是它对你的函数

09:24.580 --> 09:25.580
那么先

09:25.580 --> 09:26.580
请啊

09:26.580 --> 09:28.580
咱们把这个函数倒进来

09:28.580 --> 09:32.580
use imperative handle

09:32.580 --> 09:33.580
就这个函数

09:33.580 --> 09:34.580
那么这个函数怎么用呢

09:34.580 --> 09:36.580
我们现在不是用这种方式了

09:36.580 --> 09:37.580
那么这个函数怎么用呢

09:37.580 --> 09:39.580
就是use imperative handle

09:39.580 --> 09:40.580
然后这里边呢

09:40.580 --> 09:42.580
第一个函数就传的是Rave

09:42.580 --> 09:43.580
因为Rave呢

09:43.580 --> 09:45.580
它本质上是一个对象

09:45.580 --> 09:47.580
对象里面不是有corrent

09:47.580 --> 09:48.580
对不对

09:48.580 --> 09:50.580
不就是有corrent吗

09:50.580 --> 09:51.580
那么

09:51.580 --> 09:52.580
第二个参数

09:52.580 --> 09:54.580
就是给它corrent

09:54.580 --> 09:55.580
这个属性

09:55.580 --> 09:57.580
付一个出值

09:57.580 --> 09:59.580
你想付啥值

09:59.580 --> 10:00.580
就付啥值

10:00.580 --> 10:01.580
你知道这个意思吧

10:01.580 --> 10:02.580
你想给它付啥值

10:02.580 --> 10:04.580
就付啥值

10:04.580 --> 10:05.580
随便你

10:05.580 --> 10:07.580
随便你

10:07.580 --> 10:09.580
这就是这个

10:09.580 --> 10:10.580
第二个参数

10:10.580 --> 10:11.580
第二个参数呢

10:11.580 --> 10:12.580
它是这样子

10:12.580 --> 10:13.580
它是一个函数

10:13.580 --> 10:15.580
这个函数的返回结果呢

10:15.580 --> 10:17.580
它会把它作为corrent的值

10:17.580 --> 10:18.580
给它复制进去

10:18.580 --> 10:20.580
比方说我们这里写个函数啊

10:20.580 --> 10:21.580
这个函数呢

10:21.580 --> 10:22.580
返回一个数字1

10:22.580 --> 10:23.580
比方说嘛

10:23.580 --> 10:24.580
随便写嘛

10:24.580 --> 10:25.580
返回一个数字1

10:25.580 --> 10:26.580
那么这样子一来的话

10:26.580 --> 10:28.580
它是相当于是什么呢

10:28.580 --> 10:30.580
相当于是

10:30.580 --> 10:32.580
相当于

10:32.580 --> 10:33.580
给

10:33.580 --> 10:35.580
Ref的corrent

10:35.580 --> 10:36.580
复制为了1

10:36.580 --> 10:37.580
就这个意思

10:37.580 --> 10:38.580
二

10:38.580 --> 10:39.580
这个东西不就是个对象吗

10:39.580 --> 10:40.580
咱们之前探讨过

10:40.580 --> 10:41.580
这个Ref的本质

10:41.580 --> 10:42.580
就是一个普通对象

10:42.580 --> 10:43.580
它里面有个corrent的属性

10:43.580 --> 10:45.580
相当于是给它复制为了1

10:45.580 --> 10:46.580
就这么个意思

10:46.580 --> 10:47.580
好 保存啊

10:47.580 --> 10:48.580
保存

10:48.580 --> 10:49.580
那么现在呢

10:49.580 --> 10:50.580
我们看一下

10:50.580 --> 10:51.580
我们这里输出这个

10:51.580 --> 10:53.580
testRef

10:53.580 --> 10:55.580
testRef

10:55.580 --> 10:56.580
保存

10:56.580 --> 10:57.580
点击

10:57.580 --> 10:58.580
你看是不是1

10:58.580 --> 10:59.580
就这么简单

10:59.580 --> 11:00.580
你刚才返回啥值

11:00.580 --> 11:01.580
就复啥值

11:01.580 --> 11:02.580
就这个函数

11:02.580 --> 11:03.580
那么这个函数

11:03.580 --> 11:04.580
什么时候调用呢

11:04.580 --> 11:06.580
这个函数是初始的时候调用

11:08.580 --> 11:09.580
该函数

11:09.580 --> 11:10.580
第一次

11:12.580 --> 11:13.580
夹展

11:13.580 --> 11:14.580
组件

11:14.580 --> 11:15.580
后调用

11:16.580 --> 11:17.580
之后呢

11:17.580 --> 11:18.580
之后因为这个

11:18.580 --> 11:19.580
是一个函数组件

11:19.580 --> 11:20.580
那个函数可能会反复调用

11:20.580 --> 11:21.580
导说这个函数

11:21.580 --> 11:22.580
会反复调用

11:22.580 --> 11:23.580
之后

11:23.580 --> 11:24.580
是这样的

11:24.580 --> 11:25.580
我们看一下测试一下吧

11:26.580 --> 11:27.580
说实话

11:27.580 --> 11:28.580
这个地方用的很少

11:28.580 --> 11:29.580
我又有点忘了这个API了

11:29.580 --> 11:31.580
我们这里函数里边输出一个吧

11:31.580 --> 11:32.580
输出一个

11:33.580 --> 11:34.580
123

11:35.580 --> 11:36.580
我们这里呢

11:36.580 --> 11:38.580
为了刷新这个组件

11:38.580 --> 11:40.580
为了刷新这个组件

11:41.580 --> 11:42.580
我们这里呢

11:42.580 --> 11:43.580
为了刷新它的话

11:43.580 --> 11:45.580
强制刷新一下嘛

11:47.580 --> 11:48.580
强制刷新组件

11:48.580 --> 11:49.580
UseState

11:50.580 --> 11:51.580
再测试一下就行了

11:53.580 --> 11:54.580
有的时候那些API忘了

11:54.580 --> 11:55.580
没关系

11:55.580 --> 11:56.580
都不是很重要

11:56.580 --> 11:57.580
就是

11:57.580 --> 11:58.580
要知道怎么去测试就完成

11:59.580 --> 12:00.580
ForceUpdate

12:03.580 --> 12:07.660
其实这个东西还可以封装一下

12:07.660 --> 12:08.660
说实话

12:08.660 --> 12:09.660
大家可以自己想一想

12:09.660 --> 12:10.660
怎么去封装

12:10.660 --> 12:11.660
把封装一个函数

12:11.660 --> 12:12.660
ForceUpdate一调用

12:12.660 --> 12:13.660
就去刷新组件

12:14.660 --> 12:15.660
那么这里呢

12:17.660 --> 12:18.660
点击过后

12:18.660 --> 12:19.660
我们刷新一次

12:19.660 --> 12:20.660
ForceUpdate

12:22.660 --> 12:23.660
看一下

12:24.660 --> 12:25.660
输出123

12:25.660 --> 12:26.660
调用一次

12:26.660 --> 12:28.660
还是输出了

12:28.660 --> 12:29.660
还是输出了

12:29.660 --> 12:30.660
说明一下呢

12:30.660 --> 12:31.660
说明一下

12:31.660 --> 12:33.660
这个是每次都要调用的

12:33.660 --> 12:34.660
每次都要调用的

12:34.660 --> 12:35.660
就是说

12:35.660 --> 12:36.660
第一次加点

12:36.660 --> 12:38.660
就是如果说

12:38.660 --> 12:42.660
如果不给依赖项

12:42.660 --> 12:46.660
则每次调用

12:46.660 --> 12:50.660
每次运行函数组件

12:50.660 --> 12:52.660
都会调用

12:53.660 --> 12:56.660
都会调用该方法

12:56.660 --> 12:57.660
得到返回值

12:57.660 --> 12:58.660
把这个返回值

12:58.660 --> 13:00.660
作为Ref

13:00.660 --> 13:01.660
给它复制为Ref的

13:01.660 --> 13:02.660
current这个属性

13:03.660 --> 13:05.660
如果说你给它加依赖项呢

13:05.660 --> 13:06.660
加依赖项的话

13:06.660 --> 13:07.660
就第三个参数了

13:07.660 --> 13:08.660
就依赖项

13:08.660 --> 13:09.660
这个没什么好多的

13:09.660 --> 13:11.660
跟其他都是一样的

13:11.660 --> 13:13.660
如果使用依赖项的话

13:13.660 --> 13:18.660
如果使用了依赖项

13:18.660 --> 13:20.660
则

13:20.660 --> 13:24.660
第一次调用后

13:24.660 --> 13:26.660
会进行缓存

13:26.660 --> 13:28.660
把这个值缓存下来

13:28.660 --> 13:31.660
只有依赖项发生

13:31.660 --> 13:33.660
变化时

13:33.660 --> 13:36.660
才会重新调用函数

13:36.660 --> 13:38.660
就这么简单

13:38.660 --> 13:39.660
通常情况下

13:39.660 --> 13:41.660
我们都不太会

13:41.660 --> 13:42.660
让它反复调用

13:42.660 --> 13:43.660
一般就调用一次

13:43.660 --> 13:44.660
就完事了

13:44.660 --> 13:45.660
保存

13:45.660 --> 13:46.660
你看一下

13:46.660 --> 13:47.660
那么现在呢

13:47.660 --> 13:48.660
是不是只调用一次

13:48.660 --> 13:50.660
没有给它依赖项

13:50.660 --> 13:51.660
当然我这里

13:51.660 --> 13:53.660
不知道该给什么样的依赖项

13:53.660 --> 13:54.660
那么这里呢

13:54.660 --> 13:55.660
我们先最终

13:55.660 --> 13:56.660
要实现什么

13:56.660 --> 13:58.660
要实现这个方法

13:58.660 --> 14:05.560
要实现这种方式

14:05.560 --> 14:07.560
就是这样

14:07.560 --> 14:09.560
最终我们要实现这种方式

14:09.560 --> 14:10.560
那怎么办

14:10.560 --> 14:11.560
是不是很简单的

14:11.560 --> 14:12.560
现在

14:12.560 --> 14:13.560
你无非就是

14:13.560 --> 14:14.560
你该返回个东西呗

14:14.560 --> 14:15.560
你该返回啥

14:15.560 --> 14:16.560
返回个对象嘛

14:16.560 --> 14:17.560
这对象里面

14:17.560 --> 14:19.560
有个没事的方法

14:19.560 --> 14:20.560
就这么简单

14:20.560 --> 14:22.560
就这么简单

14:22.560 --> 14:23.560
在对象里面

14:23.560 --> 14:24.560
有个没事的方法

14:24.560 --> 14:25.560
这个方法里面

14:25.560 --> 14:26.560
干嘛呢

14:26.560 --> 14:28.560
就输出

14:28.560 --> 14:30.560
一个什么

14:30.560 --> 14:33.560
Test Component Code

14:33.560 --> 14:34.560
对吧

14:34.560 --> 14:36.560
就完了

14:36.560 --> 14:37.560
保存

14:37.560 --> 14:38.560
你看一下

14:38.560 --> 14:39.560
对吧

14:39.560 --> 14:40.560
就调用这个方法

14:40.560 --> 14:41.560
没了

14:41.560 --> 14:42.560
没了

14:42.560 --> 14:43.560
这就是这个

14:43.560 --> 14:46.560
Imperative Handle Hook

14:46.560 --> 14:47.560
就这个东西

14:47.560 --> 14:48.560
好了

14:48.560 --> 14:49.560
就是关于这个点

14:49.560 --> 14:50.560
这个有个警告

14:50.560 --> 14:53.560
它用了Ustate

14:53.560 --> 14:54.560
好

14:54.560 --> 14:55.560
这是关于这个Ref

14:55.560 --> 14:56.560
这个Hook

14:56.560 --> 14:57.560
这个Hook用的很少

14:57.560 --> 14:58.560
了解一下就行了

