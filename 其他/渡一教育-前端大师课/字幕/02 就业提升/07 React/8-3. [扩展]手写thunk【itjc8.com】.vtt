WEBVTT

00:00.560 --> 00:04.660
咱们这一刻来实现这个桑克的原码

00:04.660 --> 00:06.160
就熟写一个桑克

00:06.160 --> 00:08.160
桑克他就没有几句代码

00:08.160 --> 00:09.360
这个代码特别特别简单

00:09.360 --> 00:12.160
就是我上一期可能都已经画到嘴边了

00:12.160 --> 00:14.860
大家可能都知道他怎么回事了

00:14.860 --> 00:16.760
桑克我们刚才画一个图

00:16.760 --> 00:19.360
不就是说他就是这么一个中间线

00:19.360 --> 00:20.560
他什么东西呢

00:20.560 --> 00:23.360
如果说你给他的X是一个函数

00:23.360 --> 00:25.160
他就直接调用这个函数 没了

00:25.160 --> 00:27.660
如果你给的X不是一个函数

00:27.660 --> 00:29.160
就往后移交 没了

00:29.260 --> 00:30.860
完了 就这么简单

00:30.860 --> 00:32.560
特别特别简单

00:32.560 --> 00:35.760
桑克这个中间线特别特别简单

00:35.760 --> 00:37.460
比较说咱们在这里建个文件

00:37.460 --> 00:40.760
咱写这么一个桑克叫做Redux

00:40.760 --> 00:42.660
等一下

00:42.660 --> 00:45.060
在讲桑克之前我这里说一下

00:45.060 --> 00:47.460
我们之前写了个Redux原码的时候

00:47.460 --> 00:49.160
有一节课叫做扩展课程

00:49.160 --> 00:51.660
就是Apply Medalware

00:51.660 --> 00:53.060
这个扩展课程

00:53.060 --> 00:54.660
有一代码我写错了

00:54.660 --> 00:56.360
当时我没注意

00:56.360 --> 00:59.560
我是上节课的时候

00:59.560 --> 01:01.060
我写个东西的时候发现了

01:01.060 --> 01:02.160
发现这个问题

01:02.160 --> 01:04.560
我再给他说一下

01:04.560 --> 01:05.960
有一些代码我写错了

01:05.960 --> 01:07.460
就是怎么回事呢

01:07.460 --> 01:08.560
你看一下

01:08.560 --> 01:12.260
如果说我们在这里用他原生的Redux的话

01:12.260 --> 01:13.560
你看是没有问题的

01:13.560 --> 01:14.060
是没有问题的

01:14.060 --> 01:15.760
就是咱们上一课的代码

01:15.760 --> 01:18.660
我是在上一课的代码上建了分支

01:18.660 --> 01:21.360
但是如果说

01:21.360 --> 01:23.360
我这里用的不是原生的Redux

01:23.360 --> 01:24.760
是我们自己写的Redux

01:24.760 --> 01:26.860
你会发现LOG

01:26.860 --> 01:28.160
它触发不了

01:28.160 --> 01:29.560
触发不了

01:29.560 --> 01:31.160
你看一下没有触发

01:31.160 --> 01:32.360
这个的问题在哪呢

01:32.360 --> 01:33.560
是在这

01:33.560 --> 01:35.460
我当时写Apply Medalware的时候

01:35.460 --> 01:36.460
写得太急了

01:36.460 --> 01:37.760
没有仔细注意

01:37.760 --> 01:38.760
就在这

01:38.760 --> 01:40.560
就这个时候我们看着图说

01:40.560 --> 01:41.260
看着图说

01:41.260 --> 01:43.560
因为如果说你没有听过了扩展课程的话

01:43.560 --> 01:44.560
你是直接快进

01:44.560 --> 01:46.360
把这段跳过就行了

01:46.360 --> 01:47.460
看这个图说

01:47.460 --> 01:51.460
就说当时我们写Apply Medalware的时候

01:51.460 --> 01:53.060
我们写了一个Simple Store

01:53.060 --> 01:54.360
Simple Store给它传的进去

01:54.360 --> 01:54.960
对不对

01:54.960 --> 01:55.860
当然官方的名字

01:55.860 --> 01:56.760
它不是叫这个名字

01:56.760 --> 01:58.160
它叫Medalware API

01:58.160 --> 01:59.360
无所谓

01:59.360 --> 02:00.760
那么一个名字无所谓

02:00.760 --> 02:02.260
我们把这个对象给它传进去了

02:02.260 --> 02:02.860
对吧

02:02.860 --> 02:03.960
那么传进去作为什么

02:03.960 --> 02:04.960
作为Store

02:04.960 --> 02:06.560
作为一个中间键的

02:06.560 --> 02:08.360
中间键不是第一个参数

02:08.360 --> 02:09.460
是Store吗

02:09.460 --> 02:09.860
对吧

02:09.860 --> 02:11.960
作为Store那个参数

02:11.960 --> 02:13.760
但是这里会有一个问题

02:13.760 --> 02:15.260
由于我这个对象里边

02:15.260 --> 02:16.660
这个Dispatch

02:16.660 --> 02:17.660
这个Dispatch

02:17.660 --> 02:20.160
这个属性指向的是原始的

02:20.160 --> 02:22.660
最原始那个仓库的Dispatch

02:23.060 --> 02:24.260
也就是说我这个Dispatch

02:24.260 --> 02:25.160
指向的是谁

02:25.160 --> 02:26.060
指向的是这个

02:26.060 --> 02:28.660
最原始那个Store里边的Dispatch

02:28.660 --> 02:29.860
指向的是这个

02:29.860 --> 02:31.760
这个属性有没有发生变化了

02:31.760 --> 02:33.360
它是没有发生变化的

02:33.360 --> 02:34.860
实际上我们当时讲原代码的时候

02:34.860 --> 02:35.760
是不是这样说的

02:35.760 --> 02:37.460
这里会产生一个新的Dispatch

02:37.460 --> 02:37.960
对吧

02:37.960 --> 02:40.360
最终会返回一个新的对象

02:40.360 --> 02:41.660
Dispatch

02:41.660 --> 02:43.460
它得到的是一个新的Dispatch

02:45.360 --> 02:46.460
最终它会返回

02:46.460 --> 02:48.560
它会把这个东西混合到这个对象里边

02:48.560 --> 02:50.060
形成一个新的对象返回

02:50.060 --> 02:51.460
也就是说原来的窗户里边

02:51.460 --> 02:52.960
Dispatch是没有变化的

02:52.960 --> 02:54.560
因此你这里传令到Dispatch

02:54.560 --> 02:56.360
是最原始的Dispatch

02:56.360 --> 02:58.260
是最维原始的Dispatch

02:58.260 --> 03:00.260
那么就会导致问题

03:00.260 --> 03:01.260
那么什么问题呢

03:01.260 --> 03:04.360
就是说我们到时候传递给那个

03:04.360 --> 03:05.260
传递给谁

03:05.260 --> 03:06.360
传递这个桑格

03:06.360 --> 03:08.360
它传递给那个就是

03:08.360 --> 03:10.460
那个X型函数的时候

03:10.460 --> 03:12.760
就是传递给这个

03:12.760 --> 03:14.060
X型

03:14.060 --> 03:16.060
传递给这个负重函数的Dispatch

03:16.060 --> 03:18.860
是最原始最原始的Dispatch

03:18.860 --> 03:20.860
而不是最终混合之后

03:20.860 --> 03:22.560
更新的一个Dispatch

03:22.560 --> 03:24.160
所以说这样子写是不行的

03:24.160 --> 03:25.860
是不行的

03:25.860 --> 03:29.080
跑哪去了

03:29.080 --> 03:30.880
在这里

03:30.880 --> 03:32.180
这样写不行的

03:32.180 --> 03:33.980
那么最新的Dispatch是什么

03:33.980 --> 03:34.780
是不是这个

03:34.780 --> 03:36.780
但是你又不能这样子写

03:36.780 --> 03:38.380
你不能这样子写

03:41.080 --> 03:42.380
你为什么不能这样子写呢

03:42.380 --> 03:43.380
因为这样子写的话

03:43.380 --> 03:44.380
它指向的是谁

03:44.380 --> 03:45.780
指向的是这个地址

03:45.780 --> 03:46.080
对吧

03:46.080 --> 03:47.080
这个函数地址

03:47.080 --> 03:48.280
它指向的是这个

03:48.280 --> 03:50.080
到时候更新这个变量的时候

03:50.080 --> 03:51.680
它这个属性没有变

03:51.780 --> 03:53.480
属性还是指向的是原来这个

03:53.480 --> 03:53.880
对吧

03:53.880 --> 03:54.480
原来这个

03:54.480 --> 03:55.180
你不能这样子写

03:55.180 --> 03:55.680
这样子写的话

03:55.680 --> 03:56.780
始终会爆错

03:56.780 --> 03:57.880
它始终会告诉你

03:57.880 --> 03:59.480
目前还不能使用Dispatch

03:59.480 --> 03:59.980
对吧

03:59.980 --> 04:01.180
始终会爆错

04:01.180 --> 04:02.380
所以说到这里怎么写呢

04:02.380 --> 04:05.820
我们这里这样子写

04:05.820 --> 04:06.920
这样子写

04:08.120 --> 04:09.720
Dispatch

04:09.720 --> 04:11.420
Dispatch

04:11.420 --> 04:13.120
那个就是

04:13.120 --> 04:14.520
这样子写

04:14.520 --> 04:15.120
这样子写

04:15.120 --> 04:16.920
少一点

04:16.920 --> 04:18.120
这样子写什么意思呢

04:18.120 --> 04:19.620
就是它给它指向一个函数

04:19.620 --> 04:20.620
它是一个函数

04:20.620 --> 04:21.920
当你调用Dispatch的时候

04:21.920 --> 04:23.220
你传一些参数进来

04:23.220 --> 04:24.520
那么这个参数调用谁呢

04:24.520 --> 04:25.520
调用这个

04:25.520 --> 04:26.620
调用这个Dispatch

04:26.620 --> 04:27.820
那么这样子它一变

04:27.820 --> 04:28.820
是不是它也跟着变了

04:28.820 --> 04:29.120
对吧

04:29.120 --> 04:30.420
因为这个东西就是它

04:30.420 --> 04:31.120
对不对

04:31.120 --> 04:31.820
就是它

04:31.820 --> 04:34.120
那么保持引用地址一致

04:34.120 --> 04:35.720
那么它始终是一个函数

04:35.720 --> 04:36.920
当运行这个函数的时候

04:36.920 --> 04:38.920
调用这个Dispatch

04:38.920 --> 04:40.020
把换成这样子

04:40.020 --> 04:41.920
换成这样子的话就一切正常了

04:41.920 --> 04:43.220
就一切正常了

04:43.220 --> 04:44.220
这里我说一下

04:44.220 --> 04:45.520
说一下

04:45.520 --> 04:45.620
好

04:45.620 --> 04:46.920
那么

04:46.920 --> 04:48.620
这里一块说完了

04:48.620 --> 04:49.620
可能我们讲到现在

04:49.620 --> 04:51.520
很容易开始非常非常晕了

04:51.520 --> 04:52.020
对吧

04:52.020 --> 04:54.320
讲那个特别是桑克这一块

04:54.320 --> 04:56.120
因为埃克形里边本来是很简单的

04:56.120 --> 04:58.820
埃克形就反回一个就是普通的平面对象

04:58.820 --> 05:00.520
但是你这样加了桑克过后了

05:00.520 --> 05:01.620
会反回一个函数

05:01.620 --> 05:02.920
感觉有些东西开始晕了

05:02.920 --> 05:04.020
其实没有什么好

05:04.020 --> 05:05.320
没有那么复杂

05:05.320 --> 05:07.220
就是桑克的中间延期的作用

05:07.220 --> 05:08.620
埃克形它可以是一个函数

05:08.620 --> 05:10.420
如果是函数调用就完事了

05:10.420 --> 05:11.420
咱们来写这么

05:11.420 --> 05:13.820
我们下节课会做一个完整的例子

05:13.820 --> 05:15.120
完整的数据例子

05:15.120 --> 05:18.220
对学生的管理的一个数据的例子

05:18.220 --> 05:19.020
所以通过那个例子

05:19.020 --> 05:21.920
大家可以理解更多的东西

05:22.020 --> 05:23.120
因为我们后边

05:23.120 --> 05:25.220
桑克可能用的没有那么多

05:25.220 --> 05:27.320
可能大部分用的时候是用了桑克

05:27.320 --> 05:28.320
所以说

05:28.320 --> 05:31.120
怕你们以后到了公司里面

05:31.120 --> 05:32.220
可能会用到桑克

05:32.220 --> 05:34.920
因此我这里还是要做个完整的例子

05:34.920 --> 05:37.220
那么这里我们回到Redux里面来

05:37.220 --> 05:39.220
回到Redux里面来

05:39.220 --> 05:41.920
我们这里建立一个新建议文件夹

05:41.920 --> 05:43.920
叫做Redux桑克

05:47.320 --> 05:48.920
咱们来写这么一个index点

05:48.920 --> 05:49.920
JS

05:49.920 --> 05:50.920
几句大辆就写完了

05:50.920 --> 05:52.920
也会发现特别简单

05:52.920 --> 05:55.420
那么这里它实际上就提供了这么一个函数

05:55.420 --> 05:58.920
叫做CreaseSunkMiddleware

06:01.420 --> 06:02.620
提供了这么一个函数

06:02.620 --> 06:03.720
这个函数干嘛呢

06:03.720 --> 06:05.420
它返回一个中间键

06:05.420 --> 06:10.420
该函数返回一个Sunk中间键

06:10.420 --> 06:11.320
中间键怎么写

06:11.320 --> 06:12.420
大家还知道吗

06:12.420 --> 06:13.220
还记得吗

06:13.220 --> 06:14.920
Storm

06:14.920 --> 06:17.420
然后Next

06:18.420 --> 06:19.420
Action

06:19.420 --> 06:19.920
对不对

06:19.920 --> 06:21.420
这是中间键的写法

06:21.420 --> 06:23.420
中间键的写法就这样子

06:23.420 --> 06:25.420
那么中间键里边怎么写呢

06:25.420 --> 06:26.420
就这么简单

06:26.420 --> 06:27.920
就像我刚才说的

06:27.920 --> 06:29.920
如果说Action是一个函数

06:29.920 --> 06:30.420
判断一下吧

06:30.420 --> 06:31.420
Type

06:31.420 --> 06:32.420
Action

06:32.420 --> 06:34.920
如果说是一个函数方形

06:34.920 --> 06:35.920
那么怎么办呢

06:35.920 --> 06:37.420
就雕用这个函数

06:37.420 --> 06:38.420
就完了

06:38.420 --> 06:39.420
雕用这个函数

06:39.420 --> 06:40.420
传三个参数进去

06:40.420 --> 06:42.420
第一个参数来自于哪呢

06:42.420 --> 06:44.420
第一个参数来自于这

06:44.420 --> 06:46.420
第一个参数就是

06:46.920 --> 06:47.420
Dispatch

06:47.420 --> 06:50.420
Dispatch来自于Stone.Dispatch

06:50.420 --> 06:51.420
传过去

06:51.420 --> 06:52.420
第二个参数是什么呢

06:52.420 --> 06:53.420
getState

06:53.420 --> 06:55.420
就是Stone.getState

06:55.420 --> 06:56.420
传过去

06:56.420 --> 06:58.420
第三个参数是一个额外的参数

06:58.420 --> 06:59.420
是一个额外的参数

06:59.420 --> 07:00.420
额外的参数

07:00.420 --> 07:02.420
我们可以通过函数的参数来复制

07:02.420 --> 07:05.420
函数的参数就是extra

07:05.420 --> 07:07.420
一个额外的参数

07:07.420 --> 07:08.420
没了

07:08.420 --> 07:09.420
没了

07:09.420 --> 07:10.420
就这么简单

07:10.420 --> 07:11.420
如果是函数

07:11.420 --> 07:12.420
就雕用这个函数

07:12.420 --> 07:13.420
其他啥都不管

07:13.420 --> 07:15.420
如果不是函数的话

07:15.420 --> 07:16.420
else

07:16.420 --> 07:17.420
如果不是函数的话

07:17.420 --> 07:18.420
雕用 next

07:18.420 --> 07:20.420
直接把extra传给下一个

07:20.420 --> 07:21.420
没了

07:22.420 --> 07:23.420
就写完了

07:23.420 --> 07:24.420
就写完了

07:24.420 --> 07:25.420
就这么简单

07:25.420 --> 07:26.420
特别简单

07:26.420 --> 07:27.420
就是你

07:27.420 --> 07:28.420
他如果发现你Dispatch的

07:28.420 --> 07:29.420
extra是一个函数

07:29.420 --> 07:32.420
那么我就直接雕用这个函数

07:32.420 --> 07:33.420
我其他啥都不做

07:33.420 --> 07:34.420
也不往后移交

07:34.420 --> 07:35.420
如果他不是个函数

07:35.420 --> 07:36.420
是一个正常的extra

07:36.420 --> 07:37.420
是一个平面对象

07:37.420 --> 07:38.420
OK往后移交

07:38.420 --> 07:39.420
就没了

07:39.420 --> 07:40.420
那么这样子

07:40.420 --> 07:41.420
你可以想一想

07:41.420 --> 07:42.420
你extra是不是

07:42.420 --> 07:43.420
就可以是个函数

07:43.420 --> 07:44.420
因为他会雕用这个函数

07:44.420 --> 07:45.420
当你去Dispatch

07:45.420 --> 07:46.420
一个函数的extra的时候

07:46.420 --> 07:47.420
实际上本质上

07:47.420 --> 07:49.420
就是在雕用这个函数

07:49.420 --> 07:50.420
没了

07:50.420 --> 07:51.420
就是在雕用那个函数

07:51.420 --> 07:52.420
其他都没啥了

07:53.420 --> 07:55.420
他会把这些相关的东西

07:55.420 --> 07:56.420
传过去

07:56.420 --> 07:57.420
传过去

07:57.420 --> 07:58.420
他其实这里

07:58.420 --> 07:59.420
还有一个

07:59.420 --> 08:00.420
他还写了一句话

08:00.420 --> 08:01.420
就是写了一个return

08:01.420 --> 08:02.420
写了一个return

08:02.420 --> 08:03.420
是什么意思呢

08:03.420 --> 08:04.420
那么到时候

08:04.420 --> 08:05.420
你这个Dispatch

08:05.420 --> 08:06.420
他就会返回

08:06.420 --> 08:07.420
跟那个extra

08:07.420 --> 08:08.420
函数一样的值

08:08.420 --> 08:09.420
就是extra

08:09.420 --> 08:10.420
函数返回什么

08:10.420 --> 08:11.420
比方当时

08:11.420 --> 08:12.420
我们写的extra

08:12.420 --> 08:13.420
写的extra

08:13.420 --> 08:14.420
你看这个是不是个函数

08:14.420 --> 08:15.420
那么比方到这个函数

08:15.420 --> 08:16.420
他有一个返回值

08:16.420 --> 08:17.420
他这里返回什么

08:17.420 --> 08:18.420
返回个promise

08:18.420 --> 08:19.420
那么这个异步函数

08:19.420 --> 08:21.420
返回的一定是promise

08:21.420 --> 08:22.420
那么他返回什么

08:22.420 --> 08:23.420
那么我这个Dispatch

08:23.420 --> 08:24.420
函数就返回什么

08:24.420 --> 08:26.420
他就保持返回值一致

08:26.420 --> 08:27.420
那么这里也写个return

08:28.420 --> 08:29.420
那么就可以去掉else

08:29.420 --> 08:30.420
他原色的

08:30.420 --> 08:31.420
就这样子写的

08:31.420 --> 08:32.420
特别特别简单

08:32.420 --> 08:33.420
但是这个东西

08:33.420 --> 08:34.420
不符合我们当时

08:34.420 --> 08:35.420
用的方式

08:35.420 --> 08:36.420
当时我们怎么用的

08:36.420 --> 08:37.420
导入这个sunk

08:37.420 --> 08:38.420
他就直接用了

08:38.420 --> 08:39.420
把当成冬天键直接用了

08:39.420 --> 08:40.420
所以说他是这样子

08:40.420 --> 08:42.420
他这里写了一个变量

08:43.420 --> 08:44.420
那么掉入这个函数

08:46.420 --> 08:47.420
参数没有

08:47.420 --> 08:48.420
没有参数

08:48.420 --> 08:49.420
参数就是undefine

08:49.420 --> 08:50.420
对不对

08:50.420 --> 08:53.420
然后直接export defaultsunk

08:53.420 --> 08:54.420
对吧

08:54.420 --> 08:55.420
他就是这样子写的

08:55.420 --> 08:56.420
没了

08:56.420 --> 08:57.420
没了

08:57.420 --> 08:58.420
好

08:58.420 --> 08:59.420
你看他不就得到一个

08:59.420 --> 09:00.420
掉入那个函数

09:00.420 --> 09:01.420
不就得到一个中间键吗

09:01.420 --> 09:02.420
他把这个中间键返回

09:03.420 --> 09:04.420
那么现在我们来用一下

09:04.420 --> 09:05.420
用一下我们自己写的

09:05.420 --> 09:06.420
Redux Sunk

09:08.420 --> 09:09.420
Redux Sunk

09:09.420 --> 09:10.420
来看一下

09:10.420 --> 09:11.420
保存

09:12.420 --> 09:13.420
你看一下是不是一样的效果

09:13.420 --> 09:14.420
对吧

09:14.420 --> 09:15.420
一样的效果

09:15.420 --> 09:16.420
仍然可以执行这个函数

09:16.420 --> 09:17.420
可不可以

09:17.420 --> 09:18.420
仍然可以执行

09:18.420 --> 09:19.420
我们之前返回的函数

09:19.420 --> 09:20.420
是完全一样的效果

09:20.420 --> 09:21.420
对吧

09:21.420 --> 09:23.420
就这么简单

09:23.420 --> 09:24.420
就这么简单

09:24.420 --> 09:25.420
特色里边

09:25.420 --> 09:26.420
你看这个dispatch

09:26.420 --> 09:27.420
那么这个dispatch

09:27.420 --> 09:28.420
还可以收到返回结果

09:28.420 --> 09:29.420
对吧

09:29.420 --> 09:30.420
返回结果

09:30.420 --> 09:31.420
Redux

09:31.420 --> 09:33.420
你看一下这个返回结果

09:33.420 --> 09:34.420
返回结果

09:34.420 --> 09:35.420
是不是个promise

09:35.420 --> 09:36.420
对吧

09:36.420 --> 09:37.420
promise

09:37.420 --> 09:38.420
返回一个promise

09:38.420 --> 09:39.420
那么也就是说

09:39.420 --> 09:40.420
我们在dispatch的时候

09:40.420 --> 09:41.420
由于这个sunk的存在

09:41.420 --> 09:42.420
它的dispatch

09:42.420 --> 09:43.420
它有返回了

09:43.420 --> 09:44.420
它有返回了

09:44.420 --> 09:45.420
你看这里

09:45.420 --> 09:46.420
是不是有返回了

09:46.420 --> 09:47.420
调用x的返回结果

09:47.420 --> 09:48.420
就返回

09:48.420 --> 09:49.420
对不对

09:49.420 --> 09:50.420
所以说

09:50.420 --> 09:51.420
你这一句话

09:51.420 --> 09:52.420
就相当于在运行什么

09:52.420 --> 09:54.420
就在运行这个函数

09:54.420 --> 09:55.420
就在运行你这里返回的函数

09:55.420 --> 09:57.420
就在运行这个函数

09:57.420 --> 09:58.420
就相当于在运行函数了

09:58.420 --> 09:59.420
那么这个函数返回什么

09:59.420 --> 10:01.420
这个dispatch又返回什么

10:01.420 --> 10:02.420
因为有sunk的存在

10:02.420 --> 10:03.420
这是因为sunk的作用

10:03.420 --> 10:04.420
那么这里还可以写

10:04.420 --> 10:05.420
认

10:05.420 --> 10:06.420
把它返回一个promise

10:06.420 --> 10:07.420
对吧

10:07.420 --> 10:08.420
认

10:08.420 --> 10:09.420
那么比如说

10:09.420 --> 10:10.420
出出一个

10:10.420 --> 10:11.420
夹载完成

10:12.420 --> 10:13.420
比方说

10:13.420 --> 10:14.420
夹载完成过后

10:14.420 --> 10:15.420
你可能要做一些事情

10:15.420 --> 10:16.420
你可以在后边写

10:16.420 --> 10:17.420
看没

10:17.420 --> 10:18.420
对吧

10:18.420 --> 10:19.420
特别简单

10:19.420 --> 10:20.420
好

10:20.420 --> 10:21.420
那么这个额外参数怎么办

10:21.420 --> 10:22.420
你这里又没有传参数

10:22.420 --> 10:24.420
那怎么来处理额外参数呢

10:24.420 --> 10:25.420
它是这样子处理的

10:25.420 --> 10:26.420
我直接说一下

10:26.420 --> 10:27.420
这个东西

10:27.420 --> 10:29.420
我们平时不怎么用

10:29.420 --> 10:30.420
了解一下就行了

10:30.420 --> 10:31.420
就是它里边有一个

10:31.420 --> 10:33.420
sunk里边有一个方法

10:33.420 --> 10:35.420
叫做we

10:35.420 --> 10:36.420
叫啥呢

10:36.420 --> 10:37.420
叫啥呢

10:37.420 --> 10:39.790
那个方法

10:39.790 --> 10:40.790
那个方法我忘了

10:40.790 --> 10:42.790
忘了叫什么名字了

10:42.790 --> 10:43.790
一长串的方法

10:43.790 --> 10:44.790
咱们来看一下

10:44.790 --> 10:45.790
看一下它的npm

10:45.790 --> 10:47.790
gst上面怎么解释的

10:47.790 --> 10:48.790
名字很长串

10:48.790 --> 10:49.790
方法的作用就是

10:49.790 --> 10:51.790
传递一个额外参数

10:52.790 --> 10:56.620
一个sunk

10:56.620 --> 10:57.620
看一下吧

10:58.620 --> 10:59.620
好像叫做

11:00.620 --> 11:02.620
we is

11:02.620 --> 11:03.620
我们看一下

11:03.620 --> 11:04.620
它的官方的

11:04.620 --> 11:05.620
在这里

11:06.620 --> 11:07.620
sunk

11:07.620 --> 11:08.620
we is

11:08.620 --> 11:10.620
extra argument

11:10.620 --> 11:12.620
就是附加一个额外参数

11:12.620 --> 11:13.620
那么它怎么写的呢

11:13.620 --> 11:14.620
它是这样子写的

11:14.620 --> 11:15.620
它给这个

11:15.620 --> 11:16.620
返回了这个中间键里边

11:16.620 --> 11:17.620
加了一个属性

11:17.620 --> 11:18.620
叫做we is

11:18.620 --> 11:19.620
extra argument

11:19.620 --> 11:20.620
这个属性等于什么呢

11:20.620 --> 11:21.620
就等于这个

11:21.620 --> 11:22.620
就等于这个函数

11:22.620 --> 11:24.620
就等于这个函数

11:24.620 --> 11:25.620
所以说你调用这个方法

11:25.620 --> 11:26.620
是不是在调用这个函数

11:26.620 --> 11:28.620
重新创建一个中间键

11:28.620 --> 11:29.620
对吧

11:29.620 --> 11:30.620
当时我们是怎么举例子的

11:30.620 --> 11:31.620
我们说在这

11:31.620 --> 11:32.620
调用这个方法

11:32.620 --> 11:33.620
传递一个

11:33.620 --> 11:34.620
一个属

11:34.620 --> 11:35.620
参数进去

11:35.620 --> 11:36.620
那么返回那个中间键

11:36.620 --> 11:37.620
那么这里也是一样

11:37.620 --> 11:38.620
也是一样

11:38.620 --> 11:40.620
使用我们自己的野箱

11:40.620 --> 11:41.620
野箱

11:41.620 --> 11:42.620
野箱

11:42.620 --> 11:46.310
这是什么

11:46.310 --> 11:47.310
这里说啥

11:47.310 --> 11:48.310
它说什么

11:48.310 --> 11:49.310
create a sunk

11:49.310 --> 11:51.310
made aware is not a function

11:51.310 --> 11:52.310
这里写错了

11:52.310 --> 11:53.310
这里应该是

11:53.310 --> 11:54.310
we is

11:54.310 --> 11:56.310
extra argument

11:57.310 --> 11:58.310
那么效果是一样的

11:58.310 --> 12:00.310
效果是一样的

12:00.310 --> 12:02.310
就可以加下一个额外参数了

12:02.310 --> 12:03.310
没了

12:03.310 --> 12:04.310
就这么简单

12:04.310 --> 12:05.310
特别简单

12:05.310 --> 12:07.310
sunk就几个代码就写完了

12:07.310 --> 12:08.310
看一下吧

12:08.310 --> 12:09.310
再看一下

12:09.310 --> 12:11.310
一共十多行代码就写完了

12:11.310 --> 12:12.310
这就是sunk

12:12.310 --> 12:14.310
只要是函数就调用

12:14.310 --> 12:15.310
不是函数

12:15.310 --> 12:16.310
我用到后面传递

12:16.310 --> 12:17.310
后面全人

12:17.310 --> 12:18.310
里面去分法

12:18.310 --> 12:19.310
我不管了

12:19.310 --> 12:20.310
因为我就是在处理副作用函数的

12:20.310 --> 12:21.310
你不是函数

12:21.310 --> 12:22.310
我管不了

12:22.310 --> 12:23.310
里面去自己去处理

12:23.310 --> 12:25.310
然后加那个return

12:25.310 --> 12:26.310
它可以把这个

12:26.310 --> 12:27.310
它调用那个

12:27.310 --> 12:28.310
下一个dspark

12:28.310 --> 12:30.310
和调用这个x的返回结果返回

12:31.310 --> 12:32.310
然后呢

12:32.310 --> 12:33.310
创建这么一个中间键

12:33.310 --> 12:34.310
返回就完事了

12:34.310 --> 12:36.310
这就是sunk的元代码

12:36.310 --> 12:37.310
几句代码就写完了

12:37.310 --> 12:38.310
那么下一个

12:38.310 --> 12:40.310
咱们来做这么一个完整的例子

12:40.310 --> 12:42.310
就比方说学生的查询

12:42.310 --> 12:43.310
学生的查询

12:43.310 --> 12:45.310
他的数据该怎么去管理

12:45.310 --> 12:46.310
咱们来做一个完整的例子

12:46.310 --> 12:47.310
给大家打开一个思路

12:47.310 --> 12:48.310
好

12:48.310 --> 12:49.310
咱们下一个

12:49.310 --> 12:50.310
下一个再说吧

