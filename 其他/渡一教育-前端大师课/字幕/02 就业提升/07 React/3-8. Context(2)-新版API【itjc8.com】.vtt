WEBVTT

00:00.690 --> 00:07.690
好了 上节课咱们学习了如何去在旧的APN里边去控制这个上下文

00:07.690 --> 00:12.690
这节课咱们学习在新的APN里边怎么去操作上下文

00:12.690 --> 00:17.690
旧的APN里边我们这里先补充一个知识 在讲新的之前先补充一个知识

00:17.690 --> 00:21.690
因为上节课好像没想到 就是说这么一种情况

00:21.690 --> 00:23.690
它还可能会存在这么一种情况

00:23.690 --> 00:26.690
就是说我们上节课创建的上下文是谁创建的呢

00:26.690 --> 00:29.690
他创建的 对吧 他创建了这么一个上下文

00:29.690 --> 00:32.690
然后他有可能会出现这么一种情况

00:32.690 --> 00:35.690
就是这个childN他又创建了一个

00:35.690 --> 00:37.690
有没有可能呢 当然有可能

00:37.690 --> 00:39.690
childN他又创建了一个上下文

00:39.690 --> 00:44.690
比较重要 比较换个颜色 换成一个声色

00:44.690 --> 00:48.690
换成个声色 至于底层

00:48.690 --> 00:50.690
然后再上移动一层

00:50.690 --> 00:53.690
上移一层 OK

00:53.690 --> 00:57.690
那咱们这个childN他又创建了一个这么一个上下文

00:57.690 --> 01:00.690
他又创建了一个

01:00.690 --> 01:03.690
然后呢 这里边他也提供了一些数据

01:03.690 --> 01:05.690
而且还有相同的数据

01:05.690 --> 01:08.690
比较说A和就一个A嘛

01:08.690 --> 01:11.690
然后呢 有一个A有一个C

01:11.690 --> 01:14.690
有一个A有一个C C是知不错

01:14.690 --> 01:15.690
听过这么一个数据

01:15.690 --> 01:18.690
那有人说那如果数据都有A

01:18.690 --> 01:20.690
但是A的内形不一样了 不行

01:20.690 --> 01:22.690
内形必须要一样

01:22.690 --> 01:23.690
内形必须要一样 不一样

01:23.690 --> 01:25.690
好 抱错了 内形必须要一样

01:25.690 --> 01:26.690
好 那么现在呢

01:26.690 --> 01:28.690
我们主要是观察一下这个

01:28.690 --> 01:30.690
这样子的一种情况下

01:30.690 --> 01:32.690
那么在对于childB而言

01:32.690 --> 01:35.690
和对于childA而言

01:35.690 --> 01:38.690
他们获得了上下文分别是什么

01:38.690 --> 01:39.690
比方说获取A

01:39.690 --> 01:41.690
那么得到的分别是什么

01:41.690 --> 01:43.690
主要是研究一下这个东西

01:43.690 --> 01:44.690
好 那么我们就来写一下吧

01:44.690 --> 01:45.690
childA呢

01:45.690 --> 01:47.690
我们是要给他创建一个上下文

01:47.690 --> 01:48.690
我们照到这个

01:48.690 --> 01:49.690
我们之前的代码

01:49.690 --> 01:51.690
之前代码的childA是个函数逐渐

01:51.690 --> 01:52.690
那我这里呢

01:52.690 --> 01:54.690
先把之前代码复制一下

01:54.690 --> 01:57.690
把这个childA给他改成一个

01:57.690 --> 02:00.690
给他改成一个内逐渐

02:00.690 --> 02:03.690
class child child

02:03.690 --> 02:05.690
a extends

02:05.690 --> 02:06.690
我记得那个插件里面

02:06.690 --> 02:09.690
是有一个内逐渐的减写

02:09.690 --> 02:13.690
class component

02:13.690 --> 02:17.510
component

02:17.510 --> 02:18.510
叫什么呢

02:18.510 --> 02:23.510
react class component

02:23.510 --> 02:24.510
但他这个东西

02:24.510 --> 02:25.510
会把这个东西也导入进来

02:25.510 --> 02:26.510
关上了吗

02:26.510 --> 02:27.510
关上了吗

02:27.510 --> 02:28.510
这里呢

02:28.510 --> 02:31.510
我们使用那个childA

02:31.510 --> 02:33.510
这个组件里面的快捷键

02:33.510 --> 02:35.510
大家可以去看一下

02:35.510 --> 02:36.510
老汪

02:36.510 --> 02:37.510
平时不怎么用的话

02:37.510 --> 02:38.510
就老汪

02:38.510 --> 02:39.510
在这个地方

02:39.510 --> 02:41.510
就是我们安装这个插件

02:41.510 --> 02:42.510
插件里面

02:42.510 --> 02:43.510
它下面有很多的快捷键

02:43.510 --> 02:44.510
就这些快捷键

02:44.510 --> 02:46.510
你可以去看一下

02:46.510 --> 02:48.510
看一下这些快捷键什么写的

02:48.510 --> 02:49.510
再找一下吧

02:49.510 --> 02:50.510
再找一下吧

02:50.510 --> 02:51.510
反正想着来了

02:51.510 --> 02:52.510
咱们也不找

02:52.510 --> 02:53.510
不用特别着急

02:54.510 --> 02:55.510
我看一下

02:55.510 --> 02:58.510
创建一个react

02:58.510 --> 03:03.100
好像没有啊

03:03.100 --> 03:04.100
react component

03:04.100 --> 03:06.100
rcc是这个

03:06.100 --> 03:08.100
rce呢

03:08.100 --> 03:10.100
是这个

03:10.100 --> 03:14.570
然后看一下

03:14.570 --> 03:16.570
有没有直接只创建的一组件

03:16.570 --> 03:17.570
没有那个

03:17.570 --> 03:19.570
没有不导入模块的

03:19.570 --> 03:20.570
看有没有

03:21.570 --> 03:23.570
我没有的话也就算了

03:24.570 --> 03:25.570
这是个函数组件吗

03:25.570 --> 03:29.220
好像是没有

03:29.220 --> 03:30.220
好像是没有

03:30.220 --> 03:31.220
那行了吗

03:31.220 --> 03:32.220
那就这样吧

03:32.220 --> 03:34.540
怎么说的

03:34.540 --> 03:35.540
说到这儿来了

03:36.540 --> 03:37.540
qlda

03:37.540 --> 03:38.540
然后呢

03:38.540 --> 03:40.540
还是把之前的该做好

03:40.540 --> 03:41.540
这里是

03:41.540 --> 03:42.540
我们现在就把它写到什么

03:42.540 --> 03:43.540
写到render里面

03:43.540 --> 03:44.540
把它写到render里面

03:44.540 --> 03:45.540
render的时候

03:45.540 --> 03:47.540
这里就来自于z.context

03:47.540 --> 03:49.540
这里来自于z.context.b

03:49.540 --> 03:51.540
先把之前的先做好

03:51.540 --> 03:52.540
然后

03:52.540 --> 03:53.540
a里面有个静态属性

03:53.540 --> 03:54.540
contexttaps

03:55.540 --> 03:56.540
我们把它写到这儿

03:58.540 --> 03:59.540
contexttaps

03:59.540 --> 04:00.540
等于什么

04:00.540 --> 04:01.540
taps

04:02.540 --> 04:03.540
好了

04:03.540 --> 04:04.540
保存

04:04.540 --> 04:05.540
咱们来看一下

04:05.540 --> 04:06.540
目前的qlda

04:06.540 --> 04:07.540
肯定还没有创建自己的

04:07.540 --> 04:08.540
上下文

04:08.540 --> 04:09.540
没创建上下文

04:09.540 --> 04:10.540
那么它只是用

04:10.540 --> 04:11.540
之前的上下文

04:11.540 --> 04:12.540
把它变成内组件了

04:12.540 --> 04:15.230
保存看一下

04:16.230 --> 04:17.230
它包出

04:17.230 --> 04:18.230
那里包出

04:18.230 --> 04:19.230
这里

04:20.230 --> 04:21.230
不能导出

04:21.230 --> 04:22.230
没有导出

04:22.230 --> 04:23.230
保存

04:23.230 --> 04:24.230
看一下

04:24.230 --> 04:25.230
是不是一样的

04:25.230 --> 04:26.230
跟之前

04:26.230 --> 04:27.230
跟之前没什么区别

04:27.230 --> 04:28.230
是一样的

04:29.230 --> 04:30.230
那么现在呢

04:30.230 --> 04:31.230
我们要做这么一件事

04:31.230 --> 04:33.230
它也要创建自己的上下文

04:33.230 --> 04:34.230
好

04:34.230 --> 04:35.230
那么怎么做呢

04:35.230 --> 04:36.230
跟之前是不一样的

04:36.230 --> 04:37.230
一个静态的

04:37.230 --> 04:38.230
什么属性

04:38.230 --> 04:40.230
child.contexttaps

04:40.230 --> 04:41.230
对吧

04:41.230 --> 04:42.230
我的上下文里边

04:42.230 --> 04:43.230
有哪些东西呢

04:43.230 --> 04:44.230
你看着

04:44.230 --> 04:45.230
有a number

04:45.230 --> 04:46.230
c in a string

04:48.230 --> 04:49.230
a

04:49.230 --> 04:50.230
probe.taps

04:50.230 --> 04:51.230
number

04:52.230 --> 04:53.230
c in a

04:53.230 --> 04:54.230
probe.taps

04:55.230 --> 04:56.230
string

04:56.230 --> 04:57.230
有自己的上下文

04:57.230 --> 04:58.230
然后呢

04:58.230 --> 04:59.230
它还要写个方法

04:59.230 --> 05:00.230
get child.context

05:00.230 --> 05:01.230
这里返回一个什么

05:01.230 --> 05:02.230
返回

05:02.230 --> 05:03.230
说好的返回a

05:03.230 --> 05:04.230
a是个数字

05:05.230 --> 05:06.230
789

05:06.230 --> 05:07.230
然后呢

05:07.230 --> 05:08.230
c是一个字不串

05:08.230 --> 05:09.230
比方说 hello

05:10.230 --> 05:12.230
那么我们首先看一下

05:13.230 --> 05:16.230
现在我们a也创建了上下文了

05:16.230 --> 05:17.230
然后呢

05:17.230 --> 05:18.230
在a的上下文里边

05:18.230 --> 05:20.230
在这个上下文里边

05:20.230 --> 05:22.230
在这个组件里边

05:22.230 --> 05:25.230
它如果去获取上下文里边的a

05:25.230 --> 05:27.230
它获取的是啥

05:27.230 --> 05:29.230
我们先看这个child.a

05:29.230 --> 05:31.230
它获取的这个a是啥

05:31.230 --> 05:33.230
获取的结果是123

05:33.230 --> 05:34.230
说明了什么了

05:34.230 --> 05:35.230
说明了

05:35.230 --> 05:37.230
它不会往自己创建的

05:37.230 --> 05:38.230
上下文里边找东西

05:38.230 --> 05:39.230
这是我们之前

05:39.230 --> 05:40.230
也讲过类似的

05:41.230 --> 05:43.230
讲过类似的东西对吧

05:43.230 --> 05:44.230
我说这个东西

05:44.230 --> 05:45.230
它自己创建的上下文

05:45.230 --> 05:46.230
数据本来就是它的

05:46.230 --> 05:48.230
它需要从上下文里面去取

05:48.230 --> 05:49.230
数据它本来

05:49.230 --> 05:50.230
你上下文里面

05:50.230 --> 05:51.230
都得到这个数据

05:51.230 --> 05:52.230
你看这个函数里面

05:52.230 --> 05:54.230
你不是数据就是你自己的吗

05:54.230 --> 05:55.230
你自己写的这个数据

05:55.230 --> 05:57.230
那你还需要从上下文里面去取

05:57.230 --> 05:59.230
所以它取得上下文

05:59.230 --> 06:01.230
对于child.a而言

06:01.230 --> 06:03.230
它不会往自己的上下文里面去取

06:03.230 --> 06:06.230
它会从副级的上下文里面去取

06:06.230 --> 06:07.230
所以它会取到什么

06:07.230 --> 06:08.230
会取到这个a

06:08.230 --> 06:09.230
会取到这个b

06:09.230 --> 06:11.230
会取到unchanged a

06:11.230 --> 06:13.230
它自己的是取不到的

06:13.230 --> 06:14.230
比方自己的有什么

06:14.230 --> 06:16.230
这些东西都取不到

06:16.230 --> 06:18.230
比方说

06:18.230 --> 06:20.230
我们这里得到的a是什么a呢

06:20.230 --> 06:22.230
是不是来自于这里的a

06:22.230 --> 06:23.230
这是对于child.a

06:23.230 --> 06:25.230
这个组建而言

06:25.230 --> 06:26.230
对于这个组建而言

06:26.230 --> 06:27.230
因为本身数据是它的

06:27.230 --> 06:29.230
它干嘛还要从上下文里面去取

06:29.230 --> 06:31.230
它觉得这样做呢

06:31.230 --> 06:32.230
是不符合逻辑的

06:32.230 --> 06:33.230
不符合道理的

06:33.230 --> 06:34.230
当然这个画图的话

06:34.230 --> 06:35.230
你可以把它认为

06:35.230 --> 06:36.230
这个图是这样子的

06:38.230 --> 06:40.230
你可以认为是这样子的

06:41.230 --> 06:42.230
当然

06:42.230 --> 06:44.230
实际上这样子的

06:46.230 --> 06:48.230
能不能这样想呢

06:48.230 --> 06:49.230
也不行啊

06:49.230 --> 06:50.230
因为这个数据本来是它的

06:50.230 --> 06:51.230
是它的数据

06:51.230 --> 06:52.230
也不行

06:52.230 --> 06:54.230
那就用之前的方式

06:54.230 --> 06:55.230
你就这样理解就行了

06:55.230 --> 06:57.230
就是这个数据

06:57.230 --> 06:58.230
是上下文的数据

06:58.230 --> 06:59.230
上下文本来就是它创建的

06:59.230 --> 07:00.230
所以它对这个数据

07:00.230 --> 07:01.230
拥有完整的

07:01.230 --> 07:03.230
至少有访问权限

07:03.230 --> 07:04.230
对吧

07:04.230 --> 07:06.230
访问这个数据是不成问题的

07:06.230 --> 07:07.230
哪怕我去第二个函数

07:07.230 --> 07:09.230
是不是也可以访问到这个数据

07:09.230 --> 07:10.230
对吧

07:10.230 --> 07:12.230
当它去取上下文的时候

07:12.230 --> 07:13.230
当这个childa

07:13.230 --> 07:14.230
去取这个上下文的时候

07:14.230 --> 07:16.230
它不会往自己的上下文里面去取

07:16.230 --> 07:17.230
它觉得没有什么意义

07:17.230 --> 07:19.230
它会往附近的上下文去取

07:19.230 --> 07:22.230
但是对于这个childb

07:22.230 --> 07:23.230
看一下

07:23.230 --> 07:24.230
对于这个childb

07:24.230 --> 07:25.230
你看

07:25.230 --> 07:27.230
它a取出来就是789

07:27.230 --> 07:28.230
怎么回事呢

07:28.230 --> 07:30.230
对于这个childb而言

07:30.230 --> 07:32.230
那么它的上下文的数据

07:32.230 --> 07:35.230
它有点类似于介石的作用预验

07:35.230 --> 07:37.230
它会理它最近的去查找

07:37.230 --> 07:38.230
查到到a

07:38.230 --> 07:40.230
那么就ok了

07:40.230 --> 07:42.230
它不会往继续往后点查到了

07:42.230 --> 07:44.230
明白这个意思吧

07:44.230 --> 07:45.230
没问题吧

07:45.230 --> 07:47.230
这是关于这一块

07:47.230 --> 07:48.230
如果有就是那种

07:48.230 --> 07:50.230
某一个组建在多个上下文里边的时候

07:50.230 --> 07:52.230
那么它取数据的时候

07:52.230 --> 07:53.230
一定是究竟原则

07:53.230 --> 07:55.230
能找到就尽量找

07:55.230 --> 07:56.230
找不到的话

07:56.230 --> 07:58.230
再往上里面一个一个去看

07:58.230 --> 07:59.230
好

07:59.230 --> 08:01.230
那么现在我们再点这个指按钮

08:01.230 --> 08:03.230
指按钮a加2看一下

08:03.230 --> 08:07.180
指按钮的a加2

08:07.180 --> 08:08.180
是不是没反应了

08:08.180 --> 08:09.180
咱们再重新看一下

08:09.180 --> 08:11.180
发现一个很神奇的现象

08:11.180 --> 08:12.180
点这个a加2

08:12.180 --> 08:13.180
它突然变成791了

08:13.180 --> 08:14.180
这怎么回事呢

08:14.180 --> 08:16.180
因为点这个a加2

08:16.180 --> 08:17.180
它运行的是

08:17.180 --> 08:18.180
就是这个childb

08:18.180 --> 08:19.180
去运行的是啥

08:19.180 --> 08:21.180
运行的是unchain解a

08:21.180 --> 08:22.180
对吧

08:22.180 --> 08:23.180
unchain解a运行的时候

08:23.180 --> 08:25.180
它传递的数据是啥

08:25.180 --> 08:26.180
你别说

08:26.180 --> 08:28.180
这里很容易出考试题

08:28.180 --> 08:29.180
就是面试题

08:29.180 --> 08:30.180
它传的数据是啥

08:30.180 --> 08:32.180
是当前上下文里边的a加2

08:32.180 --> 08:34.180
而当前上下文的a

08:34.180 --> 08:35.180
你看一下

08:35.180 --> 08:37.180
当前上下文的a是不是789

08:37.180 --> 08:38.180
对吧

08:38.180 --> 08:39.180
是来自于这

08:39.180 --> 08:41.180
它传的时候

08:41.180 --> 08:42.180
它调用这个unchain解a

08:42.180 --> 08:43.180
传的时候是吧

08:43.180 --> 08:45.180
当前的a加2

08:45.180 --> 08:46.180
当前的a是多少

08:46.180 --> 08:47.180
是789

08:47.180 --> 08:49.180
789加2是不是791

08:49.180 --> 08:50.180
对吧

08:50.180 --> 08:51.180
那么一加上去

08:51.180 --> 08:53.180
谁作为参数传给它

08:53.180 --> 08:54.180
那么它里面

08:54.180 --> 08:55.180
改变的是谁的数据

08:55.180 --> 08:56.180
是不是改变了这个a

08:56.180 --> 08:57.180
对吧

08:57.180 --> 08:58.180
把它改成791了

08:58.180 --> 08:59.180
好

08:59.180 --> 09:00.180
改变了这个a过后

09:00.180 --> 09:01.180
这个childb的a

09:01.180 --> 09:02.180
这里会变

09:02.180 --> 09:03.180
变化

09:03.180 --> 09:04.180
你看点了过后

09:04.180 --> 09:05.180
它变成791了

09:05.180 --> 09:06.180
但它会不会变化

09:06.180 --> 09:07.180
它不会变化

09:08.180 --> 09:09.180
它不会变化

09:09.180 --> 09:10.180
因为它始终读的是这个

09:10.180 --> 09:11.180
这个a没有发生变化

09:11.180 --> 09:12.180
所以它不会变

09:12.180 --> 09:14.180
那么我们继续点的话

09:14.180 --> 09:16.180
它不会发生任何反应

09:16.180 --> 09:18.180
它会不断的运行这个函数改变

09:18.180 --> 09:19.180
改变了属性

09:19.180 --> 09:20.180
没有变化它也会触发

09:20.180 --> 09:21.180
对吧

09:21.180 --> 09:22.180
改变了这个状态

09:22.180 --> 09:23.180
但是呢

09:23.180 --> 09:24.180
只没有变

09:24.180 --> 09:25.180
为什么呢

09:25.180 --> 09:26.180
它永远都是789加2

09:26.180 --> 09:27.180
永远都是789加2

09:28.180 --> 09:29.180
原来的意思吧

09:30.180 --> 09:31.180
这是关于

09:31.180 --> 09:32.180
就是

09:33.180 --> 09:34.180
多个上下文的情况

09:34.180 --> 09:35.180
在9版API里边

09:36.180 --> 09:37.180
好了

09:37.180 --> 09:38.180
那这里我就基本上讲清楚了

09:38.180 --> 09:39.180
好了

09:39.180 --> 09:40.180
还有这个

09:40.180 --> 09:41.180
对

09:41.180 --> 09:42.180
还有这个c

09:42.180 --> 09:43.180
如果你要获取这个c的话

09:43.180 --> 09:44.180
你要在childb里边

09:44.180 --> 09:45.180
获取c的话

09:45.180 --> 09:46.180
那肯定是一样的

09:46.180 --> 09:47.180
你这里要

09:47.180 --> 09:48.180
获取c的话

09:48.180 --> 09:49.180
这样子写了

09:49.180 --> 09:50.180
context

09:50.180 --> 09:51.180
c

09:51.180 --> 09:52.180
能不能获取到了

09:52.180 --> 09:53.180
保存

09:53.180 --> 09:54.180
你看一下

09:54.180 --> 09:55.180
c是不是获取不到

09:55.180 --> 09:56.180
对吧

09:56.180 --> 09:57.180
c获取不到

09:57.180 --> 09:58.180
为什么获取不到呢

09:58.180 --> 09:59.180
然后前面加个都号

10:00.180 --> 10:01.180
看一下

10:01.180 --> 10:02.180
c获取不到

10:02.180 --> 10:03.180
为什么获取不到呢

10:03.180 --> 10:04.180
是因为这个c

10:04.180 --> 10:06.180
你没有写到这里面

10:06.180 --> 10:07.180
你没有声明说

10:07.180 --> 10:08.180
我要哪些数据内容

10:08.180 --> 10:09.180
你没有声明

10:09.180 --> 10:10.180
你只声明了什么

10:10.180 --> 10:11.180
只声明了

10:11.180 --> 10:12.180
这个里面ab

10:12.180 --> 10:13.180
onchain

10:13.180 --> 10:14.180
对吧

10:14.180 --> 10:15.180
c你没有声明

10:15.180 --> 10:16.180
所以说你获取不到

10:16.180 --> 10:17.180
那怎么来获取呢

10:17.180 --> 10:18.180
那这里这样子

10:18.180 --> 10:19.180
这样子写吧

10:19.180 --> 10:20.180
我们把这个types展开

10:20.180 --> 10:21.180
types展开

10:21.180 --> 10:22.180
然后再加一个c

10:22.180 --> 10:24.180
c来这些propertypes

10:24.180 --> 10:25.180
什么

10:25.180 --> 10:26.180
stune

10:26.180 --> 10:27.180
好

10:27.180 --> 10:28.180
那么这样子

10:28.180 --> 10:29.180
就可以获取到c了

10:29.180 --> 10:30.180
看一下吧

10:30.180 --> 10:31.180
c是不是好了

10:31.180 --> 10:32.180
对吧

10:32.180 --> 10:33.180
永远是究竟原则

10:33.180 --> 10:34.180
当然他还要

10:34.180 --> 10:35.180
看你什么

10:35.180 --> 10:36.180
看你声明

10:36.180 --> 10:37.180
要用哪些东西

10:38.180 --> 10:39.180
这是关于旧版

10:39.180 --> 10:40.180
APN里边的

10:40.180 --> 10:41.180
这些知识

10:42.180 --> 10:43.180
好了

10:43.180 --> 10:44.180
那么现在呢

10:44.180 --> 10:49.570
我们来看新版APN

10:49.570 --> 10:50.570
新

10:50.570 --> 10:51.570
版

10:51.570 --> 10:53.570
就是16版本之后的APN

10:53.570 --> 10:54.570
那么旧的版APN

10:54.570 --> 10:55.570
为什么要移除掉呢

10:55.570 --> 10:56.570
主要是效率问题

10:56.570 --> 10:59.570
旧版APN存在

10:59.570 --> 11:01.570
效率严重的

11:01.570 --> 11:02.570
效率问题

11:02.570 --> 11:04.570
所以说在新版APN里边

11:04.570 --> 11:06.570
就给它修复掉了

11:06.570 --> 11:08.570
而且旧版APN里边

11:08.570 --> 11:09.570
它的有些

11:10.570 --> 11:12.570
这种语法逻辑上

11:12.570 --> 11:13.570
也感觉不太合适

11:13.570 --> 11:15.570
在新版APN里边

11:15.570 --> 11:17.570
我们会感觉到

11:17.570 --> 11:19.570
这个上下文的

11:19.570 --> 11:21.570
这种方式

11:21.570 --> 11:23.570
更加符合

11:23.570 --> 11:24.570
程序的逻辑

11:24.570 --> 11:25.570
整个程序的架构

11:25.570 --> 11:26.570
更加纯粹的

11:26.570 --> 11:28.570
一是旧版APN存在

11:28.570 --> 11:29.570
严重的效率问题

11:29.570 --> 11:31.570
并且

11:31.570 --> 11:33.570
容易

11:33.570 --> 11:35.570
导致

11:36.570 --> 11:37.570
使用

11:37.570 --> 11:38.570
难用

11:38.570 --> 11:40.570
容易导致难用

11:40.570 --> 11:41.570
所以说

11:41.570 --> 11:42.570
在新版的APN里边

11:42.570 --> 11:44.570
它给你做了一种新的方式

11:44.570 --> 11:46.570
让你去控制上下文

11:46.570 --> 11:47.570
以后大家

11:47.570 --> 11:49.570
在用上下文的时候

11:49.570 --> 11:50.570
十字八九

11:50.570 --> 11:51.570
都是新版的APN

11:51.570 --> 11:52.570
旧版的APN

11:52.570 --> 11:53.570
现在目前还能用

11:53.570 --> 11:54.570
可能在

11:54.570 --> 11:55.570
一七百万过后

11:55.570 --> 11:56.570
可能就移除掉了

11:56.570 --> 11:57.570
可能一些人

11:57.570 --> 11:58.570
旧的公司里边

11:58.570 --> 11:59.570
它有些老的项目

11:59.570 --> 12:00.570
还在用旧版的APN

12:00.570 --> 12:01.570
它都很少了

12:01.570 --> 12:03.570
基本上都是新版的APN

12:03.570 --> 12:04.570
好,咱们来看新版的APN

12:04.570 --> 12:06.570
还是分为两个部分来讲

12:06.570 --> 12:07.570
第一个部分

12:07.570 --> 12:09.570
是创建上下文

12:11.570 --> 12:12.570
另一个部分

12:12.570 --> 12:14.570
是使用

12:14.570 --> 12:16.570
上下文中的数据

12:18.570 --> 12:19.570
好

12:19.570 --> 12:20.570
我们之前

12:20.570 --> 12:21.570
是一个

12:21.570 --> 12:23.570
组建在创建上下文对吧

12:23.570 --> 12:25.570
是一个组建在创建上下文

12:25.570 --> 12:27.570
那么在新版的APN

12:27.570 --> 12:28.570
它不是了

12:28.570 --> 12:30.570
上下文

12:30.570 --> 12:32.570
上下文是一个

12:32.570 --> 12:33.570
独立于

12:33.570 --> 12:35.570
组建的

12:35.570 --> 12:37.570
对象

12:37.570 --> 12:38.570
上下文是一个独立于

12:38.570 --> 12:39.570
组建的对象

12:39.570 --> 12:40.570
它跟组建

12:40.570 --> 12:42.570
并没有什么直接的关系

12:42.570 --> 12:43.570
比方说

12:43.570 --> 12:44.570
我们来看一下这个图

12:44.570 --> 12:45.570
我们之前

12:45.570 --> 12:46.570
创建上下文

12:46.570 --> 12:47.570
这里创建的

12:47.570 --> 12:48.570
对吧

12:48.570 --> 12:49.570
跟组建相关的

12:49.570 --> 12:51.570
但是我们在新版的APN里边

12:51.570 --> 12:53.570
上下文它是应该是这个样子的

12:54.570 --> 12:55.570
组合一下

12:55.570 --> 12:57.570
至于底部

12:57.570 --> 12:58.570
新版的APN里边

12:58.570 --> 13:00.570
上下文它就是一个

13:00.570 --> 13:02.570
上下文它就是一个单独的对象

13:02.570 --> 13:03.570
它跟组建没有什么直接的关系

13:03.570 --> 13:04.570
那么到时候

13:04.570 --> 13:05.570
我们可以在组建里面

13:05.570 --> 13:06.570
把它进行关联

13:06.570 --> 13:07.570
跟组建关联起来

13:07.570 --> 13:08.570
但是它实际上

13:08.570 --> 13:10.570
它跟组建没有直接的关系

13:10.570 --> 13:11.570
没有直接的关系

13:11.570 --> 13:12.570
它就是一个对象

13:12.570 --> 13:13.570
脱离组建的对象

13:13.570 --> 13:14.570
那么这样的上下文

13:14.570 --> 13:15.570
它更加纯粹了

13:15.570 --> 13:17.570
也满足软件设计的原则

13:17.570 --> 13:18.570
低偶和

13:18.570 --> 13:19.570
对吧

13:19.570 --> 13:21.570
降低跟其他东西之间的关联

13:21.570 --> 13:22.570
那么它就是一个

13:22.570 --> 13:23.570
纯粹的对象而已

13:23.570 --> 13:25.570
原来的意思吗

13:25.570 --> 13:26.570
好

13:26.570 --> 13:28.570
然后呢

13:28.570 --> 13:29.570
我们在新版里边

13:29.570 --> 13:30.570
去创建一个上下文试一下

13:30.570 --> 13:32.570
我们这里新建一个

13:32.570 --> 13:34.570
new context

13:34.570 --> 13:36.570
做出一个一模一样的效果

13:36.570 --> 13:37.570
情况下一个效果

13:37.570 --> 13:38.570
没有什么实际意义

13:38.570 --> 13:41.570
把这个关联

13:41.570 --> 13:43.570
这里面我们如何来

13:43.570 --> 13:45.570
创建一个上下文对象呢

13:45.570 --> 13:46.570
它是这样子

13:46.570 --> 13:48.570
你肯定要首先导入react

13:49.570 --> 13:51.570
我先写这么一个组件

13:51.570 --> 13:53.570
先把个组件写出来

13:53.570 --> 13:55.570
这里注射掉

13:55.570 --> 13:57.570
import new context

13:57.570 --> 14:02.840
from new context

14:02.840 --> 14:03.840
这里呢

14:03.840 --> 14:05.840
我们先把这个对象写出来

14:05.840 --> 14:06.840
怎么来创建个对象呢

14:06.840 --> 14:07.840
是react

14:07.840 --> 14:08.840
里边有一个函数叫做

14:08.840 --> 14:10.840
create context

14:10.840 --> 14:11.840
就这么简单

14:11.840 --> 14:12.840
就这么简单

14:12.840 --> 14:13.840
通过它

14:13.840 --> 14:15.840
去创建这么一个上下文对象

14:15.840 --> 14:16.840
它反回的就是一个

14:16.840 --> 14:19.840
上下文对象

14:19.840 --> 14:21.840
ctx

14:21.840 --> 14:24.840
反回这么一个上下文对象

14:24.840 --> 14:26.840
然后我们这里记彼

14:26.840 --> 14:29.840
通过该对象

14:29.840 --> 14:32.840
通过react

14:32.840 --> 14:35.840
第二create context

14:35.840 --> 14:38.840
创建

14:38.840 --> 14:39.840
然后这个函数

14:39.840 --> 14:40.840
我说一下

14:40.840 --> 14:41.840
这个函数

14:41.840 --> 14:42.840
它里边可以写默认值

14:42.840 --> 14:44.840
就是你不是有数据吗

14:44.840 --> 14:46.840
这里的数据

14:46.840 --> 14:48.840
这些数据的默认值是什么

14:48.840 --> 14:49.840
你可以写到这

14:49.840 --> 14:50.840
比方说

14:50.840 --> 14:51.840
咱们是一个字不错的数据

14:51.840 --> 14:52.840
咱们上下文里边就一个字不错

14:52.840 --> 14:54.840
那你就可以写个字不错的默认值

14:54.840 --> 14:55.840
一个空字不错

14:55.840 --> 14:56.840
或者是abc

14:56.840 --> 14:57.840
就这么一个意涵意

14:57.840 --> 14:58.840
然后如果你是个对象的话

14:58.840 --> 15:00.840
你可以写在里边

15:00.840 --> 15:01.840
比方说

15:01.840 --> 15:02.840
默认值为0

15:02.840 --> 15:04.840
b的值为abc

15:04.840 --> 15:05.840
比方说

15:05.840 --> 15:07.840
我们写上这么一个东西

15:07.840 --> 15:09.840
写上这么一个东西

15:09.840 --> 15:10.840
没问题吧

15:10.840 --> 15:12.840
那么这里就创建到上下文对象了

15:12.840 --> 15:14.840
就这么简单

15:14.840 --> 15:16.840
然后这个对象里边有什么东西呢

15:16.840 --> 15:18.840
我们把它打印出来看一下

15:18.840 --> 15:19.840
这个对象其实非常非常简单

15:19.840 --> 15:20.840
它里边有什么东西呢

15:20.840 --> 15:21.840
保存

15:21.840 --> 15:22.840
你看它是不是脱离组件的

15:22.840 --> 15:23.840
跟组件有啥关系

15:23.840 --> 15:24.840
现在跟组件

15:24.840 --> 15:25.840
没有啥关系的

15:25.840 --> 15:26.840
保存

15:26.840 --> 15:27.840
我们看一下

15:27.840 --> 15:29.840
它出现了一个这么一个东西

15:29.840 --> 15:30.840
因为发现了

15:30.840 --> 15:32.840
它里边有两个属性

15:32.840 --> 15:34.840
一个属性叫做consumer

15:34.840 --> 15:36.840
一个属性叫做provider

15:36.840 --> 15:38.840
这两个属性是啥玩意

15:38.840 --> 15:40.840
这两个是一个两个组件

15:40.840 --> 15:42.840
两个组件

15:42.840 --> 15:44.840
也就是我们现在新的API里边

15:44.840 --> 15:45.840
我们的上下文呢

15:45.840 --> 15:46.840
最终它是一个组件

15:46.840 --> 15:47.840
首先它是个对象

15:47.840 --> 15:49.840
对象里边一个provider属性

15:49.840 --> 15:50.840
是一个组件

15:50.840 --> 15:52.840
我们这里记录一下

15:53.840 --> 15:55.840
这里是默认值

15:55.840 --> 15:56.840
默认值

15:56.840 --> 15:57.840
就是数据的默认值

15:57.840 --> 15:58.840
这里我们就是

15:58.840 --> 16:00.840
返回的

16:00.840 --> 16:02.840
是一个包含

16:02.840 --> 16:05.840
两个属性的对象

16:05.840 --> 16:07.840
哪两个属性

16:07.840 --> 16:10.840
一个是provider

16:10.840 --> 16:12.840
provider属性

16:12.840 --> 16:15.840
一个是consumer

16:15.840 --> 16:18.840
有这么两个属性

16:18.840 --> 16:19.840
provider属性

16:19.840 --> 16:20.840
provider什么意思

16:20.840 --> 16:21.840
表示提供者

16:21.840 --> 16:23.840
表示提供者

16:23.840 --> 16:26.840
我们这里通常把它叫做生产者

16:26.840 --> 16:27.840
这个属性是什么呢

16:27.840 --> 16:29.840
本质上就是一个组件

16:29.840 --> 16:30.840
它就是一个组件

16:30.840 --> 16:32.840
这个组件用来做什么呢

16:32.840 --> 16:33.840
这个组件

16:33.840 --> 16:35.840
该组件

16:36.840 --> 16:37.840
该组件

16:37.840 --> 16:40.840
会创建一个上下文

16:40.840 --> 16:41.840
现在说

16:41.840 --> 16:43.840
我们说的上下文

16:43.840 --> 16:44.840
我们这里说的上下文

16:44.840 --> 16:46.840
就不再是

16:46.840 --> 16:48.840
不再是我们之前的

16:48.840 --> 16:50.840
我们自己写的

16:50.840 --> 16:51.840
组件创建上下文

16:51.840 --> 16:52.840
有它在创建上下文

16:52.840 --> 16:53.840
有它在创建

16:53.840 --> 16:54.840
而谁在创建上下文呢

16:54.840 --> 16:57.840
它可以提供这么一个provider组件

16:57.840 --> 16:58.840
这个组件

16:58.840 --> 17:00.840
它会来创建一个上下文

17:00.840 --> 17:01.840
是这么个意思

17:01.840 --> 17:02.840
也就是说

17:02.840 --> 17:03.840
你之后要用上下文的话

17:03.840 --> 17:05.840
要使用这个组件

17:05.840 --> 17:06.840
好

17:06.840 --> 17:07.840
那么我们来看一下

17:07.840 --> 17:09.840
怎么来使用这个组件

17:09.840 --> 17:10.840
怎么来使用这个组件

17:10.840 --> 17:11.840
到这边来

17:12.840 --> 17:13.840
我们现在

17:13.840 --> 17:14.840
我们的数据

17:14.840 --> 17:16.840
有两个moren值的

17:16.840 --> 17:19.840
现在我们要在这个组件里边

17:19.840 --> 17:21.840
把这个上下文的

17:21.840 --> 17:22.840
就是provider的这个组件

17:22.840 --> 17:23.840
要用过来

17:23.840 --> 17:24.840
怎么用呢

17:24.840 --> 17:25.840
我们可以这样子

17:25.840 --> 17:29.540
provider

17:29.540 --> 17:30.540
拿到

17:30.540 --> 17:31.540
从哪里面拿到

17:31.540 --> 17:33.540
provider

17:34.540 --> 17:36.540
这边我们就这样子写

17:36.540 --> 17:37.540
provider

17:39.540 --> 17:41.540
provider

17:41.540 --> 17:43.540
写上这么一个组件

17:43.540 --> 17:44.540
就这么简单

17:44.540 --> 17:45.540
那么这个组件

17:45.540 --> 17:46.540
它就会创建上下文

17:46.540 --> 17:48.540
那么现在的就变成

17:48.540 --> 17:49.540
一种什么样的结构了

17:49.540 --> 17:50.540
现在我们看图

17:50.540 --> 17:52.540
它就变成这么一种结构了

17:53.540 --> 17:55.540
这个上下文是谁创建的呢

17:55.540 --> 18:00.130
是有一个provider创建的

18:00.130 --> 18:03.700
这是new context

18:03.700 --> 18:04.700
这里面

18:04.700 --> 18:08.100
它是这样子

18:08.100 --> 18:09.100
provider

18:10.100 --> 18:16.030
有它来创建的上下文

18:16.030 --> 18:17.030
那么这里

18:17.030 --> 18:18.030
是这么个意思的

18:18.030 --> 18:20.030
现在

18:20.030 --> 18:22.030
现在是这么个意思的

18:22.030 --> 18:34.690
好

18:34.690 --> 18:35.690
那么这个上下文

18:35.690 --> 18:37.690
是有provider创建的

18:37.690 --> 18:38.690
看没

18:38.690 --> 18:39.690
是有它来创建的上下文

18:39.690 --> 18:40.690
要这么理解

18:40.690 --> 18:41.690
就不是说

18:41.690 --> 18:42.690
有我们自己写的

18:42.690 --> 18:43.690
哪个组件创建的

18:43.690 --> 18:44.690
这样子

18:44.690 --> 18:45.690
跟我们自己写的组件

18:45.690 --> 18:46.690
是不是分离开了

18:46.690 --> 18:47.690
对吧

18:47.690 --> 18:48.690
就分离开了

18:48.690 --> 18:49.690
我们的自己的组件

18:49.690 --> 18:50.690
就不用去关心这些东西了

18:50.690 --> 18:51.690
直接用就完事了

18:51.690 --> 18:53.690
直接用

18:53.690 --> 18:54.690
没问题吧

18:54.690 --> 18:56.690
provider来创建的上下文

18:58.690 --> 18:59.690
不对

18:59.690 --> 19:00.690
应该这样说

19:00.690 --> 19:01.690
因为我们这个provider

19:01.690 --> 19:04.690
是在new context里面用的

19:04.690 --> 19:05.690
是在这里面用的

19:05.690 --> 19:06.690
应该是它包含它

19:06.690 --> 19:07.690
对吧

19:07.690 --> 19:09.690
应该是它包含它

19:09.690 --> 19:10.690
它包含它

19:10.690 --> 19:11.690
对不对

19:11.690 --> 19:12.690
这个没问题吧

19:12.690 --> 19:13.690
所以说我们这里

19:13.690 --> 19:14.690
应该是这样的话才对

19:14.690 --> 19:16.690
provider在下面

19:21.340 --> 19:23.340
是这么一种结构了

19:24.340 --> 19:25.340
没问题吧

19:25.340 --> 19:26.340
放个颜色

19:26.340 --> 19:27.340
放个颜色

19:30.420 --> 19:31.420
这个组件

19:31.420 --> 19:32.420
它创建这么一个上下文

19:33.420 --> 19:38.230
再放一个

19:38.230 --> 19:39.230
白色

19:40.230 --> 19:42.230
是这么一种结构了

19:42.230 --> 19:46.500
这个上下文是它创建的

19:46.500 --> 19:47.500
没问题吧

19:48.500 --> 19:49.500
没问题吧

19:50.500 --> 19:51.500
provider里面的

19:52.500 --> 19:54.500
这个上下文是由它来创建的

19:55.500 --> 19:58.500
然后它创建了上下文之后

19:58.500 --> 19:59.500
后边的组件

19:59.500 --> 20:01.500
都可以使用这个上下文了

20:01.500 --> 20:02.500
对吧

20:02.500 --> 20:05.500
provider叫做上下文生产者

20:05.500 --> 20:07.500
它叫做生产者

20:08.500 --> 20:10.500
生产者

20:10.500 --> 20:12.500
那么生产者

20:12.500 --> 20:13.500
生产了什么东西

20:13.500 --> 20:15.500
是不是生产了一个上下文出来

20:15.500 --> 20:18.500
那么上下文里面的数据呢

20:18.500 --> 20:20.500
数据呢我们这里直线了默认值

20:20.500 --> 20:21.500
对吧

20:21.500 --> 20:23.500
这里只是数据的默认值

20:23.500 --> 20:24.500
你看一下

20:24.500 --> 20:26.500
现在组件结构也发生变化了

20:26.500 --> 20:27.500
之前的组件结构是

20:27.500 --> 20:29.500
没有发生任何变化的

20:29.500 --> 20:30.500
你看现在是不是多了一个

20:30.500 --> 20:31.500
contact是provider

20:31.500 --> 20:32.500
多了这么一个东西了

20:33.500 --> 20:34.500
那么我们在这里写了一个

20:34.500 --> 20:36.500
什么上下文的默认

20:36.500 --> 20:37.500
就是个默认值

20:37.500 --> 20:39.500
上下文里面数据的默认值

20:39.500 --> 20:41.500
那么我要改这个值这么办

20:41.500 --> 20:42.500
它是这样子

20:42.500 --> 20:44.500
通过这个value属性改变

20:44.500 --> 20:46.500
它里面有个属性value

20:47.500 --> 20:49.500
你可以给这个value属性负值

20:49.500 --> 20:51.500
然后重新改变它里面的数据

20:51.500 --> 20:52.500
比方说

20:52.500 --> 20:53.500
这里

20:54.500 --> 20:58.500
该组件有一个value属性

20:58.500 --> 21:00.500
通过该属性

21:01.500 --> 21:03.500
可以负值

21:03.500 --> 21:04.500
为其

21:04.500 --> 21:05.500
为其什么了

21:05.500 --> 21:07.500
为其数据负值

21:08.500 --> 21:10.500
你每一次渲染的时候

21:10.500 --> 21:12.500
那么我把这个value值给它

21:12.500 --> 21:14.500
那么它就把上下文里面的东西更新了

21:14.500 --> 21:16.500
那跟之前的过程是不是

21:16.500 --> 21:18.500
之前还有单独一个函数

21:18.500 --> 21:19.500
单独一个函数

21:19.500 --> 21:20.500
就是我们之前写的

21:20.500 --> 21:21.500
单独有这么一个函数

21:21.500 --> 21:23.500
叫做getcontact

21:23.500 --> 21:25.500
那么现在是不是没了

21:25.500 --> 21:26.500
我们之前说这个函数

21:26.500 --> 21:28.500
会在render之后运行

21:28.500 --> 21:30.500
但是现在就跟render直接合并了

21:30.500 --> 21:31.500
它就是一个组件

21:31.500 --> 21:32.500
一个普普通通的组件

21:32.500 --> 21:33.500
那么我把数据给它

21:33.500 --> 21:35.500
render的时候是不是把数据给它

21:35.500 --> 21:37.500
那么它是不是会重新渲染

21:37.500 --> 21:38.500
对不对

21:38.500 --> 21:40.500
它重新不会把数据放到上下文里面

21:40.500 --> 21:41.500
重新渲染

21:41.500 --> 21:42.500
就这么简单

21:42.500 --> 21:44.500
更加符合逻辑了

21:44.500 --> 21:46.500
当然这里有两种写法

21:46.500 --> 21:47.500
一种写法是

21:47.500 --> 21:48.500
就这种写法

21:48.500 --> 21:49.500
这种写法

21:49.500 --> 21:51.500
另一种写法是这样子

21:51.500 --> 21:53.500
直接把表达是写到元素这里

21:53.500 --> 21:54.500
我好像之前说过

21:54.500 --> 21:56.500
表达是不能写到这里

21:56.500 --> 21:58.500
之前我讲了一个问题

21:58.500 --> 21:59.500
讲了一个问题

21:59.500 --> 22:00.500
因为我之前

22:00.500 --> 22:01.500
我想

22:01.500 --> 22:02.500
脑袋里面想的是这个东西

22:02.500 --> 22:04.500
就是这种表达是

22:04.500 --> 22:05.500
比方说

22:06.500 --> 22:07.500
这种表达是

22:07.500 --> 22:09.500
proper name

22:09.500 --> 22:11.500
provider

22:11.500 --> 22:13.500
我想的是这种表达是

22:17.070 --> 22:19.070
这种表达是不能这样写的

22:19.070 --> 22:21.070
这种表达是不能再放到

22:21.070 --> 22:22.070
元素内容这里

22:22.070 --> 22:24.070
这是不行的

22:24.070 --> 22:25.070
但是这种是可以的

22:25.070 --> 22:26.070
这种是可以的

22:26.070 --> 22:27.070
没问题的

22:28.070 --> 22:30.070
现在给歪六属性复制

22:30.070 --> 22:31.070
比方说

22:31.070 --> 22:32.070
我跟之前的一样

22:32.070 --> 22:33.070
New contact

22:33.070 --> 22:35.070
里面它有提供状态

22:35.070 --> 22:36.070
也提供状态

22:36.070 --> 22:37.070
State

22:38.070 --> 22:39.070
跟之前一样

22:39.070 --> 22:41.070
n为0

22:41.070 --> 22:43.070
b为abc

22:43.070 --> 22:45.070
这里其实默认值也不用写了

22:45.070 --> 22:46.070
默认值也不用写了

22:46.070 --> 22:47.070
就创造一个上下文德了

22:48.070 --> 22:49.070
然后把State

22:49.070 --> 22:50.070
给他

22:50.070 --> 22:51.070
z.state

22:52.070 --> 22:53.070
把setState给他就行了

22:54.070 --> 22:55.070
没问题吧

22:55.070 --> 22:56.070
当然也可以

22:56.070 --> 22:58.070
在这里再写个对象

22:58.070 --> 23:00.070
对象里面有abc

23:00.070 --> 23:01.070
State给他

23:02.070 --> 23:04.070
这样子就完了

23:04.070 --> 23:05.070
形成最终结果

23:05.070 --> 23:06.070
也还是这样一个效果

23:06.070 --> 23:08.070
New contact里面有个provider

23:08.070 --> 23:10.070
上下文的提供者

23:10.070 --> 23:12.070
上下文提供哪来的

23:12.070 --> 23:14.070
是通过这个地方创建了一个对象

23:14.070 --> 23:15.070
对象里面有一个属性

23:15.070 --> 23:16.070
provider

23:16.070 --> 23:17.070
提供者

23:17.070 --> 23:18.070
那么这个东西

23:18.070 --> 23:19.070
产生上下文

23:19.070 --> 23:20.070
你把上下文的数据

23:20.070 --> 23:21.070
给他就完事了

23:22.070 --> 23:23.070
不管你这个数据哪来的

23:23.070 --> 23:24.070
来自于状态

23:24.070 --> 23:25.070
来自于这个

23:25.070 --> 23:26.070
主建的属性

23:26.070 --> 23:27.070
无所谓

23:27.070 --> 23:29.070
反正你属性变化

23:29.070 --> 23:30.070
你状态变化

23:30.070 --> 23:31.070
你肯定要运行Render

23:31.070 --> 23:32.070
你Render的时候

23:32.070 --> 23:33.070
我是不是重新复制的

23:33.070 --> 23:34.070
对了

23:34.070 --> 23:35.070
你Render是不是重新复制的

23:35.070 --> 23:36.070
那么跟之前那一相比

23:36.070 --> 23:38.070
你看之前那种生命周期一相比

23:38.070 --> 23:40.070
那这里是不是非常好理解

23:40.070 --> 23:42.070
他多了一个组建而已

23:42.070 --> 23:43.070
你改变了数据

23:43.070 --> 23:45.070
他这个肯定要重新复制

23:45.070 --> 23:47.070
重新渲染的时候

23:47.070 --> 23:49.070
肯定要重新复制

23:49.070 --> 23:51.070
就一切都非常非常自然

23:51.070 --> 23:53.070
这是数据的提供者

23:53.070 --> 23:54.070
那么数据的使用者

23:54.070 --> 23:55.070
我们看一下

23:55.070 --> 23:57.070
比方说我们这里有一个

23:58.070 --> 23:59.070
韩式组建还是一样

23:59.070 --> 24:01.070
Chill的A

24:01.070 --> 24:02.070
Chill的A

24:02.070 --> 24:04.070
Props

24:04.070 --> 24:07.070
这里面我们返回的是一个DIV

24:07.070 --> 24:09.070
我们把这个东西复制过来

24:09.070 --> 24:10.070
复制过来

24:10.070 --> 24:11.070
Chill的A

24:11.070 --> 24:12.070
Chill的B

24:12.070 --> 24:14.510
看着

24:14.510 --> 24:16.510
跟之前有什么样的区别

24:17.510 --> 24:19.510
Chill的A里边

24:19.510 --> 24:21.510
我们先不写这句话

24:21.510 --> 24:22.510
先不写这句话

24:23.510 --> 24:24.510
Chill的A里边

24:24.510 --> 24:25.510
有一个

24:25.510 --> 24:27.510
这里没有第二个参数

24:27.510 --> 24:28.510
然后有个DIV

24:28.510 --> 24:29.510
DIV里面

24:29.510 --> 24:30.510
这个无所谓

24:30.510 --> 24:32.510
然后再放一个Chill的B

24:32.510 --> 24:34.510
Chill的B里边没有这个东西

24:34.510 --> 24:36.510
然后这里边按钮也没了

24:36.510 --> 24:39.510
那么现在我要取这个数据

24:39.510 --> 24:42.510
要在Chill的B里边去取这个数据

24:42.510 --> 24:44.510
取上下文里边的数据

24:44.510 --> 24:46.510
取数据的方式倒是一样的

24:46.510 --> 24:47.510
倒是一样的

24:47.510 --> 24:49.510
但是跟之前的有个区别

24:49.510 --> 24:50.510
就在于什么了

24:50.510 --> 24:52.510
我们现在看一下解构

24:52.510 --> 24:53.510
解构弄清楚

24:53.510 --> 24:55.510
现在Provider里面提供了上下文

24:55.510 --> 24:57.510
然后Chill的A里边有个Chill的B

24:57.510 --> 24:59.510
现在我要在Chill的B里边

24:59.510 --> 25:01.510
去拿到上下文里边的数据

25:01.510 --> 25:04.510
我们来看一下Chill的B怎么去拿

25:04.510 --> 25:06.510
Chill的B呢

25:07.510 --> 25:08.510
在这

25:08.510 --> 25:10.510
我要在这里面倒进来

25:10.510 --> 25:11.510
再倒进来

25:11.510 --> 25:13.510
Chill的A

25:15.510 --> 25:17.510
Chill的B怎么去拿这个数据

25:17.510 --> 25:19.510
现在肯定是拿不到的

25:19.510 --> 25:21.510
因为我们在讲就版的API的时候

25:21.510 --> 25:22.510
都说过一个东西

25:22.510 --> 25:24.510
要从上下文里面去拿数据

25:24.510 --> 25:25.510
有个要求

25:25.510 --> 25:26.510
必须要有一个静态

25:26.510 --> 25:28.510
首先contact steps

25:28.510 --> 25:29.510
为什么要这个要求

25:29.510 --> 25:30.510
我当时也解释了

25:30.510 --> 25:33.510
它是因为你加了上下文之后

25:33.510 --> 25:35.510
你肯定有多了一个依赖关系

25:35.510 --> 25:36.510
它房子里出错

25:36.510 --> 25:38.510
房子里乱去写这个代码

25:38.510 --> 25:40.510
因此主要的目的是让你去

25:40.510 --> 25:42.510
自己手动声音一下

25:42.510 --> 25:43.510
你到底要干嘛

25:43.510 --> 25:46.510
你是不是真的要去依赖上下文

25:46.510 --> 25:48.510
那么在新版里边

25:48.510 --> 25:49.510
使用上下文里边的数据

25:49.510 --> 25:51.510
也是一样

25:51.510 --> 25:54.510
康休曼属性的后续讲解

25:54.510 --> 25:56.510
后续讲解

25:56.510 --> 25:58.510
那么有个要求

25:58.510 --> 25:59.510
什么要求呢

25:59.510 --> 26:03.510
就是必须拥有静态属性

26:03.510 --> 26:05.510
这属性的名字跟之前差不多

26:05.510 --> 26:07.510
叫做contact type

26:07.510 --> 26:08.510
注意没有s了

26:08.510 --> 26:09.510
之前有个s

26:09.510 --> 26:11.510
就叫做contact type

26:11.510 --> 26:13.510
这个type应该

26:13.510 --> 26:16.510
复制为

26:16.510 --> 26:20.510
创建的上下文对象

26:21.510 --> 26:23.510
就是之前通过这个东西

26:23.510 --> 26:25.510
创建的上下文对象

26:25.510 --> 26:27.510
于是我们这里看

26:27.510 --> 26:29.510
现在拿不到这个数据

26:29.510 --> 26:31.510
那么我们现在为了拿到这个数据

26:31.510 --> 26:34.510
我在childb里边写上这么一个静态属性

26:34.510 --> 26:35.510
静态属性

26:35.510 --> 26:37.510
static

26:37.510 --> 26:38.510
然后什么属性呢

26:38.510 --> 26:39.510
叫contact type

26:39.510 --> 26:41.510
你看是不是有智能提示的

26:41.510 --> 26:42.510
直接给它复制

26:42.510 --> 26:43.510
复制为谁

26:43.510 --> 26:45.510
就复制为这个东西

26:45.510 --> 26:46.510
就完了

26:46.510 --> 26:48.510
复制为这个东西就完事了

26:49.510 --> 26:50.510
那么你复制为这个东西过后

26:50.510 --> 26:51.510
它就知道了

26:51.510 --> 26:53.510
原来你想拿这个上下文里边的数据

26:53.510 --> 26:55.510
这个上下文里边的数据

26:55.510 --> 26:58.510
它就会自动通过一系列的稍稍做

26:58.510 --> 27:00.510
然后给你往contact里面

27:00.510 --> 27:01.510
给你复制

27:01.510 --> 27:02.510
往这个属性里面复制

27:02.510 --> 27:03.510
那么之后

27:03.510 --> 27:06.510
就可以通过contact拿到这个数据了

27:06.510 --> 27:07.510
包存你看一下

27:07.510 --> 27:09.510
就拿到了0abc

27:09.510 --> 27:11.510
拿到这个数据了

27:11.510 --> 27:12.510
那么现在是不是非常简洁了

27:12.510 --> 27:13.510
你看

27:13.510 --> 27:14.510
非常简洁

27:14.510 --> 27:15.510
你这个东西

27:15.510 --> 27:16.510
肯定要单独提一个文件

27:16.510 --> 27:18.510
如果你要用多文件的格式的话

27:18.510 --> 27:21.510
那么这个东西肯定要单独提一个磨块数据

27:21.510 --> 27:22.510
然后倒出

27:22.510 --> 27:23.510
那么这里呢

27:23.510 --> 27:25.510
你只要一想使用哪个上下文的数据

27:25.510 --> 27:26.510
那么去依赖就行了

27:26.510 --> 27:29.510
这样子依赖关系也非常好理解

27:29.510 --> 27:30.510
就是我这个组建币

27:30.510 --> 27:32.510
它除了依赖属性之外

27:32.510 --> 27:33.510
还依赖一个上下文

27:33.510 --> 27:34.510
你看没

27:34.510 --> 27:35.510
它依赖这个上下文

27:35.510 --> 27:36.510
那么你要用我这个组建

27:36.510 --> 27:38.510
那你必须要提供这么一个上下文

27:38.510 --> 27:39.510
就非常非常清楚了

27:39.510 --> 27:41.510
那么使用这个组建的人

27:41.510 --> 27:43.510
就必须要从这个上下文里边

27:43.510 --> 27:45.510
去加一个提供者

27:45.510 --> 27:46.510
往这里边放数据

27:46.510 --> 27:47.510
不然的话

27:47.510 --> 27:48.510
它里边的组建要出问题

27:48.510 --> 27:49.510
因为这个组建

27:49.510 --> 27:50.510
它要用到这个上下文

27:50.510 --> 27:51.510
你不提供给它

27:51.510 --> 27:52.510
那么它拿不到数据

27:53.510 --> 27:54.510
看没

27:54.510 --> 27:56.510
它就用这种模式来做了

27:56.510 --> 27:57.510
好好看一下

27:57.510 --> 27:58.510
好好看一下

27:58.510 --> 28:00.510
最好了现在你暂停视频

28:00.510 --> 28:01.510
跟着写一遍

28:01.510 --> 28:03.510
看一下新版的跟舊版的有什么区别

28:03.510 --> 28:05.510
它的道理是一样的

28:05.510 --> 28:06.510
只不过新版里边

28:06.510 --> 28:07.510
再加了一个组建

28:07.510 --> 28:08.510
叫Provider

28:08.510 --> 28:09.510
加了这么一个组建

28:09.510 --> 28:11.510
加了这个组建之后呢

28:11.510 --> 28:12.510
就加了这个

28:13.510 --> 28:14.510
就这里

28:17.510 --> 28:18.510
加这个组建之后

28:18.510 --> 28:20.510
那么由这个组建来提供上下文

28:20.510 --> 28:22.510
这个上下文的数据

28:22.510 --> 28:23.510
通过这个组建的属性

28:23.510 --> 28:25.510
Value给它复制

28:25.510 --> 28:26.510
通过这个属性的属性

28:26.510 --> 28:28.510
Value给它复制

28:28.510 --> 28:29.510
那么就把数据给它

28:29.510 --> 28:31.510
那么如果要变化这个数据

28:31.510 --> 28:32.510
是不是很简单

28:32.510 --> 28:33.510
你变化这个State就完成了

28:33.510 --> 28:35.510
变化这个数据

28:35.510 --> 28:36.510
咱们来吧

28:36.510 --> 28:38.510
这里写个Button

28:38.510 --> 28:41.510
复组建的按钮

28:41.510 --> 28:43.510
然后A加1

28:43.510 --> 28:45.510
A加1

28:45.510 --> 28:50.040
这里onclick

28:50.040 --> 28:52.040
改变A的值

28:52.040 --> 28:54.040
然后Z is setState

28:54.040 --> 28:55.040
改变A的值

28:55.040 --> 28:56.040
A的值为什么

28:56.040 --> 28:59.040
Z is setState.A加1

28:59.040 --> 29:00.040
那么这样子一来

29:00.040 --> 29:01.040
你看我通过点按钮

29:01.040 --> 29:03.040
改变了我这个NewContact

29:03.040 --> 29:05.040
改变了这个组建

29:05.040 --> 29:06.040
改变了这个组建的数据

29:06.040 --> 29:07.040
而这个数据

29:07.040 --> 29:08.040
是不是

29:08.040 --> 29:09.040
这里的数据是不是就来自于这

29:09.040 --> 29:10.040
你看这个代码

29:10.040 --> 29:12.040
State

29:12.040 --> 29:14.040
就说这里的数据

29:14.040 --> 29:15.040
只继续放到这来了

29:15.040 --> 29:16.040
所以说你改变了State

29:16.040 --> 29:17.040
是不是要重新宣展

29:17.040 --> 29:18.040
一重新宣展

29:18.040 --> 29:19.040
是不是它这个Value值

29:19.040 --> 29:20.040
也要变化

29:20.040 --> 29:21.040
那么它里边的东西

29:21.040 --> 29:22.040
就跟这边了

29:22.040 --> 29:23.040
都跟这边了

29:23.040 --> 29:25.040
保存看一下

29:25.040 --> 29:26.040
按钮值加1

29:26.040 --> 29:27.040
你看是这里

29:27.040 --> 29:28.040
上下文的数据是不是

29:28.040 --> 29:29.040
共享的

29:29.040 --> 29:30.040
没问题吧

29:30.040 --> 29:31.040
其实没有什么特别的

29:31.040 --> 29:32.040
就是

29:32.040 --> 29:33.040
以前是通过属性传递

29:33.040 --> 29:34.040
那么现在多了一种方式

29:34.040 --> 29:35.040
通过上下文

29:35.040 --> 29:36.040
来获取数据

29:36.040 --> 29:37.040
它就不用

29:37.040 --> 29:38.040
上下文获取数据

29:38.040 --> 29:40.040
它就不用管千套层次了

29:40.040 --> 29:41.040
那么同样的道理

29:41.040 --> 29:42.040
那我这里

29:42.040 --> 29:44.040
要改变上下文的数据

29:44.040 --> 29:45.040
我要在后代组建里边

29:45.040 --> 29:46.040
改变上下文的数据

29:46.040 --> 29:47.040
那上下文里边

29:47.040 --> 29:49.040
是不是也要提供一个方法

29:49.040 --> 29:50.040
对吧

29:50.040 --> 29:51.040
也要提供一个方法

29:51.040 --> 29:52.040
那么我们都可以直接

29:52.040 --> 29:54.040
State里边去提供了吧

29:54.040 --> 29:55.040
因为反正我用的是State

29:55.040 --> 29:57.040
但是你在这里提供也行

29:57.040 --> 29:59.040
你在这里提供也行

29:59.040 --> 30:00.040
比方说

30:02.040 --> 30:04.040
我们这里

30:04.040 --> 30:05.040
就写到这吧

30:05.040 --> 30:06.040
就写到这

30:06.040 --> 30:08.040
写什么东西

30:08.040 --> 30:10.040
那么这里也给我一个新的字

30:10.040 --> 30:11.040
新的字

30:11.040 --> 30:12.040
6A

30:12.040 --> 30:13.040
然后我这里

30:13.040 --> 30:18.980
ZsetState

30:18.980 --> 30:20.980
A的字把它复制为6A

30:20.980 --> 30:21.980
对吧

30:21.980 --> 30:22.980
好

30:22.980 --> 30:23.980
那么我把整个State传给你

30:23.980 --> 30:25.980
当然你可以只传一部分

30:25.980 --> 30:26.980
你在这里进行处理就行了

30:26.980 --> 30:28.980
当然可以只传一部分

30:28.980 --> 30:29.980
我把整个只传给你

30:29.980 --> 30:38.980
整个只传给你过后

30:38.980 --> 30:39.980
整个只传给你过后了

30:39.980 --> 30:41.980
那你这里是不是可以用

30:41.980 --> 30:42.980
用这个签结了

30:42.980 --> 30:43.980
对不对

30:43.980 --> 30:44.980
不用去声明类型了

30:44.980 --> 30:45.980
现在不用去声明类型了

30:45.980 --> 30:48.980
这下面有个按钮

30:48.980 --> 30:52.980
就是指主键的按钮

30:52.980 --> 30:54.980
后代主键

30:56.980 --> 30:58.980
点击改变A

30:58.980 --> 30:59.980
点击改变

30:59.980 --> 31:00.980
点击A

31:00.980 --> 31:01.980
加2

31:01.980 --> 31:03.980
看一下吧

31:03.980 --> 31:04.980
onclick

31:04.980 --> 31:05.980
是一样的

31:05.980 --> 31:06.980
跟那个属性

31:06.980 --> 31:09.980
并没有什么本质的区别

31:09.980 --> 31:10.980
我们以前属性

31:10.980 --> 31:11.980
在这里面去调函数

31:11.980 --> 31:12.980
对吧

31:12.980 --> 31:13.980
那么现在我们的上下文里边

31:13.980 --> 31:14.980
去调函数

31:14.980 --> 31:15.980
因为它函数传给你的

31:15.980 --> 31:16.980
签结

31:16.980 --> 31:17.980
那么就是当前

31:17.980 --> 31:18.980
上下文里边的A

31:18.980 --> 31:19.980
加上2

31:19.980 --> 31:21.980
就完了

31:21.980 --> 31:22.980
好

31:22.980 --> 31:23.980
保存

31:23.980 --> 31:24.980
看一下吧

31:24.980 --> 31:25.980
那么这里

31:25.980 --> 31:26.980
是不是也可以跟着改

31:26.980 --> 31:27.980
对不对

31:27.980 --> 31:28.980
也可以跟着改

31:28.980 --> 31:29.980
这里也可以改

31:29.980 --> 31:30.980
这里也可以改

31:30.980 --> 31:31.980
改的都是同一个数据

31:31.980 --> 31:32.980
好

31:32.980 --> 31:33.980
这就是新的

31:33.980 --> 31:35.980
那种上下文的使用方式

31:35.980 --> 31:36.980
用法是一样的

31:36.980 --> 31:38.980
this context是属性

31:38.980 --> 31:39.980
只不过静态属性变了

31:39.980 --> 31:41.980
变成直接使用这个对象了

31:41.980 --> 31:43.980
不再是怎么乱七八糟的

31:43.980 --> 31:44.980
proper types

31:44.980 --> 31:45.980
不再是这个了

31:45.980 --> 31:46.980
直接使用这个对象

31:46.980 --> 31:48.980
因为这个对象是可以附用的

31:48.980 --> 31:49.980
提供的

31:49.980 --> 31:50.980
提供上下文的人

31:50.980 --> 31:53.980
要使用这个对象

31:53.980 --> 31:54.980
那么使用这个

31:54.980 --> 31:55.980
上下文的人

31:55.980 --> 31:58.980
也要使用这个对象

31:58.980 --> 31:59.980
明白的意思吧

31:59.980 --> 32:00.980
好

32:00.980 --> 32:01.980
OK

32:01.980 --> 32:02.980
还有另外一个点

32:02.980 --> 32:04.980
大家就是要注意一个点

32:04.980 --> 32:07.980
provider这个属性最好不要附用

32:07.980 --> 32:09.980
最好不要附用

32:09.980 --> 32:10.980
就是说

32:10.980 --> 32:11.980
什么意思呢

32:11.980 --> 32:12.980
就是说你在这个

32:12.980 --> 32:13.980
比方说

32:13.980 --> 32:15.980
我们在这个new context里面

32:15.980 --> 32:16.980
在这个new context里面

32:16.980 --> 32:18.980
用了这个provider

32:18.980 --> 32:19.980
用了这个provider

32:19.980 --> 32:20.980
那么这个provider能力

32:20.980 --> 32:22.980
不要在其他中间里面用了

32:22.980 --> 32:23.980
如果说

32:23.980 --> 32:24.980
你要提供多个上下文的话

32:24.980 --> 32:26.980
你重新去创建一个

32:26.980 --> 32:27.980
去

32:27.980 --> 32:29.980
又重新去创建一个crazy context

32:29.980 --> 32:31.980
再重新创建一个上下文

32:31.980 --> 32:32.980
为什么呢

32:32.980 --> 32:34.980
跟他的实现原理有关系

32:34.980 --> 32:36.980
不要重复的去使用这个provider

32:36.980 --> 32:38.980
这provider就在一个组件里面用

32:38.980 --> 32:39.980
比方说我们现在在这个

32:39.980 --> 32:40.980
new context的组件里面

32:40.980 --> 32:41.980
用了这个provider

32:41.980 --> 32:43.980
那么其他组件就不要用这个了

32:43.980 --> 32:45.980
要用的话重新去创建一个

32:45.980 --> 32:46.980
跟他的实现原理有关系

32:46.980 --> 32:47.980
原理有关系

32:47.980 --> 32:48.980
其实从逻辑上来说的话

32:48.980 --> 32:49.980
这也符合逻辑

32:49.980 --> 32:51.980
上下文来做什么了

32:51.980 --> 32:52.980
数据共享

32:52.980 --> 32:54.980
同一个要共享的数据

32:54.980 --> 32:56.980
你怎么会出现多分的

32:56.980 --> 32:57.980
比方说

32:57.980 --> 32:58.980
这边还有一个组件

32:58.980 --> 32:59.980
这边还有一个组件数

32:59.980 --> 33:01.980
比方说

33:01.980 --> 33:03.980
他也要用到同一份数据

33:03.980 --> 33:04.980
那么你要做什么

33:04.980 --> 33:07.980
你应该把这个数据提升到这里来

33:07.980 --> 33:09.980
你应该把这个provider提升到这里来

33:09.980 --> 33:11.980
让app创建这个provider

33:11.980 --> 33:13.980
然后provider里面包含他

33:13.980 --> 33:14.980
provider里面包含他

33:14.980 --> 33:15.980
应该做这种事情

33:15.980 --> 33:17.980
而不应该去重复的去创建

33:17.980 --> 33:19.980
两个一模一样的数据

33:19.980 --> 33:21.980
不应该这样做

33:21.980 --> 33:23.980
明白我的意思吗

33:23.980 --> 33:25.980
比方说provider里面有个数据

33:25.980 --> 33:26.980
叫做locking user

33:26.980 --> 33:28.980
当前登入的用户

33:28.980 --> 33:29.980
那如果这边也要用的话

33:29.980 --> 33:31.980
你不要重复去使用provider

33:31.980 --> 33:34.980
应该把provider提升到整个应用程序

33:34.980 --> 33:35.980
因为都要用

33:35.980 --> 33:37.980
所以说它是一个共享的数据

33:37.980 --> 33:40.980
你不应该去整两份数据出来

33:40.980 --> 33:41.980
明白我的意思吗

33:41.980 --> 33:42.980
所以说你千万不要

33:42.980 --> 33:44.980
把一个provider用在多个组件里面

33:44.980 --> 33:45.980
不要去这样用

33:45.980 --> 33:47.980
那么有多个provider可以

33:47.980 --> 33:49.980
你只要调用多次

33:49.980 --> 33:50.980
create context

33:50.980 --> 33:51.980
这是一个

33:51.980 --> 33:52.980
还可以继续调用

33:52.980 --> 33:54.980
又产生了上下文

33:54.980 --> 33:55.980
create context

33:55.980 --> 33:56.980
可以

33:56.980 --> 33:57.980
通过调用多次

33:57.980 --> 33:58.980
可以产生不同的上下文

33:58.980 --> 34:00.980
它里面有不同的provider

34:00.980 --> 34:01.980
对吧

34:01.980 --> 34:02.980
这样子是可以的

34:02.980 --> 34:03.980
因为你可能有

34:03.980 --> 34:05.980
有些数据在这一部分共享

34:05.980 --> 34:07.980
另一些数据在另一部分共享

34:07.980 --> 34:08.980
都是可以存在的

34:08.980 --> 34:10.980
但是你不要把一个provider

34:10.980 --> 34:11.980
用在多处

34:11.980 --> 34:12.980
大家注意一下

34:14.980 --> 34:15.980
我写一下吧

34:15.980 --> 34:16.980
不要

34:17.980 --> 34:19.980
同一个provider

34:19.980 --> 34:20.980
它跟它实现原理有关系

34:20.980 --> 34:21.980
我们以后讲到

34:21.980 --> 34:23.980
原码部分你就知道怎么回事了

34:23.980 --> 34:24.980
实际上它的数据在哪

34:24.980 --> 34:25.980
它上下文的数据

34:25.980 --> 34:26.980
非常简单

34:26.980 --> 34:27.980
就在它的静态属性里面

34:27.980 --> 34:28.980
我们以后讲

34:28.980 --> 34:29.980
原码的时候再说

34:29.980 --> 34:30.980
同一个provider

34:30.980 --> 34:33.980
不要用到多个主键中

34:36.980 --> 34:38.980
如果需要

34:40.980 --> 34:43.980
在其他主键中

34:43.980 --> 34:45.980
使用该数据

34:46.980 --> 34:48.980
应该考虑

34:48.980 --> 34:52.980
将数据提升到更高的层次

34:54.980 --> 34:55.980
就像刚才那样子

34:55.980 --> 34:56.980
如果有这边的主键

34:56.980 --> 34:57.980
还要用这个数据的话

34:57.980 --> 34:58.980
你应该把provider

34:58.980 --> 34:59.980
提升到更高的层次

34:59.980 --> 35:01.980
让App来创建这个主键

35:01.980 --> 35:03.980
让App来给它这个数据

35:03.980 --> 35:05.980
是整个应用程序的数据

35:05.980 --> 35:07.980
是这么个意思

35:08.980 --> 35:09.980
我讲清楚没有

35:09.980 --> 35:10.980
你可以讲清楚了

35:11.980 --> 35:12.980
这是provider

35:12.980 --> 35:13.980
那么现在我们来看

35:13.980 --> 35:14.980
一个concumer

35:15.980 --> 35:17.980
concumer叫做消费者

35:17.980 --> 35:18.980
我写错了

35:19.980 --> 35:20.980
消费者

35:20.980 --> 35:21.980
其实它整个就是一个

35:21.980 --> 35:22.980
面向对象的设计模式

35:22.980 --> 35:24.980
生产者

35:24.980 --> 35:25.980
消费者模式

35:25.980 --> 35:27.980
生产者的负责提供一些东西

35:27.980 --> 35:29.980
消费者的负责拿到

35:29.980 --> 35:30.980
获取这些东西

35:30.980 --> 35:31.980
使用这些东西

35:32.980 --> 35:34.980
消费这东西有什么用的

35:34.980 --> 35:35.980
它也是个主键

35:37.980 --> 35:39.980
在那一组键中

35:40.980 --> 35:44.630
直接使用

35:45.630 --> 35:47.630
Z context

35:47.630 --> 35:48.630
获取

35:49.630 --> 35:50.630
上下文数据

35:50.630 --> 35:51.630
这个很简单

35:52.630 --> 35:53.630
那么第二个问题

35:53.630 --> 35:55.630
是在函数主键中

35:55.630 --> 35:57.630
在函数主键中

35:57.630 --> 35:58.630
需要使用

35:59.630 --> 36:00.630
concumer

36:01.630 --> 36:02.630
来

36:03.630 --> 36:04.630
获取

36:04.630 --> 36:06.630
上下文数据

36:06.630 --> 36:07.630
什么意思呢

36:07.630 --> 36:08.630
concumer

36:08.630 --> 36:09.630
它是一个函数

36:09.630 --> 36:11.630
concumer是一个主键

36:13.630 --> 36:15.630
然后这个主键有这么一个特点

36:15.630 --> 36:16.630
它的

36:16.630 --> 36:18.630
止节点

36:19.630 --> 36:20.630
止节点

36:20.630 --> 36:21.630
是一个函数

36:23.630 --> 36:24.630
换句话说

36:24.630 --> 36:26.630
它的Props

36:28.630 --> 36:30.630
需要传递一个函数

36:31.630 --> 36:32.630
我们这里看一下怎么来用

36:32.630 --> 36:33.630
一看就明白了

36:34.630 --> 36:35.630
在敲的A里边

36:35.630 --> 36:36.630
比方说

36:36.630 --> 36:38.630
我这里边也要获取

36:38.630 --> 36:39.630
也要获取啥呢

36:39.630 --> 36:41.630
获取上下文里边的数据

36:41.630 --> 36:42.630
A

36:42.630 --> 36:43.630
也要获取上下文里边的数据

36:43.630 --> 36:44.630
A和B

36:45.630 --> 36:46.630
我们看一下怎么获取

36:46.630 --> 36:47.630
这里有函数

36:47.630 --> 36:49.630
我在这里边也要获取

36:49.630 --> 36:50.630
上下文里边的数据

36:50.630 --> 36:51.630
A和B

36:51.630 --> 36:52.630
它是函数主键

36:52.630 --> 36:54.630
那肯定没有Z context

36:54.630 --> 36:56.630
它没有这个东西

36:56.630 --> 36:58.630
当然它同样的要做一件事

36:58.630 --> 36:59.630
就是child

37:00.630 --> 37:01.630
context type

37:01.630 --> 37:02.630
应该为什么呢

37:04.630 --> 37:05.630
这里不需要了

37:05.630 --> 37:07.630
这里不需要做这件事

37:07.630 --> 37:09.630
你现在要做的事情就是

37:09.630 --> 37:11.630
使用context里边的

37:12.630 --> 37:13.630
concumer

37:17.030 --> 37:18.030
concumer

37:18.030 --> 37:19.030
要做的是用这个

37:20.030 --> 37:21.030
就用这个就行了

37:21.030 --> 37:23.030
concumer就是消费者

37:23.030 --> 37:24.030
他给的提供这么一个主键

37:24.030 --> 37:25.030
那么这个主键

37:25.030 --> 37:27.030
它本身就能获取上下文的数据

37:27.030 --> 37:29.030
然后它会把这个数据传给

37:29.030 --> 37:31.030
你这里边要传一个函数进去

37:31.030 --> 37:33.030
要传一个函数进去

37:33.030 --> 37:35.030
它会把这个数据传给这个函数的

37:35.030 --> 37:37.030
作为函数的参数传进来

37:37.030 --> 37:38.030
value

37:39.030 --> 37:41.030
它会作为这个函数的参数传进来

37:41.030 --> 37:42.030
那么这个函数的反回值

37:42.030 --> 37:43.030
它会把它显示出来

37:44.030 --> 37:46.030
比方说咱们反回的是什么呢

37:46.030 --> 37:49.030
我们反回的是这么一个东西

37:50.030 --> 37:51.030
反回的是一个

37:52.030 --> 37:53.030
十半元数

37:53.030 --> 37:54.030
十半元数

37:54.030 --> 37:56.030
或者是H2P元数里面

37:56.030 --> 37:57.030
不能包含H2

37:57.030 --> 37:59.030
那这里我们用H2元数

38:01.030 --> 38:03.030
这里我们用H2元数

38:03.030 --> 38:05.030
那么这里我们显示的是什么呢

38:05.030 --> 38:06.030
反回的是一个

38:06.030 --> 38:08.030
里边是一个数据

38:08.030 --> 38:09.030
直接显示一个数据

38:09.030 --> 38:10.030
数据是什么呢

38:10.030 --> 38:11.030
数据是

38:12.030 --> 38:13.030
value.

38:14.030 --> 38:15.030
这样子写吧

38:17.030 --> 38:18.030
这里边是数据

38:18.030 --> 38:19.030
数据是

38:19.030 --> 38:20.030
value.a

38:21.030 --> 38:22.030
然后呢

38:23.030 --> 38:24.030
value.b

38:25.030 --> 38:26.030
你这样子再显示

38:26.030 --> 38:28.030
它会把这个函数的反回结果

38:28.030 --> 38:29.030
渲染出来

38:30.030 --> 38:31.030
保存看一下

38:32.030 --> 38:33.030
你看是不是显示出来了

38:33.030 --> 38:34.030
函数组件里面

38:34.030 --> 38:36.030
它是不需要写这个静态属性的

38:39.030 --> 38:40.030
这是内组件的要求

38:41.030 --> 38:42.030
在新版里面

38:42.030 --> 38:43.030
函数组件

38:43.030 --> 38:44.030
它是不需要设置静态属性的

38:44.030 --> 38:46.030
为什么不需要设置静态属性的

38:46.030 --> 38:47.030
你想

38:47.030 --> 38:48.030
你通过这句话

38:48.030 --> 38:49.030
是不是已经明确的告诉他

38:49.030 --> 38:51.030
我要使用哪一个

38:51.030 --> 38:53.030
哪一个就是上下文了

38:53.030 --> 38:54.030
对吧

38:54.030 --> 38:56.030
因为你看CTX就是一个上下文

38:56.030 --> 38:57.030
对应到这个上下文

38:57.030 --> 38:58.030
通过这句话

38:58.030 --> 38:59.030
明确的告诉他

38:59.030 --> 39:00.030
我要使用哪个上下文了

39:00.030 --> 39:02.030
那么你就直接用就行了

39:02.030 --> 39:04.030
你不用再写什么

39:04.030 --> 39:06.030
就是静态属性了

39:06.030 --> 39:08.030
因为这里的语法

39:08.030 --> 39:09.030
已经非常明确了

39:09.030 --> 39:10.030
你看

39:10.030 --> 39:11.030
我们通过函数组件的

39:11.030 --> 39:12.030
你看

39:12.030 --> 39:13.030
这是提供着

39:13.030 --> 39:14.030
对吧

39:14.030 --> 39:15.030
我把数据给你

39:15.030 --> 39:16.030
那么这是消费者

39:16.030 --> 39:18.030
甭管签到多么深的层次

39:18.030 --> 39:19.030
我总能通过这里

39:19.030 --> 39:21.030
把对应的上下文的数据拿到

39:21.030 --> 39:23.030
拿到对应的上下文的数据

39:23.030 --> 39:24.030
拿到

39:24.030 --> 39:26.030
看呗

39:26.030 --> 39:28.030
就能获取到A和B

39:28.030 --> 39:29.030
我们这里点击

39:29.030 --> 39:30.030
你看是不是跟着变了

39:30.030 --> 39:31.030
对不对

39:31.030 --> 39:32.030
他们是同一套数据

39:32.030 --> 39:33.030
看呗

39:33.030 --> 39:34.030
这里也是

39:34.030 --> 39:35.030
同一套数据

39:35.030 --> 39:36.030
没问题吧

39:36.030 --> 39:39.030
你看这个东西是不是传递

39:39.030 --> 39:40.030
相当于是传递的啥

39:40.030 --> 39:42.030
相当于是传递给他一个切尔军

39:42.030 --> 39:43.030
对吧

39:43.030 --> 39:44.030
相当于是传递的这个东西

39:44.030 --> 39:46.030
那么只不过那个切尔军里面

39:46.030 --> 39:47.030
你传递的是啥呢

39:47.030 --> 39:48.030
传递的是一个函数

39:48.030 --> 39:49.030
对不对

39:49.030 --> 39:50.030
跟这种写法是一样的

39:50.030 --> 39:51.030
你看一下吧

39:51.030 --> 39:52.030
是一样的

39:52.030 --> 39:53.030
对吧

39:53.030 --> 39:54.030
你写到这里面

39:54.030 --> 39:56.030
我们知道切尔军是个语法堂

39:56.030 --> 39:57.030
它是个特殊的属性

39:57.030 --> 39:58.030
你这样的写相

39:58.030 --> 39:59.030
当于把这个东西

39:59.030 --> 40:00.030
作为切尔军传过去

40:00.030 --> 40:03.030
他要求里切尔军必须是一个函数

40:03.030 --> 40:04.030
那么他会把什么

40:04.030 --> 40:06.030
把这个就是那个

40:06.030 --> 40:08.030
上下文的数据

40:08.030 --> 40:09.030
就是这个上下文的数据

40:09.030 --> 40:11.030
因为用的是这个上下文

40:11.030 --> 40:12.030
他会把这个上下文的数据

40:12.030 --> 40:14.030
作为参数指示传给你

40:14.030 --> 40:15.030
那么你爱怎么用

40:15.030 --> 40:16.030
怎么去用

40:16.030 --> 40:18.030
他会把你返回的结果

40:18.030 --> 40:20.030
来进行渲染

40:20.030 --> 40:22.030
就这么简单

40:22.030 --> 40:25.600
这是使用函数组件

40:25.600 --> 40:27.600
来获取上下文

40:27.600 --> 40:29.600
那么这是使用内组件来获取

40:29.600 --> 40:30.600
内组件里面

40:30.600 --> 40:31.600
能不能用这种方式来获取

40:31.600 --> 40:32.600
也可以

40:32.600 --> 40:33.600
内组件里面

40:33.600 --> 40:35.600
也可以用这种方式来获取

40:35.600 --> 40:36.600
比方说吧

40:36.600 --> 40:37.600
我们这里

40:37.600 --> 40:38.600
就保存一个

40:38.600 --> 40:39.600
好

40:39.600 --> 40:40.600
我们把内组件里面

40:40.600 --> 40:41.600
把这个去掉

40:41.600 --> 40:43.600
因为这种获取方式

40:43.600 --> 40:44.600
是非常明确的

40:44.600 --> 40:46.600
它的写法

40:46.600 --> 40:48.600
到这边来

40:49.600 --> 40:51.600
它的写法是非常明确的

40:51.600 --> 40:52.600
这边

40:52.600 --> 40:53.600
还是用这种写法

40:53.600 --> 40:55.600
把这种写法看得清楚一点

40:55.600 --> 40:59.580
我们看一下

40:59.580 --> 41:01.580
在内组件里面

41:01.580 --> 41:03.580
它也可以用这种方式来获取

41:03.580 --> 41:04.580
我们来写一下

41:04.580 --> 41:05.580
就不要这句话了

41:05.580 --> 41:06.580
这句话就不用了

41:06.580 --> 41:07.580
好

41:07.580 --> 41:08.580
那么这里我们返

41:08.580 --> 41:09.580
我们这里返回什么呢

41:09.580 --> 41:10.580
返回的是一个

41:10.580 --> 41:12.580
这个东西

41:12.580 --> 41:13.580
C

41:13.580 --> 41:15.580
Consumer

41:15.580 --> 41:18.580
这里写上一个函数

41:18.580 --> 41:20.580
Value

41:20.580 --> 41:21.580
Value

41:21.580 --> 41:22.580
好

41:22.580 --> 41:23.580
这个函数的返回结果了

41:23.580 --> 41:24.580
返回的是什么呢

41:24.580 --> 41:25.580
返回的是一个

41:25.580 --> 41:27.580
要渲染的东西

41:27.580 --> 41:29.580
返回的是要渲染的东西

41:29.580 --> 41:30.580
我们这里打个货号嘛

41:30.580 --> 41:36.060
最好打货号

41:36.060 --> 41:38.060
就是GSX表达是前后最好打货号

41:38.060 --> 41:39.060
不然的话

41:39.060 --> 41:40.060
有换行的话

41:40.060 --> 41:41.060
就识别不出来了

41:41.060 --> 41:42.060
那么这里呢

41:42.060 --> 41:44.060
我们这里Value值

41:44.060 --> 41:46.060
这里是通过Value值来获取

41:46.060 --> 41:48.060
Value值来获取

41:48.060 --> 41:49.060
这里也是

41:49.060 --> 41:51.060
通过Value值来获取

41:51.060 --> 41:52.060
这里也是

41:52.060 --> 41:53.060
Value值

41:55.890 --> 41:56.890
Value值

41:56.890 --> 41:57.890
好 你看一下吧

41:57.890 --> 41:58.890
看一下

41:58.890 --> 41:59.890
保存

42:00.890 --> 42:01.890
是不是一样的

42:01.890 --> 42:02.890
对吧 一样的

42:02.890 --> 42:03.890
可以通过

42:03.890 --> 42:05.890
也可以通过这种方式来获取

42:05.890 --> 42:06.890
没问题的

42:07.890 --> 42:08.890
这就是

42:08.890 --> 42:09.890
新版的

42:09.890 --> 42:11.890
就是那个上下文

42:11.890 --> 42:12.890
该怎么去用

42:13.890 --> 42:14.890
用这种做法呢

42:14.890 --> 42:15.890
其实

42:15.890 --> 42:17.890
你写了好像说多写一点话

42:17.890 --> 42:18.890
多写一句话

42:18.890 --> 42:19.890
这个结构看上去有点乱

42:19.890 --> 42:20.890
实际上这种用法

42:20.890 --> 42:21.890
是结构最清晰的

42:21.890 --> 42:23.890
实际上是结构最清晰的

42:23.890 --> 42:24.890
就是这是消费的

42:24.890 --> 42:26.890
通过这句话一看就明白了

42:26.890 --> 42:28.890
我这里要用到这个上下文

42:28.890 --> 42:30.890
并且我要消费这里边的数据

42:30.890 --> 42:31.890
我要用这里边的数据

42:31.890 --> 42:32.890
一看这个代码

42:32.890 --> 42:33.890
马上就明白了

42:33.890 --> 42:34.890
我要依赖这个上下文

42:36.890 --> 42:38.890
好 那么再我们再来聊一聊

42:38.890 --> 42:40.890
在新版的APN里边

42:40.890 --> 42:41.890
如果有多个上下文

42:41.890 --> 42:43.890
该怎么来处理

42:43.890 --> 42:44.890
如果有多个上下文

42:44.890 --> 42:45.890
该怎么来处理

42:45.890 --> 42:46.890
比方说吧

42:46.890 --> 42:47.890
还是一样的

42:47.890 --> 42:48.890
咱们又来

42:48.890 --> 42:49.890
又来了

42:49.890 --> 42:51.890
这个Chill的A里边

42:51.890 --> 42:52.890
又来的上下文

42:54.890 --> 42:55.890
我这样子不行了

42:55.890 --> 42:57.890
这样子先把它字为底一层

42:57.890 --> 43:00.890
然后再把它放上一层

43:01.890 --> 43:04.260
这样子

43:04.260 --> 43:06.260
那么在新版里边

43:06.260 --> 43:07.260
Chill的A

43:07.260 --> 43:08.260
它又创建个上下文

43:08.260 --> 43:09.260
新版创建的上下文

43:09.260 --> 43:10.260
肯定是这样的结构

43:10.260 --> 43:11.260
它一定是这样的结构

43:13.260 --> 43:18.560
这里往下画一点了

43:18.560 --> 43:19.560
它一定是这样的结构

43:19.560 --> 43:25.050
这是一个上下文

43:26.050 --> 43:27.050
Chill的A

43:27.050 --> 43:28.050
它创建个上下文

43:28.050 --> 43:30.050
它又是不是多那个Provider

43:30.050 --> 43:33.050
这边是比方说CTX1.Provider

43:33.050 --> 43:34.050
那么这个地方

43:34.050 --> 43:37.050
比方说CTX2.Provider

43:37.050 --> 43:38.050
它区分的非常明显

43:38.050 --> 43:40.050
因为它是组件

43:40.050 --> 43:41.050
它通过组件的区分

43:41.050 --> 43:43.050
它区分的非常明显

43:43.050 --> 43:45.050
你爱用哪个用哪个

43:45.050 --> 43:46.050
它不存在说

43:46.050 --> 43:47.050
你要什么覆盖不覆盖的

43:47.050 --> 43:48.050
不存在

43:48.050 --> 43:49.050
你爱用哪个用哪个

43:49.050 --> 43:50.050
因为它是有不同的

43:50.050 --> 43:52.050
组件提供的上下文

43:52.050 --> 43:53.050
我们来看一下吧

43:53.050 --> 43:54.050
你看现在结构上

43:54.050 --> 43:56.050
是不是比以前更加清晰了

43:57.050 --> 43:58.050
比方说

43:58.050 --> 44:00.050
这里也存在这么一个数据

44:00.050 --> 44:02.050
那么我们把它写成这么一种结构

44:02.050 --> 44:03.050
来试一下吧

44:03.050 --> 44:04.050
写成这么一种结构

44:04.050 --> 44:06.050
看一下

44:06.050 --> 44:08.050
咱们再复制一下

44:08.050 --> 44:09.050
复制一下

44:09.050 --> 44:10.050
然后这里

44:10.050 --> 44:12.050
我们对Chill的A进行要更改

44:12.050 --> 44:14.050
对Chill的A进行要更改

44:14.050 --> 44:15.050
那么现在Chill的A是函数组件

44:15.050 --> 44:16.050
函数组件

44:16.050 --> 44:18.050
能不能提供上下文

44:18.050 --> 44:19.050
能不能提供

44:19.050 --> 44:20.050
当然可以提供

44:20.050 --> 44:21.050
为什么不能提供

44:21.050 --> 44:22.050
上下文

44:22.050 --> 44:23.050
现在不就是跟组件

44:23.050 --> 44:25.050
没什么直接关系了

44:25.050 --> 44:27.050
我们把它改成CTX1

44:27.050 --> 44:29.050
然后我们现在再建立一个

44:29.050 --> 44:30.050
CTX2

44:30.050 --> 44:31.050
react

44:31.050 --> 44:32.050
你看跟这个组件

44:32.050 --> 44:33.050
没有什么直接关系了

44:33.050 --> 44:34.050
它把分裂出去了

44:34.050 --> 44:36.050
你看这种结构是不是更好

44:36.050 --> 44:37.050
那么Chill的A

44:37.050 --> 44:39.050
它除了要消费

44:39.050 --> 44:40.050
它除了是一个消费者

44:40.050 --> 44:42.050
要得到A和B

44:42.050 --> 44:44.050
得到之前的上下文1

44:44.050 --> 44:45.050
你看

44:45.050 --> 44:46.050
CTX1的数据

44:46.050 --> 44:48.050
你看这个非常明显

44:48.050 --> 44:49.050
我要得到这里面的数据

44:49.050 --> 44:50.050
A和B

44:50.050 --> 44:52.050
从这个语意上就非常明显了

44:52.050 --> 44:53.050
都不用我解释了

44:53.050 --> 44:54.050
我这里得到的

44:54.050 --> 44:55.050
肯定是CTX1

44:55.050 --> 44:57.050
这个上下文里边的数据

44:57.050 --> 44:58.050
你看一下

44:59.050 --> 45:00.050
是不是没问题

45:00.050 --> 45:02.050
得到的是CTX1的数据

45:02.050 --> 45:03.050
对吧

45:03.050 --> 45:05.050
那么现在我不仅要得到它的数据

45:05.050 --> 45:06.050
我还要做什么

45:06.050 --> 45:08.050
我还要把这个数据

45:08.050 --> 45:09.050
又包装

45:09.050 --> 45:11.050
我还有一个上下文

45:11.050 --> 45:13.050
就Chill的A里边了

45:13.050 --> 45:14.050
它还有一个上下文

45:14.050 --> 45:15.050
比方说

45:15.050 --> 45:16.050
来这里

45:16.050 --> 45:17.050
打上个小货号

45:17.050 --> 45:24.670
货号在这

45:27.050 --> 45:28.050
现在我们外面

45:28.050 --> 45:29.050
再给它提供一个上下文

45:29.050 --> 45:31.050
它又是个上下文的提供者

45:32.050 --> 45:33.050
Provider

45:38.190 --> 45:39.190
看一下

45:39.190 --> 45:45.860
你看一下

45:45.860 --> 45:47.860
我这里面不但要用到

45:47.860 --> 45:49.860
CTX1的数据

45:49.860 --> 45:51.860
不但要用这个数据

45:51.860 --> 45:52.860
而且我还给你

45:52.860 --> 45:54.860
我又见了个上下文

45:54.860 --> 45:56.860
那是不是这种结构了

45:56.860 --> 45:57.860
ChillA

45:57.860 --> 45:58.860
它要用到这个数据

45:58.860 --> 45:59.860
它里边要用到CTX1

45:59.860 --> 46:01.860
为什么它要用到CTX1

46:01.860 --> 46:02.860
因为我们这里写的

46:02.860 --> 46:04.860
写的就是CTX1

46:04.860 --> 46:06.860
所以说它写什么就用什么

46:06.860 --> 46:07.860
跟之前什么

46:07.860 --> 46:08.860
究竟覆盖

46:08.860 --> 46:09.860
扯不到什么关系了

46:09.860 --> 46:10.860
对吧

46:10.860 --> 46:11.860
我用啥就是啥

46:11.860 --> 46:12.860
我要用这个就是这个

46:13.860 --> 46:16.860
我这里肯定是用的是CTX1的

46:16.860 --> 46:17.860
那么这里

46:17.860 --> 46:18.860
我们再给它提供一些数据

46:18.860 --> 46:20.860
我这里就瞎写了

46:20.860 --> 46:21.860
随便写了

46:21.860 --> 46:22.860
提供一个对象

46:22.860 --> 46:23.860
提供一个对象

46:23.860 --> 46:26.860
A就是数字

46:26.860 --> 46:27.860
789

46:27.860 --> 46:28.860
789

46:28.860 --> 46:29.860
B是一个支付串

46:29.860 --> 46:31.860
C是一个支付串

46:31.860 --> 46:32.860
Hello

46:32.860 --> 46:34.860
我又给它提供了一个上下文

46:34.860 --> 46:36.860
你看一下变成这种结构了

46:36.860 --> 46:37.860
A那是一个数字

46:37.860 --> 46:38.860
789

46:38.860 --> 46:41.860
C那是一个Hello

46:41.860 --> 46:43.860
现在不用去你写这些数据了

46:43.860 --> 46:45.860
不用你写了

46:45.860 --> 46:49.860
不用去写写什么属性类型了

46:49.860 --> 46:50.860
ABC

46:50.860 --> 46:52.860
目前写成这么一种结构

46:52.860 --> 46:54.860
那么在ChillB里边

46:54.860 --> 46:55.860
它用哪个上下文

46:55.860 --> 46:56.860
用的是哪个数据

46:56.860 --> 46:57.860
跟什么究竟原则

46:57.860 --> 46:58.860
没有什么关系

46:58.860 --> 46:59.860
在ChillB里边

46:59.860 --> 47:00.860
你看一下

47:00.860 --> 47:02.860
目前ChillB的数据

47:02.860 --> 47:03.860
是不是还是这里的数据

47:03.860 --> 47:05.860
为什么还是这里的数据

47:05.860 --> 47:06.860
你看ChillB是怎么写的

47:06.860 --> 47:09.860
是用的是上下文1的消费者

47:09.860 --> 47:10.860
你用的是哪个上下文

47:10.860 --> 47:12.860
你用哪个上下文

47:12.860 --> 47:13.860
你看看

47:13.860 --> 47:15.860
现在是不是结构非常非常明确

47:15.860 --> 47:16.860
我用的是这个上下文

47:16.860 --> 47:18.860
我就用这个上下文

47:18.860 --> 47:20.860
那如果我要用另外一个上下文

47:20.860 --> 47:21.860
那比如说

47:21.860 --> 47:22.860
刚才有同学说

47:22.860 --> 47:23.860
写那个

47:23.860 --> 47:24.860
写静态属性

47:24.860 --> 47:26.860
content type

47:26.860 --> 47:27.860
content是type

47:27.860 --> 47:28.860
那你这里是不是还是要给

47:28.860 --> 47:29.860
要么给它

47:29.860 --> 47:30.860
要么给它

47:30.860 --> 47:31.860
你用的是哪一个

47:31.860 --> 47:33.860
content就指向哪一个

47:33.860 --> 47:34.860
就指向哪一个

47:34.860 --> 47:35.860
但是这种写法

47:35.860 --> 47:37.860
它不能适用于多个上下文

47:37.860 --> 47:39.860
如果我要用多个上下文的话

47:39.860 --> 47:40.860
我这个上下文用一点数据

47:40.860 --> 47:41.860
那个上下文用一点数据

47:41.860 --> 47:43.860
那么这种写法就办不到了

47:43.860 --> 47:44.860
这种写法只能用一个

47:44.860 --> 47:45.860
上下文的数据

47:45.860 --> 47:46.860
好 那么我们看一下

47:46.860 --> 47:47.860
这里

47:47.860 --> 47:48.860
我们可以用多个

47:48.860 --> 47:49.860
上下文的数据

47:49.860 --> 47:51.860
那么这是我们用的是ctx1

47:51.860 --> 47:52.860
对吧

47:52.860 --> 47:54.860
那么如果我们想用ctx2的数据

47:54.860 --> 47:55.860
不要说了

47:55.860 --> 47:56.860
咱们继续写

47:56.860 --> 47:58.860
后边我们这里

47:58.860 --> 48:00.860
写了这么一个

48:01.860 --> 48:02.860
fragment

48:02.860 --> 48:03.860
写个fragment

48:03.860 --> 48:04.860
这个代码片段

48:04.860 --> 48:05.860
这里有个P元数

48:05.860 --> 48:06.860
不要说了

48:06.860 --> 48:08.860
咱们还有个P元数

48:08.860 --> 48:10.860
这里面我们想用ctx2

48:10.860 --> 48:12.860
ctx2里面的数据

48:12.860 --> 48:13.860
怎么办呢

48:13.860 --> 48:15.860
所以又来ctx2叫什么

48:15.860 --> 48:16.860
Consumer

48:16.860 --> 48:17.860
对不对

48:17.860 --> 48:19.860
那里面你是不是提供了

48:19.860 --> 48:20.860
一个数据了

48:20.860 --> 48:21.860
对不对

48:21.860 --> 48:22.860
vama

48:22.860 --> 48:23.860
我们换一个名字

48:23.860 --> 48:24.860
避免冲突

48:24.860 --> 48:25.860
那么这里

48:25.860 --> 48:27.860
我给你返回一个逐渐

48:27.860 --> 48:28.860
不是逐渐 返回一个元数

48:28.860 --> 48:30.860
这是来自于

48:30.860 --> 48:34.860
来自于ctx2的数据

48:34.860 --> 48:36.860
然后s是啥

48:36.860 --> 48:38.860
s来自于var.a

48:38.860 --> 48:40.860
然后C是啥

48:40.860 --> 48:42.860
C来自于var.c

48:42.860 --> 48:44.860
对吧

48:44.860 --> 48:45.860
没问题吧

48:45.860 --> 48:47.860
我们这里要返回一个逐渐

48:47.860 --> 48:50.300
这样子吧

48:50.300 --> 48:52.300
我这样返回

48:52.300 --> 48:54.300
返回这么一个逐渐

48:54.300 --> 48:56.300
你看我想用哪个数据

48:56.300 --> 48:58.300
用哪个数据

48:58.300 --> 48:59.300
保存

48:59.300 --> 49:00.300
你看一下

49:01.300 --> 49:02.300
既可以拿到

49:02.300 --> 49:03.300
上一个上下文的东西

49:03.300 --> 49:06.300
又可以拿到ctx2的数据

49:06.300 --> 49:07.300
都可以拿到

49:07.300 --> 49:08.300
对吧

49:08.300 --> 49:09.300
你看互不干擾

49:09.300 --> 49:10.300
对吧

49:10.300 --> 49:11.300
所以逻辑性比

49:11.300 --> 49:13.300
以前要清晰很多了

49:13.300 --> 49:14.300
以前很混乱的

49:14.300 --> 49:15.300
我什么究竟原则

49:15.300 --> 49:16.300
去拿到覆盖

49:16.300 --> 49:17.300
什么乱七八糟的

49:17.300 --> 49:18.300
很混乱的

49:18.300 --> 49:19.300
那么现在就非常明确了

49:19.300 --> 49:20.300
你要用哪个上下文

49:20.300 --> 49:22.300
去拿上下文的数据

49:22.300 --> 49:24.300
你要用哪个就能去拿哪个

49:24.300 --> 49:25.300
这就是一个生产者

49:25.300 --> 49:26.300
消费者模式

49:26.300 --> 49:28.300
这是一个非常

49:28.300 --> 49:30.300
你们以后会学习

49:30.300 --> 49:31.300
设计模式

49:31.300 --> 49:32.300
学习设计模式的时候

49:32.300 --> 49:33.300
就会学习这种模式

49:33.300 --> 49:34.300
生产者消费者

49:34.300 --> 49:36.300
生产者就是 provider

49:36.300 --> 49:37.300
给你提供数据

49:37.300 --> 49:39.300
concealment

49:39.300 --> 49:41.300
从数据提供者的那里去拿数据

49:41.300 --> 49:43.300
你从哪个提供者里面拿的

49:43.300 --> 49:44.300
拿到的

49:44.300 --> 49:46.300
就是哪个提供者的数据

49:47.300 --> 49:49.300
它就不会出现混乱了

49:49.300 --> 49:50.300
这是目前

49:50.300 --> 49:52.300
我们新的API里面

49:52.300 --> 49:53.300
使用的做法

49:55.300 --> 49:56.300
好好看一下

49:58.300 --> 49:59.300
大家最好跟着写一下

49:59.300 --> 50:00.300
写完了过后

50:00.300 --> 50:02.300
我们再说另外一个问题

50:02.300 --> 50:03.300
最后一个问题了

50:03.300 --> 50:06.300
就是一个非常非常小的细节

50:06.300 --> 50:07.300
这个细节

50:07.300 --> 50:10.300
很多人可能会容易忽略掉

50:10.300 --> 50:12.300
什么细节呢

50:12.300 --> 50:13.300
记录一下

50:13.300 --> 50:15.300
就是说注意细节

50:15.300 --> 50:17.610
就是说

50:17.610 --> 50:18.610
如果

50:20.610 --> 50:23.610
上下文提供者

50:23.610 --> 50:24.610
就是什么

50:24.610 --> 50:25.610
就是 provider 对吧

50:25.610 --> 50:28.610
就是 context 里面的属性 provider

50:30.610 --> 50:32.610
中的歪流属性

50:33.610 --> 50:35.610
发生变化

50:36.610 --> 50:37.610
会导致

50:38.610 --> 50:40.610
该上下文

50:41.610 --> 50:45.610
提供者的所有后代元素

50:46.610 --> 50:47.610
全部更新

50:47.610 --> 50:49.610
全部重新渲染

50:49.610 --> 50:54.180
只要这个歪流属性发生变化

50:54.180 --> 50:55.180
你看这就是这

50:56.180 --> 50:58.180
歪流属性发生变化

50:58.180 --> 51:00.180
会导致后边的所有的组件

51:00.180 --> 51:02.180
它里面不是要传一些纸元素吗

51:02.180 --> 51:04.180
等于纸元素全部要重新渲染

51:04.180 --> 51:05.180
无论

51:06.180 --> 51:12.180
该纸元素是否有优化

51:12.180 --> 51:13.180
怎么优化呢

51:13.180 --> 51:16.180
就是我们不之前不是学过一个生命周期函数吗

51:16.180 --> 51:17.180
should

51:17.180 --> 51:18.180
看一下吧

51:18.180 --> 51:20.180
生命周期函数

51:20.180 --> 51:23.180
无论是就版还是新版里面都有

51:23.180 --> 51:24.180
生命周期函数

51:24.180 --> 51:25.180
生命周期函数哪一个

51:25.180 --> 51:26.180
就这个

51:27.180 --> 51:28.180
性能优化点

51:28.180 --> 51:29.180
should component update

51:29.180 --> 51:30.180
就这个函数

51:30.180 --> 51:31.180
无论这个函数

51:33.180 --> 51:34.180
就是无论

51:35.180 --> 51:36.180
这个函数

51:39.180 --> 51:40.180
函数

51:40.180 --> 51:43.680
返回什么结果

51:43.680 --> 51:44.680
我们之前说过

51:44.680 --> 51:45.680
这个函数返回 false 的话

51:45.680 --> 51:47.680
它就不会重新渲染

51:47.680 --> 51:48.680
但是

51:48.680 --> 51:49.680
如果

51:49.680 --> 51:51.680
你是把它掏在上下文里边了

51:51.680 --> 51:54.680
上下文的歪流值一旦发生变化

51:55.680 --> 51:56.680
那么它里边

51:56.680 --> 51:58.680
所有东西一定要重新渲染

51:58.680 --> 51:59.680
因为它认为

51:59.680 --> 52:00.680
它里边的东西

52:00.680 --> 52:02.680
你虽然说属性可能没变

52:02.680 --> 52:03.680
状态可能没变

52:03.680 --> 52:04.680
但是上下文变了

52:04.680 --> 52:05.680
那如果我不重新渲染的话

52:05.680 --> 52:06.680
那上下文怎么

52:06.680 --> 52:08.680
怎么又知道新的上下文了

52:08.680 --> 52:11.680
所以说它会强制重新渲染

52:11.680 --> 52:13.990
咱们来举个例子

52:13.990 --> 52:15.990
再复制一个

52:17.990 --> 52:18.990
就什么例子呢

52:19.990 --> 52:20.990
就一个上下文

52:20.990 --> 52:22.990
我这里只需要一个就行了

52:22.990 --> 52:26.070
这个吧

52:26.070 --> 52:27.070
我这样子

52:27.070 --> 52:28.070
还是this child

52:28.070 --> 52:30.070
现在就不要这个玩意

52:30.070 --> 52:31.070
不要这个玩意了

52:33.510 --> 52:35.510
然后我们把这些都简化一下

52:35.510 --> 52:36.510
child B

52:37.510 --> 52:39.510
主要是看一下child B

52:42.340 --> 52:43.340
child B是它的后代元素

52:43.340 --> 52:44.340
对不对

52:44.340 --> 52:45.340
child B里边

52:45.340 --> 52:47.340
我们也不只搞这些花里福哨的了

52:47.340 --> 52:48.340
static

52:49.340 --> 52:50.340
context type

52:50.340 --> 52:51.340
context

52:53.340 --> 52:54.340
这边我们就直接

52:56.340 --> 52:57.340
直接输出

52:57.340 --> 53:01.970
直接输出一个结果

53:01.970 --> 53:02.970
直接输出一个结果

53:02.970 --> 53:03.970
这个结果就是

53:03.970 --> 53:04.970
A为什么呢

53:05.970 --> 53:06.970
this context

53:07.970 --> 53:09.970
context.a

53:09.970 --> 53:11.970
然后 B是什么呢

53:11.970 --> 53:14.970
this context.b

53:15.970 --> 53:16.970
就把输出玩意了

53:16.970 --> 53:18.970
也不做什么按钮了

53:18.970 --> 53:19.970
我们这里输出

53:19.970 --> 53:20.970
render

53:20.970 --> 53:22.970
child B

53:25.970 --> 53:26.970
render

53:26.970 --> 53:27.970
就表示我们渲染了

53:27.970 --> 53:29.970
表示我们这里渲染了

53:29.970 --> 53:30.970
好

53:30.970 --> 53:31.970
然后我们在这里

53:31.970 --> 53:32.970
child B里边

53:32.970 --> 53:34.970
给它写一个优化函数

53:34.970 --> 53:36.970
should component

53:36.970 --> 53:38.970
update

53:38.970 --> 53:40.970
就这么个函数

53:40.970 --> 53:41.970
这个函数里边

53:41.970 --> 53:43.970
我们直接该返回force

53:43.970 --> 53:45.970
不允许你重新渲染

53:45.970 --> 53:46.970
为了优化

53:46.970 --> 53:47.970
当然我们实际情况下

53:47.970 --> 53:48.970
肯定要做判断

53:48.970 --> 53:49.970
做各种各样的判断

53:49.970 --> 53:51.970
然后让你

53:51.970 --> 53:53.970
不要重新渲染

53:54.970 --> 53:56.970
那么我这里直接返回force

53:56.970 --> 53:58.970
现在我们这样子

53:59.970 --> 54:00.970
在provider里边

54:00.970 --> 54:01.970
我们来看一下

54:02.970 --> 54:03.970
保存

54:03.970 --> 54:04.970
你看我这点按钮过后

54:04.970 --> 54:05.970
是不是要改变状态

54:05.970 --> 54:06.970
对吧

54:06.970 --> 54:07.970
改变状态

54:07.970 --> 54:08.970
那么现在我们来看一下

54:08.970 --> 54:10.970
改变状态有没有重新渲染

54:10.970 --> 54:11.970
点击

54:11.970 --> 54:12.970
是不是还是要重新渲染

54:12.970 --> 54:13.970
对吧

54:13.970 --> 54:15.970
child B是不是还是要重新渲染

54:15.970 --> 54:16.970
没问题吧

54:16.970 --> 54:19.970
它还是会重新渲染

54:19.970 --> 54:21.970
还是要重新渲染

54:21.970 --> 54:23.970
那么这是怎么回事呢

54:23.970 --> 54:24.970
这怎么回事呢

54:24.970 --> 54:26.970
那如果

54:26.970 --> 54:28.970
我这里用的不是上下文的话

54:28.970 --> 54:29.970
它肯定不会重新渲染

54:29.970 --> 54:30.970
因为我这里

54:30.970 --> 54:32.970
should component update

54:32.970 --> 54:33.970
是为了force

54:33.970 --> 54:34.970
我们这里运行一下

54:34.970 --> 54:35.970
输出

54:35.970 --> 54:37.970
优化

54:37.970 --> 54:39.970
运行了

54:39.970 --> 54:40.970
优化

54:40.970 --> 54:42.970
你看我们这里点击

54:43.970 --> 54:45.970
它甚至连这个函数都没有运行

54:45.970 --> 54:47.970
它是直接绕过这个函数

54:47.970 --> 54:49.970
来进行直接重新渲染

54:49.970 --> 54:51.970
它绕过了这个函数直接重新渲染

54:52.970 --> 54:53.970
那么这种方式

54:53.970 --> 54:54.970
其实我们后面会学习

54:54.970 --> 54:56.970
叫做强制更新

54:56.970 --> 54:57.970
强制更新的话

54:57.970 --> 54:58.970
它是不会

54:58.970 --> 54:59.970
它是不会运行这个函数的

54:59.970 --> 55:01.970
是不会运行这个函数的

55:01.970 --> 55:03.970
那么这个函数都没有运行

55:03.970 --> 55:04.970
如果说

55:04.970 --> 55:06.970
如果我们这里用的

55:06.970 --> 55:08.970
比方说我们直接用这个敲的臂嘛

55:08.970 --> 55:09.970
绕过这个敲的臂

55:09.970 --> 55:10.970
这个敲的臂对我们来说

55:10.970 --> 55:11.970
也没什么用

55:11.970 --> 55:12.970
绕过这个敲的臂

55:12.970 --> 55:13.970
写简单一点

55:13.970 --> 55:14.970
敲的臂

55:14.970 --> 55:17.970
比方说我们直接用敲的臂

55:17.970 --> 55:20.970
然后不用这个上下文了

55:20.970 --> 55:21.970
不用这个上下文

55:21.970 --> 55:22.970
直接用这个敲的臂

55:22.970 --> 55:24.970
给它提供属相

55:24.970 --> 55:25.970
你看一下

55:25.970 --> 55:26.970
敲的臂

55:27.970 --> 55:29.970
它里边属相

55:29.970 --> 55:30.970
来自于状态里边

55:30.970 --> 55:31.970
把它展开

55:31.970 --> 55:32.970
这是第一次

55:32.970 --> 55:33.970
把状态展开

55:33.970 --> 55:34.970
给它属相

55:34.970 --> 55:35.970
把属性给它复制

55:35.970 --> 55:37.970
把属性给它复制

55:37.970 --> 55:39.970
然后我们这里点击

55:39.970 --> 55:40.970
还是一样的

55:40.970 --> 55:41.970
外面写个DIV

55:41.970 --> 55:46.540
然后这里写个按钮

55:46.540 --> 55:48.540
点击了改变属性的臂

55:48.540 --> 55:49.540
你看一下

55:49.540 --> 55:50.540
这样子的根据

55:50.540 --> 55:52.540
我们以前的做法

55:52.540 --> 55:53.540
改变

55:53.540 --> 55:54.540
点击过后

55:54.540 --> 55:55.540
改变状态的臂

55:55.540 --> 55:57.540
你看一下

55:58.540 --> 56:01.540
这里就不能用状态了

56:01.540 --> 56:11.750
应该用属性

56:13.750 --> 56:14.750
我们用以前的做法

56:14.750 --> 56:15.750
就是传递属性

56:15.750 --> 56:17.750
把属性给它传过来

56:17.750 --> 56:18.750
这是CHELL的臂

56:18.750 --> 56:19.750
把属性传过来

56:19.750 --> 56:21.750
显示属性的臂

56:21.750 --> 56:22.750
咱们来看一下

56:22.750 --> 56:24.750
这个东西不要了

56:24.750 --> 56:26.750
保存看一下

56:26.750 --> 56:27.750
点击

56:27.750 --> 56:28.750
是不是没有

56:28.750 --> 56:29.750
看运行的优化

56:29.750 --> 56:30.750
它返回到FORCE

56:31.750 --> 56:32.750
返回到FORCE

56:32.750 --> 56:33.750
所以说它没有渲染

56:33.750 --> 56:35.750
尽管属性变化了

56:35.750 --> 56:36.750
尽管给它传递的属性

56:36.750 --> 56:38.750
你看是不是传递的属性变化了

56:38.750 --> 56:39.750
点击按钮过后

56:39.750 --> 56:40.750
你传递的属性

56:40.750 --> 56:41.750
是不是发生了变化

56:41.750 --> 56:42.750
对不对

56:42.750 --> 56:44.750
传递的属性发生了变化

56:44.750 --> 56:45.750
因为我这里属性就是

56:45.750 --> 56:47.750
把STATE给它的

56:47.750 --> 56:48.750
属性发生变化的话

56:48.750 --> 56:49.750
那么

56:50.750 --> 56:51.750
它会运行这个函数

56:51.750 --> 56:52.750
如果这个函数返回FORCE

56:52.750 --> 56:53.750
那么就表示

56:53.750 --> 56:54.750
不会重新宣传

56:54.750 --> 56:56.750
你看这个生命周期图

56:56.750 --> 56:57.750
运行到FORCE

56:57.750 --> 56:58.750
它不会重新宣传

56:58.750 --> 57:00.750
但是如果用的是上下纹

57:00.750 --> 57:01.750
再复制一下

57:01.750 --> 57:03.750
如果用的是上下纹

57:03.750 --> 57:04.750
那就不一样了

57:05.750 --> 57:12.200
如果用的是上下纹就不一样了

57:12.200 --> 57:14.200
又把它换成上下纹

57:14.200 --> 57:16.200
如果用的是上下纹就不一样了

57:16.200 --> 57:17.200
上下纹它发现

57:17.200 --> 57:19.200
发现变化之后

57:19.200 --> 57:20.200
发现这个东西变化之后

57:20.200 --> 57:22.200
那么它会

57:22.200 --> 57:24.200
重新进行宣传

57:24.200 --> 57:26.200
一定是强制宣传的

57:26.200 --> 57:27.200
你看强制宣传

57:27.200 --> 57:29.200
都没有运行那个

57:29.200 --> 57:30.200
SUIT COMPOINT

57:30.200 --> 57:31.200
update

57:31.200 --> 57:32.200
都没有运行这个函数

57:32.200 --> 57:33.200
那么这怎么回事呢

57:33.200 --> 57:34.200
我们后边会说

57:34.200 --> 57:35.200
这叫强制更新

57:35.200 --> 57:37.200
它会进行强制更新

57:38.200 --> 57:39.200
这是这么一个细节

57:39.200 --> 57:40.200
大家注意一下

57:40.200 --> 57:41.200
大家注意一下

57:43.200 --> 57:45.200
由于这个细节存在

57:45.200 --> 57:48.200
它可能会导致这么一个问题

57:48.200 --> 57:49.200
就是说

57:49.200 --> 57:51.200
如果我这个属性

57:51.200 --> 57:52.200
它没有变化

57:54.200 --> 57:55.200
比方说我这样子写的

57:56.200 --> 57:58.200
我这个属性它没有变化

57:58.200 --> 57:59.200
跟之前的一样

57:59.200 --> 58:01.200
跟之前的一样

58:02.200 --> 58:04.200
那么这个属性没有变化

58:04.200 --> 58:05.200
这里是不是没有变化

58:05.200 --> 58:06.200
对吧

58:06.200 --> 58:07.200
这里是不是没有变化

58:07.200 --> 58:08.200
那么现在你看

58:11.200 --> 58:13.200
是不是也导致了重新宣传

58:13.200 --> 58:14.200
对吧

58:14.200 --> 58:16.200
它也导致了重新宣传

58:16.200 --> 58:17.200
看到没

58:17.200 --> 58:18.200
为什么呢

58:18.200 --> 58:21.200
因为我们这个状态

58:21.200 --> 58:23.200
每一次set state的时候

58:23.200 --> 58:25.200
得到的都是一个全新的对象

58:25.200 --> 58:27.200
都是把之前的对象覆盖掉

58:27.200 --> 58:29.200
得到一个全新的对象

58:29.200 --> 58:31.200
就不再是之前的对象了

58:31.200 --> 58:33.200
得到的是一个全新的对象

58:34.200 --> 58:37.200
所以我看一下这个东西怎么来

58:38.200 --> 58:41.200
怎么来验证了

58:41.200 --> 58:43.200
就要给大家验证一下

58:43.200 --> 58:44.200
就是每一次

58:44.200 --> 58:45.200
调整set state

58:45.200 --> 58:47.200
得到的都是一个全新的对象

58:47.200 --> 58:48.200
咱们这样子来吧

58:48.200 --> 58:50.200
这样子来验证一下

58:51.200 --> 58:52.200
data是

58:52.200 --> 58:54.200
我们写个数组

58:54.200 --> 58:56.200
这个数组里边有这么一个对象

58:56.200 --> 58:57.200
有这么一个对象

58:57.200 --> 58:58.200
它是个数组

58:58.200 --> 59:00.200
然后我们这个state一开始

59:00.200 --> 59:02.200
等于这个数组的第一下

59:02.200 --> 59:04.200
等于这个数组的第一下

59:04.200 --> 59:05.200
data是

59:05.200 --> 59:06.200
数组的0

59:06.200 --> 59:07.200
这个没问题吧

59:07.200 --> 59:09.200
等于这个数组的第一下

59:10.200 --> 59:11.200
一开始等于这个数组的第一下

59:11.200 --> 59:13.200
这个没什么问题吧

59:14.200 --> 59:15.200
把这个状态的

59:15.200 --> 59:16.200
一开始初始状态

59:16.200 --> 59:18.200
放到这个数组里边

59:18.200 --> 59:19.200
然后把这个数组的第一下

59:19.200 --> 59:20.200
复制给这个state

59:20.200 --> 59:21.200
接下来

59:21.200 --> 59:23.200
我们每一次改变state

59:23.200 --> 59:24.200
你看这里是不是改变

59:24.200 --> 59:26.200
不是一个回调函数吗

59:26.200 --> 59:28.200
我们在回调函数里边

59:28.200 --> 59:30.200
每一次改变完了之后

59:30.200 --> 59:32.200
改变完了之后

59:32.200 --> 59:33.200
我用一个给它加

59:33.200 --> 59:34.200
往那个数组里边加一下

59:34.200 --> 59:35.200
data是

59:35.200 --> 59:36.200
push

59:36.200 --> 59:37.200
state

59:38.200 --> 59:39.200
也就是说这个

59:39.200 --> 59:40.200
data是这个数组里边

59:40.200 --> 59:41.200
保存的是

59:41.200 --> 59:43.200
每一次状态发生变化的时候

59:43.200 --> 59:44.200
它都把这个状态

59:44.200 --> 59:45.200
保存到个数组里边

59:45.200 --> 59:47.200
这是一开始的状态

59:47.200 --> 59:48.200
然后我们改变了状态

59:48.200 --> 59:49.200
虽然我啥都没改变

59:49.200 --> 59:50.200
对吧

59:50.200 --> 59:51.200
我也把它push到数组里边

59:51.200 --> 59:53.200
然后我们再得输出

59:53.200 --> 59:55.200
数组里边的东西是不是一样的

59:55.200 --> 59:57.200
看那个数组的0

59:57.200 --> 59:58.200
和这个数组的第1项

59:58.200 --> 59:59.200
是不是一样的

01:00:01.200 --> 01:00:02.200
看是不是两个项等的

01:00:02.200 --> 01:00:03.200
保存

01:00:03.200 --> 01:00:04.200
你看一下

01:00:04.200 --> 01:00:05.200
点击

01:00:05.200 --> 01:00:06.200
是不是force

01:00:06.200 --> 01:00:07.200
得到的是force

01:00:07.200 --> 01:00:08.200
说明什么

01:00:08.200 --> 01:00:11.200
你只要雕用了set state

01:00:11.200 --> 01:00:13.200
哪怕你什么都没有改变

01:00:13.200 --> 01:00:15.200
你得到的是不是个全新的对象

01:00:15.200 --> 01:00:18.200
而你只要是一个全新的对象

01:00:18.200 --> 01:00:19.200
注意

01:00:19.200 --> 01:00:21.200
你只要是一个全新的对象

01:00:21.200 --> 01:00:22.200
那么对于

01:00:22.200 --> 01:00:24.200
上下文而言

01:00:24.200 --> 01:00:25.200
它比较的时候

01:00:25.200 --> 01:00:26.200
它是用引用比较的

01:00:26.200 --> 01:00:28.200
比较的是对象的引用

01:00:28.200 --> 01:00:29.200
是不是相同

01:00:29.200 --> 01:00:31.200
如果引用不相同的话

01:00:31.200 --> 01:00:33.200
那么它就认为发生了变化

01:00:36.200 --> 01:00:38.200
如果是引用不相同

01:00:38.200 --> 01:00:39.200
那么这里就是

01:00:39.200 --> 01:00:40.200
上下文发生变化

01:00:40.200 --> 01:00:42.200
什么叫发生变化

01:00:42.200 --> 01:00:44.200
就是地址不一样

01:00:44.200 --> 01:00:45.200
当然原式内形的话

01:00:45.200 --> 01:00:46.200
就比较原式内形

01:00:46.200 --> 01:00:47.200
对吧

01:00:47.200 --> 01:00:48.200
它实际上是用怎么来比较的

01:00:48.200 --> 01:00:49.200
它实际上是用objects

01:00:49.200 --> 01:00:51.200
一直来比较的

01:00:51.200 --> 01:00:53.200
它是用这个函数来比较的

01:00:53.200 --> 01:00:55.200
那么用它来比较的时候

01:00:55.200 --> 01:00:57.200
它发现两个对象的地址不一样

01:00:57.200 --> 01:00:58.200
于是它认为

01:00:58.200 --> 01:00:59.200
百六指发生了变化

01:00:59.200 --> 01:01:00.200
于是就强制更新了

01:01:00.200 --> 01:01:01.200
所以说我们这里

01:01:01.200 --> 01:01:02.200
会看到

01:01:02.200 --> 01:01:03.200
点击这个

01:01:03.200 --> 01:01:04.200
你看每一次都

01:01:04.200 --> 01:01:05.200
CHELL的B都RENDER了

01:01:05.200 --> 01:01:06.200
强制更新了

01:01:06.200 --> 01:01:08.200
每一次都强制更新了

01:01:10.200 --> 01:01:11.200
因为

01:01:11.200 --> 01:01:13.200
当我们调用setState之后

01:01:13.200 --> 01:01:15.200
当我们调用这个玩意之后

01:01:15.200 --> 01:01:16.200
虽然说啥都没变

01:01:16.200 --> 01:01:17.200
但是State

01:01:17.200 --> 01:01:18.200
又已经是一个

01:01:18.200 --> 01:01:20.200
完整的全新的对象了

01:01:20.200 --> 01:01:22.200
不再是之前的对象

01:01:23.200 --> 01:01:24.200
那么这样子

01:01:25.200 --> 01:01:27.200
可能不太利于

01:01:27.200 --> 01:01:28.200
性能的优化

01:01:28.200 --> 01:01:29.200
我们之前做了一些组建

01:01:29.200 --> 01:01:31.200
它可能做了一些性能优化

01:01:31.200 --> 01:01:32.200
设置了这个函数

01:01:32.200 --> 01:01:34.200
设置了这个性能优化

01:01:34.200 --> 01:01:36.200
那么你这样子写

01:01:36.200 --> 01:01:37.200
导致个性能优化

01:01:37.200 --> 01:01:38.200
就直接失销了

01:01:38.200 --> 01:01:39.200
直接失销了

01:01:39.200 --> 01:01:40.200
那么怎么办呢

01:01:40.200 --> 01:01:42.200
我们可以这样子来写

01:01:42.200 --> 01:01:43.200
可以这样子来写

01:01:43.200 --> 01:01:44.200
怎么写呢

01:01:44.200 --> 01:01:45.200
就是说

01:01:45.200 --> 01:01:47.200
我们把这个数据

01:01:47.200 --> 01:01:49.200
把这个valid的数据

01:01:49.200 --> 01:01:50.200
放到一个

01:01:50.200 --> 01:01:52.200
对象本身

01:01:53.200 --> 01:01:55.200
应该不变化的时候

01:01:55.200 --> 01:01:56.200
它就不变化

01:01:56.200 --> 01:01:58.200
该变化的时候就变化了

01:01:58.200 --> 01:02:00.200
放到这么一个对象里边

01:02:00.200 --> 01:02:01.200
那么怎么来放呢

01:02:02.200 --> 01:02:04.200
你不能这样子写

01:02:04.200 --> 01:02:05.200
有的人说

01:02:05.200 --> 01:02:06.200
能不能这样子写

01:02:06.200 --> 01:02:08.200
我附着一个新的对象

01:02:08.200 --> 01:02:09.200
把setState展开

01:02:09.200 --> 01:02:10.200
这样子也不行

01:02:10.200 --> 01:02:11.200
你每次还不是

01:02:11.200 --> 01:02:12.200
一个新的对象

01:02:12.200 --> 01:02:13.200
每次渲染的时候

01:02:13.200 --> 01:02:14.200
你看对象字面量

01:02:14.200 --> 01:02:15.200
两个大括号

01:02:15.200 --> 01:02:16.200
是不是新建了个对象

01:02:16.200 --> 01:02:18.200
每次还是一个新的对象

01:02:18.200 --> 01:02:20.200
它并没有发生什么变化

01:02:22.200 --> 01:02:23.200
你看还不是运行了

01:02:23.200 --> 01:02:24.200
Render

01:02:27.200 --> 01:02:29.200
那么这个时候你该怎么办呢

01:02:29.200 --> 01:02:30.200
这个时候

01:02:30.200 --> 01:02:31.200
如果你要处理

01:02:31.200 --> 01:02:32.200
这个新能优化的话

01:02:32.200 --> 01:02:34.200
你可以用这种方式来处理

01:02:34.200 --> 01:02:36.200
你把这些数据

01:02:37.200 --> 01:02:39.200
我们就不要这个了吧

01:02:39.200 --> 01:02:40.200
把注射料

01:02:40.200 --> 01:02:41.200
放着吧

01:02:41.200 --> 01:02:42.200
注射料

01:02:42.200 --> 01:02:44.200
再复制一个

01:02:45.200 --> 01:02:46.200
我们现在看一下

01:02:46.200 --> 01:02:47.200
如果要优化这一块的话

01:02:47.200 --> 01:02:48.200
该怎么来做

01:02:48.200 --> 01:02:49.200
我们把这个数据

01:02:49.200 --> 01:02:51.200
还是写到State里面

01:02:51.200 --> 01:02:53.200
但是我给它套一层

01:02:54.200 --> 01:02:55.200
给它套一层

01:02:55.200 --> 01:02:56.200
比方说context

01:02:56.200 --> 01:02:58.200
这是我们上下文里面的数据

01:02:58.200 --> 01:02:59.200
上下文里面的数据

01:02:59.200 --> 01:03:00.200
我给它套一层

01:03:00.200 --> 01:03:02.200
把这个数据套到这里面

01:03:02.200 --> 01:03:03.200
套到这里面

01:03:03.200 --> 01:03:04.200
为什么要套一层呢

01:03:04.200 --> 01:03:05.200
是因为

01:03:05.200 --> 01:03:06.200
这个State本身的对象

01:03:06.200 --> 01:03:08.200
它是不断的发生变化的

01:03:08.200 --> 01:03:09.200
你每一次调用State

01:03:09.200 --> 01:03:10.200
它必定发生

01:03:10.200 --> 01:03:11.200
这个对象

01:03:11.200 --> 01:03:12.200
必定是一个新的对象

01:03:12.200 --> 01:03:13.200
你到时候

01:03:13.200 --> 01:03:14.200
把这个State给它的话

01:03:14.200 --> 01:03:15.200
它就要出问题

01:03:15.200 --> 01:03:16.200
因为每次都是个新的对象

01:03:16.200 --> 01:03:17.200
每次都是个新的对象

01:03:17.200 --> 01:03:18.200
那这里Value只能发现

01:03:18.200 --> 01:03:19.200
它比较的时候

01:03:19.200 --> 01:03:20.200
地址不一样

01:03:20.200 --> 01:03:21.200
它就认为它变化了

01:03:21.200 --> 01:03:22.200
实际上可能啥都没变

01:03:22.200 --> 01:03:24.200
它就认为它变化了

01:03:24.200 --> 01:03:26.200
所以说它会导致这样的问题

01:03:27.200 --> 01:03:28.200
那么这里

01:03:28.200 --> 01:03:29.200
我们就可以

01:03:29.200 --> 01:03:30.200
在这里这样子写

01:03:31.200 --> 01:03:32.200
这个Value呢

01:03:32.200 --> 01:03:34.200
来自于Zestate的CTX

01:03:34.200 --> 01:03:37.200
来自于这里面

01:03:38.200 --> 01:03:39.200
没问题吧

01:03:39.200 --> 01:03:41.200
我们把这个对象给它

01:03:42.200 --> 01:03:43.200
然后我们改变的时候

01:03:43.200 --> 01:03:44.200
我们这样子改变

01:03:44.200 --> 01:03:45.200
改变的时候

01:03:45.200 --> 01:03:47.200
直接不写这个了

01:03:48.200 --> 01:03:49.200
改变的时候

01:03:49.200 --> 01:03:50.200
那么这个时候

01:03:50.200 --> 01:03:51.200
我啥都

01:03:51.200 --> 01:03:53.200
我就要传一个空对象进去

01:03:53.200 --> 01:03:55.200
传空对象进去

01:03:55.200 --> 01:03:57.200
它只会覆盖掉这个

01:03:58.200 --> 01:03:59.200
State本身变成一个新的对象了

01:03:59.200 --> 01:04:01.200
但是State里面的属性

01:04:01.200 --> 01:04:02.200
它是一个对象

01:04:02.200 --> 01:04:03.200
属性的地址还是一样的

01:04:03.200 --> 01:04:05.200
这个属性并没有发生变化

01:04:06.200 --> 01:04:07.200
那么相当于是我这里

01:04:07.200 --> 01:04:08.200
我这里State

01:04:08.200 --> 01:04:09.200
相当于是什么呢

01:04:09.200 --> 01:04:10.200
相当于它是State

01:04:10.200 --> 01:04:11.200
得到一个新的对象

01:04:11.200 --> 01:04:12.200
这个新的对象

01:04:13.200 --> 01:04:15.200
它还是等于之前的

01:04:15.200 --> 01:04:17.200
那个状态里面的CTX

01:04:17.200 --> 01:04:19.200
这个并没有发生变化

01:04:19.200 --> 01:04:20.200
原来这个意思吧

01:04:20.200 --> 01:04:21.200
这个地址并没有发生变化

01:04:21.200 --> 01:04:23.200
只是它这个State全新

01:04:23.200 --> 01:04:25.200
就整个改变了

01:04:25.200 --> 01:04:27.200
那么但是我给它的不是整个State

01:04:27.200 --> 01:04:28.200
给它的是什么

01:04:28.200 --> 01:04:30.200
给它的是CTX

01:04:30.200 --> 01:04:31.200
给它的是这个东西

01:04:31.200 --> 01:04:33.200
所以说这个东西并没有发生变化

01:04:33.200 --> 01:04:36.200
因此它会走一个正常的生命周期

01:04:36.200 --> 01:04:38.200
它会就会走一个正常的生命周期

01:04:38.200 --> 01:04:39.200
保存你看一下

01:04:40.200 --> 01:04:41.200
你看是不是运行了优化

01:04:41.200 --> 01:04:42.200
是不是运行了优化

01:04:42.200 --> 01:04:44.200
它就会走一个正常的生命周期

01:04:44.200 --> 01:04:45.200
它就不会强制更新了

01:04:45.200 --> 01:04:48.200
因为这个歪六指

01:04:48.200 --> 01:04:49.200
它没有发生变化

01:04:49.200 --> 01:04:51.200
这个歪六指它没有发生变化

01:04:51.200 --> 01:04:53.200
因为两个对象的地址是一样的

01:04:53.200 --> 01:04:54.200
它并没有发生变化

01:04:54.200 --> 01:04:55.200
这个歪六指

01:04:55.200 --> 01:04:57.200
因此它就会走一个正常的生命周期

01:04:57.200 --> 01:04:58.200
你该更新就更新

01:04:58.200 --> 01:04:59.200
你这里返回去

01:04:59.200 --> 01:05:01.200
那就会更新

01:05:01.200 --> 01:05:02.200
它就会更新

01:05:03.200 --> 01:05:04.200
它就会更新

01:05:04.200 --> 01:05:06.200
你这里返回Force

01:05:06.200 --> 01:05:07.200
它就不会更新

01:05:07.200 --> 01:05:10.200
那么就可以进行正常的性能优化了

01:05:10.200 --> 01:05:12.200
这是一个细节

01:05:13.200 --> 01:05:14.200
大家注意一下

01:05:14.200 --> 01:05:20.510
这是关于新的组建的API

01:05:20.510 --> 01:05:21.510
总体来说的话

01:05:21.510 --> 01:05:25.510
新的上下文的API肯定是要比

01:05:25.510 --> 01:05:28.510
旧版的简单好用的很多

01:05:28.510 --> 01:05:29.510
简单好用的很多

01:05:29.510 --> 01:05:34.510
所以说我们后边讲安逸的时候

01:05:34.510 --> 01:05:35.510
肯定是用新的API

01:05:35.510 --> 01:05:37.510
新的API必须要学会

01:05:37.510 --> 01:05:39.510
旧的API可以作为了解

01:05:39.510 --> 01:05:40.510
下来把这几课

01:05:40.510 --> 01:05:42.510
我们课了它写到了内容

01:05:42.510 --> 01:05:43.510
都去试验一下

01:05:43.510 --> 01:05:45.510
对这个API有点

01:05:45.510 --> 01:05:46.510
要有这么一个印象

01:05:46.510 --> 01:05:47.510
不然的话

01:05:47.510 --> 01:05:49.510
下几课你肯定是在听天书的

01:05:49.510 --> 01:05:50.510
不知道我来说什么

01:05:50.510 --> 01:05:51.510
你肯定是晕的

01:05:51.510 --> 01:05:53.510
所以一定要去用一下

01:05:53.510 --> 01:05:54.510
熟悉一下这个API

01:05:54.510 --> 01:05:55.510
API一定要熟悉

01:05:55.510 --> 01:05:56.510
熟悉过后下几课

01:05:56.510 --> 01:05:57.510
我们来做一个小的demo

