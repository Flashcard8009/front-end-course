WEBVTT

00:01.650 --> 00:04.650
这些课呢 咱们来说另外一个库啊

00:04.650 --> 00:07.650
叫做 Redox Promise

00:07.650 --> 00:11.650
这个库呢 其实它跟那个桑克

00:11.650 --> 00:15.650
那个库呢 有点类似啊 都是用来解决

00:15.650 --> 00:18.650
负重的问题的 也这个解决的方式呢

00:18.650 --> 00:20.650
也都是在Action这里进行处理

00:20.650 --> 00:22.650
我们之前不在Action里面写嘛 对吧

00:22.650 --> 00:25.650
在Action里面去添加一些具有负重的代码

00:25.650 --> 00:27.650
之前的桑克是怎么做的呢

00:27.650 --> 00:30.650
桑克的话 它是在这里

00:31.650 --> 00:33.650
在这里 你可以返回一个函数

00:33.650 --> 00:36.650
如果说桑克的中间键 它发现你返回的

00:36.650 --> 00:38.650
你得到了Action是一个函数的话

00:38.650 --> 00:42.650
因此呢 它会执行这个函数而不去分发这个Action

00:42.650 --> 00:45.650
是这么个意思 那么现在另外一个库呢

00:45.650 --> 00:49.650
它提供了一个另外一种思路 就是Redox Promise

00:49.650 --> 00:52.650
它也可以用于解决负重的问题

00:52.650 --> 00:55.650
也是Action创建函数 也就是Action这一块

00:55.650 --> 00:57.650
来解决这个问题

00:57.650 --> 00:59.650
这个库呢 它相对于那个

00:59.650 --> 01:02.650
我们之前学的桑克那个库来说的话

01:02.650 --> 01:04.650
它的使用量要小一些

01:04.650 --> 01:06.650
我们在NPM介绍来看一下

01:06.650 --> 01:09.650
所以说这一课呢 我把它作为扩展课成德了

01:09.650 --> 01:11.650
因为我会 因为你们以后呢

01:11.650 --> 01:13.650
可能不太会用到这个库

01:13.650 --> 01:17.650
当然呢 这里呢 为什么要讲这个库啊

01:17.650 --> 01:19.650
是因为有的 有之前有个学生

01:19.650 --> 01:22.650
有几个学生 比较少

01:22.650 --> 01:24.650
但是呢 有遇到在公司里面

01:24.650 --> 01:26.650
他们要用这个库

01:26.650 --> 01:28.650
所以说这里还是把拿出来讲一下

01:28.650 --> 01:31.650
我们来看一下Redox Sunk这个库

01:31.650 --> 01:34.650
它的周下载量的话 大概在100多万

01:34.650 --> 01:37.650
147万 周下载加载量

01:37.650 --> 01:41.650
然后Redox Promise这个库呢

01:41.650 --> 01:43.650
它的下载量少一些

01:43.650 --> 01:46.650
它的下载量好像只有几万 只有5万多

01:46.650 --> 01:48.650
所以说这个库呢 大家可以作为了解就行了

01:48.650 --> 01:50.650
如果说你们以后到公司里面

01:50.650 --> 01:52.650
遇到这个库的话 你就可以再回过头来看

01:52.650 --> 01:54.650
也非常非常简单

01:54.650 --> 01:56.650
所以说这些课呢 咱们就直接把这个库讲完

01:56.650 --> 01:58.650
反正都是扩展课程

01:58.650 --> 02:00.650
把这个库的如何去使用

02:00.650 --> 02:02.650
以及呢 如何去实现它的圆码

02:02.650 --> 02:04.650
都讲一下 非常非常简单啊

02:04.650 --> 02:08.650
好 这个库 既然是扩展课程

02:08.650 --> 02:10.650
那我们直接从圆码讲得了

02:10.650 --> 02:13.650
算了算了 还是想一想使用吧

02:13.650 --> 02:17.650
这个库怎么用呢 我们这里停止啊

02:17.650 --> 02:19.650
这里添加一下这个库

02:20.650 --> 02:23.650
好 这个库怎么用呢 它是这样子

02:23.650 --> 02:26.650
就说你的Action里面呢 你可以写副作用

02:26.650 --> 02:29.650
那么这个副作用呢 你返回的不是这样子

02:29.650 --> 02:31.650
返回的不是一个函数

02:31.650 --> 02:34.650
返回什么呢 你可以返回一个Promise

02:34.650 --> 02:36.650
你直接返回一个Promise

02:36.650 --> 02:39.650
来吧 那咱们直接返回一个Promise

02:39.650 --> 02:42.650
好 那么这里呢 我们就返回的是什么呢

02:42.650 --> 02:44.650
返回的是一个New

02:44.650 --> 02:45.650
一个Promise

02:45.650 --> 02:48.650
这是一种写法 直接返回一个Promise

02:48.650 --> 02:51.650
你要的意思吧 就是这里的Resolve

02:51.650 --> 02:53.650
对吧 还有什么

02:54.650 --> 02:56.650
两个三数啊 你别传个函数

02:56.650 --> 02:58.650
Resolve or reject

02:58.650 --> 03:00.650
就你直接返回一个Promise

03:01.650 --> 03:04.650
这个能调用这个方法 是不是就表示

03:04.650 --> 03:07.650
我这个Promise完成了 对吧

03:07.650 --> 03:10.650
这个方法呢 就表示这个Promise的出现问题了

03:10.650 --> 03:12.650
被拒绝了

03:13.650 --> 03:15.650
来表示这个Promise的状态

03:15.650 --> 03:17.650
总之呢 你返回一个Promise

03:17.650 --> 03:19.650
那你要做什么副作用的操作呢

03:19.650 --> 03:21.650
在这个Promise里边 这个函数里边去做

03:21.650 --> 03:24.650
好 咱们 哎呀 我可能把之前的删掉了

03:24.650 --> 03:26.650
我要看一下啊

03:26.650 --> 03:28.650
那么咱们这里边写啥呢

03:28.650 --> 03:30.650
我把这个

03:30.650 --> 03:32.650
把这个注射掉吧 重新写一下

03:32.650 --> 03:34.650
Export 方式

03:34.650 --> 03:36.650
Fish Student

03:37.650 --> 03:39.650
好 这里返回 返回什么呢

03:39.650 --> 03:41.650
返回的是一个Promise

03:41.650 --> 03:43.650
返回的是一个Promise

03:43.650 --> 03:45.650
返回的是一个Promise

03:45.650 --> 03:47.650
New一个Promise

03:47.650 --> 03:49.650
Resolve

03:49.650 --> 03:51.650
Retract

03:51.650 --> 03:53.650
好 那么这里边去写一些副作用的操作

03:53.650 --> 03:55.650
比方说什么操作呢

03:55.650 --> 03:57.650
我们这里边不是要那个

03:57.650 --> 03:59.650
要干嘛

04:00.650 --> 04:02.650
这里面不是要那个

04:03.650 --> 04:05.650
得到学生吗 对不对

04:05.650 --> 04:07.650
得到学生

04:07.650 --> 04:09.650
既然这个东西就是Promise

04:09.650 --> 04:11.650
那我不只就在这里写

04:11.650 --> 04:13.650
那我这里这样子写一下

04:13.650 --> 04:15.650
这里Set Timeout

04:15.650 --> 04:17.650
设置一段时间

04:17.650 --> 04:19.650
设置一段时间

04:19.650 --> 04:21.650
比方说一秒钟

04:21.650 --> 04:23.650
一秒钟之后

04:23.650 --> 04:25.650
我给它一个学生数组

04:25.650 --> 04:27.650
来模拟就是我们得到学生

04:27.650 --> 04:29.650
得到学生的一个过程

04:29.650 --> 04:31.650
那么这里一秒钟过后

04:31.650 --> 04:33.650
我给它一个学生数组

04:33.650 --> 04:35.650
那么学生数组怎么给它呢

04:35.650 --> 04:37.650
是用这种方式

04:37.650 --> 04:40.650
这里边你就直接写上你的Action

04:40.650 --> 04:42.650
Action是一个平面对象对吧

04:42.650 --> 04:43.650
那么我这里呢

04:43.650 --> 04:45.650
返回了不是平面对象

04:45.650 --> 04:46.650
得到了不是平面对象

04:46.650 --> 04:47.650
是一个Promise

04:47.650 --> 04:49.650
那么这里Resolve

04:49.650 --> 04:51.650
直接把真正的Action给它写上

04:51.650 --> 04:53.650
真正的Action给它写上

04:53.650 --> 04:55.650
具体怎么写呢

04:55.650 --> 04:56.650
Action怎么写呢

04:56.650 --> 04:58.650
不就是一个Type值吗对不对

04:58.650 --> 05:00.650
Type还有什么Payload对不对

05:00.650 --> 05:01.650
那么这个东西呢

05:01.650 --> 05:03.650
我们可以利用之前的Action创建函数

05:03.650 --> 05:05.650
来得到这么一个Action

05:05.650 --> 05:07.650
这些创建函数不是一个Set Students

05:07.650 --> 05:09.650
and Total吗对不对

05:09.650 --> 05:11.650
设置一个学生数组和总数

05:11.650 --> 05:12.650
那么我们这里呢

05:12.650 --> 05:13.650
就得到啊

05:13.650 --> 05:14.650
就通过这个函数

05:14.650 --> 05:16.650
Set Students and Total

05:16.650 --> 05:18.650
来得到这么一个Action

05:18.650 --> 05:19.650
把学生数组给它

05:19.650 --> 05:20.650
我们这里随便给一个嘛

05:20.650 --> 05:21.650
随便给一个数组

05:21.650 --> 05:22.650
ID

05:22.650 --> 05:23.650
或者说我们把它写过来吧

05:23.650 --> 05:24.650
也代码太长了

05:24.650 --> 05:26.650
大家看着也牢火

05:26.650 --> 05:27.650
总之呢

05:27.650 --> 05:28.650
我们得到这么一个Action

05:28.650 --> 05:29.650
就在这里触发一个Action

05:29.650 --> 05:30.650
这个Action怎么来的

05:30.650 --> 05:31.650
其实无所谓

05:31.650 --> 05:32.650
ID呢

05:33.650 --> 05:35.650
再来个学生

05:41.650 --> 05:43.650
这是学生的数组

05:43.650 --> 05:44.650
然后呢

05:44.650 --> 05:45.650
还要给各种数

05:45.650 --> 05:46.650
两个

05:46.650 --> 05:47.650
两个

05:47.650 --> 05:48.650
学生

05:48.650 --> 05:49.650
通过这个

05:49.650 --> 05:50.650
我们之前写好的函数

05:50.650 --> 05:51.650
是不是可以得到一个Action

05:51.650 --> 05:52.650
对吧

05:52.650 --> 05:53.650
之前我们用上课的时候

05:53.650 --> 05:54.650
不是也这样做吗

05:54.650 --> 05:55.650
Dispatch的时候

05:55.650 --> 05:56.650
也相当于是

05:56.650 --> 05:58.650
Dispatch的时候就是

05:58.650 --> 05:59.650
利用这个东西对吧

05:59.650 --> 06:01.650
因为我们之前写好的Action函数

06:01.650 --> 06:02.650
来给它数组

06:02.650 --> 06:03.650
给它种数

06:03.650 --> 06:04.650
那么我们这里呢

06:04.650 --> 06:05.650
只不过没有用阿加克斯请求

06:05.650 --> 06:06.650
总之呢

06:06.650 --> 06:07.650
得到这么一个Action

06:07.650 --> 06:09.650
也就是我们要触发Action

06:09.650 --> 06:10.650
怎么来触发呢

06:10.650 --> 06:11.650
用Resolve来触发

06:11.650 --> 06:13.650
用Resolve的方式来触发Action

06:13.650 --> 06:15.650
因为这里边你得不到Dispatch

06:15.650 --> 06:17.650
用Promise这个库的时候

06:17.650 --> 06:19.650
你是得不到Dispatch的

06:19.650 --> 06:22.650
所以说要用Resolve来触发Action

06:22.650 --> 06:23.650
没了意思吧

06:23.650 --> 06:24.650
就没了

06:24.650 --> 06:26.650
这个锐接个手我们用不到

06:26.650 --> 06:28.650
目前用不到

06:28.650 --> 06:29.650
就没了

06:29.650 --> 06:30.650
咱们打个处事

06:30.650 --> 06:34.650
由于使用了

06:34.650 --> 06:36.650
使用了就是

06:36.650 --> 06:40.650
Redug's Promise中间键

06:40.650 --> 06:48.650
因此允许Action

06:48.650 --> 06:50.650
是一个Promise

06:50.650 --> 06:51.650
是一个Promise

06:51.650 --> 06:55.650
那么在Promise中

06:55.650 --> 06:59.650
如果要触发Action

06:59.650 --> 07:00.650
在这里边可以做一些

07:00.650 --> 07:01.650
副作用的操作

07:01.650 --> 07:02.650
比如说Timeouts

07:02.650 --> 07:03.650
一部的东西

07:03.650 --> 07:05.650
如果要触发Action

07:05.650 --> 07:09.650
则使用Resolve

07:09.650 --> 07:12.650
将来用Resolve来触发Action

07:12.650 --> 07:14.650
就这么简单

07:14.650 --> 07:15.650
就这么简单

07:15.650 --> 07:17.650
没了

07:17.650 --> 07:18.650
那么现在呢

07:18.650 --> 07:21.650
我们来看一下

07:21.650 --> 07:23.650
这里写好了

07:23.650 --> 07:25.650
然后我们到index里边来

07:25.650 --> 07:26.650
index里边来

07:26.650 --> 07:27.650
我们之前用的是Sunk

07:27.650 --> 07:28.650
用的是Sunk

07:28.650 --> 07:29.650
那么现在呢

07:29.650 --> 07:34.650
我们把它换成Promise

07:34.650 --> 07:35.650
就我们导入的时候

07:35.650 --> 07:37.650
导入为Dug's Promise

07:37.650 --> 07:40.650
那么把Promise放进来

07:40.650 --> 07:41.650
好了

07:41.650 --> 07:42.650
咱们直接看一个页面

07:42.650 --> 07:44.650
直接看页面

07:44.650 --> 07:46.650
页面过一秒钟过后

07:46.650 --> 07:47.650
我们把时间写长一点

07:47.650 --> 07:48.650
你看得更加清楚一点

07:48.650 --> 07:50.650
三秒钟

07:50.650 --> 07:52.650
看一下

07:52.650 --> 07:53.650
三秒钟之后

07:53.650 --> 07:54.650
它会触发一个Action

07:54.650 --> 07:55.650
你看是不是用Resolve

07:55.650 --> 07:56.650
触发的

07:56.650 --> 07:57.650
触发一个Action

07:57.650 --> 07:58.650
Action的类型

07:58.650 --> 07:59.650
就是我们刚才写的

07:59.650 --> 08:00.650
两个数组

08:00.650 --> 08:01.650
两个数组偷偷加进来

08:01.650 --> 08:02.650
然后

08:02.650 --> 08:03.650
下一个状态

08:03.650 --> 08:04.650
你看下一个状态

08:04.650 --> 08:05.650
是不是

08:05.650 --> 08:06.650
就是Resolve里边

08:06.650 --> 08:07.650
它就有数组了

08:07.650 --> 08:08.650
对吧

08:08.650 --> 08:09.650
这东西就写好了

08:09.650 --> 08:10.650
没问题吧

08:10.650 --> 08:11.650
对不对

08:11.650 --> 08:12.650
就这么简单

08:12.650 --> 08:14.650
就这么简单

08:14.650 --> 08:15.650
然后这里呢

08:15.650 --> 08:16.650
就是我们这里是

08:16.650 --> 08:18.650
直接返回了一个New Promise

08:18.650 --> 08:19.650
对吧

08:19.650 --> 08:20.650
其实我们也可以利用

08:20.650 --> 08:22.650
异步的那种操作

08:22.650 --> 08:23.650
就是把这个函数

08:23.650 --> 08:24.650
变成一个异步函数

08:24.650 --> 08:25.650
因为你把它变成

08:25.650 --> 08:26.650
一个异步函数

08:26.650 --> 08:27.650
它不就是返回一个Promise

08:27.650 --> 08:28.650
对不对

08:28.650 --> 08:30.650
它一定就是返回一个Promise

08:30.650 --> 08:32.650
所以说你把它变成异步函数也行

08:32.650 --> 08:33.650
把它变成异步函数

08:33.650 --> 08:34.650
我们这里

08:34.650 --> 08:35.650
因为我们这里的本来

08:35.650 --> 08:36.650
Article之前就是异步的

08:36.650 --> 08:37.650
对吧

08:37.650 --> 08:38.650
就是一个返回的

08:38.650 --> 08:39.650
就是一个Promise

08:39.650 --> 08:40.650
返回的就是一个Promise

08:40.650 --> 08:41.650
因此我们这里可以用

08:41.650 --> 08:42.650
这种方式

08:42.650 --> 08:43.650
我们这里换一种写法

08:43.650 --> 08:44.650
嗯

08:44.650 --> 08:46.650
我们利用ES7

08:46.650 --> 08:47.650
那种就是

08:47.650 --> 08:50.650
Async和Away成的处理方式

08:50.650 --> 08:51.650
也可以

08:51.650 --> 08:52.650
你会发现它也可以

08:52.650 --> 08:55.470
这里我们返回来

08:55.470 --> 08:56.470
就不是Promise了

08:56.470 --> 08:57.470
直接把这个函数变成

08:57.470 --> 08:58.470
异步的函数

08:58.470 --> 08:59.470
异步的函数

08:59.470 --> 09:00.470
那么异步的函数

09:00.470 --> 09:01.470
它一定是返回Promise

09:01.470 --> 09:02.470
那么我们这里

09:02.470 --> 09:03.470
只要你

09:03.470 --> 09:04.470
你只要记住

09:04.470 --> 09:05.470
在Promise里面

09:05.470 --> 09:06.470
Resolve

09:06.470 --> 09:07.470
就是在分发

09:07.470 --> 09:08.470
但是你不能分发多个

09:08.470 --> 09:09.470
因为我们知道

09:09.470 --> 09:10.470
之前学过的Promise里面的

09:10.470 --> 09:11.470
Resolve

09:11.470 --> 09:12.470
只能Resolve一次

09:12.470 --> 09:13.470
对吧

09:13.470 --> 09:14.470
Resolve一次

09:14.470 --> 09:15.470
那么后边的Zen

09:15.470 --> 09:16.470
再去做后面的操作

09:16.470 --> 09:17.470
所以说你这里面

09:17.470 --> 09:18.470
不要去写多个Resolve

09:18.470 --> 09:19.470
因此

09:19.470 --> 09:20.470
不能像之前

09:20.470 --> 09:21.470
那个Dispatch的样子

09:21.470 --> 09:22.470
去触发多次

09:22.470 --> 09:23.470
只能触发一次

09:23.470 --> 09:24.470
那么这里

09:24.470 --> 09:25.470
那么这里

09:25.470 --> 09:27.470
我们在Fate Student里面

09:27.470 --> 09:28.470
在这里面

09:29.470 --> 09:31.470
我们直接使用

09:31.470 --> 09:32.470
Search Students

09:32.470 --> 09:33.470
像上面这样子

09:33.470 --> 09:34.470
Search Students

09:34.470 --> 09:35.470
把这个复字过来

09:39.170 --> 09:40.170
在这里

09:40.170 --> 09:41.170
把复字过来

09:44.170 --> 09:45.170
我们首先

09:45.170 --> 09:46.170
把这个条件拿到

09:46.170 --> 09:47.170
这个条件

09:47.170 --> 09:48.170
这个条件

09:49.170 --> 09:51.170
这个条件你拿不到了

09:51.170 --> 09:52.170
这个条件你拿不到了

09:52.170 --> 09:54.170
你得通过参数传过来

09:54.170 --> 09:55.170
你得通过参数传过来

09:55.170 --> 09:56.170
因为这个条件

09:56.170 --> 09:57.170
你这里面是拿不到

09:57.170 --> 09:58.170
getState的

09:58.170 --> 09:59.170
是拿不到这个条件的

09:59.170 --> 10:00.170
所以说你条件这里

10:00.170 --> 10:01.170
拿不到

10:01.170 --> 10:02.170
你得通过参数传进来

10:02.170 --> 10:03.170
传进来

10:03.170 --> 10:04.170
然后我们Search Students

10:04.170 --> 10:05.170
来去

10:05.170 --> 10:06.170
从服务器拿到

10:06.170 --> 10:07.170
服务器的响应结果

10:07.170 --> 10:08.170
那么这里面

10:08.170 --> 10:09.170
不是有那个

10:09.170 --> 10:10.170
不是有那个

10:10.170 --> 10:12.170
就是学生的

10:12.170 --> 10:14.170
数主和学生的数量吗

10:14.170 --> 10:15.170
OK

10:15.170 --> 10:16.170
我这里直接返回这个

10:16.170 --> 10:17.170
直接返回这个

10:17.170 --> 10:18.170
那么这种写法

10:18.170 --> 10:19.170
就像

10:19.170 --> 10:20.170
因为它返回的

10:20.170 --> 10:21.170
一定是Promise

10:21.170 --> 10:22.170
那么这个返回的东西

10:22.170 --> 10:23.170
实际上是Promise

10:23.170 --> 10:24.170
Resolve的值

10:24.170 --> 10:25.170
对不对

10:25.170 --> 10:27.170
是Promise Resolve的值

10:27.170 --> 10:28.170
那么这样子

10:28.170 --> 10:29.170
那由于它这个寒数

10:29.170 --> 10:30.170
本来就返回了Promise

10:30.170 --> 10:32.170
那么Resolve的值就是这个

10:32.170 --> 10:33.170
那么这个东西是个

10:33.170 --> 10:34.170
是个X

10:34.170 --> 10:35.170
那么就相当于是出发了

10:35.170 --> 10:36.170
这个X

10:36.170 --> 10:37.170
冒充

10:37.170 --> 10:38.170
你看一下

10:38.170 --> 10:39.170
来

10:39.170 --> 10:40.170
来来来

10:41.170 --> 10:42.170
拿个地方写错了

10:43.170 --> 10:44.170
他说

10:44.170 --> 10:45.170
应该是网络寝求

10:45.170 --> 10:46.170
这一块出了问题

10:46.170 --> 10:48.170
这一块出了问题

10:50.670 --> 10:52.670
服务器出问题了

10:53.670 --> 10:54.670
我看一下

10:54.670 --> 10:56.670
我们给他请求的地址是

10:57.670 --> 10:58.670
请求的地址是这个

10:59.670 --> 11:00.670
翻的牌

11:00.670 --> 11:01.670
AppleKey

11:01.670 --> 11:02.670
Page1 size是

11:02.670 --> 11:03.670
没问题

11:03.670 --> 11:04.670
没问题

11:05.670 --> 11:07.670
服务器出了一个500的错误

11:10.670 --> 11:11.670
这两天

11:11.670 --> 11:13.670
应该是服务器那边在调试吧

11:13.670 --> 11:14.670
应该是在调试

11:14.670 --> 11:15.670
我看一下

11:15.670 --> 11:16.670
我看一下

11:16.670 --> 11:18.670
就是服务器那边

11:21.670 --> 11:22.670
叫啥呢

11:23.670 --> 11:25.670
API杜仪ADU

11:30.290 --> 11:31.290
我看一下

11:31.290 --> 11:32.290
服务器这边

11:32.290 --> 11:33.290
怎么回事

11:41.880 --> 11:42.880
我们这里

11:42.880 --> 11:44.880
学生管理系统

11:44.880 --> 11:45.880
学生管理系统

11:45.880 --> 11:46.880
我们请求要有一个地址

11:46.880 --> 11:47.880
为什么拿不到呢

11:47.880 --> 11:48.880
接口闻到

11:48.880 --> 11:50.880
这是Fantal

11:50.880 --> 11:51.880
Fantabye Page

11:51.880 --> 11:52.880
Fantabye Page

11:52.880 --> 11:54.880
那么我们在这边

11:54.880 --> 11:55.880
直接把我们请求

11:55.880 --> 11:56.880
直接把我们的

11:56.880 --> 11:58.880
请求地址复制一下

11:58.880 --> 12:00.880
直接请求地址复制一下

12:00.880 --> 12:03.380
这个地址

12:05.380 --> 12:06.380
复制一下

12:07.380 --> 12:08.380
能拿到吗

12:08.380 --> 12:10.380
这数据是能拿到的

12:10.380 --> 12:11.380
这里面

12:11.380 --> 12:12.380
这边我们刷新一下

12:12.380 --> 12:13.380
再来刷新一下

12:13.380 --> 12:16.400
拿到了

12:16.400 --> 12:17.400
拿到这个数据了

12:17.400 --> 12:18.400
你看没

12:18.400 --> 12:19.400
刚才不知道怎么回事

12:19.400 --> 12:20.400
反正不是我们的原因

12:20.400 --> 12:22.400
因为我们代表改的没改

12:22.400 --> 12:23.400
那么现在呢

12:23.400 --> 12:24.400
你看

12:24.400 --> 12:25.400
得到了Payload的数据

12:25.400 --> 12:27.400
Payload的

12:27.400 --> 12:28.400
Action里面

12:28.400 --> 12:29.400
是否正常拿到了

12:29.400 --> 12:30.400
它触发的Action

12:30.400 --> 12:31.400
总之呢

12:31.400 --> 12:32.400
也就是说

12:32.400 --> 12:33.400
我们使用了这个冬天键

12:33.400 --> 12:34.400
它一直要给它一个Promise

12:34.400 --> 12:35.400
Promise里面

12:35.400 --> 12:37.400
resolve的东西

12:37.400 --> 12:38.400
resolve的东西

12:38.400 --> 12:39.400
就是

12:39.400 --> 12:41.400
要触发的Action

12:41.400 --> 12:42.400
要触发的Action

12:42.400 --> 12:43.400
对吧

12:43.400 --> 12:44.400
就这么个意思

12:44.400 --> 12:45.400
就这么个意思

12:45.400 --> 12:47.400
没问题吧

12:47.400 --> 12:49.400
那么这是

12:49.400 --> 12:50.400
这是这一块

12:50.400 --> 12:52.400
好 这是这一种用法

12:52.400 --> 12:54.400
还有另外一种用法呢

12:54.400 --> 12:55.400
还有另外一种用法

12:55.400 --> 12:56.400
是这样子

12:56.400 --> 12:57.400
export

12:57.400 --> 12:58.400
sync

12:58.400 --> 12:59.400
我们再来写

12:59.400 --> 13:00.400
多写一种用法

13:00.400 --> 13:02.400
fake students

13:02.400 --> 13:06.610
fake students

13:06.610 --> 13:07.610
还有一种用法

13:07.610 --> 13:08.610
因为这里为什么

13:08.610 --> 13:09.610
我没有传

13:09.610 --> 13:10.610
tester里面没有传递

13:10.610 --> 13:11.610
这个condition

13:11.610 --> 13:12.610
它也能获取呢

13:12.610 --> 13:13.610
因为我们调用的这个方法的时候

13:13.610 --> 13:14.610
condition它有默认值

13:14.610 --> 13:15.610
对吧

13:15.610 --> 13:16.610
你没有传递它有默认值的

13:16.610 --> 13:17.610
那个无所谓

13:17.610 --> 13:18.610
那么咱们再看

13:18.610 --> 13:19.610
另外一种用法

13:19.610 --> 13:20.610
还是fake students

13:20.610 --> 13:21.610
然后呢

13:21.610 --> 13:22.610
还是得把那个

13:22.610 --> 13:23.610
condition传进来

13:23.610 --> 13:25.610
你的条件传进来

13:25.610 --> 13:26.610
然后呢

13:26.610 --> 13:27.610
当然这个condition

13:27.610 --> 13:28.610
应该

13:28.610 --> 13:29.610
按正常逻辑说的话

13:29.610 --> 13:30.610
应该从这里获取

13:30.610 --> 13:32.610
应该在这里

13:32.610 --> 13:33.610
在这里

13:33.610 --> 13:34.610
fake students

13:34.610 --> 13:35.610
这里要传个condition

13:35.610 --> 13:37.610
来自于store

13:37.610 --> 13:38.610
get states

13:38.610 --> 13:39.610
get states

13:39.610 --> 13:40.610
里面有一个就是

13:40.610 --> 13:41.610
students

13:41.610 --> 13:43.610
students里面有个condition

13:43.610 --> 13:45.610
有个condition

13:45.610 --> 13:47.610
同样的传过去

13:47.610 --> 13:48.610
那么这边

13:48.610 --> 13:49.610
我们再看另外一种写法

13:49.610 --> 13:50.610
另外一种写法

13:50.610 --> 13:51.610
就是返回一个

13:51.610 --> 13:54.610
正常的平面的x形对象

13:54.610 --> 13:55.610
返回一个正常的

13:55.610 --> 13:57.610
平面的x形对象

13:57.610 --> 13:59.610
那么这里返回的是什么呢

13:59.610 --> 14:00.610
返回的是一个type值

14:00.610 --> 14:01.610
type值是什么

14:01.610 --> 14:03.610
type值是search

14:04.610 --> 14:05.610
action types

14:05.610 --> 14:06.610
search

14:07.610 --> 14:08.610
set students

14:08.610 --> 14:09.610
and total

14:11.610 --> 14:13.610
type值返回这个type值

14:14.610 --> 14:15.610
然后呢

14:15.610 --> 14:17.610
它里面的payload

14:17.610 --> 14:19.610
payload不是应该是那个

14:19.610 --> 14:21.610
payload不是应该那个

14:21.610 --> 14:23.610
是一个什么呢

14:23.610 --> 14:24.610
payload不是应该看一下

14:24.610 --> 14:25.610
之前的

14:25.610 --> 14:26.610
不是应该是一个

14:26.610 --> 14:27.610
对象对吧

14:27.610 --> 14:28.610
是一个对象

14:28.610 --> 14:29.610
那么对象里面

14:29.610 --> 14:31.610
直接设置数组和总数

14:31.610 --> 14:32.610
对吧

14:32.610 --> 14:33.610
直接设置数组和总数

14:33.610 --> 14:34.610
但是呢

14:34.610 --> 14:35.610
我们跟刚才那个

14:35.610 --> 14:36.610
把这个复字过来

14:36.610 --> 14:38.610
大家对比一下

14:38.610 --> 14:39.610
你看这两个返回的

14:39.610 --> 14:41.610
都是类似的一个x形

14:41.610 --> 14:42.610
看没

14:42.610 --> 14:43.610
这个返回的也是type

14:43.610 --> 14:44.610
等于这个x形

14:44.610 --> 14:45.610
那么payload

14:45.610 --> 14:46.610
它是直接是个对象

14:46.610 --> 14:47.610
对吧

14:47.610 --> 14:48.610
这是我们

14:48.610 --> 14:49.610
举手里面想要的是这个东西

14:49.610 --> 14:50.610
但是呢

14:50.610 --> 14:51.610
我们这里写的这个

14:51.610 --> 14:52.610
fetch students

14:52.610 --> 14:53.610
我们是

14:53.610 --> 14:54.610
要经过这个

14:54.610 --> 14:55.610
通过这个条件去查询的

14:55.610 --> 14:56.610
这个payload

14:56.610 --> 14:57.610
通过条件查询出来的

14:57.610 --> 14:58.610
把这个payload

14:58.610 --> 15:00.610
给它写成Promise

15:00.610 --> 15:01.610
是

15:01.610 --> 15:02.610
它是这种解法

15:02.610 --> 15:04.610
只是把payload的这个位置

15:04.610 --> 15:05.610
写成Promise

15:05.610 --> 15:06.610
这里呢

15:06.610 --> 15:08.610
我们留一个Promise

15:08.610 --> 15:09.610
把payload的这个位置

15:09.610 --> 15:11.610
写成一个Promise

15:12.610 --> 15:13.610
那么Promise里面呢

15:13.610 --> 15:14.610
自然有resolve

15:14.610 --> 15:15.610
对吧

15:15.610 --> 15:16.610
resolve

15:17.610 --> 15:18.610
好

15:18.610 --> 15:19.610
那么这个resolve

15:19.610 --> 15:20.610
我们怎么来得到呢

15:20.610 --> 15:21.610
我们就可以利用

15:21.610 --> 15:22.610
这个函数

15:22.610 --> 15:23.610
我们之前的那个

15:23.610 --> 15:24.610
API函数

15:24.610 --> 15:25.610
search students

15:25.610 --> 15:26.610
查询

15:26.610 --> 15:27.610
把条件传进去查询

15:27.610 --> 15:28.610
然后呢

15:28.610 --> 15:29.610
当我们查询

15:29.610 --> 15:31.610
结果之后

15:31.610 --> 15:33.610
然后结果之后干嘛呢

15:33.610 --> 15:34.610
然后结果之后

15:34.610 --> 15:36.610
我们把这个服务器的结果

15:36.610 --> 15:38.610
组装成这个对象

15:38.610 --> 15:39.610
来返回

15:39.610 --> 15:40.610
把服务器的这个结果

15:40.610 --> 15:42.610
组装成对象来返回

15:42.610 --> 15:43.610
那么什么对象呢

15:43.610 --> 15:44.610
就是这个对象

15:44.610 --> 15:46.610
组装成这个对象

15:46.610 --> 15:48.610
我要返回的是这个对象

15:48.610 --> 15:49.610
对吧

15:49.610 --> 15:50.610
这里

15:50.610 --> 15:51.610
我们要组装成

15:51.610 --> 15:52.610
这个对象来返回

15:52.610 --> 15:54.610
那么这里呢

15:54.610 --> 15:55.610
看一下

15:55.610 --> 15:56.610
这个AR

15:56.610 --> 15:57.610
数组是什么

15:57.610 --> 15:58.610
数组就是服务器的

15:58.610 --> 15:59.610
data

15:59.610 --> 16:00.610
data

16:01.610 --> 16:03.610
是data

16:03.610 --> 16:04.610
我看一下

16:04.610 --> 16:05.610
这里边

16:05.610 --> 16:07.610
data是对的

16:07.610 --> 16:08.610
总数呢

16:08.610 --> 16:09.610
是来自于服务器的

16:09.610 --> 16:10.610
resp

16:10.610 --> 16:11.610
count

16:12.610 --> 16:13.610
什么意思

16:13.610 --> 16:14.610
我解释一下

16:14.610 --> 16:15.610
我解释一下

16:16.610 --> 16:17.610
我们就

16:17.610 --> 16:18.610
干脆在这里

16:18.610 --> 16:19.610
不用写

16:19.610 --> 16:20.610
不用写另一个promise

16:20.610 --> 16:21.610
在这

16:21.610 --> 16:22.610
就直接这样子写

16:23.610 --> 16:24.610
那么这个是什么意思呢

16:24.610 --> 16:25.610
就是说

16:25.610 --> 16:27.610
我整个fage students

16:27.610 --> 16:28.610
他返回的是一个

16:28.610 --> 16:29.610
普普通通的一个型

16:29.610 --> 16:30.610
他有type属性

16:30.610 --> 16:31.610
有payload属性

16:31.610 --> 16:33.610
只不过payload属性是一个promise

16:33.610 --> 16:35.610
你看payload属性是不是一个promise

16:35.610 --> 16:37.610
他一定是一个promise

16:37.610 --> 16:38.610
他一定是个promise

16:38.610 --> 16:39.610
为什么

16:39.610 --> 16:40.610
因为这个东西返回的是个promise

16:40.610 --> 16:41.610
对吧

16:41.610 --> 16:42.610
然后我们

16:42.610 --> 16:43.610
当他成功之后

16:43.610 --> 16:44.610
我们进行处理

16:44.610 --> 16:45.610
处理完了过后

16:46.610 --> 16:47.610
我们是不是返回了对象

16:47.610 --> 16:48.610
返回对象

16:48.610 --> 16:49.610
那么你想一想

16:49.610 --> 16:50.610
下一次任

16:51.610 --> 16:52.610
下一次处理

16:52.610 --> 16:53.610
就是接下来的

16:53.610 --> 16:54.610
下一次处理

16:54.610 --> 16:55.610
可以达到这个对象

16:55.610 --> 16:56.610
对吧

16:56.610 --> 16:57.610
因为我们知道promise

16:57.610 --> 16:58.610
你们以前学过的promise

16:58.610 --> 16:59.610
promise

16:59.610 --> 17:01.610
无论你使用的是任还是什么玩意儿

17:01.610 --> 17:02.610
他最终

17:02.610 --> 17:03.610
会返回的是一个什么

17:03.610 --> 17:05.610
最终的话

17:05.610 --> 17:08.610
返回的是一个promise

17:08.610 --> 17:10.610
就整个框住这一坨

17:10.610 --> 17:11.610
返回的还是个promise

17:11.610 --> 17:12.610
那么这个promise

17:12.610 --> 17:13.610
result的对象是啥

17:13.610 --> 17:14.610
result的对象就是

17:14.610 --> 17:15.610
之前那一次任

17:15.610 --> 17:16.610
得到的对象

17:16.610 --> 17:17.610
就这个对象

17:17.610 --> 17:18.610
所以说

17:18.610 --> 17:19.610
我们可以

17:19.610 --> 17:20.610
下一次任

17:20.610 --> 17:21.610
下一次任

17:21.610 --> 17:22.610
那么他这里

17:22.610 --> 17:23.610
得到的就是

17:23.610 --> 17:24.610
payload

17:24.610 --> 17:25.610
是什么

17:25.610 --> 17:26.610
这一次任

17:26.610 --> 17:27.610
得到的payload

17:27.610 --> 17:28.610
是不是这个玩意儿

17:28.610 --> 17:29.610
对吧

17:29.610 --> 17:30.610
是不是这个玩意儿

17:30.610 --> 17:31.610
对不对

17:31.610 --> 17:32.610
就这个东西

17:32.610 --> 17:33.610
那么也就是说

17:33.610 --> 17:35.610
我们把最终这个promise

17:35.610 --> 17:36.610
resolve的东西

17:36.610 --> 17:37.610
resolve的东西

17:37.610 --> 17:38.610
当做

17:38.610 --> 17:39.610
action的payload

17:39.610 --> 17:40.610
仅仅是当做

17:40.610 --> 17:41.610
action的payload

17:41.610 --> 17:42.610
不是整个action

17:42.610 --> 17:43.610
对吧

17:43.610 --> 17:44.610
也就是他支持两种方案

17:44.610 --> 17:45.610
第一种方案

17:45.610 --> 17:46.610
是直接返回一个promise

17:46.610 --> 17:48.610
直接返回一个promise

17:48.610 --> 17:50.610
第二种方案

17:50.610 --> 17:51.610
是

17:51.610 --> 17:53.610
你的payload是一个promise

17:53.610 --> 17:54.610
就整个两种方案

17:54.610 --> 17:55.610
那么他具体的做法

17:55.610 --> 17:56.610
是怎么做的呢

17:56.610 --> 17:57.610
他具体的做法是这样做的

17:57.610 --> 17:58.610
就是说

17:58.610 --> 18:01.610
如果action是一个

18:03.610 --> 18:05.610
是一个promise

18:05.610 --> 18:07.610
是一个promise

18:07.610 --> 18:09.610
则会

18:09.610 --> 18:11.610
等待

18:11.610 --> 18:13.610
promise完成

18:13.610 --> 18:15.610
等待promise完成

18:15.610 --> 18:16.610
如果

18:16.610 --> 18:19.610
就是将完成的结果

18:19.610 --> 18:21.610
作为action触发

18:21.610 --> 18:23.610
将完成的结果

18:23.610 --> 18:25.610
作为action触发

18:25.610 --> 18:27.610
那么如果

18:27.610 --> 18:29.610
action

18:29.610 --> 18:31.610
不是一个promise

18:31.610 --> 18:33.610
不是一个promise

18:33.610 --> 18:35.610
则直接触发

18:35.610 --> 18:37.610
直接触发

18:37.610 --> 18:39.610
他大致上的

18:39.610 --> 18:41.610
则判断

18:41.610 --> 18:42.610
则判断

18:42.610 --> 18:44.610
其payload

18:44.610 --> 18:46.610
是否是一个promise

18:46.610 --> 18:48.610
是否是一个promise

18:48.610 --> 18:50.610
如果是

18:50.610 --> 18:52.610
如果payload是一个promise

18:52.610 --> 18:54.610
那么等待

18:54.610 --> 18:56.610
promise完成

18:56.610 --> 18:58.610
然后触发

18:58.610 --> 19:01.610
然后将得到的结果

19:01.610 --> 19:03.610
作为

19:03.610 --> 19:05.610
payload的

19:05.610 --> 19:06.610
触发

19:06.610 --> 19:07.610
那么大致上的

19:07.610 --> 19:08.610
是这么一种流程

19:08.610 --> 19:09.610
他就是在中间里面

19:09.610 --> 19:10.610
做了一个判断

19:10.610 --> 19:11.610
判断action

19:11.610 --> 19:12.610
是不是一个promise

19:12.610 --> 19:13.610
然后呢

19:13.610 --> 19:14.610
如果是的话

19:14.610 --> 19:16.610
那么就把它作为promise触发

19:16.610 --> 19:17.610
如果他不是promise的话

19:17.610 --> 19:18.610
那么判断payload的

19:18.610 --> 19:19.610
是不是promise

19:19.610 --> 19:20.610
如果是的话

19:20.610 --> 19:21.610
等待promise完成

19:21.610 --> 19:22.610
然后把它作为

19:22.610 --> 19:23.610
payload的触发

19:23.610 --> 19:24.610
他代码没有几

19:24.610 --> 19:25.610
所以我们现在可以

19:25.610 --> 19:26.610
直接写下他的代码

19:26.610 --> 19:27.610
直接来写下他的代码

19:27.610 --> 19:28.610
你看了

19:28.610 --> 19:29.610
其实很多东西

19:29.610 --> 19:30.610
你只要看了他的原代码之后

19:30.610 --> 19:31.610
你就会非常清楚了

19:31.610 --> 19:32.610
了解他怎么回事了

19:32.610 --> 19:33.610
好咱们来写一下

19:33.610 --> 19:34.610
这个代码

19:34.610 --> 19:35.610
叫做ray

19:35.610 --> 19:36.610
那个是

19:36.610 --> 19:38.610
promise

19:38.610 --> 19:39.610
我们这里

19:39.610 --> 19:40.610
就一个文件

19:40.610 --> 19:41.610
就一个文件

19:41.610 --> 19:43.610
好看一下这里面怎么写的

19:43.610 --> 19:45.610
这边是怎么写的

19:46.610 --> 19:47.610
我们这里

19:48.610 --> 19:49.610
在这里

19:49.610 --> 19:50.610
我们使用

19:50.610 --> 19:51.610
在这里

19:51.610 --> 19:52.610
我们使用自己写的

19:52.610 --> 19:53.610
redax promise

19:56.610 --> 19:57.610
redax promise

19:57.610 --> 19:58.610
我们使用自己的

20:02.010 --> 20:04.010
那么在这个redax promise里面

20:04.010 --> 20:05.010
我们导出一个

20:05.010 --> 20:06.010
导出一个

20:06.010 --> 20:07.010
中间键

20:07.010 --> 20:08.010
对吧

20:08.010 --> 20:09.010
要导出一个中间键

20:09.010 --> 20:10.010
那么我们这里可以通过一个

20:10.010 --> 20:11.010
函数来创建

20:11.010 --> 20:12.010
一个中间键

20:12.010 --> 20:14.010
或者是直接导出一个中间键也行

20:14.010 --> 20:15.010
导出一个中间键也行

20:15.010 --> 20:16.010
那个中间键也没有什么特别

20:16.010 --> 20:17.010
直接导出也行

20:17.010 --> 20:18.010
export

20:18.010 --> 20:19.010
直接导出个中间键

20:19.010 --> 20:20.010
export

20:20.010 --> 20:21.010
default

20:21.010 --> 20:22.010
那中间键怎么写的

20:22.010 --> 20:23.010
对吧

20:23.010 --> 20:24.010
第一个

20:24.010 --> 20:25.010
stone对不对

20:25.010 --> 20:26.010
然后呢

20:26.010 --> 20:27.010
next

20:27.010 --> 20:28.010
然后什么x

20:28.010 --> 20:29.010
就是这么一种函数

20:29.010 --> 20:30.010
这就是中间键

20:30.010 --> 20:31.010
导出这么一个中间键

20:31.010 --> 20:33.010
这个中间键怎么写的

20:33.010 --> 20:35.010
那么它就判断

20:35.010 --> 20:36.010
就判断这个x

20:36.010 --> 20:37.010
到底是一个什么玩意

20:37.010 --> 20:38.010
这里

20:38.010 --> 20:39.010
我就贴合它的元代码

20:39.010 --> 20:40.010
说

20:40.010 --> 20:41.010
它的元代码

20:41.010 --> 20:42.010
基本上是这样的逻辑

20:42.010 --> 20:43.010
但是有一点点

20:43.010 --> 20:44.010
细微的

20:44.010 --> 20:45.010
差异

20:45.010 --> 20:46.010
我就贴合元代码

20:46.010 --> 20:47.010
它是怎么判断的呢

20:47.010 --> 20:48.010
它首先是这个

20:48.010 --> 20:49.010
这个判断

20:49.010 --> 20:51.010
如果x

20:51.010 --> 20:54.010
是一个标准的

20:54.010 --> 20:55.010
标准的

20:55.010 --> 20:57.010
标准的就是

20:57.010 --> 21:00.770
刚才我好像

21:00.770 --> 21:02.770
刚才我给大家观察一下

21:02.770 --> 21:04.770
给大家看一下一个结果

21:04.770 --> 21:06.770
运行结果

21:06.770 --> 21:07.770
等一下

21:07.770 --> 21:10.590
稍等一下

21:10.590 --> 21:11.590
刚才我好像写了

21:11.590 --> 21:12.590
还没给看结果

21:12.590 --> 21:13.590
还没有看结果

21:13.590 --> 21:14.590
panel的

21:14.590 --> 21:15.590
我给他写的是一个

21:15.590 --> 21:16.590
写的是一个promise

21:16.590 --> 21:17.590
来看一下

21:20.590 --> 21:21.590
好

21:21.590 --> 21:22.590
那么这里

21:22.590 --> 21:24.590
你看到一个元

21:24.590 --> 21:25.590
你看到这里

21:25.590 --> 21:26.590
结果

21:26.590 --> 21:27.590
它是什么

21:27.590 --> 21:28.590
它并没有触发

21:28.590 --> 21:29.590
那个中间键

21:29.590 --> 21:30.590
你发现没

21:30.590 --> 21:31.590
它并没有把panel的

21:31.590 --> 21:33.590
等待这个promise完成

21:33.590 --> 21:35.590
它并没有等待这个promise完成

21:35.590 --> 21:37.590
并没有去等待它完成

21:37.590 --> 21:38.590
你看它这里panel的

21:38.590 --> 21:39.590
最终触发的x

21:39.590 --> 21:40.590
还是个promise

21:40.590 --> 21:41.590
这怎么回事呢

21:41.590 --> 21:42.590
它是因为这样子

21:42.590 --> 21:43.590
它是因为

21:43.590 --> 21:45.590
它认为你这个x

21:45.590 --> 21:46.590
x的类型

21:46.590 --> 21:48.590
不是一个标准的

21:48.590 --> 21:49.590
就是x的类型

21:49.590 --> 21:50.590
为什么呢

21:50.590 --> 21:51.590
因为它是遵从的是

21:51.590 --> 21:52.590
flux的x的标准

21:52.590 --> 21:55.590
在flux的x的标准里面

21:55.590 --> 21:56.590
它的type

21:56.590 --> 21:57.590
必须是一个字五串

21:57.590 --> 21:58.590
但是我们的type

21:58.590 --> 21:59.590
是一个symbol

21:59.590 --> 22:00.590
是一个symbol

22:00.590 --> 22:01.590
所以说它这里出了问题

22:01.590 --> 22:02.590
那如果说你把type

22:02.590 --> 22:03.590
变成字五串

22:03.590 --> 22:04.590
那就正确了

22:04.590 --> 22:05.590
就正确了

22:05.590 --> 22:06.590
我刚才写的

22:06.590 --> 22:07.590
突然想到这个问题

22:07.590 --> 22:08.590
你看现在是不是正确了

22:08.590 --> 22:09.590
对吧

22:09.590 --> 22:11.590
panel的就不再是一个promise

22:11.590 --> 22:12.590
它变成一个

22:12.590 --> 22:14.590
等待promise完成之后的字

22:14.590 --> 22:15.590
它要求你这个type

22:15.590 --> 22:16.590
必须是一个字五串

22:16.590 --> 22:18.590
这是那个

22:20.590 --> 22:21.590
它的要求

22:21.590 --> 22:23.590
flux它的要求

22:23.590 --> 22:25.590
flux要求x的标准

22:26.590 --> 22:27.590
但是我们平时

22:27.590 --> 22:29.590
其实我个人习惯用symbol

22:29.590 --> 22:31.590
所以说这个枯

22:31.590 --> 22:32.590
它有意做了这样的判断

22:32.590 --> 22:34.590
因此我不太会用这个枯

22:34.590 --> 22:35.590
这里我说一下

22:35.590 --> 22:37.590
它的具体怎么写的

22:37.590 --> 22:38.590
看了它原来

22:38.590 --> 22:39.590
过后你什么都明白

22:40.590 --> 22:41.590
那么这里首先判断

22:41.590 --> 22:42.590
做了一个判断

22:42.590 --> 22:43.590
判断啥呢

22:43.590 --> 22:45.590
x是不是

22:45.590 --> 22:50.590
一个标准的flux的x

22:50.590 --> 22:52.590
就是一个标准的flux

22:52.590 --> 22:53.590
那么它这个判断

22:53.590 --> 22:55.590
利用的是一个第三方库

22:55.590 --> 22:57.590
利用的是一个第三方库来判断的

22:57.590 --> 22:59.590
其实这个判断也没去解决在

22:59.590 --> 23:01.590
所以我们这里直接写

23:01.590 --> 23:03.590
就写这么一个函数

23:05.590 --> 23:10.590
叫做e is fs fs f

23:10.590 --> 23:11.590
就表示flux

23:11.590 --> 23:12.590
s表示standard

23:12.590 --> 23:13.590
表示标准的

23:13.590 --> 23:14.590
a表示x

23:14.590 --> 23:15.590
判断一个x

23:15.590 --> 23:17.590
是不是一个标准的flux

23:17.590 --> 23:19.590
是不是一个标准的flux

23:19.590 --> 23:22.590
那么这里你给我一个x

23:22.590 --> 23:24.590
那么我来帮你进行判断

23:24.590 --> 23:25.590
判断这个东西

23:25.590 --> 23:26.590
是不是一个标准的flux

23:26.590 --> 23:31.970
判断一个x

23:31.970 --> 23:36.970
是不是标准的flux

23:36.970 --> 23:38.970
判断这个

23:39.970 --> 23:40.970
那么这个东西怎么判断

23:40.970 --> 23:42.970
它是有这么一个要求

23:42.970 --> 23:44.970
首先这个x

23:44.970 --> 23:46.970
它必须是

23:46.970 --> 23:48.970
必须是一个品面对象

23:48.970 --> 23:50.970
就是plane object 车

23:50.970 --> 23:52.970
就是plane object 车

23:52.970 --> 23:54.970
不想再重新写一次的

23:54.970 --> 23:55.970
不想再重新写一次的

23:55.970 --> 23:58.970
然后我直接利用loader 起来

23:58.970 --> 24:00.970
用loader 起

24:00.970 --> 24:01.970
因为loader 起里边

24:01.970 --> 24:03.970
它给你做了这样的判断

24:08.970 --> 24:09.970
再听见一个库吧

24:09.970 --> 24:10.970
一会我们还要看判断

24:10.970 --> 24:12.970
是不是 promise

24:12.970 --> 24:14.970
再听见一个库

24:14.970 --> 24:16.970
这个库大家可能没见过

24:16.970 --> 24:17.970
这个库很简单

24:17.970 --> 24:18.970
就是几行代

24:18.970 --> 24:19.970
它来判断一个东西

24:19.970 --> 24:21.970
是不是一个promise对象

24:21.970 --> 24:22.970
是不是一个promise对象

24:22.970 --> 24:23.970
就这么简单

24:23.970 --> 24:24.970
没了

24:24.970 --> 24:25.970
听见这两个库

24:25.970 --> 24:26.970
让它添加吧

24:26.970 --> 24:27.970
那么这里

24:27.970 --> 24:29.970
x 必须是一个品面对象

24:29.970 --> 24:32.970
然后x.tap

24:32.970 --> 24:33.970
这个属性

24:33.970 --> 24:36.970
必须是一个制服串

24:36.970 --> 24:38.970
就是一个标准的

24:38.970 --> 24:40.970
x的一种格式

24:40.970 --> 24:41.970
就是flux 标准里边

24:41.970 --> 24:42.970
一个格式

24:42.970 --> 24:44.970
但是你其实可以用symbol

24:44.970 --> 24:45.970
没有任何问题的

24:45.970 --> 24:47.970
那么x的还有什么呢

24:47.970 --> 24:49.970
x的就是

24:49.970 --> 24:52.970
x的属性

24:52.970 --> 24:54.970
不能包含

24:54.970 --> 24:57.970
其他非标准属性

24:57.970 --> 24:59.970
就是它的属性呢

24:59.970 --> 25:00.970
有哪些是标准属性呢

25:00.970 --> 25:01.970
我们这里说一下

25:01.970 --> 25:03.970
标准属性

25:03.970 --> 25:05.970
标准属性是这么一些

25:05.970 --> 25:07.970
tap

25:07.970 --> 25:09.970
这是个标准属性

25:09.970 --> 25:10.970
还有什么

25:11.970 --> 25:13.970
其实还有两个

25:13.970 --> 25:14.970
一个是arrow

25:14.970 --> 25:15.970
是不是有错误

25:15.970 --> 25:16.970
是不是有错误

25:16.970 --> 25:18.970
arrow 是一个标准属性

25:18.970 --> 25:19.970
还有什么呢

25:19.970 --> 25:20.970
还有一个是

25:22.970 --> 25:24.970
meta

25:24.970 --> 25:25.970
meta 是一些远数据

25:25.970 --> 25:27.970
也是附加的一些信息

25:27.970 --> 25:29.970
跟那种主体数据无关的

25:29.970 --> 25:31.970
那么这个东西相对于是个主体数据

25:31.970 --> 25:32.970
这个是一些

25:32.970 --> 25:33.970
y的一些乱七八糟的数据

25:33.970 --> 25:34.970
如果有的话

25:34.970 --> 25:35.970
再加上

25:35.970 --> 25:37.970
也就是在flux 标准里边

25:37.970 --> 25:39.970
x里面只能有这么四个属性

25:40.970 --> 25:42.970
那么再判断吧

25:42.970 --> 25:43.970
那怎么判断呢

25:43.970 --> 25:44.970
直接返回结构就行了

25:44.970 --> 25:45.970
是不是一品面对象

25:45.970 --> 25:46.970
那么我们可以利用

25:46.970 --> 25:48.970
nodec里边的东西来处理

25:51.970 --> 25:52.970
nodec里边

25:52.970 --> 25:53.970
我们也不用这个下滑线了

25:53.970 --> 25:54.970
直接导出

25:54.970 --> 25:56.970
导出它两个方法

25:56.970 --> 25:57.970
一个是

26:02.970 --> 26:03.970
还是用下滑线

26:03.970 --> 26:04.970
它没有智能提示

26:04.970 --> 26:06.970
那么我们这里用下滑线

26:07.970 --> 26:08.970
它没有智能提示

26:10.970 --> 26:11.970
我们直接写吧

26:11.970 --> 26:12.970
强行写

26:12.970 --> 26:13.970
它有两个方法

26:13.970 --> 26:15.970
isplay object

26:15.970 --> 26:16.970
这是一个方法

26:16.970 --> 26:17.970
还有一个是

26:19.970 --> 26:20.970
有这么两个方法来判断

26:20.970 --> 26:22.970
它是不是个品面对象

26:22.970 --> 26:24.970
和是不是一个字母串

26:24.970 --> 26:25.970
那么这里我们使用

26:29.970 --> 26:31.970
如果它是一个品面对象

26:31.970 --> 26:33.970
并且它是一个字母串

26:33.970 --> 26:35.970
就是action.tap

26:35.970 --> 26:36.970
是一个字母串

26:36.970 --> 26:37.970
还并且

26:37.970 --> 26:39.970
它里边的属性

26:39.970 --> 26:41.970
所有的属性都必须是标准属性

26:41.970 --> 26:42.970
那么这里怎么判断的

26:42.970 --> 26:44.970
这是两个并且的

26:44.970 --> 26:45.970
就是第一个并且

26:45.970 --> 26:46.970
它保证它是品面对象

26:46.970 --> 26:47.970
第二个并且

26:47.970 --> 26:48.970
表示它是一个字母串

26:48.970 --> 26:50.970
第三个并且

26:50.970 --> 26:51.970
它必须是

26:52.970 --> 26:53.970
第三个并且

26:53.970 --> 26:55.970
第三个并且是

26:55.970 --> 26:57.970
它的用objects.tiz

26:57.970 --> 26:58.970
来达到它里面的

26:58.970 --> 27:00.970
对象里面的所有属性

27:00.970 --> 27:01.970
看一下是不是所有的属性

27:01.970 --> 27:02.970
都满足一个要求

27:02.970 --> 27:03.970
什么要求

27:03.970 --> 27:05.970
我们把属性名字拿到

27:05.970 --> 27:06.970
这个属性名字

27:06.970 --> 27:07.970
什么要求呢

27:07.970 --> 27:09.970
就是这个数组

27:09.970 --> 27:11.970
这个数组里边

27:11.970 --> 27:14.970
index.t

27:14.970 --> 27:16.970
要大于-1

27:16.970 --> 27:17.970
对吧

27:17.970 --> 27:18.970
大于-1

27:18.970 --> 27:19.970
写完了

27:19.970 --> 27:20.970
就这么写

27:20.970 --> 27:21.970
你看一下吧

27:21.970 --> 27:23.970
三个条件必须要同时满足

27:23.970 --> 27:25.970
它是一个标准的action

27:25.970 --> 27:26.970
这是一个标准的

27:26.970 --> 27:28.970
就是flux的action

27:28.970 --> 27:29.970
第一个它必须是品面对象

27:29.970 --> 27:30.970
第二个type

27:30.970 --> 27:31.970
必须是一个字母串

27:31.970 --> 27:32.970
第三个

27:32.970 --> 27:33.970
它的就是

27:33.970 --> 27:34.970
所有的属性名字

27:34.970 --> 27:36.970
every表示必须要全部满足

27:36.970 --> 27:37.970
必须要

27:37.970 --> 27:38.970
这个数组里边

27:38.970 --> 27:39.970
全部条件都要满足

27:39.970 --> 27:41.970
才能返回出

27:41.970 --> 27:42.970
它的所有属性

27:42.970 --> 27:44.970
都必须是标准属性

27:44.970 --> 27:45.970
那么我们看一下所有属性

27:45.970 --> 27:47.970
去询换它的所有属性

27:47.970 --> 27:48.970
那么所有的属性里边

27:48.970 --> 27:50.970
如果说

27:50.970 --> 27:51.970
这是我们的标准属性

27:51.970 --> 27:52.970
标准属性

27:52.970 --> 27:54.970
看一下你这个属性

27:54.970 --> 27:55.970
是不是大于-1的

27:55.970 --> 27:56.970
是不是大于-1的

27:56.970 --> 27:57.970
就是说

27:57.970 --> 27:58.970
你这个属性值

27:58.970 --> 27:59.970
是不是在这个数组里边

27:59.970 --> 28:01.970
是不是在这个数组里边

28:01.970 --> 28:02.970
当然我们其实

28:02.970 --> 28:03.970
这个数组里边

28:03.970 --> 28:05.970
也可以用这个include

28:05.970 --> 28:06.970
include 新的方法

28:06.970 --> 28:07.970
不过这个方法

28:07.970 --> 28:08.970
正在实验中

28:08.970 --> 28:10.970
可能有些些接种性问题

28:10.970 --> 28:11.970
那么这样子写也可以

28:11.970 --> 28:13.970
是不是包含key

28:13.970 --> 28:15.970
如果包含key表示一个标准属性

28:15.970 --> 28:16.970
这就是判断

28:16.970 --> 28:17.970
是否是标准属性

28:17.970 --> 28:19.970
那么所有的属性都满足

28:19.970 --> 28:20.970
它都是标准属性

28:20.970 --> 28:21.970
又是品面对象

28:21.970 --> 28:22.970
又是type 又是字母串

28:22.970 --> 28:24.970
ok 那么它就是一个标准的x

28:24.970 --> 28:25.970
那么这里

28:25.970 --> 28:26.970
要判断

28:26.970 --> 28:27.970
是不是标准x

28:27.970 --> 28:28.970
我们是不是可以利用这个方法

28:28.970 --> 28:29.970
if fsa

28:29.970 --> 28:30.970
对不对

28:30.970 --> 28:32.970
它是不是一个标准的x

28:32.970 --> 28:34.970
如果说它不是一个标准的x

28:34.970 --> 28:36.970
它的原代码就这样子写了

28:36.970 --> 28:38.970
如果说它不是一个标准的x

28:38.970 --> 28:39.970
那么怎么做呢

28:39.970 --> 28:41.970
它是这样子来处理的

28:41.970 --> 28:43.970
就像刚才我们记笔记的时候

28:43.970 --> 28:44.970
那么

28:44.970 --> 28:46.970
再进行这样的判断

28:46.970 --> 28:47.970
再进行这样的判断

28:47.970 --> 28:49.970
如果x是一个promise

28:49.970 --> 28:50.970
那么怎么样怎么样

28:50.970 --> 28:51.970
等它完成

28:51.970 --> 28:52.970
对不对

28:52.970 --> 28:53.970
等它完成

28:53.970 --> 28:54.970
所以说

28:54.970 --> 28:55.970
如果说它不是一个标准的x

28:55.970 --> 28:59.970
如果不是一个标准的x

29:00.970 --> 29:01.970
那么怎么办呢

29:01.970 --> 29:03.970
它可能就是promise的

29:03.970 --> 29:04.970
可能就是promise的

29:04.970 --> 29:05.970
那么我们这里

29:05.970 --> 29:06.970
它是这样子好多的

29:06.970 --> 29:07.970
就是说

29:07.970 --> 29:08.970
如果它不是一个标准的x

29:08.970 --> 29:10.970
我们这里看一下

29:10.970 --> 29:12.970
它是不是一个promise

29:12.970 --> 29:13.970
那么怎么来判断

29:13.970 --> 29:14.970
是不是一个promise的

29:14.970 --> 29:16.970
我们可以利用刚才安装的酷

29:16.970 --> 29:17.970
ispromise

29:17.970 --> 29:18.970
安装的酷

29:18.970 --> 29:19.970
就是ispromise

29:19.970 --> 29:21.970
这个酷里面提供的一个方法

29:21.970 --> 29:22.970
非常非常简单的方法

29:22.970 --> 29:23.970
就是判断它

29:23.970 --> 29:25.970
是不是一个就是promise

29:25.970 --> 29:28.970
如果说x是一个promise

29:28.970 --> 29:29.970
那怎么办呢

29:29.970 --> 29:32.970
我就把它当成promise来使用

29:32.970 --> 29:33.970
来加个z

29:33.970 --> 29:35.970
把这个promiseresolve的结果

29:35.970 --> 29:37.970
resolve的结果

29:37.970 --> 29:39.970
当成x来触发

29:39.970 --> 29:40.970
对吧

29:40.970 --> 29:42.970
把resolve的结果

29:42.970 --> 29:45.970
当成x来触发

29:45.970 --> 29:46.970
那么这里是不是可以利用

29:46.970 --> 29:47.970
store.dispatch

29:47.970 --> 29:49.970
你这里也可以解构一下

29:49.970 --> 29:51.970
这里我们用不到getState

29:51.970 --> 29:53.970
只需要dispatch就行了

29:53.970 --> 29:54.970
只需要dispatch就行了

29:54.970 --> 29:55.970
我们在这里扩起来

29:55.970 --> 29:56.970
把结构

29:56.970 --> 30:00.970
那么我们这里就是直接使用dispatch

30:00.970 --> 30:02.970
dispatch

30:02.970 --> 30:04.970
把这个x型触发出去

30:04.970 --> 30:05.970
对吧

30:05.970 --> 30:06.970
如果它x型本身

30:06.970 --> 30:07.970
给它的x型

30:07.970 --> 30:09.970
就是一个promise的话

30:09.970 --> 30:10.970
那么我就把它触发出去

30:10.970 --> 30:11.970
触发这个x型

30:11.970 --> 30:12.970
当然你看这个代码

30:12.970 --> 30:13.970
你可以减些成为dispatch

30:13.970 --> 30:14.970
对吧

30:14.970 --> 30:15.970
直接把dispatch这个函数

30:15.970 --> 30:16.970
扔进来也行

30:16.970 --> 30:17.970
也行

30:17.970 --> 30:18.970
也就运行这个函数

30:18.970 --> 30:20.970
那么当它resolve的时候

30:20.970 --> 30:21.970
把resolve的结果扔到这个函数

30:21.970 --> 30:22.970
作为参数

30:22.970 --> 30:23.970
扔进去

30:23.970 --> 30:24.970
运行这个函数

30:24.970 --> 30:25.970
好

30:25.970 --> 30:27.970
这是扔的情况

30:27.970 --> 30:28.970
那么

30:28.970 --> 30:30.970
如果说它不是promise

30:30.970 --> 30:31.970
就是它不是一个标准的x型

30:31.970 --> 30:32.970
又不是promise

30:32.970 --> 30:33.970
OK

30:33.970 --> 30:34.970
我们使用next

30:34.970 --> 30:35.970
那个是

30:35.970 --> 30:36.970
调用下一个

30:36.970 --> 30:37.970
调用下一个

30:37.970 --> 30:39.970
下一个就是dispatch

30:39.970 --> 30:41.970
把x型扔进去

30:41.970 --> 30:42.970
那我就不管了

30:42.970 --> 30:43.970
就是我就不管了

30:43.970 --> 30:45.970
那么整个把它返回

30:45.970 --> 30:47.970
它也跟那个sunk是一样的

30:47.970 --> 30:48.970
它最重要返回的

30:48.970 --> 30:49.970
那么这个逻辑是什么呢

30:49.970 --> 30:51.970
这个逻辑我们打个注释

30:51.970 --> 30:55.970
如果x型是一个promise

30:55.970 --> 31:00.970
则将其resolve的值

31:00.970 --> 31:03.970
resolve的值dispatch

31:03.970 --> 31:05.970
resolve的值进行分发

31:05.970 --> 31:07.970
否则怎么呢

31:07.970 --> 31:08.970
否则交

31:08.970 --> 31:10.970
不做任何处理

31:10.970 --> 31:11.970
不做任何处理

31:11.970 --> 31:14.970
交给下一个dispatch

31:14.970 --> 31:16.970
交给下一个中间键

31:16.970 --> 31:18.970
那么如果说

31:18.970 --> 31:19.970
它是promise

31:19.970 --> 31:21.970
它就不交给下一个中间键了

31:21.970 --> 31:23.970
直接自己去触发这个x型

31:23.970 --> 31:24.970
重新触发一次

31:24.970 --> 31:26.970
重新走一次整个流程

31:26.970 --> 31:29.970
它是标准的情况下

31:29.970 --> 31:32.970
如果它不是一个标准的x型

31:32.970 --> 31:33.970
如果它不是一个标准的x型

31:33.970 --> 31:35.970
它就进入下面的流程

31:35.970 --> 31:36.970
就是我们之前笔记里面

31:36.970 --> 31:37.970
记得这个流程

31:37.970 --> 31:40.970
它不是一个标准的x型

31:40.970 --> 31:42.970
那么看一下

31:42.970 --> 31:44.970
它是不是一个promise

31:44.970 --> 31:46.970
看一下它是不是一个promise

31:46.970 --> 31:48.970
如果说它的payload是一个promise的话

31:48.970 --> 31:50.970
那么就等待promise完成

31:50.970 --> 31:51.970
将它结构作为payload的触发

31:51.970 --> 31:53.970
如果说payload

31:53.970 --> 31:55.970
它不是promise的话

31:55.970 --> 31:58.970
那就交给下一个就行了

31:58.970 --> 32:00.970
它是这样的处理的方式

32:00.970 --> 32:02.970
所以说这里代码

32:02.970 --> 32:04.970
我们具体写的话就是这样的写

32:04.970 --> 32:05.970
我给它写出来

32:05.970 --> 32:06.970
解释起来不是很好写

32:06.970 --> 32:08.970
写出来就好理解了

32:08.970 --> 32:09.970
直接返回

32:09.970 --> 32:11.970
如果再判断一下

32:11.970 --> 32:14.970
它那个x型的payload

32:14.970 --> 32:16.970
payload是不是promise

32:16.970 --> 32:17.970
判断这个

32:17.970 --> 32:18.970
payload是不是promise

32:18.970 --> 32:20.970
如果说payload是一个promise的话

32:20.970 --> 32:21.970
怎么办呢

32:21.970 --> 32:23.970
我就可以返回这个东西

32:23.970 --> 32:27.970
x型payload

32:27.970 --> 32:30.970
等你完成

32:30.970 --> 32:32.970
等你完成之后我干吗呢

32:32.970 --> 32:33.970
你看我们这样子

32:33.970 --> 32:35.970
等你完成之后是不是得到一个值

32:35.970 --> 32:36.970
对不对

32:36.970 --> 32:38.970
得到一个值

32:38.970 --> 32:40.970
这个值呢

32:40.970 --> 32:41.970
等你完成之后

32:41.970 --> 32:42.970
我们会得到一个值

32:42.970 --> 32:43.970
resolve的一个值

32:43.970 --> 32:45.970
这个值呢把它作为payload的值

32:45.970 --> 32:47.970
把这个值作为payload的值

32:47.970 --> 32:49.970
它这样子来处理的

32:49.970 --> 32:50.970
于是呢

32:50.970 --> 32:51.970
这里

32:51.970 --> 32:52.970
把你

32:52.970 --> 32:54.970
把你就是完成的resolve的值

32:54.970 --> 32:56.970
得到当成payload的值

32:56.970 --> 32:58.970
你看之前是把resolve的值

32:58.970 --> 32:59.970
当成整个x型

32:59.970 --> 33:00.970
那么现在这里

33:00.970 --> 33:01.970
把resolve的值

33:01.970 --> 33:02.970
当成payload的值

33:02.970 --> 33:03.970
那么这个时候呢

33:03.970 --> 33:05.970
来去处罚x型

33:05.970 --> 33:06.970
dispatch

33:06.970 --> 33:07.970
处罚x型

33:07.970 --> 33:08.970
x型写什么呢

33:08.970 --> 33:10.970
x型就是把之前的x型

33:10.970 --> 33:11.970
把之前的x型展开

33:11.970 --> 33:12.970
这在x型里面

33:12.970 --> 33:13.970
可能有别的东西

33:13.970 --> 33:15.970
把之前的x型展开

33:15.970 --> 33:17.970
然后把payload的替换一下

33:17.970 --> 33:18.970
替换成什么呢

33:18.970 --> 33:20.970
替换成我们这个地方的payload的

33:20.970 --> 33:22.970
就是resolve的结果

33:22.970 --> 33:23.970
payload的

33:23.970 --> 33:24.970
重新去出发一次

33:24.970 --> 33:26.970
这是payload的是

33:26.970 --> 33:27.970
payload的就是

33:27.970 --> 33:29.970
它是一个Promise的情况

33:29.970 --> 33:30.970
那么这里呢

33:30.970 --> 33:31.970
其实它还做了一个处理

33:31.970 --> 33:32.970
就是说

33:32.970 --> 33:33.970
如果你成功的时候

33:33.970 --> 33:34.970
那么我把payload给你

33:34.970 --> 33:36.970
那么开始

33:36.970 --> 33:38.970
如果说你失败的时候

33:38.970 --> 33:39.970
失败的时候

33:39.970 --> 33:40.970
就是你reject的时候

33:40.970 --> 33:41.970
reject的时候

33:41.970 --> 33:42.970
这个时候呢

33:42.970 --> 33:43.970
它做了这么一种处理

33:43.970 --> 33:45.970
它还是dispatch

33:45.970 --> 33:47.970
还是dispatch

33:47.970 --> 33:49.970
还是dispatch

33:49.970 --> 33:50.970
dispatch呢

33:50.970 --> 33:52.970
它这里面处理的方式是这样子

33:52.970 --> 33:53.970
x型

33:53.970 --> 33:54.970
我们这里换一行

33:54.970 --> 33:57.730
换个行嘛

33:57.730 --> 33:59.730
那么x型展开

33:59.730 --> 34:01.730
然后payload变成

34:01.730 --> 34:03.730
payload变成error

34:03.730 --> 34:04.730
变成error

34:04.730 --> 34:05.730
然后还有一个属性

34:05.730 --> 34:06.730
叫error

34:06.730 --> 34:07.730
给大家多加了一个属性

34:07.730 --> 34:08.730
error2

34:08.730 --> 34:10.730
这是开启的情况

34:10.730 --> 34:11.730
开启的情况

34:11.730 --> 34:12.730
它就这样处理的

34:12.730 --> 34:14.730
它处理就是reject的情况

34:14.730 --> 34:15.730
它只是处理这个

34:15.730 --> 34:17.730
它只处理payload是x型的情况

34:17.730 --> 34:18.730
它只加了开启

34:18.730 --> 34:21.730
那么这种情况还没有加开启

34:21.730 --> 34:23.730
然后

34:23.730 --> 34:24.730
这就是

34:24.730 --> 34:25.730
这就是那个

34:25.730 --> 34:26.730
三目运创复的第二个位置

34:26.730 --> 34:27.730
对吧

34:27.730 --> 34:28.730
三目运创复的第二个位置

34:28.730 --> 34:29.730
那么如果说

34:29.730 --> 34:30.730
它不是promise

34:30.730 --> 34:32.730
它不是promise的话

34:32.730 --> 34:33.730
我们就next

34:33.730 --> 34:34.730
把x型传进去

34:34.730 --> 34:35.730
就完成了

34:35.730 --> 34:36.730
整个逻辑

34:36.730 --> 34:38.730
它代码就这么一点

34:38.730 --> 34:39.730
像这个意思

34:39.730 --> 34:40.730
FSA

34:40.730 --> 34:41.730
它在另一个库里边

34:41.730 --> 34:42.730
是一个

34:42.730 --> 34:43.730
另一个第三方库里边

34:43.730 --> 34:44.730
所以它整个代码

34:44.730 --> 34:46.730
只有这么一点点

34:46.730 --> 34:47.730
这是它的逻辑

34:47.730 --> 34:49.730
它的逻辑

34:49.730 --> 34:50.730
代码

34:50.730 --> 34:51.730
写的好像

34:51.730 --> 34:52.730
感觉有点绕

34:52.730 --> 34:53.730
因为这一块

34:53.730 --> 34:55.730
如果说你对promise那一块

34:55.730 --> 34:56.730
你叫很模糊的话

34:56.730 --> 34:58.730
那这一块肯定会比较绕

34:58.730 --> 34:59.730
因为promise

34:59.730 --> 35:00.730
它也是个坎

35:00.730 --> 35:02.730
学ES6的时候也是个坎

35:02.730 --> 35:04.730
那么这里就是

35:04.730 --> 35:05.730
底下的逻辑

35:05.730 --> 35:07.730
如果说它是一个标准的x型

35:07.730 --> 35:09.730
我进入这么一个逻辑处理

35:09.730 --> 35:10.730
那么看一下

35:10.730 --> 35:11.730
你是不是promise

35:11.730 --> 35:12.730
是不是promise等待你

35:12.730 --> 35:13.730
等待你完成

35:13.730 --> 35:14.730
完成过后

35:14.730 --> 35:15.730
把你完成的结果

35:15.730 --> 35:16.730
直接dispatch

35:16.730 --> 35:18.730
如果你不是一个promise的话

35:18.730 --> 35:19.730
我直接交给下一个

35:20.730 --> 35:21.730
那么

35:21.730 --> 35:24.730
如果说你不是一个标准的x型

35:24.730 --> 35:26.730
不是一个标准的x型

35:27.730 --> 35:28.730
是一个标准的x型

35:28.730 --> 35:30.730
如果说你是一个标准的x型

35:30.730 --> 35:32.730
那么我就进入这样的处理

35:32.730 --> 35:33.730
你看一下

35:33.730 --> 35:34.730
你是不是promise

35:34.730 --> 35:35.730
panel的是不是promise

35:35.730 --> 35:37.730
那么如果说panel的

35:37.730 --> 35:38.730
是promise的话

35:38.730 --> 35:39.730
我等待你

35:39.730 --> 35:40.730
完成

35:40.730 --> 35:41.730
完成过后

35:41.730 --> 35:42.730
把你完成的东西

35:42.730 --> 35:43.730
当成panel的

35:43.730 --> 35:45.730
重新出发一个x型

35:46.730 --> 35:47.730
那么如果说

35:47.730 --> 35:48.730
你在处理的过程中

35:48.730 --> 35:49.730
出现了问题

35:49.730 --> 35:50.730
出现了问题

35:50.730 --> 35:51.730
那么我就给你一个错误

35:51.730 --> 35:52.730
把你错误的东西

35:52.730 --> 35:53.730
当成panel的

35:53.730 --> 35:54.730
然后再加一个属性

35:54.730 --> 35:55.730
error 为true

35:55.730 --> 35:56.730
因为 error 为true

35:56.730 --> 35:57.730
它 error 的属性

35:57.730 --> 35:58.730
也是标准的

35:58.730 --> 35:59.730
FSE

35:59.730 --> 36:00.730
n里边的属性

36:00.730 --> 36:01.730
重新出发一次

36:02.730 --> 36:03.730
如果说你不是

36:03.730 --> 36:04.730
panel的不是promise

36:04.730 --> 36:05.730
那就是一个正常的x型

36:05.730 --> 36:07.730
那么我直接交给下个中间键

36:07.730 --> 36:08.730
对吧

36:08.730 --> 36:09.730
它就是这样子处理的

36:09.730 --> 36:10.730
保存

36:10.730 --> 36:11.730
保存过后

36:11.730 --> 36:12.730
咱们来看一下

36:12.730 --> 36:13.730
我看一下

36:13.730 --> 36:14.730
我们这边

36:14.730 --> 36:15.730
用成我们自己的

36:15.730 --> 36:19.170
用成我们自己的

36:19.170 --> 36:20.170
保存

36:21.170 --> 36:22.170
我这里停止了

36:22.170 --> 36:23.170
服务器停止了

36:23.170 --> 36:24.170
要start

36:27.860 --> 36:28.860
让它运行出来

36:28.860 --> 36:29.860
让它运行出来

36:29.860 --> 36:42.170
稍等一下

36:42.170 --> 36:43.170
总之呢

36:43.170 --> 36:45.170
reduce promise

36:45.170 --> 36:46.170
这个东西

36:46.170 --> 36:48.170
它无非就是

36:49.170 --> 36:50.170
它无非就是

36:50.170 --> 36:52.170
你可以允许你在那个

36:52.170 --> 36:53.170
action里边

36:53.170 --> 36:54.170
返回一个promise

36:54.170 --> 36:56.170
可以允许你返回一个promise

36:56.170 --> 36:57.170
就像这样子

36:57.170 --> 36:59.170
返回一个promise

36:59.170 --> 37:00.170
是一个异步函数

37:00.170 --> 37:01.170
返回一个promise就行了

37:01.170 --> 37:02.170
就得到一个promise

37:02.170 --> 37:04.170
你可以把promise作为action

37:04.170 --> 37:05.170
或者呢

37:05.170 --> 37:06.170
你可以用一个正常的action

37:06.170 --> 37:08.170
但是panel的是promise

37:08.170 --> 37:09.170
只要遇到了promise

37:09.170 --> 37:10.170
你就可以理解为

37:10.170 --> 37:11.170
它要等待

37:11.170 --> 37:12.170
前提条件呢

37:12.170 --> 37:14.170
它对这个

37:14.170 --> 37:16.170
对这个就是内向一个前提条件

37:16.170 --> 37:18.170
action的type 一个前提条件

37:18.170 --> 37:19.170
得是一个致不错

37:19.170 --> 37:20.170
我这里写错了

37:20.170 --> 37:22.170
漏大器找不到

37:22.170 --> 37:23.170
找不到某块漏大器

37:23.170 --> 37:24.170
我这里写错了

37:24.170 --> 37:26.170
漏大器应该是这样子

37:26.170 --> 37:27.170
这样子写的

37:28.170 --> 37:29.170
保存

37:29.170 --> 37:31.990
你看一下

37:31.990 --> 37:32.990
是不是仍然出发了

37:32.990 --> 37:33.990
对吧

37:33.990 --> 37:34.990
仍然出发了

37:34.990 --> 37:35.990
没问题吧

37:37.990 --> 37:38.990
最终

37:38.990 --> 37:39.990
数据都达到了

37:39.990 --> 37:40.990
对吧

37:40.990 --> 37:41.990
都达到了

37:41.990 --> 37:42.990
好

37:42.990 --> 37:43.990
这是关于这一块

37:43.990 --> 37:44.990
关于这一块

37:45.990 --> 37:46.990
反正这个东西

37:46.990 --> 37:47.990
了解就行了

37:47.990 --> 37:48.990
因为

37:48.990 --> 37:49.990
promise

37:49.990 --> 37:50.990
我确实在

37:50.990 --> 37:51.990
遇到了不多

37:51.990 --> 37:52.990
遇到了不多

37:52.990 --> 37:53.990
只是有

37:53.990 --> 37:54.990
有个别的学生

37:54.990 --> 37:55.990
在公司里面遇到这个东西

37:55.990 --> 37:56.990
因为我觉得

37:56.990 --> 37:57.990
他要说

37:57.990 --> 37:59.990
他跟那个桑克莱比较的话

37:59.990 --> 38:00.990
两个比较的话

38:00.990 --> 38:01.990
肯定桑克莱要好用一点

38:01.990 --> 38:03.990
而且桑克莱也好理解一点

38:03.990 --> 38:04.990
promise

38:04.990 --> 38:05.990
因为promise

38:05.990 --> 38:06.990
这个东西

38:06.990 --> 38:07.990
很多同学

38:07.990 --> 38:08.990
对promise本身

38:08.990 --> 38:09.990
就比较模糊

38:09.990 --> 38:10.990
加上这个

38:10.990 --> 38:11.990
在这样子一玩

38:11.990 --> 38:12.990
它就蒙了

38:12.990 --> 38:13.990
所以说

38:13.990 --> 38:14.990
这个东西

38:14.990 --> 38:15.990
实际上用的比较少一点

38:15.990 --> 38:16.990
在整个环境里面

38:16.990 --> 38:17.990
用的比较少一点

38:17.990 --> 38:18.990
好

38:18.990 --> 38:19.990
但是我们现在就讲了

38:19.990 --> 38:20.990
两种数据处理方案了

38:20.990 --> 38:21.990
对吧

38:21.990 --> 38:22.990
桑克和promise

