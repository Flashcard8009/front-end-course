WEBVTT

00:00.690 --> 00:09.000
上节课呢 咱们讲了那个 渲染过程中的 第一个过程

00:09.000 --> 00:15.000
就是当有新的节点产生的时候 那么它会 当然首次加载嘛

00:15.000 --> 00:19.000
首次加载的所有的节点 就是更节点了 它肯定是新的节点

00:19.000 --> 00:24.000
所以说 后边整个 这个 我们的节点数呢 全是全新的

00:24.000 --> 00:28.000
因此呢 新的节点是怎么来渲染的啊 我们上节课把它讲了

00:29.000 --> 00:33.000
这一课呢 我们来讲另外一个东西 就是更新节点 它怎么回事

00:37.380 --> 00:42.380
更新节点 就是说 这个节点呢 它不是新的节点啊

00:42.380 --> 00:46.380
它是之前已经存在的节点 你现在把它更新

00:46.380 --> 00:49.380
那么这个地方呢 该怎么来做

00:49.380 --> 00:52.380
因为我们研究的呢 其实就是这个虚的动物树

00:52.380 --> 00:56.380
你看 就是这个树啊 就是这个树形结构 就这种树形结构

00:56.380 --> 01:00.380
好 我们就研究的是 如果它某一个部分节点

01:00.380 --> 01:04.380
刚才之前我们研究的是全新的嘛 那么某一个节点如果更新了

01:04.380 --> 01:07.380
那么它应该怎么来做

01:07.380 --> 01:10.380
好 这里边呢 我们首先搞清楚一个问题

01:10.380 --> 01:14.380
节点什么时候会更新

01:14.380 --> 01:17.380
节点什么时候会更新呢

01:17.380 --> 01:19.380
什么时候呢 就两种情况

01:19.380 --> 01:23.380
按照我们目前学过的就是 就两种情况 没别的了

01:23.380 --> 01:30.380
哪两种情况呢 第一种就是更新的 更新的场景

01:30.380 --> 01:32.380
更新的场景

01:32.380 --> 01:36.380
哪两种情况呢 第一种

01:36.380 --> 01:40.380
第一种情况呢 就是重新调用Render

01:40.380 --> 01:45.380
重新调用React.Render

01:45.380 --> 01:51.380
就是完全重新生成节点树

01:51.380 --> 01:54.380
也就是虚的动物树 这是第一种情况

01:54.380 --> 01:57.380
咱们最早的时候啊 讲那个React的时候

01:57.380 --> 02:00.380
不是讲过什么那个倒计时 是吧 还记得吗

02:00.380 --> 02:04.380
咱们就是当时就是写了个寒树 包了一个React.Render

02:04.380 --> 02:07.380
然后每个一段时间重新调用一次这个方法

02:07.380 --> 02:09.380
这就会导致节点更新

02:09.380 --> 02:11.380
它之前有点节点 对吧

02:11.380 --> 02:13.380
我们之前说过 首次宣言的时候呢

02:13.380 --> 02:16.380
它会把这个节点树呢 保存起来

02:16.380 --> 02:19.380
它会把这个生成的虚的动物树

02:20.380 --> 02:23.380
把这个树呢 保存起来 以便后续使用

02:23.380 --> 02:26.380
所以说 首次加带的时候呢 它就会把保存起来

02:26.380 --> 02:29.380
那么后边呢 你再生成新的树的时候呢

02:29.380 --> 02:31.380
那么它会进行对比的更新

02:31.380 --> 02:33.380
这是第一种情况

02:33.380 --> 02:36.380
第二种情况呢 那就是最常见的了

02:36.380 --> 02:40.380
最常见的是什么 就是调用内组件

02:40.380 --> 02:42.380
就是在内组件中

02:44.380 --> 02:48.380
内组件中 调用什么 调用SetState

02:48.380 --> 02:52.380
对吧 那么这个时候呢 它也会发生更新

02:52.380 --> 02:55.380
就这两种情况 没别的了 没别的了

02:56.380 --> 02:59.380
那么到底触发哪个节点更新呢

02:59.380 --> 03:02.380
这两种情况呢 它是有点区别的

03:02.380 --> 03:05.380
比方说第一种情况 它触发的是哪个节点更新

03:05.380 --> 03:08.380
它触发的是根节点更新

03:08.380 --> 03:13.380
它这个触发根节点更新

03:13.380 --> 03:18.380
甭管你这个动物节点树是啥玩意儿 无所谓

03:18.380 --> 03:21.380
比方说这种 你再重新调轮轮之后

03:21.380 --> 03:24.380
它从根节点就开始更新 从这个节点开始

03:25.380 --> 03:28.380
那么另外一种情况呢 就是SetState

03:28.380 --> 03:31.380
在内组件里边调用这个玩意儿 SetState

03:31.380 --> 03:33.380
那么这个时候会触发哪个更新呢

03:33.380 --> 03:35.380
它会触发谁的更新

03:35.380 --> 03:39.380
那么就看一下 你这个 因为你在内组件里边调用SetState

03:40.380 --> 03:42.380
那么你一定是有一个这个内的对象

03:42.380 --> 03:44.380
在对象里边去调用的

03:44.380 --> 03:47.380
那比方说吧 咱们之前讲这个

03:47.380 --> 03:49.380
这个这种节点树的时候

03:50.380 --> 03:53.380
那么这里呢 不是有这么一个

03:53.380 --> 03:56.380
这里 这个节点树的时候

03:56.380 --> 03:58.380
不是有这么一个实力吗 对不对

03:58.380 --> 04:00.380
App的实力

04:00.380 --> 04:03.380
那么这个一定是在实力里边调用的吧

04:03.380 --> 04:05.380
你还能怎么调用的 对不对

04:05.380 --> 04:07.380
一个内组件吧 内组件一个对象吧

04:07.380 --> 04:09.380
一个内的对象 另外一个App

04:09.380 --> 04:11.380
它自动会帮你运行啊 这些东西

04:11.380 --> 04:14.380
我们之前说过 它什么时候会创立这个实力

04:14.380 --> 04:17.380
那么它在实力里边调用 比方说在这个实力里边

04:17.380 --> 04:19.380
调用那个SetState

04:19.380 --> 04:22.380
那么会触发谁的更新 是不是触发它的更新

04:22.380 --> 04:24.380
对吧 它会触发它的更新

04:24.380 --> 04:26.380
那么跟它有没有关系

04:26.380 --> 04:28.380
没有任何关系 跟它有什么关系的

04:28.380 --> 04:31.380
人家动的没动力 把别人更新了干嘛了

04:31.380 --> 04:34.380
所以它只会出发 从这个节点开始出发更新

04:34.380 --> 04:36.380
那么这个节点也是一样 比方说

04:36.380 --> 04:39.380
比方说 你调用的不是这里的SetState

04:39.380 --> 04:42.380
而调用的是这里的SetState

04:42.380 --> 04:44.380
那么它就会触发这里的更新

04:44.380 --> 04:47.380
它就会触发这里的更新 你看这意思吧

04:47.380 --> 04:50.380
不要说啊 那么你在这里调用SetState

04:50.380 --> 04:53.380
那么它会触发这个节点 从这个节点开始更新

04:53.380 --> 04:55.380
就什么个意思

04:55.380 --> 04:58.380
所以说为什么说 单项的数据流很重要呢

04:58.380 --> 05:00.380
你看一下这里更新

05:00.380 --> 05:03.380
如果说数据流有导致流动的话

05:03.380 --> 05:05.380
那么这就事情麻烦了

05:05.380 --> 05:08.380
那比方说 如果它更新了

05:08.380 --> 05:11.380
如果这个数据流可能会倒起来流动的话

05:11.380 --> 05:13.380
那么是不是也可能会影响它

05:13.380 --> 05:15.380
也可能会影响它 对不对

05:15.380 --> 05:18.380
所以都有可能会影响 没问题吧

05:18.380 --> 05:21.380
所以单项的数据流是非常非常重要的

05:21.380 --> 05:24.380
它会让整个数形结构变得非常简单 容易控制

05:24.380 --> 05:26.380
如果是更加复杂的双项数据流

05:26.380 --> 05:29.380
比方说它的数据可能会流向它的话

05:29.380 --> 05:31.380
那么它更新了 它就可能导致复杂点也更新

05:31.380 --> 05:33.380
那这个事情就麻烦了

05:33.380 --> 05:36.380
一是麻烦 二是它的效率会非常非常低

05:36.380 --> 05:40.380
这就是为什么会使用单项的数据流的原因

05:40.380 --> 05:43.380
包括5u 别看5u有什么VMOD

05:43.380 --> 05:46.380
但是5u的 它的本质上 它的数据流

05:46.380 --> 05:48.380
仍然是单项的数据流

05:48.380 --> 05:51.380
因为VMOD它实际上是一个余法堂 对吧

05:51.380 --> 05:53.380
这就是为什么需要单项的数据流

05:53.380 --> 05:57.380
它更新了 因为它的数据只会影响到后边的节点

05:57.380 --> 05:59.380
那么只会影响后边节点的更新

05:59.380 --> 06:00.380
它不会影响上边的

06:00.380 --> 06:04.380
大家可以看 发现了 上面的其实根本就没有什么变化

06:04.380 --> 06:06.380
好 这是关于这一点

06:06.380 --> 06:08.380
我们先把这一点说明

06:08.380 --> 06:11.380
就是在内组件中调用set state

06:11.380 --> 06:16.380
会导致该实力

06:16.380 --> 06:21.380
内组件 该这样说 在内组件的实力对象中

06:21.380 --> 06:26.380
调用set state 会导致该实力所在的

06:26.380 --> 06:31.380
所在的节点更新

06:31.380 --> 06:34.380
就是我们首先搞清楚 谁在更新 谁在更新

06:34.380 --> 06:37.380
两种情况 一个是你重新调用的Render

06:37.380 --> 06:39.380
谁更新呢 这个节点更新

06:39.380 --> 06:41.380
这个节点更新

06:41.380 --> 06:43.380
这是这种情况

06:43.380 --> 06:47.380
那么另外一种情况就是

06:47.380 --> 06:49.380
你调用一个实力的

06:49.380 --> 06:53.380
这里调用一个实力的就是set state

06:53.380 --> 06:56.380
它会导致实力所在的节点更新

06:56.380 --> 07:00.380
因为实力一定是附着在节点上面的

07:00.380 --> 07:01.380
它不可能单独存在

07:01.380 --> 07:03.380
因为这个实力也不是我们创建的

07:03.380 --> 07:08.380
是react本身 它在构建这个书的过程中创建的

07:08.380 --> 07:09.380
这是我们上里可讲的

07:09.380 --> 07:11.380
所以你在实力里面调用这个

07:11.380 --> 07:15.380
它会导致实力所在的节点进行更新

07:15.380 --> 07:18.380
那么这里我当然肯定要说set state

07:18.380 --> 07:19.380
从这里开始说

07:19.380 --> 07:21.380
当然这个是完全一样的

07:21.380 --> 07:23.380
关键是你要搞新的哪个更新

07:23.380 --> 07:25.380
那么这里我们把之前的代码的复制一下

07:25.380 --> 07:26.380
copy一下

07:26.380 --> 07:29.380
那么这里我们重新写一块代码

07:29.380 --> 07:31.380
重新写一块

07:31.380 --> 07:33.380
我们这样子写吧

07:33.380 --> 07:36.380
RCT

07:36.380 --> 07:40.380
这个class app里边

07:40.380 --> 07:42.380
有这么一个组件

07:42.380 --> 07:43.380
我这里不分文件了

07:43.380 --> 07:45.380
因为我们只是演示

07:45.380 --> 07:47.380
这里有一个类组件

07:47.380 --> 07:50.380
class comp a

07:50.380 --> 07:51.380
extends

07:51.380 --> 07:52.380
react

07:52.380 --> 07:54.380
component

07:54.380 --> 07:55.380
运行这个

07:55.380 --> 07:57.380
然后在

07:57.380 --> 08:00.380
它里边写上一个render

08:00.380 --> 08:02.380
返回

08:02.380 --> 08:07.380
div

08:07.380 --> 08:09.380
div里边有一个comp a

08:09.380 --> 08:11.380
comp b

08:11.380 --> 08:13.380
class复制一下

08:13.380 --> 08:15.380
comp b

08:15.380 --> 08:18.380
comp b它返回的就是一个hecomp b

08:19.380 --> 08:20.380
完了

08:20.380 --> 08:21.380
没了

08:21.380 --> 08:22.380
很简单对吧

08:22.380 --> 08:27.380
comp a返回的是一个hecomp a

08:27.380 --> 08:32.380
然后再返回一个comp b

08:32.380 --> 08:34.380
OK

08:34.380 --> 08:36.380
这样子就完成了对吧

08:36.380 --> 08:41.380
然后这里的app里面的comp a

08:41.380 --> 08:43.380
我们先把这个组件数画一下

08:43.380 --> 08:45.380
先画一下这个组件数

08:45.380 --> 08:47.380
这个组件数我相信大家

08:47.380 --> 08:49.380
这个时候应该有自己的能力

08:49.380 --> 08:50.380
把它画出来了

08:50.380 --> 08:51.380
OK

08:51.380 --> 08:53.380
我们这里的ppd里面加一个

08:53.380 --> 08:56.380
跟组件跟节点是谁的

08:56.380 --> 08:57.380
跟节点就毫无疑问

08:57.380 --> 08:58.380
跟前面的人一样的

08:58.380 --> 09:00.380
跟节点的话毫无疑问

09:00.380 --> 09:01.380
在index里面

09:01.380 --> 09:03.380
跟一点倒是个df

09:03.380 --> 09:04.380
但是没必要

09:04.380 --> 09:06.380
直接来个app就完成了

09:06.380 --> 09:08.380
我们现在就这样子写了

09:08.380 --> 09:11.380
这样子写

09:11.380 --> 09:13.380
跟一点是

09:13.380 --> 09:15.380
跟一点就是一个类组件

09:15.380 --> 09:16.380
一个类组件

09:16.380 --> 09:18.380
不是动物节点了

09:18.380 --> 09:20.380
跟节点就是

09:20.380 --> 09:23.380
类组件

09:23.380 --> 09:25.380
是组件节点

09:25.380 --> 09:26.380
什么组件节点呢

09:26.380 --> 09:27.380
是类组件

09:27.380 --> 09:31.840
app

09:31.840 --> 09:33.840
class

09:33.840 --> 09:34.840
app

09:34.840 --> 09:36.840
那么这里的是不是会创建

09:36.840 --> 09:37.840
类的对象

09:37.840 --> 09:39.840
app实力

09:39.840 --> 09:41.840
它会创建一个app的实力

09:41.840 --> 09:44.660
这是第一个

09:44.660 --> 09:45.660
跟节点

09:45.660 --> 09:46.660
我们把它画好

09:46.660 --> 09:47.660
不着急

09:47.660 --> 09:48.660
慢慢来

09:48.660 --> 09:50.660
然后app里面

09:50.660 --> 09:52.660
app里面有一个coma

09:52.660 --> 09:53.660
comb

09:53.660 --> 09:54.660
咱们把这样子

09:54.660 --> 09:56.660
把comb

09:56.660 --> 09:58.660
设成一个函数组件

09:58.660 --> 09:59.660
给大家一起看一下

09:59.660 --> 10:00.660
因为都是类似的

10:00.660 --> 10:01.660
都差不多的

10:01.660 --> 10:02.660
函数组件

10:05.660 --> 10:06.660
我想一想

10:06.660 --> 10:07.660
因为不然的话

10:07.660 --> 10:08.660
我再套一层德了

10:08.660 --> 10:09.660
我再套一层

10:09.660 --> 10:11.660
再套一个函数组件

10:11.660 --> 10:12.660
因为都是一样的道理

10:12.660 --> 10:14.660
道理其实是一样的

10:14.660 --> 10:16.660
compc

10:16.660 --> 10:17.660
或者说

10:17.660 --> 10:18.660
我把这个东西

10:18.660 --> 10:19.660
设成函数组件

10:20.660 --> 10:21.660
return

10:21.660 --> 10:23.660
这个是compc

10:23.660 --> 10:24.660
这个是compc

10:24.660 --> 10:25.660
return 这里

10:25.660 --> 10:26.660
返回div

10:26.660 --> 10:28.660
div 里面

10:28.660 --> 10:30.660
compc

10:30.660 --> 10:32.660
然后有一个就是

10:33.660 --> 10:34.660
comp

10:34.660 --> 10:37.170
这里是compb

10:37.170 --> 10:39.170
这里是compc

10:39.170 --> 10:41.170
这里是compc

10:43.170 --> 10:44.170
OK

10:44.170 --> 10:45.170
我们写的这么一种结构

10:45.170 --> 10:47.860
我看一下

10:47.860 --> 10:49.860
里面包含b

10:49.860 --> 10:50.860
第四个函数组件

10:50.860 --> 10:51.860
这些都无所谓

10:51.860 --> 10:52.860
给大家一起看一下

10:52.860 --> 10:53.860
这个结构

10:53.860 --> 10:54.860
然后我们现在

10:54.860 --> 10:55.860
把这个结构画出来

10:56.860 --> 10:57.860
App的实力

10:57.860 --> 10:59.860
这是根结点

11:00.860 --> 11:01.860
根结点

11:01.860 --> 11:02.860
根结点

11:02.860 --> 11:03.860
就手指串的时候

11:03.860 --> 11:05.860
他肯定会选择根结点

11:05.860 --> 11:07.860
然后根结点里面有啥

11:07.860 --> 11:08.860
根结点里面有啥

11:08.860 --> 11:09.860
App里面

11:09.860 --> 11:10.860
到时候有Render

11:10.860 --> 11:12.860
他会调动Render

11:12.860 --> 11:13.860
我之前讲过的

11:13.860 --> 11:14.860
会设成一个动物结点

11:14.860 --> 11:15.860
div

11:15.860 --> 11:17.860
这是个动物结点

11:17.860 --> 11:18.860
什么结点

11:18.860 --> 11:19.860
什么结点

11:19.860 --> 11:20.860
是个div

11:20.860 --> 11:22.860
是个div

11:26.860 --> 11:28.860
关键是我怕画画不下

11:28.860 --> 11:30.860
我怕你这个动物结点

11:30.860 --> 11:32.860
按你说肯定是要画的

11:32.860 --> 11:33.860
肯定是要画的

11:33.860 --> 11:35.860
我怕有点画不下

11:36.860 --> 11:37.860
就这样吧

11:37.860 --> 11:38.860
试一下

11:38.860 --> 11:39.860
动物结点

11:39.860 --> 11:41.860
那肯定会生成真舍动

11:41.860 --> 11:42.860
真舍动

11:42.860 --> 11:44.860
把颜色扶持一下

11:45.860 --> 11:47.860
它会生成真舍动

11:47.860 --> 11:48.860
真舍动物对象

11:48.860 --> 11:49.860
div

11:50.860 --> 11:53.240
OK

11:53.240 --> 11:54.240
好 又来

11:54.240 --> 11:57.240
然后得到的是一个Comp-A

11:57.240 --> 11:59.240
Comp-A结点

11:59.240 --> 12:01.740
Comp-A

12:10.700 --> 12:11.700
连起来

12:11.700 --> 12:12.700
这里是呢

12:12.700 --> 12:13.700
组建结点

12:14.700 --> 12:15.700
这里是

12:16.700 --> 12:17.700
Comp

12:17.700 --> 12:18.700
就是Class

12:18.700 --> 12:20.700
Comp-A

12:20.700 --> 12:21.700
然后它当然

12:21.700 --> 12:23.700
它会生成一个Comp-A的实力

12:24.700 --> 12:25.700
这个毫不意味

12:26.700 --> 12:27.700
然后呢

12:27.700 --> 12:29.700
又来渲染这个结点

12:29.700 --> 12:30.700
这个结点呢

12:30.700 --> 12:31.700
结构数的时候呢

12:31.700 --> 12:32.700
它里面有个什么div

12:32.700 --> 12:33.700
H1对吧

12:33.700 --> 12:37.270
我们就一起写了

12:37.270 --> 12:39.270
这里会生成

12:39.270 --> 12:41.270
这个div

12:41.270 --> 12:43.270
那么它会生成一个真舍动

12:43.270 --> 12:44.270
然后呢

12:44.270 --> 12:46.270
这个div里面有个H1

12:46.270 --> 12:48.270
又是个动物结点

12:49.270 --> 12:51.270
它会生成一个H1

12:51.270 --> 12:52.270
H1

12:52.270 --> 12:53.270
自然而然

12:53.270 --> 12:54.270
它会生成一个真舍动

12:54.270 --> 12:56.270
那么它有这么一个结点

12:56.270 --> 13:03.460
这样连过来

13:03.460 --> 13:04.460
不着急 咱们慢慢讲

13:04.460 --> 13:05.460
因为这一块呢

13:05.460 --> 13:07.460
不太容易讲清楚

13:07.460 --> 13:10.460
然后H1里面有一个

13:10.460 --> 13:11.460
有一个凶器结点

13:11.460 --> 13:12.460
Comp-B

13:12.460 --> 13:13.460
Comp-B是不是又是一个

13:13.460 --> 13:14.460
组建结点

13:14.460 --> 13:16.460
它又是个组建结点

13:16.460 --> 13:18.460
这是Comp-B的实力

13:18.460 --> 13:20.460
Comp-B

13:20.460 --> 13:23.600
OK

13:23.600 --> 13:25.600
拿个线

13:25.600 --> 13:27.600
这是Comp-B这个结点

13:27.600 --> 13:29.600
Comp-B里面又有啥呢

13:29.600 --> 13:30.600
你看一下

13:30.600 --> 13:32.600
Comp-B里面它是个函数结点

13:32.600 --> 13:34.600
Comp-B不是内组建

13:34.600 --> 13:35.600
它不是内组建

13:35.600 --> 13:36.600
它是函数组建

13:36.600 --> 13:37.600
放个线

13:37.600 --> 13:39.600
它本质是一样的

13:40.600 --> 13:41.600
Comp-B

13:41.600 --> 13:42.600
它就没有实力的

13:42.600 --> 13:44.600
它是个函数结点

13:44.600 --> 13:46.600
那么它直接调用这个函数的Render就完事了

13:46.600 --> 13:47.600
调用这个函数的Render

13:47.600 --> 13:49.600
是不是又达到一组结点

13:49.600 --> 13:50.600
对吧

13:50.600 --> 13:51.600
又达到一组结点

13:51.600 --> 13:52.600
然后呢

13:52.600 --> 13:54.600
它又有div 又有H1

13:54.600 --> 14:01.070
又有一个

14:01.070 --> 14:03.070
这一块整个复制一下

14:03.070 --> 14:08.460
它是这样子的

14:11.020 --> 14:12.020
看一下

14:12.020 --> 14:13.020
然后这样子的

14:13.020 --> 14:15.020
然后这里的

14:15.020 --> 14:17.020
先连过来

14:17.020 --> 14:20.910
Comp-B里面

14:20.910 --> 14:21.910
Comp-B里面有什么

14:21.910 --> 14:23.910
有div里面有H1

14:23.910 --> 14:24.910
看一下

14:24.910 --> 14:25.910
Comp-B里面有什么

14:25.910 --> 14:28.910
有div里面有H1

14:28.910 --> 14:29.910
H1

14:29.910 --> 14:31.910
然后又有什么

14:31.910 --> 14:32.910
H1里面还有文字

14:32.910 --> 14:33.910
我实在没发话了

14:33.910 --> 14:38.670
H1里面还有文字结点的

14:38.670 --> 14:39.670
因为在画的话

14:39.670 --> 14:41.670
这个图就变得很小了

14:41.670 --> 14:43.670
这个图变得非常非常小了

14:43.670 --> 14:45.670
这是文本结点

14:45.670 --> 14:47.670
文本结点里面有个什么

14:47.670 --> 14:49.670
一个就是Comp

14:49.670 --> 14:52.670
这里是Comp-A

14:52.670 --> 14:53.670
Comp-A

14:53.670 --> 14:55.670
这是归生成争设多

14:55.670 --> 14:56.670
那么同样的

14:56.670 --> 14:58.670
这个Comp-B结点里面

14:58.670 --> 14:59.670
div H1里面

14:59.670 --> 15:00.670
所以也有文本结点

15:00.670 --> 15:01.670
我真的是画不下了

15:01.670 --> 15:02.670
真的是画不下了

15:02.670 --> 15:04.670
那么大家知道这么一个意识就行了

15:04.670 --> 15:05.670
那么下面一个

15:05.670 --> 15:07.670
内组结点

15:07.670 --> 15:09.670
是Comp-C

15:10.670 --> 15:11.670
Comp-C

15:11.670 --> 15:12.670
不行

15:12.670 --> 15:13.670
还必须要把它画完

15:13.670 --> 15:15.670
不画完一会儿不画解释

15:15.670 --> 15:16.670
得画完

15:16.670 --> 15:18.670
我不得把它画完

15:18.670 --> 15:19.670
Comp-C

15:19.670 --> 15:21.670
这是Comp-C的实力

15:21.670 --> 15:23.670
因为Comp-C是内组结

15:23.670 --> 15:25.670
就Comp-C还有个实力

15:25.670 --> 15:27.670
Comp-B里面有Comp-C

15:27.670 --> 15:29.670
那么这里Comp-C的实力

15:29.670 --> 15:30.670
那么我接着下一张画

15:30.670 --> 15:32.670
下一张图片画

15:32.670 --> 15:35.670
这里我们把这个复制过来

15:35.670 --> 15:40.970
必须要去接着画

15:43.410 --> 15:45.410
接着上面

15:46.410 --> 15:49.410
然后Comp-C

15:49.410 --> 15:51.410
H1下面是不是还有动物结点

15:51.410 --> 15:56.580
文本结点

15:56.580 --> 15:58.580
这里还有文本结点

15:58.580 --> 16:00.580
这里写的是Comp-C

16:01.580 --> 16:02.580
这里是Comp-B

16:02.580 --> 16:04.580
Comp-B的H1

16:04.580 --> 16:06.580
H1是Comp-B的div H1

16:06.580 --> 16:08.580
H1里面写的是Comp-B

16:08.580 --> 16:11.580
还有一个组件结点Comp-C

16:11.580 --> 16:12.580
接着上面的

16:12.580 --> 16:13.580
我把箭头画出来

16:13.580 --> 16:17.340
它是接着上面的

16:18.340 --> 16:19.340
Comp-C

16:19.340 --> 16:20.340
Comp-C

16:20.340 --> 16:22.340
它是Comp-C的实力

16:22.340 --> 16:24.340
里面也有东西

16:24.340 --> 16:25.340
里面有什么东西

16:25.340 --> 16:26.340
也是一样的

16:26.340 --> 16:28.340
有什么div H1

16:28.340 --> 16:29.340
OK

16:29.340 --> 16:30.340
它有这个

16:30.340 --> 16:35.380
它有div

16:35.380 --> 16:36.380
有H1

16:36.380 --> 16:42.820
但是它里面就没有组件了

16:42.820 --> 16:43.820
这样子

16:43.820 --> 16:45.820
它有这么一个结点

16:45.820 --> 16:46.820
行了

16:46.820 --> 16:48.820
咱们就差不多了

16:48.820 --> 16:49.820
画完了

16:49.820 --> 16:51.820
整个动物数

16:51.820 --> 16:52.820
就全部画完了

16:52.820 --> 16:53.820
这是Comp-C

16:53.820 --> 16:54.820
看一下

16:54.820 --> 16:56.820
先把之前生成的动物结构

16:56.820 --> 16:57.820
看清楚

16:57.820 --> 16:59.820
所以大家可以发现

16:59.820 --> 17:00.820
通过这些地址

17:00.820 --> 17:02.820
我画这一图就可以发现

17:02.820 --> 17:04.820
其实在rex里面

17:04.820 --> 17:06.820
你看上去好像没有嵌到什么

17:06.820 --> 17:08.820
只要嵌到层次已经非常多了

17:08.820 --> 17:10.820
已经非常非常多了

17:10.820 --> 17:12.820
它层次是非常深的

17:12.820 --> 17:13.820
那么这是我们

17:13.820 --> 17:17.820
第一次生成的动物数

17:17.820 --> 17:19.820
第一次生成的动物数

17:19.820 --> 17:21.820
然后现在我做这么一件事情

17:21.820 --> 17:23.820
我在comp-a里面

17:23.820 --> 17:25.820
我写这么一句话

17:25.820 --> 17:27.820
它有一个state

17:27.820 --> 17:29.820
一个state

17:31.820 --> 17:33.820
state里面有一个a

17:33.820 --> 17:35.820
一个数字a

17:35.820 --> 17:36.820
123

17:36.820 --> 17:38.820
然后b了abc

17:38.820 --> 17:40.820
有这么两个东西

17:40.820 --> 17:41.820
这么两个东西

17:41.820 --> 17:42.820
没问题吧

17:42.820 --> 17:44.820
咱们写这么两个东西

17:44.820 --> 17:45.820
然后

17:45.820 --> 17:47.820
我在a起e里面

17:47.820 --> 17:49.820
输出那个数字a

17:49.820 --> 17:50.820
resstate

17:50.820 --> 17:51.820
叫a

17:51.820 --> 17:53.820
输出这个数字a

17:53.820 --> 17:56.820
然后我们再把b

17:56.820 --> 17:58.820
又传给comp-b

17:58.820 --> 17:59.820
看着

17:59.820 --> 18:00.820
我们做这么一系列的事情

18:00.820 --> 18:02.820
在a起里面输出a

18:02.820 --> 18:03.820
这个很简单

18:03.820 --> 18:04.820
这个第一次渲染的时候

18:04.820 --> 18:05.820
a是啥

18:05.820 --> 18:06.820
a就不是就是123吗

18:06.820 --> 18:07.820
数字123

18:07.820 --> 18:08.820
所以说第一次渲染的时候

18:08.820 --> 18:09.820
这个节点

18:09.820 --> 18:11.820
a起里面就输出了123

18:11.820 --> 18:12.820
我们们节点在这里

18:12.820 --> 18:13.820
就现在是123

18:13.820 --> 18:14.820
没问题吧

18:14.820 --> 18:15.820
好

18:15.820 --> 18:17.820
然后我们这里comp-b里面

18:17.820 --> 18:18.820
comp-b里面

18:18.820 --> 18:21.820
我们把b传过去

18:21.820 --> 18:23.820
它有一个参数n

18:23.820 --> 18:26.820
n来自于resstate b

18:26.820 --> 18:28.820
给它传过去

18:28.820 --> 18:29.820
传过去

18:29.820 --> 18:31.820
传过去过后n

18:31.820 --> 18:33.820
那么这里是不是可以使用n

18:33.820 --> 18:34.820
那么这里比方说

18:34.820 --> 18:35.820
我们输出n

18:35.820 --> 18:36.820
res

18:36.820 --> 18:37.820
probs

18:37.820 --> 18:38.820
需要参数

18:38.820 --> 18:40.820
probs

18:40.820 --> 18:41.820
这里

18:41.820 --> 18:42.820
probs是第2

18:42.820 --> 18:43.820
第2n

18:43.820 --> 18:44.820
把n显示出来

18:44.820 --> 18:45.820
那么n

18:45.820 --> 18:46.820
这个b一开始是abc

18:46.820 --> 18:47.820
对吧

18:47.820 --> 18:48.820
在渲染的时候

18:48.820 --> 18:49.820
全部就确定了

18:49.820 --> 18:50.820
这些都是表达式

18:50.820 --> 18:51.820
它会把表达式的值算出来

18:51.820 --> 18:53.820
那么这个b算出来是abc

18:53.820 --> 18:55.820
把abc作为属性传过去了

18:55.820 --> 18:56.820
那么这里显示啥

18:56.820 --> 18:57.820
是不是显示abc

18:57.820 --> 18:58.820
好

18:58.820 --> 18:59.820
首次渲染的时候

18:59.820 --> 19:00.820
那里看这里

19:00.820 --> 19:02.820
这里就渲染出了abc

19:02.820 --> 19:04.820
渲染出了abc

19:04.820 --> 19:06.820
这个意思吧

19:06.820 --> 19:07.820
没问题吧

19:07.820 --> 19:09.820
应该没问题

19:09.820 --> 19:11.820
渲染出来abc

19:11.820 --> 19:13.820
然后这里comp-c我就不管了

19:13.820 --> 19:14.820
但comp-c在传个属性

19:14.820 --> 19:15.820
都无所谓

19:15.820 --> 19:16.820
都无所谓

19:16.820 --> 19:17.820
那传一个吧

19:17.820 --> 19:18.820
传一个

19:18.820 --> 19:19.820
comp-c也有一个n

19:19.820 --> 19:21.820
我把自己的属性n也传过去

19:21.820 --> 19:22.820
那么这里输出n

19:22.820 --> 19:23.820
这里输出n

19:23.820 --> 19:24.820
probs

19:24.820 --> 19:25.820
n

19:25.820 --> 19:26.820
也行吧

19:26.820 --> 19:27.820
也行吧

19:27.820 --> 19:29.820
那么comp-c现在是不是也是abc

19:29.820 --> 19:31.820
comp-c这里的文明节点也是abc

19:31.820 --> 19:32.820
于是我现在给节点

19:32.820 --> 19:33.820
抓上状态了

19:33.820 --> 19:34.820
但是

19:34.820 --> 19:36.820
跟之前并没有什么区别

19:36.820 --> 19:37.820
并没有任何的区别

19:37.820 --> 19:38.820
我只是给它

19:38.820 --> 19:40.820
加上一个状态

19:40.820 --> 19:41.820
好

19:41.820 --> 19:42.820
接下来我们做这么一件事

19:42.820 --> 19:43.820
在comp-n里面

19:43.820 --> 19:44.820
再加一个东西

19:44.820 --> 19:45.820
加个按钮

19:45.820 --> 19:46.820
button

19:46.820 --> 19:48.820
当我点击的时候

19:48.820 --> 19:49.820
我干嘛了

19:49.820 --> 19:50.820
我改变状态

19:50.820 --> 19:51.820
当我点击的时候

19:51.820 --> 19:53.820
点击

19:53.820 --> 19:54.820
该出这个事件

19:54.820 --> 19:55.820
onclick

19:56.820 --> 19:58.820
当我们点击这个按钮的时候

19:58.820 --> 19:59.820
改变状态

20:00.820 --> 20:02.820
那么这里的按钮里面

20:02.820 --> 20:03.820
它是

20:03.820 --> 20:05.820
用这个zset state

20:05.820 --> 20:07.820
改变状态

20:07.820 --> 20:08.820
改变状态改成了

20:08.820 --> 20:10.820
把a改成321

20:10.820 --> 20:11.820
1

20:11.820 --> 20:13.820
b改成bcd

20:13.820 --> 20:15.820
bca

20:15.820 --> 20:17.820
acba

20:18.820 --> 20:19.820
好就改状态

20:19.820 --> 20:20.820
那么一开始

20:20.820 --> 20:21.820
手指渲染的时候

20:21.820 --> 20:22.820
它是不是要渲染按钮

20:22.820 --> 20:23.820
对吧

20:23.820 --> 20:24.820
是不是要渲染按钮

20:24.820 --> 20:25.820
ok

20:25.820 --> 20:26.820
那么手指渲染的时候

20:26.820 --> 20:27.820
comp-n里面

20:27.820 --> 20:29.820
除了一个h1

20:29.820 --> 20:30.820
comp-b之外

20:30.820 --> 20:31.820
它还有一个东西

20:31.820 --> 20:32.820
还有一个按钮

20:32.820 --> 20:34.820
把按钮i带着画出来

20:35.820 --> 20:36.820
所以大家可以想象得到

20:36.820 --> 20:37.820
这种动作

20:37.820 --> 20:39.820
真的是不简单

20:39.820 --> 20:40.820
所以大家想象得那么简单

20:40.820 --> 20:41.820
这个书

20:41.820 --> 20:43.820
至少它的结构很深

20:43.820 --> 20:45.820
这里是

20:45.820 --> 20:46.820
动物节点

20:46.820 --> 20:47.820
什么节点呢

20:47.820 --> 20:48.820
是button

20:48.820 --> 20:49.820
对吧

20:49.820 --> 20:50.820
button

20:50.820 --> 20:51.820
那么它会生成真实动

20:51.820 --> 20:53.820
会生成真实动

20:53.820 --> 20:54.820
那么它下面还不是

20:54.820 --> 20:55.820
是不是还有文明节点

20:55.820 --> 20:56.820
对吧

20:56.820 --> 20:57.820
点击

20:57.820 --> 21:00.650
点击

21:00.650 --> 21:01.650
点击就这么两个字

21:01.650 --> 21:03.650
也会生成真实动

21:04.650 --> 21:05.650
好

21:05.650 --> 21:06.650
这就是这个节点

21:06.650 --> 21:07.650
就行了

21:07.650 --> 21:08.650
好那么一会

21:08.650 --> 21:09.650
我们点

21:09.650 --> 21:10.650
就会点按钮

21:10.650 --> 21:11.650
你说现在不会

21:11.650 --> 21:12.650
产生更新

21:12.650 --> 21:13.650
你只是注册的时间

21:13.650 --> 21:14.650
你还没有点它

21:14.650 --> 21:15.650
好

21:15.650 --> 21:16.650
接下来

21:16.650 --> 21:18.650
我们要研究的是什么呢

21:18.650 --> 21:19.650
就逐渐

21:19.650 --> 21:20.650
节点数已经画出来了

21:20.650 --> 21:22.650
分成两瓶在画的

21:22.650 --> 21:23.650
我真的画不下了

21:23.650 --> 21:24.650
大家可以

21:24.650 --> 21:25.650
为了分析方便

21:25.650 --> 21:26.650
我建议大家

21:26.650 --> 21:27.650
可以在

21:27.650 --> 21:28.650
你拿一张纸

21:28.650 --> 21:29.650
出来

21:29.650 --> 21:30.650
自己画一下

21:30.650 --> 21:31.650
用纸画的话还蛮方便

21:31.650 --> 21:32.650
自己画一下

21:32.650 --> 21:33.650
哪个是组件

21:33.650 --> 21:34.650
哪个是内组件

21:34.650 --> 21:35.650
哪个是韩式组件

21:35.650 --> 21:37.650
那么内组件会生成实力

21:37.650 --> 21:38.650
实力附着在

21:38.650 --> 21:39.650
节点之上

21:39.650 --> 21:40.650
然后呢

21:45.650 --> 21:47.650
然后哪些是动物节点

21:47.650 --> 21:48.650
把全部画出来

21:48.650 --> 21:49.650
画出来

21:49.650 --> 21:50.650
方便我们后面分析

21:50.650 --> 21:51.650
因为我自己实在画不下了

21:51.650 --> 21:52.650
好

21:52.650 --> 21:53.650
接下来

21:53.650 --> 21:54.650
我们把它运行出来

21:54.650 --> 21:55.650
我们要干嘛

21:55.650 --> 21:56.650
你觉得我要干嘛

21:56.650 --> 21:57.650
我肯定要点按钮

21:57.650 --> 21:58.650
对吧

21:58.650 --> 21:59.650
我们就研究的是

21:59.650 --> 22:00.650
点了按钮之后

22:00.650 --> 22:02.650
这次状态发生改变

22:02.650 --> 22:03.650
它要干嘛

22:03.650 --> 22:04.650
它要干嘛

22:04.650 --> 22:06.650
那么这里边的情况

22:06.650 --> 22:07.650
非常多

22:07.650 --> 22:08.650
我们一个个来分析

22:12.730 --> 22:13.730
首先我们说一下

22:13.730 --> 22:15.730
当我们一会点了按钮的时候

22:15.730 --> 22:17.730
调用的是哪个对象的set state

22:17.730 --> 22:19.730
调用的是哪个对象的

22:19.730 --> 22:21.730
哪个对象的set state

22:21.730 --> 22:23.730
你看一下这个书里边

22:23.730 --> 22:24.730
你只最好在纸上画一下

22:24.730 --> 22:26.730
画一下你看一下在纸上

22:26.730 --> 22:28.730
对到哪个实力的set state

22:28.730 --> 22:30.730
是不是对应到它的

22:30.730 --> 22:31.730
对吧

22:31.730 --> 22:32.730
看不开这个实力对象里边了

22:32.730 --> 22:33.730
我们在这个对象里边

22:33.730 --> 22:35.730
调用了set state

22:35.730 --> 22:36.730
因此呢

22:36.730 --> 22:38.730
我们到时候更新的时候

22:38.730 --> 22:40.730
可以从哪个节点开始更新

22:40.730 --> 22:42.730
是不是从这个节点

22:42.730 --> 22:43.730
对吧

22:43.730 --> 22:44.730
从这个节点开始更新

22:44.730 --> 22:46.730
那么跟之前的节点有没有关系

22:46.730 --> 22:48.730
没有任何关系啊

22:48.730 --> 22:49.730
一会我们就开始

22:49.730 --> 22:51.730
要从这个节点开始更新了

22:51.730 --> 22:53.730
那如果一会整个调用Render的话

22:53.730 --> 22:55.730
那就是从这个跟节点开始更新

22:55.730 --> 22:57.730
就从这个节点开始更新

22:57.730 --> 23:00.730
就是你首先当务之急了

23:00.730 --> 23:02.730
手当起冲的你是要知道

23:02.730 --> 23:04.730
你更新的是哪个节点

23:04.730 --> 23:06.730
你如果更新了哪个节点都不知道

23:06.730 --> 23:08.730
肯定是搞不清楚后边流程了

23:08.730 --> 23:10.730
那么我们刚才都写了

23:10.730 --> 23:13.730
一个是Render从跟节点开始更新

23:13.730 --> 23:15.730
那么这个人是

23:15.730 --> 23:18.730
会导致该实力所调的节点更新

23:18.730 --> 23:20.730
这里就是触发跟节点更新

23:20.730 --> 23:22.730
那么这里会导致该实力

23:22.730 --> 23:24.730
所调的节点更新

23:24.730 --> 23:26.730
那么接下来我们来看一下

23:26.730 --> 23:27.730
这里我们点击按钮

23:27.730 --> 23:28.730
当点击里面这个样子

23:28.730 --> 23:30.730
我们来看一下发生了什么事

23:30.730 --> 23:32.730
整个过程是什么样子的

23:32.730 --> 23:33.730
那么这个时候呢

23:33.730 --> 23:34.730
我们刚才说了

23:34.730 --> 23:36.730
不同的情况会有不同的节点

23:36.730 --> 23:37.730
开始更新

23:37.730 --> 23:39.730
那么更新的时候呢

23:39.730 --> 23:42.730
下面就是说最重要的地方了

23:42.730 --> 23:45.730
节点的更新

23:45.730 --> 23:46.730
节点的更新

23:46.730 --> 23:48.730
它是怎么更新的

23:48.730 --> 23:50.730
它到底是怎么来更新节点的

23:50.730 --> 23:52.730
它这里首先

23:52.730 --> 23:55.730
分为两种情况

23:55.730 --> 23:57.730
第一种情况

23:57.730 --> 23:59.730
就是如果

23:59.730 --> 24:03.730
调用的是React

24:03.730 --> 24:05.730
Done.Render

24:05.730 --> 24:07.730
如果你调用的是这个

24:07.730 --> 24:09.730
进入

24:09.730 --> 24:11.730
跟节点

24:11.730 --> 24:13.730
跟节点的

24:13.730 --> 24:16.730
就是对比更新

24:16.730 --> 24:18.730
对比更新跟节点

24:18.730 --> 24:19.730
我们疑惑再说

24:19.730 --> 24:21.730
怎么来对比更新跟节点

24:21.730 --> 24:23.730
对比更新节点

24:23.730 --> 24:24.730
那么

24:24.730 --> 24:25.730
其实不一定是跟节点

24:25.730 --> 24:26.730
可能是任何其他节点

24:26.730 --> 24:27.730
只要出现了对比更新

24:27.730 --> 24:30.730
它是怎么样的一个过程

24:30.730 --> 24:32.730
所以说我们把它叫做

24:32.730 --> 24:34.730
把对比的过程

24:34.730 --> 24:35.730
对比的过程

24:35.730 --> 24:37.730
叫做Deep

24:37.730 --> 24:38.730
所以我们平时说的Deep

24:38.730 --> 24:40.730
算法就是对比的过程

24:40.730 --> 24:42.730
这是第一种情况

24:42.730 --> 24:43.730
第二种情况是

24:43.730 --> 24:45.730
如果你调用的是

24:45.730 --> 24:47.730
SetState

24:47.730 --> 24:48.730
稍微复杂一点

24:48.730 --> 24:50.730
如果你调用的是SetState

24:50.730 --> 24:52.730
那么它会做这么几件事

24:52.730 --> 24:57.230
第一件事

24:57.230 --> 24:59.230
做什么呢

24:59.230 --> 25:00.230
如果你调用的是SetState

25:00.230 --> 25:01.230
那么一定是调用了

25:01.230 --> 25:03.230
某一个组建的SetState

25:03.230 --> 25:04.230
比方说调用它的SetState

25:04.230 --> 25:05.230
对吧

25:05.230 --> 25:07.230
我们刚才就是调用它的SetState

25:07.230 --> 25:10.230
比方说我们把它调一个红色

25:10.230 --> 25:12.230
调用的是它的SetState

25:12.230 --> 25:13.230
于是它干嘛呢

25:13.230 --> 25:15.230
它会做这么一些事情

25:15.230 --> 25:20.230
首先运行生命周期函数

25:20.230 --> 25:22.230
因为SetState一定是在

25:22.230 --> 25:23.230
那一组建里边

25:23.230 --> 25:24.230
不可能在函数组建里边

25:24.230 --> 25:25.230
你在函数组建里边

25:25.230 --> 25:27.230
怎么去调用SetState呢

25:27.230 --> 25:28.230
它第一件事

25:28.230 --> 25:29.230
运行生命周期函数

25:29.230 --> 25:31.230
什么函数呢

25:31.230 --> 25:32.230
我们把生命周期打开

25:32.230 --> 25:33.230
不着急

25:33.230 --> 25:34.230
慢点来

25:34.230 --> 25:35.230
它的过程比看

25:35.230 --> 25:36.230
一下子就瞬间完了

25:36.230 --> 25:38.230
实际上它做了很多很多的事情

25:38.230 --> 25:39.230
是不是这个函数

25:39.230 --> 25:40.230
对吧

25:40.230 --> 25:42.230
它如果调用这个的话

25:42.230 --> 25:44.230
它会调用这个函数

25:44.230 --> 25:46.230
调用这个函数

25:46.230 --> 25:47.230
没问题吧

25:47.230 --> 25:49.230
这是第一步

25:49.230 --> 25:50.230
第二步呢

25:50.230 --> 25:52.230
第二步

25:52.230 --> 25:53.230
运行完了

25:53.230 --> 25:55.230
这个生命周期函数过后了

25:55.230 --> 25:56.230
当然SetState过后

25:56.230 --> 25:58.230
它是不是得到一个新的状态

25:58.230 --> 26:00.230
那么得到新的状态

26:00.230 --> 26:01.230
没什么好说的

26:01.230 --> 26:03.230
跟我们更新没有什么关系

26:03.230 --> 26:05.230
就是得到新的状态之后

26:05.230 --> 26:06.230
那么运行生命周期函数

26:06.230 --> 26:07.230
这个函数

26:07.230 --> 26:08.230
然后呢

26:08.230 --> 26:10.230
又干嘛呢

26:10.230 --> 26:11.230
现在呢

26:11.230 --> 26:13.230
又运行Render

26:13.230 --> 26:15.230
运行Render

26:15.230 --> 26:17.230
运行Render是不是返回

26:17.230 --> 26:19.230
得到一个新的节点

26:19.230 --> 26:20.230
对吧

26:20.230 --> 26:21.230
是不是得到一个新的节点

26:21.230 --> 26:23.230
你看吧

26:23.230 --> 26:26.230
而且仅仅会得到一个新的节点

26:26.230 --> 26:27.230
它不可能得到多个的

26:27.230 --> 26:28.230
为什么

26:28.230 --> 26:29.230
因为组建节点

26:29.230 --> 26:31.230
组建里面Render是不是只能返回一个

26:31.230 --> 26:32.230
必须要有更节点

26:32.230 --> 26:33.230
必须要有更节点

26:33.230 --> 26:34.230
哪怕你返回个NOW

26:34.230 --> 26:35.230
NOW也是个节点嘛

26:35.230 --> 26:37.230
必须要有更节点

26:37.230 --> 26:38.230
所以说组建节点

26:38.230 --> 26:39.230
它一定是只有一个止节点

26:39.230 --> 26:40.230
你看没有

26:40.230 --> 26:42.230
任何一个组建节点

26:42.230 --> 26:43.230
它只有一个止节点

26:43.230 --> 26:44.230
你看这个组建节点

26:44.230 --> 26:45.230
方可信也是一样

26:45.230 --> 26:46.230
它只有一个节点

26:46.230 --> 26:47.230
止节点

26:47.230 --> 26:49.230
没问题吧

26:49.230 --> 26:50.230
所以说呢

26:50.230 --> 26:51.230
它会雕用Render

26:51.230 --> 26:53.230
得到一个新的节点

26:53.230 --> 26:54.230
然后

26:54.230 --> 26:56.230
进入该

26:56.230 --> 26:58.230
进入该新的节点的

26:58.230 --> 27:00.230
对比更新

27:00.230 --> 27:01.230
更新

27:01.230 --> 27:02.230
是不是又进入对比更新的

27:02.230 --> 27:04.230
我们现在还没有说对比更新

27:04.230 --> 27:06.230
那么把这件事情做完

27:06.230 --> 27:07.230
这件事情做完

27:07.230 --> 27:08.230
也可以想象到

27:08.230 --> 27:09.230
这件事情肯定要地轨

27:09.230 --> 27:11.230
这件事情肯定要地轨

27:11.230 --> 27:13.230
那么这件事情去做完

27:13.230 --> 27:15.230
做完了过后

27:15.230 --> 27:17.230
然后第三步

27:17.230 --> 27:19.230
将生命周期函数

27:19.230 --> 27:20.230
生命周期函数

27:20.230 --> 27:21.230
什么函数呢

27:21.230 --> 27:23.230
就是这个函数了

27:23.230 --> 27:25.230
就是那个

27:25.230 --> 27:27.230
还有这个

27:27.230 --> 27:29.230
shouldComponentUpdate

27:29.230 --> 27:31.230
这还有件事

27:35.820 --> 27:37.820
运行

27:37.820 --> 27:39.820
看一下

27:39.820 --> 27:40.820
这样的

27:40.820 --> 27:41.820
运行生命周期函数

27:41.820 --> 27:42.820
这个

27:42.820 --> 27:43.820
因为它现在是更新阶段了

27:43.820 --> 27:44.820
它不是说

27:44.820 --> 27:45.820
不是说那个

27:45.820 --> 27:46.820
首次加载

27:46.820 --> 27:47.820
首次加载

27:47.820 --> 27:48.820
它不会运行这个的

27:48.820 --> 27:49.820
它是更新阶段

27:49.820 --> 27:50.820
现在是更新阶段

27:50.820 --> 27:51.820
它会运行这个东西

27:51.820 --> 27:53.820
如果该函数

27:53.820 --> 27:55.820
返回

27:55.820 --> 27:56.820
Force

27:56.820 --> 27:58.820
终止

27:58.820 --> 27:59.820
当前

27:59.820 --> 28:00.820
流程

28:00.820 --> 28:01.820
那么后边的流程

28:01.820 --> 28:02.820
就一个都不做了

28:02.820 --> 28:03.820
那就相当于是

28:03.820 --> 28:04.820
一个都没有更新的

28:04.820 --> 28:05.820
如果这个函数

28:05.820 --> 28:06.820
它返回了Force

28:06.820 --> 28:07.820
这是我们之前演示过的

28:07.820 --> 28:08.820
对吧

28:08.820 --> 28:09.820
如果你这个函数返回Force

28:09.820 --> 28:10.820
是不是结束了

28:10.820 --> 28:11.820
直接结束了

28:11.820 --> 28:12.820
那么后续的流程

28:12.820 --> 28:13.820
就一个都不做了

28:13.820 --> 28:14.820
如果返回的是处的话

28:14.820 --> 28:15.820
那么才会运行

28:15.820 --> 28:16.820
进入后边的流程

28:16.820 --> 28:17.820
得到新年恋爱

28:17.820 --> 28:18.820
进入新年的对比更新

28:18.820 --> 28:19.820
我们现在还没有说

28:19.820 --> 28:20.820
对比更新

28:20.820 --> 28:22.820
我打算一个夹出

28:22.820 --> 28:23.820
我们后面会詳细说

28:23.820 --> 28:24.820
对比更新

28:24.820 --> 28:25.820
那么第四步

28:25.820 --> 28:26.820
将生命周期函数

28:26.820 --> 28:27.820
什么函数

28:27.820 --> 28:28.820
什么这个函数

28:28.820 --> 28:29.820
加入

28:29.820 --> 28:30.820
加入对列

28:30.820 --> 28:31.820
函数

28:31.820 --> 28:32.820
加入

28:32.820 --> 28:33.820
执行对列

28:33.820 --> 28:34.820
现在还会不会执行

28:34.820 --> 28:35.820
现在不会执行

28:35.820 --> 28:36.820
现在不会执行

28:36.820 --> 28:38.820
只加入执行对列

28:38.820 --> 28:39.820
将来

28:39.820 --> 28:40.820
一代将来执行

28:40.820 --> 28:43.820
一代将来执行

28:43.820 --> 28:44.820
好 第五步

28:44.820 --> 28:47.820
然后又将生命周期函数

28:47.820 --> 28:48.820
将生命周期函数

28:48.820 --> 28:49.820
什么函数

28:49.820 --> 28:50.820
对这个函数

28:50.820 --> 28:52.820
component update

28:52.820 --> 28:53.820
将这个函数

28:53.820 --> 28:55.820
加入执行对列

28:55.820 --> 28:56.820
加入执行对列

28:56.820 --> 28:58.820
当然它是不同的执行对列

28:58.820 --> 29:00.820
不同的函数是不同的执行对列

29:00.820 --> 29:01.820
加这个函数

29:01.820 --> 29:03.820
加入自己的执行对列

29:03.820 --> 29:05.820
一代将来执行

29:05.820 --> 29:06.820
一代将来执行

29:06.820 --> 29:07.820
好

29:07.820 --> 29:09.820
那么这些事情就是做完了

29:09.820 --> 29:10.820
就做完了

29:10.820 --> 29:11.820
做完了过后

29:11.820 --> 29:13.820
最后

29:13.820 --> 29:17.820
完成真实的动物更新

29:17.820 --> 29:19.820
完成真实的动物更新

29:19.820 --> 29:20.820
然后

29:20.820 --> 29:21.820
最后

29:21.820 --> 29:22.820
再来

29:22.820 --> 29:23.820
调用

29:23.820 --> 29:24.820
一次

29:24.820 --> 29:25.820
调用

29:26.820 --> 29:30.820
执行对列中的函数

29:30.820 --> 29:32.820
一次调用执行对列中的函数

29:32.820 --> 29:34.820
然后第八步

29:34.820 --> 29:39.820
一次调用执行对列中的函数

29:39.820 --> 29:41.820
component update函数

29:41.820 --> 29:43.820
然后第九步

29:43.820 --> 29:47.820
还要一次调用执行对列中的

29:47.820 --> 29:48.820
什么函数

29:48.820 --> 29:49.820
还有一个函数

29:49.820 --> 29:50.820
就这个

29:50.820 --> 29:53.820
component will mount

29:53.820 --> 29:55.820
是不是写错了

29:55.820 --> 29:57.820
我之前证明这些函数写错了

29:57.820 --> 29:58.820
应该是unmount

29:58.820 --> 29:59.820
我有unmount

29:59.820 --> 30:01.820
属键销毁

30:01.820 --> 30:03.820
调用对列中的这个函数

30:03.820 --> 30:05.820
unmount

30:05.820 --> 30:07.820
那就奇怪了

30:07.820 --> 30:09.820
老师你这里是不是少写了一个

30:09.820 --> 30:11.820
你为什么没把这个东西加上对列

30:11.820 --> 30:12.820
你想一想

30:12.820 --> 30:14.820
我在这个组建里面调用set state

30:14.820 --> 30:16.820
这个组建会不会

30:16.820 --> 30:18.820
会不会被卸展

30:18.820 --> 30:19.820
会不会

30:19.820 --> 30:21.820
这个组建本身会不会卸展

30:21.820 --> 30:22.820
肯定不会

30:22.820 --> 30:24.820
我在这个组建里面调用set state

30:24.820 --> 30:25.820
改变他的状态

30:25.820 --> 30:26.820
改变他的状态

30:26.820 --> 30:27.820
他怎么会卸展

30:27.820 --> 30:28.820
他不可能卸展

30:28.820 --> 30:30.820
腰卸展也是后边的节点卸展

30:30.820 --> 30:31.820
跟他的没有什么关系

30:31.820 --> 30:32.820
对吧

30:32.820 --> 30:33.820
跟他没有任何关系

30:33.820 --> 30:34.820
他自己不会卸展的

30:34.820 --> 30:35.820
他自己是不会卸展的

30:35.820 --> 30:36.820
明白的意思吗

30:38.820 --> 30:39.820
明白的意思吗

30:39.820 --> 30:41.820
他自己是不会卸展的

30:41.820 --> 30:43.820
这就是整个的

30:44.820 --> 30:46.820
那么这个事情

30:46.820 --> 30:49.820
还不只是set state

30:49.820 --> 30:52.820
这种情况要做

30:52.820 --> 30:53.820
其实这种情况也要做

30:53.820 --> 30:54.820
对比更新

30:54.820 --> 30:55.820
对比更新完成之后

30:55.820 --> 30:57.820
他也要做这些事情

30:57.820 --> 30:59.820
这些事情是通用的

30:59.820 --> 31:00.820
我们把这个写下来

31:04.650 --> 31:05.650
这个

31:06.650 --> 31:08.650
后续步骤

31:10.650 --> 31:12.650
完成真实的节点更新

31:12.650 --> 31:13.650
然后

31:14.650 --> 31:15.650
第三步

31:15.650 --> 31:17.650
这样要准确一点

31:17.650 --> 31:18.650
第四步

31:18.650 --> 31:19.650
也就是说

31:19.650 --> 31:21.650
这里set state

31:21.650 --> 31:22.650
他做这些事情

31:22.650 --> 31:23.650
后续步骤

31:23.650 --> 31:25.650
是无论是这种情况

31:25.650 --> 31:26.650
还是这种情况

31:26.650 --> 31:27.650
后面都要做的

31:28.650 --> 31:29.650
没问题吧

31:29.650 --> 31:30.650
好好看一下

31:31.650 --> 31:32.650
好看一下

31:32.650 --> 31:33.650
set state

31:33.650 --> 31:34.650
他无非多做这么几个步骤

31:35.650 --> 31:36.650
他做了这么一些步骤

31:36.650 --> 31:37.650
而Rind

31:37.650 --> 31:39.650
他只是从个节点开始

31:39.650 --> 31:40.650
进入对比更新

31:40.650 --> 31:42.650
直接就进入对比更新了

31:42.650 --> 31:43.650
我们现在还没有讲

31:43.650 --> 31:45.650
怎么样来进行对比更新

31:45.650 --> 31:46.650
现在还没有讲

31:46.650 --> 31:48.650
不过后面马上就会讲了

31:49.650 --> 31:51.650
但是你先看一下整体的步骤

31:51.650 --> 31:52.650
那么set state

31:52.650 --> 31:54.650
他会多运行一个生命周期函数

31:54.650 --> 31:56.650
多运行下这个

31:56.650 --> 31:57.650
会多运行Rind

31:57.650 --> 31:58.650
然后把返回的

31:58.650 --> 31:59.650
得到一个新的节点

31:59.650 --> 32:01.650
进入该新的节点的对比更新

32:01.650 --> 32:03.650
然后将生命周期函数

32:04.650 --> 32:05.650
然后后续步骤

32:05.650 --> 32:07.650
后续步骤是都要做的

32:07.650 --> 32:08.650
无论是调用Rind

32:08.650 --> 32:09.650
还是调用set state

32:09.650 --> 32:10.650
我们当然

32:10.650 --> 32:11.650
重点是关心这个玩意

32:11.650 --> 32:13.650
Rind是一样的

32:13.650 --> 32:15.650
做完了对比更新之后

32:15.650 --> 32:16.650
他们都要做这件事

32:16.650 --> 32:17.650
完成真实的动物更新

32:17.650 --> 32:19.650
然后一次调用对比中的这个

32:19.650 --> 32:20.650
调用这个

32:23.650 --> 32:25.650
其实还有

32:25.650 --> 32:27.650
还有都还有

32:27.650 --> 32:28.650
还有什么

32:28.650 --> 32:29.650
还有调用这个

32:29.650 --> 32:31.650
这里其实好多

32:31.650 --> 32:33.650
还有一次调用对比中的这个

32:33.650 --> 32:36.150
就是

32:38.150 --> 32:40.150
component

32:41.150 --> 32:43.150
component

32:43.150 --> 32:45.150
地的mount

32:45.150 --> 32:47.150
还有调用这个

32:47.150 --> 32:48.150
component 地的mount

32:48.150 --> 32:50.150
也有可能

32:50.150 --> 32:51.150
不是说更新吗

32:51.150 --> 32:52.150
它没抛了挂载去了

32:52.150 --> 32:54.150
它有可能更新的时候

32:54.150 --> 32:56.150
会导致某些逐渐

32:56.150 --> 32:57.150
产生新的逐渐

32:57.150 --> 32:59.150
它也有可能会导致挂载

32:59.150 --> 33:00.150
总之一生命周期函数

33:00.150 --> 33:02.150
像这些生命周期函数

33:02.150 --> 33:03.150
它会

33:03.150 --> 33:04.150
在后续步骤

33:04.150 --> 33:06.150
在对比中循环执行

33:06.150 --> 33:08.150
循环对比里边执行

33:08.150 --> 33:09.150
如果你看到这一块

33:09.150 --> 33:10.150
感觉上有点模糊

33:10.150 --> 33:11.150
没关系

33:11.150 --> 33:13.150
我们把后边对比更新一讲

33:13.150 --> 33:14.150
你马上就明白了

33:14.150 --> 33:15.150
为什么这里要去指

33:15.150 --> 33:16.150
一式执行这些东西

33:17.150 --> 33:18.150
这就是节点更新的步骤

33:18.150 --> 33:19.150
我们再来一次

33:19.150 --> 33:21.150
比方说你调用的是

33:21.150 --> 33:22.150
它的set state

33:22.150 --> 33:24.150
那么进入它的更新流程

33:24.150 --> 33:25.150
怎么来更新呢

33:25.150 --> 33:27.150
先运行它的should

33:27.150 --> 33:28.150
先运行这个函数

33:28.150 --> 33:29.150
这个函数我说了

33:29.150 --> 33:30.150
再运行它的should

33:30.150 --> 33:32.150
component update

33:32.150 --> 33:33.150
运行这个函数

33:33.150 --> 33:34.150
如果这个函数

33:34.150 --> 33:35.150
返回force

33:35.150 --> 33:36.150
那是最简单的

33:36.150 --> 33:37.150
啥都没做

33:37.150 --> 33:38.150
之前啥样

33:38.150 --> 33:39.150
还啥样

33:39.150 --> 33:40.150
啥都没做

33:40.150 --> 33:41.150
那么

33:41.150 --> 33:42.150
既然啥都没做的话

33:42.150 --> 33:43.150
你看后边完成

33:43.150 --> 33:44.150
真实的我们更新有吗

33:44.150 --> 33:45.150
没有

33:45.150 --> 33:47.150
没有真实的东西更新

33:47.150 --> 33:48.150
一是调用对列中

33:48.150 --> 33:49.150
这个东西

33:49.150 --> 33:50.150
对列里面是空的循环

33:50.150 --> 33:51.150
就是空循环

33:51.150 --> 33:53.150
调用对列中的这个碗

33:53.150 --> 33:54.150
空循环

33:54.150 --> 33:55.150
空循环

33:55.150 --> 33:56.150
实际上啥都没有做

33:56.150 --> 33:59.150
如果它这里就直接返回force的话

33:59.150 --> 34:00.150
当然效率很高了

34:00.150 --> 34:01.150
但是你看不到

34:01.150 --> 34:02.150
看不到变化

34:02.150 --> 34:03.150
然后再运行它的

34:03.150 --> 34:04.150
如果它没有返回force

34:04.150 --> 34:05.150
我当然说的是

34:05.150 --> 34:06.150
没有返回force的情况

34:06.150 --> 34:07.150
如果它没有返回force

34:07.150 --> 34:08.150
返回force

34:08.150 --> 34:09.150
运行 render

34:09.150 --> 34:11.150
是不是得到一个新的节点

34:11.150 --> 34:13.150
进入该新的节点的对比更新

34:13.150 --> 34:14.150
然后呢

34:14.150 --> 34:15.150
第四步

34:15.150 --> 34:16.150
将生命周期函数

34:16.150 --> 34:17.150
这个家族执行对列

34:17.150 --> 34:18.150
将自己的生命周期函数

34:18.150 --> 34:19.150
这个东西加入执行对列

34:19.150 --> 34:20.150
因为对于它而言

34:20.150 --> 34:22.150
它只有这么两个生命周期函数

34:22.150 --> 34:23.150
需要运行

34:23.150 --> 34:24.150
它根本就不会运行这个玩意

34:24.150 --> 34:26.150
也不会运行这个玩意

34:26.150 --> 34:27.150
所以它只有这两个生命周期函数

34:27.150 --> 34:28.150
会运行

34:28.150 --> 34:29.150
它只会把自己的

34:29.150 --> 34:30.150
这两个生命周期函数

34:30.150 --> 34:31.150
加入执行对列

34:32.150 --> 34:33.150
这是对于

34:33.150 --> 34:35.150
更新那个节点

34:35.150 --> 34:36.150
就这个节点

34:36.150 --> 34:37.150
对于这个节点而言

34:37.150 --> 34:38.150
它做的事情

34:39.150 --> 34:40.150
那么接下来了

34:40.150 --> 34:41.150
我们来看一下

34:41.150 --> 34:42.150
对比更新

34:42.150 --> 34:43.150
到底要说什么事

34:43.150 --> 34:44.150
终点说的是对比更新

34:45.150 --> 34:46.150
下面

34:47.150 --> 34:48.150
对比更新

34:50.150 --> 34:51.150
这个对比更新的

34:51.150 --> 34:52.150
它的整体的过程

34:52.150 --> 34:53.150
我们先大概说一下

34:54.150 --> 34:55.150
就一句话就说清楚了

34:56.150 --> 34:58.150
将新产生的节点

34:59.150 --> 35:00.150
产生的节点

35:01.150 --> 35:02.150
对比

35:02.150 --> 35:04.150
之前

35:04.150 --> 35:07.150
虚拟动数中的节点

35:08.150 --> 35:09.150
发现

35:09.150 --> 35:10.150
差异

35:10.150 --> 35:11.150
完成更新

35:12.150 --> 35:13.150
它就是

35:13.150 --> 35:14.150
整个过程

35:14.150 --> 35:15.150
它就做这么一件事

35:15.150 --> 35:17.150
将新产生的节点

35:18.150 --> 35:19.150
对比之前

35:19.150 --> 35:20.150
虚拟动数中的节点

35:20.150 --> 35:21.150
发现差异

35:21.150 --> 35:22.150
完成更新

35:22.150 --> 35:23.150
也就是说

35:23.150 --> 35:24.150
我们这里的这个组建节点

35:24.150 --> 35:26.150
它不是要运行Render吗

35:26.150 --> 35:27.150
它是不是要运行Render

35:27.150 --> 35:28.150
Render运行的过后

35:28.150 --> 35:29.150
是不是返回这个节点

35:29.150 --> 35:30.150
动物节点

35:30.150 --> 35:31.150
对吧

35:31.150 --> 35:32.150
它返回的是这个动物节点

35:32.150 --> 35:33.150
我们的组建书已经画好了

35:33.150 --> 35:34.150
我就不再重新画了

35:34.150 --> 35:36.150
返回的是这个动物节点

35:36.150 --> 35:37.150
所以说

35:37.150 --> 35:38.150
从这个动物节点

35:38.150 --> 35:39.150
开始进入对比

35:40.150 --> 35:41.150
它对比的不是它

35:41.150 --> 35:42.150
不是它自己

35:42.150 --> 35:43.150
它自己

35:43.150 --> 35:44.150
刚才已经说了

35:44.150 --> 35:45.150
它自己干嘛

35:45.150 --> 35:46.150
它自己就做这些事情

35:47.150 --> 35:48.150
而是

35:48.150 --> 35:49.150
它自己在做这些事情的时候

35:49.150 --> 35:50.150
第三步

35:50.150 --> 35:51.150
调用Render

35:51.150 --> 35:52.150
是不是返回一个新的节点

35:52.150 --> 35:53.150
对吧

35:53.150 --> 35:55.150
返回的是一个新的动物节点

35:55.150 --> 35:56.150
对不对

35:56.150 --> 35:58.150
我们才从这里开始对比更新

35:58.150 --> 35:59.150
是这么个意思

35:59.150 --> 36:00.150
能看

36:00.150 --> 36:01.150
能听懂我在说什么吗

36:04.150 --> 36:05.150
从这里开始

36:05.150 --> 36:07.150
进行对比更新

36:07.150 --> 36:08.150
从这里开始

36:09.150 --> 36:10.150
来吧

36:10.150 --> 36:11.150
怎么来对比更新

36:11.150 --> 36:13.150
它肯定是要产生新的节点

36:13.150 --> 36:14.150
那么整个过程

36:14.150 --> 36:15.150
就是将新产能的节点

36:15.150 --> 36:16.150
对比之前

36:16.150 --> 36:17.150
续动物动物的节点

36:17.150 --> 36:18.150
发现差异

36:19.150 --> 36:20.150
那么这个时候

36:20.150 --> 36:23.150
它会产生一个新的节点

36:23.150 --> 36:24.150
我真的画不下了

36:24.150 --> 36:25.150
我这里画不下了

36:25.150 --> 36:27.150
我只能翻篇画了

36:30.810 --> 36:31.810
看着

36:31.810 --> 36:32.810
这个动物节点

36:35.810 --> 36:36.810
从这里开始

36:36.810 --> 36:38.810
那么是不是产生新的动物节点

36:38.810 --> 36:39.810
对吧

36:39.810 --> 36:41.810
动物节点是DIV

36:41.810 --> 36:43.810
产生了一个新的动物节点

36:43.810 --> 36:45.810
就是动物节点

36:49.250 --> 36:51.250
看里面返回新的动物节点DIV

36:51.250 --> 36:52.250
对不对

36:52.250 --> 36:54.250
是不是返回一个它

36:54.250 --> 36:56.250
然后现在不着急

36:56.250 --> 36:57.250
不着急现在什么直节点

36:57.250 --> 36:58.250
不着急也直节点

36:58.250 --> 37:00.250
也不着急加什么真实动物元素

37:00.250 --> 37:01.250
不着急

37:01.250 --> 37:02.250
这些事情不着急

37:02.250 --> 37:04.250
因为现在是进行了更新步骤

37:04.250 --> 37:06.250
那么它首先要对比之前的

37:06.250 --> 37:07.250
续动物的节点

37:07.250 --> 37:08.250
发现差异

37:08.250 --> 37:09.250
完成整形

37:09.250 --> 37:10.250
那么现在就有一个问题

37:10.250 --> 37:11.250
问题是什么

37:11.250 --> 37:14.250
问题是对比

37:14.250 --> 37:19.250
之前动物宿中哪个节点

37:19.250 --> 37:20.250
现在关键是这个问题

37:20.250 --> 37:22.250
我都不知道跟谁来对比

37:22.250 --> 37:24.250
对比哪个节点

37:24.250 --> 37:25.250
根本就不知道谁在对比

37:25.250 --> 37:27.250
但是我们人的话

37:27.250 --> 37:28.250
依然就看清楚

37:28.250 --> 37:29.250
肯定是他

37:29.250 --> 37:30.250
但是他不知道

37:30.250 --> 37:31.250
程序不知道

37:31.250 --> 37:32.250
他不知道

37:32.250 --> 37:33.250
应该跟谁来

37:33.250 --> 37:34.250
哪个节点来对比

37:34.250 --> 37:36.250
他不知道自己

37:36.250 --> 37:37.250
之前

37:37.250 --> 37:38.250
比方说

37:38.250 --> 37:39.250
他不知道自己

37:39.250 --> 37:40.250
在哪个位置

37:40.250 --> 37:41.250
在动物宿中哪个位置

37:41.250 --> 37:42.250
他不知道

37:42.250 --> 37:44.250
那么能不能知道

37:44.250 --> 37:45.250
可以做一些标识

37:45.250 --> 37:46.250
比如说做一些ID

37:46.250 --> 37:48.250
或者是以唯一标识来知道

37:48.250 --> 37:49.250
当然可以知道

37:49.250 --> 37:51.250
但是就会遇到一个问题

37:51.250 --> 37:53.250
就是我当时要对比的时候

37:53.250 --> 37:54.250
比方说

37:54.250 --> 37:55.250
做一个唯一标识

37:55.250 --> 37:57.250
假设我们做了一个唯一标识

37:57.250 --> 37:58.250
那么这个

37:58.250 --> 37:59.250
比方说一个ID

37:59.250 --> 38:01.250
IDT

38:01.250 --> 38:04.250
那么这里的ID有一个T

38:04.250 --> 38:05.250
那么做一个唯一标识的话

38:05.250 --> 38:07.250
到时候就会遇到一个问题

38:07.250 --> 38:09.250
效率非常低

38:09.250 --> 38:11.250
我从这个节点

38:11.250 --> 38:13.250
我要找到最堆硬的节点

38:13.250 --> 38:15.250
我是不是要便利一下整个动物宿

38:15.250 --> 38:16.250
对吧

38:16.250 --> 38:17.250
便利一下整个动物宿

38:17.250 --> 38:19.250
看一下ID等于T的在哪

38:19.250 --> 38:20.250
在哪个位置

38:20.250 --> 38:21.250
就是我之前在哪

38:21.250 --> 38:22.250
现在在哪

38:22.250 --> 38:23.250
对不对

38:23.250 --> 38:24.250
我之前在哪

38:24.250 --> 38:25.250
现在在哪

38:25.250 --> 38:26.250
他要去做这么一个寻找

38:26.250 --> 38:27.250
便利寻找

38:27.250 --> 38:29.250
那么这个书型结构

38:29.250 --> 38:30.250
你看我们才写这么一点点

38:30.250 --> 38:31.250
组件

38:31.250 --> 38:32.250
这就这么深的书型结构了

38:32.250 --> 38:34.250
那么到几千几万的

38:34.250 --> 38:36.250
书型结构是非常有可能的

38:36.250 --> 38:38.250
那比方说一千个书型结构

38:38.250 --> 38:40.250
他这样子便利出来

38:40.250 --> 38:42.250
他要上意便利的便利的就是

38:45.250 --> 38:48.250
便利的最终的运算次数

38:48.250 --> 38:49.250
要上意

38:49.250 --> 38:50.250
为什么呢

38:50.250 --> 38:51.250
这一个节点他上不了意

38:51.250 --> 38:52.250
但是他下边还有节点

38:52.250 --> 38:53.250
还要做对比

38:53.250 --> 38:55.250
后边后续还要做对比

38:55.250 --> 38:57.250
那是非常恐怖的

38:57.250 --> 38:58.250
因此的效率非常低

38:58.250 --> 39:00.250
于是那Roy Aix

39:00.250 --> 39:02.250
他做了这么一种假设

39:02.250 --> 39:04.250
Roy Aix的假设

39:04.250 --> 39:05.250
他为了提高效率

39:05.250 --> 39:07.250
为了提高

39:07.250 --> 39:09.250
提高对比效率

39:09.250 --> 39:11.250
就是这个对比效率的效率指的是什么

39:11.250 --> 39:13.250
我要找到之前我之前在哪

39:13.250 --> 39:14.250
我要对比吗

39:14.250 --> 39:16.250
我之前跟谁去对比

39:16.250 --> 39:17.250
为了提高对比效率

39:17.250 --> 39:19.250
做了这么几种假设

39:19.250 --> 39:21.250
第一个假设

39:21.250 --> 39:22.250
怎么假设呢

39:22.250 --> 39:25.250
做出以下假设

39:25.250 --> 39:28.250
做出以下假设

39:28.250 --> 39:30.250
第一个假设

39:30.250 --> 39:32.250
就是假设

39:32.250 --> 39:34.250
这个节点不会出现

39:34.250 --> 39:36.250
层级的移动

39:36.250 --> 39:37.250
什么意思呢

39:37.250 --> 39:38.250
就是说

39:38.250 --> 39:40.250
你这里这个节点

39:40.250 --> 39:41.250
这个DIV

39:41.250 --> 39:42.250
之前在这对吧

39:42.250 --> 39:44.250
你不会一会跑到这来了

39:44.250 --> 39:46.250
你不会说这个DIV一会跑到这来了

39:46.250 --> 39:47.250
跑到根基点下面去了

39:47.250 --> 39:49.250
他不会出现这个层级的移动

39:49.250 --> 39:50.250
这种移动

39:50.250 --> 39:51.250
我们在实际的开发中

39:51.250 --> 39:53.250
实际上是非常非常少的

39:53.250 --> 39:55.250
确实也是非常非常少的

39:55.250 --> 39:58.250
那么他就做出这么一种假设

39:58.250 --> 39:59.250
有了这个假设之后

39:59.250 --> 40:00.250
你看一下

40:00.250 --> 40:02.250
现在对比一下就非常简单了

40:02.250 --> 40:05.250
你之前在书形结构里边

40:05.250 --> 40:08.250
在整个动物书里边

40:08.250 --> 40:10.250
是不是第四层的节点

40:10.250 --> 40:12.250
第四层的第一个节点

40:12.250 --> 40:14.250
他就可以找到了第四层的第一个节点

40:14.250 --> 40:16.250
他根据他的深度

40:16.250 --> 40:18.250
你们之前学过那个数的

40:18.250 --> 40:19.250
数据结构

40:19.250 --> 40:21.250
书里边他有个深度

40:21.250 --> 40:23.250
根据书的深度

40:23.250 --> 40:24.250
根据一个节点的位置

40:24.250 --> 40:26.250
就可以直接找到这个节点了

40:26.250 --> 40:28.250
那么这就不用ID了

40:28.250 --> 40:30.250
那么现在的是不是

40:30.250 --> 40:31.250
效率一下就提高了

40:31.250 --> 40:33.250
我之前要把整个数变理一变

40:33.250 --> 40:34.250
现在不用变理了

40:34.250 --> 40:35.250
我直接这个节点

40:35.250 --> 40:36.250
他知道

40:36.250 --> 40:37.250
他首先非常清楚这个节点

40:37.250 --> 40:39.250
他深度就是4

40:39.250 --> 40:40.250
深度就是4

40:40.250 --> 40:42.250
在这个深度下面的

40:42.250 --> 40:44.250
就这个节点的直接点

40:44.250 --> 40:45.250
他非常知道自己的位置

40:45.250 --> 40:47.250
他知道自己的位置在了

40:47.250 --> 40:48.250
然后呢

40:48.250 --> 40:49.250
为什么他知道

40:49.250 --> 40:51.250
因为我们调用这个实际的set state

40:51.250 --> 40:52.250
那么这个实际

40:52.250 --> 40:53.250
他知道这个实际

40:53.250 --> 40:54.250
所在的节点是

40:54.250 --> 40:55.250
深度是多少

40:55.250 --> 40:56.250
那么这个实际的止节点

40:56.250 --> 40:57.250
自然而然他知道

40:57.250 --> 40:58.250
深度是多少

40:58.250 --> 40:59.250
那么他知道这个节点的深度

40:59.250 --> 41:00.250
在书里边的深度

41:00.250 --> 41:02.250
于是呢他直接去找

41:02.250 --> 41:03.250
从以前那个书

41:03.250 --> 41:05.250
从之前那颗书里边

41:05.250 --> 41:06.250
在之前的书嘛

41:06.250 --> 41:07.250
直接找到这个节点

41:07.250 --> 41:09.250
一下就找到了

41:09.250 --> 41:10.250
这样的算法

41:10.250 --> 41:11.250
他的负达度是O1

41:11.250 --> 41:12.250
对不对

41:12.250 --> 41:13.250
负达度为1

41:13.250 --> 41:14.250
所以非常空

41:14.250 --> 41:16.250
这个非常就是

41:16.250 --> 41:17.250
非常

41:17.250 --> 41:19.250
效率就非常高了

41:19.250 --> 41:20.250
那么他后边还有止节点

41:20.250 --> 41:21.250
是不是一样的道理

41:21.250 --> 41:22.250
那么到时候要

41:22.250 --> 41:23.250
帝规进行对比的时候

41:23.250 --> 41:24.250
那么他就

41:24.250 --> 41:25.250
找对应深度的止就行了

41:25.250 --> 41:27.250
找对应深度的就完事了

41:27.250 --> 41:28.250
所以他一下就找到了

41:28.250 --> 41:30.250
那比方说这个节点有1000个

41:30.250 --> 41:32.250
那么他只需要变你1000次

41:32.250 --> 41:33.250
循环1000次就完事了

41:33.250 --> 41:34.250
这个节点

41:34.250 --> 41:35.250
一次

41:35.250 --> 41:36.250
下一个节点一次

41:36.250 --> 41:37.250
下一个节点一次

41:37.250 --> 41:38.250
哪怕你是个根节点

41:38.250 --> 41:40.250
你就也就1000次

41:40.250 --> 41:41.250
对吧

41:41.250 --> 41:43.250
他把ON的3次方

41:43.250 --> 41:44.250
这个负达度变成了ON

41:44.250 --> 41:46.250
你们学过那个

41:46.250 --> 41:48.250
数据那个

41:48.250 --> 41:50.250
数据的数据结构里边的

41:50.250 --> 41:51.250
算法负达度

41:51.250 --> 41:52.250
对吧

41:53.250 --> 41:54.250
那么现在效率就提高了

41:54.250 --> 41:56.250
所以他做出这么一种假设

41:56.250 --> 41:58.250
不会出现成绩的移动

41:58.250 --> 42:00.250
所以说这就会导致他对比的时候

42:00.250 --> 42:01.250
对比时

42:01.250 --> 42:04.250
直接找到

42:04.250 --> 42:07.250
就数中

42:07.250 --> 42:09.250
数中

42:09.250 --> 42:11.250
就的数里边

42:11.250 --> 42:13.250
对应位置的节点

42:13.250 --> 42:16.250
进行对比

42:16.250 --> 42:18.250
就不用去对比数里边

42:18.250 --> 42:19.250
其他东西了

42:19.250 --> 42:21.250
这是第一个假设

42:21.250 --> 42:22.250
还有两个假设

42:22.250 --> 42:23.250
这两个假设

42:23.250 --> 42:24.250
我们后边会详细说

42:24.250 --> 42:26.250
现在暂时先看一下

42:26.250 --> 42:28.250
后边会详细说

42:28.250 --> 42:31.250
不同的节点内形

42:31.250 --> 42:34.250
会生成

42:34.250 --> 42:36.250
不同的结构

42:36.250 --> 42:37.250
他做这么一种假设

42:37.250 --> 42:39.250
比方说你是一个DIV节点

42:39.250 --> 42:41.250
或者是你然后变成了一个SPAN节点

42:41.250 --> 42:42.250
那么你的

42:42.250 --> 42:43.250
以后边的内形

42:43.250 --> 42:45.250
会生成一个完全不同的结构

42:45.250 --> 42:46.250
他会做这么一种假设

42:46.250 --> 42:48.250
这也是往往我们在开发的时候

42:48.250 --> 42:50.250
会有出现的现象

42:50.250 --> 42:53.250
一个跟节点内形都不一样了

42:53.250 --> 42:55.250
那么真的结构是不一样的

42:55.250 --> 42:56.250
以后我会详细说

42:56.250 --> 42:59.250
先我们暂时一会儿

42:59.250 --> 43:02.250
详细说

43:02.250 --> 43:06.250
第三个假设是

43:06.250 --> 43:10.250
多个兄弟节点

43:10.250 --> 43:15.250
通过唯一标识来确定

43:15.250 --> 43:16.250
唯一标识是什么

43:16.250 --> 43:17.250
就是keyz

43:17.250 --> 43:18.250
我们后边会详细说

43:18.250 --> 43:19.250
现在不管

43:19.250 --> 43:22.250
通过唯一标识key

43:22.250 --> 43:24.250
来确定

43:24.250 --> 43:29.250
来确定就是对比的新节点

43:29.250 --> 43:30.250
跟哪个新节点进行对比

43:30.250 --> 43:31.250
或者说新节点

43:31.250 --> 43:33.250
跟哪个旧节点进行对比

43:33.250 --> 43:34.250
我们一会儿会详细说

43:34.250 --> 43:36.250
那么现在主要关注第一条

43:36.250 --> 43:38.250
假设节点不会出现成绩一动

43:38.250 --> 43:39.250
所以说

43:39.250 --> 43:40.250
不会出现成绩一动

43:40.250 --> 43:41.250
是不是一下就找到了

43:41.250 --> 43:42.250
找到了谁

43:42.250 --> 43:43.250
是不是就找到了

43:43.250 --> 43:44.250
那个

43:44.250 --> 43:46.250
找到了之前那个节点了

43:46.250 --> 43:47.250
就是这个节点

43:47.250 --> 43:48.250
跟这个节点

43:48.250 --> 43:49.250
我们画不下了

43:49.250 --> 43:51.250
我真的是想很想把它画成一张图

43:51.250 --> 43:53.250
一张图里面看的是最清楚的

43:53.250 --> 43:54.250
但是我真的是画不下了

43:54.250 --> 43:56.250
真的是画不下了

43:56.250 --> 43:57.250
我想想办法

43:57.250 --> 44:00.250
看能不能画下了

44:00.250 --> 44:01.250
看能不能画下

44:01.250 --> 44:02.250
真的是画不下了

44:02.250 --> 44:04.250
就是两个点进行对比

44:04.250 --> 44:05.250
好

44:05.250 --> 44:06.250
我们首先要找到

44:06.250 --> 44:08.250
跟哪个节点进行对比

44:08.250 --> 44:09.250
还不要说

44:09.250 --> 44:11.250
后边具体怎么对比

44:11.250 --> 44:12.250
我们先说

44:12.250 --> 44:13.250
首先要找到

44:13.250 --> 44:15.250
跟哪个节点进行对比

44:15.250 --> 44:16.250
他做出这么一种假设

44:16.250 --> 44:18.250
他是为了提高效率

44:18.250 --> 44:19.250
好

44:19.250 --> 44:20.250
那么现在

44:20.250 --> 44:22.250
那么就比方说已经找到了

44:22.250 --> 44:25.250
已经找到了之前对比的节点

44:25.250 --> 44:28.250
我们分情况来说

44:28.250 --> 44:29.250
这里真的是

44:29.250 --> 44:30.250
情况太多了

44:30.250 --> 44:32.250
我这里对比更新

44:32.250 --> 44:33.250
对比更新里边

44:33.250 --> 44:34.250
我们分成

44:34.250 --> 44:37.250
又分成两个部分来说

44:37.250 --> 44:38.250
对比更新这里

44:38.250 --> 44:40.250
分成两个部分来说

44:40.250 --> 44:42.250
第一个部分是指的是

44:42.250 --> 44:45.250
找到了对比的目标

44:45.250 --> 44:47.250
目标存在

44:47.250 --> 44:48.250
标到这里

44:48.250 --> 44:49.250
这个DIV

44:49.250 --> 44:50.250
这是新的节点

44:50.250 --> 44:52.250
他找到了之前的数里边的节点

44:52.250 --> 44:54.250
这个我给你进行对比

44:54.250 --> 44:56.250
找到了对比目标

44:56.250 --> 44:57.250
好

44:57.250 --> 44:58.250
那么另一种情况

44:58.250 --> 45:00.250
就是没有找到对比目标

45:00.250 --> 45:02.250
没有找到对比目标

45:02.250 --> 45:03.250
之前没有

45:03.250 --> 45:05.250
之前的节点没有

45:05.250 --> 45:06.250
这是两种情况

45:06.250 --> 45:08.250
这两种情况

45:08.250 --> 45:09.250
好

45:09.250 --> 45:10.250
我们分开来说

45:10.250 --> 45:11.250
一个个来说

45:11.250 --> 45:13.250
第一个是找到了对比目标

45:13.250 --> 45:14.250
找到了对比目标

45:14.250 --> 45:16.250
它是做这么一个流程

45:16.250 --> 45:17.250
第一步

45:17.250 --> 45:22.250
判断节点类型是否一致

45:22.250 --> 45:25.250
什么叫做节点类型一致

45:25.250 --> 45:27.250
我这里要说一下

45:27.250 --> 45:32.250
什么叫做节点类型一致

45:32.250 --> 45:33.250
就开说这个了

45:33.250 --> 45:34.250
不同的节点类型

45:34.250 --> 45:35.250
会生成不同的结构

45:35.250 --> 45:36.250
它有这么一种假设

45:36.250 --> 45:37.250
那么什么叫做

45:37.250 --> 45:39.250
相同的节点类型呢

45:39.250 --> 45:41.250
相同的节点类型

45:41.250 --> 45:42.250
什么叫做相同的节点呢

45:42.250 --> 45:45.250
首先是节点本身类型相同

45:45.250 --> 45:47.820
什么叫本身类型相同

45:47.820 --> 45:50.820
就是现在你是一个动物节点

45:50.820 --> 45:52.820
那么之前的也是个动物节点

45:52.820 --> 45:53.820
这叫节点类型相同

45:53.820 --> 45:54.820
对吧

45:54.820 --> 45:55.820
你是个文本节点

45:55.820 --> 45:57.820
之前的也是一个文本节点

45:57.820 --> 45:59.820
这叫节点类型相同

45:59.820 --> 46:01.820
没问题吧

46:01.820 --> 46:03.820
那么还有一种就是

46:03.820 --> 46:05.820
如果你是主建节点的话

46:05.820 --> 46:07.820
节点本身类型相同

46:07.820 --> 46:09.820
如果是主建节点

46:09.820 --> 46:13.820
主建类型也必须相同

46:13.820 --> 46:15.820
这就是相同的节点类型

46:15.820 --> 46:18.820
那么另外的

46:18.820 --> 46:23.820
其他的都属于

46:23.820 --> 46:28.960
不相同的节点类型

46:28.960 --> 46:29.960
就相同的节点类型

46:29.960 --> 46:30.960
必须满足两个条件

46:30.960 --> 46:32.960
意思是它节点本身的类型

46:32.960 --> 46:33.960
是一样的

46:33.960 --> 46:34.960
你是一个

46:34.960 --> 46:36.960
你是一个动物节点

46:36.960 --> 46:38.960
那么之前也是动物节点

46:38.960 --> 46:39.960
这个新的节点

46:39.960 --> 46:41.960
这个新的节点也就是动物节点

46:41.960 --> 46:43.960
那么你之前是一个文本节点

46:43.960 --> 46:44.960
那么新的动物节点

46:44.960 --> 46:45.960
也就是文本节点

46:45.960 --> 46:46.960
就是类型相同

46:46.960 --> 46:47.960
你是一个主建节点的话

46:47.960 --> 46:49.960
那么新的节点也必须是

46:49.960 --> 46:50.960
主建节点

46:50.960 --> 46:51.960
并且

46:51.960 --> 46:52.960
主建类型要相同

46:52.960 --> 46:53.960
你不能之前是主建

46:53.960 --> 46:54.960
现在就变成主建B了

46:54.960 --> 46:55.960
那就认为不一样

46:55.960 --> 46:57.960
那就认为不一样

46:57.960 --> 47:03.960
这就是节点类型必须要一致

47:03.960 --> 47:05.960
这是节点类型

47:05.960 --> 47:07.960
判断节点类型是否一致

47:08.960 --> 47:10.960
如果又分为两种情况

47:10.960 --> 47:12.960
如果一致和不一致的情况

47:12.960 --> 47:15.960
那么现在这里是不是一致的情况

47:15.960 --> 47:17.960
节点类型是不是一致的

47:17.960 --> 47:18.960
OK

47:18.960 --> 47:19.960
我们来看一下

47:19.960 --> 47:21.960
节点类型一致的情况会怎么样

47:21.960 --> 47:23.960
是否一致

47:23.960 --> 47:24.960
第一个

47:24.960 --> 47:26.960
如果节点类型是一致的

47:26.960 --> 47:28.960
另外一个是不一致的

47:28.960 --> 47:30.960
不一致的

47:30.960 --> 47:33.960
这里又是一个分字的

47:33.960 --> 47:36.960
第一个是一致的情况

47:36.960 --> 47:39.960
第二个是不一致的情况

47:39.960 --> 47:42.340
这样子行

47:42.340 --> 47:43.340
节点类型一致

47:43.340 --> 47:46.340
节点类型不一致

47:46.340 --> 47:48.340
如果是节点类型一致的话

47:48.340 --> 47:51.340
那么它会进入这么一个过程

47:51.340 --> 47:52.340
做什么呢

47:52.340 --> 47:55.340
根据不同的节点类型

47:55.340 --> 47:58.340
做不同的事情

47:58.340 --> 48:00.340
不同的事情

48:00.340 --> 48:01.340
那么什么节点

48:01.340 --> 48:02.340
做什么事情呢

48:02.340 --> 48:04.340
又要挨在来说

48:04.340 --> 48:06.340
一个个来说

48:06.340 --> 48:09.340
那么如果你是一个空节点的话

48:09.340 --> 48:11.340
节点类型一致

48:11.340 --> 48:12.340
你是空节点

48:12.340 --> 48:13.340
它也得是空节点

48:13.340 --> 48:14.340
类型要一致

48:14.340 --> 48:15.340
如果空节点的话

48:15.340 --> 48:17.340
不做任何事情

48:17.340 --> 48:19.340
不做任何事情

48:19.340 --> 48:21.340
这是空节点的情况

48:24.340 --> 48:26.340
那么这里就是

48:26.340 --> 48:27.340
这样子写吧

48:27.340 --> 48:29.340
分开写

48:29.340 --> 48:30.340
如果是空节点的话

48:30.340 --> 48:31.340
不做任何事情

48:31.340 --> 48:33.340
第二种情况是

48:33.340 --> 48:35.340
如果不是空的节点

48:35.340 --> 48:36.340
比方说

48:36.340 --> 48:38.340
如果是多么节点的话

48:38.340 --> 48:39.340
它干嘛

48:39.340 --> 48:41.340
注意啊

48:41.340 --> 48:42.340
咱们前提条件是

48:42.340 --> 48:44.340
找到了对比目标

48:44.340 --> 48:45.340
然后呢

48:45.340 --> 48:46.340
节点类型又一致

48:46.340 --> 48:48.340
节点类型又一致

48:48.340 --> 48:50.340
这才叫做

48:50.340 --> 48:52.340
这是我们的前提

48:52.340 --> 48:53.340
我们这里说的全是前提

48:53.340 --> 48:55.340
节点层面叫节点类型一致

48:55.340 --> 48:56.340
刚才说了

48:56.340 --> 48:57.340
节点本身类型相同

48:57.340 --> 48:58.340
都是多么节点

48:58.340 --> 49:00.340
都是文闷节点

49:00.340 --> 49:01.340
这里应该这样说

49:01.340 --> 49:02.340
并且

49:02.340 --> 49:04.340
如果是由

49:04.340 --> 49:07.340
rex元素生成的

49:07.340 --> 49:09.340
就是用rex create element

49:09.340 --> 49:11.340
就是用js x来生成的

49:11.340 --> 49:13.340
type值一致

49:13.340 --> 49:15.340
type值还必须一致

49:15.340 --> 49:16.340
type值不就是

49:16.340 --> 49:17.340
我们之前看到过

49:17.340 --> 49:18.340
内图件的type值呢

49:18.340 --> 49:20.340
就是指向了内本的生

49:20.340 --> 49:22.340
两个内要相同

49:22.340 --> 49:23.340
然后呢

49:23.340 --> 49:24.340
如果你是一个

49:24.340 --> 49:25.340
多么节点的话

49:25.340 --> 49:26.340
那么

49:26.340 --> 49:27.340
type值呢

49:27.340 --> 49:28.340
它就是

49:28.340 --> 49:29.340
要么就是di

49:29.340 --> 49:30.340
要么都是十变

49:30.340 --> 49:31.340
这叫类型一致

49:31.340 --> 49:32.340
这个东西

49:32.340 --> 49:34.340
判断的实际上是type值

49:34.340 --> 49:35.340
如果是多么节点的话

49:35.340 --> 49:36.340
那么它由于

49:36.340 --> 49:37.340
节点类型是一致的

49:37.340 --> 49:38.340
是不是都是同一个

49:38.340 --> 49:39.340
同一个就是

49:39.340 --> 49:40.340
要么都是div

49:40.340 --> 49:41.340
要么都是十变

49:41.340 --> 49:42.340
那么对多么节点

49:42.340 --> 49:43.340
怎么来操作呢

49:43.340 --> 49:45.340
多么节点是这样子

49:45.340 --> 49:46.340
它是这样子来处理操作的

49:46.340 --> 49:47.340
多么节点呢

49:47.340 --> 49:49.340
它玩这件事情

49:49.340 --> 49:50.340
如果

49:50.340 --> 49:53.340
就是说

49:53.340 --> 49:56.340
直接使用

49:56.340 --> 49:58.340
直接使用

49:58.340 --> 50:00.340
之前的真实

50:00.340 --> 50:01.340
多么对象

50:01.340 --> 50:02.340
也就不再新生成了

50:02.340 --> 50:03.340
不再新生成了

50:03.340 --> 50:04.340
直接使用

50:04.340 --> 50:05.340
之前的真实

50:05.340 --> 50:06.340
多么对象

50:06.340 --> 50:07.340
也就是说

50:07.340 --> 50:08.340
我们之前

50:08.340 --> 50:09.340
不是这个div里面

50:09.340 --> 50:10.340
生成过真实

50:10.340 --> 50:11.340
多么对象吗

50:11.340 --> 50:12.340
OK

50:12.340 --> 50:13.340
把这个真实

50:13.340 --> 50:14.340
多么对象直接拿过来

50:14.340 --> 50:15.340
直接用

50:15.340 --> 50:16.340
我们这里

50:16.340 --> 50:17.340
换个

50:17.340 --> 50:18.340
加个两个字

50:18.340 --> 50:20.340
重用

50:22.340 --> 50:23.340
重用这个真实

50:23.340 --> 50:24.340
多么节点

50:24.340 --> 50:25.340
它不再去新创建了

50:25.340 --> 50:27.340
不再去新创建

50:27.340 --> 50:28.340
这个多么节点了

50:28.340 --> 50:29.340
直接重用

50:30.340 --> 50:31.340
所以说

50:31.340 --> 50:32.340
由于它有重用

50:32.340 --> 50:33.340
因此

50:33.340 --> 50:34.340
它的效率非常高

50:34.340 --> 50:35.340
它不会去产生新的

50:35.340 --> 50:36.340
多么对象

50:36.340 --> 50:37.340
也不会去

50:37.340 --> 50:38.340
把之前的多么对象

50:38.340 --> 50:39.340
删掉又重新给你加入

50:39.340 --> 50:40.340
它的效率是非常高

50:40.340 --> 50:41.340
直接重用之前的

50:41.340 --> 50:42.340
因为它能找到

50:42.340 --> 50:43.340
之前的节点

50:43.340 --> 50:44.340
自然能找到

50:44.340 --> 50:45.340
之前的节点里面的

50:45.340 --> 50:46.340
多么对象

50:46.340 --> 50:47.340
直接重用之前的

50:47.340 --> 50:49.340
真实的多么对象

50:49.340 --> 50:50.340
就这么个意思

50:50.340 --> 50:51.340
就这么个意思

50:52.340 --> 50:53.340
然后

50:53.340 --> 50:54.340
我们看一下

50:54.340 --> 50:55.340
我们如何来

50:55.340 --> 50:56.340
验证这一点的

50:56.340 --> 50:57.340
刷新一下

50:58.340 --> 50:59.340
你看着

50:59.340 --> 51:00.340
如果说

51:00.340 --> 51:01.340
它如果说

51:01.340 --> 51:02.340
一会这个DIV

51:02.340 --> 51:04.340
这个DIV123

51:04.340 --> 51:05.340
这个H1

51:05.340 --> 51:07.340
这个DIV

51:07.340 --> 51:08.340
这个DIV是

51:08.340 --> 51:09.340
ID为入彩的

51:09.340 --> 51:10.340
第一个指源数

51:10.340 --> 51:11.340
第一个指源数

51:11.340 --> 51:12.340
第一个指源数

51:12.340 --> 51:13.340
对吧

51:13.340 --> 51:14.340
那如果说

51:14.340 --> 51:15.340
它是重新建的DIV

51:15.340 --> 51:16.340
那么两次

51:16.340 --> 51:17.340
我得到的

51:17.340 --> 51:18.340
在动物操作的时候

51:18.340 --> 51:19.340
两次得到的

51:19.340 --> 51:20.340
动物对象

51:20.340 --> 51:21.340
应该是不一样的

51:21.340 --> 51:22.340
那么我们来看一下

51:22.340 --> 51:23.340
第一次

51:23.340 --> 51:24.340
一开始是这个DIV

51:24.340 --> 51:25.340
对吧

51:25.340 --> 51:26.340
咱们拿到这个DIV

51:26.340 --> 51:27.340
之前的DIV

51:27.340 --> 51:28.340
Documents

51:32.340 --> 51:33.340
找到什么

51:33.340 --> 51:34.340
入彩下面的

51:34.340 --> 51:36.340
入彩下面的

51:36.340 --> 51:38.340
第一个指源数DIV

51:38.340 --> 51:40.340
然后第一个指源数DIV

51:40.340 --> 51:41.340
咱们把这个DIV

51:41.340 --> 51:42.340
O的拿到

51:42.340 --> 51:43.340
然后呢

51:43.340 --> 51:44.340
我们更新

51:44.340 --> 51:45.340
点击更新

51:45.340 --> 51:46.340
更新完了过后

51:46.340 --> 51:47.340
是不是又一个DIV了

51:47.340 --> 51:48.340
还是个DIV对吧

51:48.340 --> 51:49.340
OK

51:49.340 --> 51:50.340
那么它现在呢

51:50.340 --> 51:51.340
就把这个新的DIV

51:51.340 --> 51:52.340
我现在把新的DIV拿到

51:52.340 --> 51:54.340
DIV6

51:54.340 --> 51:55.340
看一下

51:55.340 --> 51:56.340
是不是一样的

51:56.340 --> 51:58.340
query is negative

51:58.340 --> 51:59.340
root

52:00.340 --> 52:01.340
DIV

52:01.340 --> 52:02.340
DIV

52:02.340 --> 52:03.340
DIV

52:03.340 --> 52:04.340
好

52:04.340 --> 52:05.340
两个拿到

52:05.340 --> 52:06.340
然后我们看一下

52:06.340 --> 52:07.340
DIVold

52:07.340 --> 52:08.340
是不是等于DIV6

52:08.340 --> 52:10.340
是不是两个一样的

52:10.340 --> 52:11.340
说明它们动物对象

52:11.340 --> 52:12.340
是不是完全重用的

52:12.340 --> 52:13.340
对吧

52:13.340 --> 52:14.340
因此

52:14.340 --> 52:15.340
这就是为什么

52:15.340 --> 52:16.340
这就是解释了

52:16.340 --> 52:17.340
为什么你看一下

52:17.340 --> 52:18.340
看一下这个animate成词里边

52:18.340 --> 52:20.340
当我们点击的时候

52:20.340 --> 52:22.340
注意看这个DIV

52:22.340 --> 52:23.340
当我们点击的时候

52:23.340 --> 52:24.340
你看这个DIV都没动

52:24.340 --> 52:25.340
对吧

52:25.340 --> 52:26.340
没动

52:26.340 --> 52:27.340
因为它里边

52:27.340 --> 52:28.340
它本身

52:28.340 --> 52:30.340
它的对象是没有发生变化的

52:30.340 --> 52:31.340
并没有发生

52:31.340 --> 52:32.340
它的对象并没有发生变化

52:32.340 --> 52:33.340
所以说呢

52:33.340 --> 52:34.340
这个DIV呢

52:34.340 --> 52:36.340
是重用的是之前的

52:36.340 --> 52:37.340
这就是说

52:37.340 --> 52:38.340
为什么会重用

52:38.340 --> 52:39.340
因为它们的动物

52:39.340 --> 52:40.340
它们的内形一致

52:40.340 --> 52:41.340
节点内形一致

52:41.340 --> 52:42.340
所以说

52:42.340 --> 52:43.340
如果是冲击点

52:43.340 --> 52:44.340
不做任何事情

52:44.340 --> 52:45.340
如果是动物节点的话

52:45.340 --> 52:46.340
它会直接使用

52:46.340 --> 52:47.340
之前的真识动物对象

52:47.340 --> 52:48.340
然后不只如此

52:48.340 --> 52:50.340
它还要做这么一件事

52:50.340 --> 52:51.340
啊

52:52.340 --> 52:53.340
嗯

52:53.340 --> 52:54.340
这是动物对象

52:54.340 --> 52:56.340
然后刚才还是要分

52:56.340 --> 52:57.340
分成几步来写

52:57.340 --> 52:58.340
几步来写

52:58.340 --> 53:01.670
第一步

53:01.670 --> 53:02.670
直接

53:02.670 --> 53:04.670
重用

53:04.670 --> 53:06.670
之前的

53:06.670 --> 53:08.670
真识动物对象

53:08.670 --> 53:09.670
啊

53:09.670 --> 53:10.670
但是呢

53:10.670 --> 53:11.670
是不是要设置

53:11.670 --> 53:12.670
动物对象的属性啊

53:12.670 --> 53:13.670
当然属性有可能会改变

53:13.670 --> 53:14.670
对吧

53:14.670 --> 53:15.670
属性有可能会改变

53:15.670 --> 53:17.670
只是我这里没有改变属性而已

53:17.670 --> 53:18.670
就这里

53:18.670 --> 53:19.670
我没有给这个DIV

53:19.670 --> 53:20.670
加上任何属性

53:20.670 --> 53:21.670
如果属性依赖于状态的话

53:21.670 --> 53:22.670
属性是不是也跟着变

53:22.670 --> 53:23.670
啊

53:23.670 --> 53:24.670
然后

53:24.670 --> 53:26.670
将其属性的变化

53:26.670 --> 53:29.670
将其属性的变化

53:29.670 --> 53:30.670
记录下来

53:30.670 --> 53:31.670
就是有哪些变化

53:31.670 --> 53:32.670
把记录下来

53:32.670 --> 53:33.670
啊

53:33.670 --> 53:35.670
它现在不会真正的变化啊

53:35.670 --> 53:36.670
也就说现在

53:36.670 --> 53:39.670
现在不会真正的变化

53:39.670 --> 53:41.670
只是把它做记录啊

53:41.670 --> 53:42.670
给它记录下来

53:42.670 --> 53:43.670
不会真正的变化啊

53:43.670 --> 53:45.670
什么时候真正的变化

53:46.670 --> 53:47.670
这里

53:47.670 --> 53:49.670
完成真识动物更新

53:49.670 --> 53:50.670
就是后续步骤

53:50.670 --> 53:51.670
当所有事情做完过后

53:51.670 --> 53:53.670
开始完成真实的动物更新

53:53.670 --> 53:54.670
啊

53:54.670 --> 53:55.670
在这个时候呢

53:55.670 --> 53:56.670
那么开始进行变化

53:56.670 --> 53:57.670
啊

53:57.670 --> 53:58.670
它开始进行变化

53:58.670 --> 53:59.670
这么回事啊

53:59.670 --> 54:01.670
原来的意思吧

54:01.670 --> 54:03.670
将属性的变化记录下来

54:03.670 --> 54:06.110
啊

54:06.110 --> 54:07.110
以待

54:07.110 --> 54:08.110
啊

54:08.110 --> 54:09.110
以待

54:09.110 --> 54:11.110
将来完成

54:11.110 --> 54:12.110
统一

54:12.110 --> 54:13.110
完成更新

54:13.110 --> 54:14.110
把所有的动物节点

54:14.110 --> 54:15.110
全部变化记录下来过后

54:15.110 --> 54:17.110
以后统一完成更新

54:17.110 --> 54:18.110
而不是

54:18.110 --> 54:20.110
看一点更新一点

54:20.110 --> 54:21.110
不会这样子

54:21.110 --> 54:22.110
它为了提高效率

54:22.110 --> 54:24.110
到时候是统一更新的

54:24.110 --> 54:25.110
好

54:25.110 --> 54:26.110
这是这个步骤

54:26.110 --> 54:27.110
好

54:27.110 --> 54:28.110
下一步

54:28.110 --> 54:29.110
啊

54:29.110 --> 54:30.110
下一步

54:30.110 --> 54:31.110
下一步干嘛呢

54:31.110 --> 54:33.110
下一步就是说

54:33.110 --> 54:35.110
你这个是真实动物对象

54:35.110 --> 54:36.110
对吧

54:36.110 --> 54:37.110
动物对象那是不是有直接点

54:37.110 --> 54:38.110
对不对

54:38.110 --> 54:40.110
是不是有求准属性啊

54:40.110 --> 54:41.110
便利

54:41.110 --> 54:42.110
该

54:42.110 --> 54:43.110
元素

54:43.110 --> 54:45.110
react元素

54:45.110 --> 54:47.110
它对应的react元素嘛

54:47.110 --> 54:48.110
对不对

54:48.110 --> 54:50.110
便利该react元素

54:50.110 --> 54:51.110
一会儿呢

54:51.110 --> 54:52.110
你看

54:52.110 --> 54:53.110
一会儿你返回给

54:53.110 --> 54:54.110
返回给它的

54:54.110 --> 54:55.110
比方说我们刚才

54:55.110 --> 54:56.110
Render的时候

54:56.110 --> 54:57.110
所以返回给它一个react元素

54:57.110 --> 54:58.110
对吧

54:58.110 --> 55:00.110
那么便利这个新的元素的啊

55:00.110 --> 55:04.110
便利该新的react元素的

55:04.110 --> 55:05.110
啊

55:05.110 --> 55:06.110
指元素

55:06.110 --> 55:08.110
变成它的指元素

55:08.110 --> 55:10.110
然后

55:10.110 --> 55:11.110
重新

55:11.110 --> 55:12.110
就是

55:12.110 --> 55:13.110
第一规

55:13.110 --> 55:15.110
对比更新

55:16.110 --> 55:18.110
第一规对比更新

55:18.110 --> 55:19.110
什么意思

55:19.110 --> 55:20.110
又回到这个步骤了

55:20.110 --> 55:21.110
对比更新这一个步骤

55:21.110 --> 55:22.110
对吧

55:22.110 --> 55:23.110
又回到这个步骤了

55:23.110 --> 55:24.110
怎么找对比的目标

55:24.110 --> 55:25.110
然后又怎么样

55:25.110 --> 55:26.110
又回到这个步骤了

55:26.110 --> 55:27.110
又重新来

55:27.110 --> 55:28.110
所以回到这

55:28.110 --> 55:29.110
回到这

55:29.110 --> 55:30.110
找到对比的目标

55:30.110 --> 55:32.110
或者是没有找到对比目标

55:32.110 --> 55:33.110
就是回到这

55:33.110 --> 55:34.110
对比更新

55:34.110 --> 55:35.110
又重新开始这个流程

55:35.110 --> 55:37.110
整个流程又重新来一遍

55:37.110 --> 55:40.110
便利该新的react元素

55:40.110 --> 55:42.110
第一规对比更新

55:43.110 --> 55:44.110
也就是说在更新

55:44.110 --> 55:46.110
它的指元素的时候

55:46.110 --> 55:48.110
你当前的变化还拿不到

55:48.110 --> 55:50.110
你还拿不到它的变化

55:50.110 --> 55:51.110
不要这个意思吧

55:51.110 --> 55:53.110
因为它现在还没有真正的变化

55:53.110 --> 55:56.110
它到最后是统一变化的

55:56.110 --> 55:57.110
好

55:57.110 --> 55:59.110
那么现在我们看动物节点

55:59.110 --> 56:02.110
这个动物节点是不是已经完成更新了

56:02.110 --> 56:04.110
真实的重用

56:04.110 --> 56:06.110
然后记录记录什么记录

56:06.110 --> 56:08.110
还要记录

56:09.110 --> 56:10.110
重用

56:10.110 --> 56:14.260
还要记录

56:14.260 --> 56:16.260
记录变化的部分

56:16.260 --> 56:17.260
变化的属性

56:17.260 --> 56:19.260
当然它现在没有变化的属性

56:19.260 --> 56:20.260
没有变化的属性

56:20.260 --> 56:21.260
那就没有记录

56:21.260 --> 56:22.260
但是它肯定要做这件事

56:22.260 --> 56:24.260
肯定要做这件事

56:24.260 --> 56:26.260
就是记录变化的属性

56:26.260 --> 56:29.260
那么这个节点是不是更新就完了

56:29.260 --> 56:30.260
对比更新就完成了

56:30.260 --> 56:32.260
接下来下一个节点

56:32.260 --> 56:33.260
那么它的下一个节点是谁

56:33.260 --> 56:35.260
你看新创建的动物对象

56:35.260 --> 56:37.260
下一个节点是不是指节点

56:37.260 --> 56:38.260
又一个个来

56:38.260 --> 56:40.260
H1又来

56:40.260 --> 56:42.260
H1这个指节点

56:42.260 --> 56:43.260
好来

56:43.260 --> 56:44.260
那么它下面的指节点

56:44.260 --> 56:45.260
它就完了

56:45.260 --> 56:48.260
它的对比更新就完了

56:48.260 --> 56:50.260
这里换个颜色

56:50.260 --> 56:52.260
不知道用什么颜色

56:52.260 --> 56:53.260
那么这里呢

56:53.260 --> 56:55.260
换了一个节点了

56:55.260 --> 56:56.260
现在是动物节点

56:56.260 --> 56:57.260
H1

56:57.260 --> 56:59.260
H1这个节点

56:59.260 --> 57:01.260
然后它现在是不是又要重新来一遍

57:01.260 --> 57:02.260
H1这个节点

57:02.260 --> 57:04.260
是不是又要从旧的树里面去找

57:04.260 --> 57:06.260
找了它要对比的东西

57:06.260 --> 57:07.260
是不是要对比这个

57:07.260 --> 57:09.260
要对比这个玩意儿了

57:09.260 --> 57:11.260
是不是要对比这个玩意儿

57:11.260 --> 57:13.260
没问题吧

57:13.260 --> 57:14.260
它要对比这个玩意儿了

57:14.260 --> 57:16.260
那么对比它的时候

57:16.260 --> 57:17.260
又来一遍

57:17.260 --> 57:19.260
它们都是动物节点

57:19.260 --> 57:21.260
是不是比较节点内形

57:21.260 --> 57:22.260
是不是一样的

57:22.260 --> 57:24.260
都是H1说节点内形一样

57:24.260 --> 57:26.260
节点内形一样的话

57:26.260 --> 57:28.260
是不是要重用

57:28.260 --> 57:30.260
重用真实动物

57:30.260 --> 57:32.260
之前的真实动物拿过来

57:32.260 --> 57:33.260
重用

57:33.260 --> 57:35.260
是不是要记住变化的属性

57:35.260 --> 57:36.260
对不对

57:36.260 --> 57:37.260
又要记住变化的属性

57:37.260 --> 57:39.260
那么这个对比是不是完了

57:39.260 --> 57:41.260
对比就完了

57:41.260 --> 57:43.260
然后这个还没完

57:43.260 --> 57:45.260
它还有指节点

57:45.260 --> 57:46.260
是一个文本节点

57:46.260 --> 57:47.260
OK

57:47.260 --> 57:48.260
那么现在有

57:48.260 --> 57:50.260
它H1下面

57:50.260 --> 57:52.260
是不是有文本节点吗

57:52.260 --> 57:53.260
OK

57:53.260 --> 57:54.260
那么现在又对比文本节点

57:54.260 --> 57:55.260
它又对比完了

57:55.260 --> 57:56.260
那么现在又对比

57:56.260 --> 57:57.260
它下面的文本节点

57:57.260 --> 57:58.260
就是这样一个

57:58.260 --> 58:00.260
重复了地规的过程

58:00.260 --> 58:02.260
这不是一个动物节点的

58:02.260 --> 58:03.260
这是文本节点

58:03.260 --> 58:04.260
H1

58:04.260 --> 58:05.260
不

58:05.260 --> 58:06.260
这是文本节点

58:06.260 --> 58:07.260
那么这个新的文本是啥呢

58:07.260 --> 58:08.260
新的文本

58:08.260 --> 58:09.260
我们给它的是啥

58:09.260 --> 58:11.260
给它的是来自于状态的

58:11.260 --> 58:12.260
对不对

58:12.260 --> 58:13.260
那么点了过后

58:13.260 --> 58:14.260
变成321了

58:14.260 --> 58:16.260
它的文本节点变成321了

58:16.260 --> 58:18.260
于是这里变成321

58:18.260 --> 58:19.260
OK

58:19.260 --> 58:21.260
那么现在我们来看一下

58:21.260 --> 58:23.260
这里

58:23.260 --> 58:27.490
尖头跑了去

58:27.490 --> 58:30.060
现在对比的是这个了

58:30.060 --> 58:33.370
对比的是文本节点了

58:33.370 --> 58:35.370
我讲的有点啰嗦

58:35.370 --> 58:37.370
因为我总担心你这里一块

58:37.370 --> 58:38.370
理解得不够透彻

58:38.370 --> 58:39.370
但是我觉得无所谓

58:39.370 --> 58:41.370
因为我们用的是视频课程

58:41.370 --> 58:42.370
你觉得啰嗦的话

58:42.370 --> 58:43.370
你就快进

58:43.370 --> 58:44.370
你就快进

58:44.370 --> 58:45.370
或者是

58:45.370 --> 58:46.370
加快那个播放速度

58:46.370 --> 58:47.370
好

58:47.370 --> 58:49.370
现在对比文本节点

58:49.370 --> 58:50.370
对比

58:50.370 --> 58:52.370
那么文本节点是怎么对比的呢

58:52.370 --> 58:53.370
咱们来看一下

58:53.370 --> 58:56.370
文本节点的对比方式

58:56.370 --> 58:57.370
文本节点

58:57.370 --> 58:59.370
如果你是一个文本节点的话

58:59.370 --> 59:00.370
那么怎么来对比

59:00.370 --> 59:01.370
好

59:01.370 --> 59:03.370
直接重用

59:03.370 --> 59:05.370
重用之前的

59:05.370 --> 59:08.370
真实的真实动物对象

59:08.370 --> 59:10.370
直接重用之前的真实动物对象

59:10.370 --> 59:11.370
因为文本节点

59:11.370 --> 59:12.370
是不是也要生成动物

59:12.370 --> 59:13.370
对不对

59:13.370 --> 59:14.370
也要生成动物

59:14.370 --> 59:15.370
是吗

59:15.370 --> 59:16.370
我们之前还演示过

59:16.370 --> 59:17.370
叫 document

59:17.370 --> 59:18.370
create

59:18.370 --> 59:19.370
生成文本节点

59:19.370 --> 59:21.370
它也是真实动物对象

59:21.370 --> 59:22.370
也是要重用

59:22.370 --> 59:24.370
也是要重用

59:24.370 --> 59:26.370
重用之后呢

59:26.370 --> 59:28.370
那么它只是改变什么

59:28.370 --> 59:29.370
也是记录变化的

59:29.370 --> 59:30.370
value

59:30.370 --> 59:32.370
记录变化的

59:32.370 --> 59:33.370
value

59:33.370 --> 59:35.370
因为

59:35.370 --> 59:36.370
不知道大家

59:36.370 --> 59:37.370
这是基础

59:37.370 --> 59:39.370
不知道大家

59:39.370 --> 59:40.370
这一会儿基础怎么样

59:40.370 --> 59:42.370
create text load

59:42.370 --> 59:43.370
不是创建一个文本节点吗

59:43.370 --> 59:44.370
对吧

59:44.370 --> 59:46.370
是不是拿到文本节点对象

59:46.370 --> 59:47.370
这就是个动物对象

59:47.370 --> 59:48.370
对不对

59:48.370 --> 59:49.370
txt

59:49.370 --> 59:50.370
那么这个

59:50.370 --> 59:52.370
这个节点对象里面

59:52.370 --> 59:53.370
不是一个value

59:53.370 --> 59:55.370
load value

59:55.370 --> 59:56.370
我到时候是不是要改变

59:56.370 --> 59:57.370
它的load value

59:57.370 --> 59:58.370
对不对

59:58.370 --> 01:00:00.370
它比之前是

01:00:00.370 --> 01:00:02.370
之前是123000变成321

01:00:02.370 --> 01:00:04.370
那么我要记录这个value

01:00:04.370 --> 01:00:05.370
记录这个value

01:00:05.370 --> 01:00:06.370
所以说

01:00:06.370 --> 01:00:07.370
到时候

01:00:07.370 --> 01:00:08.370
我会把这个

01:00:08.370 --> 01:00:10.370
要变化的东西

01:00:10.370 --> 01:00:11.370
把记录下来

01:00:11.370 --> 01:00:12.370
load value

01:00:12.370 --> 01:00:14.370
将来发生变化

01:00:14.370 --> 01:00:15.370
现在不变

01:00:15.370 --> 01:00:16.370
那么之前是123000

01:00:16.370 --> 01:00:17.370
现在是不是321000

01:00:17.370 --> 01:00:18.370
对吧

01:00:18.370 --> 01:00:19.370
321000

01:00:19.370 --> 01:00:20.370
那么把记录下来

01:00:20.370 --> 01:00:21.370
把记录下来就行了

01:00:21.370 --> 01:00:22.370
我现在不变

01:00:22.370 --> 01:00:23.370
我现在不给你变

01:00:23.370 --> 01:00:25.370
到时候我自然会给你变化

01:00:25.370 --> 01:00:26.370
好

01:00:26.370 --> 01:00:27.370
这是文本节点对吧

01:00:27.370 --> 01:00:28.370
那么这个变例结束了

01:00:28.370 --> 01:00:30.370
这个变例结束了

01:00:30.370 --> 01:00:31.370
OK

01:00:31.370 --> 01:00:32.370
那么回到这

01:00:32.370 --> 01:00:33.370
回到这

01:00:33.370 --> 01:00:34.370
现在刚才这变例的

01:00:34.370 --> 01:00:35.370
H1

01:00:35.370 --> 01:00:36.370
H1又变例了

01:00:36.370 --> 01:00:37.370
它里边的指援数

01:00:37.370 --> 01:00:38.370
那么现在又回到这

01:00:38.370 --> 01:00:39.370
因为DIV的指援数

01:00:39.370 --> 01:00:40.370
除了H1之外

01:00:40.370 --> 01:00:41.370
还有一个

01:00:41.370 --> 01:00:43.370
组件节点

01:00:43.370 --> 01:00:45.370
那么现在看组件节点了

01:00:45.370 --> 01:00:48.680
这个东西我就伤了

01:00:48.680 --> 01:00:49.680
我真的没法画

01:00:49.680 --> 01:00:50.680
画不下了

01:00:50.680 --> 01:00:51.680
我就把伤了

01:00:51.680 --> 01:00:52.680
那么现在

01:00:52.680 --> 01:00:53.680
又来对比这个节点

01:00:53.680 --> 01:00:54.680
组

01:00:54.680 --> 01:00:55.680
组件节点

01:00:55.680 --> 01:01:00.140
组件节点

01:01:02.140 --> 01:01:04.140
哪个组件节点呢

01:01:04.140 --> 01:01:06.140
新的组件节点是啥

01:01:06.140 --> 01:01:07.140
新的组件节点

01:01:07.140 --> 01:01:09.140
你看一下

01:01:09.140 --> 01:01:11.140
新的组件节点

01:01:11.140 --> 01:01:12.140
是不是

01:01:12.140 --> 01:01:14.140
抗B对吧

01:01:14.140 --> 01:01:16.140
抗B是一个函数组件

01:01:16.140 --> 01:01:18.140
抗B

01:01:18.140 --> 01:01:19.140
方可行

01:01:19.140 --> 01:01:20.140
抗B

01:01:20.140 --> 01:01:21.140
我们来看一下

01:01:21.140 --> 01:01:23.140
组件节点是如何来对比的

01:01:23.140 --> 01:01:24.140
那么它对比

01:01:24.140 --> 01:01:25.140
它首先找位置

01:01:25.140 --> 01:01:26.140
是不是找到它了

01:01:26.140 --> 01:01:27.140
对吧

01:01:27.140 --> 01:01:28.140
对比它

01:01:28.140 --> 01:01:29.140
看一下

01:01:29.140 --> 01:01:32.710
组件节点如何来对比

01:01:32.710 --> 01:01:33.710
那么就是

01:01:33.710 --> 01:01:34.710
这个

01:01:34.710 --> 01:01:35.710
这个组件节点

01:01:35.710 --> 01:01:36.710
跟这个组件节点

01:01:36.710 --> 01:01:37.710
进行对比对吧

01:01:37.710 --> 01:01:39.710
那么怎么来对比呢

01:01:39.710 --> 01:01:40.710
那肯定是

01:01:40.710 --> 01:01:41.710
我们这里前提条件

01:01:41.710 --> 01:01:42.710
是同类型的

01:01:42.710 --> 01:01:43.710
前提条件

01:01:43.710 --> 01:01:44.710
是同类型的节点

01:01:44.710 --> 01:01:46.710
有两个组件是一样的

01:01:46.710 --> 01:01:47.710
刚才没写完

01:01:47.710 --> 01:01:49.710
将

01:01:49.710 --> 01:01:50.710
文本

01:01:50.710 --> 01:01:52.710
将新的

01:01:52.710 --> 01:01:53.710
文本变化

01:01:53.710 --> 01:01:55.710
记录下来

01:01:55.710 --> 01:01:57.710
将来

01:01:57.710 --> 01:02:00.710
统一完成更新

01:02:00.710 --> 01:02:01.710
看一下

01:02:01.710 --> 01:02:02.710
看一下这个文本节点

01:02:02.710 --> 01:02:03.710
看一下

01:02:03.710 --> 01:02:04.710
他们是不是同一个文本

01:02:04.710 --> 01:02:06.710
别人还不信

01:02:06.710 --> 01:02:07.710
是不是同一个文本节点

01:02:07.710 --> 01:02:08.710
之前是一二三

01:02:08.710 --> 01:02:09.710
对吧

01:02:09.710 --> 01:02:10.710
之前是一二三

01:02:10.710 --> 01:02:11.710
咱们先拿到

01:02:11.710 --> 01:02:13.710
O的TST

01:02:13.710 --> 01:02:14.710
拿到什么

01:02:14.710 --> 01:02:16.710
拿到document

01:02:16.710 --> 01:02:17.710
query is negative

01:02:17.710 --> 01:02:18.710
达到什么

01:02:18.710 --> 01:02:20.710
H1里面的

01:02:20.710 --> 01:02:22.710
就是入彩下面DIV

01:02:22.710 --> 01:02:24.710
DIV下面的H1

01:02:24.710 --> 01:02:26.710
那么就是入彩

01:02:26.710 --> 01:02:28.710
下面的DIV

01:02:28.710 --> 01:02:30.710
DIV下面的DIV

01:02:30.710 --> 01:02:31.710
H1

01:02:31.710 --> 01:02:33.710
拿到这个H1元素

01:02:33.710 --> 01:02:34.710
H元素找到他的什么

01:02:34.710 --> 01:02:35.710
找到他的child

01:02:35.710 --> 01:02:37.710
load

01:02:37.710 --> 01:02:38.710
他的所有的

01:02:38.710 --> 01:02:39.710
直接点到第1个

01:02:39.710 --> 01:02:41.710
第1个不就是文本节点吗

01:02:41.710 --> 01:02:42.710
来看一下

01:02:42.710 --> 01:02:44.710
O的TST

01:02:44.710 --> 01:02:45.710
不就是一二三吗

01:02:45.710 --> 01:02:46.710
对吧

01:02:46.710 --> 01:02:47.710
文本节点

01:02:47.710 --> 01:02:49.710
然后我们更新

01:02:49.710 --> 01:02:51.710
更新完了过后

01:02:51.710 --> 01:02:52.710
咱们再来找一下

01:02:52.710 --> 01:02:55.710
这个节点

01:02:55.710 --> 01:02:56.710
New

01:02:56.710 --> 01:02:57.710
TST

01:02:57.710 --> 01:02:58.710
再来找一下这个节点

01:02:58.710 --> 01:02:59.710
好

01:02:59.710 --> 01:03:00.710
然后我们看一下

01:03:00.710 --> 01:03:02.710
O的TST

01:03:02.710 --> 01:03:03.710
是不是跟

01:03:03.710 --> 01:03:05.710
New的TST

01:03:05.710 --> 01:03:06.710
是一样的

01:03:06.710 --> 01:03:07.710
是不是

01:03:07.710 --> 01:03:08.710
所以说文本节点

01:03:08.710 --> 01:03:09.710
它动物对象仍然是重用的

01:03:09.710 --> 01:03:11.710
它重用度非常非常高

01:03:11.710 --> 01:03:12.710
你不用担心

01:03:12.710 --> 01:03:13.710
它

01:03:13.710 --> 01:03:14.710
其实这个步骤里面

01:03:14.710 --> 01:03:15.710
你看一下

01:03:15.710 --> 01:03:16.710
至少在目前我们看到的一部分

01:03:16.710 --> 01:03:17.710
没有一个

01:03:17.710 --> 01:03:18.710
任何一个新的元素

01:03:18.710 --> 01:03:20.710
真实动物的对象产生

01:03:20.710 --> 01:03:21.710
也没有任何一个

01:03:21.710 --> 01:03:22.710
动物对象被移除

01:03:22.710 --> 01:03:24.710
所以它的效率非常非常高

01:03:24.710 --> 01:03:25.710
所以RX这里面

01:03:25.710 --> 01:03:26.710
根本不用担心它的渲染

01:03:26.710 --> 01:03:27.710
渲染真实动物的效率

01:03:27.710 --> 01:03:30.710
因为它是重用之前的动物对象

01:03:30.710 --> 01:03:32.710
明白的意思吧

01:03:32.710 --> 01:03:34.710
那么现在看组建节点

01:03:34.710 --> 01:03:35.710
组建节点

01:03:35.710 --> 01:03:36.710
跟它进行对比

01:03:36.710 --> 01:03:37.710
那么两个类型一致

01:03:37.710 --> 01:03:38.710
进入这个流测

01:03:38.710 --> 01:03:39.710
那么如果你是

01:03:39.710 --> 01:03:40.710
组建节点的话

01:03:40.710 --> 01:03:41.710
那么该怎么办

01:03:42.710 --> 01:03:43.710
组建节点是不是要分为

01:03:43.710 --> 01:03:44.710
两种组建

01:03:44.710 --> 01:03:46.710
一种是函数组建

01:03:46.710 --> 01:03:48.710
就是组建节点

01:03:48.710 --> 01:03:50.710
两种组建

01:03:50.710 --> 01:03:53.710
一种是函数组建

01:03:53.710 --> 01:03:54.710
如果你是一个

01:03:54.710 --> 01:03:56.710
函数组建的话

01:03:56.710 --> 01:03:57.710
该怎么办呢

01:03:57.710 --> 01:03:58.710
如果你是一个

01:03:58.710 --> 01:03:59.710
函数组建的话

01:03:59.710 --> 01:04:01.710
该怎么办

01:04:01.710 --> 01:04:02.710
是这样子

01:04:02.710 --> 01:04:04.710
直接重新调用函数

01:04:04.710 --> 01:04:06.710
就完事了

01:04:06.710 --> 01:04:07.710
就这么简单

01:04:07.710 --> 01:04:09.710
直接重新调用函数

01:04:09.710 --> 01:04:10.710
函数组建

01:04:10.710 --> 01:04:11.710
非常非常简单

01:04:11.710 --> 01:04:12.710
非常非常简单

01:04:12.710 --> 01:04:16.710
直接重新调用函数

01:04:16.710 --> 01:04:17.710
函数

01:04:17.710 --> 01:04:19.710
得到一个

01:04:19.710 --> 01:04:22.710
就是节点对象

01:04:22.710 --> 01:04:23.710
对吧

01:04:23.710 --> 01:04:24.710
又进入

01:04:24.710 --> 01:04:26.710
进入地规

01:04:26.710 --> 01:04:29.710
进入地规对比更新

01:04:29.710 --> 01:04:33.730
你重新调用函数组建

01:04:33.730 --> 01:04:34.730
那么也就是说

01:04:34.730 --> 01:04:35.730
这里你看

01:04:35.730 --> 01:04:36.730
Comp B的时候

01:04:36.730 --> 01:04:37.730
对比到这个组建的时候

01:04:37.730 --> 01:04:39.730
它其实没有做啥事情

01:04:39.730 --> 01:04:40.730
没做啥事情

01:04:40.730 --> 01:04:41.730
它之前有这个组建

01:04:41.730 --> 01:04:43.730
现在不是还有这个组建

01:04:43.730 --> 01:04:45.730
两个都是函数组建

01:04:45.730 --> 01:04:48.730
那我现在也没什么事情可以做

01:04:48.730 --> 01:04:50.730
就调用这个函数就完事了

01:04:50.730 --> 01:04:51.730
那么调用这个函数

01:04:51.730 --> 01:04:52.730
是不是又拿到一个组建了

01:04:52.730 --> 01:04:53.730
调用这个函数

01:04:53.730 --> 01:04:54.730
调用这个函数

01:04:54.730 --> 01:04:55.730
是不是拿到一个组建了

01:04:55.730 --> 01:04:56.730
拿到什么组建

01:04:56.730 --> 01:04:57.730
又拿到这个DIB组建了

01:04:57.730 --> 01:04:58.730
就拿到这个DIB组建了

01:04:58.730 --> 01:04:59.730
调用函数

01:04:59.730 --> 01:05:00.730
OK

01:05:00.730 --> 01:05:02.730
那我直接调用函数就完事了

01:05:02.730 --> 01:05:03.730
直接调用函数就完事了

01:05:03.730 --> 01:05:05.730
那么是不是又拿到一个组建了

01:05:05.730 --> 01:05:06.730
拿到这个组建

01:05:06.730 --> 01:05:07.730
那么直接下来

01:05:07.730 --> 01:05:09.730
又来对比这个组建

01:05:09.730 --> 01:05:11.730
还是进入对比更新的流程

01:05:11.730 --> 01:05:12.730
那这又是个动物组建

01:05:12.730 --> 01:05:14.730
是不是对比之前那个位置

01:05:14.730 --> 01:05:16.730
对比之前这个位置

01:05:16.730 --> 01:05:17.730
不要我这意思吧

01:05:17.730 --> 01:05:18.730
我后面就不挨在这说了

01:05:18.730 --> 01:05:20.730
又把它真实的动物对象拿过来重用

01:05:20.730 --> 01:05:21.730
对吧

01:05:21.730 --> 01:05:22.730
又来基础它自己的变化值

01:05:22.730 --> 01:05:24.730
又来地规它更新它里面的什么

01:05:24.730 --> 01:05:25.730
切入损

01:05:25.730 --> 01:05:26.730
我就不重复说了

01:05:26.730 --> 01:05:27.730
我就不重复说了

01:05:29.730 --> 01:05:30.730
就是一个地规的更新流程

01:05:30.730 --> 01:05:31.730
我们这里

01:05:31.730 --> 01:05:33.730
全部的一切的前提条件

01:05:33.730 --> 01:05:35.730
都是节建类型一致

01:05:35.730 --> 01:05:36.730
好我们继续看

01:05:36.730 --> 01:05:38.730
那么这里有它的指援说

01:05:38.730 --> 01:05:40.730
对比H1

01:05:40.730 --> 01:05:41.730
H1里面又有什么

01:05:41.730 --> 01:05:43.730
又有文本节点对不对

01:05:43.730 --> 01:05:45.730
又对比H1

01:05:45.730 --> 01:05:47.730
H1里面又有文本节点

01:05:47.730 --> 01:05:49.730
这没什么好说的了

01:05:50.730 --> 01:05:51.730
对比H1

01:05:51.730 --> 01:05:54.730
H1里面是不是也有文本节点

01:05:54.730 --> 01:05:56.730
是不是也有文本节点

01:05:56.730 --> 01:05:57.730
H1里面

01:05:57.730 --> 01:05:59.730
文本节点

01:05:59.730 --> 01:06:03.230
那么这个文本节点

01:06:04.230 --> 01:06:05.230
这个文本节点

01:06:05.230 --> 01:06:06.230
该更新就更新

01:06:06.230 --> 01:06:07.230
该更新就更新

01:06:07.230 --> 01:06:08.230
比方说之前

01:06:08.230 --> 01:06:10.230
你这里不是传递这个属性吗

01:06:10.230 --> 01:06:11.230
传递的属性

01:06:11.230 --> 01:06:12.230
我文本节点点

01:06:12.230 --> 01:06:13.230
显示的是N

01:06:13.230 --> 01:06:15.230
那么N有变化了

01:06:15.230 --> 01:06:16.230
N有变化了

01:06:16.230 --> 01:06:18.230
那么你这个文本节点

01:06:18.230 --> 01:06:19.230
之前是ABCA

01:06:19.230 --> 01:06:21.230
现在变成了CBA

01:06:21.230 --> 01:06:23.230
现在变成CBA了

01:06:23.230 --> 01:06:25.230
它会把个变化要记录下来

01:06:25.230 --> 01:06:26.230
记录下来

01:06:26.230 --> 01:06:27.230
到时候统一变化

01:06:28.230 --> 01:06:29.230
这还是一样的流程

01:06:29.230 --> 01:06:31.230
那么今天我们看一下内足键

01:06:31.230 --> 01:06:33.230
那么对比到这的时候

01:06:33.230 --> 01:06:34.230
它就是一次地规对比

01:06:34.230 --> 01:06:35.230
我就不一个个说了

01:06:35.230 --> 01:06:37.230
一个个说太麻烦了

01:06:38.230 --> 01:06:40.230
那么看到对比到这了

01:06:40.230 --> 01:06:42.230
现在对比到这了

01:06:42.230 --> 01:06:43.230
内足键

01:06:43.230 --> 01:06:45.230
内足键

01:06:45.230 --> 01:06:46.230
看一下内足键

01:06:46.230 --> 01:06:48.230
它肯定要复杂一些

01:06:48.230 --> 01:06:50.230
那么对比到内足键的时候

01:06:50.230 --> 01:06:51.230
它怎么来

01:06:51.230 --> 01:06:52.230
它做哪些事情呢

01:06:52.230 --> 01:06:54.230
它首先这样子

01:06:54.230 --> 01:06:55.230
前提条件

01:06:55.230 --> 01:06:57.230
一定是

01:06:57.230 --> 01:06:59.230
一定是那个

01:06:59.230 --> 01:07:01.230
主键内型一致

01:07:01.230 --> 01:07:05.060
内足键

01:07:05.060 --> 01:07:07.060
内足键的情况下

01:07:07.060 --> 01:07:08.060
那么它做哪些事情呢

01:07:08.060 --> 01:07:09.060
第一步

01:07:09.060 --> 01:07:11.060
重用

01:07:11.060 --> 01:07:13.060
之前的对象

01:07:13.060 --> 01:07:15.060
之前的实力

01:07:15.060 --> 01:07:16.060
也就是它不会去

01:07:16.060 --> 01:07:18.060
给你重新产生一个六一个了

01:07:18.060 --> 01:07:20.060
不会重新给你去六一个

01:07:20.060 --> 01:07:21.060
之前你这里不是有一个

01:07:21.060 --> 01:07:22.060
抗不死的实力吗

01:07:22.060 --> 01:07:24.060
直接拿过来用

01:07:24.060 --> 01:07:26.060
直接拿过来用

01:07:26.060 --> 01:07:27.060
就这么个意思

01:07:27.060 --> 01:07:29.060
重用之前的实力

01:07:29.060 --> 01:07:30.060
然后呢

01:07:30.060 --> 01:07:31.060
进入

01:07:31.060 --> 01:07:32.060
是不是进入生命周期了

01:07:33.060 --> 01:07:34.060
调用

01:07:34.060 --> 01:07:35.060
调用什么呢

01:07:35.060 --> 01:07:36.060
那个方法

01:07:36.060 --> 01:07:37.060
生命周期方法

01:07:37.060 --> 01:07:39.060
生命周期方法

01:07:39.060 --> 01:07:40.060
什么方法

01:07:40.060 --> 01:07:41.060
就这个方法

01:07:41.060 --> 01:07:44.370
调用这个方法

01:07:44.370 --> 01:07:45.370
然后呢

01:07:45.370 --> 01:07:46.370
再调用

01:07:46.370 --> 01:07:49.370
生命周期方法

01:07:49.370 --> 01:07:50.370
打个方法

01:07:50.370 --> 01:07:52.370
should component update

01:07:52.370 --> 01:07:53.370
性能优化点

01:07:53.370 --> 01:07:54.370
调用这个方法

01:07:54.370 --> 01:07:55.370
若

01:07:55.370 --> 01:07:56.370
该方法

01:07:56.370 --> 01:07:57.370
返回force

01:07:57.370 --> 01:07:59.370
如果它返回的是force

01:07:59.370 --> 01:08:01.370
对了

01:08:01.370 --> 01:08:02.370
终止

01:08:02.370 --> 01:08:04.370
主要这个点就终止了

01:08:04.370 --> 01:08:05.370
后边就不管了

01:08:05.370 --> 01:08:07.370
直接这个点终止

01:08:07.370 --> 01:08:08.370
你要这个意思吧

01:08:08.370 --> 01:08:10.370
如果它调用了force的话

01:08:10.370 --> 01:08:11.370
那么直接

01:08:11.370 --> 01:08:12.370
如果比较到这里

01:08:12.370 --> 01:08:13.370
调用了force

01:08:13.370 --> 01:08:14.370
直接在这里终止

01:08:14.370 --> 01:08:15.370
后边的不再对比更新了

01:08:15.370 --> 01:08:17.370
不再对比更新了

01:08:17.370 --> 01:08:18.370
就这么个意思

01:08:19.370 --> 01:08:21.370
后边的就不再对比更新了

01:08:21.370 --> 01:08:22.370
好

01:08:22.370 --> 01:08:23.370
然后呢

01:08:25.370 --> 01:08:26.370
第四步

01:08:26.370 --> 01:08:27.370
第四步

01:08:27.370 --> 01:08:29.370
如果它返回的是chew的话怎么办

01:08:29.370 --> 01:08:31.370
运行render

01:08:31.370 --> 01:08:32.370
运行render

01:08:32.370 --> 01:08:34.370
得到新的

01:08:34.370 --> 01:08:35.370
一个

01:08:35.370 --> 01:08:36.370
得到新的节点对象

01:08:36.370 --> 01:08:37.370
因为只要运行render

01:08:37.370 --> 01:08:38.370
是不是得到一个节点

01:08:38.370 --> 01:08:40.370
得到新的节点对象

01:08:40.370 --> 01:08:41.370
又进入

01:08:42.370 --> 01:08:43.370
第一规

01:08:43.370 --> 01:08:44.370
对比更新

01:08:44.370 --> 01:08:46.370
又进入这个新的节点的对比更新

01:08:46.370 --> 01:08:47.370
就这么个意思

01:08:47.370 --> 01:08:48.370
你看这个

01:08:49.370 --> 01:08:50.370
come see

01:08:50.370 --> 01:08:51.370
运行render

01:08:51.370 --> 01:08:52.370
是不是返回一个新的节点

01:08:52.370 --> 01:08:53.370
又进入它的对比更新

01:08:53.370 --> 01:08:54.370
那么后边都是动物元素

01:08:54.370 --> 01:08:55.370
就不再说了

01:08:56.370 --> 01:08:57.370
然后第五步

01:08:57.370 --> 01:08:58.370
将

01:08:58.370 --> 01:09:00.370
该对象的

01:09:00.370 --> 01:09:01.370
什么方法呢

01:09:01.370 --> 01:09:03.370
叫做component

01:09:03.370 --> 01:09:04.370
就这个方法

01:09:05.370 --> 01:09:06.370
复制一下

01:09:06.370 --> 01:09:07.370
加入对列

01:09:08.370 --> 01:09:09.370
将这个方法

01:09:09.370 --> 01:09:11.370
加入对列

01:09:11.370 --> 01:09:12.370
加入对列

01:09:12.370 --> 01:09:13.370
然后将

01:09:13.370 --> 01:09:14.370
该对象的

01:09:14.370 --> 01:09:15.370
这个方法

01:09:17.370 --> 01:09:19.370
将该对象的

01:09:19.370 --> 01:09:20.370
这个方法

01:09:20.370 --> 01:09:21.370
夹住对列

01:09:21.370 --> 01:09:22.370
对吧

01:09:22.370 --> 01:09:23.370
那么到时候呢

01:09:23.370 --> 01:09:24.370
它肯定是

01:09:24.370 --> 01:09:25.370
会挨在的

01:09:25.370 --> 01:09:26.370
从对比里边挨在的运行

01:09:26.370 --> 01:09:27.370
对吧

01:09:27.370 --> 01:09:28.370
这就是类组建的

01:09:28.370 --> 01:09:30.370
更新过程

01:09:30.370 --> 01:09:31.370
关键点在于什么

01:09:31.370 --> 01:09:32.370
关键点在于

01:09:32.370 --> 01:09:33.370
它会重用实力

01:09:33.370 --> 01:09:34.370
重用它的对象

01:09:34.370 --> 01:09:35.370
然后呢

01:09:35.370 --> 01:09:36.370
会进入生命中心的方法

01:09:37.370 --> 01:09:38.370
好

01:09:38.370 --> 01:09:39.370
接下来

01:09:39.370 --> 01:09:41.370
咱们就可以来面试体了

01:09:41.370 --> 01:09:42.370
面试体就可以来了

01:09:44.370 --> 01:09:45.370
那么比方说吧

01:09:45.370 --> 01:09:46.370
any bill

01:09:47.370 --> 01:09:48.370
any bill

01:09:48.370 --> 01:09:49.370
有这么一个方法

01:09:51.370 --> 01:09:53.370
就是叫做component

01:09:54.370 --> 01:09:55.370
叫做

01:09:56.370 --> 01:09:57.370
did update

01:09:59.370 --> 01:10:00.370
did update

01:10:01.370 --> 01:10:02.370
完成更新的方法

01:10:03.370 --> 01:10:04.370
完成更新的方法

01:10:04.370 --> 01:10:05.370
这个输出

01:10:05.370 --> 01:10:06.370
输出comp

01:10:07.370 --> 01:10:08.370
a

01:10:08.370 --> 01:10:09.370
然后呢

01:10:09.370 --> 01:10:10.370
component

01:10:10.370 --> 01:10:11.370
did update

01:10:12.370 --> 01:10:13.370
就是这个

01:10:13.370 --> 01:10:14.370
好

01:10:14.370 --> 01:10:15.370
下边呢

01:10:15.370 --> 01:10:16.370
comp c 里边也有一个

01:10:16.370 --> 01:10:17.370
那么哪个先运行

01:10:17.370 --> 01:10:19.370
comp c 还是 comp

01:10:19.370 --> 01:10:20.370
a 先运行

01:10:21.370 --> 01:10:22.370
是不是跟之前那个

01:10:22.370 --> 01:10:24.370
did mount 是一样的

01:10:24.370 --> 01:10:25.370
comp c 先运行

01:10:25.370 --> 01:10:26.370
为什么呢

01:10:26.370 --> 01:10:27.370
我们现在比方说点击

01:10:27.370 --> 01:10:29.370
就是一会我们点按钮的时候

01:10:29.370 --> 01:10:32.940
为什么我先看吧

01:10:32.940 --> 01:10:33.940
点击一般

01:10:33.940 --> 01:10:35.940
comp c 然后再comp a

01:10:35.940 --> 01:10:37.940
为什么跟之前那个是一样的道理

01:10:37.940 --> 01:10:38.940
它是这样子的一个过程

01:10:38.940 --> 01:10:39.940
就是说

01:10:39.940 --> 01:10:40.940
之前我们点了过后呢

01:10:40.940 --> 01:10:41.940
是不是

01:10:41.940 --> 01:10:42.940
调用它的set status

01:10:42.940 --> 01:10:43.940
对吧

01:10:43.940 --> 01:10:45.940
调用那个就是comp a 的set status

01:10:45.940 --> 01:10:46.940
那么第三步叫进入

01:10:46.940 --> 01:10:48.940
第一规的对比更新了

01:10:48.940 --> 01:10:50.940
那么对比更新完了过后

01:10:50.940 --> 01:10:51.940
它才会把自己的这个东西

01:10:51.940 --> 01:10:52.940
加入对列

01:10:52.940 --> 01:10:53.940
才会加入对列

01:10:53.940 --> 01:10:55.940
一代将来执行

01:10:56.940 --> 01:10:57.940
才会把这个东西

01:10:57.940 --> 01:10:58.940
加入对列

01:10:58.940 --> 01:10:59.940
所以说呢

01:10:59.940 --> 01:11:01.940
在这一块

01:11:01.940 --> 01:11:02.940
在这一块

01:11:02.940 --> 01:11:03.940
那么

01:11:03.940 --> 01:11:05.940
得到的结果就是反着的

01:11:05.940 --> 01:11:06.940
反着来的

01:11:06.940 --> 01:11:07.940
因为它是

01:11:07.940 --> 01:11:08.940
低规的

01:11:08.940 --> 01:11:10.940
包括如果它有直逐键

01:11:10.940 --> 01:11:12.940
那么也会运行它的直逐键的

01:11:12.940 --> 01:11:14.940
前运行它的直逐键的这个方法

01:11:14.940 --> 01:11:15.940
因为

01:11:15.940 --> 01:11:17.940
它直逐键对比更新完了过后

01:11:17.940 --> 01:11:19.940
那么才会进入

01:11:19.940 --> 01:11:21.940
它的后面两个步骤

01:11:21.940 --> 01:11:23.940
就这么个道理

01:11:23.940 --> 01:11:24.940
这是第一个

01:11:24.940 --> 01:11:25.940
第一个面试体容易考的

01:11:25.940 --> 01:11:27.940
面试体不太容易考的就是

01:11:27.940 --> 01:11:29.940
更加一些更加细微的规则

01:11:29.940 --> 01:11:30.940
那比方说

01:11:30.940 --> 01:11:32.940
Render的时候

01:11:32.940 --> 01:11:34.940
比方说在Type-C

01:11:34.940 --> 01:11:36.940
Type-C的Render的时候

01:11:36.940 --> 01:11:38.940
我们要获取

01:11:38.940 --> 01:11:39.940
获取什么呢

01:11:39.940 --> 01:11:41.940
获取这个东西

01:11:41.940 --> 01:11:43.940
获取这个

01:11:43.940 --> 01:11:45.940
就是

01:11:45.940 --> 01:11:46.940
这个

01:11:46.940 --> 01:11:47.940
这个里面

01:11:47.940 --> 01:11:48.940
A7里面的东西

01:11:48.940 --> 01:11:50.940
我们在运行Type-C的Render的时候

01:11:50.940 --> 01:11:52.940
我们要获取

01:11:52.940 --> 01:11:53.940
这里面的东西

01:11:53.940 --> 01:11:54.940
A7里面的东西

01:11:54.940 --> 01:11:55.940
那么我们看一下

01:11:55.940 --> 01:11:57.940
获取出来是什么结果

01:11:57.940 --> 01:11:59.940
比方说给这个A7

01:12:00.940 --> 01:12:02.940
加个ID

01:12:02.940 --> 01:12:03.940
Title嘛

01:12:03.940 --> 01:12:05.940
我们在这里Render的时候

01:12:05.940 --> 01:12:07.940
在Type-C Render的时候

01:12:08.940 --> 01:12:10.940
我们把这个Title获取到

01:12:10.940 --> 01:12:11.940
Document

01:12:11.940 --> 01:12:12.940
Curry

01:12:12.940 --> 01:12:13.940
GetsElementByID

01:12:13.940 --> 01:12:15.940
我们有真实动物操作

01:12:15.940 --> 01:12:16.940
当然

01:12:16.940 --> 01:12:17.940
真的不要像这样去做

01:12:17.940 --> 01:12:18.940
不要这样去做

01:12:18.940 --> 01:12:20.940
只是让我说明这个问题

01:12:20.940 --> 01:12:22.940
如果它存在的话

01:12:22.940 --> 01:12:23.940
如果它存在的话

01:12:23.940 --> 01:12:24.940
输出什么了

01:12:24.940 --> 01:12:26.940
输出Title的

01:12:26.940 --> 01:12:27.940
Inner

01:12:28.940 --> 01:12:29.940
输出它这个

01:12:29.940 --> 01:12:30.940
那么请问你

01:12:30.940 --> 01:12:31.940
比方的面子

01:12:31.940 --> 01:12:32.940
它可能会这样搞

01:12:32.940 --> 01:12:33.940
一般面子的不太会这样搞

01:12:33.940 --> 01:12:35.940
这个东西要搞清楚的话

01:12:35.940 --> 01:12:36.940
你不看我这个课程

01:12:36.940 --> 01:12:38.940
你怎么可能搞得清楚

01:12:38.940 --> 01:12:40.940
你只要除非去看远

01:12:40.940 --> 01:12:41.940
我都是从远

01:12:41.940 --> 01:12:43.940
基本上不断的去总结

01:12:43.940 --> 01:12:44.940
让大家不用去看远

01:12:44.940 --> 01:12:46.940
都可以了解这个过程

01:12:46.940 --> 01:12:48.940
那么输出的结果是什么

01:12:49.940 --> 01:12:50.940
第一是一开始

01:12:50.940 --> 01:12:51.940
我怎么都不做

01:12:51.940 --> 01:12:52.940
输出什么结果

01:12:53.940 --> 01:12:55.940
comb里面包含comc

01:12:55.940 --> 01:12:56.940
输出什么结果

01:12:56.940 --> 01:12:59.940
这个n一开始是一二三

01:12:59.940 --> 01:13:00.940
是一二三

01:13:01.940 --> 01:13:02.940
输出什么结果呢

01:13:04.940 --> 01:13:05.940
输出什么结果

01:13:05.940 --> 01:13:06.940
能输出一二三吗

01:13:06.940 --> 01:13:07.940
你看一下

01:13:07.940 --> 01:13:09.940
一开始是不是啥都没输出

01:13:09.940 --> 01:13:10.940
啥都没输出说明啥

01:13:10.940 --> 01:13:12.940
说明这个动物对象

01:13:12.940 --> 01:13:13.940
根本就没得到

01:13:13.940 --> 01:13:14.940
根本就没得到

01:13:14.940 --> 01:13:16.940
我们来输出一下这个Title

01:13:16.940 --> 01:13:18.940
如果这里判断为假的话

01:13:18.940 --> 01:13:19.940
我们输出Title

01:13:19.940 --> 01:13:20.940
你看一下

01:13:20.940 --> 01:13:21.940
它是用理范的

01:13:23.940 --> 01:13:24.940
你看一下

01:13:24.940 --> 01:13:25.940
它是NOW

01:13:25.940 --> 01:13:26.940
没得到

01:13:26.940 --> 01:13:27.940
为什么没得到

01:13:28.940 --> 01:13:29.940
我们之前讲上节可讲过

01:13:29.940 --> 01:13:30.940
首次渲染的时候

01:13:30.940 --> 01:13:31.940
真实的动物对象

01:13:31.940 --> 01:13:33.940
加到页面什么时候

01:13:33.940 --> 01:13:34.940
我那些事情完了之后

01:13:34.940 --> 01:13:35.940
什么Render那些

01:13:35.940 --> 01:13:36.940
这些虚计动物数

01:13:36.940 --> 01:13:37.940
全部构建完之后

01:13:37.940 --> 01:13:38.940
构建完之后

01:13:38.940 --> 01:13:39.940
我们才会把

01:13:39.940 --> 01:13:40.940
真实的动物对象

01:13:40.940 --> 01:13:41.940
加到页面上去

01:13:41.940 --> 01:13:43.940
这个时候还没有加到页面

01:13:43.940 --> 01:13:44.940
所以自然得不到

01:13:44.940 --> 01:13:45.940
自然得不到

01:13:45.940 --> 01:13:46.940
那么我们看一下

01:13:46.940 --> 01:13:48.940
一开始是一二三

01:13:48.940 --> 01:13:49.940
现在得到一二三

01:13:49.940 --> 01:13:50.940
点击的

01:13:50.940 --> 01:13:51.940
什么时候可以得到

01:13:51.940 --> 01:13:52.940
什么就是component

01:13:52.940 --> 01:13:53.940
地的mount的时候

01:13:53.940 --> 01:13:54.940
那个时候

01:13:54.940 --> 01:13:55.940
真实的动物

01:13:55.940 --> 01:13:56.940
都想去加到页面上去了

01:13:56.940 --> 01:13:57.940
那个时候可以得到

01:13:57.940 --> 01:13:58.940
那个时候没问题

01:13:58.940 --> 01:14:00.940
就是完成首次

01:14:00.940 --> 01:14:02.940
就挂载完成之后

01:14:02.940 --> 01:14:03.940
什么要挂载

01:14:03.940 --> 01:14:04.940
就是虚计动物

01:14:04.940 --> 01:14:05.940
挂载到页面上

01:14:05.940 --> 01:14:06.940
成为真实动物

01:14:06.940 --> 01:14:07.940
这是我们以前讲过的

01:14:07.940 --> 01:14:08.940
那么这个时候是可以得到的

01:14:08.940 --> 01:14:09.940
好

01:14:09.940 --> 01:14:10.940
那么现在我们点击

01:14:10.940 --> 01:14:11.940
现在是一二三

01:14:11.940 --> 01:14:12.940
点击过后

01:14:14.940 --> 01:14:15.940
对了

01:14:15.940 --> 01:14:16.940
之前是ABC

01:14:16.940 --> 01:14:17.940
现在变成CBL

01:14:17.940 --> 01:14:18.940
但是我们这里

01:14:18.940 --> 01:14:19.940
得到的是什么

01:14:19.940 --> 01:14:20.940
得到的是ABC

01:14:20.940 --> 01:14:21.940
为什么

01:14:21.940 --> 01:14:22.940
为什么得到ABC

01:14:22.940 --> 01:14:24.940
这里说了更新的流程里边

01:14:24.940 --> 01:14:26.940
你看更新的流程里边

01:14:26.940 --> 01:14:27.940
什么时候才会

01:14:27.940 --> 01:14:29.940
真正的更新动物对象

01:14:29.940 --> 01:14:30.940
是不是要把全部的

01:14:30.940 --> 01:14:31.940
虚计动物节点

01:14:31.940 --> 01:14:32.940
要重新

01:14:32.940 --> 01:14:33.940
全部对比更新完了之后

01:14:33.940 --> 01:14:34.940
最后才完成

01:14:34.940 --> 01:14:36.940
真实动物更新

01:14:36.940 --> 01:14:37.940
这个时候才完成

01:14:37.940 --> 01:14:38.940
真实动物更新

01:14:38.940 --> 01:14:40.940
是这么个意思

01:14:40.940 --> 01:14:41.940
要搞清楚

01:14:41.940 --> 01:14:42.940
这个地方要搞清楚

01:14:42.940 --> 01:14:43.940
所以一开始

01:14:43.940 --> 01:14:44.940
在Render的时候

01:14:44.940 --> 01:14:45.940
根本没有真实动物更新的

01:14:45.940 --> 01:14:46.940
它是把它记录下来

01:14:46.940 --> 01:14:47.940
将来统一的

01:14:47.940 --> 01:14:49.940
完成真实动物更新

01:14:50.940 --> 01:14:52.940
它是做了这么一个操作

01:14:53.940 --> 01:14:54.940
好了

01:14:55.940 --> 01:14:56.940
那么现在

01:14:56.940 --> 01:14:57.940
就搞定了内主键

01:14:57.940 --> 01:14:58.940
就知道了

01:14:58.940 --> 01:14:59.940
内主键就知道

01:14:59.940 --> 01:15:00.940
怎么回事了

01:15:00.940 --> 01:15:01.940
那么咱们再看

01:15:01.940 --> 01:15:02.940
还有什么主键

01:15:02.940 --> 01:15:03.940
空主节点不做任何事情

01:15:03.940 --> 01:15:04.940
动物节点

01:15:04.940 --> 01:15:05.940
说了文文节点

01:15:05.940 --> 01:15:06.940
说了主键节点

01:15:06.940 --> 01:15:07.940
也说了

01:15:07.940 --> 01:15:08.940
还有一个

01:15:08.940 --> 01:15:09.940
还有什么

01:15:09.940 --> 01:15:10.940
是不是

01:15:10.940 --> 01:15:11.940
数组节点

01:15:11.940 --> 01:15:12.940
对不对

01:15:12.940 --> 01:15:13.940
数组节点

01:15:15.940 --> 01:15:17.940
数组节点很简单

01:15:17.940 --> 01:15:19.940
就是边地数组

01:15:19.940 --> 01:15:21.940
进行对比就完事了

01:15:21.940 --> 01:15:22.940
边地数组

01:15:22.940 --> 01:15:23.940
进行对比

01:15:24.940 --> 01:15:26.940
边地数组

01:15:26.940 --> 01:15:27.940
然后进行

01:15:27.940 --> 01:15:28.940
地规

01:15:28.940 --> 01:15:30.940
对比更新

01:15:30.940 --> 01:15:31.940
又把数组里面

01:15:31.940 --> 01:15:32.940
每一个拿出来

01:15:32.940 --> 01:15:33.940
也进行对比

01:15:33.940 --> 01:15:34.940
对比更新

01:15:34.940 --> 01:15:36.940
数字现在没什么好做的了

01:15:37.940 --> 01:15:38.940
这一块

01:15:38.940 --> 01:15:39.940
全部都说的是啥

01:15:39.940 --> 01:15:40.940
全部都说的是

01:15:40.940 --> 01:15:42.940
节点内行一致

01:15:42.940 --> 01:15:44.940
节点内行一致的情况下

01:15:44.940 --> 01:15:45.940
要做的事情

01:15:45.940 --> 01:15:46.940
那如果不一致

01:15:47.940 --> 01:15:49.940
现在最好消化一下

01:15:49.940 --> 01:15:50.940
最好消化一下

01:15:50.940 --> 01:15:52.940
一致到底是怎么一种情况

01:15:52.940 --> 01:15:53.940
那么接下来我说一下

01:15:53.940 --> 01:15:55.940
如果不一致怎么办

01:15:56.940 --> 01:15:57.940
不一致怎么办

01:15:57.940 --> 01:15:59.940
这一刻是不是时间太长了

01:16:00.940 --> 01:16:01.940
时间好长

01:16:01.940 --> 01:16:02.940
没关系

01:16:02.940 --> 01:16:03.940
它是一个统一的整体

01:16:03.940 --> 01:16:05.940
我不能把它拆开

01:16:05.940 --> 01:16:06.940
慢慢消化

01:16:06.940 --> 01:16:08.940
可能内容肯定会多

01:16:08.940 --> 01:16:10.940
肯定不像官网说的那么简单

01:16:10.940 --> 01:16:12.940
如果是不一致的话

01:16:12.940 --> 01:16:13.940
内容不一致

01:16:13.940 --> 01:16:15.940
它会产生一个什么样的情况

01:16:15.940 --> 01:16:16.940
它是这样子

01:16:17.940 --> 01:16:18.940
整体上

01:16:18.940 --> 01:16:19.940
整体上

01:16:19.940 --> 01:16:20.940
卸载

01:16:20.940 --> 01:16:22.940
就是从整体的原则

01:16:22.940 --> 01:16:24.940
它是要卸载

01:16:24.940 --> 01:16:25.940
旧的

01:16:26.940 --> 01:16:27.940
节点

01:16:28.940 --> 01:16:29.940
然后创建

01:16:30.940 --> 01:16:31.940
全新创建

01:16:32.940 --> 01:16:33.940
全新创建

01:16:34.940 --> 01:16:35.940
新的节点

01:16:36.940 --> 01:16:37.940
它整个问题是这样子

01:16:37.940 --> 01:16:39.940
因为它是基于一种假设

01:16:39.940 --> 01:16:40.940
假设什么呢

01:16:40.940 --> 01:16:42.940
假设说那个假设在哪

01:16:42.940 --> 01:16:44.940
就是不同的节点内行

01:16:44.940 --> 01:16:45.940
会产生不同的结构

01:16:45.940 --> 01:16:47.940
那么以前的节点内行是不一致的

01:16:47.940 --> 01:16:49.940
那么说明之前的结构

01:16:49.940 --> 01:16:50.940
跟之前的结构

01:16:50.940 --> 01:16:51.940
你不要再做什么对比了

01:16:51.940 --> 01:16:53.940
直接把之前扔上得了

01:16:53.940 --> 01:16:55.940
全部用全新的

01:16:55.940 --> 01:16:58.940
因为它认为这个结构一定是发生了

01:16:58.940 --> 01:16:59.940
翻天覆地的变化

01:16:59.940 --> 01:17:00.940
所以说呢

01:17:00.940 --> 01:17:02.940
它让你直接系列旧的节点

01:17:02.940 --> 01:17:04.940
创建新的节点

01:17:04.940 --> 01:17:05.940
当然这里边有很多细节

01:17:05.940 --> 01:17:06.940
我们来来说

01:17:07.940 --> 01:17:09.940
我这里把这个f的介绍

01:17:09.940 --> 01:17:10.940
再复制一个

01:17:11.940 --> 01:17:14.940
这里边我就重新写一下

01:17:14.940 --> 01:17:15.940
这一块的代码

01:17:15.940 --> 01:17:16.940
怎么写呢

01:17:16.940 --> 01:17:17.940
我想想

01:17:18.940 --> 01:17:19.940
这样子吧

01:17:19.940 --> 01:17:21.940
做个最简单的效果

01:17:21.940 --> 01:17:22.940
就是说

01:17:22.940 --> 01:17:23.940
如果判断一下

01:17:23.940 --> 01:17:25.940
判断一下Zestat

01:17:25.940 --> 01:17:26.940
如果等于

01:17:26.940 --> 01:17:27.940
多少啊

01:17:27.940 --> 01:17:28.940
一二三

01:17:28.940 --> 01:17:30.940
如果一开始等于一二三的话

01:17:30.940 --> 01:17:31.940
我直接返回Laurel

01:17:31.940 --> 01:17:32.940
我啥都不返回

01:17:32.940 --> 01:17:34.940
那么这样子一来的话

01:17:34.940 --> 01:17:37.940
它那个一开始的元素结构

01:17:37.940 --> 01:17:39.940
一开始的节点结构

01:17:39.940 --> 01:17:40.940
你看一下

01:17:40.940 --> 01:17:43.570
是不是变成这个样子的

01:17:43.570 --> 01:17:44.570
再复制一下

01:17:45.570 --> 01:17:46.570
我靠

01:17:46.570 --> 01:17:47.570
这么多

01:17:47.570 --> 01:17:49.570
一开始的节点结构

01:17:49.570 --> 01:17:50.570
就是那个combo air

01:17:50.570 --> 01:17:51.570
这个实力里边

01:17:51.570 --> 01:17:52.570
你看一开始

01:17:52.570 --> 01:17:53.570
是不是

01:17:53.570 --> 01:17:56.260
想一想

01:17:56.260 --> 01:17:57.260
想一想

01:17:57.260 --> 01:17:58.260
一开始

01:17:58.260 --> 01:18:00.260
我就直接返回一个按钮吧

01:18:00.260 --> 01:18:01.260
行吗

01:18:01.260 --> 01:18:03.260
我直接就返回一个按钮得了

01:18:05.260 --> 01:18:06.260
就这样子

01:18:06.260 --> 01:18:08.260
一开始的只有一个按钮

01:18:08.260 --> 01:18:09.260
点击过后

01:18:09.260 --> 01:18:10.260
出现这些东西

01:18:11.260 --> 01:18:12.260
咱们来看一下

01:18:12.260 --> 01:18:13.260
首先

01:18:13.260 --> 01:18:14.260
我在这里

01:18:14.260 --> 01:18:16.260
画一下一开始的结构

01:18:16.260 --> 01:18:17.260
一开始

01:18:17.260 --> 01:18:18.260
就是这样子的

01:18:19.260 --> 01:18:21.260
就combo air的实力

01:18:21.260 --> 01:18:22.260
combo air的实力下面

01:18:22.260 --> 01:18:23.260
就直接是个按钮了

01:18:23.260 --> 01:18:24.260
对吧

01:18:24.260 --> 01:18:25.260
因为它做了判断

01:18:25.260 --> 01:18:26.260
Render方法

01:18:26.260 --> 01:18:27.260
它返回的就是一个按钮

01:18:27.260 --> 01:18:28.260
对不对

01:18:28.260 --> 01:18:30.260
于是一开始

01:18:33.960 --> 01:18:35.960
就这个玩意

01:18:36.960 --> 01:18:38.960
这是一开始的样子

01:18:38.960 --> 01:18:42.490
把画一下

01:18:46.340 --> 01:18:47.340
放过来

01:18:47.340 --> 01:18:49.340
一开始是这个样子

01:18:49.340 --> 01:18:51.340
然后现在combo air有个按钮

01:18:51.340 --> 01:18:52.340
现在我们点击这个按钮

01:18:52.340 --> 01:18:53.340
是不是更新了

01:18:53.340 --> 01:18:54.340
对不对

01:18:54.340 --> 01:18:55.340
点击我们更新

01:18:56.340 --> 01:18:57.340
更新的话

01:18:57.340 --> 01:18:58.340
这个时候

01:18:58.340 --> 01:18:59.340
它干嘛呢

01:18:59.340 --> 01:19:00.340
它会这样子做

01:19:00.340 --> 01:19:02.340
卸载旧的节点

01:19:02.340 --> 01:19:03.340
为什么要卸载旧的节点呢

01:19:03.340 --> 01:19:04.340
因为你看一下

01:19:04.340 --> 01:19:06.340
咱们点更新了过后

01:19:06.340 --> 01:19:08.340
它甚至的元素结构了又变了

01:19:09.340 --> 01:19:10.340
现在我们就可以画在一起了

01:19:10.340 --> 01:19:12.340
现在就可以画在一起了

01:19:12.340 --> 01:19:14.340
现在对于这个节点而已

01:19:14.340 --> 01:19:15.340
就看这个

01:19:15.340 --> 01:19:17.340
就combo air下边的节点

01:19:17.340 --> 01:19:19.340
之前是这个button

01:19:19.340 --> 01:19:21.340
那么现在是什么呢

01:19:21.340 --> 01:19:23.340
现在它这里返回的是一个div

01:19:25.340 --> 01:19:27.340
那么如果更新了状态过后

01:19:27.340 --> 01:19:29.340
你看现在返回的是不是这个div

01:19:29.340 --> 01:19:30.340
对不对

01:19:30.340 --> 01:19:31.340
现在我们看一下

01:19:31.340 --> 01:19:33.340
这里返回的就是这么个东西了

01:19:35.340 --> 01:19:37.340
就这么个东西了

01:19:37.340 --> 01:19:39.340
所以说它会把这个东西

01:19:39.340 --> 01:19:41.340
跟这个红色的来进行对比

01:19:41.340 --> 01:19:43.340
是不是节点内情不一样

01:19:43.340 --> 01:19:44.340
虽然都是动物节点

01:19:44.340 --> 01:19:45.340
但是它们的内情不一样

01:19:45.340 --> 01:19:47.340
它就卸载旧节点

01:19:47.340 --> 01:19:49.340
夹载新节点

01:19:49.340 --> 01:19:51.340
那么怎么来卸载旧节点呢

01:19:51.340 --> 01:19:52.340
我们来看一下

01:19:52.340 --> 01:19:54.340
如果旧节点还有几种情况

01:19:54.340 --> 01:19:56.340
就是卸载

01:19:57.340 --> 01:19:59.340
卸载旧节点

01:19:59.340 --> 01:20:01.340
卸载旧节点的时候有这么几种情况

01:20:01.340 --> 01:20:02.340
第一种情况是

01:20:02.340 --> 01:20:04.340
如果是文本节点

01:20:04.340 --> 01:20:05.340
如果这个旧节点

01:20:05.340 --> 01:20:07.340
就是一个文本节点的话

01:20:08.340 --> 01:20:10.340
当然这里不是文本节点

01:20:12.340 --> 01:20:14.340
如果是文本节点的话

01:20:14.340 --> 01:20:16.340
如果是文本节点的话

01:20:16.340 --> 01:20:17.340
那么直接

01:20:18.340 --> 01:20:20.340
一起说

01:20:20.340 --> 01:20:22.340
如果是文本节点

01:20:22.340 --> 01:20:24.340
如果是dorm节点

01:20:24.340 --> 01:20:26.340
还有一种是什么节点呢

01:20:27.340 --> 01:20:29.340
还有一种是宿主节点

01:20:32.340 --> 01:20:34.340
如果是这么一些节点的话

01:20:34.340 --> 01:20:36.340
文本节点dorm节点

01:20:36.340 --> 01:20:38.340
和宿主节点

01:20:39.340 --> 01:20:41.340
如果是这么一些节点

01:20:41.340 --> 01:20:43.340
还有就是个空节点

01:20:43.340 --> 01:20:45.340
还有什么

01:20:45.340 --> 01:20:47.340
就没啥了

01:20:47.340 --> 01:20:49.340
我想想

01:20:49.340 --> 01:20:51.340
还有啥呢

01:20:51.340 --> 01:20:53.340
还有函数組件节点

01:20:53.340 --> 01:20:55.340
如果是这些节点的话

01:20:55.340 --> 01:20:57.340
那么就做一件非常非常简单的事情

01:20:57.340 --> 01:20:59.340
就是直接扔掉

01:20:59.340 --> 01:21:01.340
直接放弃

01:21:01.340 --> 01:21:03.340
直接放弃该节点

01:21:03.340 --> 01:21:05.340
直接放弃完事了

01:21:05.340 --> 01:21:07.340
就是将来生成新的动物树

01:21:07.340 --> 01:21:09.340
因为最终更新完成

01:21:09.340 --> 01:21:11.340
它的动物树会更新

01:21:11.340 --> 01:21:13.340
它的结构会更新

01:21:13.340 --> 01:21:15.340
那么之前这些节点就直接不要了

01:21:15.340 --> 01:21:17.340
就这么简单

01:21:17.340 --> 01:21:19.340
以及这个节点下面的所有东西全部不要了

01:21:19.340 --> 01:21:21.340
哪怕这个节点下面

01:21:21.340 --> 01:21:23.340
还有一千个指援树

01:21:23.340 --> 01:21:25.340
还有弯曲发动的深度

01:21:25.340 --> 01:21:27.340
全部不要了

01:21:27.340 --> 01:21:29.340
然后呢

01:21:29.340 --> 01:21:31.340
第二步

01:21:31.340 --> 01:21:33.340
创建新节点

01:21:35.340 --> 01:21:37.340
那么创建新节点的时候

01:21:37.340 --> 01:21:39.340
是不是进入新节点的

01:21:39.340 --> 01:21:41.340
挂载流程

01:21:41.340 --> 01:21:43.340
那么进入哪个流程

01:21:43.340 --> 01:21:45.340
就是我们上一节课讲的

01:21:45.340 --> 01:21:47.340
这个

01:21:47.340 --> 01:21:49.340
手次渲染

01:21:49.340 --> 01:21:51.340
就是新节点渲染的流程

01:21:51.340 --> 01:21:53.340
是不是一样的了

01:21:53.340 --> 01:21:55.340
那么新节点

01:21:55.340 --> 01:21:57.340
那么创建

01:21:57.340 --> 01:21:59.340
同时创建DIV

01:21:59.340 --> 01:22:01.340
同时创建真实动物元素

01:22:01.340 --> 01:22:03.340
然后循环它的指元素

01:22:03.340 --> 01:22:05.340
跟之前是不是完全一样了

01:22:05.340 --> 01:22:07.340
跟之前的生命周期就完全一样了

01:22:07.340 --> 01:22:09.340
那么来过一下吧

01:22:09.340 --> 01:22:11.340
首先创建节点

01:22:11.340 --> 01:22:13.340
什么节点呢

01:22:13.340 --> 01:22:15.340
创建节点过后了

01:22:15.340 --> 01:22:17.340
根据不同的节点类型做不同的事情

01:22:17.340 --> 01:22:19.340
跟我们之前就完全一样了

01:22:19.340 --> 01:22:21.340
最后把它加入到容器里边

01:22:21.340 --> 01:22:23.340
这就是

01:22:23.340 --> 01:22:25.340
手次渲染

01:22:25.340 --> 01:22:27.340
手次渲染

01:22:27.340 --> 01:22:29.340
这就是新节点创建的过程

01:22:29.340 --> 01:22:31.340
当然这个节点一会儿

01:22:31.340 --> 01:22:33.340
它就会挂得到哪

01:22:33.340 --> 01:22:35.340
它就会挂得到这

01:22:35.340 --> 01:22:37.340
那么更新的动物结构数

01:22:37.340 --> 01:22:39.340
所以说我们这里

01:22:39.340 --> 01:22:41.340
好像没记这个东西

01:22:41.340 --> 01:22:43.340
后续步骤会就是

01:22:43.340 --> 01:22:45.340
最开始一件事

01:22:45.340 --> 01:22:47.340
更新动物结构数

01:22:49.340 --> 01:22:51.340
更新虚拟动物数

01:22:51.340 --> 01:22:53.340
之前的动物数就不要了

01:22:53.340 --> 01:22:55.340
现在就用新的虚拟动物数了

01:22:55.340 --> 01:22:57.340
把它合并到之前的动物数里边

01:22:57.340 --> 01:22:59.340
进行合并

01:22:59.340 --> 01:23:01.340
更新虚拟动物数

01:23:01.340 --> 01:23:03.340
后面就不化了

01:23:03.340 --> 01:23:05.340
这就是卸载旧节点

01:23:05.340 --> 01:23:07.340
非常非常简单

01:23:07.340 --> 01:23:09.340
那如果是这种情况

01:23:09.340 --> 01:23:11.340
比方说是这种情况

01:23:11.340 --> 01:23:13.340
就是说如果你卸载的旧节点

01:23:13.340 --> 01:23:15.340
里边

01:23:15.340 --> 01:23:17.340
它可能会有

01:23:17.340 --> 01:23:19.340
就是

01:23:19.340 --> 01:23:21.340
这种情况

01:23:21.340 --> 01:23:23.340
在这

01:23:23.340 --> 01:23:25.340
如果除了button之外

01:23:25.340 --> 01:23:27.340
除了button之外

01:23:27.340 --> 01:23:29.340
它的旧节点里边还有一个组件

01:23:29.340 --> 01:23:31.340
比方说

01:23:31.340 --> 01:23:33.340
还有一个combo c组件

01:23:33.340 --> 01:23:35.340
combo c也是那组件

01:23:35.340 --> 01:23:37.340
还有这么一个combo c组件

01:23:37.340 --> 01:23:39.340
那如果遇到了这种情况

01:23:39.340 --> 01:23:41.340
不要再给它一个n

01:23:41.340 --> 01:23:43.340
this state

01:23:43.340 --> 01:23:45.340
什么b

01:23:45.340 --> 01:23:47.340
不要说

01:23:47.340 --> 01:23:49.340
它里边还有一个combo c这个组件

01:23:49.340 --> 01:23:51.340
那么以后在对比的时候

01:23:51.340 --> 01:23:53.340
它就变成这样子

01:23:53.340 --> 01:23:55.340
它一开始是一个动物节点button

01:23:55.340 --> 01:23:57.340
对吧

01:23:57.340 --> 01:23:59.340
那么这个东西以后肯定要卸载

01:23:59.340 --> 01:24:01.340
因为结构不一样了

01:24:01.340 --> 01:24:03.340
一个动物节点button

01:24:03.340 --> 01:24:05.340
然后还有一个内组件

01:24:05.340 --> 01:24:07.340
它还有一个内组件

01:24:11.340 --> 01:24:13.340
然后还有一个内组件

01:24:13.340 --> 01:24:15.340
就是组件节点

01:24:15.340 --> 01:24:17.340
组件节点什么呢

01:24:17.340 --> 01:24:19.340
组件节点class

01:24:19.340 --> 01:24:21.340
class comp c

01:24:21.340 --> 01:24:23.340
那么到时候肯定会创建combo c的实力

01:24:23.340 --> 01:24:25.340
combo c的实力

01:24:25.340 --> 01:24:27.340
那么这是一个组

01:24:27.340 --> 01:24:29.340
它里边有什么东西

01:24:29.340 --> 01:24:31.340
我就不画了

01:24:31.340 --> 01:24:33.340
然后

01:24:33.340 --> 01:24:35.340
现在更新的combo

01:24:35.340 --> 01:24:37.340
是不是要重新渲染

01:24:37.340 --> 01:24:39.340
当然它这里边应该是顶层还有一个div

01:24:39.340 --> 01:24:43.100
顶层还有div

01:24:43.100 --> 01:24:46.410
顶层还有div节点

01:24:46.410 --> 01:24:48.410
动物节点div

01:24:48.410 --> 01:24:50.410
这是个真实动物

01:24:50.410 --> 01:24:52.410
那么这里连过来

01:24:52.410 --> 01:24:54.410
它是这么一种结构

01:24:54.410 --> 01:24:56.410
之前的结构

01:24:56.410 --> 01:24:58.410
这个div存在

01:24:58.410 --> 01:25:00.410
这个div是不是还存

01:25:00.410 --> 01:25:02.410
这里没有div 它是个空节点

01:25:02.410 --> 01:25:04.410
不是空节点 它是一个组件节点

01:25:04.410 --> 01:25:06.410
这个是个组件节点

01:25:06.410 --> 01:25:08.410
这个组件节点是一个fragment

01:25:08.410 --> 01:25:10.410
我们之前说过

01:25:10.410 --> 01:25:12.410
片段

01:25:12.410 --> 01:25:14.410
是一个韩式组件

01:25:14.410 --> 01:25:16.410
fragment

01:25:16.410 --> 01:25:18.410
它是这么一个节点

01:25:18.410 --> 01:25:20.410
组件节点

01:25:20.410 --> 01:25:22.410
内置的组件fragment

01:25:22.410 --> 01:25:24.410
就是你这样直接写空的话

01:25:24.410 --> 01:25:26.410
这样的节点

01:25:26.410 --> 01:25:28.410
那么现在

01:25:28.410 --> 01:25:30.410
一会我们这里产生了一个新的节点

01:25:30.410 --> 01:25:32.410
产生了一个新的节点

01:25:32.410 --> 01:25:34.410
那么产生新的节点的时候

01:25:34.410 --> 01:25:36.410
它是这样子

01:25:36.410 --> 01:25:38.410
我们一会它会产生一个div节点

01:25:38.410 --> 01:25:40.410
对吧

01:25:40.410 --> 01:25:42.410
这里产生一个div节点

01:25:42.410 --> 01:25:44.410
现在红色

01:25:44.410 --> 01:25:46.410
变成一个动物节点

01:25:46.410 --> 01:25:48.410
这是个div

01:25:48.410 --> 01:25:50.410
当然它就是进入全新的创建流程了

01:25:50.410 --> 01:25:52.410
就是创建一个新的div

01:25:52.410 --> 01:25:54.410
创建一个全新的创建流程

01:25:54.410 --> 01:25:56.410
那么一堆比

01:25:56.410 --> 01:25:58.410
发现这两个节点不一样

01:25:58.410 --> 01:26:00.410
这个时候

01:26:00.410 --> 01:26:02.410
它干嘛呢 卸载旧节点

01:26:02.410 --> 01:26:04.410
如果旧节点是一个

01:26:04.410 --> 01:26:06.410
就是那个

01:26:06.410 --> 01:26:08.410
多么节点或者是空节点的话

01:26:08.410 --> 01:26:10.410
直接卸载就完事了

01:26:10.410 --> 01:26:12.410
我之前说过 直接卸载就完事了

01:26:12.410 --> 01:26:14.410
放弃一点

01:26:14.410 --> 01:26:16.410
那么还有一个就是

01:26:16.410 --> 01:26:18.410
如果节点有

01:26:18.410 --> 01:26:20.410
指元素

01:26:20.410 --> 01:26:22.410
如果有指节点

01:26:22.410 --> 01:26:24.410
之前的节点素里面有指节点

01:26:24.410 --> 01:26:26.410
那么地规卸载

01:26:26.410 --> 01:26:28.410
地规卸载节点

01:26:28.410 --> 01:26:30.410
那么当前那个节点直接放弃

01:26:30.410 --> 01:26:32.410
然后这个节点

01:26:32.410 --> 01:26:34.410
它就不要了 直接放弃

01:26:34.410 --> 01:26:36.410
那么地规卸载它的指节点

01:26:36.410 --> 01:26:38.410
地规卸载的指节点

01:26:38.410 --> 01:26:40.410
因为这个是个函数节点 它直接放弃完事了

01:26:40.410 --> 01:26:42.410
那么由地规卸载它的指节点

01:26:42.410 --> 01:26:44.410
那么现在到这儿

01:26:44.410 --> 01:26:46.410
它就不再是一个这些节点了

01:26:46.410 --> 01:26:48.410
它不是文本 不是数组

01:26:48.410 --> 01:26:50.410
是函数节点

01:26:50.410 --> 01:26:52.410
那么这个时候

01:26:52.410 --> 01:26:54.410
它做这么一件事

01:26:54.410 --> 01:26:56.410
做什么事呢

01:26:56.410 --> 01:26:58.410
就是说

01:26:58.410 --> 01:27:00.410
如果它的节点是一个

01:27:00.410 --> 01:27:02.410
内组件节点

01:27:02.410 --> 01:27:04.410
第一步跟前面的节点是一样的

01:27:04.410 --> 01:27:06.410
它直接放弃这个节点

01:27:06.410 --> 01:27:08.410
如果节点有指节点的话

01:27:08.410 --> 01:27:10.410
地规卸载节点

01:27:10.410 --> 01:27:12.410
然后

01:27:12.410 --> 01:27:14.410
直接放弃该节点

01:27:14.410 --> 01:27:16.410
然后雕用

01:27:16.410 --> 01:27:18.410
component

01:27:18.410 --> 01:27:20.410
它就不是对列了

01:27:20.410 --> 01:27:22.410
我之前好像是不是把它说成对列了

01:27:22.410 --> 01:27:24.410
不值钱

01:27:24.410 --> 01:27:26.410
它不是对列

01:27:26.410 --> 01:27:28.410
OK 那么它这里是

01:27:28.410 --> 01:27:30.410
直接雕用该节点的component

01:27:30.410 --> 01:27:32.410
will amount

01:27:32.410 --> 01:27:34.410
直接雕用完事了 函数

01:27:34.410 --> 01:27:36.410
直接雕用这个节点

01:27:36.410 --> 01:27:38.410
这个函数表示我这个节点已经卸载掉了

01:27:38.410 --> 01:27:40.410
然后第三步

01:27:40.410 --> 01:27:42.410
地规卸载

01:27:42.410 --> 01:27:44.410
指节点

01:27:44.410 --> 01:27:46.410
我这个地方还写的有问题

01:27:46.410 --> 01:27:48.410
这个创建新节点是在前边

01:27:48.410 --> 01:27:50.410
卸载就节点是在后边

01:27:50.410 --> 01:27:52.410
它一堆比方也不一样

01:27:52.410 --> 01:27:54.410
那么它会先完成

01:27:54.410 --> 01:27:56.410
新节点的挂载流程

01:27:56.410 --> 01:27:58.410
然后再完成

01:27:58.410 --> 01:28:00.410
就节点的卸载流程

01:28:00.410 --> 01:28:02.410
它是这么一个流程

01:28:02.410 --> 01:28:04.410
先完成挂载新节点

01:28:04.410 --> 01:28:06.410
然后再完成卸载就节点

01:28:06.410 --> 01:28:08.410
卸载完了之后

01:28:08.410 --> 01:28:10.410
再做后面的事情

01:28:10.410 --> 01:28:12.410
后续不凑 更新动物数

01:28:12.410 --> 01:28:14.410
更新动物数 然后再一次做这些事情

01:28:16.410 --> 01:28:18.410
这里就特别绕了

01:28:18.410 --> 01:28:20.410
因为有了懈怠过后生命周期就特别绕了

01:28:20.410 --> 01:28:22.410
那么我这里要把讲清楚

01:28:22.410 --> 01:28:24.410
比方说我这里换一种结构

01:28:24.410 --> 01:28:26.410
为了让你们看得清楚

01:28:26.410 --> 01:28:28.410
换一种结构

01:28:28.410 --> 01:28:30.410
还是用comp A

01:28:30.410 --> 01:28:32.410
class

01:28:32.410 --> 01:28:34.410
我现在都用内组件

01:28:34.410 --> 01:28:36.410
extent

01:28:36.410 --> 01:28:38.410
component

01:28:38.410 --> 01:28:40.410
都有生命周期的

01:28:40.410 --> 01:28:42.410
这里App里边

01:28:42.410 --> 01:28:44.410
我们这样子来做

01:28:44.410 --> 01:28:46.410
App里边

01:28:46.410 --> 01:28:48.410
判断一下

01:28:48.410 --> 01:28:50.410
加个状态

01:28:50.410 --> 01:28:52.410
在我们的App里边操作

01:28:52.410 --> 01:28:54.410
然后n等于0

01:28:54.410 --> 01:28:56.410
n等于0

01:28:56.410 --> 01:28:58.410
ok

01:28:58.410 --> 01:29:00.410
如果state this state

01:29:00.410 --> 01:29:02.410
n等于0的时候

01:29:02.410 --> 01:29:04.410
我返回这么一个东西

01:29:06.410 --> 01:29:08.410
返回啥呢

01:29:08.410 --> 01:29:10.410
这个是一个comp B

01:29:10.410 --> 01:29:12.410
返回这么一个结构

01:29:12.410 --> 01:29:14.410
comp B

01:29:14.410 --> 01:29:16.410
else 其他情况

01:29:16.410 --> 01:29:18.410
我就返回comp A

01:29:18.410 --> 01:29:23.510
这种情况

01:29:23.510 --> 01:29:25.510
要么返回comp A

01:29:25.510 --> 01:29:27.510
要么返回comp B

01:29:27.510 --> 01:29:29.510
关键是看n等于0

01:29:29.510 --> 01:29:31.510
如果这里还要加一个

01:29:31.510 --> 01:29:35.980
必须得写一个div

01:29:35.980 --> 01:29:37.980
那么这里有个按钮

01:29:37.980 --> 01:29:39.980
因为我改变状态

01:29:39.980 --> 01:29:41.980
有一个按钮

01:29:41.980 --> 01:29:43.980
当点击这个按钮的时候

01:29:43.980 --> 01:29:45.980
点击

01:29:45.980 --> 01:29:47.980
这个按钮的时候

01:29:47.980 --> 01:29:49.980
然后onclick

01:29:49.980 --> 01:29:56.490
onclick

01:29:56.490 --> 01:29:58.490
onclick的时候

01:29:58.490 --> 01:30:00.490
我们把状态设为1

01:30:00.490 --> 01:30:02.490
this state

01:30:02.490 --> 01:30:04.490
set state

01:30:04.490 --> 01:30:06.490
把状态设为1

01:30:08.490 --> 01:30:10.490
点按钮过后把状态设为1

01:30:10.490 --> 01:30:12.490
那么一会儿就选择comp A这个节点了

01:30:12.490 --> 01:30:14.490
接下来我们写两个组件

01:30:14.490 --> 01:30:16.490
一个comp A

01:30:16.490 --> 01:30:18.490
我们再加上一个生命周期的函数

01:30:18.490 --> 01:30:20.490
component ddemount

01:30:22.490 --> 01:30:24.490
这是comp A的

01:30:26.490 --> 01:30:28.490
这个函数

01:30:28.490 --> 01:30:30.490
然后再写个组件

01:30:30.490 --> 01:30:32.490
comp B

01:30:32.490 --> 01:30:34.490
stance

01:30:36.490 --> 01:30:38.490
component

01:30:38.490 --> 01:30:40.490
它这里面

01:30:40.490 --> 01:30:42.490
写上

01:30:42.490 --> 01:30:44.490
component ddemount

01:30:44.490 --> 01:30:46.490
然后还有生命周期函数

01:30:46.490 --> 01:30:48.490
component c

01:30:48.490 --> 01:30:50.490
component wmount

01:30:50.490 --> 01:30:52.490
就卸载组件

01:30:54.490 --> 01:30:56.490
新组件挂载

01:30:56.490 --> 01:30:58.490
我们用中文吧

01:30:58.490 --> 01:31:00.490
comp A卸载

01:31:00.490 --> 01:31:02.490
我们看一下它的指形顺序

01:31:02.490 --> 01:31:04.490
comp B是新组件挂载

01:31:04.490 --> 01:31:06.490
挂载

01:31:06.490 --> 01:31:08.490
然后comp B卸载

01:31:08.490 --> 01:31:12.380
comp B卸载

01:31:12.380 --> 01:31:14.380
就能让你们看得更加清楚一点

01:31:14.380 --> 01:31:16.380
我再加上一个

01:31:16.380 --> 01:31:18.380
comp A

01:31:18.380 --> 01:31:20.380
再加一个

01:31:20.380 --> 01:31:22.380
component

01:31:24.380 --> 01:31:26.380
comp A

01:31:26.380 --> 01:31:28.380
comp A的指数件

01:31:28.380 --> 01:31:30.380
它这里反而回的就是

01:31:30.380 --> 01:31:32.380
反而回的就是comp A

01:31:32.380 --> 01:31:34.380
这个指数件

01:31:34.380 --> 01:31:36.380
它也有两个函数

01:31:36.380 --> 01:31:38.380
都加上

01:31:38.380 --> 01:31:40.380
comp A

01:31:40.380 --> 01:31:43.880
comp B

01:31:43.880 --> 01:31:45.880
comp B

01:31:45.880 --> 01:31:50.280
comp B

01:31:50.280 --> 01:31:52.280
comp B

01:31:52.280 --> 01:31:54.280
comp B

01:31:54.280 --> 01:31:56.280
它Render

01:31:56.280 --> 01:31:58.280
它就没有任何东西输出

01:31:58.280 --> 01:32:00.280
你必须要写一个函数不然

01:32:00.280 --> 01:32:02.280
它爆错的

01:32:02.280 --> 01:32:04.280
反而空气点就完事了

01:32:04.280 --> 01:32:06.280
comp A也是

01:32:06.280 --> 01:32:08.280
好,咱们来看一下

01:32:08.280 --> 01:32:12.490
comp A里边有comp

01:32:12.490 --> 01:32:14.490
画个图

01:32:14.490 --> 01:32:16.490
根节点

01:32:16.490 --> 01:32:18.490
根节点是一个组件节点

01:32:18.490 --> 01:32:20.490
up

01:32:20.490 --> 01:32:22.490
为了让你们看得清楚

01:32:22.490 --> 01:32:24.490
我就不用去画一乱七八糟的东西了

01:32:24.490 --> 01:32:26.490
我直接就画这个

01:32:26.490 --> 01:32:28.490
up下面我也不连线了

01:32:28.490 --> 01:32:30.490
这样你们看得清楚结构就行了

01:32:30.490 --> 01:32:32.490
up下面有个什么

01:32:32.490 --> 01:32:34.490
up下面

01:32:34.490 --> 01:32:36.490
up下面有DIV

01:32:36.490 --> 01:32:38.490
默认情况下

01:32:38.490 --> 01:32:40.490
comp N等于

01:32:40.490 --> 01:32:42.490
comp N等于0

01:32:42.490 --> 01:32:44.490
接过后就行了

01:32:44.490 --> 01:32:46.490
就这样子

01:32:46.490 --> 01:32:48.490
下面有个DIV组件

01:32:48.490 --> 01:32:50.490
默认情况下

01:32:50.490 --> 01:32:52.490
下面有个DIV组件

01:32:52.490 --> 01:32:54.490
下面有一个

01:32:54.490 --> 01:32:56.490
有两个组件

01:32:56.490 --> 01:32:58.490
一个是comp B

01:32:58.490 --> 01:33:00.490
comp B

01:33:00.490 --> 01:33:02.490
comp B

01:33:02.490 --> 01:33:04.490
然后

01:33:04.490 --> 01:33:06.490
还有个什么,还有一个button

01:33:06.490 --> 01:33:08.490
这是个dome组件

01:33:08.490 --> 01:33:10.490
然后button下面有个文字节点

01:33:10.490 --> 01:33:12.490
就不写了

01:33:12.490 --> 01:33:14.490
comp B

01:33:14.490 --> 01:33:16.490
comp B有什么

01:33:16.490 --> 01:33:18.490
comp B

01:33:18.490 --> 01:33:20.490
comp B

01:33:20.490 --> 01:33:22.490
一开始是这么一种组件

01:33:22.490 --> 01:33:24.490
现在我们点击

01:33:24.490 --> 01:33:26.490
comp B先挂载

01:33:26.490 --> 01:33:28.490
comp B再挂载

01:33:28.490 --> 01:33:30.490
这是我们之前讲的第一首次渲染

01:33:30.490 --> 01:33:32.490
它会加入到队列

01:33:32.490 --> 01:33:34.490
component D的mount

01:33:34.490 --> 01:33:36.490
component D的mount

01:33:36.490 --> 01:33:38.490
加入到队列

01:33:38.490 --> 01:33:40.490
它先加入

01:33:40.490 --> 01:33:42.490
所以一会儿执行的时候

01:33:42.490 --> 01:33:44.490
再执行它

01:33:44.490 --> 01:33:46.490
现在我们

01:33:46.490 --> 01:33:48.490
点一下这个按钮,看会发生什么事情

01:33:48.490 --> 01:33:51.990
需要点击

01:33:51.990 --> 01:33:53.990
新组件

01:33:53.990 --> 01:33:55.990
哦哦哦

01:33:55.990 --> 01:33:57.990
这里

01:33:57.990 --> 01:33:59.990
这个东西

01:33:59.990 --> 01:34:01.990
还是先是对的

01:34:01.990 --> 01:34:03.990
我之前没说错

01:34:03.990 --> 01:34:05.990
先懈怠的是旧节点

01:34:05.990 --> 01:34:07.990
再创建新节点

01:34:07.990 --> 01:34:09.990
好

01:34:09.990 --> 01:34:11.990
不对

01:34:11.990 --> 01:34:13.990
不对

01:34:13.990 --> 01:34:15.990
对了

01:34:15.990 --> 01:34:17.990
不要帮我搞晕了

01:34:17.990 --> 01:34:19.990
是新枪创建节点

01:34:19.990 --> 01:34:21.990
进入新节点的挂载流程

01:34:21.990 --> 01:34:23.990
对了,没问题的

01:34:23.990 --> 01:34:25.990
是新创建节点

01:34:25.990 --> 01:34:27.990
然后再细载就有点点

01:34:27.990 --> 01:34:29.990
为了让你们看得更加清楚

01:34:29.990 --> 01:34:31.990
我把render也打印出来吧

01:34:31.990 --> 01:34:33.990
不然的话这里

01:34:33.990 --> 01:34:35.990
如果遇到面试的话,这里非常容易晕

01:34:35.990 --> 01:34:37.990
然后这里

01:34:37.990 --> 01:34:39.990
compAA render

01:34:39.990 --> 01:34:41.990
compAA render

01:34:41.990 --> 01:34:45.880
compB

01:34:45.880 --> 01:34:47.880
compBb render

01:34:47.880 --> 01:34:51.380
把render打印出来

01:34:51.380 --> 01:34:53.380
我们看一下生命周期还要说

01:34:53.380 --> 01:34:55.380
一开始没问题

01:34:55.380 --> 01:34:57.380
compB

01:34:57.380 --> 01:34:59.380
先运行render

01:34:59.380 --> 01:35:01.380
它在宣传的过程中

01:35:01.380 --> 01:35:03.380
它返回了一个compBb

01:35:03.380 --> 01:35:05.380
所以说compBb还要运行render

01:35:05.380 --> 01:35:07.380
然后

01:35:07.380 --> 01:35:09.380
再把自己的compBb render

01:35:09.380 --> 01:35:11.380
加入到对列

01:35:11.380 --> 01:35:13.380
然后再把它的compBb render

01:35:13.380 --> 01:35:15.380
加入到对列

01:35:15.380 --> 01:35:17.380
所以说compBb render

01:35:17.380 --> 01:35:19.380
生命周期还要说是先运行

01:35:19.380 --> 01:35:21.380
之前我们讲的过程

01:35:21.380 --> 01:35:23.380
之前是没什么问题的

01:35:23.380 --> 01:35:25.380
那么现在我们点击

01:35:25.380 --> 01:35:27.380
点击,咱们来看一下,它的运行过程

01:35:27.380 --> 01:35:29.380
那么它怎么运行的

01:35:29.380 --> 01:35:31.380
为什么会出现这种情况呢

01:35:31.380 --> 01:35:33.380
首先我们来研究一下

01:35:33.380 --> 01:35:35.380
点击过程是不是改变了App的状态

01:35:35.380 --> 01:35:37.380
然后重新运行App的生命周期

01:35:37.380 --> 01:35:39.380
所以弄下来把它运行

01:35:39.380 --> 01:35:41.380
然后呢返回了一个compA

01:35:41.380 --> 01:35:43.380
看这

01:35:43.380 --> 01:35:45.380
它返回的就不再是个DIV了

01:35:45.380 --> 01:35:47.380
它返回的是一个compA

01:35:47.380 --> 01:35:49.380
那么

01:35:49.380 --> 01:35:51.380
都是App的止节点

01:35:51.380 --> 01:35:53.380
只不过是新

01:35:53.380 --> 01:35:55.380
这一部分是旧的

01:35:55.380 --> 01:35:57.380
这一部分是新的

01:35:57.380 --> 01:35:59.380
compA运行的时候

01:35:59.380 --> 01:36:01.380
那么它发现

01:36:01.380 --> 01:36:03.380
一堆比发现,是不同类型的节点

01:36:03.380 --> 01:36:05.380
对吧

01:36:05.380 --> 01:36:07.380
跟同一个位置进行对比

01:36:07.380 --> 01:36:09.380
发现是不同类型的节点

01:36:09.380 --> 01:36:11.380
干嘛呢,它就会进入卸载

01:36:11.380 --> 01:36:13.380
创建流程

01:36:13.380 --> 01:36:15.380
先做什么呢,先创建

01:36:15.380 --> 01:36:17.380
先创建compA

01:36:17.380 --> 01:36:19.380
那么创建就是以前的挂载流程了

01:36:19.380 --> 01:36:21.380
创建compA

01:36:21.380 --> 01:36:23.380
然后呢,创建它的实力对象

01:36:23.380 --> 01:36:25.380
对吧,这是以前的流程了

01:36:25.380 --> 01:36:27.380
创建它的实力对象

01:36:27.380 --> 01:36:29.380
然后运行这个对象的生命周期函数

01:36:29.380 --> 01:36:31.380
然后运行它,就这个生命周期函数

01:36:31.380 --> 01:36:33.380
就是挂载阶段的

01:36:33.380 --> 01:36:35.380
就这个函数

01:36:35.380 --> 01:36:37.380
运行这个函数,运行完了之后

01:36:37.380 --> 01:36:39.380
然后再运行它的Render方法

01:36:39.380 --> 01:36:41.380
所以说你首先看到的是compA Render

01:36:41.380 --> 01:36:43.380
运行它的Render方法

01:36:43.380 --> 01:36:45.380
而Render方法一运行

01:36:45.380 --> 01:36:47.380
是不是得到一个植住键

01:36:47.380 --> 01:36:49.380
compB,对不对

01:36:49.380 --> 01:36:51.380
得到这个植住键

01:36:51.380 --> 01:36:53.380
compA

01:36:53.380 --> 01:36:55.380
那不是又创建它的对象

01:36:55.380 --> 01:36:57.380
又运行它的生命周期函数

01:36:57.380 --> 01:36:59.380
这个生命周期函数

01:36:59.380 --> 01:37:01.380
然后再运行它的Render

01:37:01.380 --> 01:37:03.380
所以说你接下来看到的是compA Render

01:37:03.380 --> 01:37:05.380
看到没

01:37:05.380 --> 01:37:07.380
跟以前的挂载流程是一样的了

01:37:07.380 --> 01:37:09.380
那么这个是不是运行完了

01:37:09.380 --> 01:37:11.380
后面就没东西了,对吧

01:37:11.380 --> 01:37:13.380
没东西了,然后回到这边

01:37:13.380 --> 01:37:15.380
回到这边来卸载

01:37:15.380 --> 01:37:17.380
卸载组建

01:37:17.380 --> 01:37:19.380
卸载组建的时候

01:37:19.380 --> 01:37:21.380
当然,这里还要加入

01:37:21.380 --> 01:37:23.380
加入了对列,componentD的mount

01:37:23.380 --> 01:37:25.380
加入了对列

01:37:25.380 --> 01:37:27.380
这里还要做,肯定是先进对列

01:37:27.380 --> 01:37:29.380
然后他再进对列

01:37:29.380 --> 01:37:31.380
跟以前的挂载流程是一样的

01:37:31.380 --> 01:37:33.380
好,那么这个加诺对列过

01:37:33.380 --> 01:37:35.380
现在不倒去执行,因为我们最后

01:37:35.380 --> 01:37:37.380
才去执行这些生命周期的方法

01:37:37.380 --> 01:37:39.380
那么这个时候才去运行这边的卸载

01:37:39.380 --> 01:37:41.380
那么卸载呢

01:37:41.380 --> 01:37:43.380
DIV是不是动物组建

01:37:43.380 --> 01:37:45.380
那么它就一会直接3就完事了

01:37:45.380 --> 01:37:47.380
好,那么这里

01:37:47.380 --> 01:37:49.380
当然不是现在3,到时候3

01:37:49.380 --> 01:37:51.380
真实动物对象是到时候在3

01:37:51.380 --> 01:37:53.380
最后统一处理

01:37:53.380 --> 01:37:55.380
那么这个节电对象

01:37:55.380 --> 01:37:57.380
可以删除了

01:37:57.380 --> 01:37:59.380
那么它又变成它的直接电一次删除

01:37:59.380 --> 01:38:01.380
那么这个东西是一个内组建

01:38:01.380 --> 01:38:03.380
内组建是不是要

01:38:03.380 --> 01:38:05.380
直接运行

01:38:05.380 --> 01:38:07.380
直接运行

01:38:07.380 --> 01:38:09.380
卸载组建的方法

01:38:09.380 --> 01:38:11.380
那么一运行的话,是不是看到了

01:38:11.380 --> 01:38:13.380
componentD卸载

01:38:13.380 --> 01:38:15.380
运行componentD的amount方法

01:38:15.380 --> 01:38:17.380
运用amount方法

01:38:17.380 --> 01:38:19.380
卸载完过又变成它的直组建

01:38:19.380 --> 01:38:21.380
是不是它,对不对

01:38:21.380 --> 01:38:23.380
那么它是不是也要卸载

01:38:23.380 --> 01:38:25.380
也要会调用它的伪用amount方法

01:38:25.380 --> 01:38:27.380
那么compbb卸载

01:38:27.380 --> 01:38:29.380
好,然后再继续

01:38:29.380 --> 01:38:31.380
它卸载完过就动物对象卸载

01:38:31.380 --> 01:38:33.380
它没了

01:38:33.380 --> 01:38:35.380
那么最后它会形成一个新的动物数

01:38:35.380 --> 01:38:37.380
就变成这个样子

01:38:37.380 --> 01:38:39.380
没问题吧

01:38:39.380 --> 01:38:41.380
这是新的动物数

01:38:41.380 --> 01:38:43.380
然后再一次运行

01:38:43.380 --> 01:38:45.380
之前的对列里边的生命周期方法

01:38:45.380 --> 01:38:47.380
componentD的amount

01:38:47.380 --> 01:38:49.380
再运行它的生命周期方法

01:38:49.380 --> 01:38:51.380
所以说这是一个

01:38:51.380 --> 01:38:53.380
这么一个完整的过程

01:38:53.380 --> 01:38:55.380
这一块大家可以反复倒退视频

01:38:55.380 --> 01:38:57.380
反复观看一下

01:38:57.380 --> 01:38:59.380
它怎么来卸载和更新的

01:38:59.380 --> 01:39:01.380
这就是组建内情不一样的时候

01:39:01.380 --> 01:39:03.380
直接,不管三七二十一

01:39:03.380 --> 01:39:05.380
那有些同学说,那这里比方说

01:39:05.380 --> 01:39:07.380
那举个例子,比方说这里

01:39:07.380 --> 01:39:09.380
是compb

01:39:09.380 --> 01:39:11.380
这里是compb,那么这里一看

01:39:11.380 --> 01:39:13.380
哎呀,可以啊,这个地方虽然不一样

01:39:13.380 --> 01:39:15.380
但这个地方是一样的,看到没

01:39:15.380 --> 01:39:17.380
管这个事情吗?不管

01:39:17.380 --> 01:39:19.380
它只要发现这个节点不一样

01:39:19.380 --> 01:39:21.380
啥都不管了,它已经疯了

01:39:21.380 --> 01:39:23.380
因为它做了个假设,只要节点内情不一样

01:39:23.380 --> 01:39:25.380
那么这个节点,它认为它有天翻地覆的差别

01:39:25.380 --> 01:39:27.380
它为了提高效率

01:39:27.380 --> 01:39:29.380
做一个就简单的事情就是,直接卸载

01:39:29.380 --> 01:39:31.380
它先直接创建,全部

01:39:31.380 --> 01:39:33.380
全部都是全新的

01:39:33.380 --> 01:39:35.380
全部都是全新的,直接创建

01:39:35.380 --> 01:39:37.380
那么这里呢,直接卸载

01:39:37.380 --> 01:39:39.380
所以从来面试停了,还有可能会这样的考虑

01:39:39.380 --> 01:39:41.380
比方说一开始,这种结构

01:39:41.380 --> 01:39:43.380
然后后面变成了compa和compb

01:39:43.380 --> 01:39:45.380
看着啊

01:39:45.380 --> 01:39:47.380
后面变成了compa,底边加上

01:39:47.380 --> 01:39:49.380
后面加上了一个compa和compb

01:39:49.380 --> 01:39:51.380
就这么能结构了

01:39:51.380 --> 01:39:53.380
compa里面包含compb,当然这个节点你没用了

01:39:53.380 --> 01:39:55.380
如果是

01:39:55.380 --> 01:39:57.380
把它删掉

01:39:57.380 --> 01:40:01.270
它会问你,问你什么呢

01:40:01.270 --> 01:40:03.270
它说

01:40:03.270 --> 01:40:05.270
它说,如果我现在点击这个按钮之后

01:40:05.270 --> 01:40:07.270
就类似的这种题,点击这个按钮之后

01:40:07.270 --> 01:40:09.270
那么这个compb

01:40:09.270 --> 01:40:11.270
会不会再调用

01:40:11.270 --> 01:40:13.270
它的构造函数

01:40:13.270 --> 01:40:15.270
compb的构造函数,或者说

01:40:15.270 --> 01:40:17.270
compb的deadmount,会不会调用

01:40:17.270 --> 01:40:19.270
那么它关键是判断啥呢

01:40:19.270 --> 01:40:21.270
判断compb,是不是之前的compb

01:40:21.270 --> 01:40:23.270
是不是之前的,它们的对象

01:40:23.270 --> 01:40:25.270
是不是要重用之前的那个

01:40:25.270 --> 01:40:27.270
主线对象

01:40:27.270 --> 01:40:29.270
就这种主线对象,是实力对象,要不要重用

01:40:29.270 --> 01:40:31.270
不重用,为什么呢

01:40:31.270 --> 01:40:33.270
因为它副节点不一样

01:40:33.270 --> 01:40:35.270
那么这个节点对比起来不一样的时候

01:40:35.270 --> 01:40:37.270
它就进入了全新的流程了

01:40:37.270 --> 01:40:39.270
那么它就放弃了之前的compb节点

01:40:39.270 --> 01:40:41.270
你知道这个意思吗

01:40:41.270 --> 01:40:43.270
放弃了这么一个节点了

01:40:43.270 --> 01:40:45.270
所以说呢,这样子一来

01:40:45.270 --> 01:40:47.270
我们来看一下

01:40:47.270 --> 01:40:49.270
这里呢,我们点击

01:40:49.270 --> 01:40:51.270
你会发现compb呢

01:40:51.270 --> 01:40:53.270
之前的compb

01:40:53.270 --> 01:40:55.270
是不是卸载了,对不对

01:40:55.270 --> 01:40:57.270
而且compb,是不是也挂载了

01:40:57.270 --> 01:40:59.270
说明了一个新的compb产生了

01:40:59.270 --> 01:41:01.270
就有了compb卸载了

01:41:01.270 --> 01:41:03.270
为什么,就是因为

01:41:03.270 --> 01:41:05.270
它之前的节点的内容不一致

01:41:05.270 --> 01:41:07.270
导致了这个节点下面的所有东西

01:41:07.270 --> 01:41:09.270
全部要重新加载

01:41:09.270 --> 01:41:11.270
所以说呢,这提醒了我们

01:41:11.270 --> 01:41:13.270
在平时开发react

01:41:13.270 --> 01:41:15.270
应用的时候呢

01:41:15.270 --> 01:41:17.270
小心一点

01:41:17.270 --> 01:41:19.270
如果你根据不同的情况

01:41:19.270 --> 01:41:21.270
得到了一个不同的节点

01:41:21.270 --> 01:41:23.270
内容都不一样了

01:41:23.270 --> 01:41:25.270
它会导致救数全部卸载

01:41:25.270 --> 01:41:27.270
你救数的那些状态啊

01:41:27.270 --> 01:41:29.270
那些堆一箱啊

01:41:29.270 --> 01:41:31.270
包括那些动物元素的状态

01:41:31.270 --> 01:41:33.270
全部丢失

01:41:33.270 --> 01:41:35.270
后边会创建一个全新的数

01:41:35.270 --> 01:41:37.270
最终会合并到之前的数里面

01:41:37.270 --> 01:41:39.270
这样子合并了

01:41:39.270 --> 01:41:41.270
这样子合并过来

01:41:41.270 --> 01:41:43.270
现在这么能结构

01:41:43.270 --> 01:41:45.270
那么后边创建的节点

01:41:45.270 --> 01:41:47.270
那些动物对象是全新的动物对象

01:41:47.270 --> 01:41:49.270
真实的动物对象也完全不一样了

01:41:49.270 --> 01:41:51.270
比方说吧

01:41:51.270 --> 01:41:53.270
我给大家多举几个例子

01:41:55.270 --> 01:41:57.270
比方说

01:41:57.270 --> 01:41:59.270
举这么一个例子

01:41:59.270 --> 01:42:01.270
看着啊

01:42:01.270 --> 01:42:03.270
我这个都不用去用什么内组件了

01:42:03.270 --> 01:42:05.270
不用去用什么内组件了

01:42:05.270 --> 01:42:07.270
n等于1的时候你看着

01:42:07.270 --> 01:42:09.270
我给它一个div

01:42:09.270 --> 01:42:11.270
div里面写上

01:42:11.270 --> 01:42:14.650
写上这个吧

01:42:14.650 --> 01:42:16.650
啥都不用写

01:42:16.650 --> 01:42:18.650
好然后呢这里

01:42:18.650 --> 01:42:20.650
如果n等于1的时候呢

01:42:20.650 --> 01:42:22.650
又返回一个div

01:42:22.650 --> 01:42:24.650
你们还是一个按钮

01:42:24.650 --> 01:42:26.650
一模一样的看到没

01:42:26.650 --> 01:42:28.650
这个动物结构一模一样的

01:42:28.650 --> 01:42:30.650
那么这种情况下

01:42:30.650 --> 01:42:32.650
问大家一个问题啊

01:42:32.650 --> 01:42:34.650
这个可能面子挺容易考

01:42:34.650 --> 01:42:36.650
问大家一个问题

01:42:36.650 --> 01:42:38.650
那么现在呢

01:42:38.650 --> 01:42:40.650
第一次看到div

01:42:40.650 --> 01:42:42.650
跟点击过后看到的div

01:42:42.650 --> 01:42:44.650
是不是一个div

01:42:44.650 --> 01:42:46.650
进而

01:42:46.650 --> 01:42:48.650
可能还会这样问你

01:42:48.650 --> 01:42:50.650
疤疼是不是一个疤疼

01:42:50.650 --> 01:42:52.650
他就问你真实的动物对象

01:42:52.650 --> 01:42:54.650
是不是同一个真实的动物对象

01:42:54.650 --> 01:42:56.650
之前的动物对象有没有删除重建

01:42:56.650 --> 01:42:58.650
还有这个文本

01:42:58.650 --> 01:43:00.650
是不是同一个文本节点

01:43:00.650 --> 01:43:02.650
是不是

01:43:02.650 --> 01:43:04.650
是的

01:43:04.650 --> 01:43:06.650
这就是是的

01:43:06.650 --> 01:43:08.650
这种判断好像是不同的

01:43:08.650 --> 01:43:10.650
那一样的

01:43:10.650 --> 01:43:12.650
因为它产生的节点那一种是一样的

01:43:12.650 --> 01:43:14.650
你看这里产生div节点

01:43:14.650 --> 01:43:16.650
这里产生div节点

01:43:16.650 --> 01:43:18.650
是不是节点那一种一样

01:43:18.650 --> 01:43:20.650
那一种一样是不是会重用之前的

01:43:20.650 --> 01:43:22.650
真实动物对象

01:43:22.650 --> 01:43:24.650
如果是内组件的话

01:43:24.650 --> 01:43:26.650
就会重用之前的什么

01:43:26.650 --> 01:43:28.650
内的实力对象

01:43:28.650 --> 01:43:30.650
那这里包括这里

01:43:30.650 --> 01:43:32.650
Botten是不是一样的

01:43:32.650 --> 01:43:34.650
那么下面也一样

01:43:34.650 --> 01:43:36.650
新的节点全部诞生

01:43:36.650 --> 01:43:38.650
那么现在再再问你

01:43:38.650 --> 01:43:40.650
这里是个P元素

01:43:40.650 --> 01:43:42.650
那现在问你

01:43:42.650 --> 01:43:44.650
这个P的动物对象

01:43:44.650 --> 01:43:46.650
真实的动物对象

01:43:46.650 --> 01:43:48.650
跟这个div的真实动物对象是一个对象吗

01:43:48.650 --> 01:43:50.650
你觉得是一个对象吗

01:43:50.650 --> 01:43:52.650
你觉得它是不是一个对象

01:43:52.650 --> 01:43:54.650
之前是P,那么现在变成了div

01:43:54.650 --> 01:43:56.650
那你觉得它是一个动物对象吗

01:43:56.650 --> 01:43:58.650
肯定不是啊

01:43:58.650 --> 01:44:00.650
这东西我都打得去验证了

01:44:00.650 --> 01:44:02.650
那一定是把之前的div整个删掉

01:44:02.650 --> 01:44:04.650
因为它发现内形不一样

01:44:04.650 --> 01:44:06.650
之前的节点内形是P

01:44:06.650 --> 01:44:08.650
现在变成了div

01:44:08.650 --> 01:44:10.650
那我现在不管它很符合实力

01:44:10.650 --> 01:44:12.650
P里面所有东西全部一个个卸载

01:44:12.650 --> 01:44:14.650
还在这全部卸载完

01:44:14.650 --> 01:44:16.650
全部删掉

01:44:16.650 --> 01:44:18.650
那么以后再新建动物对象

01:44:18.650 --> 01:44:20.650
因此现在这里的Botten

01:44:20.650 --> 01:44:22.650
现在这里的Botten

01:44:22.650 --> 01:44:24.650
是什么东西

01:44:24.650 --> 01:44:26.650
就是这里的Botten

01:44:26.650 --> 01:44:28.650
是不是一个动物对象

01:44:28.650 --> 01:44:30.650
关键是个Botten

01:44:30.650 --> 01:44:32.650
Botten

01:44:32.650 --> 01:44:34.650
Botten

01:44:34.650 --> 01:44:36.650
拿到旧的Botten对象

01:44:36.650 --> 01:44:38.650
我们点击

01:44:38.650 --> 01:44:40.650
点击了过后再来一次Btn2

01:44:40.650 --> 01:44:42.650
你拿到Botten对象

01:44:42.650 --> 01:44:44.650
长的一模一样对吧

01:44:44.650 --> 01:44:46.650
Btn1是不等于Btn2

01:44:46.650 --> 01:44:48.650
不相等不是同一个动物对象

01:44:48.650 --> 01:44:50.650
说明之前的对象是不是删掉了

01:44:50.650 --> 01:44:52.650
然后后面全部是重新建立的

01:44:52.650 --> 01:44:54.650
所以说大家小心一点

01:44:54.650 --> 01:44:56.650
小心一点

01:44:56.650 --> 01:44:58.650
尽量的不要去改变

01:44:58.650 --> 01:45:00.650
动物的就是不要去改变

01:45:00.650 --> 01:45:02.650
节点类型

01:45:02.650 --> 01:45:04.650
因为改变节点类型的代价可能比较大

01:45:04.650 --> 01:45:06.650
特别是对于真实动物的一块

01:45:06.650 --> 01:45:08.650
因为我们知道效率的

01:45:08.650 --> 01:45:10.650
主要问题在于真实动物的操作对吧

01:45:10.650 --> 01:45:12.650
真实动物的操作的时候

01:45:12.650 --> 01:45:14.650
它会把自己的全部删完

01:45:14.650 --> 01:45:16.650
一个都不留

01:45:16.650 --> 01:45:18.650
然后全部重新建

01:45:18.650 --> 01:45:20.650
当然这个效率是比较低的

01:45:20.650 --> 01:45:22.650
因为它没办法

01:45:22.650 --> 01:45:24.650
它没办法它古语知道你要干嘛

01:45:24.650 --> 01:45:26.650
通常情况下我们

01:45:26.650 --> 01:45:28.650
这个没问题

01:45:28.650 --> 01:45:30.650
比如说我们以后学的路由

01:45:30.650 --> 01:45:32.650
翻页面从这个页面挑战到另外一个页面

01:45:32.650 --> 01:45:34.650
那肯定是页面结构很大的不一样了

01:45:34.650 --> 01:45:36.650
那么这个时候

01:45:36.650 --> 01:45:38.650
卸载就全部把旧的节点数卸载

01:45:38.650 --> 01:45:40.650
然后用新的节点数

01:45:40.650 --> 01:45:42.650
没有问题

01:45:42.650 --> 01:45:44.650
但是更多的时候在页面上

01:45:44.650 --> 01:45:46.650
举物变变化的时候

01:45:46.650 --> 01:45:48.650
往往它结构都差不多

01:45:48.650 --> 01:45:50.650
如果结构差不多的情况下

01:45:50.650 --> 01:45:52.650
你不要去因为一些某些特殊原因

01:45:52.650 --> 01:45:54.650
去改变这个玩意

01:45:55.650 --> 01:45:57.650
那么比方说我给他举个例子

01:45:57.650 --> 01:45:59.650
就是说如果比方说这里

01:45:59.650 --> 01:46:01.650
一个Visible

01:46:04.650 --> 01:46:06.650
那么这里有这么一个

01:46:06.650 --> 01:46:08.650
就是如果它的Visible

01:46:08.650 --> 01:46:10.650
如果它能显示的话

01:46:10.650 --> 01:46:12.650
我给它显示这么一种结构

01:46:12.650 --> 01:46:14.650
比方说

01:46:16.650 --> 01:46:18.650
我举个例子

01:46:18.650 --> 01:46:20.650
就用DIV嘛

01:46:20.650 --> 01:46:22.650
显示这么一种结构

01:46:22.650 --> 01:46:24.650
这个DIV里边有个H1元数

01:46:24.650 --> 01:46:26.650
就这个东西

01:46:26.650 --> 01:46:30.410
显示

01:46:30.410 --> 01:46:33.980
隐藏

01:46:33.980 --> 01:46:35.980
显示隐藏

01:46:35.980 --> 01:46:37.980
如果它是显示的话

01:46:37.980 --> 01:46:39.980
那么你就打印出这个东西

01:46:39.980 --> 01:46:41.980
或者是

01:46:41.980 --> 01:46:46.060
这样子吧

01:46:46.060 --> 01:46:48.060
为什么变成B了

01:46:48.060 --> 01:46:50.060
H1

01:46:50.060 --> 01:46:52.060
这里文字变一下

01:46:52.060 --> 01:46:54.060
变成一个标题

01:46:54.060 --> 01:46:56.060
我们控制这个标题的显示隐藏

01:46:56.060 --> 01:46:58.060
我们控制这个标题的显示隐藏

01:46:58.060 --> 01:47:00.060
我们控制这个标题的显示隐藏

01:47:00.060 --> 01:47:02.060
那么我们这里

01:47:02.060 --> 01:47:04.060
onclick

01:47:04.060 --> 01:47:06.060
当我们点击这个按钮的时候

01:47:06.060 --> 01:47:08.060
点击这个按钮的时候

01:47:08.060 --> 01:47:10.060
干嘛呢

01:47:10.060 --> 01:47:12.060
我们这里的set state

01:47:12.060 --> 01:47:14.060
把这个Visible

01:47:14.060 --> 01:47:16.060
给它设置成相反的

01:47:16.060 --> 01:47:18.060
set state

01:47:18.060 --> 01:47:20.060
Visible

01:47:20.060 --> 01:47:22.060
去相反的

01:47:22.060 --> 01:47:24.060
如果它能显示的话

01:47:24.060 --> 01:47:26.060
如果它不能显示的话

01:47:26.060 --> 01:47:28.060
Visible

01:47:28.060 --> 01:47:30.060
它输出这么一种结构

01:47:30.060 --> 01:47:32.060
如果它不能显示的话

01:47:32.060 --> 01:47:34.060
它只输出一个按钮

01:47:36.060 --> 01:47:38.060
它就没有这个H1元数了

01:47:38.060 --> 01:47:40.060
只有这么一个按钮

01:47:40.060 --> 01:47:42.060
看一下

01:47:42.060 --> 01:47:44.060
那么这里呢

01:47:44.060 --> 01:47:46.060
功能倒是没问题

01:47:46.060 --> 01:47:48.060
但是你这样做好不好

01:47:48.060 --> 01:47:50.060
这样做

01:47:50.060 --> 01:47:52.060
这样做呢

01:47:52.060 --> 01:47:54.060
不是很好

01:47:54.060 --> 01:47:56.060
为什么说这样做

01:47:56.060 --> 01:47:58.060
不是很好呢

01:47:58.060 --> 01:48:00.060
比方说有的时候

01:48:00.060 --> 01:48:02.060
我可以简写嘛

01:48:02.060 --> 01:48:04.060
简写也行

01:48:04.060 --> 01:48:06.060
比方说我们这里写一个变量

01:48:06.060 --> 01:48:08.060
一个变量

01:48:08.060 --> 01:48:10.060
就是net

01:48:10.060 --> 01:48:12.060
标题

01:48:12.060 --> 01:48:14.060
标题呢

01:48:14.060 --> 01:48:16.060
它不能情况下是这个

01:48:16.060 --> 01:48:18.060
不能情况下是这个玩意儿

01:48:18.060 --> 01:48:20.060
然后呢

01:48:20.060 --> 01:48:22.060
为什么不好

01:48:22.060 --> 01:48:24.060
你看一下这是旧的节点

01:48:24.060 --> 01:48:26.060
就是旧的节点

01:48:26.060 --> 01:48:28.060
然后呢一会儿呢产生了新的节点了

01:48:28.060 --> 01:48:30.060
是这么一种结构

01:48:30.060 --> 01:48:32.060
那么产生新的节点是不是要对比

01:48:32.060 --> 01:48:34.060
DIV内容是不是一样的

01:48:34.060 --> 01:48:36.060
那么这个没问题

01:48:36.060 --> 01:48:38.060
那么接下来对比新的节点的这个元数

01:48:38.060 --> 01:48:40.060
这个元数是之前的

01:48:40.060 --> 01:48:42.060
第一个元数进行对比

01:48:42.060 --> 01:48:44.060
它跟谁对比

01:48:44.060 --> 01:48:46.060
是不是跟它来对比

01:48:46.060 --> 01:48:48.060
它会跟它来对比

01:48:48.060 --> 01:48:50.060
它会跟它来进行对比

01:48:50.060 --> 01:48:52.060
来进行对比

01:48:52.060 --> 01:48:54.060
那么这样子一对比的话

01:48:54.060 --> 01:48:56.060
内形不一样它是button

01:48:56.060 --> 01:48:58.060
它是什么H1 内形不一样

01:48:58.060 --> 01:49:00.060
于是呢就把之前的H1

01:49:00.060 --> 01:49:02.060
删掉了

01:49:02.060 --> 01:49:04.060
把之前的H1删掉

01:49:04.060 --> 01:49:06.060
然后重新创建button

01:49:06.060 --> 01:49:08.060
所以说这样子一来这个button元数

01:49:08.060 --> 01:49:10.060
动物元数重新被创建了

01:49:10.060 --> 01:49:12.060
你看着吧

01:49:12.060 --> 01:49:14.060
一开始拿到btn1

01:49:14.060 --> 01:49:16.060
拿到button点击过后

01:49:16.060 --> 01:49:18.060
再拿到button

01:49:18.060 --> 01:49:20.060
咱们看一下btn1是不是等于btn2

01:49:20.060 --> 01:49:22.060
是force

01:49:22.060 --> 01:49:24.060
说明什么说明这个button是不是重新创建的

01:49:24.060 --> 01:49:26.060
莫名其妙

01:49:26.060 --> 01:49:28.060
这个东西有啥区别呢

01:49:28.060 --> 01:49:30.060
重新去创建一个

01:49:30.060 --> 01:49:32.060
就是因为它对比顺序

01:49:32.060 --> 01:49:34.060
它是这样对比的顺序的

01:49:34.060 --> 01:49:36.060
它不一样

01:49:36.060 --> 01:49:38.060
那么以后它是不是对比到没有新节点的

01:49:38.060 --> 01:49:40.060
相当于新节点散出了

01:49:40.060 --> 01:49:42.060
那么又把它又进入卸载

01:49:42.060 --> 01:49:44.060
以后我们再说

01:49:44.060 --> 01:49:46.060
会怎么样就是卸载

01:49:46.060 --> 01:49:48.060
那么这个东西肯定要卸载

01:49:48.060 --> 01:49:50.060
就点点要卸载掉

01:49:50.060 --> 01:49:52.060
相当于是把之前的button删除掉

01:49:52.060 --> 01:49:54.060
然后把新的button创建起来

01:49:54.060 --> 01:49:56.060
说这样子肯定不好

01:49:56.060 --> 01:49:58.060
另外一个不好的点在于这里

01:49:58.060 --> 01:50:00.060
这里你直接把这个节点

01:50:00.060 --> 01:50:02.060
这个动物元数干掉了

01:50:02.060 --> 01:50:04.060
干掉了之后

01:50:04.060 --> 01:50:06.060
那么如果以后将来要建立的话

01:50:06.060 --> 01:50:08.060
是不是又要重新创建动物对象

01:50:08.060 --> 01:50:10.060
那么这个效率是比较低的

01:50:10.060 --> 01:50:12.060
因为操作真实的动物对象的效率是比较低的

01:50:12.060 --> 01:50:14.060
所以官方推荐的做法是什么呢

01:50:14.060 --> 01:50:16.060
官方推荐的做法是有两种

01:50:16.060 --> 01:50:18.060
一种呢就是说

01:50:18.060 --> 01:50:20.060
如果你只是做显示隐藏的话

01:50:20.060 --> 01:50:22.060
那么建议你呢

01:50:22.060 --> 01:50:24.060
直接这样子玩

01:50:24.060 --> 01:50:26.060
看着啊

01:50:26.060 --> 01:50:28.060
官方推荐的这种做法

01:50:28.060 --> 01:50:30.060
一种呢就是说

01:50:30.060 --> 01:50:32.060
如果你只是做显示隐藏的话

01:50:32.060 --> 01:50:34.060
那么建议你呢

01:50:34.060 --> 01:50:36.060
直接这样子玩

01:50:36.060 --> 01:50:38.060
看着啊

01:50:38.060 --> 01:50:40.060
官方推荐的这种做法

01:50:40.060 --> 01:50:42.060
官方推荐的这种做法

01:50:42.060 --> 01:50:44.060
如果你仅做显示隐藏的话

01:50:44.060 --> 01:50:46.060
那么尽量这样子玩

01:50:46.060 --> 01:50:48.060
用样式来控制

01:50:48.060 --> 01:50:50.060
什么DISPLAY

01:50:50.060 --> 01:50:52.060
DISPLAY什么

01:50:52.060 --> 01:50:54.060
如果说这个属性

01:50:54.060 --> 01:50:56.060
它的就是ZestStats这个Visible

01:50:56.060 --> 01:50:58.060
如果Visible的话

01:50:58.060 --> 01:51:00.060
那么DisplayBlock

01:51:00.060 --> 01:51:02.060
用这样子的方式来控制

01:51:02.060 --> 01:51:04.060
那么这样子就不会改变这个元数的结构

01:51:04.060 --> 01:51:06.060
它的内形也不会变化

01:51:06.060 --> 01:51:08.060
那么到时候动物元数呢

01:51:08.060 --> 01:51:10.060
可以用保存

01:51:10.060 --> 01:51:12.060
你看一下显示隐藏

01:51:12.060 --> 01:51:14.060
同样的效果

01:51:14.060 --> 01:51:16.060
但是现在BTN1

01:51:16.060 --> 01:51:18.060
你看BTN1我们现在得到

01:51:18.060 --> 01:51:20.060
在点击BTN2

01:51:20.060 --> 01:51:22.060
那么现在BTN1和BTN2

01:51:22.060 --> 01:51:24.060
你看是不是一样的

01:51:24.060 --> 01:51:26.060
它就不会重新创建真实动物对象

01:51:26.060 --> 01:51:28.060
那么有的时候呢

01:51:28.060 --> 01:51:30.060
你可能确实不需要这个元数的

01:51:30.060 --> 01:51:32.060
可能有些特殊情况啊

01:51:32.060 --> 01:51:34.060
不仅仅要显示隐藏

01:51:34.060 --> 01:51:36.060
这个元数确实要给它干掉

01:51:36.060 --> 01:51:38.060
不建议你呢

01:51:38.060 --> 01:51:40.060
这样子来处理

01:51:40.060 --> 01:51:42.060
就是一个折衷的方案

01:51:42.060 --> 01:51:44.060
比如写个辩量

01:51:44.060 --> 01:51:46.060
比方说H1

01:51:46.060 --> 01:51:48.060
它没认为Low

01:51:48.060 --> 01:51:50.060
判断一下

01:51:50.060 --> 01:51:52.060
如果H1

01:51:52.060 --> 01:51:54.060
或者说就把它写成个3分余算符嘛

01:51:54.060 --> 01:51:56.060
ZestStats

01:51:56.060 --> 01:51:58.060
Visible

01:51:58.060 --> 01:52:00.060
如果Visible的话

01:52:00.060 --> 01:52:02.060
那么我得到一个H1元数

01:52:02.060 --> 01:52:04.060
这些标题

01:52:04.060 --> 01:52:06.060
这是一种比较折衷的方案

01:52:06.060 --> 01:52:09.500
好这种方案

01:52:09.500 --> 01:52:11.500
比之前那个还要好

01:52:11.500 --> 01:52:13.500
要好一点

01:52:13.500 --> 01:52:15.500
为什么呢你看着啊

01:52:15.500 --> 01:52:17.500
虽然说

01:52:17.500 --> 01:52:19.500
我们这里呢

01:52:19.500 --> 01:52:21.500
跟之前的元数结构看上去是一样的

01:52:21.500 --> 01:52:23.500
没有这个H1元数

01:52:23.500 --> 01:52:25.500
但是呢你看着我们发现一个神奇的现象

01:52:25.500 --> 01:52:27.500
BTN1达到

01:52:27.500 --> 01:52:29.500
点击

01:52:29.500 --> 01:52:31.500
BTN2达到

01:52:31.500 --> 01:52:33.500
BTN1是不是等于BTN2

01:52:33.500 --> 01:52:35.500
不相等

01:52:35.500 --> 01:52:37.500
因为Low它也是一个节点

01:52:37.500 --> 01:52:39.500
Low是什么节点

01:52:39.500 --> 01:52:41.500
Low是空节点

01:52:41.500 --> 01:52:43.500
空节点是不是有用

01:52:43.500 --> 01:52:45.500
空节点虽然它不参与宣展

01:52:45.500 --> 01:52:47.500
但是它是不是有用的

01:52:47.500 --> 01:52:49.500
你看一下吧

01:52:49.500 --> 01:52:51.500
这个APP里面DIV有什么

01:52:51.500 --> 01:52:53.500
一开始的时候是不显示的

01:52:53.500 --> 01:52:55.500
不显示的那么这里是个空节点

01:52:55.500 --> 01:52:57.500
空

01:52:57.500 --> 01:52:59.500
空节点

01:52:59.500 --> 01:53:01.500
那么这里是个button

01:53:01.500 --> 01:53:03.500
这两个是一样的

01:53:03.500 --> 01:53:05.500
继续对比下面的指元数

01:53:05.500 --> 01:53:07.500
进入对比更新

01:53:07.500 --> 01:53:09.500
那么这里变成了一个

01:53:09.500 --> 01:53:11.500
H1

01:53:11.500 --> 01:53:13.500
这里变成了一个button

01:53:13.500 --> 01:53:15.500
对比吗

01:53:15.500 --> 01:53:17.500
H1是不是对应到这

01:53:17.500 --> 01:53:19.500
这里是不是内形不一样

01:53:19.500 --> 01:53:21.500
之前的卸载掉

01:53:21.500 --> 01:53:23.500
重建

01:53:23.500 --> 01:53:25.500
H1整个重建了

01:53:25.500 --> 01:53:27.500
这个东西没办法

01:53:27.500 --> 01:53:29.500
要干掉之前的元数

01:53:29.500 --> 01:53:31.500
重建

01:53:31.500 --> 01:53:33.500
button他现在是不是跟他来对比了

01:53:33.500 --> 01:53:35.500
因为有之前空节点的存在

01:53:35.500 --> 01:53:37.500
button他就跟他来对比了

01:53:37.500 --> 01:53:39.500
所以说button他就不会重新

01:53:39.500 --> 01:53:41.500
创建多么元数

01:53:41.500 --> 01:53:43.500
这是一种比较折腾的方案

01:53:43.500 --> 01:53:45.500
如果你像刚才那样说的话

01:53:45.500 --> 01:53:47.500
直接给他干掉的话

01:53:47.500 --> 01:53:49.500
用这种判断的方式直接干掉的话

01:53:49.500 --> 01:53:51.500
那么就会导致问题

01:53:51.500 --> 01:53:53.500
就会导致这个问题

01:53:53.500 --> 01:53:55.500
导致这个button他跟之前的H1

01:53:55.500 --> 01:53:57.500
来进行对比了

01:53:57.500 --> 01:53:59.500
写的时候只要你记住

01:53:59.500 --> 01:54:01.500
尽量的不要去改变

01:54:01.500 --> 01:54:03.500
节点内形和节点结构

01:54:03.500 --> 01:54:05.500
就可以提高效率

01:54:05.500 --> 01:54:07.500
这是

01:54:07.500 --> 01:54:09.500
这是这一块

01:54:09.500 --> 01:54:11.500
那么这里前面就说完了

01:54:11.500 --> 01:54:13.500
前面说的是什么

01:54:13.500 --> 01:54:15.500
前面说的就是

01:54:15.500 --> 01:54:17.500
找到了对比目标的情况下

01:54:17.500 --> 01:54:19.500
就是我有对比目标

01:54:19.500 --> 01:54:21.500
有的时候没有对比目标

01:54:21.500 --> 01:54:23.500
这个没有对比目标的就是说

01:54:23.500 --> 01:54:27.500
新的多么数中

01:54:27.500 --> 01:54:29.500
有

01:54:29.500 --> 01:54:31.500
节点被删除

01:54:31.500 --> 01:54:35.500
或者说新的多么数中

01:54:35.500 --> 01:54:37.500
有节点添加

01:54:37.500 --> 01:54:39.500
有节点添加

01:54:39.500 --> 01:54:41.500
或者是节点删除

01:54:41.500 --> 01:54:43.500
那么面对这种情况的话

01:54:43.500 --> 01:54:45.500
那么就是没有对比目标

01:54:45.500 --> 01:54:47.500
比方说我们这里可以看到

01:54:47.500 --> 01:54:49.500
一开始的情况是这样子

01:54:49.500 --> 01:54:51.500
一开始没有对吧

01:54:51.500 --> 01:54:53.500
新出来了一个是吧

01:54:53.500 --> 01:54:55.500
H1

01:54:55.500 --> 01:54:57.500
H1跟它来对比

01:54:57.500 --> 01:54:59.500
H1跟它来对比

01:54:59.500 --> 01:55:01.500
H1会跟它来进行对比

01:55:01.500 --> 01:55:03.500
发现内形不一样

01:55:03.500 --> 01:55:05.500
它卸载H1添加

01:55:05.500 --> 01:55:07.500
然后再加这个

01:55:07.500 --> 01:55:09.500
这个是不是新的

01:55:09.500 --> 01:55:11.500
它没有对比的东西

01:55:11.500 --> 01:55:13.500
它要对比第二个

01:55:13.500 --> 01:55:15.500
它没有第二个

01:55:15.500 --> 01:55:17.500
它本来这里应该有一个

01:55:17.500 --> 01:55:19.500
它没有像这种情况

01:55:19.500 --> 01:55:21.500
没有对比的目标

01:55:21.500 --> 01:55:23.500
还有一种情况

01:55:23.500 --> 01:55:27.640
反过来

01:55:27.640 --> 01:55:29.640
这种情况其实很简单

01:55:29.640 --> 01:55:31.640
反过来就是什么

01:55:31.640 --> 01:55:33.640
一开始有一个节点

01:55:33.640 --> 01:55:35.640
后面变成少了一个节点

01:55:35.640 --> 01:55:37.640
它跟它来对比

01:55:37.640 --> 01:55:39.640
反正内形不一样

01:55:39.640 --> 01:55:41.640
它删除它重建

01:55:41.640 --> 01:55:43.640
它以前有

01:55:43.640 --> 01:55:45.640
现在没有了

01:55:45.640 --> 01:55:47.640
它要卸载

01:55:47.640 --> 01:55:49.640
这个过程其实很简单

01:55:49.640 --> 01:55:51.640
旧的

01:55:51.640 --> 01:55:53.640
就是创建

01:55:53.640 --> 01:55:55.640
新加入的

01:55:55.640 --> 01:55:57.640
节点

01:55:57.640 --> 01:55:59.640
然后卸载

01:55:59.640 --> 01:56:01.640
多余的旧节点

01:56:01.640 --> 01:56:03.640
就是发现一些旧节点是多余的

01:56:03.640 --> 01:56:05.640
那么把它卸载掉

01:56:05.640 --> 01:56:07.640
创建新加入的节点

01:56:07.640 --> 01:56:09.640
然后卸载旧多余的节点

01:56:09.640 --> 01:56:11.640
那么怎么来创建新加入的节点

01:56:11.640 --> 01:56:13.640
是不是进入那个挂载流程

01:56:13.640 --> 01:56:15.640
新节点渲染的流程

01:56:15.640 --> 01:56:17.640
就用这个流程

01:56:17.640 --> 01:56:19.640
就进入卸载流程

01:56:19.640 --> 01:56:21.640
那么就是这么一种状态

01:56:21.640 --> 01:56:23.640
就跟之前的东西是不是接上了

01:56:23.640 --> 01:56:25.640
它不要到这里

01:56:25.640 --> 01:56:27.640
旧的节点是不是多了一个

01:56:27.640 --> 01:56:29.640
多了一个

01:56:29.640 --> 01:56:31.640
是不是它要卸载掉

01:56:31.640 --> 01:56:33.640
反过来的话

01:56:33.640 --> 01:56:35.640
那么这里是不是

01:56:35.640 --> 01:56:37.640
旧的节点少了一个

01:56:37.640 --> 01:56:39.640
那么它进入新创建的流程

01:56:39.640 --> 01:56:41.640
就这么一回事

01:56:41.640 --> 01:56:43.640
它跟它的对比不是说没有找到对比目标

01:56:43.640 --> 01:56:45.640
它们是有对比目标的

01:56:45.640 --> 01:56:47.640
内容不一样

01:56:47.640 --> 01:56:49.640
就是关于这一块

01:56:49.640 --> 01:56:51.640
好 最后一部分

01:56:51.640 --> 01:56:53.640
咱们这一刻的最后一部分就是关于这个了

01:56:53.640 --> 01:56:55.640
之前我们说过假设

01:56:55.640 --> 01:56:57.640
假设这里呢

01:56:57.640 --> 01:56:59.640
刚才说一块想一说

01:56:59.640 --> 01:57:01.640
对吧 现在可以想一说了

01:57:01.640 --> 01:57:03.640
这个key

01:57:03.640 --> 01:57:05.640
这个key用来干嘛呢

01:57:05.640 --> 01:57:07.640
这个key我们写到在前面

01:57:07.640 --> 01:57:09.640
key值的作用

01:57:09.640 --> 01:57:11.640
是

01:57:11.640 --> 01:57:13.640
作用是用于找到

01:57:13.640 --> 01:57:15.640
用于

01:57:15.640 --> 01:57:17.640
通过

01:57:17.640 --> 01:57:19.640
旧节点

01:57:19.640 --> 01:57:21.640
寻找

01:57:21.640 --> 01:57:23.640
对应的新节点

01:57:23.640 --> 01:57:25.640
我们之前不是说

01:57:25.640 --> 01:57:27.640
一个是找到了目标对比目标

01:57:27.640 --> 01:57:29.640
一个是没有找到对比目标吗对吧

01:57:29.640 --> 01:57:31.640
key值来做什么用之后

01:57:31.640 --> 01:57:33.640
就是在帮助你找到目标

01:57:33.640 --> 01:57:35.640
跟谁来对比

01:57:35.640 --> 01:57:37.640
它就起这么一个作用

01:57:37.640 --> 01:57:39.640
到底是跟谁来对比

01:57:39.640 --> 01:57:41.640
找到对比过后是不是后面就一样了

01:57:41.640 --> 01:57:43.640
那么key值的作用是专门来用于

01:57:43.640 --> 01:57:45.640
就是来进行对比的

01:57:45.640 --> 01:57:47.640
来找了一个对比的节点

01:57:47.640 --> 01:57:49.640
要到底要跟神态

01:57:49.640 --> 01:57:51.640
谁来对比

01:57:51.640 --> 01:57:53.640
如果某个旧节点

01:57:53.640 --> 01:57:55.640
旧节点

01:57:55.640 --> 01:57:57.640
有key值

01:57:57.640 --> 01:57:59.640
折

01:57:59.640 --> 01:58:01.640
其寻找

01:58:01.640 --> 01:58:03.640
折其更新时

01:58:03.640 --> 01:58:05.640
会寻找

01:58:05.640 --> 01:58:07.640
对应

01:58:07.640 --> 01:58:09.640
寻找

01:58:09.640 --> 01:58:11.640
相同层级

01:58:11.640 --> 01:58:13.640
它不会说挑越层级

01:58:13.640 --> 01:58:15.640
它有key值它不会跑到这里去找

01:58:15.640 --> 01:58:17.640
它一定是找相同层级的

01:58:17.640 --> 01:58:19.640
找相同层级

01:58:19.640 --> 01:58:21.640
相同层级

01:58:21.640 --> 01:58:23.640
会寻找相同层级中的

01:58:23.640 --> 01:58:25.640
相同key值

01:58:25.640 --> 01:58:27.640
的节点

01:58:27.640 --> 01:58:29.640
进行对比

01:58:29.640 --> 01:58:31.640
当然找不到的话就进入这个了

01:58:31.640 --> 01:58:33.640
进入没有找到对比目标了

01:58:33.640 --> 01:58:35.640
这里给大家举个例子

01:58:35.640 --> 01:58:37.640
key值就这个作用

01:58:37.640 --> 01:58:39.640
key值不要认为它很高声

01:58:39.640 --> 01:58:41.640
它就是来找目标的

01:58:41.640 --> 01:58:43.640
跟谁来进行对比的目标

01:58:43.640 --> 01:58:45.640
比方说吧

01:58:45.640 --> 01:58:47.640
咱们这里

01:58:47.640 --> 01:58:49.640
app里边写上这么一个玩意儿

01:58:51.640 --> 01:58:53.640
div下边的话

01:58:53.640 --> 01:58:55.640
我们写上这么一个按钮

01:58:55.640 --> 01:58:57.640
这个按钮显示了这么一句话

01:58:57.640 --> 01:58:59.640
就是

01:58:59.640 --> 01:59:01.640
is a rig

01:59:01.640 --> 01:59:03.640
is a rig

01:59:03.640 --> 01:59:05.640
这里写上

01:59:05.640 --> 01:59:07.640
force

01:59:07.640 --> 01:59:09.640
表示

01:59:09.640 --> 01:59:11.640
是否是

01:59:11.640 --> 01:59:13.640
注册

01:59:13.640 --> 01:59:15.640
那么下边是这样子的

01:59:15.640 --> 01:59:17.640
我们的写法是这样子的

01:59:17.640 --> 01:59:19.640
这个button里边

01:59:19.640 --> 01:59:21.640
我们写上

01:59:21.640 --> 01:59:23.640
点击is rig 给它取反

01:59:23.640 --> 01:59:25.640
这里是

01:59:25.640 --> 01:59:27.640
登录

01:59:27.640 --> 01:59:29.640
进行登录注册切换的

01:59:29.640 --> 01:59:31.640
登录注册进行切换

01:59:31.640 --> 01:59:33.640
这种情况很容易遇到

01:59:33.640 --> 01:59:35.640
里面以后就知道了

01:59:35.640 --> 01:59:37.640
那么登录注册切换

01:59:37.640 --> 01:59:39.640
切换的时候

01:59:39.640 --> 01:59:41.640
下面有个div

01:59:41.640 --> 01:59:43.640
登录是一个div

01:59:43.640 --> 01:59:45.640
注册是一个div

01:59:45.640 --> 01:59:47.640
下面有个div

01:59:49.640 --> 01:59:51.640
这个div有可能是登录

01:59:51.640 --> 01:59:53.640
有可能是注册

01:59:53.640 --> 01:59:55.640
咱们干脆就写了一个辩量

01:59:55.640 --> 01:59:57.640
或者说就在这里面直接写

01:59:57.640 --> 01:59:59.640
直接写表示

01:59:59.640 --> 02:00:01.640
如果is a rig

02:00:01.640 --> 02:00:03.640
如果是注册的话

02:00:03.640 --> 02:00:05.640
那么我生成一个节点结构

02:00:05.640 --> 02:00:07.640
如果是登录的话

02:00:07.640 --> 02:00:09.640
又生成一个节点结构

02:00:09.640 --> 02:00:11.640
咱们比方说

02:00:11.640 --> 02:00:13.640
如果是注册的话

02:00:13.640 --> 02:00:15.640
我们生成一个div

02:00:15.640 --> 02:00:20.870
有个内样是rig

02:00:20.870 --> 02:00:22.870
rig

02:00:22.870 --> 02:00:24.870
class name

02:00:24.870 --> 02:00:26.870
如果是注册的话

02:00:26.870 --> 02:00:28.870
我们生成这样一个内样是的div

02:00:28.870 --> 02:00:32.440
这个div里面有两个

02:00:32.440 --> 02:00:34.440
一个是input

02:00:34.440 --> 02:00:36.440
帐号

02:00:36.440 --> 02:00:38.440
然后

02:00:38.440 --> 02:00:40.440
一个input

02:00:40.440 --> 02:00:42.440
这是

02:00:42.440 --> 02:00:44.440
帐号

02:00:44.440 --> 02:00:46.440
不让它受控了

02:00:46.440 --> 02:00:48.440
麻烦

02:00:48.440 --> 02:00:50.440
这么一个问题就行了

02:00:50.440 --> 02:00:52.440
temp

02:00:52.440 --> 02:00:54.440
password

02:00:54.440 --> 02:00:56.440
然后再来

02:00:56.440 --> 02:00:58.440
确认密码

02:00:58.440 --> 02:01:00.440
确认密码

02:01:00.440 --> 02:01:02.440
这里使用什么

02:01:02.440 --> 02:01:04.440
就用这个

02:01:04.440 --> 02:01:06.440
就行了 后面有一个按钮

02:01:06.440 --> 02:01:08.440
提注册

02:01:08.440 --> 02:01:10.440
这是注册的结构

02:01:10.440 --> 02:01:12.440
没问题吧

02:01:12.440 --> 02:01:14.440
这是注册的结构

02:01:14.440 --> 02:01:16.440
登录的结构我就全部写到一起

02:01:16.440 --> 02:01:18.440
但是最好是用两个组件

02:01:18.440 --> 02:01:20.440
最好是用两个组件

02:01:20.440 --> 02:01:22.440
那么这里呢

02:01:22.440 --> 02:01:24.440
我主要是说明一个问题

02:01:24.440 --> 02:01:26.440
这里我们写上login

02:01:26.440 --> 02:01:28.440
内样子变了

02:01:28.440 --> 02:01:30.440
也拿来去写内样子

02:01:30.440 --> 02:01:32.440
然后有一个什么

02:01:32.440 --> 02:01:34.440
登录

02:01:34.440 --> 02:01:36.440
保存

02:01:36.440 --> 02:01:38.440
切换

02:01:38.440 --> 02:01:40.440
这是切换的注册

02:01:40.440 --> 02:01:42.440
接下来

02:01:42.440 --> 02:01:44.440
我们在文笨框里写些东西

02:01:44.440 --> 02:01:47.750
看到问题没

02:01:47.750 --> 02:01:49.750
我在切换登录和注册的时候

02:01:49.750 --> 02:01:51.750
这个文笨框它没有清空

02:01:51.750 --> 02:01:53.750
它为什么没有清空

02:01:53.750 --> 02:01:55.750
为什么没有清空

02:01:55.750 --> 02:01:57.750
先说说明这两个文笨框

02:01:57.750 --> 02:01:59.750
为什么没有清空

02:01:59.750 --> 02:02:01.750
因为它发现结构是一样的

02:02:01.750 --> 02:02:03.750
结垫内形是一样的

02:02:03.750 --> 02:02:05.750
注册的时候得到DIV

02:02:05.750 --> 02:02:07.750
所以DIV它不会切换掉

02:02:07.750 --> 02:02:09.750
DIV会重用之前的动物对象

02:02:09.750 --> 02:02:11.750
它只是改了内样式而已

02:02:11.750 --> 02:02:13.750
它不会把之前的动物对象删掉

02:02:13.750 --> 02:02:15.750
又重新建

02:02:15.750 --> 02:02:17.750
它会重用动物对象

02:02:17.750 --> 02:02:19.750
动物对象里面比较指援

02:02:19.750 --> 02:02:21.750
P元素是不一样的

02:02:21.750 --> 02:02:23.750
input元素是不一样的

02:02:23.750 --> 02:02:25.750
结垫内形都是一样的

02:02:25.750 --> 02:02:27.750
前面是个文笨结垫

02:02:27.750 --> 02:02:29.750
没问题吧

02:02:29.750 --> 02:02:31.750
没问题吧

02:02:31.750 --> 02:02:33.750
好那么现在比方说

02:02:33.750 --> 02:02:35.750
所以说这里密码

02:02:35.750 --> 02:02:37.750
帐号这里

02:02:37.750 --> 02:02:39.750
它们两个的动物元素

02:02:39.750 --> 02:02:41.750
真实动物元素是重用的

02:02:41.750 --> 02:02:43.750
所以说真实动物元素并没有发生变化

02:02:43.750 --> 02:02:45.750
因此它保留了动物元素里面的状态

02:02:45.750 --> 02:02:47.750
它就保留了动物元素里面的状态

02:02:47.750 --> 02:02:49.750
所以说它为什么要受控

02:02:49.750 --> 02:02:51.750
受控就不会

02:02:51.750 --> 02:02:53.750
因为受控的话它的Y6只要重新去读取

02:02:53.750 --> 02:02:55.750
读取状态里面的Y6只

02:02:55.750 --> 02:02:57.750
看了没

02:02:57.750 --> 02:02:59.750
好那么比方说

02:02:59.750 --> 02:03:01.750
如果说我把这个两个字删掉

02:03:01.750 --> 02:03:03.750
前面帐号两个字删掉

02:03:03.750 --> 02:03:05.750
那现在会不会出现

02:03:05.750 --> 02:03:07.750
这种情况了

02:03:07.750 --> 02:03:09.750
是没了为什么结构不一样的

02:03:09.750 --> 02:03:11.750
它原来这里一个文笨结垫

02:03:11.750 --> 02:03:13.750
现在没有文笨结垫了

02:03:13.750 --> 02:03:15.750
那么现在就是把input元素

02:03:15.750 --> 02:03:17.750
跟谁来比较

02:03:17.750 --> 02:03:19.750
跟之前的文笨结垫来比较

02:03:19.750 --> 02:03:21.750
那是自然比较不到的

02:03:21.750 --> 02:03:23.750
就把文笨结垫删除掉

02:03:23.750 --> 02:03:24.750
后面又看到这个东西

02:03:24.750 --> 02:03:25.750
这个东西已经没有对比的了

02:03:25.750 --> 02:03:27.750
把它删除掉

02:03:27.750 --> 02:03:29.750
有这样子不一样了

02:03:29.750 --> 02:03:31.750
好那么接下来

02:03:31.750 --> 02:03:33.750
比方说我们现在

02:03:33.750 --> 02:03:35.750
现在再看下面确认密码

02:03:35.750 --> 02:03:37.750
确认密码能不能保留

02:03:37.750 --> 02:03:39.750
你觉得能不能保留

02:03:39.750 --> 02:03:41.750
确认密码

02:03:41.750 --> 02:03:43.750
确认密码保留不了

02:03:43.750 --> 02:03:45.750
因为确认密码对不上

02:03:45.750 --> 02:03:47.750
这个东西对不上

02:03:47.750 --> 02:03:49.750
跟这边对不上对不对

02:03:49.750 --> 02:03:51.750
确认密码这一颗跟这边对不上

02:03:52.750 --> 02:03:54.750
安留的自然

02:03:54.750 --> 02:03:55.750
安留的状态也不会保留

02:03:55.750 --> 02:03:56.750
因为和结构不一样了

02:03:56.750 --> 02:03:58.750
但前面两个结构是一样的

02:03:58.750 --> 02:04:00.750
那现在如果我希望

02:04:00.750 --> 02:04:02.750
如果我希望

02:04:02.750 --> 02:04:05.750
账号和密码这里不要保留

02:04:05.750 --> 02:04:07.750
其他的动物元素可以保留

02:04:07.750 --> 02:04:09.750
你可以重用为了提高效率

02:04:09.750 --> 02:04:11.750
但是账号和密码这里也不要保留

02:04:11.750 --> 02:04:13.750
怎么办呢很简单

02:04:13.750 --> 02:04:14.750
加上key

02:04:14.750 --> 02:04:16.750
加上keyz

02:04:16.750 --> 02:04:18.750
keyz想写它写

02:04:18.750 --> 02:04:20.750
可以写数字可以写个对象可以

02:04:20.750 --> 02:04:22.750
数字的话就这样子写

02:04:22.750 --> 02:04:24.750
对象的话就这样子写

02:04:24.750 --> 02:04:26.750
想写它写啥

02:04:26.750 --> 02:04:28.750
表示这里是注册的

02:04:28.750 --> 02:04:30.750
reg

02:04:30.750 --> 02:04:32.750
这里是reg注册的

02:04:32.750 --> 02:04:34.750
这里是登录的

02:04:34.750 --> 02:04:36.750
login

02:04:36.750 --> 02:04:38.750
这里也是登录的

02:04:38.750 --> 02:04:40.750
login你看一下现在不一样了

02:04:40.750 --> 02:04:42.750
账号随便写

02:04:42.750 --> 02:04:44.750
密码随便写点击

02:04:44.750 --> 02:04:46.750
你看是不是没了

02:04:46.750 --> 02:04:48.750
因为他发现keyz不一样

02:04:48.750 --> 02:04:50.750
表示他写的到这

02:04:50.750 --> 02:04:52.750
你看吧他写的一开始是注册

02:04:52.750 --> 02:04:54.750
一开始是注册

02:04:54.750 --> 02:04:56.750
那么他是这样子一个div

02:04:56.750 --> 02:04:58.750
div里面有一个

02:04:58.750 --> 02:05:00.750
我外面还有一个div

02:05:00.750 --> 02:05:02.750
我就去看这

02:05:02.750 --> 02:05:04.750
两个p元数

02:05:04.750 --> 02:05:06.750
div里面有两个p元数

02:05:06.750 --> 02:05:08.750
p元数里面这两个p元数

02:05:08.750 --> 02:05:10.750
后面就不写了

02:05:10.750 --> 02:05:12.750
这是一个input元数

02:05:12.750 --> 02:05:14.750
文明节点我也不写了

02:05:14.750 --> 02:05:16.750
他的key等于多少

02:05:16.750 --> 02:05:18.750
他的key是reg

02:05:18.750 --> 02:05:20.750
那么他有了keyz

02:05:20.750 --> 02:05:22.750
如果没有keyz的话就找相同位置

02:05:22.750 --> 02:05:24.750
如果有了keyz的话

02:05:24.750 --> 02:05:26.750
就找keyz对应的东西

02:05:26.750 --> 02:05:28.750
那么新生的节点

02:05:28.750 --> 02:05:30.750
里面是不是也有p元数

02:05:30.750 --> 02:05:32.750
内情都是一样的

02:05:32.750 --> 02:05:34.750
但是新生的节点里面

02:05:34.750 --> 02:05:36.750
这个input

02:05:36.750 --> 02:05:40.750
他的keyz是login

02:05:40.750 --> 02:05:42.750
这里的keyz是login

02:05:42.750 --> 02:05:44.750
他说keyz重复了

02:05:44.750 --> 02:05:46.750
keyz是这样子

02:05:46.750 --> 02:05:48.750
keyz不是说不能重复

02:05:48.750 --> 02:05:50.750
他指的是在同一层次下面是不能重复的

02:05:50.750 --> 02:05:52.750
比方这个p的指元数里面

02:05:52.750 --> 02:05:54.750
他的keyz是不能重复的

02:05:54.750 --> 02:05:56.750
这个p的指元数里面

02:05:56.750 --> 02:05:58.750
keyz是不能重复

02:05:58.750 --> 02:06:00.750
他在不同的层次里面

02:06:00.750 --> 02:06:02.750
是可以重复的

02:06:02.750 --> 02:06:04.750
因为他的对比是

02:06:04.750 --> 02:06:06.750
只对比同一层次的

02:06:06.750 --> 02:06:08.750
首先p元数都是一致

02:06:08.750 --> 02:06:10.750
这些都是从用的

02:06:10.750 --> 02:06:12.750
从用的换一个颜色

02:06:12.750 --> 02:06:14.750
换成绿色表示从用的

02:06:14.750 --> 02:06:16.750
然后这个东西来对比

02:06:16.750 --> 02:06:18.750
虽然他们内形一致

02:06:18.750 --> 02:06:20.750
但是他们的key不一样

02:06:20.750 --> 02:06:22.750
因为它是怎么对比的

02:06:22.750 --> 02:06:24.750
从揪的动物数里面拿到keyz rake

02:06:24.750 --> 02:06:26.750
那么它会去找啥

02:06:26.750 --> 02:06:28.750
找这个p元数里面

02:06:28.750 --> 02:06:30.750
相同的keyz的东西

02:06:30.750 --> 02:06:32.750
有没有找到

02:06:32.750 --> 02:06:34.750
它就不会去寻找这个东西了

02:06:34.750 --> 02:06:36.750
它就不会寻找对应位置的了

02:06:36.750 --> 02:06:38.750
它要去寻找对应keyz的东西

02:06:38.750 --> 02:06:39.750
它就没有找到

02:06:39.750 --> 02:06:41.750
找到过后再进行对比

02:06:41.750 --> 02:06:42.750
它没有找到

02:06:42.750 --> 02:06:44.750
没有找到会怎么样呢

02:06:44.750 --> 02:06:45.750
没有找到是不是

02:06:45.750 --> 02:06:47.750
它就没有对比了

02:06:47.750 --> 02:06:48.750
它就进入这么一个流程了

02:06:48.750 --> 02:06:49.750
没有找到对比目标

02:06:49.750 --> 02:06:50.750
那干嘛呢

02:06:50.750 --> 02:06:51.750
该删了山

02:06:51.750 --> 02:06:53.750
它就是不是被删了

02:06:53.750 --> 02:06:54.750
该新建的新建

02:06:54.750 --> 02:06:55.750
它是新建的了

02:06:55.750 --> 02:06:57.750
它会放到新的数里面

02:06:57.750 --> 02:06:58.750
一会儿这边是不是一样

02:06:58.750 --> 02:06:59.750
它被删除了

02:06:59.750 --> 02:07:01.750
那么它会放到新数里面

02:07:01.750 --> 02:07:03.750
这是新的动物数

02:07:03.750 --> 02:07:04.750
所以说

02:07:04.750 --> 02:07:06.750
这是两个全新的

02:07:06.750 --> 02:07:07.750
元素

02:07:07.750 --> 02:07:08.750
明白这个意思吧

02:07:08.750 --> 02:07:10.750
keyz就起这么一个作用

02:07:11.750 --> 02:07:13.750
这就是keyz

02:07:13.750 --> 02:07:14.750
那么包括一个

02:07:14.750 --> 02:07:15.750
包括那个组建对象的话

02:07:15.750 --> 02:07:16.750
那是一样的

02:07:16.750 --> 02:07:17.750
组建对象的话

02:07:17.750 --> 02:07:19.750
如果有相同的keyz

02:07:19.750 --> 02:07:20.750
那么它会重用

02:07:20.750 --> 02:07:21.750
组建对象

02:07:21.750 --> 02:07:22.750
对象会重用

02:07:22.750 --> 02:07:24.750
如果没有相同keyz

02:07:24.750 --> 02:07:25.750
那么组建会被卸载

02:07:25.750 --> 02:07:26.750
一些对象会被卸载

02:07:26.750 --> 02:07:27.750
进入卸载生命周期

02:07:27.750 --> 02:07:28.750
然后呢

02:07:28.750 --> 02:07:29.750
另外一个对象呢

02:07:29.750 --> 02:07:31.750
会被新建

02:07:31.750 --> 02:07:32.750
比方说吧

02:07:32.750 --> 02:07:34.750
再来个例子嘛

02:07:35.750 --> 02:07:37.750
还是用Visible嘛

02:07:37.750 --> 02:07:38.750
还是用Visible

02:07:38.750 --> 02:07:39.750
设为处

02:07:39.750 --> 02:07:43.770
举一个简单例子就行了

02:07:44.770 --> 02:07:45.770
看着啊

02:07:49.400 --> 02:07:50.400
这里呢

02:07:50.400 --> 02:07:52.400
我们写这么一个组建

02:07:52.400 --> 02:07:53.400
class

02:07:54.400 --> 02:07:55.400
方形

02:07:58.400 --> 02:07:59.400
comp a

02:07:59.400 --> 02:08:00.400
extence

02:08:00.400 --> 02:08:01.400
component

02:08:01.400 --> 02:08:02.400
写这么一个组建

02:08:02.400 --> 02:08:03.400
Render

02:08:03.400 --> 02:08:05.400
Render没啥好说的

02:08:05.400 --> 02:08:06.400
就是

02:08:06.400 --> 02:08:07.400
Render没啥好说的

02:08:07.400 --> 02:08:08.400
就是comp a

02:08:09.400 --> 02:08:10.400
ok

02:08:10.400 --> 02:08:11.400
然后这个组建里边呢

02:08:11.400 --> 02:08:13.400
我们写上这么一个东西

02:08:15.900 --> 02:08:17.900
写上一个component

02:08:17.900 --> 02:08:20.920
deadmount

02:08:20.920 --> 02:08:21.920
comp a

02:08:22.920 --> 02:08:23.920
component

02:08:23.920 --> 02:08:24.920
deadmount

02:08:25.920 --> 02:08:26.920
再来一个东西啊

02:08:26.920 --> 02:08:27.920
就是

02:08:27.920 --> 02:08:28.920
component

02:08:28.920 --> 02:08:29.920
will

02:08:29.920 --> 02:08:30.920
amount

02:08:31.920 --> 02:08:32.920
卸载嘛

02:08:32.920 --> 02:08:33.920
卸载

02:08:33.920 --> 02:08:34.920
component a

02:08:34.920 --> 02:08:35.920
willamount

02:08:36.920 --> 02:08:37.920
好像这两个生命周期喊说

02:08:37.920 --> 02:08:39.920
我们主要是看他有没有卸载

02:08:39.920 --> 02:08:40.920
有没有就是新建

02:08:40.920 --> 02:08:41.920
这个就是新建对吧

02:08:41.920 --> 02:08:42.920
挂载

02:08:42.920 --> 02:08:43.920
就新建了

02:08:43.920 --> 02:08:45.920
就说新建嘛

02:08:45.920 --> 02:08:47.920
好这个呢就是什么

02:08:47.920 --> 02:08:49.920
这个就是那个卸载

02:08:50.920 --> 02:08:51.920
好来看一下吧

02:08:51.920 --> 02:08:52.920
我们这里呢

02:08:53.920 --> 02:08:55.920
Render里边我们根据状态

02:08:55.920 --> 02:08:57.920
根据状态来反悔不同的东西

02:08:57.920 --> 02:08:58.920
如果

02:09:02.000 --> 02:09:03.000
这样吧

02:09:03.000 --> 02:09:04.000
这样

02:09:05.000 --> 02:09:06.000
我们这里呢

02:09:06.000 --> 02:09:07.000
状态里面随便写个状态嘛

02:09:07.000 --> 02:09:09.000
这状态其实无所谓的

02:09:09.000 --> 02:09:10.000
随便写个状态

02:09:12.000 --> 02:09:13.000
这样子吧

02:09:13.000 --> 02:09:14.000
就是无所谓的状态

02:09:14.000 --> 02:09:15.000
状态没什么用

02:09:15.000 --> 02:09:16.000
没什么用啊

02:09:16.000 --> 02:09:17.000
那么这里呢我们这样子来玩

02:09:17.000 --> 02:09:18.000
看着

02:09:18.000 --> 02:09:19.000
comp a

02:09:19.000 --> 02:09:20.000
一个卸杠

02:09:21.000 --> 02:09:22.000
然后呢给他个keyz

02:09:22.000 --> 02:09:23.000
keyz为啥呢

02:09:23.000 --> 02:09:25.000
为那个master riddle

02:09:25.000 --> 02:09:27.000
给一个随机数

02:09:27.000 --> 02:09:30.980
给个随机数

02:09:30.980 --> 02:09:31.980
下面一个按钮

02:09:32.980 --> 02:09:33.980
点击改变

02:09:33.980 --> 02:09:34.980
点击更新

02:09:34.980 --> 02:09:35.980
我主要是更新状态

02:09:35.980 --> 02:09:36.980
让它重新圈了

02:09:38.980 --> 02:09:40.980
主要是起到更新的作用

02:09:41.980 --> 02:09:42.980
啥都不写

02:09:42.980 --> 02:09:43.980
主要是为它重新

02:09:43.980 --> 02:09:44.980
为了让它重新圈了

02:09:45.980 --> 02:09:46.980
好

02:09:46.980 --> 02:09:47.980
咱们看一下

02:09:49.980 --> 02:09:50.980
说什么问题

02:09:50.980 --> 02:09:51.980
他说

02:09:51.980 --> 02:09:54.980
your randomness should have a return statement

02:09:54.980 --> 02:09:55.980
这里没有return

02:09:59.440 --> 02:10:00.440
好大家看一下

02:10:00.440 --> 02:10:01.440
一开始新建了

02:10:01.440 --> 02:10:02.440
这个

02:10:02.440 --> 02:10:03.440
这个

02:10:03.440 --> 02:10:04.440
组建

02:10:04.440 --> 02:10:05.440
没问题吧

02:10:05.440 --> 02:10:06.440
我们每次点击你看

02:10:07.440 --> 02:10:09.440
每次都是卸杂新建

02:10:09.440 --> 02:10:10.440
卸杂新建

02:10:10.440 --> 02:10:11.440
为什么呢

02:10:11.440 --> 02:10:12.440
看上去呢

02:10:12.440 --> 02:10:14.440
因为它结构是一样的

02:10:14.440 --> 02:10:16.440
但是由于它有不同的keyz

02:10:16.440 --> 02:10:18.440
每一次keyz是不是重新得到的

02:10:18.440 --> 02:10:19.440
重新得到的keyz

02:10:19.440 --> 02:10:21.440
由于每一次keyz不一样

02:10:21.440 --> 02:10:22.440
那么导致了

02:10:22.440 --> 02:10:23.440
它在对比的时候

02:10:23.440 --> 02:10:24.440
找不到对应的节点

02:10:24.440 --> 02:10:26.440
它找不到相同keyz的节点

02:10:26.440 --> 02:10:27.440
没有找到对比目标

02:10:27.440 --> 02:10:29.440
那么它之前的只能卸载掉

02:10:29.440 --> 02:10:30.440
就有keyz

02:10:30.440 --> 02:10:31.440
只能卸载掉

02:10:31.440 --> 02:10:34.440
新的有新的keyz的元素的新建

02:10:34.440 --> 02:10:36.440
说大家用这个keyz的时候

02:10:36.440 --> 02:10:37.440
一定要注意

02:10:37.440 --> 02:10:39.440
我们一看很多教程里边

02:10:39.440 --> 02:10:40.440
包括官方轮道里边

02:10:40.440 --> 02:10:42.440
都要说这么一个问题就是

02:10:42.440 --> 02:10:48.440
keyz应该在一个范围内唯一

02:10:48.440 --> 02:10:50.440
不是说全局唯一

02:10:50.440 --> 02:10:51.440
它不是id全局唯一

02:10:51.440 --> 02:10:52.440
它是在某一个范围内

02:10:52.440 --> 02:10:54.440
就是某一个兄弟元素之类

02:10:54.440 --> 02:10:56.440
通常是兄弟元素之类

02:10:56.440 --> 02:10:59.440
兄弟节点中

02:10:59.440 --> 02:11:00.440
应该唯一

02:11:00.440 --> 02:11:02.440
并且

02:11:02.440 --> 02:11:05.440
应该保持稳定

02:11:05.440 --> 02:11:07.440
保持稳定

02:11:07.440 --> 02:11:08.440
什么叫保持稳定呢

02:11:08.440 --> 02:11:09.440
也不能是这种

02:11:09.440 --> 02:11:11.440
一会儿这个字

02:11:11.440 --> 02:11:12.440
一会儿那个字

02:11:12.440 --> 02:11:13.440
应该是用什么

02:11:13.440 --> 02:11:15.440
一般情况下keyz会用id

02:11:15.440 --> 02:11:16.440
不要说这个组件

02:11:16.440 --> 02:11:17.440
它会绑进一条数据

02:11:17.440 --> 02:11:18.440
那么这个数据的id

02:11:18.440 --> 02:11:19.440
就是我一标时

02:11:19.440 --> 02:11:21.440
一般会做出它的keyz

02:11:21.440 --> 02:11:23.440
这个keyz没变

02:11:23.440 --> 02:11:25.440
顺便数据没变

02:11:25.440 --> 02:11:28.440
那就用同一个东西

02:11:28.440 --> 02:11:29.440
好 咱们再看一下

02:11:29.440 --> 02:11:31.440
keyz还有什么用

02:11:31.440 --> 02:11:32.440
keyz这一块

02:11:32.440 --> 02:11:34.440
它用处还蛮多的

02:11:34.440 --> 02:11:35.440
还有什么用呢

02:11:35.440 --> 02:11:37.440
这个keyz

02:11:37.440 --> 02:11:38.440
在渲染数

02:11:38.440 --> 02:11:39.440
就是数组节点的时候

02:11:39.440 --> 02:11:41.440
不是我们是有数组节点吗

02:11:41.440 --> 02:11:43.440
它要求里必须要有keyz

02:11:43.440 --> 02:11:45.440
为什么数组节点里面

02:11:45.440 --> 02:11:46.440
它要求里必须要有keyz呢

02:11:46.440 --> 02:11:47.440
它是这样子

02:11:47.440 --> 02:11:49.440
这样的一种情况

02:11:49.440 --> 02:11:51.440
我们再来一个例子

02:11:51.440 --> 02:11:52.440
看着啊

02:11:52.440 --> 02:11:53.440
这里边呢

02:11:53.440 --> 02:11:55.440
比方说我们有个数组

02:11:55.440 --> 02:11:59.440
这个数组里边

02:11:59.440 --> 02:12:01.440
就用ULLI

02:12:01.440 --> 02:12:03.440
ULLI

02:12:03.440 --> 02:12:06.750
外面套一个DIB

02:12:06.750 --> 02:12:07.750
UL

02:12:07.750 --> 02:12:08.750
AI呢

02:12:08.750 --> 02:12:09.750
它来自于一个数组

02:12:09.750 --> 02:12:10.750
数组呢

02:12:10.750 --> 02:12:11.750
我们放到State里边

02:12:11.750 --> 02:12:12.750
ARR

02:12:12.750 --> 02:12:13.750
它是个数组

02:12:13.750 --> 02:12:14.750
数组里边

02:12:14.750 --> 02:12:15.750
我们随便放一些数字

02:12:15.750 --> 02:12:17.750
随便放一些数字

02:12:17.750 --> 02:12:19.750
随便放一些数字

02:12:19.750 --> 02:12:20.750
OK

02:12:20.750 --> 02:12:21.750
那么这个数组呢

02:12:21.750 --> 02:12:22.750
我们可以通过

02:12:22.750 --> 02:12:24.750
ZStateARMAP出来

02:12:24.750 --> 02:12:25.750
对吧

02:12:25.750 --> 02:12:26.750
这个没什么好说的

02:12:26.750 --> 02:12:27.750
音色出来

02:12:27.750 --> 02:12:28.750
每个音色一个Li

02:12:28.750 --> 02:12:29.750
每个音色一个Li

02:12:29.750 --> 02:12:30.750
Li里边得到这个数字

02:12:30.750 --> 02:12:32.750
把数字显示到这个Li里边

02:12:32.750 --> 02:12:34.750
显示到这个Li里边

02:12:34.750 --> 02:12:35.750
没问题吧

02:12:36.750 --> 02:12:39.750
随便写个

02:12:39.750 --> 02:12:40.750
好

02:12:40.750 --> 02:12:41.750
然后呢

02:12:41.750 --> 02:12:42.750
我们干嘛呢

02:12:42.750 --> 02:12:43.750
把这个Li显示出来

02:12:43.750 --> 02:12:44.750
好

02:12:44.750 --> 02:12:47.450
现在告诉大家

02:12:47.450 --> 02:12:48.450
为什么它要

02:12:48.450 --> 02:12:50.450
让你有这个keyz

02:12:50.450 --> 02:12:51.450
我们这里

02:12:51.450 --> 02:12:52.450
为了

02:12:52.450 --> 02:12:53.450
编语分析

02:12:53.450 --> 02:12:54.450
我们这里数字写少一点

02:12:54.450 --> 02:12:55.450
两个

02:12:55.450 --> 02:12:56.450
先写两个

02:12:56.450 --> 02:12:57.450
三和五

02:12:57.450 --> 02:12:58.450
为什么它要让你有这个keyz

02:12:58.450 --> 02:12:59.450
看着

02:12:59.450 --> 02:13:01.450
如果你没有这个keyz的话

02:13:01.450 --> 02:13:03.450
那么它会导致一个问题

02:13:04.450 --> 02:13:06.450
这里是ULLI

02:13:06.450 --> 02:13:07.450
UL

02:13:07.450 --> 02:13:08.450
UL

02:13:10.450 --> 02:13:11.450
如果你没有keyz

02:13:11.450 --> 02:13:12.450
那么下面就有很多Li

02:13:12.450 --> 02:13:13.450
对吧

02:13:13.450 --> 02:13:14.450
现在有两个

02:13:14.450 --> 02:13:15.450
有两个

02:13:15.450 --> 02:13:16.450
很多Li

02:13:16.450 --> 02:13:17.450
第1个Li是多少

02:13:17.450 --> 02:13:18.450
是3

02:13:18.450 --> 02:13:19.450
第1个Li是多少

02:13:19.450 --> 02:13:20.450
是5

02:13:20.450 --> 02:13:22.450
如果没有keyz

02:13:22.450 --> 02:13:23.450
如果没有keyz

02:13:23.450 --> 02:13:24.450
会导致一个什么样的问题

02:13:24.450 --> 02:13:25.450
好

02:13:25.450 --> 02:13:26.450
一般情况下

02:13:26.450 --> 02:13:27.450
如果是手势渲染的话

02:13:27.450 --> 02:13:28.450
肯定不会有任何问题

02:13:28.450 --> 02:13:29.450
因为keyz

02:13:29.450 --> 02:13:30.450
它主要是做更新用的

02:13:30.450 --> 02:13:31.450
但是如果说

02:13:31.450 --> 02:13:32.450
你做了一个

02:13:32.450 --> 02:13:33.450
应用出来的

02:13:33.450 --> 02:13:34.450
你永远不更新吗

02:13:34.450 --> 02:13:35.450
永远不更新

02:13:35.450 --> 02:13:36.450
你写这个应用干嘛

02:13:36.450 --> 02:13:38.450
你还不如写进它一面算了

02:13:38.450 --> 02:13:40.450
所以说它肯定是要更新的

02:13:40.450 --> 02:13:41.450
你看着

02:13:41.450 --> 02:13:43.450
一更新要出麻烦了

02:13:43.450 --> 02:13:45.450
添加数字

02:13:45.450 --> 02:13:47.450
添加一个数字

02:13:47.450 --> 02:13:48.450
比方说

02:13:48.450 --> 02:13:49.450
我们添加的数字

02:13:49.450 --> 02:13:51.450
是在末尾

02:13:51.450 --> 02:13:53.450
往第1个

02:13:53.450 --> 02:13:55.450
向第1个

02:13:55.450 --> 02:13:56.450
远

02:13:56.450 --> 02:13:57.450
数组第1项

02:13:57.450 --> 02:13:59.450
数组第1项

02:13:59.450 --> 02:14:01.450
添加一个水积数

02:14:01.450 --> 02:14:03.450
添加水积数

02:14:03.450 --> 02:14:21.990
我们先把它写好

02:14:21.990 --> 02:14:22.990
写好再说

02:14:22.990 --> 02:14:24.990
这里onclick

02:14:24.990 --> 02:14:26.990
马上就看到这个问题了

02:14:29.620 --> 02:14:30.620
然后

02:14:30.620 --> 02:14:32.620
我们向第1个添加个水积数

02:14:32.620 --> 02:14:33.620
对吧

02:14:33.620 --> 02:14:35.620
我们先产生个水积数再说

02:14:35.620 --> 02:14:36.620
水积数n

02:14:36.620 --> 02:14:38.620
等于mys.riden

02:14:38.620 --> 02:14:40.620
乘1个1000

02:14:40.620 --> 02:14:41.620
乘1个1000

02:14:41.620 --> 02:14:43.620
这里用PoseInt

02:14:43.620 --> 02:14:44.620
PoseInt

02:14:44.620 --> 02:14:45.620
随便吧

02:14:45.620 --> 02:14:46.620
乘1个1000

02:14:46.620 --> 02:14:47.620
产生个这么个水积数

02:14:47.620 --> 02:14:49.620
把水积数加到第1下

02:14:49.620 --> 02:14:50.620
zsetState

02:14:51.620 --> 02:14:52.620
加到第1项

02:14:52.620 --> 02:14:54.620
ar等于一个新的数组

02:14:54.620 --> 02:14:55.620
第1项是n

02:14:55.620 --> 02:14:57.620
后边把这个数组展开

02:14:57.620 --> 02:14:58.620
之前的数据展开

02:14:58.620 --> 02:14:59.620
State

02:14:59.620 --> 02:15:00.620
ar

02:15:00.620 --> 02:15:01.620
没问题吧

02:15:01.620 --> 02:15:02.620
重新改变状态

02:15:02.620 --> 02:15:03.620
加一个水积数字

02:15:03.620 --> 02:15:04.620
再重新渲染

02:15:04.620 --> 02:15:05.620
看一下

02:15:05.620 --> 02:15:09.130
你看功能没有任何问题

02:15:09.130 --> 02:15:11.130
功能是没有任何问题的

02:15:11.130 --> 02:15:13.130
那他凭什么会报这个错呢

02:15:13.130 --> 02:15:15.130
他是觉得渲染效率

02:15:15.130 --> 02:15:17.130
现在低得不得了

02:15:17.130 --> 02:15:19.130
为什么说渲染效率低得不得了

02:15:19.130 --> 02:15:20.130
你看着

02:15:20.130 --> 02:15:21.130
一开始是35

02:15:22.130 --> 02:15:24.130
然后现在我们点一下

02:15:24.130 --> 02:15:26.130
是不是加了一下660

02:15:26.130 --> 02:15:27.130
而且加的是第1项

02:15:27.130 --> 02:15:28.130
加的是第1项

02:15:28.130 --> 02:15:29.130
于是

02:15:29.130 --> 02:15:30.130
他的新节点

02:15:30.130 --> 02:15:31.130
前面是不是一样的

02:15:31.130 --> 02:15:32.130
前面都是一样的

02:15:32.130 --> 02:15:33.130
没什么好说的

02:15:33.130 --> 02:15:34.130
所以说

02:15:34.130 --> 02:15:35.130
如果你不涉及到数组的话

02:15:35.130 --> 02:15:36.130
一般他不会

02:15:36.130 --> 02:15:37.130
他不会给你报这个警告的

02:15:37.130 --> 02:15:38.130
关键是数组

02:15:38.130 --> 02:15:40.130
因为数组他有可能会变化

02:15:40.130 --> 02:15:41.130
关键是数组他会变化

02:15:41.130 --> 02:15:42.130
还会加一下

02:15:42.130 --> 02:15:43.130
多一下

02:15:43.130 --> 02:15:44.130
好

02:15:44.130 --> 02:15:46.130
那么现在他的li变成这个样子了

02:15:46.130 --> 02:15:47.130
li的里边

02:15:47.130 --> 02:15:48.130
实际上是一个文本节点的

02:15:48.130 --> 02:15:49.130
文本节点3

02:15:49.130 --> 02:15:50.130
文本节点5

02:15:50.130 --> 02:15:51.130
然后这个东西不说了

02:15:51.130 --> 02:15:52.130
我来看一下吧

02:15:52.130 --> 02:15:54.130
他实际上会变成这样子

02:15:54.130 --> 02:15:55.130
多少数字

02:15:55.130 --> 02:15:56.130
660

02:15:56.130 --> 02:15:57.130
来吧

02:15:57.130 --> 02:15:58.130
你对比一下

02:16:01.130 --> 02:16:02.130
他和谁对比

02:16:02.130 --> 02:16:03.130
没有keyz

02:16:03.130 --> 02:16:04.130
现在没有keyz

02:16:04.130 --> 02:16:06.130
他和谁对比

02:16:06.130 --> 02:16:07.130
他里面

02:16:07.130 --> 02:16:08.130
这是文本节点

02:16:08.130 --> 02:16:09.130
我们记住就行了

02:16:09.130 --> 02:16:10.130
这是文本节点

02:16:10.130 --> 02:16:11.130
他和谁对比

02:16:11.130 --> 02:16:12.130
是不是跟他的对比

02:16:12.130 --> 02:16:13.130
是不是要改

02:16:13.130 --> 02:16:14.130
是不是要改

02:16:14.130 --> 02:16:15.130
对吧

02:16:16.130 --> 02:16:18.130
是不是他要到时候记录

02:16:18.130 --> 02:16:19.130
记录什么

02:16:19.130 --> 02:16:22.130
第一个li的文本

02:16:22.130 --> 02:16:24.130
第一个li的文本

02:16:24.130 --> 02:16:27.130
修改为660

02:16:27.130 --> 02:16:28.130
他会这样记录

02:16:28.130 --> 02:16:29.130
好然后对比

02:16:29.130 --> 02:16:30.130
第二个

02:16:30.130 --> 02:16:31.130
他跟谁对比

02:16:31.130 --> 02:16:32.130
说跟他的对比

02:16:32.130 --> 02:16:33.130
你对比出来

02:16:33.130 --> 02:16:34.130
是不是他要记录

02:16:34.130 --> 02:16:36.130
第二个li的文本

02:16:36.130 --> 02:16:39.130
修改为3

02:16:39.130 --> 02:16:40.130
然后第三个给谁对比

02:16:40.130 --> 02:16:41.130
他跟

02:16:41.130 --> 02:16:42.130
不存在的对比

02:16:42.130 --> 02:16:44.130
不存在是不是要新建

02:16:44.130 --> 02:16:48.130
新建li文本为5

02:16:48.130 --> 02:16:50.130
到时候他对真实的动物对象

02:16:50.130 --> 02:16:51.130
做改动

02:16:51.130 --> 02:16:52.130
他要出这么些改动

02:16:52.130 --> 02:16:53.130
做三个改动

02:16:53.130 --> 02:16:54.130
你觉得三个改动没多少

02:16:54.130 --> 02:16:55.130
那这个数据一千项

02:16:55.130 --> 02:16:56.130
一万项的

02:16:56.130 --> 02:16:57.130
这是一万项的数据

02:16:57.130 --> 02:16:58.130
一万的数据

02:16:58.130 --> 02:16:59.130
第一项加了一个

02:16:59.130 --> 02:17:00.130
你是不是疑似内推

02:17:00.130 --> 02:17:01.130
是不是可以

02:17:01.130 --> 02:17:02.130
会导致很多很多地方

02:17:02.130 --> 02:17:03.130
都要做改动

02:17:03.130 --> 02:17:05.130
他要疑似改动

02:17:05.130 --> 02:17:07.130
这就是为什么要keyz

02:17:07.130 --> 02:17:08.130
因为他这样子

02:17:08.130 --> 02:17:09.130
往前面一加

02:17:09.130 --> 02:17:10.130
往后边一加

02:17:10.130 --> 02:17:11.130
都不会有问题

02:17:11.130 --> 02:17:12.130
往后边一加不会有问题

02:17:12.130 --> 02:17:13.130
但是你没有办法

02:17:13.130 --> 02:17:14.130
保证这个数据

02:17:14.130 --> 02:17:15.130
里面他是怎么变化的

02:17:15.130 --> 02:17:16.130
所以说

02:17:16.130 --> 02:17:17.130
你往前面一加一加

02:17:17.130 --> 02:17:20.130
你会发现问题就出现了

02:17:20.130 --> 02:17:21.130
本来我只加了一项

02:17:21.130 --> 02:17:23.130
你新建个节点就完了

02:17:23.130 --> 02:17:24.130
但是没办法

02:17:24.130 --> 02:17:25.130
他对比的时候

02:17:25.130 --> 02:17:26.130
他很傻

02:17:26.130 --> 02:17:27.130
他不知道

02:17:27.130 --> 02:17:28.130
他怎么知道你这个

02:17:28.130 --> 02:17:29.130
这个节点就是

02:17:29.130 --> 02:17:31.130
这个节点是新的节点

02:17:31.130 --> 02:17:32.130
根本就不知道

02:17:32.130 --> 02:17:33.130
他不知道这个东西

02:17:33.130 --> 02:17:34.130
跟这个东西是一样的

02:17:34.130 --> 02:17:35.130
是不一样的

02:17:35.130 --> 02:17:36.130
他不知道

02:17:36.130 --> 02:17:37.130
他认为就是之前的一个节点

02:17:37.130 --> 02:17:38.130
他重用

02:17:38.130 --> 02:17:40.130
导致了这样的问题

02:17:40.130 --> 02:17:41.130
所以说

02:17:41.130 --> 02:17:42.130
这样子一来

02:17:42.130 --> 02:17:43.130
那么就会导致

02:17:43.130 --> 02:17:44.130
后边的元素

02:17:44.130 --> 02:17:46.130
去产生大量的改动

02:17:46.130 --> 02:17:47.130
而这些改动

02:17:47.130 --> 02:17:48.130
这些改动都是真实的

02:17:48.130 --> 02:17:49.130
动物对象改动

02:17:49.130 --> 02:17:52.130
这个效率是很夸张的

02:17:52.130 --> 02:17:54.130
所以说为了让他知道

02:17:54.130 --> 02:17:55.130
这个Li就等

02:17:55.130 --> 02:17:56.130
就是这个Li

02:17:56.130 --> 02:17:57.130
去对应到这个

02:17:57.130 --> 02:17:58.130
这个东西去对应到这个

02:17:58.130 --> 02:18:00.130
因此我们加keyz

02:18:00.130 --> 02:18:02.130
我们加keyz

02:18:02.130 --> 02:18:03.130
正的keyz

02:18:03.130 --> 02:18:04.130
比方说

02:18:04.130 --> 02:18:05.130
比方就是数字

02:18:05.130 --> 02:18:06.130
当然这里

02:18:06.130 --> 02:18:07.130
应该一般来说

02:18:07.130 --> 02:18:08.130
就用id

02:18:08.130 --> 02:18:11.130
就用这个数字

02:18:11.130 --> 02:18:13.130
那么现在就不一样了

02:18:13.130 --> 02:18:14.130
现在不一样了

02:18:14.130 --> 02:18:15.130
你看着

02:18:15.130 --> 02:18:16.130
现在我们再加一下

02:18:16.130 --> 02:18:17.130
284

02:18:17.130 --> 02:18:19.130
这个284

02:18:19.130 --> 02:18:21.130
因为他有keyz

02:18:21.130 --> 02:18:22.130
对吧

02:18:22.130 --> 02:18:23.130
他的keyz多少

02:18:23.130 --> 02:18:24.130
3

02:18:24.130 --> 02:18:25.130
他的keyz多少

02:18:25.130 --> 02:18:26.130
5

02:18:26.130 --> 02:18:27.130
那么他的keyz多少

02:18:27.130 --> 02:18:29.130
284

02:18:29.130 --> 02:18:30.130
他的keyz多少

02:18:30.130 --> 02:18:31.130
3

02:18:32.130 --> 02:18:33.130
他的keyz多少

02:18:33.130 --> 02:18:34.130
5

02:18:37.130 --> 02:18:38.130
他这样的keyz

02:18:38.130 --> 02:18:39.130
那么现在对比的

02:18:39.130 --> 02:18:40.130
之所以就不一样了

02:18:40.130 --> 02:18:41.130
首先

02:18:41.130 --> 02:18:42.130
他看到这个

02:18:42.130 --> 02:18:43.130
就现在有这个keyz

02:18:43.130 --> 02:18:44.130
对吧

02:18:44.130 --> 02:18:45.130
他去寻找新界点里面

02:18:45.130 --> 02:18:46.130
有没有对应keyz的东西

02:18:46.130 --> 02:18:47.130
有

02:18:47.130 --> 02:18:49.130
ok他跟他对比

02:18:49.130 --> 02:18:50.130
无变化

02:18:50.130 --> 02:18:51.130
看到没

02:18:51.130 --> 02:18:52.130
有keyz的话

02:18:52.130 --> 02:18:54.130
无变化

02:18:54.130 --> 02:18:55.130
他的keyz跟他的keyz比

02:18:55.130 --> 02:18:56.130
没有变化

02:18:56.130 --> 02:18:57.130
啥都不做

02:18:58.130 --> 02:18:59.130
啥都不做

02:18:59.130 --> 02:19:00.130
当然他要不要进入

02:19:00.130 --> 02:19:01.130
生命周期流程

02:19:01.130 --> 02:19:02.130
要但是他不会修改

02:19:02.130 --> 02:19:03.130
真实的动物对象

02:19:03.130 --> 02:19:05.130
不要说因为keyz相同

02:19:05.130 --> 02:19:06.130
他连生命周期都不走

02:19:06.130 --> 02:19:07.130
什么suit

02:19:07.130 --> 02:19:08.130
computers

02:19:08.130 --> 02:19:09.130
都不走不可能的

02:19:09.130 --> 02:19:10.130
他只是说

02:19:10.130 --> 02:19:11.130
不去改动真实的动物对象

02:19:11.130 --> 02:19:12.130
我们这里说

02:19:12.130 --> 02:19:13.130
真实的动物对象

02:19:13.130 --> 02:19:14.130
改动是比较耗费效率的

02:19:14.130 --> 02:19:15.130
那如果你不希望

02:19:15.130 --> 02:19:16.130
他走生命周期流程的话

02:19:16.130 --> 02:19:17.130
你自己去写什么

02:19:17.130 --> 02:19:18.130
存住键

02:19:18.130 --> 02:19:19.130
peo components

02:19:19.130 --> 02:19:20.130
直接去去重写

02:19:20.130 --> 02:19:21.130
suit components

02:19:21.130 --> 02:19:22.130
update的函数

02:19:22.130 --> 02:19:23.130
自己去重写

02:19:23.130 --> 02:19:24.130
他不管你

02:19:24.130 --> 02:19:25.130
他只是说

02:19:25.130 --> 02:19:26.130
不渲染真实的动物对象

02:19:26.130 --> 02:19:28.130
不重新去做这个操作了

02:19:28.130 --> 02:19:29.130
好那么这里

02:19:29.130 --> 02:19:30.130
keyz找不到对吧

02:19:30.130 --> 02:19:31.130
keyz找不到

02:19:31.130 --> 02:19:32.130
那么keyz找不到的话

02:19:32.130 --> 02:19:33.130
那么这里

02:19:33.130 --> 02:19:34.130
是不是要新建

02:19:34.130 --> 02:19:35.130
他只记住一个

02:19:35.130 --> 02:19:36.130
新建li

02:19:36.130 --> 02:19:37.130
内容

02:19:37.130 --> 02:19:38.130
284

02:19:38.130 --> 02:19:39.130
对吧

02:19:39.130 --> 02:19:40.130
所以说

02:19:40.130 --> 02:19:41.130
keyz

02:19:41.130 --> 02:19:42.130
它的影响

02:19:42.130 --> 02:19:43.130
它的影响是什么

02:19:43.130 --> 02:19:44.130
影响的是

02:19:44.130 --> 02:19:45.130
真实的动物对象

02:19:45.130 --> 02:19:46.130
你看我点击

02:19:46.130 --> 02:19:47.130
你看

02:19:47.130 --> 02:19:48.130
后面的li

02:19:48.130 --> 02:19:49.130
它没有发生变化

02:19:49.130 --> 02:19:50.130
你看动画效果

02:19:50.130 --> 02:19:51.130
是没发生变化的

02:19:51.130 --> 02:19:52.130
看到没

02:19:52.130 --> 02:19:53.130
是没发生变化的

02:19:53.130 --> 02:19:54.130
后面都没动

02:19:54.130 --> 02:19:55.130
所以说

02:19:55.130 --> 02:19:57.130
它会影响到真实的动物的改动

02:19:57.130 --> 02:19:58.130
但是keyz

02:19:58.130 --> 02:19:59.130
不在真实的动物里边

02:19:59.130 --> 02:20:00.130
很多人认为

02:20:00.130 --> 02:20:02.130
keyz是放到一个真实的动物里边

02:20:02.130 --> 02:20:03.130
不是的

02:20:03.130 --> 02:20:04.130
它是在哪

02:20:04.130 --> 02:20:05.130
它是在节点对象里边

02:20:05.130 --> 02:20:07.130
keyz是放到这儿的

02:20:07.130 --> 02:20:09.130
它比较的是节点对象

02:20:09.130 --> 02:20:10.130
节点对象产生差异过后

02:20:10.130 --> 02:20:12.130
那么它才会生成一个差异

02:20:12.130 --> 02:20:14.130
改变真实动物对象

02:20:14.130 --> 02:20:16.130
它是这么一种操作的过程

02:20:16.130 --> 02:20:17.130
那么比方说

02:20:17.130 --> 02:20:18.130
刚才我们把keyz再去了

02:20:18.130 --> 02:20:19.130
再看一下

02:20:19.130 --> 02:20:21.130
再看一下keyz

02:20:21.130 --> 02:20:22.130
保存

02:20:22.130 --> 02:20:24.130
那么现在肯定要报警告

02:20:24.130 --> 02:20:25.130
你看一下

02:20:25.130 --> 02:20:26.130
现在li

02:20:26.130 --> 02:20:27.130
点击

02:20:27.130 --> 02:20:28.130
你看li是不是全部散动了

02:20:28.130 --> 02:20:30.130
说明之前li都消失了

02:20:30.130 --> 02:20:31.130
要全部重新建

02:20:31.130 --> 02:20:32.130
看到没有

02:20:32.130 --> 02:20:33.130
不是全部重新建

02:20:33.130 --> 02:20:34.130
都要重新改动

02:20:34.130 --> 02:20:35.130
都会发生改动

02:20:35.130 --> 02:20:36.130
这些li

02:20:37.130 --> 02:20:38.130
所以说

02:20:38.130 --> 02:20:39.130
keyz

02:20:39.130 --> 02:20:40.130
它的作用

02:20:40.130 --> 02:20:41.130
不是说功能上的

02:20:41.130 --> 02:20:43.130
它的作用是

02:20:43.130 --> 02:20:44.130
帮我们

02:20:44.130 --> 02:20:46.130
一方面是有些

02:20:46.130 --> 02:20:47.130
有些组件保持它的

02:20:47.130 --> 02:20:48.130
对象

02:20:48.130 --> 02:20:49.130
保持组件对象

02:20:49.130 --> 02:20:50.130
相同keyz

02:20:50.130 --> 02:20:52.130
比方这里不是li

02:20:52.130 --> 02:20:53.130
是一个组件

02:20:53.130 --> 02:20:54.130
一个组件

02:20:54.130 --> 02:20:55.130
比方内组件

02:20:55.130 --> 02:20:57.130
那么有相同keyz的组件

02:20:57.130 --> 02:20:58.130
那么他们的对象是通用的

02:20:58.130 --> 02:21:00.130
还不会去重新产生对象

02:21:00.130 --> 02:21:02.130
它对象可以通用的

02:21:02.130 --> 02:21:03.130
保留之前的状态

02:21:03.130 --> 02:21:04.130
可以通用的

02:21:05.130 --> 02:21:06.130
对吧

02:21:06.130 --> 02:21:07.130
那么

02:21:07.130 --> 02:21:08.130
keyz

02:21:08.130 --> 02:21:09.130
它主要是起这么一个作用

02:21:09.130 --> 02:21:10.130
就是

02:21:10.130 --> 02:21:12.130
关键是来关联两个节点

02:21:12.130 --> 02:21:13.130
它到时候要对比节点

02:21:13.130 --> 02:21:14.130
要完成更新

02:21:14.130 --> 02:21:16.130
它必须要找到对比的节点

02:21:16.130 --> 02:21:17.130
它主要是为了

02:21:17.130 --> 02:21:18.130
让我们帮我们找到

02:21:18.130 --> 02:21:20.130
你要跟哪个节点进行对比

02:21:20.130 --> 02:21:21.130
它在数组里面

02:21:21.130 --> 02:21:22.130
特别特别有用

02:21:22.130 --> 02:21:23.130
特别有用

02:21:24.130 --> 02:21:25.130
好吧

02:21:25.130 --> 02:21:26.130
这是关于keyz

02:21:26.130 --> 02:21:27.130
好

02:21:27.130 --> 02:21:28.130
最后我们再来举个例子

02:21:28.130 --> 02:21:29.130
就结束本节课了

02:21:29.130 --> 02:21:30.130
这个本节课

02:21:30.130 --> 02:21:31.130
时间好长

02:21:31.130 --> 02:21:32.130
再举个例子

02:21:32.130 --> 02:21:33.130
有多一个组件

02:21:34.130 --> 02:21:35.130
写个内组件

02:21:36.130 --> 02:21:37.130
看不

02:21:39.130 --> 02:21:41.130
还是跟keyz相关的

02:21:41.130 --> 02:21:42.130
还是跟keyz相关的

02:21:43.130 --> 02:21:44.130
好

02:21:44.130 --> 02:21:45.130
这里我们把拯命东西

02:21:45.130 --> 02:21:46.130
函数放着

02:21:46.130 --> 02:21:47.130
它有个状态

02:21:48.130 --> 02:21:49.130
状态里面有个n

02:21:49.130 --> 02:21:50.130
数字n

02:21:50.130 --> 02:21:52.130
数字n一开始是1

02:21:52.130 --> 02:21:53.130
然后这个组件里面

02:21:53.130 --> 02:21:54.130
有个div

02:21:54.130 --> 02:21:55.130
div

02:21:55.130 --> 02:21:57.130
div里面有一个

02:21:57.130 --> 02:21:58.130
数字

02:21:59.130 --> 02:22:01.130
来自于zstatsn

02:22:01.130 --> 02:22:02.130
好

02:22:03.130 --> 02:22:04.130
加数字

02:22:04.130 --> 02:22:05.130
onclick

02:22:05.130 --> 02:22:06.130
这个很简单

02:22:06.130 --> 02:22:07.130
很简单

02:22:08.130 --> 02:22:09.130
当我们点加的时候

02:22:09.130 --> 02:22:10.130
zstats

02:22:10.130 --> 02:22:12.130
把n的值

02:22:13.130 --> 02:22:14.130
设置为

02:22:14.130 --> 02:22:15.130
当前的n

02:22:16.130 --> 02:22:18.130
n-1

02:22:18.130 --> 02:22:19.130
当前n-1

02:22:20.130 --> 02:22:21.130
好

02:22:21.130 --> 02:22:22.130
这个没问题吧

02:22:22.130 --> 02:22:23.130
那么app里面

02:22:23.130 --> 02:22:24.130
很简单

02:22:24.130 --> 02:22:25.130
就去用这个

02:22:25.130 --> 02:22:26.130
用这个组件

02:22:27.130 --> 02:22:28.130
com

02:22:28.130 --> 02:22:29.130
com

02:22:29.130 --> 02:22:30.130
用这个组件

02:22:30.130 --> 02:22:31.130
就完成了

02:22:31.130 --> 02:22:32.130
保存

02:22:32.130 --> 02:22:33.130
看一下

02:22:33.130 --> 02:22:34.130
这没什么好说的

02:22:35.130 --> 02:22:36.130
没什么好说的

02:22:37.130 --> 02:22:38.130
那么现在

02:22:39.130 --> 02:22:41.130
之所以这个组件的状态

02:22:41.130 --> 02:22:42.130
它能保留

02:22:42.130 --> 02:22:44.130
是因为每一次更新的时候

02:22:44.130 --> 02:22:45.130
更新的时候

02:22:45.130 --> 02:22:46.130
它们都是同一个组件

02:22:46.130 --> 02:22:47.130
同一个节点

02:22:47.130 --> 02:22:48.130
所以它们状态能保留

02:22:48.130 --> 02:22:50.130
然后现在我们做这么一件事

02:22:50.130 --> 02:22:51.130
这个stats里面

02:22:53.130 --> 02:22:54.130
我还用数组吗

02:22:54.130 --> 02:22:55.130
还是用啥

02:22:58.130 --> 02:23:00.130
我们数组都来用一下

02:23:01.130 --> 02:23:02.130
好

02:23:03.130 --> 02:23:04.130
这个数组里边

02:23:04.130 --> 02:23:06.130
它里边有一些complay

02:23:07.130 --> 02:23:08.130
数组里边有一些complay

02:23:08.130 --> 02:23:09.130
没问题吧

02:23:09.130 --> 02:23:10.130
它里面装的是对象

02:23:10.130 --> 02:23:11.130
有些complay

02:23:11.130 --> 02:23:12.130
OK

02:23:12.130 --> 02:23:13.130
我们直接把这个数组渲染进来

02:23:14.130 --> 02:23:15.130
放一个UL

02:23:16.130 --> 02:23:17.130
UL吗

02:23:17.130 --> 02:23:18.130
UL里边

02:23:21.130 --> 02:23:22.130
把这个数组

02:23:22.130 --> 02:23:23.130
直接渲染进来

02:23:24.130 --> 02:23:25.130
AR2

02:23:27.130 --> 02:23:28.130
LIS

02:23:28.130 --> 02:23:29.130
LIS

02:23:30.130 --> 02:23:31.130
然后

02:23:32.130 --> 02:23:33.130
ZStats

02:23:34.130 --> 02:23:35.130
AR2

02:23:36.130 --> 02:23:37.130
生成一个Li

02:23:37.130 --> 02:23:38.130
生成个Li

02:23:39.130 --> 02:23:41.820
Li

02:23:41.820 --> 02:23:42.820
Li里边有啥呢

02:23:42.820 --> 02:23:43.820
有

02:23:45.820 --> 02:23:46.820
这个

02:23:46.820 --> 02:23:48.820
把它里边的那个节点放进来

02:23:48.820 --> 02:23:49.820
它们数组的每一项

02:23:49.820 --> 02:23:50.820
不就是个节点吗

02:23:50.820 --> 02:23:51.820
把它里边的节点放进来

02:23:52.820 --> 02:23:53.820
OK形成这么一种结构

02:23:54.820 --> 02:23:55.820
没问题吧

02:23:55.820 --> 02:23:56.820
或者是

02:23:56.820 --> 02:23:57.820
算了算了

02:23:57.820 --> 02:23:58.820
我用这种方式

02:23:58.820 --> 02:23:59.820
大家可能要晕

02:23:59.820 --> 02:24:00.820
容易晕

02:24:01.820 --> 02:24:02.820
那么这样吧

02:24:02.820 --> 02:24:03.820
我就这么一个数组

02:24:03.820 --> 02:24:04.820
就这么一个数组

02:24:04.820 --> 02:24:05.820
OK

02:24:05.820 --> 02:24:06.820
这个数组里边

02:24:06.820 --> 02:24:07.820
我们这里就不用什么UL了

02:24:07.820 --> 02:24:08.820
用DIV

02:24:08.820 --> 02:24:10.820
DIV里边就直接放这个数组得了

02:24:10.820 --> 02:24:11.820
LIS

02:24:12.820 --> 02:24:13.820
AR

02:24:13.820 --> 02:24:14.820
直接放这个数组得了

02:24:14.820 --> 02:24:15.820
保存

02:24:15.820 --> 02:24:16.820
你看一下

02:24:17.820 --> 02:24:18.820
现在没问题

02:24:18.820 --> 02:24:19.820
没问题

02:24:19.820 --> 02:24:21.820
那么现在我们下面再加个按钮

02:24:22.820 --> 02:24:23.820
添加一项

02:24:23.820 --> 02:24:24.820
添加一项

02:24:25.820 --> 02:24:26.820
onclick

02:24:27.820 --> 02:24:28.820
我现在没有写key

02:24:29.820 --> 02:24:30.820
没有写key

02:24:30.820 --> 02:24:31.820
添加一项

02:24:31.820 --> 02:24:32.820
然后添加什么

02:24:32.820 --> 02:24:34.820
就是zset state

02:24:35.820 --> 02:24:36.820
然后这个AR

02:24:36.820 --> 02:24:37.820
等于什么

02:24:37.820 --> 02:24:39.820
等于一个新的complay

02:24:39.820 --> 02:24:41.820
一个新的complay

02:24:43.820 --> 02:24:44.820
complay

02:24:44.820 --> 02:24:46.820
然后后面展开

02:24:47.820 --> 02:24:48.820
AR

02:24:48.820 --> 02:24:49.820
把之前的数组展开

02:24:49.820 --> 02:24:50.820
加到第一项

02:24:50.820 --> 02:24:51.820
你看会有什么样的问题

02:24:54.140 --> 02:24:55.140
好像没什么问题

02:24:55.140 --> 02:24:56.140
添加一项

02:24:58.140 --> 02:24:59.140
都加了

02:24:59.140 --> 02:25:00.140
对了

02:25:00.140 --> 02:25:01.140
对了

02:25:01.140 --> 02:25:02.140
对了

02:25:02.140 --> 02:25:03.140
现在的问题很怪

02:25:03.140 --> 02:25:04.140
明明我添加的是第一项

02:25:04.140 --> 02:25:05.140
你看看

02:25:05.140 --> 02:25:06.140
我添加的是第一项

02:25:06.140 --> 02:25:07.140
怎么跑的

02:25:07.140 --> 02:25:08.140
好像感觉是添加最后一项

02:25:08.140 --> 02:25:09.140
这怎么回事呢

02:25:10.140 --> 02:25:12.140
就是keyz倒的鬼

02:25:13.140 --> 02:25:14.140
他怎么回事呢

02:25:14.140 --> 02:25:15.140
他这样子

02:25:15.140 --> 02:25:17.140
一开始里边不是有两个complay

02:25:17.140 --> 02:25:18.140
对吧

02:25:18.140 --> 02:25:19.140
他没有keyz

02:25:19.140 --> 02:25:20.140
complay

02:25:20.140 --> 02:25:21.140
他没有keyz

02:25:23.640 --> 02:25:24.640
看着

02:25:24.640 --> 02:25:25.640
明明添加的是第一项

02:25:25.640 --> 02:25:26.640
他没有keyz

02:25:27.640 --> 02:25:28.640
那么

02:25:28.640 --> 02:25:29.640
keyz没有

02:25:30.640 --> 02:25:31.640
那现在呢

02:25:31.640 --> 02:25:32.640
我们又加了

02:25:32.640 --> 02:25:33.640
又加了一项

02:25:33.640 --> 02:25:34.640
对吧

02:25:34.640 --> 02:25:35.640
加了一个新的complay

02:25:36.640 --> 02:25:37.640
那么之前的complay

02:25:37.640 --> 02:25:38.640
比方说

02:25:38.640 --> 02:25:39.640
比方说之前的complay

02:25:39.640 --> 02:25:41.640
数字一变成了2,3

02:25:41.640 --> 02:25:42.640
2,3,4

02:25:42.640 --> 02:25:43.640
2和4

02:25:43.640 --> 02:25:45.640
他的数字一变成了2

02:25:45.640 --> 02:25:46.640
和4

02:25:46.640 --> 02:25:48.640
一变成2和4

02:25:48.640 --> 02:25:50.640
那么我们现在新加入了一个complay

02:25:50.640 --> 02:25:51.640
加入了这

02:25:51.640 --> 02:25:53.640
加入了第一下

02:25:53.640 --> 02:25:54.640
那么后边呢

02:25:54.640 --> 02:25:56.640
本来是形成这么一种结构的

02:25:57.640 --> 02:25:59.640
本来我们的新的结构是这样子的

02:25:59.640 --> 02:26:00.640
对吧

02:26:00.640 --> 02:26:01.640
新的结构是这样子的

02:26:01.640 --> 02:26:02.640
应该是这样子的还对

02:26:02.640 --> 02:26:04.640
那么新加坡肯定是1对不对

02:26:04.640 --> 02:26:06.640
新加坡肯定是1

02:26:06.640 --> 02:26:07.640
但是呢

02:26:09.640 --> 02:26:10.640
他会做这么一个

02:26:10.640 --> 02:26:11.640
就是对比

02:26:11.640 --> 02:26:12.640
对比啥呢

02:26:12.640 --> 02:26:13.640
对比这两个组件

02:26:13.640 --> 02:26:14.640
他这个组件对比这个组件

02:26:14.640 --> 02:26:15.640
对吧

02:26:15.640 --> 02:26:16.640
他会把这个新加坡的组件

02:26:16.640 --> 02:26:17.640
对比这个组件

02:26:18.640 --> 02:26:20.640
这个一对比是不是同一个组件

02:26:20.640 --> 02:26:21.640
对吧

02:26:21.640 --> 02:26:22.640
同一个组件干嘛

02:26:22.640 --> 02:26:24.640
同一个组件是不是进入

02:26:24.640 --> 02:26:25.640
他的生命周期

02:26:25.640 --> 02:26:26.640
是吧

02:26:26.640 --> 02:26:27.640
重新渲染对吧

02:26:27.640 --> 02:26:28.640
重新了他的状态又没有变化

02:26:28.640 --> 02:26:29.640
他状态还是2啊

02:26:29.640 --> 02:26:30.640
你不说这里把状态变成1了

02:26:30.640 --> 02:26:31.640
不是的

02:26:31.640 --> 02:26:32.640
不是的

02:26:32.640 --> 02:26:34.640
他发现是同一个组件

02:26:34.640 --> 02:26:35.640
他发现是同一个组件

02:26:35.640 --> 02:26:37.640
他就会拥之前的那个对象

02:26:37.640 --> 02:26:39.640
拥之前的对象

02:26:39.640 --> 02:26:41.640
不是说要创建对象吗

02:26:41.640 --> 02:26:42.640
他就会重用之前的对象

02:26:42.640 --> 02:26:44.640
那之前的对象里面是不是2

02:26:44.640 --> 02:26:45.640
对不对

02:26:45.640 --> 02:26:46.640
于是那个新建的

02:26:46.640 --> 02:26:47.640
这个complay这个节点

02:26:47.640 --> 02:26:48.640
他里面的状态

02:26:48.640 --> 02:26:49.640
就拥的是之前的状态

02:26:49.640 --> 02:26:50.640
所以说他是2

02:26:50.640 --> 02:26:51.640
于是他是1

02:26:51.640 --> 02:26:52.640
他跟他一对比

02:26:52.640 --> 02:26:53.640
他重用他之前的对象

02:26:53.640 --> 02:26:55.640
是重新渲染吧

02:26:55.640 --> 02:26:57.640
重新渲染吧

02:26:57.640 --> 02:26:59.640
然后了这个玩意

02:26:59.640 --> 02:27:00.640
没有对吧

02:27:00.640 --> 02:27:01.640
没有这里

02:27:01.640 --> 02:27:03.640
这里才真的是新建

02:27:03.640 --> 02:27:04.640
新建那么这里是1

02:27:04.640 --> 02:27:05.640
看到没有

02:27:05.640 --> 02:27:06.640
他变成这个样子了

02:27:06.640 --> 02:27:09.640
加一项过后变成21了

02:27:09.640 --> 02:27:10.640
这不是我们想要的对吧

02:27:10.640 --> 02:27:11.640
那怎么办

02:27:11.640 --> 02:27:12.640
是不是用剃子

02:27:12.640 --> 02:27:14.640
让他知道这个组件对应这个

02:27:14.640 --> 02:27:15.640
这个组件对应这个

02:27:15.640 --> 02:27:16.640
对吧

02:27:16.640 --> 02:27:18.640
让他知道这个对应关系

02:27:18.640 --> 02:27:19.640
让他知道这个对应关系

02:27:19.640 --> 02:27:20.640
好

02:27:20.640 --> 02:27:22.640
那么怎么来用剃子呢

02:27:22.640 --> 02:27:23.640
困定是这里我没有id

02:27:23.640 --> 02:27:25.640
我没有id

02:27:28.640 --> 02:27:29.640
那这样吧

02:27:29.640 --> 02:27:31.640
这样我们这里写个id

02:27:31.640 --> 02:27:32.640
写个id

02:27:32.640 --> 02:27:33.640
n

02:27:33.640 --> 02:27:35.640
id

02:27:35.640 --> 02:27:36.640
id

02:27:36.640 --> 02:27:37.640
写个从1开始

02:27:37.640 --> 02:27:39.640
从1开始

02:27:39.640 --> 02:27:41.640
这里给他个keyz

02:27:41.640 --> 02:27:42.640
keyz

02:27:42.640 --> 02:27:43.640
id为1

02:27:43.640 --> 02:27:44.640
这里一开始给他keyz

02:27:44.640 --> 02:27:45.640
总之

02:27:45.640 --> 02:27:47.640
应该从数据库里面去读id

02:27:47.640 --> 02:27:48.640
在这里我没有id

02:27:48.640 --> 02:27:50.640
那么下一个id

02:27:50.640 --> 02:27:51.640
下一个id是3

02:27:52.640 --> 02:27:53.640
那么这里呢

02:27:53.640 --> 02:27:54.640
这个keyz

02:27:54.640 --> 02:27:55.640
所以可以写了

02:27:55.640 --> 02:27:56.640
写什么keyz

02:27:56.640 --> 02:27:57.640
写这个keyz

02:27:57.640 --> 02:27:58.640
keyz等于什么

02:27:58.640 --> 02:27:59.640
等于z

02:27:59.640 --> 02:28:00.640
那个是id

02:28:00.640 --> 02:28:01.640
state

02:28:01.640 --> 02:28:02.640
那个是id

02:28:02.640 --> 02:28:04.640
把下一个id给他

02:28:04.640 --> 02:28:06.640
就是用id来唯一区分

02:28:06.640 --> 02:28:07.640
然后呢

02:28:07.640 --> 02:28:09.640
除了设置这个数字之外

02:28:09.640 --> 02:28:10.640
再把id加1

02:28:10.640 --> 02:28:11.640
state

02:28:11.640 --> 02:28:12.640
那个是id

02:28:12.640 --> 02:28:13.640
加1

02:28:13.640 --> 02:28:15.640
这是那个是id

02:28:15.640 --> 02:28:16.640
对吧

02:28:16.640 --> 02:28:17.640
那么这样子可以保证

02:28:17.640 --> 02:28:19.640
每一个组件的id是不一样的

02:28:19.640 --> 02:28:20.640
是一个唯一的id

02:28:20.640 --> 02:28:22.640
并且是稳定的id

02:28:22.640 --> 02:28:23.640
那么看一下

02:28:23.640 --> 02:28:25.640
那现在就不一样了

02:28:25.640 --> 02:28:26.640
你看

02:28:26.640 --> 02:28:27.640
是不是正确了

02:28:27.640 --> 02:28:28.640
对吧

02:28:28.640 --> 02:28:30.640
是不是正确了

02:28:30.640 --> 02:28:31.640
为什么正确了

02:28:31.640 --> 02:28:32.640
现在的情况是这样子

02:28:32.640 --> 02:28:34.640
他的有个keyz

02:28:34.640 --> 02:28:36.640
他comp a里面

02:28:36.640 --> 02:28:38.640
比方说现在一开始

02:28:38.640 --> 02:28:39.640
我填到了2和4

02:28:39.640 --> 02:28:40.640
2和4

02:28:45.640 --> 02:28:46.640
填到2和4

02:28:46.640 --> 02:28:47.640
那么一开始

02:28:47.640 --> 02:28:48.640
他的keyz

02:28:48.640 --> 02:28:50.640
这里keyz是1

02:28:50.640 --> 02:28:52.640
这里keyz是2

02:28:52.640 --> 02:28:54.640
那么新创建的

02:28:54.640 --> 02:28:56.640
就是新创建的节点

02:28:56.640 --> 02:28:58.640
这个节点里面keyz是

02:28:58.640 --> 02:28:59.640
3

02:28:59.640 --> 02:29:00.640
那么这个节点

02:29:00.640 --> 02:29:02.640
keyz是

02:29:02.640 --> 02:29:04.640
keyz是

02:29:04.640 --> 02:29:05.640
2

02:29:05.640 --> 02:29:06.640
1

02:29:06.640 --> 02:29:07.640
这个keyz是

02:29:07.640 --> 02:29:08.640
2

02:29:08.640 --> 02:29:11.140
keyz是2

02:29:11.140 --> 02:29:12.140
对吧

02:29:12.140 --> 02:29:13.140
新创建的那个数组里面

02:29:13.140 --> 02:29:14.140
节点是不是这样子

02:29:14.140 --> 02:29:15.140
我们把新加入的一项keyz

02:29:15.140 --> 02:29:16.140
下一个keyz

02:29:16.140 --> 02:29:17.140
放到这

02:29:17.140 --> 02:29:18.140
放到第一下

02:29:18.140 --> 02:29:19.140
对比的时候

02:29:20.140 --> 02:29:21.140
没有

02:29:21.140 --> 02:29:22.140
没有就是新节点

02:29:22.140 --> 02:29:24.140
就是他变成新节点的

02:29:24.140 --> 02:29:26.140
于是他变成新节点的

02:29:29.140 --> 02:29:30.140
那么这里keyz相同

02:29:30.140 --> 02:29:31.140
是不是他对应到的2

02:29:31.140 --> 02:29:32.140
重复使用对象

02:29:32.140 --> 02:29:33.140
把之前的对象拿过来

02:29:33.140 --> 02:29:34.140
那么之前的状态里面

02:29:34.140 --> 02:29:35.140
是不是拿到了

02:29:35.140 --> 02:29:36.140
这些状态是2

02:29:36.140 --> 02:29:37.140
那么这个状态是不是拿到了

02:29:37.140 --> 02:29:39.140
使用重复的对象

02:29:39.140 --> 02:29:40.140
是

02:29:40.140 --> 02:29:41.140
对吧

02:29:41.140 --> 02:29:42.140
没问题吧

02:29:42.140 --> 02:29:43.140
OK

02:29:43.140 --> 02:29:44.140
那么这些东西就全部拿到了

02:29:44.140 --> 02:29:45.140
这就是

02:29:45.140 --> 02:29:46.140
这里

02:29:46.140 --> 02:29:48.140
解决这个bug的关键

02:29:48.140 --> 02:29:49.140
就是给keyz

02:29:49.140 --> 02:29:50.140
好

02:29:50.140 --> 02:29:52.140
这是数组的情况

02:29:52.140 --> 02:29:53.140
给数组的情况

02:29:53.140 --> 02:29:54.140
那么还有一种情况

02:29:54.140 --> 02:29:55.140
是这样子

02:29:55.140 --> 02:29:56.140
还有一种情况

02:29:56.140 --> 02:29:58.140
他不一定是数组

02:29:58.140 --> 02:29:59.140
在内组建里面

02:29:59.140 --> 02:30:00.140
也会发生这种情况

02:30:00.140 --> 02:30:01.140
比方说

02:30:01.140 --> 02:30:02.140
我们又有这么一个属性

02:30:02.140 --> 02:30:03.140
把一个复制一下

02:30:04.140 --> 02:30:05.140
要下去慢慢看

02:30:06.140 --> 02:30:07.140
这里呢

02:30:07.140 --> 02:30:08.140
isVisible

02:30:08.140 --> 02:30:09.140
isVisible

02:30:11.140 --> 02:30:12.140
是否显示force

02:30:15.140 --> 02:30:16.140
不显示

02:30:16.140 --> 02:30:17.140
那么现在呢

02:30:17.140 --> 02:30:18.140
我们这里

02:30:19.140 --> 02:30:21.140
做这样子的一个判定

02:30:21.140 --> 02:30:22.140
如果

02:30:23.140 --> 02:30:24.140
this

02:30:26.140 --> 02:30:27.140
想一想

02:30:27.140 --> 02:30:29.140
我该做什么样的一个

02:30:29.140 --> 02:30:30.140
判定

02:30:31.140 --> 02:30:32.140
该做什么样的判定

02:30:32.140 --> 02:30:33.140
这样子吧

02:30:33.140 --> 02:30:34.140
比方说

02:30:34.140 --> 02:30:36.140
我们又用到之前的那种写法

02:30:36.140 --> 02:30:37.140
如果

02:30:37.140 --> 02:30:39.140
isVisible

02:30:39.140 --> 02:30:41.140
如果它是可以显示的

02:30:41.140 --> 02:30:43.140
我返回的是一个div

02:30:44.140 --> 02:30:45.140
返回了这么一个div

02:30:46.140 --> 02:30:47.140
这个div里面

02:30:47.140 --> 02:30:49.140
显示了一个he

02:30:49.140 --> 02:30:50.140
标题

02:30:50.140 --> 02:30:51.140
button

02:30:53.140 --> 02:30:54.140
然后这里是

02:30:54.140 --> 02:30:55.140
显示

02:30:57.140 --> 02:30:58.140
映尝

02:30:58.140 --> 02:30:59.140
这里

02:30:59.140 --> 02:31:00.140
unclick

02:31:01.140 --> 02:31:02.140
我主要是说明这个问题

02:31:03.140 --> 02:31:05.140
this setState

02:31:06.140 --> 02:31:07.140
isVisible

02:31:07.140 --> 02:31:08.140
为什么

02:31:08.140 --> 02:31:09.140
为

02:31:10.140 --> 02:31:11.140
this去犯

02:31:12.140 --> 02:31:13.140
this

02:31:13.140 --> 02:31:14.140
State

02:31:14.140 --> 02:31:15.140
isVisible

02:31:15.140 --> 02:31:16.140
去犯

02:31:16.140 --> 02:31:18.140
那么显示映尝这个标题

02:31:18.140 --> 02:31:19.140
同时

02:31:19.140 --> 02:31:20.140
还有这么一个东西

02:31:20.140 --> 02:31:21.140
complay

02:31:21.140 --> 02:31:23.140
还有一个complay在这里

02:31:23.140 --> 02:31:27.820
ok

02:31:29.820 --> 02:31:31.820
如果它是要显示的话

02:31:31.820 --> 02:31:33.820
我们就显示多显示一个标题

02:31:33.820 --> 02:31:34.820
如果它不显示的话

02:31:34.820 --> 02:31:35.820
我们返回

02:31:36.820 --> 02:31:37.820
如果它不显示的话

02:31:37.820 --> 02:31:38.820
返回这个

02:31:39.820 --> 02:31:40.820
就没有这个标题

02:31:41.820 --> 02:31:42.820
好看一下

02:31:45.780 --> 02:31:46.780
显示

02:31:48.780 --> 02:31:49.780
还原了

02:31:49.780 --> 02:31:51.780
为什么会还原

02:31:51.780 --> 02:31:52.780
同样的问题

02:31:52.780 --> 02:31:53.780
同样的问题

02:31:54.780 --> 02:31:55.780
它到时候会把

02:31:55.780 --> 02:31:56.780
就是如果一开始

02:31:56.780 --> 02:31:57.780
一开始是不显示的

02:31:57.780 --> 02:31:58.780
对吧

02:31:58.780 --> 02:31:59.780
一开始是不显示的

02:31:59.780 --> 02:32:00.780
一开始运行的是这个

02:32:00.780 --> 02:32:01.780
对吧

02:32:01.780 --> 02:32:02.780
是这个节点

02:32:02.780 --> 02:32:03.780
一个complay

02:32:03.780 --> 02:32:04.780
一个button

02:32:04.780 --> 02:32:05.780
好一会要显示的时候

02:32:05.780 --> 02:32:06.780
是运行的这个

02:32:06.780 --> 02:32:07.780
它怎么比较了

02:32:07.780 --> 02:32:08.780
它是把这个ac跟谁比较

02:32:08.780 --> 02:32:09.780
是不跟它来比较

02:32:10.780 --> 02:32:11.780
对吧跟它来比较

02:32:11.780 --> 02:32:12.780
那ac跟它来比较

02:32:12.780 --> 02:32:13.780
肯定类型不一样

02:32:13.780 --> 02:32:14.780
于是

02:32:14.780 --> 02:32:15.780
怎么办

02:32:15.780 --> 02:32:16.780
新节点

02:32:16.780 --> 02:32:17.780
新节

02:32:17.780 --> 02:32:18.780
就节点

02:32:18.780 --> 02:32:19.780
卸载掉

02:32:19.780 --> 02:32:20.780
好然后这个

02:32:20.780 --> 02:32:21.780
这个跟谁比较

02:32:21.780 --> 02:32:22.780
跟button比较

02:32:22.780 --> 02:32:23.780
好那么

02:32:23.780 --> 02:32:24.780
是不是不一样

02:32:24.780 --> 02:32:25.780
不一样卸载

02:32:26.780 --> 02:32:27.780
button卸载

02:32:27.780 --> 02:32:28.780
它新建

02:32:28.780 --> 02:32:30.780
它又是新建的一个complay

02:32:30.780 --> 02:32:32.780
就会导致这样的问题

02:32:32.780 --> 02:32:33.780
你看那个

02:32:33.780 --> 02:32:34.780
新建了对吧

02:32:34.780 --> 02:32:35.780
显示

02:32:35.780 --> 02:32:36.780
你看就是新建卸载了

02:32:36.780 --> 02:32:37.780
对吧新建卸载了

02:32:37.780 --> 02:32:38.780
跟之前的安留是一样的

02:32:39.780 --> 02:32:40.780
好那么现在

02:32:40.780 --> 02:32:41.780
为了避免这种情况

02:32:41.780 --> 02:32:43.780
如果你代码写成这种格式

02:32:43.780 --> 02:32:44.780
又不太好改

02:32:44.780 --> 02:32:45.780
那么为了避免这种情况

02:32:45.780 --> 02:32:47.780
其实也可以用做法

02:32:47.780 --> 02:32:48.780
keyz

02:32:48.780 --> 02:32:49.780
keyz

02:32:49.780 --> 02:32:50.780
比较complay

02:32:50.780 --> 02:32:52.780
给它们一个相同的keyz

02:32:52.780 --> 02:32:53.780
那么这样子一来了

02:32:53.780 --> 02:32:54.780
它就保持稳定了

02:32:54.780 --> 02:32:55.780
它到时候找的时候

02:32:55.780 --> 02:32:57.780
就不是按照元素的顺序来找了

02:32:57.780 --> 02:32:59.780
它是按照同一个层级的keyz

02:32:59.780 --> 02:33:00.780
来进行寻找

02:33:00.780 --> 02:33:02.780
注意是同一个层级

02:33:02.780 --> 02:33:03.780
好那么一看

02:33:03.780 --> 02:33:04.780
是不是就没问题了

02:33:04.780 --> 02:33:05.780
对吧

02:33:05.780 --> 02:33:06.780
用keyz也可以达到同样的效果

02:33:06.780 --> 02:33:07.780
当然给这个button加keyz

02:33:07.780 --> 02:33:08.780
也可以达到同样的效果

02:33:08.780 --> 02:33:11.780
就避免了button重新建立

02:33:11.780 --> 02:33:12.780
这是对内组建的

02:33:12.780 --> 02:33:13.780
有的时候出现这种bug

02:33:13.780 --> 02:33:14.780
该怎么去解决

02:33:15.780 --> 02:33:16.780
好了

02:33:16.780 --> 02:33:17.780
咱们就讲完了

02:33:18.780 --> 02:33:21.780
这就是整个的渲染原理

02:33:21.780 --> 02:33:26.470
要么就是挂展新建的一个东西

02:33:26.470 --> 02:33:27.470
一个流程

02:33:27.470 --> 02:33:28.470
首次渲染

02:33:28.470 --> 02:33:29.470
要么就是更新

02:33:30.470 --> 02:33:32.470
更新就是触发了set state

02:33:32.470 --> 02:33:33.470
触发了更新

02:33:33.470 --> 02:33:34.470
或者是雕用Render

02:33:34.470 --> 02:33:35.470
触发更新是一样的

02:33:36.470 --> 02:33:37.470
更新的时候要做对比

02:33:37.470 --> 02:33:39.470
关键点在于什么呢

02:33:39.470 --> 02:33:40.470
关键点在于

02:33:40.470 --> 02:33:42.470
如何找到对比的目标

02:33:43.470 --> 02:33:44.470
我们其实

02:33:44.470 --> 02:33:45.470
我们在官网上

02:33:45.470 --> 02:33:46.470
或者很多教堂里面

02:33:46.470 --> 02:33:47.470
看到deaf就是更新这里

02:33:47.470 --> 02:33:49.470
它怎么来去找目标

02:33:49.470 --> 02:33:50.470
怎么去找目标

02:33:50.470 --> 02:33:51.470
怎么去找差异

02:33:51.470 --> 02:33:53.470
我们这里讲得更加详细一点

02:33:54.470 --> 02:33:55.470
对比的时候

02:33:55.470 --> 02:33:56.470
关键点要找到目标

02:33:56.470 --> 02:33:58.470
怎么来找到目标呢

02:34:00.470 --> 02:34:01.470
它有这么几个假设

02:34:02.470 --> 02:34:04.470
节点不会出现层次的移动

02:34:04.470 --> 02:34:06.470
层次的移动不会出现

02:34:06.470 --> 02:34:08.470
比方说它出现层次的移动

02:34:08.470 --> 02:34:09.470
怎么办

02:34:09.470 --> 02:34:10.470
比方说这个东西

02:34:10.470 --> 02:34:12.470
它出现了层次的移动

02:34:12.470 --> 02:34:14.470
它变成了这个样子

02:34:15.470 --> 02:34:17.470
这两个东西变到这了

02:34:19.470 --> 02:34:21.470
DIV里边套了一个DIV

02:34:21.470 --> 02:34:22.470
这个套了一个DIV里面

02:34:22.470 --> 02:34:23.470
变成这个了

02:34:23.470 --> 02:34:24.470
层次移动怎么办

02:34:24.470 --> 02:34:25.470
你说怎么办

02:34:25.470 --> 02:34:26.470
这两个一样的

02:34:26.470 --> 02:34:27.470
这个东西跟谁在对比

02:34:27.470 --> 02:34:29.470
跟这个成绩的进行对比

02:34:29.470 --> 02:34:30.470
同一个成绩进行对比

02:34:30.470 --> 02:34:31.470
尽管哪怕有keyz

02:34:31.470 --> 02:34:33.470
都是同一个成绩进行对比

02:34:33.470 --> 02:34:34.470
这个成绩跟这个成绩对比

02:34:34.470 --> 02:34:36.470
一对与是不是这两个卸载

02:34:36.470 --> 02:34:37.470
这个新建

02:34:38.470 --> 02:34:39.470
然后这两个在新建

02:34:39.470 --> 02:34:41.470
因为它后面没有成绩的

02:34:42.470 --> 02:34:43.470
因为它新建的

02:34:43.470 --> 02:34:44.470
它后面的肯东

02:34:44.470 --> 02:34:45.470
它是新的

02:34:45.470 --> 02:34:47.470
那么后面东西全是新的

02:34:49.470 --> 02:34:50.470
所以说它有一个假设

02:34:50.470 --> 02:34:51.470
不会出现层次的移动

02:34:51.470 --> 02:34:52.470
如果你出现了层次的移动

02:34:52.470 --> 02:34:53.470
ok

02:34:53.470 --> 02:34:55.470
它就可以卸载新建

02:34:55.470 --> 02:34:56.470
它用这种方式

02:34:56.470 --> 02:34:57.470
对吧

02:34:57.470 --> 02:34:58.470
出现了层次的移动

02:34:58.470 --> 02:34:59.470
你对比对不上了

02:34:59.470 --> 02:35:00.470
对不对

02:35:00.470 --> 02:35:01.470
所以说

02:35:01.470 --> 02:35:02.470
它就假设

02:35:02.470 --> 02:35:03.470
不会出现层次的移动

02:35:03.470 --> 02:35:05.470
因为它认为层次移动

02:35:05.470 --> 02:35:07.470
如果要考虑这个问题的话

02:35:07.470 --> 02:35:08.470
那么它的对比起来

02:35:08.470 --> 02:35:10.470
耗费的效率太低了

02:35:11.470 --> 02:35:12.470
所以它先做这个假设

02:35:12.470 --> 02:35:13.470
那么第二个

02:35:13.470 --> 02:35:15.470
不同节点内型会生成不同的结构

02:35:15.470 --> 02:35:16.470
如果遇到了内型不一样

02:35:16.470 --> 02:35:17.470
比方到这里

02:35:17.470 --> 02:35:18.470
这个DIV

02:35:19.470 --> 02:35:20.470
没法对比了对吧

02:35:20.470 --> 02:35:21.470
比方找到这个

02:35:21.470 --> 02:35:22.470
如果没有keyz

02:35:22.470 --> 02:35:23.470
如果没有keyz

02:35:23.470 --> 02:35:24.470
那这个DIV

02:35:24.470 --> 02:35:25.470
这个是个组件

02:35:25.470 --> 02:35:27.470
它认为它的结构一定是千差万米

02:35:27.470 --> 02:35:28.470
于是

02:35:28.470 --> 02:35:29.470
直接不用比较后边的

02:35:29.470 --> 02:35:31.470
直接把整个节点卸载掉

02:35:31.470 --> 02:35:33.470
用这个新建的节点替换掉

02:35:35.470 --> 02:35:36.470
当然如果我们没有对比上的话

02:35:36.470 --> 02:35:37.470
那么没有对比上的话

02:35:37.470 --> 02:35:39.470
那就自然而然就是卸载掉

02:35:40.470 --> 02:35:41.470
如果

02:35:41.470 --> 02:35:43.470
然为了在某些特殊场景下

02:35:43.470 --> 02:35:45.470
特别是数主的操作的时候

02:35:45.470 --> 02:35:46.470
为了避免

02:35:46.470 --> 02:35:47.470
效率低下

02:35:47.470 --> 02:35:49.470
因此它做了这么一个东西

02:35:49.470 --> 02:35:50.470
key

02:35:50.470 --> 02:35:51.470
key能用来标做什么事情呢

02:35:51.470 --> 02:35:53.470
key的作用就一个作用

02:35:53.470 --> 02:35:54.470
就是如果以后面试的时候

02:35:54.470 --> 02:35:55.470
问你key什么

02:35:55.470 --> 02:35:57.470
你不用跟它说那么大堆东西

02:35:58.470 --> 02:35:59.470
你休息跟它说一句话

02:36:00.470 --> 02:36:01.470
什么话呢

02:36:01.470 --> 02:36:03.470
用来确定

02:36:03.470 --> 02:36:05.470
节点对比的目标

02:36:05.470 --> 02:36:07.470
key的作用就这个作用

02:36:07.470 --> 02:36:09.470
到底跟谁来对比

02:36:09.470 --> 02:36:11.470
它用来确定这个东西的

02:36:11.470 --> 02:36:13.470
只要能够确定对比的目标

02:36:13.470 --> 02:36:15.470
当然它没听懂你啥意思

02:36:15.470 --> 02:36:17.470
你可以给它详细的解释一下

02:36:17.470 --> 02:36:19.470
只有确定了对比的目标之后

02:36:19.470 --> 02:36:22.470
我们才能接着往后边的步骤来走

02:36:22.470 --> 02:36:24.470
比方说找到对比目标怎么样

02:36:24.470 --> 02:36:26.470
没有找到对比目标又怎么样

02:36:26.470 --> 02:36:28.470
你可以把后边的留生家说一下

02:36:28.470 --> 02:36:31.470
key的最关键的作用是找对比目标的

02:36:31.470 --> 02:36:33.470
它不跟什么生命周期那些

02:36:33.470 --> 02:36:34.470
没有半毛钱关系

02:36:34.470 --> 02:36:35.470
不要认为它

02:36:35.470 --> 02:36:37.470
它会影响到什么生命周期

02:36:37.470 --> 02:36:38.470
是不是加了key之

02:36:38.470 --> 02:36:40.470
一生命周期函数就不用运行的

02:36:40.470 --> 02:36:41.470
就不用重新渲染了

02:36:41.470 --> 02:36:43.470
不是的

02:36:43.470 --> 02:36:45.470
key它就是在找目标的

02:36:45.470 --> 02:36:46.470
跟谁来对比

02:36:46.470 --> 02:36:47.470
该渲染的就渲染

02:36:47.470 --> 02:36:48.470
后边怎么

02:36:48.470 --> 02:36:49.470
后边找到目标之后干什么事情

02:36:49.470 --> 02:36:51.470
我们之前都说明了

02:36:53.470 --> 02:36:54.470
OK

02:36:54.470 --> 02:36:56.470
花费的时间很多

02:36:56.470 --> 02:36:58.470
这几刻渲染原理

02:36:58.470 --> 02:36:59.470
因为它确实东西很多

02:36:59.470 --> 02:37:01.470
其实我都还没有把它讲到

02:37:01.470 --> 02:37:02.470
更深的地方

02:37:02.470 --> 02:37:04.470
更深的地方需要在原码部分讲

02:37:04.470 --> 02:37:05.470
不过我现在觉得

02:37:05.470 --> 02:37:07.470
就这个东西面前试的时候

02:37:07.470 --> 02:37:08.470
够用了

02:37:08.470 --> 02:37:09.470
真心够用了

02:37:09.470 --> 02:37:10.470
真心够用了

02:37:10.470 --> 02:37:11.470
你想知道更深入的东西

02:37:11.470 --> 02:37:12.470
那么

02:37:12.470 --> 02:37:14.470
你要去了解原码了

02:37:14.470 --> 02:37:15.470
包括key之

02:37:15.470 --> 02:37:17.470
key之里面其实还有很多细节

02:37:17.470 --> 02:37:19.470
你要去了解原码了

02:37:19.470 --> 02:37:20.470
好了

02:37:20.470 --> 02:37:21.470
如果这两节课

02:37:21.470 --> 02:37:22.470
没有听懂的话

02:37:22.470 --> 02:37:23.470
你可以反复听一下

02:37:23.470 --> 02:37:24.470
建议大家最后

02:37:24.470 --> 02:37:25.470
以后在面试之前

02:37:25.470 --> 02:37:27.470
反复听一下一个渲染原理

02:37:27.470 --> 02:37:28.470
这两节课

02:37:28.470 --> 02:37:30.470
我讲的已经算是非常深入了

02:37:30.470 --> 02:37:31.470
OK

02:37:31.470 --> 02:37:32.470
这是渲染原理

