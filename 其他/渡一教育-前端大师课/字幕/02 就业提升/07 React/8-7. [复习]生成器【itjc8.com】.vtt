WEBVTT

00:00.620 --> 00:05.620
上一课咱们复习了那个迭代器以及可迭代协议

00:05.620 --> 00:09.620
有了这两个知识之后 这一课咱们来复习一下生存器

00:09.620 --> 00:14.620
我相信之前很多同学在学习ES6的时候学习到生存器这一块

00:14.620 --> 00:16.620
都会遇到不小的难度

00:16.620 --> 00:22.620
就是ES6里面整个新增的东西 难度都比较低 普遍比较低

00:22.620 --> 00:28.620
最有难度的应该就算是生存器以及Promise

00:28.620 --> 00:31.620
就是这两个东西了 其他的都没啥了

00:31.620 --> 00:33.620
咱们来说一下生存器

00:33.620 --> 00:36.620
生存器是一个什么东西呢

00:36.620 --> 00:39.620
它单词叫做Generator

00:39.620 --> 00:42.620
生存器它是这样一个东西 我给它下一个定义

00:42.620 --> 00:48.130
关于生存器 关于Generator

00:48.130 --> 00:51.130
这个东西它叫做生存器 给它下个定义

00:51.130 --> 00:55.130
定义就是说生存器

00:55.130 --> 01:04.130
有构造函数Generator创建的对象

01:04.130 --> 01:09.130
也就是生存器它是有一个构造函数Generator创建的对象

01:09.130 --> 01:12.130
该对象具有这么一样一个特征

01:12.130 --> 01:21.130
该对象既满足 既是一个迭代器

01:21.130 --> 01:25.130
也就是说 这个对象里面是不是有个Nex的方法

01:25.130 --> 01:29.130
它里面有个Nex的方法 它是一个迭代器

01:29.130 --> 01:37.130
同时又是一个可迭代对象

01:37.130 --> 01:39.130
什么叫可迭代对象 咱们上一课说的

01:39.130 --> 01:45.130
就是一个满足可迭代协议的对象

01:45.130 --> 01:48.130
就是可迭代对象

01:48.130 --> 01:50.130
这个生存器它本身就是一个对象

01:50.130 --> 01:51.130
它是有怎么来的呢

01:51.130 --> 01:54.130
它是通过Generator构造函数创建的

01:54.130 --> 01:56.130
创建好的这个对象之后

01:56.130 --> 01:59.130
它既是一个迭代器 它里面有Nex的方法

01:59.130 --> 02:02.130
同时又是一个可迭代对象

02:02.130 --> 02:06.130
也就是说你对它是可以用425循环的

02:06.130 --> 02:09.130
如果说我们写这么一个违代码的话

02:09.130 --> 02:12.130
那么大概是这个样子

02:12.130 --> 02:14.130
就是违代码

02:14.130 --> 02:17.950
下面注意 下面是违代码

02:17.950 --> 02:18.950
它不能真实地运行了

02:18.950 --> 02:20.950
违代码的话大概是这个样子

02:20.950 --> 02:24.950
Generator等于New什么 Generator

02:24.950 --> 02:27.950
通过个构造函数创建的这么一个东西

02:27.950 --> 02:30.950
然后这个东西里边它是不是有Nex

02:30.950 --> 02:33.950
它本身就是个迭代器

02:33.950 --> 02:35.950
它里面有Nex的方法

02:35.950 --> 02:38.950
它具有Nex的方法

02:38.950 --> 02:40.950
同时由于它是一个可迭代对象

02:40.950 --> 02:43.950
是不是它里面也有什么

02:44.950 --> 02:46.950
它里面也有

02:46.950 --> 02:48.950
这个什么

02:51.950 --> 02:53.950
它里面也有这个东西

02:53.950 --> 02:57.950
因为它也是一个可迭代对象

02:57.950 --> 02:59.950
所以说它里面有这么一个

02:59.950 --> 03:02.950
就是知名的Symbol符号

03:02.950 --> 03:05.950
也就是同时由于它是一个可迭代对象

03:05.950 --> 03:07.950
是不是也可以用425循环

03:07.950 --> 03:08.950
对不对

03:08.950 --> 03:12.950
425循环Generator

03:13.950 --> 03:19.950
由于它是一个可迭代对象

03:19.950 --> 03:24.950
因此也可以使用425循环

03:24.950 --> 03:25.950
对吧

03:25.950 --> 03:27.950
这就是生成器的这么一个特点

03:27.950 --> 03:28.950
生成器本身就是个对象

03:28.950 --> 03:29.950
它哪来的

03:29.950 --> 03:31.950
就通过Generator构造函数创建的

03:31.950 --> 03:32.950
最压的是违代码

03:32.950 --> 03:34.950
为什么说它是违代码呢

03:34.950 --> 03:36.950
是因为Generator这个构造函数

03:36.950 --> 03:38.950
它是内部使用的

03:38.950 --> 03:40.950
接下来是引擎内部使用的

03:40.950 --> 03:43.950
我们开发者是不能直接通过它来创建的

03:43.950 --> 03:44.950
对吧

03:44.950 --> 03:47.950
这里注意

03:47.950 --> 03:51.950
就是Generator构造函数

03:51.950 --> 03:55.950
不提供给开发者使用

03:55.950 --> 04:01.950
仅作为解实引擎内部使用

04:01.950 --> 04:02.950
也就是说我们在

04:02.950 --> 04:04.950
如果说我们在浏览器里面

04:04.950 --> 04:06.950
去找一找Generator的函数

04:06.950 --> 04:07.950
你会发现它是找不到的

04:07.950 --> 04:09.950
是找不到这么一个玩意的

04:09.950 --> 04:10.950
咱们来看一下吧

04:10.950 --> 04:14.950
这里我们生成器

04:14.950 --> 04:18.330
这里先建个页面

04:18.330 --> 04:20.330
应该是点AT面

04:20.330 --> 04:23.330
然后我这里建个页面

04:23.330 --> 04:27.330
就这样子运行出来

04:27.330 --> 04:28.330
运行出来

04:28.330 --> 04:31.330
咱们在控制台里面来看一下吧

04:31.330 --> 04:35.330
看一下Generator看一下

04:35.330 --> 04:36.330
有吗

04:36.330 --> 04:37.330
是不是找不到

04:37.330 --> 04:39.330
Generator is not defined

04:39.330 --> 04:40.330
实际上是有的

04:40.330 --> 04:43.330
但是我们外部的开发者是不能使用的

04:43.330 --> 04:45.330
那就麻烦就来了

04:45.330 --> 04:46.330
这个问题

04:46.330 --> 04:49.330
我们又不能调用那个构造函数Generator

04:49.330 --> 04:51.330
那我们怎么来得到一个生成器呢

04:51.330 --> 04:53.330
我们这一节课不就讲生成器吗

04:53.330 --> 04:55.330
那我要怎么来得到生成器呢

04:55.330 --> 04:56.330
得不到

04:56.330 --> 04:59.330
你自己不能使用这个构造函数来得到

04:59.330 --> 05:00.330
那你该怎么得到了

05:00.330 --> 05:02.330
它要使用这种方式来得到

05:02.330 --> 05:03.330
所以我们第二个部分

05:03.330 --> 05:04.330
就是重点来了

05:04.330 --> 05:06.330
重点在第二个部分

05:06.330 --> 05:07.330
第二个部分就是

05:07.330 --> 05:10.330
我们把它称之为Generator function

05:10.330 --> 05:12.330
也就是说

05:12.330 --> 05:16.330
叫做什么生成器函数

05:16.330 --> 05:18.330
我们把它叫详细点的话

05:18.330 --> 05:21.330
叫做生成器创建

05:21.330 --> 05:25.330
生成器创建函数

05:25.330 --> 05:31.330
那么该函数用于创建一个生成器

05:31.330 --> 05:33.330
也就是说我们那个生成器呢

05:33.330 --> 05:34.330
它不是说

05:34.330 --> 05:36.330
通过直接调用构造函数来的

05:36.330 --> 05:38.330
而是通过一个函数来得到的

05:38.330 --> 05:40.330
这个函数叫做生成器创建函数

05:40.330 --> 05:42.330
这个也叫减称为生成器函数

05:42.330 --> 05:44.330
这个函数用来得到一个生成器

05:44.330 --> 05:45.330
那么这个函数呢

05:45.330 --> 05:47.330
那这个问题来了

05:47.330 --> 05:48.330
麻烦了

05:48.330 --> 05:51.330
那既然说我们不能调用那个

05:51.330 --> 05:53.330
构造函数

05:53.330 --> 05:55.330
那比方说我这里写这么一个函数

05:55.330 --> 05:57.330
叫CreateGenerator

05:57.330 --> 05:58.330
创建一个生成器

05:58.330 --> 06:00.330
那么这里边我要返回对吧

06:00.330 --> 06:01.330
我要返回一个生成器

06:01.330 --> 06:04.330
那还不是得调用这个玩意

06:04.330 --> 06:05.330
这个东西

06:05.330 --> 06:06.330
你怎么办了

06:06.330 --> 06:07.330
一直告诉我怎么办了

06:07.330 --> 06:08.330
这个东西还不是得调用这个

06:08.330 --> 06:09.330
我要得到一个生成器

06:09.330 --> 06:10.330
那它是怎么回事

06:10.330 --> 06:11.330
它是这样子

06:11.330 --> 06:15.330
ES6提出

06:15.330 --> 06:18.330
就是新增

06:18.330 --> 06:21.330
新增了一个特殊的函数

06:21.330 --> 06:24.330
叫做生成器函数

06:24.330 --> 06:27.330
只要在函数名

06:27.330 --> 06:32.330
与那个方式关键字之间

06:32.330 --> 06:37.330
只要在函数名与方式关键字之间

06:37.330 --> 06:42.330
关键字之间加上一个新号

06:42.330 --> 06:43.330
一个新号

06:43.330 --> 06:49.330
则该函数会自动返回一个生成器

06:49.330 --> 06:50.330
就这么个意思

06:50.330 --> 06:52.330
也就是说我们要做的事情

06:52.330 --> 06:55.330
不是说在这里边去创建一个生成器

06:55.330 --> 06:56.330
而是要做的事情

06:56.330 --> 06:58.330
是在语法上做改动

06:58.330 --> 07:01.330
在方形和函数名字之间

07:01.330 --> 07:03.330
写上了每个新号

07:03.330 --> 07:04.330
这个格式

07:04.330 --> 07:06.330
每个公司有一些不一样

07:06.330 --> 07:07.330
有些新号写这儿

07:07.330 --> 07:08.330
有些新号写这儿

07:08.330 --> 07:09.330
贴到这儿写

07:09.330 --> 07:10.330
其实无所谓

07:10.330 --> 07:11.330
贴到哪儿都无所谓

07:11.330 --> 07:13.330
可能网上比较多的

07:13.330 --> 07:15.330
公司名比较多的是贴到这儿写

07:15.330 --> 07:17.330
因为它有可能是个地名函数

07:17.330 --> 07:19.330
没有名字的函数

07:19.330 --> 07:20.330
没有名字的函数

07:20.330 --> 07:21.330
也可以加上这个

07:21.330 --> 07:22.330
总之

07:22.330 --> 07:24.330
你只要加上这个新号

07:24.330 --> 07:26.330
其实东西都是学过的

07:26.330 --> 07:28.330
只是帮助大家回忆一下

07:28.330 --> 07:29.330
加上这个新号

07:29.330 --> 07:32.330
这个函数就变成了一个生成器函数

07:32.330 --> 07:33.330
它不是生成器

07:33.330 --> 07:35.330
它本身不是生成器

07:35.330 --> 07:36.330
生成器是一个对象

07:36.330 --> 07:38.330
它指的是一个生成器函数

07:38.330 --> 07:42.330
下面的函数

07:42.330 --> 07:45.330
是一个生成器函数

07:45.330 --> 07:46.330
用来干嘛的

07:46.330 --> 07:49.330
用于创建生成器

07:49.330 --> 07:50.330
那么这个函数

07:50.330 --> 07:52.330
我们不用去写任何代码

07:52.330 --> 07:54.330
在这里边什么代码都不用写

07:54.330 --> 07:55.330
什么代码都不用写

07:55.330 --> 07:57.330
然后我们这里调用这个函数

07:57.330 --> 07:58.330
我们去调用这个函数

07:58.330 --> 07:59.330
你就会发现

07:59.330 --> 08:01.330
这个函数你看看提示你

08:01.330 --> 08:03.330
提示你

08:03.330 --> 08:05.330
Aterable表示可迭代的

08:05.330 --> 08:06.330
可迭代对象

08:06.330 --> 08:08.330
同时又是个Aterator

08:08.330 --> 08:10.330
Eterable可迭代对象

08:10.330 --> 08:11.330
Eterator表示的是

08:11.330 --> 08:13.330
它又是一个迭代器

08:13.330 --> 08:15.330
也就是说这里返回的是一个什么

08:15.330 --> 08:18.330
返回的就是一个生成器

08:18.330 --> 08:21.330
返回的Generator

08:21.330 --> 08:22.330
返回的就是一个生成器

08:22.330 --> 08:24.330
有调用这个函数里边

08:24.330 --> 08:25.330
一行代码都没有

08:25.330 --> 08:26.330
只要你使用这个特殊符号

08:26.330 --> 08:27.330
放到这

08:27.330 --> 08:28.330
那么这个函数

08:28.330 --> 08:30.330
它会自动的给你返回个生成器

08:30.330 --> 08:32.330
就好比说用了六关键字过后

08:32.330 --> 08:33.330
它会自动给你返回个对象

08:33.330 --> 08:34.330
哪怕你没有写return

08:34.330 --> 08:35.330
对吧

08:35.330 --> 08:38.330
那么这里就是得到了调用

08:38.330 --> 08:40.330
然后一定得到

08:40.330 --> 08:41.330
它不可能是其他情况

08:41.330 --> 08:44.330
一定得到一个生成器

08:44.330 --> 08:46.330
那现在我们来看一下

08:46.330 --> 08:47.330
这个生成器

08:47.330 --> 08:48.330
保存看一下

08:48.330 --> 08:50.330
我们是不是得到Generator

08:50.330 --> 08:53.330
来看一下Generator

08:53.330 --> 08:55.330
这个Generator的话

08:55.330 --> 08:56.330
Protot就是影视员一些

08:56.330 --> 08:57.330
是不是Generator

08:57.330 --> 08:58.330
对吧

08:58.330 --> 08:59.330
是一个构造函数

08:59.330 --> 09:00.330
对不对

09:00.330 --> 09:01.330
构造函数

09:01.330 --> 09:02.330
只不过那个构造函数

09:02.330 --> 09:03.330
我们自己不能使用

09:03.330 --> 09:04.330
不能使用

09:04.330 --> 09:05.330
你可以理解

09:05.330 --> 09:06.330
它就是个构造函数

09:06.330 --> 09:07.330
那么来看一下

09:07.330 --> 09:08.330
验证一下之前的

09:08.330 --> 09:09.330
这个生成器里边

09:09.330 --> 09:10.330
是不是有NATURE的方法

09:10.330 --> 09:11.330
你看一下

09:11.330 --> 09:12.330
是不是一个NATURE的方法

09:12.330 --> 09:13.330
对不对

09:13.330 --> 09:14.330
NATURE

09:14.330 --> 09:15.330
里边是native code

09:15.330 --> 09:16.330
什么叫native code

09:16.330 --> 09:17.330
就是本地代码

09:17.330 --> 09:18.330
就是说

09:18.330 --> 09:19.330
它里边包含了什么C語言

09:19.330 --> 09:20.330
CR加代码

09:20.330 --> 09:22.330
我们不用去管它怎么写的

09:22.330 --> 09:23.330
然后Generator

09:23.330 --> 09:24.330
是不是里边

09:24.330 --> 09:27.330
simple.atorator

09:27.330 --> 09:28.330
是不是有这个东西

09:28.330 --> 09:29.330
你看

09:29.330 --> 09:30.330
是不是也有

09:30.330 --> 09:31.330
对不对

09:31.330 --> 09:32.330
也有

09:32.330 --> 09:33.330
也就是它既有NATURE

09:33.330 --> 09:35.330
也有这个

09:35.330 --> 09:36.330
这个居民符号

09:36.330 --> 09:38.330
并且我们都可以猜得到

09:38.330 --> 09:39.330
因为它自己有NATURE

09:39.330 --> 09:40.330
对吧

09:40.330 --> 09:41.330
并且Generator

09:41.330 --> 09:43.330
里边有什么simple

09:43.330 --> 09:46.330
simple

09:46.330 --> 09:47.330
simple

09:47.330 --> 09:49.330
上级科学的atorator

09:49.330 --> 09:50.330
这个殖民符号

09:50.330 --> 09:51.330
调用它是不是

09:51.330 --> 09:52.330
可以得到一个对象

09:52.330 --> 09:53.330
对象里边是不是有NATURE的方法

09:53.330 --> 09:54.330
这两个是不是一样的

09:54.330 --> 09:55.330
你会发现是一样的

09:55.330 --> 09:56.330
是同一个方法

09:56.330 --> 09:57.330
它内部可以实现的

09:57.330 --> 09:58.330
我们都不用管

09:58.330 --> 09:59.330
都不用管它

09:59.330 --> 10:01.330
明白这个意思吗

10:01.330 --> 10:03.330
这就是一个生存器

10:03.330 --> 10:05.330
就验证了我们之前说的

10:05.330 --> 10:06.330
所以说生存器

10:06.330 --> 10:07.330
我们自己是得不到的

10:07.330 --> 10:09.330
必须要通过生存器

10:09.330 --> 10:10.330
函数来得到

10:10.330 --> 10:11.330
而这个函数

10:11.330 --> 10:12.330
你自己什么代码都不用写

10:12.330 --> 10:13.330
你只要加个新号

10:13.330 --> 10:15.330
它一定得到这个函数

10:15.330 --> 10:16.330
好

10:16.330 --> 10:17.330
那么接下来

10:17.330 --> 10:18.330
我们来研究一下

10:18.330 --> 10:19.330
生存器函数里边的特点

10:19.330 --> 10:20.330
已经了

10:20.330 --> 10:21.330
它跟那个生存器之间

10:21.330 --> 10:22.330
怎么来联用

10:22.330 --> 10:24.330
这是我们这几颗的重点

10:24.330 --> 10:26.330
这里面的细节是比较多的

10:26.330 --> 10:28.330
首先我们在这个函数里边

10:28.330 --> 10:29.330
写上这么一句话

10:29.330 --> 10:30.330
就一个输出

10:30.330 --> 10:32.330
输出就是什么

10:32.330 --> 10:34.330
我是一个就是

10:34.330 --> 10:38.330
雕用了生存器函数

10:38.330 --> 10:39.330
雕用了生存器

10:39.330 --> 10:42.330
雕用了生存器函数

10:42.330 --> 10:44.330
那么这是换句说法

10:44.330 --> 10:48.330
生存器函数的函数体

10:48.330 --> 10:50.330
这是生存器函数的函数体

10:50.330 --> 10:51.330
对吧

10:51.330 --> 10:52.330
这里调用函数

10:52.330 --> 10:53.330
是不是应该输出这句话

10:53.330 --> 10:54.330
对吧

10:54.330 --> 10:55.330
好

10:55.330 --> 10:56.330
咱们来看一下

10:56.330 --> 10:57.330
有没有输出这句话

10:57.330 --> 10:58.330
刷新一万次

10:58.330 --> 10:59.330
它都不会输出

10:59.330 --> 11:00.330
它没有输出这句话

11:00.330 --> 11:02.330
为什么没有输出这句话呢

11:02.330 --> 11:04.330
这里就是我们生存器函数的

11:04.330 --> 11:05.330
第一个特点

11:05.330 --> 11:07.330
它就是比较怪异的地方

11:07.330 --> 11:08.330
不说怪异

11:08.330 --> 11:09.330
就是比较特别的地方

11:09.330 --> 11:10.330
跟我们之前学的函数

11:10.330 --> 11:12.330
不太一样了

11:12.330 --> 11:15.330
就是说生存器函数的特点

11:15.330 --> 11:18.330
生存器函数的特点

11:18.330 --> 11:19.330
来吧

11:19.330 --> 11:21.330
生存器本身没有什么好说的

11:21.330 --> 11:22.330
没有什么好说的

11:22.330 --> 11:23.330
它就是一个可谍

11:23.330 --> 11:24.330
它里面有Nex

11:24.330 --> 11:26.330
也有什么具名符号

11:26.330 --> 11:27.330
这里我们主要说

11:27.330 --> 11:29.330
生存器函数的特点

11:29.330 --> 11:30.330
一个个来

11:30.330 --> 11:32.330
第一个

11:32.330 --> 11:36.330
就是调用生存器函数

11:36.330 --> 11:43.330
会返回一个生存器

11:43.330 --> 11:48.330
而不是执行函数体

11:48.330 --> 11:50.330
一个非常非常特别的地方

11:50.330 --> 11:51.330
像以前咱们学的函数

11:51.330 --> 11:52.330
一定要用它

11:52.330 --> 11:53.330
它一定会执行函数

11:53.330 --> 11:54.330
这里面写的什么东西

11:54.330 --> 11:55.330
它就一定会执行

11:55.330 --> 11:59.330
但是生存器函数不一样

11:59.330 --> 12:00.330
生存器函数

12:00.330 --> 12:01.330
一定要用它过后

12:01.330 --> 12:03.330
它里面一句代码都不会执行

12:03.330 --> 12:04.330
什么都不会执行

12:04.330 --> 12:06.330
它会直接得到一个生存器

12:06.330 --> 12:08.330
这是生存器函数的特点

12:08.330 --> 12:09.330
它会得到一个生存器

12:09.330 --> 12:10.330
里面的函数体里面代码

12:10.330 --> 12:12.330
是不会执行的

12:12.330 --> 12:13.330
为什么不会执行

12:13.330 --> 12:14.330
就是我们后边要说的

12:14.330 --> 12:16.330
这里面函数的执行

12:16.330 --> 12:19.330
是受生存器控制的

12:19.330 --> 12:27.330
就是因为生存器函数的函数体执行

12:27.330 --> 12:30.330
受到生存器控制

12:30.330 --> 12:31.330
也就是说

12:31.330 --> 12:33.330
我们要怎么来控制它函数执行呢

12:33.330 --> 12:34.330
是要通过它来控制的

12:34.330 --> 12:36.330
而不是说直接调用这个函数

12:36.330 --> 12:38.330
来运行这个函数

12:38.330 --> 12:39.330
原来的意思吧

12:39.330 --> 12:41.330
是我这边得到的生存器

12:41.330 --> 12:44.330
能够控制这里面的函数来执行

12:44.330 --> 12:48.330
这是生存器还是个第一个特点

12:48.330 --> 12:50.330
那么怎么来执行呢

12:50.330 --> 12:51.330
到底怎么来执行呢

12:51.330 --> 12:52.330
咱们又来看

12:52.330 --> 12:54.330
执行的方式是

12:54.330 --> 13:00.330
每当调用了生存器

13:00.330 --> 13:05.330
每当调用了生存器的那个式的方法

13:05.330 --> 13:08.330
每当调用了生存器的那个式的方法

13:08.330 --> 13:09.330
我不管你是

13:09.330 --> 13:10.330
我们之前演示过

13:10.330 --> 13:12.330
不管你是通过那个Generator

13:12.330 --> 13:13.330
那个式来调用的

13:13.330 --> 13:15.330
还是通过这个具名符号

13:15.330 --> 13:16.330
symbol

13:16.330 --> 13:18.330
具名符号

13:18.330 --> 13:20.330
get

13:20.330 --> 13:22.330
然后调那个式来调用的

13:22.330 --> 13:23.330
管理怎么调用的

13:23.330 --> 13:24.330
其实无所谓

13:24.330 --> 13:25.330
当然这样子很麻烦对吧

13:25.330 --> 13:27.330
我们通常都是直接使用那个式来调用的

13:27.330 --> 13:28.330
对不对

13:28.330 --> 13:29.330
我不管你怎么调用的

13:29.330 --> 13:31.330
只要你调用的那个式的方法

13:31.330 --> 13:33.330
每当你调用一次

13:33.330 --> 13:35.330
它会做什么事情呢

13:35.330 --> 13:41.330
生存器

13:41.330 --> 13:42.330
的函数体

13:42.330 --> 13:51.330
会从上一次EOD的位置

13:51.330 --> 13:54.330
或开始位置

13:54.330 --> 14:00.330
运行到下一个EOD

14:00.330 --> 14:03.330
这是生存器函数的执行方式

14:03.330 --> 14:05.330
啥意思呢

14:05.330 --> 14:08.330
咱们这里来写一下

14:08.330 --> 14:11.330
这是生存器函数的函数体

14:11.330 --> 14:15.330
开始

14:15.330 --> 14:19.330
这里我们多写两句

14:19.330 --> 14:21.330
运行中

14:21.330 --> 14:23.330
运行1

14:23.330 --> 14:25.330
运行2

14:25.330 --> 14:27.330
然后再来一个运行3

14:27.330 --> 14:29.330
接下来

14:29.330 --> 14:33.330
我们来在这里边写上一个EOD

14:33.330 --> 14:35.330
写错了

14:35.330 --> 14:41.830
下面又写上一个EOD

14:42.830 --> 14:44.830
行了

14:44.830 --> 14:47.830
咱们来看一下函数是怎么运行的

14:47.830 --> 14:49.830
这个函数你会发现一开始

14:49.830 --> 14:50.830
一句代码的不运行

14:50.830 --> 14:51.830
就是我们之前解释的

14:51.830 --> 14:52.830
生存器函数比较特殊

14:52.830 --> 14:54.830
如果说你是一个普通函数的话

14:54.830 --> 14:56.830
自然而然它要运行

14:56.830 --> 14:59.830
但是普通函数里面是不能使用这个关键字的

14:59.830 --> 15:00.830
EOD

15:00.830 --> 15:02.830
不能使用这个关键字的

15:02.830 --> 15:04.830
那么只有在生存器函数里面

15:04.830 --> 15:06.830
才能使用这个关键字

15:06.830 --> 15:09.830
这里我们还是来记一笔

15:09.830 --> 15:16.830
EOD关键字只能在生存器内部使用

15:16.830 --> 15:20.830
不可以在普通函数内部使用

15:20.830 --> 15:22.830
普通函数内部使用

15:22.830 --> 15:23.830
普通函数内部

15:23.830 --> 15:25.830
你看我之前介绍过EOD的吗

15:25.830 --> 15:26.830
没有

15:26.830 --> 15:28.830
只能在生存器内部使用

15:28.830 --> 15:29.830
它表示怎么意思呢

15:29.830 --> 15:31.830
它表示暂停

15:32.830 --> 15:33.830
暂停

15:33.830 --> 15:36.830
并返回一个

15:39.830 --> 15:40.830
迭代的

15:40.830 --> 15:42.830
当前迭代的数据

15:42.830 --> 15:44.830
这里我们一会再解释

15:44.830 --> 15:45.830
好

15:45.830 --> 15:46.830
我们来看一下

15:46.830 --> 15:47.830
刚才我们说到那个点

15:47.830 --> 15:48.830
就说这个函数

15:48.830 --> 15:49.830
调用的时候

15:49.830 --> 15:50.830
它不会运行

15:50.830 --> 15:51.830
不会运行

15:51.830 --> 15:52.830
并不会运行这个函数

15:52.830 --> 15:53.830
什么时候运行呢

15:53.830 --> 15:54.830
它要等到

15:54.830 --> 15:56.830
调用生存器的Nex的时候

15:56.830 --> 15:57.830
它才会运行

15:57.830 --> 15:58.830
看着

15:58.830 --> 16:00.830
生存器调用Nex

16:00.830 --> 16:01.830
返回啥

16:01.830 --> 16:02.830
来回忆一下

16:02.830 --> 16:03.830
Nex的返回啥

16:03.830 --> 16:04.830
它是一个

16:04.830 --> 16:05.830
这个Nex

16:05.830 --> 16:06.830
因为它是迭代器

16:06.830 --> 16:08.830
所以说固然具有这个Nex的方法

16:08.830 --> 16:09.830
那么迭代器要求

16:09.830 --> 16:10.830
Nex的方法返回啥

16:10.830 --> 16:12.830
返回一个对象

16:12.830 --> 16:13.830
有Value属性

16:13.830 --> 16:14.830
有Done属性

16:14.830 --> 16:15.830
对吧

16:15.830 --> 16:16.830
好

16:16.830 --> 16:17.830
那么我们回车

16:17.830 --> 16:18.830
也会看到

16:18.830 --> 16:19.830
返回的结果

16:19.830 --> 16:20.830
是不是一个Value属性

16:20.830 --> 16:21.830
Undefend

16:21.830 --> 16:22.830
对吧

16:22.830 --> 16:23.830
为什么是Undefend

16:23.830 --> 16:24.830
我们一会再解释

16:24.830 --> 16:25.830
Done是Force

16:25.830 --> 16:26.830
对不对

16:26.830 --> 16:27.830
是Force

16:27.830 --> 16:28.830
看呗

16:28.830 --> 16:29.830
就完了

16:29.830 --> 16:30.830
这句话是不是运行了

16:30.830 --> 16:32.830
为什么这句话运行了

16:32.830 --> 16:33.830
就是我们刚才解释的

16:33.830 --> 16:37.830
当我们调用生存器的Nex的方法的时候

16:37.830 --> 16:38.830
生存器

16:38.830 --> 16:40.830
它杜印的生存器函数

16:40.830 --> 16:41.830
它的函数体

16:41.830 --> 16:44.830
会从上一次一有的位置

16:44.830 --> 16:45.830
上一次有没有一有的

16:45.830 --> 16:47.830
目前是最开始调用对吧

16:47.830 --> 16:48.830
上一次没有一有的

16:48.830 --> 16:49.830
所以说

16:49.830 --> 16:51.830
或开始位置

16:51.830 --> 16:52.830
会函数开始位置

16:52.830 --> 16:53.830
那么现在就是

16:53.830 --> 16:55.830
从函数开始位置开始调用

16:55.830 --> 16:57.830
一直运行运行

16:57.830 --> 16:58.830
运行到哪呢

16:58.830 --> 17:00.830
运行到下一个一有的

17:00.830 --> 17:01.830
下一个一有的在哪

17:01.830 --> 17:02.830
是不是在这

17:02.830 --> 17:03.830
对不对

17:03.830 --> 17:04.830
运行到这个一有的

17:04.830 --> 17:05.830
所以在这里

17:05.830 --> 17:06.830
是不是又停止了

17:06.830 --> 17:07.830
运行到这里不再动了

17:07.830 --> 17:08.830
停止的

17:08.830 --> 17:09.830
但是你要注意

17:09.830 --> 17:10.830
我说的停止

17:10.830 --> 17:12.830
它不会影响后边的执行

17:12.830 --> 17:13.830
它不会影响后边的执行

17:13.830 --> 17:15.830
不要让你后边输出

17:15.830 --> 17:16.830
什么也

17:16.830 --> 17:18.830
输出

17:18.830 --> 17:19.830
输这东西

17:19.830 --> 17:20.830
它不会影响的

17:20.830 --> 17:21.830
你看呗

17:21.830 --> 17:22.830
不会影响的

17:22.830 --> 17:24.830
它只是在暂停这个函数

17:24.830 --> 17:26.830
只是在控制这个函数里面的运行

17:26.830 --> 17:27.830
对吧

17:27.830 --> 17:28.830
如果不是这个函数的话

17:28.830 --> 17:29.830
得到不同的承证级

17:29.830 --> 17:30.830
它控制的

17:30.830 --> 17:33.830
就相当于是不同的函数副本

17:33.830 --> 17:35.830
到这个东西我们就不用管了

17:35.830 --> 17:36.830
好

17:36.830 --> 17:38.830
那么现在我们只运行了一次

17:38.830 --> 17:39.830
于是它运行到哪呢

17:39.830 --> 17:40.830
它运行到最开始的位置

17:40.830 --> 17:41.830
对吧

17:41.830 --> 17:42.830
最开始的位置运行到这句话

17:42.830 --> 17:43.830
然后停在哪呢

17:43.830 --> 17:44.830
是不是停在这句话

17:44.830 --> 17:45.830
对吧

17:45.830 --> 17:46.830
停在这句话

17:46.830 --> 17:47.830
你要这个意思吗

17:47.830 --> 17:48.830
这句话停止了

17:48.830 --> 17:49.830
运行到这

17:49.830 --> 17:50.830
ok 停止的

17:50.830 --> 17:51.830
那么这句话有没有运行完了

17:51.830 --> 17:52.830
有

17:52.830 --> 17:53.830
这句话运行完了

17:53.830 --> 17:54.830
运行完了

17:54.830 --> 17:55.830
运行完了就停止了

17:55.830 --> 17:56.830
运行完了停止的

17:56.830 --> 17:57.830
好

17:57.830 --> 17:58.830
那么下一次

17:58.830 --> 17:59.830
我们再调用那个词

17:59.830 --> 18:00.830
你看着

18:00.830 --> 18:01.830
那么就从上一次

18:01.830 --> 18:02.830
那个eod的位置

18:02.830 --> 18:03.830
上一次是不是运行到这个位置

18:03.830 --> 18:05.830
把这句话刚刚好运行完

18:05.830 --> 18:06.830
那么是不是要运行这了

18:06.830 --> 18:07.830
对吧

18:07.830 --> 18:08.830
上一次eod的位置

18:08.830 --> 18:09.830
又继续运行

18:09.830 --> 18:10.830
运行到下一次eod

18:10.830 --> 18:11.830
看一下

18:11.830 --> 18:12.830
对吧

18:12.830 --> 18:13.830
是不是运行到这

18:13.830 --> 18:14.830
函数体运行到这

18:14.830 --> 18:15.830
运行到e

18:15.830 --> 18:16.830
对不对

18:16.830 --> 18:17.830
又运行到这

18:17.830 --> 18:18.830
看没

18:18.830 --> 18:19.830
然后down with force

18:19.830 --> 18:20.830
看到没

18:20.830 --> 18:21.830
是不是很简单

18:21.830 --> 18:22.830
对吧

18:22.830 --> 18:23.830
然后我们再来那个词

18:23.830 --> 18:24.830
又来

18:24.830 --> 18:25.830
运行这句话又停止了

18:25.830 --> 18:26.830
对吧

18:26.830 --> 18:27.830
看到eod的就停止

18:27.830 --> 18:28.830
对吧

18:28.830 --> 18:29.830
又运行3

18:29.830 --> 18:30.830
咱们呢

18:30.830 --> 18:31.830
运行

18:31.830 --> 18:32.830
运行3

18:32.830 --> 18:33.830
运行3过后

18:33.830 --> 18:34.830
运行了完了过后

18:34.830 --> 18:35.830
他发现

18:35.830 --> 18:36.830
后面都没有eod

18:36.830 --> 18:37.830
函数结束了

18:37.830 --> 18:38.830
对吧

18:38.830 --> 18:39.830
如果遇到了函数结束

18:39.830 --> 18:40.830
那么

18:40.830 --> 18:41.830
返回的是

18:41.830 --> 18:42.830
我们这里说一下

18:44.830 --> 18:45.830
如果

18:45.830 --> 18:48.830
没有下一个eod

18:50.830 --> 18:52.830
没有下一个eod

18:52.830 --> 18:54.830
到了函数结束

18:54.830 --> 18:55.830
则

18:55.830 --> 18:57.830
生成器的

18:57.830 --> 18:59.830
next方法

18:59.830 --> 19:01.830
得到的

19:01.830 --> 19:03.830
结果中的

19:03.830 --> 19:04.830
down

19:04.830 --> 19:05.830
维促

19:05.830 --> 19:07.830
就表示完成了

19:07.830 --> 19:08.830
就表示完成了

19:08.830 --> 19:09.830
得到结果中的down

19:09.830 --> 19:10.830
你看第1次

19:10.830 --> 19:11.830
第2次

19:11.830 --> 19:12.830
第3次

19:12.830 --> 19:13.830
再运行

19:13.830 --> 19:14.830
什么down维促了

19:14.830 --> 19:15.830
就运行完成了

19:15.830 --> 19:16.830
就是这么个意思

19:16.830 --> 19:17.830
看没

19:17.830 --> 19:18.830
这就是生成器

19:18.830 --> 19:19.830
也就是生成器

19:19.830 --> 19:20.830
给我们提供了一个

19:20.830 --> 19:21.830
什么样的能力

19:21.830 --> 19:22.830
以前我们从来

19:22.830 --> 19:23.830
不具备的能力

19:23.830 --> 19:24.830
我们在函数外

19:24.830 --> 19:25.830
可以控制

19:25.830 --> 19:27.830
某一个函数体的

19:27.830 --> 19:28.830
执行过程

19:28.830 --> 19:29.830
可以控制它

19:29.830 --> 19:30.830
你控制到运行到这句话

19:30.830 --> 19:31.830
过停了

19:31.830 --> 19:32.830
以后我再运行

19:32.830 --> 19:33.830
你下一句话

19:33.830 --> 19:34.830
我等一会再运行

19:34.830 --> 19:35.830
再下一句话

19:35.830 --> 19:36.830
就这么个意思

19:36.830 --> 19:37.830
我在函数体外面

19:37.830 --> 19:38.830
可以控制的

19:38.830 --> 19:39.830
以前是绝对不可能的

19:39.830 --> 19:40.830
对吧

19:40.830 --> 19:41.830
你运行函数

19:41.830 --> 19:42.830
它一定是

19:42.830 --> 19:43.830
就运行完了

19:43.830 --> 19:44.830
它不会

19:44.830 --> 19:45.830
通过外面的

19:45.830 --> 19:46.830
可以控制

19:46.830 --> 19:47.830
外面要控制的

19:47.830 --> 19:48.830
只能去调

19:48.830 --> 19:49.830
传什么回调

19:49.830 --> 19:50.830
就非常非常麻烦

19:50.830 --> 19:51.830
但是有了生成器过后

19:51.830 --> 19:52.830
就可以控制

19:52.830 --> 19:54.830
它的函数执行了

19:54.830 --> 19:55.830
所以说

19:55.830 --> 19:56.830
我们换句话说

19:56.830 --> 19:58.830
生成器这一块

19:58.830 --> 20:00.830
生成器和生成器函数

20:00.830 --> 20:02.830
这两个是高度偶和的

20:02.830 --> 20:03.830
就这两个对应的

20:03.830 --> 20:05.830
函数是高度偶和的

20:05.830 --> 20:06.830
不是说

20:06.830 --> 20:07.830
因为我们

20:07.830 --> 20:08.830
跟我们以前

20:08.830 --> 20:09.830
调用的施度就不一样

20:09.830 --> 20:10.830
以前我们写好一个

20:10.830 --> 20:11.830
函数不合

20:11.830 --> 20:12.830
我就完全不用管它的函数体

20:12.830 --> 20:13.830
函数体

20:13.830 --> 20:14.830
我就完全不用管

20:14.830 --> 20:15.830
管它函数体

20:15.830 --> 20:16.830
写的是啥呢

20:16.830 --> 20:17.830
完全不用管

20:17.830 --> 20:18.830
因为我们一调用

20:18.830 --> 20:19.830
函数就实现某一个功能

20:19.830 --> 20:20.830
但是

20:20.830 --> 20:21.830
如果是一个生成器函数

20:21.830 --> 20:22.830
也不一样了

20:22.830 --> 20:23.830
因为歪步要控制

20:23.830 --> 20:24.830
函数内部的执行

20:24.830 --> 20:25.830
所以说

20:25.830 --> 20:27.830
歪步就必须要知晓

20:27.830 --> 20:29.830
函数内部到底是怎么来运作的

20:29.830 --> 20:31.830
它可能要做一些特殊的控制

20:31.830 --> 20:32.830
因此

20:32.830 --> 20:34.830
它们两个之间是高度偶和的

20:34.830 --> 20:35.830
这也是符合逻辑的

20:35.830 --> 20:36.830
因为它们两个就是

20:36.830 --> 20:37.830
成对出现的

20:37.830 --> 20:39.830
这个没什么问题

20:39.830 --> 20:40.830
所以说

20:40.830 --> 20:41.830
这个施度

20:41.830 --> 20:42.830
大家要慢慢转变过来

20:42.830 --> 20:43.830
就在生成器函数这一块

20:43.830 --> 20:44.830
要慢慢转变过来

20:44.830 --> 20:45.830
好

20:45.830 --> 20:46.830
那么现在我们再来说

20:46.830 --> 20:47.830
这个生成器函数

20:47.830 --> 20:48.830
每一次调用那个字

20:48.830 --> 20:50.830
它不是得到一个迭代对象

20:50.830 --> 20:52.830
得到一个迭代信息

20:52.830 --> 20:54.830
有一个档属性表示

20:54.830 --> 20:55.830
是否完成迭代

20:55.830 --> 20:56.830
这东西它自动给你表示的

20:56.830 --> 20:58.830
只要遇到了E2

20:58.830 --> 20:59.830
表示

20:59.830 --> 21:00.830
后边还有

21:00.830 --> 21:01.830
如果后面没有E2

21:01.830 --> 21:03.830
表示就是函数结束了

21:03.830 --> 21:04.830
OK 它档属性就是True

21:04.830 --> 21:05.830
就这么简单

21:05.830 --> 21:06.830
因此

21:06.830 --> 21:07.830
这个档属性

21:07.830 --> 21:09.830
它会自动帮你维护

21:09.830 --> 21:11.830
但是那个Value属性是什么呢

21:11.830 --> 21:12.830
Value属性为什么

21:12.830 --> 21:13.830
全部是undefined的呢

21:13.830 --> 21:15.830
咱们来说Value属性

21:15.830 --> 21:16.830
它得到了是什么

21:16.830 --> 21:17.830
好

21:17.830 --> 21:19.830
我们这里说一下

21:19.830 --> 21:21.830
E2的关键字

21:21.830 --> 21:23.830
后面的数据

21:23.830 --> 21:26.830
就是表达式

21:26.830 --> 21:28.830
表达式

21:28.830 --> 21:31.830
返回的数据

21:31.830 --> 21:33.830
会作为

21:33.830 --> 21:35.830
当前迭代

21:35.830 --> 21:36.830
因为迭代是什么

21:36.830 --> 21:37.830
迭代就是Nex

21:37.830 --> 21:38.830
迭代一次

21:38.830 --> 21:39.830
迭代一次就调用Nex

21:39.830 --> 21:43.830
会作为当前迭代的数据

21:43.830 --> 21:44.830
什么意思呢

21:44.830 --> 21:45.830
比方说

21:45.830 --> 21:47.830
写上这么一个1

21:47.830 --> 21:48.830
写上这么一个2

21:48.830 --> 21:49.830
写上这么一个3

21:49.830 --> 21:50.830
E2的后面

21:50.830 --> 21:52.830
我们当时没有写东西对吧

21:52.830 --> 21:53.830
没有写东西就是undefined

21:53.830 --> 21:55.830
没有写东西就是undefined

21:55.830 --> 21:56.830
好

21:56.830 --> 21:57.830
那么这里呢

21:57.830 --> 21:58.830
我们可以写东西

21:58.830 --> 21:59.830
可以写字面量

21:59.830 --> 22:00.830
可以写边量

22:00.830 --> 22:02.830
可以写一个函数调用

22:02.830 --> 22:04.830
总之可以写个表达式

22:04.830 --> 22:05.830
它呢

22:05.830 --> 22:07.830
它会把这个表达式的返回结果

22:07.830 --> 22:10.830
作为这一次迭代的结果

22:10.830 --> 22:11.830
什么意思呢

22:11.830 --> 22:12.830
你看着

22:12.830 --> 22:13.830
我们又重新来一次

22:13.830 --> 22:14.830
一开始啥都没有

22:14.830 --> 22:15.830
为什么啥都没有

22:15.830 --> 22:16.830
因为我们没有调用Nex

22:16.830 --> 22:17.830
对吧

22:17.830 --> 22:18.830
没有调用Nex

22:18.830 --> 22:20.830
这里我们调用的是Nex

22:20.830 --> 22:21.830
好

22:21.830 --> 22:23.830
我这里没保存

22:23.830 --> 22:24.830
调用的是Nex

22:24.830 --> 22:26.830
你看一下

22:26.830 --> 22:27.830
第一次调用Nex的时候

22:27.830 --> 22:29.830
它从函数的最开始运行这句话

22:29.830 --> 22:30.830
对吧

22:30.830 --> 22:31.830
运行完这句话

22:31.830 --> 22:32.830
运行完这句话

22:32.830 --> 22:33.830
又运行这句话

22:33.830 --> 22:34.830
这个代码是要运行的

22:34.830 --> 22:35.830
是要运行的

22:35.830 --> 22:36.830
运行这个代码

22:36.830 --> 22:37.830
这个代码的E2的

22:37.830 --> 22:38.830
后面有个E

22:38.830 --> 22:39.830
停止的

22:39.830 --> 22:40.830
那么现在呢

22:40.830 --> 22:42.830
它就会直接把这个E

22:42.830 --> 22:43.830
作为数据返回

22:43.830 --> 22:44.830
它会返回一个什么东西呢

22:44.830 --> 22:45.830
它会返回这么一个东西

22:45.830 --> 22:47.830
Value为E

22:47.830 --> 22:48.830
Done为Force

22:48.830 --> 22:50.830
它就会返回这么一个东西

22:50.830 --> 22:52.830
那么就把这个东西交给谁了

22:52.830 --> 22:53.830
交给那个Nex

22:53.830 --> 22:55.830
就是Nex方法的返回结果

22:55.830 --> 22:56.830
就这么个意思

22:56.830 --> 22:57.830
所以Nex得到了

22:57.830 --> 22:58.830
这一次迭代

22:58.830 --> 22:59.830
它得到了的是什么数据呢

22:59.830 --> 23:00.830
得到的就是这个数据

23:00.830 --> 23:02.830
这一次迭代就是这个数据

23:02.830 --> 23:03.830
看懂了吗

23:03.830 --> 23:05.830
这一次迭代就是这个数据

23:05.830 --> 23:06.830
你看

23:06.830 --> 23:07.830
那么得到了的是Value

23:07.830 --> 23:08.830
Done Force

23:08.830 --> 23:09.830
现在停止了

23:09.830 --> 23:10.830
等待下一次迭代

23:10.830 --> 23:11.830
下一次迭代的话

23:11.830 --> 23:12.830
Nex是不是又继续运行

23:12.830 --> 23:13.830
对吧

23:13.830 --> 23:14.830
又继续运行

23:14.830 --> 23:15.830
运行这句话

23:15.830 --> 23:17.830
又运行到E有的

23:17.830 --> 23:18.830
是不是在这

23:18.830 --> 23:19.830
对吧

23:19.830 --> 23:20.830
又运行到E有的

23:20.830 --> 23:21.830
又运行到这

23:21.830 --> 23:22.830
运行到这的时候

23:22.830 --> 23:24.830
那么2作为这一次迭代的结果

23:24.830 --> 23:25.830
所以得到的结果

23:25.830 --> 23:26.830
Value为2

23:26.830 --> 23:27.830
Done为Force

23:27.830 --> 23:28.830
然后再运行

23:28.830 --> 23:29.830
是不是又继续运行

23:29.830 --> 23:30.830
运行这句话

23:30.830 --> 23:31.830
E有的3

23:31.830 --> 23:32.830
那么就把3

23:32.830 --> 23:34.830
作为这一次迭代的结果

23:34.830 --> 23:35.830
Value为3

23:35.830 --> 23:36.830
Done Force

23:36.830 --> 23:37.830
好

23:37.830 --> 23:38.830
然后再运行

23:38.830 --> 23:39.830
是没了

23:39.830 --> 23:40.830
运行这个就

23:40.830 --> 23:41.830
到函数结尾了

23:41.830 --> 23:42.830
好

23:42.830 --> 23:44.830
到了函数结尾之后

23:44.830 --> 23:46.830
Value自然为Undefined

23:46.830 --> 23:47.830
看没

23:47.830 --> 23:48.830
是不是这个意思

23:48.830 --> 23:49.830
Value自然为Undefined

23:49.830 --> 23:51.830
那就没数据了

23:51.830 --> 23:52.830
Done为True

23:52.830 --> 23:54.830
这就是E有的

23:54.830 --> 23:55.830
看到没

23:55.830 --> 23:56.830
这就是E有的

23:56.830 --> 23:58.830
这种方式

23:58.830 --> 23:59.830
那么一始终记住

23:59.830 --> 24:00.830
这个E有的

24:00.830 --> 24:01.830
后边的东西是什么

24:01.830 --> 24:03.830
是交给这个Nex的

24:03.830 --> 24:05.830
不是说交给谁的

24:05.830 --> 24:07.830
它是交给这个Nex的

24:07.830 --> 24:08.830
就是这一次迭代

24:08.830 --> 24:09.830
它会生成一个迭代结果

24:09.830 --> 24:10.830
把这个结果

24:10.830 --> 24:11.830
交给Nex

24:11.830 --> 24:13.830
你可以这样就想想

24:13.830 --> 24:14.830
好

24:14.830 --> 24:15.830
那么现在我们来关注

24:15.830 --> 24:16.830
最后一次

24:16.830 --> 24:18.830
最后一次

24:18.830 --> 24:19.830
好

24:19.830 --> 24:20.830
如果说是最后一次的话

24:20.830 --> 24:21.830
那么它得到的Value

24:21.830 --> 24:22.830
是Undefined

24:22.830 --> 24:23.830
看没

24:23.830 --> 24:24.830
Done为True

24:24.830 --> 24:25.830
Done为True没什么问题

24:25.830 --> 24:26.830
因为后面没有E有的了

24:26.830 --> 24:27.830
它运行到函数结尾了

24:27.830 --> 24:28.830
对吧

24:28.830 --> 24:29.830
运行到函数结尾了

24:29.830 --> 24:30.830
它没有E有的了

24:30.830 --> 24:31.830
因此

24:31.830 --> 24:32.830
它的Done为True

24:32.830 --> 24:33.830
这个没问题

24:33.830 --> 24:34.830
那么Value为Undefined

24:34.830 --> 24:35.830
那么这个Value

24:35.830 --> 24:36.830
能不能改

24:36.830 --> 24:37.830
就Done为True的时候

24:37.830 --> 24:38.830
Value能不能改

24:38.830 --> 24:39.830
改会去改它

24:39.830 --> 24:40.830
改它干嘛了

24:40.830 --> 24:41.830
对不对

24:41.830 --> 24:42.830
改它干嘛了

24:42.830 --> 24:43.830
没有必要去改它

24:43.830 --> 24:44.830
那么这个时候

24:44.830 --> 24:45.830
它是这样子

24:45.830 --> 24:48.830
函数的反回值

24:48.830 --> 24:51.830
就是生成器

24:51.830 --> 24:52.830
生成器

24:52.830 --> 24:54.830
函数的反回值

24:54.830 --> 24:56.830
会作为

24:56.830 --> 24:59.830
作为

24:59.830 --> 25:00.830
就是

25:00.830 --> 25:02.830
迭代结束时

25:02.830 --> 25:04.830
迭代结束时

25:04.830 --> 25:05.830
等Value

25:05.830 --> 25:06.830
因为这个函数

25:06.830 --> 25:07.830
我现在没有反回

25:07.830 --> 25:08.830
对吧

25:08.830 --> 25:09.830
没有反回任何东西

25:09.830 --> 25:10.830
那么这个时候

25:10.830 --> 25:12.830
它的Negas

25:12.830 --> 25:13.830
你看最后一次迭代

25:13.830 --> 25:14.830
最后一次迭代的Negas

25:14.830 --> 25:16.830
Value自然自然会Undefined

25:16.830 --> 25:17.830
因为你没有反回的话

25:17.830 --> 25:18.830
就相当于是你

25:18.830 --> 25:19.830
反回了一个Undefined

25:19.830 --> 25:20.830
相当于是这个

25:20.830 --> 25:21.830
是一样的效果

25:21.830 --> 25:22.830
好

25:22.830 --> 25:23.830
咱们看一下吧

25:25.830 --> 25:26.830
好

25:26.830 --> 25:27.830
你看一下

25:27.830 --> 25:28.830
最后一次不是Undefined

25:28.830 --> 25:29.830
对吧

25:29.830 --> 25:30.830
它到了函数莫为了

25:30.830 --> 25:31.830
那如果说你

25:31.830 --> 25:32.830
反回的一个就是结束

25:32.830 --> 25:33.830
反回一个支付刷结束

25:33.830 --> 25:34.830
好

25:34.830 --> 25:35.830
咱们再来看一下

25:35.830 --> 25:36.830
Negas

25:37.830 --> 25:38.830
你看

25:38.830 --> 25:39.830
最后一个Value

25:39.830 --> 25:40.830
是不是结束了

25:40.830 --> 25:41.830
对吧

25:41.830 --> 25:42.830
最后一次的Value

25:42.830 --> 25:43.830
它得到了是

25:43.830 --> 25:45.830
最后一次迭代的Value

25:45.830 --> 25:46.830
它得到了是

25:46.830 --> 25:47.830
函数的反回结果

25:48.830 --> 25:49.830
这个东西

25:49.830 --> 25:50.830
虽然说我们平时

25:50.830 --> 25:51.830
没这么用

25:51.830 --> 25:52.830
就了解一下就行了

25:52.830 --> 25:53.830
给我们Saga也没有什么关系

25:53.830 --> 25:54.830
有这个东西

25:54.830 --> 25:55.830
给我们Saga没什么关系

25:56.830 --> 25:57.830
但是这里

25:57.830 --> 25:59.830
大家要做一个小细节

25:59.830 --> 26:00.830
一个小细节就是

26:01.830 --> 26:02.830
但是

26:03.830 --> 26:05.830
如果在结束过后

26:06.830 --> 26:08.830
调用Negas

26:08.830 --> 26:11.830
则Value为Undefined

26:12.830 --> 26:13.830
这又是什么意思呢

26:13.830 --> 26:14.830
就是说

26:14.830 --> 26:15.830
如果我们Negas

26:15.830 --> 26:16.830
Negas

26:16.830 --> 26:17.830
Negas

26:17.830 --> 26:18.830
最后一次Value是结束

26:18.830 --> 26:19.830
如果说我们继续调用Negas

26:19.830 --> 26:20.830
它就变成Undefined了

26:20.830 --> 26:21.830
后面全是Undefined了

26:21.830 --> 26:22.830
你说我们这里

26:22.830 --> 26:24.830
应该怎么用文字来描述呢

26:24.830 --> 26:25.830
就是说

26:25.830 --> 26:26.830
当

26:26.830 --> 26:27.830
首次把档变成初的时候

26:27.830 --> 26:28.830
表示迭代结束嘛

26:28.830 --> 26:30.830
首次把档变成初的时候

26:30.830 --> 26:31.830
那个这个时候

26:31.830 --> 26:32.830
得到了是

26:32.830 --> 26:33.830
函数提的反回结果

26:33.830 --> 26:35.830
那么后面全部为Undefined

26:35.830 --> 26:37.830
就是这么一个小的细节

26:37.830 --> 26:38.830
平时呢

26:38.830 --> 26:39.830
我们也不太会用到

26:39.830 --> 26:41.830
这样的这么一个特点

26:41.830 --> 26:42.830
也不太会用到

26:42.830 --> 26:44.830
这是关于这一块

26:44.830 --> 26:45.830
好了

26:45.830 --> 26:46.830
了解了这么一些

26:46.830 --> 26:48.830
知识之后呢

26:48.830 --> 26:49.830
咱们来

26:49.830 --> 26:50.830
如果说来写一下

26:50.830 --> 26:51.830
之前的迭代器

26:51.830 --> 26:52.830
我们用生成器来写一下

26:52.830 --> 26:53.830
之前的迭代器的话

26:53.830 --> 26:54.830
因为发现

26:54.830 --> 26:56.830
有了生成器函数之后呢

26:56.830 --> 26:57.830
我们会发现

26:57.830 --> 26:58.830
迭代器就非常非常好写了

26:58.830 --> 26:59.830
比方说

26:59.830 --> 27:01.830
咱们写这么一个

27:01.830 --> 27:03.830
迭代器

27:04.830 --> 27:06.830
还是要迭代一个数组

27:06.830 --> 27:09.830
还是要迭代一个数组

27:09.830 --> 27:10.830
这里呢

27:10.830 --> 27:11.830
我们写上这么一个迭代器

27:11.830 --> 27:13.830
迭代器函数

27:13.830 --> 27:14.830
方形

27:14.830 --> 27:16.830
怎么迭代器函数

27:16.830 --> 27:17.830
就得到一个迭代器的

27:17.830 --> 27:19.830
这么一个东西

27:19.830 --> 27:21.830
我们就写上一个就是

27:21.830 --> 27:23.830
create

27:23.830 --> 27:25.830
atorator

27:25.830 --> 27:26.830
之前我们是不是写过的

27:26.830 --> 27:27.830
你给我一个数组

27:27.830 --> 27:28.830
对吧

27:28.830 --> 27:29.830
给我一个数组

27:29.830 --> 27:30.830
OK 我来帮你进行迭代

27:30.830 --> 27:32.830
给你生成一个迭代器

27:32.830 --> 27:33.830
好 那么我们现在知道了

27:33.830 --> 27:34.830
生成器本身

27:34.830 --> 27:35.830
它就是一个迭代器

27:35.830 --> 27:36.830
对吧

27:36.830 --> 27:37.830
生成器它里边是不是

27:37.830 --> 27:38.830
就是一个迭代器

27:38.830 --> 27:40.830
看一下笔记

27:40.830 --> 27:41.830
生成器呢

27:43.830 --> 27:44.830
生成器就是个对象

27:44.830 --> 27:45.830
对象就是一个迭代器

27:45.830 --> 27:46.830
对不对

27:46.830 --> 27:47.830
所以说我们完全可以把它

27:47.830 --> 27:48.830
变成一个生成器

27:48.830 --> 27:50.830
生成器不就是迭代器吗

27:50.830 --> 27:51.830
不就是个迭代器吗

27:51.830 --> 27:52.830
你给我传个参数

27:52.830 --> 27:54.830
传个参数

27:54.830 --> 27:56.830
那么传个参数过后呢

27:56.830 --> 27:57.830
我给你返回的

27:57.830 --> 27:58.830
它返回的肯定是一个生成器

27:58.830 --> 27:59.830
你啥都不写的

27:59.830 --> 28:00.830
返回的都是生成器

28:00.830 --> 28:01.830
好 那么现在呢

28:01.830 --> 28:02.830
我们就是它在迭代的时候

28:02.830 --> 28:03.830
我们要给它什么东西呢

28:03.830 --> 28:04.830
不是一个数组吗

28:04.830 --> 28:05.830
对不对

28:05.830 --> 28:06.830
OK 我就循环数组呗

28:06.830 --> 28:08.830
我就循环数组呗

28:08.830 --> 28:10.830
循环数组

28:10.830 --> 28:11.830
每一循环一次

28:11.830 --> 28:12.830
我们EO的Ital

28:12.830 --> 28:13.830
完了

28:13.830 --> 28:14.830
写完了

28:14.830 --> 28:15.830
你看一下吧

28:15.830 --> 28:16.830
怎么回事

28:16.830 --> 28:17.830
你看一下

28:17.830 --> 28:18.830
咱们呢

28:18.830 --> 28:19.830
跟之前用的用法一样

28:19.830 --> 28:21.830
Aterator

28:21.830 --> 28:23.830
当然 这里肯定是Generator

28:23.830 --> 28:24.830
肯定是Generator

28:24.830 --> 28:25.830
给它个数组吧

28:25.830 --> 28:27.830
123456

28:27.830 --> 28:29.830
解除这么一个数组

28:29.830 --> 28:31.830
这里呢 写上Generator

28:31.830 --> 28:33.830
当然它其实也是一个Aterator

28:33.830 --> 28:36.830
因为Generator就是一个Aterator

28:36.830 --> 28:39.830
好 那么看一下Generator

28:39.830 --> 28:40.830
那个是

28:40.830 --> 28:41.830
调用第一次

28:41.830 --> 28:42.830
好 调用第一次的时候

28:42.830 --> 28:43.830
才开始运行这个函数

28:43.830 --> 28:44.830
对吧

28:44.830 --> 28:45.830
这个函数不是一开始运行的

28:45.830 --> 28:46.830
是调用的时候才运行的

28:46.830 --> 28:47.830
调用第一次的时候

28:47.830 --> 28:48.830
是不是第一次徬循环

28:48.830 --> 28:49.830
对吧

28:49.830 --> 28:50.830
运行到

28:50.830 --> 28:52.830
是不是把数组的第一项

28:52.830 --> 28:53.830
作为什么

28:53.830 --> 28:54.830
作为第一次迭代的结果

28:54.830 --> 28:55.830
对不对

28:55.830 --> 28:57.830
你看一下

28:57.830 --> 28:58.830
换一面了

28:58.830 --> 28:59.830
换一面了

29:01.830 --> 29:02.830
Aterator

29:02.830 --> 29:03.830
Generator

29:03.830 --> 29:04.830
那个是

29:04.830 --> 29:05.830
第一次迭代

29:05.830 --> 29:06.830
是不是Value1

29:06.830 --> 29:07.830
当为Force

29:07.830 --> 29:08.830
对吧

29:08.830 --> 29:09.830
当为Force

29:09.830 --> 29:10.830
因为函数还没有结束

29:10.830 --> 29:11.830
所以说一定是当为Force

29:11.830 --> 29:12.830
好 那么等待

29:12.830 --> 29:14.830
因为现在是卡在哪

29:14.830 --> 29:16.830
是不是卡在下一次循环

29:16.830 --> 29:17.830
卡在下一次循环

29:17.830 --> 29:18.830
我们这样子

29:18.830 --> 29:19.830
用Four循环

29:19.830 --> 29:21.830
更加容易看得出来

29:22.830 --> 29:24.830
更加容易看得出来

29:24.830 --> 29:25.830
好 这里呢

29:25.830 --> 29:27.830
我们Eo的Element

29:27.830 --> 29:30.850
Item

29:31.850 --> 29:32.850
Eo的Item

29:32.850 --> 29:34.850
然后这里就是

29:36.850 --> 29:38.850
第几次迭代了

29:38.850 --> 29:39.850
我们这里

29:39.850 --> 29:40.850
这样子

29:42.850 --> 29:43.850
I次

29:43.850 --> 29:45.850
迭代

29:45.850 --> 29:46.850
迭代

29:46.850 --> 29:48.850
好 我们来看一下吧

29:48.850 --> 29:49.850
看一下

29:49.850 --> 29:50.850
好

29:50.850 --> 29:51.850
然后我们第一次调用

29:51.850 --> 29:52.850
第零次迭代

29:52.850 --> 29:53.850
对吧

29:53.850 --> 29:54.850
现在是不是运行完

29:54.850 --> 29:55.850
这句话

29:55.850 --> 29:56.850
第一次循环运行完了

29:56.850 --> 29:57.850
那么把这个东西

29:57.850 --> 29:58.850
是不是交给

29:58.850 --> 29:59.850
第一次迭代的结果

29:59.850 --> 30:00.850
第零次迭代的结果

30:00.850 --> 30:01.850
交给谁

30:01.850 --> 30:02.850
交给那个社返回

30:02.850 --> 30:03.850
变成白六一

30:03.850 --> 30:04.850
当为Force

30:04.850 --> 30:05.850
那么现在呢

30:05.850 --> 30:06.850
现在我们再运行

30:06.850 --> 30:07.850
再运行那个社

30:07.850 --> 30:08.850
是不是要继续循环了

30:08.850 --> 30:09.850
继续循环

30:09.850 --> 30:10.850
后面运行到这个单

30:10.850 --> 30:11.850
因为现在卡在这

30:11.850 --> 30:12.850
循环还没运行完

30:12.850 --> 30:13.850
还卡在这

30:13.850 --> 30:15.850
好 现在我们又运行

30:15.850 --> 30:16.850
是不是第一次迭代

30:16.850 --> 30:17.850
对不对

30:17.850 --> 30:18.850
就是下表尾一的一次迭代

30:18.850 --> 30:21.850
那么又把二二又传给这个

30:21.850 --> 30:22.850
二二又传给他了

30:22.850 --> 30:24.850
因为现在卡在这

30:24.850 --> 30:25.850
卡在这

30:25.850 --> 30:26.850
把这句话运行了

30:26.850 --> 30:27.850
他就不再运行了

30:27.850 --> 30:28.850
这句话运行了过后

30:28.850 --> 30:29.850
就不再运行了

30:29.850 --> 30:30.850
因为我已经得到了

30:30.850 --> 30:31.850
这一次迭代的结果

30:31.850 --> 30:32.850
我就不再往后面运行了

30:32.850 --> 30:33.850
后边就是后边

30:33.850 --> 30:34.850
迭代的事情了

30:34.850 --> 30:35.850
明白这个意思吗

30:35.850 --> 30:36.850
总之你看到这个EO的

30:36.850 --> 30:38.850
就表示

30:38.850 --> 30:39.850
只有外面掉到那个社

30:39.850 --> 30:40.850
才会运行到这个点

30:40.850 --> 30:41.850
运到这个点就停止了

30:41.850 --> 30:43.850
我把EO的

30:43.850 --> 30:44.850
后边的东西给力

30:44.850 --> 30:46.850
表示这一次迭代的结果

30:46.850 --> 30:47.850
那么我就停了

30:47.850 --> 30:48.850
不再运行了

30:48.850 --> 30:49.850
等待你

30:49.850 --> 30:50.850
等你什么呢

30:50.850 --> 30:51.850
等你下一次那个社的时候

30:51.850 --> 30:53.850
再继续运行

30:53.850 --> 30:54.850
那么

30:54.850 --> 30:55.850
一看一下

30:55.850 --> 30:56.850
是不是这样子

30:56.850 --> 30:57.850
是个逻辑吗

30:57.850 --> 30:58.850
你看

30:58.850 --> 30:59.850
后面就没了

30:59.850 --> 31:01.850
因为函数都运行结束了

31:01.850 --> 31:03.850
函数运行结束了

31:03.850 --> 31:04.850
我们再来个例子

31:04.850 --> 31:05.850
比方说

31:05.850 --> 31:07.850
我们在这里输出一句话

31:07.850 --> 31:10.850
就是函数结束

31:10.850 --> 31:11.850
那么这句话

31:11.850 --> 31:13.850
一开始会不会输出

31:13.850 --> 31:14.850
不会

31:14.850 --> 31:15.850
是不是一定要迭代

31:15.850 --> 31:16.850
把这个循环迭代

31:16.850 --> 31:17.850
运行完了过

31:17.850 --> 31:18.850
才会输出这句话

31:18.850 --> 31:20.850
因为循环是卡住的

31:20.850 --> 31:21.850
那个循环是卡住的

31:21.850 --> 31:22.850
你看

31:24.850 --> 31:26.850
这个时候才函数结束

31:26.850 --> 31:27.850
看到没有

31:27.850 --> 31:28.850
循环是被卡住的

31:28.850 --> 31:29.850
你看现在是不是可以通过

31:29.850 --> 31:31.850
外部来控制这个函数

31:31.850 --> 31:32.850
内部的执行了

31:32.850 --> 31:33.850
对不对

31:33.850 --> 31:34.850
就这么个意思

31:34.850 --> 31:36.850
就这么个意思

31:36.850 --> 31:37.850
好 关于这一点

31:37.850 --> 31:39.850
那么我们再来说一个问题

31:39.850 --> 31:40.850
就是说

31:40.850 --> 31:41.850
如果说

31:41.850 --> 31:44.850
你提前结束了函数了

31:44.850 --> 31:46.850
如果说你提前结束了函数了

31:46.850 --> 31:47.850
比方说在这里

31:47.850 --> 31:48.850
我们这里就

31:48.850 --> 31:50.850
这里就直接return了

31:50.850 --> 31:52.850
那里会怎么样呢

31:52.850 --> 31:54.850
你觉得会怎么样吗

31:54.850 --> 31:56.850
那里说会怎么样呢

31:56.850 --> 31:58.850
这个没什么

31:58.850 --> 32:00.850
没什么特别的

32:00.850 --> 32:01.850
第一次调用

32:01.850 --> 32:02.850
从函数最开始调用

32:02.850 --> 32:04.850
运行到这对吧

32:04.850 --> 32:05.850
运行到一有了这

32:05.850 --> 32:06.850
是不是停止了

32:06.850 --> 32:07.850
这个时候有没有运行return

32:07.850 --> 32:08.850
没有

32:08.850 --> 32:09.850
停在这了

32:09.850 --> 32:11.850
就把这个值给它的过后

32:11.850 --> 32:12.850
把我们这次迭代的结果

32:12.850 --> 32:13.850
给它的过后就停了

32:13.850 --> 32:14.850
这句话运行完了

32:14.850 --> 32:16.850
但是没有继续往后运行的

32:16.850 --> 32:17.850
然后下一次

32:17.850 --> 32:18.850
再运行那个是

32:18.850 --> 32:19.850
函数是不是结束了

32:19.850 --> 32:20.850
函数结束了

32:20.850 --> 32:21.850
是不是value undefined

32:21.850 --> 32:22.850
当为q

32:22.850 --> 32:23.850
对不对

32:23.850 --> 32:24.850
当为q

32:24.850 --> 32:25.850
就这么简单

32:25.850 --> 32:26.850
后面还可能运行吗

32:26.850 --> 32:28.850
是不是永远不可能运行的

32:28.850 --> 32:29.850
函数都结束了

32:29.850 --> 32:30.850
函数结束了

32:30.850 --> 32:32.850
是永远不可能运行的

32:32.850 --> 32:33.850
看没

32:33.850 --> 32:34.850
就这么个意思

32:34.850 --> 32:37.850
这是关于

32:37.850 --> 32:39.850
这个细节

32:39.850 --> 32:40.850
下一个

32:40.850 --> 32:42.850
它就是非常非常绕的地方了

32:42.850 --> 32:43.850
就是说

32:43.850 --> 32:46.850
生成器

32:46.850 --> 32:48.850
生成器

32:48.850 --> 32:51.850
雕用next的时候

32:51.850 --> 32:54.850
可以传递参数

32:54.850 --> 32:56.850
可以传递参数

32:56.850 --> 32:57.850
该参数

32:57.850 --> 33:00.850
会作为

33:00.850 --> 33:02.850
生成器

33:02.850 --> 33:04.850
生成器

33:04.850 --> 33:06.850
函数体

33:06.850 --> 33:07.850
上一次

33:07.850 --> 33:09.850
eal的

33:09.850 --> 33:11.850
表达式的值

33:11.850 --> 33:13.850
上一次eal的表达式的值

33:13.850 --> 33:15.850
是什么意思呢

33:15.850 --> 33:16.850
咱们来看个例子

33:16.850 --> 33:21.760
通过一个例子来说明

33:21.760 --> 33:22.760
TES-3

33:22.760 --> 33:24.760
现在我们这样子来写了

33:24.760 --> 33:30.740
这是运行eal

33:30.740 --> 33:32.740
我们这里用一个变量

33:32.740 --> 33:37.620
用个变量result

33:37.620 --> 33:38.620
这里面

33:38.620 --> 33:40.620
我们复制一下

33:40.620 --> 33:43.190
把这个去掉

33:43.190 --> 33:47.140
这个加上

33:47.140 --> 33:48.140
行了

33:48.140 --> 33:50.140
这里result都加上

33:50.140 --> 33:51.140
也就是说

33:51.140 --> 33:53.140
我们现在写成这么一种格式了

33:53.140 --> 33:54.140
写成这么一种格式了

33:54.140 --> 33:55.140
eal的eal

33:55.140 --> 33:57.140
把它复制给什么result

33:57.140 --> 34:00.140
这种格式非常非常容易造成误解

34:00.140 --> 34:03.140
很多同学在这里都绕云了

34:03.140 --> 34:04.140
为什么呢

34:04.140 --> 34:05.140
因为他看这个代码

34:05.140 --> 34:06.140
一看就感觉好像是把

34:06.140 --> 34:08.140
一复制给result对吧

34:08.140 --> 34:10.140
不是的

34:10.140 --> 34:13.140
它是把什么东西复制给result

34:13.140 --> 34:17.140
看着它是这样子的

34:17.140 --> 34:18.140
首先我们这里调用

34:18.140 --> 34:20.140
generate它的next

34:20.140 --> 34:22.140
这个函数里边是可以传参的

34:22.140 --> 34:23.140
是可以传参的

34:23.140 --> 34:25.140
比方说我传一个a进去

34:25.140 --> 34:26.140
传参的

34:26.140 --> 34:28.140
一回车

34:28.140 --> 34:29.140
那么现在的运行

34:29.140 --> 34:31.140
是不是从函数里提一开始运行

34:31.140 --> 34:33.140
那么第一次传参

34:33.140 --> 34:35.140
无意义没有任何意义

34:35.140 --> 34:37.140
我们这里记一遍

34:37.140 --> 34:39.140
生成器

34:39.140 --> 34:43.140
第一次调用next

34:43.140 --> 34:47.140
next函数时

34:47.140 --> 34:50.140
传递参数没有任何意义

34:50.140 --> 34:52.140
当然你传的还也不会爆错

34:52.140 --> 34:53.140
总之没有任何意义

34:53.140 --> 34:54.140
所以第一次传参的话

34:54.140 --> 34:55.140
到无所谓

34:55.140 --> 34:56.140
你不传也无所谓

34:56.140 --> 34:57.140
反正没有意义

34:57.140 --> 34:58.140
那为什么没有意义

34:58.140 --> 34:59.140
以后你就知道了

34:59.140 --> 35:00.140
那么这个时候

35:00.140 --> 35:02.140
按照我们刚才说的运行

35:02.140 --> 35:03.140
运行到哪儿的

35:03.140 --> 35:05.140
看一下

35:05.140 --> 35:06.140
我们来看一下

35:06.140 --> 35:07.140
关键是看

35:07.140 --> 35:09.140
你要理解它运行到哪儿的

35:09.140 --> 35:10.140
这小三

35:10.140 --> 35:11.140
运行到哪儿的

35:11.140 --> 35:12.140
它运行到这句话

35:12.140 --> 35:13.140
对吧

35:13.140 --> 35:14.140
从一开始开始运行

35:14.140 --> 35:15.140
停在哪儿

35:15.140 --> 35:16.140
是不是停在这儿

35:16.140 --> 35:17.140
注意哦

35:17.140 --> 35:18.140
不是停在整个这句话

35:18.140 --> 35:19.140
它是这样子

35:19.140 --> 35:20.140
运行到这句话

35:20.140 --> 35:21.140
下面就是复制

35:21.140 --> 35:23.140
把右边的表达

35:23.140 --> 35:24.140
是复制给result

35:24.140 --> 35:25.140
对吧

35:25.140 --> 35:26.140
那么先要运算

35:26.140 --> 35:27.140
右边的表达是

35:27.140 --> 35:29.140
右边的表达是一个E有的

35:29.140 --> 35:30.140
那是不是要停止

35:30.140 --> 35:31.140
我把E

35:31.140 --> 35:33.140
作为这一次的

35:33.140 --> 35:34.140
迭代结果

35:34.140 --> 35:36.140
将E

35:36.140 --> 35:38.140
作为

35:38.140 --> 35:39.140
第一次的

35:39.140 --> 35:41.140
迭代结果

35:41.140 --> 35:43.140
迭代的值

35:43.140 --> 35:44.140
那么这一次

35:44.140 --> 35:45.140
就把E

35:45.140 --> 35:46.140
给到谁了

35:46.140 --> 35:47.140
是不是给到Legas

35:47.140 --> 35:48.140
对吧

35:48.140 --> 35:49.140
是不是给到Legas的Value

35:49.140 --> 35:50.140
对不对

35:50.140 --> 35:51.140
给到Hala

35:51.140 --> 35:52.140
那么这个时候

35:52.140 --> 35:54.140
这一句话运行完了

35:54.140 --> 35:55.140
停了

35:55.140 --> 35:56.140
不动了

35:56.140 --> 35:58.140
代码是停在这儿的

35:58.140 --> 36:00.140
它还没有完成复制

36:00.140 --> 36:01.140
这个时候还没有复制

36:01.140 --> 36:02.140
它只是把这个表达

36:02.140 --> 36:03.140
是运行的

36:03.140 --> 36:04.140
因为这个表达

36:04.140 --> 36:05.140
是一个E有的

36:05.140 --> 36:06.140
所以它只能停止

36:06.140 --> 36:07.140
只能停止

36:07.140 --> 36:08.140
它等待什么呢

36:08.140 --> 36:10.140
等待你的召唤

36:10.140 --> 36:11.140
下一次运行

36:11.140 --> 36:12.140
我才去复制

36:12.140 --> 36:13.140
我再去复制

36:13.140 --> 36:14.140
再去运行

36:14.140 --> 36:15.140
后面的代码

36:15.140 --> 36:16.140
下一次运行

36:16.140 --> 36:17.140
那个时候再复制

36:17.140 --> 36:18.140
那么下一次

36:18.140 --> 36:19.140
我运行那个时候

36:19.140 --> 36:20.140
给它传了个B进去

36:20.140 --> 36:21.140
给它传一个A

36:21.140 --> 36:22.140
是不是一样的

36:22.140 --> 36:23.140
对吧

36:23.140 --> 36:25.140
现在我们再给它传一个B

36:25.140 --> 36:26.140
一回车

36:26.140 --> 36:27.140
你看着

36:27.140 --> 36:28.140
它又怎么回事

36:28.140 --> 36:30.140
上一次停在哪儿的

36:30.140 --> 36:31.140
上一次是不是停在这儿的

36:31.140 --> 36:32.140
对吧

36:32.140 --> 36:33.140
上一次生存器在这儿停了

36:33.140 --> 36:34.140
一回车

36:34.140 --> 36:35.140
一回车

36:35.140 --> 36:36.140
一回车

36:36.140 --> 36:37.140
一回车

36:37.140 --> 36:38.140
一回车

36:38.140 --> 36:39.140
一回车

36:39.140 --> 36:40.140
一回车

36:40.140 --> 36:41.140
一回车

36:41.140 --> 36:42.140
一回车

36:42.140 --> 36:43.140
一回车

36:43.140 --> 36:44.140
一回车

36:44.140 --> 36:45.140
一回车

36:45.140 --> 36:46.140
一回车

36:46.140 --> 36:47.140
一回车

36:47.140 --> 36:48.140
一回车

36:48.140 --> 36:49.140
一回车

36:49.140 --> 36:50.140
生存器在这儿停了

36:50.140 --> 36:51.140
好

36:51.140 --> 36:52.140
那么等待你的召唤

36:52.140 --> 36:53.140
怎么召唤

36:53.140 --> 36:54.140
又掉了那个车

36:54.140 --> 36:55.140
给它传那个B进去

36:55.140 --> 36:56.140
那么这个B

36:56.140 --> 36:58.140
就会把作为上一次

36:58.140 --> 36:59.140
就是整个这个E2的

36:59.140 --> 37:00.140
表达式的返回结果

37:00.140 --> 37:01.140
那么

37:01.140 --> 37:02.140
这个时候继续运行

37:02.140 --> 37:03.140
上一次

37:03.140 --> 37:04.140
因为上一次停在这儿

37:04.140 --> 37:05.140
对不对

37:05.140 --> 37:06.140
它等待等这里

37:06.140 --> 37:07.140
那么这里

37:07.140 --> 37:08.140
给它一个B

37:08.140 --> 37:09.140
那么它就会把这个B

37:09.140 --> 37:11.140
作为整个表达式的结果

37:11.140 --> 37:12.140
传递给result

37:12.140 --> 37:13.140
你看

37:13.140 --> 37:14.140
外面的

37:14.140 --> 37:15.140
外面的一个生存器

37:15.140 --> 37:16.140
是不是完全可以

37:16.140 --> 37:17.140
控制这里边的东西

37:17.140 --> 37:18.140
对吧

37:18.140 --> 37:19.140
有E2的地方

37:19.140 --> 37:20.140
那没有E2的地方

37:20.140 --> 37:21.140
我控制不了

37:21.140 --> 37:22.140
这一代码是正常运行的

37:22.140 --> 37:23.140
控制不了

37:23.140 --> 37:24.140
但是有E2的地方

37:24.140 --> 37:26.140
我是完全可以控制它的

37:26.140 --> 37:28.140
我还可以控制它的返回结果

37:28.140 --> 37:29.140
那么它会把这个

37:29.140 --> 37:31.140
那个时候传递到参数B

37:31.140 --> 37:33.140
传递到参数B

37:33.140 --> 37:34.140
给谁呢

37:34.140 --> 37:36.140
给这个result

37:36.140 --> 37:37.140
给这个result

37:37.140 --> 37:38.140
那么这里是不是输出

37:38.140 --> 37:39.140
继续运行

37:39.140 --> 37:40.140
这是正常代码

37:40.140 --> 37:41.140
没有什么问题

37:41.140 --> 37:42.140
输出这个B

37:42.140 --> 37:43.140
看没有

37:43.140 --> 37:44.140
输出这个B

37:44.140 --> 37:45.140
好

37:45.140 --> 37:46.140
然后呢

37:46.140 --> 37:47.140
又运行到这句话

37:47.140 --> 37:48.140
我现在又把

37:48.140 --> 37:50.140
将2

37:50.140 --> 37:52.140
将2作为

37:52.140 --> 37:54.140
第二次

37:54.140 --> 37:56.140
迭代的值

37:56.140 --> 37:58.140
迭代的值

37:58.140 --> 37:59.140
对吧

37:59.140 --> 38:00.140
迭代的值

38:00.140 --> 38:01.140
那么又卡在这了

38:01.140 --> 38:02.140
对吧

38:02.140 --> 38:03.140
卡在这了

38:03.140 --> 38:04.140
又要等待

38:04.140 --> 38:05.140
等待你下一次召唤

38:05.140 --> 38:06.140
那么于是呢

38:06.140 --> 38:07.140
第二次调用

38:07.140 --> 38:08.140
你看看

38:08.140 --> 38:09.140
第二次调用

38:09.140 --> 38:10.140
它是不是得到2

38:10.140 --> 38:11.140
得到2

38:11.140 --> 38:12.140
好

38:12.140 --> 38:13.140
现在又卡在这了

38:13.140 --> 38:14.140
等待你召唤

38:14.140 --> 38:15.140
好

38:15.140 --> 38:16.140
那么现在是不是

38:16.140 --> 38:17.140
把C

38:17.140 --> 38:18.140
作为上一次的运行结果

38:18.140 --> 38:19.140
反而给它

38:19.140 --> 38:20.140
对吧

38:20.140 --> 38:21.140
给它

38:21.140 --> 38:22.140
然后又运行运行

38:22.140 --> 38:23.140
这里输出啥

38:23.140 --> 38:24.140
输出C

38:24.140 --> 38:25.140
然后呢

38:25.140 --> 38:26.140
这里

38:26.140 --> 38:27.140
是不是又卡在这了

38:27.140 --> 38:28.140
又把3

38:28.140 --> 38:29.140
作为第三次的迭代结果

38:29.140 --> 38:30.140
你看

38:30.140 --> 38:31.140
又等于3

38:31.140 --> 38:32.140
又等待你召唤了

38:32.140 --> 38:33.140
对吧

38:33.140 --> 38:34.140
如果说你没有传参数

38:34.140 --> 38:35.140
没有传参就是undefine

38:35.140 --> 38:36.140
没有传参数

38:36.140 --> 38:37.140
那么就相当于

38:37.140 --> 38:38.140
传了一个undefine进去

38:38.140 --> 38:39.140
那么它就会

38:39.140 --> 38:40.140
undefine负责给它

38:40.140 --> 38:41.140
然后这里

38:41.140 --> 38:42.140
输出undefine

38:42.140 --> 38:43.140
总之

38:43.140 --> 38:46.140
在生成器寒树内部

38:46.140 --> 38:48.140
只要出现eod的地方

38:48.140 --> 38:50.140
是受到外部控制的

38:50.140 --> 38:51.140
没有出现eod的地方

38:51.140 --> 38:52.140
不管

38:52.140 --> 38:53.140
执行到这儿

38:53.140 --> 38:54.140
它就一次执行就完事了

38:54.140 --> 38:56.140
只要你出现了eod

38:56.140 --> 38:57.140
那么整个反回的

38:57.140 --> 38:58.140
反反回的值

38:58.140 --> 38:59.140
也是外部控制

38:59.140 --> 39:00.140
外部控制

39:00.140 --> 39:02.140
可以控制这个关键点

39:02.140 --> 39:03.140
你可以把这些地方

39:03.140 --> 39:04.140
当中关键点

39:04.140 --> 39:06.140
就是3次迭代结果

39:06.140 --> 39:07.140
对不对

39:07.140 --> 39:08.140
一共有3次迭代结果

39:08.140 --> 39:09.140
每一次迭代结果

39:09.140 --> 39:10.140
那么在寒树体内部

39:10.140 --> 39:11.140
它反回的值是什么

39:11.140 --> 39:12.140
都是可以控制的

39:12.140 --> 39:15.140
外面是用next来进行控制

39:15.140 --> 39:17.140
那么我建议大家

39:17.140 --> 39:18.140
先停下来

39:18.140 --> 39:19.140
先不要着急往后面学了

39:19.140 --> 39:20.140
因为这一块

39:20.140 --> 39:21.140
特别特别糟

39:21.140 --> 39:23.140
大家先把这个寒树写一遍

39:23.140 --> 39:24.140
写出这么样的

39:24.140 --> 39:25.140
一个类似的效果

39:25.140 --> 39:26.140
来体会一下

39:26.140 --> 39:27.140
它这个反回值

39:27.140 --> 39:28.140
是从哪里来的

39:28.140 --> 39:30.140
一定要区分开

39:30.140 --> 39:31.140
它不是说在这里

39:31.140 --> 39:33.140
把这个e给它的值

39:33.140 --> 39:34.140
一定不是这个意思

39:34.140 --> 39:35.140
一定不是这个意思

39:35.140 --> 39:38.140
是外面的给它的

39:38.140 --> 39:40.140
是外面的给它的

39:40.140 --> 39:41.140
这个意思

39:45.580 --> 39:47.580
那么如果说

39:47.580 --> 39:49.580
我就要把

39:49.580 --> 39:50.580
如果说外面不是外面控制吗

39:50.580 --> 39:51.580
对吧

39:51.580 --> 39:52.580
外面就是要把上一次的

39:52.580 --> 39:53.580
得到的

39:53.580 --> 39:55.580
上一次生存期迭代的值

39:55.580 --> 39:56.580
复制给

39:56.580 --> 39:57.580
作为表达式的值

39:57.580 --> 39:58.580
复制给它

39:58.580 --> 39:59.580
那我就要把

39:59.580 --> 40:00.580
比方说把这个e复制给它

40:00.580 --> 40:01.580
把这个2复制给它

40:01.580 --> 40:02.580
那外面应该怎么写

40:02.580 --> 40:03.580
怎么样的代码呢

40:03.580 --> 40:04.580
我们可以这样子写

40:04.580 --> 40:05.580
可以这样子写

40:05.580 --> 40:07.580
generator

40:07.580 --> 40:08.580
那个是

40:08.580 --> 40:09.580
这就解释了

40:09.580 --> 40:10.580
为什么一开始传那个是没用

40:10.580 --> 40:11.580
还是都还没开始运行

40:11.580 --> 40:12.580
对吧

40:12.580 --> 40:13.580
那你不存在上一个

40:13.580 --> 40:15.580
停顿的e复的表达式

40:15.580 --> 40:16.580
不存在上一个e复的

40:16.580 --> 40:17.580
所以说你给它复

40:17.580 --> 40:18.580
复这个值没意义

40:18.580 --> 40:20.580
这个值的意思呢

40:20.580 --> 40:21.580
这个传输的意思是指的是

40:21.580 --> 40:22.580
上一个停顿的e复的

40:22.580 --> 40:24.580
它等于表达式的值是多少

40:24.580 --> 40:25.580
所以第一次无所谓

40:25.580 --> 40:26.580
直接运行一晚上

40:26.580 --> 40:27.580
好 下面这一次

40:27.580 --> 40:30.580
generator

40:30.580 --> 40:31.580
上面这一次那个时候

40:31.580 --> 40:32.580
是不是运行过后

40:32.580 --> 40:33.580
会得到一个结果

40:33.580 --> 40:34.580
对吧

40:34.580 --> 40:35.580
会得到一个结果

40:35.580 --> 40:36.580
result

40:36.580 --> 40:37.580
没问题吧

40:37.580 --> 40:38.580
得到一个结果

40:38.580 --> 40:39.580
那么下一次那个时候

40:39.580 --> 40:40.580
是不是

40:40.580 --> 40:43.580
我可以把上一次的结果result

40:43.580 --> 40:45.580
上一次的y6值传练进去

40:45.580 --> 40:47.580
作为传输

40:47.580 --> 40:48.580
看一下吧

40:48.580 --> 40:49.580
看一下

40:49.580 --> 40:50.580
我们这里用了两个dx

40:50.580 --> 40:51.580
看一下输出什么

40:51.580 --> 40:53.580
是不是开始运行e

40:53.580 --> 40:54.580
对不对

40:54.580 --> 40:55.580
这里输出了e

40:55.580 --> 40:56.580
是不是把上一次的结果给它了

40:56.580 --> 40:58.580
那么都result是不是e

40:58.580 --> 40:59.580
怎么回事

40:59.580 --> 41:00.580
好 第一次那个时候运行

41:00.580 --> 41:01.580
是不是运行在这里

41:01.580 --> 41:02.580
这句话

41:02.580 --> 41:03.580
好 运行到哪儿停止

41:03.580 --> 41:04.580
是不是运行到这儿停止

41:04.580 --> 41:06.580
表示我要返回一个

41:06.580 --> 41:07.580
迭代的值了

41:07.580 --> 41:08.580
把这个e

41:08.580 --> 41:10.580
是不是扔到result里边

41:10.580 --> 41:11.580
这个result是啥

41:11.580 --> 41:12.580
这个result是啥

41:12.580 --> 41:14.580
result是不是value为e

41:14.580 --> 41:16.580
当为force

41:16.580 --> 41:17.580
对吧

41:17.580 --> 41:18.580
value为e 当为force

41:18.580 --> 41:19.580
把这个e给到它

41:19.580 --> 41:20.580
给到它这个value了

41:20.580 --> 41:21.580
好

41:21.580 --> 41:22.580
那么现在停在这儿了

41:22.580 --> 41:23.580
对吧

41:23.580 --> 41:24.580
那下一次运行

41:24.580 --> 41:25.580
我就把上一次的那个value

41:25.580 --> 41:27.580
上一次的那个value

41:27.580 --> 41:28.580
作为传输传练来

41:28.580 --> 41:29.580
那么这样子一来

41:29.580 --> 41:31.580
上一次停动那个位置

41:31.580 --> 41:32.580
是不是就得到了

41:32.580 --> 41:33.580
上一次的返回结果

41:33.580 --> 41:35.580
就把值给到result

41:35.580 --> 41:36.580
就把这个value e

41:36.580 --> 41:38.580
传递给了这个result

41:38.580 --> 41:39.580
又继续运行

41:40.580 --> 41:42.580
那么后边是不是一样的

41:42.580 --> 41:43.580
后边是不是一样的

41:43.580 --> 41:44.580
那这里如果说

41:44.580 --> 41:45.580
我要把全部运行完的话

41:45.580 --> 41:46.580
我可以写这么一个循环

41:46.580 --> 41:47.580
看着

41:47.580 --> 41:49.580
我可以写这么一个循环

41:49.580 --> 41:50.580
那么这里

41:50.580 --> 41:51.580
我们只要判断

41:51.580 --> 41:52.580
while

41:53.580 --> 41:54.580
result

41:54.580 --> 41:55.580
当

41:55.580 --> 41:56.580
是不是已经完成

41:56.580 --> 41:58.580
是不是已经完成

41:58.580 --> 41:59.580
如果说result

41:59.580 --> 42:00.580
当

42:00.580 --> 42:02.580
如果说它没有完成

42:02.580 --> 42:03.580
那么继续循环

42:03.580 --> 42:04.580
如果说没有完成

42:04.580 --> 42:06.580
就是有迭代的值

42:06.580 --> 42:08.580
有迭代的值

42:08.580 --> 42:09.580
那怎么办呢

42:09.580 --> 42:10.580
怎么办呢

42:10.580 --> 42:11.580
我就要

42:11.580 --> 42:12.580
继续迭代

42:12.580 --> 42:14.580
继续进行下一次迭代

42:14.580 --> 42:15.580
继续进行下一次迭代

42:15.580 --> 42:16.580
那么我们这里

42:16.580 --> 42:18.580
把result

42:18.580 --> 42:19.580
重新复制

42:19.580 --> 42:20.580
generator

42:20.580 --> 42:21.580
那个时候

42:21.580 --> 42:22.580
重新调用那个时候

42:22.580 --> 42:23.580
是不是要进行下一次迭代

42:23.580 --> 42:24.580
好 下一次迭代的时候

42:24.580 --> 42:26.580
要把之前那一次迭代的结果

42:26.580 --> 42:27.580
给它一个值

42:27.580 --> 42:28.580
给它什么值呢

42:28.580 --> 42:30.580
给它之前的那个value

42:30.580 --> 42:32.580
那么就可以这样子写

42:32.580 --> 42:33.580
保存 你看一下

42:33.580 --> 42:34.580
声音出来了

42:34.580 --> 42:35.580
那你看一下

42:35.580 --> 42:37.580
声音进行函数的函数体

42:37.580 --> 42:39.580
开始运行一 二 三

42:39.580 --> 42:40.580
那么result

42:40.580 --> 42:41.580
这里得到一

42:41.580 --> 42:43.580
这里得到二 这里得到三

42:43.580 --> 42:45.580
好好看一下这个代码

42:45.580 --> 42:47.580
这个代码要好好去体会

42:47.580 --> 42:49.580
好好去体会一下这个代码

42:49.580 --> 42:50.580
总之

42:50.580 --> 42:51.580
这个表达式的值

42:51.580 --> 42:53.580
一定不可能说

42:53.580 --> 42:55.580
它是直接把这个值返过来的

42:55.580 --> 42:56.580
它一定是在那个时候

42:56.580 --> 42:57.580
里面给它传辑的值

42:57.580 --> 42:58.580
一定是在那个时候

42:58.580 --> 42:59.580
里面给它传辑的值

42:59.580 --> 43:01.580
那么EO的后边的表达式

43:01.580 --> 43:03.580
它是作为迭代的值

43:03.580 --> 43:04.580
返回到EO

43:04.580 --> 43:06.580
返回到那个时候里面

43:06.580 --> 43:08.580
它形成了这么一种结构

43:08.580 --> 43:10.580
这个地方我为什么没画图

43:10.580 --> 43:11.580
画图都不好画

43:11.580 --> 43:13.580
我告诉你 这画图都真的不好画

43:13.580 --> 43:15.580
你只能去慢慢去体会这个理解

43:15.580 --> 43:17.580
你只要记住

43:17.580 --> 43:19.580
只要EO的后边的表达式

43:19.580 --> 43:21.580
它一定是交给那个时候来处理的

43:21.580 --> 43:22.580
它一定不是

43:22.580 --> 43:24.580
想象的 大家想象的

43:24.580 --> 43:25.580
一错当难的

43:25.580 --> 43:26.580
好像这个表达式运行的

43:26.580 --> 43:27.580
就复制给它了

43:27.580 --> 43:28.580
一定不是这个样子

43:28.580 --> 43:29.580
它一定会转折一下

43:29.580 --> 43:30.580
把这个东西交给那个时候

43:30.580 --> 43:32.580
因为它受外部控制

43:32.580 --> 43:33.580
它如果不交给那个时候

43:33.580 --> 43:34.580
怎么来控制呢

43:34.580 --> 43:35.580
它交给那个时候

43:35.580 --> 43:37.580
然后停止

43:37.580 --> 43:38.580
下一次那个时候

43:38.580 --> 43:39.580
传辑的数据

43:39.580 --> 43:41.580
就是接着运行

43:41.580 --> 43:43.580
传辑过来 接着运行

43:43.580 --> 43:45.580
就形成了这么一种逻辑

43:47.580 --> 43:48.580
咱们这里

43:48.580 --> 43:49.580
再来个例子

43:49.580 --> 43:51.580
因为最核心的就是这一块

43:51.580 --> 43:54.580
就是怎么往它那边返回一个数据

43:54.580 --> 43:56.580
怎么来得到EO的值

43:56.580 --> 43:57.580
这是最核心的

43:57.580 --> 43:59.580
咱们再来个例子

43:59.580 --> 44:00.580
再来个例子

44:00.580 --> 44:04.580
我们由于那个实际点的例子

44:04.580 --> 44:06.580
因为这个生成器这一块

44:06.580 --> 44:08.580
它提供了这么一种特殊的场景

44:08.580 --> 44:09.580
所以说

44:09.580 --> 44:12.580
我们现在有能力在函数外部

44:12.580 --> 44:14.580
来控制函数内部的执行

44:14.580 --> 44:16.580
并且在EO的关键值那个点

44:16.580 --> 44:19.580
我们可以控制到它反回的值

44:19.580 --> 44:20.580
由于这个特性存在

44:20.580 --> 44:23.580
我们可以来解决一些异部问题

44:23.580 --> 44:25.580
来看一个例子

44:25.580 --> 44:27.580
我们在ES6的时候

44:27.580 --> 44:29.580
我们讲过这么一个东西

44:29.580 --> 44:31.580
就是Promise

44:31.580 --> 44:33.580
Promise呢

44:33.580 --> 44:36.580
它肯定要比回调要好那么一点

44:36.580 --> 44:38.580
但是它就形成了一种

44:38.580 --> 44:40.580
标准格式的回调

44:40.580 --> 44:41.580
它没有消灭回调

44:41.580 --> 44:44.580
它形成了一种标准格式的回调

44:44.580 --> 44:46.580
但是Promise

44:46.580 --> 44:48.580
用起来还是不是那么好用

44:48.580 --> 44:49.580
所以说ES7

44:49.580 --> 44:51.580
那个时候才出来了

44:51.580 --> 44:52.580
Athink and Wait

44:52.580 --> 44:53.580
这两个关键值

44:53.580 --> 44:54.580
有了这两个关键值过后

44:54.580 --> 44:56.580
就变成异部的终极解决方案了

44:57.580 --> 44:58.580
大家想过没有

44:58.580 --> 45:01.580
那ES6出来了过后

45:01.580 --> 45:04.580
ES7成为标准之前

45:04.580 --> 45:06.580
这段时间大家是怎么过的呢

45:06.580 --> 45:07.580
日子是怎么过的呢

45:07.580 --> 45:09.580
全部要写Promise 认

45:09.580 --> 45:10.580
然后再认

45:10.580 --> 45:11.580
对吧

45:11.580 --> 45:12.580
要写这些东西

45:12.580 --> 45:13.580
日子不好过

45:13.580 --> 45:15.580
那这个时候怎么办呢

45:15.580 --> 45:17.580
这个时候我们就可以利用

45:17.580 --> 45:19.580
ES6的EO的

45:19.580 --> 45:22.580
就是利用ES6的生成器

45:22.580 --> 45:24.580
函数来解决这样的问题

45:24.580 --> 45:26.580
这也是Saga

45:26.580 --> 45:28.580
我们后面要讲的Saga

45:28.580 --> 45:29.580
他为什么要选择生成器的

45:29.580 --> 45:31.580
一个很重要的原因

45:31.580 --> 45:33.580
因为生成器有这个东西过后

45:33.580 --> 45:35.580
我们可以解决异部的

45:35.580 --> 45:37.580
函数代码丑陋的问题

45:37.580 --> 45:39.580
当然ES7过后

45:39.580 --> 45:41.580
肯定是用Ethink而为者

45:41.580 --> 45:42.580
更加舒服一点

45:42.580 --> 45:44.580
但是在ES7出来了

45:44.580 --> 45:45.580
因为Saga出现的时间

45:45.580 --> 45:46.580
是在ES7之前

45:46.580 --> 45:48.580
说那个时候还没有Ethink而为者

45:48.580 --> 45:49.580
所以他想出来的

45:49.580 --> 45:50.580
用这种生成器的办法

45:50.580 --> 45:51.580
当然这个办法

45:51.580 --> 45:52.580
也不是用塌床的想出来的

45:52.580 --> 45:54.580
就早就有人在这样子去用了

45:54.580 --> 45:56.580
只不过他介绍了这种方式

45:56.580 --> 45:58.580
咱们来看一下吧

45:58.580 --> 46:00.580
说这么多来看一下

46:00.580 --> 46:02.580
比方说吧

46:02.580 --> 46:06.580
我们这里有这么一个函数

46:06.580 --> 46:09.580
这个函数我们就是Ethink

46:09.580 --> 46:12.580
它是异部的得到一个数据

46:12.580 --> 46:14.580
getdata

46:14.580 --> 46:17.580
是一个异部的得到数据

46:17.580 --> 46:18.580
于是说这个函数

46:18.580 --> 46:19.580
它返回的是一个什么

46:19.580 --> 46:22.580
返回的是一个promise

46:22.580 --> 46:24.580
返回的是一个promise

46:24.580 --> 46:29.660
resolve

46:29.660 --> 46:31.660
我们这里就用一个set timeouts

46:31.660 --> 46:34.660
两秒钟之后

46:34.660 --> 46:40.660
然后我们这里resolve一个值

46:40.660 --> 46:43.660
比方说我们这里得到一个用户

46:43.660 --> 46:46.660
乘搁

46:46.660 --> 46:48.660
得到一个就是用户名字

46:48.660 --> 46:49.660
一个字物算

46:49.660 --> 46:51.660
那么凭是我们调用这个方法

46:51.660 --> 46:52.660
怎么调用的

46:52.660 --> 46:53.660
Ethink

46:54.660 --> 46:56.660
那么我们是不是这样调用的

46:56.660 --> 46:58.660
要zin

46:58.660 --> 47:01.980
resolve

47:01.980 --> 47:04.980
然后这里输出resolve

47:04.980 --> 47:06.980
我们得这样调用

47:06.980 --> 47:12.660
看一下

47:17.220 --> 47:19.220
调用函数

47:19.220 --> 47:21.220
保存

47:21.220 --> 47:22.220
两秒钟之后

47:22.220 --> 47:24.220
输出成个两个字

47:24.220 --> 47:26.220
那么这个时候

47:26.220 --> 47:27.220
我们能不能用一种

47:27.220 --> 47:29.220
更加優雅的输写方式

47:29.220 --> 47:31.220
我现在用生存器怎么来写

47:31.220 --> 47:33.220
我写一个生存器

47:33.220 --> 47:35.220
给它写个task

47:37.220 --> 47:38.220
表示一个任务

47:38.220 --> 47:39.220
我要去完成一个任务

47:39.220 --> 47:40.220
这个任务里边

47:40.220 --> 47:42.220
有可能有一些异部的东西在里边

47:42.220 --> 47:43.220
没关系

47:43.220 --> 47:44.220
我就这样子写

47:44.220 --> 47:45.220
这里我们就说

47:45.220 --> 47:49.220
正在开始获取数据

47:49.220 --> 47:51.220
我们就写成这么一个东西

47:51.220 --> 47:52.220
这个随便写一句话

47:52.220 --> 47:54.220
然后我们去调用这个

47:54.220 --> 47:56.220
asyncgetdata

47:56.220 --> 47:57.220
调用这个函数

47:57.220 --> 47:59.220
然后这个函数的返回结果

47:59.220 --> 48:00.220
我们之前要写arwait

48:00.220 --> 48:01.220
现在

48:01.220 --> 48:02.220
假设现在es7

48:02.220 --> 48:03.220
还没有出来

48:03.220 --> 48:04.220
没有arwait怎么办呢

48:04.220 --> 48:08.220
也有得到数据

48:08.220 --> 48:12.220
数据resultdata

48:12.220 --> 48:15.220
获取到数据

48:15.220 --> 48:17.220
打个数据data

48:17.220 --> 48:18.220
好

48:18.220 --> 48:19.220
我们就写上这么一个任务

48:19.220 --> 48:21.220
在这里边有这么一个东西

48:21.220 --> 48:23.220
好 接下来我们来看一下

48:23.220 --> 48:25.220
来看一下

48:25.220 --> 48:27.220
现在我们

48:27.220 --> 48:29.220
我们去运行这个task函数

48:29.220 --> 48:31.220
能不能运行这一代吗

48:31.220 --> 48:32.220
别浪运了

48:32.220 --> 48:33.220
反复强调了

48:33.220 --> 48:35.220
是不可能运行这一代吗的

48:35.220 --> 48:36.220
为什么

48:36.220 --> 48:39.220
因为它得到的是一个生存器

48:39.220 --> 48:42.220
这里我们generator

48:42.220 --> 48:44.220
得到的是一个生存器

48:44.220 --> 48:45.220
对吧

48:45.220 --> 48:47.220
那么得到的生存器过后

48:47.220 --> 48:49.220
我们要调用next

48:49.220 --> 48:50.220
才会运行这一代

48:50.220 --> 48:51.220
对不对

48:51.220 --> 48:52.220
要调用next

48:52.220 --> 48:53.220
才会运行这一代

48:53.220 --> 48:54.220
现在我们来调用一个next

48:54.220 --> 48:56.220
看一下generator

48:56.220 --> 48:57.220
调用next

48:57.220 --> 48:58.220
那么请问

48:58.220 --> 49:00.220
这个next得到了value指示啥

49:00.220 --> 49:01.220
我这里调用next

49:01.220 --> 49:02.220
它不是得到一个对象吗

49:02.220 --> 49:03.220
有value 有dunk

49:03.220 --> 49:05.220
dunk肯定是force

49:05.220 --> 49:07.220
那么得到的value指示啥

49:07.220 --> 49:11.790
是乘搁这两个制服串

49:11.790 --> 49:13.790
还是一个promise对象

49:13.790 --> 49:16.790
你告诉我

49:16.790 --> 49:18.790
是不是一个promise对象

49:18.790 --> 49:19.790
对吧

49:19.790 --> 49:21.790
你eo的这里

49:21.790 --> 49:22.790
就是调用函数

49:22.790 --> 49:23.790
把函数的返回结果

49:23.790 --> 49:25.790
作为这一次的value指示

49:25.790 --> 49:26.790
这个函数返回啥

49:26.790 --> 49:28.790
是不是返回一个promise对象

49:28.790 --> 49:29.790
对不对

49:29.790 --> 49:30.790
它同步执行

49:30.790 --> 49:32.790
得到一个promise对象

49:32.790 --> 49:34.790
那你这里是不是得到一个promise对象

49:34.790 --> 49:35.790
对吧

49:35.790 --> 49:37.790
所以说我们这里得到的是啥

49:37.790 --> 49:38.790
得到的是啥

49:38.790 --> 49:39.790
那个是

49:39.790 --> 49:40.790
得到一个promise对象

49:40.790 --> 49:41.790
对吧

49:41.790 --> 49:42.790
看是不是promise

49:42.790 --> 49:44.790
对吧

49:44.790 --> 49:46.790
那我们现在再调用那个是

49:46.790 --> 49:47.790
再调用那个next

49:47.790 --> 49:49.790
data有指吗

49:49.790 --> 49:51.790
有没有指

49:51.790 --> 49:53.790
有没有指是不是看你是不是

49:53.790 --> 49:54.790
这里传东西了

49:54.790 --> 49:55.790
有没有传东西

49:55.790 --> 49:56.790
对不对

49:56.790 --> 49:57.790
你都没有传东西

49:57.790 --> 49:58.790
它肯定没有指

49:58.790 --> 49:59.790
这数据肯定是上一个地方的

49:59.790 --> 50:00.790
不是说时间没有到

50:00.790 --> 50:01.790
时间早就到了

50:01.790 --> 50:02.790
过了两秒钟了

50:02.790 --> 50:03.790
时间早就到了

50:03.790 --> 50:05.790
是因为这里没有传东西

50:05.790 --> 50:07.790
那我们怎么办呢

50:07.790 --> 50:09.790
我们是不是可以利用这种方式

50:09.790 --> 50:11.790
这个generator

50:11.790 --> 50:12.790
得到next

50:12.790 --> 50:13.790
对吧

50:13.790 --> 50:15.790
是不是得到一个对象

50:15.790 --> 50:16.790
得到一个resout对象

50:16.790 --> 50:17.790
对不对

50:17.790 --> 50:19.790
这个对象是不是个promise

50:19.790 --> 50:20.790
它是不是个promise

50:20.790 --> 50:22.790
这里得到是不是promise

50:22.790 --> 50:25.790
我们给这个对象加上一个z

50:25.790 --> 50:26.790
它是个promise

50:26.790 --> 50:27.790
肯定有z

50:27.790 --> 50:28.790
z呢

50:28.790 --> 50:29.790
我们把这个数据拿到

50:29.790 --> 50:31.790
拿到这个数据过后

50:31.790 --> 50:32.790
我们再去调用什么

50:32.790 --> 50:34.790
再去调用generator的那个是

50:34.790 --> 50:35.790
对吧

50:35.790 --> 50:36.790
然后把这个数据给它传进去

50:36.790 --> 50:38.790
那么这样一传进去的话

50:38.790 --> 50:39.790
这个数据是不是跑到这儿来了

50:39.790 --> 50:40.790
对吧

50:40.790 --> 50:41.790
是这个意思吧

50:41.790 --> 50:43.790
等到它数据或许到了之后

50:43.790 --> 50:45.790
然后我把这个数据

50:45.790 --> 50:46.790
再去调用这个那个是

50:46.790 --> 50:47.790
把数据给它传过去

50:47.790 --> 50:49.790
我不是说我调到那个时候

50:49.790 --> 50:50.790
过后必须要马上调用那个是

50:50.790 --> 50:51.790
不是的

50:51.790 --> 50:52.790
我当我实际成熟的时候

50:52.790 --> 50:54.790
我再让它恢复运行

50:54.790 --> 50:55.790
看没有

50:55.790 --> 50:56.790
那么在这个函数内部

50:56.790 --> 50:57.790
是不是可以实现

50:57.790 --> 50:59.790
那个sync await的同样的效果

50:59.790 --> 51:00.790
对吧

51:00.790 --> 51:01.790
是不是可以实现同样的效果

51:01.790 --> 51:02.790
我不是

51:02.790 --> 51:03.790
不是之前卡在这儿吗

51:03.790 --> 51:04.790
我不着急调用你

51:04.790 --> 51:05.790
我等我数据或许到了过后

51:05.790 --> 51:06.790
我再调用你

51:06.790 --> 51:07.790
我把数据传给你

51:07.790 --> 51:08.790
那么这样data

51:08.790 --> 51:09.790
是不是拿到了

51:09.790 --> 51:10.790
拿到它的数据了

51:10.790 --> 51:11.790
好

51:11.790 --> 51:12.790
你

51:12.790 --> 51:13.790
你

51:13.790 --> 51:15.790
我哪里写错了

51:15.790 --> 51:16.790
调用那个是

51:16.790 --> 51:18.790
这个东西肯定是个promise

51:18.790 --> 51:21.790
他说Zin is not a function

51:21.790 --> 51:22.790
我们看一下这个result

51:22.790 --> 51:23.790
是个啥

51:23.790 --> 51:25.790
哦哦哦

51:25.790 --> 51:27.790
result the value

51:27.790 --> 51:29.790
the value

51:29.790 --> 51:30.790
保存

51:30.790 --> 51:32.790
你看一下

51:32.790 --> 51:33.790
对吧

51:33.790 --> 51:34.790
是不是或许到了

51:34.790 --> 51:35.790
那么现在你看一下

51:35.790 --> 51:36.790
这样能或许到数据

51:36.790 --> 51:37.790
说明啥

51:37.790 --> 51:38.790
在这个函数里边

51:38.790 --> 51:39.790
我们是不是

51:39.790 --> 51:41.790
虽然没有用sync await

51:41.790 --> 51:42.790
但是我们也能实现

51:42.790 --> 51:43.790
类似于这样的功能

51:43.790 --> 51:45.790
在生存器里边

51:45.790 --> 51:46.790
对不对

51:46.790 --> 51:47.790
只要有一个东西

51:47.790 --> 51:48.790
才搞定这件事情

51:48.790 --> 51:49.790
实际上

51:49.790 --> 51:51.790
我们在这里还可以写上

51:51.790 --> 51:53.790
写成一个通用的函数

51:53.790 --> 51:54.790
比方说我们写的函数

51:54.790 --> 51:56.790
叫做wrong

51:56.790 --> 51:58.790
就是运行一个任务

52:03.000 --> 52:04.000
运行

52:05.000 --> 52:08.000
运行一个生存器任务

52:08.000 --> 52:11.000
你把生存器函数传给我

52:11.000 --> 52:14.000
generator function

52:14.000 --> 52:16.000
你给我传一个生存器函数

52:16.000 --> 52:17.000
那么我来帮你来运行

52:17.000 --> 52:18.000
这个生存器函数

52:18.000 --> 52:19.000
来运行生存器函数

52:19.000 --> 52:20.000
运行生存器函数

52:20.000 --> 52:22.000
返回的生存器任务

52:22.000 --> 52:23.000
那么这里

52:23.000 --> 52:24.000
我们到时候

52:24.000 --> 52:25.000
调用的时候

52:25.000 --> 52:26.000
就怎么调用呢

52:26.000 --> 52:27.000
这样调用task

52:28.000 --> 52:29.000
wrong

52:29.000 --> 52:30.000
task传进去

52:30.000 --> 52:31.000
把我们的生存器

52:31.000 --> 52:32.000
函数传进去

52:32.000 --> 52:33.000
那么这是个通用函数

52:33.000 --> 52:35.890
通用的

52:35.890 --> 52:37.890
运行一个生存器任务

52:37.890 --> 52:38.890
那看一下这个函数里边

52:38.890 --> 52:39.890
怎么写

52:39.890 --> 52:40.890
我们来研究一下

52:40.890 --> 52:41.890
这个函数里边

52:41.890 --> 52:43.890
该怎么去写这个代码

52:44.890 --> 52:45.890
这个函数里边

52:45.890 --> 52:46.890
怎么写呢

52:46.890 --> 52:47.890
我们可以用这种方式

52:47.890 --> 52:48.890
来写

52:48.890 --> 52:49.890
先调用这个函数

52:49.890 --> 52:50.890
对不对

52:50.890 --> 52:51.890
调用一个函数

52:51.890 --> 52:52.890
generator

52:52.890 --> 52:53.890
得到一个生存器再说

52:53.890 --> 52:56.890
得到一个生存器

52:56.890 --> 52:57.890
当然

52:57.890 --> 52:58.890
如果说生存器有参数的话

52:58.890 --> 52:59.890
我还可以在这里

52:59.890 --> 53:00.890
比方说参数

53:00.890 --> 53:01.890
额外的参数

53:01.890 --> 53:02.890
比方说

53:02.890 --> 53:03.890
因为我也不知道

53:03.890 --> 53:05.890
你到时候要运行哪个生存器函数

53:05.890 --> 53:06.890
对吧

53:06.890 --> 53:07.890
所以说这里

53:07.890 --> 53:08.890
万一有参数了

53:08.890 --> 53:09.890
对不对

53:09.890 --> 53:10.890
万一有参数了

53:10.890 --> 53:11.890
比方说请求地址

53:11.890 --> 53:12.890
分业

53:12.890 --> 53:13.890
什么的

53:13.890 --> 53:14.890
我也说不准

53:14.890 --> 53:15.890
那么如果说有参数的话

53:15.890 --> 53:16.890
我可以把参数传给你

53:16.890 --> 53:17.890
传给你

53:17.890 --> 53:18.890
这个东西都无所谓

53:18.890 --> 53:19.890
就没有参数吧

53:19.890 --> 53:20.890
比较难一点

53:20.890 --> 53:21.890
总之得到一个生存器

53:21.890 --> 53:22.890
那么首先我是不是

53:22.890 --> 53:23.890
第一次的

53:23.890 --> 53:24.890
调用一次

53:24.890 --> 53:25.890
调用一次这个生存器

53:25.890 --> 53:26.890
调用一次吧

53:26.890 --> 53:27.890
咱们这里

53:27.890 --> 53:28.890
写上这么一个代码

53:28.890 --> 53:29.890
调用一次

53:29.890 --> 53:30.890
得到一个result

53:30.890 --> 53:31.890
对吧

53:31.890 --> 53:32.890
得到这么一个result

53:34.890 --> 53:36.890
这里我们用net

53:36.890 --> 53:37.890
result

53:37.890 --> 53:39.890
得到调用生存器

53:39.890 --> 53:41.890
就是generator

53:41.890 --> 53:42.890
net

53:42.890 --> 53:43.890
对吧

53:43.890 --> 53:45.890
调用生存器得到一个result

53:45.890 --> 53:47.890
就是一开始调用一次

53:47.890 --> 53:49.890
调用一次

53:49.890 --> 53:51.890
调用一次过后

53:51.890 --> 53:52.890
调用一次过后

53:52.890 --> 53:53.890
我们是不是可以对这个result

53:53.890 --> 53:55.890
来进行分析

53:55.890 --> 53:56.890
我接下来还要不要调用

53:56.890 --> 53:57.890
还要怎么去调用

53:57.890 --> 53:59.890
是不是可以对它进行分析

53:59.890 --> 54:00.890
对吧

54:00.890 --> 54:01.890
可以进行分析

54:01.890 --> 54:02.890
那么这里的分析

54:02.890 --> 54:03.890
因为我要调用

54:03.890 --> 54:05.890
最终要把这个函数执行完

54:05.890 --> 54:07.890
我肯定最终要把这个函数执行完

54:07.890 --> 54:08.890
为了方便我们后边

54:08.890 --> 54:10.890
控制我们这里有两种写法

54:10.890 --> 54:12.890
一种是在内部写一个函数

54:12.890 --> 54:14.890
反复调用这个函数

54:14.890 --> 54:15.890
另一种就是写循环

54:15.890 --> 54:16.890
我们先用循环

54:16.890 --> 54:18.890
循环好理解一点

54:18.890 --> 54:20.890
这就是我们之前写过的循环

54:20.890 --> 54:26.890
如果result不为当

54:26.890 --> 54:30.890
result就是没有结束

54:30.890 --> 54:32.890
那么就表示说

54:32.890 --> 54:35.890
有迭代结果

54:35.890 --> 54:36.890
那么有迭代结果的时候

54:36.890 --> 54:38.890
是不是我们可以拿到迭代结果

54:38.890 --> 54:41.890
是不是拿到迭代结果

54:41.890 --> 54:44.890
value等于result.value

54:44.890 --> 54:51.890
拿到迭代的数据

54:51.890 --> 54:53.890
好如果说

54:53.890 --> 54:54.890
判断一下

54:54.890 --> 54:56.890
如果说这个迭代的数据是一个promise

54:56.890 --> 54:57.890
怎么来判断一下

54:57.890 --> 54:58.890
是不是promise呢

54:58.890 --> 54:59.890
我们就简单判断吧

54:59.890 --> 55:00.890
当然我们之前也讲过

55:00.890 --> 55:02.890
有专门的一个cool对吧

55:02.890 --> 55:03.890
叫做ease promise

55:03.890 --> 55:04.890
我这里拦了起来

55:04.890 --> 55:05.890
就直接简单判断一下

55:05.890 --> 55:07.890
只要判断一下这个value

55:07.890 --> 55:09.890
如果说value的

55:09.890 --> 55:11.890
就是有个rin

55:11.890 --> 55:13.890
这个rin的属性等于方式

55:13.890 --> 55:16.890
我们用type of

55:16.890 --> 55:17.890
如何rin呢

55:17.890 --> 55:19.890
它是一个方形

55:19.890 --> 55:21.890
就这样吧

55:21.890 --> 55:23.890
那么表示的是

55:23.890 --> 55:24.890
那么假设

55:24.890 --> 55:25.890
就这样判断

55:25.890 --> 55:26.890
就假设说

55:26.890 --> 55:27.890
这个value

55:27.890 --> 55:31.890
迭代的数据

55:31.890 --> 55:33.890
是一个promise

55:33.890 --> 55:34.890
就在这里

55:34.890 --> 55:36.890
你给我的数据是一个promise

55:36.890 --> 55:37.890
那我干嘛呢

55:37.890 --> 55:38.890
是不是等待

55:38.890 --> 55:39.890
我等一下

55:39.890 --> 55:40.890
我等待

55:40.890 --> 55:41.890
等待一下

55:41.890 --> 55:43.890
等到什么时候呢

55:43.890 --> 55:45.890
promise

55:45.890 --> 55:48.890
value

55:48.890 --> 55:49.890
等你

55:49.890 --> 55:51.890
等你把数据拿到过后

55:51.890 --> 55:53.890
拿到过后干嘛

55:53.890 --> 55:54.890
我在进行下一步

55:54.890 --> 55:56.890
generator

55:56.890 --> 55:58.890
在进行下一步

55:58.890 --> 55:59.890
下一步呢

55:59.890 --> 56:00.890
我们是什么呢

56:00.890 --> 56:01.890
下一步就是

56:01.890 --> 56:02.890
给它的数据是什么

56:02.890 --> 56:03.890
results

56:03.890 --> 56:04.890
value

56:04.890 --> 56:05.890
对不对

56:05.890 --> 56:07.890
如果说你是一个方形

56:07.890 --> 56:09.890
如果说你是一个promise

56:09.890 --> 56:10.890
那么我等一下

56:10.890 --> 56:12.890
等到你数据拿到之后

56:12.890 --> 56:13.890
我再去调整那个数

56:13.890 --> 56:15.890
下一步

56:15.890 --> 56:16.890
else

56:16.890 --> 56:17.890
就表示的是

56:17.890 --> 56:19.890
你不是一个promise

56:19.890 --> 56:20.890
你不是一个promise

56:20.890 --> 56:22.890
而不是一个promise的话

56:22.890 --> 56:23.890
那么我这里呢

56:23.890 --> 56:25.890
就直接调整generator

56:25.890 --> 56:26.890
next

56:26.890 --> 56:27.890
result

56:27.890 --> 56:29.890
value

56:29.890 --> 56:31.890
直接调整那个数据

56:31.890 --> 56:32.890
value

56:32.890 --> 56:33.890
直接给你

56:33.890 --> 56:34.890
直接往后面运行

56:34.890 --> 56:35.890
那么咱们试一下

56:35.890 --> 56:36.890
拿到数据过后

56:36.890 --> 56:37.890
拿到数据

56:37.890 --> 56:38.890
后面再来一次

56:40.890 --> 56:41.890
data2

56:41.890 --> 56:42.890
data2

56:42.890 --> 56:44.890
再来拿一次

56:45.890 --> 56:47.890
又获取到了数据

56:47.890 --> 56:49.890
到了数据

56:49.890 --> 56:50.890
多写几次

56:50.890 --> 56:52.890
你也不知道我要到底要写多少次

56:52.890 --> 56:54.890
然后我们再来一个

56:54.890 --> 56:56.890
data1

56:56.890 --> 57:00.200
data3

57:02.200 --> 57:04.200
又获取到了数据

57:04.200 --> 57:07.900
这里是data3

57:07.900 --> 57:09.900
这个就不是一步的了

57:09.900 --> 57:10.900
不是一步的了

57:10.900 --> 57:12.900
那么这里就结束了

57:12.900 --> 57:13.900
咱们试一下

57:13.900 --> 57:15.900
现在能不能得到正常的结果

57:15.900 --> 57:21.580
你看一下

57:21.580 --> 57:22.580
出问题了

57:22.580 --> 57:24.580
这里还少写一句话

57:24.580 --> 57:26.580
还少写一句话

57:26.580 --> 57:27.580
少写什么呢

57:27.580 --> 57:32.300
少写一个就是

57:32.300 --> 57:34.300
我们调用了next过后

57:34.300 --> 57:35.300
调用了next过后

57:35.300 --> 57:37.300
我还得把这个next的返回结果

57:37.300 --> 57:39.300
要重新复制给result

57:39.300 --> 57:40.300
这个不能

57:40.300 --> 57:41.300
这个最化的

57:41.300 --> 57:42.300
再加上

57:42.300 --> 57:43.300
不然的话他永远不会迭代

57:43.300 --> 57:44.300
不然的话

57:44.300 --> 57:46.300
他永远不会循环结束

57:46.300 --> 57:47.300
对吧

57:47.300 --> 57:48.300
循环永远不会结束

57:48.300 --> 57:49.300
因为这个result没变

57:49.300 --> 57:51.300
result这个变量没变

57:51.300 --> 57:52.300
再把重新复制

57:52.300 --> 57:54.300
重新再一次

57:54.300 --> 57:56.300
复制一下

57:56.300 --> 57:59.060
这边

57:59.060 --> 58:00.060
卡死了

58:00.060 --> 58:01.060
点击

58:01.060 --> 58:03.060
这里翻了就卡死了

58:03.060 --> 58:04.060
现在就永远出不来了

58:04.060 --> 58:05.060
那想一想

58:05.060 --> 58:06.060
为什么出不来了

58:06.060 --> 58:07.060
永远出不来了

58:07.060 --> 58:08.060
想一想

58:08.060 --> 58:09.060
为什么永远出不来了

58:09.060 --> 58:11.060
如果说我这里不写这些东西

58:11.060 --> 58:13.060
就给正常的数据的话

58:14.060 --> 58:15.060
如果说

58:15.060 --> 58:16.060
不写这些东西

58:16.060 --> 58:17.060
给正常的数据的话

58:17.060 --> 58:18.060
你会发现一些正常

58:18.060 --> 58:19.060
没问题

58:19.060 --> 58:21.060
第一道数据3 4 1

58:21.060 --> 58:22.060
3 4 1 没问题

58:22.060 --> 58:23.060
对吧

58:23.060 --> 58:25.060
但是为什么写到异部数据就出不来了

58:25.060 --> 58:26.060
为什么

58:26.060 --> 58:27.060
你想一想

58:27.060 --> 58:28.060
你写到异部过后

58:28.060 --> 58:29.060
那这段代码

58:29.060 --> 58:30.060
是不是

58:30.060 --> 58:31.060
扔这里边的东西

58:31.060 --> 58:32.060
要等一会儿才执行

58:32.060 --> 58:33.060
对吧

58:33.060 --> 58:34.060
是要等一会儿才执行

58:34.060 --> 58:35.060
好 等一会儿才执行

58:35.060 --> 58:36.060
是不是

58:36.060 --> 58:37.060
那这个循环会不会等他

58:37.060 --> 58:39.060
循环不会等他

58:39.060 --> 58:40.060
这个循环不会等他

58:40.060 --> 58:42.060
那循环还会自己继续执行

58:42.060 --> 58:43.060
因为这个是异部的

58:43.060 --> 58:45.060
他要等一会儿才会执行这个代码

58:45.060 --> 58:46.060
循环不会等他

58:46.060 --> 58:47.060
循环他又判断

58:47.060 --> 58:49.060
这个维绕者是不是结束了

58:49.060 --> 58:50.060
肯定没有结束

58:50.060 --> 58:51.060
他现在都没有运行下一个

58:51.060 --> 58:52.060
对吧

58:52.060 --> 58:53.060
那又是一个这个东西

58:53.060 --> 58:54.060
是不是又加了一个Z

58:54.060 --> 58:55.060
对吧

58:55.060 --> 58:56.060
又加了一个Z

58:56.060 --> 58:58.060
那现在又不会等他

58:58.060 --> 58:59.060
又进行循环

58:59.060 --> 59:00.060
是不是死循环了

59:00.060 --> 59:01.060
对吧

59:01.060 --> 59:02.060
因为循环

59:02.060 --> 59:03.060
他不会等待这个东西

59:03.060 --> 59:04.060
所以这里用循环

59:04.060 --> 59:05.060
要出问题

59:05.060 --> 59:06.060
用循环是要出问题的

59:06.060 --> 59:07.060
那么我们

59:07.060 --> 59:08.060
当时呢

59:08.060 --> 59:09.060
我就是想犹豫了一下

59:09.060 --> 59:10.060
我说要不要一开始

59:10.060 --> 59:11.060
又写函数

59:11.060 --> 59:12.060
还是大家体会下循环吧

59:12.060 --> 59:13.060
循环这里是要出问题的

59:13.060 --> 59:14.060
因为这一块是异部的

59:14.060 --> 59:17.060
他循环他不会等待这个异部

59:17.060 --> 59:18.060
所以说他这个循环会

59:18.060 --> 59:19.060
不断的运行

59:19.060 --> 59:20.060
不断的运行很快的速度

59:20.060 --> 59:22.060
那么导致他卡在这

59:22.060 --> 59:23.060
好了

59:23.060 --> 59:24.060
那么现在呢

59:24.060 --> 59:30.990
我们现在把它换成另外一种写法

59:30.990 --> 59:31.990
这个函数呢

59:31.990 --> 59:33.990
我在这里封装这么一个函数

59:33.990 --> 59:34.990
这个函数作用呢

59:34.990 --> 59:35.990
我打个注释

59:35.990 --> 59:37.990
就是

59:37.990 --> 59:38.990
调用

59:38.990 --> 59:40.990
就是

59:40.990 --> 59:41.990
进行

59:41.990 --> 59:42.990
下一次

59:42.990 --> 59:44.990
疊带

59:44.990 --> 59:45.990
疊带

59:45.990 --> 59:47.990
就是封装了Generator的Nexter

59:47.990 --> 59:49.990
就是封装了Generator的Nexter的方法

59:49.990 --> 59:56.990
封装了Generator的Nexter的方法

59:56.990 --> 59:58.990
进行下一次对待

59:58.990 --> 59:59.990
并且呢

59:59.990 --> 01:00:00.990
传了一个数据

01:00:00.990 --> 01:00:01.990
这个数据呢就掉

01:00:01.990 --> 01:00:02.990
你说这里呢

01:00:02.990 --> 01:00:03.990
我做的事情就很简单

01:00:03.990 --> 01:00:04.990
Generator.Nexter

01:00:04.990 --> 01:00:05.990
NexterValue

01:00:05.990 --> 01:00:06.990
就这么简单

01:00:06.990 --> 01:00:07.990
调用一下

01:00:07.990 --> 01:00:09.990
调用一下就完了

01:00:09.990 --> 01:00:13.750
得到Results

01:00:13.750 --> 01:00:14.750
调用一下就完了

01:00:14.750 --> 01:00:15.750
我去帮你封装一下

01:00:15.750 --> 01:00:16.750
就这么简单

01:00:16.750 --> 01:00:17.750
帮你封装一下

01:00:17.750 --> 01:00:18.750
那么也说这里呢

01:00:18.750 --> 01:00:19.750
我们一开始呢

01:00:19.750 --> 01:00:20.750
是不是可以直接调用这个函数

01:00:20.750 --> 01:00:21.750
对不对

01:00:21.750 --> 01:00:22.750
调用这个函数就完事了

01:00:22.750 --> 01:00:23.750
调用这个函数

01:00:23.750 --> 01:00:25.750
一开始不传令任何东西吗

01:00:25.750 --> 01:00:26.750
它就帮你封装了一下

01:00:26.750 --> 01:00:27.750
其他啥都没有做

01:00:27.750 --> 01:00:28.750
好 那么这个函数

01:00:28.750 --> 01:00:29.750
因为有了函数过后

01:00:29.750 --> 01:00:30.750
它就不像循环

01:00:30.750 --> 01:00:31.750
循环它就不会等待

01:00:31.750 --> 01:00:32.750
函数呢

01:00:32.750 --> 01:00:33.750
我调用它才动一下

01:00:33.750 --> 01:00:34.750
调用它才动一下

01:00:34.750 --> 01:00:35.750
不调用它就不会动

01:00:35.750 --> 01:00:37.750
所以说这里的函数里面

01:00:37.750 --> 01:00:38.750
就很好处理的

01:00:38.750 --> 01:00:40.750
函数里面我们首先判断一下

01:00:40.750 --> 01:00:41.750
Results

01:00:41.750 --> 01:00:43.750
当是不是结束了

01:00:43.750 --> 01:00:45.750
迭代 结束了

01:00:45.750 --> 01:00:46.750
如果说你只要调用这个函数

01:00:46.750 --> 01:00:48.750
我甭管你是什么时候调用的

01:00:48.750 --> 01:00:49.750
那我发现迭代已经结束了

01:00:49.750 --> 01:00:50.750
我就返回了

01:00:50.750 --> 01:00:52.750
这个函数什么都不做

01:00:52.750 --> 01:00:53.750
什么都不做

01:00:53.750 --> 01:00:55.750
好 如果说你没有结束

01:00:55.750 --> 01:00:56.750
那么那就是一样的

01:00:56.750 --> 01:00:58.750
对吧 拿到迭代数据

01:00:58.750 --> 01:00:59.750
对不对 拿到迭代的数据

01:00:59.750 --> 01:01:00.750
然后判断

01:01:00.750 --> 01:01:01.750
对不对

01:01:01.750 --> 01:01:04.750
是不是一样的

01:01:04.750 --> 01:01:05.750
是不是一样的

01:01:05.750 --> 01:01:07.750
如果说你没有结束

01:01:07.750 --> 01:01:08.750
拿到迭代的数据

01:01:08.750 --> 01:01:10.750
如果说你迭代的数据是一个Promise

01:01:10.750 --> 01:01:12.750
你给我的是一个Promise

01:01:12.750 --> 01:01:13.750
好 我等一下

01:01:13.750 --> 01:01:15.750
等一下等你数据拿到过后

01:01:15.750 --> 01:01:17.750
我就不是立即执行了

01:01:17.750 --> 01:01:18.750
因为这是个异部

01:01:18.750 --> 01:01:20.750
还说等你数据拿到过后

01:01:20.750 --> 01:01:21.750
我又调用自己

01:01:21.750 --> 01:01:22.750
是不是地归

01:01:22.750 --> 01:01:23.750
对吧

01:01:23.750 --> 01:01:24.750
好 你又调用自己

01:01:24.750 --> 01:01:26.750
那么下一次的数据是什么

01:01:26.750 --> 01:01:27.750
是不是Data

01:01:27.750 --> 01:01:29.750
对吧 下一次的数据是个Data

01:01:29.750 --> 01:01:31.750
就这么个意思

01:01:31.750 --> 01:01:32.750
我又调用自己

01:01:32.750 --> 01:01:33.750
把数据传进去

01:01:33.750 --> 01:01:34.750
好 那么这里呢

01:01:34.750 --> 01:01:36.750
自然它这里调用的是那个词的

01:01:36.750 --> 01:01:37.750
把数据传进去

01:01:37.750 --> 01:01:39.750
下一次又得到Rate Out

01:01:39.750 --> 01:01:40.750
对吧

01:01:40.750 --> 01:01:41.750
那如果说

01:01:41.750 --> 01:01:42.750
如果说迭代的数据

01:01:42.750 --> 01:01:43.750
它不是一个Promise

01:01:43.750 --> 01:01:44.750
一个正常的数据的话

01:01:44.750 --> 01:01:46.750
我直接调用下一个

01:01:46.750 --> 01:01:47.750
把数据传进去

01:01:47.750 --> 01:01:48.750
把你之前

01:01:48.750 --> 01:01:50.750
这一次迭代的数据

01:01:50.750 --> 01:01:52.750
作为下一次的返回值传进去

01:01:52.750 --> 01:01:54.750
好 你写出来这么一种格式

01:01:54.750 --> 01:01:55.750
你看一下

01:01:55.750 --> 01:01:56.750
写了这么一个格式

01:01:56.750 --> 01:01:57.750
一开始调用一次

01:01:57.750 --> 01:01:58.750
然后启动起来

01:01:58.750 --> 01:02:00.750
就写出来这么一个通用的函数状

01:02:00.750 --> 01:02:02.750
保存你看一下

01:02:02.750 --> 01:02:04.750
两秒过后获到成个

01:02:04.750 --> 01:02:05.750
又等两秒

01:02:05.750 --> 01:02:06.750
然后得到数据一

01:02:06.750 --> 01:02:07.750
看没有

01:02:07.750 --> 01:02:08.750
那么这样子是不是写成

01:02:08.750 --> 01:02:09.750
个通用的绕函数

01:02:09.750 --> 01:02:10.750
那么这样子

01:02:10.750 --> 01:02:11.750
我们就可以使用生成器

01:02:11.750 --> 01:02:12.750
我们之后

01:02:12.750 --> 01:02:13.750
这个函数就不用再动了

01:02:13.750 --> 01:02:15.750
我们只需要去写这么一个生成器

01:02:15.750 --> 01:02:16.750
这个生成器里边

01:02:16.750 --> 01:02:18.750
我们通过eO的

01:02:18.750 --> 01:02:20.750
通过eO的来实现这么一种

01:02:20.750 --> 01:02:21.750
e不效果

01:02:21.750 --> 01:02:22.750
就像编写同步代码的样子

01:02:22.750 --> 01:02:23.750
去编写这些东西

01:02:23.750 --> 01:02:25.750
无论这里使用了多少次

01:02:25.750 --> 01:02:26.750
这个函数会帮你搞定

01:02:28.750 --> 01:02:29.750
好好看一下

01:02:29.750 --> 01:02:30.750
这个函数呢

01:02:30.750 --> 01:02:31.750
我建议大家最好去

01:02:31.750 --> 01:02:33.750
好好去体会一下

01:02:33.750 --> 01:02:34.750
甚至呢

01:02:34.750 --> 01:02:36.750
你可以尝试着自己写一下

01:02:36.750 --> 01:02:38.750
看能不能写出来

01:02:38.750 --> 01:02:39.750
那么刚才我已经解释了

01:02:39.750 --> 01:02:40.750
为什么不能用循环

01:02:40.750 --> 01:02:41.750
因为循环它不会等

01:02:41.750 --> 01:02:42.750
函数它就会等

01:02:42.750 --> 01:02:44.750
我调人的时候你才会动一下

01:02:44.750 --> 01:02:46.750
不调你也不会动

01:02:46.750 --> 01:02:48.750
于是形成这么一种结构了

01:02:48.750 --> 01:02:50.750
好好看一下

01:02:50.750 --> 01:02:52.750
这是关于这一块生成器的

01:02:52.750 --> 01:02:54.750
就是一个常见的

01:02:54.750 --> 01:02:56.750
一个应用场景

01:02:56.750 --> 01:02:57.750
好生成器这一块

01:02:57.750 --> 01:02:58.750
还有两个细节

01:02:58.750 --> 01:02:59.750
我简单说一下

01:02:59.750 --> 01:03:00.750
这两个东西

01:03:00.750 --> 01:03:01.750
也非常简单了

01:03:01.750 --> 01:03:02.750
一个是

01:03:02.750 --> 01:03:04.750
生成器里边有这么一个方法

01:03:04.750 --> 01:03:05.750
叫做

01:03:05.750 --> 01:03:07.750
一个的说吗

01:03:07.750 --> 01:03:08.750
叫做

01:03:08.750 --> 01:03:13.060
生成器带有

01:03:13.060 --> 01:03:15.060
一个slow方法

01:03:16.060 --> 01:03:18.060
该方法与

01:03:18.060 --> 01:03:19.060
那个

01:03:19.060 --> 01:03:23.060
该方法与next的效果

01:03:23.060 --> 01:03:24.060
相同

01:03:24.060 --> 01:03:25.060
相同

01:03:25.060 --> 01:03:27.060
唯一的区别

01:03:27.060 --> 01:03:30.060
在于slow方法

01:03:30.060 --> 01:03:32.060
会

01:03:32.060 --> 01:03:33.060
在于什么呢

01:03:33.060 --> 01:03:35.060
在于我这样说吧

01:03:35.060 --> 01:03:36.060
next的方法

01:03:36.060 --> 01:03:38.060
传递的参数

01:03:38.060 --> 01:03:40.060
会

01:03:40.060 --> 01:03:43.060
会被返回

01:03:43.060 --> 01:03:46.060
成一个

01:03:46.060 --> 01:03:49.060
正常的值

01:03:49.060 --> 01:03:50.060
就是说我们这里

01:03:50.060 --> 01:03:52.060
我们之前写过的

01:03:52.060 --> 01:03:54.060
next

01:03:54.060 --> 01:03:56.060
我写完了

01:03:56.060 --> 01:03:57.060
这里

01:03:57.060 --> 01:03:58.060
我们这里只要掉到next

01:03:58.060 --> 01:04:00.060
next里被它传递的参数

01:04:00.060 --> 01:04:01.060
就是把这个

01:04:01.060 --> 01:04:03.060
当时这个表达式的结果返回

01:04:03.060 --> 01:04:04.060
返回到这

01:04:04.060 --> 01:04:06.060
而slow不一样

01:04:06.060 --> 01:04:07.060
就这个地方有区别

01:04:07.060 --> 01:04:09.060
slow的方法

01:04:09.060 --> 01:04:11.060
它也要传递的参数

01:04:11.060 --> 01:04:13.060
参数是一个错误对象

01:04:13.060 --> 01:04:15.060
传递的错误对象

01:04:15.060 --> 01:04:17.060
会导致

01:04:17.060 --> 01:04:19.060
生成器

01:04:19.060 --> 01:04:20.060
函数

01:04:20.060 --> 01:04:21.060
内部

01:04:21.060 --> 01:04:23.060
发生

01:04:23.060 --> 01:04:24.060
一个错误

01:04:24.060 --> 01:04:25.060
发生一个错误

01:04:25.060 --> 01:04:26.060
什么意思呢

01:04:26.060 --> 01:04:27.060
看一下

01:04:27.060 --> 01:04:28.060
看一个例子

01:04:29.060 --> 01:04:30.060
特色5

01:04:30.060 --> 01:04:34.080
看一下吧

01:04:34.080 --> 01:04:36.080
我们这里

01:04:36.080 --> 01:04:38.080
就在这吧

01:04:38.080 --> 01:04:39.080
看着

01:04:39.080 --> 01:04:42.080
一开始我们运行next

01:04:42.080 --> 01:04:48.310
换个一面了

01:04:48.310 --> 01:04:50.310
现在我们先调用Generic的next

01:04:50.310 --> 01:04:51.310
一开始调用一次

01:04:51.310 --> 01:04:52.310
next

01:04:52.310 --> 01:04:53.310
还说开始

01:04:53.310 --> 01:04:54.310
Y6是不是停在这了

01:04:54.310 --> 01:04:56.310
还没有继续运行

01:04:56.310 --> 01:04:57.310
下一次

01:04:57.310 --> 01:04:58.310
我们这样子

01:04:58.310 --> 01:05:00.310
下一次我们使用slow

01:05:00.310 --> 01:05:01.310
然后这里

01:05:01.310 --> 01:05:03.310
创建一个新的错误对象

01:05:03.310 --> 01:05:05.310
6 error

01:05:05.310 --> 01:05:07.310
爆错了

01:05:07.310 --> 01:05:08.310
这个爆错了

01:05:08.310 --> 01:05:09.310
它会在哪里爆错呢

01:05:09.310 --> 01:05:11.310
它传了个错误对象进去

01:05:11.310 --> 01:05:12.310
它会在哪里爆错呢

01:05:12.310 --> 01:05:14.310
它会在这个位置

01:05:14.310 --> 01:05:16.310
它让生成器继续执行

01:05:16.310 --> 01:05:19.310
让生成器继续执行

01:05:19.310 --> 01:05:21.310
在这个位置爆错了

01:05:21.310 --> 01:05:22.310
在这个位置爆错了

01:05:22.310 --> 01:05:23.310
它能不能把这个错误

01:05:23.310 --> 01:05:24.310
它是不是把这个错误对象

01:05:24.310 --> 01:05:25.310
复制过去

01:05:25.310 --> 01:05:26.310
不是

01:05:26.310 --> 01:05:27.310
它是直接在这里

01:05:27.310 --> 01:05:28.310
爆了一个错误

01:05:30.310 --> 01:05:31.310
回彻

01:05:31.310 --> 01:05:32.310
你看一下

01:05:32.310 --> 01:05:33.310
16行

01:05:33.310 --> 01:05:34.310
16行是不是这

01:05:34.310 --> 01:05:35.310
是不是这里爆错了

01:05:35.310 --> 01:05:36.310
对吧

01:05:36.310 --> 01:05:37.310
它在这里给爆了一个错误

01:05:37.310 --> 01:05:38.310
是这么个意思

01:05:38.310 --> 01:05:39.310
也就是一看

01:05:39.310 --> 01:05:40.310
再一次说明了

01:05:40.310 --> 01:05:42.310
这个生成器函数内部的执行

01:05:42.310 --> 01:05:44.310
是不是完全受到生成器控制

01:05:44.310 --> 01:05:45.310
对吧

01:05:45.310 --> 01:05:46.310
它还可以让它爆错

01:05:46.310 --> 01:05:48.310
它想让它爆出去让它爆错

01:05:48.310 --> 01:05:49.310
对吧

01:05:49.310 --> 01:05:50.310
那这个地方呢

01:05:50.310 --> 01:05:51.310
如果说你不是爆错的话

01:05:51.310 --> 01:05:53.310
不要说我们重新刷新

01:05:54.310 --> 01:05:55.310
那个是对吧

01:05:55.310 --> 01:05:56.310
一开始执行

01:05:56.310 --> 01:05:57.310
如果你之前的不是错误

01:05:57.310 --> 01:05:58.310
而是那个时辰的话

01:05:58.310 --> 01:05:59.310
给它传个错误

01:05:59.310 --> 01:06:00.310
它会怎么样了

01:06:00.310 --> 01:06:01.310
它会

01:06:01.310 --> 01:06:03.310
它会把这个错误对象放过去

01:06:03.310 --> 01:06:04.310
它会把这个错误对象

01:06:04.310 --> 01:06:05.310
传到results里边去

01:06:06.310 --> 01:06:07.310
它会把这个错误对象

01:06:07.310 --> 01:06:08.310
传到results里边去

01:06:08.310 --> 01:06:09.310
那么这里打印出来results

01:06:09.310 --> 01:06:10.310
是不是

01:06:10.310 --> 01:06:11.310
就这个玩意儿

01:06:11.310 --> 01:06:12.310
对不对

01:06:12.310 --> 01:06:13.310
打印出来results是这个玩意儿

01:06:13.310 --> 01:06:14.310
这个玩意儿

01:06:14.310 --> 01:06:15.310
这个意思吧

01:06:15.310 --> 01:06:17.310
但是如果你使用的是错误的话

01:06:17.310 --> 01:06:19.310
如果你使用的是错误

01:06:21.310 --> 01:06:22.310
那么它会在这个位置呢

01:06:22.310 --> 01:06:24.310
就是之前挺对那个位置

01:06:24.310 --> 01:06:25.310
直接爆一个错

01:06:25.310 --> 01:06:26.310
那么这个错误能不能处理的

01:06:26.310 --> 01:06:27.310
当然能处理的

01:06:27.310 --> 01:06:28.310
在这里边是不是

01:06:28.310 --> 01:06:29.310
可以用tracket来处理

01:06:29.310 --> 01:06:30.310
tracket

01:06:31.310 --> 01:06:33.310
比方说catch

01:06:33.310 --> 01:06:34.310
air

01:06:34.310 --> 01:06:36.310
它相当于在这里就包了一个错误了

01:06:36.310 --> 01:06:38.310
你是不是可以把air对象获取到

01:06:38.310 --> 01:06:39.310
对吧

01:06:39.310 --> 01:06:40.310
获取到

01:06:40.310 --> 01:06:41.310
比方说我们在这里写

01:06:41.310 --> 01:06:43.310
如果说你包了错误之后

01:06:43.310 --> 01:06:44.310
你包了错误之后

01:06:44.310 --> 01:06:46.310
我们在这里再写上一个

01:06:47.310 --> 01:06:48.310
爆错了

01:06:49.310 --> 01:06:50.310
看一下吧

01:06:50.310 --> 01:06:51.310
看一下

01:06:52.310 --> 01:06:53.310
好 这里

01:06:54.310 --> 01:06:55.310
开始

01:06:55.310 --> 01:06:56.310
域形到这了

01:06:56.310 --> 01:06:57.310
卡在这

01:06:57.310 --> 01:06:58.310
等待执行

01:06:58.310 --> 01:07:00.310
那么现在我强行拿它包一个错

01:07:01.310 --> 01:07:02.310
包一个错误过后

01:07:02.310 --> 01:07:03.310
但是它没有包错了

01:07:03.310 --> 01:07:04.310
因为为什么用了tracket

01:07:04.310 --> 01:07:05.310
在这里个地方

01:07:05.310 --> 01:07:06.310
包了一个错误

01:07:06.310 --> 01:07:07.310
是不是到了开启里面执行

01:07:07.310 --> 01:07:09.310
把错误对象给它了

01:07:09.310 --> 01:07:10.310
然后这里输出了包错了

01:07:10.310 --> 01:07:11.310
包错了过后

01:07:11.310 --> 01:07:13.310
由于整个任务结束了

01:07:13.310 --> 01:07:14.310
整个生存器结束了

01:07:14.310 --> 01:07:16.310
因为后面没有再写eo的了

01:07:16.310 --> 01:07:17.310
所以说它这里

01:07:17.310 --> 01:07:18.310
就是什么

01:07:18.310 --> 01:07:19.310
得到的是undefined

01:07:19.310 --> 01:07:20.310
当然这后面

01:07:20.310 --> 01:07:21.310
能不能再写eo的

01:07:21.310 --> 01:07:22.310
当然可以

01:07:22.310 --> 01:07:23.310
当然可以

01:07:23.310 --> 01:07:24.310
abc吗

01:07:24.310 --> 01:07:25.310
比方说我们学院写一个

01:07:25.310 --> 01:07:26.310
看着

01:07:26.310 --> 01:07:28.310
一开始那个是卡在这

01:07:29.310 --> 01:07:30.310
卡在这等着

01:07:30.310 --> 01:07:32.310
下面让我给它包一个错

01:07:32.310 --> 01:07:33.310
包错了

01:07:33.310 --> 01:07:34.310
是不是继续执行

01:07:34.310 --> 01:07:35.310
包错了进入开启

01:07:35.310 --> 01:07:36.310
刚才能没有用开启

01:07:36.310 --> 01:07:38.310
所以说它没法执行了

01:07:38.310 --> 01:07:39.310
它就直接包错了

01:07:39.310 --> 01:07:40.310
那没办法了

01:07:40.310 --> 01:07:42.310
现在有了开启过后

01:07:42.310 --> 01:07:43.310
它可以继续执行

01:07:43.310 --> 01:07:44.310
那么执行了

01:07:44.310 --> 01:07:45.310
出出了是吗

01:07:45.310 --> 01:07:46.310
包错了

01:07:46.310 --> 01:07:47.310
然后又把这个执

01:07:47.310 --> 01:07:48.310
又给了生存器

01:07:48.310 --> 01:07:49.310
对吧

01:07:49.310 --> 01:07:50.310
又给了生存器

01:07:50.310 --> 01:07:51.310
所以说这个输了

01:07:51.310 --> 01:07:53.310
所以它组织就是包了一个错误

01:07:53.310 --> 01:07:54.310
这是实误

01:07:54.310 --> 01:07:55.310
好

01:07:55.310 --> 01:07:56.310
下一个

01:07:57.310 --> 01:07:58.310
生存器

01:08:00.310 --> 01:08:01.310
生存器

01:08:01.310 --> 01:08:04.310
带有一个return方法

01:08:04.310 --> 01:08:06.310
该方法

01:08:06.310 --> 01:08:09.310
会直接结束

01:08:09.310 --> 01:08:11.310
结束

01:08:11.310 --> 01:08:12.310
生存器函数

01:08:12.310 --> 01:08:14.310
生存器函数

01:08:14.310 --> 01:08:15.310
好

01:08:15.310 --> 01:08:16.310
什么意思呢

01:08:16.310 --> 01:08:17.310
咱们再举个例子

01:08:17.310 --> 01:08:18.310
定6个TES6

01:08:18.310 --> 01:08:22.030
好

01:08:22.030 --> 01:08:23.030
这里我们不用揣开起了

01:08:24.030 --> 01:08:25.030
比方说

01:08:26.030 --> 01:08:29.030
那么这里我们写上先来一个net

01:08:29.030 --> 01:08:30.030
什么卡在这

01:08:30.030 --> 01:08:31.030
对吧

01:08:31.030 --> 01:08:32.030
卡在这

01:08:32.030 --> 01:08:34.030
接下来我们调用generator的return

01:08:34.030 --> 01:08:36.030
调用return

01:08:36.030 --> 01:08:38.030
return过后你看一下

01:08:38.030 --> 01:08:40.030
是马上就结束了

01:08:40.030 --> 01:08:41.030
马上就结束了

01:08:41.030 --> 01:08:42.030
这些代码还运行吗

01:08:42.030 --> 01:08:43.030
不运行的

01:08:43.030 --> 01:08:46.030
直接结束整个生存器函数

01:08:46.030 --> 01:08:48.030
所以说外部还可以控制这个函数

01:08:48.030 --> 01:08:50.030
什么时候结束

01:08:50.030 --> 01:08:52.030
反复的强调这一点

01:08:52.030 --> 01:08:54.030
说明生存器函数

01:08:54.030 --> 01:08:56.030
受到它对应的生存器

01:08:56.030 --> 01:08:57.030
完全控制

01:08:57.030 --> 01:08:59.030
控制它的执行

01:08:59.030 --> 01:09:00.030
那么这里你看

01:09:00.030 --> 01:09:01.030
是不是结束了

01:09:01.030 --> 01:09:02.030
那后面再调用那个时候有用吗

01:09:02.030 --> 01:09:03.030
没用了

01:09:03.030 --> 01:09:05.030
函数已经结束了

01:09:05.030 --> 01:09:07.030
就相当于在强行的位置运行

01:09:07.030 --> 01:09:10.030
完了过后强行加一个return

01:09:10.030 --> 01:09:13.730
强行加一个return

01:09:13.730 --> 01:09:14.730
就是这么个意思

01:09:14.730 --> 01:09:16.730
没了

01:09:17.730 --> 01:09:18.730
这就是关于生存器

01:09:18.730 --> 01:09:19.730
我们要复习的知识

01:09:19.730 --> 01:09:21.730
好好去梳理一下这些知识

01:09:21.730 --> 01:09:22.730
这些知识非常非常重要

01:09:22.730 --> 01:09:24.730
对我们后面要理解这个saga

01:09:24.730 --> 01:09:25.730
不然的话你真的不知道

01:09:25.730 --> 01:09:27.730
它在干吗

01:09:27.730 --> 01:09:30.730
对 还有一个东西

01:09:30.730 --> 01:09:32.730
还有东西我要说一下

01:09:34.730 --> 01:09:41.860
在生存器内部调用其他生存器

01:09:41.860 --> 01:09:47.860
若需要在生存器内部调用

01:09:47.860 --> 01:09:49.860
其他生存器

01:09:49.860 --> 01:09:51.860
调用其他生存器

01:09:51.860 --> 01:09:52.860
注意

01:09:52.860 --> 01:09:55.860
如果直接调用

01:09:56.860 --> 01:09:59.860
得到的是一个生存器

01:10:00.860 --> 01:10:03.860
如果加入新号调用

01:10:04.860 --> 01:10:09.860
则进入其生存器内部执行

01:10:09.860 --> 01:10:10.860
什么意思

01:10:10.860 --> 01:10:12.860
这个说真的很抽象

01:10:12.860 --> 01:10:13.860
说起来真的很抽象

01:10:13.860 --> 01:10:15.860
我们只能举例子

01:10:15.860 --> 01:10:17.860
这个还蛮重要的

01:10:18.860 --> 01:10:19.860
比方说

01:10:19.860 --> 01:10:21.860
又有这么一个例子

01:10:21.860 --> 01:10:22.860
这里的生存器

01:10:22.860 --> 01:10:25.860
比方说我们这里写上一个

01:10:27.860 --> 01:10:28.860
就放在这吧

01:10:28.860 --> 01:10:29.860
就放在这

01:10:29.860 --> 01:10:31.860
我们这里再写个函数

01:10:31.860 --> 01:10:33.860
这个函数也是个生存器

01:10:35.860 --> 01:10:37.860
G2

01:10:37.860 --> 01:10:38.860
第二个生存器

01:10:38.860 --> 01:10:40.860
这个函数我们就输出一个

01:10:40.860 --> 01:10:41.860
G2

01:10:42.860 --> 01:10:43.860
开始

01:10:45.860 --> 01:10:47.860
那么G2

01:10:47.860 --> 01:10:49.860
运行1

01:10:50.860 --> 01:10:51.860
这里我们

01:10:51.860 --> 01:10:53.860
net results

01:10:53.860 --> 01:10:54.860
yield

01:10:54.860 --> 01:10:56.860
G1

01:10:57.860 --> 01:10:58.860
然后

01:10:59.860 --> 01:11:02.860
net results

01:11:04.860 --> 01:11:05.860
这个去掉

01:11:07.860 --> 01:11:08.860
等于

01:11:08.860 --> 01:11:09.860
yield

01:11:09.860 --> 01:11:10.860
G2

01:11:11.860 --> 01:11:12.860
好行了吧

01:11:12.860 --> 01:11:13.860
行了

01:11:14.860 --> 01:11:15.860
然后我们在这里

01:11:16.860 --> 01:11:18.860
比方说我们在这里写上这么一句话

01:11:19.860 --> 01:11:20.860
G2

01:11:21.860 --> 01:11:22.860
好你看一下

01:11:24.860 --> 01:11:26.860
咱们来看一下

01:11:27.860 --> 01:11:29.860
好那么现在我们来看

01:11:29.860 --> 01:11:33.490
首先大家思考这么一个问题

01:11:33.490 --> 01:11:35.490
这个函数里面要带吗

01:11:35.490 --> 01:11:37.490
我们运行这个generator

01:11:37.490 --> 01:11:38.490
我们肯定是运行的是

01:11:38.490 --> 01:11:40.490
通过这个generator生存器

01:11:40.490 --> 01:11:41.490
generator

01:11:41.490 --> 01:11:43.490
那么我们调问一个generator

01:11:43.490 --> 01:11:44.490
调问一个内涩过程中

01:11:44.490 --> 01:11:46.490
会不会输出这些东西

01:11:46.490 --> 01:11:47.490
会不会输出这些东西

01:11:47.490 --> 01:11:49.490
会不会等待

01:11:49.490 --> 01:11:50.490
好好想一想

01:11:51.490 --> 01:11:53.490
好想想我们之前讲的逻辑

01:11:54.490 --> 01:11:56.490
会不会等待了

01:11:56.490 --> 01:11:57.490
会不会输出这些东西

01:11:57.490 --> 01:11:59.490
我告诉你什么都不会输出

01:11:59.490 --> 01:12:01.490
开始

01:12:01.490 --> 01:12:03.490
你看运行1

01:12:03.490 --> 01:12:04.490
运行2

01:12:04.490 --> 01:12:05.490
运行3

01:12:05.490 --> 01:12:06.490
结束

01:12:06.490 --> 01:12:07.490
跟它有关系吗

01:12:07.490 --> 01:12:08.490
没关系

01:12:08.490 --> 01:12:09.490
但是老师

01:12:09.490 --> 01:12:11.490
那这个函数这样的东西在哪去了

01:12:11.490 --> 01:12:13.490
你是不是又忘了

01:12:13.490 --> 01:12:15.490
这是个生存器函数

01:12:15.490 --> 01:12:16.490
调用生存器函数

01:12:16.490 --> 01:12:18.490
会运行函数题吗

01:12:18.490 --> 01:12:19.490
是不是不会运行

01:12:19.490 --> 01:12:20.490
它得到的是一个生存器

01:12:20.490 --> 01:12:22.490
这个函数返回的结果是一个生存器

01:12:22.490 --> 01:12:24.490
我们不要说在这里

01:12:24.490 --> 01:12:25.490
写一个rid

01:12:25.490 --> 01:12:26.490
就是G

01:12:26.490 --> 01:12:27.490
输出G

01:12:27.490 --> 01:12:29.490
你看一下G是啥

01:12:29.490 --> 01:12:30.490
一开始没有运行G

01:12:30.490 --> 01:12:31.490
一开始运行到这

01:12:31.490 --> 01:12:32.490
卡在这的

01:12:32.490 --> 01:12:34.490
然后下一次那个时候运行

01:12:34.490 --> 01:12:35.490
运行到这么几句话

01:12:35.490 --> 01:12:36.490
都要运行

01:12:36.490 --> 01:12:37.490
然后卡在这

01:12:37.490 --> 01:12:38.490
然后卡在这

01:12:38.490 --> 01:12:40.490
前面几句话都要运行

01:12:40.490 --> 01:12:41.490
那么下一次那个时候

01:12:41.490 --> 01:12:42.490
你看一下

01:12:44.490 --> 01:12:46.490
我们这里调用了G

01:12:46.490 --> 01:12:47.490
看一下

01:12:47.490 --> 01:12:48.490
之前的

01:12:48.490 --> 01:12:49.490
这句话输出了

01:12:50.490 --> 01:12:51.490
我们输出了G呢

01:12:51.490 --> 01:12:52.490
等一下

01:12:52.490 --> 01:12:54.490
这里保存了吗

01:12:54.490 --> 01:12:56.490
我特色五云

01:12:56.490 --> 01:12:58.490
我说怎么回事

01:12:59.490 --> 01:13:00.490
不过效果是一样的

01:13:00.490 --> 01:13:01.490
那个是

01:13:01.490 --> 01:13:02.490
一开始

01:13:02.490 --> 01:13:03.490
卡在这

01:13:03.490 --> 01:13:04.490
卡在这

01:13:04.490 --> 01:13:05.490
下面我们再运行

01:13:05.490 --> 01:13:06.490
那个是

01:13:06.490 --> 01:13:08.490
你看一下它输出了什么

01:13:08.490 --> 01:13:09.490
它把这个负责负出为昂迪凡

01:13:09.490 --> 01:13:11.490
因为我这里没有传递参数

01:13:11.490 --> 01:13:12.490
这里没传递参数

01:13:12.490 --> 01:13:13.490
所以说这里是昂迪凡

01:13:13.490 --> 01:13:14.490
这个没问题

01:13:14.490 --> 01:13:15.490
然后调用G2

01:13:15.490 --> 01:13:16.490
G是不是个生存器

01:13:16.490 --> 01:13:17.490
得到G

01:13:17.490 --> 01:13:18.490
然后输出G

01:13:18.490 --> 01:13:19.490
生存器

01:13:19.490 --> 01:13:20.490
生存器对象

01:13:20.490 --> 01:13:21.490
好

01:13:21.490 --> 01:13:22.490
然后再运行这个

01:13:22.490 --> 01:13:23.490
输出了什么

01:13:23.490 --> 01:13:24.490
昂迪凡的

01:13:24.490 --> 01:13:25.490
昂迪凡的

01:13:25.490 --> 01:13:27.490
然后得到E2的结果

01:13:27.490 --> 01:13:28.490
2V2

01:13:28.490 --> 01:13:29.490
当为Force

01:13:29.490 --> 01:13:30.490
是这样子的

01:13:30.490 --> 01:13:31.490
它不会进入到

01:13:31.490 --> 01:13:33.490
这个生存器内部去执行

01:13:33.490 --> 01:13:34.490
如果说

01:13:34.490 --> 01:13:35.490
你希望进入到

01:13:35.490 --> 01:13:37.490
生存器内部的执行的话

01:13:37.490 --> 01:13:38.490
在生存器里边

01:13:38.490 --> 01:13:39.490
在运行一个生存器的时候

01:13:39.490 --> 01:13:40.490
如果说

01:13:40.490 --> 01:13:41.490
希望生入到

01:13:41.490 --> 01:13:43.490
另一个生存器内部去执行

01:13:43.490 --> 01:13:45.490
勤力加上E

01:13:45.490 --> 01:13:47.490
加上E

01:13:47.490 --> 01:13:49.930
现在再看

01:13:49.930 --> 01:13:50.930
现在再看

01:13:50.930 --> 01:13:54.430
还要加个新号

01:13:54.430 --> 01:13:55.430
不加新号还不行

01:13:55.430 --> 01:13:56.430
不加新号不行

01:13:56.430 --> 01:13:57.430
如果说你不加新号的话

01:13:57.430 --> 01:13:58.430
那就是把G2

01:13:58.430 --> 01:13:59.430
G2是不是个寒说

01:13:59.430 --> 01:14:00.430
调用了返回

01:14:00.430 --> 01:14:01.430
是不是得到一个生存器

01:14:01.430 --> 01:14:02.430
它会把生存器

01:14:02.430 --> 01:14:03.430
作为这一次

01:14:03.430 --> 01:14:04.430
迭代的结果

01:14:04.430 --> 01:14:05.430
那如果你不加新号

01:14:05.430 --> 01:14:06.430
你看一下

01:14:06.430 --> 01:14:07.430
第一次

01:14:07.430 --> 01:14:08.430
卡在这没问题吧

01:14:08.430 --> 01:14:09.430
好 第二次

01:14:09.430 --> 01:14:10.430
那个是

01:14:10.430 --> 01:14:11.430
是不是得到一个

01:14:11.430 --> 01:14:13.430
生存器对象

01:14:13.430 --> 01:14:14.430
对吧

01:14:14.430 --> 01:14:15.430
调用这个寒说

01:14:15.430 --> 01:14:16.430
得到一个生存器对象

01:14:16.430 --> 01:14:17.430
它并没有生存到

01:14:17.430 --> 01:14:18.430
它里边去执行

01:14:18.430 --> 01:14:19.430
如果说你要生存到

01:14:19.430 --> 01:14:20.430
执行的话

01:14:20.430 --> 01:14:22.430
你必须要加上新号

01:14:22.430 --> 01:14:23.430
加上新号过后

01:14:23.430 --> 01:14:25.430
E有的加上新号过后

01:14:25.430 --> 01:14:26.430
必须要用这种语法

01:14:26.430 --> 01:14:27.430
E有的加新号

01:14:27.430 --> 01:14:28.430
然后这里写

01:14:28.430 --> 01:14:29.430
另一个生存器

01:14:29.430 --> 01:14:30.430
去调用另一个生存器

01:14:30.430 --> 01:14:31.430
好 那么这个时候

01:14:31.430 --> 01:14:32.430
它会

01:14:32.430 --> 01:14:33.430
它是一种特殊语法

01:14:33.430 --> 01:14:34.430
它会进入

01:14:34.430 --> 01:14:35.430
这个生存器内部去执行

01:14:35.430 --> 01:14:36.430
好 咱们去看一下

01:14:36.430 --> 01:14:37.430
那个是

01:14:37.430 --> 01:14:38.430
你看到这了

01:14:38.430 --> 01:14:39.430
卡在这

01:14:39.430 --> 01:14:40.430
好 那么现在呢

01:14:40.430 --> 01:14:41.430
继续

01:14:41.430 --> 01:14:42.430
那个是

01:14:42.430 --> 01:14:43.430
你看G2开始

01:14:43.430 --> 01:14:44.430
怎么运行的

01:14:44.430 --> 01:14:45.430
怎么运行到这

01:14:45.430 --> 01:14:46.430
好 生到这里

01:14:46.430 --> 01:14:47.430
被去执行了

01:14:47.430 --> 01:14:48.430
生到这里

01:14:48.430 --> 01:14:49.430
是不是卡在这

01:14:49.430 --> 01:14:50.430
得到G1

01:14:50.430 --> 01:14:51.430
看到没有

01:14:51.430 --> 01:14:52.430
得到G1

01:14:52.430 --> 01:14:53.430
然后

01:14:53.430 --> 01:14:55.430
下面再调用那个时候

01:14:55.430 --> 01:14:56.430
那个时候

01:14:56.430 --> 01:14:57.430
给它传一个ABC

01:14:57.430 --> 01:14:58.430
那么现在呢

01:14:58.430 --> 01:14:59.430
就是把这个ABC传给result

01:14:59.430 --> 01:15:00.430
对吧

01:15:00.430 --> 01:15:01.430
传给result

01:15:01.430 --> 01:15:02.430
然后呢

01:15:02.430 --> 01:15:04.430
然后我这里没打印出来

01:15:04.430 --> 01:15:05.430
没打印出来

01:15:05.430 --> 01:15:06.430
然后用运行G2运行1

01:15:06.430 --> 01:15:07.430
看到没有

01:15:07.430 --> 01:15:08.430
G2运行1

01:15:08.430 --> 01:15:09.430
然后又卡在这

01:15:09.430 --> 01:15:10.430
对吧

01:15:10.430 --> 01:15:11.430
得到的结果是G2

01:15:11.430 --> 01:15:12.430
G2

01:15:12.430 --> 01:15:14.430
然后现在在那个时候运行

01:15:14.430 --> 01:15:15.430
那个时候运行

01:15:15.430 --> 01:15:17.430
那个时候运行过后

01:15:17.430 --> 01:15:18.430
继续往后

01:15:18.430 --> 01:15:19.430
继续往后

01:15:19.430 --> 01:15:20.430
输出这个

01:15:20.430 --> 01:15:21.430
输出这个

01:15:21.430 --> 01:15:22.430
这个

01:15:22.430 --> 01:15:23.430
然后呢

01:15:23.430 --> 01:15:24.430
又得到这个

01:15:24.430 --> 01:15:25.430
得到这个

01:15:25.430 --> 01:15:26.430
卡在这

01:15:26.430 --> 01:15:27.430
现在是2

01:15:27.430 --> 01:15:28.430
2

01:15:28.430 --> 01:15:29.430
2

01:15:29.430 --> 01:15:30.430
2

01:15:30.430 --> 01:15:31.430
2

01:15:31.430 --> 01:15:32.430
2

01:15:32.430 --> 01:15:33.430
2

01:15:33.430 --> 01:15:34.430
2

01:15:34.430 --> 01:15:35.430
2

01:15:35.430 --> 01:15:36.430
2

01:15:36.430 --> 01:15:37.430
2

01:15:37.430 --> 01:15:38.430
2

01:15:38.430 --> 01:15:39.430
2

01:15:39.430 --> 01:15:40.430
2

01:15:40.430 --> 01:15:41.430
2

01:15:41.430 --> 01:15:42.430
2

01:15:42.430 --> 01:15:43.430
2

01:15:43.430 --> 01:15:44.430
2

01:15:44.430 --> 01:15:45.430
2

01:15:45.430 --> 01:15:46.430
2

01:15:46.430 --> 01:15:47.430
卡在这

01:15:47.430 --> 01:15:48.430
现在是2

01:15:48.430 --> 01:15:49.430
卡在这

01:15:49.430 --> 01:15:51.430
就伸入到它里边去运行了

01:15:51.430 --> 01:15:52.430
在生存器内部

01:15:52.430 --> 01:15:54.430
如果你要伸入到另一个生存器里边去运行

01:15:54.430 --> 01:15:55.430
必须要用这种方式

01:15:55.430 --> 01:15:57.430
否则的话你会得到一个生存器对象

01:15:57.430 --> 01:15:59.430
你拿这个对象也毫无办法

01:15:59.430 --> 01:16:00.430
对吧

01:16:00.430 --> 01:16:01.430
好 就这一块

01:16:01.430 --> 01:16:02.430
另外一个就是说

01:16:02.430 --> 01:16:04.430
如果你调用一个生存器对象的

01:16:04.430 --> 01:16:05.430
它的反回值是什么

01:16:05.430 --> 01:16:07.430
就是个函数的反回值

01:16:07.430 --> 01:16:08.430
它不再是那个时候的反回值了

01:16:08.430 --> 01:16:09.430
那个是反回值

01:16:09.430 --> 01:16:10.430
它只会影响E有的

01:16:10.430 --> 01:16:11.430
它不会影响E有的新号

01:16:11.430 --> 01:16:12.430
比如说

01:16:12.430 --> 01:16:13.430
这里的

01:16:13.430 --> 01:16:14.430
反回值

01:16:14.430 --> 01:16:15.430
这里的反回值

01:16:15.430 --> 01:16:17.430
这都是函数的反回值

01:16:17.430 --> 01:16:18.430
Result

01:16:18.430 --> 01:16:21.430
为G2的反回值

01:16:21.430 --> 01:16:25.430
为G2函数的反回值

01:16:25.430 --> 01:16:27.430
函数的反回值

01:16:27.430 --> 01:16:28.430
为什么呢

01:16:28.430 --> 01:16:29.430
因为你调

01:16:29.430 --> 01:16:30.430
卡在这的时候

01:16:30.430 --> 01:16:31.430
你调到那个时候

01:16:31.430 --> 01:16:32.430
该传那个ABC

01:16:32.430 --> 01:16:33.430
是不是把ABC复制给result的

01:16:33.430 --> 01:16:34.430
对吧

01:16:34.430 --> 01:16:35.430
它并不是复制给它的

01:16:35.430 --> 01:16:36.430
是复制给这的

01:16:36.430 --> 01:16:37.430
对不对

01:16:37.430 --> 01:16:38.430
复制给这的

01:16:38.430 --> 01:16:39.430
好 那么这个函数运行完了

01:16:39.430 --> 01:16:40.430
这个函数反回来是undefined

01:16:40.430 --> 01:16:42.430
那么它再会把这个undefined

01:16:42.430 --> 01:16:43.430
复制给result

01:16:44.430 --> 01:16:45.430
再来说一次

01:16:45.430 --> 01:16:47.430
比方说我们看一下吧

01:16:47.430 --> 01:16:48.430
那个是

01:16:49.430 --> 01:16:51.430
这里不反回undefined

01:16:51.430 --> 01:16:52.430
return

01:16:52.430 --> 01:16:53.430
123

01:16:53.430 --> 01:16:56.060
好 看着

01:16:56.060 --> 01:16:58.060
那个是运行卡在这

01:16:58.060 --> 01:16:59.060
卡在这

01:16:59.060 --> 01:17:00.060
得到的结果是

01:17:00.060 --> 01:17:01.060
1

01:17:01.060 --> 01:17:02.060
对不对

01:17:02.060 --> 01:17:03.060
再再用那个

01:17:03.060 --> 01:17:04.060
G2开始

01:17:04.060 --> 01:17:05.060
好 现在卡在这

01:17:05.060 --> 01:17:07.060
得到的结果是G1

01:17:07.060 --> 01:17:08.060
对不对

01:17:08.060 --> 01:17:11.700
好 然后再运行

01:17:11.700 --> 01:17:12.700
是不是卡在这

01:17:12.700 --> 01:17:14.700
得到的结果是G2

01:17:14.700 --> 01:17:15.700
好 那么现在

01:17:16.700 --> 01:17:17.700
下面再运行

01:17:17.700 --> 01:17:19.700
我给它传一个abc

01:17:20.700 --> 01:17:21.700
abc 它传给谁呢

01:17:21.700 --> 01:17:22.700
传个result 继续运行

01:17:22.700 --> 01:17:23.700
传个result

01:17:24.700 --> 01:17:25.700
result里面放了abc

01:17:25.700 --> 01:17:26.700
但是我没有把result返回

01:17:26.700 --> 01:17:27.700
返回的是123

01:17:27.700 --> 01:17:29.700
那么它就把123

01:17:29.700 --> 01:17:30.700
复制给result

01:17:30.700 --> 01:17:31.700
这里有点区别

01:17:31.700 --> 01:17:32.700
复制给result

01:17:32.700 --> 01:17:34.700
然后这里输出的是123

01:17:34.700 --> 01:17:35.700
对不对

01:17:35.700 --> 01:17:36.700
123

01:17:36.700 --> 01:17:37.700
然后继续运行就卡在这

01:17:37.700 --> 01:17:38.700
2

01:17:38.700 --> 01:17:39.700
得到的结果是2

01:17:39.700 --> 01:17:40.700
对不对

01:17:40.700 --> 01:17:41.700
所以这里记一笔

01:17:42.700 --> 01:17:44.700
如果是

01:17:44.700 --> 01:17:46.700
eo的

01:17:46.700 --> 01:17:47.700
新号

01:17:47.700 --> 01:17:49.700
如果是这种方式来调用

01:17:49.700 --> 01:17:51.700
关上代码格式

01:17:52.700 --> 01:17:53.700
调用

01:17:55.700 --> 01:17:56.700
韩数

01:17:57.700 --> 01:17:58.700
这种方式调用

01:17:58.700 --> 01:17:59.700
调用生成器

01:17:59.700 --> 01:18:00.700
韩数

01:18:01.700 --> 01:18:03.700
主要这个地方不能是普通韩数

01:18:03.700 --> 01:18:04.700
用这种方式调用

01:18:04.700 --> 01:18:05.700
必须是个生成器韩数

01:18:05.700 --> 01:18:07.700
调用生成器韩数

01:18:07.700 --> 01:18:08.700
则

01:18:08.700 --> 01:18:09.700
则

01:18:09.700 --> 01:18:10.700
则

01:18:10.700 --> 01:18:11.700
则

01:18:11.700 --> 01:18:13.700
该韩数的返回结果

01:18:13.700 --> 01:18:14.700
为

01:18:14.700 --> 01:18:16.700
该表达式的结果

01:18:16.700 --> 01:18:17.700
有这个

01:18:17.700 --> 01:18:18.700
这个表达式的结果

01:18:18.700 --> 01:18:19.700
是这个韩数的返回结果

01:18:19.700 --> 01:18:21.700
而不是那个式的参数了

01:18:21.700 --> 01:18:23.700
这个大家注意一下

01:18:23.700 --> 01:18:25.700
其他就没了

01:18:25.700 --> 01:18:27.700
其他就没有啥了

01:18:27.700 --> 01:18:28.700
没有啥了

01:18:28.700 --> 01:18:29.700
什么东西这一块

01:18:29.700 --> 01:18:30.700
我要去理一下

01:18:30.700 --> 01:18:31.700
东西有点多

01:18:31.700 --> 01:18:32.700
又特别特别的热

01:18:32.700 --> 01:18:34.700
这一块你理清楚了过后

01:18:34.700 --> 01:18:35.700
你对理解Saga

01:18:35.700 --> 01:18:36.700
基本上就没多少问题了

01:18:36.700 --> 01:18:37.700
Saga

01:18:37.700 --> 01:18:39.700
就全是基于这些东西来做的

01:18:39.700 --> 01:18:40.700
这是关于这一块

