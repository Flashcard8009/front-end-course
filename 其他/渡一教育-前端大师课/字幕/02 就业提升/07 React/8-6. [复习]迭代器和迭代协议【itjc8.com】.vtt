WEBVTT

00:00.750 --> 00:05.450
好 我们自此呢已经学了两个中间键了对吧

00:05.450 --> 00:08.950
都可以解决那个副作用的问题

00:08.950 --> 00:11.450
一个呢是咱们来回归一下啊

00:11.450 --> 00:14.250
就是解决副作用的中间键

00:14.250 --> 00:17.950
解决副作用的中间键

00:17.950 --> 00:21.500
Redux中间键

00:21.500 --> 00:24.600
有哪些呢 我们这里呢已经学了第一个啊

00:24.600 --> 00:27.300
就是回忆一下啊

00:27.300 --> 00:29.500
就是ReduxSunk

00:29.500 --> 00:30.700
做什么用的呢

00:30.700 --> 00:34.100
它是呢需要啊需要改动Action

00:34.100 --> 00:35.700
需要改动Action

00:35.700 --> 00:39.100
可接受啊

00:39.100 --> 00:43.600
可接受Action是一个函数对不对

00:43.600 --> 00:45.400
一个带有副作用的函数

00:45.400 --> 00:46.900
这是Sunk这个中间键啊

00:46.900 --> 00:48.700
它也是非常非常简单的

00:48.700 --> 00:51.100
当时我们还分析了它的原码实现

00:51.100 --> 00:53.500
原码实现的也非常非常简单

00:53.500 --> 00:57.300
然后呢我们又学了一个就是ReduxPromise啊

00:57.300 --> 01:00.500
那么它也是需要改动Action啊

01:00.700 --> 01:03.100
可接收

01:03.100 --> 01:04.700
可接收什么了

01:04.700 --> 01:08.900
Action是一个Promise对象啊

01:08.900 --> 01:10.700
是一个Promise对象

01:10.700 --> 01:16.100
或Action是Action的Payload的啊

01:16.100 --> 01:18.700
是一个Promise对象

01:18.700 --> 01:19.300
也就是说呢

01:19.300 --> 01:22.500
它们都需要对Action的做出改动

01:22.500 --> 01:23.700
但是这样子一来呢

01:23.700 --> 01:25.500
就是这两个中间键呢

01:25.500 --> 01:28.900
它会怎么说

01:28.900 --> 01:33.100
它会那个无法保持Redux的存进

01:33.100 --> 01:34.000
Redux呢

01:34.000 --> 01:38.600
它要求Action是一个非常非常简单的一个

01:38.600 --> 01:39.600
平面对象

01:39.600 --> 01:42.700
一个非常非常简单的一个平面对象

01:42.700 --> 01:43.300
Redux呢

01:43.300 --> 01:44.600
也是一个存函数

01:44.600 --> 01:46.100
包括Action的创建函数

01:46.100 --> 01:47.400
也是一个存函数

01:47.400 --> 01:49.000
没有任何副作用

01:49.000 --> 01:50.300
但是这样子一来的话

01:50.300 --> 01:53.200
它无论是Sunk还是Promise

01:53.200 --> 01:55.600
它们都会导致Action发生变动

01:55.600 --> 01:58.600
它不再是一个简单的平面对象的啊

01:58.600 --> 02:00.900
变成了一个有带有副作用的东西了

02:00.900 --> 02:03.500
这不是Redux的初衷

02:03.500 --> 02:06.100
虽然说这两个中间键可以解决副作用了

02:06.100 --> 02:06.500
但是呢

02:06.500 --> 02:07.300
它带

02:07.300 --> 02:09.200
而且用起来也很简单

02:09.200 --> 02:09.600
但是呢

02:09.600 --> 02:11.100
这两个中间键呢

02:11.100 --> 02:11.600
它带来呢

02:11.600 --> 02:13.500
还是带来不少的影响

02:13.500 --> 02:17.000
它影响了Redux的存进

02:17.000 --> 02:21.300
就是以上两个中间键

02:21.300 --> 02:25.500
会导致Action

02:25.500 --> 02:29.200
或Action创建函数

02:29.200 --> 02:33.800
不再存击

02:33.800 --> 02:36.200
就是它会带有一些乱七八糟的东西

02:36.200 --> 02:38.100
不是Redux的初衷

02:38.100 --> 02:39.600
那么有没有一种中间键

02:39.600 --> 02:41.500
它既可以解决副作用

02:41.500 --> 02:46.000
又可以保持Action和Redux的存进

02:46.000 --> 02:48.900
跟之前我们学的Redux是一样的

02:48.900 --> 02:50.600
而且用起来又简单

02:50.600 --> 02:50.900
而且呢

02:50.900 --> 02:52.600
功能又非常非常强大呢

02:52.600 --> 02:54.500
有没有这样的一个中间键呢

02:54.500 --> 02:55.100
有

02:55.100 --> 02:57.100
就是我们接下来要重点

02:57.100 --> 03:01.300
花很多捷克要讲的Saga

03:01.300 --> 03:04.700
就是Redux Saga

03:04.700 --> 03:07.800
将解决这样的问题

03:07.800 --> 03:09.100
它不仅可以

03:09.100 --> 03:15.000
它不仅可以保持Action和Action

03:15.000 --> 03:16.000
保持Action

03:16.000 --> 03:18.800
Action创建函数

03:18.800 --> 03:22.400
以及Redux的存进

03:22.500 --> 03:28.200
而且可以用模块化的方式

03:28.200 --> 03:29.400
解决副作用

03:29.400 --> 03:30.700
我们之后学了过后了

03:30.700 --> 03:31.800
你就会看到了

03:31.800 --> 03:33.500
解决副作用

03:33.500 --> 03:37.800
并且功能非常强大

03:37.800 --> 03:40.100
这就是Redux Saga

03:40.100 --> 03:41.200
我们其实后边

03:41.200 --> 03:43.000
无论学习什么Diva

03:43.000 --> 03:44.700
还有什么UmiJS

03:44.700 --> 03:47.000
还有那乱七八糟的大腿玩意

03:47.000 --> 03:49.200
他们最终都用到了Saga

03:49.200 --> 03:51.700
来解决这样的一个副作用问题

03:51.700 --> 03:53.500
包括说Viu

03:53.500 --> 03:55.200
Viu.js里边

03:55.200 --> 03:56.300
它解决副作用的

03:56.300 --> 03:58.900
也是参考了Saga这种方式

03:58.900 --> 04:02.700
当然它的实际上做法有点不一样

04:02.700 --> 04:05.400
但是它实际上参考了Saga这种方式

04:05.400 --> 04:07.000
我们之后学到Diva

04:07.000 --> 04:07.900
学到UmiJS

04:07.900 --> 04:10.500
你会慢慢发现了

04:10.500 --> 04:13.200
这就是我们接下来要很多捷克

04:13.200 --> 04:14.000
要讲的东西

04:14.000 --> 04:14.900
Saga

04:14.900 --> 04:16.800
但是Saga有一个特点

04:16.800 --> 04:18.200
它比较难学

04:18.200 --> 04:19.500
它没有那么简单

04:19.500 --> 04:21.100
学起来没有那么简单

04:21.200 --> 04:22.500
当你学懂了之后

04:22.500 --> 04:24.100
你用起来就简单了

04:24.100 --> 04:26.300
我之前在线下售后的时候

04:26.300 --> 04:27.300
发现Saga这个

04:27.300 --> 04:28.100
每次讲到Saga

04:28.100 --> 04:30.400
这真的是云一大片

04:30.400 --> 04:31.700
后来我慢慢的去总结

04:31.700 --> 04:35.300
发现了同学们对Saga这一块之所以云

04:35.300 --> 04:38.900
是因为他们之前的一些基础

04:38.900 --> 04:40.700
掌握得不够牢固

04:40.700 --> 04:41.600
什么基础呢

04:41.600 --> 04:43.000
因为Saga这个东西

04:43.000 --> 04:46.500
它要用到我们之前在学ES6的时候

04:46.500 --> 04:50.100
要用到一个东西叫做生存器

04:50.100 --> 04:52.500
也叫Retax Saga

04:52.500 --> 05:02.000
是建立在ES6的生存器基础上的

05:02.000 --> 05:03.400
也就是说要离

05:03.400 --> 05:06.500
要熟练的使

05:06.500 --> 05:08.200
我们都不说分析原码了

05:08.200 --> 05:10.700
Saga的原码是比较复杂的

05:10.700 --> 05:13.200
虽然说代码可能不多

05:13.200 --> 05:17.700
但你要理解起来非常非常恶心

05:17.700 --> 05:18.900
但是你要说

05:18.900 --> 05:20.100
如何去使用它的话

05:20.100 --> 05:21.900
实际上还好

05:21.900 --> 05:24.900
要熟练的使用Saga

05:24.900 --> 05:28.300
必须理解生存器

05:28.300 --> 05:30.900
一对生存器能理解的越深刻

05:30.900 --> 05:31.900
对Saga

05:31.900 --> 05:35.600
你就使用起来你就越得心应受

05:35.600 --> 05:38.900
其实之前我发现了一个现象就是

05:38.900 --> 05:40.900
那如果说你不理解生存器

05:40.900 --> 05:42.100
你能不能学Saga呢

05:42.100 --> 05:43.500
其实还是能学

05:43.500 --> 05:44.900
它一种固定的模式

05:44.900 --> 05:46.200
一种固定的写法

05:46.200 --> 05:46.800
你知道

05:46.800 --> 05:48.800
只要知道它怎么写就行了

05:48.800 --> 05:49.500
我再说一下

05:49.500 --> 05:51.300
Saga的东西你是跑不了的

05:51.300 --> 05:52.200
不要你认为

05:52.200 --> 05:54.800
我之前有了两个中间键Sung Promise

05:54.800 --> 05:56.300
可以解决副作用的问题

05:56.300 --> 05:57.800
我就不用学Saga了

05:57.800 --> 05:58.600
不行

05:58.600 --> 05:59.700
因为以后公司里面

05:59.700 --> 06:01.700
一定是用Saga解决问题的

06:01.700 --> 06:02.900
尽管了他们

06:02.900 --> 06:04.000
你们以后到公司里面

06:04.000 --> 06:05.700
可能会用一些DVAR

06:05.700 --> 06:06.400
無密解释

06:06.400 --> 06:08.800
可能会在Saga基础上

06:08.800 --> 06:11.500
进一步的封装

06:11.500 --> 06:13.700
可能用起来要简单一点

06:13.700 --> 06:14.600
只不过

06:14.600 --> 06:16.900
但是你要去用一些很特殊的场景

06:16.900 --> 06:19.000
或者说你要去灵活应用它的话

06:19.000 --> 06:20.800
还是得跑不掉

06:20.800 --> 06:21.900
还是得学习Saga

06:21.900 --> 06:23.800
所以说你这一块跑不掉的

06:23.800 --> 06:25.200
Saga你至少

06:25.200 --> 06:26.100
我可能

06:26.100 --> 06:27.900
我不要求你说

06:27.900 --> 06:29.000
在我们这门客里边

06:29.000 --> 06:30.800
你要去掌握Saga的原码

06:30.800 --> 06:32.100
这个不要求

06:32.100 --> 06:33.300
这个呢

06:33.300 --> 06:35.200
如果说你已经工作了一年了

06:35.200 --> 06:36.000
两年了

06:36.000 --> 06:38.800
你想回过头来再深入的去了解Saga

06:38.800 --> 06:40.500
需要去看一下它的原码

06:40.500 --> 06:41.900
但是呢

06:41.900 --> 06:42.600
它怎么去用

06:42.600 --> 06:44.400
你必须要回

06:44.400 --> 06:44.800
但是呢

06:44.800 --> 06:45.600
你如果说

06:45.600 --> 06:47.800
你不知道生成器的话

06:47.800 --> 06:48.900
那么

06:48.900 --> 06:51.100
你要灵活应用

06:51.100 --> 06:52.300
那就有困难了

06:52.300 --> 06:54.100
但是你运用起来还是没问题

06:54.100 --> 06:54.800
还是没问题

06:54.800 --> 06:55.700
还是可以用

06:55.700 --> 06:56.300
但是呢

06:56.300 --> 06:58.800
你要灵活应用就比较困难了

06:58.800 --> 06:59.300
所以说呢

06:59.300 --> 07:00.300
考虑到这一点

07:00.300 --> 07:01.500
又考虑到咱们这个呢

07:01.500 --> 07:03.300
是一个视频课程

07:03.300 --> 07:04.900
有没有时长限制

07:04.900 --> 07:06.300
我想多讲一点呢

07:06.300 --> 07:07.800
就尽量多讲一点

07:07.800 --> 07:08.200
所以说呢

07:08.200 --> 07:09.800
我们在讲Saga之前呢

07:09.800 --> 07:11.700
我们有必要对

07:11.700 --> 07:14.200
生成器做一个复习

07:14.200 --> 07:14.600
但是呢

07:14.600 --> 07:16.800
要理解生成器

07:16.800 --> 07:19.400
要理解生成器

07:19.400 --> 07:23.000
又必须先理解

07:23.000 --> 07:27.880
迭代器和可迭代协议

07:27.880 --> 07:29.780
你要理解的这两个东西呢

07:29.780 --> 07:32.080
你才能理解生成器

07:32.080 --> 07:32.780
所以说呢

07:32.780 --> 07:33.880
我们这一块呢

07:33.880 --> 07:35.180
又得先去讲

07:35.180 --> 07:37.680
迭代器和可迭代协议

07:37.680 --> 07:38.580
你看这意思吗

07:38.580 --> 07:40.080
所以说我们这节课呢

07:40.080 --> 07:42.080
以及后面我们复习

07:42.080 --> 07:43.380
这节课相当于是个复习

07:43.380 --> 07:45.380
因为ES6都讲过嘛

07:45.780 --> 07:46.180
只不过呢

07:46.180 --> 07:47.580
后面我们平时很少用

07:47.580 --> 07:49.180
可能很多同学都忘记了

07:49.180 --> 07:49.880
另外一个呢

07:49.880 --> 07:51.680
就是我们这里借课了

07:51.680 --> 07:53.980
复习迭代器和可迭代协议

07:53.980 --> 07:54.680
那么下节课呢

07:54.680 --> 07:56.680
我们还要去复习一下生成器

07:56.680 --> 07:57.880
把这些东西呢

07:57.880 --> 07:58.680
复习完了

07:58.680 --> 07:59.080
然后呢

07:59.080 --> 08:00.680
我们再去进入Saga来学习

08:00.680 --> 08:02.080
你会发现的学习呢

08:02.080 --> 08:03.580
要轻松很多啊

08:03.580 --> 08:05.180
好理解很多

08:05.180 --> 08:06.180
那这意思吗

08:06.180 --> 08:06.880
咱们呢

08:06.880 --> 08:07.480
这几课

08:07.480 --> 08:10.980
先来复习迭代器和可迭代协议

08:10.980 --> 08:11.780
复习这一课

08:11.780 --> 08:13.680
主要目的是为了下一课

08:13.680 --> 08:14.880
咱们复习生成器

08:16.380 --> 08:17.080
好

08:17.880 --> 08:19.880
那么这里我们一个说

08:19.880 --> 08:20.580
这里的节课呢

08:20.580 --> 08:22.080
是用两个东西组成的

08:22.080 --> 08:23.880
一个是可迭代器

08:23.880 --> 08:24.580
另一个呢

08:24.580 --> 08:25.480
是可迭代协议

08:25.480 --> 08:26.780
这是两个东西

08:26.780 --> 08:28.180
那么要理解这两个东西呢

08:28.180 --> 08:30.580
你首先得理解一个概念

08:30.580 --> 08:32.080
什么叫做迭代

08:32.980 --> 08:33.680
迭代

08:34.380 --> 08:35.480
迭代的概念呢

08:35.480 --> 08:38.680
其实它很类似于便利

08:38.680 --> 08:40.180
很类似于便利

08:43.240 --> 08:44.340
什么叫便利

08:44.340 --> 08:46.840
原来说什么叫便利

08:46.940 --> 08:50.240
便利呢就是有多个

08:51.040 --> 08:54.240
有多个数据组成的集合

08:54.240 --> 08:54.940
这个集合呢

08:54.940 --> 08:56.040
可能是set

08:56.040 --> 08:57.340
可能是map

08:57.340 --> 08:58.640
可能是一个数组

08:59.640 --> 09:00.040
总之呢

09:00.040 --> 09:01.240
是有很多数据组成了

09:01.240 --> 09:02.540
一个这么一个集合

09:02.540 --> 09:03.740
这么一个数据结构

09:03.740 --> 09:05.340
组成了集合数据结构

09:06.540 --> 09:07.540
它可能是个数组

09:07.540 --> 09:10.140
可能是一个map

09:10.140 --> 09:11.440
或者是set

09:11.440 --> 09:13.340
或者是suit array

09:13.340 --> 09:14.040
就这些东西

09:14.040 --> 09:15.540
它是一种数据结构

09:15.540 --> 09:16.240
那么

09:16.240 --> 09:17.840
有多个数据组成这个数据结构

09:17.840 --> 09:22.640
那么需要从该结构中

09:22.640 --> 09:28.240
一次取出数据进行某种分析

09:30.440 --> 09:32.640
进行某种处理

09:32.640 --> 09:34.340
比方说我们要从数组里边

09:34.340 --> 09:35.640
把一个一个数据拿出来

09:35.640 --> 09:36.440
然后输出

09:36.440 --> 09:36.840
对不对

09:36.840 --> 09:37.940
这就是一个便利

09:37.940 --> 09:40.040
把一个集合中的所谓东西

09:40.040 --> 09:41.840
一个一个挨着挨着拿出来

09:41.840 --> 09:42.740
进行处理

09:42.740 --> 09:43.340
这个处理呢

09:43.340 --> 09:44.140
可能是输出

09:44.140 --> 09:46.140
可能是进行一些运算

09:46.140 --> 09:47.340
那么这就叫做便利

09:47.340 --> 09:49.540
比方说我们平时以前写

09:49.540 --> 09:50.340
复讯环

09:50.340 --> 09:50.640
对吧

09:50.640 --> 09:51.640
就是一个便利

09:51.640 --> 09:52.240
就是个便利

09:53.940 --> 09:55.840
那么这里就是

09:55.840 --> 09:57.040
这是关于便利

09:57.040 --> 09:57.840
关于便利

09:57.840 --> 10:00.040
那么什么叫迭代呢

10:00.040 --> 10:01.440
迭代就是指的是

10:03.040 --> 10:05.740
按照某种逻辑

10:05.740 --> 10:08.040
按照某种逻辑

10:08.040 --> 10:13.040
一次取出下一个数据进行处理

10:14.540 --> 10:16.040
其实非常非常类似

10:16.140 --> 10:17.940
比方说我们数组里边

10:17.940 --> 10:20.140
从数组里边一次取出某一个数据

10:20.140 --> 10:22.740
每一个每一项的数据来进行处理

10:22.740 --> 10:23.140
对吧

10:23.140 --> 10:24.540
这可以叫做便利

10:24.540 --> 10:25.740
也可以叫做迭代

10:25.740 --> 10:28.540
那么迭代和便利有什么样的区别呢

10:28.540 --> 10:30.540
它的主要区别在于

10:30.540 --> 10:31.440
迭代呢

10:31.440 --> 10:34.440
它不要求理由这么一种集合

10:34.440 --> 10:36.740
它并没有说我必须要用一种集合

10:36.740 --> 10:37.540
比方说数组

10:37.540 --> 10:38.240
必须要一个数组

10:38.240 --> 10:39.540
或者是map

10:39.540 --> 10:41.940
set或者是等

10:41.940 --> 10:44.740
或者是等其他类数组

10:44.740 --> 10:45.040
对吧

10:45.040 --> 10:48.640
还比方说一些动物的集合之类的东西

10:48.640 --> 10:51.040
它不要求理由这么一种数据结构

10:51.040 --> 10:54.340
你只要能够每一次得到下一个数据就行了

10:54.340 --> 10:56.240
只要能够每一次得到下一个数据

10:56.240 --> 10:58.240
那么这就叫做迭代

10:58.240 --> 11:00.040
就这么一点细微的区别

11:00.040 --> 11:01.540
一会我们写单码的时候

11:01.540 --> 11:02.940
大家就会看到

11:02.940 --> 11:04.240
能够看到这样的一个

11:04.240 --> 11:06.040
很显著的一个区别了

11:06.040 --> 11:06.940
这要迭代

11:06.940 --> 11:08.440
当然每一个数

11:08.440 --> 11:09.540
我们可以这样说

11:09.540 --> 11:11.940
所有的数组或者是内数组

11:11.940 --> 11:14.140
他们都是可以迭代的

11:14.240 --> 11:16.440
他们都是可以迭代的

11:16.440 --> 11:18.040
因为他们都可以一个个数据拿出来

11:18.040 --> 11:19.040
对不对

11:19.040 --> 11:20.240
可以进行课讯完了

11:20.240 --> 11:21.240
都可以进行迭代

11:21.240 --> 11:23.940
但是迭代它不一定能进行便利

11:23.940 --> 11:25.040
它不一定能进行便利

11:25.040 --> 11:27.040
说起来好像有点糟

11:27.040 --> 11:28.240
我们一会写单码的时候

11:28.240 --> 11:30.140
大家就会非常清楚了

11:30.140 --> 11:31.040
所以说他们这两个

11:31.040 --> 11:33.140
平时我们如果不留意的话

11:33.140 --> 11:34.340
说这两个东西

11:34.340 --> 11:36.240
实际上我们感觉感知上的

11:36.240 --> 11:37.440
好像是没有什么区别

11:37.440 --> 11:38.340
但是实际上

11:38.340 --> 11:39.840
它是有那么一点点区别的

11:39.840 --> 11:42.040
只是我们平时不是很care而已

11:42.040 --> 11:43.440
这是关于迭代的概念

11:43.440 --> 11:45.140
它也是一个个数据拿出来

11:45.140 --> 11:47.140
但是只是说

11:47.140 --> 11:49.740
我们每一次拿下一个数据

11:49.740 --> 11:51.740
它没有要求我必须要一个数组

11:51.740 --> 11:54.340
必须要一个集合这么一个数据结构

11:54.340 --> 11:56.340
是这么个意思

11:56.340 --> 11:57.740
好 这是关于迭代

11:57.740 --> 11:59.540
那么现在我们来说迭代器

11:59.540 --> 12:01.340
什么叫迭代器

12:01.340 --> 12:02.740
如果说你对迭代这一块

12:02.740 --> 12:03.740
还有点模糊

12:03.740 --> 12:04.240
没关系

12:04.240 --> 12:05.540
我们一会讲耐马的时候

12:05.540 --> 12:07.540
就会非常清楚了

12:07.540 --> 12:09.940
那么什么叫迭代器呢

12:09.940 --> 12:12.340
实际上在加瓦语言

12:12.340 --> 12:14.840
一些传统的后端语言里边

12:14.840 --> 12:17.240
迭代这个概念以及迭代器

12:17.240 --> 12:19.240
早就有了

12:19.240 --> 12:22.240
好多时候是三个世纪就有了

12:22.240 --> 12:24.840
但是介石它签的帐比较多

12:24.840 --> 12:26.640
其实你们之前也知道

12:26.640 --> 12:29.440
刘亮奇大战关于介石的一些

12:29.440 --> 12:32.440
不堪回首的往事

12:32.440 --> 12:34.240
导致了介石这个语言

12:34.240 --> 12:36.440
一直被称之为玩具语言

12:36.440 --> 12:39.240
就是不像是一个正规军力学介石

12:39.240 --> 12:41.040
都不好意思出来大招呼

12:41.040 --> 12:43.940
因为介石里边确实缺少了很多传统语言

12:43.940 --> 12:45.640
应该有的东西

12:45.640 --> 12:47.640
直到介石2015

12:47.640 --> 12:49.340
也就是介石6出来过后了

12:49.340 --> 12:52.240
很多东西才开始补这个签的帐

12:52.240 --> 12:54.640
才开始补以前的缺失的东西

12:54.640 --> 12:55.840
那么在介石6里边

12:55.840 --> 12:58.440
它才2015年过了这么多年的

12:58.440 --> 13:00.540
它才把那个迭代器给加上

13:00.540 --> 13:02.240
所以迭代器并不是算

13:02.240 --> 13:03.940
在我们计算机语言里边

13:03.940 --> 13:05.640
并不算是一个新的东西

13:05.640 --> 13:09.040
只是对介石这个语言本身的

13:09.040 --> 13:10.740
它算是一个比较新的东西

13:10.740 --> 13:12.440
其他语言里面早就有了

13:12.440 --> 13:14.140
这个迭代器是什么东西呢

13:14.140 --> 13:15.340
这个迭代器呢

13:15.340 --> 13:17.640
不同的语言有不同的规范

13:17.640 --> 13:20.140
它的主要作用都是为了进行迭代的

13:20.140 --> 13:21.640
主要作用是为了进行迭代的

13:21.640 --> 13:23.640
那么如果你对介石的概念不知很清楚

13:23.640 --> 13:25.840
我们一会儿写大码的时候就明白了

13:25.840 --> 13:27.140
在介石语言里面

13:27.140 --> 13:29.740
它对迭代器有一个规定

13:29.740 --> 13:32.240
介石语言规定

13:32.240 --> 13:33.740
什么是迭代器呢

13:33.740 --> 13:37.940
如果一个对象具有

13:37.940 --> 13:41.640
具有next方法

13:41.640 --> 13:48.440
并且next方法满足一定的约束

13:48.440 --> 13:53.940
则该对象是一个迭代器

13:53.940 --> 13:55.140
这个对象就是一个迭代器

13:55.140 --> 13:56.340
就这么简单

13:56.340 --> 13:58.240
也就是说我们只要写一个对象

13:58.240 --> 14:01.240
我们比方我们在这里新建个文件

14:01.240 --> 14:07.950
新建个文件讲到了关于迭代器

14:07.950 --> 14:10.250
迭代器里面我们新建一个文件

14:10.250 --> 14:14.250
比方说我们这里写上这么一个就是

14:14.250 --> 14:21.620
Test1

14:21.620 --> 14:23.720
比方说我们这里有一个介石对象

14:23.720 --> 14:25.620
介石Object

14:25.620 --> 14:26.920
那么这个对象里面

14:26.920 --> 14:29.620
如果提供了一个next方法

14:29.620 --> 14:34.120
它是一个方法

14:34.120 --> 14:36.220
它提供了这么一个next方法

14:36.220 --> 14:39.520
那么如果说这个方法满足一定的约束

14:39.520 --> 14:41.520
以后我们来说满足什么约束

14:41.520 --> 14:42.820
那么这个对象就是迭代器

14:42.920 --> 14:45.120
这个对象就是迭代器

14:45.120 --> 14:51.220
那么这个对象介石Object是一个迭代器

14:51.220 --> 14:54.120
那么迭代器我们通常不是用这个名字

14:54.120 --> 14:57.720
通常我们用atorator

14:57.720 --> 14:59.020
我读对没有

14:59.020 --> 15:02.120
不要到时候又读什么atorator

15:02.120 --> 15:04.820
应该是读atorator

15:04.820 --> 15:06.220
看一下

15:06.220 --> 15:08.120
怎么读的

15:08.120 --> 15:10.620
atorator

15:10.620 --> 15:12.020
atorator

15:12.820 --> 15:13.520
好那行吗

15:13.520 --> 15:14.520
atorator

15:14.520 --> 15:16.920
那么这个东西我们通常把用这个单词

15:16.920 --> 15:19.020
来表示一个迭代器

15:19.020 --> 15:20.820
来表示一个迭代器

15:20.820 --> 15:23.320
记住有什么东西就行了

15:23.320 --> 15:24.920
那么这里

15:24.920 --> 15:26.820
那么这就是个迭代器

15:26.820 --> 15:28.820
atorator

15:28.820 --> 15:29.920
再说一次

15:29.920 --> 15:30.820
只要一个对象

15:30.820 --> 15:32.120
它有一个next方法

15:32.120 --> 15:34.020
这个方法满足一定的约束

15:34.020 --> 15:36.320
那么这个它就是一个迭代器

15:36.320 --> 15:37.620
那么现在我们就来研究

15:37.620 --> 15:39.820
这个方法要满足什么样的约束

15:39.820 --> 15:40.920
就是你不能随便写

15:40.920 --> 15:42.620
像这个方法它就不满足约束

15:42.620 --> 15:42.920
对吧

15:42.920 --> 15:44.020
就不满足约束

15:44.020 --> 15:45.720
它必须要满足一个约束

15:45.720 --> 15:47.520
什么样的约束呢

15:47.520 --> 15:49.920
下面我们来写一下

15:49.920 --> 15:54.720
next方法的约束

15:54.720 --> 15:58.720
该方法必须返回

15:58.720 --> 16:00.320
返回一个对象

16:00.320 --> 16:01.020
有这个方法

16:01.020 --> 16:02.720
它也得返回一个对象

16:02.720 --> 16:03.420
这个方法

16:03.420 --> 16:04.720
它在返回一个对象

16:04.720 --> 16:06.020
这个对象里边

16:06.020 --> 16:09.220
它具有两个属性

16:09.220 --> 16:13.420
该对象至少具有两个属性

16:13.420 --> 16:14.820
其他的属性它不管了

16:14.820 --> 16:16.820
它只会用到这两个属性

16:16.820 --> 16:17.620
哪两个属性呢

16:17.620 --> 16:20.720
第一个叫做value

16:20.720 --> 16:23.920
第二个叫做档

16:23.920 --> 16:24.620
我们一个个说

16:24.620 --> 16:27.020
也就是说它要返回一个对象

16:27.020 --> 16:30.620
这个对象里面有一个属性叫做value

16:30.620 --> 16:31.520
啥啥啥

16:31.520 --> 16:33.020
然后一个档

16:33.020 --> 16:34.220
啥啥啥

16:34.220 --> 16:34.720
对吧

16:34.720 --> 16:36.120
你看这种结构

16:36.120 --> 16:37.620
只要形成了这种结构

16:37.620 --> 16:39.520
那么这个玩意就是一个跌弹器

16:39.520 --> 16:40.920
它里面提供了一个函数

16:40.920 --> 16:41.920
那个是一调用它

16:41.920 --> 16:43.120
它就会返回一个对象

16:43.120 --> 16:45.120
对象里边有两个属性

16:45.120 --> 16:48.320
value和档就这么简单

16:48.320 --> 16:49.620
那么这个value档

16:49.620 --> 16:50.920
它又是什么意思呢

16:50.920 --> 16:52.220
它也有规定

16:52.220 --> 17:01.620
这个value表示下一个数据的值

17:01.620 --> 17:12.320
档表示是否还有是否已经跌弹完成

17:12.320 --> 17:14.320
是否已经跌弹完成

17:14.320 --> 17:15.320
这啥意思呢

17:15.320 --> 17:17.520
这个档我们至少可以知道

17:17.520 --> 17:19.620
它表示是否怎么样怎么样怎么样

17:19.620 --> 17:20.120
对吧

17:20.120 --> 17:23.220
那么这个档我们可以认为是一个

17:23.220 --> 17:24.120
是一个啥呢

17:24.120 --> 17:26.920
是一个布尔类型

17:26.920 --> 17:29.120
那么玩意表示一个数据的值

17:29.120 --> 17:31.020
这个数据可以是任意数据

17:31.120 --> 17:32.920
那么这个value可以是任意类型

17:32.920 --> 17:34.120
就是什么类型都可以

17:34.120 --> 17:35.520
什么类型都可以

17:35.520 --> 17:38.120
规定就写完了

17:38.120 --> 17:39.720
这就是一个跌弹器

17:39.720 --> 17:42.520
整个如果说你有个对象

17:42.520 --> 17:43.420
它有个那个方法

17:43.420 --> 17:44.520
这个方法返回一个对象

17:44.520 --> 17:46.120
这个对象里边有value和档

17:46.120 --> 17:49.520
档必于是一个true或者是force

17:49.520 --> 17:51.320
表示是否完成

17:51.320 --> 17:52.920
是否跌弹完成

17:52.920 --> 17:54.420
那么这就是一个跌弹器

17:54.420 --> 17:56.720
atorator就是个跌弹器

17:56.720 --> 18:00.320
那么这里我们来简单的写一下

18:00.820 --> 18:02.120
简单的写一下

18:02.120 --> 18:03.620
比方说吧

18:03.620 --> 18:05.120
咱们那个市场里面

18:05.120 --> 18:07.220
我们就写出这么一个东西

18:07.220 --> 18:08.220
我们写这么一个东西

18:08.220 --> 18:09.220
写这么一个代码

18:09.220 --> 18:11.120
这个那个市场方法里边

18:11.120 --> 18:13.520
咱们写上

18:13.520 --> 18:14.920
我们比方说跌弹三次

18:14.920 --> 18:15.720
什么叫跌弹三次

18:15.720 --> 18:16.820
就是有三个数据

18:16.820 --> 18:18.220
我们可以把取出来

18:18.220 --> 18:19.320
跌弹三次

18:19.320 --> 18:21.720
那么我们这里写上一个

18:22.920 --> 18:23.420
变量

18:24.920 --> 18:27.220
变量投档等于3

18:27.220 --> 18:30.220
表示可跌弹三次

18:30.520 --> 18:32.120
可跌弹三次

18:32.120 --> 18:33.420
那么有一个i

18:33.420 --> 18:34.020
表示

18:35.920 --> 18:40.520
当前的跌弹次数

18:40.520 --> 18:42.320
当前的跌弹次数

18:42.320 --> 18:44.020
那么这样子我们value里面

18:44.020 --> 18:44.920
返回什么呢

18:44.920 --> 18:46.120
返回的就是

18:46.120 --> 18:48.120
我们这里写上一个ob界

18:48.120 --> 18:49.020
ob界

18:49.020 --> 18:50.120
ob界表示什么意思呢

18:50.120 --> 18:53.620
表示当前这一次

18:53.620 --> 18:57.120
跌弹到的数据

18:57.120 --> 18:58.120
跌弹到的数据

18:58.120 --> 18:59.520
咱们ob界里面

18:59.620 --> 19:00.620
value为什么呢

19:00.620 --> 19:03.420
value比方说我们就用i

19:03.420 --> 19:05.020
比方说当然可以用任何东西

19:05.020 --> 19:06.220
可以用任何东西

19:06.220 --> 19:07.820
这个value可以是任何数据

19:07.820 --> 19:09.220
我们比方说就写个i

19:09.220 --> 19:10.420
就写个i

19:10.420 --> 19:12.720
那么这个当表示什么意思呢

19:12.720 --> 19:14.820
表示的是是否迭代完成

19:14.820 --> 19:15.820
那么一看一下

19:15.820 --> 19:18.020
一共可以迭代三次

19:18.020 --> 19:18.920
那么什么

19:18.920 --> 19:20.920
i表示当前迭代的次数

19:20.920 --> 19:23.020
当前迭代的次数

19:23.020 --> 19:24.220
那么当前我们比方说

19:24.220 --> 19:25.920
从一开始

19:25.920 --> 19:28.020
那么这个当什么时候迭代完成的

19:28.020 --> 19:29.920
是不是打语的三次就迭代完成了

19:29.920 --> 19:31.520
所以说我们这里可以用i大语

19:31.520 --> 19:32.520
是不是大语三

19:32.520 --> 19:33.920
如果说你i大语的三

19:33.920 --> 19:35.820
表示我已经迭代完成了

19:35.820 --> 19:36.620
那么否则的话

19:36.620 --> 19:37.920
我就没有迭代完成

19:37.920 --> 19:40.220
就这么个意思

19:40.220 --> 19:41.220
那么这里

19:41.220 --> 19:42.120
每次迭代完成过后

19:42.120 --> 19:42.620
i加加

19:42.620 --> 19:44.420
最后我们把ob界返回

19:44.420 --> 19:46.820
总之你只要最后给它返回了一个对象

19:46.820 --> 19:48.120
它里面有i6值

19:48.120 --> 19:49.720
有当这个两个数据

19:49.720 --> 19:50.120
OK

19:50.120 --> 19:52.420
那么我们就表示

19:52.420 --> 19:54.820
整个这个atrater是一个迭代器

19:56.020 --> 19:56.120
好

19:56.120 --> 19:56.620
那么这样子

19:56.620 --> 19:58.120
我们写完了之后

19:58.120 --> 19:59.920
我们可以得到一个什么样的结果

19:59.920 --> 20:00.520
那关键是

20:00.520 --> 20:00.720
好

20:00.720 --> 20:01.720
咱们运行出来看一下

20:03.720 --> 20:04.620
我们在控制台里边

20:07.720 --> 20:08.320
控制台里边

20:08.320 --> 20:09.520
我们不是一个atrater吗

20:09.520 --> 20:10.520
对不对

20:10.520 --> 20:11.520
atrater

20:11.520 --> 20:12.420
我们这里可以是不是

20:12.420 --> 20:13.220
它里面一个方法

20:13.220 --> 20:14.020
Nex

20:14.020 --> 20:14.720
每一次调的方法

20:14.720 --> 20:15.920
是不是可以得到一个对象

20:15.920 --> 20:16.220
对吧

20:16.220 --> 20:17.420
是可以得到一个对象吗

20:17.420 --> 20:18.320
对不对

20:18.320 --> 20:19.620
那么这里呢

20:19.620 --> 20:20.120
一回车

20:20.120 --> 20:22.420
你看第一次得到的是什么

20:22.420 --> 20:23.020
调Nex

20:23.020 --> 20:24.220
是不是得到一个对象

20:24.220 --> 20:25.120
i等1

20:25.120 --> 20:26.120
对不对

20:26.120 --> 20:27.220
是不是完成迭代了

20:27.220 --> 20:29.020
还没有还没有完成

20:29.020 --> 20:29.320
对吧

20:29.320 --> 20:31.220
我们可以通过这个对象知道

20:31.220 --> 20:32.520
哎后边还有东西

20:32.520 --> 20:32.820
对不对

20:32.820 --> 20:33.920
后边还有东西

20:33.920 --> 20:34.320
但是呢

20:34.320 --> 20:36.320
我不知道后边东西是啥

20:36.320 --> 20:36.620
但是呢

20:36.620 --> 20:38.420
我知道后边一定还有东西

20:38.420 --> 20:38.820
对吧

20:38.820 --> 20:40.320
一定还有东西

20:40.320 --> 20:40.520
好

20:40.520 --> 20:41.820
那么这里

20:41.820 --> 20:42.220
这里呢

20:42.220 --> 20:43.520
我们就得到第一个结果

20:43.520 --> 20:43.920
对吧

20:43.920 --> 20:45.420
拿到了第一个数据

20:45.420 --> 20:46.920
我们说之前说什么叫迭代

20:46.920 --> 20:47.720
是不是一个数据

20:47.720 --> 20:48.520
一个数据拿出来

20:48.520 --> 20:50.020
也是这个意思啊

20:50.020 --> 20:51.420
一次拿出一些数据

20:51.420 --> 20:52.020
那么这里呢

20:52.020 --> 20:53.520
我们拿出了第一个数据

20:53.520 --> 20:54.320
当这个属性呢

20:54.320 --> 20:56.120
表示后边还有数据

20:56.120 --> 20:57.320
还有数据

20:57.320 --> 20:57.720
然后呢

20:57.720 --> 20:58.820
我们这里呢

20:58.820 --> 21:00.320
再调到那个是

21:00.320 --> 21:00.620
哦

21:00.620 --> 21:01.920
这里写的问题啊

21:01.920 --> 21:02.920
Mate Space叫那个是

21:02.920 --> 21:03.720
它偷偷没变

21:03.720 --> 21:04.120
对不对

21:04.120 --> 21:04.920
偷偷没变

21:04.920 --> 21:05.120
好

21:05.120 --> 21:05.720
那么这里呢

21:05.720 --> 21:07.920
我们可以在Ateryter里面

21:07.920 --> 21:09.120
我们写上一个偷偷

21:09.120 --> 21:10.520
在这里写上偷偷

21:10.520 --> 21:11.420
3

21:11.420 --> 21:14.420
i表示当前迭代的次数1

21:14.420 --> 21:15.720
这个是可迭代次数

21:15.720 --> 21:17.020
可迭代三次

21:17.020 --> 21:18.820
这是当前迭代的次数

21:18.820 --> 21:19.720
啊

21:19.720 --> 21:21.120
当前迭代的次数

21:21.120 --> 21:21.320
好

21:21.320 --> 21:21.920
那么这边呢

21:21.920 --> 21:23.920
我们就用那个Zestir

21:23.920 --> 21:24.520
i

21:24.520 --> 21:25.320
Zestir

21:26.320 --> 21:26.820
这里呢

21:26.820 --> 21:27.520
用Zestir

21:27.520 --> 21:28.520
i

21:28.520 --> 21:28.920
Zestir

21:28.920 --> 21:30.020
i加加

21:30.020 --> 21:30.120
好

21:30.120 --> 21:30.920
这样子来写

21:30.920 --> 21:31.920
这样子来写

21:31.920 --> 21:32.320
除了的话

21:32.320 --> 21:33.020
每次调用还说

21:33.020 --> 21:34.220
它都重新开始了

21:34.220 --> 21:34.620
好

21:34.620 --> 21:36.520
咱们来看一下啊

21:36.520 --> 21:37.220
第一次调用

21:37.220 --> 21:39.120
你看我们得到了数据是1

21:39.120 --> 21:39.420
对吧

21:39.420 --> 21:41.020
得到数据是1

21:41.020 --> 21:41.820
当这个属性呢

21:41.820 --> 21:43.520
表示后边还有没有数据呢

21:43.520 --> 21:45.120
后边已经没有数据了

21:45.120 --> 21:46.220
还有数据啊

21:46.220 --> 21:47.020
还有数据

21:47.020 --> 21:48.220
于是我们又调用那个是

21:48.220 --> 21:48.720
你看

21:48.720 --> 21:50.220
下一个数据是否得到2

21:50.220 --> 21:50.720
对不对

21:50.720 --> 21:51.220
下一次

21:51.220 --> 21:52.520
下一次i得明二了吗

21:52.520 --> 21:52.920
对不对

21:52.920 --> 21:53.820
i得明二了

21:53.820 --> 21:54.620
有没有完成呢

21:54.620 --> 21:55.920
还没有完成啊

21:55.920 --> 21:57.620
说明后边是不是还有数据

21:57.620 --> 21:58.020
对吧

21:58.020 --> 21:59.620
我们再调用一次啊

21:59.620 --> 22:00.920
得到了结果是3

22:00.920 --> 22:02.220
后边还有没有数据呢

22:02.220 --> 22:02.520
啊

22:02.520 --> 22:04.020
他表示后边还有数据啊

22:04.020 --> 22:05.620
还有数据再调用一次

22:06.320 --> 22:07.420
当结束了啊

22:07.420 --> 22:08.120
结束了

22:08.120 --> 22:09.020
表示呢

22:09.020 --> 22:11.320
这个已经已经不是一个正常的数据了啊

22:11.320 --> 22:12.720
表示已经完成了啊

22:12.720 --> 22:13.820
已经完成了

22:13.820 --> 22:15.320
我们通常情况下呢

22:15.320 --> 22:16.520
在完成之后呢

22:16.520 --> 22:17.020
这个数据呢

22:17.020 --> 22:19.220
我们会把它设置为undefend啊

22:19.220 --> 22:20.620
会把它设置为undefend

22:20.720 --> 22:22.420
也就是我们这里可以判断一下啊

22:22.420 --> 22:23.720
是否完成啊

22:23.720 --> 22:24.320
是否完成

22:24.320 --> 22:25.720
如果说已经完成了

22:25.720 --> 22:26.420
那么这个纸呢

22:26.420 --> 22:28.620
我们通常会把它设置为undefend啊

22:29.320 --> 22:29.820
嗯

22:29.820 --> 22:30.620
这样子说吧

22:30.620 --> 22:31.620
这个y6纸啊

22:31.620 --> 22:32.220
y6纸

22:34.220 --> 22:35.020
嗯

22:35.020 --> 22:36.020
就是如果

22:36.020 --> 22:37.720
如果当属性

22:38.820 --> 22:39.620
维促

22:41.020 --> 22:41.320
啊

22:42.320 --> 22:43.120
他没有这样子

22:43.120 --> 22:44.120
没有强行规定啊

22:44.120 --> 22:45.520
虽然说没有强行规定

22:45.520 --> 22:45.920
但是呢

22:45.920 --> 22:47.320
我们通常会这样做

22:47.320 --> 22:49.420
如果说当属性为促的话啊

22:49.420 --> 22:50.020
通常

22:50.620 --> 22:55.420
会将Value设置为undefend啊

22:56.020 --> 22:57.620
会把Value设置为undefend

22:57.620 --> 22:57.820
好

22:57.820 --> 22:58.220
那么这里呢

22:58.220 --> 22:59.220
我们稍微判断一下

22:59.220 --> 22:59.620
有完事了

22:59.620 --> 23:00.020
对吧

23:00.020 --> 23:01.920
如果说i等于i大于3

23:01.920 --> 23:04.120
是不是说明已经完成了

23:04.120 --> 23:04.620
已经完成了

23:04.620 --> 23:05.620
我们把设为undefend

23:05.620 --> 23:06.520
否则的话设为

23:06.520 --> 23:07.020
哎

23:07.020 --> 23:07.820
对不对

23:07.820 --> 23:09.020
我们做个三分一上

23:09.020 --> 23:09.920
判断就完事了

23:11.020 --> 23:11.320
啊

23:11.320 --> 23:12.220
你看第一个

23:12.220 --> 23:13.620
第二个三个对吧

23:13.620 --> 23:15.020
这三个数据都是正常的数据

23:15.020 --> 23:15.320
对不对

23:15.320 --> 23:17.020
都是我们迭代出来的数据

23:17.020 --> 23:18.020
然后再下一次呢

23:18.020 --> 23:19.120
是不是没有数据了

23:19.120 --> 23:19.620
对吧

23:19.620 --> 23:20.520
表示已经完成了

23:21.020 --> 23:21.320
哎

23:21.320 --> 23:22.520
这就是一个迭代器

23:22.520 --> 23:23.520
那你看一下整个过程

23:23.520 --> 23:25.120
有没有用到什么数据啊

23:25.120 --> 23:26.020
map啊

23:26.020 --> 23:26.620
set啊

23:26.620 --> 23:29.220
t这种这种集合这种结构

23:29.220 --> 23:30.120
有没有用到

23:30.120 --> 23:31.320
是完全没用到

23:31.320 --> 23:31.820
对不对

23:31.820 --> 23:32.220
那么

23:33.020 --> 23:33.820
这个过程呢

23:33.820 --> 23:35.320
其实也叫做迭代

23:35.320 --> 23:36.720
不断的调用max过程

23:36.720 --> 23:38.720
它其实也叫做迭代啊

23:38.720 --> 23:39.920
但是你看

23:39.920 --> 23:41.220
虽然说我们没有用到数据

23:41.220 --> 23:42.320
没有用到集合

23:42.320 --> 23:42.620
但是呢

23:42.620 --> 23:44.720
我们是不是一个一个数据的拿出来

23:44.720 --> 23:45.320
对不对

23:45.320 --> 23:45.720
并且呢

23:45.720 --> 23:48.320
通过一个当属性来指示啊

23:48.320 --> 23:49.420
有没有数据

23:49.420 --> 23:50.520
还有没有数据

23:50.520 --> 23:50.820
对不对

23:50.820 --> 23:52.820
通过这个属性来指示啊

23:52.820 --> 23:54.420
这就是一个迭代器

23:54.420 --> 23:56.120
它的这么一个特征啊

23:56.120 --> 23:56.920
这是个迭代器

23:56.920 --> 23:58.020
好好理一下啊

23:58.020 --> 23:58.720
我建议呢

23:58.720 --> 23:59.920
你现在可以暂停视频

23:59.920 --> 24:01.520
如果你觉得模糊的话

24:01.520 --> 24:02.620
你把这个东西再代码

24:02.620 --> 24:04.320
跟着我写一遍啊

24:04.320 --> 24:05.120
写一遍过

24:05.120 --> 24:07.020
好好去体会一下这个代码

24:07.020 --> 24:09.220
它通过一个max的方法啊

24:09.220 --> 24:09.920
就说迭代器呢

24:09.920 --> 24:10.820
它不要求你说

24:10.820 --> 24:11.820
你只有max的方法

24:11.820 --> 24:12.420
你其他可以

24:12.420 --> 24:13.920
其他属性你随便

24:13.920 --> 24:14.320
但是呢

24:14.320 --> 24:16.420
你至少得包含一个max的方法

24:16.420 --> 24:17.420
这个方法关码了

24:17.420 --> 24:18.620
它一定要返回个对象

24:18.620 --> 24:19.820
这个对象里面有两个属性

24:19.820 --> 24:20.220
一个value

24:20.220 --> 24:20.820
一个档

24:20.820 --> 24:22.720
value表示我要迭代的数据

24:22.720 --> 24:23.520
什么要迭代数据

24:23.520 --> 24:24.220
就是一个一个

24:24.220 --> 24:24.820
迭代什么意思

24:24.820 --> 24:26.420
就是一个一个拿出来啊

24:26.420 --> 24:27.220
可迭代三次

24:27.220 --> 24:29.120
就是可以拿出来三次啊

24:29.120 --> 24:30.020
当前迭代的数据

24:30.020 --> 24:32.420
就是当前拿到第几次啊

24:32.420 --> 24:34.620
那么这个value只能可以是任何数据啊

24:34.620 --> 24:36.120
可以是任何数据

24:36.120 --> 24:36.520
不要这意思吧

24:36.520 --> 24:37.120
比方说这里呢

24:37.120 --> 24:39.420
我们也完全可以不用这个zsi

24:39.420 --> 24:40.520
可以用个max write

24:40.520 --> 24:40.920
可不可以

24:40.920 --> 24:42.520
任何数据都可以啊

24:42.520 --> 24:44.620
任何数据都可以

24:44.620 --> 24:45.220
那么比方说

24:45.220 --> 24:46.120
那么这样子的话

24:46.220 --> 24:47.920
我们是不是可以拿到第一个数据

24:47.920 --> 24:48.420
对吧

24:48.420 --> 24:49.520
第二个数据

24:49.520 --> 24:50.720
第三个数据都可以拿到

24:50.720 --> 24:51.820
然后再拿是不是没了

24:51.820 --> 24:52.820
拿不到了

24:52.820 --> 24:53.120
对不对

24:53.120 --> 24:54.020
是不是拿不到数据了

24:55.020 --> 24:56.220
没问题吧

24:56.220 --> 24:57.320
那么整个呢

24:57.320 --> 24:58.420
这个ator

24:58.420 --> 24:59.720
就是一个迭代器

24:59.720 --> 25:00.420
它可以通过

25:00.420 --> 25:01.120
我们也就是说

25:01.120 --> 25:02.420
我们可以通过迭代器

25:04.120 --> 25:05.220
通过迭代器

25:06.120 --> 25:07.520
通过迭代器

25:10.320 --> 25:12.420
的max的方法

25:12.420 --> 25:15.320
可以一次取出数据

25:16.220 --> 25:18.220
并可以根据

25:18.220 --> 25:21.320
返回的当属性

25:21.320 --> 25:22.720
返回的当属性

25:22.720 --> 25:24.620
判定是否

25:24.620 --> 25:26.320
迭代结束

25:26.320 --> 25:27.820
是否迭代结束

25:27.820 --> 25:29.120
这就是一个迭代器的

25:29.120 --> 25:30.420
它的作用

25:30.420 --> 25:30.920
作用是什么

25:30.920 --> 25:32.320
它就提供一个那个手法

25:32.320 --> 25:32.920
那个手法

25:32.920 --> 25:34.220
我们可以一次拿出来数据

25:34.220 --> 25:34.720
第一个数据

25:34.720 --> 25:35.120
第二个数据

25:35.120 --> 25:36.120
第三个数据

25:36.120 --> 25:36.520
然后呢

25:36.520 --> 25:37.520
我们怎么知道拿完了

25:37.520 --> 25:38.320
没有数据了呢

25:38.320 --> 25:39.220
我们通过一个当的

25:39.220 --> 25:40.320
这个属性来判断

25:40.320 --> 25:40.920
对吧

25:40.920 --> 25:42.520
有还又没有数据

25:42.520 --> 25:43.920
没问题吧

25:43.920 --> 25:45.520
而真是因为这个有迭代器

25:45.520 --> 25:46.220
这么一个特点

25:46.220 --> 25:47.320
它并不要求你

25:47.320 --> 25:49.420
有什么有什么数组啊

25:49.420 --> 25:51.320
这些集合这种数据结构

25:51.320 --> 25:51.720
因此呢

25:51.720 --> 25:54.220
我们可以迭代一些无线的对列

25:54.220 --> 25:55.220
无线的对列

25:55.220 --> 25:56.820
比方说我们这里不要挨

25:56.820 --> 25:57.920
不要挨

25:57.920 --> 25:58.520
当呢

25:58.520 --> 26:00.220
永远为force

26:00.220 --> 26:01.520
比方说

26:01.520 --> 26:01.920
我们这里

26:01.920 --> 26:08.530
欢迎加一个文件写

26:08.530 --> 26:09.130
那么这里呢

26:09.130 --> 26:10.530
就是一个无线

26:10.530 --> 26:13.030
比方说我们做一个无线的

26:13.030 --> 26:14.830
无线就是可

26:14.830 --> 26:16.130
无线

26:16.130 --> 26:19.030
无线迭代的水积数

26:19.030 --> 26:20.830
可以无线对代的水积数

26:20.830 --> 26:21.830
那么这两个属性不要了

26:21.830 --> 26:23.630
我不限制你的次数

26:23.630 --> 26:25.330
没有说迭代器必须要有这个东西

26:25.330 --> 26:27.530
必须要有可有限的次数

26:27.530 --> 26:28.230
没有

26:28.230 --> 26:29.730
我不限制你的次数

26:29.730 --> 26:30.430
那么

26:30.430 --> 26:31.930
当我永远给你设为force

26:31.930 --> 26:33.430
永远不会结束

26:33.430 --> 26:34.430
永远不会结束

26:34.430 --> 26:35.630
v6只能mess

26:35.630 --> 26:36.630
right

26:36.630 --> 26:38.730
我直接返回

26:38.730 --> 26:42.560
直接返回

26:42.560 --> 26:43.960
那么这样子写出来这么一个

26:43.960 --> 26:44.760
attractor

26:44.760 --> 26:45.860
attractor过后了

26:45.860 --> 26:46.860
怎么来看一下

26:46.860 --> 26:47.660
那么这个迭代器

26:47.760 --> 26:49.260
它就可以无线迭代下去了

26:49.260 --> 26:49.960
你看一下

26:49.960 --> 26:51.660
每一次我调用那个

26:51.660 --> 26:53.560
那个是不是都可以拿到一个水积数

26:53.560 --> 26:53.860
对吧

26:53.860 --> 26:55.660
而且是无穷无尽的

26:55.660 --> 26:56.360
对吧

26:56.360 --> 26:56.960
那你想一下

26:56.960 --> 26:58.960
这个东西是不是比数组更加优秀

26:58.960 --> 27:01.960
如果说让你产生一个无穷的

27:01.960 --> 27:05.260
无穷数据量无穷的数组

27:05.260 --> 27:06.660
那里把计算机内存搞不好

27:06.660 --> 27:08.360
都没办法产生

27:08.360 --> 27:09.060
对不对

27:09.060 --> 27:11.360
因为它的数据量是无线的

27:11.360 --> 27:12.860
但是迭代器可以

27:12.860 --> 27:13.760
迭代器可以

27:13.760 --> 27:15.660
因为我只管我

27:15.660 --> 27:16.860
这一次的数据是啥

27:16.860 --> 27:18.360
上一次跟我没什么关系

27:18.360 --> 27:19.660
下一次跟我没啥关系

27:19.660 --> 27:21.860
我只管我这一次的数据是啥

27:21.860 --> 27:22.960
然后来表示一下

27:22.960 --> 27:23.660
还有没有

27:23.660 --> 27:25.460
就是我这是不是已经结束了

27:25.460 --> 27:26.860
来做一个表示就完事了

27:26.860 --> 27:27.660
那么如果你说

27:27.660 --> 27:30.060
你把所有的把个档次为force

27:30.060 --> 27:31.360
那么它永远就不会结束

27:31.360 --> 27:32.160
对不对

27:32.160 --> 27:34.460
迭代器就会表示这种无线的对立

27:34.460 --> 27:34.960
对吧

27:34.960 --> 27:37.460
就会表示这种无线的对立

27:37.460 --> 27:40.260
这就是个迭代器

27:40.260 --> 27:42.860
比方说我们再来一个例子

27:42.860 --> 27:46.460
一个无线的飞波拉七数据

27:46.560 --> 27:49.960
比方说我们这里写一个

27:49.960 --> 27:53.460
一个无线的飞波拉七数据

27:53.460 --> 27:54.660
什么叫飞波拉七数据呢

27:54.660 --> 27:57.560
就是前两位固定为1

27:57.560 --> 27:58.760
然后呢

27:58.760 --> 28:01.760
后一位是前两位之和

28:01.760 --> 28:04.760
11235813

28:04.760 --> 28:05.960
对不对

28:05.960 --> 28:08.560
1021对不对

28:08.560 --> 28:10.660
这就是飞波拉七数据

28:10.660 --> 28:11.960
前两位固定为1

28:11.960 --> 28:15.260
然后后两位是前两位之和

28:15.360 --> 28:17.260
这就是飞波拉七数据

28:17.260 --> 28:19.860
那么如果说我要用一个数组来做的话

28:19.860 --> 28:21.160
比方说

28:21.160 --> 28:22.760
我们可能有的时候呢

28:22.760 --> 28:24.660
要输出飞波拉七数据的前两位

28:24.660 --> 28:26.160
可能有的时候要输出前三位

28:26.160 --> 28:28.060
有的时候要输出前五位

28:28.060 --> 28:29.160
对不对

28:29.160 --> 28:31.360
那么我也不知道要到底要输出

28:31.360 --> 28:33.660
比方说有这么一个需求

28:33.660 --> 28:34.060
需求

28:36.460 --> 28:43.460
要输出飞波拉七数据的前n位

28:43.560 --> 28:45.560
我也不知道要输出多少位

28:45.560 --> 28:47.760
到时候我想输出多少位就输出多少位

28:47.760 --> 28:48.560
那么这个时候呢

28:48.560 --> 28:50.360
你用数组的话就很麻烦

28:50.360 --> 28:52.160
你说这个数组里边保存几项了

28:52.160 --> 28:53.760
你说你保存一百项吧

28:53.760 --> 28:54.560
你保存一百项

28:54.560 --> 28:56.460
到时候要输出一百零一项了

28:56.460 --> 28:57.460
那怎么办呢

28:57.460 --> 28:59.360
你说你要保存两百项吧

28:59.360 --> 29:00.860
那你到时候要输出二百零一项

29:00.860 --> 29:01.660
又怎么办呢

29:01.660 --> 29:03.560
你又不可能去保存无限项

29:03.560 --> 29:03.960
对吧

29:03.960 --> 29:04.560
有的时候呢

29:04.560 --> 29:06.660
会遇到这种很恶心的这种需求

29:06.660 --> 29:08.060
当然你现在这个场景下面

29:08.060 --> 29:09.060
你说你写个函数

29:09.060 --> 29:09.760
对吧

29:09.760 --> 29:11.860
你给我传一个n的职位也可以搞定

29:11.860 --> 29:12.260
但是呢

29:12.360 --> 29:14.160
有的时候实际上没有那么简单

29:14.160 --> 29:16.560
可能有的时候就会遇到这种类似的问题

29:16.560 --> 29:17.860
就是说我要取这个数据

29:17.860 --> 29:19.260
但是我也不知道

29:19.260 --> 29:21.660
他将来他到底要取多少个

29:21.660 --> 29:23.060
要取前面的多少个

29:23.060 --> 29:25.160
那我也不可能给你准备太多的数据

29:25.160 --> 29:26.460
太多数据浪费内存空间

29:26.460 --> 29:28.660
比方说给你准备了一万个飞布拉奇数列

29:28.660 --> 29:29.660
结果你直去一个

29:29.660 --> 29:31.960
那这样的空间内存空间是不是浪费掉了

29:31.960 --> 29:33.660
地存那么多干嘛了

29:33.660 --> 29:34.160
对不对

29:34.160 --> 29:36.460
那么这个时候迭代器就发挥用出了

29:36.460 --> 29:37.560
你看迭代器怎么用

29:37.560 --> 29:39.660
我压根没有什么数据

29:39.660 --> 29:41.860
当然有数据也可以无所谓

29:41.860 --> 29:42.860
管理有没有数据

29:42.860 --> 29:44.860
反正我就是一个个取

29:44.860 --> 29:46.960
我就这里就写个A

29:46.960 --> 29:52.360
A等于A等于B等于E

29:52.360 --> 29:54.160
就表示目前的前两位

29:54.160 --> 29:55.460
目前的前两位

29:55.460 --> 29:57.060
A和B表示目前的前两位

29:57.060 --> 29:58.460
目前的前两位就是A

29:58.460 --> 29:59.360
就是1和1

29:59.360 --> 29:59.960
对不对

29:59.960 --> 30:01.060
就是1和1

30:01.060 --> 30:02.660
就这么个意思

30:02.660 --> 30:04.260
然后我们再来一个电量

30:04.260 --> 30:07.660
表示当前的是第几位

30:07.660 --> 30:09.060
你目前取到第几位了

30:12.860 --> 30:14.860
比方说我们从一开始

30:14.860 --> 30:17.860
从一开始符合现实逻辑一点

30:17.860 --> 30:26.360
表示当前取到飞布拉奇的第几位了

30:26.360 --> 30:28.660
取到第几位了

30:28.660 --> 30:30.260
那么这个我们从一开始

30:30.260 --> 30:31.960
从一开始比较符合现实逻辑

30:31.960 --> 30:33.660
但是从零开始也行

30:33.660 --> 30:35.060
然后那个时候里边怎么做呢

30:35.060 --> 30:36.260
我们就这样来操作

30:36.260 --> 30:37.160
判断一下

30:37.160 --> 30:40.260
如果说你现在取到的是第一位

30:40.260 --> 30:42.360
或者是你的飞布拉奇苏联

30:42.360 --> 30:43.860
现在取到了第二位

30:43.860 --> 30:44.460
我干嘛呢

30:44.460 --> 30:45.660
我是返回1

30:45.660 --> 30:46.460
对不对

30:46.460 --> 30:48.260
前两位固定为1吗

30:48.260 --> 30:49.260
没什么好说的

30:49.260 --> 30:50.960
前两位固定为1

30:50.960 --> 30:52.860
我们返回1就完事了

30:52.860 --> 30:53.260
对吧

30:53.260 --> 30:54.460
没问题吧

30:54.460 --> 30:54.760
好

30:54.760 --> 30:56.060
然后别忘了

30:56.060 --> 30:57.760
柯茵这个社家

30:57.760 --> 30:59.860
表示你目前取到了第一位

30:59.860 --> 31:00.760
我先给你加1

31:00.760 --> 31:02.060
下一次就不是第一位了

31:02.060 --> 31:02.260
对吧

31:02.260 --> 31:03.960
下一次就第二位了

31:03.960 --> 31:05.960
那么最终返回1

31:05.960 --> 31:06.860
如果是第二位的话

31:06.860 --> 31:08.260
那么下一次就是第三位了

31:08.260 --> 31:09.260
对不对

31:09.260 --> 31:11.060
柯茵这个社家

31:11.060 --> 31:12.260
我们这样子来处理

31:12.260 --> 31:13.460
对不对

31:13.460 --> 31:15.660
当然那也可以把柯茵这个社家

31:15.660 --> 31:16.260
放到后面

31:16.260 --> 31:17.260
都无所谓

31:17.260 --> 31:18.260
那么现在

31:18.260 --> 31:20.060
那么到了这个25行的时候

31:20.060 --> 31:22.460
是不是一定是第二位以后了

31:22.460 --> 31:22.860
对不对

31:22.860 --> 31:24.260
第二位以后了

31:24.260 --> 31:26.460
那么这一块我们怎么来处理呢

31:26.460 --> 31:28.760
第二位以后我们怎么来处理呢

31:28.760 --> 31:31.260
我们这样子来操作

31:31.260 --> 31:32.460
因为A和B

31:32.460 --> 31:35.060
记录的是前两位的东西

31:35.060 --> 31:35.560
对不对

31:35.560 --> 31:37.860
A和B记录的是前两位的东西

31:37.860 --> 31:38.060
OK

31:38.060 --> 31:40.860
比方说我们之前到了第三位

31:40.860 --> 31:41.660
A等于G

31:43.660 --> 31:45.060
第三位

31:45.060 --> 31:46.160
这是第三位

31:46.160 --> 31:47.460
目前A等于E

31:47.460 --> 31:48.360
B等于E

31:48.360 --> 31:49.860
是这样对应过去的

31:49.860 --> 31:50.060
对吧

31:50.060 --> 31:51.260
E对应到A

31:51.260 --> 31:52.260
E对应到B

31:52.260 --> 31:53.960
那么下一位第三位

31:53.960 --> 31:55.260
第三位应该等于什么呢

31:55.260 --> 31:56.660
是不是A加B

31:56.660 --> 31:57.660
对不对

31:57.660 --> 31:59.660
第三位我们取个C

31:59.660 --> 32:01.160
等于什么A加B

32:01.160 --> 32:01.960
对不对

32:01.960 --> 32:03.660
等于CA加B

32:03.660 --> 32:04.560
那么不要忘记了

32:04.560 --> 32:05.660
柯茵这个社家是不是

32:05.660 --> 32:06.460
还要加加

32:06.460 --> 32:07.060
对不对

32:07.060 --> 32:07.760
还要加加

32:07.760 --> 32:09.960
那么最终我们肯定是要返回C

32:09.960 --> 32:11.760
但是返回C的过后你要注意

32:11.760 --> 32:13.360
那么下一位

32:13.360 --> 32:14.560
那么C是不是算出来了

32:14.560 --> 32:15.960
C是2返回了

32:15.960 --> 32:16.560
对不对

32:16.560 --> 32:18.260
那么下一位的时候

32:18.260 --> 32:19.960
由于A和B是不是没变

32:19.960 --> 32:21.360
那到时候加出来还是2

32:21.360 --> 32:22.160
所以说到

32:22.160 --> 32:23.960
带2这个位置你还不要着急

32:23.960 --> 32:26.560
你要把A和B往前移动两相

32:26.560 --> 32:27.160
对吧

32:27.160 --> 32:28.260
那么A等于什么

32:28.260 --> 32:29.760
等于之前的B

32:29.760 --> 32:30.260
对吧

32:30.260 --> 32:31.760
A等于之前的B

32:31.760 --> 32:32.860
那么B等于什么

32:32.860 --> 32:35.760
等于相加的值就是C

32:35.760 --> 32:36.660
相加的值

32:36.660 --> 32:38.560
所以说我们这里还要处理一下

32:38.560 --> 32:40.860
就是A等于之前的B

32:40.860 --> 32:42.060
把B的值付给A

32:42.060 --> 32:43.560
然后B等于C

32:43.560 --> 32:44.860
B等于C

32:44.860 --> 32:46.660
最后返回

32:46.660 --> 32:47.560
这样子就搞定了

32:47.560 --> 32:48.260
你看一下

32:48.260 --> 32:50.460
那么现在A和B有指向这了

32:50.460 --> 32:51.560
对吧

32:51.560 --> 32:53.260
那么下一位的时候一看

32:53.260 --> 32:55.260
看一下这个逻辑

32:55.260 --> 32:56.560
到下一位的时候

32:56.560 --> 32:58.760
到第四位的时候

32:58.760 --> 33:00.760
那么C的值等于多少呢

33:00.760 --> 33:02.260
A和B相加

33:02.260 --> 33:03.460
A和B相加等于3

33:03.460 --> 33:04.260
对不对

33:04.260 --> 33:05.960
然后柯茵这个是加1

33:05.960 --> 33:07.560
那么下一位就是第五位了

33:07.560 --> 33:09.560
然后A又指向B

33:09.560 --> 33:11.260
A到这来了

33:11.260 --> 33:13.760
B等于指向C

33:13.760 --> 33:14.560
这是不是C

33:14.560 --> 33:16.160
对吧

33:16.160 --> 33:17.360
把C优付给B

33:17.360 --> 33:17.960
那么A和B

33:17.960 --> 33:19.260
就现在指向这个值了

33:19.260 --> 33:20.160
看到没

33:20.160 --> 33:22.560
那么下一位是不是一样的过程

33:22.560 --> 33:23.360
一样的过程

33:23.360 --> 33:24.360
那你看一下

33:24.360 --> 33:27.160
由于我现在并没有用任何数组

33:27.160 --> 33:29.760
那就是说我现在根本就没有管之前的值

33:29.760 --> 33:30.160
对吧

33:30.160 --> 33:31.560
之前我记住了哪些值管

33:31.560 --> 33:31.860
都不管

33:31.860 --> 33:33.660
我只考虑我当前的值

33:33.660 --> 33:35.560
你看整个过程用到的数据量多吗

33:35.560 --> 33:36.560
我就三个属性

33:36.560 --> 33:38.260
其他的没了

33:38.260 --> 33:40.160
我就可以表示一个无限的

33:40.160 --> 33:41.460
非不拉弃数列了

33:41.460 --> 33:42.460
无论掉了多少次

33:42.460 --> 33:44.060
我都可以给你得到结果

33:44.060 --> 33:45.560
当然返回了不是C

33:45.560 --> 33:47.760
返回的是这么一个迭代器

33:47.760 --> 33:49.460
Value等于什么等于C

33:49.460 --> 33:50.060
对吧

33:50.060 --> 33:51.360
Value等于C

33:51.360 --> 33:52.560
然后呢

33:52.560 --> 33:53.060
还有什么呢

33:53.060 --> 33:54.460
还有就是那个

33:54.460 --> 33:55.160
Done

33:55.160 --> 33:57.360
Done永远为Force

33:57.360 --> 33:59.360
永远不会结束

33:59.360 --> 34:00.960
就返回这么一个东西

34:00.960 --> 34:01.360
保存

34:01.360 --> 34:02.160
你看一下

34:02.160 --> 34:04.160
咱们这里运行

34:04.160 --> 34:07.020
运行一下

34:07.020 --> 34:10.720
好 这边

34:10.720 --> 34:12.520
来 调用这个Aterator

34:12.520 --> 34:13.420
那个是

34:13.420 --> 34:16.420
非不拉弃数列A

34:16.420 --> 34:18.120
应该用Z是对吧

34:18.120 --> 34:21.020
应该用Z

34:21.020 --> 34:24.500
这里都没有加Z

34:24.500 --> 34:25.600
Z

34:25.600 --> 34:26.300
Z

34:26.300 --> 34:26.900
Z

34:26.900 --> 34:28.800
Z

34:28.800 --> 34:30.000
Z

34:30.000 --> 34:31.100
OK

34:31.100 --> 34:31.700
好了

34:31.700 --> 34:33.200
那么非不拉弃数列第一位

34:33.200 --> 34:33.800
第二位

34:33.800 --> 34:36.600
Z

34:36.600 --> 34:38.400
这里少了个Z

34:38.400 --> 34:39.300
再来

34:39.300 --> 34:40.000
第一位

34:40.000 --> 34:40.600
第二位

34:40.600 --> 34:42.200
第三位

34:42.200 --> 34:43.600
前两项还有问题

34:43.600 --> 34:44.300
前两项

34:44.300 --> 34:45.800
我们应该是个标准格式

34:45.800 --> 34:46.900
Value等于什么呢

34:46.900 --> 34:48.300
Value等于E

34:48.300 --> 34:51.000
Done为Force

34:51.000 --> 34:52.500
格式不标准

34:52.500 --> 34:53.800
那个是第一位

34:53.800 --> 34:54.800
第二位

34:54.800 --> 34:55.600
第三位

34:55.600 --> 34:56.300
第四位

34:56.300 --> 34:56.900
第五位

34:56.900 --> 34:57.500
第六位

34:57.500 --> 34:58.000
第七位

34:58.000 --> 34:58.800
第八位

34:58.800 --> 34:59.400
可以这样是不是

34:59.400 --> 35:00.400
可以这样无限

35:00.400 --> 35:01.600
无限进行下去

35:01.600 --> 35:02.000
对吧

35:02.000 --> 35:03.200
无限进行下去

35:03.200 --> 35:05.300
我并没有要求你多少个

35:05.300 --> 35:08.000
你要用多少个去调用多少个Nex就行了

35:08.000 --> 35:08.800
那么比方说

35:08.800 --> 35:09.700
我到时候

35:09.700 --> 35:13.700
要输出非不拉弃数列的前5位的值

35:13.700 --> 35:14.900
那怎么来输出呢

35:14.900 --> 35:15.900
我们比方说

35:15.900 --> 35:18.300
要输出非不拉弃数列前5位的值

35:18.300 --> 35:19.300
我们就这样吧

35:19.300 --> 35:20.400
就这样

35:20.400 --> 35:22.900
一个4循环

35:22.900 --> 35:23.700
循环几次呢

35:23.700 --> 35:24.900
循环5次

35:24.900 --> 35:26.700
循环5次

35:26.700 --> 35:27.400
对吧

35:27.400 --> 35:29.200
然后每一次输出啥

35:29.200 --> 35:32.300
每一次输出Aterator

35:32.300 --> 35:33.300
调用Nex过后

35:33.300 --> 35:34.100
是不是一个Value

35:34.100 --> 35:34.500
对吧

35:34.500 --> 35:35.500
他的Value值

35:35.500 --> 35:36.900
他的Value值就完成了

35:36.900 --> 35:37.600
保存

35:37.600 --> 35:38.400
你看一下

35:38.400 --> 35:39.900
输出了11235

35:39.900 --> 35:40.500
对吧

35:40.500 --> 35:41.600
那么如果说

35:41.600 --> 35:42.900
20位呢

35:42.900 --> 35:43.200
你看

35:43.200 --> 35:45.100
我就说输出了20位的值

35:45.100 --> 35:45.900
对不对

35:45.900 --> 35:47.000
你想输出多少位

35:47.000 --> 35:47.900
就输出多少位

35:47.900 --> 35:49.300
比方说100位

35:49.300 --> 35:50.100
100位

35:50.100 --> 35:51.900
后面的值就很恐怖了

35:51.900 --> 35:52.700
100位

35:52.700 --> 35:53.400
对吧

35:53.400 --> 35:54.500
你想输出多少个

35:54.500 --> 35:55.300
就多输出多少个

35:55.300 --> 35:57.100
它的效率是非常高的

35:57.100 --> 36:00.000
因为它根本就没有保存之前的数据

36:00.000 --> 36:01.200
原来的意思吧

36:01.200 --> 36:02.400
这是迭代器

36:02.400 --> 36:04.600
它所具有的一些特殊的优势

36:06.400 --> 36:07.200
那么通过这个例子

36:07.200 --> 36:08.500
大家也可以知道

36:08.500 --> 36:10.500
比方说我们要便利

36:10.500 --> 36:11.900
要便利一个迭代器

36:11.900 --> 36:13.600
直到它便利结束

36:13.600 --> 36:14.700
那么怎么去便利呢

36:14.700 --> 36:16.300
比方说我们再举个例子

36:16.300 --> 36:17.100
多来点例子

36:17.100 --> 36:18.500
我们视频课程呢

36:18.500 --> 36:19.500
我就不着急了

36:19.500 --> 36:20.800
咱们我希望呢

36:20.800 --> 36:22.200
每一个同学听我的课程同学呢

36:22.200 --> 36:23.700
都能搞清楚是怎么回事

36:23.700 --> 36:24.900
反正我尽量讲

36:24.900 --> 36:26.900
就我自己最大的努力在讲

36:26.900 --> 36:27.000
好

36:27.000 --> 36:27.300
这里呢

36:27.300 --> 36:28.200
比方说我们这里

36:29.800 --> 36:30.100
这里呢

36:30.100 --> 36:31.200
不是可迭代3次吗

36:31.200 --> 36:31.500
对吧

36:31.500 --> 36:32.300
我也不知道

36:32.300 --> 36:33.400
但是我得到的迭代器过后

36:33.400 --> 36:33.900
我也不知道

36:33.900 --> 36:35.700
那一步可以迭代几次

36:35.700 --> 36:37.800
那么比方说我要便利

36:37.800 --> 36:42.400
就是一个一个迭代

36:42.400 --> 36:47.500
直到不能迭代为止

36:47.500 --> 36:48.500
迭代为止

36:48.500 --> 36:50.300
那么我们该来怎么来写呢

36:50.300 --> 36:51.400
怎么来写这个东西呢

36:51.400 --> 36:53.400
我们可以用这种方式

36:53.400 --> 36:55.700
得到它的数据

36:55.700 --> 36:58.800
得到它的NATURATE

36:58.800 --> 37:00.100
调这个NATURATE

37:00.100 --> 37:00.500
对吧

37:00.600 --> 37:02.400
拿到它的第一个数据

37:02.400 --> 37:03.400
判断一下

37:03.400 --> 37:04.500
判断一下

37:04.500 --> 37:06.400
如果说这个NATURATE

37:06.400 --> 37:09.100
但它还没有完成

37:09.100 --> 37:11.500
它还没有完成

37:11.500 --> 37:14.600
若当前迭代

37:14.600 --> 37:15.900
迭代的数据

37:15.900 --> 37:18.600
没有

37:18.600 --> 37:22.700
不是迭代器的结束

37:22.700 --> 37:23.100
结束

37:23.100 --> 37:23.600
什么要结束

37:23.600 --> 37:25.300
就迭代器没数据了

37:25.300 --> 37:26.400
就是没数据了

37:26.400 --> 37:28.200
换句话说就是

37:28.300 --> 37:30.600
如果当前

37:30.600 --> 37:33.600
如果当前还有数据

37:33.600 --> 37:35.100
还有数据是没有结束

37:35.100 --> 37:36.000
还有数据

37:36.000 --> 37:36.700
还有数据干嘛

37:36.700 --> 37:40.400
那我就输出这个NATURATE 06

37:40.400 --> 37:41.000
输出完了过后

37:41.000 --> 37:42.200
是不是要指向下一下

37:42.200 --> 37:42.700
对吧

37:42.700 --> 37:43.400
又来一次

37:43.400 --> 37:44.500
NATURATE NATURATE 06

37:44.500 --> 37:44.700
对吧

37:44.700 --> 37:45.900
又指向下一下

37:45.900 --> 37:46.400
下一下看一下

37:46.400 --> 37:47.300
有没有结束

37:47.300 --> 37:48.200
没有结束又来

37:48.200 --> 37:49.100
又来又来

37:49.100 --> 37:50.100
对吧

37:50.100 --> 37:50.800
保存

37:50.800 --> 37:50.900
好

37:50.900 --> 37:51.800
咱们看一下

37:51.800 --> 37:57.320
第一个

37:57.320 --> 37:58.920
第四个

37:58.920 --> 37:59.520
运行看一下

38:00.720 --> 38:02.120
好

38:02.120 --> 38:03.320
你看一下输出

38:03.320 --> 38:04.020
是不是输出了

38:04.020 --> 38:04.820
三个水技术

38:04.820 --> 38:05.220
对吧

38:05.220 --> 38:06.120
三个水技术

38:06.120 --> 38:06.920
因为到了第四个

38:06.920 --> 38:08.020
就表示已经结束了

38:08.020 --> 38:08.520
对吧

38:08.520 --> 38:10.320
就表示已经结束了

38:10.320 --> 38:10.920
看没

38:10.920 --> 38:12.720
这就是这个

38:12.720 --> 38:13.920
迭代器

38:13.920 --> 38:14.920
它的这几种

38:14.920 --> 38:16.520
它的这些常见的用法

38:16.520 --> 38:18.320
常见的用法

38:18.320 --> 38:19.720
那么现在大家应该明白

38:19.720 --> 38:21.320
迭代和便利的区别了

38:21.320 --> 38:22.020
便利的话

38:22.020 --> 38:22.920
一般我们指的便利

38:22.920 --> 38:23.320
指的是

38:23.320 --> 38:24.720
它有一个数据结构

38:24.720 --> 38:26.120
结构已经把数据装好了

38:26.120 --> 38:27.620
数据已经现成的了

38:27.620 --> 38:28.120
对吧

38:28.120 --> 38:29.620
已经是现成的数据了

38:29.720 --> 38:30.620
那么你去

38:30.620 --> 38:31.920
挨摘着去拿

38:31.920 --> 38:32.620
迭代

38:32.620 --> 38:33.420
它指的是

38:33.420 --> 38:34.920
这个数据不一定是现成的

38:34.920 --> 38:35.620
这拿的时候

38:35.620 --> 38:36.120
我给你加

38:36.120 --> 38:36.920
我给你拿一个

38:36.920 --> 38:37.620
你要多少

38:37.620 --> 38:38.120
我给你拿多少

38:38.120 --> 38:39.220
要多少给你拿多少

38:39.220 --> 38:39.820
要一个

38:39.820 --> 38:40.520
下一个的时候

38:40.520 --> 38:41.720
我就去生成这样的数据

38:41.720 --> 38:42.720
结定

38:42.720 --> 38:44.020
它指的是这么个意思

38:47.020 --> 38:48.820
当然我们也可以

38:48.820 --> 38:50.320
一会儿也可以写新地址

38:50.320 --> 38:51.720
跟那个输出了结合

38:51.720 --> 38:53.420
来做一个迭代器也行

38:53.420 --> 38:54.320
这是迭代器

38:54.320 --> 38:55.020
始终记住

38:55.020 --> 38:55.820
迭代器就是

38:55.820 --> 38:56.820
写了这么多地址

38:56.820 --> 38:58.820
我建议大家慢一点

38:58.820 --> 39:00.020
因为这一块到了后边

39:00.020 --> 39:01.220
肯定会有点绕

39:01.220 --> 39:02.420
大家慢一点学习

39:02.420 --> 39:03.620
可以先把这一块东西

39:03.620 --> 39:04.420
先巩固一下

39:04.420 --> 39:05.820
先去写一下

39:05.820 --> 39:06.920
先写一下

39:06.920 --> 39:07.620
理解了过后

39:07.620 --> 39:08.620
我们再继续往后学

39:10.220 --> 39:10.720
然后迭代器

39:10.720 --> 39:11.420
它就是一个对象

39:11.420 --> 39:12.220
它有个那个时候方法

39:12.220 --> 39:12.820
那个时候方法

39:12.820 --> 39:13.620
反回一个新的对象

39:13.620 --> 39:14.320
有 value 和当

39:14.320 --> 39:15.420
这两个数据

39:15.420 --> 39:17.020
它们分别什么意思

39:17.020 --> 39:18.420
然后我们这里再说一个

39:18.420 --> 39:20.320
关于迭代器的一个

39:20.320 --> 39:21.620
另一个东西

39:21.620 --> 39:22.320
叫做了

39:23.620 --> 39:25.620
叫做了 attrator function

39:25.620 --> 39:26.920
creator

39:26.920 --> 39:27.620
我们把它叫做

39:28.820 --> 39:29.820
迭代器

39:31.420 --> 39:32.820
创建函数

39:34.220 --> 39:34.920
迭代器什么意思

39:34.920 --> 39:35.920
叫 attrator

39:37.220 --> 39:38.420
迭代器创建函数

39:38.420 --> 39:39.420
叫 attrator

39:40.920 --> 39:41.520
creator

39:43.420 --> 39:44.220
这什么东西呢

39:45.420 --> 39:46.820
这个东西表示的是

39:47.820 --> 39:50.520
它是指一个函数

39:51.620 --> 39:53.220
它是指一个函数

39:54.620 --> 39:57.020
它是指一个函数

39:57.620 --> 39:59.320
调用该函数后

39:59.920 --> 40:00.920
该函数后

40:01.420 --> 40:03.820
返回一个迭代器

40:04.520 --> 40:04.820
对吧

40:04.820 --> 40:06.020
返回一个迭代器

40:06.020 --> 40:07.720
则该函数

40:07.720 --> 40:10.820
称之为迭代器

40:10.820 --> 40:12.120
创建函数

40:12.120 --> 40:12.720
也有迭代器

40:12.720 --> 40:14.820
不是我刚才我们之前写的都是

40:14.820 --> 40:16.820
直接写一个迭代器

40:16.820 --> 40:17.520
对吧

40:17.520 --> 40:17.920
那么

40:19.120 --> 40:19.920
更多的时候

40:19.920 --> 40:22.220
迭代器是通过一个函数来创建的

40:22.220 --> 40:23.620
那么这个函数

40:23.620 --> 40:24.920
返回一个迭代器

40:24.920 --> 40:25.820
那么这个函数叫迭代器

40:25.820 --> 40:26.720
创建函数

40:26.720 --> 40:27.420
有的时候

40:28.220 --> 40:29.420
可以简称为

40:31.020 --> 40:32.620
称为迭代器

40:33.620 --> 40:34.520
函数

40:34.520 --> 40:36.320
就是我发现很多同学学迭代器

40:36.320 --> 40:37.420
学习证据这一块

40:37.420 --> 40:38.720
就是忽略了这个东西

40:38.720 --> 40:39.520
它把迭代器

40:39.520 --> 40:42.220
跟迭代器创建函数搞昏小了

40:42.220 --> 40:42.620
而且

40:42.620 --> 40:43.920
但是实际上

40:43.920 --> 40:46.220
这个在国外的文献里边

40:46.220 --> 40:47.520
它是有明确的教法的

40:47.520 --> 40:48.120
只不过国内

40:48.120 --> 40:49.720
很少这样去教

40:49.720 --> 40:51.820
很少去教说什么迭代器函数

40:51.820 --> 40:52.920
迭代器创建函数

40:52.920 --> 40:54.120
很少去这样子说

40:54.120 --> 40:56.520
所以说很容易给初学长的造成昏小

40:56.520 --> 40:57.120
那么这里呢

40:57.120 --> 40:59.720
我就强行给大家加上这么一个名词

40:59.720 --> 41:01.520
叫做迭代器创建函数

41:01.520 --> 41:02.520
创建函数

41:02.520 --> 41:04.320
通过这个函数为创建个迭代器

41:04.320 --> 41:05.420
比方说

41:05.420 --> 41:07.820
咱们再来写个

41:07.820 --> 41:09.520
比方说1.2

41:09.520 --> 41:10.920
这里

41:10.920 --> 41:12.020
我们把它写成一种

41:12.020 --> 41:14.720
迭代器创建函数的方式

41:20.440 --> 41:22.340
迭代器创建函数的这种方式

41:22.340 --> 41:23.940
那么刚才我们是直接写个迭代器

41:23.940 --> 41:24.440
对吧

41:24.440 --> 41:24.640
好

41:24.640 --> 41:26.140
那么现在我们换动写法

41:26.140 --> 41:26.940
看着

41:26.940 --> 41:28.140
换动写法

41:29.240 --> 41:31.240
就是create

41:33.240 --> 41:33.940
创建个迭代器

41:33.940 --> 41:35.540
你给我传一个总数进来

41:35.540 --> 41:36.940
能够迭代多少次

41:36.940 --> 41:37.440
我也不知道

41:37.440 --> 41:38.740
你可以给传一个参数进来

41:38.740 --> 41:40.140
当然也可以没有参数

41:40.140 --> 41:41.440
先说没有参数

41:41.440 --> 41:42.040
没有参数的话

41:42.040 --> 41:43.740
我们这里直接定一个变量

41:43.740 --> 41:44.540
等于3

41:44.540 --> 41:45.840
然后i等于1

41:45.840 --> 41:46.840
对吧

41:46.840 --> 41:48.440
那么这个东西

41:48.440 --> 41:49.740
是不是直接可以返回了

41:49.740 --> 41:50.340
返回一个对象

41:50.340 --> 41:52.340
这个对象里面一个那个舍方法

41:52.340 --> 41:53.140
就完了

41:53.140 --> 41:54.040
没了

41:54.040 --> 41:55.440
就这么简单

41:55.440 --> 41:56.040
就这么简单

41:56.040 --> 41:57.740
这就是个迭代器创建函数

41:57.740 --> 41:58.140
对吧

41:58.140 --> 41:59.340
你看看这个函数调用之后

41:59.340 --> 42:01.840
是不是返回了一个迭代器

42:01.840 --> 42:03.640
你看看是不是返回了一个迭代器

42:03.640 --> 42:03.940
对吧

42:03.940 --> 42:05.440
一共迭代三次

42:05.440 --> 42:06.740
一共迭代三次

42:06.740 --> 42:08.040
对吧

42:08.040 --> 42:08.940
没问题吧

42:08.940 --> 42:09.740
那么

42:09.740 --> 42:10.440
那么之后

42:10.440 --> 42:12.140
如果说我要得到迭代器的话

42:12.140 --> 42:13.040
我可以怎么得到

42:13.040 --> 42:15.140
我就不是直接写的对象

42:15.140 --> 42:16.840
而是通过这个函数来得到

42:16.840 --> 42:19.040
帮我们来得到一个迭代器

42:19.040 --> 42:20.140
这样子的更加灵活

42:20.140 --> 42:21.340
因为这个函数里面可以传参数

42:21.340 --> 42:22.740
可以进行一些配置

42:22.740 --> 42:25.440
就比我们自己熟悉对象要灵活的多

42:25.440 --> 42:26.040
那么这里

42:26.040 --> 42:27.940
我们可以通过调用这个函数

42:27.940 --> 42:29.240
来得到这么一个迭代器

42:29.240 --> 42:30.440
iterator

42:31.740 --> 42:33.240
得到这个迭代器

42:33.240 --> 42:34.940
那么如果说我要便利的话

42:34.940 --> 42:35.540
也很简单

42:35.540 --> 42:36.140
就这样的便利

42:36.140 --> 42:38.240
跟之前的便利方式是一样的

42:38.240 --> 42:39.540
便利方式是不是一样的

42:39.540 --> 42:40.640
对不对

42:40.640 --> 42:42.640
挨着来的迭代一个个拿出来

42:42.640 --> 42:44.040
是完全一样的

42:44.040 --> 42:47.750
运行出来看一下的

42:47.750 --> 42:48.150
你看一下

42:48.150 --> 42:48.350
是吧

42:48.350 --> 42:49.150
迭代了三次

42:49.150 --> 42:49.450
对吧

42:49.450 --> 42:50.550
拿到了三个水渐数

42:50.550 --> 42:51.450
迭代了三次

42:51.450 --> 42:52.150
那么这个函数

42:52.150 --> 42:53.550
因为它是一个函数

42:53.550 --> 42:54.850
所以它可以很灵活

42:54.850 --> 42:56.350
比方说你给我偷偷

42:56.350 --> 42:57.750
函数你给我传进来

42:57.750 --> 42:57.950
对吧

42:57.950 --> 42:58.750
函数给我传进来

42:58.750 --> 42:59.350
ok

42:59.350 --> 43:02.050
那我现在就按照你的函数来定就行了

43:02.050 --> 43:02.850
比方说我这里

43:02.850 --> 43:04.150
要迭代100次

43:04.150 --> 43:05.550
我这里要迭代100次

43:05.550 --> 43:05.750
好

43:05.750 --> 43:06.150
保存

43:11.360 --> 43:12.860
为什么还只有三次

43:12.860 --> 43:13.860
我看一下

43:15.060 --> 43:17.160
这里我怎么写死了

43:17.160 --> 43:18.760
这里不应该写死

43:18.760 --> 43:21.160
要使ZS.toto

43:21.160 --> 43:22.760
不应该写死

43:22.760 --> 43:23.960
为什么把它写死了

43:26.160 --> 43:28.260
ZS.toto

43:28.360 --> 43:29.360
这里也是

43:29.360 --> 43:29.860
这里也是

43:29.860 --> 43:31.060
不应该写死

43:33.360 --> 43:33.460
好

43:33.460 --> 43:34.160
那么这里也是

43:35.260 --> 43:35.660
Toto

43:39.610 --> 43:40.210
那么这样子

43:40.210 --> 43:41.810
我们就其实利用到了B包

43:41.810 --> 43:42.110
对吧

43:42.110 --> 43:42.910
利用到了B包

43:42.910 --> 43:44.710
我对象就非常的纯净

43:44.710 --> 43:46.610
没有其他乱七八糟的属性了

43:46.610 --> 43:48.610
当然有其他属性也不影响

43:48.610 --> 43:50.110
也不影响它是一个迭代器

43:50.110 --> 43:50.610
只不过

43:50.610 --> 43:52.210
它比较纯净了

43:52.210 --> 43:53.510
我们就通过内部变量

43:53.510 --> 43:55.410
一些参数来完成的B包

43:55.410 --> 43:56.810
在函数里边使用到参数

43:56.810 --> 43:57.910
使用到内部变量

43:57.910 --> 43:59.710
那么外面就访问不到了

43:59.710 --> 44:01.110
我们在这里就可以通过

44:01.110 --> 44:03.810
这种方式来创建一个指定次数的迭代器

44:03.810 --> 44:05.410
那么这个迭代器可以迭代100次

44:05.410 --> 44:05.810
对吧

44:05.810 --> 44:06.510
那么这里

44:06.510 --> 44:08.510
我们写个5就可以迭代5次

44:08.510 --> 44:08.710
对吧

44:08.710 --> 44:10.310
就迭代5次

44:10.310 --> 44:11.310
没问题吧

44:11.310 --> 44:12.310
这就是

44:12.310 --> 44:14.610
我们可以通过一个函数

44:14.610 --> 44:17.210
来得到这么一个迭代器

44:17.210 --> 44:19.310
这个函数叫做迭代器函数

44:19.310 --> 44:21.710
或者叫迭代器创建函数

44:21.710 --> 44:23.310
当然你说迭代器创建函数

44:23.310 --> 44:24.510
要更加准确一点

44:24.510 --> 44:26.010
只不过我们平时文说简洁了

44:26.010 --> 44:27.610
也说成迭代器

44:27.610 --> 44:28.810
就是

44:29.710 --> 44:30.910
但是它不是一个迭代器

44:30.910 --> 44:31.910
它本身不是个迭代器

44:31.910 --> 44:33.010
它才是迭代器

44:33.010 --> 44:35.010
它是用来得到迭代器的

44:35.010 --> 44:36.810
比如说我们再来一个例子

44:36.810 --> 44:37.910
比如说我们要迭代

44:37.910 --> 44:39.810
我们要把一个数组变成一个迭代器

44:43.810 --> 44:46.310
比如说我们要把一个数组变成一个迭代器

44:46.310 --> 44:47.510
有这么一个数组吗

44:47.510 --> 44:48.110
比如说

44:50.310 --> 44:53.310
我们希望把它变成一个迭代器的模式来使用

44:53.310 --> 44:55.750
二位

44:55.750 --> 44:56.750
就随便写个

44:57.750 --> 44:58.850
随便写个

44:58.950 --> 45:01.650
我们希望把它变成一个迭代器数组来使用

45:01.650 --> 45:02.850
怎么做呢

45:02.850 --> 45:04.150
迭代器它其实很简单

45:04.150 --> 45:04.650
就是一个对象

45:04.650 --> 45:06.250
它的对象里面有一个Nex

45:06.250 --> 45:08.750
那么这里我们就可以利用一个迭代器函数

45:08.750 --> 45:12.250
叫做Critz Array Aetherator

45:12.250 --> 45:14.250
用于迭代数组的迭代器

45:17.080 --> 45:24.320
创建一个用于迭代数组的迭代器

45:24.320 --> 45:25.420
那么这里要传个参数

45:25.420 --> 45:26.720
传个数组性来

45:26.720 --> 45:27.920
传个数组性来

45:27.920 --> 45:29.620
比方说到时候我们就直接调用

45:29.620 --> 45:31.420
直接调用就完事了

45:31.420 --> 45:33.020
到时候我们比方说

45:33.020 --> 45:33.620
Aetherator

45:33.620 --> 45:34.820
我们到时候要怎么用呢

45:34.820 --> 45:38.020
就是通过这个方法Critz Array Aetherator

45:38.020 --> 45:39.520
那么把数组传进去

45:39.520 --> 45:40.920
然后通过调用Nex

45:40.920 --> 45:43.420
它就可以依次取出数组的每一项

45:43.420 --> 45:45.120
当然你说这个真的有啥意义呢

45:45.120 --> 45:46.720
当然没啥意义

45:46.720 --> 45:47.620
你不着急吗

45:47.620 --> 45:49.720
你不着急要知道怎么写

45:49.720 --> 45:50.920
要知道怎么写

45:50.920 --> 45:52.220
那么这样子

45:52.220 --> 45:54.720
就可以依次取出一个数组里面每一项了

45:54.720 --> 45:55.920
怎么取出就是Aetherator

45:55.920 --> 45:57.220
DurNex取出第1项

45:57.220 --> 45:58.820
DurNex取出第2项

45:58.820 --> 46:00.220
就是这个意思

46:00.320 --> 46:02.120
那么这里咱们怎么写呢

46:02.120 --> 46:02.720
怎么写呢

46:02.720 --> 46:03.820
我们其实就用一个变量

46:03.820 --> 46:05.720
i来表示数组的下标

46:05.720 --> 46:10.720
下标从0开始变立跌带

46:10.720 --> 46:11.520
好返回的是什么

46:11.520 --> 46:12.720
返回的是一定要记住

46:12.720 --> 46:13.720
返回的是一个对象

46:13.720 --> 46:15.620
对象里面有一个Nex的方法

46:15.620 --> 46:16.620
这个方法里面

46:16.620 --> 46:17.320
返回的是什么呢

46:17.320 --> 46:18.020
又返回一个对象

46:18.020 --> 46:19.020
它一定是这种格式

46:19.020 --> 46:20.320
没有别的格式了

46:20.320 --> 46:22.020
一定是这种格式

46:22.020 --> 46:23.720
那么这里返回的对象是什么呢

46:23.720 --> 46:25.320
n6值等于什么

46:25.320 --> 46:27.020
是不是通过下标i

46:27.020 --> 46:29.020
来取出数组的其中一项

46:29.020 --> 46:30.120
下标i

46:30.120 --> 46:32.220
取出数组中其中一下

46:32.220 --> 46:33.320
对不对

46:33.320 --> 46:35.820
那有没有超过这个数组的边界呢

46:35.820 --> 46:37.120
当然有可能超过

46:37.120 --> 46:37.820
超过这个数组的边界

46:37.820 --> 46:38.820
它自然是undefined

46:38.820 --> 46:40.320
所以说这里不用去缓它了

46:40.320 --> 46:41.820
自然而然是undefined

46:41.820 --> 46:43.720
好那么这里的当

46:43.720 --> 46:45.320
是不是取完了呢

46:45.320 --> 46:46.520
那看什么呢

46:46.520 --> 46:48.120
看下怎么来看是不是取完了

46:48.120 --> 46:50.620
是不是i大于等于了数组长度

46:50.620 --> 46:53.920
i大于等于了数组的长度

46:53.920 --> 46:55.520
是不是就取完了

46:55.520 --> 46:57.720
如果说这个条件满足了

46:57.720 --> 46:58.720
是不是就取完了

46:58.720 --> 46:59.520
超出了边界了

46:59.520 --> 47:02.020
因为i的值最大就是数组长度减1

47:02.020 --> 47:03.220
那大于等于了数组长度

47:03.220 --> 47:04.420
那自然就取完了

47:04.420 --> 47:05.120
对不对

47:05.120 --> 47:06.120
好那么你不要忘记了

47:06.120 --> 47:07.020
i还要加加

47:07.020 --> 47:08.420
每一次取了过i要加加

47:08.420 --> 47:10.320
所以说我们这里先用个辨量

47:10.320 --> 47:11.120
先用辨量

47:11.120 --> 47:12.420
然后i加加

47:12.420 --> 47:14.720
最后返回这个辨量

47:14.720 --> 47:15.520
对吧

47:15.520 --> 47:16.920
就完了

47:16.920 --> 47:20.420
好保存你看一下吧

47:20.420 --> 47:21.120
好那么这样子呢

47:21.120 --> 47:23.020
我们就得到一个数组的迭代器了

47:23.020 --> 47:24.820
得到数组的一个迭代器

47:24.820 --> 47:25.720
通过这个迭代器呢

47:25.720 --> 47:26.720
我们Aterator

47:26.720 --> 47:28.120
那么每一次掉到Nex

47:28.120 --> 47:29.720
我们就可以发现

47:29.720 --> 47:30.820
AteratorNex

47:30.920 --> 47:33.120
就会发现打出了数组的第1项

47:33.120 --> 47:33.720
第2项

47:33.720 --> 47:34.220
第3项

47:34.220 --> 47:34.720
第4项

47:34.720 --> 47:35.420
第5项

47:35.420 --> 47:36.120
第6项

47:36.120 --> 47:36.320
哎

47:36.320 --> 47:36.920
没了

47:36.920 --> 47:38.020
看见没

47:38.020 --> 47:38.320
哎

47:38.320 --> 47:39.020
就这么个意思

47:39.020 --> 47:39.220
看见没

47:39.220 --> 47:40.820
后面全部没了

47:40.820 --> 47:43.320
数组里的东西就全部没了

47:43.320 --> 47:44.020
但是有的时候呢

47:44.020 --> 47:44.720
你为了

47:44.720 --> 47:46.320
有的时候我看

47:46.320 --> 47:47.420
你们以后在网上

47:47.420 --> 47:48.920
看到一些别的教程里边

47:48.920 --> 47:49.820
或者一些帖子里边

47:49.820 --> 47:50.820
他写的比较简洁

47:50.820 --> 47:51.820
可能这样子写

47:51.820 --> 47:52.420
Return

47:52.420 --> 47:53.320
i加加

47:53.320 --> 47:53.820
对吧

47:53.820 --> 47:54.820
把加加写到这儿

47:54.820 --> 47:55.520
写到这儿

47:55.520 --> 47:55.920
那么这里呢

47:55.920 --> 47:57.520
就是大于数组长度

47:57.520 --> 47:58.420
这样子写也行

47:58.420 --> 47:58.620
啊

47:58.620 --> 47:59.020
也行

47:59.020 --> 47:59.720
到底是一样的

47:59.720 --> 48:00.520
只不过这里呢

48:00.520 --> 48:02.120
你要稍微女一女

48:02.120 --> 48:03.020
稍微要遭遇

48:03.020 --> 48:04.320
就说这里呢

48:04.320 --> 48:05.120
加加放后边

48:05.120 --> 48:06.220
整个表达是

48:06.220 --> 48:07.220
它的值不变

48:07.220 --> 48:08.420
i是多少就是多少

48:08.420 --> 48:09.920
但是运行完这个表达是之后

48:09.920 --> 48:10.920
i要加1

48:10.920 --> 48:12.720
由于这里i加1了

48:12.720 --> 48:13.920
那比较说最后一个下标

48:13.920 --> 48:16.220
最后一个下标是i等于长度减1

48:16.220 --> 48:17.620
长度减1是能取到值的

48:17.620 --> 48:17.820
对吧

48:17.820 --> 48:18.720
能取到值

48:18.720 --> 48:19.020
但是呢

48:19.020 --> 48:19.820
这样子呢

48:19.820 --> 48:20.520
加加过后呢

48:20.520 --> 48:20.920
i的值

48:20.920 --> 48:22.220
就这个表达是运行完了过后

48:22.220 --> 48:23.520
i是不是变成长度了

48:23.520 --> 48:23.920
对吧

48:23.920 --> 48:24.920
i是变成长度了

48:24.920 --> 48:26.020
那么一说i的长

48:26.020 --> 48:27.220
i等于

48:27.220 --> 48:28.720
二位的长度也是允许的

48:28.720 --> 48:29.820
因为他加加了

48:29.820 --> 48:30.520
加加过后

48:30.520 --> 48:31.820
那么这里的判断呢

48:31.820 --> 48:33.120
你要把它想象成为

48:33.120 --> 48:34.820
i之前已经加了一次了

48:34.820 --> 48:35.920
加了一次i了

48:35.920 --> 48:37.120
加了一次i的时候呢

48:37.120 --> 48:38.320
你看是不是结束

48:38.320 --> 48:39.420
那么你就跟

48:39.420 --> 48:40.520
大于这个数字长度

48:40.520 --> 48:41.820
而不是大于等于了

48:41.820 --> 48:43.620
因为它这里已经完成一次加加

48:43.620 --> 48:44.920
这个稍微去女一下

48:44.920 --> 48:47.120
将大家都能女清楚

48:47.120 --> 48:47.320
好

48:47.320 --> 48:47.620
总之呢

48:47.620 --> 48:48.620
这也是也行

48:48.620 --> 48:49.120
也行

48:49.120 --> 48:51.520
367 213

48:51.520 --> 48:54.520
367 223

48:54.620 --> 48:55.020
没了

48:56.720 --> 48:57.120
好

48:57.120 --> 48:58.220
那么这就是一个

48:58.220 --> 48:59.520
迭代器

48:59.520 --> 49:00.620
跟数组的怎么去结合

49:00.620 --> 49:01.420
当然你知道

49:01.420 --> 49:02.520
跟数字怎么结合

49:02.520 --> 49:03.420
其他什么map

49:03.420 --> 49:04.120
CSS

49:04.120 --> 49:04.920
是不是都行

49:04.920 --> 49:05.320
对吧

49:05.320 --> 49:05.820
都行

49:06.820 --> 49:07.020
好

49:07.020 --> 49:07.520
那么现在呢

49:07.520 --> 49:07.920
我们支持

49:07.920 --> 49:09.420
我们讲清楚了两个问题

49:09.420 --> 49:11.020
一个什么是迭代器

49:11.020 --> 49:12.020
非常清楚了吧

49:12.020 --> 49:14.220
我相信没有任何同学有疑问了

49:14.220 --> 49:16.520
一个是迭代器创建函数是什么

49:16.520 --> 49:17.420
就是一个函数

49:17.420 --> 49:18.520
返回个迭代器

49:18.520 --> 49:20.420
这个函数有什么样的参数

49:20.420 --> 49:21.820
无所谓的

49:21.820 --> 49:22.020
好

49:22.020 --> 49:23.020
那么这一块是

49:23.020 --> 49:24.520
迭代器讲完了

49:25.820 --> 49:27.420
迭代器讲完了之后呢

49:28.820 --> 49:31.020
下一个就是可迭代协议

49:33.120 --> 49:34.320
可迭代协议

49:35.220 --> 49:36.920
可迭代协议又非常好讲了

49:38.620 --> 49:40.020
你只要你深刻的理解了

49:40.020 --> 49:40.820
什么叫迭代器

49:40.820 --> 49:41.820
他的本质是什么

49:41.820 --> 49:43.420
那么可迭代协议就很好讲

49:44.020 --> 49:46.420
那么什么叫做可迭代协议呢

49:47.320 --> 49:48.420
他指的是这么一个东西

49:50.520 --> 49:51.220
可迭代协议呢

49:51.220 --> 49:53.220
他不是说你的代码应该怎么去

49:53.820 --> 49:55.520
他没有说代码是什么样子

49:55.920 --> 49:57.520
他只是一种规范

49:58.520 --> 50:00.620
就是说在ES6过后呢

50:00.820 --> 50:02.520
他出现了这么一个循环

50:02.520 --> 50:03.820
叫做FOR25循环

50:03.820 --> 50:04.520
对不对

50:04.520 --> 50:06.120
FOR25循环干嘛的呢

50:07.020 --> 50:12.520
ES6中出现了FOR25循环

50:13.720 --> 50:18.020
该循环就是用于迭代

50:19.720 --> 50:22.520
某个对象的

50:22.820 --> 50:24.220
他是用来迭代某个对象的

50:24.220 --> 50:27.020
就把对象的相应信息一个个取出来

50:27.020 --> 50:28.420
就是FOR25循环

50:28.420 --> 50:29.820
当你以前给你讲的时候

50:29.820 --> 50:31.020
我也不知道

50:31.020 --> 50:32.920
因为我现在我还没有讲到ES6

50:32.920 --> 50:34.620
我不知道你之前的老师怎么讲的

50:34.620 --> 50:36.920
因为FOR25循环最直观的就是说

50:36.920 --> 50:37.820
便利

50:37.820 --> 50:39.020
便利数组的每一项

50:39.020 --> 50:41.420
便利一个东西的每一项

50:41.420 --> 50:42.820
一个集合的每一项

50:42.820 --> 50:44.420
它是起个便利的作用

50:44.420 --> 50:46.020
实际上它是用来迭代的

50:46.020 --> 50:48.220
它是迭代对象的每一个东西

50:49.220 --> 50:50.420
那么也就是说

50:50.520 --> 50:52.220
FOR25循环

50:52.220 --> 50:55.920
因此FOR25循环

50:55.920 --> 51:00.820
要求对象必须是可迭代的

51:00.820 --> 51:02.220
什么叫对象是可迭代的呢

51:02.220 --> 51:06.520
指的是对象必须满足可迭代协议

51:07.920 --> 51:08.520
就这个意思

51:10.020 --> 51:10.720
FOR25循环

51:10.720 --> 51:15.020
他要求对象必须要满足可迭代协议

51:15.020 --> 51:17.020
那么可迭代协议是什么呢

51:17.020 --> 51:23.220
可迭代协议是用于约束一个对象的

51:23.220 --> 51:28.620
如果一个对象满足下面的规范

51:28.620 --> 51:34.420
则该对象满足可迭代协议

51:34.420 --> 51:42.400
也称之为该对象是可以被迭代的

51:42.400 --> 51:43.700
说了半天绕来绕去

51:43.700 --> 51:44.800
啥意思

51:44.800 --> 51:46.600
就是说如果说一个对象

51:46.600 --> 51:47.100
我们这里

51:48.100 --> 51:48.900
先给我介绍

51:48.900 --> 51:50.400
可迭代协议

51:52.400 --> 51:53.000
TESTIE

51:54.800 --> 51:56.900
如果说一个对象

51:59.940 --> 52:02.040
他满足一些规范

52:02.040 --> 52:04.840
那么这个对象就表示是可迭代的

52:06.440 --> 52:07.240
可迭代的

52:08.140 --> 52:09.640
比方说我们这个OBG

52:10.640 --> 52:12.540
如果一个对象他满足一个规范

52:12.540 --> 52:14.540
那么这个对象就表示可迭代的

52:14.540 --> 52:16.740
或者叫做他满足可迭代协议

52:16.740 --> 52:18.240
都是一个意思

52:18.340 --> 52:21.640
那如果说一个对象是可以迭代的

52:21.640 --> 52:24.440
他就可以放到forOB循环里边

52:24.440 --> 52:26.640
他就可以放到这里边

52:26.640 --> 52:28.440
比方说我们就一个普普通通的对象

52:28.440 --> 52:29.640
就一个普普通通的对象

52:29.640 --> 52:31.640
咱们就把它放到forOB循环里边

52:31.640 --> 52:35.640
你看一下能不能看行不行

52:35.640 --> 52:37.340
保存右键运行出来

52:39.140 --> 52:40.540
就这样子看行不行

52:40.540 --> 52:41.940
右键

52:41.940 --> 52:42.240
检查

52:43.440 --> 52:44.340
你看是不是爆出来了

52:44.340 --> 52:48.040
他说OBG is not suitable

52:48.040 --> 52:50.240
就是这个OBG他是不能被迭代的

52:50.240 --> 52:51.640
不能被迭代的

52:51.640 --> 52:53.140
这些东西其实我们之前都讲过了

52:53.140 --> 52:55.040
所以说这两个是复习

52:55.040 --> 52:56.740
如果你这两个或者是东西

52:56.740 --> 52:58.840
之前音学的非常非常牢固了

52:58.840 --> 53:00.140
ok 往后边看就行了

53:00.140 --> 53:01.640
就不用去复习了

53:01.640 --> 53:03.440
如果说你或者有点晕

53:03.440 --> 53:06.140
或者是觉得你之前没有长得很牢固

53:06.140 --> 53:07.240
或者是又忘了

53:07.240 --> 53:08.940
建议你花点时间看一下

53:08.940 --> 53:11.340
因为对我们后遥血砂卡非常非常重要

53:12.540 --> 53:13.940
那么之前的是不能迭代对吧

53:13.940 --> 53:16.740
因为他不满足可迭代协议

53:16.740 --> 53:18.940
他不满足可迭代协议的约束

53:18.940 --> 53:20.340
那么下面约束是什么呢

53:20.340 --> 53:22.040
可迭代协议

53:22.040 --> 53:25.740
迭代协议的约束如象

53:28.840 --> 53:33.240
对象必须有一个符号属象

53:33.240 --> 53:34.440
什么叫符号属象

53:34.440 --> 53:34.940
就是symbol

53:37.340 --> 53:38.240
symbol

53:38.240 --> 53:39.740
我写对不对

53:39.740 --> 53:40.940
这个单词我经常写错

53:43.140 --> 53:44.240
就是symbol

53:44.240 --> 53:44.640
对了

53:45.640 --> 53:47.640
他必须要一个符号属象

53:47.640 --> 53:49.640
而且这个符号是一个知名符号

53:49.640 --> 53:50.440
什么叫知名符号

53:50.440 --> 53:51.540
就是公共符号

53:51.540 --> 53:52.340
通用的

53:52.340 --> 53:53.840
权局通用的符号

53:53.840 --> 53:56.240
符号的名字叫做atorator

53:56.240 --> 53:57.840
就这个名字

53:57.840 --> 53:59.040
必须要有这个属象

53:59.040 --> 54:00.040
没有这个属象不想

54:00.040 --> 54:01.840
必须要有这个属象

54:01.840 --> 54:04.040
于是如果说这个对象

54:04.040 --> 54:06.140
他要想变成一个可迭代的对象

54:06.140 --> 54:07.040
也就是说这个对象

54:07.040 --> 54:09.440
他要满足可迭代协议的话

54:09.440 --> 54:11.240
那么他就必须要有一个属象

54:11.240 --> 54:15.240
叫做symbolatorator

54:15.240 --> 54:16.040
对吧

54:16.040 --> 54:18.540
当然你不能直接这样的写

54:18.540 --> 54:20.640
这样的写是不满足语法的

54:20.640 --> 54:21.340
这是属性名

54:21.340 --> 54:23.840
属性名怎么叫做symbolatorator

54:23.840 --> 54:25.240
属性名打叫这种属性名

54:25.240 --> 54:26.640
你必须要用属性表达式

54:26.640 --> 54:27.540
用综合化扩起来

54:27.540 --> 54:28.840
表这里面是个表达式

54:28.840 --> 54:32.540
把这个表达式的值作为属性名

54:32.540 --> 54:33.940
他又必须要有这个属性

54:33.940 --> 54:37.540
那么这个属性是一个啥呢

54:37.540 --> 54:38.940
该属性

54:38.940 --> 54:40.040
该属性

54:40.040 --> 54:45.740
必须是一个迭代器创建函数

54:45.740 --> 54:46.340
完了

54:46.340 --> 54:47.240
这就是可迭代协议

54:47.240 --> 54:48.140
没了

54:48.140 --> 54:49.740
没了

54:49.740 --> 54:50.240
该属性

54:50.240 --> 54:51.640
必须是一个可迭代

54:51.640 --> 54:53.040
迭代器创建函数

54:53.040 --> 54:56.040
那迭代器的创建函数

54:56.040 --> 54:56.340
对

54:56.340 --> 54:57.240
还有无参

54:57.240 --> 54:58.440
无参

54:58.440 --> 55:02.140
是一个无参的迭代器创建函数

55:02.140 --> 55:03.140
那迭代器创建函数

55:03.140 --> 55:04.240
我们之前是不是写过很多

55:04.240 --> 55:04.840
对吧

55:04.840 --> 55:06.440
那这个拿过来呗

55:06.440 --> 55:07.440
拿过来

55:07.440 --> 55:10.120
能过来

55:10.120 --> 55:11.220
复制一下

55:11.220 --> 55:12.120
能过来

55:12.120 --> 55:13.720
这边是个迭代器创建函数

55:13.720 --> 55:15.520
只不过它不能有参

55:15.520 --> 55:16.820
不能有参数

55:16.820 --> 55:17.420
那么这里呢

55:17.420 --> 55:18.220
我们偷偷比方说

55:18.220 --> 55:19.520
这里就随便复个字

55:19.520 --> 55:21.120
偷偷为三个

55:21.120 --> 55:22.420
这就是个迭代器

55:22.420 --> 55:23.720
看呗

55:23.720 --> 55:25.620
这是不是个迭代器创建函数

55:25.620 --> 55:26.320
对吧

55:26.320 --> 55:28.320
这是一个迭代器

55:28.320 --> 55:30.720
那么这个OB界满足可迭代协议

55:30.720 --> 55:31.120
对不对

55:31.120 --> 55:33.420
它是不是满足可迭代协议

55:33.420 --> 55:34.320
是满足

55:34.320 --> 55:36.220
是满足可迭代协议

55:36.220 --> 55:39.720
那么它满足可迭代协议

55:40.220 --> 55:42.720
那么这个符号位置

55:42.720 --> 55:44.320
它是一个迭代器创建函数

55:44.320 --> 55:45.620
它返回个迭代器

55:45.620 --> 55:51.720
那么现在我们就认为OB界满足可迭代协议了

55:51.720 --> 55:53.920
并且OB界也可以说

55:53.920 --> 55:57.520
说成是OB界可被迭代

55:57.520 --> 56:00.020
如果说一个对象它可以被迭代

56:00.020 --> 56:02.920
那么它就可以放到forO5循环里边

56:02.920 --> 56:06.520
咱们看一下forO5循环返回什么字

56:06.520 --> 56:08.320
看到没

56:08.320 --> 56:09.920
特色1这个页面

56:09.920 --> 56:11.320
所以返回了三个字

56:11.320 --> 56:12.320
forO5循环

56:12.320 --> 56:13.720
为什么会返回这三个字呢

56:13.720 --> 56:17.020
那么现在要说到forO5循环的原理

56:17.020 --> 56:20.220
forO5循环的原理

56:20.220 --> 56:21.720
它是怎么做的呢

56:21.720 --> 56:22.420
它什么原理呢

56:22.420 --> 56:26.720
就是调用对象的

56:26.720 --> 56:27.620
因为数组也好

56:27.620 --> 56:28.620
map也好set小

56:28.620 --> 56:29.320
是不是都是对象

56:29.320 --> 56:29.820
对吧

56:29.820 --> 56:34.520
调用对象的symbol

56:34.520 --> 56:36.520
symbol

56:36.620 --> 56:38.520
delaterator

56:38.520 --> 56:39.420
方法

56:39.420 --> 56:40.120
对吧

56:40.120 --> 56:42.420
所以说它必须要要求你有这个方法

56:42.420 --> 56:44.620
得到一个迭代器

56:44.620 --> 56:45.120
对吧

56:45.120 --> 56:47.520
这个方法是不是迭代器创建函说

56:47.520 --> 56:48.620
那么它是创建函说

56:48.620 --> 56:50.220
它自然会返回一个迭代器

56:50.220 --> 56:52.120
那么这样它会得到一个迭代器

56:52.120 --> 56:55.120
得到一个迭代器之后呢

56:55.120 --> 56:57.820
一次

56:57.820 --> 57:02.420
不断调用Negas的方法

57:02.520 --> 57:05.820
只要返回的

57:05.820 --> 57:07.720
不

57:07.720 --> 57:09.120
就是当为forst

57:09.120 --> 57:10.020
就是还有东西

57:10.020 --> 57:11.120
当为forst

57:11.120 --> 57:15.220
则进入循环体

57:15.220 --> 57:19.620
则将返回的value

57:19.620 --> 57:21.320
传递给

57:21.320 --> 57:23.020
就是变量

57:23.020 --> 57:25.120
然后进入循环体

57:25.120 --> 57:27.420
执行一次

57:27.420 --> 57:29.120
这就是

57:29.120 --> 57:31.020
for一起循环的执行方式

57:31.020 --> 57:32.220
也就是说它怎么执行呢

57:32.220 --> 57:34.020
它这样子

57:34.020 --> 57:35.920
首先第一步

57:35.920 --> 57:37.520
就是我们来模拟一个forr5循环

57:37.520 --> 57:38.720
还是这样做的

57:38.720 --> 57:40.720
模拟

57:40.720 --> 57:42.820
forr5循环

57:42.820 --> 57:43.820
那么它怎么做的呢

57:43.820 --> 57:46.220
它首先调用这个第一步

57:46.220 --> 57:47.820
调用这个obj的

57:47.820 --> 57:50.920
就是

57:50.920 --> 57:51.620
这个东西

57:51.620 --> 57:52.820
symbol

57:52.820 --> 57:54.120
a-trator

57:54.120 --> 57:56.020
调用这个东西

57:56.020 --> 57:58.320
调用这个obj的symbol

57:58.320 --> 57:59.720
a-trator

57:59.720 --> 58:00.320
调用它

58:00.320 --> 58:01.520
得到一个迭代器

58:01.520 --> 58:03.320
拿到一个迭代器之后

58:03.320 --> 58:05.120
拿到之后

58:05.120 --> 58:06.420
这是个迭代器创建函数

58:06.420 --> 58:07.020
你要用调用它

58:07.020 --> 58:08.420
自然会拿到一个迭代器

58:08.420 --> 58:10.020
迭代器得到之后

58:10.020 --> 58:10.820
干嘛呢

58:10.820 --> 58:12.420
是不是拿到这个next

58:12.420 --> 58:12.620
对吧

58:12.620 --> 58:14.220
拿到这个数据

58:14.220 --> 58:17.220
就是result

58:17.220 --> 58:18.020
调用什么

58:18.020 --> 58:19.820
调用a-trator的next

58:19.820 --> 58:22.220
就跟我们之前的变律是一样的

58:22.220 --> 58:22.520
好

58:22.520 --> 58:23.020
然后

58:23.020 --> 58:24.220
看一下

58:24.220 --> 58:25.320
它里边返回的当

58:25.320 --> 58:26.420
是不是有值

58:26.420 --> 58:27.320
是不是

58:27.320 --> 58:28.620
是不是为forst

58:28.620 --> 58:29.920
如果说为forst的话

58:30.020 --> 58:30.720
表示什么意思呢

58:30.720 --> 58:31.820
表示它有数据

58:31.820 --> 58:32.120
对吧

58:32.120 --> 58:33.120
有数据

58:33.120 --> 58:33.320
好

58:33.320 --> 58:34.720
有数据

58:34.720 --> 58:36.220
那么就进入这个循环体

58:36.220 --> 58:37.820
这个循环体里边不是这句话吗

58:37.820 --> 58:39.020
对不对

58:39.020 --> 58:39.720
有数据呢

58:39.720 --> 58:40.820
它就会干嘛呢

58:40.820 --> 58:41.820
它就会把这个数据

58:41.820 --> 58:43.220
复制给item

58:43.220 --> 58:44.520
复制给item

58:44.520 --> 58:45.120
这个item

58:45.120 --> 58:46.620
就这里

58:46.620 --> 58:48.620
复制给这个item

58:48.620 --> 58:50.420
复制给这个item

58:50.420 --> 58:53.520
item等于什么result.value

58:53.520 --> 58:54.120
对吧

58:54.120 --> 58:55.620
把数据复制给item

58:55.620 --> 58:57.620
然后就运行这句话

58:57.620 --> 58:59.020
运行你的循环体

59:00.020 --> 59:02.620
执行循环体

59:02.620 --> 59:03.620
执行完循环体过后

59:03.620 --> 59:05.220
它就然后又把

59:05.220 --> 59:06.420
又把什么result

59:06.420 --> 59:09.220
又重新复制为

59:09.220 --> 59:10.820
item

59:10.820 --> 59:12.220
item

59:12.220 --> 59:13.520
又复制为下一个

59:13.520 --> 59:15.020
然后又看一下下一个是不是

59:15.020 --> 59:15.820
还有数据呢

59:15.820 --> 59:18.420
还有数据又把这个item拿出来

59:18.420 --> 59:19.020
复制给

59:19.020 --> 59:20.220
value拿出来复制给item

59:20.220 --> 59:21.220
又运行循环体

59:21.220 --> 59:21.720
对吧

59:21.720 --> 59:23.220
这就是for over循环

59:23.220 --> 59:24.820
最终的做法

59:24.820 --> 59:26.420
跟下面一个做法一模一样

59:26.420 --> 59:27.620
一点匹配没有

59:27.620 --> 59:28.820
一点匹配没有

59:29.220 --> 59:30.220
没什么意思

59:30.220 --> 59:31.420
我帮你看一下

59:31.420 --> 59:33.020
它两次都是随机数

59:33.020 --> 59:34.420
两次肯定不一样

59:34.420 --> 59:37.220
但是一点区别都没有

59:37.220 --> 59:37.620
没问题

59:37.620 --> 59:38.820
没问题了吧

59:38.820 --> 59:40.520
没问题了

59:40.520 --> 59:43.120
这就是迭代期

59:43.120 --> 59:46.420
好好看一下

59:46.420 --> 59:49.220
那么这就是可迭代协议

59:49.220 --> 59:50.420
可迭代协议

59:50.420 --> 59:51.420
那么如果说一个对象

59:51.420 --> 59:53.120
它具备了可迭代协议

59:53.120 --> 59:54.520
那么它就自然可以用

59:54.520 --> 59:56.220
for over循环去循环它

59:56.220 --> 59:58.320
那么我们之前学学习的set

59:58.320 --> 59:59.320
map

59:59.320 --> 01:00:00.520
像数组这些东西

01:00:00.520 --> 01:00:02.320
他们都能放到for over循环里面

01:00:02.320 --> 01:00:02.920
对吧

01:00:02.920 --> 01:00:04.220
说明了数组那些东西

01:00:04.220 --> 01:00:06.420
是不是都满足可迭代协议

01:00:06.420 --> 01:00:06.820
那么不行

01:00:06.820 --> 01:00:08.020
我们看一下吧

01:00:08.020 --> 01:00:13.540
我们随便写个数组

01:00:13.540 --> 01:00:14.940
那么这个数组

01:00:14.940 --> 01:00:16.540
它既然可以用for over循环

01:00:16.540 --> 01:00:18.340
那么它一定是满足可迭代协议

01:00:18.340 --> 01:00:19.640
所以说我们可以手动的

01:00:19.640 --> 01:00:21.440
通过symbol

01:00:21.440 --> 01:00:23.040
点ator

01:00:23.040 --> 01:00:24.440
是不是可以拿到它的迭代

01:00:24.440 --> 01:00:25.540
调用这个函数

01:00:25.540 --> 01:00:26.240
对吧

01:00:26.240 --> 01:00:27.940
看一下是不是可以拿到一个迭代期

01:00:27.940 --> 01:00:29.840
ator

01:00:29.840 --> 01:00:33.640
你看一下 next

01:00:33.640 --> 01:00:34.540
你看数组

01:00:34.540 --> 01:00:36.840
它自己给你实现好的迭代期

01:00:36.840 --> 01:00:38.840
看到没

01:00:38.840 --> 01:00:40.440
你看是不是可以拿到

01:00:40.440 --> 01:00:41.640
对吧

01:00:41.640 --> 01:00:43.440
这就是可迭代协议

01:00:43.440 --> 01:00:44.440
说明数组

01:00:44.440 --> 01:00:44.840
map

01:00:44.840 --> 01:00:46.940
set都实现了可迭代协议

01:00:46.940 --> 01:00:47.940
当然我们自己的对象

01:00:47.940 --> 01:00:49.940
要实现可迭代协议也可以实现

01:00:49.940 --> 01:00:51.540
也可以实现

01:00:51.540 --> 01:00:52.340
ok

01:00:52.340 --> 01:00:53.440
这就是关于这些可能

01:00:53.440 --> 01:00:54.740
怎么样附近的东西

01:00:54.740 --> 01:00:55.040
好

01:00:55.040 --> 01:00:56.840
老计这一刻的东西

01:00:56.840 --> 01:00:59.540
老计这一刻的东西

01:00:59.840 --> 01:01:01.440
这是关于

01:01:01.440 --> 01:01:03.140
迭代器以及可迭代协议

01:01:03.140 --> 01:01:04.240
这一刻的设计要代码

01:01:04.240 --> 01:01:05.040
我建议大家了

01:01:05.040 --> 01:01:06.040
如果你觉得有点晕

01:01:06.040 --> 01:01:06.740
有点烧

01:01:06.740 --> 01:01:08.040
那么一定要去写一遍

01:01:08.040 --> 01:01:08.940
加深印象

01:01:08.940 --> 01:01:09.340
不然的话

01:01:09.340 --> 01:01:10.740
后边你新的生存器的话

01:01:10.740 --> 01:01:12.540
你就完全不知道我来说啥了

01:01:12.540 --> 01:01:13.940
好

01:01:13.940 --> 01:01:14.640
这是关于这些

