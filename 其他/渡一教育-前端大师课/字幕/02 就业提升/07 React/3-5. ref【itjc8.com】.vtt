WEBVTT

00:00.820 --> 00:03.380
好 这个属性啊 这个叫REF

00:03.900 --> 00:04.920
REF

00:05.180 --> 00:06.200
这么一个属性

00:06.720 --> 00:08.240
这个东西是怎么玩

00:08.500 --> 00:13.100
是怎么玩啊 首先我们来看它到底要解决一个什么样的问题

00:13.880 --> 00:17.720
举个例子啊 比方说咱们组建里边有这么一个组建啊

00:18.480 --> 00:19.260
新鲜的文件

00:20.280 --> 00:22.060
就随便一个名字吧

00:22.320 --> 00:23.100
有这么一个组建

00:24.120 --> 00:26.420
这个组建是一个内组建啊

00:27.960 --> 00:30.000
这个组建里边有这么一个东西

00:30.320 --> 00:31.780
一个呢是一个文本框

00:32.040 --> 00:33.080
input元素

00:33.580 --> 00:39.980
这个文本框 我很懒得把它变成收控组建了啊 因为我们要说明的问题呢 跟它是不是收控组建

00:40.240 --> 00:41.000
就没有什么关系

00:41.780 --> 00:43.060
这下面有个按钮

00:43.320 --> 00:44.600
就是聚焦

00:45.100 --> 00:45.880
比方说吧

00:46.140 --> 00:46.900
有这么一个按钮

00:47.160 --> 00:50.480
现在呢 我要做这么一件事啊 我先把它打入进来啊

00:51.760 --> 00:53.040
看到界面来讲

00:53.560 --> 00:54.840
comfra

00:58.190 --> 00:59.990
好 这里把这个组建打入进来啊

01:00.970 --> 01:04.640
好 保存啊

01:04.900 --> 01:05.920
看一下啊 看一下这边

01:06.700 --> 01:08.480
现在我们要做这么一件事啊 就说

01:09.000 --> 01:12.080
当我们点这个按钮的时候呢 这个文本框要聚焦

01:13.340 --> 01:13.860
这个是吧

01:14.380 --> 01:15.400
这就是聚焦 对吧

01:15.660 --> 01:17.700
当我们点这个按钮的时候文本框要聚焦

01:18.220 --> 01:19.500
那怎么弄了这个玩意

01:20.520 --> 01:22.820
我当然呢 我肯定要是要给这个

01:23.080 --> 01:27.940
button的注册事件啊 这个毫无疑问的啊 比方说咱们写这么一个事件处理函数

01:28.200 --> 01:28.960
handleclick

01:29.580 --> 01:31.220
啊 有这么个事件处理函数

01:31.480 --> 01:34.540
要给他注册事件啊 那么这个事件呢就是onclick

01:35.580 --> 01:36.580
啊 等于什么呢

01:38.140 --> 01:40.680
就是这个处理函数 handleclick

01:42.700 --> 01:45.260
关键是这个函数里边写啥我就懵逼了

01:45.780 --> 01:46.800
我要干嘛呢

01:47.300 --> 01:51.140
如果不是react的话 那就一切都变得非常非常简单

01:51.400 --> 01:52.940
如果不是react的话怎么做

01:53.200 --> 01:55.500
是不是拿到这个文本框的动物元素啊

01:55.760 --> 01:58.000
动物元素里面不是提供了这么一个什么

01:58.200 --> 02:01.400
啊 focus这个函数吗 对不对 你看吧动物元素里面提供了的

02:01.660 --> 02:04.860
啊比方dom document query is negative

02:05.300 --> 02:06.900
找到这个文本框啊 input

02:07.760 --> 02:08.500
找到这东西

02:08.820 --> 02:10.080
然后呢 把这个dom呢

02:10.340 --> 02:11.260
调用focus

02:11.780 --> 02:14.940
啊 调用这个函数 哎 我这个动物是谁啊

02:17.050 --> 02:18.570
focus 哎 为什么不行呢

02:19.170 --> 02:20.610
dom focus

02:22.130 --> 02:22.610
啊

02:25.590 --> 02:28.230
啊 看一下啊 哎 Google的关系现在不行了吗

02:29.210 --> 02:31.850
哎 我查一下啊 我查一下 Google的关系现在好像

02:32.110 --> 02:33.050
不能调这个函数了吗

02:34.850 --> 02:37.130
啊 我刚才查了一下啊 是这样子的

02:37.650 --> 02:41.490
是这样子的 它是有效的啊 这个dom focus是有效的

02:42.010 --> 02:45.570
只不过呢 看现在为什么看不到效果了 因为现在我们焦点在这

02:46.050 --> 02:49.170
焦点在这个控制台里边 它没有办法把焦点放到页面上

02:49.450 --> 02:52.410
啊 所以说以后呢 我们调的那种它实际上是管用的啊

02:52.650 --> 02:53.370
实际上是管用的

02:53.610 --> 02:56.850
就是说如果这里呢 我们写dom操作了 我就把这句话写过来嘛

02:57.150 --> 02:59.150
啊 比较说 哇 冻

02:59.550 --> 03:03.470
啊 等于什么 document, queries, and input

03:04.510 --> 03:06.270
啊 然后dom呢 就是focus

03:07.150 --> 03:10.390
这样子啊 实际上是有效的啊 保存啊 咱们看一下

03:10.830 --> 03:13.270
聚焦 你看 是不是有效的啊 怎么再来

03:13.830 --> 03:15.430
好 聚焦 你看 是不是有效的

03:16.910 --> 03:20.630
也就是说什么呢 我们就是有的时候呢 可能会

03:21.750 --> 03:23.670
想直接操作动物元素

03:23.990 --> 03:26.830
因为动物元素里边 它毕竟提供了一些方法

03:27.150 --> 03:30.750
啊 非常实用的方法呢 可能会帮我们来解决一些问题

03:31.350 --> 03:36.630
啊 比方说更加不用说什么 etym 5 里边 etym 5 里边不是有什么播放器啊 对吧

03:36.950 --> 03:40.070
让它播放 它暂停 你说你用react 咋做

03:40.830 --> 03:44.110
你怎么根据一个状态来设置它暂停和播放了 没法

03:44.710 --> 03:50.870
因为我们在react 里边呢 它宣然 它只是负责渲染元素啊 渲染这个react元素

03:51.190 --> 03:53.750
这些呢 都是一个一个的对象 一个一个的组件 对吧

03:54.370 --> 03:58.930
那么我们宣然的时候呢 只是给它提供不同的样式 提供不同的不同的属性

03:59.530 --> 04:02.810
但是如果你要调用这些元素的方法 你是不是没法没法

04:03.330 --> 04:04.770
办了 对吧 你办不到了

04:05.450 --> 04:11.890
因此呢 这个ref 呢 它就来解决这个问题啊 这个ref 是什么东西呢 它叫做reference

04:13.010 --> 04:13.650
reference

04:14.690 --> 04:17.850
啊 全程是这个 就是一个引用 他是指的是引用的意思

04:18.330 --> 04:23.570
就是他给了我们一个机会 让我们可以直接引用这个组件对象

04:24.210 --> 04:25.650
可以直接引用这个组件对象

04:26.530 --> 04:32.970
那么它具体怎么用呢 其实你在学view的时候呢 也接触这么个玩意儿 肯定是接触这么个玩意儿

04:33.410 --> 04:35.450
在view 里边是怎么用的呢 他是这样子啊

04:36.090 --> 04:44.090
比较到这里啊 我们直接给他写刚刚ref 就相当于是id 相当于是id 比方说吧 给他取个名字叫做tst

04:46.010 --> 04:50.970
好 接下来呢 我们写了这个东西过后呢 我们点击的时候你看一下啊 咱们就可以获取掉

04:51.390 --> 04:56.910
获取到这个z 你看一下z里边有什么东西啊 当前的对象里边有什么东西 保存啊

04:58.350 --> 05:05.110
点击 点击过后你看z就是一个component对象 对吧 component对象里面 你看是不是就refs

05:05.470 --> 05:05.990
refs

05:06.790 --> 05:11.590
就这么一个属性 这个属性里面呢就包含了一个tst属性对吧 tst属性

05:12.470 --> 05:14.390
这个tst属性哪来的 就在这一则

05:15.370 --> 05:17.050
跟那个view 是不是一样的

05:17.690 --> 05:22.090
对吧 是一样的啊 它就包含了这么一个属性啊 tst 那么这个属性的值呢是什么

05:22.530 --> 05:24.330
就是一个你看这个东西是不是个动物对象

05:25.010 --> 05:26.330
对吧 完全就是个动物对象

05:27.010 --> 05:30.010
所以说这里的用法呢 就很简单了 怎么用呢 就是说

05:30.570 --> 05:32.850
我们这里z是什么refs

05:33.530 --> 05:38.890
refs 叫什么tst 就得到这个文门框对象 就动物对象了啊 这就是真实的动物对象

05:39.410 --> 05:40.690
然后focus就完事了

05:41.690 --> 05:43.970
是不是非常简单的 好 咱们再看一下啊

05:44.450 --> 05:46.690
老师去教练 然后聚焦 你看是就完成了

05:47.250 --> 05:51.410
对吧 那么跟动物元素相关的所有东西我们是不是都可以在这里使用对不对

05:52.010 --> 05:54.410
啊 都会在这里使用 所以说我们这里总结一下啊

05:55.010 --> 05:58.250
refs这个东西呢 通常用的场景是什么了

05:58.890 --> 05:59.370
场景

06:00.970 --> 06:04.650
是希望直接啊

06:05.530 --> 06:06.530
希望直接

06:07.290 --> 06:07.850
使用

06:08.570 --> 06:09.890
啊 动物元素

06:10.570 --> 06:12.650
中的某个方法啊

06:13.430 --> 06:18.390
因此呢 我们要直接使用动物元素 你就弄到某个方法 我们肯定要得到动物元素对吧

06:18.950 --> 06:23.950
或者希望直接使用制定义组件中的

06:25.110 --> 06:25.710
某个方法

06:26.950 --> 06:33.710
啊 这样子也可以啊 这样子也可以 那比方说吧 我们写个制定义组件啊 比方说写个制定组件

06:34.310 --> 06:39.990
嗯 这里边呢 我们除了有这个input之外呢 我们再写个组件吧 再写个组件

06:40.390 --> 06:42.230
比方说class 一个组件 a

06:42.710 --> 06:45.430
啊 这个组件a 那extend啊component

06:47.780 --> 06:51.740
这个组件a没啥用 没啥东西啊 我们这里就选了一个吧 return

06:52.340 --> 06:53.860
h a

06:53.860 --> 06:58.340
啊 组件a 好 组件a里边呢 有一个方法啊 有一个方

06:58.900 --> 07:00.940
有个方法 这个方法呢 叫做

07:03.380 --> 07:06.940
test吧 我又不知道该使用什么样的方法啊 master

07:07.260 --> 07:09.660
啊 master 里边呢 有一个就输出嘛啊

07:10.160 --> 07:10.640
组件

07:11.400 --> 07:12.280
调用了

07:12.880 --> 07:16.680
组件a的方法啊 他调用了这个方法

07:17.280 --> 07:24.400
那么有如果啊 我这里边这个comp里边呢 他要使用了a组件啊 使用了一个a组件 那么a组件的本质是啥

07:24.960 --> 07:27.800
是不是就是这个内的对象啊 他就是这个内的对象

07:29.400 --> 07:36.160
好 于是呢 这个a组件呢 我希望了调用这个对象里边的一个方法就是master的啊 想调用这个方法

07:36.460 --> 07:42.780
那怎么调用啊 我得不到这个组件对象啊 我只能说不停的渲染他对吧 给他不同的属性 给他不同的样式

07:43.060 --> 07:48.260
但是我想要调用他的方法没法调用啊 那要调用他的方法的话 就必须要把那个组件对象拿到

07:48.740 --> 07:50.740
好 ok 那么么就可以使用ref

07:51.900 --> 07:52.460
comp a

07:53.100 --> 08:01.020
啊 比方说我们这样子写 好 这样子写的过后呢 我们都给这一次你看一下他的他这个属性refs啊reference里边

08:01.820 --> 08:05.660
啊 点击过后啊 你看一下reference里边是不是多了一个啊

08:06.380 --> 08:10.020
comp a 里面还是不是还有一个tst对吧 tst和comp a 是不是都有了

08:10.740 --> 08:16.460
而这个tst呢 是不是对应的是什么动物元素对吧 就是一个动物元素 你看呀 指着他就是个动物元素

08:17.020 --> 08:21.220
而comp a呢 这comp a呢 就是一个对象就是a的对象看到没

08:21.900 --> 08:27.300
a的对象里边是不是他就包含了什么啊 method的那个方法在哪里在原型里边

08:27.700 --> 08:29.460
原型里边他多了个 method 看没

08:30.460 --> 08:34.060
哎 所以说我们这里呢就可以通过这个thisreference

08:34.600 --> 08:35.120
第二什么

08:37.000 --> 08:39.880
comp a 第二什么 method

08:41.800 --> 08:43.680
好 保存啊 保存 来看一下吧

08:44.920 --> 08:50.360
啊 点击啊 放小点啊 点击聚焦 你看我们放聚焦了 并且呢 他调用了主键a的方法

08:51.160 --> 08:54.280
看没有 我们就可以通过这种方式呢 来获取主键对象

08:55.360 --> 08:58.360
因此呢 我们这里总结一下啊 就说通过ref了

08:59.000 --> 09:00.480
ref 就是

09:01.460 --> 09:06.620
的几种情况 一个呢 是ref 如果作用于啊 作用于

09:07.220 --> 09:09.660
啊 内置的atm

09:10.260 --> 09:18.900
主键啊 就内置的atm主键就是react 自己写好的atm主键什么div啊 什么he啊 什么bottom啊 这这些主键的时候了 那么

09:19.460 --> 09:20.940
得到的僵势

09:23.580 --> 09:24.900
僵势什么了 僵势那个

09:26.540 --> 09:27.260
真实的

09:27.980 --> 09:28.500
动物对象

09:29.480 --> 09:33.840
啊 如果作用于这的话 他得到的是真实的动物对象 好 第二个啊

09:34.600 --> 09:36.680
如果ref呢 作用于

09:39.080 --> 09:43.760
内内主键 就是我们自己写的主键 得到的僵势

09:44.640 --> 09:46.000
啊 内的实力

09:47.040 --> 09:50.160
就是内的对象 通过这个内创建的对象 因为我们知道一个主键

09:50.560 --> 09:54.400
一个主键的元素他就是一个对象 对吧 一个内的对象 得到的是这个内的对象

09:55.380 --> 09:58.860
那么如果作用于函数主键会怎么样呢 怎么来看一下吧

09:59.460 --> 10:02.980
啊 如果是一个函数主键啊 class b

10:03.820 --> 10:06.260
不是class的啊 就是一个普通的函数主键 b

10:08.460 --> 10:11.860
函数主键呢 我们这里直接返回啊 直接返回

10:12.580 --> 10:15.820
呃 比如说a 主键b

10:16.380 --> 10:18.220
好 我们这里使用这个b啊 b主键

10:18.980 --> 10:20.700
也给这个b主键了一个ref

10:21.300 --> 10:23.660
ref它不是一个属性啊 它不是一个属性

10:24.120 --> 10:27.560
你可以看上去呢 像是一个属性的写法 但是呢 它实际上不是属性

10:27.960 --> 10:30.560
啊 不是属性 为什么不是属性呢 我们看一下它的结构吧

10:31.400 --> 10:34.560
看一下它的结构 这里边我们这个com 这个a

10:34.880 --> 10:39.640
a里边不是刚才传那个ref吗 对吧 ref 属性里面有没有 你看probs里面有没有

10:40.000 --> 10:43.680
他并没有 看到没 他并没有这个属性啊 并没有这个属性

10:44.280 --> 10:49.680
所以说ref呢 你可以认为他是写法上的像是一个属性 但是他并不会传递到一个属性上面

10:50.140 --> 10:56.420
就我们写属性的指的是 定义属性的名称的时候呢 也要尽量避免去定 定跟这个关键值重复

10:57.300 --> 11:02.580
好 比方说这里 我们写com b 好 咱们看一下 这样 这样子会有什么样的结果啊 我们还是输出这次

11:04.060 --> 11:05.500
好 看一下 这里是不是爆错了

11:06.300 --> 11:11.420
他说什么呢 function components 函数主键 他不能给他的什么

11:11.900 --> 11:12.540
ref

11:13.300 --> 11:15.540
ref 他不能给 为什么不能给呢

11:16.360 --> 11:23.120
因为这个函数主键给他没意义 为什么 因为你像ref给他得到的是真实的动物对象 这个没问题

11:23.480 --> 11:28.240
ref给他得到的是这个内的对象 得到的是那个内的实力 对吧 那个对象

11:28.800 --> 11:33.360
那么函数你想得到啥 请问你想得到啥 他能给你得到啥呢

11:34.200 --> 11:40.360
函数主键他有 你把这个函数给你吧 因为什么意义 对吧 给你这个函数有没有什么意义

11:40.640 --> 11:43.200
所以说他觉得函数主键ref是没有意义的

11:43.580 --> 11:46.660
所以说函数主键是不能使用ref的啊 所以大家注意一下

11:49.060 --> 11:50.900
就是说ref

11:51.900 --> 11:55.700
不能作用于函数主键

11:56.340 --> 12:02.980
在函数主键 如果是一个函数主键 你是不能给他ref的 他不能写到函数主键上面

12:06.060 --> 12:12.740
但是你不要搞混淆了啊 千万不要搞混淆了 我说的是ref不能写到这个函数主键上 你看这个b是函数主键

12:12.800 --> 12:19.240
所以说这里不能使用ref 他并不意味着b这个函数主键里边不能写ref啊 这样子是可以写的啊

12:19.880 --> 12:24.680
这个函数主键里边可以写ref 对吧 因为我们就可以得到这个a奇的动物对象啊 这个

12:25.680 --> 12:28.520
那么当然这里面了 他只能在这里边使用啊 外面用不了

12:29.440 --> 12:38.240
是这么个意思啊 我说我就你ref写的位置 他必须是一个内主键 或者是一个内置的一天门主键 他不能是函数主键

12:39.220 --> 12:40.300
ok啊 说一下这个

12:41.420 --> 12:42.140
好 这是关于

12:43.060 --> 12:44.060
好 这里就

12:44.860 --> 12:49.540
我这里 把这个注释掉了啊 这这一部分 好 把复制一下啊

12:50.940 --> 12:54.780
好 接下来我要说一个问题就是说 现在呢 实际上有这么一个情况

12:55.180 --> 13:00.460
就是说这个制服串呢 我们刚才用的是制服串啊 ref复制的是一个制服串 你看

13:01.060 --> 13:05.380
ref复制的是一个制服串 这种做法已经过时了啊 已经过时了

13:06.120 --> 13:11.080
ref不再推荐使用制服串复制

13:13.680 --> 13:16.960
制服串复制的方式 将来

13:18.400 --> 13:20.000
可能会被移除

13:21.040 --> 13:21.680
会被移除

13:24.170 --> 13:28.970
主要的原因呢 他是考虑到效率问题 那么为什么会有效率问题呢

13:29.890 --> 13:34.050
这跟那个ref底层原理有关了 咱们以后讲原码的时候再说

13:34.670 --> 13:40.430
现在呢 你知道啊 他有效率问题就行了 有严重的效率问题 而且呢不够灵活

13:40.950 --> 13:47.990
那么为什么他不够灵活呢 我们之后呢 看了新的方式之后呢 你就会知道啊 新的方式要灵活的多 虽然写上来

13:48.270 --> 13:53.830
写上去了 不像以前那么好写了 但是呢 确实要非常灵活 灵活一些

13:54.590 --> 13:59.110
因此呢 现在呢 目前ref推荐使用

13:59.870 --> 14:01.070
对象啊

14:01.930 --> 14:02.890
或者是

14:03.530 --> 14:03.970
函数

14:05.090 --> 14:06.450
给ref复制的时候

14:07.170 --> 14:09.770
就这里 给他复制的时候呢 要复制一个对象

14:10.370 --> 14:14.970
或者是一个函数 咱们挨在再来说 首先第一个啊 对象

14:15.850 --> 14:19.570
这个对象哪来的啊 这个对象哪来的 这个对象来自于

14:21.010 --> 14:24.010
就通过啊 应该这样说啊 通过react

14:24.570 --> 14:26.330
create ref创建

14:27.310 --> 14:33.190
通过这个函数来创建 就是你不是自己写的对象啊 是直接通过这个create ref函数创建

14:34.990 --> 14:40.590
当然以后我们可以看到 实际上你自己写的对象也行 他也行 好 那么这个我们看一下怎么来做

14:42.070 --> 14:48.630
现在我们刚才把之前的copy出去了啊 现在我们这里再回到这 还是实现同样的同样的一个功能

14:49.270 --> 14:53.950
我现在不考虑什么类组件了 总之我们把得到就行了 类组件的得到方式呢 跟这个

14:54.930 --> 14:57.690
类似的atm元素呢 是一样的 都没什么好说的

14:58.570 --> 15:09.410
好 现在呢 我们不再使用对象了 不再使用那个制服串了 要使用对象 这个对象哪来的呢 我们一般的一般情况下呢 会直接在构造函数里面创建好

15:10.250 --> 15:11.250
把这个对象创建好

15:12.090 --> 15:12.450
super

15:13.530 --> 15:20.490
为了避免每一次render的时候都重新去创建对象 为了避免这一点 所以说呢 我们一般是给他先创建好

15:21.270 --> 15:27.630
这个对象呢 我们 比方说把它放到z里边吧 因为它是类组件嘛 对吧 我们可以把它放到z里边 保存起来

15:28.630 --> 15:30.270
给他取个名字叫做txt

15:30.750 --> 15:31.070
txt

15:31.990 --> 15:32.470
放到这个

15:33.190 --> 15:37.550
当前这个组件的属性里面啊 txt 啊 给他复制 怎么复制呢

15:38.350 --> 15:38.830
通过

15:39.870 --> 15:41.830
rayx create

15:42.310 --> 15:42.990
ref

15:43.630 --> 15:47.310
来进行复制 他这个东西没有参数啊 没有参数就这么简单就完了

15:48.310 --> 15:48.790
就复制了

15:49.290 --> 15:54.090
产生一个什么东西呢 产生的就是一个对象 咱们来输出一下吧 zst

15:55.090 --> 15:59.330
输出一下 保存看一下啊 他常常就是一个对象 这个对象怎简单

16:00.450 --> 16:03.410
没有啥东西 就是一个有一个属性叫corrent

16:04.090 --> 16:09.570
这个corrent属性呢 他目前是now啊 一开始在构造函数里边的时候是now对吧

16:10.330 --> 16:15.170
好 什么时候复制呢 他到时候会给这个corrent复制 什么时候复制呢

16:15.830 --> 16:21.550
当第一次轩了这个组件的时候 他就会给这个r这个corrent给他复制

16:22.350 --> 16:28.250
好 怎么复制呢 他就这样子复制的 这样子复制的就是 zs

16:29.210 --> 16:35.850
txt 也把这个ref 创建的这个ref对象 你看现在ref要给个对象了啊 不再是给个制服创了

16:36.170 --> 16:38.850
你把这个对象给他 他什么时候完成复制

16:40.050 --> 16:44.650
他就在render的时候给他完成复制啊 render的时候就完成复制

16:45.450 --> 16:46.490
好 看一下吧

16:47.530 --> 16:54.010
好 现在没有值对吧 但是我们一展开的时候 你看现在已经渲染完了 渲染完了过后一展开的时候啊 因为这个

16:54.570 --> 17:00.930
控制台这里呢 是实时更新的啊 所以说你这里渲染完了过后你这里闪开重新计算 一计算出来你看

17:01.330 --> 17:01.850
所以复制了

17:02.650 --> 17:05.530
对不对 就复制了 那么corrent他的值是什么

17:06.090 --> 17:12.330
他这个对象里边那个属性correntcorrent这个值的是什么 就是一个真实多么元素 那跟我们之前讲的是一致的

17:13.070 --> 17:19.430
之前讲的是什么 就是那个来自于啊 就是如果是内置的主件 得到了就是真实的多么对象

17:19.950 --> 17:25.150
如果是内主件的话 得到了将是内的实力 跟之前的情况是不是一样的了

17:26.550 --> 17:29.590
对不对 就是一样了啊 所以说我们现在呢

17:30.350 --> 17:34.870
那么我们现在看 那这里边还有吗 看一下这里边还有吗 点击一下啊

17:36.230 --> 17:41.990
你看现在直接爆错了啊 他说根本就找不到啊 从ond范里面找不到 我们看一下现在还有没有ref是

17:42.470 --> 17:48.830
是没有了 有这个东西的现在也不再用了啊 因为这个东西是对应到以前用制服串的那种方式

17:49.670 --> 17:51.950
所以说现在不再用制服串了 说这个东西没用了

17:52.510 --> 17:56.230
那么现在我们该怎么来得到这个闻闷框啊 我们应该用这种方式来得到

17:56.830 --> 18:02.430
你看我们之前不就不已经拿到了吗 对吧 保存到这儿的 那么直接通过这个t里边的什么

18:02.870 --> 18:06.310
corrent啊 直接通过这个 是不是可以得到这个闻闷框

18:07.230 --> 18:08.630
哎 保存看一下吧

18:09.010 --> 18:13.730
啊 啊 点击啊 你看

18:14.650 --> 18:21.250
点击 你看 是不是仍然可以得到一样的效果 因此呢 我们现在的那个真实的动物元素存在哪的 都存在这儿的

18:22.250 --> 18:22.490
对不对

18:23.610 --> 18:25.250
好 就完事了啊 就完事了

18:26.170 --> 18:33.970
这就是用对象的方式啊 创建一个对象 但是如果你不用这种方式创建也可以 直接该写个对象里面只要包含一个corrent属性就完事了

18:34.430 --> 18:37.150
啊 这样子也可以 也可以我们把这个打印出来嘛

18:37.830 --> 18:42.310
this log this.tft.corrent 打印出来就知道了

18:43.230 --> 18:44.430
保存啊 看一下啊

18:46.840 --> 18:52.480
点击聚焦 你看是一样的 对吧 一样的 就他那个函数很简单啊 他这个函数我们自己都可以写

18:52.840 --> 18:56.240
他就是给你返回一个这个东西 一个这么一种对象结构 其他就没啥了

18:56.600 --> 19:00.120
这是一种 他他自行约定好的一种标准的对象结构

19:01.120 --> 19:02.360
可能有些同学想问啊 就说

19:02.780 --> 19:08.340
为什么你这里呢 他要去用这种方式来处理

19:08.980 --> 19:10.900
他为什么不直接给这个对象负责就完事了

19:11.740 --> 19:17.100
啊 他是考虑到就是效率的问题啊 还是考虑到效率问题 他要保持这个对象不变

19:17.940 --> 19:22.060
他要保持这个对象不变 只更新这个对象里边的引用啊 里边的这个属性

19:22.940 --> 19:25.860
他是要考虑到效率问题的啊 我们后边讲原码的时候再详细分析

19:27.180 --> 19:31.460
好 这是这一块啊 也就是这个地方呢 我们可以用那个什么用reacts啊

19:32.420 --> 19:35.980
用这种方式也可以自己写个对象都行 只要对象结构是一样子就行了

19:36.500 --> 19:39.500
我们的最终在渲染的时候呢 他就会给这个ref

19:40.220 --> 19:44.540
给这个对象里边的属性负责啊 在渲染的时候他就会给这个对象的属性负责

19:45.060 --> 19:50.020
负责的他就会给他里面属性corrent负责 负责到什么责呢 就来自于这里的规则

19:51.100 --> 19:54.660
该是内的实力就是内的实力该是真实的动物对象就是真实的动物对象

19:55.180 --> 20:01.060
那以后呢 我们要拿我们ref的动物对象就可以通过啊 这个corrent的属性拿到了

20:02.040 --> 20:04.080
好 这是第1种方式啊 第1种方式

20:04.800 --> 20:06.800
另外一种方式呢 是寒树

20:08.960 --> 20:14.440
使用使用那个寒 寒树的方式啊 我们看一下另外一种方式 寒树

20:16.720 --> 20:22.160
寒树呢 就是啊呀 这里不好解释啊 直接直接来 我正在复制一次

20:24.760 --> 20:28.280
好 这边呢 我们就这样子写 我们这里能写一个寒树

20:29.400 --> 20:33.520
写个寒树 或者说我们这里都难得写寒树了啊 都难得写这个东西了

20:33.900 --> 20:38.100
直接在这里写ref这里 直接写个写个写个寒树

20:39.620 --> 20:40.260
直接写个寒树

20:42.980 --> 20:47.180
好 这个寒树里边呢 他有一个参数 他会自动传给你 什么参数呢

20:47.860 --> 20:53.940
这个参数是什么呢 我先说一下这个寒树 先不管什么时候调用啊 先不管他什么时候调用这个寒树

20:54.220 --> 20:58.180
那么这个寒树呢 他首先有个参数 这个参数是什么呢 这个参数

20:58.720 --> 21:00.720
就是这里的规则

21:01.640 --> 21:07.440
如果你是内置的itm组建 那么就是真实的动作对象 如果你作用的是内组建的 得到的就是内的实力

21:07.960 --> 21:13.320
总之这个参数就是这个东西 他把这个参数传给你 你爱干嘛干嘛 属于一边的干嘛

21:14.000 --> 21:15.800
那么我就可以把这个参数是不是给这个

21:16.560 --> 21:20.320
当前对象的属性负责 对吧 比方说t t等于e l

21:21.160 --> 21:27.200
我就可以把这个东西给我 随便找个属性嘛 加一个属性嘛行不行 对不对 我给他属性负责

21:27.700 --> 21:31.340
给我自己的属性负责 好 负完这个后一个属性是不是有质了

21:32.420 --> 21:35.580
哎 他他会去在适当的时机会去调用这个寒树

21:36.500 --> 21:41.900
这是用寒树的写法 保存咱们看一下啊 看一下 这里呢 我们点击

21:42.860 --> 21:44.540
聚焦 哎 抱错了

21:45.580 --> 21:52.660
他说什么 哦 这里不再不再使用current了啊 不再使用current了 为什么 因为直接你看这个东西 直接就是他的对象了

21:53.180 --> 21:56.500
直接就是对应到这了 这了 对不对 直接就是个对象了

21:57.300 --> 22:00.500
好 我们这里很聚焦 点击聚焦 你看是一样的效果

22:01.380 --> 22:02.940
啊 这是用寒树的模式

22:03.940 --> 22:06.500
好 寒 那么现在关键问题是这个寒树什么时候调用的

22:07.780 --> 22:13.000
咱们来看一下吧 我们这里 这个寒树里边啊

22:14.200 --> 22:14.720
我们输出

22:16.120 --> 22:17.720
寒树被调用了

22:19.000 --> 22:19.680
看一下这个寒树

22:20.800 --> 22:28.320
保存 目前的只调用了一次 对不对 目前只调用了一次 那么我们现在呢 为了看到效果呢

22:28.380 --> 22:32.660
我们在每一次点击过后啊 点击过后呢 强势让他重新刷新一次

22:33.460 --> 22:34.460
强势让他重新刷新

22:35.580 --> 22:35.900
保存

22:36.620 --> 22:37.020
好 看一下

22:37.980 --> 22:42.740
目前第一开始调用了一次 因为一开始要渲染嘛 在渲染的时候他就会调用这个寒树

22:43.340 --> 22:47.100
啊 一开始渲染的时候就会调用这个寒树 然后我们点击的时候 你看

22:47.620 --> 22:49.820
他又调用了 而且还调用了两次

22:50.540 --> 22:51.380
这是怎么回事了

22:52.740 --> 22:56.180
那么我这里要说一下啊 这个寒树是什么时候调用的

22:57.160 --> 22:58.960
这里呢 咱们把它记录一下

22:59.960 --> 23:01.360
就是寒树的调用时间

23:02.160 --> 23:05.920
他是怎么 他是怎么来处理这个问题的啊 寒树的调用时间

23:07.560 --> 23:09.240
首先第一个 就是

23:09.800 --> 23:14.080
组件挂载完成之后啊 就是component

23:15.160 --> 23:15.640
地的

23:16.760 --> 23:18.080
mount的时候

23:19.440 --> 23:20.560
地的mount的时候

23:21.760 --> 23:22.240
会

23:22.920 --> 23:24.360
调用该寒树

23:25.140 --> 23:26.020
也就是说

23:26.280 --> 23:29.580
说明什么呢 我们在component地的mount这个

23:29.820 --> 23:34.300
钩子寒树里边 就已经可以使用是吧 就已经可以使用那个

23:35.580 --> 23:38.900
就是这个txt了 就已经可以使用了 因为这个寒树已经调用了

23:39.420 --> 23:41.980
好 比方说咱们component地的mount

23:44.020 --> 23:45.820
component地的mount

23:46.080 --> 23:48.620
这一句一听啊 很多校成里面都没有说到这个问题

23:49.660 --> 23:50.680
就是

23:51.460 --> 23:53.240
可以使用

23:53.500 --> 23:54.260
就是

23:54.820 --> 23:56.380
地的mount

23:57.140 --> 23:58.660
然后这里我们打印出txt

23:59.700 --> 24:00.700
看一下 保存

24:02.500 --> 24:06.100
你看一下 是不是在地的mount的时候 是不是已经可以使用它了

24:06.340 --> 24:09.660
所以说 当我们挂载完成的这个生命周期事件里边

24:09.940 --> 24:11.980
咱们就可以使用这个东西的 大胆的用

24:12.740 --> 24:14.540
但是在这个事件之前 是不是不能使用

24:15.300 --> 24:19.260
对吧 在这个事件之前是不能使用的啊 是不能使用这个txt的

24:19.500 --> 24:21.180
比方说在构造寒树里边能不能使用这个东西

24:21.640 --> 24:26.000
它还没有挂载出来 还没有挂载完成 所以说这个寒树还没有调用

24:26.260 --> 24:28.040
所以构造寒树里边是不能使用的啊

24:28.560 --> 24:29.840
这里说一下啊

24:30.360 --> 24:30.860
就是说

24:31.360 --> 24:31.880
在

24:33.920 --> 24:34.440
在

24:36.580 --> 24:37.100
这里

24:37.360 --> 24:38.640
在这个事件中

24:39.920 --> 24:41.460
可以使用

24:41.720 --> 24:43.020
可以使用那个

24:44.280 --> 24:48.620
在这里面可以使用那个引用得到这个动物元素 是没问题的

24:49.140 --> 24:50.420
好 这是第一个时间点

24:51.180 --> 24:52.460
好 接下来是这么回事

24:53.540 --> 24:56.100
实际上接下来的时间点了

24:56.360 --> 24:59.680
它本来是不会调用了 但是它有这么一个规则

25:00.180 --> 25:01.180
如果

25:03.020 --> 25:05.300
如果阿爷夫的职

25:05.820 --> 25:07.300
发生了变动

25:08.380 --> 25:09.660
如果他的职发生了变动

25:09.920 --> 25:14.540
也就是说他之前是一个寒树 对吧 现在又给他重新复制了一个新的寒树

25:14.980 --> 25:15.820
那么这个时候

25:16.820 --> 25:19.140
写完怎么啊 就旧的寒树

25:19.900 --> 25:22.460
被新的寒树替代

25:23.460 --> 25:24.900
那么这个时候该怎么做呢

25:25.160 --> 25:25.580
他会

25:25.840 --> 25:26.600
调用

25:26.860 --> 25:28.660
分别调用

25:29.420 --> 25:30.960
旧的寒树

25:31.220 --> 25:31.980
以及

25:32.500 --> 25:33.260
新的寒树

25:33.780 --> 25:36.340
他会分别调用 调用的时间点在什么地方呢

25:36.600 --> 25:37.620
时间点

25:38.140 --> 25:39.660
出现在

25:39.920 --> 25:40.420
地的

25:41.200 --> 25:41.700
update

25:41.960 --> 25:43.500
应该说component

25:44.780 --> 25:45.540
component

25:45.800 --> 25:47.100
地的update

25:47.340 --> 25:47.860
之前

25:48.120 --> 25:49.660
时间点出现在这个之前

25:50.160 --> 25:52.460
他会调用两次寒树

25:52.860 --> 25:54.820
这就是为什么我们这里看到了

25:55.080 --> 25:59.420
点击过后由于重新宣展了对吧 重新宣展过后还有两次输出

25:59.680 --> 26:01.220
为什么会有两次输出呢

26:01.480 --> 26:02.500
是因为这里呢

26:02.760 --> 26:05.060
你看一下每一次宣展是不是给他一个新的寒树

26:05.320 --> 26:08.380
你看这里一个箭头寒树 每次是创建了一个新的寒树给他

26:08.640 --> 26:10.420
那么他会把旧的寒树调用一次

26:10.680 --> 26:12.480
然后再把新的寒树调用一次

26:12.740 --> 26:13.760
如果我在这里呢

26:14.020 --> 26:15.040
再打印出这个东西

26:15.540 --> 26:16.580
再打印出这个EL

26:16.840 --> 26:18.120
你会发现一个神奇的现象

26:18.380 --> 26:20.160
打印出这个EL 我们看一下吧

26:20.920 --> 26:21.440
保存

26:21.640 --> 26:24.060
一开始没问题对吧 一开始给了他一个动物元素

26:24.320 --> 26:27.280
点聚焦的时候你看一次是鸟 一次是这个

26:28.040 --> 26:29.320
那么他鸟是什么意思呢

26:29.580 --> 26:30.600
指的是

26:30.860 --> 26:32.400
旧的寒树

26:33.680 --> 26:36.240
旧的寒树被调用时

26:37.520 --> 26:38.280
传递鸟

26:39.560 --> 26:42.380
新的寒树被调用时

26:42.640 --> 26:43.920
传递

26:44.180 --> 26:45.200
对象

26:45.460 --> 26:48.260
有可能是真实的动物对象 有可能是内的实力

26:48.520 --> 26:50.740
这个不说了 这个对象是什么东西 前面说过了

26:50.940 --> 26:51.460
就这个东西

26:52.620 --> 26:54.580
你看这个是吧 所以说你给他寒

26:54.820 --> 26:56.060
给他寒树的时候呢

26:57.600 --> 26:59.400
你如果用这种方式写

26:59.660 --> 27:00.680
如果你这种方式写

27:00.940 --> 27:03.240
他每一次重新变两都在替代

27:03.500 --> 27:04.780
都在替代这个RIFT

27:05.040 --> 27:06.300
这个RIFT都是新的值

27:06.560 --> 27:08.600
尽管这个寒树长得一模一样 但是

27:08.860 --> 27:11.680
因为每一次新建一个寒树 相当于就是新的对象了

27:11.940 --> 27:14.240
所以说每一次他都会调用一下这个寒树

27:14.500 --> 27:16.540
旧的寒树调用一次 新的寒树调用一次

27:16.800 --> 27:18.340
旧的寒树里边要给他传一个鸟

27:18.600 --> 27:20.380
新的寒树里边要给他传一个正常的执行来

27:20.940 --> 27:22.740
他是做了这么一个处理

27:24.020 --> 27:27.340
好 那么如果你不希望有这种现象发生

27:27.600 --> 27:28.620
你就想

27:28.880 --> 27:30.420
当然有的时候

27:30.680 --> 27:32.980
有的时候我们可能希望这种事情发生

27:33.240 --> 27:36.560
因为有的时候我们可能在这里边不一定是给什么属性负责

27:36.820 --> 27:38.100
而是要做一些事情

27:38.360 --> 27:39.640
每次渲染的时候呢

27:39.900 --> 27:41.180
每次渲染的时候呢

27:41.420 --> 27:44.760
他这个RIFT发生变动过后了 我们都要做一些事情有的时候

27:45.020 --> 27:46.800
但这种情况比较稍微少一点

27:47.060 --> 27:49.360
更多的时候呢我们是

27:49.580 --> 27:51.180
就是把他引用保存下来

27:51.440 --> 27:54.680
如果你希望做这种操作的话 那我建议你不要用这种方式来写

27:54.940 --> 27:56.740
用什么方式呢 把它换成这种方式

27:57.000 --> 27:58.780
把它写成一个对象的实力

27:59.040 --> 28:00.580
把它写成个实力方法

28:01.340 --> 28:01.860
就是

28:03.400 --> 28:05.180
GETRIF

28:05.440 --> 28:05.960
比方说吧

28:06.720 --> 28:07.740
写成这么一个实力方法

28:08.000 --> 28:10.970
然后呢这里

28:12.770 --> 28:13.530
放过来

28:13.790 --> 28:17.630
那么我们这里给他啥呢 就给他Z加GETRIF

28:17.890 --> 28:19.410
那你看一下这样子就不一样了

28:19.630 --> 28:21.830
那么每一次给他的函数是不是同一个函数

28:22.090 --> 28:22.430
对吧

28:22.690 --> 28:27.550
既然是同一个函数 那么他只在什么地的mount的时候调用一下 那么后边就不会调用了

28:28.830 --> 28:31.910
当然他还会有一次要调用就是

28:32.170 --> 28:34.970
当这个组件卸载的时候还会调用啊 这个都不说了

28:35.230 --> 28:38.570
好 这里呢 我们看一下 点击聚焦 你看是不是没有重复调用了

28:38.830 --> 28:41.630
因为他没有必要重新更新了啊 因为他认为啊

28:41.890 --> 28:43.890
你如果把这个东西提出来写

28:44.150 --> 28:44.970
提到外面去写

28:45.230 --> 28:48.290
那么说明了你往往就是来保存一下他的引用

28:48.670 --> 28:53.070
而很多时候我们都是这样做的 对吧 来保存一下他的引用 那么这种情况下呢

28:53.750 --> 28:58.470
这个引用他始终指向的是真实的动物对象 这个真实动物对象又没有没有变化

28:59.110 --> 29:03.390
对不对 又没有变化 除非一个动物对象被干掉了 否则的话没有变化

29:04.470 --> 29:06.150
因此这个函数他只会调用一次

29:06.950 --> 29:10.710
当然如果个组件不存在了 不存在了的话 那么他会调用一次

29:11.630 --> 29:13.510
好 这就是这种 这种方式

29:14.390 --> 29:15.910
好 后面说一下吧 说一下

29:16.650 --> 29:20.970
如果组件被卸载 如果阿爷夫所在的组件

29:22.690 --> 29:24.010
组件被卸载

29:25.810 --> 29:31.730
会调用干函数 调用函数 那么举个例子啊 还是举个例子 这里呢

29:32.770 --> 29:37.330
我们就要写判断了啊 要写判断了 我们这里看一下啊

29:38.370 --> 29:39.970
写个几个状态吗 写个状态

29:40.430 --> 29:40.930
State

29:42.470 --> 29:44.430
一个状态 修回修

29:45.230 --> 29:48.910
那么他当然有可能会变成force 什么时候为force呢 点击过后了

29:49.270 --> 29:52.990
我就不聚焦了啊 就不聚焦了 不聚焦了 然后把它设为force

29:55.390 --> 29:59.350
点击过后把隐藏 就不是把卸载调了吗 对不对 卸载调了啊

29:59.830 --> 30:01.670
那么把它这样子吧 取犯

30:02.070 --> 30:03.990
State 修 而取犯

30:05.190 --> 30:05.790
显示隐藏

30:06.910 --> 30:07.430
显示

30:08.350 --> 30:08.750
隐藏

30:09.730 --> 30:12.650
好 这里边呢 我们这样子写 这样子写

30:15.790 --> 30:17.590
这里 我们就直接用个三目云刷符嘛

30:19.590 --> 30:20.190
Z

30:20.630 --> 30:21.350
State

30:21.670 --> 30:22.190
修

30:23.190 --> 30:24.070
如果它为真

30:24.990 --> 30:27.030
如果它为真的话 我们就显示这个东西

30:27.590 --> 30:28.830
否则的话就啥都不显示

30:29.710 --> 30:33.190
就这样子写 这也是一种在react里边的一种常见写法

30:33.430 --> 30:37.430
如果它为真就做这么一件事 就显示得到这个东西 否则的话就什么都不写

30:37.950 --> 30:39.230
好 保存啊 看一下

30:40.910 --> 30:41.550
显示隐藏

30:42.070 --> 30:44.950
你看 是不是韩束被调用了 他传来个闹进来 对不对

30:45.710 --> 30:50.510
好 然后再显示 所以又被调用了 对不对 这个组件 这个组件有 就是这个组件

30:51.550 --> 30:55.910
跟真摄动物是一样的 只要真摄动物变了 那么它一定会调用这个韩束

30:56.270 --> 31:02.670
只要真摄动物它没变 它就不会调用这个韩束 那么对于内组件而言 只要那个内对象消失了 它就会调用一次

31:03.030 --> 31:04.470
对于对象还在 它就不会调用

31:04.990 --> 31:07.550
啊 当然这这个前提条件啊 是我们把这个

31:08.010 --> 31:12.770
韩束 回掉韩束 写外面了 如果写里边的话 是每次肯定要调用的 而且要调用两次

31:14.050 --> 31:16.530
好 这是关于这么一块东西啊

31:18.170 --> 31:19.770
这是关于这个Riv

31:20.410 --> 31:27.490
这个Riv呢 主要的目的呢 就是为了让我们可以得到啊 得到一个多目对象的引用 很多时候都是这样子

31:28.170 --> 31:33.810
有的时候呢 我们做了一个内主线出来了 我们可能要得到一个内的对象的引用 可能要调用它的方法

31:34.430 --> 31:38.350
但是呢 我们平时真正的开发的时候呢 要谨慎的使用

31:40.230 --> 31:40.830
谨慎

31:41.910 --> 31:48.310
谨慎使用Riv 为什么要谨慎使用Riv呢 因为Riv呢 实际上是一个种反模式

31:48.950 --> 31:51.230
你看rex 它给你搞了这么多东西出来

31:52.190 --> 31:56.270
它无非就是让你渲染UI界面的 要根据数据来渲染

31:56.710 --> 32:02.270
而不要去直接操作UI界面 我们的UI界面的变化是根据数据而变化的

32:02.730 --> 32:07.650
最好就是使用什么 属性啊 使用状态啊 这些来控制UI界面的变化

32:08.170 --> 32:14.010
而不应该是直接去操控 那么有了这个Riv过后呢 我们就有了机会可以直接操控了

32:14.330 --> 32:18.010
但是这样做呢 是根据rex的理念 哲学理念是不符的

32:18.810 --> 32:25.850
因此它又不能把它干掉 又不能把它这个RF去掉 因为有的时候确实需要这么干 比方说刚才说聚焦

32:26.470 --> 32:31.630
对吧 聚焦这个点确实需要这么干 所以说呢 它还是保留了这个东西

32:32.470 --> 32:36.710
只不过呢 我们在用的时候呢 谨慎使用 能够啊 就是能够

32:37.950 --> 32:41.870
使用属性和状态进行控制

32:43.590 --> 32:46.590
就不要使用啊 就不要使用

32:47.910 --> 32:48.310
不要

32:49.750 --> 32:53.870
使用Riv 不要认为发现了Riv就好像发现一个新大陆一样

32:54.290 --> 32:57.170
干什么都像直接去操控了 那你跟以前的那个

32:57.770 --> 33:03.450
你写那个最基础那个动对象的时候就原生界式的时候有啥区别呢 要说有啥区别

33:04.570 --> 33:08.410
所以说就没啥区别了啊 那就还用用什么rex呢 你不要用rex了

33:09.250 --> 33:15.210
所以说他你不推荐你啊 到处去使用Riv 我们平时使用Riv呢 往往就是这么一些场景啊

33:15.690 --> 33:18.810
就是第一个要调用真实的

33:19.890 --> 33:21.010
动对象中的

33:22.210 --> 33:23.450
动对象中的方法

33:24.090 --> 33:28.650
比方说刚才focus 比方说以后atm5里面的什么要做那个是

33:29.330 --> 33:30.650
atm5里面要做那个

33:33.290 --> 33:33.450
嗯

33:33.810 --> 33:38.850
播放器啊 播放器 播放器要用界式来控制啊 再调用动物对象里面的方法来控制他的播放

33:39.410 --> 33:44.250
或者说要用cameras啊 画布来进行绘画 对吧 这些都要操作真实的动物

33:45.010 --> 33:47.890
所以这个时候呢 我们可以使用Riv

33:48.850 --> 33:52.770
要调用真实动物对象里面方法 因为rex跟我们提供的 并不是真实的动物

33:53.510 --> 33:57.270
那你要做的功能呢 要跟真实的动物相关

33:57.910 --> 34:00.910
他的方法在真实的动物里面 那么这个时候要去使用Riv

34:01.670 --> 34:02.470
第二个呢 就是

34:04.510 --> 34:08.110
需要啊 需要某个时候

34:09.190 --> 34:09.550
时候

34:10.550 --> 34:14.070
需要调用啊 内组件的方法

34:15.790 --> 34:21.510
比方说啊 我们写了个内组件 内组件里面提供了一些方法 他并不知道这些方法在什么时候调用

34:22.010 --> 34:26.850
这个内组件是不知道的 这一方法呢 也不好使用属性啊 使用状态来控制

34:27.490 --> 34:31.210
比方说 你们以前学过那个view view里面不是有一个

34:32.370 --> 34:38.850
view里面不是有这么个东西吗 叫做animate UI啊 我们不知道你之前学的是animate UI还是I view啊

34:39.330 --> 34:42.090
啊 都差不多啊 他里面不是有个这个东西吗

34:42.730 --> 34:48.250
不是有个表单组件吗 对吧 表单组件 而表单组件里面不是有验证吗 对不对

34:48.710 --> 34:52.950
有的时候呢 我们希望发生了一件事起过后 你表单整体验证一下

34:54.270 --> 34:56.750
这个时候发生了一件事 你要说能

34:57.270 --> 35:03.670
一说说这个表单组件里面能够通过属性和状态来控制 他在触发验证吗 好像也不太容易

35:04.630 --> 35:09.590
他于是呢 他就给你提供了一个方法 让你通过这个调用这个方法来触发他的验证

35:11.110 --> 35:16.710
就是有的时候呢 我们可能会遇到类似的这种情况啊 我们要使用Riv 总之呢Riv呢

35:17.130 --> 35:25.370
他不一定是个好东西 他必须要有 但是他不是个好东西 他是反模式啊 他跟这个rex的设计理念是不一致的

35:26.050 --> 35:29.730
但是有的时候确实没办法 我不知道万不得已啊 不要去使用Riv

35:30.690 --> 35:35.610
好 下期课呢 我们当然还是会举一个例子啊 做一个小的demo来练习一下这个Riv的使用

35:35.850 --> 35:42.810
就是咱们这个课呢 讲课的时候呢 主要讲他的支持点 啊 支持点讲完了过后呢 再去讲他的一些

35:43.790 --> 35:50.190
使用啊 一些例子 而且这个Riv呢 我们现在还没有讲完啊 还没有讲完 还有个转发这一副

35:50.710 --> 35:54.550
Riv我们换一个课来讲 好吧 这是Riv的基本人支持

