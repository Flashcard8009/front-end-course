WEBVTT

00:00.000 --> 00:10.240
接着上一个 上节课 咱们呢 这节课呢 是一个扩展课程 你们懂得啊 咱们来熟写这么一个就是

00:11.360 --> 00:14.640
熟写章了 对啊 我们熟写

00:15.680 --> 00:16.400
connected

00:17.520 --> 00:18.320
react

00:18.800 --> 00:19.200
rotor

00:20.160 --> 00:20.880
熟写这么个东西

00:21.520 --> 00:28.240
那么在熟写之前呢 我们首先我们上节课回顾一下啊 咱们上节课呢 学了这么这个主这个第三方库

00:28.640 --> 00:33.440
这个第三方库里面不就提供了这么几个东西吗 对吧 一个是咋呢 一个是connected

00:35.120 --> 00:38.400
rotor 这东西是啥 是不是有函数 他返回啥

00:39.040 --> 00:42.960
返回一个reducer 对吧 因为因为你得用一个reducer来

00:43.840 --> 00:50.960
来管理仓库吧 你你把放到仓库里边得有得有一个东西来管理吧 这个东西只能是reducer 还能是啥呢

00:51.280 --> 00:55.840
对不对 嗯 还有呢 他给你提供了一个啥呢 还给你提供了一个就是

00:56.320 --> 00:59.840
madeware 就是一个中间键 对吧 就是create

01:00.800 --> 01:04.320
上节课我们用的是啊 这个名字啊 名字写的是啊 我看一下啊

01:05.040 --> 01:11.440
上节课咱们store里边 这个中间键叫做rotor madeware啊 他是个函数

01:13.360 --> 01:15.600
他是也是一个函数 函数

01:16.960 --> 01:22.960
返回一个中间键 对吧 中间键呢 就是大个数的中间键 我们很熟悉了

01:23.920 --> 01:28.160
然后还有什么呢 他还给你有这么一个东西叫做connected

01:29.040 --> 01:34.320
rotor 这个是什么呢 这是个组件啊 这是个组件用来做什么 用来提供

01:35.200 --> 01:39.920
路由上下文的啊 就是路由信息上下文 就是跟那个

01:40.640 --> 01:43.200
类似于啊 类似于那个

01:44.080 --> 01:49.840
什么browser啊 browser rotor啊 或者是哈希rotor啊等

01:50.320 --> 01:53.840
那是有这些东西啊 只不过呢 他你可以把它替换成这个玩意

01:54.800 --> 01:59.840
然后还有个啥呢 他给你提供了一些n形创建函数啊 n形creators

02:01.440 --> 02:08.000
啊 比方说push 啊 还有什么replace啊 可以提供了这么一些函数来帮助你来创建一个n形

02:08.160 --> 02:10.560
那么这些特殊的n形的话 你不需要处理

02:11.040 --> 02:17.520
谁在处理 你可以想象谁在处理 是不是这些reducer在处理啊 对不对啊 这些reducer他在处理这些n形

02:18.160 --> 02:20.160
啊 就这么个意思 没了啊 没了

02:21.360 --> 02:27.200
好 那么咱们来分析一下 他这里边每一个地方 他们是怎么来协同工作 完成

02:27.840 --> 02:36.160
把仓库和我们的路由进行啊 进行那个就是匹配的啊 进行同步的 他是怎么来做的这么严肃的

02:36.400 --> 02:40.320
我给大家画一张图啊 通过这张图了 大家就可以看得很清楚了

02:41.280 --> 02:42.400
我们还是用个bbt

02:43.120 --> 02:50.880
首先呢 你要想 比如说你来写这个东西啊 就是我们讲圆骂的话 终点还真不是他的圆骂啥写的

02:51.120 --> 02:59.600
我们要去想去思考 就是我要来做这个东西 应该怎么来做 有没有什么办法 然后我们再对照他的啊 这样子学习要我是最好的

03:00.240 --> 03:04.880
现在呢 我们是有这么一个仓库 对吧 仓库里边他是有一个reducer

03:05.040 --> 03:15.520
他在管理什么呢 管理很多的reducer 对吧 我们通过那个combined reducer是来进行合并啊 他有很多的reducer啊 我们这里呢

03:17.040 --> 03:18.080
就是这个reducer啊

03:19.680 --> 03:25.440
他通过一个combined reducer来进行合并啊 我们把它叫做rooch reducer 对吧 合并成了一个reducer

03:25.680 --> 03:32.160
那么这个rooch reducer呢 他就是在待一管啊 拖管整个数据的 那么他遇到一个action过后呢

03:32.880 --> 03:42.080
来到一个action过后 是不是他把它分发到其他的reducer来处理 对不对啊 我们这是比方说其他的reducer啊 reducer1啊 然后呢 reducer2

03:43.280 --> 03:51.040
那么其中一个reducer 是不是就是我 就是这个地方啊 这个地方他给你提供reducer 对吧 他必须要给你提供一个reducer啊 这个跑不掉的

03:51.280 --> 03:58.000
因为他要管理仓库的数据 他不没有reducer 他怎么能管理呢 对不对 他必须要提供一个reducer 这个是跑不掉的

03:58.480 --> 04:05.520
啊 好 那么其中一个reducer 就我们把它取名为啊 比方说叫做rooch reducer

04:06.320 --> 04:10.480
那么这个东西呢 他是用来管理什么 管理这个就是仓库里边的数据

04:11.040 --> 04:17.040
所以说我们仓库里边有什么数据呢 我们之前看到过啊 有什么action啊 还有什么还有什么那个就是

04:18.000 --> 04:21.760
location啊 这些数据对吧 在仓库里边是靠谁来管理 是不是他来管理

04:22.240 --> 04:25.520
对吧 他来管理 那么这数据是不是有可能会变化

04:26.480 --> 04:33.120
是不是有可能会变化 那么当数据它发生了变化之后啊 当数据发生了变化之后

04:33.440 --> 04:40.000
那么我们是不是要改变这个数据啊 改变仓库里边数据 靠什么改变 是不是要触发一个action

04:40.400 --> 04:45.760
啊 我们这里这两个就不画了啊 这两个我们就不画了 你们心里面知道是什么意思就行了啊

04:46.320 --> 04:54.960
那么他是不是要去通过一个action来改变数据啊 对不对 他通过action来改变数据 所以说你得给他一个action

04:56.000 --> 05:06.480
啊 你得给他一个action 那么这个action怎么来得到呢 啊 比方说你就可以利用他这些函数啊 action creators这些函数来得到一个action啊 那么这里

05:08.400 --> 05:17.200
那么这个action里边是不是要附带数据啊 action里面附带什么数据啊 哪些数据你觉得要哪些 哪些数据要附带过来 是不是什么那个

05:18.960 --> 05:24.800
payload 就是payload里边数据啊 附带的数据 有哪些数据要附带过来了 什么就是那个

05:26.480 --> 05:35.200
路由动作啊 就是铺鞋啊 pop啊这些东西 其实路由动作之下就是action啊 为了避免为了避免跟那个regardx的action能

05:35.520 --> 05:40.240
造成了混淆啊 所以说我这里写个路由动作 还有什么呢 还有location对象 对吧

05:40.400 --> 05:45.280
location对象 是不是要通过action附带过来 那么把这个附带过来的东西呢传给谁

05:45.680 --> 05:51.280
是不是传给reducer 那么他有了这个附带的信息过后 是不是就可以改变啊 产生一个新的

05:51.920 --> 05:54.480
新的对象 对吧 他就可以产生一个新的状态

05:55.040 --> 06:00.000
啊 对于这个reducer人还就说这么一个事 因为reducer是非常非常纯粹的啊 新的状态

06:00.880 --> 06:12.160
新的状态是不是就写完了 对吧 是不是没问题啊 这就是这么一个 这么一个东西 好 咱们看一下这个reducer啊 我们这里看一下

06:12.640 --> 06:17.200
呃 之前咱们写到哪了 写到这个地方

06:17.920 --> 06:28.160
不是 写到reducer里面啊 那么这里connects rotor这个函数 他返回一个reducer 那么这个reducer呢 就是来做这么一件事情的

06:29.040 --> 06:35.920
好 明白这个意思吗 嗯 但是呢 这里有一个问题啊 就是我们刚刚看原码的 看他的代码的时候呢

06:36.080 --> 06:44.080
他是通过一个函数来创建的这个reducer 也就是个reducer哪来的 是通过一个函数来创建的 这个函数的名字叫做connect

06:45.040 --> 06:51.360
connect 那么大家现在开始思考啊 他为什么要通过一个函数来创建 叫做connect

06:52.080 --> 06:53.680
redu 就是rotor

06:54.880 --> 07:01.120
啊 这个reducer哪来的 是通过一个函数创建的 那么这个函数他还有还有一个参数啊

07:01.600 --> 07:04.880
他的参数呢 就是pirons啊 什么就是

07:06.160 --> 07:11.840
history 要传一个history进来 你觉得他为什么要传一个history 这个特别特别有意思

07:12.800 --> 07:15.680
好 那么这个时候呢 我告诉你 你们怎么来分析这个问题

07:16.080 --> 07:20.720
你要去读懂他的元代 你就 你要去猜测他的思路啊 就是有的时候真的

07:21.200 --> 07:28.320
当你的开发能力到达一定程度之后 你真的是没有必要去完全去把他元代码一行一行去读

07:28.800 --> 07:31.680
你死 你就去猜都八九不离死 我告诉你

07:32.400 --> 07:39.760
那么你就这样子 我就假设不需要参数啊 我们通过一个函数来创来创建一个rotor reducer

07:40.080 --> 07:43.840
或者说 我根本就不通过函数来创建 我就直接写一个rotor reducer

07:44.400 --> 07:49.040
你看一下会出什么样的问题 咱们直接才写 你会发马上就发现出问题了

07:49.440 --> 07:52.960
好 咱们来首先啊 我新建个文件夹 给他取名为connected

07:53.440 --> 07:56.080
connected什么rotor

07:57.200 --> 08:00.000
好 这里边还是老回去 先给你这个解释

08:00.400 --> 08:04.320
然后呢 这边新建个文件 我们都要先想要写啥 先要写那个connected

08:04.880 --> 08:10.240
就是rotor 对吧 要写这么一个函数啊 我们一开始干脆不写函数 直接导出一个reducer

08:10.320 --> 08:14.880
你不就是插一个reducer吗 对不对 我就自己可以导出一个reducer就完成了 我干嘛

08:15.680 --> 08:20.560
一定要就是 我干嘛由于一定要用通过函数创建了 我直接导出一个reducer

08:21.680 --> 08:25.360
啊 你不就是个函数吗 有什么特别呢 一个stats 一个x

08:25.360 --> 08:31.280
对吧 就是个函数嘛 然后呢 我根据x的类型来返回一个新的

08:31.600 --> 08:38.080
新的状态 对不对 x我们刚才已经说了啊 根据我们分析x呢 它会自动带一个路由动作啊

08:38.480 --> 08:44.960
我们放 而且还带有一个location对象进来 那么我们这里呢 就假设啊 不说假设 约定好

08:45.280 --> 08:49.840
x的格式 它是这样子的啊 首先一个type 只是跑不了的 type 只能我们一会再说

08:50.560 --> 08:56.160
然后呢 我们这里呢 有一个payload payload呢 应该是这样的格式啊 什么格式呢 就是x

08:57.120 --> 09:03.040
这个这个x的意思 你要搞清楚啊 这个x是什么意思 这个x的意思表示的是路由动作

09:03.760 --> 09:07.920
不是不是那个reducer的x 是路由动作 它里边比方说是push啊

09:08.480 --> 09:13.920
push这种这种格式 对吧 放进来 然后呢 还有什么location对象对吧

09:14.320 --> 09:17.120
location对象是一个什么什么什么啊 就是

09:17.600 --> 09:23.680
location对象 你通过x给我 好 那我干嘛呢 我就首先判断一下type对吧 switch

09:24.640 --> 09:29.840
啊 判断什么 判断那个action点type 对吧 判断action点type

09:30.160 --> 09:34.400
好 如果你的type 等于某一个特殊的值啊 什么特殊值呢

09:35.200 --> 09:41.120
啊 他 我给大家说一下 他用的值呢 他是建了一个长量啊 我们比方说 我们这里也建一个长量吧 或者不建长量啊

09:42.160 --> 09:46.720
还是建个长量吧 还是建个长量 呃 长量吧 就是type 是啊 x

09:47.440 --> 09:47.840
type

09:48.720 --> 09:50.720
点 gs

09:51.680 --> 09:57.520
呃 对啊 我给你Types点 gs 那么这里呢 我们导出一个啊 导出一个export

09:58.480 --> 10:04.800
啊 导出一个长量 呃 叫做这个长量的名字 呃 叫做location

10:05.680 --> 10:07.680
change啊 什么意思呢 就是

10:08.560 --> 10:15.360
当那个路由变化之后 就是当我们的地址变化之后 这个地址呢 可能是hash地址 可能是history api的地址

10:15.520 --> 10:20.560
也可能是memory啊 memory那个 就是因为你现在听到扩展课程 你之前肯定看过那个

10:20.880 --> 10:26.640
柔头的圆码的 对吧 你懂我在说什么啊 memory柔头的那种地址啊 总之你给我一个地址 地址变化了

10:26.800 --> 10:32.720
地址变化了是不是要产生一个型 一个型里边 一个型它要让我们的就是仓库要跟着发生变化

10:32.880 --> 10:38.800
就地址变化之后 我们仓库也要发生变化 所以这个x的类型呢 我们给它取个名字叫做location change啊

10:38.960 --> 10:40.960
当我们的地址发生变化的时候啊

10:41.680 --> 10:48.400
当地址变化后产生的一个型啊 当地址变化之后产生了一个型

10:48.960 --> 10:55.200
就location change 咱们给它写上这么一个字不错啊 我们用一个字不错来代表action的名称

10:55.600 --> 11:01.040
action的type的名称呢 我们用一个特殊的符号 两个ata啊 两个ata就是rotor

11:01.920 --> 11:04.640
就表示我们用两个ata的表示我们是系统

11:05.280 --> 11:09.680
类制的一些类型啊 一般我们用两个ata表示系统类制的一些类型

11:09.920 --> 11:15.200
啊 咱们用两个atarotor表示这是我们系统类制的啊rotor这个x型type 那么

11:15.760 --> 11:17.600
值呢 是什么 值就是location

11:19.920 --> 11:24.160
location change 就用这个字

11:25.920 --> 11:32.240
没问题吧 没问题吧 我们看一下吧 它其实就是这样做的啊 我们就把这个注写下来看一下运行出来

11:33.920 --> 11:35.440
cd right

11:36.560 --> 11:37.360
要start

11:39.120 --> 11:44.160
看一下吧 看一下我们在切换路由的时候 之前我们观察过 观察过它的出发的x型的类型

11:44.400 --> 11:45.520
其实就是这样的类型

11:46.720 --> 11:47.520
啊 咱们看一下

11:48.160 --> 11:51.040
也不用按F12啊 把redux打开就行了

11:51.680 --> 11:59.950
稍等一下啊 它第一次启动了稍微一点吧 好 出发了啊 然后呢 我们看一下

12:00.430 --> 12:01.550
你看 是不是

12:02.190 --> 12:07.070
action的类型 哎 我这里都把它点击 to right

12:09.230 --> 12:16.110
啊 你看一下action的类型rotor 两个atarotor location change 对吧 是不是这样子啊 就是这个类型 对吧

12:16.350 --> 12:19.390
那么我们该写上这个action类型啊 这就是我们的action类型

12:19.550 --> 12:23.950
好 那么这里呢 有了这个action类型之后呢 就很简单的 我们把action类型导入进来啊 import

12:24.830 --> 12:27.070
from 什么 第二 action types

12:27.470 --> 12:29.470
好 这里边我们得到什么 得到这个

12:30.750 --> 12:35.870
location change 好 我们的判断一下啊 如果说你给我的action类型

12:36.110 --> 12:38.510
等于了什么呢 等于了这个啊 这个值

12:39.070 --> 12:42.670
deforced的话很简单 deforced的话我就返回远峰不动的 返回它的状态

12:43.150 --> 12:50.750
啊 之前的状态是哪有返回它 对吧 哎 location change 当我们地址改 如果说你的类型是等于这个类型的话 我们干嘛

12:51.070 --> 12:56.110
是不是要改变 要得到一个新的状态 哎 新的状态是啥呢 新的状态是啥呢

12:56.830 --> 13:02.990
是不是就是啊 就是这个action的payload 对吧 我们直接把这个action的payload返回就完事了

13:03.550 --> 13:07.950
action的payload里面就附带了新的状态 对吧 action 迫隙啊 location 是不是得到新的

13:08.270 --> 13:15.550
路由动作 还有location对象 直接把它返回就完事了 因为我们的状态里面保存的不就是这个东西嘛 你看我们的rotor的状态里面

13:15.870 --> 13:20.110
保存的不就是一个action嘛 然后的一个location 对吧 保存的就是一个玩意啊

13:20.830 --> 13:26.510
对不对 就是保存的就是一个玩意儿 就是直接返回就完事了啊 完事了 那么这个就写完了

13:27.310 --> 13:35.870
哎 我们一看没有任何障碍啊 那凭什么你要给我一个参数 history 非要通过一个函数来创建呢 你直接导出一个

13:36.270 --> 13:37.310
reducer不就完了吗

13:38.750 --> 13:41.710
你好好看一下 还有个地方没写 你看到了没

13:43.550 --> 13:48.750
还有一个地方没写哦 哪个地方 是不是这个状态的默认值

13:49.710 --> 13:59.230
是不是没写 好默认值应该是啥 是不是也应该是这种格式 哎 默认值的 你看一下 我们放到这啊 最开始的时候 初始化的时候

13:59.550 --> 14:06.030
默认值的是 你默认值是看是不是还是有location 还是有action 看到没 是不是还是有这两个属性

14:06.510 --> 14:09.470
对吧 是不是还是有这两个属性 哎 他有默认值哦

14:10.430 --> 14:15.150
那这个默认值他不是也能正确的读取地址吗 那就告诉我这个默认值哪来呢

14:16.190 --> 14:23.550
你这个时候没有出发任何来个性啊 出发 你要说一定要说出发来个性的话 就出发这个引列车 你说你给你给你这个来个性 你能干嘛

14:24.110 --> 14:27.630
那你默认值是什么 默认值是不是应该跟当前的

14:28.190 --> 14:30.190
啊 跟当前的这个history

14:30.830 --> 14:36.910
对象里边的那个什么action 啊 因为history对象里边还本来就有action 我们来看一下吧 右键检查

14:37.630 --> 14:41.070
咱们来看一下路由里边的信息啊 路由里边

14:42.110 --> 14:47.230
不就是有这个就是history对象吗 history对象里面不就有action吗 对不对 action里边

14:47.630 --> 14:53.070
history对象里面不就有action吗 所以说一开始默认值是不是得从history对象里面去拿呀

14:53.630 --> 14:59.630
对不对 所以说这里呢 他为什么要一个history 就是为了得到他的默认值

15:00.190 --> 15:02.750
就起这么一个作用 得到他的默认值

15:03.390 --> 15:08.350
好 所以说呢 我们这里为了拿到默认值没办法了 只能从history对象里面去拿

15:08.990 --> 15:17.310
因此呢 我迫不得已 这就是为什么 你说你这个东西你要去分析 你要去尝试的去思考的话 你就一定能思考得出来

15:18.030 --> 15:19.870
啊 我们就必须要有一个

15:20.350 --> 15:28.190
函数 你告诉我 你还能怎么办 你告诉我 你还能怎么办吗 你没办法了啊 你只能导出一个函数啊 函数

15:30.270 --> 15:32.750
这个函数呢 你要给我传一个history进来

15:33.630 --> 15:40.110
好 那么通过这个函数 我再给你返回一个啊 返回一个函数 这个函数呢 就是这个

15:42.210 --> 15:42.690
对吧

15:43.970 --> 15:45.490
给你返回这么一个reducer函数

15:46.370 --> 15:48.930
为什么 原因就是这个默认值你搞不定

15:49.890 --> 15:54.770
那么现在呢 有了history对象过后 默认值是可以搞定的 对吧 一下就写出来了啊 initial

15:55.250 --> 16:01.010
默认值 等于啥啊 来吧 一个是什么history对象里边的呗load

16:02.130 --> 16:09.810
对不对 history对象里面的x 等于啥 history对第二x 对吧 一下就写出来了啊 尽管我们写的代码了 可能跟公安方的元代码呢

16:10.370 --> 16:13.890
多多少少的有点区别啊 有点区别 但是呢 原理就是什么个原理

16:14.370 --> 16:20.210
原理就是什么个原理 所以我们学原代码一定要理解它的核心思路 而不要去在乎那些细致摸截的东西

16:21.090 --> 16:24.930
action 是不是要从这里拿 好然后呢 还有什么location 是不是也要从这里拿

16:25.170 --> 16:30.370
所以说这个history对象起什么作用 就是起给它一个默认值的作用啊 怎么把个默认值都可以放到了

16:31.330 --> 16:40.210
看没 就起这么一个作用 这就是为什么啊 这个这个connect rotor这个函数 它要通过一个函数来创建它

16:40.450 --> 16:47.330
而且呢 要给它喘一个牺牲的参数 我们用的时候很怪 但是你如果是你自己写 你会发现你真的是没有办法 你真的是没有办法

16:48.210 --> 16:52.210
好 那么这个地方是不是写好了 好 我们在index里边把它导出啊 重新导出

16:53.330 --> 17:01.170
from 导出从哪里来了 connect rotor啊connect rotor 那么这里呢 我们写上这个就是

17:03.410 --> 17:06.770
导出 重新导出 重新导出那个就是d force

17:07.330 --> 17:12.610
啊 把d force 重新导出 再重新命个名字啊 叫做connect rotor

17:13.330 --> 17:21.970
再重新命个名字 好 咱们再试一下啊 我们只替换这一块 把这个connect rotor替换掉 其他都不替换 我们来试一下行不行 因为发现就

17:22.610 --> 17:29.890
没问题 你们发现完全没问题 好 咱们呢 把这个地方啊 把这个地方替换一下

17:30.610 --> 17:33.570
那 那么connect rotor来自于哪呢 来自于我们自己写的

17:34.130 --> 17:39.970
来自于我们自己写的这个东西 好 看一下吧 保存

17:40.690 --> 17:47.810
啊 咱们打开这个 哎 好 重新刷新了啊 重新刷新了 你看切切几了啊 你看State

17:48.370 --> 17:53.650
好 你看一下里边axin pop location 是不是拿到了啊 对吧 是不是拿到了啊 好 然后呢 我们这里

17:54.050 --> 18:01.010
刻成列表啊 这里点击刻成列表 挑转了啊 是不是出发了新的axin啊 我们看一下新的axin出发过后

18:01.730 --> 18:03.410
哎 我看一下新的axin

18:04.450 --> 18:05.330
axin里边

18:06.610 --> 18:17.010
axin的payload里边的axin pop location 拿到了 哎 我为什么状态没变化呢 我看一下状态啊 状态没有发生变化

18:18.130 --> 18:20.210
没有发生变化 哎 这就为什么

18:21.090 --> 18:26.370
啊 肯定要发生变化的啊 这毫无疑问的 我们这里呢 打印一下啊 打印一下这个axin的type

18:30.590 --> 18:38.270
啊 这里 刻成列表 哎 打印了axin的type了 这个没问题啊 打印出来了啊 你看一下我是哪个地方

18:40.510 --> 18:44.430
名字没有没有写对吗 我看一下axin的type

18:45.390 --> 18:48.270
rotan location change 我是名字没有写对吗

18:51.600 --> 18:57.280
哦 然后名字写错了啊 名字写错了啊 重新来啊 重新来啊 不用看控制台了啊

18:58.240 --> 19:03.200
好 咱们关卡车啊 关卡车啊 刻成列表 点了过后 你看一下 这边

19:04.000 --> 19:07.520
多了一个axin 对吧 这个axin呢 嗯 我们不用看第一幅啊

19:08.080 --> 19:13.920
我们哪个行的 就出发这么一个axin 然后给他传那个payload进来 payload里边啊 这个这个地方呢 是不是写了一个

19:14.080 --> 19:16.880
is first a rendering啊 is first a rendering

19:17.680 --> 19:20.800
这个是否首次加载 这个东西跟我们没关系啊 我们都不用去管他

19:21.600 --> 19:26.560
location啊 是不是一个新的location给你的 对吧 然后呢axin是不是给你的

19:26.960 --> 19:33.280
啊 这个这个是路由动作来个行啊 然后我们看状态里边是不是跟着变了 你看一下 状态里边是不是跟着变了

19:34.240 --> 19:36.400
对不对 你看刚才是不是跟着变了啊

19:37.200 --> 19:41.520
就这么简单啊 就特别特别简单 你看我们这里reducer就写完了

19:42.320 --> 19:45.120
他不就是给你返回一个reducer而已 仅此而已

19:46.240 --> 19:52.080
好 这是这个reducer 那么第一部分呢 我们就写完了啊 扛那个说reducer函数

19:53.280 --> 19:54.800
好 接下来呢 我们再来看

19:55.760 --> 20:01.760
他为什么需要一个中间键啊 他为什么需要一个中间键

20:02.000 --> 20:06.320
你要搞清楚这个问题的话 那么你想一想 现在有了reducer过后

20:06.880 --> 20:08.960
我们还能还应该干嘛

20:10.320 --> 20:15.600
还有什么事情要做啊 我们比较尝试来来来想这个问题吧啊来想这个问题

20:16.000 --> 20:17.920
那么还有什么事情要做呢

20:18.640 --> 20:19.520
那你想一想

20:20.960 --> 20:22.480
如果说啊

20:22.960 --> 20:28.080
如果说 我们到时候呢 要触发一些特殊的埃克型

20:28.640 --> 20:33.120
啊 触发一些特殊的埃克型来完成啊 页面跳转

20:33.680 --> 20:37.360
来完成页面跳转啊 比方说我们之前用过的 用了Poohi对吧 我们要

20:37.840 --> 20:42.720
要用一种统一的模式嘛 这是埃克型创建函数 他用来 他的作用就是用来创建一个埃克型的

20:43.200 --> 20:44.240
啊 那么我们

20:44.480 --> 20:49.360
要通过一些埃克型创建函数来创建一些埃克型 最终要导致仓库变化

20:49.600 --> 20:51.040
不但要导致仓库变化

20:51.040 --> 20:57.440
而且同时要导致什么 要导致那个叶变地址要发生变化 你看我们之前写的

20:57.680 --> 20:58.240
在这里

20:58.480 --> 21:01.520
天天雪山这里 我们点击这个按钮 你看地址啊

21:02.560 --> 21:06.960
我们这里先清空啊 这里先清空啊 这里你点击地址是不是变了

21:07.680 --> 21:11.760
我们触发了一个埃克型啊 触发什么埃克型 就最终触发的是这个埃克型对吧

21:12.160 --> 21:17.920
最终触发的是这个埃克型啊 都可以你签计 是吧 还是这个埃克型对吧 都可以你签计还是这个埃克型

21:18.240 --> 21:24.720
那么触发这个埃克型 那么它不但是导致的仓库发生变化 而且呢 浏览器地址也发生了变化

21:26.160 --> 21:34.240
看到没 浏览器地址也发生变化 好 那么我们尝试着写一下 尝试着写一下 我们这里呢写这么见真每个文件 叫做埃克型

21:34.960 --> 21:41.520
craters啊 埃克型craters 就是来做一些埃克型的创建函数啊 做一些埃克型的创建函数

21:41.840 --> 21:50.160
我们这里导出两个 比如说导出一些函数啊 导出呢 有一个函数叫做铺席 对吧 铺席 你给我传一些参数进来

21:51.040 --> 21:53.360
你给我传一些参数进来 这是铺席

21:54.400 --> 22:01.920
好 然后呢 你通过这通参数 我最终是不是反回一个埃克型 这是埃克型创建函数嘛 所以它最终得反回一个埃克型

22:02.320 --> 22:08.080
太不值得用啥 那么根据我们这里的观察 都可以签计 对吧 它太不值还是这个太

22:08.320 --> 22:10.240
所以说 我们这里导出 因为

22:11.760 --> 22:16.960
它最终会导致啊 仓库 仓库发生变化 那么埃克型太不值

22:17.440 --> 22:21.280
就是location迁击 好 太不值怎么 太不值就location迁击

22:22.000 --> 22:26.720
哎 你会发现问题就来了 这个埃克型他要给他什么陪漏的

22:27.840 --> 22:29.680
回忆一下啊 刚刚刚那么没太写了

22:30.240 --> 22:35.280
要给他什么陪漏的 是不是里面有个埃克型表示路由动作对吧 路由动作是铺席还是

22:35.920 --> 22:42.000
还是那个就是 当然这个路由动作肯定是铺席啊 原理调问的是铺席的埃克型 对吧 路由动作肯定是铺席

22:42.560 --> 22:46.880
好 然后呢 这里边还要写什么呢 还要写这个location对吧

22:48.320 --> 22:49.520
你告诉我这个location咋写

22:50.880 --> 22:54.560
哎 你告诉我这个location你咋写

22:56.320 --> 23:02.240
你看一下铺席到时候是怎么用的啊 铺席 我当时说了这个铺席呢 跟那个history的铺席是一样的

23:02.480 --> 23:06.160
你这里要传路径啊 你要传一个路径对吧 传路径

23:06.560 --> 23:11.360
然后呢 还可以传 还可以传什么呢 还可以传一种对象的格式啊 past name 对不对

23:11.600 --> 23:16.800
你可以传各种各样的模式啊 各种各样的模式 跟那个history在铺席是完全一样的

23:17.360 --> 23:20.480
还有什么stat的都可以传进去啊 都可以传进去

23:21.440 --> 23:24.480
那么他最重要形成location 你告诉我他怎么来形成location

23:28.050 --> 23:29.090
怎么形成location

23:29.970 --> 23:33.650
你会发现这个location呢 就会变得特别特别困难

23:34.130 --> 23:37.090
而且就算你搞定了location

23:38.050 --> 23:41.890
你搞定了location对象 那你又怎么来完成页面地址调转啊

23:43.090 --> 23:47.650
哎 他只是一个x形创建 他只是一个x形创建还说他只是返回一个普通的x形而已

23:48.530 --> 23:54.290
那么这个x形如果说如果说你把直接把这个铺席这个x形直接交给谁

23:54.690 --> 23:56.370
只如果说你直接交给

23:57.330 --> 23:57.890
这个

23:58.610 --> 24:02.930
也就是rotor 他才不管你那么多 他可以调转页面 你等吧

24:03.250 --> 24:08.370
他可以调转p的页面 他就是改变一个新的状态 而且调转页面是副作用 他也不能做这件事情

24:09.410 --> 24:12.450
所以说如果说你把铺席这个东西

24:12.930 --> 24:14.690
铺席 这是个x形创建还说

24:15.330 --> 24:18.770
如果说你把铺席这个东西产生了产生了x

24:21.090 --> 24:25.490
如果说你把铺席产生一个就是那个location签计的x

24:28.660 --> 24:33.300
如果说你把铺席传成了x形 直接传给rotor reducer

24:33.940 --> 24:35.540
就是我们通过那个函数创建的 reducer

24:36.020 --> 24:36.900
就刚才我们写在这

24:37.700 --> 24:42.020
那你感觉他能帮你搞定页面调转吗 是不是搞不定啊

24:42.580 --> 24:44.900
是不是搞不定 那你想想有什么办法

24:46.980 --> 24:48.020
来想想有什么办法

24:48.660 --> 24:49.140
想呗

24:52.020 --> 24:56.260
现在的问题根源是 我这个地方 如果直接产生这个x形

24:56.500 --> 24:58.340
那么它是真的不可能给你挑转的

24:58.500 --> 25:01.780
它只是一个reducer给你挑了个p 它肯定不会给你挑转

25:01.780 --> 25:03.060
它直接给你返回一个新的状态

25:04.980 --> 25:07.460
那么你想一想 最终我们调问这个

25:07.460 --> 25:08.980
我们触发这个铺席x形

25:09.300 --> 25:12.180
最终是不是一定要用history的铺席

25:12.180 --> 25:14.660
是不是一定要用history的铺席才能调传页面

25:15.300 --> 25:15.620
对吧

25:16.100 --> 25:18.260
那么这个history铺席能不能在这里面写

25:18.260 --> 25:19.460
我们就找个面原因

25:20.020 --> 25:20.820
是不是不能在这里面写

25:20.820 --> 25:22.900
这是x形创建函数必须保持纯净

25:23.220 --> 25:24.420
能不能在reducer里面写

25:25.220 --> 25:26.900
是不是也不能 reducer必须要保持纯净

25:26.900 --> 25:27.780
这毫无疑问了

25:28.420 --> 25:30.100
x形的都还可以放松一点

25:30.100 --> 25:31.700
但reducer是绝对不能有什么

25:31.700 --> 25:32.820
页面挑的那些东西的

25:33.380 --> 25:35.060
它只是改变常库的新的纸

25:35.780 --> 25:37.460
那么谁来做这个设

25:37.460 --> 25:38.820
这个张火内火谁来做

25:38.820 --> 25:40.740
是不是只能中间间来做

25:42.100 --> 25:42.900
是不是这样子

25:42.900 --> 25:44.180
只能中间间来做

25:44.820 --> 25:47.300
因此我们这里可以用这种模式

25:47.700 --> 25:50.260
我铺形的产生的根本就不是这个x形

25:50.900 --> 25:52.820
产生的不是大家看到的这个x形

25:52.820 --> 25:54.340
那也说为什么看到这个x形

25:54.340 --> 25:55.300
等一下不着急吗

25:55.940 --> 25:58.020
我们这里产生一个别的x形

25:59.060 --> 26:00.980
就有点类似于SACHA那种

26:00.980 --> 26:02.900
交给某一个中间间来处理

26:02.900 --> 26:04.260
比方说SACHA中间间

26:04.260 --> 26:05.700
它来处理一些副作用的东西

26:06.180 --> 26:07.300
产生一个别的x形

26:07.780 --> 26:08.900
我们给它取个名字叫做

26:11.060 --> 26:11.460
call

26:13.060 --> 26:13.780
hissatory

26:14.820 --> 26:15.540
master的

26:15.540 --> 26:16.020
什么意思

26:16.420 --> 26:17.940
就是它最终会调用一个

26:17.940 --> 26:19.700
hissary对象里面的对应方法

26:19.700 --> 26:20.820
比方说你调用这个x形

26:21.140 --> 26:22.340
它最终会导致

26:22.340 --> 26:24.020
调用hissary里面的副系

26:24.020 --> 26:26.260
你到时候调用replace这个x形

26:26.260 --> 26:27.460
那么它最终会导致

26:27.540 --> 26:30.340
调用hissary里面的replace

26:30.820 --> 26:31.540
明白的意思吗

26:32.740 --> 26:34.180
能不能明白的意思吗

26:34.500 --> 26:35.300
比方说这里边

26:35.940 --> 26:37.140
我都是能猜得到

26:37.140 --> 26:38.500
应该还有一些

26:38.740 --> 26:39.220
比方说

26:41.650 --> 26:42.370
还有一些

26:44.940 --> 26:45.420
看一下

26:46.300 --> 26:46.780
还有一些

26:47.660 --> 26:48.620
go back go forward

26:48.620 --> 26:49.020
对吧

26:49.020 --> 26:51.260
那是不是都是hissary对应的函数

26:51.260 --> 26:51.660
对不对

26:51.980 --> 26:53.340
都是hissary对应的函数

26:53.340 --> 26:54.460
所以说这个x形

26:54.620 --> 26:55.500
它的触发

26:55.660 --> 26:57.740
它只是用来产生一个别的x形

26:58.700 --> 27:00.540
这个x形这个能不能处理

27:00.540 --> 27:01.340
这个x形内形

27:01.340 --> 27:02.060
这个能不能处理

27:02.060 --> 27:02.860
这不能处理

27:02.860 --> 27:04.220
它只能处理什么内形

27:04.220 --> 27:05.980
只能处理我们刚才写的那个

27:05.980 --> 27:07.340
location change那个内形

27:11.090 --> 27:12.930
location change

27:12.930 --> 27:14.130
它只能处理这个动作

27:14.130 --> 27:14.450
对吧

27:14.450 --> 27:15.730
这个动作它是不是处理不了

27:15.730 --> 27:17.330
那么这个动作是带有副作用的

27:17.330 --> 27:19.010
因为它最终要是要调用hissary的

27:19.010 --> 27:19.970
是不是要交给中间键

27:20.850 --> 27:22.610
这就是它为什么要中间键

27:22.610 --> 27:24.130
它要来处理这个副作用

27:24.130 --> 27:26.130
你看这一步一步分析是不是就出来了

27:26.130 --> 27:27.330
是不是交给它的中间键

27:28.290 --> 27:30.610
中间键是不是要来处理这个东西

27:31.810 --> 27:32.450
中间键

27:32.450 --> 27:34.450
那么中间键里面处理的过后

27:34.450 --> 27:35.490
是不是会导致

27:36.370 --> 27:38.210
调用hissary的方法

27:40.770 --> 27:44.930
调用hissary的对应用方法

27:45.490 --> 27:45.890
对吧

27:46.290 --> 27:47.650
是不是要形成这么一个流程

27:48.130 --> 27:48.610
对不对

27:48.610 --> 27:50.210
咱们先把这个流程走通

27:50.210 --> 27:51.810
所以说扑起这个x形

27:51.810 --> 27:54.050
它得到的x形内形根本就不是这个

27:54.610 --> 27:55.490
根本就不是这个

27:55.490 --> 27:57.010
是一个别的x形内形

27:57.410 --> 27:58.610
好 咱们看一下

27:58.610 --> 28:00.610
这里我们再导出一个x形内形

28:01.330 --> 28:05.250
叫做call history method

28:05.970 --> 28:06.610
那么这里呢

28:06.610 --> 28:07.970
我们还是一起这样的格式

28:07.970 --> 28:14.050
rotr call history method

28:15.170 --> 28:24.450
就是会导致调用hissary对应用方法的x形内形

28:26.130 --> 28:27.250
好 这是这么一个x形

28:28.290 --> 28:29.090
那么这里呢

28:29.090 --> 28:31.170
它产生的是这个x形而不是这个

28:31.170 --> 28:33.250
我们刚才分析的不可能产生这个

28:33.250 --> 28:35.090
因为这个东西是直接要交给reducer的

28:35.090 --> 28:37.330
你怎么办嘛 你告诉我怎么办

28:37.330 --> 28:38.290
reducer怎么办嘛

28:38.290 --> 28:38.850
它没法

28:39.490 --> 28:40.130
所以说这里呢

28:40.130 --> 28:42.930
应该导出的是call history method

28:42.930 --> 28:44.530
它出现的是这个x形

28:45.010 --> 28:46.130
只不过这个x形呢

28:46.130 --> 28:47.650
没有任何一个reducer能处理

28:48.290 --> 28:49.250
是谁在处理

28:49.250 --> 28:50.450
是中间键在处理

28:50.850 --> 28:52.130
所以说它的penel的里边

28:52.130 --> 28:52.930
在这

28:53.490 --> 28:54.690
它的penel的里边写啥

28:55.570 --> 28:56.050
写啥

28:57.010 --> 28:59.330
i就是它的就是

28:59.330 --> 29:00.290
它的就是那个

29:01.410 --> 29:02.690
这里的message of length

29:02.690 --> 29:04.370
我们这里写个message of length

29:04.370 --> 29:05.730
内面是啥 就是push

29:05.730 --> 29:07.730
调用的方法就是push 对吧

29:07.730 --> 29:08.610
就是push方法

29:09.730 --> 29:10.130
然后呢

29:10.130 --> 29:11.250
其他的参数呢

29:11.250 --> 29:12.770
参数我们是不是可以直接写出来

29:13.890 --> 29:15.090
参数是不是可以放到这

29:15.810 --> 29:17.570
就是调用这个方法的时候

29:17.570 --> 29:18.530
它传辑的参数

29:19.170 --> 29:19.650
对吧

29:19.650 --> 29:21.810
然后让中间键去调用这个方法

29:21.810 --> 29:22.930
调用hissary variable的方法

29:22.930 --> 29:24.050
因为它这里面不能调用

29:24.050 --> 29:25.010
这是个x形创键

29:25.170 --> 29:26.050
它调用啥呢

29:26.050 --> 29:26.850
它啥都不调用

29:27.250 --> 29:28.050
啥都不调用

29:28.370 --> 29:28.690
对吧

29:29.250 --> 29:29.970
是不是这个道理

29:32.050 --> 29:32.690
没问题吧

29:32.690 --> 29:33.490
就是这个道理

29:33.490 --> 29:34.050
好

29:34.050 --> 29:34.610
那么这里呢

29:34.610 --> 29:35.330
我们export

29:35.810 --> 29:36.370
export

29:36.370 --> 29:37.650
再导致导出一个

29:37.650 --> 29:38.610
比如go back

29:38.610 --> 29:39.250
go forward的时候

29:39.250 --> 29:40.290
都可以用类似的方式

29:40.290 --> 29:40.770
对吧

29:40.770 --> 29:41.890
甚至呢你这里有个

29:41.890 --> 29:42.530
你这一块呢

29:42.530 --> 29:43.410
还可以把它综合

29:43.410 --> 29:44.770
写成一个通用的函数

29:45.410 --> 29:48.130
一个可以给它传一个

29:48.130 --> 29:49.090
制服刷铺进去

29:49.090 --> 29:50.530
它就能返回这么一个函数

29:50.530 --> 29:51.010
都可以

29:51.010 --> 29:51.570
都可以

29:51.570 --> 29:52.050
好

29:52.050 --> 29:52.610
那么这里呢

29:52.610 --> 29:53.570
方形我们再导出一个

29:54.050 --> 29:56.770
导出一个就是replace

29:57.810 --> 29:58.690
给我传一些函数

29:58.690 --> 29:59.490
因为这个你的函数

29:59.490 --> 30:00.450
跟那个github里边的

30:00.450 --> 30:01.730
里边的函数是一样的

30:01.730 --> 30:02.450
是一样的

30:02.450 --> 30:03.490
它返回的是一个x形

30:04.450 --> 30:05.650
返回的是一个x形

30:05.650 --> 30:06.690
那么它的x形呢

30:06.690 --> 30:07.330
就是

30:07.330 --> 30:07.730
叫做

30:08.290 --> 30:09.570
也是内形是一样的

30:09.570 --> 30:09.970
penel的

30:09.970 --> 30:11.170
就是把这个message变一下

30:11.170 --> 30:11.890
变成replace

30:12.610 --> 30:13.330
对吧

30:13.330 --> 30:13.890
是不是这个意思

30:14.610 --> 30:16.050
这就是Igny创键函数

30:16.050 --> 30:17.170
但是大家看一下

30:17.170 --> 30:18.050
这个Igny创键函数

30:18.050 --> 30:19.570
创键的Igny是不是不交给它

30:19.570 --> 30:20.530
它没法处理啊

30:20.530 --> 30:21.330
你交给它处理

30:21.330 --> 30:21.810
怎么处理嘛

30:21.810 --> 30:22.610
它没法处理

30:22.690 --> 30:24.050
它是交给中间键来处理

30:24.050 --> 30:25.650
这就是为什么这里

30:25.650 --> 30:26.850
它有了一个中间键

30:26.850 --> 30:27.970
它就是来处理这个

30:27.970 --> 30:28.850
这些Igny的

30:29.490 --> 30:30.930
这是中间键出现的原因

30:32.210 --> 30:32.850
好那么这里

30:32.850 --> 30:33.970
咱们再写这么一个中间键

30:33.970 --> 30:34.930
再处理这些Igny

30:36.210 --> 30:36.690
我们这里

30:36.690 --> 30:37.890
intx里边把它导出啊

30:39.730 --> 30:40.370
d4

30:40.370 --> 30:41.330
不是d4

30:43.330 --> 30:44.370
这导出什么呢

30:44.370 --> 30:45.330
导出Igny

30:45.330 --> 30:46.450
quator十里边的什么

30:47.170 --> 30:47.810
push啊

30:48.290 --> 30:50.130
还有什么replace啊

30:50.130 --> 30:50.930
当然还可以写什么

30:50.930 --> 30:51.810
go啊 go forward

30:51.970 --> 30:52.610
都很简单

30:52.610 --> 30:53.410
go back

30:53.410 --> 30:54.050
都很简单

30:55.250 --> 30:55.970
好那么这里呢

30:55.970 --> 30:57.010
我们新建个文件

30:57.010 --> 30:58.210
来写这个中间键

30:58.850 --> 31:00.210
中间名字要咋来的

31:01.490 --> 31:02.770
叫做rotar medware

31:03.890 --> 31:04.530
它是个函数

31:04.530 --> 31:05.650
它反回一个中间键

31:05.650 --> 31:06.450
那么问题又来了

31:06.450 --> 31:07.250
它为什么是个函数

31:07.250 --> 31:08.690
它为什么不直接导出一个中间键

31:08.690 --> 31:10.690
它为什么要反回一个中间键

31:10.690 --> 31:12.130
而且还要给它传一个

31:12.130 --> 31:13.090
提示给对象

31:13.090 --> 31:13.410
对吧

31:14.130 --> 31:16.770
好如果说你直接导出一个中间键的话

31:16.770 --> 31:18.690
因为我们最终产生的Igny是要干嘛

31:19.250 --> 31:20.690
刚才说了是要干嘛

31:20.770 --> 31:21.970
是不是要调用

31:21.970 --> 31:23.090
它最终目的是要调用

31:23.090 --> 31:25.010
History对象的对应的方法

31:25.010 --> 31:25.490
对吧

31:25.490 --> 31:26.610
你不给它History对象

31:26.610 --> 31:28.290
它怎么调用对应的方法呢

31:28.290 --> 31:29.410
它怎么调用呢

31:29.410 --> 31:31.090
所以说你得给它

31:31.090 --> 31:33.330
给它传递一个History对象

31:33.330 --> 31:33.810
因此呢

31:33.810 --> 31:35.090
这就是它为什么

31:35.090 --> 31:36.530
导出的函数

31:36.530 --> 31:38.690
你要给它一个History对象的原因

31:38.690 --> 31:40.850
因为它最终要调用这个History对象

31:40.850 --> 31:41.170
对吧

31:41.730 --> 31:42.290
那么这里呢

31:42.290 --> 31:43.250
反回了什么

31:43.250 --> 31:44.370
反回了就是个中间键

31:44.370 --> 31:45.570
中间键怎么写的

31:45.570 --> 31:47.330
Store啊

31:47.330 --> 31:47.970
然后呢

31:48.370 --> 31:49.250
Nest

31:49.250 --> 31:49.890
然后呢

31:49.890 --> 31:50.690
Igny对吧

31:51.410 --> 31:52.450
这就不就中间键嘛

31:53.010 --> 31:53.810
中间键

31:53.810 --> 31:54.210
甚至呢

31:54.210 --> 31:55.970
你这个History是不是也可以

31:55.970 --> 31:57.330
因为这是一个函数嘛对吧

31:57.330 --> 31:58.850
这是个函数里面反回这个东西

31:58.850 --> 31:59.490
那么甚至呢

31:59.490 --> 32:00.210
也可以这样子写

32:00.770 --> 32:01.490
也可以这样子写

32:02.690 --> 32:04.450
它的那个代码里面就这样子写了

32:04.450 --> 32:05.010
History

32:05.890 --> 32:06.610
就是一样的

32:06.610 --> 32:07.250
有一样的

32:07.250 --> 32:07.730
外面

32:07.730 --> 32:09.090
这是一个函数

32:09.090 --> 32:10.290
这个函数反回这个东西

32:11.170 --> 32:11.970
反回这个东西

32:11.970 --> 32:12.690
就这么一个东西

32:13.650 --> 32:15.570
那么这个函数里面

32:15.570 --> 32:17.490
现在是可以拿到History了

32:17.570 --> 32:18.450
好那么现在来呗

32:18.450 --> 32:19.810
来拦戒这个Igny

32:19.810 --> 32:20.930
判断一下吧

32:20.930 --> 32:22.290
这个很好判断啊

32:22.290 --> 32:23.010
很好判断

32:24.210 --> 32:24.770
from

32:24.770 --> 32:25.490
来自于哪呢

32:25.490 --> 32:27.090
来自于就是比方说啊

32:27.090 --> 32:27.650
来自于

32:30.130 --> 32:30.530
在这

32:32.770 --> 32:33.490
IgnyTypes

32:34.530 --> 32:35.250
判断什么

32:35.250 --> 32:35.810
Call

32:35.810 --> 32:36.850
History 白色的

32:36.850 --> 32:38.290
那么这个这个东西呢

32:38.290 --> 32:38.770
就是呢

32:38.770 --> 32:40.050
如果遇到了这样的类型呢

32:40.050 --> 32:41.330
Igny是中间键在处理

32:41.330 --> 32:42.450
而不是Reducer在处理

32:42.450 --> 32:44.370
Reducer根本就处理不了这个东西

32:44.370 --> 32:45.490
好判断一下

32:45.490 --> 32:45.970
如果说

32:46.930 --> 32:47.810
Igny的类型

32:49.980 --> 32:51.020
等于了啥

32:51.020 --> 32:51.820
等于那Call

32:52.380 --> 32:53.580
History method

32:53.580 --> 32:54.220
等于那这个

32:54.860 --> 32:56.060
我干嘛呢

32:56.060 --> 32:56.940
我干嘛呢

32:56.940 --> 32:58.380
我是不是要调用

32:58.380 --> 32:59.980
History的对应的方法

32:59.980 --> 33:00.300
对吧

33:01.340 --> 33:03.580
调用History

33:03.580 --> 33:05.180
对应的方法

33:06.380 --> 33:06.620
好

33:06.620 --> 33:06.940
然后呢

33:06.940 --> 33:08.460
我们这里调用History

33:08.460 --> 33:09.180
调用什么呢

33:09.180 --> 33:10.140
调用什么方法呢

33:10.780 --> 33:11.340
什么方法

33:11.340 --> 33:12.780
Pushy還是Replace

33:12.780 --> 33:13.740
那么取决一下

33:13.740 --> 33:14.700
是不是这个Igny的

33:14.700 --> 33:16.380
Payload里边的

33:16.540 --> 33:18.220
那个Messor的名称

33:18.220 --> 33:19.100
你看一下

33:19.580 --> 33:20.380
我们这个

33:21.340 --> 33:23.180
IgnyCreators里边

33:23.180 --> 33:23.740
你看

33:23.740 --> 33:25.340
它调用方法名称是不是在这

33:25.340 --> 33:25.740
对吧

33:25.740 --> 33:26.540
Payload里边

33:26.540 --> 33:27.020
对吧

33:27.020 --> 33:28.620
我们从Igny里边是不是可以拿到这个

33:28.620 --> 33:29.500
方法名称

33:29.500 --> 33:30.700
来去调用它

33:30.700 --> 33:31.500
参数是什么

33:32.380 --> 33:33.100
参数是啥

33:33.820 --> 33:35.100
参数是不是这里

33:35.100 --> 33:36.140
这里的参数

33:36.140 --> 33:37.100
这不是个数组吗

33:37.100 --> 33:37.580
参数数组

33:37.580 --> 33:38.380
你把数组展开

33:38.380 --> 33:39.180
人进去玩笑了

33:39.180 --> 33:39.580
对吧

33:39.580 --> 33:40.860
这是它传递的参数

33:40.860 --> 33:41.820
所以说为什么说

33:41.820 --> 33:42.780
这个PushyReplace

33:42.780 --> 33:43.980
跟那个History里边的用法

33:43.980 --> 33:44.780
一模一样了

33:44.780 --> 33:45.900
因为它这里传递的参数

33:45.900 --> 33:47.500
就是完全远方不动的传过去

33:49.600 --> 33:51.280
当然我们也可以用解构的方式

33:51.840 --> 33:52.640
解构的方式

33:53.280 --> 33:55.200
来自于IgnyCreators的Payload

33:56.160 --> 33:57.040
把这个Messor的

33:57.680 --> 33:58.240
Messor的

33:58.880 --> 33:59.520
还有这个什么

34:00.240 --> 34:01.680
Aculus解构出来

34:02.240 --> 34:03.680
那么这里就是调用的方法

34:04.800 --> 34:06.320
然后参数展开

34:07.120 --> 34:07.440
对吧

34:08.880 --> 34:09.040
好

34:09.040 --> 34:10.160
遇到这样的IgnyCreators

34:10.160 --> 34:12.000
我需不需要交给下一个中间间

34:12.480 --> 34:14.160
这个中间间就是人来挑转的

34:14.160 --> 34:15.040
它还能干嘛呢

34:15.040 --> 34:16.160
这个中间间还能干嘛

34:16.640 --> 34:18.240
是不是不做任何其他事情的

34:18.560 --> 34:20.160
因此我在这个情况下

34:20.160 --> 34:21.840
就不调用那个车了

34:22.160 --> 34:23.280
就不调用那个车了

34:24.960 --> 34:28.720
不再向下传递IgnyCreators

34:29.040 --> 34:29.680
不再向下一个

34:29.680 --> 34:30.880
向下一个中间间传递IgnyCreators

34:30.880 --> 34:31.760
所以后面的中间间

34:31.760 --> 34:32.880
全部收不到这个IgnyCreators

34:32.880 --> 34:34.000
更不要说Reduce了

34:34.000 --> 34:35.200
Reduce更加收不到了

34:36.480 --> 34:36.720
好

34:36.720 --> 34:37.600
如果说Ael是

34:37.600 --> 34:39.520
如果说你给的是别的IgnyCreators

34:39.520 --> 34:40.560
那我啥都不管

34:40.560 --> 34:41.760
跟我没什么关系

34:41.760 --> 34:43.360
我就调用下一个IgnyCreators

34:43.360 --> 34:44.240
下一个中间间

34:44.960 --> 34:45.840
把什么给传过去

34:46.160 --> 34:47.440
所以把IgnyCreators传过去

34:47.440 --> 34:48.000
对吧

34:48.560 --> 34:50.000
把IgnyCreators传过去

34:50.000 --> 34:51.280
调一下给中间间就完事了

34:53.600 --> 34:54.480
没办法这个意思吧

34:55.120 --> 34:56.160
能没办法这个意思吗

34:58.640 --> 34:59.040
好

34:59.040 --> 34:59.680
这就是

35:00.640 --> 35:02.800
这么一个它这个中间间的作用

35:02.800 --> 35:04.160
就是能拦戒这个东西的

35:04.960 --> 35:05.120
好

35:05.120 --> 35:06.160
咱们试一下吧

35:06.160 --> 35:07.520
如果有了这个中间间过后

35:07.520 --> 35:08.240
我们来看一下

35:08.720 --> 35:09.200
看一下

35:09.520 --> 35:10.480
基本上的问题呢

35:11.280 --> 35:13.200
基本上得到了绝大部分解决了

35:13.600 --> 35:14.560
你看我们这里

35:14.560 --> 35:15.760
使用我们自己写的

35:16.400 --> 35:17.760
Coloring as a Router

35:17.760 --> 35:18.480
这里还要导出

35:19.040 --> 35:19.600
还要导出

35:22.990 --> 35:23.550
来自于

35:25.790 --> 35:26.830
RouterMedware

35:27.950 --> 35:29.390
这里导出默认的

35:30.750 --> 35:32.190
因为它导出的是默认字

35:32.750 --> 35:33.310
默认导出

35:33.310 --> 35:33.950
那么我们这里

35:34.510 --> 35:35.230
来改个名字

35:35.230 --> 35:36.270
RouterMedware

35:36.270 --> 35:36.510
好

35:36.510 --> 35:37.310
那么这边

35:37.310 --> 35:38.830
你是不是可以用这个函数了

35:38.830 --> 35:40.510
那么它产生的是不是个中间间

35:40.510 --> 35:41.710
你把中间间应用进去

35:41.710 --> 35:42.270
对吧

35:42.270 --> 35:42.830
应用进去

35:42.830 --> 35:43.710
为什么放第一个

35:43.710 --> 35:45.630
就是首先它叫被拦戒

35:45.710 --> 35:47.710
首先它就要被拦戒

35:48.510 --> 35:48.910
对吧

35:49.470 --> 35:51.310
那么我们这里使用这个

35:51.310 --> 35:52.510
然后我们刚才

35:53.390 --> 35:55.550
之前那个地方

35:55.550 --> 35:56.190
我看一下

35:56.670 --> 35:57.790
那个配级是里边

35:58.350 --> 35:59.230
配级是里边

35:59.870 --> 36:00.910
配级是那个Push

36:00.910 --> 36:01.870
我们使用自己写的

36:03.150 --> 36:03.470
哦

36:03.470 --> 36:03.950
在Menu

36:03.950 --> 36:04.750
Menu主线里边

36:06.750 --> 36:07.230
不是

36:07.230 --> 36:07.870
不是不是

36:07.870 --> 36:09.550
在配级是哪个地方呢

36:10.350 --> 36:11.390
ATD students

36:11.710 --> 36:12.190
在这里

36:12.670 --> 36:14.110
我们得使用自己写的

36:14.750 --> 36:15.550
使用自己写的

36:17.230 --> 36:18.430
使用自己写的Push

36:18.430 --> 36:18.830
对吧

36:18.830 --> 36:19.630
使用自己写的Push

36:19.630 --> 36:20.590
去触发这个X型

36:21.070 --> 36:21.950
触发这个X型

36:21.950 --> 36:23.870
因为它最终会被中间间拦戒

36:24.190 --> 36:25.310
被中间间拦戒

36:25.710 --> 36:26.510
你看这图啊

36:26.750 --> 36:27.870
它触发的这个X型呢

36:27.870 --> 36:28.670
会被中间间拦戒

36:28.670 --> 36:29.470
它来去调整

36:29.470 --> 36:30.430
History对应的方法

36:30.430 --> 36:32.670
最终来完成这个页面的跳转

36:33.470 --> 36:33.870
好

36:33.870 --> 36:35.550
然后我们之前还写过这个就是

36:36.670 --> 36:38.590
那个Connect是Router对吧

36:38.590 --> 36:38.910
好

36:38.910 --> 36:40.670
咱们也使用我们自己写的

36:40.670 --> 36:41.550
你会发现呢

36:41.550 --> 36:42.430
基本上就差不多了

36:43.230 --> 36:43.550
哎

36:43.550 --> 36:44.190
跑到去了

36:44.190 --> 36:45.310
有丢算里边

36:45.950 --> 36:46.910
我们使用自己写的

36:47.870 --> 36:48.510
好

36:48.510 --> 36:49.630
咱们来看一下啊

36:49.630 --> 36:50.350
看一下

36:51.150 --> 36:52.510
首先看能不能跳转啊

36:52.510 --> 36:53.470
能不能跳转

36:53.470 --> 36:54.830
首先这些地方可能能跳转

36:54.830 --> 36:55.870
因为这些地方跟我们写的

36:55.870 --> 36:57.150
还没什么关系啊

36:57.150 --> 36:58.030
它是用那个

36:58.030 --> 37:00.750
原始的React Router来跳转的

37:00.750 --> 37:01.790
用Live Link对吧

37:01.790 --> 37:03.150
用Live Link来跳转的

37:03.150 --> 37:03.710
对吧

37:03.710 --> 37:04.990
用Live Link来跳转的

37:04.990 --> 37:06.430
这里跳转没有什么问题

37:07.070 --> 37:07.550
然后呢

37:07.550 --> 37:07.950
我们看呀

37:07.950 --> 37:09.310
点击我们这个能不能跳转啊

37:09.310 --> 37:10.110
注意看地址

37:10.110 --> 37:11.070
注意看地址

37:11.070 --> 37:12.510
Students ADD

37:12.510 --> 37:13.230
点击

37:13.230 --> 37:14.350
你看是跳转过来了

37:14.350 --> 37:15.070
谁跳转过来了

37:15.070 --> 37:15.870
是中间间

37:15.870 --> 37:16.270
对吧

37:16.510 --> 37:17.470
中间间跳转过来了

37:18.110 --> 37:18.350
好

37:18.350 --> 37:19.150
然后我们来对照一下

37:19.150 --> 37:19.790
我们的仓库

37:21.150 --> 37:22.590
对照一下我们的仓库

37:25.310 --> 37:25.950
现在呢

37:25.950 --> 37:26.270
我们

37:28.990 --> 37:29.710
点击

37:29.710 --> 37:30.750
从这里开始跳转啊

37:34.900 --> 37:35.860
我们先不着急

37:35.860 --> 37:37.380
因为我现在还剩最后一个东西

37:37.380 --> 37:38.580
还剩最后东西就是这个

37:38.580 --> 37:39.780
为什么需要这个组件

37:39.780 --> 37:41.380
我们假设没有这个组件

37:41.380 --> 37:43.300
我们先假设没有这个组件

37:43.300 --> 37:45.620
就是用的是原来的这个Froster Router

37:46.980 --> 37:47.380
对吧

37:47.380 --> 37:49.140
这些东西都是出现都是有原因的

37:49.380 --> 37:51.140
没有这个组件

37:51.140 --> 37:55.060
我们用的就是那个Broster Router

37:55.060 --> 37:56.660
看一下会遇到什么样的问题

37:57.700 --> 37:58.260
看着啊

37:58.260 --> 38:00.340
我们现在跳转能跳转吗

38:00.340 --> 38:01.220
肯定能跳转

38:01.220 --> 38:01.860
肯定能跳转

38:01.860 --> 38:02.260
没有问题

38:02.260 --> 38:02.900
任何问题

38:02.900 --> 38:03.540
包括这

38:03.540 --> 38:04.820
包括这点击

38:04.820 --> 38:05.620
是不是也能跳转

38:05.620 --> 38:06.020
对吧

38:06.020 --> 38:06.500
也能跳转

38:06.500 --> 38:07.220
没有任何问题

38:07.940 --> 38:08.500
但是

38:09.380 --> 38:09.780
但是

38:10.340 --> 38:11.380
我们来看一下仓库

38:12.500 --> 38:13.380
是不是没有触发

38:14.020 --> 38:15.380
我刚才不是触发了X型吗

38:15.380 --> 38:17.140
刚才不是触发了PUSH这个X型吗

38:17.140 --> 38:18.580
但是PUSH这个X型呢

38:18.740 --> 38:20.180
它被这个东西拦戒掉了

38:21.060 --> 38:22.340
它被这个网上拦戒掉了

38:22.340 --> 38:22.980
对吧

38:22.980 --> 38:24.420
被这个组件线拦戒掉了

38:24.420 --> 38:25.140
那么拦戒掉过了

38:25.140 --> 38:26.180
它没有往下传递

38:26.180 --> 38:27.460
所以说这个LOG

38:27.460 --> 38:28.980
像这个就是

38:29.620 --> 38:31.140
这个调试工具它也获取不到

38:31.140 --> 38:32.740
也获取不到你触发了什么X型

38:32.740 --> 38:34.420
因为它没有往后传递

38:34.420 --> 38:35.700
所以说你后面获取不到

38:35.700 --> 38:36.980
你触发了什么X型

38:36.980 --> 38:38.820
当然如果说你往后面传递

38:38.820 --> 38:39.780
那就知道了

38:39.780 --> 38:40.580
它触发了一个X型

38:40.580 --> 38:41.620
被组件线拦戒了

38:42.980 --> 38:44.340
那么现在的问题是

38:44.900 --> 38:47.540
当我们只是第一次能够发生跳转

38:47.620 --> 38:49.540
但是仓库里面是不是就没有改变

38:50.020 --> 38:50.340
对吧

38:50.340 --> 38:51.460
是不是没有改变

38:51.460 --> 38:52.980
我们通过那个History对象

38:53.540 --> 38:56.020
当我们通过History对象的对应用方法

38:56.020 --> 38:57.860
无论是你点的Levelink

38:58.580 --> 39:00.660
还是说你怎么去跳转

39:00.660 --> 39:02.820
还是说你这里调用到History对象里面的

39:02.820 --> 39:04.340
PUSH啊replace方法

39:04.340 --> 39:05.300
跳转页面

39:05.300 --> 39:06.260
跳转页面过后

39:06.260 --> 39:07.460
仓库是不是没变

39:08.020 --> 39:09.220
因为仓库要变化

39:09.220 --> 39:11.460
它就必须要产生这么一个

39:11.460 --> 39:13.060
location签计这么一个X型

39:13.060 --> 39:14.820
才能会导致仓库发生变化

39:14.820 --> 39:15.460
对吧

39:15.460 --> 39:17.460
但是你直接调用的是History对应的

39:18.020 --> 39:19.060
仓库是不是没动

39:19.060 --> 39:19.780
它不知道

39:20.820 --> 39:22.340
它不知道那个地址变了

39:24.180 --> 39:25.140
那么这个时候怎么办

39:27.170 --> 39:29.010
你想来想去的话

39:29.010 --> 39:30.770
也只有这种处理方式呢

39:30.770 --> 39:32.050
你写一个组件

39:32.050 --> 39:35.490
在这个组件里边去监听这个History

39:35.490 --> 39:37.650
History里面不是有个监听函数吗

39:37.650 --> 39:38.130
对不对

39:38.130 --> 39:39.890
lesson监听函数

39:39.890 --> 39:41.170
通过这个lesson监听函数

39:41.170 --> 39:43.330
是不是可以监听那个History的变化

39:43.330 --> 39:44.930
当它变化的时候

39:44.930 --> 39:47.330
你手动的去触发一个X型

39:47.890 --> 39:50.050
让仓库也跟着发生变化

39:50.050 --> 39:51.570
你是不是得只能这样做

39:51.570 --> 39:52.290
对吧

39:52.290 --> 39:53.250
只能这样做

39:53.250 --> 39:54.450
那么于是呢

39:54.450 --> 39:56.050
你这里就想出来这么一个方案

39:56.050 --> 39:58.130
就想出来这么一个方案

39:59.490 --> 40:02.690
就是我这里要写一个组件

40:02.690 --> 40:04.610
要写个组件

40:04.610 --> 40:05.570
要做什么呢

40:05.570 --> 40:08.050
监听History

40:08.050 --> 40:11.090
然后如果History发生变化

40:11.090 --> 40:13.490
要触发触发X型

40:13.490 --> 40:14.530
什么X型

40:14.690 --> 40:18.850
要触发什么X型

40:18.850 --> 40:19.890
是不是这个X型

40:19.890 --> 40:21.890
让仓库也跟着变

40:21.890 --> 40:23.490
是这个逻辑吧

40:23.490 --> 40:25.090
肯定是这个逻辑

40:25.090 --> 40:26.290
所以说到时候呢

40:26.290 --> 40:27.650
你不管调用的

40:27.650 --> 40:29.410
你是用这个PoO型这个X型

40:29.410 --> 40:31.330
被中间键调用到History的方法

40:31.330 --> 40:34.450
还是说你自己在页面上用到Nivelink

40:34.450 --> 40:37.810
因为Nivelink本质也是调用History的PoO型

40:37.810 --> 40:38.210
对吧

40:38.210 --> 40:39.730
我们之前解析过原嘛

40:39.730 --> 40:40.530
所以说

40:40.530 --> 40:41.570
你无论怎么调用

40:41.570 --> 40:42.690
只要你调用到History

40:42.770 --> 40:43.970
导致它发生变化

40:43.970 --> 40:45.890
它一定会触发X型

40:45.890 --> 40:47.410
但是有个潜力条件

40:47.410 --> 40:48.610
是不是就必须要要求

40:48.610 --> 40:50.370
History对象是同一个

40:50.370 --> 40:51.410
比方说你中间键调用到

40:51.410 --> 40:52.450
是别的History对象

40:52.450 --> 40:53.890
那你这里的监听是另外一个

40:53.890 --> 40:54.610
那监听得到吗

40:54.610 --> 40:55.410
肯定监听不到

40:55.410 --> 40:56.210
这就是为什么

40:56.210 --> 40:58.370
他们需要同一个History对象

40:58.370 --> 41:00.210
这些都是有原因的

41:00.210 --> 41:01.330
那你还能怎么做呢

41:01.330 --> 41:03.170
你告诉我你还能怎么做呢

41:03.170 --> 41:03.730
这里呢

41:03.730 --> 41:06.530
我们这里就可以使用这个模式

41:06.530 --> 41:08.370
我们这里建一个新的武念甲

41:08.370 --> 41:11.810
叫做Connected Router

41:11.810 --> 41:12.530
建这么一个

41:12.610 --> 41:13.810
导致的是一个什么玩意

41:13.810 --> 41:15.090
导致的是一个

41:16.370 --> 41:17.410
一个组件

41:17.410 --> 41:17.890
对不对

41:17.890 --> 41:18.850
组件这个组件呢

41:18.850 --> 41:20.690
有一个History对属性

41:20.690 --> 41:21.890
为什么要History属性

41:21.890 --> 41:22.930
我们刚才解释过了

41:22.930 --> 41:24.370
因为我要监听这个History

41:24.370 --> 41:25.970
必须要告诉我这个History对象

41:26.690 --> 41:28.130
所以说我们当时用的时候

41:28.130 --> 41:28.770
怎么用的

41:28.770 --> 41:29.970
当时用的时候

41:29.970 --> 41:31.410
这还不远了

41:31.410 --> 41:32.530
还没发还远了

41:32.530 --> 41:33.410
当时我们怎么用的

41:33.410 --> 41:34.290
是不是用这个玩意

41:34.290 --> 41:34.770
对吧

41:34.770 --> 41:35.650
就不能用原

41:35.650 --> 41:37.410
不能用它一个BrosterHistory

41:37.410 --> 41:38.370
不能用它那个了

41:38.370 --> 41:39.170
因为它那个

41:39.170 --> 41:40.770
它是自己给你新建一个History

41:40.770 --> 41:41.570
你能监听到吗

41:41.570 --> 41:42.290
肯定监听不到

41:42.290 --> 41:43.570
它也不会给你监听

41:43.570 --> 41:43.970
是吧

41:43.970 --> 41:45.090
你要把一个History对象

41:45.090 --> 41:46.370
同一个History对象

41:46.370 --> 41:47.410
传过来

41:47.410 --> 41:49.170
传过来之后

41:49.170 --> 41:51.250
它里边是不是可以监听这个对象

41:51.250 --> 41:53.570
监听那个History对象里边的变化

41:53.570 --> 41:54.370
对吧

41:54.370 --> 41:55.090
所以说这里呢

41:55.090 --> 41:56.130
其实就很简单

41:56.130 --> 41:57.170
它就是一个组件

41:57.170 --> 41:59.410
FC

41:59.410 --> 42:00.610
不就是个组件吗

42:00.610 --> 42:03.010
导出Connected Router

42:03.010 --> 42:04.450
那么

42:04.450 --> 42:06.210
导致的韩式组件

42:06.210 --> 42:07.010
RCC

42:07.010 --> 42:08.370
就是一个组件

42:08.370 --> 42:09.010
好

42:09.010 --> 42:10.050
这个组件里边呢

42:10.050 --> 42:10.610
它有什么呢

42:10.610 --> 42:11.490
有History对吧

42:11.490 --> 42:12.530
我们是不是要监听

42:12.530 --> 42:14.210
我们当我们Component

42:14.210 --> 42:15.490
Determined的时候

42:15.490 --> 42:16.850
我们是不是可以监听

42:16.850 --> 42:18.050
这个组件里边的

42:18.050 --> 42:19.810
通过History里边去监听

42:19.810 --> 42:19.970
好

42:19.970 --> 42:23.810
我们这里拿到这个组件的History对象

42:23.810 --> 42:27.490
就是拿到ListProps.History

42:27.490 --> 42:28.610
拿到这个对象

42:28.610 --> 42:28.930
好

42:28.930 --> 42:30.050
然后我们来干嘛

42:30.050 --> 42:31.170
当然可以判断一下

42:31.170 --> 42:32.050
对象存不存在

42:32.050 --> 42:33.170
我们拿来判断的

42:33.170 --> 42:33.970
Nation

42:33.970 --> 42:35.090
我们就写核心代嘛

42:35.090 --> 42:35.890
对吧

42:35.890 --> 42:37.490
History对象里边是不是个Nation

42:37.490 --> 42:39.010
当地址发生变化的时候

42:39.010 --> 42:40.530
它是不是

42:40.610 --> 42:42.850
会运行这么一个函数

42:42.850 --> 42:43.730
对不对

42:43.730 --> 42:45.890
就是会运行这么一个函数

42:45.890 --> 42:46.850
那么这个函数里边

42:46.850 --> 42:48.130
我们还知道它有什么

42:48.130 --> 42:49.170
它有什么

42:49.170 --> 42:51.090
这边还有参数

42:51.090 --> 42:54.290
NewLocation对吧

42:54.290 --> 42:56.930
得到一个新的Location对不对

42:56.930 --> 42:57.890
新的Location

42:57.890 --> 42:58.370
还有什么

42:58.370 --> 42:59.650
还有一个X

42:59.650 --> 43:00.690
它的参数数据是什么

43:00.690 --> 43:01.650
我们打印一下吧

43:01.650 --> 43:03.890
打印一下

43:03.890 --> 43:07.010
X NewLocation

43:07.010 --> 43:08.530
打印一下

43:08.530 --> 43:08.690
好

43:08.690 --> 43:09.250
咱们来看一下

43:09.250 --> 43:10.370
我们直接用这个

43:10.450 --> 43:11.730
Connected Rotor

43:11.730 --> 43:13.570
那么这里Render的时候干嘛

43:13.570 --> 43:15.970
Render的时候直接使用什么

43:15.970 --> 43:16.930
直接使用那个就是

43:19.570 --> 43:22.300
Children

43:22.300 --> 43:24.460
还有Render这里

43:24.460 --> 43:25.180
Render这里

43:25.180 --> 43:26.060
因为我注意中

43:26.060 --> 43:26.860
还是要

43:26.860 --> 43:27.820
因为做的功能

43:27.820 --> 43:29.020
是不是跟那边是一样的

43:29.020 --> 43:30.940
跟Browse Rotors要一样

43:30.940 --> 43:32.300
对吧

43:32.300 --> 43:34.140
是不是说的功能要跟Browse Rotor

43:34.140 --> 43:36.220
或者是Hashe Rotor要一样

43:36.220 --> 43:37.900
那我这里是不是要包装一个

43:37.900 --> 43:40.460
Browse Rotor和Hashe Rotor呢

43:40.460 --> 43:41.740
不用

43:41.740 --> 43:43.900
因为我为什么放在扩展课程里面讲

43:43.900 --> 43:46.860
因为你们之前学过React Rotor原码

43:46.860 --> 43:48.620
我们自己熟悉过的

43:48.620 --> 43:49.980
你会发现当时我们写

43:49.980 --> 43:51.980
React Rotor原码的时候

43:51.980 --> 43:56.780
Browse Rotor和Hashe Rotor的本质是啥

43:56.780 --> 43:58.380
Browse还记得吗

43:58.380 --> 44:01.420
Browse Rotor和那个Hashe Rotor

44:01.420 --> 44:02.780
它的本质是啥

44:02.780 --> 44:04.700
是不是他们都去使用了一个组件

44:04.700 --> 44:05.900
叫做Rotor

44:05.900 --> 44:06.940
这个组件要什么

44:06.940 --> 44:09.340
它是不是要的就是一个History属性

44:09.340 --> 44:10.220
对吧

44:10.220 --> 44:11.340
要的就是History属性

44:11.420 --> 44:13.900
我们当时说了还自己写了的

44:13.900 --> 44:15.820
Browse Rotor干了什么事情呢

44:15.820 --> 44:18.940
它就是帮你来创建了一个Browse History

44:18.940 --> 44:20.300
他们用History第三方库

44:20.300 --> 44:22.140
在创建了一个Browse History

44:22.140 --> 44:24.620
然后向传递给这个Rotor组件

44:24.620 --> 44:26.780
给它的History组件给它传过去

44:26.780 --> 44:28.300
Hashe Rotor做的什么事呢

44:28.300 --> 44:29.660
Hashe Rotor它就给做了

44:29.660 --> 44:31.340
创建了一个Hashe History

44:31.340 --> 44:33.180
然后给这个Rotor组件传过去

44:33.180 --> 44:34.620
真正起作用的

44:34.620 --> 44:37.180
向上下吻里边放东西的是这个Rotor组件

44:37.180 --> 44:37.580
对吧

44:37.580 --> 44:39.100
我们当时还说了两个库

44:39.180 --> 44:42.220
一个是Rotor这个库

44:42.220 --> 44:44.940
一个是Rotor Dom这个库

44:44.940 --> 44:46.540
我们当时说这个库呢

44:47.820 --> 44:49.260
跟浏览器无关

44:51.490 --> 44:52.770
你可以试任何设备

44:52.770 --> 44:54.130
你只要给它传一个History对象

44:54.130 --> 44:54.770
它就能操作

44:55.890 --> 44:56.850
你就它就能操作了

44:58.370 --> 44:58.930
这个库呢

44:58.930 --> 45:00.370
它是跟浏览器相关的

45:00.370 --> 45:01.410
比方说Browse History

45:01.410 --> 45:03.170
Hashe History是不是它里边的东西

45:03.170 --> 45:03.490
对吧

45:03.490 --> 45:04.210
它里边的东西

45:05.010 --> 45:07.090
因为浏览器就不是比较Browse嘛

45:07.090 --> 45:08.530
它其实做的事情很简单

45:08.530 --> 45:10.210
就是帮你来创建一个History

45:11.330 --> 45:11.810
然后呢

45:11.810 --> 45:12.690
因为这个组件

45:12.690 --> 45:14.290
这个组件实际上实际上是它的

45:15.010 --> 45:17.170
它跟具体的终端设备无关

45:17.170 --> 45:19.650
所以以后在手机端也可以使用它

45:20.050 --> 45:20.850
也可以使用它

45:21.810 --> 45:22.530
你还记得是吧

45:22.530 --> 45:24.050
所以说我们这里要包装一个啥

45:24.610 --> 45:25.730
就是因为我们这里

45:25.730 --> 45:27.010
它不就是要一个History吗

45:27.010 --> 45:28.450
OK 我们就返回一个啥

45:28.450 --> 45:29.650
返回的就是一个Rotor

45:29.650 --> 45:29.970
对吧

45:29.970 --> 45:31.010
就是一个Rotor组件

45:31.010 --> 45:33.170
所以说我们得导入什么

45:33.170 --> 45:33.970
导入Rotor

45:36.050 --> 45:37.330
fromreactor

45:38.850 --> 45:39.330
Rotor

45:40.850 --> 45:41.970
从这里面导入什么

45:41.970 --> 45:42.690
导入Rotor

45:43.570 --> 45:44.690
导入Rotor

45:44.690 --> 45:46.530
它这里面也给你重新导出了的

45:47.810 --> 45:51.090
这个组件其实是ReactorRotor这个组件里面的

45:51.090 --> 45:52.290
实际上是这个组件里面的

45:52.290 --> 45:54.770
它在这个组件里面可以重新导出了

45:54.770 --> 45:56.290
OK 我们这里就使用这个组件

45:57.650 --> 45:58.530
使用这个组件

45:58.530 --> 46:00.130
好 这个组件不是需要切入准吗

46:00.130 --> 46:01.970
OK 我把我的切入准传给你

46:03.730 --> 46:05.090
我就是给你包装一下

46:05.090 --> 46:06.450
我的切入准传给你

46:06.450 --> 46:07.810
然后这里面你要写啥呢

46:07.810 --> 46:08.850
它要的就一个东西

46:08.850 --> 46:09.810
就是History

46:09.890 --> 46:11.250
那么我就把我的这个

46:11.250 --> 46:13.010
thisprobs里面的History传给你

46:13.650 --> 46:14.290
传给你

46:14.290 --> 46:16.610
那么实际上它功能是不是就全部实现了

46:16.610 --> 46:18.050
说这里面没有写多少台吗

46:18.050 --> 46:21.810
你不要认为这里面好像把ReactorRotor给你全部写了一遍

46:21.810 --> 46:23.650
没有 没有这个必要

46:23.650 --> 46:25.010
别人已经给你实现了个功能

46:25.650 --> 46:26.530
你就直接用就行了

46:27.810 --> 46:29.570
好 那么现在我们回过回到这里

46:29.570 --> 46:30.210
回到这里

46:30.210 --> 46:31.010
我们来看一下

46:31.010 --> 46:32.050
我们现在做了个戒

46:32.050 --> 46:32.930
就夹了一件事

46:32.930 --> 46:34.530
就是坚定地走的变化

46:35.570 --> 46:36.370
那么我们看一下

46:37.250 --> 46:37.730
控制台

46:38.690 --> 46:39.650
地址变化之后

46:39.650 --> 46:41.090
我们把logo去掉也挺烦的

46:41.090 --> 46:42.610
现在我们有了调试工具过后

46:42.610 --> 46:43.650
我们不需要logo了

46:44.370 --> 46:46.290
不需要这个就是

46:47.250 --> 46:48.450
这个中间键了

46:48.450 --> 46:48.930
不需要了

46:50.450 --> 46:51.250
没用了

46:51.250 --> 46:52.210
没有调试工具了

46:53.730 --> 46:54.930
好 现在我们点击

46:55.650 --> 46:56.210
贺成那边

46:57.890 --> 46:59.090
它没接听到

46:59.090 --> 47:00.210
没接听到

47:00.210 --> 47:01.410
我这里还没有用

47:01.410 --> 47:02.050
还没有用

47:02.770 --> 47:03.330
我看一下

47:04.770 --> 47:05.890
我们这里

47:06.130 --> 47:07.090
Connected Rotor

47:07.090 --> 47:08.210
还是用的是官方的

47:08.690 --> 47:09.890
还用的不是我们自己的

47:12.500 --> 47:13.860
我们这里Connected Rotor

47:13.860 --> 47:14.980
我们当时导出没有

47:14.980 --> 47:15.940
好像还没有导出

47:19.860 --> 47:21.140
Connected Rotor

47:21.780 --> 47:23.140
这里重新把导出

47:24.580 --> 47:25.700
Connected Rotor

47:25.700 --> 47:26.820
这里重新保存一下

47:27.540 --> 47:28.660
好 咱们看一下

47:28.660 --> 47:29.220
天下学生

47:36.850 --> 47:37.890
为什么没监听到呢

47:38.770 --> 47:40.370
我们看一下为什么没监听到

47:41.090 --> 47:42.450
Connected Rotor

47:42.530 --> 47:44.050
我们在这里打印出一句话

47:44.770 --> 47:45.250
abc

47:47.650 --> 47:49.570
这件事运行了

47:49.570 --> 47:50.610
运行了的

47:51.250 --> 47:52.530
我们打印出这个黑水对象

47:53.890 --> 47:55.090
打印出这个黑水对象

47:57.040 --> 47:58.400
我这个单词又写错了

48:00.880 --> 48:01.280
Listen

48:01.280 --> 48:01.680
对了

48:02.400 --> 48:02.880
Listener

48:05.490 --> 48:05.890
Listen

48:06.290 --> 48:07.490
这里边要传一个函数

48:07.730 --> 48:08.050
对吧

48:08.450 --> 48:09.170
传一个函数

48:12.450 --> 48:14.370
它没有运行这个函数

48:15.090 --> 48:16.690
它没有运行这个函数

48:16.930 --> 48:17.970
我们来看一下

48:18.450 --> 48:22.160
就是地址变化了

48:23.440 --> 48:23.920
看一下

48:23.920 --> 48:25.520
为什么没有运行这个函数

48:26.000 --> 48:27.120
对了 运行了的

48:27.120 --> 48:27.680
没问题

48:28.000 --> 48:28.800
运行了的

48:28.800 --> 48:29.840
地址变化了

48:29.840 --> 48:30.480
还没

48:30.480 --> 48:31.280
运行了的

48:31.280 --> 48:33.280
我主要是要测试个函数的参数

48:33.280 --> 48:34.480
参数到底是啥

48:35.440 --> 48:37.760
打印一下参数

48:39.040 --> 48:40.080
我有点忘了

48:40.080 --> 48:41.360
第一个是nok形对象

48:41.360 --> 48:42.880
第一个是nok形对象

48:43.920 --> 48:45.440
第一个是nok形对象

48:45.520 --> 48:46.720
这个没什么问题

48:46.720 --> 48:48.000
就新的nok形对象

48:48.000 --> 48:50.000
第二个参数应该是x

48:50.000 --> 48:51.840
我记得应该是x

48:51.840 --> 48:53.120
这个参数应该是x

48:54.400 --> 48:55.680
重新来刷新

48:56.960 --> 48:58.000
对了

48:58.000 --> 48:59.520
第二个参数是x

48:59.520 --> 48:59.760
看没

48:59.760 --> 49:00.800
那就行了

49:00.800 --> 49:02.080
你打到了x

49:02.080 --> 49:03.360
拿到了nok形对象

49:03.360 --> 49:04.400
你还要干嘛

49:04.400 --> 49:05.920
是不是就产生

49:05.920 --> 49:07.200
要干嘛

49:07.200 --> 49:08.240
是不是要去

49:08.240 --> 49:12.320
dispatch一个x

49:12.320 --> 49:13.600
对不对

49:13.600 --> 49:14.880
是不是要dispatch一个x

49:15.040 --> 49:16.560
我们这里刚才看了图

49:16.560 --> 49:17.760
我们这里监听history

49:17.760 --> 49:18.880
当history发生变化的时候

49:18.880 --> 49:20.400
是不是要触发一个x形

49:20.400 --> 49:21.680
那么我们这里

49:21.680 --> 49:23.840
就去手动的去构建这么一个x形

49:23.840 --> 49:25.840
手动去构建这么一个x形

49:25.840 --> 49:28.400
就是reduxx形

49:28.400 --> 49:29.440
x形是什么呢

49:29.440 --> 49:30.080
类型

49:30.080 --> 49:31.280
type

49:31.280 --> 49:32.480
自己手动构建一下

49:33.920 --> 49:35.040
当然也可以用一个

49:35.040 --> 49:36.480
hacking创建函数

49:36.480 --> 49:37.360
亏持一个x形

49:37.360 --> 49:38.480
也行

49:38.480 --> 49:39.520
我们这里创建函数

49:43.680 --> 49:44.480
当个形

49:44.880 --> 49:45.920
create

49:45.920 --> 49:48.480
location

49:48.480 --> 49:49.760
location

49:49.760 --> 49:51.120
change

49:51.120 --> 49:51.760
x形

49:51.760 --> 49:53.280
这个函数名字有点长

49:53.280 --> 49:54.320
你不用过来传type

49:54.320 --> 49:55.440
你就给我传payload

49:55.440 --> 49:56.720
就是传一个x形

49:56.720 --> 49:57.520
动作名称

49:57.520 --> 49:58.560
就路由动作

49:58.560 --> 49:59.600
还有传一个什么呢

49:59.600 --> 50:00.560
location对象

50:00.560 --> 50:03.120
给我传这两个东西进来就行了

50:03.120 --> 50:04.960
我帮你产生一个x形

50:04.960 --> 50:05.280
好

50:05.280 --> 50:06.560
这里来我返回什么

50:06.560 --> 50:08.880
返回type为什么呢

50:08.880 --> 50:11.520
type到另外一个

50:11.520 --> 50:13.200
就是change

50:13.280 --> 50:15.360
location change

50:15.360 --> 50:19.020
直接在这里导致就行了

50:19.020 --> 50:19.340
好

50:19.340 --> 50:21.340
我们这里类型就是这个类型

50:21.340 --> 50:21.660
好

50:21.660 --> 50:22.540
然后呢

50:22.540 --> 50:23.580
payload

50:23.580 --> 50:25.420
payload一个就是x形

50:25.420 --> 50:26.460
一个是location

50:26.460 --> 50:26.700
对吧

50:26.700 --> 50:27.580
但是你一定要注意

50:27.580 --> 50:28.220
这个x形

50:28.220 --> 50:29.740
它自得不是redux的x形

50:29.740 --> 50:31.420
是路由动作的x形

50:31.420 --> 50:34.380
它这个函数就帮你创建一个

50:34.380 --> 50:37.100
创建一个

50:37.100 --> 50:38.940
创建一个

50:38.940 --> 50:40.700
用于改变

50:40.700 --> 50:43.980
用于地址变化后

50:43.980 --> 50:47.340
改变仓库的x形

50:47.340 --> 50:49.820
它来帮你创建这么个东西

50:49.820 --> 50:51.260
好了

50:51.260 --> 50:51.580
好

50:51.580 --> 50:52.540
那么回到这边来

50:52.540 --> 50:53.740
那么我们就可以利用

50:53.740 --> 50:55.820
这应该是要导出一个

50:55.820 --> 50:58.380
导出一个

50:58.380 --> 51:00.060
create location

51:00.060 --> 51:00.780
change x形

51:00.780 --> 51:02.140
或者说不在这里导出

51:02.140 --> 51:03.500
不能不导出这个玩意了

51:03.500 --> 51:04.860
因为是内部使用嘛

51:04.860 --> 51:05.820
不导出这个玩意了

51:05.820 --> 51:08.540
我们在这里边直接导出

51:08.540 --> 51:09.340
是吧

51:09.340 --> 51:09.900
叫斜杠

51:09.900 --> 51:10.940
x形create house

51:10.940 --> 51:12.860
里边有一个create

51:13.020 --> 51:14.460
location change x形

51:14.460 --> 51:15.980
那么这里得到一个x形

51:15.980 --> 51:16.860
redux x形

51:16.860 --> 51:17.980
通过函数

51:17.980 --> 51:18.940
把什么传进去

51:18.940 --> 51:20.220
把x形传进去

51:20.220 --> 51:21.740
把location传进去

51:21.740 --> 51:22.220
对吧

51:22.220 --> 51:23.660
是不是可以得到一个新的x形

51:23.660 --> 51:26.380
那么接下来问题在于

51:26.380 --> 51:28.620
怎么去触发

51:28.620 --> 51:30.300
问题在于

51:30.300 --> 51:34.220
怎么去触发这个x形呢

51:34.220 --> 51:35.580
怎么去触发呢

51:35.580 --> 51:38.460
触发是不是要用dispatch

51:38.460 --> 51:39.100
对吧

51:39.100 --> 51:40.620
是不是要用dispatch

51:40.620 --> 51:41.660
触发

51:41.820 --> 51:43.260
触发要用dispatch

51:43.260 --> 51:46.620
那么怎么来用dispatch呢

51:46.620 --> 51:48.620
我们来看一下我们这个组件

51:48.620 --> 51:50.060
组件里边有个provider

51:50.060 --> 51:51.980
这个provider是不是这个仓库的

51:51.980 --> 51:54.860
就是redux redux的仓库的provider

51:54.860 --> 51:55.580
对不对

51:55.580 --> 51:56.780
这个provider里边

51:56.780 --> 51:58.780
它不是给你提供了一个上下纹吗

51:58.780 --> 51:59.180
对不对

51:59.180 --> 52:00.060
上下纹里边

52:00.060 --> 52:02.860
上下纹里边不是有一个store吗

52:02.860 --> 52:05.740
store里边不是一个dispatch吗

52:05.740 --> 52:06.780
那么我们是不是只要能够

52:06.780 --> 52:08.140
拿到这个上下纹就行了

52:08.140 --> 52:09.820
当然你说你在这里用连接

52:09.900 --> 52:12.380
用那个redux redux连接行不行

52:12.380 --> 52:14.220
连接行不行

52:14.220 --> 52:14.860
抗那个车

52:14.860 --> 52:16.460
这里引出一个事件嘛

52:16.460 --> 52:16.860
对不对

52:16.860 --> 52:17.660
然后进行连接

52:17.660 --> 52:18.220
行不行

52:18.220 --> 52:19.580
可以

52:19.580 --> 52:22.300
也可以直接从上下纹里边去拿

52:22.300 --> 52:24.220
直接从上下纹里边去拿

52:24.220 --> 52:26.300
那么怎么拿呢

52:26.300 --> 52:29.980
其实在redux redux那个库里边

52:29.980 --> 52:32.140
它本身给你返回了这么一个上下纹

52:32.140 --> 52:34.220
它是直接把上下纹扔出来的

52:34.220 --> 52:35.580
你随时可以拿来用

52:35.580 --> 52:36.860
随时可以拿来用

52:36.860 --> 52:38.300
这里怎么写呢

52:38.380 --> 52:39.900
其实直接导入就行了

52:39.900 --> 52:42.700
它实际上redux redux那个库里边

52:42.700 --> 52:44.460
它直接把上下纹给你拿过来了

52:44.460 --> 52:47.260
就是它名字叫做redux redux

52:47.260 --> 52:48.620
你看就这个玩意

52:48.620 --> 52:49.580
就这个上下纹

52:49.580 --> 52:50.540
你可以直接用

52:50.540 --> 52:51.900
可以直接用这个上下纹

52:51.900 --> 52:52.780
好来吧

52:52.780 --> 52:54.140
Static

52:54.140 --> 52:55.260
context type

52:55.260 --> 52:55.580
对吧

52:55.580 --> 52:57.020
等于这个玩意

52:57.020 --> 52:57.340
对吧

52:57.340 --> 52:58.940
是不是可以把上下纹拿到了

52:58.940 --> 52:59.500
对不对

52:59.500 --> 53:00.780
拿到上下纹过后

53:00.780 --> 53:01.580
那么我们拿到

53:01.580 --> 53:03.660
是不是可以拿到这个dispatch这个函数

53:03.660 --> 53:04.380
从哪里拿

53:04.380 --> 53:06.780
是不是从这个z.context里边

53:06.860 --> 53:07.900
找到什么Stone

53:07.900 --> 53:09.420
看一下上下纹

53:09.420 --> 53:11.180
上下纹里边的数据

53:11.180 --> 53:12.940
value里边是什么一个Stone

53:12.940 --> 53:13.500
对吧

53:13.500 --> 53:15.100
Stone里边是一个dispatch

53:15.100 --> 53:15.580
对不对

53:15.580 --> 53:17.180
dispatch

53:17.180 --> 53:18.300
第二dispatch

53:18.300 --> 53:19.420
是不是可以拿到

53:19.420 --> 53:21.260
拿到过后是不是触发就完事了

53:21.260 --> 53:22.540
触发这个redux

53:22.540 --> 53:23.660
x

53:23.660 --> 53:24.460
redux

53:24.460 --> 53:26.140
x就完事了

53:26.140 --> 53:26.540
对不对

53:26.540 --> 53:28.620
这就是nation的作用

53:28.620 --> 53:28.940
好

53:28.940 --> 53:30.220
现在我们就写完了

53:30.220 --> 53:32.380
保存看一下

53:32.380 --> 53:33.100
看一下

53:33.100 --> 53:34.220
我们看一下我们的

53:34.220 --> 53:36.060
就是仓库变化

53:36.140 --> 53:37.660
点击课程列表

53:38.780 --> 53:39.900
你看是不是变了

53:39.900 --> 53:40.300
对吧

53:40.300 --> 53:41.020
课程列表

53:41.020 --> 53:41.660
location

53:41.660 --> 53:42.380
对不对

53:42.380 --> 53:43.020
看状态

53:44.460 --> 53:45.820
是不是x

53:45.820 --> 53:47.260
push

53:47.260 --> 53:48.540
location.cos

53:48.540 --> 53:49.260
对吧

53:49.260 --> 53:49.500
好

53:49.500 --> 53:50.540
然后再来

53:50.540 --> 53:51.340
添加课程

53:51.340 --> 53:52.620
因为地址一变

53:52.620 --> 53:53.500
地址一变

53:53.500 --> 53:55.740
它是不是一定会触发这个相应的x

53:55.740 --> 53:56.540
对吧

53:56.540 --> 53:57.820
相应的x

53:57.820 --> 53:58.620
你看

53:58.620 --> 53:59.660
这里监听的d

53:59.660 --> 54:00.540
监听history

54:00.540 --> 54:03.420
无论你是用什么方式来改变的地址

54:03.420 --> 54:04.380
一定是通过history

54:04.380 --> 54:05.580
最终一定是通过history

54:06.300 --> 54:06.780
history

54:06.780 --> 54:07.660
因为是同一个对象

54:07.660 --> 54:08.380
只要它一变

54:08.380 --> 54:10.300
那么去触发对哪个形去改变

54:10.860 --> 54:11.900
才能新的状态

54:11.900 --> 54:12.380
你看看

54:12.380 --> 54:13.740
是不是完全同步了

54:13.740 --> 54:14.300
对吧

54:14.940 --> 54:15.820
哪怕你自己

54:15.820 --> 54:17.740
你自己去用这种方式来触发

54:17.740 --> 54:18.860
点击这里来触发

54:19.500 --> 54:20.300
也可以

54:20.300 --> 54:21.020
完成同步

54:21.020 --> 54:21.900
看呗

54:21.900 --> 54:22.780
也可以完成同步

54:23.580 --> 54:23.660
好

54:23.660 --> 54:24.780
这就是这么一个原理

54:24.780 --> 54:25.980
当然这里还有一件事

54:25.980 --> 54:26.220
就是

54:27.340 --> 54:29.180
要你再把取消对不对

54:29.180 --> 54:29.740
unnation

54:30.540 --> 54:31.660
你再把取消

54:31.660 --> 54:33.580
当这个组建销毁的时候

54:33.580 --> 54:34.620
component

54:34.700 --> 54:35.820
will amount

54:36.700 --> 54:38.140
当这个组建销毁的时候

54:38.140 --> 54:39.980
那么你得unnation

54:39.980 --> 54:41.020
取消监听

54:41.020 --> 54:42.620
不要再去触发这个一个形容

54:43.660 --> 54:44.460
就写完了

54:44.460 --> 54:45.820
其实核心的东西

54:45.820 --> 54:46.780
就这么一点点

54:46.780 --> 54:47.420
就这么一点点

54:47.420 --> 54:49.020
它本来这个库的代码就不多

54:49.740 --> 54:50.060
好吧

54:50.060 --> 54:51.820
这个库其实也很简单

54:51.820 --> 54:53.260
其实我希望通过

54:53.260 --> 54:54.380
讲解圆满了

54:54.380 --> 54:56.140
是能够给大家提供一些

54:56.140 --> 54:58.060
解决问题的思路

54:58.060 --> 54:59.180
而不是说

54:59.180 --> 55:00.860
去使尽背这些圆满

55:00.860 --> 55:01.660
毫无意义

55:01.660 --> 55:02.220
我告诉你

55:02.220 --> 55:03.340
理解这个圆满屁用了

55:03.340 --> 55:03.980
这个玩意儿

55:04.060 --> 55:04.940
你这个库呢

55:04.940 --> 55:06.060
你这个库用了

55:06.060 --> 55:06.700
有那么多吗

55:08.220 --> 55:09.500
还有那么一点点多

55:09.500 --> 55:10.620
有那么一点点多

55:10.620 --> 55:11.100
但是呢

55:11.740 --> 55:13.340
你学这个库的圆满了

55:13.340 --> 55:14.140
核心作用不是

55:14.140 --> 55:15.180
也要把这个库理解的

55:15.180 --> 55:15.900
多么透彻

55:15.900 --> 55:16.940
那个不是重点

55:16.940 --> 55:17.980
那你如果说你

55:17.980 --> 55:19.020
我花这么多时间

55:19.020 --> 55:19.900
讲圆满

55:19.900 --> 55:21.820
仅仅是为了理解这一个库

55:21.820 --> 55:22.620
它的特点的话

55:23.340 --> 55:24.060
那就太

55:24.060 --> 55:25.020
意义太小了

55:25.020 --> 55:25.900
真的太小了

55:25.900 --> 55:28.140
我们是希望通过圆满了

55:28.140 --> 55:29.020
告诉了很多

55:29.020 --> 55:30.060
就是已经工作了

55:30.060 --> 55:31.180
一两年的同学

55:31.180 --> 55:32.300
想要提高的同学

55:32.300 --> 55:33.740
给你们开阔一些事业

55:34.060 --> 55:34.860
当你们遇到

55:34.860 --> 55:36.540
以后遇到类似问题的时候

55:36.540 --> 55:39.100
你们应该用什么样的思路去解决

55:39.100 --> 55:40.780
打开这种思路

55:40.780 --> 55:42.620
这才是讲解圆满的作用

55:42.620 --> 55:44.220
所以说你看我讲解圆满的时候

55:44.220 --> 55:45.740
我不太会把那个

55:45.740 --> 55:46.780
github打开

55:46.780 --> 55:49.100
github这样圆满是怎么写的

55:49.100 --> 55:50.060
这一行它是怎么写的

55:50.620 --> 55:51.900
没有啥意义

55:51.900 --> 55:53.980
我们就是来尝试来解决这个问题

55:53.980 --> 55:55.420
它不是有要解决问题吗

55:55.420 --> 55:56.940
OK我们就来尝试解决个问题

55:56.940 --> 55:58.380
我们会发现问题解决过程中

55:58.380 --> 55:59.500
会遇到一些困难

55:59.500 --> 56:00.380
那么这个时候呢

56:00.380 --> 56:01.100
我们再尝试

56:01.100 --> 56:01.980
看一下想想

56:01.980 --> 56:03.100
它为什么要这样做

56:03.100 --> 56:04.140
它为什么这样做

56:04.140 --> 56:05.260
能不能解决这个问题

56:05.260 --> 56:07.420
就可以帮我们打开这个思路

56:07.420 --> 56:08.060
没有这意思吗

56:08.060 --> 56:10.380
这才是讲解圆满的作用

56:10.380 --> 56:11.660
好了还是老规矩

56:11.660 --> 56:13.260
下来一定要去写一下

56:13.260 --> 56:14.460
你都要听完了

56:14.460 --> 56:15.420
你肯定要把它写一下

56:15.420 --> 56:17.020
不然的话你听到白听

56:17.020 --> 56:18.540
反正我反复强调了

56:18.540 --> 56:19.820
这个咱们学开发的话

56:19.820 --> 56:20.700
你不去做

56:20.700 --> 56:21.740
你不去写

56:21.740 --> 56:22.620
然后你听到东西

56:22.620 --> 56:23.900
真的是等于白听

56:23.900 --> 56:25.340
听到就很快就忘了

56:25.340 --> 56:26.780
转个眼睡觉就忘了

56:26.780 --> 56:28.380
好先来把它写一下

56:28.380 --> 56:29.580
好这是这一块

