WEBVTT

00:00.620 --> 00:09.340
接着来 上一课咱们写了这么四个affect

00:09.340 --> 00:14.340
它的原理就是它们这些函数返回一个affect object的描述对象

00:14.340 --> 00:21.820
然后有Rom Saga来调用对应的处理函数去处理这个对象

00:21.820 --> 00:23.380
来完成一些功能

00:23.380 --> 00:26.740
那么现在还剩下一些 这些东西就不是很好写了

00:26.740 --> 00:28.740
不是很好写了 会有点绕

00:28.940 --> 00:33.300
我们首先这里先把这两个写出来take和fork

00:33.300 --> 00:36.180
这两个写出来过后你会觉得基本上就完成了

00:36.180 --> 00:38.460
关键是这两个不是那么好写

00:38.460 --> 00:41.540
一个个来 首先我们先来写一个take

00:41.540 --> 00:45.020
首先我们来想想 先把那个type加上

00:45.020 --> 00:48.620
内容多了一个叫做take

00:48.620 --> 00:51.940
为什么呢 因为这个take它有主色效果

00:51.940 --> 00:54.460
它需要等待 等什么呢

00:54.500 --> 01:01.460
等到那个就是当对应的action发生了之后

01:01.460 --> 01:03.300
它才会继续运行 对吧

01:03.300 --> 01:06.140
它会有这么一个效果 它需要等待

01:06.140 --> 01:13.460
那么这个等待就不是那么简单了

01:13.460 --> 01:15.780
那怎么等待呢 它是这样子

01:15.780 --> 01:16.900
我给大家画个图

01:16.900 --> 01:18.620
这个take 我们先把这个写出来

01:18.620 --> 01:23.420
先把内容写出来再把这个加上take 解释

01:23.420 --> 01:26.260
这里肯定要导出两个函数 这是毫无疑问的

01:26.260 --> 01:29.580
一个是take 本身是这个函数

01:29.580 --> 01:32.300
然后再来导出一个函数

01:32.300 --> 01:35.020
就是wrong take effect

01:35.020 --> 01:37.180
这个格式是固定的

01:37.180 --> 01:40.580
然后这里这个参数也是一样的

01:40.580 --> 01:42.900
参数也是一样的 放过来

01:42.900 --> 01:45.020
导出这两个函数 这是毫无疑问的

01:45.020 --> 01:48.780
然后in这个手里边 我们要把take那个函数导出

01:48.780 --> 01:52.340
take 只导出take函数就行了

01:52.380 --> 01:53.740
然后还有什么呢

01:53.740 --> 01:56.260
还有wrong effect里面

01:56.260 --> 01:58.700
就是把这些该处理的 该处理的

01:58.700 --> 02:00.260
这里要导入一个take

02:00.260 --> 02:04.220
它的处理函数叫做wrong take effect

02:04.220 --> 02:08.340
好 我们这里写上case wrong

02:08.340 --> 02:13.660
就是affect types 第二 take

02:13.660 --> 02:17.380
好 这里拿我们写wrong take effect

02:17.380 --> 02:23.710
传进去 next break

02:24.270 --> 02:25.830
然后接下来我们来看周里边

02:25.830 --> 02:28.990
关键周里边不是那么好写

02:28.990 --> 02:30.910
首先这个函数倒好写

02:30.910 --> 02:32.590
这个函数它就是给我一个啥

02:32.590 --> 02:34.470
还记得吗 咱们take怎么用的

02:34.470 --> 02:36.430
当时我们只怎么用take的

02:36.430 --> 02:37.430
take我们是这样子

02:37.430 --> 02:41.790
我们比方说到这个saga里边

02:41.790 --> 02:44.710
然后比方说我们这里引入一个take

02:44.710 --> 02:46.270
导入我们自己写的take

02:46.270 --> 02:51.710
take就是说当我们去接收take

02:51.710 --> 02:52.990
接收一个action 对吧

02:53.030 --> 02:54.510
那么这里是不是要写个action

02:54.510 --> 02:55.670
对吧action的类型

02:55.670 --> 02:57.310
你可以写字无创也可以写别的东西

02:57.310 --> 02:59.790
比方说我们这里写上这么一个action类型

02:59.790 --> 03:01.510
把action类型导入进来

03:01.510 --> 03:04.590
action types 把导入进来

03:04.590 --> 03:06.430
我们接收的taps是什么

03:06.430 --> 03:10.110
是increase

03:10.110 --> 03:14.750
就是一步增加

03:14.750 --> 03:16.150
这里写个delay

03:16.150 --> 03:19.710
比方说它这个会返回什么

03:19.710 --> 03:21.750
返回一个完整的action对象

03:21.950 --> 03:23.230
我们这里输出一下

03:23.230 --> 03:25.550
完整的action

03:25.550 --> 03:26.910
这里输出一下

03:26.910 --> 03:28.590
然后我们一步增加怎么做呢

03:28.590 --> 03:29.990
一步增加我们就这样子

03:29.990 --> 03:32.910
给它一个delay

03:32.910 --> 03:33.950
1000

03:33.950 --> 03:36.590
前面不要忘记写eo

03:36.590 --> 03:41.670
1000毫秒之后咱们去扑扯一个increase

03:41.670 --> 03:44.070
好 行了 咱们写成这么一种格式

03:44.070 --> 03:45.710
没问题吧

03:45.710 --> 03:48.070
那么现在关键是take

03:48.070 --> 03:50.150
take还要等待一直卡在这

03:50.150 --> 03:52.390
要等待action的发生

03:52.390 --> 03:54.150
action发生了之后

03:54.150 --> 03:55.470
它再会继续处理

03:55.470 --> 03:56.910
那么这个逻辑是什么

03:56.910 --> 03:59.550
这个逻辑其实就是一个订阅者模式

03:59.550 --> 04:01.230
或者叫做监听者模式

04:01.230 --> 04:03.150
这种模式咱们在书写之前

04:03.150 --> 04:05.030
书写rotor的时候是不是书写过的

04:05.030 --> 04:06.470
对吧 它是这么一回事

04:06.470 --> 04:08.830
就是当我们take的时候

04:08.830 --> 04:11.150
当我们产生一个take的时候

04:11.150 --> 04:13.510
这个Rom Saga它会往一个

04:13.510 --> 04:15.750
我们这里先开一个图

04:16.750 --> 04:22.820
这里是take

04:22.820 --> 04:24.180
这是take函数

04:24.180 --> 04:26.220
它会返回一个对象

04:26.220 --> 04:27.860
对吧 它会返回一个什么对象

04:27.860 --> 04:30.180
一个affix描述对象

04:30.180 --> 04:31.980
会返回一个take描述对象

04:31.980 --> 04:36.100
这个描述对象里面的payload的

04:36.100 --> 04:39.140
type等于take

04:39.140 --> 04:40.100
type等于take

04:40.100 --> 04:42.300
大写的take

04:42.300 --> 04:44.580
然后它的payload里面

04:44.580 --> 04:46.260
它会加上这么一个东西

04:46.380 --> 04:48.100
我这里把画一下

04:48.100 --> 04:48.820
稍微的画一下

04:51.420 --> 04:53.140
它的payload里面会加上

04:53.140 --> 04:55.260
就是你要等待的x类型

04:55.260 --> 04:56.540
x

04:56.540 --> 04:58.860
x type

04:58.860 --> 05:00.060
这是你传过去了 对吧

05:00.060 --> 05:01.420
传过去了x类型

05:01.420 --> 05:03.900
类型比方说咱们等待的类型

05:03.900 --> 05:06.540
是async increase

05:06.540 --> 05:07.500
这是我们

05:07.500 --> 05:08.860
它这是take这个函数

05:08.860 --> 05:10.460
产生了一个描述对象

05:10.460 --> 05:12.380
那么这个描述对象会交给谁呢

05:12.420 --> 05:13.860
会交给

05:13.860 --> 05:15.020
会交给一个

05:15.020 --> 05:17.700
就是long take effect

05:17.700 --> 05:18.340
这个描述对象

05:18.340 --> 05:19.900
会到时候这个函数来处理

05:19.900 --> 05:21.980
就是long take effect

05:21.980 --> 05:23.020
这个函数来处理

05:23.020 --> 05:24.580
来处理这个描述对象

05:24.580 --> 05:26.380
那么它怎么来处理这个描述对象呢

05:26.380 --> 05:28.460
这里它用到了一个监听者模式

05:28.460 --> 05:30.180
也叫做订阅者模式

05:30.180 --> 05:31.140
它怎么做的呢

05:31.140 --> 05:32.500
它是

05:32.500 --> 05:34.340
首先有一个订阅器

05:34.340 --> 05:35.220
一个订阅器

05:35.220 --> 05:36.780
比方说我们这里的一个订阅器

05:36.780 --> 05:38.260
叫做channel

05:38.260 --> 05:40.340
官方的元代码里面

05:40.340 --> 05:41.420
把它叫做channel

05:41.420 --> 05:42.700
这么一个订阅器

05:42.700 --> 05:44.780
这个订阅器里面它提供了

05:44.780 --> 05:45.700
一个就是

05:45.700 --> 05:47.820
可以通过这个订阅器来进行订阅

05:47.820 --> 05:49.540
它里面提供了两个函数

05:49.540 --> 05:50.820
一个是

05:50.820 --> 05:52.260
一个叫做take

05:52.260 --> 05:53.580
一个叫做put

05:53.580 --> 05:54.620
这两个函数

05:54.620 --> 05:56.300
看名字不是那么好理解

05:56.300 --> 05:57.300
take什么意思呢

05:57.300 --> 05:59.220
take是给它加一个监听

05:59.220 --> 06:00.260
给它加一个监听

06:00.260 --> 06:01.820
put表示的是

06:01.820 --> 06:03.100
触发一个监听

06:03.100 --> 06:04.700
触发一个监听

06:04.700 --> 06:05.260
一个take

06:05.260 --> 06:06.260
一个put

06:06.260 --> 06:06.940
这两个函数

06:06.940 --> 06:07.940
take表示什么

06:07.940 --> 06:09.180
添加一个监听器

06:10.180 --> 06:14.900
添加一个监听器

06:15.900 --> 06:17.220
添加一个监听器

06:17.220 --> 06:22.620
put表示触发监听函数

06:22.620 --> 06:23.220
对吧

06:23.220 --> 06:24.420
触发监听函数

06:24.420 --> 06:25.460
那么也就是说take

06:25.460 --> 06:27.140
收网这个channel

06:27.140 --> 06:28.980
这个东西里边加一个什么

06:28.980 --> 06:30.780
加一个就是

06:30.780 --> 06:32.180
加一个函数进去

06:32.180 --> 06:33.900
只是纯粹的加一个函数进去

06:33.900 --> 06:35.620
它不会运行函数

06:35.620 --> 06:37.780
因为这个函数要等到什么时候运行

06:37.900 --> 06:39.060
需要等到

06:39.060 --> 06:40.140
那个

06:40.140 --> 06:42.180
当我们x发生的时候才会运行

06:42.180 --> 06:42.620
对吧

06:42.620 --> 06:45.980
put成了它是来触发监听函数的

06:45.980 --> 06:46.460
对不对

06:46.460 --> 06:47.620
所以说这个channel里边

06:47.620 --> 06:48.460
你可以想象

06:48.460 --> 06:50.180
它维护了

06:50.180 --> 06:52.540
维护了一个对象

06:52.540 --> 06:53.740
维护了一个对象

06:53.740 --> 06:54.380
对象的

06:54.380 --> 06:56.620
你可以认为对象的属性名

06:56.620 --> 06:58.980
就指的是这个x的类型

06:58.980 --> 06:59.540
比方说

06:59.540 --> 07:02.700
咱们这里不是那么好理解

07:02.700 --> 07:04.060
比方说咱们这一个函数

07:04.060 --> 07:05.180
这个是channel

07:05.180 --> 07:07.180
channel

07:07.220 --> 07:08.820
channel里边它维护了一个对象

07:08.820 --> 07:09.820
比方说nationals

07:11.540 --> 07:13.380
这是个

07:13.380 --> 07:14.420
它维护了这么一个对象

07:14.420 --> 07:15.020
channel里边

07:16.220 --> 07:16.700
nationals

07:18.540 --> 07:19.860
那么这里是个对象

07:19.860 --> 07:20.940
为什么要加个对象呢

07:20.940 --> 07:23.860
因为它可能会有很多的take

07:23.860 --> 07:25.220
监听不同的x型

07:25.220 --> 07:25.820
对吧

07:25.820 --> 07:27.100
那么每一个x型

07:27.100 --> 07:28.620
我们对象里面的属性名

07:28.620 --> 07:29.540
那就是x型的名字

07:29.540 --> 07:33.580
比方它的属性名是a think increase

07:33.580 --> 07:35.340
那么这个属性它是一个数组

07:35.380 --> 07:38.060
这个数组里边存上了一个很多的函数

07:38.060 --> 07:39.460
它是这么一种结构

07:39.460 --> 07:41.900
它存上存了很多函数进去

07:41.900 --> 07:44.340
当到时候发生x型的时候

07:44.340 --> 07:45.340
当我们发生

07:45.340 --> 07:47.500
比方说我们到时候dispatch

07:47.500 --> 07:48.300
一个x型

07:48.300 --> 07:49.620
这个x型的是这个x型

07:49.620 --> 07:51.020
我们这里就用伟代码

07:51.020 --> 07:52.060
伟代码来说明一下

07:52.060 --> 07:53.740
这种当然这里肯定不能是这不算

07:53.740 --> 07:54.340
是一个对象

07:54.340 --> 07:55.500
x型对象对吧

07:55.500 --> 07:56.900
到时候我们触发一个x型

07:56.900 --> 07:58.100
还是写完

07:58.100 --> 07:59.700
当我们触发一个x型的时候

08:00.860 --> 08:02.300
触发这么一个x型的时候

08:02.300 --> 08:03.340
那么我们要干嘛

08:03.380 --> 08:05.100
我们要去运行

08:05.100 --> 08:06.940
这个对象里边的

08:06.940 --> 08:09.620
对应的这个属性里边的所有函数

08:09.620 --> 08:10.180
对吧

08:10.180 --> 08:11.820
运行这个所有函数

08:11.820 --> 08:13.060
它实际上是这么一种结构

08:13.060 --> 08:15.540
因为每个take它坚定的不一样

08:15.540 --> 08:17.300
所以说我们这里用属性来区别

08:17.300 --> 08:18.380
因为属性的话

08:18.380 --> 08:19.540
它一定是唯一的

08:19.540 --> 08:22.020
它不可能存在两个同名的属性名字

08:22.020 --> 08:24.140
我们这里可以用属性来进行区别

08:24.140 --> 08:25.820
然后一个take它坚定的是这个

08:25.820 --> 08:27.540
另外一个take坚定的是别的

08:27.540 --> 08:30.660
比方说a think decrease

08:30.660 --> 08:31.060
对吧

08:31.060 --> 08:32.340
它可能坚定的别的

08:32.340 --> 08:33.900
另外有个方可1

08:33.900 --> 08:36.220
可能只有一个任务在坚定这个

08:36.220 --> 08:37.700
因为我们到时候会启动多个任务

08:37.700 --> 08:40.340
每个任务它里面都可能有take在坚定

08:40.340 --> 08:42.380
所以说我们到时候触发一个型的时候

08:42.380 --> 08:44.940
要去运行这里的所有函数

08:44.940 --> 08:45.980
而且运行完了过后

08:45.980 --> 08:47.340
我们还要把属性删掉

08:47.340 --> 08:47.660
为什么

08:47.660 --> 08:49.540
因为take它只运行一次

08:49.540 --> 08:50.020
对吧

08:50.020 --> 08:50.740
只运行一次

08:50.740 --> 08:51.540
只坚定一次

08:51.540 --> 08:54.340
所以我们要把对应的属性删掉

08:54.340 --> 08:56.260
因此我们这里要完成take

08:56.260 --> 08:57.940
首先得完成这个channel

08:57.940 --> 08:59.620
首先得完成这个channel

08:59.620 --> 09:01.580
那么这个channel我们在这里建个文件

09:01.620 --> 09:03.180
叫做createchannel

09:03.180 --> 09:05.060
或者直接建个构造函数也行

09:05.060 --> 09:06.580
比方说我们建个构造函数

09:06.580 --> 09:07.380
解释

09:07.380 --> 09:09.380
这里我们导出一个内

09:09.380 --> 09:12.180
classchannel

09:12.180 --> 09:13.180
导出这么一个内

09:13.180 --> 09:14.780
或者是我们用createchannel都行

09:14.780 --> 09:16.580
都行

09:16.580 --> 09:18.980
其实这么一个构造函数导出这么一个内

09:18.980 --> 09:19.180
好

09:19.180 --> 09:21.860
这个内里边我们首先给它写个属性

09:21.860 --> 09:23.060
nationers

09:23.060 --> 09:25.900
内部的属性

09:25.900 --> 09:27.060
就表示监听

09:27.060 --> 09:27.820
它是个什么东西

09:27.820 --> 09:29.460
它是个对象

09:29.460 --> 09:31.180
它有这么一个属性

09:31.180 --> 09:33.740
这个channel里边它提供两个方法

09:33.740 --> 09:35.580
一个方法是take

09:35.580 --> 09:36.780
打上这个注释

09:36.780 --> 09:37.820
一个take方法

09:37.820 --> 09:39.380
这个方法干嘛用的

09:39.380 --> 09:44.180
你给我传一个属性的名字

09:44.180 --> 09:46.180
然后给我传一个函数

09:46.180 --> 09:48.660
给我传个函数

09:48.660 --> 09:51.580
就是添加一个监听者

09:51.580 --> 09:56.040
或者要订阅者

09:56.040 --> 09:57.920
添加一个订阅者take

09:57.920 --> 09:59.280
take就是拿过来

09:59.280 --> 10:01.680
拿过来我们放到对象的

10:01.680 --> 10:03.840
当然这种函数的名字其实无所谓的

10:03.840 --> 10:05.520
你可以随便取其他名字

10:05.520 --> 10:06.760
添加一个订阅者

10:06.760 --> 10:08.000
但是这个也要take跟那个

10:08.000 --> 10:09.520
我们的affiliate take两把刷

10:09.520 --> 10:11.560
只是同名字而已

10:11.560 --> 10:13.040
那么这个proper什么意思呢

10:13.040 --> 10:15.200
就是属性名

10:15.200 --> 10:17.680
就是要往我们的监听器里面加的属性名

10:17.680 --> 10:19.880
那么这里的应该就是一个action type

10:19.880 --> 10:20.520
对吧

10:20.520 --> 10:25.600
方可就表示的是订阅函数

10:25.600 --> 10:26.880
那么这个take怎么来完成了

10:26.880 --> 10:27.440
怎么写呢

10:27.440 --> 10:28.520
其实特别简单

10:28.520 --> 10:29.880
我们首先判断一下

10:29.920 --> 10:31.160
这个nationer

10:31.160 --> 10:32.280
this.nationer里边

10:32.280 --> 10:34.040
有没有这个属性

10:34.040 --> 10:35.360
有没有这个属性

10:35.360 --> 10:36.800
看一下有没有这个属性

10:36.800 --> 10:38.280
如果说有这个属性的话

10:38.280 --> 10:39.600
说明这个属性已经存在了

10:39.600 --> 10:40.000
对吧

10:40.000 --> 10:40.680
已经存在了

10:40.680 --> 10:42.000
它已经是一个数组了

10:42.000 --> 10:43.880
那么我们往这个数组里面加一个函数

10:43.880 --> 10:45.240
就完成了

10:45.240 --> 10:48.200
this.nationers.poosh

10:48.200 --> 10:50.240
加对应的这个属性

10:50.240 --> 10:51.280
这个属性是一个函数

10:51.280 --> 10:53.280
然后poosh加上一个监听函数

10:53.280 --> 10:54.920
就完成了

10:54.920 --> 10:58.160
添加监听函数

10:58.240 --> 11:00.400
然后如果说

11:00.400 --> 11:03.840
就是它没有这个属性

11:03.840 --> 11:04.440
else

11:04.440 --> 11:05.960
它没有这个属性

11:05.960 --> 11:06.960
那么没有这个属性

11:06.960 --> 11:10.520
我就把这个属性初始化为一个数组

11:10.520 --> 11:12.480
这个数组里面只有一个函数

11:12.480 --> 11:13.600
只有这么一个函数

11:13.600 --> 11:13.840
对吧

11:13.840 --> 11:14.840
这就是take的写法

11:14.840 --> 11:16.640
非常非常简单

11:16.640 --> 11:18.520
就是维护这么一个对象

11:18.520 --> 11:19.640
这个对象里面

11:19.640 --> 11:20.960
你始终就有这种格式

11:20.960 --> 11:23.400
这个nationer是这么一种格式的对象

11:23.400 --> 11:24.880
那么你给我一个属性名

11:24.880 --> 11:26.720
然后给我你要添加的函数

11:26.720 --> 11:27.480
那么我判断一下

11:27.480 --> 11:28.760
这个属性是不是存在的

11:28.760 --> 11:29.400
比方说一开始

11:29.400 --> 11:30.480
它不存在这个属性

11:30.480 --> 11:31.080
不存在

11:31.080 --> 11:32.720
那么你这里调用了这个take

11:32.720 --> 11:33.840
你调用了这个take

11:33.840 --> 11:37.400
给它传了一个sync decrease

11:37.400 --> 11:38.280
传了这么一个东西来

11:38.280 --> 11:39.640
然后传了一个函数进去

11:39.640 --> 11:39.920
对吧

11:39.920 --> 11:41.160
传了一个函数进去

11:41.160 --> 11:42.280
那么它会怎么做呢

11:42.280 --> 11:43.080
它就会在这里

11:43.080 --> 11:43.600
它判断

11:43.600 --> 11:45.320
没有这个属性

11:45.320 --> 11:46.920
我把这个属性给它加上

11:46.920 --> 11:48.520
给它初始化为一个数组

11:48.520 --> 11:50.360
这个数组里面只有这个函数

11:50.360 --> 11:51.240
只有这个函数

11:51.240 --> 11:52.120
就这么个意思

11:52.120 --> 11:53.360
如果说已经存在这个函数了

11:53.360 --> 11:56.080
就往这个函数数里面加一下

11:56.120 --> 11:57.560
你看一下

11:57.560 --> 11:57.960
好

11:57.960 --> 12:00.160
另外一个对应的函数就是put

12:00.160 --> 12:02.400
put表示触发

12:02.400 --> 12:03.960
就是发布一个订阅

12:03.960 --> 12:06.240
就是触发减击函数

12:06.240 --> 12:07.120
就发布一个订阅

12:07.120 --> 12:07.760
就订阅模式

12:07.760 --> 12:08.600
添加订阅

12:08.600 --> 12:09.240
发布订阅

12:09.240 --> 12:09.680
发布订阅

12:09.680 --> 12:11.440
就是让那些订阅者开始行动

12:11.440 --> 12:12.440
行动起来

12:12.440 --> 12:12.600
好

12:12.600 --> 12:13.800
那么这个put

12:13.800 --> 12:14.560
put这个函数

12:14.560 --> 12:15.760
你要给我传什么

12:15.760 --> 12:17.360
你要给我传属性名字

12:17.360 --> 12:18.560
你得把属性名字告诉我

12:18.560 --> 12:19.040
不然的话

12:19.040 --> 12:20.600
我在哪里去找呢

12:20.600 --> 12:21.200
对不对

12:21.200 --> 12:23.040
你得把属性名字告诉我

12:23.040 --> 12:25.920
属性名字告诉我了之后

12:26.000 --> 12:26.880
然后干嘛呢

12:26.880 --> 12:28.760
我去我去帮你去触发

12:28.760 --> 12:30.120
帮你去触发

12:30.120 --> 12:31.000
而触发的时候

12:31.000 --> 12:32.600
你可能还要传一个参数进来

12:32.600 --> 12:34.240
还要传参数进来

12:34.240 --> 12:34.560
ok

12:34.560 --> 12:35.680
你传给我就行了

12:35.680 --> 12:36.440
不要让我这里

12:36.440 --> 12:37.720
触发你给我传一些参数

12:37.720 --> 12:38.600
额外的参数

12:38.600 --> 12:40.080
打个数是吧

12:40.080 --> 12:40.280
好

12:40.280 --> 12:43.000
这个是发布一个订阅

12:43.000 --> 12:46.640
也就是说触发监听函数

12:46.640 --> 12:47.960
触发监听函数

12:47.960 --> 12:50.640
这是触发的属性名

12:50.640 --> 12:53.240
然后这是额外的参数

12:53.240 --> 12:54.600
就是我要调用这些函数的时候

12:54.640 --> 12:55.880
给它传递的额外参数

12:55.880 --> 12:57.600
好

12:57.600 --> 12:58.800
那么这是个put

12:58.800 --> 12:59.160
对吧

12:59.160 --> 13:00.280
put

13:00.280 --> 13:00.920
那么接下来

13:00.920 --> 13:01.440
我们来看一下

13:01.440 --> 13:02.720
这里怎么写

13:02.720 --> 13:03.680
其实很简单

13:03.680 --> 13:05.000
如果说我们

13:05.000 --> 13:06.320
这个neson哪里边

13:06.320 --> 13:07.640
neson哪里边

13:07.640 --> 13:09.720
这个属性看它存不存在

13:09.720 --> 13:11.760
如果说这个属性存在的时候

13:11.760 --> 13:12.880
我们才做这件事情

13:12.880 --> 13:13.920
不存在我们啥都不做

13:13.920 --> 13:14.640
对吧

13:14.640 --> 13:15.320
存在的时候

13:15.320 --> 13:16.640
我们是不是拿到一个数组

13:16.640 --> 13:17.080
对吧

13:17.080 --> 13:19.080
数组方形

13:19.080 --> 13:20.840
拿到这么一个数组

13:20.840 --> 13:21.440
通过这个属性

13:21.440 --> 13:23.160
是不是拿到一个监听数组

13:23.160 --> 13:23.800
监

13:23.800 --> 13:29.000
就是订阅函数的数组

13:29.000 --> 13:30.000
拿到这个数组

13:30.000 --> 13:31.480
然后我们是不是循环这个数组

13:31.480 --> 13:32.680
去触发就完事了

13:32.680 --> 13:33.160
对吧

13:33.160 --> 13:34.240
for一起循环

13:34.240 --> 13:35.840
是不是每一次拿到一个函数

13:35.840 --> 13:37.200
每一次拿到一个函数

13:37.200 --> 13:39.680
去运行这个函数就完事了

13:39.680 --> 13:41.440
然后把这个参数给它传进去

13:41.440 --> 13:41.840
对吧

13:41.840 --> 13:42.440
就没了

13:42.440 --> 13:43.600
就没了

13:43.600 --> 13:44.920
这就是铺成模式

13:44.920 --> 13:45.120
好

13:45.120 --> 13:46.200
那么运行完了过后

13:46.200 --> 13:47.320
你千万不要忘记

13:47.320 --> 13:49.520
还要删除

13:49.520 --> 13:50.040
删除听觉

13:50.040 --> 13:51.760
因为像我们那个take要用这个东西

13:51.760 --> 13:52.520
那么这个take

13:52.560 --> 13:53.760
是不是他用了一次

13:53.760 --> 13:54.280
他就没了

13:54.280 --> 13:55.280
对不对

13:55.280 --> 13:56.200
你不要忘记了

13:56.200 --> 13:57.280
还要删除

13:57.280 --> 13:57.960
delete

13:57.960 --> 13:59.400
什么属性呢

13:59.400 --> 14:01.960
listeners prop

14:01.960 --> 14:04.240
移除订阅

14:04.240 --> 14:05.520
就是把这个属性删了

14:05.520 --> 14:07.080
甭管这个属性里面有多少个函数

14:07.080 --> 14:07.920
你全部触发完了

14:07.920 --> 14:08.200
对吧

14:08.200 --> 14:08.880
全部触发完了

14:08.880 --> 14:09.560
把删了

14:09.560 --> 14:11.200
那么将来你要再订阅的话

14:11.200 --> 14:13.320
又重新加这个属性

14:13.320 --> 14:14.840
就形成了这么一种模式

14:14.840 --> 14:16.240
那么我们通过这个勾到函数

14:16.240 --> 14:17.200
六一个channel

14:17.200 --> 14:19.560
那么就表示的是

14:19.600 --> 14:22.120
这是一个订阅频道

14:22.120 --> 14:26.780
订阅频道

14:26.780 --> 14:28.340
前面就是频道了意思

14:28.340 --> 14:29.660
那么我们一个订阅频道了

14:29.660 --> 14:31.300
它里面就维护了一个输主

14:31.300 --> 14:35.540
当然我们这一块只需要一个频道就够了

14:35.540 --> 14:36.860
那么其实官方文道里面

14:36.860 --> 14:38.860
他为了处理更多的细节的话

14:38.860 --> 14:40.100
在某些特殊情况下

14:40.100 --> 14:41.260
他还会有多个频道

14:41.260 --> 14:42.340
但我们这里不管了

14:42.340 --> 14:43.700
只需要一个频道就够了

14:43.700 --> 14:45.460
那么只需要一个频道就够了的话

14:45.460 --> 14:46.700
那么这个频道对象

14:46.700 --> 14:48.060
我们是不是在最开始的时候

14:48.060 --> 14:48.820
就可以创建

14:48.860 --> 14:52.260
并把它作为全局通用的东西放进去

14:52.260 --> 14:52.860
对吧

14:52.860 --> 14:54.140
所以说这个频道对象

14:54.140 --> 14:55.340
我们可以放到这

14:56.100 --> 14:57.420
Rom Saga里边

14:57.420 --> 14:59.540
Rom Saga里边不是在产生一个

15:00.300 --> 15:00.980
不是

15:00.980 --> 15:02.140
在这

15:02.140 --> 15:03.180
在这

15:03.180 --> 15:04.740
创建的中间建议这里

15:04.740 --> 15:06.700
那么这里中间建议在MV里边

15:06.700 --> 15:08.660
这个环境全局

15:08.660 --> 15:09.940
这是一个全局

15:10.940 --> 15:11.820
全

15:12.500 --> 15:14.180
这里就这样的写吧

15:14.180 --> 15:16.740
这是一个全局的环境

15:16.740 --> 15:18.780
环境信息

15:19.340 --> 15:20.620
那么除了一个Stone之外

15:20.620 --> 15:22.260
我还给它创建一个Channel

15:22.260 --> 15:23.140
Channel

15:24.100 --> 15:25.420
我们这里写上一个辨量

15:26.220 --> 15:27.020
写上一个辨量

15:28.540 --> 15:29.620
我看一下创建在哪

15:29.620 --> 15:30.660
创建在哪

15:33.940 --> 15:34.500
就在这

15:34.500 --> 15:35.100
就在这

15:35.900 --> 15:36.620
Channel

15:36.620 --> 15:38.700
Channel我们给它留一个Channel

15:38.700 --> 15:39.180
对吧

15:39.180 --> 15:40.060
给它留一个Channel

15:41.180 --> 15:42.100
创建一个

15:42.100 --> 15:43.500
创建一个就是Channel

15:43.500 --> 15:45.500
那么这里边可以给它添加订阅

15:45.500 --> 15:46.020
也可以

15:46.020 --> 15:47.940
就是所有的订阅都在同一个频道里面

15:48.420 --> 15:49.300
没有别的频道

15:50.340 --> 15:50.580
好

15:50.580 --> 15:53.380
那么这里我们还要改动一下这个中间建

15:54.060 --> 15:58.220
就是全局唯一的频道

15:58.740 --> 15:59.620
订阅频道

16:00.820 --> 16:02.500
那么这个Channel有了之后

16:02.500 --> 16:03.420
我们到这里

16:03.940 --> 16:05.780
当我们去触发一个Icon型的时候

16:05.780 --> 16:07.340
是不是要往这个要去发

16:07.340 --> 16:08.980
我们要去发布订阅

16:08.980 --> 16:10.420
还是要去添加订阅

16:11.620 --> 16:12.380
想一想

16:12.380 --> 16:13.940
触发Icon型的时候

16:13.940 --> 16:15.220
我们是要发布订阅

16:15.220 --> 16:17.340
还是要添加订阅了

16:17.420 --> 16:18.540
是不是发布订阅

16:18.540 --> 16:20.700
就是一件事已经发生了

16:20.700 --> 16:21.580
你要去处理

16:21.580 --> 16:21.860
对吧

16:21.860 --> 16:22.700
你们去处理

16:22.700 --> 16:25.460
之前添加的订阅全部要去处理

16:25.460 --> 16:26.780
那么这一块

16:26.780 --> 16:30.300
它的官方就是人大马里边是怎么写的呢

16:30.300 --> 16:30.980
它是这样子

16:30.980 --> 16:33.060
首先把它交给下个中间建去处理

16:33.060 --> 16:34.980
下个中间建一次去处理完

16:34.980 --> 16:36.020
处理完了过后

16:36.020 --> 16:37.180
我再去发布订阅

16:37.180 --> 16:39.620
所以说它这里用一个变量把它保存起来

16:39.620 --> 16:41.740
就是先交给下个中间建处理

16:41.740 --> 16:43.180
处理完了过后你会得到一个结果

16:43.180 --> 16:44.140
管理是什么呢

16:44.140 --> 16:45.420
是你们的事情

16:45.420 --> 16:46.340
跟我们没关系

16:46.380 --> 16:48.100
然后我再去发布订阅

16:48.100 --> 16:49.540
发布订阅

16:50.980 --> 16:51.580
对不对

16:51.580 --> 16:52.700
所以说要发布订阅

16:52.700 --> 16:53.860
发布订阅的话

16:53.860 --> 16:54.940
我们这里使用什么

16:54.940 --> 16:58.300
就是env.channel

16:58.300 --> 17:00.700
那么那边是不是用put

17:00.700 --> 17:01.140
对吧

17:01.140 --> 17:02.300
发布一个订阅

17:02.300 --> 17:03.460
发布一个订阅

17:03.460 --> 17:04.820
属性名是啥呢

17:04.820 --> 17:06.900
属性名就是x的type

17:06.900 --> 17:07.860
这是属性名

17:09.100 --> 17:09.940
然后呢

17:09.940 --> 17:11.100
顾外的参数有啥呢

17:11.100 --> 17:12.740
顾外的参数就把x传给你

17:12.740 --> 17:14.620
把整个x对象传给你

17:14.620 --> 17:15.420
对吧

17:15.580 --> 17:18.180
我们这里就完成一个发布订阅了

17:18.180 --> 17:18.820
发布订阅了

17:18.820 --> 17:21.140
最终我们还是把这轮道子返回

17:21.140 --> 17:23.020
所以说它的处理逻辑

17:23.020 --> 17:24.940
就是说我先交给下个中间建

17:24.940 --> 17:25.660
你们去处理

17:25.660 --> 17:26.460
处理完了过后

17:26.460 --> 17:27.940
我再发布我的订阅

17:27.940 --> 17:29.820
然后发布我的订阅之前的参加

17:29.820 --> 17:31.780
就是订阅了这个x型的类型的人

17:31.780 --> 17:33.420
订阅了相应的x型的类型的人

17:33.420 --> 17:34.780
是不是就可以行动了

17:34.780 --> 17:35.220
对吧

17:35.220 --> 17:36.100
就可以行动了

17:36.100 --> 17:37.980
那么这里中间建这部分

17:37.980 --> 17:39.220
我们把它改造完成了

17:39.220 --> 17:40.460
变成这个样子

17:41.460 --> 17:44.420
那么现在我们再回过头来看这个take

17:44.460 --> 17:46.700
take还其实做的事情就很简单

17:46.700 --> 17:49.020
你给我传一个x型type进来

17:49.020 --> 17:50.700
我给你返回一个啥呢

17:50.700 --> 17:51.900
你看着

17:52.980 --> 17:55.980
把这个放过来

17:55.980 --> 17:59.220
我给你返回一个create effect

17:59.220 --> 18:01.820
类型就是effects type is take

18:01.820 --> 18:02.740
这个类型

18:02.740 --> 18:05.380
然后payload里面就一个东西

18:05.380 --> 18:06.540
x型type

18:06.540 --> 18:08.220
把x型type传给你

18:08.220 --> 18:09.340
传给你完成了

18:09.340 --> 18:10.860
就take是做的事情

18:10.860 --> 18:13.140
关键是runtake

18:13.140 --> 18:14.860
那么runtake它得到这个

18:14.940 --> 18:16.220
得到这个payload之后

18:16.220 --> 18:17.940
它是不是可以拿到x型type

18:17.940 --> 18:18.900
对不对

18:18.900 --> 18:20.580
x型type

18:20.580 --> 18:21.260
这样吧

18:21.260 --> 18:22.740
是不是可以拿到这个x型type

18:22.740 --> 18:24.900
我们拿到这个effects

18:24.900 --> 18:26.820
第二payload

18:26.820 --> 18:28.940
payload 第二x型type

18:28.940 --> 18:30.060
是不是可以拿到

18:30.060 --> 18:32.100
拿到这个x型type之后

18:32.100 --> 18:33.460
是不是立即调用下一个呢

18:33.460 --> 18:33.900
不是

18:33.900 --> 18:36.860
他要等什么等一段时间过后了

18:36.860 --> 18:38.540
这个x型发生了之后才能调到

18:38.540 --> 18:39.780
才能够拿下一个

18:39.780 --> 18:42.740
那么我们是不是可以利用环境里面的channel

18:43.740 --> 18:44.700
channel

18:44.740 --> 18:45.180
对吧

18:45.180 --> 18:47.860
这个频道是不是该添加一个订阅

18:47.860 --> 18:49.300
这个频道不就是在做个算吗

18:49.300 --> 18:50.980
我添加一个订阅订阅这个

18:50.980 --> 18:52.540
订阅这个东西

18:52.540 --> 18:53.660
当它发生的时候

18:53.660 --> 18:54.980
我去做一些事情

18:54.980 --> 18:57.580
所以说我们这里可以调用take

18:57.580 --> 18:59.700
这个channel里面的take方法

18:59.700 --> 19:01.140
是不是添加一个订阅

19:01.140 --> 19:01.420
对吧

19:01.420 --> 19:02.580
添加一个订阅

19:02.580 --> 19:04.100
因为这个channel是在环境里面

19:04.100 --> 19:05.540
全具唯一的

19:05.540 --> 19:06.300
添加一个take

19:06.300 --> 19:07.460
take里面要传什么呢

19:07.460 --> 19:07.940
我们看一下

19:07.940 --> 19:09.500
第一个是不是传一个属性

19:09.500 --> 19:10.340
属性是什么

19:10.340 --> 19:11.740
是不是x型type

19:11.740 --> 19:12.060
对吧

19:12.060 --> 19:12.940
这是我的属性

19:12.940 --> 19:14.460
我要订阅这个东西

19:14.500 --> 19:15.900
到时候发生的时候

19:15.900 --> 19:16.820
什么时候发生

19:16.820 --> 19:17.700
是不是在这里

19:17.700 --> 19:19.900
是不是在中间键里边

19:21.180 --> 19:22.220
在中间键里边

19:22.220 --> 19:22.500
对吧

19:22.500 --> 19:23.740
在这个位置发生的

19:23.740 --> 19:24.300
这个位置

19:24.300 --> 19:25.340
是不是要干嘛

19:25.340 --> 19:27.580
是不是他会去发布订阅

19:27.580 --> 19:28.060
对吧

19:28.060 --> 19:29.260
去触发这些函数

19:29.780 --> 19:31.300
在发布x型的时候

19:31.300 --> 19:33.380
根据x型的内形去触发函数

19:33.380 --> 19:34.660
所以说这一边

19:34.660 --> 19:36.620
我们这里只需要添加订阅就行了

19:36.620 --> 19:38.500
那么当这个订阅发生的时候

19:38.500 --> 19:39.820
第二个是不是处理函数

19:39.820 --> 19:40.340
对吧

19:40.340 --> 19:41.980
当这个订阅发生的时候

19:41.980 --> 19:43.540
我们要去运行这个函数

19:43.620 --> 19:44.660
这个函数是做什么

19:44.660 --> 19:46.740
就是订阅函数

19:47.740 --> 19:48.820
订阅函数

19:48.820 --> 19:52.260
当x型发生的时候

19:52.260 --> 19:54.020
要运行的函数

19:54.020 --> 19:56.740
于是我们就写成这么一种结构了

19:56.740 --> 19:57.780
所以说take这里

19:57.780 --> 19:59.020
如果说有难度的话

19:59.020 --> 19:59.980
关键难度在这

19:59.980 --> 20:01.180
它是一个订阅模式

20:02.940 --> 20:05.220
你只要把这个签诺搞清楚

20:05.220 --> 20:06.140
什么意思

20:06.140 --> 20:08.140
然后搞清楚这一块

20:08.140 --> 20:09.740
它这里在发布订阅

20:09.740 --> 20:10.620
x型发生的时候

20:10.620 --> 20:11.820
我就你去触发吧

20:11.820 --> 20:13.500
我不管你之前注册的哪些函数

20:13.940 --> 20:14.500
有就有

20:14.500 --> 20:15.060
没有就没有

20:15.060 --> 20:15.740
反正你去触发

20:15.740 --> 20:17.060
每个x型我都给你

20:17.060 --> 20:17.780
当然了

20:17.780 --> 20:18.900
如果你没有订阅的话

20:18.900 --> 20:20.700
那我就没有什么任何东西触发

20:20.700 --> 20:21.500
那么这里take

20:21.500 --> 20:23.620
他做的事情就是添加一个订阅而已

20:23.620 --> 20:25.220
那么当我们x型发生的时候

20:25.220 --> 20:26.940
他才会去运行这个函数

20:26.940 --> 20:28.900
那么这个函数你不要干嘛呢

20:28.900 --> 20:29.780
你不要干嘛呢

20:31.340 --> 20:32.980
这里不要做的事情就是

20:32.980 --> 20:34.460
是不是就是调用next

20:34.460 --> 20:35.140
对吧

20:35.140 --> 20:36.060
调用下一个

20:36.060 --> 20:37.420
下一个

20:37.420 --> 20:39.180
下一个我们该传的Values是什么呢

20:39.180 --> 20:40.900
是不是就是真实的

20:40.900 --> 20:42.220
真实的x型

20:42.220 --> 20:42.700
对吧

20:42.740 --> 20:43.740
就是x型对象

20:43.740 --> 20:45.340
那么这个函数里面有个参数

20:45.340 --> 20:46.340
就是x型对象

20:46.340 --> 20:48.900
我们把这个x型对象放进来就完事了

20:48.900 --> 20:50.260
就这么简单

20:50.260 --> 20:51.220
是不是特别简单

20:51.220 --> 20:53.340
你以为多复杂了

20:53.340 --> 20:54.940
非常简单

20:54.940 --> 20:55.900
单码写不了多好

20:55.900 --> 20:57.260
关键是这里稍微有点绕

20:57.260 --> 20:58.100
绕一个圈

20:58.100 --> 20:59.540
就是他有个订阅模式在里边

21:00.700 --> 21:02.300
那么这个参数哪来的

21:02.300 --> 21:04.340
这个参数是不是通过这里传进来的

21:04.340 --> 21:06.100
传到额外参数对吧

21:06.100 --> 21:07.100
我们发布订阅的时候

21:07.100 --> 21:09.220
要往订阅函数里边传到额外参数

21:09.220 --> 21:09.940
那么前脑里边

21:09.940 --> 21:12.580
他就会把这个额外参数传过去

21:12.620 --> 21:14.660
传到这个订阅函数里边去

21:14.660 --> 21:17.500
那么这个订阅函数里边是不是可以收到了

21:17.500 --> 21:17.700
好

21:17.700 --> 21:18.660
那么看一下啊

21:18.660 --> 21:19.980
这个take我们写好了

21:19.980 --> 21:20.900
我们在这里

21:20.900 --> 21:22.260
我们刚才这个saga里边

21:22.260 --> 21:23.580
看一下take管不管用

21:23.580 --> 21:24.700
管不管用

21:24.700 --> 21:25.740
这里我们输出一个

21:26.900 --> 21:28.940
监听

21:28.940 --> 21:29.740
监听啥呢

21:29.740 --> 21:32.260
监听那个x型

21:33.460 --> 21:33.980
x型

21:35.460 --> 21:37.620
taps.async increase

21:38.660 --> 21:38.980
好

21:38.980 --> 21:39.820
保存

21:39.820 --> 21:40.340
大家看一下

21:42.780 --> 21:45.300
他说他说这里没法

21:45.300 --> 21:46.180
没法转换成实均

21:46.180 --> 21:46.580
对吧

21:46.580 --> 21:47.380
那我们这里用都好

21:48.700 --> 21:49.980
保存

21:49.980 --> 21:51.660
右键检查看一下

21:51.660 --> 21:53.220
他现在监听说监听这个玩意

21:53.220 --> 21:53.500
对吧

21:53.500 --> 21:54.060
监听这个玩意

21:54.060 --> 21:55.660
你看现在代码是不是没有运行

21:55.660 --> 21:56.220
卡在这了

21:56.220 --> 21:56.700
对吧

21:56.700 --> 21:57.420
为什么

21:57.420 --> 21:59.980
因为现在只是添加了订阅函数

21:59.980 --> 22:03.420
只是往这个环境里边添加了订阅函数

22:03.420 --> 22:04.820
我们来看一下吧

22:04.820 --> 22:05.260
在哪呢

22:06.500 --> 22:07.620
我在这

22:07.620 --> 22:08.580
是不是往这个函数里

22:08.580 --> 22:10.860
往这个前脑里边添加了一个订阅函数

22:10.860 --> 22:11.460
对吧

22:11.460 --> 22:12.540
添加个订阅函数

22:12.540 --> 22:13.980
但是这个函数是不是没运行

22:13.980 --> 22:16.260
它等到什么时候运行

22:16.260 --> 22:18.660
比方说我们触发一个increase

22:19.420 --> 22:20.620
触发一个increase

22:20.620 --> 22:21.860
有没有运行这个函数

22:21.860 --> 22:22.620
没有

22:22.620 --> 22:23.020
为什么

22:23.020 --> 22:24.300
因为这个

22:24.300 --> 22:25.020
这样子

22:25.020 --> 22:26.700
你触发的x型

22:26.700 --> 22:27.620
你来这

22:27.620 --> 22:28.780
跑这

22:28.780 --> 22:29.700
你铺车的时候

22:29.700 --> 22:30.900
x型type是什么

22:30.900 --> 22:31.900
是increase

22:31.900 --> 22:32.380
对吧

22:32.380 --> 22:33.300
而这个type

22:33.300 --> 22:34.300
它是

22:34.300 --> 22:35.500
lessoners里边

22:35.500 --> 22:36.380
这个lessoners里面

22:36.380 --> 22:37.260
是没有这个属性的

22:37.260 --> 22:38.940
它没有运行任何函数

22:38.940 --> 22:41.140
你只有去触发了对应的x型

22:41.180 --> 22:42.620
而syncincrease

22:42.620 --> 22:43.700
去触发这个过后

22:43.700 --> 22:44.180
你看

22:46.180 --> 22:47.740
触发而syncincrease过后

22:47.740 --> 22:49.260
那么是不是可以得到一个完

22:49.260 --> 22:50.620
那么这个函数来启动了

22:50.620 --> 22:50.860
对吧

22:50.860 --> 22:51.900
这个函数来启动了

22:51.900 --> 22:53.140
它得到在这

22:54.460 --> 22:55.620
然后把它调一个那个词

22:55.620 --> 22:56.740
把x型传进去

22:56.740 --> 22:57.980
那么x型也传进去

22:57.980 --> 23:00.300
那这边是不是可以拿到这个x型了

23:00.300 --> 23:00.580
对吧

23:00.580 --> 23:01.340
x型了

23:01.340 --> 23:01.780
拿到了

23:01.780 --> 23:03.380
那么获得一个完整的x型

23:03.380 --> 23:04.020
是不是这个

23:04.020 --> 23:04.220
对吧

23:04.220 --> 23:05.660
都是一个完整的x型

23:05.660 --> 23:05.900
好

23:05.900 --> 23:06.980
然后呢

23:06.980 --> 23:08.100
等待了一秒钟过后

23:08.100 --> 23:09.100
又去触发了一个什么

23:09.100 --> 23:10.060
触发了一个put

23:10.060 --> 23:10.500
对吧

23:10.500 --> 23:10.900
put

23:10.900 --> 23:11.300
然后呢

23:11.300 --> 23:13.180
就是又去触发了一个increase

23:13.180 --> 23:14.940
把它增加了

23:14.940 --> 23:15.060
好

23:15.060 --> 23:15.620
最后呢

23:15.620 --> 23:17.100
是触发一个监听

23:17.100 --> 23:18.140
因为使循环

23:18.140 --> 23:20.060
又重新监听了

23:20.060 --> 23:21.620
就是这么一个逻辑

23:21.620 --> 23:22.620
就是take

23:22.620 --> 23:24.060
take就写完了

23:24.060 --> 23:24.340
对吧

23:26.420 --> 23:27.420
take写完了

23:27.420 --> 23:28.380
那么接下来呢

23:28.380 --> 23:30.740
我们还是打一个

23:30.740 --> 23:31.700
take写完了

23:31.700 --> 23:32.900
就这一块稍微点绕

23:34.900 --> 23:35.500
那么接下来

23:35.500 --> 23:36.340
来写这个fork

23:37.620 --> 23:39.220
这个fork也不是个

23:39.220 --> 23:40.700
也不是个擅长

23:41.100 --> 23:41.860
fork

23:41.860 --> 23:42.260
来吧

23:42.260 --> 23:43.140
我们写这么一个fork

23:44.900 --> 23:45.700
fork可以写出来

23:45.700 --> 23:46.980
你会发现好的东西都能

23:46.980 --> 23:48.100
都能写出来了

23:48.100 --> 23:49.860
咱们把这个复制一下嘛

23:49.860 --> 23:51.100
fork

23:51.100 --> 23:52.020
改一下名字

23:52.020 --> 23:58.650
fork

23:58.650 --> 23:59.570
这里改一下

23:59.570 --> 24:00.410
改一下名字

24:00.410 --> 24:02.170
这里去掉

24:02.170 --> 24:03.050
runfork

24:03.050 --> 24:04.450
effect

24:04.450 --> 24:04.770
这里呢

24:04.770 --> 24:06.530
index

24:06.530 --> 24:07.370
导出

24:07.370 --> 24:11.330
导出这个fork

24:11.330 --> 24:11.890
这边

24:11.890 --> 24:13.570
effect helper里边

24:13.570 --> 24:18.340
多一个fork

24:18.340 --> 24:20.860
fork

24:20.860 --> 24:21.620
然后呢

24:21.620 --> 24:23.940
然后就是runeffect里边

24:23.940 --> 24:27.230
又多一个fork

24:27.230 --> 24:29.110
fork

24:29.110 --> 24:32.310
这是runfork effect

24:32.310 --> 24:33.030
这里面呢

24:33.030 --> 24:34.710
我们case

24:34.710 --> 24:35.590
effect

24:35.590 --> 24:36.710
taps

24:36.710 --> 24:39.150
fork

24:39.150 --> 24:40.910
这里

24:40.910 --> 24:44.110
我们runtake effect

24:44.110 --> 24:47.230
runfork effect

24:47.230 --> 24:48.350
格式是一样的

24:48.350 --> 24:50.190
格式并没有什么区别

24:50.190 --> 24:51.070
好写好了

24:51.070 --> 24:51.550
那么接下来

24:51.550 --> 24:53.350
我们来完成这个fork

24:53.350 --> 24:54.270
fork干嘛呢

24:54.270 --> 24:55.550
我们回忆一下

24:55.550 --> 24:57.470
fork这里边是不是要传一个函数

24:57.470 --> 24:58.430
这个函数是什么函数

24:58.430 --> 25:00.350
是不是generator方形

25:00.350 --> 25:01.110
对吧

25:01.110 --> 25:02.030
是不是一个就是

25:02.030 --> 25:03.470
你给我传个函数去来运行

25:03.470 --> 25:03.870
对吧

25:03.870 --> 25:04.830
就是一个任务

25:04.830 --> 25:05.150
对吧

25:05.150 --> 25:06.190
一个任务

25:06.190 --> 25:08.550
这里要传一个什么generator

25:08.550 --> 25:12.150
generator方形

25:12.150 --> 25:13.430
说要传一个任务

25:13.430 --> 25:15.270
就是任务就不就是个函数吗

25:15.270 --> 25:16.910
到时候我们用的是怎么用的

25:16.910 --> 25:18.870
再来给我们看一下fork

25:18.870 --> 25:20.630
到时候我们怎么用的fork

25:20.670 --> 25:23.550
比方我们这里导入fork

25:23.550 --> 25:26.230
我们用的时候是这样用的

25:26.230 --> 25:27.710
比方说我们这里写个

25:27.710 --> 25:32.230
写个test

25:32.230 --> 25:33.430
一个generator函数

25:33.430 --> 25:35.070
test

25:35.070 --> 25:38.430
那么这里我们开一个fork

25:38.430 --> 25:40.710
yieldfork

25:40.710 --> 25:42.190
这个test函数传进去

25:42.190 --> 25:43.670
其他还有额外的函数

25:43.670 --> 25:44.550
还有额外的函数

25:44.550 --> 25:45.510
比方说123

25:45.510 --> 25:47.630
就随便传

25:47.630 --> 25:48.190
123

25:48.190 --> 25:49.670
那么这里

25:49.710 --> 25:50.910
是不是可以得到这些参数

25:50.910 --> 25:51.270
对不对

25:51.270 --> 25:53.070
还有可能有些参数

25:53.070 --> 25:54.710
那么fork的反映回结果是什么

25:54.710 --> 25:56.190
是不是一个test对象

25:56.190 --> 25:56.510
对吧

25:56.510 --> 25:57.190
一个test对象

25:57.190 --> 25:58.550
这个test是可以取消的

25:58.550 --> 25:59.150
对不对

25:59.150 --> 26:02.430
它不影响这个任务的执行

26:02.430 --> 26:03.510
它不会组设

26:03.510 --> 26:04.110
它会接着

26:04.110 --> 26:05.550
它会执行它的任务

26:05.550 --> 26:08.710
跟现在目前的任务没有任何关系

26:08.710 --> 26:09.990
是这么个意思

26:09.990 --> 26:11.310
就是fork

26:11.310 --> 26:12.710
那么这就是运行一个函数

26:12.710 --> 26:14.030
给它传一些参数进去

26:14.030 --> 26:15.830
那么这个函数里面是不是可以随便来

26:15.830 --> 26:16.870
比方说这个函数

26:16.870 --> 26:17.950
这个函数永远都不会

26:18.030 --> 26:18.990
一个使循环

26:18.990 --> 26:20.310
永远不会运行结束

26:20.310 --> 26:21.670
那么这里我们来喊数据

26:21.670 --> 26:22.510
不断的监听

26:22.510 --> 26:23.150
对吧

26:23.150 --> 26:25.270
不断的去监听

26:25.270 --> 26:28.390
就是eod

26:28.390 --> 26:29.150
take

26:29.150 --> 26:29.710
监听怎么了

26:29.710 --> 26:32.750
监听比方说是

26:32.750 --> 26:35.390
action types increase

26:35.390 --> 26:36.350
async increase

26:36.350 --> 26:37.470
去监听这个

26:37.470 --> 26:38.470
监听到过后

26:38.470 --> 26:40.230
我们delay

26:40.230 --> 26:42.030
一秒钟

26:42.030 --> 26:42.830
一秒钟过后

26:42.830 --> 26:43.710
我们干嘛呢

26:43.710 --> 26:46.110
我们去触发一个action

26:46.110 --> 26:47.190
put

26:48.190 --> 26:49.550
去触发一个action

26:50.710 --> 26:52.310
eod

26:53.590 --> 26:55.870
put increase

26:55.870 --> 26:56.590
触发一个action

26:57.990 --> 26:58.470
对不对

26:58.470 --> 26:59.590
是不是写完了

26:59.590 --> 27:01.070
好

27:01.070 --> 27:02.790
那么这就是它字节

27:02.790 --> 27:04.670
但是它这里是不会影响的

27:04.670 --> 27:05.630
不会影响的

27:05.630 --> 27:06.590
不会影响这里的

27:06.590 --> 27:09.190
就是这里的进行

27:09.190 --> 27:13.990
这个就是Saga任务运行结束

27:13.990 --> 27:15.590
就是这个Saga任务运行结束了

27:15.590 --> 27:16.990
但是它这个任务还没有结束

27:16.990 --> 27:17.230
对吧

27:17.870 --> 27:18.750
fork是干嘛

27:18.750 --> 27:20.910
fork是开启一个新的任务的

27:20.910 --> 27:24.230
就这么个意思

27:24.230 --> 27:24.510
对吧

27:24.510 --> 27:25.550
它不会主色

27:25.550 --> 27:27.230
这是fork的作用

27:27.230 --> 27:28.670
那么fork里边传了一个generator

27:28.670 --> 27:29.470
方形进来

27:29.470 --> 27:30.550
就是传了一个函数进来

27:30.550 --> 27:31.230
那么第1个

27:31.230 --> 27:33.710
fork这里本身写下来非常简单

27:33.710 --> 27:35.470
这里特别简单

27:35.470 --> 27:36.630
返回来就是一个什么呢

27:36.630 --> 27:39.110
返回来就是一个内详式

27:39.110 --> 27:41.030
affix,taps, fork

27:41.030 --> 27:41.230
对吧

27:41.230 --> 27:42.510
这些都是固定写法了

27:42.510 --> 27:45.870
Panel里边就要传一个generator方形

27:45.870 --> 27:47.030
fn等于这个

27:47.030 --> 27:48.550
generator方形

27:48.550 --> 27:49.870
它有这么一个函数

27:49.870 --> 27:51.110
然后它还有一些参数

27:51.110 --> 27:51.510
对吧

27:51.510 --> 27:53.630
还有一些参数

27:53.630 --> 27:55.830
参数应该传过去

27:55.830 --> 27:56.070
对吧

27:56.070 --> 27:57.910
它只是产生这么一个对象而已

27:57.910 --> 27:58.990
描述对象

27:58.990 --> 28:01.110
关键是在这

28:01.110 --> 28:02.630
关键是在这

28:02.630 --> 28:05.910
wrong fork effect

28:05.910 --> 28:07.150
关键在这

28:07.150 --> 28:08.870
wrong fork effect干嘛呢

28:08.870 --> 28:10.230
它要做什么事情

28:10.230 --> 28:10.630
你告诉我

28:10.630 --> 28:12.750
它要做什么事情

28:12.750 --> 28:14.870
它要做的事情

28:14.910 --> 28:19.470
是不是就是启动一个

28:19.470 --> 28:22.390
启动一个新的任务

28:22.390 --> 28:24.830
这个东西我写过没

28:24.830 --> 28:25.630
写过没

28:25.630 --> 28:27.630
它不在当前的generator里边了

28:27.630 --> 28:28.310
什么叫任务

28:28.310 --> 28:30.030
任务就是维护一个generator

28:30.030 --> 28:30.390
对吧

28:30.390 --> 28:32.190
维护一个就是迭代器

28:32.190 --> 28:34.510
还不断的去迭代一个generator

28:34.510 --> 28:35.110
不断去迭代

28:35.110 --> 28:35.750
不断的去迭代

28:35.750 --> 28:37.390
就是要维护一个任务

28:37.390 --> 28:38.630
那么启动一个新的任务

28:38.630 --> 28:40.510
是不是要产生一个新的generator了

28:40.510 --> 28:40.710
对吧

28:40.710 --> 28:42.510
跟之前的没什么关系了

28:42.510 --> 28:44.310
那么启动一个新的任务是在干嘛

28:44.350 --> 28:46.110
我之前写过这么一个函数的

28:46.110 --> 28:47.150
忘了吗

28:47.150 --> 28:48.470
写

28:48.470 --> 28:50.230
这就是在启动一个新任务

28:50.230 --> 28:51.030
这个函数

28:51.030 --> 28:53.150
这个函数就是在启动一个新任务

28:53.150 --> 28:54.670
就这么简单

28:54.670 --> 28:56.990
所以说我们启动一个新任务

28:56.990 --> 28:59.870
其实特别特别简单

28:59.870 --> 29:02.230
做什么事情的启动一个新的任务

29:02.230 --> 29:05.590
就是去调用

29:05.590 --> 29:07.070
import

29:07.070 --> 29:07.910
调用什么

29:07.910 --> 29:11.470
调用一个wrong saga

29:11.470 --> 29:14.620
倒入进来

29:14.620 --> 29:15.740
wrong saga

29:15.780 --> 29:17.660
就是重新去调用wrong saga

29:17.660 --> 29:20.220
让它去启动一个任务

29:20.220 --> 29:21.140
它去启动一个任务

29:21.140 --> 29:21.860
你去启动吧

29:21.860 --> 29:23.420
我把环境给力

29:23.420 --> 29:24.740
还是同一个环境面量

29:24.740 --> 29:25.900
然后generator方式

29:25.900 --> 29:27.220
是不是在payload里面

29:27.220 --> 29:29.300
refect then payload

29:29.300 --> 29:31.060
generator方式在这里面

29:31.060 --> 29:32.420
还有什么额外的参数

29:32.420 --> 29:32.740
对不对

29:32.740 --> 29:33.900
额外的参数也在这里面

29:33.900 --> 29:34.820
refect

29:34.820 --> 29:36.540
payload

29:36.540 --> 29:37.820
argue

29:37.820 --> 29:39.660
把它展开

29:39.660 --> 29:40.900
对吧

29:40.900 --> 29:41.540
我就给力

29:41.540 --> 29:43.860
你去启动一个新任务就完事了

29:43.860 --> 29:44.740
那么更目前的

29:44.740 --> 29:46.220
会不会主设目前的任务

29:46.220 --> 29:47.020
不会主设

29:47.020 --> 29:48.100
什么叫不会主设

29:48.100 --> 29:50.420
马上调用next

29:50.420 --> 29:52.900
跟我目前的任务没有一毛钱关系

29:52.900 --> 29:54.860
我马上调用next

29:54.860 --> 29:56.140
当前任务

29:56.140 --> 29:58.380
当前任务不会主设

29:58.380 --> 30:01.100
你去开启一个新的任务就完事了

30:01.100 --> 30:02.860
那么我们这里马上调用next

30:02.860 --> 30:02.980
好

30:02.980 --> 30:03.900
那个时候调用啥

30:03.900 --> 30:05.740
给它传一个什么

30:05.740 --> 30:07.620
是不是就是一个task对象

30:07.620 --> 30:09.020
因为每一个wrong saga

30:09.020 --> 30:11.900
你看我们是不是把之前的东西连起来了

30:11.900 --> 30:13.260
之前的wrong saga

30:13.300 --> 30:14.660
是不是会返回一个任务对象

30:14.660 --> 30:16.700
最终最终会返回一个任务对象

30:16.700 --> 30:18.340
这个任务对象目前好像没啥用

30:18.340 --> 30:19.700
好像是没啥用

30:19.700 --> 30:21.940
那么到时候会总之还会返回一个任务对象

30:21.940 --> 30:24.060
这个任务对象是可以用于取消的

30:24.060 --> 30:25.860
那么这里的当前任务

30:25.860 --> 30:26.780
是不是可以拿到一个

30:26.780 --> 30:28.060
拿到这个任务对象

30:28.060 --> 30:28.780
你看一下

30:28.780 --> 30:30.660
在这是不是可以拿到这个任务对象

30:30.660 --> 30:31.300
fork

30:31.300 --> 30:33.740
他返回的结果

30:33.740 --> 30:34.580
那么这里的next

30:34.580 --> 30:36.540
我们是不是要把任务对象给他

30:36.540 --> 30:41.540
那么这里任务对象task

30:41.540 --> 30:42.260
任务对象

30:42.260 --> 30:43.980
我把这个任务对象给你

30:43.980 --> 30:44.300
对吧

30:44.300 --> 30:46.380
当前任务就不会出色了

30:46.380 --> 30:47.820
没问题吧

30:47.820 --> 30:48.820
就完了

30:48.820 --> 30:50.140
就没了

30:50.140 --> 30:51.580
这就是fork的写法

30:51.580 --> 30:53.460
特别特别简单

30:53.460 --> 30:55.860
就开启个新任务就完事了

30:55.860 --> 30:57.540
那么接下来咱们来写

30:57.540 --> 30:59.300
咱们来试一下

30:59.300 --> 31:01.780
看一下这个fork是不是真的是这样子呢

31:01.780 --> 31:03.660
咱们看一下这个fork

31:03.660 --> 31:06.060
是不是真的是这样子

31:06.060 --> 31:07.260
这个task

31:07.260 --> 31:08.420
我看一下

31:08.420 --> 31:10.620
我们这个saga里面

31:10.620 --> 31:11.100
运向fork

31:11.100 --> 31:14.700
看一下是不是有类似的效果

31:14.700 --> 31:17.140
generatorfunk is not a function

31:17.140 --> 31:19.620
他说我们的generatorfunk

31:19.620 --> 31:21.860
is not a function

31:21.860 --> 31:22.980
什么意思

31:22.980 --> 31:25.860
我看一下哪里包的错

31:25.860 --> 31:27.820
他说这个东西不是一个方形

31:27.820 --> 31:29.180
那这里我们打个断点

31:29.180 --> 31:29.780
刷新一下

31:29.780 --> 31:31.460
看一下它怎么回事

31:31.460 --> 31:32.260
这个地方

31:32.260 --> 31:33.980
这个第一次是个方形

31:33.980 --> 31:36.140
然后我们运行下一次

31:36.140 --> 31:37.540
下一次启动任务的时候

31:37.540 --> 31:39.620
它传的是undefend

31:39.780 --> 31:40.940
它传的是undefend

31:40.940 --> 31:41.420
我们看一下

31:41.420 --> 31:43.820
它为什么会传undefend进来呢

31:43.820 --> 31:46.060
我们是在这里传递的

31:46.060 --> 31:49.340
wrong saga

31:49.340 --> 31:50.900
传递的env

31:50.900 --> 31:52.300
figure

31:52.300 --> 31:53.580
哦 这里是fn

31:53.580 --> 31:54.500
这里是fn

31:54.500 --> 31:57.510
我写错了

31:57.510 --> 31:59.430
好 重新刷新

31:59.430 --> 32:00.710
好 你看一下

32:00.710 --> 32:01.750
首先saga任务结束了

32:01.750 --> 32:02.230
对吧

32:02.230 --> 32:02.910
saga任务结束了

32:02.910 --> 32:04.310
也就是它没有组设什么

32:04.310 --> 32:05.510
而且得到一个任务对象

32:05.510 --> 32:07.670
这个任务对象里面目前啥都没有

32:07.670 --> 32:09.070
也就是它不会组设什么

32:09.070 --> 32:10.350
不会组设

32:10.430 --> 32:11.870
我们的这个任务

32:11.870 --> 32:14.150
这条任务线它不会组设

32:14.150 --> 32:15.710
那么新开了一个任务

32:15.710 --> 32:16.590
它是不是在监听

32:16.590 --> 32:16.830
对吧

32:16.830 --> 32:17.310
我们来试一下

32:17.310 --> 32:18.390
它有没有监听

32:18.390 --> 32:21.270
Ethnc Increase

32:21.270 --> 32:23.230
你看 是不是有监听

32:23.230 --> 32:25.390
有监听 它触发了Increase

32:25.390 --> 32:27.030
然后再调用Ethnc Increase

32:27.030 --> 32:27.230
对吧

32:27.230 --> 32:28.790
所以又有监听

32:28.790 --> 32:30.510
也就是它开了一个新的任务了

32:30.510 --> 32:31.350
那条任务线

32:31.350 --> 32:33.110
就是一个新的generator来维护

32:33.110 --> 32:34.870
它在另外一个函数的执行

32:34.870 --> 32:35.710
在维护

32:35.710 --> 32:37.230
那么我这一次的函数执行

32:37.230 --> 32:38.430
就马上就结束了

32:38.430 --> 32:39.550
没有了

32:39.590 --> 32:40.830
它不会组设当前的任务

32:40.830 --> 32:42.510
这就是Folker的邪法

32:42.510 --> 32:42.950
对吧

32:42.950 --> 32:44.070
Folker的邪法

32:44.950 --> 32:45.110
好

32:45.110 --> 32:46.310
那么接下来我们再说

32:46.310 --> 32:48.350
Folker它不是要取消吗

32:48.350 --> 32:49.070
对不对

32:49.070 --> 32:50.710
Folker是不是要取消啊

32:50.710 --> 32:51.710
Tenso

32:52.310 --> 32:54.310
那么这个取消又怎么做了

32:54.310 --> 32:55.910
Folker我们现在已经搞定了

32:56.910 --> 32:57.830
已经搞定了

32:57.830 --> 33:00.030
那么现在这个取消怎么做了

33:00.030 --> 33:01.510
这个取消的话

33:01.510 --> 33:03.670
这里肯定不太容易想到了

33:03.670 --> 33:04.870
这个取消的话

33:04.870 --> 33:07.270
要依托于这个东西

33:08.270 --> 33:10.030
要依托于这个task对象

33:11.310 --> 33:13.070
其实取消是什么

33:13.590 --> 33:17.950
取消其实就是雕用那个设方法

33:18.710 --> 33:19.230
对吧

33:19.230 --> 33:20.990
就是雕用那个设方法

33:20.990 --> 33:23.150
然后前面两个参数传到

33:23.150 --> 33:24.390
最后一个参数传出

33:24.390 --> 33:24.950
对吧

33:24.950 --> 33:26.390
是不是雕用一下它

33:26.390 --> 33:27.470
那么运行下一个

33:27.470 --> 33:28.510
下一个把它

33:28.990 --> 33:29.870
把它设为去

33:29.870 --> 33:30.990
把一拙O吧设为去

33:30.990 --> 33:31.750
那么是不是

33:31.750 --> 33:32.870
一拙O为去过后

33:32.870 --> 33:34.510
它就结束了整个迭代

33:34.510 --> 33:34.870
对吧

33:34.870 --> 33:36.390
那么这条任务是不是就结束了

33:36.510 --> 33:37.550
因为迭代结束了

33:37.550 --> 33:38.030
迭代结束了

33:38.030 --> 33:39.150
它们有什么东西可以运行的

33:39.150 --> 33:40.990
那么这个函数就运行结束了

33:40.990 --> 33:42.590
这个函数运行结束了就没了

33:42.590 --> 33:45.030
跟这一次任务就没什么任何关系了

33:45.030 --> 33:45.630
对吧

33:45.630 --> 33:47.830
所以说取消就是雕用那个设方法

33:47.830 --> 33:48.870
就这么简单

33:48.870 --> 33:51.590
所以说我们要要在task里面做文章

33:51.590 --> 33:52.710
为什么要在task做文章

33:52.710 --> 33:54.710
因为到时候取消的时候是怎么取消的

33:54.710 --> 33:57.270
cancel是怎么取消的

33:57.270 --> 33:59.070
是不是里面传了一个task对象

33:59.070 --> 33:59.670
对吧

33:59.670 --> 34:00.670
task对象

34:00.670 --> 34:02.270
cancel里面有没有别的东西

34:02.270 --> 34:03.270
那么cancel里面

34:03.270 --> 34:04.310
到时候处理cancel的时候

34:04.310 --> 34:05.750
要能雕用这个函吗

34:05.790 --> 34:07.630
这个函数是它的内部函数调不到

34:07.630 --> 34:09.350
是这个函数的内部函数调不到

34:09.350 --> 34:12.510
所以说我们得在task对象里面做文章

34:12.510 --> 34:14.550
比方说我们可以这样子写

34:14.550 --> 34:17.190
task里面我们给它写上这么一个函数

34:17.190 --> 34:17.990
叫做cancel

34:17.990 --> 34:19.310
因为你自己取消就行了

34:19.310 --> 34:20.870
你取消就完事了

34:20.870 --> 34:23.150
就取消当前任务

34:23.150 --> 34:24.870
取消当前任务

34:24.870 --> 34:26.070
那么怎么来取消呢

34:26.070 --> 34:27.310
特别特别简单

34:27.310 --> 34:28.630
你给这个task函数

34:28.630 --> 34:30.270
构造函数里面传一个参数

34:30.270 --> 34:32.110
就是next

34:32.110 --> 34:34.630
它把这个next的方法保存起来就完事了

34:34.630 --> 34:35.510
就没了

34:35.510 --> 34:38.230
一个task里面保存这个next的方法

34:38.230 --> 34:39.750
我叫这来

34:39.750 --> 34:41.430
一个task里面保存那个那个方法

34:41.430 --> 34:42.190
取消怎么取消

34:42.190 --> 34:45.190
你看着this.next

34:45.190 --> 34:47.390
next value now

34:47.390 --> 34:49.190
arrow now is over

34:49.190 --> 34:50.230
所以就完了

34:50.230 --> 34:52.230
没了就取消了

34:52.230 --> 34:53.070
就这么简单

34:53.070 --> 34:54.790
就取消当前任务

34:54.790 --> 34:55.990
那么到时候

34:55.990 --> 34:57.390
cancel里面传个task对象

34:57.390 --> 34:58.030
它怎么取消

34:58.030 --> 34:59.270
是不是调一个对象的

34:59.270 --> 35:00.430
cancel就完事了

35:00.430 --> 35:00.910
对吧

35:00.910 --> 35:02.030
取消当前任务就完事了

35:02.030 --> 35:03.390
就特别简单了

35:03.390 --> 35:04.790
那么关键是你这个next

35:04.790 --> 35:06.670
是不是得传进来

35:06.670 --> 35:08.070
我们在这个就是

35:08.070 --> 35:10.470
这里就特别绕了

35:10.470 --> 35:14.590
我们在wrong saga里面

35:14.590 --> 35:15.190
创建一个

35:15.190 --> 35:16.470
返回一个新的task

35:16.470 --> 35:17.750
task里面是不是要把

35:17.750 --> 35:19.830
我这一次任务的next

35:19.830 --> 35:21.070
这个函数要传进来

35:21.070 --> 35:21.950
因为每一个任务

35:21.950 --> 35:23.350
它的next函数是不一样的

35:23.350 --> 35:23.670
对吧

35:23.670 --> 35:25.790
你看我们写的是内部函数

35:25.790 --> 35:27.070
这个每次调用这个函数

35:27.070 --> 35:28.190
是不是要创建一个新的next

35:28.190 --> 35:28.470
对吧

35:28.470 --> 35:29.230
他们互不干扰

35:29.230 --> 35:30.830
每条任务线互不干扰

35:30.830 --> 35:34.070
那么我们这里要把这个next传过去

35:34.550 --> 35:35.550
那么传过去过后

35:35.550 --> 35:36.870
这里面就可以取消了

35:36.870 --> 35:37.670
就这么简单

35:37.670 --> 35:38.910
就这样子写完了

35:39.910 --> 35:40.110
好

35:40.110 --> 35:41.110
那么取消怎么取消

35:41.110 --> 35:41.870
你看着

35:42.510 --> 35:44.110
我就已经现在已经搞定取消功能了

35:44.110 --> 35:45.150
就已经搞定了

35:45.150 --> 35:46.750
取消怎么取消

35:51.540 --> 35:53.220
我们这里呢

35:53.220 --> 35:55.500
就是找到这个

35:56.100 --> 35:57.060
找到这个费个证

35:57.060 --> 35:57.860
添加一个

35:57.860 --> 35:58.620
cancel

35:59.380 --> 36:00.220
调节词

36:00.660 --> 36:01.780
cancel.js

36:02.180 --> 36:02.980
取消

36:03.780 --> 36:06.460
这里面我们再添一个内容

36:06.460 --> 36:07.620
一个内容

36:07.620 --> 36:08.540
内容的话

36:09.220 --> 36:09.940
cancel

36:12.380 --> 36:13.060
cancel

36:14.780 --> 36:18.260
cancel 取消一个任务

36:18.260 --> 36:21.020
当然其实让官方的元代马尼亚

36:21.020 --> 36:23.940
取消这里会有一些细微的区别

36:23.940 --> 36:24.900
细微的区别

36:24.900 --> 36:26.140
它就这个内容会有

36:26.140 --> 36:27.420
这个地方会有变化

36:27.420 --> 36:28.620
但是我们无所谓了

36:28.620 --> 36:29.580
把功能做出来就行了

36:29.580 --> 36:30.980
思路大概都是一样的

36:30.980 --> 36:31.460
好

36:31.460 --> 36:32.780
取消我们加一个cancel

36:32.860 --> 36:34.700
然后这里边是不是也是一样

36:34.700 --> 36:35.820
导致两个函数

36:35.820 --> 36:36.580
复制一下

36:38.140 --> 36:38.780
复制一下

36:39.660 --> 36:40.660
这里是cancel

36:41.460 --> 36:42.580
cancel 要干嘛

36:42.580 --> 36:43.700
要传一个什么进来

36:43.700 --> 36:45.420
是不是要传一个task对象进来

36:45.420 --> 36:46.020
对不对

36:46.020 --> 36:47.620
传一个task对象进来

36:47.620 --> 36:47.820
好

36:47.820 --> 36:49.380
那么这里是wrongcancel

36:50.540 --> 36:51.180
erfict

36:51.660 --> 36:52.580
取消一个任务

36:53.100 --> 36:54.780
这里其实我马上就写完了

36:54.780 --> 36:56.100
cancel里面反挥啥

36:56.100 --> 36:57.820
反挥createerfict

36:57.820 --> 36:59.660
erfict tabscancel

37:01.340 --> 37:02.100
取消

37:02.140 --> 37:03.500
然后payload里面传啥

37:03.500 --> 37:04.940
是不是传一个task对象进去

37:04.940 --> 37:05.500
对吧

37:05.500 --> 37:06.740
传个task对象进去

37:06.740 --> 37:07.660
那么这个wrong

37:08.380 --> 37:10.420
执行取消的时候怎么取消

37:10.420 --> 37:11.060
怎么取消

37:11.060 --> 37:12.500
是不是找到erficts

37:13.260 --> 37:16.660
payloadtaskcancel

37:16.660 --> 37:17.340
所以就取消了

37:17.340 --> 37:18.980
就这么简单

37:20.540 --> 37:21.020
就取消了

37:21.020 --> 37:21.980
还要干嘛

37:21.980 --> 37:22.940
还能干嘛呢

37:22.940 --> 37:23.420
对不对

37:23.420 --> 37:24.420
还能干嘛呢

37:24.420 --> 37:25.460
就取消了

37:25.460 --> 37:27.340
那么后面还需要那个是不用了

37:27.340 --> 37:28.980
因为cancel里面就已经

37:28.980 --> 37:29.900
掉了那个是

37:29.900 --> 37:30.860
就直接结束了

37:30.900 --> 37:31.860
就直接结束了

37:32.380 --> 37:33.020
就这么简单

37:33.580 --> 37:34.100
没了

37:34.100 --> 37:34.500
没了

37:36.140 --> 37:36.620
好

37:36.620 --> 37:38.340
那么现在我们到这边来

37:41.260 --> 37:41.740
到这边来

37:43.940 --> 37:45.620
这里wrongerficts

37:46.780 --> 37:49.180
这要加一个cancel

37:50.180 --> 37:51.300
cancel

37:51.300 --> 37:52.620
这里我们这里一些

37:52.620 --> 37:54.260
wrongcancel erficts

37:55.700 --> 37:56.540
这里复制一下

37:57.980 --> 37:58.940
这里是cancel

38:01.020 --> 38:05.260
这里wrongcancel erficts

38:06.100 --> 38:08.140
就写完了cancel这一块就搞定了

38:08.140 --> 38:08.380
好

38:08.380 --> 38:09.220
咱们试一下

38:09.220 --> 38:10.980
试一下cancel这里是不是真的搞定了

38:11.860 --> 38:12.900
你这里不断的监听

38:12.900 --> 38:13.180
对吧

38:13.180 --> 38:14.060
不断的监听

38:14.380 --> 38:15.980
我这个A和B也没什么用

38:15.980 --> 38:16.580
不要了吧

38:17.300 --> 38:18.740
你这里在不断的监听

38:19.060 --> 38:20.140
不断的监听的话

38:20.140 --> 38:20.860
那么比方说

38:20.860 --> 38:23.500
我这里我在主任务里边

38:24.020 --> 38:25.500
你是一条新的任务线

38:25.500 --> 38:25.740
对吧

38:25.740 --> 38:26.580
在不断的监听

38:26.580 --> 38:27.820
那么我在主任务里边

38:27.820 --> 38:28.940
我们也写个delay

38:29.460 --> 38:30.300
eo的delay

38:30.420 --> 38:32.620
比方说5秒钟之后

38:32.620 --> 38:33.980
5秒钟之后

38:35.060 --> 38:36.460
我就取消你这个任务

38:37.020 --> 38:39.100
5秒钟之后task

38:39.460 --> 38:41.260
就是eo的

38:41.260 --> 38:42.620
我们要导入cancel

38:42.620 --> 38:44.260
cancel还没有这里导出

38:44.780 --> 38:45.740
这里还没有导出

38:48.940 --> 38:49.540
cancel

38:49.980 --> 38:51.980
这里导出cancel

38:53.260 --> 38:53.540
好

38:53.540 --> 38:54.900
这边到这边来

38:54.900 --> 38:55.780
三个里边来

38:55.900 --> 38:56.180
好

38:56.180 --> 38:58.900
这里我们就调用cancel task

39:01.380 --> 39:01.660
好

39:01.660 --> 39:02.980
就是cancel导入进来

39:03.980 --> 39:04.980
好

39:04.980 --> 39:06.260
5秒钟之后取消任务

39:06.260 --> 39:07.500
我们这里输出一下

39:08.980 --> 39:11.620
任务已被取消

39:12.180 --> 39:12.460
好

39:12.460 --> 39:12.860
保存

39:12.860 --> 39:13.380
咱们来看一下

39:15.380 --> 39:16.700
这里我们cancel

39:17.100 --> 39:17.700
没问题

39:17.700 --> 39:19.340
你看cancel没问题

39:20.100 --> 39:20.740
等一下

39:22.060 --> 39:22.460
没了

39:22.460 --> 39:22.740
对吧

39:22.740 --> 39:23.220
没了

39:23.220 --> 39:24.460
他这里没输出

39:25.540 --> 39:26.140
没有输出

39:26.140 --> 39:27.020
cancel task

39:28.020 --> 39:28.540
没有输出

39:28.540 --> 39:28.860
我看一下

39:28.860 --> 39:29.780
为什么没有输出

39:30.220 --> 39:31.060
再重新来

39:31.620 --> 39:32.180
cancel

39:33.020 --> 39:33.900
出发没问题

39:33.900 --> 39:34.380
sync

39:34.780 --> 39:35.580
出发没问题

39:38.780 --> 39:40.340
他没有输出这句话

39:41.140 --> 39:42.540
他没有输出这句话

39:42.740 --> 39:43.980
cancel task

39:44.500 --> 39:46.460
当我们取消任务的时候

39:46.460 --> 39:48.340
调用的是任务里边的next

39:48.340 --> 39:48.820
对吧

39:49.140 --> 39:50.140
调用的next

39:50.140 --> 39:52.140
那我们看一下 task 里边

39:52.860 --> 39:54.140
task 里边的next

39:54.540 --> 39:55.420
我们这里输出

39:57.940 --> 39:58.700
next

39:59.620 --> 40:00.340
next

40:01.820 --> 40:02.460
cancel

40:03.180 --> 40:03.780
试一下

40:03.780 --> 40:05.980
看一下无缘动之后有没有输出的那个cancel

40:09.380 --> 40:10.220
这个输出了

40:10.660 --> 40:11.300
这个输出了

40:11.300 --> 40:11.700
过后了

40:11.700 --> 40:12.660
这个next

40:14.460 --> 40:15.140
我们想一想

40:15.660 --> 40:16.220
想一想

40:19.200 --> 40:21.040
为什么他这句话没有输出

40:22.160 --> 40:22.760
我想一想

40:22.760 --> 40:23.560
这是什么回事

40:23.800 --> 40:25.360
为什么这句话没有输出

40:27.600 --> 40:28.400
我的问题

40:28.400 --> 40:29.440
我的锅

40:30.120 --> 40:30.520
这里

40:30.720 --> 40:32.320
这里得调那个设

40:32.800 --> 40:33.480
得调那个设

40:33.760 --> 40:35.080
因为是不一样的

40:35.720 --> 40:36.280
这里要注意

40:36.880 --> 40:37.760
cancel

40:38.200 --> 40:40.200
cancel 中的next

40:40.720 --> 40:42.160
指向的是

40:43.760 --> 40:45.880
他对应的

40:46.680 --> 40:49.360
就是那个任务的next

40:49.560 --> 40:50.720
因为每一次

40:50.720 --> 40:52.440
wrong saga 是不是启动一个任务

40:52.440 --> 40:53.200
每次调用这个函数

40:53.200 --> 40:54.440
是不是启动一个任务

40:54.480 --> 40:55.000
对吧

40:55.160 --> 40:56.320
启动这个一个任务的时候

40:56.320 --> 40:58.080
是不是产生一个对应的task对象

40:58.400 --> 40:58.840
对吧

40:58.840 --> 41:00.680
那么这个task对象里边的next

41:00.680 --> 41:02.040
只对应的是

41:02.560 --> 41:05.960
那个新开启的这个任务的next

41:06.320 --> 41:07.680
而我们这个的next

41:07.680 --> 41:08.680
不一定是这个玩意

41:08.680 --> 41:09.360
不一定的

41:09.360 --> 41:11.000
因为我们这里的next

41:11.160 --> 41:12.400
就是我们这里的next

41:12.400 --> 41:14.040
是当前任务的next

41:15.600 --> 41:17.520
这里就这里特别特别

41:18.320 --> 41:20.240
是当前的next

41:20.520 --> 41:20.800
对吧

41:20.800 --> 41:21.440
是不一样的

41:21.440 --> 41:22.320
是不一样的

41:23.360 --> 41:23.960
保存看一下

41:26.040 --> 41:27.040
你看现在没问题

41:27.040 --> 41:27.320
对吧

41:27.320 --> 41:28.360
好任务被取消了

41:28.360 --> 41:29.560
你看任务一旦取消

41:29.560 --> 41:31.520
你看increase 是不是不能出发了

41:31.520 --> 41:33.000
那个任务就直接结束了

41:33.000 --> 41:34.600
甭管他运行到哪个位置

41:34.600 --> 41:35.640
他就直接结束了

41:36.160 --> 41:38.360
不要说刚才我们这里写的是一个使循环

41:38.360 --> 41:38.840
对吧

41:38.840 --> 41:40.360
使循环他就某一个地方

41:40.360 --> 41:41.040
一定要等待

41:41.040 --> 41:41.480
对不对

41:41.480 --> 41:42.120
在eo的

41:42.120 --> 41:42.400
好

41:42.400 --> 41:43.640
那么这里被取消了

41:43.640 --> 41:44.680
取消了过后了

41:44.680 --> 41:46.440
那么什么都不会运行了

41:46.440 --> 41:47.280
我们之前讲的那个

41:47.280 --> 41:48.280
Generator的时候也说过

41:48.280 --> 41:48.800
对吧

41:49.200 --> 41:49.440
好

41:49.440 --> 41:50.560
那么这里是不是搞定了

41:50.560 --> 41:51.560
cancel就搞定了

41:52.120 --> 41:52.320
好

41:52.320 --> 41:53.880
我们现在搞定了fork之后

41:53.960 --> 41:55.880
你会发现这件事情就可以做了

41:56.080 --> 41:57.200
cancel现在也搞定了

41:58.760 --> 42:01.240
搞定了这个fork之后

42:01.360 --> 42:02.880
take average就可以做了

42:03.640 --> 42:04.800
take average就可以做了

42:04.840 --> 42:06.760
因为take average其实就是fork

42:06.760 --> 42:08.560
我们之前都写过那个take average的代码

42:08.560 --> 42:09.080
对吧

42:09.080 --> 42:09.360
好

42:09.360 --> 42:10.920
这里写一个take average

42:10.920 --> 42:12.720
他都没有新的类型

42:12.720 --> 42:14.400
没有新的affect nation

42:14.400 --> 42:17.440
他就是利用fork和take来搞定的

42:17.440 --> 42:17.680
好

42:17.680 --> 42:18.400
怎么写的呢

42:18.400 --> 42:19.520
这个take average怎么写的呢

42:19.520 --> 42:20.280
看一下

42:20.800 --> 42:23.520
那导出一个take average

42:25.910 --> 42:27.030
导出这么个东西

42:27.590 --> 42:27.830
好

42:27.830 --> 42:29.070
take average里面怎么写的呢

42:29.070 --> 42:30.390
他就导出一个函数的玩意儿

42:32.440 --> 42:33.920
take average

42:34.320 --> 42:34.520
好

42:34.520 --> 42:35.640
你给我传一个什么

42:35.640 --> 42:37.200
传一个action的类型

42:37.480 --> 42:39.320
然后再给我传一个处理函数

42:39.840 --> 42:40.880
再给我传一个处理函数

42:40.880 --> 42:42.040
还有什么额外的参数

42:42.040 --> 42:43.680
这个处理函数的额外参数

42:45.520 --> 42:45.720
好

42:45.720 --> 42:47.440
那么这个take average怎么写的呢

42:47.440 --> 42:48.200
他这样的写的

42:48.560 --> 42:50.480
我们这里他导入的是什么

42:50.480 --> 42:52.440
一个是fork

42:56.070 --> 42:57.070
导入fork

42:57.950 --> 42:59.790
fromfork

43:00.230 --> 43:01.230
然后再导入

43:01.550 --> 43:02.590
因为他不会主色

43:02.590 --> 43:04.110
take average是不会主色的

43:04.630 --> 43:05.630
再导入什么了

43:05.790 --> 43:07.310
导入那个就是

43:09.830 --> 43:12.830
再导入那个

43:13.830 --> 43:14.830
什么了

43:15.830 --> 43:16.830
还有什么

43:16.830 --> 43:17.830
还有take

43:17.830 --> 43:18.830
还有take

43:19.830 --> 43:20.830
再导入take

43:21.830 --> 43:22.830
导入这两个函数

43:22.830 --> 43:23.830
一个fork

43:23.830 --> 43:24.830
一个take

43:24.830 --> 43:26.830
利用这两个函数就已经可以做了

43:26.830 --> 43:27.830
他返回的是啥呢

43:27.830 --> 43:28.830
take average

43:28.830 --> 43:29.830
他返回的也是个task对象

43:30.830 --> 43:31.830
返回的也是个task对象

43:31.830 --> 43:32.830
你可以控制他的

43:32.830 --> 43:34.830
那么返回的其实就是什么

43:34.830 --> 43:36.830
就是调用fork返回的东西

43:37.830 --> 43:38.830
fork里边要传一个什么

43:38.830 --> 43:40.830
传一个函数对象

43:40.830 --> 43:41.830
函数

43:41.830 --> 43:42.830
传一个函数

43:42.830 --> 43:43.830
对不对

43:43.830 --> 43:44.830
好参数呢

43:47.830 --> 43:48.830
对了

43:48.830 --> 43:49.830
参数呢

43:49.830 --> 43:50.830
参数是不是在这

43:50.830 --> 43:51.830
对不对

43:51.830 --> 43:52.830
参数传过去

43:52.830 --> 43:53.830
参数传过去

43:54.830 --> 43:55.830
对吧

43:55.830 --> 43:56.830
take average

43:56.830 --> 43:57.830
好只不过

43:57.830 --> 43:58.830
take average

43:58.830 --> 44:00.830
他要做这么一件事情

44:00.830 --> 44:02.830
就是要调用take

44:02.830 --> 44:04.830
在函数里边要调用take

44:04.830 --> 44:05.830
那么这里的函数

44:05.830 --> 44:07.830
这里的函数你不能

44:07.830 --> 44:09.830
还真不能直接把这个写进来

44:09.830 --> 44:12.830
因为这个函数是我们每一次

44:12.830 --> 44:14.830
每一次监听到了相应的请求

44:14.830 --> 44:15.830
因为监听到了相应的x型过后了

44:15.830 --> 44:16.830
触发的函数

44:16.830 --> 44:18.830
但是我们这里要不断的监听

44:18.830 --> 44:19.830
不断的监听

44:19.830 --> 44:21.830
所以说这个函数他是自己写的

44:21.830 --> 44:22.830
他写了这么一个函数

44:22.830 --> 44:24.830
这里面我们写上这么一个函数

44:24.830 --> 44:25.830
放个型

44:25.830 --> 44:27.830
或者说我们做一个匿名函数

44:27.830 --> 44:28.830
放到这

44:28.830 --> 44:29.830
放个型

44:29.830 --> 44:31.830
做个匿名函数放到这

44:32.830 --> 44:34.830
那么运行的是这个函数

44:34.830 --> 44:36.830
运行的是这个函数

44:36.830 --> 44:37.830
原来这意思

44:37.830 --> 44:38.830
运行的是这个函数

44:38.830 --> 44:39.830
我这里都不要arguess

44:39.830 --> 44:40.830
不要这个东西了

44:40.830 --> 44:41.830
fork

44:41.830 --> 44:43.830
开启一个新的任务

44:43.830 --> 44:46.830
开启一个新的任务

44:46.830 --> 44:47.830
每一次任务

44:47.830 --> 44:49.830
就是任务他运行的是这个函数

44:49.830 --> 44:50.830
这个函数里边干嘛呢

44:50.830 --> 44:52.830
我就写了一个死循环

44:53.830 --> 44:54.830
一个死循环

44:54.830 --> 44:55.830
这个死循环

44:55.830 --> 44:56.830
里边

44:56.830 --> 44:58.830
每一次我们去take

44:58.830 --> 44:59.830
take

44:59.830 --> 45:00.830
take什么呢

45:00.830 --> 45:01.830
你给我传一个x型type

45:01.830 --> 45:02.830
对吧

45:02.830 --> 45:03.830
take一个x型type

45:04.830 --> 45:05.830
好那这里

45:05.830 --> 45:07.830
返回了是不是一个完整的x型对象

45:07.830 --> 45:08.830
对吧

45:08.830 --> 45:09.830
返回了一个完整的x型对象

45:09.830 --> 45:11.830
好拿到这个x型对象之后

45:11.830 --> 45:13.830
拿到这个x型对象之后

45:13.830 --> 45:14.830
我干嘛呢

45:14.830 --> 45:16.830
我要去调用这个函数

45:17.830 --> 45:19.830
把你的参数传进去

45:19.830 --> 45:21.830
把你的参数给展开传进去

45:21.830 --> 45:22.830
然后再给你传一个x型

45:23.830 --> 45:24.830
所以说我们在take every

45:24.830 --> 45:25.830
他对应的函数里边

45:25.830 --> 45:26.830
take every的时候

45:26.830 --> 45:28.830
你给他放在函数里边

45:28.830 --> 45:29.830
你是可以获取到x型对象的

45:29.830 --> 45:30.830
就在对合个参数里边

45:30.830 --> 45:32.830
可以获取到x型对象

45:32.830 --> 45:33.830
对不对

45:33.830 --> 45:34.830
就这样子写的

45:34.830 --> 45:35.830
但是他实际上

45:35.830 --> 45:36.830
这里还做了一点改动

45:36.830 --> 45:38.830
就是我们之前讲过的了

45:38.830 --> 45:40.830
如果说你做这样的操作的话

45:40.830 --> 45:42.830
如果你去直接这样子写的话

45:42.830 --> 45:45.830
那么可能会导致问题

45:45.830 --> 45:46.830
什么问题呢

45:46.830 --> 45:49.830
就是说你这个函数调用

45:49.830 --> 45:51.830
如果说你这个函数里边

45:51.830 --> 45:52.830
再组成了

45:52.830 --> 45:54.830
是不是会影响这里的外傲的行为

45:54.830 --> 45:55.830
对吧

45:55.830 --> 45:56.830
他会影响这里

45:56.830 --> 45:57.830
会影响这里

45:57.830 --> 45:59.830
所以说他这一块

45:59.830 --> 46:01.830
他对于这个函数的调用

46:02.830 --> 46:04.830
因为你这一块

46:04.830 --> 46:05.830
他也是一个generator函数

46:05.830 --> 46:06.830
对吧

46:06.830 --> 46:07.830
你不能你直接调用的话

46:07.830 --> 46:08.830
还不行

46:08.830 --> 46:10.830
因为他这里也是一个generator函数

46:10.830 --> 46:13.830
所以说你这里得新开启一个任务

46:13.830 --> 46:16.830
让我们这里的监听也不要受到阻涉

46:16.830 --> 46:18.830
让我们的监听也不要受到阻涉

46:18.830 --> 46:20.830
所以说我们这里有的

46:20.830 --> 46:22.830
folk

46:22.830 --> 46:25.830
又开启一个新的任务

46:26.830 --> 46:28.830
这个任务函数

46:28.830 --> 46:30.830
函数就是这个函数

46:30.830 --> 46:31.830
去运行这个函数

46:31.830 --> 46:33.830
然后给你传的参数是什么

46:33.830 --> 46:35.830
我们把这个数组

46:35.830 --> 46:36.830
concuit

46:36.830 --> 46:38.830
连接上这个x

46:38.830 --> 46:39.830
把x凭接进来

46:39.830 --> 46:42.830
作为整个数组的参数的最后一个

46:42.830 --> 46:43.830
凭接这么一个东西

46:43.830 --> 46:44.830
这里展开

46:44.830 --> 46:46.830
就是这样子写的

46:46.830 --> 46:47.830
看着

46:47.830 --> 46:48.830
take every

46:48.830 --> 46:51.830
他实际上本身就是开启一个新的任务

46:51.830 --> 46:53.830
本身就是开启一个新的任务

46:53.830 --> 46:55.830
然后可以传的一个函数进去

46:55.830 --> 46:56.830
这个新的任务做什么

46:56.830 --> 46:57.830
不断的去监听

46:57.830 --> 46:59.830
为了让监听不受到阻涉

46:59.830 --> 47:01.830
为了让监听不受到阻涉

47:01.830 --> 47:03.830
所以说这里又要去开启一个任务

47:03.830 --> 47:05.830
它不能阻涉这里的监听

47:05.830 --> 47:07.830
如果说这个函数里面做了很多很多的事情

47:07.830 --> 47:09.830
那么这个监听会被阻涉了

47:09.830 --> 47:11.830
那么下一次监听就监听不到了

47:11.830 --> 47:13.830
所以说监听是不能被阻涉的

47:13.830 --> 47:15.830
因此你这里要去开启一个新的任务

47:15.830 --> 47:16.830
去运行这个函数

47:16.830 --> 47:17.830
运行这个函数

47:17.830 --> 47:19.830
这个函数就是一个generator方式

47:19.830 --> 47:20.830
对吧

47:20.830 --> 47:21.830
然后这里

47:21.830 --> 47:22.830
参数的话

47:22.830 --> 47:23.830
把你原本传的参数

47:23.830 --> 47:25.830
在最后凭接上一个action

47:25.830 --> 47:26.830
这是它的做法

47:26.830 --> 47:27.830
take every

47:27.830 --> 47:29.830
有了take every过后

47:29.830 --> 47:30.830
我们再看一下

47:31.830 --> 47:32.830
这里我们比方说

47:32.830 --> 47:33.830
我们这里就写上一个

47:33.830 --> 47:35.830
take every

47:35.830 --> 47:37.830
take every

47:37.830 --> 47:41.550
写这么一个

47:41.550 --> 47:42.550
foq不要了

47:42.550 --> 47:43.550
foq不要了

47:44.550 --> 47:45.550
这里也可以

47:45.550 --> 47:47.550
8秒钟之后取消任务

47:47.550 --> 47:49.550
take every它也会返回一个任务

47:49.550 --> 47:50.550
返回一个任务

47:50.550 --> 47:52.550
那么取消过后它就不再监听了

47:52.550 --> 47:53.550
就不再监听了

47:53.550 --> 47:55.550
take every它就运行这个函数

47:55.550 --> 47:56.550
这个函数里面干嘛

47:56.550 --> 47:59.550
我就写这两步就行了

47:59.550 --> 48:01.550
只需要这两个就行了

48:01.550 --> 48:02.550
take都不要了

48:04.860 --> 48:05.860
看一下吧

48:11.200 --> 48:12.200
还没有写这个

48:12.200 --> 48:13.200
还没有写监听的

48:13.200 --> 48:14.200
监听的类型

48:14.200 --> 48:16.200
async increase

48:16.200 --> 48:17.200
看一下吧

48:18.200 --> 48:19.200
傲存

48:20.200 --> 48:21.200
你看呀

48:22.200 --> 48:24.200
increase

48:24.200 --> 48:25.200
async increase

48:25.200 --> 48:26.200
是不是监听到了

48:26.200 --> 48:27.200
async increase

48:27.200 --> 48:28.200
是不是监听到了

48:28.200 --> 48:29.200
任务被取消了

48:29.200 --> 48:30.200
8秒钟到了

48:30.200 --> 48:31.200
它就没有再出发了

48:31.200 --> 48:32.200
再看

48:32.200 --> 48:33.200
监听到了对吧

48:33.200 --> 48:34.200
再来

48:34.200 --> 48:35.200
监听到了

48:37.200 --> 48:38.200
为什么新的没有了

48:40.200 --> 48:41.200
第二次为什么没有监听到

48:41.200 --> 48:42.200
这里还有点小问题

48:42.200 --> 48:44.200
我把函数传给它了

48:44.200 --> 48:45.200
函数传给它了

48:45.200 --> 48:47.200
每一次监听它都会启动这个函数

48:48.200 --> 48:49.200
take every

48:50.200 --> 48:51.200
看一下

48:52.200 --> 48:55.200
当前任务没有被注射

48:56.200 --> 48:59.510
你看这方向任务没有被注射

48:59.510 --> 49:00.510
这个是没问题的

49:00.510 --> 49:01.510
那么它在不断的监听

49:01.510 --> 49:02.510
take every

49:03.510 --> 49:05.510
我们看一下take every的代码

49:05.510 --> 49:07.510
我们这里fork了一个

49:07.510 --> 49:09.510
开启了一个新的任务

49:09.510 --> 49:11.510
这个新的任务里边去使循环

49:11.510 --> 49:15.510
然后每一次去take一个xing type

49:15.510 --> 49:16.510
xing type

49:17.510 --> 49:19.510
这里会主设

49:19.510 --> 49:21.510
这里会主设监听

49:21.510 --> 49:22.510
这里会主设

49:22.510 --> 49:24.510
当这个xing type发生了之后

49:24.510 --> 49:27.510
它会去开启一个新的任务

49:27.510 --> 49:30.510
然后去运行这个函数

49:30.510 --> 49:33.510
这里把这个xing会传进去

49:33.510 --> 49:35.510
为什么它会第二次又不行呢

49:35.510 --> 49:37.510
我们先暂时不取消

49:37.510 --> 49:38.510
我们先暂时不取消

49:38.510 --> 49:39.510
调试一下

49:39.510 --> 49:41.510
我们看一下哪里的问题

49:41.510 --> 49:43.510
看一下是哪里的问题

49:43.510 --> 49:47.490
sync

49:47.490 --> 49:49.490
第一次没问题

49:50.490 --> 49:51.490
后面不运行的

49:51.490 --> 49:53.490
行 那我们在这里打个断点

49:53.490 --> 49:55.490
打个就是debug

49:56.490 --> 49:57.490
看一下

49:58.490 --> 49:59.490
一开始没问题

49:59.490 --> 50:00.490
停在这了

50:00.490 --> 50:01.490
对吧 等待

50:01.490 --> 50:03.490
现在等待 没问题

50:03.490 --> 50:04.490
现在我们运行一下

50:04.490 --> 50:05.490
运行到这了

50:05.490 --> 50:07.490
fork开启一个新的任务

50:07.490 --> 50:09.490
去运行这个函数

50:09.490 --> 50:11.490
fork

50:11.490 --> 50:12.490
fork这里写对没有

50:12.490 --> 50:13.490
没问题

50:13.490 --> 50:14.490
没问题

50:15.490 --> 50:17.490
fork去运行这个函数

50:17.490 --> 50:19.490
下一次又来监听

50:20.490 --> 50:22.490
于是我们这里又来

50:23.490 --> 50:24.490
又来监听

50:24.490 --> 50:26.490
它就没在运行了

50:26.490 --> 50:28.490
不是应该运行吗

50:29.490 --> 50:30.490
再一次监听

50:30.490 --> 50:34.500
它就没有在运行了

50:34.500 --> 50:35.500
我想想

50:35.500 --> 50:37.500
我想想这里是怎么回事

50:37.500 --> 50:38.500
我刚才这里

50:38.500 --> 50:40.500
至于调试了一下

50:40.500 --> 50:42.500
这个问题呢 只真不好找

50:42.500 --> 50:43.500
这个问题在哪呢

50:43.500 --> 50:45.500
是在这里发生的问题

50:45.500 --> 50:47.500
你得先删除定约

50:48.500 --> 50:50.500
然后再去调用这个函数

50:50.500 --> 50:51.500
就是这里的问题

50:51.500 --> 50:53.500
为什么呢 是这样子

50:53.500 --> 50:54.500
如果说你先调用函数

50:54.500 --> 50:55.500
再删除定约的话

50:55.500 --> 50:56.500
因为这个调用函数

50:56.500 --> 50:58.500
函数里边要做很多的事情

50:58.500 --> 50:59.500
你看一下 比方说

50:59.500 --> 51:00.500
我们刚才的take里边

51:00.500 --> 51:01.500
take里边

51:01.500 --> 51:03.500
调用take的时候

51:03.500 --> 51:05.500
调用这个函数的时候

51:05.500 --> 51:07.500
对吧 这是定约函数

51:07.500 --> 51:09.500
这个函数里边是又调用那个

51:09.500 --> 51:10.500
又往下一步执行了

51:10.500 --> 51:11.500
那如果说下一步

51:11.500 --> 51:12.500
它又加了一个take

51:12.500 --> 51:14.500
又去监听了

51:14.500 --> 51:15.500
那么又监听了

51:15.500 --> 51:16.500
又添加了一个订阅者

51:16.500 --> 51:18.500
那个订阅者都还没有执行

51:18.500 --> 51:20.500
然后最后你把3除掉了

51:20.500 --> 51:21.500
就你执行这些函数的时候

51:21.500 --> 51:23.500
它里边又加了一个订阅者

51:23.500 --> 51:25.500
但是你最后把3除掉了

51:25.500 --> 51:26.500
所以我们得先删除

51:26.500 --> 51:28.500
然后再运行

51:28.500 --> 51:30.500
再运行

51:30.500 --> 51:31.500
原来的意思吧

51:31.500 --> 51:32.500
一个运行的过程中

51:32.500 --> 51:33.500
如果说你再加了订阅者

51:33.500 --> 51:34.500
OK 你这个属性又加进去了

51:34.500 --> 51:36.500
那么下一次又可以监听了

51:36.500 --> 51:38.500
这个小的细节

51:38.500 --> 51:40.500
然后我们把这个d8给去掉

51:40.500 --> 51:42.500
再看一下

51:42.500 --> 51:43.500
就这一块特别特别难

51:43.500 --> 51:46.500
我们说saga这一个难度

51:46.500 --> 51:47.500
难度很高

51:47.500 --> 51:48.500
就是在这一块

51:48.500 --> 51:49.500
难度特别特别高

51:49.500 --> 51:50.500
特别特别糟

51:50.500 --> 51:52.500
我们来看一下

51:52.500 --> 51:54.500
去掉了

51:54.500 --> 51:56.500
刷新

51:56.500 --> 51:59.500
你看当前任务是没有组设的

51:59.500 --> 52:01.500
哪里有包警告

52:01.500 --> 52:03.500
他说cancel is defend

52:03.500 --> 52:04.500
but they have used

52:04.500 --> 52:06.500
他说这里

52:06.500 --> 52:07.500
我这里没有cancel对吧

52:07.500 --> 52:08.500
没有cancel

52:08.500 --> 52:10.500
那这里我们先暂时不cancel

52:10.500 --> 52:11.500
暂时不取消

52:11.500 --> 52:12.500
把取消加上

52:12.500 --> 52:13.500
加上

52:13.500 --> 52:15.500
看一下吧

52:15.500 --> 52:16.500
当前任务没有组设

52:16.500 --> 52:18.500
加一个

52:18.500 --> 52:21.500
这是I think it creates

52:21.500 --> 52:23.500
来 走一个

52:23.500 --> 52:24.500
没问题

52:24.500 --> 52:25.500
走一个

52:26.500 --> 52:27.500
没问题

52:27.500 --> 52:28.500
等一下

52:28.500 --> 52:29.500
稍微等一下

52:29.500 --> 52:30.500
任务被取消了

52:30.500 --> 52:31.500
然后我们再来看

52:31.500 --> 52:32.500
是没了

52:32.500 --> 52:33.500
再等一下

52:33.500 --> 52:34.500
是没了

52:34.500 --> 52:35.500
这个任务已经不存在了

52:35.500 --> 52:36.500
被取消掉了

52:36.500 --> 52:37.500
看没

52:37.500 --> 52:40.500
这就是take average的写法

52:40.500 --> 52:42.500
就这么写的

52:42.500 --> 52:44.500
那么最后take average

52:44.500 --> 52:45.500
现在也搞定了

52:45.500 --> 52:47.500
最后就剩下一个or了

52:47.500 --> 52:49.500
这个or这一块U

52:49.500 --> 52:50.500
不是很好处理

52:50.500 --> 52:51.500
or是什么呢

52:51.500 --> 52:54.500
or是要等到所有的generator

52:54.500 --> 52:56.500
全部结束之后

52:56.500 --> 52:57.500
然后才往

52:57.500 --> 52:58.500
它要一直组设

52:58.500 --> 52:59.500
要等到后边的generator

52:59.500 --> 53:01.500
全部完成之后

53:01.500 --> 53:03.500
才能继续往下走

53:03.500 --> 53:04.500
这是个or

53:04.500 --> 53:05.500
or这个东西

53:05.500 --> 53:06.500
我们也给它写一下

53:06.500 --> 53:07.500
复制一下

53:07.500 --> 53:08.500
暂停过来

53:08.500 --> 53:09.500
这是or

53:09.500 --> 53:11.500
create effect

53:11.500 --> 53:12.500
or这里要传啥

53:12.500 --> 53:14.500
是不是要传很多的generator进来

53:14.500 --> 53:15.500
要传一个数组

53:15.500 --> 53:17.500
传一个数组进来

53:17.500 --> 53:19.500
就是很多的generators

53:19.500 --> 53:20.500
generators

53:20.500 --> 53:21.500
它传的不是generators的函数

53:21.500 --> 53:23.500
它传的不是generators的函数

53:23.500 --> 53:26.500
它传的是所有的生存器

53:26.500 --> 53:28.500
那么这里

53:28.500 --> 53:30.500
返回的内形

53:30.500 --> 53:31.500
内形该加上

53:31.500 --> 53:33.500
最后一个了

53:33.500 --> 53:35.500
内形就是or

53:35.500 --> 53:37.880
你看我现在基本上

53:37.880 --> 53:40.880
把三个都快写完了

53:40.880 --> 53:42.880
然后在这里边

53:42.880 --> 53:43.880
or effect

53:43.880 --> 53:44.880
这里边加上一个

53:44.880 --> 53:46.880
再先把这个or写完

53:46.880 --> 53:48.880
把函数名字写出来

53:48.880 --> 53:50.880
or effect

53:50.880 --> 53:53.260
那么这里

53:53.260 --> 53:54.260
返回的是什么呢

53:54.260 --> 53:56.260
返回的是

53:56.260 --> 53:58.260
内形是or

53:58.260 --> 54:00.260
然后返回的payload

54:00.260 --> 54:02.260
里面就是一个generators

54:02.260 --> 54:04.260
generators

54:04.260 --> 54:05.260
这个数组

54:05.260 --> 54:06.260
好,那么这里

54:06.260 --> 54:08.260
or effect

54:08.260 --> 54:09.260
我们一会儿再说

54:09.260 --> 54:10.260
这个地方怎么做

54:10.260 --> 54:11.260
一会儿再说

54:11.260 --> 54:12.260
我们先把这个地方写好

54:12.260 --> 54:15.260
index导出

54:15.260 --> 54:18.630
or

54:18.630 --> 54:20.630
这边or effect

54:20.630 --> 54:22.630
这里边也要

54:23.630 --> 54:25.630
or

54:25.630 --> 54:28.630
然后这里是or effect

54:28.630 --> 54:30.630
好,这边下面

54:30.630 --> 54:32.630
这里复制一下

54:32.630 --> 54:33.630
这里

54:33.630 --> 54:35.630
如果匹配到or

54:35.630 --> 54:37.630
那么这里要or effect

54:37.630 --> 54:39.630
这一块又不太好写了

54:39.630 --> 54:40.630
为什么

54:40.630 --> 54:41.630
因为你给我传了一个

54:41.630 --> 54:42.630
generators

54:42.630 --> 54:43.630
我们这里可以很轻松的得到

54:43.630 --> 54:45.630
这个没问题

54:45.630 --> 54:47.630
可以很轻松的得到这个数组

54:47.630 --> 54:48.630
那么如果说

54:48.630 --> 54:50.630
这里会有这样的写

54:50.630 --> 54:51.630
generators

54:51.630 --> 54:53.630
如果说它没有值

54:53.630 --> 54:54.630
没有值的话

54:54.630 --> 54:55.630
给它一个空数组

54:55.630 --> 54:57.630
总之到这里可以得到一个数组

54:57.630 --> 54:59.630
or effect

54:59.630 --> 55:00.630
通过payload

55:00.630 --> 55:01.630
里边的是吗

55:01.630 --> 55:02.630
generators

55:02.630 --> 55:04.630
来得到这个数组

55:04.630 --> 55:05.630
好,那么这里

55:05.630 --> 55:06.630
得到一个数组

55:06.630 --> 55:07.630
怎么运行呢

55:07.630 --> 55:08.630
是不是又要

55:08.630 --> 55:09.630
每一个数组

55:09.630 --> 55:11.630
每一个generators

55:11.630 --> 55:13.630
是不是要开启一个新的任务

55:13.630 --> 55:15.630
是不是又要开启一个新的任务

55:15.630 --> 55:16.630
没问题吧

55:16.630 --> 55:18.630
又要开启一个新的任务

55:18.630 --> 55:19.630
对吧

55:19.630 --> 55:20.630
这个开启新的任务

55:20.630 --> 55:21.630
是不是又要runsaga

55:21.630 --> 55:22.630
但是你会发现

55:22.630 --> 55:23.630
runsaga

55:23.630 --> 55:24.630
它这里要传函数

55:24.630 --> 55:26.630
你传的是一个函数

55:26.630 --> 55:28.630
而不是

55:28.630 --> 55:29.630
而不是generator

55:29.630 --> 55:30.630
应该的意思吧

55:30.630 --> 55:32.630
你得传一个函数进来

55:32.630 --> 55:33.630
得传一个函数进来

55:33.630 --> 55:35.630
是这么个意思

55:35.630 --> 55:36.630
好,那怎么办呢

55:36.630 --> 55:37.630
那咋办呢

55:37.630 --> 55:38.630
那简单呀

55:38.630 --> 55:39.630
我们把这块封装成一个函数

55:39.630 --> 55:40.630
不完了吗

55:40.630 --> 55:41.630
把下面这一坨

55:41.630 --> 55:43.630
封装成一个函数

55:43.630 --> 55:44.630
不就完了吗

55:44.630 --> 55:45.630
对不对

55:45.630 --> 55:47.630
如果你给我一个generator

55:47.630 --> 55:48.630
OK

55:48.630 --> 55:50.630
那么我就给你运行个函数

55:50.630 --> 55:52.630
把它封装一下就完事了

55:52.630 --> 55:54.630
咱们导出

55:54.630 --> 55:55.630
这个地方导出了

55:55.630 --> 55:56.630
导出这个

55:56.630 --> 55:58.630
导出个proc

55:58.630 --> 56:00.630
执行一个generator

56:03.630 --> 56:06.630
执行一个generator

56:06.630 --> 56:08.630
或者叫做attrator

56:08.630 --> 56:09.630
都行

56:09.630 --> 56:10.630
你给我一个啥

56:10.630 --> 56:12.630
给我一个attrator

56:12.630 --> 56:13.630
那么我就执行

56:13.630 --> 56:14.630
执行的过程

56:14.630 --> 56:16.630
是不是跟这里是一样的

56:16.630 --> 56:17.630
对吧

56:17.630 --> 56:18.630
跟这里是一样的

56:18.630 --> 56:19.630
跟那个手

56:19.630 --> 56:21.630
那个手这里是不是一样的

56:21.630 --> 56:22.630
对不对

56:22.630 --> 56:23.630
跟那个手这里是一样的

56:23.630 --> 56:24.630
那么就在这里呢

56:24.630 --> 56:25.630
我们在这里

56:25.630 --> 56:27.630
就去调用什么

56:27.630 --> 56:28.630
这里调用proc

56:28.630 --> 56:29.630
把generator传

56:29.630 --> 56:31.630
把attrator传进去

56:31.630 --> 56:32.630
对吧

56:32.630 --> 56:33.630
就完事了

56:33.630 --> 56:34.630
那它去调用

56:34.630 --> 56:35.630
就把这些东西

56:35.630 --> 56:36.630
交给函数来调用

56:36.630 --> 56:37.630
对吧

56:37.630 --> 56:38.630
交给函数来调用

56:38.630 --> 56:39.630
好,这个函数

56:39.630 --> 56:40.630
我们把复字

56:40.630 --> 56:42.630
剪切粘贴过来

56:42.630 --> 56:44.630
粘贴过来

56:44.630 --> 56:45.630
还有一个

56:45.630 --> 56:46.630
m

56:46.630 --> 56:47.630
就是

56:47.630 --> 56:48.630
环境

56:48.630 --> 56:49.630
环境

56:49.630 --> 56:51.630
那么把这个m传进来

56:51.630 --> 56:52.630
对不对

56:52.630 --> 56:53.630
把稍微改造一下

56:53.630 --> 56:54.630
稍微改造一下

56:54.630 --> 56:55.630
是一样的效果

56:55.630 --> 56:56.630
对吧

56:56.630 --> 56:57.630
放到函数里面吧

56:57.630 --> 56:58.630
好,然后这里面

56:58.630 --> 56:59.630
是不是完全一样的

56:59.630 --> 57:00.630
你看我都不用改

57:00.630 --> 57:01.630
这个代码

57:01.630 --> 57:02.630
都完全一样的

57:02.630 --> 57:03.630
没什么问题吧

57:03.630 --> 57:04.630
对吧

57:04.630 --> 57:05.630
那么这里就是

57:05.630 --> 57:06.630
执行的是一个attrator

57:06.630 --> 57:07.630
attrator

57:07.630 --> 57:08.630
那么这个

57:08.630 --> 57:09.630
哦,这里

57:09.630 --> 57:10.630
是不是我们这里

57:10.630 --> 57:11.630
得到了很多generators

57:11.630 --> 57:12.630
对不对

57:12.630 --> 57:13.630
是不是要

57:13.630 --> 57:14.630
干嘛

57:14.630 --> 57:15.630
我们要去

57:15.630 --> 57:17.630
运行每一个generator

57:17.630 --> 57:18.630
是

57:18.630 --> 57:20.630
然后得到一个什么task的速度

57:20.630 --> 57:21.630
对不对

57:21.630 --> 57:22.630
每一个generator

57:22.630 --> 57:23.630
运行就是个task的速度

57:23.630 --> 57:24.630
in port

57:24.630 --> 57:25.630
proc

57:25.630 --> 57:26.630
导入这个

57:26.630 --> 57:28.630
from

57:28.630 --> 57:30.630
index

57:30.630 --> 57:32.630
no, wrong

57:32.630 --> 57:33.630
saga

57:33.630 --> 57:35.630
里面还有一个proc

57:35.630 --> 57:36.630
这个函数要做什么呢

57:36.630 --> 57:37.630
就才运行一个generator

57:37.630 --> 57:38.630
好,那么找一个

57:38.630 --> 57:40.630
这里就是generatormap

57:40.630 --> 57:42.630
每一个generator

57:42.630 --> 57:43.630
我们干嘛呢

57:43.630 --> 57:44.630
这个proc

57:44.630 --> 57:45.630
把这个generator

57:45.630 --> 57:46.630
传进去

57:46.630 --> 57:47.630
n5传进去

57:47.630 --> 57:48.630
这个generator传进去

57:48.630 --> 57:49.630
是不是可以得到

57:49.630 --> 57:50.630
一个task的速度

57:50.630 --> 57:51.630
对吧

57:51.630 --> 57:52.630
generator的速度

57:52.630 --> 57:53.630
是不是可以得到

57:53.630 --> 57:54.630
一个task的速度

57:54.630 --> 57:55.630
对不对

57:55.630 --> 57:56.630
得到一个task的速度

57:56.630 --> 57:57.630
好,那么现在呢

57:57.630 --> 57:58.630
就是

57:58.630 --> 57:59.630
等待

57:59.630 --> 58:01.630
所有的task

58:01.630 --> 58:02.630
task

58:02.630 --> 58:05.630
全部完成之后

58:05.630 --> 58:07.630
全部完成之后

58:07.630 --> 58:08.630
然后呢

58:08.630 --> 58:10.630
再继续运行

58:10.630 --> 58:11.630
再继续运行

58:11.630 --> 58:12.630
再调用

58:13.630 --> 58:14.630
next

58:14.630 --> 58:15.630
让当前任务

58:15.630 --> 58:16.630
继续运行

58:16.630 --> 58:17.630
那么怎么来知道

58:17.630 --> 58:18.630
所有的task

58:18.630 --> 58:19.630
全部完成之后呢

58:19.630 --> 58:20.630
我们这里呢

58:20.630 --> 58:21.630
知道有这么一个东西

58:21.630 --> 58:22.630
叫做promise

58:22.630 --> 58:23.630
promise,诶

58:23.630 --> 58:24.630
promise

58:24.630 --> 58:25.630
你不要说

58:25.630 --> 58:26.630
是不是一个all吗

58:26.630 --> 58:27.630
对吧

58:27.630 --> 58:28.630
你给它传入一个promise的速度

58:28.630 --> 58:29.630
那么它等到

58:29.630 --> 58:30.630
所有的promise速度

58:30.630 --> 58:31.630
全部完成之后

58:31.630 --> 58:32.630
诶,我再继续

58:32.630 --> 58:33.630
这也继续

58:33.630 --> 58:34.630
就是我这个promise

58:34.630 --> 58:35.630
再继续执行

58:35.630 --> 58:37.630
它有这么一个东西

58:37.630 --> 58:38.630
那么如果说

58:38.630 --> 58:39.630
我能够把这个task

58:39.630 --> 58:41.630
转换成一个什么

58:41.630 --> 58:43.630
转换成一个promise就完成了

58:43.630 --> 58:44.630
那么我们如果说

58:44.630 --> 58:46.630
在task对象里边

58:46.630 --> 58:47.630
提供这么一个方法

58:47.630 --> 58:49.630
叫做to promise

58:49.630 --> 58:50.630
你去看一下

58:50.630 --> 58:51.630
官方的那个

58:51.630 --> 58:52.630
返回的task里边

58:52.630 --> 58:53.630
它有这么一个方法

58:53.630 --> 58:54.630
to promise

58:54.630 --> 58:55.630
表示的是

58:55.630 --> 58:59.630
将当前的task

58:59.630 --> 59:00.630
task

59:00.630 --> 59:03.630
转换为一个promise对象

59:03.630 --> 59:05.630
转换为一个promise对象

59:05.630 --> 59:06.630
好,如果说

59:06.630 --> 59:07.630
提供了这么一个方法

59:07.630 --> 59:09.630
它会得到一个promise对象

59:09.630 --> 59:11.630
又一个promise对象

59:11.630 --> 59:13.630
返回result

59:13.630 --> 59:14.630
等等等等

59:14.630 --> 59:15.630
它会等到

59:15.630 --> 59:16.630
等到这个对象

59:16.630 --> 59:17.630
返回一个promise对象

59:17.630 --> 59:18.630
那么如果说

59:18.630 --> 59:19.630
这个方法已经写好了

59:19.630 --> 59:20.630
那这里就写法

59:20.630 --> 59:21.630
就特别简单了

59:21.630 --> 59:22.630
怎么写呢

59:22.630 --> 59:23.630
task

59:23.630 --> 59:24.630
然后呢等到

59:24.630 --> 59:26.630
就是使用task

59:26.630 --> 59:27.630
然后呢又把它

59:27.630 --> 59:29.630
转换成为promise

59:29.630 --> 59:31.630
用用map

59:31.630 --> 59:32.630
t

59:32.630 --> 59:34.630
t to promise

59:34.630 --> 59:35.630
promise

59:35.630 --> 59:36.630
对吧,调个promise方法

59:36.630 --> 59:37.630
那么得到一个什么

59:37.630 --> 59:38.630
得到一个promise

59:39.630 --> 59:41.630
得到一个promise的数组

59:44.630 --> 59:47.630
得到一个promise的数组

59:47.630 --> 59:48.630
好,拿到一个数组过后

59:48.630 --> 59:50.630
我们就可以使用promise

59:50.630 --> 59:52.630
等到所有的promise

59:52.630 --> 59:54.630
全部完成

59:54.630 --> 59:56.630
等到promise

59:56.630 --> 59:57.630
全部完成

59:57.630 --> 59:58.630
全部完成之后

59:58.630 --> 59:59.630
我们再认

59:59.630 --> 01:00:00.630
认

01:00:01.630 --> 01:00:02.630
什么呢

01:00:02.630 --> 01:00:03.630
result

01:00:03.630 --> 01:00:05.630
result

01:00:05.630 --> 01:00:07.630
认那个next

01:00:08.630 --> 01:00:10.630
值呢,值就是什么

01:00:10.630 --> 01:00:12.630
全部完成之后

01:00:12.630 --> 01:00:13.630
值呢我都可以

01:00:13.630 --> 01:00:14.630
不用给它值

01:00:14.630 --> 01:00:16.630
也不用给它值

01:00:16.630 --> 01:00:17.630
就完了

01:00:17.630 --> 01:00:18.630
掉next

01:00:18.630 --> 01:00:20.630
就没了

01:00:20.630 --> 01:00:21.630
对不对

01:00:21.630 --> 01:00:23.630
咱们就这样子来写

01:00:23.630 --> 01:00:25.630
现在问题的焦点就放到这了

01:00:25.630 --> 01:00:27.630
怎么让把它转换成一个promise呢

01:00:27.630 --> 01:00:29.630
什么时候这个promise完成

01:00:29.630 --> 01:00:31.630
什么时候完成

01:00:31.630 --> 01:00:33.630
什么时候完成

01:00:33.630 --> 01:00:34.630
是不是要等到那个

01:00:34.630 --> 01:00:36.630
这个任务结束了过后

01:00:36.630 --> 01:00:37.630
是不是就完成了

01:00:37.630 --> 01:00:38.630
对不对

01:00:38.630 --> 01:00:39.630
任务被取消

01:00:39.630 --> 01:00:41.630
或者说任务自然而难结束了

01:00:41.630 --> 01:00:43.630
那么这个promise

01:00:43.630 --> 01:00:44.630
是被完成

01:00:44.630 --> 01:00:45.630
对不对

01:00:45.630 --> 01:00:46.630
那么任务被结束

01:00:46.630 --> 01:00:47.630
任务被取消

01:00:47.630 --> 01:00:48.630
谁最清楚

01:00:48.630 --> 01:00:49.630
是不是那个时候

01:00:49.630 --> 01:00:50.630
这个方法最清楚

01:00:50.630 --> 01:00:51.630
那个时候的方法里边

01:00:51.630 --> 01:00:52.630
是不是它提供了

01:00:52.630 --> 01:00:53.630
你看那个时候

01:00:53.630 --> 01:00:54.630
这个地方

01:00:54.630 --> 01:00:55.630
是不是任务结束了

01:00:55.630 --> 01:00:56.630
对吧

01:00:56.630 --> 01:00:57.630
还有这个地方

01:00:57.630 --> 01:00:58.630
return

01:00:58.630 --> 01:00:59.630
是不是结束了

01:00:59.630 --> 01:01:00.630
对不对

01:01:00.630 --> 01:01:01.630
是不是结束了

01:01:01.630 --> 01:01:02.630
是不是这里是最清楚的

01:01:02.630 --> 01:01:03.630
对吧

01:01:03.630 --> 01:01:04.630
这里是最清楚的

01:01:04.630 --> 01:01:06.630
我们希望它这里一块

01:01:06.630 --> 01:01:08.630
能够通知到这个task

01:01:08.630 --> 01:01:10.630
能够通知到task

01:01:10.630 --> 01:01:12.630
那怎么做呢

01:01:12.630 --> 01:01:14.630
那怎么来通知task呢

01:01:14.630 --> 01:01:15.630
怎么让

01:01:15.630 --> 01:01:16.630
就是在这里

01:01:16.630 --> 01:01:17.630
我们肯定要去

01:01:17.630 --> 01:01:19.630
在这个

01:01:19.630 --> 01:01:20.630
那个舍里边

01:01:20.630 --> 01:01:23.630
是不是要调用一个回调函数

01:01:23.630 --> 01:01:26.630
调用一个回调函数

01:01:26.630 --> 01:01:28.630
调用这么一个回调函数

01:01:28.630 --> 01:01:30.630
然后

01:01:30.630 --> 01:01:31.630
这个回调函数

01:01:31.630 --> 01:01:33.630
能够通知到这个task

01:01:33.630 --> 01:01:34.630
也就是说

01:01:34.630 --> 01:01:35.630
这个回调函数在哪

01:01:35.630 --> 01:01:37.630
是不是task里边给它付的值

01:01:37.630 --> 01:01:38.630
对吧

01:01:38.630 --> 01:01:39.630
这个回调函数在task里边给它付的值

01:01:39.630 --> 01:01:40.630
好

01:01:40.630 --> 01:01:41.630
那么我们这样的处理

01:01:41.630 --> 01:01:43.630
在proc里边

01:01:43.630 --> 01:01:46.630
我新建了每个对象

01:01:46.630 --> 01:01:48.630
叫cbobject

01:01:48.630 --> 01:01:50.630
回调函数对象

01:01:50.630 --> 01:01:52.630
这是一个

01:01:52.630 --> 01:01:54.630
回调函数对象

01:01:54.630 --> 01:01:55.630
这个对象里边

01:01:55.630 --> 01:01:57.630
提供了一个callback

01:01:57.630 --> 01:01:59.630
callback

01:01:59.630 --> 01:02:02.630
默认为naw

01:02:03.630 --> 01:02:05.630
然后我们把这个回调对象

01:02:05.630 --> 01:02:07.630
传给task

01:02:07.630 --> 01:02:09.630
把这个回调对象团块task

01:02:09.630 --> 01:02:10.630
因为它是引用传递

01:02:10.630 --> 01:02:11.630
对不对

01:02:11.630 --> 01:02:13.630
task里边是不是可以收到一个

01:02:13.630 --> 01:02:16.630
回调函数对象cbobject

01:02:16.630 --> 01:02:17.630
这是个回调函数对象

01:02:17.630 --> 01:02:18.630
我们可以把记录下来

01:02:18.630 --> 01:02:20.630
cbobject

01:02:20.630 --> 01:02:21.630
记录下来

01:02:21.630 --> 01:02:22.630
等于cbobject

01:02:22.630 --> 01:02:23.630
因为它是同一个对象

01:02:23.630 --> 01:02:25.630
就这个对象的引用地址

01:02:25.630 --> 01:02:26.630
跟外面的引用地址

01:02:26.630 --> 01:02:27.630
是一样的

01:02:27.630 --> 01:02:28.630
跟这个是一样的

01:02:28.630 --> 01:02:29.630
那么我这里是不是可以

01:02:29.630 --> 01:02:30.630
更改对象的属性

01:02:30.630 --> 01:02:31.630
要更改一个属性

01:02:31.630 --> 01:02:33.630
把它写成这么一个函数

01:02:33.630 --> 01:02:35.630
更改这个属性

01:02:35.630 --> 01:02:37.630
它更改里边的哪个属性

01:02:37.630 --> 01:02:40.630
哪个属性就是callback这个属性

01:02:40.630 --> 01:02:42.630
你为什么不能直接传个函数

01:02:42.630 --> 01:02:43.630
直接传个函数的话

01:02:43.630 --> 01:02:44.630
我这里改

01:02:44.630 --> 01:02:45.630
直接给它复制

01:02:45.630 --> 01:02:46.630
是不是只改了这个参数

01:02:46.630 --> 01:02:47.630
外面的是不是没动

01:02:47.630 --> 01:02:48.630
外面的是没动的

01:02:48.630 --> 01:02:49.630
我们这里更改

01:02:49.630 --> 01:02:52.630
对象里边的属性callback

01:02:52.630 --> 01:02:54.630
表示的是结束了

01:02:54.630 --> 01:02:55.630
表示的是结束了

01:02:55.630 --> 01:02:56.630
当然结束的时候

01:02:56.630 --> 01:02:57.630
你还可以告诉它

01:02:57.630 --> 01:02:58.630
是怎么结束的

01:02:58.630 --> 01:02:59.630
是自然而然结束的

01:02:59.630 --> 01:03:02.630
还是被取消结束的

01:03:02.630 --> 01:03:04.630
那么这里是结束了

01:03:04.630 --> 01:03:05.630
于是我们现在

01:03:05.630 --> 01:03:07.630
就可以收到一个通知了

01:03:07.630 --> 01:03:09.630
我们在这里

01:03:09.630 --> 01:03:11.630
那个是方法里边

01:03:11.630 --> 01:03:12.630
当我们迭代结束的时候

01:03:12.630 --> 01:03:13.630
干嘛呢

01:03:13.630 --> 01:03:15.630
判断一下CBOB界里边

01:03:15.630 --> 01:03:17.630
是不是有个callback

01:03:17.630 --> 01:03:19.630
我们这样子吧

01:03:19.630 --> 01:03:21.630
CBOB界里边有个callback

01:03:21.630 --> 01:03:22.630
如果说有这个属性的话

01:03:22.630 --> 01:03:24.630
我们就调用这个callback

01:03:24.630 --> 01:03:25.630
表示结束了

01:03:25.630 --> 01:03:27.630
迭代结束了

01:03:27.630 --> 01:03:28.630
然后这里return这里

01:03:28.630 --> 01:03:29.630
是不是也是一样

01:03:29.630 --> 01:03:31.630
return这里也是一样

01:03:31.630 --> 01:03:32.630
结束整个迭代

01:03:32.630 --> 01:03:34.630
结束整个迭代的时候

01:03:34.630 --> 01:03:36.630
我们也给它调用一下这个函数

01:03:36.630 --> 01:03:38.630
调用一下这个函数

01:03:38.630 --> 01:03:41.630
表示整个迭代结束了

01:03:41.630 --> 01:03:42.630
我们这样子

01:03:42.630 --> 01:03:44.630
就可以知道这个任务

01:03:44.630 --> 01:03:45.630
结束的时候要干嘛

01:03:45.630 --> 01:03:47.630
我们就可以通过callback来搞定了

01:03:47.630 --> 01:03:51.780
可以在这里写也行

01:03:51.780 --> 01:03:52.780
然后这个task里边

01:03:52.780 --> 01:03:53.780
只要调到callback

01:03:53.780 --> 01:03:54.780
表示结束了

01:03:54.780 --> 01:03:55.780
结束要干嘛

01:03:55.780 --> 01:03:57.780
是不是要u45

01:03:57.780 --> 01:03:58.780
但是这是两callback

01:03:58.780 --> 01:03:59.780
是不是分开写的

01:03:59.780 --> 01:04:00.780
那这个简单

01:04:00.780 --> 01:04:02.780
我这里resolve

01:04:02.780 --> 01:04:03.780
创建一个promise的时候

01:04:03.780 --> 01:04:04.780
我这里不做任何事情

01:04:04.780 --> 01:04:06.780
只是把resolve保存起来

01:04:06.780 --> 01:04:08.780
保存到属性里边

01:04:08.780 --> 01:04:10.780
保存到属性里边resolve里边

01:04:10.780 --> 01:04:12.780
然后这里结束的时候

01:04:12.780 --> 01:04:14.780
判断一下thisresolve

01:04:14.780 --> 01:04:15.780
有没有值

01:04:15.780 --> 01:04:17.780
如果说有值的话

01:04:17.780 --> 01:04:20.780
resolve调用一下就完事了

01:04:20.780 --> 01:04:21.780
对吧

01:04:21.780 --> 01:04:22.780
这里更加糟了

01:04:22.780 --> 01:04:23.780
对吧更加糟了

01:04:23.780 --> 01:04:24.780
这样子我们通过这个函数

01:04:24.780 --> 01:04:25.780
就可以得到一个promise对象

01:04:25.780 --> 01:04:26.780
它什么时候结束

01:04:26.780 --> 01:04:27.780
什么时候调用callback

01:04:27.780 --> 01:04:29.780
什么时候结束

01:04:29.780 --> 01:04:30.780
对吧

01:04:30.780 --> 01:04:31.780
就完了

01:04:31.780 --> 01:04:33.780
好那么这里就写完了

01:04:33.780 --> 01:04:34.780
我就写完了

01:04:34.780 --> 01:04:36.780
等到所有的promise

01:04:36.780 --> 01:04:37.780
全部结束过后

01:04:37.780 --> 01:04:39.780
那么我们调用next

01:04:39.780 --> 01:04:40.780
对吧

01:04:40.780 --> 01:04:41.780
那么测试一下

01:04:41.780 --> 01:04:42.780
测试一下

01:04:42.780 --> 01:04:43.780
就最后一个测试了

01:04:43.780 --> 01:04:45.780
我们在saga里边

01:04:45.780 --> 01:04:46.780
我们这里使用or

01:04:46.780 --> 01:04:48.780
跟我们之前的做法一样了

01:04:48.780 --> 01:04:50.780
使用or

01:04:50.780 --> 01:04:53.780
然后我们这里写一个saga

01:04:53.780 --> 01:04:56.780
写一个increase

01:04:57.780 --> 01:04:59.780
再写一个decrease

01:04:59.780 --> 01:05:01.780
decrease

01:05:01.780 --> 01:05:02.780
写这两个

01:05:02.780 --> 01:05:04.780
然后这里导入

01:05:04.780 --> 01:05:07.780
importincrease

01:05:07.780 --> 01:05:10.780
fromincrease

01:05:10.780 --> 01:05:12.780
再导入一个decrease

01:05:12.780 --> 01:05:16.600
decrease

01:05:16.600 --> 01:05:18.600
好这里我们使用or

01:05:18.600 --> 01:05:23.360
这里我们使用eald

01:05:23.360 --> 01:05:24.360
or

01:05:24.360 --> 01:05:26.360
or这里边传一个数组对吧

01:05:26.360 --> 01:05:28.360
数组里边调用increase

01:05:29.360 --> 01:05:31.360
再调用decrease

01:05:31.360 --> 01:05:32.360
调用decrease

01:05:32.360 --> 01:05:34.360
给它传两个generator精确

01:05:34.360 --> 01:05:36.360
好那么这里我下面输出

01:05:36.360 --> 01:05:38.360
saga结束了

01:05:38.360 --> 01:05:39.360
saga结束了

01:05:39.360 --> 01:05:41.360
好那么increase里边导出

01:05:41.360 --> 01:05:43.360
导出default

01:05:43.360 --> 01:05:45.360
导出一个函数increase

01:05:45.360 --> 01:05:47.360
当然它是一个generator函数

01:05:48.360 --> 01:05:49.360
有没有被绕晕啊

01:05:49.360 --> 01:05:50.360
我觉得好

01:05:50.360 --> 01:05:51.360
应该是很多同学都被绕晕了

01:05:51.360 --> 01:05:52.360
所以说这几节课

01:05:52.360 --> 01:05:53.360
我觉得有几年

01:05:53.360 --> 01:05:55.360
公众经验过后再来看好一点

01:05:55.360 --> 01:05:56.360
不然的话

01:05:56.360 --> 01:05:57.360
特别特别容易绕晕

01:05:57.360 --> 01:05:58.360
你在公众里边

01:05:58.360 --> 01:06:00.360
需要受过一些折磨之后

01:06:00.360 --> 01:06:01.360
才能看得到

01:06:01.360 --> 01:06:03.360
你看一下现在是不是不能结束

01:06:03.360 --> 01:06:04.360
对吧因为这里

01:06:04.360 --> 01:06:05.360
这两个generator

01:06:05.360 --> 01:06:07.360
这两个generator

01:06:11.360 --> 01:06:13.360
我们这里先写这个increase

01:06:13.360 --> 01:06:15.360
先写这个increase

01:06:15.360 --> 01:06:16.360
好这个increase里边

01:06:16.360 --> 01:06:18.360
我们这是增加对不对

01:06:18.360 --> 01:06:19.360
增加

01:06:19.360 --> 01:06:20.360
OK我们这里使用

01:06:20.360 --> 01:06:21.360
import

01:06:21.360 --> 01:06:22.360
它写完吧

01:06:22.360 --> 01:06:26.360
take average from

01:06:28.360 --> 01:06:30.360
对对写钢

01:06:30.360 --> 01:06:31.360
对对写钢

01:06:31.360 --> 01:06:32.360
react

01:06:32.360 --> 01:06:33.360
react

01:06:35.360 --> 01:06:36.360
take average

01:06:36.360 --> 01:06:38.360
take average

01:06:39.360 --> 01:06:40.360
什么类型呢

01:06:40.360 --> 01:06:42.360
我们还要导入action

01:06:42.360 --> 01:06:43.360
from

01:06:43.360 --> 01:06:44.360
对对写钢

01:06:44.360 --> 01:06:46.360
action counter

01:06:46.360 --> 01:06:48.360
这里使用increase

01:06:48.360 --> 01:06:51.360
increase action types

01:06:52.360 --> 01:06:53.360
take average

01:06:53.360 --> 01:06:54.360
action types

01:06:54.360 --> 01:06:56.360
async increase

01:06:57.360 --> 01:06:58.360
然后

01:06:58.360 --> 01:07:00.360
运行什么函数呢

01:07:00.360 --> 01:07:01.360
我们这里写个函数

01:07:04.360 --> 01:07:05.360
increase

01:07:05.360 --> 01:07:06.360
increase这个函数

01:07:07.360 --> 01:07:08.360
这里钢这个函数

01:07:08.360 --> 01:07:09.360
increase

01:07:11.360 --> 01:07:13.360
这里名字重复了对吧

01:07:13.360 --> 01:07:15.360
async increase

01:07:16.360 --> 01:07:17.360
钢这个函数

01:07:17.360 --> 01:07:18.360
好这个函数里边干嘛呢

01:07:18.360 --> 01:07:19.360
就是delay

01:07:19.360 --> 01:07:20.360
还要导入delay

01:07:22.360 --> 01:07:24.360
delay put

01:07:25.360 --> 01:07:26.360
eod

01:07:26.360 --> 01:07:27.360
delay

01:07:28.360 --> 01:07:29.360
这里是

01:07:30.360 --> 01:07:31.360
1000

01:07:32.360 --> 01:07:33.360
然后呢

01:07:33.360 --> 01:07:34.360
eod

01:07:34.360 --> 01:07:35.360
put

01:07:35.360 --> 01:07:37.360
put increase

01:07:37.360 --> 01:07:39.360
increase导入

01:07:40.360 --> 01:07:42.360
好那么这里复制一下

01:07:42.360 --> 01:07:44.360
这里 decrease

01:07:44.360 --> 01:07:45.360
这里也干复制

01:07:45.360 --> 01:07:46.360
粘贴一下

01:07:46.360 --> 01:07:48.360
这里是 decrease

01:07:49.360 --> 01:07:50.360
decrease

01:07:50.360 --> 01:07:51.360
decrease

01:07:51.360 --> 01:07:52.360
async

01:07:52.360 --> 01:07:53.360
decrease

01:07:54.360 --> 01:07:56.360
这里复制过来

01:07:56.360 --> 01:07:57.360
这里是

01:07:57.360 --> 01:07:58.360
decrease

01:07:58.360 --> 01:07:59.360
async

01:07:59.360 --> 01:08:01.360
好行了啊保存

01:08:02.360 --> 01:08:03.360
好那么现在

01:08:03.360 --> 01:08:04.360
o是没有结束的对吧

01:08:04.360 --> 01:08:05.360
没有结束的

01:08:05.360 --> 01:08:06.360
现在咱们咱们来看一下

01:08:06.360 --> 01:08:07.360
increase

01:08:07.360 --> 01:08:08.360
async increase

01:08:11.380 --> 01:08:13.380
出问题了是吧

01:08:13.380 --> 01:08:14.380
出问题了

01:08:14.380 --> 01:08:15.380
我看一下

01:08:15.380 --> 01:08:16.380
o这里出问题了

01:08:16.380 --> 01:08:17.380
我们这里

01:08:17.380 --> 01:08:18.380
输出一下

01:08:18.380 --> 01:08:19.380
装o

01:08:19.380 --> 01:08:21.380
看一下有没有输出

01:08:22.380 --> 01:08:23.380
没有输出

01:08:24.380 --> 01:08:25.380
诶

01:08:25.380 --> 01:08:27.380
我这个地方都居然没有输出

01:08:27.380 --> 01:08:30.820
我看一下啊

01:08:30.820 --> 01:08:31.820
哪个地方写错了

01:08:32.820 --> 01:08:34.820
saga

01:08:34.820 --> 01:08:35.820
这里

01:08:35.820 --> 01:08:36.820
eod

01:08:36.820 --> 01:08:37.820
or

01:08:37.820 --> 01:08:38.820
or这个函数

01:08:38.820 --> 01:08:40.820
会反而回一个结果

01:08:40.820 --> 01:08:41.820
这个结果呢

01:08:41.820 --> 01:08:42.820
它没有交给

01:08:42.820 --> 01:08:43.820
现在我们的问题是

01:08:43.820 --> 01:08:45.820
它都没有交给这个or来运行

01:08:45.820 --> 01:08:47.820
都没有交给wrong or effect来运行

01:08:47.820 --> 01:08:49.820
好咱们来看一下这个wrong effect

01:08:49.820 --> 01:08:50.820
这里是不是写错了

01:08:50.820 --> 01:08:52.820
wrong effect

01:08:52.820 --> 01:08:53.820
对了对了

01:08:54.820 --> 01:08:55.820
wrong or effect

01:08:57.820 --> 01:08:59.820
我们在这里打印一下

01:08:59.820 --> 01:09:01.820
看这里有没有监控到

01:09:01.820 --> 01:09:02.820
保存

01:09:03.820 --> 01:09:05.820
这里都没有监控到

01:09:05.820 --> 01:09:06.820
看没

01:09:06.820 --> 01:09:07.820
诶哟

01:09:07.820 --> 01:09:09.820
这里都没有监控到

01:09:10.820 --> 01:09:12.820
诶我这里不是运行了or吗

01:09:13.820 --> 01:09:15.820
我看一下这里一定这个时候倒出

01:09:15.820 --> 01:09:17.820
哦也没问题啊

01:09:17.820 --> 01:09:18.820
也没问题

01:09:18.820 --> 01:09:19.820
那我们来看一下这样子吧

01:09:19.820 --> 01:09:20.820
这样怎么来看

01:09:20.820 --> 01:09:21.820
一点点的调试啊

01:09:21.820 --> 01:09:22.820
一点点的调试

01:09:22.820 --> 01:09:24.820
我们看一下这里有没有运行

01:09:24.820 --> 01:09:28.380
不要说这里都没有运行

01:09:28.380 --> 01:09:29.380
ok

01:09:29.380 --> 01:09:30.380
这里都没有运行

01:09:30.380 --> 01:09:32.380
连or这个函数都没有运行

01:09:32.380 --> 01:09:35.380
那我刚才那个or是拿倒入进来的呢

01:09:35.380 --> 01:09:36.380
我看一下啊

01:09:36.380 --> 01:09:38.380
那咱们这个or是拿倒入进来的呢

01:09:38.380 --> 01:09:39.380
这个or

01:09:40.380 --> 01:09:41.380
对啊

01:09:41.380 --> 01:09:42.380
generators

01:09:42.380 --> 01:09:44.380
any

01:09:44.380 --> 01:09:47.380
给它传的一个就是generator的数数

01:09:47.380 --> 01:09:49.380
那我这个or拿倒入进来的呢

01:09:49.380 --> 01:09:51.380
我这个掉入了or函数啊

01:09:51.380 --> 01:09:53.380
它居然连这个函数都没有运行

01:09:53.380 --> 01:09:55.380
连这个函数都没有运行

01:09:55.380 --> 01:09:58.380
好咱们再刷新一下啊刷新看一下

01:09:58.380 --> 01:10:02.380
呃在or这个函数里面再再打印一下

01:10:02.380 --> 01:10:04.380
这个见鬼了

01:10:04.380 --> 01:10:07.380
连or这个函数都没有运行

01:10:07.380 --> 01:10:09.380
如果说连or这个函数都没有运行的话

01:10:09.380 --> 01:10:12.380
那么我们也就是说在这里

01:10:12.380 --> 01:10:14.380
这前面都没有运行

01:10:14.380 --> 01:10:16.380
这这里都没有运行

01:10:16.380 --> 01:10:17.380
对吧

01:10:17.380 --> 01:10:19.380
因为它是没有运行这吗

01:10:19.380 --> 01:10:21.380
连这个函数都没有运行

01:10:21.380 --> 01:10:25.380
呃我看一下哪个地方写的有问题

01:10:25.380 --> 01:10:27.380
wrong root saga

01:10:27.380 --> 01:10:29.380
那么这个叫wrong总该运行了吧

01:10:29.380 --> 01:10:31.380
我们这里掉入了wrong的

01:10:31.380 --> 01:10:33.380
我给它这里打印一下啊

01:10:33.380 --> 01:10:35.380
这里总该运行了吧

01:10:35.380 --> 01:10:36.380
这里是运行了的

01:10:36.380 --> 01:10:38.380
好那么这个wrong saga呢

01:10:38.380 --> 01:10:40.380
是wrong saga这个函数啊

01:10:40.380 --> 01:10:42.380
wrong saga这个函数

01:10:44.380 --> 01:10:45.380
wrong saga这个函数

01:10:45.380 --> 01:10:47.380
这个函数

01:10:47.380 --> 01:10:51.460
这个函数总该运行了的

01:10:51.460 --> 01:10:52.460
这个函数运行了的

01:10:52.460 --> 01:10:53.460
然后呢

01:10:53.460 --> 01:10:55.460
这个函数我们在这里打个debug

01:10:55.460 --> 01:10:56.460
看一下怎么回事

01:10:57.460 --> 01:10:58.460
保存

01:10:59.460 --> 01:11:01.460
好我们依次调试啊

01:11:01.460 --> 01:11:03.460
呃运行这个函数啊

01:11:03.460 --> 01:11:05.460
就是我们给它的就是那个匿名函数

01:11:05.460 --> 01:11:08.460
atorator啊运行到这没问题啊

01:11:08.460 --> 01:11:09.460
运行到这个proc

01:11:09.460 --> 01:11:12.460
n传进去啊atorator传进去

01:11:12.460 --> 01:11:13.460
好

01:11:13.460 --> 01:11:14.460
然后看一下这边

01:11:14.460 --> 01:11:16.460
callback

01:11:16.460 --> 01:11:18.460
哦明白了明白了

01:11:18.460 --> 01:11:21.460
我的天啊我这里少写了预划

01:11:21.460 --> 01:11:23.460
啊我这里少写了预划

01:11:23.460 --> 01:11:24.460
就这里啊

01:11:24.460 --> 01:11:26.460
它要一在一开始的时候要雕容那个时候

01:11:26.460 --> 01:11:27.460
雕容一次对吧

01:11:27.460 --> 01:11:29.460
那才能启动任务嘛对不对

01:11:29.460 --> 01:11:30.460
启动任务

01:11:30.460 --> 01:11:32.460
不然的话任务都没有启动

01:11:33.460 --> 01:11:34.460
好那么现在呢

01:11:34.460 --> 01:11:35.460
现在应该没问题了啊

01:11:35.460 --> 01:11:37.460
现在哦那些东西应该都没问题了

01:11:37.460 --> 01:11:38.460
好现在我们试一下啊

01:11:38.460 --> 01:11:40.460
a-sync increase

01:11:40.460 --> 01:11:42.460
你看是不是增加了对吧

01:11:42.460 --> 01:11:44.460
哎 d d-sync

01:11:47.460 --> 01:11:49.460
a-sync decrease

01:11:50.460 --> 01:11:52.460
是不是增加了减少了对不对

01:11:52.460 --> 01:11:54.460
哎这两个任务是不是都没有结束

01:11:54.460 --> 01:11:55.460
啊都没有结束

01:11:55.460 --> 01:11:56.460
那么怎么整个就不会结束

01:11:56.460 --> 01:11:57.460
我就不会结束

01:11:57.460 --> 01:11:59.460
啊那么如果说这两个任务都结束了呢

01:11:59.460 --> 01:12:01.460
比方说我们这里啊

01:12:01.460 --> 01:12:03.460
take average得到一个task

01:12:03.460 --> 01:12:05.460
啊得到一个task

01:12:06.460 --> 01:12:08.460
啊那么3秒钟之后啊

01:12:08.460 --> 01:12:09.460
3秒钟之后

01:12:09.460 --> 01:12:11.460
就是取消啊tencel

01:12:11.460 --> 01:12:13.460
取消task

01:12:13.460 --> 01:12:15.460
tencel yield

01:12:15.460 --> 01:12:17.460
tencel

01:12:18.460 --> 01:12:20.460
task

01:12:20.460 --> 01:12:21.460
好

01:12:21.460 --> 01:12:25.220
那么这里呢也是一样

01:12:25.220 --> 01:12:26.220
两个都要取消啊

01:12:26.220 --> 01:12:27.220
一个取消都不行

01:12:27.220 --> 01:12:28.220
你看一下一个取消都不行

01:12:28.220 --> 01:12:29.220
我们这里

01:12:29.220 --> 01:12:31.220
这里输出

01:12:31.220 --> 01:12:33.220
任务被取消了

01:12:33.220 --> 01:12:35.220
啊被取消了

01:12:35.220 --> 01:12:37.220
啊保存

01:12:37.220 --> 01:12:41.880
eod cancel

01:12:41.880 --> 01:12:43.880
哦这里一下就被取消了对吧

01:12:43.880 --> 01:12:44.880
要等一下啊

01:12:44.880 --> 01:12:46.880
等一下稍微等一下

01:12:46.880 --> 01:12:48.880
eod

01:12:48.880 --> 01:12:51.450
点内

01:12:51.450 --> 01:12:53.450
2秒钟吗

01:12:53.450 --> 01:12:54.450
5秒钟

01:12:54.450 --> 01:12:56.450
5秒钟过后任务取消

01:12:56.450 --> 01:12:58.450
一开始没有什么问题

01:12:58.450 --> 01:13:01.450
一开始都没有什么问题

01:13:01.450 --> 01:13:03.450
好任务被取消了看没

01:13:03.450 --> 01:13:04.450
好那么现在呢

01:13:04.450 --> 01:13:06.450
我们再调用async increase

01:13:06.450 --> 01:13:07.450
哦这是decrease

01:13:07.450 --> 01:13:08.450
async decrease

01:13:08.450 --> 01:13:09.450
你看是不是没用了

01:13:09.450 --> 01:13:11.450
对吧没用了

01:13:11.450 --> 01:13:12.450
但是all有没有结束

01:13:12.450 --> 01:13:14.450
如果说all结束了的话

01:13:14.450 --> 01:13:16.450
如果说all也结束了的话

01:13:16.450 --> 01:13:17.450
这里是不是要输出

01:13:17.450 --> 01:13:18.450
saga结束了

01:13:18.450 --> 01:13:19.450
没有结束

01:13:19.450 --> 01:13:20.450
increase还没有结束

01:13:20.450 --> 01:13:22.450
所以说我们这里

01:13:22.450 --> 01:13:24.450
increase里面也搞进这样的一件事情

01:13:24.450 --> 01:13:25.450
同样一件事情

01:13:25.450 --> 01:13:27.450
好这里呢我们eod

01:13:27.450 --> 01:13:28.450
点内

01:13:28.450 --> 01:13:30.450
啊比方说6秒钟

01:13:30.450 --> 01:13:32.450
然后呢再eod

01:13:32.450 --> 01:13:33.450
cancel

01:13:33.450 --> 01:13:35.450
task

01:13:35.450 --> 01:13:37.450
拿到这个task

01:13:37.450 --> 01:13:39.450
好保存看一下啊

01:13:39.450 --> 01:13:41.450
那么一开始decrease

01:13:41.450 --> 01:13:43.450
increase都可以正常执行对吧

01:13:43.450 --> 01:13:44.450
都可以正常执行

01:13:44.450 --> 01:13:45.450
好任务被取消了

01:13:45.450 --> 01:13:47.450
好saga结束了对吧

01:13:47.450 --> 01:13:49.450
好就没了啊

01:13:49.450 --> 01:13:51.450
这是咱们这里saga的

01:13:51.450 --> 01:13:53.450
元代码写法

01:13:53.450 --> 01:13:55.450
是不是感觉有点糟啊

01:13:55.450 --> 01:13:56.450
难道有点高啊

01:13:56.450 --> 01:13:57.450
代码量也比较大

01:13:57.450 --> 01:13:59.450
只是呢我通过这个

01:13:59.450 --> 01:14:00.450
通过这个元代码分析呢

01:14:00.450 --> 01:14:01.450
告诉大家就是

01:14:01.450 --> 01:14:04.450
在这种面对这种复杂场景的话

01:14:04.450 --> 01:14:05.450
啊

01:14:05.450 --> 01:14:07.450
有这么一种处理方式

01:14:07.450 --> 01:14:08.450
而且呢你会发现

01:14:08.450 --> 01:14:10.450
这里面用到了大量的地规

01:14:10.450 --> 01:14:11.450
那个是调用那个是

01:14:11.450 --> 01:14:13.450
对吧然后呢

01:14:13.450 --> 01:14:15.450
用什么那个是

01:14:16.450 --> 01:14:18.450
那个时候里面又会调用

01:14:18.450 --> 01:14:19.450
这个saga对不对

01:14:19.450 --> 01:14:21.450
或者是调用那个proc

01:14:21.450 --> 01:14:22.450
用了那种直接或者是

01:14:22.450 --> 01:14:24.450
间接的地规

01:14:24.450 --> 01:14:25.450
那么这种好处在于呢

01:14:25.450 --> 01:14:26.450
这个逻辑呢可以从

01:14:26.450 --> 01:14:28.450
从反复的复用

01:14:28.450 --> 01:14:29.450
可以反复的复用

01:14:29.450 --> 01:14:30.450
地规这一块呢

01:14:30.450 --> 01:14:31.450
大家不要去细想

01:14:31.450 --> 01:14:32.450
他的代码执行

01:14:32.450 --> 01:14:33.450
没有这个必要

01:14:33.450 --> 01:14:34.450
你只需要知道

01:14:34.450 --> 01:14:35.450
这个函数的作用是什么

01:14:35.450 --> 01:14:37.450
要启动一个新的任务

01:14:37.450 --> 01:14:39.450
调用saga或者是proc

01:14:39.450 --> 01:14:41.450
啊saga的话你给他一个

01:14:41.450 --> 01:14:42.450
generator方形

01:14:42.450 --> 01:14:44.450
就是generator函数

01:14:44.450 --> 01:14:46.450
如果说proc的话

01:14:46.450 --> 01:14:48.450
proc的话你给他的是一个就是

01:14:48.450 --> 01:14:50.450
generator对象

01:14:50.450 --> 01:14:51.450
就是ator对象

01:14:51.450 --> 01:14:53.450
两个呢一举同工之妙

01:14:53.450 --> 01:14:54.450
因为saga

01:14:54.450 --> 01:14:56.450
本身他也会调用这个proc

01:14:56.450 --> 01:14:57.450
对不对

01:14:57.450 --> 01:14:58.450
那么我们也知道了

01:14:58.450 --> 01:15:00.450
他的主色到底是怎么回事

01:15:00.450 --> 01:15:01.450
他不是真正的主色

01:15:01.450 --> 01:15:02.450
好像这里好像是

01:15:02.450 --> 01:15:03.450
有多现成的样子

01:15:03.450 --> 01:15:04.450
他不是这样子

01:15:04.450 --> 01:15:06.450
他是用一步的方式

01:15:06.450 --> 01:15:07.450
就是我有件事

01:15:07.450 --> 01:15:08.450
但是我现在不做

01:15:08.450 --> 01:15:10.450
我等一会再做之后再做

01:15:10.450 --> 01:15:11.450
一步呢就是

01:15:11.450 --> 01:15:13.450
不是要放到时间对电业里面吗

01:15:13.450 --> 01:15:14.450
等我时间成熟了过后

01:15:14.450 --> 01:15:16.450
把它放到时间对电业里面去处理

01:15:16.450 --> 01:15:18.450
这是他的为什么会主色

01:15:18.450 --> 01:15:19.450
主色不是真正的主色

01:15:19.450 --> 01:15:20.450
是会

01:15:20.450 --> 01:15:22.450
他是一个一步的效果

01:15:22.450 --> 01:15:24.450
比方说promise我等

01:15:24.450 --> 01:15:25.450
等他

01:15:25.450 --> 01:15:26.450
等他那个完成过后

01:15:26.450 --> 01:15:27.450
我再去

01:15:27.450 --> 01:15:29.450
我再去执行下一步

01:15:29.450 --> 01:15:31.450
不是一下子就执行下一步

01:15:31.450 --> 01:15:32.450
然后呢还有什么

01:15:32.450 --> 01:15:34.450
还有那个就是take

01:15:34.450 --> 01:15:35.450
他会主色

01:15:35.450 --> 01:15:36.450
他怎么做算呢

01:15:36.450 --> 01:15:37.450
他就是要等到

01:15:37.450 --> 01:15:39.450
等到什么dispatch action的时候

01:15:39.450 --> 01:15:40.450
分发action的时候

01:15:40.450 --> 01:15:41.450
匹配上了

01:15:41.450 --> 01:15:42.450
才去运行他对应的函数

01:15:42.450 --> 01:15:43.450
那么对应的函数里面

01:15:43.450 --> 01:15:44.450
才会调用next

01:15:44.450 --> 01:15:45.450
他的主色就是

01:15:45.450 --> 01:15:46.450
其实关键点在于什么

01:15:46.450 --> 01:15:49.450
主色本质上是什么了

01:15:49.450 --> 01:15:51.450
本质上我延迟

01:15:51.450 --> 01:15:54.450
等一会再去调用next

01:15:54.450 --> 01:15:55.450
就是主色

01:15:55.450 --> 01:15:56.450
对吧

01:15:56.450 --> 01:15:57.450
我不调用next

01:15:57.450 --> 01:15:58.450
是不是迭代器就不会往下运行

01:15:58.450 --> 01:15:59.450
对不对

01:15:59.450 --> 01:16:00.450
好

01:16:00.450 --> 01:16:02.450
这整个他sacar的代码

01:16:02.450 --> 01:16:03.450
虽然说我们那个代码

01:16:03.450 --> 01:16:05.450
跟sacar的官方的元代码

01:16:05.450 --> 01:16:07.450
多多少少会有一些差异

01:16:07.450 --> 01:16:08.450
但是思路

01:16:08.450 --> 01:16:10.450
核心的思想是完全一致的

01:16:10.450 --> 01:16:11.450
我是综合了

01:16:11.450 --> 01:16:13.450
官方的元代码的就是

01:16:13.450 --> 01:16:14.450
核心理念

01:16:14.450 --> 01:16:15.450
约度了完了之后

01:16:15.450 --> 01:16:16.450
再给大家总结出来

01:16:16.450 --> 01:16:19.450
以注意是容易让大家接受的方式

01:16:19.450 --> 01:16:20.450
给大家讲出来

01:16:20.450 --> 01:16:21.450
如果说我完全的

01:16:21.450 --> 01:16:23.450
这官方的文章里面要找讲

01:16:23.450 --> 01:16:25.450
他这个前络都分为几个

01:16:25.450 --> 01:16:27.450
他这个频道都分为好几个频道

01:16:27.450 --> 01:16:29.450
不同的频道类型

01:16:29.450 --> 01:16:30.450
那这个太复杂了

01:16:30.450 --> 01:16:31.450
也没有必要

01:16:31.450 --> 01:16:32.450
但是你看我们现在

01:16:32.450 --> 01:16:33.450
这种做法是不是

01:16:33.450 --> 01:16:34.450
也可以把sacar的功能

01:16:34.450 --> 01:16:35.450
全部实现

01:16:35.450 --> 01:16:36.450
你告诉我有什么差别呢

01:16:36.450 --> 01:16:38.450
基本上基本上是没有什么差别

01:16:38.450 --> 01:16:39.450
好吧

01:16:39.450 --> 01:16:41.450
大家下来了有能力的同学

01:16:41.450 --> 01:16:43.450
尽量的自己去写一下这个sacar

01:16:43.450 --> 01:16:45.450
对你们是非常有帮助的

