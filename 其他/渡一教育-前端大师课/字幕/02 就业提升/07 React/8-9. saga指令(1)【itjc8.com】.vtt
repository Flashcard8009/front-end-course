WEBVTT

00:01.260 --> 00:03.820
这一课咱们还是接到张立科讲

00:03.820 --> 00:06.380
继续来讲解Saga里边的指令

00:06.380 --> 00:07.860
我们上一课说了

00:07.860 --> 00:10.460
Saga里面其实有很多很多的指令

00:10.460 --> 00:13.060
那么这些指令呢我们也讲不完

00:13.060 --> 00:16.660
其实还有那么几个不太用的也没有怎么讲

00:16.660 --> 00:19.460
我们只讲那些最常用的啊

00:19.460 --> 00:20.860
最常用的那些指令

00:20.860 --> 00:21.860
更多的指令的话

00:21.860 --> 00:24.260
大家可以去Saga的中文文档里面去查阅

00:24.260 --> 00:26.260
只要你理解了Saga它的核心原理

00:26.260 --> 00:29.660
那么这些指令呢你学一些也非常非常简单

00:30.060 --> 00:33.260
咱们这些课呢学习这么五个指令

00:33.260 --> 00:35.660
一个说我们之前还是还是说的啊

00:35.660 --> 00:38.760
每一个指令前面必须要使用eO的

00:38.760 --> 00:40.460
因为你不使用eO的话

00:40.460 --> 00:44.460
那个Saga它的生成器它就没法控制了啊

00:44.460 --> 00:46.060
因为我们知道之前知道啊

00:46.060 --> 00:49.360
生成器呢它能够控制生成器函数

00:49.360 --> 00:52.060
控制函数哪个位置呢控制eO的那个位置

00:52.060 --> 00:52.660
对吧

00:52.660 --> 00:54.060
所以说呢我们这里呢

00:54.060 --> 00:55.560
再多记一笔嘛啊

00:55.560 --> 01:00.660
就指令啊前面必须使用eO的啊

01:00.660 --> 01:06.360
以确保该指令的返回结果

01:06.360 --> 01:09.160
被Saga控制

01:09.160 --> 01:10.760
所以说你只因为每一个指令

01:10.760 --> 01:12.960
它都返回的是一个指令对象啊

01:12.960 --> 01:14.160
你可以这样去理解

01:14.160 --> 01:17.960
所以说呢你这个指令呢

01:17.960 --> 01:20.160
你返回的对象呢需要指令对象呢

01:20.160 --> 01:21.560
需要交给Saga来控制

01:21.560 --> 01:23.360
你必须要写名加eO的

01:23.360 --> 01:24.160
好下面呢这个呢

01:24.160 --> 01:25.460
就叫做定内指令

01:25.460 --> 01:27.360
定内指令的非常简单啊

01:27.360 --> 01:28.460
它是一个组设啊

01:28.460 --> 01:29.560
一个组设指令

01:29.560 --> 01:31.160
它能够组设啊

01:31.160 --> 01:35.860
就是组设指定的毫秒数

01:35.860 --> 01:36.960
就这么简单啊

01:36.960 --> 01:39.060
相当于是延迟多少毫秒啊

01:39.060 --> 01:41.460
定内就是延迟的意思吗啊

01:41.460 --> 01:42.960
好那么咱们举个例子啊

01:42.960 --> 01:45.460
把这些东西这些玩意儿删掉啊

01:45.460 --> 01:46.560
copy这一玩意儿删掉

01:47.860 --> 01:49.560
比方说咱们之前呢

01:49.560 --> 01:53.260
不是说那个counter task对吧

01:53.360 --> 01:55.560
这里边呢我们

01:55.560 --> 01:57.160
当我们坚持到这个action的时候呢

01:57.160 --> 01:58.360
我们触发这个函数

01:58.360 --> 02:00.460
这个action的时候呢触发这个函数

02:00.460 --> 02:02.060
那么这个函数里边呢

02:02.060 --> 02:05.460
我们希望它延迟一段时间执行啊

02:05.460 --> 02:05.860
一不忙

02:05.860 --> 02:07.060
我们有的时候为了测试

02:07.060 --> 02:09.060
为了模拟或者一些特殊的情况

02:09.060 --> 02:10.260
我们就要延迟

02:10.260 --> 02:12.460
那么我们都可能需要延迟啊

02:12.460 --> 02:13.460
但是延迟的话

02:13.460 --> 02:16.160
你在这里不能去写这个什么set timeouts啊

02:16.160 --> 02:18.160
你是不能写这个玩意儿的啊

02:18.160 --> 02:19.660
为什么不能写这个玩意儿

02:19.660 --> 02:21.260
你写这个玩意儿之后呢

02:21.260 --> 02:23.560
你这个函数能不能受到saga控制啊

02:23.560 --> 02:24.560
这不能对吧

02:24.560 --> 02:26.360
saga并不知道这里有个函数

02:26.360 --> 02:28.460
这个函数要要执行

02:28.460 --> 02:30.260
那么这句话是不是马上就执行了

02:30.260 --> 02:30.560
对不对

02:30.560 --> 02:31.560
马上就执行了

02:31.560 --> 02:32.560
那有同学说那里吧

02:32.560 --> 02:34.360
只需要把这句话写进来就完事了啊

02:34.360 --> 02:35.760
那这样子也挺简单啊

02:36.760 --> 02:38.160
是这样子也挺简单

02:38.160 --> 02:39.260
但是我们到时候呢

02:39.260 --> 02:41.460
这里是不是要去做一些副作用操作

02:41.460 --> 02:43.760
比方说我们要去触发一个action

02:43.760 --> 02:45.460
那你这里的话就没法触发了

02:45.460 --> 02:46.760
因为你触发action的时候呢

02:46.760 --> 02:48.760
我们到时候还是需要指令

02:48.760 --> 02:50.160
那你这里也没发

02:50.260 --> 02:52.160
总之你来这里面没发使用指令

02:52.160 --> 02:53.160
明白这个意思吗

02:53.160 --> 02:54.660
因为这是另外一个函数了啊

02:54.660 --> 02:55.460
就是一个

02:55.460 --> 02:57.060
satemaut里边的毁掉函数

02:57.060 --> 02:57.660
这个函数呢

02:57.660 --> 02:59.060
saga控制不了

02:59.060 --> 03:00.660
saga没法去控制这个函数

03:00.660 --> 03:02.760
所以说你这里是不能使用satemaut的啊

03:02.760 --> 03:03.760
总之不能使用

03:03.760 --> 03:04.160
一会呢

03:04.160 --> 03:06.060
我们学到一些其他的指令过后呢

03:06.060 --> 03:06.660
你就知道了

03:06.660 --> 03:07.460
你在这里面

03:07.460 --> 03:09.660
因为你在这里面没法去使用指令

03:09.660 --> 03:11.560
不是说不能使用这个satemaut

03:11.560 --> 03:13.360
而是在这里面发使用指令

03:13.360 --> 03:15.160
一些其他的指令你没法使用了

03:15.160 --> 03:17.160
因为saga他控制不到这个地方

03:17.160 --> 03:17.960
所以说呢

03:17.960 --> 03:18.360
而且呢

03:18.360 --> 03:19.160
这样的协访呢

03:19.160 --> 03:20.360
看上去也不太舒服

03:20.360 --> 03:20.960
对不对

03:20.960 --> 03:21.760
我们希望呢

03:21.760 --> 03:25.160
saga能够给我们带来一些新的开发体验

03:25.160 --> 03:25.760
就是说

03:25.760 --> 03:27.160
我们写一些异布的东西呢

03:27.160 --> 03:29.560
也可以像铜布的样子来进行书写

03:29.560 --> 03:31.160
这是saga给我们带来的

03:31.160 --> 03:32.960
特别舒服的地方

03:32.960 --> 03:33.260
所以说呢

03:33.260 --> 03:34.160
这一个呢

03:34.160 --> 03:36.560
我们不太会在saga里边

03:36.560 --> 03:37.960
去写什么satemaut啊

03:37.960 --> 03:38.560
写这些东西

03:38.560 --> 03:39.760
不太会写

03:39.760 --> 03:39.860
好

03:39.860 --> 03:41.160
咱们来看一下啊

03:41.160 --> 03:42.560
那么不用satemaut之后呢

03:42.560 --> 03:44.560
我们怎么来去延时呢

03:44.560 --> 03:46.160
我们使用一个指令啊

03:46.160 --> 03:48.160
saga里边提供了一个指令叫做delay

03:48.360 --> 03:49.960
delay这个指令

03:49.960 --> 03:50.160
好

03:50.160 --> 03:51.260
这个指令怎么用呢

03:51.260 --> 03:52.060
那就非常简单

03:52.060 --> 03:53.760
指令前面必须要写一个e有的

03:53.760 --> 03:53.960
好

03:53.960 --> 03:55.160
然后呢delay

03:55.160 --> 03:56.760
delay

03:56.760 --> 03:57.460
这里边呢

03:57.460 --> 03:59.360
写上一个就是

03:59.360 --> 04:00.560
啊

04:00.560 --> 04:03.060
指令延时延迟的时间啊

04:03.060 --> 04:04.760
写上这么一个延迟的时间啊

04:04.760 --> 04:05.260
比方说呢

04:05.260 --> 04:07.260
我们这里写上一个

04:07.260 --> 04:09.560
两秒钟吗啊

04:09.560 --> 04:10.560
2000毫秒

04:10.560 --> 04:13.060
2000毫秒之后再出发这个玩意

04:13.060 --> 04:13.360
好

04:13.360 --> 04:13.860
那么这里呢

04:13.860 --> 04:15.360
我们也可以用这种方式啊

04:16.460 --> 04:16.660
好

04:16.660 --> 04:17.060
保存

04:17.060 --> 04:17.860
咱们来看一下啊

04:18.860 --> 04:19.960
现在让我们调用啊

04:19.960 --> 04:22.260
a think decrease

04:22.260 --> 04:22.760
一回车

04:24.260 --> 04:24.860
两秒钟之后

04:24.860 --> 04:26.260
你看是不是出发这个玩意

04:26.260 --> 04:26.860
对吧

04:26.860 --> 04:27.660
那么这个一个型呢

04:27.660 --> 04:28.460
是马上触发的

04:28.460 --> 04:29.360
这个毫无疑问

04:29.360 --> 04:30.660
因为我们触发的

04:30.660 --> 04:31.460
就是这个一个型嘛

04:31.460 --> 04:31.960
对不对

04:31.960 --> 04:33.560
这个一个型马上触发啊

04:33.560 --> 04:35.160
但是等了两秒钟之后呢

04:35.160 --> 04:36.660
才会去做这件事情啊

04:36.660 --> 04:38.660
才去去运行这个函数里边的这个函

04:38.660 --> 04:39.460
这个地方

04:39.460 --> 04:40.460
你看这个意思吗

04:40.460 --> 04:41.460
相当于这个图里边

04:41.460 --> 04:42.860
我们给它触发了一个什么一个型

04:42.860 --> 04:44.260
触发了这么一个一个型啊

04:44.260 --> 04:45.460
叫做a think

04:46.460 --> 04:47.860
s y n c

04:47.860 --> 04:49.460
a think decrease

04:49.460 --> 04:50.860
触发这么一个一个型

04:50.860 --> 04:51.660
那么这个一个型呢

04:51.660 --> 04:52.860
交给了saga对吧

04:52.860 --> 04:53.460
ok

04:53.460 --> 04:54.660
那这里呢也是啊

04:56.260 --> 04:57.660
触发这么一个一个型

04:58.860 --> 04:59.460
好

04:59.460 --> 05:00.260
那么这个一个型呢

05:00.260 --> 05:01.660
肯定要经过所有的中间键

05:01.660 --> 05:02.460
因为它触发了嘛

05:02.460 --> 05:02.860
对不对

05:02.860 --> 05:03.660
它依次交给

05:03.660 --> 05:05.660
saga它不会拦戒这种中间键的

05:05.660 --> 05:06.260
不会的

05:06.260 --> 05:07.260
它不像sunk啊

05:07.260 --> 05:07.860
promise啊

05:07.860 --> 05:09.460
它会拦戒中间键啊

05:10.460 --> 05:11.460
不是拦戒中间键

05:11.460 --> 05:12.260
拦戒这个一个型

05:12.260 --> 05:12.860
它不会拦戒

05:12.860 --> 05:13.860
它会依次把这个一个型

05:13.860 --> 05:14.860
往后面移交

05:14.860 --> 05:16.260
它不知道后面要做什么

05:18.260 --> 05:18.660
所以说呢

05:18.660 --> 05:20.060
我们在那个啊

05:20.060 --> 05:20.860
log啊

05:20.860 --> 05:22.460
中间键里边也看到了这个点

05:22.460 --> 05:23.260
对吧

05:23.260 --> 05:25.460
在log中间键里边也看到了这一点啊

05:25.460 --> 05:28.060
就是看到了这个log啊

05:28.060 --> 05:31.260
log它触发了就是log里边的字字记录

05:31.260 --> 05:32.140
所以说这个中

05:32.140 --> 05:34.460
这个x它会依次移交

05:34.460 --> 05:36.260
只不过这个x它监听到了

05:36.260 --> 05:36.860
于是呢

05:36.860 --> 05:38.860
它发现了counter里面有个任务啊

05:38.860 --> 05:40.260
监听的是decrease

05:40.260 --> 05:40.860
于是呢

05:40.860 --> 05:42.860
它顺便去运行的一个函数

05:42.860 --> 05:44.860
这也是Sagara这么一种特点啊

05:44.860 --> 05:47.260
它不会阻止x型的移交啊

05:47.260 --> 05:48.660
它不会阻止x型的移交

05:49.660 --> 05:49.860
好

05:49.860 --> 05:50.460
那么这里呢

05:50.460 --> 05:52.660
一会我们运行那个increase

05:52.660 --> 05:54.460
sync increase也是一样的啊

05:54.460 --> 05:55.860
完全一样的道理

05:55.860 --> 05:57.660
你看等了秒钟之后啊

05:57.660 --> 05:59.260
再去运行这个玩意

05:59.260 --> 06:00.460
不要的意思吧

06:00.460 --> 06:01.260
OK啊

06:01.260 --> 06:02.360
那么这就是地内啊

06:02.360 --> 06:04.060
非常非常的简单

06:04.060 --> 06:06.560
那么整个这个地内有没有反回结果呢

06:06.560 --> 06:07.560
实际上有一个反回结果

06:07.560 --> 06:08.960
它就反回个true啊

06:08.960 --> 06:10.260
不过我们这个反回结果呢

06:10.260 --> 06:11.960
也没有必要去得到啊

06:11.960 --> 06:13.560
这个反回结果也没有啥意义

06:13.560 --> 06:14.260
没有啥意义

06:16.060 --> 06:16.260
啊

06:16.260 --> 06:17.360
这里呢

06:17.360 --> 06:17.960
不要说啊

06:17.960 --> 06:19.060
写上这么一个反回结果

06:19.060 --> 06:20.160
看一下吧

06:20.160 --> 06:20.760
我们这里呢

06:20.760 --> 06:22.460
increase

06:22.460 --> 06:23.560
两秒钟之后啊

06:23.560 --> 06:24.260
两秒钟之后

06:24.260 --> 06:25.160
你看得到一个true

06:25.160 --> 06:26.760
它反回的就一个true啊

06:26.760 --> 06:27.560
其实这个反回结果呢

06:27.560 --> 06:28.360
你还可以控制的

06:28.360 --> 06:29.560
就是说你在这里呢

06:29.560 --> 06:30.660
写上第二个参数

06:30.660 --> 06:31.660
这个参数写的是啥

06:31.660 --> 06:32.460
它就反回啥

06:32.460 --> 06:33.260
两秒钟之后

06:33.260 --> 06:34.160
反回一个结果

06:34.160 --> 06:35.360
比方说我们写个123

06:35.360 --> 06:36.960
那这个东西对我们来说没啥用啊

06:36.960 --> 06:37.960
没啥用

06:37.960 --> 06:39.460
就是这些API里面

06:39.460 --> 06:40.760
还有很多细致末节的东西啊

06:40.860 --> 06:41.960
只不过我们平时没啥用

06:41.960 --> 06:42.860
所以说我这里

06:42.860 --> 06:43.360
之后呢

06:43.360 --> 06:45.060
可能会忽略它来进行讲解

06:47.160 --> 06:47.360
好

06:47.360 --> 06:48.760
这是关于这个eO的啊

06:49.460 --> 06:49.660
好

06:49.660 --> 06:50.160
这个delay

06:50.160 --> 06:50.960
这关于delay

06:51.660 --> 06:51.860
好

06:51.860 --> 06:52.660
这是个主设啊

06:52.660 --> 06:53.360
它会主设的

06:53.960 --> 06:54.160
好

06:54.160 --> 06:54.780
下面这个

06:54.780 --> 06:55.560
put指令

06:56.060 --> 06:56.760
put指令呢

06:56.760 --> 06:57.960
我只要没有写主设

06:57.960 --> 06:58.860
它就不会主设

06:59.060 --> 07:00.160
put指令是什么呢

07:00.160 --> 07:01.460
put指令指的是

07:02.360 --> 07:03.360
相当于

07:03.760 --> 07:05.560
相当于dispatch

07:06.560 --> 07:07.360
一个axing

07:08.560 --> 07:10.160
它是用于触发axing的

07:10.760 --> 07:14.160
用于重新触发axing

07:15.160 --> 07:17.160
就说我们之前做附重用

07:17.160 --> 07:19.060
什么sunk promise也好

07:19.060 --> 07:19.460
对吧

07:19.460 --> 07:20.560
他们做附重用的时候

07:20.560 --> 07:22.460
是不是都是为了重新触发axing

07:22.460 --> 07:23.260
对不对

07:23.260 --> 07:24.160
不然用sunk

07:24.160 --> 07:25.760
sunk反过来是一个函数

07:25.760 --> 07:27.160
它传了一个dispatch进来

07:27.160 --> 07:28.160
那么方便你呢

07:28.660 --> 07:30.160
完成了一些附重用操作之后呢

07:30.160 --> 07:31.760
要触发一个正常的axing

07:31.760 --> 07:32.560
那么这里呢

07:32.560 --> 07:33.860
其实铺扯也是一样

07:33.860 --> 07:34.860
铺扯也是一样

07:34.860 --> 07:38.660
比方说这个increase increase增加增加

07:38.660 --> 07:39.660
增加一个就是

07:40.060 --> 07:41.760
增加一个数字

07:41.760 --> 07:42.560
那么到时候呢

07:42.560 --> 07:44.360
我们最终因为最终的增加

07:44.360 --> 07:46.260
是要去触发谁才能增加

07:46.260 --> 07:47.460
因为reducer里边

07:47.460 --> 07:48.460
它真正的增加

07:48.460 --> 07:49.860
它不是说触发这个能增加

07:49.860 --> 07:50.060
对吧

07:50.060 --> 07:51.060
我们刚才也看到了

07:51.060 --> 07:52.260
触发这个

07:52.460 --> 07:53.460
它并不能增加

07:53.460 --> 07:53.760
对吧

07:53.760 --> 07:54.460
并不能增加

07:54.460 --> 07:55.860
它一之前是死还是死

07:55.860 --> 07:58.060
因为reducer它不处理附重用

07:58.060 --> 07:59.460
附重用是在这里处理的

07:59.460 --> 08:01.060
那么这里处理完附重用

08:01.060 --> 08:02.360
比方处理的良妙中

08:02.360 --> 08:03.560
做了一些一步啊

08:03.560 --> 08:04.760
之类的乱七八糟的玩意儿

08:04.760 --> 08:06.360
良妙东之后呢

08:06.360 --> 08:08.760
你要去增加增加这个数字

08:08.860 --> 08:09.960
那怎么来增加呢

08:09.960 --> 08:11.160
你就可以使用铺子

08:11.160 --> 08:13.360
铺子呢就相当于是一个dispatch

08:13.360 --> 08:15.060
相当于是个dispatch

08:15.060 --> 08:15.960
铺子

08:15.960 --> 08:16.960
这个指令

08:16.960 --> 08:18.560
这个指令呢就相当于是一个dispatch

08:18.560 --> 08:20.160
那么我们这里可以利用铺子

08:20.160 --> 08:21.960
来触发一个新的x

08:21.960 --> 08:23.060
那么这个新的x

08:23.060 --> 08:24.660
你是不是可以利用什么

08:24.660 --> 08:26.560
x创建函数对吧

08:26.560 --> 08:27.560
increase

08:27.560 --> 08:29.060
以及什么decrease

08:29.060 --> 08:30.960
利用这些函数来得到一个

08:32.260 --> 08:33.660
就是没有附重用的x

08:33.660 --> 08:35.760
不是说没有附重的x

08:35.760 --> 08:36.860
就是一个普通的x

08:36.860 --> 08:38.860
你这个x呢传递给reducer来使用

08:38.860 --> 08:39.860
对吧就完了

08:39.860 --> 08:40.460
就完了

08:40.460 --> 08:41.860
这就是一个铺子的作用

08:41.860 --> 08:43.260
铺子的作用

08:43.260 --> 08:44.860
没问题吧

08:44.860 --> 08:45.660
那么同样的

08:45.660 --> 08:47.260
肯定要使用什么eard

08:47.260 --> 08:49.160
肯定要使用eard

08:49.160 --> 08:50.960
这是铺子的作用

08:50.960 --> 08:53.960
触发这么一个x

08:53.960 --> 08:55.160
那么这里呢

08:55.160 --> 08:55.560
下面呢

08:55.560 --> 08:57.860
我们也可以利用increase

08:57.860 --> 08:59.360
就decrease

08:59.360 --> 09:01.060
来触发这么一个x

09:01.060 --> 09:01.460
保存

09:01.460 --> 09:03.060
咱们来看一下先看效果

09:03.060 --> 09:05.160
那么目前我们坚定的是这两个x

09:05.260 --> 09:07.160
当比方说我们这里的使用

09:07.160 --> 09:09.360
increase

09:09.360 --> 09:11.460
当我们使用这个x的时空了

09:11.460 --> 09:12.960
当我们触发这个x的时空了

09:12.960 --> 09:14.360
它首先触发这个x

09:14.360 --> 09:15.560
然后两秒钟之后

09:15.560 --> 09:17.560
然后它就完成了一些附重用操作

09:17.560 --> 09:18.860
然后去触发这个x

09:18.860 --> 09:19.160
于是呢

09:19.160 --> 09:20.460
我们可以看到

09:20.460 --> 09:21.360
它对我们的x

09:21.360 --> 09:22.260
有没有什么影响了

09:22.260 --> 09:23.360
没有什么影响

09:23.360 --> 09:24.860
你看你触发两个x

09:24.860 --> 09:26.160
它就是触发了两个x

09:26.160 --> 09:27.160
它不像sunk

09:27.160 --> 09:27.560
sunk

09:27.560 --> 09:28.960
如果你x是一个对象

09:28.960 --> 09:30.660
是一个那个函数的话

09:30.660 --> 09:31.560
它会被拦截

09:31.560 --> 09:31.860
对吧

09:31.860 --> 09:33.160
不会往后面移交

09:33.160 --> 09:34.460
那么在那个

09:34.560 --> 09:35.060
saga里边

09:35.060 --> 09:37.060
它每一个x都会往后面移交

09:37.060 --> 09:38.660
都会往后面中间移交

09:38.660 --> 09:39.460
所以说日子记录了

09:39.460 --> 09:40.660
都能记录得到

09:40.660 --> 09:41.260
因为每一个x

09:41.260 --> 09:43.060
都是一个非常非常普通的x

09:43.060 --> 09:43.460
只不过呢

09:43.460 --> 09:44.360
这个x

09:44.360 --> 09:44.760
你丢失了

09:44.760 --> 09:45.460
是不是没有处理

09:45.460 --> 09:45.660
对吧

09:45.660 --> 09:46.460
它没有甩它

09:46.460 --> 09:46.860
对吧

09:46.860 --> 09:47.460
完全没甩

09:47.460 --> 09:48.260
这个x

09:48.260 --> 09:48.860
那么这个x

09:48.860 --> 09:50.160
被它坚定到了

09:50.160 --> 09:50.860
那么坚定到过程

09:50.860 --> 09:52.660
它做了什么事情呢

09:52.660 --> 09:53.960
它等了两秒钟

09:53.960 --> 09:55.360
然后去触发了

09:55.360 --> 09:59.590
触发了另外一个x

09:59.590 --> 10:00.990
我们这里

10:00.990 --> 10:02.590
怎么来画这个图

10:04.390 --> 10:04.890
那么这里呢

10:04.890 --> 10:07.190
我们该画成这么一个图

10:07.190 --> 10:09.690
这里我们使用了两秒钟之后

10:09.690 --> 10:10.690
两秒钟之后

10:12.490 --> 10:14.490
两秒之后

10:14.490 --> 10:16.090
又触发了

10:16.090 --> 10:17.790
就是increase

10:17.790 --> 10:19.490
又触发了这个x

10:19.490 --> 10:21.690
你看它就这么一种逻辑

10:21.690 --> 10:22.890
它就完成一些副作用

10:22.890 --> 10:23.890
那么完成一些副作用

10:23.890 --> 10:26.590
或者可能又会触发x

10:26.590 --> 10:27.290
那么这个x

10:27.290 --> 10:28.490
是不是reducer可以处理的

10:28.490 --> 10:29.390
对吧

10:29.390 --> 10:30.490
reducer没有处理这个x

10:30.490 --> 10:31.790
那就可以处理这个x

10:31.790 --> 10:33.290
那么它就重新去触发

10:33.290 --> 10:34.590
它不是往后边移交

10:34.690 --> 10:37.290
它是重新从头开始来触发这个increase

10:37.290 --> 10:38.790
那么由于这个increase

10:38.790 --> 10:39.690
它们又没有监听

10:39.690 --> 10:40.190
没有监听

10:40.190 --> 10:41.790
那Saga就没有做任何处理

10:41.790 --> 10:42.790
那么reducer

10:42.790 --> 10:43.590
这个reducer

10:43.590 --> 10:45.890
就不断移交到后边去

10:45.890 --> 10:48.690
也就是到时最终会触发了两个x

10:48.690 --> 10:51.090
一个是被Saga监听的这个x

10:51.090 --> 10:53.790
一个是被reducer处理的x

10:53.790 --> 10:54.490
increase

10:54.490 --> 10:54.990
看没

10:54.990 --> 10:56.090
那么现在是不是增加了

10:56.090 --> 10:56.690
对不对

10:56.690 --> 10:58.190
增加了这个数据了

10:58.190 --> 10:58.790
同样的

10:58.790 --> 10:59.490
那么decrease

10:59.490 --> 11:00.490
是不是一样的

11:00.490 --> 11:01.590
decrease也是一样的

11:01.590 --> 11:02.990
来看一下吧

11:02.990 --> 11:05.990
decrease

11:06.090 --> 11:07.590
先触发这个

11:07.590 --> 11:08.290
不行

11:08.290 --> 11:09.390
不能那样子写

11:09.390 --> 11:11.590
应该是increase

11:11.590 --> 11:13.390
那么这里先触发这个x

11:13.390 --> 11:15.390
然后等一下再触发这个x

11:15.390 --> 11:15.790
对吧

11:15.790 --> 11:16.390
put

11:16.390 --> 11:17.790
这是put的写吧

11:17.790 --> 11:18.790
非常非常简单

11:18.790 --> 11:19.690
有什么难的呢

11:19.690 --> 11:21.090
一点难度都没有

11:21.090 --> 11:23.090
这是关于put

11:23.090 --> 11:23.290
好

11:23.290 --> 11:25.790
下面这个叫做core指令

11:25.790 --> 11:28.390
core指令是用于

11:28.390 --> 11:30.490
用于副作用

11:30.490 --> 11:32.190
函数调用

11:32.190 --> 11:33.190
用于

11:33.190 --> 11:34.390
通常是一步

11:34.390 --> 11:37.520
通常是一步

11:37.520 --> 11:39.420
通常是一步

11:39.420 --> 11:40.820
一步的函数调用

11:40.820 --> 11:42.620
这是个core函数

11:42.620 --> 11:44.220
这个指令

11:44.220 --> 11:46.420
它就是来调用一些一步函数的

11:46.420 --> 11:47.620
那比方说吧

11:47.620 --> 11:48.320
比方说

11:48.320 --> 11:50.220
我们这里的student task里边

11:50.220 --> 11:51.820
我们现在来搞定学生

11:51.820 --> 11:52.820
搞定学生

11:52.820 --> 11:55.820
学生这里我看一下之前的

11:55.820 --> 11:57.520
之前的

11:57.520 --> 11:58.720
我看一下这个

11:58.720 --> 11:59.220
index

12:02.920 --> 12:04.320
这是学生的查询结果

12:04.320 --> 12:04.720
对吧

12:04.720 --> 12:05.520
查询结果

12:08.520 --> 12:11.720
在x里边

12:11.720 --> 12:12.920
看一下学生的查询结果

12:12.920 --> 12:13.320
x

12:13.320 --> 12:15.920
x是有一个设置学生数组

12:15.920 --> 12:17.020
和学生的总数

12:17.020 --> 12:17.520
对吧

12:17.520 --> 12:19.120
设置学生数组和学生总数

12:19.120 --> 12:20.520
还有一个set is loading

12:20.520 --> 12:21.920
set is loading

12:21.920 --> 12:24.320
有这么两个就是x

12:24.320 --> 12:25.420
有这么两个x

12:25.420 --> 12:27.920
那么我们再加一个有带有副作用的

12:27.920 --> 12:30.920
就是会被saga监听到的x

12:30.920 --> 12:31.620
什么x呢

12:31.620 --> 12:33.020
我们比方要说就是fetch

12:33.020 --> 12:34.620
fetch student

12:34.620 --> 12:36.920
symbol

12:37.420 --> 12:38.020
我们这里呢

12:38.020 --> 12:40.420
写上fetch student

12:40.420 --> 12:41.220
所以说saga

12:41.220 --> 12:43.520
他对x的唯一影响就是你加一个

12:43.520 --> 12:44.520
加一个x

12:44.520 --> 12:45.920
加一个x就完事了

12:45.920 --> 12:47.620
那其实这个x呢

12:47.620 --> 12:48.720
其实这个x呢

12:48.720 --> 12:50.020
他不像sunk那样子

12:50.020 --> 12:51.320
他会对x本身

12:51.320 --> 12:52.620
他的格式有所变化

12:52.620 --> 12:53.920
他没有任何变化

12:53.920 --> 12:55.320
该什么格式就是什么格式

12:55.320 --> 12:56.520
那么也要说我们导出

12:56.520 --> 12:59.320
导出一个被saga监听的x

12:59.320 --> 13:01.720
fetch student

13:01.720 --> 13:03.420
那么这里有参数就有参数

13:03.420 --> 13:04.920
没参数就没参数

13:04.920 --> 13:05.920
我们这里呢

13:05.920 --> 13:07.520
获取学生

13:07.520 --> 13:08.720
反而回忆这么一个x

13:08.720 --> 13:10.720
x就是一个普通的纯粹的对象

13:10.720 --> 13:11.120
那一型呢

13:11.120 --> 13:12.520
就是action types

13:12.520 --> 13:14.420
fetch student

13:14.420 --> 13:16.320
有没有payload的呢

13:16.320 --> 13:18.320
payload的

13:18.320 --> 13:19.320
payload的没有

13:19.320 --> 13:19.920
没有payload的

13:19.920 --> 13:21.220
就这个x

13:21.220 --> 13:23.120
那么剩下的事情就是一个副作用操作了

13:23.120 --> 13:23.920
然后就从

13:23.920 --> 13:27.620
用阿迦克斯去获取服务器的学生

13:27.620 --> 13:28.420
那么这里呢

13:28.420 --> 13:31.820
我们回到这个student's task

13:31.820 --> 13:32.420
那么这里呢

13:32.420 --> 13:34.520
就专门来监听这种x来进行处理

13:34.520 --> 13:36.920
我们这里导入这个action

13:36.920 --> 13:39.020
from

13:39.020 --> 13:42.220
返回action student

13:42.220 --> 13:43.520
search result

13:43.520 --> 13:44.120
这里呢

13:44.120 --> 13:46.620
有这么一个x叫fetch student

13:46.620 --> 13:48.320
fetch student

13:48.320 --> 13:48.820
好

13:48.820 --> 13:49.620
那么这个x

13:49.620 --> 13:50.820
我们要去监听

13:50.820 --> 13:52.320
那么这里我们怎么写

13:52.320 --> 13:53.220
回忆一下

13:53.220 --> 13:54.120
是不是要监听

13:54.120 --> 13:54.720
对吧

13:54.720 --> 13:55.020
监听呢

13:55.020 --> 13:57.820
我们导入saga

13:57.820 --> 13:59.020
effect

13:59.020 --> 14:00.520
然后这里有一个tag

14:00.520 --> 14:02.720
every

14:02.720 --> 14:03.120
好

14:03.120 --> 14:04.120
我们这里去监听啥

14:04.120 --> 14:05.520
监听那个

14:05.520 --> 14:06.420
哪个action呢

14:06.420 --> 14:08.320
就是fetch student

14:08.320 --> 14:11.720
这里是用action types

14:11.720 --> 14:11.820
好

14:11.820 --> 14:13.020
我们这里监听什么呢

14:13.020 --> 14:14.220
监听action types

14:14.220 --> 14:16.020
里边的fetch students

14:16.020 --> 14:17.120
fetch students

14:17.120 --> 14:18.620
我这里顺便说一下

14:18.620 --> 14:19.420
监听这里呢

14:19.420 --> 14:21.520
还可以写个字五串通配服

14:21.520 --> 14:22.820
还可以写个通配服

14:22.820 --> 14:23.720
那么这里可以匹配

14:23.720 --> 14:25.420
任所有的action

14:25.420 --> 14:26.820
所有的action

14:26.820 --> 14:28.220
这里是可以写通配服的

14:28.220 --> 14:28.920
但是前例条件

14:28.920 --> 14:29.420
你的action

14:29.420 --> 14:31.120
必须要是一个字五串

14:31.120 --> 14:31.620
你的action

14:31.620 --> 14:32.420
必须要是一个字五串

14:32.420 --> 14:33.720
才行

14:33.820 --> 14:35.520
action的类型必须是字五串

14:35.520 --> 14:37.120
就顺便说一下

14:37.120 --> 14:37.320
好

14:37.320 --> 14:37.920
我们这里呢

14:37.920 --> 14:38.820
action types

14:38.820 --> 14:41.120
这里边我们找到fetch students

14:41.120 --> 14:42.320
监听这个action

14:42.320 --> 14:44.020
监听好了过后去运行什么呢

14:44.020 --> 14:45.220
运行

14:45.220 --> 14:46.620
我们写这么一个函数嘛

14:46.620 --> 14:48.120
fetch students

14:48.120 --> 14:49.720
写这么一个函数

14:49.720 --> 14:50.720
这里自打而来

14:50.720 --> 14:52.120
它肯定是一个什么

14:52.120 --> 14:54.020
一个生存器函数

14:54.020 --> 14:55.720
我们去监听这个action

14:55.720 --> 14:57.920
监听这个action

14:57.920 --> 14:58.320
好

14:58.320 --> 14:59.120
这里

14:59.120 --> 15:02.120
当然它要用一有的

15:02.120 --> 15:02.720
好

15:02.720 --> 15:04.720
那么当我们运行这个action的时候

15:04.720 --> 15:06.120
它自然会触发到这

15:06.120 --> 15:07.520
测试一下吧

15:07.520 --> 15:08.320
还是一样的

15:08.320 --> 15:10.120
我们在window里边加个方法

15:10.120 --> 15:11.920
window里边

15:11.920 --> 15:13.520
window里面加个方法

15:13.520 --> 15:17.120
fetch students

15:17.120 --> 15:19.320
这个方法就触发一个action就完成了

15:19.320 --> 15:20.520
其实很简单

15:20.520 --> 15:21.120
我们这里呢

15:21.120 --> 15:23.020
导入

15:23.020 --> 15:23.520
导入呢

15:23.520 --> 15:28.320
就是导入上一个目录的action

15:28.320 --> 15:30.020
对不对

15:30.020 --> 15:31.420
导入哪呢

15:31.420 --> 15:33.620
当前目录下面的action

15:33.620 --> 15:35.720
students

15:35.720 --> 15:36.920
students

15:36.920 --> 15:37.320
然后呢

15:37.320 --> 15:39.820
search results

15:39.820 --> 15:43.020
那么这里导入的是action time

15:43.020 --> 15:44.520
fetch students

15:44.520 --> 15:45.120
那么这里呢

15:45.120 --> 15:46.020
就很简单

15:46.020 --> 15:47.320
去触发一下就完成了

15:47.320 --> 15:48.120
dispatch

15:48.120 --> 15:49.720
触发一个fetch students

15:49.720 --> 15:51.620
它反回来action

15:51.620 --> 15:53.220
所以我们这里多次用到这个名字

15:53.220 --> 15:54.120
不要搞混了

15:54.120 --> 15:55.520
这是为了

15:55.520 --> 15:56.820
外面可以好方便测试

15:56.820 --> 15:58.720
往window里边加的一个属性

15:58.720 --> 16:00.920
这是我们的action的生存

16:01.020 --> 16:01.720
函数对吧

16:01.720 --> 16:03.120
action创建函数

16:03.120 --> 16:03.520
然后呢

16:03.520 --> 16:04.320
这边

16:04.320 --> 16:04.620
这个呢

16:04.620 --> 16:07.820
是真正去执行一副作用的函数

16:07.820 --> 16:08.920
就这么个东西

16:08.920 --> 16:09.920
那么接下来呢

16:09.920 --> 16:10.620
它触发了

16:10.620 --> 16:11.920
它监听到这个东西

16:11.920 --> 16:14.020
是不是就触发到了这个

16:14.020 --> 16:14.620
什么

16:14.620 --> 16:16.120
就触发到了这个action了

16:16.120 --> 16:16.620
对不对

16:16.620 --> 16:17.820
触发到了这个函数了

16:17.820 --> 16:18.820
对不对

16:18.820 --> 16:20.820
就触发到了这么一个函数

16:20.820 --> 16:23.920
那么这个函数里边要做什么事情呢

16:23.920 --> 16:25.320
要做啥事情呢

16:25.320 --> 16:26.320
那么这里边呢

16:26.320 --> 16:28.520
他要做的事情是

16:28.520 --> 16:30.620
我们可以在这里边

16:30.620 --> 16:33.620
先要干嘛

16:33.620 --> 16:35.620
先要set is loading对不对

16:35.620 --> 16:36.520
先要把它

16:36.520 --> 16:37.820
就是正在加载中

16:37.820 --> 16:40.020
把它变成正在加载

16:40.020 --> 16:43.420
设置为正在加载中

16:43.420 --> 16:45.420
那么这个时候是不是要触发action

16:45.420 --> 16:45.720
对吧

16:45.720 --> 16:46.320
要触发action

16:46.320 --> 16:48.020
我们可以用put

16:48.020 --> 16:50.420
用put来触发action

16:50.420 --> 16:51.320
put

16:51.320 --> 16:52.620
那么触发什么action呢

16:52.620 --> 16:54.920
触发就是set is loading

16:54.920 --> 16:57.120
这个action创建函数

16:57.120 --> 16:57.320
好

16:57.320 --> 16:57.920
我们这里呢

16:57.920 --> 16:59.420
给它一个action

16:59.420 --> 17:02.120
所以去正在加载中

17:02.120 --> 17:03.720
就触发这么一个action

17:03.720 --> 17:04.220
对吧

17:04.220 --> 17:05.820
看一下啊

17:05.820 --> 17:06.020
好

17:06.020 --> 17:06.320
这里呢

17:06.320 --> 17:08.920
我们调用

17:08.920 --> 17:10.820
这里我们输出一个

17:10.820 --> 17:13.820
输出一个正在监听

17:13.820 --> 17:14.820
监听什么呢

17:14.820 --> 17:19.680
监听fetch student

17:19.680 --> 17:19.880
好

17:19.880 --> 17:20.280
那么这里呢

17:20.280 --> 17:22.480
我们使用fetch student

17:22.480 --> 17:24.380
在温豆里边的测试函数

17:24.380 --> 17:25.380
一调用

17:25.380 --> 17:25.580
好

17:25.580 --> 17:25.980
你看一下

17:25.980 --> 17:27.380
是不是触发两个action啊

17:27.380 --> 17:28.080
一开始呢

17:28.080 --> 17:29.080
它触发了这个action

17:29.080 --> 17:31.680
就这个温豆函数

17:31.680 --> 17:32.280
就这个函数

17:32.280 --> 17:33.280
它所触发的action

17:33.280 --> 17:33.680
对吧

17:33.680 --> 17:34.980
fetch student

17:34.980 --> 17:35.280
然后呢

17:35.280 --> 17:36.580
它马上就触发了另外一个action

17:36.580 --> 17:37.580
set is loading

17:37.580 --> 17:38.580
因为这个这个action

17:38.580 --> 17:39.580
被监听到了

17:39.580 --> 17:40.880
被saga监听到了

17:40.880 --> 17:41.980
那么它在这里边进行处理

17:41.980 --> 17:42.880
它又触发了一个action

17:42.880 --> 17:43.880
set is loading

17:43.880 --> 17:44.580
那么这个触发呢

17:44.580 --> 17:45.480
就相当于是

17:45.480 --> 17:47.180
在students的任务里边

17:47.180 --> 17:48.280
又进行重新触发了

17:48.280 --> 17:48.880
对吧

17:48.880 --> 17:50.580
回过头来重新触发

17:50.580 --> 17:50.780
好

17:50.780 --> 17:51.880
那么触发这个action

17:51.880 --> 17:53.580
那么现在是不是要一步获取了

17:53.580 --> 17:54.180
一步获取呢

17:54.180 --> 17:55.180
我们可以使用之前

17:55.180 --> 17:56.880
我们写到API

17:56.880 --> 17:58.680
导入

17:58.780 --> 18:00.780
from

18:00.780 --> 18:01.980
再返回

18:01.980 --> 18:03.280
services

18:03.280 --> 18:04.280
导入这个students

18:04.280 --> 18:06.480
里边不是有个叫search students

18:06.480 --> 18:07.280
对不对

18:07.280 --> 18:08.680
就这么个函数

18:08.680 --> 18:08.980
好

18:08.980 --> 18:10.280
这个函数是不是一个一步函数

18:10.280 --> 18:11.480
它返回的是一个promise

18:11.480 --> 18:12.080
看没

18:12.080 --> 18:13.480
它返回的是一个promise

18:13.480 --> 18:13.680
好

18:13.680 --> 18:14.680
那么这个函数呢

18:14.680 --> 18:16.280
我们怎么办呢

18:16.280 --> 18:16.980
怎么来办呢

18:16.980 --> 18:17.980
我们在这里呢

18:17.980 --> 18:19.080
不要去这样的写

18:19.080 --> 18:19.880
不要去这样的写

18:19.880 --> 18:22.280
我们这里要去给它一个收获条件

18:22.280 --> 18:24.380
不要在这里边去写任

18:24.380 --> 18:25.680
不要去写任

18:25.680 --> 18:27.180
为什么不要去写任呢

18:27.280 --> 18:29.680
因为任里边是不是要签了个回调函数

18:29.680 --> 18:31.780
这个回调函数你能不能去做指令

18:31.780 --> 18:32.280
不能了

18:32.280 --> 18:33.380
因为这里边又掏了一个函

18:33.380 --> 18:34.980
掏了函数就没法做指令了

18:34.980 --> 18:35.380
所以说呢

18:35.380 --> 18:36.780
不要去这样的写

18:36.780 --> 18:38.280
那么这里应该怎么写呢

18:38.280 --> 18:40.380
这里最简单的

18:40.380 --> 18:42.880
最简单的就是在这里

18:42.880 --> 18:45.380
直接前面直接写上一个eo的

18:45.380 --> 18:47.280
当saka他发现你调用一个

18:47.280 --> 18:49.080
你得到一个得到的是一个promise

18:49.080 --> 18:51.080
你把promise交给saka之后呢

18:51.080 --> 18:53.580
saka会自动的去等待这个promise

18:53.580 --> 18:55.580
这个东西我们之前是不是也自己写过

18:55.580 --> 18:56.180
对吧

18:56.180 --> 18:58.580
去等如果他发现我给就是next

18:58.580 --> 19:00.080
得到的结果是一个promise

19:00.080 --> 19:01.880
那么我会去等待这个promise

19:01.880 --> 19:03.180
把等待完成之后

19:03.180 --> 19:05.180
我才会把这个等待的结果

19:05.180 --> 19:07.580
作为返回值返回给你

19:07.580 --> 19:08.180
那么这里呢

19:08.180 --> 19:09.980
我们可以得到这个服务器的响应结果

19:09.980 --> 19:10.880
那么这样一写出来

19:10.880 --> 19:12.680
是不是跟那个awaits是差不多的

19:12.680 --> 19:14.480
但这里边是肯定不能写awaits的

19:14.480 --> 19:16.480
这又不是ebo函数

19:16.480 --> 19:17.180
那咱们呢

19:17.180 --> 19:18.580
我们这里输出啊

19:18.580 --> 19:19.780
服务器的响应结果

19:19.780 --> 19:20.680
试一下看一下啊

19:22.480 --> 19:24.180
我们这里拿学生

19:24.180 --> 19:25.980
诶等一下啊

19:25.980 --> 19:29.380
这个服务器响应又出问题了

19:29.380 --> 19:32.380
这个服务器响应怎么老是出问题啊

19:32.380 --> 19:37.740
重新来刷新一次

19:37.740 --> 19:38.440
拿到了对吧

19:38.440 --> 19:40.140
拿到了看没

19:40.140 --> 19:41.140
说明了

19:41.140 --> 19:41.640
诶

19:41.640 --> 19:43.140
这个东西他已经给你做好了

19:43.140 --> 19:43.440
对吧

19:43.440 --> 19:44.240
这不是非常舒服

19:44.240 --> 19:45.240
就像同步代码的样子

19:45.240 --> 19:47.040
书写就行了啊

19:47.040 --> 19:48.240
这大概就是啊

19:48.240 --> 19:52.140
当saka发现

19:52.140 --> 19:55.840
得到的结果是一个promise

19:55.840 --> 19:56.940
对象

19:56.940 --> 19:59.940
他会自动等待啊

19:59.940 --> 20:01.740
他会自动等待

20:01.740 --> 20:04.940
呃该对象啊

20:04.940 --> 20:06.940
该对象完成啊

20:06.940 --> 20:09.540
该promise完成

20:09.540 --> 20:10.340
然后呢

20:10.340 --> 20:12.140
完成之后

20:12.140 --> 20:15.140
会把完成的结果啊

20:15.140 --> 20:18.940
会把完成的结果啊

20:18.940 --> 20:21.040
作为值啊

20:21.040 --> 20:22.540
传递到

20:22.540 --> 20:24.040
下一次那个事

20:24.040 --> 20:24.840
所以说我们这里

20:24.940 --> 20:26.240
是不是可以收到上

20:26.240 --> 20:27.540
就下一次那个时候的值

20:27.540 --> 20:28.140
对吧

20:28.140 --> 20:29.840
那么他就会是

20:29.840 --> 20:31.940
就是那边响应的结果

20:31.940 --> 20:33.740
那就这么个意思

20:33.740 --> 20:33.940
好

20:33.940 --> 20:34.840
那么如果说

20:34.840 --> 20:36.240
那你这里没有完成

20:36.240 --> 20:38.340
那如果是为这个者拒绝了呢

20:38.340 --> 20:38.440
啊

20:38.440 --> 20:40.340
如果是为这个者拒绝了怎么办呢

20:40.340 --> 20:41.140
呃

20:41.140 --> 20:43.740
我们这里举个例子吧

20:43.740 --> 20:44.240
行吧

20:44.240 --> 20:45.440
咱们来举个例子

20:45.440 --> 20:46.540
那如果说拒绝了啊

20:46.540 --> 20:48.740
我们这里写这么一个函数

20:48.740 --> 20:49.140
呃

20:49.140 --> 20:51.440
我们写上这么一个

20:51.540 --> 20:52.940
mock

20:52.940 --> 20:53.240
啊

20:53.240 --> 20:53.840
mock

20:53.840 --> 20:55.840
就是魔力学生啊

20:55.840 --> 20:57.440
魔力学生这么一个函数

20:57.440 --> 20:59.740
他反过来是一个promise

20:59.740 --> 21:00.840
那么如果说这个promise

21:00.840 --> 21:03.240
被拒绝了会怎么样

21:03.240 --> 21:04.640
result啊

21:04.640 --> 21:06.840
会借个词

21:06.840 --> 21:08.540
啊

21:08.540 --> 21:10.040
如果说被拒绝了会怎么样呢

21:10.040 --> 21:10.240
好

21:10.240 --> 21:10.640
咱们呢

21:10.640 --> 21:11.040
这里呢

21:11.040 --> 21:12.240
如果写这么一个

21:12.240 --> 21:12.740
这个们啊

21:12.740 --> 21:14.340
写个三个set timeout啊

21:14.340 --> 21:16.640
set timeout

21:16.640 --> 21:18.140
比方说两秒钟之后啊

21:18.140 --> 21:19.540
魔力这个等待啊

21:19.540 --> 21:20.040
魔力等待

21:20.140 --> 21:21.440
两秒钟之后

21:21.440 --> 21:21.640
呃

21:21.640 --> 21:22.840
我们判断一下啊

21:22.840 --> 21:24.040
mass.radon

21:24.040 --> 21:24.840
产生个水积数

21:24.840 --> 21:26.140
如果说大于0.5

21:26.140 --> 21:28.040
那么我们就完成啊

21:28.040 --> 21:29.140
完成啊

21:29.140 --> 21:30.540
这是学生数据

21:30.540 --> 21:31.140
那么自然啊

21:31.140 --> 21:32.940
你就会得到学生数据

21:32.940 --> 21:33.640
else

21:33.640 --> 21:35.440
那么如果我们就拒绝啊

21:35.440 --> 21:37.240
就拒绝啊错误

21:38.640 --> 21:39.040
好

21:39.040 --> 21:40.240
那么比方说啊

21:41.340 --> 21:42.040
比方说

21:42.040 --> 21:43.740
那咱们如果说在这里啊

21:43.740 --> 21:44.940
出现了这么一种情况

21:44.940 --> 21:46.540
那么我们这里去调用这个mock

21:46.540 --> 21:47.440
啊mock students

21:47.440 --> 21:49.040
他反过来也是一个啊

21:49.040 --> 21:50.540
也是一个异步嘛

21:50.540 --> 21:50.940
对吧

21:50.940 --> 21:52.440
也是一个异步函数啊

21:52.440 --> 21:53.540
反过来是个promise

21:53.540 --> 21:54.440
看一下啊

21:54.440 --> 21:56.540
那么这样子又会怎么样呢

21:56.540 --> 21:56.640
好

21:56.640 --> 21:58.340
我们这里运行

21:58.340 --> 22:00.140
两秒钟之后啊

22:00.140 --> 22:00.840
得到了学生数据

22:00.840 --> 22:01.140
对吧

22:01.140 --> 22:02.040
这是正常的结果

22:02.040 --> 22:02.840
这个没问题

22:02.840 --> 22:02.940
好

22:02.940 --> 22:03.840
我们再来一次

22:03.840 --> 22:04.740
fake students

22:04.740 --> 22:06.140
两秒钟之后

22:06.140 --> 22:06.640
好

22:06.640 --> 22:07.840
你看错误会怎么样

22:07.840 --> 22:08.940
错误是不是爆错了

22:08.940 --> 22:10.040
对不对啊

22:10.040 --> 22:11.640
那么你可以想象的到啊

22:11.640 --> 22:13.240
如果啊

22:13.240 --> 22:16.840
如果promise对象被拒绝啊

22:16.840 --> 22:17.640
被拒绝

22:17.640 --> 22:19.740
saka会使用

22:19.740 --> 22:20.340
会使用什么

22:20.340 --> 22:22.740
你觉得会使用generator

22:22.740 --> 22:22.940
啊

22:22.940 --> 22:24.440
我们是不是写过的straw

22:24.440 --> 22:25.040
对吧

22:25.040 --> 22:28.140
拋出一个错误啊

22:28.140 --> 22:29.940
他会拋出这么一个错误啊

22:29.940 --> 22:31.340
就这么个意思

22:31.340 --> 22:31.640
好

22:31.640 --> 22:32.340
那么你这里

22:32.340 --> 22:33.040
他拋出错误

22:33.040 --> 22:34.340
是不是在这里可以用揣开起

22:34.340 --> 22:34.540
对吧

22:34.540 --> 22:36.040
如果说你要补货错误的话

22:36.040 --> 22:37.640
那么这里就可以用揣开起

22:37.640 --> 22:39.940
就跟同步代码的书写方式是一样的

22:39.940 --> 22:40.140
啊

22:40.140 --> 22:41.740
开启了我们这里写个arrow

22:41.740 --> 22:43.240
把这个arrow输出

22:43.240 --> 22:43.440
好

22:43.440 --> 22:44.440
看一下吧

22:44.440 --> 22:45.940
保存

22:45.940 --> 22:48.140
这里当我们使用face students

22:48.140 --> 22:49.440
等两秒钟

22:49.440 --> 22:51.140
你看是不是说错误连着两个字

22:51.140 --> 22:51.740
对吧

22:51.740 --> 22:52.540
那也就是说

22:52.540 --> 22:53.540
这个错误这里

22:53.540 --> 22:54.540
这个arrow是什么呢

22:54.540 --> 22:55.740
它不一定是错误对象

22:55.740 --> 22:56.340
因为你这里

22:56.340 --> 22:58.140
它是你拒绝的结果

22:58.140 --> 22:59.540
是你拒绝的结果

22:59.540 --> 23:00.740
你拒绝了什么

23:00.740 --> 23:01.740
你拒绝了什么

23:01.740 --> 23:03.040
那么他就

23:03.040 --> 23:03.840
他就给你返回

23:03.840 --> 23:05.340
他就给他开启别返回什么

23:05.340 --> 23:07.040
那么这个arrow

23:07.040 --> 23:09.340
arrow表示

23:09.340 --> 23:11.240
对接个者的内容

23:11.240 --> 23:12.540
啊

23:12.540 --> 23:14.340
就这么个意思

23:14.340 --> 23:15.740
这三个都被你处理好了

23:15.840 --> 23:16.940
我们这里复制一下

23:16.940 --> 23:18.240
写个副本

23:18.240 --> 23:18.940
那么这里呢

23:18.940 --> 23:22.040
就是我这里顺便说一下这个东西啊

23:22.040 --> 23:24.340
那么这里我把这个去掉了

23:24.340 --> 23:26.640
还是使用到students

23:26.640 --> 23:27.140
好

23:27.140 --> 23:27.740
那么这样子呢

23:27.740 --> 23:29.540
我去是不是拿到了服务器的返回结果

23:29.540 --> 23:30.140
对吧

23:30.140 --> 23:30.240
好

23:30.240 --> 23:31.440
那么返回结果拿到之后呢

23:31.440 --> 23:33.140
我们是不是又可以触发X型的

23:33.140 --> 23:33.640
对不对

23:33.640 --> 23:34.540
eodput

23:34.540 --> 23:35.440
触发X型

23:35.440 --> 23:36.040
我们这里呢

23:36.040 --> 23:37.140
触发什么set

23:37.140 --> 23:39.740
我们触发另外一个X型

23:39.740 --> 23:40.640
触发另外一个

23:40.640 --> 23:43.540
就是叫做set students and total

23:43.540 --> 23:44.740
去触发这个X型

23:44.740 --> 23:45.640
set students

23:46.140 --> 23:46.940
and total

23:46.940 --> 23:47.540
那么这里呢

23:47.540 --> 23:48.740
要传一个学生的数组

23:48.740 --> 23:49.540
数组在哪呢

23:49.540 --> 23:51.540
数组在这里边

23:51.540 --> 23:54.340
我看一下这个服务器返回结果是啥呀

23:54.340 --> 23:55.140
服务器返回结果

23:55.140 --> 23:56.140
我看一下吧

23:56.140 --> 23:57.340
我把它打印出来

23:57.340 --> 23:58.340
打印出来看一下

23:58.340 --> 24:00.920
我都忘了

24:00.920 --> 24:01.420
啊

24:01.420 --> 24:02.020
打印出来啊

24:02.020 --> 24:03.120
看一下

24:03.120 --> 24:04.720
datas和count

24:04.720 --> 24:07.780
datas和count

24:07.780 --> 24:08.880
datas

24:08.880 --> 24:09.980
总数呢

24:09.980 --> 24:11.480
risk count

24:11.480 --> 24:13.380
它的单字好像写的有问题

24:13.380 --> 24:15.180
count是一个u的这里

24:15.180 --> 24:15.380
好

24:15.380 --> 24:16.480
那么触发这个X型

24:16.480 --> 24:16.780
好

24:16.780 --> 24:17.080
然后呢

24:17.080 --> 24:17.980
再去触发

24:18.080 --> 24:18.480
还有什么

24:18.480 --> 24:20.080
还要把set一楼顶

24:20.080 --> 24:20.680
对吧

24:20.680 --> 24:21.980
set为什么force

24:22.980 --> 24:23.480
对吧

24:23.480 --> 24:24.380
那么这样子呢

24:24.380 --> 24:24.880
是不是达到了

24:24.880 --> 24:27.180
跟之前我们写的一个桑可一样的效果

24:27.180 --> 24:27.480
对吧

24:27.480 --> 24:28.480
是一样的效果

24:28.480 --> 24:28.880
只不过呢

24:28.880 --> 24:29.280
现在呢

24:29.280 --> 24:31.580
我们副作用是单独抽立的模块出来

24:31.580 --> 24:33.480
后来我就保持了X型

24:33.480 --> 24:35.080
非常非常的纯净

24:35.080 --> 24:35.980
你看X型

24:35.980 --> 24:37.180
有没有点乱七八糟的东西

24:37.180 --> 24:37.680
没有

24:37.680 --> 24:39.580
就是一个返回的一个纯粹的X型

24:39.580 --> 24:40.080
这个X型呢

24:40.080 --> 24:41.780
就是服务通通的一个X型

24:41.780 --> 24:43.680
reducer完全没有受到任何影响

24:43.680 --> 24:45.280
reducer它只是处理

24:45.280 --> 24:46.180
我们关心了

24:46.180 --> 24:47.480
哪些X型会触发

24:47.480 --> 24:49.380
会直接触发数据改变

24:49.380 --> 24:51.280
reducer我们只关心那些X型

24:51.280 --> 24:54.380
那些直接触发数据改变的X型

24:54.380 --> 24:55.480
那副作用我就不管了

24:55.480 --> 24:58.880
副作用专门来放到这个Saga里边再进行处理

24:58.880 --> 25:00.180
保存的看一下

25:00.180 --> 25:00.680
那么现在呢

25:00.680 --> 25:02.980
我们来触发去获取学生

25:02.980 --> 25:04.180
你看一下

25:04.180 --> 25:05.480
由于我们的副作用操作

25:05.480 --> 25:08.080
那么是不是有多个X型触发了

25:08.080 --> 25:08.980
它最先触发的

25:08.980 --> 25:10.280
直接触发的是这个X型

25:10.280 --> 25:10.780
这个X型呢

25:10.780 --> 25:12.280
被什么监听到了

25:12.280 --> 25:14.480
被那个Saga监听到了

25:14.480 --> 25:15.380
那么Saga里边

25:15.380 --> 25:16.680
它又触发了这个X型

25:16.680 --> 25:17.280
对吧

25:18.280 --> 25:19.680
然后它又去获取数据

25:19.680 --> 25:20.880
获取完数据过后了

25:20.880 --> 25:21.980
它又去触发这个X型

25:21.980 --> 25:22.580
看没

25:22.580 --> 25:24.580
又去触发这个X型

25:24.580 --> 25:25.980
不要这个意思吧

25:25.980 --> 25:26.680
OK啊

25:26.680 --> 25:29.980
这就是Saga它的这种处理方式

25:29.980 --> 25:31.880
这是关于

25:31.880 --> 25:32.880
如果说你给它

25:32.880 --> 25:34.480
给它的是一个Promise的话

25:34.480 --> 25:36.280
那么它就用这种处理

25:36.280 --> 25:38.780
那其实这里边还有一种协法

25:38.780 --> 25:39.380
还有一种协法

25:39.380 --> 25:41.280
我不是很推荐大家用这种协法

25:41.280 --> 25:42.380
不是很推荐

25:42.380 --> 25:43.580
为什么呢

25:43.580 --> 25:45.380
因为这Saga里边呢

25:45.380 --> 25:46.380
这个eO的后面呢

25:46.380 --> 25:48.380
我们尽量的保持

25:48.380 --> 25:50.780
始终放置的是指令

25:50.780 --> 25:52.080
放置的是Saga指令

25:52.080 --> 25:53.180
那么我们这里放置的

25:53.180 --> 25:54.380
是不是Saga指令

25:54.380 --> 25:54.780
不是

25:54.780 --> 25:56.480
你看这一铺扯是Saga指令

25:56.480 --> 25:58.280
我们之前的什么TagAvery对吧

25:58.280 --> 25:59.380
什么Tag啊

25:59.380 --> 26:00.880
什么All啊这种东西

26:00.880 --> 26:02.180
它们都是Saga指令

26:02.180 --> 26:03.880
但是这个东西不是Saga指令

26:03.880 --> 26:05.180
那其实不是Saga指令

26:05.180 --> 26:06.580
它也能接受

26:06.580 --> 26:07.880
如果是一个普通函数的话

26:07.880 --> 26:08.780
它就是什么都不做

26:08.780 --> 26:10.480
直接往后面运行完事了

26:10.480 --> 26:11.680
那就没有必要用eO的了

26:11.680 --> 26:12.380
对不对

26:12.380 --> 26:13.580
如果是一个Promise的话

26:13.580 --> 26:14.780
它会帮你进行等待

26:14.780 --> 26:16.580
它会做了这么一个操作

26:16.580 --> 26:18.380
只不过呢

26:18.380 --> 26:20.680
如果说我们要统一格式的话

26:20.680 --> 26:22.380
尽量都写指令

26:22.380 --> 26:23.480
为什么要统一格式

26:23.480 --> 26:25.680
是为了方便单元测试

26:25.680 --> 26:27.980
你们现在的可能还没有学习单元测试

26:27.980 --> 26:31.380
因为我们之前做了个课程规划的时候

26:31.380 --> 26:33.080
我们是把单元测试的话

26:33.080 --> 26:34.280
后边放了一方

26:34.280 --> 26:36.480
所以说你们现在还没有学习单元测试

26:36.480 --> 26:37.780
所以你无法理解

26:37.780 --> 26:39.480
它为什么要用统一种格式

26:39.480 --> 26:40.680
因为统一种格式的话

26:40.680 --> 26:41.780
是最好测试的

26:41.780 --> 26:43.480
因为无论是哪个指令

26:43.480 --> 26:45.180
它反复的都是一个指令对象

26:45.180 --> 26:47.380
到时候我们测试起来非常方便

26:47.380 --> 26:49.680
所以说强烈推荐你

26:49.680 --> 26:51.680
不要使用这种方式

26:51.680 --> 26:54.280
而去使用什么指令的方式

26:54.280 --> 26:56.280
我们这里再复制一个

26:56.280 --> 26:59.380
这里我们现在去用另外一种方式

26:59.380 --> 27:01.380
使用扣指令

27:01.380 --> 27:03.780
来达到完全一样的效果

27:03.780 --> 27:07.180
就是它用一个指令来帮助你调中函数

27:07.180 --> 27:08.980
那么这里我们就怎么来写了

27:08.980 --> 27:10.980
我们使用扣

27:10.980 --> 27:12.680
扣

27:12.680 --> 27:14.180
扣这里写上

27:14.180 --> 27:17.880
就有点类似于函数里面的一个圆形方法

27:17.880 --> 27:18.880
扣对吧

27:18.880 --> 27:20.780
扣它第一个就写上

27:20.780 --> 27:21.880
你要调中哪个函数

27:21.880 --> 27:22.680
调中哪个函数呢

27:22.680 --> 27:24.580
search students

27:24.580 --> 27:26.180
调用这个函数

27:26.180 --> 27:27.880
然后这个函数没有参数

27:27.880 --> 27:28.980
没有参数就不用写了

27:28.980 --> 27:29.880
如果有参数的话

27:29.880 --> 27:31.080
你在后面写上参数

27:31.080 --> 27:32.780
它就会把参数传进去

27:32.780 --> 27:33.680
这非常简单

27:33.680 --> 27:34.780
就这个扣

27:34.780 --> 27:36.680
那么它就会帮你去调用这个函数

27:36.680 --> 27:38.280
那么如果这个函数反回的是Promise

27:38.280 --> 27:39.880
它也会进行等待

27:39.880 --> 27:41.680
总之结构是一样的

27:41.680 --> 27:42.880
只不过呢

27:42.880 --> 27:44.680
你现在就是这种标准格式的

27:44.680 --> 27:48.880
一要的后面始终使用的是Saga指令

27:48.880 --> 27:49.880
看没

27:49.880 --> 27:50.480
好

27:50.480 --> 27:51.280
保存

27:51.280 --> 27:52.380
你看一下

27:52.380 --> 27:53.980
它是完全一样的效果

27:53.980 --> 27:55.680
你看是不是完全一样的效果

27:55.680 --> 27:56.680
对吧

27:56.680 --> 27:58.280
那么现在设置到学生之后

27:58.280 --> 28:00.680
你看最终学生他有优质的

28:00.680 --> 28:02.680
学生就有优质的

28:02.680 --> 28:05.280
data是学生有优质的

28:05.280 --> 28:06.380
看没

28:06.380 --> 28:08.180
就是我们以后强力建议大家

28:08.180 --> 28:09.880
不要去直接使用这个函数

28:09.880 --> 28:11.480
而要用扩去调用

28:11.480 --> 28:13.480
扩是调用

28:13.480 --> 28:16.480
那么这个扩调用的时候

28:16.480 --> 28:18.680
它如果有参数

28:18.680 --> 28:20.480
如果说它有参数

28:20.480 --> 28:22.480
那么它参数传递是这样子传递的

28:22.480 --> 28:24.280
它参数是这样子传递的

28:24.280 --> 28:25.480
明白这个意思吧

28:25.480 --> 28:27.280
那如果说扩里边调用这个函数

28:27.280 --> 28:29.180
如果说这个函数里边要使用Zis

28:29.180 --> 28:30.480
我们这里说一下就行了

28:30.480 --> 28:31.180
非常简单

28:31.180 --> 28:33.580
如果说它这里边要使用Zis关键字

28:33.580 --> 28:36.280
那么怎么来绑定Zis关键字呢

28:36.280 --> 28:38.480
如果说你要绑定Zis关键字的话

28:38.480 --> 28:40.480
那么你这里要写

28:40.480 --> 28:43.480
你要写这么一个数组

28:43.480 --> 28:45.180
你要写这么一个数组

28:45.180 --> 28:46.280
这个数组里边

28:46.280 --> 28:49.380
第一个参数就是Zis绑定的结果

28:49.380 --> 28:50.580
Zis绑定的结果

28:50.580 --> 28:51.380
比方说Zis

28:51.380 --> 28:53.580
我给它绑定一个字幕创ABC

28:53.580 --> 28:54.580
随便写一个

28:54.580 --> 28:55.780
随便写一个

28:55.780 --> 28:57.680
Zis比方说绑定了这个东西

28:57.680 --> 28:58.780
后边就写参数

28:58.780 --> 29:01.080
就是这么写法

29:01.080 --> 29:02.880
比方参数

29:02.880 --> 29:04.380
参数也没写了

29:04.380 --> 29:05.380
它这里没什么参数

29:05.380 --> 29:06.380
那么这样子

29:06.380 --> 29:07.680
调用这个函数的时候

29:07.680 --> 29:09.280
它会把Zis绑定进去

29:09.280 --> 29:10.080
咱们来看一下

29:10.080 --> 29:11.480
再测试一下

29:11.480 --> 29:14.680
这里我们找到之前的services

29:14.680 --> 29:16.580
这边search students

29:16.580 --> 29:19.780
这里我们在这里打印出Zis

29:19.780 --> 29:21.480
打印出Zis

29:21.480 --> 29:22.280
保存

29:22.280 --> 29:23.980
我们这里前面加上一个

29:23.980 --> 29:27.280
加上一个search students

29:27.280 --> 29:29.180
方法

29:29.180 --> 29:31.780
保存

29:31.780 --> 29:35.080
那么这里调用Face students

29:35.080 --> 29:35.680
你看

29:35.780 --> 29:37.880
Students的方法里边Zis是不是指向ABC了

29:37.880 --> 29:38.280
对吧

29:38.280 --> 29:39.380
Zis就指向ABC了

29:39.380 --> 29:40.280
就是有的时候

29:40.280 --> 29:42.280
如果说你要绑定Zis

29:42.280 --> 29:43.880
如果说你要绑定Zis的话

29:43.880 --> 29:46.480
那么就可以使用这种方式

29:46.480 --> 29:47.780
很简单

29:47.780 --> 29:48.880
这是用数组

29:48.880 --> 29:50.080
其实它还有很多用法

29:50.080 --> 29:51.780
比方说还可以写个对象

29:51.780 --> 29:52.980
第一个写个对象

29:52.980 --> 29:55.280
对象里边context

29:55.280 --> 29:58.180
context表示的是Zis的指向

29:58.180 --> 29:59.980
Zis的指向

29:59.980 --> 30:01.380
然后这里的fn

30:01.380 --> 30:04.680
表示你要调用函数search students

30:04.680 --> 30:05.880
也可以这样来传递

30:05.880 --> 30:06.680
扣

30:06.680 --> 30:07.880
你要调用函数是Zis

30:07.880 --> 30:09.780
你Zis指向的是Zis

30:09.780 --> 30:10.980
是一样的

30:10.980 --> 30:12.280
我们来看一下

30:17.680 --> 30:19.280
我们运行Face students

30:19.280 --> 30:19.780
你看

30:19.780 --> 30:20.680
是不是一样的

30:20.680 --> 30:21.380
一样的

30:21.380 --> 30:23.080
多种写法

30:23.080 --> 30:24.280
多种写法都支持

30:24.280 --> 30:25.280
当然我们如果说

30:25.280 --> 30:26.180
不绑定Zis的话

30:26.180 --> 30:27.780
不绑定Zis就很简单

30:27.780 --> 30:29.780
不绑定Zis的话

30:33.260 --> 30:34.260
没问题

30:34.360 --> 30:36.060
不绑定Zis的话就很简单了

30:36.060 --> 30:40.560
直接在这里写上函数字玩笑了

30:40.560 --> 30:42.360
这是关于扣

30:42.360 --> 30:44.560
扣这个指令

30:44.560 --> 30:45.560
好 说了扣这个指令

30:45.560 --> 30:46.360
过后我们再说一下

30:46.360 --> 30:47.660
Apply这个指令

30:47.660 --> 30:49.360
Apply这个指令

30:49.360 --> 30:50.260
这个扣这个指令

30:50.260 --> 30:51.560
有没有组设呢

30:51.560 --> 30:52.560
可能有组设

30:52.560 --> 30:53.360
可能没有

30:53.360 --> 30:55.760
那么关键看在于

30:55.760 --> 30:57.660
你是不是一个promise

30:57.660 --> 30:59.060
如果你是一个promise的话

30:59.060 --> 30:59.760
肯定要等待

30:59.760 --> 31:01.260
肯定要组设

31:01.260 --> 31:02.160
扣指令

31:02.160 --> 31:04.460
就是可能组设

31:04.460 --> 31:05.860
可能组设

31:06.660 --> 31:08.360
就是说如果你是一个promise的话

31:08.360 --> 31:09.060
它就会组设

31:09.060 --> 31:10.160
如果你不是promise的话

31:10.160 --> 31:10.760
你不会组设

31:10.760 --> 31:11.260
当然你

31:11.260 --> 31:12.660
如果你不是promise的话

31:12.660 --> 31:13.660
你调用扣干嘛了

31:13.660 --> 31:14.360
对不对

31:14.360 --> 31:15.260
你调用扣干嘛

31:15.260 --> 31:16.760
没有什么意义

31:16.760 --> 31:18.160
没有什么意义

31:18.160 --> 31:18.860
那你直接调用

31:18.860 --> 31:20.360
调用就完事了

31:20.360 --> 31:22.360
我们通常是一个promise的时候

31:22.360 --> 31:23.460
才去调用扣

31:23.460 --> 31:24.460
这个Apply指令

31:24.460 --> 31:25.960
跟扣的作用是一样的

31:25.960 --> 31:27.460
也是调用一个函数

31:27.460 --> 31:29.060
只不过它调用的格式

31:29.060 --> 31:29.960
不太一样

31:29.960 --> 31:30.560
不太一样

31:30.560 --> 31:31.660
就传餐的时候

31:31.660 --> 31:32.460
不太一样

31:32.460 --> 31:34.360
Apply指令

31:34.360 --> 31:35.160
也是一样

31:35.260 --> 31:36.260
跟call是

31:36.260 --> 31:37.660
作用是完全一样的

31:37.660 --> 31:38.960
那么比方说Apply指令

31:38.960 --> 31:39.560
它是怎么写的呢

31:39.560 --> 31:42.270
是这样子

31:42.270 --> 31:44.070
如果是Apply指令的话

31:44.070 --> 31:47.570
这么写上一个Apply

31:47.570 --> 31:48.270
说一下就行了

31:48.270 --> 31:49.170
因为这个两个是

31:49.170 --> 31:51.570
作用是完全一样的

31:51.570 --> 31:52.670
那么Apply的指令的话

31:52.670 --> 31:53.270
它是

31:53.270 --> 31:54.070
第一个参数

31:54.070 --> 31:54.870
要写什么

31:54.870 --> 31:56.470
第一个参数要写z

31:56.470 --> 31:57.470
要写z

31:57.470 --> 31:58.970
z绑定的是啥

31:58.970 --> 32:00.270
第一个参数是z

32:00.270 --> 32:01.470
第二个参数是

32:01.470 --> 32:02.770
你要调用函数

32:02.770 --> 32:04.270
后面的参数是一个数组

32:04.370 --> 32:05.470
这个数组里面就是你

32:05.470 --> 32:07.570
传递给这个函数的参数

32:07.570 --> 32:08.570
那你想回忆一下

32:08.570 --> 32:10.170
是不是跟那个

32:10.170 --> 32:12.670
那个函数里面的Apply是一样的

32:12.670 --> 32:13.370
对吧

32:13.370 --> 32:14.970
跟函数里面的Apply

32:14.970 --> 32:16.170
是完全一样的

32:16.170 --> 32:17.470
完全一样的

32:17.470 --> 32:18.670
就这么个意思

32:18.670 --> 32:20.170
说第一个是z

32:20.170 --> 32:20.670
指向了z

32:20.670 --> 32:21.770
z指向了z

32:21.770 --> 32:23.270
第二个是你调用的函数

32:23.270 --> 32:24.770
第三个是

32:24.770 --> 32:26.070
就是

32:26.070 --> 32:27.870
你具体往这个函数里面

32:27.870 --> 32:29.070
传递的参数

32:29.070 --> 32:29.570
有就有

32:29.570 --> 32:30.870
没有就没有

32:30.870 --> 32:31.570
就是Apply

32:31.570 --> 32:32.370
了解一下就行了

32:36.200 --> 32:37.500
我们用的比较多的是扣

32:37.500 --> 32:38.100
扣

32:39.400 --> 32:39.800
好

32:39.800 --> 32:40.400
那么

32:41.000 --> 32:42.400
这是扣

32:42.400 --> 32:43.900
扣就指令和Apply

32:46.200 --> 32:47.300
我们再说一下这个指令

32:47.300 --> 32:48.000
是那个指令

32:48.800 --> 32:50.300
这个指令可以用来做什么

32:50.300 --> 32:52.100
它是用于

32:52.100 --> 32:52.700
它不是

32:52.700 --> 32:53.700
它不会注射

32:53.700 --> 32:54.900
它用于得到

32:55.700 --> 32:59.200
当前仓库中的数据

32:59.200 --> 32:59.900
就是有的时候

32:59.900 --> 33:01.800
我们要做一些负重的操作的时候

33:01.800 --> 33:04.200
可能要取出当前仓库里面的数据

33:04.200 --> 33:05.600
它是来做这个事情的

33:05.600 --> 33:06.500
比方说像这里

33:10.100 --> 33:10.900
比方说这里

33:10.900 --> 33:11.600
在这里的话

33:11.600 --> 33:12.900
我们查询

33:12.900 --> 33:14.100
查询是不是要

33:15.400 --> 33:16.100
查询

33:16.800 --> 33:18.300
按照什么的查询

33:18.300 --> 33:19.900
按照就是

33:19.900 --> 33:23.900
当前仓库中的条件来进行查询

33:23.900 --> 33:24.400
对吧

33:24.400 --> 33:26.400
按照当前仓库中的条件的查询

33:26.400 --> 33:28.600
那你是不是要得到当前的仓库对象

33:28.600 --> 33:28.900
对吧

33:28.900 --> 33:29.600
仓库对象

33:29.600 --> 33:30.600
然后怎么来得到呢

33:30.600 --> 33:32.000
我们就要使用一个指令

33:32.000 --> 33:32.800
叫做slegs

33:33.300 --> 33:34.200
slegs这个指令

33:35.200 --> 33:36.000
那么这个指令

33:36.000 --> 33:36.600
我们来看一下

33:38.200 --> 33:40.900
得到这个仓库里面的数据

33:40.900 --> 33:42.600
slegs

33:43.900 --> 33:45.400
当然你肯定要用什么

33:45.400 --> 33:46.400
eo的对吧

33:46.400 --> 33:47.200
这是个指令

33:47.200 --> 33:48.000
不要忘了

33:48.000 --> 33:49.700
千万不要忘了用eo的

33:49.700 --> 33:50.200
slegs

33:50.200 --> 33:51.100
打印出来看一下吧

33:52.300 --> 33:52.900
我们这里

33:52.900 --> 33:53.700
fetch students

33:54.500 --> 33:55.300
你看一下

33:55.300 --> 33:56.800
得到了是不是整个仓库的数据

33:56.800 --> 33:57.600
对吧

33:57.600 --> 33:59.600
counter students condition

33:59.600 --> 33:59.900
对吧

33:59.900 --> 34:01.400
是不是整个仓库的数据都拿到了

34:01.400 --> 34:02.000
对不对

34:03.400 --> 34:04.100
非常简单

34:04.100 --> 34:06.500
就通过这个拿到仓库里面的数据

34:06.500 --> 34:07.500
这个slegs程里边

34:07.500 --> 34:09.100
还可以传一个函数

34:09.100 --> 34:10.100
这边还可以传个函数

34:10.100 --> 34:12.500
就是对这个数据进行筛选

34:13.700 --> 34:15.100
可以对这个数据进行筛选

34:15.100 --> 34:16.100
传这么一个函数

34:16.100 --> 34:18.000
它会把整个仓库的数据给力

34:18.000 --> 34:19.900
然后你在对这个数据

34:19.900 --> 34:21.000
你返回一个结果

34:21.000 --> 34:22.000
返回的结果

34:22.000 --> 34:24.600
就是你要获取的结果

34:24.600 --> 34:26.500
有时候先对它进行筛选一次

34:26.500 --> 34:26.900
那么比方说

34:26.900 --> 34:28.100
我们这里返回的是

34:28.100 --> 34:29.500
stats里边的

34:29.500 --> 34:30.900
student里边的

34:31.900 --> 34:33.900
那个什么

34:33.900 --> 34:35.400
condition

34:35.400 --> 34:36.600
比方说我们返回这个

34:36.600 --> 34:37.300
那么这样子

34:37.300 --> 34:39.100
我们这里一块得到的就是这个东西

34:39.100 --> 34:40.000
就这个东西

34:40.000 --> 34:41.100
当然你不用这个函数

34:41.100 --> 34:44.100
直接在这里这样子写也行

34:44.100 --> 34:45.200
稍微说一下

34:45.200 --> 34:46.900
非常简单

34:46.900 --> 34:47.900
你看看我们得到的数据

34:47.900 --> 34:48.900
是不是condition

34:48.900 --> 34:50.100
整个condition对象

34:50.100 --> 34:50.700
对吧

34:50.700 --> 34:52.600
我们可以在这里直接进行筛选

34:52.600 --> 34:55.340
condition

34:55.340 --> 34:57.340
就拿到这个condition了

34:57.340 --> 34:58.340
拿到这个condition之后

34:58.340 --> 34:59.940
我们把condition作为参数

34:59.940 --> 35:01.640
传到这个函数里边去

35:01.640 --> 35:03.940
那么这样子

35:03.940 --> 35:05.240
它在运行的时候

35:05.240 --> 35:06.640
它就会按照这个条件

35:06.640 --> 35:07.840
再进行查询

35:07.840 --> 35:08.440
保存

35:08.440 --> 35:10.440
你看看

35:10.440 --> 35:11.640
这里

35:11.640 --> 35:13.640
当然查询的结果差不多的

35:13.640 --> 35:15.840
但是我们条件就传进去了

35:15.840 --> 35:18.240
就把条件的参数传进去了

35:18.240 --> 35:19.640
就这么简单

35:19.640 --> 35:20.640
没了

35:20.640 --> 35:22.040
这是select

35:22.040 --> 35:24.880
select

35:24.880 --> 35:26.680
还有啥呢

35:26.680 --> 35:28.480
还有这个指令我说一下吧

35:28.480 --> 35:29.380
这个指令

35:29.380 --> 35:30.580
我们这些可能就讲了一些

35:30.580 --> 35:31.680
最常见的指令

35:31.680 --> 35:34.380
下面可能我们讲一些高级部分的指令

35:34.380 --> 35:35.580
CPS

35:35.580 --> 35:36.980
这个指令

35:36.980 --> 35:38.480
它是这样子

35:38.480 --> 35:40.080
它是也有可能组设

35:40.080 --> 35:40.880
可能组设

35:40.880 --> 35:43.280
遇到异部的时候可能是组设的

35:43.280 --> 35:49.380
它是用于调用那些原始的

35:49.380 --> 35:55.480
就是传统的回调方式的异部函数

35:55.480 --> 35:56.680
什么意思呢

35:56.680 --> 35:57.480
它是什么意思呢

35:57.480 --> 36:00.880
我给大家举个例子

36:00.980 --> 36:03.080
比方说我们这里复制一个

36:03.080 --> 36:10.440
又来一个mock students

36:10.440 --> 36:13.440
来模拟一个学生的数据

36:13.440 --> 36:14.940
比方说吧

36:14.940 --> 36:17.740
我们这里返回的不是一个promise

36:17.740 --> 36:21.040
我们是直接给一个set timeout

36:21.040 --> 36:23.540
给这么一个set timeout

36:23.540 --> 36:27.340
set timeout里面我们写上

36:27.340 --> 36:29.240
三秒钟

36:29.240 --> 36:32.140
三秒钟之后我们能够获得学生

36:32.140 --> 36:34.440
拿到学生过后怎么办

36:34.440 --> 36:37.740
你给我传递一个回调函数

36:37.740 --> 36:39.140
callback

36:39.140 --> 36:41.540
你给我传递这么一个回调函数

36:41.540 --> 36:46.740
三秒钟之后我会调用这个回调函数

36:46.740 --> 36:48.040
然后有可能有错误

36:48.040 --> 36:48.940
有可能没有错误

36:48.940 --> 36:50.740
比方说我们这里判断一下

36:50.740 --> 36:52.340
如果说

36:52.340 --> 36:54.040
mess the random

36:54.040 --> 36:55.440
大于0.5

36:55.440 --> 36:57.140
表示没有错误

36:57.140 --> 36:59.640
没有错误的话我就调用那个callback

36:59.640 --> 37:01.240
第一个参数表示错误对象

37:01.240 --> 37:02.640
我给你传一个null

37:02.640 --> 37:03.440
没有错误

37:03.440 --> 37:04.640
给你传一个null

37:04.640 --> 37:07.740
第二个参数表示的是我的数据

37:07.740 --> 37:09.240
我给你的数据

37:09.240 --> 37:10.240
我给你的什么数据

37:10.240 --> 37:11.940
一个学生一个学生对象

37:11.940 --> 37:13.140
学生对象

37:13.140 --> 37:14.640
count

37:14.640 --> 37:17.940
比方说78

37:17.940 --> 37:20.140
datas学生是一个数组

37:20.140 --> 37:20.940
是个数组

37:20.940 --> 37:22.140
name

37:22.140 --> 37:24.240
等于abc一个学生

37:24.240 --> 37:24.940
就写两个吧

37:24.940 --> 37:26.140
随便写两个

37:26.140 --> 37:27.540
name bct

37:27.640 --> 37:29.640
两个学生

37:29.640 --> 37:30.640
id再写一个

37:30.640 --> 37:31.640
1

37:31.640 --> 37:32.340
这里呢

37:32.340 --> 37:33.940
id写上2

37:33.940 --> 37:34.840
好了

37:34.840 --> 37:36.140
就模拟一下数据

37:36.140 --> 37:37.540
模拟一下数据

37:37.540 --> 37:39.340
不知道这里面大家有没有学过mock.js

37:39.340 --> 37:40.140
mock.js

37:40.140 --> 37:44.140
可以专门的用来模拟数据的

37:44.140 --> 37:46.340
我这里不用是一个生存器

37:46.340 --> 37:48.340
不用是个生存器

37:48.340 --> 37:51.540
3秒钟之后

37:51.540 --> 37:52.340
一个随机数

37:52.340 --> 37:53.340
如果大于0.5

37:53.340 --> 37:53.940
不要正确了

37:53.940 --> 37:56.340
正确的话我给你错误消息是那

37:56.340 --> 37:58.940
那么这里呢

37:58.940 --> 38:00.140
给你一个数据

38:00.140 --> 38:01.440
给你我获得的数据

38:01.440 --> 38:03.040
else表示错误

38:03.040 --> 38:05.640
错误的话我会给你一个callback

38:05.640 --> 38:06.940
也调用那个函数

38:06.940 --> 38:08.340
就是用传统的这种模式

38:08.340 --> 38:09.340
它不是一个promise

38:09.340 --> 38:10.540
它是一个回调

38:10.540 --> 38:12.040
第一个就是一个错误对象

38:12.040 --> 38:13.240
一个错误对象

38:13.240 --> 38:19.680
表示的是出错了

38:19.680 --> 38:20.580
然后呢

38:20.580 --> 38:21.580
给你的数据是什么

38:21.580 --> 38:22.880
给你的数据是哪

38:22.880 --> 38:24.980
没有数据

38:24.980 --> 38:26.780
好就完了

38:26.880 --> 38:27.580
那现在呢

38:27.580 --> 38:30.180
就变成这么一种回调模式

38:30.180 --> 38:32.880
这是回调模式的异步

38:32.880 --> 38:36.180
回调模式的异步

38:36.180 --> 38:37.680
那么而且这个回调方法

38:37.680 --> 38:39.380
我们是一个固定的格式

38:39.380 --> 38:41.080
一种固定的回调方法

38:41.080 --> 38:41.980
这种格式

38:41.980 --> 38:42.880
固定的

38:42.880 --> 38:44.380
那么这种回调方法

38:44.380 --> 38:45.480
它有两个参数

38:45.480 --> 38:47.480
这种叫load接式风格

38:47.480 --> 38:48.680
load接式风格

38:48.680 --> 38:49.380
那么这种风格

38:49.380 --> 38:50.180
大家load接式

38:50.180 --> 38:51.480
大家还没有接触过

38:51.480 --> 38:51.980
没有学过

38:51.980 --> 38:52.980
没关系

38:52.980 --> 38:53.880
我给大家说一下

38:53.880 --> 38:54.680
load接式风格

38:54.680 --> 38:55.880
就是这种风格

38:55.880 --> 38:56.380
callback

38:56.380 --> 38:57.680
第一个参数是错误

38:57.680 --> 38:59.680
第二参数是实际的结果

38:59.680 --> 39:03.080
那么写好了这个函数

39:03.080 --> 39:05.380
于是我们现在要去调用这个函数

39:05.380 --> 39:06.380
调用这个函数的时候

39:06.380 --> 39:08.180
我们现在还能使用call吗

39:08.180 --> 39:09.280
不能了

39:09.280 --> 39:10.780
因为call它如果返回的时候

39:10.780 --> 39:12.180
有个promise会等待

39:12.180 --> 39:14.680
那如果不是promise

39:14.680 --> 39:15.880
那它怎么办

39:15.880 --> 39:18.380
那它就把这个函数的返回结果给你

39:18.380 --> 39:19.780
这个函数返回它

39:19.780 --> 39:20.680
返回的是什么

39:20.680 --> 39:22.780
返回的是一个undefend

39:22.780 --> 39:23.580
你看这个函数返回的

39:23.580 --> 39:24.180
是不是undefend

39:24.180 --> 39:25.680
调用这个函数瞬间就返回了

39:25.780 --> 39:26.680
咱们这是undefend的

39:26.680 --> 39:29.180
这个东西得到就是undefend的

39:29.180 --> 39:29.980
那你看一下吧

39:29.980 --> 39:33.180
如果说我们这里还去调用这个mock students

39:33.180 --> 39:36.580
mock students比方的第一个参数是condition

39:36.580 --> 39:39.180
参数传进来

39:39.180 --> 39:44.380
这里就是输出一下mock students

39:44.380 --> 39:47.580
参数是condition

39:47.580 --> 39:48.780
肯定答应出来

39:48.780 --> 39:51.480
那比方说我们去调用mock students

39:51.480 --> 39:52.780
然后把参数传给它

39:52.780 --> 39:54.680
那么现在还能得到正常的结果吗

39:54.780 --> 39:56.280
就不行了

39:56.280 --> 40:00.100
看一下吧

40:00.100 --> 40:04.660
这里fade to students

40:12.420 --> 40:13.420
我写错了

40:13.420 --> 40:15.020
学错位置了

40:15.020 --> 40:17.220
应该改动这边

40:17.220 --> 40:19.020
我怎么改到这边来了

40:19.020 --> 40:21.420
把这个再复制一下

40:21.420 --> 40:23.720
把这个三拉过来

40:23.720 --> 40:24.420
是这边

40:24.420 --> 40:25.020
改动到这边

40:25.020 --> 40:26.620
我说怎么回事了

40:26.620 --> 40:28.220
那么现在我们调

40:28.220 --> 40:28.620
看一下

40:28.620 --> 40:29.520
说出错了

40:29.520 --> 40:30.020
对吧

40:30.020 --> 40:31.020
为什么出错了

40:31.020 --> 40:32.720
因为得到的是undefend

40:32.720 --> 40:34.120
得到的是undefend

40:34.120 --> 40:36.320
你看这里

40:36.320 --> 40:38.720
这里是不是得到的undefend

40:38.720 --> 40:40.720
这里得到的undefend

40:40.720 --> 40:42.020
所以他这里报了一个错

40:42.020 --> 40:42.720
他说什么呢

40:42.720 --> 40:44.420
他说那个就是

40:44.420 --> 40:45.720
connards read the property

40:45.720 --> 40:46.920
data是undefend

40:46.920 --> 40:49.020
他说你读这个data属性的时候

40:49.020 --> 40:50.620
从undefend里边读得不到

40:50.620 --> 40:51.520
为什么是undefend

40:51.520 --> 40:53.220
因为这个还说他返回了结果

40:53.220 --> 40:54.120
是不是undefend

40:54.120 --> 40:54.420
对吧

40:54.420 --> 40:55.320
他不是个promise

40:55.320 --> 40:57.020
因此他自然不会当代

40:57.020 --> 40:58.920
他是那种毁掉模式

40:58.920 --> 41:00.320
毁掉模式怎么做呢

41:00.320 --> 41:02.120
如果说以后遇到一个比较特殊的情况

41:02.120 --> 41:02.920
他又毁掉模式

41:02.920 --> 41:04.220
当然现在不太可能了

41:04.220 --> 41:07.320
基本上我们现在写的代码都是使用的是promise

41:07.320 --> 41:08.420
远程清球

41:08.420 --> 41:11.220
那么如果你确实需要使用毁掉模式

41:11.220 --> 41:13.420
你要使用cps

41:13.420 --> 41:15.420
他也是一个函数调用

41:15.420 --> 41:19.220
他就会来处理一个毁掉模式

41:19.220 --> 41:21.520
他会自动给你传的一个毁掉函数

41:21.520 --> 41:22.620
就写完了

41:22.620 --> 41:24.120
改成cps就完了

41:24.120 --> 41:25.920
调用这个函数

41:25.920 --> 41:27.920
然后把它传递一个参数 扛地形

41:27.920 --> 41:29.320
没什么问题

41:29.320 --> 41:30.520
然后呢

41:30.520 --> 41:32.220
他会自动的再往这个函数里边

41:32.220 --> 41:34.020
最后一个函数给你传一个毁掉函数

41:34.020 --> 41:35.620
他会自动传的 你不用管

41:35.620 --> 41:36.720
他会自动往这个函数里边

41:36.720 --> 41:39.320
最后一个函数给你传一个毁掉函数

41:39.320 --> 41:41.220
传了毁掉函数之后呢

41:41.220 --> 41:42.620
当调用这个毁掉

41:42.620 --> 41:43.920
他会等 等什么

41:43.920 --> 41:45.520
等这个毁掉函数调用

41:45.520 --> 41:47.920
调用这个毁掉函数的时候

41:47.920 --> 41:50.820
他才会完成

41:50.820 --> 41:51.820
完成这一次

41:51.820 --> 41:53.620
然后往后边继续走

41:53.620 --> 41:55.220
所以这个东西呢会组设的

41:55.220 --> 41:58.120
他也是有可能会组设的

41:58.120 --> 41:58.920
关键是个

41:58.920 --> 41:59.520
什么时候组设

41:59.520 --> 42:00.520
关键是个毁掉函数

42:00.520 --> 42:01.820
什么时候调用

42:01.820 --> 42:03.820
什么时候调用

42:03.820 --> 42:06.420
这就是这里的方法

42:06.420 --> 42:08.620
看一下吧

42:08.620 --> 42:11.780
保存

42:11.780 --> 42:13.780
看一下

42:13.780 --> 42:15.180
两秒钟之后

42:15.180 --> 42:16.380
三秒钟之后

42:16.380 --> 42:17.180
如果出错了

42:17.180 --> 42:18.280
那么一样的道理

42:18.280 --> 42:19.380
如果说出错了的话

42:19.380 --> 42:20.580
那么他这里的

42:20.580 --> 42:21.880
这里callback 一个 error

42:21.880 --> 42:22.480
出错了

42:22.480 --> 42:23.180
出错了后

42:23.180 --> 42:24.780
他会在这里给你抛出一个错误

42:24.780 --> 42:25.880
也是一样的

42:25.880 --> 42:26.580
也是一样的

42:26.580 --> 42:27.780
如果说你第一个参数

42:27.780 --> 42:29.380
所以说为什么要使用漏的解释

42:29.380 --> 42:30.380
标准风格

42:30.380 --> 42:31.380
因为标准风格里边

42:31.380 --> 42:32.780
第一个参数

42:32.780 --> 42:33.980
就是一个错误对象

42:33.980 --> 42:35.380
就是个错误对象

42:35.380 --> 42:36.180
他始终把第一个参数

42:36.180 --> 42:39.380
当成错误来抛出

42:39.380 --> 42:39.980
好

42:39.980 --> 42:40.580
那么这里呢

42:40.580 --> 42:41.480
我们看一下

42:41.480 --> 42:42.680
那如果是正确了

42:42.680 --> 42:43.780
正确

42:43.780 --> 42:45.980
再试一次

42:45.980 --> 42:48.180
他不可能永远出错吧

42:48.180 --> 42:50.780
没有那么贝

42:50.780 --> 42:56.000
正确的情况下

42:56.000 --> 42:58.100
等一下

42:58.100 --> 43:02.990
我的数据呢

43:02.990 --> 43:03.990
我看一下

43:03.990 --> 43:05.590
students

43:05.590 --> 43:07.090
等一下

43:07.090 --> 43:08.190
我这里的

43:08.190 --> 43:11.190
为什么一个都没出发呢

43:11.190 --> 43:12.490
再来

43:12.490 --> 43:12.790
好

43:12.790 --> 43:13.390
等一下

43:13.390 --> 43:15.290
稍微等一下

43:15.290 --> 43:16.490
又出错了

43:16.490 --> 43:19.090
再重新来

43:19.090 --> 43:19.890
所以重新刷新

43:19.890 --> 43:21.890
为什么现在刚才不行了

43:21.890 --> 43:22.790
刚才为什么不行了

43:22.790 --> 43:23.890
因为他爆错了

43:23.890 --> 43:25.190
爆出了终止了

43:25.190 --> 43:26.490
这里能不能重新来

43:26.490 --> 43:28.690
因为我这里没有进行错误处理

43:28.690 --> 43:30.190
我考这么贝

43:30.190 --> 43:31.890
我们这里变成一秒钟

43:31.890 --> 43:32.790
一秒钟

43:32.790 --> 43:34.990
我们这里写上个揣开器

43:35.090 --> 43:41.030
写上个揣开器

43:43.030 --> 43:45.030
揣开器

43:45.030 --> 43:46.730
如果爆了错误过后

43:46.730 --> 43:48.130
我们输出一个错误

43:48.130 --> 43:50.830
输出一个错误

43:50.830 --> 43:52.830
adro.message

43:52.830 --> 43:54.230
输出错误消息

43:54.230 --> 43:54.530
然后呢

43:54.530 --> 43:55.330
finally

43:55.330 --> 43:56.730
无论你有没有错误

43:56.730 --> 43:59.230
无论有没有错误

43:59.230 --> 44:01.730
你都应该把set as loading as a force

44:01.730 --> 44:03.830
这个是毫无疑问的

44:03.830 --> 44:04.530
保存

44:04.530 --> 44:05.830
写成这种格式

44:05.830 --> 44:06.030
好

44:06.030 --> 44:08.530
运行

44:08.530 --> 44:09.630
出错了

44:09.630 --> 44:10.730
怎么老是在出错

44:10.730 --> 44:12.330
我看呀

44:12.330 --> 44:14.230
怎么老是在出错

44:14.230 --> 44:16.130
出错了

44:16.130 --> 44:16.830
再来

44:16.830 --> 44:18.830
这么贝

44:18.830 --> 44:19.130
好

44:19.130 --> 44:19.930
得到几结果了

44:19.930 --> 44:20.830
得到结果了

44:20.830 --> 44:22.630
看到没有

44:22.630 --> 44:23.730
set student 产的头脱

44:23.730 --> 44:24.230
对吧

44:24.230 --> 44:26.530
得到了这个函数的返回结果

44:26.530 --> 44:27.830
你看设置完了之后

44:27.830 --> 44:28.330
一看一个写

44:28.330 --> 44:29.830
我们看一个写就行了

44:29.830 --> 44:30.430
palo 的

44:30.430 --> 44:31.230
studium 产 data

44:31.230 --> 44:32.030
什么两个数据

44:32.030 --> 44:32.730
对吧

44:32.730 --> 44:34.030
还有这个头脱78

44:34.030 --> 44:34.730
对吧

44:34.730 --> 44:36.730
也就设置进去了

44:36.730 --> 44:37.930
这是回调模式

44:37.930 --> 44:39.130
当这种情况比较少

44:39.130 --> 44:41.130
cps 了解一下就行了

44:41.130 --> 44:41.330
好

44:41.330 --> 44:41.730
这一刻

44:41.730 --> 44:43.030
咱们讲了这么一些指令

44:43.030 --> 44:44.030
这些指令里边

44:44.030 --> 44:45.930
最重要的

44:45.930 --> 44:47.430
put指令

44:47.430 --> 44:48.930
这个是毫无疑问最重要的

44:48.930 --> 44:50.430
因为他要触发一个型

44:50.430 --> 44:52.430
因为你最终是要触发一个型改变数据

44:52.430 --> 44:52.730
对不对

44:52.730 --> 44:54.730
put指令用来触发一个型

44:54.730 --> 44:56.230
call 指令调用

44:56.230 --> 44:57.330
调用附中用函数

44:57.330 --> 44:58.830
apply 指令调用附中用函数

44:58.830 --> 45:00.030
那你说

45:00.030 --> 45:00.830
原老师

45:00.830 --> 45:01.330
那如果说

45:01.330 --> 45:02.830
我要调用一个函数

45:02.830 --> 45:03.530
那个函数返回的

45:03.530 --> 45:05.030
既不是 promise

45:05.030 --> 45:06.730
他也不是回调这种模式

45:06.730 --> 45:07.830
那怎么办呢

45:08.830 --> 45:09.830
那就不用指令

45:09.830 --> 45:11.630
你直接调用这个函数不完

45:11.630 --> 45:12.630
你不用指令

45:12.630 --> 45:13.930
不是说每一个函数调用

45:13.930 --> 45:15.130
都必须要用eO的

45:15.130 --> 45:16.730
你直接调用这个函数就完事了

45:16.730 --> 45:17.830
我们为什么要用eO的

45:17.830 --> 45:20.130
是为了处理一些特殊的场景

45:20.130 --> 45:21.430
比方说附中用

45:21.430 --> 45:23.030
比方说我们要监听

45:23.030 --> 45:24.030
这些东西

45:24.030 --> 45:25.030
才去调用指令

45:25.030 --> 45:26.530
那没有其他的东西

45:26.530 --> 45:28.830
就直接调用就完事了

45:28.830 --> 45:30.530
那么这一刻需要这些指令

45:30.530 --> 45:31.430
其实有了这些指令

45:31.430 --> 45:32.430
你会发现

45:32.430 --> 45:34.430
我们的附中用是不是已经搞定的

45:34.430 --> 45:36.330
基本上就已经搞定了

45:36.330 --> 45:36.830
不过呢

45:36.830 --> 45:38.430
为了说明这个Sagara

45:38.430 --> 45:39.830
是功能非常强大的

45:39.830 --> 45:41.230
而且非常灵活的

45:41.230 --> 45:42.630
咱们下期可能还会介绍一些

45:42.630 --> 45:44.130
Sagara一些其他指令

45:44.130 --> 45:44.830
一些

45:44.830 --> 45:46.230
嗯

45:46.230 --> 45:48.030
一些我们不太会用的到

45:48.030 --> 45:50.430
但是有的时候也会用的到指令

45:50.430 --> 45:52.730
下期可不可以简单介绍一些

45:52.730 --> 45:53.830
这一刻就到这里了

