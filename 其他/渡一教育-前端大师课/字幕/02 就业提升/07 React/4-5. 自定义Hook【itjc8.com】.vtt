WEBVTT

00:00.750 --> 00:04.750
好 这节课呢咱们来讲那个制定义的 hook

00:04.750 --> 00:08.750
其实我们之前学习的两个了对吧 两个 hook 了

00:08.750 --> 00:12.750
一个是呢 叫做stat hook

00:12.750 --> 00:16.750
这个 hook 呢 它使用的函数呢 是这个 usestat

00:16.750 --> 00:21.750
我们之前说过 hook 呢 它的命名规则呢 都是 use 开头的

00:21.750 --> 00:25.750
另外一个呢 咱们学习的另外一个 hook 叫做 effect hook

00:25.750 --> 00:28.750
这个 hook 呢 它是处理副作用的

00:28.750 --> 00:32.750
那么它的函数呢 是 use effect

00:32.750 --> 00:35.750
这是咱们之前学习的 实际上呢

00:35.750 --> 00:38.750
这两个一学习的话 咱们 hook 这里呢

00:38.750 --> 00:42.750
80%的应用场景呢 都已经覆盖完了

00:42.750 --> 00:46.750
所以说我们可以呢 我儿去一些花样出来

00:46.750 --> 00:50.750
就比方说这几课 咱们讲的制定义 hook

00:50.750 --> 00:53.750
制定义 hook 呢 它是什么东西呢

00:53.750 --> 00:58.640
制定义 hook 其实非常非常简单

00:58.640 --> 01:04.640
它没有任何的新知识 就是将一些常用的

01:04.640 --> 01:12.640
常用的跨越多个组件的 hook 功能

01:12.640 --> 01:17.640
抽离出去 形成一个函数

01:17.640 --> 01:26.640
该函数 该函数呢 就是制定义 hook

01:27.640 --> 01:30.640
就这么简单 将一些常用的

01:30.640 --> 01:33.640
跨越多个组件的 hook 功能

01:33.640 --> 01:35.640
那么抽离出去 形成一个函数

01:35.640 --> 01:37.640
那么这个函数就是制定 hook

01:37.640 --> 01:39.640
那么这个东西呢 我刚才举个例子

01:39.640 --> 01:42.640
可能说起来的比较抽象 举个例子就明白了

01:42.640 --> 01:45.640
那么比方说 比方说

01:45.640 --> 01:50.640
例如 例如 比方 第1个例子嘛

01:51.640 --> 01:59.640
很多组件都需要在第1次加载完成之后

01:59.640 --> 02:06.640
第1次加载完成之后 获取学生的数据

02:06.640 --> 02:09.640
比方说 很多组件都有这么一个功能

02:09.640 --> 02:11.640
获取所有学生数据

02:11.640 --> 02:16.400
比方说 都是举例子 举例子

02:16.400 --> 02:18.400
给大家提示一个开头

02:18.400 --> 02:21.400
你不可能说 我在课程中把以后咱们项目里面的

02:21.400 --> 02:23.400
遇到的所有情况都告诉大家

02:23.400 --> 02:25.400
这个我也讲不完

02:25.400 --> 02:27.400
我也想不到那么多 对不对

02:27.400 --> 02:29.400
所以给他举个例子 开个头

02:29.400 --> 02:31.400
以后呢 大家遇到各种场景的

02:31.400 --> 02:32.400
就知道该怎么去处理了

02:32.400 --> 02:35.400
比方说 很多组件都需要在第1次加载完成之后

02:35.400 --> 02:37.400
获取所有的学生数据

02:37.400 --> 02:40.400
那么在以前的话

02:40.400 --> 02:43.400
你每个组件 比方说有10个组件都需要这样做

02:43.400 --> 02:46.400
那么你这10个组件在以前的话

02:46.400 --> 02:48.400
你是不是得写内组件

02:48.400 --> 02:49.400
对吧

02:49.400 --> 02:50.400
然后在生命周期

02:50.400 --> 02:53.400
complete a component

02:53.400 --> 02:55.400
第1次挂载完成之后

02:55.400 --> 02:57.400
生命周期函数里边

02:57.400 --> 02:59.400
然后用阿迦克斯去获取学生数据

02:59.400 --> 03:02.400
那么这个逻辑上是不是重复了

03:02.400 --> 03:03.400
有些同学说

03:03.400 --> 03:04.400
那我如果说

03:04.400 --> 03:08.400
把所有的获取学生数据放到一个函数里边

03:08.400 --> 03:10.400
抽象成一个函数 比方说这

03:10.400 --> 03:11.400
对吧

03:11.400 --> 03:12.400
把抽象成一个函数

03:12.400 --> 03:14.400
那这个可不可以呢 可以

03:14.400 --> 03:16.400
那你生命周期函数是不是得写

03:16.400 --> 03:18.400
是不是得写生命周期函数

03:18.400 --> 03:21.400
你每个生命周期函数里边要去调用这个函数

03:21.400 --> 03:23.400
最终要去调用这个函数

03:23.400 --> 03:25.400
是不是得在complete the amount

03:25.400 --> 03:28.400
生命周期函数里边去调用这个函数

03:28.400 --> 03:29.400
你这个跑不掉吧

03:29.400 --> 03:31.400
但是有了互可之后

03:31.400 --> 03:33.400
你连这一步都可以省略

03:33.400 --> 03:35.400
因为互可这个东西

03:35.400 --> 03:38.400
它拆分得非常非常细

03:38.400 --> 03:40.400
首先说 状态上的拆分

03:40.400 --> 03:42.400
它可以把状态分成多个状态

03:42.400 --> 03:43.400
不同的状态之间

03:43.400 --> 03:45.400
可以达到互不干燥的效果

03:45.400 --> 03:47.400
那么包括这个effect hook

03:47.400 --> 03:49.400
它也可以有多个

03:49.400 --> 03:52.400
所以说我们就可以进行拆分了对它

03:52.400 --> 03:54.400
因此我们比方说

03:54.400 --> 03:56.400
我们写这么一个自定义 hook

03:56.400 --> 04:00.400
我们这里新建的文件 比方说吧

04:00.400 --> 04:02.400
就要取个名字

04:04.400 --> 04:06.400
我自己的 hook 把抽象出来

04:06.400 --> 04:07.400
我们在开发过程中

04:07.400 --> 04:09.400
比方说我们发现了很多出现

04:09.400 --> 04:10.400
都要做这件事情

04:10.400 --> 04:13.400
于是我就写成了这么一个自定义 hook

04:13.400 --> 04:14.400
比方说

04:14.400 --> 04:18.400
not all students

04:18.400 --> 04:20.400
不能这样秘密

04:20.400 --> 04:21.400
自定义 hook

04:21.400 --> 04:22.400
大家注意一下

04:22.400 --> 04:24.400
自定义 hook

04:24.400 --> 04:28.400
自定义 hook

04:28.400 --> 04:35.400
由于其内部需要使用 hook 功能

04:35.400 --> 04:36.400
自定义 hook

04:36.400 --> 04:39.400
由于它内部需要使用 hook 功能

04:39.400 --> 04:47.400
所以它本身也需要按照 hook 的规则实现

04:47.400 --> 04:48.400
什么规则实现呢

04:48.400 --> 04:49.400
就是第一个

04:49.400 --> 04:56.400
就是函数名必须以 use 开头

04:56.400 --> 04:57.400
另外一个

04:57.400 --> 05:03.400
就是雕用自定义 hook 函数时

05:03.400 --> 05:04.400
现在说起来可能比较抽象

05:04.400 --> 05:05.400
以后我举例子

05:05.400 --> 05:07.400
叫雕用自定义函数时

05:07.400 --> 05:11.400
应该放到顶层

05:11.400 --> 05:12.400
什么叫顶层

05:12.400 --> 05:13.400
就不能在千套群欢呀

05:13.400 --> 05:15.400
什么千套函数里边

05:15.400 --> 05:16.400
判断里边

05:16.400 --> 05:17.400
不要放到这里边

05:17.400 --> 05:18.400
因为它里边会使用 hook

05:18.400 --> 05:20.400
hook 本来是不能放到这里边的

05:20.400 --> 05:21.400
对吧

05:21.400 --> 05:23.400
好 接下来让我们来写这么一个

05:23.400 --> 05:24.400
新建个函数

05:24.400 --> 05:30.400
咱们给它取个名字叫做 use all students

05:30.400 --> 05:31.400
.js

05:31.400 --> 05:32.400
好 写这么一个函数

05:32.400 --> 05:34.400
于是我这里就直接导出玩笑了

05:34.400 --> 05:35.400
导出这个函数

05:35.400 --> 05:39.400
名字叫做 use all students

05:39.400 --> 05:40.400
这个函数

05:40.400 --> 05:42.400
这个函数干嘛呢

05:42.400 --> 05:44.400
这个函数其实要做的事情很简单

05:44.400 --> 05:48.400
就是把第一次夹载完成之后

05:48.400 --> 05:50.400
获取所有写生数据

05:50.400 --> 05:52.400
这些动作给它抽象出去

05:52.400 --> 05:54.400
抽象成一个函数

05:54.400 --> 05:56.400
于是我们这里就导入

05:56.400 --> 05:58.400
导入什么react

05:58.400 --> 06:01.400
react 我觉得不用导入了

06:01.400 --> 06:02.400
直接导入什么

06:02.400 --> 06:03.400
从react里面

06:03.400 --> 06:08.400
导入use effect

06:08.400 --> 06:10.400
use effect

06:10.400 --> 06:12.400
你看这意思吧

06:12.400 --> 06:14.400
还导入use state

06:14.400 --> 06:16.400
我们看写完了

06:16.400 --> 06:18.400
咱们再来说再来理解

06:18.400 --> 06:21.400
由于我这里要获取学生数据

06:21.400 --> 06:23.400
所以说还要导入一个

06:23.400 --> 06:26.400
services student

06:26.400 --> 06:28.400
这里导入什么

06:28.400 --> 06:29.400
from

06:29.400 --> 06:32.400
导入get all students

06:32.400 --> 06:34.400
这里我们就把这个功能抽象出去

06:34.400 --> 06:35.400
它跟组建无关

06:35.400 --> 06:37.400
它跟哪个组建在用它无关

06:37.400 --> 06:39.400
只要你组建里面用了这个hook

06:39.400 --> 06:41.400
我们自定义的hook

06:41.400 --> 06:44.400
我们这里就能实现这个功能

06:44.400 --> 06:45.400
实现什么功能呢

06:45.400 --> 06:50.400
就是当组建首次夹载完成后

06:50.400 --> 06:53.400
获取所有学生数据

06:53.400 --> 06:55.400
就做这么一个功能

06:55.400 --> 06:56.400
这个功能怎么做呢

06:56.400 --> 06:57.400
是不是以前写过的

06:57.400 --> 06:59.400
use effect

07:00.400 --> 07:02.400
肯定是一个副作用

07:02.400 --> 07:05.400
然后副作用里面说要执行一个函数

07:05.400 --> 07:08.400
并且这个副作用是不是没有依赖项

07:08.400 --> 07:09.400
没有依赖项的话

07:09.400 --> 07:11.400
它是不是就是什么

07:11.400 --> 07:12.400
是不是就是那个

07:12.400 --> 07:14.400
第一次夹载完成过后的运行

07:14.400 --> 07:15.400
后面就不运行了

07:15.400 --> 07:17.400
而且我们还要会使用什么

07:17.400 --> 07:18.400
使用一个状态

07:18.400 --> 07:20.400
use state

07:20.400 --> 07:22.400
使用这么一个状态

07:22.400 --> 07:24.400
状态里面

07:24.400 --> 07:26.400
默认值为一个空数组

07:26.400 --> 07:28.400
因为我们要获取学生

07:28.400 --> 07:30.400
我们把它做成一个状态

07:30.400 --> 07:32.400
状态

07:32.400 --> 07:34.400
student

07:34.400 --> 07:36.400
第二个

07:36.400 --> 07:38.400
还有一个就是

07:38.400 --> 07:40.400
student

07:40.400 --> 07:42.400
写的这么一个状态

07:42.400 --> 07:43.400
OK

07:43.400 --> 07:45.400
那么现在就是在首次夹载完成之后

07:45.400 --> 07:46.400
干嘛呢

07:46.400 --> 07:47.400
干嘛呢

07:47.400 --> 07:48.400
我们是不是就用

07:48.400 --> 07:49.400
arachis请求

07:49.400 --> 07:50.400
对吧

07:50.400 --> 07:52.400
咱们这里可以写个

07:52.400 --> 07:53.400
立即执行的异步函数

07:53.400 --> 07:55.400
这是我们之前说过的

07:55.400 --> 07:57.400
立即执行的异步函数

07:57.400 --> 08:00.400
然后来通过这个函数

08:00.400 --> 08:02.400
get all students

08:02.400 --> 08:04.400
获取所有学生

08:04.400 --> 08:06.400
那么这里是不是拿到一个数组

08:06.400 --> 08:07.400
对吧

08:07.400 --> 08:09.400
拿到一个数组

08:09.400 --> 08:11.400
为什么这里要写异步函数

08:11.400 --> 08:13.400
因为use effect 这个函数本身呢

08:13.400 --> 08:15.400
我想把它变成异步函数

08:15.400 --> 08:16.400
它不行

08:16.400 --> 08:17.400
因为变成异步函数过后了

08:17.400 --> 08:19.400
异步函数它一定返回一个 promise 对象

08:19.400 --> 08:21.400
这不符合

08:21.400 --> 08:23.400
use effect 里面的这个函数规则

08:23.400 --> 08:24.400
这个函数呢

08:24.400 --> 08:25.400
它只能发现一个

08:25.400 --> 08:26.400
这个函数规则

08:26.400 --> 08:27.400
这个函数呢

08:27.400 --> 08:28.400
它只能返回一个 onD犯

08:28.400 --> 08:29.400
或者是返回一个什么

08:29.400 --> 08:30.400
返回一个函数

08:30.400 --> 08:31.400
表示清理函数

08:31.400 --> 08:33.400
你不能返回一个 promise 对象

08:33.400 --> 08:34.400
所以从没办法

08:34.400 --> 08:36.400
只能在这里面写个异步函数

08:36.400 --> 08:37.400
但是能不能不写异步函数

08:37.400 --> 08:38.400
也有人来进行了

08:38.400 --> 08:39.400
当然可以

08:39.400 --> 08:40.400
只剩了我

08:40.400 --> 08:42.400
我喜欢这样子写行不行

08:42.400 --> 08:43.400
我喜欢这样子

08:43.400 --> 08:45.400
用这个Archis来写

08:45.400 --> 08:46.400
好

08:46.400 --> 08:47.400
那么我们获取到

08:47.400 --> 08:48.400
所谓的学生数组

08:48.400 --> 08:49.400
然后把这个学生数组

08:49.400 --> 08:50.400
是不是设置状态

08:50.400 --> 08:52.400
use student

08:52.400 --> 08:54.400
student

08:54.400 --> 08:55.400
对吧

08:55.400 --> 08:56.400
把设置进去

08:56.400 --> 08:57.400
设置进去

08:57.400 --> 08:58.400
就完事了

08:58.400 --> 08:59.400
好

08:59.400 --> 09:00.400
那么

09:00.400 --> 09:02.400
这个设置的状态之后

09:02.400 --> 09:04.400
这个设置的状态之后

09:04.400 --> 09:06.400
最后咱们怎么样呢

09:06.400 --> 09:08.400
我们最后把这个

09:08.400 --> 09:10.400
student

09:10.400 --> 09:11.400
返回

09:11.400 --> 09:12.400
对吧

09:12.400 --> 09:13.400
返回什么呢

09:13.400 --> 09:15.400
返回就是学生的数组

09:15.400 --> 09:16.400
好

09:16.400 --> 09:17.400
咱们来看一下

09:17.400 --> 09:18.400
看一下

09:18.400 --> 09:19.400
好

09:19.400 --> 09:20.400
这里我们测试一下

09:20.400 --> 09:21.400
在

09:21.400 --> 09:22.400
也不在主节里面

09:22.400 --> 09:23.400
就在app里边

09:23.400 --> 09:24.400
比方测试一下

09:24.400 --> 09:25.400
好

09:25.400 --> 09:26.400
app里面

09:26.400 --> 09:27.400
它是个函数组件

09:27.400 --> 09:28.400
对吧

09:28.400 --> 09:29.400
OK

09:29.400 --> 09:30.400
我们这里

09:30.400 --> 09:31.400
希望比方说

09:31.400 --> 09:32.400
我再写个组件

09:32.400 --> 09:33.400
test

09:33.400 --> 09:35.710
来测试一下

09:35.710 --> 09:36.710
这个组件

09:36.710 --> 09:38.710
要显示所有的学生姓名

09:38.710 --> 09:40.710
要显示所有的学生姓名

09:40.710 --> 09:41.710
那么当然

09:41.710 --> 09:42.710
它只是第一次加载的时候

09:42.710 --> 09:43.710
显示

09:43.710 --> 09:44.710
后边

09:44.710 --> 09:45.710
它也不会改变了

09:45.710 --> 09:46.710
这个学生的数据

09:46.710 --> 09:47.710
它也不会发生改变

09:47.710 --> 09:48.710
所以说

09:48.710 --> 09:49.710
我们就第一次加载的时候

09:49.710 --> 09:50.710
显示就完事了

09:50.710 --> 09:51.710
那么按照以前

09:51.710 --> 09:52.710
我们要写个内组件

09:52.710 --> 09:53.710
要写生命都去函数

09:53.710 --> 09:54.710
那将来

09:54.710 --> 09:55.710
如果我们又做了一个组件

09:55.710 --> 09:56.710
又要显示

09:56.710 --> 09:57.710
用另一种格式

09:57.710 --> 09:58.710
来显示学生数据的话

09:58.710 --> 10:00.710
我们是不是又得来一次

10:00.710 --> 10:01.710
对吧

10:01.710 --> 10:02.710
比方说有多个组件

10:02.710 --> 10:04.710
他们都要显示学生数据

10:04.710 --> 10:06.710
并且都是第一次加载

10:06.710 --> 10:08.710
要得到所有的学生数据

10:08.710 --> 10:10.710
只是显示的样式不一样

10:10.710 --> 10:11.710
比方说

10:11.710 --> 10:12.710
我们先写完

10:12.710 --> 10:13.710
那么现在

10:13.710 --> 10:14.710
我们就可以利用

10:14.710 --> 10:15.710
函数组件

10:15.710 --> 10:16.710
来完成这个事

10:16.710 --> 10:17.710
于是

10:17.710 --> 10:19.710
我们再导入

10:19.710 --> 10:21.710
导入了那个什么my hooks

10:21.710 --> 10:22.710
我们发现

10:22.710 --> 10:24.710
我们自己写了一个 hook

10:24.710 --> 10:25.710
来搞定这个事情

10:25.710 --> 10:26.710
于是

10:26.710 --> 10:27.710
我们这里导入

10:27.710 --> 10:30.710
use all students

10:30.710 --> 10:32.710
导入这个 hook

10:32.710 --> 10:34.710
有了这个 hook 之后

10:34.710 --> 10:36.710
我们这里就非常非常简单了

10:36.710 --> 10:37.710
来吧

10:37.710 --> 10:38.710
直接来得到学生数据

10:38.710 --> 10:42.710
use all students hook

10:42.710 --> 10:44.710
完了

10:44.710 --> 10:45.710
没了

10:45.710 --> 10:46.710
不需要任何参数

10:46.710 --> 10:47.710
我这里没有给他参数

10:47.710 --> 10:51.340
不需要任何参数

10:51.340 --> 10:52.340
那么现在

10:53.340 --> 10:55.340
有了这个数据之后

10:55.340 --> 10:56.340
我们直接把渲染出来

10:56.340 --> 10:57.340
就完事了

10:57.340 --> 10:58.340
就没了

10:58.340 --> 10:59.340
就这么简单

10:59.340 --> 11:00.340
list

11:00.340 --> 11:01.340
你看一下

11:01.340 --> 11:02.340
现在代码了

11:02.340 --> 11:04.340
变得极其的简洁

11:06.340 --> 11:07.340
一个li

11:07.340 --> 11:08.340
比方说给他个keyz

11:08.340 --> 11:09.340
keyz为什么

11:09.340 --> 11:10.340
it

11:10.340 --> 11:11.340
这里显示的是

11:11.340 --> 11:13.340
it's the name

11:13.340 --> 11:14.340
OK

11:14.340 --> 11:15.340
我们这里返回

11:15.340 --> 11:17.340
返回一个 ul

11:17.340 --> 11:18.340
里边写list

11:18.340 --> 11:19.340
完了

11:19.340 --> 11:20.340
没了

11:20.340 --> 11:21.340
你看这个

11:21.340 --> 11:23.340
写的是不是非常非常简洁了

11:23.340 --> 11:24.340
对吧

11:24.340 --> 11:25.340
运行出来看一下

11:26.340 --> 11:27.340
CD

11:27.340 --> 11:28.340
我们先运行出来

11:28.340 --> 11:29.340
可以看到效果

11:29.340 --> 11:30.340
慢慢来解释

11:35.980 --> 11:40.460
我们解释一下

11:40.460 --> 11:42.460
他是怎么运作的

11:42.460 --> 11:43.460
然后

11:44.460 --> 11:45.460
我们再来说

11:46.460 --> 11:47.460
他跟我们对比

11:47.460 --> 11:48.460
对比这个class

11:48.460 --> 11:49.460
组件了

11:49.460 --> 11:51.460
他有什么样的优势

11:54.460 --> 11:55.460
他说

11:57.460 --> 11:59.460
尝试导入错误

12:05.460 --> 12:06.460
他说

12:06.460 --> 12:07.460
这个模块里面

12:07.460 --> 12:09.460
我们没有一个默认导出

12:09.460 --> 12:10.460
哦

12:10.460 --> 12:11.460
这里没写

12:11.460 --> 12:12.460
export default

12:12.460 --> 12:13.460
保存

12:14.460 --> 12:15.460
你看一下

12:15.460 --> 12:17.460
是不是先在功能了

12:17.460 --> 12:18.460
莫名其妙

12:18.460 --> 12:19.460
看这个代码

12:19.460 --> 12:20.460
怎么这么简单

12:20.460 --> 12:21.460
几句代码就实现了

12:21.460 --> 12:22.460
这是怎么回事呢

12:22.460 --> 12:23.460
你想想这个道理

12:23.460 --> 12:24.460
咱们来捋一下

12:24.460 --> 12:25.460
捋一下

12:25.460 --> 12:27.460
你在调用这个函数

12:27.460 --> 12:28.460
是不是就相当于

12:28.460 --> 12:30.460
是在运行这个函数里面代码

12:31.460 --> 12:32.460
对吧

12:32.460 --> 12:33.460
是不是就相当于

12:33.460 --> 12:35.460
是把这个代码放这儿来了

12:36.460 --> 12:37.460
是吧

12:37.460 --> 12:38.460
相当于把这个代码放这儿来了

12:38.460 --> 12:39.460
对吧

12:39.460 --> 12:41.460
比方这里是stews

12:41.460 --> 12:42.460
是吧

12:42.460 --> 12:43.460
把这个代码放这儿来了

12:43.460 --> 12:44.460
没问题吧

12:45.460 --> 12:46.460
那么

12:46.460 --> 12:47.460
这个代码能理解吗

12:47.460 --> 12:48.460
我们之前讲过的

12:48.460 --> 12:49.460
那这里使用了状态

12:49.460 --> 12:50.460
对吧

12:50.460 --> 12:52.460
当地势加载完成之后

12:52.460 --> 12:53.460
当地势加载完成之后

12:53.460 --> 12:54.460
他会运行这个函数

12:54.460 --> 12:55.460
这个函数呢

12:55.460 --> 12:56.460
最终执行了一些副作用

12:56.460 --> 12:58.460
比方说一步软件拔刀的东西

12:58.460 --> 12:59.460
最终呢

12:59.460 --> 13:01.460
他会得到一个学生数组

13:01.460 --> 13:03.460
把这个数组重新设置为状态

13:03.460 --> 13:04.460
重新设置为状态

13:04.460 --> 13:05.460
是不是又重新刷新

13:05.460 --> 13:07.460
又重新刷新这个组件

13:07.460 --> 13:09.460
那么重新刷新这个组件的时候

13:09.460 --> 13:10.460
由于这个

13:10.460 --> 13:12.460
再一次拿到之前的状态

13:12.460 --> 13:13.460
对吧

13:13.460 --> 13:14.460
他就不会重新拿

13:14.460 --> 13:15.460
重新出使化了

13:15.460 --> 13:16.460
我们之前讲过了

13:16.460 --> 13:17.460
因为之前已经有这个状态了

13:17.460 --> 13:19.460
那么就会拿到新的状态

13:19.460 --> 13:21.460
新的状态就是学生

13:21.460 --> 13:22.460
具有数据的学生数组

13:22.460 --> 13:23.460
然后由于呢

13:23.460 --> 13:25.460
这个依赖相没有发生变化

13:25.460 --> 13:26.460
所以从了这个

13:26.460 --> 13:27.460
后可函数呢

13:27.460 --> 13:28.460
还有没有再执行

13:28.460 --> 13:29.460
对吧

13:29.460 --> 13:30.460
第二次就没有再执行了

13:30.460 --> 13:31.460
于是呢

13:31.460 --> 13:32.460
他就宣展出了

13:32.460 --> 13:33.460
有数据的学生数组

13:33.460 --> 13:35.460
把这么长的一段话

13:35.460 --> 13:36.460
好好看几遍

13:36.460 --> 13:37.460
好好看几遍

13:37.460 --> 13:38.460
我来说什么

13:38.460 --> 13:40.460
就相当于把写到这儿来了

13:40.460 --> 13:41.460
无非呢

13:41.460 --> 13:42.460
现在呢

13:42.460 --> 13:43.460
我们就是把他放到函数里边去了

13:43.460 --> 13:44.460
有啥区别呢

13:44.460 --> 13:46.460
我们雕用这个函数

13:46.460 --> 13:48.460
是不是就是在雕用这一段代码

13:48.460 --> 13:49.460
对吧

13:49.460 --> 13:50.460
你看一下啊

13:50.460 --> 13:51.460
咱们第一次加在

13:51.460 --> 13:52.460
函数里边的时候

13:52.460 --> 13:53.460
雕用这个函数

13:53.460 --> 13:55.460
雕用这个函数干嘛呢

13:55.460 --> 13:56.460
它干嘛

13:56.460 --> 13:58.460
它是不是产生一个状态

13:58.460 --> 13:59.460
对吧

13:59.460 --> 14:00.460
先产生个状态

14:00.460 --> 14:01.460
默认是空速组

14:01.460 --> 14:02.460
一开始就是空速组

14:02.460 --> 14:03.460
然后呢

14:03.460 --> 14:05.460
注册了一个副作用的函数

14:05.460 --> 14:07.460
有它的依赖相

14:07.460 --> 14:08.460
那么这个副作用函数呢

14:08.460 --> 14:09.460
目前还不会运行

14:09.460 --> 14:10.460
要等宣展完成之后

14:10.460 --> 14:11.460
才会运行

14:11.460 --> 14:12.460
然后呢

14:12.460 --> 14:13.460
我们把这个空速组

14:13.460 --> 14:14.460
返回给他

14:14.460 --> 14:15.460
然后宣展出来

14:15.460 --> 14:16.460
是不是空速组一开始

14:16.460 --> 14:17.460
对吧

14:17.460 --> 14:19.460
宣展出来是一个空速组

14:19.460 --> 14:20.460
我们这里打印出来

14:20.460 --> 14:23.460
第一次宣展

14:23.460 --> 14:24.460
宣展了

14:24.460 --> 14:25.460
这个数组

14:25.460 --> 14:26.460
把数据的打到

14:26.460 --> 14:27.460
打印出来

14:27.460 --> 14:28.460
保存

14:28.460 --> 14:29.460
你看一下

14:29.460 --> 14:30.460
它肯定是宣展了两次

14:30.460 --> 14:31.460
肯定是宣展了两次

14:31.460 --> 14:32.460
你看一下

14:32.460 --> 14:34.460
第一次宣展是不是空速组

14:34.460 --> 14:35.460
对吧

14:35.460 --> 14:36.460
第一次宣展完成之后

14:36.460 --> 14:38.460
由于这里边是不是注册了一个

14:38.460 --> 14:40.460
副作用的操作

14:40.460 --> 14:41.460
副作用的操作

14:41.460 --> 14:42.460
是不是宣展完成之后

14:42.460 --> 14:43.460
会运行

14:43.460 --> 14:44.460
对吧

14:44.460 --> 14:45.460
其实rex

14:45.460 --> 14:46.460
它并不知道

14:46.460 --> 14:47.460
rex其实

14:47.460 --> 14:48.460
它没有那么智能

14:48.460 --> 14:49.460
它并不知道

14:49.460 --> 14:50.460
这里用了什么自定应付可

14:50.460 --> 14:52.460
rex它完全不管这个

14:52.460 --> 14:53.460
rex这个理念里面

14:53.460 --> 14:55.460
它其实就是rex

14:55.460 --> 14:56.460
原代码里面

14:56.460 --> 14:58.460
它根本不知道有什么自定应付可

14:58.460 --> 14:59.460
它只知道你这里雕像个函数

14:59.460 --> 15:01.460
它就运行这个函数就完了

15:01.460 --> 15:02.460
这个函数里面的功能

15:02.460 --> 15:03.460
它该怎么运行就怎么运行

15:03.460 --> 15:04.460
那么这个函数里面

15:04.460 --> 15:06.460
是不是注册了一个副作用

15:06.460 --> 15:07.460
对吧

15:07.460 --> 15:08.460
注册了一个副作用

15:08.460 --> 15:09.460
所以说这个自定应付可

15:09.460 --> 15:11.460
是我们自己教的

15:11.460 --> 15:12.460
注册了一个副作用

15:12.460 --> 15:13.460
那么这个副作用等于

15:13.460 --> 15:14.460
第一次宣展完成之后

15:14.460 --> 15:15.460
是不是要拿选择数据

15:15.460 --> 15:16.460
等它拿完了之后

15:16.460 --> 15:17.460
是不是要设置状态

15:20.460 --> 15:21.460
第二次宣展了

15:21.460 --> 15:22.460
我自己写错了

15:23.460 --> 15:24.460
那么是不是要重新宣展

15:24.460 --> 15:26.460
一重新宣展的话

15:26.460 --> 15:27.460
是不是又要重新运行这个函数

15:27.460 --> 15:29.460
又要运行这句话

15:29.460 --> 15:30.460
而这句话里面干吗

15:30.460 --> 15:32.460
是不是又来获取之前的数据

15:32.460 --> 15:34.460
之前的数据是不是已经复制了

15:34.460 --> 15:36.460
第一次宣展完成之后

15:36.460 --> 15:37.460
就已经复制了

15:37.460 --> 15:38.460
复完之过后

15:38.460 --> 15:39.460
由于这个副作用函数

15:39.460 --> 15:40.460
它的依赖下没有发生变化

15:40.460 --> 15:42.460
所以这句话就没有运行了

15:42.460 --> 15:43.460
于是就返回了

15:43.460 --> 15:45.460
这个复制完成之后的取成数据

15:45.460 --> 15:46.460
那么拿到全程数据过后

15:46.460 --> 15:47.460
再进行宣展

15:47.460 --> 15:48.460
就这么简单

15:48.460 --> 15:52.460
其实当我们使用自定义户口的时候

15:52.460 --> 15:53.460
不要想那么多

15:53.460 --> 15:54.460
你想那么多

15:54.460 --> 15:56.460
反而脑袋里面一团江湖

15:56.460 --> 15:57.460
不要去想那么多

15:57.460 --> 15:59.460
就是说我们这个函数

15:59.460 --> 16:01.460
已经把这件事情搞定了

16:01.460 --> 16:02.460
这样我们把注射打好

16:02.460 --> 16:04.460
测试一下没有问题

16:04.460 --> 16:06.460
我们后面就大胆地用就行了

16:06.460 --> 16:08.460
只要使用这个

16:08.460 --> 16:10.460
只要使用这个就是那个函数

16:10.460 --> 16:11.460
它就能得到全程数据

16:11.460 --> 16:13.460
你管它这么弄的

16:13.460 --> 16:15.460
它那些东西一定处理好

16:15.460 --> 16:16.460
而现在一直到它

16:16.460 --> 16:17.460
它是有注射的

16:17.460 --> 16:18.460
看没

16:18.460 --> 16:20.460
当时晚上后获得了写成数据

16:20.460 --> 16:21.460
对吧

16:21.460 --> 16:22.460
它有注射

16:22.460 --> 16:23.460
它有功能就行了

16:23.460 --> 16:24.460
你就直接用就行了

16:24.460 --> 16:26.460
你管它是怎么写成的

16:26.460 --> 16:27.460
你看这个代码

16:27.460 --> 16:28.460
是不是极其简洁到可怕

16:28.460 --> 16:29.460
对不对

16:29.460 --> 16:30.460
就跟一个普通函数

16:30.460 --> 16:33.460
已经无限接近一个普通函数了

16:33.460 --> 16:35.460
你看这个代码多简洁

16:35.460 --> 16:37.460
如果你是一个内组件的话

16:37.460 --> 16:39.460
你想象这个道理

16:39.460 --> 16:40.460
如果你是这个内组件

16:40.460 --> 16:42.460
还能这样子玩吗

16:42.460 --> 16:43.460
是玩不了了

16:43.460 --> 16:44.460
这个事情

16:44.460 --> 16:45.460
因为如果你是一个内组件的话

16:45.460 --> 16:49.460
你就必须要写

16:49.460 --> 16:53.460
你不能把这个生命周期函数给我抽象出去吧

16:53.460 --> 16:55.460
我们这里说一下这个问题

16:55.460 --> 16:56.460
就是说

16:56.460 --> 16:57.460
如果你是一个内组件

16:57.460 --> 16:59.460
你要怎么来玩这个事情

16:59.460 --> 17:01.460
如果你要抽象出去的话

17:01.460 --> 17:03.460
你要把这个东西抽象出去

17:03.460 --> 17:05.460
就是获取第一次加载完成

17:05.460 --> 17:06.460
获取学生数据

17:06.460 --> 17:07.460
你要抽象出去的话

17:07.460 --> 17:08.460
你该怎么来玩

17:08.460 --> 17:11.460
你好像普通的方式肯定玩不了

17:11.460 --> 17:12.460
咱们来看一下吧

17:12.460 --> 17:14.460
顺便复习一下以前的知识

17:14.460 --> 17:17.460
当我们知道内组件的缺陷之后

17:17.460 --> 17:18.460
你就知道了

17:18.460 --> 17:20.460
为什么它的用心良苦

17:20.460 --> 17:22.460
为什么要搞出这个东西出来

17:22.460 --> 17:24.460
比方说我们有三个组件

17:24.460 --> 17:26.460
我现在说内组件

17:26.460 --> 17:28.460
内组件1

17:28.460 --> 17:31.460
那么内组件2

17:31.460 --> 17:34.460
内组件3都需要学生数据

17:34.460 --> 17:35.460
都需要做这件事情

17:35.460 --> 17:36.460
那么怎么办呢

17:36.460 --> 17:40.460
我们只能说抽象一个函数出来

17:40.460 --> 17:42.460
抽象一个函数

17:42.460 --> 17:45.460
这个函数就是在这里的函数

17:45.460 --> 17:46.460
就service

17:46.460 --> 17:48.460
get all students

17:48.460 --> 17:49.460
就这个函数

17:49.460 --> 17:50.460
抽象这么一个函数出来

17:50.460 --> 17:53.460
get all students

17:53.460 --> 17:55.460
然后在内组件1里边

17:55.460 --> 17:57.460
是不是要注册一个生命周期函数

17:57.460 --> 18:01.460
component did mount这个函数

18:01.460 --> 18:03.460
然后在这个函数里边

18:03.460 --> 18:04.460
去干嘛呢

18:04.460 --> 18:06.460
是不是去调用

18:06.460 --> 18:10.460
调用get all students

18:10.460 --> 18:11.460
对不对

18:11.460 --> 18:12.460
是不是要调用这个

18:12.460 --> 18:14.460
那么内组件2里面

18:14.460 --> 18:15.460
是不是要做同样的事情

18:15.460 --> 18:16.460
对不对

18:16.460 --> 18:17.460
内组件2 内组件3

18:17.460 --> 18:18.460
是不是要做同样的事情

18:18.460 --> 18:20.460
是不是非常麻烦

18:20.460 --> 18:22.460
它非常麻烦

18:22.460 --> 18:23.460
你别看上去

18:23.460 --> 18:25.460
看上去好像说没问题

18:25.460 --> 18:32.740
不要看上去说

18:32.740 --> 18:34.740
好像是没有什么问题

18:34.740 --> 18:36.740
你认为你这里

18:36.740 --> 18:38.740
无非就是雕用一下吧

18:38.740 --> 18:39.740
写个生命周期还是雕用一下吧

18:39.740 --> 18:41.740
那么你想一想

18:41.740 --> 18:45.740
这个生命周期就是在加载完成之后

18:45.740 --> 18:47.740
获取学生数据这个功能点

18:47.740 --> 18:49.740
我现在做的不是说

18:49.740 --> 18:50.740
获取学生数据

18:50.740 --> 18:53.740
我是要在第一次加载完成之后

18:53.740 --> 18:57.740
获取学生数据并且设置状态

18:57.740 --> 18:59.740
我现在要做什么事情

18:59.740 --> 19:00.740
我现在出的事情不是说

19:00.740 --> 19:02.740
简单的获取学生数据

19:02.740 --> 19:03.740
我要抽象的

19:03.740 --> 19:04.740
我要分离的

19:04.740 --> 19:06.740
不是简单的获取学生数据

19:06.740 --> 19:08.740
我想分离的是什么呢

19:08.740 --> 19:09.740
想分离的是

19:09.740 --> 19:13.740
当第一次加载完成之后

19:14.740 --> 19:16.740
获取学生数据

19:16.740 --> 19:19.740
然后设置状态

19:19.740 --> 19:21.740
我想抽离这么一部分功能

19:21.740 --> 19:23.740
但是以前能抽离吗

19:23.740 --> 19:24.740
是不是不能抽离

19:24.740 --> 19:26.740
因为这个生命周期函数里不能抽

19:26.740 --> 19:27.740
放到别的内里边

19:27.740 --> 19:28.740
放到别的函数里边

19:28.740 --> 19:29.740
怎么放啊

19:29.740 --> 19:30.740
你内足间就放不了

19:30.740 --> 19:32.740
就没法抽离出去

19:32.740 --> 19:33.740
但是以前

19:33.740 --> 19:36.740
确实有这么一个功能

19:36.740 --> 19:38.740
有什么功能呢

19:38.740 --> 19:39.740
可以

19:39.740 --> 19:41.740
以前其实也可以抽离的

19:41.740 --> 19:43.740
怎么来抽离呢

19:43.740 --> 19:45.740
我这里再给大家讲戏一点

19:45.740 --> 19:47.740
以前的抽离方式使用

19:47.740 --> 19:48.740
Render Props

19:48.740 --> 19:50.740
或者是用高接组件

19:50.740 --> 19:52.740
怎么抽离

19:52.740 --> 19:54.740
比方说我们这里

19:54.740 --> 19:57.740
写一个

19:57.740 --> 19:59.740
写个什么呢

19:59.740 --> 20:01.740
高接组件

20:01.740 --> 20:03.740
这个高接组件

20:03.740 --> 20:05.740
这个高接组件里边

20:05.740 --> 20:07.740
使用ComponentDMount

20:07.740 --> 20:08.740
然后在这里边

20:08.740 --> 20:10.740
调用这个GetAllStudents

20:10.740 --> 20:12.740
然后再设置

20:12.740 --> 20:14.740
设置高接组件的

20:14.740 --> 20:16.740
状态

20:16.740 --> 20:17.740
可不可以

20:17.740 --> 20:18.740
当然可以

20:18.740 --> 20:19.740
高接组件里边

20:19.740 --> 20:21.740
我们写个高接组件

20:21.740 --> 20:23.740
高接组件里面要返回的组件

20:23.740 --> 20:25.740
我给大家写一下

20:25.740 --> 20:27.740
体会这么一个意识

20:27.740 --> 20:31.310
我们看一下

20:31.310 --> 20:32.310
比方说以后

20:32.310 --> 20:33.310
以前要这样做的话

20:33.310 --> 20:34.310
我们得怎么写呢

20:34.310 --> 20:36.310
我们得写这么一个高接组件

20:36.310 --> 20:38.310
放个心

20:38.310 --> 20:40.310
就是

20:40.310 --> 20:42.310
高接组件是由Wiz开头的

20:42.310 --> 20:44.310
Wiz AllStudents

20:44.310 --> 20:46.310
你给我一个组件

20:46.310 --> 20:48.310
你给我一个组件

20:48.310 --> 20:50.310
我给你返回一个

20:50.310 --> 20:52.310
包装的组件

20:52.310 --> 20:54.310
AllStudents

20:54.310 --> 20:56.310
Wiper

20:56.310 --> 20:58.310
返回这么一个包装的组件

20:58.310 --> 21:00.310
Class

21:00.310 --> 21:02.310
Extends

21:02.310 --> 21:05.820
React

21:05.820 --> 21:07.820
Component

21:07.820 --> 21:09.820
返回这么一个高接组件

21:09.820 --> 21:11.820
然后呢

21:11.820 --> 21:12.820
这个组件里边

21:12.820 --> 21:13.820
是不是可以写什么东西

21:13.820 --> 21:15.820
来说ComponentDMount

21:15.820 --> 21:17.820
在这个组件夹在完成之后

21:17.820 --> 21:18.820
我把这个代码

21:18.820 --> 21:25.070
稍微复制一下

21:25.070 --> 21:27.070
那么这个组件夹在完成之后

21:27.070 --> 21:28.070
干嘛呢

21:28.070 --> 21:29.070
我是不是就可以

21:29.070 --> 21:31.070
获取学生数据了

21:31.070 --> 21:33.070
这个组件还有一个状态

21:33.070 --> 21:34.070
State

21:34.070 --> 21:36.070
State

21:36.070 --> 21:38.070
这里面

21:38.070 --> 21:40.070
是不是可以获取学生数据了

21:40.070 --> 21:42.070
学生数据来自于哪呢

21:42.070 --> 21:43.070
State

21:43.070 --> 21:45.070
它一开始空数组

21:45.070 --> 21:46.070
然后呢我们这里呢

21:46.070 --> 21:48.070
去获取学生数据

21:48.070 --> 21:49.070
Stills

21:49.070 --> 21:52.070
就是getAllAwait

21:52.070 --> 21:54.070
getAllStudents

21:54.070 --> 21:56.070
拿到所有的学生数据

21:56.070 --> 21:57.070
然后呢把这个数组

21:57.070 --> 21:58.070
是不是设置到状态里边

21:58.070 --> 21:59.070
改变它的状态

21:59.070 --> 22:00.070
它重新渲染

22:00.070 --> 22:02.070
ThisSetState

22:02.070 --> 22:03.070
然后呢

22:03.070 --> 22:04.070
Stills

22:04.070 --> 22:05.070
对吧

22:05.070 --> 22:07.070
让它重新渲染

22:07.070 --> 22:08.070
没问题吧

22:08.070 --> 22:10.070
这是我们以前的做法

22:10.070 --> 22:11.070
然后Render的时候呢

22:11.070 --> 22:12.070
返回啥呢

22:12.070 --> 22:14.070
Render的时候返回的是

22:14.070 --> 22:16.070
我们返回的是

22:16.070 --> 22:18.070
这个Comp组件

22:18.070 --> 22:20.070
保重一下这个Comp组件

22:20.070 --> 22:21.070
返回这个Comp组件

22:21.070 --> 22:22.070
这个Comp组件呢

22:22.070 --> 22:24.070
我们一次把我们的属性给它

22:24.070 --> 22:26.070
就是如果你传给我这个组件的属性

22:26.070 --> 22:28.070
全部给力

22:28.070 --> 22:29.070
然后呢

22:29.070 --> 22:30.070
我在额外给力一个属性

22:30.070 --> 22:31.070
什么属性呢

22:31.070 --> 22:33.070
就是学生

22:33.070 --> 22:35.070
Stills嘛

22:35.070 --> 22:37.070
对的

22:37.070 --> 22:38.070
Stills

22:38.070 --> 22:39.070
然后呢

22:39.070 --> 22:41.070
我们把这个States

22:41.070 --> 22:42.070
Stills传给力

22:42.070 --> 22:43.070
这是高解组件的写法

22:43.070 --> 22:44.070
好好看一下啊

22:44.070 --> 22:46.070
这是咱们以前的做法

22:46.070 --> 22:47.070
没问题吧

22:47.070 --> 22:48.070
很简单的代码啊

22:48.070 --> 22:49.070
你给我一个组件

22:49.070 --> 22:50.070
这个组件呢

22:50.070 --> 22:51.070
它不是说要

22:51.070 --> 22:52.070
需要学生数据吗

22:52.070 --> 22:53.070
它自己又难得获取

22:53.070 --> 22:54.070
我帮你来获取

22:54.070 --> 22:55.070
获取完了过后呢

22:55.070 --> 22:57.070
我把通过这个属性给你传过来

22:57.070 --> 22:58.070
对吧

22:58.070 --> 22:59.070
就设置好了这么一个高解组件

22:59.070 --> 23:00.070
然后呢

23:00.070 --> 23:01.070
我们后边呢

23:01.070 --> 23:02.070
写这个函数

23:02.070 --> 23:03.070
比方说

23:03.070 --> 23:04.070
有个组件

23:04.070 --> 23:05.070
它需要这个东西

23:05.070 --> 23:06.070
比方说啊

23:06.070 --> 23:07.070
有这么一个组件

23:07.070 --> 23:08.070
需要这个学生数据

23:08.070 --> 23:10.070
那么这个Test组件呢

23:10.070 --> 23:11.070
我们就假设

23:11.070 --> 23:12.070
它有一个Propos

23:12.070 --> 23:13.070
Propos里面

23:13.070 --> 23:15.070
就已经带了学生数据了

23:15.070 --> 23:17.070
就已经带了这个学生数据了

23:17.070 --> 23:18.070
好

23:18.070 --> 23:19.070
于是Propos

23:19.070 --> 23:20.070
这个组件就这么写

23:20.070 --> 23:21.070
就完了

23:21.070 --> 23:22.070
好

23:22.070 --> 23:23.070
最后呢

23:23.070 --> 23:24.070
我们用包装组件

23:24.070 --> 23:25.070
包装一下

23:25.070 --> 23:27.070
with all students test

23:27.070 --> 23:28.070
好

23:28.070 --> 23:29.070
然后呢

23:29.070 --> 23:30.070
这里边

23:30.070 --> 23:32.070
得到一个新的组件

23:32.070 --> 23:35.070
test students

23:36.070 --> 23:38.070
得到这个新的组件

23:38.070 --> 23:39.070
OK

23:39.070 --> 23:40.070
我们把学生那个新的组件

23:40.070 --> 23:42.070
这样子也能渲染出来

23:42.070 --> 23:43.070
你好好看一下代码

23:43.070 --> 23:44.070
代码

23:44.070 --> 23:45.070
不要前面学习的

23:45.070 --> 23:46.070
后面有丢了

23:46.070 --> 23:47.070
千万不要这样子

23:47.070 --> 23:49.070
现在就不用到这个了

23:49.070 --> 23:50.070
好

23:50.070 --> 23:51.070
你看一下这个代码

23:51.070 --> 23:52.070
保存咱们来看一下

23:52.070 --> 23:53.070
哎

23:53.070 --> 23:54.070
儿子

23:54.070 --> 23:56.070
有Temps import services

23:56.070 --> 23:58.070
students with outside

23:58.070 --> 23:59.070
哦

23:59.070 --> 24:00.070
这里

24:00.070 --> 24:01.070
路径写错了

24:01.070 --> 24:02.070
花了文件夹了

24:02.070 --> 24:04.070
路径写错了

24:04.070 --> 24:05.070
好

24:05.070 --> 24:06.070
保存啊

24:06.070 --> 24:07.070
这也可以

24:07.070 --> 24:08.070
对吧

24:08.070 --> 24:09.070
也可以

24:09.070 --> 24:10.070
但是呢

24:10.070 --> 24:11.070
这样子呢

24:11.070 --> 24:13.070
要跟我们刚才的那种写法比起来

24:13.070 --> 24:14.070
那就简直是

24:14.070 --> 24:16.070
差的不是异性慢点

24:16.070 --> 24:17.070
之前的那种写法

24:17.070 --> 24:19.070
是极其容易理解的

24:19.070 --> 24:20.070
我只不过

24:20.070 --> 24:21.070
封装了一个函数而已

24:21.070 --> 24:22.070
对吧

24:22.070 --> 24:23.070
你看你这里

24:23.070 --> 24:24.070
给我绕了多少个圈

24:24.070 --> 24:25.070
啊

24:25.070 --> 24:27.070
你给我传一个组件进来

24:27.070 --> 24:29.070
我返回又返回一个组件

24:29.070 --> 24:30.070
这个组件尤其做一些事情

24:30.070 --> 24:32.070
然后又把自己的

24:32.070 --> 24:33.070
过来传过去

24:33.070 --> 24:34.070
脑袋都传云了

24:34.070 --> 24:35.070
是不是高阶组件

24:35.070 --> 24:36.070
特别复杂

24:36.070 --> 24:37.070
你们刚才之前学过了

24:37.070 --> 24:38.070
高阶组件的

24:38.070 --> 24:39.070
应该感觉到高阶组件

24:39.070 --> 24:40.070
特别复杂

24:40.070 --> 24:41.070
那么现在

24:41.070 --> 24:42.070
现在这个东西

24:42.070 --> 24:44.070
特别特别简洁

24:44.070 --> 24:45.070
无非就抽离出一个

24:45.070 --> 24:46.070
生生函数吧

24:46.070 --> 24:47.070
你们学了这么久的解释

24:47.070 --> 24:49.070
难道还不会封装函数吗

24:49.070 --> 24:51.070
无非就把功能写到函数里面

24:51.070 --> 24:52.070
就完了吗

24:52.070 --> 24:53.070
对不对

24:53.070 --> 24:54.070
你看一下

24:54.070 --> 24:56.070
而且你高阶组件里边

24:56.070 --> 24:57.070
还有个重大的缺陷就是

24:57.070 --> 24:58.070
它会导致我们的

24:58.070 --> 24:59.070
组件层次会变得

24:59.070 --> 25:00.070
越来越深

25:00.070 --> 25:02.070
本来我们都很简洁的

25:02.070 --> 25:03.070
一个APP组件下面

25:03.070 --> 25:04.070
有一个什么

25:04.070 --> 25:06.070
有个特色组件对吧

25:06.070 --> 25:07.070
因为我要增强猛弱

25:07.070 --> 25:08.070
还有个淘了一个组件

25:08.070 --> 25:09.070
是不是又导致了

25:09.070 --> 25:10.070
什么

25:10.070 --> 25:12.070
Rave转发

25:12.070 --> 25:13.070
乱七八糟的问题

25:13.070 --> 25:14.070
是不是又来了

25:14.070 --> 25:15.070
对不对

25:15.070 --> 25:18.070
就导致了很多问题

25:18.070 --> 25:19.070
那么现在有了

25:19.070 --> 25:20.070
Hook之后

25:20.070 --> 25:22.070
变得无比的简洁

25:22.070 --> 25:25.070
就是一个普通的函数调用

25:25.070 --> 25:28.070
而且不仅如此

25:28.070 --> 25:29.070
我们可以很

25:29.070 --> 25:31.070
为什么说Hook的出现

25:31.070 --> 25:32.070
它是为了

25:32.070 --> 25:34.070
它是为了搞定那个

25:34.070 --> 25:36.070
横切关注点的呢

25:36.070 --> 25:37.070
因为我们现在

25:37.070 --> 25:40.070
无论是副作用也好

25:40.070 --> 25:41.070
还是什么状态也好

25:41.070 --> 25:43.070
是不是全部可以拆开

25:43.070 --> 25:44.070
拆开对吧

25:44.070 --> 25:45.070
可以拆得非常细

25:45.070 --> 25:47.070
比方说

25:47.070 --> 25:49.070
比方说

25:49.070 --> 25:51.070
组件1

25:51.070 --> 25:54.070
它要用到五种副作用

25:54.070 --> 25:56.070
副作用操作

25:56.070 --> 25:58.070
副作用操作

25:59.070 --> 26:02.070
其中三种

26:02.070 --> 26:04.070
三种副作用操作

26:04.070 --> 26:07.070
是通用的

26:07.070 --> 26:08.070
是在其他组件里面

26:08.070 --> 26:09.070
也可能会用到

26:09.070 --> 26:10.070
那么我们只需要去

26:10.070 --> 26:13.070
拆分这三种副作用操作就行了

26:13.070 --> 26:14.070
对不对

26:14.070 --> 26:16.070
没问题吧

26:16.070 --> 26:17.070
是这个意思吧

26:17.070 --> 26:18.070
其中三种副作用的

26:18.070 --> 26:19.070
是操作

26:19.070 --> 26:21.070
是通用的

26:21.070 --> 26:22.070
那么我们只需要

26:22.070 --> 26:23.070
拆分成三个函数

26:23.070 --> 26:24.070
对吧

26:24.070 --> 26:25.070
一个函数搞定一个副作用

26:25.070 --> 26:27.070
一个函数搞定一个副作用

26:27.070 --> 26:28.070
对吧

26:28.070 --> 26:30.070
就完了

26:30.070 --> 26:31.070
那么如果说

26:31.070 --> 26:33.070
以前的内组件里面怎么办

26:33.070 --> 26:35.070
你是不是要封装三个高隶函数

26:35.070 --> 26:36.070
那个组件的层次

26:36.070 --> 26:37.070
会不会越套越深

26:37.070 --> 26:38.070
咱们之前讲过

26:38.070 --> 26:39.070
有些的时候

26:39.070 --> 26:41.070
我们为了横切关注点

26:41.070 --> 26:42.070
一个横吹

26:42.070 --> 26:43.070
不要说日式记录

26:43.070 --> 26:45.070
是一个关注点对吧

26:45.070 --> 26:46.070
还有什么呢

26:46.070 --> 26:47.070
当时我们举了什么例子

26:47.070 --> 26:48.070
总之还有一些

26:48.070 --> 26:49.070
其他的就是功能点

26:49.070 --> 26:50.070
我们都可能会

26:50.070 --> 26:52.070
把它抽象成一个高隶组件

26:52.070 --> 26:53.070
那么这样子

26:53.070 --> 26:54.070
一层套一层

26:54.070 --> 26:55.070
我先把它封装一次

26:55.070 --> 26:56.070
用这个高隶组件封装一次

26:56.070 --> 26:57.070
再用另外一个高隶组件

26:57.070 --> 26:58.070
给它增强一个功能

26:58.070 --> 26:59.070
那是不是这个层次

26:59.070 --> 27:00.070
会越套越深

27:00.070 --> 27:01.070
越套越深

27:01.070 --> 27:02.070
对吧

27:02.070 --> 27:03.070
到时我们组件结构

27:03.070 --> 27:04.070
就很难理解了

27:04.070 --> 27:05.070
但是你看一下

27:05.070 --> 27:07.070
我们如果使用这个

27:07.070 --> 27:08.070
扶子

27:08.070 --> 27:09.070
张开过来

27:09.070 --> 27:10.070
如果使用这个

27:10.070 --> 27:12.070
非常简洁的Hook

27:12.070 --> 27:14.070
你看一下组件结构

27:14.070 --> 27:16.070
非常非常的纯净

27:16.070 --> 27:17.070
组件结构

27:17.070 --> 27:18.070
就这么简单

27:18.070 --> 27:19.070
而且它既完成了

27:19.070 --> 27:20.070
功能的裁分

27:20.070 --> 27:21.070
而且这种裁分

27:21.070 --> 27:23.070
要比内组件好太多了

27:23.070 --> 27:25.070
因为内组件里面

27:25.070 --> 27:27.070
状态是揉在一起的

27:27.070 --> 27:28.070
但这里的状态

27:28.070 --> 27:29.070
全部是分级的

27:29.070 --> 27:30.070
比方说我们这里

27:30.070 --> 27:31.070
比方说这个组件

27:31.070 --> 27:32.070
要做很多事情

27:32.070 --> 27:33.070
它其中一件事情

27:33.070 --> 27:34.070
是要用到这个东西

27:34.070 --> 27:35.070
ok

27:35.070 --> 27:36.070
那这一件事

27:36.070 --> 27:37.070
要用到这个东西

27:37.070 --> 27:38.070
我就去调用

27:38.070 --> 27:39.070
那如果还要用到

27:39.070 --> 27:40.070
别的其他通用的事情

27:40.070 --> 27:41.070
我们去调用

27:41.070 --> 27:43.070
另外的制定Hook

27:43.070 --> 27:44.070
对吧

27:44.070 --> 27:45.070
它就裁分了

27:45.070 --> 27:46.070
非常非常细

27:46.070 --> 27:48.070
非常非常细

27:48.070 --> 27:49.070
比方说

27:49.070 --> 27:51.070
再举个例子

27:51.070 --> 27:52.070
比方说我要分页

27:52.070 --> 27:54.070
或许学生数据

27:54.070 --> 27:57.070
再写个制定Hook

27:57.070 --> 28:01.900
那么这里的UsePageStudents

28:01.900 --> 28:03.900
又来一个制定Hook

28:03.900 --> 28:05.900
我们把这个代码复制一下

28:05.900 --> 28:06.900
分页或许学生数据

28:06.900 --> 28:07.900
该怎么选的

28:07.900 --> 28:09.900
是不是要传个页码进来

28:09.900 --> 28:10.900
你告诉我一个页码

28:10.900 --> 28:11.900
还有什么一个页容量

28:11.900 --> 28:12.900
对吧

28:12.900 --> 28:13.900
你告诉我一个页码

28:13.900 --> 28:14.900
和页容量

28:14.900 --> 28:15.900
我管你这个页码

28:15.900 --> 28:16.900
页容量哪来的

28:16.900 --> 28:17.900
关我屁事

28:17.900 --> 28:18.900
你给我就行了

28:18.900 --> 28:19.900
给我我干嘛

28:19.900 --> 28:20.900
你给我我干嘛

28:20.900 --> 28:21.900
你给我我干嘛

28:21.900 --> 28:22.900
你给我我干嘛

28:22.900 --> 28:24.900
你给我我干嘛

28:24.900 --> 28:25.900
给我我干嘛

28:25.900 --> 28:27.900
我是不是要有个状态

28:27.900 --> 28:28.900
对不对

28:28.900 --> 28:29.900
有个状态

28:29.900 --> 28:30.900
一开始有个状态

28:30.900 --> 28:32.900
然后我是不是要执行副作用

28:32.900 --> 28:33.900
副作用干嘛

28:33.900 --> 28:34.900
是不是另外一个函数了

28:34.900 --> 28:36.900
getStudents函数

28:37.900 --> 28:39.900
getStudents函数

28:39.900 --> 28:41.900
那么这个函数里边

28:41.900 --> 28:42.900
调那个函数

28:42.900 --> 28:44.900
是不是要传页码进去

28:44.900 --> 28:45.900
要传什么

28:45.900 --> 28:46.900
还要传Limiter进去

28:46.900 --> 28:47.900
对吧

28:47.900 --> 28:48.900
它说马上就提示你了

28:48.900 --> 28:49.900
你这里边有一奈像

28:49.900 --> 28:50.900
一奈什么呢

28:50.900 --> 28:52.900
一奈Page和Limiter

28:52.900 --> 28:53.900
只要这个没变

28:53.900 --> 28:55.900
OK 那个学习数据是稳定的

28:55.900 --> 28:56.900
只要这个东西变了

28:56.900 --> 28:58.900
我一定会重新调一个副作用函数

28:58.900 --> 29:00.900
我们把这一块功能抽离出去就完事了

29:00.900 --> 29:01.900
对吧

29:01.900 --> 29:02.900
好 那么这里呢

29:02.900 --> 29:03.900
返回来是什么呢

29:03.900 --> 29:05.900
返回来是一个

29:06.900 --> 29:07.900
一个这个

29:07.900 --> 29:08.900
一个这个

29:09.900 --> 29:10.900
一个就是返回值

29:10.900 --> 29:12.900
这个返回值里边

29:12.900 --> 29:14.900
我们这里换个名字吧

29:14.900 --> 29:16.900
因为这里返回来有可能有种数

29:16.900 --> 29:17.900
还有学生数组对吧

29:17.900 --> 29:18.900
返回来两个东西

29:18.900 --> 29:19.900
我把这两个东西都给你

29:19.900 --> 29:20.900
我管它那么多

29:20.900 --> 29:22.900
我把这两个东西都给你

29:23.900 --> 29:25.900
这也是Risp

29:26.900 --> 29:28.900
这就是那个响应结果

29:29.900 --> 29:31.900
这响应结果一开始是一个空对象

29:31.900 --> 29:33.900
一开始是个空对象

29:33.900 --> 29:34.900
好 那么这里呢

29:34.900 --> 29:36.900
当我们响应结果完成之后

29:36.900 --> 29:37.900
我把这个响应结果给你

29:37.900 --> 29:38.900
对吧

29:38.900 --> 29:40.900
所以说你们一定要去练习

29:40.900 --> 29:41.900
我们之前讲过一些练习的时候

29:41.900 --> 29:43.900
你们一定要跟着做

29:43.900 --> 29:45.900
一定要一定要跟着做

29:45.900 --> 29:47.900
否则的话

29:48.900 --> 29:49.900
否则的话你

29:49.900 --> 29:51.900
你可能连这些API都搞不清楚

29:51.900 --> 29:52.900
都是模糊的

29:53.900 --> 29:54.900
而且这些API呢

29:54.900 --> 29:56.900
虽然跟我们支持没有什么关系

29:56.900 --> 29:58.900
但是会影响你听课

29:59.900 --> 30:01.900
你完全不知道这个API是啥

30:01.900 --> 30:02.900
它返回来的结果不是这样子吗

30:02.900 --> 30:04.900
返回来的结果是啥

30:05.900 --> 30:06.900
所以那个Count

30:06.900 --> 30:07.900
对吧 我都记得了

30:07.900 --> 30:08.900
为什么我记得

30:08.900 --> 30:09.900
我不是我记性好

30:09.900 --> 30:11.900
虽然我写了的 我自然记得

30:11.900 --> 30:12.900
这是种数

30:12.900 --> 30:13.900
对吧

30:13.900 --> 30:14.900
数据种数

30:14.900 --> 30:15.900
还有这么Fant

30:15.900 --> 30:16.900
BadPage

30:16.900 --> 30:17.900
对吧 这是个数组

30:17.900 --> 30:19.900
这是它返回来的东西

30:20.900 --> 30:21.900
OK 那么这里呢

30:21.900 --> 30:23.900
我就写好这个自定以后可了

30:23.900 --> 30:25.900
那么这个就不是手势加载

30:25.900 --> 30:27.900
那么当

30:28.900 --> 30:29.900
就是根据业码

30:30.900 --> 30:33.900
根据业码和业容量

30:33.900 --> 30:35.900
获取学生数据

30:35.900 --> 30:37.900
获取学生数据

30:37.900 --> 30:38.900
得到

30:39.900 --> 30:41.900
得到一个响应结果

30:42.900 --> 30:43.900
并且

30:43.900 --> 30:48.900
当业码和业容量变化时

30:48.900 --> 30:52.900
将重新获取学生数据

30:53.900 --> 30:54.900
就这么成绩

30:54.900 --> 30:56.900
甚至还可以给默认值

30:56.900 --> 30:57.900
1

30:57.900 --> 30:58.900
10

30:58.900 --> 30:59.900
可以给默认值

30:59.900 --> 31:00.900
你爱传不传

31:01.900 --> 31:02.900
保存 你看一下

31:02.900 --> 31:04.900
那么比方说到这边

31:04.900 --> 31:05.900
这边

31:05.900 --> 31:07.900
就还是个特色为例吧

31:07.900 --> 31:09.900
那么我们在这里来换一个

31:09.900 --> 31:10.900
叫做

31:11.900 --> 31:14.900
UsePageStudents

31:14.900 --> 31:17.900
UsePageStudents

31:18.900 --> 31:20.900
就掉了还是就完了

31:20.900 --> 31:21.900
就掉了

31:21.900 --> 31:22.900
爱传不传

31:22.900 --> 31:23.900
对不对

31:23.900 --> 31:24.900
爱传不传

31:24.900 --> 31:25.900
那么这里呢

31:25.900 --> 31:26.900
返回一个响应结果对吧

31:26.900 --> 31:28.900
比方说1

31:28.900 --> 31:29.900
10

31:29.900 --> 31:30.900
响应结果

31:31.900 --> 31:32.900
我们这里

31:32.900 --> 31:33.900
输

31:36.900 --> 31:38.900
得到响应结果里面

31:38.900 --> 31:40.900
Fant byPage对吧

31:40.900 --> 31:41.900
Fant byPage

31:41.900 --> 31:43.900
那么得到这个输出

31:43.900 --> 31:45.900
好 这里上面再输出一个

31:45.900 --> 31:46.900
再输出一个

31:53.470 --> 31:54.470
和起来

31:54.470 --> 31:56.470
上面再输出一个种数

31:56.470 --> 32:00.230
数据 种数

32:00.230 --> 32:02.230
种数是多少呢

32:02.230 --> 32:04.230
种数是

32:04.230 --> 32:06.230
RisperCult

32:06.230 --> 32:11.660
OK

32:11.660 --> 32:12.660
好 来看一下吧

32:12.660 --> 32:13.660
保存

32:17.480 --> 32:19.480
好多这个东西是NDP

32:19.480 --> 32:20.480
行吧

32:20.480 --> 32:21.480
咱们输出一下

32:21.480 --> 32:22.480
Risp

32:22.480 --> 32:25.790
在控制台里面输出一下

32:26.790 --> 32:28.790
哦

32:28.790 --> 32:30.790
一开始是没有数据的

32:30.790 --> 32:32.790
它一开始是没数据的

32:32.790 --> 32:33.790
所以说

32:33.790 --> 32:34.790
第一开始

32:34.790 --> 32:36.790
我这个代码就报错了

32:36.790 --> 32:38.790
它一开始是没有数据的

32:38.790 --> 32:39.790
是没有数据的

32:40.790 --> 32:41.790
那这样子吧

32:41.790 --> 32:42.790
一开始我

32:42.790 --> 32:44.790
以为它没有数据

32:44.790 --> 32:45.790
以为它没有数据

32:45.790 --> 32:46.790
一开始我们用

32:46.790 --> 32:48.790
就不给默认词

32:48.790 --> 32:49.790
不给默认词

32:49.790 --> 32:51.790
使用Undefend

32:51.790 --> 32:52.790
使用Undefend

32:52.790 --> 32:53.790
我们这里

32:53.790 --> 32:54.790
得到这个结果

32:54.790 --> 32:55.790
判断一下吧

32:55.790 --> 32:57.790
如果Risper有值的话

32:57.790 --> 32:59.790
如果它有值的话

32:59.790 --> 33:02.100
那么这里呢

33:02.100 --> 33:03.100
返回

33:03.100 --> 33:04.100
否则的话

33:04.100 --> 33:05.100
如果它没有值的话

33:05.100 --> 33:06.100
返回NOW

33:06.100 --> 33:07.100
就啥都不显示

33:07.100 --> 33:08.100
保存

33:09.100 --> 33:10.100
好 你看一下

33:10.100 --> 33:11.100
是不是达到第一页数据了

33:11.100 --> 33:13.100
当然我们这里是传使的

33:13.100 --> 33:15.100
当前页码和种数

33:15.100 --> 33:16.100
页容量是传使的

33:16.100 --> 33:17.100
那么这两个东西

33:17.100 --> 33:18.100
是不是又可以

33:18.100 --> 33:19.100
自己再写个Hook

33:19.100 --> 33:20.100
它管理这个东西

33:20.100 --> 33:21.100
哪来的呢

33:21.100 --> 33:22.100
跟它有什么关系呢

33:22.100 --> 33:24.100
我们可以自己写个Hook

33:24.100 --> 33:25.100
对吧

33:26.100 --> 33:27.100
比方说吧

33:27.100 --> 33:29.100
我们这里随便哪一个吧

33:29.100 --> 33:31.100
就UseState

33:31.100 --> 33:35.570
UseState

33:35.570 --> 33:37.570
那么这里呢

33:40.570 --> 33:41.570
我们使用

33:41.570 --> 33:44.900
E

33:44.900 --> 33:45.900
Page

33:45.900 --> 33:47.900
SetPage

33:47.900 --> 33:49.900
我们自己写的一个StateHook

33:49.900 --> 33:50.900
这里呢

33:50.900 --> 33:51.900
来自于Page

33:52.900 --> 33:53.900
那么下面呢

33:53.900 --> 33:54.900
我们加上一个

33:54.900 --> 33:56.900
Input文文光码

33:56.900 --> 33:57.900
Number

33:58.900 --> 33:59.900
它的Values

33:59.900 --> 34:00.900
来自于哪呢

34:00.900 --> 34:01.900
来自于Page

34:02.900 --> 34:03.900
Unchanged

34:03.900 --> 34:04.900
当改变的时候呢

34:04.900 --> 34:05.900
干嘛呢

34:06.900 --> 34:07.900
当改变的时候呢

34:07.900 --> 34:08.900
我们重新SetPage

34:09.900 --> 34:10.900
PoseInt

34:11.900 --> 34:13.900
1点Target

34:13.900 --> 34:14.900
点Value

34:17.340 --> 34:18.340
好 保存

34:18.340 --> 34:19.340
你看一下

34:20.340 --> 34:21.340
好 那么现在是第一页

34:21.340 --> 34:22.340
你看呀 点击

34:22.340 --> 34:23.340
第二页

34:23.340 --> 34:24.340
看是不是显示第二页数据了

34:24.340 --> 34:25.340
点击第三页

34:25.340 --> 34:26.340
是不是显示第三页了

34:26.340 --> 34:27.340
你看我们把这个

34:27.340 --> 34:28.340
重新获取学生数据

34:28.340 --> 34:29.340
就全部放到Hook里边了

34:29.340 --> 34:31.340
整个这个函数里边

34:31.340 --> 34:32.340
没有任何一句话

34:32.340 --> 34:34.340
跟什么获取学生数据有关系

34:34.340 --> 34:35.340
没有任何一句话

34:35.340 --> 34:36.340
全在这里面全部封装好了

34:36.340 --> 34:37.340
好好体会一下

34:37.340 --> 34:39.340
下来一定要你自己去写一下

34:39.340 --> 34:40.340
你自己不写的话

34:40.340 --> 34:41.340
你体会不到

34:41.340 --> 34:42.340
这个东西有多爽

34:42.340 --> 34:44.340
真的是你体会不到有多爽

34:44.340 --> 34:45.340
后边

34:45.340 --> 34:46.340
虽然说现在Hook呢

34:46.340 --> 34:48.340
还没有完全普及

34:48.340 --> 34:49.340
很多公司里边呢

34:49.340 --> 34:50.340
可能习惯上了

34:50.340 --> 34:51.340
因为以前用了太久了

34:51.340 --> 34:52.340
这些内总监

34:52.340 --> 34:53.340
生命中的函数也太熟悉了

34:53.340 --> 34:55.340
没有太具用了这个Hook

34:55.340 --> 34:56.340
但是呢

34:56.340 --> 34:59.340
以后我觉得他一定会大放异产

34:59.340 --> 35:01.340
在我们这个Rx开发当中

35:01.340 --> 35:03.340
我当时看到这个Hook的

35:03.340 --> 35:04.340
这个点的时候呢

35:04.340 --> 35:06.340
当时我去约组官方稳当

35:06.340 --> 35:08.340
读到他那个就是

35:08.340 --> 35:10.340
就是Stats

35:10.340 --> 35:11.340
Ustats的时候

35:11.340 --> 35:12.340
当时我就读了

35:12.340 --> 35:14.340
第一篇Ustats

35:14.340 --> 35:15.340
我惊呆了

35:15.340 --> 35:16.340
我说这个东西

35:16.340 --> 35:17.340
这个裁分太厉害了

35:17.340 --> 35:18.340
这个裁分

35:18.340 --> 35:19.340
我们可以进行更加

35:19.340 --> 35:21.340
细腻度的封装

35:21.340 --> 35:22.340
对吧

35:22.340 --> 35:23.340
以前的话

35:23.340 --> 35:24.340
在内组建里边

35:24.340 --> 35:25.340
比方说

35:25.340 --> 35:26.340
一些复杂的组建

35:26.340 --> 35:28.340
生命中的Deadmount里边

35:28.340 --> 35:29.340
第10家在完成

35:29.340 --> 35:30.340
我们可能要做很多事情

35:30.340 --> 35:31.340
举个例子吧

35:33.340 --> 35:35.340
Component

35:35.340 --> 35:36.340
Deadmount

35:36.340 --> 35:37.340
当我们在

35:38.340 --> 35:40.340
完成生命中的这个函数的时候

35:40.340 --> 35:42.340
我们可能要做很多事情

35:42.340 --> 35:43.340
比方说

35:43.340 --> 35:46.340
Rx获取数据

35:46.340 --> 35:47.340
这是副作用操作

35:47.340 --> 35:48.340
对吧

35:48.340 --> 35:49.340
还有就是设置

35:49.340 --> 35:50.340
设置

35:50.340 --> 35:51.340
设置

35:51.340 --> 35:52.340
设置

35:52.340 --> 35:53.340
设置

35:53.340 --> 35:54.340
设置

35:54.340 --> 35:55.340
设置

35:55.340 --> 35:56.340
设置

35:56.340 --> 35:57.340
设置

35:57.340 --> 35:58.340
设置

35:58.340 --> 35:59.340
设置

35:59.340 --> 36:00.340
设置

36:00.340 --> 36:01.340
设置

36:01.340 --> 36:02.340
设置

36:02.340 --> 36:03.340
设置

36:03.340 --> 36:04.340
设置

36:04.340 --> 36:05.340
设置

36:05.340 --> 36:06.340
设置

36:06.340 --> 36:07.340
设置

36:07.340 --> 36:08.340
设置

36:08.340 --> 36:09.340
设置

36:09.340 --> 36:10.340
设置

36:10.340 --> 36:11.340
设置

36:11.340 --> 36:12.340
设置

36:12.340 --> 36:13.340
设置

36:13.340 --> 36:14.340
设置

36:14.340 --> 36:15.340
设置

36:15.340 --> 36:16.340
设置

36:16.340 --> 36:17.340
设置

36:17.340 --> 36:18.340
设置

36:18.340 --> 36:19.340
设置

36:19.340 --> 36:20.340
设置

36:20.340 --> 36:21.340
设置

36:21.340 --> 36:22.340
设置

36:22.340 --> 36:23.340
把他抽离出去

36:23.340 --> 36:24.340
Rx获取数据

36:24.340 --> 36:25.340
数据是一个高階组建

36:25.340 --> 36:27.340
然后设置一些真实的动物元素

36:27.340 --> 36:28.340
是一个高階组建

36:28.340 --> 36:29.340
全部把他抽离出去

36:29.340 --> 36:30.340
抽出去过

36:30.340 --> 36:32.340
这个组建结构会变得非常复杂

36:32.340 --> 36:34.340
调用起来也非常难用

36:34.340 --> 36:35.340
因为这些数据

36:35.340 --> 36:37.340
这些事情是不相关的

36:37.340 --> 36:38.340
但是生命中的函数

36:38.340 --> 36:39.340
由于只有这一个

36:39.340 --> 36:40.340
你没办法

36:40.340 --> 36:42.340
你只能把它写到一个函数里面

36:42.340 --> 36:44.340
但是现在有了Hook

36:44.340 --> 36:46.340
把这东西全部抽离出去

36:46.340 --> 36:48.340
横向切分出去

36:48.340 --> 36:50.340
一个副作用操作就是个Hook

36:51.340 --> 36:53.340
这个是一个Hook

36:53.340 --> 36:54.340
这个是一个Hook

36:54.340 --> 36:55.340
全部变成一个制定Hook

36:55.340 --> 36:56.340
那么他里面

36:56.340 --> 36:57.340
每一个Hook里面

36:57.340 --> 36:58.340
还有自己的状态

36:58.340 --> 36:59.340
每一个Hook里面

36:59.340 --> 37:00.340
可能有自己的副作用

37:00.340 --> 37:01.340
对吧

37:01.340 --> 37:02.340
他们的情况可能都不一样

37:02.340 --> 37:03.340
单独抽离出去

37:03.340 --> 37:04.340
去做

37:04.340 --> 37:06.340
这种做法

37:06.340 --> 37:08.340
要比你全部揉在一起

37:08.340 --> 37:10.340
真的是好上千万倍

37:10.340 --> 37:11.340
所以说

37:11.340 --> 37:13.340
当时看到这个Ustet的时候

37:13.340 --> 37:14.340
我进来了

37:14.340 --> 37:15.340
我这个玩意

37:15.340 --> 37:16.340
它一定可以达到一个

37:16.340 --> 37:17.340
抽离状态的目的

37:17.340 --> 37:19.340
状态的更加吸力度的划分

37:19.340 --> 37:21.340
那么多个组建里面

37:21.340 --> 37:23.340
共享的那种就是状态逻辑

37:23.340 --> 37:24.340
指的不是多个组建

37:24.340 --> 37:25.340
共享的状态

37:25.340 --> 37:26.340
因为我们知道Hook

37:26.340 --> 37:27.340
每次交用的

37:27.340 --> 37:29.340
就是每一个节点的状态

37:29.340 --> 37:31.340
是相隔开的

37:31.340 --> 37:33.340
它不是同一个状态

37:33.340 --> 37:34.340
只是他们的状态

37:34.340 --> 37:35.340
处理逻辑

37:35.340 --> 37:37.340
是不是完全一样的

37:37.340 --> 37:38.340
把这些完全一样的

37:38.340 --> 37:39.340
多个组建共享的

37:39.340 --> 37:40.340
就不用再去使用

37:40.340 --> 37:41.340
什么高阶组建了

37:41.340 --> 37:42.340
而使用一个

37:42.340 --> 37:43.340
普普通通的函数

37:43.340 --> 37:44.340
就可以搞定

37:44.340 --> 37:45.340
而且它不会改变

37:45.340 --> 37:46.340
这个结构

37:46.340 --> 37:48.340
不会改变组建结构

37:49.340 --> 37:50.340
那我们以前

37:50.340 --> 37:52.340
除了用高阶组建之外

37:52.340 --> 37:53.340
其实以前还有一些做法

37:53.340 --> 37:54.340
还要比较

37:54.340 --> 37:56.340
以前我们

37:56.340 --> 37:58.340
我给它写一些吧

37:58.340 --> 38:00.340
我就不过多的去

38:00.340 --> 38:01.340
演示

38:01.340 --> 38:03.340
还有什么做法

38:03.340 --> 38:05.340
还就是Render Props

38:05.340 --> 38:07.340
就是Render Props

38:07.340 --> 38:08.340
比方说我们这里

38:08.340 --> 38:10.340
写这么一个组建

38:10.340 --> 38:11.340
All Students

38:11.340 --> 38:13.340
就这么一个组建

38:13.340 --> 38:14.340
这个组建

38:14.340 --> 38:15.340
它也不用给我

38:15.340 --> 38:17.340
传一个什么函数进来

38:17.340 --> 38:19.340
你也不用传一个函数进来

38:19.340 --> 38:21.340
我就是一个组建

38:21.340 --> 38:23.340
就是凉容做法都可以

38:23.340 --> 38:25.340
其实Render Props

38:25.340 --> 38:26.340
其实本质上

38:26.340 --> 38:27.340
就是一个高阶组建

38:27.340 --> 38:29.340
本质上就是个高阶组建

38:29.340 --> 38:31.340
只不过Render Props

38:31.340 --> 38:33.340
它是解决某一层面的问题

38:33.340 --> 38:34.340
就是

38:34.340 --> 38:35.340
我数据一样

38:35.340 --> 38:37.340
显示不一样的问题

38:37.340 --> 38:39.340
那么这个就是可以用Render Props

38:39.340 --> 38:40.340
不要说All Students

38:40.340 --> 38:41.340
就这么一个组建

38:41.340 --> 38:42.340
这个组建里面

38:42.340 --> 38:43.340
就一个数组

38:43.340 --> 38:44.340
然后

38:44.340 --> 38:45.340
当家在完成过后

38:45.340 --> 38:47.340
得到所有学生数据

38:47.340 --> 38:48.340
设置状态

38:48.340 --> 38:49.340
然后显示的时候

38:49.340 --> 38:50.340
显示啥呢

38:50.340 --> 38:51.340
显示啥呢

38:51.340 --> 38:53.340
我们就显示的是

38:53.340 --> 38:54.340
你给我传递的一个

38:54.340 --> 38:55.340
判断一下

38:56.340 --> 38:57.340
显示的是

38:57.340 --> 38:58.340
如果你给我传递的一个属性

38:58.340 --> 38:59.340
叫做Render

38:59.340 --> 39:00.340
这个属性

39:00.340 --> 39:01.340
Render Props

39:01.340 --> 39:02.340
Render属性

39:02.340 --> 39:03.340
对不对

39:03.340 --> 39:04.340
你给我传递的属性

39:04.340 --> 39:05.340
那我干嘛

39:05.340 --> 39:07.340
那我返回

39:07.340 --> 39:08.340
返回这个

39:08.340 --> 39:09.340
属

39:09.340 --> 39:10.340
雕用这个函数

39:10.340 --> 39:12.340
你给我传了一个函数

39:13.340 --> 39:14.340
我最好判断一下

39:14.340 --> 39:16.340
Type of Render

39:16.340 --> 39:17.340
是不是一个方可形

39:17.340 --> 39:18.340
对吧

39:18.340 --> 39:20.340
如果你给我传的Render

39:20.340 --> 39:22.340
Render这个属性

39:22.340 --> 39:23.340
它是一个函数

39:23.340 --> 39:24.340
于是我去雕用这个函数

39:24.340 --> 39:26.340
我把这个学生数据传给你

39:26.340 --> 39:28.340
就这么一个意思

39:28.340 --> 39:29.340
我把这个学生数据

39:29.340 --> 39:30.340
Restate

39:30.340 --> 39:31.340
Destose

39:31.340 --> 39:32.340
传给你

39:32.340 --> 39:33.340
然后你去干

39:33.340 --> 39:34.340
干嘛干嘛

39:34.340 --> 39:35.340
你返回来

39:35.340 --> 39:36.340
应该是一个节点

39:37.340 --> 39:38.340
l死呢

39:38.340 --> 39:39.340
如果你

39:39.340 --> 39:40.340
给我的啥都没给我了

39:40.340 --> 39:41.340
我就返回了

39:42.340 --> 39:43.340
对吧

39:43.340 --> 39:45.340
Render Probe是不就这样写的吗

39:47.340 --> 39:48.340
然后到这边

39:48.340 --> 39:50.340
这边用的时候咋用了

39:50.340 --> 39:51.340
用的时候

39:51.340 --> 39:52.340
用的时候是这样子

39:54.340 --> 39:56.340
我们比方就使用这个玩意

39:56.340 --> 39:57.340
就使用这个玩意

39:59.340 --> 40:01.340
All Students

40:02.340 --> 40:04.340
它不是一个Render属性吗

40:04.340 --> 40:05.340
这个属性

40:05.340 --> 40:06.340
你要给它一个函数

40:06.340 --> 40:08.340
它会传过来一个学生数组

40:08.340 --> 40:10.340
会传给你一个学生数组

40:10.340 --> 40:11.340
然后你返回啥呢

40:11.340 --> 40:12.340
返回它一个组件

40:12.340 --> 40:13.340
或者是返回它一个元素

40:13.340 --> 40:14.340
啥都行

40:14.340 --> 40:15.340
返回到是一个Test

40:16.340 --> 40:17.340
对吧

40:18.340 --> 40:19.340
返回到

40:19.340 --> 40:20.340
返回到是一个Test

40:21.340 --> 40:22.340
好

40:22.340 --> 40:23.340
Test里不是要属性吗

40:23.340 --> 40:24.340
Stose是个属性

40:25.340 --> 40:26.340
不给它复制为Stose

40:26.340 --> 40:27.340
对吧

40:27.340 --> 40:28.340
把这个属性复制给它

40:29.340 --> 40:30.340
那这样子也可以

40:30.340 --> 40:31.340
算了

40:31.340 --> 40:32.340
我们还是演示一下

40:32.340 --> 40:34.660
看一下吧

40:34.660 --> 40:35.660
所以说基础一定要打牢

40:35.660 --> 40:37.660
基础打牢的关键点就在于

40:37.660 --> 40:38.660
你们之前

40:38.660 --> 40:39.660
我们做的练习

40:39.660 --> 40:41.660
你们一定要跟着做一遍

40:41.660 --> 40:43.660
老师讲得再清楚

40:43.660 --> 40:45.660
讲得再直白都没用

40:45.660 --> 40:47.660
你不去练都没用

40:47.660 --> 40:48.660
我告诉你

40:48.660 --> 40:50.660
全部是前功尽弃

40:50.660 --> 40:52.660
一定要去练习

40:52.660 --> 40:53.660
你练习了过后

40:53.660 --> 40:54.660
你这些东西才有印象

40:54.660 --> 40:56.660
你还知道它是怎么玩的

40:56.660 --> 40:57.660
RenderPurpose

40:57.660 --> 40:58.660
不就是这样玩吗

40:58.660 --> 40:59.660
对不对

40:59.660 --> 41:00.660
你给它一个函数吧

41:00.660 --> 41:01.660
那么它到时候呢

41:01.660 --> 41:02.660
你传掉函数过来

41:02.660 --> 41:03.660
它到时候会调用这个函数

41:03.660 --> 41:05.660
到时候会调用这个函数

41:05.660 --> 41:07.660
它发现它是函数去调用

41:07.660 --> 41:08.660
把数就给你传过来

41:08.660 --> 41:09.660
返回这个函数

41:09.660 --> 41:10.660
返回了结果

41:11.660 --> 41:12.660
没问题吧

41:12.660 --> 41:13.660
好

41:13.660 --> 41:14.660
那么咱们来看一下

41:14.660 --> 41:15.660
是一样的

41:15.660 --> 41:16.660
好

41:16.660 --> 41:17.660
那么现在

41:17.660 --> 41:18.660
这个组建结构

41:18.660 --> 41:19.660
是不是也变得复杂了

41:19.660 --> 41:20.660
多了一个组建的

41:20.660 --> 41:22.660
多一个莫名其妙的组建的

41:22.660 --> 41:23.660
本来我就是想

41:23.660 --> 41:24.660
之前是这个东西的

41:24.660 --> 41:25.660
多了

41:25.660 --> 41:27.660
封装了莫名其妙的一个组建

41:27.660 --> 41:28.660
而且这个绕来绕去

41:28.660 --> 41:29.660
是不是绕晕了

41:29.660 --> 41:30.660
特别容易绕晕

41:30.660 --> 41:32.660
但是现在用后壳的

41:32.660 --> 41:33.660
制定后壳

41:33.660 --> 41:35.660
就非常非常简洁

41:36.660 --> 41:37.660
制定后壳没多少讲的

41:37.660 --> 41:38.660
我只要可以讲

41:38.660 --> 41:40.660
我之所以花那么多时间

41:40.660 --> 41:42.660
一是因为他的视频课程

41:42.660 --> 41:44.660
我希望通过视频课程

41:44.660 --> 41:45.660
给他讲清楚

41:45.660 --> 41:47.660
给他讲清楚一点

41:47.660 --> 41:48.660
我怎么又变成英文了

41:48.660 --> 41:49.660
这英文都

41:49.660 --> 41:51.660
其实这英文有啥区别呢

41:51.660 --> 41:52.660
这个就没有

41:52.660 --> 41:53.660
除了拆单之外

41:53.660 --> 41:55.660
你不注意看的话

41:55.660 --> 41:56.660
都没有发生变化

41:56.660 --> 41:57.660
对吧

41:57.660 --> 41:58.660
到这里顺便说一下

41:58.660 --> 41:59.660
INF1

41:59.660 --> 42:00.660
有一些同学说

42:00.660 --> 42:01.660
他变成英文一升级

42:01.660 --> 42:02.660
变成英文之后

42:02.660 --> 42:03.660
那就不知道怎么办了

42:03.660 --> 42:04.660
写代吧都不知道怎么写了

42:04.660 --> 42:05.660
都蒙了

42:05.660 --> 42:07.660
这些configure

42:07.660 --> 42:09.660
display language

42:09.660 --> 42:13.660
这里选择ZH-CN

42:14.660 --> 42:15.660
他要让我重启

42:15.660 --> 42:17.660
重启Basque算了

42:17.660 --> 42:19.660
我不重启

42:19.660 --> 42:20.660
要的意思吧

42:20.660 --> 42:21.660
那么这里呢

42:21.660 --> 42:23.660
我们再举个例子

42:23.660 --> 42:24.660
就说我们现在视频课程

42:24.660 --> 42:26.660
尽量多发现时间

42:26.660 --> 42:27.660
我不但要告诉你这个知识

42:27.660 --> 42:29.660
而现在让你体会到这个知识

42:29.660 --> 42:31.660
它生成吃的含义

42:31.660 --> 42:32.660
它为什么要有这个东西

42:32.660 --> 42:34.660
你要彻底理解它过后

42:34.660 --> 42:36.660
你才能灵活自如的应用

42:36.660 --> 42:38.660
再来第二个例子

42:38.660 --> 42:39.660
比如说

42:39.660 --> 42:41.660
很多组建

42:41.660 --> 42:43.660
它都有这么一个功能

42:43.660 --> 42:45.660
都需要在

42:45.660 --> 42:48.660
第一次夹展

42:48.660 --> 42:50.660
完成后

42:50.660 --> 42:53.660
启动一个技时器

42:53.660 --> 42:55.660
很多组建可能需要这么一个功能

42:55.660 --> 42:57.660
在第一次夹展完成之后

42:57.660 --> 42:59.660
启动一个技时器

42:59.660 --> 43:01.660
然后在

43:01.660 --> 43:04.660
组建销毁时

43:04.660 --> 43:05.660
卸展

43:05.660 --> 43:07.660
都随便举了两个例子

43:07.660 --> 43:09.660
很多组建都需要做这么一件事情

43:09.660 --> 43:10.660
那按照以前的做法

43:10.660 --> 43:12.660
是不是又得高階组建了

43:12.660 --> 43:14.660
也要把这个功能点用高階组建

43:14.660 --> 43:16.660
抽离出去

43:16.660 --> 43:17.660
否则的话

43:17.660 --> 43:19.660
一代码就会不断地重复

43:19.660 --> 43:21.660
但是现在有了乎可之后

43:21.660 --> 43:23.660
真的是方便的赶人

43:23.660 --> 43:24.660
你知道吗

43:24.660 --> 43:25.660
又是

43:25.660 --> 43:27.660
这个取了什么名字呢

43:28.660 --> 43:29.660
Tamer

43:29.660 --> 43:31.660
又是Tamer

43:31.660 --> 43:33.660
好,来吧

43:33.660 --> 43:34.660
你看

43:34.660 --> 43:36.660
给它写这么两个例子就够了

43:36.660 --> 43:40.030
它要不要这个UseData

43:40.030 --> 43:41.030
放怎么放

43:41.030 --> 43:42.030
以后不用再说

43:42.030 --> 43:44.030
UsePortDefault

43:44.030 --> 43:46.030
有没有这个

43:47.030 --> 43:49.030
行了,就这个吧

43:49.030 --> 43:50.030
那么我们写这么一个函数

43:50.030 --> 43:52.030
我没有用方个形的

43:52.030 --> 43:53.030
要不然还是用一个方个形

43:53.030 --> 43:55.030
算了,就这样吧

43:55.030 --> 43:56.030
UseTamer

43:56.030 --> 43:58.030
我就写这么一个函数

43:58.030 --> 43:59.030
这个函数干嘛呢

43:59.030 --> 44:01.030
是不是就是UseFX

44:01.030 --> 44:02.030
你第一次夹展的时候

44:02.030 --> 44:04.030
要启动一个技时器嘛,对不对

44:04.030 --> 44:06.030
是不是要启动一个技时器

44:06.030 --> 44:08.030
要启动这么一个技时器

44:08.030 --> 44:11.030
那么我就写这么一个UseFX

44:11.030 --> 44:14.030
UseFX里边干嘛呢

44:14.030 --> 44:16.030
是不是要启动技时器

44:16.030 --> 44:18.030
对吧,启动技时器

44:18.030 --> 44:20.030
因为它只是在

44:20.030 --> 44:22.030
第一次夹展里面的时候启动

44:22.030 --> 44:24.030
所以说我们这里

44:24.030 --> 44:26.030
一旦相为空数组

44:26.030 --> 44:28.030
只有第一次夹展的时候启动

44:28.030 --> 44:30.030
那么这里呢,我就设置一个Tamer

44:30.030 --> 44:32.030
Tamer

44:32.030 --> 44:34.030
然后干嘛呢

44:34.030 --> 44:36.030
再一次,Interval

44:36.030 --> 44:38.030
比方说Interval嘛

44:38.030 --> 44:41.470
Interval

44:41.470 --> 44:44.470
每隔一段时间做啥事

44:44.470 --> 44:46.470
那么做啥事我是不是不知道

44:46.470 --> 44:48.470
我咋知道你要做啥事呢

44:48.470 --> 44:50.470
我只知道我要启动技时器

44:50.470 --> 44:52.470
但是你要做啥事我确实不知道

44:52.470 --> 44:54.470
所以说你做啥事是不是在传给我

44:54.470 --> 44:55.470
通通参数

44:55.470 --> 44:56.470
传给我一个啥

44:56.470 --> 44:58.470
传给我一个就是Funk

44:58.470 --> 45:00.470
要做什么事情

45:00.470 --> 45:01.470
传给我

45:01.470 --> 45:03.470
那么我去做这些事情

45:03.470 --> 45:05.470
那么你把这个函数传给我

45:05.470 --> 45:07.470
我也没有什么传数给你

45:07.470 --> 45:09.470
好,那么时间间隔

45:09.470 --> 45:10.470
Directing

45:10.470 --> 45:11.470
你要告诉我

45:11.470 --> 45:13.470
我也不知道多好间隔去做一次

45:13.470 --> 45:15.470
时间间隔传给我

45:15.470 --> 45:17.470
我只是帮你启动一个技时器而已

45:17.470 --> 45:19.470
这个技时器写好了之后呢

45:19.470 --> 45:21.470
我们返回一个清理函数

45:21.470 --> 45:23.470
这个清理函数要做的事情很简单

45:23.470 --> 45:25.470
就是把这个技时器

45:25.470 --> 45:27.470
给它清空

45:27.470 --> 45:28.470
对吧

45:28.470 --> 45:30.470
打个注释,这个函数

45:30.470 --> 45:32.470
这个制定互可干嘛

45:32.470 --> 45:36.470
就是主键首次宣然后

45:36.470 --> 45:39.470
启动一个技时器

45:39.470 --> 45:40.470
什么技时器呢

45:40.470 --> 45:41.470
是一个interval技时器

45:41.470 --> 45:43.470
我们给它把注释打好

45:43.470 --> 45:47.470
然后主键卸载后

45:47.470 --> 45:50.470
清除该技时器

45:50.470 --> 45:51.470
对吧

45:51.470 --> 45:54.470
那么我们就可以用这种方式来处理

45:54.470 --> 45:56.470
那么这个Ustex没用了

45:56.470 --> 45:58.470
没用了,去掉

45:58.470 --> 46:00.470
好,那么这就写完了

46:00.470 --> 46:01.470
你挨做什么事情

46:01.470 --> 46:02.470
你自己去做

46:02.470 --> 46:03.470
你给我传参数传进来

46:03.470 --> 46:04.470
你自己去做

46:04.470 --> 46:05.470
我不管你了

46:05.470 --> 46:07.470
接下来这里有一个

46:07.470 --> 46:08.470
不是抱错,是一个警告

46:08.470 --> 46:10.470
这个警告为什么一会有呢

46:10.470 --> 46:11.470
是因为它说

46:11.470 --> 46:13.470
你这个副作用函数里面

46:13.470 --> 46:14.470
它用到了这两个变量

46:14.470 --> 46:16.470
但是你没有把它做为依赖项

46:16.470 --> 46:18.470
我们这个警告呢

46:18.470 --> 46:20.470
如果要解决的话

46:20.470 --> 46:21.470
当然很简单

46:21.470 --> 46:22.470
你只给它传一个函数

46:22.470 --> 46:24.470
duration过去就行了

46:24.470 --> 46:25.470
你给它传过去就行了

46:25.470 --> 46:26.470
但是呢

46:26.470 --> 46:28.470
我这里确实不想传

46:28.470 --> 46:30.470
因为它确实是第一次操作

46:30.470 --> 46:31.470
就做这个事

46:31.470 --> 46:32.470
后面它一定不会做了

46:32.470 --> 46:34.470
因为我们的功能说明就是这样子

46:34.470 --> 46:36.470
它后面一定不会做了

46:36.470 --> 46:38.470
所以说管它一代向改不改变

46:38.470 --> 46:39.470
我都不会再做任何事情了

46:39.470 --> 46:41.470
只有主建卸载的时候

46:41.470 --> 46:42.470
才会做这件事情

46:42.470 --> 46:43.470
那么我想不希望

46:43.470 --> 46:44.470
看到一点老火

46:44.470 --> 46:46.470
当然你不管它也无所谓

46:46.470 --> 46:48.470
看到一点老火对不对

46:48.470 --> 46:51.470
我们想把这个就是警告清除掉

46:51.470 --> 46:53.470
那么这个清除警告的话

46:53.470 --> 46:54.470
我这里说一下吧

46:54.470 --> 46:56.470
之前还没讲过这个清除警告

46:56.470 --> 46:58.470
有的时候我确实

46:58.470 --> 47:00.470
我知道我自己在干什么

47:00.470 --> 47:01.470
我不需要一代的两个东西

47:01.470 --> 47:02.470
虽然说我用到了它

47:02.470 --> 47:04.470
但是我不需要一代的两个东西

47:04.470 --> 47:06.470
那么如何来清除这个警告呢

47:06.470 --> 47:07.470
首先我跟大家说一下

47:07.470 --> 47:10.470
这个警告是怎么产生的

47:10.470 --> 47:12.470
说一下

47:12.470 --> 47:14.470
这是个页外的知识

47:14.470 --> 47:20.470
在使用hook的时候

47:20.470 --> 47:25.470
如果没有严格按照hook的规则进行

47:25.470 --> 47:27.470
不要该写一带一项

47:27.470 --> 47:28.470
你没有写

47:28.470 --> 47:30.470
或者说这个hook

47:30.470 --> 47:32.470
该使用use开头你没有用

47:32.470 --> 47:34.470
或者说这个hook

47:34.470 --> 47:35.470
只能在顶层调用

47:35.470 --> 47:36.470
这都是一定的

47:36.470 --> 47:37.470
只能在顶层调用

47:37.470 --> 47:39.470
不能在判断里面去调用

47:39.470 --> 47:41.470
但是你跑到判断里面去调用了

47:41.470 --> 47:42.470
但是有些特殊情况下

47:42.470 --> 47:44.470
我们确实知道自己在干什么

47:44.470 --> 47:45.470
我们能够控制它

47:45.470 --> 47:47.470
希望不要去给我进行

47:47.470 --> 47:49.470
这样的代码检查

47:49.470 --> 47:50.470
那么如果你没有按照

47:50.470 --> 47:52.470
hook的规则进行的话

47:52.470 --> 47:56.470
esnint的一个插件

47:56.470 --> 48:00.470
会爆一个警告

48:00.470 --> 48:02.470
会爆出警告

48:02.470 --> 48:04.470
那么插件的名字叫什么

48:04.470 --> 48:05.470
名字很长

48:05.470 --> 48:06.470
我也记不住

48:06.470 --> 48:08.470
它使用这个角色架

48:08.470 --> 48:10.470
create-react-app这个角色架的时候

48:10.470 --> 48:12.470
它就已经安装好了这个插件

48:12.470 --> 48:13.470
它的名字叫什么

48:13.470 --> 48:14.470
我收一下

48:14.470 --> 48:16.470
叫做react

48:16.470 --> 48:18.470
esnint

48:18.470 --> 48:20.470
反正是你这个开头

48:20.470 --> 48:22.470
pronging一定是这个开头的

48:22.470 --> 48:24.470
后边你看一下

48:24.470 --> 48:28.470
esnint-pronging-hooks

48:28.470 --> 48:29.470
就这个插件

48:29.470 --> 48:32.470
这个插件里面会给你爆一个警告

48:32.470 --> 48:34.470
哪个插件是这个插件

48:34.470 --> 48:40.470
esnint-pronging-react-hooks

48:40.470 --> 48:42.470
它会给你爆出警告

48:42.470 --> 48:44.470
那么它爆警告的时候

48:44.470 --> 48:46.470
它是有两个规则

48:46.470 --> 48:47.470
有两个规则给爆警告

48:47.470 --> 48:49.470
那么刚才我们这里的规则是什么

48:49.470 --> 48:51.470
就是依赖向不满足要求

48:51.470 --> 48:53.470
它会给你爆警告

48:53.470 --> 48:55.470
那么根据我们esnint的支持

48:55.470 --> 48:57.470
我们是不是可以让它忽略掉这一点

48:57.470 --> 48:58.470
对吧

48:58.470 --> 49:00.470
我们可以让它在这个文件里边

49:00.470 --> 49:01.470
就不要给我警告了

49:01.470 --> 49:03.470
忽略掉这个就是

49:03.470 --> 49:05.470
忽略掉这个就是检查

49:05.470 --> 49:07.470
那么怎么来忽略呢

49:07.470 --> 49:08.470
OK

49:08.470 --> 49:10.470
这里我们来查一下

49:10.470 --> 49:12.470
这个插件它的官方文档是怎么说的

49:12.470 --> 49:13.470
这个要学会

49:13.470 --> 49:14.470
要学会如何去查一个

49:14.470 --> 49:15.470
插件的官方文档

49:15.470 --> 49:16.470
好

49:16.470 --> 49:17.470
怎么来查呢

49:17.470 --> 49:19.470
我们就进入网页里边

49:19.470 --> 49:20.470
去搜一下

49:20.470 --> 49:22.470
我们npm介石

49:22.470 --> 49:24.470
进入这个网站

49:24.470 --> 49:26.470
然后去搜一下这个插件的名字

49:26.470 --> 49:28.470
复制一下

49:28.470 --> 49:29.470
搜一下这个插件的名字

49:29.470 --> 49:31.470
它就会告诉你它的规则

49:31.470 --> 49:35.100
点进去看一下

49:35.100 --> 49:37.100
然后它告诉你它的规则就两个

49:37.100 --> 49:38.100
就两个

49:38.100 --> 49:39.100
一个是互可的规则

49:39.100 --> 49:40.100
一个是呢

49:40.100 --> 49:42.100
就是依赖向检查的规则

49:42.100 --> 49:44.100
一个是hensity

49:44.100 --> 49:46.100
一个是hensity

49:46.100 --> 49:48.100
什么意思

49:48.100 --> 49:50.100
叫做全面的

49:50.100 --> 49:52.100
就是依赖向检查

49:52.100 --> 49:54.100
全面的依赖向检查

49:54.100 --> 49:56.100
那么你把它设置为war

49:56.100 --> 49:57.100
表示有警告

49:57.100 --> 49:58.100
有警告发生

49:58.100 --> 49:59.100
那么这里呢

49:59.100 --> 50:01.100
我们就把它设置为off

50:01.100 --> 50:03.100
off我们在一般的eslint

50:03.100 --> 50:04.100
表示把它关掉

50:04.100 --> 50:05.100
把这个配置关掉

50:05.100 --> 50:06.100
好

50:06.100 --> 50:08.100
那么根据我们以前学过的知识

50:08.100 --> 50:09.100
怎么写这里

50:09.100 --> 50:10.100
咋写

50:10.100 --> 50:12.100
是不是在这个文件开头

50:12.100 --> 50:14.100
我们只需要它忽略的文件就行了

50:14.100 --> 50:15.100
在这个文件开头

50:16.100 --> 50:18.100
打上一个注释不就完了吗

50:18.100 --> 50:19.100
对不对

50:19.100 --> 50:20.100
这个注释里边是不是前面写上

50:20.100 --> 50:21.100
eslint空格

50:21.100 --> 50:23.100
后边写上我们的配置

50:23.100 --> 50:24.100
就这个配置

50:24.100 --> 50:26.100
把它设置为off

50:26.100 --> 50:27.100
对吧

50:27.100 --> 50:28.100
就完了

50:28.100 --> 50:29.100
一看就不报警告了

50:29.100 --> 50:30.100
就是eslint的东西

50:30.100 --> 50:32.100
跟我们现在rex没什么关系

50:32.100 --> 50:33.100
ok

50:34.100 --> 50:35.100
它就不报警告了

50:35.100 --> 50:36.100
对吧

50:36.100 --> 50:38.100
那么现在这个就写完了

50:38.100 --> 50:40.100
我们来测试一下吧

50:40.100 --> 50:42.100
到这里面来

50:42.100 --> 50:43.100
复制一个

50:43.100 --> 50:44.100
复制一个

50:45.100 --> 50:47.100
然后我们这里

50:47.100 --> 50:49.100
也不要这个组件了

50:49.100 --> 50:50.100
也不要这个玩意了

50:50.100 --> 50:51.100
还是用个test

50:51.100 --> 50:52.100
还是用test

50:52.100 --> 50:55.670
有这么一个组件

50:55.670 --> 50:56.670
这个组件

50:56.670 --> 50:57.670
它要使用一个hook

50:57.670 --> 50:59.670
它可能一开始要启动技术器

50:59.670 --> 51:01.670
我们刚好就写了这么一个hook

51:01.670 --> 51:03.670
启动一个技术器

51:03.670 --> 51:06.670
就是use tamer

51:06.670 --> 51:09.670
from my hooks

51:09.670 --> 51:11.670
use tamer

51:12.670 --> 51:13.670
那么这里边

51:13.670 --> 51:14.670
这个组件啥

51:14.670 --> 51:15.670
啥都没有

51:18.670 --> 51:19.670
这是一个组件

51:19.670 --> 51:21.670
test组件

51:21.670 --> 51:23.670
然后我们这里

51:23.670 --> 51:26.670
就调用use tamer

51:26.670 --> 51:28.670
它啥都没返回

51:28.670 --> 51:29.670
对吧

51:29.670 --> 51:30.670
非常灵活的

51:30.670 --> 51:31.670
这个函数里随便打写

51:31.670 --> 51:32.670
然后这里要传一个函数

51:32.670 --> 51:33.670
就是每一次时间

51:33.670 --> 51:34.670
间隔到了过后要干嘛

51:34.670 --> 51:36.670
比方说一秒钟

51:36.670 --> 51:37.670
间隔为一秒钟

51:37.670 --> 51:39.670
每隔一秒钟要干嘛

51:39.670 --> 51:41.670
我们要输出一个

51:41.670 --> 51:42.670
输出一个啥

51:42.670 --> 51:44.670
我也不知道输出啥

51:44.670 --> 51:46.670
输出一个

51:46.670 --> 51:51.670
test组件的一些副作用

51:51.670 --> 51:52.670
操作

51:52.670 --> 51:53.670
比方说随便写吧

51:53.670 --> 51:55.670
随便写

51:55.670 --> 51:57.670
那么咱们来看一下

51:57.670 --> 51:58.670
这边

51:58.670 --> 52:02.180
你看是不是每个一秒运行次

52:02.180 --> 52:03.180
对吧

52:03.180 --> 52:04.180
它就实现这么一个功能了

52:04.180 --> 52:05.180
对不对

52:05.180 --> 52:06.180
而且它还有一个功能是什么

52:06.180 --> 52:08.180
当它卸载的时候

52:08.180 --> 52:09.180
它就不见了

52:09.180 --> 52:11.180
比方说这个函数里边

52:11.180 --> 52:12.180
把它卸载掉

52:12.180 --> 52:14.180
我们这里UseState

52:14.180 --> 52:16.180
这里是Visible

52:20.180 --> 52:23.810
这里倒进来

52:23.810 --> 52:24.810
UseState

52:24.810 --> 52:25.810
其实像这个玩意

52:25.810 --> 52:26.810
是不是也可以抽象出去

52:26.810 --> 52:27.810
对吧

52:27.810 --> 52:29.810
也可以抽象出去的

52:29.810 --> 52:31.810
然后这里的

52:32.810 --> 52:34.810
test这里

52:34.810 --> 52:37.810
我们再给它写上一个按钮

52:37.810 --> 52:40.810
隐藏显示

52:40.810 --> 52:42.810
显示

52:43.810 --> 52:45.810
于是我们这里这样子写

52:49.210 --> 52:50.210
这样子写

52:50.210 --> 52:51.210
这里Visible

52:51.210 --> 52:53.210
如果它的值为处的话

52:53.210 --> 52:55.210
我们显示这个组件

52:55.210 --> 52:57.210
点击这个按钮干嘛呢

52:57.210 --> 52:58.210
onclick

52:58.210 --> 52:59.210
点击这个按钮的时候

52:59.210 --> 53:01.210
我们就重新设置

53:01.210 --> 53:02.210
setVisible

53:02.210 --> 53:03.210
为什么

53:03.210 --> 53:05.210
之前的相反的情况

53:06.210 --> 53:07.210
保存

53:07.210 --> 53:08.210
你看一下吧

53:08.210 --> 53:10.210
一开始它有这个副作用操作

53:10.210 --> 53:11.210
对吧

53:11.210 --> 53:13.210
隐藏是不是写在这个组件了

53:13.210 --> 53:14.210
这个谈判是不是清空了

53:14.210 --> 53:15.210
对吧

53:15.210 --> 53:17.210
再显示是不是一个新的组件出来了

53:17.210 --> 53:18.210
它又继续

53:18.210 --> 53:19.210
计时器

53:19.210 --> 53:20.210
然后再隐藏

53:20.210 --> 53:22.210
计时器又消失了

53:22.210 --> 53:23.210
对吧

53:23.210 --> 53:24.210
我们就把这个功能点

53:24.210 --> 53:25.210
给它抽离出去了

53:25.210 --> 53:27.210
所以说我们用了互可之后

53:27.210 --> 53:28.210
它会变得

53:28.210 --> 53:31.210
整个程序会变得非常非常细致

53:31.210 --> 53:34.210
大家以后在公司里面开发代码的时候

53:34.210 --> 53:36.210
特别是用rex开发代码的时候

53:36.210 --> 53:38.210
一开始可以不用去抽离这个东西

53:38.210 --> 53:39.210
而写着写着

53:39.210 --> 53:41.210
发现我们有些功能经常会用到

53:41.210 --> 53:43.210
于是你这个时候就可以考虑优化

53:43.210 --> 53:44.210
把它抽离出去

53:44.210 --> 53:46.210
而且这种抽离

53:46.210 --> 53:48.210
它不会改变这个组件结构

53:48.210 --> 53:50.210
所以你不会产生了

53:50.210 --> 53:52.210
组件结构发生变化

53:52.210 --> 53:54.210
导致你可能有些相关的功能

53:54.210 --> 53:55.210
发生问题

53:55.210 --> 53:56.210
它不会的

53:56.210 --> 53:57.210
组件结构非常纯净

53:57.210 --> 53:58.210
就是这两个组件

53:58.210 --> 53:59.210
App and Test

53:59.210 --> 54:01.210
这样的做法要比

54:01.210 --> 54:02.210
高阶组件

54:02.210 --> 54:05.210
要比什么Render Props

54:05.210 --> 54:06.210
要好

54:06.210 --> 54:08.210
所以这个互可的就是它的优势

54:08.210 --> 54:09.210
所在

54:10.210 --> 54:12.210
而且它的代码非常容易理解

54:12.210 --> 54:14.210
它无非就是抽离的一个函数

54:14.210 --> 54:15.210
出去玩事了

54:15.210 --> 54:17.210
把风光的一个函数而已

54:17.210 --> 54:19.210
你看高阶组件和Render Props

54:19.210 --> 54:21.210
要绕多大一个圈

54:21.210 --> 54:22.210
你才能理解这个东西

54:22.210 --> 54:23.210
所以说用这个互可的过后

54:23.210 --> 54:25.210
会变得非常简洁

54:26.210 --> 54:28.210
这个东西让大家下来练习一下

54:28.210 --> 54:29.210
都去做一下练习

54:29.210 --> 54:31.210
比方说像我们这个技时器

54:31.210 --> 54:34.210
像刚才做了一个什么

54:34.210 --> 54:36.210
或许水层数据

54:36.210 --> 54:38.210
这些千七百万的抽离

54:38.210 --> 54:40.210
以后我们在真实项目里边

54:40.210 --> 54:42.210
可能会遇到更多的一些场景

54:42.210 --> 54:44.210
去抽离这些东西

54:44.210 --> 54:46.210
这是关于自定义互可

54:46.210 --> 54:47.210
它没有什么新的知识

54:47.210 --> 54:49.210
就是你写个函数把风桩一下

54:49.210 --> 54:52.210
就变得整个代码变得非常简洁

54:52.210 --> 54:55.210
这是关于自定互可

54:55.210 --> 54:56.210
其实互可的核心知识

54:56.210 --> 54:57.210
我们已经讲完了

54:57.210 --> 54:58.210
最核心的知识

54:58.210 --> 54:59.210
百分之八十的场景用的知识

54:59.210 --> 55:01.210
都已经讲完了

55:01.210 --> 55:02.210
后面还有一大堆东西

55:02.210 --> 55:03.210
一大堆东西的话

55:03.210 --> 55:05.210
都是一些不太常见的东西了

55:06.210 --> 55:08.210
我们把它作为什么

55:08.210 --> 55:10.210
作为那个

55:10.210 --> 55:12.210
它作为扩展课程吧

55:12.210 --> 55:14.210
把后边的东西作为扩展课程

55:14.210 --> 55:15.210
得了

55:15.210 --> 55:16.210
因为后边的东西

55:16.210 --> 55:17.210
确实不是那么常见

55:17.210 --> 55:18.210
算了算了

55:18.210 --> 55:19.210
还是不要作为扩展课程的

55:19.210 --> 55:21.210
因为毕竟我

55:21.210 --> 55:22.210
主要是担心它以后

55:22.210 --> 55:24.210
用的场景会非常非常多

55:24.210 --> 55:26.210
可能会用到那些知识

55:26.210 --> 55:27.210
所以大家还是听一下

55:27.210 --> 55:28.210
听一下

55:28.210 --> 55:30.210
OK 这是关于自定互可

