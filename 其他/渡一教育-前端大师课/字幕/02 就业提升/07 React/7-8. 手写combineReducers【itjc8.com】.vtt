WEBVTT

00:00.940 --> 00:05.940
到现在呢 留给我们要写的东西呢 其实就已经不多了

00:05.940 --> 00:10.940
因为我们用到的 当时里面用到的就这么几个 对吧 没了

00:10.940 --> 00:15.940
CreatorStorm 什么Band Action Creators 上一颗写的 对吧

00:15.940 --> 00:18.940
这里一块呢 咱们来写comband reducers

00:18.940 --> 00:22.940
这一块呢 应该是 这里边比较有难度的吧

00:22.940 --> 00:26.940
其实难度也不高 也很简单

00:26.940 --> 00:29.940
咱们先用一下 先用一下它的

00:29.940 --> 00:33.940
我们把这里用成原生的 也不在这里用成原生的

00:33.940 --> 00:36.940
我们看一下这里 因为这个东西我们功能都已经实现了

00:36.940 --> 00:39.940
一模一样的 在这

00:39.940 --> 00:43.940
这comband reducers 对吧 这是我们之前写的 用的是原生的

00:43.940 --> 00:47.940
原生的 用了原生的之后呢 它其实就是上面类似的代码

00:47.940 --> 00:50.940
类似的代码 帮我们组合成一个新的状态

00:50.940 --> 00:54.940
然后呢 这里边 属性名呢 给你传递的属性名是一致的

00:54.940 --> 00:57.940
这里的 也是一致的 对吧

00:57.940 --> 01:00.940
那么这些属性的籽呢 就来自于你给它传的 reducer

01:00.940 --> 01:03.940
你去调用它 调用你传递的 reducer

01:03.940 --> 01:07.940
来得到的就是属性值 其实整体上的是非常非常简单的

01:07.940 --> 01:10.940
咱们来用一下 看它有什么样的比较特殊的地方

01:10.940 --> 01:13.940
我们在这个 我们自己的就是

01:13.940 --> 01:15.940
因为 reducer 它形成了一个树嘛 对吧

01:15.940 --> 01:17.940
reducer 它形成了一个树 这个东西呢

01:17.940 --> 01:20.940
是通过comband reducer 是来产生的

01:20.940 --> 01:23.940
那么下边的东西呢 都是我们自己手写的 对吧

01:23.940 --> 01:25.940
都是手写的 好 手写的里面呢

01:25.940 --> 01:27.940
我们这里输出一句话 输出这个type值

01:27.940 --> 01:29.940
咱们来看一下 保存

01:29.940 --> 01:32.940
然后在index 里面我们不是触发了x 嘛 对吧

01:32.940 --> 01:35.940
触发了x 把这个去掉

01:35.940 --> 01:39.940
好 然后呢 我们来看一下 这里 运行出来

01:39.940 --> 01:41.940
第一个 看一下

01:41.940 --> 01:45.320
好 它这样运行出来的话

01:45.320 --> 01:47.320
你会发现一个比较奇特的现象

01:47.320 --> 01:50.320
就是呢 它这里的type值呢

01:50.320 --> 01:53.320
type值呢 给你写了两个type值 你看到没

01:53.320 --> 01:56.320
我们这里把它复制一下嘛 记录一下

01:56.320 --> 01:58.320
给你写了两个type值在这

02:01.320 --> 02:04.320
在这 给你写了两个type值

02:04.320 --> 02:07.320
第三个呢 是我们最后是自己触发的 对不对

02:07.320 --> 02:09.320
是我们创建仓库的时候

02:09.320 --> 02:12.320
它不是要触发 也分发一次x 嘛 对吧

02:12.320 --> 02:15.320
一个初始化的x 那这里呢 它给你写的

02:15.320 --> 02:17.320
但是呢 这个comband reducer 是

02:17.320 --> 02:20.320
它给你自行的 给你触发了两次

02:20.320 --> 02:23.320
其实这件事呢 你们做和不做都无所谓

02:23.320 --> 02:26.320
都无所谓 它为什么给你先触发两次呢

02:26.320 --> 02:29.320
comband reducer 是里面 它主要是为了验证

02:29.320 --> 02:32.320
怕你自己写的这个reducer 它写的有问题

02:32.320 --> 02:34.320
它主要是写一个验证的作用

02:34.320 --> 02:36.320
一会呢 我们就按照它的来骂

02:36.320 --> 02:38.320
那就看一下它怎么去验证的

02:38.320 --> 02:41.320
其实也很简单 它就给你随便触发两次

02:41.320 --> 02:43.320
然后去验证一下你返回的结果

02:43.320 --> 02:45.320
它主要是验证你返回的结果 是不是undefend

02:45.320 --> 02:47.320
它要求你不能是undefend

02:47.320 --> 02:49.320
它就是这么个意思

02:49.320 --> 02:51.320
就是使用inlet来触发

02:51.320 --> 02:53.320
因为inlet它是一个特殊的axing

02:53.320 --> 02:55.320
就是初始化的axing

02:55.320 --> 02:56.320
看一下inlet这个axing触发过后

02:56.320 --> 02:57.320
你有没有返回undefend

02:57.320 --> 02:59.320
如果有的话 还可以爆出

02:59.320 --> 03:01.320
那么如果说inlet没问题

03:01.320 --> 03:03.320
它再给你触发 随便乱触发一个

03:03.320 --> 03:05.320
因为它怕你进行的

03:05.320 --> 03:06.320
你把它写死了

03:06.320 --> 03:07.320
它怕你在reducer里面写到这种东西

03:07.320 --> 03:09.320
当然我们不会这样子写 对吧

03:09.320 --> 03:10.320
它怕你写到这么一个东西

03:10.320 --> 03:13.320
就是说 如果type

03:13.320 --> 03:15.320
里面include 比方说

03:15.320 --> 03:18.320
或者是start

03:18.320 --> 03:20.320
这个字不错的函数叫它

03:20.320 --> 03:22.320
叫start-wis

03:22.320 --> 03:24.320
比方说

03:24.320 --> 03:26.320
你可能会这样子写start-wis

03:26.320 --> 03:29.320
如果说是以inlet开头的

03:29.320 --> 03:30.320
比方说at-at

03:30.320 --> 03:32.320
为大个是inlet

03:32.320 --> 03:34.320
如果是以inlet开头的

03:34.320 --> 03:36.320
你可能特殊的给它返回一个特殊的东西

03:36.320 --> 03:38.320
它怕你这样去写 这种错误的代码

03:38.320 --> 03:40.320
所以说 它第二次触发了

03:40.320 --> 03:42.320
又给你触发了一个完全又不一样的axing type

03:42.320 --> 03:44.320
那么 如果你还返回

03:44.320 --> 03:46.320
又返回的是undefend

03:47.320 --> 03:49.320
就这么个意思 其他的没啥了

03:49.320 --> 03:51.320
它就是错误去提示你

03:51.320 --> 03:53.320
你应该在位置的axing下面

03:53.320 --> 03:55.320
你应该返回 远风不动的返回对象

03:55.320 --> 03:58.320
它主要是保证这个 其他的它就无所谓了

03:58.320 --> 04:00.320
当然我们自己知道

04:00.320 --> 04:02.320
我们按照规范来写的话 这样子写是没问题的

04:02.320 --> 04:03.320
无非就是这样子

04:03.320 --> 04:05.320
它就可以做到这么两件事

04:05.320 --> 04:06.320
所以说 它这里

04:06.320 --> 04:08.320
犹豫它一会要触发inlet

04:08.320 --> 04:11.320
要触发这个乱七八糟的玩意

04:11.320 --> 04:13.320
那么我们最好

04:13.320 --> 04:15.320
把这些特殊的axing type

04:15.320 --> 04:16.320
封装一下

04:16.320 --> 04:18.320
因为我们之前写过这么一个东西

04:18.320 --> 04:20.320
是写到这儿的

04:20.320 --> 04:22.320
写到这儿的

04:22.320 --> 04:24.320
我们是把它写到这儿的

04:24.320 --> 04:26.320
那么我们干脆由于它要重用

04:26.320 --> 04:28.320
inlet它要重用

04:30.320 --> 04:31.320
它要重用

04:31.320 --> 04:33.320
所以说我们这里最好把它封装一下

04:33.320 --> 04:35.320
便于在另外一个文件里面也可以用

04:35.320 --> 04:37.320
封装一个

04:37.320 --> 04:39.320
封装一个就是axing

04:39.320 --> 04:40.320
封装一个就是

04:40.320 --> 04:42.320
或者加个文件夹吧

04:45.320 --> 04:46.320
加个文件夹

04:46.320 --> 04:48.320
叫Utils

04:48.320 --> 04:49.320
一个工具箱

04:49.320 --> 04:52.320
工具箱里面提供的一个就是axing types

04:52.320 --> 04:53.320
axing types

04:53.320 --> 04:55.320
这里边它该导出一些常用的

04:55.320 --> 04:57.320
常用的就是

04:57.320 --> 04:59.320
特殊的axing类型

04:59.320 --> 05:00.320
导出一些常用的

05:00.320 --> 05:03.320
比方说这里边人不是有两个吗

05:03.320 --> 05:04.320
不是有两个吗

05:04.320 --> 05:05.320
is playing object

05:05.320 --> 05:06.320
对吧

05:06.320 --> 05:07.320
这个

05:07.320 --> 05:08.320
这个玩意儿

05:08.320 --> 05:10.320
那么这个东西我们可以写到这儿的

05:10.320 --> 05:11.320
写到这儿的

05:11.320 --> 05:12.320
对吧

05:12.320 --> 05:13.320
写到这儿的

05:14.320 --> 05:16.320
那么这里有个get ridden stream

05:16.320 --> 05:17.320
给过一个长度

05:17.320 --> 05:19.320
我给你返回一个就是水移至无串

05:19.320 --> 05:20.320
水移至无串

05:20.320 --> 05:21.320
用点拼接的水移至无串

05:21.320 --> 05:22.320
返回这么一个函数

05:22.320 --> 05:24.320
最后我们导出

05:25.320 --> 05:27.320
导出的是一个对象

05:27.320 --> 05:30.320
对象里边写上这么一个就是innet

05:30.320 --> 05:31.320
或者叫大写

05:31.320 --> 05:33.320
innet

05:33.320 --> 05:35.320
它是一个函数

05:35.320 --> 05:36.320
这个函数

05:36.320 --> 05:38.320
返回的是一个innet的

05:38.320 --> 05:40.320
就是水移至无串

05:40.320 --> 05:41.320
那么这里调弄的是什么呢

05:41.320 --> 05:42.320
get ridden stream

05:44.320 --> 05:46.320
我看它那个好像是6个

05:46.320 --> 05:47.320
6个字母

05:47.320 --> 05:48.320
对6个

05:48.320 --> 05:49.320
我们之前写的是7个

05:49.320 --> 05:50.320
写错了对吧

05:50.320 --> 05:51.320
这里是6个

05:51.320 --> 05:52.320
ok 这是innet

05:52.320 --> 05:53.320
然后呢

05:53.320 --> 05:55.320
这是这个x的类型

05:55.320 --> 05:56.320
然后呢

05:56.320 --> 05:58.320
我们再导出一个就是online

05:58.320 --> 06:00.950
online

06:00.950 --> 06:01.950
online的话

06:01.950 --> 06:02.950
它是这个类型

06:03.950 --> 06:04.950
复最下

06:05.950 --> 06:06.950
这里

06:06.950 --> 06:07.950
这里我要拼接一下

06:07.950 --> 06:08.950
对吧

06:08.950 --> 06:11.840
我得拼接一下

06:12.840 --> 06:13.840
拼接一下

06:13.840 --> 06:16.840
然后前边写上一个固定的字母圈

06:16.840 --> 06:17.840
就这个

06:17.840 --> 06:18.840
对吧

06:18.840 --> 06:19.840
拼接一下

06:19.840 --> 06:20.840
好了

06:20.840 --> 06:21.840
这是innet返回的东西

06:21.840 --> 06:22.840
就特别特别简单

06:22.840 --> 06:24.840
下面这个呢返回这个

06:24.840 --> 06:26.840
主要是为了测试一下

06:26.840 --> 06:27.840
你的就是

06:27.840 --> 06:29.840
只x型有没有问题

06:29.840 --> 06:30.840
其实像这个

06:30.840 --> 06:32.840
只reducer有没有问题

06:32.840 --> 06:33.840
只reducer有没有问题

06:33.840 --> 06:34.840
就像这些reducer

06:34.840 --> 06:35.840
它形成一个数型结构

06:35.840 --> 06:36.840
对不对

06:36.840 --> 06:38.840
我们的数据形成了一个数型结构

06:38.840 --> 06:39.840
那么这里呢

06:39.840 --> 06:40.840
也是get ridden stream

06:40.840 --> 06:41.840
ok

06:41.840 --> 06:42.840
就写这么两个

06:42.840 --> 06:44.840
两个特殊的x型

06:44.840 --> 06:45.840
x型type

06:45.840 --> 06:46.840
刁问这个函数

06:46.840 --> 06:47.840
就会得到这个x型type

06:47.840 --> 06:48.840
对吧

06:48.840 --> 06:49.840
就是x型的类型

06:49.840 --> 06:50.840
那么有了这个

06:50.840 --> 06:51.840
这个方法之后

06:51.840 --> 06:53.840
我们可以在quidstone里面

06:53.840 --> 06:54.840
那么就把这个东西去掉了

06:54.840 --> 06:55.840
就不要了

06:55.840 --> 06:56.840
这里呢

06:56.840 --> 06:57.840
我们导入

06:57.840 --> 06:58.840
import

06:58.840 --> 06:59.840
x

06:59.840 --> 07:00.840
x

07:00.840 --> 07:01.840
x

07:01.840 --> 07:02.840
x

07:02.840 --> 07:03.840
x

07:03.840 --> 07:04.840
x

07:04.840 --> 07:05.840
x

07:05.840 --> 07:06.840
x

07:06.840 --> 07:07.840
x

07:07.840 --> 07:08.840
x

07:08.840 --> 07:09.840
x

07:09.840 --> 07:10.840
x

07:10.840 --> 07:11.840
x

07:12.840 --> 07:14.840
x

07:14.840 --> 07:16.840
x

07:17.840 --> 07:18.840
2

07:19.840 --> 07:20.840
完了

07:20.840 --> 07:21.840
没了

07:21.840 --> 07:22.840
既然写到工具箱

07:22.840 --> 07:24.840
我们順便把这个东西扔进去吧

07:24.840 --> 07:26.840
把这个东西也扔进去

07:26.840 --> 07:28.760
导致这个地方的单码间接

07:32.840 --> 07:33.840
那么这里呢

07:33.840 --> 07:35.840
就导出一个函数

07:35.840 --> 07:36.800
port default

07:36.800 --> 07:38.840
导出一个函数

07:38.840 --> 07:40.840
把这个

07:40.840 --> 07:42.340
这个剪切一下

07:42.600 --> 07:44.120
好 这边来 导入

07:45.400 --> 07:46.880
不论导出一个函数

07:48.480 --> 07:50.440
这个复制一下 放上来

07:52.980 --> 07:54.900
好了 行了 差不多了

07:54.900 --> 07:56.740
然后这边来 我们导入这个函数

07:56.740 --> 07:57.540
Import

07:57.540 --> 08:00.100
IsPlayObject

08:00.100 --> 08:03.340
就是判断一个东西 是不是一个平面对象的

08:04.460 --> 08:05.460
Utils

08:05.780 --> 08:07.620
IsPlayObject

08:07.620 --> 08:08.460
好

08:08.980 --> 08:09.980
到这个

08:10.500 --> 08:12.500
来了 把这个稍微改造一下

08:12.660 --> 08:15.620
那么现在我们要写这个Combined Reduces 对吧

08:15.620 --> 08:16.780
它的作用就是什么

08:16.780 --> 08:17.980
就是组装

08:18.780 --> 08:20.180
组装Reduces

08:21.100 --> 08:25.460
形成一个完整的

08:26.100 --> 08:29.020
形成一个Reduces 反而回一个Reduces

08:29.860 --> 08:30.620
Reduces

08:31.380 --> 08:33.820
组装Reduces 反而回一个Reduces

08:33.820 --> 08:39.140
然后数据使用一个对象表示

08:39.820 --> 08:41.620
对象的属性名

08:42.220 --> 08:45.620
与传递的参数对象

08:45.860 --> 08:46.980
保持一致

08:47.460 --> 08:48.380
保持一致

08:48.860 --> 08:49.780
就完了 没了

08:50.100 --> 08:51.780
就是Combined Reduces作用

08:51.780 --> 08:53.660
好 咱们边写边说

08:54.940 --> 08:56.900
这里新建一个Combined Reduces

08:57.220 --> 08:57.940
点解释

08:58.660 --> 08:59.780
然后这里导出

09:00.300 --> 09:02.140
导出的话 我们这里也用

09:02.140 --> 09:03.100
Export

09:03.740 --> 09:04.500
Defort

09:04.500 --> 09:05.300
Earth

09:06.300 --> 09:07.420
Combined Reduces

09:07.420 --> 09:07.940
From

09:08.900 --> 09:10.060
Combined Reduces

09:10.580 --> 09:11.740
把默认导出一玩意

09:12.380 --> 09:14.300
好 那么这边到这边来

09:14.300 --> 09:15.180
到这边来

09:15.180 --> 09:17.340
那么这里我们就不再使用Reduces原生的了

09:17.340 --> 09:18.340
我们使用自己的

09:19.140 --> 09:20.380
使用自己的Reduces

09:22.380 --> 09:24.660
从Reduces里面导出Combined Reduces

09:25.180 --> 09:27.260
看一下我们自己的功能能不能实现

09:27.260 --> 09:27.980
当然现在的

09:28.500 --> 09:29.700
现在的肯定是不行的

09:30.620 --> 09:31.060
到这边来

09:31.980 --> 09:33.820
我们这边是不是导出一个啥

09:33.820 --> 09:34.380
导出

09:34.380 --> 09:35.460
哎呀 我吓死我了

09:36.460 --> 09:38.460
导出一个函数

09:38.900 --> 09:39.460
对不对

09:39.460 --> 09:40.620
导出一个函数

09:40.620 --> 09:42.940
这个函数就是Combined Reduces

09:42.940 --> 09:43.980
就导出这个东西

09:44.300 --> 09:45.900
那么这个函数有哪些参数

09:45.900 --> 09:47.700
是不是就是一个Reduces传进去

09:47.700 --> 09:48.620
你看一下这边

09:49.620 --> 09:50.580
看下这边

09:50.580 --> 09:52.340
你看看传的是不是就是个对象

09:52.340 --> 09:52.860
对吧

09:52.860 --> 09:54.220
传的就是一个对象

09:54.660 --> 09:55.340
没问题吧

09:55.340 --> 09:57.100
传的就是这么一个对象

09:57.100 --> 10:00.060
这个对象他把你这边的属性值得到

10:00.060 --> 10:01.900
就是说我给他这么一个东西

10:02.900 --> 10:04.340
我给他这么一个东西

10:06.020 --> 10:06.460
呃

10:07.260 --> 10:09.140
比方说这个我这里给他找的

10:09.140 --> 10:09.900
login user

10:10.500 --> 10:11.540
是一个Reducer对吧

10:11.540 --> 10:12.620
他是一个fn啊

10:12.620 --> 10:13.340
就是个Reducer

10:14.500 --> 10:15.380
啊那么再

10:16.380 --> 10:16.860
再给他

10:17.540 --> 10:18.500
再给他一个就是

10:20.180 --> 10:20.700
users

10:21.300 --> 10:23.180
啊那么fn reducer

10:23.900 --> 10:25.580
那么他返回的是什么了

10:25.580 --> 10:26.540
返回的是对象吗

10:26.540 --> 10:27.220
是不是个对象

10:28.380 --> 10:29.340
返回的是不是个对象

10:30.940 --> 10:32.300
兄弟返回的是不是个对象

10:32.300 --> 10:33.380
返回的不是

10:33.380 --> 10:35.100
返回的是一个Reducer

10:35.660 --> 10:36.900
返回的是一个函数

10:37.740 --> 10:38.740
他返回的结果

10:39.260 --> 10:40.580
这个函数的状态

10:41.060 --> 10:42.460
状态呢是什么

10:42.460 --> 10:43.820
是这个对象的格式

10:43.820 --> 10:45.460
状态是这样的格式

10:45.460 --> 10:46.420
login user

10:46.420 --> 10:47.580
login user

10:47.580 --> 10:49.420
这个login user的状态来自于哪儿了

10:49.420 --> 10:51.180
来自于用这个Reducer来维护

10:51.180 --> 10:51.580
对吧

10:53.140 --> 10:54.580
这是个数据

10:54.580 --> 10:55.380
然后呢

10:55.380 --> 10:56.340
user是呢

10:56.340 --> 10:57.900
用这个Reducer来维护

10:57.900 --> 10:58.380
对吧

10:59.100 --> 11:00.820
还有维护的结果就是一个数据嘛

11:00.820 --> 11:02.620
对吧Reducer他始终返回一个数据

11:03.300 --> 11:03.820
对不对

11:03.820 --> 11:04.660
那么这个状态

11:04.700 --> 11:06.020
有时候返回的结果

11:06.620 --> 11:07.420
返回状态

11:07.420 --> 11:08.100
它是这个

11:08.100 --> 11:09.700
这是Reducer函数它的作用

11:09.700 --> 11:10.820
它就做这件事情

11:10.820 --> 11:11.780
其他没了

11:12.580 --> 11:13.380
看一下吧

11:13.740 --> 11:15.420
始终理解这个结果

11:15.420 --> 11:16.980
你传入的是一个对象

11:17.300 --> 11:18.540
传入的是个对象

11:18.540 --> 11:19.900
那么这个对象呢

11:19.900 --> 11:21.380
返回的是一个什么

11:21.660 --> 11:23.340
返回的是一个状态

11:23.340 --> 11:25.060
返回的是一个函数

11:25.700 --> 11:26.660
Reducer函数

11:26.660 --> 11:28.940
这个函数返回的是一个状态

11:29.380 --> 11:30.220
是这么个意思

11:30.220 --> 11:31.940
一说大哥的结构是这样子

11:31.940 --> 11:33.100
我这里返回的是什么

11:33.100 --> 11:34.500
返回的是一个函数

11:34.540 --> 11:35.580
这个函数表示Reducer

11:35.580 --> 11:36.740
Reducer该怎么写

11:36.940 --> 11:38.300
是不是第一个是State

11:38.300 --> 11:39.580
第二个是Action

11:39.580 --> 11:40.140
对不对

11:42.740 --> 11:43.300
对不对

11:43.300 --> 11:44.140
是不是这样子

11:44.140 --> 11:44.780
对吧

11:44.780 --> 11:46.780
这个Reducer函数

11:46.780 --> 11:48.300
这个Reducer函数

11:48.300 --> 11:54.740
这里返回的是一个Reducer函数

11:56.500 --> 11:57.540
那么这个Reducer函数

11:57.540 --> 11:59.420
就是要加到仓库里面的Reducer函数

11:59.420 --> 11:59.860
对吧

11:59.860 --> 12:00.900
那么这里呢

12:02.620 --> 12:03.980
这里面是不是要返回状态

12:04.500 --> 12:05.540
返回一个状态

12:07.220 --> 12:08.380
返回状态

12:08.580 --> 12:09.700
注意这个逻辑

12:09.700 --> 12:11.140
返回了一个状态的格式

12:11.140 --> 12:11.900
是这种格式

12:11.900 --> 12:12.420
看到没

12:12.420 --> 12:13.300
是这种格式

12:13.300 --> 12:15.620
这种格式表示返回了状态的格式

12:15.620 --> 12:17.540
而不是这个函数返回的格式

12:17.540 --> 12:19.300
这个函数返回的是一个Reducer函数

12:20.380 --> 12:20.700
好

12:20.700 --> 12:21.300
慢慢来吧

12:21.300 --> 12:21.940
第一个

12:22.540 --> 12:23.540
这个函数里边

12:23.540 --> 12:25.180
首先你给我传了一个Reducer函数进来

12:25.180 --> 12:25.620
对不对

12:25.620 --> 12:27.100
那我是不是要验证一下

12:27.380 --> 12:28.060
要不要验证一下

12:28.060 --> 12:28.700
哪里给我

12:28.700 --> 12:29.900
那我完全把他传一些东西

12:29.900 --> 12:31.220
那我怎么想呢

12:31.220 --> 12:31.580
对不对

12:31.580 --> 12:32.580
是不是要验证一下

12:33.380 --> 12:34.260
我们这个写个函数

12:34.980 --> 12:37.180
Validate Reducers

12:39.700 --> 12:40.380
Reducers

12:41.620 --> 12:43.140
那么这里我们就调用这个函数

12:43.260 --> 12:44.580
第一步就是验证

12:44.820 --> 12:46.540
验证你给我传的数据是不是正确的

12:46.780 --> 12:48.260
Validate Reducers

12:49.660 --> 12:51.980
这个代码我可能跟原代码的格式不太一样

12:51.980 --> 12:53.940
但是函计逻辑是完全一样的

12:54.060 --> 12:55.740
验证这个Reducers是不正确的

12:55.820 --> 12:57.060
那么怎么叫正确的呢

12:57.060 --> 12:58.100
首先如果说

12:58.380 --> 13:02.180
如果说你这个Type Reducers

13:02.180 --> 13:03.300
它不是一个对象

13:03.420 --> 13:05.220
那不行

13:05.220 --> 13:06.740
如果说不是一个Object

13:06.740 --> 13:07.620
不是个对象

13:07.620 --> 13:08.740
那么抛出一个错误

13:08.740 --> 13:10.300
New Type Error

13:10.300 --> 13:12.020
表什么内表什么错误呢

13:12.020 --> 13:13.700
就是Reducers

13:14.780 --> 13:18.700
Must be an object

13:20.740 --> 13:21.700
必须是个对象

13:23.020 --> 13:23.340
好

13:23.340 --> 13:24.820
那么如果你是一个对象

13:24.820 --> 13:25.740
还有什么问题呢

13:25.740 --> 13:26.380
你是一个对象

13:26.380 --> 13:27.500
你得是一个平面对象

13:27.500 --> 13:29.620
他这个地方有要求的

13:29.780 --> 13:31.900
他必须要要求你是一个平面对象

13:31.900 --> 13:33.260
也就是说我们可以利用

13:33.580 --> 13:37.020
之前我们写过那个IsPlaneObjects

13:37.020 --> 13:38.340
反复用这个函数

13:38.860 --> 13:41.620
UtilsIsPlaneObjects

13:41.620 --> 13:41.900
好

13:41.900 --> 13:43.900
那么这里呢

13:43.900 --> 13:46.700
我们要判断一下

13:46.700 --> 13:47.740
如果说Type

13:48.780 --> 13:49.740
拜拜

13:49.740 --> 13:52.340
如果说那个不是一个平面对象

13:52.340 --> 13:53.580
IsPlaneObjects

13:53.580 --> 13:54.740
Reducers

13:54.740 --> 13:56.540
如果说你不是一个平面对象

13:56.540 --> 13:57.900
那么我们也要爆出

13:58.740 --> 13:59.700
爆一个错误

13:59.700 --> 14:02.820
就是Reducers must be an PlaneObjects

14:03.340 --> 14:04.820
而PlaneObjects

14:04.820 --> 14:06.300
也要爆一个错误

14:07.300 --> 14:07.620
好

14:07.620 --> 14:09.780
那么这样子验证完了过后

14:09.780 --> 14:11.420
就没了吗

14:11.860 --> 14:13.340
这样子验证完了过后

14:13.340 --> 14:14.300
就没了吗

14:14.300 --> 14:15.220
也不是

14:15.220 --> 14:16.420
还要做一个验证

14:16.420 --> 14:17.620
就是我们之前说的

14:17.620 --> 14:19.620
还要做哪两个验证的

14:19.620 --> 14:22.540
就是先给他传一个Inlet进去

14:22.900 --> 14:24.940
先给他传一个Inlet进去

14:24.940 --> 14:27.220
再给他传一个OnLowIn进去

14:27.220 --> 14:27.780
对吧

14:27.780 --> 14:29.260
传这两个X型进去

14:29.260 --> 14:31.620
看一下他是不是会遇到问题

14:32.340 --> 14:34.620
看一下他会不会反悔OnDefend

14:34.620 --> 14:39.820
验证Reducers的返回结果

14:39.820 --> 14:42.980
是不是OnDefend

14:42.980 --> 14:44.540
如果是OnDefend是要爆错的

14:44.540 --> 14:46.460
因为CombinedReducers

14:46.460 --> 14:48.140
他要求了稍微严格一点

14:48.140 --> 14:49.620
他要求你Reducers里面

14:49.620 --> 14:50.820
不能反悔OnDefend

14:50.820 --> 14:53.020
你的状态始终得有个默认值

14:53.020 --> 14:54.460
哪怕你默认Low都行

14:54.460 --> 14:55.740
都不能反悔OnDefend

14:55.740 --> 14:57.700
那么反悔OnDefend的话

14:57.700 --> 15:00.020
他认为你这里面进行了硬边码

15:00.020 --> 15:00.980
什么叫硬边码

15:01.020 --> 15:02.420
就是说在这里面去判断了

15:02.420 --> 15:03.460
我们刚才写了个

15:03.460 --> 15:06.300
在这里写的

15:06.300 --> 15:08.460
就是你可能进行到这样的判断

15:08.460 --> 15:10.140
判断那个Type值

15:10.140 --> 15:11.980
Type值是一种特殊值

15:11.980 --> 15:13.620
比方说Includes

15:13.620 --> 15:16.100
包含某一个字不错Inlet

15:16.100 --> 15:17.220
如果说初始化的话

15:17.220 --> 15:18.100
干嘛干嘛干嘛

15:18.100 --> 15:19.740
你可能去做这样的判断去了

15:19.740 --> 15:21.780
那么你可能没有考虑到

15:21.780 --> 15:23.460
这些情况都不符合的情况

15:23.460 --> 15:24.100
都不符合

15:24.100 --> 15:25.220
他意识就是说

15:25.220 --> 15:26.260
如果说你这个Type

15:26.260 --> 15:26.900
你不处理

15:26.900 --> 15:27.420
不处理的话

15:27.420 --> 15:28.700
你把原来状态返回

15:28.700 --> 15:29.780
他就是这么个意思

15:29.860 --> 15:30.980
一定要有一个初始值

15:30.980 --> 15:32.300
并且要把原来状态返回

15:32.300 --> 15:33.740
他就是这个意思

15:33.740 --> 15:36.020
所以说他给你处罚两个特殊的X型

15:36.020 --> 15:37.180
看一下验证一下

15:37.180 --> 15:38.380
你一开始

15:38.380 --> 15:39.860
在最开始的时候验证一下

15:39.860 --> 15:41.380
你是不是返回了Undefined

15:41.380 --> 15:43.580
他主要起的目的就是这样子

15:43.580 --> 15:46.980
于是你这个Reducers里边

15:46.980 --> 15:48.580
你不是有很多的

15:51.460 --> 15:54.860
不是说这里有很多的属性吗

15:54.860 --> 15:56.780
我验证一下这里面的属性

15:56.780 --> 15:58.780
因为你给我的是个对象

15:58.860 --> 16:00.660
对象里面有很多属性

16:00.660 --> 16:02.220
我验证一下你的属性

16:03.220 --> 16:03.900
Foenin

16:03.900 --> 16:05.020
key值

16:05.020 --> 16:05.660
循环这个吗

16:05.660 --> 16:06.460
Reducers

16:06.460 --> 16:07.700
循环这个

16:08.460 --> 16:10.660
那么我们来看一下你这个属性

16:10.660 --> 16:11.900
你看一下一个属性

16:11.900 --> 16:13.500
这个属性先拿到

16:13.500 --> 16:14.700
先拿到这个属性

16:16.540 --> 16:18.420
就是Reducers

16:19.420 --> 16:21.820
拿到这个Reducers key

16:23.100 --> 16:25.140
拿到Reducers

16:25.460 --> 16:27.940
那么这里我随便给你触发一个东西

16:27.980 --> 16:29.820
看一下你得到的结果是不是正确了

16:29.820 --> 16:30.780
Reducers

16:30.780 --> 16:31.580
调用这个Reducers

16:31.580 --> 16:32.180
它是个函数

16:32.180 --> 16:32.660
对吧

16:32.660 --> 16:33.380
它有两个坛数

16:33.380 --> 16:34.540
第一个坛数是状态

16:34.540 --> 16:36.180
状态的话我就给你Undefined

16:36.180 --> 16:37.060
啥都不给你

16:37.060 --> 16:38.180
啥都不给你

16:38.180 --> 16:41.380
然后再给你一个特殊的X型

16:41.380 --> 16:43.020
特殊的X型是什么

16:43.020 --> 16:44.900
特殊的X型是一个Type值

16:44.900 --> 16:45.820
Type值

16:45.820 --> 16:46.580
Type值等于什么

16:46.580 --> 16:48.580
我们把个特殊的Type值倒入进来

16:48.580 --> 16:50.140
Type值

16:50.140 --> 16:51.100
from

16:51.580 --> 16:51.940
第二

16:51.940 --> 16:52.620
什么

16:53.980 --> 16:55.140
Utils

16:55.260 --> 16:59.140
叫X型Types

16:59.140 --> 16:59.780
OK

16:59.780 --> 17:01.460
我把这个X型Typesinnet

17:01.460 --> 17:03.020
首先给你传一个innet的进去

17:03.860 --> 17:05.580
就传递一个特殊的Type值

17:06.180 --> 17:10.940
传递一个特殊的Type值

17:10.940 --> 17:11.380
好

17:11.380 --> 17:12.420
那么你会返回一个结果

17:12.420 --> 17:12.700
对吧

17:12.700 --> 17:14.060
我给你一个初始状态

17:14.060 --> 17:14.860
你肯定有默认值

17:15.380 --> 17:16.340
如果你没有默认值

17:16.340 --> 17:17.900
肯定到时候要出问题

17:17.900 --> 17:20.460
反正你总之你不能给我返回一个

17:20.460 --> 17:22.940
不能给我返回一个就是

17:23.940 --> 17:25.500
就是那個undefend

17:25.500 --> 17:27.100
如果说你给我返回了

17:28.300 --> 17:29.380
undefend

17:29.380 --> 17:30.540
那怎么办呢

17:30.540 --> 17:31.140
那怎么办呢

17:31.140 --> 17:32.580
我给你报仇

17:32.580 --> 17:33.900
他就做了这么一件事情

17:33.900 --> 17:34.540
当然代码的

17:34.540 --> 17:36.300
还有原式的代码不是我这样写的

17:36.300 --> 17:37.220
但是是类似的

17:37.220 --> 17:38.180
逻辑是一样的

17:39.180 --> 17:40.940
那么这里的保存是什么了

17:40.940 --> 17:42.740
就是reduce

17:44.740 --> 17:47.020
must not return

17:49.700 --> 17:50.660
undefend

17:52.790 --> 17:54.030
return undefend

17:55.310 --> 17:56.990
不能返回undefend

17:58.510 --> 18:00.750
那如果说你这里通过了

18:00.750 --> 18:01.670
这里没有报仇

18:01.670 --> 18:03.110
报仇肯定是函数结束了

18:03.110 --> 18:04.910
如果说你这里通过了

18:04.910 --> 18:06.150
那么我们继续来

18:06.150 --> 18:06.910
还没完

18:06.910 --> 18:07.910
还没完

18:07.910 --> 18:09.550
那么我们现在继续来

18:10.310 --> 18:11.830
我又给你触发一次

18:11.830 --> 18:12.910
那么这一次的内形

18:12.910 --> 18:15.030
是什么unlearn这个内形

18:15.870 --> 18:17.550
万一你在里边给我写了什么

18:17.550 --> 18:18.190
银列车

18:18.190 --> 18:19.430
就判断了是不是银列车

18:19.430 --> 18:20.430
银列车做什么事情

18:20.430 --> 18:21.710
其他的地方又无关了

18:21.710 --> 18:23.830
那我给你换一个x型

18:23.870 --> 18:24.590
特殊的x型

18:24.590 --> 18:26.230
再看一下你是不是undefend

18:26.230 --> 18:27.990
它一开始就做了这么两件事

18:29.390 --> 18:30.790
那么又跑出错误

18:33.470 --> 18:33.950
完了

18:33.950 --> 18:35.550
它就给你写了这么一个东西

18:36.070 --> 18:37.150
当然你这个东西

18:37.150 --> 18:38.750
如果说我们自己写的话

18:38.750 --> 18:39.870
你可以不用写这个东西

18:40.390 --> 18:42.270
因为我们自己写单

18:42.270 --> 18:44.590
reduce是按照严格按照标准来做的

18:44.590 --> 18:46.390
不会去给你返回undefend的

18:46.390 --> 18:48.270
如果说内形不笔配

18:48.270 --> 18:50.270
正确的做法就是应该把数据

18:50.270 --> 18:51.230
原封不动的返回

18:51.230 --> 18:52.470
并且还有默认识

18:53.430 --> 18:55.310
就是做了这么两个验证

18:55.310 --> 18:56.230
就是做了两个验证

18:56.230 --> 18:57.950
所以说那些这些函数里边

18:57.950 --> 18:59.270
我说为什么能够得到

18:59.270 --> 19:01.830
就是能够得到这两个x型的

19:01.830 --> 19:03.510
是因为它这里手动触发了一下

19:03.510 --> 19:05.110
手动调整了一下reducer

19:06.430 --> 19:07.470
那么这里是验证

19:07.470 --> 19:09.070
那么只要这个函数它没有爆错

19:09.070 --> 19:10.110
说明就验证通过了

19:10.110 --> 19:11.470
爆出它自然不会运行的

19:11.470 --> 19:12.950
所以说我们一开始验证一下

19:12.950 --> 19:14.070
这个reducer

19:14.070 --> 19:15.630
验证通过过后

19:15.630 --> 19:17.430
我们就返回我们自己的reducer

19:18.150 --> 19:19.270
我们自己的reducer

19:19.270 --> 19:20.470
这个状态的默认值是啥

19:20.470 --> 19:21.430
你看状态

19:21.510 --> 19:22.430
是不是一个对象

19:23.670 --> 19:25.430
现在我们进入这个reducer函数了

19:25.430 --> 19:27.230
现在我们进入这个reducer函数了

19:27.230 --> 19:28.790
那么这个reducer函数不是一个状态吗

19:28.790 --> 19:29.790
状态是不是一个对象

19:29.790 --> 19:30.470
对不对

19:30.470 --> 19:30.870
OK

19:30.870 --> 19:31.950
那么我们给它一个默认值

19:32.630 --> 19:34.150
这状态就是一个对象

19:34.150 --> 19:34.870
就是一个对象

19:36.110 --> 19:37.150
没问题吧

19:37.150 --> 19:38.350
状态就是个对象

19:38.350 --> 19:41.470
那么对象里边有哪些属性呢

19:41.470 --> 19:43.190
就是我们最终要返回一个新的状态

19:43.870 --> 19:44.470
new state

19:46.510 --> 19:47.990
最终我们要返回一个新的状态

19:49.790 --> 19:53.490
这是新的状态

19:53.490 --> 19:56.730
要返回的新的状态

19:56.730 --> 19:57.810
这是我们旧的状态

19:57.810 --> 19:58.410
对吧

19:58.410 --> 20:00.290
上面我们函数是我们旧的状态

20:00.290 --> 20:01.250
那如果说一开始

20:01.250 --> 20:02.090
函数没有指的时候

20:02.090 --> 20:03.690
我们默认就是一个空对象

20:03.690 --> 20:05.810
这是我们要返回的新的状态

20:05.810 --> 20:06.250
那行呗

20:07.530 --> 20:08.290
来吧

20:08.290 --> 20:10.170
那我这里要干嘛呢

20:10.170 --> 20:12.250
我这里要做的事情就是

20:12.250 --> 20:13.730
我现在拿到的是这个对象

20:13.730 --> 20:14.330
这个对象在哪

20:14.330 --> 20:15.610
是不是reducer里边

20:15.610 --> 20:15.810
对吧

20:15.810 --> 20:16.810
在这里边

20:16.810 --> 20:17.410
对吧

20:17.410 --> 20:17.650
好

20:17.650 --> 20:18.890
我们拿到的是这个对象

20:18.890 --> 20:19.290
OK

20:19.290 --> 20:20.890
我们现在把这个对象的

20:20.890 --> 20:22.850
得到一个新的状态

20:23.050 --> 20:24.570
新的状态返回

20:24.570 --> 20:26.250
这个状态里边每一个属性的值

20:26.250 --> 20:28.770
来自于它对应的reducer调用的结果

20:28.770 --> 20:30.290
你看这个罗金优热的属性值

20:30.290 --> 20:31.930
来自于这个reducer调用的结果

20:31.930 --> 20:32.850
这个优热的属性值

20:32.850 --> 20:34.250
来自于这个reducer调用的结果

20:34.250 --> 20:35.890
我们就要做这么一件事

20:35.890 --> 20:37.770
所以说这里是不是还是要否硬循环

20:37.770 --> 20:38.050
对吧

20:38.050 --> 20:38.530
循环啥

20:38.530 --> 20:39.130
reducer

20:40.490 --> 20:40.890
循环啥

20:40.890 --> 20:41.530
循环这个对象

20:42.730 --> 20:44.490
每一循环一个这个对象过后

20:44.490 --> 20:46.090
我们是不是要拿到他的reducer

20:46.090 --> 20:46.690
对吧

20:46.690 --> 20:48.330
reducer

20:48.330 --> 20:50.210
拿到他的reducer

20:50.210 --> 20:52.010
拿到这个reducer之后

20:52.050 --> 20:53.210
那么我们干嘛

20:53.210 --> 20:56.210
我们是不是要去调用这个reducer

20:56.210 --> 20:58.010
拿到他返回的状态

20:58.010 --> 20:58.370
对吧

20:58.370 --> 20:59.050
比方罗金优热

20:59.050 --> 21:00.690
他的reducer是不是返回个状态

21:00.690 --> 21:03.690
我们把它复制到同名的属性里边

21:03.690 --> 21:05.210
所以说我们这里复制怎么复制

21:05.210 --> 21:06.290
new state

21:06.290 --> 21:07.170
t

21:07.170 --> 21:08.250
同名的属性

21:08.250 --> 21:09.170
给它复制为什么

21:09.170 --> 21:10.490
调用这个reducer

21:10.490 --> 21:11.690
把什么传进去

21:11.690 --> 21:13.850
你给我的state

21:13.850 --> 21:15.130
当然不是整个传递

21:15.130 --> 21:16.050
不是整个传递

21:16.050 --> 21:18.050
是把他内部份传递

21:18.050 --> 21:19.170
就是把这个罗金优热

21:19.170 --> 21:19.810
就状态里边

21:19.810 --> 21:21.810
之前的罗金优热传进去

21:21.810 --> 21:23.290
之前的状态里边

21:23.290 --> 21:24.010
罗金优热

21:24.010 --> 21:25.410
是不是可以用这种方式来获取

21:25.410 --> 21:25.810
t

21:25.810 --> 21:27.370
对吧

21:27.370 --> 21:28.450
对不对

21:28.450 --> 21:29.650
这个t值你看一下

21:29.650 --> 21:30.690
这个循环的是他

21:30.690 --> 21:30.930
对吧

21:30.930 --> 21:31.850
循环到他

21:31.850 --> 21:34.370
那么我们就把原来的状态里边的

21:34.370 --> 21:35.810
罗金优热这个值

21:35.810 --> 21:36.730
这个数据

21:36.730 --> 21:39.250
把这个数据给你传进去

21:39.250 --> 21:41.490
然后再把I个型给你传进去

21:41.490 --> 21:43.450
然后你会是不是会返回一个新的数据

21:43.450 --> 21:43.810
好吧

21:43.810 --> 21:46.530
新的数据保存到这个属性里边

21:46.530 --> 21:47.490
梳理一下

21:47.490 --> 21:47.970
你看

21:47.970 --> 21:49.210
这是我们新的状态

21:49.210 --> 21:50.250
这个new state是啥

21:50.250 --> 21:50.970
这个new state

21:51.010 --> 21:52.770
就是整个这个对象

21:52.770 --> 21:53.690
给它加属性

21:53.690 --> 21:53.970
对吧

21:53.970 --> 21:55.130
给它加属性

21:55.130 --> 21:55.330
好

21:55.330 --> 21:57.290
那么这个t值是不是对应到这

21:57.290 --> 21:58.010
你看

21:58.010 --> 21:59.410
我们一开始试一个

21:59.410 --> 22:00.970
这是比方说

22:00.970 --> 22:02.290
我们旧的状态是这样子

22:02.290 --> 22:04.170
旧的状态是我们之前生存的

22:04.170 --> 22:05.890
生存的旧的状态

22:05.890 --> 22:08.050
罗金优热旧的状态

22:08.050 --> 22:09.370
比方说

22:09.370 --> 22:10.970
随便写吧

22:10.970 --> 22:12.570
那么这里就是

22:12.570 --> 22:13.890
优热是一个数据

22:13.890 --> 22:14.570
对吧

22:14.570 --> 22:15.610
随便写

22:15.610 --> 22:15.770
好

22:15.770 --> 22:17.290
那么现在返回新的状态

22:17.290 --> 22:18.650
我们现在拿到的是一个空对象

22:18.650 --> 22:18.890
对吧

22:18.890 --> 22:19.850
一个空对象

22:19.890 --> 22:21.490
那么空对象的第一个循环

22:21.490 --> 22:22.370
再循环

22:22.370 --> 22:23.610
空对象的这个属性

22:23.610 --> 22:24.330
罗金优热

22:24.330 --> 22:25.330
为什么是罗金优热

22:25.330 --> 22:26.050
因为我们循环了

22:26.050 --> 22:27.130
是上面那个对象

22:28.410 --> 22:29.610
循环的是上面那个对象

22:29.610 --> 22:29.810
对吧

22:29.810 --> 22:30.770
把上面那个属性远

22:30.770 --> 22:31.530
作为它的属性远

22:31.530 --> 22:32.210
罗金优热

22:32.210 --> 22:33.570
它的值是什么呢

22:33.570 --> 22:35.490
值是不是调用这个reducer

22:35.490 --> 22:38.930
把之前那个状态里面的对应的key值

22:38.930 --> 22:40.330
是不是把这个东西传进去

22:40.330 --> 22:41.490
传到reducer里面去

22:41.490 --> 22:42.650
然后再把x传进去

22:42.650 --> 22:44.210
它是不是会返回一个数据

22:44.210 --> 22:46.490
把这个返回的数据当作它的属性值

22:46.490 --> 22:48.450
是这么个意思

22:48.450 --> 22:50.890
那有时候说它第一次的状态是哪来的呢

22:50.890 --> 22:52.570
第一次

22:52.570 --> 22:53.730
你想想第一次哪来的

22:53.730 --> 22:54.770
那第一次我们

22:54.770 --> 22:56.610
第一次是不是这里啥都没有

22:56.610 --> 22:56.810
对吧

22:56.810 --> 22:58.050
状态里面是空的

22:58.050 --> 22:59.650
那传递过去

22:59.650 --> 23:00.490
罗金优热的传递过去

23:00.490 --> 23:01.370
是on the fact

23:01.370 --> 23:02.850
on the fact它是不是有出值

23:02.850 --> 23:04.130
它返回的是不是一定有值

23:04.130 --> 23:05.050
它一定不是on the fact

23:05.050 --> 23:06.290
因为前面我们验证过的

23:06.290 --> 23:07.930
对吧

23:07.930 --> 23:08.490
是这么个意思

23:10.490 --> 23:11.930
那么这里reducer传进去

23:11.930 --> 23:12.370
就完了

23:12.370 --> 23:13.170
没了

23:13.170 --> 23:15.570
最后我们把新的状态返回

23:15.570 --> 23:19.370
这就是comband reducer的写法

23:19.370 --> 23:19.970
对吧

23:19.970 --> 23:20.650
就这么简单

23:20.650 --> 23:21.930
多了一些验证而已

23:21.930 --> 23:24.290
多了一些验证而已

23:24.290 --> 23:25.570
非常简单

23:25.570 --> 23:25.970
保存

23:25.970 --> 23:28.770
咱们来看一下吧

23:28.770 --> 23:29.170
你看一下

23:29.170 --> 23:30.010
是不是仍然可以

23:30.010 --> 23:30.650
对吧

23:30.650 --> 23:31.890
comband reducer是过后了

23:31.890 --> 23:33.130
它是不是仍然可以使用

23:33.130 --> 23:33.370
对吧

23:33.370 --> 23:35.330
现在我们已经用的是自己的了

23:35.330 --> 23:36.250
看一下吧

23:36.250 --> 23:38.930
已经用的是自己的了

23:38.930 --> 23:42.090
并且如果说我们在这里打印出Type值的话

23:42.090 --> 23:45.830
我们会发现跟之前一样了

23:45.830 --> 23:47.030
Type值打印一下

23:47.830 --> 23:48.750
那你会发现

23:48.750 --> 23:50.150
是不是跟之前一样了

23:50.150 --> 23:52.310
对吧

23:52.310 --> 23:53.430
这就这么简单

23:53.430 --> 23:55.670
comband reducer

23:55.670 --> 23:56.870
下来还是一样的

23:56.870 --> 23:58.390
把它写一次

23:58.390 --> 24:00.950
那么至此我们学过的Redux的知识

24:00.950 --> 24:02.430
我们都用原代码实现了一次

24:02.430 --> 24:04.110
你会发现其实一点都不复杂

24:04.110 --> 24:07.070
很简单的

24:07.070 --> 24:09.190
那么接下来Redux

24:09.190 --> 24:09.830
还有一些东西

24:09.830 --> 24:11.470
就是还有一个点

24:11.470 --> 24:13.030
就是中间键了

24:13.030 --> 24:14.230
咱们从下一个开始

24:14.230 --> 24:15.590
开始来详细讲解中间键

