WEBVTT

00:00.180 --> 00:07.780
来吧 下一个组件 下一个组件呢是实现这个switch

00:08.420 --> 00:13.220
啊switch 这个组件 积极吧 积一下吧啊switch

00:15.390 --> 00:20.990
switch 组件 啊那个switch 组件呢 我们来先看一下它的啊 先看一下它的

00:21.390 --> 00:26.910
那功能呢 我都没啥说的了啊 功能大家都知道啊 他做什么事情的 我们主要是看一下他的啊

00:27.790 --> 00:35.390
这边呢 我们就直接写两个页面得了啊 直接写两个页面啊 就完事了啊 直接写两个页面完事

00:36.110 --> 00:46.590
好吧 咱们直接写这两个页面配级一配级二 然后就行了吧啊 然后呢 外面给他套上一个switch

00:47.550 --> 00:51.710
switch 组件啊 这是他自己的rex rotor dome啊 就是

00:52.430 --> 00:56.750
呃 官方的裤啊 咱们在外面呢 掏一个switch

01:01.470 --> 01:08.990
掏一个switch 把这个放进去啊 掏了一个switch之后呢 咱们来看一下吧 看一下页面上啊

01:10.190 --> 01:13.230
我们访问配级一啊 比方说啊 我们访问配级一

01:13.870 --> 01:21.390
保存配级一呢 他只显示配级一啊 就甭他只匹配到一个啊 另一个不管怎么样啊 他就不管了啊 比方另一个啊 就是

01:22.590 --> 01:28.830
比方说吧 我们就随便举个例子啊 另一个是配级一配级二 他就不管了啊 他就不管了 你看只匹配到配级一

01:29.150 --> 01:35.550
就匹配到一个他就结束了啊 就不再匹配了啊 就这么个意思啊 咱们点击右键检查 主要是看他的

01:36.350 --> 01:39.550
主键结构啊 看他声认出来的主键结构大概是什么样子

01:40.030 --> 01:49.390
因为发现了 就是掏了一个switch之后呢switch里边呢 他应用到了上下文 他肯定使用到了上下文里边的东西啊 他用到了上下文里边的东西

01:50.030 --> 01:56.990
呃 也就是他这里的一个像上下文的消费者对吧 呃 然后呢 里边他只显示了匹配的这个肉车出现

01:57.310 --> 02:04.830
没有匹配的他就没有显示了 这跟我们之前没有使用switch的就不太一样 比方说我们没有使用switch的时候呢 你看一下啊

02:06.430 --> 02:08.910
没有使用switch的时候呢 下面啊

02:10.510 --> 02:16.430
他是不是有两个 对吧 这一个啊 这一个对不对 是不是有两个 哎 他有两个 那么

02:17.230 --> 02:26.030
只是呢 一个显示了 一个没显示啊 但是两个肉车主键是出来的 对吧 两个肉车主键是出来的 没问题吧啊 所以说呢

02:27.150 --> 02:35.070
你用了switch之后呢 他的区别就在于他匹配到了过后呢 连肉车主键都不出现了啊 连这个肉车主键都不出现了

02:35.390 --> 02:41.470
啊 就这么个区别 好 所以说switch的功能啊 我们可以简单的记一笔啊 他的功能是什么呢

02:42.430 --> 02:43.950
嗯 他的功能呢 就是

02:45.390 --> 02:47.710
匹配啊 匹配就是

02:49.630 --> 02:52.190
指援数啊 就是肉车指援数

02:54.430 --> 03:01.310
指援数 因为我们可以switch传递的呢 都是肉车 对吧 他的指援数都是肉车 那么他匹配肉车指援数

03:01.870 --> 03:03.710
呃匹配的结果啊

03:04.590 --> 03:07.790
然后就是匹配数的指援数啊

03:08.830 --> 03:10.510
将渲染

03:11.310 --> 03:12.750
第一个匹配

03:13.390 --> 03:15.870
到的肉 这他的功能

03:16.670 --> 03:23.070
那么基于这个功能呢 我们要去实现这个switch主键 其实呢失诺了就很容易出来了

03:23.470 --> 03:26.670
什么样的失诺呢 实现的switch主键啊

03:27.390 --> 03:34.990
就做什么事情呢 就是循环 因为switch他不是给他一个qt嘛 对吧 这些东西都是给switch的qt

03:35.630 --> 03:37.070
循环switch

03:37.870 --> 03:38.270
啊

03:39.150 --> 03:40.670
主键的qt

03:41.390 --> 03:42.270
循环的qt

03:43.070 --> 03:44.030
呃一次

03:44.910 --> 03:46.990
找到啊 一次匹配

03:47.710 --> 03:49.310
每一个肉

03:49.630 --> 03:50.110
主键

03:50.670 --> 03:55.790
啊 所以说switch这个主键他有一个特殊要求 他里边呢必须要是肉车这个主键

03:56.110 --> 04:01.710
啊 如果说你开了一个p元数在这里 那就不行了啊 他的指援数必须要是肉车主键 因为他会去循环

04:01.950 --> 04:03.710
一是匹配每一个肉车主键

04:04.190 --> 04:06.270
当匹配到啊 匹配到时

04:07.310 --> 04:08.830
啊 直接旋了

04:09.550 --> 04:11.710
啊 而不再停滞循环

04:12.670 --> 04:15.150
对吧 就做得很简单啊 就做得很简单

04:15.470 --> 04:16.910
这是switch的核心原理

04:17.390 --> 04:23.710
啊 那么基于这样的原理呢 我们写这么一个switch主键啊 还是同样的这个switch主键呢 他属于rex rotor里边的东西

04:24.030 --> 04:25.950
啊 咱们新建一个啊switch主键

04:28.240 --> 04:29.280
他是一个核心功能嘛

04:29.760 --> 04:33.680
好 咱们呢 这里呢 写上这么一个内主键啊 写上那么一个内主键

04:34.240 --> 04:40.800
啊 名字叫switch 那么同样的同样的方式呢 我们在index.js里边 把导出啊 把导出

04:41.440 --> 04:43.280
导出一个就是switch

04:44.400 --> 04:45.520
啊 这里呢switch

04:46.080 --> 04:46.560
switch

04:48.400 --> 04:53.840
好 然后呢 同样的在rex rotor动里面呢 再把重新导出啊 再把重新导出

04:55.760 --> 05:01.440
导出那个rex rotor里边的这个啊 直接在这里重新导出啊switch

05:02.560 --> 05:03.520
重新导出就完事了

05:04.640 --> 05:09.120
好 然后这个switch主键里边啊 我们在这里啊 在这里就直接

05:09.760 --> 05:11.760
直接使用这个了啊 第二階段

05:12.400 --> 05:14.400
就这样 就用我们自己的rex rotor动

05:15.120 --> 05:17.600
好 然后现在我们来实现这个switch主键啊

05:18.160 --> 05:20.320
这个主键里面渲染的时候 是不是要

05:21.040 --> 05:28.080
呃 我们先不说要不要 要不要用到张下文嘛 我们先说循环求菌来进行匹配这个问题 对吧

05:28.560 --> 05:30.960
也就是说我们这里呢 可以写个函数 比方说

05:32.320 --> 05:35.600
get march uh child

05:36.480 --> 05:38.880
啊 写这么一个函数 这个函数的作用是什么呢

05:39.440 --> 05:41.600
打个注释啊 该函数的作用就是

05:42.720 --> 05:45.280
呃 循环 循环求菌

05:46.320 --> 05:49.680
得到什么呢 得到那个匹配的

05:50.480 --> 05:52.400
就是得到第一个匹配的

05:53.520 --> 05:54.400
弱彻主键

05:55.280 --> 05:57.200
若没有匹配

05:57.920 --> 05:59.040
则反悔烙

05:59.600 --> 06:05.040
啊 是反悔烙 那么假设这个函数已经写好了啊 那么假设这个函数已经写好了

06:05.680 --> 06:08.560
事情就变得很简单了啊 怎么做呢

06:09.120 --> 06:11.280
如果这个函数写好了 那么这里Render了是不是 就是

06:12.000 --> 06:16.080
this get march child对吧 都完了对不对

06:17.040 --> 06:19.200
是不是就完了 哎 我们这里只要

06:20.400 --> 06:24.240
调用这个方法 把这个方法的返回结果啊 血染出来就完事了

06:24.480 --> 06:29.520
说这个方法它能做的事情就是循环求菌 那么得到一个匹配的主键啊 那么就返回

06:30.560 --> 06:32.160
好 那么这个方法怎么写呢

06:33.200 --> 06:36.000
这个方法怎么写呢 你是不是在循环啊

06:36.640 --> 06:41.760
是不是在循环求菌 对吧 ok 那咱们呢 就循环那个求菌啊 for of

06:42.640 --> 06:44.400
循环那个求菌啊 child

06:45.040 --> 06:49.520
循环这个啊什么 uh this props their children 循环一个求菌

06:49.680 --> 06:54.240
但是那个求菌呢 他就要求他必须是一个宿主啊 他必须是一个宿主

06:54.240 --> 06:58.800
那有没有可能求菌他不是宿主呢 有没有可能呢 他有 他是有可能的

06:59.200 --> 07:04.960
比方说什么情况下 看着啊 那你不能让他爆出了吧 这里 我们这里输出啊 输出这个求菌

07:05.760 --> 07:08.640
this props children 好 保存啊

07:10.240 --> 07:14.800
嗯 咱们呢 在这边来 这个先去掉吧 免得他爆这个警告

07:16.560 --> 07:19.360
好 app 这里你看一下 swiss 都给他求菌的 对吧

07:19.520 --> 07:26.800
好咱们打印出 哎 nothing was returned 啊他都没返回东西啊 我们先返回那我嘛 先返回那

07:28.560 --> 07:33.280
好 那么现在是不是得到一个宿主 对吧 你是不是给了他两个元素啊 两个人

07:33.760 --> 07:38.880
就是rex元素对吧 两个肉球元素啊rex元素啊 你看没 对吧

07:39.920 --> 07:45.520
没问题吧 那么你这里给了他一个宿主 那如果说他这这宿主真真真真是正常的情况

07:46.000 --> 07:52.000
那如果说我给只给了一个 哎 只给一个是不是可以 对吧 是不是可以只给一个对不对

07:52.320 --> 07:57.840
那怎么不能只给一个了 那么只给一个的情况下 你看他的气候去是不是就不是宿主了

07:58.800 --> 08:05.520
你看没 他就是一个单个对象了 看到没 这是他就是rex element啊 就是通过那个rex

08:06.400 --> 08:12.400
create element他的那种处理方式 如果说你气候存了 只给了他一个有单个对象的话就变成这个样子了

08:12.560 --> 08:18.800
啊 就是jsx里面 你给他单个对象 那么他就只是单个对象 他不是宿主啊 你看他就变成单个对象了

08:19.040 --> 08:25.280
那单个对象我们是不是也在判断 对不对 也在正常处理啊 还有这种情况就是你没有给他气候去

08:26.160 --> 08:28.640
啊 你没有给他气候去 那么是不是undefend

08:29.120 --> 08:34.400
对吧 是undefend 他就没有气候去嘛 啊 没有去哪怕你都换多行 他还是undefend

08:34.720 --> 08:40.880
对吧 他没有气候去 所以说这种情况啊 我们都得把它考虑进去啊 都要把它考虑到

08:41.680 --> 08:44.800
啊 于是呢 我们要考虑这些问题啊 所以说到这边来

08:45.840 --> 08:49.360
你这个气候准是不是有多种情况 那么我们这样子

08:50.080 --> 08:56.160
这样子吧 就是说 如果你给我传的气候准是undefend呢 我就给一个空数组啊 我就循环一个空数组

08:56.400 --> 09:01.520
对吧 我们把它做成一个统一的情况来处理 这也是在软件开发过程中的一种常见方案啊

09:01.760 --> 09:04.560
你有多种情况的时候呢 我们把它变成一种统一的情况

09:04.880 --> 09:12.720
不要 你没有传气候准 那我给你一个空数组 如果你只传了一个气候准啊 有单个对象 我就把你变成一个数组里边有单个对象

09:12.960 --> 09:16.960
对吧 那如果你传的是一个正常的气候准 那我就循环正常的气候准

09:17.360 --> 09:22.720
因此这种处理呢 我们可以可以那个在这里在这里进行判断

09:23.680 --> 09:27.840
啊 在这里进行判断 如果说this props their children

09:28.800 --> 09:30.480
啊 等于呢 怎么undefend

09:31.200 --> 09:36.480
啊 你没给我传 没给我传气候准 OK 那我这里定个变量啊 定个变量气候准

09:38.000 --> 09:43.040
啊 我们首先让他等于一个空 空对象啊 一个空数组啊 一个空数组

09:43.840 --> 09:47.920
好 那么如果说你这种情况是不处理 对吧 就让他保持空数组就完事了

09:48.400 --> 09:52.880
好 如果说 如果说你这个气候准的是一个数组啊

09:53.520 --> 09:55.600
我们用而为啊 意思而为

09:56.160 --> 10:02.960
如果你传的气候准啊 this props their children 是一个数组 那么我们就把这个气候准重新复制为

10:04.160 --> 10:05.120
this props children

10:06.320 --> 10:10.720
好 如果说你给我传的他不是数组啊 不是数组

10:11.120 --> 10:11.520
气候准

10:12.640 --> 10:16.960
啊 当然了 你要排除掉那种空的情况啊 你要排除掉空的情况

10:17.520 --> 10:21.120
啊 就是你给我传的那个气候准呢 是一个对象啊 是一个对象

10:23.200 --> 10:24.000
lcf

10:24.480 --> 10:26.960
啊 就是啊 type of

10:28.000 --> 10:31.280
this props their children 是一个对象

10:32.320 --> 10:32.880
object

10:33.520 --> 10:37.120
啊 那么如果你是个对象的话 ok 那么我就

10:37.840 --> 10:45.120
把这个气候准里面 铺洗一下啊 铺洗一下啊 因为是数组吗 加一项 加什么呢 加this props their children

10:45.760 --> 10:51.760
这就处理了那个什么单个的情况啊 处理了单个的情况 或者说我们这里直接重新复制这样的复制

10:52.320 --> 10:53.040
啊 这样的复制

10:53.840 --> 11:00.640
啊 我们怎么复制呢 就是把这个this props children 直接放进来 对吧 数组里面就只有一项啊 就只有一项

11:01.200 --> 11:08.400
啊 咱们把这个各种情况处理一下 如果你是一个数组 那我就直接用你啊 如果你不是数组啊 你是个对象 那我就直接处理

11:09.040 --> 11:12.960
就把你当成单个对象来处理 那如果你是其他情况的话 那我就直接

11:13.520 --> 11:18.640
是一个空数组啊 其他情况就是直接是个空数组啊 把这个问题处理一下 那么处理之后呢

11:19.040 --> 11:20.960
咱们带来打印出这个气候准啊

11:21.360 --> 11:27.920
来看一下吧 那么这样子的格式又统一了啊 你看一下单个对象的时候呢 你看他还是放到数组里边了 你看呗

11:28.960 --> 11:34.080
单个对象的时候放到数组里边了 多个对象呢 他就是那个没什么问题啊 就是两个对不对

11:35.120 --> 11:41.920
哎 就就这么个意思啊 就这么个意思啊 那么就是个水水是不搞定的啊 这里呢 我们给了两个配几亿啊 也就是说

11:42.160 --> 11:48.080
按理说呢 两个都要渲染啊 但是加了水一起过分了 肯定只能渲染一个啊 只能渲染一个 我们把配几个先注射掉

11:50.320 --> 11:56.080
好 那么回到这边来 现在我们是不是可以循环数组了 他怎么样他都是个数组 对吧 是不是可以循环数组了

11:56.720 --> 12:02.560
好 循环数的时候每一次循环是不是可以拿到一个敲的 对吧 啊 拿到一个敲的

12:03.440 --> 12:15.360
看一下啊 那么关键是我们现在要干嘛 是不是要判断啊 判断该指援数是否能够啊 是否能够就是匹配对不对

12:16.160 --> 12:25.120
啊 是吧 判断个指援数是否能够匹配 我们现在拿到的是一个指援数的对象啊 拿到的是一个 这里要喜欢这个啊 喜欢求质

12:26.320 --> 12:31.440
啊 这里要拿到的是一个一个一个的指援数对象 那么我们怎么来根据这个指援数对象

12:32.240 --> 12:35.200
能够判断他是否能匹配呢 怎么来判断了

12:36.160 --> 12:44.270
嗯 那么我们来看一下这个对象 这个对象里边呢 有这么一个啊 就是啊

12:44.910 --> 12:48.510
就是这个probs啊 有这么一个probs

12:49.790 --> 12:56.110
probs呢 里边呢 是不是给了一些什么pass啊 这些属性对吧 还有可能给什么呢 还有可能给那个就是啊

12:57.070 --> 12:57.470
啊

12:58.430 --> 13:03.150
那个一个rex呀 strix呀这些属性 是不是都可能给他对不对 都可能给他

13:03.710 --> 13:07.550
好 那么也就是说呢 我们可以通过这个rex element

13:08.430 --> 13:13.150
是不是就可以拿到拿到啥 是不是可以拿到他的里边那些配置的属性

13:14.110 --> 13:20.910
哎 拿到了这些配置的属性之后 是不是又可以去调用那个march pass这个函数来

13:21.550 --> 13:29.150
来知道是不是匹配了 对吧 来确定是不是匹配 是这个意思吧 我们又可以调用这个函数来确定是否匹配了

13:29.790 --> 13:33.470
所以说呢 我们这一块啊 在这一块

13:35.230 --> 13:42.190
我们就要通过这个child 什么拿到他的一些属性什么pass属性啊 对吧 还有什么其他的属性对不对

13:42.670 --> 13:50.750
好 那么这里呢 咱们拿到啊 拿到这个child里边的属性 这个child的属性怎么拿 是不是这个child里边props里边是可以拿到这些属性对吧

13:51.310 --> 13:56.590
啊 我们只关心什么pass啊一个rex啊strict啊神圣庭谱这些属性啊 只关心这些属性

13:57.070 --> 13:59.630
好 那么我们这里去拿拿这个属性

14:01.310 --> 14:03.150
哪些属性呢 我们要去拿pass

14:04.030 --> 14:07.150
要去要去拿那个就是一个rex

14:08.190 --> 14:08.990
啊一个rex

14:09.710 --> 14:11.950
呃 要去拿什么strict

14:12.590 --> 14:21.870
要去拿sensity 对吧 要去拿这些属性 从哪里拿 从child props里边去解构啊 解构出这些属性 其他的我都不需要 我只需要这些属性

14:22.990 --> 14:27.310
因为这些属性呢 决定了我要判断你是否能够去匹配啊

14:28.430 --> 14:29.390
作为判断的基础

14:29.950 --> 14:36.590
所以说呢 我们需要把这些属性呢 全部拿到啊 全部拿到 当然这里呢 有些地方可以给默认值啊 可以给默认值

14:36.830 --> 14:42.990
如果你pass没有值 pass没有值始终是能匹配的 我就给一个写杠啊 一个rex呢 我给一个默认值 比方说force

14:44.190 --> 14:49.870
不精确匹配 那么这些都是不不严格啊 不区分大小写给他默认值嘛 对吧

14:50.910 --> 14:54.670
啊 那做法呢 跟那个肉手里边就是匹配是类似的

14:55.630 --> 14:59.790
啊 当然你可以把这一块呢抽象出来一个公共的模块来搞定这件事情

15:00.430 --> 15:05.070
好 那么这里呢 把这些数据拿到过后 是不是可以导入啊 我们导入那个就是

15:06.030 --> 15:06.670
啊 march

15:08.590 --> 15:09.470
导入那个什么

15:10.750 --> 15:15.390
merge pass from from 点儿写到 march pass

15:16.030 --> 15:19.310
好 那么那么我们这里可以是不可以通过方法 march pass

15:19.870 --> 15:22.190
啊 我的路径规则给你

15:23.310 --> 15:29.710
好 那么第二个参数 先打个问号来这里 第三个参数是配置 配置很简单 我们就给给个对象一个rex

15:30.510 --> 15:36.510
strgth 啊 还有个什么sensitive 对吧 把对象给你 你会给我返回一个匹配结果

15:37.630 --> 15:41.390
啊 你会给我一个返回那个匹配结果 好 那么这里呢

15:42.670 --> 15:43.870
march pass里边

15:44.590 --> 15:50.270
这个参数啊 这个就是 这是路径规则 那么这个地方是不是要填目前的路径啊

15:50.990 --> 15:54.030
是不是要从location里边去取出passname

15:54.830 --> 15:58.430
对不对 好 那么这里问题是这里怎么来得到location呢

15:59.790 --> 16:04.510
怎么来得到location了 比方说我这里没有location对吧 那这个函数需要给我传一个location对象进来

16:04.830 --> 16:08.510
啊 需要给我传一个location对象进来 那我这里怎么来得到这个location的问题是

16:09.870 --> 16:15.550
这个location在哪 是不是上下文里边啊 你看一下他上下文里边是不是提供了这个location

16:16.350 --> 16:20.830
啊 我们之前放了个路径组件 他个上下文里边是不是提供了这个location对吧

16:21.230 --> 16:24.110
那我们这个switch组件是不是得从上下文里边去取啊

16:24.750 --> 16:29.070
对吧 所以switch组件这就是为什么switch组件他仍然要用到一个上下文

16:29.470 --> 16:32.510
啊 为什么他仍然要用到上下文 所以说那在render的时候

16:33.310 --> 16:38.910
我们这里呢 实际上要用到上下文的啊 所以把rex还导入进来 然后那把上下文导入进来

16:39.550 --> 16:43.150
ctx from 叫鞋杠rotor context

16:43.950 --> 16:47.150
啊 上下文导入进来 好 那么这里呢ctx

16:48.030 --> 16:50.430
ctx consumer

16:51.550 --> 16:55.950
要用上下文 好 那么这里边是不是要传一个函数 通过这个函数的反应会结果来渲染

16:56.350 --> 16:59.950
好 函数呢 有一个上下文里边的数据 就是上下文的value

17:00.430 --> 17:03.230
好 然后反而回到结果是什么呢 反回来结果就是

17:04.590 --> 17:06.350
this gets much child

17:07.310 --> 17:13.230
this gets much child 对吧 反回来结果就是这个 当然呢你也可以

17:14.110 --> 17:20.030
呃 直接把这个函数放这 直接把这个函数放这 this gets much child

17:20.350 --> 17:22.190
直接把这个函数放这 但是呢这个

17:22.910 --> 17:26.510
呃 你要注意一下 z 是指向的问题啊 你要这样子写

17:27.390 --> 17:31.790
保证这个 z 指向没问题 你可以直接把函数放这 那么函数放这过后呢

17:31.790 --> 17:38.110
就是你家传了一个什么 传了一个函数进去 对吧 把一个函数作为作为它的气候水 那么它肯定会调用这个函数

17:38.430 --> 17:42.350
那么调用这个函数的时候 它是不是会把那个上下文的数据所有的数据都传给你

17:42.350 --> 17:46.030
就是把这个上下文的value全部传给你 那么这里呢我们就可以解构出来

17:46.430 --> 17:49.550
这个都可以行 是不是可以解构 对吧 解构出来

17:50.270 --> 17:53.870
好 那么这里呢 我们就把这个location点什么passname

17:54.910 --> 18:02.590
啊 传进去 那是不是 就是我们目前访问的地址 这是路径规则 那么呢 这是一些配置 让你帮我来看一下啊

18:02.990 --> 18:05.790
这个 这些配置呢 这些路径规则和配置都是从那个

18:06.350 --> 18:10.350
肉车这个组件里边来的 对不对 都是从这里边来的 那么你帮我看一下

18:10.910 --> 18:12.910
看一下这个组件是否能匹配

18:13.870 --> 18:21.230
那么我们这里来输出一下啊 是否没匹配 如果能匹配的话 它自然会输出一个匹配对象 如果不能匹配的话 那么它什么都不会输出

18:21.710 --> 18:24.670
不能匹配的话就会输出 怎么闹 好 保存你看一下

18:25.790 --> 18:31.550
控制台 那现在是不是都输出了 对吧 因为两个都是配级都能匹配了 好 那比方说我们这里呢

18:34.350 --> 18:36.750
app里边一个配级二嘛 加个配级二

18:39.250 --> 18:40.690
加一个配级二

18:42.990 --> 18:48.110
好 你看一下 那时候只输出两个匹配的一个没有匹配 对吧

18:48.990 --> 18:55.310
因此呢 我们在寻环里边呢 就可以知道每一个肉车组件哪个匹配的 哪个没匹配 那么这要做这要做的事情很简单

18:55.630 --> 19:02.750
因为我们这里得到的就是什么 第一个匹配的肉车组件 好 一出这些判断一下就完了 如果维造成有质 是不是

19:03.390 --> 19:07.710
该肉车组件匹配了 对不对 好 那么怎么办

19:08.110 --> 19:15.070
怎么办 是不是 返回 返回啥 返回这个child就完事了

19:16.590 --> 19:22.430
返回这个child child不就是我们要渲染的东西吗 对不对 返回这个child就完事了 就这么简单

19:22.990 --> 19:28.510
好 保存一下 那么你看一下 现在呢 它直接渲染的配级 然后我们来看一下react里边

19:30.670 --> 19:36.270
啊 你看switch里边有个concurement 对吧 它用弄了上下文 它肯定是毫无疑问的 然后它这里只渲染的

19:36.670 --> 19:39.630
渲染了一个肉车 因为它只渲染到 只渲染到

19:40.110 --> 19:46.350
匹配到的那个肉车 你看 这里有两个配级 是不是只匹配到了第一个 对吧 后面就没再匹配了

19:46.830 --> 19:52.510
这非常非常简单啊switch组组件 那就是它就是来控制这个指援数 控制个指援数

19:53.070 --> 19:58.110
只渲染匹配到的那一个 把这个指援数的属性分析出来 然后再去匹配就完事了

19:58.670 --> 20:03.630
对吧 因此呢 你加了switch过后呢 也说明了一个道理 就是加了switch过后

20:03.870 --> 20:09.230
这个肉车的切尔准属性 如果说你再给肉车加切尔准 还有没有意义 是没有意义了

20:09.710 --> 20:16.750
这就是为什么我之前讲那个啊 讲那个路由切换动画的时候啊 说不要加switch 因为加了switch过后

20:16.990 --> 20:23.710
它必须要匹配 必须要匹配才会渲染这个肉车组件 如果说连肉车组件都不会渲染 那些切尔准还有什么意义呢

20:24.030 --> 20:26.990
本来是呢切尔准呢 本来是在这里面写的切尔准

20:28.270 --> 20:29.230
本来这个切尔准啊

20:30.030 --> 20:34.190
指的是不管你匹不匹配 我都要渲染 对吧 都要渲染

20:34.670 --> 20:40.110
但是现在有个问题 外面套了一个switch switch它决定了 如果说你没有匹配 我连这个组件都不给你

20:40.510 --> 20:42.910
那你渲染啥呢 你切尔准肯定渲染不了

20:43.470 --> 20:45.390
所以说切尔准的在switch里面啊

20:46.030 --> 20:50.190
那就可以可以可以这么跟Render是一样的了 因为只有匹配到瑞士组件 他才会渲染

20:51.150 --> 20:53.470
啊 这是关于这个switch啊switch的组件

20:54.270 --> 20:57.790
啊其他就没啥了 没啥了 那如果说你要再严格一点的话啊

20:58.190 --> 21:00.830
再严格一点的话 你可以判断一下这个切尔准的内形

21:01.150 --> 21:07.310
对吧 这个判断他的切尔准的内形 他是不是一个肉彻组件啊 是不是这个肉彻组件 那怎么判断了

21:07.630 --> 21:09.790
那比方说吧 我们要判断 那怎么判断的

21:10.750 --> 21:14.990
要怎么判断的 好 这里呢 我们打印出来一个切尔准嘛 你可以自己灵活处理啊

21:16.750 --> 21:21.630
好 打印这个切尔的啊 他匹配到了一个 他只打印了一次 因为这里就直接返回了 第一个匹配到了

21:22.030 --> 21:26.350
那么切尔的里面 他是不是是不是有个type 对吧 type speak是内样一个

21:27.070 --> 21:31.550
构造函数 是不是就内的内形肉彻 对吧 好 那么这里呢 我们就导入这个

21:32.030 --> 21:34.430
我们自己写的肉彻 导入自己写的肉彻

21:35.630 --> 21:37.550
爽 第二肉彻

21:38.670 --> 21:42.110
好 如果说啊 如果说判断一下啊

21:43.310 --> 21:47.070
嗯 然后这个如果说这个切尔的呢

21:48.510 --> 21:50.830
不等于啊 不等于肉彻

21:51.710 --> 21:54.190
来吧 切尔点 切尔点type

21:54.750 --> 21:57.390
他的他的内形不是这个内啊

21:58.670 --> 22:05.230
啊 构原数不是肉彻组件 那么这个时候是不是要抛出错误了

22:05.630 --> 22:07.790
you type error

22:08.430 --> 22:12.750
表示了什么意思呢 表示了就是说啊switch

22:16.030 --> 22:19.310
the child children of switch

22:20.030 --> 22:22.030
component

22:22.830 --> 22:23.630
component

22:24.750 --> 22:28.190
must be type of

22:29.070 --> 22:29.470
root

22:31.870 --> 22:35.310
好 保存啊 那咱们呢你看一下 如果说我这里呢

22:35.950 --> 22:38.190
啊 随便给个吧 前面给他个p元数

22:38.590 --> 22:42.910
啊p元数 哪里告诉他怎么怎么玩的东西的啊 是不是就爆错了对吧

22:43.550 --> 22:47.790
the children of switch components must be type of root 就是我们自己爆了个错误了对吧

22:48.750 --> 22:54.910
啊 就这么简单啊 非常简单啊 这是关于这个switch组件他的实现啊 那么事情是不是又来了

22:54.990 --> 22:58.590
大家下去啊 把这个switch组组件给他实现了就完事了啊

