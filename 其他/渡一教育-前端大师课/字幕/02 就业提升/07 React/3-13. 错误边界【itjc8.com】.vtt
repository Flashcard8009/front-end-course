WEBVTT

00:00.690 --> 00:03.690
这一块咱们来讲这个错误边界

00:03.690 --> 00:06.690
这一块的知识非常非常简单

00:06.690 --> 00:08.690
但是同时也很实用

00:08.690 --> 00:11.690
虽然说我们在平时开发的时候

00:11.690 --> 00:13.690
就是我们做一些小的练习

00:13.690 --> 00:14.690
在学校里面学习的时候

00:14.690 --> 00:16.690
做一些小的项目

00:16.690 --> 00:18.690
可能不太会用到这个东西

00:18.690 --> 00:21.690
但是以后你们在公司里面做开发的话

00:21.690 --> 00:23.690
它可能会在某些情况下

00:23.690 --> 00:25.690
它可能会非常非常有用

00:25.690 --> 00:27.690
它是什么东西呢

00:27.690 --> 00:29.690
首先跟大家说这么一个规则

00:29.690 --> 00:33.690
就是在reaction中默认情况下

00:33.690 --> 00:37.690
若一个组件在渲染期间

00:37.690 --> 00:38.690
什么叫渲染期间

00:38.690 --> 00:41.690
就是Render的时候发生错误

00:41.690 --> 00:44.690
在渲染期间发生介绍的错误的话

00:44.690 --> 00:45.690
那么会怎么样了

00:45.690 --> 00:50.690
会导致整个组件数全部被卸载

00:50.690 --> 00:53.690
就整个组件数里一个都看不到了

00:53.690 --> 00:56.690
哪怕这个页面上很多有100个组件

00:56.690 --> 00:59.690
其中一个非常非常小的组件发生了

00:59.690 --> 01:01.690
在渲染的时候发生了错误

01:01.690 --> 01:04.690
那么就会导致整个页面上一个都看什么东西都看不到

01:04.690 --> 01:06.690
因为组件数会被全部卸载

01:06.690 --> 01:08.690
它会有这么一种情况

01:08.690 --> 01:10.690
它为什么会有这么一个规则呢

01:10.690 --> 01:11.690
它主要是为了安全

01:11.690 --> 01:13.690
当你发生错误的时候就不要再运行了

01:13.690 --> 01:16.690
这也是很多语言采取的规则

01:16.690 --> 01:17.690
包括很多后端语言

01:17.690 --> 01:19.690
什么Java啊C-Sharp啊

01:19.690 --> 01:21.690
C-Java啊C语言这些

01:21.690 --> 01:22.690
如果你发生了错误

01:22.690 --> 01:23.690
你看那个程序还能运行吗

01:23.690 --> 01:24.690
肯定是不能运行的

01:24.690 --> 01:26.690
整个程序崩溃了

01:26.690 --> 01:28.690
它是用这么一种方式来处理的

01:28.690 --> 01:30.690
但是这种处理方式

01:30.690 --> 01:32.690
很多时候都是没什么问题的

01:32.690 --> 01:34.690
但是在某一些情况下

01:34.690 --> 01:37.690
它可能跟我们的要求不太相符

01:37.690 --> 01:39.690
比方说我们页面上有一个非常不起眼的组件

01:39.690 --> 01:41.690
它就是来打广告的

01:41.690 --> 01:42.690
就是一个广告

01:42.690 --> 01:43.690
谈出个广告

01:43.690 --> 01:45.690
那个组件在宣扬的时候出了问题

01:45.690 --> 01:47.690
我也不知道什么原因出了问题

01:47.690 --> 01:48.690
总之出问题了吗

01:48.690 --> 01:50.690
那它出了问题过后

01:50.690 --> 01:52.690
有必要把整个页面全部看不见吗

01:52.690 --> 01:54.690
它这是个广告啊

01:54.690 --> 01:56.690
就是我们可以用剃带的

01:56.690 --> 01:57.690
剃带的方式比较多

01:57.690 --> 01:59.690
显示这个组件出错了

01:59.690 --> 02:00.690
现在不了了

02:00.690 --> 02:02.690
或者是什么都不显示就完事了

02:02.690 --> 02:05.690
没有必要让整个页面都处于崩溃状态

02:05.690 --> 02:07.690
所以说我们有的时候

02:07.690 --> 02:09.690
需要对它进行处理

02:09.690 --> 02:11.690
好 接下来我们给大家看个例子

02:12.690 --> 02:13.690
这里面

02:13.690 --> 02:16.690
app里面我们写上这么几个组件

02:17.690 --> 02:21.690
写这么几个函数组件怎么样

02:21.690 --> 02:22.690
写这么函数组件

02:22.690 --> 02:23.690
Comp1

02:26.450 --> 02:27.450
然后呢 返回什么呢

02:27.450 --> 02:28.450
返回一个div

02:28.450 --> 02:29.450
div里面ha

02:29.450 --> 02:31.450
写上comp1

02:31.450 --> 02:33.450
comp1 这是这么一个组件

02:33.450 --> 02:36.450
然后呢 再给它写上一个

02:36.450 --> 02:37.450
这样吧

02:38.450 --> 02:40.450
写个style

02:40.450 --> 02:41.450
写个style

02:43.450 --> 02:47.820
宽度的话就给它写90%

02:47.820 --> 02:49.820
然后高度的话

02:49.820 --> 02:51.820
给它写一个500个相属

02:51.820 --> 02:52.820
500个相属

02:53.820 --> 02:55.820
然后写个边框

02:55.820 --> 02:56.820
写个边框

02:57.820 --> 02:58.820
两个相属

02:58.820 --> 02:59.820
solid

03:00.820 --> 03:01.820
这是组件1

03:01.820 --> 03:02.820
组件1

03:02.820 --> 03:03.820
咱们把它放到这

03:03.820 --> 03:04.820
comp1

03:04.820 --> 03:05.820
保存

03:05.820 --> 03:06.820
我们看一下

03:06.820 --> 03:07.820
组件1出来了

03:07.820 --> 03:08.820
对吧

03:08.820 --> 03:09.820
组件1出来了

03:09.820 --> 03:10.820
App下面包含了一个组件

03:10.820 --> 03:11.820
comp1

03:12.820 --> 03:13.820
comp1里面呢

03:13.820 --> 03:14.820
又包含一个comp2

03:15.820 --> 03:17.820
咱们复制一下吧

03:18.820 --> 03:19.820
comp2

03:19.820 --> 03:21.820
comp2的宽度也是90%

03:21.820 --> 03:24.820
然后它的高度也为90%

03:25.820 --> 03:26.820
有一个边框

03:27.820 --> 03:28.820
这是comp2

03:28.820 --> 03:30.820
comp1里面除了自己的东西之外

03:30.820 --> 03:31.820
它还有一个comp2

03:32.820 --> 03:34.820
这里70%

03:34.820 --> 03:35.820
70%

03:35.820 --> 03:36.820
行了

03:36.820 --> 03:37.820
保存

03:37.820 --> 03:38.820
看一下吧

03:38.820 --> 03:39.820
这是comp2

03:39.820 --> 03:40.820
这个组件

03:41.820 --> 03:42.820
然后呢

03:42.820 --> 03:43.820
再来一个组件

03:43.820 --> 03:44.820
comp3

03:49.630 --> 03:50.630
它的

03:51.630 --> 03:52.630
跟comp1一样

03:52.630 --> 03:53.630
行不行

03:53.630 --> 03:54.630
跟comp1一样

03:57.520 --> 03:58.520
复制一下

03:58.520 --> 04:01.600
comp3

04:03.600 --> 04:05.600
我真的写到哪去了

04:05.600 --> 04:06.600
写到哪去了

04:06.600 --> 04:07.600
应该是这

04:08.600 --> 04:09.600
小字

04:09.600 --> 04:10.600
comp3

04:11.600 --> 04:12.600
那么App里面

04:12.600 --> 04:14.600
就是一个DIV里面包含

04:14.600 --> 04:16.600
一个是comp1

04:16.600 --> 04:18.600
一个是comp3

04:18.600 --> 04:21.810
保存

04:21.810 --> 04:22.810
那么看一下

04:23.810 --> 04:24.810
下面是comp3

04:24.810 --> 04:25.810
前面是comp1

04:25.810 --> 04:26.810
comp2

04:26.810 --> 04:28.810
我们在PPT里面画一下吧

04:28.810 --> 04:30.810
画一下它的组件结构

04:30.810 --> 04:32.810
App里面包含了comp1

04:32.810 --> 04:33.810
comp1

04:33.810 --> 04:35.810
还包含了comp3

04:35.810 --> 04:38.810
comp1下面又包含了comp2

04:38.810 --> 04:42.180
形成这么一个组件数

04:42.180 --> 04:43.180
这里

04:43.180 --> 04:45.180
画一个箭头

04:46.180 --> 04:47.180
箭头

04:47.180 --> 04:48.180
拿过来

04:49.180 --> 04:51.180
形成这么一种结构

04:51.180 --> 04:57.060
再连过来

04:58.060 --> 05:00.060
形成这么一种结构

05:00.060 --> 05:01.060
那么现在

05:01.060 --> 05:03.060
我现在故意做这么一个操作

05:03.060 --> 05:05.060
我在comp2里面爆错

05:05.060 --> 05:06.060
我在这里面爆错

05:06.060 --> 05:07.060
comp2里面

05:07.060 --> 05:08.060
给它爆一个错误

05:08.060 --> 05:09.060
什么错误呢

05:09.060 --> 05:11.060
是在渲染期间发生的错误

05:11.060 --> 05:13.060
在渲染期间发生的错误

05:13.060 --> 05:14.060
那么这里

05:14.060 --> 05:15.060
怎么爆错呢

05:15.060 --> 05:16.060
比方说

05:16.060 --> 05:17.060
咱们就写一个辩量

05:17.060 --> 05:19.060
当然你可以直接拨出个错误也行

05:19.060 --> 05:20.060
throw new error

05:20.060 --> 05:21.060
对吧

05:21.060 --> 05:22.060
直接拨出个错误也行

05:22.060 --> 05:23.060
我这里就写个辩量

05:23.060 --> 05:24.060
就是

05:24.060 --> 05:25.060
模拟一下

05:25.060 --> 05:26.060
一个真实的场景

05:26.060 --> 05:27.060
比方说

05:27.060 --> 05:28.060
接着一个数组

05:28.060 --> 05:29.060
datax

05:29.060 --> 05:30.060
一个数组

05:30.060 --> 05:31.060
这数组哪来的呢

05:31.060 --> 05:33.060
可能是调用一个方法来的

05:33.060 --> 05:34.060
比方说我们写什么方法

05:34.060 --> 05:35.060
就模拟真实情况

05:35.060 --> 05:36.060
getdatax

05:36.060 --> 05:37.060
写什么方法

05:37.060 --> 05:38.060
这个方法

05:38.060 --> 05:39.060
做了一大堆处理

05:39.060 --> 05:40.060
最后返回了一个undefined

05:40.060 --> 05:42.060
最后返回了一个undefined

05:42.060 --> 05:44.060
当然这个方法

05:44.060 --> 05:45.060
实际情况不会这样子写

05:45.060 --> 05:46.060
比方说

05:46.060 --> 05:47.060
这个方法里面

05:47.060 --> 05:48.060
可能去读取其他的东西

05:48.060 --> 05:49.060
来创建这么一个数组

05:49.060 --> 05:50.060
最后把数组返回

05:50.060 --> 05:51.060
总之呢

05:51.060 --> 05:52.060
它会返回个数组

05:52.060 --> 05:53.060
但是它这里

05:53.060 --> 05:54.060
可能因为总动情况

05:54.060 --> 05:56.060
它返回了一个

05:56.060 --> 05:57.060
返回了一个就是

05:57.060 --> 05:58.060
返回了一个undefined

05:58.060 --> 05:59.060
好

05:59.060 --> 06:00.060
那么我这里

06:00.060 --> 06:01.060
把它当成数组来使用

06:01.060 --> 06:02.060
来吧

06:02.060 --> 06:03.060
我们这里写上一个什么

06:03.060 --> 06:04.060
map

06:04.060 --> 06:05.060
对吧

06:05.060 --> 06:06.060
每一个数组的每一项

06:06.060 --> 06:08.060
生成一个span元数

06:08.060 --> 06:10.060
一个某一项

06:10.060 --> 06:11.060
某一项

06:11.060 --> 06:12.060
生成一个span元数

06:12.060 --> 06:13.060
OK

06:13.060 --> 06:15.060
我们把它放到变量里边

06:15.060 --> 06:16.060
spans

06:16.060 --> 06:18.060
然后还要在这里去显示

06:18.060 --> 06:19.060
你说它能显示吗

06:19.060 --> 06:20.060
是不是不能显示

06:20.060 --> 06:21.060
它会在哪里报错

06:21.060 --> 06:23.060
是不是在这句话报错了

06:23.060 --> 06:24.060
对吧

06:24.060 --> 06:25.060
undefined它没有map这个函数

06:25.060 --> 06:27.060
所以它会在这里报错

06:27.060 --> 06:28.060
来看一下吧

06:28.060 --> 06:30.060
这就是我们看到的结果

06:30.060 --> 06:31.060
页面上出现了错误

06:31.060 --> 06:34.060
中点还不是说页面上出现了错误

06:34.060 --> 06:35.060
中点不是

06:35.060 --> 06:36.060
因为页面上错误

06:36.060 --> 06:39.060
他以为我们是开发期间

06:39.060 --> 06:40.060
开发期间

06:40.060 --> 06:41.060
我们这里会看到错误

06:41.060 --> 06:42.060
他这里说了

06:42.060 --> 06:44.060
这个屏幕上

06:44.060 --> 06:47.060
显示的东西只存在于

06:47.060 --> 06:48.060
开发期间

06:48.060 --> 06:49.060
我们在开发阶段

06:49.060 --> 06:51.060
到了以后的打包

06:51.060 --> 06:53.060
就是使用什么112 build

06:53.060 --> 06:54.060
对吧

06:54.060 --> 06:55.060
我们之前说过

06:55.060 --> 06:56.060
打包112 build

06:56.060 --> 06:57.060
使用这个命令打包

06:57.060 --> 06:58.060
打包出来过后

06:58.060 --> 07:00.060
我们把它挂到服务器上运行的时候

07:00.060 --> 07:01.060
它就是生产模式了

07:01.060 --> 07:04.060
生产模式下面是看不见这个东西的

07:04.060 --> 07:06.060
看不见这个错误的

07:06.060 --> 07:08.060
是吧

07:08.060 --> 07:09.060
它说

07:09.060 --> 07:11.060
it will not appear

07:11.060 --> 07:12.060
它不会出现在

07:12.060 --> 07:13.060
它是不会出现的

07:13.060 --> 07:14.060
什么情况也不会出现的

07:14.060 --> 07:17.060
如果这个应用崩溃在什么

07:17.060 --> 07:18.060
在生产模式

07:18.060 --> 07:21.060
在那个生产模式下

07:21.060 --> 07:22.060
生产环境下面

07:22.060 --> 07:24.060
它是不会出现这个错误的

07:24.060 --> 07:25.060
好吧

07:25.060 --> 07:27.060
那么主要是不是在这里

07:27.060 --> 07:29.060
主要的问题是在这

07:29.060 --> 07:30.060
你看react

07:30.060 --> 07:32.060
react这个调试工具

07:32.060 --> 07:34.060
组建了我们的

07:34.060 --> 07:35.060
是不是组建一个都没了

07:35.060 --> 07:37.060
咱们一个组建都没了

07:37.060 --> 07:38.060
什么都看不到了

07:38.060 --> 07:39.060
为什么会出现这种情况

07:39.060 --> 07:41.060
就是我们刚才说的

07:41.060 --> 07:43.060
如果一个组建在生产期间

07:43.060 --> 07:44.060
发生错误

07:44.060 --> 07:45.060
会导致整个组建书

07:45.060 --> 07:46.060
全部被卸载

07:46.060 --> 07:47.060
那么具体是怎么

07:47.060 --> 07:48.060
什么情况

07:48.060 --> 07:49.060
它是这样子的

07:49.060 --> 07:50.060
比方说

07:50.060 --> 07:51.060
它发生了错误

07:51.060 --> 07:52.060
它处理不了

07:52.060 --> 07:53.060
它自己处理不了这个错误

07:53.060 --> 07:55.060
组建是没法自己处理

07:55.060 --> 07:56.060
自己的错误的

07:56.060 --> 07:57.060
它处理不了这个错误

07:57.060 --> 07:58.060
也没有处理

07:58.060 --> 07:59.060
对吧

07:59.060 --> 08:00.060
那怎么办

08:00.060 --> 08:01.060
那么它就会把这个错误了

08:01.060 --> 08:02.060
扔到谁

08:02.060 --> 08:03.060
扔到它

08:03.060 --> 08:04.060
让它去处理

08:04.060 --> 08:05.060
你能不能处理一下

08:05.060 --> 08:06.060
我反正出了问题了

08:06.060 --> 08:08.060
你就处理一下吧

08:08.060 --> 08:09.060
它是个普通组建

08:09.060 --> 08:10.060
它也没有处理这个错误

08:10.060 --> 08:11.060
它又发生错误了

08:11.060 --> 08:12.060
我也处理不了

08:12.060 --> 08:14.060
我也把处理

08:14.060 --> 08:15.060
交给谁

08:15.060 --> 08:16.060
不交给它了

08:16.060 --> 08:17.060
让它去处理

08:17.060 --> 08:18.060
它也没法处理

08:18.060 --> 08:19.060
所以说

08:19.060 --> 08:20.060
整个应用程序

08:20.060 --> 08:21.060
它卸载了

08:21.060 --> 08:22.060
它卸载了

08:22.060 --> 08:23.060
它是根源书

08:23.060 --> 08:24.060
那么整个应用程序

08:24.060 --> 08:25.060
全部被卸载了

08:25.060 --> 08:27.060
一个组建都看不到

08:27.060 --> 08:29.060
这是默认情况下

08:29.060 --> 08:30.060
它的处理方式

08:30.060 --> 08:31.060
那么现在

08:31.060 --> 08:33.060
我们要讲这个错误边界

08:33.060 --> 08:36.060
其实就是让这个

08:36.060 --> 08:38.060
就是让组建的错误了

08:38.060 --> 08:40.060
它不要继续往后边传播了

08:40.060 --> 08:42.060
错误边界

08:42.060 --> 08:43.060
是什么东西

08:43.060 --> 08:44.060
我们再解释一下

08:44.060 --> 08:45.060
错误边界

08:45.060 --> 08:48.060
本质上就是一个组建

08:48.060 --> 08:49.060
就是一个组建

08:49.060 --> 08:50.060
也不用本质上了

08:50.060 --> 08:52.060
是一个组建

08:52.060 --> 08:55.060
该组建

08:55.060 --> 08:57.060
若该组建

08:57.060 --> 08:58.060
这样说

08:58.060 --> 09:01.060
该组建会补货到

09:01.060 --> 09:02.060
补货到

09:02.060 --> 09:03.060
相当于是用Track Hatch一样

09:03.060 --> 09:05.060
会补货到

09:05.060 --> 09:06.060
渲染期间

09:06.060 --> 09:07.060
注意啊

09:07.060 --> 09:08.060
一定是渲染期间

09:08.060 --> 09:09.060
我特别强调这个

09:09.060 --> 09:10.060
我们后边还会

09:10.060 --> 09:11.060
具体给大家举例子

09:11.060 --> 09:12.060
让大家注意

09:12.060 --> 09:13.060
一定是渲染期间

09:13.060 --> 09:15.060
就是Render

09:15.060 --> 09:17.060
在渲染的时候

09:17.060 --> 09:19.060
Render

09:19.060 --> 09:22.060
渲染期间发生的错误

09:22.060 --> 09:24.060
它会补货到渲染期间

09:24.060 --> 09:25.060
发生的错误

09:25.060 --> 09:28.060
并有能力

09:28.060 --> 09:30.060
这里还要加上一个潜力条件

09:30.060 --> 09:32.060
会补货到渲染期间

09:32.060 --> 09:34.060
直组建发生的错误

09:34.060 --> 09:37.060
并有能力阻止

09:37.060 --> 09:40.060
错误继续传播

09:40.060 --> 09:41.060
还有能力阻止

09:41.060 --> 09:42.060
这个错误继续传播

09:42.060 --> 09:43.060
这就是错误边界

09:43.060 --> 09:45.060
它本质上就是一个组建

09:45.060 --> 09:46.060
那如果要画图来说明的话

09:46.060 --> 09:47.060
那很简单

09:47.060 --> 09:48.060
比方说

09:48.060 --> 09:51.060
我可以在这里

09:51.060 --> 09:53.060
加一个组建

09:53.060 --> 09:54.060
加上这么一个组建

09:54.060 --> 09:56.060
这个组建叫Boundary

09:56.060 --> 09:57.060
叫做Error

09:57.060 --> 09:59.060
该是随便取个名字

09:59.060 --> 10:01.060
组建的名字是我们自己取的

10:01.060 --> 10:02.060
Boundary

10:02.060 --> 10:04.060
表示或者叫Bound

10:04.060 --> 10:06.060
组建

10:06.060 --> 10:07.060
就是错误的边界

10:07.060 --> 10:08.060
Error 错误

10:08.060 --> 10:10.060
Bounder 边界

10:10.060 --> 10:12.060
那么给它加上这么一个组建

10:12.060 --> 10:13.060
那这个组建有什么作用呢

10:13.060 --> 10:14.060
它是这样子

10:14.060 --> 10:17.060
如果它发生了错误

10:17.060 --> 10:18.060
那么它处理不了

10:18.060 --> 10:19.060
扔到副组建

10:19.060 --> 10:20.060
副组建继续处理吧

10:20.060 --> 10:22.060
它也处理不了

10:22.060 --> 10:24.060
然后继续往上扔到这

10:24.060 --> 10:26.060
它能发现这个错误

10:26.060 --> 10:28.060
它能处理的

10:28.060 --> 10:29.060
然后呢

10:29.060 --> 10:31.060
它就根据自己的情况

10:31.060 --> 10:33.060
来去做这些事情

10:33.060 --> 10:35.060
根据具体的情况去做这些事情

10:35.060 --> 10:36.060
那么它这把个错误

10:36.060 --> 10:37.060
就定格到这了

10:37.060 --> 10:39.060
这两个组建肯定卸载了

10:39.060 --> 10:40.060
肯定是不能显示的

10:40.060 --> 10:41.060
没法显示

10:41.060 --> 10:43.060
但是它可以根据情况

10:43.060 --> 10:44.060
你有错误怎么显示

10:44.060 --> 10:45.060
没有错误怎么显示

10:45.060 --> 10:47.060
根据情况来做具体的显示

10:47.060 --> 10:48.060
所以这就和我们学习到是啥呢

10:48.060 --> 10:49.060
学习到就是

10:49.060 --> 10:51.060
如何来自己写

10:51.060 --> 10:52.060
写出这么一个组建

10:52.060 --> 10:54.060
这个组建Rex没有提供给你

10:54.060 --> 10:55.060
你需要自己写

10:55.060 --> 10:57.060
那么咱们就写这么一个组建

10:57.060 --> 10:59.060
我们把它当成一个通用组建

10:59.060 --> 11:00.060
写到这

11:00.060 --> 11:02.060
写出这么一个文件夹

11:02.060 --> 11:03.060
叫做Error

11:03.060 --> 11:04.060
Error

11:04.060 --> 11:06.060
Bund

11:06.060 --> 11:07.060
写这么一个文件夹

11:07.060 --> 11:09.060
里边写上一个介绍

11:09.060 --> 11:10.060
in这个社

11:10.060 --> 11:11.060
介绍

11:11.060 --> 11:13.060
看一下咱们怎么来处理这个问题

11:13.060 --> 11:15.060
RCC

11:15.060 --> 11:18.370
Purus

11:18.370 --> 11:20.370
这是Error

11:20.370 --> 11:21.370
Bund

11:21.370 --> 11:23.370
有这么一个组建

11:23.370 --> 11:25.370
这个组建里边

11:25.370 --> 11:26.370
到时候我们先不说

11:26.370 --> 11:27.370
它怎么写呆嘛

11:27.370 --> 11:29.370
我们先说它怎么来用

11:29.370 --> 11:31.370
这个组建它怎么来用

11:31.370 --> 11:32.370
它怎么用呢

11:32.370 --> 11:33.370
我们希望它到时候

11:33.370 --> 11:34.370
当然这个用法有很多

11:34.370 --> 11:35.370
你可以根据情况

11:35.370 --> 11:36.370
自行进行处理

11:36.370 --> 11:38.370
我把这个app复制一下

11:38.370 --> 11:39.370
具体怎么用呢

11:39.370 --> 11:41.370
我到时候会这样子用

11:41.370 --> 11:43.370
我把这个组建导入进来

11:43.370 --> 11:45.370
Inport

11:45.370 --> 11:47.370
就是Error

11:47.370 --> 11:48.370
Bund

11:48.370 --> 11:49.370
From

11:49.370 --> 11:51.370
Component

11:51.370 --> 11:52.370
ErrorBund

11:52.370 --> 11:53.370
组建导入进来

11:53.370 --> 11:54.370
导入进来的时候

11:54.370 --> 11:55.370
我们用的时候这样子用

11:55.370 --> 11:57.370
我到时候不是要使用这个

11:57.370 --> 11:58.370
组建1吗

11:58.370 --> 11:59.370
我到时候我当时会想

11:59.370 --> 12:01.370
这个组建1可能就是个广告

12:01.370 --> 12:02.370
组建

12:02.370 --> 12:03.370
它就有错误就有错误

12:03.370 --> 12:05.370
我就不显示了

12:05.370 --> 12:07.370
或者说选是一个错误消息

12:07.370 --> 12:09.370
我没有必要导致整个

12:09.370 --> 12:11.370
整个页面都没发现的

12:11.370 --> 12:13.370
那我就干脆直接用一个

12:13.370 --> 12:14.370
Bund ErrorBund

12:14.370 --> 12:15.370
把它包起来

12:15.370 --> 12:16.370
那么这样子

12:16.370 --> 12:18.370
它里边有了错误之后

12:18.370 --> 12:19.370
它传播到这

12:19.370 --> 12:20.370
它就会停止了

12:20.370 --> 12:22.370
它就不会继续往上传播了

12:22.370 --> 12:23.370
我们就要做这么一个东西

12:23.370 --> 12:25.370
这就是我们要做的事情

12:25.370 --> 12:27.370
所谓说ErrorBund的这个组建里边

12:27.370 --> 12:28.370
怎么写的

12:28.370 --> 12:29.370
非常简单

12:29.370 --> 12:30.370
它渲染的时候

12:30.370 --> 12:31.370
渲染啥

12:31.370 --> 12:33.370
它直接就渲染这个东西

12:33.370 --> 12:34.370
直接就渲染什么

12:34.370 --> 12:36.370
ZisProbs里边的 children

12:36.370 --> 12:37.370
对吧 直接把 children

12:37.370 --> 12:38.370
渲染出来就完事了

12:38.370 --> 12:39.370
你不是给它

12:39.370 --> 12:41.370
给它的东西就是 children

12:41.370 --> 12:42.370
对吧 children的属性

12:42.370 --> 12:43.370
我直接把 children

12:43.370 --> 12:44.370
渲染出来就完事了

12:44.370 --> 12:46.370
它如果是很简单

12:46.370 --> 12:47.370
但是如果你仅仅这样做的话

12:47.370 --> 12:48.370
它只是一个普通组建

12:48.370 --> 12:50.370
它只是名字变成这个了

12:50.370 --> 12:51.370
其他没有任何区别

12:51.370 --> 12:52.370
没有任何意义

12:52.370 --> 12:54.370
它也没有补货错误

12:54.370 --> 12:55.370
所以目前的情况下

12:55.370 --> 12:57.370
还是写掉了整个组建书

12:57.370 --> 12:58.370
还是

12:58.370 --> 12:59.370
刷新一下

13:00.370 --> 13:01.370
它还是写掉了整个组建书

13:01.370 --> 13:03.370
你看整个组建都没了

13:03.370 --> 13:05.370
那么我们现在要怎么来处理

13:05.370 --> 13:07.370
才能让它补货到错误呢

13:07.370 --> 13:09.370
这里的几个笔记

13:10.370 --> 13:13.370
就是让某个组建补货错误

13:14.370 --> 13:15.370
第一个

13:15.370 --> 13:17.370
第一种方式

13:17.370 --> 13:18.370
两种方式都可以

13:18.370 --> 13:19.370
两种方式都可以

13:19.370 --> 13:21.370
第一种方式是

13:21.370 --> 13:23.370
书写

13:23.370 --> 13:24.370
编写

13:24.370 --> 13:26.370
生命周期函书

13:26.370 --> 13:27.370
什么函书呢

13:27.370 --> 13:29.370
这个函书叫做get

13:29.370 --> 13:30.370
这个函书名字好长

13:30.370 --> 13:32.370
又记不住了

13:32.370 --> 13:33.370
叫做

13:34.370 --> 13:35.370
static

13:35.370 --> 13:36.370
它是静态的

13:36.370 --> 13:38.370
我们会说get

13:39.370 --> 13:41.370
它这里的名字改一下

13:41.370 --> 13:43.370
是个自能提示

13:43.370 --> 13:48.220
叫做addware

13:48.220 --> 13:50.220
是这么一个函书

13:50.220 --> 13:52.220
我们这里输出

13:52.220 --> 13:54.220
发生错误了

13:54.220 --> 13:56.220
看一下这个函书

13:56.220 --> 13:58.220
我们看一下这句话

13:58.220 --> 13:59.220
保存

13:59.220 --> 14:00.220
看一下

14:00.220 --> 14:01.220
现在肯定是没有组建书

14:01.220 --> 14:03.220
因为我们还没有处理错误

14:03.220 --> 14:04.220
我们看一下控制台

14:04.220 --> 14:06.220
看看有没有这句话输出

14:06.220 --> 14:07.220
你看这里

14:07.220 --> 14:09.220
是不是这句话输出了

14:09.220 --> 14:10.220
发生了错误了

14:10.220 --> 14:11.220
发生错误了

14:11.220 --> 14:12.220
这句话输出了

14:12.220 --> 14:13.220
说明这个函书运行了

14:14.220 --> 14:15.220
这个函书的名字

14:15.220 --> 14:17.220
看一下这个函书有什么样的特点

14:17.220 --> 14:19.220
以及什么时候运行

14:19.220 --> 14:21.220
这个函书

14:21.220 --> 14:22.220
这个函书

14:22.220 --> 14:24.220
是一个静态函书

14:24.220 --> 14:26.220
是一个静态函书

14:26.220 --> 14:28.220
它是在16版本之后

14:28.220 --> 14:30.220
像错误边界这个知识

14:30.220 --> 14:31.220
错误边界这个东西

14:31.220 --> 14:33.220
它本身就是在16版本之后

14:33.220 --> 14:34.220
出现的东西

14:34.220 --> 14:36.220
以前是没有的

14:36.220 --> 14:38.220
它出现这么一个生命周期函书

14:38.220 --> 14:39.220
它是个静态函书

14:39.220 --> 14:40.220
这个我们说一下

14:40.220 --> 14:41.220
第二个

14:41.220 --> 14:43.220
我不能去使用Z

14:43.220 --> 14:44.220
Z是什么东西都拿不到的

14:44.220 --> 14:45.220
拿不到Z

14:45.220 --> 14:47.220
那么这个函书什么时候运行了

14:47.220 --> 14:48.220
运行的时间

14:48.220 --> 14:50.220
运行时间点

14:50.220 --> 14:52.220
什么时候是运行

14:52.220 --> 14:55.220
是在渲染值组件时

14:55.220 --> 14:58.220
渲染值组件

14:58.220 --> 15:00.220
发生错误时

15:00.220 --> 15:02.220
在渲染值组件

15:02.220 --> 15:04.220
时

15:04.220 --> 15:06.220
发生错误的时候

15:06.220 --> 15:08.220
是这么一个时间点

15:08.220 --> 15:09.220
然后发生错误时

15:09.220 --> 15:11.220
还有在什么之前呢

15:11.220 --> 15:13.220
发生错误值组件

15:13.220 --> 15:15.220
渲染值组件发生错误之后

15:17.220 --> 15:19.220
应该是渲染对了

15:19.220 --> 15:20.220
语句怎么读出来不通呢

15:20.220 --> 15:26.220
渲染值组件的过程中

15:26.220 --> 15:28.220
发生错误之后

15:28.220 --> 15:33.220
然后在显示到页面之前

15:33.220 --> 15:36.220
再把错误显示到页面之前

15:36.220 --> 15:38.220
在渲染之前

15:38.220 --> 15:42.220
或者说在更新页面之前

15:42.220 --> 15:43.220
它是这个时间点

15:43.220 --> 15:44.220
因为这个页面还没有更新

15:44.220 --> 15:46.220
但是已经发生错误了

15:46.220 --> 15:48.220
那么会运行这个函书

15:48.220 --> 15:50.220
是这个时间点

15:50.220 --> 15:51.220
然后继续说

15:51.220 --> 15:53.220
这个函书有什么样的特点

15:53.220 --> 15:56.220
还有另外一个要注意

15:56.220 --> 15:57.220
注意

15:57.220 --> 16:02.530
只有值组件发生错误

16:02.530 --> 16:05.530
才会运行该函书

16:05.530 --> 16:07.530
只有值组件发生错误的时候

16:07.530 --> 16:08.530
才会运行这个函书

16:08.530 --> 16:10.530
也就是说这个函书

16:10.530 --> 16:11.530
如果说Render里面

16:11.530 --> 16:12.530
值组件没有错误

16:12.530 --> 16:13.530
比方说我这里

16:13.530 --> 16:14.530
就返回一个A71

16:14.530 --> 16:15.530
是不是没有错误

16:15.530 --> 16:17.530
我压根就没有使用值组件

16:17.530 --> 16:19.530
我返回一个A71

16:19.530 --> 16:21.530
没问题吧

16:21.530 --> 16:22.530
就返回一个A71

16:22.530 --> 16:24.530
我就没有渲染什么值组件

16:24.530 --> 16:26.530
根本就没有渲染值组件

16:26.530 --> 16:27.530
那么现在肯定是没有错误的

16:27.530 --> 16:29.530
A71里面就有一个A71

16:29.530 --> 16:30.530
这个没问题吧

16:30.530 --> 16:32.530
我取个名字叫做A71

16:32.530 --> 16:34.530
不是说取个名字就有神奇的效果

16:34.530 --> 16:35.530
我没有渲染值组件

16:35.530 --> 16:36.530
它自然没有错误

16:36.530 --> 16:38.530
但是我这里

16:38.530 --> 16:40.530
比较我知己渲染的时候发生错误

16:40.530 --> 16:42.530
知己渲染的时候发生错误

16:42.530 --> 16:43.530
你看一下

16:43.530 --> 16:44.530
它会不会运行这句话

16:44.530 --> 16:46.530
关键是看它会不会运行这句话

16:46.530 --> 16:50.220
保存

16:50.220 --> 16:52.220
你看一下会不会运行这句话

16:52.220 --> 16:54.220
这句语句有没有输出这个函书

16:54.220 --> 16:56.220
是不是没有运行

16:56.220 --> 16:58.220
所以说我们这里一定要注意

16:58.220 --> 17:00.220
只有值组件发生错误的时候

17:00.220 --> 17:01.220
才会运行这个函书

17:01.220 --> 17:02.220
那么它自己发生错误

17:02.220 --> 17:03.220
它是不会运行的

17:03.220 --> 17:04.220
也就是说

17:04.220 --> 17:05.220
如果它自己本身发生错误

17:05.220 --> 17:06.220
它又处理不了了

17:06.220 --> 17:07.220
它又要往上扔了

17:07.220 --> 17:10.220
又导致整个组件数卸载掉了

17:10.220 --> 17:12.220
那么这是这个

17:12.220 --> 17:15.220
这是函书运行的时间点

17:15.220 --> 17:19.750
大家一定要注意

17:19.750 --> 17:20.750
我们继续

17:20.750 --> 17:22.750
那么这个函书还有什么作用

17:22.750 --> 17:23.750
这个函书现在写得过后

17:23.750 --> 17:25.750
好像跟没写一样

17:25.750 --> 17:26.750
一发生错误

17:26.750 --> 17:27.750
还不是就发生错误了

17:27.750 --> 17:28.750
组件数还不是被卸载了

17:28.750 --> 17:30.750
跟没写一样

17:30.750 --> 17:31.750
是因为我们这里

17:31.750 --> 17:33.750
一般情况下要自行来处理

17:33.750 --> 17:34.750
怎么来处理呢

17:34.750 --> 17:35.750
它是这样子

17:35.750 --> 17:37.750
该函书

17:37.750 --> 17:40.750
该函书的返回一个对象

17:40.750 --> 17:43.750
你要返回一个对象

17:43.750 --> 17:47.750
React 会将该对象

17:47.750 --> 17:49.750
混合到

17:49.750 --> 17:52.750
该对象的属性

17:52.750 --> 17:57.750
覆盖掉当前组件的State

17:57.750 --> 17:59.750
也就是说什么意思呢

17:59.750 --> 18:00.750
就是这个函书

18:00.750 --> 18:03.750
它跟From Props差不多

18:03.750 --> 18:04.750
还好返回一个对象

18:04.750 --> 18:06.750
比方说我们这里一个State

18:06.750 --> 18:08.750
这个State里边有个状态

18:08.750 --> 18:10.750
状态里边有一个属性叫做

18:10.750 --> 18:12.750
Has Error

18:12.750 --> 18:14.750
Has Error 是不是有错误

18:14.750 --> 18:16.750
默认情况下没有错误

18:16.750 --> 18:17.750
当我们发生错误的时候

18:17.750 --> 18:19.750
是不是会运行这个函书

18:19.750 --> 18:20.750
运行函书的时候

18:20.750 --> 18:22.750
我们返回一个对象

18:22.750 --> 18:24.750
Has Error

18:24.750 --> 18:25.750
它这一去

18:25.750 --> 18:26.750
那么它会怎么样呢

18:26.750 --> 18:27.750
它会把这个Has Error

18:27.750 --> 18:30.750
这个对象里边的属性覆盖掉

18:30.750 --> 18:33.750
就相当于是运行的Zestate

18:33.750 --> 18:35.750
但是你这里不能直接写

18:35.750 --> 18:36.750
这个State 是不行的

18:36.750 --> 18:37.750
因为这是静态

18:37.750 --> 18:38.750
静态方法

18:38.750 --> 18:39.750
你再返回一个对象

18:39.750 --> 18:41.750
Rex会自动的把这个对象

18:41.750 --> 18:43.750
覆盖掉这个State

18:43.750 --> 18:45.750
它里边的同名属性会覆盖掉

18:45.750 --> 18:46.750
那么这样子一来

18:46.750 --> 18:48.750
我们就有机会操作错误了

18:48.750 --> 18:49.750
因为我们可以根据

18:49.750 --> 18:50.750
这个State的不同

18:50.750 --> 18:51.750
来渲染不同的东西

18:51.750 --> 18:52.750
比方说Render的时候

18:52.750 --> 18:53.750
我们也可以写

18:53.750 --> 18:54.750
这也没有什么神奇的

18:54.750 --> 18:56.750
就是根据代码来写就行了

18:56.750 --> 18:58.750
就是以前的代码

18:58.750 --> 18:59.750
只不过多了一个生命中心

18:59.750 --> 19:00.750
含述而已

19:00.750 --> 19:02.750
那么如果它有错误的话

19:02.750 --> 19:03.750
怎么办

19:03.750 --> 19:04.750
有错误怎么办

19:04.750 --> 19:05.750
我就该渲染一个

19:05.750 --> 19:06.750
比方说什么都不渲染

19:06.750 --> 19:07.750
我返回啦

19:07.750 --> 19:08.750
没问题

19:08.750 --> 19:09.750
啥都不渲染

19:09.750 --> 19:10.750
我也给它返回一个

19:10.750 --> 19:12.750
H1比方说

19:12.750 --> 19:13.750
出现错误了

19:13.750 --> 19:15.750
当然我可以给它返回一个DBA

19:15.750 --> 19:16.750
返回一张图片

19:16.750 --> 19:17.750
什么都行

19:17.750 --> 19:18.750
你想返回啥返回啥

19:18.750 --> 19:19.750
你自行处理

19:19.750 --> 19:20.750
如果没有错误的话

19:20.750 --> 19:22.750
那么渲染这个东西

19:22.750 --> 19:24.750
它是用这种模式的

19:24.750 --> 19:25.750
一开始没有错误

19:25.750 --> 19:27.750
那么渲染

19:27.750 --> 19:29.750
渲染过程中发现有问题了

19:29.750 --> 19:30.750
出现问题了

19:30.750 --> 19:31.750
马上又会运行这个函数

19:31.750 --> 19:34.750
这个函数它就会把这个错误

19:34.750 --> 19:36.750
把它把这个State标记为Q

19:36.750 --> 19:37.750
然后再重新渲染

19:37.750 --> 19:39.750
重新渲染的时候就渲染出这个东西了

19:39.750 --> 19:41.750
保存你看一下

19:41.750 --> 19:42.750
那么你看

19:42.750 --> 19:43.750
这里

19:43.750 --> 19:44.750
虽然说散了一下

19:44.750 --> 19:46.750
最终它还会显示这个错误消息

19:46.750 --> 19:47.750
但是没关系

19:47.750 --> 19:48.750
因为这是

19:48.750 --> 19:49.750
生

19:49.750 --> 19:50.750
这是开发环境

19:50.750 --> 19:52.750
开发环境它一定会显示这种消息的

19:52.750 --> 19:53.750
没关系

19:53.750 --> 19:54.750
咱们看一下组建数

19:54.750 --> 19:57.750
有没有消失组建数

19:57.750 --> 19:59.750
组建数是不是出现了

19:59.750 --> 20:00.750
对吧

20:00.750 --> 20:01.750
那么它现在出来这个东西了

20:01.750 --> 20:02.750
H1元数

20:02.750 --> 20:03.750
虽然我们在这里看不见

20:03.750 --> 20:06.750
其实你仔细看一下是看不见的

20:06.750 --> 20:08.750
一散就过了

20:08.750 --> 20:10.750
但是生产环境就没问题了

20:10.750 --> 20:12.750
到了部署到真实的服务器上的话

20:12.750 --> 20:15.750
那么还会正常全是H1元数

20:15.750 --> 20:17.750
那么可以看到组建数

20:17.750 --> 20:18.750
它仍然还在

20:18.750 --> 20:20.750
错误到这里结束了

20:20.750 --> 20:21.750
终止了

20:21.750 --> 20:22.750
于是就是这张图

20:22.750 --> 20:24.750
它发生错误往上抛

20:24.750 --> 20:26.750
它处理的这个错误

20:26.750 --> 20:27.750
那么于是

20:27.750 --> 20:28.750
这个错误在这里终止了

20:28.750 --> 20:30.750
它没有继续往上抛了

20:30.750 --> 20:32.750
于是这里出现错误的时候

20:32.750 --> 20:34.750
显示了一个H1

20:34.750 --> 20:36.750
你看这里面出现了个H1元数

20:36.750 --> 20:37.750
看到没

20:37.750 --> 20:39.750
这就是

20:39.750 --> 20:43.750
这就是生命周期函数的用法

20:43.750 --> 20:45.750
另外生命周期函数里边

20:45.750 --> 20:47.750
还有一个参数

20:47.750 --> 20:50.750
参数有一个错误对象

20:50.750 --> 20:52.750
它有一个错误对象

20:52.750 --> 20:54.750
咱们来看一下一个错误对象

20:54.750 --> 20:55.750
非常非常简单

20:55.750 --> 20:56.750
如果你需要的话

20:56.750 --> 20:59.750
你可以使用这个参数

20:59.750 --> 21:01.750
我们把这个错误对象输出

21:01.750 --> 21:03.750
输出

21:04.750 --> 21:05.750
出现错误了

21:05.750 --> 21:06.750
大家看

21:06.750 --> 21:08.750
前面是报了错误的东西

21:08.750 --> 21:09.750
那么你看

21:09.750 --> 21:10.750
这个错误对象是不是输出了

21:10.750 --> 21:11.750
对吧

21:11.750 --> 21:14.750
就把个错误对象输出了

21:14.750 --> 21:15.750
当然了

21:15.750 --> 21:16.750
前面输出就是个错误对象

21:16.750 --> 21:17.750
对不对

21:17.750 --> 21:19.750
输出就是个错误对象

21:19.750 --> 21:20.750
无非它就差输出了

21:20.750 --> 21:22.750
是不是用error输出的

21:22.750 --> 21:24.750
它用这种方式来输出的

21:24.750 --> 21:25.750
对吧

21:26.750 --> 21:28.750
你看这个输出的是不是一模一样的

21:28.750 --> 21:29.750
就是一个错误对象

21:29.750 --> 21:30.750
就是一个error对象

21:30.750 --> 21:31.750
因为我们知道

21:31.750 --> 21:33.750
GS里边的错误都是一个error对象

21:33.750 --> 21:35.750
那么它这里得到的就是error对象

21:35.750 --> 21:36.750
没什么好说的

21:36.750 --> 21:37.750
你要拿来

21:37.750 --> 21:38.750
怎么用随便你

21:38.750 --> 21:39.750
随便你怎么用

21:39.750 --> 21:41.750
这就是这个错误对象

21:41.750 --> 21:43.750
这是关于这个生命周期函数

21:43.750 --> 21:45.750
还有另外一个生命周期函数

21:45.750 --> 21:47.750
另外一个生命周期函数

21:47.750 --> 21:48.750
什么函数呢

21:48.750 --> 21:49.750
叫做

21:51.750 --> 21:52.750
另外一个

21:52.750 --> 21:54.750
两种方式都可以

21:54.750 --> 21:55.750
边写生命

21:55.750 --> 21:56.750
这里说错了

21:56.750 --> 21:57.750
这里写错了

21:57.750 --> 21:58.750
生命周期

22:01.380 --> 22:03.380
边写生命周期函数

22:04.380 --> 22:06.380
这个函数名字也是一长串

22:06.380 --> 22:07.380
咱们来写一下

22:07.380 --> 22:08.380
函数名字叫做

22:08.380 --> 22:12.210
component did

22:12.210 --> 22:16.030
component

22:16.030 --> 22:18.030
component did

22:18.030 --> 22:19.030
catch

22:19.030 --> 22:21.030
这么一个生命周期函数

22:21.030 --> 22:23.030
应该是cdc

22:25.030 --> 22:27.030
那么这个生命周期函数

22:27.030 --> 22:30.540
它是一个实力函数

22:30.540 --> 22:31.540
复制一下

22:31.540 --> 22:34.980
这是一个实力方法

22:35.980 --> 22:36.980
它不是心态方法

22:36.980 --> 22:38.980
那么它的运行时间点

22:38.980 --> 22:39.980
是什么呢

22:39.980 --> 22:41.980
它的运行时间点是

22:41.980 --> 22:43.980
渲染直驻件的过程中

22:43.980 --> 22:44.980
发现错误之后

22:44.980 --> 22:46.980
然后发现错误

22:46.980 --> 22:48.980
更新页面之后

22:48.980 --> 22:50.980
页面已经更凶了

22:50.980 --> 22:51.980
更新页面之后

22:51.980 --> 22:53.980
它是在之后发生的

22:53.980 --> 22:54.980
component did

22:54.980 --> 22:55.980
catch

22:55.980 --> 22:56.980
是在之后发生的

22:56.980 --> 22:58.980
那么如果你要在周里面处理的话

22:58.980 --> 22:59.980
那么我们来看一下

22:59.980 --> 23:01.980
res set state

23:01.980 --> 23:02.980
比方说

23:02.980 --> 23:03.980
我们这里发现错误了

23:03.980 --> 23:04.980
对吧发现错误了

23:04.980 --> 23:05.980
我们干嘛呢

23:05.980 --> 23:06.980
我们就用res set state

23:08.980 --> 23:10.980
我们用调动方式写一次

23:10.980 --> 23:12.980
我们把生命周期函数注冊

23:12.980 --> 23:14.980
用这个函数写一次

23:14.980 --> 23:18.610
看一下保存

23:18.610 --> 23:20.610
那么看一下组建

23:20.610 --> 23:21.610
组建结构

23:21.610 --> 23:22.610
是不是仍然可以保留

23:22.610 --> 23:24.610
对吧仍然可以保留

23:24.610 --> 23:25.610
保留这个东西

23:25.610 --> 23:26.610
没问题的

23:26.610 --> 23:27.610
因为它本来是发生错误了

23:27.610 --> 23:29.610
但是我马上又给它

23:29.610 --> 23:30.610
它本来一开始

23:30.610 --> 23:31.610
一看一下这个过程

23:31.610 --> 23:32.610
刷新

23:36.430 --> 23:37.430
太快了

23:37.430 --> 23:38.430
看不见

23:38.430 --> 23:39.430
它实际上是这么一回事

23:39.430 --> 23:40.430
因为它运行的生命周期

23:40.430 --> 23:41.430
它比较靠后

23:41.430 --> 23:43.430
它已经在更新页面之后了

23:43.430 --> 23:44.430
就是一开始没有组建

23:44.430 --> 23:45.430
除了错

23:45.430 --> 23:46.430
没有组建了

23:46.430 --> 23:47.430
把组建数全部卸载了

23:47.430 --> 23:48.430
卸载之后

23:48.430 --> 23:50.430
它又运行这个函数

23:51.430 --> 23:52.430
然后它发现有错误了

23:52.430 --> 23:54.430
然后把它设为q

23:54.430 --> 23:55.430
把有错误设为q

23:55.430 --> 23:56.430
然后又导致重新选择

23:56.430 --> 23:57.430
因为重新选择过后

23:57.430 --> 23:58.430
又没有错误了

23:58.430 --> 24:00.430
它又把组建数重新构建出来

24:00.430 --> 24:02.430
所以说这个生命周期函数

24:02.430 --> 24:03.430
可以用

24:03.430 --> 24:04.430
只不过

24:04.430 --> 24:05.430
这个生命周期函数

24:05.430 --> 24:07.430
一般来说

24:07.430 --> 24:09.430
如果你要做状态标记的话

24:09.430 --> 24:10.430
最好使用这个

24:10.430 --> 24:12.430
因为这个它有影响效率

24:12.430 --> 24:14.430
它一面已经卸载了过后

24:14.430 --> 24:16.430
又重新把整个组建数构建出来

24:16.430 --> 24:18.430
那就不如在卸载之前

24:18.430 --> 24:19.430
就把这件事做了

24:19.430 --> 24:21.430
所以说运行这个函数的时候

24:21.430 --> 24:23.430
实际上是没有卸载组建数的

24:23.430 --> 24:26.430
你到时候不用重新去构建整个组建数

24:26.430 --> 24:28.430
都是在更新页面之前运行的

24:28.430 --> 24:31.430
这是在更新页面之后运行的

24:31.430 --> 24:33.430
这是这两个函数

24:33.430 --> 24:36.430
所以说因为它时间比较靠后

24:36.430 --> 24:40.430
所以说我们通常不会在这里边去更新状态

24:40.430 --> 24:48.430
由于其时间比较靠后

24:48.430 --> 24:51.430
因此不太会

24:51.430 --> 24:56.430
尤其只运行时间点比较靠后

24:56.430 --> 25:02.430
因此不太会在该函数中改变状态

25:02.430 --> 25:05.810
另外这个函数里边

25:05.810 --> 25:07.810
它会有两个参数大家看到没

25:07.810 --> 25:08.810
有这么两个参数

25:08.810 --> 25:10.810
一个是 error 一个是 info

25:10.810 --> 25:12.810
我们来看一下这两个参数

25:12.810 --> 25:13.810
打印出来

25:13.810 --> 25:16.810
error info

25:16.810 --> 25:17.810
保存

25:17.810 --> 25:20.810
看一下吧两个参数

25:20.810 --> 25:23.810
这是我们自动打印的错误

25:23.810 --> 25:26.810
error 打印出来是这个东西

25:26.810 --> 25:28.810
就是我们的 error 对象

25:28.810 --> 25:30.810
然后我们这样打印

25:30.810 --> 25:31.810
这样打印

25:31.810 --> 25:33.810
DIR

25:33.810 --> 25:37.950
这样子看得清楚一点

25:41.950 --> 25:46.460
我们分开打印

25:46.460 --> 25:48.460
消息太长了

25:48.460 --> 25:51.460
因为它包含了错误对战的里边东西

25:51.460 --> 25:52.460
error 没什么好说的

25:52.460 --> 25:53.460
就是一个错误对象

25:53.460 --> 25:55.460
上面这一坨就是 error

25:55.460 --> 25:57.460
因为它里面的制服创里面包含了

25:57.460 --> 25:59.460
什么错误的对战信息

25:59.460 --> 26:00.460
在哪里包了错

26:00.460 --> 26:01.460
全部包含进来了

26:01.460 --> 26:03.460
那么下面是个 object 一个词

26:03.460 --> 26:06.460
那么这个 object 词里边有什么东西

26:06.460 --> 26:08.460
它就一个叫 component stack

26:08.460 --> 26:10.460
你看一下吧

26:10.460 --> 26:13.460
就是一个错误的摘要

26:13.460 --> 26:15.460
一个错误的摘要信息

26:15.460 --> 26:16.460
它告诉你

26:16.460 --> 26:17.460
这个错误在哪里发生的

26:17.460 --> 26:20.460
app.js 11行发生的

26:20.460 --> 26:21.460
comp2 里边

26:21.460 --> 26:23.460
然后在 div 里边发生的

26:23.460 --> 26:24.460
就一层一层

26:24.460 --> 26:25.460
最终

26:25.460 --> 26:26.460
一层到最外层

26:26.460 --> 26:28.460
最底层是在这里发生的错误

26:28.460 --> 26:29.460
然后拨到 div

26:29.460 --> 26:31.460
div 拨到 comp1

26:31.460 --> 26:33.460
实际上我们这里的组件数没画完整

26:33.460 --> 26:35.460
实际上还有一些内置组件

26:35.460 --> 26:37.460
什么 div,he 这些组件都没画出来

26:37.460 --> 26:39.460
这个也拨到 error bound

26:39.460 --> 26:41.460
error bound 也拨到 div 也拨到 app

26:41.460 --> 26:43.460
对吧 它有个错误的摘要信息

26:43.460 --> 26:45.460
有这么一个错误的摘要信息

26:47.460 --> 26:49.460
那么你爱怎么用怎么用

26:49.460 --> 26:52.460
说这个函数一般用来做什么呢

26:52.460 --> 26:56.830
通常该函数用于

26:57.830 --> 26:59.830
记录错误消息

27:00.830 --> 27:02.830
就是把错误消息发送到服务器

27:02.830 --> 27:03.830
用 agax 发送到服务器

27:03.830 --> 27:05.830
让服务器把错误消息记录一下

27:05.830 --> 27:06.830
在什么时间点

27:06.830 --> 27:07.830
什么样的客服端

27:07.830 --> 27:08.830
出现了这样的一个问题

27:08.830 --> 27:09.830
你可以把它记录一下

27:09.830 --> 27:11.830
这个函数一般不会改变状态的

27:11.830 --> 27:14.830
那么上边这个函数一般是用于

27:14.830 --> 27:16.830
通常用

27:16.830 --> 27:19.830
该函数用于改变

27:19.830 --> 27:21.830
状态

27:21.830 --> 27:22.830
所以说这两个函数

27:22.830 --> 27:23.830
各有各的用处

27:23.830 --> 27:25.830
当然我们最核心的是改变状态

27:25.830 --> 27:26.830
因为只有改变状态来过后

27:26.830 --> 27:29.830
我们才能根据状态做不同的显示

27:29.830 --> 27:31.830
才能根据状态做不同的显示

27:31.830 --> 27:32.830
所以说我们这里

27:32.830 --> 27:35.830
这个函数的作用只是记录错误信息

27:35.830 --> 27:38.830
只是做这么一个记录就完成了

27:39.830 --> 27:41.830
这就是我们的错误边界

27:41.830 --> 27:43.830
就非常非常简单

27:43.830 --> 27:44.830
有了错误边界之后

27:44.830 --> 27:47.830
咱们就不会导致逐渐卸载掉了

27:47.830 --> 27:52.300
这里把它加上

27:52.300 --> 27:53.300
出现错误

27:53.300 --> 27:55.300
那么逐渐它就不会卸载掉了

27:55.300 --> 27:57.300
没问题吧

27:57.300 --> 27:59.300
OK

27:59.300 --> 28:01.300
那么咱们就这里

28:01.300 --> 28:04.300
就是这种处理方式

28:04.300 --> 28:06.300
这种处理方式

28:06.300 --> 28:08.300
另外我再说一个细节

28:10.300 --> 28:11.300
细节

28:11.300 --> 28:12.300
其实我们前面已经强调了

28:12.300 --> 28:13.300
只是

28:13.300 --> 28:14.300
前面已经说到了

28:14.300 --> 28:16.300
只是没有强调而已

28:16.300 --> 28:18.300
就是某些错误

28:18.300 --> 28:21.300
某些错误

28:21.300 --> 28:23.300
错误边界

28:23.300 --> 28:24.300
这个组件

28:24.300 --> 28:26.300
无法捕捉

28:26.300 --> 28:28.300
哪些错误呢

28:28.300 --> 28:30.300
也就是说这个函数它不会运行

28:30.300 --> 28:31.300
说白了

28:31.300 --> 28:36.080
就这个函数不会运行

28:36.080 --> 28:38.080
这个函数不会运行

28:38.080 --> 28:39.080
好

28:39.080 --> 28:40.080
哪些错误呢

28:40.080 --> 28:42.080
这个函数不会运行了

28:42.080 --> 28:43.080
第一个

28:43.080 --> 28:44.080
自身出现的错误

28:44.080 --> 28:45.080
是不是演示过了

28:45.080 --> 28:47.080
自身的错误

28:47.080 --> 28:48.080
你自身的错误

28:48.080 --> 28:50.080
它是不会运行的

28:50.080 --> 28:51.080
自身的错误

28:51.080 --> 28:53.080
像这些

28:53.080 --> 28:55.080
比方说自己在Render里面

28:55.080 --> 28:56.080
报了一个错

28:56.080 --> 28:57.080
它是不会运行的

28:57.080 --> 28:58.080
另外还有什么

28:58.080 --> 29:00.080
异步的错误

29:00.080 --> 29:01.080
异步的错误

29:01.080 --> 29:03.080
就是这个错误是异步发生的

29:03.080 --> 29:05.080
它不会运行

29:05.080 --> 29:06.080
比方说在Render的时候

29:06.080 --> 29:08.080
我们该是写成一个什么

29:08.080 --> 29:10.080
set timeout

29:10.080 --> 29:12.080
它本身植柱件没有错误

29:12.080 --> 29:13.080
假设植柱件没有错误

29:13.080 --> 29:15.080
把植柱件改一下

29:15.080 --> 29:17.080
copy一个

29:17.080 --> 29:19.080
假设植柱件没有错误

29:19.080 --> 29:21.080
正常显示的

29:21.080 --> 29:22.080
一切都正常

29:22.080 --> 29:23.080
ok 没有任何错误

29:23.080 --> 29:25.080
这个给它去掉

29:25.080 --> 29:26.080
那么

29:26.080 --> 29:28.080
它自身出了一个错误

29:28.080 --> 29:30.080
比方说一秒钟之后

29:30.080 --> 29:32.080
sure new error

29:32.080 --> 29:36.220
看一下

29:36.220 --> 29:38.220
这种情况下

29:38.220 --> 29:40.220
看一下

29:40.220 --> 29:42.220
你看整个组建书是不是全部出来了

29:42.220 --> 29:43.220
对吧

29:43.220 --> 29:45.220
整个组建书都全部出来了

29:45.220 --> 29:46.220
对不对

29:46.220 --> 29:47.220
它并没有

29:47.220 --> 29:48.220
它有没有运行这个函数

29:48.220 --> 29:50.220
我们来看一下有没有运行这个函数

29:50.220 --> 29:52.220
有没有补货到这个函数

29:52.220 --> 29:53.220
是没有

29:53.220 --> 29:54.220
没有补货到这个函数

29:54.220 --> 29:55.220
如果这个函数

29:55.220 --> 29:56.220
它不会处理这个问题

29:56.220 --> 29:57.220
异部的错误

29:57.220 --> 29:59.220
它不会处理

29:59.220 --> 30:01.220
然后我们再看

30:04.220 --> 30:06.220
还有一种情况

30:06.220 --> 30:08.220
就是

30:08.220 --> 30:13.220
事件中的错误

30:13.220 --> 30:14.220
事件中的错误

30:14.220 --> 30:15.220
比方说

30:15.220 --> 30:17.220
我们这里没有这个错误

30:17.220 --> 30:19.220
比方说这里没有这个错误

30:19.220 --> 30:21.220
然后错误在哪呢

30:21.220 --> 30:22.220
在这

30:23.220 --> 30:24.220
在comp2里边有一个

30:24.220 --> 30:25.220
有一个h1

30:25.220 --> 30:26.220
可以写个按钮

30:26.220 --> 30:27.220
点击事件

30:27.220 --> 30:28.220
onclick

30:28.220 --> 30:29.220
点击事件

30:29.220 --> 30:31.220
当点击的时候发生一个错误

30:31.220 --> 30:34.220
sure new error

30:34.220 --> 30:35.220
发生个错误

30:35.220 --> 30:36.220
点击的错

30:36.220 --> 30:39.220
点击时发生的错误

30:39.220 --> 30:40.220
保存

30:40.220 --> 30:42.220
你看一下

30:42.220 --> 30:44.220
当我们去点这个comp2的时候

30:44.220 --> 30:45.220
报了错了

30:45.220 --> 30:46.220
看没有

30:46.220 --> 30:47.220
报了错了

30:47.220 --> 30:49.220
那么我们的组建书在不在呢

30:49.220 --> 30:50.220
在

30:50.220 --> 30:51.220
组建书全部都在

30:51.220 --> 30:52.220
你看

30:52.220 --> 30:54.220
根本就没有运行我们的函数

30:54.220 --> 30:55.220
那个函数

30:55.220 --> 30:56.220
根本你看

30:56.220 --> 30:57.220
有没有输出这句话

30:57.220 --> 30:58.220
有没有输出这句话

30:58.220 --> 30:59.220
没有

30:59.220 --> 31:01.220
根本就没有运行这些函数

31:01.220 --> 31:02.220
这些函数

31:02.220 --> 31:03.220
这些错误是补货不到的

31:03.220 --> 31:04.220
所以说你像

31:04.220 --> 31:05.220
在这些错误里边改变状态

31:05.220 --> 31:06.220
让它去显示

31:06.220 --> 31:08.220
这个h1是不可能的

31:08.220 --> 31:09.220
是显示不了的

31:09.220 --> 31:11.220
你看这意思吧

31:11.220 --> 31:12.220
那么为什么呢

31:12.220 --> 31:13.220
它是这样子

31:13.220 --> 31:15.220
因为它跟它的规则有关系

31:15.220 --> 31:17.220
错误边界处理的是什么问题

31:17.220 --> 31:19.220
是渲染期间

31:19.220 --> 31:21.220
它处于渲染期间的话

31:21.220 --> 31:24.220
渲染期间渲染的整个过程是同步的

31:24.220 --> 31:26.220
渲染的整个过程是同步的

31:26.220 --> 31:28.220
那么渲染期间里边

31:28.220 --> 31:29.220
如果发生了异部的错误

31:29.220 --> 31:30.220
像这种

31:30.220 --> 31:31.220
它根本就不会管

31:31.220 --> 31:32.220
因为它会把同步代码

31:32.220 --> 31:33.220
运行完了之后

31:33.220 --> 31:34.220
才会去运行异部代码

31:34.220 --> 31:36.220
运行完了之后呢

31:36.220 --> 31:38.220
那么跟错误边界就没有什么关系了

31:38.220 --> 31:39.220
同样的

31:39.220 --> 31:41.220
事件处理里边发生的错误

31:41.220 --> 31:43.220
事件是不是在渲染的时候完成的

31:43.220 --> 31:44.220
不是

31:44.220 --> 31:46.220
事件有可能会导致重新渲染

31:46.220 --> 31:47.220
如果你说

31:47.220 --> 31:49.220
事件导致的重新渲染

31:49.220 --> 31:50.220
不要在事件里边

31:50.220 --> 31:51.220
一定要用的是吧

31:51.220 --> 31:52.220
ZSZSZ

31:52.220 --> 31:54.220
但是这里不能这样用

31:54.220 --> 31:55.220
一定要用这个函数

31:55.220 --> 31:57.220
那么导致了它有错误

31:57.220 --> 31:59.220
在重新渲染的时候有错误

31:59.220 --> 32:00.220
那我可以补货

32:00.220 --> 32:01.220
但是如果你事件

32:01.220 --> 32:02.220
本身里边发生的界式错误

32:02.220 --> 32:03.220
它是补货不到的

32:03.220 --> 32:06.220
它只会补货渲染期间的错误

32:08.220 --> 32:09.220
加个重点

32:09.220 --> 32:11.220
它只会补货渲染期间的错误

32:11.220 --> 32:12.220
所以说像这类类型的错误

32:12.220 --> 32:14.220
它不会补货

32:14.220 --> 32:15.220
那么这类型的错误

32:15.220 --> 32:17.220
如果你还是要做同样的事情怎么办呢

32:17.220 --> 32:19.220
那你老老实实用拆开起

32:19.220 --> 32:21.220
跟我们的rex没有什么关系

32:21.220 --> 32:23.220
老老实实用拆开起

32:23.220 --> 32:25.220
比方说你这里发生的错误

32:25.220 --> 32:26.220
你可以判断是不是有错误

32:26.220 --> 32:28.220
比方说你用拆开起

32:28.220 --> 32:30.220
拆开起

32:30.220 --> 32:31.220
有错误怎么办

32:31.220 --> 32:32.220
没有错误怎么办

32:32.220 --> 32:33.220
比方说它是个内组件

32:33.220 --> 32:34.220
有错误的话

32:34.220 --> 32:35.220
你做一个标志

32:35.220 --> 32:36.220
那么有错误的话怎么渲染

32:36.220 --> 32:37.220
没有错误怎么渲染

32:37.220 --> 32:39.220
你自己用拆开起就搞定

32:39.220 --> 32:41.220
它不给你做任何自行处理

32:41.220 --> 32:42.220
包括这边

32:42.220 --> 32:43.220
如果一部里边有错误

32:43.220 --> 32:44.220
自己用拆开起来处理

32:44.220 --> 32:46.220
它只处理在渲染期间的

32:46.220 --> 32:48.220
同步代码里边的错误

32:48.220 --> 32:50.220
或者说我们

32:50.220 --> 32:53.220
把这两句话总结

32:53.220 --> 32:55.220
总结就是什么

32:55.220 --> 32:58.220
就是仅处理

32:58.220 --> 33:02.220
渲染直主件期间的

33:02.220 --> 33:04.220
同步错误

33:04.220 --> 33:06.220
在渲染直主件期间

33:06.220 --> 33:07.220
因为渲染的过程是同步的

33:07.220 --> 33:09.220
那么在这个期间发生的错误

33:09.220 --> 33:11.220
它只处理这些错误

33:11.220 --> 33:14.220
这就是关于错误边界

33:14.220 --> 33:16.220
这是这么一个知识

33:16.220 --> 33:17.220
这个知识也没有什么demon可以练习

33:17.220 --> 33:18.220
就是我们这里练习一下就行了

33:18.220 --> 33:20.220
写这么一个公共主件

33:20.220 --> 33:22.220
你就写这么一个公共主件就行了

33:22.220 --> 33:24.220
那么到时候以后

33:24.220 --> 33:25.220
我们可能会用的

