WEBVTT

00:00.880 --> 00:05.420
好 我们接着来 接下来我们来开始写这个Effect来

00:05.420 --> 00:10.140
之前咱们做到这就是如果第一种情况就是它是一个Effect对象

00:10.140 --> 00:14.640
它就是通过这些函数传过来对吧 传过来一个Effect对象

00:14.640 --> 00:18.540
那么这边要根据不同的Effect对象去做不同的事情

00:18.540 --> 00:22.640
比方说你给我一个Put的Effect

00:22.640 --> 00:26.800
那么我就给干嘛呢 我就去触发一个Action

00:27.020 --> 00:30.700
你给我一个SnextEffect 我就给你一个状态

00:30.700 --> 00:33.320
根据不同的对象做不同的事

00:33.320 --> 00:37.660
那么这里你用脚响的话 你都知道这些代码肯定是比较多的

00:37.660 --> 00:42.860
所以说这一块我们又把分割出去 又形成了这么一个模块

00:42.860 --> 00:46.820
这个模块我给它取个名字 我给它取个名字叫做RoundEffect

00:46.820 --> 00:51.820
就是运行一个Effect 就处理一个Effect

00:51.820 --> 01:00.440
该模块主要用于处理一个Effect对象

01:00.440 --> 01:04.340
就是我拿到一个Effect对象之后 我干嘛 我该干嘛

01:04.340 --> 01:07.040
那么这里我们就这里就去调用这个函数

01:07.040 --> 01:09.980
比方这里我们去导出一个函数

01:09.980 --> 01:13.120
Default 方形 导出这么一个函数

01:13.120 --> 01:18.140
那么这边就很简单 我这里就去把函数导入进来

01:18.140 --> 01:25.540
就是RoundEffect from这里

01:25.540 --> 01:28.140
导出这个函数 然后我们这里去调用就完事了

01:28.140 --> 01:31.540
对了 调用就完事了 这里去调用就完事了

01:31.540 --> 01:35.340
那么调用的时候这个函数有没有参数呢 你想一想

01:35.340 --> 01:41.140
你想它在处理Effect的过程中 这个东西是不是要给它

01:41.140 --> 01:43.140
这个整个的环境里边的数据

01:43.140 --> 01:45.540
我们目前环境里边不就是一个仓库吗 对吧

01:45.540 --> 01:48.040
仓库得给它 比方说它要触发一个型

01:48.040 --> 01:50.540
那里不给它仓库它怎么触发一个型呢 对不对

01:50.540 --> 01:53.440
它Dispatch的函数都没有 它怎么来触发一个型呢

01:53.440 --> 01:57.640
所以说第一个参数呢 我们肯定要把这个东西给它

01:57.640 --> 02:00.540
所以说这边需要一个参数 第一个参数就是M

02:00.540 --> 02:04.540
表示我们的环境对象 我们一会儿拿出什么

02:04.540 --> 02:08.440
还有没有别的参数呢 你是不是要把Effect给它

02:08.440 --> 02:12.740
你把Effect对象要给它 你把Value要给它 对吧

02:12.740 --> 02:18.040
那么这里呢 还需要一个什么Effect 还需要这个东西

02:18.040 --> 02:21.640
好 那么它处理处理处理 它处理完了过后

02:21.640 --> 02:24.140
它最终是不是还是要调那个Next

02:24.140 --> 02:28.040
它会在一个合适的时间点 去调用 继续往下一步

02:28.040 --> 02:30.340
不然你处理的 你就处理一次吗

02:30.340 --> 02:34.140
你处理一次这个函数就结束了 后续就不会再处理了

02:34.140 --> 02:36.540
所以说你得继续下一步走

02:36.540 --> 02:38.540
因为任务管理 我这个任务处理完了

02:38.540 --> 02:41.340
这一次Eo的处理完了 我还得进行下一次

02:41.340 --> 02:43.640
所以说你还要给它传一个Next进去

02:43.640 --> 02:45.940
你要把这个Next函数本身给它传过去

02:45.940 --> 02:48.240
有Next函数本身要传过去 对吧

02:48.240 --> 02:49.940
要给它传这么三个函数

02:49.940 --> 02:53.240
好 那么这边呢 就是一个是环境对象

02:53.240 --> 02:55.540
一个是Effect 当然名字我取得不一样

02:55.540 --> 02:57.740
这边名字看上去更加合适一点

02:57.740 --> 02:59.740
第三个呢 就是一个回调函数

02:59.740 --> 03:02.140
回调函数CB 就是我处理完了过后

03:02.140 --> 03:04.140
或者就用Next嘛 也行

03:04.140 --> 03:06.540
处理完了过后要进行下一个步骤

03:06.540 --> 03:09.140
好 那么这里呢 打两个出示

03:09.140 --> 03:11.240
这个模块干嘛呢 这个模块就是

03:11.240 --> 03:15.340
处理一个Effect对象

03:15.340 --> 03:19.940
然后这里呢 就是环境 全局的环境对象

03:19.940 --> 03:24.140
然后Effect呢 就表示Effect对象

03:24.140 --> 03:25.540
Effect对象

03:25.540 --> 03:29.640
然后那个字呢 就是下一个任务

03:29.640 --> 03:32.940
下一个就是 下一个处理

03:32.940 --> 03:34.240
对吧 下一个处理 要进行

03:34.240 --> 03:35.640
当然合适的时间点过后呢

03:35.640 --> 03:37.140
我们要进行下一个处理

03:37.140 --> 03:39.140
对 我们这个函数就写好了

03:39.140 --> 03:40.840
好 那么这个函数里边要干嘛呢

03:40.840 --> 03:44.140
它就是根据不同的

03:44.140 --> 03:51.240
就是根据不同的Effect里边的Type值

03:51.240 --> 03:56.440
做不同的处理

03:56.440 --> 03:58.540
你看一下我们之前说过Effect

03:58.540 --> 04:00.040
我们之前创建的时候

04:00.040 --> 04:01.640
创建Effect的时候呢

04:01.640 --> 04:03.440
你是不是要CreatedEffect

04:03.440 --> 04:05.440
所以要给它 一定会给它一个Type值

04:05.440 --> 04:07.040
对不对 这个Type值里边呢

04:07.040 --> 04:08.840
它一共目前就这么写对吧

04:08.840 --> 04:10.140
这个Type值里边呢

04:10.140 --> 04:12.140
它就记录了我这个内雄是什么

04:12.140 --> 04:15.140
我这个处理的 我产生了什么样的Effect

04:15.140 --> 04:16.040
对吧 所以说呢

04:16.040 --> 04:18.540
我们这里呢 要根据它不同的Type值

04:18.540 --> 04:20.340
就做不同的处理

04:20.340 --> 04:21.540
好 那么比方说吧

04:21.540 --> 04:23.440
我们这里可以写出这么一种代码格式

04:23.440 --> 04:24.640
Switch

04:24.640 --> 04:26.840
什么呢 Effect 叫Type

04:26.840 --> 04:28.740
我看一下它的Type值是啥

04:28.740 --> 04:30.740
比方说我们第一个分支

04:30.740 --> 04:31.540
Type值是啥呢

04:31.540 --> 04:33.540
我们就可以把Types导入进来

04:33.540 --> 04:35.540
Import

04:35.540 --> 04:41.540
导入Effect Helper里边的Effect Types

04:41.540 --> 04:44.540
这里边不是所有的Types都在里边吗

04:44.540 --> 04:46.040
我们之前好像还写多了

04:46.040 --> 04:47.540
我们先写第一个嘛

04:47.540 --> 04:49.040
先写第一个 一个个写

04:49.040 --> 04:50.540
不着急

04:50.540 --> 04:51.540
Effect

04:51.540 --> 04:53.040
我们这里的一个个写

04:53.040 --> 04:54.040
我们先写个扩

04:54.040 --> 04:55.040
先写个扩

04:55.040 --> 04:56.540
只有一个扩

04:56.540 --> 04:58.540
好 那么这边到这边来

04:58.540 --> 05:01.040
好 这边是不是要判断一下

05:01.040 --> 05:02.040
它是不是等于扩

05:02.040 --> 05:03.540
对吧 是不是等于扩

05:03.540 --> 05:05.040
那么如果等于扩的话

05:05.040 --> 05:06.040
我们进行一些处理

05:06.040 --> 05:07.540
进行一些处理

05:07.540 --> 05:11.540
Break

05:11.540 --> 05:16.040
对 扩的处理

05:16.040 --> 05:17.040
好 那么这里报警告

05:17.040 --> 05:18.540
是因为你没有Switch

05:18.540 --> 05:20.540
你没有写Default

05:20.540 --> 05:21.540
Default的话就是

05:21.540 --> 05:22.540
它这些扩

05:22.540 --> 05:24.040
它这些类型都不满足

05:24.040 --> 05:25.040
对吧 都不满足

05:25.040 --> 05:26.040
我就报错了

05:26.040 --> 05:27.040
我就报错了

05:27.040 --> 05:29.040
New

05:29.040 --> 05:31.040
类型无效

05:31.040 --> 05:32.040
类型无效

05:32.040 --> 05:33.040
我就报错

05:33.040 --> 05:34.040
对吧 我们根据不同的Types

05:34.040 --> 05:35.040
做不同的处理

05:35.040 --> 05:36.540
那么目前我们Switch

05:36.540 --> 05:38.540
一个分支就是core

05:38.540 --> 05:40.040
好 那么这个core

05:40.040 --> 05:41.040
我怎么处理呢

05:41.040 --> 05:42.040
OK 那么这里

05:42.040 --> 05:43.040
那你想想这个逻辑

05:43.040 --> 05:45.040
就是想想一个代码格式

05:45.040 --> 05:46.540
如果说我把处理写到这儿

05:46.540 --> 05:48.040
把处理的逻辑全部写到这儿

05:48.040 --> 05:49.040
那一会这个函数

05:49.040 --> 05:50.040
是不是非常非常龐大

05:50.040 --> 05:51.040
对吧 一会有core

05:51.040 --> 05:52.040
一会有put

05:52.040 --> 05:54.040
还有各种各样的Effect Type

05:54.040 --> 05:55.040
不同的类型

05:55.040 --> 05:56.040
我要不同的处理

05:56.040 --> 05:57.040
处理的逻辑

05:57.040 --> 05:58.040
肯定越来越龐大

05:58.040 --> 06:00.040
所以说我们希望封装一下

06:00.040 --> 06:01.040
就是关于core

06:01.040 --> 06:03.040
我们专门来写这么一个东西

06:03.040 --> 06:04.040
就是专门来写个模块

06:04.040 --> 06:06.040
它来处理core这个东西

06:06.040 --> 06:08.040
同时它也可以用于

06:08.040 --> 06:10.040
产生一个core的Effect

06:10.040 --> 06:12.040
所以说我们这里新建文念夹

06:12.040 --> 06:13.040
就是Effect文念夹

06:13.040 --> 06:14.040
其实这个文念夹

06:14.040 --> 06:15.040
就相当于是什么呢

06:15.040 --> 06:16.040
相当于我们之前

06:16.040 --> 06:17.040
在用Saga的时候

06:17.040 --> 06:18.040
我们要导入Effect

06:18.040 --> 06:20.040
尤其它是Saga 斜槓Effect

06:20.040 --> 06:22.040
就相当于是这么一个文念夹

06:22.040 --> 06:23.040
这个文念夹里边

06:23.040 --> 06:25.040
有一个index.js

06:25.040 --> 06:26.040
这个js主要的作用

06:26.040 --> 06:27.040
是为了导出的

06:27.040 --> 06:29.040
为了做导出的

06:29.040 --> 06:30.040
那么这里边

06:30.040 --> 06:33.040
我们首先写上这么一个core

06:33.040 --> 06:35.040
我们写上第1个Effect

06:35.040 --> 06:36.040
这个文件做什么呢

06:36.040 --> 06:38.040
它第1件事情要做

06:38.040 --> 06:39.040
要做2件事情

06:39.040 --> 06:40.040
第1件事情要做

06:40.040 --> 06:44.040
就是提供一个core函数

06:44.040 --> 06:49.040
用于产生coreEffect

06:49.040 --> 06:50.040
用于产生

06:50.040 --> 06:51.040
我们雕用这个函数

06:51.040 --> 06:53.040
雕用这个core函数

06:53.040 --> 06:54.040
这个core函数

06:54.040 --> 06:55.040
它就会产生一个Effect

06:55.040 --> 06:56.040
对吧

06:56.040 --> 06:57.040
来做这么一件事情

06:57.040 --> 06:58.040
好 第2个

06:58.040 --> 07:00.040
它还要能够处理

07:00.040 --> 07:03.040
处理core的Effect

07:03.040 --> 07:05.040
因为跟core相关的所有事情

07:05.040 --> 07:06.040
都全部放到这

07:06.040 --> 07:07.040
对吧

07:07.040 --> 07:08.040
官方的文件结构

07:08.040 --> 07:09.040
是不是这样做的呢

07:09.040 --> 07:10.040
不是 它给你打包过后了

07:10.040 --> 07:11.040
它给你整合了

07:11.040 --> 07:12.040
打包过后整合了

07:12.040 --> 07:14.040
但是我都能够猜到

07:14.040 --> 07:16.040
官方应该提供了

07:16.040 --> 07:18.040
应该使用的是类似的做法

07:18.040 --> 07:19.040
那么这得把分模块

07:19.040 --> 07:21.040
因为这个core函数

07:21.040 --> 07:22.040
它提供Effect

07:22.040 --> 07:23.040
那么它提供Effect

07:23.040 --> 07:24.040
它是最清楚

07:24.040 --> 07:25.040
该怎么处理的

07:25.040 --> 07:26.040
OK 那么它这里

07:26.040 --> 07:27.040
要处理这个东西

07:27.040 --> 07:29.040
我们这里导出两个函数

07:29.040 --> 07:31.040
第一个函数是

07:31.040 --> 07:33.040
第一个函数是

07:33.040 --> 07:35.040
方形core函数

07:35.040 --> 07:37.040
导出这么一个core函数

07:37.040 --> 07:38.040
这个core函数用来干嘛呢

07:38.040 --> 07:40.040
用来产生core的Effect

07:40.040 --> 07:41.040
好 第2个

07:41.040 --> 07:42.040
我们还要导出一个函数

07:42.040 --> 07:44.040
就是叫做

07:44.040 --> 07:45.040
处理

07:45.040 --> 07:46.040
ROUND

07:46.040 --> 07:47.040
比方说ROUND

07:47.040 --> 07:49.040
core的Effect

07:49.040 --> 07:51.040
运行core的Effect

07:51.040 --> 07:53.040
提供这么两个函数

07:53.040 --> 07:54.040
我们一个个写

07:54.040 --> 07:55.040
首先这个函数

07:55.040 --> 07:56.040
这个函数我们一会儿

07:56.040 --> 07:58.040
肯定要在index里面导出

07:58.040 --> 08:01.040
index里面肯定要导出

08:01.040 --> 08:02.040
导出

08:02.040 --> 08:03.040
从来个模块

08:03.040 --> 08:04.040
从core这个模块

08:04.040 --> 08:05.040
导出一个什么呢

08:05.040 --> 08:06.040
导出一个core

08:06.040 --> 08:07.040
里面不是有个这个东西吗

08:07.040 --> 08:08.040
对不对

08:08.040 --> 08:09.040
把导出就完事了

08:09.040 --> 08:11.040
好 那么这样子一导出的话

08:11.040 --> 08:12.040
这样子一导出

08:12.040 --> 08:13.040
我们在一会儿再用

08:13.040 --> 08:14.040
再用这个saga的时候

08:14.040 --> 08:15.040
是不是就可以这样子使用了

08:15.040 --> 08:16.040
对吧

08:16.040 --> 08:17.040
你看着

08:17.040 --> 08:18.040
返回

08:18.040 --> 08:20.040
再返回

08:20.040 --> 08:22.040
对了

08:22.040 --> 08:23.040
是不是可以这样子使用了core

08:23.040 --> 08:24.040
对吧

08:24.040 --> 08:25.040
那么到时候

08:25.040 --> 08:26.040
我们一会儿

08:26.040 --> 08:27.040
一会儿测试的时候

08:27.040 --> 08:28.040
就比方说

08:28.040 --> 08:29.040
我们这里可以这样测试

08:29.040 --> 08:30.040
测试一下

08:30.040 --> 08:32.040
我们这里就resolve

08:32.040 --> 08:34.040
两秒钟过后

08:34.040 --> 08:35.040
resolve一个

08:35.040 --> 08:36.040
123

08:36.040 --> 08:37.040
随便写

08:37.040 --> 08:38.040
随便写

08:38.040 --> 08:39.040
那么这个函数

08:39.040 --> 08:40.040
这个函数不要了

08:40.040 --> 08:41.040
一会儿测试

08:41.040 --> 08:42.040
就这样测试

08:43.040 --> 08:44.040
一会儿这边

08:44.040 --> 08:45.040
我们这里就使用

08:45.040 --> 08:47.040
eal的什么core

08:47.040 --> 08:49.040
然后给它传一个函数

08:49.040 --> 08:50.040
对不对

08:50.040 --> 08:51.040
test

08:51.040 --> 08:52.040
这么一个函数

08:52.040 --> 08:53.040
test

08:53.040 --> 08:54.040
如果说这个函数

08:54.040 --> 08:55.040
有儿外的参数的话

08:55.040 --> 08:57.040
那么后面可以依持传递

08:57.040 --> 08:58.040
可以依持传递

08:58.040 --> 09:00.040
让它去调用这个函数

09:00.040 --> 09:01.040
调用这个函数

09:01.040 --> 09:02.040
然后给它传一个参数

09:04.040 --> 09:05.040
给它传一个参数

09:05.040 --> 09:07.040
比方说这里给它传一个abc

09:07.040 --> 09:09.040
那么这里resolve的时候

09:09.040 --> 09:10.040
把这个参数打印

09:10.040 --> 09:11.040
给它就行了

09:12.040 --> 09:13.040
随便测试一下

09:13.040 --> 09:14.040
随便测试一下

09:14.040 --> 09:15.040
eal的core

09:15.040 --> 09:16.040
那么这里

09:16.040 --> 09:17.040
返回的结果

09:17.040 --> 09:19.040
咱们来接受一下

09:19.040 --> 09:20.040
咱们来接受一下

09:21.040 --> 09:22.040
resolve

09:22.040 --> 09:23.040
返回的结果

09:23.040 --> 09:24.040
我们输出resolve

09:24.040 --> 09:26.040
我们期望的是什么呢

09:26.040 --> 09:27.040
期望的是

09:27.040 --> 09:28.040
它会输出一个abc

09:28.040 --> 09:29.040
为什么

09:29.040 --> 09:30.040
因为这里

09:30.040 --> 09:31.040
它里边用了一个就是

09:31.040 --> 09:33.040
eal得到一个promise

09:33.040 --> 09:35.040
运行这个函数

09:35.040 --> 09:36.040
得到一个promise

09:36.040 --> 09:37.040
promise它等到

09:37.040 --> 09:39.040
promise完成的时候

09:39.040 --> 09:40.040
它再把完成的结果

09:40.040 --> 09:41.040
放到这儿

09:41.040 --> 09:42.040
对吧

09:42.040 --> 09:43.040
放到这儿

09:43.040 --> 09:44.040
就这么个意思

09:44.040 --> 09:45.040
那么这个core

09:45.040 --> 09:46.040
你还要考虑到

09:46.040 --> 09:47.040
一个问题就是

09:47.040 --> 09:48.040
它还要给它一个contact

09:48.040 --> 09:49.040
对吧

09:49.040 --> 09:50.040
还要给它一个bunding

09:50.040 --> 09:52.040
bunding res对象进去

09:52.040 --> 09:53.040
也可以用这个模式来输写

09:53.040 --> 09:54.040
总之它这个core

09:54.040 --> 09:56.040
它总之会给你返回一个

09:56.040 --> 09:58.040
总之会给你返回一个

09:58.040 --> 09:59.040
就是这个东西

09:59.040 --> 10:00.040
arfex object

10:00.040 --> 10:02.040
那么你去处理

10:02.040 --> 10:03.040
好 接下来

10:03.040 --> 10:04.040
我们看一下怎么来写这个单码

10:04.040 --> 10:05.040
其实你这里的core

10:05.040 --> 10:06.040
你只要写出来一个

10:06.040 --> 10:07.040
后边的你大概都知道

10:07.040 --> 10:08.040
怎么写了

10:08.040 --> 10:09.040
好 那么这个core函数

10:09.040 --> 10:10.040
它首先接收参数

10:10.040 --> 10:12.040
是不是接收两个参数

10:12.040 --> 10:13.040
第一个参数

10:13.040 --> 10:15.040
是我们的函数fn

10:15.040 --> 10:17.040
第二个参数是剩余的参数

10:17.040 --> 10:18.040
我也不知道

10:18.040 --> 10:19.040
要传几个参数

10:19.040 --> 10:20.040
总之把参数给我传过来

10:20.040 --> 10:22.040
就是这个参数什么意思呢

10:22.040 --> 10:23.040
这个参数就是这个函数

10:23.040 --> 10:24.040
调用的时候

10:24.040 --> 10:25.040
需要得到的参数

10:25.040 --> 10:27.040
但是你要注意

10:27.040 --> 10:28.040
第一个参数

10:28.040 --> 10:30.040
它有可能是一个数组

10:30.040 --> 10:31.040
它有可能是一个数组

10:31.040 --> 10:32.040
如果它是一个数组的话

10:32.040 --> 10:34.040
数组的第一项表示

10:34.040 --> 10:35.040
bunding res

10:35.040 --> 10:36.040
第一项表示

10:36.040 --> 10:37.040
bunding res

10:37.040 --> 10:38.040
比方说我们这里写

10:38.040 --> 10:39.040
写这么一个res

10:39.040 --> 10:40.040
res的话

10:40.040 --> 10:42.040
一二三

10:42.040 --> 10:45.040
我们这里输出一下res

10:45.040 --> 10:46.040
你看着

10:46.040 --> 10:48.040
那么这里

10:49.040 --> 10:53.540
这样子写res指向

10:53.540 --> 10:54.540
这样子写

10:54.540 --> 10:55.540
第一个参数是res

10:55.540 --> 10:57.540
第二个数组的第二项

10:57.540 --> 10:58.540
才是函数

10:58.540 --> 10:59.540
所以说这里要判断一下

10:59.540 --> 11:00.540
我们定义两个变量

11:00.540 --> 11:01.540
什么变量

11:01.540 --> 11:03.540
第一个就是res的值

11:03.540 --> 11:05.540
res的值就是context

11:05.540 --> 11:07.540
res的指向默认为low

11:07.540 --> 11:09.540
就是res指向

11:09.540 --> 11:11.540
默认为low

11:11.540 --> 11:12.540
然后呢

11:12.540 --> 11:15.540
第二个就是函数

11:15.540 --> 11:16.540
要运行的函数

11:16.540 --> 11:17.540
运行的函数

11:17.540 --> 11:19.540
默认为fn

11:19.540 --> 11:21.540
默认为fn

11:21.540 --> 11:23.540
要运

11:23.540 --> 11:25.540
运行的

11:25.540 --> 11:28.540
运行的函数

11:28.540 --> 11:30.540
那么这里要判断一下

11:30.540 --> 11:32.540
就是说如果你不是一个函

11:32.540 --> 11:33.540
如果你这个fn

11:33.540 --> 11:34.540
传的不是一个数组的话

11:34.540 --> 11:35.540
那就是这种情况

11:35.540 --> 11:36.540
但是呢

11:36.540 --> 11:37.540
如果判断一下

11:37.540 --> 11:38.540
如果你res

11:38.540 --> 11:39.540
意思

11:39.540 --> 11:40.540
res

11:40.540 --> 11:41.540
如果你fn是数组的话

11:41.540 --> 11:42.540
那么这里要变动一下

11:42.540 --> 11:43.540
context等于

11:43.540 --> 11:45.540
数组的第一项

11:45.540 --> 11:46.540
然后呢

11:46.540 --> 11:47.540
你要运行的函数

11:47.540 --> 11:48.540
等于数组的第二项

11:48.540 --> 11:49.540
对吧

11:49.540 --> 11:50.540
你做个判断就行了

11:51.540 --> 11:55.540
res指向数组的第一项

11:56.540 --> 11:57.540
那么这里呢

11:57.540 --> 11:59.540
运行的函数

11:59.540 --> 12:02.540
指向数组的第二项

12:02.540 --> 12:03.540
对吧

12:03.540 --> 12:04.540
好最终

12:04.540 --> 12:05.540
我们最终是完成

12:05.540 --> 12:06.540
这两个属性的

12:06.540 --> 12:08.540
这两个东西的复词

12:08.540 --> 12:09.540
完成了之后

12:09.540 --> 12:10.540
这里要不要调用函数

12:10.540 --> 12:11.540
你想一想

12:11.540 --> 12:12.540
想想一个逻辑

12:12.540 --> 12:14.540
这里要不要调用函数

12:15.540 --> 12:16.540
要不要了

12:17.540 --> 12:18.540
是不要去调用函数

12:18.540 --> 12:20.540
你看一下这个图

12:20.540 --> 12:21.540
这里边的effect

12:21.540 --> 12:24.540
反回的始终是一个描述对象

12:24.540 --> 12:25.540
所以说呢

12:25.540 --> 12:26.540
我们这里最终返回的是啥

12:26.540 --> 12:27.540
返回的是不是

12:27.540 --> 12:29.540
哎我们给他导入一下

12:29.540 --> 12:30.540
导入一下

12:30.540 --> 12:31.540
导入那个我们之前写的

12:31.540 --> 12:33.540
creator effect

12:34.540 --> 12:35.540
这里

12:35.540 --> 12:36.540
之前我们不是写过一个函数吗

12:36.540 --> 12:37.540
creator effect

12:37.540 --> 12:38.540
对吧写过这么一个函数

12:38.540 --> 12:40.540
这个函数来创建一个effect

12:40.540 --> 12:41.540
你返回的是啥

12:41.540 --> 12:42.540
返回的就是这个函数

12:42.540 --> 12:44.540
创建的effect对象

12:44.540 --> 12:45.540
你给他一个啥

12:45.540 --> 12:46.540
给他一个内行

12:46.540 --> 12:47.540
effect内行

12:47.540 --> 12:48.540
内行是啥

12:48.540 --> 12:49.540
内行是不是

12:49.540 --> 12:50.540
我们通过那个effect tabs

12:50.540 --> 12:51.540
来拿到内行

12:51.540 --> 12:52.540
对不对

12:52.540 --> 12:53.540
内行是什么

12:53.540 --> 12:54.540
内行是call

12:54.540 --> 12:55.540
payload

12:55.540 --> 12:57.540
那么还要附加的信息是什么

12:57.540 --> 12:58.540
就是一会儿这边要处理的时候

12:58.540 --> 13:00.540
肯定要拿到这个附加信息

13:00.540 --> 13:01.540
附加信息是不是

13:01.540 --> 13:02.540
把这些东西传过去

13:02.540 --> 13:04.540
咱们写上这么一个对象

13:04.540 --> 13:05.540
写上这么一个对象

13:05.540 --> 13:06.540
附加信息

13:06.540 --> 13:07.540
好附加信息的话

13:07.540 --> 13:08.540
有什么呢

13:08.540 --> 13:09.540
比方说啊

13:09.540 --> 13:10.540
我们contact是该传进来

13:10.540 --> 13:12.540
我们要运行的函数

13:12.540 --> 13:13.540
fn该传进来

13:13.540 --> 13:15.540
这是我们要运行的函数

13:15.540 --> 13:16.540
用这个属性

13:16.540 --> 13:17.540
咱们用这个属性

13:17.540 --> 13:19.540
fn那么指向这个funk

13:19.540 --> 13:20.540
然后还有什么呢

13:20.540 --> 13:21.540
还有呢

13:21.540 --> 13:23.540
就是一个函数的参数

13:23.540 --> 13:24.540
对不对

13:24.540 --> 13:26.540
函数的参数给它传过去

13:26.540 --> 13:28.540
那么这边到时候要运行

13:28.540 --> 13:29.540
运行这个effect的时候

13:29.540 --> 13:31.540
是不是可以拿到这个东西了

13:31.540 --> 13:32.540
注意啊

13:32.540 --> 13:33.540
我们这个逻辑是

13:33.540 --> 13:34.540
这边的这个些函数

13:34.540 --> 13:36.540
它只返回一个描述对象

13:36.540 --> 13:37.540
它不做任何处理

13:37.540 --> 13:38.540
具体的处理

13:38.540 --> 13:39.540
是拿到这个描述对象之后

13:39.540 --> 13:41.540
我们来进行处理

13:41.540 --> 13:42.540
其实你可以去看一下

13:42.540 --> 13:44.540
那个官方那个

13:44.540 --> 13:45.540
就是call那个东西

13:45.540 --> 13:47.540
它其实也是这样返回的

13:47.540 --> 13:49.540
咱们就一会去看一下了

13:49.540 --> 13:50.540
一会看一下

13:50.540 --> 13:51.540
好那么咱们这里呢

13:51.540 --> 13:53.540
wrong call effect

13:53.540 --> 13:54.540
wrong call effect

13:54.540 --> 13:55.540
就算运行 effect

13:55.540 --> 13:57.540
那么这个时候就是在这边

13:57.540 --> 14:00.540
在wrong effect的时候

14:00.540 --> 14:01.540
当我们判断出

14:01.540 --> 14:04.540
你触发的effect是一个call的类型

14:04.540 --> 14:05.540
那么我们这里要干嘛

14:05.540 --> 14:07.540
是不是雕用call里边

14:07.540 --> 14:08.540
提供了这个函数啊

14:08.540 --> 14:09.540
雕用这个函数

14:09.540 --> 14:10.540
所以这个函数呢

14:10.540 --> 14:11.540
参数呢

14:11.540 --> 14:13.540
跟这边的参数是完全一样的

14:13.540 --> 14:15.540
是完全一样的

14:15.540 --> 14:17.540
就是把这边封装一下

14:17.540 --> 14:18.540
为什么要再说一次

14:18.540 --> 14:19.540
为什么要封装到这边

14:19.540 --> 14:21.540
因为它来产生一个call的effect

14:21.540 --> 14:23.540
它是最清楚该怎么来处理的

14:23.540 --> 14:25.540
准备把小字

14:25.540 --> 14:26.540
好那么到这边

14:26.540 --> 14:27.540
这边我们干嘛

14:27.540 --> 14:28.540
是不是把导入进来

14:28.540 --> 14:30.540
导入导入了一个什么

14:30.540 --> 14:33.540
导入了一个effect里边的

14:33.540 --> 14:35.540
effect里边的call

14:35.540 --> 14:37.540
它里边有一个叫做

14:38.540 --> 14:39.540
run call effect

14:39.540 --> 14:40.540
对吧

14:40.540 --> 14:41.540
导入这个函数

14:41.540 --> 14:42.540
那么我们这里呢

14:42.540 --> 14:43.540
干嘛

14:43.540 --> 14:44.540
我们干嘛

14:44.540 --> 14:45.540
是不是运行这个函数

14:45.540 --> 14:46.540
就完事了

14:46.540 --> 14:47.540
运行这个函数

14:47.540 --> 14:49.540
n effect 传过去

14:49.540 --> 14:50.540
那个是传过去

14:50.540 --> 14:52.540
运行这个函数就完事了

14:52.540 --> 14:53.540
没了

14:53.540 --> 14:54.540
这样的

14:54.540 --> 14:55.540
交给这个函数来处理

14:55.540 --> 14:56.540
对吧

14:56.540 --> 14:57.540
就写出来这么一种结构了

14:57.540 --> 14:58.540
好那么接下来

14:58.540 --> 14:59.540
我们在call里边进行处理

14:59.540 --> 15:01.540
那么我们在call里边怎么处理呢

15:01.540 --> 15:02.540
就像说

15:02.540 --> 15:03.540
我们这里输出一下

15:03.540 --> 15:05.540
输出一下这个n

15:05.540 --> 15:07.540
然后再输出一下这个effect

15:07.540 --> 15:08.540
再输出一下这个max

15:08.540 --> 15:09.540
我们来看一下

15:09.540 --> 15:10.540
这三个东西是什么东西

15:10.540 --> 15:11.540
保存

15:11.540 --> 15:13.540
你看着啊

15:13.540 --> 15:15.540
他说

15:15.540 --> 15:17.540
objects values

15:17.540 --> 15:18.540
include

15:18.540 --> 15:20.540
include写错了

15:20.540 --> 15:24.050
在那个

15:24.050 --> 15:25.050
这里边

15:25.050 --> 15:26.050
这里边写错了

15:26.050 --> 15:28.050
include

15:28.050 --> 15:31.320
好 保存

15:32.320 --> 15:33.320
好 你看一下

15:33.320 --> 15:36.320
那么这里是不是运行了这个函数了

15:36.320 --> 15:38.320
是不是运行了这个函数了

15:40.320 --> 15:41.320
是不是运行了这个函数了

15:41.320 --> 15:42.320
怎么运行的

15:42.320 --> 15:43.320
你看着啊

15:43.320 --> 15:44.320
我们再来重新捋一遍

15:44.320 --> 15:46.320
我们在这

15:46.320 --> 15:48.320
include

15:48.320 --> 15:50.320
那么一旦include的时候

15:50.320 --> 15:51.320
是不是把这个东西

15:51.320 --> 15:53.320
把这个函数的返回结构

15:53.320 --> 15:55.320
把这个函数返回结构交给谁了

15:55.320 --> 15:57.320
是不是交给那个就是

15:57.320 --> 15:59.320
john saga里边的这个

15:59.320 --> 16:00.320
next 是不是交给他了

16:00.320 --> 16:01.320
对不对

16:01.320 --> 16:02.320
交给他 他放到menu里边

16:02.320 --> 16:03.320
对吧

16:03.320 --> 16:04.320
他掉了next

16:04.320 --> 16:05.320
对吧

16:05.320 --> 16:06.320
掉了next

16:06.320 --> 16:07.320
然后得到一个result

16:07.320 --> 16:08.320
里边结构出value

16:08.320 --> 16:10.320
那么得到那个value

16:10.320 --> 16:11.320
那么判断这个value

16:11.320 --> 16:13.320
它由于它是一个effect对象

16:13.320 --> 16:14.320
所以说我们运行了wrong effect

16:14.320 --> 16:16.320
运行了这个函数

16:16.320 --> 16:17.320
而这个函数

16:17.320 --> 16:19.320
发现它的effect的类型是call

16:19.320 --> 16:20.320
所以说我们运行了call

16:20.320 --> 16:21.320
里边的这个函数

16:21.320 --> 16:22.320
是不是一层一层传过去了

16:22.320 --> 16:23.320
对吧

16:23.320 --> 16:24.320
一层一层

16:24.320 --> 16:26.320
所以一层一层传过去了

16:26.320 --> 16:27.320
好 传过去过后

16:27.320 --> 16:28.320
这里是不是得到

16:28.320 --> 16:29.320
可以得到这个effect

16:29.320 --> 16:30.320
对吧

16:30.320 --> 16:31.320
你看一下effect

16:31.320 --> 16:32.320
这是环境嘛

16:32.320 --> 16:33.320
环境里没个仓库

16:33.320 --> 16:34.320
这个没什么

16:34.320 --> 16:35.320
这是next函数

16:35.320 --> 16:36.320
然后这个东西是不是effect

16:36.320 --> 16:37.320
看一下effect

16:37.320 --> 16:38.320
对不对

16:38.320 --> 16:39.320
payload里面

16:39.320 --> 16:40.320
adjust就是我们的参数

16:40.320 --> 16:42.320
context 123

16:42.320 --> 16:43.320
fn 是不是这个玩意

16:43.320 --> 16:44.320
对吧

16:44.320 --> 16:46.320
咱们来试一下

16:46.320 --> 16:47.320
咱们来试一下那个

16:47.320 --> 16:49.320
就是它官方给我们

16:49.320 --> 16:50.320
提供那个effect

16:50.320 --> 16:52.320
是不是也是类似的结构呢

16:52.320 --> 16:54.320
咱们把这里

16:54.320 --> 16:55.320
写成官方的提供了effect

16:55.320 --> 16:57.320
这个call 保存

16:57.320 --> 16:58.320
然后打印一下

16:58.320 --> 16:59.320
我们看一下

16:59.320 --> 17:00.320
官方提供的call

17:00.320 --> 17:01.320
是不是多了一个这个属性

17:01.320 --> 17:02.320
这个属性

17:02.320 --> 17:03.320
对我们来说没什么用

17:03.320 --> 17:05.320
那你看是不是同样的结构

17:05.320 --> 17:06.320
payload

17:06.320 --> 17:07.320
context 123

17:07.320 --> 17:08.320
对不对

17:08.320 --> 17:09.320
fn就是我们的函数

17:09.320 --> 17:10.320
adjust就是我们的参数

17:10.320 --> 17:11.320
对吧

17:11.320 --> 17:12.320
就没了

17:12.320 --> 17:13.320
对吧

17:13.320 --> 17:14.320
就非常简单

17:14.320 --> 17:15.320
所以说

17:15.320 --> 17:16.320
而fig成的其实很简单

17:16.320 --> 17:18.320
它就产生这么一个对象就完事了

17:18.320 --> 17:20.320
具体的处理是在这里处理的

17:20.320 --> 17:21.320
那么这里怎么处理呢

17:21.320 --> 17:22.320
你看着吧

17:22.320 --> 17:23.320
我现在提供给你的什么

17:23.320 --> 17:24.320
内形是call

17:24.320 --> 17:26.320
反正你知道自己内形是call

17:26.320 --> 17:27.320
因为你写到这里面

17:27.320 --> 17:28.320
肯定处理的是call

17:28.320 --> 17:29.320
你不用判断了

17:29.320 --> 17:30.320
别人交给你的时候

17:30.320 --> 17:31.320
内形一定是call

17:31.320 --> 17:33.320
好 那你接下来怎么处理呢

17:33.320 --> 17:35.320
那你现在就要回忆一下

17:35.320 --> 17:37.320
call里边是不是要调用函数

17:37.320 --> 17:38.320
对吧

17:38.320 --> 17:39.320
调用什么函数

17:39.320 --> 17:41.320
调用call里边

17:41.320 --> 17:42.320
是不是调用这个地方

17:42.320 --> 17:43.320
传调的函数

17:43.320 --> 17:44.320
对吧

17:44.320 --> 17:45.320
那么这个函数放在哪的

17:45.320 --> 17:46.320
是不放在payload的

17:46.320 --> 17:47.320
fn里边了

17:47.320 --> 17:48.320
对吧

17:48.320 --> 17:49.320
参数也给力了

17:49.320 --> 17:50.320
是个数组

17:50.320 --> 17:51.320
参数放在数组里边

17:51.320 --> 17:52.320
所以说你要做的事情

17:52.320 --> 17:53.320
这个是绑定的riss

17:53.320 --> 17:54.320
对吧

17:54.320 --> 17:55.320
绑定的riss

17:55.320 --> 17:56.320
绑定要做的事情就简单了

17:56.320 --> 17:57.320
特别简单

17:57.320 --> 17:58.320
做什么事

17:58.320 --> 17:59.320
来告诉我怎么写

17:59.320 --> 18:02.320
而fig里边找到什么payload的

18:02.320 --> 18:05.320
找到什么fn

18:05.320 --> 18:06.320
然后调了它的call方法

18:06.320 --> 18:07.320
对不对

18:07.320 --> 18:08.320
调了它的call方法

18:08.320 --> 18:09.320
riss绑定啥

18:09.320 --> 18:11.320
绑定而fig的

18:11.320 --> 18:14.320
payload里边的context

18:14.320 --> 18:15.320
对吧

18:15.320 --> 18:16.320
绑定这个

18:16.320 --> 18:17.320
这就是riss的指向

18:17.320 --> 18:19.320
然后呢

18:19.320 --> 18:20.320
参数呢

18:20.320 --> 18:22.320
是不是展开而fig的

18:22.320 --> 18:24.320
payload的

18:24.320 --> 18:26.320
什么argues

18:26.320 --> 18:27.320
对不对

18:27.320 --> 18:28.320
当然你可以先解构嘛

18:28.320 --> 18:29.320
先解构也行

18:29.320 --> 18:30.320
解构

18:30.320 --> 18:31.320
结构context

18:31.320 --> 18:33.320
还有什么fn

18:33.320 --> 18:34.320
还有什么argues

18:34.320 --> 18:35.320
对吧

18:35.320 --> 18:36.320
通过fx

18:36.320 --> 18:37.320
payload里边的解构

18:37.320 --> 18:38.320
解构出来

18:38.320 --> 18:39.320
那么这里呢

18:39.320 --> 18:40.320
就可以简单的写了

18:40.320 --> 18:41.320
fncall

18:41.320 --> 18:42.320
call什么呢

18:42.320 --> 18:43.320
context

18:43.320 --> 18:44.320
这是riss的指向

18:44.320 --> 18:45.320
然后呢

18:45.320 --> 18:46.320
argues

18:46.320 --> 18:47.320
对吧

18:47.320 --> 18:48.320
这一件的

18:48.320 --> 18:49.320
运行

18:49.320 --> 18:50.320
运行出来过后呢

18:50.320 --> 18:52.320
是不是会得到一个结果

18:52.320 --> 18:53.320
这个函数运行了嘛

18:53.320 --> 18:54.320
运行了会

18:54.320 --> 18:55.320
是不是得到一个函数的结果

18:55.320 --> 18:56.320
对不对

18:56.320 --> 18:57.320
拿到这个函数结果过后

18:57.320 --> 18:59.320
还要进一步处理

18:59.320 --> 19:00.320
因为我们最终的目的是

19:00.320 --> 19:01.320
要调整它

19:01.320 --> 19:02.320
对吧

19:02.320 --> 19:03.320
然后交给下一个

19:03.320 --> 19:04.320
下一次那个时候

19:04.320 --> 19:05.320
往下继续处理了

19:05.320 --> 19:06.320
那么下一次处理的时候

19:06.320 --> 19:07.320
我们要传一个函数

19:07.320 --> 19:08.320
关键是在这

19:08.320 --> 19:09.320
好

19:09.320 --> 19:10.320
那么这个result

19:10.320 --> 19:11.320
就是函数调用

19:11.320 --> 19:12.320
调用函数得到结果

19:12.320 --> 19:14.320
调用函数

19:14.320 --> 19:17.320
得到函数的返回结果

19:17.320 --> 19:18.320
拿到这个返回结果过后

19:18.320 --> 19:20.320
我们要进行判断

19:20.320 --> 19:21.320
判断什么呢

19:21.320 --> 19:24.320
这个函数返回的是一个啥呢

19:24.320 --> 19:26.320
它如果是一个promise

19:26.320 --> 19:27.320
我们是不是要等待

19:27.320 --> 19:28.320
如果是一个普通函数

19:28.320 --> 19:30.320
我们就接着往后面走就行了

19:30.320 --> 19:31.320
所以说我们这里

19:31.320 --> 19:33.320
还要判断它是不是一个promise

19:33.320 --> 19:37.320
is promise from

19:37.320 --> 19:38.320
is promise

19:38.320 --> 19:41.320
判断它是不是一个promise

19:41.320 --> 19:42.320
如果说函数调用的结果

19:42.320 --> 19:44.320
is promise

19:44.320 --> 19:45.320
是一个promise的话

19:45.320 --> 19:46.320
怎么办

19:46.320 --> 19:47.320
是不是跟之前一样的处理方式

19:47.320 --> 19:49.320
之前我们写过类似的代码

19:49.320 --> 19:50.320
等一下

19:50.320 --> 19:51.320
等一下

19:51.320 --> 19:53.320
等到它就是promise完成之后

19:53.320 --> 19:54.320
得到的Values

19:54.320 --> 19:56.320
我们调用next

19:56.320 --> 19:57.320
把V传进去

19:57.320 --> 19:59.320
这是成功的情况

19:59.320 --> 20:00.320
那如果不成功

20:00.320 --> 20:02.320
就是为这个车开启的时候

20:02.320 --> 20:03.320
开启的时候

20:03.320 --> 20:05.320
那么它会有一个错误

20:05.320 --> 20:07.320
我们把这个错误调用next

20:07.320 --> 20:09.320
那么白柳就为

20:09.320 --> 20:11.320
错误就给它舔润

20:11.320 --> 20:12.320
对吧

20:12.320 --> 20:14.320
是不是就这么简单

20:14.320 --> 20:15.320
就这么简单

20:15.320 --> 20:16.320
完了

20:16.320 --> 20:17.320
这是promise的情况

20:17.320 --> 20:19.320
那么如果说是一个普通函数的话

20:19.320 --> 20:21.320
我们直接调用next

20:21.320 --> 20:22.320
把普通函数的返回结果

20:22.320 --> 20:24.320
给它传过去就行了

20:24.320 --> 20:26.320
这就是一个wrong core fix

20:26.320 --> 20:27.320
就写完了

20:27.320 --> 20:28.320
好好去理语一下

20:28.320 --> 20:29.320
我简单讲讲

20:29.320 --> 20:30.320
现在可以

20:30.320 --> 20:31.320
如果说你有点模糊的话

20:31.320 --> 20:32.320
再看一遍

20:32.320 --> 20:33.320
如果说你觉得差不多了

20:33.320 --> 20:34.320
你可以停下来

20:34.320 --> 20:35.320
先把它写好

20:35.320 --> 20:37.320
保证这一块没有什么问题

20:37.320 --> 20:38.320
那这里是确实

20:38.320 --> 20:39.320
确实没有用到这个n

20:39.320 --> 20:40.320
我们后边会用

20:40.320 --> 20:41.320
现在没有用到

20:41.320 --> 20:42.320
对吧

20:42.320 --> 20:44.320
那么这里就写好了

20:45.320 --> 20:46.320
好 这里写好了之后

20:46.320 --> 20:48.320
我们再回过头来看一下

20:48.320 --> 20:49.320
这一块能不能这样子

20:49.320 --> 20:50.320
这样子正常运行了呢

20:50.320 --> 20:51.320
能不能运行了呢

20:51.320 --> 20:52.320
我们看一下

20:52.320 --> 20:53.320
刷新

20:53.320 --> 20:54.320
你看

20:54.320 --> 20:56.320
你看z是否绑立进去了

20:56.320 --> 20:57.320
对吧

20:57.320 --> 20:58.320
等了3秒钟之后

20:58.320 --> 20:59.320
再输出这个abc

20:59.320 --> 21:00.320
对不对

21:00.320 --> 21:01.320
那么这里是e有了

21:01.320 --> 21:02.320
是不是可以帮你等待了

21:02.320 --> 21:03.320
对不对

21:03.320 --> 21:04.320
没问题吧

21:04.320 --> 21:06.320
这里z指向也绑立进去了

21:06.320 --> 21:07.320
对不对

21:07.320 --> 21:08.320
好 那我们再测试一下

21:08.320 --> 21:09.320
如果说不是这样传递的

21:09.320 --> 21:11.320
我们是直接传递test的

21:11.320 --> 21:13.320
那么z指向nau

21:13.320 --> 21:14.320
对吧

21:14.320 --> 21:15.320
然后3秒钟过后

21:15.320 --> 21:16.320
就到abc

21:16.320 --> 21:17.320
所以跟官方做的

21:17.320 --> 21:18.320
是不是一模一样的

21:18.320 --> 21:20.320
这是core

21:20.320 --> 21:22.320
那么这个core写出来了

21:22.320 --> 21:23.320
你会发现

21:23.320 --> 21:25.320
另外一个也出来了

21:25.320 --> 21:26.320
什么出来了

21:26.320 --> 21:27.320
delay就出来了

21:27.320 --> 21:28.320
什么apply我就不写了

21:28.320 --> 21:29.320
apply里面自己有写

21:29.320 --> 21:31.320
那个写法跟这个有啥区别呢

21:31.320 --> 21:32.320
无非它就是参数

21:32.320 --> 21:33.320
就是放了一声

21:33.320 --> 21:35.320
apply跟core的唯一区别

21:35.320 --> 21:36.320
就在于

21:36.320 --> 21:38.320
core呢

21:38.320 --> 21:39.320
core

21:39.320 --> 21:40.320
apply

21:40.320 --> 21:41.320
其他没有区别

21:41.320 --> 21:43.320
其他没有区别

21:43.320 --> 21:44.320
那么这个core做出来过后

21:44.320 --> 21:46.320
其实我们也可以做出一个

21:46.320 --> 21:47.320
delay

21:47.320 --> 21:48.320
延迟

21:48.320 --> 21:49.320
是不是可以做了

21:49.320 --> 21:51.320
延迟怎么做呢

21:51.320 --> 21:52.320
延迟呢这一块

21:52.320 --> 21:53.320
我不需要让它

21:53.320 --> 21:54.320
返回一个什么effects

21:54.320 --> 21:55.320
不需要

21:55.320 --> 21:57.320
我就去包装这个core

21:57.320 --> 21:59.320
就是利用这个core的功能

21:59.320 --> 22:00.320
返回就完事了

22:00.320 --> 22:02.320
所以说延迟就特别特别简单

22:02.320 --> 22:03.320
延迟怎么做

22:03.320 --> 22:04.320
你看着

22:04.320 --> 22:05.320
export

22:05.320 --> 22:06.320
导出一个

22:06.320 --> 22:07.320
方形

22:07.320 --> 22:08.320
delay

22:08.320 --> 22:09.320
延迟

22:09.320 --> 22:10.320
我都不需要去处理

22:10.320 --> 22:11.320
自己的函数了

22:11.320 --> 22:13.320
自己的就是那個

22:13.320 --> 22:14.320
effects

22:14.320 --> 22:15.320
它也不产生

22:15.320 --> 22:16.320
任何的effects对象

22:16.320 --> 22:18.320
因为延迟的本质

22:18.320 --> 22:20.320
你只需要产生一个啥对象

22:20.320 --> 22:22.320
是不是只需要产生一个core的

22:22.320 --> 22:23.320
effects就完事了

22:23.320 --> 22:24.320
对不对

22:24.320 --> 22:25.320
我们看着

22:25.320 --> 22:26.320
看一下怎么写

22:26.320 --> 22:27.320
看下怎么写

22:27.320 --> 22:29.320
这里传入一个delay

22:29.320 --> 22:31.320
传入一个delay

22:31.320 --> 22:33.320
要延迟多少好秒

22:33.320 --> 22:34.320
对不对

22:34.320 --> 22:35.320
我给你返回啥呢

22:35.320 --> 22:37.320
你看着

22:37.320 --> 22:43.270
这里我们导入core

22:43.270 --> 22:45.270
你看着我怎么做

22:45.270 --> 22:46.270
delay

22:46.270 --> 22:47.270
实际上我给你返回的是啥呢

22:47.270 --> 22:49.270
返回的是一个core

22:49.270 --> 22:51.270
返回的是一个core

22:51.270 --> 22:52.270
delay这个core

22:52.270 --> 22:54.270
那么这里不是要传一个函数吗

22:54.270 --> 22:55.270
对不对

22:55.270 --> 22:56.270
OK 我给你传一个函数

22:56.270 --> 22:59.270
我在这里给你传一个函数

22:59.270 --> 23:00.270
对不对

23:00.270 --> 23:01.270
传一个函数

23:01.270 --> 23:02.270
返回一个promise

23:02.270 --> 23:03.270
new promise

23:03.270 --> 23:05.270
resolve

23:05.270 --> 23:07.270
这个promise里面怎么写的

23:07.270 --> 23:09.270
set timeout

23:09.270 --> 23:11.270
指定的时间过后

23:11.270 --> 23:13.270
我去resolve一个东西

23:13.270 --> 23:15.270
resolve一个东西

23:15.270 --> 23:16.270
对不对

23:16.270 --> 23:17.270
就这样写

23:17.270 --> 23:18.270
没问题吧

23:18.270 --> 23:19.270
如果说你要delay

23:19.270 --> 23:20.270
还可以给它传参数

23:20.270 --> 23:22.270
如果说你要delay

23:22.270 --> 23:23.270
不用传数了

23:23.270 --> 23:24.270
resolve就完事了

23:24.270 --> 23:25.270
delay

23:25.270 --> 23:26.270
对吧

23:26.270 --> 23:28.270
我给你返回这么一个函数

23:28.270 --> 23:29.270
就是core的时候

23:29.270 --> 23:31.270
让它去调用这个函数

23:31.270 --> 23:33.270
这个函数让它去生成这么一个

23:33.270 --> 23:34.270
core的affect

23:34.270 --> 23:35.270
对吧

23:35.270 --> 23:36.270
就完了

23:36.270 --> 23:37.270
就完了

23:37.270 --> 23:38.270
没有人玩的函数

23:38.270 --> 23:39.270
对吧

23:39.270 --> 23:40.270
这就delay就写完了

23:40.270 --> 23:42.270
我还不用去生成任何的affect

23:42.270 --> 23:44.270
所以说我们这里

23:44.270 --> 23:47.270
我们这里就是在这里

23:47.270 --> 23:48.270
我们比方说

23:48.270 --> 23:49.270
我们使用delay

23:49.270 --> 23:50.270
导入delay

23:50.270 --> 23:54.480
现在我们把delay也导出

23:54.480 --> 23:56.790
delay

23:56.790 --> 23:58.790
导出delay

23:58.790 --> 24:00.790
把delay也导出

24:00.790 --> 24:02.790
那么我们这边使用delay

24:02.790 --> 24:04.790
看一下能不能实现效果

24:04.790 --> 24:06.790
我们一边看delay能不能实现效果

24:06.790 --> 24:08.790
一会儿再观察一下delay

24:08.790 --> 24:10.790
它产生的affect是啥

24:10.790 --> 24:13.790
这里我们

24:13.790 --> 24:19.680
再来一个就是delay

24:19.680 --> 24:21.680
这里写个1000

24:21.680 --> 24:23.680
一秒钟之后

24:23.680 --> 24:25.680
杀杀完成

24:25.680 --> 24:27.680
保存看一下吧

24:27.680 --> 24:29.680
首先3秒钟之后

24:29.680 --> 24:33.060
输出这个

24:33.060 --> 24:35.060
这里没用eo的

24:35.060 --> 24:37.060
保存

24:37.060 --> 24:39.060
abc再等一秒钟

24:39.060 --> 24:41.060
杀杀完成

24:41.060 --> 24:43.060
再来一次

24:43.060 --> 24:45.060
abc再来一秒钟

24:45.060 --> 24:46.060
杀杀完成

24:46.060 --> 24:47.060
好

24:47.060 --> 24:48.060
咱们来看一下

24:48.060 --> 24:49.060
delay返回的到底是啥

24:49.060 --> 24:50.060
delay返回的

24:50.060 --> 24:51.060
咱们这里

24:51.060 --> 24:53.060
直接调用delay

24:53.060 --> 24:54.060
不用eo的

24:54.060 --> 24:55.060
直接调用delay

24:55.060 --> 24:56.060
它会得到一个结果

24:56.060 --> 24:59.060
我们来输出一下

24:59.060 --> 25:00.060
输出一下

25:00.060 --> 25:01.060
这个delay的

25:01.060 --> 25:02.060
这个函数返回的结果

25:02.060 --> 25:04.060
返回的就是一个普通对象而已

25:04.060 --> 25:06.060
你看一下

25:06.060 --> 25:07.060
返回的是不是普通对象

25:07.060 --> 25:09.060
Payload里面

25:09.060 --> 25:10.060
包装了一个fn

25:10.060 --> 25:11.060
这个fn

25:11.060 --> 25:12.060
这个函数

25:12.060 --> 25:13.060
扣的函数

25:13.060 --> 25:14.060
是不是就是这个

25:14.060 --> 25:15.060
就这个函数

25:15.060 --> 25:16.060
对不对

25:16.060 --> 25:17.060
这个函数返回的

25:17.060 --> 25:19.060
由于它返回的是一个promise

25:19.060 --> 25:21.060
那么到时候处理这个扣的时候

25:21.060 --> 25:22.060
在扣进行处理的时候

25:22.060 --> 25:23.060
它会等这个promise完成

25:23.060 --> 25:24.060
这个promise

25:24.060 --> 25:25.060
它等待了一定的时间

25:25.060 --> 25:26.060
对吧

25:26.060 --> 25:27.060
所以说delay

25:27.060 --> 25:28.060
它本身没有力产生

25:28.060 --> 25:30.060
任何新的Effects

25:30.060 --> 25:31.060
那么其实这里

25:31.060 --> 25:32.060
我们也可以看一下

25:32.060 --> 25:34.060
官方给我们提供的delay

25:34.060 --> 25:36.060
完全一样

25:36.060 --> 25:38.060
你看

25:38.060 --> 25:39.060
好

25:39.060 --> 25:40.060
你看

25:40.060 --> 25:41.060
效果

25:41.060 --> 25:42.060
我们用官方的提供的Effects

25:42.060 --> 25:43.060
效果是完全一样的

25:43.060 --> 25:44.060
对吧

25:44.060 --> 25:45.060
你看

25:45.060 --> 25:46.060
效果完全一样

25:46.060 --> 25:47.060
对吧

25:47.060 --> 25:48.060
这是官方提供的Effects

25:48.060 --> 25:49.060
你看官方提供的delay

25:49.060 --> 25:50.060
这个Effects

25:50.060 --> 25:51.060
得到的结果是啥

25:51.060 --> 25:52.060
还是个core

25:52.060 --> 25:53.060
所以delay

25:53.060 --> 25:54.060
它相当于是一个

25:54.060 --> 25:55.060
给你

25:55.060 --> 25:56.060
也比较余法堂

25:56.060 --> 25:57.060
给你封装了一下

25:57.060 --> 25:58.060
其实就是给你封装一下

25:58.060 --> 26:00.060
本质用的还是这个core

26:00.060 --> 26:03.060
这是关于delay

26:03.060 --> 26:04.060
这个delay

26:04.060 --> 26:05.060
这个delay就出来了

26:05.060 --> 26:06.060
对吧

26:06.060 --> 26:07.060
咱们就继续看

26:07.060 --> 26:08.060
继续看

26:08.060 --> 26:09.060
现在我们

26:09.060 --> 26:10.060
把写好了就打个

26:10.060 --> 26:11.060
打个勾

26:11.060 --> 26:12.060
勾

26:12.060 --> 26:14.690
还有这个玩意

26:14.690 --> 26:15.690
这是啥

26:15.690 --> 26:16.690
表示写好了

26:16.690 --> 26:18.690
我们就跟这个表示写好了

26:18.690 --> 26:19.690
core写好了

26:19.690 --> 26:20.690
Apply不用写了

26:20.690 --> 26:21.690
你自己写就完了

26:21.690 --> 26:22.690
delay我们也写好了

26:23.690 --> 26:24.690
今天我们也写好了

26:24.690 --> 26:25.690
那么现在我们写了

26:25.690 --> 26:26.690
一个

26:26.690 --> 26:27.690
我们写Poot

26:27.690 --> 26:29.690
和Snag

26:29.690 --> 26:30.690
咱们来写一个Poot的Effects

26:30.690 --> 26:32.690
那么现在多了Effects内容了

26:32.690 --> 26:33.690
所以说我们要在这里

26:33.690 --> 26:35.690
要加一个内容

26:35.690 --> 26:37.690
加一个内容

26:37.690 --> 26:38.690
叫做Poot

26:38.690 --> 26:42.770
一会还有什么

26:42.770 --> 26:43.770
还有那个就是

26:45.770 --> 26:46.770
Snag

26:46.770 --> 26:47.770
把这两个写了

26:47.770 --> 26:51.420
Snag

26:51.420 --> 26:52.420
就这两个

26:53.420 --> 26:54.420
把写了

26:55.420 --> 26:57.420
然后这里边加了这个

26:57.420 --> 26:58.420
我们这里是不是要建两个文件

26:58.420 --> 27:01.420
一个是Poot.js

27:01.420 --> 27:05.420
一个是Snag.js

27:05.420 --> 27:06.420
那么In这个词里边

27:06.420 --> 27:07.420
是不是要导出

27:07.420 --> 27:09.420
要导出一个是Effects

27:10.420 --> 27:11.420
一个是Snag

27:11.420 --> 27:14.420
一个是Poot

27:15.420 --> 27:16.420
一个是Snag

27:16.420 --> 27:17.420
一个是Poot

27:18.420 --> 27:19.420
对吧

27:19.420 --> 27:20.420
导出这两个

27:20.420 --> 27:22.420
然后同样的道理

27:22.420 --> 27:23.420
同样的道理

27:23.420 --> 27:24.420
我们在Poot里边

27:24.420 --> 27:26.420
是不是要写两个函数

27:26.420 --> 27:27.420
一个是Poot

27:27.420 --> 27:28.420
一个第一个函数

27:28.420 --> 27:29.420
第一个函数就是Poot

27:29.420 --> 27:30.420
对吧

27:30.420 --> 27:31.420
Poot

27:31.420 --> 27:32.420
我们先不知道去写函数

27:32.420 --> 27:33.420
第二个函数是

27:33.420 --> 27:37.420
一个叫做WrongPootEffects

27:37.420 --> 27:39.420
是运行PootEffects的

27:39.420 --> 27:40.420
那么这个函数的函数

27:40.420 --> 27:41.420
是固定的

27:41.420 --> 27:42.420
跟我们之前扣了一样

27:42.420 --> 27:43.420
就这个

27:43.420 --> 27:47.500
这三个函数

27:47.500 --> 27:48.500
这是Poot

27:48.500 --> 27:49.500
对吧

27:49.500 --> 27:50.500
好 那么Poot写好了

27:50.500 --> 27:51.500
Snag是不是也可以

27:51.500 --> 27:52.500
一样的

27:52.500 --> 27:53.500
Snag

27:53.500 --> 27:54.500
我们一会再具体的做

27:54.500 --> 27:56.500
这里是WrongSnag

27:56.500 --> 27:57.500
Effects

27:57.500 --> 27:58.500
好 那么这里写写好了之后

27:58.500 --> 28:00.500
我们到WrongEffects里边

28:00.500 --> 28:01.500
是不是可以改造了对他

28:01.500 --> 28:03.500
好 刚才我们判断了Core

28:03.500 --> 28:04.500
那么现在呢

28:04.500 --> 28:05.500
还要判断两个

28:06.500 --> 28:08.940
我一直写错了

28:09.940 --> 28:10.940
好 是不是还要判断两个

28:10.940 --> 28:11.940
一个是什么呢

28:11.940 --> 28:12.940
一个是Poot

28:12.940 --> 28:14.940
好 一个是Snag

28:14.940 --> 28:15.940
Snag

28:15.940 --> 28:16.940
对吧

28:16.940 --> 28:17.940
好 那么这里

28:17.940 --> 28:19.940
那么这里是不是要导入

28:19.940 --> 28:20.940
对吧 导入

28:20.940 --> 28:22.940
一个是WrongPoot

28:23.940 --> 28:25.940
这里是Poot

28:25.940 --> 28:27.940
这里是Snag

28:27.940 --> 28:30.940
一个是WrongPootEffects

28:30.940 --> 28:34.940
一个是WrongSnagEffects

28:34.940 --> 28:35.940
好 我们这里

28:35.940 --> 28:37.940
WrongPootEffects

28:37.940 --> 28:39.940
这里WrongSnagEffects

28:39.940 --> 28:41.940
这是对Poot的处理

28:42.940 --> 28:44.940
这是对Snag的处理

28:44.940 --> 28:45.940
对吧

28:45.940 --> 28:46.940
这边就只是负责

28:46.940 --> 28:48.940
根据不同的情况去调整就完了

28:48.940 --> 28:50.940
传令的参数都是一样的

28:51.940 --> 28:52.940
好 那么现在呢

28:52.940 --> 28:54.940
我们来写这里边的东西

28:54.940 --> 28:56.940
首先让我们Poot

28:56.940 --> 28:58.940
Poot这里面我们回忆一下

28:58.940 --> 29:00.940
这里面传的是不是Action

29:00.940 --> 29:01.940
对吧 是要触发

29:01.940 --> 29:02.940
Poot的作用是什么

29:02.940 --> 29:04.940
触发一个Action

29:05.940 --> 29:06.940
Poot的作用是触发一个Action

29:06.940 --> 29:07.940
对吧

29:07.940 --> 29:09.940
那这里是不是要传一个Action对象进来

29:09.940 --> 29:10.940
对不对

29:10.940 --> 29:11.940
要传一个Action对象进来

29:11.940 --> 29:13.940
那么传一个Action对象进来

29:13.940 --> 29:14.940
那么我这干嘛呢

29:14.940 --> 29:15.940
这里要不要触发

29:15.940 --> 29:17.940
这个函数里面要不要触发

29:17.940 --> 29:18.940
不触发

29:18.940 --> 29:19.940
这个函数

29:19.940 --> 29:20.940
它的作用是什么呢

29:20.940 --> 29:22.940
它只是为了产生一个Effect

29:22.940 --> 29:23.940
Object

29:23.940 --> 29:25.940
只是为了产生这么一个玩意

29:25.940 --> 29:26.940
你看这个意思吧

29:26.940 --> 29:28.940
它本身是不做任何触发的

29:28.940 --> 29:29.940
它不去做任何处理

29:29.940 --> 29:31.940
它只是产生一个Effect

29:31.940 --> 29:32.940
Object

29:32.940 --> 29:33.940
所以我们这里是不是又要调用那个

29:33.940 --> 29:35.940
调用这个玩意

29:35.940 --> 29:36.940
对吧

29:36.940 --> 29:37.940
倒进来

29:37.940 --> 29:38.940
我们这里返回什么呢

29:38.940 --> 29:40.940
返回CreateEffect

29:40.940 --> 29:41.940
创建Effect

29:41.940 --> 29:42.940
内存是什么呢

29:42.940 --> 29:43.940
EffectsTab

29:43.940 --> 29:45.940
使用Poot内存

29:45.940 --> 29:47.940
你看我们之前写到这么一个

29:47.940 --> 29:48.940
调量之后呢

29:48.940 --> 29:50.940
我们就可以反复的用这里面的属性

29:50.940 --> 29:51.940
就避免了什么

29:51.940 --> 29:53.940
避免了就是去写死了

29:53.940 --> 29:55.940
到时候我们要改内存的名字的话

29:55.940 --> 29:56.940
就不好改了

29:56.940 --> 29:57.940
那么Painload

29:57.940 --> 29:58.940
Painload是什么

29:58.940 --> 30:00.940
Painload我们直接把这个Action

30:00.940 --> 30:01.940
把它喘过去一玩意儿了

30:01.940 --> 30:03.940
直接把Action打喘过去

30:03.940 --> 30:04.940
喘到Painload的里面

30:04.940 --> 30:05.940
那么当我们去运行

30:05.940 --> 30:07.940
这个Poot而Fact的时候

30:07.940 --> 30:09.940
是不是我们就可以取出这个Action

30:09.940 --> 30:10.940
对吧

30:10.940 --> 30:11.940
是不是可以取出Action

30:11.940 --> 30:12.940
而Fact

30:12.940 --> 30:14.940
调什么Painload

30:14.940 --> 30:15.940
调Action

30:15.940 --> 30:16.940
是不是可以取出来

30:16.940 --> 30:17.940
对吧

30:17.940 --> 30:18.940
说可以取出来

30:18.940 --> 30:19.940
好

30:19.940 --> 30:21.940
那么取出来了过后

30:21.940 --> 30:23.940
取出来过后

30:23.940 --> 30:25.940
我们是不是要触发这个Action

30:25.940 --> 30:26.940
对吧

30:26.940 --> 30:28.940
是不是要触发这个Action

30:28.940 --> 30:29.940
好

30:29.940 --> 30:31.940
那么要触发这个Action

30:31.940 --> 30:32.940
怎么来触发呢

30:32.940 --> 30:33.940
怎么来触发

30:33.940 --> 30:34.940
是不是

30:34.940 --> 30:35.940
环境里边

30:35.940 --> 30:36.940
这个M里边

30:36.940 --> 30:37.940
还记得吗

30:37.940 --> 30:38.940
我们有一个Storm

30:38.940 --> 30:39.940
对不对

30:39.940 --> 30:40.940
现在是不是有用了

30:40.940 --> 30:41.940
它里边不是一个Dispatch

30:41.940 --> 30:42.940
对吧

30:42.940 --> 30:43.940
把Action来去触发就完事了

30:43.940 --> 30:44.940
就触发Action

30:44.940 --> 30:45.940
就触发了

30:45.940 --> 30:46.940
就触发了

30:46.940 --> 30:48.940
我把这个Dispatch的返回结果

30:48.940 --> 30:50.940
我把这个Dispatch的返回结果

30:50.940 --> 30:52.940
给你作为参数

30:52.940 --> 30:53.940
给你传过来

30:53.940 --> 30:55.940
这是这个Dispatch的返回结果

30:55.940 --> 30:57.940
然后触发完了过后就完了

30:57.940 --> 30:58.940
触发完了过后

30:58.940 --> 30:59.940
我们就调到Next

30:59.940 --> 31:00.940
把这个什么

31:00.940 --> 31:02.940
把这个就是返回结果

31:06.940 --> 31:07.940
把这个返回结果

31:07.940 --> 31:08.940
放进来

31:08.940 --> 31:09.940
就完事了

31:09.940 --> 31:10.940
调到Next

31:10.940 --> 31:11.940
放进来就完事了

31:11.940 --> 31:13.940
那就这么简单

31:13.940 --> 31:14.940
就这么简单

31:14.940 --> 31:15.940
没了

31:15.940 --> 31:16.940
你看一下

31:16.940 --> 31:17.940
POOT是不特别简单

31:17.940 --> 31:19.940
触发一个Action就完事了

31:19.940 --> 31:20.940
好

31:20.940 --> 31:21.940
咱们试一下

31:21.940 --> 31:22.940
试一下看能不能用

31:22.940 --> 31:24.940
然后我们到这边来

31:24.940 --> 31:26.940
到这个Saga

31:26.940 --> 31:27.940
这边来

31:27.940 --> 31:29.940
我们这里就保持个不动

31:29.940 --> 31:31.940
我们现在再导入一个POOT

31:31.940 --> 31:33.940
POOT

31:33.940 --> 31:35.940
我们比方说

31:35.940 --> 31:36.940
我们这里

31:36.940 --> 31:38.940
其实就已经可以做这个效果了

31:38.940 --> 31:40.940
Think Increase

31:40.940 --> 31:42.940
可以做这个效果了

31:43.940 --> 31:45.940
Think Increase

31:45.940 --> 31:46.940
不需要传参数

31:46.940 --> 31:48.940
不需要传参数

31:49.940 --> 31:51.940
然后我们看一下

31:51.940 --> 31:53.940
Think Increase

31:53.940 --> 31:54.940
我们这样子

31:54.940 --> 31:57.580
我们这样子

31:57.580 --> 31:58.580
不行

31:58.580 --> 31:59.580
不行

31:59.580 --> 32:00.580
我们现在还不能监控

32:00.580 --> 32:01.580
Action对吧

32:01.580 --> 32:02.580
还不能监听Action

32:02.580 --> 32:03.580
还没有写take

32:03.580 --> 32:04.580
无所谓

32:04.580 --> 32:05.580
我们一开始就来

32:05.580 --> 32:07.580
就直接来

32:07.580 --> 32:09.580
让它隔一段时间过后

32:09.580 --> 32:11.580
隔一段时间过后去触发

32:11.580 --> 32:13.580
那么咱们这里

32:14.580 --> 32:16.580
不需要扣

32:16.580 --> 32:17.580
地内

32:17.580 --> 32:18.580
算了

32:18.580 --> 32:20.580
我们还是把这个保存一下

32:20.580 --> 32:27.150
还是把这个保存一下

32:27.150 --> 32:28.150
保存一下

32:28.150 --> 32:31.150
这里我们就不需要这个扣了

32:32.150 --> 32:34.150
我们让它延迟

32:34.150 --> 32:35.150
三秒钟

32:35.150 --> 32:36.150
三秒钟延迟过后

32:36.150 --> 32:38.150
我们去触发一个Action

32:39.150 --> 32:40.150
延迟三秒钟

32:40.150 --> 32:42.150
去触发一个Action

32:42.150 --> 32:44.150
这里我们是用POOT

32:44.150 --> 32:45.150
来触发Action

32:45.150 --> 32:46.150
一有的POOT

32:46.150 --> 32:47.150
触发Action

32:47.150 --> 32:48.150
在哪呢

32:48.150 --> 32:49.150
我们可以通过

32:49.150 --> 32:53.360
找到之前的Action

32:53.360 --> 32:54.360
Action

32:54.360 --> 32:56.360
Counter

32:56.360 --> 32:57.360
好

32:57.360 --> 32:59.360
这里边让我们找到Increase

32:59.360 --> 33:00.360
Increase

33:00.360 --> 33:01.360
对吧

33:01.360 --> 33:02.360
好

33:02.360 --> 33:03.360
没问题吧

33:03.360 --> 33:04.360
那么整理

33:04.360 --> 33:05.360
我们POOT一个是吗

33:05.360 --> 33:06.360
Increase

33:06.360 --> 33:07.360
Increase

33:07.360 --> 33:08.360
好

33:08.360 --> 33:09.360
试一下

33:09.360 --> 33:10.360
保存

33:10.360 --> 33:11.360
你看着

33:11.360 --> 33:12.360
三秒钟之后

33:12.360 --> 33:13.360
它触发一个Action

33:13.360 --> 33:14.360
你看是不是触发了

33:14.360 --> 33:15.360
对吧

33:15.360 --> 33:16.360
那么Saga结束了

33:16.360 --> 33:17.360
因为后面没有什么任务了

33:17.360 --> 33:18.360
当然这里

33:18.360 --> 33:19.360
比方说我要不断的触发

33:19.360 --> 33:20.360
不断的触发

33:20.360 --> 33:22.360
那么这里写个使讯环

33:22.360 --> 33:23.360
对吧

33:23.360 --> 33:24.360
也很简单

33:24.360 --> 33:25.360
保存

33:25.360 --> 33:26.360
你看呀

33:26.360 --> 33:28.360
三秒钟之后

33:28.360 --> 33:29.360
触发一次

33:30.360 --> 33:31.360
三秒钟之后

33:31.360 --> 33:32.360
再触发一次

33:32.360 --> 33:33.360
对吧

33:33.360 --> 33:34.360
所以写个使讯环

33:34.360 --> 33:36.360
所以可以搞定了

33:36.360 --> 33:37.360
对不对

33:37.360 --> 33:38.360
非常简单

33:38.360 --> 33:39.360
这是关于POOT

33:40.360 --> 33:41.360
好

33:41.360 --> 33:42.360
接下来它是Sennect

33:42.360 --> 33:43.360
Sennect

33:43.360 --> 33:44.360
Sennect是用来干嘛的

33:44.360 --> 33:45.360
回忆一下

33:45.360 --> 33:46.360
Sennect

33:46.360 --> 33:49.360
在得到当前仓库里面的数据的

33:49.360 --> 33:51.360
这个东西也特别简单

33:51.360 --> 33:52.360
Sennect

33:52.360 --> 33:54.360
Sennect 这里当什么回忆一下

33:54.360 --> 33:55.360
有没有参数呢

33:55.360 --> 33:56.360
有一个参数

33:56.360 --> 33:57.360
它可以传一个函数进来

33:57.360 --> 33:59.360
当时我们是这样子用的

33:59.360 --> 34:02.990
回忆一下

34:02.990 --> 34:04.990
这里我们触发一个Action

34:04.990 --> 34:05.990
触发Action过后

34:05.990 --> 34:07.990
我们现在要得到仓库里面的数据

34:07.990 --> 34:09.990
这里比方说有个Sennect

34:09.990 --> 34:11.990
我们可以通过Sennect

34:11.990 --> 34:13.990
得到仓库里面的数据

34:13.990 --> 34:14.990
State

34:14.990 --> 34:16.990
来自于Sennect

34:16.990 --> 34:18.990
Eld

34:18.990 --> 34:20.990
Sennect

34:20.990 --> 34:22.990
可以得到仓库里面的数据

34:22.990 --> 34:24.990
这是得到整个仓库里面的数据

34:24.990 --> 34:26.990
也可以传一个参数

34:26.990 --> 34:28.990
那么这个人先做一次筛选

34:28.990 --> 34:30.990
把整个仓库数据传给你

34:30.990 --> 34:32.990
然后以返回的东西

34:32.990 --> 34:34.990
我作为结果放到这

34:34.990 --> 34:36.990
那么这里也可以做一个筛选

34:36.990 --> 34:38.990
比方说State点Counter

34:38.990 --> 34:40.990
是不是可以做个筛选

34:40.990 --> 34:41.990
对吧

34:41.990 --> 34:44.990
这里我们也可以打印出State

34:44.990 --> 34:46.990
对吧

34:46.990 --> 34:48.990
那么这里也可以

34:48.990 --> 34:50.990
这里也是可以的

34:50.990 --> 34:52.990
所以说我们这一块

34:52.990 --> 34:53.990
使用Sennect

34:53.990 --> 34:55.990
无论这里边传不传函数

34:55.990 --> 34:56.990
我们都要进行处理

34:56.990 --> 34:59.990
所以说这里有可能会传一个函数进来

34:59.990 --> 35:01.990
那么这里怎么处理呢

35:01.990 --> 35:02.990
非常简单

35:02.990 --> 35:04.990
我要给它返回这么一个东西

35:04.990 --> 35:06.990
最终我还是要返回一个

35:06.990 --> 35:07.990
Effects对象

35:07.990 --> 35:09.990
这是毫无疑问的

35:09.990 --> 35:11.990
我返回的最终一定是一个Effects对象

35:11.990 --> 35:14.990
我们一定是调用CreateEffects

35:14.990 --> 35:15.990
然后内形该传进去

35:15.990 --> 35:16.990
EffectsTaps

35:16.990 --> 35:18.990
调这个Sennect

35:18.990 --> 35:19.990
这个内形该传进去

35:19.990 --> 35:21.990
然后Panel里边写啥呢

35:21.990 --> 35:24.990
关键是Panel里边写啥呢

35:24.990 --> 35:28.990
Panel里边是不是就写上那个就是

35:28.990 --> 35:30.990
我们运行的函数

35:30.990 --> 35:31.990
对不对

35:31.990 --> 35:32.990
这个函数有没有值

35:32.990 --> 35:33.990
有没有值

35:33.990 --> 35:34.990
总之把这个函数写过去

35:34.990 --> 35:35.990
Fn

35:35.990 --> 35:36.990
Funk

35:36.990 --> 35:37.990
对吧

35:37.990 --> 35:39.990
把这个函数给它

35:39.990 --> 35:40.990
还有啥呢

35:40.990 --> 35:41.990
那就没了

35:41.990 --> 35:42.990
就特别简单

35:42.990 --> 35:43.990
Sennect就是这个东西

35:43.990 --> 35:44.990
对吧

35:44.990 --> 35:45.990
就这个东西

35:45.990 --> 35:46.990
好

35:46.990 --> 35:47.990
那么到时候

35:47.990 --> 35:48.990
我们调用Sennect的时候

35:48.990 --> 35:49.990
看怎么调用

35:49.990 --> 35:50.990
怎么调用

35:50.990 --> 35:52.990
是不是调用这个函数

35:52.990 --> 35:53.990
对吧

35:53.990 --> 35:54.990
调用这个函数

35:54.990 --> 35:55.990
那么有这个函数的话

35:55.990 --> 35:56.990
就调用这个函数

35:56.990 --> 35:57.990
没有这个函数的话

35:57.990 --> 35:58.990
我们就把整个仓库

35:58.990 --> 35:59.990
往后面传进来

35:59.990 --> 36:00.990
所以我们这里先得到

36:00.990 --> 36:02.990
整个仓库的数据

36:02.990 --> 36:04.990
来自于MStore

36:04.990 --> 36:06.990
仓库里边是不是有GetState

36:06.990 --> 36:07.990
对吧

36:07.990 --> 36:09.990
我们可以得到整个仓库的数据

36:09.990 --> 36:12.990
整个仓库的数据

36:12.990 --> 36:14.990
那么如果说它没有这个函数

36:14.990 --> 36:16.990
没有给我传函数据来的话

36:16.990 --> 36:17.990
那么很简单

36:17.990 --> 36:19.990
我到时候就直接调用那个式了

36:19.990 --> 36:20.990
把这个仓库数据传进去

36:20.990 --> 36:21.990
对吧

36:21.990 --> 36:22.990
仓库数据传进去

36:22.990 --> 36:23.990
你看一下

36:23.990 --> 36:24.990
是不是这里就达到整个仓库数据了

36:24.990 --> 36:25.990
对吧

36:25.990 --> 36:26.990
所以说

36:26.990 --> 36:28.990
如果没有这个函数就特别简单

36:28.990 --> 36:29.990
如果有这个函数

36:29.990 --> 36:30.990
也特别简单

36:30.990 --> 36:32.990
如果说有这个函数

36:32.990 --> 36:33.990
Panode里边

36:33.990 --> 36:34.990
有这个State

36:34.990 --> 36:35.990
有这个Fn

36:35.990 --> 36:37.990
有这个函数怎么办呢

36:37.990 --> 36:38.990
有这个函数

36:38.990 --> 36:40.990
就去DIO用一下这个函数

36:40.990 --> 36:41.990
把整个

36:41.990 --> 36:43.990
你看这个函数是怎么写的

36:43.990 --> 36:44.990
这个函数是不是传一个

36:44.990 --> 36:45.990
整个仓库进去

36:45.990 --> 36:46.990
它返回一个结果

36:46.990 --> 36:47.990
对吧

36:47.990 --> 36:49.990
我把整个仓库的数据传给你

36:49.990 --> 36:50.990
然后你返回的结果

36:50.990 --> 36:51.990
我重新给这个State复制

36:51.990 --> 36:53.990
最终还是把这个State

36:53.990 --> 36:54.990
给下一步

36:54.990 --> 36:55.990
对吧

36:55.990 --> 36:56.990
就完了

36:56.990 --> 36:57.990
什么那个时候也非常好写

36:57.990 --> 36:58.990
咱们来看一下

36:58.990 --> 36:59.990
看一下

36:59.990 --> 37:01.990
我们这里还是加个while2

37:01.990 --> 37:04.990
while2

37:04.990 --> 37:06.990
把这个放进来

37:06.990 --> 37:09.500
保存

37:09.500 --> 37:10.500
你看一下

37:10.500 --> 37:11.500
三秒钟过后

37:11.500 --> 37:13.500
我们不但可以得到

37:13.500 --> 37:14.500
仓库

37:14.500 --> 37:15.500
还可以得到

37:15.500 --> 37:16.500
不但可以出发Ight

37:16.500 --> 37:17.500
还可以得到仓库里边的数据

37:17.500 --> 37:18.500
Counter

37:18.500 --> 37:19.500
对不对

37:19.500 --> 37:21.500
那如果说我不写这个

37:21.500 --> 37:22.500
不写这个

37:22.500 --> 37:25.500
那么还得到整个仓库的数据

37:25.500 --> 37:27.500
看一下

37:27.500 --> 37:28.500
对吧

37:28.500 --> 37:30.500
整个仓库的数据

37:30.500 --> 37:31.500
对不对

37:31.500 --> 37:32.500
你看

37:32.500 --> 37:33.500
是不是这样子

37:33.500 --> 37:35.500
看没

37:35.500 --> 37:36.500
这就是

37:36.500 --> 37:37.500
这就是这个

37:37.500 --> 37:38.500
Snag车

37:38.500 --> 37:39.500
对吧

37:39.500 --> 37:41.500
像这种模式写出来过后

37:41.500 --> 37:43.500
你是不是就觉得非常非常简单了

37:43.500 --> 37:47.600
好

37:47.600 --> 37:48.600
就这几个

37:48.600 --> 37:49.600
然后想一想

37:49.600 --> 37:50.600
我们这几个

37:50.600 --> 37:51.600
肯定还讲不完

37:51.600 --> 37:52.600
下一个还有这些

37:52.600 --> 37:53.600
这些比较复杂的

37:53.600 --> 37:55.600
然后想一想

37:55.600 --> 37:56.600
还有啥呢

37:56.600 --> 37:57.600
还有啥呢

37:57.600 --> 37:58.600
我们之前用过

37:58.600 --> 38:00.600
Fix里边还有啥呢

38:00.600 --> 38:04.360
我想想

38:04.360 --> 38:05.360
好像就

38:05.360 --> 38:06.360
就没啥了

38:06.360 --> 38:07.360
就没啥了

38:07.360 --> 38:08.360
就是我们这几个

38:08.360 --> 38:10.360
就简单讲了这么四个

38:10.360 --> 38:12.360
现在把它的结构给它写出来了

38:12.360 --> 38:13.360
关键是这个结构

38:13.360 --> 38:14.360
你写出一个结构过后

38:14.360 --> 38:16.360
后面就可以不断的扩展了

38:16.360 --> 38:17.360
比较到以后

38:17.360 --> 38:19.360
Saga里边加了新的Fix

38:19.360 --> 38:20.360
是不是很简单

38:20.360 --> 38:21.360
很轻松就可以扩展了

38:21.360 --> 38:22.360
把这个结构写出来

38:22.360 --> 38:23.360
说咱们学原代码

38:23.360 --> 38:26.360
学的不是它原本是怎么写的

38:26.360 --> 38:28.360
这个还真不是很重要

38:28.360 --> 38:29.360
重要是学它的那种

38:29.360 --> 38:31.360
思路和处理逻辑

38:31.360 --> 38:32.360
好

38:32.360 --> 38:33.360
那么接下来

38:33.360 --> 38:34.360
这节课写完了过后

38:34.360 --> 38:35.360
大家也可以把这个代码

38:35.360 --> 38:37.360
自己去写一遍

38:37.360 --> 38:38.360
好

38:38.360 --> 38:39.360
谢谢大家

