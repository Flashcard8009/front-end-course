WEBVTT

00:00.820 --> 00:04.820
Hello 大家好 这一集我们来说简单快速排序

00:04.820 --> 00:07.820
提到快排很多人就开始有兴趣了 是吧

00:07.820 --> 00:10.820
我也想学快排 但是事先说好

00:10.820 --> 00:16.820
快排是现在绝大多数同学都看不懂的

00:16.820 --> 00:18.820
我讲了你也未必能看得懂

00:18.820 --> 00:21.820
为什么在这讲呢 因为这块讲排序了

00:21.820 --> 00:25.820
这个东西必须得随着你的变成的思维的加深

00:25.820 --> 00:27.820
对代码的熟练度的增高

00:27.820 --> 00:29.820
你才能逐渐的能看得懂的一个做算法

00:29.820 --> 00:33.820
所以它是个硬坎 你拿的没有办法

00:33.820 --> 00:37.820
所以说当你想去一个好一点的公司的话

00:37.820 --> 00:39.820
这个就是一个硬性的基本功

00:39.820 --> 00:43.820
不然的话你这个很难进的去

00:43.820 --> 00:47.820
快排是一个非常符合变成思维的一个变成思想

00:47.820 --> 00:49.820
非常符合变成思维的

00:49.820 --> 00:51.820
因为它不像冒泡选择一样

00:51.820 --> 00:54.820
它都是冒泡和选择都是人在操作 是吧

00:54.820 --> 00:57.820
我找出一个最小的放这 找出一个最大的放这 是吧

00:57.820 --> 00:58.820
都是这样的

00:58.820 --> 01:00.820
还不是 快排很随意

01:00.820 --> 01:02.820
我随便拿出来的第一个

01:02.820 --> 01:06.820
就是说 这是讲说这个数字就一个班机

01:06.820 --> 01:08.820
你就是班长了

01:08.820 --> 01:10.820
然后没班长发话了

01:10.820 --> 01:14.820
比我小的站我左边 比我大的站我右边

01:14.820 --> 01:16.820
比我小的站我左边

01:16.820 --> 01:24.820
一 三 二 六 九 八 七 是吧

01:24.820 --> 01:26.820
大概是这样的一坨 是吧

01:26.820 --> 01:27.820
随便放

01:27.820 --> 01:30.820
比他小的站我左边 比他大的站你右边

01:30.820 --> 01:32.820
那好了 大家都站好了

01:32.820 --> 01:34.820
抬头的当组长

01:34.820 --> 01:37.820
那你这个一就是组长了 对吧

01:37.820 --> 01:40.820
一说了 比我小的站左边 比我大的站右边

01:40.820 --> 01:42.820
发现三个二 我觉得都比你大

01:42.820 --> 01:44.820
然后六当组长 是吧

01:44.820 --> 01:47.820
说比我小的站我左边 比我大的都站我右边

01:47.820 --> 01:49.820
然后发现都比他的

01:49.820 --> 01:53.820
这两个组长 名副其实是小组长 是吧

01:53.820 --> 01:59.820
然后三 每一个小组分成这么多个小队

01:59.820 --> 02:03.820
然后三说比我小的站左边 比我大的站右边

02:03.820 --> 02:05.820
二就站在这 对吧

02:05.820 --> 02:08.820
然后九是一个抬头 变成小队长

02:08.820 --> 02:12.820
九小队长说比我小的站左边 比我大的站右边

02:12.820 --> 02:16.190
变成了这样的小组

02:16.190 --> 02:17.190
对吧

02:17.190 --> 02:20.190
然后八是一个小队的两个队员了 是吧

02:20.190 --> 02:22.190
他俩又有个先来后到 是吧

02:23.190 --> 02:25.190
咱俩拜个把子 是吧

02:25.190 --> 02:28.190
然后比我小的话就站过左边 比我大的站我右边

02:28.190 --> 02:30.190
七就站在这

02:30.190 --> 02:33.190
然后你最后你做一个垂眼 你看到

02:33.190 --> 02:35.190
合应上去了之后

02:35.190 --> 02:36.190
一二三 是吧

02:36.190 --> 02:38.190
因为二在三的左边 最左边一

02:38.190 --> 02:42.190
然后二 然后三 然后四 五 六

02:42.190 --> 02:43.190
是吧

02:43.190 --> 02:45.190
八和七 比他小 是吧

02:45.190 --> 02:47.190
站在左边

02:47.190 --> 02:50.190
六 然后七 八就 排完续

02:50.190 --> 02:52.190
我们发现整个的过程中

02:52.190 --> 02:54.190
没有说最小的放在最前面

02:54.190 --> 02:56.190
最大的放在最后面的过程

02:56.190 --> 02:58.190
都是小的站左 大的站右

02:58.190 --> 03:01.190
这就是快排的一个思路

03:01.190 --> 03:03.190
这是一个快排的思路 记住这句话

03:03.190 --> 03:06.190
这是快排的思路 不是快排的算法

03:06.190 --> 03:08.190
这是快排的思路

03:08.190 --> 03:11.190
你可以用这个思路去实现一个算法

03:11.190 --> 03:13.190
可以用这个思路去实现一个算法

03:13.190 --> 03:15.190
我们可以先来实现一个

03:15.190 --> 03:19.190
我来给大家写的算法都是我划减之后的

03:19.190 --> 03:21.190
如果你想看圆版

03:21.190 --> 03:24.190
推荐你去看算法讨论

03:24.190 --> 03:29.140
如果你想看圆版

03:29.140 --> 03:33.900
看算法的完全版

03:33.900 --> 03:36.900
推荐大概大家去看算法讨论

03:36.900 --> 03:38.900
这本书能看懂的同学

03:38.900 --> 03:40.900
不超过0.5成

03:40.900 --> 03:42.900
有20个同学里面

03:42.900 --> 03:44.900
有一个人能看得懂

03:44.900 --> 03:46.900
就算不非常不错

03:46.900 --> 03:48.900
几乎是大家很难看得懂的

03:48.900 --> 03:49.900
如果你都能看得懂了

03:49.900 --> 03:51.900
我就直接让你去看那本书就得了

03:51.900 --> 03:53.900
我不会录这个课

03:53.900 --> 03:55.900
这个课上我写的绝大多数的算法

03:55.900 --> 03:57.900
都是我优化之后的

03:57.900 --> 03:59.900
能够让大家看得懂

03:59.900 --> 04:01.900
如果我优化之后的代码

04:01.900 --> 04:04.900
你要是还是觉得看不懂

04:04.900 --> 04:07.900
那就证明基础有点太弱了

04:07.900 --> 04:09.900
就需要多练习了

04:09.900 --> 04:12.900
这种基础就必须得多练习

04:12.900 --> 04:14.900
才能练出

04:14.900 --> 04:15.900
代码量少

04:15.900 --> 04:19.900
是一定学不好算法的

04:19.900 --> 04:21.900
所以说这个东西必须得练

04:21.900 --> 04:23.900
每一个东西都得给的练习物

04:23.900 --> 04:25.900
尤其是基础的东西

04:25.900 --> 04:27.900
好了,咱们来写一个

04:27.900 --> 04:32.240
加四文件

04:32.240 --> 04:36.240
我有一个数组

04:36.240 --> 04:43.370
问一个AR

04:43.370 --> 04:45.370
这个数组还是这个

04:45.370 --> 04:49.000
41693287

04:49.000 --> 04:56.000
41693287

04:56.000 --> 04:57.000
这样的一个数组

04:57.000 --> 05:00.000
然后我们希望对这个数组

05:00.000 --> 05:01.000
进行排序

05:01.000 --> 05:03.000
然后我们要进行快排

05:03.000 --> 05:08.040
我写一个快排

05:08.040 --> 05:10.040
亏个算是

05:10.040 --> 05:12.040
快排的名字

05:12.040 --> 05:13.040
传出这个

05:13.040 --> 05:16.040
看好了

05:16.040 --> 05:17.040
我要干嘛

05:17.040 --> 05:19.040
第一步先选什么

05:19.040 --> 05:21.040
第一步选班长

05:21.040 --> 05:24.250
是吧

05:24.250 --> 05:26.250
然后小的站左边

05:26.250 --> 05:27.250
大的站右边

05:27.250 --> 05:28.250
是吧

05:28.250 --> 05:31.250
小的站左边

05:32.250 --> 05:34.250
大的站右边是吧

05:34.250 --> 05:36.250
大的站右边

05:36.250 --> 05:42.250
对吧

05:42.250 --> 05:44.250
就是现在是左边都比我小

05:44.250 --> 05:45.250
右边都比我大是吧

05:45.250 --> 05:46.250
然后我再对左边进行排序

05:46.250 --> 05:48.250
再对右边进行排序就行

05:48.250 --> 05:49.250
对吧

05:49.250 --> 05:50.250
先选班长

05:50.250 --> 05:51.250
谁是班长

05:51.250 --> 05:53.250
问一个Leader

05:53.250 --> 05:54.250
谁是班长

05:54.250 --> 05:56.250
AR0是吧

05:56.250 --> 05:57.250
但是别忘了

05:57.250 --> 05:58.250
算法

05:58.250 --> 05:59.250
一定要

05:59.250 --> 06:00.250
怎么样

06:00.250 --> 06:03.010
必须得

06:03.010 --> 06:05.010
是不是必须得严谨性判断的

06:05.010 --> 06:08.010
AR

06:08.010 --> 06:10.010
如果AR等于空

06:10.010 --> 06:12.010
或者是

06:12.010 --> 06:16.830
或者是AR的烂词

06:16.830 --> 06:17.830
等于0

06:17.830 --> 06:20.830
我就直接

06:20.830 --> 06:22.830
return

06:22.830 --> 06:24.830
空

06:24.830 --> 06:26.830
return一个空数组

06:30.400 --> 06:32.400
那我先选择一个Leader

06:32.400 --> 06:33.400
当它不为空的时候

06:33.400 --> 06:34.400
0就是Leader

06:34.400 --> 06:36.400
然后小的站左边

06:36.400 --> 06:37.400
大的站右边

06:37.400 --> 06:39.400
那我要做一个Leader

06:39.400 --> 06:41.840
是个数组

06:41.840 --> 06:42.840
是吧

06:42.840 --> 06:43.840
那做一个Ret

06:43.840 --> 06:45.840
也是一个数组

06:45.840 --> 06:46.840
是吧

06:46.840 --> 06:47.840
小的站左边

06:47.840 --> 06:48.840
大的站右边

06:48.840 --> 06:49.840
怎么站

06:49.840 --> 06:50.840
风凶完

06:50.840 --> 06:51.840
对吧

06:51.840 --> 06:52.840
0号位

06:52.840 --> 06:53.840
已经被它给站了

06:53.840 --> 06:54.840
所以I等于谁

06:54.840 --> 06:57.840
I等于1是吧

06:57.840 --> 06:58.840
然后

06:58.840 --> 07:02.840
I小于AR的烂词

07:07.240 --> 07:09.240
如果

07:09.240 --> 07:10.240
AR

07:10.240 --> 07:13.240
I小于

07:13.240 --> 07:14.240
Leader

07:14.240 --> 07:15.240
比它小是吧

07:15.240 --> 07:17.240
怎么站左边是吧

07:17.240 --> 07:19.240
Leader的Push

07:19.240 --> 07:22.240
对吧

07:22.240 --> 07:23.240
否则呢

07:23.240 --> 07:25.240
就是大于等于的

07:25.240 --> 07:26.240
是吧

07:26.240 --> 07:28.240
AR

07:28.240 --> 07:32.240
Ret的Push

07:32.240 --> 07:35.680
这样的话

07:35.680 --> 07:36.680
循环之后

07:36.680 --> 07:37.680
我们就能得到

07:37.680 --> 07:38.680
左边一个数组

07:38.680 --> 07:39.680
右边一个数组

07:39.680 --> 07:41.680
然后我怎么返回

07:41.680 --> 07:42.680
return

07:42.680 --> 07:44.680
怎么样

07:44.680 --> 07:47.680
我们给它拼接起来是吧

07:47.680 --> 07:50.680
左边加上中间的

07:50.680 --> 07:51.680
加上Ret是吧

07:51.680 --> 07:54.680
比如说Leader加上Leader

07:54.680 --> 07:56.680
加上Ret

07:56.680 --> 07:58.680
是不是就是我们要返回的结果

07:58.680 --> 08:00.680
但是我们这是数组

08:00.680 --> 08:02.680
数组没有这些方法

08:02.680 --> 08:04.680
我们数组有什么方法

08:04.680 --> 08:08.820
数组有什么方法

08:08.820 --> 08:10.820
比如说我有一个数组

08:10.820 --> 08:12.820
123

08:12.820 --> 08:14.820
我想和另一个数组连接

08:14.820 --> 08:18.580
康泰的是吧

08:18.580 --> 08:20.580
比如说连一个456

08:20.580 --> 08:21.580
是吧

08:21.580 --> 08:22.580
用康泰的方法

08:22.580 --> 08:23.580
对吧

08:23.580 --> 08:25.580
所以说我应该用什么

08:25.580 --> 08:28.580
Leader的Push

08:28.580 --> 08:34.200
先把Leader给加进去

08:34.200 --> 08:36.200
Leader的Push

08:36.200 --> 08:37.200
Leader

08:37.200 --> 08:38.200
是吧

08:38.200 --> 08:39.200
给它加到最后了

08:39.200 --> 08:40.200
然后我们return是谁

08:40.200 --> 08:41.200
return

08:41.200 --> 08:43.200
Leader的康泰

08:43.200 --> 08:48.590
Right

08:48.590 --> 08:53.930
Leader的康泰

08:53.930 --> 08:54.930
是吧

08:54.930 --> 08:56.930
这个是比4小的

08:56.930 --> 08:58.930
拼上4再加上一个比4大的

08:58.930 --> 08:59.930
是吧

08:59.930 --> 09:02.930
console了点

09:02.930 --> 09:03.930
log

09:03.930 --> 09:05.930
什么quick salt

09:05.930 --> 09:06.930
ar

09:06.930 --> 09:07.930
你看一下

09:07.930 --> 09:08.930
现在这会有什么样的结果

09:08.930 --> 09:10.930
我们先拿到一个什么样的结果

09:10.930 --> 09:11.930
4在中间是吧

09:11.930 --> 09:13.930
比4小都在左边

09:13.930 --> 09:14.930
比4大都在右边是吧

09:14.930 --> 09:16.930
但是左边不是有趣的

09:16.930 --> 09:17.930
右边呢

09:17.930 --> 09:18.930
它还不是有趣的

09:18.930 --> 09:19.930
对吧

09:19.930 --> 09:21.930
所以我得怎么办

09:21.930 --> 09:22.930
左边的也变得有趣

09:22.930 --> 09:24.930
live的等于什么

09:24.930 --> 09:26.930
再掉下自己quick salt live

09:26.930 --> 09:28.930
把左边的排了

09:28.930 --> 09:31.930
right再掉下自己

09:31.930 --> 09:36.520
把右边的一个排了

09:36.520 --> 09:37.520
是吧

09:37.520 --> 09:39.520
左边的就有趣了

09:39.520 --> 09:41.520
这就是一个简单的quick salt

09:41.520 --> 09:43.520
是不是特别的简单

09:43.520 --> 09:44.520
简单的

09:44.520 --> 09:45.520
我们感觉可能没有什么

09:45.520 --> 09:46.520
更简单的

09:46.520 --> 09:48.520
你全网上去看quick salt

09:48.520 --> 09:49.520
都算法

09:49.520 --> 09:50.520
可能这个是最好理解的

09:50.520 --> 09:51.520
但是呢

09:51.520 --> 09:53.520
这个是用性能患者

09:53.520 --> 09:54.520
拿什么性能患者

09:54.520 --> 09:56.520
我这个中间

09:56.520 --> 09:58.520
创造了多少个数组

09:58.520 --> 09:59.520
创造了很多的数组

09:59.520 --> 10:00.520
所以说

10:00.520 --> 10:01.520
这个东西

10:01.520 --> 10:03.520
方便大家的理解

10:03.520 --> 10:04.520
你面试的时候这么写

10:04.520 --> 10:05.520
OK

10:05.520 --> 10:06.520
OK

10:06.520 --> 10:07.520
跟大家说

10:07.520 --> 10:08.520
虽然这个东西的性能

10:08.520 --> 10:09.520
不是最好的

10:09.520 --> 10:10.520
但是你面试的时候

10:10.520 --> 10:11.520
拿这个去写

10:11.520 --> 10:13.520
它一定是对的

10:13.520 --> 10:14.520
它一定是对的

10:14.520 --> 10:16.520
所以你就正常的拿这个去写

10:16.520 --> 10:17.520
就行了

10:17.520 --> 10:18.520
当然了quick salt

10:18.520 --> 10:19.520
咱们后面还会讲

10:19.520 --> 10:20.520
正式的版本

10:20.520 --> 10:22.520
但是如果正式的版本

10:22.520 --> 10:23.520
你听不懂

10:23.520 --> 10:24.520
因为正式的版本

10:24.520 --> 10:26.520
就比较接近于标准版

10:27.520 --> 10:29.520
那就比较难了

10:29.520 --> 10:31.520
如果相对于男女学不会的话

10:31.520 --> 10:33.520
你不如记住一个这个版本

10:33.520 --> 10:35.520
这是我给大家优化之后的

10:35.520 --> 10:37.520
我牺牲了一个极大

10:37.520 --> 10:39.520
数据量下的性能

10:39.520 --> 10:40.520
来换取的

10:40.520 --> 10:42.520
建议程度

10:42.520 --> 10:44.520
因为这样的写的话

10:44.520 --> 10:45.520
因为它会创建很多数组

10:45.520 --> 10:47.520
如果你传入的数组

10:47.520 --> 10:48.520
比如说有100万这么多

10:48.520 --> 10:50.520
它会创建很多数组

10:50.520 --> 10:51.520
它就慢了

10:51.520 --> 10:53.520
它的性能就差了

10:53.520 --> 10:54.520
所以说

10:54.520 --> 10:55.520
我们正常的情况

10:55.520 --> 10:57.520
预料了几十个几百的话

10:57.520 --> 10:59.520
这样的性能是完全没有问题的

10:59.520 --> 11:01.520
所以你拿这个去面试的话

11:01.520 --> 11:02.520
也是完全没有问题的

11:02.520 --> 11:03.520
它比较简单

11:03.520 --> 11:05.520
它也比较好学

11:05.520 --> 11:07.520
也比较好理解

11:07.520 --> 11:09.520
如果这个都不能理解的话

11:09.520 --> 11:10.520
我就建议大家

11:10.520 --> 11:12.520
暂时先别学算法

11:12.520 --> 11:14.520
先去学正常的基础知识

11:14.520 --> 11:16.520
学这些编程的东西

11:16.520 --> 11:18.520
等把这些语法

11:18.520 --> 11:20.520
或者一些编程的逻辑

11:20.520 --> 11:22.520
都不练得比较熟了之后

11:22.520 --> 11:24.520
再来学算吧

11:24.520 --> 11:26.520
这是人比较有一个推荐的

11:26.520 --> 11:27.520
如果你直接想应许

11:27.520 --> 11:28.520
很难

11:28.520 --> 11:29.520
直接想应许的话

11:29.520 --> 11:30.520
这个很难

11:30.520 --> 11:32.520
它需要有一定的编程的基础

11:32.520 --> 11:34.520
和编程的素养才行

11:34.520 --> 11:36.520
这就是一个

11:36.520 --> 11:38.520
Quicksault的一个简单的写法

11:38.520 --> 11:40.520
标准的写法

11:40.520 --> 11:42.520
我们可能会怎么去写呢

11:42.520 --> 11:44.520
下一节课我们来改造一下

11:44.520 --> 11:45.520
这个Quicksault

11:45.520 --> 11:46.520
我们下一集来说

