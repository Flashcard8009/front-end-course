WEBVTT

00:01.070 --> 00:08.470
Hello 上一集我们说了树的游言搜索

00:08.470 --> 00:11.470
这一集我们来说一下树的广度游言搜索

00:11.470 --> 00:15.870
还是刚才的节点 还是刚才的这些图

00:15.870 --> 00:19.070
结构还是这样的 还是这样的

00:19.070 --> 00:22.070
但是这个时候我们是广度游言搜索

00:22.070 --> 00:26.070
方式 BFS 广度游言搜索

00:26.070 --> 00:29.070
广度游言搜索还是要先传入一个root 是吧

00:29.070 --> 00:31.470
但是这个时候还是和二十二数一样

00:31.470 --> 00:36.470
我们传入一个是root 词

00:38.470 --> 00:40.470
刚才我们是便利 是吧

00:40.470 --> 00:42.470
这个时候我们传入一个target

00:42.470 --> 00:45.470
传入一个target

00:48.470 --> 00:53.620
怎么样来插着

00:53.620 --> 00:57.620
比如说把这个A作为root传进去

00:58.020 --> 01:02.020
然后我问几点 C在不在里面

01:02.020 --> 01:05.460
怎么插着

01:05.460 --> 01:09.460
同理 如果root等于空

01:09.460 --> 01:15.830
或者是root的lance等于零

01:15.830 --> 01:17.830
我们就return first

01:17.830 --> 01:20.830
返回一个解 是吧

01:20.830 --> 01:21.830
返回一个结果为解

01:21.830 --> 01:22.830
因为它不可能

01:22.830 --> 01:24.830
它都以为空了或者长度为零

01:24.830 --> 01:26.830
就不可能有这个东西

01:26.830 --> 01:28.830
如果不为空也不为零 怎么办

01:29.230 --> 01:31.230
不为空

01:31.230 --> 01:35.230
因为我的root是一个数组

01:35.230 --> 01:37.230
i 小于

01:37.230 --> 01:39.230
root的lance

01:39.230 --> 01:41.230
再加

01:41.230 --> 01:43.230
然后判断一下

01:43.230 --> 01:45.230
leave 什么

01:45.230 --> 01:49.230
如果root i

01:49.230 --> 01:51.230
the value

01:51.230 --> 01:55.250
我这编辑卡死了

01:57.250 --> 01:59.250
稍等我得再关一下

02:04.670 --> 02:06.670
又变成一个彩虹状了

02:06.670 --> 02:12.420
卡死了

02:12.420 --> 02:26.480
彻底关掉 然后再开

02:26.480 --> 02:28.480
如果root i的value

02:28.480 --> 02:30.480
等于target

02:30.480 --> 02:34.480
等于我们要找这个目标

02:34.480 --> 02:36.480
是不是我就直接return出就可以了

02:36.480 --> 02:40.480
如果不等于呢

02:40.480 --> 02:42.480
不等于怎么办

02:42.480 --> 02:46.480
我得把root i的所有的字节点都添加进来是吧

02:46.880 --> 02:50.880
对吧 我得把它的字节点都添加进来

02:50.880 --> 02:52.880
所以说怎么办

02:52.880 --> 02:54.880
做一个chill

02:54.880 --> 02:56.880
是空的 是吧

02:56.880 --> 03:00.880
然后chill等于什么呢

03:00.880 --> 03:02.880
chill等于

03:02.880 --> 03:04.880
chill点

03:04.880 --> 03:06.880
concat

03:06.880 --> 03:08.880
root i的chill

03:08.880 --> 03:10.880
chill

03:10.880 --> 03:12.880
它给连接起来

03:12.880 --> 03:14.880
拼到这个数组里

03:15.280 --> 03:17.280
最后

03:17.280 --> 03:19.280
怎么办

03:19.280 --> 03:21.280
这是一个数组了是吧

03:21.280 --> 03:23.280
return bfs

03:25.280 --> 03:27.280
得什么呀

03:27.280 --> 03:29.280
return bfs

03:29.280 --> 03:31.280
chill

03:31.280 --> 03:33.280
target

03:33.280 --> 03:37.280
我们可以用这样的方式来进行寻找

03:37.280 --> 03:39.280
看这个的结果

03:39.280 --> 03:46.700
我们可以进行bfs

03:47.100 --> 03:49.100
ac

03:49.100 --> 03:55.040
我来看一下

03:55.040 --> 03:57.040
不是这样

03:57.040 --> 03:59.040
数组里面是a

03:59.040 --> 04:02.540
c是存在的

04:02.540 --> 04:04.540
d呢

04:04.540 --> 04:06.540
是不是也是存在的

04:06.540 --> 04:08.540
我找个n

04:08.540 --> 04:10.540
n是不存在的

04:10.540 --> 04:12.540
不存在的方式

04:12.540 --> 04:14.540
这样的结果

04:14.540 --> 04:16.540
它和二查数是很像的

04:16.540 --> 04:18.540
它和二查数是很像的

04:18.540 --> 04:20.540
和二查数是很像的

04:20.940 --> 04:22.940
这个是

04:22.940 --> 04:24.940
深度优先搜索

04:24.940 --> 04:26.940
这个是广度优先搜索

04:26.940 --> 04:28.940
然后咱们来说一下这个深搜

04:28.940 --> 04:32.700
上一节深搜

04:32.700 --> 04:34.700
咱们只说了一个便利

04:34.700 --> 04:36.700
简单的说了一个便利

04:36.700 --> 04:38.700
我们把这个深搜的代码拿出来

04:40.700 --> 04:42.700
你说了一个便利

04:42.700 --> 04:44.700
实际上

04:44.700 --> 04:46.700
在哪返回处

04:46.700 --> 04:48.700
在哪返回first

04:48.700 --> 04:50.700
在哪返回处

04:51.100 --> 04:53.100
衣服

04:53.100 --> 04:55.100
入词的value

04:55.100 --> 04:57.100
等于

04:57.100 --> 04:59.100
Target

04:59.100 --> 05:05.810
是吧

05:05.810 --> 05:07.810
微秤

05:07.810 --> 05:09.810
处

05:09.810 --> 05:11.810
如果入词的value

05:11.810 --> 05:13.810
不等于

05:13.810 --> 05:15.810
Target

05:15.810 --> 05:17.810
我得找它的所有的

05:17.810 --> 05:19.810
字集合

05:19.810 --> 05:21.810
我问一个result

05:21.810 --> 05:23.810
等于first

05:23.810 --> 05:25.810
我认为它是没有的

05:25.810 --> 05:27.810
然后只要有任何一个分支有

05:27.810 --> 05:29.810
我是不是就代表着存在了

05:29.810 --> 05:31.810
就result的

05:31.810 --> 05:33.810
或等于

05:33.810 --> 05:35.810
看了这是或等于

05:35.810 --> 05:37.810
按位或

05:37.810 --> 05:39.810
一针则针

05:39.810 --> 05:41.810
只要有一个分支里面

05:41.810 --> 05:43.810
有Target

05:43.810 --> 05:45.810
result就会变成处

05:45.810 --> 05:49.570
然后我result

05:49.570 --> 05:51.570
看

05:51.570 --> 05:53.570
solo.log

05:53.570 --> 05:55.570
A

05:55.570 --> 06:08.030
C

06:08.030 --> 06:11.600
它给我返回的是0

06:11.600 --> 06:13.600
我看看这是为什么的

06:13.600 --> 06:15.600
这个是

06:15.600 --> 06:21.920
result

06:21.920 --> 06:23.920
处

06:23.920 --> 06:30.560
看一下

06:30.560 --> 06:32.560
给出A是跟节点

06:32.560 --> 06:34.560
是吧

06:34.560 --> 06:36.560
然后我找C这个节点

06:36.560 --> 06:38.560
看它有没有

06:38.560 --> 06:40.560
C的节点如果要是有的话

06:40.560 --> 06:42.560
如果要是有的话

06:42.560 --> 06:44.560
return处

06:44.560 --> 06:46.560
如果要是没有的话

06:46.560 --> 06:48.560
就

06:48.560 --> 06:50.560
return

06:50.560 --> 06:52.560
就往下找

06:52.560 --> 06:54.560
是吧

06:54.560 --> 06:56.560
但是我明明有这个C

06:56.560 --> 06:58.560
我看一下

06:58.560 --> 07:00.560
是吧

07:00.560 --> 07:02.560
A的Chill的Push

07:02.560 --> 07:04.560
A的第一个Chill就是C

07:04.560 --> 07:06.560
result是first

07:08.560 --> 07:11.940
返回的是什么呢

07:11.940 --> 07:13.940
我们打印一下

07:13.940 --> 07:15.940
每一次的result

07:15.940 --> 07:28.210
0000

07:28.210 --> 07:37.860
0000

07:37.860 --> 07:39.860
为什么呢

07:39.860 --> 07:41.860
result是first

07:41.860 --> 07:43.860
那我看看这个的

07:43.860 --> 07:45.860
不是一个Time

07:45.860 --> 07:47.860
打印

07:47.860 --> 07:58.720
为什么会全都是first

07:58.720 --> 08:04.590
明明

08:04.590 --> 08:06.590
第铺色迟了之后

08:06.590 --> 08:10.290
Root的Chill的I

08:10.290 --> 08:15.390
就已经是C了

08:15.390 --> 08:17.390
哦

08:17.390 --> 08:25.060
这分没有传特概的

08:25.060 --> 08:27.060
这不是扯的吗

08:27.060 --> 08:29.060
result的或等于

08:29.060 --> 08:32.690
这个啊

08:32.690 --> 08:34.690
这就处了是吧

08:34.690 --> 08:36.690
这个代表的是第铺色是吧

08:36.690 --> 08:38.690
我能找到C是吧

08:38.690 --> 08:40.690
我再写个F

08:40.690 --> 08:42.690
能不能找到F

08:42.690 --> 08:44.690
能是吧

08:44.690 --> 08:46.690
我再写个E能不能找到E

08:46.690 --> 08:48.690
也是可以找到E的是吧

08:48.690 --> 08:50.690
我写个N

08:50.690 --> 08:52.690
这样的话

08:52.690 --> 08:54.690
我们可以通过深度远搜索

08:54.690 --> 08:56.690
来返回我有这个数

08:56.690 --> 08:58.690
还是没有这个数

08:58.690 --> 09:00.690
我们会发现数的深搜比二刹数的深搜

09:00.690 --> 09:02.690
稍微的复杂了一点点

09:02.690 --> 09:04.690
因为数的分支数量不确定

09:04.690 --> 09:06.690
数的分支数量不确定

09:06.690 --> 09:08.690
但是还有一些情况

09:08.690 --> 09:10.690
比数的深搜还要复杂一点

09:10.690 --> 09:12.690
就是图的深搜

09:12.690 --> 09:14.690
数它有个好处

09:14.690 --> 09:16.690
它不会形成还

09:16.690 --> 09:18.690
是吧图不一样

09:18.690 --> 09:20.690
所以如果深搜还了

09:20.690 --> 09:22.690
你这样深度远搜它

09:22.690 --> 09:24.690
就ABC

09:24.690 --> 09:26.690
就无限循环了

09:26.690 --> 09:28.690
就无限循环了

09:28.690 --> 09:30.690
所以我们必须得避免无限循环的

09:30.690 --> 09:32.690
这种情况的产生

09:32.690 --> 09:34.690
所以我们下集来说

09:34.690 --> 09:36.690
图的深搜和图的广搜

09:36.690 --> 09:38.690
如何来做

09:38.690 --> 09:40.690
我们下集来说

