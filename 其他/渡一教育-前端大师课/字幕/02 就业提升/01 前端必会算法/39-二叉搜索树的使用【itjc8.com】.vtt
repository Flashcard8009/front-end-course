WEBVTT

00:00.560 --> 00:02.560
哈喽大家好啊

00:02.560 --> 00:05.560
上一集我们说了如何利用

00:05.560 --> 00:09.560
如何构建出来一棵二叉搜索树

00:09.560 --> 00:10.560
这一集我们来说说

00:10.560 --> 00:13.560
构建出来二叉搜索树来说我们怎么用

00:13.560 --> 00:15.560
上一集的代码写到这儿

00:15.560 --> 00:17.560
构建出来一棵二叉搜索树了

00:17.560 --> 00:19.560
是root为根结点

00:19.560 --> 00:23.560
然后我们如何来进行查

00:23.560 --> 00:25.560
是吧

00:25.560 --> 00:27.560
构建出来了是构建出来了

00:27.560 --> 00:29.560
如何来查呢

00:29.560 --> 00:33.560
search by tree

00:33.560 --> 00:37.130
给我一个root

00:37.130 --> 00:39.130
用了一个target

00:39.130 --> 00:44.820
如果root等于空

00:44.820 --> 00:48.820
直接就return first

00:48.820 --> 00:50.820
没得说是吧否则的话呢

00:50.820 --> 00:52.820
比较

00:52.820 --> 00:56.820
如果root的value等于target

00:56.820 --> 00:59.820
return true

00:59.820 --> 01:01.820
是吧

01:01.820 --> 01:07.820
如果root的value大于target

01:07.820 --> 01:09.820
怎么办 往左找是吧

01:09.820 --> 01:12.820
return search by tree

01:12.820 --> 01:17.820
root的life target

01:17.820 --> 01:19.820
else

01:19.820 --> 01:21.820
不是比它小就是比它大是吧

01:21.820 --> 01:25.820
return search by tree

01:25.820 --> 01:30.800
root的right

01:30.800 --> 01:32.800
这个就是它的搜索过程

01:32.800 --> 01:34.800
搜索过程非常的简单

01:34.800 --> 01:35.800
是吧

01:35.800 --> 01:38.800
是不是就是非常像什么

01:38.800 --> 01:41.800
又是非常像前去便利是吧

01:41.800 --> 01:43.800
又是非常像前去便利是吧

01:43.800 --> 01:45.800
看当前等不等不等的话

01:45.800 --> 01:47.800
看是小不小

01:47.800 --> 01:48.800
小了就往左走

01:48.800 --> 01:49.800
大了就往右走是吧

01:49.800 --> 01:52.800
又是一个前去便利的一个变形

01:52.800 --> 01:54.800
我们首先来构建一个二叉树

01:54.800 --> 01:56.800
root等于

01:56.800 --> 02:00.800
build search tree

02:00.800 --> 02:06.800
然后cancel了点log search by tree

02:06.800 --> 02:08.800
root

02:08.800 --> 02:11.800
然后还是同样的数

02:11.800 --> 02:12.800
同样的数1000

02:12.800 --> 02:14.800
我们看有没有

02:14.800 --> 02:16.800
我们先让它这个值必须得是正确的

02:16.800 --> 02:17.800
是吧

02:17.800 --> 02:19.800
上面是first 下面就也得是first

02:19.800 --> 02:20.800
是吧

02:20.800 --> 02:22.800
上面是first 下面也得是first

02:22.800 --> 02:24.800
first first

02:24.800 --> 02:26.800
上面是first 下面也是first

02:26.800 --> 02:29.800
是吧 上面first 下面也是first

02:29.800 --> 02:30.800
这么难吗

02:30.800 --> 02:31.800
然后假设我们变成一万个

02:31.800 --> 02:33.800
变成一万个

02:33.800 --> 02:38.240
上面是true 下面是true

02:38.240 --> 02:40.240
上面是true 下面是true

02:40.240 --> 02:41.240
是吧

02:41.240 --> 02:45.810
但是我们给它加一个比较次数

02:45.810 --> 02:48.810
误会一个nam2

02:48.810 --> 02:50.810
我们每进行一次比较

02:50.810 --> 02:53.810
我们就对nam2进行加价

02:53.810 --> 02:55.810
加等于

02:55.810 --> 02:58.810
然后最后我们再输出一下nam2的次数

03:04.900 --> 03:09.460
它查找了一万次

03:09.460 --> 03:11.460
再告诉你没有

03:11.460 --> 03:13.460
我们用这个数据结构

03:13.460 --> 03:15.460
只需要查找16次就可以告诉你没有

03:17.460 --> 03:19.460
上面查找5264次

03:19.460 --> 03:21.460
下面查找23次

03:21.460 --> 03:24.460
下面查找5736次

03:24.460 --> 03:26.460
下面查找10次

03:26.460 --> 03:29.460
上面比较了614次

03:29.460 --> 03:31.460
下面比较14次

03:31.460 --> 03:33.460
上面比较了1万次

03:33.460 --> 03:35.460
下面比较了16次

03:35.460 --> 03:39.460
这就是二插搜索数

03:39.460 --> 03:42.460
这就是二插搜索数的一个强大之处

03:42.460 --> 03:44.460
你之前需要比较上万次

03:44.460 --> 03:45.460
几千次的

03:45.460 --> 03:47.460
我只要换了一个数据结构

03:47.460 --> 03:50.460
换成我这种数据结构来存储的话

03:50.460 --> 03:52.460
我只需要比较十几次

03:52.460 --> 03:54.460
而且色识白锤的功能

03:54.460 --> 03:57.460
它也不是很麻烦

03:57.460 --> 03:59.460
一万个节点

03:59.460 --> 04:01.460
我只需要比较十几次

04:01.460 --> 04:02.460
就能查找出来

04:02.460 --> 04:03.460
它在里面

04:03.460 --> 04:04.460
还是不在里面

04:04.460 --> 04:06.460
这是非常强大的一个性能

04:08.460 --> 04:10.460
这个就是二插搜索数

04:10.460 --> 04:12.460
但是我们

04:12.460 --> 04:14.460
到现在就已经很厉害了

04:14.460 --> 04:16.460
实际上就已经很厉害了

04:16.460 --> 04:18.460
上万个节点

04:18.460 --> 04:20.460
我们只需要比较十几次

04:20.460 --> 04:22.460
性能提升了

04:22.460 --> 04:23.460
好几十倍

04:23.460 --> 04:25.460
性能提升了好几十倍

04:25.460 --> 04:27.460
但是对于一个科学方面

04:27.460 --> 04:28.460
我们记住

04:28.460 --> 04:29.460
计算机科学

04:29.460 --> 04:30.460
但是一门科学

04:30.460 --> 04:32.460
我们追求的是极致的性能

04:32.460 --> 04:34.460
极致的效率

04:34.460 --> 04:36.460
就是这颗数

04:36.460 --> 04:38.460
你们会发现

04:38.460 --> 04:39.460
这个五六七这块

04:39.460 --> 04:41.460
它都是一直往这边延长

04:41.460 --> 04:43.460
我们发现它根本就

04:46.460 --> 04:48.460
如果我们给它换一个结构

04:48.460 --> 04:50.460
比如说让五座为根结点

04:51.460 --> 04:53.460
它可能可以让它的层数变得更少

04:54.460 --> 04:57.480
对吧

04:58.480 --> 05:00.480
如果换五座根结点

05:00.480 --> 05:01.480
刚才是比较六四

05:01.480 --> 05:02.480
现在一四层

05:02.480 --> 05:03.480
两层

05:03.480 --> 05:04.480
三层

05:04.480 --> 05:05.480
四层

05:05.480 --> 05:06.480
五层

05:06.480 --> 05:08.480
现在可能就比较五层就ok

05:09.480 --> 05:11.480
如果再换个结点

05:11.480 --> 05:13.480
可能能让它比较的层数更少

05:13.480 --> 05:14.480
什么样的情况下

05:14.480 --> 05:16.480
它能达到极致

05:16.480 --> 05:18.480
什么情况下能达到极致

05:18.480 --> 05:19.480
如果它能达到

05:19.480 --> 05:21.480
一颗比较满的二刹数

05:22.480 --> 05:24.480
它就是能在最少的层里面

05:25.480 --> 05:27.480
装了最多的数

05:27.480 --> 05:29.480
我们这个数的搜索性能

05:29.480 --> 05:30.480
它是什么决定的

05:31.480 --> 05:33.480
搜索的性能是有什么来决定的

05:33.480 --> 05:35.480
这个数有多深

05:35.480 --> 05:37.480
我就最多

05:37.480 --> 05:38.480
得搜索多少次

05:38.480 --> 05:39.480
是吧

05:39.480 --> 05:41.480
这个数最深有多深

05:41.480 --> 05:42.480
我就最多能搜多少次

05:42.480 --> 05:43.480
是吧

05:43.480 --> 05:45.480
我们如果想要这个数的深度

05:45.480 --> 05:46.480
变浅

05:47.480 --> 05:49.480
我希望让这颗数的深度变浅

05:50.480 --> 05:51.480
怎么样

05:51.480 --> 05:52.480
我得尽量的铺满

05:52.480 --> 05:53.480
上面这些层

05:53.480 --> 05:54.480
是吧

05:54.480 --> 05:56.480
我现在不考虑大小的问题

05:56.480 --> 05:58.480
我是不是今天让它铺满

05:58.480 --> 05:59.480
一层

05:59.480 --> 06:00.480
是吧

06:00.480 --> 06:01.480
你看刚才这个东西

06:01.480 --> 06:02.480
我如果铺满的话

06:02.480 --> 06:03.480
也就是四层

06:03.480 --> 06:04.480
第一层一个

06:04.480 --> 06:05.480
第二层两个

06:05.480 --> 06:06.480
第三层四个

06:06.480 --> 06:07.480
第四层一个是吧

06:07.480 --> 06:08.480
最多就是四层

06:08.480 --> 06:10.480
四层代表什么

06:10.480 --> 06:11.480
最多就比较四次

06:11.480 --> 06:12.480
就能给查出来

06:13.480 --> 06:14.480
对吧

06:14.480 --> 06:15.480
四层代表是最多比较四次

06:15.480 --> 06:16.480
就能查出来

06:16.480 --> 06:17.480
是吧

06:17.480 --> 06:18.480
刚才那种

06:18.480 --> 06:19.480
怎么的都得比较五六次

06:19.480 --> 06:21.480
那人就很麻烦

06:21.480 --> 06:23.480
所以我们需要

06:23.480 --> 06:25.480
对我们现在已有的

06:25.480 --> 06:27.480
二刹搜索数进行优化

06:27.480 --> 06:30.480
将它优化为一个

06:30.480 --> 06:32.480
比较平衡的

06:32.480 --> 06:33.480
二刹搜索数

06:33.480 --> 06:36.480
所以我们希望

06:36.480 --> 06:38.480
做一个什么优化呢

06:38.480 --> 06:44.320
我们希望

06:44.320 --> 06:46.320
我们希望

06:46.320 --> 06:47.320
将

06:47.320 --> 06:50.320
二刹搜索数

06:50.320 --> 06:53.320
将二刹搜索数

06:53.320 --> 06:57.210
变为

06:57.210 --> 07:00.210
二刹平衡

07:00.210 --> 07:02.210
搜索数

07:02.210 --> 07:04.210
别看它只有一句话

07:04.210 --> 07:06.210
复杂了去

07:06.210 --> 07:08.210
我们希望将

07:08.210 --> 07:10.210
二刹搜索数变成一颗

07:10.210 --> 07:12.210
二刹平衡搜索数

07:12.210 --> 07:14.210
就多了两个平衡

07:14.210 --> 07:15.210
字

07:15.210 --> 07:17.210
就要增加很多的

07:17.210 --> 07:18.210
操作

07:18.210 --> 07:19.210
最后的性能

07:19.210 --> 07:21.210
肯定也不会特别的明显

07:21.210 --> 07:22.210
是吧

07:22.210 --> 07:23.210
你都已经从几千次

07:23.210 --> 07:24.210
调到十来次了

07:24.210 --> 07:25.210
是吧

07:25.210 --> 07:26.210
你还能从十几次调到

07:26.210 --> 07:27.210
夫几次吗

07:27.210 --> 07:28.210
不可能是吧

07:28.210 --> 07:30.210
也就是再少个四五次

07:30.210 --> 07:31.210
性能不会特别的明显

07:31.210 --> 07:33.210
但是就是追求极致

07:33.210 --> 07:35.210
所以说这一块的东西

07:35.210 --> 07:36.210
才比较更值钱

07:36.210 --> 07:37.210
是吧

07:37.210 --> 07:38.210
我们多做的这些

07:38.210 --> 07:39.210
就能让我的性能

07:39.210 --> 07:40.210
再提升一减

07:40.210 --> 07:42.210
让我们的性能再提升一减

07:42.210 --> 07:44.210
其实现在的这种科技也好

07:44.210 --> 07:45.210
还是这种技术也好

07:45.210 --> 07:47.210
都是在精一求有的过程

07:47.210 --> 07:49.210
就是现在比谁做的

07:49.210 --> 07:50.210
更精致

07:50.210 --> 07:51.210
比谁做的更精细

07:51.210 --> 07:53.210
这样的话就能性能更好

07:53.210 --> 07:54.210
所以这是一个

07:54.210 --> 07:57.210
我们要进化的一个思路

07:57.210 --> 07:58.210
下一集

07:58.210 --> 08:00.210
开始我们就来说

08:00.210 --> 08:02.210
如何将一颗二叉搜索数

08:02.210 --> 08:04.210
变为二叉平衡搜索数

08:04.210 --> 08:05.210
我们下一集

