WEBVTT

00:01.390 --> 00:08.390
哈喽 大家好 上一集我们说了冒泡牌区 这一集我们来说选择牌区

00:08.390 --> 00:14.390
选择牌区和冒泡牌区很像 我们来建一个文件

00:14.390 --> 00:19.390
还是我们来创建一个数组 AR等于这个数组是什么呢

00:19.390 --> 00:23.390
数组是41693287是吧

00:25.390 --> 00:30.390
41693287

00:31.390 --> 00:34.390
这样的一个数组

00:34.390 --> 00:40.390
我要对这个数组进行牌序 之前说了数组的牌序要有几个核心部分来着

00:40.390 --> 00:47.390
一个是比较 是吧 另一个是进行交换

00:49.390 --> 00:52.390
然后最后是牌序算法 是吧

00:52.390 --> 00:56.390
对某个数组进行牌序比较的是对A和B进行比较

00:56.390 --> 01:01.390
然后交换是对数组中的跌一个位置和B一个位置进行交换

01:01.390 --> 01:06.390
交换最好写一个临时变量等于ARA

01:06.390 --> 01:12.390
然后ARA等于ARB

01:12.390 --> 01:16.390
然后ARB等于临时变量

01:16.390 --> 01:18.390
这是交换

01:18.390 --> 01:22.390
然后我们开始比较 是吧

01:22.390 --> 01:32.340
如果A小于B

01:32.340 --> 01:36.660
然后我就return to

01:36.660 --> 01:40.660
然后ARS return first

01:40.660 --> 01:42.660
大概就这么一个情况

01:42.660 --> 01:46.660
A小于B return to ARS return first

01:46.660 --> 01:50.660
然后我们说了冒泡牌序怎么回事来着

01:50.660 --> 01:53.660
受寻环 味一个接等于零

01:53.660 --> 01:58.660
然后接小于AR点浪子 接加加

01:58.660 --> 02:02.660
每一次就进行一下比较

02:02.660 --> 02:04.660
比较谁 Tom Pair

02:04.660 --> 02:09.660
AR接位和接加易位 是吧

02:09.660 --> 02:12.660
这两个位置进行比较

02:12.660 --> 02:15.660
如果返回处了 我就进行交换

02:15.660 --> 02:19.660
xchange AR接和接加易

02:19.660 --> 02:23.660
否则的话就走下一路 是吧

02:23.660 --> 02:25.660
然后我们说这个东西必须得简易

02:25.660 --> 02:27.660
这是进行一次筛选 是吧

02:27.660 --> 02:29.660
筛选出来的是啥 最大的 是吧

02:29.660 --> 02:33.660
然后我们要进行N次筛选 对吧

02:33.660 --> 02:38.500
我们要进行N次筛选

02:38.500 --> 02:40.500
N次筛选怎么来的 玩一个i等于零

02:40.500 --> 02:46.500
i小于AR点浪子 加加

02:47.500 --> 02:49.500
然后我们就能排序了 是吧

02:49.500 --> 02:55.140
sort AR

02:55.140 --> 02:58.140
看sort了点log

02:58.140 --> 03:03.880
这是道序 是吧

03:03.880 --> 03:10.880
然后我把这样就变成正序了 是吧

03:10.880 --> 03:13.880
就是一个这样的过程

03:13.880 --> 03:16.880
然后这个是冒泡排序

03:16.880 --> 03:17.880
是两个两个一比

03:17.880 --> 03:18.880
就像是一个小气泡一样

03:18.880 --> 03:19.880
像是水里的气泡一样

03:19.880 --> 03:22.880
孤独孤独的给它冒上去

03:22.880 --> 03:24.880
那选择排序跟它不一样

03:24.880 --> 03:27.880
选择排序是每一圈

03:27.880 --> 03:34.770
选择排序

03:34.770 --> 03:41.530
那层循环

03:41.530 --> 03:48.530
每一圈选出一个最大的

03:48.530 --> 03:53.530
然后放在后面

03:53.530 --> 03:55.530
那我就说接等于零

03:55.530 --> 03:56.530
这些东西

03:56.530 --> 03:58.530
我得选出一个最大的

03:58.530 --> 04:00.530
对吧

04:00.530 --> 04:05.530
我得were一个max index

04:05.530 --> 04:08.530
最大的号的序号是多少

04:08.530 --> 04:09.530
对吧

04:09.530 --> 04:11.530
我默认它等于零

04:11.530 --> 04:14.840
我默认它等于零

04:14.840 --> 04:18.840
如果我们进行一下比较

04:19.840 --> 04:21.840
谁和谁比较

04:21.840 --> 04:23.840
max index

04:23.840 --> 04:25.840
和谁进行比较

04:25.840 --> 04:28.840
和接进行比较

04:28.840 --> 04:30.840
如果它返回处了

04:30.840 --> 04:34.840
我们就让max index

04:34.840 --> 04:35.840
等于接

04:35.840 --> 04:37.840
就证明这个是新的一个

04:37.840 --> 04:39.840
需要放在最后的

04:39.840 --> 04:41.840
然后复循环一圈了之后

04:41.840 --> 04:43.840
这里面肯定有个值

04:43.840 --> 04:44.840
是吧

04:44.840 --> 04:45.840
然后我们让这个值

04:45.840 --> 04:47.840
和当前最后的进行交换

04:48.840 --> 04:50.840
xchanger

04:50.840 --> 04:51.840
ar

04:51.840 --> 04:52.840
这个当前的这个值

04:52.840 --> 04:53.840
max index

04:53.840 --> 04:54.840
最后的就是这样

04:54.840 --> 05:00.840
ar.lantz-1

05:00.840 --> 05:02.840
你说我能每一次都和

05:02.840 --> 05:04.840
ar.lantz-1进行交换吗

05:04.840 --> 05:06.840
那不都覆盖了是吗

05:06.840 --> 05:08.840
还得减一个i是吧

05:08.840 --> 05:11.840
现在跟最后一个交换

05:11.840 --> 05:13.840
下一步就跟倒数第二个交换

05:13.840 --> 05:15.840
再下一步和倒数第三个交换

05:15.840 --> 05:17.840
这个就是一个

05:17.840 --> 05:19.840
选择排序的一个过程

05:19.840 --> 05:21.840
还是倒数对吧

05:21.840 --> 05:23.840
a

05:23.840 --> 05:24.840
b

05:24.840 --> 05:28.980
让的话就是正确了是吧

05:28.980 --> 05:29.980
我们看

05:29.980 --> 05:31.980
选择和冒泡的差别在哪

05:31.980 --> 05:33.980
冒泡是不是

05:33.980 --> 05:35.980
compare了之后就xchanger

05:35.980 --> 05:37.980
compare之后就xchanger

05:37.980 --> 05:39.980
选择是compare之后

05:39.980 --> 05:41.980
攒着找到一个最小的

05:41.980 --> 05:43.980
进行一个xchanger

05:43.980 --> 05:44.980
对吧

05:44.980 --> 05:45.980
所以说

05:45.980 --> 05:47.980
这是选择和冒泡的区别

05:47.980 --> 05:49.980
这两种算法

05:49.980 --> 05:51.980
没有优劣之分

05:51.980 --> 05:52.980
大家记住

05:52.980 --> 05:54.980
任何一种排序算法

05:54.980 --> 05:56.980
都没有优劣之分

05:58.980 --> 06:01.980
任何一种排序算法

06:02.980 --> 06:05.980
都没有优劣之分

06:07.980 --> 06:08.980
只有

06:08.980 --> 06:10.980
是否

06:10.980 --> 06:12.980
适合的场景

06:12.980 --> 06:13.980
有的说

06:13.980 --> 06:14.980
冒泡排序最简单了

06:14.980 --> 06:15.980
最简单了

06:15.980 --> 06:16.980
最先学的

06:16.980 --> 06:17.980
所以它不好

06:17.980 --> 06:18.980
我们后来学的

06:18.980 --> 06:20.980
以后还有快速排序什么的

06:20.980 --> 06:21.980
这些好

06:21.980 --> 06:22.980
是这样吗

06:22.980 --> 06:23.980
不是

06:23.980 --> 06:25.980
越混乱

06:25.980 --> 06:27.980
越适合快速排序

06:27.980 --> 06:28.980
越有序

06:28.980 --> 06:30.980
越适合冒泡排序

06:30.980 --> 06:31.980
比如说你数组里面

06:31.980 --> 06:32.980
10个数

06:32.980 --> 06:33.980
我9个数都是有序的

06:33.980 --> 06:34.980
只有一个数无序

06:34.980 --> 06:35.980
这种情况下

06:35.980 --> 06:36.980
最适合用什么

06:36.980 --> 06:37.980
最适合的就是冒泡排序

06:37.980 --> 06:39.980
冒泡排序的性能最好

06:40.980 --> 06:41.980
然后

06:41.980 --> 06:42.980
选择排序

06:42.980 --> 06:44.980
数码曲的一些区中

06:44.980 --> 06:45.980
快速排序

06:45.980 --> 06:46.980
就是越混乱

06:46.980 --> 06:48.980
越适合快排

06:48.980 --> 06:52.550
越混乱

06:54.550 --> 06:55.550
他有不同的射程的场景

06:55.550 --> 06:56.550
大家要知道

06:56.550 --> 06:59.550
许多许

06:59.550 --> 07:08.550
每个算法

