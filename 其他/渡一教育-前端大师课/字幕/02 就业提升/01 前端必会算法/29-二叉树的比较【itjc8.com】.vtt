WEBVTT

00:01.390 --> 00:03.390
Hello 大家好

00:03.390 --> 00:06.390
前两集我们说了

00:06.390 --> 00:10.390
跟我们说了二叉树的深色和广色

00:10.390 --> 00:14.390
然后我们这一节课来说一个经典的一个题目

00:14.390 --> 00:17.390
就是二叉树的比较

00:17.390 --> 00:21.390
二叉树的比较是所有树形比较的基础

00:21.390 --> 00:26.540
二叉树的比较

00:26.540 --> 00:29.540
二叉树的比较是所有树形结构比较的基础

00:29.540 --> 00:33.540
有很多同学在学习费用议的时候遇到什么地负算法

00:33.540 --> 00:37.540
比如说两个道目结构的比较

00:37.540 --> 00:39.540
两个页面上道目结构的比较

00:39.540 --> 00:41.540
页面上的道目结构是树形结构

00:41.540 --> 00:43.540
它不是二叉树结构

00:43.540 --> 00:45.540
所以说它比比较更复杂

00:45.540 --> 00:48.540
这个之后咱们可能会涉及到一些

00:48.540 --> 00:51.540
说到一些二叉树的地负

00:51.540 --> 00:54.540
但是这个的基础就是二叉树的比较

00:54.540 --> 00:57.540
上面这个图里面我现在有两个二叉树

00:57.540 --> 00:58.540
一个是蓝色的树

00:58.540 --> 00:59.540
一个是黄色的树

00:59.540 --> 01:03.540
我们可以发现现在这两个树是一样的

01:03.540 --> 01:04.540
对吧

01:04.540 --> 01:07.540
我如果把黄色的树的G给去掉

01:07.540 --> 01:09.540
那明显就不一样了

01:09.540 --> 01:11.540
所以我需要写一个算法

01:11.540 --> 01:13.540
来对这颗二叉树来进行比较

01:13.540 --> 01:16.540
来看看它两个到底一样不一样

01:16.540 --> 01:18.540
我们首先要实现第一个功能

01:18.540 --> 01:21.540
判断两个二叉树是否相同

01:21.540 --> 01:25.540
判断两颗二叉树是否相同

01:25.540 --> 01:31.640
这之前的代码我提交一下

01:31.640 --> 01:33.640
我们可以先来想一下

01:33.640 --> 01:35.640
所有的二叉树的

01:35.640 --> 01:37.640
这些比较搜索也好

01:37.640 --> 01:38.640
其实都是有基础的

01:38.640 --> 01:39.640
就是二叉树的变利

01:39.640 --> 01:41.640
以二叉树的变利为基础

01:41.640 --> 01:42.640
我们来想一下

01:42.640 --> 01:44.640
我们如何通过二叉树为基础

01:44.640 --> 01:46.640
来实现这个功能

01:46.640 --> 01:48.640
如何通过二叉树的变利

01:48.640 --> 01:50.640
为基础来实现这个功能

01:50.640 --> 01:56.810
二叉树的比较

01:56.810 --> 02:01.400
来创建一个GS

02:01.400 --> 02:05.930
创建了一个GS

02:05.930 --> 02:07.930
首先我们有一个方式

02:07.930 --> 02:09.930
创建一个Node

02:09.930 --> 02:10.930
给出一个Value

02:10.930 --> 02:13.930
Z4的Value等于Value

02:13.930 --> 02:16.930
然后Z4的Life等于空

02:16.930 --> 02:19.930
然后Z4的Ret等于空

02:19.930 --> 02:21.930
一个最基本的接连

02:21.930 --> 02:24.930
然后我们来实现这两个二叉树

02:24.930 --> 02:25.930
是吧

02:25.930 --> 02:27.930
Ve一个A

02:27.930 --> 02:29.930
A1

02:29.930 --> 02:31.930
等于

02:31.930 --> 02:33.930
用一个Node

02:34.930 --> 02:35.930
A

02:35.930 --> 02:39.940
AD

02:39.940 --> 02:41.940
E

02:41.940 --> 02:43.940
FG

02:43.940 --> 02:44.940
A1

02:44.940 --> 02:45.940
B

02:46.940 --> 02:47.940
C

02:47.940 --> 02:48.940
D

02:49.940 --> 02:50.940
E

02:50.940 --> 02:52.940
FG

02:52.940 --> 02:53.940
是吧

02:53.940 --> 02:56.940
这个E代表的是左边这个数字节

02:56.940 --> 02:58.940
左边这个数字节

02:58.940 --> 03:01.940
然后A1的Life等于C

03:01.940 --> 03:04.940
A1的Ret等于

03:05.940 --> 03:07.940
B

03:07.940 --> 03:08.940
是吧

03:08.940 --> 03:10.940
C的左边是FG

03:10.940 --> 03:13.940
C1的Life等于FG

03:13.940 --> 03:17.940
C1的Ret

03:17.940 --> 03:19.940
等于D

03:19.940 --> 03:22.940
然后B1的Life等于D

03:22.940 --> 03:25.940
然后B1的Ret等于E

03:27.940 --> 03:28.940
是吧

03:28.940 --> 03:29.940
这是左边这个数字

03:29.940 --> 03:31.940
然后我们再创建右边这个数字

03:31.940 --> 03:33.940
AR

03:33.940 --> 03:35.940
Node

03:35.940 --> 03:36.940
A

03:36.940 --> 03:37.940
B

03:37.940 --> 03:38.940
C

03:38.940 --> 03:39.940
D

03:39.940 --> 03:40.940
E

03:40.940 --> 03:41.940
FG

03:41.940 --> 03:42.940
B2

03:42.940 --> 03:43.940
C2

03:43.940 --> 03:44.940
D2

03:44.940 --> 03:45.940
E2

03:45.940 --> 03:46.940
F2

03:46.940 --> 03:47.940
G2

03:47.940 --> 03:49.940
是吧

03:49.940 --> 03:50.940
A

03:50.940 --> 03:51.940
B

03:51.940 --> 03:52.940
C

03:52.940 --> 03:53.940
D

03:53.940 --> 03:54.940
E

03:54.940 --> 03:55.940
FG

03:55.940 --> 03:56.940
A

03:56.940 --> 03:57.940
B

03:57.940 --> 03:58.940
C

03:58.940 --> 03:59.940
D

03:59.940 --> 04:00.940
E

04:00.940 --> 04:01.940
FG

04:01.940 --> 04:04.940
A2的Life等于C2

04:04.940 --> 04:05.940
是吧

04:05.940 --> 04:07.940
A2的Ret

04:07.940 --> 04:09.940
等于B2

04:09.940 --> 04:12.940
然后C2的Life等于

04:12.940 --> 04:13.940
F2

04:13.940 --> 04:15.940
C2的Ret

04:15.940 --> 04:16.940
等于G2

04:16.940 --> 04:19.940
然后B2的Life

04:20.940 --> 04:22.940
等于D2

04:22.940 --> 04:24.940
然后B2的Ret

04:24.940 --> 04:26.940
等于E2

04:26.940 --> 04:27.940
是吧

04:27.940 --> 04:28.940
这是两个数的结构

04:28.940 --> 04:30.940
这是两个数的结构

04:30.940 --> 04:33.940
然后我们需要写一个方法来判断

04:33.940 --> 04:34.940
Compire

04:34.940 --> 04:36.940
Treat

04:36.940 --> 04:40.940
传入一颗Root1

04:40.940 --> 04:42.940
传入一个Root2

04:42.940 --> 04:43.940
是吧

04:43.940 --> 04:44.940
代表两颗数的跟接点

04:44.940 --> 04:45.940
然后我们就比较一下

04:45.940 --> 04:47.940
这两个数是否相当

04:47.940 --> 04:49.940
比较这两个数是否相当

04:49.940 --> 04:51.940
比如说我现在cancel了点log

04:51.940 --> 04:52.940
我想输出一下

04:52.940 --> 04:53.940
Compire

04:53.940 --> 04:54.940
Treat

04:54.940 --> 04:56.940
A1

04:56.940 --> 04:57.940
和

04:57.940 --> 04:58.940
AR

04:58.940 --> 04:59.940
这两个数

05:00.940 --> 05:01.940
是否相当

05:02.940 --> 05:03.940
怎么来判断

05:03.940 --> 05:05.940
如何来判断呢

05:05.940 --> 05:06.940
E4

05:06.940 --> 05:07.940
到了

05:07.940 --> 05:08.940
如果Root1

05:08.940 --> 05:10.940
等于Root2

05:11.940 --> 05:12.940
相当吗

05:13.940 --> 05:15.940
如果Root1都等于Root2

05:15.940 --> 05:16.940
那就Ret上一个处吧

05:16.940 --> 05:17.940
是吧

05:17.940 --> 05:19.940
两个数都完全相当

05:19.940 --> 05:20.940
那还有什么不相当的

05:20.940 --> 05:21.940
对吧

05:21.940 --> 05:23.940
就反过一个处

05:24.940 --> 05:26.940
然后E4

05:26.940 --> 05:30.150
Root1

05:31.150 --> 05:32.150
等于空

05:33.150 --> 05:34.150
且

05:34.150 --> 05:35.150
Root2

05:36.150 --> 05:37.150
不等于空

05:37.150 --> 05:38.150
是吧

05:38.150 --> 05:39.150
E为空不等于空

05:39.150 --> 05:40.150
R不为空

05:40.150 --> 05:41.150
或者是

05:42.150 --> 05:43.150
Root2为空

05:45.150 --> 05:47.150
且Root1不等于空

05:48.150 --> 05:49.150
这就是什么情况

05:49.150 --> 05:50.150
两个数

05:50.150 --> 05:51.150
有一个为空

05:51.150 --> 05:52.150
一个不为空

05:52.150 --> 05:53.150
Ret上一个处

05:53.150 --> 05:54.150
就不相当

05:55.150 --> 05:56.150
对吧

05:57.150 --> 05:58.150
然后第三种情况

05:58.150 --> 06:00.150
我们来判断一下

06:00.150 --> 06:03.150
如果Root1的Value

06:03.150 --> 06:06.150
不等于Root2的Value

06:06.150 --> 06:09.720
那就Ret上False是吧

06:09.720 --> 06:10.720
值不相当

06:10.720 --> 06:12.720
这代表什么值不相当

06:15.030 --> 06:17.030
相同位置的值

06:17.030 --> 06:20.030
相同位置的值

06:20.030 --> 06:23.410
相同位置的值不相当

06:24.410 --> 06:26.410
这个就是

06:27.410 --> 06:30.410
其中一个为空

06:30.410 --> 06:33.410
另一个不为空

06:35.850 --> 06:37.850
这个是相同位置的值

06:37.850 --> 06:38.850
不相当

06:38.850 --> 06:40.850
所以说也是返回False

06:40.850 --> 06:43.850
这个就是两个数是同一颗数

06:44.850 --> 06:47.850
是同一颗数

06:47.850 --> 06:56.600
这两个数是同一颗数

06:56.600 --> 06:58.600
但是有一种情况

06:58.600 --> 07:00.600
如果这两个Root1和Root2

07:00.600 --> 07:02.600
都为空

07:02.600 --> 07:03.600
怎么算

07:04.600 --> 07:05.600
Root1和Root2

07:05.600 --> 07:07.600
如果都为空怎么算

07:08.600 --> 07:10.600
我们先保留一个问题

07:12.600 --> 07:16.600
Root1和Root2

07:18.600 --> 07:20.600
都为空

07:20.600 --> 07:23.600
算相等

07:23.600 --> 07:27.620
我们先保留这个问题

07:27.620 --> 07:28.620
我们先不看

07:28.620 --> 07:30.620
然后我们看下面

07:30.620 --> 07:32.620
如果Root1和Root2都相等的话

07:32.620 --> 07:33.620
我们认为是同一颗数

07:33.620 --> 07:34.620
然后就返回处

07:34.620 --> 07:36.620
如果1和2有任何一个为空

07:36.620 --> 07:37.620
另一个不为空

07:37.620 --> 07:39.620
那就证明就是都不一样了

07:39.620 --> 07:41.620
所以就是Ret上False

07:42.620 --> 07:44.620
如果Root1和Root2都不为空

07:44.620 --> 07:46.620
但是它俩的值

07:46.620 --> 07:48.620
不相等

07:48.620 --> 07:49.620
它也不行

07:49.620 --> 07:50.620
值不相等可不行

07:50.620 --> 07:52.620
也不能是相等

07:52.620 --> 07:53.620
相同的二差数

07:54.620 --> 07:55.620
如果

07:56.620 --> 07:58.620
当前的值也相等

07:58.620 --> 07:59.620
怎么办

08:01.620 --> 08:02.620
Compire

08:03.620 --> 08:05.620
Root1的Left

08:05.620 --> 08:09.620
和Root2的Left

08:09.620 --> 08:10.620
是吧

08:10.620 --> 08:12.620
1的左子数和2的左子数比

08:14.620 --> 08:16.620
Root1的Ret

08:17.620 --> 08:20.620
Root2的Ret

08:20.620 --> 08:23.620
Root1的右子数和Root2的右子数相等

08:23.620 --> 08:26.620
看看它俩相不相等

08:28.620 --> 08:29.620
是吧

08:30.620 --> 08:31.620
Left

08:33.620 --> 08:35.620
和Ret

08:36.620 --> 08:37.620
布尔

08:38.620 --> 08:39.620
它们两个判断相不相等

08:39.620 --> 08:40.620
是吧

08:40.620 --> 08:41.620
有一边不相等

08:41.620 --> 08:42.620
就不相等

08:42.620 --> 08:43.620
它俩必须得起眼的关系

08:43.620 --> 08:44.620
是吧

08:44.620 --> 08:46.620
所以我Left的起眼

08:46.620 --> 08:47.620
Ret

08:48.620 --> 08:49.620
看什么

08:51.620 --> 08:53.620
下面是当前几点相等了

08:53.620 --> 08:55.620
然后判断

08:56.620 --> 09:00.620
左子数是否相等

09:01.620 --> 09:03.620
这个是判断

09:03.620 --> 09:07.620
右子数是否相等

09:12.270 --> 09:14.270
就是必须

09:14.270 --> 09:17.270
左右子数都相等

09:18.270 --> 09:20.270
才算相等

09:23.270 --> 09:24.270
这是一个这样的

09:24.270 --> 09:25.270
赶紧

09:26.270 --> 09:28.270
所以我们来Compire一下

09:28.270 --> 09:29.270
这两个Treat

09:29.270 --> 09:30.270
你看看现在相不相等

09:30.270 --> 09:31.270
走

09:31.270 --> 09:32.270
True是吧

09:32.270 --> 09:33.270
True

09:33.270 --> 09:34.270
相等

09:34.270 --> 09:36.270
是因为我这两个数

09:36.270 --> 09:37.270
现在确实都是相等

09:37.270 --> 09:39.270
我删出C的右边是G

09:39.270 --> 09:41.270
黄颜色的是R数

09:41.270 --> 09:43.270
C的右边是G

09:43.270 --> 09:44.270
我给它注释掉

09:44.270 --> 09:46.270
看看这回相不相等

09:46.270 --> 09:49.610
Fourth了

09:49.610 --> 09:50.610
不相等了

09:51.610 --> 09:54.610
我把它给

09:54.610 --> 09:57.610
把C2的右边是G2给去掉

09:57.610 --> 09:59.610
然后把C1的右边是G1得去掉

09:59.610 --> 10:00.610
是不是应该又相等

10:00.610 --> 10:02.610
我相等于把这个也给删了

10:02.610 --> 10:03.610
是吧

10:03.610 --> 10:05.610
把这个点也给删了

10:05.610 --> 10:07.610
我把这个蓝色的和这个黄色的都删了

10:07.610 --> 10:09.610
看看现在相不相等

10:09.610 --> 10:10.610
是吧

10:10.610 --> 10:11.610
右边为True

10:11.610 --> 10:14.610
Root1和Root2都为空算相等

10:14.610 --> 10:16.610
我们其实应该算相等

10:16.610 --> 10:17.610
是吧

10:17.610 --> 10:18.610
两个数都没有

10:18.610 --> 10:19.610
它两个数还是一样

10:19.610 --> 10:20.610
对吧

10:20.610 --> 10:21.610
你是零分

10:21.610 --> 10:22.610
我是零分

10:22.610 --> 10:23.610
它也是零分

10:23.610 --> 10:25.610
它两个分数还是一样

10:26.610 --> 10:29.610
所以我们用这样的方法

10:29.610 --> 10:32.610
可以判断出来两个数是否相等

10:32.610 --> 10:34.610
判断出来两个数是否相等

10:34.610 --> 10:36.610
我们可以用这种简单的东西

10:36.610 --> 10:37.610
类比到Dom

10:37.610 --> 10:40.610
可以判断两个Dom结构

10:40.610 --> 10:42.610
是否相等

10:42.610 --> 10:44.610
但是现在我们还无法区分

10:44.610 --> 10:45.610
哪不相等

10:45.610 --> 10:46.610
当然了

10:46.610 --> 10:47.610
必须给一步一步来

10:47.610 --> 10:49.610
我们现在第一步是区分

10:49.610 --> 10:51.610
两个数是否相等

10:51.610 --> 10:53.610
但是

10:53.610 --> 10:55.610
二查数上还有另外一个概念

10:55.610 --> 10:57.610
二查数上还有另外一个概念

10:57.610 --> 10:59.610
二查数有的时候

10:59.610 --> 11:01.610
是区分左右子数的

11:01.610 --> 11:02.610
就是左子数就是左子数

11:02.610 --> 11:04.610
右子数就是右子数

11:04.610 --> 11:05.610
但是有的时候

11:05.610 --> 11:07.610
左子数和右子数是可以互换的

11:07.610 --> 11:09.610
就是我们认为是拓骨关系的时候

11:09.610 --> 11:10.610
是吧

11:10.610 --> 11:12.610
这个C假如是A的爸爸

11:12.610 --> 11:14.610
B是A的妈妈

11:14.610 --> 11:16.610
爸爸在左门

11:16.610 --> 11:17.610
妈妈在右边

11:17.610 --> 11:19.610
他是爸爸妈妈和爸妈和妈妈

11:19.610 --> 11:20.610
是吧

11:20.610 --> 11:22.610
C在右边B和B在左门

11:22.610 --> 11:24.610
它还是他爸和他妈的关系

11:24.610 --> 11:25.610
对吧

11:25.610 --> 11:27.610
这个关系是不变的

11:27.610 --> 11:28.610
所以大家记住

11:28.610 --> 11:30.610
二查数比较的时候

11:30.610 --> 11:32.610
如果遇到了这样的体

11:32.610 --> 11:34.610
必须要

11:34.610 --> 11:35.610
慎重

11:35.610 --> 11:36.610
为什么呢

11:36.610 --> 11:37.610
要看

11:37.610 --> 11:39.610
左右子数交换位置

11:39.610 --> 11:40.610
算不算

11:40.610 --> 11:41.610
同一颗二查数

11:41.610 --> 11:42.610
必须要判断

11:44.610 --> 11:49.010
遇到

11:49.010 --> 11:52.010
二查数比较的问题时

11:52.010 --> 11:54.010
必须要

11:54.010 --> 11:56.010
确定

11:56.010 --> 11:58.010
左右

11:58.010 --> 11:59.010
两颗

11:59.010 --> 12:00.010
子数

12:00.010 --> 12:04.900
如果交换位置

12:04.900 --> 12:06.900
G

12:06.900 --> 12:12.490
左右互换

12:12.490 --> 12:13.490
还算不算

12:13.490 --> 12:15.490
同一颗二查数

12:16.490 --> 12:17.490
算不算

12:17.490 --> 12:19.490
同一颗

12:19.490 --> 12:21.490
二查数

12:21.490 --> 12:22.490
记住

12:22.490 --> 12:24.490
一定要问一下这样的问题

12:24.490 --> 12:26.490
如果是面试的话

12:26.490 --> 12:27.490
你直接问面试官

12:27.490 --> 12:29.490
如果面试官不告诉你的话

12:29.490 --> 12:30.490
你去写两种答案

12:30.490 --> 12:31.490
算呢

12:31.490 --> 12:32.490
写一种

12:32.490 --> 12:33.490
不算的一种

12:33.490 --> 12:35.490
他写的这种都是什么

12:35.490 --> 12:37.490
是左右交换了之后

12:37.490 --> 12:39.490
就不算一颗二查数了是吧

12:39.490 --> 12:40.490
我这是

12:40.490 --> 12:41.490
左子数和左子数比

12:41.490 --> 12:42.490
右子数和右子数比

12:42.490 --> 12:44.490
对吧

12:44.490 --> 12:45.490
是吧

12:45.490 --> 12:46.490
左子数和左子数比

12:46.490 --> 12:47.490
右子数和右子数比

12:47.490 --> 12:48.490
是吧

12:48.490 --> 12:49.490
我没有写

12:49.490 --> 12:50.490
左子数和右子数比

12:50.490 --> 12:51.490
右子数和左子数比

12:51.490 --> 12:52.490
对吧

12:52.490 --> 12:54.490
所以这种比较的方式

12:54.490 --> 12:55.490
是

12:55.490 --> 12:57.490
强调左右不能互换

12:57.490 --> 12:58.490
那么反过来

12:58.490 --> 13:00.490
如果左右能互换

13:00.490 --> 13:04.700
如果是比式的

13:04.700 --> 13:06.700
没有

13:06.700 --> 13:08.700
特殊的说明

13:08.700 --> 13:09.700
左右

13:09.700 --> 13:10.700
互换

13:10.700 --> 13:11.700
还是

13:11.700 --> 13:12.700
统一可输

13:14.700 --> 13:15.700
那么

13:15.700 --> 13:16.700
默认

13:16.700 --> 13:17.700
互换

13:17.700 --> 13:18.700
后

13:18.700 --> 13:19.700
不是

13:19.700 --> 13:21.700
统一可输

13:21.700 --> 13:25.140
就是默认左右数

13:25.140 --> 13:26.140
互换

13:26.140 --> 13:27.140
互换了之后

13:27.140 --> 13:28.140
不是统一可输

13:28.140 --> 13:29.140
不算的

13:29.140 --> 13:31.140
如果是面试

13:33.140 --> 13:34.140
尽量

13:34.140 --> 13:35.140
问一下

13:35.140 --> 13:36.140
来确认

13:36.140 --> 13:37.140
左右互换了之后

13:37.140 --> 13:39.140
是不是一可输

13:39.140 --> 13:41.140
从二叉数的

13:41.140 --> 13:43.140
严格的定义上来讲

13:43.140 --> 13:45.140
从二叉数的严格的定义上来讲

13:45.140 --> 13:46.140
左右互换了之后

13:46.140 --> 13:47.140
不算

13:47.140 --> 13:48.140
但是有一些

13:48.140 --> 13:49.140
从拓补的角度上来讲

13:49.140 --> 13:51.140
左右互换的又算

13:51.140 --> 13:52.140
所以说

13:52.140 --> 13:53.140
之所以算还是不算

13:53.140 --> 13:55.140
是取决于我们的

13:55.140 --> 13:56.140
一个需求

13:56.140 --> 13:57.140
可以算

13:57.140 --> 13:58.140
也可以不算

13:58.140 --> 13:59.140
都有些样的算法

13:59.140 --> 14:00.140
所以要问一下

14:00.140 --> 14:01.140
这一集

14:01.140 --> 14:02.140
我们来说的是

14:02.140 --> 14:03.140
二叉数

14:03.140 --> 14:04.140
左右

14:04.140 --> 14:06.140
可以互换的情况下

14:06.140 --> 14:07.140
来判断

14:07.140 --> 14:08.140
它是否相当

14:08.140 --> 14:09.140
下一集

14:09.140 --> 14:10.140
我们来说

14:10.140 --> 14:11.140
如果我们左右互换了之后

14:11.140 --> 14:13.140
还处于同一颗二叉数

14:13.140 --> 14:14.140
还算是相当的话

14:14.140 --> 14:16.140
我们该如何来进行判断

14:16.140 --> 14:17.140
这个内容

14:17.140 --> 14:18.140
我们下一集来说

