WEBVTT

00:01.330 --> 00:03.130
hello 大家好

00:03.130 --> 00:07.130
这一集我们来说两个新的数据解构

00:07.130 --> 00:09.330
一个叫做战 一个叫做对列

00:09.330 --> 00:11.330
什么叫做战 什么叫做对列

00:11.330 --> 00:12.930
这两个词可能经常听

00:12.930 --> 00:18.130
但是很多同学可能对战和对列的了解不够多

00:18.130 --> 00:22.130
战我们可以理解为是一个箱子

00:22.130 --> 00:24.130
我来个无天冲

00:24.130 --> 00:28.130
然后边框 线条 粗一点

00:28.130 --> 00:30.330
假如说这是一个箱子

00:30.330 --> 00:32.330
我想往里面放东西

00:32.330 --> 00:33.330
我想往里面放东西

00:33.330 --> 00:37.330
放这个小方块

00:37.330 --> 00:39.330
这是我的一号小方块 是吧

00:39.330 --> 00:42.330
放进去了 就放进去了 对吧

00:42.330 --> 00:46.330
然后我再有个小方块 二号小方块

00:46.330 --> 00:49.330
二号小方块放进去了 就放进去了

00:49.330 --> 00:52.330
想想到假日说再大一点

00:52.330 --> 00:56.330
我来一个三号小方块

00:56.330 --> 00:58.330
三号小方块放进去了

00:58.330 --> 00:59.330
我也能放进去

00:59.330 --> 01:02.330
但是这个时候我想往外拿

01:02.330 --> 01:04.330
我是不是只能拿出来第三个 是吧

01:04.330 --> 01:06.330
一和二都压在底下呢

01:06.330 --> 01:08.330
我拿不出来第一个和第二个

01:08.330 --> 01:10.330
我只能先拿出来第三个

01:10.330 --> 01:14.330
再拿出来第二个 最后才能拿出来第一个

01:14.330 --> 01:17.330
这种形式就叫做战

01:17.330 --> 01:23.920
战数据结构

01:23.920 --> 01:25.920
战结构有一个特点

01:25.920 --> 01:32.320
叫做先进后出

01:32.320 --> 01:36.320
先进后出

01:36.320 --> 01:38.320
这是一个箱子

01:38.320 --> 01:41.320
可以类比成箱子

01:41.320 --> 01:47.320
类比成一个箱子

01:47.320 --> 01:50.320
先放进去的

01:50.320 --> 01:55.530
被压在了下面

01:55.530 --> 01:57.530
这就是一个战结构

01:57.530 --> 01:59.530
我们经常说的我们的变量

01:59.530 --> 02:01.530
变量的声明其实就是个战结构

02:01.530 --> 02:02.530
是吧

02:02.530 --> 02:03.530
变量在最底层

02:03.530 --> 02:05.530
我一个函数结束了之后

02:05.530 --> 02:07.530
我要释放的变量是什么

02:07.530 --> 02:10.530
我释放的变量都是后创建的

02:10.530 --> 02:12.530
我释放的变量都是后创建的

02:12.530 --> 02:14.530
先创建的变量都在最底下压震

02:14.530 --> 02:16.530
比如说这是全聚变量

02:16.530 --> 02:18.530
这是某一个主函数的变量

02:18.530 --> 02:20.530
然后这是函数里面套着的

02:20.530 --> 02:22.530
其他的子函数的变量 是吧

02:22.530 --> 02:24.530
我先释放的 先释放谁

02:24.530 --> 02:26.530
我子函数运行完了

02:26.530 --> 02:28.530
先释放子函数的

02:28.530 --> 02:30.530
然后再释放我的主函数的

02:30.530 --> 02:32.530
最后这个程序都结束了

02:32.530 --> 02:33.530
我才能释放全聚的

02:33.530 --> 02:34.530
对吧

02:34.530 --> 02:35.530
这就是战结构

02:35.530 --> 02:38.530
战结构是我们程序里面经常用的

02:38.530 --> 02:41.530
和战结构类似的

02:41.530 --> 02:47.500
还有一种我们叫做对列

02:47.500 --> 02:49.500
对列你可以把它理解成什么

02:49.500 --> 02:52.500
对列就是一个管子

02:52.500 --> 02:58.630
对列结构

02:58.630 --> 03:04.070
对列结构的一个特点就是先入先出

03:04.070 --> 03:06.070
先入先出

03:06.070 --> 03:08.070
可以类比成一个管子

03:08.070 --> 03:11.070
成一个管道

03:11.070 --> 03:13.070
可以类比成一个管道

03:13.070 --> 03:15.070
一 从入口进去

03:15.070 --> 03:16.070
到这

03:16.070 --> 03:18.070
然后二 从入口进去

03:18.070 --> 03:19.070
到这

03:19.070 --> 03:20.070
这是上面是入口

03:20.070 --> 03:22.070
三 从入口进去

03:22.070 --> 03:24.070
那想出得从哪边出呢

03:24.070 --> 03:26.070
总能这样一点点往下露

03:26.070 --> 03:27.070
看到了吗

03:27.070 --> 03:29.070
一点一点的往下露

03:29.070 --> 03:30.070
出去

03:30.070 --> 03:31.070
一出去

03:31.070 --> 03:32.070
二出去

03:32.070 --> 03:34.070
三出去

03:34.070 --> 03:36.070
一点点的往下露

03:36.070 --> 03:38.070
这是一个管道型的结构

03:38.070 --> 03:40.070
所以这是对列结构

03:40.070 --> 03:42.070
我们可以用前端的一些

03:42.070 --> 03:44.070
代码来实现

03:44.070 --> 03:46.070
对列结构和战结构

03:46.070 --> 03:48.070
咱们来实现一下

03:48.070 --> 03:49.070
战呢

03:49.070 --> 03:52.070
我们一般叫Stake

03:52.070 --> 03:55.070
Stake被称为一个战

03:55.070 --> 03:57.070
比如说方格生

03:57.070 --> 03:59.070
一个PUSH

03:59.070 --> 04:01.070
再方格生一个POP

04:01.070 --> 04:06.600
然后我们准备一个数组

04:07.600 --> 04:12.230
那这个PUSH和POP都是什么

04:12.230 --> 04:14.230
就是往那个数组里面放是吧

04:14.230 --> 04:16.230
看好了

04:16.230 --> 04:17.230
我先进去

04:17.230 --> 04:18.230
先放一个

04:18.230 --> 04:21.230
比如说我要PUSH一个1

04:21.230 --> 04:23.540
我要PUSH一个1

04:23.540 --> 04:25.540
假如我用AR点PUSH

04:27.540 --> 04:29.540
PUSH一个VALUE

04:29.540 --> 04:32.110
是吧

04:32.110 --> 04:34.110
然后我再PUSH一个2

04:34.110 --> 04:36.110
然后我再PUSH一个3

04:38.110 --> 04:40.110
然后我们来打印一下

04:40.110 --> 04:46.500
是什么结构

04:46.500 --> 04:47.500
是123是吧

04:47.500 --> 04:50.500
当我这个时候希望我POP一下的时候

04:50.500 --> 04:53.500
我希望拿出来的是谁

04:53.500 --> 04:55.500
我希望拿出来的是3是吧

04:55.500 --> 04:57.500
谁最后放进去的

04:57.500 --> 04:59.500
我就要给谁拿出来是吧

04:59.500 --> 05:01.500
那Returned是谁

05:01.500 --> 05:02.500
AR点

05:02.500 --> 05:04.500
也是POP就到了是吧

05:04.500 --> 05:07.500
咱们前端的GS

05:07.500 --> 05:09.500
比任何一种语言

05:09.500 --> 05:11.500
实现战结构都简单

05:11.500 --> 05:12.500
为什么

05:12.500 --> 05:13.500
因为咱们的数组里面有PUSH

05:13.500 --> 05:14.500
POP

05:14.500 --> 05:15.500
SHIFT

05:15.500 --> 05:16.500
安SHIFT的这四个方法

05:16.500 --> 05:18.500
其他的语言里都没有

05:18.500 --> 05:24.540
这是咱们前端的一大优点

05:24.540 --> 05:26.540
我拿出去一个

05:26.540 --> 05:28.540
就剩一二了

05:28.540 --> 05:34.540
我再拿一下

05:34.540 --> 05:35.540
没打印是吧

05:35.540 --> 05:37.540
就变成

05:37.540 --> 05:38.540
只有一个了

05:38.540 --> 05:41.420
是吧

05:41.420 --> 05:42.420
这就是一个战结构

05:42.420 --> 05:44.420
你把它封装起来

05:44.420 --> 05:46.420
你把它封装起来

05:46.420 --> 05:48.420
把它封装到一个

05:48.420 --> 05:50.420
方式

05:50.420 --> 05:52.420
Stick

05:52.420 --> 05:53.420
是吧

05:53.420 --> 05:54.420
这里面写两个是吧

05:54.420 --> 05:56.420
ZS的PUSH

05:56.420 --> 05:57.420
等于

05:57.420 --> 05:59.420
方式

05:59.420 --> 06:01.990
对吧

06:01.990 --> 06:02.990
然后

06:02.990 --> 06:04.990
ZS的POP

06:04.990 --> 06:05.990
等于

06:05.990 --> 06:11.160
方式

06:11.160 --> 06:13.160
是这样的一个结构

06:13.160 --> 06:14.160
是吧

06:14.160 --> 06:16.160
然后我自带有一个数组

06:16.160 --> 06:18.160
是吧

06:18.160 --> 06:20.160
ZS的AR

06:20.160 --> 06:21.160
等于

06:22.160 --> 06:23.160
对

06:23.160 --> 06:24.160
所以说

06:24.160 --> 06:25.160
当我们需要

06:25.160 --> 06:27.160
创建一个对象的时候

06:27.160 --> 06:29.160
玩一个Stick

06:29.160 --> 06:32.660
等于没有一个Stick

06:32.660 --> 06:33.660
是吧

06:33.660 --> 06:35.660
然后Stick的PUSH

06:35.660 --> 06:36.660
一

06:36.660 --> 06:38.660
Stick的PUSH

06:38.660 --> 06:39.660
二

06:39.660 --> 06:41.660
Stick的PUSH

06:41.660 --> 06:43.660
三

06:43.660 --> 06:44.660
然后

06:44.660 --> 06:48.620
打印一下

06:48.620 --> 06:52.620
打印一下Stick的AR

06:52.620 --> 06:54.620
然后我们再Stick

06:54.620 --> 06:58.310
的POP

06:58.310 --> 07:00.940
然后

07:00.940 --> 07:01.940
打印一下

07:01.940 --> 07:03.940
Stick的AR

07:03.940 --> 07:08.900
它都是对ZS的AR进行操作

07:08.900 --> 07:19.660
来试一下

07:19.660 --> 07:20.660
是吧

07:20.660 --> 07:21.660
PUSH的三个就是1,2,3

07:21.660 --> 07:23.660
拿去的一个就剩1,2是吧

07:23.660 --> 07:24.660
这就是Stick

07:24.660 --> 07:25.660
占结构

07:25.660 --> 07:27.660
你们可能会以后在

07:27.660 --> 07:28.660
面试的

07:28.660 --> 07:30.660
这个去

07:30.660 --> 07:32.660
头简历了之后的比式

07:32.660 --> 07:34.660
会经常的遇到这种题

07:34.660 --> 07:35.660
让你用数组

07:35.660 --> 07:36.660
结构

07:36.660 --> 07:38.660
对于咱们GS的代码来说

07:38.660 --> 07:39.660
是非常的简单的

07:39.660 --> 07:41.660
对于咱们GS的代码来说

07:41.660 --> 07:42.660
是非常简单的

07:42.660 --> 07:46.100
对列怎么办

07:46.100 --> 07:47.100
对列

07:47.100 --> 07:48.100
Stick

07:48.100 --> 07:49.100
你说很好整

07:49.100 --> 07:51.100
对列

07:51.100 --> 07:52.100
对列

07:52.100 --> 07:55.740
通常叫做Q

07:55.740 --> 07:56.740
然后

07:56.740 --> 07:57.740
对列

07:57.740 --> 07:58.740
也可以往里面PUSH

07:58.740 --> 07:59.740
也可以往外拿

07:59.740 --> 08:01.740
ZS也是用AR来实现

08:01.740 --> 08:03.740
也是用AR来实现

08:03.740 --> 08:04.740
ZS的PUSH

08:04.740 --> 08:06.740
也是等于一个方式

08:06.740 --> 08:07.740
往后面TN

08:07.740 --> 08:08.740
就是往后面TN就得了

08:08.740 --> 08:09.740
是吧

08:09.740 --> 08:13.740
就是还是ZS的AR.PUSH

08:13.740 --> 08:14.740
来流

08:14.740 --> 08:18.740
但是它往外拿的时候

08:18.740 --> 08:20.740
但是它往外拿的时候

08:20.740 --> 08:23.740
这回可不能调用POP方法

08:23.740 --> 08:27.520
往外拿的时候

08:27.520 --> 08:29.520
不能调用POP方法

08:29.520 --> 08:30.520
POP方法是什么

08:30.520 --> 08:31.520
从数组的摸尾

08:31.520 --> 08:32.520
拿出去一个是吧

08:32.520 --> 08:33.520
对列是什么

08:33.520 --> 08:34.520
你先进的

08:34.520 --> 08:35.520
得先出是吧

08:35.520 --> 08:36.520
必须得从

08:36.520 --> 08:39.960
前面拿出去一个

08:39.960 --> 08:40.960
ZS的AR点是什么

08:40.960 --> 08:41.960
从前面拿是吧

08:41.960 --> 08:43.960
Shift是吧

08:43.960 --> 08:44.960
是吧

08:44.960 --> 08:45.960
Shift

08:45.960 --> 08:47.960
我们来试一下

08:47.960 --> 08:49.960
Ware一个QUE

08:49.960 --> 08:50.960
UE

08:50.960 --> 08:51.960
等于

08:51.960 --> 08:53.960
你有一个QUEUE

08:53.960 --> 08:57.960
然后QUEUE的PUSH

08:57.960 --> 08:58.960
1

08:58.960 --> 08:59.960
2

08:59.960 --> 09:01.960
3

09:01.960 --> 09:03.960
然后我们来打印一下

09:03.960 --> 09:07.960
QUEUE的AR

09:07.960 --> 09:09.960
然后我们再拿出来一个

09:09.960 --> 09:13.590
然后我们再来打印一下

09:13.590 --> 09:18.820
看

09:18.820 --> 09:19.820
放上去了3是吧

09:19.820 --> 09:20.820
123

09:20.820 --> 09:21.820
然后拿出来一个1

09:21.820 --> 09:22.820
是吧

09:22.820 --> 09:24.820
这回从前面拿出来一个

09:24.820 --> 09:25.820
这样的话

09:25.820 --> 09:27.820
我们就能封装出来一个对列

09:27.820 --> 09:30.820
这就是用JS来封装对列结构

09:30.820 --> 09:31.820
你会发现什么

09:31.820 --> 09:32.820
Java、C

09:32.820 --> 09:34.820
用他们的数组去封装对列

09:34.820 --> 09:36.820
和站超级的麻烦

09:36.820 --> 09:38.820
但是在我们JS里面

09:38.820 --> 09:39.820
就非常简单

09:39.820 --> 09:41.820
这个都是有助于

09:41.820 --> 09:43.820
AR这个函数

09:43.820 --> 09:44.820
封装的好

09:44.820 --> 09:45.820
它是个底层

09:45.820 --> 09:47.820
封装动态的数组

09:47.820 --> 09:49.820
它这个程度是可以变的

09:49.820 --> 09:50.820
所以说

09:50.820 --> 09:51.820
让我们来

09:51.820 --> 09:52.820
基于这个数字

09:52.820 --> 09:54.820
来封装Stake和QUEUE对列的话

09:54.820 --> 09:56.820
就变得非常的简单

09:56.820 --> 09:57.820
如果有一天的话

09:57.820 --> 09:58.820
你就知道这样的题的话

09:58.820 --> 09:59.820
千万不要忘了

09:59.820 --> 10:00.820
这样的封装方法

10:00.820 --> 10:01.820
这就是

10:01.820 --> 10:03.820
站和对列

