WEBVTT

00:01.070 --> 00:03.070
哈喽大家好

00:03.070 --> 00:07.070
上一集我们说了二大树的深度幼园搜索

00:07.070 --> 00:12.070
这一集我们来说二大树的广度幼园搜索是如何实现的

00:12.070 --> 00:16.070
广度幼园搜索比深度幼园搜索要复杂一些

00:16.070 --> 00:20.070
它的代码没有我们想象中那么容易

00:20.070 --> 00:24.070
广度幼园搜索你不能直接通过这样简单的地规就实现

00:24.070 --> 00:27.070
这是广度幼园搜索达不到的

00:28.070 --> 00:35.970
我先来充电一个吧

00:35.970 --> 00:37.970
28

00:37.970 --> 00:40.970
二叉树代码实现

00:40.970 --> 00:43.970
二叉树的广度

00:43.970 --> 00:50.330
优先搜索

00:50.330 --> 00:53.330
这么一个内容广度幼园搜索

00:53.330 --> 00:56.330
还是我们还是得构建是吧

00:56.330 --> 00:59.330
其实这个东西我都快写完了

00:59.330 --> 01:02.330
方个是node value

01:02.330 --> 01:05.330
然后这次的value等于value

01:05.330 --> 01:08.330
这次的life等于空

01:08.330 --> 01:14.110
然后这次的right等于空

01:14.110 --> 01:17.110
我写的已经熟的都不得了了是吧

01:17.110 --> 01:20.110
等于new一个node然后这是a

01:20.110 --> 01:24.110
然后abcdfg是吧abcdefg是吧

01:24.110 --> 01:28.110
然后能a的b

01:28.110 --> 01:33.110
cdefg

01:33.110 --> 01:37.110
abcdefg

01:37.110 --> 01:41.110
然后a的life是等于c是吧

01:41.110 --> 01:44.110
然后a的right等于b是吧

01:44.110 --> 01:47.110
然后c的life等于啥来着

01:47.110 --> 01:51.810
c的life等于f

01:51.810 --> 01:54.810
c的right等于g

01:54.810 --> 01:58.810
然后b的life等于d

01:58.810 --> 02:01.810
然后b的right等于e

02:01.810 --> 02:03.810
这是一叉二叉树是吧

02:03.810 --> 02:07.810
然后我们现在进行广度一些搜索是吧

02:07.810 --> 02:09.810
给我一个root

02:09.810 --> 02:11.810
然后给我一个target

02:11.810 --> 02:13.810
给我一个根基点给我一个路边

02:13.810 --> 02:14.810
我要进行搜索

02:14.810 --> 02:16.810
首先还是第一步

02:16.810 --> 02:17.810
年底性判断

02:17.810 --> 02:19.810
如果root它都是空的话

02:19.810 --> 02:20.810
我们肯定什么东西都没有

02:20.810 --> 02:22.810
我就recent a first

02:22.810 --> 02:23.810
完事

02:23.810 --> 02:25.810
如果root不为空

02:25.810 --> 02:27.810
如果root不为空

02:27.810 --> 02:29.810
我该

02:29.810 --> 02:32.810
检验什么

02:32.810 --> 02:34.810
我该检验什么

02:34.810 --> 02:35.810
我该检验什么

02:35.810 --> 02:37.810
我该检验什么

02:37.810 --> 02:40.810
我该检验根基点

02:40.810 --> 02:42.810
还是该检验一个

02:42.810 --> 02:44.810
一些什么东西

02:44.810 --> 02:45.810
看好了

02:45.810 --> 02:48.810
这个root我们这会不传root

02:48.810 --> 02:56.590
我叫root list

02:56.590 --> 02:57.590
这是一个根基点

02:57.590 --> 02:58.590
我这会不传单个

02:58.590 --> 03:00.590
我传在集合

03:00.590 --> 03:04.590
那就是或root list的lens

03:04.590 --> 03:07.970
等于0也不行

03:07.970 --> 03:09.970
等于0也不行

03:09.970 --> 03:11.970
就是这样的一个节奏

03:17.410 --> 03:19.410
这个root现在是list

03:19.410 --> 03:21.410
是不止一个节点

03:21.410 --> 03:23.410
这是不止一个节点

03:23.410 --> 03:25.410
之前我们伸搜都是传一个键

03:25.410 --> 03:27.410
现在我这是不止一个键点

03:27.410 --> 03:28.410
看好了

03:28.410 --> 03:33.230
如果不为空的话

03:33.230 --> 03:34.230
i等于0

03:34.230 --> 03:38.230
i小于root list的lens

03:38.230 --> 03:39.230
变立每个节点

03:39.230 --> 03:40.230
看一下这个节点里面

03:40.230 --> 03:43.230
到底是不是

03:43.230 --> 03:48.230
判断root list的i

03:48.230 --> 03:51.230
等于y6

03:51.230 --> 03:54.230
首先root list的不能等于空

03:54.230 --> 03:58.230
root list的i

03:58.230 --> 04:01.230
不能等于空

04:01.230 --> 04:05.230
并且它的y6

04:05.230 --> 04:09.230
等于

04:09.230 --> 04:10.230
怎么办

04:10.230 --> 04:11.230
就啥也别管了

04:11.230 --> 04:13.230
就root list出就得了

04:13.230 --> 04:17.230
否则呢

04:17.230 --> 04:18.230
看好了

04:18.230 --> 04:20.230
广度优先搜索的是一层一层

04:20.230 --> 04:21.230
比如说第一层

04:21.230 --> 04:23.230
这个list只有一个节点

04:23.230 --> 04:24.230
是吧

04:24.230 --> 04:25.230
如果它不行

04:25.230 --> 04:28.230
我就把它的两个孩子都放在集合里

04:28.230 --> 04:31.230
交给下一层级来做

04:31.230 --> 04:32.230
是吧

04:32.230 --> 04:33.230
第二层级的时候

04:33.230 --> 04:34.230
list有两个节点

04:34.230 --> 04:35.230
如果c不行

04:35.230 --> 04:38.230
我把fg放在一个集合里

04:38.230 --> 04:39.230
b不行

04:39.230 --> 04:41.230
把b和e再添到端产的集合里

04:41.230 --> 04:42.230
是吧

04:42.230 --> 04:44.230
所以我必须得

04:44.230 --> 04:47.230
为一个集合

04:47.230 --> 04:51.800
chilled list

04:51.800 --> 04:53.800
如果不行的话

04:53.800 --> 04:56.800
我要给chilled list的push

04:56.800 --> 04:57.800
push什么呢

04:57.800 --> 04:59.800
root list i

04:59.800 --> 05:01.800
the left

05:01.800 --> 05:06.430
以及root list

05:07.430 --> 05:09.430
i the right

05:10.430 --> 05:12.430
把它两个纸节点给扔进去

05:12.430 --> 05:13.430
所以说

05:13.430 --> 05:14.430
如果相同的话

05:14.430 --> 05:15.430
就root list出

05:15.430 --> 05:16.430
如果不相同的话

05:16.430 --> 05:17.430
就把它两个纸节点扔进去

05:17.430 --> 05:19.430
如果变成一圈

05:19.430 --> 05:20.430
没有相同的

05:20.430 --> 05:21.430
我有一个chilled list

05:21.430 --> 05:22.430
是吧

05:22.430 --> 05:23.430
return

05:23.430 --> 05:25.430
fe

05:25.430 --> 05:28.740
fe

05:28.740 --> 05:30.740
chilled list

05:30.740 --> 05:32.740
它改起

05:32.740 --> 05:34.740
这样的话

05:34.740 --> 05:35.740
我第一次

05:35.740 --> 05:36.740
我看的是我当前这个节点

05:36.740 --> 05:37.740
如果不行的话

05:37.740 --> 05:38.740
我把下一层的节点

05:38.740 --> 05:39.740
放到例子里

05:39.740 --> 05:40.740
下一层来判断

05:40.740 --> 05:41.740
是吧

05:41.740 --> 05:42.740
每一层判断的

05:42.740 --> 05:44.740
都是刚才给我传进来的集合

05:44.740 --> 05:45.740
是吧

05:45.740 --> 05:46.740
第二层如果不行的话

05:46.740 --> 05:49.740
把下一层都压到例子里

05:49.740 --> 05:50.740
把这个集合

05:50.740 --> 05:51.740
传到下一层

05:51.740 --> 05:54.740
下一层一起来判

05:54.740 --> 05:55.740
这就是一个

05:55.740 --> 05:56.740
深度约定的搜索

05:56.740 --> 05:57.740
来看一下

05:57.740 --> 06:02.440
log

06:02.440 --> 06:04.440
fe

06:04.440 --> 06:07.440
一个集合a

06:07.440 --> 06:08.440
我们最开始只有一个

06:08.440 --> 06:09.440
是吧

06:09.440 --> 06:11.440
然后我们找f在不在里面

06:11.440 --> 06:14.840
出是吧

06:14.840 --> 06:15.840
我们看一下打印一下

06:15.840 --> 06:17.840
打印一下这个顺序

06:17.840 --> 06:19.840
看一下打印的这个顺序

06:20.840 --> 06:22.840
console.log

06:22.840 --> 06:24.840
root list

06:24.840 --> 06:27.840
a

06:27.840 --> 06:35.930
2.6

06:35.930 --> 06:37.930
ab

06:37.930 --> 06:38.930
acbf是吧

06:38.930 --> 06:40.930
acbf

06:40.930 --> 06:41.930
是吧

06:41.930 --> 06:42.930
一层一层的

06:42.930 --> 06:43.930
它跟深度不一样

06:43.930 --> 06:44.930
a打b

06:44.930 --> 06:45.930
c打b

06:45.930 --> 06:46.930
d

06:46.930 --> 06:49.930
如果我要找的是e

06:53.710 --> 06:56.710
是不是acbfgd

06:56.710 --> 06:58.710
acbfgd

06:58.710 --> 07:00.710
它是一层一层的去打

07:00.710 --> 07:02.710
而不是深度约定搜索

07:02.710 --> 07:03.710
我要去打

07:03.710 --> 07:06.710
我在网上找到这些内容

07:06.710 --> 07:09.710
我觉得c率怎么老抢卦呢

07:09.710 --> 07:15.710
我把手机关机

07:15.710 --> 07:16.710
好了

07:16.710 --> 07:19.710
这个就是一个深度约定搜索

07:19.710 --> 07:21.710
我们把

07:21.710 --> 07:23.710
当前一层的先判断一遍

07:23.710 --> 07:24.710
如果不行的话

07:24.710 --> 07:25.710
把它的紫节点

07:25.710 --> 07:27.710
压到chill的list的里面

07:27.710 --> 07:28.710
这样的话

07:28.710 --> 07:30.710
我最后chill的list是什么呢

07:30.710 --> 07:32.710
是当前层

07:34.710 --> 07:35.710
所有

07:35.710 --> 07:36.710
节点的

07:36.710 --> 07:37.710
紫节点

07:38.710 --> 07:39.710
都在

07:41.710 --> 07:42.710
这个list

07:43.710 --> 07:44.710
这样

07:44.710 --> 07:45.710
传入

07:46.710 --> 07:49.020
下一层级的时候

07:50.020 --> 07:53.680
这样的话

07:53.680 --> 07:55.680
我们再传入下一个层级的时候

07:55.680 --> 07:56.680
就可以

07:57.680 --> 08:00.120
便利

08:01.120 --> 08:02.120
整个

08:02.120 --> 08:03.120
层级的

08:03.120 --> 08:04.120
节点

08:04.120 --> 08:05.120
是吧

08:05.120 --> 08:06.120
传入下一个层级的时候

08:06.120 --> 08:08.120
就可以便利整个层级的节点

08:08.120 --> 08:10.120
我是一层一层的

08:10.120 --> 08:11.120
往下传的

08:11.120 --> 08:12.120
是吧

08:12.120 --> 08:14.120
你必须得便利第二层

08:14.120 --> 08:16.120
你才能获得第三层的所有的节点

08:16.120 --> 08:18.120
当我获得了第三层的节点

08:18.120 --> 08:19.120
每获得一个

08:19.120 --> 08:21.120
我就往chill的list里放了

08:21.120 --> 08:22.120
什么事

08:23.120 --> 08:24.120
这种方式

08:24.120 --> 08:26.120
我们就可以做到广度渊搜索

08:26.120 --> 08:27.120
广度渊搜索

08:28.120 --> 08:30.120
所以说做到广度渊搜索的代码

08:30.120 --> 08:31.120
其实也挺容易的

08:32.120 --> 08:33.120
不难

08:33.120 --> 08:35.120
大家回去一定要练一下

08:35.120 --> 08:38.120
这是二叉树的深搜和广搜

08:39.120 --> 08:41.120
二叉树还有很多的概念

08:41.120 --> 08:43.120
比如说一些什么二叉树的比较

08:44.120 --> 08:46.120
还有我们要用图来生成二叉树

08:47.120 --> 08:48.120
我们后续

08:48.120 --> 08:49.120
来个来讲

