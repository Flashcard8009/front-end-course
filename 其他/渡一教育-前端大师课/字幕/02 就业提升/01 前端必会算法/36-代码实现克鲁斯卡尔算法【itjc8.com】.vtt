WEBVTT

00:01.010 --> 00:03.010
Hello 大家好

00:03.010 --> 00:05.010
上一集我们说了普林姆算法

00:05.010 --> 00:09.010
这一集我们来说说这个科洛斯卡尔算法

00:09.010 --> 00:12.010
普林姆算法号称加点法

00:12.010 --> 00:14.010
科洛斯卡尔算法号称加编法

00:14.010 --> 00:17.010
无论是加点法还是加编法

00:17.010 --> 00:19.010
我们在描述一个图的时候

00:19.010 --> 00:22.010
都是要传入他的所有的点的集合

00:22.010 --> 00:25.010
以及他所有编的距离的集合

00:25.010 --> 00:28.010
传入这个点集和编集

00:28.010 --> 00:31.010
我们来写一个function

00:31.010 --> 00:33.010
借一个crucical

00:33.010 --> 00:36.010
如果看着这样的单词的话代表的是科洛斯卡尔算法

00:36.010 --> 00:38.010
代表科洛斯卡尔算法

00:38.010 --> 00:39.010
我们希望给我们传入什么呢

00:39.010 --> 00:41.010
还是一个点的集合

00:41.010 --> 00:43.010
pointer sight

00:43.010 --> 00:46.010
还有一个编辑 distance

00:46.010 --> 00:50.010
我们就希望他们给我们传入这两个东西就够了

00:50.010 --> 00:51.010
然后在调用的时候

00:51.010 --> 00:55.010
我们就crucical

00:55.010 --> 00:57.010
pointer sight distance

00:59.010 --> 01:02.010
这样的话就能调用科洛斯卡尔算法了

01:02.010 --> 01:05.010
然后我们希望在科洛斯卡尔算法里面

01:05.010 --> 01:07.010
我们要干嘛加编是吧

01:07.010 --> 01:09.010
他们不像普利姆算法

01:09.010 --> 01:11.010
普利姆算法得给一个其实点

01:11.010 --> 01:13.010
科洛斯卡尔不用

01:13.010 --> 01:14.010
科洛斯卡尔算法

01:14.010 --> 01:18.010
我自己线算哪个编最短

01:18.010 --> 01:20.010
我自己线算哪个编最短

01:20.010 --> 01:22.010
那怎么算

01:22.010 --> 01:24.010
怎么算

01:24.010 --> 01:27.010
维尔一个min distance

01:27.010 --> 01:30.010
找到一个设定一个最小的编

01:30.010 --> 01:32.010
默认指我让它是max

01:32.010 --> 01:33.010
是个很大

01:33.010 --> 01:35.010
这样的话只要是个编就应该比它小

01:35.010 --> 01:36.010
对吧

01:36.010 --> 01:38.010
然后咱们再定一个起点

01:38.010 --> 01:41.010
begin

01:41.010 --> 01:44.010
咱们再定一个终点

01:45.010 --> 01:47.010
有个起点一个终点

01:47.010 --> 01:50.010
然后我就在各个编里面找

01:50.010 --> 01:51.010
两重循环

01:51.010 --> 01:55.010
因为5个点之间都可以相互的连接

01:55.010 --> 01:56.010
是吧

01:56.010 --> 01:57.010
我就找

01:57.010 --> 01:59.010
维尔一个i

01:59.010 --> 02:00.010
等于0

02:00.010 --> 02:04.010
i小于distance的lens

02:04.010 --> 02:05.010
i下降

02:05.010 --> 02:07.010
内重循环

02:07.010 --> 02:11.090
副循环

02:11.090 --> 02:13.090
一个接

02:13.090 --> 02:16.090
接小于distancei的lens

02:16.090 --> 02:18.090
因为便利这个二维数组

02:18.090 --> 02:20.090
distance它是个二维数组

02:20.090 --> 02:21.090
对吧

02:22.090 --> 02:23.090
然后

02:23.090 --> 02:25.090
begin

02:25.090 --> 02:27.090
是怎么获得的

02:27.090 --> 02:29.090
begin

02:29.090 --> 02:32.400
begin如何获得

02:32.400 --> 02:35.400
我们希望得到的是begin的什么

02:35.400 --> 02:38.400
我们随便拿到一个点作为起点

02:38.400 --> 02:40.400
然后在随便拿到一个编

02:40.400 --> 02:43.400
作为随便拿到一个点作为终点

02:43.400 --> 02:46.400
然后我们看一下这两个点之间的一个距离

02:46.400 --> 02:48.400
begin

02:48.400 --> 02:50.900
begin什么

02:50.900 --> 02:52.900
等于di一个点

02:52.900 --> 02:53.900
是吧

02:53.900 --> 02:54.900
di一个点

02:54.900 --> 02:56.900
就是point side

02:56.900 --> 02:58.900
对吧

02:58.900 --> 03:00.900
按的呢

03:00.900 --> 03:02.900
按的就是di一个点

03:02.900 --> 03:04.900
point side

03:04.900 --> 03:08.540
接

03:08.540 --> 03:09.540
没有问题是吧

03:09.540 --> 03:10.540
没有问题

03:10.540 --> 03:13.540
然后如果什么样的情况下

03:13.540 --> 03:16.540
我们判断下什么情况下算

03:16.540 --> 03:17.540
i和接相等

03:17.540 --> 03:18.540
那时候是啥意思

03:18.540 --> 03:19.540
i和接相等

03:19.540 --> 03:20.540
那时候代表的是自己

03:20.540 --> 03:21.540
到自己

03:21.540 --> 03:22.540
是吧

03:22.540 --> 03:23.540
对角线什么

03:23.540 --> 03:24.540
i和接相等

03:24.540 --> 03:25.540
对角线对吧

03:25.540 --> 03:26.540
自己和相等

03:26.540 --> 03:27.540
自己不能相等是吧

03:27.540 --> 03:30.540
首先i不等于接

03:30.540 --> 03:33.540
这是为了什么呢

03:33.540 --> 03:37.540
为了去掉

03:37.540 --> 03:40.540
自己到自己的距离

03:41.540 --> 03:43.540
因为都为0

03:43.540 --> 03:44.540
对吧

03:44.540 --> 03:46.540
因为都为0

03:46.540 --> 03:47.540
这个得去掉

03:47.540 --> 03:49.540
然后起

03:49.540 --> 03:50.540
第二种情况

03:51.540 --> 03:52.540
distance

03:52.540 --> 03:53.540
是不是得小于

03:53.540 --> 03:54.540
我们

03:54.540 --> 03:55.540
预订的distance

03:55.540 --> 03:56.540
对吧

03:56.540 --> 03:57.540
distance

03:57.540 --> 03:58.540
id

03:58.540 --> 03:59.540
我得小于

03:59.540 --> 04:01.540
min distance

04:01.540 --> 04:02.540
对吧

04:02.540 --> 04:04.540
我得小于min distance

04:04.540 --> 04:06.540
然后呢

04:06.540 --> 04:07.540
小于了还不行

04:07.540 --> 04:08.540
我还不知道

04:08.540 --> 04:09.540
能不能连接

04:09.540 --> 04:10.540
是否能够连接

04:10.540 --> 04:11.540
咱们说了

04:11.540 --> 04:12.540
close car

04:12.540 --> 04:13.540
有哪些种情况不能连接

04:13.540 --> 04:14.540
看看ppd

04:15.540 --> 04:16.540
close car

04:16.540 --> 04:17.540
哪种东西不能连接

04:17.540 --> 04:19.540
我们得有两种情况是吧

04:19.540 --> 04:22.540
一个是他至少得连接一个新的点

04:22.540 --> 04:23.540
是吧

04:23.540 --> 04:24.540
要比接是新的

04:24.540 --> 04:25.540
要么按的是新的

04:25.540 --> 04:26.540
对吧

04:26.540 --> 04:28.540
或者将这两个边

04:28.540 --> 04:30.540
连接的是两个部落

04:30.540 --> 04:31.540
或者这两个边

04:31.540 --> 04:33.540
连接的是两个部落

04:33.540 --> 04:37.540
所以我们要进行一下测试

04:37.540 --> 04:38.540
是吧

04:38.540 --> 04:39.540
写一个方法

04:39.540 --> 04:40.540
clink

04:40.540 --> 04:42.540
但是我们根本就没有

04:42.540 --> 04:43.540
clink这么个东西

04:43.540 --> 04:45.540
我们来写一个方式

04:45.540 --> 04:46.540
clink

04:47.540 --> 04:48.540
是吧

04:48.540 --> 04:50.540
能否连接

04:50.540 --> 04:51.540
然后你看看

04:51.540 --> 04:53.540
我们要往里面传什么

04:54.540 --> 04:56.540
咱往里面传什么

04:56.540 --> 04:57.540
一个是

04:57.540 --> 04:58.540
这不能用比拼的

04:58.540 --> 04:59.540
叫type比拼

05:00.540 --> 05:04.540
为了一个type比拼

05:04.540 --> 05:07.540
然后我为了一个type

05:08.540 --> 05:10.540
是我们要判断的是什么

05:10.540 --> 05:12.540
临时的起点

05:12.540 --> 05:14.540
得传进去一个临时的起点是吧

05:14.540 --> 05:16.540
然后传入临时的终点

05:19.040 --> 05:21.040
然后我要判断

05:21.040 --> 05:22.040
这个点

05:22.040 --> 05:24.040
这两个点之间的连线能不能连

05:24.040 --> 05:25.040
是吧

05:25.040 --> 05:27.040
那我现在得有一个什么

05:27.040 --> 05:29.040
我得有一个我哪一些点

05:29.040 --> 05:31.040
被连起来

05:31.040 --> 05:33.040
我得有一个我哪一些点

05:33.040 --> 05:34.040
被连起来

05:34.040 --> 05:35.040
是吧

05:35.040 --> 05:36.040
我问一个

05:37.040 --> 05:38.040
问一个什么

05:38.040 --> 05:41.040
问一个result list

05:43.040 --> 05:45.040
我这个是一个数组

05:46.040 --> 05:48.040
我这个是一个数组

05:48.040 --> 05:50.040
但是我这个数组

05:50.040 --> 05:51.040
是个二维数组

05:51.040 --> 05:53.040
看好了我这个是个二维数组

05:54.040 --> 05:55.040
这里是

05:55.040 --> 05:57.040
二维数组

05:58.040 --> 06:01.040
这个数组代表的是有多少个部落

06:01.040 --> 06:02.040
代表的是

06:03.040 --> 06:05.040
此数组

06:06.040 --> 06:08.040
代表的是

06:08.040 --> 06:11.040
有多少个部落

06:11.040 --> 06:14.040
还记着部落这个词是怎么来的

06:14.040 --> 06:15.040
当

06:15.040 --> 06:16.040
4

06:16.040 --> 06:17.040
这条边连结的时候

06:17.040 --> 06:19.040
当6还没有连结的时候

06:20.040 --> 06:22.040
7也没有连结的时候

06:22.040 --> 06:25.040
4先将A和B连在一块形成了一个部落

06:25.040 --> 06:28.040
5一连将C和D连结在一块

06:28.040 --> 06:30.040
形成了一个部落

06:30.040 --> 06:32.040
我们这个时候有了一个红色部落

06:32.040 --> 06:33.040
有个黄色部落

06:33.040 --> 06:35.040
我们说下一条边线

06:35.040 --> 06:37.040
要么得有一个点是新的

06:38.040 --> 06:40.040
要不然得连接出来两个部落

06:40.040 --> 06:42.040
所以说我们这个理解

06:43.040 --> 06:45.040
所以说我们这个里面存的是部落

06:47.040 --> 06:49.040
result list里面存的是部落

06:49.040 --> 06:51.040
所以说result里面

06:51.040 --> 06:53.040
一个部落里面也是一个数组

06:53.040 --> 06:55.040
比如说某一个部落里面只有A和B

06:55.040 --> 06:56.040
那就是A和B

06:56.040 --> 06:58.040
然后另一个部落里面有C和D

06:58.040 --> 06:59.040
那就是C和D

06:59.040 --> 07:00.040
类似于这样

07:00.040 --> 07:01.040
这样的一个结果

07:01.040 --> 07:03.040
所以result list

07:03.040 --> 07:05.040
我们存放的是有多少个部落

07:06.040 --> 07:08.040
然后我们把部落也传进去

07:08.040 --> 07:10.040
把部落也传进去

07:11.040 --> 07:12.040
result list

07:13.040 --> 07:15.040
因为通过这个东西

07:15.040 --> 07:16.040
它就能判断

07:16.040 --> 07:18.040
它不明硬是不是新的

07:18.040 --> 07:19.040
它不暗的是不是新的

07:19.040 --> 07:20.040
如果都不是新的的话

07:20.040 --> 07:21.040
它

07:21.040 --> 07:23.040
它们两个点是不是来自于两个部落

07:23.040 --> 07:24.040
是吧

07:24.040 --> 07:25.040
就可以判断出来了

07:25.040 --> 07:26.040
这是看令

07:26.040 --> 07:28.040
如果成功了的话

07:28.040 --> 07:29.040
如果成功了的话

07:29.040 --> 07:30.040
那明Dase

07:30.040 --> 07:31.040
那就得更新了

07:31.040 --> 07:33.040
刷新一下最短距离的记录

07:34.040 --> 07:35.040
来接

07:37.040 --> 07:38.040
然后Begin

07:38.040 --> 07:39.040
Begin

07:39.040 --> 07:41.040
等于Tie不Begin

07:42.040 --> 07:43.040
然后按的

07:43.040 --> 07:45.040
等于Tie不按的

07:46.040 --> 07:48.040
就干一个这么个事

07:48.040 --> 07:50.040
然后两重复运完之后

07:50.040 --> 07:51.040
我们干一个什么事

07:51.040 --> 07:52.040
把这两个点给连接在一块

07:52.040 --> 07:53.040
是吧

07:54.040 --> 07:55.040
Binck

07:55.040 --> 07:56.040
这个东西

07:56.040 --> 07:57.040
还没有做这个方法

07:57.040 --> 07:58.040
是吧

07:58.040 --> 07:59.040
我们再写一个

07:59.040 --> 08:00.040
方式Binck

08:00.040 --> 08:01.040
将这两个点

08:01.040 --> 08:02.040
给它连接在一块

08:02.040 --> 08:03.040
高则往这边放

08:03.040 --> 08:04.040
result list

08:04.040 --> 08:06.040
然后Begin

08:06.040 --> 08:07.040
按的

08:07.040 --> 08:08.040
高则们

08:08.040 --> 08:09.040
这回是真连

08:09.040 --> 08:10.040
刚才是测试一下

08:10.040 --> 08:11.040
连个点

08:11.040 --> 08:12.040
这样的话

08:12.040 --> 08:13.040
从这到这

08:13.040 --> 08:14.040
是天进去

08:14.040 --> 08:15.040
一条线

08:15.040 --> 08:16.040
对吧

08:16.040 --> 08:17.040
我们有多少条线

08:17.040 --> 08:18.040
不知道

08:18.040 --> 08:19.040
所以呢

08:19.040 --> 08:20.040
要Vouche

08:20.040 --> 08:21.040
我们说了

08:21.040 --> 08:23.040
直到次数的用Full循环

08:23.040 --> 08:25.040
不知道次数的用Vouche循环

08:25.040 --> 08:26.040
是吧

08:28.040 --> 08:29.040
Vouche

08:29.040 --> 08:30.040
然后

08:30.040 --> 08:31.040
什么时候退出

08:31.040 --> 08:32.040
什么时候退出

08:35.480 --> 08:37.480
这是result list

08:37.480 --> 08:38.480
list的size

08:38.480 --> 08:39.480
the length

08:40.480 --> 08:41.480
等于代表什么

08:41.480 --> 08:43.480
只存在一个部落

08:43.480 --> 08:45.480
只存在一个部落

08:46.480 --> 08:50.480
只存在一个部落

08:50.480 --> 08:52.480
然后并且

08:52.480 --> 08:53.480
并且怎么办

08:53.480 --> 08:55.480
这个部落里的

08:55.480 --> 08:56.480
村庄数

08:56.480 --> 09:00.650
得是

09:00.650 --> 09:01.650
和我的

09:01.650 --> 09:02.650
所有的村庄的

09:02.650 --> 09:03.650
总和是相等的

09:03.650 --> 09:04.650
是吧

09:04.650 --> 09:05.650
这样代表的是

09:05.650 --> 09:06.650
我所有的村庄

09:06.650 --> 09:07.650
都连接到了

09:07.650 --> 09:08.650
同一个部落里

09:09.650 --> 09:10.650
然后可以

09:11.650 --> 09:12.650
这个时候

09:12.650 --> 09:13.650
我们难题就剩两个

09:13.650 --> 09:14.650
是吧

09:14.650 --> 09:15.650
难题一个是看link

09:15.650 --> 09:16.650
一个是link

09:16.650 --> 09:17.650
是吧

09:17.650 --> 09:18.650
我们先看看link

09:18.650 --> 09:19.650
看它能不能连接到一起

09:19.650 --> 09:20.650
我们有三个没了

09:20.650 --> 09:21.650
是吧

09:21.650 --> 09:22.650
result list

09:22.650 --> 09:23.650
time begin time on

09:26.790 --> 09:27.790
result

09:27.790 --> 09:28.790
result list

09:28.790 --> 09:30.790
然后time begin

09:30.790 --> 09:32.790
和这个time on

09:32.790 --> 09:33.790
begin和on

09:33.790 --> 09:34.790
它就是两个点

09:34.790 --> 09:35.790
对吧

09:35.790 --> 09:36.790
然后咱们看看

09:36.790 --> 09:37.790
咱们看看

09:38.790 --> 09:39.790
看看一个什么

09:39.790 --> 09:40.790
这个

09:40.790 --> 09:41.790
node 1

09:41.790 --> 09:43.790
在哪一个部落里

09:43.790 --> 09:44.790
就是这个

09:44.790 --> 09:45.790
第一个节点

09:45.790 --> 09:46.790
在哪个部落里

09:47.790 --> 09:48.790
这个begin这个节点

09:48.790 --> 09:49.790
在哪个部落里

09:49.790 --> 09:50.790
我们取一个别辆

09:50.790 --> 09:51.790
比如说叫

09:52.790 --> 09:53.790
begin in

09:56.790 --> 09:57.790
一个on的in

10:00.790 --> 10:01.790
我们看一下

10:01.790 --> 10:02.790
begin在哪个部落里

10:02.790 --> 10:03.790
on的在哪个部落里

10:03.790 --> 10:04.790
好吧

10:05.790 --> 10:06.790
循环一下

10:07.790 --> 10:12.190
为了一个i等于0

10:12.190 --> 10:14.190
i小于result list的籃词

10:16.190 --> 10:18.190
这个便利是吧

10:18.190 --> 10:20.190
然后如果

10:21.190 --> 10:23.190
如果result list

10:24.190 --> 10:25.190
i

10:26.190 --> 10:28.190
the index of

10:29.190 --> 10:30.190
time begin

10:32.190 --> 10:33.190
大约附近

10:34.190 --> 10:35.190
这代表什么

10:36.190 --> 10:37.190
我这个time begin

10:37.190 --> 10:39.190
是在result i里面的

10:39.190 --> 10:40.190
是吧

10:40.190 --> 10:41.190
所以我的begin in

10:41.190 --> 10:43.190
等于result list i

10:44.190 --> 10:45.190
这个部落里

10:45.190 --> 10:46.190
是吧

10:46.190 --> 10:47.190
然后if

10:50.190 --> 10:52.190
result list i

10:54.190 --> 10:56.190
index of

10:57.190 --> 10:58.190
什么

10:58.190 --> 10:59.190
这个time on

11:00.190 --> 11:02.190
如果这个大约附近

11:02.190 --> 11:03.190
这个代表什么

11:03.190 --> 11:04.190
这代表的是

11:04.190 --> 11:06.190
我这个and在这个部落里

11:07.190 --> 11:09.190
等于result list i

11:10.190 --> 11:11.190
是吧

11:11.190 --> 11:13.190
我们拿到了begin和and

11:13.190 --> 11:14.190
所在的部落是吧

11:14.190 --> 11:17.190
如果没有任何部落里面

11:17.190 --> 11:18.190
他们不在任何部落里的话

11:18.190 --> 11:19.190
它就会等于空

11:19.190 --> 11:20.190
是吧

11:20.190 --> 11:22.190
所以我们看这么几种情况

11:22.190 --> 11:23.190
我们看这种几种情况

11:26.190 --> 11:27.190
复讯完之后

11:28.190 --> 11:29.190
复讯完之后

11:29.190 --> 11:30.190
我们就能找到

11:30.190 --> 11:32.190
这两个所在的一个部落了

11:32.190 --> 11:33.190
对吧

11:33.190 --> 11:35.190
我们什么样的情况

11:35.190 --> 11:37.190
说不能连结

11:37.190 --> 11:39.190
什么是情况不能连结

11:39.190 --> 11:42.950
什么是情况不能连结

11:42.950 --> 11:45.950
这两个点在同一个部落里不能连结

11:45.950 --> 11:46.950
对吧

11:46.950 --> 11:47.950
否则都能连结

11:47.950 --> 11:48.950
是吧

11:48.950 --> 11:49.950
我们都有什么情况

11:50.950 --> 11:51.950
两个点

11:53.950 --> 11:54.950
两个点

11:54.950 --> 11:56.950
都是新的点

11:57.950 --> 11:58.950
也就是

11:59.950 --> 12:00.950
都不在

12:01.950 --> 12:02.950
任何部落里

12:06.030 --> 12:07.030
是不是可以连结

12:07.030 --> 12:10.030
对象这是可以连结

12:10.030 --> 12:13.030
然后产生新的部落

12:13.030 --> 12:14.030
是吧

12:14.030 --> 12:15.030
然后

12:15.030 --> 12:20.030
如果begin在a部落

12:20.030 --> 12:22.030
and

12:22.030 --> 12:24.030
没有部落

12:24.030 --> 12:28.880
那相当于什么呢

12:28.880 --> 12:30.880
相当于

12:30.880 --> 12:34.700
a部落

12:34.700 --> 12:35.700
部落

12:35.700 --> 12:38.700
扩张一个

12:39.700 --> 12:40.700
存庄是吧

12:43.700 --> 12:44.700
如果

12:45.700 --> 12:46.700
and

12:46.700 --> 12:47.700
在

12:47.700 --> 12:48.700
a部落

12:49.700 --> 12:50.700
begin

12:51.700 --> 12:53.700
没有部落

12:54.700 --> 12:55.700
这相当于什么呢

12:55.700 --> 12:56.700
相当于

12:56.700 --> 12:57.700
a部落

12:58.700 --> 12:59.700
扩张

13:02.140 --> 13:03.140
一个存庄是吧

13:03.140 --> 13:05.140
这也是相当于扩张那个存庄

13:05.140 --> 13:06.140
还有什么呢

13:06.140 --> 13:07.140
begin

13:08.140 --> 13:09.140
在

13:09.140 --> 13:10.140
a部落

13:11.140 --> 13:12.140
and

13:12.140 --> 13:13.140
在

13:13.140 --> 13:14.140
b部落

13:16.140 --> 13:17.140
这相当于什么

13:17.140 --> 13:18.140
将

13:18.140 --> 13:19.140
ab

13:20.140 --> 13:22.140
两个部落

13:22.140 --> 13:23.140
合并

13:24.140 --> 13:25.140
对吧

13:25.140 --> 13:27.140
只有最后一种不能连结

13:27.140 --> 13:28.140
什么

13:28.140 --> 13:29.140
begin

13:30.140 --> 13:31.140
和

13:31.140 --> 13:32.140
and

13:32.140 --> 13:33.140
在

13:33.140 --> 13:34.140
同一个部落

13:34.140 --> 13:36.140
这种情况下

13:37.140 --> 13:39.140
不可以连结

13:39.140 --> 13:40.140
所以说

13:40.140 --> 13:41.140
只有一种情况下不可以连结

13:41.140 --> 13:42.140
就是

13:42.140 --> 13:43.140
什么呢

13:44.140 --> 13:45.140
这个

13:45.140 --> 13:47.140
begin也不为空

13:49.140 --> 13:50.140
and也不为空

13:50.140 --> 13:52.140
他们都有自己的部落

13:52.140 --> 13:54.140
然后并且

13:54.140 --> 13:57.140
begin和and是同一个部落

13:59.140 --> 14:00.140
这种情况下

14:00.140 --> 14:01.140
不可以连结

14:03.140 --> 14:04.140
其他的情况

14:04.140 --> 14:06.140
全都是可以连结

14:06.140 --> 14:10.570
所以

14:10.570 --> 14:11.570
这个就是

14:11.570 --> 14:12.570
can link

14:12.570 --> 14:13.570
我们在这会儿告诉他

14:13.570 --> 14:14.570
是否可以连结

14:14.570 --> 14:16.570
然后我们一个link

14:16.570 --> 14:17.570
link的方法

14:17.570 --> 14:18.570
跟can link

14:18.570 --> 14:20.570
基本上是一样的

14:20.570 --> 14:21.570
can link是什么

14:21.570 --> 14:23.570
link的就是啥

14:23.570 --> 14:24.570
而且

14:24.570 --> 14:25.570
不但参数一样

14:25.570 --> 14:26.570
甚至写的东西

14:26.570 --> 14:27.570
都一样

14:27.570 --> 14:28.570
link我也得写

14:28.570 --> 14:30.570
我也得写

14:32.940 --> 14:33.940
获得了

14:33.940 --> 14:34.940
begin所在的部落

14:34.940 --> 14:35.940
或者是

14:35.940 --> 14:37.940
and所在的部落

14:37.940 --> 14:38.940
但是这四种情况

14:38.940 --> 14:40.940
我不能合并了

14:40.940 --> 14:41.940
这回我得分开来写

14:43.940 --> 14:44.940
这个就是区别

14:44.940 --> 14:45.940
这四种情况

14:45.940 --> 14:46.940
我得分开来写

14:46.940 --> 14:47.940
是吧

14:47.940 --> 14:48.940
两个点

14:49.940 --> 14:52.940
都是新的点

14:53.940 --> 14:55.940
两个点都是新的点

14:55.940 --> 14:56.940
然后

14:56.940 --> 14:57.940
可以连结

14:57.940 --> 14:58.940
产生新的部落

14:58.940 --> 14:59.940
是吧

14:59.940 --> 15:00.940
这是什么情况

15:00.940 --> 15:01.940
就是efo

15:03.940 --> 15:06.940
beginin等于空

15:06.940 --> 15:07.940
并且

15:07.940 --> 15:10.940
and in等于空

15:10.940 --> 15:11.940
对吧

15:11.940 --> 15:12.940
这是这种情况

15:12.940 --> 15:13.940
是吧

15:13.940 --> 15:14.940
两个部落

15:14.940 --> 15:15.940
产生一个新的部落

15:15.940 --> 15:16.940
是吧

15:16.940 --> 15:18.940
或一个new array

15:20.940 --> 15:22.940
然后把这两个点放下

15:22.940 --> 15:24.940
new array

15:24.940 --> 15:25.940
push

15:25.940 --> 15:27.940
把这两个点

15:27.940 --> 15:28.940
扔进去

15:28.940 --> 15:29.940
一个是

15:30.940 --> 15:32.940
time begin

15:33.940 --> 15:35.940
一个是time and

15:39.470 --> 15:40.470
但是这个新的部落

15:40.470 --> 15:42.470
我得添到我的部落集合

15:42.470 --> 15:43.470
result的例子

15:43.470 --> 15:44.470
是部落的集合

15:44.470 --> 15:45.470
是吧

15:45.470 --> 15:46.470
我的result的例子

15:46.470 --> 15:47.470
push

15:48.470 --> 15:49.470
new array

15:53.830 --> 15:54.830
这是两个点都是新的点

15:54.830 --> 15:55.830
对吧

15:55.830 --> 15:56.830
然后efo

15:59.830 --> 16:00.830
还没这些efo

16:00.830 --> 16:01.830
ios efo

16:01.830 --> 16:02.830
ios efo

16:03.830 --> 16:04.830
讲是吧

16:04.830 --> 16:07.830
beginin等于空

16:07.830 --> 16:09.830
并且and in

16:09.830 --> 16:10.830
不等于空

16:11.830 --> 16:15.620
这是begin

16:15.620 --> 16:16.620
beginin不等于空

16:16.620 --> 16:17.620
and in等于空

16:19.620 --> 16:20.620
这代表的是

16:20.620 --> 16:22.620
begin在a部落

16:23.620 --> 16:24.620
然后and没有部落

16:26.620 --> 16:27.620
对吧

16:27.620 --> 16:30.060
我把注尸放在盒目

16:32.060 --> 16:34.060
这个是begin在a部落

16:34.060 --> 16:35.060
and没有在部落

16:36.060 --> 16:37.060
这个怎么样

16:37.060 --> 16:39.060
是a所在的部落

16:39.060 --> 16:40.060
得添加进去

16:40.060 --> 16:41.060
是吧

16:41.060 --> 16:42.060
那就是

16:42.060 --> 16:43.060
beginin

16:43.060 --> 16:44.060
push

16:45.060 --> 16:46.060
谁

16:46.060 --> 16:47.060
他用按的

16:47.060 --> 16:48.060
是吧

16:52.070 --> 16:53.070
下一种情况

16:53.070 --> 16:54.070
ios efo

16:56.960 --> 16:58.960
beginin等于空

16:58.960 --> 17:00.960
beginin没有部落

17:00.960 --> 17:02.960
and in不等于空

17:03.960 --> 17:04.960
and in不落

17:05.960 --> 17:06.960
是吧

17:06.960 --> 17:08.960
那就往and里面填

17:09.960 --> 17:10.960
对吧

17:12.960 --> 17:13.960
那就是and in

17:13.960 --> 17:14.960
的push

17:15.960 --> 17:16.960
beginin

17:17.960 --> 17:19.960
tambin

17:21.960 --> 17:22.960
tambin

17:22.960 --> 17:23.960
是吧

17:23.960 --> 17:25.960
最后一种

17:25.960 --> 17:26.960
begin在a部落

17:26.960 --> 17:28.960
and in在b部落

17:30.960 --> 17:31.960
这种情况下

17:32.960 --> 17:33.960
ios efo

17:34.960 --> 17:35.960
这是什么

17:35.960 --> 17:37.960
beginin不等于空

17:38.960 --> 17:40.960
且and in

17:40.960 --> 17:41.960
不等于空

17:41.960 --> 17:42.960
并且

17:43.960 --> 17:45.960
beginin不等于

17:45.960 --> 17:46.960
不等于

17:46.960 --> 17:47.960
and in

17:51.360 --> 17:52.360
这代表什么

17:52.360 --> 17:54.360
来自于两个不同的部落

17:54.360 --> 17:55.360
是吧

17:55.360 --> 17:56.360
那我们怎么样

17:56.360 --> 17:57.360
将两个部落

17:57.360 --> 17:58.360
给它连接在一起

17:59.360 --> 18:00.360
对吧

18:00.360 --> 18:01.360
来自于两个部落

18:01.360 --> 18:02.360
将两个部落

18:02.360 --> 18:03.360
连接在一起

18:03.360 --> 18:04.360
假如我们用begin

18:04.360 --> 18:06.360
去连接

18:07.360 --> 18:08.360
and in

18:08.360 --> 18:10.360
给它们连接在一起

18:10.360 --> 18:11.360
但是我begin

18:11.360 --> 18:12.360
把and in给吞了之后

18:12.360 --> 18:13.360
我是不是得把

18:13.360 --> 18:14.360
这个and in

18:14.360 --> 18:15.360
从这个

18:15.360 --> 18:17.360
list里面删除

18:17.360 --> 18:18.360
对吧

18:18.360 --> 18:19.360
我们是不是得

18:19.360 --> 18:20.360
从这个list里删除

18:20.360 --> 18:24.530
删除的话用哪个

18:24.530 --> 18:26.530
删除的话用哪个

18:26.530 --> 18:27.530
比如说

18:27.530 --> 18:28.530
我这块有一个

18:28.530 --> 18:30.530
数组

18:30.530 --> 18:32.530
1 2 3 4

18:34.530 --> 18:35.530
点

18:36.530 --> 18:37.530
splace

18:38.530 --> 18:40.530
我说删除3

18:41.530 --> 18:44.030
行吗

18:45.030 --> 18:46.030
不行吧

18:46.030 --> 18:47.030
比如说我删除

18:48.030 --> 18:49.030
1

18:49.030 --> 18:50.030
21

18:51.030 --> 18:54.180
这啥意思

18:54.180 --> 18:55.180
splace

18:57.180 --> 18:58.180
是不是也是结取

18:59.180 --> 19:00.180
我是结取的这一块

19:00.180 --> 19:01.180
但是它不是删除

19:01.180 --> 19:02.180
是吧

19:02.180 --> 19:03.180
我们有什么可以

19:03.180 --> 19:04.180
删除的操作

19:05.180 --> 19:07.680
没有remove是吧

19:08.680 --> 19:09.680
我看我摆渡一下

19:10.680 --> 19:11.680
有没有直接能删除的

19:12.680 --> 19:13.680
怎么感觉应该有的

19:14.680 --> 19:15.680
GS

19:16.680 --> 19:17.680
数组删除

19:18.680 --> 19:19.680
某个元素

19:20.680 --> 19:25.550
实在不行的话

19:25.550 --> 19:27.550
我们可以先引代个

19:27.550 --> 19:28.550
然后再删除是吧

19:29.550 --> 19:31.550
好像没有直接

19:31.550 --> 19:32.550
这么删的方法是吧

19:37.810 --> 19:39.810
删除70下标为1的

19:39.810 --> 19:40.810
splace

19:41.810 --> 19:43.810
这么玩没有意思

19:43.810 --> 19:44.810
看看

19:44.810 --> 19:48.910
有一个数组

19:49.910 --> 19:54.180
1 2 3 4

19:54.180 --> 19:56.620
点

19:56.620 --> 19:57.620
splace

19:58.620 --> 19:59.620
1

20:00.620 --> 20:06.430
这是删除1

20:07.430 --> 20:08.430
这是删除前两个是吧

20:11.430 --> 20:14.740
如果删除4个的话

20:14.740 --> 20:15.740
就全都没了

20:15.740 --> 20:16.740
我看到

20:17.740 --> 20:18.740
删除Count

20:19.740 --> 20:20.740
删除Count

20:20.740 --> 20:25.270
这是结取

20:27.270 --> 20:29.270
味一个result

20:30.270 --> 20:36.300
等于这个

20:37.300 --> 20:39.300
然后result的splace

20:40.300 --> 20:41.300
结取掉

20:43.300 --> 20:44.300
第一位的之后

20:45.300 --> 20:46.300
然后看这个时候的result

20:47.300 --> 20:48.300
是不是就掉了这位

20:48.300 --> 20:50.300
所以说我要删除哪一个的话

20:50.300 --> 20:52.300
我就找到第几个的index

20:53.300 --> 20:54.300
我要是删除哪个的话

20:54.300 --> 20:55.300
我就找到第几个的index

20:56.300 --> 20:57.300
所以说我还是

20:57.300 --> 20:58.300
得先找到index

20:59.300 --> 21:00.300
没有直接的方法

21:01.300 --> 21:03.300
我得先找到index

21:03.300 --> 21:04.300
在哪呢

21:04.300 --> 21:06.610
这种情况是吧

21:09.610 --> 21:10.610
连接了之后

21:10.610 --> 21:11.610
我得先找index

21:12.610 --> 21:14.610
result list的index off

21:14.610 --> 21:15.610
按的1

21:16.610 --> 21:19.240
这个是

21:19.240 --> 21:21.240
need

21:21.240 --> 21:22.240
remove

21:23.240 --> 21:25.240
然后我再result list

21:26.240 --> 21:27.240
点

21:27.240 --> 21:28.240
splace

21:30.240 --> 21:31.240
need remove

21:31.240 --> 21:32.240
这个位置

21:32.240 --> 21:33.240
删除一个

21:35.620 --> 21:36.620
这样的话result list

21:37.620 --> 21:38.620
就删除了

21:39.620 --> 21:40.620
它这个splace

21:40.620 --> 21:41.620
结取了之后

21:41.620 --> 21:43.620
它剩下的东西是少

21:43.620 --> 21:44.620
它返回的是

21:44.620 --> 21:45.620
结取掉的那一个

21:45.620 --> 21:46.620
然后它剩下的

21:47.620 --> 21:48.620
这个元素

21:48.620 --> 21:49.620
它就会变少

21:49.620 --> 21:50.620
它会修改元素组

21:51.620 --> 21:52.620
这样的话就

21:52.620 --> 21:53.620
搞定了是吧

21:53.620 --> 21:54.620
连接上

21:55.620 --> 21:56.620
然后我们再把

21:56.620 --> 21:57.620
这两个点

21:57.620 --> 21:58.620
进行连接

21:58.620 --> 21:59.620
一个是

21:59.620 --> 22:00.620
time will begin

22:00.620 --> 22:01.620
the neighbor

22:02.620 --> 22:03.620
the aid

22:04.620 --> 22:05.620
time will end

22:06.620 --> 22:07.620
再一个是

22:07.620 --> 22:08.620
time will end

22:08.620 --> 22:09.620
the neighbor

22:09.620 --> 22:10.620
aid

22:10.620 --> 22:11.620
time will begin

22:12.620 --> 22:13.620
把这两个点

22:13.620 --> 22:14.620
进行连接

22:15.620 --> 22:16.620
这是link

22:16.620 --> 22:17.620
是吧

22:18.620 --> 22:19.620
多种情况下的

22:19.620 --> 22:20.620
一个连接

22:20.620 --> 22:21.620
这个整个算法

22:21.620 --> 22:22.620
就是close car

22:22.620 --> 22:23.620
算法

22:23.620 --> 22:24.620
这个close car

22:24.620 --> 22:25.620
算法

22:25.620 --> 22:26.620
它可以用加编法

22:26.620 --> 22:27.620
把我们所有的点

22:27.620 --> 22:28.620
都给搞定

22:28.620 --> 22:29.620
然后打印完了之后

22:30.620 --> 22:31.620
我来尝试着

22:31.620 --> 22:32.620
输出一下

22:32.620 --> 22:33.620
看看能不能运行

22:33.620 --> 22:34.620
看看搜索了点

22:34.620 --> 22:35.620
log

22:35.620 --> 22:36.620
谁

22:36.620 --> 22:37.620
point of sight

22:38.620 --> 22:44.000
看吧

22:44.000 --> 22:45.000
爆错是比较正常的

22:45.000 --> 22:46.000
是吧

22:47.000 --> 22:48.000
我们来看看点

22:48.000 --> 22:49.000
爆错了

22:49.000 --> 22:51.000
它的 neighbor aid

22:53.000 --> 22:54.000
the neighbor

22:54.000 --> 22:55.000
的铺是吧

22:56.000 --> 23:02.660
走

23:05.660 --> 23:06.660
result list

23:06.660 --> 23:08.660
的概册理论的籃子

23:08.660 --> 23:09.660
只存在一个部落

23:09.660 --> 23:10.660
这也好像是吧

23:11.660 --> 23:12.660
概册 is a function

23:13.660 --> 23:14.660
is not a function

23:15.660 --> 23:16.660
说

23:17.660 --> 23:18.660
result list

23:18.660 --> 23:19.660
不是概册

23:19.660 --> 23:20.660
我这个java

23:20.660 --> 23:21.660
有的时候写多了

23:21.660 --> 23:22.660
就有点写习惯了

23:23.660 --> 23:24.660
第零个

23:30.240 --> 23:31.240
是吧

23:31.240 --> 23:32.240
又跟普林母算法

23:32.240 --> 23:33.240
出现了几乎一样的问题

23:33.240 --> 23:34.240
是吧

23:34.240 --> 23:35.240
它开始在这块

23:35.240 --> 23:36.240
循环上了

23:36.240 --> 23:37.240
没完没了

23:37.240 --> 23:38.240
然后我们来看一下

23:39.240 --> 23:40.240
到底是什么东西

23:40.240 --> 23:41.240
来让它

23:41.240 --> 23:42.240
如此的疯狂

23:42.240 --> 23:43.240
是吧

23:43.240 --> 23:44.240
我们来试试

23:44.240 --> 23:45.240
看搜了点log

23:45.240 --> 23:46.240
我打印行的等号

23:46.240 --> 23:47.240
我看看这个循环

23:47.240 --> 23:48.240
它会执行多少次

23:49.240 --> 23:50.240
然后发现

23:50.240 --> 23:51.240
我的天啊

23:51.240 --> 23:52.240
它一直在这不停的循环

23:52.240 --> 23:53.240
是吧

23:54.240 --> 23:55.240
我看到它每一次

23:55.240 --> 23:57.240
这个result list

23:57.240 --> 23:58.240
会不会发生什么变化

24:02.090 --> 24:03.090
停吧

24:04.090 --> 24:06.090
我这个result list

24:06.090 --> 24:07.090
一般呀

24:07.090 --> 24:09.090
有点多是吧

24:09.090 --> 24:11.090
我打印行的等号

24:11.090 --> 24:12.090
给它隔开

24:12.090 --> 24:14.590
它们自己的愿

24:14.590 --> 24:15.590
它们

24:22.060 --> 24:23.060
不用得罢过

24:24.060 --> 24:26.060
大家一定要习惯于调错

24:26.060 --> 24:27.060
不要寄希望于

24:27.060 --> 24:28.060
你能写出来一个

24:28.060 --> 24:29.060
不可错的代码

24:29.060 --> 24:32.060
这种想法是很可笑的

24:32.060 --> 24:33.060
所以写代码

24:33.060 --> 24:35.060
这个错误是比较正常的

24:35.060 --> 24:37.060
所以我们要习惯于调错

24:37.060 --> 24:38.060
一个是node

24:38.060 --> 24:39.060
a和b相连

24:39.060 --> 24:41.060
再一个是node c和d相连

24:41.060 --> 24:42.060
是吧

24:45.270 --> 24:47.270
然后我发现

24:47.270 --> 24:49.270
ab相连来之后

24:49.270 --> 24:50.270
cd相连来之后

24:50.270 --> 24:51.270
下一条编是什么呢

24:51.270 --> 24:53.270
看看这个ppt

24:53.270 --> 24:54.270
ab相连来之后

24:54.270 --> 24:55.270
cd相连来之后

24:55.270 --> 24:56.270
我们下一条编是

24:56.270 --> 24:58.270
ab和cd进行相连

24:58.270 --> 24:59.270
对吧

24:59.270 --> 25:00.270
ab和cd进行相连

25:00.270 --> 25:02.270
然后把cd给删了

25:03.270 --> 25:04.270
但是我们最后的结果

25:04.270 --> 25:05.270
是

25:05.270 --> 25:06.270
cd确实给删了

25:06.270 --> 25:08.270
ab和cd没有相连

25:09.270 --> 25:10.270
是吧

25:10.270 --> 25:12.270
就是这种情况下

25:12.270 --> 25:13.270
这种情况

25:16.270 --> 25:19.270
并没有把他们进行连接

25:19.270 --> 25:21.270
但是却把他们给删了

25:22.270 --> 25:23.270
concuit

25:24.270 --> 25:25.270
不会进行连接吗

25:25.270 --> 25:26.270
难道

25:28.780 --> 25:31.780
beginin的concuit按的印

25:31.780 --> 25:32.780
他这个事后

25:32.780 --> 25:33.780
确实把按的印给删了

25:33.780 --> 25:34.780
但是

25:35.780 --> 25:36.780
没有进行相连

25:39.340 --> 25:40.340
concuit来之后

25:40.340 --> 25:41.340
是不是我得付给beginin

25:42.340 --> 25:47.790
走

25:47.790 --> 25:50.360
也不是是吧

25:51.360 --> 25:53.800
看看

25:53.800 --> 25:55.800
1234

25:57.800 --> 25:59.800
123的concuit

25:59.800 --> 26:03.620
456

26:04.620 --> 26:05.620
他会得出

26:05.620 --> 26:07.620
得这个的结果是吧

26:07.620 --> 26:17.020
他会在那呢

26:17.020 --> 26:18.020
在这呢是吧

26:18.020 --> 26:20.020
这个beginin是我最后

26:20.020 --> 26:22.020
要得到的这个结果是吧

26:23.020 --> 26:25.020
beginin concuit之后

26:25.020 --> 26:28.020
是我得出来的结果是beginin

26:28.020 --> 26:29.020
那我们这样

26:33.580 --> 26:36.580
needrebo等于

26:39.660 --> 26:40.660
我想想

26:40.660 --> 26:41.660
这样的话

26:41.660 --> 26:43.660
我们希望是把这个拼成的结果

26:43.660 --> 26:44.660
给它塞过去

26:44.660 --> 26:45.660
是吧

26:45.660 --> 26:46.660
希望我们把这个拼成的结果

26:46.660 --> 26:47.660
给塞过去

26:47.660 --> 26:48.660
那我们来一个这样的

26:48.660 --> 26:49.660
来一个

26:49.660 --> 26:51.660
味一个

26:52.660 --> 26:53.660
合并

26:54.660 --> 26:55.660
all in

26:57.660 --> 26:58.660
拿出来一个all in

26:58.660 --> 27:01.660
来得到这个拼装后的结果

27:01.660 --> 27:02.660
然后呢

27:02.660 --> 27:04.660
我们把这两个都给remove掉

27:05.660 --> 27:07.660
needremove等于

27:07.660 --> 27:09.660
result list的

27:09.660 --> 27:10.660
index of

27:11.660 --> 27:12.660
beginin

27:14.660 --> 27:17.660
然后result list的splice

27:20.360 --> 27:21.360
needremove

27:22.360 --> 27:23.360
删一个

27:24.360 --> 27:25.360
然后呢

27:25.360 --> 27:26.360
result list的push

27:28.360 --> 27:29.360
all in

27:31.860 --> 27:32.860
看一下这样

27:38.120 --> 27:39.120
这样的话就ok了

27:39.120 --> 27:40.120
结束了

27:40.120 --> 27:42.120
我们把这两个好像都给去掉

27:43.120 --> 27:44.120
让它答应

27:45.120 --> 27:46.120
是吧

27:46.120 --> 27:47.120
a有一个邻居

27:47.120 --> 27:48.120
b有两个

27:48.120 --> 27:49.120
c有一个

27:49.120 --> 27:50.120
d有三个

27:50.120 --> 27:51.120
e有一个

27:51.120 --> 27:52.120
是吧

27:52.120 --> 27:53.120
看一下我们的这个

27:54.120 --> 27:57.120
把它当它连上了之后

27:57.120 --> 27:58.120
这个也变成红的了

27:58.120 --> 27:59.120
这个也变成红的了

28:00.120 --> 28:02.120
d和e之间是连在一起的

28:03.120 --> 28:04.120
所以a有一个邻居

28:04.120 --> 28:05.120
b有两个

28:05.120 --> 28:06.120
b是一个a一个d

28:06.120 --> 28:07.120
对吧

28:07.120 --> 28:08.120
c呢

28:08.120 --> 28:09.120
c只有一个邻居

28:09.120 --> 28:10.120
一个d是吧

28:10.120 --> 28:11.120
d有三个邻居

28:11.120 --> 28:12.120
是吧

28:12.120 --> 28:13.120
b c e

28:13.120 --> 28:14.120
然后e有一个邻居

28:14.120 --> 28:15.120
d

28:16.120 --> 28:17.120
这个呢

28:17.120 --> 28:18.120
就是close card算法

28:18.120 --> 28:19.120
这就是close card算法

28:19.120 --> 28:20.120
所以总来说

28:20.120 --> 28:21.120
close card算法

28:21.120 --> 28:22.120
要比prime算法

28:22.120 --> 28:23.120
稍微复杂一点

28:24.120 --> 28:25.120
这个呢

28:25.120 --> 28:27.120
也是大家在学算法以来

28:27.120 --> 28:28.120
会遇到的一个

28:28.120 --> 28:29.120
暂时

28:29.120 --> 28:30.120
到现在为止

28:30.120 --> 28:31.120
遇到的最难的一个算法

28:31.120 --> 28:32.120
close card算法

28:33.120 --> 28:35.120
这个就是最小生成数的两种算法

28:35.120 --> 28:36.120
是吧

28:36.120 --> 28:37.120
一个prime算法

28:37.120 --> 28:38.120
一个close card算法

28:38.120 --> 28:39.120
非常的出名

28:39.120 --> 28:40.120
考的

28:40.120 --> 28:42.120
考编程题的时候比较少

28:42.120 --> 28:44.120
prime算法和close card算法

28:44.120 --> 28:46.120
在考编程题的时候比较少

28:46.120 --> 28:47.120
通常都是

28:48.120 --> 28:49.120
考的是天空题

28:49.120 --> 28:50.120
让你填上

28:51.120 --> 28:52.120
用加点法

28:52.120 --> 28:53.120
或者用加编法

28:53.120 --> 28:54.120
来写什么呢

28:54.120 --> 28:55.120
来写

28:56.120 --> 28:57.120
这个

28:57.120 --> 28:59.120
点的介入顺序

28:59.120 --> 29:00.120
比如说

29:00.120 --> 29:01.120
prime算法

29:01.120 --> 29:02.120
出时点是c

29:02.120 --> 29:03.120
然后问你

29:04.120 --> 29:06.120
其他的村庄是按照什么次序介入

29:07.120 --> 29:08.120
这是一个天空题

29:08.120 --> 29:09.120
是吧

29:09.120 --> 29:10.120
70点是c

29:10.120 --> 29:11.120
那就是5

29:11.120 --> 29:12.120
是吧

29:12.120 --> 29:13.120
这是d

29:13.120 --> 29:14.120
b

29:14.120 --> 29:15.120
a

29:15.120 --> 29:16.120
e

29:16.120 --> 29:17.120
是吧

29:17.120 --> 29:18.120
给你一个70点

29:18.120 --> 29:19.120
然后是问你其他的村庄

29:19.120 --> 29:20.120
是按照

29:20.120 --> 29:21.120
什么顺序介入的

29:21.120 --> 29:22.120
然后或者告诉你

29:22.120 --> 29:24.120
用close card算法

29:25.120 --> 29:26.120
分别

29:26.120 --> 29:28.120
按次序的先后

29:28.120 --> 29:30.120
分别连接来的条件

29:30.120 --> 29:31.120
那就是a

29:31.120 --> 29:32.120
b

29:32.120 --> 29:33.120
cd

29:33.120 --> 29:34.120
bd

29:34.120 --> 29:35.120
d

29:35.120 --> 29:36.120
是吧

29:36.120 --> 29:37.120
这样的4条件

29:37.120 --> 29:39.120
这种考法比较多

29:39.120 --> 29:40.120
这种考法比较多

29:41.120 --> 29:44.120
只要是考写代码的时候比较少

29:44.120 --> 29:45.120
纯写代码比较少

29:45.120 --> 29:46.120
当然

29:46.120 --> 29:47.120
我说的这是鄙视

29:47.120 --> 29:48.120
面试的话

29:48.120 --> 29:50.120
是都有可能会考到

29:50.120 --> 29:52.120
面试的话是都有可能不会考到

29:52.120 --> 29:53.120
好

29:53.120 --> 29:54.120
以上的部分

29:54.120 --> 29:55.120
就是最小双乘数

29:55.120 --> 29:56.120
普利姆算法

29:56.120 --> 29:57.120
和close card算法

