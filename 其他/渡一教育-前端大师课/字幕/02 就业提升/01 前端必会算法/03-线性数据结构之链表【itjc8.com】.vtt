WEBVTT

00:01.900 --> 00:03.900
Hello 大家好

00:03.900 --> 00:05.900
上一集我们说了数组

00:05.900 --> 00:07.900
是吧 意味着数据结构里的数组

00:07.900 --> 00:09.900
我们说数组的时候

00:09.900 --> 00:11.900
说了很多的数组的

00:11.900 --> 00:13.900
优缺点 是吧

00:13.900 --> 00:15.900
既然数组有这么多的缺点

00:15.900 --> 00:17.900
那我们还要用它吗

00:17.900 --> 00:19.900
其实也不一定 是吧

00:19.900 --> 00:21.900
肯定是分情况的

00:21.900 --> 00:23.900
有的时候我们就是为了查询

00:23.900 --> 00:25.900
所以就用数组

00:25.900 --> 00:27.900
有的时候为了方便

00:27.900 --> 00:29.900
是吧 因为数组的每一个

00:29.900 --> 00:31.900
变成圆里面都是内置的

00:31.900 --> 00:33.900
无论是前端也好

00:33.900 --> 00:35.900
还是C圆也好

00:35.900 --> 00:37.900
还是乍外也好 还是拍摄也好

00:37.900 --> 00:39.900
都内置了数组的数据结构

00:39.900 --> 00:41.900
那我们用起来

00:41.900 --> 00:43.900
可能用起来的时候比较方便

00:43.900 --> 00:45.900
但是有很多的时候

00:45.900 --> 00:47.900
我们要避免它的这些缺点

00:47.900 --> 00:49.900
有的时候我就是有1万个数

00:49.900 --> 00:51.900
有10万个数得存

00:51.900 --> 00:53.900
那怎么办

00:53.900 --> 00:55.900
我要存10万个数

00:55.900 --> 00:57.900
我创建一个长度为10万个数组

00:57.900 --> 00:59.900
一个极其消耗性能的东西

01:01.900 --> 01:03.900
这种时候我们就不能用数组了

01:03.900 --> 01:05.900
不能用数组了

01:05.900 --> 01:07.900
那怎么办

01:07.900 --> 01:09.900
现性数据结构

01:09.900 --> 01:11.900
以为数据结构被称为现性数据结构

01:11.900 --> 01:13.900
那数组明显的

01:13.900 --> 01:15.900
它就是个直线 是吧

01:15.900 --> 01:17.900
没人说线就只能是直线

01:17.900 --> 01:19.900
我们可不可以有个曲线

01:19.900 --> 01:21.900
你说你必须点连续的

01:21.900 --> 01:23.900
我弯一下行不行

01:23.900 --> 01:25.900
我挑一下行不行

01:25.900 --> 01:27.900
没有这么直的事情

01:27.900 --> 01:29.900
我们希望

01:29.900 --> 01:31.900
我们有一种数据结构

01:31.900 --> 01:33.900
虽然还是现性的

01:33.900 --> 01:35.900
但是它可以

01:35.900 --> 01:37.900
没有那么直男

01:37.900 --> 01:39.900
不要那么直

01:39.900 --> 01:41.900
遇到前面有障碍的时候

01:41.900 --> 01:43.900
我空间不连续的时候

01:43.900 --> 01:45.900
我可以跳过去

01:45.900 --> 01:47.900
我可以到下一个空间上去

01:47.900 --> 01:49.900
这种时候另一种数据结构

01:49.900 --> 01:51.900
就应援生了 就是练秒

01:51.900 --> 01:53.900
练秒它可以不是直的

01:53.900 --> 01:55.900
这个点如往下

01:55.900 --> 01:57.900
它也可以往下指

01:57.900 --> 01:59.900
我也不知道这个软件怎么可以让它旋转

01:59.900 --> 02:01.900
它可以往下指 是吧

02:08.750 --> 02:10.750
我们在使用练秒的时候

02:10.750 --> 02:12.750
练秒这种结构 练二式的结构

02:12.750 --> 02:14.750
像锁链是吧

02:14.750 --> 02:16.750
它不一定像是这种数组

02:16.750 --> 02:18.750
这样 数组可以形容

02:18.750 --> 02:20.750
就是个棍子

02:20.750 --> 02:22.750
你想弯不了一弯就舌了

02:22.750 --> 02:24.750
练秒它就是一个锁链

02:24.750 --> 02:26.750
怎么来回的曲折

02:26.750 --> 02:28.750
都无所谓

02:28.750 --> 02:30.750
它的上一环永远套着下一环

02:30.750 --> 02:32.750
它的上一环永远套着下一环

02:32.750 --> 02:34.750
练秒是你们以后

02:34.750 --> 02:36.750
非常常见的一种数据结构

02:36.750 --> 02:38.750
在初学的时候用不着

02:38.750 --> 02:40.750
有很多同学说我工作了用不着

02:40.750 --> 02:42.750
那是因为工作太烂了

02:42.750 --> 02:44.750
所以说这是一个以后

02:44.750 --> 02:46.750
非常常见的数据结构

02:46.750 --> 02:48.750
而且非常的基础

02:48.750 --> 02:50.750
它有非常多的特性

02:50.750 --> 02:52.750
咱们会将在之后

02:52.750 --> 02:54.750
练秒有什么样的一个

02:54.750 --> 02:56.750
特点的结构

02:56.750 --> 02:58.750
练秒有什么样的结构特点

02:58.750 --> 03:02.320
练秒咱们刚才在这边看到了

03:02.320 --> 03:04.320
是吧 一个指向下一个

03:04.320 --> 03:06.320
另一个指向下一个

03:06.320 --> 03:08.320
这个时候我不知道同学

03:08.320 --> 03:10.320
有没有动脑思考

03:10.320 --> 03:12.320
数据 这个小方格

03:12.320 --> 03:16.320
我写了一 二 三 四 五

03:16.320 --> 03:18.320
我们可以理解是用来存放数据的

03:18.320 --> 03:22.320
你说箭头是个什么鬼

03:22.320 --> 03:24.320
是吧 这个箭头是个什么鬼

03:26.320 --> 03:28.320
有没有想过这个问题

03:28.320 --> 03:30.320
这个方块是我们用来存放数据的

03:30.320 --> 03:32.320
那这个箭头是什么呢

03:32.320 --> 03:34.320
你方块我可以副一个a等于1

03:34.320 --> 03:36.320
这个呢副一个a b等于2

03:36.320 --> 03:38.320
那这个箭头怎么

03:38.320 --> 03:40.320
什么a等于2

03:40.320 --> 03:42.320
那不可能 是吧 那就变成复职了

03:42.320 --> 03:44.320
所以说练秒是我们

03:44.320 --> 03:46.320
真正要学习的第一个

03:46.320 --> 03:48.320
带有封装性质的数据结构

03:48.320 --> 03:50.320
带有封装性质的数据结构

03:50.320 --> 03:52.320
我们一般怎么写

03:52.320 --> 03:54.320
我们一般怎么样生明这个练秒

03:54.320 --> 03:56.320
看好了

03:56.320 --> 03:58.320
我有一个小方块

03:58.320 --> 04:00.320
这个小方块是一种数据结构

04:00.320 --> 04:02.320
是一个数据的结构

04:02.320 --> 04:06.320
我看看怎么能给它弄个小变块

04:06.320 --> 04:08.320
箭条

04:08.320 --> 04:10.320
这是一个数据结构

04:10.320 --> 04:12.320
这个数据结构它其实是有两个部分的

04:12.320 --> 04:14.320
有两个部分的

04:14.320 --> 04:16.320
其中的一个部分

04:16.320 --> 04:18.320
用来存数据

04:18.320 --> 04:20.320
其中的一个部分

04:20.320 --> 04:22.320
用来存数据

04:22.320 --> 04:24.320
还有另外一个部分

04:24.320 --> 04:26.320
用来存引用

04:26.320 --> 04:31.810
这个引用是啥意思

04:31.810 --> 04:33.810
引用就是下一个

04:33.810 --> 04:37.810
这个块的手地指

04:37.810 --> 04:42.210
啥叫引用

04:42.210 --> 04:44.210
比如说这个东西我命名为a

04:44.210 --> 04:49.630
比如说这个对象

04:49.630 --> 04:51.630
我命名为a

04:51.630 --> 04:53.630
然后后面这个对象

04:53.630 --> 04:55.630
我命名为b

04:56.630 --> 04:59.630
引用这块存的就是b

04:59.630 --> 05:01.630
是吧

05:01.630 --> 05:03.630
我通过a可以找到b是吧

05:03.630 --> 05:05.630
a里面是不是包含b

05:05.630 --> 05:07.630
有b的引用

05:07.630 --> 05:09.630
大家记住了

05:09.630 --> 05:11.630
我们之前都管这块叫啥

05:11.630 --> 05:13.630
是个属性是吧

05:13.630 --> 05:15.630
指为e引用为b

05:15.630 --> 05:17.630
它指为2可能引用为c

05:17.630 --> 05:19.630
是吧

05:19.630 --> 05:21.630
我们认为b是a的一个属性

05:21.630 --> 05:23.630
但是实际上不是

05:23.630 --> 05:27.630
a里面只是存的b的一个引用

05:27.630 --> 05:29.630
在c原里面叫指针

05:29.630 --> 05:31.630
在面向对象的原里面我问的叫引用

05:31.630 --> 05:33.630
引用就是它可以指向下一个对象

05:33.630 --> 05:35.630
但是下一个对象

05:35.630 --> 05:37.630
并没有存在a的里面

05:37.630 --> 05:39.630
这个对象并不是存在a的里面

05:39.630 --> 05:41.630
这个对象是存在一个很遥远的地方

05:41.630 --> 05:43.630
存在外面

05:43.630 --> 05:47.630
只不过a里面有一个属性指向

05:47.630 --> 05:51.630
大家必须要变息这个概念

05:51.630 --> 05:55.630
我们用代码来写一下

05:55.630 --> 05:59.580
我们用代码来写一下

06:01.580 --> 06:03.580
结回master

06:03.580 --> 06:05.580
03

06:05.580 --> 06:10.690
数据

06:10.690 --> 06:14.690
线性数据结构之链饼

06:14.690 --> 06:21.280
很多同学可能不是科班出身

06:21.280 --> 06:23.280
所以在学习在这个过程中

06:23.280 --> 06:27.280
有很多的东西学的不规范

06:27.280 --> 06:29.280
比如说我们举个例子

06:29.280 --> 06:31.280
问一个a

06:31.280 --> 06:33.280
等于

06:33.280 --> 06:35.280
这样

06:35.280 --> 06:37.280
y6为1

06:37.280 --> 06:39.280
然后

06:39.280 --> 06:41.280
next

06:41.280 --> 06:43.280
为b

06:43.280 --> 06:45.280
我再问一个b

06:45.280 --> 06:49.740
问一个b

06:49.740 --> 06:51.740
y6

06:51.740 --> 06:53.740
为2

06:53.740 --> 06:55.740
然后

06:55.740 --> 06:57.740
next

06:57.740 --> 06:59.740
next

06:59.740 --> 07:01.740
为空

07:01.740 --> 07:03.740
你说

07:03.740 --> 07:05.740
a为一个对象是吧

07:05.740 --> 07:07.740
a是一个对象是吧

07:07.740 --> 07:11.740
a是不是对象中有两个指

07:11.740 --> 07:13.740
有两个属性是吧

07:13.740 --> 07:15.740
一个是它的指

07:15.740 --> 07:17.740
另一个是它的下一个

07:17.740 --> 07:19.740
a的指为e

07:19.740 --> 07:21.740
a的下一个为b

07:21.740 --> 07:25.740
不是说b存在了a里

07:25.740 --> 07:27.740
在空间上不是说a是

07:27.740 --> 07:29.740
b是a的一部分

07:29.740 --> 07:31.740
不是这样的

07:31.740 --> 07:33.740
不是不是说b是a的一部分

07:33.740 --> 07:37.740
不是说a的某一个属性的指为b

07:37.740 --> 07:39.740
b就是a的一个部分了

07:39.740 --> 07:41.740
千万不要这么想

07:41.740 --> 07:43.740
这是一个非常错误的想法

07:43.740 --> 07:45.740
他们不是浅套关系

07:45.740 --> 07:49.500
他们是引用关系

07:49.500 --> 07:51.500
a里面有一个属性的指为b

07:51.500 --> 07:53.500
是指的是a的属性指向了b

07:53.500 --> 07:55.500
不是说b存在了a的里面

07:55.500 --> 07:59.500
不是b存在了a的里面

07:59.500 --> 08:03.500
所以说b就相当于是箭头

08:03.500 --> 08:05.500
它指向了b

08:05.500 --> 08:10.160
它指向了b

08:10.160 --> 08:14.160
所以我们在使用a.next的时候

08:14.160 --> 08:16.160
实际上是和b是相等的

08:16.160 --> 08:18.160
对吧

08:18.160 --> 08:20.160
a.next的时候是不是等于b

08:20.160 --> 08:26.240
solo.log

08:26.240 --> 08:28.240
a.next的我们看它是不是等于b

08:28.240 --> 08:30.240
两个对象进行比较

08:30.240 --> 08:32.240
比较的是什么

08:32.240 --> 08:34.240
对象是地址

08:34.240 --> 08:36.240
a.next的就是b

08:36.240 --> 08:38.240
对吧

08:38.240 --> 08:40.240
它俩是同一个东西

08:40.240 --> 08:42.240
所以说这个next存的是b的地址

08:42.240 --> 08:44.240
我们可以说存的是b的地址

08:44.240 --> 08:46.240
它作为一个b的引用

08:46.240 --> 08:48.240
存的是b的地址

08:48.240 --> 08:50.240
以这样的情况

08:50.240 --> 08:54.240
来把内容传进下去

08:54.240 --> 08:56.240
他们可以不是连续的

08:56.240 --> 08:58.240
是吧

08:58.240 --> 09:02.450
我这会假如再来一个c

09:02.450 --> 09:04.450
明显我可以让它转弯的

09:04.450 --> 09:06.450
是吧

09:06.450 --> 09:08.450
我也不知道怎么让它这个转

09:08.450 --> 09:13.360
存单的

09:13.360 --> 09:19.230
有个循转角度之类的

09:19.230 --> 09:21.230
大概这样的

09:21.230 --> 09:23.230
对吧

09:23.230 --> 09:25.230
你可以发现abc在空间上

09:25.230 --> 09:27.230
不用连续是吧

09:27.230 --> 09:29.230
a和b中间也可以跳着别的东西

09:29.230 --> 09:31.230
隔着别的东西

09:31.230 --> 09:33.230
对吧

09:33.230 --> 09:35.230
在b之间隔着其他的东西

09:35.230 --> 09:37.230
我们依然可以指向

09:37.230 --> 09:39.230
对吧

09:39.230 --> 09:41.230
可以依然可以指向

09:41.230 --> 09:43.230
所以这就是链表的一个优点

09:43.230 --> 09:45.230
对吧

09:45.230 --> 09:47.230
链表的优点

09:47.230 --> 09:50.800
什么时候链表的优缺点

09:50.800 --> 09:52.800
链表的特性

09:52.800 --> 09:59.890
先说链表的特性

09:59.890 --> 10:01.890
链表的特点1

10:01.890 --> 10:03.890
在空间上

10:03.890 --> 10:05.890
不是连续的

10:05.890 --> 10:07.890
对吧

10:07.890 --> 10:09.890
链表在空间上不是连续的

10:09.890 --> 10:11.890
这个节点之间是跳跃的

10:13.890 --> 10:15.890
2

10:15.890 --> 10:19.260
是什么

10:19.260 --> 10:21.260
每存放

10:21.260 --> 10:23.260
一个值

10:23.260 --> 10:25.260
都要

10:25.260 --> 10:27.260
多开销

10:27.260 --> 10:29.260
一个

10:29.260 --> 10:31.260
引用空间

10:31.260 --> 10:33.260
你说我本来存一个数字1

10:33.260 --> 10:35.260
我存一个数字就ok了

10:35.260 --> 10:37.260
我现在还得再多存一个引用

10:37.260 --> 10:39.260
每多一个东西

10:39.260 --> 10:41.260
它就是多一份空间的开销

10:41.260 --> 10:43.260
所以说在空间上是有点浪费的

10:45.260 --> 10:47.260
我们回过头来看链表的优点

10:49.260 --> 10:51.260
优点

10:51.260 --> 10:53.260
只要

10:53.260 --> 10:55.260
内存足够大

10:55.260 --> 10:57.260
就能存得下

10:57.260 --> 10:59.260
是吧

10:59.260 --> 11:01.260
不用担心

11:01.260 --> 11:03.260
空间碎片的问题

11:03.260 --> 11:05.260
只要内存足够大

11:05.260 --> 11:07.260
它就能放得下

11:07.260 --> 11:09.260
不用担心

11:09.260 --> 11:16.480
空间碎片的问题

11:16.480 --> 11:18.480
放在这吧

11:18.480 --> 11:20.480
不用担心空间碎片的问题

11:20.480 --> 11:22.480
是不是解决了

11:22.480 --> 11:24.480
数组的缺点1

11:24.480 --> 11:26.480
是不是

11:26.480 --> 11:28.480
数组是不是担心空间碎片

11:28.480 --> 11:30.480
它是不是不担心空间碎片

11:30.480 --> 11:32.480
对吧

11:32.480 --> 11:34.480
数组是担心空间碎片的

11:34.480 --> 11:36.480
它是不担心空间碎片的

11:36.480 --> 11:38.480
第二个

11:38.480 --> 11:40.480
涉及到链表

11:40.480 --> 11:42.480
添加和删除

11:42.480 --> 11:44.480
涉及到链表

11:44.480 --> 11:46.480
你说链表怎么添加和删除呢

11:46.480 --> 11:48.480
再复制一下

11:48.480 --> 11:50.480
拿出来一份

11:50.480 --> 11:55.010
我们单读书

11:55.010 --> 12:01.710
没删掉了

12:01.710 --> 12:05.730
把C删掉了

12:05.730 --> 12:07.730
比如说在3和4之间

12:07.730 --> 12:09.730
太高了

12:09.730 --> 12:11.730
3和4之间我想插入一个6

12:11.730 --> 12:15.550
我想在这个之间

12:15.550 --> 12:17.550
插入一个6

12:17.550 --> 12:19.550
这个东西存储

12:19.550 --> 12:21.550
不一定非得按照数据的大小存储

12:21.550 --> 12:23.550
它是随机的

12:23.550 --> 12:25.550
以后你们存的都是自负创

12:25.550 --> 12:27.550
没有什么顺序的

12:27.550 --> 12:29.550
3和4之间我想插入一个6

12:29.550 --> 12:31.550
我得怎么办

12:31.550 --> 12:33.550
在数组里面

12:33.550 --> 12:35.550
我想添加一个新的东西

12:35.550 --> 12:37.550
你得扩容了

12:37.550 --> 12:39.550
但是在链表里不用

12:39.550 --> 12:41.550
链表里怎么搞

12:41.550 --> 12:43.550
6你得有个箭头

12:43.550 --> 12:45.550
我想在3和4之间

12:45.550 --> 12:47.550
插入一个6

12:47.550 --> 12:49.550
我的下加就指向4就行了

12:49.550 --> 12:51.550
这样是吧

12:51.550 --> 12:53.550
然后让3指向6

12:53.550 --> 12:58.660
就可以了

12:58.660 --> 13:00.660
这样它还是个链表

13:00.660 --> 13:02.660
是吧链是吗

13:02.660 --> 13:04.660
没说链必须得是直的

13:04.660 --> 13:06.660
现在是1指向2

13:06.660 --> 13:08.660
2指向3

13:08.660 --> 13:10.660
我们只需要

13:10.660 --> 13:12.660
你说你想存一个6

13:12.660 --> 13:14.660
你创建个对象是必须的

13:14.660 --> 13:16.660
你让6指向4

13:16.660 --> 13:18.660
改变一下引用

13:18.660 --> 13:20.660
3指向6也就改变一下引用

13:20.660 --> 13:22.660
其实就是改变了两下引用

13:22.660 --> 13:24.660
跟数组相比

13:24.660 --> 13:26.660
你数组得先扩容

13:26.660 --> 13:28.660
简然代价要小很多

13:28.660 --> 13:30.660
我们说

13:30.660 --> 13:32.660
删除一个数怎么办

13:32.660 --> 13:34.660
比如说现在用完了之后

13:34.660 --> 13:36.660
我要把6给删了怎么办

13:36.660 --> 13:38.660
我们要让3和4之间

13:38.660 --> 13:40.660
没有6怎么办

13:40.660 --> 13:42.660
直接就让3不指向6了

13:42.660 --> 13:44.660
3直接指向4就行了

13:44.660 --> 13:46.660
完事

13:46.660 --> 13:48.660
看什么有的人在6没删除

13:48.660 --> 13:50.660
你看

13:50.660 --> 13:52.660
传递链表

13:52.660 --> 13:54.660
比如说我想把链表给你

13:54.660 --> 13:56.660
我得给你什么节点

13:56.660 --> 13:58.660
必须得给的是链表的根基点

13:58.660 --> 14:00.660
对吧

14:00.660 --> 14:02.660
这是一个点

14:02.660 --> 14:04.660
大家必须得记住

14:04.660 --> 14:10.400
我想传递一个链表

14:10.400 --> 14:12.400
链表

14:12.400 --> 14:14.400
我必须

14:14.400 --> 14:16.400
传递

14:16.400 --> 14:18.400
链表的根结点

14:18.400 --> 14:22.420
看好了

14:22.420 --> 14:24.420
链表的特点是什么呢

14:24.420 --> 14:26.420
我们现在所有研究的链表

14:26.420 --> 14:28.420
我们都称为单链表

14:28.420 --> 14:32.620
单链表

14:32.620 --> 14:34.620
我们一说链表

14:34.620 --> 14:36.620
不认就是单链表

14:36.620 --> 14:38.620
有的同学开始台干

14:38.620 --> 14:40.620
说双链表

14:40.620 --> 14:42.620
什么双链表

14:42.620 --> 14:44.620
只要不提双链表的事

14:44.620 --> 14:46.620
我们都不提双链表

14:46.620 --> 14:48.620
我们都用的是双链表

14:48.620 --> 14:50.620
因为双链表的所有的东西

14:50.620 --> 14:52.620
都可以用单链表实现

14:52.620 --> 14:54.620
双链表还有两个引用

14:54.620 --> 14:56.620
极度浪费空间

14:56.620 --> 14:58.620
所以双链表不是一个好东西

14:58.620 --> 15:00.620
我们所有说的链表都指的是单链表

15:00.620 --> 15:02.620
之后我们会说什么是双链表

15:02.620 --> 15:04.620
就介绍一下概念

15:04.620 --> 15:06.620
因为我们根本就不会去用双链表

15:06.620 --> 15:08.620
很少用

15:08.620 --> 15:10.620
双链表所有的东西都可以用单链表实现

15:10.620 --> 15:12.620
所以说我当想把我这个链表

15:12.620 --> 15:14.620
传递给别人的时候

15:14.620 --> 15:16.620
我有一串数

15:16.620 --> 15:18.620
我把这个数传给你的时候

15:18.620 --> 15:20.620
我必须得传递的是根结点

15:20.620 --> 15:22.620
你比如说我把你传给2

15:22.620 --> 15:24.620
那你想找到1

15:24.620 --> 15:26.620
你根本就找不到

15:26.620 --> 15:28.620
因为没有任何箭头指向1

15:28.620 --> 15:30.620
对吧

15:30.620 --> 15:32.620
我给你传的东西不全

15:32.620 --> 15:34.620
我给你传的东西是23456

15:34.620 --> 15:36.620
明明我链表是123456

15:36.620 --> 15:38.620
因为没有任何箭头指向1了

15:38.620 --> 15:40.620
20是指向3

15:40.620 --> 15:42.620
30是指向4

15:42.620 --> 15:44.620
所以说

15:44.620 --> 15:46.620
我想传递一个链表的时候

15:46.620 --> 15:48.620
必须传递的是根结点

15:48.620 --> 15:50.620
然后每一个结点

15:50.620 --> 15:52.620
记住这个特性

15:52.620 --> 15:53.620
非常的关键

15:53.620 --> 15:54.620
这是我总结起来的

15:54.620 --> 15:56.620
而且各个数里面都不怎么说的

15:56.620 --> 16:00.450
每一个结点

16:00.450 --> 16:02.450
都认为

16:02.450 --> 16:04.450
自己是

16:04.450 --> 16:06.450
根结点

16:06.450 --> 16:08.450
每一个结点

16:08.450 --> 16:10.450
都认为自己是根结点

16:10.450 --> 16:12.450
这句话

16:12.450 --> 16:14.450
我也得背下来

16:14.450 --> 16:16.450
之后所有的设计到算法

16:16.450 --> 16:18.450
设计到链表

16:18.450 --> 16:20.450
设计到二刹数相关的比较有难度的地方

16:20.450 --> 16:22.450
都是可以用这个理论

16:22.450 --> 16:24.450
去解决掉的

16:24.450 --> 16:26.450
每一个结点都认为自己是根结点

16:26.450 --> 16:28.450
为啥呀

16:28.450 --> 16:30.450
废话你比如说2

16:30.450 --> 16:32.450
2是不是认为自己是根结点

16:32.450 --> 16:34.450
如果你觉得他不是根结点

16:34.450 --> 16:36.450
这个结点他得知道

16:36.450 --> 16:38.450
他得有上架是吧

16:38.450 --> 16:40.450
但是他没有上架的任何的记录

16:40.450 --> 16:42.450
他只记录自己和自己的后边

16:42.450 --> 16:44.450
我们不记录自己的上边

16:44.450 --> 16:46.450
所以说每一个结点

16:46.450 --> 16:48.450
都会认为自己是根结点

16:48.450 --> 16:50.450
也就是说对于链表来说

16:50.450 --> 16:52.450
每一个结点

16:52.450 --> 16:54.450
都是一个链表的歧视

16:54.450 --> 16:56.450
每一个结点

16:56.450 --> 16:58.450
都是一个链表的歧视

16:58.450 --> 17:00.450
一定要记住这个概念

17:00.450 --> 17:02.450
如果不行的话

17:02.450 --> 17:04.450
重听几遍

17:04.450 --> 17:06.450
这个概念如果不过

17:06.450 --> 17:08.450
不要往后面学

17:08.450 --> 17:09.450
必须要理解

17:09.450 --> 17:11.450
每一个结点都认为自己是根结点

17:11.450 --> 17:13.450
每一个结点都是链表的歧视

17:13.450 --> 17:15.450
这个概念

17:15.450 --> 17:17.450
如果不理解清楚

17:17.450 --> 17:19.450
千万不要往后学

17:19.450 --> 17:21.450
把他理解清楚了之后

17:21.450 --> 17:23.450
再往后学

17:23.450 --> 17:25.450
因为每一个结点都只知道自己指向谁

17:25.450 --> 17:27.450
不知道谁指向了自己

17:27.450 --> 17:29.450
所以谁都认为自己是起点

17:29.450 --> 17:31.450
谁都认为自己是起点

17:31.450 --> 17:33.450
所以说

17:33.450 --> 17:35.450
当我们要把一个链表中的

17:35.450 --> 17:37.450
某一个结点删掉的时候

17:37.450 --> 17:39.450
我们只需要让他在上一家

17:39.450 --> 17:41.450
指向他在下一家就可以

17:41.450 --> 17:43.450
6的上一家是3

17:43.450 --> 17:45.450
6的下一家是14

17:45.450 --> 17:47.450
所以当我们想把6删掉的时候

17:47.450 --> 17:49.450
只需要让从3指向6的

17:49.450 --> 17:51.450
改到3指向4就可以

17:51.450 --> 17:53.450
这样的话

17:53.450 --> 17:55.450
1 2 3 4

17:55.450 --> 17:57.450
就没有人再会走到6了

17:57.450 --> 17:59.450
按照链表的正常的逻辑来说

17:59.450 --> 18:01.450
就没有任何东西走向6了

18:01.450 --> 18:03.450
有同学就非得抬高

18:03.450 --> 18:05.450
我通过6也可以走到4

18:05.450 --> 18:07.450
看废话

18:07.450 --> 18:09.450
你随便生命一个变量

18:09.450 --> 18:11.450
你也可以指向链表

18:11.450 --> 18:13.450
都能捡到每一个元素

18:13.450 --> 18:15.450
没有意义

18:15.450 --> 18:17.450
当我们传递链表的时候

18:17.450 --> 18:19.450
就是按照券去走的

18:19.450 --> 18:21.450
你不可能

18:21.450 --> 18:23.450
当我传递1的时候你不可能在指向6

18:23.450 --> 18:25.450
传递2的时候你也不可能只在指向4了

18:25.450 --> 18:27.450
链表

18:27.450 --> 18:29.450
6客观存在

18:29.450 --> 18:31.450
但与链表无关

18:31.450 --> 18:33.450
我们是允许这种客观存在的

18:33.450 --> 18:35.450
如果正常有1 2 3 4 5

18:35.450 --> 18:37.450
忽然我就想生命一个变量A

18:37.450 --> 18:39.450
指向4

18:39.450 --> 18:41.450
你还能不让我A指向4

18:41.450 --> 18:43.450
我就觉得

18:43.450 --> 18:45.450
4这几点特殊我单独用个A指向

18:45.450 --> 18:47.450
行不行

18:47.450 --> 18:49.450
就可以这么理解

18:49.450 --> 18:51.450
我就有个6指向的

18:51.450 --> 18:53.450
没有任何问题

18:53.450 --> 18:55.450
链表之外

18:55.450 --> 18:57.450
就像你用个数组

18:57.450 --> 18:59.450
我也可以问一个A等于A3

18:59.450 --> 19:01.450
就像你刚才

19:01.450 --> 19:03.450
你觉得这个数组比较厉害

19:03.450 --> 19:08.680
比较特殊

19:08.680 --> 19:10.680
我看到了

19:10.680 --> 19:12.680
我先把这个保存一下

19:12.680 --> 19:21.750
先把这个保存提交一下

19:21.750 --> 19:28.780
它好像有点慢

19:28.780 --> 19:33.820
稍等一下

19:33.820 --> 19:35.820
我们可以用PPT来先来讲一下

19:35.820 --> 19:37.820
就比如说我们刚才有个数组

19:37.820 --> 19:39.820
你可以说有一个味一个

19:39.820 --> 19:41.820
啊

19:41.820 --> 19:43.820
数组

19:43.820 --> 19:45.820
咱哪儿写呢

19:45.820 --> 19:49.900
在这

19:49.900 --> 19:51.900
比如说味一个A

19:51.900 --> 19:53.900
等于

19:53.900 --> 19:55.900
1,2,3,4,5

19:57.900 --> 19:59.900
我就说这个2特殊

19:59.900 --> 20:01.900
我味一个B等于

20:01.900 --> 20:03.900
A

20:03.900 --> 20:05.900
行不行

20:05.900 --> 20:07.900
也行是吧

20:07.900 --> 20:09.900
你不能说多了一个B指向2

20:09.900 --> 20:11.900
它就不是数组了

20:11.900 --> 20:13.900
对吧,一个道理

20:13.900 --> 20:15.900
逻辑必须要辨明清楚

20:15.900 --> 20:17.900
你不能因为多了一个6指向4

20:17.900 --> 20:19.900
而它就不是一个链表了

20:19.900 --> 20:21.900
之前的链表里

20:21.900 --> 20:23.900
以1为首的链表里

20:23.900 --> 20:25.900
已经没有6了

20:25.900 --> 20:27.900
我们应该这样说

20:27.900 --> 20:29.900
以1为首的链表里

20:29.900 --> 20:31.900
已经没有6了

20:31.900 --> 20:33.900
我们允许其他的东西指向

20:33.900 --> 20:35.900
我们这里的每一个节点

20:35.900 --> 20:37.900
就像我们允许有其他的辨量

20:37.900 --> 20:39.900
指向我们数组中的每一个节点

20:39.900 --> 20:41.900
一样

20:41.900 --> 20:43.900
所以说

20:43.900 --> 20:45.900
我们的链表有第二个优点

20:45.900 --> 20:47.900
就是

20:47.900 --> 20:51.530
链表的

20:51.530 --> 20:53.530
添加

20:53.530 --> 20:55.530
和删除

20:55.530 --> 20:57.530
非常的

20:57.530 --> 20:59.530
容易

20:59.530 --> 21:01.530
非常的方便

21:01.530 --> 21:03.530
链表的添加和删除

21:03.530 --> 21:05.530
非常的方便是吧

21:05.530 --> 21:07.530
添加我就直接

21:07.530 --> 21:09.530
剩明一个对象

21:09.530 --> 21:11.530
只像下一个,上一个人只像我就ok了

21:11.530 --> 21:13.530
改变两个引用

21:13.530 --> 21:15.530
删除直接让我的上一家

21:15.530 --> 21:17.530
链表的添加和删除

21:17.530 --> 21:19.530
都非常的容易

21:19.530 --> 21:21.530
这是它的优点,它的缺点呢

21:21.530 --> 21:25.540
缺点它其实也有两个

21:25.540 --> 21:27.540
第一个

21:27.540 --> 21:31.620
查询速度慢是吧

21:31.620 --> 21:33.620
这个查询指的是

21:33.620 --> 21:35.620
查询

21:35.620 --> 21:37.620
某个位置

21:37.620 --> 21:39.620
比如说我要链表里

21:39.620 --> 21:41.620
我要查询第四个,怎么办

21:41.620 --> 21:43.620
第1个,第2个,第3个

21:43.620 --> 21:45.620
第4个,给您

21:45.620 --> 21:47.620
那怎么不能像

21:47.620 --> 21:49.620
数组是这些跳啊,因为它不是连续的

21:49.620 --> 21:51.620
它只能通过

21:51.620 --> 21:53.620
第1个的引用

21:53.620 --> 21:55.620
找到第2个,第2个的引用

21:55.620 --> 21:57.620
找到第3个,第3个的Nex

21:57.620 --> 21:59.620
找到第4个

21:59.620 --> 22:01.620
所以说

22:01.620 --> 22:03.620
链表的查询的速度

22:03.620 --> 22:05.620
它是要相对要慢一些的

22:05.620 --> 22:07.620
它的性能相对

22:07.620 --> 22:09.620
是要差一些的

22:09.620 --> 22:11.620
第2个

22:11.620 --> 22:13.620
链表

22:13.620 --> 22:15.620
每

22:15.620 --> 22:17.620
每一个

22:17.620 --> 22:19.620
节点

22:19.620 --> 22:21.620
都需要

22:21.620 --> 22:23.620
创建一个

22:23.620 --> 22:25.620
指向

22:25.620 --> 22:27.620
指向

22:27.620 --> 22:29.620
Nex

22:29.620 --> 22:31.620
的引用

22:31.620 --> 22:33.620
浪费一些空间

22:33.620 --> 22:38.150
我们的链表

22:38.150 --> 22:40.150
都需要创建一个Nex是吧

22:40.150 --> 22:42.150
本来你需要存一个数

22:42.150 --> 22:44.150
你现在

22:44.150 --> 22:46.150
得多存一个

22:46.150 --> 22:48.150
所以说它浪费一些空间

22:48.150 --> 22:50.150
单身的缺点

22:50.150 --> 22:52.150
也可以避免

22:52.150 --> 22:54.150
是吧

22:54.150 --> 22:56.150
避免什么呢

22:56.150 --> 22:58.150
怎么避免呢

22:58.150 --> 23:01.530
就是

23:01.530 --> 23:03.530
当节点内

23:03.530 --> 23:05.530
数据

23:05.530 --> 23:07.530
越多的时候

23:09.530 --> 23:11.530
这部分

23:11.530 --> 23:13.530
多开销的

23:13.530 --> 23:15.530
内存

23:15.530 --> 23:17.530
越小

23:17.530 --> 23:19.530
越少

23:19.530 --> 23:21.530
这是什么意思

23:21.530 --> 23:23.530
比如说我数据里面只存一个数

23:23.530 --> 23:25.530
你还得多开一个引用

23:25.530 --> 23:27.530
我内存就是翻一倍

23:27.530 --> 23:29.530
但是我的数据里面

23:29.530 --> 23:31.530
如果存10个数

23:31.530 --> 23:33.530
我多开一个应用

23:33.530 --> 23:35.530
我就相当于什么呢

23:35.530 --> 23:37.530
我也就多了10%

23:37.530 --> 23:39.530
我这里如果存100个数

23:39.530 --> 23:41.530
我这里多开一个应用

23:41.530 --> 23:43.530
就影响了1%

23:43.530 --> 23:45.530
你存的越多

23:45.530 --> 23:47.530
我们越适合于运用链表

23:47.530 --> 23:49.530
反正链表是个固定开销

23:49.530 --> 23:51.530
固定的得多创建一个应用

23:51.530 --> 23:53.530
我们存的数据越多

23:53.530 --> 23:55.530
它就占据的就越少

23:55.530 --> 23:57.530
就相当于什么呢

23:57.530 --> 23:59.530
打个比方就像你吃火锅

23:59.530 --> 24:01.530
火锅底料钱是固定的

24:01.530 --> 24:03.530
你去吃的人越多

24:03.530 --> 24:05.530
火锅底料钱

24:05.530 --> 24:07.530
相当于人群的越少

24:07.530 --> 24:09.530
那就越划算

24:09.530 --> 24:11.530
如果你只有一个人去

24:11.530 --> 24:13.530
你划了100

24:13.530 --> 24:15.530
比如说两个人去

24:15.530 --> 24:17.530
火锅底料还是70

24:17.530 --> 24:19.530
但是你一人吃30块钱

24:19.530 --> 24:21.530
相当于最后一共划13

24:21.530 --> 24:23.530
人群就15

24:23.530 --> 24:25.530
这样的话人群瞬间就下来了

24:25.530 --> 24:27.530
这个相当于这样

24:27.530 --> 24:29.530
它数组的开销是固定的

24:29.530 --> 24:31.530
所以你存放的数据越多

24:31.530 --> 24:33.530
它的影响相对于

24:33.530 --> 24:35.530
百分比来说就会越少

24:35.530 --> 24:37.530
所以说这个数据是可以解决的

24:37.530 --> 24:39.530
所以说我们当我们使用

24:39.530 --> 24:41.530
尽量要存的数据对象

24:41.530 --> 24:43.530
稍微大一点

24:43.530 --> 24:45.530
这样的话它的影响就会比较小

24:45.530 --> 24:47.530
说了半天

24:47.530 --> 24:49.530
练表的好处

24:49.530 --> 24:51.530
练表我该怎样创建的

24:51.530 --> 24:53.530
怎么还铺实费用

24:53.530 --> 24:55.530
待会再说

24:55.530 --> 24:57.530
练表该怎样创建的

24:57.530 --> 24:59.530
首先在创建练表的时候

24:59.530 --> 25:01.530
我们必须要定义

25:01.530 --> 25:03.530
练表的结构

25:03.530 --> 25:05.530
首先要定义要练表的结构

25:05.530 --> 25:07.530
我们通常每一个节点

25:07.530 --> 25:09.530
被称为一个node

25:09.530 --> 25:11.530
node就是个节点

25:11.530 --> 25:13.530
然后我们需要存入它的

25:13.530 --> 25:15.530
一个value

25:15.530 --> 25:17.530
然后让this的value

25:17.530 --> 25:19.530
等于value

25:19.530 --> 25:21.530
然后

25:21.530 --> 25:23.530
this的knives

25:23.530 --> 25:25.530
等于空

25:25.530 --> 25:28.900
这就是我们定义的一个节点

25:28.900 --> 25:30.900
是吧

25:30.900 --> 25:32.900
我们可以存入一个数

25:32.900 --> 25:34.900
它的value

25:34.900 --> 25:36.900
它的下一个我们默认为空

25:36.900 --> 25:38.900
下一个才行

25:38.900 --> 25:40.900
比如说

26:00.470 --> 26:02.470
但是有这四个了之后

26:02.470 --> 26:04.470
他们是练表吗

26:04.470 --> 26:06.470
他们不是练表

26:06.470 --> 26:08.470
他们就是四个独立的数

26:08.470 --> 26:10.470
他们的knives都会空

26:10.470 --> 26:12.470
这样的话我们怎么能把它变成练表

26:12.470 --> 26:14.470
a的knives等于b

26:14.470 --> 26:16.470
b的knives

26:16.470 --> 26:18.470
等于c

26:18.470 --> 26:20.470
c的knives

26:20.470 --> 26:22.470
等于d

26:22.470 --> 26:24.470
d的knives

26:24.470 --> 26:26.470
等于空

26:26.470 --> 26:28.470
这样的话我们就可以查到

26:28.470 --> 26:30.470
通过a

26:30.470 --> 26:32.470
能查到每一个了是吧

26:32.470 --> 26:34.470
比如说我想要练表的

26:34.470 --> 26:36.470
这四个元素那就是a的value是吧

26:36.470 --> 26:38.470
练表的第二个元素

26:38.470 --> 26:40.470
其实是b是吧

26:40.470 --> 26:42.470
我们可以是a的knives的value

26:42.470 --> 26:44.470
对吧

26:44.470 --> 26:46.470
第三个元素

26:46.470 --> 26:48.470
a的knives

26:48.470 --> 26:50.470
等于knives

26:50.470 --> 26:52.470
等于c

26:52.470 --> 26:54.470
第四个元素

26:54.470 --> 26:56.470
a的knives

26:56.470 --> 26:58.470
等于c

26:58.470 --> 27:00.470
等于c

27:00.470 --> 27:02.470
等于c

27:02.470 --> 27:04.470
我来看一下

27:04.470 --> 27:06.470
执行一下

27:06.470 --> 27:08.470
1234对吧

27:08.470 --> 27:10.470
这样的话

27:10.470 --> 27:12.470
我们就可以把这几个变量

27:12.470 --> 27:14.470
穿成一个串

27:14.470 --> 27:16.470
当然了

27:16.470 --> 27:18.470
如果现实生活中

27:18.470 --> 27:20.470
如果a的knives

27:20.470 --> 27:22.470
这么要来写的话

27:22.470 --> 27:24.470
简直能把人给逼疯是吧

27:24.470 --> 27:26.470
这种时候就是什么呢

27:26.470 --> 27:28.470
我们缺少一个算法

27:28.470 --> 27:30.470
来解决这些问题

27:30.470 --> 27:32.470
我们说了什么是

27:32.470 --> 27:34.470
线性数据结构的练表

27:34.470 --> 27:36.470
那下一节课

27:36.470 --> 27:38.470
我们来说一些算法

27:38.470 --> 27:40.470
通过这些算法来操作

27:40.470 --> 27:42.470
数组和练表

27:42.470 --> 27:44.470
那我们下一集来说

