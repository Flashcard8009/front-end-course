WEBVTT

00:00.880 --> 00:07.040
Hello 大家好 这一集开始 我们开始来奔向红黑树

00:07.040 --> 00:09.400
但是我们不是这一集来讲红黑树

00:09.400 --> 00:12.560
为什么 因为红黑树是一个非常复杂的概念

00:12.560 --> 00:16.480
如果你直接去看这些概念的话 你根本看不懂

00:16.480 --> 00:18.680
直接去看这个概念的话 你根本就看不懂

00:18.680 --> 00:22.360
比如说你可以去搜一下红黑树 百度是吧

00:22.360 --> 00:27.040
可以搜一下红黑树 红黑树

00:27.040 --> 00:29.480
你可以去看一下这些红黑树的概念

00:29.640 --> 00:32.080
你看了半天 最后你会得出来一个结论

00:32.080 --> 00:35.280
是什么 什么节点是黑色的 这个节点是红色的

00:35.280 --> 00:38.000
但是你根本就不知道红黑树有什么用

00:38.000 --> 00:40.000
这是为什么 而且这些东西

00:40.000 --> 00:43.040
我无论怎么直接跟你讲红黑树 你都不懂

00:43.040 --> 00:43.920
知道这是为什么吗

00:43.920 --> 00:48.160
这就是因为在红黑树之前有非常多的

00:48.160 --> 00:51.120
而且密集的知识点进行铺垫

00:51.120 --> 00:54.520
就是红黑树是推到推出来的

00:54.520 --> 00:58.120
而不是人们的一想设计出来

00:58.240 --> 01:00.680
如果我是这个东西是我设计出来的

01:00.680 --> 01:03.000
我把我的灵感告诉你 你就会了

01:03.000 --> 01:05.600
就像普丽姆斯兰克鲁斯卡尔特曼

01:05.600 --> 01:08.000
我把这个思路告诉你你就会了

01:08.000 --> 01:10.760
但是红黑树不是 红黑树不是灵感型的

01:10.760 --> 01:12.760
红黑树是推到型的

01:12.760 --> 01:14.320
它是有最开始的基础问题

01:14.320 --> 01:16.480
然后一部分的改进推到出来的

01:16.480 --> 01:18.840
所以这样的话我直接告诉你什么是红黑树

01:18.840 --> 01:19.840
你是不理解的

01:19.840 --> 01:22.280
因为你不知道它的演变过程

01:22.280 --> 01:27.880
这一节开始 我们就来聊聊红黑树的演变过程

01:27.880 --> 01:30.200
今天我们先提出第一个概念

01:30.200 --> 01:33.160
这个概念也是很厉害

01:33.160 --> 01:36.200
这个概念来自于一个问题

01:36.200 --> 01:37.400
什么问题呢?

01:39.000 --> 01:39.640
说

01:40.840 --> 01:41.480
问题

01:42.360 --> 01:44.120
问题

01:45.080 --> 01:46.360
有一万个数

01:49.350 --> 01:51.750
一万个数

01:53.270 --> 01:54.550
我们要写一个算法

01:54.550 --> 01:57.750
写一个方法

01:57.750 --> 01:59.030
进行查找

02:01.850 --> 02:03.290
写一个方法进行查找

02:03.290 --> 02:04.570
查找什么呢?

02:04.570 --> 02:05.530
查找

02:07.290 --> 02:08.170
查找

02:08.570 --> 02:09.530
给定的数

02:11.770 --> 02:13.770
返回存在

02:13.770 --> 02:15.530
还是不存在

02:17.450 --> 02:18.090
要求

02:20.570 --> 02:23.610
尽可能的性能好

02:26.440 --> 02:27.720
尽可能的性能好是吧

02:27.720 --> 02:28.520
有一万个数

02:28.520 --> 02:30.200
我要写一个方法进行查找

02:30.840 --> 02:31.960
查找一个给定的数

02:32.840 --> 02:35.080
然后返回这个数是存在还是不存在

02:36.520 --> 02:38.760
然后我们希望要尽可能的性能好

02:39.480 --> 02:40.200
这么一个问题

02:40.920 --> 02:42.600
之前代码我先提交一下

02:43.880 --> 02:45.320
你说这种问题的话怎么解

02:46.600 --> 02:47.960
是不是我们按照一个

02:47.960 --> 02:50.040
我们以往普通的一个写法

02:50.040 --> 02:50.920
就是暴力写

02:50.920 --> 02:51.560
是吧

02:52.120 --> 02:53.320
随即生成一万个数什么

02:53.320 --> 02:54.280
都给它扔数组里

02:54.840 --> 02:55.720
不管它是吧

02:55.720 --> 02:57.000
给它扔数组里

02:57.000 --> 02:58.040
然后我挨个招

02:59.000 --> 02:59.400
是吧

03:00.120 --> 03:02.120
我来创建一个新的

03:03.080 --> 03:03.720
一个分支

03:08.970 --> 03:09.530
37

03:11.050 --> 03:12.330
二查搜索数

03:22.360 --> 03:24.040
我们会一般的话怎么做呢

03:25.640 --> 03:25.960
这样

03:27.720 --> 03:29.160
为了一个数组是吧

03:29.160 --> 03:30.920
AR等于这个东西

03:31.480 --> 03:33.000
你不随即生成一万个数吗

03:33.000 --> 03:33.320
来吧

03:34.200 --> 03:34.680
冯雄

03:35.560 --> 03:36.680
为了一个i等于0

03:36.680 --> 03:38.680
i小于1万

03:39.880 --> 03:40.680
然后i加加

03:41.640 --> 03:42.520
生成数

03:42.520 --> 03:43.240
AR

03:44.440 --> 03:44.680
i

03:45.480 --> 03:46.520
等于谁呢

03:46.520 --> 03:48.440
假设说咱这一万个数都是整数

03:48.440 --> 03:49.640
i max的flow

03:50.520 --> 03:52.760
max的random成里

03:53.480 --> 03:53.880
10万

03:57.800 --> 03:58.200
好吧

03:58.680 --> 04:00.120
我随即生成一个数

04:00.120 --> 04:01.400
然后附到ARi里

04:02.040 --> 04:03.880
这是有1万个数是吧

04:03.880 --> 04:04.920
我该怎么寻找呢

04:07.000 --> 04:07.400
search

04:07.960 --> 04:08.680
传入一个AR

04:09.320 --> 04:10.360
传入一个target

04:11.880 --> 04:13.240
按照我们的习惯怎么找

04:18.250 --> 04:18.650
怎么找

04:20.010 --> 04:21.770
是不是从头到尾的便利

04:22.810 --> 04:23.690
i等于0

04:23.690 --> 04:26.490
然后i小于AR的lans

04:27.130 --> 04:27.770
i加加

04:29.450 --> 04:30.010
对吧

04:30.010 --> 04:30.970
然后如果

04:32.650 --> 04:33.130
efo

04:33.850 --> 04:34.650
ARi

04:37.610 --> 04:38.730
等于target

04:38.730 --> 04:40.490
我们就return to

04:41.610 --> 04:44.330
然后 else的话就进行循环

04:44.330 --> 04:45.210
到了最后

04:45.210 --> 04:47.210
return first

04:48.490 --> 04:50.010
你说这样的话性能好吗

04:52.970 --> 04:53.290
log

04:54.650 --> 04:55.130
search

04:56.010 --> 04:59.050
我问这个数组中存不存在1000这个数

05:02.500 --> 05:03.780
存不存在1000的这个数

05:04.500 --> 05:05.940
first不存在是吧

05:05.940 --> 05:06.980
再来一遍

05:06.980 --> 05:08.100
还是不存在

05:08.100 --> 05:09.380
再来一遍还是不存在

05:10.020 --> 05:11.540
再来一遍还是不存在

05:11.540 --> 05:12.820
再来一遍还是不存在

05:13.940 --> 05:16.260
看来它就一直都是不存在是吧

05:16.260 --> 05:17.780
因为我们根本就没有这些数是吧

05:18.740 --> 05:19.780
我打印一下

05:19.780 --> 05:20.740
打印一下这个数组

05:25.500 --> 05:27.340
看看这10000个数是不是真的有10000个数

05:29.420 --> 05:31.100
首先是真的有10000个数是吧

05:31.740 --> 05:32.940
都是随机生成的

05:32.940 --> 05:34.620
然后确实是不存在以前这个数

05:35.180 --> 05:36.300
然后咱们来看一下

05:36.860 --> 05:39.340
我判断了一个数存在

05:39.340 --> 05:41.900
还是不存在进行了多少次比较

05:45.240 --> 05:46.680
每进行一次比较

05:46.680 --> 05:48.200
我们都要进行那么加加

05:51.260 --> 05:52.460
那么加点意义

05:52.460 --> 05:55.020
然后咱们最后输出了一个数了之后

05:55.020 --> 05:56.140
我们再输出一下那么

05:56.780 --> 05:58.620
看一下不但要看一下存不存在

05:58.700 --> 06:00.140
还得看一下比较了多少次

06:02.140 --> 06:03.900
我这10000个数是进行了

06:03.900 --> 06:06.860
这个生成是不是有点变态了的

06:07.420 --> 06:09.980
处是吧比较了6792次

06:12.300 --> 06:14.460
处比较了2950次

06:16.540 --> 06:18.380
处比较了3444次

06:20.140 --> 06:22.700
还是处比较了5649次

06:22.700 --> 06:24.860
是吧这个得比较多少次

06:24.860 --> 06:27.260
得比较5649次

06:27.340 --> 06:29.820
我才能确定一个数是在里面

06:29.820 --> 06:30.700
还是不在里面

06:31.660 --> 06:34.460
如果你感觉这个东西的性能很烂的话

06:34.700 --> 06:36.220
只有两个方面可以提升

06:36.860 --> 06:39.340
一个是数据结构不对

06:39.740 --> 06:41.020
一个是算法不对

06:41.980 --> 06:43.660
你说我这算法还能有啥不对

06:43.660 --> 06:44.860
对就比呗对吧

06:44.860 --> 06:46.780
比招的就是比不着就不是

06:46.780 --> 06:47.740
算法人有啥不对的

06:47.740 --> 06:48.060
是吧

06:48.380 --> 06:50.700
所以问题出在那问题就是数据结构

06:51.980 --> 06:54.380
输足太烂了

06:54.940 --> 06:55.740
输足太烂了

06:56.220 --> 06:57.820
我们希望给它让它什么呢

06:58.780 --> 07:00.300
我们希望把它变成一个

07:00.300 --> 07:01.900
我们这堂课要讲的一个概念

07:01.900 --> 07:04.860
这个数叫做二叉搜索数

07:04.860 --> 07:06.460
也叫做二叉排序数

07:07.900 --> 07:10.860
我们来说一下二叉搜索数和二叉排序数的概念

07:16.020 --> 07:21.460
二叉搜索数也叫二叉排序数

07:23.620 --> 07:24.980
这个数厉害了

07:24.980 --> 07:26.340
它是有什么概念的

07:26.740 --> 07:27.540
它首先

07:28.420 --> 07:30.740
首先这是一颗二叉数

07:31.540 --> 07:32.260
这不废话吗

07:32.260 --> 07:32.420
是吧

07:32.420 --> 07:33.780
都二叉搜索数了

07:33.780 --> 07:34.660
它那是三叉嘛

07:34.660 --> 07:35.140
对吧

07:35.140 --> 07:37.620
首先它是二叉数

07:38.420 --> 07:38.820
其次

07:41.220 --> 07:43.540
有排序的效果

07:45.220 --> 07:46.580
什么叫排序的效果呢

07:49.140 --> 07:50.580
在左边的

07:50.580 --> 07:53.220
左子数的节点

07:54.180 --> 08:00.230
都比当前节点小

08:01.910 --> 08:05.510
右子数的节点都比

08:07.670 --> 08:09.510
当前节点大

08:11.270 --> 08:12.870
比如说咱们来一串数

08:12.870 --> 08:14.150
比如说来一串数

08:14.150 --> 08:15.190
随便先复制一个吧

08:20.490 --> 08:20.970
复制一个

08:24.820 --> 08:26.420
比如说复制一个数是三

08:27.380 --> 08:27.700
然后

08:49.580 --> 08:50.940
三五一六七二九八

08:50.940 --> 08:52.700
这是随便我随便弄的一个数组

08:53.500 --> 08:59.980
我要想把这些数变成一颗二叉搜索数

08:59.980 --> 09:00.380
怎么变

09:01.420 --> 09:03.660
跟大家说一个通用变法

09:04.540 --> 09:05.260
不管怎么样

09:05.260 --> 09:06.620
取第一个数做跟接点

09:08.940 --> 09:09.820
然后取第二个数

09:10.380 --> 09:11.660
看是比它大还是比它小

09:11.660 --> 09:12.700
比它小就放左边

09:12.700 --> 09:13.660
比它大就放右边

09:13.660 --> 09:14.780
五显然比它大是吧

09:14.780 --> 09:15.260
放在右边

09:16.540 --> 09:18.860
然后一比它小放左边

09:18.860 --> 09:20.380
比它大就放右边放在这

09:21.100 --> 09:21.340
六

09:21.980 --> 09:22.860
六比三大是吧

09:22.860 --> 09:23.740
应该在右边

09:23.740 --> 09:25.020
但是二叉数

09:25.020 --> 09:26.380
三只有一个右叉是吧

09:26.380 --> 09:27.340
那就得再跟五比

09:28.220 --> 09:29.020
六比五大

09:29.020 --> 09:29.900
六放在五的右边

09:29.900 --> 09:32.940
然后是七

09:33.500 --> 09:34.300
七跟三比

09:34.300 --> 09:35.340
七比三大

09:35.340 --> 09:36.060
七比五大

09:36.060 --> 09:36.940
七比六大

09:36.940 --> 09:37.740
它在放在右边

09:38.460 --> 09:38.940
看这个二

09:39.420 --> 09:40.620
二比三小

09:40.620 --> 09:41.820
但是二比一大

09:41.820 --> 09:42.460
它得放在这

09:43.340 --> 09:43.660
对吧

09:44.220 --> 09:45.020
然后看看九

09:45.020 --> 09:46.220
九比三大

09:46.220 --> 09:46.860
九比五大

09:46.860 --> 09:47.420
九比六大

09:47.420 --> 09:48.460
九比七大

09:48.460 --> 09:48.860
放在这

09:50.220 --> 09:51.020
然后最后

09:52.860 --> 09:53.420
这个八

09:54.140 --> 09:54.940
八比三大

09:54.940 --> 09:55.580
八比五大

09:55.580 --> 09:56.220
八比六大

09:56.220 --> 09:56.940
八比七大

09:57.900 --> 09:59.100
八比九小

09:59.100 --> 09:59.500
放在这

10:00.860 --> 10:02.060
变成了这样的一颗数

10:02.700 --> 10:04.780
这个就是二叉所数

10:05.420 --> 10:06.780
刚才我们想找一个数

10:06.780 --> 10:08.300
从头到尾得便利

10:08.300 --> 10:08.940
八个数

10:08.940 --> 10:09.500
是吧

10:09.500 --> 10:10.860
现在你看它有几个层

10:11.580 --> 10:12.060
一层

10:12.700 --> 10:13.260
两层

10:13.740 --> 10:14.620
三层

10:14.620 --> 10:15.340
四层

10:15.340 --> 10:16.060
五层

10:16.060 --> 10:16.460
六层

10:16.460 --> 10:16.700
是吧

10:16.700 --> 10:17.660
现在它就只有六层

10:18.220 --> 10:19.660
所以说它最多就只能

10:20.220 --> 10:21.260
便利六下就对

10:21.260 --> 10:22.380
就能得出来结果

10:22.380 --> 10:22.620
是吧

10:22.620 --> 10:23.420
要么比它大

10:23.420 --> 10:24.220
要么比它小

10:24.220 --> 10:25.420
这样就能得出结果

10:26.380 --> 10:27.900
这就是一颗二叉所数

10:28.860 --> 10:30.460
我们用二叉所数

10:30.460 --> 10:33.260
就一定能够比二叉数

10:33.260 --> 10:35.180
节省很多的资源

10:35.820 --> 10:37.260
我们现在数少

10:37.260 --> 10:38.540
你感觉的不明显

10:39.260 --> 10:40.140
待会我们去

10:41.100 --> 10:42.300
用这个一万个数

10:42.300 --> 10:43.980
来制造一颗二叉所数

10:43.980 --> 10:44.460
到了时候

10:44.460 --> 10:45.180
你再看

10:45.820 --> 10:47.740
制造完了二叉所数了之后

10:47.740 --> 10:49.260
你再看比较次数

10:49.260 --> 10:50.860
就会非常明显

10:51.900 --> 10:54.220
那我们下一节课来写

10:54.220 --> 10:56.140
如何用代码来构建

10:56.140 --> 10:57.660
一颗二叉所数

