WEBVTT

00:01.260 --> 00:03.260
哈喽 大家好啊

00:03.260 --> 00:07.260
上一集我们说了Close car算法的一个理论上的实现

00:07.260 --> 00:08.260
是吧

00:08.260 --> 00:13.260
这一集开始我们来分别的用代码来实现普林姆算法和Close car算法

00:13.260 --> 00:17.260
现在一个最大的问题

00:17.260 --> 00:18.260
这是一个图

00:18.260 --> 00:19.260
是吧

00:19.260 --> 00:22.260
你说225可以左左右右左右右的这样的给搞出来

00:22.260 --> 00:25.260
图我怎么传给你

00:25.260 --> 00:28.260
我如何把一个图给传给你

00:28.260 --> 00:30.260
同学说你给他连着之后传一个点就行了

00:30.260 --> 00:32.260
反正也是什么回事

00:32.260 --> 00:34.260
图还有其他的表示方法

00:34.260 --> 00:38.260
我们来说一下图的表示方法

00:38.260 --> 00:42.260
比如说这样的一张图

00:42.260 --> 00:45.260
我可能我希望他的所有的节点

00:45.260 --> 00:47.260
现在都是蓝色的

00:47.260 --> 00:51.920
我为什么这么费劲的

00:51.920 --> 00:58.330
是吧

00:58.330 --> 01:03.540
这些都删掉

01:03.540 --> 01:05.540
有这样的一张图

01:05.540 --> 01:08.540
我如何来表示这张图呢

01:08.540 --> 01:10.540
跟大家说

01:10.540 --> 01:12.540
表述一张图有两个要素

01:12.540 --> 01:15.540
一个是点击盒一个是编辑盒

01:15.540 --> 01:19.540
点击盒和编辑盒

01:19.540 --> 01:22.540
表示一个图

01:22.540 --> 01:29.540
可以使用点击盒和编辑盒

01:29.540 --> 01:33.540
表示一张图可以省点击盒和编辑盒

01:33.540 --> 01:35.540
像这样图里面几个点

01:35.540 --> 01:37.540
A,B,C,D,E,F

01:37.540 --> 01:42.450
那么点击盒就是

01:42.450 --> 01:44.450
点击盒

01:44.450 --> 01:47.450
其实你就可以理解为是一个数组

01:47.450 --> 01:49.450
比如说是个数组

01:49.450 --> 01:53.450
A,B,C,D,E,F

01:53.450 --> 01:54.450
对吧

01:54.450 --> 01:56.450
这是个点击盒

01:56.450 --> 01:59.450
编的击盒怎么表示

01:59.450 --> 02:01.450
比如说A到B是4

02:01.450 --> 02:03.450
B到A是4

02:03.450 --> 02:05.450
编是什么

02:05.450 --> 02:07.450
编是点和点之间的关系

02:07.450 --> 02:09.450
编是点和点之间的关系

02:09.450 --> 02:12.450
我们一般可以用表格来表示

02:12.450 --> 02:15.450
A5去

02:15.450 --> 02:17.450
我错了

02:17.450 --> 02:21.720
我们一般用表格来表示

02:21.720 --> 02:27.060
像我们新创建一个页面

02:27.060 --> 02:31.060
我创建出来一个新的表格

02:31.060 --> 02:35.260
一个新的表格

02:35.260 --> 02:42.740
我尽量都给它弄成方形

02:42.740 --> 02:45.740
我把这页的图粘过去

02:45.740 --> 02:50.720
不用了

02:50.720 --> 02:53.720
我把表格粘上去

02:56.720 --> 02:57.720
我几个点

02:57.720 --> 02:59.720
我有五个点

02:59.720 --> 03:01.720
我需要在右边再加上一个点

03:01.720 --> 03:03.720
在后面添加列

03:03.720 --> 03:04.720
五个点

03:04.720 --> 03:06.720
一行

03:06.720 --> 03:07.720
两行

03:07.720 --> 03:08.720
三行

03:08.720 --> 03:09.720
四行

03:09.720 --> 03:11.720
我在下面添加行

03:12.720 --> 03:14.720
有五个列

03:14.720 --> 03:19.720
所以没代表的是A,B,C,D

03:19.720 --> 03:20.720
还有E是吧

03:20.720 --> 03:22.720
再添加一列

03:22.720 --> 03:25.860
E

03:25.860 --> 03:27.860
然后多少行呢

03:27.860 --> 03:33.860
A,B,C,D,E

03:33.860 --> 03:38.860
这样的一个节奏

03:38.860 --> 03:40.860
我稍微放大点

03:40.860 --> 03:42.860
大家能看得稍微清楚一些

03:42.860 --> 03:48.930
然后如何来表示

03:48.930 --> 03:49.930
这是个啥

03:49.930 --> 03:51.930
这是不是就是一个二维数组

03:51.930 --> 03:52.930
对吧

03:52.930 --> 03:54.930
就是一个二维数组

03:54.930 --> 03:56.930
A到A的距离

03:56.930 --> 03:57.930
0

03:57.930 --> 03:58.930
自己到自己的距离都是0

03:58.930 --> 03:59.930
B到B的距离也是0

03:59.930 --> 04:01.930
C到C的距离是0

04:01.930 --> 04:02.930
D到D的距离是0

04:02.930 --> 04:04.930
E到E的距离也是0

04:04.930 --> 04:08.930
然后A到B的距离是4

04:08.930 --> 04:10.930
B到A的距离是不是也是4

04:10.930 --> 04:11.930
对吧

04:11.930 --> 04:14.930
然后A到C的距离是7

04:14.930 --> 04:16.930
C到A的距离是不是也是7

04:16.930 --> 04:18.930
对称的

04:18.930 --> 04:22.930
B到C的距离是8

04:22.930 --> 04:24.930
B到C的距离是8

04:24.930 --> 04:26.930
C到B的距离也是8

04:26.930 --> 04:27.930
对吧

04:27.930 --> 04:33.300
然后B到D的距离是6

04:33.300 --> 04:36.300
D到B的距离也是6

04:36.300 --> 04:41.300
然后C到D的距离是5

04:41.300 --> 04:44.300
然后D到C的距离也是5

04:44.300 --> 04:47.300
然后D到E的距离是7

04:47.300 --> 04:49.300
E到D的距离也是7

04:49.300 --> 04:52.300
像D到A就没有连着

04:52.300 --> 04:55.300
我们认为是最大值Max

04:55.300 --> 05:00.300
那剩下的这些位置我们都认为是Max

05:00.300 --> 05:11.270
这样来玩的

05:11.270 --> 05:13.270
这样的话我们可以用一个点

05:13.270 --> 05:16.270
点的集合是个数组是吧

05:16.270 --> 05:18.270
然后再用一个二维数组

05:18.270 --> 05:22.270
就能表示出来所有的点和所有的点

05:22.270 --> 05:25.270
我们用这样的方式来表示一个图

05:25.270 --> 05:28.270
用这样的方式来表示一个图

05:29.270 --> 05:30.270
好吧

05:30.270 --> 05:32.270
我们开始吧

05:32.270 --> 05:34.270
打开一个新的项目

05:34.270 --> 05:35.270
是吧

05:35.270 --> 05:36.270
新的分支

05:36.270 --> 05:39.270
创建一个接下来

05:41.270 --> 05:44.270
那我们先来并一个点的集合

05:44.270 --> 05:46.270
point side

05:46.270 --> 05:47.270
点的集合

05:47.270 --> 05:49.270
用哪些点呢

05:49.270 --> 05:54.760
AB

05:54.760 --> 05:56.760
CDE

05:56.760 --> 05:58.760
C

05:58.760 --> 06:00.760
D

06:00.760 --> 06:02.760
E

06:02.760 --> 06:03.760
对吧

06:03.760 --> 06:04.760
我有这些点

06:04.760 --> 06:07.760
然后我再握一个distance

06:07.760 --> 06:10.760
这个是一个二维数组是吧

06:10.760 --> 06:11.760
二维数组

06:11.760 --> 06:13.760
这是第一行

06:13.760 --> 06:15.760
这是第二行

06:15.760 --> 06:17.760
这是第三行

06:17.760 --> 06:19.760
这是第四行

06:19.760 --> 06:20.760
这是第五行

06:20.760 --> 06:21.760
是吧

06:21.760 --> 06:23.760
我们分辨往里面复职是吧

06:23.760 --> 06:25.760
047Max

06:25.760 --> 06:28.760
047Max

06:28.760 --> 06:30.760
Max我们怎么填

06:30.760 --> 06:35.160
Max怎么填

06:35.160 --> 06:37.160
我有一个Max

06:37.160 --> 06:39.160
比如说等于100万

06:39.160 --> 06:40.160
好吧

06:40.160 --> 06:42.160
Max等于100万是吧

06:42.160 --> 06:44.160
Max

06:44.160 --> 06:46.160
然后呢

06:46.160 --> 06:47.160
第二行

06:47.160 --> 06:49.160
4086Max

06:49.160 --> 06:50.160
是吧

06:50.160 --> 06:54.160
4086Max

06:54.160 --> 06:56.160
第三行

06:56.160 --> 06:58.160
7805Max

06:58.160 --> 07:03.160
7805Max

07:03.160 --> 07:04.160
第四行

07:04.160 --> 07:06.160
Max 6507

07:06.160 --> 07:07.160
是吧

07:07.160 --> 07:11.160
Max 6507

07:11.160 --> 07:12.160
最后一行

07:12.160 --> 07:14.160
Max Max Max 70

07:14.160 --> 07:23.010
Max Max Max 70

07:23.010 --> 07:24.010
是吧

07:24.010 --> 07:25.010
我们这样的方式

07:25.010 --> 07:27.010
做了一个点的集合

07:27.010 --> 07:28.010
做了一个点的集合

07:28.010 --> 07:29.010
然后呢

07:29.010 --> 07:32.010
我刚刚有个普林姆算法

07:32.010 --> 07:35.010
给我传入一个

07:35.010 --> 07:37.010
Pulled Size

07:37.010 --> 07:40.010
我传入一个Distance

07:40.010 --> 07:42.010
给我传入一个70点

07:42.010 --> 07:43.010
是吧

07:43.010 --> 07:45.010
因为我们说了普林姆算法是需要一个70点的

07:45.010 --> 07:46.010
是吧

07:46.010 --> 07:48.010
需要一个70点的

07:48.010 --> 07:50.010
我们用这样的东西

07:50.010 --> 07:52.010
就能反正搞得定了

07:52.010 --> 07:54.010
搞得定

07:54.010 --> 07:56.010
这是一个普林姆的算法

07:56.010 --> 07:57.010
对吧

07:57.010 --> 07:58.010
然后呢

07:58.010 --> 07:59.010
我们怎么使用

08:00.010 --> 08:01.010
我们怎么使用

08:01.010 --> 08:02.010
比如说

08:02.010 --> 08:04.010
我们可以来一个

08:07.010 --> 08:12.010
来一个Prim

08:12.010 --> 08:14.010
Pulled Size

08:14.010 --> 08:15.010
传入Pulled Size

08:15.010 --> 08:16.010
70点

08:16.010 --> 08:17.010
Distance

08:17.010 --> 08:19.010
我们传入一个Distance

08:19.010 --> 08:20.010
然后呢

08:20.010 --> 08:21.010
起始的点

08:21.010 --> 08:24.010
我们从哪个点开始起始呢

08:24.010 --> 08:25.010
起始点

08:25.010 --> 08:26.010
我们从哪个点开始起

08:26.010 --> 08:30.010
我们假如从C来开始起

08:30.010 --> 08:31.010
好吧

08:31.010 --> 08:33.010
从C来开始起

08:33.010 --> 08:35.010
这是一个70点

08:35.010 --> 08:36.010
好吧

08:36.010 --> 08:39.010
这是一个一个点了

08:39.010 --> 08:40.010
然后呢

08:40.010 --> 08:42.010
我们来看普林姆算法

08:42.010 --> 08:45.010
首先

08:45.010 --> 08:46.010
首先

08:46.010 --> 08:49.010
我每一次连接一个点

08:49.010 --> 08:50.010
我要给它创建一个对象

08:50.010 --> 08:51.010
是吧

08:51.010 --> 08:52.010
不论怎样

08:52.010 --> 08:54.010
你现在传进来的Start

08:54.010 --> 08:55.010
传进来Start

08:55.010 --> 08:57.010
我都要给它创建一个

08:57.010 --> 08:58.010
节点是吧

08:58.010 --> 09:00.010
Node

09:01.010 --> 09:04.010
图的对象怎么创建来的

09:06.010 --> 09:08.010
Z的

09:08.010 --> 09:09.010
Neighbor 是吧

09:10.010 --> 09:12.010
因为它可能有很多的邻居是吧

09:12.010 --> 09:13.010
它有可能有很多的邻居

09:13.010 --> 09:14.010
对吧

09:14.010 --> 09:16.010
Neighbor的我们说

09:16.010 --> 09:17.010
刚传进来的这个

09:17.010 --> 09:18.010
我必须得给它连上

09:18.010 --> 09:19.010
对吧

09:19.010 --> 09:20.010
刚传进来的这个

09:20.010 --> 09:21.010
我必须得给它连上

09:21.010 --> 09:23.010
所以怎么办

09:23.010 --> 09:24.010
Node一个

09:24.010 --> 09:25.010
Start

09:27.010 --> 09:28.010
Ware一个

09:28.010 --> 09:30.010
Ware一个这个Root

09:30.010 --> 09:31.010
是吧

09:31.010 --> 09:32.010
Furth

09:32.010 --> 09:35.580
Furth也不太合适是吧

09:36.580 --> 09:38.580
Node

09:38.580 --> 09:40.580
等于Neighbor一个Node

09:40.580 --> 09:44.490
Start

09:47.490 --> 09:49.490
把这个节点创建进来

09:49.490 --> 09:50.490
放在这里

09:50.490 --> 09:51.490
把这个节点创建进来

09:51.490 --> 09:52.490
放在这里

09:53.490 --> 09:54.490
然后呢

09:54.490 --> 09:58.990
我们要根据这个节点

09:58.990 --> 10:00.990
我们要根据

10:00.990 --> 10:02.990
已有的这个节点

10:02.990 --> 10:04.990
我们要根据已有的这个节点

10:04.990 --> 10:06.990
来获取什么

10:06.990 --> 10:10.300
获取

10:10.300 --> 10:12.300
最小代价的

10:12.300 --> 10:14.300
编

10:14.300 --> 10:15.300
对吧

10:15.300 --> 10:16.300
获取最小代价的编

10:16.300 --> 10:17.300
是吧

10:17.300 --> 10:18.300
但是普利姆斯拉姆说了

10:18.300 --> 10:19.300
最开始的时候

10:19.300 --> 10:20.300
你有一个节点

10:20.300 --> 10:21.300
连进来的就有两个节点

10:21.300 --> 10:22.300
再连进来的话

10:22.300 --> 10:23.300
就有三个节点

10:23.300 --> 10:24.300
所以说

10:24.300 --> 10:25.300
你要根据的是

10:25.300 --> 10:26.300
一个点的集合来获取

10:26.300 --> 10:27.300
对吧

10:28.300 --> 10:30.300
get一个min

10:30.300 --> 10:31.300
this

10:31.300 --> 10:32.300
node

10:33.300 --> 10:34.300
我们要

10:34.300 --> 10:35.300
传进来什么呢

10:35.300 --> 10:37.300
传入一个all points

10:38.300 --> 10:42.410
all points

10:42.410 --> 10:43.410
所有的点

10:44.410 --> 10:45.410
然后呢

10:45.410 --> 10:46.410
还得传入一个distance

10:47.410 --> 10:48.410
别的all points

10:48.410 --> 10:49.410
跟着保持一致吧

10:49.410 --> 10:50.410
好吧

10:51.410 --> 10:52.410
点击

10:52.410 --> 10:53.410
编辑

10:53.410 --> 10:54.410
还需要再传入什么

10:55.410 --> 10:57.410
当前已经有的

10:57.410 --> 10:58.410
点是吧

10:58.410 --> 10:59.410
no

10:59.410 --> 11:00.410
point side

11:02.410 --> 11:03.410
已经连进来的多少

11:04.410 --> 11:05.410
你说我刚传进来的时候

11:05.410 --> 11:06.410
这个side里面

11:06.410 --> 11:08.410
是不是只有一个

11:09.410 --> 11:10.410
是不是只有一个点

11:10.410 --> 11:11.410
是不是只有一个点

11:13.410 --> 11:14.410
对吧

11:14.410 --> 11:15.410
最开始的时候

11:15.410 --> 11:16.410
我是不是

11:16.410 --> 11:17.410
只有一个点

11:17.410 --> 11:18.410
是

11:18.410 --> 11:19.410
连同进来的

11:19.410 --> 11:20.410
那我就要

11:20.410 --> 11:21.410
以这个点为

11:21.410 --> 11:22.410
起点

11:23.410 --> 11:24.410
是吧

11:24.410 --> 11:25.410
不管怎么样

11:25.410 --> 11:26.410
我也不知道进行几次

11:26.410 --> 11:27.410
没有出

11:29.410 --> 11:30.410
然后呢

11:30.410 --> 11:31.410
我要

11:31.410 --> 11:32.410
word一个min

11:32.410 --> 11:33.410
this

11:33.410 --> 11:34.410
node

11:35.410 --> 11:36.410
等于

11:36.410 --> 11:37.410
getmin

11:37.410 --> 11:38.410
this node

11:38.410 --> 11:39.410
我要通过这种方法

11:39.410 --> 11:40.410
来获取一个最小的点

11:40.410 --> 11:42.410
我要传进去什么

11:42.410 --> 11:43.410
传进去什么呀

11:44.410 --> 11:45.410
首先点击传进去

11:45.410 --> 11:46.410
编辑传进去

11:46.410 --> 11:48.410
还有一个no point side

11:48.410 --> 11:49.410
no point side

11:49.410 --> 11:50.410
是吧

11:50.410 --> 11:52.410
是我们需要的

11:52.410 --> 11:53.410
我把这个人

11:53.410 --> 11:54.410
喜欢注释

11:54.410 --> 11:56.850
需要

11:56.850 --> 11:57.850
传入

11:57.850 --> 11:59.850
点的集合

11:59.850 --> 12:01.850
编的集合

12:01.850 --> 12:02.850
还有

12:02.850 --> 12:03.850
当前

12:03.850 --> 12:05.850
已经

12:05.850 --> 12:06.850
连接

12:06.850 --> 12:08.850
进入的集合

12:09.850 --> 12:10.850
点的集合

12:10.850 --> 12:11.850
编的集合

12:11.850 --> 12:12.850
还有当前已经连接进入的集合

12:12.850 --> 12:13.850
是吧

12:13.850 --> 12:14.850
那我们这个

12:14.850 --> 12:15.850
当前已经连接进入的集合

12:15.850 --> 12:16.850
要怎么样

12:16.850 --> 12:17.850
我们要来一个

12:17.850 --> 12:18.850
是吧

12:21.290 --> 12:22.290
怎么办

12:22.290 --> 12:23.290
怎么来

12:23.290 --> 12:25.290
是不是word一个

12:26.290 --> 12:28.290
no point side

12:28.290 --> 12:29.290
side

12:29.290 --> 12:30.290
等于一个数组

12:30.290 --> 12:31.290
就ok了

12:31.290 --> 12:32.290
是吧

12:32.290 --> 12:34.290
等于这个数组就ok了

12:34.290 --> 12:36.290
然后你刚才不是有个node吗

12:36.290 --> 12:38.290
我让no point side

12:38.290 --> 12:39.290
点

12:39.290 --> 12:40.290
push

12:40.290 --> 12:41.290
node

12:41.290 --> 12:42.290
把当前这个节点放进去

12:42.290 --> 12:43.290
是吧

12:43.290 --> 12:45.290
我们把这个集合传进去

12:45.290 --> 12:47.290
我们希望得到一个

12:47.290 --> 12:49.290
距离最小的节点

12:49.290 --> 12:50.290
我们希望得到一个

12:50.290 --> 12:51.290
距离最小的节点

12:54.290 --> 12:55.290
那

12:55.290 --> 12:56.290
开始吧

12:56.290 --> 12:57.290
我们来写这个算法

12:57.290 --> 12:59.290
这个算法是需要

12:59.290 --> 13:00.290
获得一个

13:00.290 --> 13:01.290
这个算法

13:01.290 --> 13:02.290
这个方法

13:02.290 --> 13:03.290
此方法

13:04.290 --> 13:07.300
是

13:07.300 --> 13:08.300
根据

13:08.300 --> 13:10.300
当前已经

13:12.300 --> 13:13.300
有的节点

13:15.300 --> 13:16.300
来

13:17.300 --> 13:18.300
进行

13:18.300 --> 13:19.300
判断

13:20.300 --> 13:21.300
获取到

13:22.300 --> 13:23.300
最短的点

13:25.300 --> 13:26.300
距离最短的点

13:32.650 --> 13:33.650
对吧

13:34.650 --> 13:36.650
获得到当前距离最短的点

13:36.650 --> 13:38.650
我们先来一个起点

13:38.650 --> 13:39.650
我们的起点

13:39.650 --> 13:40.650
可能是不一定的

13:40.650 --> 13:41.650
word一个

13:41.650 --> 13:42.650
from node

13:43.650 --> 13:44.650
起点

13:44.650 --> 13:45.650
等于空

13:45.650 --> 13:46.650
在word一个

13:46.650 --> 13:47.650
终点

13:49.650 --> 13:50.650
me

13:50.650 --> 13:51.650
this node

13:52.650 --> 13:53.650
等于空

13:54.650 --> 13:55.650
这个是代表的是

13:55.650 --> 13:56.650
线段的起点

13:58.650 --> 13:59.650
这个代表的是

13:59.650 --> 14:00.650
线段的终点

14:04.880 --> 14:05.880
一个起点

14:06.880 --> 14:07.880
然后我们再设置一个

14:07.880 --> 14:08.880
word一个

14:08.880 --> 14:09.880
me

14:09.880 --> 14:10.880
this

14:10.880 --> 14:11.880
最短的距离

14:11.880 --> 14:12.880
我们要看到

14:12.880 --> 14:13.880
这一条线段

14:13.880 --> 14:14.880
最短的距离

14:14.880 --> 14:15.880
是多少

14:15.880 --> 14:16.880
最开始的时候

14:16.880 --> 14:17.880
我们认为max

14:18.880 --> 14:19.880
认为max

14:19.880 --> 14:20.880
我们要找的比max小的

14:20.880 --> 14:21.880
是不是

14:21.880 --> 14:22.880
只要是个数据

14:22.880 --> 14:23.880
应该比max小

14:23.880 --> 14:24.880
对吧

14:24.880 --> 14:25.880
那我们来

14:25.880 --> 14:28.190
进行一次

14:29.190 --> 14:30.190
word i

14:30.190 --> 14:31.190
等于0

14:31.190 --> 14:32.190
i小于

14:33.190 --> 14:34.190
no point of sight

14:34.190 --> 14:35.190
点line

14:35.190 --> 14:36.190
我们要根据

14:36.190 --> 14:37.190
现在已有的这些点

14:41.570 --> 14:42.570
根据

14:42.570 --> 14:43.570
当前

14:43.570 --> 14:44.570
已有的

14:44.570 --> 14:45.570
这些点

14:47.570 --> 14:48.570
为起点

14:52.010 --> 14:53.010
一次

14:55.010 --> 14:56.010
判断

14:57.010 --> 14:58.010
连接

14:58.010 --> 14:59.010
其他的点

15:01.010 --> 15:02.010
的距离是多少

15:05.010 --> 15:06.010
根据当前已有的点

15:06.010 --> 15:07.010
为起点

15:07.010 --> 15:09.010
其他的距离是多少

15:09.010 --> 15:10.010
比如说

15:10.010 --> 15:11.010
no point of sight

15:11.010 --> 15:12.010
现在取得了

15:12.010 --> 15:13.010
第一个

15:13.010 --> 15:14.010
取得了第一个

15:14.010 --> 15:15.010
当前的

15:15.010 --> 15:16.010
得跟哪些比

15:16.010 --> 15:17.010
跟哪些比

15:23.670 --> 15:24.670
no point of sight

15:24.670 --> 15:25.670
我得跟哪些比

15:26.670 --> 15:27.670
是不是

15:29.670 --> 15:30.670
word 一个 i

15:30.670 --> 15:31.670
接

15:31.670 --> 15:32.670
小于0

15:32.670 --> 15:33.670
接小于

15:33.670 --> 15:34.670
什么

15:34.670 --> 15:37.180
接

15:37.180 --> 15:38.180
小于

15:39.180 --> 15:40.180
什么

15:40.180 --> 15:41.180
distance

15:42.180 --> 15:44.180
我们要找的这一行是吧

15:44.180 --> 15:45.180
比如说

15:45.180 --> 15:46.180
我们最开始的起点

15:46.180 --> 15:47.180
是啥

15:47.180 --> 15:48.180
比如说我们最开始的起点

15:48.180 --> 15:49.180
传经就是C

15:49.180 --> 15:50.180
我要看

15:50.180 --> 15:51.180
从C开始

15:51.180 --> 15:52.180
到各个

15:53.180 --> 15:54.180
点的距离

15:54.180 --> 15:55.180
我要找的这一行

15:55.180 --> 15:57.180
我这个C是第几行

15:58.180 --> 15:59.180
C是第几行

16:01.180 --> 16:02.180
C是第几行

16:03.180 --> 16:04.180
我没有这个方法是吧

16:04.180 --> 16:05.180
C是第几行

16:05.180 --> 16:07.180
取决于它的序号之际

16:07.180 --> 16:08.180
是吧

16:08.180 --> 16:09.180
我写个方法

16:10.180 --> 16:11.180
cat index

16:11.180 --> 16:12.180
传入一个

16:14.180 --> 16:15.180
然后复讯完

16:17.180 --> 16:18.180
wake i

16:18.180 --> 16:19.180
等于0

16:19.180 --> 16:20.180
i小于

16:21.180 --> 16:22.180
point of sight

16:22.180 --> 16:23.180
the lens

16:23.180 --> 16:24.180
i加加

16:25.180 --> 16:26.180
if

16:26.180 --> 16:27.180
s72

16:28.180 --> 16:29.180
等于

16:29.180 --> 16:31.620
point of sight

16:31.620 --> 16:32.620
i

16:33.620 --> 16:35.620
这点是找到相同了是吧

16:35.620 --> 16:36.620
return

16:36.620 --> 16:37.620
什么

16:37.620 --> 16:38.620
return

16:39.620 --> 16:40.620
如果最后都找不到呢

16:40.620 --> 16:41.620
那就return

16:45.570 --> 16:47.570
那我们要对哪一行

16:47.570 --> 16:48.570
看的是哪一行

16:49.570 --> 16:50.570
这个distance

16:50.570 --> 16:51.570
有很多行是吧

16:51.570 --> 16:52.570
哪一行

16:53.570 --> 16:54.570
cat index

16:56.570 --> 16:57.570
cat index

16:57.570 --> 16:58.570
cat index是谁

16:59.570 --> 17:00.570
no point of sight

17:01.570 --> 17:03.570
我现在看的是哪个点

17:03.570 --> 17:05.570
我就找的是第几行

17:05.570 --> 17:06.570
是吧

17:06.570 --> 17:07.570
看的点的那一行

17:07.570 --> 17:08.570
the lens

17:09.570 --> 17:10.570
很多同学的

17:10.570 --> 17:11.570
我现在可能看不懂

17:11.570 --> 17:12.570
wake no point

17:13.570 --> 17:16.780
index

17:17.780 --> 17:18.780
我给他提示

17:20.780 --> 17:22.780
可能能稍微好看一点

17:23.780 --> 17:28.140
这一块就要求

17:28.140 --> 17:30.140
对代码得非常的熟练

17:30.140 --> 17:32.140
对代码得非常的熟练

17:32.140 --> 17:34.140
因为逻辑是正确的

17:34.140 --> 17:35.140
很多同学要是因为

17:35.140 --> 17:36.140
代码的熟练对不上

17:36.140 --> 17:37.140
那就只能去练代码去

17:37.140 --> 17:39.140
这个跟逻辑就没有什么关系

17:41.140 --> 17:42.140
这个是

17:42.140 --> 17:43.140
获取

17:44.140 --> 17:46.140
当前节点的序号

17:47.140 --> 17:49.140
获取当前节点的序号

17:49.140 --> 17:51.580
好了

17:51.580 --> 17:52.580
依次去比较

17:52.580 --> 17:53.580
这一行的东西

17:53.580 --> 17:54.580
是吧

17:54.580 --> 17:56.580
但是不是什么都能比的

17:56.580 --> 17:57.580
不是什么都能比的

17:57.580 --> 17:58.580
有几种情况

17:58.580 --> 17:59.580
不行

17:59.580 --> 18:00.580
哪几种情况

18:01.580 --> 18:02.580
首先

18:04.580 --> 18:05.580
普利姆算法怎么样

18:09.420 --> 18:11.420
如果这个dm

18:11.420 --> 18:12.420
bm 被连进来了

18:12.420 --> 18:13.420
普利姆算法是吧

18:13.420 --> 18:14.420
如果另一端

18:14.420 --> 18:15.420
没有被连进来

18:15.420 --> 18:16.420
就连进

18:16.420 --> 18:17.420
如果被连进来

18:17.420 --> 18:18.420
不行

18:18.420 --> 18:19.420
就不能连的是吧

18:19.420 --> 18:20.420
什么叫被连进来

18:20.420 --> 18:22.420
no point of sight 里面已经有的了

18:22.420 --> 18:23.420
是吧

18:23.420 --> 18:24.420
对吧

18:24.420 --> 18:25.420
no point of sight 里面有的了

18:25.420 --> 18:26.420
是吧

18:26.420 --> 18:27.420
那我们怎么判断有的

18:27.420 --> 18:28.420
no point of sight的

18:28.420 --> 18:29.420
index of

18:29.420 --> 18:30.420
什么

18:31.420 --> 18:32.420
index of 这个点

18:32.420 --> 18:33.420
是吧

18:37.530 --> 18:38.530
index of 什么

18:40.530 --> 18:41.530
我看一下

18:43.530 --> 18:45.530
我们这块现在不是自不创的

18:45.530 --> 18:48.930
是吧

18:48.930 --> 18:49.930
no point of sight

18:49.930 --> 18:50.930
我先不创业对象

18:50.930 --> 18:51.930
我先把这个四二刷进去

18:55.390 --> 18:56.390
我先把这个四二刷进去

18:57.390 --> 18:58.390
这个no point of sight

18:58.390 --> 18:59.390
我先不创业对象

19:00.390 --> 19:01.390
比如说

19:02.390 --> 19:03.390
index of 什么

19:03.390 --> 19:04.390
index of

19:05.390 --> 19:06.390
distance

19:10.050 --> 19:11.050
再创业

19:12.050 --> 19:13.050
this node

19:14.050 --> 19:15.050
等于

19:15.050 --> 19:16.050
distance

19:18.050 --> 19:19.050
那什么

19:21.620 --> 19:22.620
distance

19:22.620 --> 19:23.620
什么

19:23.620 --> 19:24.620
distance

19:24.620 --> 19:25.620
distance

19:26.620 --> 19:27.620
i

19:28.620 --> 19:29.620
我这是d接个了是吧

19:30.620 --> 19:32.620
distance我最开始看的应该是什么

19:33.620 --> 19:34.620
第零个

19:34.620 --> 19:35.620
第一个

19:35.620 --> 19:36.620
第二个

19:36.620 --> 19:37.620
第三个

19:37.620 --> 19:38.620
第四个

19:38.620 --> 19:39.620
是吧

19:39.620 --> 19:40.620
我只能判断的是

19:40.620 --> 19:41.620
我现在接的是这个的序号

19:41.620 --> 19:42.620
第零个

19:42.620 --> 19:43.620
第一个

19:43.620 --> 19:44.620
第二个

19:44.620 --> 19:45.620
第三个

19:45.620 --> 19:46.620
第四个

19:46.620 --> 19:47.620
我现在要获得什么呢

19:47.620 --> 19:48.620
我这个的序号

19:48.620 --> 19:49.620
对应的字母是哪个点

19:50.620 --> 19:51.620
我这个序号

19:51.620 --> 19:52.620
对应的字母是哪个点

19:53.620 --> 19:55.620
point of sight

19:55.620 --> 19:58.120
接

20:02.930 --> 20:03.930
是这个点是吧

20:04.930 --> 20:05.930
point of sight

20:05.930 --> 20:06.930
接是这个点对吧

20:08.930 --> 20:10.930
我现在判断的是第零个

20:10.930 --> 20:11.930
第零个是谁

20:11.930 --> 20:12.930
第零个是a是吧

20:12.930 --> 20:13.930
研究的是

20:13.930 --> 20:14.930
现在是no point

20:14.930 --> 20:15.930
是d

20:15.930 --> 20:16.930
是当前几点的序号

20:16.930 --> 20:17.930
比如说是c

20:17.930 --> 20:19.930
那就是c to a的句

20:19.930 --> 20:20.930
是吧

20:20.930 --> 20:21.930
我判

20:21.930 --> 20:22.930
看no point of sight

20:22.930 --> 20:23.930
里面

20:23.930 --> 20:24.930
有没有

20:25.930 --> 20:26.930
this note

20:29.930 --> 20:31.930
如果this note大于

20:31.930 --> 20:32.930
-1就不行了

20:32.930 --> 20:33.930
是吧

20:33.930 --> 20:34.930
必须得

20:34.930 --> 20:35.930
等于-1

20:35.930 --> 20:36.930
或者说我们必须得小一零

20:38.930 --> 20:39.930
才行

20:40.930 --> 20:41.930
必须得小一零才行

20:42.930 --> 20:43.930
首先

20:44.930 --> 20:45.930
首先

20:45.930 --> 20:46.930
这个点

20:46.930 --> 20:47.930
不能是

20:47.930 --> 20:48.930
已经

20:48.930 --> 20:49.930
接入的点

20:51.930 --> 20:52.930
这是第1条

20:53.930 --> 20:54.930
然后

20:56.930 --> 20:57.930
写什么

20:57.930 --> 20:59.930
它的距离得够短

20:59.930 --> 21:00.930
是吧

21:00.930 --> 21:02.930
它的distance

21:04.930 --> 21:05.930
distance

21:05.930 --> 21:06.930
接

21:07.930 --> 21:09.930
它这个距离

21:09.930 --> 21:14.710
no point of sight

21:15.710 --> 21:16.710
接

21:16.710 --> 21:17.710
因为它是个二维数字

21:17.710 --> 21:18.710
得怎么样

21:19.710 --> 21:20.710
得小于

21:21.710 --> 21:22.710
min this

21:23.710 --> 21:24.710
是吧

21:24.710 --> 21:25.710
它得小于

21:25.710 --> 21:26.710
min this

21:26.710 --> 21:27.710
这种情况下

21:27.710 --> 21:28.710
才行

21:28.710 --> 21:29.710
其次

21:32.660 --> 21:34.660
点之间的距离

21:38.380 --> 21:41.380
这是目前的

21:41.380 --> 21:42.380
最短距离

21:43.380 --> 21:44.380
这才行

21:45.380 --> 21:46.380
符合这两个条件了

21:46.380 --> 21:47.380
那from note的

21:47.380 --> 21:48.380
变成谁

21:49.380 --> 21:50.380
from note变成谁

21:50.380 --> 21:51.380
变成

21:51.380 --> 21:52.380
no point

21:55.910 --> 21:56.910
sight a

21:57.910 --> 21:58.910
是吧

21:58.910 --> 21:59.910
比如说

21:59.910 --> 22:00.910
现在是c

22:00.910 --> 22:01.910
是吧

22:03.910 --> 22:04.910
min this note

22:05.910 --> 22:06.910
等于什么呢

22:07.910 --> 22:08.910
等于this note

22:09.910 --> 22:10.910
这个this note

22:10.910 --> 22:11.910
就是获得当前的note

22:11.910 --> 22:12.910
对吧

22:12.910 --> 22:13.910
这个this note

22:13.910 --> 22:14.910
也就是

22:15.910 --> 22:16.910
这个里面数字

22:16.910 --> 22:17.910
是吧

22:21.250 --> 22:22.250
还有一个

22:22.250 --> 22:23.250
就是

22:23.250 --> 22:24.250
min this

22:24.250 --> 22:25.250
我们得更新

22:25.250 --> 22:26.250
最小的距离

22:26.250 --> 22:27.250
你发现了一个新的

22:27.250 --> 22:28.250
最小的点

22:28.250 --> 22:30.250
我们要让min this等于

22:31.250 --> 22:32.250
distance

22:33.250 --> 22:34.250
这个

22:35.250 --> 22:36.250
这样的话

22:36.250 --> 22:37.250
我们才能保证

22:37.250 --> 22:38.250
这个点是最短的

22:38.250 --> 22:40.250
保证这个点是最短的

22:42.250 --> 22:43.250
这样的话

22:43.250 --> 22:44.250
我们找了一圈

22:44.250 --> 22:45.250
到了最后

22:45.250 --> 22:47.250
我们就能看到一个from note的

22:47.250 --> 22:48.250
是吧

22:48.250 --> 22:50.250
然后还能看到一个

22:50.250 --> 22:51.250
min this note的

22:52.250 --> 22:53.250
是吧

22:53.250 --> 22:55.250
我们能找到一个线的起点

22:55.250 --> 22:56.250
找到一个线的终点

22:56.250 --> 22:57.250
是吧

22:57.250 --> 22:59.250
我们希望的是将起点

22:59.250 --> 23:01.250
和终点进行连接

23:01.250 --> 23:04.250
这个no points side

23:04.250 --> 23:05.250
这块

23:05.250 --> 23:08.750
我们希望传进来的是什么呢

23:09.750 --> 23:11.750
希望传进来的是

23:12.750 --> 23:13.750
看一下

23:13.750 --> 23:14.750
这个东西

23:14.750 --> 23:16.750
我要想着会创建一个对象的

23:16.750 --> 23:19.320
word一个note

23:20.320 --> 23:23.320
nu一个note

23:23.320 --> 23:24.320
start

23:26.320 --> 23:28.760
tart

23:29.760 --> 23:30.760
如果传进去的是

23:30.760 --> 23:31.760
这个节点

23:31.760 --> 23:32.760
那么

23:39.420 --> 23:41.420
如果传进去的是这个节点

23:41.420 --> 23:42.420
我看看这个都哪儿用到了

23:43.420 --> 23:50.260
点lans没有问题

23:51.260 --> 23:52.260
index of

23:54.890 --> 23:56.890
主要是index of这块可能会有问题

23:56.890 --> 23:57.890
是吧

23:57.890 --> 23:58.890
我们要判断是否存在

23:58.890 --> 23:59.890
我们得写一个方法

23:59.890 --> 24:04.030
我们还是应该把这个点

24:04.030 --> 24:06.030
这个东西传出来

24:06.030 --> 24:08.030
getindex

24:08.030 --> 24:13.010
getindex

24:14.010 --> 24:16.010
i的value

24:16.010 --> 24:19.640
比如说我现在C这个点

24:19.640 --> 24:20.640
我现在是个点的对象

24:20.640 --> 24:22.640
但是我得获得C这个值

24:22.640 --> 24:23.640
它是点value

24:23.640 --> 24:25.640
获写得当前节点的序号

24:26.640 --> 24:29.640
然后它我要判断是否存在这个点

24:29.640 --> 24:31.640
我要判断是否存在这个点

24:33.640 --> 24:34.640
function

24:34.640 --> 24:36.640
hasPoint

24:36.640 --> 24:44.660
判断是否存在某个节点

24:46.660 --> 24:47.660
传入第1个是ar

24:49.660 --> 24:50.660
传一个数组

24:50.660 --> 24:53.660
然后我们判断的是一个target

24:55.970 --> 24:56.970
这个

24:57.970 --> 24:58.970
主要是index

24:58.970 --> 24:59.970
这个this node是个啥

24:59.970 --> 25:01.970
这个this node是个字母

25:04.470 --> 25:13.100
this node表示this tense中的点

25:14.100 --> 25:16.100
但是这个点不是对象

25:18.100 --> 25:19.100
因为还没有创建对象

25:19.100 --> 25:20.100
是吧

25:20.100 --> 25:21.100
因为只有当前

25:21.100 --> 25:22.100
no point set里面

25:22.100 --> 25:24.100
才是真正的点的对象

25:25.100 --> 25:26.100
这个能理解了

25:26.100 --> 25:29.100
当前只有no point set里面的东西

25:29.100 --> 25:30.100
才是点的对象

25:32.480 --> 25:33.480
所以说我们点击

25:33.480 --> 25:36.480
其实如果用abcde是不太合适的

25:36.480 --> 25:39.480
点击如果用abcde是不太合适的

25:39.480 --> 25:42.480
我们最好是把abcde给它换了

25:43.480 --> 25:45.480
待会我们来说怎么给它换了

25:47.480 --> 25:48.480
我们要不然的话

25:48.480 --> 25:49.480
还得一个人给它创建

25:49.480 --> 25:52.480
这个点击直接用abcde不太合适

25:52.480 --> 25:54.480
因为我们已经有了这么多个节点

25:55.480 --> 25:56.480
我们已经有了这么多个节点

25:56.480 --> 25:59.480
所以说我们对点击进行下修改

25:59.480 --> 26:01.480
对点击进行下修改

26:01.480 --> 26:03.480
传入点击的时候

26:03.480 --> 26:05.480
我们要传入真正的no

26:05.480 --> 26:06.480
传入真正的no

26:07.480 --> 26:10.480
像我们刚才这种传入的方式是有问题的

26:10.480 --> 26:13.480
但刚才传入的就是abcde都是字母

26:13.480 --> 26:15.480
我们在这里面献创建对象

26:16.480 --> 26:18.480
这样的话写起来就会很麻烦

26:18.480 --> 26:19.480
我们现在写一种

26:20.480 --> 26:23.480
当有了no的了之后

26:23.480 --> 26:24.480
我们来个这样

26:24.480 --> 26:29.560
剥一个a等于你用一个no的

26:32.560 --> 26:36.980
用5个点

26:46.980 --> 26:48.980
将这5个点的放进去

26:54.500 --> 26:56.500
point side的push a

26:57.500 --> 26:58.500
push b

26:58.500 --> 26:59.500
push c

26:59.500 --> 27:00.500
push d

27:00.500 --> 27:01.500
push e

27:09.500 --> 27:11.500
这样的话point side

27:11.500 --> 27:12.500
实际上都是no的对象

27:13.500 --> 27:14.500
no的对象之后

27:14.500 --> 27:16.500
我们也就没有这么一个东西

27:16.500 --> 27:19.500
就直接给的是push start的对象

27:22.500 --> 27:23.500
no point的对象

27:23.500 --> 27:24.500
你现在传进来的一个点击

27:24.500 --> 27:25.500
一个边击

27:25.500 --> 27:27.500
我现在把这个点给传进去

27:28.500 --> 27:31.500
然后获取最小代价的边

27:31.500 --> 27:32.500
然后我们过去

27:37.500 --> 27:38.500
传入点击

27:38.500 --> 27:39.500
是一对真正的no的点

27:39.500 --> 27:41.500
边击是一对距离

27:41.500 --> 27:43.500
然后no point side

27:43.500 --> 27:44.500
也是一个具体的点

27:45.500 --> 27:46.500
这样的话

27:46.500 --> 27:47.500
我们from node

27:47.500 --> 27:49.500
其实是现在的起点

27:49.500 --> 27:50.500
min node

27:50.500 --> 27:51.500
this node

27:51.500 --> 27:52.500
是一个真正的终点

27:52.500 --> 27:53.500
第一种讯法

27:53.500 --> 27:55.500
是便利所有的起点

27:56.500 --> 27:58.500
然后我们获取一个什么

27:59.500 --> 28:01.500
获取一个当前的节点的序号

28:01.500 --> 28:02.500
是吧

28:02.500 --> 28:03.500
del y6

28:03.500 --> 28:04.500
能够获取来的序号

28:04.500 --> 28:06.500
然后我们要便利

28:06.500 --> 28:08.500
这个序号所对应的函

28:09.500 --> 28:11.500
这个序号所对应的整函

28:11.500 --> 28:12.500
对应的整函

28:12.500 --> 28:14.500
找个是哪一个函呢

28:14.500 --> 28:15.500
刚才说了no point

28:15.500 --> 28:16.500
index

28:16.500 --> 28:17.500
index 是吧

28:17.500 --> 28:18.500
这一行

28:18.500 --> 28:19.500
便利这一行

28:20.500 --> 28:21.500
然后看的是

28:21.500 --> 28:23.500
这一行里的每一个点

28:24.500 --> 28:26.500
看的是这一行里的每一个点

28:27.500 --> 28:29.500
看看它是否存在

28:33.500 --> 28:35.500
如果它存在的话

28:36.500 --> 28:37.500
首先它得不存在

28:37.500 --> 28:38.500
如果它存在的话

28:38.500 --> 28:39.500
是不行的

28:39.500 --> 28:41.500
它得不存在

28:41.500 --> 28:42.500
然后并且

28:42.500 --> 28:43.500
它其次点的距离

28:43.500 --> 28:45.500
得是最短的距离

28:45.500 --> 28:47.500
这样才行

28:47.500 --> 28:48.500
这样的话

28:48.500 --> 28:50.500
两重奉勋还了之后

28:50.500 --> 28:51.500
我们的from node

28:51.500 --> 28:52.500
就是点了起点

28:52.500 --> 28:53.500
min node

28:53.500 --> 28:55.500
就是我们想要的终点

28:55.500 --> 28:57.500
然后我们要将这两个点相连

28:57.500 --> 28:58.500
如何相连

29:00.500 --> 29:02.500
from node的neighbor

29:03.500 --> 29:04.500
的push

29:05.500 --> 29:06.500
是吧

29:08.500 --> 29:10.500
起点的邻居是终点

29:10.500 --> 29:11.500
是吧

29:11.500 --> 29:13.500
然后终点的邻居

29:17.600 --> 29:18.600
是起点

29:20.600 --> 29:21.600
是吧

29:21.600 --> 29:22.600
起点的邻居是终点

29:22.600 --> 29:24.600
终点的邻居是起点

29:24.600 --> 29:25.600
然后我们return

29:26.600 --> 29:27.600
min this node

29:28.600 --> 29:29.600
将它返回过去

29:29.600 --> 29:30.600
是吧

29:30.600 --> 29:32.600
然后在我们getmin this node

29:32.600 --> 29:34.600
之后我们就要把它给怎么样

29:35.600 --> 29:37.600
获得了这样的一个点

29:37.600 --> 29:38.600
是吧

29:38.600 --> 29:40.600
我们就要点击给它添加进去

29:42.600 --> 29:44.600
no point aside的push

29:45.600 --> 29:46.600
min this node

29:47.600 --> 29:49.600
代表着我们又连进来了一个点

29:49.600 --> 29:51.600
什么时候结束呢

29:52.600 --> 29:53.600
如果

29:54.600 --> 29:55.600
什么时候结束

29:55.600 --> 29:56.600
如果result

29:57.600 --> 29:58.600
如果result

29:58.600 --> 30:01.600
如果这个no point side的lens

30:03.600 --> 30:05.600
等于point side的lens

30:06.600 --> 30:07.600
是吧

30:07.600 --> 30:09.600
我们相当于把所有的点都连进来

30:10.600 --> 30:11.600
我们就break

30:12.600 --> 30:13.600
我们就break

30:14.600 --> 30:16.600
这个时候break了之后

30:16.600 --> 30:18.600
我们所有的点都是

30:18.600 --> 30:19.600
相连的

30:20.600 --> 30:21.600
比如说break了之后

30:22.600 --> 30:23.600
那我们

30:24.600 --> 30:25.600
来一个吧

30:29.320 --> 30:30.320
C的话是什么呢

30:30.320 --> 30:32.320
是point side的push

30:32.320 --> 30:33.320
是吧

30:34.320 --> 30:35.320
我们来打印一下

30:37.320 --> 30:38.320
cancel了点log

30:40.320 --> 30:41.320
point side

30:42.320 --> 30:43.320
可能会打印很多

30:43.320 --> 30:44.320
咱们试一下

30:53.480 --> 30:54.480
这个lens安定范是吗

30:58.650 --> 31:00.650
我们来看一下这个no point

31:00.650 --> 31:01.650
是多少

31:06.580 --> 31:07.580
cancel了点log

31:08.580 --> 31:09.580
no point index

31:10.580 --> 31:15.460
得bug一下

31:16.460 --> 31:17.460
附一是吧

31:18.460 --> 31:21.020
为啥会得附一呢

31:23.020 --> 31:25.020
那我看一下这个i的value是多少

31:32.330 --> 31:33.330
value是c是吧

31:35.330 --> 31:37.330
该的index为什么会得出来附一呢

31:38.330 --> 31:43.650
i的value

31:45.650 --> 31:51.670
再来执行

32:00.320 --> 32:01.320
然后我们会发现这个地方

32:01.320 --> 32:02.320
有的地方已经

32:02.320 --> 32:03.320
一直不停是吧

32:03.320 --> 32:05.320
就有的地方出现死群完了

32:05.320 --> 32:07.320
这个也是一个正常的现象是吧

32:07.320 --> 32:09.320
因为我们可能某一个地方的出口

32:09.320 --> 32:10.320
没有写清楚

32:10.320 --> 32:12.320
然后咱们再来具体的看一下

32:12.320 --> 32:15.320
哪个地方需要再加一些出口

32:15.320 --> 32:17.320
再看一下哪个地方需要加出口

32:17.320 --> 32:19.320
我们在min distance

32:19.320 --> 32:21.320
来打一个断点吧

32:21.320 --> 32:22.320
好吧

32:22.320 --> 32:23.320
cancel了点log

32:24.320 --> 32:25.320
no point side

32:27.320 --> 32:28.320
好吧

32:28.320 --> 32:30.320
我们每一次把点的集合给打一下

32:33.660 --> 32:34.660
执行

32:37.030 --> 32:39.030
第一圈打完了之后

32:39.030 --> 32:41.030
然后呢就一直的在循环

32:41.030 --> 32:42.030
不出去了吗

32:43.030 --> 32:49.670
看看这就不出去了是吧

32:49.670 --> 32:55.350
还没有掉进来第二次

32:56.350 --> 32:58.350
我在这会我再来打一个一下

32:59.350 --> 33:03.260
看看cancel了点log

33:03.260 --> 33:04.260
打一下行等

33:04.260 --> 33:08.280
看看哪块出现了死群完

33:09.280 --> 33:13.700
没有出去是吧

33:15.700 --> 33:17.700
这块代码没有出去

33:17.700 --> 33:22.320
打一下行等

33:23.320 --> 33:32.030
没有走到这是吧

33:32.030 --> 33:33.030
没有走到这是吧

33:33.030 --> 33:37.860
代表的是上面这块出现了

33:37.860 --> 33:39.860
死群完之类的功能是吧

33:39.860 --> 33:44.640
打这块打一下等号

33:44.640 --> 33:46.640
大家一定要习惯这种调试啊

33:46.640 --> 33:48.640
习惯这种调试啊

33:48.640 --> 33:49.640
这个是必须

33:49.640 --> 33:51.640
你们以后必须要经历的

33:52.640 --> 33:54.640
打一下等号OK是吧

33:57.910 --> 33:58.910
搜了点log

33:59.910 --> 34:00.910
一

34:00.910 --> 34:03.930
一号位

34:05.930 --> 34:06.930
然后二号位

34:13.400 --> 34:14.400
关闭

34:16.400 --> 34:17.400
一号位

34:17.400 --> 34:18.400
二号位一直在走是吧

34:19.400 --> 34:21.400
然后那就是这个复讯环

34:22.400 --> 34:23.400
结束不了是吧

34:24.400 --> 34:25.400
是不是一号位

34:25.400 --> 34:26.400
二号位都能走

34:26.400 --> 34:28.400
但是走不到333

34:32.950 --> 34:33.950
看一下啊

34:34.950 --> 34:35.950
对吧一号位

34:35.950 --> 34:36.950
二号位都能走

34:36.950 --> 34:37.950
但是走不到333

34:37.950 --> 34:38.950
看一下我们来进行调试啊

34:38.950 --> 34:39.950
接等于零

34:39.950 --> 34:40.950
你看这边进行哎

34:40.950 --> 34:41.950
假假是吧

34:41.950 --> 34:42.950
这边应该进行接假

34:43.950 --> 34:44.950
就是调试

34:44.950 --> 34:46.950
有很多同学遇到这样的问题的话

34:46.950 --> 34:47.950
他就懵了

34:47.950 --> 34:49.950
一定要自己进行调试

34:49.950 --> 34:51.950
这种分段调试

34:53.950 --> 34:54.950
二号位

34:54.950 --> 34:55.950
这样我就打印出来了是吧

34:56.950 --> 35:01.740
哎能够进行打印

35:02.740 --> 35:05.740
然后看看就打印出来这么多

35:06.740 --> 35:12.740
还有那块有console的代码

35:12.740 --> 35:14.740
console代码现在需要删掉

35:18.260 --> 35:19.260
这块是吧

35:26.440 --> 35:27.440
A

35:27.440 --> 35:28.440
看A有几个邻居

35:28.440 --> 35:29.440
A有一个邻居

35:29.440 --> 35:30.440
B有几个邻居

35:30.440 --> 35:31.440
B有两个邻居

35:31.440 --> 35:32.440
C有一个邻居

35:32.440 --> 35:33.440
A有一个邻居

35:33.440 --> 35:34.440
是吧

35:34.440 --> 35:35.440
是不是这样的

35:35.440 --> 35:36.440
看一下

35:36.440 --> 35:37.440
A有一个邻居

35:37.440 --> 35:38.440
B有一个

35:38.440 --> 35:39.440
B有两个邻居

35:39.440 --> 35:40.440
是吧

35:40.440 --> 35:41.440
B有一个A

35:41.440 --> 35:42.440
B有一个D

35:42.440 --> 35:43.440
C有一个邻居

35:43.440 --> 35:44.440
C只有一个D对吧

35:45.440 --> 35:46.440
D有三个邻居

35:46.440 --> 35:47.440
B C E

35:47.440 --> 35:48.440
对吧

35:48.440 --> 35:49.440
D有三个邻居

35:49.440 --> 35:50.440
然后呢

35:50.440 --> 35:51.440
E只有一个邻居

35:51.440 --> 35:52.440
E只有一个邻居

35:52.440 --> 35:53.440
D

35:54.440 --> 35:55.440
这样的话

35:55.440 --> 35:57.440
我们就能完成一个普利姆算法

35:58.440 --> 35:59.440
普利姆算法

35:59.440 --> 36:00.440
其实还是

36:01.440 --> 36:02.440
有点难度的

36:02.440 --> 36:03.440
是吧

36:03.440 --> 36:04.440
普利姆算法的话

36:04.440 --> 36:05.440
相对就有点难度的

36:06.440 --> 36:08.440
这就是一个简单的一个题吧

36:09.440 --> 36:11.440
这个HS炮人的可以不用了

36:11.440 --> 36:13.440
因为我们把那个

36:13.440 --> 36:15.440
炮人的size的结构给变了

36:15.440 --> 36:16.440
这个算法

36:16.440 --> 36:18.440
大家必须要回去多看几遍

36:18.440 --> 36:20.440
这种人注释我也写得很全了

36:20.440 --> 36:21.440
然后呢

36:21.440 --> 36:22.440
这里面的带面

36:22.440 --> 36:23.440
我也写得很全了

36:23.440 --> 36:24.440
所以说

36:24.440 --> 36:25.440
大家回去多练几遍

36:25.440 --> 36:27.440
普利姆算法比较

36:27.440 --> 36:28.440
复杂

36:28.440 --> 36:29.440
一不留身就容易写错

36:29.440 --> 36:31.440
这不就一不留身写错了一个地方吗

36:31.440 --> 36:32.440
但是这都是小问题

36:32.440 --> 36:34.440
大家遇到问题了之后

36:34.440 --> 36:35.440
也是

36:35.440 --> 36:36.440
打断点

36:37.440 --> 36:38.440
一次去看

36:38.440 --> 36:39.440
每一个步骤

36:39.440 --> 36:40.440
是不是你想要的

36:40.440 --> 36:41.440
一次去进行调试

36:41.440 --> 36:43.440
这就是普利姆算法

36:43.440 --> 36:44.440
那下一集

36:44.440 --> 36:45.440
我们来说

