WEBVTT

00:00.180 --> 00:04.180
哦 今天咱们讲啥呀 讲这个优化

00:08.320 --> 00:13.520
优化 优化这个东西呢 在我们讲课之前呢 我还是有必要给大家说一下

00:14.680 --> 00:18.880
这个玩意呢 现在呢 在我们现在这个开发环境里边

00:19.680 --> 00:28.680
已经没有像过去那么重要了 啊 像我当时在读初中高中的时候 读初中的时候 第一次接触电脑

00:29.320 --> 00:34.920
那个时候电脑的内存下多少啊 它一兆两兆 这算是比较ok的了

00:35.640 --> 00:43.000
所以那个时候优化显得特别特别重要 因为配置就那么那么一点对吧 cpu 也比较差 什么双和不存在的

00:43.800 --> 00:53.160
内存有比较少 cpu 呢 也比较运算速度也比较差 所以说呢 我们的要做出一些丰富的效果呢 就必须要考虑到硬件的限制

00:53.480 --> 00:57.480
所以说呢 我们只能利用有限的资源去尽量的啊

00:58.520 --> 01:01.720
做出一些好的效果 那么那个优化的就显得特别特别重要

01:02.600 --> 01:05.560
但是学着我们计算机的发展 硬件的更新速度呢

01:06.680 --> 01:13.160
时越来越快 我们的硬件的配置呢 越来越高 你看现在的内存我不知道你们的 现在基本上是八级标配了

01:14.040 --> 01:17.720
对不对 cpu 的话 双和都算是低配了

01:18.440 --> 01:20.680
啊 我的电脑是16盒的

01:21.320 --> 01:29.960
所以说现在的配置这么高的情况下呢 优化呢 它就没有它的地位呢 就已经没有过去那么重要了 尤其是咱们前端

01:30.920 --> 01:36.440
因为我们前端的代码呢 运行在什么位置的 我们应该知道 它运行在浏览器的

01:37.000 --> 01:42.440
浏览器在哪呢 是在用户的电脑上 对不对 你使用的是用户电脑的资源

01:43.160 --> 01:49.400
所以说你又不是使用了浮览器资源 因此呢 对于前端优化而言呢 它的地位

01:50.200 --> 01:59.400
肯定相对于 相对于后端优化来说要低的读 这是这么一个整体的情况 但是它并不是说前端优化不重要

01:59.800 --> 02:05.800
只是呢 它没就那么的重要了 有的时候呢 其实我们在开发过程中要考虑到很多东西

02:06.600 --> 02:13.000
比方说代码的可阅读性 可维护性 以及呢 我们的开发效率

02:14.200 --> 02:19.160
那么这些事情呢 我们肯定还是会考虑的 然后再加上一个优化

02:19.480 --> 02:25.000
所以说优化呢 只是我们在开发过程中 中多考虑环节中的 其中一环而已

02:26.440 --> 02:29.240
而且呢 这一环还并不是最重要的那一环

02:30.360 --> 02:34.760
那么优化我们在对于前端开发而言 我们通常在时代什么时候做呢

02:35.400 --> 02:37.080
一般来说有一些优化

02:38.120 --> 02:40.280
就是他不会影响你的代码可阅读性

02:41.000 --> 02:45.080
你代码阅读起来还ok 也不会耗费你太多的开发时间

02:45.880 --> 02:49.960
那么这种情况下呢 你能做的把它做了啊 就顺便把它做了

02:50.920 --> 02:54.680
那么有一些优化呢 可能会耗费你很多时间

02:55.400 --> 02:59.960
而且呢 他会降低你的代码可阅读性 举个简单的例子啊 就是我们的地规

03:00.920 --> 03:05.240
朋友们学过地规 对吧 那么有一个东西叫做 伪地规优化

03:09.300 --> 03:12.420
像这个东西 他就会严重的影响代码可阅读性

03:14.820 --> 03:19.140
他会严重影响代码可读性

03:20.100 --> 03:24.020
那么像这种优化呢 我们倾向于尽量不住

03:25.060 --> 03:29.140
实在是没办法了啊 比方说将来我们一测试发现这个性能不达标

03:29.540 --> 03:31.860
不达标的时候呢 我们去找到性能的热点

03:32.820 --> 03:36.500
到底是哪一块性能耗费的比较多 发现了这里有一个地规函数

03:36.900 --> 03:39.460
那么他性能耗费的比较多 然后我们综合考虑了

03:40.260 --> 03:43.780
觉得没办法 这一块性能必须要解决 因为不然的话打不了标

03:44.180 --> 03:47.940
所以这个时候呢 我们再去考虑进行伪地规优化呀 去做一些其他优化

03:48.500 --> 03:52.980
那么当然呢 他的付出的代价就是他降低了代码的可读性

03:53.380 --> 03:57.780
所以有的时候呢 大家不要为了一个优化而舍奔逐目

03:58.260 --> 04:00.260
把一些重要的东西呢 就丢弃掉了

04:00.740 --> 04:04.420
你如果说你一切为了性能的话 那里最好去学习机器语言

04:04.740 --> 04:07.140
尽管这个事业上以前已经没有人学习机器语言了

04:07.300 --> 04:11.220
那个性能是最高的 你直接输入一和零 让计算机去使用

04:11.220 --> 04:12.740
那个性能最高毫无疑问的

04:13.300 --> 04:15.940
甚至呢 我们去学习汇编 用汇编开发

04:16.740 --> 04:17.700
那么这但是呢

04:18.260 --> 04:21.700
那个代码就没法看 根本就没法读 它完全不具有可维护性

04:22.020 --> 04:25.140
它会损失很多东西 其实我们我们的开发呢

04:25.860 --> 04:29.300
我们写的软件 我们的开发语言 他们都是工具

04:30.100 --> 04:34.260
它只是一个工具而已啊 能能够帮助我们解决现实问题的工具

04:34.980 --> 04:38.500
不能为了启动某一个指标而去舍奔逐步啊

04:38.500 --> 04:41.380
首先我给大家说这么一个情况啊 优化的情况

04:41.860 --> 04:42.900
不过呢 我们在

04:44.020 --> 04:47.060
今天的课里边 我们还是会尽量的给他详细的介绍吧

04:47.060 --> 04:49.460
在五幼里边 我们可以做的哪些优化

04:50.020 --> 04:54.820
那么对于我们一个五幼项目而言 或者是对于我们一个前端项目而言呢

04:54.980 --> 04:57.460
我们要做的优化通常了分为两大类

04:57.940 --> 04:59.540
一个是打包体积优化

05:01.300 --> 05:05.460
怎么样打包体积 我们将来 你们将来写到前端开发的代码

05:06.980 --> 05:10.100
全部都需要打包的 你看包括我们前几天

05:11.220 --> 05:13.860
讲了一些五幼的工程对吧 特别是用那个五幼颗粒

05:14.980 --> 05:18.020
搭建的工程 那么这个工程是不能直接运行的

05:18.020 --> 05:22.020
你需要打包啊 打包过后呢 变成一个传统的

05:22.980 --> 05:26.180
A-Temple CSSS

05:26.740 --> 05:30.180
GS变成这个东西 然后这个东西呢 交给牛郎七运行

05:31.540 --> 05:34.980
而我们打包的结果里面呢 这个GS包含的东西很毒

05:35.540 --> 05:39.940
因为它包含了我们在工程里面 用到了什么五幼的代码 还有你自己写的代码

05:40.420 --> 05:43.460
还有就是你用了一些第三方库 比如说什么Momentia

05:43.460 --> 05:46.260
Nodash啊XS啊MeguiJS啊等等等等啊

05:46.660 --> 05:48.820
用了可能会用到一些第三方库

05:49.300 --> 05:53.460
那么它都会打不到GS里面 就会导致这个GS的体积过大

05:54.100 --> 05:56.500
那么这里呢 体积过大会造成一个什么影响

05:56.980 --> 05:59.220
因为这些网站呢 将来一旦放到服务器

06:00.180 --> 06:03.540
你从网以从通过浏览器去访问 是不是下载速度

06:04.180 --> 06:07.940
不是下载速度啊 就是下载的时间是不是会变长

06:08.500 --> 06:10.820
对不对 所以打包体积优化的主要目的呢

06:11.700 --> 06:12.180
是

06:14.020 --> 06:17.620
让我们的网站首次加载的时间啊 尽量

06:18.100 --> 06:21.220
短一点 它是起这么一个目的啊 这大包体积优化

06:21.940 --> 06:25.460
好 另一方面优化呢 就是运行使优化

06:28.070 --> 06:32.950
什么叫运行使优化 就是我的GS也好 ATM也好 CSS也好

06:32.950 --> 06:36.310
全部都下载到本地了 都到浏览器了 然后浏览器开始执行了

06:36.310 --> 06:39.030
开始渲染页面了 开始运行我们的GS了

06:39.590 --> 06:42.230
那么这需要一个过程对吧 它不是刷 训练完成的

06:42.230 --> 06:43.350
它是需要一个过程的

06:44.150 --> 06:47.590
渲染我们知道 渲染一个界面是不是要生成什么 ATM

06:47.590 --> 06:51.590
动物数 要生成样式数啊 要生成那个

06:52.310 --> 06:56.950
渲染数 然后一个画出来 对吧 包括我们的GS執行

06:56.950 --> 06:59.670
是不是要一定时间 对吧 要才能执行完

06:59.670 --> 07:01.990
那么这些都是属于运行使优化

07:01.990 --> 07:05.670
所以运行使优化呢 关注的是 我们代码在运行的过程中

07:05.670 --> 07:07.510
怎么样 让它时间更短一点

07:07.910 --> 07:10.630
或者是有的时候呢 我们觉得时间可能短不了

07:10.790 --> 07:15.110
没怕缩短时间了 但是呢 我们可以让用户体验好一点

07:16.150 --> 07:17.830
我举个点难例子啊 有些人觉得

07:18.390 --> 07:20.470
用户体验好不就是时间短吗 那不一定

07:21.590 --> 07:24.390
有的时候呢 你可能做一些小小的工作 比方说

07:25.990 --> 07:29.990
我的网站运行的时间可能要三秒 我说的比较夸张一点啊

07:30.470 --> 07:32.950
这三秒如果说你啥都不做 用户去看到也是一个白板

07:33.350 --> 07:35.430
那可能训练就走了啊 一秒钟过后就跑了

07:35.990 --> 07:39.030
那我们可以做什么呢 如果说我们降低不了这个三秒钟的时间

07:39.030 --> 07:41.030
就是我们可以给它一个假的进度条

07:41.350 --> 07:43.510
你们在网页上看的进度条全是假的

07:43.990 --> 07:46.630
没有网站用真的进度条 真的进度条很难做的

07:46.630 --> 07:49.510
不是说它技术有多高 根本就没用必要把它做出来

07:49.510 --> 07:52.950
因为进度条的目的就是让用户不要走而已

07:53.750 --> 07:56.390
那它不要走 所以说全是假的 你们看到的进度条

07:56.870 --> 08:00.390
我说网易上的进度条基本上全是假的

08:01.190 --> 08:05.430
所以我们就给它显示一个进度条 或者是给它显示一段动画

08:05.430 --> 08:07.350
或者是cameras动画 或者是svg动画

08:07.350 --> 08:09.910
让它先看一看 让它不要走

08:10.150 --> 08:13.510
那么这其实也是一种优化 知道吧 这是运行识化

08:13.510 --> 08:18.550
但是我们当然最好的 最高的目标还是尽量的缩短代码执行时间

08:19.350 --> 08:23.750
那么我们今天晚上给大家讲的呢 讲的是运行识优化

08:24.150 --> 08:27.030
打包体积的这个优化呢就没有时间讲了啊

08:27.350 --> 08:30.470
咱们后续课程里面都有 我们讲的是运行识优化

08:30.710 --> 08:34.950
而运行识优化里面呢 我们讲的是哪一块呢

08:35.030 --> 08:37.030
我讲的是跟伍佑密切相关的

08:38.070 --> 08:40.870
和伍佑密切相关的

08:41.270 --> 08:45.190
那么有些东西跟伍佑没有关系的话 那就靠你的平时的代码积累了

08:45.430 --> 08:49.590
比方说你写了一个js函数 那个函数运行的时间过长

08:50.070 --> 08:53.510
那么这里呢 如果说你要优化的话 跟伍佑就没有关系了

08:53.510 --> 08:55.350
你至于优化了一个函数的指示秀

08:56.230 --> 08:58.630
我们今天晚上讲的都是跟伍佑密切相关的啊

08:58.790 --> 09:03.670
这也是面试题的时候问到的 伍佑里面我们会使用哪些优化手段

09:03.670 --> 09:08.310
那么我今天晚上的课呢 到时候面试的时候能够想起多少就该回答多少了

09:09.350 --> 09:12.390
好 这是关于这个优化了多说一句啊 再多说一句啊

09:12.790 --> 09:17.990
就咱们如果说在做运行时优化的时候了 还有一些考虑点

09:18.550 --> 09:21.270
一个基本的考虑点就是 如果说一块

09:22.230 --> 09:24.070
一块代码它执行的时间很长

09:25.750 --> 09:28.950
那么我们是不是一定要去优化它呢 其实是不一定的

09:29.750 --> 09:31.750
比方说下举个例子吧

09:32.230 --> 09:37.670
一个业链上手次加载啊 业链上手次运行界是

09:37.990 --> 09:43.350
花了时间从20毫秒你把它优化到10毫秒 你觉得有感觉吗

09:43.350 --> 09:48.070
你花了很多力气 花了很多时间和成本 你把它优化到10毫秒 你觉得有意义吗

09:48.310 --> 09:52.470
一点意义都没有对吧 因为根据你感觉不到的 它仍然比这个网站的速度很快

09:52.710 --> 09:55.350
20毫秒跟10毫秒没有什么本质的差别

09:56.230 --> 10:01.670
所以说它其实并不可以了 甚至呢你把它从100毫秒优化到10毫秒

10:01.830 --> 10:02.630
都没有什么感觉

10:04.630 --> 10:07.190
因此我们在做优化的时候呢 其实

10:08.470 --> 10:12.950
有些地方的确实可能会有性的问题 但是呢如果说我们觉得优化它的成本过高

10:12.950 --> 10:17.590
我们也不一定会优化的 它会有个综合考量啊 你们将来来就做了项目经理

10:18.150 --> 10:22.550
做了技术总监 你们将来就会慢慢明白这一点啊 我们都会有考量的

10:23.110 --> 10:26.470
那么我们一般来说会在什么时候进行一些优化呢

10:26.710 --> 10:31.910
我们一般会发现有一些性能热点 然后要因热点 就说它执行的时间很长

10:32.790 --> 10:36.230
像这些性能热点呢 如果说它是单个出现的

10:37.030 --> 10:40.710
就它只是执行一遍 或者是最开始执行一遍后面就不执行了

10:41.190 --> 10:43.910
那么这种情况我懒得去优化了 因为它有什么意义呢

10:44.070 --> 10:47.910
除非它特别好事了 然后耗了几秒钟 我把它优化到100毫秒

10:47.990 --> 10:49.670
那么这个这个是有优化必要的

10:49.990 --> 10:54.070
但是如果说它就像这样子啊 从100毫秒优化到10毫秒其实没多少

10:54.790 --> 10:57.510
我们一般来说优化是要在什么情况下进行优化呢

10:57.910 --> 11:00.390
是有一个东西 它是放到循环里面的

11:01.670 --> 11:04.790
那你就不知道要循环多少次 有可能循环1000次1万次

11:05.590 --> 11:09.030
那么这个东西就很容易放大了 哪怕你优化了1毫秒

11:09.830 --> 11:12.710
放大了1000次 是不是就是1000毫秒

11:13.270 --> 11:16.070
对不对 那么这个时候呢 就非常有优化的必要了

11:16.230 --> 11:18.390
所以我们往往优化会发生在什么时候

11:18.630 --> 11:21.910
发生在那个性能热点 它放到了一个循环里面

11:22.070 --> 11:24.390
那么这个时候呢 我会去考虑它进一优化

11:24.390 --> 11:26.070
让它时间尽量短一点

11:26.070 --> 11:30.230
所以说为什么说一些框架呀 一些第三方库 它特别在乎性能

11:30.230 --> 11:34.790
为什么呢 因为它这些东西呢 它不知道它在什么场地下使用

11:35.190 --> 11:37.350
它有可能再就用一次

11:37.590 --> 11:40.630
但是也有可能会在一个循环里面反复的调用

11:40.790 --> 11:43.110
所以说呢 它必须要把它的性能做到极致

11:43.430 --> 11:47.830
这就是为什么第三方库和一些框架的作者它特别在乎性能

11:47.830 --> 11:48.710
这就是这个原因

11:48.710 --> 11:50.950
而一般来说开发一个业务功能的话

11:51.190 --> 11:52.390
反而觉得无所谓

11:52.390 --> 11:54.390
就这个优化跟我们没有什么关系

11:54.390 --> 11:56.790
所以说你们以后做开发你们就知道了

11:56.790 --> 11:58.870
你们在公司里面做开发 你会发现

11:58.870 --> 12:00.390
因为我之前学到这么多优化

12:00.390 --> 12:01.990
好像跟我们开发没有什么关系

12:01.990 --> 12:03.830
那是因为你平时写的是业务

12:03.830 --> 12:05.510
没有写一些公共的组件

12:05.510 --> 12:07.830
没有写一些公共的模范或者是框架

12:07.830 --> 12:10.790
那自然就不觉得这个优化有什么意义

12:10.790 --> 12:13.670
但一旦你写了这些东西的话 优化就变得有意义了

12:13.670 --> 12:16.710
这是咱们在上课之前啊 先给大家

12:17.270 --> 12:20.790
从一个更高的角度去聊一聊优化这个事

12:22.980 --> 12:23.460
好 来吧

12:25.060 --> 12:26.020
咱们来看一下这个

12:27.460 --> 12:28.980
今天晚上我们学一些

12:28.980 --> 12:29.620
5U里边

12:30.260 --> 12:31.460
在运行的状态下

12:31.460 --> 12:33.460
运行时里边有哪些优化手段

12:33.460 --> 12:35.460
第一个优化手段就是我们昨天讲的使用T

12:37.380 --> 12:38.500
是不是昨天讲过的

12:38.500 --> 12:40.020
我们把总结到这

12:40.020 --> 12:41.220
也是以后面试的时候

12:41.220 --> 12:42.420
你告诉他第一个优化手段

12:42.420 --> 12:44.420
我们就可以给循环的列表里边

12:45.140 --> 12:46.980
一个稳定且唯一的T

12:46.980 --> 12:47.940
所以我们介绍过啊

12:47.940 --> 12:49.140
这就不再推出了

12:49.140 --> 12:50.900
那么这为什么要给一个T呢

12:50.980 --> 12:52.900
是因为我们在列表变动的时候

12:52.900 --> 12:55.620
特别是在插入一个数据

12:55.620 --> 12:57.700
或者是删除一个数据的时候

12:57.700 --> 13:00.660
那么尽量少的去改动真实动

13:00.660 --> 13:02.900
那如果说这一块面试方要详细的

13:02.900 --> 13:03.780
当你介绍一下

13:03.780 --> 13:05.620
是不是昨天的姿势就来了

13:05.620 --> 13:06.980
对吧 就把昨天那个Dev

13:06.980 --> 13:08.900
他的整个比较过程去给他介绍一点

13:09.940 --> 13:12.420
好 这是第一个啊 就不再推出了

13:12.420 --> 13:12.820
第二个

13:14.340 --> 13:16.180
使用冻结的对象

13:16.180 --> 13:17.540
那么首先我给大家说一下

13:17.540 --> 13:18.900
什么叫做冻结的对象

13:19.860 --> 13:21.700
冻结的对象呢是浏览器

13:21.700 --> 13:23.060
啊 列表一个API

13:23.700 --> 13:25.060
啊不是浏览器一个API

13:25.060 --> 13:26.500
是咱们ES列表一个API

13:27.700 --> 13:28.900
顺便我这里问一下啊

13:30.900 --> 13:31.940
因为这几天呢

13:31.940 --> 13:33.700
都遇到了很多很多的基础知识

13:35.460 --> 13:37.940
浏览器API和ES

13:40.950 --> 13:41.590
和ES

13:41.590 --> 13:42.790
大家知道这两个的区别吗

13:47.450 --> 13:47.850
知道吧

13:48.570 --> 13:51.290
或者说加马script和ACMA

13:51.930 --> 13:52.890
ACMAscript

13:53.850 --> 13:55.850
ACMAscript

13:55.850 --> 13:57.850
他们两个区别知道吧

14:01.850 --> 14:02.810
知道Q和E

14:02.810 --> 14:04.010
不知道的话Q和R

14:10.860 --> 14:12.060
后面二个都没听说过啊

14:13.500 --> 14:15.260
那你可能学到一个假的前端吧

14:16.060 --> 14:17.420
这个得听说过啊

14:17.420 --> 14:18.060
这个得听说过

14:18.060 --> 14:19.500
你这个前端的开发里不

14:19.500 --> 14:21.180
其实没有人说什么ES6

14:21.180 --> 14:22.620
就是说这个ACMAscript什么

14:22.620 --> 14:23.260
就这个东西

14:23.260 --> 14:25.900
ES其实就是ACMAscript这个简称啊

14:29.110 --> 14:30.550
燃辉同学说的没错啊

14:30.550 --> 14:32.230
后边呢是前面那个标准

14:32.870 --> 14:33.830
我简单说一下啊

14:35.270 --> 14:35.910
快点说吧

14:35.910 --> 14:36.870
因为我们今天减少优化

14:36.870 --> 14:37.590
不然时间不够

14:38.470 --> 14:39.910
ES呢是最先出现的

14:39.910 --> 14:41.670
用于浏览器团的语言

14:41.670 --> 14:43.430
后来呢经过了浏览器大战

14:44.070 --> 14:44.870
我们知道那个

14:45.990 --> 14:47.190
王进浏览器就

14:48.070 --> 14:49.270
欧味了对吧

14:49.270 --> 14:50.550
就推出了第15台

14:50.550 --> 14:51.990
他一去一度之下呢

14:51.990 --> 14:53.350
反正我也不玩了

14:53.350 --> 14:54.950
就剩微转一个人在玩了

14:54.950 --> 14:55.750
那我就干脆了

14:55.750 --> 14:57.270
就把我发明这个语言呢

14:57.270 --> 14:59.270
就提交给那个欧洲集团机

14:59.830 --> 15:00.390
协会啊

15:00.390 --> 15:01.990
让他把它做成一个语言标准

15:03.110 --> 15:04.550
就跟我们的加巴呀

15:04.550 --> 15:05.910
cjrp呀这些语言一样

15:05.910 --> 15:06.150
对吧

15:06.150 --> 15:08.310
形成一种通用的语言规判

15:08.310 --> 15:09.030
那么就

15:09.670 --> 15:10.950
答案生了这么一个东西啊

15:10.950 --> 15:11.590
就是这个东西呢

15:11.590 --> 15:12.950
就是在加巴斯绩不成的

15:12.950 --> 15:15.190
基础上提取出来的一个语言标准

15:15.190 --> 15:16.870
那么他们目前有什么区别呢

15:16.870 --> 15:18.870
其实我们目前很多时候啊

15:19.750 --> 15:21.990
没有不搞学术研究的话

15:21.990 --> 15:22.790
说这两个东西

15:22.790 --> 15:24.070
实际上是一个东西

15:24.070 --> 15:24.470
但是呢

15:24.470 --> 15:25.750
你要去深扣他的话

15:25.750 --> 15:27.190
他们还是有区别的

15:27.830 --> 15:28.790
有什么区别呢

15:28.790 --> 15:30.870
我们加巴斯绩不成的这个语言呢

15:30.950 --> 15:32.790
他实际上是在浏览期段运行的

15:34.470 --> 15:35.910
而我们的X马斯绩不成的

15:36.390 --> 15:36.710
他

15:37.110 --> 15:38.710
他不依赖于任何环境

15:38.710 --> 15:40.310
他可以在浏览期里边运行

15:40.310 --> 15:41.670
将来你们学的逗的结识

15:41.670 --> 15:43.350
他也可以在服务期段运行

15:43.910 --> 15:45.270
只要有一个环境支持他

15:45.270 --> 15:46.150
能够识别他

15:46.150 --> 15:46.950
他就能运行

15:46.950 --> 15:48.390
他是一套语言标准

15:48.390 --> 15:49.430
我再举个例子啊

15:49.910 --> 15:50.950
就好比说我们

15:51.590 --> 15:52.070
中文

15:53.110 --> 15:53.670
英文

15:54.310 --> 15:55.110
法语

15:55.110 --> 15:57.110
这些东西都属于语言标准

15:57.110 --> 15:58.070
他告诉你你

15:58.070 --> 15:59.750
他在告诉你语法规则

15:59.830 --> 16:00.790
你该怎么样的说话

16:01.350 --> 16:02.710
你怎么样去主持

16:02.710 --> 16:03.190
照去

16:03.190 --> 16:04.390
这叫语法规则

16:04.710 --> 16:05.270
比方说

16:05.270 --> 16:06.870
这个语言标准里边去告诉你

16:06.870 --> 16:09.110
你定义变量得用这个关键词

16:09.670 --> 16:11.430
你用判断得用这个关键词

16:11.430 --> 16:12.790
你也用循环的话

16:12.790 --> 16:13.670
只用这个关键词

16:13.670 --> 16:13.990
对吧

16:13.990 --> 16:15.510
他就定义语言标准

16:15.510 --> 16:16.630
然后呢他会定义

16:16.630 --> 16:17.910
我这个语言里边

16:17.910 --> 16:19.590
有哪些基本的类型

16:20.310 --> 16:20.950
比方说什么

16:20.950 --> 16:21.590
老呀

16:22.310 --> 16:22.550
啊

16:23.110 --> 16:24.470
不解个车呀对吧

16:24.470 --> 16:24.990
还有什么

16:24.990 --> 16:25.750
布林呀对吧

16:25.750 --> 16:26.390
这些东西

16:26.390 --> 16:26.950
他就告诉你

16:26.950 --> 16:28.630
我这个语言里边有哪些基本类型

16:29.350 --> 16:31.350
还有哪些标准的一项

16:31.350 --> 16:32.870
比方说像而瑞呀

16:32.870 --> 16:33.990
这些是不是标准的一项

16:33.990 --> 16:35.510
标准的一项里边有哪些函数

16:35.510 --> 16:36.310
比方说

16:36.310 --> 16:37.670
有什么filter函数啊

16:37.670 --> 16:38.630
有map函数啊

16:38.630 --> 16:39.350
等等等等

16:39.990 --> 16:41.830
还有什么sort函数啊

16:41.830 --> 16:43.430
reverse函数啊

16:44.310 --> 16:46.630
那么这些都是语言标准定义的

16:47.590 --> 16:49.270
他就告诉你该怎么说话

16:49.270 --> 16:50.390
就好比中文一样

16:50.390 --> 16:51.430
也认字

16:51.430 --> 16:52.310
主持

16:52.310 --> 16:53.670
那么这个玩意是什么呢

16:53.670 --> 16:55.190
他是在语言标准

16:56.070 --> 16:56.630
基础上

16:57.590 --> 16:59.510
基于扭烂器环境

16:59.510 --> 17:00.790
创建了这么一个

17:00.790 --> 17:01.910
就是东西

17:01.910 --> 17:02.630
那么也就是说

17:02.630 --> 17:03.830
他的他这里边呢

17:03.830 --> 17:05.190
他包含了语言标准

17:05.190 --> 17:06.710
就是我用他说话

17:06.710 --> 17:07.030
但是呢

17:07.030 --> 17:08.550
我在扭烂器环境里边

17:08.550 --> 17:09.590
所以说我可以说的一些

17:09.590 --> 17:10.550
特别的东西

17:10.550 --> 17:11.910
就好比说我们学了计创机

17:12.870 --> 17:13.750
你们平时说话

17:13.750 --> 17:14.790
平时跟朋友聊天

17:15.430 --> 17:16.950
不会像跟计创机专业

17:16.950 --> 17:18.310
专业人士那样聊天

17:18.310 --> 17:19.510
那样子的那种一样吧

17:20.070 --> 17:21.030
你跟专业人士聊天

17:21.030 --> 17:22.550
是不是有很多的数据啊

17:22.550 --> 17:23.110
对不对

17:23.110 --> 17:24.470
比方说你们将来说的什么

17:24.630 --> 17:25.750
土木工程之类

17:25.750 --> 17:26.790
土木工程专业

17:26.790 --> 17:27.670
那么你是问这里边

17:27.670 --> 17:28.470
这个专业里边

17:28.470 --> 17:29.670
都是用汉语

17:29.670 --> 17:30.710
都是用英语

17:30.710 --> 17:31.830
那么这里边会有很多的

17:31.830 --> 17:32.790
专业数据

17:33.750 --> 17:34.390
对不对

17:34.390 --> 17:35.910
那么这个加了计创机也是一样

17:35.910 --> 17:37.670
他用的语言还是这个语言

17:37.670 --> 17:39.030
用的语言标准还是他

17:39.030 --> 17:39.750
只不过他里边的

17:39.750 --> 17:41.750
加了一些扭烂器特有的东西

17:41.750 --> 17:42.310
比方说

17:47.030 --> 17:47.670
还有什么

17:49.670 --> 17:50.950
你将来也会学习

17:50.950 --> 17:52.230
而这个是这些函数

17:52.230 --> 17:52.870
还包括什么

17:54.790 --> 17:55.430
log

17:55.430 --> 17:55.670
对不对

17:55.670 --> 17:56.550
还像我们这些东西

17:57.510 --> 17:58.310
怎么刀片面子

17:58.870 --> 17:59.830
这些玩意都是在

17:59.830 --> 18:02.070
扭烂器环境里边给你加的东西

18:03.990 --> 18:04.950
明白的意思吧

18:04.950 --> 18:06.950
还包括window这些东西

18:06.950 --> 18:08.070
那么我们把这些东西呢

18:08.070 --> 18:09.590
统称为web API

18:11.110 --> 18:12.470
统称为web API

18:13.590 --> 18:14.710
那么也就是我们可以得到

18:14.710 --> 18:16.070
这么一种是加了script

18:16.070 --> 18:17.510
是等于web API

18:18.710 --> 18:20.310
加上yes

18:21.030 --> 18:22.390
加上acma script

18:22.390 --> 18:23.750
就是我们在这个语言基础上

18:23.830 --> 18:25.350
再勾招了一些web API

18:25.350 --> 18:26.630
就形成了我们的加把script

18:27.350 --> 18:27.910
明白的意思吧

18:27.910 --> 18:28.550
所以将来呢

18:28.550 --> 18:29.430
你们学到log的环境

18:30.230 --> 18:31.910
就不会再有web API了

18:31.910 --> 18:33.590
它就变成log的API了

18:33.590 --> 18:35.030
es的东西招人可以用

18:35.030 --> 18:36.230
sudo招人可以用

18:36.230 --> 18:37.190
对象招人可以用

18:37.190 --> 18:38.310
循环招人可以用

18:38.310 --> 18:39.030
但是呢

18:39.030 --> 18:40.310
怎么这些玩意就用不了了

18:41.270 --> 18:42.230
其实也能用

18:42.230 --> 18:43.510
只不过他里边给你勾

18:43.510 --> 18:44.630
勾到了一些

18:45.270 --> 18:46.550
一模一样的东西出来

18:46.550 --> 18:46.950
但是呢

18:46.950 --> 18:47.910
实际上跟扭烂器里边

18:47.910 --> 18:49.110
就已经有区别了

18:51.540 --> 18:51.860
好

18:51.860 --> 18:52.420
那么这就是

18:52.420 --> 18:52.660
哎

18:52.660 --> 18:53.780
我怎么讲得出来了

18:54.740 --> 18:56.180
我到表说上来

18:56.180 --> 18:56.660
哦对

18:56.660 --> 18:57.140
我说这个

18:58.420 --> 18:59.140
object

18:59.700 --> 19:00.980
一边有个函数

19:00.980 --> 19:01.860
叫做freeze

19:01.860 --> 19:02.820
这是es里面的

19:02.820 --> 19:03.620
提供的函数

19:03.620 --> 19:04.980
标准里面的函数

19:04.980 --> 19:06.100
那么这个freeze里面呢

19:06.100 --> 19:07.300
可以传啥呢

19:07.300 --> 19:08.500
可以传一个对象

19:08.500 --> 19:09.220
那么对象呢

19:09.220 --> 19:09.860
可以是宿主

19:09.860 --> 19:11.060
也可以是一个普通对象

19:11.060 --> 19:12.180
那么比方说

19:12.180 --> 19:13.140
我们这里的有个对象

19:13.940 --> 19:14.900
那就学哪一个吧

19:15.540 --> 19:16.580
m1 b等于2

19:16.580 --> 19:17.300
那么接下来

19:17.300 --> 19:18.420
我们去用objects

19:19.940 --> 19:20.420
freeze

19:20.420 --> 19:21.300
冻结

19:21.300 --> 19:23.220
把这个对象一旦冻结了之后呢

19:23.300 --> 19:24.020
从此以后

19:24.020 --> 19:24.980
这个对象呢

19:24.980 --> 19:26.420
东西就不能改了

19:26.420 --> 19:27.700
你不能去改变它

19:27.700 --> 19:29.220
比方说你要去改变这个a

19:29.220 --> 19:29.700
等于3

19:30.500 --> 19:31.300
好像是能变

19:31.300 --> 19:31.540
对吧

19:31.540 --> 19:32.660
那个来看一下ob界

19:32.660 --> 19:33.860
是不是还是没有变化

19:34.500 --> 19:34.820
然后呢

19:34.820 --> 19:36.100
我给对象加一个属性

19:36.100 --> 19:36.740
c等于3

19:37.540 --> 19:38.500
你看那个ob界

19:38.500 --> 19:40.180
是不是还是没有新增属性

19:40.180 --> 19:40.420
对吧

19:40.420 --> 19:41.700
这叫冻结对象

19:41.700 --> 19:42.500
冻结对象呢

19:42.500 --> 19:43.300
你就可以认为它

19:43.300 --> 19:44.500
是不可变的

19:44.500 --> 19:45.220
它不能变化

19:45.780 --> 19:46.740
没啥意思吧

19:46.740 --> 19:47.540
叫冻结对象

19:48.100 --> 19:49.060
那么我为什么要说

19:49.060 --> 19:50.100
这个冻结对象呢

19:51.220 --> 19:52.660
它是我们在5u里面

19:52.740 --> 19:54.180
作为性能优化的

19:54.180 --> 19:55.860
其中一个手段

19:55.860 --> 19:56.500
为什么呢

19:56.500 --> 19:58.340
因为我们之前第二天的时候

19:58.340 --> 19:59.780
给大家介绍过5u

19:59.780 --> 20:01.380
它的响应式系统

20:01.380 --> 20:02.260
还记得吗

20:02.260 --> 20:03.540
5u的响应式系统

20:03.540 --> 20:04.340
它怎么来操作的

20:06.980 --> 20:08.100
它是不是便利啊

20:08.100 --> 20:10.100
就第一规便利

20:10.820 --> 20:13.380
对象的每一个属性

20:13.380 --> 20:14.340
把每一个属性

20:14.340 --> 20:15.620
全部重新定义一遍

20:15.620 --> 20:16.340
还记得吧

20:16.340 --> 20:17.060
它定义的方式

20:17.060 --> 20:17.860
就是用objects

20:17.860 --> 20:19.460
define property

20:20.420 --> 20:21.460
所以用这种方式

20:21.460 --> 20:22.820
把这个对象的每一个属性

20:22.820 --> 20:23.700
全部定义一遍

20:23.860 --> 20:25.140
那比如说这个对象里边

20:25.860 --> 20:26.740
有100个属性

20:26.740 --> 20:28.340
它就变定了100次

20:29.380 --> 20:30.180
哪怕这100个属性

20:30.180 --> 20:31.460
可能嵌透了程式很深

20:33.300 --> 20:34.420
然后它就变定了100次

20:34.420 --> 20:34.980
那么就不

20:34.980 --> 20:36.900
然后一次给它定义

20:37.860 --> 20:38.500
别的意思吧

20:38.500 --> 20:39.700
那么这样子呢

20:40.260 --> 20:42.260
达到把每一个数据变成响应式

20:42.260 --> 20:43.380
为什么变成响应式

20:43.380 --> 20:44.900
以后这个数据变化之后

20:44.900 --> 20:45.940
我能收到一个通知

20:46.580 --> 20:47.860
它起着每个人作用

20:47.860 --> 20:49.460
但是那你会想到啊

20:49.460 --> 20:50.340
其实有的时候呢

20:50.340 --> 20:52.100
我们在界面上

20:52.100 --> 20:53.060
有些数据确实

20:53.060 --> 20:53.860
不会变化的

20:54.820 --> 20:56.260
我们一般不会去改动它

20:56.260 --> 20:57.700
我们只是把它展示出来

20:58.500 --> 20:59.300
我用一套数据

20:59.300 --> 21:00.660
比方说这个数据

21:00.660 --> 21:01.380
有个数据

21:01.380 --> 21:03.300
数据里边有一些文章

21:04.100 --> 21:05.540
那么我只是把这个文章

21:05.540 --> 21:06.420
展示到一面上

21:06.420 --> 21:07.380
没有人去修改它

21:08.100 --> 21:09.220
那么这个时候呢

21:09.860 --> 21:11.380
你去变异这一套东西

21:11.380 --> 21:12.340
有意义吗

21:12.340 --> 21:13.700
实际上是没有意义的

21:13.700 --> 21:14.980
你把它变成响应式干嘛呢

21:14.980 --> 21:16.420
我将来又不会去改它

21:17.140 --> 21:18.100
因此而为用呢

21:18.100 --> 21:20.100
它其实考虑到这一点的啊

21:20.100 --> 21:22.100
它就做了这么一个处理

21:22.100 --> 21:23.700
如果说你给它的对象

21:24.500 --> 21:25.060
不是

21:25.940 --> 21:26.660
正常的对象

21:26.660 --> 21:28.260
是一个被冻结的对象

21:28.260 --> 21:28.980
像这种

21:28.980 --> 21:30.020
因为被冻结的对象

21:30.020 --> 21:30.580
它有个特点

21:30.580 --> 21:31.780
它就不会变化

21:31.780 --> 21:32.500
那么唯有一看

21:32.500 --> 21:33.780
哦 原来你被冻结了

21:33.780 --> 21:36.100
你里边东西根本就不会变化

21:36.100 --> 21:36.500
因此呢

21:36.500 --> 21:38.500
我没有必要把它变成响应式了

21:38.500 --> 21:39.460
于是这个对象

21:39.460 --> 21:41.140
它就不会做这个响应式处理

21:42.020 --> 21:42.660
明儿的意思吧

21:44.100 --> 21:44.820
那又来说

21:44.820 --> 21:46.260
那么这个对象里边

21:46.260 --> 21:47.540
对象里边能用多少数据

21:49.140 --> 21:50.100
我何必呢

21:50.100 --> 21:51.060
就十哪个

21:52.180 --> 21:53.380
数据可能不得了了

21:53.380 --> 21:55.140
二十哪个数据可能不得了了

21:55.140 --> 21:57.460
那我何必去搞这么麻烦的

21:57.460 --> 21:59.220
你多寻判十四嘛

21:59.220 --> 22:01.140
也影响不了太多的效率

22:01.140 --> 22:02.660
但是你要考虑到这一点

22:02.660 --> 22:03.540
所以我们说效率

22:04.820 --> 22:05.540
优化

22:05.540 --> 22:06.420
一定要把它放到一个

22:07.540 --> 22:08.820
大的角度来看

22:08.820 --> 22:11.300
就是它有可能会在一个循环里边

22:11.300 --> 22:12.340
比方说我们有一个数组

22:14.900 --> 22:16.340
问大家一个问题啊

22:16.340 --> 22:17.540
你能觉得

22:17.540 --> 22:18.660
一个组件里边

22:20.020 --> 22:21.700
它的数据里边的数据

22:23.660 --> 22:26.060
会不会经常超过100个

22:28.330 --> 22:29.610
你们觉得一个组件里边

22:29.610 --> 22:30.890
它的data里边的数据

22:32.570 --> 22:34.010
会不会经常超过100个

22:39.740 --> 22:40.380
不会是吧

22:41.260 --> 22:41.820
实际上呢

22:41.820 --> 22:45.340
这其实是非常常见的

22:45.900 --> 22:47.420
为什么会经常常见的

22:47.980 --> 22:49.180
大家看过这个代码呗

22:49.900 --> 22:51.900
你们组件里边经常都在写这个代码

22:52.540 --> 22:53.180
我相信每一个

22:53.180 --> 22:54.700
只要你写过五六

22:54.700 --> 22:55.820
你基本上都写过这个代码

22:56.460 --> 22:57.900
哎有的人发现了啊

22:58.060 --> 23:00.140
这个数据说看后台给力多少啊

23:00.140 --> 23:01.260
比方说我们这里呢

23:01.260 --> 23:02.220
有一个articles

23:03.580 --> 23:05.740
哎好像就只有一个属性啊

23:05.740 --> 23:07.340
但是你会这样子写代码

23:07.340 --> 23:07.900
created

23:08.780 --> 23:10.540
当这个组件夹杂的时候

23:10.540 --> 23:11.580
我会从远程

23:13.020 --> 23:14.300
从服务器去拿数据

23:15.900 --> 23:17.420
就写个伟代码啊

23:17.420 --> 23:19.500
从服务器去拿拿这个数据

23:19.500 --> 23:21.020
拿到把个数据拿到过后呢

23:21.020 --> 23:22.780
再给这个articles复职

23:22.780 --> 23:24.060
你看这样子一复职

23:25.020 --> 23:26.460
是不是数据有很多了

23:26.540 --> 23:27.740
服务器可能拿到一个数据

23:27.740 --> 23:29.020
这个数据可能有三十条

23:29.900 --> 23:31.340
三十条新闻数据

23:31.340 --> 23:32.860
每条新闻数据是一个对象

23:32.860 --> 23:35.660
每个对象呢可能有二十个数据

23:35.660 --> 23:36.540
非常正常嘛

23:36.540 --> 23:38.780
一个一篇新闻有很多很多的相关数据

23:38.780 --> 23:39.740
表演它的关键字啊

23:39.740 --> 23:40.300
它的表体啊

23:40.300 --> 23:41.260
它的剪接啊

23:41.260 --> 23:42.300
它的桌子啊

23:42.300 --> 23:43.660
它的引用链接啊

23:43.660 --> 23:44.700
它的图片

23:44.700 --> 23:45.820
图片啊对不对

23:45.820 --> 23:46.940
它的创建日期啊

23:46.940 --> 23:47.900
有很多很多的数据

23:48.540 --> 23:49.500
那么这样子一上下来

23:49.500 --> 23:50.140
是不是瞬间

23:50.780 --> 23:52.700
我们的响应数据就一大堆数据了

23:53.500 --> 23:53.980
对不对

23:53.980 --> 23:54.700
那么这个时候呢

23:54.700 --> 23:56.060
它去便利这些数据

23:56.140 --> 23:57.900
把它完成响应式就比较好时间了

23:58.460 --> 24:00.140
而且这只是一个组件哦

24:00.140 --> 24:00.860
同学们

24:00.860 --> 24:02.300
这只是一个组件

24:02.300 --> 24:04.300
我们的页面上只有一个组件吧

24:04.300 --> 24:04.700
不是吧

24:05.420 --> 24:06.860
如果说一个非常大的页面

24:06.860 --> 24:07.420
复杂的页面

24:08.780 --> 24:10.860
上千一般不会啊

24:10.860 --> 24:11.980
一百多个组件呢

24:11.980 --> 24:13.180
是完全有可能的

24:13.180 --> 24:14.860
那如果说这里边有一般的组件

24:14.860 --> 24:15.900
是这种情况

24:15.900 --> 24:16.860
数据就非常多了

24:16.860 --> 24:18.220
这个新闻损耗就比较大了

24:18.220 --> 24:19.980
一个组件确实没有什么新闻损耗

24:20.620 --> 24:21.180
明显的意思啊

24:21.180 --> 24:22.460
所以说这个优化呢

24:22.460 --> 24:23.580
也要根据情况来看

24:24.140 --> 24:25.260
如果说你的组件

24:26.220 --> 24:27.500
它用的数据很多

24:27.500 --> 24:28.220
或者是

24:28.220 --> 24:29.100
我们页面上有很多

24:29.100 --> 24:30.460
类似的这样的组件

24:30.460 --> 24:30.780
那么

24:31.980 --> 24:33.500
我们就需要对它行一行的优化

24:34.780 --> 24:35.580
现在我刚才说了

24:35.580 --> 24:36.780
三十条文章也不留意

24:36.780 --> 24:37.660
不就是分页了吗

24:37.660 --> 24:38.620
如果说你不分页的话

24:38.620 --> 24:39.660
拿文章数据

24:39.660 --> 24:40.860
那就是几十万的导了

24:40.860 --> 24:41.980
那就不是三十条了

24:42.940 --> 24:43.500
而且

24:43.500 --> 24:44.860
比如说那一个页面

24:44.860 --> 24:46.140
它会有三十条数据吗

24:46.140 --> 24:46.860
太正常了

24:46.860 --> 24:48.220
你随便去找一个新闻网站

24:48.220 --> 24:49.180
你看一个页面里面

24:49.180 --> 24:50.380
有多少条文章数据

24:50.380 --> 24:51.820
它只是没有把这些数据

24:51.820 --> 24:53.500
全部给你显示出来而已

24:53.500 --> 24:54.780
它只是显示它的标题

24:54.780 --> 24:57.020
或者是显示它也很小的东西

24:57.020 --> 24:57.500
对吧

24:57.500 --> 25:00.060
但是它数据确实全部拿到了

25:00.060 --> 25:01.100
就说了半天

25:01.100 --> 25:01.820
就这么个意思

25:01.820 --> 25:02.780
像这种数据

25:02.780 --> 25:05.580
我们就有必要把它变成冻结数据

25:05.580 --> 25:06.300
冻结数据

25:06.300 --> 25:07.820
它就不会进行相应式

25:07.820 --> 25:09.100
这里有一个例子

25:09.100 --> 25:10.140
大家看一下

25:10.140 --> 25:11.580
使用冻结都一样

25:11.580 --> 25:13.420
给大家看一下代码

25:13.420 --> 25:13.980
非常简单

25:17.160 --> 25:18.360
我这里有两个数据

25:18.360 --> 25:19.320
一个是普通数据

25:20.040 --> 25:21.000
一个是冻结数据

25:22.920 --> 25:23.560
普通数据

25:25.480 --> 25:25.960
一个是

25:26.920 --> 25:30.440
将来会被冻结的数据

25:30.440 --> 25:32.440
那一开始要不要冻结它

25:32.440 --> 25:33.560
一开始冻结它干嘛呢

25:33.560 --> 25:34.760
它就是个空数据

25:34.760 --> 25:35.800
一种把它冻结过后

25:35.800 --> 25:37.320
我怎么往里边加数据

25:37.320 --> 25:38.360
所以一开始不用去冻结它

25:38.360 --> 25:39.800
一开始根本没有什么数据

25:40.520 --> 25:41.240
这是个普通数据

25:41.240 --> 25:42.360
将来会被冻结的数据

25:42.360 --> 25:43.960
目前看上去都是一样的

25:43.960 --> 25:45.160
然后我做了一件什么事呢

25:45.160 --> 25:45.560
你看着

25:46.440 --> 25:47.640
我这里有个函数

25:47.640 --> 25:49.560
这个函数我就做了个魔力

25:49.560 --> 25:51.000
我就循环了100万次

25:51.800 --> 25:53.080
就魔力我们这个页面上

25:53.080 --> 25:54.280
有很多很多的数据

25:54.280 --> 25:55.000
这个组件用一点

25:55.160 --> 25:55.960
那个组件用一点

25:57.080 --> 25:58.520
然后循环了100万次

25:58.520 --> 25:59.480
每一次循环了

25:59.480 --> 26:01.320
往这个result里边加了一个对象

26:01.320 --> 26:03.560
对象里边就生成一个id

26:03.560 --> 26:04.200
生成一个name

26:04.200 --> 26:05.320
生成一个 address

26:05.320 --> 26:06.120
生成一大堆东西

26:06.680 --> 26:08.520
反正就是随便生成一些属性

26:08.520 --> 26:10.360
一个对象往这个数据里边加

26:10.360 --> 26:11.720
然后把这个数据返回

26:11.720 --> 26:13.640
这里一个辅助方法给的是data

26:14.440 --> 26:16.120
好 接下来我们看这两个函数

26:16.120 --> 26:18.760
一个是load normal data

26:18.760 --> 26:20.040
这是加载普通数据

26:21.480 --> 26:22.920
加载普通数据

26:25.160 --> 26:26.200
看一下我怎么做的

26:26.200 --> 26:27.960
我这里做的方式很简单

26:27.960 --> 26:29.560
如果说你调用这个方法

26:29.560 --> 26:31.880
那么我就会去调用getdata

26:31.880 --> 26:33.720
是不是拿到100万个数据

26:34.600 --> 26:35.800
然后把它放到哪里

26:35.800 --> 26:37.720
把它放到这个属性里边

26:38.920 --> 26:39.480
给它复制

26:40.360 --> 26:41.560
然后我就得输出一下

26:42.680 --> 26:43.880
输出一下这个东西

26:44.520 --> 26:45.960
接下来我又

26:45.960 --> 26:47.800
另外一个方法就是加载冻结数据

26:51.590 --> 26:52.950
好 这个方法我做了什么事呢

26:52.950 --> 26:54.550
我还是调用getdata

26:54.550 --> 26:55.990
我就多写了一句话

26:56.070 --> 26:57.190
把它返回了结果

26:57.190 --> 26:58.390
返回了是不是一个数组

26:58.390 --> 26:59.590
把它返回了这个结果

26:59.590 --> 27:00.470
我给它进行冻结

27:01.270 --> 27:02.310
那么这个数组以后

27:02.310 --> 27:04.710
就从此以后就不能进行更改了

27:04.710 --> 27:05.670
然后把这个冻结

27:06.630 --> 27:08.390
这个冻结的数组

27:08.390 --> 27:09.270
复制给它

27:09.270 --> 27:10.710
这个freeze它会返回

27:10.710 --> 27:12.630
返回冻结的结果

27:12.630 --> 27:14.230
把冻结的结果

27:14.230 --> 27:14.790
复制给它

27:14.790 --> 27:15.990
那么它就是个冻结的东西了

27:16.950 --> 27:17.990
然后我们再输出

27:17.990 --> 27:18.790
这个冻结的对象

27:19.510 --> 27:20.150
好 一看

27:20.150 --> 27:21.910
我这两个方法就只有一个区别

27:21.910 --> 27:22.870
都是调用它

27:22.870 --> 27:24.230
给它结成一个属性复制

27:24.230 --> 27:24.790
然后输出

27:25.750 --> 27:26.790
只不过有一个

27:27.590 --> 27:28.390
唯一不同的就是

27:28.390 --> 27:29.750
我在这个函数里边

27:29.750 --> 27:31.670
我对返回的东西进行冻结

27:31.670 --> 27:32.790
那么这居然模拟什么

27:32.790 --> 27:34.310
模拟从服务器拿到的数据

27:34.310 --> 27:35.350
拿到一大堆数据

27:35.350 --> 27:36.310
而这一堆数据

27:36.310 --> 27:37.750
我们不需要去做改变

27:37.750 --> 27:39.030
我们只是把它显示出来

27:39.830 --> 27:41.510
好 这是我们的整个代码节奏

27:41.510 --> 27:42.710
先让我们看我们的模办

27:42.710 --> 27:43.750
模办没有非常简单

27:44.470 --> 27:45.910
我有两个A期

27:46.790 --> 27:47.430
第一个A期

27:47.430 --> 27:49.590
我就显示普通数据的长度

27:50.310 --> 27:51.350
第二个A期

27:51.350 --> 27:53.670
我显示的是冻结数据的长度

27:55.190 --> 27:55.750
原理是吧

27:55.750 --> 27:57.590
这两个A期就完事了

27:57.590 --> 27:59.110
普通数据的数量

27:59.110 --> 28:00.150
冻结数据的数量

28:00.150 --> 28:01.750
然后上面有两个按钮

28:01.750 --> 28:03.190
第一个按钮点击过后了

28:03.190 --> 28:04.390
是夹载冻结数据

28:04.390 --> 28:05.830
是不是调用这个方法

28:05.830 --> 28:06.870
第二个按钮点击过后了

28:06.870 --> 28:08.710
是夹载冻结数据

28:08.710 --> 28:09.430
一个夹载普通

28:09.430 --> 28:10.550
一个夹载冻结

28:10.550 --> 28:11.430
好 接下来我们来看一下

28:12.310 --> 28:13.590
我进入这个文件夹

28:13.590 --> 28:14.710
区别运行它

28:14.710 --> 28:15.670
大家可以体会一下

28:15.670 --> 28:16.310
它们的区别

28:17.590 --> 28:18.150
一双色

28:25.100 --> 28:26.300
好 大家运行它

28:27.260 --> 28:30.460
一开始两个数据的数量是零

28:30.460 --> 28:32.220
然后接下来我们来点击这个

28:32.220 --> 28:34.140
夹载普通数据点一下

28:34.140 --> 28:39.700
要等一会儿了

28:39.700 --> 28:41.700
好 显示出来了

28:41.700 --> 28:43.540
那么从我点击到显示

28:43.540 --> 28:45.140
是不是经过了很长一段时间

28:45.140 --> 28:47.140
那么你觉得它这段时间的干嘛呀

28:47.140 --> 28:48.740
干嘛呀

28:48.740 --> 28:51.220
不就是在完成数据想用是吗

28:51.220 --> 28:54.260
当然这个地方可能会耗一点时间

28:54.260 --> 28:55.460
循环了100万次

28:55.460 --> 28:57.620
其实循环100万次耗不了多少时间

28:57.620 --> 28:58.420
耗不了多少

28:58.740 --> 29:01.140
那么我们点这个按钮看一下

29:01.940 --> 29:02.980
这个点这个按钮

29:02.980 --> 29:04.340
它也要循环100万次

29:04.340 --> 29:06.180
对吧 也要从刁文这个方法来看一下

29:07.940 --> 29:08.660
是不是快得多

29:09.780 --> 29:10.420
对不对

29:10.420 --> 29:12.420
那么我们可以其实这是直观的看法

29:12.420 --> 29:14.260
其实我们可以利用浏览器的

29:14.260 --> 29:15.940
这个调试工具叫Performance

29:17.460 --> 29:18.420
叫做性能监测

29:18.980 --> 29:20.740
我们在这边可以更加清楚的看到

29:20.740 --> 29:21.780
我再重新刷新一次

29:22.740 --> 29:23.700
好 接下来我们点这个

29:24.260 --> 29:25.140
开始录制

29:25.140 --> 29:27.220
它就会监控我们的整个浏览器里边

29:27.380 --> 29:28.660
包括GS的执行

29:28.660 --> 29:29.780
包括我们的页面宣展

29:29.780 --> 29:31.860
它花费的时间都会监控下来

29:31.860 --> 29:33.140
我们点击开始录制

29:33.140 --> 29:34.260
它开始录制了

29:34.260 --> 29:34.820
不用管它

29:34.820 --> 29:35.940
那么接下来我们点这个按钮

29:36.500 --> 29:37.380
加载普通数据

29:39.420 --> 29:39.980
等一会儿

29:42.950 --> 29:44.390
可以看这个时间是不是很久

29:44.390 --> 29:45.750
接下来我们加载这个

29:45.750 --> 29:46.710
加载冻节数据

29:49.030 --> 29:49.350
出完了

29:49.350 --> 29:51.110
那么这里我们点击停止

29:51.110 --> 29:51.750
不用监测了

29:51.750 --> 29:52.710
我们来看一下之前

29:53.670 --> 29:54.710
生成的那个就是

29:55.750 --> 29:56.390
叫Profile

29:56.390 --> 29:57.030
是怎么翻译的

29:58.150 --> 29:58.710
接下来给我们看

29:59.350 --> 29:59.830
看这一段

30:00.710 --> 30:01.830
我们只观测这一段

30:01.830 --> 30:03.190
从这里开始到这里结束

30:03.590 --> 30:04.230
那么这里呢

30:04.230 --> 30:05.910
就是出现了一个播风

30:05.910 --> 30:06.310
对不对

30:06.870 --> 30:08.390
那么这个播风其实就是我们

30:09.190 --> 30:10.070
所耗的时间

30:10.070 --> 30:11.510
就是有些东西正在忙

30:11.830 --> 30:12.790
在忙活的时间

30:13.350 --> 30:14.230
那么大家可以看到

30:14.230 --> 30:15.670
这一个这一段

30:15.670 --> 30:17.110
基本上被什么占据了

30:17.110 --> 30:18.310
基本上是被那个

30:19.510 --> 30:20.550
黄色占据了

30:20.550 --> 30:21.270
对不对

30:21.270 --> 30:22.550
那么这个黄色是什么呢

30:22.550 --> 30:23.430
我们往下找

30:23.430 --> 30:24.310
它是不是一个土地

30:24.310 --> 30:25.830
它告诉你这个黄色是什么

30:25.830 --> 30:26.470
是script

30:27.670 --> 30:28.310
是这个东西

30:28.790 --> 30:29.510
script

30:29.510 --> 30:30.550
你什么意思

30:30.550 --> 30:31.910
是不是脚本执行的时间

30:32.390 --> 30:32.790
对不对

30:32.790 --> 30:34.230
那么你可以明显的看到

30:34.230 --> 30:35.830
第一次点这个按钮的时候

30:35.830 --> 30:37.030
脚本疯狂的执行

30:37.750 --> 30:39.350
就执行了一段很长的时间

30:40.150 --> 30:41.270
然后我们再看这一段

30:41.270 --> 30:42.630
脚本执行的时间是不是很短

30:43.350 --> 30:43.670
对不对

30:43.670 --> 30:44.470
为什么很短呢

30:44.470 --> 30:45.190
因为它没有

30:45.190 --> 30:45.990
它是冻解对象

30:45.990 --> 30:47.910
它不需要去便利每一个属性

30:47.910 --> 30:49.510
然后对它进行影响认识

30:49.510 --> 30:49.750
对吧

30:49.750 --> 30:51.190
这里我们可以从这个时间上

30:51.190 --> 30:52.390
也可以做明显的区分

30:53.110 --> 30:54.230
然后我们再可以

30:54.230 --> 30:55.430
可以从那个控制台里面看

30:57.270 --> 30:57.670
你看吧

30:57.750 --> 30:59.510
这是普通的对象

30:59.510 --> 31:00.310
我展开看一下

31:03.460 --> 31:05.060
所以每一个对象都变成了响认识

31:05.620 --> 31:06.020
对不对

31:06.020 --> 31:06.980
那么响认识的好处

31:06.980 --> 31:08.020
当然显而易见

31:08.020 --> 31:09.780
当然将来一去改它的时候

31:09.780 --> 31:11.380
是不是就能够触发

31:11.380 --> 31:12.980
我们的render重新选的

31:13.780 --> 31:14.740
这是普通对象

31:14.740 --> 31:16.340
然后我们再看FreezeData

31:16.340 --> 31:17.060
它印出来的

31:18.900 --> 31:19.940
是不是就是一个普通对象

31:19.940 --> 31:20.980
是不是不再是响认识

31:21.540 --> 31:21.860
对不对

31:21.860 --> 31:22.660
是一个普通对象

31:22.660 --> 31:23.700
这里边数组也好

31:23.700 --> 31:24.980
包括数组里边对象也好

31:24.980 --> 31:26.420
全都是普通对象

31:26.900 --> 31:27.620
没啥意思吧

31:28.340 --> 31:30.020
所以它就减少了

31:30.020 --> 31:31.540
就是循环便利的这个时间

31:32.260 --> 31:34.260
这是关于这个优化点

31:34.260 --> 31:35.140
使用动机对象

31:35.140 --> 31:35.940
这一块没问题的话

31:35.940 --> 31:36.260
没问题

31:36.260 --> 31:36.820
要丢个1

31:40.980 --> 31:41.220
好

31:41.220 --> 31:41.620
下一个

31:43.060 --> 31:43.940
函数式组件

31:46.060 --> 31:48.060
就有的时候又会出现这种情况

31:48.060 --> 31:48.380
就是

31:50.940 --> 31:51.500
比方说吧

31:51.500 --> 31:53.100
也要去做一个文章组件

31:54.460 --> 31:55.340
这一块我就不解释了

31:55.340 --> 31:56.140
因为它比较简单

31:57.020 --> 31:59.180
做一个文章详情组件

32:00.940 --> 32:03.260
你会发现这个文章详情组件

32:04.140 --> 32:05.420
做的东西还蛮多的

32:06.860 --> 32:09.100
可能文章标题那一块

32:09.100 --> 32:10.300
有些非常多的样式

32:10.300 --> 32:11.180
而一大堆样式

32:12.460 --> 32:14.700
可能还要去适应流量器的宽度

32:15.260 --> 32:15.740
比方说

32:16.620 --> 32:17.980
在电脑上是什么样子

32:17.980 --> 32:19.020
做一个响应式布局

32:19.020 --> 32:20.700
但是移动端又是什么样子

32:20.700 --> 32:22.140
可能要做很多的样式

32:22.140 --> 32:23.900
所以说你很有可能把这个文章

32:23.900 --> 32:26.940
详情组件可以把它细分为很多织组件

32:26.940 --> 32:28.140
比方说标题组件

32:29.820 --> 32:30.540
然后就是

32:32.060 --> 32:33.260
附加信息组件

32:34.220 --> 32:35.100
什么叫附加信息

32:35.100 --> 32:35.820
就表示作者

32:37.660 --> 32:38.700
文章的发布时间

32:38.700 --> 32:39.660
修改时间

32:39.660 --> 32:40.780
还有文章的来源

32:42.380 --> 32:43.900
这篇新闻的记者

32:44.860 --> 32:46.940
小编这些东西就是附加信息

32:46.940 --> 32:48.540
那么这些就单独做个组件

32:48.540 --> 32:51.100
然后证文内容做个组件

32:51.100 --> 32:52.940
然后目录做个组件

32:53.020 --> 32:55.980
然后还有就是文章的夜角做个组件

32:56.860 --> 32:59.580
然后就相关推荐做个组件

33:00.780 --> 33:02.860
你可能会做很多很多的组件出来

33:02.860 --> 33:04.220
但是你仔细观察

33:04.220 --> 33:04.780
你会发现

33:05.340 --> 33:06.220
这些组件

33:07.340 --> 33:08.780
他们基本上没有什么通用性

33:09.740 --> 33:11.420
他们都是只在文章详情里面

33:11.420 --> 33:12.540
用一下就完事了

33:12.540 --> 33:14.540
而且更加重要的是这些组件

33:16.380 --> 33:17.100
他们没有

33:17.740 --> 33:19.260
没有互操作性

33:19.980 --> 33:21.340
就是没有说什么

33:21.340 --> 33:22.700
用户鼠标移入过后

33:23.020 --> 33:23.660
做什么事情

33:24.220 --> 33:25.820
用户点击过后遇

33:25.820 --> 33:26.460
做什么事情

33:26.460 --> 33:27.820
没有什么可操作性

33:27.820 --> 33:28.860
最多有个A

33:28.860 --> 33:29.580
有个A元素

33:29.580 --> 33:30.300
一个超链接

33:31.020 --> 33:33.340
没有什么需要我们去监听的事件

33:33.340 --> 33:35.740
它只是把这些信息展示出来而已

33:36.620 --> 33:38.460
而且他们没有自己的状态

33:38.460 --> 33:39.900
比方说我这个组件里面

33:39.900 --> 33:42.300
就会把一个文章对象传给他

33:42.300 --> 33:42.940
传给他

33:42.940 --> 33:43.500
传给他

33:43.500 --> 33:45.420
你根据这个文章对象去显示就行了

33:45.980 --> 33:47.340
你没有什么自己的状态

33:47.340 --> 33:48.540
怎么叫没有自己的状态

33:48.540 --> 33:49.980
就是组件里面是没有data的

33:50.940 --> 33:52.140
是没有这个状态信息的

33:53.420 --> 33:55.100
而且我们再观察会发现

33:55.100 --> 33:57.740
这些组件是不需要生命周期函数的

33:58.300 --> 34:00.220
你说这些组件要什么生命周期函数吗

34:00.220 --> 34:01.260
根本就不需要

34:01.260 --> 34:03.100
对它只是做一些展示用的

34:04.140 --> 34:07.020
那么这里边会有什么样的性能问题呢

34:07.500 --> 34:08.620
到底会有什么样的性能问题呢

34:08.620 --> 34:11.420
如果说我们不把它细分为组件的话

34:11.980 --> 34:13.980
首先我们能不能不去细分

34:13.980 --> 34:15.100
不去细分可以

34:15.100 --> 34:16.620
但是你就会保持这个组件

34:16.620 --> 34:18.140
代码特别特别多

34:18.140 --> 34:19.260
不好维护

34:19.260 --> 34:21.180
就从代码可维护性的角度来讲

34:21.180 --> 34:22.300
我们应该把它细分

34:22.780 --> 34:24.140
但是一旦细分过后了

34:24.140 --> 34:25.980
你会发现我莫名其妙的

34:25.980 --> 34:27.420
我就要显示一篇文章

34:27.420 --> 34:28.940
结果我要创建一大堆组件

34:30.060 --> 34:30.300
你们

34:31.580 --> 34:32.940
朋友们都知道啊

34:32.940 --> 34:35.340
组件最终会生成什么

34:35.340 --> 34:36.780
就是组件实力啊

34:36.780 --> 34:37.980
每一个组件

34:37.980 --> 34:40.140
它都相当于最终会雕用一个粒5U

34:40.860 --> 34:42.940
结果它能够到喊说名字不叫粒5U

34:43.580 --> 34:45.260
我们就可以认为它是雕用一个粒5U

34:45.820 --> 34:47.580
所以会生成很多的组件对象

34:48.220 --> 34:49.900
那么每一个组件对象

34:50.940 --> 34:52.460
是不是有很多很多的属性啊

34:52.860 --> 34:54.860
这些属性对他们来说有意义吗

34:54.860 --> 34:55.740
没有意义

34:55.740 --> 34:58.220
他们仅仅是做存信息展示的

34:58.220 --> 34:59.580
实际上是没有意义

34:59.580 --> 35:02.380
那么在创建这些组件对象的时候

35:02.380 --> 35:05.820
它实际上会消耗很多的内存空间

35:07.100 --> 35:07.980
一是消耗时间

35:07.980 --> 35:09.020
二是消耗内存空间

35:09.900 --> 35:11.660
实际上我们对这些组件而言

35:11.660 --> 35:12.860
这些组件对我们而言

35:12.860 --> 35:14.700
我们只需要用到它显示的东西有

35:15.820 --> 35:17.020
那么这个时候呢

35:17.020 --> 35:17.340
其实

35:18.620 --> 35:19.980
我这里好像有这个例子

35:19.980 --> 35:21.340
使用函数点以后我们可以看一下

35:22.700 --> 35:23.980
那么就可以使用函数组件

35:24.940 --> 35:26.140
那么什么叫函数组件呢

35:26.140 --> 35:27.820
这里一个官方链接啊

35:27.820 --> 35:29.020
其实非常简单

35:29.020 --> 35:30.620
你只需要把组件

35:30.620 --> 35:31.660
就组件配置里面

35:31.660 --> 35:33.260
你只需要做一件事

35:33.260 --> 35:34.860
给它配置一个叫方形容

35:34.860 --> 35:36.380
把它设为q就可以了

35:36.380 --> 35:38.140
那么它就变成一个函数组件了

35:38.140 --> 35:40.380
函数组件有什么样的特点呢

35:40.380 --> 35:42.380
函数组件没有生命周期函数

35:43.100 --> 35:43.900
它不能有

35:43.900 --> 35:45.260
它就不能有生命周期函数

35:46.140 --> 35:48.060
不能有那个data

35:48.060 --> 35:48.940
就这个东西不能有

35:49.900 --> 35:51.580
然后生命周期函数不能有

35:52.940 --> 35:53.420
life

35:54.540 --> 35:55.020
cycle

35:56.970 --> 35:57.770
这个东西是不能有

35:57.770 --> 35:58.650
这两个东西都不能有

35:59.290 --> 36:00.730
因为它自己没有状态

36:00.730 --> 36:01.610
那么函数组件

36:01.610 --> 36:02.810
它的目的就一个

36:02.810 --> 36:04.170
它就是邦尼生成虚的动物

36:05.610 --> 36:06.650
然后这个虚的动物呢

36:06.650 --> 36:08.490
直接就扔给副组件了

36:08.490 --> 36:09.290
就是函数组件

36:09.290 --> 36:10.090
对于副组件而言

36:10.090 --> 36:11.610
就好像是不存在一样

36:11.610 --> 36:12.330
啊一块脑袭

36:12.330 --> 36:13.450
我们可以看一下啊

36:13.450 --> 36:14.810
可以看一下这个情况

36:14.810 --> 36:16.330
那么接下来我们来看一下吧

36:16.330 --> 36:16.810
这里呢

36:16.810 --> 36:17.450
我有个例子啊

36:17.450 --> 36:18.330
使用函数组件

36:19.370 --> 36:20.010
这边看

36:20.010 --> 36:21.290
我这里写了两个组件

36:21.290 --> 36:22.330
一个是普通组件

36:24.010 --> 36:25.610
这个普通组件非常简单

36:25.610 --> 36:27.210
啊就是有一个属相

36:27.210 --> 36:28.410
你给我传一个靠着进来

36:28.410 --> 36:30.490
我把它显示出来就完事了啊

36:30.490 --> 36:31.210
告诉他啊

36:31.210 --> 36:32.490
生成的A型一元数

36:32.490 --> 36:33.690
我这是一个普通组件

36:33.690 --> 36:34.810
我显示一个数字

36:34.810 --> 36:35.210
cont

36:36.170 --> 36:36.970
你说这个组件

36:36.970 --> 36:38.170
它有自己的状态吗

36:38.170 --> 36:38.890
没有状态

36:38.890 --> 36:39.930
它有生命周期函数吗

36:39.930 --> 36:40.250
没有

36:40.250 --> 36:41.290
它做存暂式的

36:42.090 --> 36:44.010
将来你们在开发的过程中啊

36:44.010 --> 36:46.010
你发现这种类型的组件呢

36:46.010 --> 36:47.450
其实你可以考虑啊

36:47.450 --> 36:49.370
可以考虑把它变成函数组件

36:50.010 --> 36:51.370
好接下来我们来看下面这个

36:51.370 --> 36:52.090
另外一个组件

36:52.810 --> 36:53.610
一模一样的

36:54.090 --> 36:55.210
还是给我传一个probs

36:56.250 --> 36:57.450
给我传个数据

36:57.450 --> 36:57.850
然后呢

36:57.850 --> 36:59.290
我把它设置为函数组件

36:59.290 --> 37:00.170
当形容得于处

37:01.210 --> 37:02.410
我把它显示出来

37:02.410 --> 37:02.890
注意哦

37:02.890 --> 37:04.490
在函数组件显示的时候

37:04.490 --> 37:06.410
这里不能直接使用cult啊

37:06.410 --> 37:08.010
必须要写上一个显税啊

37:08.010 --> 37:09.130
叫probs

37:09.130 --> 37:10.650
从属性里边读取它

37:12.330 --> 37:13.370
那这就是函数组件

37:14.250 --> 37:15.930
然后以后我们可以看它的区别啊

37:15.930 --> 37:16.570
然后现在呢

37:16.570 --> 37:18.010
我们把它组装起来啊

37:18.010 --> 37:19.930
通过这个组件把它组装起来app

37:19.930 --> 37:20.730
来看一下这个代码

37:22.330 --> 37:23.610
我这里注册两个组件啊

37:23.610 --> 37:24.410
一个是普通组件

37:24.410 --> 37:25.530
一个是函数组件

37:25.530 --> 37:26.890
然后这里我有两个数据

37:26.890 --> 37:28.250
一个是函数组件的数量

37:28.890 --> 37:32.090
一个是普通组件的数量

37:33.610 --> 37:34.010
这里呢

37:34.010 --> 37:35.290
我把z

37:35.290 --> 37:36.170
在multi的时候呢

37:36.170 --> 37:37.850
我把z是复制为给温斗一个

37:38.410 --> 37:40.250
给温斗的一个便量

37:40.250 --> 37:41.530
这样子方便我们调试

37:41.530 --> 37:43.130
以后我在浏览器里边通过它

37:43.130 --> 37:44.570
是不是可以拿到当前这个app

37:44.570 --> 37:45.530
组件的实力的

37:45.530 --> 37:45.770
对不对

37:45.770 --> 37:47.050
以后我们就可以看得很清楚了

37:47.930 --> 37:48.250
好

37:48.250 --> 37:49.530
接下来我会做什么事呢

37:50.090 --> 37:50.570
你看啊

37:51.130 --> 37:52.330
我这里有个container

37:52.330 --> 37:52.890
一个容器

37:54.570 --> 37:55.850
我这个容器写了一些样式

37:55.850 --> 37:56.490
这个样式呢

37:56.490 --> 37:57.210
不用管它啊

37:57.210 --> 37:58.970
就是简单的

37:58.970 --> 37:59.930
简单的写了一下样式

38:00.650 --> 38:01.050
然后呢

38:01.050 --> 38:02.730
我这里会循环这么多次

38:03.450 --> 38:04.410
我目前是零嘛

38:04.410 --> 38:05.370
那就循环零次

38:06.810 --> 38:07.770
在这儿啊

38:07.770 --> 38:08.970
目前是零对吧

38:08.970 --> 38:09.850
那我就循环零次

38:10.410 --> 38:10.890
那一会呢

38:10.890 --> 38:12.010
这个数据会变化对吧

38:12.010 --> 38:13.370
那一会我会把它变成一个

38:13.370 --> 38:14.010
非常大的值

38:14.010 --> 38:15.850
你看我点击这个按钮的时候

38:15.850 --> 38:17.690
我这里就是把它复制为1万

38:18.410 --> 38:19.210
点这个按钮的时候

38:19.210 --> 38:20.410
我就会把它复制为1万

38:21.770 --> 38:22.730
还没

38:22.810 --> 38:23.130
然后呢

38:23.130 --> 38:24.490
我这里就循环这么多次

38:24.490 --> 38:25.930
每一循环一次呢

38:25.930 --> 38:27.450
我生成一个normal comp

38:27.450 --> 38:29.050
就是生成一个普通组件

38:30.650 --> 38:31.050
然后呢

38:31.050 --> 38:32.090
给他一个属性嘛

38:32.090 --> 38:32.970
给他一个cont

38:32.970 --> 38:34.330
cont就是复制为n

38:36.170 --> 38:37.450
知道这种格式吧

38:37.450 --> 38:38.650
这里可以写数字的啊

38:39.210 --> 38:41.450
那么这里n就从1到1万啊

38:41.450 --> 38:43.130
不是从0到9999

38:43.130 --> 38:44.330
是从1到1万

38:45.610 --> 38:46.090
另外呢

38:46.090 --> 38:46.890
这边也是一样的

38:46.890 --> 38:47.610
一模一样的

38:47.610 --> 38:49.370
无非就是把组件换成了函数组件

38:49.370 --> 38:49.690
你看

38:49.690 --> 38:51.130
所以我写法完全一样的

38:51.210 --> 38:52.890
v4 key count

38:53.770 --> 38:54.730
好这样我们再看一下

38:59.590 --> 39:00.630
我怎么又回到这个页面了

39:01.510 --> 39:01.990
停止啊

39:03.990 --> 39:04.310
二

39:05.590 --> 39:06.630
np的装饰

39:14.700 --> 39:15.820
好运行出来看一下啊

39:18.760 --> 39:21.160
我们先生成1万个普通组件

39:21.880 --> 39:22.280
点击

39:22.840 --> 39:23.480
真的出来了

39:23.480 --> 39:25.000
再生成1万个函数组件

39:26.280 --> 39:28.120
好像没有明显的区别对吧

39:28.120 --> 39:29.400
以后我们再看啊

39:29.480 --> 39:31.000
好接下来我们来看一下检查

39:31.720 --> 39:33.160
看一下这个控制台啊

39:33.160 --> 39:35.320
我们先生成1万个普通组件

39:36.040 --> 39:38.040
再生成1万个函数组件

39:38.040 --> 39:39.240
效果是一模一样的

39:39.240 --> 39:40.840
效果都是完全一样的

39:40.840 --> 39:42.600
然后接下来我们来看一下这个vm

39:42.600 --> 39:43.880
就当前组件实力

39:45.400 --> 39:47.000
就是当前这个ip组件的实力

39:47.000 --> 39:48.040
就是它的实力

39:48.040 --> 39:49.640
它的实力里面是不是有个v漏的呀

39:50.760 --> 39:51.560
对我们之前学过的

39:51.560 --> 39:51.800
对吧

39:51.800 --> 39:53.240
v漏的就是虚的节点

39:53.240 --> 39:54.440
我们来看一下他们的区别

39:55.560 --> 39:57.800
呃7o准里面有什么button bottom div

39:57.800 --> 39:59.240
就相当于对应这啊

39:59.240 --> 40:00.520
button bottom div

40:00.520 --> 40:01.800
好这个div展开

40:02.520 --> 40:03.640
还有两个节点啊

40:03.640 --> 40:04.920
一个是第一个div

40:04.920 --> 40:05.880
第一个div是不是他

40:06.840 --> 40:07.960
对对是他

40:07.960 --> 40:09.400
好我们把他展开

40:09.400 --> 40:10.200
他里面是啥

40:10.200 --> 40:11.160
是个普通组件

40:12.280 --> 40:14.040
普通组件我们展开看是啥

40:14.040 --> 40:14.680
什么格式啊

40:15.720 --> 40:16.840
展开1万个

40:17.880 --> 40:19.160
每一个组件是什么格式呢

40:19.160 --> 40:20.680
你会发现每一个组件呢

40:20.680 --> 40:22.360
是一个组件的虚的节点

40:23.320 --> 40:24.600
而组件的虚的节点

40:24.600 --> 40:26.360
是不是会挂在一个组件实力

40:26.360 --> 40:27.320
这个组件实力在哪呢

40:27.320 --> 40:28.760
在component instance里边

40:29.400 --> 40:31.000
这就是每一个虚的节点

40:31.000 --> 40:33.160
就是比方第一个这个虚的节点

40:33.160 --> 40:34.600
他就会挂在一个组件实力

40:34.600 --> 40:36.360
看看就component instance里边

40:38.200 --> 40:39.280
就咱们后期

40:39.280 --> 40:40.680
互费客里边有几个叫

40:41.400 --> 40:43.960
呃组件数里边的完整生命周期啊

40:43.960 --> 40:45.160
里边就会讲到这个属性

40:46.840 --> 40:48.840
那这个这个就是我们组件的实力

40:48.840 --> 40:51.320
那么这个实力就是通过656创建出来的

40:51.320 --> 40:52.840
就是我们刚刚刚给大家看的

40:52.840 --> 40:54.520
什么通过这个656创建出来的

40:55.480 --> 40:55.800
啊

40:56.520 --> 40:57.560
你看这里边

40:57.640 --> 41:00.040
那么你说这个节点下边是没有节点的

41:00.600 --> 41:02.280
这个下这个节点下边还有节点吗

41:02.280 --> 41:03.000
还有切维剧吗

41:03.000 --> 41:03.400
没有了

41:04.040 --> 41:05.080
还有说那不对啊

41:05.080 --> 41:06.600
里边不是还有个A7E吗

41:06.600 --> 41:07.240
不是的

41:07.240 --> 41:09.160
A7E是在这个组件里边

41:09.160 --> 41:11.320
这个组件实力里边的被漏的里边

41:12.280 --> 41:12.440
啊

41:12.440 --> 41:13.960
它是这么一个解斗

41:13.960 --> 41:15.480
所以说我们普通组件的话

41:16.200 --> 41:17.480
对于if组件而言

41:17.480 --> 41:19.000
记录到这个组件就ok了

41:19.000 --> 41:19.960
那么这个组件里边

41:19.960 --> 41:21.720
哪怕你有一万个元素不记录了

41:22.520 --> 41:23.880
那么这里边的元素

41:23.880 --> 41:25.400
交给这个组件实力去记住

41:26.280 --> 41:26.760
没了意思吧

41:26.760 --> 41:28.040
就形成了这么一个组件数啊

41:28.920 --> 41:29.080
好

41:29.080 --> 41:30.520
这就是普通组件

41:30.520 --> 41:32.600
然后接下来我们再看一下函数组件

41:34.760 --> 41:35.960
刚才是普通组件对吧

41:35.960 --> 41:37.080
先让我们看函数组件啊

41:37.080 --> 41:38.040
第二个DIV

41:38.040 --> 41:39.400
第二个DIV我们看它的切维剧

41:40.600 --> 41:42.040
看到发现什么区别没有

41:42.600 --> 41:44.120
切维剧是不是直接是A7E

41:45.240 --> 41:46.360
直接就是这个A7E了

41:46.360 --> 41:47.720
也就是说它少了一个什么

41:47.720 --> 41:48.840
少了一个组件实力

41:48.840 --> 41:51.320
组件组件直接就被穿透了

41:51.320 --> 41:53.640
就是这个组件好像就根本就没有到界面上了

41:53.640 --> 41:55.000
好像根本就没有到界面上

41:55.080 --> 41:57.240
它直接就把这个A7E交给它的副组件

41:57.640 --> 41:58.280
IPE组件了

41:58.840 --> 41:59.400
没了意思吧

42:00.680 --> 42:02.920
它就这个组件本身它不生成任何东西

42:02.920 --> 42:05.400
它只是帮你生成虚拟动物元素

42:05.880 --> 42:06.920
你看这里边还有什么

42:06.920 --> 42:08.120
component instance吗

42:08.120 --> 42:08.600
是不是没有

42:09.560 --> 42:10.120
能理解吧

42:10.120 --> 42:11.400
大家这一块能听懂吗

42:11.400 --> 42:11.640
这一块

42:15.980 --> 42:17.180
就是函数组件啊

42:17.180 --> 42:18.620
它根本就不生成组件实力

42:19.260 --> 42:20.220
它就是来帮你

42:21.260 --> 42:22.620
说了再直一点

42:22.620 --> 42:24.140
函数组件它就过一亿个功能

42:24.140 --> 42:25.100
就是帮你生成这个模板

42:26.140 --> 42:27.020
你给它一个属性

42:27.020 --> 42:27.900
它通过这个属性

42:27.980 --> 42:28.780
给你生成一个模板

42:29.500 --> 42:30.620
然后你把这个模板

42:30.620 --> 42:31.820
就直接交给副组件了

42:32.940 --> 42:34.380
它就做这么一件事

42:34.380 --> 42:35.660
这就是函数组件的特点

42:36.220 --> 42:36.860
那么我们来看一下

42:36.860 --> 42:38.300
它的性能真的是有差异吗

42:38.300 --> 42:39.900
我们到Performance来看一下

42:39.900 --> 42:42.940
你会发现它的时间其实都差不多

42:42.940 --> 42:43.260
对吧

42:43.260 --> 42:44.700
然后我们来记录一下

42:44.700 --> 42:45.260
刷新

42:46.300 --> 42:47.100
点击开始

42:47.660 --> 42:48.700
生成一千个

42:48.700 --> 42:49.580
一万个普通组件

42:49.580 --> 42:51.260
再生成一万个函数组件

42:51.260 --> 42:51.580
停止

42:53.180 --> 42:54.060
时间上的差异

42:54.060 --> 42:55.340
有没有差异的有差异

42:55.340 --> 42:55.900
差异不大

42:56.620 --> 42:57.420
大家看一下

42:57.660 --> 42:58.220
这个时间

42:59.180 --> 43:00.220
大家看到这个时间

43:01.260 --> 43:02.300
里边除了黄色

43:02.300 --> 43:03.580
就是介石之外

43:03.580 --> 43:05.340
还有一个纸色

43:05.340 --> 43:05.580
对吧

43:05.580 --> 43:06.220
一个纸色是什么

43:06.220 --> 43:06.940
叫Rendery

43:08.060 --> 43:08.780
什么叫Rendery

43:09.420 --> 43:10.060
就是浏览器

43:10.700 --> 43:11.660
在布局

43:12.620 --> 43:14.620
这些元素生成真实动物

43:14.620 --> 43:16.060
是不是都会导致浏览器布局

43:16.060 --> 43:16.460
对吧

43:16.460 --> 43:17.900
因为这里的元素比较多

43:17.900 --> 43:18.780
有一万个元素

43:18.780 --> 43:19.420
很多元素

43:19.420 --> 43:20.460
所以浏览器布局

43:20.460 --> 43:21.100
需要一万个时间

43:21.580 --> 43:22.460
叫Rendery

43:22.460 --> 43:23.340
这个Rendery什么意思

43:23.340 --> 43:25.020
就是生成动物数

43:25.020 --> 43:26.860
生成那个央视数

43:26.860 --> 43:27.740
生成渲染数

43:27.740 --> 43:28.300
就这个东西

43:28.300 --> 43:29.340
就这段时间

43:29.340 --> 43:30.140
你会发现这段时间

43:30.140 --> 43:30.700
都差不多

43:31.820 --> 43:32.780
有的时候这边多一点

43:32.780 --> 43:33.900
有的时候这边少一点

43:33.900 --> 43:34.540
都差不多

43:34.540 --> 43:36.220
但是介石的执行时间

43:36.220 --> 43:37.580
明显这边要少一些

43:37.580 --> 43:37.980
对吧

43:37.980 --> 43:38.780
这边的介石

43:38.780 --> 43:39.820
黄色的指标多一些

43:39.820 --> 43:40.540
这边要少一些

43:41.420 --> 43:43.820
然后我们再看内存的占用

43:43.820 --> 43:44.780
你看内存的占用

43:44.780 --> 43:46.540
下面蓝色的波浪线

43:46.540 --> 43:47.500
就内存的占用

43:47.500 --> 43:48.380
因为看到一开始

43:48.380 --> 43:49.580
内存在这么一条线

43:49.980 --> 43:50.300
看到没

43:51.340 --> 43:52.780
一开始内存是不是在这么一条线

43:54.140 --> 43:54.780
然后到这

43:55.740 --> 43:57.500
所以斗然增加

43:57.500 --> 43:58.220
增加到这了

43:58.220 --> 43:59.180
对不对

43:59.180 --> 44:00.220
说内存占用很多

44:00.220 --> 44:01.340
然后到这边

44:01.340 --> 44:02.860
内存占用增加了

44:02.860 --> 44:03.420
是不是不多

44:03.420 --> 44:04.860
增加了比较平均换一点

44:04.860 --> 44:05.980
看到没

44:05.980 --> 44:09.500
内存占用的也是韩束祖先占用

44:09.500 --> 44:12.220
这是关于这个韩束祖先

44:12.220 --> 44:13.740
它确实能够

44:13.740 --> 44:15.500
减上我们内存的占用

44:15.500 --> 44:16.620
已经提高

44:16.620 --> 44:18.620
就是缩减一点点时间

44:18.620 --> 44:19.340
执行时间

44:19.340 --> 44:23.260
好

44:23.260 --> 44:23.900
这一块看来

44:23.900 --> 44:24.540
有没有什么问题

44:24.540 --> 44:25.180
听懂了

44:25.180 --> 44:25.740
QE

44:26.700 --> 44:27.740
没什么问题

44:27.740 --> 44:28.940
等会我们继续继续了

44:28.940 --> 44:29.500
有问题的话

44:29.500 --> 44:30.380
直接把问题打出来

44:32.380 --> 44:32.620
好

44:32.620 --> 44:33.100
下一个

44:33.100 --> 44:33.740
计算属性

44:35.420 --> 44:35.980
计算属性

44:35.980 --> 44:36.620
我没法展开讲

44:37.980 --> 44:38.860
我只能说

44:38.860 --> 44:40.300
用一个最简单的讲法

44:40.300 --> 44:41.100
就是计算属性

44:41.100 --> 44:42.220
你们都是学过的

44:42.220 --> 44:42.780
5U里边

44:42.780 --> 44:43.500
基础里边都有

44:44.380 --> 44:44.700
实际上

44:44.700 --> 44:45.580
计算属性那一块

44:45.580 --> 44:46.540
也是特别容易充电

44:46.540 --> 44:46.940
是急的

44:46.940 --> 44:47.820
就问你计算属性

44:47.820 --> 44:48.780
跟方法有什么区别

44:49.820 --> 44:50.220
就是你如果说

44:50.220 --> 44:51.260
你只是回答说

44:51.260 --> 44:52.380
计算属性有缓存

44:52.380 --> 44:53.340
方法没有缓存

44:53.900 --> 44:56.300
直接比较显而易见的区别的话

44:56.300 --> 44:57.340
倒不是说错

44:57.340 --> 44:58.220
错肯定是没有错

44:58.220 --> 44:59.580
只是拿出了高分

44:59.580 --> 45:00.300
那么

45:00.300 --> 45:01.020
要应该尽量

45:01.020 --> 45:02.620
从原理上去偷袭它

45:02.620 --> 45:03.660
其实计算属性跟我们的

45:03.660 --> 45:04.460
watcher

45:04.460 --> 45:05.260
你们之前去过那个

45:05.260 --> 45:06.460
watcher是密切相关的

45:07.900 --> 45:09.100
这里不展开说了

45:09.100 --> 45:10.060
那么我们只说

45:10.060 --> 45:11.340
计算属性对我们的

45:11.340 --> 45:12.380
优化有什么影响

45:12.940 --> 45:14.620
就是我们这里很容易想到

45:14.620 --> 45:16.700
因为计算属性是有缓存的

45:16.700 --> 45:18.140
所以我们应该尽量的使用

45:18.140 --> 45:19.100
就是说如果说

45:19.100 --> 45:20.860
有些数据是通过计算得到的

45:20.860 --> 45:21.260
那么这个

45:22.220 --> 45:23.580
我们应该尽量的使用

45:23.580 --> 45:25.260
计算属性去缓存它

45:26.700 --> 45:27.420
举个例子吧

45:27.420 --> 45:29.180
你们都开发过那个

45:29.180 --> 45:29.740
配件组建

45:29.740 --> 45:30.300
这个配件组建

45:30.300 --> 45:31.420
就是一个典型的例子

45:31.420 --> 45:32.300
就是分业组建

45:33.180 --> 45:34.780
分业组建里面属性有哪些

45:35.420 --> 45:36.060
有哪些属性

45:36.060 --> 45:36.540
一般来说

45:36.540 --> 45:38.140
分业组建都会传这么几个属性

45:38.700 --> 45:39.420
当前页嘛

45:40.860 --> 45:41.580
当前页嘛

45:45.740 --> 45:46.220
总数

45:46.220 --> 45:47.580
总记录书

45:49.660 --> 45:50.540
什么叫总记录书

45:51.740 --> 45:52.780
就是我们页面上

45:54.460 --> 45:55.580
一共有多少条数据

45:55.580 --> 45:57.180
比方说你要显示文章

45:57.820 --> 45:58.780
那一共有多少文章呢

45:58.780 --> 46:00.140
可能一共有一百万条

46:00.140 --> 46:01.820
但是我这一次给不了你那么多

46:01.820 --> 46:02.540
只给你一些

46:03.020 --> 46:04.060
就是总记录书

46:04.540 --> 46:05.740
一百万就是总记录书

46:06.540 --> 46:07.340
当前第几页

46:07.340 --> 46:08.300
当前第一页第二页

46:09.180 --> 46:09.580
然后呢

46:09.580 --> 46:10.780
还有一个就是配件组建

46:11.740 --> 46:12.540
这个东西叫什么呢

46:12.540 --> 46:13.260
叫做

46:13.260 --> 46:14.780
有的时候也把它叫做nimus

46:14.780 --> 46:15.660
就是一个意思

46:16.620 --> 46:17.500
叫做页容量

46:18.700 --> 46:19.420
什么叫页容量

46:19.420 --> 46:20.780
就是每页显示多少条

46:21.660 --> 46:23.820
显示多少条数据

46:24.780 --> 46:26.540
然后它基本上属性的话

46:26.540 --> 46:27.420
就给你这么一些

46:27.420 --> 46:28.620
给你这么一些属性就OK了

46:29.500 --> 46:30.540
那么你要算的东西

46:30.540 --> 46:31.740
是不是特别特别多

46:31.740 --> 46:32.860
你要算什么呢

46:32.860 --> 46:33.420
你要算

46:35.260 --> 46:36.060
总页数

46:36.060 --> 46:36.860
得算吧

46:36.860 --> 46:37.820
除了算总页数

46:39.100 --> 46:40.220
总页数怎么怎么算

46:40.220 --> 46:40.940
你们自己去想

46:41.740 --> 46:42.540
好像我之前

46:43.980 --> 46:45.980
工业课里边好像没有讲分页数捷

46:46.860 --> 46:47.580
总页数怎么算

46:47.580 --> 46:48.460
就是总记录书

46:48.460 --> 46:49.500
厨艺页容量对吧

46:49.500 --> 46:50.940
一共有一百条数据

46:51.020 --> 46:51.980
你每页显示10条

46:51.980 --> 46:52.940
不就是10页吗

46:52.940 --> 46:54.380
就是它处于它

46:54.380 --> 46:55.660
那么像这个总页数

46:55.660 --> 46:58.140
就非常适合用计算属性

46:58.140 --> 46:58.540
为什么呢

46:58.540 --> 46:59.660
如果说你把它写成方法

47:01.420 --> 47:02.300
把它写成方法的话

47:02.300 --> 47:03.020
比方说s

47:03.580 --> 47:04.300
配级number

47:05.500 --> 47:06.700
里边单码都一样

47:06.700 --> 47:08.700
就是return this total

47:10.220 --> 47:12.060
除以s配级30

47:12.060 --> 47:13.660
当然你还要考一个小数问题啊

47:13.660 --> 47:15.020
我这里难得说了

47:16.460 --> 47:17.100
还有一种做法

47:17.100 --> 47:17.900
就是把它写成

47:17.900 --> 47:19.020
写成那个计算属性

47:19.900 --> 47:20.540
配级number

47:21.500 --> 47:22.540
包里是一样的

47:22.540 --> 47:24.060
它也是个函数

47:25.340 --> 47:25.980
那么这里呢

47:25.980 --> 47:27.500
我们如果说两者选择之

47:27.500 --> 47:28.380
两者之间选择的话

47:28.380 --> 47:30.140
我们一定是把它作为计算属性

47:30.140 --> 47:30.460
为什么呢

47:30.460 --> 47:31.500
因为我们页面上

47:31.500 --> 47:32.300
可能很多地方

47:32.300 --> 47:33.500
这个分页组件里边

47:33.500 --> 47:34.620
都要显示这个总页数

47:35.500 --> 47:36.300
有可能要显示

47:36.300 --> 47:37.340
有可能要用到它

47:37.340 --> 47:38.460
如果说你使用方法的话

47:38.460 --> 47:39.580
你每一次交用方法

47:39.580 --> 47:41.260
它都会重新运行这个代码

47:41.260 --> 47:42.540
都会重新去计算一遍

47:43.340 --> 47:45.020
那如果说你使用计算属性的话

47:45.020 --> 47:46.220
它只计算一遍

47:46.220 --> 47:47.420
只要这个只没变

47:47.420 --> 47:48.540
只要这个只没变

47:48.540 --> 47:50.380
那么我返回的结果就不会变

47:50.540 --> 47:52.380
你无论用多少次都可以

47:52.380 --> 47:52.940
这个玩意儿

47:52.940 --> 47:53.420
计算属性

47:53.420 --> 47:54.940
我相信只要你学过5U

47:54.940 --> 47:55.980
你一定

47:55.980 --> 47:57.100
无论你学的多么基础

47:57.100 --> 48:00.570
那计算属性你一定是学过的

48:00.570 --> 48:01.850
我问一下了

48:01.850 --> 48:02.730
有没有学过5U

48:02.730 --> 48:03.130
没有

48:03.130 --> 48:04.250
有没有学过5U

48:04.250 --> 48:08.520
没有学过计算属性的

48:08.520 --> 48:10.040
应该没有吧

48:10.040 --> 48:10.440
应该没有

48:10.440 --> 48:11.560
你只要学

48:11.560 --> 48:12.200
还真有吗

48:13.880 --> 48:15.080
应该没有吧

48:15.080 --> 48:16.520
你别骗我

48:16.520 --> 48:17.800
你只要学过5U

48:17.800 --> 48:18.840
哪怕你学的在一起的时候

48:18.840 --> 48:20.360
都会接触到计算属性的

48:22.550 --> 48:23.750
那如果说你没有学过的话

48:24.710 --> 48:26.310
你一定是故意的

48:26.310 --> 48:28.390
肯定是学过计算属性的

48:28.390 --> 48:29.910
看过文道也算吗

48:29.910 --> 48:31.750
你只要知道这个计算属性是有缓存的

48:31.750 --> 48:32.470
就OK

48:32.470 --> 48:34.470
那么这里我就说这么一个点

48:34.470 --> 48:36.790
就是根据

48:36.790 --> 48:38.550
如果说你是根据一用数据

48:38.550 --> 48:39.990
来得到东西的话

48:39.990 --> 48:41.430
那么尽量使用计算属性

48:41.430 --> 48:42.710
但是有的时候你没办法

48:42.710 --> 48:45.030
比方说你这里边要传残属

48:45.030 --> 48:46.790
有些东西要传残属的

48:46.790 --> 48:48.310
那你就没办法

48:48.310 --> 48:49.990
比方说我有一个东西

48:49.990 --> 48:51.510
我需要根据

48:51.510 --> 48:52.710
当前的时间戳

48:52.710 --> 48:54.950
来得到一个日期的

48:54.950 --> 48:56.310
一个正常的日期格式

48:57.590 --> 48:58.710
那比方说我们形成方法的话

48:58.710 --> 48:59.510
应该是这样子写的

49:00.390 --> 49:01.910
get 10

49:01.910 --> 49:02.390
有方法

49:02.390 --> 49:03.510
你给我一个时间戳

49:03.510 --> 49:04.710
ten stand

49:04.710 --> 49:06.470
那么我肯定给你返回一个

49:06.470 --> 49:07.990
一个本地的日期格式

49:07.990 --> 49:08.870
我可能就这样写

49:08.870 --> 49:09.910
new days 10

49:09.910 --> 49:10.550
写简单一点

49:11.510 --> 49:13.270
to local stream

49:14.710 --> 49:17.270
to local days stream

49:19.610 --> 49:20.490
那么像这种东西

49:20.490 --> 49:21.530
就没发出计算属性了

49:21.530 --> 49:22.330
因为计算属性

49:22.330 --> 49:23.450
里边是不能有参数的

49:24.570 --> 49:26.250
像这种东西只能用方法

49:26.250 --> 49:28.090
或者是fuelter

49:28.090 --> 49:29.130
或者是郭律器

49:29.130 --> 49:29.530
郭律器

49:29.530 --> 49:30.330
你们以后学到

49:30.330 --> 49:31.290
进阶的部分以后学习

49:32.490 --> 49:33.450
这就是计算属性

49:33.450 --> 49:34.410
就说一下就OK了

49:35.210 --> 49:35.610
下一个

49:38.280 --> 49:39.800
非实施绑定的表现象

49:40.520 --> 49:41.080
这是啥意思呢

49:42.600 --> 49:43.480
这个玩意见过吧

49:46.120 --> 49:47.080
那我又问大家

49:47.080 --> 49:47.720
不要骗我

49:47.720 --> 49:48.520
你们不要骗我

49:48.520 --> 49:49.400
骗我为什么意思呢

49:50.120 --> 49:51.000
你不要欺负我

49:52.040 --> 49:52.520
学过

49:52.520 --> 49:54.040
我又没有学过这个统

49:54.120 --> 49:55.400
这个东西的同学

49:55.400 --> 49:55.880
出个译

49:58.420 --> 49:58.900
没有学过

49:58.900 --> 49:59.780
我就简单说一下

50:02.710 --> 50:04.390
那我就简单说一下吧

50:04.390 --> 50:05.750
这个vmode是什么意思呢

50:05.750 --> 50:08.150
还表示双向绑定的意思

50:08.150 --> 50:09.110
在伍佑里边

50:09.110 --> 50:10.710
一般用来表达元素里边

50:10.710 --> 50:11.270
比方说你

50:12.070 --> 50:12.790
有一个input

50:13.350 --> 50:14.630
有一个表达元素

50:14.630 --> 50:15.430
这个input呢

50:16.390 --> 50:18.470
我希望绑定一个数据

50:18.470 --> 50:19.590
我就简单写一下吧

50:19.590 --> 50:20.310
非常简单啊

50:23.450 --> 50:24.730
我就在这个demo里边

50:24.730 --> 50:25.290
我写一下吧

50:31.880 --> 50:33.080
比方说这个这个组件

50:33.080 --> 50:34.520
我这边就写个input元素

50:37.370 --> 50:37.930
input元素

50:37.930 --> 50:38.490
然后这里呢

50:38.490 --> 50:39.370
准备好一个data

50:40.650 --> 50:41.770
我返回一个东西

50:41.770 --> 50:43.210
比方说我就返回一个title吧

50:44.090 --> 50:45.370
title默认是一个空称创

50:45.370 --> 50:46.650
或者是默认是halo5u嘛

50:47.850 --> 50:48.090
好

50:48.090 --> 50:48.410
接下来呢

50:48.410 --> 50:49.210
我把这个title呢

50:49.210 --> 50:50.650
就通过这个vmode

50:50.650 --> 50:52.570
绑定到input里边

50:52.570 --> 50:53.450
我简单讲一下啊

50:54.330 --> 50:54.890
这里边

50:55.370 --> 50:56.010
这个vmode

50:56.010 --> 50:56.970
其实可以聊的东西

50:56.970 --> 50:57.610
还是蛮多的

50:58.330 --> 50:59.210
这个网项里边可以

51:00.170 --> 51:01.450
我们要深入到原地的话

51:01.450 --> 51:02.410
里边还是有些东西

51:02.410 --> 51:03.610
它跟那个虚地动物有关系

51:05.530 --> 51:05.770
好

51:05.850 --> 51:06.170
然后呢

51:06.170 --> 51:06.810
我这个a11

51:06.810 --> 51:08.810
到就显示这个title

51:09.930 --> 51:10.890
那么这样子写

51:10.890 --> 51:11.050
好

51:11.050 --> 51:11.690
我们来看一下啊

51:13.800 --> 51:14.120
你看

51:14.760 --> 51:15.960
我们的文笨框里边

51:16.760 --> 51:17.640
我们的文笨框里边

51:17.640 --> 51:19.160
是不是显示到我们的halo5u

51:21.080 --> 51:22.840
文笨框里边是不是显示到halo5u

51:22.840 --> 51:25.080
然后a11里边是不是也显示到halo5u

51:25.080 --> 51:26.200
那么这说明啥

51:26.200 --> 51:27.720
这说明了我们这个title

51:27.720 --> 51:29.640
是不是绑定到了input里边

51:30.200 --> 51:30.600
对吧

51:30.600 --> 51:32.200
绑定到了这个input里边

51:32.200 --> 51:33.000
通过这个vmode

51:33.880 --> 51:34.200
看没

51:35.240 --> 51:36.280
然后我们再来看

51:36.360 --> 51:38.440
如果说我们去改变这个input的话

51:39.640 --> 51:40.200
你会发现

51:40.840 --> 51:41.640
这个也变了

51:41.640 --> 51:42.680
这是为什么呢

51:42.680 --> 51:44.600
当我们改变这个input的时候

51:45.880 --> 51:47.560
那么它的变化

51:47.560 --> 51:48.920
它会自动的把数据

51:48.920 --> 51:50.440
又重新复制变

51:50.440 --> 51:51.160
这个title

51:51.160 --> 51:52.040
让title发生变化

51:52.040 --> 51:53.240
就要双向往地

51:53.240 --> 51:55.160
就它的数据会影响input

51:55.160 --> 51:57.160
然后input的变化也会影响它

51:57.160 --> 51:59.160
它们两个的数据绑定在一起了

51:59.160 --> 51:59.960
它是什么数据

51:59.960 --> 52:01.240
我的title有什么数据

52:01.240 --> 52:02.360
而title的数据一变

52:02.360 --> 52:03.400
由于它是享用式的

52:03.400 --> 52:04.760
就导致我们这里重新渲染

52:04.920 --> 52:06.040
从现在是不是要输出这个

52:06.840 --> 52:07.080
对吧

52:07.080 --> 52:08.280
这里又会重新更新

52:09.240 --> 52:09.880
这就是vmode

52:11.080 --> 52:11.720
vmod

52:13.320 --> 52:14.760
这是咱们这个vmod

52:14.760 --> 52:15.720
那么为什么要说这呢

52:16.920 --> 52:18.440
vmod是一个好东西

52:18.440 --> 52:19.560
它让我们的数据

52:19.560 --> 52:21.640
始终跟我们的界面保持一致

52:21.640 --> 52:22.520
这是一个好天下

52:23.240 --> 52:24.040
这就避免了

52:24.040 --> 52:24.840
我们有的时候

52:24.840 --> 52:26.600
在来啪啪啪不停地打文门框

52:26.600 --> 52:27.080
结果呢

52:27.080 --> 52:28.520
我们的数据变得没变

52:28.520 --> 52:29.560
它是个好东西

52:29.560 --> 52:30.680
但是有的时候呢

52:31.480 --> 52:33.240
它发现给我们造成了一些困扰

52:34.200 --> 52:36.680
因为vmod它绑定了一个表达项的时候

52:36.680 --> 52:38.920
如果说用户改变这个vmode

52:38.920 --> 52:39.720
改变这个东西

52:39.720 --> 52:40.920
它的数据也会变

52:40.920 --> 52:42.200
而我们数据变了是不是

52:42.760 --> 52:44.120
会影响重新渲染

52:44.440 --> 52:45.480
重新渲染在干嘛

52:45.480 --> 52:46.680
是不是要来执行介石

52:47.320 --> 52:47.720
对不对

52:48.200 --> 52:50.680
而执行介石会为大家一些性能的开销

52:50.680 --> 52:51.800
那肯定会啊

52:51.800 --> 52:52.600
你看我们这里

52:53.320 --> 52:54.600
这个界面渲染了多少次啊

52:54.600 --> 52:55.640
渲染了很多次

52:55.640 --> 52:57.000
一次 两次 三次 五次

52:57.000 --> 52:58.680
四次 五 六 七 八

52:58.680 --> 52:59.400
几个渲染

52:59.960 --> 53:01.240
它其实重新变染了很多次

53:01.240 --> 53:02.600
那我可以带来一些性能的开销

53:02.840 --> 53:04.120
那么这些开销了平时

53:04.120 --> 53:05.640
如果说很多时候呢

53:05.640 --> 53:07.080
其实感觉不到的

53:07.080 --> 53:08.120
用户觉得没啥

53:08.120 --> 53:09.320
开销就开销了

53:09.320 --> 53:11.240
但是有的时候用户就能感觉到

53:11.800 --> 53:12.760
什么时候呢

53:12.760 --> 53:14.360
就是一页面上有一些动画

53:14.360 --> 53:15.640
正在进行中

53:15.640 --> 53:17.320
那么这个时候用户就能感觉到

53:17.320 --> 53:18.760
为什么会感觉到了

53:18.760 --> 53:21.080
因为我们GS执行现成

53:21.080 --> 53:22.200
这是基础知识的

53:22.200 --> 53:23.080
跟5G无关的

53:24.360 --> 53:25.880
GS的执行现成

53:25.880 --> 53:28.520
跟我们浏览器的渲染现成是互斥的

53:29.720 --> 53:31.080
他们两个只能一个人干活

53:31.560 --> 53:32.920
就是浏览器在渲染的时候

53:32.920 --> 53:33.800
你够等着

53:33.800 --> 53:34.680
你GS不能执行

53:35.560 --> 53:36.680
GS在执行的时候

53:36.680 --> 53:37.960
浏览器是不能渲染的

53:38.520 --> 53:39.640
它是卡住的

53:40.360 --> 53:40.920
所以说呢

53:40.920 --> 53:41.560
如果说

53:42.760 --> 53:44.520
你在改变闻闷框的时候

53:44.520 --> 53:46.440
恰好有些动画在执行了

53:46.440 --> 53:47.240
那么这个时候

53:47.240 --> 53:48.920
浏览器的动画就会出现卡顿

53:49.640 --> 53:51.080
造成一些用户体验的降低

53:51.720 --> 53:52.600
那么这个问题

53:52.600 --> 53:54.200
我们可以在这里直观的看到

53:59.000 --> 53:59.480
停止啊

54:00.040 --> 54:00.520
又回去

54:01.240 --> 54:02.760
给删了

54:04.760 --> 54:05.880
准备了一些势力

54:05.880 --> 54:06.760
都用了好多时间了

54:06.760 --> 54:07.880
之前讲的这个课就是

54:14.630 --> 54:14.950
好

54:14.950 --> 54:15.510
咱们来看一下

54:19.180 --> 54:20.300
这里有很多动画

54:20.300 --> 54:21.100
不是动画呢

54:21.100 --> 54:22.860
又是另外一些支持了

54:22.860 --> 54:23.580
就在这

54:23.580 --> 54:25.340
一个是又是v-mode

54:25.340 --> 54:27.500
就是用使用v-mode来处理

54:27.500 --> 54:28.860
那么这里边有些动画

54:28.860 --> 54:29.740
跟动画相关的办法

54:29.740 --> 54:30.460
比较这里我用了

54:30.460 --> 54:31.260
全新group

54:31.980 --> 54:32.860
如果说你学过的话

54:32.860 --> 54:33.660
你自然能看得懂

54:33.660 --> 54:34.540
如果说你没学过的话

54:34.620 --> 54:35.580
我这里没有那么多时间

54:35.580 --> 54:36.620
给你解释

54:36.620 --> 54:37.820
总之这里边有动画

54:37.820 --> 54:39.020
你甭管它怎么来的

54:39.020 --> 54:40.220
你们以后都会学习的

54:41.500 --> 54:42.220
然后呢

54:42.220 --> 54:42.940
我这里呢

54:42.940 --> 54:44.700
有一个input

54:44.700 --> 54:46.060
你只关注这一块就行了

54:46.060 --> 54:47.020
这我使用了v-mode

54:48.060 --> 54:48.620
v-mode

54:49.260 --> 54:50.300
绑定了一个数据

54:50.300 --> 54:51.420
new to do content

54:52.220 --> 54:52.780
绑定了它

54:54.540 --> 54:55.420
绑定了它

54:55.420 --> 54:57.020
当我们在这个文凳框里边

54:57.020 --> 54:58.300
按下回车键的时候

54:59.580 --> 55:00.620
按键盘的回车键

55:01.740 --> 55:02.940
这是一个修饰服务

55:02.940 --> 55:04.380
键盘的回车键

55:04.460 --> 55:06.220
我会调用这个函数add to do

55:07.260 --> 55:07.820
调用这个函数

55:07.820 --> 55:08.780
这个函数在做什么呢

55:08.780 --> 55:10.620
它首先判断这个有没有值

55:10.620 --> 55:11.580
为什么要判断它

55:11.580 --> 55:13.260
因为它的数据跟我们的文凳框数据

55:13.260 --> 55:14.700
是双向绑定的

55:14.700 --> 55:16.300
它有值文凳框里面就有值

55:16.300 --> 55:17.820
它没有值文凳框就没有值

55:17.820 --> 55:18.620
它如果说没有值

55:18.620 --> 55:19.900
我就啥都不做

55:19.900 --> 55:21.020
如果说它有值的话

55:21.020 --> 55:22.300
我做的事情很简单

55:22.300 --> 55:23.740
我就往这个对象

55:23.740 --> 55:25.100
对象数组里边

55:25.100 --> 55:26.300
today表示我的任务

55:26.300 --> 55:27.180
目前的任务

55:27.180 --> 55:29.260
对象数组里边加一条数据

55:29.260 --> 55:30.220
id自动成程

55:30.220 --> 55:31.580
我这也写了个random

55:31.580 --> 55:32.380
自动成程一个id

55:34.680 --> 55:35.480
这个能看懂吗

55:37.080 --> 55:38.280
以后有机会来讲吧

55:39.560 --> 55:40.840
自动成程一个id

55:40.840 --> 55:44.600
然后把这个新的任务的内容

55:44.600 --> 55:45.720
复制给这个content

55:45.720 --> 55:46.280
复制给它

55:47.160 --> 55:48.360
就是生成这么一个对象

55:48.360 --> 55:50.200
把个对象加到这个数据的第一项

55:50.760 --> 55:51.560
这个很简单

55:51.560 --> 55:52.840
是看关键代吧

55:52.840 --> 55:54.600
然后把这个数据清空

55:54.600 --> 55:55.880
为什么要把这个数据清空

55:55.880 --> 55:56.840
因为它一清空

55:56.840 --> 55:57.800
是不是文凳框就清空了

55:58.360 --> 56:00.280
文凳框的数据跟它是双向绑定的

56:00.280 --> 56:01.000
它的数据变化

56:01.000 --> 56:02.120
文凳框会变化

56:02.120 --> 56:03.240
文凳框的数据会变化

56:03.240 --> 56:04.200
它的数据会变化

56:04.840 --> 56:06.040
只看这个关键代吧

56:07.000 --> 56:08.040
这块代吧能看懂吗

56:08.040 --> 56:09.880
就是我刚才讲的那块代吧

56:09.880 --> 56:10.360
能不能看懂

56:17.030 --> 56:18.150
就只一个同学吗

56:18.150 --> 56:19.110
还是给我这反应吧

56:20.870 --> 56:21.510
不要吓我嘛

56:22.390 --> 56:23.110
到底哪里不懂

56:23.750 --> 56:24.870
你不用去管这个动画

56:24.870 --> 56:25.830
动画的一些不用去管

56:25.830 --> 56:26.790
我们就看核心代吧

56:26.790 --> 56:27.830
我这里有个宿主

56:27.830 --> 56:28.950
宿主里面有很多任务

56:29.510 --> 56:30.630
然后我一个文凳框

56:30.630 --> 56:31.510
跟他绑定在一起

56:31.510 --> 56:33.590
当我回车添加的时候

56:33.590 --> 56:34.390
我教了这个函数

56:34.950 --> 56:36.390
我看一下你有没有写东西

56:36.390 --> 56:37.190
没写东西就算了

56:37.910 --> 56:38.790
你写了东西的话

56:38.790 --> 56:39.670
我就生成一个对象

56:39.670 --> 56:41.110
加到这个宿主的地底下

56:41.110 --> 56:42.550
然后这里边我把

56:42.550 --> 56:44.150
我把这个宿主循环渲染出来

56:44.150 --> 56:45.190
你甭管它怎么循环

56:46.230 --> 56:47.510
好 那么就完成了

56:47.510 --> 56:48.470
其他都不用管

56:49.110 --> 56:50.150
好 咱们来看一下

56:50.150 --> 56:51.270
我这里随便写一个回车

56:51.830 --> 56:52.630
不停号嘛对不对

56:54.070 --> 56:54.870
好像没什么问题

56:54.870 --> 56:55.990
确实没什么问题

56:55.990 --> 56:56.790
但是大家再看

57:01.320 --> 57:02.280
看到没看到卡顿没

57:06.460 --> 57:07.100
看到卡顿没

57:07.660 --> 57:08.780
当我们不停在文凳框

57:08.780 --> 57:09.660
那边敲东西的时候

57:09.660 --> 57:11.500
如果说这个时候恰好有动画

57:11.500 --> 57:13.080
动画是跟我们的GSE

57:13.080 --> 57:14.440
是指寻是故赤的

57:14.440 --> 57:15.960
就导致了浏览器渲染不过来

57:18.050 --> 57:19.330
看到没看到卡顿没

57:20.610 --> 57:22.610
这就是微墨的当时的问题

57:22.610 --> 57:23.890
那么这个问题怎么解决呢

57:24.370 --> 57:26.290
就是不要用微墨的就可以解决

57:26.290 --> 57:27.090
那不要用微墨的

57:27.090 --> 57:27.810
就可以用啥呢

57:27.810 --> 57:28.770
用啥都可以

57:28.770 --> 57:29.410
你用啥都可以

57:29.410 --> 57:30.770
反正就不要用微墨的

57:30.770 --> 57:31.890
那么有一种做法就是

57:32.770 --> 57:34.610
使用微墨的里边有个修饰服

57:34.610 --> 57:35.170
叫NASI

57:36.770 --> 57:38.050
但是这个这个例子呢

57:38.050 --> 57:38.930
不太适用

57:38.930 --> 57:40.290
这个例子不太适用

57:40.290 --> 57:41.170
就是通过一个NASI

57:41.170 --> 57:42.130
NASI是什么呢

57:42.290 --> 57:44.530
它就是延迟双向绑定

57:45.170 --> 57:46.610
就是不要绑定得那么着急

57:47.250 --> 57:48.290
什么时候绑定呢

57:48.290 --> 57:50.210
当我们闷框失去焦点的时候

57:51.330 --> 57:52.530
比方我们闷框变了

57:52.530 --> 57:55.010
变的时候那就不要给它重新复制

57:55.010 --> 57:56.770
只有当我们闷框失去焦点的时候

57:56.770 --> 57:58.130
再统一给它复制

57:58.130 --> 57:59.330
这不只复制一次

58:00.050 --> 58:00.930
那么NASI

58:00.930 --> 58:01.650
这是一种做法

58:01.650 --> 58:03.250
但是这个场景不适用

58:03.250 --> 58:03.970
就是因为这个场景

58:03.970 --> 58:05.810
我是在我们框聚焦的状态下

58:05.810 --> 58:06.690
按到回车

58:06.690 --> 58:07.730
所以说这个场景不适用

58:08.290 --> 58:09.410
那么这个场景用啥呢

58:10.050 --> 58:11.250
我就不用微墨的

58:11.250 --> 58:11.810
你看

58:11.890 --> 58:13.410
其他单码都完全一样

58:13.410 --> 58:14.450
就这个地方区别

58:15.010 --> 58:16.370
你看我没有使用微墨的

58:16.690 --> 58:18.850
我连新的数据都没了

58:18.850 --> 58:21.250
之前这里是不是有个New to do

58:22.530 --> 58:23.090
航天者

58:23.090 --> 58:24.130
现在都没这个数据了

58:24.130 --> 58:24.850
数据都不要了

58:25.490 --> 58:26.770
每个场景要具体分析

58:26.770 --> 58:27.890
具体问题必须去分析

58:27.890 --> 58:28.850
只是这个场景里面

58:28.850 --> 58:30.050
我就可以不要那个数据了

58:30.850 --> 58:31.890
那么我们这里

58:31.890 --> 58:33.090
按下回车过后

58:33.090 --> 58:33.810
调问这个函数

58:33.810 --> 58:34.530
ADD to do

58:35.010 --> 58:35.730
调这个函数

58:35.730 --> 58:37.330
这个函数有个事件参数亿

58:37.570 --> 58:38.370
这个应该学过

58:38.370 --> 58:39.490
应该知道

58:39.730 --> 58:40.370
都是基础

58:40.370 --> 58:41.570
非常基础的东西

58:41.650 --> 58:42.770
就是5u里面的

58:42.770 --> 58:43.970
这些元素的事件里面

58:43.970 --> 58:44.930
还会自动给你带一个

58:44.930 --> 58:45.810
实践参数亿

58:45.970 --> 58:47.250
这个实践参数亿是啥呢

58:50.240 --> 58:51.120
和浏览器

58:52.160 --> 58:53.600
浏览器事件

58:55.680 --> 58:57.440
中的参数

58:57.440 --> 58:58.480
完全一致

58:58.480 --> 58:59.280
就是那个参数

58:59.680 --> 59:00.640
它会带一个底

59:00.640 --> 59:01.600
那么通过这个参数

59:01.600 --> 59:03.200
是不是可以拿到1.talkit

59:03.200 --> 59:04.080
1.value

59:04.080 --> 59:04.800
是不是可以拿

59:04.800 --> 59:05.840
1.talkit是什么意思

59:05.840 --> 59:07.200
就是浏览器的动物对象

59:07.200 --> 59:08.240
真实动物对象

59:08.240 --> 59:08.960
拿到它的value

59:08.960 --> 59:09.520
是不是就可以拿到

59:09.520 --> 59:10.480
那个文明框的纸

59:10.480 --> 59:11.120
是吧

59:11.120 --> 59:12.560
然后统络的事情

59:12.560 --> 59:13.440
如果说没有内容

59:13.520 --> 59:14.320
就返回

59:14.320 --> 59:15.120
有内容的话

59:15.120 --> 59:16.560
那我就生成那个东西

59:16.560 --> 59:18.000
然后把这个文明清空

59:18.720 --> 59:19.280
对吧

59:19.280 --> 59:20.480
所以我们没有用这个

59:20.480 --> 59:22.320
就脱离到5u那一套东西

59:22.320 --> 59:23.360
来做这个事情

59:23.360 --> 59:24.160
那么这样子呢

59:24.160 --> 59:24.800
就避免了

59:25.440 --> 59:26.400
它的打字的时候

59:26.400 --> 59:27.520
造成了介事指向

59:28.000 --> 59:29.200
好 咱们再看这边

59:30.480 --> 59:31.360
非常的有详

59:31.920 --> 59:33.640
你看

59:33.640 --> 59:34.520
所以没有法顿

59:34.520 --> 59:35.400
没有法顿

59:36.440 --> 59:37.320
所以这是关于这个

59:37.320 --> 59:38.520
vmod的优化

59:38.520 --> 59:39.320
vmod的优化

59:39.320 --> 59:39.960
就是如果

59:39.960 --> 59:41.000
平时都没有啥问题

59:41.720 --> 59:43.160
但是鸡蛋那个东西多了

59:43.640 --> 59:44.200
或者是

59:45.080 --> 59:46.520
基本上有动画的时候

59:47.000 --> 59:47.960
就会非常明显的

59:47.960 --> 59:48.760
感觉到有卡顿

59:49.640 --> 59:50.760
那么解决办法

59:50.760 --> 59:52.040
要么就是使用nazzy

59:52.040 --> 59:52.840
比方说

59:52.840 --> 59:54.440
像那个一些表单

59:55.320 --> 59:56.200
表单有很多项

59:56.760 --> 59:57.880
那么这个时候呢

59:57.880 --> 59:58.600
你完全可以

59:58.600 --> 59:59.320
加上一个nazzy

59:59.960 --> 01:00:01.400
延时绑垫

01:00:01.400 --> 01:00:02.520
10月10点的时候再绑垫

01:00:03.480 --> 01:00:04.760
或者是像我刚才那种情况

01:00:04.760 --> 01:00:05.960
根本就不用vmod

01:00:05.960 --> 01:00:07.320
vmod都可以

01:00:07.320 --> 01:00:07.880
只是这一块

01:00:07.880 --> 01:00:09.320
这一块听懂没问题吧

01:00:09.320 --> 01:00:09.960
没问题吧

01:00:09.960 --> 01:00:10.360
求的一

01:00:15.720 --> 01:00:17.240
好

01:00:17.240 --> 01:00:17.560
下一个

01:00:19.160 --> 01:00:20.680
保持对象引用稳定

01:00:21.640 --> 01:00:22.760
这位是说的是啥呀

01:00:23.880 --> 01:00:25.560
我们第二天的时候

01:00:25.560 --> 01:00:26.840
学过了那个

01:00:26.840 --> 01:00:28.040
响应式系统对吧

01:00:28.920 --> 01:00:29.800
响应式系统里边

01:00:29.800 --> 01:00:31.000
我们当时还给大家

01:00:31.000 --> 01:00:32.040
看过一段源嘛

01:00:33.240 --> 01:00:34.760
就是这段源吧

01:00:34.760 --> 01:00:35.320
不知道还

01:00:35.320 --> 01:00:36.200
还有没有印象

01:00:36.200 --> 01:00:37.320
dev-loty

01:00:38.600 --> 01:00:39.640
叫做派发更新

01:00:41.240 --> 01:00:42.120
我当时还用那种

01:00:42.120 --> 01:00:42.920
非常白话的方式

01:00:42.920 --> 01:00:44.200
给大家解释了

01:00:44.280 --> 01:00:45.320
啥意思呢

01:00:45.320 --> 01:00:46.440
就是说

01:00:46.440 --> 01:00:48.120
我这个数据变了

01:00:48.120 --> 01:00:49.320
那么那些

01:00:50.280 --> 01:00:51.240
我之前小本上

01:00:51.240 --> 01:00:52.680
记录的那些观察者

01:00:52.680 --> 01:00:54.600
你们去干活

01:00:54.600 --> 01:00:56.360
你们去出发去执行

01:00:56.360 --> 01:00:57.480
叫做派发更新

01:00:57.480 --> 01:00:57.800
通知

01:00:59.720 --> 01:01:01.320
什么情况下发生通知呢

01:01:01.320 --> 01:01:02.840
唯有里边有一段判断代码

01:01:03.880 --> 01:01:05.400
导查给大家看过的

01:01:05.400 --> 01:01:07.080
如果说你给这个数据

01:01:07.080 --> 01:01:09.080
新的值跟旧的值

01:01:09.080 --> 01:01:09.800
完全一样

01:01:10.360 --> 01:01:11.160
那么这个时候

01:01:11.160 --> 01:01:12.680
它不会发出任何通知

01:01:12.680 --> 01:01:13.480
直接就结束了

01:01:14.680 --> 01:01:15.400
对不对

01:01:15.400 --> 01:01:16.360
也就是它就相当于是

01:01:16.360 --> 01:01:18.280
没有通知重新宣展

01:01:18.280 --> 01:01:19.160
没有通知

01:01:19.160 --> 01:01:20.440
没有通知那些玩具去执行

01:01:21.560 --> 01:01:22.760
哎后边这个是啥意思呢

01:01:24.600 --> 01:01:25.560
有没有人看得懂

01:01:25.560 --> 01:01:26.680
后边那个东西是啥意思

01:01:34.400 --> 01:01:35.360
有没有人看懂啊

01:01:40.240 --> 01:01:41.760
后边这个神奇的代码

01:01:41.760 --> 01:01:43.680
也就是在介石里面才会出现

01:01:44.560 --> 01:01:45.360
new value

01:01:45.360 --> 01:01:45.920
什么情况下

01:01:45.920 --> 01:01:46.880
它自己不等于自己

01:01:49.240 --> 01:01:50.600
什么情况下它自己不等于自己

01:01:57.350 --> 01:01:57.910
浪嘛

01:02:02.120 --> 01:02:03.880
我记得乘哥的介石讲过这个

01:02:11.090 --> 01:02:11.570
还有呢

01:02:17.890 --> 01:02:19.410
NN是啊

01:02:19.410 --> 01:02:20.530
浪对啊浪对

01:02:20.530 --> 01:02:21.010
那我的

01:02:21.010 --> 01:02:22.770
那这个同学还挺不错啊

01:02:22.770 --> 01:02:23.410
还挺不错

01:02:23.970 --> 01:02:24.290
那个

01:02:25.490 --> 01:02:26.530
说闹的是谁

01:02:26.530 --> 01:02:27.170
我看一下啊

01:02:28.690 --> 01:02:29.090
大大

01:02:30.370 --> 01:02:31.810
还有这个地主家

01:02:31.810 --> 01:02:32.530
还挺不错的

01:02:32.530 --> 01:02:33.810
我的继承是NN的

01:02:33.810 --> 01:02:34.610
我的老大老大

01:02:34.610 --> 01:02:36.050
老大里边的继承是NN的

01:02:37.970 --> 01:02:39.090
NAN

01:02:39.090 --> 01:02:40.690
是不是等于NAN

01:02:41.010 --> 01:02:42.690
我记返了啊

01:02:46.000 --> 01:02:47.440
自己不等于自己的就是NAN

01:02:47.440 --> 01:02:48.160
看NAN的

01:02:50.800 --> 01:02:51.760
NAN也是

01:02:51.760 --> 01:02:52.400
NAN也是

01:02:52.960 --> 01:02:54.800
那么也就是说它排出了什么情况呢

01:02:54.800 --> 01:02:56.240
排这两个代码就排出了

01:02:56.880 --> 01:02:59.200
他们两个都是NAN的情况

01:02:59.200 --> 01:03:00.240
或者是都是NAN

01:03:00.240 --> 01:03:01.040
或者是一个是NAN

01:03:01.040 --> 01:03:01.760
一个是NAN

01:03:01.760 --> 01:03:02.400
一个是NAN

01:03:02.400 --> 01:03:02.800
一个是NAN

01:03:03.360 --> 01:03:04.480
那么像这种情况了

01:03:04.480 --> 01:03:06.320
他都认为你没有什么变化

01:03:06.320 --> 01:03:07.920
也就是说他被从NAN变成NAN

01:03:08.720 --> 01:03:10.080
他从NAN变成NAN

01:03:10.080 --> 01:03:10.960
他认为没有变化

01:03:11.040 --> 01:03:12.160
他说NAN变成NAN

01:03:12.160 --> 01:03:13.280
也认为没有变化

01:03:13.280 --> 01:03:14.720
像这种情况他就return

01:03:15.760 --> 01:03:15.920
好

01:03:15.920 --> 01:03:17.280
总之他觉得没有变化的话

01:03:17.280 --> 01:03:18.160
他就会return

01:03:18.160 --> 01:03:18.880
也就是说

01:03:18.880 --> 01:03:19.280
什么呢

01:03:19.280 --> 01:03:21.200
我们如果说要阻止他炫的

01:03:21.200 --> 01:03:22.240
在无忧里边

01:03:22.240 --> 01:03:24.160
我们就尽量要给他的属性啊

01:03:24.160 --> 01:03:24.960
或者是数据啊

01:03:24.960 --> 01:03:26.320
尽量不要让他的变

01:03:26.320 --> 01:03:27.840
不要他当他东西变化

01:03:28.400 --> 01:03:29.520
那么这种情况下

01:03:29.520 --> 01:03:30.800
就是不是有矛盾啊

01:03:30.800 --> 01:03:31.360
什么矛盾啊

01:03:31.360 --> 01:03:31.680
就是说

01:03:32.800 --> 01:03:34.640
我只有见面刷新的时候

01:03:34.640 --> 01:03:35.840
就是我希望他变的时候

01:03:35.840 --> 01:03:36.480
我才会变他

01:03:37.440 --> 01:03:38.480
我不希望他变的时候

01:03:38.480 --> 01:03:39.680
我干嘛要去变他呀

01:03:39.840 --> 01:03:41.600
但是有的时候就会出问题

01:03:41.600 --> 01:03:42.400
给他看个例子啊

01:03:42.400 --> 01:03:43.760
这个例子呢比较长

01:03:43.760 --> 01:03:45.040
我给大家解释一下

01:03:45.040 --> 01:03:47.280
这也是开发里面比较常见的一个场景

01:03:48.400 --> 01:03:49.280
现在呢我有一个

01:03:49.920 --> 01:03:51.520
组件叫做user comments

01:03:52.400 --> 01:03:53.040
这个组件

01:03:53.040 --> 01:03:53.520
这个组件呢

01:03:53.520 --> 01:03:54.720
接受一个对象

01:03:54.720 --> 01:03:56.080
这个对象呢叫做评论

01:03:58.080 --> 01:03:58.800
评论

01:03:58.800 --> 01:04:00.480
为了让你们看得清楚了

01:04:00.480 --> 01:04:02.560
我这里给这个组件了一个数据啊

01:04:02.560 --> 01:04:03.680
这个数据其实没有什么用

01:04:03.680 --> 01:04:05.280
主要是为了让你们看得清楚

01:04:06.560 --> 01:04:06.800
就是

01:04:07.760 --> 01:04:08.800
组件

01:04:10.000 --> 01:04:11.120
重渲染的次数

01:04:13.920 --> 01:04:14.640
默认是零

01:04:14.640 --> 01:04:15.680
一开始没有重新渲染

01:04:15.680 --> 01:04:15.920
对吧

01:04:15.920 --> 01:04:17.040
一开始只渲染一次

01:04:17.040 --> 01:04:17.680
首次渲染

01:04:17.680 --> 01:04:18.400
不叫重渲染

01:04:19.040 --> 01:04:19.920
默认是零

01:04:19.920 --> 01:04:20.240
然后呢

01:04:20.240 --> 01:04:22.000
我注册了一个生命周期勾字函数

01:04:24.160 --> 01:04:25.600
就组件在重渲染的时候

01:04:26.720 --> 01:04:27.840
重渲染时

01:04:28.800 --> 01:04:29.200
加一

01:04:29.920 --> 01:04:31.040
这个组件出了

01:04:31.040 --> 01:04:31.920
没问题吧

01:04:31.920 --> 01:04:32.720
很好理解吧

01:04:32.720 --> 01:04:33.680
你给我一个评论对象

01:04:33.680 --> 01:04:34.880
我负责显示评论

01:04:34.880 --> 01:04:35.920
这这几句单吧

01:04:35.920 --> 01:04:36.880
都是为了让你们

01:04:36.880 --> 01:04:37.600
看得清楚啊

01:04:37.680 --> 01:04:38.880
它到底重渲染了几次

01:04:39.600 --> 01:04:40.480
一开始零次

01:04:40.480 --> 01:04:41.600
然后只要重新渲染了

01:04:41.600 --> 01:04:43.360
它就会运行这个生命周期勾字函数

01:04:43.360 --> 01:04:44.000
然后它加加

01:04:44.720 --> 01:04:46.080
那么接下来我们来在界面上

01:04:46.080 --> 01:04:46.960
界面上就是

01:04:46.960 --> 01:04:48.400
我生成一个十半元数

01:04:48.400 --> 01:04:50.320
如果说它有重渲染的话

01:04:50.320 --> 01:04:51.520
这个重渲染不为零

01:04:51.520 --> 01:04:52.320
它大于零

01:04:52.320 --> 01:04:53.760
那么我就把它显示出来

01:04:53.760 --> 01:04:54.880
表示这里重渲染了

01:04:54.880 --> 01:04:55.840
重渲染了几次呢

01:04:55.840 --> 01:04:57.040
我这里显示出来

01:04:57.040 --> 01:04:58.080
然后这里上我就显示

01:04:58.080 --> 01:05:00.000
那个评论的用户名

01:05:00.000 --> 01:05:00.960
评论的内容

01:05:02.320 --> 01:05:03.440
这就是我这个单吧

01:05:04.400 --> 01:05:04.720
没问题吧

01:05:04.720 --> 01:05:05.280
非常简单吧

01:05:05.280 --> 01:05:06.000
这个这个组件

01:05:06.560 --> 01:05:06.800
好

01:05:06.800 --> 01:05:07.760
接下来我们看

01:05:07.760 --> 01:05:08.800
我们是怎么去操作它的

01:05:10.760 --> 01:05:12.120
这里边有很多东西都在模拟

01:05:12.680 --> 01:05:13.240
我这里呢

01:05:13.240 --> 01:05:14.920
用到了一些阿迦克斯请求

01:05:14.920 --> 01:05:15.640
比较说这里的

01:05:15.640 --> 01:05:17.320
加到一个第三方户叫Axios

01:05:17.320 --> 01:05:19.320
它主要是要做阿迦克斯请求的

01:05:19.320 --> 01:05:19.720
但是呢

01:05:19.720 --> 01:05:21.000
我这里没有真正的去请求

01:05:21.000 --> 01:05:22.040
我使用了默克数据

01:05:22.040 --> 01:05:23.240
就是模拟数据

01:05:23.240 --> 01:05:24.280
关于这个模拟数据呢

01:05:24.280 --> 01:05:25.320
我不在这里展开了

01:05:25.880 --> 01:05:26.600
总之我这里

01:05:26.600 --> 01:05:27.880
有了这个模拟数据过后呢

01:05:27.880 --> 01:05:29.160
它就能请求到数据了

01:05:30.040 --> 01:05:30.200
好

01:05:30.200 --> 01:05:30.840
我们来看一下

01:05:30.840 --> 01:05:31.640
做了什么事

01:05:31.640 --> 01:05:33.000
这个函数在做什么事情

01:05:33.480 --> 01:05:34.280
你不用去看这里

01:05:34.280 --> 01:05:34.760
不要耽误

01:05:34.760 --> 01:05:35.880
我就告诉他做什么事情

01:05:36.440 --> 01:05:37.880
他通过阿迦克斯

01:05:37.880 --> 01:05:39.720
就通过网络请求

01:05:39.720 --> 01:05:41.560
获取所有的评论

01:05:42.920 --> 01:05:43.720
所有的评论

01:05:43.720 --> 01:05:44.600
反过来是一个数据

01:05:45.400 --> 01:05:46.920
反回一个评论数据

01:05:48.760 --> 01:05:49.400
好

01:05:49.400 --> 01:05:49.720
这个

01:05:50.760 --> 01:05:52.520
这是通过阿迦克斯

01:05:52.520 --> 01:05:53.800
添加一个评论

01:05:54.440 --> 01:05:55.160
一条评论

01:05:56.600 --> 01:05:58.200
因为添加评论不能添加到本地

01:05:58.200 --> 01:05:59.640
你再告诉服务器

01:05:59.640 --> 01:06:00.920
我这边评论新增了

01:06:00.920 --> 01:06:02.680
就是它是一个远程请求

01:06:03.240 --> 01:06:04.440
这两个还是都是异步的

01:06:04.520 --> 01:06:05.960
异步的我都逼问了

01:06:05.960 --> 01:06:07.400
这个ES7的

01:06:07.400 --> 01:06:08.760
阿迦克斯和俄卫者

01:06:08.760 --> 01:06:10.680
这两个网友你看不懂也没关系

01:06:10.680 --> 01:06:11.880
你只要知道意识就行了

01:06:11.880 --> 01:06:13.640
我们要看关键性的代码

01:06:13.640 --> 01:06:15.480
你不要把被这些东西分形了

01:06:15.480 --> 01:06:16.280
所以说

01:06:16.280 --> 01:06:17.560
因为我们这个直播课呢

01:06:18.680 --> 01:06:20.360
每个同学的基础能力都不一样

01:06:20.360 --> 01:06:21.960
有一些同学前面学的很多

01:06:21.960 --> 01:06:22.680
都很扎实

01:06:22.680 --> 01:06:23.800
有一些同学前面就要压根

01:06:23.800 --> 01:06:24.440
没学过这些东西

01:06:24.440 --> 01:06:25.080
那就没办法

01:06:25.800 --> 01:06:26.520
所以我们一

01:06:26.520 --> 01:06:27.320
如果说没学过的话

01:06:27.320 --> 01:06:28.440
你要看关键性的代码

01:06:28.440 --> 01:06:29.880
这个东西你知道什么意思就行了

01:06:30.440 --> 01:06:30.680
好吧

01:06:30.680 --> 01:06:31.880
不然的话你会影响到

01:06:31.880 --> 01:06:32.600
我们的学习的

01:06:33.560 --> 01:06:34.680
不要被这些东西干扰

01:06:35.800 --> 01:06:36.040
好

01:06:36.040 --> 01:06:38.040
接下来我在这里的注册这个组建

01:06:38.040 --> 01:06:39.640
我这里的准备了两个评论列表

01:06:40.360 --> 01:06:41.800
为什么要准备两个评论列表

01:06:41.800 --> 01:06:42.600
我为了对比

01:06:43.800 --> 01:06:44.840
对比看一下

01:06:44.840 --> 01:06:46.840
就是两种方案

01:06:46.840 --> 01:06:48.600
它造成的效率有什么样的问题

01:06:49.480 --> 01:06:50.360
一个是评论列表

01:06:50.360 --> 01:06:51.240
另一个评论列表

01:06:51.240 --> 01:06:51.640
好

01:06:51.640 --> 01:06:52.040
看着

01:06:52.760 --> 01:06:53.640
最开始的时候

01:06:54.440 --> 01:06:55.640
做的事情完全一样

01:06:56.440 --> 01:06:57.480
调用这个函数

01:06:57.480 --> 01:06:58.680
基本上拿到所有评论

01:06:59.320 --> 01:07:00.200
拿到所有评论

01:07:00.200 --> 01:07:01.800
把这个评论数组复制给他

01:07:02.760 --> 01:07:04.200
你知道什么意思就行了

01:07:04.200 --> 01:07:05.080
这个东西你不用管

01:07:05.800 --> 01:07:06.920
获取所有评论

01:07:06.920 --> 01:07:08.280
远程获取所有评论

01:07:08.280 --> 01:07:09.400
拿到一个评论数组

01:07:09.400 --> 01:07:10.760
把这个评论数组复制给他

01:07:11.480 --> 01:07:12.760
这个玩意也是完全一样

01:07:12.760 --> 01:07:13.400
所以说一开始

01:07:13.400 --> 01:07:15.000
大家显示的东西完全一样

01:07:15.000 --> 01:07:15.640
看一下吧

01:07:20.200 --> 01:07:20.600
CD

01:07:22.840 --> 01:07:23.240
4

01:07:24.040 --> 01:07:24.520
NP1

01:07:24.520 --> 01:07:25.320
RAM

01:07:29.110 --> 01:07:29.670
这上面

01:07:29.670 --> 01:07:30.550
这上面的东西很简单

01:07:31.030 --> 01:07:32.470
就点击按钮

01:07:32.470 --> 01:07:33.350
按钮不用管

01:07:33.350 --> 01:07:34.070
然后这里说是

01:07:34.070 --> 01:07:35.670
就循环生成这个User Command

01:07:36.230 --> 01:07:37.030
生成这个组建

01:07:37.030 --> 01:07:37.830
对吧

01:07:37.830 --> 01:07:39.270
生成这个组建User Command

01:07:39.270 --> 01:07:40.070
循环生成它

01:07:40.950 --> 01:07:43.030
然后把这个评论数据传过去

01:07:43.030 --> 01:07:43.430
循环

01:07:43.430 --> 01:07:43.670
你看

01:07:43.670 --> 01:07:45.270
循环第一个数组

01:07:45.270 --> 01:07:45.670
key的话

01:07:45.670 --> 01:07:46.870
就是它的ID

01:07:46.870 --> 01:07:48.230
把这个数据给他

01:07:48.230 --> 01:07:48.790
然后这里呢

01:07:48.790 --> 01:07:50.550
也是循环第二个数组

01:07:50.550 --> 01:07:50.870
key呢

01:07:50.870 --> 01:07:51.750
就是它的ID

01:07:51.750 --> 01:07:52.390
把这个数据给他

01:07:52.390 --> 01:07:53.670
一开始数组完全一样的

01:07:59.110 --> 01:08:00.390
你看一开始完全一样

01:08:01.030 --> 01:08:02.070
效果一样

01:08:02.070 --> 01:08:02.950
效率也完全一样

01:08:02.950 --> 01:08:03.750
这个没有任何区别

01:08:04.710 --> 01:08:05.510
数据也不多

01:08:05.510 --> 01:08:06.550
一共就十条数据

01:08:07.510 --> 01:08:07.670
好

01:08:07.670 --> 01:08:08.470
接下来我们看这

01:08:09.190 --> 01:08:10.070
添加评论

01:08:10.710 --> 01:08:11.110
添加评论

01:08:11.110 --> 01:08:12.230
当然要写个文文框

01:08:12.230 --> 01:08:13.110
然后写一些东西

01:08:13.110 --> 01:08:13.670
对吧

01:08:13.670 --> 01:08:14.230
然后登录

01:08:14.230 --> 01:08:15.110
那些评论我就不做了

01:08:15.750 --> 01:08:16.470
会干扰我们的

01:08:16.470 --> 01:08:17.910
目前的要讲的东西

01:08:17.910 --> 01:08:18.550
我们就做一个

01:08:18.550 --> 01:08:19.750
非常简单的模拟效果

01:08:20.390 --> 01:08:20.870
添

01:08:20.870 --> 01:08:22.310
就是他们之前的完全一样

01:08:22.310 --> 01:08:23.430
就是添加的时候不一样

01:08:24.070 --> 01:08:24.710
所以说你们以后

01:08:24.710 --> 01:08:25.270
写弹码的时候

01:08:25.270 --> 01:08:26.790
要注意注意到这个效率问题

01:08:28.390 --> 01:08:30.390
第一种方式添加

01:08:31.190 --> 01:08:31.910
添加后

01:08:31.910 --> 01:08:32.790
它的做法是

01:08:32.790 --> 01:08:34.950
添加后重新获取数据

01:08:34.950 --> 01:08:35.430
看着啊

01:08:37.430 --> 01:08:37.990
方式一

01:08:38.710 --> 01:08:39.670
我调用这个方法

01:08:41.190 --> 01:08:42.070
添加一条评论

01:08:42.070 --> 01:08:43.670
它会随即生成一个评论

01:08:43.670 --> 01:08:44.390
无所谓

01:08:44.390 --> 01:08:45.830
总之它会调用这个方法

01:08:45.830 --> 01:08:46.950
来添加一条评论

01:08:48.550 --> 01:08:49.110
然后呢

01:08:49.110 --> 01:08:49.750
添加评论过后

01:08:49.750 --> 01:08:50.310
是不是

01:08:50.310 --> 01:08:51.350
我们的服务器那边

01:08:51.350 --> 01:08:52.230
数据更新了

01:08:52.230 --> 01:08:53.350
短聊提交到服务器

01:08:53.910 --> 01:08:54.150
好

01:08:54.150 --> 01:08:54.790
数据更新了过后

01:08:54.790 --> 01:08:55.830
我重新从服务器

01:08:55.830 --> 01:08:56.790
拿取新的评论

01:08:57.510 --> 01:08:59.030
复制给这个comments1

01:08:59.830 --> 01:09:00.550
看一下这样子

01:09:01.270 --> 01:09:02.310
这样子做会怎么样

01:09:03.830 --> 01:09:04.550
接下来我们这里

01:09:04.550 --> 01:09:05.590
演技这个按钮添加

01:09:08.050 --> 01:09:09.250
是不是一条新的评论出来了

01:09:09.890 --> 01:09:10.850
这个没问题吧

01:09:10.850 --> 01:09:11.490
没问题

01:09:11.650 --> 01:09:12.690
但是你会发现

01:09:12.690 --> 01:09:13.890
下边的出问题了

01:09:14.770 --> 01:09:16.690
下边这些逐渐全部重新渲染了

01:09:18.720 --> 01:09:19.920
这是咋回事了

01:09:19.920 --> 01:09:21.040
这些数据并没有变啊

01:09:21.040 --> 01:09:21.440
你看

01:09:21.440 --> 01:09:22.640
lame0还是content0

01:09:22.640 --> 01:09:23.680
lame1还是content1

01:09:24.240 --> 01:09:25.200
你看这边对一个

01:09:25.200 --> 01:09:25.440
对吧

01:09:25.440 --> 01:09:26.320
是不是没有变化

01:09:26.320 --> 01:09:27.680
但它为什么要重新渲染的

01:09:28.960 --> 01:09:29.840
原因就是

01:09:30.320 --> 01:09:32.640
由于你从服务器重新拿数据

01:09:32.640 --> 01:09:33.840
拿到了是一个什么

01:09:33.840 --> 01:09:36.000
拿到了不仅是一个新数据

01:09:36.000 --> 01:09:37.040
数据肯定是新数据

01:09:38.400 --> 01:09:40.480
而且数据里边每一个对象

01:09:40.480 --> 01:09:41.840
全部都是新的

01:09:41.840 --> 01:09:42.640
你记住啊

01:09:42.640 --> 01:09:44.640
你每一次从服务器拿到了数据

01:09:44.640 --> 01:09:46.320
全都是全新的对象

01:09:46.320 --> 01:09:48.400
尽管对象里边每一个属性值

01:09:48.400 --> 01:09:49.440
长得跟之前一样

01:09:49.440 --> 01:09:50.080
哪怕一样

01:09:50.080 --> 01:09:51.120
它也是新的对象

01:09:51.120 --> 01:09:52.480
它对象地址不一样

01:09:53.600 --> 01:09:56.160
而由于从服务器

01:09:56.160 --> 01:09:57.920
一开始服务器拿到一个数据

01:09:57.920 --> 01:09:59.360
比方说拿个对象

01:09:59.360 --> 01:10:00.000
就三个嘛

01:10:00.800 --> 01:10:02.880
然后一会从服务器拿到了四个数据

01:10:05.360 --> 01:10:05.840
你看

01:10:05.840 --> 01:10:06.800
这个是新增的

01:10:06.800 --> 01:10:07.040
对吧

01:10:07.040 --> 01:10:08.160
新增的数据

01:10:08.160 --> 01:10:09.200
但这个数据呢

01:10:09.200 --> 01:10:11.520
这个数据跟之前的里边的内容完全一样

01:10:11.600 --> 01:10:13.440
但是它这个对象跟它的对象

01:10:13.440 --> 01:10:14.240
是完全不一样的

01:10:15.280 --> 01:10:15.920
没啥意思啊

01:10:17.200 --> 01:10:18.720
这两个对象是完全不一样的

01:10:18.720 --> 01:10:20.800
它们的地址是不一样的

01:10:20.800 --> 01:10:22.320
那么就导致了一个问题

01:10:22.320 --> 01:10:25.360
我把这个新的数据拿去循环渲染生成的时候

01:10:25.360 --> 01:10:27.200
尽管T的ID是没问题的

01:10:27.920 --> 01:10:30.800
但是我是给它的数据是不是一个全新的对象

01:10:31.360 --> 01:10:32.800
就导致了我这里的数据

01:10:32.800 --> 01:10:33.760
给它的数据

01:10:33.760 --> 01:10:35.680
就给它的一个全新的对象

01:10:35.680 --> 01:10:37.600
由于给它的全新的对象

01:10:37.600 --> 01:10:39.200
那么是不是就会触发重渲染

01:10:41.160 --> 01:10:42.280
是不是就会触发重渲染

01:10:42.280 --> 01:10:43.000
就看这儿

01:10:43.880 --> 01:10:46.200
给它的新的值不等于旧的值

01:10:46.200 --> 01:10:47.640
是不是会触发重渲染

01:10:47.640 --> 01:10:50.600
那么触发重渲染是不是这个里边就会重新渲染

01:10:50.600 --> 01:10:52.840
那么就会运行这个生命车区的物质汤数

01:10:52.840 --> 01:10:53.480
没啥意思吧

01:10:54.120 --> 01:10:55.080
所以大家以后呢

01:10:55.080 --> 01:10:56.280
要注意到的这一点

01:10:56.280 --> 01:10:57.560
情况它的数据没有变化

01:10:57.560 --> 01:10:59.640
那么这里的列表比较少

01:10:59.640 --> 01:11:02.040
当然你们可能会遇到一些很长很长的列表

01:11:03.880 --> 01:11:04.760
那么这两只呢

01:11:04.760 --> 01:11:07.800
就会带来一些不必要的重新重渲染

01:11:07.800 --> 01:11:09.160
明明加了一条数据而已

01:11:09.160 --> 01:11:11.320
结果这些列表整个列表全部重新渲染

01:11:11.320 --> 01:11:11.800
你看

01:11:12.280 --> 01:11:13.640
你看这边重渲染了两次

01:11:13.640 --> 01:11:15.560
之前那个新数据又重渲染了一次

01:11:15.560 --> 01:11:16.520
又加了新的一条

01:11:16.920 --> 01:11:17.400
对吧

01:11:17.400 --> 01:11:18.360
不认了重新渲染

01:11:19.480 --> 01:11:20.600
好这是这个问题

01:11:20.600 --> 01:11:21.880
那么这个问题要怎么解决呢

01:11:21.880 --> 01:11:23.160
其实非常非常简单

01:11:24.200 --> 01:11:25.160
看第二种方式

01:11:25.720 --> 01:11:26.920
第二种添加方式

01:11:26.920 --> 01:11:27.960
第二种添加方式呢

01:11:28.360 --> 01:11:30.040
我就添加到服务器

01:11:31.400 --> 01:11:34.280
一般来说服务器那边会给我返回一个对象

01:11:34.280 --> 01:11:36.040
一般来说都会给你返回

01:11:36.040 --> 01:11:37.880
如说服务器它不给你返回怎么办

01:11:38.440 --> 01:11:39.400
你去找后装打架

01:11:40.120 --> 01:11:42.600
你去要求它把刀架在好脖子上

01:11:42.600 --> 01:11:43.800
它必须给你返回的东西

01:11:44.280 --> 01:11:45.480
它又会返回决定一个

01:11:46.200 --> 01:11:46.760
评论对象

01:11:47.480 --> 01:11:49.800
那么你要做的事情就是把这个评论对象

01:11:49.800 --> 01:11:51.480
夹到这个列表的地底下

01:11:51.480 --> 01:11:52.600
或者是最后底下

01:11:52.600 --> 01:11:54.040
那么看要求看需求

01:11:55.080 --> 01:11:56.440
那么这样子来做的话

01:11:56.440 --> 01:11:58.040
那么就是之前是有一个数组

01:11:58.040 --> 01:11:59.720
那么现在无非就是在这个数组里面

01:11:59.720 --> 01:12:00.920
新增了一个元素

01:12:00.920 --> 01:12:01.560
对不对

01:12:01.560 --> 01:12:03.880
那之前的对象是引用地址是不是一样的

01:12:04.840 --> 01:12:05.880
引用地址是不是一样的

01:12:05.880 --> 01:12:07.240
那么引用地址一样

01:12:07.320 --> 01:12:09.240
这样子传到这个数据里边去

01:12:09.240 --> 01:12:10.760
传到这个数据里边去

01:12:10.760 --> 01:12:13.160
是不是地址跟之前的地址是一样的

01:12:13.160 --> 01:12:14.440
那么它到时候一判断

01:12:14.440 --> 01:12:15.720
你给它复制的时候

01:12:16.360 --> 01:12:17.880
发现这两个地址是一个地址

01:12:17.880 --> 01:12:18.760
它是不是就return了

01:12:19.560 --> 01:12:20.680
就结束了

01:12:20.680 --> 01:12:21.080
对不对

01:12:21.080 --> 01:12:21.240
好

01:12:21.240 --> 01:12:21.960
咱们来看一下这边

01:12:23.000 --> 01:12:24.440
是不是这些主线都没有重新选了

01:12:25.880 --> 01:12:26.760
这一块能听懂的话

01:12:26.760 --> 01:12:27.240
求个以啊

01:12:35.280 --> 01:12:37.600
哪里面就去PK呗

01:12:37.760 --> 01:12:40.800
你看看谁去的健身房次数比较多

01:12:41.600 --> 01:12:42.560
一般全端来说

01:12:42.560 --> 01:12:44.080
可能去健身房的次数还多一点

01:12:44.080 --> 01:12:46.240
毕竟是毕竟后端要辛苦一点

01:12:46.240 --> 01:12:46.560
对不对

01:12:50.130 --> 01:12:50.370
好

01:12:50.370 --> 01:12:51.730
这是这一块啊

01:12:51.730 --> 01:12:52.210
但是呢

01:12:52.210 --> 01:12:53.410
这样第二种方式呢

01:12:53.410 --> 01:12:55.250
有一个什么不好的地方呢

01:12:55.250 --> 01:12:56.610
有一个什么不好的地方呢

01:12:56.610 --> 01:12:57.250
你看着啊

01:12:57.250 --> 01:12:59.250
它还是有一点点不好的地方

01:12:59.250 --> 01:12:59.970
但是这个地方呢

01:12:59.970 --> 01:13:02.370
我觉得也ok了

01:13:02.370 --> 01:13:03.330
你看啊这里

01:13:03.330 --> 01:13:05.090
比方说我这边新增了一个

01:13:05.890 --> 01:13:07.810
现在现在的真实数据是不是有

01:13:07.810 --> 01:13:09.250
有12条数据

01:13:09.250 --> 01:13:09.730
对不对

01:13:09.730 --> 01:13:11.010
有10和11

01:13:11.010 --> 01:13:12.530
但是我这边点了过后

01:13:12.530 --> 01:13:13.330
只拿到了12

01:13:13.970 --> 01:13:15.330
是不是只拿到新增的那一条

01:13:15.890 --> 01:13:17.410
那么在新增之前

01:13:17.410 --> 01:13:20.450
和第一次加载之间的这些数据是拿不到了

01:13:20.450 --> 01:13:21.410
它不知道有

01:13:21.410 --> 01:13:21.970
根本就不知道

01:13:21.970 --> 01:13:23.410
因为它没有重新重复去拿

01:13:23.970 --> 01:13:24.610
明了的意思吧

01:13:25.410 --> 01:13:25.970
啊它没有

01:13:25.970 --> 01:13:26.850
有这个问题

01:13:26.850 --> 01:13:28.450
那么左边那个就不存在这样的问题

01:13:29.650 --> 01:13:30.770
你看我加两条

01:13:30.770 --> 01:13:31.730
然后这边再加一条

01:13:31.730 --> 01:13:33.090
是不是10和11都拿到了

01:13:33.650 --> 01:13:33.890
对吧

01:13:33.890 --> 01:13:34.930
左边是不存在问题的

01:13:34.930 --> 01:13:35.890
在右边有这个问题

01:13:35.890 --> 01:13:36.530
但这个问题呢

01:13:36.530 --> 01:13:37.330
其实也没事

01:13:37.330 --> 01:13:38.210
首先我们平时

01:13:38.290 --> 01:13:39.490
很多场景下

01:13:39.490 --> 01:13:40.770
都不需要实施数据

01:13:40.770 --> 01:13:42.050
哪需要那么多实施数据

01:13:42.050 --> 01:13:42.610
对吧

01:13:42.610 --> 01:13:44.370
你觉得少两条评论有什么

01:13:44.370 --> 01:13:46.290
有什么问题吗

01:13:46.290 --> 01:13:46.930
没有什么问题

01:13:47.730 --> 01:13:49.250
如果说你一定要做实施数据

01:13:49.250 --> 01:13:50.690
其实你要用web少case

01:13:52.290 --> 01:13:53.250
做法都不一样了

01:13:53.250 --> 01:13:54.210
肯定不是用这种方式

01:13:54.210 --> 01:13:55.410
点一下拿实施数据

01:13:55.410 --> 01:13:55.970
肯定不是

01:13:56.450 --> 01:13:57.730
你应该用web少case

01:13:58.930 --> 01:14:01.170
那你即便是要点一下拿实施数据

01:14:01.170 --> 01:14:02.130
那么你应该

01:14:02.130 --> 01:14:03.330
从服务器拿到一个新的

01:14:03.890 --> 01:14:05.250
就是哪怕你一定要从服务器

01:14:05.250 --> 01:14:06.370
拿到一个新的数据

01:14:06.370 --> 01:14:07.490
那么你可以这样做呗

01:14:07.570 --> 01:14:08.130
从服务

01:14:08.130 --> 01:14:09.170
拿到两个数据了对吧

01:14:10.770 --> 01:14:12.210
之前的数据是三项

01:14:12.210 --> 01:14:13.170
现在那变成了四项

01:14:15.170 --> 01:14:16.370
这是第一次从服务器拿的

01:14:16.370 --> 01:14:17.570
第二次从服务器拿的

01:14:17.570 --> 01:14:18.530
那么这些地址全部

01:14:18.530 --> 01:14:19.890
引用地址全部不一样

01:14:19.890 --> 01:14:20.770
那应该怎么做

01:14:20.770 --> 01:14:22.050
应该去对比两个数据

01:14:22.610 --> 01:14:23.730
如果ID相同

01:14:24.210 --> 01:14:26.370
就要保持数据的值不变

01:14:26.370 --> 01:14:27.970
找到ID不同的

01:14:27.970 --> 01:14:29.410
加入到数据的相近位置

01:14:29.410 --> 01:14:30.690
这是一道算法

01:14:30.690 --> 01:14:31.490
这是一道算法题

01:14:33.970 --> 01:14:35.250
对两个数据比较

01:14:35.250 --> 01:14:35.890
比较更新

01:14:36.370 --> 01:14:38.610
那就是目标就是要保持那个

01:14:40.290 --> 01:14:40.930
地址稳定

01:14:42.530 --> 01:14:43.410
好下一个

01:14:43.410 --> 01:14:45.650
使用V秀和TiDiVe

01:14:46.210 --> 01:14:47.650
那么这个东西不是一定的啊

01:14:48.370 --> 01:14:49.010
什么意思呢

01:14:49.010 --> 01:14:50.450
就是说我们的界面上的

01:14:50.450 --> 01:14:51.570
写templates的时候呢

01:14:51.570 --> 01:14:53.570
往往是有可以写两种的

01:14:55.010 --> 01:14:55.970
没有回到电脉买

01:15:02.920 --> 01:15:03.640
简单写个吧

01:15:04.920 --> 01:15:05.240
投稿

01:15:06.040 --> 01:15:06.440
有秀

01:15:08.840 --> 01:15:09.800
下边有个H1

01:15:13.090 --> 01:15:15.090
来回红条的

01:15:18.820 --> 01:15:19.700
上面的一个按钮

01:15:20.580 --> 01:15:21.380
这个按钮很简单

01:15:22.180 --> 01:15:23.060
点击过后呢

01:15:23.060 --> 01:15:25.140
就切换这个状态

01:15:32.100 --> 01:15:32.580
click

01:15:34.260 --> 01:15:35.780
就把这个秀复制为

01:15:35.780 --> 01:15:37.220
它相反的状态就OK了

01:15:37.220 --> 01:15:38.020
然后这个H1

01:15:38.020 --> 01:15:39.140
那我们可以使用V秀

01:15:40.740 --> 01:15:41.780
然后把秀放上

01:15:42.580 --> 01:15:43.140
我们看一下吧

01:15:45.780 --> 01:15:46.820
是不是来回红条

01:15:46.820 --> 01:15:48.580
那么这种用V秀呢

01:15:48.580 --> 01:15:49.700
因为V秀它决定了

01:15:49.700 --> 01:15:51.300
它到底要不要生成虚拟动

01:15:52.260 --> 01:15:54.260
如果说它V秀为forced的时候

01:15:54.260 --> 01:15:55.620
是不是就不生成虚拟动

01:15:55.620 --> 01:15:56.900
你看这里是不是啥都没有

01:15:57.940 --> 01:15:58.340
对不对

01:15:58.340 --> 01:16:00.820
并不存在H1生成虚拟动

01:16:00.820 --> 01:16:02.180
不生成虚拟动

01:16:02.180 --> 01:16:02.740
对吧

01:16:02.740 --> 01:16:03.540
这是V秀

01:16:03.540 --> 01:16:04.740
那么用V秀呢

01:16:05.460 --> 01:16:08.310
效果是完全一样的

01:16:10.230 --> 01:16:10.950
只不过呢

01:16:11.830 --> 01:16:13.190
你看是效果完全一样

01:16:13.190 --> 01:16:14.310
只不过它区别在于

01:16:14.310 --> 01:16:15.750
你看它显示的时候

01:16:15.750 --> 01:16:18.470
它并不会把这个H1删掉

01:16:18.470 --> 01:16:19.910
它只是用了Display Now

01:16:20.390 --> 01:16:21.430
也就用什么意思呢

01:16:21.430 --> 01:16:22.310
用V秀

01:16:23.110 --> 01:16:25.030
会不会影响虚拟动物的生成

01:16:25.030 --> 01:16:25.750
不会

01:16:25.750 --> 01:16:27.350
它一定会生成虚拟动

01:16:27.350 --> 01:16:29.030
只是这个虚拟动物的Display呢

01:16:29.030 --> 01:16:29.510
V Now

01:16:30.390 --> 01:16:31.510
就这么个意思

01:16:31.510 --> 01:16:31.910
所以说

01:16:32.710 --> 01:16:34.070
这就是他们的区别

01:16:34.070 --> 01:16:35.430
所以说V秀就相当于是什么呢

01:16:35.430 --> 01:16:36.630
你这样子写就相当于是

01:16:36.630 --> 01:16:37.510
它Render函数里边

01:16:37.510 --> 01:16:38.950
各位写了这么一个东西

01:16:38.950 --> 01:16:39.830
Render函数里边

01:16:40.550 --> 01:16:41.350
它生成了这个

01:16:41.350 --> 01:16:42.870
生成了一个H1是这个样子的

01:16:43.990 --> 01:16:44.950
H1

01:16:44.950 --> 01:16:45.510
然后呢

01:16:45.510 --> 01:16:47.750
它配置里边ATTR

01:16:49.670 --> 01:16:51.990
Style里边一个Display

01:16:53.830 --> 01:16:55.670
到底是只是什么

01:16:55.670 --> 01:16:57.750
应该取决于ZS秀

01:16:57.750 --> 01:16:59.030
ZS秀为Q的话

01:16:59.030 --> 01:17:01.190
那不就是啥都没有

01:17:01.190 --> 01:17:01.990
啥都没有

01:17:01.990 --> 01:17:03.110
否则的话就是那

01:17:03.110 --> 01:17:04.150
它就这样子写的

01:17:04.870 --> 01:17:05.350
原来意思吧

01:17:05.350 --> 01:17:06.390
它就是控制这个属性

01:17:06.390 --> 01:17:08.310
它一定会生成这个H1虚拟动物的

01:17:09.430 --> 01:17:11.590
那么由于它们有这样的一个区别

01:17:11.590 --> 01:17:12.550
那么我们在开发的时候

01:17:12.550 --> 01:17:13.830
如何选择呢

01:17:13.830 --> 01:17:14.630
你会发现

01:17:14.630 --> 01:17:16.230
如果说你用被衣服的话

01:17:16.230 --> 01:17:18.710
那么如果说你平换了切换显示

01:17:18.710 --> 01:17:19.750
如果说你用被衣服

01:17:20.390 --> 01:17:22.470
平换的去切换显示

01:17:22.630 --> 01:17:24.470
那么会导致我们那个动物数

01:17:24.470 --> 01:17:25.430
是不是不稳定了

01:17:25.430 --> 01:17:26.870
它一会儿只有一个指节点

01:17:26.870 --> 01:17:28.390
一会儿有两个指节点

01:17:28.390 --> 01:17:29.510
那么就会

01:17:29.510 --> 01:17:31.110
数的不稳定会导致什么

01:17:31.110 --> 01:17:32.230
是不是一定会导致

01:17:32.230 --> 01:17:33.910
三除和创建元素

01:17:34.550 --> 01:17:35.110
对不对

01:17:35.110 --> 01:17:36.150
三除元素

01:17:36.150 --> 01:17:37.190
创建元素

01:17:37.190 --> 01:17:37.830
对不对

01:17:37.830 --> 01:17:38.870
那如果说现在这个元素

01:17:38.870 --> 01:17:40.070
只有一个倒是没啥

01:17:40.070 --> 01:17:41.350
那如果说这里是个DIV

01:17:41.350 --> 01:17:43.030
DIV里边有一千个元素

01:17:43.030 --> 01:17:43.830
是不是导致这个

01:17:43.830 --> 01:17:45.190
千个元素全部被销毁

01:17:45.190 --> 01:17:46.150
然后创建的时候

01:17:46.150 --> 01:17:47.910
是不是导致很多元素重新被创建

01:17:48.470 --> 01:17:48.950
对不对

01:17:48.950 --> 01:17:49.670
那么这个时候呢

01:17:49.670 --> 01:17:50.950
是比较影响效率的

01:17:50.950 --> 01:17:52.150
那如果说你用V秀的话

01:17:52.150 --> 01:17:52.710
就非常好

01:17:54.230 --> 01:17:55.110
用V秀的话

01:17:56.390 --> 01:17:57.270
你看啊

01:17:57.270 --> 01:17:59.030
它这个元素并不会重新创建

01:17:59.030 --> 01:18:00.150
还是用之前的

01:18:00.150 --> 01:18:02.070
只剩下我切换了一下属性而已

01:18:02.070 --> 01:18:03.910
就是这个央视属性而已

01:18:03.910 --> 01:18:04.310
对不对

01:18:04.310 --> 01:18:06.950
所以说它能够保持数的稳定

01:18:08.630 --> 01:18:09.270
那是不是说

01:18:09.270 --> 01:18:11.030
V秀一定被V秀付好了

01:18:11.030 --> 01:18:11.510
也不是

01:18:12.630 --> 01:18:15.030
什么时候我们V秀付要好一些

01:18:15.030 --> 01:18:16.790
就是它没有频繁切换

01:18:16.790 --> 01:18:18.710
它可能一开始不显示

01:18:18.710 --> 01:18:20.310
但是到达某一个时机

01:18:20.310 --> 01:18:21.110
就显示出来了

01:18:21.110 --> 01:18:21.750
显示出来了过后

01:18:21.750 --> 01:18:22.710
就不再显示了

01:18:22.710 --> 01:18:23.910
就不再隐藏了

01:18:23.910 --> 01:18:24.790
就一直显示

01:18:25.350 --> 01:18:26.150
这种情况多不多

01:18:26.150 --> 01:18:27.110
这种情况多得不得了

01:18:27.910 --> 01:18:28.550
多得不得了

01:18:29.190 --> 01:18:31.510
比方说你现在要做一个文章组建

01:18:31.510 --> 01:18:32.550
文章详情组建

01:18:33.270 --> 01:18:34.310
这里边东西说

01:18:34.310 --> 01:18:35.430
元素是不是特别多

01:18:35.430 --> 01:18:36.550
但是个文章详情

01:18:36.550 --> 01:18:37.510
一开始是不显示的

01:18:37.510 --> 01:18:39.750
为什么要远程拿数据

01:18:39.750 --> 01:18:41.030
它一开始是不显示的

01:18:42.070 --> 01:18:43.750
然后要等远程拿数据

01:18:44.470 --> 01:18:45.590
远程数据拿什么数据

01:18:45.590 --> 01:18:46.470
拿文章数据

01:18:47.190 --> 01:18:48.310
远程文章数据

01:18:48.870 --> 01:18:49.110
好

01:18:50.150 --> 01:18:51.430
拿到文章数据过后

01:18:51.590 --> 01:18:52.790
再把它切换到显示

01:18:53.510 --> 01:18:54.470
然后再显示

01:18:54.470 --> 01:18:56.470
然后从此以后就不会再隐藏了

01:18:56.470 --> 01:18:57.270
就一直显示

01:18:57.830 --> 01:18:59.270
像这种情况多得不得了

01:18:59.670 --> 01:19:01.750
那么这个时候就非常适合用微衣服

01:19:01.750 --> 01:19:03.190
为什么不适合用微修呢

01:19:04.630 --> 01:19:05.190
为什么呢

01:19:09.220 --> 01:19:10.740
首先你用微修的话

01:19:10.740 --> 01:19:12.180
那一开始它这里边显示啥

01:19:12.180 --> 01:19:13.540
可能很多地方都要爆出

01:19:13.540 --> 01:19:15.380
因为它的文章数据是纳的

01:19:15.380 --> 01:19:17.060
你要去这个显示的组建里边

01:19:17.060 --> 01:19:19.140
要去读各种文章的属性

01:19:19.140 --> 01:19:19.780
根本就读不到

01:19:20.980 --> 01:19:22.020
这是一个

01:19:22.100 --> 01:19:22.740
而且呢

01:19:23.460 --> 01:19:25.140
你看这里是不是要渲染两次

01:19:25.140 --> 01:19:26.580
一开始不显示的时候

01:19:26.580 --> 01:19:27.540
组建里面的渲染出来吧

01:19:27.540 --> 01:19:28.660
因为这是一步操作

01:19:28.660 --> 01:19:30.180
一步操作需要一段时间的

01:19:30.180 --> 01:19:31.140
你可以把这个时间

01:19:31.140 --> 01:19:32.420
想上的长一点

01:19:32.420 --> 01:19:33.380
比较一个小时

01:19:33.380 --> 01:19:35.300
它一个小时之后才能拿到文章数据

01:19:35.300 --> 01:19:36.660
所以一开始必须要显示一遍

01:19:37.140 --> 01:19:38.180
显示一个空的东西

01:19:38.180 --> 01:19:38.820
对吧

01:19:38.820 --> 01:19:40.180
或者显示一个加载金图条

01:19:41.140 --> 01:19:42.580
然后显示的时候

01:19:42.580 --> 01:19:43.460
是不是又要渲染一遍

01:19:43.460 --> 01:19:44.420
因为数据改变了

01:19:44.420 --> 01:19:45.060
是不是要渲染一遍

01:19:45.060 --> 01:19:46.260
一共要渲染两次

01:19:46.260 --> 01:19:47.700
那如果说你用微修的话

01:19:48.420 --> 01:19:49.620
尽管一开始没有数据

01:19:49.620 --> 01:19:50.980
是不是你要还算渲染出

01:19:51.060 --> 01:19:52.180
很多的元素结构

01:19:53.620 --> 01:19:54.340
是不是比较慢啊

01:19:54.340 --> 01:19:54.740
一开始

01:19:55.540 --> 01:19:55.780
对不对

01:19:55.780 --> 01:19:57.220
它没有必要选择这些东西啊

01:19:57.220 --> 01:19:58.100
它都没有数据啊

01:19:58.740 --> 01:20:00.420
而一会儿文章显示出来的时候

01:20:01.940 --> 01:20:03.060
那么我虽然说

01:20:03.060 --> 01:20:04.180
文章显示出来的时候

01:20:05.540 --> 01:20:06.340
文章显示出来的时候

01:20:06.340 --> 01:20:07.220
是不是还是改动了很多

01:20:07.220 --> 01:20:08.900
因为你这个Display

01:20:08.900 --> 01:20:10.420
不是光把这个Display

01:20:10.420 --> 01:20:11.860
变成那个Block

01:20:12.500 --> 01:20:13.860
而且它里边的很多元素啊

01:20:13.860 --> 01:20:15.060
什么标题元素啊

01:20:15.060 --> 01:20:15.780
什么图片啊

01:20:15.780 --> 01:20:16.580
是不是全部都要改

01:20:17.300 --> 01:20:18.020
因为数据来了

01:20:18.020 --> 01:20:18.580
对吧

01:20:18.580 --> 01:20:19.140
之前没有数据

01:20:19.140 --> 01:20:19.780
现在数据来了

01:20:19.780 --> 01:20:21.220
里边很多的数据全部都要改

01:20:21.220 --> 01:20:23.220
它显示它渲染的东西还是很多

01:20:24.260 --> 01:20:25.380
那么就没有必要

01:20:25.940 --> 01:20:27.460
那还不如用微衣服

01:20:27.460 --> 01:20:28.340
微衣服的好处在于

01:20:28.340 --> 01:20:30.580
一开始这个整个元素都没有

01:20:30.580 --> 01:20:32.260
所以渲染的速度非常快

01:20:32.260 --> 01:20:33.380
然后一会儿

01:20:33.380 --> 01:20:33.940
元素来的

01:20:33.940 --> 01:20:35.140
就是数据来的时候呢

01:20:35.140 --> 01:20:36.420
我再去生存这些元素

01:20:37.700 --> 01:20:39.140
它不是说一定的啊

01:20:39.140 --> 01:20:40.260
那什么情况要用微修

01:20:40.260 --> 01:20:41.540
什么情况要用微衣服呢

01:20:41.540 --> 01:20:43.940
就是如果说切换的没有那么平凡

01:20:43.940 --> 01:20:45.220
偶尔切换银丝

01:20:45.220 --> 01:20:46.100
那么这个时候呢

01:20:46.100 --> 01:20:46.900
可以用微衣服

01:20:47.620 --> 01:20:49.940
保持尽量净减的渲染

01:20:50.500 --> 01:20:52.260
比如说切换的非常平凡

01:20:52.260 --> 01:20:54.180
那我就需要保持数的稳定

01:20:54.180 --> 01:20:55.860
这个要根据具体情况

01:20:55.860 --> 01:20:57.140
比方说像有的时候呢

01:20:57.140 --> 01:20:58.340
一些纸菜单

01:20:58.340 --> 01:20:59.300
二级菜单

01:20:59.300 --> 01:21:00.180
你鼠标移上去

01:21:00.180 --> 01:21:01.140
就可以刷

01:21:01.140 --> 01:21:02.820
显示一个大堆的菜单

01:21:02.820 --> 01:21:04.820
那么这种情况也比较适合用微修

01:21:04.820 --> 01:21:06.100
你为什么呢

01:21:06.100 --> 01:21:07.940
因为鼠标移上去这个动作

01:21:07.940 --> 01:21:08.740
太平凡了

01:21:08.740 --> 01:21:09.140
对吧

01:21:09.140 --> 01:21:10.580
不小心的可能移上去

01:21:11.220 --> 01:21:13.140
因为不知道大家有没有用阿利云

01:21:13.140 --> 01:21:14.420
阿利云里边的那个

01:21:14.420 --> 01:21:15.620
那些东西的菜单

01:21:15.620 --> 01:21:17.860
是不是比较适合用微修

01:21:26.690 --> 01:21:27.170
不对啊

01:21:27.170 --> 01:21:28.530
你有ID呀

01:21:28.530 --> 01:21:30.610
ID从哪里来啊

01:21:30.610 --> 01:21:31.650
你不把ID给我们

01:21:32.770 --> 01:21:34.290
还有一些数据你要教验的

01:21:34.290 --> 01:21:35.250
而且有些数据呢

01:21:35.250 --> 01:21:38.290
你要重新给我格式化的

01:21:38.290 --> 01:21:39.250
就是我写了一些

01:21:39.250 --> 01:21:40.610
比方说简单的例子

01:21:40.610 --> 01:21:43.890
我那个账号

01:21:43.890 --> 01:21:45.170
你可能要去掉所谓空格

01:21:45.170 --> 01:21:45.490
对吧

01:21:45.490 --> 01:21:47.490
你一定会有一些规则

01:21:47.490 --> 01:21:49.090
你可能要格式化一些数据

01:21:49.090 --> 01:21:49.490
对不对

01:21:53.540 --> 01:21:54.020
好

01:21:54.020 --> 01:21:54.660
最后一个啊

01:21:55.700 --> 01:21:57.300
使用延迟装占

01:21:57.300 --> 01:21:57.620
defer

01:21:58.820 --> 01:21:59.460
这什么意思呢

01:21:59.460 --> 01:22:00.260
大家看一个例子

01:22:01.700 --> 01:22:02.500
直接看例子啊

01:22:06.200 --> 01:22:07.400
今天晚上你们真的是

01:22:08.280 --> 01:22:09.160
赚到了

01:22:09.160 --> 01:22:09.800
好多例子

01:22:09.800 --> 01:22:10.840
别的例子我都准备

01:22:10.840 --> 01:22:11.880
要准备都准备好久

01:22:17.110 --> 01:22:17.350
好

01:22:17.350 --> 01:22:17.830
我们来看

01:22:17.830 --> 01:22:18.310
首先看一下

01:22:19.110 --> 01:22:20.550
我们现在这什么东西啊

01:22:20.550 --> 01:22:21.510
一个是

01:22:21.510 --> 01:22:22.470
我们这里写了个主件

01:22:22.470 --> 01:22:23.510
这个主件特别变态

01:22:24.070 --> 01:22:25.830
这个主件里面包含了五千个主件

01:22:26.230 --> 01:22:27.110
五千个元素

01:22:27.830 --> 01:22:29.430
这个符合真实情况吗

01:22:31.270 --> 01:22:31.910
这个真实

01:22:31.910 --> 01:22:33.750
让它这个真实情况里面呢

01:22:33.750 --> 01:22:35.030
没有那么夸张啊

01:22:35.030 --> 01:22:36.630
但是可能也差不多

01:22:36.630 --> 01:22:37.510
一些大的页面

01:22:38.150 --> 01:22:39.190
它里面元素很多

01:22:39.190 --> 01:22:40.230
因为它里面就不

01:22:40.230 --> 01:22:41.430
不但自己有很多元素

01:22:41.430 --> 01:22:42.070
还有一些纸

01:22:42.070 --> 01:22:42.950
还有一些纸

01:22:42.950 --> 01:22:43.750
纸主件

01:22:43.750 --> 01:22:45.030
纸主件里面还有纸主件

01:22:45.030 --> 01:22:46.630
纸主件里面可能还有个循环渲染

01:22:48.630 --> 01:22:49.750
我们之所以感觉到

01:22:50.310 --> 01:22:52.070
我们网页上可能没有那么多元素

01:22:52.070 --> 01:22:53.350
是因为很多元素很小

01:22:53.350 --> 01:22:54.150
知道吧

01:22:54.150 --> 01:22:54.870
你可能因为写过

01:22:54.870 --> 01:22:55.750
都写过静态页面

01:22:55.750 --> 01:22:56.870
是不是有的时候

01:22:56.870 --> 01:22:58.150
一个非常非常小的区域

01:22:58.150 --> 01:23:00.070
都会写很多很多的元素进去

01:23:00.070 --> 01:23:00.630
对不对

01:23:00.630 --> 01:23:02.230
你们应该理过这种感觉

01:23:02.230 --> 01:23:03.430
所以不是说页面

01:23:03.430 --> 01:23:04.310
它滚动条

01:23:04.950 --> 01:23:06.470
滚动条就没有什么滚动条

01:23:06.470 --> 01:23:07.670
那说明它的元素少

01:23:07.670 --> 01:23:08.870
那不是这个意思的

01:23:08.870 --> 01:23:09.990
因为有的很多很多

01:23:09.990 --> 01:23:11.430
稀小的地方

01:23:11.430 --> 01:23:12.630
它会有很多的元素的

01:23:13.510 --> 01:23:15.590
我们正在模拟到一个很大的页面

01:23:15.590 --> 01:23:17.590
这一个主件就会生成五千个元素

01:23:18.470 --> 01:23:19.750
我只不过把每一个元素

01:23:19.750 --> 01:23:20.790
设得非常小

01:23:20.790 --> 01:23:21.750
五相数三相数

01:23:22.710 --> 01:23:23.110
然后呢

01:23:23.110 --> 01:23:24.630
我们这边的有两套袋嘛

01:23:24.630 --> 01:23:25.350
第一套袋嘛

01:23:25.590 --> 01:23:26.630
就是我们老老实实

01:23:27.670 --> 01:23:28.790
没有什么心机的

01:23:28.790 --> 01:23:29.990
来把它写出来

01:23:29.990 --> 01:23:31.670
我这里注册这个主件

01:23:31.670 --> 01:23:34.630
我的首页里边可能有21个这样的主件

01:23:34.630 --> 01:23:36.630
我就循环了21次

01:23:37.510 --> 01:23:38.550
海外什么意思

01:23:38.550 --> 01:23:39.670
很重的主件

01:23:39.670 --> 01:23:41.830
就模拟出来是什么

01:23:41.830 --> 01:23:43.270
模拟出来我们页面上有很多板块

01:23:43.270 --> 01:23:43.830
对吧

01:23:43.830 --> 01:23:44.630
一个板块是一个主件

01:23:44.630 --> 01:23:45.590
一个板块是一个主件

01:23:45.590 --> 01:23:47.110
但我这里懒得去写那么多主件啊

01:23:47.110 --> 01:23:48.390
都用同一个板块

01:23:48.390 --> 01:23:50.230
总之我们就表示我们的主件

01:23:50.230 --> 01:23:52.230
页面上有21个这样的主件

01:23:52.390 --> 01:23:54.470
然后这个主件里边的东西很多

01:23:54.470 --> 01:23:55.830
好 咱们来看一下

01:23:55.830 --> 01:23:57.830
说不定有段时间是白平的

01:23:57.830 --> 01:23:58.630
为什么白平

01:23:58.630 --> 01:24:05.170
他要执行戒业室

01:24:06.530 --> 01:24:08.530
还有什么情况下还要白平

01:24:08.530 --> 01:24:10.050
检查看一下

01:24:11.570 --> 01:24:13.730
戒业室那个东西是避免不了的

01:24:13.730 --> 01:24:15.170
早晚都得执行的

01:24:15.170 --> 01:24:16.450
我们来看一下这个

01:24:17.730 --> 01:24:19.010
录制

01:24:19.010 --> 01:24:20.290
发信

01:24:21.570 --> 01:24:22.850
停止

01:24:22.850 --> 01:24:24.130
你觉得这一段时间

01:24:25.090 --> 01:24:31.400
你觉得这一段时间里边

01:24:31.400 --> 01:24:32.680
大部分时间在干嘛呀

01:24:32.680 --> 01:24:36.400
是不是在rendering

01:24:36.400 --> 01:24:39.600
rendering是谁在操作呀

01:24:39.600 --> 01:24:41.840
是浏览器在操作

01:24:41.840 --> 01:24:42.880
跟武幼有关系吗

01:24:42.880 --> 01:24:44.320
武幼戒业室执行完了

01:24:44.320 --> 01:24:45.520
跟你武幼就没关系了

01:24:45.520 --> 01:24:47.680
生产的事情都交给浏览器宣言了

01:24:47.680 --> 01:24:50.240
浏览器要宣言的元素特别多

01:24:50.240 --> 01:24:52.800
它要生成动物树

01:24:52.800 --> 01:24:55.120
所以生成了要生成很多的动物树

01:24:55.120 --> 01:24:56.400
动物树就特别大

01:24:56.400 --> 01:24:58.480
我这里还没有什么写什么样式

01:24:58.800 --> 01:25:01.920
再加上一些样式可能更加不得了

01:25:01.920 --> 01:25:04.800
还加上一些元素选择器的话更加不得了

01:25:04.800 --> 01:25:06.640
生成样式树生成渲染树

01:25:06.640 --> 01:25:08.720
然后绿色的是画

01:25:08.720 --> 01:25:11.040
就像画画一样把它画到一面上

01:25:11.040 --> 01:25:13.120
所以终点的时间在这一块

01:25:13.120 --> 01:25:14.880
对吧 是不是在这一块

01:25:14.880 --> 01:25:16.560
那么这一块的时间我们

01:25:16.560 --> 01:25:20.560
有没有办法把它减少呢

01:25:20.560 --> 01:25:22.880
有没有办法减少呢

01:25:22.880 --> 01:25:25.120
有办法你去把你的CPU

01:25:25.120 --> 01:25:27.280
把你的GPU把你的显卡换好一点

01:25:27.280 --> 01:25:29.600
还有时间就减少了

01:25:29.760 --> 01:25:32.320
显卡差一点它的时间就增加了

01:25:32.320 --> 01:25:34.160
内存条多差几呢

01:25:34.160 --> 01:25:35.920
CPU换成16核的

01:25:35.920 --> 01:25:37.760
它的时间就刚刚减少了

01:25:37.760 --> 01:25:39.200
这是办法

01:25:39.200 --> 01:25:41.200
除此之外你没有什么好的办法把它减少

01:25:41.200 --> 01:25:43.200
因为你的元素有那么多呀

01:25:43.200 --> 01:25:45.680
你有那么多元素你减少不了

01:25:45.680 --> 01:25:48.560
那我们既然减少不了这种时间

01:25:48.560 --> 01:25:51.040
我们又没有什么特别的想法呢

01:25:51.040 --> 01:25:54.980
我们是不是可以这样子来想

01:25:54.980 --> 01:25:57.060
我们有这么多元素

01:25:57.060 --> 01:25:59.460
我有必要一下子全部渲染出来吗

01:25:59.460 --> 01:26:01.140
其实没有必要

01:26:01.220 --> 01:26:03.060
我可以先渲染这一部分

01:26:03.060 --> 01:26:04.340
再渲染这一部分

01:26:04.340 --> 01:26:05.380
再渲染这一部分

01:26:05.380 --> 01:26:07.220
可以分布渲染

01:26:07.220 --> 01:26:09.940
也说这里要渲染21个这样的组件

01:26:09.940 --> 01:26:11.700
我们可以分布渲染

01:26:11.700 --> 01:26:13.220
渲染一个再渲染第二个

01:26:13.220 --> 01:26:14.900
再渲染第三个

01:26:14.900 --> 01:26:15.700
对吧

01:26:15.700 --> 01:26:19.060
那么我们就需要找到一个合适的时间点

01:26:19.060 --> 01:26:20.340
什么时候渲染第一个

01:26:20.340 --> 01:26:21.380
什么时候渲染第二个

01:26:21.380 --> 01:26:22.820
什么时候渲染第三个呢

01:26:22.820 --> 01:26:25.940
最合适的时间点就是浏览器的刷新率

01:26:25.940 --> 01:26:33.540
这就是涉及到浏览器的刷新率的

01:26:33.540 --> 01:26:35.700
那么这是一块第一手知识

01:26:35.700 --> 01:26:37.380
就是浏览器的它不断的刷新

01:26:37.380 --> 01:26:38.740
就像一个画家一样

01:26:38.740 --> 01:26:40.180
为什么浏览器里边可以看到动画

01:26:40.180 --> 01:26:41.060
它是不断的在画

01:26:41.060 --> 01:26:41.700
不断的画

01:26:41.700 --> 01:26:43.780
它每一次做画都是一个静态的

01:26:43.780 --> 01:26:46.340
它连在一起就变成动态的了

01:26:46.340 --> 01:26:47.300
它不断的在画

01:26:47.300 --> 01:26:49.300
它会画什么样的一个频率呢

01:26:49.300 --> 01:26:52.020
一般来说是每秒钟六十次

01:26:52.020 --> 01:26:54.260
这个东西根据你机器的配置呢

01:26:54.340 --> 01:26:57.700
还有就是你当前页面的界式执行情况呢

01:26:57.700 --> 01:26:59.620
都可能会多多少少的会有一些差异

01:26:59.620 --> 01:27:00.420
就正常情况下

01:27:00.420 --> 01:27:03.700
一般是一秒钟六十次

01:27:03.700 --> 01:27:05.780
那么我们在这条时间走上呢

01:27:05.780 --> 01:27:10.180
用一些点来表示浏览器的渲染时间点

01:27:10.180 --> 01:27:12.980
这就是浏览器渲染的时间点

01:27:12.980 --> 01:27:13.300
对吧

01:27:13.300 --> 01:27:15.300
它是一格一格的

01:27:15.300 --> 01:27:16.740
渲染这一次等一会儿

01:27:16.740 --> 01:27:17.620
然后渲染第二次

01:27:17.620 --> 01:27:18.260
再等一会儿

01:27:18.260 --> 01:27:19.940
渲染第三次

01:27:19.940 --> 01:27:22.340
然后浏览器里边有一个函数

01:27:22.660 --> 01:27:30.660
这个函数叫做request animation free

01:27:30.660 --> 01:27:33.220
它里面会传入一个毁掉

01:27:33.220 --> 01:27:34.020
有时候你会

01:27:34.020 --> 01:27:35.220
你调用这个函数的时候

01:27:35.220 --> 01:27:37.380
你再传一个函数进去

01:27:37.380 --> 01:27:39.540
那么这个函数在什么时候执行呢

01:27:39.540 --> 01:27:45.780
它就在这个点执行

01:27:45.780 --> 01:27:47.220
它就在这个点

01:27:47.220 --> 01:27:50.710
诶

01:27:50.710 --> 01:27:52.550
等一下啊

01:27:52.550 --> 01:27:53.590
它就在这个点

01:27:53.590 --> 01:27:54.150
这个点

01:27:54.150 --> 01:27:58.480
就是每一次渲染之前

01:27:58.480 --> 01:28:00.720
它就在这个点执行

01:28:00.800 --> 01:28:02.160
明显的意思啊

01:28:02.160 --> 01:28:05.360
你传入一个函数进去

01:28:05.360 --> 01:28:06.880
你传入一个函数进去

01:28:06.880 --> 01:28:07.920
这个函数就每

01:28:07.920 --> 01:28:09.680
它就会在这个点执行

01:28:09.680 --> 01:28:10.880
当然它只执行一次

01:28:10.880 --> 01:28:12.240
它不会反复地执行

01:28:12.240 --> 01:28:14.960
它实际上它只执行一次

01:28:14.960 --> 01:28:16.960
这就是这个函数的所有

01:28:16.960 --> 01:28:18.640
那如果说我希望它每一次

01:28:18.640 --> 01:28:20.880
在每一次渲染之后执行

01:28:20.880 --> 01:28:21.600
怎么办呢

01:28:21.600 --> 01:28:24.880
里面同学能够想到一些好办法

01:28:24.880 --> 01:28:26.320
它只执行一次

01:28:26.320 --> 01:28:27.360
如果说我希望

01:28:27.360 --> 01:28:46.520
它每一次在渲染之后执行呢

01:28:46.600 --> 01:28:47.320
那延迟

01:28:47.320 --> 01:28:48.040
延迟多久呢

01:28:48.040 --> 01:28:49.400
你也不知道延迟多久

01:28:49.400 --> 01:28:51.400
其实我们可以用一种非常巧妙的写法

01:28:51.400 --> 01:28:52.040
这种写法呢

01:28:52.040 --> 01:28:54.040
在5U的代码里面也会看到

01:28:54.040 --> 01:28:56.040
在很多的一些第三方库里面的代码

01:28:56.040 --> 01:28:56.840
里面都会看到

01:28:56.840 --> 01:28:59.000
特别是跟那种界面相关的库

01:28:59.000 --> 01:29:00.760
你都会看到这样的代码

01:29:00.760 --> 01:29:03.000
你就应该这样的写啊

01:29:03.000 --> 01:29:05.640
我只给它说一下吧

01:29:05.640 --> 01:29:07.320
就随便写吧

01:29:07.320 --> 01:29:08.840
我们一般来说会写这么一个函数

01:29:08.840 --> 01:29:09.960
叫RF

01:29:09.960 --> 01:29:12.280
叫RequestAnimationFree

01:29:12.280 --> 01:29:14.920
你给我传一个函数进来

01:29:14.920 --> 01:29:15.720
你给我传一个函数

01:29:15.720 --> 01:29:16.520
我就用FN嘛

01:29:16.520 --> 01:29:18.120
FN大家可以看得

01:29:18.120 --> 01:29:19.560
感觉上它像是一个函数

01:29:19.560 --> 01:29:20.120
对不对

01:29:20.120 --> 01:29:21.560
那么这个函数什么时候执行呢

01:29:21.560 --> 01:29:24.360
如果说你这样子写RequestAnimationFree

01:29:24.360 --> 01:29:25.800
把这个FN传进去

01:29:25.800 --> 01:29:27.720
那么它就是在每一次渲染之前执行

01:29:27.720 --> 01:29:29.000
就是我们刚才看的那个图

01:29:29.000 --> 01:29:30.040
对不对

01:29:30.040 --> 01:29:33.160
那怎么样我们才能在每一次渲染之后执行呢

01:29:33.160 --> 01:29:39.110
我把这个图啊

01:29:39.110 --> 01:29:41.030
你看着

01:29:41.030 --> 01:29:43.110
我这里这样子给它传定

01:29:43.110 --> 01:29:45.670
我传一个函数进去

01:29:45.670 --> 01:29:47.270
那么这个函数在什么时候执行呢

01:29:47.270 --> 01:29:48.390
是不是在这里执行呢

01:29:48.390 --> 01:29:49.510
一定是在这里执行的

01:29:50.230 --> 01:29:54.230
然后我在这个函数里边再调用一次RequestAnimationFree

01:29:54.230 --> 01:29:56.550
那么里边传一个FN

01:29:56.550 --> 01:29:57.670
看着啊

01:29:57.670 --> 01:29:59.430
这个函数在哪里执行的

01:29:59.430 --> 01:30:01.350
是不是在这里执行的

01:30:01.350 --> 01:30:03.350
然后这个函数的执行过程中

01:30:03.350 --> 01:30:04.550
又调用了这个函数

01:30:04.550 --> 01:30:06.550
那么这一次是不是下一次

01:30:06.550 --> 01:30:07.990
下一次渲染的

01:30:07.990 --> 01:30:12.930
是不是跑到这来了

01:30:12.930 --> 01:30:14.930
是不是跑到这来了

01:30:14.930 --> 01:30:17.250
那么也就是说这个FN

01:30:17.250 --> 01:30:19.250
这个函数是在这

01:30:19.250 --> 01:30:22.770
这个FN是不是在这

01:30:22.850 --> 01:30:23.730
没意思吧

01:30:23.730 --> 01:30:25.490
我们这通过这样的办法

01:30:25.490 --> 01:30:27.330
就可以达到

01:30:27.330 --> 01:30:28.130
传入一个FN

01:30:28.130 --> 01:30:32.130
它在下一次就这一次渲染之后执行

01:30:32.130 --> 01:30:32.850
能理解吧

01:30:32.850 --> 01:30:37.170
这是一种非常非常常见的写法啊

01:30:37.170 --> 01:30:37.490
好

01:30:37.490 --> 01:30:41.880
那么我们就回到我们的问题

01:30:41.880 --> 01:30:44.120
回到这啊

01:30:44.120 --> 01:30:46.600
所以说因为要把一个框架学好的话

01:30:46.600 --> 01:30:52.760
真的基础部分一定要掌握牢靠啊

01:30:52.760 --> 01:30:55.000
我们这里要渲染而是一次

01:30:55.000 --> 01:30:57.560
但是我们没有必要一下子渲染出来

01:30:57.560 --> 01:30:59.080
我只需要

01:30:59.080 --> 01:31:01.400
每一次在animation的时候

01:31:01.400 --> 01:31:03.720
就是每一次花一次我渲染一个

01:31:03.720 --> 01:31:05.000
花第二次我渲染一个

01:31:05.000 --> 01:31:06.280
花第三次渲染一个

01:31:06.280 --> 01:31:08.040
而且呢最好我要可以控制

01:31:08.040 --> 01:31:09.640
比方说可以控制第一个组件

01:31:09.640 --> 01:31:10.920
第一次

01:31:10.920 --> 01:31:13.320
哎比方说第一次那个Heavy Comp

01:31:13.320 --> 01:31:14.360
那么我在

01:31:14.360 --> 01:31:15.400
我要在这里渲染

01:31:15.400 --> 01:31:18.640
就是我可以控制的

01:31:18.640 --> 01:31:23.350
我可以灵活控制的

01:31:23.350 --> 01:31:25.270
看着啊

01:31:25.270 --> 01:31:26.230
我第一次可以

01:31:26.230 --> 01:31:27.830
我可以让第一次在这里渲染

01:31:27.830 --> 01:31:29.110
第二次在这里渲染

01:31:29.190 --> 01:31:30.230
对吧

01:31:30.230 --> 01:31:31.430
我可以控制的

01:31:31.430 --> 01:31:32.390
可以灵活控制

01:31:32.390 --> 01:31:36.230
那么怎么来达到这个要这样的一个要求呢

01:31:36.230 --> 01:31:37.190
其实

01:31:37.190 --> 01:31:39.190
我们可以这样做

01:31:39.190 --> 01:31:42.070
我们在这个组件里面呢去做一些处理

01:31:42.070 --> 01:31:43.430
比方有什么处理的

01:31:43.430 --> 01:31:49.680
我在这里记录一个data

01:31:49.680 --> 01:31:52.240
里面一个属性叫做

01:31:52.240 --> 01:31:55.520
当前的

01:31:55.520 --> 01:31:56.960
shrimcult

01:31:56.960 --> 01:31:58.400
当前渲染的次数

01:31:58.400 --> 01:32:01.120
就当前浏览器渲染了多少次

01:32:01.120 --> 01:32:06.560
当前浏览器渲染了多少次

01:32:06.560 --> 01:32:08.320
好那么这个东西我在什么

01:32:08.320 --> 01:32:09.280
不让你去更改它

01:32:09.280 --> 01:32:10.000
什么时候更改它

01:32:10.000 --> 01:32:13.000
可以记得

01:32:13.000 --> 01:32:13.960
创建的时候

01:32:13.960 --> 01:32:15.320
我通过什么来更改它

01:32:15.320 --> 01:32:18.760
我通过那个sets

01:32:18.760 --> 01:32:19.880
拜拜

01:32:19.880 --> 01:32:21.800
request animation

01:32:21.800 --> 01:32:22.840
是不是就是刚才这个

01:32:22.840 --> 01:32:23.720
这个函数啊

01:32:23.720 --> 01:32:25.000
是不是就是这个函数

01:32:25.000 --> 01:32:25.400
对吧

01:32:25.400 --> 01:32:29.920
把这个套娃拿过来吧

01:32:30.080 --> 01:32:32.400
我在这

01:32:32.400 --> 01:32:34.160
所以每一次渲染之后

01:32:34.160 --> 01:32:39.120
每一次浏览器渲染之后

01:32:39.120 --> 01:32:41.520
每一次浏览器渲染之后干嘛呀

01:32:41.520 --> 01:32:42.800
我把这个f

01:32:42.800 --> 01:32:45.120
request framecult加加

01:32:45.120 --> 01:32:47.970
是不是加一

01:32:47.970 --> 01:32:48.610
可以吧

01:32:48.610 --> 01:32:48.850
可以

01:32:48.850 --> 01:32:49.890
那么这个数字可以记住

01:32:49.890 --> 01:32:52.210
每一浏览器渲染了多少次

01:32:52.210 --> 01:32:53.570
那么我们比方说

01:32:53.570 --> 01:32:54.930
我只关心

01:32:54.930 --> 01:32:56.610
浏览器渲染的前30次

01:32:56.610 --> 01:32:57.650
比方说30次以内

01:32:57.650 --> 01:32:59.890
我一定要把这个东西全部渲染出来

01:32:59.970 --> 01:33:01.730
我只关心它的前30次

01:33:01.730 --> 01:33:03.890
那么我就可以设置一个最大值

01:33:03.890 --> 01:33:04.530
好

01:33:04.530 --> 01:33:07.620
如果说

01:33:07.620 --> 01:33:09.940
我这里把这个玩意儿写成一个函数啊

01:33:09.940 --> 01:33:13.750
把它写成个函数

01:33:13.750 --> 01:33:14.870
嗯

01:33:14.870 --> 01:33:16.550
frame

01:33:16.550 --> 01:33:17.830
add

01:33:17.830 --> 01:33:20.310
写这么一个函数啊

01:33:20.310 --> 01:33:21.430
好看着啊

01:33:21.430 --> 01:33:22.390
嗯

01:33:22.390 --> 01:33:24.390
我这个这个里边干嘛

01:33:24.390 --> 01:33:25.990
就是每一次浏览器渲染之后

01:33:25.990 --> 01:33:26.870
把它加一

01:33:26.870 --> 01:33:27.830
加一了过后呢

01:33:27.830 --> 01:33:28.870
我判断一下

01:33:28.870 --> 01:33:30.230
sets framecult

01:33:30.230 --> 01:33:32.230
是不是大于

01:33:32.310 --> 01:33:34.790
是不是小于30

01:33:34.790 --> 01:33:36.470
小于30是不是我们还要不断的记录

01:33:36.470 --> 01:33:38.070
一直要记录到30次

01:33:38.070 --> 01:33:40.950
30次过后我就不管了

01:33:40.950 --> 01:33:41.670
原来的意思吧

01:33:41.670 --> 01:33:42.150
好

01:33:42.150 --> 01:33:43.270
只要它小于30

01:33:43.270 --> 01:33:45.990
我就重新调用这个函数

01:33:45.990 --> 01:33:46.150
好

01:33:46.150 --> 01:33:47.030
你看看

01:33:47.030 --> 01:33:47.910
我可以记得时候

01:33:47.910 --> 01:33:49.510
一开始调用一次

01:33:49.510 --> 01:33:50.310
在一开始的时候

01:33:50.310 --> 01:33:51.430
调用一次这个函数

01:33:51.430 --> 01:33:52.470
那是不是

01:33:52.470 --> 01:33:55.270
函数就会在下一次渲染之后

01:33:55.270 --> 01:33:55.750
加一

01:33:55.750 --> 01:33:57.270
表示渲染一次了

01:33:57.270 --> 01:33:58.870
然后呢由于以小于30

01:33:58.870 --> 01:34:00.470
它又重新调用这个函数

01:34:00.470 --> 01:34:01.190
又重新调用过后

01:34:01.190 --> 01:34:03.030
就是又是高速浏览器

01:34:03.030 --> 01:34:05.750
再下一次渲染过后加一

01:34:05.750 --> 01:34:06.790
是不是这个

01:34:06.790 --> 01:34:07.830
就是变成二了

01:34:07.830 --> 01:34:08.470
二小于30

01:34:08.470 --> 01:34:09.430
然后就不断的调用

01:34:09.430 --> 01:34:11.190
直到它等于30为止

01:34:11.190 --> 01:34:12.390
那么这样子呢

01:34:12.390 --> 01:34:13.590
就是隔一段时间

01:34:13.590 --> 01:34:14.710
渲染一次过后

01:34:14.710 --> 01:34:15.270
这个加一

01:34:15.270 --> 01:34:16.070
渲染一次过后加一

01:34:16.070 --> 01:34:18.550
就达到这么一个效果

01:34:18.550 --> 01:34:19.110
好

01:34:19.110 --> 01:34:20.630
然后这边我就可以玩得很

01:34:20.630 --> 01:34:21.190
很happy了

01:34:21.190 --> 01:34:24.370
你看我怎么玩

01:34:24.370 --> 01:34:25.890
我这样子写

01:34:25.890 --> 01:34:30.070
vif

01:34:30.070 --> 01:34:33.190
什么情况下我要显示它呢

01:34:33.190 --> 01:34:36.800
我这里写个message

01:34:36.800 --> 01:34:38.960
叫做diff

01:34:38.960 --> 01:34:41.200
表示我延迟加载

01:34:41.200 --> 01:34:42.480
就是我要不要渲染它

01:34:42.480 --> 01:34:44.400
你给我一个n

01:34:44.400 --> 01:34:44.960
啥意思

01:34:44.960 --> 01:34:46.960
就表示

01:34:46.960 --> 01:34:50.240
目前的渲染次数

01:34:50.240 --> 01:34:53.200
是否达到了n

01:34:53.200 --> 01:34:55.200
就这么个意思

01:34:55.200 --> 01:34:55.760
反回什么

01:34:55.760 --> 01:34:56.400
反回非常简单

01:34:56.400 --> 01:34:57.360
Restream called

01:34:57.360 --> 01:34:59.680
是不是大约等于n

01:34:59.680 --> 01:35:00.720
比方你给我传个10

01:35:00.720 --> 01:35:01.840
表示目前的渲染次数

01:35:01.840 --> 01:35:04.160
有没有大约等于10

01:35:04.240 --> 01:35:05.200
那么这里看

01:35:05.200 --> 01:35:08.240
我就可以这样写diff

01:35:08.240 --> 01:35:09.920
我这里可以有很多种写法

01:35:09.920 --> 01:35:11.120
因为我这里是循环生存的

01:35:11.120 --> 01:35:12.000
但是真实项目里边

01:35:12.000 --> 01:35:12.480
一般来说

01:35:12.480 --> 01:35:13.760
这些都是不同的组件

01:35:13.760 --> 01:35:14.960
你不会循环生存的

01:35:14.960 --> 01:35:16.320
那么你可以给某一个组件

01:35:16.320 --> 01:35:17.360
写上一个1

01:35:17.360 --> 01:35:19.280
表示它的第一次渲染之后

01:35:19.280 --> 01:35:20.080
它就要渲染了

01:35:20.080 --> 01:35:20.960
它就会返回to

01:35:20.960 --> 01:35:22.000
那么我就渲染它

01:35:22.000 --> 01:35:23.040
那么第一次渲染之前

01:35:23.040 --> 01:35:23.920
它返回的是force

01:35:23.920 --> 01:35:24.960
我就不渲染它

01:35:24.960 --> 01:35:26.880
是不是会减少这个组件的渲染

01:35:26.880 --> 01:35:27.120
对不对

01:35:27.120 --> 01:35:27.920
就是这么个意思

01:35:27.920 --> 01:35:28.960
那么如果说下一个组件

01:35:28.960 --> 01:35:29.920
我就可以写3

01:35:29.920 --> 01:35:31.200
下一个组件我就可以写7

01:35:31.200 --> 01:35:32.320
就是你可以自己

01:35:32.320 --> 01:35:33.200
根据这个时间

01:35:33.600 --> 01:35:34.480
自己来定义

01:35:34.480 --> 01:35:35.760
那么这里我就非常简单的

01:35:35.760 --> 01:35:37.120
把它写上一个n

01:35:37.120 --> 01:35:38.480
就表示你是第几个组件

01:35:38.480 --> 01:35:40.080
我就选人第几次

01:35:40.080 --> 01:35:42.480
就是第几帧过后我就选人

01:35:42.480 --> 01:35:43.360
那么这样子你写了过后

01:35:43.360 --> 01:35:46.770
你看一下

01:35:46.770 --> 01:35:47.090
嗯

01:35:47.090 --> 01:35:48.130
我错了

01:35:48.130 --> 01:35:49.650
firm idd is not function

01:35:51.890 --> 01:35:52.850
哦

01:35:52.850 --> 01:35:54.610
这里还要加上这个

01:35:54.610 --> 01:35:56.050
这还是一个函数

01:35:59.680 --> 01:36:00.640
这样才对

01:36:02.240 --> 01:36:02.720
好

01:36:02.720 --> 01:36:03.040
你看

01:36:08.550 --> 01:36:10.550
是不是没有什么白平的时间呢

01:36:10.550 --> 01:36:12.550
白平的时间是不是大到减少了

01:36:13.510 --> 01:36:14.150
对不对

01:36:14.150 --> 01:36:14.950
不大到减少了

01:36:15.750 --> 01:36:15.990
啊

01:36:15.990 --> 01:36:17.830
就这这这就是它的这种做法

01:36:17.830 --> 01:36:19.350
那么它是一式宣传出来的

01:36:20.630 --> 01:36:21.350
就这么个意思

01:36:22.790 --> 01:36:23.990
那就这种做法

01:36:23.990 --> 01:36:24.630
那么这种做法呢

01:36:24.630 --> 01:36:25.910
其实写单码的比较麻烦

01:36:25.910 --> 01:36:26.630
而且这种做法呢

01:36:26.630 --> 01:36:27.990
是具有普世性的

01:36:27.990 --> 01:36:28.870
所以说一般来说呢

01:36:28.870 --> 01:36:30.070
我们会把这个东西呢

01:36:30.070 --> 01:36:31.350
抽象成为一个max

01:36:31.350 --> 01:36:32.150
就是一个混合

01:36:32.790 --> 01:36:32.870
啊

01:36:32.870 --> 01:36:34.230
这又是五月的高级用法了啊

01:36:35.270 --> 01:36:35.350
啊

01:36:35.350 --> 01:36:36.470
有时候我们可以把一些

01:36:36.470 --> 01:36:38.230
通用的配置啊抽离出来

01:36:38.230 --> 01:36:39.110
抽离成一个混合

01:36:39.830 --> 01:36:40.550
你看这些什么

01:36:40.550 --> 01:36:41.830
message里边的defer

01:36:42.550 --> 01:36:43.110
方法

01:36:43.110 --> 01:36:45.190
和create的神秘中心函数

01:36:45.190 --> 01:36:46.230
还有这个data里边的东西

01:36:46.230 --> 01:36:47.430
都可以抽离出去的吧

01:36:47.430 --> 01:36:48.790
抽离出去一个混合

01:36:48.790 --> 01:36:50.790
那么你看我这边就抽离出去了

01:36:50.790 --> 01:36:51.750
我写了一个函数

01:36:51.750 --> 01:36:52.630
你雕用这个函数呢

01:36:52.630 --> 01:36:54.230
我就会返回一个组件配置

01:36:54.230 --> 01:36:55.510
你看那个配置里边是不是data

01:36:56.150 --> 01:36:57.750
multi的里边是不是就这个东西

01:36:57.750 --> 01:36:57.910
啊

01:36:57.910 --> 01:36:59.830
我这个名字只是用的这个名字

01:36:59.830 --> 01:37:00.390
对吧

01:37:00.390 --> 01:37:01.270
然后呢这个defer

01:37:01.830 --> 01:37:02.470
是不是一样的

01:37:03.190 --> 01:37:04.310
一模之前写的是n

01:37:04.310 --> 01:37:05.030
这里写的是这个

01:37:05.030 --> 01:37:05.590
是不是一样的

01:37:05.590 --> 01:37:06.390
就把这些组件

01:37:06.390 --> 01:37:07.830
把这些配置抽离出去

01:37:07.830 --> 01:37:08.390
然后呢

01:37:08.390 --> 01:37:09.510
最大的最大的就是

01:37:09.590 --> 01:37:10.550
我们要关心的

01:37:10.550 --> 01:37:11.350
最大的数量呢

01:37:11.350 --> 01:37:12.710
你给我通过参数传进来

01:37:13.270 --> 01:37:14.390
你看就相当于是个参数

01:37:14.390 --> 01:37:14.870
相当于什么

01:37:14.870 --> 01:37:15.910
相当于是这里的30

01:37:17.110 --> 01:37:18.310
那么如果这个defer过后了

01:37:18.310 --> 01:37:18.790
你看

01:37:18.790 --> 01:37:19.910
我们就可以用这种写法

01:37:20.710 --> 01:37:21.350
延迟加载

01:37:23.720 --> 01:37:24.200
我这个

01:37:24.200 --> 01:37:25.480
我这个组件写的很简单的

01:37:26.280 --> 01:37:28.360
我直接用message配置

01:37:28.360 --> 01:37:29.720
我就是把混合进来

01:37:29.720 --> 01:37:30.760
我雕用这个defer

01:37:32.760 --> 01:37:33.800
雕用这个函数

01:37:34.920 --> 01:37:36.360
你看我把个defer

01:37:36.360 --> 01:37:37.080
导入进来

01:37:37.080 --> 01:37:38.120
然后该要传一个21

01:37:38.120 --> 01:37:40.040
表示我这里只关心21次

01:37:40.120 --> 01:37:40.680
写法的时候呢

01:37:40.680 --> 01:37:41.480
我不管了

01:37:41.480 --> 01:37:42.600
我只关心21次

01:37:43.880 --> 01:37:45.400
那么在21次内

01:37:46.200 --> 01:37:46.920
第一次渲染

01:37:48.280 --> 01:37:49.080
我写到这的

01:37:49.080 --> 01:37:50.120
写到这跟写到这

01:37:50.120 --> 01:37:51.400
其实也都可以

01:37:51.400 --> 01:37:51.800
都可以

01:37:52.360 --> 01:37:52.840
那么都行

01:37:54.680 --> 01:37:55.560
第一次渲染呢

01:37:55.560 --> 01:37:57.000
我延迟到

01:37:57.000 --> 01:37:58.600
就第一次这个defer

01:37:58.600 --> 01:37:59.560
我延迟到这个

01:38:00.200 --> 01:38:01.320
第一针之后

01:38:01.320 --> 01:38:02.360
第二次这个defer

01:38:02.360 --> 01:38:03.480
我延迟到第二针之后

01:38:04.040 --> 01:38:04.840
就这么一一次

01:38:05.400 --> 01:38:05.960
那么效果呢

01:38:05.960 --> 01:38:06.760
你看一下

01:38:06.760 --> 01:38:07.400
同样的效果

01:38:07.880 --> 01:38:08.840
它渲染的速度呢

01:38:08.840 --> 01:38:09.160
你看

01:38:12.130 --> 01:38:13.330
它就是一时渲染出来了

01:38:13.890 --> 01:38:16.210
这就是用这种延迟加在的方式

01:38:17.570 --> 01:38:17.810
好

01:38:17.810 --> 01:38:18.210
最后呢

01:38:18.210 --> 01:38:18.690
两个呢

01:38:18.690 --> 01:38:19.650
就给它写在这

01:38:19.650 --> 01:38:21.090
因为我确实没有时间讲了

01:38:21.090 --> 01:38:22.130
之前备课的时候

01:38:22.130 --> 01:38:23.170
我也觉得没有时间讲

01:38:24.050 --> 01:38:25.250
咱们之前在

01:38:25.810 --> 01:38:27.730
给后期咱们全家班农同学

01:38:27.730 --> 01:38:29.170
讲那个课程的时候

01:38:29.170 --> 01:38:29.890
这两个东西呢

01:38:29.890 --> 01:38:31.810
也是单独拿成两节课来讲的

01:38:32.450 --> 01:38:33.170
我简单说一下

01:38:33.170 --> 01:38:33.810
tiponlime呢

01:38:33.810 --> 01:38:34.850
就是能够

01:38:34.850 --> 01:38:36.530
它在切换组件显示的时候

01:38:37.090 --> 01:38:38.290
它通过被异服来

01:38:38.290 --> 01:38:39.330
切换组件显示的时候

01:38:39.330 --> 01:38:40.850
它能够保留那个组件的实力

01:38:41.490 --> 01:38:43.010
避免重新创建实力

01:38:43.010 --> 01:38:43.970
这里边

01:38:43.970 --> 01:38:45.010
tiponlime还

01:38:45.010 --> 01:38:47.010
是非常容易单独出一个面试题的

01:38:47.010 --> 01:38:49.570
让你讲tiponlime的原理

01:38:50.930 --> 01:38:52.530
然后长列表优化什么意思呢

01:38:52.530 --> 01:38:53.090
就是如果说

01:38:53.090 --> 01:38:54.610
我们用手移动端去刷

01:38:54.610 --> 01:38:55.890
不停的上拉

01:38:55.890 --> 01:38:56.610
加载更多

01:38:56.610 --> 01:38:57.170
加载更多

01:38:57.170 --> 01:38:58.130
就比方刷微博啊

01:38:58.130 --> 01:38:59.170
刷一刷一东西

01:38:59.170 --> 01:39:00.610
所以这个列表就会越来越长

01:39:00.610 --> 01:39:01.250
越来越长

01:39:01.810 --> 01:39:03.170
如果说你刷一个通销

01:39:03.170 --> 01:39:05.330
那么这个列表可能就有几万条数学

01:39:05.330 --> 01:39:06.210
非常不得了了

01:39:06.210 --> 01:39:07.010
那么这个这个时候

01:39:07.010 --> 01:39:08.050
页面就会很卡顿

01:39:08.050 --> 01:39:09.570
那么这个时候该怎么去优化

01:39:10.530 --> 01:39:11.490
就讲的是这两个东西

01:39:11.490 --> 01:39:11.970
这两个东西呢

01:39:11.970 --> 01:39:12.770
都需要单独来

01:39:12.770 --> 01:39:13.410
有一些课来讲

01:39:13.410 --> 01:39:14.210
我就没有时间了

01:39:14.210 --> 01:39:15.410
但他们也是会作为

01:39:15.410 --> 01:39:17.250
无忧的一个常见的优化手段

01:39:17.250 --> 01:39:17.970
我写到这

01:39:19.330 --> 01:39:19.810
OK

