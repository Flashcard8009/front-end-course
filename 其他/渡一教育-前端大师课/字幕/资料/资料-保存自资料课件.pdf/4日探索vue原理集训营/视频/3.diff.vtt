WEBVTT

00:00.820 --> 00:03.620
好 今天咱们讲这个地方

00:03.620 --> 00:06.620
实际上在无忧的整个系统里边

00:06.620 --> 00:09.220
如果说你自己要去写代码

00:09.220 --> 00:10.620
去实现一个无忧的话

00:10.620 --> 00:12.420
就自己熟悉一个无忧的话

00:12.420 --> 00:14.820
最麻烦的应该是这一块

00:14.820 --> 00:18.020
应该是模板编译

00:18.020 --> 00:19.220
对于自己熟悉的话

00:19.220 --> 00:20.820
最麻烦是这一块

00:20.820 --> 00:23.020
但这一块它并不复杂

00:23.020 --> 00:27.020
它只是比较繁术 比较麻烦

00:27.020 --> 00:29.420
最复杂的其实就是我们昨天讲的

00:29.420 --> 00:33.220
那个响应系统

00:33.220 --> 00:34.820
最复杂的就是这一块

00:34.820 --> 00:36.820
那一块其实它代码并不多

00:36.820 --> 00:39.820
代码加起来可能五六百行

00:39.820 --> 00:41.420
七八百行那个样子

00:41.420 --> 00:42.420
代码并不多

00:42.420 --> 00:45.620
但它里边设计到极其精妙

00:45.620 --> 00:47.620
今天我们讲的这个地府算法

00:47.620 --> 00:50.220
其实它写代码确实比较麻烦

00:50.220 --> 00:53.020
但它其实原理并不复杂

00:53.020 --> 00:54.020
原理还是蛮简单的

00:54.020 --> 00:55.820
所以今天的课难度上

00:55.820 --> 00:58.020
要比昨天要小一些

00:58.020 --> 01:00.620
我首先给大家说一下

01:00.620 --> 01:03.220
然后这里在我们上课之前

01:03.220 --> 01:06.820
这里有一道题

01:06.820 --> 01:09.220
我昨天忘了讲了

01:09.220 --> 01:09.820
忘了说了

01:09.820 --> 01:12.220
我今天给大家补充一下

01:12.220 --> 01:15.220
这道题是关于LexTech的题

01:15.220 --> 01:18.020
其实我们昨天的知识就能够用上了

01:18.020 --> 01:18.220
好

01:18.220 --> 01:19.620
咱们再看一下这道题

01:19.620 --> 01:22.020
这道题其实代码也不多

01:22.020 --> 01:23.620
就说现在我们有个模板

01:23.620 --> 01:24.820
这个模板里面显示啥

01:24.820 --> 01:26.220
显示一个H1元素

01:26.220 --> 01:27.620
H1元素有一个ID

01:27.820 --> 01:31.260
然后里边有一个ABCD

01:31.260 --> 01:32.060
有一个按钮

01:32.060 --> 01:33.460
这个ABCD的数据你看一下

01:33.460 --> 01:34.160
1234

01:34.160 --> 01:35.060
比如说这里面显示

01:35.060 --> 01:38.060
一开始显示出来肯定就是1234

01:38.060 --> 01:38.860
1234

01:38.860 --> 01:40.060
非常简单

01:40.060 --> 01:43.660
然后下面有一个按钮叫Change All

01:43.660 --> 01:47.260
这里有一个函数叫HandleChange

01:47.260 --> 01:49.060
然后这个函数里边

01:49.060 --> 01:51.060
我写了这么个代码

01:51.060 --> 01:53.160
叫做Znextech

01:53.160 --> 01:54.460
这个nextech的功能

01:54.460 --> 01:56.860
跟我们昨天介绍的那个nextech

01:56.860 --> 01:58.360
完全一样

01:58.360 --> 01:59.360
它会把这个

01:59.360 --> 02:01.360
它会把你传入了这个函数

02:01.360 --> 02:04.360
放入到微对里

02:04.360 --> 02:05.860
然后下面有四个

02:05.860 --> 02:07.360
我们写了四条语句

02:07.360 --> 02:10.660
分别去改变ABCD的值

02:10.660 --> 02:12.360
接下来有个Render函数

02:12.360 --> 02:13.160
这个Render函数

02:13.160 --> 02:15.160
我主要是为了去输出一句话

02:15.160 --> 02:16.960
就输出这个Render

02:16.960 --> 02:18.360
这个Render函数显示的东西

02:18.360 --> 02:19.660
反回的虚的多么

02:19.660 --> 02:21.560
其实跟这里是完全一样的

02:21.560 --> 02:23.360
跟这个模板是完全一样的

02:23.360 --> 02:25.360
也就是你不写这个Render函数

02:25.360 --> 02:26.560
它本身就会把这个模板

02:26.560 --> 02:28.160
编译成Render函数

02:28.160 --> 02:30.460
不过我这里为了去输出一个Render

02:30.460 --> 02:32.460
我这里专门自己写到一边

02:32.460 --> 02:33.860
我就为输出一个Render

02:33.860 --> 02:35.060
然后这里边写的东西

02:35.060 --> 02:36.460
跟上面是完全一样的

02:36.460 --> 02:37.860
你不用看了

02:37.860 --> 02:39.660
所以说你可以看到一开始的显示

02:39.660 --> 02:41.460
除了1234

02:41.460 --> 02:43.260
那么一开始肯定要运行Render

02:43.260 --> 02:44.660
这个毫无疑问的

02:44.660 --> 02:45.860
要运行Render

02:45.860 --> 02:48.560
这个提到下面还有一个

02:48.560 --> 02:51.460
下面还有一句话

02:51.460 --> 02:53.360
先把这个关了

02:53.360 --> 02:57.160
下面会输出一个

02:57.160 --> 03:00.490
就输出一个E

03:00.490 --> 03:02.590
那么现在第一个问题

03:02.590 --> 03:04.390
这到底是第一个问题

03:04.390 --> 03:04.990
请问

03:04.990 --> 03:06.890
最开始的时候

03:06.890 --> 03:11.100
它会输出什么东西

03:11.100 --> 03:12.300
大家回答一下

03:12.300 --> 03:14.200
最开始的时候

03:14.200 --> 03:15.000
它会输出什么

03:15.000 --> 03:16.300
不是显示什么东西

03:16.300 --> 03:18.200
显示肯定是1234

03:18.200 --> 03:22.310
它会输出什么样的东西

03:22.310 --> 03:23.510
肯定要输出E

03:23.510 --> 03:25.010
但是你不要忽略Render

03:25.010 --> 03:26.010
Render和E

03:26.010 --> 03:26.810
谁先输出

03:26.810 --> 03:29.840
谁后输出

03:29.840 --> 03:32.140
E和Render之间

03:32.140 --> 03:33.040
他们谁先输出

03:33.040 --> 03:35.920
谁后输出

03:35.920 --> 03:39.520
是E Render还是RenderE

03:39.520 --> 03:40.420
要打拳吗

03:40.420 --> 03:44.250
要打完吗

03:44.250 --> 03:48.410
E Render吗

03:48.410 --> 03:51.410
老师我咋什么都听啊

03:51.410 --> 03:52.210
疼

03:52.210 --> 03:54.910
这是啥意思

03:54.910 --> 03:56.310
你什么都听不懂吗

03:56.310 --> 03:57.810
你是说

03:57.810 --> 03:59.210
就是如果什么都听不懂的话

03:59.210 --> 04:01.210
它肯定是基础部分有问题

04:01.210 --> 04:02.910
就是你

04:02.910 --> 04:04.110
无忧的一些基础

04:04.110 --> 04:06.210
还甚至包括GES的一些技术

04:06.210 --> 04:10.180
肯定是有问题

04:10.180 --> 04:10.980
我没学过这样

04:10.980 --> 04:11.980
那是正常的

04:11.980 --> 04:12.480
熊大

04:12.480 --> 04:13.180
熊大同学

04:13.180 --> 04:14.180
那是正常的

04:14.180 --> 04:15.280
那你慢慢先啃吧

04:15.280 --> 04:17.380
先把这个无忧的基础部分先啃

04:17.380 --> 04:18.880
就是你首先得

04:18.880 --> 04:21.080
能够用无忧来做出一点东西

04:21.080 --> 04:22.880
甭管是做一个轮波图啊

04:22.880 --> 04:24.280
还是做一些小的demo啊

04:24.280 --> 04:24.980
都行

04:24.980 --> 04:25.680
随便你做

04:25.680 --> 04:26.880
你只要做过一点东西

04:26.880 --> 04:27.880
咱要倾这个课呢

04:27.880 --> 04:29.080
你会很有收获

04:29.080 --> 04:30.780
如果说你完全没有学过无忧的话

04:30.780 --> 04:31.580
听那个课呢

04:31.580 --> 04:32.220
确实肯定是

04:32.220 --> 04:33.380
肯定是要蒙的啊

04:33.380 --> 04:33.880
因为这个课呢

04:33.880 --> 04:34.980
本身就是给

04:34.980 --> 04:36.480
学过无忧的同学准备的

04:36.480 --> 04:37.880
那如果说你现在没有学过无忧的话

04:37.880 --> 04:39.280
这个课你绝对不吃亏

04:39.280 --> 04:40.480
你绝对不吃亏的

04:40.480 --> 04:41.780
因为你会发现了

04:41.780 --> 04:43.080
你以后在互联网上

04:43.080 --> 04:48.620
你也就找不到这样的课了

04:48.620 --> 04:49.220
怎么说出呢

04:49.220 --> 04:50.720
是一Render还是Render一呢

04:50.720 --> 04:51.420
我会发现啊

04:51.420 --> 04:53.220
发现有同学

04:53.220 --> 04:55.120
好多同学认为是一Render是吧

04:55.120 --> 04:56.920
那么如果说你认为是一Render的话

04:56.920 --> 04:59.020
那你肯定认为这个Render函数的执行呢

04:59.020 --> 05:00.320
它是一步的

05:00.320 --> 05:02.320
那么昨天我其实给大家说了啊

05:02.320 --> 05:04.220
在第一次执行的时候

05:04.220 --> 05:06.220
实际上它是同步执行的

05:06.220 --> 05:07.420
为什么是同步执行呢

05:07.420 --> 05:08.820
你要知道为什么啊

05:08.820 --> 05:09.820
为什么是同步执行呢

05:09.920 --> 05:13.220
是因为这个Render函数是放到Watcher里面的

05:13.220 --> 05:13.720
啊

05:13.720 --> 05:15.120
我们这个Render函数啊

05:15.120 --> 05:17.120
实际上是放到这个Watcher里面执行的

05:18.620 --> 05:19.520
知道吧

05:19.520 --> 05:20.820
昨天我给大家看了一个代码

05:20.820 --> 05:21.320
对吧

05:21.320 --> 05:23.320
它是放到这个Watcher函数里面执行的

05:23.320 --> 05:24.820
而Watcher函数里面放了一个函数

05:24.820 --> 05:26.720
它会首先把它执行一遍

05:26.720 --> 05:27.820
那么这个时候呢

05:27.820 --> 05:30.120
它是同步执行的

05:30.120 --> 05:32.320
实际上Watcher的功能非常强大

05:32.320 --> 05:34.820
它可以支持同步也可以支持一步啊

05:34.820 --> 05:36.020
只不过呢

05:36.020 --> 05:37.320
默认情况下啊

05:37.320 --> 05:39.020
一开始都是同步执行的

05:39.020 --> 05:40.020
所以说呢

05:40.020 --> 05:41.920
这个Render函数

05:41.920 --> 05:43.520
实际上它会先输出Render

05:43.520 --> 05:44.620
然后再输出1

05:44.620 --> 05:47.820
咱们来看一下

05:47.820 --> 05:49.220
是不是Render1

05:49.220 --> 05:49.520
对吧

05:49.520 --> 05:51.420
这是第一开始

05:51.420 --> 05:52.120
然后接下来

05:52.120 --> 05:55.020
我再问大家一个问题啊

05:55.020 --> 05:57.720
接下来就比较麻烦了

05:57.720 --> 05:59.720
好好看

05:59.720 --> 06:02.520
Negastake可以扩展一下这个吧

06:02.520 --> 06:03.320
这个其实很简单

06:03.320 --> 06:05.920
我昨天其实就已经给他说了

06:05.920 --> 06:06.920
这个Negastake呢

06:06.920 --> 06:09.520
其实就是以传入一个函数

06:09.520 --> 06:10.020
然后呢

06:10.020 --> 06:11.320
它会执行这个函数

06:11.320 --> 06:12.520
但是执行的时候呢

06:12.520 --> 06:14.420
它是把它加到微对列里面的

06:14.420 --> 06:16.020
而且它里面的实现方式

06:16.020 --> 06:16.920
我给大家说了

06:16.920 --> 06:18.320
它的实现方式非常简单

06:18.320 --> 06:19.620
你不是传了一个函数进去吗

06:19.620 --> 06:20.220
对不对

06:20.220 --> 06:24.430
我就给大家写个伟大码啊

06:24.430 --> 06:25.430
你传了一个函数进去

06:25.430 --> 06:25.930
对吧

06:25.930 --> 06:29.430
那么它的做的事情就是Promise

06:29.430 --> 06:30.630
其实它没有那么简单啊

06:30.630 --> 06:32.030
它是里面是有个对列

06:32.030 --> 06:33.030
我们不管

06:33.030 --> 06:33.530
我们这里呢

06:33.530 --> 06:35.830
就写个非常简单的函数啊

06:35.830 --> 06:39.730
PromiseResultZ

06:40.730 --> 06:41.630
它就这样写的

06:41.630 --> 06:43.130
所以说你这个函数

06:43.130 --> 06:45.230
是不是放到一个微对列里面去执行呢

06:45.230 --> 06:45.630
对吧

06:45.630 --> 06:45.930
这里呢

06:45.930 --> 06:48.430
我们直接构造了一个

06:48.430 --> 06:51.430
已经完成的Promise

06:51.430 --> 06:51.830
然后呢

06:51.830 --> 06:52.930
告诉它完成之后

06:52.930 --> 06:54.830
运行这个函数

06:54.830 --> 06:56.230
所以就这么简单

06:56.230 --> 06:57.030
并不复杂啊

06:57.030 --> 06:59.030
它非常简单的

06:59.030 --> 07:00.430
只不过它不是这么简单

07:00.430 --> 07:01.030
它这个代码

07:01.030 --> 07:02.430
其实它里面代码不是那么简单

07:02.430 --> 07:04.130
还是有那么几次行

07:04.130 --> 07:05.030
它维护了一个数组

07:05.030 --> 07:05.930
维护了一个对列

07:05.930 --> 07:07.530
其实无论是维护什么对列

07:07.530 --> 07:08.630
那个对列里面的函数

07:08.730 --> 07:11.730
它最终都是到微对列里面去执行

07:11.730 --> 07:12.330
就这么简单

07:12.330 --> 07:14.130
就这么一个意思啊

07:14.130 --> 07:15.330
那么现在问题

07:15.330 --> 07:18.730
我们点击到这个安扭之后

07:18.730 --> 07:19.830
是不是ABCD要改变

07:19.830 --> 07:21.830
你看就运行这个代码

07:21.830 --> 07:23.930
那么请问点击安扭过后

07:23.930 --> 07:26.230
它输出啥

07:26.230 --> 07:28.630
这个好好看一下吧

07:28.630 --> 07:29.830
点击安扭过后

07:29.830 --> 07:33.760
它会输出啥

07:33.760 --> 07:34.960
这道题其实并不简单

07:34.960 --> 07:36.560
并不并不复杂

07:36.560 --> 07:38.360
Render1

07:38.360 --> 07:39.560
第二个问题好好看一下

07:39.660 --> 07:47.100
根据我们昨天学过的知识

07:47.100 --> 07:48.500
现在呢有这么一个函数

07:50.300 --> 07:51.400
我放到nextec里边

07:53.100 --> 07:57.960
然后呢我这里去改变了ABCD

07:57.960 --> 07:59.860
那么首先改变了ABCD

07:59.860 --> 08:01.260
它肯定要运行什么

08:01.260 --> 08:02.260
运行watcher

08:02.260 --> 08:02.460
对吧

08:02.460 --> 08:04.060
因为我们数据变了

08:04.060 --> 08:04.960
而我们界面上

08:04.960 --> 08:07.260
界面是依赖的数据的

08:07.260 --> 08:08.860
所以说你会看到这一步

08:09.860 --> 08:14.500
这一步一定将watcher

08:14.500 --> 08:15.500
添加到

08:16.100 --> 08:19.400
添加到nextec中

08:19.400 --> 08:19.900
对吧

08:19.900 --> 08:21.300
所以添加到scheduler中

08:21.300 --> 08:21.500
对吧

08:21.500 --> 08:23.200
scheduler一般添加到nextec中

08:23.200 --> 08:23.900
对不对

08:23.900 --> 08:25.600
那么这里呢也是一样

08:25.600 --> 08:28.000
但是以为他们几个watcher都是一样的

08:28.000 --> 08:29.400
都指的是宣传函数

08:29.400 --> 08:31.000
所以说他们只会添加一次

08:31.000 --> 08:32.900
他并不会添加多次

08:32.900 --> 08:34.300
这是我们昨天讲的

08:35.600 --> 08:37.400
那么也就说添加watcher什么意思呢

08:37.400 --> 08:39.300
其实就是要运行Render

08:39.300 --> 08:40.100
那么说白了

08:40.100 --> 08:41.100
这句话干嘛呢

08:41.100 --> 08:44.900
就是Render被添加

08:44.900 --> 08:48.650
到nextec

08:48.650 --> 08:50.050
那么这里也是一样

08:50.050 --> 08:51.450
Render被添加进去了

08:51.450 --> 08:52.050
这里也是一样

08:53.850 --> 08:55.850
但是呢只会添加一次

08:55.850 --> 08:57.350
所以说他Render函数要不要执行

08:57.350 --> 08:58.950
肯定要执行

08:58.950 --> 08:59.950
这个函数要不要执行

08:59.950 --> 09:01.350
也肯定要执行

09:01.350 --> 09:02.750
那么现在的问题就是

09:02.750 --> 09:04.750
到底是先执行Render

09:04.750 --> 09:06.850
还是先执行他

09:06.850 --> 09:07.650
这个很关键

09:09.150 --> 09:10.250
那么到底是先执行

09:10.250 --> 09:11.650
我们这个自定义函数呢

09:11.650 --> 09:12.850
还是先执行Render呢

09:14.450 --> 09:16.050
因为我们的Render也好

09:16.050 --> 09:17.650
还是这个自定义函数也好

09:17.650 --> 09:20.050
是不是都会被添加到nextec

09:20.050 --> 09:20.750
对不对

09:20.750 --> 09:22.650
那么他里边是有个对列的

09:22.650 --> 09:25.050
谁先进去就运行谁

09:26.250 --> 09:27.350
那么谁先进去

09:27.350 --> 09:28.950
是不是他先进去

09:28.950 --> 09:31.050
除了说我们的函数运行顺序

09:31.050 --> 09:32.850
他一定是先运行他

09:33.850 --> 09:34.850
都是一步执行

09:34.850 --> 09:36.950
他在维对列都是一步执行

09:36.950 --> 09:38.150
再运行他

09:38.150 --> 09:38.450
对不对

09:38.450 --> 09:39.350
一定是这个样子

09:40.150 --> 09:41.150
先运行他

09:41.150 --> 09:42.050
再运行他

09:42.050 --> 09:42.350
好了

09:42.350 --> 09:43.450
那我们就离来想

09:43.450 --> 09:44.550
那么先运行他

09:44.550 --> 09:46.550
以至现在新的Render还没有执行

09:46.550 --> 09:47.350
对吧

09:47.350 --> 09:48.250
先运行他

09:48.250 --> 09:49.350
那么运行他的时候

09:49.350 --> 09:50.350
我们该干嘛呀

09:50.350 --> 09:53.350
我们根据ID来获得这个A11元数

09:53.350 --> 09:53.750
于是呢

09:53.750 --> 09:56.850
我们得到这个A11元数的InnerText

09:56.850 --> 09:58.350
他的内文本

09:58.350 --> 09:59.150
那么这个时候

09:59.150 --> 10:01.250
我请问大家此时

10:02.950 --> 10:10.090
此时界面更新了吗

10:10.090 --> 10:10.890
有没有更新啊

10:11.890 --> 10:12.490
是没有

10:12.490 --> 10:13.890
界面更新必须要运行什么

10:13.890 --> 10:14.890
要运行Render

10:14.890 --> 10:16.590
而这个时候有没有运行Render

10:16.590 --> 10:17.090
没有

10:17.190 --> 10:18.590
因为排队嘛

10:18.590 --> 10:19.890
他他先运行

10:19.890 --> 10:21.090
然后再他运行

10:21.090 --> 10:21.490
对吧

10:21.490 --> 10:22.690
他为什么会排到后面

10:22.690 --> 10:24.490
因为后边还改变了数据

10:24.490 --> 10:25.490
所以说呢

10:25.490 --> 10:26.890
先运行他再运行Render

10:26.890 --> 10:28.790
因此我们这个时候还没有运行Render

10:28.790 --> 10:30.090
我们的界面没有更新

10:30.090 --> 10:31.490
说这个时候应该输出什么

10:31.490 --> 10:32.990
应该输出1234

10:32.990 --> 10:35.490
还是旧的旧的那个东西

10:35.490 --> 10:36.090
对吧

10:36.090 --> 10:37.390
输出1234

10:37.390 --> 10:39.490
然后再输出Render

10:39.490 --> 10:40.390
是这么一回事啊

10:40.390 --> 10:41.390
所以说你可以看到

10:41.390 --> 10:42.390
点击按钮过后呢

10:42.390 --> 10:44.290
他得到的是1234Render

10:44.290 --> 10:45.590
然后Render运行了

10:45.590 --> 10:46.990
我们界面更新了

10:47.090 --> 10:48.190
实施1234Render

10:49.890 --> 10:50.490
没问题吧

10:51.790 --> 10:52.690
然后再来

10:52.690 --> 10:54.090
这个题可以变化的啊

10:54.990 --> 10:56.290
那么比方说我这里呢

10:56.290 --> 10:57.490
又输出一个E

10:59.720 --> 11:00.920
那现在又输出什么

11:01.520 --> 11:03.120
如果点击按钮过后啊

11:03.120 --> 11:04.420
现在我点击按钮过后

11:04.420 --> 11:05.320
他又会输出什么

11:25.220 --> 11:27.220
11234Render

11:29.130 --> 11:29.930
其他同学呢

11:35.070 --> 11:35.670
其他同学呢

11:35.670 --> 11:36.870
你们答案是不是这样子

11:42.300 --> 11:42.700
对吧

11:42.700 --> 11:43.600
那没问题啊

11:43.600 --> 11:44.800
是这个案子的案啊

11:44.800 --> 11:45.900
就说他先会输出E

11:45.900 --> 11:46.300
为什么呢

11:46.300 --> 11:47.500
因为这个时候

11:48.100 --> 11:50.400
这个函数是放到V队的一边

11:50.400 --> 11:50.800
为什么呢

11:50.800 --> 11:51.900
它是通过Lexpec

11:52.300 --> 11:53.100
放进去的

11:53.100 --> 11:53.800
为什么我要用

11:53.800 --> 11:55.300
我就是这是一道题啊

11:56.100 --> 11:57.100
其实没有必要用的啊

11:57.100 --> 11:58.400
我只是一道题而已

11:58.800 --> 12:01.400
这个这个这个功能没有任何意义

12:01.500 --> 12:02.500
它只是一道题

12:03.500 --> 12:04.000
啊

12:05.900 --> 12:07.000
这个函数在V队的

12:07.000 --> 12:07.500
所以说呢

12:07.500 --> 12:09.700
这是一个这是一个异步异步代码

12:09.800 --> 12:10.500
那么这个Render

12:10.500 --> 12:11.700
他也会放放到V队的

12:11.700 --> 12:12.900
所以说我们这个视线队里面

12:12.900 --> 12:13.900
就两个东西嘛

12:14.300 --> 12:15.000
V队的

12:16.000 --> 12:16.800
啊

12:16.800 --> 12:18.200
那么这这就是Fn

12:18.200 --> 12:19.700
就是我们自己自己写的函数

12:21.500 --> 12:22.000
在这

12:22.300 --> 12:22.600
然后呢

12:22.600 --> 12:23.200
还有一个是什么呢

12:23.200 --> 12:24.800
还有一个是Render在这

12:25.000 --> 12:26.200
然后我们同步代码

12:26.800 --> 12:28.400
同步代码是不是还要输出E

12:29.000 --> 12:29.400
对吧

12:29.800 --> 12:31.200
同步代码要输出E

12:31.300 --> 12:32.400
所以说我们可以得到的结果

12:32.400 --> 12:33.400
就是先输出E

12:33.400 --> 12:34.800
先把同步代码运行完

12:35.200 --> 12:36.200
然后再从V队的一边

12:36.200 --> 12:37.200
一个一个取出来

12:37.300 --> 12:38.500
运行我们那个函数

12:38.600 --> 12:39.600
运行我们那个函数的时候

12:39.600 --> 12:40.200
还没有渲染

12:40.200 --> 12:41.500
所以说输出1234

12:42.200 --> 12:43.300
在再运行Render

12:43.300 --> 12:44.000
再输出Render

12:44.000 --> 12:45.700
所以说E1234

12:46.800 --> 12:47.400
Render

12:49.210 --> 12:50.010
那边问题啊

12:50.310 --> 12:50.510
啊

12:50.510 --> 12:52.210
这问题可以各种变化啊

12:52.210 --> 12:54.110
比方说我这里可能可能会这样子写

12:56.660 --> 12:57.560
那就写零嘛

12:57.660 --> 12:58.160
都一

13:01.260 --> 13:02.160
那这样子呢

13:02.260 --> 13:03.660
我们把这个写到前面啊

13:04.860 --> 13:04.960
啊

13:04.960 --> 13:05.660
这就考

13:05.660 --> 13:07.360
考验的其实上就不是什么

13:07.360 --> 13:08.160
无忧的知识了

13:08.460 --> 13:10.260
这考验的是寿线循环的知识

13:13.240 --> 13:14.140
那这样子写呢

13:16.470 --> 13:17.070
所谓同学们

13:17.070 --> 13:18.570
里面学框架之前

13:19.070 --> 13:20.770
真的要把基础掌握老靠

13:20.770 --> 13:21.870
像咱们后期课里面

13:21.870 --> 13:23.470
框架都是比较靠后学习的

13:23.970 --> 13:25.470
先要把基础的一些东西掌握老靠

13:25.470 --> 13:26.570
证明从网络通信啊

13:26.570 --> 13:27.670
db协议啊

13:27.870 --> 13:29.070
特别是GS基础

13:29.070 --> 13:29.770
还有ES5

13:29.770 --> 13:30.570
ES6啊

13:30.670 --> 13:31.870
像这CS3啊

13:31.970 --> 13:32.770
像这些东西

13:32.770 --> 13:33.470
H5啊

13:33.670 --> 13:34.670
要掌握老靠啊

13:35.270 --> 13:36.570
那么到时候你写框架的时候

13:36.570 --> 13:37.670
就会得信一手了

13:41.270 --> 13:42.470
那么这种情况也怎么样呢

13:45.090 --> 13:45.490
啊

13:45.590 --> 13:47.190
最想回答出来是程序同学啊

13:47.190 --> 13:47.990
非常不错

13:48.090 --> 13:50.090
那么这个时候就会输出1234

13:50.190 --> 13:50.790
Render 1

13:50.790 --> 13:51.990
那么这个是又怎么回事了

13:51.990 --> 13:52.690
这跟视线

13:52.790 --> 13:53.990
视线循环有关系

13:53.990 --> 13:54.990
有没有同木单吗

13:55.290 --> 13:55.790
有同木单

13:55.790 --> 13:56.690
但是我们没有

13:56.790 --> 13:57.990
没有输出的同木单吧

13:58.090 --> 13:59.090
同木单码里面没有输出

13:59.090 --> 13:59.790
不用管它

13:59.990 --> 14:00.390
那么现在呢

14:00.390 --> 14:01.990
我们有个红队的

14:02.190 --> 14:02.490
对吧

14:02.490 --> 14:04.490
我们的set-timeout是在红队的里边

14:04.590 --> 14:06.490
我们输出1是在红队里边

14:06.490 --> 14:08.090
所以同木单码运行完了之后

14:08.190 --> 14:10.290
那么开始先从围队里边去

14:10.290 --> 14:11.190
先运行这个

14:12.290 --> 14:13.690
再运行Render

14:14.690 --> 14:15.890
再运行1

14:15.890 --> 14:16.190
对吧

14:16.190 --> 14:17.690
说1234 Render 1

14:18.890 --> 14:19.590
啊再看

14:21.090 --> 14:21.490
1

14:22.490 --> 14:23.490
好在了啊

14:23.990 --> 14:25.990
这条题可玩的东西可多了

14:26.290 --> 14:26.990
那么现在呢

14:26.990 --> 14:28.590
我现在问这样一个问题

14:28.790 --> 14:29.990
那如果说我点这个按钮

14:29.990 --> 14:30.690
这个没问题啊

14:30.690 --> 14:31.990
输出了1234 Render

14:32.190 --> 14:33.590
然后我再点一次呢

14:35.190 --> 14:36.790
我再点一次他会输出什么

14:36.990 --> 14:39.290
你看这一道题就可以问出很多花样出来

14:39.390 --> 14:40.990
考察了各种方面的知识

14:41.690 --> 14:42.790
我再点一次

14:44.190 --> 14:44.690
他还

14:45.290 --> 14:46.390
那么他又会怎么样呢

14:51.500 --> 14:52.800
就第二次点击

14:53.700 --> 14:54.500
他会怎么样呢

15:04.560 --> 15:04.960
来吧

15:04.960 --> 15:05.860
你们觉得啊

15:05.860 --> 15:06.560
如果说

15:07.260 --> 15:08.060
猜一猜嘛

15:08.360 --> 15:09.860
你们觉得关键在点

15:09.860 --> 15:11.060
他这个玩意肯定在执行吧

15:11.060 --> 15:11.960
这个毫无疑问

15:13.160 --> 15:15.360
而且他一定是就算要执行Render的话

15:15.360 --> 15:16.460
他要先一步执行

15:16.460 --> 15:18.660
其实现在现在就回到一个问题

15:19.060 --> 15:20.860
就是Render要不要执行的问题

15:22.960 --> 15:23.960
要不要执行的问题

15:23.960 --> 15:24.460
Render

15:25.860 --> 15:26.960
啊再来看一下吧

15:27.660 --> 15:29.760
输出10 11 12 13

15:30.360 --> 15:32.660
说明啥说明Render是不是没有执行

15:32.760 --> 15:33.960
为什么没有执行呢

15:33.960 --> 15:36.860
因为你负责值跟他当前的值是一样的

15:37.060 --> 15:38.760
他当前已经是这个值了

15:39.060 --> 15:40.260
你在改变

15:40.260 --> 15:41.160
他还是这个值

15:41.160 --> 15:42.460
因此他觉得没有变

15:42.560 --> 15:43.060
没有变

15:43.060 --> 15:44.460
他就不会派发更新

15:44.460 --> 15:46.260
不知道大家还记不记得啊

15:46.260 --> 15:47.660
昨天给大家看了这么一个东西啊

15:47.660 --> 15:48.560
就是那个

15:49.060 --> 15:49.660
楼梯派

15:50.660 --> 15:51.060
对

15:51.560 --> 15:52.360
楼梯派

15:54.060 --> 15:55.260
在哪呢

15:55.460 --> 15:56.260
在

15:57.060 --> 15:57.560
在这

15:58.860 --> 15:59.360
啊你看

15:59.360 --> 16:02.260
昨天还好像给你们顺便提了一句对吧

16:02.660 --> 16:05.660
他如果说给他的新的值跟旧的值是一样的

16:06.260 --> 16:07.460
那么他就直接结束了

16:07.460 --> 16:08.660
他并不会楼梯派

16:08.760 --> 16:11.160
并不会派发更新啊并不会通知

16:12.060 --> 16:12.660
知道吧

16:13.160 --> 16:13.860
所以说了

16:15.060 --> 16:16.460
他这里并不会啊

16:16.460 --> 16:18.660
他并不会触发那个Render执行

16:19.460 --> 16:20.460
好在了啊

16:21.360 --> 16:22.860
我如果说把他写到这的

16:29.960 --> 16:32.860
那么现在第一次点击啊第一次点击

16:34.560 --> 16:35.560
他会输出啥呀

16:37.160 --> 16:38.960
那其实我们就是就考虑的是

16:38.960 --> 16:40.760
他到底先运行的是Render

16:40.760 --> 16:42.360
还是先运行的是这个函数

16:43.260 --> 16:44.660
你只要这个东西找到了

16:44.660 --> 16:46.260
他肯定是能够知道啊

16:46.260 --> 16:47.060
他结果是什么

16:47.660 --> 16:48.460
先运行的Render

16:48.460 --> 16:49.660
他一定是得到了是Render

16:49.860 --> 16:50.860
渲染之后的值

16:51.160 --> 16:52.260
那么先运行这个函数

16:52.260 --> 16:53.860
他一定是得到渲染之前的值

16:57.050 --> 16:58.450
那么你在这个时候

16:58.450 --> 17:00.250
你觉得他会先运行啥呀

17:05.490 --> 17:07.690
就是先那一定是先运行的是Render

17:07.690 --> 17:07.990
对吧

17:07.990 --> 17:08.790
非常好啊

17:08.890 --> 17:10.190
先运行的是Render

17:10.290 --> 17:11.390
那么先运行

17:11.390 --> 17:12.490
运行的是Render

17:12.490 --> 17:13.190
那么哦对

17:13.190 --> 17:14.390
这里还有个问题啊

17:15.490 --> 17:17.890
那么这里得到了结果了啊

17:20.320 --> 17:21.420
老公我先看结果啊

17:21.420 --> 17:22.120
先看结果

17:23.320 --> 17:24.820
十十一十二十三

17:25.020 --> 17:26.620
哎那么一头就有疑问了啊

17:26.620 --> 17:28.220
哎我是刚刚只改变了

17:28.220 --> 17:28.620
哎对吧

17:28.620 --> 17:30.620
这个时候还没有改变BCB

17:31.220 --> 17:32.220
那为什么这个得到了

17:32.220 --> 17:33.220
得到的结果是

17:33.920 --> 17:35.220
不是个刚才总结说啊

17:35.220 --> 17:36.820
十只改变了一个十对吧

17:36.820 --> 17:38.320
后边还是之前的结果二三四

17:38.320 --> 17:39.220
不是这样子的

17:40.020 --> 17:42.620
嗯这就是说一道事件军环了啊

17:43.020 --> 17:45.020
我们那个F人函数和Render函数

17:45.020 --> 17:46.420
他一定是在v对列里边

17:46.420 --> 17:47.720
因为他是通过next take

17:47.820 --> 17:48.920
他是在v对列里边

17:49.020 --> 17:50.020
所以我们这里的顺序呢

17:50.020 --> 17:52.320
是先运行Render再运行Fn

17:52.420 --> 17:53.520
但是我们的同步代码

17:53.520 --> 17:55.320
是不是一定要等同步代码运行完

17:55.620 --> 17:56.620
什么叫同步代码

17:57.420 --> 17:58.520
这里的大码已经运行了

17:58.520 --> 18:00.220
那么这三句是不是还是同步代码

18:00.620 --> 18:02.920
所以我们还要等待给b负值

18:04.220 --> 18:06.720
还要等待给c负值

18:07.520 --> 18:09.120
还要等待给d负值

18:09.320 --> 18:09.820
对不对

18:10.120 --> 18:12.120
那么这三句话负值完了过后

18:12.120 --> 18:13.820
最后是不是才运行那个

18:14.020 --> 18:15.720
事件对列里边的东西

18:15.720 --> 18:17.720
所以说当你运行到Render的时候

18:17.720 --> 18:19.120
实际上只早就复完了

18:19.520 --> 18:21.320
同步代码一定是运行结束了

18:21.820 --> 18:23.720
我们之前还在这里打了一个e对不对

18:23.720 --> 18:25.620
你会发现这个e一定是先运行的

18:25.620 --> 18:26.720
因为他是同步代码

18:27.620 --> 18:28.120
对吧

18:28.120 --> 18:29.920
之前我们不是看过吗

18:29.920 --> 18:31.420
这个e是不是一定先运行

18:31.720 --> 18:32.720
就这么个道理

18:32.720 --> 18:34.420
所以同步代码一定先运行

18:34.420 --> 18:35.720
那么这个运行完了过后

18:35.720 --> 18:36.920
再从v对列里边取

18:36.920 --> 18:37.720
那么这个时候呢

18:37.720 --> 18:38.620
渲染的时候

18:38.820 --> 18:40.520
他就已经是最终的数据了

18:40.520 --> 18:42.120
所以渲染出来就已经是10

18:42.120 --> 18:42.520
11

18:42.520 --> 18:42.820
12

18:42.820 --> 18:43.320
13

18:43.920 --> 18:44.220
好

18:44.220 --> 18:45.320
那么Render运行完了

18:45.420 --> 18:46.320
Render运行完了过

18:46.320 --> 18:46.920
这个时候呢

18:46.920 --> 18:49.620
界面上就已经能够看到10

18:49.620 --> 18:49.920
11

18:49.920 --> 18:50.120
12

18:50.120 --> 18:50.320
13

18:50.320 --> 18:51.720
那么这个时候呢

18:51.820 --> 18:53.320
你再去从这里取东西

18:53.320 --> 18:55.420
那取出来就是最终的结果

18:57.620 --> 18:58.220
能理解吗

18:58.220 --> 18:58.720
这一块

18:59.820 --> 19:00.620
解释清楚没有

19:01.320 --> 19:02.320
因为什么疑问

19:02.720 --> 19:03.220
没有什么疑问

19:03.220 --> 19:03.720
我们就讲

19:03.720 --> 19:04.920
开始讲今天的课了啊

19:07.980 --> 19:08.080
好

19:08.080 --> 19:08.780
这是关于那个这个

19:08.780 --> 19:09.580
那个结果很难吗

19:09.580 --> 19:10.180
一点都不难

19:10.180 --> 19:10.480
对吧

19:10.480 --> 19:11.380
你只要知道他的东西

19:11.380 --> 19:11.980
在v对列

19:11.980 --> 19:12.680
然后我们的Render

19:12.680 --> 19:13.480
还是也在v对列

19:13.480 --> 19:14.480
就ok了

19:15.480 --> 19:16.480
要考的话

19:16.480 --> 19:17.280
他无非就是

19:17.480 --> 19:19.180
就是基于这种形式来考

19:20.380 --> 19:20.680
好

19:20.680 --> 19:21.980
这是咱们昨天的啊

19:22.180 --> 19:22.880
扣斩一下

19:23.880 --> 19:24.080
好

19:24.080 --> 19:24.780
我们今天的

19:24.780 --> 19:25.980
我们今天讲deaf

19:26.680 --> 19:27.380
怎么样deaf呢

19:27.380 --> 19:28.980
其实我们之前讲那个

19:30.680 --> 19:32.880
昨天讲了个享用式系统的时候

19:33.180 --> 19:35.080
给大家就看到了这么一个东西

19:35.080 --> 19:37.680
其实大家一直应该有这么一个疑问啊

19:37.680 --> 19:40.580
我们爱好爱好爱好思考的同学

19:40.980 --> 19:42.280
应该有这么一个疑问

19:42.680 --> 19:45.180
就说我每一次改变数据

19:45.580 --> 19:46.880
像我们这些改变数据

19:46.880 --> 19:48.580
他都会导致Render运行

19:49.080 --> 19:49.580
为什么呢

19:49.580 --> 19:50.580
又要重新券了

19:51.480 --> 19:52.480
为什么要执行Render呢

19:52.480 --> 19:54.280
因为我们要重新生成

19:54.880 --> 19:55.580
虚拟洞

19:55.680 --> 19:55.880
对吧

19:55.880 --> 19:56.580
虚拟节点

19:58.180 --> 19:59.880
但是我们国王有虚拟节点

19:59.980 --> 20:01.380
能够看到界面吗

20:01.380 --> 20:02.580
肯定是看不见的

20:02.980 --> 20:04.980
就是我们最重要的能够在瀏覽器里面

20:04.980 --> 20:06.080
看到这些东西

20:06.080 --> 20:07.780
是必须要有真实的动物的

20:08.380 --> 20:10.480
那么这里边就引寒了一个步骤

20:10.780 --> 20:12.980
就是如何把我们的虚拟洞

20:13.080 --> 20:14.580
变成真实的洞

20:15.580 --> 20:16.880
就这么一个问题对吧

20:16.980 --> 20:18.680
所以说我们今天晚上

20:19.180 --> 20:20.480
整个整个晚上

20:20.680 --> 20:23.180
研究的所有问题都是这么一个问题

20:23.880 --> 20:25.180
我现在有蓄力动物了

20:25.680 --> 20:26.580
要运行Render

20:26.780 --> 20:29.880
那么我怎么样把这个Render变成真实的动物

20:30.380 --> 20:31.380
就是研究这么一个问题

20:31.380 --> 20:32.380
这个问题的过程呢

20:32.380 --> 20:33.880
其实就是我们的Dev算法

20:34.580 --> 20:35.880
那么面试起到时候

20:35.880 --> 20:36.780
肯定会问你啊

20:36.780 --> 20:38.580
请阐述5U的Dev算法

20:38.580 --> 20:40.380
或者是就问你5U里边

20:41.380 --> 20:42.980
Dev算法你是怎么理解的

20:42.980 --> 20:44.280
那么你就直无不延

20:44.280 --> 20:44.880
眼问不尽

20:44.880 --> 20:46.180
在那边有个参考回答

20:46.380 --> 20:48.280
你如果说目前去看这个参考回答的话

20:48.280 --> 20:49.180
可能看不懂

20:49.980 --> 20:50.580
没关系啊

20:50.580 --> 20:54.380
我们重新给大家从头到尾解释一下

20:54.480 --> 20:55.280
它是怎么回事

20:55.880 --> 20:56.080
好

20:56.080 --> 20:56.780
第一个问题

20:57.280 --> 20:58.080
你回答的时候

20:58.080 --> 20:59.580
第一个问题就是要回答出

20:59.980 --> 21:01.580
Dev发生了时间点

21:02.080 --> 21:03.480
什么时候发生这件事

21:04.880 --> 21:04.980
好

21:04.980 --> 21:05.580
看着啊

21:05.680 --> 21:06.380
一点来

21:08.420 --> 21:10.620
当我们的组建创建的时候

21:10.620 --> 21:11.920
什么叫组建创建

21:13.620 --> 21:14.520
溜了一个5U

21:16.120 --> 21:17.220
或者是你在这里边

21:17.220 --> 21:18.920
你去使用了一些别的组建

21:20.220 --> 21:22.220
你去使用了一些自定义组建

21:22.520 --> 21:24.120
那么自定义组建什么时候创建

21:24.320 --> 21:25.220
什么时候创建呢

21:26.020 --> 21:27.220
实在润到的时候

21:27.220 --> 21:29.120
润到的时候是不是会生成它的距离节点

21:29.520 --> 21:31.220
那么发现它是一个组建节点

21:31.420 --> 21:33.120
这个时候它就会创建组建对象

21:34.320 --> 21:35.220
溜的时候

21:35.220 --> 21:36.220
或者是这个时候

21:36.220 --> 21:38.320
它都会创建组建对象

21:39.420 --> 21:40.220
那么创建

21:40.220 --> 21:41.320
无论是这个时候

21:41.320 --> 21:43.120
还是创建在刚才那种写法

21:43.420 --> 21:44.720
本质都是一样的

21:45.220 --> 21:47.120
都是溜了一个5U从东西出来

21:47.120 --> 21:48.420
都是溜了这么一个东西出来

21:49.420 --> 21:50.420
那么这个时候

21:50.420 --> 21:52.220
它会做很多很多的事情

21:52.420 --> 21:53.820
在这个5U的构造函数里边

21:53.820 --> 21:55.420
有超级多的事情要做

21:56.720 --> 21:57.820
那么它里边

21:57.820 --> 22:00.820
我们现在只关心它的一些关键的事情

22:00.820 --> 22:01.620
怎么事情呢

22:05.010 --> 22:06.810
当我们的组建创建的时候

22:06.810 --> 22:08.210
以及依赖的属性

22:08.210 --> 22:09.910
或者是数据变化的时候

22:09.910 --> 22:11.910
它们它都会运行一个函数

22:12.810 --> 22:13.610
看这句话啊

22:14.110 --> 22:16.410
创建一个组建或者是

22:17.710 --> 22:19.110
组建依赖的属性

22:19.210 --> 22:20.410
组建里边不是有属性吗

22:20.410 --> 22:21.410
不是有这个东西吗

22:22.610 --> 22:23.410
probs

22:23.510 --> 22:23.910
对吧

22:23.910 --> 22:24.810
是不是有这个东西

22:25.310 --> 22:26.510
就是我们组建的属性

22:27.110 --> 22:28.710
或者是组建的数据

22:32.010 --> 22:34.310
组建里边不是就可以有数据对吧

22:34.410 --> 22:36.010
那么它的数据有可能会变化

22:36.010 --> 22:37.610
它的属性的传入的属性

22:37.610 --> 22:38.710
也有可能会变化

22:39.310 --> 22:39.910
对不对

22:39.910 --> 22:42.810
那么属性变化或者是数据变化的时候

22:43.110 --> 22:45.110
以及组建新建的时候呢

22:45.110 --> 22:46.410
它们都会运行一个函数

22:46.410 --> 22:47.610
是同一个函数

22:48.310 --> 22:49.210
并没有分开

22:49.710 --> 22:51.510
那么这个函数会做什么事情呢

22:52.110 --> 22:52.910
就这个函数

22:53.010 --> 22:54.610
就给大家说昨天看到的对吧

22:54.610 --> 22:56.210
昨天我们不是看到过这个函数吗

22:56.410 --> 22:58.710
叫做update components

22:59.210 --> 22:59.910
这个函数

23:04.380 --> 23:05.080
在

23:07.220 --> 23:07.720
这

23:08.120 --> 23:08.920
就这个函数

23:10.020 --> 23:11.320
它里边其实做的事情呢

23:11.320 --> 23:12.320
就这么一件事情

23:12.420 --> 23:15.120
它会调用当前组建里边一个方法

23:15.120 --> 23:16.420
叫做update方法

23:17.620 --> 23:20.020
然后update方法里边传入了一个参数

23:20.020 --> 23:22.220
这个参数是通过render方法传入的

23:22.920 --> 23:24.220
也说在核心代表就这个

23:24.820 --> 23:25.820
调用这个方法

23:26.120 --> 23:26.820
然后呢

23:27.020 --> 23:27.920
这个方法来的

23:27.920 --> 23:30.020
通过render方法的反应回结果

23:30.020 --> 23:31.120
传入一个参数

23:31.620 --> 23:33.020
它会组装成这么一个函数

23:33.320 --> 23:34.620
然后把这个函数呢

23:34.620 --> 23:36.320
传入到一个watcher里边

23:36.320 --> 23:37.420
像我们昨天讲的

23:38.020 --> 23:39.120
watcher的功能是什么

23:39.220 --> 23:40.920
它跟函数就关联在一起了

23:41.220 --> 23:43.220
这个函数的运行过程中

23:44.120 --> 23:46.420
用到了所有的响应式数据

23:47.720 --> 23:49.420
都会拿个小本记录下来

23:49.420 --> 23:51.120
有个watcher在用它们

23:51.420 --> 23:52.720
这就是watcher的作用

23:52.920 --> 23:53.620
然后这个watcher呢

23:53.620 --> 23:55.920
会首先直接把这个函数运行一遍

23:56.520 --> 23:56.720
对吧

23:56.720 --> 23:58.020
我们昨天再把也可以看到了

23:58.020 --> 23:59.420
下面是不是一个new watcher

23:59.720 --> 24:00.920
是把这个函数放进去了

24:01.020 --> 24:01.120
对吧

24:01.120 --> 24:02.520
其他的参数我们不用管啊

24:04.120 --> 24:04.320
好

24:04.320 --> 24:05.520
这就是这一块

24:05.520 --> 24:06.620
它的核心代表也在这

24:06.820 --> 24:08.320
那么接下来我们再看一下啊

24:08.320 --> 24:09.320
我们的主键里边

24:09.320 --> 24:10.920
这个z是表示的当前主键

24:10.920 --> 24:11.320
对吧

24:11.320 --> 24:12.120
当前主键里边

24:12.120 --> 24:13.620
是不是有这么两个函数

24:13.720 --> 24:14.620
直接我们来看一下

24:17.010 --> 24:17.510
就在这吧

24:17.510 --> 24:18.210
随便找个地方

24:18.210 --> 24:18.710
就在这

24:20.210 --> 24:20.810
可以记得

24:22.410 --> 24:23.510
我输出一下z

24:24.510 --> 24:26.110
输出一下z

24:28.540 --> 24:29.540
控制台看一下啊

24:30.440 --> 24:31.640
这是我们当前的主键

24:31.740 --> 24:33.240
当前的主键里边我们找一找啊

24:33.240 --> 24:36.740
有没有那个render函数和这个update函数

24:37.440 --> 24:38.240
在元箱里边

24:39.240 --> 24:39.940
看一下啊

24:41.540 --> 24:42.340
是不是一个render

24:44.140 --> 24:45.440
然后这里是不是一个update

24:46.540 --> 24:48.440
看到没不就是两个函数吗

24:48.840 --> 24:49.440
对吧好

24:49.440 --> 24:50.740
那么我们一个个来说

24:51.540 --> 24:54.240
首先我们从这个代码里边就可以看到啊

24:54.840 --> 24:56.840
它一开始是不是一定要会运行它

24:57.240 --> 24:58.740
对不对一开始一定会运行它吗

24:59.040 --> 25:00.640
那么现在它就开始运行了

25:00.640 --> 25:02.440
就是创建主键的时候是不是

25:02.440 --> 25:03.840
首先会把它运行一遍

25:04.040 --> 25:05.240
因为瓦解的功能就是

25:05.240 --> 25:06.740
把那个传入的函数运行一遍

25:07.240 --> 25:08.440
好那么就会运行它

25:08.840 --> 25:09.940
运行它的时候呢

25:09.940 --> 25:11.240
它里边会怎么运行的

25:11.240 --> 25:13.040
它肯定会先运行这个表达式

25:13.640 --> 25:15.340
运行render函数

25:15.440 --> 25:17.840
把render函数的反而回结果作为参数

25:17.840 --> 25:18.540
传进去

25:18.540 --> 25:20.340
然后再调用update函数

25:20.340 --> 25:20.640
对吧

25:20.640 --> 25:22.140
它的运行顺序是这样子的

25:22.540 --> 25:23.740
那么首先会运行它

25:23.940 --> 25:24.940
那么运行它的时候

25:24.940 --> 25:25.940
它又在干嘛呢

25:25.940 --> 25:27.440
这个函数我们以前没有见过

25:27.540 --> 25:28.240
它的干嘛呢

25:28.240 --> 25:30.440
就它要做的事情的特别特别简单

25:30.740 --> 25:31.640
它做啥事呢

25:32.040 --> 25:34.240
它就是调用我们给它的给它的一个render

25:34.240 --> 25:35.040
就这么简单

25:35.440 --> 25:36.940
然后传入一个函数

25:37.140 --> 25:38.140
就这么简单啊

25:38.140 --> 25:39.140
然后我们来看一下吧

25:40.340 --> 25:41.040
那个

25:41.940 --> 25:42.540
render

25:42.940 --> 25:43.740
render函数

25:48.170 --> 25:48.770
你看吧

25:51.000 --> 25:51.700
这个函数

25:52.800 --> 25:55.000
不拉不拉不拉不拉是写了半天啊

25:55.000 --> 25:56.700
我们来看一下最核心的代码

25:57.400 --> 25:58.800
最核心的代码在哪呢

26:02.090 --> 26:02.890
我找一找啊

26:04.090 --> 26:05.090
最核心的代码

26:05.490 --> 26:06.290
render

26:06.290 --> 26:06.890
啊有的

26:06.890 --> 26:07.290
你看

26:08.290 --> 26:09.390
从文这是这是什么

26:09.390 --> 26:10.190
这个是什么东西

26:10.190 --> 26:12.090
这个是我们给5u传的配置

26:12.790 --> 26:13.390
就是这个

26:14.090 --> 26:15.890
整个这个对象是不是就5u的配置

26:15.990 --> 26:17.490
就是给给一个组件的配置

26:17.490 --> 26:17.790
对吧

26:17.790 --> 26:18.790
就是个配置对象

26:19.190 --> 26:20.690
它又会从一个配置对象中

26:21.390 --> 26:22.590
找到那个render

26:22.990 --> 26:24.890
这是es6的语法叫结构

26:25.390 --> 26:27.590
你们以后学es6都是会学的

26:27.590 --> 26:28.090
什么意思呢

26:28.090 --> 26:29.990
我们的简单解释一下非常简单

26:29.990 --> 26:32.790
就从那个对象中取出它的render配置

26:33.190 --> 26:33.690
是不是这个

26:34.590 --> 26:35.490
所以有render配置

26:35.690 --> 26:36.190
就这个东西

26:36.190 --> 26:37.390
他把这个函数取出来

26:37.790 --> 26:38.690
那么取出来过后呢

26:38.690 --> 26:40.790
我们看关键代码其他东西都不用去扣款

26:41.390 --> 26:41.990
看到这没

26:42.690 --> 26:44.690
render core是不是在执行

26:45.190 --> 26:46.690
那么一看到那个core说明啥

26:46.690 --> 26:47.990
是不是给它绑定了一个riss

26:47.990 --> 26:49.590
这就是为什么在render里边

26:49.690 --> 26:51.090
riss的指向啊

26:51.090 --> 26:52.990
始终指向当前的这个实力

26:52.990 --> 26:54.490
就这么就这么个意思啊

26:54.990 --> 26:56.590
那么这就是给绑定了一个riss

26:56.590 --> 26:57.790
然后给它传了一个什么呢

26:57.890 --> 27:00.090
传到另外一个函数进去叫做create element

27:01.090 --> 27:01.890
这个函数是怎么了

27:01.890 --> 27:03.390
这个函数其实就是这个H

27:03.690 --> 27:04.590
是不是要传过来了

27:05.190 --> 27:05.690
看到没

27:05.790 --> 27:07.990
我们它传的这个函数就是比较传过来了

27:08.090 --> 27:09.190
所以说我们其实呢

27:09.390 --> 27:09.990
说白了

27:10.090 --> 27:11.090
这个render函数啊

27:11.090 --> 27:12.990
它调用的核心代码

27:12.990 --> 27:13.990
就是它的核心代码

27:13.990 --> 27:15.690
就是调用我们给它写的

27:15.690 --> 27:17.090
传入了那个配置对象

27:17.090 --> 27:18.490
配置配置的那个render

27:18.890 --> 27:19.990
就这么个意思啊

27:20.990 --> 27:21.890
好这是这一点

27:23.190 --> 27:23.890
好接下来

27:23.990 --> 27:25.490
也就我们这个函数一调用

27:25.490 --> 27:27.290
是不是就运行了这个render函数了

27:27.390 --> 27:28.390
是不是运行了它了

27:28.390 --> 27:29.190
那么你想一想

27:29.190 --> 27:30.490
这个运行它的过程中

27:30.690 --> 27:32.390
是收到water来监控的

27:32.690 --> 27:34.890
所以说它的运行过程中用到了所有数据

27:35.090 --> 27:36.590
都会打小板记一下啊

27:36.690 --> 27:37.590
有个water

27:37.890 --> 27:38.590
用到了我

27:38.890 --> 27:40.090
将来如果说

27:40.490 --> 27:41.390
我的数据一变

27:41.390 --> 27:42.890
它就会重新运行这个函数

27:42.890 --> 27:44.690
重新运行这个函数它又来一遍

27:44.690 --> 27:45.890
是不是又重新运行render

27:46.090 --> 27:46.290
对吧

27:46.290 --> 27:46.990
就是这么个回

27:46.990 --> 27:49.490
那么这就是为什么它render可以反复的执行

27:49.490 --> 27:50.490
就这个原因啊

27:51.390 --> 27:53.290
好那么现在拿到这个虚利动物了过后

27:53.290 --> 27:54.690
这一次呢返回一个虚利动物

27:55.690 --> 27:57.690
这里看我们是不是反复了一个虚利动

27:57.990 --> 27:59.190
哪怕你自己不写这个render

27:59.190 --> 28:00.290
他又通过模板编译

28:00.290 --> 28:01.590
他这种也会得到一个虚利动

28:02.590 --> 28:03.790
好那么现在的问题就在这了

28:03.790 --> 28:04.990
其实我们今天晚上的问题了

28:05.290 --> 28:07.490
这个虚利动物它不是直接拿去渲染的

28:07.490 --> 28:08.290
没法渲染

28:08.590 --> 28:10.090
它必须要经过一个函数

28:10.090 --> 28:11.390
这个函数叫做update函数

28:11.390 --> 28:12.390
你面试的时候

28:12.390 --> 28:13.690
一定要把这个函数回答到

28:14.390 --> 28:16.690
你告诉他我们的无忧里边

28:17.790 --> 28:20.390
他渲染的流程是什么分两步骤

28:20.690 --> 28:21.390
第一步

28:21.990 --> 28:24.590
运行我们配置的render拿到虚利节点

28:24.790 --> 28:25.490
第二步

28:26.290 --> 28:28.090
把这个虚利节点作为参数

28:28.090 --> 28:30.690
传入到一个叫update的函数里边去执行

28:31.390 --> 28:32.790
对吧一定要回答这么两个步骤

28:32.790 --> 28:34.390
这才是能够完成一个渲染

28:34.490 --> 28:35.590
先拿虚利节点

28:35.690 --> 28:37.290
然后再调用update

28:37.490 --> 28:38.890
那么update的作用就是

28:39.490 --> 28:40.190
根据

28:41.890 --> 28:43.190
我们的虚利节点

28:43.890 --> 28:46.290
生成一个真实的动物

28:46.390 --> 28:47.990
这就是update的作用

28:49.290 --> 28:50.790
你看我们这里写的好了啊

28:50.790 --> 28:52.090
render两步

28:52.090 --> 28:53.990
render生成一个新的虚利动物数

28:54.190 --> 28:55.190
运行update

28:55.190 --> 28:55.890
然后呢

28:56.490 --> 28:58.790
生成完成对真实动物的更新

28:59.990 --> 29:01.590
我们的dif上发在哪呢

29:01.690 --> 29:03.790
就发生在update的函数里边

29:04.490 --> 29:06.190
就是他的运行过程中

29:06.990 --> 29:08.490
好这第一步你要回答到啊

29:08.590 --> 29:09.890
他的发生的时间点

29:10.290 --> 29:11.290
他怎么发生的

29:11.790 --> 29:13.290
这一块有没有什么问题

29:13.890 --> 29:14.690
我慢慢讲啊

29:19.000 --> 29:19.500
啊

29:20.400 --> 29:21.500
关注我们的那个

29:21.500 --> 29:23.000
杜一德咱们的集训员吧

29:23.800 --> 29:25.100
关注咱们杜一德集训员吧

29:25.100 --> 29:26.600
我我们集训员的话

29:26.600 --> 29:27.900
有会有一次

29:28.800 --> 29:29.900
不一定是下个月啊

29:29.900 --> 29:31.500
有可能是下下个月不一定啊

29:31.500 --> 29:32.600
反正有一次的集训员

29:32.600 --> 29:33.700
我会讲这个东西

29:34.300 --> 29:35.900
会专门来讲一些基础的东西

29:38.600 --> 29:39.100
没问题吧

29:39.100 --> 29:40.200
好咱们继续了啊

29:40.700 --> 29:42.000
好接下来我们重点来看

29:42.100 --> 29:43.700
这个update函数在干嘛

29:45.200 --> 29:46.900
update他就是一个函数

29:47.000 --> 29:48.500
这个函数他接受一个参数

29:48.500 --> 29:49.400
就是vload的

29:50.200 --> 29:51.100
update函数

29:53.660 --> 29:55.160
好那么这个函数在干嘛了

29:55.160 --> 29:57.860
他首先做了一件非常简单的事情

29:58.660 --> 29:59.360
什么事情呢

29:59.760 --> 30:01.560
就是咱把z

30:02.660 --> 30:05.160
vload设置为这个vload

30:05.160 --> 30:06.860
他就做这么一件非常简单的事情

30:06.960 --> 30:08.060
然后在设置之前呢

30:08.060 --> 30:09.260
先保存一下啊

30:09.360 --> 30:10.060
先保存一下

30:10.060 --> 30:12.760
o的vload等于z

30:13.060 --> 30:13.660
vload

30:13.660 --> 30:15.060
啊那么我一点点说

30:15.160 --> 30:15.960
这是两件

30:15.960 --> 30:17.560
这是两句非常核心的来吧

30:18.460 --> 30:19.560
好了一哥哥说啊

30:19.560 --> 30:20.960
首先这个东西是啥

30:21.260 --> 30:22.160
首先z是啥

30:22.160 --> 30:23.660
z他一定是当前逐渐

30:24.260 --> 30:25.360
那么这个玩意是啥

30:25.360 --> 30:26.260
那么来看一下

30:27.260 --> 30:28.360
这个玩意到底是啥

30:28.460 --> 30:28.960
刷新

30:29.260 --> 30:30.560
这是我们当前逐渐对吧

30:30.560 --> 30:32.360
当前逐渐的实力往下找

30:32.760 --> 30:35.760
他里边有个属性叫做下滑线vload

30:36.160 --> 30:37.760
那么他是个什么玩意呢

30:38.160 --> 30:40.060
他就是当前组件

30:40.460 --> 30:42.760
生成的那个根节点

30:43.360 --> 30:45.760
也就是说换句话说就是这个Render函数

30:45.760 --> 30:47.160
反而回到那个vload的

30:48.360 --> 30:50.160
你看说一个div

30:51.160 --> 30:51.760
看到没

30:51.760 --> 30:52.960
他那个alm

30:53.360 --> 30:54.460
说这个div

30:54.460 --> 30:55.960
对吧那么这个vload

30:55.960 --> 30:56.960
是不是还有76准

30:56.960 --> 30:58.660
76准有se有8准对吧

30:58.860 --> 31:00.860
你看se里边又有76准

31:00.860 --> 31:02.860
有一个文本1234

31:03.360 --> 31:05.060
看看也就是说我们

31:05.360 --> 31:05.960
这个

31:06.260 --> 31:07.960
组件里边的这个东西

31:10.000 --> 31:11.200
下滑线vload的

31:11.200 --> 31:12.900
他始终指向

31:13.200 --> 31:15.200
Render函数返回的结果

31:16.300 --> 31:17.100
明儿的意思吧

31:17.400 --> 31:19.700
好那我们再来看这个update函数

31:20.100 --> 31:21.100
他做了这么两句话

31:21.100 --> 31:22.000
你觉得他在干吗

31:22.200 --> 31:24.500
他首先把当前的vload的

31:25.300 --> 31:27.500
放到一个变量叫o的vload里边

31:27.900 --> 31:29.700
然后把我们传入到vload的

31:29.700 --> 31:31.600
设置到他的下滑线vload里边

31:32.200 --> 31:33.400
这是在做啥呀这是

31:35.700 --> 31:37.100
我们这个vload是哪来的

31:37.500 --> 31:38.400
参数哪来的

31:38.700 --> 31:41.700
参数是不是来自于当前Render执行的结果

31:42.700 --> 31:45.100
对吧是Render执行的结果作为参数传进来了

31:45.400 --> 31:47.000
那也就是说这个update函数

31:47.000 --> 31:48.500
他首先做的第一件事

31:48.700 --> 31:51.800
就是把我们新的那个vload

31:52.200 --> 31:53.800
给这个下滑线vload的复制

31:53.800 --> 31:55.300
就让他当前组建的vload的

31:55.300 --> 31:58.400
始终指向Render函数返回的结果

31:58.700 --> 32:00.900
对吧这件事是不是在做这么一件事

32:01.200 --> 32:06.100
始终指向Render返回的结果

32:07.800 --> 32:09.000
表示新的那颗数

32:09.300 --> 32:10.800
那么这一句话在干吗呢

32:11.500 --> 32:12.900
因为我们这个函数啊

32:12.900 --> 32:14.900
这个函数是不是有一个人会反复执行

32:15.300 --> 32:17.200
他不是说组建一开始会执行一次

32:17.200 --> 32:18.100
以后就不执行了

32:18.200 --> 32:19.600
他只要数据一变化

32:19.600 --> 32:21.100
是不是一定会重新执行

32:21.600 --> 32:22.800
重新执行这个函数

32:23.100 --> 32:24.400
那么也就意味着

32:24.500 --> 32:25.900
在我们这句话之前

32:25.900 --> 32:27.800
是不是可能之前还有个vload的

32:28.200 --> 32:28.800
你看啊

32:29.900 --> 32:30.500
比方说

32:32.000 --> 32:32.700
我们这里

32:33.800 --> 32:35.500
目前的vload是这个对吧

32:35.600 --> 32:36.400
是这个东西

32:36.500 --> 32:37.600
运行的是Render函数

32:37.600 --> 32:39.900
目前指向Render函数返回那个vload的

32:40.300 --> 32:42.000
然后如果说我们点击这个按钮过后

32:42.000 --> 32:43.700
是不是要重新运行Render函数

32:44.100 --> 32:45.200
那么他的主法就是

32:45.200 --> 32:46.800
把当前这个vload呢

32:47.300 --> 32:48.300
保存到这

32:49.000 --> 32:49.700
然后呢

32:49.700 --> 32:51.600
把重新生成那个vload的

32:51.700 --> 32:52.500
复制给他

32:53.000 --> 32:54.700
这两句话有没有有没有什么问题

32:55.300 --> 32:56.000
能不能理解

32:59.800 --> 33:01.000
能力啊并不复杂了

33:03.850 --> 33:04.750
于似乎

33:05.250 --> 33:06.850
他现在是不是有两个vload了

33:08.350 --> 33:09.350
一个vload是什么

33:09.550 --> 33:12.350
o的vload表示之前的

33:12.950 --> 33:13.650
虚利节点

33:13.650 --> 33:15.450
对吧之前的见面的虚利节点

33:15.850 --> 33:17.050
另一个vload是什么呢

33:17.250 --> 33:18.050
就是个vload

33:18.350 --> 33:20.250
是不是新的虚利节点

33:21.150 --> 33:22.350
对吧是不是有两个东西了

33:22.850 --> 33:23.650
那么这就是啊

33:23.650 --> 33:24.950
他接下来要做什么事情

33:27.310 --> 33:28.310
Render函数的干嘛

33:29.110 --> 33:30.110
他接受了一个vload的

33:30.110 --> 33:31.910
那么就是新生成的虚利动物数

33:32.310 --> 33:33.110
啊然后呢

33:33.210 --> 33:35.010
他会通过当前组织的vload的属性

33:35.010 --> 33:36.210
拿到旧的虚利动物数

33:36.210 --> 33:36.710
然后呢

33:36.710 --> 33:38.110
会给这个vload的重新复制

33:38.310 --> 33:39.310
那么参与一张图

33:39.510 --> 33:40.510
比方说这个组建

33:41.010 --> 33:42.610
更新了属性变化了

33:42.610 --> 33:44.010
或者是数据变化了

33:44.010 --> 33:44.710
他要更新

33:44.710 --> 33:46.410
那么他一定会重新运行Render

33:46.810 --> 33:48.710
生成一个新的新的虚利动物数

33:48.710 --> 33:49.110
对吧

33:49.510 --> 33:51.210
然后他里边一个vload的属性

33:53.010 --> 33:54.310
他里边一个vload的属性

33:55.310 --> 33:56.010
颜色啊

34:00.640 --> 34:01.540
这个vload的属性

34:01.540 --> 34:03.440
他就会指向新的虚利动物数

34:03.640 --> 34:04.540
然后旧的动物数呢

34:04.540 --> 34:05.740
会保存在一个变量里边

34:06.040 --> 34:08.040
他就会拿到两颗虚利动物数

34:08.840 --> 34:09.240
对吧

34:09.240 --> 34:10.440
就是他做了这么一件事

34:11.740 --> 34:13.340
然后接下来他会做一个判断

34:13.740 --> 34:15.740
他会判断旧数是否存在

34:15.740 --> 34:17.040
就是有没有旧的数

34:17.040 --> 34:18.540
也就是他判断这个东西纯不存在

34:19.040 --> 34:20.440
O的vload的纯不存在

34:20.940 --> 34:21.740
他其实我们这里呢

34:21.740 --> 34:23.140
可以看到他的原始代码里边

34:23.140 --> 34:23.840
也可以看一下

34:24.940 --> 34:25.540
update

34:29.490 --> 34:30.090
在哪呢

34:34.450 --> 34:35.050
你看啊

34:36.250 --> 34:37.250
是不是拿到先拿到

34:37.250 --> 34:38.850
先把这个vload的保存到一个变量啊

34:38.850 --> 34:40.450
他用的名字不就不叫O的啊

34:40.450 --> 34:41.150
叫做pril

34:41.150 --> 34:41.850
之前的啊

34:41.850 --> 34:42.650
一个意思啊

34:42.950 --> 34:44.050
之前的vload

34:44.250 --> 34:45.550
然后把当前的vload呢

34:45.550 --> 34:47.050
是不是复制给vload

34:47.450 --> 34:48.850
然后首先是不是判断一下

34:48.850 --> 34:50.350
之前有没有这个vload

34:50.850 --> 34:51.350
对不对

34:51.650 --> 34:52.650
他做这么一件事啊

34:52.750 --> 34:54.550
判断一下旧数是否存在

34:54.650 --> 34:55.550
那么请问大家

34:55.650 --> 34:58.150
什么情况下旧数是不存在的

34:59.650 --> 35:00.850
这种情况什么情况下

35:00.850 --> 35:02.050
旧数是不存在的

35:07.290 --> 35:08.290
是不是首次宣传

35:08.890 --> 35:09.290
对不对

35:09.290 --> 35:10.290
第一次宣传的时候

35:10.290 --> 35:11.490
你看他有这个vload吗

35:11.490 --> 35:12.290
根本没有

35:12.290 --> 35:12.590
对吧

35:12.590 --> 35:14.090
仍然还说第一次运销

35:14.290 --> 35:15.190
那么之前的

35:15.290 --> 35:16.990
之前的vload

35:17.090 --> 35:18.390
一定是空帮地办的

35:18.990 --> 35:20.290
说那么这个时候呢

35:20.390 --> 35:21.790
旧数是不存在的

35:21.990 --> 35:23.290
如果说旧数不存在的话

35:23.290 --> 35:23.990
那非常简单

35:23.990 --> 35:25.590
那就是第一次加载组件

35:25.690 --> 35:25.990
于是呢

35:25.990 --> 35:28.390
他会通过内部的一个函数叫做patch

35:31.320 --> 35:31.720
对不对

35:31.820 --> 35:33.420
他他调用逻辑

35:33.420 --> 35:34.620
其实非常的清晰

35:34.720 --> 35:36.120
你把这干擾代码区调过

35:36.120 --> 35:37.520
他逻辑非常清晰

35:37.920 --> 35:39.420
他调用里面一个函数叫patch

35:41.120 --> 35:43.020
纸这个patch还说干嘛呀

35:43.120 --> 35:43.820
简单说一下

35:43.820 --> 35:45.620
就是他的直接便利新数

35:46.120 --> 35:49.120
为每一个节点生成真实的动物

35:49.820 --> 35:50.220
对吧

35:50.220 --> 35:51.520
就是一个数的便利

35:51.920 --> 35:52.820
有没有你以后

35:52.920 --> 35:54.220
咱们都已有一个算法课

35:54.220 --> 35:55.320
里面就讲到数的便利

35:55.320 --> 35:55.920
非常简单

35:55.920 --> 35:57.520
就是便利数的每一个节点

35:57.620 --> 35:58.620
然后对每一个节点呢

35:58.620 --> 35:59.420
用document

35:59.420 --> 36:00.420
crease element

36:00.620 --> 36:02.420
去创建一个真实的动物

36:02.420 --> 36:03.520
然后把个真实动物呢

36:03.520 --> 36:04.220
放到哪呢

36:04.220 --> 36:05.720
放到每一个区域动物的

36:06.120 --> 36:07.220
alm属性里边

36:08.520 --> 36:09.420
是放到这

36:09.820 --> 36:11.720
放到alm属性里边关联起来

36:11.720 --> 36:12.120
对吧

36:12.120 --> 36:12.720
就完事了

36:12.720 --> 36:13.720
是不是创建的真实动物过后

36:13.720 --> 36:15.020
我们就能够看到界面

36:15.420 --> 36:16.220
就这么简单

36:16.920 --> 36:18.620
说这种情况是非常简单的

36:20.120 --> 36:21.320
好第二种情况

36:22.220 --> 36:23.320
如果说他存在

36:23.320 --> 36:25.620
就是之前的那颗数有存存在

36:25.620 --> 36:26.820
不是第一次

36:26.820 --> 36:28.120
不是第一次创建的

36:28.320 --> 36:31.120
那么说明之前就已经宣览过这个组件了

36:31.620 --> 36:33.120
那么现在就是有两颗数

36:33.520 --> 36:34.520
一颗新的数

36:34.520 --> 36:36.020
一颗之前宣览的数

36:36.320 --> 36:37.820
那么这个时候怎么办呢

36:38.620 --> 36:39.220
这个时候呢

36:39.220 --> 36:41.020
他也会调这个叛起函数

36:41.020 --> 36:43.020
只是传入的参数不一样啊

36:43.820 --> 36:45.120
那么这个时候呢

36:45.120 --> 36:45.720
他就会

36:46.020 --> 36:47.620
传入两颗虚拟动物数

36:47.620 --> 36:49.420
你看之前的那颗数

36:49.420 --> 36:50.220
新的数

36:50.220 --> 36:50.420
对吧

36:50.420 --> 36:51.820
传入两颗虚拟动物数

36:52.020 --> 36:54.420
让叛起函数来去完成对比

36:55.720 --> 36:56.820
那么叛起函数

36:57.520 --> 36:59.020
主要的目标是什么呢

36:59.220 --> 37:01.520
目标就是要改动真实动物

37:01.620 --> 37:03.320
他需不需要去改动虚拟动物呀

37:04.220 --> 37:06.120
你觉得他需不需要去改动虚拟动物呀

37:11.400 --> 37:12.200
需不需要啊

37:15.010 --> 37:16.110
为什么不需要呢

37:16.210 --> 37:17.210
为什么不需要去改变

37:17.210 --> 37:18.710
去改变虚拟动物呢

37:19.010 --> 37:19.910
是因为他的虚拟动物

37:19.910 --> 37:21.010
是不是已经正确了

37:21.210 --> 37:22.610
他已经指向新的数了

37:22.910 --> 37:24.010
有必要去改动他们

37:24.510 --> 37:25.410
不用动对吧

37:25.410 --> 37:27.010
现在唯一不正确的是

37:27.010 --> 37:28.310
揪的那颗虚拟动物数

37:28.310 --> 37:29.510
但是揪的那颗虚拟动物数

37:29.510 --> 37:30.210
已经不用了

37:30.210 --> 37:30.810
用都不用了

37:30.810 --> 37:31.910
我用现在用的是新的了

37:31.910 --> 37:32.410
对吧

37:32.510 --> 37:34.210
所以我没有必要去改动虚拟动物

37:34.510 --> 37:36.110
我现在要的目标就是

37:36.410 --> 37:39.610
对比新就两颗虚拟动物

37:40.110 --> 37:41.610
不用改你就对比

37:41.910 --> 37:43.310
看哪个地方不一样

37:43.810 --> 37:46.110
然后去反应到真实的动物

37:46.110 --> 37:47.210
里面变化就完事了

37:48.310 --> 37:48.710
但是呢

37:48.710 --> 37:50.010
为了提高效率啊

37:50.010 --> 37:52.110
他之所以去搞出这套虚拟动物出来

37:52.110 --> 37:53.310
就是为了避免

37:54.410 --> 37:56.910
过太过频繁的去操作真实动物

37:56.910 --> 37:58.010
所以他对比的时候呢

37:58.010 --> 37:59.110
一定要非常小心

37:59.910 --> 38:02.210
他要完成对所有真实动物的

38:02.310 --> 38:03.710
注意小话处理

38:03.810 --> 38:05.410
怎么样注意小话就能不动

38:05.410 --> 38:06.210
就不动

38:07.010 --> 38:08.210
最好啥都不要动

38:08.910 --> 38:09.910
比的没办法了

38:10.210 --> 38:12.510
能动少一点就动少一点

38:12.710 --> 38:14.310
不要去改动的太多

38:14.610 --> 38:16.010
这是他的目标啊

38:16.010 --> 38:17.210
一是要完成变化

38:17.210 --> 38:18.510
而是要注意小话处理

38:20.910 --> 38:21.410
然后呢

38:21.410 --> 38:22.210
还有一件事情呢

38:22.210 --> 38:23.310
他就顺便把它做了

38:23.310 --> 38:24.910
就是让新数的节点呢

38:24.910 --> 38:27.010
对应到合适的真实动物

38:27.010 --> 38:28.410
因为我们知道新的那颗数

38:28.410 --> 38:29.810
是不是没有这个l我们属性

38:30.410 --> 38:31.610
就的那颗数是有的

38:35.440 --> 38:36.540
我们的每一个虚拟

38:36.540 --> 38:38.340
虚拟节点上是不是有个l我们属性啊

38:38.340 --> 38:38.840
在这

38:40.340 --> 38:41.340
是不是有这个东西

38:41.540 --> 38:43.240
就就的那颗数是有的

38:43.240 --> 38:44.740
新的那颗数是没有的

38:44.940 --> 38:45.140
对吧

38:45.140 --> 38:46.940
我们云道里面哪跟他负责这个属性

38:46.940 --> 38:47.940
没有跟他负责这个属性

38:47.940 --> 38:48.340
对吧

38:48.340 --> 38:50.140
所以新的那颗数是没有这个东西的

38:50.140 --> 38:51.540
所以说他还会给新的

38:51.540 --> 38:53.040
这颗数l我们负责

38:53.240 --> 38:54.240
他一边对比

38:54.240 --> 38:55.640
一边更改真实动物

38:55.640 --> 38:56.740
一边给他负责

38:57.340 --> 38:58.140
所以说我们呢

38:58.140 --> 38:59.140
看下面这颗图

39:00.740 --> 39:01.540
看那个图啊

39:03.140 --> 39:03.540
嗯

39:03.540 --> 39:04.140
把它

39:04.440 --> 39:05.340
负责一下吧

39:06.040 --> 39:07.640
到流下去了看得清楚一点啊

39:11.990 --> 39:13.290
在开始的时候

39:13.890 --> 39:14.890
他是指

39:15.790 --> 39:17.390
他是指向旧的那颗数的

39:18.190 --> 39:18.790
对不对

39:18.790 --> 39:19.790
他指向他的

39:19.990 --> 39:21.790
现在我们数据变化了更新了

39:22.190 --> 39:23.690
于是他重新运行人道

39:23.690 --> 39:24.990
重新运行updata

39:25.190 --> 39:25.490
于是呢

39:25.490 --> 39:26.390
后来v兜的呢

39:27.190 --> 39:28.790
他就会指向新的那颗数

39:28.990 --> 39:30.390
所以v兜的就已经正确了

39:30.690 --> 39:31.890
但是现在一个问题啊

39:31.890 --> 39:32.790
有两个问题

39:32.990 --> 39:34.590
真实动物里边还没有反应变化

39:34.590 --> 39:36.190
比方说有些稳定更新了

39:36.190 --> 39:37.390
有些那个动

39:37.590 --> 39:38.790
真实动物的顺序变了

39:38.790 --> 39:39.890
有些有的时候呢

39:39.890 --> 39:41.490
有些有些真实动物呢

39:41.490 --> 39:43.090
要移除有些真实动物呢

39:43.090 --> 39:44.090
要去新建

39:44.090 --> 39:44.290
对吧

39:44.290 --> 39:46.090
还有很多改动没有更新

39:46.090 --> 39:47.090
这是一个问题

39:47.090 --> 39:47.690
第二个问题呢

39:47.690 --> 39:48.790
是我们这棵树里边

39:48.790 --> 39:50.290
是不是没有这个alm呢

39:51.190 --> 39:52.290
是不是没有这个alm

39:52.390 --> 39:52.590
对不对

39:52.590 --> 39:54.190
他要做两件事啊

39:55.090 --> 39:56.190
一件事呢是

39:56.890 --> 39:57.690
该新建

39:57.690 --> 39:58.490
然后这里啊

39:58.490 --> 39:59.790
新就是新增了一个啊

39:59.790 --> 40:00.490
然后这里

40:01.490 --> 40:02.590
这里就新增了一个

40:02.790 --> 40:03.690
然后呢这里呢

40:03.690 --> 40:04.690
就移除了一个

40:04.690 --> 40:05.190
看到没

40:05.190 --> 40:06.790
真实动物是不是少了一个

40:07.290 --> 40:07.890
然后呢

40:07.890 --> 40:09.190
不仅要做这些事情

40:09.190 --> 40:09.890
还要把

40:10.490 --> 40:11.790
这个alm的属性呢

40:11.790 --> 40:12.790
要给他复职

40:13.390 --> 40:14.390
所以他做两件事

40:14.590 --> 40:16.190
这两件事一做完

40:16.390 --> 40:17.690
然后一看就变成最终结构

40:17.690 --> 40:18.490
就变成这个样子了

40:18.790 --> 40:20.290
这个变成这个样子的结果

40:20.290 --> 40:21.690
是不是就又稳定了

40:22.090 --> 40:23.390
那么又总在下一次更新

40:23.390 --> 40:24.090
下一次更新呢

40:24.090 --> 40:24.990
又重新来一次

40:24.990 --> 40:26.690
又那么这棵树又变成旧树了

40:26.790 --> 40:28.190
又又生存一次新树

40:28.190 --> 40:29.390
又来重新做一次

40:29.490 --> 40:29.690
对吧

40:29.690 --> 40:30.890
还有整个过程就是这样子的

40:31.690 --> 40:32.090
好

40:32.690 --> 40:33.690
那么他怎么做的

40:34.490 --> 40:35.690
这样就是又是

40:35.890 --> 40:37.090
我们一步一步推进啊

40:37.290 --> 40:38.890
那么现在就进入到派起函树

40:38.890 --> 40:40.490
就看他具体是怎么做的

40:41.190 --> 40:42.390
啊这个地方呢

40:42.890 --> 40:44.390
就是你们要在面试的时候呢

40:44.390 --> 40:45.890
要回答出这么几个点啊

40:45.890 --> 40:46.390
一个是

40:46.790 --> 40:47.690
颠夫的时机

40:47.890 --> 40:49.490
一个是阿不爹的函树在干嘛

40:49.790 --> 40:50.890
他到底在做什么

40:51.190 --> 40:53.690
然后第三个就是派起函树的流程

40:54.590 --> 40:57.190
啊为了解给你们解释清楚这个派起函树呢

40:57.590 --> 40:59.690
啊我这里首先要给大家说一些数语

41:00.090 --> 41:01.290
不然的话一会我解释一下

41:01.290 --> 41:02.090
很不好解释啊

41:02.090 --> 41:03.190
其实他病病毒复杂

41:03.190 --> 41:04.090
你只要听懂了过后

41:04.090 --> 41:05.290
你觉得他就并不复杂了

41:05.790 --> 41:06.590
但是你要你

41:06.590 --> 41:08.090
他以为要是一个地规的过程

41:08.590 --> 41:10.490
我先要搞去给大家介绍一下啊

41:11.490 --> 41:12.790
一个是什么什么叫相同

41:12.790 --> 41:14.590
以后我可以高抄一下什么叫相同

41:15.390 --> 41:16.890
相同是这里是指的是什么意思呢

41:16.890 --> 41:18.690
就一会你看到这个词啊

41:18.690 --> 41:19.390
两个书名号

41:19.390 --> 41:20.690
一个两个字相同

41:20.690 --> 41:23.090
他指的就是两个虚拟结进来

41:23.090 --> 41:24.190
标签内相

41:24.190 --> 41:25.190
什么叫标签内相

41:25.990 --> 41:27.090
就这个太克属性

41:28.290 --> 41:29.590
太克属性是一样的

41:30.990 --> 41:31.990
啊标签内相

41:32.390 --> 41:33.890
还有这个是key值

41:34.090 --> 41:34.990
知不知道key值

41:34.990 --> 41:36.290
将我们在循环

41:36.490 --> 41:38.190
宣了一些动物元素的时候

41:38.190 --> 41:39.590
对吧循环圈的元素的时候

41:39.590 --> 41:40.390
是用v4

41:40.890 --> 41:41.890
v4的时候是不是

41:43.390 --> 41:45.090
我不知道你们有没有听过我的伍佑啊

41:45.090 --> 41:46.290
甭管你是听我的伍佑

41:46.290 --> 41:48.190
还是从别的老师的伍佑都没关系

41:48.190 --> 41:49.390
他一定会告诉你

41:49.390 --> 41:50.490
一定要加上那个key

41:50.490 --> 41:51.090
对不对

41:51.290 --> 41:52.090
当上key

41:52.690 --> 41:53.490
甭管你加啥吧

41:53.490 --> 41:54.790
一般是加id啊

41:54.790 --> 41:57.090
key值要保持稳定和唯一

41:57.090 --> 41:58.090
对不对啊

41:58.090 --> 41:59.390
那么key值我就会在这里解释

41:59.390 --> 42:00.390
他为什么要这样做

42:01.190 --> 42:02.290
key值要相同

42:02.790 --> 42:03.790
标签内形相同

42:03.790 --> 42:04.690
key值相同

42:04.790 --> 42:07.190
那么他们就是同一个虚拟结定

42:08.490 --> 42:09.190
听懂的意思吗

42:09.490 --> 42:11.890
key值相同标签内形相同

42:11.890 --> 42:13.590
他们就是同一个虚拟结定

42:13.990 --> 42:15.590
这就是他们就是相同的

42:15.890 --> 42:17.190
我们说相同就这个含义

42:18.290 --> 42:19.790
好然后给大家举个例子

42:20.390 --> 42:21.190
我就在这写吧

42:30.850 --> 42:31.850
请问这两个

42:31.950 --> 42:33.850
这两个虚拟结定是不是同一个虚拟结定

42:35.550 --> 42:36.350
是的话q1

42:36.450 --> 42:37.350
不是的话q2

42:42.530 --> 42:43.230
是对吧

42:44.030 --> 42:44.430
嗯

42:45.130 --> 42:46.030
我还有不是的

42:46.530 --> 42:47.730
我指的是这个相同啊

42:47.730 --> 42:49.330
我这里定义的数与相同

42:49.530 --> 42:51.930
啊如说用动物对象来看的话肯定不是啊

42:51.930 --> 42:53.030
也要用那个虚拟动

42:53.130 --> 42:55.730
虚拟结定那个对象的引用地址来说肯定不是

42:55.730 --> 42:57.330
但是我这里说的是这种相同

42:57.330 --> 42:58.730
我说的相同是这个意思啊

42:59.330 --> 43:01.230
就是为什么我要先解释数与呢

43:01.830 --> 43:02.930
好然后呢

43:03.130 --> 43:04.530
如果说是这样子写呢

43:09.040 --> 43:10.140
他们是不是同一个

43:12.980 --> 43:14.580
是的话q1不是的话q2

43:16.280 --> 43:17.380
所以不是了对吧

43:17.380 --> 43:19.380
他必须要标签内形相同

43:19.380 --> 43:20.480
key值也要相同

43:20.580 --> 43:22.080
刚才没有key值没有key值的话key

43:22.080 --> 43:22.980
就是undie犯的

43:23.480 --> 43:24.980
undie犯的是等于undie犯的

43:25.080 --> 43:25.980
对不对没问题

43:26.480 --> 43:27.080
好又来

43:37.840 --> 43:39.340
他们是不是同一个虚拟结定

43:42.460 --> 43:43.060
是不是

43:44.560 --> 43:45.760
还是一样

43:46.160 --> 43:48.360
一定要相信我相信我给你们写的

43:48.360 --> 43:50.560
你不要害怕相信我给你写的

43:50.660 --> 43:52.160
两个虚拟的标签内形相同

43:52.160 --> 43:53.160
内形一不一样吗

43:53.160 --> 43:54.860
都是一期嘛key值一不一样吗

43:54.860 --> 43:55.360
一样

43:56.060 --> 43:57.060
这些看的不看

43:57.260 --> 43:58.460
所以他们还是同一个

43:59.160 --> 43:59.860
好再来

44:07.700 --> 44:08.600
现在是不是同一个

44:10.510 --> 44:11.210
是不是同一个

44:12.110 --> 44:13.610
还是同一个不要怕啊

44:13.610 --> 44:15.510
一定要相信我给你们写的那句话

44:15.610 --> 44:16.710
一定是这样子的啊

44:17.310 --> 44:19.710
那么他为什么要去做这个相同的判断呢

44:19.810 --> 44:21.410
其实一会你讲了过后就知道了

44:21.610 --> 44:24.310
他是为了尽量少的相同的节点

44:24.310 --> 44:25.910
他是不会删除和新建的

44:26.110 --> 44:28.110
就不要他纠的节点是这个样子

44:28.210 --> 44:29.110
新的节点是这个样子

44:29.110 --> 44:30.710
他一旦判断他们相同了

44:31.410 --> 44:32.310
这个不会删

44:32.410 --> 44:33.510
这个不会新的创

44:33.510 --> 44:34.310
不会新建

44:34.310 --> 44:35.310
他就去去改

44:35.410 --> 44:36.710
改动原来的东西

44:36.710 --> 44:37.810
比方说他id变了

44:37.810 --> 44:39.910
那就把id从taito1改到taito2

44:40.010 --> 44:41.610
是不是可以重复的利用动

44:41.710 --> 44:42.210
对吧

44:42.910 --> 44:43.910
class从

44:44.010 --> 44:46.210
把taito就把这个taito就给他移除掉

44:46.410 --> 44:47.510
就这么个意思啊

44:47.710 --> 44:50.510
所以说他就是说为什么他判断相同的原因

44:51.010 --> 44:53.310
但是如果说你是aq他被这里变成aq2

44:53.710 --> 44:54.810
哪里这东西怎么改呢

44:54.810 --> 44:55.810
改变表情类型啊

44:55.810 --> 44:56.910
你不能改表情类型了

44:56.910 --> 44:57.910
所以说这个字

44:57.910 --> 44:58.710
他就不相同

44:58.710 --> 45:00.010
不相同的话只能删除

45:00.010 --> 45:00.910
只能新建

45:01.410 --> 45:01.910
没有意思吧

45:01.910 --> 45:03.510
他就判断相同的方式啊

45:04.010 --> 45:04.610
那么这里呢

45:04.610 --> 45:05.710
有一个小的系列

45:05.710 --> 45:07.710
就是input元素有点特殊

45:07.910 --> 45:10.110
input元素还要看这个type属性

45:10.910 --> 45:12.110
还要看type属性

45:12.610 --> 45:13.110
好吧

45:14.110 --> 45:15.210
看type属性的时候呢

45:15.210 --> 45:16.910
其实还是有一些还有很多细节啊

45:16.910 --> 45:17.810
不过这些东西呢

45:18.010 --> 45:18.610
你放心

45:18.610 --> 45:21.010
面试是不再不再不会问你到这么细的

45:21.010 --> 45:22.110
其实我们可以看一下

45:22.310 --> 45:24.710
在我们的元代码里边其实就是一个seminode

45:25.110 --> 45:25.910
就是一个函数啊

45:25.910 --> 45:26.510
seminode

45:27.410 --> 45:28.110
先跑下去

45:29.510 --> 45:30.410
好吧就是一个函数

45:30.410 --> 45:31.010
seminode

45:33.020 --> 45:34.020
哦seminvnode

45:39.560 --> 45:40.360
在这啊

45:40.560 --> 45:41.460
我看一下啊

45:41.560 --> 45:42.060
在这

45:42.360 --> 45:44.060
你看就是派起点介石里面

45:45.060 --> 45:46.260
判断

45:46.260 --> 45:47.060
你看怎么判断的

45:47.060 --> 45:47.960
t值相同

45:48.360 --> 45:49.160
并且

45:50.060 --> 45:50.860
type相同

45:50.860 --> 45:51.860
其他的属性不用管

45:52.160 --> 45:53.260
其他的属性不用管

45:53.560 --> 45:55.260
所以关键就是一个t值要相同

45:55.260 --> 45:56.060
type要相同

45:56.560 --> 45:57.060
对不对

45:57.960 --> 46:00.060
那么如果说input元素的话

46:00.060 --> 46:02.460
那么还要去判断他们的type属性

46:03.060 --> 46:03.460
你看

46:03.460 --> 46:05.460
seminput里边还要判判

46:05.460 --> 46:06.460
看判断他们什么

46:06.460 --> 46:07.560
判断他们的type

46:10.160 --> 46:10.360
好

46:10.360 --> 46:11.560
这就是相同的概念

46:11.560 --> 46:12.560
接下来看下一个

46:12.860 --> 46:14.360
什么叫新建元素

46:16.160 --> 46:17.760
新建元素什么意思呢

46:20.760 --> 46:21.560
根据一个

46:21.560 --> 46:23.960
它指的是根据一个虚拟节点提供的信息

46:23.960 --> 46:25.360
创建一个真实的动物元素

46:25.360 --> 46:28.460
挂得到虚拟节点的AOM属性上

46:28.960 --> 46:29.560
什么意思

46:29.860 --> 46:30.660
就是新建元素

46:30.660 --> 46:31.960
比方说我有一个虚拟节点

46:31.960 --> 46:32.760
这是虚拟节点

46:33.360 --> 46:34.860
它长的肯定是个对象

46:34.860 --> 46:35.560
它长的是个对象

46:35.560 --> 46:37.360
我写的时候呢是这样子写的

46:37.660 --> 46:38.400
它长的时候

46:38.400 --> 46:39.660
长出来的肯定是个对象

46:39.860 --> 46:40.560
那么我就

46:40.760 --> 46:41.560
什么叫新建元素

46:41.560 --> 46:45.560
我就是用 document create element

46:47.560 --> 46:49.760
然后创建一个H2

46:49.960 --> 46:52.560
然后给这个H2的ID

46:52.560 --> 46:53.760
复制为Title

46:54.160 --> 46:55.260
懂了意思吗

46:55.660 --> 46:57.560
然后给这个H2

46:58.360 --> 46:59.360
也没有什么东西了

46:59.360 --> 46:59.760
对吧

47:00.260 --> 47:04.660
然后把这个H2放到虚拟动物的AOM属性里边

47:05.960 --> 47:07.360
虚拟动物不是有个这个属性吗

47:07.860 --> 47:08.560
它放进去

47:08.560 --> 47:09.360
把关联起来

47:09.660 --> 47:10.960
这就是要新建元素

47:10.960 --> 47:11.960
就这么个意思

47:11.960 --> 47:13.360
以后我说到新建元素的时候

47:13.360 --> 47:14.560
你们要知道我来说啥

47:15.260 --> 47:15.660
好

47:15.760 --> 47:17.560
下一个概念就是销毁元素

47:17.860 --> 47:19.160
销毁元素特别简单

47:19.160 --> 47:21.360
就是找到虚拟动物里边的AOM

47:21.860 --> 47:23.160
是不是它那个真实动物

47:23.160 --> 47:23.660
是吧

47:23.760 --> 47:24.860
找到它那个真实动物

47:24.960 --> 47:26.360
然后把它remove移除掉

47:26.360 --> 47:28.160
移除了就把个真实动物移除就完成

47:28.860 --> 47:29.560
就这么简单

47:30.060 --> 47:30.760
这是销毁动

47:30.860 --> 47:31.660
销毁元素

47:32.760 --> 47:32.960
好

47:32.960 --> 47:33.960
下一个更新

47:34.160 --> 47:35.160
什么要更新呢

47:35.360 --> 47:37.960
指的是将两个虚拟节点进行对比

47:38.160 --> 47:40.560
然后这个两个进进行对比

47:41.860 --> 47:44.260
如果说他们相同的话

47:44.660 --> 47:46.560
那么他就会进入更新流程

47:47.260 --> 47:48.260
所以说更新以后

47:48.260 --> 47:49.360
我写到更新的时候

47:49.360 --> 47:50.960
有一定有个前提条件

47:51.060 --> 47:52.360
就是两个虚拟动物

47:52.360 --> 47:53.060
他一定要有

47:53.060 --> 47:54.760
你就是一定要是相同的

47:55.260 --> 47:56.260
那么大家看一下

47:56.360 --> 47:57.260
这两个虚拟动物

47:57.260 --> 47:58.860
他们能不能进入更新流程

48:01.020 --> 48:02.420
这两个能不能进入更新流程

48:07.520 --> 48:08.320
关于剃子啊

48:08.320 --> 48:09.320
以后你慢慢往后听

48:09.320 --> 48:10.720
就只越来越明白了

48:13.290 --> 48:14.890
所以不行

48:14.890 --> 48:16.190
因为他们不是相同的

48:16.190 --> 48:16.690
对吧

48:16.690 --> 48:17.590
他们不是相同的

48:17.590 --> 48:18.790
他们会进入什么流程呢

48:18.890 --> 48:21.490
他们会进入销毁和新建流程

48:22.090 --> 48:22.590
他销毁

48:22.590 --> 48:23.190
他是旧的

48:23.190 --> 48:23.790
他销毁

48:24.190 --> 48:24.890
他新建

48:25.590 --> 48:26.790
他们会进入这个流程

48:27.790 --> 48:30.690
还有个对比指节点指的是什么意思呢

48:30.790 --> 48:33.490
指的是对两个虚拟节点的指节点进行对比

48:33.690 --> 48:34.290
那么具体过程

48:34.290 --> 48:35.090
一会再描述

48:35.490 --> 48:36.690
那么这是这几个数语

48:37.490 --> 48:38.490
解释好数语过后呢

48:38.490 --> 48:39.590
因为这是个地规的流程

48:39.590 --> 48:40.990
最好先把数语解释一遍

48:41.790 --> 48:41.890
好

48:41.890 --> 48:43.190
接下来我们看详细流程

48:43.590 --> 48:44.590
详细怎么比较的

48:44.890 --> 48:45.990
现在我们目前就是个样

48:45.990 --> 48:47.190
这个这么一个情况

48:47.190 --> 48:47.990
有一颗秀数

48:47.990 --> 48:48.790
有一颗新数

48:48.990 --> 48:50.190
就数里面有一些lm

48:50.190 --> 48:51.190
新数里面啥都没有

48:51.790 --> 48:53.390
整个比较流程呢

48:53.390 --> 48:55.590
他整体上是这样的流程比较的

48:56.290 --> 48:57.790
深度优先变地

48:58.390 --> 49:00.190
然后呢同级比较

49:00.290 --> 49:01.290
也就是什么呢

49:01.290 --> 49:02.790
什么叫深度优先变地呢

49:02.790 --> 49:03.390
比较多

49:03.590 --> 49:05.190
他应该是先变了他

49:05.790 --> 49:06.990
从根结点开始啊

49:07.190 --> 49:07.990
先变了他

49:10.350 --> 49:11.650
他ok啊

49:11.750 --> 49:13.950
他是相同进入更新流程

49:14.150 --> 49:15.550
只有进入了更新流程

49:15.550 --> 49:17.750
才会变才会对比指节点

49:17.950 --> 49:19.550
好在比在比较他

49:20.250 --> 49:20.850
和他

49:23.080 --> 49:24.380
好在比较

49:25.680 --> 49:26.180
他

49:26.880 --> 49:27.480
和他

49:28.080 --> 49:29.080
好比较到他的时候啊

49:29.080 --> 49:30.180
比方说这里还有一个啊

49:30.280 --> 49:30.880
举个例子啊

49:30.880 --> 49:31.680
这里还有一个

49:32.980 --> 49:34.380
嗯比较到他的时候呢

49:34.380 --> 49:36.380
由于他又他们有指节点

49:36.380 --> 49:37.780
所以说深度优先

49:38.380 --> 49:39.380
又会比较他

49:40.780 --> 49:41.280
和他

49:42.080 --> 49:42.780
原理是吧

49:42.980 --> 49:44.180
大概就是这么个意思

49:44.280 --> 49:45.880
那么这边没有了啊

49:45.880 --> 49:46.980
没有了不管他

49:47.080 --> 49:48.280
那么这边呢有

49:48.280 --> 49:49.280
那么在比较他

49:52.380 --> 49:53.880
叫深度优先变地

49:54.980 --> 49:56.380
啊就有直接点

49:56.580 --> 49:58.080
比较到自己过后

49:58.180 --> 49:59.580
再去比较他的指节点

49:59.780 --> 50:01.180
不着急就比较下一个

50:01.480 --> 50:02.880
这叫深度优先啊

50:03.280 --> 50:04.880
那么什么叫同级比较呢

50:04.880 --> 50:06.180
同级比较指的是

50:06.180 --> 50:07.880
他一定不会出现这种情况

50:08.380 --> 50:08.880
他

50:09.580 --> 50:10.780
跟他去比较

50:11.180 --> 50:12.580
一定不会出现这种情况

50:13.380 --> 50:13.880
对吧

50:13.880 --> 50:14.780
那么比较的时候呢

50:14.780 --> 50:17.380
要么就是他跟他来比较

50:17.480 --> 50:18.380
要么呢就是

50:19.080 --> 50:20.680
他跟他来比较

50:20.780 --> 50:21.180
对吧

50:21.180 --> 50:22.980
他一定不会出现跨级的比较

50:23.280 --> 50:23.480
对吧

50:23.480 --> 50:24.480
这就是他们最

50:24.780 --> 50:26.480
就是无论是Rx还是5u

50:26.980 --> 50:27.880
他的地府算法呢

50:27.880 --> 50:28.580
都是这样子

50:29.180 --> 50:31.480
深度优先变地同级比较

50:32.680 --> 50:32.980
好

50:32.980 --> 50:33.480
然后呢

50:33.480 --> 50:34.580
再来看他的细节

50:35.080 --> 50:36.080
他具体怎么比较的呢

50:36.080 --> 50:37.380
他首先比较跟节点

50:39.480 --> 50:40.480
比较跟节点的时候

50:40.480 --> 50:42.180
他会有这么一些流程

50:42.480 --> 50:44.280
如果说两个跟节点

50:44.580 --> 50:45.280
相同

50:45.280 --> 50:47.280
你看这里我用了数语相同

50:47.380 --> 50:48.380
知道相同什么意思吧

50:48.380 --> 50:49.380
刚才解释过了啊

50:49.680 --> 50:51.380
如果说这两个节点相同

50:51.380 --> 50:52.880
他就会进入更新流程

50:53.680 --> 50:55.480
如果说两个节点不相同的话

50:55.480 --> 50:56.380
特别简单

50:57.580 --> 50:58.880
纠结点直接销毁

50:58.880 --> 51:00.180
就后面不再比较了

51:00.880 --> 51:01.680
后面还比较吗

51:01.680 --> 51:02.480
不不比较了

51:02.480 --> 51:03.680
什么都不用比较了

51:04.380 --> 51:05.880
直接把就结点

51:06.080 --> 51:08.380
找到这个l.remove

51:09.380 --> 51:10.180
销毁元素是不是

51:10.180 --> 51:10.880
刚才解释过

51:10.880 --> 51:11.880
什么叫销毁元素

51:12.480 --> 51:13.080
remove

51:13.380 --> 51:13.980
ok了

51:13.980 --> 51:14.580
是不是这个

51:14.580 --> 51:15.380
键量看不见了

51:15.380 --> 51:16.680
把真实动物销毁掉了

51:16.880 --> 51:17.980
然后新节点

51:17.980 --> 51:18.880
第一规遍地

51:18.880 --> 51:19.980
一个一个去新键

51:20.380 --> 51:21.280
新键真实动

51:22.480 --> 51:22.980
对不对

51:23.680 --> 51:23.980
啊

51:23.980 --> 51:24.980
这就是这么一个意思

51:25.380 --> 51:27.080
那么也就是说啥意思呢

51:27.480 --> 51:29.280
平时大家在写这个代码的时候

51:29.380 --> 51:30.480
你要注意啊

51:30.880 --> 51:32.380
比方说我这里呢

51:32.380 --> 51:32.980
我这里

51:38.740 --> 51:40.540
比方说你在模板里面是这样子写的

51:42.140 --> 51:43.240
就简单的例子啊

51:46.630 --> 51:47.330
嗯

51:49.920 --> 51:51.120
跟节点

51:55.030 --> 51:56.330
h e

51:57.130 --> 51:57.930
或者是d

51:58.430 --> 51:59.230
div

51:59.730 --> 52:00.530
vif

52:01.530 --> 52:02.030
好

52:03.230 --> 52:04.430
里面有很多东西

52:07.360 --> 52:08.160
div

52:08.560 --> 52:09.360
这不是div

52:09.360 --> 52:10.160
叫sexy

52:10.760 --> 52:11.360
vl

52:23.670 --> 52:25.670
首先能不能能不能写这样的代码首先

52:26.170 --> 52:26.970
能不能写啊

52:26.970 --> 52:28.370
就语法上能不能通过

52:32.390 --> 52:33.190
为啥不能啊

52:37.240 --> 52:37.840
不能吗

52:37.840 --> 52:38.740
为啥不能啊

52:42.350 --> 52:43.950
就语法上是可以通过的啊

52:44.750 --> 52:46.050
我这里是只有一个根啊

52:46.050 --> 52:47.250
他要么要么就他是根嘛

52:47.250 --> 52:48.050
要么就他是根

52:49.750 --> 52:50.750
可以的可以的

52:51.150 --> 52:52.250
这个玩意就相当于是人家

52:52.250 --> 52:53.650
Render函数里边这样子写的

52:53.850 --> 52:56.150
Render函数里边这样子写的啊

52:56.150 --> 52:56.850
判断

52:57.650 --> 52:59.050
判断如果说

52:59.450 --> 53:00.150
啥啥啥

53:01.150 --> 53:02.150
我就返回

53:02.850 --> 53:03.950
我就返回什么

53:04.050 --> 53:05.550
h div

53:05.850 --> 53:06.550
你不要不写了啊

53:06.550 --> 53:07.250
后边不写了

53:07.650 --> 53:08.450
l是呢

53:08.850 --> 53:10.350
这这样怎么不行呢

53:10.950 --> 53:12.150
return我就返回

53:12.550 --> 53:13.550
嗯sexy

53:14.150 --> 53:14.350
对吧

53:14.350 --> 53:15.050
这怎么不行呢

53:15.050 --> 53:15.850
肯定是可以的

53:16.450 --> 53:16.850
可以的

53:17.450 --> 53:18.650
但这样子写好不好了

53:18.650 --> 53:20.250
比如说我都没有都没有这样子去写过

53:20.250 --> 53:20.650
对吧

53:20.950 --> 53:22.050
这样子写好不好了

53:22.050 --> 53:22.850
肯定不好

53:23.550 --> 53:24.050
肯定不好

53:24.050 --> 53:25.450
比方说这里边东西很多啊

53:25.950 --> 53:26.450
很多

53:26.450 --> 53:27.550
而且变化的体积不大

53:27.550 --> 53:29.750
你就你就为了不造什么原因

53:29.750 --> 53:31.750
你要把这个元素名字给它变的

53:31.750 --> 53:33.850
因为元素的名字一变的

53:34.650 --> 53:36.350
他比方他一开始显示他

53:36.810 --> 53:39.150
一开始第一次的学历学历

53:39.850 --> 53:40.250
水

53:41.450 --> 53:41.950
漏的

53:42.050 --> 53:43.050
哎呦这些错了啊

53:43.150 --> 53:44.050
这是谁个系

53:44.550 --> 53:45.550
不要再一人一系系

53:46.050 --> 53:47.750
之前的节点是不是一个div

53:48.050 --> 53:48.750
然后呢

53:48.850 --> 53:50.550
新的节点vlow的

53:50.650 --> 53:51.250
是什么呢

53:51.450 --> 53:52.250
是sexy

53:52.850 --> 53:55.350
哪怕里边有很多相同的元素

53:55.550 --> 53:56.050
但是呢

53:56.050 --> 53:57.850
由于这个根节点都不一样

53:58.050 --> 53:58.650
他会干嘛

53:58.650 --> 54:00.850
他直接把之前的真实动物直接给干掉了

54:01.050 --> 54:03.550
哪怕里边有一千个元素全部全部没了

54:04.050 --> 54:04.990
全部重新

54:04.990 --> 54:07.250
IZ的全部重新去给你建立新的

54:07.550 --> 54:08.150
真实动物

54:08.150 --> 54:09.550
所以他性能很差的啊

54:10.150 --> 54:11.050
不要去这样做

54:11.050 --> 54:12.650
不管是你是用根节点也好

54:12.650 --> 54:14.250
还是你去包含到里边也好

54:14.550 --> 54:15.050
都不要

54:15.250 --> 54:17.050
如果说他里边包含的东西太多

54:17.150 --> 54:18.650
你都不要这样做

54:19.450 --> 54:20.350
啊除非你们

54:20.450 --> 54:22.350
除非你们两个东西就完全不一样啊

54:22.350 --> 54:24.650
他里边东西跟他的里边东西就确实完全不一样

54:25.250 --> 54:26.450
他里边是一些超链接

54:26.450 --> 54:27.650
他里边是有很多图片

54:27.750 --> 54:28.550
就完全不一样

54:28.550 --> 54:30.350
那就可以没有没有任何问题

54:30.950 --> 54:33.050
本来就应该以数和新建对吧

54:33.150 --> 54:33.550
但是呢

54:33.550 --> 54:34.250
如果说

54:34.250 --> 54:35.650
他里边很多东西都是相似的

54:35.650 --> 54:36.350
你莫名其妙的

54:36.350 --> 54:37.850
有感觉他的元素名字

54:38.050 --> 54:39.050
这样不好的啊

54:40.150 --> 54:41.350
好都是关于这里

54:43.350 --> 54:43.950
呃

54:44.950 --> 54:45.450
来

54:47.390 --> 54:48.490
刚才说了不相同

54:48.490 --> 54:48.790
为啥呢

54:48.790 --> 54:49.690
就很非常简单

54:49.690 --> 54:50.890
消毁消毁就节点

54:51.190 --> 54:53.090
新节点的地规新建元素

54:54.690 --> 54:54.990
好

54:54.990 --> 54:57.390
接下来看如果说相同怎么办

54:57.990 --> 54:58.690
相同的话

54:58.690 --> 55:00.190
他就会进入更新流程

55:00.290 --> 55:00.590
来

55:00.590 --> 55:02.490
我们一步看更新流程是什么样子

55:02.990 --> 55:04.190
刚才不是说了更新流程吗

55:04.190 --> 55:05.190
但是我没有详细说

55:05.190 --> 55:05.490
对吧

55:05.490 --> 55:06.790
然后更新流程到底是什么样子

55:07.090 --> 55:08.990
他就是把旧节点的真实多文

55:08.990 --> 55:10.090
复制到新节点上

55:10.090 --> 55:10.890
就是一级代码

55:11.390 --> 55:13.090
新节点的L

55:14.090 --> 55:15.890
复制为旧节点的L

55:16.790 --> 55:17.390
简单吧

55:18.090 --> 55:18.990
是非常简单

55:19.690 --> 55:20.490
来看一下吧

55:21.990 --> 55:23.290
比方说这里有个旧节点啊

55:23.290 --> 55:24.090
我们只看根啊

55:24.090 --> 55:25.190
目前就看根节点

55:25.190 --> 55:26.590
他关联了一个真实的动物

55:27.290 --> 55:28.290
为什么写个5的5

55:28.290 --> 55:29.790
就是表示他的剃子吗

55:29.790 --> 55:30.990
他们元素都是一样的啊

55:30.990 --> 55:32.290
比方说元素都一样

55:33.690 --> 55:34.490
元素都一样

55:34.490 --> 55:35.490
剃子呢都是5

55:36.090 --> 55:36.890
那么他没有关

55:36.890 --> 55:37.590
关联那个真实动物

55:37.590 --> 55:37.990
真实动物

55:37.990 --> 55:38.990
比方说就随便来一个吧

55:38.990 --> 55:39.790
就是一个文本

55:40.290 --> 55:40.790
无所谓

55:41.790 --> 55:44.090
他第一件事情就做得非常简单

55:44.090 --> 55:45.690
就是把旧节点的真实动物

55:45.690 --> 55:47.290
复制给新节点

55:47.890 --> 55:52.250
就就就完了

55:52.250 --> 55:54.050
让新节点的新节点的这个L

55:54.050 --> 55:56.050
属性也去指向那个真实动物

55:57.050 --> 55:57.450
对吧

55:57.450 --> 55:59.050
因为他要承担一个任务就是

55:59.050 --> 56:00.750
他不但要更新真实动物

56:00.750 --> 56:01.950
还要让每一个节点里面

56:01.950 --> 56:02.850
要关联到真实动物

56:03.250 --> 56:04.650
这就是第一件事

56:04.650 --> 56:05.650
因为他们相同嘛

56:05.650 --> 56:06.850
所以说我们就重复地

56:06.850 --> 56:08.050
去使用这个真实动物

56:08.050 --> 56:09.050
真实动物不变了

56:09.050 --> 56:10.350
重复地去使用它

56:10.850 --> 56:11.150
对吧

56:11.150 --> 56:11.850
这是第一件事

56:12.250 --> 56:13.250
当然这个部分呢

56:14.250 --> 56:15.250
你千万不要认为

56:15.250 --> 56:16.750
这里在复制那个真实动物

56:18.250 --> 56:19.250
千万不要这样认为

56:19.250 --> 56:20.250
这是只是一个引用

56:20.250 --> 56:20.950
因为这动物呢

56:20.950 --> 56:21.750
它也是个对象

56:21.750 --> 56:23.150
它只是一个地址传过去的

56:24.750 --> 56:25.750
第二件事情

56:26.350 --> 56:28.750
对比新节点和旧节点的属性

56:28.750 --> 56:29.750
有变化的呢

56:29.750 --> 56:31.150
更新到真实动物中

56:31.150 --> 56:32.350
那么就非常简单了

56:32.350 --> 56:33.350
比方说啊

56:33.350 --> 56:34.150
他们发现呢

56:34.150 --> 56:35.150
新的动物里面呢

56:35.150 --> 56:36.150
可能有些属性

56:36.750 --> 56:37.950
比方说ID呢

56:38.950 --> 56:39.950
ID呢是

56:40.950 --> 56:42.650
Title2

56:42.850 --> 56:44.250
之前的ID呢

56:44.450 --> 56:45.650
是Title1

56:46.650 --> 56:47.250
对吧

56:47.450 --> 56:48.050
然后呢

56:48.050 --> 56:49.450
现在的class呢

56:51.050 --> 56:52.150
那样式呢

56:52.150 --> 56:53.850
越是可能有动态绑定嘛

56:53.850 --> 56:54.550
可能那样式呢

56:54.550 --> 56:55.650
container2

56:56.250 --> 56:57.750
那么之前的那样式呢

56:57.750 --> 56:59.450
可能是container1

56:59.450 --> 56:59.850
对吧

56:59.950 --> 57:00.850
它就去对比

57:00.850 --> 57:02.250
跟它就会对比新就

57:02.250 --> 57:03.350
两个旧节点的

57:03.450 --> 57:04.850
这些属性

57:05.350 --> 57:06.250
各种信息

57:06.450 --> 57:07.250
IDA去对比

57:07.450 --> 57:08.550
如果它发现有变化

57:08.550 --> 57:10.450
比方说他跟他发现有变化

57:10.550 --> 57:12.650
那么他就会去找到这个真实动物

57:12.650 --> 57:14.050
把ID给他改成新的

57:14.550 --> 57:15.350
就这么简单

57:15.850 --> 57:16.050
啊

57:16.050 --> 57:17.450
如果他他跟他有变化

57:17.450 --> 57:18.850
那么他就会找到他的class

57:18.850 --> 57:20.050
给他改成这个

57:20.850 --> 57:21.550
简单嘛

57:21.550 --> 57:22.350
非常简单嘛

57:23.050 --> 57:23.350
对吧

57:23.350 --> 57:23.950
他就是

57:24.050 --> 57:25.550
也就是他节点不要去动

57:25.550 --> 57:26.350
不会去删除他

57:26.350 --> 57:27.350
也不会去移动他

57:27.350 --> 57:28.850
他只是跟定了他的属性

57:29.850 --> 57:30.050
好

57:30.050 --> 57:30.850
这是第二件事

57:31.450 --> 57:34.150
当前两个节点处理完毕之后

57:34.250 --> 57:35.850
开始对比直节点

57:36.350 --> 57:37.250
也就是现在呢

57:37.450 --> 57:38.050
如果说

57:38.050 --> 57:39.250
把这两件事情都做了

57:39.250 --> 57:41.750
那么你看这个真实动物就已经ok了

57:41.950 --> 57:42.250
对吧

57:42.250 --> 57:43.850
属性也是用的最新的了

57:45.050 --> 57:46.450
那么节点呢

57:46.450 --> 57:47.350
也没有去动他

57:47.850 --> 57:48.850
所以就已经ok了

57:48.850 --> 57:51.350
那么现在就去找他的指节点

57:51.750 --> 57:52.750
我没有画出来啊

57:52.750 --> 57:53.750
就有的指节点

57:54.250 --> 57:55.950
然后是不是拿到两个数组

57:56.150 --> 57:57.450
旧的指节点是一个数组

57:57.450 --> 57:58.950
新的指节点也是一个数组

57:59.150 --> 57:59.750
然后去

57:59.950 --> 58:01.950
根据两个数组来进行对比

58:02.350 --> 58:03.850
那么就会进入到这个流程

58:03.850 --> 58:05.250
对比指节点的流程

58:07.120 --> 58:07.820
好这一块

58:07.820 --> 58:08.720
听到这一块

58:09.120 --> 58:09.920
有没有什么问题

58:09.920 --> 58:10.320
没问题了

58:18.110 --> 58:18.310
好

58:18.310 --> 58:19.810
那么现在是对比指节点啊

58:20.710 --> 58:21.910
对比指节点的时候呢

58:21.910 --> 58:22.710
在面试的时候

58:22.710 --> 58:23.910
你一定要回答出

58:24.010 --> 58:25.310
他用到了双指针

58:25.510 --> 58:26.310
以后我会讲

58:27.510 --> 58:28.410
对比指节点的时候

58:28.410 --> 58:29.810
现在手上有两个数组

58:30.810 --> 58:31.910
他就不是这种情况了

58:31.910 --> 58:32.910
他是这种情况

58:34.710 --> 58:35.410
这是旧的

58:35.910 --> 58:36.710
是拿到一个数组

58:36.710 --> 58:37.710
蓄力节点的数组

58:37.810 --> 58:38.410
新的

58:38.410 --> 58:39.810
是拿到一个蓄力节点的数组

58:40.810 --> 58:41.610
旧的节点

58:41.610 --> 58:42.610
他会关联到

58:43.210 --> 58:44.110
真实的动物

58:44.710 --> 58:45.610
新的节点呢

58:45.610 --> 58:47.010
一个真实动物都没有

58:48.010 --> 58:48.610
那么他怎么来

58:48.610 --> 58:50.310
一步一步去完成这个比对

58:51.910 --> 58:52.910
对比指节点的时候呢

58:52.910 --> 58:54.510
他做了很多的操作

58:54.510 --> 58:55.310
那么这些操作呢

58:55.310 --> 58:56.510
都只有一个目的

58:57.010 --> 58:57.510
什么目的呢

58:57.510 --> 58:58.810
就是尽量的

58:59.410 --> 59:00.410
傻业别墅

59:00.610 --> 59:01.710
你就对比就完了

59:01.810 --> 59:02.910
尽量的一个真实动物

59:02.910 --> 59:03.610
都不要去动

59:04.110 --> 59:04.810
但是呢

59:05.110 --> 59:06.110
这是说不到的啊

59:06.310 --> 59:07.710
因为毕竟我们有变化

59:07.710 --> 59:08.310
对不对

59:08.510 --> 59:10.310
如果实在不行的话

59:10.410 --> 59:12.910
那么就尽量的改动元素的属性

59:14.010 --> 59:15.710
改改一下他的属性就ok了

59:16.410 --> 59:17.910
如果还不行的话

59:17.910 --> 59:19.710
那么就尽量的移动元素

59:20.210 --> 59:22.010
而不要去三处和创建

59:22.910 --> 59:24.410
因为三处和创建的话

59:24.910 --> 59:26.210
是非常消耗性能的

59:27.210 --> 59:28.310
关于创建那个元素

59:28.310 --> 59:30.010
创建元素的一块

59:30.110 --> 59:30.310
啊

59:30.310 --> 59:31.710
之前是给人家演示过

59:31.710 --> 59:31.910
对吧

59:31.910 --> 59:33.610
循环一千万是与创建元素

59:33.910 --> 59:35.510
如果平凡的去新建和创建

59:35.510 --> 59:37.510
三处和创建是非常浪费性能的

59:38.010 --> 59:38.710
如果实际

59:38.710 --> 59:40.010
这些都还搞不定的话

59:40.010 --> 59:40.710
那没办法了

59:40.710 --> 59:41.910
只能创建和删除

59:43.410 --> 59:45.210
所以他追寻这么一个原则

59:45.210 --> 59:46.710
那么具体是怎么做的呢

59:47.610 --> 59:48.310
这个东西没法用

59:48.310 --> 59:49.710
没法用那个笔记来写的啊

59:49.710 --> 59:50.710
到这里面数的时候

59:50.710 --> 59:51.610
你告诉他们

59:51.710 --> 59:52.510
告诉面试官

59:52.910 --> 59:54.310
这里边他用到了双指针

59:55.110 --> 59:56.610
每一个数组里边

59:56.610 --> 59:57.710
他有两个指针

59:58.310 --> 59:59.110
指针什么意思

59:59.110 --> 01:00:00.110
就是个这里的指针

01:00:00.110 --> 01:00:02.110
跟C不是C元的里边指针啊

01:00:02.210 --> 01:00:03.110
他就是两个变量

01:00:03.310 --> 01:00:04.610
一个变量指向数组的头

01:00:04.610 --> 01:00:05.910
一个变量指向数组的尾

01:00:06.810 --> 01:00:07.310
是吧

01:00:07.310 --> 01:00:08.210
所以就双指针

01:00:08.710 --> 01:00:09.410
到双面试的时候

01:00:09.410 --> 01:00:10.110
怎么回答

01:00:10.210 --> 01:00:11.210
你用双指针

01:00:11.310 --> 01:00:11.910
头指针呢

01:00:11.910 --> 01:00:12.910
往右移动

01:00:13.310 --> 01:00:14.110
为指针呢

01:00:14.210 --> 01:00:15.310
往左边移动

01:00:15.510 --> 01:00:16.810
直到两个指针重叠

01:00:17.110 --> 01:00:18.110
来进行对比

01:00:19.310 --> 01:00:20.710
Q的那棵树有两个指针

01:00:20.710 --> 01:00:22.310
新的那棵树有也有两个指针

01:00:22.310 --> 01:00:23.710
那么他到底是怎么对比的呢

01:00:23.710 --> 01:00:24.210
我现在

01:00:24.310 --> 01:00:25.010
通过一个例子

01:00:25.010 --> 01:00:26.010
给大家解释啊

01:00:26.410 --> 01:00:27.510
这一块比较复杂

01:00:27.610 --> 01:00:28.010
但是呢

01:00:28.010 --> 01:00:29.610
其实你看看懂了过

01:00:29.610 --> 01:00:30.010
也

01:00:30.810 --> 01:00:31.810
只是觉得比较繁数啊

01:00:31.810 --> 01:00:32.710
也不要那么老虎

01:00:33.710 --> 01:00:35.310
他首先比较

01:00:35.310 --> 01:00:37.910
新数的救数和新数的投资针

01:00:38.310 --> 01:00:39.110
一不一样

01:00:39.110 --> 01:00:40.110
是不是相同的

01:00:41.810 --> 01:00:42.910
比较是不是相同的

01:00:42.910 --> 01:00:44.910
如果说是相同的

01:00:44.910 --> 01:00:45.510
怎么办

01:00:46.510 --> 01:00:48.310
他就会进入更新流程

01:00:51.400 --> 01:00:52.500
又回到这个流程了

01:00:53.200 --> 01:00:54.700
就这两个鞋点一比较相同

01:00:54.700 --> 01:00:55.800
我可以进入这个流程了

01:00:55.800 --> 01:00:57.100
那么这个流程要干嘛呀

01:00:57.100 --> 01:01:00.600
这个流程就是首先把这个I2弄过来

01:01:01.300 --> 01:01:02.900
这个数字表示key的意思啊

01:01:02.900 --> 01:01:03.500
key值

01:01:03.700 --> 01:01:04.600
都是同一个远处比较

01:01:04.600 --> 01:01:05.500
都是li嘛

01:01:05.500 --> 01:01:06.600
都是li远处

01:01:07.200 --> 01:01:08.000
key值又一样

01:01:08.000 --> 01:01:08.700
那么也相同

01:01:09.200 --> 01:01:10.400
所以把这个东西连过来

01:01:10.900 --> 01:01:11.200
对吧

01:01:11.200 --> 01:01:12.000
这是第一步

01:01:12.000 --> 01:01:12.900
第二步呢

01:01:13.400 --> 01:01:14.700
就通过新节点的

01:01:14.700 --> 01:01:16.500
看一下有没有什么属性的变化

01:01:16.500 --> 01:01:17.700
有没有什么配置的变化

01:01:17.800 --> 01:01:18.400
有变化的话

01:01:18.400 --> 01:01:19.800
去更改什么id啊

01:01:20.400 --> 01:01:21.200
class啊

01:01:21.400 --> 01:01:22.700
这些乱七八糟的属性

01:01:23.000 --> 01:01:24.100
更改到真实的动

01:01:24.100 --> 01:01:24.400
对吧

01:01:24.400 --> 01:01:25.800
然后真实的我们的反应出来

01:01:26.500 --> 01:01:27.900
然后接下来是不是还要去辩定

01:01:27.900 --> 01:01:29.700
他的指节点和他的指节点

01:01:29.700 --> 01:01:30.100
对吧

01:01:30.100 --> 01:01:31.300
然后地规则去辩定

01:01:31.400 --> 01:01:33.400
那么针对他的指节点和他的指节点

01:01:33.400 --> 01:01:34.400
他的流程是怎么了

01:01:34.500 --> 01:01:35.300
又是这个流程

01:01:37.470 --> 01:01:38.070
听懂了吧

01:01:38.070 --> 01:01:39.870
如果说这投资人相同

01:01:40.170 --> 01:01:40.970
两个投资人相同

01:01:40.970 --> 01:01:42.270
他就进入到更新流程

01:01:42.270 --> 01:01:44.470
第一步真实真实的我们拿过来

01:01:44.770 --> 01:01:45.870
形成他的属性

01:01:46.170 --> 01:01:46.570
哎呦

01:01:48.370 --> 01:01:50.470
形成他的属性就流vload

01:01:52.370 --> 01:01:52.870
哎呦

01:01:53.670 --> 01:01:55.770
等于o的vload

01:01:56.070 --> 01:01:57.070
哎呦就这么简单

01:01:57.370 --> 01:01:58.070
那第一步

01:01:58.770 --> 01:01:59.570
第二步呢

01:01:59.670 --> 01:02:01.670
对比这个两个区别的多么节点的

01:02:01.670 --> 01:02:02.470
就是属性

01:02:02.770 --> 01:02:04.970
该该反应到真实节点的去反应

01:02:05.170 --> 01:02:05.970
第三步

01:02:06.670 --> 01:02:07.970
对比指节点对吧

01:02:07.970 --> 01:02:09.070
所以一个地规的流程

01:02:09.370 --> 01:02:10.270
他的指节点拿出来

01:02:10.270 --> 01:02:11.270
他的指节点拿出来

01:02:11.270 --> 01:02:12.470
又重新经过这个流程

01:02:12.470 --> 01:02:13.670
这叫深度游线

01:02:14.070 --> 01:02:14.570
看没

01:02:15.170 --> 01:02:15.670
那么现在呢

01:02:15.670 --> 01:02:17.470
我就不用去考虑他的指节点了啊

01:02:17.470 --> 01:02:19.770
他指节点反正反正就是重复这个流程了

01:02:20.070 --> 01:02:21.770
那么这个节点是不是就搞定了

01:02:21.870 --> 01:02:23.170
搞定了过后我会把

01:02:24.070 --> 01:02:24.970
这样子来

01:02:25.570 --> 01:02:26.670
这个节点是不是ok了

01:02:26.970 --> 01:02:28.070
好接下来我们看下一个

01:02:28.710 --> 01:02:30.970
接下来他会把这个投资人往右移动

01:02:31.710 --> 01:02:33.170
这个投资人也会往右移动

01:02:33.370 --> 01:02:34.170
又重新来

01:02:34.270 --> 01:02:35.270
进入下一次对比

01:02:35.670 --> 01:02:36.670
下一次对比又来

01:02:36.770 --> 01:02:39.170
对比两个投资争一不一样啊

01:02:39.670 --> 01:02:40.270
不一样

01:02:40.470 --> 01:02:41.070
注意哦

01:02:41.070 --> 01:02:42.070
现在他不一样

01:02:42.070 --> 01:02:43.270
但是他没完

01:02:43.870 --> 01:02:45.170
他不说这个时候就要删除

01:02:45.170 --> 01:02:46.370
就要小鬼去新建了

01:02:46.370 --> 01:02:47.570
跟那个根键点也不一样

01:02:47.570 --> 01:02:48.370
根键点不一样

01:02:48.370 --> 01:02:49.570
是不是就急一会小鬼

01:02:49.570 --> 01:02:50.470
一定会新建

01:02:50.470 --> 01:02:51.570
但是这个时候不是

01:02:52.470 --> 01:02:53.370
这个时候会怎么样

01:02:53.370 --> 01:02:54.070
怎么样呢

01:02:54.170 --> 01:02:55.470
他会看违視者

01:02:56.370 --> 01:02:57.870
看尾巴上有没有相同

01:02:58.170 --> 01:02:59.970
就他尽量的去找相同的

01:03:00.770 --> 01:03:03.170
我发现尾巴上是相同的那ok

01:03:03.370 --> 01:03:05.570
那又来这个流程进入更新流程

01:03:05.970 --> 01:03:07.270
来连过来

01:03:08.770 --> 01:03:11.270
然后呢该更新属性的去更新

01:03:11.270 --> 01:03:12.570
然后对比他们的直接点

01:03:12.670 --> 01:03:13.170
对吧

01:03:13.670 --> 01:03:14.970
好那么把他搞定

01:03:16.570 --> 01:03:18.370
你看是不是两个真实动物都搞定了

01:03:18.470 --> 01:03:20.670
五合七是不是反映了新的情况了

01:03:21.270 --> 01:03:22.770
都已经反映到新的情况里边了

01:03:23.070 --> 01:03:23.770
好接下来

01:03:24.170 --> 01:03:25.970
维持着向左移动

01:03:28.840 --> 01:03:30.540
又来又进入下一次对比

01:03:30.840 --> 01:03:31.840
投资针一样吗

01:03:31.840 --> 01:03:32.440
不一样

01:03:32.740 --> 01:03:33.840
维持针一样吗

01:03:33.940 --> 01:03:34.540
不一样

01:03:34.940 --> 01:03:36.640
这个时候他会这样来对比

01:03:36.640 --> 01:03:37.340
还没完

01:03:37.640 --> 01:03:38.840
他要去这样对比

01:03:39.040 --> 01:03:41.040
他对比一下头尾一样吗

01:03:41.440 --> 01:03:43.340
这个的头跟这个的尾巴一样吗

01:03:44.140 --> 01:03:45.440
发现是一样的

01:03:46.240 --> 01:03:46.840
连过来

01:03:51.160 --> 01:03:51.960
啊连过来

01:03:52.960 --> 01:03:55.260
那这个时候呢会发发生一些变化啊

01:03:55.260 --> 01:03:56.360
不光要连过来

01:03:56.860 --> 01:03:57.860
进入更新流程啊

01:03:57.860 --> 01:04:00.060
然后呢把这些属性放到这里边去啊

01:04:00.060 --> 01:04:01.760
该更新属性的更新属性

01:04:02.460 --> 01:04:03.660
啊然后对比直接点

01:04:03.760 --> 01:04:05.560
那些弄啊弄完

01:04:05.960 --> 01:04:07.560
弄完了过后还要做一件事

01:04:08.060 --> 01:04:08.960
他会导致

01:04:08.960 --> 01:04:11.160
因为这个他们对比的是头尾指针

01:04:11.160 --> 01:04:12.060
说明说明什么

01:04:12.160 --> 01:04:13.760
说明他的位置会有变化

01:04:14.360 --> 01:04:16.160
这个元素的位置不能在这

01:04:16.460 --> 01:04:17.560
那么他会在哪呢

01:04:18.060 --> 01:04:19.260
他会把它放到

01:04:19.660 --> 01:04:20.360
这个尾

01:04:20.560 --> 01:04:22.760
就是这个纠结的尾巴后边

01:04:24.160 --> 01:04:25.860
他会把他放到这个指针的后边

01:04:26.260 --> 01:04:27.160
于是放到了这

01:04:28.860 --> 01:04:29.760
所以元素移动

01:04:29.760 --> 01:04:31.060
那个元素移动很简单吗

01:04:31.260 --> 01:04:33.160
你们用个原生多么都都能写出来

01:04:33.160 --> 01:04:33.560
对吧

01:04:33.760 --> 01:04:34.960
元素元素移动

01:04:35.460 --> 01:04:36.460
就可以移动到这

01:04:37.960 --> 01:04:38.560
没问题吧

01:04:38.960 --> 01:04:40.660
好那么这个节点是搞定的

01:04:42.730 --> 01:04:44.130
你看这个节点的顺序啊

01:04:44.130 --> 01:04:46.130
一看一个浅色的顺序是搞定的

01:04:46.230 --> 01:04:47.330
527

01:04:47.630 --> 01:04:49.130
真是真实动物527

01:04:49.130 --> 01:04:51.130
他完全不管旧的动物对不对

01:04:51.530 --> 01:04:53.130
旧的虚极点他完全管都不管

01:04:53.130 --> 01:04:54.930
他只管真实动物ok就ok了

01:04:56.430 --> 01:04:56.830
好

01:04:57.630 --> 01:04:58.930
那么这个顺序搞定的

01:04:59.030 --> 01:05:00.430
接下来他做的事情是

01:05:00.430 --> 01:05:02.030
这边的头往右边移动

01:05:02.030 --> 01:05:03.830
这边的尾巴往左边移动

01:05:04.830 --> 01:05:05.930
优心如下一次

01:05:06.330 --> 01:05:07.130
下一次是什么

01:05:07.230 --> 01:05:08.630
优然对比头一样吗

01:05:08.730 --> 01:05:09.330
不一样

01:05:09.530 --> 01:05:10.330
尾巴一样吗

01:05:10.430 --> 01:05:11.030
不一样

01:05:11.130 --> 01:05:12.030
那么这个头尾

01:05:12.330 --> 01:05:13.230
头尾一样吗

01:05:13.330 --> 01:05:13.930
不一样

01:05:14.130 --> 01:05:15.430
这边的头尾还要比较

01:05:15.630 --> 01:05:16.130
一样吗

01:05:16.130 --> 01:05:16.730
不一样

01:05:17.230 --> 01:05:17.830
是不是找不到了

01:05:17.830 --> 01:05:19.030
找不到一个一样的了

01:05:19.330 --> 01:05:20.030
那怎么办呢

01:05:20.030 --> 01:05:21.930
你看他不不甘心的还要来

01:05:22.730 --> 01:05:24.230
他把这个头子人拿出来

01:05:25.130 --> 01:05:25.830
看这个

01:05:25.930 --> 01:05:26.930
然后呢

01:05:27.030 --> 01:05:29.730
他会去整个剩下的元素里边去找

01:05:31.130 --> 01:05:32.430
这里边他用了一种巧门的办法

01:05:32.430 --> 01:05:33.430
叫做映射

01:05:33.630 --> 01:05:34.830
用映射地图去找

01:05:35.030 --> 01:05:36.030
他不是循环去找

01:05:36.130 --> 01:05:37.030
总之他会去找

01:05:37.430 --> 01:05:38.830
你可以把它当成循环去找

01:05:39.030 --> 01:05:40.030
实际上不是循环

01:05:40.030 --> 01:05:41.630
他有一种更高效的方式

01:05:42.830 --> 01:05:45.130
他会从整个剩下的东西里边去找

01:05:45.730 --> 01:05:47.130
找到是不是找到他了

01:05:48.130 --> 01:05:48.430
对不对

01:05:48.430 --> 01:05:49.130
是不是找到他了

01:05:49.630 --> 01:05:50.830
找到他了过后

01:05:51.530 --> 01:05:52.330
会怎么样了

01:05:53.330 --> 01:05:54.330
找到他了过后

01:05:54.630 --> 01:05:56.630
他会把他的真实动物

01:05:56.630 --> 01:05:58.230
复制给他进入更新流测

01:05:59.230 --> 01:06:02.230
你看伍佑的就想了一切办法

01:06:02.230 --> 01:06:04.530
尽量的重复去利用这些东西

01:06:06.540 --> 01:06:08.240
然后去更新他的属性

01:06:08.240 --> 01:06:09.240
更新他的样式

01:06:09.240 --> 01:06:10.640
然后对比他的指节点

01:06:10.640 --> 01:06:11.040
是吧

01:06:11.440 --> 01:06:11.640
好

01:06:11.640 --> 01:06:12.840
这个时候会涉及到

01:06:13.140 --> 01:06:14.040
位置的移动

01:06:14.340 --> 01:06:15.940
那么这位置移动到哪呢

01:06:17.040 --> 01:06:18.240
位置他会移动到

01:06:18.340 --> 01:06:20.040
这个节点之前

01:06:21.440 --> 01:06:23.340
他会移动到这个节点之前

01:06:23.540 --> 01:06:24.240
所以说了

01:06:24.240 --> 01:06:25.040
他会移动到

01:06:26.040 --> 01:06:26.540
这

01:06:27.640 --> 01:06:29.040
哎不是不是这个节点

01:06:29.540 --> 01:06:30.240
不是这个节点

01:06:30.240 --> 01:06:31.540
他会移动到这个节点啊

01:06:31.540 --> 01:06:32.440
因为这个这个节点

01:06:32.440 --> 01:06:34.040
他没有指向现在的真实动物

01:06:34.040 --> 01:06:34.440
对吧

01:06:34.540 --> 01:06:35.440
移动到这个节点

01:06:35.440 --> 01:06:36.640
指向了真实动物之前

01:06:37.040 --> 01:06:38.240
转移动1-2-4

01:06:38.240 --> 01:06:38.440
对吧

01:06:38.440 --> 01:06:39.340
是不是移动过去了

01:06:41.040 --> 01:06:42.240
那么这个节点是搞定的

01:06:44.480 --> 01:06:44.780
好

01:06:44.780 --> 01:06:45.480
然后搞定过后

01:06:45.480 --> 01:06:46.680
他只移动一个指正

01:06:47.080 --> 01:06:47.880
移动这个指正

01:06:49.180 --> 01:06:49.680
由来

01:06:50.980 --> 01:06:51.680
比较头

01:06:52.080 --> 01:06:52.580
不一样

01:06:52.880 --> 01:06:54.280
比较尾巴不一样

01:06:54.580 --> 01:06:55.880
比较头尾不一样

01:06:56.280 --> 01:06:57.080
比较特别的头尾

01:06:57.080 --> 01:06:57.880
说又一样了

01:06:58.180 --> 01:06:58.680
又来

01:07:01.710 --> 01:07:02.310
沿过来

01:07:03.810 --> 01:07:05.010
啊更新样书跟

01:07:05.010 --> 01:07:06.010
然后对比直接练

01:07:06.110 --> 01:07:07.310
然后位置有变化

01:07:07.610 --> 01:07:09.210
那么他会把他的位置

01:07:09.910 --> 01:07:10.610
放到哪呢

01:07:10.810 --> 01:07:11.710
也是一样

01:07:11.710 --> 01:07:12.610
放到这个头

01:07:12.610 --> 01:07:13.810
这个头指针指向了

01:07:14.010 --> 01:07:14.910
真实动物之前

01:07:16.010 --> 01:07:16.510
放到这呢

01:07:20.640 --> 01:07:21.040
好

01:07:21.140 --> 01:07:22.240
那么这个时候呢

01:07:22.540 --> 01:07:23.940
这个指针往这边移动

01:07:24.240 --> 01:07:25.640
这个指针往这边移动

01:07:27.140 --> 01:07:28.340
好重合了

01:07:28.540 --> 01:07:29.740
重合了也在哪呀

01:07:29.940 --> 01:07:31.040
头一样吗

01:07:31.040 --> 01:07:31.540
不一样

01:07:31.740 --> 01:07:32.640
尾巴一样吗

01:07:32.640 --> 01:07:33.140
不一样

01:07:33.240 --> 01:07:34.640
头头尾一样吗

01:07:34.640 --> 01:07:35.140
不一样

01:07:35.240 --> 01:07:36.040
头尾一样吗

01:07:36.040 --> 01:07:36.640
不一样

01:07:36.840 --> 01:07:37.640
都不一样

01:07:37.940 --> 01:07:38.540
说明啥

01:07:39.140 --> 01:07:41.040
说明这个节点是新的

01:07:41.140 --> 01:07:42.040
之前没有

01:07:43.040 --> 01:07:43.240
对吧

01:07:43.240 --> 01:07:44.340
他还还会去找啊

01:07:44.340 --> 01:07:45.440
对还有个去找

01:07:45.540 --> 01:07:46.840
找所有的圣语节点中

01:07:46.840 --> 01:07:48.140
圣语节点只剩他两个了啊

01:07:48.140 --> 01:07:48.740
他已经没了

01:07:48.840 --> 01:07:49.740
只剩他两个了

01:07:49.940 --> 01:07:51.440
那么他两个里边也没有吧

01:07:51.540 --> 01:07:53.140
所以说他一定是新的

01:07:53.240 --> 01:07:54.340
新的会怎么样呢

01:07:55.040 --> 01:07:56.840
新的他就会新

01:07:57.440 --> 01:07:58.740
他就会新建一个

01:07:58.940 --> 01:07:59.540
真实动物

01:08:00.040 --> 01:08:00.840
新建一个

01:08:02.040 --> 01:08:02.740
这是新的

01:08:03.140 --> 01:08:03.840
然后呢

01:08:03.940 --> 01:08:04.740
去指向他

01:08:04.740 --> 01:08:05.940
那这个时候只能新建了

01:08:05.940 --> 01:08:06.740
你还能干嘛呀

01:08:07.040 --> 01:08:07.940
没法了啊

01:08:09.440 --> 01:08:10.340
只能去新建

01:08:11.040 --> 01:08:11.840
好新建过后

01:08:11.840 --> 01:08:12.740
他放在哪呢

01:08:12.740 --> 01:08:14.340
他放了元素位置放在哪呢

01:08:14.540 --> 01:08:16.140
放在他的头指针

01:08:16.240 --> 01:08:17.440
指向了多么元素之情

01:08:19.040 --> 01:08:20.340
好那么这个节点就搞定了

01:08:21.740 --> 01:08:22.440
好接下来

01:08:22.440 --> 01:08:23.940
头指针继续往后面移动

01:08:24.240 --> 01:08:24.940
那么这个时候

01:08:24.940 --> 01:08:26.940
头指针的位置已经大于了维持着

01:08:27.740 --> 01:08:28.480
循环结束

01:08:28.480 --> 01:08:29.340
对比结束

01:08:29.640 --> 01:08:30.740
对比结束过后

01:08:32.840 --> 01:08:33.940
继续节点里边

01:08:34.740 --> 01:08:36.240
但是他会他会判断啊

01:08:36.240 --> 01:08:37.840
如果说循环结束过后

01:08:37.840 --> 01:08:39.240
发现继续节点里边

01:08:39.740 --> 01:08:41.640
头指针的位置

01:08:41.740 --> 01:08:43.640
仍然是小于等于维持人

01:08:43.940 --> 01:08:45.340
也就是继续节点还没有处理完

01:08:45.340 --> 01:08:45.840
对吧

01:08:45.940 --> 01:08:47.540
继续节点没有处理完的真实动物

01:08:47.940 --> 01:08:49.140
循环删除他

01:08:49.540 --> 01:08:50.340
循环到6

01:08:50.340 --> 01:08:51.240
删除真实动

01:08:51.640 --> 01:08:52.440
循环到1

01:08:52.440 --> 01:08:53.240
删除真实动

01:08:54.340 --> 01:08:55.040
那么就完了

01:08:55.040 --> 01:08:55.940
这就是整个过程

01:08:55.940 --> 01:08:57.140
那么整个过程完了过后

01:08:57.140 --> 01:08:57.840
你们看一下

01:08:58.040 --> 01:09:00.040
539827

01:09:00.340 --> 01:09:02.540
539827

01:09:03.540 --> 01:09:04.940
那有些同学说救动物怎么办

01:09:04.940 --> 01:09:06.140
救的虚拟动物怎么办

01:09:06.140 --> 01:09:07.240
你管他不用管他

01:09:07.440 --> 01:09:09.240
因为一旦对比结束

01:09:09.240 --> 01:09:10.140
我们的救的动物

01:09:10.140 --> 01:09:11.040
他无非就是一个

01:09:11.440 --> 01:09:12.140
一个变量

01:09:13.540 --> 01:09:14.640
救的救的这个动物

01:09:14.640 --> 01:09:15.640
他无非就是一个变量

01:09:15.640 --> 01:09:16.140
你看吧

01:09:16.140 --> 01:09:16.840
updates

01:09:20.990 --> 01:09:22.290
他就是一个临时的变量

01:09:22.290 --> 01:09:23.690
prevvido的

01:09:23.790 --> 01:09:25.090
一旦这个函数运行结束

01:09:25.090 --> 01:09:26.190
这个变量是不是就没了

01:09:26.490 --> 01:09:27.090
就没了

01:09:27.090 --> 01:09:28.290
就找不再也找不到了

01:09:28.290 --> 01:09:29.090
找不到过后呢

01:09:29.090 --> 01:09:30.490
那个救数就没有任何东西

01:09:30.490 --> 01:09:31.390
可以找到救数了

01:09:31.490 --> 01:09:33.290
那么垃圾回收器会把他回收掉

01:09:33.790 --> 01:09:35.090
那么将来这个救数就没了

01:09:36.390 --> 01:09:36.790
你看吧

01:09:36.790 --> 01:09:37.490
就这么个意思

01:09:37.490 --> 01:09:39.090
所以说最后去只剩新书了

01:09:39.490 --> 01:09:42.490
所以他完成了整个动物结点的对比

01:09:46.590 --> 01:09:48.490
对一个数据里面肯定都是同级的动物

01:09:48.890 --> 01:09:49.490
肯定啊

01:09:49.690 --> 01:09:51.090
因为他是跟接点来吧

01:09:51.190 --> 01:09:51.790
跟接点

01:09:52.090 --> 01:09:52.990
他们他的直接点

01:09:52.990 --> 01:09:54.490
跟他的直接点是不是同级的吗

01:09:54.490 --> 01:09:55.190
肯定是同级的

01:09:55.190 --> 01:09:55.590
对不对

01:09:55.790 --> 01:09:56.690
这两个跟接点

01:09:56.890 --> 01:09:58.190
那么对比到每一个结点的时候

01:09:58.190 --> 01:10:00.090
他的直接点跟他的直接点是不是同级的

01:10:00.090 --> 01:10:00.890
肯定是同级的

01:10:04.700 --> 01:10:07.000
多么放前放后是根据什么判断的

01:10:07.000 --> 01:10:08.200
根据实际情况判断的

01:10:08.200 --> 01:10:10.400
到底就是根据你到底移动的是哪一个指针

01:10:10.800 --> 01:10:12.100
其实你看那张图

01:10:12.100 --> 01:10:13.200
根据我们刚才的过程

01:10:13.200 --> 01:10:14.800
你自己看你都知道

01:10:15.100 --> 01:10:17.200
该放到他前面还是该放到他后面

01:10:17.500 --> 01:10:18.700
你自己看都知道

01:10:24.870 --> 01:10:25.270
好

01:10:28.050 --> 01:10:28.550
没看懂吧

01:10:28.550 --> 01:10:29.350
没看懂瞎来

01:10:29.350 --> 01:10:30.250
去多看几次路

01:10:30.250 --> 01:10:31.050
能路过啊

01:10:31.550 --> 01:10:32.950
路过多看几次这一块

01:10:33.350 --> 01:10:33.850
这一块呢

01:10:33.850 --> 01:10:34.950
其实你在面试的时候

01:10:34.950 --> 01:10:36.850
你只需要回达回达到两个点

01:10:36.850 --> 01:10:37.650
就是一个点

01:10:37.750 --> 01:10:39.350
就他们又使用了两个指针

01:10:39.850 --> 01:10:41.050
救数有两个指针

01:10:41.250 --> 01:10:42.450
新数有两个指针

01:10:42.450 --> 01:10:44.050
然后告诉他们指针移动的方向

01:10:44.850 --> 01:10:46.950
每一棵树的指头指针往右边移动

01:10:47.250 --> 01:10:48.550
为指针往左边移动

01:10:48.750 --> 01:10:49.750
一次对比

01:10:50.850 --> 01:10:52.050
你就告诉他这一点就行了

01:10:52.350 --> 01:10:53.550
他一般就就ok了

01:10:53.550 --> 01:10:54.050
面试的时候

01:10:54.050 --> 01:10:55.550
他不会问到你更深入的东西了

01:10:56.250 --> 01:10:57.150
比如说你真的有兴趣

01:10:57.150 --> 01:10:57.550
就像

01:10:58.050 --> 01:10:59.150
想搞清楚这一块的话

01:10:59.150 --> 01:11:00.150
你下来去把这个

01:11:01.050 --> 01:11:02.350
整个过程再去重新看一遍

01:11:03.950 --> 01:11:05.550
原码里边就是大量的判断

01:11:06.450 --> 01:11:07.050
原码里边

01:11:07.050 --> 01:11:07.850
你看一下吧

01:11:11.350 --> 01:11:11.650
嗯

01:11:12.550 --> 01:11:13.050
patch

01:11:14.250 --> 01:11:15.050
直接找patch吧

01:11:16.950 --> 01:11:17.750
src

01:11:18.350 --> 01:11:18.950
core

01:11:19.050 --> 01:11:19.950
一般vlog

01:11:20.250 --> 01:11:20.750
vlog

01:11:20.850 --> 01:11:22.150
其实我们里边有一个patch

01:11:24.260 --> 01:11:25.960
这里边超级多的函数啊

01:11:28.000 --> 01:11:28.600
我下转

01:11:29.400 --> 01:11:30.000
我下转

01:11:31.300 --> 01:11:32.500
啊这个大半比较多

01:11:32.500 --> 01:11:32.800
好

01:11:32.800 --> 01:11:34.300
你看就是个patch load

01:11:35.200 --> 01:11:36.300
old vdo的

01:11:38.100 --> 01:11:38.600
在这

01:11:38.700 --> 01:11:38.900
好

01:11:38.900 --> 01:11:39.900
我们进入这个函数啊

01:11:41.300 --> 01:11:42.000
这个函数

01:11:42.400 --> 01:11:43.000
呃

01:11:43.000 --> 01:11:44.700
对比这是对比两个节点

01:11:45.300 --> 01:11:46.400
然后我们往下找

01:11:47.500 --> 01:11:49.300
那找到他的对比值节点啊

01:11:53.260 --> 01:11:54.460
找到一个关键点

01:11:54.760 --> 01:11:56.560
这个函数的名字我忘了

01:11:56.560 --> 01:11:57.960
肯定找得到我们找一找吧

01:12:07.290 --> 01:12:07.790
找一找啊

01:12:07.790 --> 01:12:09.490
这就是我们把函数折叠起来

01:12:16.020 --> 01:12:17.880
还是哪个函数来着

01:12:18.720 --> 01:12:19.780
update的切入去

01:12:20.880 --> 01:12:21.680
应该是这个

01:12:22.280 --> 01:12:23.480
啊你看这这这这

01:12:24.380 --> 01:12:26.380
什么两个是不是有这么几个指摘

01:12:26.580 --> 01:12:28.480
哦的究竟两个提示指

01:12:28.480 --> 01:12:29.780
提示指摘

01:12:30.180 --> 01:12:32.080
那个究竟两个结束指摘

01:12:32.080 --> 01:12:33.980
新结新那个新数的

01:12:33.980 --> 01:12:35.280
提示指摘新数的

01:12:35.380 --> 01:12:36.080
结束指摘

01:12:36.080 --> 01:12:37.580
他是他的循环条件

01:12:37.580 --> 01:12:39.280
循环里边是有超级多的判断

01:12:39.980 --> 01:12:42.080
对不对啊如果说头没有

01:12:42.380 --> 01:12:45.180
头那个头节点没有定义怎么办啊

01:12:45.180 --> 01:12:46.880
或者是旧数的

01:12:46.980 --> 01:12:48.780
结束节点没有定义怎么办

01:12:48.880 --> 01:12:52.080
那么就看是不是头跟尾跟新节点是不一样的

01:12:52.280 --> 01:12:53.680
你看旧数的

01:12:54.480 --> 01:12:56.680
头指针跟新数的头针一不一样

01:12:56.980 --> 01:12:58.980
旧数的结束指针跟新数的结束指针

01:12:58.980 --> 01:12:59.680
一不一样

01:12:59.680 --> 01:13:01.780
旧数的提示指针跟新数的结束指针

01:13:01.780 --> 01:13:02.380
一不一样

01:13:02.780 --> 01:13:04.880
旧数的结束指针跟新数的提示指针

01:13:04.880 --> 01:13:05.480
一不一样

01:13:05.480 --> 01:13:06.480
我都不一样

01:13:06.480 --> 01:13:07.380
那还没完

01:13:07.380 --> 01:13:08.180
还要去找

01:13:08.480 --> 01:13:09.580
你看没有还要去找

01:13:13.400 --> 01:13:14.700
这是拿去带吧

01:13:14.700 --> 01:13:15.600
在这啊

01:13:15.900 --> 01:13:17.800
通过新数的头指针

01:13:18.100 --> 01:13:19.600
看新数的头节点

01:13:20.600 --> 01:13:23.000
去找从旧数里边去找新数的头节点

01:13:23.000 --> 01:13:24.000
看找被找得到

01:13:24.300 --> 01:13:25.200
看能不能找得到

01:13:25.200 --> 01:13:26.100
找得到个位置

01:13:26.100 --> 01:13:28.800
找到位置过后又又来做剩下的事情

01:13:28.800 --> 01:13:30.400
然后做完了过后投资人加一

01:13:30.400 --> 01:13:30.800
看没有

01:13:30.800 --> 01:13:31.800
这是他整个流程

01:13:31.800 --> 01:13:33.000
一大堆都判断

01:13:33.400 --> 01:13:35.700
这里面鞋鞋非常的繁殊

01:13:35.700 --> 01:13:36.300
非常繁殊

01:13:36.300 --> 01:13:37.000
特别小心

01:13:42.900 --> 01:13:44.700
这是这一块

01:13:46.780 --> 01:13:47.380
那就没了

01:13:48.180 --> 01:13:48.580
就没了

01:13:48.580 --> 01:13:50.580
这是咱们的地府的整个过程

01:13:50.980 --> 01:13:52.880
最后我给他说一下这个keyz

01:13:52.880 --> 01:13:54.380
那么为什么这个keyz呢

01:13:54.680 --> 01:13:57.680
为什么在循环的过程中需要大家去设置这个keyz

01:13:58.880 --> 01:13:59.780
这里我有

01:14:00.480 --> 01:14:01.180
两个例子

01:14:03.610 --> 01:14:04.510
第一个例子看一下

01:14:06.750 --> 01:14:07.550
第一个例子呢

01:14:09.750 --> 01:14:10.550
有一个Ul

01:14:10.550 --> 01:14:12.750
Ul里边循环渲染了一些li

01:14:12.750 --> 01:14:14.050
这个li那里特别简单

01:14:14.050 --> 01:14:15.950
就一个数组数组里面有12345

01:14:16.550 --> 01:14:17.650
我就循环这个数组

01:14:18.350 --> 01:14:19.650
我把keyz设为n

01:14:20.550 --> 01:14:22.150
我先不设置keyz吧

01:14:22.150 --> 01:14:23.250
我先不设置keyz

01:14:24.250 --> 01:14:25.250
不设置keyz呢

01:14:25.250 --> 01:14:26.550
我直接把这个n渲染出来

01:14:28.550 --> 01:14:29.550
然后呢

01:14:29.550 --> 01:14:30.650
我这里点击

01:14:31.450 --> 01:14:32.450
翻转数组

01:14:32.550 --> 01:14:33.950
然后这个头部插入

01:14:34.750 --> 01:14:35.350
这能看懂吗

01:14:35.350 --> 01:14:36.350
这个代码能不能看懂

01:14:36.650 --> 01:14:38.250
reverse就把个把个数组

01:14:38.550 --> 01:14:39.950
调过来啊5321

01:14:41.150 --> 01:14:44.150
n渲染成的就是往那个数组里面头部加一个100

01:14:45.550 --> 01:14:46.250
我们来看一下

01:14:46.250 --> 01:14:48.250
首先我们不设置keyz会怎么样

01:14:49.650 --> 01:14:51.450
那结构肯定是没问题啊

01:14:51.650 --> 01:14:52.550
翻转就翻转了

01:14:52.550 --> 01:14:53.850
头部插入头部插入了

01:14:55.350 --> 01:14:57.950
那么这样子会导致一个什么样的结果呢

01:14:58.550 --> 01:14:59.950
咱们从这个图里面来看

01:15:00.750 --> 01:15:01.550
复制一下啊

01:15:02.550 --> 01:15:03.550
这是旧数

01:15:03.550 --> 01:15:04.550
对吧1235

01:15:04.550 --> 01:15:05.550
新数

01:15:06.550 --> 01:15:07.550
11235

01:15:07.550 --> 01:15:09.550
但是由于他们没有keyz

01:15:10.550 --> 01:15:11.550
他们是没有keyz的

01:15:15.020 --> 01:15:16.020
你看啊

01:15:16.020 --> 01:15:17.020
他们没有keyz

01:15:18.020 --> 01:15:20.020
只有一个dome对吧

01:15:21.020 --> 01:15:23.020
那么导致的结果就是

01:15:23.020 --> 01:15:26.390
他跟他对比

01:15:26.390 --> 01:15:27.390
一样吗

01:15:27.390 --> 01:15:28.390
首先一不一样

01:15:28.390 --> 01:15:29.390
他们是不是同一个节点

01:15:31.960 --> 01:15:32.960
这里是100啊

01:15:32.960 --> 01:15:33.960
但是呢

01:15:33.960 --> 01:15:34.960
它是稳定是100

01:15:34.960 --> 01:15:35.960
他们是不是同一个节点

01:15:35.960 --> 01:15:36.960
他们不是key

01:15:37.960 --> 01:15:38.960
是不是

01:15:38.960 --> 01:15:39.960
是不是同一个节点

01:15:39.960 --> 01:15:41.960
同一个节点会怎么样

01:15:42.960 --> 01:15:43.960
他会把它附用

01:15:44.960 --> 01:15:45.960
附用

01:15:45.960 --> 01:15:46.960
他认为这个是同一个节点

01:15:46.960 --> 01:15:47.960
附用

01:15:47.960 --> 01:15:48.960
附用完过后

01:15:48.960 --> 01:15:49.960
是不是要对比

01:15:49.960 --> 01:15:51.960
更新元数的什么各种数项

01:15:51.960 --> 01:15:52.960
然后对比指元数

01:15:52.960 --> 01:15:53.960
也对比指元数的时候

01:15:53.960 --> 01:15:54.960
对比到这个数字

01:15:54.960 --> 01:15:55.960
数字是不是有变化

01:15:55.960 --> 01:15:56.960
数字又变了

01:15:56.960 --> 01:15:57.960
把1变成了100

01:15:58.960 --> 01:15:59.960
那么这里还是比较简单

01:16:00.960 --> 01:16:01.960
为什么比较简单呢

01:16:01.960 --> 01:16:02.960
因为我们这里

01:16:02.960 --> 01:16:03.960
这里只有一个数字而已

01:16:03.960 --> 01:16:04.960
那我们实际开发中

01:16:04.960 --> 01:16:05.960
这里边是不是有可能

01:16:05.960 --> 01:16:06.960
有很多元数

01:16:06.960 --> 01:16:07.960
可能有DIV

01:16:07.960 --> 01:16:08.960
可能有E内级

01:16:08.960 --> 01:16:09.960
可能有A元数

01:16:09.960 --> 01:16:10.960
是不是很多地方都不一样

01:16:10.960 --> 01:16:11.960
对吧

01:16:11.960 --> 01:16:13.960
比方说这是一篇文章的摘要

01:16:15.960 --> 01:16:16.960
那么我们在头部

01:16:16.960 --> 01:16:17.960
加了一篇新文章过后

01:16:17.960 --> 01:16:18.960
就会导致之前的

01:16:18.960 --> 01:16:19.960
第一篇文章

01:16:19.960 --> 01:16:20.960
和现在的第一篇文章不一样了

01:16:20.960 --> 01:16:21.960
但它如果说

01:16:21.960 --> 01:16:22.960
这种做法的话

01:16:22.960 --> 01:16:23.960
是不是导致个文章里边

01:16:23.960 --> 01:16:25.960
大量的元数全部被更改

01:16:25.960 --> 01:16:27.960
更改了特别特别多

01:16:27.960 --> 01:16:28.960
对吧

01:16:28.960 --> 01:16:29.960
就看这里被更改了

01:16:29.960 --> 01:16:30.960
更改了地方

01:16:30.960 --> 01:16:31.960
我就用一个

01:16:31.960 --> 01:16:33.960
用一个红色来表示吧

01:16:35.960 --> 01:16:36.960
被更改了

01:16:36.960 --> 01:16:37.960
然后接下来

01:16:37.960 --> 01:16:39.960
又移动它

01:16:39.960 --> 01:16:41.960
你们懂得对吧

01:16:41.960 --> 01:16:42.960
是不是一样的

01:16:42.960 --> 01:16:43.960
所以说它要变成什么

01:16:43.960 --> 01:16:44.960
变成E

01:16:44.960 --> 01:16:45.960
是不是也得更改

01:16:46.960 --> 01:16:47.960
它要变成E

01:16:48.960 --> 01:16:49.960
那么同样的道理

01:16:49.960 --> 01:16:50.960
它要变成2

01:16:50.960 --> 01:16:51.960
它要变成3

01:16:51.960 --> 01:16:52.960
它要变成4

01:16:52.960 --> 01:16:53.960
所以全要更改

01:16:53.960 --> 01:16:54.960
所以元数一个都跑不了

01:16:54.960 --> 01:16:55.960
全要改

01:16:55.960 --> 01:16:56.960
全部都改

01:16:57.960 --> 01:16:58.960
那么改完了过后

01:16:58.960 --> 01:16:59.960
你看这些连过来

01:16:59.960 --> 01:17:00.960
我就不E写了

01:17:00.960 --> 01:17:01.960
连过来

01:17:01.960 --> 01:17:02.960
连过来

01:17:02.960 --> 01:17:03.960
然后就是要它了

01:17:04.960 --> 01:17:05.960
到它了

01:17:05.960 --> 01:17:07.960
那么它已经过去了

01:17:07.960 --> 01:17:08.960
它已经过去了

01:17:08.960 --> 01:17:09.960
那么这边的元数已经没了

01:17:09.960 --> 01:17:10.960
那么就算它了

01:17:10.960 --> 01:17:11.960
它的话

01:17:11.960 --> 01:17:12.960
我们之前看到过

01:17:12.960 --> 01:17:14.960
就是这边先结束的

01:17:14.960 --> 01:17:15.960
那么现在是这边先结束

01:17:15.960 --> 01:17:16.960
这边先结束的话

01:17:16.960 --> 01:17:17.960
那么就

01:17:17.960 --> 01:17:18.960
这边要新建

01:17:18.960 --> 01:17:19.960
生育的元数一个个要新建

01:17:19.960 --> 01:17:20.960
所以说

01:17:20.960 --> 01:17:22.960
这边还要新建一个结建

01:17:22.960 --> 01:17:23.960
它就是这种情况

01:17:23.960 --> 01:17:25.960
也就明明我只加了一个元数

01:17:25.960 --> 01:17:26.960
结果我改了

01:17:26.960 --> 01:17:27.960
六个元数

01:17:28.960 --> 01:17:29.960
六个元数改了

01:17:29.960 --> 01:17:30.960
改了五个元数

01:17:30.960 --> 01:17:31.960
新建了一个元数

01:17:31.960 --> 01:17:32.960
那如果说你想一想

01:17:32.960 --> 01:17:35.960
这里数组的长度不是五

01:17:35.960 --> 01:17:36.960
而是一百

01:17:36.960 --> 01:17:39.960
是要改动一百次

01:17:39.960 --> 01:17:40.960
然后新生成一次

01:17:40.960 --> 01:17:42.960
这不是特别恐怖的

01:17:42.960 --> 01:17:43.960
每个元数里面很多真实的

01:17:43.960 --> 01:17:45.960
多么都要去改动

01:17:45.960 --> 01:17:46.960
对吧

01:17:46.960 --> 01:17:49.960
那么有了keyz过后会怎么样了

01:17:49.960 --> 01:17:51.960
你看现在是我们用keyz

01:17:51.960 --> 01:17:52.960
那么现在这个情况

01:17:52.960 --> 01:17:54.960
就是它跟它不一样了

01:17:54.960 --> 01:17:55.960
不一样怎么办

01:17:55.960 --> 01:17:56.960
比较维持人

01:17:56.960 --> 01:17:58.960
那么维持人怎么样连过来

01:17:58.960 --> 01:18:00.960
对吧

01:18:00.960 --> 01:18:01.960
维持人连过来

01:18:02.960 --> 01:18:04.960
而且他们都没有什么变化

01:18:04.960 --> 01:18:05.960
基本上内央式

01:18:05.960 --> 01:18:06.960
属性的都是一样的

01:18:06.960 --> 01:18:07.960
我们在宣言列表的时候

01:18:07.960 --> 01:18:08.960
也很少去动态改变

01:18:08.960 --> 01:18:10.960
它的内央式那些东西

01:18:10.960 --> 01:18:12.960
那么这个元数里边的内容

01:18:12.960 --> 01:18:13.960
是不是也是一样的

01:18:13.960 --> 01:18:15.960
里边的各种指援数也是一样的

01:18:15.960 --> 01:18:16.960
基本上不用动

01:18:16.960 --> 01:18:18.960
一个真实动物都不用动

01:18:18.960 --> 01:18:20.960
基本上不用动

01:18:20.960 --> 01:18:21.960
就ok了

01:18:21.960 --> 01:18:23.960
然后维持人移动

01:18:23.960 --> 01:18:24.960
同样的道理

01:18:24.960 --> 01:18:25.960
你看这个4

01:18:25.960 --> 01:18:27.960
是不是也不用动

01:18:27.960 --> 01:18:28.960
也不用动

01:18:28.960 --> 01:18:29.960
3也不用动

01:18:29.960 --> 01:18:31.960
维持人14往前面移动

01:18:31.960 --> 01:18:32.960
2也不用动

01:18:32.960 --> 01:18:33.960
1也不用动

01:18:33.960 --> 01:18:34.960
那么剩下的事情

01:18:34.960 --> 01:18:36.960
就是丢剩一个100了

01:18:36.960 --> 01:18:41.170
那么100是不是去新建一个

01:18:41.170 --> 01:18:42.170
是不是去新建一个

01:18:42.170 --> 01:18:44.170
就改动了一下这个

01:18:44.170 --> 01:18:46.170
然后把它加到它的投资人之前

01:18:46.170 --> 01:18:47.170
对吧

01:18:47.170 --> 01:18:48.170
这就完了

01:18:48.170 --> 01:18:50.170
那么这样子是不是更加符合

01:18:50.170 --> 01:18:51.170
我们的期望

01:18:51.170 --> 01:18:53.170
这就是为什么要去加这个p值

01:18:53.170 --> 01:18:54.170
比较意思吧

01:18:54.170 --> 01:18:57.480
p值它可以对应到一个节点

01:18:57.480 --> 01:18:59.480
然后我们再来看

01:18:59.480 --> 01:19:01.480
p值最好是跟那个

01:19:01.480 --> 01:19:03.480
它的数据是有关系的

01:19:03.480 --> 01:19:04.480
比方说我们一般来说

01:19:04.480 --> 01:19:05.480
比方说一篇评论

01:19:05.480 --> 01:19:06.480
它有一个尾一编号

01:19:06.480 --> 01:19:07.480
一篇文章

01:19:07.480 --> 01:19:08.480
它有一个尾一编号

01:19:08.480 --> 01:19:09.480
因为id是最好的

01:19:09.480 --> 01:19:10.480
那么这一边

01:19:10.480 --> 01:19:12.480
刚才用的是什么key呢

01:19:12.480 --> 01:19:13.480
刚才用的是n

01:19:13.480 --> 01:19:15.480
n在这里也基本上

01:19:15.480 --> 01:19:16.480
能够代表这个数字

01:19:16.480 --> 01:19:17.480
就这个东西

01:19:17.480 --> 01:19:18.480
跟这个东西是对应的

01:19:18.480 --> 01:19:19.480
这个数据

01:19:19.480 --> 01:19:20.480
t值的数据

01:19:20.480 --> 01:19:22.480
跟这里边的内容是对应的

01:19:22.480 --> 01:19:24.480
当然我这边就是直接数字对应的

01:19:24.480 --> 01:19:26.480
实际在实际开发中的

01:19:26.480 --> 01:19:28.480
这一边一篇文章的编号

01:19:28.480 --> 01:19:29.480
一篇文章的编号

01:19:29.480 --> 01:19:30.480
就对应了这篇文章的所有内容

01:19:30.480 --> 01:19:31.480
对吧

01:19:31.480 --> 01:19:32.480
一般是要对应

01:19:32.480 --> 01:19:33.480
为什么要对应呢

01:19:33.480 --> 01:19:35.480
就害怕你用这种情况

01:19:35.480 --> 01:19:36.480
这种写法

01:19:36.480 --> 01:19:42.500
你用什么下标去作为key值

01:19:42.500 --> 01:19:43.500
下标

01:19:43.500 --> 01:19:45.500
你说下标也是唯一的

01:19:45.500 --> 01:19:47.500
下标能不能作为key值呢

01:19:47.500 --> 01:19:48.500
那咱们来看一下

01:19:48.500 --> 01:19:49.500
你用下标作为key值

01:19:49.500 --> 01:19:51.500
那还不如不用不用key值

01:19:51.500 --> 01:19:53.500
是一样的

01:19:53.500 --> 01:19:54.500
下标作为key值

01:19:54.500 --> 01:19:55.500
结果就是这里是0

01:19:55.500 --> 01:19:56.500
1

01:19:56.500 --> 01:19:57.500
2

01:19:57.500 --> 01:19:58.500
3

01:19:58.500 --> 01:19:59.500
4

01:19:59.500 --> 01:20:00.500
这边也是变成了0

01:20:00.500 --> 01:20:01.500
1

01:20:01.500 --> 01:20:02.500
2

01:20:02.500 --> 01:20:03.500
3

01:20:03.500 --> 01:20:04.500
就一样的

01:20:04.500 --> 01:20:06.500
跟那个不用key值是不是一样的

01:20:06.500 --> 01:20:07.500
它们两个一堆笔

01:20:07.500 --> 01:20:08.500
一样的

01:20:08.500 --> 01:20:10.500
就会把它改成100

01:20:10.500 --> 01:20:12.500
第一个变成100

01:20:12.500 --> 01:20:13.500
它跟它一堆笔

01:20:13.500 --> 01:20:14.500
一样的

01:20:14.500 --> 01:20:16.500
就会把它改成1

01:20:16.500 --> 01:20:17.500
原来的意思吧

01:20:17.500 --> 01:20:19.500
为什么不要用下标去作为key值

01:20:19.500 --> 01:20:21.500
因为下标的key值

01:20:21.500 --> 01:20:23.500
是不能反映内容的

01:20:23.500 --> 01:20:25.500
是不能反映

01:20:25.500 --> 01:20:28.500
就是它对应的数据的

01:20:28.500 --> 01:20:29.500
因为它数据

01:20:29.500 --> 01:20:31.500
可能它的对应的下标会变化

01:20:31.500 --> 01:20:34.500
一定要用一个唯一且稳定的key值

01:20:34.500 --> 01:20:36.500
一般来说就用id

01:20:37.500 --> 01:20:39.500
一般就是id

01:20:39.500 --> 01:20:40.500
时间

01:20:40.500 --> 01:20:42.500
什么时间

01:20:43.500 --> 01:20:45.500
你说对比的时间复杂度

01:20:45.500 --> 01:20:49.940
时间复杂度毫无疑问是On的

01:20:49.940 --> 01:20:51.940
肯定是On的

01:20:51.940 --> 01:20:54.940
它的数据目录是不是就一次便利

01:20:54.940 --> 01:20:56.940
它不是就一次便利

01:20:56.940 --> 01:21:00.940
它没有key值用时间

01:21:00.940 --> 01:21:01.940
别多了

01:21:01.940 --> 01:21:03.940
key值怎么能用时间呢

01:21:03.940 --> 01:21:06.500
key值

01:21:06.500 --> 01:21:07.500
我的天啊

01:21:07.500 --> 01:21:09.500
key值怎么可能用时间戳啊

01:21:09.500 --> 01:21:13.140
首先不说别的

01:21:13.140 --> 01:21:14.140
利用时间戳

01:21:14.140 --> 01:21:16.140
因为你时间戳是精确的好妙

01:21:16.140 --> 01:21:18.140
那么标这里有10个li

01:21:18.140 --> 01:21:20.140
虽然说它们可能时间戳都是一样的

01:21:20.140 --> 01:21:22.140
都是完全一样的时间戳

01:21:22.140 --> 01:21:24.140
它们的运行速度很快的

01:21:24.140 --> 01:21:25.140
哪怕不一样

01:21:25.140 --> 01:21:27.140
那就可能会导致一个结果就是

01:21:27.140 --> 01:21:28.140
谁教你们的

01:21:28.140 --> 01:21:30.140
就写点比方说它的时间戳

01:21:30.140 --> 01:21:31.140
那假设不一样吗

01:21:31.140 --> 01:21:33.140
12345

01:21:34.140 --> 01:21:35.140
新圈的时候

01:21:35.140 --> 01:21:37.140
时间戳是不是又变了

01:21:37.140 --> 01:21:40.140
变成了789

01:21:40.140 --> 01:21:42.140
全部不一样了

01:21:42.140 --> 01:21:46.410
11 12

01:21:46.410 --> 01:21:48.410
这会导致一个什么结果

01:21:48.410 --> 01:21:50.410
这些元素全部消费

01:21:50.410 --> 01:21:51.410
找不到相同的呀

01:21:51.410 --> 01:21:52.410
全部消费

01:21:52.410 --> 01:21:55.410
这边元素全部重新建

01:21:55.410 --> 01:21:56.410
不能这样去搞啊

01:21:56.410 --> 01:21:57.410
不能这样去搞

01:21:57.410 --> 01:21:59.410
key值呢一般用id

01:21:59.410 --> 01:22:01.410
一般你们从这一块

01:22:01.410 --> 01:22:03.410
会从服务器拿数据

01:22:03.410 --> 01:22:04.410
服务器呢一般

01:22:05.410 --> 01:22:06.410
新闻数据

01:22:06.410 --> 01:22:07.410
用户数据

01:22:07.410 --> 01:22:08.410
文章数据

01:22:08.410 --> 01:22:10.410
都会给你的id

01:22:10.410 --> 01:22:11.410
id是非常稳定的

01:22:11.410 --> 01:22:12.410
永远不会变化

01:22:12.410 --> 01:22:14.410
天荒地老都不会变化

01:22:14.410 --> 01:22:17.410
它永远跟那个数据关联在一起

01:22:17.410 --> 01:22:18.410
对就是组建

01:22:18.410 --> 01:22:19.410
你们以后学到

01:22:19.410 --> 01:22:20.410
学到那个结石的时候

01:22:20.410 --> 01:22:21.410
讲到买车课的时候

01:22:21.410 --> 01:22:23.410
你们就会学习到

01:22:23.410 --> 01:22:24.410
好 第二个例子呢

01:22:24.410 --> 01:22:25.410
是这个例子

01:22:25.410 --> 01:22:27.780
看一下吧

01:22:27.780 --> 01:22:28.780
做的非常简单啊

01:22:28.780 --> 01:22:30.780
我就做了这么一个东西

01:22:30.780 --> 01:22:31.780
就是我们的界面呢

01:22:31.780 --> 01:22:32.780
也非常简单

01:22:32.780 --> 01:22:33.780
就是我一个数据

01:22:34.780 --> 01:22:35.780
是否用账号来登录

01:22:35.780 --> 01:22:36.780
默认是q

01:22:37.780 --> 01:22:38.780
你看看我们这里呢

01:22:38.780 --> 01:22:39.780
有两个n元数

01:22:39.780 --> 01:22:40.780
一个是账号登录

01:22:40.780 --> 01:22:41.780
一个是手机号登录

01:22:41.780 --> 01:22:42.780
点账号登录的时候呢

01:22:42.780 --> 01:22:43.780
我就把这个

01:22:45.780 --> 01:22:46.780
点手机号登录的时候

01:22:46.780 --> 01:22:47.780
就把它设为force

01:22:47.780 --> 01:22:48.780
就通过这个值呢

01:22:48.780 --> 01:22:50.780
来控制到底用什么登录

01:22:50.780 --> 01:22:51.780
下面有两个div

01:22:51.780 --> 01:22:52.780
这个div呢

01:22:52.780 --> 01:22:53.780
如果说你是账号登录的话

01:22:53.780 --> 01:22:54.780
我就显示这一块

01:22:54.780 --> 01:22:56.780
如果说你是手机号登录的话

01:22:56.780 --> 01:22:57.780
我就显示这一块

01:22:58.780 --> 01:22:59.780
非常简单啊

01:22:59.780 --> 01:23:00.780
这个界面非常简单

01:23:00.780 --> 01:23:01.780
你看吧切换

01:23:03.780 --> 01:23:04.780
但是这个代码

01:23:04.780 --> 01:23:05.780
会有什么样的问题呢

01:23:05.780 --> 01:23:09.610
也会好像有这样的一个问题

01:23:09.610 --> 01:23:10.610
这啥问题

01:23:16.250 --> 01:23:17.250
是不是两边的那个文笨框

01:23:17.250 --> 01:23:18.250
被附用了

01:23:19.250 --> 01:23:20.250
被重复使用了

01:23:21.250 --> 01:23:22.250
为啥会这样呢

01:23:23.250 --> 01:23:24.250
为啥会这样呢

01:23:24.250 --> 01:23:25.250
那我们来看一下吧

01:23:25.250 --> 01:23:26.250
跟那个虚拟节点

01:23:26.250 --> 01:23:27.250
对比就有关系

01:23:28.250 --> 01:23:29.250
就是它一开始

01:23:29.250 --> 01:23:30.250
那个节点是什么呢

01:23:30.250 --> 01:23:31.250
是这个

01:23:31.250 --> 01:23:32.250
一开始就节点

01:23:32.250 --> 01:23:33.250
比方说一开始就节点

01:23:33.250 --> 01:23:34.250
是这个

01:23:35.250 --> 01:23:36.250
就节点是这个

01:23:36.250 --> 01:23:37.250
对吧

01:23:38.250 --> 01:23:39.250
然后新节点呢

01:23:39.250 --> 01:23:40.250
变成了这个

01:23:42.880 --> 01:23:45.380
就节点

01:23:46.380 --> 01:23:47.380
就是新节点

01:23:48.380 --> 01:23:51.530
你看吧

01:23:51.530 --> 01:23:52.530
在对比的时候

01:23:52.530 --> 01:23:54.530
它跟它是不是同一个节点

01:23:54.530 --> 01:23:55.530
是吧

01:23:55.530 --> 01:23:56.530
所以说它不会

01:23:56.530 --> 01:23:57.530
不会删除它

01:23:57.530 --> 01:23:58.530
不会删除

01:23:58.530 --> 01:23:59.530
不会新建它嘛

01:23:59.530 --> 01:24:00.530
所以只会重复使用

01:24:00.530 --> 01:24:01.530
然后对比直接点的时候

01:24:01.530 --> 01:24:03.530
它跟它是不是同一个节点

01:24:03.530 --> 01:24:04.530
是吧

01:24:04.530 --> 01:24:05.530
是同一个节点吗

01:24:05.530 --> 01:24:07.530
所以说它只会把里边的

01:24:07.530 --> 01:24:08.530
又对比直接点

01:24:08.530 --> 01:24:09.530
它跟它是不是同一个节点

01:24:09.530 --> 01:24:10.530
是同一个节点

01:24:10.530 --> 01:24:11.530
注意哦

01:24:11.530 --> 01:24:12.530
这个节点

01:24:12.530 --> 01:24:13.530
这个节点

01:24:13.530 --> 01:24:14.530
跟这个节点

01:24:14.530 --> 01:24:15.530
是同一个节点

01:24:15.530 --> 01:24:16.530
它们的Tag

01:24:16.530 --> 01:24:17.530
都是 Undefined

01:24:18.530 --> 01:24:19.530
它们的Tag属性

01:24:19.530 --> 01:24:20.530
都是 Undefined

01:24:21.530 --> 01:24:22.530
又同时没有Kiz

01:24:22.530 --> 01:24:23.530
它们是同一个节点

01:24:24.530 --> 01:24:25.530
知道吧

01:24:25.530 --> 01:24:26.530
那么到时候变化了

01:24:26.530 --> 01:24:28.530
就把它文本内容变了

01:24:29.530 --> 01:24:30.530
把它

01:24:30.530 --> 01:24:31.530
这两个字变成手机号

01:24:31.530 --> 01:24:32.530
那么这两个节点

01:24:32.530 --> 01:24:33.530
是不是同一个节点

01:24:33.530 --> 01:24:34.530
是同一个节点

01:24:34.530 --> 01:24:35.530
所以说

01:24:35.530 --> 01:24:36.530
新的音谱者元素

01:24:36.530 --> 01:24:37.530
它就会

01:24:37.530 --> 01:24:39.530
把旧的音谱者元素

01:24:39.530 --> 01:24:40.530
拿来进行复用

01:24:40.530 --> 01:24:41.530
因此你会看到

01:24:41.530 --> 01:24:42.530
切换过去的时候

01:24:42.530 --> 01:24:43.530
尽管看上去的

01:24:43.530 --> 01:24:44.530
这个DEV好像

01:24:44.530 --> 01:24:45.530
V

01:24:45.530 --> 01:24:46.530
这个DEV好像消失了

01:24:46.530 --> 01:24:47.530
它为Force了

01:24:47.530 --> 01:24:48.530
它好像消失了

01:24:48.530 --> 01:24:49.530
实际上它里边的

01:24:49.530 --> 01:24:50.530
真实的母强被复用了

01:24:50.530 --> 01:24:51.530
因此

01:24:51.530 --> 01:24:52.530
文笨框里边的值

01:24:52.530 --> 01:24:53.530
得到了保留

01:24:53.530 --> 01:24:54.530
有的时候

01:24:54.530 --> 01:24:55.530
这样子并不好

01:24:55.530 --> 01:24:56.530
你想这种情况

01:24:56.530 --> 01:24:57.530
首先能够

01:24:57.530 --> 01:24:58.530
明显这个要切过去的时候

01:24:58.530 --> 01:25:00.530
明显要把它变成

01:25:01.530 --> 01:25:02.530
清空的状态

01:25:02.530 --> 01:25:03.530
对吧

01:25:03.530 --> 01:25:04.530
也就是说

01:25:04.530 --> 01:25:05.530
我们希望切过去的时候

01:25:05.530 --> 01:25:06.530
至少对于这个文笨框而言

01:25:06.530 --> 01:25:08.530
你最好给我

01:25:08.530 --> 01:25:09.530
扔掉旧的

01:25:09.530 --> 01:25:10.530
重新给我渐行的

01:25:10.530 --> 01:25:11.530
拉怎么办的

01:25:11.530 --> 01:25:12.530
就非常简单

01:25:13.530 --> 01:25:14.530
为什么它要重用它

01:25:14.530 --> 01:25:15.530
至于因为它

01:25:15.530 --> 01:25:16.530
认为它是同一个节点

01:25:16.530 --> 01:25:17.530
你怎么让它

01:25:17.530 --> 01:25:18.530
你怎么让它

01:25:19.530 --> 01:25:20.530
怎么高速5U

01:25:20.530 --> 01:25:21.530
它不是同一个节点

01:25:21.530 --> 01:25:25.120
怎么让高速5U

01:25:25.120 --> 01:25:26.120
它不是同一个节点

01:25:27.120 --> 01:25:28.120
是透过key吗

01:25:29.120 --> 01:25:30.120
你随便给它个key

01:25:30.120 --> 01:25:31.120
比方说这个key为1

01:25:31.120 --> 01:25:33.120
最好给个有1的名字

01:25:33.120 --> 01:25:34.120
给个什么

01:25:34.120 --> 01:25:35.120
比方说这是

01:25:35.120 --> 01:25:36.120
Alt

01:25:36.120 --> 01:25:37.120
然后

01:25:38.120 --> 01:25:39.120
这个呢是手机号

01:25:40.120 --> 01:25:41.120
for

01:25:41.120 --> 01:25:42.120
对吧

01:25:42.120 --> 01:25:43.120
那么这样子对比

01:25:43.120 --> 01:25:44.120
虽然它们元素类型

01:25:44.120 --> 01:25:45.120
一样

01:25:45.120 --> 01:25:46.120
太不职业一样

01:25:46.120 --> 01:25:47.120
但是它T不一样

01:25:47.120 --> 01:25:48.120
它就不是同一个节点

01:25:48.120 --> 01:25:49.120
不是同一个节点

01:25:49.120 --> 01:25:50.120
怎么办呢

01:25:50.120 --> 01:25:51.120
扔掉

01:25:51.120 --> 01:25:52.120
清洁

01:25:52.120 --> 01:25:53.120
那么新建的input元素

01:25:53.120 --> 01:25:54.120
它肯定就没有迟了

01:25:54.120 --> 01:25:55.120
所以说我们这里

01:25:55.120 --> 01:25:56.120
要解决这个问题的

01:25:56.120 --> 01:25:57.120
做法其实非常简单

01:25:57.120 --> 01:25:58.120
t值

01:25:58.120 --> 01:26:01.140
account

01:26:02.140 --> 01:26:04.830
那么这个t值

01:26:10.340 --> 01:26:11.340
for

01:26:11.340 --> 01:26:12.340
接格不能

01:26:12.340 --> 01:26:13.340
不给行

01:26:13.340 --> 01:26:14.340
可以啊

01:26:14.340 --> 01:26:15.340
这个不给行也可以

01:26:15.340 --> 01:26:16.340
那么这个不给的话

01:26:16.340 --> 01:26:17.340
还是对应不上

01:26:17.340 --> 01:26:18.340
那可以的没问题

01:26:19.340 --> 01:26:20.340
应该是不是还是可以的

01:26:20.340 --> 01:26:21.340
没问题

01:26:21.340 --> 01:26:22.340
只要它对应不上就行了

01:26:22.340 --> 01:26:23.340
但是呢

01:26:23.340 --> 01:26:25.340
从代码的可阅读性来说

01:26:25.340 --> 01:26:27.340
你为什么这样子呢

01:26:27.340 --> 01:26:28.340
为什么众齿势比

01:26:28.340 --> 01:26:30.340
你不是众账号

01:26:30.340 --> 01:26:31.340
亲手机号吗

01:26:31.340 --> 01:26:32.340
众男亲女吗

01:26:32.340 --> 01:26:34.340
不要这个样子的

01:26:34.340 --> 01:26:35.340
公平一点

01:26:35.340 --> 01:26:38.300
它给的还是给一个

01:26:38.300 --> 01:26:39.300
改成number

01:26:39.300 --> 01:26:40.300
它应该还是会重

01:26:40.300 --> 01:26:41.300
还是会重用

01:26:41.300 --> 01:26:42.300
改成number

01:26:42.300 --> 01:26:43.300
还是会重用

01:26:43.300 --> 01:26:44.300
如果说没基错的话

01:26:44.300 --> 01:26:45.300
还是会重用

01:26:45.300 --> 01:26:47.990
等一下

01:26:47.990 --> 01:26:48.990
我又写数字

01:26:48.990 --> 01:26:49.990
你看

01:26:49.990 --> 01:26:50.990
就还是会重用

01:26:50.990 --> 01:26:51.990
为什么呢

01:26:51.990 --> 01:26:52.990
因为它就涉及到

01:26:52.990 --> 01:26:53.990
这个input文门框

01:26:53.990 --> 01:26:54.990
它怎么来判断

01:26:54.990 --> 01:26:55.990
它是不是同一个东西

01:26:55.990 --> 01:26:56.990
就涉及到我们之前

01:26:56.990 --> 01:26:57.990
给它说的那个

01:26:57.990 --> 01:26:58.990
seminode的问题

01:26:58.990 --> 01:27:00.990
seminbedode的问题

01:27:00.990 --> 01:27:01.990
我当时没有细想

01:27:01.990 --> 01:27:02.990
你有些军情的同学

01:27:02.990 --> 01:27:03.990
可以自己看一下原来

01:27:03.990 --> 01:27:04.990
就这一块

01:27:04.990 --> 01:27:05.990
seminode

01:27:05.990 --> 01:27:06.990
它到底是不是同一个

01:27:06.990 --> 01:27:07.990
input元的数

01:27:07.990 --> 01:27:08.990
那么

01:27:09.990 --> 01:27:10.990
这里有一个

01:27:10.990 --> 01:27:11.990
这种判断

01:27:11.990 --> 01:27:12.990
就是extinput

01:27:16.390 --> 01:27:17.390
就是这个判断

01:27:18.390 --> 01:27:20.390
它是不是

01:27:20.390 --> 01:27:21.390
它们是不是

01:27:21.390 --> 01:27:22.390
都是文本

01:27:22.390 --> 01:27:23.390
文本那个input

01:27:23.390 --> 01:27:24.390
如果都是

01:27:24.390 --> 01:27:25.390
文本input的话

01:27:25.390 --> 01:27:26.390
那么也ok

01:27:26.390 --> 01:27:27.390
我也认为它是相同的

01:27:27.390 --> 01:27:28.390
结果它们的type

01:27:28.390 --> 01:27:29.390
可能不一样

01:27:29.390 --> 01:27:30.390
那么这个东西

01:27:30.390 --> 01:27:31.390
又是怎么判断的呢

01:27:31.390 --> 01:27:32.390
这个东西它是在这

01:27:32.390 --> 01:27:33.390
我找一找

01:27:33.390 --> 01:27:34.390
能找到就找到

01:27:34.390 --> 01:27:35.390
找不到就算了

01:27:39.390 --> 01:27:41.390
在哪个位置呢

01:27:42.390 --> 01:27:43.390
在这

01:27:44.390 --> 01:27:45.390
makeup

01:27:45.390 --> 01:27:46.390
我还要去解释

01:27:46.390 --> 01:27:47.390
这个海朔

01:27:47.390 --> 01:27:48.390
我这个就告诉你们吧

01:27:48.390 --> 01:27:49.390
它这个做法

01:27:49.390 --> 01:27:50.390
这个方法

01:27:50.390 --> 01:27:51.390
是生成一个函数的

01:27:51.390 --> 01:27:52.390
它传入一个字幕的时候

01:27:52.390 --> 01:27:53.390
会帮你生成一个函数

01:27:53.390 --> 01:27:54.390
这是个高阶方法

01:27:55.390 --> 01:27:56.390
就是说

01:27:56.390 --> 01:27:57.390
它的type只能

01:27:57.390 --> 01:27:58.390
如果说是text

01:27:58.390 --> 01:27:59.390
number

01:27:59.390 --> 01:28:00.390
password

01:28:00.390 --> 01:28:01.390
search

01:28:01.390 --> 01:28:02.390
email

01:28:02.390 --> 01:28:03.390
tale

01:28:03.390 --> 01:28:04.390
unl

01:28:04.390 --> 01:28:05.390
它们都认为是一样的

01:28:05.390 --> 01:28:06.390
它认为它们都是文本

01:28:06.390 --> 01:28:07.390
文本的input

01:28:07.390 --> 01:28:08.390
认为它们都是同一个

01:28:08.390 --> 01:28:09.390
就这么个意思

01:28:14.220 --> 01:28:15.220
当然你这个key

01:28:15.220 --> 01:28:16.220
比如说

01:28:16.220 --> 01:28:17.220
这里边除了

01:28:17.220 --> 01:28:18.220
这两个东西之外

01:28:18.220 --> 01:28:19.220
还有一些别的东西

01:28:19.220 --> 01:28:20.220
我们都希望

01:28:20.220 --> 01:28:21.220
你要把

01:28:21.220 --> 01:28:22.220
就要切换的时候

01:28:22.220 --> 01:28:23.220
像这种情况

01:28:23.220 --> 01:28:24.220
看上去好像两个都差不多

01:28:24.220 --> 01:28:25.220
但是实际上

01:28:25.220 --> 01:28:26.220
我不希望你重用

01:28:26.220 --> 01:28:27.220
我希望整个dibe

01:28:27.220 --> 01:28:28.220
都要给我销毁重建

01:28:29.220 --> 01:28:30.220
那么如果说

01:28:30.220 --> 01:28:31.220
有这样的需求的话

01:28:31.220 --> 01:28:32.220
那么你可以把这个

01:28:32.220 --> 01:28:33.220
T放到这

01:28:35.220 --> 01:28:37.720
是不是也一样

01:28:37.720 --> 01:28:38.720
对不对

01:28:38.720 --> 01:28:39.720
那么这个时候

01:28:39.720 --> 01:28:40.720
它们两个对比

01:28:40.720 --> 01:28:41.720
都不会成功

01:28:41.720 --> 01:28:42.720
它们两个对比不成功

01:28:42.720 --> 01:28:43.720
它根本就不会

01:28:43.720 --> 01:28:44.720
对比紫园数

01:28:44.720 --> 01:28:45.720
因为我们更新的流程

01:28:45.720 --> 01:28:46.720
一定要是

01:28:46.720 --> 01:28:47.720
两个是同一个阶段

01:28:47.720 --> 01:28:48.720
如果它们不同的话

01:28:48.720 --> 01:28:49.720
就直接销毁新�

01:28:49.720 --> 01:28:50.720
直接销毁新鲜

01:29:02.140 --> 01:29:03.140
好了

01:29:03.140 --> 01:29:04.140
那这就是

01:29:04.140 --> 01:29:05.140
咱们今天的内容

