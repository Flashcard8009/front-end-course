WEBVTT

00:00.300 --> 00:02.300
今天咱们讲啥呢

00:02.300 --> 00:06.300
讲一个双指针的问题

00:06.300 --> 00:08.300
双指针它不是一个问题啊实际上

00:08.300 --> 00:10.300
它是一个解决问题的一个办法

00:10.300 --> 00:12.300
那么这个指针指的是什么呢

00:12.300 --> 00:14.300
这个指针不是说C元的指针

00:14.300 --> 00:16.300
你们这里边可能有些同学来学过

00:16.300 --> 00:18.300
C元是压加

00:18.300 --> 00:20.300
那里边不是一个指针吗对不对

00:20.300 --> 00:22.300
它不是那个指针啊

00:22.300 --> 00:24.300
这个指针呢 它的含义就是一个变量

00:24.300 --> 00:26.300
它指向某一个对列的锁印

00:26.300 --> 00:28.300
比方说有一个数组

00:28.300 --> 00:30.300
非常简单的一个数组

00:30.300 --> 00:32.300
诶 比方说随便写一个数吧

00:32.300 --> 00:34.300
随便写个数组

00:34.300 --> 00:36.300
好 比方说我定一个变量i 这为0

00:36.300 --> 00:38.300
那么我们可以认为i是一个指针

00:38.300 --> 00:40.300
它指向数组这个位置

00:40.300 --> 00:42.300
比方这个意思吧

00:42.300 --> 00:44.300
什么叫双指针呢

00:44.300 --> 00:46.300
就是我设置两个变量

00:46.300 --> 00:48.300
分别指向数组不同的位置

00:48.300 --> 00:50.300
就是双指针

00:50.300 --> 00:52.300
双指针呢可以解决一些

00:52.300 --> 00:54.300
特定的问题

00:54.300 --> 00:56.300
那么到底哪些问题呢

00:56.300 --> 00:58.300
所以说这里呢也不是很好办

00:58.300 --> 01:00.300
如果说你做面诗题

01:00.300 --> 01:02.300
做这种算法题做多了的话

01:02.300 --> 01:04.300
那么你会自然而然就会有这种感觉

01:04.300 --> 01:06.300
不然的话你肯定是不知道

01:06.300 --> 01:08.300
这个地方能不能用双指针解决

01:08.300 --> 01:10.300
好 这个我举个例子

01:10.300 --> 01:12.300
比方说这里呢有一个代码

01:12.300 --> 01:14.300
你看这就是数组对吧

01:14.300 --> 01:16.300
那么这里我定两个变量

01:16.300 --> 01:18.300
一个i 一个g

01:18.300 --> 01:20.300
分别指向数组的不同位置

01:20.300 --> 01:22.300
这是下标

01:22.300 --> 01:24.300
一个是0 指向这个位置

01:24.300 --> 01:26.300
其实双指针里边还可以细分

01:26.300 --> 01:28.300
简单跟大家说一下吧

01:28.300 --> 01:30.300
简单说一下

01:32.300 --> 01:34.300
双指针呢分为这么几种

01:34.300 --> 01:36.300
一种叫做快慢指针

01:36.300 --> 01:38.300
什么叫快慢指针呢

01:38.300 --> 01:40.300
他们都是为了解决一些

01:40.300 --> 01:42.300
特定问题的

01:42.300 --> 01:44.300
它不是什么新的技术

01:44.300 --> 01:46.300
都是一些技巧性的东西

01:46.300 --> 01:48.300
什么叫快慢指针呢

01:48.300 --> 01:50.300
就是说我这两个指针

01:50.300 --> 01:52.300
可能一开始呢他们是重叠的

01:52.300 --> 01:54.300
都指向同一个位置

01:54.300 --> 01:56.300
但是呢我们在不断的移动过程中呢

01:56.300 --> 01:58.300
一个指针快一点

01:58.300 --> 02:00.300
一个指针慢一点

02:00.300 --> 02:02.300
比方这个指针我就移动两格

02:02.300 --> 02:04.300
而这个指针呢只移动一格

02:04.300 --> 02:06.300
来完成一次移动

02:06.300 --> 02:08.300
好 接下来呢我们再移动的时候呢

02:08.300 --> 02:10.300
这个又是移动两格

02:10.300 --> 02:12.300
这个又是移动一格

02:12.300 --> 02:14.300
这就是快慢指针

02:14.300 --> 02:16.300
快慢指针呢通常呢

02:16.300 --> 02:18.300
用来判断一个

02:18.300 --> 02:20.300
练表是不是有还这种结构

02:23.320 --> 02:24.320
怎么样对撞指针呢

02:24.320 --> 02:25.320
非常简单

02:25.320 --> 02:27.320
就是一个指针只在左边

02:27.320 --> 02:29.320
一个指针只在右边

02:29.320 --> 02:31.320
然后呢左边的往右边移动

02:31.320 --> 02:32.320
右边的往左边移动

02:32.320 --> 02:34.320
只到两个指针同叠

02:34.320 --> 02:35.320
来解决一些问题

02:35.320 --> 02:37.320
还有一个指针呢叫做

02:37.320 --> 02:39.320
滑动窗口

02:40.320 --> 02:43.320
滑动窗口

02:44.320 --> 02:46.320
这于啥意思呢

02:47.320 --> 02:49.320
它也是两个指针啊

02:49.320 --> 02:50.320
他们一开始是重叠的

02:50.320 --> 02:52.320
然后呢其中一个指针在移动

02:52.320 --> 02:53.320
另一个指针不动

02:53.320 --> 02:54.320
不要移动移动

02:54.320 --> 02:56.320
移动到这儿满足一定条件之后呢

02:56.320 --> 02:57.320
看一下这一段

02:57.320 --> 02:59.320
这一段是有什么样的特点

02:59.320 --> 03:01.320
然后呢做完了这件事情过后呢

03:01.320 --> 03:03.320
两个指针又重叠在一起

03:03.320 --> 03:04.320
然后呢又重新来这个过程

03:04.320 --> 03:06.320
它移动它不动

03:06.320 --> 03:07.320
又移动

03:07.320 --> 03:08.320
好 那么你看是

03:08.320 --> 03:09.320
你看一下是不是一个窗口啊

03:09.320 --> 03:10.320
一开始指向这儿

03:10.320 --> 03:11.320
一开始是这个

03:11.320 --> 03:12.320
然后变成这个

03:12.320 --> 03:14.320
然后呢整个窗口又合并了

03:15.320 --> 03:16.320
它又变成这个

03:16.320 --> 03:18.320
变成这个变成这个

03:18.320 --> 03:19.320
对吧

03:19.320 --> 03:21.320
他们都是为了解决一些特定的问题的

03:21.320 --> 03:22.320
当然呢如果说

03:22.320 --> 03:24.320
脱离了这些具体的问题的话

03:24.320 --> 03:26.320
你可能觉得听得有点懵

03:26.320 --> 03:27.320
不过那么马上

03:27.320 --> 03:28.320
会有两个面试题

03:28.320 --> 03:29.320
来看一下这两个面试题

03:29.320 --> 03:31.320
他们就会用到对撞指针

03:31.320 --> 03:33.320
和一个滑动窗口

03:33.320 --> 03:34.320
好 首先看地道题

03:34.320 --> 03:36.320
这是一道字节面试题

03:36.320 --> 03:37.320
其实这道题呢

03:37.320 --> 03:39.320
已经非常常见了

03:39.320 --> 03:40.320
不仅是字节跳动啊

03:40.320 --> 03:42.320
很多大厂都遇到过这种面试题

03:42.320 --> 03:43.320
连续制服

03:43.320 --> 03:44.320
看一下吧

03:45.320 --> 03:46.320
它说

03:47.320 --> 03:49.320
给地一个字无错而s

03:50.320 --> 03:53.320
要得到其中最长的

03:53.320 --> 03:55.320
连续制服的长度

03:55.320 --> 03:56.320
啥意思呢

03:56.320 --> 03:57.320
你看这个制服啊

03:57.320 --> 03:59.320
AAA,BB,CD

03:59.320 --> 04:02.320
它的落结果呢就应该是3

04:02.320 --> 04:03.320
为什么呢

04:03.320 --> 04:04.320
因为它最长的连续制服啊

04:04.320 --> 04:06.320
注意是连续的啊

04:06.320 --> 04:07.320
是不是3

04:07.320 --> 04:08.320
长度为3

04:08.320 --> 04:09.320
好 看这道题

04:09.320 --> 04:10.320
AA

04:10.320 --> 04:12.320
然后呢4个B

04:12.320 --> 04:13.320
3个A

04:13.320 --> 04:14.320
CC,DD

04:14.320 --> 04:16.320
得到结果呢是4

04:16.320 --> 04:18.320
因为呢有最长的连续制服B

04:18.320 --> 04:20.320
长度为4

04:20.320 --> 04:22.320
然后那出现了5次A

04:22.320 --> 04:24.320
但是5次A它并不连续

04:24.320 --> 04:26.320
这个连续的2次

04:26.320 --> 04:27.320
这个连续的3次

04:27.320 --> 04:28.320
明儿的意思吧

04:28.320 --> 04:29.320
比方度1

04:29.320 --> 04:31.320
得到应该是1

04:31.320 --> 04:32.320
为什么呢

04:32.320 --> 04:33.320
因为这里边

04:33.320 --> 04:34.320
每个制服都没有连续

04:34.320 --> 04:35.320
最长的连续制服就是

04:35.320 --> 04:37.320
一个制服

04:37.320 --> 04:39.320
好 这是它的题目

04:39.320 --> 04:48.010
首先题目能不能看懂啊

04:48.010 --> 04:49.010
可以是吧

04:49.010 --> 04:50.010
可以啊

04:50.010 --> 04:51.010
好 那么我们来看一下

04:51.010 --> 04:53.010
这道问题怎么解

04:54.010 --> 04:55.010
这个代码呢

04:55.010 --> 04:56.010
这个函数我们把这个代码

04:56.010 --> 04:58.010
复制过来啊

04:58.010 --> 04:59.010
这边我们新建一个文件

04:59.010 --> 05:00.010
叫做

05:02.010 --> 05:04.010
注意长连续制服

05:04.010 --> 05:07.010
用那个中文得了

05:07.010 --> 05:08.010
这边呢

05:08.010 --> 05:09.010
我在我安装了一个

05:09.010 --> 05:10.010
vscode的插件啊

05:10.010 --> 05:11.010
这个插件的名字呢

05:11.010 --> 05:14.960
叫做code wronger

05:14.960 --> 05:15.960
叫做code wronger

05:15.960 --> 05:16.960
这个插件呢

05:16.960 --> 05:17.960
你安装过后呢

05:17.960 --> 05:18.960
就有一个好处

05:18.960 --> 05:19.960
就在于你写好

05:19.960 --> 05:20.960
解释文件过后呢

05:20.960 --> 05:21.960
可以点击右键

05:21.960 --> 05:22.960
这里啊

05:22.960 --> 05:23.960
wrong code

05:23.960 --> 05:24.960
直接指示它

05:24.960 --> 05:25.960
有这么一个好处

05:25.960 --> 05:28.960
你们可以去安装一下啊

05:28.960 --> 05:29.960
好

05:29.960 --> 05:30.960
我们要做的事情呢

05:30.960 --> 05:32.960
就是完成这个函数

05:32.960 --> 05:33.960
这下面呢

05:33.960 --> 05:34.960
有一些测试代码

05:34.960 --> 05:35.960
它告诉你

05:35.960 --> 05:36.960
如果说你完成之后呢

05:36.960 --> 05:37.960
测试的结果

05:37.960 --> 05:38.960
看一下这么正确

05:38.960 --> 05:39.960
比方说这个制服圈呢

05:39.960 --> 05:40.960
得到的长度呢

05:40.960 --> 05:41.960
就应该是3

05:41.960 --> 05:42.960
这个制服圈得到的长度

05:42.960 --> 05:43.960
今天是4

05:43.960 --> 05:44.960
这个玩意呢

05:44.960 --> 05:45.960
就得到10

05:45.960 --> 05:46.960
这个是1

05:46.960 --> 05:47.960
这个是1

05:47.960 --> 05:48.960
好 我们要做的事情呢

05:48.960 --> 05:49.960
就是把这个函数完成

05:49.960 --> 05:50.960
那么这个函数

05:50.960 --> 05:52.960
怎么去做这件事呢

05:52.960 --> 05:53.960
这里呢

05:53.960 --> 05:54.960
大家可以去思考一下啊

05:54.960 --> 05:56.960
其实我们就可以用到双字针

05:56.960 --> 05:58.960
怎么样用呢

05:58.960 --> 06:00.960
这里一张图给大家看一下

06:00.960 --> 06:02.960
我们可以整整这种方式来

06:02.960 --> 06:04.960
首先我们可以判断

06:04.960 --> 06:05.960
一个特殊的情况

06:05.960 --> 06:06.960
什么特殊情况呢

06:06.960 --> 06:08.960
就是制服圈的长度

06:08.960 --> 06:09.960
如果说

06:09.960 --> 06:10.960
你给我的制服圈的长度

06:10.960 --> 06:11.960
有没有同学

06:11.960 --> 06:13.960
不知道这个意思

06:13.960 --> 06:16.960
这是咱们的函数注释啊

06:16.960 --> 06:17.960
注释里边呢

06:17.960 --> 06:18.960
我们可以注释一些参数

06:18.960 --> 06:20.960
什么类型的

06:20.960 --> 06:21.960
返回的是什么类型的

06:21.960 --> 06:22.960
Number

06:22.960 --> 06:24.960
就做一个注释

06:24.960 --> 06:25.960
这个呢

06:25.960 --> 06:26.960
我们首先判断一下

06:26.960 --> 06:27.960
制服圈的长度

06:27.960 --> 06:29.960
如果说等于0的话

06:29.960 --> 06:30.960
那么说明了

06:30.960 --> 06:31.960
这个制服圈没东西

06:31.960 --> 06:32.960
没东西的话

06:32.960 --> 06:34.960
我们的最长

06:34.960 --> 06:35.960
连续制服的长度了

06:35.960 --> 06:36.960
自然而然适应

06:36.960 --> 06:37.960
对吧

06:37.960 --> 06:38.960
我们把个边界情况了

06:38.960 --> 06:39.960
判断一下

06:39.960 --> 06:40.960
好 今天让我们看

06:40.960 --> 06:43.960
普遍性的情况

06:43.960 --> 06:44.960
那么我们可以怎么办呢

06:44.960 --> 06:46.960
我们可以准备两个指针

06:46.960 --> 06:47.960
一个是G

06:47.960 --> 06:48.960
一个是I

06:48.960 --> 06:49.960
他们都指向一个制服圈

06:49.960 --> 06:50.960
最开始的位置

06:50.960 --> 06:52.960
首先我们再准备一个边界

06:52.960 --> 06:53.960
它的指能是1

06:53.960 --> 06:54.960
这什么意思呢

06:54.960 --> 06:55.960
表示目前啊

06:55.960 --> 06:57.960
就是我后边全部不看

06:57.960 --> 07:00.960
我们把后边折起来

07:00.960 --> 07:01.960
我这里呢

07:01.960 --> 07:03.960
把折一下啊

07:03.960 --> 07:04.960
给它一个半透明

07:04.960 --> 07:06.960
不透明了

07:06.960 --> 07:07.960
这样子

07:07.960 --> 07:08.960
把后边折起来

07:08.960 --> 07:09.960
就是我们人去

07:09.960 --> 07:10.960
怎么去算这个事

07:10.960 --> 07:11.960
其实很多时候呢

07:11.960 --> 07:12.960
计算机就算来

07:12.960 --> 07:13.960
模拟人的操作的

07:13.960 --> 07:14.960
咱们把这个

07:14.960 --> 07:15.960
看一下人怎么来

07:15.960 --> 07:16.960
算这个事呢

07:16.960 --> 07:17.960
首先我们来看一下

07:17.960 --> 07:18.960
第一个制服

07:18.960 --> 07:19.960
是不是连

07:19.960 --> 07:20.960
它肯定是连续的嘛

07:20.960 --> 07:21.960
只有一个制服

07:21.960 --> 07:22.960
那么我们记录

07:22.960 --> 07:23.960
记录一下

07:23.960 --> 07:25.960
目前的最长连续制服

07:25.960 --> 07:26.960
是1

07:26.960 --> 07:27.960
好 接下来

07:27.960 --> 07:29.960
我们往后边移动

07:29.960 --> 07:30.960
往后边移动

07:30.960 --> 07:31.960
接下来看下一个制服

07:31.960 --> 07:32.960
下一个制服

07:32.960 --> 07:33.960
跟之前的制服一样

07:33.960 --> 07:34.960
对吧

07:34.960 --> 07:35.960
一样的不动

07:35.960 --> 07:37.960
不管 继续往后看

07:37.960 --> 07:38.960
再往后移动

07:38.960 --> 07:39.960
现在是不是不一样了

07:39.960 --> 07:40.960
也就是

07:40.960 --> 07:41.960
现在这个界这个位置

07:41.960 --> 07:42.960
跟这个I这个位置

07:42.960 --> 07:43.960
是不是不一样了

07:43.960 --> 07:44.960
我们发现

07:44.960 --> 07:45.960
看到这的时候

07:46.960 --> 07:47.960
之前是不是连续制服

07:47.960 --> 07:48.960
已经结束了

07:48.960 --> 07:49.960
于是

07:49.960 --> 07:50.960
我们现在又记录一下

07:50.960 --> 07:52.960
看一下目前的连续制服

07:52.960 --> 07:53.960
有多少

07:53.960 --> 07:54.960
所以出现了两个

07:54.960 --> 07:56.960
出现了两个连续制服

07:56.960 --> 07:57.960
因此呢

07:57.960 --> 07:58.960
我们把这个MAX

07:58.960 --> 07:59.960
跟MAX比较一下

07:59.960 --> 08:01.960
我现在有两个连续制服了

08:01.960 --> 08:02.960
之前的是几个呢

08:02.960 --> 08:03.960
一个

08:03.960 --> 08:04.960
就是说两个比一个大

08:04.960 --> 08:05.960
因此呢

08:05.960 --> 08:06.960
我要记录成两个

08:06.960 --> 08:07.960
好 接下来

08:07.960 --> 08:08.960
我们继续移动

08:08.960 --> 08:09.960
我们继续往后移动

08:09.960 --> 08:10.960
等一下

08:10.960 --> 08:11.960
在这里

08:11.960 --> 08:12.960
这个时候

08:12.960 --> 08:13.960
我们现在记录过后

08:13.960 --> 08:14.960
我们就把这个I

08:14.960 --> 08:16.960
跟这个界再一次重叠

08:16.960 --> 08:17.960
就前面不看了

08:17.960 --> 08:18.960
前面已经记录好了

08:18.960 --> 08:20.960
我们现在接着往后看

08:20.960 --> 08:22.960
好 现在我们继续往后移动

08:22.960 --> 08:23.960
没问题吧

08:23.960 --> 08:24.960
相同的

08:24.960 --> 08:25.960
相同不管

08:25.960 --> 08:26.960
我们往后移动

08:26.960 --> 08:27.960
相同的

08:27.960 --> 08:28.960
不管往后移动

08:28.960 --> 08:29.960
是不是又遇到不同的

08:29.960 --> 08:30.960
不同的说明啥

08:30.960 --> 08:32.960
说明前边的这个连续制服

08:32.960 --> 08:33.960
是不是已经结束了

08:33.960 --> 08:34.960
因此呢

08:34.960 --> 08:35.960
我们周围来看一下

08:35.960 --> 08:37.960
目前I和界的跨度

08:37.960 --> 08:38.960
是不是跨度为3个

08:38.960 --> 08:39.960
对不对

08:39.960 --> 08:40.960
跨越了3个

08:40.960 --> 08:41.960
因此呢

08:41.960 --> 08:42.960
目前这个B的连续制服

08:42.960 --> 08:43.960
虽然几次了

08:43.960 --> 08:44.960
继续了3次

08:44.960 --> 08:46.960
好 三次跟2来相比

08:46.960 --> 08:47.960
是不是又比它大

08:47.960 --> 08:48.960
因此呢

08:48.960 --> 08:49.960
它还有更大的连续制服

08:49.960 --> 08:50.960
3次

08:50.960 --> 08:51.960
好 周围之间

08:51.960 --> 08:52.960
稍微过后呢

08:52.960 --> 08:53.960
又把这个I和界重叠

08:53.960 --> 08:55.960
又来继续看

08:55.960 --> 08:56.960
往后看

08:56.960 --> 08:57.960
相同的

08:57.960 --> 08:58.960
不管

08:58.960 --> 08:59.960
相同的不管

08:59.960 --> 09:00.960
好 不同的了

09:00.960 --> 09:01.960
是不是不同了

09:01.960 --> 09:02.960
不同的

09:02.960 --> 09:03.960
又来看一次

09:03.960 --> 09:04.960
两个跨度为3

09:04.960 --> 09:05.960
相同

09:05.960 --> 09:06.960
相同不动

09:06.960 --> 09:07.960
我们又重叠

09:07.960 --> 09:08.960
然后接下来继续往后看

09:09.960 --> 09:10.960
不同了

09:10.960 --> 09:11.960
不同是1

09:11.960 --> 09:12.960
最长连续制服是1

09:12.960 --> 09:14.960
那么1比3小不动

09:14.960 --> 09:15.960
好 重叠

09:15.960 --> 09:16.960
继续往后看

09:16.960 --> 09:17.960
好 注意哦

09:17.960 --> 09:18.960
这个时候还要往后看一眼

09:18.960 --> 09:19.960
因为你不知道

09:19.960 --> 09:20.960
你后边还有没有东西

09:20.960 --> 09:22.960
还要往后看一眼

09:22.960 --> 09:23.960
好 看一眼

09:23.960 --> 09:24.960
后边没东西了

09:24.960 --> 09:25.960
没东西了

09:25.960 --> 09:26.960
这个东西最长制服是多少

09:26.960 --> 09:28.960
最长制服是1

09:28.960 --> 09:29.960
对不对

09:29.960 --> 09:30.960
好 那么1比3小不动

09:30.960 --> 09:31.960
那么最终呢

09:31.960 --> 09:33.960
我们就拿到这个呢

09:33.960 --> 09:34.960
拿到这个最长制服

09:34.960 --> 09:35.960
连续制服

09:36.960 --> 09:38.960
好 这一块失度能理解吧

09:38.960 --> 09:43.490
这就是滑动窗客

09:43.490 --> 09:45.490
就是一个指针不动

09:45.490 --> 09:47.490
另一个指针往后移动

09:47.490 --> 09:49.490
然后在某一个时候呢

09:49.490 --> 09:51.490
又重新把这两个指针

09:51.490 --> 09:53.490
放到一个合适的位置

09:53.490 --> 09:55.490
接下来又是一个指针动

09:55.490 --> 09:56.490
一个指针不动

09:56.490 --> 09:57.490
就是滑动窗客

09:58.490 --> 10:01.490
好 那么失度告诉你呢

10:01.490 --> 10:03.490
我调查一下啊

10:04.490 --> 10:07.490
觉得自己能够把代码写出来的同学

10:07.490 --> 10:08.490
求个1

10:08.490 --> 10:09.490
觉得自己写不出来的

10:09.490 --> 10:10.490
求个2

10:10.490 --> 10:12.490
现在失度都知道了吧

10:17.230 --> 10:18.230
就是这样的问题啊

10:18.230 --> 10:19.230
所以说

10:19.230 --> 10:20.230
Q2的同学呢

10:20.230 --> 10:21.230
还是要多去训练一下

10:21.230 --> 10:23.230
像后边的每一道面试题啊

10:23.230 --> 10:25.230
我都会先告诉你失度

10:25.230 --> 10:26.230
然后你可以自己想一想

10:26.230 --> 10:28.230
能不能把代码写出来

10:28.230 --> 10:29.230
如果说你写不出来的话

10:29.230 --> 10:30.230
那么这方面呢

10:30.230 --> 10:31.230
是比较薄弱的啊

10:31.230 --> 10:32.230
程序示威是比较薄弱的

10:32.230 --> 10:34.230
需要大量的训练

10:34.230 --> 10:35.230
好 来吧

10:35.230 --> 10:40.850
咱们来写一下

10:40.850 --> 10:41.850
我看到的就是

10:41.850 --> 10:43.850
评论里面有一些

10:43.850 --> 10:44.850
别的问题啊

10:44.850 --> 10:45.850
这些别的问题呢

10:45.850 --> 10:46.850
我在讲完课之后呢

10:46.850 --> 10:47.850
同意给大家问吧

10:47.850 --> 10:48.850
这个时候讲课的时候呢

10:48.850 --> 10:50.850
就不知道答案可难结束了

10:50.850 --> 10:53.610
来吧

10:53.610 --> 10:54.610
一般性的失路

10:54.610 --> 10:55.610
我们首先一步一步来啊

10:55.610 --> 10:56.610
首先

10:56.610 --> 10:58.610
我们是不是要定义两个变量

10:58.610 --> 11:00.610
是不是要有两个变量

11:00.610 --> 11:01.610
以后呢

11:01.610 --> 11:02.610
别人给你提供这个失路

11:02.610 --> 11:03.610
不可能给你画图的啊

11:03.610 --> 11:05.610
就给你用文字说

11:05.610 --> 11:06.610
最多用文字给你说

11:06.610 --> 11:07.610
或者是用口述

11:07.610 --> 11:08.610
不可能给你画图的

11:08.610 --> 11:09.610
所以你在头脑里边

11:09.610 --> 11:10.610
或者是你自己要把

11:10.610 --> 11:12.610
画成图形来进行分析

11:12.610 --> 11:13.610
好 这里呢

11:13.610 --> 11:14.610
我们要准备什么

11:14.610 --> 11:15.610
两个变量

11:15.610 --> 11:16.610
I合计

11:16.610 --> 11:17.610
他们的纸

11:17.610 --> 11:19.610
一开始应该是多少

11:19.610 --> 11:22.610
是不是要指向个数组的最开始啊

11:22.610 --> 11:23.610
所以应该是0

11:23.610 --> 11:24.610
对不对

11:24.610 --> 11:25.610
好 I

11:25.610 --> 11:26.610
G

11:26.610 --> 11:27.610
都是0

11:27.610 --> 11:29.610
他们指向个数组的最开始位置

11:29.610 --> 11:30.610
然后呢

11:30.610 --> 11:31.610
是不是我们还要准备一个变量

11:31.610 --> 11:32.610
max

11:32.610 --> 11:33.610
它的值为多少

11:33.610 --> 11:34.610
是不是为1

11:34.610 --> 11:35.610
刚才分析过的

11:35.610 --> 11:36.610
对吧

11:36.610 --> 11:37.610
这个东西很简单吧

11:37.610 --> 11:38.610
一开始

11:38.610 --> 11:39.610
一开始的情况

11:39.610 --> 11:40.610
没问题吧

11:40.610 --> 11:43.610
好 接下来我们循环

11:43.610 --> 11:44.610
循环啥呀

11:44.610 --> 11:45.610
我们要移动的是谁

11:45.610 --> 11:47.610
移动的是不是这个界呀

11:47.610 --> 11:50.610
它是不是要一次往后移动

11:50.610 --> 11:51.610
对不对

11:51.610 --> 11:52.610
是不是要一次往后移动

11:52.610 --> 11:55.610
好 那么我们就循环这个界

11:55.610 --> 11:56.610
循环

11:56.610 --> 11:58.610
循环 缝循环的第一段

11:58.610 --> 11:59.610
我们不写

11:59.610 --> 12:00.610
因为缝循环的第一段

12:00.610 --> 12:01.610
我们通常是定一个变量

12:01.610 --> 12:02.610
对吧

12:02.610 --> 12:03.610
定一个变量等于0

12:03.610 --> 12:04.610
但是呢

12:04.610 --> 12:05.610
现在编呢已经定好了

12:05.610 --> 12:06.610
我们要循环的变量在这

12:06.610 --> 12:07.610
不用写了

12:07.610 --> 12:09.610
第一段不用写了

12:09.610 --> 12:10.610
就看第二段

12:10.610 --> 12:12.610
第二段是一个条件

12:12.610 --> 12:14.610
也就是我们这个界呀

12:14.610 --> 12:16.610
要移动到哪个位置呢

12:16.610 --> 12:17.610
刚才分析过的

12:17.610 --> 12:19.610
需要小鱼

12:19.610 --> 12:21.610
s.nance

12:21.610 --> 12:22.610
谢谢佳佳

12:22.610 --> 12:24.610
那么我这里问一下

12:24.610 --> 12:26.610
这里写的是小鱼

12:26.610 --> 12:29.610
还是应该写小鱼等于

12:29.610 --> 12:31.610
如果说我用这种代码格式的话

12:31.610 --> 12:32.610
我应该是写小鱼

12:32.610 --> 12:34.610
还是应该小鱼等于

12:34.610 --> 12:35.610
想一想啊

12:35.610 --> 12:36.610
这里呢

12:36.610 --> 12:45.680
其实应该是小鱼等于

12:45.680 --> 12:51.040
应该是小鱼等于

12:51.040 --> 12:52.040
为什么呢

12:52.040 --> 12:54.040
因为凭是我们循环数

12:54.040 --> 12:55.040
主权都是小鱼对吧

12:55.040 --> 12:56.040
因为他只能取到数字

12:56.040 --> 12:58.040
最大下标就Ns-1

12:58.040 --> 12:59.040
他取不到Ns

12:59.040 --> 13:01.040
我们不用看这个位置

13:01.040 --> 13:02.040
但是呢这一次不一样

13:02.040 --> 13:04.040
你要具体情况具体分析

13:04.040 --> 13:05.040
这一次呢

13:05.040 --> 13:06.040
我们刚才演示的

13:06.040 --> 13:07.040
之后发现

13:07.040 --> 13:08.040
这个界这个变量啊

13:08.040 --> 13:09.040
他要可能要

13:09.040 --> 13:11.040
还要看一下这个位置

13:11.040 --> 13:12.040
他是不是还要看一下

13:12.040 --> 13:13.040
这个位置

13:13.040 --> 13:14.040
为什么呢

13:14.040 --> 13:15.040
因为我不知道

13:15.040 --> 13:16.040
后面还有没有连续制服

13:16.040 --> 13:17.040
对吧

13:17.040 --> 13:18.040
还要做一下同样的处理

13:18.040 --> 13:19.040
说要看到这个位置

13:19.040 --> 13:20.040
这个位置还是要看一次

13:20.040 --> 13:21.040
这个位置没有东西

13:21.040 --> 13:22.040
没有东西

13:22.040 --> 13:23.040
没有东西

13:23.040 --> 13:24.040
说明

13:24.040 --> 13:25.040
这个连续制服结束了

13:25.040 --> 13:26.040
对吧

13:26.040 --> 13:27.040
所以说我们海上

13:27.040 --> 13:28.040
循环到这个位置了

13:28.040 --> 13:29.040
因此到这里

13:29.040 --> 13:31.040
我们要写个小鱼等于

13:31.040 --> 13:32.040
好

13:32.040 --> 13:34.040
每一次循环做啥呢

13:34.040 --> 13:35.040
那就去看一下

13:35.040 --> 13:36.040
我们刚才的分析里边

13:36.040 --> 13:38.040
每一次在干什么

13:38.040 --> 13:39.040
在干什么呢

13:39.040 --> 13:41.040
是不是看一下

13:41.040 --> 13:43.040
这个界相同不管

13:43.040 --> 13:44.040
也就是说

13:44.040 --> 13:45.040
我们管的是什么

13:45.040 --> 13:47.040
管的是不相同的地方

13:47.040 --> 13:48.040
是不是这个界的东西

13:48.040 --> 13:50.040
跟i不一样了

13:50.040 --> 13:52.040
界不断的往后边移动

13:52.040 --> 13:53.040
相同不管

13:53.040 --> 13:54.040
下一次

13:54.040 --> 13:55.040
到这里

13:55.040 --> 13:56.040
不相同的

13:56.040 --> 13:57.040
不相同是不是

13:57.040 --> 13:58.040
我们要看一下

13:58.040 --> 13:59.040
因此呢

13:59.040 --> 14:00.040
我们这里的货里边

14:00.040 --> 14:01.040
所以应该有判断

14:01.040 --> 14:02.040
判断什么呀

14:02.040 --> 14:04.040
判断这个A

14:04.040 --> 14:05.040
其实我们写

14:05.040 --> 14:06.040
那个算法题呀

14:06.040 --> 14:08.040
呆马往往不多

14:08.040 --> 14:09.040
可能最多的话

14:09.040 --> 14:10.040
就几十行

14:10.040 --> 14:12.040
上百行呆马就不得了了

14:12.040 --> 14:13.040
呆马往往不多

14:13.040 --> 14:15.040
但是他的逻辑思维呢

14:15.040 --> 14:16.040
比较复杂

14:16.040 --> 14:18.040
今天晚上的还好一点

14:18.040 --> 14:20.040
就是这个界纸

14:20.040 --> 14:21.040
这个位置

14:21.040 --> 14:23.040
它指向的这个制服

14:23.040 --> 14:24.040
跟这个i这个位置

14:24.040 --> 14:25.040
指向的制服

14:25.040 --> 14:26.040
是不是不一样

14:26.040 --> 14:27.040
不一样的话

14:27.040 --> 14:28.040
我们是不是要记录一下

14:28.040 --> 14:30.040
之前连续出现了几次

14:30.040 --> 14:31.040
对吧

14:31.040 --> 14:32.040
好那么我们看一下

14:32.040 --> 14:33.040
看什么呢

14:33.040 --> 14:37.040
是不是si不等于sg

14:37.040 --> 14:38.040
对吧

14:38.040 --> 14:39.040
是不是不一样了

14:39.040 --> 14:40.040
有跟着我的思路者后

14:40.040 --> 14:42.040
我这里不好写注释的

14:42.040 --> 14:43.040
算法题中之中

14:43.040 --> 14:45.040
算法题都很难写注释的

14:45.040 --> 14:47.040
因为你写的注释也没用啊

14:47.040 --> 14:48.040
你不知道这个逻辑

14:48.040 --> 14:49.040
思维逻辑

14:49.040 --> 14:50.040
它的思维方向

14:51.040 --> 14:52.040
它不一样了

14:52.040 --> 14:54.040
不一样表现到这个时候

14:54.040 --> 14:55.040
它不一样的时候

14:55.040 --> 14:56.040
我们要干嘛

14:56.040 --> 14:57.040
要干嘛

14:57.040 --> 14:58.040
所以有几件事情要做

14:58.040 --> 15:00.040
首先我们要看一下

15:00.040 --> 15:03.040
目前就是它前边

15:03.040 --> 15:05.040
是不是一定是连续制服

15:05.040 --> 15:07.040
不然的话一动不到这个位置

15:07.040 --> 15:08.040
它一动到这个位置

15:08.040 --> 15:09.040
它一定是连续制服

15:09.040 --> 15:11.040
前边连续制服

15:11.040 --> 15:12.040
出现了几次

15:12.040 --> 15:13.040
那么这个出现了几次

15:13.040 --> 15:14.040
应该怎么算

15:14.040 --> 15:16.930
你们觉得

15:16.930 --> 15:17.930
出现几次

15:17.930 --> 15:18.930
应该怎么算

15:18.930 --> 15:19.930
怎么知道它出现了几次

15:20.930 --> 15:21.930
是非常简单

15:21.930 --> 15:22.930
这i简接就完事了

15:22.930 --> 15:23.930
对 接解i

15:23.930 --> 15:24.930
是不是就完事了

15:24.930 --> 15:26.930
对吧 接比较现在是2

15:26.930 --> 15:27.930
2-0

15:27.930 --> 15:28.930
不就是2吗

15:28.930 --> 15:29.930
不就是2次吗

15:29.930 --> 15:30.930
所以它出现的次数

15:30.930 --> 15:31.930
非常非常简单

15:31.930 --> 15:32.930
几次呢

15:32.930 --> 15:33.930
number

15:33.930 --> 15:35.930
或者called

15:35.930 --> 15:37.930
是不是接 解i

15:37.930 --> 15:40.930
前面重复制服

15:40.930 --> 15:42.930
出现的次数

15:43.930 --> 15:44.930
为了验证一下

15:44.930 --> 15:45.930
我们来看一下

15:45.930 --> 15:46.930
如果说只有

15:46.930 --> 15:47.930
只重复的一个

15:47.930 --> 15:48.930
是不是也是这样子

15:48.930 --> 15:50.930
如果说C这里

15:50.930 --> 15:51.930
C

15:51.930 --> 15:52.930
我们移动到D

15:52.930 --> 15:53.930
那么

15:53.930 --> 15:54.930
D是不是跟C不一样

15:54.930 --> 15:55.930
那么我们看

15:55.930 --> 15:56.930
C出现了几次

15:56.930 --> 15:57.930
所以也是接解i

15:57.930 --> 15:58.930
出现一次

15:58.930 --> 15:59.930
都是一样的

15:59.930 --> 16:01.930
它具有普世性的

16:01.930 --> 16:02.930
好 那么就是

16:02.930 --> 16:03.930
它出现的次数

16:03.930 --> 16:04.930
接下来干嘛

16:04.930 --> 16:06.930
接下来干嘛

16:06.930 --> 16:08.930
我刚才说了

16:08.930 --> 16:09.930
一光是出现的一个次数

16:09.930 --> 16:10.930
还不够

16:10.930 --> 16:11.930
我们还要把它记录一下

16:11.930 --> 16:12.930
因为最终

16:12.930 --> 16:13.930
我们要返回结果 对吧

16:13.930 --> 16:14.930
但是你现在不能返回

16:14.930 --> 16:15.930
你现在不能

16:15.930 --> 16:16.930
直接返回一个2

16:16.930 --> 16:17.930
那肯定不行的

16:17.930 --> 16:18.930
还有更长的

16:18.930 --> 16:19.930
所以说

16:19.930 --> 16:20.930
我们要把这个

16:20.930 --> 16:22.930
目前最长的记录一下

16:22.930 --> 16:23.930
目前最长是1

16:23.930 --> 16:24.930
那么现在说

16:24.930 --> 16:26.930
要跟这个东西来进行比较

16:26.930 --> 16:27.930
跟它进行比较

16:27.930 --> 16:29.930
如果说

16:29.930 --> 16:31.930
Count

16:31.930 --> 16:32.930
大于了

16:32.930 --> 16:33.930
什么

16:33.930 --> 16:34.930
Max

16:34.930 --> 16:36.930
是不是要记住最大的

16:36.930 --> 16:38.930
把重新记录

16:38.930 --> 16:39.930
一个更大的

16:39.930 --> 16:41.930
重复之复

16:41.930 --> 16:42.930
数量

16:42.930 --> 16:43.930
那么我们记录一下

16:43.930 --> 16:45.930
记录一下就是

16:45.930 --> 16:46.930
Max等于Count

16:47.930 --> 16:50.620
完成了

16:50.620 --> 16:52.620
然后还要做啥

16:52.620 --> 16:54.620
还要做啥

16:54.620 --> 16:56.620
不管你有没有重新记录它

16:56.620 --> 16:57.620
我们接下来

16:57.620 --> 16:58.620
是不是这个制服

16:58.620 --> 16:59.620
已经看完了

16:59.620 --> 17:00.620
我们要干嘛

17:00.620 --> 17:01.620
是不是要重新

17:01.620 --> 17:02.620
把这个i归位

17:02.620 --> 17:04.620
重新归到这个位置

17:04.620 --> 17:05.620
因为后边还要重新来了

17:05.620 --> 17:06.620
它要去看

17:06.620 --> 17:07.620
下一个制服了

17:07.620 --> 17:08.620
对不对

17:08.620 --> 17:09.620
所以说i这个制服

17:09.620 --> 17:11.620
要重新把它的位置

17:11.620 --> 17:12.620
归到

17:12.620 --> 17:13.620
借这个位置

17:13.620 --> 17:14.620
就写完了

17:14.620 --> 17:16.620
最后我们返回

17:16.620 --> 17:17.620
除了这个循环

17:17.620 --> 17:18.620
你看这个循环结束之后

17:18.620 --> 17:20.620
是不是把整个制服

17:20.620 --> 17:21.620
看完了

17:21.620 --> 17:22.620
看完之后

17:22.620 --> 17:23.620
整个连续制服就出来了

17:23.620 --> 17:24.620
就到连续制服就出来了

17:24.620 --> 17:25.620
对成Max

17:26.620 --> 17:27.620
带吧

17:27.620 --> 17:28.620
本身不读

17:28.620 --> 17:29.620
这个带吧还可以简化一下

17:29.620 --> 17:30.620
比方说

17:30.620 --> 17:31.620
我也不能简化了

17:31.620 --> 17:32.620
没法简化

17:32.620 --> 17:35.060
就这样子

17:35.060 --> 17:36.060
好

17:36.060 --> 17:37.060
这个函数就写完了

17:37.060 --> 17:38.060
最后验证一下这个结果

17:38.060 --> 17:39.060
我们看一下这个结果

17:39.060 --> 17:40.060
是不是我们

17:40.060 --> 17:41.060
这个测试结果

17:41.060 --> 17:42.060
运行一下

17:42.060 --> 17:44.060
34011

17:44.060 --> 17:45.060
没问题

17:45.060 --> 17:46.060
好

17:46.060 --> 17:47.060
一个函数

17:47.060 --> 17:48.060
这么一个算法题

17:48.060 --> 17:49.060
虽然主要简单

17:49.060 --> 17:50.060
但是通过这个题

17:50.060 --> 17:52.060
这也是真实的面试题

17:52.060 --> 17:53.060
通过这个题

17:53.060 --> 17:54.060
给大家做一个启发

17:54.060 --> 17:55.060
就是说算法题

17:55.060 --> 17:57.060
你首先要做的事情

17:57.060 --> 17:58.060
是找到思路

17:59.060 --> 18:00.060
那么一开始找不到

18:00.060 --> 18:01.060
老实可以告诉你

18:01.060 --> 18:02.060
但找到思路过后

18:02.060 --> 18:03.060
你还是有一个能力

18:03.060 --> 18:04.060
就是你要把这个思路

18:04.060 --> 18:05.060
转换成带吧

18:05.060 --> 18:06.060
怎么去转换成带吧

18:06.060 --> 18:07.060
大家可以体会一下

18:07.060 --> 18:08.060
这种感觉

18:09.060 --> 18:10.060
这是第1道题

18:10.060 --> 18:11.060
第1道题有啥问题吗

18:14.850 --> 18:15.850
有路过了

18:18.610 --> 18:19.610
我看一下前面

18:19.610 --> 18:20.610
前面同学们有啥问题吗

18:20.610 --> 18:21.610
第1道问题

18:21.610 --> 18:22.610
前面同学

18:23.610 --> 18:24.610
可能问到了我没看到的

18:24.610 --> 18:25.610
有没有什么问题

18:25.610 --> 18:26.610
可以

18:26.610 --> 18:27.610
可以打一下

18:34.340 --> 18:35.340
那么下一个

18:37.340 --> 18:38.340
今天的题都比较简单

18:38.340 --> 18:39.340
今天我们开开会

18:39.340 --> 18:40.340
不要搞的第1天

18:40.340 --> 18:41.340
就非常沉重

18:42.340 --> 18:43.340
第二道题

18:43.340 --> 18:44.340
是一个阿里的面试题

18:44.340 --> 18:45.340
其实这道题

18:45.340 --> 18:46.340
也不仅仅是阿里的

18:46.340 --> 18:47.340
我已经见到

18:47.340 --> 18:49.340
不少大厂都有这道面试题了

18:50.340 --> 18:51.340
验证回温串

18:52.340 --> 18:53.340
啥叫回温串

18:54.340 --> 18:55.340
还有一个制服串

18:55.340 --> 18:58.340
它争择读跟反择读是一样的

18:58.340 --> 19:00.340
它的字母出现顺序是一样的

19:00.340 --> 19:01.340
叫回温串

19:02.340 --> 19:03.340
比方说我们这里有个例子

19:04.340 --> 19:06.340
本题中我们将空制服串

19:09.340 --> 19:10.340
定义为有效制服串

19:10.340 --> 19:11.340
有效的回温串

19:11.340 --> 19:12.340
啥意思呢

19:12.340 --> 19:13.340
如果说了一个制服串

19:13.340 --> 19:14.340
它是一个空制服串

19:14.340 --> 19:15.340
它什么内容都没有

19:15.340 --> 19:16.340
它仍然是一个有效的回温串

19:16.340 --> 19:18.340
它是这样子规定的

19:18.340 --> 19:20.340
而且回温串中

19:20.340 --> 19:21.340
只能考虑制服

19:21.340 --> 19:22.340
字母和数字

19:23.340 --> 19:24.340
有什么兜号

19:24.340 --> 19:25.340
空格

19:25.340 --> 19:26.340
回车换行

19:26.340 --> 19:28.340
这些东西全部忽略

19:28.340 --> 19:30.340
而且忽略字母的大条写

19:30.340 --> 19:31.340
举到一个几个例子

19:31.340 --> 19:32.340
比方说

19:32.340 --> 19:35.350
这个例子

19:39.350 --> 19:40.350
这就是一个回温串

19:40.350 --> 19:41.350
为什么呢你反正读看一下吧

19:41.350 --> 19:43.350
反正我只是没有

19:43.350 --> 19:45.350
就是你要完全过滤掉空格

19:45.350 --> 19:46.350
兜号

19:46.350 --> 19:47.350
这些干擾制服

19:47.350 --> 19:48.350
看一下吧

19:55.350 --> 19:56.350
Plan

19:59.350 --> 20:00.350
Tan

20:03.350 --> 20:04.350
Tan

20:08.350 --> 20:09.350
Plam

20:09.350 --> 20:10.350
上面就是一个回温串

20:11.350 --> 20:12.350
要完全忽略掉

20:12.350 --> 20:13.350
这个兜号

20:13.350 --> 20:14.350
大小写

20:14.350 --> 20:15.350
以及空格

20:15.350 --> 20:16.350
好

20:16.350 --> 20:17.350
第二个例子

20:17.350 --> 20:18.350
它又不是一个回温串

20:18.350 --> 20:19.350
你看

20:19.350 --> 20:20.350
r

20:20.350 --> 20:21.350
r没问题

20:21.350 --> 20:22.350
a没问题

20:22.350 --> 20:23.350
c

20:23.350 --> 20:24.350
c没问题

20:24.350 --> 20:25.350
但是这里出现问题了

20:25.350 --> 20:26.350
对吧

20:26.350 --> 20:27.350
e和a不一样

20:28.350 --> 20:29.350
这就是一个回温串

20:29.350 --> 20:31.350
那么这个回温串怎么去验证呢

20:35.350 --> 20:36.350
可能今天可能要加几道题

20:36.350 --> 20:37.350
今天可能要加几道题

20:40.350 --> 20:42.350
这个回温串怎么去验证呢

20:42.350 --> 20:46.430
我们可以用对撞直升

20:46.430 --> 20:47.430
其实我们人的话

20:47.430 --> 20:48.430
怎么去验那个回温串

20:48.430 --> 20:49.430
不就是这样来吗

20:49.430 --> 20:50.430
就是说

20:50.430 --> 20:51.430
如果说我告诉你

20:51.430 --> 20:52.430
你其实你做一些面

20:52.430 --> 20:53.430
面试的算法题的时候

20:53.430 --> 20:55.430
其实你可以用这种这样的识录

20:55.430 --> 20:56.430
就说

20:56.430 --> 20:57.430
你不用去考虑程序

20:57.430 --> 20:59.430
你说你怎么办

20:59.430 --> 21:00.430
这东西让你来判断

21:00.430 --> 21:01.430
到底是不是回温串

21:01.430 --> 21:02.430
你怎么办

21:03.430 --> 21:04.430
最好的办法是什么

21:04.430 --> 21:05.430
就是

21:05.430 --> 21:06.430
一个一个看呗

21:06.430 --> 21:07.430
它看第一个

21:07.430 --> 21:08.430
它看最后一个

21:08.430 --> 21:09.430
它看第二个

21:09.430 --> 21:10.430
它看到处第二个

21:10.430 --> 21:11.430
对吧

21:11.430 --> 21:12.430
是不是用这种方式来看

21:12.430 --> 21:13.430
遇到空格

21:13.430 --> 21:14.430
遇到兜号

21:14.430 --> 21:15.430
直接忽略

21:15.430 --> 21:16.430
比方说

21:16.430 --> 21:17.430
a

21:17.430 --> 21:18.430
a没问题

21:18.430 --> 21:19.430
n

21:19.430 --> 21:20.430
n没问题

21:20.430 --> 21:21.430
兜号

21:21.430 --> 21:22.430
直接忽略

21:22.430 --> 21:23.430
下一个空格

21:23.430 --> 21:24.430
直接忽略

21:24.430 --> 21:25.430
下一个a

21:25.430 --> 21:26.430
这边

21:26.430 --> 21:27.430
a没问题

21:27.430 --> 21:28.430
是不是

21:28.430 --> 21:29.430
一个往右边看

21:29.430 --> 21:30.430
一个往左边看

21:30.430 --> 21:31.430
那么这个玩意

21:31.430 --> 21:32.430
就是一个

21:32.430 --> 21:33.430
双纸针的对双纸针

21:33.430 --> 21:34.430
好

21:34.430 --> 21:35.430
咱们来看一下

21:35.430 --> 21:36.430
这里是一个字幕串

21:36.430 --> 21:37.430
它第一个是空格

21:37.430 --> 21:38.430
有一些兜号

21:38.430 --> 21:39.430
这里有两个空格

21:39.430 --> 21:40.430
看一下怎么看的

21:40.430 --> 21:41.430
我用两个纸针

21:41.430 --> 21:42.430
当然如果说

21:42.430 --> 21:43.430
这个字幕串长度为0

21:43.430 --> 21:44.430
我们把一个

21:44.430 --> 21:45.430
先把一个代码

21:45.430 --> 21:46.430
靠谤过去

21:46.430 --> 21:50.540
这是

21:51.540 --> 21:52.540
验证

21:52.540 --> 21:54.540
回温串

21:54.540 --> 21:59.700
首先把这个情况

21:59.700 --> 22:00.700
过滤掉

22:00.700 --> 22:02.700
s.n

22:02.700 --> 22:03.700
小于

22:03.700 --> 22:05.700
等于0的情况

22:05.700 --> 22:06.700
那么这种情况

22:06.700 --> 22:09.700
我们直接反回0

22:09.700 --> 22:10.700
直接反回去

22:10.700 --> 22:11.700
因为空字幕串

22:11.700 --> 22:12.700
我们刚才说了

22:12.700 --> 22:13.700
假设空字幕串

22:13.700 --> 22:14.700
它就是一个

22:14.700 --> 22:15.700
有效的回温串

22:15.700 --> 22:16.700
好 接下来

22:16.700 --> 22:17.700
我们自己去看看

22:17.700 --> 22:18.700
看这边

22:18.700 --> 22:20.700
正常的情况下

22:20.700 --> 22:21.700
我们准备好两个纸针

22:21.700 --> 22:23.700
一个只向左边

22:23.700 --> 22:25.700
一个只向右边

22:25.700 --> 22:26.700
好

22:26.700 --> 22:27.700
接下来我们就

22:27.700 --> 22:29.700
开始了

22:29.700 --> 22:30.700
首先看一下

22:30.700 --> 22:32.700
左边这个纸针

22:32.700 --> 22:33.700
是不是

22:33.700 --> 22:35.700
只向了一个无效的制服

22:35.700 --> 22:37.700
如果说无效

22:37.700 --> 22:39.700
往右边移动

22:39.700 --> 22:41.700
好 下一次

22:41.700 --> 22:42.700
右看一下

22:42.700 --> 22:43.700
左边这个纸针

22:43.700 --> 22:44.700
是不是只向有效的制服

22:44.700 --> 22:45.700
好 它是了

22:45.700 --> 22:46.700
对不对 没问题

22:46.700 --> 22:47.700
好 接下来

22:47.700 --> 22:48.700
我们看一下

22:48.700 --> 22:49.700
右边这个纸针

22:49.700 --> 22:50.700
是不是只向有效的制服

22:50.700 --> 22:51.700
不是

22:51.700 --> 22:53.700
往左边移动

22:53.700 --> 22:55.700
好 下一次

22:55.700 --> 22:56.700
再一下一次

22:56.700 --> 22:57.700
右来看一下

22:57.700 --> 22:59.700
左边那个是不是有效的

22:59.700 --> 23:01.700
有效 不动

23:01.700 --> 23:03.700
右边那个是不是无效的

23:03.700 --> 23:06.700
无效的往左边移动

23:06.700 --> 23:07.700
好 右来

23:07.700 --> 23:08.700
看一下左边这个

23:08.700 --> 23:10.700
是不是有效的

23:10.700 --> 23:11.700
看一下右边这个

23:11.700 --> 23:12.700
是不是有效的

23:12.700 --> 23:13.700
都有效的

23:13.700 --> 23:14.700
那么都有效的情况下

23:14.700 --> 23:15.700
看一下这两个制服

23:15.700 --> 23:17.700
是不是不向等

23:17.700 --> 23:18.700
好 如果说

23:18.700 --> 23:19.700
它们不向等

23:19.700 --> 23:21.700
比方说这里是一个异

23:21.700 --> 23:24.700
它们不向等怎么办

23:24.700 --> 23:25.700
你们觉得

23:25.700 --> 23:26.700
如果说这里看到了

23:26.700 --> 23:28.700
已经有不向等的了

23:28.700 --> 23:29.700
怎么办

23:29.700 --> 23:36.980
直接返回Force就完事了

23:36.980 --> 23:37.980
对不对

23:37.980 --> 23:38.980
还用继续看吗

23:38.980 --> 23:40.980
它肯定不是一个返回温串了

23:40.980 --> 23:41.980
对吧

23:41.980 --> 23:42.980
像头位的位置

23:42.980 --> 23:43.980
都已经不一样了

23:43.980 --> 23:44.980
肯定不是返回温串

23:44.980 --> 23:45.980
直接返回Force

23:45.980 --> 23:46.980
不用再往后看了

23:46.980 --> 23:49.980
那么我们只看向等的情况

23:49.980 --> 23:51.980
如果说向等的情况

23:51.980 --> 23:53.980
那么怎么办

23:53.980 --> 23:55.980
是不是这一位已经没问题了

23:55.980 --> 23:56.980
没问题就继续往后看

23:56.980 --> 23:58.980
因为后面可能还有问题

23:58.980 --> 23:59.980
所以继续往后看

23:59.980 --> 24:01.980
它就往右边移动

24:01.980 --> 24:03.980
它又往左边移动

24:03.980 --> 24:04.980
好 又来

24:04.980 --> 24:05.980
下一次呢

24:05.980 --> 24:06.980
它没问题

24:06.980 --> 24:08.980
它是一个无效制服

24:08.980 --> 24:09.980
往右边移动

24:09.980 --> 24:10.980
再下一次

24:10.980 --> 24:11.980
它是有效的

24:11.980 --> 24:13.980
再下一次

24:13.980 --> 24:15.980
它是无效的

24:15.980 --> 24:17.980
往左边移动

24:17.980 --> 24:18.980
好 接下来

24:18.980 --> 24:19.980
两个都有效了

24:19.980 --> 24:20.980
两个都有效

24:20.980 --> 24:21.980
看一下一不一样

24:21.980 --> 24:22.980
一样 没问题

24:22.980 --> 24:24.980
移动

24:24.980 --> 24:25.980
好 那么这个时候呢

24:25.980 --> 24:26.980
又来

24:26.980 --> 24:27.980
看一下有没有有效呢

24:27.980 --> 24:28.980
它是有效制服

24:28.980 --> 24:30.980
它呢是无效制服

24:30.980 --> 24:32.980
无效制服往左边移动

24:32.980 --> 24:34.980
好 两个字针重叠了

24:34.980 --> 24:36.980
重叠了还用看吗

24:36.980 --> 24:37.980
就不用看了

24:37.980 --> 24:38.980
不能重叠

24:38.980 --> 24:39.980
你重叠的没意义了

24:39.980 --> 24:40.980
因为这个位置

24:40.980 --> 24:41.980
他们都是一个位置

24:41.980 --> 24:42.980
他们一定是相同的

24:42.980 --> 24:43.980
对吧

24:43.980 --> 24:45.980
如果说两个字针碰上了

24:45.980 --> 24:47.980
见了面

24:47.980 --> 24:49.980
说明他们走过的位置

24:49.980 --> 24:50.980
全部没问题

24:50.980 --> 24:51.980
如果有问题

24:51.980 --> 24:52.980
早就结束了

24:52.980 --> 24:53.980
它不用看了

24:53.980 --> 24:54.980
因为我们知道

24:54.980 --> 24:55.980
之前如果说发现

24:55.980 --> 24:57.980
任何一个不正确

24:57.980 --> 24:59.980
不正确的话直接返回了

24:59.980 --> 25:02.980
直到两个字针碰撞在一起的时候呢

25:02.980 --> 25:03.980
就发现他们走过的地方

25:03.980 --> 25:04.980
都一定没问题了

25:04.980 --> 25:05.980
那么这个时候

25:05.980 --> 25:06.980
就可以大胆的认为

25:06.980 --> 25:08.980
他们就是一个维吻串

25:08.980 --> 25:10.980
好 这是它的实录

25:10.980 --> 25:11.980
没问题吧

25:11.980 --> 25:17.450
实录能听懂吗

25:17.450 --> 25:18.450
OK

25:18.450 --> 25:19.450
有同学说

25:19.450 --> 25:20.450
那么这个问题

25:20.450 --> 25:21.450
我们可以首先

25:21.450 --> 25:22.450
把这个制服串的

25:22.450 --> 25:24.450
这些无效制服全部去掉

25:24.450 --> 25:25.450
对吧

25:25.450 --> 25:26.450
把什么只要是不是数字

25:26.450 --> 25:27.450
只要不是字母

25:27.450 --> 25:28.450
那么这样的制服

25:28.450 --> 25:29.450
都给它去掉

25:29.450 --> 25:31.450
但是我不建议这样去做

25:31.450 --> 25:32.450
为什么呢

25:32.450 --> 25:33.450
因为如果说

25:33.450 --> 25:34.450
一旦涉及到算法的话

25:34.450 --> 25:35.450
一般来说

25:35.450 --> 25:38.450
都希望你用最高效率的写法

25:38.450 --> 25:40.450
你用一个政策去替换

25:40.450 --> 25:41.450
当然这里肯定要设计

25:41.450 --> 25:42.450
这里到一个政策替换

25:42.450 --> 25:43.450
对吧

25:43.450 --> 25:44.450
非数字

25:44.450 --> 25:45.450
这个代码其实可以把

25:45.450 --> 25:47.450
写一行写出来

25:47.450 --> 25:48.450
你希望怎么写的

25:48.450 --> 25:49.450
就是一个replace

25:49.450 --> 25:54.230
就是把那些空格

25:54.230 --> 25:55.230
回车

25:55.230 --> 25:56.230
兜号

25:56.230 --> 25:57.230
这些非数字

25:57.230 --> 25:58.230
非字母的东西全部去掉

25:58.230 --> 25:59.230
怎么去掉呢

25:59.230 --> 26:00.230
你就可以写个政策

26:00.230 --> 26:03.230
只要你不是数字

26:03.230 --> 26:06.230
也不是字母

26:06.230 --> 26:07.230
小写字母

26:07.230 --> 26:08.230
或者是大写字母

26:08.230 --> 26:10.230
这些都不是

26:10.230 --> 26:12.230
那么我就把它替换成

26:12.230 --> 26:13.230
一个空白字路串

26:13.230 --> 26:14.230
一个空字路串

26:14.230 --> 26:15.230
可不可以

26:15.230 --> 26:16.230
当然可以

26:16.230 --> 26:17.230
这样做起来会简单很多

26:17.230 --> 26:19.230
但是我不推荐大家

26:19.230 --> 26:20.230
这样去做

26:20.230 --> 26:21.230
为什么呢

26:21.230 --> 26:22.230
因为这样做

26:22.230 --> 26:23.230
会影响的

26:23.230 --> 26:24.230
会影响效率的

26:24.230 --> 26:25.230
为什么会影响效率呢

26:25.230 --> 26:28.230
因为政策的替换

26:28.230 --> 26:30.230
它也是会辨历的

26:30.230 --> 26:31.230
尽管你这里没有写

26:31.230 --> 26:32.230
什么方式循环

26:32.230 --> 26:33.230
没有写外卫循环

26:33.230 --> 26:34.230
但是它里边

26:34.230 --> 26:35.230
这个函数内部

26:35.230 --> 26:36.230
它会去辨历

26:36.230 --> 26:37.230
这个字母串

26:37.230 --> 26:39.230
一端一端的去看

26:39.230 --> 26:40.230
所以它实际上

26:40.230 --> 26:41.230
把这个字母串

26:41.230 --> 26:42.230
已经辨历了一次了

26:42.230 --> 26:43.230
那你想

26:43.230 --> 26:44.230
之前是不是

26:44.230 --> 26:45.230
已经辨历了一次了

26:45.230 --> 26:46.230
那么接下来

26:46.230 --> 26:47.230
我又要辨历一次

26:47.230 --> 26:48.230
辨历了两次

26:48.230 --> 26:49.230
对不对

26:49.230 --> 26:50.230
其实没有必要的

26:50.230 --> 26:51.230
那么这里

26:51.230 --> 26:53.230
我就按照刚才的施路

26:53.230 --> 26:54.230
看一位

26:54.230 --> 26:55.230
它有问题

26:55.230 --> 26:56.230
有问题的话

26:56.230 --> 26:57.230
就往后移

26:57.230 --> 26:58.230
我这个东西

26:58.230 --> 26:59.230
不用这么方式

26:59.230 --> 27:00.230
那么这里边

27:00.230 --> 27:01.230
就涉及到一个问题

27:01.230 --> 27:02.230
就是说

27:02.230 --> 27:03.230
我这里边

27:03.230 --> 27:04.230
怎么样判断一个字符

27:04.230 --> 27:05.230
它是不是有效的

27:05.230 --> 27:06.230
就判断了一个字符

27:06.230 --> 27:08.230
它是不是有效的

27:08.230 --> 27:09.230
那怎么来判断呢

27:09.230 --> 27:11.230
我们可以写成一个函数

27:11.230 --> 27:12.230
一个辅助函数

27:12.230 --> 27:13.230
给它取个名字叫

27:13.230 --> 27:14.230
Espany的

27:14.230 --> 27:15.230
这个函数非常简单

27:15.230 --> 27:16.230
就判断一个字符

27:16.230 --> 27:17.230
是不是有效的

27:17.230 --> 27:19.230
你给我一个字符

27:19.230 --> 27:20.230
我来判断这个字符

27:20.230 --> 27:21.230
是不是有效的

27:21.230 --> 27:23.230
怎么判断

27:23.230 --> 27:24.230
这里要用到

27:24.230 --> 27:25.230
一些基础的知识

27:26.230 --> 27:28.230
打开一个浏览器

27:32.610 --> 27:33.610
比方说

27:33.610 --> 27:34.610
你给我一个字符

27:34.610 --> 27:35.610
逗号

27:35.610 --> 27:36.610
我怎么知道

27:36.610 --> 27:37.610
它是不是有效的

27:38.610 --> 27:39.610
你们会怎么判断

27:41.610 --> 27:42.610
同学很好

27:42.610 --> 27:43.610
非常不错

27:43.610 --> 27:44.610
有的人知道

27:44.610 --> 27:45.610
用ASK码去判断

27:45.610 --> 27:46.610
那么其实

27:46.610 --> 27:47.610
这里很简单

27:47.610 --> 27:48.610
因为在我们

27:48.610 --> 27:49.610
JS大码里边

27:49.610 --> 27:50.610
可以通过

27:50.610 --> 27:51.610
字符

27:51.610 --> 27:52.610
本身就可以

27:52.610 --> 27:54.610
跟一个数字进行比较

27:54.610 --> 27:55.610
或者字符

27:55.610 --> 27:56.610
进行比较

27:56.610 --> 27:57.610
比方说

27:57.610 --> 27:58.610
我们知道A

27:58.610 --> 27:59.610
小于Z

27:59.610 --> 28:00.610
它是Q

28:00.610 --> 28:01.610
为什么是Q呢

28:01.610 --> 28:02.610
因为A的ASK码

28:02.610 --> 28:04.610
它是小于Z的ASK码

28:04.610 --> 28:05.610
因此我们这里

28:05.610 --> 28:06.610
要做的事情

28:06.610 --> 28:07.610
其实很简单

28:07.610 --> 28:08.610
就是我们知道

28:08.610 --> 28:09.610
0的ASK码

28:10.610 --> 28:11.610
是不是小于1的呢

28:11.610 --> 28:12.610
是不是小于1

28:12.610 --> 28:13.610
那么最大的

28:13.610 --> 28:14.610
是多少

28:14.610 --> 28:15.610
最大的是不是9

28:15.610 --> 28:16.610
因此我们可以判断

28:16.610 --> 28:17.610
它到底是不是

28:17.610 --> 28:18.610
一个数字就可以了

28:18.610 --> 28:20.610
我们可以这样判断

28:22.610 --> 28:24.610
CHARD的范围

28:24.610 --> 28:25.610
字符是不是

28:25.610 --> 28:27.610
大于等于0

28:27.610 --> 28:31.610
并且小于等于9

28:32.610 --> 28:33.610
就可以

28:33.610 --> 28:34.610
有0到9吗

28:34.610 --> 28:35.610
那么表示数字

28:35.610 --> 28:36.610
那是OK的

28:36.610 --> 28:37.610
表示有效的

28:38.610 --> 28:39.610
或者它不是数字

28:39.610 --> 28:40.610
它可能是字母

28:40.610 --> 28:41.610
那么它是不是

28:41.610 --> 28:44.610
大于等于A

28:45.610 --> 28:49.610
并且小于等于Z

28:49.610 --> 28:50.610
就可以

28:50.610 --> 28:52.610
A到Z之间也可以

28:52.610 --> 28:53.610
或者呢

28:53.610 --> 28:55.610
是不是大于等于

28:55.610 --> 28:57.610
大写的A

28:57.610 --> 28:59.610
并且小于等于

28:59.610 --> 29:00.610
大写的Z

29:00.610 --> 29:01.610
这样子是可以判断

29:01.610 --> 29:02.610
这样当然可以判断

29:02.610 --> 29:03.610
我们来试一下吧

29:03.610 --> 29:04.610
把这个函数扔过来

29:04.610 --> 29:07.300
好

29:07.300 --> 29:08.300
我们来试一下

29:08.300 --> 29:09.300
这个函数

29:09.300 --> 29:10.300
你看豆号

29:10.300 --> 29:11.300
冒号

29:11.300 --> 29:12.300
是不是一个有效的数字

29:12.300 --> 29:13.300
Force

29:13.300 --> 29:15.300
或者是我们看一下A

29:15.300 --> 29:16.300
OK

29:16.300 --> 29:17.300
没问题

29:17.300 --> 29:18.300
大写的A

29:18.300 --> 29:19.300
没问题

29:19.300 --> 29:20.300
大写的B

29:20.300 --> 29:22.300
没问题

29:23.300 --> 29:24.300
然后呢

29:28.300 --> 29:29.300
就可以判断了

29:29.300 --> 29:31.300
先写个辅助还说

29:31.300 --> 29:32.300
当然这里边写法有很多

29:32.300 --> 29:34.300
比方说你也可以写成这种格式

29:34.300 --> 29:36.300
写成用正则来判断

29:36.300 --> 29:37.300
怎么正则呢

29:37.300 --> 29:40.810
我们可以写一个

29:40.810 --> 29:41.810
写钢技

29:41.810 --> 29:43.810
A到Z

29:43.810 --> 29:45.810
这是个正则表达式

29:45.810 --> 29:46.810
然后用Test

29:46.810 --> 29:47.810
这也可以

29:47.810 --> 29:49.810
如果说测试通过

29:49.810 --> 29:50.810
表示它是一个有效的数字

29:50.810 --> 29:52.810
有效的字母

29:52.810 --> 29:54.810
那么都可以

29:54.810 --> 29:56.810
这里会不会影响效率呢

29:56.810 --> 29:57.810
这里不会

29:57.810 --> 29:58.810
为什么不会呢

29:58.810 --> 29:59.810
因为它只看了一个字符

29:59.810 --> 30:00.810
它只看了一个

30:00.810 --> 30:02.810
这里也可以用正则

30:02.810 --> 30:03.810
也是没问题的

30:03.810 --> 30:04.810
不过你这里

30:04.810 --> 30:06.810
如果说你要追求集式的效率的话

30:06.810 --> 30:07.810
那么这个正则表达式

30:07.810 --> 30:09.810
你可以把它提出去

30:09.810 --> 30:10.810
为什么提出去好一点呢

30:10.810 --> 30:12.810
因为如果说你这样的写的话

30:12.810 --> 30:14.810
你每一次运行函数

30:14.810 --> 30:15.810
都会创建这个正则表达式对象

30:15.810 --> 30:16.810
因为我们知道

30:16.810 --> 30:17.810
正则表达式本质上是一个对象

30:17.810 --> 30:18.810
所以一个Rigger

30:18.810 --> 30:19.810
一个Expression

30:19.810 --> 30:20.810
对吧

30:20.810 --> 30:21.810
这样子写了

30:21.810 --> 30:22.810
是不是创建了一个Rigger

30:22.810 --> 30:23.810
Expression

30:23.810 --> 30:24.810
创建一个对象

30:24.810 --> 30:25.810
每次都会创建一个同一个对象

30:25.810 --> 30:26.810
没什么意义

30:26.810 --> 30:28.810
你可以把它写出去

30:28.810 --> 30:33.810
Vanity的Expression

30:33.810 --> 30:37.250
把它写出去了

30:37.250 --> 30:38.250
这样子就避免

30:38.250 --> 30:39.250
每次创建对象了

30:39.250 --> 30:41.250
其实这些都是小的細写

30:41.250 --> 30:44.620
它并不影响最终的结构

30:44.620 --> 30:45.620
OK

30:45.620 --> 30:46.620
那么这个函数就写好了

30:47.620 --> 30:48.620
好

30:48.620 --> 30:49.620
接下来

30:49.620 --> 30:50.620
继续

30:50.620 --> 30:52.620
那么现在我们回到这个函数

30:52.620 --> 30:53.620
是不是一个回温圈

30:53.620 --> 30:54.620
怎么判断呢

30:54.620 --> 30:55.620
看这

30:56.620 --> 30:57.620
两个指针

30:57.620 --> 30:59.620
我们一个要往右边移动

30:59.620 --> 31:03.000
一个要往左边移动

31:03.000 --> 31:04.000
什么时候停止

31:04.000 --> 31:05.000
是不是要不断的移动

31:05.000 --> 31:06.000
它肯定是有循环

31:06.000 --> 31:08.000
什么时候停止呢

31:08.000 --> 31:10.000
是不是两个指针碰上了

31:10.000 --> 31:12.000
或者说这种情况

31:12.000 --> 31:13.000
或者是这种情况

31:13.000 --> 31:15.000
如果说出现这种情况

31:15.000 --> 31:18.000
然后他们比方说相同

31:18.000 --> 31:19.000
比方说出现这种情况

31:19.000 --> 31:20.000
他们相同

31:20.000 --> 31:21.000
然后一个往右边移动

31:21.000 --> 31:22.000
一个往左边移动

31:22.000 --> 31:24.000
是不是错过了

31:24.000 --> 31:25.000
相装或者相

31:25.000 --> 31:27.000
就是位置一样了

31:27.000 --> 31:28.000
或者是位置错过了

31:28.000 --> 31:29.000
都要停止

31:29.000 --> 31:31.000
什么时候不停止呢

31:31.000 --> 31:32.000
就是这种情况

31:32.000 --> 31:33.000
一个在左边

31:33.000 --> 31:34.000
一个在右边

31:34.000 --> 31:35.000
那就不停止

31:35.000 --> 31:36.000
所以说我们的循环条件

31:36.000 --> 31:37.000
是不是Left

31:37.000 --> 31:39.000
要先提两个辩量

31:39.000 --> 31:40.000
一个是左边

31:40.000 --> 31:41.000
0

31:41.000 --> 31:42.000
右边呢

31:42.000 --> 31:44.000
是不是说的长度减1

31:44.000 --> 31:45.000
就是一个指向

31:45.000 --> 31:46.000
一个位置

31:46.000 --> 31:47.000
一个指向这个位置

31:47.000 --> 31:48.000
对不对

31:48.000 --> 31:49.000
好

31:49.000 --> 31:50.000
然后呢

31:50.000 --> 31:52.000
什么时候它要继续呢

31:52.000 --> 31:54.000
就是Left小于Right

31:54.000 --> 31:55.000
对不对

31:55.000 --> 31:57.000
是不是它小于它的时候

31:57.000 --> 31:59.820
小于它的时候呢

31:59.820 --> 32:01.820
是不是还没看完

32:01.820 --> 32:02.820
因为他们如果说

32:02.820 --> 32:03.820
一旦相遇就看完了

32:03.820 --> 32:04.820
小于它的时候

32:04.820 --> 32:05.820
就没有看完

32:05.820 --> 32:06.820
没有看完

32:06.820 --> 32:07.820
要继续看

32:07.820 --> 32:08.820
那么欢迎而言之

32:08.820 --> 32:10.820
如果说出了循环

32:10.820 --> 32:11.820
循环

32:11.820 --> 32:13.820
循环里边还没写

32:13.820 --> 32:15.820
如果说循环结束了

32:15.820 --> 32:16.820
我们应该做什么

32:16.820 --> 32:17.820
来填空

32:17.820 --> 32:19.820
循环结束了

32:19.820 --> 32:22.580
应该做什么

32:22.580 --> 32:23.580
这就出了

32:23.580 --> 32:24.580
对吧

32:24.580 --> 32:30.610
看完了

32:30.610 --> 32:31.610
就已经看完了

32:31.610 --> 32:32.610
看完了都没问题

32:32.610 --> 32:33.610
对吧

32:33.610 --> 32:34.610
它走过了路

32:34.610 --> 32:35.610
和它走过了路

32:35.610 --> 32:36.610
都没问题了

32:36.610 --> 32:37.610
那就循环结束了

32:37.610 --> 32:38.610
两个人都相遇了

32:38.610 --> 32:39.610
那就OK

32:39.610 --> 32:40.610
赶回去

32:40.610 --> 32:41.610
是吧

32:41.610 --> 32:42.610
很好啊

32:42.610 --> 32:43.610
还是跟得上思路

32:43.610 --> 32:44.610
那么接下来

32:44.610 --> 32:45.610
就在循环里边了

32:45.610 --> 32:47.610
每一次循环结束了

32:47.610 --> 32:49.610
每一次循环干嘛呢

32:49.610 --> 32:51.610
有几件事情要做

32:51.610 --> 32:52.610
首先看一下

32:52.610 --> 32:54.610
左边制服有效没

32:54.610 --> 32:55.610
有没有效

32:55.610 --> 32:56.610
好

32:56.610 --> 32:57.610
那么看一下

32:57.610 --> 32:58.610
判断一下

32:58.610 --> 32:59.610
左边那个制服

32:59.610 --> 33:00.610
是不是有效的

33:00.610 --> 33:01.610
我们这里得到

33:01.610 --> 33:02.610
左边那个制服吧

33:02.610 --> 33:03.610
或者直接判断吧

33:03.610 --> 33:04.610
得到吧

33:04.610 --> 33:05.610
得到左边那个制服

33:05.610 --> 33:06.610
left chart

33:06.610 --> 33:07.610
什么呢

33:07.610 --> 33:08.610
就是s left

33:08.610 --> 33:10.610
就得到左边的制服

33:11.610 --> 33:12.610
然后得到右边的制服

33:12.610 --> 33:13.610
都拿吧

33:13.610 --> 33:14.610
拿一下

33:14.610 --> 33:15.610
s right

33:16.610 --> 33:18.610
右边的制服

33:18.610 --> 33:19.610
好

33:19.610 --> 33:20.610
如果说

33:20.610 --> 33:21.610
左边的制服

33:21.610 --> 33:22.610
is valid

33:22.610 --> 33:23.610
是不是之前的辅助

33:23.610 --> 33:24.610
还说用啥

33:24.610 --> 33:25.610
看一下左边的制服

33:25.610 --> 33:26.610
是有效的

33:27.610 --> 33:28.610
如果说

33:28.610 --> 33:29.610
左边那个制服

33:29.610 --> 33:30.610
无效

33:31.610 --> 33:32.610
说明啥呀

33:32.610 --> 33:33.610
左边指向那个空格

33:33.610 --> 33:34.610
指向那个什么兜号

33:34.610 --> 33:35.610
这东西

33:35.610 --> 33:36.610
看都没法看的

33:36.610 --> 33:37.610
因此怎么办

33:37.610 --> 33:38.610
是不是得把它

33:38.610 --> 33:40.610
向右移动

33:40.610 --> 33:41.610
移动一位

33:41.610 --> 33:42.610
把左边的制服

33:42.610 --> 33:43.610
看下一个对吧

33:43.610 --> 33:44.610
next

33:44.610 --> 33:45.610
夹夹

33:46.610 --> 33:47.610
没问题吧

33:47.610 --> 33:48.610
这是这种情况啊

33:48.610 --> 33:49.610
那么话而言之

33:49.610 --> 33:50.610
如果说

33:50.610 --> 33:51.610
左边的制服有效

33:51.610 --> 33:52.610
右边的制服没效

33:52.610 --> 33:53.610
无效

33:53.610 --> 33:54.610
是一样的道理

33:54.610 --> 33:55.610
判断一下

33:55.610 --> 33:56.610
else if

33:56.610 --> 33:58.980
is valid

33:59.980 --> 34:00.980
right chart

34:01.980 --> 34:02.980
右边的制服

34:02.980 --> 34:03.980
是无效的

34:04.980 --> 34:05.980
那么这个时候呢

34:05.980 --> 34:06.980
我们要把

34:06.980 --> 34:07.980
右边的制服

34:07.980 --> 34:08.980
往左边移动

34:09.980 --> 34:10.980
right

34:11.980 --> 34:13.980
利用不同的思路

34:13.980 --> 34:14.980
代码是不一样的

34:14.980 --> 34:15.980
你像这里呢

34:15.980 --> 34:16.980
其实还有一些不同的思路

34:16.980 --> 34:17.980
就是说

34:17.980 --> 34:18.980
我这个移动

34:18.980 --> 34:19.980
左边的时候呢

34:19.980 --> 34:20.980
我一定要移动到

34:20.980 --> 34:21.980
不能移动为止

34:21.980 --> 34:22.980
如果说

34:22.980 --> 34:23.980
它有多个空格

34:23.980 --> 34:24.980
我要连续移动

34:24.980 --> 34:25.980
移动右边的时候呢

34:25.980 --> 34:26.980
我一定要移动到

34:26.980 --> 34:27.980
不能移动为止

34:27.980 --> 34:28.980
移动到这

34:28.980 --> 34:29.980
也可以

34:29.980 --> 34:30.980
它写出代码就又不一样了

34:30.980 --> 34:31.980
那么这里呢

34:31.980 --> 34:32.980
我们就移动一次

34:32.980 --> 34:33.980
因为移动一次过后

34:33.980 --> 34:34.980
又继续判断

34:34.980 --> 34:35.980
继续判断过后呢

34:35.980 --> 34:36.980
又继续往后整

34:36.980 --> 34:37.980
没问题吧

34:38.980 --> 34:39.980
好

34:39.980 --> 34:40.980
那么现在呢

34:40.980 --> 34:41.980
我们接着

34:41.980 --> 34:42.980
接着看

34:42.980 --> 34:43.980
接下来我们继续看啊

34:43.980 --> 34:45.980
两边的制服都有效

34:46.980 --> 34:48.980
两边的制服都有效

34:49.980 --> 34:50.980
那么这种情况下呢

34:50.980 --> 34:51.980
也要判断什么

34:51.980 --> 34:52.980
判断两个制服

34:52.980 --> 34:53.980
是不是一样的

34:53.980 --> 34:54.980
怎么判断

34:54.980 --> 34:55.980
判断

34:55.980 --> 34:56.980
要是一

34:57.980 --> 34:58.980
如果说

34:58.980 --> 34:59.980
两个制服不一样

34:59.980 --> 35:00.980
注意哦

35:00.980 --> 35:01.980
要区分

35:01.980 --> 35:02.980
不区分大小写

35:02.980 --> 35:03.980
所以说你把两个

35:03.980 --> 35:04.980
都转换成小写

35:04.980 --> 35:05.980
或者你这里

35:05.980 --> 35:06.980
这里转换也可以

35:06.980 --> 35:07.980
to lower case

35:09.980 --> 35:10.980
都转换小写

35:10.980 --> 35:11.980
那就不区分大小写了

35:13.980 --> 35:14.980
好

35:14.980 --> 35:15.980
那么就是left chop

35:15.980 --> 35:18.980
如果说不等于right chop

35:18.980 --> 35:23.190
如果说这种情况

35:23.190 --> 35:24.190
怎么办

35:24.190 --> 35:25.190
这种情况怎么办

35:25.190 --> 35:32.380
有人听不懂了吗

35:32.380 --> 35:33.380
那我们再过一下

35:33.380 --> 35:34.380
再过一下

35:35.380 --> 35:36.380
我的意思呢

35:36.380 --> 35:37.380
就是说

35:37.380 --> 35:38.380
整体的施动呢

35:38.380 --> 35:39.380
就是有两个指针

35:39.380 --> 35:40.380
一个指针呢

35:40.380 --> 35:41.380
在左边

35:41.380 --> 35:42.380
一个指针呢

35:42.380 --> 35:43.380
在右边

35:44.380 --> 35:45.380
那我挺担心

35:45.380 --> 35:46.380
明天的课呀

35:46.380 --> 35:47.380
我挺担心明天

35:47.380 --> 35:48.380
和后天

35:49.380 --> 35:50.380
今天的东西

35:50.380 --> 35:51.380
我已经是非常谨慎的

35:51.380 --> 35:52.380
出了题

35:54.380 --> 35:55.380
一个字没关系

35:55.380 --> 35:56.380
反正有路播的

35:56.380 --> 35:57.380
你们可能

35:57.380 --> 35:58.380
有些同学呢

35:58.380 --> 35:59.380
目前的代码量不够

35:59.380 --> 36:01.380
平时也没有怎么去写代码

36:01.380 --> 36:02.380
没有怎么去训练过

36:02.380 --> 36:04.380
只能可能遇到循环

36:04.380 --> 36:05.380
稍微代码过一点点

36:05.380 --> 36:06.380
可能一点受不了

36:07.380 --> 36:08.380
不过你将来

36:08.380 --> 36:10.380
肯定是要经过这个阶段的

36:10.380 --> 36:11.380
那么这个可能有路播

36:11.380 --> 36:12.380
你可以将来

36:12.380 --> 36:13.380
来看一下这个课

36:13.380 --> 36:15.880
也可以

36:15.880 --> 36:16.880
准备好两个指针

36:16.880 --> 36:17.880
一个指针能往右边移动

36:17.880 --> 36:18.880
一个指针往左边移动

36:18.880 --> 36:19.880
你看我们平时

36:19.880 --> 36:20.880
人来做这个操作

36:20.880 --> 36:21.880
不也是这样做吗

36:21.880 --> 36:22.880
对吧

36:22.880 --> 36:23.880
你眼睛一扫

36:23.880 --> 36:24.880
左边有空格

36:24.880 --> 36:25.880
往后边看

36:25.880 --> 36:26.880
这边有空格

36:26.880 --> 36:27.880
往后边看

36:27.880 --> 36:28.880
然后继续看

36:28.880 --> 36:29.880
左边没空格了

36:29.880 --> 36:30.880
这边还有空格

36:30.880 --> 36:31.880
还往这边看

36:31.880 --> 36:32.880
然后接下来

36:32.880 --> 36:33.880
两个都有效了

36:33.880 --> 36:34.880
然后再看一下一不一样

36:34.880 --> 36:36.880
不就是要做这些事吗

36:36.880 --> 36:37.880
你看

36:37.880 --> 36:38.880
左边的没东西

36:38.880 --> 36:40.880
左边的是无效的

36:40.880 --> 36:41.880
往后看

36:41.880 --> 36:43.880
右边的是无效的

36:43.880 --> 36:44.880
往后看

36:44.880 --> 36:45.880
让下一次循环

36:45.880 --> 36:47.880
再重新来做一次操作

36:47.880 --> 36:48.880
如果说这个判断没进

36:48.880 --> 36:49.880
这个判断没进

36:49.880 --> 36:51.880
是不是两边制服都一定是有效的

36:51.880 --> 36:52.880
有效的情况下

36:52.880 --> 36:54.880
看一下制服一不一样

36:54.880 --> 36:55.880
看这个制服

36:55.880 --> 36:56.880
跟这个制服是不一样的

36:56.880 --> 36:58.880
如果说不一样的话

36:58.880 --> 36:59.880
刚才说过了

36:59.880 --> 37:00.880
应该怎么样

37:00.880 --> 37:01.880
不一样的话

37:01.880 --> 37:03.880
是不是应该返回force

37:03.880 --> 37:06.830
对不对

37:06.830 --> 37:08.830
整个函数结束

37:08.830 --> 37:09.830
不用循环了

37:09.830 --> 37:10.830
你不用循环了

37:10.830 --> 37:11.830
你不用看了

37:11.830 --> 37:12.830
你也不用跑来跑去了

37:12.830 --> 37:13.830
肯定是

37:13.830 --> 37:15.830
肯定不是回关串

37:15.830 --> 37:16.830
好

37:17.830 --> 37:19.830
这里首先能返回处吗

37:19.830 --> 37:20.830
肯定是不行

37:20.830 --> 37:22.830
因为你还没有看完

37:22.830 --> 37:23.830
是不是回关串

37:23.830 --> 37:24.830
你还没有看完

37:24.830 --> 37:26.830
这里应该怎么样呢

37:26.830 --> 37:27.830
是不是应该

37:27.830 --> 37:30.830
这里应该干什么

37:30.830 --> 37:31.830
说过了

37:31.830 --> 37:37.420
这应该干嘛

37:37.420 --> 37:39.420
只有左边加加吗

37:39.420 --> 37:41.420
所以要两个一起来

37:41.420 --> 37:43.420
这边加加

37:43.420 --> 37:44.420
这边减减

37:44.420 --> 37:45.420
直接到下一个位置

37:45.420 --> 37:46.420
这个位置已经走过了

37:46.420 --> 37:47.420
对吧

37:47.420 --> 37:48.420
走过了

37:48.420 --> 37:49.420
这个指针

37:49.420 --> 37:51.420
它滑过的位置都是没问题的

37:51.420 --> 37:52.420
这个指针

37:52.420 --> 37:54.420
滑过的位置都是没问题的

37:54.420 --> 37:55.420
明儿那意思吧

37:55.420 --> 37:56.420
直到他们两个相遇

37:56.420 --> 37:57.420
相遇的话

37:57.420 --> 37:58.420
他们都是走完了

37:58.420 --> 37:59.420
你的路已经走完了

37:59.420 --> 38:00.420
我的路已经走完了

38:00.420 --> 38:01.420
都没问题的

38:01.420 --> 38:02.420
就没问题了

38:02.420 --> 38:03.420
好

38:03.420 --> 38:04.420
所以我们这里

38:04.420 --> 38:05.420
两个位置都没问题

38:05.420 --> 38:06.420
所以说

38:06.420 --> 38:07.420
Left加加

38:07.420 --> 38:08.420
Rise

38:08.420 --> 38:10.420
这个弹码就写完了

38:10.420 --> 38:13.420
就是回问上的验证

38:13.420 --> 38:14.420
我们来看一下

38:14.420 --> 38:16.420
下面有很多的测试弹码

38:16.420 --> 38:17.420
运行

38:18.420 --> 38:19.420
今天我们第一天

38:19.420 --> 38:20.420
尽量轻松一点

38:20.420 --> 38:21.420
第一个是去

38:21.420 --> 38:22.420
你可以

38:22.420 --> 38:23.420
就是我们刚才的例子

38:23.420 --> 38:24.420
没问题的

38:24.420 --> 38:25.420
去

38:25.420 --> 38:26.420
第二个是force

38:26.420 --> 38:27.420
第三个空之不错

38:27.420 --> 38:28.420
去

38:29.420 --> 38:30.420
只有一个空格

38:30.420 --> 38:31.420
也是去

38:31.420 --> 38:32.420
因为空格我们不看

38:32.420 --> 38:33.420
下面是e

38:33.420 --> 38:35.420
e它肯定是一个回问圈

38:35.420 --> 38:36.420
去

38:36.420 --> 38:37.420
下面是eA

38:37.420 --> 38:38.420
那肯定是force

38:38.420 --> 38:39.420
下面

38:39.420 --> 38:40.420
去去去force

38:40.420 --> 38:41.420
你们可以看一下

38:41.420 --> 38:42.420
去去去force

38:42.420 --> 38:44.420
去force

38:45.420 --> 38:46.420
这是回问圈的验证

38:46.420 --> 38:48.920
怎么样

38:48.920 --> 38:50.920
今天的东西还是比较简单

38:50.920 --> 38:51.920
时间还比较多

38:51.920 --> 38:54.920
我们可以再给大家出一道题

38:54.920 --> 38:55.920
出一道类似的

38:55.920 --> 38:56.920
也不要把问题

38:56.920 --> 38:57.920
搞得太复杂了

38:57.920 --> 38:58.920
出一道类似的

38:58.920 --> 39:01.420
什么题呢

39:01.420 --> 39:03.420
这其实也是一道面试题

39:04.420 --> 39:06.420
叫reverse

39:06.420 --> 39:07.420
非常简单

39:07.420 --> 39:08.420
我现在好像

39:08.420 --> 39:10.420
诚哥的GX课里面都讲过

39:10.420 --> 39:12.420
讲不讲过我忘了

39:12.420 --> 39:13.420
啥意思呢

39:13.420 --> 39:15.420
就是给了一个字无创

39:15.420 --> 39:16.420
有个函数

39:16.420 --> 39:18.420
reverse

39:19.420 --> 39:20.420
给了一个字无创

39:20.420 --> 39:23.860
你要把这个字无创的顺序颠倒

39:23.860 --> 39:24.860
返回一个新

39:26.860 --> 39:32.180
将该字无创的顺序

39:32.180 --> 39:33.180
好了

39:33.180 --> 39:34.180
数组

39:34.180 --> 39:35.180
给了一个数组

39:35.180 --> 39:37.180
reverse

39:37.180 --> 39:42.180
将该数组的顺序返转

39:42.180 --> 39:43.180
不是导序排序

39:43.180 --> 39:44.180
是返转

39:45.180 --> 39:50.340
那么怎么来做

39:50.340 --> 39:51.340
用什么

39:51.340 --> 39:52.340
肯定要用双子针

39:52.340 --> 39:53.340
用哪一种双子针

39:53.340 --> 39:56.620
随便提个数组

40:01.100 --> 40:02.100
把这个数组的

40:02.100 --> 40:03.100
所有的位置返转

40:05.100 --> 40:06.100
好像成了六个作业

40:06.100 --> 40:08.100
反正我有点这个印象

40:09.100 --> 40:10.100
顺便讲一下这个作业

40:11.100 --> 40:12.100
就用对撞

40:12.100 --> 40:14.100
一个子针指向第一个位置

40:14.100 --> 40:16.100
一个子针指向最后一个位置

40:16.100 --> 40:17.100
这里方大一点

40:18.100 --> 40:19.100
看不大

40:22.100 --> 40:23.100
等一下

40:24.100 --> 40:25.100
一个子针指向这

40:28.570 --> 40:29.570
一个子针指向这

40:30.570 --> 40:31.570
然后怎么样

40:31.570 --> 40:32.570
两个位置交换

40:34.570 --> 40:35.570
交换完了过后

40:35.570 --> 40:36.570
这里是不是变成了

40:37.570 --> 40:38.570
变成了一

40:38.570 --> 40:39.570
这里变成了三

40:39.570 --> 40:40.570
那么这个位置

40:40.570 --> 40:41.570
是不是已经交换了

40:41.570 --> 40:42.570
接下来要做的事情

40:42.570 --> 40:43.570
就是把这个子针往这边移动

40:44.570 --> 40:45.570
这个子针往这边移动

40:46.570 --> 40:47.570
然后又交换

40:47.570 --> 40:48.570
然后这个子针继续移动

40:49.570 --> 40:50.570
这个子针继续移动

40:50.570 --> 40:51.570
交换

40:51.570 --> 40:53.570
然后两个子针再移动

40:54.570 --> 40:55.570
把颜色变一下

40:56.570 --> 40:57.570
颜色变一下

41:01.940 --> 41:02.940
换个颜色

41:02.940 --> 41:10.540
还不是很用得熟

41:10.540 --> 41:12.540
如果说两个子针位置错过了

41:12.540 --> 41:13.540
是不是交换完成了

41:14.540 --> 41:17.540
或者是两个子针的位置相同了

41:17.540 --> 41:18.540
是不是交换完成

41:18.540 --> 41:19.540
对不对

41:19.540 --> 41:20.540
就非常简单

41:22.920 --> 41:23.920
因此

41:26.920 --> 41:27.920
时间复杂度

41:27.920 --> 41:29.920
没有用二分之一代表示

41:29.920 --> 41:31.920
你可以说时间是二分之一n

41:31.920 --> 41:32.920
可以

41:32.920 --> 41:33.920
但是时间复杂度

41:33.920 --> 41:34.920
没有二分之一n

41:34.920 --> 41:35.920
这种表示方式

41:35.920 --> 41:36.920
只有on

41:36.920 --> 41:37.920
因此复杂度

41:37.920 --> 41:40.920
它表示的是跟规模之间的关系

41:40.920 --> 41:42.920
问题规模之间的关系

41:42.920 --> 41:44.920
它并不表示缺缺的时间

41:48.230 --> 41:49.230
好

41:49.230 --> 41:50.230
那么这个问题

41:50.230 --> 41:51.230
其实我们有了思路过后

41:51.230 --> 41:52.230
我们就可以把它做完

41:53.230 --> 41:55.230
首先你需要一个辅助函数

41:55.230 --> 41:56.230
比方说我们要做什么

41:56.230 --> 41:57.230
交换对吧

41:57.230 --> 41:58.230
两个位置交换

41:58.230 --> 41:59.230
我们可以用一个辅助函数

41:59.230 --> 42:01.230
辅助函数

42:01.230 --> 42:02.230
交换

42:03.230 --> 42:05.230
你给我一个数组

42:05.230 --> 42:07.230
你给我一个i

42:07.230 --> 42:08.230
给我一个j

42:08.230 --> 42:09.230
啥意思呢

42:09.230 --> 42:11.230
我要把数组的这个位置

42:11.230 --> 42:12.230
和这个位置进行交换

42:12.230 --> 42:14.230
方便我们后边进行处理

42:14.230 --> 42:15.230
怎么交换

42:15.230 --> 42:16.230
交换单法非常简单

42:16.230 --> 42:17.230
这个没什么好说了吧

42:17.230 --> 42:19.230
是不是一个临时辨量

42:19.230 --> 42:21.230
没有任何难度

42:21.230 --> 42:23.230
临时辨量先保存一下

42:23.230 --> 42:25.230
然后把这个玩意提换成这个玩意

42:25.230 --> 42:27.230
然后再把这个玩意

42:28.230 --> 42:33.660
提换成这个玩意

42:33.660 --> 42:34.660
好

42:34.660 --> 42:35.660
这里有这么一个辅助函数

42:35.660 --> 42:37.660
可以交换一个数组

42:37.660 --> 42:38.660
一个数组的两个位置

42:38.660 --> 42:39.660
那么接下来

42:39.660 --> 42:40.660
这个函数

42:40.660 --> 42:41.660
这个函数怎么说呢

42:41.660 --> 42:43.660
如果说这个字幕是空的

42:43.660 --> 42:45.660
或者是不用去拍上这个东西了

42:45.660 --> 42:47.660
我们直接给一个辨量i

42:47.660 --> 42:48.660
就是左边

42:48.660 --> 42:49.660
左边的东西

42:49.660 --> 42:51.660
是不是指一开始指向0

42:51.660 --> 42:54.660
然后右边那个指针的指向

42:54.660 --> 43:01.740
长度减1

43:01.740 --> 43:03.740
这里顺便说一个小技巧

43:03.740 --> 43:04.740
就是你写函数的时候

43:04.740 --> 43:07.740
你可能这里边没有智能提示

43:07.740 --> 43:08.740
你看这里我想点那个是点不出来

43:08.740 --> 43:09.740
为什么点不出来呢

43:09.740 --> 43:10.740
因为vscode

43:10.740 --> 43:11.740
他也不知道这个函数的参数

43:11.740 --> 43:12.740
是什么类型

43:12.740 --> 43:13.740
也不是说你写了一个AR

43:13.740 --> 43:15.740
他就是一个数组了

43:15.740 --> 43:17.740
他不知道什么类型

43:17.740 --> 43:18.740
因此他就不知道

43:18.740 --> 43:20.740
这个玩意是一个数组

43:20.740 --> 43:21.740
他就不知道是数组了

43:21.740 --> 43:22.740
他就不知道这里边有个数

43:22.740 --> 43:23.740
新叫dance

43:23.740 --> 43:26.740
那怎么样让vscode知道他是数组呢

43:26.740 --> 43:27.740
有两种办法

43:27.740 --> 43:29.740
一种是你们将来会学习一个语言

43:29.740 --> 43:30.740
叫tapscript

43:30.740 --> 43:31.740
非常好

43:31.740 --> 43:32.740
大家可以知道

43:32.740 --> 43:33.740
那你学了他过后

43:33.740 --> 43:35.740
他自然就而然就有智能提示了

43:35.740 --> 43:36.740
但是现在这个东西

43:36.740 --> 43:37.740
离你们还比较远

43:37.740 --> 43:39.740
那是你们后期

43:39.740 --> 43:40.740
比较后期的事情

43:40.740 --> 43:42.740
比较后期的课程

43:42.740 --> 43:44.740
还有一种非常简单的方式

43:44.740 --> 43:46.740
就是你给他打一个注释

43:46.740 --> 43:48.740
也这里给他标注一下

43:48.740 --> 43:49.740
他的类型

43:49.740 --> 43:50.740
类型是什么

43:50.740 --> 43:51.740
是一个array

43:51.740 --> 43:52.740
于是vscode的

43:52.740 --> 43:53.740
是不是就知道了

43:53.740 --> 43:54.740
这个参数是一个array

43:54.740 --> 43:55.740
因此你看一下

43:55.740 --> 43:56.740
点dance

43:56.740 --> 43:57.740
他也知道他是一个数组

43:57.740 --> 43:58.740
这个小的技巧

43:58.740 --> 44:00.740
简易

44:02.740 --> 44:03.740
于是我们现在定了

44:03.740 --> 44:05.740
两个指针段

44:05.740 --> 44:06.740
一个指向第1个

44:06.740 --> 44:07.740
一个指向最后一个

44:07.740 --> 44:08.740
现在要干嘛

44:08.740 --> 44:12.760
跟刚才的做法是差不多

44:12.760 --> 44:13.760
注释怎么打出来的

44:13.760 --> 44:14.760
有一个写钢

44:14.760 --> 44:15.760
两个型号一回车

44:15.760 --> 44:16.760
他就出来了

44:16.760 --> 44:19.760
vscode他远程就支持的

44:19.760 --> 44:20.760
哇哦

44:20.760 --> 44:21.760
接下来循环

44:21.760 --> 44:22.760
什么情况下

44:22.760 --> 44:23.760
我们要进行循环

44:23.760 --> 44:25.760
是不是跟那个条件一样

44:25.760 --> 44:27.760
左边小鱼

44:27.760 --> 44:28.760
右边的情况下

44:28.760 --> 44:29.760
是不是这种情况

44:29.760 --> 44:31.760
我们要进行循环

44:31.760 --> 44:32.760
循环的时候干嘛呀

44:32.760 --> 44:35.760
我们就做一件事

44:35.760 --> 44:36.760
什么事

44:36.760 --> 44:37.760
就把这个位置

44:37.760 --> 44:39.760
跟这个位置进行交换

44:39.760 --> 44:43.710
swap

44:43.710 --> 44:44.710
array

44:45.710 --> 44:47.710
交换

44:48.710 --> 44:49.710
交换完了过后

44:49.710 --> 44:50.710
还要做什么

44:50.710 --> 44:52.710
还要swap加加

44:52.710 --> 44:53.710
array

44:55.710 --> 44:56.710
两个指针

44:56.710 --> 44:57.710
左边往后边移动

44:57.710 --> 44:59.710
右边往左边移动

44:59.710 --> 45:01.710
下一个位置你交换

45:01.710 --> 45:02.710
直到什么情况下

45:02.710 --> 45:04.710
直到两个指针相遇了

45:04.710 --> 45:05.710
或者是两个指针错过了

45:05.710 --> 45:06.710
全部交换完了

45:06.710 --> 45:07.710
全部交换完了

45:07.710 --> 45:08.710
那就完了

45:08.710 --> 45:09.710
就完了就没了

45:09.710 --> 45:10.710
我们来看一下吧

45:10.710 --> 45:11.710
我们来看一下吧

45:12.710 --> 45:13.710
不要忘了这里

45:13.710 --> 45:14.710
我们定义到数据

45:15.710 --> 45:21.970
随便来一个吧

45:21.970 --> 45:23.970
然后我们使用

45:23.970 --> 45:25.970
就是b4

45:25.970 --> 45:27.970
reverse

45:27.970 --> 45:28.970
交换前

45:28.970 --> 45:30.970
然后我们进行交换

45:30.970 --> 45:31.970
reverse

45:31.970 --> 45:32.970
arr

45:32.970 --> 45:36.410
这个不一定的

45:36.410 --> 45:38.410
你要写成 FOR 循环也可以呀

45:38.410 --> 45:40.410
循环之间是可以相互转换的

45:40.410 --> 45:42.410
你要写成 FOR 循环我就给你写的

45:42.410 --> 45:46.100
写成 FOR 循环

45:46.100 --> 45:47.100
你写成 FOR 循环吗

45:47.100 --> 45:49.100
如果说你喜欢 FOR 循环的话

45:49.100 --> 45:52.420
这是循环的第一段对吧

45:52.420 --> 45:53.420
循环的第一段

45:53.420 --> 45:55.420
循环的第二段

45:55.420 --> 45:59.050
循环的第三段

45:59.050 --> 46:02.870
这里有个扩号吧

46:02.870 --> 46:04.870
这里有两条语句

46:04.870 --> 46:06.870
用扩号

46:06.870 --> 46:08.870
Rise 加加

46:09.870 --> 46:11.870
看的也可以啊

46:11.870 --> 46:12.870
剪剪啊

46:12.870 --> 46:14.870
Left 加加

46:14.870 --> 46:17.310
Rise 剪剪

46:17.310 --> 46:18.310
这能看懂吗

46:18.310 --> 46:19.310
这个 FOR 循环

46:19.310 --> 46:20.310
可能这东西吧

46:21.310 --> 46:22.310
道理是一样的

46:22.310 --> 46:24.310
就是你第一段只执行一次

46:24.310 --> 46:26.310
一开始执行一次

46:26.310 --> 46:28.310
然后中间是一条循环条件

46:28.310 --> 46:31.310
右边是每次循环之后要做的事情

46:31.310 --> 46:33.310
都要是一样的道理

46:33.310 --> 46:34.310
是一样的

46:34.310 --> 46:35.310
好 我们来看一下吧

46:35.310 --> 46:36.310
交换之后

46:36.310 --> 46:39.310
我们输出 After Reverse

46:39.310 --> 46:44.670
你看交换之后

46:44.670 --> 46:45.670
什么交换了

46:46.670 --> 46:47.670
翻转了对吧

46:47.670 --> 46:48.670
就翻转了

46:48.670 --> 46:50.670
5121863

46:50.670 --> 46:52.670
OK 这是这道题

46:58.000 --> 46:59.000
就是你们大家不用去在意

46:59.000 --> 47:01.000
这种具体的代码

47:01.000 --> 47:02.000
我这里订了个变量

47:02.000 --> 47:03.000
这个变量的名字是啥

47:03.000 --> 47:04.000
我们用的是拨循环

47:04.000 --> 47:05.000
还是坏了循环

47:05.000 --> 47:06.000
这些不重要

47:06.000 --> 47:07.000
重要的是这个思路

47:07.000 --> 47:09.000
因为一个思路

47:09.000 --> 47:11.000
其实思路就有很多

47:11.000 --> 47:12.000
然后呢

47:12.000 --> 47:14.000
每一种思路可以转换成不同的代码

47:14.000 --> 47:16.000
看下去怎么去写都可以

47:16.000 --> 47:19.000
好 那么这是今天咱们讲的内容

47:19.000 --> 47:20.000
还是比较简单

47:20.000 --> 47:21.000
然后呢

47:21.000 --> 47:23.000
为了给后边的

47:23.000 --> 47:24.000
给后边的

47:24.000 --> 47:25.000
就是后边两天东西

47:25.000 --> 47:26.000
可能有点复杂

47:26.000 --> 47:28.000
为了给大家打下个基础

47:28.000 --> 47:30.000
我们这里面就扩展一点

47:30.000 --> 47:31.000
一个知识

47:31.000 --> 47:32.000
有一些人知道

47:32.000 --> 47:33.000
有一些人不知道

47:33.000 --> 47:34.000
我这里说一下叫地规

47:34.000 --> 47:38.460
这个也可以

47:39.460 --> 47:40.460
效率是一样的

47:40.460 --> 47:42.460
有一点地点区别都没有

47:42.460 --> 47:43.460
你把这个玩意儿写外面

47:44.460 --> 47:45.460
你把这个玩意儿写外面

47:45.460 --> 47:47.460
因为它只执行一次

47:47.460 --> 47:50.970
这个玩意儿只执行一次

47:50.970 --> 47:51.970
这里也是执行一次

47:51.970 --> 47:52.970
在这里也是执行一次

47:52.970 --> 47:53.970
有啥区别呢

47:53.970 --> 47:54.970
没有什么区别

47:57.410 --> 47:58.410
好 这里说一下地规

47:58.410 --> 47:59.410
因为我们后边两天

47:59.410 --> 48:00.410
有可能会用的

48:01.410 --> 48:03.410
然后再补充一个

48:03.410 --> 48:04.410
叫模板自补串

48:04.410 --> 48:06.410
后边两个都有可能会用的

48:06.410 --> 48:09.850
自补串

48:09.850 --> 48:10.850
好 首先说地规

48:10.850 --> 48:11.850
地规什么意思呢

48:11.850 --> 48:14.850
地规表示一个函数

48:14.850 --> 48:17.850
在运行的过程中

48:17.850 --> 48:21.850
直接或间接的

48:21.850 --> 48:22.850
调用自己

48:22.850 --> 48:25.290
看一下第二题吗

48:25.290 --> 48:26.290
第二题的代码

48:26.290 --> 48:27.290
一会儿就可以

48:27.290 --> 48:28.290
大家发下来的

48:29.290 --> 48:30.290
第二题

48:30.290 --> 48:31.290
以后看行吗

48:31.290 --> 48:33.290
我先把这个地规讲一下

48:34.290 --> 48:38.140
啥意思呢

48:38.140 --> 48:40.140
有个经典的案例

48:40.140 --> 48:41.140
叫做非波拉器树林

48:42.140 --> 48:43.140
不然的话

48:43.140 --> 48:44.140
明后两天讲一下

48:44.140 --> 48:45.140
我特别吃力

48:45.140 --> 48:46.140
非波拉器树林

48:46.140 --> 48:47.140
明天不一定会遇到

48:47.140 --> 48:48.140
后天一定会遇到

48:49.140 --> 48:50.140
怎么叫非波拉器树林

48:50.140 --> 48:51.140
是这么一种树林

48:51.140 --> 48:53.140
它非常适合用地规来解决

48:53.140 --> 48:54.140
就是第1个数字

48:54.140 --> 48:57.140
和第2个数字都为1

48:58.140 --> 49:00.140
然后第3个数字开始

49:00.140 --> 49:02.140
是浅量位置合

49:02.140 --> 49:05.140
第3位就是1加1

49:05.140 --> 49:06.140
第4位就是1加2

49:08.510 --> 49:11.510
第5位就是2加3

49:11.510 --> 49:14.510
1 4 4 8 13 21

49:14.510 --> 49:15.510
懂了意思吗

49:15.510 --> 49:16.510
不好意思

49:16.510 --> 49:18.510
那么这个非波拉器

49:18.510 --> 49:19.510
就写了无数诗篇了

49:19.510 --> 49:20.510
它是讲了地规的一个

49:20.510 --> 49:21.510
非常经典的案例

49:21.510 --> 49:22.510
非常容易讲地规

49:22.510 --> 49:23.510
因为它本身并不复杂

49:23.510 --> 49:25.510
现在希望有一个函数

49:26.510 --> 49:27.510
其实编程

49:28.510 --> 49:30.510
它要的不是数学本身

49:30.510 --> 49:32.510
要的是数学思维

49:33.510 --> 49:35.510
或者要程序思维

49:35.510 --> 49:36.510
因为程序思维

49:37.510 --> 49:39.510
也不说完全一样吧

49:39.510 --> 49:40.510
比较类似

49:40.510 --> 49:42.510
它不需要你有很深的数学知识

49:42.510 --> 49:44.510
你不需要去会什么举证

49:44.510 --> 49:46.510
不需要去什么集合

49:46.510 --> 49:47.510
这些东西

49:47.510 --> 49:48.510
不太会需要

49:48.510 --> 49:49.510
除非你去开发

49:49.510 --> 49:51.510
除非你去进入了一些

49:51.510 --> 49:52.510
比较特殊的工种

49:52.510 --> 49:54.510
否则的话不太需要这些东西

49:55.510 --> 49:57.510
平时业务逻辑处理的话

49:57.510 --> 49:59.510
普通数学的试则运算就够了

49:59.510 --> 50:00.510
但它特别需要这种

50:00.510 --> 50:01.510
思维能力

50:01.510 --> 50:03.510
因此很多数学学的

50:03.510 --> 50:05.510
好的同学来学开发的话

50:05.510 --> 50:07.510
它一开始就学得非常快

50:07.510 --> 50:08.510
但是如果说你数学不好的话

50:08.510 --> 50:09.510
你学开发

50:09.510 --> 50:10.510
可能一开始会慢

50:10.510 --> 50:12.510
但最终还是会补起来的

50:12.510 --> 50:13.510
你不能说你完全不能学

50:13.510 --> 50:15.510
其实我数学就不得不好

50:15.510 --> 50:17.510
我看大学里面的那些

50:17.510 --> 50:19.510
高等大师都忘了差不多了

50:19.510 --> 50:23.400
我还不是活下来了

50:23.400 --> 50:25.400
还不是在写代版写这么多年的

50:25.400 --> 50:26.400
还不然能写

50:26.400 --> 50:27.400
而且作为一些复杂问题的时候

50:27.400 --> 50:28.400
我还是能做

50:29.400 --> 50:30.400
它不太会需要

50:30.400 --> 50:32.400
对它高等的数学知识

50:33.400 --> 50:34.400
但它特别需要这种思维

50:34.400 --> 50:36.400
现在我们需要一个函数

50:36.400 --> 50:37.400
这个函数的名字呢

50:37.400 --> 50:38.400
就该取个

50:39.400 --> 50:40.400
F吧

50:40.400 --> 50:44.990
这个函数要做什么事情

50:45.990 --> 50:46.990
就是说

50:47.990 --> 50:48.990
这是一个囊本

50:49.990 --> 50:50.990
计算

50:50.990 --> 50:51.990
非柏拉气

50:51.990 --> 50:52.990
数列

50:52.990 --> 50:53.990
D

50:53.990 --> 50:54.990
N位的值

50:57.560 --> 50:59.560
当这件事有很弄做法

50:59.560 --> 51:01.560
你可以写个循环

51:02.560 --> 51:03.560
是不是可以写循环来做

51:03.560 --> 51:04.560
以后我们可以写个循环来做

51:04.560 --> 51:06.560
但是这里我们不想用循环来做

51:07.560 --> 51:09.560
我想用一种非常特别的方式

51:09.560 --> 51:12.560
就是先用一个公式去推倒它

51:13.560 --> 51:14.560
什么公式呢

51:14.560 --> 51:15.560
你会发现

51:15.560 --> 51:17.560
非柏拉气数列有这么一个特点

51:17.560 --> 51:19.560
如果说一个F函数

51:20.560 --> 51:21.560
里边的数字呢

51:21.560 --> 51:23.560
表示的是非柏拉气数列的第几位

51:23.560 --> 51:24.560
比方说F1

51:24.560 --> 51:26.560
就表示非柏拉气数列的第一位

51:26.560 --> 51:28.560
那么我们就可以得到这么一个特点

51:28.560 --> 51:31.560
F1等于F2等于1

51:37.070 --> 51:38.070
对吧

51:38.070 --> 51:39.070
是不是这样子

51:39.070 --> 51:41.070
第一位和第二位的值

51:42.070 --> 51:43.070
都是1

51:43.070 --> 51:44.070
好

51:44.070 --> 51:45.070
那么如果说N

51:45.070 --> 51:47.070
如果说里边不是1和不是2

51:47.070 --> 51:49.070
那么就是Fn

51:49.070 --> 51:51.070
那么它的值呢

51:51.070 --> 51:54.070
就等于Fn-1

51:54.070 --> 51:56.070
加上Fn-2

51:56.070 --> 51:58.070
前两位之合吗

51:58.070 --> 51:59.070
是不是这个道理

52:00.070 --> 52:02.070
你不用去想编程

52:02.070 --> 52:04.070
你就算没有学过编程

52:04.070 --> 52:05.070
这个东西是不是也能理解

52:06.070 --> 52:07.070
你不用去写

52:07.070 --> 52:09.070
不用有什么很复杂的数学知识

52:09.070 --> 52:11.070
你只要知道数学函数

52:11.070 --> 52:13.070
就能理解这个东西

52:13.070 --> 52:14.070
非常自然的

52:14.070 --> 52:16.070
你不需要回编程

52:16.070 --> 52:18.070
而且你会发现

52:18.070 --> 52:20.070
就这两个式子

52:20.070 --> 52:22.070
式子1

52:22.070 --> 52:24.070
这两个式子

52:24.070 --> 52:25.070
是不是就已经表述完了

52:25.070 --> 52:27.070
整个问题的所有需求

52:27.070 --> 52:29.070
所有情况是不是全部涵盖完了

52:29.070 --> 52:31.070
没有其他情况了吧

52:31.070 --> 52:32.070
没有任何其他情况了吧

52:32.070 --> 52:34.070
全部涵盖完了

52:34.070 --> 52:36.070
只要你能够用式子

52:36.070 --> 52:37.070
把这个东西表示出来

52:37.070 --> 52:39.070
而且你会发现

52:39.070 --> 52:41.070
你又能够涵盖所有情况

52:41.070 --> 52:42.070
那么这个问题

52:42.070 --> 52:44.070
就特别适合用帝规

52:44.070 --> 52:45.070
那么帝规怎么写

52:45.070 --> 52:47.070
你就安不就把它写出来

52:47.070 --> 52:49.070
怎么写呢

52:49.070 --> 52:51.070
如果说你这个数字

52:51.070 --> 52:53.070
传怪的N这个数字

52:53.070 --> 52:55.070
是1

52:55.070 --> 52:57.070
或者是

52:57.070 --> 52:58.070
等于2

52:58.070 --> 52:59.070
或者是2

52:59.070 --> 53:00.070
那么我就反过1

53:00.070 --> 53:02.070
是不是得到1吗

53:02.070 --> 53:03.070
N等于1

53:03.070 --> 53:04.070
N等于2

53:04.070 --> 53:06.070
那么这个函数的结果就是1

53:06.070 --> 53:07.070
否则的话

53:07.070 --> 53:08.070
这个函数的结果

53:08.070 --> 53:10.070
我就应该是FN-1

53:10.070 --> 53:12.070
加上FN-2

53:12.070 --> 53:15.830
就可以了

53:15.830 --> 53:16.830
好 咱们输出一下

53:16.830 --> 53:19.830
F1

53:19.830 --> 53:20.830
F2

53:20.830 --> 53:21.830
3

53:21.830 --> 53:22.830
4

53:22.830 --> 53:23.830
5

53:23.830 --> 53:24.830
6

53:24.830 --> 53:25.830
7

53:25.830 --> 53:27.830
好 冰球

53:27.830 --> 53:28.830
你看

53:28.830 --> 53:29.830
1123

53:29.830 --> 53:30.830
813

53:30.830 --> 53:31.830
对吧

53:31.830 --> 53:32.830
好 那么

53:32.830 --> 53:33.830
刷出来是没问题的

53:33.830 --> 53:34.830
但是总感觉

53:34.830 --> 53:35.830
有些人可能总感觉

53:35.830 --> 53:36.830
有点怪怪的

53:36.830 --> 53:37.830
因为地规这个东西

53:37.830 --> 53:39.830
就感觉很不好理解

53:39.830 --> 53:40.830
这个函数本身

53:40.830 --> 53:43.830
它为什么能够自己调用自己呢

53:43.830 --> 53:44.830
那么这一块

53:44.830 --> 53:46.830
你需要知道那个

53:46.830 --> 53:47.830
执行站的知识

53:47.830 --> 53:49.830
那么这里我尽量的

53:49.830 --> 53:50.830
给你解释一下

53:50.830 --> 53:51.830
它是怎么去调用的

53:51.830 --> 53:54.830
我以F4为例

53:54.830 --> 53:56.830
或者是以F5为例

53:56.830 --> 54:00.210
我看一下它怎么调用的

54:00.210 --> 54:03.290
我这里给它画张图

54:03.290 --> 54:05.290
它的调用方式是这样子的

54:05.290 --> 54:10.010
首先它要算这个函数

54:10.010 --> 54:14.730
F5

54:14.730 --> 54:15.730
算这个F5的时候

54:15.730 --> 54:16.730
它进不了这个判断

54:16.730 --> 54:17.730
对吧

54:17.730 --> 54:18.730
N等于5

54:18.730 --> 54:19.730
它进不了这个判断

54:19.730 --> 54:20.730
余生的它要算什么

54:20.730 --> 54:22.730
它就要算这个Fn-1

54:22.730 --> 54:24.730
加上Fn-2

54:24.730 --> 54:25.730
是不是要算两个

54:25.730 --> 54:27.730
它要算什么

54:27.730 --> 54:28.730
它要算

54:32.040 --> 54:33.040
点出来

54:34.040 --> 54:35.040
等一下

54:35.040 --> 54:36.040
拥有了

54:36.040 --> 54:37.040
不是手啊

54:37.040 --> 54:38.040
这个玩意

54:38.040 --> 54:43.100
稍等一下

54:43.100 --> 54:45.100
我这个画图的

54:45.100 --> 54:46.100
又出问题了

54:46.100 --> 54:52.830
再来

54:52.830 --> 54:54.830
这里是

54:54.830 --> 54:58.140
F5

54:58.140 --> 55:00.140
然后它会算成两个

55:00.140 --> 55:02.140
一个是

55:02.140 --> 55:03.140
我就这样写吧

55:03.140 --> 55:04.140
F4

55:04.140 --> 55:06.140
一个是F3

55:06.140 --> 55:07.140
是不是

55:07.140 --> 55:09.140
F5它会分解成要算

55:09.140 --> 55:10.140
它要算出F5

55:10.140 --> 55:11.140
它就必须要运算这个表达式

55:11.140 --> 55:13.140
这个表达式是要重新调用函数

55:13.140 --> 55:15.140
传进去一个什么5-1

55:15.140 --> 55:16.140
等于4

55:16.140 --> 55:17.140
传一个4进去

55:17.140 --> 55:18.140
还要算什么

55:18.140 --> 55:19.140
还要算F3

55:19.140 --> 55:20.140
那么这个表达式

55:20.140 --> 55:22.140
会从左到右进行运算

55:22.140 --> 55:24.140
它会先算这个

55:24.140 --> 55:25.140
它会

55:25.140 --> 55:27.140
它会先算这个

55:27.140 --> 55:29.140
然后再算这个

55:29.140 --> 55:31.140
那么现在目前它是先算这个

55:31.140 --> 55:33.140
也是不是算F10

55:33.140 --> 55:35.140
于是现在F5和函数调用

55:35.140 --> 55:36.140
是不是卡在这了

55:36.140 --> 55:37.140
它没有运行完

55:37.140 --> 55:39.140
它要等F4算出来

55:39.140 --> 55:41.140
于是要重新调用函数

55:41.140 --> 55:42.140
注意哦

55:42.140 --> 55:43.140
它这里重新调用

55:43.140 --> 55:45.140
相当于是开了一块新的空间

55:45.140 --> 55:46.140
去重新调用

55:46.140 --> 55:47.140
它不会影响之前的调用的

55:47.140 --> 55:49.140
于是它现在又去算什么

55:49.140 --> 55:51.140
又去算F3

55:51.140 --> 55:54.290
F3

55:54.290 --> 55:56.290
和F2

55:57.290 --> 56:01.370
F2

56:01.370 --> 56:02.370
F4现在分解成了

56:02.370 --> 56:04.370
F3和F2

56:04.370 --> 56:05.370
那么要算F3

56:05.370 --> 56:06.370
它又去分解成为了

56:06.370 --> 56:07.370
F2

56:07.370 --> 56:09.370
F2是不是就直接出结果了

56:09.370 --> 56:10.370
因为N等于2

56:10.370 --> 56:11.370
那么是不是直接出结果了

56:11.370 --> 56:12.370
就是等于1

56:12.370 --> 56:15.370
F2就是1

56:15.370 --> 56:16.370
加上

56:16.370 --> 56:17.370
F3是不是等于F2

56:17.370 --> 56:19.370
加上F1

56:19.370 --> 56:20.370
那么这样子

56:20.370 --> 56:22.370
写下不好看

56:22.370 --> 56:24.370
还是这样的写吧

56:24.370 --> 56:26.370
写到这还好一点

56:27.370 --> 56:28.370
要算F5

56:28.370 --> 56:32.370
那么它要算F4加上F3

56:32.370 --> 56:34.370
要算F4

56:34.370 --> 56:35.370
现在要算F4

56:35.370 --> 56:38.370
那么它要算F3加上F2

56:38.370 --> 56:40.370
现在要算F3

56:40.370 --> 56:43.370
它要算F2加上F1

56:43.370 --> 56:44.370
F2的值是多少

56:44.370 --> 56:45.370
直接就是1

56:45.370 --> 56:46.370
因为N等于2的时候

56:46.370 --> 56:47.370
就直接是1

56:47.370 --> 56:48.370
F1就直接是1

56:48.370 --> 56:49.370
1加1等于2

56:49.370 --> 56:51.370
于是F3就算出来了

56:51.370 --> 56:52.370
是不是等于2

56:52.370 --> 56:53.370
好 接下来算F2

56:53.370 --> 56:54.370
因为F2算出来过后

56:54.370 --> 56:56.370
1加才能知道F4的结果

56:56.370 --> 56:58.370
所以说要算这个F2

56:58.370 --> 56:59.370
F2的时候

56:59.370 --> 57:00.370
F2它的值本身就是1

57:00.370 --> 57:02.370
N等于2的时候等于1

57:02.370 --> 57:03.370
所以说这个结果就是3

57:03.370 --> 57:05.370
因此F4的结果就出来了

57:05.370 --> 57:07.370
然后再算这个F3

57:07.370 --> 57:09.370
F3的结果算法是一样的

57:09.370 --> 57:11.370
F2加上F1

57:11.370 --> 57:13.370
那么这样的结果

57:13.370 --> 57:15.370
它是1

57:15.370 --> 57:17.370
它是2

57:17.370 --> 57:19.370
于是结果结果就是5

57:19.370 --> 57:22.370
就这么样做的

57:25.260 --> 57:28.260
为地规优化可以

57:28.260 --> 57:30.260
但是我跟大家说一下

57:30.260 --> 57:32.260
若为调用优化

57:32.260 --> 57:35.260
在科朗浏览区是不存在的

57:37.260 --> 57:39.260
在现代浏览区里面是不存在的

57:39.260 --> 57:40.260
有一篇文章

57:40.260 --> 57:42.260
我具体的忘了

57:42.260 --> 57:44.260
是科朗当时的一个开发者写的

57:44.260 --> 57:45.260
他告诉你

57:45.260 --> 57:46.260
他为什么浏览区里面

57:46.260 --> 57:48.260
他没有办法进行优化

57:48.260 --> 57:50.260
当然你可以

57:50.260 --> 57:52.260
不过还有一件事情要跟你说的

57:52.260 --> 57:54.260
就是伪地规优化的话

57:54.260 --> 57:56.260
它可能会把代码变得很难看

57:56.260 --> 57:58.260
会变得很难看

57:58.260 --> 58:01.260
什么情况下要进行伪地规优化

58:01.260 --> 58:04.260
如果说你不知道伪地规优化是啥的话

58:04.260 --> 58:06.260
你可以去百度查一下

58:06.260 --> 58:07.260
我就跟那个同学说一下

58:07.260 --> 58:09.260
什么情况下要进行伪地规优化

58:09.260 --> 58:12.260
就它的地规的成绩是不可控的

58:12.260 --> 58:14.260
无法控制的地规成绩

58:14.260 --> 58:16.260
那么就可以进行伪地规优化

58:16.260 --> 58:18.260
实际上这道题

58:18.260 --> 58:20.260
是应该进行伪地规优化的

58:20.260 --> 58:22.260
甚至不应该使用地规

58:22.260 --> 58:23.260
只不过

58:23.260 --> 58:24.260
因为这道题

58:24.260 --> 58:25.260
讲地规太合适了

58:25.260 --> 58:27.260
所以说我用这种方式来做

58:27.260 --> 58:28.260
比较好理解而已

58:28.260 --> 58:32.630
因为这个地规的成绩就很难控制的

58:32.630 --> 58:35.630
你不知道它耗我多深

58:35.630 --> 58:37.630
那么这就是这种做法

58:37.630 --> 58:38.630
自己雕用自己

58:38.630 --> 58:39.630
我们后面两天

58:39.630 --> 58:40.630
会用这种做法来解决

58:40.630 --> 58:42.630
比较麻烦的问题

58:42.630 --> 58:43.630
这是这个地方

58:43.630 --> 58:44.630
那么这道题

58:44.630 --> 58:45.630
我刚才说了

58:45.630 --> 58:46.630
它也可以用循环来做

58:46.630 --> 58:48.630
用循环又怎么来做呢

58:48.630 --> 58:50.630
循环怎么来做呢

58:50.630 --> 58:54.630
循环这里就可以使用双指针

58:54.630 --> 58:55.630
就是一个指向

58:55.630 --> 58:56.630
第一个位置

58:56.630 --> 58:57.630
就是前一位

58:57.630 --> 58:59.630
一个指向前两位

58:59.630 --> 59:01.630
所以说我们这里先判断

59:01.630 --> 59:03.630
n是不是等于1

59:03.630 --> 59:04.630
或者是n等于2

59:04.630 --> 59:06.630
先把这种情况看一下

59:06.630 --> 59:07.630
这种情况没问题的话

59:07.630 --> 59:08.630
就直接返回1

59:08.630 --> 59:09.630
好了

59:09.630 --> 59:10.630
那么现在接下来

59:10.630 --> 59:11.630
就是n等于

59:11.630 --> 59:13.630
n大于等于2的情况

59:13.630 --> 59:14.630
大于2的情况

59:14.630 --> 59:15.630
就从第三位开始

59:15.630 --> 59:16.630
第三位开始的话

59:16.630 --> 59:18.630
我们就先这样子

59:18.630 --> 59:23.630
上一个位置

59:23.630 --> 59:24.630
是不是1

59:24.630 --> 59:30.160
n上一个位置

59:30.160 --> 59:32.160
那是2嘛

59:32.160 --> 59:33.160
是不是还是1

59:33.160 --> 59:34.160
那是1

59:34.160 --> 59:36.160
上一个位置是1

59:36.160 --> 59:37.160
那是2

59:37.160 --> 59:38.160
是不是还是1

59:38.160 --> 59:42.160
就是我用两个箭头

59:42.160 --> 59:43.160
一个指向这

59:43.160 --> 59:44.160
一个指向这

59:44.160 --> 59:46.160
来算这个位置

59:46.160 --> 59:47.160
对不对

59:47.160 --> 59:48.160
好

59:48.160 --> 59:49.160
那么我们接下来

59:49.160 --> 59:50.160
就开始来算

59:50.160 --> 59:51.160
我们定一个边量

59:51.160 --> 59:53.160
因为我不知道n的值是多少

59:53.160 --> 59:55.160
比较n的值可能是在这

59:55.160 --> 59:56.160
1 2 3 4 5 6

59:56.160 --> 59:57.160
n的值等于6

59:57.160 --> 59:58.160
才定6位

59:58.160 --> 59:59.160
所以说我们从第三位

59:59.160 --> 01:00:00.160
开始进行算

01:00:00.160 --> 01:00:01.160
对吧

01:00:01.160 --> 01:00:02.160
好

01:00:02.160 --> 01:00:03.160
因此我们判断

01:00:03.160 --> 01:00:04.160
定一个i

01:00:04.160 --> 01:00:05.160
等于是多少呢

01:00:05.160 --> 01:00:08.160
等于

01:00:08.160 --> 01:00:10.160
从第三位开始算

01:00:10.160 --> 01:00:15.160
从第三位开始计算

01:00:15.160 --> 01:00:17.660
好

01:00:17.660 --> 01:00:18.660
判断一下

01:00:18.660 --> 01:00:19.660
进行循环

01:00:19.660 --> 01:00:20.660
因为n要不断的往

01:00:20.660 --> 01:00:21.660
后移动

01:00:21.660 --> 01:00:22.660
对吧

01:00:22.660 --> 01:00:23.660
i要不断的往

01:00:23.660 --> 01:00:24.660
后移动

01:00:24.660 --> 01:00:25.660
移动到这个n的位置

01:00:25.660 --> 01:00:26.660
好

01:00:26.660 --> 01:00:27.660
因此我们判断一下

01:00:27.660 --> 01:00:29.660
i如果说小鱼

01:00:29.660 --> 01:00:34.660
等于n

01:00:34.660 --> 01:00:38.660
小鱼n

01:00:38.660 --> 01:00:39.660
对了

01:00:39.660 --> 01:00:40.660
没问题

01:00:40.660 --> 01:00:42.660
如果说i小鱼n的情况下

01:00:42.660 --> 01:00:44.660
是不是要一直往后移动

01:00:44.660 --> 01:00:45.660
对不对

01:00:45.660 --> 01:00:46.660
是不是要一直往后移动

01:00:46.660 --> 01:00:47.660
看一下刚才的图

01:00:47.660 --> 01:00:48.660
i和7

01:00:48.660 --> 01:00:49.660
就是个n1和n2

01:00:49.660 --> 01:00:50.660
是不是指向前两个

01:00:50.660 --> 01:00:51.660
这是n1

01:00:51.660 --> 01:00:52.660
上一位

01:00:52.660 --> 01:00:53.660
n2

01:00:53.660 --> 01:00:55.660
前两位

01:00:55.660 --> 01:00:56.660
然后有个i

01:00:56.660 --> 01:00:57.660
目前的看的是

01:00:57.660 --> 01:00:58.660
看的是哪呢

01:00:58.660 --> 01:00:59.660
目前看的是这

01:00:59.660 --> 01:01:01.660
看的是这

01:01:01.660 --> 01:01:03.660
我们最终的结果说看哪呢

01:01:03.660 --> 01:01:04.660
我们最终的结果

01:01:04.660 --> 01:01:06.660
比方说看这

01:01:06.660 --> 01:01:08.660
是不是还没有到目标

01:01:08.660 --> 01:01:09.660
没有到目标怎么办

01:01:09.660 --> 01:01:11.660
一是往后移动

01:01:11.660 --> 01:01:12.660
但是每次移动的时候

01:01:12.660 --> 01:01:14.660
每次移动之前

01:01:14.660 --> 01:01:16.660
我是不是要重新

01:01:16.660 --> 01:01:17.660
把这个箭头

01:01:18.660 --> 01:01:19.660
放这

01:01:19.660 --> 01:01:20.660
这个箭头放这

01:01:20.660 --> 01:01:21.660
不然的话

01:01:21.660 --> 01:01:22.660
刷不出最后一个纸

01:01:22.660 --> 01:01:23.660
对不对

01:01:23.660 --> 01:01:24.660
好 下一次

01:01:24.660 --> 01:01:25.660
他移动到这了

01:01:25.660 --> 01:01:26.660
是不是我要把箭头

01:01:26.660 --> 01:01:27.660
移动到这

01:01:27.660 --> 01:01:28.660
移动到这

01:01:28.660 --> 01:01:29.660
原来的意思吧

01:01:29.660 --> 01:01:30.660
因此我们要做的事情

01:01:30.660 --> 01:01:31.660
每一次循环

01:01:31.660 --> 01:01:32.660
我们要做的什么事情

01:01:32.660 --> 01:01:33.660
就是把

01:01:33.660 --> 01:01:36.660
这个箭头往后边移动移位

01:01:36.660 --> 01:01:37.660
那么它这个箭头

01:01:37.660 --> 01:01:38.660
往后边移动移位

01:01:38.660 --> 01:01:39.660
是啥

01:01:39.660 --> 01:01:40.660
是啥

01:01:40.660 --> 01:01:42.660
是不是就是这两位之合

01:01:42.660 --> 01:01:44.660
这个箭头是不是这两位之合

01:01:44.660 --> 01:01:46.660
是不是指向这两位

01:01:46.660 --> 01:01:47.660
这个箭头是不是指向

01:01:47.660 --> 01:01:49.660
这个这个之合

01:01:49.660 --> 01:01:51.660
对吧 指向这个位置

01:01:51.660 --> 01:01:52.660
然后这个箭头

01:01:52.660 --> 01:01:53.660
是不是

01:01:53.660 --> 01:01:54.660
这个箭头是不是要指向

01:01:54.660 --> 01:01:55.660
它之前的那个纸

01:01:55.660 --> 01:01:56.660
对吧

01:01:56.660 --> 01:01:57.660
所以说我们这里

01:01:57.660 --> 01:02:00.810
可以用这种做法

01:02:00.810 --> 01:02:02.810
所以我最近下载一个东西

01:02:02.810 --> 01:02:04.810
叫做修

01:02:04.810 --> 01:02:05.810
叫做brush

01:02:05.810 --> 01:02:06.810
叫什么brush

01:02:06.810 --> 01:02:11.140
叫screen brush

01:02:11.140 --> 01:02:12.140
我还没有用俗

01:02:12.140 --> 01:02:13.140
还没有用俗

01:02:13.140 --> 01:02:14.140
真正用

01:02:14.140 --> 01:02:16.140
我觉得挺不错的

01:02:17.140 --> 01:02:18.140
我们要做的事情

01:02:18.140 --> 01:02:19.140
就是把刚才那个

01:02:19.140 --> 01:02:20.140
刚才这个逻辑实现

01:02:20.140 --> 01:02:21.140
首先我把他的纸

01:02:21.140 --> 01:02:22.140
占存一下

01:02:22.140 --> 01:02:23.140
把他的纸向的东西

01:02:23.140 --> 01:02:24.140
占存一下

01:02:24.140 --> 01:02:25.140
因为他一会儿

01:02:25.140 --> 01:02:26.140
他只要复纸给他

01:02:26.140 --> 01:02:27.140
对吧

01:02:27.140 --> 01:02:28.140
所以他的只要占存一下

01:02:28.140 --> 01:02:29.140
首先把这个

01:02:29.140 --> 01:02:30.140
nust2

01:02:30.140 --> 01:02:31.140
存一个temp

01:02:31.140 --> 01:02:32.140
nust2

01:02:32.140 --> 01:02:33.140
存一下

01:02:33.140 --> 01:02:34.140
然后接下来

01:02:34.140 --> 01:02:35.140
我要做的事情就是

01:02:35.140 --> 01:02:37.140
把这个地方

01:02:37.140 --> 01:02:39.140
这个地方指向什么

01:02:39.140 --> 01:02:40.140
ta加ta

01:02:40.140 --> 01:02:41.140
对不对

01:02:41.140 --> 01:02:43.140
因此我要把nust2

01:02:43.140 --> 01:02:44.140
等于什么

01:02:44.140 --> 01:02:46.140
nust1

01:02:46.140 --> 01:02:48.140
加上nust2

01:02:50.140 --> 01:02:51.140
就指向这了

01:02:51.140 --> 01:02:53.140
就指向这了

01:02:53.140 --> 01:02:54.140
然后把这个东西

01:02:54.140 --> 01:02:56.140
指向他之前那个

01:02:56.140 --> 01:02:58.140
之前那个字是不是temp

01:02:58.140 --> 01:02:59.140
对不对

01:02:59.140 --> 01:03:00.140
所以我要nust1

01:03:00.140 --> 01:03:02.140
指向temp

01:03:02.140 --> 01:03:03.140
就完事了

01:03:03.140 --> 01:03:05.140
这个移动是不是就完了

01:03:05.140 --> 01:03:06.140
然后再把什么

01:03:06.140 --> 01:03:08.140
i加加

01:03:08.140 --> 01:03:09.140
对不对

01:03:09.140 --> 01:03:10.140
i加加

01:03:10.140 --> 01:03:13.420
什么话

01:03:13.420 --> 01:03:14.420
这个code

01:03:14.420 --> 01:03:16.420
怎么会要钱啊

01:03:16.420 --> 01:03:18.420
这是vscode的插件

01:03:18.420 --> 01:03:19.420
vscode的插件

01:03:19.420 --> 01:03:20.420
还从来没有遇到过

01:03:20.420 --> 01:03:21.420
要收费的

01:03:21.420 --> 01:03:23.420
code的

01:03:23.420 --> 01:03:26.980
你跑了百度去收

01:03:26.980 --> 01:03:28.980
跑了百度去收去了

01:03:28.980 --> 01:03:30.980
这是vscode的插件

01:03:30.980 --> 01:03:32.980
怎么出来

01:03:32.980 --> 01:03:36.380
收一下

01:03:36.380 --> 01:03:37.380
我这里的

01:03:37.380 --> 01:03:38.380
不知道怎么回事

01:03:38.380 --> 01:03:39.380
连不上了

01:03:39.380 --> 01:03:43.980
在这里收一下

01:03:43.980 --> 01:03:44.980
然后就完事了

01:03:44.980 --> 01:03:45.980
最后

01:03:45.980 --> 01:03:46.980
你看最后

01:03:46.980 --> 01:03:47.980
最后

01:03:47.980 --> 01:03:49.980
i移动到什么位置就结束了

01:03:49.980 --> 01:03:51.980
是不是移动到这就结束了

01:03:51.980 --> 01:03:53.980
然后

01:03:53.980 --> 01:03:55.980
所以移动到这

01:03:55.980 --> 01:03:57.980
然后

01:03:57.980 --> 01:03:58.980
他指向他

01:03:58.980 --> 01:03:59.980
他指向他

01:03:59.980 --> 01:04:00.980
他本来是这样子

01:04:00.980 --> 01:04:01.980
然后i加加

01:04:01.980 --> 01:04:02.980
收到这

01:04:02.980 --> 01:04:03.980
到这是不是结束了

01:04:03.980 --> 01:04:05.980
结束的时候

01:04:05.980 --> 01:04:06.980
干嘛

01:04:06.980 --> 01:04:07.980
结束的时候干嘛

01:04:07.980 --> 01:04:08.980
我只需要返回

01:04:08.980 --> 01:04:09.980
他加他

01:04:09.980 --> 01:04:11.980
是不是完事了

01:04:11.980 --> 01:04:13.980
是不是返回他加他就完事了

01:04:13.980 --> 01:04:14.980
好

01:04:14.980 --> 01:04:15.980
最后返回

01:04:15.980 --> 01:04:19.740
nust1加上nust2

01:04:19.740 --> 01:04:20.740
用code

01:04:20.740 --> 01:04:21.740
你看

01:04:21.740 --> 01:04:22.740
4v5

01:04:22.740 --> 01:04:24.740
我前面全部注視取消

01:04:25.740 --> 01:04:29.580
英雄

01:04:29.580 --> 01:04:31.580
1123 5% 113

01:04:31.580 --> 01:04:33.580
就是这种情况还有很多种解法

01:04:33.580 --> 01:04:35.580
只不过他比较适合讲帝规

01:04:35.580 --> 01:04:37.580
你看帝规的代码是不是特别清晰简单

01:04:37.580 --> 01:04:38.580
又好理解

01:04:38.580 --> 01:04:39.580
对吧

01:04:39.580 --> 01:04:40.580
就这个题

01:04:40.580 --> 01:04:41.580
帝规我说一下

01:04:41.580 --> 01:04:42.580
后边我们今天我们用不到

01:04:42.580 --> 01:04:43.580
后边我们可能会用

01:04:43.580 --> 01:04:44.580
然后下一个指数点

01:04:44.580 --> 01:04:45.580
我简单说一下

01:04:45.580 --> 01:04:46.580
这个模板支部串

01:04:46.580 --> 01:04:47.580
这模板支部串呢

01:04:47.580 --> 01:04:49.580
是ES6的指数

01:04:50.580 --> 01:04:51.580
因为我后边

01:04:51.580 --> 01:04:53.580
可能会用他来解决一些问题

01:04:53.580 --> 01:04:55.580
用普通的支部串有点麻烦

01:04:56.580 --> 01:04:57.580
非常简单

01:04:57.580 --> 01:04:58.580
他就是我们之前的支部串

01:04:58.580 --> 01:05:00.580
协法不用两种协法吧

01:05:00.580 --> 01:05:01.580
一种是双引号

01:05:01.580 --> 01:05:03.580
一种是单引号

01:05:03.580 --> 01:05:04.580
这两种支部串

01:05:04.580 --> 01:05:05.580
协法有什么问题呢

01:05:05.580 --> 01:05:06.580
其实没啥问题

01:05:06.580 --> 01:05:08.580
只剩下有很多不方便

01:05:08.580 --> 01:05:09.580
比如说你要换行

01:05:09.580 --> 01:05:11.580
比如说我要写篇文章

01:05:11.580 --> 01:05:12.580
就是标题

01:05:12.580 --> 01:05:13.580
我要断诺

01:05:13.580 --> 01:05:14.580
我要换行

01:05:14.580 --> 01:05:15.580
一换行是不是包说了

01:05:15.580 --> 01:05:16.580
因为他不允许的换行

01:05:17.580 --> 01:05:18.580
换行你要用什么

01:05:18.580 --> 01:05:19.580
你要用这种协法

01:05:19.580 --> 01:05:21.580
要用写个n

01:05:21.580 --> 01:05:23.580
然后断诺1

01:05:23.580 --> 01:05:24.580
断诺1

01:05:25.580 --> 01:05:27.580
然后写缸n

01:05:27.580 --> 01:05:28.580
断诺2

01:05:28.580 --> 01:05:29.580
这条比较麻烦

01:05:29.580 --> 01:05:30.580
也可以

01:05:30.580 --> 01:05:31.580
当然你以前

01:05:31.580 --> 01:05:32.580
他为了解决这个问题

01:05:32.580 --> 01:05:33.580
也可以让你写个写缸

01:05:33.580 --> 01:05:35.580
他也允许写个写缸

01:05:35.580 --> 01:05:36.580
换行也可以

01:05:36.580 --> 01:05:37.580
这样也可以

01:05:38.580 --> 01:05:39.580
但是你不能直接换

01:05:39.580 --> 01:05:41.580
总归是有点不好看

01:05:41.580 --> 01:05:42.580
那怎么办呢

01:05:43.580 --> 01:05:44.580
以前解决这个问题

01:05:44.580 --> 01:05:45.580
还有很多一些

01:05:45.580 --> 01:05:46.580
比较

01:05:48.580 --> 01:05:49.580
特别的技巧

01:05:51.580 --> 01:05:52.580
我都不撤远了

01:05:53.580 --> 01:05:54.580
那么现在

01:05:54.580 --> 01:05:55.580
还就双一号

01:05:55.580 --> 01:05:56.580
也是同样的问题

01:05:56.580 --> 01:05:57.580
这是第一个问题

01:05:57.580 --> 01:05:58.580
第二个问题呢

01:05:58.580 --> 01:05:59.580
是它拼接起来很不方便

01:05:59.580 --> 01:06:01.580
比方说我这里有两个辩量

01:06:01.580 --> 01:06:02.580
A等于

01:06:03.580 --> 01:06:04.580
B等于2

01:06:04.580 --> 01:06:05.580
我要写这么一个制补串

01:06:05.580 --> 01:06:06.580
我要写上

01:06:06.580 --> 01:06:07.580
我要输出

01:06:07.580 --> 01:06:08.580
S呢

01:06:08.580 --> 01:06:09.580
要等于这个

01:06:10.580 --> 01:06:11.580
A

01:06:11.580 --> 01:06:12.580
加

01:06:12.580 --> 01:06:13.580
就是1

01:06:13.580 --> 01:06:14.580
加2

01:06:14.580 --> 01:06:15.580
等于3

01:06:15.580 --> 01:06:16.580
我要输出这么一个制补串

01:06:16.580 --> 01:06:17.580
那么以前怎么写

01:06:17.580 --> 01:06:18.580
以前呢

01:06:18.580 --> 01:06:19.580
我平时讲课的时候

01:06:19.580 --> 01:06:20.580
是这么写的

01:06:20.580 --> 01:06:21.580
问号

01:06:21.580 --> 01:06:22.580
加上问号

01:06:22.580 --> 01:06:23.580
等于问号

01:06:23.580 --> 01:06:24.580
第一个问号位置

01:06:24.580 --> 01:06:25.580
位置的要拼接什么

01:06:25.580 --> 01:06:26.580
拼接A

01:06:26.580 --> 01:06:28.580
所以说我把A拼接到前面

01:06:28.580 --> 01:06:29.580
第二个问号位置

01:06:29.580 --> 01:06:30.580
要拼接B

01:06:30.580 --> 01:06:32.580
就是我要把B拼接到这

01:06:32.580 --> 01:06:34.580
就特别恶心写出来

01:06:34.580 --> 01:06:35.580
最后问号位置

01:06:35.580 --> 01:06:36.580
要拼接什么

01:06:36.580 --> 01:06:37.580
A加B

01:06:37.580 --> 01:06:38.580
是不是还要扩起来

01:06:38.580 --> 01:06:39.580
A加B

01:06:39.580 --> 01:06:40.580
以前是不是得这么写

01:06:40.580 --> 01:06:42.580
非常不好阅读

01:06:42.580 --> 01:06:43.580
那么怎么办呢

01:06:43.580 --> 01:06:44.580
我们在ES6里边

01:06:44.580 --> 01:06:45.580
为了解决

01:06:45.580 --> 01:06:46.580
上述两个问题

01:06:46.580 --> 01:06:47.580
它就做了这么一个东西

01:06:47.580 --> 01:06:48.580
叫模板制补串

01:06:48.580 --> 01:06:49.580
模板制补串

01:06:49.580 --> 01:06:50.580
它就不是一单一号

01:06:50.580 --> 01:06:51.580
和双一号了

01:06:51.580 --> 01:06:53.580
它是以反一些

01:06:53.580 --> 01:06:54.580
反引号

01:06:54.580 --> 01:06:55.580
以这个引号开头

01:06:55.580 --> 01:06:56.580
和这个引号结束

01:06:56.580 --> 01:06:57.580
那么中间呢

01:06:57.580 --> 01:06:58.580
首先是换行问题

01:06:58.580 --> 01:06:59.580
你可以随便换行吗

01:06:59.580 --> 01:07:00.580
标题

01:07:00.580 --> 01:07:02.580
段落

01:07:02.580 --> 01:07:04.580
你看是不是可以随便换行

01:07:04.580 --> 01:07:05.580
换行的位置

01:07:05.580 --> 01:07:07.580
它就自动写当N

01:07:07.580 --> 01:07:08.580
自动写当N

01:07:08.580 --> 01:07:09.580
好

01:07:09.580 --> 01:07:10.580
接下来呢

01:07:10.580 --> 01:07:11.580
如果说你要实现拼接的话

01:07:11.580 --> 01:07:12.580
也非常简单

01:07:12.580 --> 01:07:13.580
刚才是不是写个

01:07:13.580 --> 01:07:14.580
问号

01:07:14.580 --> 01:07:16.580
加上问号等于问号

01:07:16.580 --> 01:07:17.580
第一个问号位置

01:07:17.580 --> 01:07:18.580
是不是要放A

01:07:18.580 --> 01:07:19.580
要拼接A

01:07:19.580 --> 01:07:20.580
在模板制补串中

01:07:20.580 --> 01:07:21.580
非常简单

01:07:21.580 --> 01:07:22.580
你写个多了

01:07:22.580 --> 01:07:23.580
两个大过号

01:07:23.580 --> 01:07:25.580
在这个位置呢

01:07:25.580 --> 01:07:26.580
大过号里边

01:07:26.580 --> 01:07:27.580
花过号里边

01:07:27.580 --> 01:07:30.580
你可以写JS表达式

01:07:30.580 --> 01:07:32.580
JS表达式

01:07:32.580 --> 01:07:33.580
它会把

01:07:33.580 --> 01:07:34.580
它会把这个位置的东西

01:07:34.580 --> 01:07:35.580
算出来

01:07:35.580 --> 01:07:37.580
替换掉这个位置

01:07:37.580 --> 01:07:38.580
就相当于是拼接的

01:07:38.580 --> 01:07:39.580
相当于是拼接的

01:07:39.580 --> 01:07:40.580
它把这个东西算出来

01:07:40.580 --> 01:07:41.580
替换掉这个位置

01:07:41.580 --> 01:07:42.580
那么这里写啥

01:07:42.580 --> 01:07:43.580
我们是不是可以写个A

01:07:43.580 --> 01:07:45.580
把A的值

01:07:45.580 --> 01:07:46.580
1

01:07:46.580 --> 01:07:48.580
替换掉这个位置

01:07:48.580 --> 01:07:49.580
好

01:07:49.580 --> 01:07:50.580
写个B

01:07:51.580 --> 01:07:52.580
说好看多了

01:07:52.580 --> 01:07:53.580
这个位置写的

01:07:53.580 --> 01:07:55.580
是不是写A加B

01:07:56.580 --> 01:07:57.580
那么整个制服串的格式

01:07:57.580 --> 01:07:58.580
没有被打乱

01:07:58.580 --> 01:07:59.580
我们知道

01:07:59.580 --> 01:08:00.580
这一坨

01:08:00.580 --> 01:08:01.580
一个制服加

01:08:01.580 --> 01:08:02.580
这一坨

01:08:02.580 --> 01:08:03.580
一个制服等

01:08:03.580 --> 01:08:05.580
然后这一坨

01:08:05.580 --> 01:08:07.580
是不就拼接出来了

01:08:07.580 --> 01:08:08.580
然后

01:08:09.580 --> 01:08:10.580
我真没有影响

01:08:10.580 --> 01:08:11.580
输出S

01:08:12.580 --> 01:08:13.580
这是我给大家补充的

01:08:13.580 --> 01:08:14.580
一点知识

01:08:16.580 --> 01:08:17.580
答应好

01:08:17.580 --> 01:08:18.580
反应好在哪呢

01:08:18.580 --> 01:08:19.580
在ESC下边

01:08:20.580 --> 01:08:21.580
ESC下边

01:08:21.580 --> 01:08:23.580
也就Type-G上边

01:08:24.580 --> 01:08:25.580
好

01:08:25.580 --> 01:08:26.580
那么这一坨

01:08:26.580 --> 01:08:27.580
我们今天讲到这了

