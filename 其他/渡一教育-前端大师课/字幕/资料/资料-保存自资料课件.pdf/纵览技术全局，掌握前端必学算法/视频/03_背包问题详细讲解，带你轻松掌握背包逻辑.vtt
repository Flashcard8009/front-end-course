WEBVTT

00:00.000 --> 00:03.060
好 那咱们今天晚上来讲动态规划

00:03.840 --> 00:07.420
在我们的面试题里边 如果说考到算法题的话

00:08.440 --> 00:14.080
最灵活的地方就是动态规划了 咱们昨天讲了战对吧 战的应用场景呢

00:14.340 --> 00:17.920
还是比较多的 但是一般来说呢你可以

00:18.180 --> 00:20.480
如果说你做多了这个战的题啊

00:20.740 --> 00:24.320
其实你有这种感觉 他要不要拥有战 一般来说

00:24.840 --> 00:27.640
我们昨天是做一个制不错的解析对吧

00:28.400 --> 00:32.500
昨天是做了一个制不错的解析 一个制不错 制不错里边有一些东西

00:33.520 --> 00:38.640
一个表达式啊 然后这个表达式里边呢 我们可能会就是写了一些东西吧

00:38.900 --> 00:41.460
那么我们去解析这个制不错 去做一些事

00:42.480 --> 00:46.840
而将来呢 我们可能会学习到维吾尔 原码分析

00:47.360 --> 00:52.980
那么这些其实他也有类似的事情要做 比方说像维吾尔里边呢 他也要解析一个制不错

00:53.240 --> 00:55.040
他制不错是吗 就template是模板

00:55.800 --> 00:56.820
在模板里边呢

00:57.540 --> 00:58.820
有什么 有这么一些东西对吧

01:00.100 --> 01:01.900
他要解析成一个虚拟洞

01:02.660 --> 01:04.700
那么这个玩意呢 其实他也会用到战的啊

01:05.480 --> 01:06.500
解析 解析

01:07.780 --> 01:09.060
解析个虚拟洞 他也会用到战

01:09.320 --> 01:11.100
像riot也是类似的道理

01:11.360 --> 01:12.900
像战的这个这个

01:14.180 --> 01:19.300
数据结构呢 一般来说啊 他说一些制不错解析的工作的时候 非常可能会用到

01:20.580 --> 01:23.140
好 说昨天的东西啊 我们今天说动态规划

01:24.100 --> 01:28.500
动态规划这一块呢 就比较麻烦一点了 因为他的题太过于灵活了

01:29.140 --> 01:30.020
有的时候呢

01:30.900 --> 01:34.100
你拿到一道题 你一眼是看不出来 他需不需要动态规划

01:34.820 --> 01:40.500
那么这个动态规划到底是啥呀 我们这里呢 通过一个菲伯拉奇数列 给大家把这个概念呢隐身出来

01:41.540 --> 01:46.020
好 只要看这个问题啊 这个菲伯拉奇数列呢 也是咱们第一天给大家讲过的

01:46.900 --> 01:51.300
就这么一个数列啊 前两位固定为一 后边的就是二三五八 就是前两位之和

01:51.860 --> 01:53.860
之前看过了对吧 八加十三二十一

01:54.660 --> 01:57.860
那么这个菲伯拉奇数列呢 我们把它写成一个函数 比较说F函数

01:58.340 --> 02:01.780
那么传入一个N 我们希望得到一个菲伯拉奇数列的N位的值

02:02.660 --> 02:08.340
这个玩意呢 我们第一天就分析过了 对吧 我们可以把它转换成一个什么问题呢 就是把一个FN

02:08.900 --> 02:09.700
转换成

02:10.820 --> 02:12.980
FN-1加上

02:14.020 --> 02:16.820
FN-2 是不是 转换成这么一个公式

02:17.700 --> 02:22.900
转换这个公式过后呢 我们就可以使用地规来实现啊 比方我们之前写过的 是吧 我们现在再写一次

02:23.620 --> 02:24.420
菲伯拉奇数列

02:25.780 --> 02:27.300
菲伯拉奇数列

02:28.100 --> 02:30.100
快速的写一下啊 我们之前写过的

02:31.620 --> 02:34.100
我们通过这个问题呢 来隐身出咱们的动态规划

02:35.220 --> 02:37.620
一个方式啊 我们就用F吧 结果一个N

02:38.100 --> 02:42.660
我判断一下 如果说N这个N等于1或者是这个N等于2

02:43.140 --> 02:46.340
这种情况呢 我们直接返回1 因为前两位固定为一嘛

02:46.900 --> 02:50.260
剩下的情况呢 我们就直接返回N-1加上

02:51.620 --> 02:52.980
加上FN-2

02:55.320 --> 02:58.600
这个问题很简单 但是呢 特别能说明说明一些道理

02:59.480 --> 03:03.960
那么这样子写呢 程序就已经ok了啊 我们比较输出一下DF

03:04.440 --> 03:07.000
D6位的值吧 我们D6位是3

03:07.560 --> 03:10.920
1 2 3 4 5 6 D6位是8 对吧 我们来输出一下

03:12.280 --> 03:14.120
D6位是不是得到8了 没问题了

03:14.680 --> 03:18.120
但是这个这个地方 我们有优化的空间吗

03:18.680 --> 03:20.280
实际上我们是有优化的空间的

03:21.240 --> 03:23.480
怎么优化呢 看这张图

03:24.680 --> 03:29.400
咱们的F6啊 它会被分解成为F5加上F4

03:30.040 --> 03:34.760
对不对 你看 我们把6团进去说要算F5是多少 然后要算F4是多少

03:35.480 --> 03:39.080
对吧 那么要算F5的时候 它要说要重新调动函数

03:39.400 --> 03:42.600
这一重新调动函数说要分解成为F4加上F3

03:43.480 --> 03:46.040
而我们的F4要分解成为F3加上F2

03:46.440 --> 03:48.440
那么我们的F2呢 直接可以得到结果

03:48.440 --> 03:52.520
F2的Fn等于1 n等于2 它直接得到1 这个没问题

03:52.920 --> 03:56.760
那么F3就分解成为F2加F1 这边也是一样 你看这张图

03:57.640 --> 04:02.440
那么如果说我们不去做任何处理的话 这样子计算量是非常大的

04:03.000 --> 04:04.520
为什么呢 你看这个F6这个例子

04:05.160 --> 04:08.920
把它分解成为F5 你要算吧 那你要算F4

04:09.560 --> 04:11.320
F4你要算吧 你要算F3

04:11.800 --> 04:13.880
好 你看F3和F4是不是算了一次了

04:14.360 --> 04:18.360
算了一次过后呢 我们这里边又要重新去算一下F3

04:18.360 --> 04:21.080
因为F4算出来了嘛 我们这里还要加上F3

04:21.400 --> 04:23.960
就要重新去算一下F3 那又要来分解一次

04:23.960 --> 04:27.960
F2加F1 把F3算出来 好 终于把这个F5算出来了

04:28.360 --> 04:30.760
然后接下来我们要算F4 是不是又要重新算

04:30.760 --> 04:34.360
明明之前算过这个F4 但是不行 现在还要重新算一次

04:34.360 --> 04:35.880
因为又是一次新的函数交用

04:36.760 --> 04:40.600
而算这个F4呢 又要算这个F3 要加F2 F3是不是又要重新算

04:41.080 --> 04:42.840
从这个图里边其实你可以看到

04:44.360 --> 04:46.520
咱们这个动态规划的

04:46.520 --> 04:50.280
对 这个维吾拉希数列里边其实重复的算了很多东西

04:50.840 --> 04:52.680
我们可以通过一个代码把它

04:53.400 --> 04:56.280
验证一下 一和二就不用管了 我们来看一下

04:56.280 --> 04:58.840
除了一和二之外 我们来输出一下

05:00.200 --> 05:03.480
计算F 我们用那个模板中不错吗

05:04.040 --> 05:07.080
这讲过的啊 计算F 什么的值呢

05:08.520 --> 05:09.480
拼件一下啊 N

05:10.120 --> 05:11.640
计算F 什么的值

05:13.890 --> 05:15.730
好 保存啊 咱们来看一下

05:17.730 --> 05:19.810
这里运行 你看一下算的过程

05:20.450 --> 05:24.770
就是重复算了一些东西啊 我们要算F6 是不是要算F5 加上F4

05:24.770 --> 05:30.130
要算F5的话 要算F3

05:30.850 --> 05:32.050
咦 怎么少了一些了

05:33.650 --> 05:37.890
哦 对 要算F5的话 要算F4加F3 要算F4的话

05:38.210 --> 05:46.370
要算F4的话 要算F3 要算F2就算了啊

05:46.370 --> 05:47.810
那么就把F4算出来了

05:47.810 --> 05:51.330
然后再算F4 这边的F4

05:51.330 --> 05:52.530
总之它会有一些重复

05:52.530 --> 05:55.330
你可以看那个图 它就会有一些重复的运算

05:55.330 --> 05:57.490
那么这个重复的运算就会影响程序的效率

05:58.050 --> 06:01.730
如果说这个数字很小的话 还感觉不到

06:01.730 --> 06:04.130
如果说这个数字比较大的话就非常恐怖了

06:04.130 --> 06:05.730
比方说这个数字呢 给它写个一版

06:06.530 --> 06:09.170
这个数字越大 它重复的东西越多

06:09.170 --> 06:09.970
运行你看一下

06:11.250 --> 06:11.890
你看一下吧

06:13.010 --> 06:14.050
一直算不出来

06:14.050 --> 06:15.250
所以一直算不出来

06:15.250 --> 06:17.170
它要重复的算很多很多东西

06:17.170 --> 06:17.970
我们停止了啊

06:18.770 --> 06:21.010
总之这个重复的值越大

06:21.010 --> 06:23.330
这个值越大 它要重复的东西就越多

06:23.330 --> 06:24.850
那么这个问题怎么来解决呢

06:25.490 --> 06:27.170
我们可以通过 刚才有同学说

06:27.170 --> 06:29.570
我们可以通过一张表格来记录一下

06:29.570 --> 06:31.570
就说你第一次算的时候

06:31.570 --> 06:33.570
算一个指标 第一次算F5的时候

06:34.530 --> 06:36.210
没有记录

06:36.210 --> 06:37.010
那么我们就算

06:37.010 --> 06:38.770
算完了过后呢

06:38.770 --> 06:40.130
我要把它记录一下啊

06:40.130 --> 06:41.410
我们F5已经算过了

06:41.410 --> 06:42.690
你不需要 以后就不需要算了

06:42.690 --> 06:44.050
直接拿到这个结果就行了

06:44.050 --> 06:45.330
你如果我们现在需要个什么呢

06:45.330 --> 06:46.210
需要个东西来记录

06:47.330 --> 06:49.010
比方说你算这个F3的时候

06:50.850 --> 06:52.210
我们用个对象来记录吧

06:52.210 --> 06:54.130
你算这个F3的时候

06:54.130 --> 06:55.410
你好不容易算出来了

06:55.410 --> 06:56.210
等于多少啊

06:56.210 --> 06:57.250
等于2

06:58.210 --> 06:59.810
好 那么我就记录一下

06:59.810 --> 07:01.170
将来你再遇到F3

07:01.170 --> 07:02.770
直接从那个对象里边去取

07:02.850 --> 07:04.290
你就不用再重复的进去算了

07:04.290 --> 07:05.570
当然你用这个记录的话

07:05.570 --> 07:06.370
你可以用对象

07:06.370 --> 07:07.410
你可以用任何东西

07:07.410 --> 07:08.930
总之你把它记录下来

07:08.930 --> 07:10.610
好 到时候你算F4的时候

07:11.410 --> 07:13.890
是不是要等于F3加上F2

07:13.890 --> 07:15.650
那么F3就直接出来了

07:15.650 --> 07:16.530
因为我们之前算过了

07:16.530 --> 07:17.890
就不用再重复算了

07:17.890 --> 07:18.930
它起这么一个作用

07:18.930 --> 07:20.370
比如我们现在需要这么一个东西

07:20.370 --> 07:21.330
把它记录一下啊

07:21.970 --> 07:23.490
好 我们用什么样的东西来记录呢

07:23.490 --> 07:24.530
我们就用一个对象吧

07:24.530 --> 07:25.570
我们把它称之为DP

07:27.650 --> 07:29.170
我们把它称之为DP表格

07:29.170 --> 07:29.810
就是一个表格

07:30.610 --> 07:31.410
它可以是个对象

07:31.410 --> 07:32.050
可以是个数组

07:32.050 --> 07:32.770
可以是任何东西

07:32.770 --> 07:35.250
你只要方便你记录的东西都可以

07:35.250 --> 07:37.650
我们现在就用个对象来记录一下

07:37.650 --> 07:39.330
如果说n等于1

07:39.330 --> 07:40.930
或者是n等于2

07:40.930 --> 07:42.130
那么这种情况呢

07:43.730 --> 07:44.690
我就不管了

07:44.690 --> 07:45.650
这种情况我就不管了

07:45.650 --> 07:46.450
我就直接反回1

07:47.330 --> 07:49.090
如果不是1和2

07:49.090 --> 07:50.130
那么这个时候呢

07:50.130 --> 07:51.010
我们首先

07:51.010 --> 07:51.810
逻辑是

07:51.810 --> 07:53.330
首先看一下有没有记录

07:54.530 --> 07:55.570
看一下DP

07:55.570 --> 07:56.930
我们用n来表示

07:56.930 --> 07:58.850
你现在算的是第几位的值

07:58.850 --> 08:00.530
不要说把n传进去

08:00.530 --> 08:01.410
作为属性传进去

08:01.490 --> 08:02.530
比方例算F3

08:02.530 --> 08:03.650
我就把3传进去

08:03.650 --> 08:04.690
看一下这个F3

08:04.690 --> 08:05.730
这个记录过没有啊

08:05.730 --> 08:07.650
这个值是不是已经算过了

08:07.650 --> 08:08.930
如果说有值的话

08:10.130 --> 08:11.890
直接返回DPn

08:13.250 --> 08:14.050
所以有过记录

08:14.690 --> 08:15.490
有过记录

08:16.850 --> 08:17.730
那就直接返回

08:18.770 --> 08:19.730
把缓存一下

08:20.450 --> 08:21.970
如果说没有记录的话

08:22.770 --> 08:24.290
我就算这个Fn的值

08:24.290 --> 08:25.410
好 算出来过后了

08:25.410 --> 08:26.290
我就把记录一下

08:26.290 --> 08:27.010
怎么记录呢

08:27.010 --> 08:27.570
把它放进来

08:28.210 --> 08:28.530
对吧

08:28.530 --> 08:29.970
我把算出来的结果

08:29.970 --> 08:30.770
把它记录进去

08:31.570 --> 08:32.610
好 记录进去过后了

08:32.610 --> 08:33.570
我们再最后返回

08:34.530 --> 08:35.010
你看一下

08:35.010 --> 08:35.810
这样子的话

08:36.370 --> 08:37.410
效率就高很多了

08:38.050 --> 08:39.010
我们直接运行啊

08:39.010 --> 08:39.650
这个F100

08:39.650 --> 08:40.130
直接运行

08:40.130 --> 08:40.850
看一下效率

08:41.410 --> 08:42.290
所以瞬间就算出来了

08:42.770 --> 08:43.650
就快快了很多

08:43.650 --> 08:44.770
刚才一直算不出来

08:44.770 --> 08:46.210
你看是不是每一次

08:46.210 --> 08:48.130
都是算的是不重复的东西

08:48.130 --> 08:48.930
它没有重复的

08:49.650 --> 08:51.090
需要计算的都没有重复

08:51.090 --> 08:51.650
那么最后呢

08:51.650 --> 08:53.010
我可以打印出一下这个DP

08:54.690 --> 08:56.930
打印一下这个DP

08:56.930 --> 08:57.250
运行

08:57.970 --> 08:58.610
你看

08:58.610 --> 08:59.890
这个DP里面是记录

08:59.890 --> 09:01.010
这个对象里面是记录了

09:01.010 --> 09:03.090
所有的我们以前运算过的值

09:03.090 --> 09:04.130
是不是换出下来的

09:04.130 --> 09:04.610
对吧

09:04.610 --> 09:05.170
3 2

09:05.890 --> 09:06.770
第四位的是3

09:06.770 --> 09:07.730
第五位的是5

09:07.730 --> 09:09.010
全部换出下来

09:09.010 --> 09:09.650
那么之后呢

09:09.650 --> 09:10.130
比方说

09:10.130 --> 09:11.490
我再算10001

09:11.490 --> 09:12.450
是不是就非常方便了

09:12.450 --> 09:13.650
就瞬间就出来了

09:13.650 --> 09:15.730
因为F100和F99

09:15.730 --> 09:17.090
我们都已经算过了

09:17.090 --> 09:18.210
一样的意思呢

09:18.210 --> 09:19.010
就这么个意思

09:20.370 --> 09:20.770
这就是

09:21.890 --> 09:22.850
这道题

09:22.850 --> 09:24.610
我们可以用一种思想

09:24.610 --> 09:27.090
叫做用空间去换时间

09:28.130 --> 09:29.410
我们可能会增加

09:29.410 --> 09:30.450
我们的存储空间

09:30.450 --> 09:31.170
多了一个东西了

09:31.170 --> 09:31.330
对吧

09:31.330 --> 09:32.530
多个对象肯定会增加

09:32.530 --> 09:33.810
我们的内存消耗

09:33.810 --> 09:34.210
但是呢

09:34.210 --> 09:34.930
我们节省了

09:34.930 --> 09:36.450
我们函数的运算时间

09:36.450 --> 09:38.130
这叫做用空间去换时间

09:38.930 --> 09:39.890
就这么一个例子

09:39.890 --> 09:40.770
这是菲波拉希

09:40.770 --> 09:41.730
树列这么一个例子

09:41.730 --> 09:43.090
听到这没问题吧

09:43.090 --> 09:43.970
能听懂吧

09:43.970 --> 09:44.690
给你弄出个1

09:51.170 --> 09:51.490
OK

09:52.210 --> 09:53.490
接下来我们来说这个动态规划

09:55.570 --> 09:56.850
啥叫动态规划呢

09:57.490 --> 09:59.010
其实动态规划里面包含了

09:59.010 --> 10:00.290
两个核心思想

10:00.850 --> 10:02.770
你只要一个问题呢

10:02.850 --> 10:04.930
你能够用这两个核心思想去解决

10:04.930 --> 10:05.890
我们就觉得

10:05.890 --> 10:08.130
认为你使用的是动态规划的思想

10:08.850 --> 10:09.970
哪两种思想呢

10:09.970 --> 10:11.810
第一个叫做状态转移方程

10:12.290 --> 10:13.650
什么叫状态转移方程

10:13.650 --> 10:15.010
就是有一个复杂的问题

10:15.570 --> 10:16.610
一个很大的问题

10:17.170 --> 10:19.490
我可能一时半会找不到什么思路

10:19.490 --> 10:19.970
但是呢

10:19.970 --> 10:21.170
我能够把这个大问题呢

10:21.170 --> 10:23.730
分解成很多的重叠指问题

10:24.610 --> 10:26.050
比方说这个菲波拉希树列

10:26.610 --> 10:27.570
大问题是什么呢

10:27.570 --> 10:29.170
大问题就是我要算这个F

10:29.490 --> 10:33.490
重叠指问题是什么呢

10:33.490 --> 10:35.090
我觉得算这个Fn

10:35.090 --> 10:37.490
跟算这个Fn-1是一样的

10:37.490 --> 10:38.930
它的逻辑是一样的

10:38.930 --> 10:40.530
跟算这个Fn-2

10:40.530 --> 10:42.130
跟算这个Fn-3

10:42.130 --> 10:43.890
它逻辑是完全一样的

10:43.890 --> 10:45.410
并没有什么区别

10:45.410 --> 10:48.050
那么这些都就是重叠指问题

10:48.050 --> 10:50.370
这是首先要做的事情

10:50.370 --> 10:51.650
能够把一个大问题

10:51.650 --> 10:53.890
变成一个很多的重叠指问题

10:53.890 --> 10:55.890
但是不仅要如此

10:55.890 --> 10:57.330
还要能够寻找

10:57.490 --> 11:00.290
重叠指问题之间有什么关系

11:01.250 --> 11:02.450
像这个菲波拉希树列

11:02.450 --> 11:03.730
是不是非常明显

11:03.730 --> 11:05.810
这个问题跟这些重叠指问题之间

11:05.810 --> 11:06.610
是什么关系的

11:06.610 --> 11:07.570
它关系就是

11:07.570 --> 11:08.370
一个Fn

11:08.370 --> 11:09.970
应该等于Fn-1

11:09.970 --> 11:11.330
是这个重叠指问题

11:11.330 --> 11:12.530
它是个重叠问题

11:12.530 --> 11:14.610
那么Fn-2也是个重叠问题

11:14.610 --> 11:16.130
我们认为这两个重叠问题

11:16.130 --> 11:17.970
之合就等于Fn

11:17.970 --> 11:19.170
所以就找到了关系了

11:19.730 --> 11:23.410
你只要能够找到重叠指问题

11:23.410 --> 11:24.610
并且能够找到

11:24.610 --> 11:26.850
重叠指问题之间的关系

11:27.010 --> 11:29.890
你就可以列出这个状态转移方程

11:30.930 --> 11:34.770
这是动态规划的第一个重要的一个思想

11:35.490 --> 11:37.410
当然这一块是很难的

11:37.410 --> 11:40.450
其实动态规划最难的还不是缓存

11:40.450 --> 11:42.370
动态规划最难的就是这个

11:42.370 --> 11:44.770
你要能够找到这个关系

11:44.770 --> 11:45.970
找到重叠指问题

11:45.970 --> 11:46.930
可能还稍微简单一点

11:46.930 --> 11:48.850
找到这个关系可不简单

11:48.850 --> 11:49.970
当然这个菲波拉希树列

11:49.970 --> 11:51.010
是比较简单的问题

11:51.010 --> 11:52.050
你看就看明白了

11:52.050 --> 11:53.810
但是有的时候

11:53.810 --> 11:55.330
你遇到一些算法问题

11:55.330 --> 11:56.530
你可能不是那么好找

11:57.250 --> 11:59.410
有的时候可能还需要一些数学

11:59.410 --> 12:01.730
像我们这个开发里面的

12:01.730 --> 12:04.050
有一个职位叫做算法工程师

12:04.050 --> 12:07.090
如果说你要立志作为一个算法工程师的话

12:07.090 --> 12:09.490
那些数学必须要学得非常好才行

12:11.650 --> 12:13.490
好 第二个核心的思想呢

12:13.490 --> 12:14.850
就是一个缓存表

12:15.250 --> 12:17.250
就是因为我在

12:18.530 --> 12:20.610
在计算动态规划的时候

12:20.610 --> 12:21.810
在算这个问题的时候

12:21.810 --> 12:23.650
可能会遇到一些重复的迷算

12:24.610 --> 12:25.730
动态

12:26.610 --> 12:28.770
它很有可能会形成这么一种数形结构

12:28.770 --> 12:30.210
就是运算的数形结构

12:30.770 --> 12:31.570
那么算的时候

12:31.570 --> 12:33.330
就会遇到一些重复的运算

12:33.330 --> 12:35.570
为了避免反复的去算这些

12:35.570 --> 12:36.450
已经算过的东西

12:36.450 --> 12:38.050
我们可以准备一个缓存表

12:38.050 --> 12:39.810
这个缓存表可以是任何类型

12:39.810 --> 12:40.770
可以是一个数组

12:40.770 --> 12:42.210
可以是一个二维数组

12:42.210 --> 12:43.170
可以是一个对象

12:43.170 --> 12:44.370
可以是任何东西

12:44.370 --> 12:47.490
你只要能够非常方便地把存进去

12:47.490 --> 12:49.570
非常方便地把它取出来就OK

12:50.770 --> 12:52.690
所以为了缓存表的作用

12:52.770 --> 12:54.290
主要是为了提高

12:54.290 --> 12:55.890
我们的运算效率

12:55.890 --> 12:56.930
这就是动态规划

12:56.930 --> 12:58.530
像我们刚才的就用算这个

12:58.530 --> 12:59.330
非常简单的问题

12:59.330 --> 13:01.330
就是用到了动态规划的思想

13:02.450 --> 13:04.690
但是很多问题它不是这么简单

13:04.690 --> 13:06.210
那么接下来看一道

13:06.210 --> 13:08.530
非常非常经典的面试题

13:09.490 --> 13:11.170
叫做离异背包问题

13:11.170 --> 13:12.850
背包问题其实有很多

13:12.850 --> 13:14.690
我可以百度去搜一下

13:14.690 --> 13:16.530
背包问题的各种变种

13:16.530 --> 13:17.730
我们来看一下离异背包问题

13:19.570 --> 13:20.370
它说什么意思呢

13:20.370 --> 13:21.490
就好必说

13:21.490 --> 13:24.530
你到一家超市里边去

13:24.530 --> 13:25.650
我不限制你时间

13:26.530 --> 13:28.130
你能不能找到一种办法

13:28.130 --> 13:29.330
你身上背了一个包

13:29.970 --> 13:32.770
这个包装的商品是有限的

13:32.770 --> 13:34.370
你能不能想到一种办法

13:35.090 --> 13:36.690
能够去在超市里面

13:36.690 --> 13:37.810
随便装东西

13:37.810 --> 13:39.250
爱装多少装多少

13:39.250 --> 13:40.130
把这个包装满

13:40.930 --> 13:41.730
尽量的装满

13:43.090 --> 13:45.730
然后让这个包里面的价值最大

13:45.730 --> 13:46.690
这就是这个背包问题

13:47.890 --> 13:48.850
有什么样的办法

13:48.850 --> 13:49.810
我们要找到这个办法

13:50.530 --> 13:52.370
因为你只要自己包

13:52.370 --> 13:54.050
超市里边的商品这么多

13:54.050 --> 13:56.370
你要自己去做的话

13:56.370 --> 13:57.250
那么可能比较麻烦

13:57.250 --> 13:59.250
你希望有一个程序来帮你算这个东西

13:59.250 --> 14:00.370
所以我们要找到一种办法

14:01.410 --> 14:02.930
那你如果说按照你来做的话

14:02.930 --> 14:03.490
你怎么做啊

14:04.610 --> 14:05.730
这问题还不好做

14:05.730 --> 14:06.130
对吧

14:06.130 --> 14:07.570
你拿看到一件物品

14:07.570 --> 14:09.810
比较说你从超市进门开始

14:09.810 --> 14:10.850
就一个一个看

14:10.850 --> 14:11.730
看第一件物品

14:11.730 --> 14:13.010
它到底要不要拿呢

14:13.650 --> 14:14.930
拿还是不拿

14:14.930 --> 14:15.650
是一个问题啊

14:16.530 --> 14:16.850
对不对

14:17.810 --> 14:21.410
我们肯定是倾向于拿什么呢

14:21.410 --> 14:24.050
拿那种它体积又小

14:24.770 --> 14:26.050
价值又高的东西

14:26.690 --> 14:26.930
对吧

14:26.930 --> 14:28.290
我们肯定是比较有赚时

14:28.290 --> 14:29.650
咱们直接拿赚时

14:29.650 --> 14:30.450
体积很小

14:30.450 --> 14:31.090
价值很高

14:31.730 --> 14:32.450
对不对

14:32.450 --> 14:36.050
但是如果说我们只按照这种做法来的话

14:36.050 --> 14:38.370
就一定能够找到最优点吗

14:39.490 --> 14:40.050
那不一定

14:41.010 --> 14:41.730
然后我举个例子

14:42.770 --> 14:45.650
比方说我们在超市里边的时候

14:45.730 --> 14:48.450
遇到了有这么一件商品

14:48.450 --> 14:49.890
它体积很小

14:49.890 --> 14:50.930
价值很大

14:50.930 --> 14:52.610
然后比方说我们的背包体积

14:54.130 --> 14:56.610
背包体积是一般

14:57.330 --> 14:58.290
假设啊

14:58.290 --> 15:00.130
我们的商品有这么一些

15:00.130 --> 15:00.930
第一个商品

15:01.970 --> 15:02.930
商品一

15:02.930 --> 15:05.570
它的占用体积是

15:06.770 --> 15:09.570
背包体积我们设小一点吧

15:10.130 --> 15:11.090
设小一点

15:11.090 --> 15:12.530
背包体积是

15:12.530 --> 15:13.730
它占用的体积是

15:15.730 --> 15:17.730
6

15:17.730 --> 15:18.930
它的价值

15:18.930 --> 15:19.810
用price

15:19.810 --> 15:21.170
所以它的价值

15:21.170 --> 15:23.410
价值呢是12

15:23.410 --> 15:24.450
还不错对吧

15:24.450 --> 15:25.170
体积为6

15:25.170 --> 15:25.970
价值为12

15:26.690 --> 15:28.290
然后第二件商品呢

15:29.490 --> 15:31.170
它的体积是

15:31.170 --> 15:32.370
不用10吧

15:32.370 --> 15:33.730
今天我先把问题简化吧

15:34.850 --> 15:36.370
它占用的体积呢是

15:39.410 --> 15:41.010
价值呢为8

15:42.210 --> 15:43.570
第三件商品呢

15:43.570 --> 15:44.610
它占用的体积

15:45.810 --> 15:50.130
为6

15:50.930 --> 15:52.130
为4

15:53.010 --> 15:54.130
价值呢为2

15:55.490 --> 15:56.370
后边的商品呢

15:56.370 --> 15:57.730
占用的体积呢为

16:00.610 --> 16:01.410
我这个问题呢

16:01.410 --> 16:01.890
还不是

16:03.490 --> 16:04.610
我看一下啊

16:04.610 --> 16:06.610
这个问题应该怎么弄

16:06.610 --> 16:08.290
才能够把这个道理说明白

16:11.430 --> 16:11.910
这个呢

16:12.550 --> 16:12.870
7

16:15.880 --> 16:16.600
12

16:20.200 --> 16:21.480
这个呢为3

16:27.590 --> 16:27.830
是

16:29.270 --> 16:29.590
5

16:30.550 --> 16:31.830
这个呢是2

16:33.590 --> 16:33.830
为

16:34.870 --> 16:35.510
为多少啊

16:36.870 --> 16:37.590
为3

16:39.750 --> 16:41.190
好咱们来看一下啊

16:41.190 --> 16:42.230
如果说你只

16:43.270 --> 16:44.950
只追求性价比的话

16:44.950 --> 16:46.070
好像这个问题还不行

16:46.790 --> 16:47.830
性价比最高的是谁

16:48.790 --> 16:49.910
性价比最高就是

16:49.910 --> 16:50.870
用它的价值

16:50.870 --> 16:52.470
处于它的体积对吧

16:52.470 --> 16:54.630
这问题就是单位体积的价值最高

16:54.630 --> 16:54.870
对不对

16:54.870 --> 16:55.750
所以性价比最高

16:56.470 --> 16:56.870
但是呢

16:56.870 --> 16:58.070
性价比最高的你看一下

16:58.070 --> 16:58.790
这里边

16:58.790 --> 17:00.390
性价比最高的肯定是它

17:00.470 --> 17:01.990
但是如果说你装了它的话

17:01.990 --> 17:03.510
你会发现并不是最优点

17:04.230 --> 17:04.950
你装了它

17:04.950 --> 17:05.430
你怎么装

17:06.070 --> 17:06.790
装它

17:06.790 --> 17:08.230
是不是就占用了空间为6

17:08.230 --> 17:09.270
是不是还剩四个空间

17:09.830 --> 17:10.630
它装不下了吧

17:11.430 --> 17:12.470
四个空间是不是它

17:12.470 --> 17:13.750
它和它选一个

17:13.750 --> 17:14.870
四个空间有去选它吗

17:15.510 --> 17:15.990
17

17:16.870 --> 17:17.990
是不是得到得到

17:17.990 --> 17:19.430
目前的最高价值是17

17:20.630 --> 17:21.110
对不对

17:21.110 --> 17:21.510
但是呢

17:21.510 --> 17:22.710
我们是不是还有更有血

17:22.710 --> 17:23.110
哎

17:23.110 --> 17:23.510
好像

17:24.470 --> 17:25.670
好像这个问题也不对啊

17:27.030 --> 17:27.590
嗯

17:27.590 --> 17:28.550
我看一下怎么来

17:28.550 --> 17:29.830
这个就为9吧

17:29.910 --> 17:30.950
没有为9

17:32.310 --> 17:32.710
呃

17:33.430 --> 17:33.910
这个呢

17:33.910 --> 17:34.230
我也

17:34.870 --> 17:35.350
实施

17:36.150 --> 17:36.550
这样子

17:36.550 --> 17:37.430
我们9.9

17:37.430 --> 17:38.390
来说明这个问题

17:39.110 --> 17:40.710
只要能够把这个问题说明就行了

17:42.070 --> 17:42.550
9.9

17:43.110 --> 17:44.070
好比方说啊

17:44.070 --> 17:44.230
这

17:45.110 --> 17:46.550
性价比最高的是不是还是它

17:47.190 --> 17:47.990
性价比最高的

17:48.470 --> 17:50.550
那么按照按照如果说你要装它的话

17:50.550 --> 17:52.630
那么我们剩下的就是2和3装一个

17:52.630 --> 17:54.310
那么只能装价值最高的

17:54.310 --> 17:55.190
是不是装了一个

17:55.910 --> 17:56.390
5

17:56.390 --> 17:57.910
那么加它就是17

17:57.990 --> 17:59.190
但是是不是还有更压

17:59.190 --> 18:00.070
更优的解

18:00.070 --> 18:00.790
怎么解

18:00.790 --> 18:01.190
就它

18:02.470 --> 18:03.830
占用空间为5

18:03.830 --> 18:05.110
它占用空间为3

18:05.110 --> 18:06.150
它占用空间为2

18:06.150 --> 18:07.030
是刚好装嘛

18:07.030 --> 18:07.750
那么

18:07.750 --> 18:09.430
是不是得到的空间是9.9

18:09.430 --> 18:10.630
加5加3

18:10.630 --> 18:11.590
是多少吧

18:11.590 --> 18:12.470
是不是就是

18:14.470 --> 18:15.350
17.9

18:16.550 --> 18:16.870
对不对

18:17.430 --> 18:18.710
说还有更优的解

18:18.710 --> 18:20.950
但是如果说你只去考虑性价比的话

18:21.510 --> 18:22.790
那就是另外一种算法

18:22.790 --> 18:23.750
就是贪心算法

18:24.790 --> 18:26.070
贪心算法就非常简单

18:27.030 --> 18:28.390
我就看目前最好的

18:28.390 --> 18:29.270
我不管以后

18:29.270 --> 18:30.230
以后的我管都不管

18:30.230 --> 18:31.510
我就看目前最好的

18:32.790 --> 18:33.910
看到一个性价比高了

18:33.910 --> 18:34.870
直接就铺上去了

18:34.870 --> 18:36.630
我根本就不管以后

18:36.630 --> 18:37.670
那么就是贪心算法

18:37.670 --> 18:38.950
贪心算法比较简单

18:38.950 --> 18:40.310
那么这样做出来的话

18:40.310 --> 18:41.910
它并不是一定是最优解

18:41.910 --> 18:42.870
能理解这个意思吧

18:45.350 --> 18:46.390
能理解这一块

18:46.390 --> 18:47.270
这一块能理解

18:49.910 --> 18:50.710
能理解这个意思啊

18:50.710 --> 18:52.070
不理解就要打出你的问题啊

18:54.000 --> 18:55.360
所以说这个问题怎么办呢

18:56.240 --> 18:57.520
我觉得这个问题还不简单

18:58.240 --> 18:58.880
这个问题呢

18:58.880 --> 19:00.960
你只能用穷举的思想

19:00.960 --> 19:01.920
什么叫穷举的思想呢

19:01.920 --> 19:02.240
就是说

19:03.120 --> 19:04.560
这个东西啊

19:04.560 --> 19:06.560
不管它跟性价比就没有关系了

19:07.280 --> 19:09.760
我拿它和不拿它

19:09.760 --> 19:11.600
会影响到以后的

19:12.320 --> 19:13.840
那我就怎么怎么做呢

19:13.840 --> 19:16.160
我就尝试着去拿一下

19:16.160 --> 19:17.120
拿了过后

19:17.120 --> 19:18.800
我看一下后边又怎么办

19:19.760 --> 19:20.080
好

19:20.080 --> 19:22.320
如果说拿了过后得到一个价值

19:22.320 --> 19:24.240
然后不拿它又得到另一个价值

19:24.240 --> 19:25.280
我们来比较一下

19:25.840 --> 19:27.680
来注意中来决定这件东西

19:27.680 --> 19:28.560
我到底拿不拿

19:29.280 --> 19:30.000
只能这样做

19:30.560 --> 19:31.120
因为只能

19:31.120 --> 19:33.120
因为我们现在每一个选项

19:33.120 --> 19:34.480
我们每一个选择

19:34.480 --> 19:35.680
都会影响到后续的

19:36.240 --> 19:37.120
这就是背包问题

19:39.480 --> 19:39.800
好

19:39.800 --> 19:41.160
咱们来看一下

19:41.160 --> 19:42.200
我们的问题描述啊

19:42.840 --> 19:44.760
有一个背包容级为C

19:44.760 --> 19:46.440
能装体积为C的东西

19:47.240 --> 19:48.680
现在有一个物品列表

19:48.680 --> 19:49.960
这个每一个物品的是一个对象

19:50.840 --> 19:51.560
对象呢

19:51.560 --> 19:52.600
它里面有两个属性

19:52.600 --> 19:54.280
一个是它占用了体积

19:54.280 --> 19:55.560
一个是它的价值

19:55.640 --> 19:56.440
就这两个东西

19:57.560 --> 19:59.480
问如何选择

19:59.480 --> 20:00.680
装入背包的物品

20:01.640 --> 20:04.680
使装入背包的物品的总价值最大

20:04.680 --> 20:05.960
这是个求最优秀

20:05.960 --> 20:06.680
很多时候啊

20:07.320 --> 20:08.520
像动态规划

20:09.720 --> 20:11.800
都可以解决这种最优秀的问题

20:11.800 --> 20:13.640
但是不是一定要用动态规划的

20:14.840 --> 20:15.080
好

20:15.080 --> 20:15.640
咱们来看一下

20:15.640 --> 20:16.600
我们的目前

20:16.600 --> 20:18.440
希望你实现一个什么样的函数

20:18.440 --> 20:19.640
这个函数的名字叫package

20:20.200 --> 20:21.080
背包

20:21.080 --> 20:22.440
传入一个背包体积

20:23.480 --> 20:24.840
传入一个物品列表

20:25.960 --> 20:27.240
把这个物品列表传给你

20:28.200 --> 20:28.680
然后呢

20:28.680 --> 20:31.480
你要给我返回一个最大价值

20:31.480 --> 20:33.800
就是你能得能够得到的最大价值

20:33.800 --> 20:34.200
啥意思

20:34.200 --> 20:35.720
比较下面一个测试啊

20:35.720 --> 20:36.520
我有一个数组

20:36.520 --> 20:38.040
这里这里边有一些物品

20:38.040 --> 20:39.560
每个物品只能选一次

20:39.560 --> 20:40.120
选了就没了

20:40.920 --> 20:42.120
就是要领意背包问题嘛

20:42.120 --> 20:42.680
要么就选

20:42.680 --> 20:43.320
要么就不选

20:44.680 --> 20:46.040
有很多种物品

20:46.040 --> 20:46.600
每种物品呢

20:46.600 --> 20:47.960
还有不同的体积

20:47.960 --> 20:48.840
有不同的价值

20:49.720 --> 20:51.160
这是它的列表

20:51.160 --> 20:51.560
然后呢

20:51.560 --> 20:53.560
我的背包体积呢是40

20:54.360 --> 20:55.000
那么传入

20:55.640 --> 20:56.520
背包体积

20:56.520 --> 20:58.600
传入了一个物品的列表

20:58.600 --> 21:00.920
我希望呢得到一个结果

21:00.920 --> 21:01.960
就是它最大价值

21:01.960 --> 21:03.000
比方说这里呢

21:03.000 --> 21:04.440
我之前算过的啊

21:04.440 --> 21:05.800
最大价值应该是39

21:06.680 --> 21:07.960
怎么来的这个39

21:07.960 --> 21:09.080
它是这个几个

21:09.080 --> 21:10.280
在组合起来的啊

21:10.280 --> 21:10.760
选他

21:13.170 --> 21:13.570
这样子

21:14.850 --> 21:15.250
选他

21:16.370 --> 21:16.690
选

21:19.170 --> 21:20.130
我有点忘了

21:20.130 --> 21:21.330
到底选哪一个

21:21.330 --> 21:22.290
选他好像是

21:23.730 --> 21:24.530
哎不对

21:24.530 --> 21:25.090
不是选他

21:25.730 --> 21:26.130
选他

21:27.090 --> 21:27.890
选

21:28.930 --> 21:29.970
这是多少了

21:29.970 --> 21:30.530
28

21:31.330 --> 21:35.030
哎我有点忘了

21:35.030 --> 21:36.070
总之是39

21:36.070 --> 21:36.870
你们看一下

21:36.870 --> 21:37.910
应该选哪几个呀

21:38.710 --> 21:39.590
应该选哪几个

21:39.590 --> 21:40.310
我有点忘了啊

21:40.870 --> 21:41.510
我有点忘了

21:41.510 --> 21:45.120
总之它的得到价值应该是39啊

21:45.120 --> 21:46.080
我之前算过的

21:46.080 --> 21:47.120
这个我会有意识办法

21:47.120 --> 21:48.160
靠人工还算不出来

21:49.280 --> 21:50.720
总之应该是39

21:51.280 --> 21:51.680
那么

21:52.480 --> 21:53.360
怎么去解这个问题

21:53.360 --> 21:54.160
我们关注的是

21:54.160 --> 21:55.120
怎么去解这个问题

21:56.080 --> 21:56.800
怎么解呢

21:56.800 --> 21:58.640
我们就可以用动态规划的思想

21:58.640 --> 21:59.680
动态规划的思想

21:59.760 --> 22:00.480
动态规划的思想

22:00.480 --> 22:01.680
我刚才说了有两个层面

22:01.680 --> 22:02.880
一个是状态转移方程

22:02.880 --> 22:03.920
这是最晚发展的

22:03.920 --> 22:05.120
一个是缓存表

22:05.120 --> 22:06.400
缓存表我们可以放一边

22:06.400 --> 22:07.200
因为缓存的话

22:07.200 --> 22:08.160
我们最后

22:08.160 --> 22:09.200
单独来弄一下都可以

22:09.200 --> 22:10.160
像刚才那个

22:10.160 --> 22:11.200
菲伯拉基数列一样

22:11.200 --> 22:12.720
最后再弄一下缓存都可以

22:12.720 --> 22:13.200
但是

22:13.200 --> 22:14.320
状态转移方程

22:14.320 --> 22:15.200
我们必须要列出来

22:15.200 --> 22:16.160
不然那个背包问题

22:16.160 --> 22:17.920
不然个动态规划就解不出来

22:17.920 --> 22:19.200
代码结构都不知道

22:20.080 --> 22:21.040
那怎么来解呢

22:21.600 --> 22:22.720
看下面有个分析

22:25.480 --> 22:26.440
我们假设

22:27.400 --> 22:28.440
有很多件物品

22:28.440 --> 22:29.640
比方说就I件物品

22:30.600 --> 22:31.880
有很多件物品

22:33.800 --> 22:35.400
有N件吧

22:35.400 --> 22:36.280
我们有N件物品

22:41.440 --> 22:42.160
有很多物品

22:44.550 --> 22:46.150
物品的体积呢

22:46.150 --> 22:47.990
是V1

22:47.990 --> 22:48.870
用V来表示

22:48.870 --> 22:49.750
它是一个数组

22:49.750 --> 22:50.150
对吧

22:50.150 --> 22:51.350
只不过我们GS里边

22:51.350 --> 22:53.350
把它全放到对象里边去了

22:53.350 --> 22:53.750
没关系

22:53.750 --> 22:54.630
都是一样道理

22:55.190 --> 22:56.150
物品的体积呢

22:56.150 --> 22:56.710
是一个数组

22:57.350 --> 22:58.950
第一件物品占用的体积

22:58.950 --> 22:59.750
为V0

22:59.750 --> 23:00.790
第二件物品的占用的体积

23:00.790 --> 23:01.430
为V1

23:01.430 --> 23:03.110
都用一个东西来表示

23:03.110 --> 23:03.590
一个数列

23:04.390 --> 23:04.790
然后呢

23:04.790 --> 23:05.750
我们的每一个物品呢

23:05.750 --> 23:06.710
也有价值

23:06.710 --> 23:08.150
它又形成了一个数列

23:08.150 --> 23:08.710
叫P

23:08.710 --> 23:09.830
我们用Price吧

23:10.470 --> 23:11.430
P0到PN

23:12.390 --> 23:13.830
我们现在要求的是

23:15.350 --> 23:15.830
注意

23:15.830 --> 23:17.030
最后啊

23:17.030 --> 23:17.670
我们要去

23:19.110 --> 23:20.870
背包的生育空间为Rest

23:21.990 --> 23:23.830
我们通过拿去拿这些物品

23:23.830 --> 23:25.030
去选这些物品

23:25.030 --> 23:26.790
能够得到最U的价值

23:27.510 --> 23:28.870
那么我们可以立个方程出来

23:29.510 --> 23:31.750
假设我们选D

23:31.750 --> 23:33.270
就是遇到了D I件物品

23:34.550 --> 23:36.150
D I件物品

23:36.150 --> 23:37.110
就从这里开始啊

23:37.110 --> 23:37.590
比方说

23:37.590 --> 23:38.070
举个例子

23:38.950 --> 23:40.390
我们前面的物品不看了

23:40.390 --> 23:41.350
看都不看了

23:41.350 --> 23:42.470
我们只看

23:42.470 --> 23:43.590
从D I件比方说

23:43.590 --> 23:44.630
I等于2

23:44.630 --> 23:45.110
那么也就说

23:45.110 --> 23:46.070
我们只看这一部分

23:49.250 --> 23:50.290
只看这一部分

23:50.290 --> 23:50.770
注意听哦

23:50.770 --> 23:51.570
这一块比较糟

23:52.210 --> 23:52.930
就前面的物品

23:52.930 --> 23:54.290
我们假设不看

23:54.290 --> 23:55.570
我们只看这一部分

23:56.530 --> 23:57.410
那么这一部分

23:57.410 --> 23:59.010
也就说只看这件物品

24:00.130 --> 24:01.170
I从这里开始

24:01.810 --> 24:03.170
I等于2嘛

24:03.170 --> 24:03.890
I从这里开始

24:03.890 --> 24:04.370
假设啊

24:05.250 --> 24:05.890
我们如果说

24:05.890 --> 24:07.250
只看这一个区域

24:07.250 --> 24:08.770
我们可以列出一个方程

24:08.770 --> 24:10.290
用FI REST

24:10.290 --> 24:10.930
什么叫REST

24:10.930 --> 24:12.850
就是目前的剩余空间

24:13.730 --> 24:14.370
目前还

24:14.370 --> 24:15.730
背包里边还剩多少空间

24:16.370 --> 24:17.330
比方前面两个物品

24:17.330 --> 24:17.810
有可能选了

24:17.810 --> 24:18.290
有可能没选

24:18.290 --> 24:19.010
不管

24:19.010 --> 24:20.130
反正目前的背包

24:20.130 --> 24:21.010
还剩这么多空间

24:21.730 --> 24:22.690
也就我们的问题呢

24:22.690 --> 24:23.730
就描述成为了

24:24.210 --> 24:26.290
从D I件物品开始

24:26.290 --> 24:27.490
我如何选

24:28.290 --> 24:30.210
才能把这个剩余空间

24:30.210 --> 24:31.330
发挥到最大价值

24:32.450 --> 24:33.570
那么如果说

24:33.570 --> 24:35.330
这个函数来表示最大价值的话

24:36.210 --> 24:37.010
那么这个函数

24:38.610 --> 24:39.410
跟那个

24:39.410 --> 24:41.090
它就是一个重叠的值问题

24:41.090 --> 24:42.370
因为你I可以等于2

24:42.370 --> 24:43.170
I也可以等于3

24:43.810 --> 24:44.210
对不对

24:45.090 --> 24:45.890
I也可以等于3

24:47.910 --> 24:48.470
这一部分

24:49.110 --> 24:50.710
I也可以等于1

24:52.230 --> 24:53.590
I也可以等于0

24:53.590 --> 24:54.390
等于0的时候

24:54.390 --> 24:56.150
是不是就是我们要求的东西

24:56.550 --> 24:56.870
对吧

24:57.910 --> 24:58.790
等于0的时候

24:58.790 --> 24:59.910
是不是就是我们要求的东西

25:00.710 --> 25:01.110
对不对

25:01.750 --> 25:03.430
所以说I可以等于任何一个值

25:03.430 --> 25:04.470
是不是重叠值问题

25:05.270 --> 25:06.310
就跟那个非布拉奇数列

25:06.310 --> 25:07.270
是不是一样的道理

25:07.270 --> 25:08.150
Fn

25:08.150 --> 25:09.110
Fn也可以

25:09.110 --> 25:09.910
Fn-1也可以

25:09.910 --> 25:10.870
Fn-2也可以

25:10.870 --> 25:11.590
Fn-3

25:11.590 --> 25:12.630
不都是重叠值问题

25:13.430 --> 25:14.230
就这么个意思

25:15.430 --> 25:15.990
那么

25:15.990 --> 25:17.510
这个重叠值问题

25:17.510 --> 25:19.030
它跟其他的重叠值问题之间

25:19.030 --> 25:20.070
有什么样的关系呢

25:21.990 --> 25:23.110
下面一个

25:24.710 --> 25:25.110
式子

25:25.670 --> 25:26.790
你把这个式子看懂了

25:26.790 --> 25:27.510
背包问题了

25:27.510 --> 25:27.910
基本上

25:28.630 --> 25:29.990
总体的思路就有了

25:31.350 --> 25:32.150
我们如果说

25:32.150 --> 25:34.150
要求D I件物品开始

25:34.150 --> 25:34.710
比方说

25:34.710 --> 25:35.910
我们要求的是这一部分

25:35.910 --> 25:36.550
I等于1

25:37.990 --> 25:39.190
生于空间为rest

25:40.470 --> 25:41.750
这一部分的最优点

25:42.550 --> 25:43.830
它应该等于什么呢

25:44.390 --> 25:45.590
应该等于

25:45.590 --> 25:47.750
选这一个DI件物品

25:47.750 --> 25:49.510
到底选和不选

25:50.550 --> 25:52.230
两个求一个最优

25:52.230 --> 25:52.710
啥意思

25:53.750 --> 25:54.310
你看这里

25:55.270 --> 25:56.310
这是一个表达式

25:56.950 --> 25:58.310
这是一个表达式

25:58.310 --> 25:59.030
我们一个个看

25:59.750 --> 26:01.590
左边的表达式是什么意思呢

26:01.590 --> 26:03.750
就是说我要选DI件物品

26:03.750 --> 26:04.310
I等于1

26:04.470 --> 26:05.270
比方说I等于1

26:05.750 --> 26:07.430
我要选DI件物品

26:08.070 --> 26:09.190
你说这个东西我要选

26:10.470 --> 26:11.990
那么选了过后

26:11.990 --> 26:13.590
我的最大价值应该多少呢

26:13.590 --> 26:15.030
就是我选了过后

26:15.030 --> 26:16.070
是不是加上一个pi

26:16.070 --> 26:16.550
对吧

26:16.550 --> 26:17.750
把这个价值加上

26:17.750 --> 26:18.630
加上什么呢

26:18.630 --> 26:20.150
加上后面的

26:22.150 --> 26:22.790
最大价值

26:24.470 --> 26:25.110
对不对

26:25.110 --> 26:26.070
就加上后边了

26:26.630 --> 26:27.910
从I加1开始

26:28.550 --> 26:29.990
生于空间是不是减少了

26:29.990 --> 26:31.190
生于空间是不是rest

26:31.190 --> 26:32.230
减去了v1

26:33.190 --> 26:34.310
是不是减去了v1

26:34.870 --> 26:35.430
再来看一下

26:35.430 --> 26:36.470
我再给大家画一下

26:39.590 --> 26:41.350
就是说如果说I等于

26:41.350 --> 26:42.150
比方I等于0

26:43.110 --> 26:43.830
I等于0

26:44.550 --> 26:45.830
那么它的最大价值

26:45.830 --> 26:46.710
应该等于什么呢

26:46.710 --> 26:47.830
我们就必须要立出一个

26:47.830 --> 26:48.870
状态转移方程

26:50.150 --> 26:50.950
就像等于

26:50.950 --> 26:53.830
如果说我选了DI件

26:53.830 --> 26:54.790
就是选了它

26:55.590 --> 26:57.030
选了它是不是空间就减少了

26:57.590 --> 26:58.230
是不是rest

26:58.230 --> 26:59.110
是要减vi

26:59.830 --> 27:00.710
所以减去它

27:00.710 --> 27:01.670
所以空间就减少了

27:02.310 --> 27:04.150
那么在减少过后

27:05.430 --> 27:07.350
然后在生于的物品中

27:07.350 --> 27:08.630
选出一个最大价值

27:09.270 --> 27:11.030
加上我们这个价值

27:11.030 --> 27:12.390
所以相加

27:12.390 --> 27:15.110
就是我选它的最大价值

27:16.230 --> 27:17.190
但是我有可能选它

27:17.190 --> 27:18.070
有可能不选它

27:18.630 --> 27:20.550
那如果说我不选它的话

27:20.550 --> 27:20.950
你看啊

27:21.910 --> 27:23.110
如果说方I是选了

27:23.750 --> 27:24.630
现在我们还是

27:24.630 --> 27:25.350
要算这个vi

27:27.590 --> 27:28.310
方I是选

27:28.310 --> 27:28.950
现在是不选

27:29.510 --> 27:30.710
不选它的话

27:30.710 --> 27:32.230
那么我们是不是空间不变

27:32.950 --> 27:34.790
直接就略过这一项

27:34.790 --> 27:36.070
直接看后边的

27:37.750 --> 27:38.470
空间不变

27:38.470 --> 27:39.590
你看rest空间不变

27:40.390 --> 27:40.950
然后呢

27:40.950 --> 27:42.870
把I加1看下一项

27:44.070 --> 27:45.830
从下一项开始的最大价值

27:46.390 --> 27:47.430
那么我也说不选

27:47.430 --> 27:49.030
不选当前这个产品的话

27:49.030 --> 27:49.990
那么就一意味着

27:49.990 --> 27:51.190
我目前的最大价值

27:51.190 --> 27:53.990
就等于生于的最大价值

27:55.030 --> 27:56.390
你看是不是有两种情况

27:56.390 --> 27:57.110
一是选

27:57.670 --> 27:58.550
第二种是不选

27:59.510 --> 28:01.110
选和不选之间

28:01.190 --> 28:02.870
我们来求一个max

28:03.750 --> 28:04.470
就我们看一下

28:04.470 --> 28:05.830
到底选它好了

28:05.830 --> 28:07.110
还是不选它好

28:07.110 --> 28:08.630
把两个值算出来

28:08.630 --> 28:09.430
我们来求最大

28:10.070 --> 28:10.790
哪个最大

28:10.790 --> 28:11.350
就哪个好

28:11.910 --> 28:12.870
能理解吧

28:12.870 --> 28:13.830
这就是背包问题的

28:13.830 --> 28:15.030
状态转移方程

28:15.030 --> 28:16.470
你能够把这个状态转移方程

28:16.470 --> 28:17.830
开头看懂的话

28:17.830 --> 28:18.790
那么基本上

28:18.790 --> 28:19.350
这个题呢

28:19.830 --> 28:20.710
就八九不理识了

28:25.670 --> 28:26.390
最长的其实就是

28:26.390 --> 28:27.190
状态转移方程

28:28.310 --> 28:28.950
能听懂吗

28:28.950 --> 28:29.350
这一块

28:31.190 --> 28:31.990
现在不写代码

28:32.070 --> 28:32.950
现在不着急写代码

28:32.950 --> 28:33.590
我们把这个

28:34.150 --> 28:35.510
到底的逻辑理性出

28:36.310 --> 28:36.950
能理解吧

28:38.150 --> 28:39.590
因为这个逻辑理解不了的话

28:39.590 --> 28:40.550
那一会儿的代码

28:40.550 --> 28:41.430
肯定是理解不了的

28:43.810 --> 28:44.530
其他同学呢

28:45.250 --> 28:46.210
其他同学还在晕吗

28:48.230 --> 28:49.110
我再说一次

28:49.830 --> 28:50.550
我再说一次

28:54.400 --> 28:56.080
你去超市里边拿东西

28:56.080 --> 28:57.200
往背包里边塞东西

28:58.000 --> 28:59.040
你就一线物品

28:59.040 --> 28:59.680
一线物品看

29:00.400 --> 29:01.440
是不是每一件物品

29:01.440 --> 29:02.480
只有两种情况

29:02.480 --> 29:04.000
不可能有第三种情况了

29:04.000 --> 29:05.840
不可能是什么量子叠加态

29:05.840 --> 29:07.200
到底选和不选是叠加态

29:07.200 --> 29:07.760
不可能了

29:08.240 --> 29:09.440
要么就选他

29:09.440 --> 29:10.640
要么就不选他

29:10.640 --> 29:11.760
总有一个是最优的

29:11.760 --> 29:12.320
对吧

29:12.320 --> 29:12.800
选他

29:13.440 --> 29:14.480
会不会导致最优呢

29:14.480 --> 29:15.520
要么就是不选他

29:15.520 --> 29:17.200
要么会是不是导致最优呢

29:17.200 --> 29:18.560
是不是只有这两种情况

29:18.560 --> 29:20.160
所以说我们列出一个方程

29:20.160 --> 29:20.560
就是说

29:21.200 --> 29:22.720
如果说我要去求

29:24.160 --> 29:25.600
第I件商品开始

29:26.320 --> 29:27.360
比较I等于0

29:27.360 --> 29:29.280
这个I是可以不断的变化的

29:29.280 --> 29:30.000
因为它是重叠

29:30.000 --> 29:31.040
指问题都是一样的

29:31.840 --> 29:33.440
我们假设I等于0

29:35.920 --> 29:36.480
写一下吧

29:38.160 --> 29:39.280
假设I等于0

29:43.380 --> 29:44.420
这种情况下

29:45.220 --> 29:47.620
我到底要不要选这件商品

29:47.620 --> 29:49.540
就这东西我到底要不要选

29:49.540 --> 29:50.420
只有两种情况

29:50.420 --> 29:51.540
要么要选和不选

29:52.100 --> 29:53.860
我在要选和不选之间

29:53.860 --> 29:54.820
找一个最优的

29:54.820 --> 29:55.060
对吧

29:55.060 --> 29:56.100
到底选还是不选

29:56.100 --> 29:57.380
这我不知道啊

29:57.380 --> 29:58.660
我不知道到底要不要选

29:58.660 --> 30:00.020
所以我两个都必须要算

30:00.660 --> 30:02.580
如果说我选他会怎么样

30:02.580 --> 30:04.100
如果说我不选他会怎么样

30:04.740 --> 30:06.260
那如果说我选他的话

30:06.900 --> 30:08.100
价值是应该怎么算的

30:08.100 --> 30:09.380
价值是不是就是

30:09.380 --> 30:11.620
当前这个商品的价值选了他

30:12.340 --> 30:13.300
他的价值要加上

30:13.300 --> 30:14.500
因为我算的就是最大价值

30:15.060 --> 30:20.420
他的价值加上生于的部分最大价值

30:21.780 --> 30:22.660
我就选他了

30:22.660 --> 30:24.580
我背包里边少了一个空间了

30:25.220 --> 30:27.780
然后我在生于的空间里边去找最大价值

30:27.780 --> 30:29.780
是不是就是选他的最大价值

30:30.420 --> 30:30.820
对不对

30:30.820 --> 30:31.460
所以说他可以放

30:31.460 --> 30:33.380
他的列出来的式子就是应该是这个

30:33.380 --> 30:34.100
PI

30:34.100 --> 30:36.020
当前那个商品的价值加上

30:37.220 --> 30:38.260
我这个商品不看了

30:38.260 --> 30:38.900
你选都选了

30:38.900 --> 30:39.300
对吧

30:39.300 --> 30:39.940
不看了

30:39.940 --> 30:40.580
我直接看

30:40.660 --> 30:41.540
从后边开始看

30:42.260 --> 30:44.020
看后边开始的那一位

30:44.740 --> 30:46.340
空间减少了PI

30:46.340 --> 30:47.700
因为他选了他空间就减少了

30:47.700 --> 30:47.940
吗

30:48.660 --> 30:50.500
减少了过后他的最大价值

30:51.540 --> 30:52.900
加上我的价值

30:52.900 --> 30:54.900
是不是我选他的最大价值

30:56.820 --> 30:57.380
就理解了

30:58.100 --> 30:59.060
因为我要看两个吧

30:59.060 --> 30:59.940
选他和不选他

31:00.740 --> 31:01.060
好

31:01.060 --> 31:03.060
选他就选他的最大价值就算出来了

31:04.420 --> 31:06.020
那如果说我不选他的话

31:06.980 --> 31:07.620
我不选这个

31:08.900 --> 31:09.380
不选他

31:09.940 --> 31:10.660
不选他的话

31:10.660 --> 31:12.340
那这个商品是不是直接就略过了

31:13.300 --> 31:15.140
略过这个商品过后

31:16.100 --> 31:18.340
生于商品的最大价值

31:18.340 --> 31:19.300
是不是就等于

31:20.180 --> 31:21.780
不选他的最大价值

31:21.780 --> 31:22.980
就是我这个商品我不选了

31:22.980 --> 31:25.140
是不是就跟他相当于是直接略过了

31:25.140 --> 31:26.900
是不是就直接变成这个式子

31:27.540 --> 31:28.580
我就不看了

31:28.580 --> 31:30.020
直接从下一位开始看

31:30.020 --> 31:31.140
空间不变

31:31.140 --> 31:34.020
就是你把背个空包包跑到第一个商品面前

31:34.020 --> 31:34.660
我不选他了

31:35.380 --> 31:36.580
这个商品就跟你没关系了

31:36.580 --> 31:38.100
我直接是不是又看下一个

31:38.100 --> 31:38.500
对吧

31:38.580 --> 31:39.700
空间是不是不变

31:39.700 --> 31:41.460
我直接看下一个空间不变

31:41.460 --> 31:44.580
那么在生于的东西找到最大价值

31:44.580 --> 31:45.940
是不是有两种情况就出来了

31:45.940 --> 31:46.660
第一种情况

31:47.540 --> 31:49.780
选他的价值最大价值

31:49.780 --> 31:51.300
和不选他的最大价值

31:51.860 --> 31:52.580
是不是就算出来了

31:54.740 --> 31:56.660
选他的和不选他的

31:57.380 --> 31:58.580
那么总有一个是最优的

31:58.580 --> 31:59.700
那到底要不要选他呢

31:59.700 --> 32:01.220
你要两个都要算出来

32:01.220 --> 32:02.260
算出来的过后

32:02.900 --> 32:05.140
我在两个之间求最大值

32:06.020 --> 32:06.980
是不是就是最优节

32:07.540 --> 32:07.860
对吧

32:10.280 --> 32:12.440
这个玩意就是状态转移方程

32:13.880 --> 32:15.720
他要算的是什么呢

32:15.720 --> 32:17.160
不是给你一个公式的

32:17.160 --> 32:19.320
你用人工的方式给你一个i

32:19.320 --> 32:20.440
然后你就可以把算出来

32:20.440 --> 32:21.160
不是的

32:21.160 --> 32:26.280
他是要找到每一个重叠值问题之间的关系

32:27.320 --> 32:28.760
他要找这个东西

32:28.760 --> 32:29.560
找关系

32:30.520 --> 32:31.240
你看啊这个

32:32.360 --> 32:34.120
非布拉希数列是不是就在找关系啊

32:34.840 --> 32:36.760
n和n-1到n-2之间

32:36.760 --> 32:38.280
跟他们之间的关系对吧

32:38.280 --> 32:39.000
那么这里呢

32:39.080 --> 32:42.040
他这就是也是重叠值问题之间的关系

32:42.040 --> 32:43.640
但是他没有前面那么简单

32:44.280 --> 32:45.320
他这个要绕一点

32:45.960 --> 32:47.160
但道理都是一样的

32:48.280 --> 32:51.160
这个函数跟这个函数跟这个函数之间

32:51.160 --> 32:52.440
是不是就找出了一个关系

32:53.080 --> 32:53.480
对不对

32:54.680 --> 32:55.640
那么这个问题

32:55.640 --> 32:57.640
只要你能够把这个东西梳理出来

32:58.120 --> 32:59.960
你这个问题就已经差不多了

32:59.960 --> 33:00.600
八九不理解

33:00.600 --> 33:01.800
至少完成一半了

33:01.800 --> 33:03.400
剩下的东西就是写代码了

33:03.400 --> 33:04.600
就考验了大家是

33:04.600 --> 33:06.600
就考验的是大家写代码的能力了

33:07.720 --> 33:08.520
这是这一块

33:12.420 --> 33:12.820
嗯

33:14.920 --> 33:15.400
嗯

33:16.280 --> 33:17.560
嗯不应该这么说啊

33:18.440 --> 33:20.600
动态规划了也不一定是用低规解决

33:20.600 --> 33:21.880
有可能会用循环解决

33:21.880 --> 33:22.920
都可以解决的

33:22.920 --> 33:23.560
实际上呢

33:23.560 --> 33:24.760
从理论上来讲

33:24.760 --> 33:26.760
每一个低规都可以写成循环

33:26.760 --> 33:28.440
每一个循环也都可以写成低规

33:29.160 --> 33:30.840
他们之间是可以相互转换的啊

33:31.400 --> 33:32.600
嗯只不过呢

33:33.160 --> 33:34.360
在某些题里边

33:35.240 --> 33:37.240
动态规划了用低规用起来的

33:37.240 --> 33:38.600
比较好理解一点

33:38.600 --> 33:40.200
这道题你用循环更加不好理解

33:40.840 --> 33:41.320
知道吧

33:42.840 --> 33:44.840
解决动态规划的一种

33:44.840 --> 33:46.120
具体的代码实现

33:46.840 --> 33:47.400
啊

33:47.400 --> 33:48.440
它是应该是这样来说

33:48.440 --> 33:49.480
他们的关系就第一位

33:49.480 --> 33:50.760
它是一个代码实现

33:50.760 --> 33:52.040
它是实现的一种方式

33:55.030 --> 33:57.190
好那么这个东西如果说你能看懂的话

33:57.190 --> 33:58.790
接下来我们这个代码就好写了

33:58.790 --> 33:59.590
就不难了

33:59.830 --> 34:00.310
啊

34:00.310 --> 34:01.270
我们来写一下吧

34:01.270 --> 34:01.910
排写起

34:02.390 --> 34:03.030
解识

34:04.630 --> 34:05.830
啊我们这里写个函数

34:05.830 --> 34:06.550
就排写起

34:06.550 --> 34:07.590
我们把这个复制过来

34:12.550 --> 34:12.950
啊

34:13.910 --> 34:14.310
嗯

34:14.950 --> 34:16.070
我们最终要得到39

34:16.550 --> 34:17.510
来吧这个函数

34:18.470 --> 34:21.190
哎刚才我们列出了那个状态转移方程

34:21.190 --> 34:22.310
函数的规格

34:22.310 --> 34:22.950
什么叫规格

34:22.950 --> 34:24.550
就是这个函数的参数啊

34:24.550 --> 34:26.550
还有那个函数的反回值啊

34:26.550 --> 34:28.070
是不是我们这个这个函数啊

34:28.950 --> 34:29.670
不是哦

34:30.390 --> 34:31.510
不是这个函数

34:31.510 --> 34:32.230
这个函数传的啥呀

34:32.230 --> 34:33.270
背包体积和什么

34:34.310 --> 34:35.190
和物品列表

34:35.750 --> 34:36.950
这里的两个参数是啥

34:38.150 --> 34:38.950
这两个参数是啥

34:38.950 --> 34:39.670
一个是i

34:40.070 --> 34:41.270
就是从第几一个

34:41.270 --> 34:43.190
就是看一下第几个

34:43.190 --> 34:44.710
从第几一个物品开始

34:45.190 --> 34:46.390
觉得的最大价值

34:47.190 --> 34:47.590
对不对

34:48.150 --> 34:49.270
它是这个意思

34:49.270 --> 34:51.510
从第几个物品开始的最大价值

34:51.910 --> 34:52.790
是不是一个数字啊

34:53.270 --> 34:54.310
Race是什么意思啊

34:54.310 --> 34:55.270
生于空间

34:55.830 --> 34:58.150
是不是这两个参数是不一样的

34:58.150 --> 34:58.950
不一样怎么办

34:59.990 --> 35:00.630
不一样怎么办

35:00.630 --> 35:01.990
你在里面写个指函数呗

35:03.190 --> 35:04.310
写成一个指函数啊

35:04.310 --> 35:05.670
不要说名字要做

35:05.670 --> 35:06.630
拍下几把

35:06.630 --> 35:07.270
打一下发现

35:07.910 --> 35:08.470
这个函数呢

35:08.470 --> 35:10.070
我就把它做成这样的参数

35:10.070 --> 35:12.550
因为我们最终要用一个状态转移方程

35:12.550 --> 35:14.470
肯定必须要把这个函数参数

35:14.470 --> 35:15.350
要设置为一致

35:15.990 --> 35:18.630
第一个参数是Race

35:19.030 --> 35:19.830
生于空间

35:20.470 --> 35:21.750
我要求的是这个函数

35:24.310 --> 35:25.350
那么我怎么

35:25.590 --> 35:26.550
我现在假设啊

35:26.550 --> 35:27.830
这个函数已经写好了

35:27.830 --> 35:28.710
已经写好了过后

35:28.710 --> 35:29.670
这个函数怎么求了

35:33.280 --> 35:34.480
里面朋友只知道

35:34.480 --> 35:35.200
假设啊

35:35.200 --> 35:36.240
这个函数已经写好了

35:36.800 --> 35:38.320
假设写好了

35:39.120 --> 35:40.720
比如说这个F函数已经写好了

35:41.760 --> 35:43.280
那么这个函数怎么求

35:51.060 --> 35:51.620
这个函数

35:52.420 --> 35:53.060
能想到吗

35:55.140 --> 35:55.860
我们一会呢

35:55.860 --> 35:57.380
肯定是重头戏在这里边

35:57.940 --> 35:58.420
但是呢

35:58.420 --> 36:00.180
我们先把这个函数写好吧

36:03.650 --> 36:04.770
我刚才不是讲了吗

36:05.810 --> 36:06.770
这个I啥意思啊

36:07.570 --> 36:09.250
从第I个物品开始

36:11.940 --> 36:12.420
计算

36:13.140 --> 36:17.300
第I个物品开始

36:19.520 --> 36:25.200
生于空间为Race的最大价值

36:29.970 --> 36:30.530
这么求啊

36:32.530 --> 36:34.770
这个函数已经写得

36:34.770 --> 36:35.810
不能再明显了啊

36:40.020 --> 36:40.900
生于空间

36:40.900 --> 36:41.700
第I个物品

36:43.460 --> 36:44.020
假设啊

36:44.020 --> 36:45.300
我们这个函数已经写好了

36:46.580 --> 36:48.260
那么你想一想这个道理啊

36:48.260 --> 36:48.900
你看着吧

36:49.940 --> 36:51.300
I等于0的时候

36:51.300 --> 36:52.420
是不是就是我们的解呀

36:53.540 --> 36:54.660
I等于0的时候

36:54.660 --> 36:55.860
是不是就是求

36:55.860 --> 36:57.780
从第0个物品开始

36:58.500 --> 37:00.980
生于空间为背包体积的

37:01.540 --> 37:02.260
最大价值

37:02.260 --> 37:03.300
是不是就是我们要求的解

37:04.340 --> 37:05.620
也就是说啥意思啊

37:05.620 --> 37:06.660
也就是说在这边

37:06.660 --> 37:08.180
我们只需要直接返回

37:08.900 --> 37:09.540
Tactic

37:10.500 --> 37:11.140
I是什么

37:11.140 --> 37:11.700
I是0

37:12.340 --> 37:13.380
生于空间是什么

37:13.380 --> 37:14.180
生于空间是C

37:15.380 --> 37:16.180
对吧

37:16.180 --> 37:16.980
这是生于空间吧

37:16.980 --> 37:18.020
背包体积

37:18.020 --> 37:19.460
我们不就是要求这个东西吗

37:20.580 --> 37:21.460
只不过呢

37:21.460 --> 37:22.580
为什么要写这个函数啊

37:22.580 --> 37:23.540
因为我们要不断的

37:23.540 --> 37:24.900
我们有个状态转移方程

37:25.380 --> 37:26.580
这个I等于0的问题

37:26.580 --> 37:28.260
要转换成I加1的问题

37:28.260 --> 37:28.820
对吧

37:28.820 --> 37:30.660
只不过有一个状态转移方程而已

37:30.660 --> 37:32.100
所以我们写个辅助函数

37:32.100 --> 37:33.300
来完成这个状态转移

37:33.940 --> 37:35.140
但是我们最重要求的

37:35.140 --> 37:36.340
不就是从0

37:36.420 --> 37:38.020
从进入超市的那个

37:38.020 --> 37:39.940
第一个物品开始来找

37:40.740 --> 37:41.700
在生于的物品中

37:41.700 --> 37:42.660
所谓的最大价值

37:42.660 --> 37:43.620
不就是要找这个东西吗

37:44.420 --> 37:44.660
对吧

37:45.620 --> 37:47.140
你首先这个结构要能理解啊

37:48.100 --> 37:49.460
这单码没开始写

37:49.460 --> 37:50.820
好 先让我们写这里边单码

37:52.180 --> 37:53.540
这里边单码最核心的

37:53.540 --> 37:54.180
就是这个东西

37:54.820 --> 37:55.460
就是这个玩意

37:56.580 --> 37:57.060
只不过呢

37:57.060 --> 37:59.060
我们可以加上一些边界条件

37:59.940 --> 38:00.420
什么情况下

38:00.420 --> 38:00.980
我就没法

38:00.980 --> 38:01.940
没法看了

38:01.940 --> 38:03.540
就是超市里边看完了

38:03.540 --> 38:04.340
什么东西都没了

38:05.300 --> 38:07.060
你都看到最后一件商品了

38:07.060 --> 38:08.900
或者是你已经看完了这个超市

38:08.900 --> 38:10.740
那就没有生于

38:10.740 --> 38:11.700
没有这大价值了

38:11.700 --> 38:13.380
所以我们把这些边界条件

38:13.380 --> 38:14.260
给它判断一下

38:14.900 --> 38:15.300
来吧

38:16.180 --> 38:17.940
我们看一下有哪些边界条件

38:17.940 --> 38:19.620
首先有个边界条件就是

38:19.620 --> 38:26.260
i超出了大于等于的速度的长度

38:27.060 --> 38:27.860
这是什么情况

38:29.380 --> 38:30.020
这是什么情况

38:31.300 --> 38:33.220
是不是前边的物品都已经看完了

38:34.020 --> 38:34.820
也就是啥意思呢

38:34.980 --> 38:35.540
就看到这了

38:36.900 --> 38:37.380
看到这了

38:40.630 --> 38:41.670
就是你i看到这了

38:42.470 --> 38:43.430
那里我问大家

38:43.910 --> 38:44.950
如果说看到这了

38:44.950 --> 38:46.150
它的最大价值是多少

38:48.310 --> 38:48.950
就是说

38:48.950 --> 38:50.470
我们一共有10件商品

38:50.470 --> 38:52.630
请问从第11件商品开始看

38:54.470 --> 38:55.430
生于空间为rest

38:55.430 --> 38:56.710
它的最大价值是多少

38:56.710 --> 38:57.830
它只能瞬移了

38:57.830 --> 38:58.630
你还能拿东西吗

38:58.630 --> 38:59.430
没法拿了

38:59.430 --> 39:00.150
物品都没了

39:00.150 --> 39:01.350
所以说只能瞬移

39:01.350 --> 39:01.670
对吧

39:01.670 --> 39:02.550
这个没有疑问吧

39:03.190 --> 39:05.110
这个情况给大家考虑进去

39:05.110 --> 39:05.510
对 创意

39:08.280 --> 39:09.160
还有什么情况呢

39:10.120 --> 39:14.600
就是我当前这个物品

39:15.080 --> 39:16.200
当前这个物品

39:16.200 --> 39:18.760
它体积已经超过了生于空间

39:18.760 --> 39:20.040
比方说你背包体积是30

39:20.600 --> 39:21.960
结果超市里边有一个冰箱

39:22.840 --> 39:23.640
体积是2半

39:24.440 --> 39:25.720
你这个商品能看吗

39:25.720 --> 39:26.360
是不是看不了

39:27.080 --> 39:27.720
是不是看不了

39:28.920 --> 39:29.880
看不了的话是不是

39:30.440 --> 39:31.720
就是生于空间不够

39:32.360 --> 39:33.400
那么这个时候怎么办

39:33.960 --> 39:34.920
什么叫生于空间不够

39:35.560 --> 39:36.920
就是我们拿到当前那个商品

39:37.640 --> 39:38.600
当前那个商品

39:39.320 --> 39:40.120
这个时候大个字

39:41.960 --> 39:44.040
获取当前的商品

39:45.720 --> 39:47.640
当前的商品是不是通过这个I下标

39:47.640 --> 39:48.680
它就是下标嘛

39:48.680 --> 39:51.080
从这个Nest是个物品列表里边去拿

39:51.080 --> 39:52.200
物品列表是个对象

39:52.200 --> 39:52.920
有两个属性

39:52.920 --> 39:53.880
一个是V Number

39:53.880 --> 39:55.160
一个是P也是Number

39:55.880 --> 39:58.600
我们可以通过这个Nest

39:58.600 --> 40:00.840
通过I是不是会获取当前的商品

40:03.920 --> 40:04.640
什么情况下

40:04.640 --> 40:06.560
这个商品是绝对不可能拿到雕的

40:06.960 --> 40:08.000
绝不可能拿到雕

40:08.000 --> 40:09.280
是不是体积不够啊

40:09.280 --> 40:09.920
装不下

40:10.080 --> 40:11.920
你冰箱里面能够装背包吗

40:11.920 --> 40:12.320
装不下

40:12.960 --> 40:13.360
判断

40:13.920 --> 40:15.760
如果说当前那个商品的什么

40:16.960 --> 40:17.760
体积

40:18.480 --> 40:19.920
大于了等于都可以

40:20.240 --> 40:20.960
都可以筛下

40:20.960 --> 40:22.240
但是大于就不行了

40:22.880 --> 40:23.840
大于了什么呢

40:24.400 --> 40:24.800
Rest

40:25.360 --> 40:26.320
是不是生于空间

40:28.740 --> 40:31.540
当前商品的体积

40:32.260 --> 40:34.500
大于了生于空间

40:35.220 --> 40:37.540
那么这种情况下是不是拿不了啊

40:39.380 --> 40:40.500
这件商品

40:40.980 --> 40:42.100
一定拿不了

40:44.840 --> 40:45.880
拿不了怎么办

40:49.650 --> 40:51.650
刚才我给大家列的这个状态转移方程

40:51.650 --> 40:53.410
是最核心的状态转移方程

40:53.410 --> 40:54.930
还有一些边界条件我们要看

40:55.410 --> 40:56.850
所以直接看下一个就完事了

40:57.330 --> 40:58.770
比方说啊我举个例子

40:58.770 --> 41:00.370
你看的I是V0

41:00.370 --> 41:01.570
你看的是第一件商品

41:01.570 --> 41:02.610
但是第一件商品拿不了

41:03.330 --> 41:04.290
拿不了的话

41:05.490 --> 41:07.490
I等于0的情况下

41:07.490 --> 41:10.770
是不是就等于不看第一件

41:10.770 --> 41:11.810
直接看后边

41:12.290 --> 41:13.170
是不是直接看后边

41:13.810 --> 41:15.970
直接看后边是不是就是这个这个这个函数

41:16.530 --> 41:18.530
I加1生于空间不变

41:19.330 --> 41:20.370
对吧直接看下一个

41:20.930 --> 41:21.650
所以完事了

41:23.330 --> 41:25.810
因此呢如果说是这种情况的话

41:26.450 --> 41:27.570
那么这件商品拿不了

41:27.570 --> 41:28.610
拿不了怎么办

41:28.610 --> 41:30.530
直接返回下一个

41:31.330 --> 41:31.890
还可以

41:31.890 --> 41:34.130
I加1生于空间不变

41:35.490 --> 41:37.170
比方说你传了一个零进来

41:37.170 --> 41:38.290
生于空间是40

41:39.090 --> 41:41.170
第一件商品就是100的体积拿不了

41:41.650 --> 41:42.930
直接看第二件商品

41:43.410 --> 41:44.130
空间不变

41:45.410 --> 41:45.970
就完了

41:46.770 --> 41:47.730
这是这种情况

41:49.170 --> 41:51.010
还有那么剩下的情况呢

41:51.010 --> 41:52.210
是什么情况呢

41:52.210 --> 41:54.370
剩下的情况那就正常情况了

41:54.370 --> 41:55.490
正常情况下

41:56.690 --> 41:57.490
就是这个东西

41:58.290 --> 41:59.010
就这个玩意儿

41:59.970 --> 42:01.570
这个代码量其实并不大啊

42:01.570 --> 42:03.010
代码量很简单的

42:03.010 --> 42:03.650
就这个玩意儿

42:04.690 --> 42:07.250
你要在两拿与和不拿之间

42:07.250 --> 42:08.290
要做出选择

42:09.090 --> 42:10.050
求一个最大值

42:10.930 --> 42:11.330
来吧

42:12.290 --> 42:13.090
拿与不拿之间

42:13.090 --> 42:14.050
我们要做出一个选择

42:14.050 --> 42:14.610
求最大值

42:15.170 --> 42:15.570
好

42:16.610 --> 42:17.410
怎么来求

42:17.410 --> 42:18.610
虽然是拿的问题

42:19.170 --> 42:20.050
就是拿

42:20.050 --> 42:20.850
拿就是那个车

42:22.610 --> 42:23.410
我们把拿

42:23.410 --> 42:24.450
拿的情况算出来

42:26.530 --> 42:28.530
拿的情况算出来

42:32.930 --> 42:34.770
拿的情况是什么情况呢

42:34.770 --> 42:35.970
是不是刚才说了

42:35.970 --> 42:38.370
就是说我当前这个产品

42:38.370 --> 42:39.250
我是说拿了

42:39.250 --> 42:40.290
拿了是不是它有价值

42:41.250 --> 42:42.530
当前的产品

42:42.530 --> 42:45.650
加上生鱼的

42:45.650 --> 42:47.170
就是把这个东西拿了之后

42:47.810 --> 42:49.090
看下一个商品

42:50.450 --> 42:51.890
然后呢空间变化

42:51.890 --> 42:53.090
空间减少了

42:53.090 --> 42:53.730
减少多少

42:53.730 --> 42:54.130
减少杯

42:55.170 --> 42:56.210
就是这个数字

42:56.850 --> 42:57.810
当我拿了过后

42:57.810 --> 42:59.250
就目前的产品的价值

42:59.650 --> 43:01.170
加上生鱼的

43:01.730 --> 43:02.450
最大价值

43:03.970 --> 43:04.370
对不对

43:05.250 --> 43:06.130
所以我怎么去找

43:06.130 --> 43:07.330
它又是重复这个过程

43:07.330 --> 43:08.290
重复指问题

43:08.290 --> 43:09.010
重叠指问题

43:09.010 --> 43:09.890
它又是重复去解

43:11.010 --> 43:13.090
这是拿的情况

43:13.730 --> 43:15.170
还有就是不拿的情况

43:15.170 --> 43:15.970
安适那个字

43:18.610 --> 43:19.490
这是拿的情况

43:21.010 --> 43:23.730
不拿的情况算出来

43:25.090 --> 43:25.570
好

43:25.570 --> 43:27.090
不拿的情况下呢

43:27.090 --> 43:27.570
是什么呢

43:28.450 --> 43:29.730
那就是这个玩意儿

43:30.770 --> 43:31.890
我一个产品不动

43:31.890 --> 43:33.010
生鱼的空间不变

43:33.010 --> 43:33.890
直接看下一个

43:38.150 --> 43:39.350
那么这两个东西

43:39.350 --> 43:40.550
是拿和不拿

43:40.550 --> 43:41.670
是不是求一个最大值的

43:41.670 --> 43:42.550
当然回就完事

43:43.510 --> 43:44.070
Mass

43:44.070 --> 43:45.030
Mass

43:45.110 --> 43:46.310
拿和不拿

43:47.830 --> 43:48.630
就完了

43:48.630 --> 43:49.430
还是有写完了

43:50.310 --> 43:51.510
简单不简单呢

43:51.510 --> 43:52.710
代码其实除了

43:52.710 --> 43:53.670
把数字移去掉

43:53.670 --> 43:54.390
简单的不得了

43:55.110 --> 43:55.910
它解决的问题

43:55.910 --> 43:57.270
确实极其复杂的问题

43:57.910 --> 43:58.310
所以说

43:59.430 --> 44:01.350
都不是说那个地规很厉害

44:01.350 --> 44:02.790
是因为我们的状态转

44:02.790 --> 44:03.670
移方程很厉害

44:04.310 --> 44:05.030
你如果说你能够

44:05.030 --> 44:05.750
把那个转移上转

44:05.750 --> 44:06.870
移方程写出来就OK了

44:06.870 --> 44:08.070
我们来算一下是不是39

44:08.950 --> 44:09.590
是不是39

44:10.550 --> 44:10.870
对吧

44:12.390 --> 44:12.710
好

44:12.710 --> 44:13.670
那么这就是这个问题

44:13.670 --> 44:14.550
好好看一下这个代码

44:15.990 --> 44:16.870
没了

44:23.830 --> 44:24.150
好

44:24.710 --> 44:25.510
这个代码能看懂吗

44:25.510 --> 44:26.070
好好看一下

44:27.350 --> 44:27.990
可能有些人

44:27.990 --> 44:28.790
可能一时半会

44:28.790 --> 44:30.390
可能这个代码呢

44:30.390 --> 44:31.030
比较吃力

44:31.670 --> 44:32.390
但是这个代码量

44:32.390 --> 44:33.110
其实并不多

44:33.670 --> 44:33.910
好

44:33.910 --> 44:34.870
现在我们能慢慢

44:34.870 --> 44:35.830
再继续研究啊

44:38.390 --> 44:40.070
现在的我不仅

44:40.070 --> 44:40.710
比方说

44:40.710 --> 44:41.750
我们现在的需求

44:42.550 --> 44:44.150
也增加了

44:44.150 --> 44:45.590
我不仅要返回一个

44:45.590 --> 44:46.310
最大价值

44:47.270 --> 44:49.190
其实思路差不多的

44:49.190 --> 44:49.830
台阶问题

44:50.630 --> 44:51.990
都是用的是

44:51.990 --> 44:52.950
东台伟发的思想

44:56.710 --> 44:57.590
现在我们不仅要

44:57.590 --> 44:58.550
返回最大价值

44:58.550 --> 44:59.110
你看我现在

44:59.110 --> 44:59.990
直接返回个39

44:59.990 --> 45:01.350
我也不知道它装的是啥

45:02.310 --> 45:03.910
我还要返回什么呢

45:03.910 --> 45:05.110
我还要返回

45:06.470 --> 45:07.910
哪些东西装了

45:08.550 --> 45:09.750
哪些东西没装

45:10.790 --> 45:11.750
我要返回这个

45:12.790 --> 45:14.070
哪些东西装了

45:14.070 --> 45:14.550
比方说

45:14.550 --> 45:15.670
我这里有个物品介表

45:15.670 --> 45:16.230
是这个样子

45:17.670 --> 45:18.630
零一伯伯问题呢

45:18.630 --> 45:19.990
它是希望返回这个东西

45:21.830 --> 45:22.630
返回一个数组

45:23.270 --> 45:25.110
这个数组里边用零来表示

45:25.110 --> 45:26.230
第一个物品装不装

45:26.230 --> 45:27.510
比方第一个物品不装

45:27.510 --> 45:28.550
那就写个零

45:28.550 --> 45:30.390
第二个物品装不装

45:30.390 --> 45:31.430
不装就写零

45:31.430 --> 45:32.790
第三个物品装不装

45:32.790 --> 45:33.830
装就写一

45:33.830 --> 45:35.830
第四个物品装不装就写一

45:35.830 --> 45:36.470
一般的意思吧

45:36.470 --> 45:37.750
它是希望返回这个东西

45:39.430 --> 45:40.150
其实啊

45:40.150 --> 45:41.030
如果说你这个

45:41.030 --> 45:42.710
这个代码你能理解的话

45:42.710 --> 45:44.230
这个玩意是非常简单的

45:44.230 --> 45:45.350
并不复杂

45:45.350 --> 45:46.070
来我们来看吧

45:46.070 --> 45:47.030
我们就要一个机窗盖

45:48.630 --> 45:50.070
比如说我要返回两个东西

45:50.070 --> 45:51.190
一个是呢

45:51.190 --> 45:52.470
最大价值

45:52.470 --> 45:54.070
就返回的东西不一样了啊

45:54.070 --> 45:55.590
反过来不仅仅是一个rest

45:55.590 --> 45:57.350
反过来也不仅仅是个最大价值

45:57.350 --> 45:58.550
反过来是一个对象

45:58.550 --> 45:59.510
对象里边的一个

46:01.350 --> 46:02.150
最大价值

46:02.150 --> 46:03.030
一个属性

46:03.030 --> 46:04.150
还有一份是一个数组

46:05.190 --> 46:06.710
是一个就是choose

46:07.510 --> 46:08.630
就是选择的数组

46:10.390 --> 46:11.030
它是一个数组

46:12.390 --> 46:13.030
什么数组呢

46:13.030 --> 46:16.310
是一个number数组

46:16.310 --> 46:17.190
这是个重视啊

46:17.190 --> 46:17.830
看得懂吗

46:17.830 --> 46:19.270
就是我要返回一个对象

46:19.270 --> 46:20.870
对象里边的value比方说啊

46:20.870 --> 46:21.590
举个例子

46:21.590 --> 46:22.870
比方说我们这里反过来对象

46:22.870 --> 46:23.830
value是什么呢

46:23.830 --> 46:24.790
value是39

46:27.190 --> 46:29.350
它的选择的东西呢

46:29.990 --> 46:30.630
是一个数组

46:30.630 --> 46:31.430
第一个选不选了

46:31.430 --> 46:31.750
不选

46:31.750 --> 46:32.390
第二个选不选了

46:32.390 --> 46:32.630
不选

46:32.630 --> 46:33.430
第三个选

46:33.430 --> 46:34.150
第四个不选

46:34.150 --> 46:35.030
第四个不选

46:35.030 --> 46:35.510
第五个选

46:35.510 --> 46:35.830
第六个选

46:35.830 --> 46:37.030
就这么个意思

46:37.030 --> 46:37.910
它返回这个东西

46:39.510 --> 46:40.230
好来吧

46:40.230 --> 46:41.350
我们看这个问题又怎么去解

46:44.310 --> 46:45.750
因为我们这里有变化啊

46:45.750 --> 46:46.470
变成这个对象了

46:47.350 --> 46:48.070
要不是

46:48.070 --> 46:49.030
返回了是一个对象

46:53.510 --> 46:53.910
好

46:53.990 --> 46:54.630
那么这里呢

46:54.630 --> 46:55.990
你不能直接返回一个0了

46:55.990 --> 46:56.870
也要返回个什么

46:56.870 --> 46:57.830
返回一个对象

46:59.590 --> 47:01.190
对象的属性是什么

47:01.190 --> 47:02.310
value有两个属性

47:02.310 --> 47:03.190
一个是value

47:03.190 --> 47:04.550
value值应该多少

47:04.550 --> 47:04.950
0吧

47:05.590 --> 47:07.110
如果说你i超过了

47:07.110 --> 47:09.030
就是你i跑到后边去了

47:09.030 --> 47:09.670
就这种情况

47:10.310 --> 47:11.190
你的i在这了

47:11.750 --> 47:13.350
那个最大价值肯定是0吗

47:13.350 --> 47:14.150
是不是肯定是0

47:15.510 --> 47:17.430
那从这个位置开始啊

47:17.430 --> 47:18.470
从这个位置开始

47:18.470 --> 47:18.950
前面的位置

47:18.950 --> 47:19.510
不管你的事

47:19.510 --> 47:20.470
是别人能做的

47:20.470 --> 47:21.670
不管你的事

47:21.670 --> 47:23.270
从这个位置开始

47:23.350 --> 47:24.790
你选择的物品的

47:24.790 --> 47:26.550
最大那个选

47:26.550 --> 47:27.990
选和不选的那个数组

47:27.990 --> 47:28.470
应该是啥

47:31.030 --> 47:31.510
应该是啥

47:32.630 --> 47:33.750
这就是个空数数吧

47:35.430 --> 47:37.110
就是choose

47:37.110 --> 47:38.310
就是空数数

47:38.310 --> 47:39.350
从这个位置开始

47:40.150 --> 47:41.110
选和不选的数组

47:41.110 --> 47:42.230
就是空数数

47:42.230 --> 47:42.790
明儿的意思吧

47:43.830 --> 47:44.470
就这个意思

47:46.900 --> 47:47.140
好

47:47.140 --> 47:48.100
然后我们看下面的

47:49.140 --> 47:49.540
看这

47:53.840 --> 47:55.200
现在的情况是

47:55.200 --> 47:57.120
如果说当前那个产品

47:57.120 --> 47:58.720
当前那个商品体积太大了

47:58.800 --> 47:59.280
装不下

47:59.280 --> 48:00.320
这个背包装不下

48:00.320 --> 48:01.440
装不下是不是不选啊

48:02.320 --> 48:04.080
是不是当前那个商品的

48:04.080 --> 48:05.360
当前那个商品的东西

48:05.360 --> 48:06.640
一定是不选的

48:06.640 --> 48:07.520
肯定是不选的

48:08.400 --> 48:09.040
那么如果说

48:09.040 --> 48:10.160
当前那个商品的东西

48:10.160 --> 48:11.520
是不选的情况下

48:12.320 --> 48:13.520
我的最大价值是多少呢

48:14.400 --> 48:15.440
来梳理一下啊

48:15.440 --> 48:16.160
最大价值是不是

48:16.160 --> 48:17.520
就是后边商品的

48:18.080 --> 48:19.120
后边的最大价值

48:20.080 --> 48:21.760
我们这个商品看的不看

48:21.760 --> 48:22.800
跟这个商品没关系

48:23.440 --> 48:24.640
那么选和不选

48:24.640 --> 48:25.920
选和不选那个数组

48:25.920 --> 48:26.880
是不是应该是这个样子

48:27.600 --> 48:28.800
当前那个商品

48:28.800 --> 48:30.320
选不选是不是零

48:31.040 --> 48:31.840
后边是不是

48:32.640 --> 48:33.920
把后边的选择放这

48:34.560 --> 48:35.840
后面的选择

48:35.840 --> 48:36.400
这放这

48:37.440 --> 48:38.320
这个逻辑能理解吧

48:38.320 --> 48:39.120
就这一块逻辑

48:43.970 --> 48:45.090
这一块逻辑能理解吧

48:45.650 --> 48:46.770
就是我目前那个商品

48:46.770 --> 48:47.250
我不要

48:47.650 --> 48:48.130
不要它

48:48.690 --> 48:49.170
不要它的话

48:49.170 --> 48:50.290
它的最大价值呢

48:50.930 --> 48:51.810
就从这个位置

48:51.810 --> 48:52.530
开始的最大价值

48:52.530 --> 48:53.410
就是从后边位置

48:53.410 --> 48:54.450
开始的最大价值

48:54.450 --> 48:55.010
一样的嘛

48:55.570 --> 48:56.610
跟这个商品没关系

48:57.090 --> 48:58.690
然后选择的数组呢

48:58.850 --> 48:59.890
就是我这个商品呢

48:59.890 --> 49:00.770
是不选的

49:00.770 --> 49:01.810
那么后边的选择呢

49:01.810 --> 49:02.450
我也不知道

49:02.450 --> 49:03.170
你算出来

49:03.170 --> 49:03.730
算出来过后呢

49:03.730 --> 49:04.530
我把放到后边

49:04.930 --> 49:05.330
对吧

49:05.970 --> 49:06.210
好

49:06.210 --> 49:07.570
那么也就是说啥意思呢

49:08.210 --> 49:09.090
我这里呢

49:09.090 --> 49:10.370
是不是后边的选择情况

49:10.930 --> 49:12.370
我把后边的选择情况拿到

49:13.970 --> 49:14.770
next

49:14.770 --> 49:15.970
后边选择的情况拿到

49:17.010 --> 49:18.930
拿到后边的选择情况呢

49:18.930 --> 49:21.010
我要得到了这个对象是这个样子

49:22.450 --> 49:22.930
value

49:24.770 --> 49:26.210
是不是就是后边

49:26.210 --> 49:27.330
后边那个最大价值

49:28.050 --> 49:29.730
因为这个函数反回来一定是个对象

49:29.730 --> 49:31.090
现在反回来不是一个数字的

49:31.090 --> 49:31.890
反回来是个对象

49:32.610 --> 49:33.890
是不是后边那个最大价值

49:34.530 --> 49:35.010
然后呢

49:35.010 --> 49:35.890
这数组呢

49:35.890 --> 49:37.010
choose呢

49:37.010 --> 49:38.210
它第一位为0

49:38.850 --> 49:40.370
后边的是不是把那个

49:40.370 --> 49:42.370
把这个next的choose啊

49:43.250 --> 49:44.930
是不是展开放这

49:45.490 --> 49:45.810
对不对

49:45.810 --> 49:46.610
是不是展开放这

49:47.170 --> 49:47.650
那么这里呢

49:47.650 --> 49:48.610
我给大家讲一讲

49:48.610 --> 49:51.010
es6里边的一个展开运算符啊

49:51.010 --> 49:52.130
用起来比较方便一点

49:52.690 --> 49:54.050
你用康开成的也可以啊

49:54.050 --> 49:54.690
只不过呢

49:54.690 --> 49:55.570
没有这个方便

49:55.570 --> 49:56.770
我给你说一下啊

49:56.850 --> 49:58.210
以方说es6里面

49:58.210 --> 49:59.650
它允许你这样子的做

49:59.650 --> 50:00.610
然后有一个数组

50:00.610 --> 50:01.490
ar1

50:02.610 --> 50:03.410
2 3 4嘛

50:04.450 --> 50:04.930
现在呢

50:04.930 --> 50:05.650
有一个数组

50:05.650 --> 50:06.690
ar2

50:06.690 --> 50:07.730
我希望了把

50:08.690 --> 50:09.570
ar1开始呢

50:09.570 --> 50:10.290
有一个1

50:11.810 --> 50:12.370
有一个1

50:12.930 --> 50:13.250
然后呢

50:13.250 --> 50:15.090
我希望把ar1的东西呢

50:15.090 --> 50:17.090
一次放到这个ar2后边

50:17.090 --> 50:17.650
那怎么办呢

50:17.650 --> 50:19.170
我可以用一个特殊的运算符啊

50:19.170 --> 50:19.650
三个点

50:19.650 --> 50:20.850
展开运算符

50:20.850 --> 50:22.370
然后把ar1写上

50:22.370 --> 50:23.250
就这么个意思

50:23.250 --> 50:25.810
它就会把这个ar1的东西全部展开

50:25.890 --> 50:27.090
一次放到这个位置

50:27.090 --> 50:29.090
就相当于是这里写了一个ar2 3 4

50:29.090 --> 50:30.130
懂了意思吧

50:30.130 --> 50:30.850
一回车

50:30.850 --> 50:32.210
我们来看一下ar2

50:32.210 --> 50:33.250
这有ar1 2 3 4的

50:34.130 --> 50:35.330
我们就要起到这么个作用啊

50:35.330 --> 50:36.530
那么这里的效果是一样的

50:37.650 --> 50:38.290
我们这里呢

50:38.290 --> 50:39.170
一开始这里是0

50:39.170 --> 50:39.650
我不选

50:40.290 --> 50:42.050
然后把生于的这个数组

50:42.050 --> 50:43.250
生于的选择

50:43.250 --> 50:43.730
展开

50:44.770 --> 50:45.250
就放这

50:46.610 --> 50:47.010
对不对

50:47.730 --> 50:48.450
好这是

50:48.450 --> 50:49.410
体积过大的情况

50:49.410 --> 50:50.290
它一定拿不了嘛

50:51.250 --> 50:51.570
好

50:51.570 --> 50:53.010
接下来我们看下边的

50:53.010 --> 50:53.650
正常情况

50:55.990 --> 50:57.270
喝水啊

50:59.910 --> 51:00.470
正常情况

51:01.510 --> 51:02.870
正常情况下呢

51:02.870 --> 51:04.470
就是我选和不选

51:04.470 --> 51:05.990
得到两种情况

51:06.710 --> 51:07.190
选和不选

51:07.190 --> 51:08.470
那这里就不能用加了啊

51:08.470 --> 51:09.430
不能用加

51:09.430 --> 51:11.190
我选的时候呢

51:11.190 --> 51:12.070
是这样子的啊

51:14.930 --> 51:16.130
我选的时候

51:16.130 --> 51:18.290
我先拿到后边的情况

51:18.290 --> 51:19.570
就是我把空间减少

51:20.450 --> 51:21.650
空间减少

51:21.650 --> 51:22.850
拿后边的情况

51:22.850 --> 51:23.730
我就用next

51:26.820 --> 51:27.140
就是

51:29.650 --> 51:31.090
这个就是空间减少

51:31.090 --> 51:32.050
就选的情况

51:33.890 --> 51:34.930
空间减少

51:34.930 --> 51:35.730
是不是空间减少了

51:36.850 --> 51:37.650
看i加一

51:37.650 --> 51:38.850
看后边的情况

51:38.850 --> 51:40.770
然后这就是我选择的情况

51:40.770 --> 51:41.490
是那个是

51:41.490 --> 51:42.370
是不是一个对象

51:42.370 --> 51:43.090
对象是什么呢

51:43.090 --> 51:43.890
Vanu等于啥

51:44.530 --> 51:45.090
它的值

51:46.050 --> 51:48.210
是不是等于当前商品的

51:48.930 --> 51:49.330
价值

51:50.210 --> 51:53.490
加上后续商品的最大价值

51:54.050 --> 51:54.450
对吧

51:55.330 --> 51:56.690
你不能直接在这里加了

51:56.690 --> 51:57.650
因为它后边是一个对象

51:57.650 --> 51:58.210
你没法加

51:59.010 --> 52:00.290
所以价值上

52:00.290 --> 52:01.650
是当前的最大

52:01.650 --> 52:03.330
当前商品的我选了它嘛

52:03.330 --> 52:05.090
当前的商品的这种价值

52:05.090 --> 52:07.650
加上后边的情况的价值

52:10.130 --> 52:10.850
然后呢

52:10.850 --> 52:12.450
我的选择情况呢

52:12.450 --> 52:13.010
是不是就是

52:13.410 --> 52:14.530
我这个商品已经选了

52:15.330 --> 52:17.170
那么以及后边的选择情况

52:22.210 --> 52:23.250
这是选的情况

52:25.090 --> 52:26.050
那么不选的情况

52:26.050 --> 52:27.010
是不是道理一样的

52:27.010 --> 52:27.410
不选情况

52:27.410 --> 52:28.450
这个代码都会直接的

52:28.450 --> 52:29.010
复制过来了

52:31.680 --> 52:32.800
这是不选的情况

52:37.920 --> 52:39.200
是不是不选的情况

52:39.200 --> 52:40.240
这是选的情况

52:40.240 --> 52:41.360
这是不选的情况

52:43.840 --> 52:44.240
对吧

52:44.240 --> 52:45.200
也是不选的情况

52:45.200 --> 52:46.320
就是直接看后边

52:46.320 --> 52:47.200
体积不减少

52:47.200 --> 52:48.720
选了过体积要减少嘛

52:48.720 --> 52:49.360
看后边

52:49.360 --> 52:50.400
那么看后边的时候呢

52:50.400 --> 52:51.200
体积不减少

52:51.840 --> 52:52.880
然后不选的情况就是

52:53.680 --> 52:54.640
我后边的价值

52:54.640 --> 52:56.000
就是我的最大价值

52:56.000 --> 52:56.400
然后呢

52:56.400 --> 52:57.520
我这里一块不选

52:57.520 --> 52:59.040
然后把后边的情况放这

53:00.000 --> 53:00.400
对吧

53:02.080 --> 53:02.400
好

53:02.400 --> 53:04.080
那么两个情况是不是要比较

53:04.160 --> 53:05.760
那么这个时候又迈克斯不合适了啊

53:06.480 --> 53:07.680
我们要判断

53:07.680 --> 53:10.000
如果说当前选的价值

53:10.560 --> 53:12.800
大于了不选的价值

53:15.520 --> 53:19.680
这个选的选的价值更高

53:20.320 --> 53:21.040
更高感嘛

53:21.040 --> 53:21.520
干嘛

53:21.520 --> 53:23.200
直接返回这个实际上就完事了

53:23.200 --> 53:23.920
那我就选呗

53:24.640 --> 53:25.920
否则的话我返回什么了

53:26.480 --> 53:27.680
否则的话我就返回

53:27.680 --> 53:28.080
啊

53:28.080 --> 53:29.520
这个是就不选呗

53:29.520 --> 53:30.960
选的价值高就返回选的吧

53:30.960 --> 53:31.600
我就选吧

53:32.560 --> 53:34.080
返回这个不选的价值高

53:34.080 --> 53:34.720
我就返回不选

53:35.680 --> 53:37.200
这会把程序就改造完了

53:37.200 --> 53:38.880
那么这个程序的代码多了一点点

53:38.880 --> 53:40.320
但是程序的思路还是不变

53:41.280 --> 53:41.680
于是呢

53:41.680 --> 53:43.520
我们可以得到更加丰富的信息了

53:43.520 --> 53:44.960
它不仅会告诉我们

53:44.960 --> 53:45.920
最大价值是多少

53:45.920 --> 53:47.680
还会告诉我们选择的情况是什么

53:49.040 --> 53:49.600
啊你看一下

53:50.160 --> 53:50.800
它告诉我

53:51.520 --> 53:52.800
最大价值是39

53:52.800 --> 53:53.600
选择的情况呢

53:53.600 --> 53:54.560
第一个不选

53:54.560 --> 53:55.600
第二个不选

53:55.600 --> 53:56.240
它选了这个

53:57.440 --> 53:58.160
它选了这个

53:58.880 --> 54:01.040
然后呢第四个不选

54:01.040 --> 54:01.760
然后选这个

54:02.880 --> 54:03.520
这个不选

54:03.520 --> 54:04.000
选这个

54:04.960 --> 54:05.520
最大价值

54:06.640 --> 54:08.320
8加1939

54:09.280 --> 54:11.200
占用的空间11加2

54:11.200 --> 54:11.920
13

54:11.920 --> 54:12.880
13加上25

54:13.520 --> 54:14.400
38

54:14.400 --> 54:15.200
啊这就是最优点

54:15.760 --> 54:16.800
啊这一定是最优点

54:18.880 --> 54:19.520
明儿的意思吧

54:20.080 --> 54:21.280
好我们来改一下啊

54:21.280 --> 54:22.960
把这个空间变少变少一点

54:22.960 --> 54:23.600
看一下

54:23.600 --> 54:24.720
比方说20

54:24.720 --> 54:25.440
就看一下

54:25.440 --> 54:26.000
这个情况

54:27.280 --> 54:27.760
21

54:28.400 --> 54:28.880
看一下吧

54:32.000 --> 54:33.520
21

54:33.520 --> 54:34.160
最大价值

54:34.160 --> 54:35.200
前面四个都不选

54:35.200 --> 54:36.400
直接选这两个

54:37.600 --> 54:38.720
是不是19啊

54:38.720 --> 54:39.760
价值是21

54:39.760 --> 54:40.000
对吧

54:40.000 --> 54:40.240
它会

54:40.800 --> 54:42.000
它会得到一个最优点

54:42.000 --> 54:43.360
这一定是个最优点

54:44.800 --> 54:45.840
啊就是动态违法问题

54:45.840 --> 54:46.800
在解决方案

54:48.320 --> 54:49.040
那么目前那个

54:49.040 --> 54:50.160
我们还要考虑个程序

54:50.160 --> 54:50.880
效率的问题

54:50.880 --> 54:51.760
现在效率高吗

54:52.880 --> 54:53.680
现在高了吗

54:53.680 --> 54:55.040
它有没有重复运算呢

54:55.840 --> 54:56.400
想一想啊

54:56.880 --> 54:58.000
这里边会不会有一些

54:59.680 --> 55:00.640
重复运算呢

55:02.080 --> 55:03.120
实际上是有的

55:05.120 --> 55:06.400
什么情况下会发生

55:06.400 --> 55:07.200
重复运算呢

55:07.200 --> 55:08.160
我给大家举个例子

55:09.440 --> 55:11.120
假设我的商品是这个样子的

55:12.080 --> 55:13.200
第一个商品呢

55:13.200 --> 55:13.920
体积为5

55:15.880 --> 55:17.080
啊就体积的为5

55:17.640 --> 55:18.520
价值呢为5

55:20.040 --> 55:20.760
第二个商品呢

55:20.760 --> 55:21.240
体积

55:22.360 --> 55:22.920
还是5

55:22.920 --> 55:24.120
啊我就写个简单的吧

55:24.120 --> 55:24.840
价格还是5

55:25.240 --> 55:25.960
价值还是5

55:26.440 --> 55:27.320
第三个商品呢

55:29.640 --> 55:30.200
就不写了啊

55:30.200 --> 55:30.760
后边就不写了

55:30.760 --> 55:31.240
你看一下

55:31.240 --> 55:31.960
你至少看一下

55:31.960 --> 55:32.920
有没有重复运算

55:32.920 --> 55:33.640
怎么说你找到了

55:33.640 --> 55:34.600
一个重复运算

55:34.680 --> 55:36.200
咱们说明这个重复运算就很多

55:36.760 --> 55:37.720
就像家里面你出

55:37.720 --> 55:38.680
出现了一直脏脑

55:38.680 --> 55:39.720
就说明有几百万只

55:41.640 --> 55:43.480
我们背包体积是40

55:44.440 --> 55:46.040
啊我这说话绕着

55:46.680 --> 55:47.480
舍同理不直

55:47.480 --> 55:48.360
反正是说20吧

55:49.880 --> 55:51.480
对第一件商品而言

55:51.480 --> 55:52.520
是不是存在

55:52.520 --> 55:53.480
这么一种情况

55:53.480 --> 55:54.840
就I等于0的时候

55:55.560 --> 55:56.440
I等于0的时候

55:56.440 --> 55:59.080
是不是我们要算一个0 20的情况

55:59.640 --> 56:00.760
要算0 20

56:00.760 --> 56:01.880
是不是我要算两个

56:02.440 --> 56:03.480
分成两个

56:03.480 --> 56:04.200
一个算啥呀

56:04.600 --> 56:07.080
一个算那个1

56:08.520 --> 56:09.080
选他

56:10.440 --> 56:11.240
是不是实物

56:11.240 --> 56:12.280
算那个一和实物

56:12.280 --> 56:12.600
对吧

56:12.600 --> 56:13.800
就我选这一块

56:13.800 --> 56:15.480
选一个是不是体积就减少了

56:15.480 --> 56:16.600
20的体积减少了

56:16.600 --> 56:17.400
变成实物了

56:17.400 --> 56:17.720
对吧

56:18.280 --> 56:19.560
我要算这个一十五

56:19.560 --> 56:20.840
同时不要算什么了

56:20.840 --> 56:21.400
我还要算

56:21.400 --> 56:22.600
他不选他的情况

56:22.600 --> 56:25.480
是不是要算那个一二十

56:26.760 --> 56:27.400
需要算这个

56:27.960 --> 56:28.680
好我们来看一下

56:28.680 --> 56:30.520
要算这个一十五的情况下

56:32.280 --> 56:33.240
我们不算一十五

56:33.320 --> 56:34.280
我们看这个

56:34.280 --> 56:35.960
要算这个一二十的情况下

56:36.680 --> 56:37.160
是不是

56:37.880 --> 56:38.760
I等于一了

56:38.760 --> 56:39.560
I等于一的时候

56:39.560 --> 56:40.520
我们是不是要算那个

56:42.280 --> 56:42.920
F2

56:44.520 --> 56:45.000
2

56:45.000 --> 56:45.640
然后呢

56:45.640 --> 56:46.200
体积

56:46.200 --> 56:47.000
我不选2

56:47.720 --> 56:48.120
20

56:50.230 --> 56:51.190
还要算什么

56:51.190 --> 56:51.750
F2

56:53.030 --> 56:54.150
选他实物

56:55.670 --> 56:56.070
明白吧

56:56.790 --> 56:58.230
这个问题转换成这个问题了

56:59.830 --> 57:00.630
对不对

57:00.630 --> 57:01.750
好那么如果说选了

57:01.750 --> 57:02.870
第一件商品的话

57:02.870 --> 57:04.150
我还要去算什么

57:04.230 --> 57:05.190
要算F2

57:08.630 --> 57:09.430
实物

57:09.430 --> 57:09.990
不选他

57:09.990 --> 57:11.190
不选第二件

57:11.190 --> 57:12.630
选了第一件不选第二件

57:12.630 --> 57:13.990
还要算选了第二件

57:13.990 --> 57:14.790
是不是选实物

57:14.790 --> 57:15.750
你看是不是有重复的

57:16.470 --> 57:17.430
是不是有重复的运算

57:18.070 --> 57:19.670
你只要看到有一个重复的运算

57:19.670 --> 57:21.270
说明这个里边的重复运算可不少

57:21.990 --> 57:23.750
因此为了提高效率呢

57:23.750 --> 57:24.710
我们需要有个表

57:25.430 --> 57:26.390
来记录一下

57:27.990 --> 57:30.150
在某一个I的情况下

57:30.150 --> 57:32.470
某一个Race的指责情况下

57:32.470 --> 57:33.990
他们一定有一个固定的值

57:34.150 --> 57:36.390
就这两个东西定下来了

57:36.390 --> 57:37.190
他们只一定固定

57:37.190 --> 57:38.230
他不可能说

57:38.230 --> 57:39.910
这个玩意和这个玩意不变

57:39.910 --> 57:41.350
他们反复的东西不一样

57:41.350 --> 57:42.470
那不可能的

57:42.470 --> 57:43.670
他只有一个最有解

57:43.670 --> 57:44.150
所以说呢

57:45.110 --> 57:47.270
我们只要找到I的值不变

57:47.270 --> 57:48.230
Race的值不变

57:48.230 --> 57:50.310
那么他一定得到一个确定的结果

57:50.310 --> 57:50.710
所以说呢

57:50.710 --> 57:53.430
我们需要可以用一个缓存表

57:54.230 --> 57:55.190
他可以怎么来记住呢

57:55.190 --> 57:56.390
我就这样规定吧

57:56.390 --> 57:57.510
非常简单的规定一下

57:58.870 --> 58:00.150
属性的名字叫做这个

58:02.230 --> 58:03.830
零一个横钢吧

58:03.990 --> 58:04.550
一个横钢

58:05.510 --> 58:06.150
二十

58:06.150 --> 58:06.870
啥意思

58:06.870 --> 58:08.870
就是I的于零的时候

58:08.870 --> 58:10.630
生于的空间为二十的时候

58:11.430 --> 58:11.990
他的结果

58:13.670 --> 58:15.670
他某一个结果记录一下

58:16.950 --> 58:18.630
生于I为一的时候

58:18.630 --> 58:20.470
生于空间为十五的时候

58:20.470 --> 58:21.990
他的值记录一下

58:21.990 --> 58:24.470
就变成这么一个就是缓存表

58:25.350 --> 58:25.590
好

58:25.590 --> 58:25.910
因此呢

58:25.910 --> 58:27.030
我们把这个单盘展开

58:27.030 --> 58:28.710
缓存表了我见到这

58:31.030 --> 58:31.670
一个空队下

58:32.630 --> 58:33.110
好

58:33.110 --> 58:34.070
一开上这种情况了

58:34.070 --> 58:34.710
不用管他

58:34.710 --> 58:36.310
就是超出了这种情况

58:36.310 --> 58:37.270
直接反馈就OK了

58:37.830 --> 58:38.950
然后生于的东西呢

58:38.950 --> 58:40.310
我叫首先判断缓存

58:42.900 --> 58:45.940
首先判断是否有缓存

58:47.620 --> 58:47.860
好

58:47.860 --> 58:48.580
怎么来判断呢

58:49.540 --> 58:51.540
我们是不是要生成一个属性的名字

58:51.540 --> 58:53.700
属性的名字是不是I一个横钢

58:53.700 --> 58:54.260
一个什么呢

58:54.260 --> 58:54.900
Race

58:54.900 --> 58:56.180
那么来生成一个属性的名字

58:58.820 --> 58:59.700
Touch

58:59.700 --> 59:00.900
不叫要P吗

59:00.900 --> 59:02.260
就是缓存的名字

59:02.420 --> 59:03.700
缓存的属性名

59:05.970 --> 59:06.690
属性名字是什么呢

59:06.690 --> 59:07.730
我们用个模板字不算

59:07.730 --> 59:08.450
讲我的啊

59:08.450 --> 59:09.410
模板字不算

59:09.410 --> 59:09.970
听见一下

59:12.400 --> 59:14.160
就是就是某一个东西

59:14.160 --> 59:14.880
一个横钢

59:14.880 --> 59:15.680
某一个东西

59:15.680 --> 59:16.640
第一个问号是啥

59:16.640 --> 59:17.680
第一个问号不就是I吗

59:18.320 --> 59:19.120
第二个问号是啥

59:19.120 --> 59:20.320
第二个问号不就是Race吗

59:21.440 --> 59:22.000
就这样子吗

59:22.000 --> 59:23.600
这是不就是属性名吗

59:23.600 --> 59:24.000
好

59:24.000 --> 59:24.880
然后来判断一下

59:24.880 --> 59:26.160
通过这个属性名判断一下

59:26.160 --> 59:26.960
有没有缓存

59:28.720 --> 59:29.920
是不是已经算过了

59:29.920 --> 59:30.640
已经算过了

59:32.680 --> 59:34.360
包里其实跟那个非波拉气数列

59:34.360 --> 59:35.160
是一样的道理

59:35.560 --> 59:37.160
直接返回

59:40.470 --> 59:41.350
如果说你像这个单码

59:41.350 --> 59:42.470
你都看在实例的话

59:42.470 --> 59:45.030
那里基础不是很牢靠

59:45.990 --> 59:47.030
还跟那个模板字不错

59:47.030 --> 59:47.670
没多少关系

59:47.670 --> 59:48.790
这个字不算唯一一些

59:48.790 --> 59:50.310
是它就是用来做凭借的

59:50.310 --> 59:51.110
马上就懂了

59:52.310 --> 59:54.310
就是你单码可能写得比较少

59:55.750 --> 59:55.910
好

59:55.910 --> 59:56.870
那么这个玩意就算过了

59:56.870 --> 59:57.030
对吧

59:57.030 --> 59:57.830
直接返回

59:57.830 --> 59:58.550
那么生命的情况

59:58.550 --> 01:00:00.070
是不是没有算过的情况

01:00:00.070 --> 01:00:00.950
没有算过的情况

01:00:00.950 --> 01:00:01.750
我就要缓存了

01:00:02.470 --> 01:00:02.950
你看吧

01:00:02.950 --> 01:00:03.910
我在这里是不是要

01:00:03.910 --> 01:00:05.350
就不是直接转了

01:00:05.350 --> 01:00:06.390
我要缓存了

01:00:06.390 --> 01:00:07.030
怎么缓存呢

01:00:07.190 --> 01:00:08.310
就是dT

01:00:08.310 --> 01:00:09.030
T

01:00:09.030 --> 01:00:09.590
缓存起来

01:00:10.230 --> 01:00:10.470
对吧

01:00:10.470 --> 01:00:11.590
把这个结果缓存起来

01:00:11.590 --> 01:00:12.710
l时的情况呢

01:00:12.710 --> 01:00:13.430
你看这里

01:00:13.430 --> 01:00:14.630
是不是我要缓存起来

01:00:14.630 --> 01:00:15.270
dT

01:00:15.270 --> 01:00:16.150
T

01:00:16.150 --> 01:00:16.710
缓存起来

01:00:16.710 --> 01:00:17.270
返回的地方

01:00:17.270 --> 01:00:18.790
我就不不着急返回

01:00:18.790 --> 01:00:19.510
啊先缓存

01:00:20.950 --> 01:00:21.110
好

01:00:21.110 --> 01:00:22.390
那么这样子运行完了过后

01:00:22.390 --> 01:00:23.430
是不是一定缓存起来了

01:00:23.430 --> 01:00:24.070
要么就是这个

01:00:24.070 --> 01:00:25.430
要么就是要么就是这个

01:00:25.430 --> 01:00:26.070
要么就是这个

01:00:26.070 --> 01:00:27.430
总总总之呢

01:00:27.430 --> 01:00:28.230
是缓存起来了

01:00:29.030 --> 01:00:30.630
好缓存起来了过后呢

01:00:30.630 --> 01:00:32.310
最后我再把那个缓存返回

01:00:35.030 --> 01:00:36.070
那么这样子呢

01:00:36.070 --> 01:00:36.950
是不是就

01:00:37.030 --> 01:00:38.230
使用了缓存

01:00:38.230 --> 01:00:39.270
那这样子

01:00:39.270 --> 01:00:41.270
效果结果是完全一样的

01:00:41.270 --> 01:00:42.470
只不过呢现在有了缓存

01:00:42.470 --> 01:00:44.230
我们可以看一下这个缓存啊

01:00:44.230 --> 01:00:44.950
呃

01:00:44.950 --> 01:00:46.950
调用这个package

01:00:46.950 --> 01:00:47.670
调用它

01:00:47.670 --> 01:00:48.470
是不是调用完了过后

01:00:48.470 --> 01:00:50.710
我们得到一个readouts吧

01:00:50.710 --> 01:00:51.750
先不着急返回啊

01:00:51.750 --> 01:00:53.430
最后返回这个readouts

01:00:53.430 --> 01:00:54.950
然后呢我们这里打印出一下

01:00:54.950 --> 01:00:55.910
打印一下这个缓存

01:00:57.350 --> 01:00:57.830
缓存

01:01:00.310 --> 01:01:01.270
dT

01:01:01.270 --> 01:01:01.670
看一下

01:01:02.790 --> 01:01:03.110
运行

01:01:05.120 --> 01:01:05.440
看呗

01:01:05.440 --> 01:01:06.240
这就是缓存结果

01:01:10.640 --> 01:01:11.680
啊

01:01:11.680 --> 01:01:12.880
你看这里

01:01:13.360 --> 01:01:14.240
呃如果说

01:01:14.240 --> 01:01:15.120
i等于6

01:01:15.120 --> 01:01:16.480
剩余空间为1的情况下

01:01:17.200 --> 01:01:18.240
那么就已经得到这个

01:01:18.240 --> 01:01:19.680
最大价值为0

01:01:19.680 --> 01:01:20.240
选择的

01:01:20.240 --> 01:01:21.360
某个东西是不选择

01:01:21.360 --> 01:01:22.000
啊没法选

01:01:22.000 --> 01:01:23.280
啊因为它可能体积不够

01:01:23.280 --> 01:01:24.880
你看是每一个没这种情况

01:01:25.520 --> 01:01:26.640
每一个i的取值

01:01:26.640 --> 01:01:28.480
每一个剩余的体积

01:01:28.480 --> 01:01:29.520
我都得到一个值

01:01:29.520 --> 01:01:30.640
啊把它缓存起来了

01:01:31.440 --> 01:01:33.760
啊就就避免了重复运算

01:01:33.760 --> 01:01:34.640
原来的意思吧

01:01:34.640 --> 01:01:35.920
也就是它真正运算的

01:01:35.920 --> 01:01:37.280
也就是这么这么多次

01:01:38.160 --> 01:01:39.600
真正运算就这么就这么多次

01:01:41.200 --> 01:01:41.920
啊这就是

01:01:42.640 --> 01:01:44.000
关于这个背包问题的

01:01:44.800 --> 01:01:45.280
解释

01:01:49.910 --> 01:01:50.630
哪里有个问题

01:01:50.630 --> 01:01:51.190
哪里有问题

01:01:54.370 --> 01:01:54.930
21

01:01:56.450 --> 01:01:57.010
21

01:01:59.040 --> 01:02:00.640
哦你这个这个是价值

01:02:01.280 --> 01:02:03.200
价值不是体积啊

01:02:04.000 --> 01:02:04.880
不是体积啊

01:02:06.640 --> 01:02:07.440
你是不是看

01:02:07.440 --> 01:02:08.800
看看困难啊

01:02:09.600 --> 01:02:09.840
啊

01:02:10.400 --> 01:02:11.920
它是价值啊不是体积

01:02:13.200 --> 01:02:14.080
你看吧

01:02:14.080 --> 01:02:15.360
这个是选择两个嘛

01:02:16.080 --> 01:02:16.640
选择两个

01:02:16.640 --> 01:02:17.600
体积只占了19

01:02:17.600 --> 01:02:17.920
对吧

01:02:18.000 --> 01:02:18.720
二加17

01:02:18.720 --> 01:02:19.360
只占了19

01:02:19.360 --> 01:02:20.480
还价值是21

01:02:21.360 --> 01:02:22.000
是这么个意思

01:02:22.560 --> 01:02:23.200
就这个东西呢

01:02:23.200 --> 01:02:24.240
你一开始呢

01:02:24.240 --> 01:02:25.200
可能觉得

01:02:25.200 --> 01:02:25.840
这个玩意儿

01:02:25.840 --> 01:02:26.720
军文平时写蛋吧

01:02:26.720 --> 01:02:27.600
好不一样啊

01:02:27.600 --> 01:02:28.480
好好乖啊

01:02:29.120 --> 01:02:30.400
啊但是你见读了过后

01:02:30.400 --> 01:02:31.040
你会发现

01:02:31.040 --> 01:02:31.840
很多复杂问题

01:02:31.840 --> 01:02:33.120
都引烂而减

01:02:33.120 --> 01:02:33.920
那么我给大家

01:02:33.920 --> 01:02:35.280
比方给大家举个例子啊

01:02:35.280 --> 01:02:36.160
我这里课堂上了

01:02:36.160 --> 01:02:38.000
可能没那么那么多时间了

01:02:38.000 --> 01:02:38.800
给大家举个例子

01:02:39.520 --> 01:02:40.800
其实像这个动态规划呀

01:02:40.800 --> 01:02:41.920
它应用的范围很过

01:02:42.560 --> 01:02:43.040
比方说

01:02:43.040 --> 01:02:44.000
我给大家说一下那个

01:02:44.480 --> 01:02:45.280
找零问题

01:02:46.000 --> 01:02:47.760
我这里随便找个东西

01:02:47.760 --> 01:02:48.800
记录一下吧

01:02:48.800 --> 01:02:50.000
找零问题

01:02:50.000 --> 01:02:55.080
怎么要找零问题呢

01:02:55.080 --> 01:02:56.840
就比方说你超市里边去收盈

01:02:56.840 --> 01:02:57.880
一个收盈系统

01:02:58.440 --> 01:02:59.240
用户呢

01:02:59.240 --> 01:03:00.600
给了你一些钱

01:03:00.600 --> 01:03:01.000
对吧

01:03:01.000 --> 01:03:01.960
也要把它找零

01:03:01.960 --> 01:03:02.760
但是这个问题呢

01:03:02.760 --> 01:03:03.720
我们把它做成一个

01:03:03.720 --> 01:03:04.600
做成一个通用问题

01:03:04.600 --> 01:03:05.080
啥问题呢

01:03:05.080 --> 01:03:05.800
就是说

01:03:07.800 --> 01:03:08.440
这样

01:03:10.440 --> 01:03:11.000
给定

01:03:11.880 --> 01:03:12.840
一些

01:03:13.480 --> 01:03:14.920
硬币的

01:03:14.920 --> 01:03:17.560
硬币的面额

01:03:17.640 --> 01:03:20.210
单词我确实不知道

01:03:20.210 --> 01:03:21.490
就费是吧

01:03:21.490 --> 01:03:22.770
费是

01:03:24.050 --> 01:03:26.610
就是有哪些面额的硬币

01:03:26.610 --> 01:03:27.890
每个硬币可以认为无限多

01:03:27.890 --> 01:03:30.450
每种硬币可以认为无限多

01:03:30.450 --> 01:03:35.570
每种硬币可以认为是无限多的

01:03:36.850 --> 01:03:40.470
有哪些面额呢

01:03:40.470 --> 01:03:41.750
比方说

01:03:41.750 --> 01:03:43.030
有100的

01:03:43.030 --> 01:03:44.310
有70的

01:03:45.590 --> 01:03:46.630
有65的

01:03:46.630 --> 01:03:47.110
有50的

01:03:47.110 --> 01:03:48.150
有30的

01:03:48.150 --> 01:03:49.430
有3

01:03:49.430 --> 01:03:50.710
25的

01:03:51.430 --> 01:03:53.110
当然它不一定是按照顺序排的

01:03:53.110 --> 01:03:54.950
我这里就说我们这个意思

01:03:54.950 --> 01:03:56.230
有5块的

01:03:56.230 --> 01:03:57.510
有10块的

01:03:57.510 --> 01:03:58.150
有2块的

01:03:58.150 --> 01:03:58.870
有1块的

01:03:59.590 --> 01:04:00.230
比方说

01:04:00.230 --> 01:04:01.030
有这么一种情况

01:04:01.830 --> 01:04:02.790
给你一些面额

01:04:02.790 --> 01:04:04.470
那个数据有可能是变化的

01:04:04.470 --> 01:04:05.830
它有可能会给你任何

01:04:05.830 --> 01:04:06.710
稀奇古怪的数据

01:04:07.830 --> 01:04:08.550
然后呢

01:04:09.590 --> 01:04:12.150
给定一个找零的

01:04:14.070 --> 01:04:14.470
额度

01:04:20.400 --> 01:04:22.000
低除了最短距离呢

01:04:22.000 --> 01:04:23.440
还要去用

01:04:23.520 --> 01:04:25.440
还要接回点图的知识

01:04:25.440 --> 01:04:27.440
要用动态规划加一点图的知识

01:04:29.700 --> 01:04:30.500
找零

01:04:30.500 --> 01:04:32.260
给定一个找零的额度

01:04:32.260 --> 01:04:33.220
比方说

01:04:33.220 --> 01:04:33.620
比如

01:04:34.580 --> 01:04:35.060
盲礼

01:04:35.700 --> 01:04:36.740
你要找多少钱呢

01:04:36.740 --> 01:04:37.220
你要找

01:04:38.340 --> 01:04:38.900
80块钱

01:04:40.180 --> 01:04:40.660
请问

01:04:42.660 --> 01:04:44.340
如何找零

01:04:45.620 --> 01:04:47.220
才能得到

01:04:47.220 --> 01:04:47.940
才能是

01:04:50.100 --> 01:04:51.620
用到最少的

01:04:51.620 --> 01:04:52.900
所以又是一个最有钱

01:04:52.900 --> 01:04:54.020
用到最少的

01:04:54.900 --> 01:04:55.460
超票

01:04:55.460 --> 01:04:56.180
然后就印并

01:04:57.540 --> 01:04:58.900
印并越少越好

01:04:58.900 --> 01:04:59.940
所以跟超是一样的

01:04:59.940 --> 01:05:00.420
对吧

01:05:00.420 --> 01:05:01.220
比方说你找

01:05:01.220 --> 01:05:02.340
给你找10块钱

01:05:02.340 --> 01:05:03.700
又要给你找7块钱

01:05:04.900 --> 01:05:05.620
他给你每

01:05:05.620 --> 01:05:06.980
全部给你1分的也行

01:05:07.540 --> 01:05:08.740
给你1块的也行

01:05:08.740 --> 01:05:09.460
给你5块钱

01:05:09.460 --> 01:05:10.500
2块也行

01:05:10.500 --> 01:05:11.220
对吧

01:05:11.220 --> 01:05:12.340
怎么样才能用到

01:05:12.340 --> 01:05:13.540
最少的印并

01:05:14.660 --> 01:05:15.860
没中印并是无限多的

01:05:15.860 --> 01:05:16.340
比方说

01:05:16.340 --> 01:05:17.060
有些可以重复找

01:05:17.060 --> 01:05:18.100
比方说找两张10块的

01:05:18.100 --> 01:05:18.500
都可以

01:05:25.060 --> 01:05:26.100
那么这个问题怎么解呢

01:05:26.100 --> 01:05:26.580
这个问题

01:05:26.580 --> 01:05:27.940
其实就是一个动态规划的问题

01:05:28.660 --> 01:05:29.540
首先你要去

01:05:29.620 --> 01:05:31.220
列出他的状态转移方程

01:05:32.180 --> 01:05:32.740
比方说

01:05:33.940 --> 01:05:34.420
这一块

01:05:35.540 --> 01:05:36.580
你用可以用刚刚

01:05:36.580 --> 01:05:38.340
刚才我们学过的那点知识

01:05:39.060 --> 01:05:40.420
我们假设

01:05:40.980 --> 01:05:41.460
假设

01:05:42.740 --> 01:05:43.940
有个函数

01:05:43.940 --> 01:05:45.860
叫做f i rest

01:05:47.970 --> 01:05:49.090
i表示什么意思

01:05:49.090 --> 01:05:50.210
i表示

01:05:50.930 --> 01:05:52.290
从第几个

01:05:53.650 --> 01:05:55.410
印并面额

01:05:55.970 --> 01:05:56.610
开始看

01:05:58.290 --> 01:05:59.330
表示从第几个

01:05:59.330 --> 01:06:00.530
印并面额开始看

01:06:01.010 --> 01:06:02.130
rest上的表示

01:06:03.730 --> 01:06:04.530
剩余的

01:06:05.090 --> 01:06:06.530
剩余要找的钱

01:06:10.160 --> 01:06:10.640
那么这个

01:06:10.640 --> 01:06:12.080
有没有同学能够列出

01:06:12.080 --> 01:06:12.960
一个状态转移方程

01:06:13.680 --> 01:06:14.240
你们想一想

01:06:16.960 --> 01:06:17.760
听这个课就好

01:06:17.760 --> 01:06:18.480
听这个课吧

01:06:18.480 --> 01:06:20.000
你怎么也讨论到土地选

01:06:25.920 --> 01:06:26.720
能不能列出来呢

01:06:27.200 --> 01:06:28.560
他跟刚才有类似

01:06:28.560 --> 01:06:29.680
但是又不一样

01:06:29.680 --> 01:06:30.560
因为刚才那个是

01:06:30.560 --> 01:06:31.760
选过了就不能再选了

01:06:31.760 --> 01:06:32.000
对吧

01:06:32.560 --> 01:06:33.760
是零一背包问题

01:06:34.400 --> 01:06:35.680
那么这个玩意选过了

01:06:35.680 --> 01:06:36.480
他还能选

01:06:37.040 --> 01:06:37.760
他还能选

01:06:41.920 --> 01:06:42.480
那么这个玩意

01:06:42.480 --> 01:06:43.520
又怎么来列出

01:06:43.520 --> 01:06:45.200
一个通用的状态转移方程呢

01:06:45.200 --> 01:06:46.240
就是我们不用考虑一些

01:06:46.240 --> 01:06:46.800
贺数情况

01:06:47.760 --> 01:06:49.520
怎么来列出一个方程呢

01:06:49.520 --> 01:06:50.160
是不是就是

01:06:50.800 --> 01:06:52.240
f i rest

01:06:55.060 --> 01:06:55.780
我们假设

01:06:57.060 --> 01:06:58.580
还有一个就是得到的结果

01:06:58.580 --> 01:06:59.860
得到的结果是

01:07:00.660 --> 01:07:01.140
找零

01:07:03.060 --> 01:07:04.100
最少的

01:07:05.380 --> 01:07:06.180
印并数

01:07:06.180 --> 01:07:07.700
得到的是印并数量

01:07:08.500 --> 01:07:09.380
用了多少多

01:07:09.380 --> 01:07:10.260
多好个印并

01:07:12.950 --> 01:07:13.830
是不是我们要求一个

01:07:13.830 --> 01:07:14.950
最小的印并数

01:07:15.670 --> 01:07:16.310
是不是一定是一个

01:07:16.310 --> 01:07:17.270
密密函数

01:07:17.910 --> 01:07:18.630
求最小的

01:07:19.910 --> 01:07:21.990
什么哪两个字间求最小了

01:07:21.990 --> 01:07:23.590
一个就是我找这个面额

01:07:23.590 --> 01:07:24.070
比方说

01:07:24.710 --> 01:07:25.030
这里

01:07:26.870 --> 01:07:27.430
你们现在可以

01:07:27.430 --> 01:07:28.470
自己去长设写一下

01:07:29.510 --> 01:07:30.550
看到这个面额了

01:07:30.550 --> 01:07:31.430
我找不找他呢

01:07:31.990 --> 01:07:33.350
当然你要判断一些边界情况

01:07:33.350 --> 01:07:34.550
比方这个面额本来就大了

01:07:34.550 --> 01:07:35.190
直接列过了

01:07:35.990 --> 01:07:36.550
这个面额

01:07:36.550 --> 01:07:38.070
我到底要不要找了

01:07:39.430 --> 01:07:41.270
我要不要找找这个面额呢

01:07:41.990 --> 01:07:43.190
那么我找一次

01:07:43.670 --> 01:07:45.110
和我一次都不找

01:07:45.110 --> 01:07:46.230
是不是就在两种情况

01:07:46.790 --> 01:07:47.110
对吧

01:07:47.670 --> 01:07:49.430
我找一次或者是

01:07:49.430 --> 01:07:50.790
就是找至少一次

01:07:50.790 --> 01:07:51.910
或者是一次都不找

01:07:52.630 --> 01:07:54.310
那么情况就是

01:07:56.310 --> 01:07:57.190
我找一次

01:07:59.110 --> 01:08:00.870
找一次是不是就产生了一个硬幣了

01:08:01.430 --> 01:08:03.030
找一次就产生了一个硬幣了

01:08:03.030 --> 01:08:03.270
一

01:08:04.310 --> 01:08:05.030
加上

01:08:05.030 --> 01:08:05.510
什么呢

01:08:05.510 --> 01:08:06.470
我找了他一次

01:08:06.470 --> 01:08:07.350
那么找一次是不是

01:08:07.350 --> 01:08:08.470
有可能会找两次

01:08:08.470 --> 01:08:09.830
说到你还不能往后看

01:08:09.830 --> 01:08:10.550
还得看他

01:08:11.270 --> 01:08:12.390
还得继续看他

01:08:12.550 --> 01:08:13.110
你说

01:08:13.110 --> 01:08:13.750
看到是什么的

01:08:13.750 --> 01:08:14.470
还是i

01:08:15.030 --> 01:08:16.790
生于到硬幣是不是变少了

01:08:16.790 --> 01:08:17.910
生于到硬幣变成了

01:08:17.910 --> 01:08:18.630
rest

01:08:19.350 --> 01:08:20.310
减去

01:08:21.510 --> 01:08:22.310
faces

01:08:22.310 --> 01:08:22.630
i

01:08:24.230 --> 01:08:24.950
变这个样子

01:08:25.830 --> 01:08:27.030
就是我找他

01:08:27.830 --> 01:08:28.870
我找了他

01:08:28.870 --> 01:08:30.550
然后还在重复看这个位置

01:08:31.670 --> 01:08:32.710
还有种情况的优质

01:08:32.710 --> 01:08:33.510
就是我不找了

01:08:33.510 --> 01:08:34.790
这个硬幣我到此结束了

01:08:34.790 --> 01:08:35.830
我不找了

01:08:35.830 --> 01:08:37.430
不找的话就是目前就是0

01:08:37.430 --> 01:08:37.670
对吧

01:08:37.670 --> 01:08:38.470
这个硬幣我不找

01:08:39.030 --> 01:08:40.310
那么就直接得到

01:08:40.310 --> 01:08:41.030
后面的

01:08:41.510 --> 01:08:42.390
i加1

01:08:43.350 --> 01:08:43.750
rest

01:08:45.110 --> 01:08:45.750
越是不变

01:08:45.750 --> 01:08:46.470
i加1

01:08:46.470 --> 01:08:47.270
然后求税小

01:08:47.270 --> 01:08:48.710
这就是状态转移方程

01:08:48.710 --> 01:08:49.510
那么他同学们

01:08:49.510 --> 01:08:50.150
下来可以去

01:08:50.950 --> 01:08:51.510
试验一下

01:08:52.390 --> 01:08:53.190
那么用这种

01:08:53.190 --> 01:08:54.230
状态转移方程出来了

01:08:54.230 --> 01:08:54.870
其实这个题呢

01:08:54.870 --> 01:08:56.150
就已经不难了

01:08:56.150 --> 01:08:56.950
就已经不难了

01:08:58.390 --> 01:08:59.190
只是这个地方

01:08:59.190 --> 01:08:59.830
你要注意一下

01:09:00.390 --> 01:09:01.430
这个位置呢

01:09:01.430 --> 01:09:02.470
你还得重复看

01:09:02.470 --> 01:09:03.590
你不能直接列过了

01:09:03.590 --> 01:09:04.070
列过了

01:09:04.070 --> 01:09:04.630
是不行的

01:09:04.630 --> 01:09:05.670
因为他有可能想

01:09:05.670 --> 01:09:06.310
找到一次过

01:09:06.310 --> 01:09:07.830
还要继续往往继续找

01:09:08.710 --> 01:09:09.350
那么也就说

01:09:09.350 --> 01:09:10.070
我这一次

01:09:10.070 --> 01:09:10.790
要不要找他

01:09:11.110 --> 01:09:11.590
和这一次

01:09:11.590 --> 01:09:12.630
就直接不找他了

01:09:12.630 --> 01:09:13.990
是不是就这两种情况

01:09:13.990 --> 01:09:14.870
我不管后边的

01:09:14.870 --> 01:09:15.910
我就看这一次

01:09:15.910 --> 01:09:17.190
这一次我要不要找他

01:09:17.190 --> 01:09:18.150
要找这一次

01:09:18.150 --> 01:09:18.950
就是我找了他

01:09:18.950 --> 01:09:20.150
然后看剩余的

01:09:20.150 --> 01:09:21.110
最小的硬幣数量

01:09:21.670 --> 01:09:22.150
然后呢

01:09:22.150 --> 01:09:23.110
如果说不找他的话

01:09:23.110 --> 01:09:23.910
我就直接看后边的

01:09:23.910 --> 01:09:24.790
最小的硬幣数量

01:09:24.790 --> 01:09:25.750
两个求最小的字

01:09:25.750 --> 01:09:26.150
就ok

01:09:28.160 --> 01:09:28.480
OK

01:09:28.480 --> 01:09:29.600
那怎么这里呢

01:09:29.600 --> 01:09:30.000
就是

01:09:30.560 --> 01:09:32.400
一个动态回话的问题

01:09:33.920 --> 01:09:34.400
好了

01:09:34.400 --> 01:09:35.520
那么今天的课啊

01:09:36.480 --> 01:09:37.520
难度是高

01:09:37.520 --> 01:09:38.880
但是代码量不多

01:09:38.880 --> 01:09:40.080
咱们玩的也比较快

01:09:40.080 --> 01:09:40.560
行了

