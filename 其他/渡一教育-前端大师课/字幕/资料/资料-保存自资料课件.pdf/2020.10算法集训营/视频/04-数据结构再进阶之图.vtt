WEBVTT

00:03.630 --> 00:06.630
啊 又是新的一天了

00:07.630 --> 00:09.630
不对 今天都过完了

00:09.630 --> 00:12.630
来 生育画面没问题到Q&A

00:12.630 --> 00:18.970
好 加油 同学们

00:18.970 --> 00:24.050
双方基本上对前端的双方

00:24.050 --> 00:26.050
考察的没有那么难

00:26.050 --> 00:30.050
但是现在有往那方面去的趋势

00:30.050 --> 00:32.050
大家要有一个心理准备

00:32.050 --> 00:34.050
反正字节跳动

00:34.050 --> 00:39.050
它每一年考算法的比例是越来越多了

00:39.050 --> 00:41.050
而且难度也越来越深了

00:41.050 --> 00:43.050
以往那方面走的趋势

00:43.050 --> 00:45.050
大家要有这么一个心理准备

00:45.050 --> 00:47.050
因为金正丽变大了

00:47.050 --> 00:51.050
所以说我告诉大家真的要学早点学吧

00:51.050 --> 00:53.050
后边会越来越难

00:53.050 --> 00:55.050
考察的会越来越多

00:55.050 --> 00:59.320
来吧 今天图

01:00.320 --> 01:02.320
昨天讲的数 是吧

01:02.320 --> 01:05.320
数呢 实际上是图的一种

01:06.320 --> 01:09.320
咱们上课就没有那么多废话了

01:09.320 --> 01:11.320
直接就开始了

01:11.320 --> 01:13.320
因为时间本来就比较紧

01:13.320 --> 01:17.320
图呢 它数呢 实际上是图的一种

01:17.320 --> 01:20.320
图里边的算法呢

01:20.320 --> 01:22.320
没有数那么多

01:22.320 --> 01:24.320
我挑几个点型的

01:24.320 --> 01:27.700
给大家在今天晚上讲了

01:27.700 --> 01:29.700
图 什么叫图呢

01:29.700 --> 01:31.700
它也是跟数一样

01:31.700 --> 01:32.700
跟练表也一样

01:32.700 --> 01:35.700
它是有一个一个节点组成的

01:35.700 --> 01:37.700
只不过图这个玩意儿呢

01:37.700 --> 01:39.700
它没有什么要求

01:39.700 --> 01:41.700
练表是不是得一个指向另一个

01:41.700 --> 01:43.700
另一个指向下一个

01:43.700 --> 01:46.700
数呢 还有什么单根无环

01:46.700 --> 01:47.700
这么一些特点

01:47.700 --> 01:48.700
图没有什么要求

01:48.700 --> 01:49.700
你随便指

01:49.700 --> 01:51.700
爱指哪指哪

01:51.700 --> 01:53.700
这就是一个图

01:53.700 --> 01:54.700
每一个节点

01:54.700 --> 01:56.700
可以练结到任意数量的

01:56.700 --> 01:58.700
其他节点

01:58.700 --> 01:59.700
这就是图的特点

01:59.700 --> 02:02.700
没了 它就只有这个要求

02:02.700 --> 02:04.700
图中的每一个节点

02:04.700 --> 02:06.700
练结可以是有向的

02:06.700 --> 02:08.700
你看咱们之前学的练表

02:08.700 --> 02:09.700
是不是有方向

02:09.700 --> 02:11.700
第一个指向第二个

02:11.700 --> 02:13.700
第二个不能指向第一个

02:13.700 --> 02:15.700
当然也有双向练表的

02:15.700 --> 02:16.700
它会指回去

02:16.700 --> 02:19.700
不过我们这里只考虑单向练表

02:19.700 --> 02:21.700
它又是有方向的

02:21.700 --> 02:22.700
但图里边呢

02:22.700 --> 02:23.700
它可以有方向

02:23.700 --> 02:25.700
也可以没有方向

02:25.700 --> 02:27.700
今天晚上我们探到的图结构呢

02:27.700 --> 02:29.700
它是没有方向的

02:29.700 --> 02:31.700
你们以后在面试过程中呢

02:31.700 --> 02:33.700
如果说遇到了图

02:33.700 --> 02:35.700
十字八九都是没有方向的

02:35.700 --> 02:36.700
也就是它会练过来

02:36.700 --> 02:37.700
它也可以练回去

02:37.700 --> 02:39.700
它是有一个双向的

02:39.700 --> 02:43.700
双向我们就可以认为它没有方向

02:43.700 --> 02:44.700
我们的数结构

02:44.700 --> 02:46.700
其实就是一种特殊的图结构

02:46.700 --> 02:47.700
在图里边呢

02:47.700 --> 02:49.700
它是没有根

02:49.700 --> 02:50.700
你说哪个是根节点的

02:50.700 --> 02:52.700
你看不出哪个是根节点

02:52.700 --> 02:53.700
随便

02:53.700 --> 02:54.700
每一个节点都可以作为根

02:54.700 --> 02:57.700
它实际上根本就没有根

02:57.700 --> 02:58.700
然后呢

02:58.700 --> 02:59.700
它可以有环

02:59.700 --> 03:02.700
你看这不就是个环状结构吗

03:02.700 --> 03:03.700
但是啊

03:03.700 --> 03:05.700
图里边有一个要求就是

03:05.700 --> 03:07.700
一个图里边

03:07.700 --> 03:10.700
它不能出现两个

03:10.700 --> 03:13.700
或两个以上的孤立结点

03:13.700 --> 03:14.700
啥意思啊

03:14.700 --> 03:16.700
你看这

03:16.700 --> 03:18.700
随便拿一个吧

03:18.700 --> 03:20.700
这得是一个图吧

03:20.700 --> 03:21.700
这得是一个图吗

03:21.700 --> 03:22.700
对不对

03:22.700 --> 03:27.780
那如果说我这个玩意儿

03:27.780 --> 03:29.780
这个玩意儿还是一个图吗

03:29.780 --> 03:31.780
它就不是一个图了

03:31.780 --> 03:33.780
它是两个图

03:33.780 --> 03:35.780
存在了孤立结点

03:35.780 --> 03:36.780
对不对

03:36.780 --> 03:37.780
它存在了孤立结点

03:37.780 --> 03:38.780
那么它跟这个

03:38.780 --> 03:39.780
这张图呢

03:39.780 --> 03:40.780
是格格不入的

03:40.780 --> 03:41.780
它们之间没有

03:41.780 --> 03:42.780
这个结点跟这个图之间

03:42.780 --> 03:43.780
没有什么联系

03:43.780 --> 03:45.780
因此它要作算为两张图

03:45.780 --> 03:46.780
这是一张图

03:46.780 --> 03:48.780
这是一张图

03:48.780 --> 03:49.780
原来的意思吧

03:49.780 --> 03:53.410
就这么个意思啊

03:53.410 --> 03:54.410
因此在图里边

03:54.410 --> 03:55.410
可以很明显的看到

03:55.410 --> 03:56.410
任何一个结点

03:56.410 --> 03:58.410
从任何一个结点出发

03:58.410 --> 03:59.410
都可以找到图里边

03:59.410 --> 04:00.410
所有的结点

04:00.410 --> 04:01.410
是吧

04:01.410 --> 04:02.410
从这里出发

04:02.410 --> 04:03.410
你可以找到它

04:03.410 --> 04:04.410
它可以找到它

04:04.410 --> 04:05.410
对吧

04:05.410 --> 04:06.410
然后从它出发也是一样

04:06.410 --> 04:08.410
可以找到所有的结点

04:08.410 --> 04:09.410
好

04:09.410 --> 04:10.410
这就是图的特点

04:10.410 --> 04:11.410
所以很简单

04:11.410 --> 04:14.410
来 我们来看一下图的代码

04:14.410 --> 04:16.410
今天晚上一共有四道题

04:16.410 --> 04:17.410
三道题

04:17.410 --> 04:18.410
三道题做完了

04:18.410 --> 04:19.410
今天晚上的课就结束了

04:19.410 --> 04:20.410
那么大家可以想象到

04:20.410 --> 04:21.410
这三道题呢

04:21.410 --> 04:23.410
是比较耗费时间的

04:23.410 --> 04:25.410
图里边的代码呢

04:25.410 --> 04:27.410
就是如何来表示一个图呢

04:27.410 --> 04:29.410
我们跟之前的链表也好

04:29.410 --> 04:30.410
数结构也好

04:30.410 --> 04:31.410
都差不多

04:31.410 --> 04:33.410
都是用一个结点来表示

04:33.410 --> 04:34.410
对不对

04:34.410 --> 04:35.410
那么图里边怎么来表示

04:35.410 --> 04:36.410
一个结点呢

04:36.410 --> 04:37.410
还是一样

04:37.410 --> 04:38.410
它里边存一个数据

04:38.410 --> 04:39.410
随便什么数据都可以

04:39.410 --> 04:40.410
存数字啊

04:40.410 --> 04:41.410
存字无法随便

04:41.410 --> 04:42.410
无所谓

04:42.410 --> 04:43.410
存一个数据

04:43.410 --> 04:44.410
然后呢

04:44.410 --> 04:46.410
它里边有一个数组

04:46.410 --> 04:47.410
nevers

04:47.410 --> 04:48.410
什么意思啊

04:48.410 --> 04:49.410
就是邻居

04:49.410 --> 04:51.410
我这个我这个结点有哪些

04:51.410 --> 04:52.410
结点跟我相邻

04:52.410 --> 04:53.410
是一个空数组

04:53.410 --> 04:54.410
那么一共有相邻的

04:54.410 --> 04:55.410
就往这个数组里边夹

04:55.410 --> 04:56.410
这就是个图结构

04:56.410 --> 04:57.410
那比方说吧

04:57.410 --> 05:01.300
我们打开vscode

05:01.300 --> 05:04.300
这里写上这么一个图

05:04.300 --> 05:06.300
啊

05:07.300 --> 05:10.990
我来写上这么一个

05:10.990 --> 05:11.990
no

05:11.990 --> 05:12.990
构造函数

05:13.990 --> 05:14.990
往里边存一个数据

05:14.990 --> 05:15.990
什么数据都可以

05:15.990 --> 05:16.990
然后呢

05:16.990 --> 05:17.990
它有个nevers

05:17.990 --> 05:18.990
没

05:18.990 --> 05:19.990
完了

05:19.990 --> 05:21.990
我也不知道单词了

05:21.990 --> 05:22.990
nevers

05:22.990 --> 05:25.990
是一个空数组

05:25.990 --> 05:26.990
好

05:26.990 --> 05:27.990
这就是个图的结点

05:27.990 --> 05:28.990
那么如果说

05:28.990 --> 05:29.990
我们用这种方式

05:29.990 --> 05:30.990
来表示一张图

05:30.990 --> 05:31.990
怎么来表示呢

05:31.990 --> 05:32.990
比方就这张图吧

05:32.990 --> 05:33.990
这张图怎么来表示呢

05:33.990 --> 05:34.990
一共有几个结点

05:35.990 --> 05:36.990
6个结点

05:36.990 --> 05:37.990
对吧

05:37.990 --> 05:38.990
来吧

05:38.990 --> 05:39.990
写6个结点

05:39.990 --> 05:40.990
a

05:40.990 --> 05:41.990
u一个load

05:41.990 --> 05:42.990
里边就存一

05:42.990 --> 05:43.990
随便存吧

05:43.990 --> 05:44.990
为了大家看的方便

05:44.990 --> 05:45.990
我就存一个字无数

05:46.990 --> 05:47.990
6个结点

05:58.990 --> 06:00.990
一共这么些结点

06:01.990 --> 06:02.990
然后呢

06:02.990 --> 06:03.990
他们之间的关系呢

06:03.990 --> 06:06.990
是a结点跟b和c相连

06:06.990 --> 06:07.990
那么你就说

06:07.990 --> 06:08.990
这里的我要这样子写

06:08.990 --> 06:10.990
a neighbors

06:10.990 --> 06:11.990
push

06:11.990 --> 06:13.990
b和c相连

06:13.990 --> 06:14.990
b和c相连

06:14.990 --> 06:15.990
对吧

06:15.990 --> 06:16.990
那么这样子

06:16.990 --> 06:17.990
是a和b和c之间的关系的

06:17.990 --> 06:18.990
那么同样的道理

06:18.990 --> 06:19.990
b结点呢

06:19.990 --> 06:22.990
跟a和d相连

06:22.990 --> 06:23.990
d结点

06:23.990 --> 06:24.990
nevers

06:24.990 --> 06:25.990
它是双向的

06:25.990 --> 06:28.990
跟a和d相连

06:29.990 --> 06:30.990
好

06:30.990 --> 06:31.990
再来

06:31.990 --> 06:32.990
d结点呢

06:32.990 --> 06:35.990
跟那个a和d相连

06:35.990 --> 06:37.990
c结点跟b结点是一样的

06:37.990 --> 06:40.990
c结点跟那个a,d,e相连

06:40.990 --> 06:41.990
有三个相连的

06:41.990 --> 06:42.990
对吧

06:44.990 --> 06:45.990
c结点

06:45.990 --> 06:46.990
nevers

06:46.990 --> 06:47.990
push

06:47.990 --> 06:48.990
a

06:48.990 --> 06:50.990
d,e

06:50.990 --> 06:52.990
有三个结点相连

06:52.990 --> 06:53.990
看一下

06:53.990 --> 06:54.990
不要写错了

06:54.990 --> 06:55.990
好

06:55.990 --> 06:56.990
d结点

06:56.990 --> 06:58.990
跟b,c,f相连

06:58.990 --> 07:00.990
d结点

07:00.990 --> 07:02.990
b,c,f相连

07:02.990 --> 07:05.430
好

07:05.430 --> 07:06.430
又来

07:06.430 --> 07:08.430
e结点跟c,f相连

07:09.430 --> 07:10.430
e结点

07:11.430 --> 07:14.430
跟那个c,f相连

07:14.430 --> 07:15.430
好

07:15.430 --> 07:16.430
然后呢

07:16.430 --> 07:17.430
f结点呢

07:17.430 --> 07:18.430
跟d和e相连

07:18.430 --> 07:19.430
f结点

07:19.430 --> 07:20.430
跟

07:21.430 --> 07:22.430
那个

07:23.430 --> 07:25.430
d和e相连

07:25.430 --> 07:26.430
好

07:26.430 --> 07:27.430
这就是个图结构

07:27.430 --> 07:28.430
我们一起说看一下

07:33.820 --> 07:34.820
放心

07:34.820 --> 07:35.820
随便打一个结点

07:35.820 --> 07:36.820
你可以找到整张图

07:36.820 --> 07:37.820
你看比方说

07:37.820 --> 07:38.820
我们拿a结点

07:38.820 --> 07:39.820
a结点里边

07:39.820 --> 07:40.820
我们可以找到什么结点呢

07:40.820 --> 07:41.820
我们可以找到b和c

07:42.820 --> 07:43.820
然后b结点呢

07:43.820 --> 07:44.820
我们又可以找回来

07:44.820 --> 07:46.820
又可以找到a,对吧

07:46.820 --> 07:47.820
那么a结点

07:47.820 --> 07:48.820
又可以找回来

07:48.820 --> 07:50.820
又可以找到那个b和c

07:50.820 --> 07:51.820
而b结点呢

07:51.820 --> 07:52.820
又可以找回来

07:52.820 --> 07:53.820
找到a

07:53.820 --> 07:54.820
看到没有

07:54.820 --> 07:55.820
说是无穷无尽的

07:55.820 --> 07:56.820
从图里边

07:56.820 --> 07:57.820
如果说

07:57.820 --> 07:58.820
你不按照一定数据的

07:58.820 --> 07:59.820
找的话

07:59.820 --> 08:00.820
那肯定就造圈了

08:00.820 --> 08:02.820
它可能无穷无尽地找下去了

08:02.820 --> 08:03.820
你看

08:03.820 --> 08:04.820
可以无穷无尽地展开

08:04.820 --> 08:05.820
无穷无尽地找下去

08:05.820 --> 08:06.820
它是没有镜头的

08:06.820 --> 08:07.820
看到没

08:07.820 --> 08:08.820
它变成这个样子

08:08.820 --> 08:10.820
当然你往这个方向找

08:10.820 --> 08:11.820
d里边

08:11.820 --> 08:13.820
d里边又包含什么b,c,f

08:13.820 --> 08:15.820
b里边又包含什么ad

08:15.820 --> 08:18.820
a里边又包含b,c

08:18.820 --> 08:19.820
懂这个意思吧

08:19.820 --> 08:20.820
总之呢

08:20.820 --> 08:21.820
它是一个无穷无尽的结构

08:21.820 --> 08:22.820
它是一个圈

08:22.820 --> 08:24.820
你可能找的话

08:24.820 --> 08:25.820
你找不出来

08:25.820 --> 08:27.820
这就是图结构

08:27.820 --> 08:29.820
那么这种图结构呢

08:29.820 --> 08:31.820
我们在实际的开发中

08:31.820 --> 08:32.820
可能你们以后

08:32.820 --> 08:33.820
不太容易遇到

08:33.820 --> 08:34.820
什么情况下

08:34.820 --> 08:36.820
我们会产生一个图结构呢

08:36.820 --> 08:39.820
实际上我们上网的这些网页

08:39.820 --> 08:41.820
每一个网页之间的关系

08:41.820 --> 08:43.820
它就是一个图结构

08:43.820 --> 08:45.820
比方说我们随便举个例子

08:45.820 --> 08:47.820
咱们互联网上有很多网页

08:47.820 --> 08:49.820
从一个网页可以挑到另一个网页

08:49.820 --> 08:51.820
从另一个网页又可以挑到另外一个网页

08:51.820 --> 08:53.820
另一个网页又可能会照回来

08:53.820 --> 08:54.820
这就是一个图结构

08:54.820 --> 08:57.820
比方说我们从这个地址开始看

08:57.820 --> 08:59.820
那么现在这是一个网页

08:59.820 --> 09:01.820
比方说网页a

09:01.820 --> 09:03.820
它里面有很多的链接

09:03.820 --> 09:04.820
可以通过这个网页

09:04.820 --> 09:05.820
挑到别的网页

09:05.820 --> 09:07.820
比方说我们随便找一个

09:07.820 --> 09:09.820
不要挑到这个网页

09:09.820 --> 09:11.820
那么我们把它叫做网页b

09:11.820 --> 09:13.820
从网页b里面

09:13.820 --> 09:15.820
我们又可以挑到别的网页

09:15.820 --> 09:17.820
比方说我们随便找一个点这个

09:17.820 --> 09:19.820
这又是个网页对吧

09:19.820 --> 09:20.820
这又是个网页

09:20.820 --> 09:23.820
这是网页c

09:23.820 --> 09:25.820
然后点它

09:25.820 --> 09:26.820
点进去吧

09:26.820 --> 09:27.820
点它

09:27.820 --> 09:28.820
那么它又可以挑到别的网页

09:28.820 --> 09:30.820
网页d

09:30.820 --> 09:32.820
然后这个网页里面

09:32.820 --> 09:33.820
我们又看

09:33.820 --> 09:35.820
比方说一看一说又跳回来了

09:35.820 --> 09:38.820
比方说我点这个的话

09:38.820 --> 09:40.820
这是我的课程

09:40.820 --> 09:43.820
又挑到这个网页d

09:43.820 --> 09:45.820
这个网页e里面

09:45.820 --> 09:47.820
又可以点这个链接

09:47.820 --> 09:49.820
所以跳回来了

09:49.820 --> 09:51.820
又挑到这个网页a了

09:51.820 --> 09:52.820
对不对

09:52.820 --> 09:54.820
就像一种无穷无尽的环

09:54.820 --> 09:56.820
我们如果说

09:56.820 --> 09:59.820
当然大家以后也不会去做什么搜索引擎

10:00.820 --> 10:02.820
它爬去互联网那么网页

10:02.820 --> 10:03.820
它就是这样爬的

10:03.820 --> 10:05.820
从一个网页开始

10:05.820 --> 10:06.820
这个网页有很多超链接

10:06.820 --> 10:08.820
那么就相当于建立

10:08.820 --> 10:09.820
其他的节点的关系

10:09.820 --> 10:11.820
然后进入其他的页面

10:11.820 --> 10:12.820
然后从其他的页面里面

10:12.820 --> 10:15.820
又去找寻超链接

10:15.820 --> 10:16.820
又找到一大堆页面

10:16.820 --> 10:18.820
那么它有可能会找回来

10:18.820 --> 10:19.820
对不对

10:19.820 --> 10:20.820
就会形成一个图结构

10:20.820 --> 10:22.820
它的原始结构就会形成图结构

10:22.820 --> 10:23.820
当然了

10:23.820 --> 10:24.820
它的内部处理过程中

10:24.820 --> 10:26.820
它又可能会经过一些的

10:26.820 --> 10:27.820
复杂变换

10:27.820 --> 10:28.820
可能又会把它变成数结构

10:28.820 --> 10:29.820
但是它的原始结构

10:29.820 --> 10:31.820
它就是一个图结构

10:31.820 --> 10:32.820
懂不懂的意思吧

10:32.820 --> 10:35.820
这就是咱们这个图

10:35.820 --> 10:37.820
这是图里边任何一个节点

10:37.820 --> 10:39.820
可以表示一整张图

10:39.820 --> 10:47.790
接下来就是图里边的各种算法

10:47.790 --> 10:48.790
图里边的算法

10:48.790 --> 10:50.790
其实我们今天晚上就讲两个

10:50.790 --> 10:51.790
第一个是查询算法

10:51.790 --> 10:53.790
查询算法里面会写两个方法

10:53.790 --> 10:54.790
一个是深度优先

10:54.790 --> 10:56.790
一个是广度优先

10:56.790 --> 10:57.790
然后第二个算法

10:57.790 --> 10:58.790
比较繁朔一点

10:58.790 --> 11:00.790
叫最小生成数

11:00.790 --> 11:03.790
这个算法还蛮实用的

11:03.790 --> 11:07.940
好 第一个查询算法

11:07.940 --> 11:09.940
什么是查询算法呢

11:09.940 --> 11:11.940
就是我要从一个图里边

11:11.940 --> 11:13.940
比方说我这里有个查询

11:13.940 --> 11:14.940
一个函数

11:14.940 --> 11:16.940
search

11:16.940 --> 11:18.940
你给我一个节点

11:18.940 --> 11:19.940
随便给我哪个节点

11:19.940 --> 11:20.940
因为任何一个节点

11:20.940 --> 11:21.940
都可以找到图里边所有节点

11:21.940 --> 11:23.940
你随便给我一个

11:23.940 --> 11:25.940
然后给我一个找的目标

11:25.940 --> 11:27.940
你要找哪个值

11:27.940 --> 11:30.940
我就找一找这个数里边存不存在

11:30.940 --> 11:31.940
这个图里边存不存在这个值

11:31.940 --> 11:33.940
这就是个查询

11:33.940 --> 11:34.940
对不对

11:34.940 --> 11:36.940
那么这个查询具体该怎么去实现呢

11:36.940 --> 11:38.940
有两种实现方式

11:38.940 --> 11:40.940
一种叫做深度优先

11:40.940 --> 11:41.940
一种叫做广度优先

11:41.940 --> 11:43.940
就昨天那个数啊

11:43.940 --> 11:44.940
所以有类似的

11:44.940 --> 11:45.940
不过图的搜索呢

11:45.940 --> 11:47.940
要稍微麻烦一点

11:47.940 --> 11:49.940
我们首先看一个深度优先

11:49.940 --> 11:50.940
deep first

11:50.940 --> 11:54.440
deep search

11:54.440 --> 11:58.740
深度优先

11:58.740 --> 11:59.740
图

11:59.740 --> 12:00.740
图搜

12:00.740 --> 12:02.740
深度

12:02.740 --> 12:04.740
优先

12:04.740 --> 12:05.740
那么怎么来搜呢

12:05.740 --> 12:07.740
深度优先

12:07.740 --> 12:08.740
看这

12:08.740 --> 12:10.740
比方说我们就任何一个节点都可以啊

12:10.740 --> 12:12.740
比方说我们以A节点出发

12:12.740 --> 12:14.740
去搜整张图

12:14.740 --> 12:15.740
找一找我们的目标

12:15.740 --> 12:17.740
是不是在这个图里边

12:17.740 --> 12:19.740
那比方说找一个不存在的目标吧

12:19.740 --> 12:20.740
比方说我们找什么呢

12:20.740 --> 12:22.740
找那个T

12:22.740 --> 12:24.740
找T这个目标

12:24.740 --> 12:25.740
这个节点

12:25.740 --> 12:27.740
首先拿这个节点来看

12:27.740 --> 12:29.740
这个节点不是吧

12:29.740 --> 12:31.740
这不是

12:31.740 --> 12:32.740
好不是的话

12:32.740 --> 12:34.740
我就找它的

12:34.740 --> 12:36.740
铃区

12:36.740 --> 12:38.740
又重复这个动作

12:38.740 --> 12:39.740
找到B节点

12:39.740 --> 12:41.740
又看一下B节点是不是

12:41.740 --> 12:43.740
B节点也不是

12:43.740 --> 12:44.740
B节点不是的话

12:44.740 --> 12:46.740
又找B节点的铃区

12:46.740 --> 12:49.740
大家发现一个问题没有

12:49.740 --> 12:51.740
B节点的铃区

12:51.740 --> 12:53.740
是不是也包含A啊

12:53.740 --> 12:56.740
是不是有可能还会找回去

12:56.740 --> 12:57.740
看到没

12:57.740 --> 12:58.740
我找A

12:58.740 --> 12:59.740
A不是

12:59.740 --> 13:01.740
我就找它的铃区

13:01.740 --> 13:02.740
B和C

13:02.740 --> 13:03.740
比方说我们先找B

13:03.740 --> 13:05.740
找B的时候又是同样的规则

13:05.740 --> 13:06.740
B不是

13:06.740 --> 13:07.740
B不是又要找B的铃区

13:07.740 --> 13:08.740
B的铃区又谁

13:08.740 --> 13:11.740
是在那里反而来回横跳

13:11.740 --> 13:12.740
对不对

13:12.740 --> 13:13.740
那么这里一样子

13:13.740 --> 13:15.740
永远也出不去的

13:15.740 --> 13:16.740
大家有没有什么办法

13:16.740 --> 13:19.740
来解决这个问题

13:19.740 --> 13:20.740
对

13:20.740 --> 13:21.740
已经知道了

13:21.740 --> 13:23.740
这个其实也没有那么复杂

13:23.740 --> 13:24.740
就是找一个东西

13:24.740 --> 13:26.740
把已经找过的就存起来

13:26.740 --> 13:27.740
找过的你不是

13:27.740 --> 13:28.740
你不是我就存起来

13:28.740 --> 13:29.740
以后就不要找了

13:29.740 --> 13:30.740
所以说

13:30.740 --> 13:32.740
深度优先搜索的时候

13:32.740 --> 13:34.740
它需要有个东西

13:34.740 --> 13:35.740
比方说有一个书主

13:35.740 --> 13:36.740
一个什么玩意都行

13:36.740 --> 13:37.740
比方说你ES6学了过

13:37.740 --> 13:38.740
还可以有个set

13:38.740 --> 13:39.740
都可以

13:39.740 --> 13:40.740
我们现在有些同学

13:40.740 --> 13:41.740
很多同学还没有学过

13:41.740 --> 13:42.740
一个ES6

13:42.740 --> 13:44.740
那我就用普通的书主

13:44.740 --> 13:45.740
无所谓了

13:45.740 --> 13:48.740
就是说我有已经找过的东西

13:51.740 --> 13:54.740
比方有这么一个书主

13:54.740 --> 13:56.740
如果说这个书主里边

13:56.740 --> 13:57.740
这里边记录了啥

13:57.740 --> 13:58.740
这里边记录的是

13:58.740 --> 14:02.740
已经找过的

14:02.740 --> 14:03.740
不是的

14:03.740 --> 14:05.740
已经找过的

14:05.740 --> 14:06.740
不是

14:06.740 --> 14:07.740
不是我们要找的

14:07.740 --> 14:08.740
如果说找到了

14:08.740 --> 14:09.740
我们就直接结束了

14:09.740 --> 14:11.740
整个查到就结束了

14:11.740 --> 14:13.740
那么既然它里边

14:13.740 --> 14:14.740
保存了的

14:14.740 --> 14:16.740
说明它之前没有找到

14:16.740 --> 14:18.740
这个书主一开始是空的

14:18.740 --> 14:20.740
首先我们找A的时候

14:20.740 --> 14:21.740
找每一个节点的时候

14:21.740 --> 14:23.740
我们先看一下

14:23.740 --> 14:24.740
它有没有找过

14:24.740 --> 14:26.740
如果说已经找过了

14:26.740 --> 14:27.740
我是不是不用再找了

14:28.740 --> 14:29.740
表示

14:29.740 --> 14:30.740
这个节点肯定不是

14:30.740 --> 14:31.740
因为以前找过了都不是

14:31.740 --> 14:33.740
那么现在没有必要再去找了

14:33.740 --> 14:34.740
除了说

14:34.740 --> 14:35.740
那么A一开始

14:35.740 --> 14:36.740
这个书主是空的

14:36.740 --> 14:37.740
因此

14:37.740 --> 14:38.740
A是不是呢

14:38.740 --> 14:40.740
要看一下

14:40.740 --> 14:41.740
那么我们找的是谁

14:41.740 --> 14:42.740
找的是T

14:42.740 --> 14:43.740
那么A不等于T

14:43.740 --> 14:44.740
就说A不是

14:44.740 --> 14:45.740
不是怎么办

14:45.740 --> 14:46.740
不是就把它放到

14:46.740 --> 14:47.740
这个书主里边去

14:47.740 --> 14:49.740
放到这里边来

14:49.740 --> 14:50.740
好

14:50.740 --> 14:51.740
接下来找A的凝聚

14:51.740 --> 14:53.740
A的凝聚是几呢

14:53.740 --> 14:54.740
有B和C

14:54.740 --> 14:55.740
那么我们先找B

14:55.740 --> 14:56.740
对B呢

14:56.740 --> 14:58.740
又是用同样的规则

14:58.740 --> 15:00.740
看一下B有没有找过呢

15:00.740 --> 15:01.740
B

15:01.740 --> 15:02.740
找过没

15:02.740 --> 15:03.740
没有找过

15:03.740 --> 15:04.740
没有找过去看B是不是

15:04.740 --> 15:05.740
B也不是

15:05.740 --> 15:06.740
也不是的话

15:06.740 --> 15:07.740
B又找过了

15:07.740 --> 15:09.740
我们把B放过来

15:09.740 --> 15:11.740
接下来同样的规则

15:11.740 --> 15:13.740
B里边不是有

15:13.740 --> 15:16.740
B里边不是有凝聚吗

15:16.740 --> 15:17.740
A和D

15:17.740 --> 15:18.740
对不对

15:18.740 --> 15:19.740
好

15:19.740 --> 15:20.740
然后B找它的凝聚

15:20.740 --> 15:21.740
A

15:21.740 --> 15:22.740
A是不是找过了

15:22.740 --> 15:24.740
找过了就直接结束了

15:24.740 --> 15:25.740
那么就表示不是

15:25.740 --> 15:26.740
好

15:26.740 --> 15:27.740
B的凝聚有D

15:27.740 --> 15:28.740
A

15:28.740 --> 15:29.740
D没有找过

15:29.740 --> 15:30.740
对吧

15:30.740 --> 15:31.740
这里边没有找过

15:31.740 --> 15:32.740
没有找过的话

15:32.740 --> 15:33.740
那么我们就看一下

15:33.740 --> 15:34.740
D是不是

15:34.740 --> 15:35.740
D也不是

15:35.740 --> 15:36.740
D也不是的话

15:36.740 --> 15:37.740
那么D又找过了

15:37.740 --> 15:38.740
那么同样的D

15:38.740 --> 15:39.740
它也有凝聚

15:39.740 --> 15:40.740
对吧

15:40.740 --> 15:41.740
C和F

15:41.740 --> 15:42.740
它没有找C

15:42.740 --> 15:43.740
看C是不是呢

15:43.740 --> 15:44.740
C也不是

15:44.740 --> 15:45.740
懂了意思吧

15:45.740 --> 15:47.740
我不再往后边一一言识了

15:47.740 --> 15:49.740
这就是深度有限

15:49.740 --> 15:52.740
不断的从凝聚后边去找

15:52.740 --> 15:53.740
好

15:53.740 --> 15:54.740
它这个单码怎么写的

15:54.740 --> 15:59.780
单码怎么写

15:59.780 --> 16:01.780
这里有重复的查找行为

16:01.780 --> 16:03.780
是不是得抵规

16:03.780 --> 16:05.780
就得抵规抵规

16:05.780 --> 16:06.780
然后同时

16:06.780 --> 16:07.780
这里是不是有

16:07.780 --> 16:09.780
已经找过的东西

16:09.780 --> 16:11.780
需要一个数组

16:11.780 --> 16:13.780
来保存已经找过的决定

16:13.780 --> 16:15.780
因此我们这里先建立一个数组

16:15.780 --> 16:18.340
Finding

16:18.340 --> 16:19.340
一个数组

16:19.340 --> 16:20.340
一开始为空

16:20.340 --> 16:23.340
已经找过的决定

16:23.340 --> 16:25.340
所以要保存一下

16:25.340 --> 16:26.340
好那么

16:26.340 --> 16:27.340
大家想一想

16:27.340 --> 16:28.340
如果说我这样子写单码

16:28.340 --> 16:30.340
会不会有问题

16:30.340 --> 16:31.340
一波肯定得抵规

16:31.340 --> 16:32.340
我不管是什么情况的抵规

16:32.340 --> 16:33.340
反正你写了一大堆单码

16:33.340 --> 16:35.340
肯定要调用它自己

16:35.340 --> 16:36.340
肯定得抵规

16:36.340 --> 16:37.340
对不对

16:37.340 --> 16:38.340
找它的什么邻居

16:38.340 --> 16:39.340
比如比方说

16:39.340 --> 16:40.340
我随便找一个

16:40.340 --> 16:41.340
找它的第一个邻居

16:41.340 --> 16:43.340
然后找它可以省

16:43.340 --> 16:45.340
那如果说你这样子写的话

16:45.340 --> 16:47.340
下一次调用这个函数

16:47.340 --> 16:48.340
你看这里又要重新调用这个函数

16:48.340 --> 16:49.340
下一次调用这个函数

16:49.340 --> 16:51.340
这个变量是不是又被

16:51.340 --> 16:53.340
复制为空数组了

16:53.340 --> 16:54.340
对不对

16:54.340 --> 16:56.340
那就说每一次找的时候

16:56.340 --> 16:57.340
都是一个新的

16:57.340 --> 16:58.340
翻计的变量

16:58.340 --> 17:00.660
明白了意思吗

17:00.660 --> 17:01.660
所以每一次找的时候

17:01.660 --> 17:02.660
都是一个新的

17:02.660 --> 17:03.660
翻计的变量

17:03.660 --> 17:05.660
那么我们

17:05.660 --> 17:06.660
我们希望的是咋呢

17:06.660 --> 17:07.660
这个翻计的

17:07.660 --> 17:09.660
它会影响整个查找过程

17:09.660 --> 17:11.660
在整个的查找期间

17:11.660 --> 17:12.660
它都使用的是

17:12.660 --> 17:15.660
同一个数组

17:15.660 --> 17:16.660
那么这个数组里边

17:16.660 --> 17:18.660
记录了已经找过的东西

17:18.660 --> 17:19.660
对不对

17:19.660 --> 17:20.660
那么如果说你用

17:20.660 --> 17:21.660
这种方式来写

17:21.660 --> 17:22.660
对它自己进行抵规的话

17:22.660 --> 17:24.660
就会有这样的问题

17:24.660 --> 17:26.660
就会有这样的问题

17:27.660 --> 17:29.660
好 那怎么办呢

17:29.660 --> 17:30.660
那怎么办呢

17:30.660 --> 17:31.660
办法呢

17:31.660 --> 17:33.660
跟之前的天

17:33.660 --> 17:34.660
每一天进步

17:34.660 --> 17:35.660
几乎都会用的一个办法

17:35.660 --> 17:36.660
一样

17:36.660 --> 17:37.660
我写这么一个

17:37.660 --> 17:41.290
内部的函数

17:41.290 --> 17:42.290
deep search

17:42.290 --> 17:45.180
漏的就

17:45.180 --> 17:46.180
给我就行了

17:46.180 --> 17:47.180
因为它会不会变

17:47.180 --> 17:48.180
我在这个函数里边

17:48.180 --> 17:50.180
对自己的抵规

17:50.180 --> 17:51.180
那么这个函数反而会

17:51.180 --> 17:52.180
调用自己

17:52.180 --> 17:53.180
是不是不会影响

17:53.180 --> 17:54.180
那个翻计的变量

17:54.180 --> 17:55.180
这个变量在

17:55.180 --> 17:56.180
这个函数弯一边

17:56.180 --> 17:58.180
所以说这个函数内部

17:58.180 --> 17:59.180
使用的是

17:59.180 --> 18:02.180
就该函数内部

18:02.180 --> 18:07.180
无论进行多少次抵规

18:07.180 --> 18:09.180
使用的都是

18:09.180 --> 18:11.180
同一个

18:11.180 --> 18:13.180
翻计的变量

18:13.180 --> 18:14.180
没啥意思吧

18:14.180 --> 18:16.180
我得这么去写

18:16.180 --> 18:17.180
那有人说

18:17.180 --> 18:18.180
那这样子行不行呢

18:18.180 --> 18:20.180
我把这个翻计的放出去

18:20.180 --> 18:22.180
这些都是介石基础

18:22.180 --> 18:23.180
放出去

18:23.180 --> 18:24.180
然后我就不需要这个函数了

18:24.180 --> 18:25.180
我就可以

18:25.180 --> 18:26.180
在这里计规的

18:26.180 --> 18:27.180
那可不可以呢

18:27.180 --> 18:28.180
可以

18:28.180 --> 18:29.180
那这样子的

18:29.180 --> 18:30.180
畢竟会莫名其妙的

18:30.180 --> 18:31.180
就污染了一个选举变量

18:31.180 --> 18:32.180
何必呢

18:32.180 --> 18:33.180
这个本来

18:33.180 --> 18:34.180
这个变量的

18:34.180 --> 18:35.180
本来就是为了

18:35.180 --> 18:36.180
实现深度优先搜索

18:36.180 --> 18:38.180
内部使用的变量

18:38.180 --> 18:40.180
那何必在这里弄弄的

18:40.180 --> 18:41.180
所以说我们这里

18:41.180 --> 18:42.180
用这种方式

18:42.180 --> 18:43.180
这个地方能听懂吗

18:43.180 --> 18:47.510
能听懂Q和E的

18:47.510 --> 18:48.510
对对对

18:48.510 --> 18:49.510
英文是放的

18:49.510 --> 18:50.510
放的

18:50.510 --> 18:56.220
放的

18:56.220 --> 18:57.220
能听懂

18:57.220 --> 18:58.220
好

18:58.220 --> 18:59.220
那么现在我们要写

18:59.220 --> 19:00.220
这个函数而已

19:00.220 --> 19:01.220
无非也就是说

19:01.220 --> 19:02.220
我外面这个函数

19:02.220 --> 19:03.220
要做的事情

19:03.220 --> 19:04.220
就是调用里边

19:04.220 --> 19:06.220
我把漏的传进去

19:06.220 --> 19:07.220
就完了

19:07.220 --> 19:09.220
就靠它来帮我了

19:09.220 --> 19:10.220
那么这个函数怎么写呢

19:10.220 --> 19:11.220
按照我们之前的分析

19:11.220 --> 19:13.220
首先就要看

19:13.220 --> 19:14.220
你不是要找

19:14.220 --> 19:15.220
找这个节点吗

19:15.220 --> 19:16.220
看这个节点是不是

19:16.220 --> 19:17.220
这个节点是

19:17.220 --> 19:18.220
有没有找过

19:18.220 --> 19:19.220
如果说找过了

19:19.220 --> 19:20.220
我就不找了

19:20.220 --> 19:22.220
去判断一下

19:22.220 --> 19:23.220
判断什么

19:23.220 --> 19:25.220
判断

19:25.220 --> 19:26.220
这个数组里边

19:26.220 --> 19:29.220
是不是已经存在这个节点了

19:29.220 --> 19:30.220
因为我们找了一个节点

19:30.220 --> 19:31.220
我就往里面加

19:31.220 --> 19:32.220
对吧

19:32.220 --> 19:33.220
已经存在了

19:33.220 --> 19:34.220
已经找过了

19:34.220 --> 19:35.220
那怎么来判断

19:35.220 --> 19:36.220
是不是存在

19:36.220 --> 19:37.220
我们可以用

19:37.220 --> 19:39.220
s5的数组里边

19:39.220 --> 19:41.220
应该是s6

19:41.220 --> 19:42.220
s6里边数组一个方法

19:42.220 --> 19:43.220
叫includes

19:43.220 --> 19:44.220
给它介绍一下

19:44.220 --> 19:45.220
方法非常简单

19:45.220 --> 19:47.220
随便来一个数组吧

19:47.220 --> 19:49.220
就是这个吧

19:49.220 --> 19:51.220
我要看这个数组里边

19:51.220 --> 19:53.220
是不是存在一个数字3

19:53.220 --> 19:54.220
怎么判断的

19:54.220 --> 19:57.220
includes3

19:57.220 --> 19:59.220
它反回2就表示存在

19:59.220 --> 20:01.220
反回force就表示不存在

20:01.220 --> 20:02.220
这个非常简单

20:02.220 --> 20:03.220
用es6这个方法

20:03.220 --> 20:04.220
可以迅速的判断

20:04.220 --> 20:05.220
一个数组里边

20:05.220 --> 20:07.220
是不是存在某一个字

20:07.220 --> 20:08.220
好

20:08.220 --> 20:09.220
那么这里呢

20:09.220 --> 20:10.220
我们就可以修

20:10.220 --> 20:12.220
fund

20:12.220 --> 20:14.220
includes

20:14.220 --> 20:15.220
load

20:15.220 --> 20:18.780
如果该节点

20:18.780 --> 20:19.780
已经找过了

20:19.780 --> 20:20.780
已经找过了

20:20.780 --> 20:21.780
说明啥

20:21.780 --> 20:22.780
之前就说明

20:22.780 --> 20:24.780
之前这个节点就不是

20:24.780 --> 20:25.780
不然的话

20:25.780 --> 20:26.780
它进不了这个数组

20:26.780 --> 20:27.780
对吧

20:27.780 --> 20:29.780
找到了早就结束了

20:29.780 --> 20:30.780
它之所以没有结束

20:30.780 --> 20:31.780
是因为它没有找到

20:31.780 --> 20:33.780
才把它放到数组里边去

20:33.780 --> 20:34.780
所以说呢

20:34.780 --> 20:35.780
这个已经找过了

20:35.780 --> 20:36.780
肯定不是

20:36.780 --> 20:37.780
所以说直接反回force

20:37.780 --> 20:39.780
这个我已经没问题了

20:39.780 --> 20:41.780
找过了我就不看了

20:41.780 --> 20:43.780
就像你找人一样

20:43.780 --> 20:44.780
你之前找过了车箱

20:44.780 --> 20:46.780
你看那你还缺

20:46.780 --> 20:47.780
继续看吧

20:47.780 --> 20:48.780
不用看了

20:48.780 --> 20:49.780
因为之前找过

20:49.780 --> 20:52.990
你没有结束

20:52.990 --> 20:53.990
说明肯定没有

20:53.990 --> 20:54.990
那么现在我们

20:54.990 --> 20:55.990
进入下面的逻辑

20:55.990 --> 20:57.990
它没有找过之前

20:57.990 --> 20:58.990
那怎么办

20:58.990 --> 21:00.990
首先看一下你是不是

21:00.990 --> 21:01.990
如果说

21:01.990 --> 21:03.990
等于了什么talkit

21:03.990 --> 21:09.000
等于了talkit

21:09.000 --> 21:10.000
怎么办呢

21:10.000 --> 21:12.000
那就反回数

21:12.000 --> 21:13.000
找到了

21:13.000 --> 21:14.000
找到了就停止了

21:14.000 --> 21:16.000
不要再找了

21:16.000 --> 21:18.000
好

21:18.000 --> 21:19.000
这是找到的情况

21:19.000 --> 21:21.000
那么没有找到了

21:21.000 --> 21:23.000
没有找到怎么办呢

21:23.000 --> 21:25.000
没有找到还是一样

21:25.000 --> 21:26.000
没有找到的话

21:26.000 --> 21:27.000
我是不是得往

21:27.000 --> 21:29.000
这个数组里边加一个

21:29.000 --> 21:30.000
对不对

21:30.000 --> 21:31.000
说明我这个节点

21:31.000 --> 21:32.000
肯定不是

21:32.000 --> 21:34.000
我自己肯定不是了

21:34.000 --> 21:35.000
这个节点

21:35.000 --> 21:36.000
不是

21:36.000 --> 21:38.000
已经找过了

21:38.000 --> 21:39.000
说往里面加

21:39.000 --> 21:41.000
方便后边的搜索

21:41.000 --> 21:43.000
脸的重复看这一节点

21:43.000 --> 21:46.500
这个节点不是

21:46.500 --> 21:48.500
好那么如果说

21:48.500 --> 21:49.500
这个节点不是

21:49.500 --> 21:50.500
就完了吗

21:50.500 --> 21:51.500
肯定不行

21:51.500 --> 21:52.500
还要看什么

21:52.500 --> 21:53.500
看铭句

21:53.500 --> 21:54.500
它找过了

21:54.500 --> 21:55.500
是不是还能看

21:55.500 --> 21:56.500
它的铭句

21:56.500 --> 21:57.500
它的铭句是一个数组

21:57.500 --> 21:59.500
是不是得循环

21:59.500 --> 22:01.500
循环什么

22:01.500 --> 22:03.500
load the neighbors

22:04.500 --> 22:07.500
找它的铭句

22:07.500 --> 22:09.500
一个一个来

22:09.500 --> 22:11.500
每一次拿到一个铭句过后

22:11.500 --> 22:12.500
什么的

22:12.500 --> 22:13.500
拿到下一个节点

22:13.500 --> 22:14.500
next load

22:14.500 --> 22:17.500
load the neighbors

22:17.500 --> 22:19.500
拿到下一个节点

22:19.500 --> 22:21.500
它是这个铭句

22:21.500 --> 22:22.500
然后接下来

22:22.500 --> 22:23.500
是不是要做的事情

22:23.500 --> 22:24.500
就是一样的

22:24.500 --> 22:26.500
看这个铭句是不是

22:26.500 --> 22:27.500
那么现在

22:27.500 --> 22:28.500
我们来判断一下

22:28.500 --> 22:29.500
如果

22:29.500 --> 22:30.500
继续用这个声搜

22:30.500 --> 22:32.500
对它铭句也是一样的做

22:34.500 --> 22:35.500
对不对

22:36.500 --> 22:37.500
铭句是

22:37.500 --> 22:38.500
而我不是

22:38.500 --> 22:39.500
但是铭句

22:39.500 --> 22:41.500
通过铭句

22:41.500 --> 22:42.500
找到了

22:42.500 --> 22:43.500
那么找到了过后

22:43.500 --> 22:45.500
是不是就返回处

22:45.500 --> 22:46.500
对不对

22:46.500 --> 22:47.500
继续返回处

22:47.500 --> 22:49.500
找到了过后就返回处

22:49.500 --> 22:50.500
那就不用再

22:50.500 --> 22:51.500
继续往后面看铭句了

22:51.500 --> 22:52.500
不用再循环了

22:52.500 --> 22:53.500
找到就返回处

22:53.500 --> 22:55.500
那没有找到了

22:56.500 --> 22:57.500
你不能还是一样

22:57.500 --> 22:58.500
你不能在这里写ls

22:58.500 --> 23:00.500
不然你只看到一个铭句

23:00.500 --> 23:02.500
你再把它循环完

23:02.500 --> 23:03.500
把所有的铭句全部看完了

23:03.500 --> 23:04.500
都不是

23:04.500 --> 23:05.500
那么这里返回处

23:07.500 --> 23:09.500
所有铭句都看完了

23:09.500 --> 23:12.500
所有的铭句都不是

23:12.500 --> 23:13.500
这就是个声搜

23:13.500 --> 23:16.710
好

23:16.710 --> 23:17.710
咱们来看一下

23:20.710 --> 23:21.710
到一面上来

23:22.710 --> 23:23.710
deep search

23:27.240 --> 23:28.240
比方说我们找这个load

23:28.240 --> 23:29.240
找这个k

23:29.240 --> 23:30.240
有没有这个k

23:30.240 --> 23:31.240
好像没有

23:31.240 --> 23:32.240
对吧

23:32.240 --> 23:34.240
找default

23:34.240 --> 23:35.240
刷新一下

23:36.240 --> 23:38.240
deep search

23:39.240 --> 23:41.240
load不是那地方的

23:41.240 --> 23:42.240
A

23:42.240 --> 23:43.240
把这个A扔进去吧

23:43.240 --> 23:44.240
然后呢

23:44.240 --> 23:45.240
我们找什么

23:45.240 --> 23:46.240
找k

23:47.240 --> 23:48.240
找不到

23:48.240 --> 23:50.240
那如果说我找一个C呢

23:50.240 --> 23:51.240
找到的

23:51.240 --> 23:52.240
那么我们可以打印出来

23:52.240 --> 23:54.240
看一下它的查到过程

23:54.240 --> 23:55.240
打印一下

23:55.240 --> 23:56.240
找问了节点

23:56.240 --> 23:57.240
我们不打印了

23:57.240 --> 23:58.240
没有找问了节点

23:58.240 --> 23:59.240
我们来找看一下

23:59.240 --> 24:00.240
它的查到过程

24:00.240 --> 24:01.240
查到顺序

24:01.240 --> 24:02.240
load

24:03.240 --> 24:04.240
C

24:04.240 --> 24:05.240
刷新一下

24:06.240 --> 24:08.240
找的顺序是abdc

24:09.240 --> 24:10.240
先找A

24:10.240 --> 24:11.240
再找它的铭句

24:11.240 --> 24:12.240
B

24:12.240 --> 24:13.240
再找它的什么

24:13.240 --> 24:14.240
B的铭句

24:14.240 --> 24:16.240
B的铭句A已经找过了

24:16.240 --> 24:17.240
那么去找D

24:17.240 --> 24:18.240
对吧

24:18.240 --> 24:19.240
D也不是

24:19.240 --> 24:20.240
那么去找D的铭句

24:20.240 --> 24:21.240
B已经找过了

24:21.240 --> 24:22.240
所以就找C

24:22.240 --> 24:23.240
对不对

24:23.240 --> 24:24.240
A C找到了

24:24.240 --> 24:26.680
这就是深度优先

24:26.680 --> 24:27.680
这是这一块

24:27.680 --> 24:28.680
deep search

24:28.680 --> 24:29.680
这一块

24:29.680 --> 24:31.680
经过这么几天的训练

24:31.680 --> 24:32.680
应该是

24:32.680 --> 24:33.680
问题不大

24:33.680 --> 24:34.680
这一块

24:34.680 --> 24:35.680
有没有问题

24:35.680 --> 24:36.680
没问题

24:36.680 --> 24:39.060
可以

24:39.060 --> 24:40.060
判断in这个社会

24:40.060 --> 24:41.060
为富一也可以

24:41.060 --> 24:42.060
也可以也可以

24:42.060 --> 24:43.060
因为

24:43.060 --> 24:44.060
为啥呢

24:44.060 --> 24:45.060
因为es6

24:45.060 --> 24:46.060
它是这样子认为的

24:46.060 --> 24:47.060
我们以前不就是

24:47.060 --> 24:48.060
这样做的吗

24:48.060 --> 24:49.060
判断一个东西

24:49.060 --> 24:50.060
在数组里面存不存在

24:50.060 --> 24:51.060
用in这个社会

24:51.060 --> 24:52.060
对不对

24:52.060 --> 24:53.060
判断

24:53.060 --> 24:54.060
它觉得

24:54.060 --> 24:55.060
从语意上

24:55.060 --> 24:56.060
看上去怪怪的

24:56.060 --> 24:58.060
不是很好阅读

24:58.060 --> 24:59.060
为啥呢

24:59.060 --> 25:00.060
因为in这个社会

25:00.060 --> 25:01.060
什么意思

25:01.060 --> 25:02.060
表示得到某一个地

25:02.060 --> 25:04.060
某一个东西的下标

25:04.060 --> 25:05.060
而我们要做的啥

25:05.060 --> 25:06.060
看它存不存在

25:06.060 --> 25:07.060
是不是要绕一下

25:07.060 --> 25:08.060
对吧

25:08.060 --> 25:09.060
当然下标为富一

25:09.060 --> 25:10.060
就表示不存在

25:10.060 --> 25:11.060
是不是要脑袋里

25:11.060 --> 25:12.060
要绕一下

25:12.060 --> 25:13.060
那就不如有这种

25:13.060 --> 25:14.060
这个东西

25:14.060 --> 25:15.060
可读性是不是非常强

25:15.060 --> 25:16.060
它是不是存在

25:16.060 --> 25:17.060
什么什么

25:17.060 --> 25:18.060
可读性是不是要强很多

25:18.060 --> 25:19.060
就这么个意思

25:19.060 --> 25:20.060
所以es6

25:20.060 --> 25:21.060
它就把这些小的

25:21.060 --> 25:22.060
小的一些

25:22.060 --> 25:24.880
给它改进了

25:24.880 --> 25:25.880
印

25:25.880 --> 25:28.640
印什么呢

25:29.640 --> 25:30.640
好

25:30.640 --> 25:31.640
来

25:31.640 --> 25:35.340
这是深度优先

25:35.340 --> 25:36.340
就是es6

25:36.340 --> 25:37.340
在很多那种

25:37.340 --> 25:38.340
语意上的一些

25:38.340 --> 25:39.340
语意上是非常不错的

25:41.340 --> 25:42.340
好

25:42.340 --> 25:43.340
现在是广度优先

25:43.340 --> 25:46.340
又来breeze search

25:46.340 --> 25:47.340
同样的参数

25:47.340 --> 25:51.030
loadtoges

25:51.030 --> 25:53.030
这也是个图搜

25:53.030 --> 25:55.030
广度优先

25:55.030 --> 25:57.030
我们先把两个搜索上

25:57.030 --> 25:58.030
写完了

25:58.030 --> 26:00.660
先开开位

26:00.660 --> 26:01.660
来

26:01.660 --> 26:03.660
广度优先是怎么搜呢

26:03.660 --> 26:04.660
跟昨天那个数

26:04.660 --> 26:05.660
是一样的

26:05.660 --> 26:06.660
它实际上就是

26:06.660 --> 26:08.660
一层一层的来

26:08.660 --> 26:09.660
比方说

26:09.660 --> 26:10.660
第一次搜啥

26:10.660 --> 26:11.660
比方说a

26:12.660 --> 26:13.660
s完了过后

26:13.660 --> 26:14.660
搜a的邻居

26:14.660 --> 26:16.660
a的邻居是啥

26:16.660 --> 26:17.660
b和c

26:17.660 --> 26:19.660
我换个颜色

26:19.660 --> 26:20.660
b和c

26:20.660 --> 26:21.660
又搜这两个

26:21.660 --> 26:22.660
这两个不是

26:22.660 --> 26:23.660
不是的话

26:23.660 --> 26:24.660
又搜他们的邻居

26:24.660 --> 26:26.660
b和c的邻居是啥

26:26.660 --> 26:27.660
所以又有重复的

26:27.660 --> 26:28.660
又会跳回来

26:28.660 --> 26:29.660
又会来回红跳

26:29.660 --> 26:31.660
是不是还得有一个东西

26:31.660 --> 26:32.660
来换存

26:32.660 --> 26:34.660
已经找过的东西

26:34.660 --> 26:35.660
还是有一个东西

26:35.660 --> 26:36.660
得换存

26:36.660 --> 26:38.660
已经找过的东西

26:38.660 --> 26:39.660
你看

26:39.660 --> 26:40.660
b和c的邻居

26:40.660 --> 26:41.660
有什么呢

26:41.660 --> 26:43.660
有a有d有e

26:43.660 --> 26:44.660
但是a已经找过了

26:44.660 --> 26:46.660
因此下一个层次

26:46.660 --> 26:50.170
我就搜d和e

26:50.170 --> 26:51.170
我就搜d和e

26:51.170 --> 26:53.170
好,d和e的邻居有哪些呢

26:53.170 --> 26:54.170
有b,c,f

26:54.170 --> 26:56.170
但是b和c已经找过了

26:56.170 --> 26:57.170
那么我们只搜

26:57.170 --> 26:59.170
最后一个搜f

26:59.170 --> 27:00.170
懂我的意思吗

27:00.170 --> 27:03.860
这就是广搜

27:03.860 --> 27:04.860
那么从广搜

27:04.860 --> 27:05.860
这种做法里边

27:05.860 --> 27:07.860
跟那个数

27:07.860 --> 27:08.860
到底是一样的

27:08.860 --> 27:10.860
它是不是一层一层来的

27:10.860 --> 27:12.860
就是一层一层来的

27:12.860 --> 27:13.860
那么每一次

27:13.860 --> 27:15.860
每一层是不是有多个节点

27:15.860 --> 27:17.860
是不是得有一个数组

27:17.860 --> 27:19.860
所以它从一个数组里面去搜

27:19.860 --> 27:20.860
不像那个深搜

27:20.860 --> 27:21.860
它是一个节点

27:21.860 --> 27:22.860
一个节点来的

27:22.860 --> 27:23.860
那么广搜是一层一层来的

27:23.860 --> 27:25.860
一层它可能会有多个节点

27:25.860 --> 27:26.860
我这个图里边

27:26.860 --> 27:27.860
最多还有两个

27:27.860 --> 27:28.860
最多有三个

27:28.860 --> 27:29.860
有四个有五个

27:29.860 --> 27:31.860
我也说不准

27:31.860 --> 27:32.860
那么怎么办呢

27:32.860 --> 27:34.860
我这里给的是一个节点

27:34.860 --> 27:35.860
但是我每搜一层

27:35.860 --> 27:36.860
是一双节点

27:36.860 --> 27:38.860
一大堆节点

27:38.860 --> 27:39.860
昨天可能不是很好理解

27:39.860 --> 27:40.860
那昨天的东西理解了

27:40.860 --> 27:42.860
那今天有东西广楼搜索

27:42.860 --> 27:43.860
基本上到底是一样的

27:43.860 --> 27:45.860
不得还有一个东西吗

27:45.860 --> 27:46.860
还是得有一个辅助

27:46.860 --> 27:47.860
还说

27:47.860 --> 27:49.860
freeze search

27:49.860 --> 27:50.860
你给我发一个什么

27:50.860 --> 27:51.860
数组

27:51.860 --> 27:52.860
对不对

27:52.860 --> 27:54.860
我们一层是一个数组吗

27:54.860 --> 27:55.860
它可以说不用传的

27:55.860 --> 27:56.860
都一样

27:57.860 --> 27:58.860
每一层是个数组

27:58.860 --> 27:59.860
对吧

27:59.860 --> 28:00.860
每一层不算

28:00.860 --> 28:01.860
这个节点

28:01.860 --> 28:02.860
节点的不一样

28:02.860 --> 28:03.860
那我不得

28:03.860 --> 28:04.860
还得有一个这个

28:04.860 --> 28:05.860
fund

28:05.860 --> 28:06.860
对不对

28:06.860 --> 28:07.860
已经找过的

28:08.860 --> 28:09.860
到底应该是放的

28:09.860 --> 28:10.860
还是fandy的

28:11.860 --> 28:13.860
有没有fandy的这个词

28:13.860 --> 28:16.300
好像还没有

28:17.300 --> 28:18.300
放的

28:19.300 --> 28:20.300
放的

28:20.300 --> 28:22.300
找到的过去分词

28:23.300 --> 28:24.300
我说的吧

28:24.300 --> 28:25.300
就这个意思

28:25.300 --> 28:26.300
那这个意思就行了

28:26.300 --> 28:28.300
那么这个是已经找过的

28:28.300 --> 28:30.940
已经找过的

28:30.940 --> 28:31.940
那不然你还一样吗

28:31.940 --> 28:32.940
对不对

28:32.940 --> 28:33.940
还是一样的

28:35.940 --> 28:36.940
那么现在呢

28:36.940 --> 28:37.940
这个函数呢

28:37.940 --> 28:38.940
我就要保证

28:38.940 --> 28:40.940
这个函数必须要保证

28:40.940 --> 28:42.940
必须保证

28:42.940 --> 28:43.940
保证什么呢

28:43.940 --> 28:44.940
nose

28:44.940 --> 28:46.940
参数中

28:47.940 --> 28:48.940
的节点

28:48.940 --> 28:51.940
都是没有找过的

28:52.940 --> 28:53.940
对吧

28:53.940 --> 28:54.940
有这个变量

28:54.940 --> 28:55.940
我肯定能保证

28:55.940 --> 28:56.940
无非就多写点代码

28:56.940 --> 28:58.940
我肯定能保证这一点

28:58.940 --> 28:59.940
你说这个

28:59.940 --> 29:00.940
这个数组里边

29:00.940 --> 29:01.940
一定是没有找过的

29:01.940 --> 29:02.940
全都是没有找过的

29:02.940 --> 29:03.940
不可能是存在

29:03.940 --> 29:04.940
已经找过的

29:04.940 --> 29:05.940
像我们刚才

29:05.940 --> 29:06.940
刚才画的图一样

29:06.940 --> 29:07.940
对吧

29:07.940 --> 29:09.940
当年节点本来是有

29:09.940 --> 29:10.940
但是a已经找过了

29:10.940 --> 29:11.940
我就把

29:11.940 --> 29:12.940
去除掉了

29:12.940 --> 29:14.940
我给他的一定是没有找过的

29:14.940 --> 29:16.940
比方说f这个节点

29:16.940 --> 29:17.940
f这个节点

29:17.940 --> 29:18.940
它本来有邻居

29:18.940 --> 29:19.940
d和e

29:19.940 --> 29:20.940
但是d和e已经找过了

29:20.940 --> 29:21.940
那么f节点的邻居

29:21.940 --> 29:23.940
就相当于是空数数

29:23.940 --> 29:25.940
懂这意思吗

29:25.940 --> 29:28.500
那么这里呢

29:28.500 --> 29:29.500
我们

29:29.500 --> 29:30.500
外面的函数

29:30.500 --> 29:31.500
要掉容的就是

29:31.500 --> 29:32.500
无非就是他

29:32.500 --> 29:33.500
把load的单个节点

29:33.500 --> 29:34.500
放到这个数组里面去

29:34.500 --> 29:35.500
对吧

29:35.500 --> 29:36.500
这样子呢

29:36.500 --> 29:37.500
主要是为了适配

29:37.500 --> 29:38.500
外面掉容者

29:38.500 --> 29:40.500
他只会传一个节点进来

29:40.500 --> 29:41.500
那么管理怎么找

29:41.500 --> 29:42.500
反正

29:42.500 --> 29:43.500
我的参数规格就是

29:43.500 --> 29:44.500
一个节点

29:44.500 --> 29:45.500
扔进去

29:45.500 --> 29:47.500
然后目标只扔进去

29:47.500 --> 29:48.500
正样的事情就是你的内部实现

29:48.500 --> 29:49.500
内部随便怎么去实现

29:49.500 --> 29:50.500
我不管

29:50.500 --> 29:51.500
反正我就给你一个节点

29:51.500 --> 29:52.500
那么但是呢

29:52.500 --> 29:53.500
我们这里内部实现

29:53.500 --> 29:54.500
需要的是多个节点

29:54.500 --> 29:55.500
一个数组

29:55.500 --> 29:56.500
所以我通过一个

29:56.500 --> 29:58.500
内部函数转换一下

29:58.500 --> 29:59.500
跟昨天那个图

29:59.500 --> 30:01.500
跟他数是一样的

30:01.500 --> 30:02.500
接下来

30:02.500 --> 30:03.500
跟我的思路

30:03.500 --> 30:05.500
第一个问题出现

30:05.500 --> 30:09.200
在这个函数里边

30:09.200 --> 30:12.200
什么情况下

30:12.200 --> 30:14.200
一定是找不到的

30:14.200 --> 30:16.200
一定是表示没有找到

30:16.200 --> 30:18.200
来先把这个问题想通

30:18.200 --> 30:20.200
在这个函数里边

30:20.200 --> 30:21.200
刚才我们这里

30:21.200 --> 30:22.200
什么情况没找到

30:22.200 --> 30:23.200
就是已经找过了

30:23.200 --> 30:24.200
这个一个节点给我

30:24.200 --> 30:25.200
那么这个节点

30:25.200 --> 30:26.200
已经找过了

30:26.200 --> 30:27.200
就没有找到

30:27.200 --> 30:28.200
那么现在我们看下面

30:28.200 --> 30:29.200
广收这个

30:29.200 --> 30:33.340
这是一个数字

30:33.340 --> 30:35.340
什么情况下

30:35.340 --> 30:36.340
是一定没有的

30:36.340 --> 30:38.340
我都不用去比较了

30:38.340 --> 30:39.340
什么情况下

30:39.340 --> 30:40.340
我是一定没有的

30:40.340 --> 30:45.830
能不能把这个想出来

30:45.830 --> 30:47.830
循环完毕

30:47.830 --> 30:52.830
再再想一想

30:52.830 --> 30:56.530
或者你就看

30:56.530 --> 30:57.530
非常好啊

30:57.530 --> 30:58.530
大大怪同学

30:58.530 --> 30:59.530
想到这上了

30:59.530 --> 31:01.530
空数组

31:01.530 --> 31:03.530
你给我的是一个空数组

31:03.530 --> 31:05.530
那我一定是找不到的

31:05.530 --> 31:07.530
你怎么从一个空数组里边去找呢

31:07.530 --> 31:08.530
肯定是没有的

31:08.530 --> 31:09.530
随便你要找什么东西

31:09.530 --> 31:11.530
空数组肯定是不存在的

31:11.530 --> 31:13.530
里边肯定没有你要的东西

31:13.530 --> 31:15.530
为什么会出现空数组呢

31:15.530 --> 31:16.530
你看啊

31:16.530 --> 31:18.530
数组里一开始只有一项

31:18.530 --> 31:20.530
这一项找完了没找到

31:20.530 --> 31:22.530
接下来给你的数组有两项

31:22.530 --> 31:23.530
对不对

31:23.530 --> 31:24.530
两项找完了没找到

31:24.530 --> 31:26.530
给你的数组还有两项

31:26.530 --> 31:27.530
没有找到

31:27.530 --> 31:28.530
然后给你的数组里面

31:28.530 --> 31:29.530
只有一项

31:29.530 --> 31:30.530
没有找到

31:30.530 --> 31:31.530
接下来再给你

31:31.530 --> 31:32.530
是不是只能给你一个空数组了

31:32.530 --> 31:34.530
因为这些东西都找过了对吧

31:34.530 --> 31:35.530
我们刚才说了

31:35.530 --> 31:36.530
这个漏字这个数组里边

31:36.530 --> 31:37.530
一定是没有找过的

31:37.530 --> 31:38.530
那么F的相临节点中

31:38.530 --> 31:40.530
没有找过的没有了

31:40.530 --> 31:42.530
只能给你一个空数组了

31:42.530 --> 31:44.530
那是不是就一定找不到呢

31:44.530 --> 31:45.530
你都找到空

31:45.530 --> 31:47.530
你都找到空的一层了

31:47.530 --> 31:49.530
这一层都没有了

31:49.530 --> 31:51.530
那后续的层肯定也啥都没有了

31:51.530 --> 31:52.530
你不可能说

31:52.530 --> 31:53.530
你不可能说

31:53.530 --> 31:54.530
一开始有一个空的一层

31:54.530 --> 31:55.530
但后面又有东西了

31:55.530 --> 31:58.290
不可能的

31:58.290 --> 31:59.290
空的一层

31:59.290 --> 32:01.290
它就不可能有任何的相临节点

32:01.290 --> 32:02.290
空的一层

32:02.290 --> 32:03.290
也就意味着什么都找不到

32:03.290 --> 32:04.290
所谓说

32:04.290 --> 32:06.290
这里的中字条件

32:06.290 --> 32:07.290
什么呢

32:07.290 --> 32:10.660
就是note your names

32:10.660 --> 32:12.660
这一层

32:12.660 --> 32:16.660
已经没有任何节点了

32:16.660 --> 32:19.660
不可能存在你要的东西

32:19.660 --> 32:24.550
不可能存在

32:24.550 --> 32:26.550
这个没问题吧

32:26.550 --> 32:27.550
好 接下来

32:27.550 --> 32:30.550
那这一层有东西

32:30.550 --> 32:32.550
那这些节点都还没有找过

32:32.550 --> 32:33.550
那我是不是得找

32:33.550 --> 32:34.550
那怎么找

32:34.550 --> 32:36.550
就是循环的

32:36.550 --> 32:37.550
循环

32:37.550 --> 32:40.550
I shall note your names

32:40.550 --> 32:43.630
循环吧

32:43.630 --> 32:44.630
就循环这些节点

32:44.630 --> 32:45.630
不是有很多节点要找吗

32:45.630 --> 32:46.630
这些节点都没有找过

32:46.630 --> 32:48.630
那我一个个看

32:48.630 --> 32:50.630
一个个看

32:50.630 --> 32:52.630
我要找到这个节点是n

32:53.630 --> 32:56.630
当前找的

32:56.630 --> 32:58.630
节点是n

32:58.630 --> 32:59.630
怎么看

32:59.630 --> 33:00.630
就看这个n的value值

33:00.630 --> 33:02.630
是不是等于它可以直接完成了

33:02.630 --> 33:04.630
是的话就返回q

33:04.630 --> 33:05.630
这个没问题吧

33:05.630 --> 33:06.630
我就一个个看呗

33:06.630 --> 33:07.630
这个n的值

33:07.630 --> 33:08.630
如果说等于我要找到值

33:08.630 --> 33:09.630
它就返回q

33:09.630 --> 33:10.630
找到了

33:10.630 --> 33:12.630
很简单

33:12.630 --> 33:15.630
那这个n的值不是吗

33:15.630 --> 33:20.200
那n的值要不是怎么办呢

33:20.200 --> 33:23.200
比方说我们找 b 和 c 这一层

33:23.200 --> 33:26.200
找 b 这个节点的时候

33:26.200 --> 33:27.200
b不是

33:27.200 --> 33:29.200
比方我要找 t

33:29.200 --> 33:31.200
b不是

33:31.200 --> 33:33.200
不是怎么办

33:33.200 --> 33:34.200
不是怎么办

33:34.200 --> 33:38.200
我是不是得把 b 的相邻节点

33:38.200 --> 33:40.200
夹到下一层里边去

33:40.200 --> 33:41.200
对不对

33:41.200 --> 33:42.200
我得有一个变量

33:42.200 --> 33:43.200
next

33:43.200 --> 33:45.960
我的一个变量

33:45.960 --> 33:46.960
next

33:46.960 --> 33:47.960
就下一层

33:47.960 --> 33:48.960
因为我不

33:48.960 --> 33:50.960
不能从这一层找完了就不找了

33:50.960 --> 33:51.960
我还得找下一层

33:51.960 --> 33:52.960
对吧

33:52.960 --> 33:54.960
我还得找先找 b 再找 c

33:54.960 --> 33:55.960
那么找 b 的时候

33:55.960 --> 33:56.960
b 发现 b 不是

33:56.960 --> 33:57.960
那我就把 b 的下一层

33:57.960 --> 33:59.960
扔到一个数组里边去

33:59.960 --> 34:00.960
懂了的意思吧

34:00.960 --> 34:02.960
那么 b 的下一层

34:02.960 --> 34:03.960
有谁

34:03.960 --> 34:05.960
是不是有 a 有 d

34:05.960 --> 34:09.720
所以有 a 有 d

34:09.720 --> 34:10.720
明儿的意思吧

34:10.720 --> 34:11.720
是有 a 有 d

34:11.720 --> 34:13.720
那么这个时候呢

34:13.720 --> 34:14.720
这个时候

34:14.720 --> 34:15.720
我先把它扔进去

34:15.720 --> 34:16.720
扔进去

34:16.720 --> 34:17.720
我们最后来再去掉

34:17.720 --> 34:18.720
已经找过的

34:18.720 --> 34:19.720
最后再去掉

34:19.720 --> 34:20.720
好 那么现在呢

34:20.720 --> 34:21.720
我们怎么弄

34:21.720 --> 34:23.720
n不是

34:23.720 --> 34:24.720
n不是

34:24.720 --> 34:25.720
对吧

34:25.720 --> 34:27.720
n 的

34:27.720 --> 34:28.720
凝聚

34:28.720 --> 34:31.720
加入到下一层的

34:31.720 --> 34:33.720
节点数组

34:33.720 --> 34:34.720
那么也就是

34:34.720 --> 34:35.720
也就是说我这里

34:35.720 --> 34:36.720
需要有这么一个数组

34:36.720 --> 34:38.720
next

34:38.720 --> 34:40.720
表示

34:40.720 --> 34:42.720
下一层的

34:42.720 --> 34:44.720
节点数组

34:44.720 --> 34:46.720
好 来吧

34:46.720 --> 34:47.720
n不是

34:47.720 --> 34:48.720
我得把 n 的凝聚

34:48.720 --> 34:49.720
加到下一层的节点中

34:49.720 --> 34:50.720
那我这里是不是

34:50.720 --> 34:51.720
在 i 的加

34:51.720 --> 34:52.720
n 有很多凝聚

34:52.720 --> 34:53.720
我现在看到 b 了

34:53.720 --> 34:54.720
对吧

34:54.720 --> 34:55.720
b 先看 b 再看 c

34:55.720 --> 34:56.720
那么看 b 的时候

34:56.720 --> 34:58.720
那 b 不是

34:58.720 --> 34:59.720
那么它就得有些凝聚吧

34:59.720 --> 35:01.720
我就把凝聚 循环

35:01.720 --> 35:02.720
一次加到什么

35:02.720 --> 35:05.720
加到这个 next 里面

35:05.720 --> 35:06.720
明儿的意思吧

35:06.720 --> 35:07.720
好 给大家看我们现在循环

35:07.720 --> 35:11.720
循环 节等于0

35:11.720 --> 35:12.720
节小于什么

35:12.720 --> 35:13.720
n 的 neighbors

35:13.720 --> 35:16.720
n 的凝聚吗

35:16.720 --> 35:20.860
节一下下

35:20.860 --> 35:21.860
整个这个 for 循环

35:21.860 --> 35:22.860
都要干这个一键的时候

35:22.860 --> 35:23.860
就是把 n 的所有的

35:23.860 --> 35:24.860
凝聚 加到什么

35:24.860 --> 35:26.860
加到 next 里面去

35:26.860 --> 35:27.860
next

35:27.860 --> 35:28.860
push 什么呢

35:28.860 --> 35:29.860
加入一个

35:29.860 --> 35:32.860
加入 n 的当前这个凝聚

35:32.860 --> 35:34.860
对吧

35:34.860 --> 35:38.860
把 n 的这个凝聚

35:38.860 --> 35:51.630
加入到下一层

35:51.630 --> 35:55.630
好 这样子写就行了吗

35:55.630 --> 35:58.630
这样子写会出现bug的

35:58.630 --> 35:59.630
为什么呢

35:59.630 --> 36:00.630
这样子写的话

36:00.630 --> 36:02.630
你会有可能会导致

36:02.630 --> 36:03.630
这个数组里面

36:03.630 --> 36:05.630
会出现一些重复的节点

36:05.630 --> 36:06.630
它可能会出现一些

36:06.630 --> 36:07.630
重复的节点

36:07.630 --> 36:08.630
它为什么会出现

36:08.630 --> 36:09.630
重复的节点呢

36:09.630 --> 36:10.630
是因为比方说

36:10.630 --> 36:12.630
你把 b 的凝聚

36:12.630 --> 36:13.630
a 和 d 加进去

36:13.630 --> 36:14.630
对不对

36:14.630 --> 36:15.630
a 和 d 加进去

36:15.630 --> 36:17.630
然后以后看 c

36:17.630 --> 36:18.630
c 也不是

36:18.630 --> 36:19.630
你也把 c 的凝聚

36:19.630 --> 36:20.630
a 和 d 加进去

36:20.630 --> 36:21.630
那这样子一来

36:21.630 --> 36:22.630
那个时候里面

36:22.630 --> 36:23.630
是出现了重复的 a

36:23.630 --> 36:24.630
重复的 d 了

36:24.630 --> 36:26.630
所以我们首先要搞定

36:26.630 --> 36:27.630
搞定的第一件事

36:27.630 --> 36:28.630
是那个时候里面

36:28.630 --> 36:30.630
它自己没有重复的

36:30.630 --> 36:31.630
懂了意思吧

36:31.630 --> 36:33.630
它自己得没有重复的

36:33.630 --> 36:34.630
因此我在加的时候

36:34.630 --> 36:36.630
我判断一下

36:36.630 --> 36:37.630
判断什么了

36:37.630 --> 36:38.630
那个时候里面

36:38.630 --> 36:41.630
是不是已经有了 include

36:41.630 --> 36:42.630
已经有了谁

36:42.630 --> 36:45.630
已经有了这个节点了

36:45.630 --> 36:47.630
是不是已经有了

36:47.630 --> 36:48.630
已经有了我就不找了

36:48.630 --> 36:49.630
反之

36:49.630 --> 36:51.630
如果说你没有

36:51.630 --> 36:54.260
我才加进去

36:54.260 --> 36:56.260
说这个判断是为了什么了

36:56.260 --> 36:59.260
这个判断是为了保证

36:59.260 --> 37:02.260
那个时候的数组中

37:02.260 --> 37:05.260
没有重复的

37:05.260 --> 37:07.260
自己没有重复

37:07.260 --> 37:08.260
接下来

37:08.260 --> 37:14.430
接下来一个比较少老的问题了

37:14.430 --> 37:15.430
有人说

37:15.430 --> 37:17.430
那我这得既然你自己

37:17.430 --> 37:18.430
不能有重复

37:18.430 --> 37:19.430
那我顺便判断一下

37:19.430 --> 37:20.430
顺便就判断一下

37:20.430 --> 37:21.430
刚才我们

37:21.430 --> 37:22.430
这样子做了这个判断

37:22.430 --> 37:23.430
过后呢

37:23.430 --> 37:24.430
最终你看

37:24.430 --> 37:25.430
那个时候里面

37:25.430 --> 37:26.430
是不是只能包含 a 和d

37:26.430 --> 37:27.430
它至少至少自己

37:27.430 --> 37:28.430
没有重复

37:28.430 --> 37:29.430
对吧

37:29.430 --> 37:31.430
至少自己没有重复

37:31.430 --> 37:33.430
大家有的人说了

37:33.430 --> 37:36.430
那既然这样

37:36.430 --> 37:38.430
我干吗不

37:38.430 --> 37:41.430
直接顺便就把 a 给排除了呢

37:41.430 --> 37:42.430
还有一个 e

37:42.430 --> 37:44.430
因为 c 的小领还有一个 e

37:44.430 --> 37:46.430
它就是 ade

37:46.430 --> 37:47.430
对不对

37:47.430 --> 37:48.430
因为它每一次添加的时候

37:48.430 --> 37:49.430
看一下那个时候里面

37:49.430 --> 37:50.430
没有

37:50.430 --> 37:51.430
没有的话我才加进去

37:51.430 --> 37:53.430
那我顺便就把 a 排除了

37:53.430 --> 37:54.430
我干吗

37:54.430 --> 37:56.430
这里不排除了

37:56.430 --> 37:57.430
怎么排除

37:57.430 --> 37:58.430
排除的方式很简单

37:58.430 --> 37:59.430
我就这样

37:59.430 --> 38:01.430
什么 next

38:01.430 --> 38:02.430
放的

38:02.430 --> 38:04.430
include

38:04.430 --> 38:06.430
under neighbors

38:06.430 --> 38:07.430
不就完了吗

38:07.430 --> 38:08.430
对不对

38:08.430 --> 38:09.430
非常简单

38:09.430 --> 38:10.430
我看一下这个邻居

38:10.430 --> 38:11.430
是不是已经找过了

38:11.430 --> 38:12.430
邻居

38:12.430 --> 38:13.430
这个节点

38:13.430 --> 38:14.430
这个邻居没有找过

38:14.430 --> 38:16.430
这个邻居也没有添加过

38:16.430 --> 38:17.430
我才把它添加进去

38:17.430 --> 38:18.430
我加上这样子

38:18.430 --> 38:19.430
不就完了吗

38:19.430 --> 38:21.430
我首先告诉大家

38:21.430 --> 38:23.430
是不行的

38:23.430 --> 38:24.430
想一想

38:24.430 --> 38:25.430
为什么不行的

38:25.430 --> 38:26.430
这个地方

38:26.430 --> 38:27.430
有一点

38:27.430 --> 38:29.430
非常非常细的东西

38:29.430 --> 38:31.430
为什么不行

38:31.430 --> 38:37.090
为啥不行

38:37.090 --> 38:38.090
我把这条线

38:38.090 --> 38:39.090
一个人连起来

38:39.090 --> 38:41.090
就知道为啥不行了

38:41.090 --> 38:43.090
假设我们图是这个样子

38:43.090 --> 38:44.090
假设啊

38:44.090 --> 38:46.850
刚才的图

38:46.850 --> 38:48.850
倒是没有这个问题

38:48.850 --> 38:49.850
但是如果说

38:49.850 --> 38:50.850
我们的图是这个样子

38:50.850 --> 38:51.850
你看一下

38:51.850 --> 38:52.850
为啥不行

38:52.850 --> 38:53.850
我先找 a

38:53.850 --> 38:54.850
不是吗

38:54.850 --> 38:55.850
我找 b 和 c

38:55.850 --> 38:57.850
接下来我找 b 和 c

38:57.850 --> 38:58.850
找 b

38:58.850 --> 38:59.850
b 也不是

38:59.850 --> 39:01.850
那么接下来我加节点

39:01.850 --> 39:03.850
如果说我加入判断

39:03.850 --> 39:07.850
b不是

39:07.850 --> 39:08.850
b不是

39:08.850 --> 39:09.850
那么这个时候

39:09.850 --> 39:10.850
我加入判断

39:10.850 --> 39:11.850
判断什么呢

39:11.850 --> 39:12.850
判断那个

39:12.850 --> 39:14.850
我把他的邻居

39:14.850 --> 39:20.850
邻居是 a,d,c 加进去

39:20.850 --> 39:21.850
所以他的邻居有三个

39:21.850 --> 39:23.850
a,d,c

39:23.850 --> 39:25.850
或者是 ac,d

39:25.850 --> 39:26.850
加到下一层

39:26.850 --> 39:27.850
好

39:27.850 --> 39:28.850
a 节点

39:28.850 --> 39:29.850
但是已经找过了

39:29.850 --> 39:30.850
对吧

39:30.850 --> 39:31.850
a 节点已经找过了

39:31.850 --> 39:34.220
不加了

39:34.220 --> 39:35.220
看到问题没

39:35.220 --> 39:37.220
他把 c 加进去了

39:37.220 --> 39:38.220
因为这个时候有没有找 c

39:38.220 --> 39:39.220
没有找 c

39:39.220 --> 39:40.220
他没有找过 c

39:40.220 --> 39:43.220
就对他来把 c 加进去

39:43.220 --> 39:44.220
懂了意思吗

39:44.220 --> 39:45.220
但是下一次循环

39:45.220 --> 39:47.220
是不是就开始找 c 了

39:47.220 --> 39:48.220
这一层还没有完

39:48.220 --> 39:49.220
只少了 b

39:49.220 --> 39:50.220
下一层循环

39:50.220 --> 39:51.220
下一次循环

39:51.220 --> 39:52.220
是不是就找 c 了

39:52.220 --> 39:53.220
好

39:53.220 --> 39:54.220
找 c 的时候

39:54.220 --> 39:55.220
c 也不是

39:55.220 --> 39:56.220
哦

39:56.220 --> 39:58.220
c 不是怎么办

39:58.220 --> 39:59.220
那么这里

39:59.220 --> 40:00.220
c 的邻居加进去

40:00.220 --> 40:01.220
c 的邻居是 ab

40:01.220 --> 40:02.220
b 找过了

40:02.220 --> 40:03.220
不用加了

40:03.220 --> 40:04.220
对不对

40:04.220 --> 40:05.220
这里还没有写

40:05.220 --> 40:06.220
他找过了

40:06.220 --> 40:07.220
不是的话

40:07.220 --> 40:09.220
再把他加到这个方子里面去

40:12.220 --> 40:13.220
这个节点

40:13.220 --> 40:14.220
不是

40:14.220 --> 40:18.220
加入到以早节点中

40:18.220 --> 40:19.220
好

40:19.220 --> 40:20.220
那么找 c 的时候

40:20.220 --> 40:21.220
c 的邻居是什么

40:21.220 --> 40:23.220
ab 都找过了

40:23.220 --> 40:24.220
ab 找过了

40:24.220 --> 40:25.220
d 已经有了

40:25.220 --> 40:27.220
那么就加入一个 e

40:27.220 --> 40:28.220
最终那个 c 变成了

40:28.220 --> 40:30.220
什么 c d e

40:30.220 --> 40:31.220
看到没

40:31.220 --> 40:33.220
他又要去重新找 c

40:33.220 --> 40:34.220
能看到吗

40:34.220 --> 40:38.690
能不能看懂

40:38.690 --> 40:39.690
如果说我在这里判断

40:39.690 --> 40:41.690
就会出现这样的问题

40:41.690 --> 40:42.690
在这里去判断

40:42.690 --> 40:43.690
也没有找过

40:43.690 --> 40:44.690
就会出现问题

40:44.690 --> 40:45.690
这个地方非常非常细节

40:45.690 --> 40:46.690
极其的细节

40:46.690 --> 40:47.690
如果说我不说的话

40:47.690 --> 40:48.690
到时候出了八个

40:48.690 --> 40:49.690
根本就找

40:49.690 --> 40:50.690
根本就找不到

40:50.690 --> 40:51.690
它是有这么一个

40:51.690 --> 40:52.690
很细的

40:52.690 --> 40:54.690
很细很细的地方

40:54.690 --> 40:55.690
根本原因在哪

40:55.690 --> 40:57.690
因为我要找这一层

40:57.690 --> 40:58.690
这一层有两个

40:58.690 --> 40:59.690
有两个

40:59.690 --> 41:01.690
但是这一层之间

41:01.690 --> 41:03.690
是有联系的

41:03.690 --> 41:04.690
那么这种情况下

41:04.690 --> 41:05.690
就会出问题

41:05.690 --> 41:07.690
因为我在看 b 的时候

41:07.690 --> 41:08.690
b 不是

41:08.690 --> 41:10.690
这个时候我还没有看到 c

41:10.690 --> 41:11.690
我这房地的里面

41:11.690 --> 41:12.690
只有一个 a

41:12.690 --> 41:13.690
只有一个 b 不是

41:13.690 --> 41:15.690
我就把 b 加进来

41:15.690 --> 41:16.690
房地的里面

41:16.690 --> 41:17.690
b 不是

41:17.690 --> 41:18.690
把 b 加进来

41:18.690 --> 41:19.690
那么今天我把 b 的邻居

41:19.690 --> 41:20.690
往这里边加

41:20.690 --> 41:22.690
加 b 的邻居的时候

41:22.690 --> 41:23.690
由于我还没有看 c

41:23.690 --> 41:24.690
说这个时候

41:24.690 --> 41:26.690
我不知道 c 将来要去找

41:26.690 --> 41:27.690
将来要去找 c

41:27.690 --> 41:28.690
不知道

41:28.690 --> 41:29.690
所以我又把 c 加进去了

41:29.690 --> 41:31.690
加了 c 和 d

41:31.690 --> 41:32.690
本来要加 a 的人

41:32.690 --> 41:33.690
a 已经找过了

41:33.690 --> 41:34.690
加了 c 和 d

41:34.690 --> 41:35.690
但是一会看了 c

41:35.690 --> 41:37.690
c 又不是

41:37.690 --> 41:39.690
我当时就很麻烦了

41:39.690 --> 41:40.690
我就很麻烦了

41:40.690 --> 41:42.690
我还要回到之前

41:42.690 --> 41:43.690
把 c 删掉

41:43.690 --> 41:44.690
就非常麻烦了

41:44.690 --> 41:45.690
懂了意思吗

41:45.690 --> 41:46.690
c 又不是

41:46.690 --> 41:47.690
c 又不是的话

41:47.690 --> 41:48.690
还要把 c 的邻居加进去

41:48.690 --> 41:49.690
a,b 有了

41:49.690 --> 41:50.690
找过了

41:50.690 --> 41:51.690
然后 d 已经有了

41:51.690 --> 41:52.690
就把 e 加进去了

41:52.690 --> 41:53.690
那么最终

41:53.690 --> 41:54.690
这个数组里边

41:54.690 --> 41:55.690
就会出现一个

41:55.690 --> 41:56.690
已经找过的结定

41:56.690 --> 41:59.690
是找他之前添加的

41:59.690 --> 42:00.690
能听懂吗

42:00.690 --> 42:03.130
这一块

42:03.130 --> 42:04.130
这个问题

42:04.130 --> 42:08.420
直接这个问题

42:08.420 --> 42:09.420
能不能听懂

42:09.420 --> 42:11.420
还听不懂吗

42:11.420 --> 42:12.420
我来想

42:12.420 --> 42:14.420
我怎么去给你解释了

42:14.420 --> 42:15.420
解释到这种情况

42:15.420 --> 42:17.420
很多话能这样子的

42:17.420 --> 42:18.420
就是说

42:18.420 --> 42:20.420
现在我有两个

42:20.420 --> 42:22.420
两个结定要去找

42:22.420 --> 42:25.310
b 和 c

42:25.310 --> 42:27.310
我没找一个结定

42:27.310 --> 42:28.310
他不是

42:28.310 --> 42:29.310
我不是有几件事要做吗

42:29.310 --> 42:30.310
他第一个不是

42:30.310 --> 42:31.310
不是我怎么办

42:31.310 --> 42:32.310
我就把他

42:32.310 --> 42:33.310
交到这个数组里边

42:33.310 --> 42:34.310
之前找 a 对吧

42:34.310 --> 42:35.310
现在我找了个 b

42:35.310 --> 42:36.310
b 不是

42:36.310 --> 42:37.310
但是我们现在一定要记住

42:37.310 --> 42:39.310
我们现在有两个结定要找

42:39.310 --> 42:41.310
我先找 b

42:41.310 --> 42:42.310
因为我程序不是说

42:42.310 --> 42:43.310
一下子同时运行的

42:43.310 --> 42:45.310
他是一步一步就走的

42:45.310 --> 42:47.310
我找 b 和 c 不得循环吗

42:47.310 --> 42:49.310
不得先找 b 再找 c吗

42:49.310 --> 42:50.310
不可能说 b 和 c 同时找

42:50.310 --> 42:51.310
不可能的

42:51.310 --> 42:52.310
程序是一步一步运行的

42:52.310 --> 42:55.310
他得先找 b 再找 c

42:55.310 --> 42:56.310
而找 b 的时候

42:56.310 --> 42:58.310
我说要经过一段逻辑

42:58.310 --> 42:59.310
逻辑是什么

42:59.310 --> 43:00.310
他是不是

43:00.310 --> 43:01.310
他是不是就结束了

43:01.310 --> 43:02.310
他不是的话

43:02.310 --> 43:03.310
他是不是找过了

43:03.310 --> 43:04.310
加入进来

43:04.310 --> 43:05.310
就得夹到几支里面来

43:05.310 --> 43:06.310
然后他不是

43:06.310 --> 43:07.310
所以说

43:07.310 --> 43:08.310
他的邻居在加入进来

43:08.310 --> 43:09.310
加入到这儿来

43:09.310 --> 43:10.310
现在还没有看 c 啊

43:10.310 --> 43:11.310
对啊

43:11.310 --> 43:12.310
现在还没有看 c

43:12.310 --> 43:13.310
但是现在在看 b

43:13.310 --> 43:14.310
他不是

43:14.310 --> 43:15.310
他得把他的邻居加入进来

43:15.310 --> 43:16.310
他邻居有啥呢

43:16.310 --> 43:19.310
邻居是不是有 acd 有三个邻居

43:19.310 --> 43:20.310
那如果说

43:20.310 --> 43:21.310
假如说

43:21.310 --> 43:23.310
我在这里就写判断

43:23.310 --> 43:24.310
在这个地方就写判断

43:24.310 --> 43:25.310
也说我

43:25.310 --> 43:27.310
我现在循环都没有结束

43:27.310 --> 43:28.310
我 bc 都还没有看完

43:28.310 --> 43:30.310
我就在写这个判断的话

43:30.310 --> 43:31.310
就会导致一个问题

43:31.310 --> 43:33.310
c 我还没有看

43:33.310 --> 43:34.310
我也不知道

43:34.310 --> 43:35.310
这个玩意

43:35.310 --> 43:36.310
他到底有没有找到

43:36.310 --> 43:37.310
他是什么情况

43:37.310 --> 43:38.310
不知道

43:38.310 --> 43:39.310
因为我现在还在第一次循环

43:39.310 --> 43:40.310
我现在还在看 b

43:40.310 --> 43:42.310
但是我由于

43:42.310 --> 43:43.310
我这个时候

43:43.310 --> 43:44.310
我就把

43:44.310 --> 43:46.310
我这个时候去做了这个判断

43:46.310 --> 43:47.310
我就把

43:47.310 --> 43:49.310
导致了我就会把 c 加进去

43:49.310 --> 43:50.310
加到下一次场面

43:50.310 --> 43:51.310
看到没

43:51.310 --> 43:53.310
我就会把 c 加进去

43:53.310 --> 43:54.310
那么 d 肯定要进来

43:54.310 --> 43:55.310
a 已经找过了

43:55.310 --> 43:56.310
他进不来

43:56.310 --> 43:58.310
是不是我找

43:58.310 --> 43:59.310
我就看 b

43:59.310 --> 44:00.310
不一不来

44:00.310 --> 44:01.310
就看 b

44:01.310 --> 44:02.310
找 b 的时候

44:02.310 --> 44:03.310
我是不是会保持

44:03.310 --> 44:05.310
把 c 和 d 加进来

44:05.310 --> 44:06.310
你说我在这里

44:06.310 --> 44:09.780
如果说写了这个判断

44:09.780 --> 44:11.780
写了这个判断

44:11.780 --> 44:17.150
found includes

44:17.150 --> 44:19.150
and your neighbors

44:19.150 --> 44:20.150
你看啊

44:20.150 --> 44:21.150
能不能解决这个问题

44:21.150 --> 44:22.150
我写了这个判断

44:22.150 --> 44:24.150
就是我去除什么情况

44:24.150 --> 44:25.150
去除他已经

44:25.150 --> 44:26.150
下一层已经有的

44:26.150 --> 44:27.150
还去除什么

44:27.150 --> 44:28.150
已经找过的

44:28.150 --> 44:29.150
如果说在这里去除

44:29.150 --> 44:30.150
已经找过的

44:30.150 --> 44:31.150
就会遇到这样的问题

44:31.150 --> 44:32.150
我找 b 的时候

44:32.150 --> 44:33.150
就看 c

44:33.150 --> 44:35.150
那 c 肯定没有找过

44:35.150 --> 44:37.150
我都还没看他

44:37.150 --> 44:39.150
那我就把 b 的邻居加进来

44:39.150 --> 44:40.150
加了邻居是啥

44:40.150 --> 44:41.150
加了邻居

44:41.150 --> 44:42.150
a 已经找过了

44:42.150 --> 44:43.150
不加了

44:43.150 --> 44:44.150
然后加了邻居

44:44.150 --> 44:46.150
是不是就 c 和 d

44:46.150 --> 44:47.150
看呗

44:47.150 --> 44:48.150
是不是就把 c 和 d 加进去了

44:48.150 --> 44:49.150
好

44:49.150 --> 44:50.150
那么 b 完了

44:50.150 --> 44:51.150
接下来

44:51.150 --> 44:52.150
下一次循环

44:52.150 --> 44:53.150
你看我这个在循环

44:53.150 --> 44:54.150
在循环

44:54.150 --> 44:55.150
他所谓的节点

44:55.150 --> 44:56.150
这是一层

44:56.150 --> 44:57.150
那么下一个节点

44:57.150 --> 44:58.150
是不是 c

44:58.150 --> 45:01.150
这个时候再看 c

45:01.150 --> 45:02.150
也不是

45:02.150 --> 45:04.150
完了

45:04.150 --> 45:05.150
c 不是

45:05.150 --> 45:06.150
当我下一层

45:06.150 --> 45:08.150
还能不能去找 c

45:08.150 --> 45:09.150
不冷了

45:09.150 --> 45:10.150
但是之前是不是

45:10.150 --> 45:11.150
已经加进去了

45:11.150 --> 45:12.150
你这个时候再要去想

45:12.150 --> 45:13.150
把它删除掉

45:13.150 --> 45:14.150
就麻烦了

45:14.150 --> 45:16.150
一个代码就不好写了

45:16.150 --> 45:17.150
那我只能说

45:17.150 --> 45:18.150
按照这个邻居来走的话

45:18.150 --> 45:19.150
c

45:19.150 --> 45:20.150
它不是

45:20.150 --> 45:21.150
那把 c 的邻居加进去

45:21.150 --> 45:22.150
这个邻居有 a

45:22.150 --> 45:23.150
b 、d 、e

45:23.150 --> 45:24.150
a b 已经找过了

45:24.150 --> 45:26.150
d 已经有了

45:26.150 --> 45:27.150
那么就下一个 e

45:27.150 --> 45:28.150
那么就导致了

45:28.150 --> 45:29.150
下一次找的时候

45:29.150 --> 45:31.150
它又要重复去找 c

45:31.150 --> 45:35.170
多人意识吧

45:35.170 --> 45:37.170
我就这样子一步一步延伸

45:37.170 --> 45:39.170
我就不知道该怎么去讲了

45:39.170 --> 45:42.170
没办法比这个讲的更稀了

45:42.170 --> 45:43.170
你仔细体会一下

45:43.170 --> 45:44.170
它这个找

45:44.170 --> 45:46.170
因为它是一层节点

45:46.170 --> 45:47.170
它是有多个

45:47.170 --> 45:48.170
有多个节点

45:48.170 --> 45:50.170
它在一个一个找

45:50.170 --> 45:51.170
每一个节点

45:51.170 --> 45:53.170
它都要经过这么一层逻辑

45:53.170 --> 45:54.170
先

45:54.170 --> 45:55.170
把自己看一下

45:55.170 --> 45:58.170
是不是事就结束了

45:58.170 --> 46:00.170
后面什么情况都没有了

46:00.170 --> 46:01.170
不是的话

46:01.170 --> 46:02.170
我就要经过一系列的逻辑

46:02.170 --> 46:03.170
它首先被找过了

46:03.170 --> 46:04.170
进入番底的

46:04.170 --> 46:06.170
找过了

46:06.170 --> 46:08.170
然后把它邻居加入到下一层

46:08.170 --> 46:10.170
因为你不能只考虑这一层

46:10.170 --> 46:11.170
这个层找完了

46:11.170 --> 46:12.170
那怎么办

46:12.170 --> 46:13.170
还得下一层找给

46:13.170 --> 46:15.170
是不是你要不要加下一层

46:15.170 --> 46:16.170
对不对

46:16.170 --> 46:19.480
但是如果说我过早的去判断

46:19.480 --> 46:21.480
它有没有存在

46:21.480 --> 46:23.480
有没有找过

46:23.480 --> 46:25.480
就会导致这样的问题

46:25.480 --> 46:27.480
因为 b 的邻居有包含 c

46:27.480 --> 46:28.480
它有可能

46:28.480 --> 46:29.480
我这里没有包含

46:29.480 --> 46:30.480
但是它有可能会包含

46:30.480 --> 46:33.480
你要考虑各种途的情况

46:33.480 --> 46:35.480
它如果说一旦包含 c 就完蛋了

46:35.480 --> 46:37.480
因为我现在判断b的时候

46:37.480 --> 46:38.480
c 还没有找

46:38.480 --> 46:41.480
还没有循环到下一个 c

46:41.480 --> 46:43.480
那我就认为 c 没有找过

46:43.480 --> 46:44.480
我就把它夹到下来

46:44.480 --> 46:45.480
结果了

46:45.480 --> 46:46.480
到时候

46:46.480 --> 46:47.480
下一次循环循环到 c 的时候

46:47.480 --> 46:48.480
哦哦

46:48.480 --> 46:50.480
c 找过了

46:50.480 --> 46:52.480
那但是我这里已经记录进来了

46:52.480 --> 46:53.480
要剃除掉就很麻烦了

46:53.480 --> 46:54.480
这个逻辑不好写

46:54.480 --> 46:56.480
相当难写

46:56.480 --> 46:57.480
那怎么办

46:57.480 --> 46:59.480
那如果说你实在听不懂

46:59.480 --> 47:00.480
那就没关系了

47:00.480 --> 47:04.500
你就听我怎么办就行了

47:04.500 --> 47:05.500
你这样

47:05.500 --> 47:06.500
你不要去管这个

47:06.500 --> 47:07.500
你就听我怎么办

47:07.500 --> 47:10.500
怎么办

47:10.500 --> 47:11.500
我一开始就根本就不管

47:11.500 --> 47:12.500
都不管

47:12.500 --> 47:14.500
它有没有找过

47:14.500 --> 47:15.500
b 找过了对吧

47:15.500 --> 47:16.500
加入进来

47:16.500 --> 47:17.500
然后 b 到邻居

47:17.500 --> 47:19.500
a 进来

47:19.500 --> 47:21.500
c 进来

47:21.500 --> 47:22.500
d 进来

47:22.500 --> 47:27.060
acd 全部进来

47:27.060 --> 47:28.060
然后再找 c

47:28.060 --> 47:29.060
c 也不是

47:29.060 --> 47:30.060
不是的话

47:30.060 --> 47:31.060
c 的邻居全部进来

47:31.060 --> 47:32.060
只要保证这里边

47:32.060 --> 47:33.060
没有重复就行了

47:33.060 --> 47:34.060
只要保证那个时候

47:34.060 --> 47:35.060
里边没有重复

47:35.060 --> 47:36.060
好

47:36.060 --> 47:37.060
c 的邻居是啥

47:37.060 --> 47:38.060
a 已经有了

47:38.060 --> 47:39.060
不能写了

47:39.060 --> 47:40.060
它这里边重复了

47:40.060 --> 47:41.060
保证这里边

47:41.060 --> 47:42.060
没有重复就行

47:42.060 --> 47:43.060
好

47:43.060 --> 47:45.060
a 有了 b 没有

47:45.060 --> 47:47.060
b

47:47.060 --> 47:48.060
好

47:48.060 --> 47:49.060
然后呢

47:49.060 --> 47:51.060
d 有了 e

47:51.060 --> 47:52.060
我出来的那个时候

47:52.060 --> 47:53.060
是这样子的

47:53.060 --> 47:54.060
所以说

47:54.060 --> 47:55.060
肯定有问题啊

47:55.060 --> 47:56.060
你这个玩意

47:56.060 --> 47:58.820
没关系

47:58.820 --> 48:02.820
我这一程找完了之后

48:02.820 --> 48:03.820
单独来

48:03.820 --> 48:05.820
我这一程全部看完了

48:05.820 --> 48:06.820
那么这样子

48:06.820 --> 48:07.820
全部看完了过后

48:07.820 --> 48:08.820
这个翻地的

48:08.820 --> 48:10.820
是不是固定下来了

48:10.820 --> 48:11.820
这个时候是不是固定下来了

48:11.820 --> 48:12.820
现在如果说

48:12.820 --> 48:13.820
我这样的写代码的话

48:13.820 --> 48:14.820
出来就这样的结果

48:14.820 --> 48:15.820
我这样写代码

48:15.820 --> 48:18.390
出来就这样的结果

48:18.390 --> 48:19.390
好

48:19.390 --> 48:20.390
那么这个时候

48:20.390 --> 48:22.390
我再来单独来看一下

48:22.390 --> 48:23.390
来去从

48:23.390 --> 48:24.390
一个个拿出来看

48:24.390 --> 48:25.390
看第一个

48:25.390 --> 48:26.390
有没有

48:26.390 --> 48:27.390
诶有

48:27.390 --> 48:28.390
去掉

48:28.390 --> 48:29.390
三除掉

48:29.390 --> 48:30.390
第二个找没找过

48:30.390 --> 48:31.390
找过了

48:31.390 --> 48:32.390
三除掉

48:32.390 --> 48:33.390
第三个

48:33.390 --> 48:34.390
找过

48:34.390 --> 48:35.390
找过了

48:35.390 --> 48:36.390
去掉

48:36.390 --> 48:37.390
一找没找过

48:37.390 --> 48:38.390
没找过

48:38.390 --> 48:39.390
不动

48:39.390 --> 48:40.390
懂我意思吗

48:40.390 --> 48:41.390
我就说

48:41.390 --> 48:42.390
我要再把这一程

48:42.390 --> 48:43.390
看完了之后

48:43.390 --> 48:44.390
翻地的已经

48:44.390 --> 48:45.390
都要放的

48:45.390 --> 48:46.390
已经确定了过后

48:46.390 --> 48:47.390
我再来统一来去从

48:48.390 --> 48:49.390
去掉

48:49.390 --> 48:50.390
已经找过的

48:50.390 --> 48:51.390
如果要再干嘛

48:51.390 --> 48:52.390
我要在这个

48:52.390 --> 48:53.390
过循环结束之后

48:53.390 --> 48:54.390
我要在这

48:54.390 --> 48:55.390
把这一程

48:55.390 --> 48:56.390
已经看完了

48:56.390 --> 48:57.390
这一程

48:57.390 --> 48:58.390
已经看完了

49:00.390 --> 49:01.390
放的

49:01.390 --> 49:02.390
已经更新了

49:03.390 --> 49:04.390
然后这个时候

49:04.390 --> 49:05.390
此时

49:05.390 --> 49:06.390
再来

49:06.390 --> 49:07.390
去掉

49:07.390 --> 49:08.390
那个史册

49:08.390 --> 49:09.390
中

49:09.390 --> 49:11.390
已经找过的结点

49:11.390 --> 49:12.390
那如果说

49:12.390 --> 49:13.390
你刚才那个

49:13.390 --> 49:14.390
问题

49:14.390 --> 49:15.390
问题实在听不懂

49:15.390 --> 49:16.390
我也不知道该怎么去讲了

49:17.390 --> 49:18.390
已经不会有

49:18.390 --> 49:19.390
比如讲的比我更细了

49:22.150 --> 49:23.150
如果刚才那个

49:23.150 --> 49:24.150
实在听不懂

49:24.150 --> 49:25.150
至少你这个逻辑

49:25.150 --> 49:26.150
能理解吧

49:26.150 --> 49:27.150
我找完了

49:27.150 --> 49:28.150
我把这一程

49:28.150 --> 49:29.150
看完了过后

49:29.150 --> 49:30.150
我再来去

49:30.150 --> 49:31.150
去掉这里边

49:31.150 --> 49:36.020
已经找过的

49:36.020 --> 49:37.020
这个能不能理解

49:37.020 --> 49:38.020
这个意思

49:38.020 --> 49:39.020
就这个意思

49:39.020 --> 49:40.020
一程判断完了过后

49:40.020 --> 49:41.020
看完了过后

49:41.020 --> 49:42.020
我再去看下一程

49:42.020 --> 49:43.020
有没有找过

49:43.020 --> 49:44.020
你不能在中途去看

49:44.020 --> 49:45.020
中途去看

49:45.020 --> 49:46.020
是不准确的

49:46.020 --> 49:47.020
这个数据

49:47.020 --> 49:50.420
问题是不准确的

49:51.420 --> 49:53.420
那就会导致这个问题

49:53.420 --> 49:54.420
因为我们这里

49:54.420 --> 49:55.420
假设的是

49:55.420 --> 49:56.420
它全部都没有找过

49:56.420 --> 49:57.420
那么就导致

49:57.420 --> 49:59.420
里边包含了有找过的

49:59.420 --> 50:03.060
数据永远清空不了

50:03.060 --> 50:04.060
那么这里

50:04.060 --> 50:05.060
怎么来判断

50:05.060 --> 50:06.060
就是单独来写

50:06.060 --> 50:08.060
这个很简单吧

50:08.060 --> 50:11.750
又来个循环

50:11.750 --> 50:14.750
来小语 next

50:14.750 --> 50:17.750
小语这个数据的长度

50:17.750 --> 50:19.750
一个个看呗

50:19.750 --> 50:20.750
看一下当前这一个

50:20.750 --> 50:22.750
是不是已经找过了

50:22.750 --> 50:23.750
怎么判断

50:23.750 --> 50:25.750
bound includes

50:25.750 --> 50:27.750
不排除呢

50:27.750 --> 50:29.750
特别是初学程序的人

50:29.750 --> 50:30.750
同学

50:30.750 --> 50:31.750
我刚刚是

50:31.750 --> 50:33.750
刚刚开始学程序的时候

50:33.750 --> 50:35.750
跟你没事一样的

50:35.750 --> 50:36.750
就是什么情况呢

50:36.750 --> 50:37.750
代码只要一读

50:37.750 --> 50:39.750
哪怕这个代码极其简单

50:39.750 --> 50:41.750
这个代码已经一先一写过了

50:41.750 --> 50:42.750
让查到问题

50:42.750 --> 50:44.750
数据里边蓄从的问题

50:44.750 --> 50:45.750
都是写过的

50:45.750 --> 50:46.750
但是只要一多了

50:46.750 --> 50:48.750
老大就云了

50:48.750 --> 50:50.750
所以有这样的问题

50:50.750 --> 50:52.750
有这样的问题的同学呢

50:52.750 --> 50:53.750
他老代里面呢

50:53.750 --> 50:55.750
就是他的程序思维呢

50:55.750 --> 50:57.750
还没有开始分块

50:57.750 --> 50:58.750
就是没有

50:58.750 --> 50:59.750
他的思维能力呢

50:59.750 --> 51:00.750
还不具备

51:00.750 --> 51:02.750
把程序分块的能力

51:02.750 --> 51:04.750
所以你写程序的时候呢

51:04.750 --> 51:05.750
你一定要知道

51:05.750 --> 51:08.750
程序是由一块一块组成的

51:08.750 --> 51:11.750
每一块之间的联系是不紧密的

51:11.750 --> 51:12.750
有少量联系

51:12.750 --> 51:13.750
但是联系不多

51:13.750 --> 51:15.750
以一块写好过后呢

51:15.750 --> 51:17.750
你心里边就不要去想它了

51:17.750 --> 51:18.750
想都不要想它了

51:18.750 --> 51:19.750
你如果说你担心它的话

51:19.750 --> 51:21.750
你就把那一块好好检查一下

51:21.750 --> 51:22.750
好好去测试一下

51:22.750 --> 51:24.750
直到你测试到过后你完全放心了

51:24.750 --> 51:26.750
你觉得那一块不会有问题了

51:26.750 --> 51:28.750
你再去写下一块

51:28.750 --> 51:30.750
就一块一块写好

51:30.750 --> 51:31.750
上面的我们已经搞定了

51:31.750 --> 51:32.750
什么事情呢

51:32.750 --> 51:33.750
已经搞定了就是

51:33.750 --> 51:35.750
那个时候里边

51:35.750 --> 51:36.750
包含下一层

51:36.750 --> 51:37.750
但是呢没有去从的问题

51:37.750 --> 51:39.750
那个时候里边有从

51:39.750 --> 51:43.750
就是已经有找过的节点

51:43.750 --> 51:44.750
我这个时候没有保证的

51:44.750 --> 51:46.750
但是我保证了还不重复

51:46.750 --> 51:47.750
在它里边有找过的节点

51:47.750 --> 51:48.750
它有可能不会存在

51:48.750 --> 51:50.750
那么你前面说写好了

51:50.750 --> 51:52.750
写好了你不要去想它了

51:52.750 --> 51:53.750
如果说你写消费的代码

51:53.750 --> 51:55.750
你脑袋里边还得想前面的代码

51:55.750 --> 51:56.750
那得完蛋了

51:56.750 --> 51:57.750
你的程序会越来越复杂

51:57.750 --> 51:58.750
越来越复杂

51:58.750 --> 52:00.750
你脑袋中意有一天

52:00.750 --> 52:01.750
你承受不了

52:01.750 --> 52:03.750
因为你们以后开发项目

52:03.750 --> 52:04.750
那是几千

52:04.750 --> 52:05.750
那不是几千行代码

52:06.750 --> 52:08.750
那是上万行代码的

52:08.750 --> 52:09.750
那你怎么承受得住

52:09.750 --> 52:11.750
你这种形制负担太重了

52:11.750 --> 52:14.750
我们后边有各种各样的框架

52:14.750 --> 52:16.750
脚里怎么去分模块

52:16.750 --> 52:18.750
把不同的功能切分开

52:18.750 --> 52:19.750
都是为了减弃

52:19.750 --> 52:21.750
降低你的形制负担

52:21.750 --> 52:25.060
不然形制负担太重了

52:25.060 --> 52:26.060
我写这个代码的时候

52:26.060 --> 52:27.060
我完全不许想前面的

52:27.060 --> 52:28.060
我就只想

52:28.060 --> 52:29.060
目前什么情况

52:29.060 --> 52:30.060
目前就是那个时候里边有

52:30.060 --> 52:31.060
已经找过的

52:31.060 --> 52:33.060
我现在就是得想办法

52:33.060 --> 52:35.060
从这个数字中驱除掉

52:35.060 --> 52:37.060
这个数组里面有的东西

52:37.060 --> 52:38.060
那么这样子

52:38.060 --> 52:39.060
你只想这一块的话

52:39.060 --> 52:40.060
代码就比较简单了

52:40.060 --> 52:41.060
如果说你把前面

52:41.060 --> 52:42.060
结合起来想的话

52:42.060 --> 52:44.060
你一定是炸掉的

52:44.060 --> 52:45.060
好

52:45.060 --> 52:46.060
那么这里怎么办

52:46.060 --> 52:47.060
就是一个循环

52:47.060 --> 52:48.060
非常简单的代码

52:48.060 --> 52:50.060
循环这个数组

52:50.060 --> 52:51.060
看一下这个数组里边

52:51.060 --> 52:52.060
这个数组里边

52:52.060 --> 52:53.060
包不包含这一样

52:53.060 --> 52:54.060
包含了说明书

52:54.060 --> 52:56.060
我得把这一项删除掉

52:56.060 --> 52:57.060
怎么删除

52:57.060 --> 52:59.060
它不就是个数组的splash吗

52:59.060 --> 53:00.060
下标

53:00.060 --> 53:01.060
来删除几个

53:01.060 --> 53:02.060
删除一个

53:02.060 --> 53:03.060
对吧

53:03.060 --> 53:04.060
我们不是要去虫吗

53:04.060 --> 53:05.060
去掉已经找过了

53:05.060 --> 53:06.060
必须删除了

53:06.060 --> 53:07.060
但是你删除完了过后

53:07.060 --> 53:08.060
一定要知道

53:08.060 --> 53:09.060
记住啊

53:09.060 --> 53:13.620
挨剪剑

53:13.620 --> 53:14.620
有没有同学

53:14.620 --> 53:15.620
需要讲这个吗

53:15.620 --> 53:16.620
需要讲挨剪剑吗

53:16.620 --> 53:18.620
需要讲的Q和E

53:18.620 --> 53:23.590
需要讲Q和E

53:23.590 --> 53:24.590
OK

53:24.590 --> 53:25.590
就是你

53:25.590 --> 53:26.590
不管是这种情况

53:26.590 --> 53:28.590
还是什么别的情况

53:28.590 --> 53:30.590
你用下标去删除组的时候

53:30.590 --> 53:31.590
特别是去删什么

53:31.590 --> 53:32.590
删满足条件的

53:32.590 --> 53:33.590
我就删除

53:33.590 --> 53:34.590
不满足条件的

53:34.590 --> 53:35.590
我就不动

53:35.590 --> 53:36.590
满足条件的就删除

53:36.590 --> 53:37.590
在这种情况下

53:37.590 --> 53:38.590
一定要记住

53:38.590 --> 53:39.590
删除完了过后

53:39.590 --> 53:40.590
就得挨剪剪

53:40.590 --> 53:41.590
为什么得挨剪剪的

53:41.590 --> 53:51.430
我给大家举个例子

53:51.430 --> 53:54.430
我要从这个数组中删基数

53:54.430 --> 53:56.430
你看如果说

53:56.430 --> 53:57.430
我怎么办

53:57.430 --> 53:58.430
我循环吗

53:58.430 --> 53:59.430
一个获循环吗

53:59.430 --> 54:00.430
挨从零开始了

54:00.430 --> 54:01.430
对不对

54:01.430 --> 54:03.430
挨从零开始

54:03.430 --> 54:04.430
那看第一项

54:04.430 --> 54:05.430
第一项是不是基数

54:05.430 --> 54:07.430
是基数吧

54:07.430 --> 54:08.430
是基数吧

54:08.430 --> 54:09.430
我得删吧

54:09.430 --> 54:10.430
好 那我删了吧

54:10.430 --> 54:15.020
如果我不挨剪剪

54:15.020 --> 54:17.020
下一次循环是不是挨便一

54:18.020 --> 54:19.020
哦

54:20.020 --> 54:21.020
挨便一

54:22.020 --> 54:23.020
是不是看这一项了

54:23.020 --> 54:25.590
看动文

54:25.590 --> 54:26.590
是不是看这一项了

54:26.590 --> 54:28.590
所以挑过了三

54:28.590 --> 54:29.590
不要理会吧

54:29.590 --> 54:31.590
因为你删了过后

54:31.590 --> 54:33.590
你把这个数据删了过后

54:33.590 --> 54:35.590
就导致后边的下标变了

54:35.590 --> 54:37.590
下标往前移动了

54:37.590 --> 54:39.590
你把这一项一删

54:39.590 --> 54:40.590
他的下标是不是

54:40.590 --> 54:41.590
以前是一线变零了

54:41.590 --> 54:43.590
那如果说你不挨剪剪的话

54:43.590 --> 54:44.590
那下一次循环

54:44.590 --> 54:45.590
挨一下一

54:45.590 --> 54:47.590
就直接看这一项了

54:47.590 --> 54:48.590
能理解吧

54:48.590 --> 54:49.590
这边应该很好懂了吧

54:49.590 --> 54:54.250
推到一个新速度当然好

54:54.250 --> 54:56.250
你学到ES5的Fiorto之后

54:56.250 --> 54:58.250
当然是更加舒服了

54:58.250 --> 55:00.250
如果说你没有学过Fiorto之前

55:00.250 --> 55:02.250
或者是有些某些情况下

55:02.250 --> 55:04.250
你得用这种方式去删

55:04.250 --> 55:06.250
那你就得用这种方式

55:06.250 --> 55:08.250
所以说你在删这个时候

55:08.250 --> 55:09.250
循环删到的时候

55:09.250 --> 55:12.250
你把第一项删了过后

55:12.250 --> 55:13.250
干嘛呢

55:13.250 --> 55:15.250
你再把先把简一变成-1

55:15.250 --> 55:17.250
好 下一次循环他-1

55:17.250 --> 55:18.250
所以又回归到0

55:18.250 --> 55:19.250
对吧

55:19.250 --> 55:20.250
也就是啥意思

55:20.250 --> 55:22.250
我就得重复看一下这个位置

55:22.250 --> 55:24.250
得重复看一次

55:24.250 --> 55:25.250
你要理解吧

55:25.250 --> 55:26.250
再重复看一次

55:26.250 --> 55:27.250
而且这一项又满足条件

55:27.250 --> 55:28.250
又删

55:28.250 --> 55:30.250
删了过后他又变-1

55:30.250 --> 55:32.250
然后他加1又变0

55:32.250 --> 55:34.250
我又得重复看一次这个位置

55:34.250 --> 55:37.250
只要你删了过后就把简剪

55:37.250 --> 55:39.250
然后你学了ES5的Fiorto之后

55:39.250 --> 55:40.250
就非常简单了

55:40.250 --> 55:41.250
ES5的Fiorto的话

55:41.250 --> 55:43.250
这个东西就很好写了

55:43.250 --> 55:45.250
什么写的Fiorto

55:45.250 --> 55:46.250
剪头发书

55:46.250 --> 55:49.250
什么Found Includes Battle

55:49.250 --> 55:51.250
一句话就写完了

55:51.250 --> 55:53.250
但是没有学过ES5之前

55:53.250 --> 55:55.250
或者是有些情况下

55:55.250 --> 55:57.250
你用循环去删了

55:57.250 --> 55:58.250
注意啊

55:58.250 --> 55:59.250
下表解译

55:59.250 --> 56:02.560
好

56:03.560 --> 56:05.560
那么这样子一删完

56:05.560 --> 56:06.560
那个时候就正确了

56:06.560 --> 56:08.560
下一程是不是没问题了

56:08.560 --> 56:11.560
我自己这一程没找到吗

56:11.560 --> 56:12.560
找到我就早就返回了

56:12.560 --> 56:13.560
早就结束了

56:13.560 --> 56:15.560
那么循环完了没有找到

56:15.560 --> 56:16.560
我得看下一层吧

56:16.560 --> 56:18.560
我就直接返回

56:21.560 --> 56:22.560
把下一层的结果返回

56:22.560 --> 56:23.560
我这一层没有

56:23.560 --> 56:25.560
那就把下一层看什么情况

56:25.560 --> 56:26.560
找下一层的时候他没有

56:26.560 --> 56:28.560
那就继续看下一层

56:28.560 --> 56:30.560
直到找到没有层了

56:30.560 --> 56:31.560
这一层没有节点

56:31.560 --> 56:32.560
这就是广收

56:37.000 --> 56:38.000
对吧

56:38.000 --> 56:39.000
找什么呢

56:39.000 --> 56:40.000
找E

56:41.000 --> 56:42.000
Force

56:42.000 --> 56:43.000
小学的E

56:43.000 --> 56:44.000
Q

56:44.000 --> 56:45.000
广收

56:45.000 --> 56:46.000
好了

56:46.000 --> 56:48.000
这是图的搜索

56:48.000 --> 56:49.000
图的查询算法

56:49.000 --> 56:50.000
搜索算法

56:50.000 --> 56:51.000
一个深度优先

56:51.000 --> 56:52.000
一个广税优先

56:52.000 --> 56:53.000
广税优先他稍微的

56:53.000 --> 56:54.000
浮上了没流油

56:54.000 --> 56:55.000
但是特别

56:55.000 --> 56:57.000
这两东西特别训练逻辑

56:57.000 --> 56:58.000
这两个呢

56:58.000 --> 56:59.000
还好

56:59.000 --> 57:00.000
还好

57:00.000 --> 57:01.000
或者有一些细节的地方呢

57:01.000 --> 57:03.000
感觉好像有点难了一点点

57:03.000 --> 57:04.000
但是呢

57:04.000 --> 57:05.000
整体上

57:05.000 --> 57:06.000
真的还好

57:06.000 --> 57:08.000
理由了前面几天的训练过后

57:08.000 --> 57:10.000
正好你整体上

57:10.000 --> 57:11.000
你这个逻辑的途律

57:11.000 --> 57:13.000
看能不能看懂吗

57:13.000 --> 57:14.000
感觉上代码呢

57:14.000 --> 57:16.000
好像

57:16.000 --> 57:17.000
听懂了

57:17.000 --> 57:18.000
但是呢自己写呢

57:18.000 --> 57:19.000
好像又写不出来

57:19.000 --> 57:21.000
有点这种晕晕的感觉

57:21.000 --> 57:23.000
其实这种感觉还好

57:23.000 --> 57:24.000
这几天呢

57:24.000 --> 57:25.000
我就是

57:25.000 --> 57:26.000
天天都是

57:26.000 --> 57:27.000
天天

57:27.000 --> 57:28.000
白天也好

57:28.000 --> 57:29.000
晚上听课也好

57:29.000 --> 57:30.000
都是这种感觉

57:30.000 --> 57:31.000
这种感觉的话

57:31.000 --> 57:32.000
你的思维才是

57:32.000 --> 57:34.000
正儿八经得到训练的

57:34.000 --> 57:36.000
如果说意料感觉都没有

57:36.000 --> 57:37.000
或者琴琴匆匆

57:37.000 --> 57:38.000
一边刷抖音

57:38.000 --> 57:39.000
一边听歌

57:39.000 --> 57:40.000
一边看课程

57:40.000 --> 57:41.000
你学啥东西

57:41.000 --> 57:42.000
就学不了东西

57:42.000 --> 57:44.000
就是要懂晕晕的感觉

57:44.000 --> 57:45.000
记住了

57:45.000 --> 57:46.000
你学习的时候

57:46.000 --> 57:47.000
如果说没有那种

57:47.000 --> 57:48.000
晕晕的感觉

57:48.000 --> 57:49.000
这好像就懂了

57:49.000 --> 57:50.000
好像又差了一点点

57:50.000 --> 57:52.000
好像要去向来去想一想

57:52.000 --> 57:53.000
好像要多看几遍

57:53.000 --> 57:54.000
你没有那种感觉的话

57:54.000 --> 57:58.020
你是没学到东西的

57:58.020 --> 58:00.020
学习的感觉就是这个样子

58:00.020 --> 58:01.020
好 第二个问题

58:01.020 --> 58:03.020
最小生成熟

58:03.020 --> 58:14.680
该喝水了喝水

58:14.680 --> 58:15.680
这啥问题

58:15.680 --> 58:21.420
都是这个问题

58:21.420 --> 58:22.420
就是说

58:22.420 --> 58:26.180
现在呢有这么一个情况

58:26.180 --> 58:27.180
我们这个

58:27.180 --> 58:29.180
我们今年去年

58:29.180 --> 58:31.180
国家不是在那个扶贫吗

58:31.180 --> 58:32.180
对不对

58:32.180 --> 58:33.180
要致富的干嘛呀

58:33.180 --> 58:35.180
得先修路

58:35.180 --> 58:36.180
那有些村庄呢

58:36.180 --> 58:38.180
还在深山里边

58:38.180 --> 58:39.180
可能我们大部分

58:39.180 --> 58:40.180
农村都已经改造过了

58:40.180 --> 58:42.180
但是还有一些村庄呢

58:42.180 --> 58:43.180
都在深山里边

58:43.180 --> 58:44.180
连路都不同

58:44.180 --> 58:47.260
那么想办法吧

58:47.260 --> 58:48.260
咱们要扶贫

58:48.260 --> 58:49.260
肯定得修路吧

58:49.260 --> 58:51.260
比方说有这么一些村庄

58:51.260 --> 58:54.260
A B C D E

58:54.260 --> 58:56.260
有这么一些村庄

58:56.260 --> 58:57.260
这些村庄呢

58:57.260 --> 59:00.260
他们有可能

59:00.260 --> 59:01.260
连通的情况

59:01.260 --> 59:02.260
我们现在还在做规划

59:02.260 --> 59:03.260
对吧

59:03.260 --> 59:04.260
他们都是孤立的

59:04.260 --> 59:05.260
孤立宁的

59:05.260 --> 59:06.260
没有路

59:06.260 --> 59:07.260
我们现在得考虑

59:07.260 --> 59:09.260
把这些村庄全部连通

59:09.260 --> 59:10.260
你连通

59:10.260 --> 59:12.260
是不是就变成一个图

59:12.260 --> 59:14.260
对不对

59:14.260 --> 59:15.260
但是这些村庄的路

59:15.260 --> 59:16.260
特别难修

59:16.260 --> 59:19.220
如果

59:19.220 --> 59:21.220
如果说你全部把它修好

59:21.220 --> 59:23.220
全部把它连起来

59:23.220 --> 59:25.220
那成本太高了

59:25.220 --> 59:26.220
于是呢

59:26.220 --> 59:28.220
那些地质学家

59:28.220 --> 59:29.220
工程师呢

59:29.220 --> 59:31.220
他就去考察

59:31.220 --> 59:33.220
发现A和B

59:33.220 --> 59:34.220
我可以修一条路

59:34.220 --> 59:36.220
比方说绕了一个山

59:36.220 --> 59:38.220
这个路长度为8

59:38.220 --> 59:39.220
我们就几组8

59:39.220 --> 59:41.220
比方8公里

59:41.220 --> 59:44.220
那么A和C之间

59:44.220 --> 59:45.220
我又有一条路

59:45.220 --> 59:46.220
可以修一条路

59:46.220 --> 59:47.220
可以修长度为3

59:47.220 --> 59:49.220
C和B有一条路

59:49.220 --> 59:50.220
如果说修的话

59:50.220 --> 59:51.220
可以修个长度为4000米的

59:51.220 --> 59:52.220
B和D之间

59:52.220 --> 59:53.220
可以长度为10

59:53.220 --> 59:55.220
但是B和D

59:55.220 --> 59:57.220
中间可能有一路火山

59:57.220 --> 01:00:00.220
B和D

01:00:00.220 --> 01:00:02.220
比方说B和D这两个村庄

01:00:02.220 --> 01:00:03.220
根本就没法修

01:00:03.220 --> 01:00:05.220
中间可能有一个火山

01:00:05.220 --> 01:00:07.220
或者是有个什么

01:00:07.220 --> 01:00:10.220
里边发现了什么草草木

01:00:10.220 --> 01:00:12.220
发现了孙悟空木

01:00:12.220 --> 01:00:14.220
修不了了

01:00:14.220 --> 01:00:15.220
没法修

01:00:15.220 --> 01:00:17.220
那没法修就没法修

01:00:17.220 --> 01:00:19.220
这里就是画出来的虚像

01:00:19.220 --> 01:00:20.220
就表示能修的

01:00:20.220 --> 01:00:21.220
但是我还没有修

01:00:21.220 --> 01:00:22.220
能修的

01:00:22.220 --> 01:00:23.220
什么意思

01:00:23.220 --> 01:00:24.220
当然这个

01:00:24.220 --> 01:00:25.220
我们就简单来看的话

01:00:25.220 --> 01:00:27.220
就是说修的路越长

01:00:27.220 --> 01:00:29.220
花的钱就越多

01:00:29.220 --> 01:00:31.220
我现在要找一个办法

01:00:31.220 --> 01:00:33.220
我要既能够把这些村庄

01:00:33.220 --> 01:00:34.220
全部连通

01:00:34.220 --> 01:00:37.220
我花的钱又最少

01:00:37.220 --> 01:00:39.220
这就是个最小生成书

01:00:39.220 --> 01:00:40.220
为什么叫做最小生成书呢

01:00:40.220 --> 01:00:42.220
因为这样子一连通起来

01:00:42.220 --> 01:00:44.220
数学证明我不去证明了

01:00:44.220 --> 01:00:46.220
这些东西连通起来

01:00:46.220 --> 01:00:48.220
连通起来过后

01:00:48.220 --> 01:00:50.220
它就是一棵树

01:00:50.220 --> 01:00:51.220
比方说

01:00:51.220 --> 01:00:53.220
这个玩意就是最小的

01:00:53.220 --> 01:00:54.220
最小的成本

01:00:54.220 --> 01:00:56.220
这个玩意是不是一棵树

01:00:56.220 --> 01:00:58.220
是不是一棵树

01:00:58.220 --> 01:00:59.220
我们把这棵树

01:00:59.220 --> 01:01:02.220
叫做最小生成书

01:01:02.220 --> 01:01:04.220
首先大家有没有懂我

01:01:04.220 --> 01:01:05.220
懂我这个意思

01:01:05.220 --> 01:01:09.870
有没有懂这个意思

01:01:09.870 --> 01:01:11.870
意思有没有理解

01:01:11.870 --> 01:01:13.870
就找最小的路心

01:01:13.870 --> 01:01:17.250
能理解的意思吧

01:01:17.250 --> 01:01:18.250
我用现实的情况

01:01:18.250 --> 01:01:19.250
给大家举例的

01:01:19.250 --> 01:01:20.250
就是要把这些东西

01:01:20.250 --> 01:01:21.250
全部连起来

01:01:21.250 --> 01:01:22.250
但同时

01:01:22.250 --> 01:01:23.250
剧短

01:01:23.250 --> 01:01:24.250
耗费的钱最少

01:01:24.250 --> 01:01:26.250
连接的线最短

01:01:26.250 --> 01:01:27.250
不要让你

01:01:27.250 --> 01:01:28.250
最好不要去连它

01:01:28.250 --> 01:01:29.250
这个线太长了

01:01:29.250 --> 01:01:32.200
还没有听懂意思吗

01:01:32.200 --> 01:01:33.200
还有什么问题

01:01:33.200 --> 01:01:35.580
有什么问题

01:01:35.580 --> 01:01:37.580
有问题就赶快问

01:01:37.580 --> 01:01:39.580
哪个地方没太明白

01:01:39.580 --> 01:01:43.660
我要把它们全部连起来

01:01:43.660 --> 01:01:45.660
你不要去想什么几何问题

01:01:45.660 --> 01:01:46.660
为什么这个地方是

01:01:46.660 --> 01:01:47.660
假写17

01:01:47.660 --> 01:01:48.660
好像有些地方

01:01:48.660 --> 01:01:50.660
不太符合三角形

01:01:50.660 --> 01:01:51.660
你不要去想几何问题

01:01:51.660 --> 01:01:52.660
图里边是

01:01:52.660 --> 01:01:54.660
它是一个脱补问题

01:01:54.660 --> 01:01:55.660
脱补学的范畴

01:01:55.660 --> 01:01:56.660
脱补学

01:01:56.660 --> 01:01:58.660
它不是几何

01:01:58.660 --> 01:01:59.660
它不是几何

01:01:59.660 --> 01:02:00.660
它不是几何问题

01:02:00.660 --> 01:02:01.660
不要让你去想象

01:02:01.660 --> 01:02:02.660
我在这里有些地方

01:02:02.660 --> 01:02:04.660
画的是玩人有趣的线

01:02:04.660 --> 01:02:05.660
有的时候

01:02:05.660 --> 01:02:07.660
它可能遇到一些情况

01:02:07.660 --> 01:02:08.660
我的招

01:02:08.660 --> 01:02:09.660
我的招

01:02:09.660 --> 01:02:10.660
中间有什么地铁之类的

01:02:10.660 --> 01:02:11.660
我的招

01:02:11.660 --> 01:02:12.660
他们这里画出来

01:02:12.660 --> 01:02:13.660
就是我有可能

01:02:13.660 --> 01:02:15.660
出现的连通情况

01:02:15.660 --> 01:02:16.660
那么现在你

01:02:16.660 --> 01:02:18.660
让你把它连通

01:02:18.660 --> 01:02:23.890
连通出来就是一棵树

01:02:23.890 --> 01:02:25.890
那么这个问题

01:02:25.890 --> 01:02:26.890
我都不说

01:02:26.890 --> 01:02:28.890
怎么去写代码了

01:02:28.890 --> 01:02:31.890
今天可能会脱一块糖

01:02:31.890 --> 01:02:33.890
我首先把这个寒树写出来

01:02:33.890 --> 01:02:35.890
这个寒树要什么参数

01:02:35.890 --> 01:02:37.890
返回的是什么

01:02:37.890 --> 01:02:39.890
我可以把这个玩意儿写出来

01:02:39.890 --> 01:02:40.890
好

01:02:40.890 --> 01:02:41.890
首先我现在

01:02:41.890 --> 01:02:42.890
其他写寒树

01:02:42.890 --> 01:02:43.890
我觉得先不着急去

01:02:43.890 --> 01:02:45.890
我现在搞定这个问题

01:02:45.890 --> 01:02:48.890
我有几个节点

01:02:48.890 --> 01:02:49.890
首先我搞定这个问题

01:02:49.890 --> 01:02:50.890
我有几个节点

01:02:50.890 --> 01:02:51.890
那比方说我这里

01:02:51.890 --> 01:02:52.890
就有这么几个节点

01:02:52.890 --> 01:02:53.890
A B C D E

01:02:53.890 --> 01:02:56.890
有五个节点

01:02:56.890 --> 01:02:57.890
这五个节点

01:02:57.890 --> 01:02:58.890
有没有连通

01:02:58.890 --> 01:02:59.890
没有连通

01:02:59.890 --> 01:03:00.890
就等着你连通

01:03:00.890 --> 01:03:01.890
都没有连通

01:03:01.890 --> 01:03:04.970
他们现在是孤立的

01:03:04.970 --> 01:03:05.970
那么这里

01:03:05.970 --> 01:03:07.970
我可以用一个数组

01:03:08.970 --> 01:03:14.070
节点的数字

01:03:16.070 --> 01:03:30.300
A B C D E

01:03:30.300 --> 01:03:32.300
一共有这么五个节点

01:03:32.300 --> 01:03:33.300
这个没问题吧

01:03:33.300 --> 01:03:34.300
节点的数字

01:03:34.300 --> 01:03:35.300
好

01:03:35.300 --> 01:03:36.300
那么这样子

01:03:36.300 --> 01:03:37.300
是不是把节点表示出来了

01:03:37.300 --> 01:03:38.300
他们之间没有联系

01:03:38.300 --> 01:03:39.300
好

01:03:39.300 --> 01:03:40.300
接下来我

01:03:40.300 --> 01:03:41.300
因为我现在不能连

01:03:41.300 --> 01:03:42.300
我现在写寒树的目的

01:03:42.300 --> 01:03:45.300
就是要用寒树去连

01:03:45.300 --> 01:03:46.300
好 接下来

01:03:46.300 --> 01:03:48.300
我怎么来表示个边呢

01:03:48.300 --> 01:03:51.300
怎么来表示个边呢

01:03:51.300 --> 01:03:52.300
表示边的话

01:03:52.300 --> 01:03:55.300
我是不是可以做一个

01:03:55.300 --> 01:03:56.300
做一个表格

01:03:56.300 --> 01:03:57.300
做一个这么一个

01:03:57.300 --> 01:03:59.300
这么一种表格

01:03:59.300 --> 01:04:05.300
A B C D E

01:04:05.300 --> 01:04:08.300
A B C D E

01:04:08.300 --> 01:04:09.300
可以做这么一个表

01:04:09.300 --> 01:04:10.300
A到A的距离

01:04:10.300 --> 01:04:12.300
我们就认为是0

01:04:12.300 --> 01:04:13.300
A到A

01:04:13.300 --> 01:04:16.300
A到它自己不就是0吗

01:04:16.300 --> 01:04:17.300
A到B的距离

01:04:17.300 --> 01:04:18.300
你看

01:04:18.300 --> 01:04:19.300
A到D不就是8吗

01:04:19.300 --> 01:04:21.300
我们表示的这个田八

01:04:21.300 --> 01:04:23.300
A到C是不是就3

01:04:23.300 --> 01:04:24.300
A到D

01:04:24.300 --> 01:04:26.300
A不能直接到D

01:04:26.300 --> 01:04:27.300
也是到不了D

01:04:27.300 --> 01:04:28.300
A到不了D的话

01:04:28.300 --> 01:04:29.300
A到D就是infinity

01:04:29.300 --> 01:04:31.300
就是无穷大

01:04:31.300 --> 01:04:33.300
然后我们用这种表格来写

01:04:33.300 --> 01:04:34.300
那么这样子写出来

01:04:34.300 --> 01:04:35.300
在程序里面

01:04:35.300 --> 01:04:37.300
是不是就是一个二维数组

01:04:38.300 --> 01:04:40.300
我们用个边来表示

01:04:40.300 --> 01:04:42.930
数组里面

01:04:42.930 --> 01:04:43.930
每一项是个数组

01:04:43.930 --> 01:04:44.930
那么第一行

01:04:44.930 --> 01:04:45.930
我们就把东西换成行吧

01:04:45.930 --> 01:04:46.930
第一行

01:04:46.930 --> 01:04:49.930
A到A的距离是多少

01:04:49.930 --> 01:04:51.930
我们一边看口一边写

01:04:51.930 --> 01:05:02.940
拿过来

01:05:02.940 --> 01:05:04.940
A到A的距离

01:05:04.940 --> 01:05:06.940
A到A的距离就是0吗

01:05:06.940 --> 01:05:09.940
自己到自己就是0吗

01:05:09.940 --> 01:05:10.940
然后呢

01:05:10.940 --> 01:05:13.940
A到B的距离

01:05:13.940 --> 01:05:14.940
对到来看

01:05:14.940 --> 01:05:15.940
对到的符

01:05:15.940 --> 01:05:16.940
对到上面的表格来看

01:05:16.940 --> 01:05:18.940
A到B的距离8

01:05:18.940 --> 01:05:20.940
A到C的距离3

01:05:20.940 --> 01:05:24.940
A到D的距离5穷大

01:05:24.940 --> 01:05:27.940
A到E的距离4

01:05:27.940 --> 01:05:29.940
是不是可以用这种方式来表示

01:05:29.940 --> 01:05:30.940
又来

01:05:30.940 --> 01:05:32.940
B到A

01:05:32.940 --> 01:05:34.940
B到A8

01:05:34.940 --> 01:05:37.940
B到B0

01:05:37.940 --> 01:05:40.940
B到C4

01:05:40.940 --> 01:05:43.940
B到D

01:05:43.940 --> 01:05:45.940
B到D10

01:05:46.940 --> 01:05:47.940
B到E

01:05:47.940 --> 01:05:48.940
5穷大

01:05:48.940 --> 01:05:51.640
好 接下来

01:05:51.640 --> 01:05:52.640
C

01:05:52.640 --> 01:05:54.640
C到A3

01:05:54.640 --> 01:05:56.640
C到B4

01:05:56.640 --> 01:05:59.640
C到C0

01:05:59.640 --> 01:06:03.640
C到D3

01:06:03.640 --> 01:06:05.640
C到E5穷大

01:06:05.640 --> 01:06:07.640
倒不了

01:06:07.640 --> 01:06:08.640
好 又来

01:06:08.640 --> 01:06:10.640
D到A

01:06:10.640 --> 01:06:12.640
倒不了

01:06:12.640 --> 01:06:14.640
D到B10

01:06:14.640 --> 01:06:18.340
D到C3

01:06:19.340 --> 01:06:20.340
D到D0

01:06:20.340 --> 01:06:22.340
D到E6

01:06:22.340 --> 01:06:23.340
好 E

01:06:23.340 --> 01:06:25.340
E到A4

01:06:25.340 --> 01:06:26.340
E到B

01:06:26.340 --> 01:06:29.340
倒不了

01:06:29.340 --> 01:06:32.840
E到

01:06:32.840 --> 01:06:35.840
E到C

01:06:35.840 --> 01:06:37.840
倒不了

01:06:37.840 --> 01:06:38.840
E到B倒不了

01:06:38.840 --> 01:06:39.840
E到C也倒不了

01:06:39.840 --> 01:06:40.840
对吧

01:06:40.840 --> 01:06:41.840
也倒不了

01:06:41.840 --> 01:06:43.840
E到D6

01:06:43.840 --> 01:06:47.220
E到E0

01:06:47.220 --> 01:06:48.220
我现在不写函数了

01:06:48.220 --> 01:06:53.810
我先把这两个表示方式能看懂吗

01:06:53.810 --> 01:06:54.810
能看懂吗

01:06:54.810 --> 01:06:59.940
怎么了

01:06:59.940 --> 01:07:00.940
怎么了

01:07:00.940 --> 01:07:01.940
宝贝

01:07:01.940 --> 01:07:02.940
同学们宝贝

01:07:02.940 --> 01:07:07.810
别怕

01:07:07.810 --> 01:07:09.810
我还没写函数

01:07:09.810 --> 01:07:11.810
我现在就是说一步一步来嘛

01:07:11.810 --> 01:07:13.810
先把这个表示方式看得懂

01:07:13.810 --> 01:07:14.810
我们现在有几个节点

01:07:14.810 --> 01:07:15.810
他们是孤立的

01:07:15.810 --> 01:07:16.810
对吧

01:07:16.810 --> 01:07:17.810
然后呢

01:07:17.810 --> 01:07:18.810
它可能会出现了边的情况

01:07:18.810 --> 01:07:19.810
边的情况呢

01:07:19.810 --> 01:07:20.810
就这个东西描述出来

01:07:20.810 --> 01:07:21.810
我得描述出来嘛

01:07:21.810 --> 01:07:22.810
我先不说实现了

01:07:22.810 --> 01:07:23.810
我都不知道

01:07:23.810 --> 01:07:25.810
我现在还没有想去怎么去实现

01:07:25.810 --> 01:07:28.810
现在还告诉你怎么去描述

01:07:28.810 --> 01:07:29.810
描述出来

01:07:29.810 --> 01:07:30.810
对吧

01:07:30.810 --> 01:07:32.810
先把表示出来再说

01:07:32.810 --> 01:07:33.810
好

01:07:33.810 --> 01:07:34.810
表示出来了

01:07:34.810 --> 01:07:35.810
现在已经

01:07:35.810 --> 01:07:37.810
表示出来了过后了

01:07:37.810 --> 01:07:38.810
那么接下来

01:07:38.810 --> 01:07:39.810
我要做一件事

01:07:39.810 --> 01:07:41.810
就是把这些点连起来

01:07:41.810 --> 01:07:42.810
现在不是没连吗

01:07:42.810 --> 01:07:43.810
对不对

01:07:43.810 --> 01:07:45.810
我再把每一个节点的邻居啊

01:07:45.810 --> 01:07:46.810
E的邻居应该是啥呀

01:07:46.810 --> 01:07:47.810
B的邻居应该是啥呀

01:07:47.810 --> 01:07:48.810
对吧

01:07:48.810 --> 01:07:49.810
现在都没有做

01:07:49.810 --> 01:07:50.810
这全是孤立的节点

01:07:50.810 --> 01:07:52.810
那我就把它连起来呀

01:07:53.810 --> 01:07:54.810
如果说

01:07:54.810 --> 01:07:55.810
你这个语法

01:07:55.810 --> 01:07:57.810
就是这个书主里面写的

01:07:57.810 --> 01:07:58.810
这种方式

01:07:58.810 --> 01:07:59.810
你看不懂的话

01:07:59.810 --> 01:08:00.810
这个基础啊

01:08:00.810 --> 01:08:01.810
真的要好好去补啊

01:08:01.810 --> 01:08:02.810
同学们

01:08:02.810 --> 01:08:03.810
不然的话

01:08:03.810 --> 01:08:04.810
什么东西都学不了

01:08:04.810 --> 01:08:07.810
那个乘客的介事课程

01:08:07.810 --> 01:08:08.810
免费的工艺课程

01:08:08.810 --> 01:08:10.810
一定要去看啊

01:08:10.810 --> 01:08:11.810
像那额围书主

01:08:11.810 --> 01:08:13.810
这种表示方式看不懂的话

01:08:13.810 --> 01:08:14.810
那基础

01:08:14.810 --> 01:08:16.810
那存在严重的问题啊

01:08:16.810 --> 01:08:17.810
好

01:08:17.810 --> 01:08:18.810
那么现在呢

01:08:18.810 --> 01:08:20.810
我们这里方形写个函数

01:08:20.810 --> 01:08:22.810
那么我们就用个中文吧

01:08:22.810 --> 01:08:25.440
连

01:08:25.440 --> 01:08:26.440
要干嘛呢

01:08:26.440 --> 01:08:28.440
你把所有的节点给我

01:08:28.440 --> 01:08:30.440
你把所有的编给我

01:08:30.440 --> 01:08:31.440
那就一件事

01:08:31.440 --> 01:08:32.440
把给我的这些点

01:08:32.440 --> 01:08:34.440
根据编的情况

01:08:34.440 --> 01:08:35.440
用最

01:08:35.440 --> 01:08:37.440
最节省成本的方式

01:08:37.440 --> 01:08:38.440
用最短的方式

01:08:38.440 --> 01:08:39.440
把一些点连起来

01:08:39.440 --> 01:08:40.440
比方说

01:08:40.440 --> 01:08:41.440
A

01:08:41.440 --> 01:08:42.440
A我连啥呀

01:08:42.440 --> 01:08:43.440
我连E还是连C呀

01:08:43.440 --> 01:08:44.440
我连

01:08:44.440 --> 01:08:45.440
要不要去连B呀等等等等

01:08:45.440 --> 01:08:46.440
就这么个意思

01:08:46.440 --> 01:08:48.440
我得把这个里面的点连起来

01:08:48.440 --> 01:08:49.440
啊

01:08:49.440 --> 01:08:50.440
将

01:08:50.440 --> 01:08:51.440
就根据

01:08:51.440 --> 01:08:54.820
编的情况

01:08:54.820 --> 01:08:55.820
啊

01:08:55.820 --> 01:08:57.820
将逗字中的

01:08:57.820 --> 01:08:58.820
节点

01:08:58.820 --> 01:08:59.820
连起来

01:09:00.820 --> 01:09:01.820
形成最小生成数

01:09:01.820 --> 01:09:03.820
因为我连起来不是随便点

01:09:03.820 --> 01:09:04.820
我还得考虑

01:09:04.820 --> 01:09:05.820
它的长短问题

01:09:05.820 --> 01:09:06.820
用最短的方式连连

01:09:06.820 --> 01:09:08.820
那么这个其实就是一个

01:09:08.820 --> 01:09:09.820
最小生成数的算法

01:09:09.820 --> 01:09:12.820
那么最小生成数的算法呢

01:09:12.820 --> 01:09:13.820
通常情况下

01:09:13.820 --> 01:09:15.820
我们一般会使用两种

01:09:15.820 --> 01:09:16.820
一种叫做普利姆算法

01:09:16.820 --> 01:09:18.820
一种叫做克鲁斯卡尔算法

01:09:18.820 --> 01:09:20.820
我们这里呢只讲

01:09:20.820 --> 01:09:21.820
普利姆算法

01:09:21.820 --> 01:09:22.820
普利姆算法呢

01:09:22.820 --> 01:09:24.820
要相对来说比较简单一点啊

01:09:24.820 --> 01:09:25.820
克鲁斯卡尔呢

01:09:25.820 --> 01:09:26.820
有点麻烦啊

01:09:26.820 --> 01:09:28.820
普利姆算法是怎么算的呢

01:09:28.820 --> 01:09:29.820
它就是

01:09:29.820 --> 01:09:31.820
它其实就是个贪心算法

01:09:31.820 --> 01:09:33.820
我们明天要说到贪心算法

01:09:33.820 --> 01:09:35.820
就是我管那么多

01:09:35.820 --> 01:09:36.820
我不许管什么全局

01:09:36.820 --> 01:09:39.820
我就是保证现在的连续

01:09:39.820 --> 01:09:40.820
最短就行了

01:09:40.820 --> 01:09:42.820
啥意思呢

01:09:42.820 --> 01:09:43.820
啥意思呢

01:09:43.820 --> 01:09:46.820
我先形成一个部落

01:09:46.820 --> 01:09:47.820
随便哪一个点

01:09:47.820 --> 01:09:49.820
不要用第一个点

01:09:49.820 --> 01:09:51.820
我把它形成一个春落

01:09:51.820 --> 01:09:53.820
一个春落里边有很多春桩

01:09:53.820 --> 01:09:55.820
形成一个部落

01:09:55.820 --> 01:09:56.820
我在外面的

01:09:56.820 --> 01:09:58.820
其他的点去找一找

01:09:58.820 --> 01:10:00.820
看哪一个点

01:10:00.820 --> 01:10:02.820
到我这个部落最近

01:10:02.820 --> 01:10:05.380
看哪一个点

01:10:05.380 --> 01:10:06.380
到我这个部落最近

01:10:06.380 --> 01:10:07.380
哪个点呢

01:10:07.380 --> 01:10:08.380
是不是C这个点

01:10:08.380 --> 01:10:09.380
好

01:10:09.380 --> 01:10:10.380
我就把A和C相连

01:10:10.380 --> 01:10:13.760
于是这条线就连接了

01:10:13.760 --> 01:10:16.460
好

01:10:16.460 --> 01:10:17.460
接下来

01:10:17.460 --> 01:10:18.460
部落是不是装大了

01:10:18.460 --> 01:10:20.460
部落有两个春桩的A和C

01:10:20.460 --> 01:10:23.460
我接下来又看

01:10:23.460 --> 01:10:25.460
重复这个过程

01:10:25.460 --> 01:10:26.460
看什么呢

01:10:26.460 --> 01:10:28.460
看接下来又是哪个点

01:10:28.460 --> 01:10:29.460
其他的点

01:10:29.460 --> 01:10:31.460
哪个点

01:10:31.460 --> 01:10:33.460
到我这个春落

01:10:33.460 --> 01:10:36.460
部落不是某一个春者

01:10:36.460 --> 01:10:37.460
不是某一个节点

01:10:37.460 --> 01:10:40.460
到我整个部落最近的

01:10:40.460 --> 01:10:41.460
先不着急写单

01:10:41.460 --> 01:10:42.460
全理解逻辑

01:10:42.460 --> 01:10:43.460
那么现在哪个点

01:10:43.460 --> 01:10:47.790
到这个部落最近

01:10:47.790 --> 01:10:52.900
哪个点到这个部落最近

01:10:52.900 --> 01:10:53.900
是不是D

01:10:53.900 --> 01:10:54.900
你看吧

01:10:54.900 --> 01:10:55.900
E这个点到部落

01:10:55.900 --> 01:10:56.900
有两个距离

01:10:56.900 --> 01:10:57.900
一个是4

01:10:57.900 --> 01:10:58.900
一个是6

01:10:58.900 --> 01:11:00.900
他肯定要去4

01:11:00.900 --> 01:11:01.900
那么E这个

01:11:01.900 --> 01:11:02.900
我们就可以认为E

01:11:02.900 --> 01:11:05.900
部落是4

01:11:05.900 --> 01:11:06.900
D到这个部落

01:11:06.900 --> 01:11:07.900
有几个

01:11:07.900 --> 01:11:08.900
有几条线呢

01:11:08.900 --> 01:11:09.900
只有一条线

01:11:09.900 --> 01:11:12.900
那么这条线就是3

01:11:12.900 --> 01:11:13.900
好

01:11:13.900 --> 01:11:14.900
D点到这个部落

01:11:14.900 --> 01:11:15.900
所以有两条线

01:11:15.900 --> 01:11:16.900
8和4

01:11:16.900 --> 01:11:17.900
那就取最短

01:11:17.900 --> 01:11:18.900
取4

01:11:18.900 --> 01:11:19.900
那么就可以4

01:11:19.900 --> 01:11:20.900
3

01:11:20.900 --> 01:11:21.900
那么肯定是他最短

01:11:21.900 --> 01:11:22.900
那么我就把他

01:11:22.900 --> 01:11:23.900
跟这个部落相连

01:11:23.900 --> 01:11:25.900
部落又装大了

01:11:25.900 --> 01:11:26.900
对不对

01:11:26.900 --> 01:11:27.900
那么接下来又来看

01:11:27.900 --> 01:11:28.900
剩下的点

01:11:28.900 --> 01:11:31.900
哪个点到我的部落最近呢

01:11:31.900 --> 01:11:32.900
有两条线到部落

01:11:32.900 --> 01:11:33.900
4和6

01:11:33.900 --> 01:11:34.900
那么取4

01:11:34.900 --> 01:11:35.900
D呢有两条

01:11:35.900 --> 01:11:36.900
有三条线

01:11:36.900 --> 01:11:37.900
4、8、10

01:11:37.900 --> 01:11:38.900
取4

01:11:38.900 --> 01:11:39.900
那么随便取一个

01:11:39.900 --> 01:11:40.900
对吧

01:11:40.900 --> 01:11:41.900
都最近

01:11:41.900 --> 01:11:42.900
他一样的

01:11:42.900 --> 01:11:45.590
那随便点一个吧

01:11:45.590 --> 01:11:46.590
不要连避

01:11:46.590 --> 01:11:47.590
好

01:11:47.590 --> 01:11:48.590
那么接下来

01:11:48.590 --> 01:11:49.590
继续看

01:11:49.590 --> 01:11:50.590
那么E

01:11:50.590 --> 01:11:51.590
到这个部落

01:11:51.590 --> 01:11:52.590
最近的

01:11:52.590 --> 01:11:53.590
最近的不就是

01:11:53.590 --> 01:11:54.590
他只能他了

01:11:54.590 --> 01:11:55.590
对吧

01:11:55.590 --> 01:11:56.590
那么取

01:11:56.590 --> 01:11:57.590
取最新的一条线

01:11:57.590 --> 01:11:58.590
这就是最小省省书

01:11:58.590 --> 01:11:59.590
那么这样的连出来

01:11:59.590 --> 01:12:00.590
就是最短的

01:12:00.590 --> 01:12:01.590
就是普林牧山

01:12:01.590 --> 01:12:02.590
他是不乱的

01:12:02.590 --> 01:12:03.590
部落直到有一天

01:12:03.590 --> 01:12:06.590
部落涵盖了所有的节点

01:12:06.590 --> 01:12:07.590
那我就连完了

01:12:07.590 --> 01:12:08.590
对吧

01:12:08.590 --> 01:12:09.590
部落里边一定是连通的

01:12:09.590 --> 01:12:10.590
你看

01:12:10.590 --> 01:12:11.590
每一个阶段

01:12:11.590 --> 01:12:15.970
部落里边一定是连通的

01:12:15.970 --> 01:12:17.970
部落里边一定是连通的

01:12:17.970 --> 01:12:18.970
好

01:12:18.970 --> 01:12:19.970
那么也就是说

01:12:19.970 --> 01:12:20.970
这里边我们写个

01:12:20.970 --> 01:12:21.970
普林牧山法

01:12:21.970 --> 01:12:25.860
首先去除错误情况

01:12:25.860 --> 01:12:26.860
怎么错误情况

01:12:26.860 --> 01:12:27.860
就是肉质

01:12:27.860 --> 01:12:29.860
调一调一

01:12:29.860 --> 01:12:31.860
有只有一个节点

01:12:31.860 --> 01:12:32.860
或者是没有节点

01:12:32.860 --> 01:12:33.860
那我咋连吗

01:12:33.860 --> 01:12:34.860
你只有一个节点

01:12:34.860 --> 01:12:35.860
没法连

01:12:35.860 --> 01:12:36.860
所以我直接发挥

01:12:36.860 --> 01:12:38.860
不用管了吧

01:12:38.860 --> 01:12:40.860
没法连

01:12:40.860 --> 01:12:41.860
好

01:12:41.860 --> 01:12:42.860
那么剩下的事情就是

01:12:42.860 --> 01:12:43.860
不断的去

01:12:43.860 --> 01:12:44.860
我们要做的目标就是

01:12:44.860 --> 01:12:45.860
不断的去壮大部落

01:12:45.860 --> 01:12:46.860
对吧

01:12:46.860 --> 01:12:47.860
那么我们首先建立一个

01:12:47.860 --> 01:12:48.860
初始的部落

01:12:48.860 --> 01:12:49.860
Horde

01:12:49.860 --> 01:12:50.860
部落的单词

01:12:50.860 --> 01:12:51.860
对吧

01:12:51.860 --> 01:12:53.860
for the Horde

01:12:53.860 --> 01:12:58.000
是个书主

01:12:58.000 --> 01:12:59.000
连

01:12:59.000 --> 01:13:01.000
就是部落

01:13:01.000 --> 01:13:02.000
部落中

01:13:02.000 --> 01:13:04.000
部落中的

01:13:04.000 --> 01:13:06.000
每一个村庄

01:13:06.000 --> 01:13:07.000
是

01:13:07.000 --> 01:13:08.000
枪

01:13:08.000 --> 01:13:09.000
是连通的

01:13:09.000 --> 01:13:14.520
连通的

01:13:14.520 --> 01:13:15.520
初始的部落

01:13:15.520 --> 01:13:16.520
是不是只有一个节点

01:13:16.520 --> 01:13:17.520
我就随便拿一个

01:13:17.520 --> 01:13:18.520
我就比方说

01:13:18.520 --> 01:13:20.520
把这个书主里面

01:13:20.520 --> 01:13:21.520
第一个节点

01:13:21.520 --> 01:13:22.520
如果说你这个看不懂的话

01:13:22.520 --> 01:13:24.520
还是基础的问题

01:13:24.520 --> 01:13:25.520
这表达是

01:13:25.520 --> 01:13:26.520
把书主里面

01:13:26.520 --> 01:13:27.520
第一个节点

01:13:27.520 --> 01:13:28.520
作为部落里面的

01:13:28.520 --> 01:13:30.520
第一箱

01:13:30.520 --> 01:13:31.520
部落里面一开始

01:13:31.520 --> 01:13:32.520
只有一个村庄

01:13:32.520 --> 01:13:34.520
初始

01:13:34.520 --> 01:13:35.520
初始

01:13:35.520 --> 01:13:38.520
只有一个村庄

01:13:40.830 --> 01:13:41.830
经常用

01:13:41.830 --> 01:13:42.830
现实的语决

01:13:42.830 --> 01:13:43.830
都没有用专业术

01:13:43.830 --> 01:13:46.400
给大家解释

01:13:46.400 --> 01:13:47.400
那么

01:13:47.400 --> 01:13:48.400
接下来

01:13:48.400 --> 01:13:49.400
就是不断的往部落里面

01:13:49.400 --> 01:13:50.400
夹

01:13:50.400 --> 01:13:51.400
不断的往部落里面夹

01:13:51.400 --> 01:13:52.400
对不对

01:13:52.400 --> 01:13:53.400
不就是往里面夹吗

01:13:53.400 --> 01:13:54.400
夹到什么情况下为止

01:13:54.400 --> 01:13:55.400
比方说

01:13:55.400 --> 01:13:56.400
就用循环

01:13:56.400 --> 01:13:57.400
夹到什么情况下为止

01:13:57.400 --> 01:13:59.400
夹到这个部落的

01:13:59.400 --> 01:14:01.400
长度

01:14:02.400 --> 01:14:03.400
只要部落的长度

01:14:03.400 --> 01:14:05.400
小于肉质的长度

01:14:05.400 --> 01:14:06.400
所以部落

01:14:06.400 --> 01:14:07.400
还有村庄

01:14:07.400 --> 01:14:08.400
说明啥

01:14:08.400 --> 01:14:10.400
说明还有村庄

01:14:10.400 --> 01:14:13.400
没有加入到部落

01:14:13.400 --> 01:14:14.400
对不对

01:14:14.400 --> 01:14:15.400
是不是说明这个

01:14:15.400 --> 01:14:16.400
那么说明这个情况

01:14:16.400 --> 01:14:18.400
它是不是还得往部落里面夹

01:14:19.400 --> 01:14:21.400
继续向

01:14:21.400 --> 01:14:22.400
部落中

01:14:22.400 --> 01:14:24.400
添加村庄

01:14:25.400 --> 01:14:26.400
同学们

01:14:26.400 --> 01:14:31.660
如果说

01:14:31.660 --> 01:14:39.470
理想法

01:14:39.470 --> 01:14:40.470
确实特别特别吃力

01:14:40.470 --> 01:14:41.470
我建议你

01:14:41.470 --> 01:14:42.470
真的

01:14:42.470 --> 01:14:43.470
有能力的话

01:14:43.470 --> 01:14:44.470
跟着他们

01:14:44.470 --> 01:14:45.470
好好把前面的东西

01:14:45.470 --> 01:14:47.470
好好学一下

01:14:47.470 --> 01:14:48.470
前面的东西

01:14:48.470 --> 01:14:49.470
学了

01:14:50.470 --> 01:14:51.470
前面东西学了

01:14:51.470 --> 01:14:52.470
过去的代码量

01:14:52.470 --> 01:14:53.470
基本上就够了

01:14:53.470 --> 01:14:55.470
后边再去看算法的话

01:14:55.470 --> 01:14:56.470
就会简单很多

01:14:57.470 --> 01:14:58.470
其实也就是

01:14:58.470 --> 01:14:59.470
代码量的问题

01:14:59.470 --> 01:15:00.470
还有一个就是

01:15:00.470 --> 01:15:01.470
基础

01:15:01.470 --> 01:15:02.470
老不老靠的问题

01:15:02.470 --> 01:15:03.470
因为没有系统的学习的话

01:15:03.470 --> 01:15:04.470
同学一下

01:15:04.470 --> 01:15:05.470
吸血一下

01:15:05.470 --> 01:15:06.470
确实的基础

01:15:06.470 --> 01:15:07.470
不是很老靠

01:15:08.470 --> 01:15:09.470
继续向

01:15:09.470 --> 01:15:11.470
部落中添加村庄

01:15:11.470 --> 01:15:12.470
那么现在问题

01:15:12.470 --> 01:15:13.470
就是怎么夹

01:15:14.470 --> 01:15:16.780
到底夹哪一个

01:15:16.780 --> 01:15:17.780
怎么夹呢

01:15:17.780 --> 01:15:18.780
这里面需要

01:15:18.780 --> 01:15:19.780
大量的辅助函数

01:15:19.780 --> 01:15:20.780
不然的话

01:15:20.780 --> 01:15:21.780
这里面写一下

01:15:21.780 --> 01:15:24.220
极其复杂

01:15:24.220 --> 01:15:25.220
别看

01:15:25.220 --> 01:15:26.220
听上去好像很简单

01:15:26.220 --> 01:15:28.220
那写下来不简单的

01:15:28.220 --> 01:15:29.220
慢慢来

01:15:29.220 --> 01:15:30.220
不着急

01:15:30.220 --> 01:15:31.220
慢慢来

01:15:31.220 --> 01:15:32.220
我现在

01:15:32.220 --> 01:15:33.220
你们一开始想不到

01:15:33.220 --> 01:15:34.220
有些辅助函数

01:15:34.220 --> 01:15:35.220
没关系

01:15:35.220 --> 01:15:36.220
我用我的程序

01:15:36.220 --> 01:15:37.220
思维能力

01:15:37.220 --> 01:15:38.220
我高速里的

01:15:38.220 --> 01:15:39.220
需要一些辅助函数

01:15:39.220 --> 01:15:40.220
我们先不着急

01:15:40.220 --> 01:15:41.220
写这个外国循环

01:15:41.220 --> 01:15:42.220
我们先把这个

01:15:42.220 --> 01:15:44.660
辅助函数搞定

01:15:45.660 --> 01:15:46.660
一个个来

01:15:46.660 --> 01:15:47.660
什么叫辅助函数呢

01:15:47.660 --> 01:15:48.660
我首先在这里边

01:15:48.660 --> 01:15:49.660
写一个辅助函数

01:15:49.660 --> 01:15:50.660
第一个辅助函数

01:15:50.660 --> 01:15:51.660
你把函数一时

01:15:51.660 --> 01:15:52.660
你想该怎么去实现

01:15:52.660 --> 01:15:54.660
跟着我的思路走就行了

01:15:54.660 --> 01:15:55.660
第一个函数

01:15:55.660 --> 01:15:58.660
我要得到两个点之间的距离

01:15:58.660 --> 01:16:04.000
get distance

01:16:04.000 --> 01:16:05.000
一个传第一个节点

01:16:05.000 --> 01:16:09.020
第二个节点

01:16:09.020 --> 01:16:14.020
得到两个节点之间的距离

01:16:15.020 --> 01:16:16.020
就是边

01:16:16.020 --> 01:16:17.020
它的边是多少

01:16:17.020 --> 01:16:18.020
不要让你传一个B

01:16:18.020 --> 01:16:19.020
传一个C

01:16:19.020 --> 01:16:20.020
我就反回一个4

01:16:20.020 --> 01:16:21.020
你传一个B

01:16:21.020 --> 01:16:22.020
传一个E

01:16:22.020 --> 01:16:23.020
我就反回E

01:16:23.020 --> 01:16:24.020
无穷大

01:16:24.020 --> 01:16:25.020
懂我的意思吗

01:16:25.020 --> 01:16:26.020
你传一个B

01:16:26.020 --> 01:16:27.020
再传个B

01:16:27.020 --> 01:16:28.020
那就反回0

01:16:28.020 --> 01:16:29.020
就这么个意思

01:16:30.020 --> 01:16:31.020
当然最好了

01:16:31.020 --> 01:16:32.020
不要传两个相同的

01:16:32.020 --> 01:16:33.020
因为这里

01:16:33.020 --> 01:16:34.020
永远不会

01:16:34.020 --> 01:16:35.020
可能去比较两个相同的

01:16:35.020 --> 01:16:36.020
所以说我这里判断一下

01:16:36.020 --> 01:16:38.020
比如说node1

01:16:38.020 --> 01:16:39.020
等于那node2

01:16:39.020 --> 01:16:40.020
它还不行

01:16:42.020 --> 01:16:45.020
不能得到自己

01:16:45.020 --> 01:16:47.020
自己到自己的距离

01:16:48.020 --> 01:16:49.020
那么比较弄的这里

01:16:49.020 --> 01:16:50.020
sure

01:16:50.020 --> 01:16:51.020
跑出一个异常

01:16:51.020 --> 01:16:53.020
也就是

01:16:54.020 --> 01:16:56.020
跑异常得知道

01:16:57.020 --> 01:16:58.020
就挺知道

01:16:58.020 --> 01:16:59.020
但是这种情况

01:16:59.020 --> 01:17:00.020
也不会出现

01:17:00.020 --> 01:17:02.020
我就把它写严格一点

01:17:02.020 --> 01:17:03.020
那么现在是两个点

01:17:03.020 --> 01:17:04.020
不同的点

01:17:04.020 --> 01:17:05.020
那怎么来得到

01:17:05.020 --> 01:17:06.020
它们的

01:17:06.020 --> 01:17:07.020
自己到自己的距离

01:17:07.020 --> 01:17:08.020
现在不用去想别的

01:17:08.020 --> 01:17:09.020
就把这个函数写好

01:17:09.020 --> 01:17:11.390
怎么来得到呢

01:17:13.390 --> 01:17:14.390
我们是不是要

01:17:14.390 --> 01:17:15.390
讨历的边

01:17:15.390 --> 01:17:16.390
对不对

01:17:16.390 --> 01:17:17.390
那来吧

01:17:17.390 --> 01:17:19.390
这里面全是距离

01:17:19.390 --> 01:17:20.390
那么一说

01:17:20.390 --> 01:17:21.390
我们来这里去选择一个距离

01:17:21.390 --> 01:17:22.390
怎么来选择

01:17:24.390 --> 01:17:25.390
结点1

01:17:25.390 --> 01:17:29.660
结点1

01:17:30.660 --> 01:17:31.660
结点2

01:17:31.660 --> 01:17:33.980
看到没

01:17:33.980 --> 01:17:37.350
我用结点1

01:17:37.350 --> 01:17:39.350
在node里面的位置

01:17:39.350 --> 01:17:40.350
比如说a结点

01:17:40.350 --> 01:17:41.350
位置是多少

01:17:41.350 --> 01:17:45.180
位置是下标为0

01:17:45.180 --> 01:17:47.180
那么我就在这个数组里面取

01:17:47.180 --> 01:17:49.180
第一个数组

01:17:49.180 --> 01:17:51.180
比如说b结点

01:17:51.180 --> 01:17:53.180
下标为1

01:17:53.180 --> 01:17:55.180
我就在这个数组里面取

01:17:55.180 --> 01:17:59.150
第二个数组

01:17:59.150 --> 01:18:00.150
当然的意思了

01:18:00.150 --> 01:18:01.150
也就是说

01:18:01.150 --> 01:18:02.150
我要得到第1个结点

01:18:03.150 --> 01:18:05.150
node里面的下标

01:18:05.150 --> 01:18:10.220
是不是

01:18:10.220 --> 01:18:12.220
node里面的in这个时候

01:18:12.220 --> 01:18:15.220
node1的下标

01:18:15.220 --> 01:18:16.220
那么一说我要取

01:18:16.220 --> 01:18:17.220
这个取出来就是行号

01:18:17.220 --> 01:18:18.220
对不对

01:18:18.220 --> 01:18:20.220
二为数组里面的行号

01:18:20.220 --> 01:18:21.220
下标为你

01:18:21.220 --> 01:18:22.220
那是第1行

01:18:22.220 --> 01:18:23.220
下标为1

01:18:23.220 --> 01:18:24.220
就第2行

01:18:24.220 --> 01:18:25.220
下标为2

01:18:25.220 --> 01:18:26.220
就第3行

01:18:26.220 --> 01:18:28.220
就行号

01:18:28.220 --> 01:18:30.220
这个没问题吧

01:18:30.220 --> 01:18:31.220
好 又来

01:18:31.220 --> 01:18:33.660
行号取出来了

01:18:33.660 --> 01:18:34.660
但是这里面

01:18:34.660 --> 01:18:35.660
有那么多边

01:18:35.660 --> 01:18:36.660
哪一个呢

01:18:36.660 --> 01:18:38.660
是不是要求列呀

01:18:38.660 --> 01:18:40.660
那又来吧

01:18:40.660 --> 01:18:41.660
我第2个结点

01:18:41.660 --> 01:18:42.660
在这个数组里面

01:18:42.660 --> 01:18:43.660
是第1个

01:18:43.660 --> 01:18:44.660
那时候就第1个

01:18:44.660 --> 01:18:46.660
是不是有第1个

01:18:46.660 --> 01:18:50.100
如果说我的

01:18:50.100 --> 01:18:51.100
第2个结点

01:18:51.100 --> 01:18:52.100
在数组里面是第2个

01:18:52.100 --> 01:18:53.100
所以就第2个

01:18:53.100 --> 01:18:56.410
那是一样的

01:18:56.410 --> 01:18:58.410
node

01:18:58.410 --> 01:19:00.410
in这个时候

01:19:00.410 --> 01:19:02.410
node2

01:19:02.410 --> 01:19:03.410
所以行号列就出来了

01:19:03.410 --> 01:19:05.410
那行号列出来了

01:19:05.410 --> 01:19:06.410
那边

01:19:06.410 --> 01:19:08.410
不就是size

01:19:08.410 --> 01:19:09.410
行

01:19:09.410 --> 01:19:11.410
列

01:19:11.410 --> 01:19:12.410
不就是这个东西吗

01:19:12.410 --> 01:19:14.410
先得到这一行的数组

01:19:14.410 --> 01:19:15.410
对吧

01:19:15.410 --> 01:19:16.410
比方说先得到这一行的数组

01:19:16.410 --> 01:19:17.410
但从这个数组里面

01:19:17.410 --> 01:19:19.410
把列传进去

01:19:19.410 --> 01:19:21.410
就是得到一个边

01:19:21.410 --> 01:19:22.410
这是给distance

01:19:22.410 --> 01:19:24.410
好 咱们测试一下吧

01:19:24.410 --> 01:19:26.410
测试一下咱们测试一下什么呢

01:19:26.410 --> 01:19:29.410
测试一下node的

01:19:29.410 --> 01:19:30.410
a这个结点

01:19:30.410 --> 01:19:32.410
我看一下吧

01:19:32.410 --> 01:19:34.410
测试一下a这个结点

01:19:34.410 --> 01:19:35.410
c的距离吧

01:19:35.410 --> 01:19:37.410
a的结点到c

01:19:37.410 --> 01:19:39.410
c是第几项

01:19:39.410 --> 01:19:43.410
c是第012

01:19:43.410 --> 01:19:46.780
好 输出一下

01:19:46.780 --> 01:19:50.860
再调用一下吧

01:19:50.860 --> 01:19:52.860
node传进去

01:19:52.860 --> 01:19:54.860
size传进去

01:19:54.860 --> 01:19:58.560
好 发音

01:19:58.560 --> 01:19:59.560
我这里输出了啥

01:19:59.560 --> 01:20:00.560
这输出干嘛

01:20:00.560 --> 01:20:02.560
给distance

01:20:02.560 --> 01:20:10.450
输出一下吧

01:20:10.450 --> 01:20:11.450
好 发音

01:20:11.450 --> 01:20:12.450
输了3

01:20:12.450 --> 01:20:13.450
a到c的距离是3

01:20:13.450 --> 01:20:14.450
好 那么再来看一下

01:20:14.450 --> 01:20:15.450
再来测试一下

01:20:15.450 --> 01:20:17.450
a到d的距离

01:20:17.450 --> 01:20:19.450
a到d

01:20:19.450 --> 01:20:21.450
d的话0

01:20:21.450 --> 01:20:23.450
0 1 2 3

01:20:23.450 --> 01:20:25.450
a到d的距离

01:20:25.450 --> 01:20:26.450
发音

01:20:26.450 --> 01:20:28.450
隐飞的体无穷打

01:20:28.450 --> 01:20:29.450
那么通过这个函数

01:20:29.450 --> 01:20:30.450
能够准确地取得

01:20:30.450 --> 01:20:34.450
两个铁垫之间的距离

01:20:34.450 --> 01:20:37.270
没问题吧

01:20:37.270 --> 01:20:38.270
好

01:20:38.270 --> 01:20:40.270
然后继续啊

01:20:40.270 --> 01:20:41.270
这是一个辅助函数

01:20:41.270 --> 01:20:42.270
我们一会儿要用的

01:20:42.270 --> 01:20:43.270
先写到这儿

01:20:43.270 --> 01:20:44.270
肯定要用到这个东西

01:20:44.270 --> 01:20:45.270
肯定要得到距离

01:20:45.270 --> 01:20:46.270
好 接下来再来看

01:20:46.270 --> 01:20:47.270
我们现在要得到

01:20:47.270 --> 01:20:49.270
还要需要一些辅助函数

01:20:49.270 --> 01:20:50.270
这些辅助函数有了之后

01:20:50.270 --> 01:20:52.270
我们后面就非常简单了

01:20:52.270 --> 01:20:54.270
还有什么辅助函数呢

01:20:54.270 --> 01:20:59.290
我要得到某个点

01:20:59.290 --> 01:21:01.290
到当前部落的

01:21:01.290 --> 01:21:05.730
某个点到当前部落的

01:21:05.730 --> 01:21:07.730
最短距离

01:21:07.730 --> 01:21:10.730
以及点到部落的哪个点

01:21:10.730 --> 01:21:11.730
说起来很长啊

01:21:11.730 --> 01:21:13.730
这句话啥意思

01:21:13.730 --> 01:21:17.360
我目前的部落是a和c

01:21:17.360 --> 01:21:18.360
比方说

01:21:18.360 --> 01:21:20.360
目前的部落是a和c

01:21:20.360 --> 01:21:22.360
我要得到的是e

01:21:22.360 --> 01:21:24.800
到这个部落

01:21:24.800 --> 01:21:27.800
到这个部落a和c

01:21:27.800 --> 01:21:30.800
e到这个部落的a和c

01:21:30.800 --> 01:21:32.800
最短的距离

01:21:32.800 --> 01:21:34.800
你看是不是有两

01:21:34.800 --> 01:21:35.800
a、c、d

01:21:35.800 --> 01:21:38.800
我的目前的部落是ac、d

01:21:38.800 --> 01:21:39.800
我要得到的是

01:21:39.800 --> 01:21:41.800
某一个点

01:21:41.800 --> 01:21:43.800
到这个部落

01:21:43.800 --> 01:21:44.800
最短的那个边

01:21:44.800 --> 01:21:45.800
你看这个点

01:21:45.800 --> 01:21:46.800
是不是到这个部落

01:21:46.800 --> 01:21:47.800
有很多条边

01:21:47.800 --> 01:21:48.800
有两个条边

01:21:48.800 --> 01:21:49.800
最短的那个边

01:21:49.800 --> 01:21:50.800
以及这条边

01:21:50.800 --> 01:21:53.800
点到部落的哪个点

01:21:53.800 --> 01:21:55.800
能听懂吗

01:21:55.800 --> 01:21:56.800
能不能得到的是这条边

01:21:56.800 --> 01:21:57.800
那么就是

01:21:57.800 --> 01:22:00.800
4和点到a点

01:22:00.800 --> 01:22:01.800
然后得到这条边

01:22:01.800 --> 01:22:03.800
就是6点到d点

01:22:03.800 --> 01:22:07.430
我要得到这么一个东西

01:22:07.430 --> 01:22:08.430
所以说呢

01:22:08.430 --> 01:22:10.430
我需要这么一个函数

01:22:10.430 --> 01:22:13.430
get

01:22:13.430 --> 01:22:19.810
最小的this tense

01:22:20.810 --> 01:22:23.810
最小的距离

01:22:23.810 --> 01:22:27.700
得到漏的

01:22:27.700 --> 01:22:32.700
到部落最小的距离

01:22:32.700 --> 01:22:37.700
以及连接到部落的

01:22:37.700 --> 01:22:40.700
哪个点

01:22:40.700 --> 01:22:42.700
我再举个例子

01:22:42.700 --> 01:22:43.700
首先认取中文的目标

01:22:43.700 --> 01:22:44.700
比方说

01:22:44.700 --> 01:22:46.700
我目前的部落

01:22:46.700 --> 01:22:47.700
比方说

01:22:47.700 --> 01:22:49.700
目前的部落是ac、d

01:22:49.700 --> 01:22:52.700
那么我给它的节点是e

01:22:52.700 --> 01:22:53.700
给它的节点是e

01:22:53.700 --> 01:22:55.700
它应该返回给我一个啥呢

01:22:55.700 --> 01:22:57.700
应该给我返回这么一个东西

01:22:57.700 --> 01:22:58.700
一个对象

01:22:58.700 --> 01:22:59.700
因为它给我两个

01:22:59.700 --> 01:23:00.700
返回两个东西

01:23:00.700 --> 01:23:01.700
一个对象

01:23:01.700 --> 01:23:03.700
对象是什么呢

01:23:03.700 --> 01:23:05.700
从1点出发

01:23:05.700 --> 01:23:07.700
从1点出发

01:23:07.700 --> 01:23:08.700
应该点到哪个点呢

01:23:08.700 --> 01:23:10.700
点到a点

01:23:10.700 --> 01:23:11.700
什么意思吧

01:23:11.700 --> 01:23:12.700
从1点出发

01:23:12.700 --> 01:23:13.700
应该点到a点

01:23:13.700 --> 01:23:16.700
然后呢

01:23:16.700 --> 01:23:17.700
距离是多少呢

01:23:17.700 --> 01:23:18.700
距离是4

01:23:18.700 --> 01:23:21.200
距离是5

01:23:21.200 --> 01:23:22.200
它不能给我说

01:23:22.200 --> 01:23:23.200
1点出发连到d

01:23:23.200 --> 01:23:24.200
d点

01:23:24.200 --> 01:23:25.200
d点距离是6

01:23:25.200 --> 01:23:26.200
因为距离一步是最短的

01:23:26.200 --> 01:23:28.200
原来意思吧

01:23:28.200 --> 01:23:33.240
那么这个玩意怎么做

01:23:33.240 --> 01:23:35.240
这个玩意其实并不复杂

01:23:35.240 --> 01:23:36.240
并不复杂

01:23:36.240 --> 01:23:37.240
真不复杂

01:23:37.240 --> 01:23:38.240
最终就要得到的

01:23:38.240 --> 01:23:39.240
不就是个对象嘛

01:23:39.240 --> 01:23:40.240
对不对

01:23:40.240 --> 01:23:41.240
对到就是个对象嘛

01:23:41.240 --> 01:23:42.240
从哪个点出发

01:23:42.240 --> 01:23:43.240
肯定是从这个漏的

01:23:43.240 --> 01:23:44.240
这个点出发

01:23:44.240 --> 01:23:45.240
对不对

01:23:45.240 --> 01:23:46.240
从它这个点出发

01:23:46.240 --> 01:23:47.240
到哪个点

01:23:47.240 --> 01:23:48.240
现在我也不知道

01:23:48.240 --> 01:23:49.240
到哪个点

01:23:49.240 --> 01:23:50.240
那么距离是多少

01:23:50.240 --> 01:23:51.240
我也不知道

01:23:52.240 --> 01:23:53.240
假设就到不了

01:23:53.240 --> 01:23:55.240
先给它一个默认值

01:23:55.240 --> 01:23:56.240
然后呢

01:23:56.240 --> 01:23:57.240
我就把这个点

01:23:57.240 --> 01:23:58.240
一次看这个点

01:23:58.240 --> 01:23:59.240
到部落

01:23:59.240 --> 01:24:00.240
每一个点的距离

01:24:00.240 --> 01:24:01.240
我看这个点

01:24:01.240 --> 01:24:02.240
到a的距离

01:24:02.240 --> 01:24:03.240
看这个点到c的距离

01:24:03.240 --> 01:24:04.240
看这个点到d的距离

01:24:04.240 --> 01:24:05.240
是不是求这个最短

01:24:05.240 --> 01:24:06.240
就完事了

01:24:06.240 --> 01:24:08.240
其实就是个求追小值

01:24:08.240 --> 01:24:09.240
所以说我这里

01:24:09.240 --> 01:24:10.240
是不是要循环部落

01:24:10.240 --> 01:24:14.790
现在我们是不是

01:24:14.790 --> 01:24:16.790
要循环部落啊

01:24:16.790 --> 01:24:17.790
好

01:24:17.790 --> 01:24:18.790
那么现在我们就循环

01:24:18.790 --> 01:24:19.790
副循环

01:24:19.790 --> 01:24:20.790
i等于0

01:24:20.790 --> 01:24:22.790
i小于hold

01:24:23.790 --> 01:24:25.790
部落里面不是有很多点吗

01:24:25.790 --> 01:24:27.790
小于部落

01:24:27.790 --> 01:24:29.790
循环部落

01:24:29.790 --> 01:24:30.790
把这个点

01:24:30.790 --> 01:24:31.790
把这个点

01:24:31.790 --> 01:24:32.790
一次看一下

01:24:32.790 --> 01:24:33.790
到部落

01:24:33.790 --> 01:24:34.790
每一个点的距离

01:24:34.790 --> 01:24:35.790
是不是可以拿到的距离

01:24:35.790 --> 01:24:36.790
this

01:24:36.790 --> 01:24:37.790
刚才是不是有个函数

01:24:37.790 --> 01:24:38.790
this sense

01:24:38.790 --> 01:24:39.790
可以用上来

01:24:39.790 --> 01:24:41.790
哪个点到哪个点

01:24:41.790 --> 01:24:42.790
漏的这个点

01:24:42.790 --> 01:24:44.790
到部落的这个点

01:24:46.790 --> 01:24:47.790
是不是

01:24:47.790 --> 01:24:48.790
我们看一下

01:24:48.790 --> 01:24:49.790
这个点

01:24:49.790 --> 01:24:50.790
到部落的这个点

01:24:50.790 --> 01:24:51.790
部落有很多点

01:24:52.790 --> 01:24:53.790
把到部落的

01:24:53.790 --> 01:24:54.790
每一个点的距离

01:24:54.790 --> 01:24:55.790
拿出来

01:24:55.790 --> 01:24:56.790
拿到这个距离

01:24:56.790 --> 01:24:57.790
看一下这个距离

01:24:57.790 --> 01:24:58.790
是不是小于这个

01:24:58.790 --> 01:24:59.790
小于它是不是

01:24:59.790 --> 01:25:00.790
有更小的情况

01:25:00.790 --> 01:25:02.790
如果说这个this

01:25:02.790 --> 01:25:04.790
小于到result

01:25:04.790 --> 01:25:05.790
this

01:25:06.790 --> 01:25:08.790
是不是有更小的距离

01:25:08.790 --> 01:25:10.790
有更小的距离

01:25:10.790 --> 01:25:11.790
就要更新

01:25:11.790 --> 01:25:12.790
更新这个result

01:25:12.790 --> 01:25:13.790
result了什么

01:25:13.790 --> 01:25:14.790
result了 to

01:25:14.790 --> 01:25:15.790
到哪个点呢

01:25:15.790 --> 01:25:16.790
到哪个点

01:25:16.790 --> 01:25:17.790
部落了这个点

01:25:17.790 --> 01:25:18.790
然后我们循环的

01:25:18.790 --> 01:25:19.790
首先循环 d

01:25:19.790 --> 01:25:20.790
比较多

01:25:20.790 --> 01:25:21.790
d 肯定是

01:25:21.790 --> 01:25:22.790
到于距离是6

01:25:22.790 --> 01:25:23.790
6要比什么

01:25:23.790 --> 01:25:24.790
你飞到底下

01:25:24.790 --> 01:25:25.790
好那么我就要更新

01:25:25.790 --> 01:25:27.790
e 可以连到地点

01:25:27.790 --> 01:25:28.790
距离是多少呢

01:25:28.790 --> 01:25:29.790
result

01:25:29.790 --> 01:25:31.790
距离是6

01:25:31.790 --> 01:25:32.790
对

01:25:32.790 --> 01:25:33.790
就是d

01:25:34.790 --> 01:25:35.790
好的一会许循环 c

01:25:35.790 --> 01:25:36.790
sc 就是无穷大了

01:25:36.790 --> 01:25:37.790
无穷大肯定不满足

01:25:37.790 --> 01:25:38.790
肯定比这个6小

01:25:38.790 --> 01:25:39.790
6大

01:25:39.790 --> 01:25:40.790
就是说不看

01:25:40.790 --> 01:25:41.790
然后一会许循环 a

01:25:41.790 --> 01:25:42.790
发现 a

01:25:42.790 --> 01:25:44.790
这里是4

01:25:44.790 --> 01:25:45.790
比6小

01:25:45.790 --> 01:25:46.790
比之前那个

01:25:46.790 --> 01:25:47.790
d 是还要小

01:25:47.790 --> 01:25:49.790
于是又更新

01:25:49.790 --> 01:25:50.790
明白吧

01:25:50.790 --> 01:25:51.790
那么这样的于循环

01:25:51.790 --> 01:25:52.790
一结束是不是

01:25:52.790 --> 01:25:53.790
这个result

01:25:53.790 --> 01:25:56.300
就是我们想要的值

01:25:56.300 --> 01:25:57.300
就是我们想要的值了

01:25:58.300 --> 01:25:59.300
好那么讲

01:25:59.300 --> 01:26:00.300
后面来测试一下

01:26:00.300 --> 01:26:01.300
测试一下这个

01:26:01.300 --> 01:26:02.300
测试一下这个函数

01:26:02.300 --> 01:26:03.300
比方说我一开始有

01:26:03.300 --> 01:26:04.300
acd

01:26:04.300 --> 01:26:06.300
一开始有 a

01:26:06.300 --> 01:26:08.300
bcd

01:26:08.300 --> 01:26:10.300
有这么三个点

01:26:10.300 --> 01:26:11.300
假设

01:26:11.300 --> 01:26:12.300
一开始部落

01:26:12.300 --> 01:26:13.300
不可能有这么多

01:26:13.300 --> 01:26:14.300
一开始部落

01:26:14.300 --> 01:26:15.300
就有这些点

01:26:15.300 --> 01:26:16.300
那么现在呢

01:26:16.300 --> 01:26:17.300
我们来看一下

01:26:17.300 --> 01:26:18.300
e 这个点

01:26:18.300 --> 01:26:19.300
到这个部落的

01:26:19.300 --> 01:26:20.300
最小距离

01:26:20.300 --> 01:26:21.300
距离的情况

01:26:21.300 --> 01:26:22.300
出出

01:26:22.300 --> 01:26:24.300
get me distance

01:26:24.300 --> 01:26:27.250
什么呢

01:26:27.250 --> 01:26:28.250
e 这个点

01:26:28.250 --> 01:26:29.250
low 至 4

01:26:29.250 --> 01:26:30.250
最后一个点

01:26:31.250 --> 01:26:32.250
到这个部落的

01:26:32.250 --> 01:26:33.250
情况

01:26:35.250 --> 01:26:36.250
看一下

01:26:36.250 --> 01:26:38.250
你看得到结果就是

01:26:38.250 --> 01:26:39.250
e 这个点

01:26:39.250 --> 01:26:40.250
要连到这个部落的话

01:26:40.250 --> 01:26:41.250
距离就是4

01:26:41.250 --> 01:26:42.250
从哪个点呢

01:26:42.250 --> 01:26:43.250
从e 连到谁

01:26:43.250 --> 01:26:44.250
连到 a

01:26:46.250 --> 01:26:47.250
你可以多去测试一下

01:26:47.250 --> 01:26:48.250
反复测试一下

01:26:48.250 --> 01:26:49.250
保证这个函数没问题

01:26:49.250 --> 01:26:50.250
没问题

01:26:50.250 --> 01:26:51.250
我们再写下一个

01:26:51.250 --> 01:26:52.250
你不要写下一个的时候

01:26:52.250 --> 01:26:53.250
又在脑袋里面

01:26:53.250 --> 01:26:54.250
又在想之前那个函数

01:26:54.250 --> 01:26:55.250
那你就脑袋里面

01:26:55.250 --> 01:26:56.250
你写完一个

01:26:56.250 --> 01:26:57.250
一定要反复

01:26:57.250 --> 01:26:58.250
你如果觉得担心

01:26:58.250 --> 01:26:59.250
你就反复测试

01:26:59.250 --> 01:27:00.250
测出来没问题

01:27:00.250 --> 01:27:01.250
OK

01:27:02.250 --> 01:27:03.250
就一旦OK了

01:27:03.250 --> 01:27:04.250
就不要去看了

01:27:04.250 --> 01:27:05.250
不要去管了

01:27:05.250 --> 01:27:06.250
不然脑袋里面

01:27:06.250 --> 01:27:07.250
永远都是云的

01:27:08.250 --> 01:27:09.250
这个函数写好了

01:27:09.250 --> 01:27:10.250
写好了过

01:27:10.250 --> 01:27:11.250
那么假设这个函数

01:27:11.250 --> 01:27:12.250
就是一开始

01:27:12.250 --> 01:27:13.250
系统就跟我们提供的

01:27:13.250 --> 01:27:14.250
浏览器就跟我们提供的函数

01:27:14.250 --> 01:27:15.250
已经写好了

01:27:15.250 --> 01:27:16.250
那接下来

01:27:17.250 --> 01:27:19.250
函数要最后一个函数

01:27:19.250 --> 01:27:21.250
最后一个函数写出来就完了

01:27:21.250 --> 01:27:22.250
这事情就结束了

01:27:24.750 --> 01:27:25.750
什么函数呢

01:27:26.750 --> 01:27:29.750
connect to hold

01:27:29.750 --> 01:27:38.210
啥意思呢

01:27:40.210 --> 01:27:41.210
啥意思呢

01:27:41.210 --> 01:27:42.210
从

01:27:43.210 --> 01:27:45.210
剩下的

01:27:45.210 --> 01:27:47.210
从非部落

01:27:48.210 --> 01:27:49.210
节点中

01:27:49.210 --> 01:27:54.780
找到一个最小的

01:27:54.780 --> 01:27:56.780
或者叫

01:27:57.780 --> 01:27:58.780
get

01:27:59.780 --> 01:28:00.780
就这样

01:28:00.780 --> 01:28:02.780
找到一个最小最短

01:28:03.780 --> 01:28:04.780
最短

01:28:05.780 --> 01:28:06.780
距离到部落最短

01:28:06.780 --> 01:28:07.780
距离的节点

01:28:08.780 --> 01:28:10.780
连接到部落

01:28:17.120 --> 01:28:18.120
比方说部落目前是这个样子

01:28:20.120 --> 01:28:21.120
我就要看我到底

01:28:21.120 --> 01:28:22.120
目前需要去连异

01:28:22.120 --> 01:28:23.120
还是连避

01:28:23.120 --> 01:28:24.120
就这个意思

01:28:25.120 --> 01:28:26.120
我就要看

01:28:26.120 --> 01:28:27.120
到底是连异还是连避

01:28:28.120 --> 01:28:29.120
那么已经在部落中

01:28:29.120 --> 01:28:30.120
我就不看了

01:28:30.120 --> 01:28:31.120
所以说这里呢

01:28:31.120 --> 01:28:32.120
是不是在循环

01:28:32.120 --> 01:28:33.120
循环所有的节点

01:28:33.120 --> 01:28:34.120
i的连

01:28:34.120 --> 01:28:35.120
i小渔

01:28:35.120 --> 01:28:36.120
node

01:28:36.120 --> 01:28:37.120
lens

01:28:37.120 --> 01:28:39.120
i加加

01:28:39.120 --> 01:28:40.120
每次循环

01:28:40.120 --> 01:28:41.120
我至少可以写出这样的代法

01:28:41.120 --> 01:28:43.750
先把一个节点找到

01:28:43.750 --> 01:28:44.750
找到一个节点

01:28:44.750 --> 01:28:45.750
然后呢

01:28:45.750 --> 01:28:47.750
这个部落里面是可以

01:28:47.750 --> 01:28:51.130
它不包含这个节点的

01:28:51.130 --> 01:28:53.130
部落里面是不包含节点的

01:28:53.130 --> 01:28:55.500
大家不要担心

01:28:55.500 --> 01:28:56.500
你们过两天考试的话

01:28:56.500 --> 01:28:57.500
不会考这么难

01:28:57.500 --> 01:28:58.500
考试的话

01:28:58.500 --> 01:28:59.500
你只要听到课

01:28:59.500 --> 01:29:00.500
你只要有课堂的笔记

01:29:00.500 --> 01:29:01.500
换句话说

01:29:01.500 --> 01:29:02.500
说的再直白点

01:29:02.500 --> 01:29:03.500
你只要有课堂的笔记

01:29:03.500 --> 01:29:04.500
就OK

01:29:04.500 --> 01:29:08.030
只要部落中

01:29:08.030 --> 01:29:09.030
不包含节点

01:29:09.030 --> 01:29:10.030
是不是非部落的

01:29:10.030 --> 01:29:11.030
不在部落中的节点

01:29:11.030 --> 01:29:14.030
不在部落中的节点

01:29:14.030 --> 01:29:15.030
那么现在问题就是

01:29:15.030 --> 01:29:16.030
我到底要连哪一个

01:29:16.030 --> 01:29:18.030
有很多的节点都不在部落中

01:29:18.030 --> 01:29:19.030
比方有e不在部落中

01:29:19.030 --> 01:29:20.030
b也不在部落中

01:29:20.030 --> 01:29:22.030
我到底要连哪一个

01:29:22.030 --> 01:29:23.030
就要看距离啊

01:29:23.030 --> 01:29:25.030
e到部落的最短距离是4

01:29:25.030 --> 01:29:27.030
b到部落的最短距离也是4

01:29:27.030 --> 01:29:28.030
要看哪连哪一个

01:29:28.030 --> 01:29:29.030
连最小的

01:29:29.030 --> 01:29:30.030
这里的情况呢

01:29:30.030 --> 01:29:31.030
还不是很好

01:29:31.030 --> 01:29:32.030
以后再重新举个例子

01:29:32.030 --> 01:29:36.030
比方说我的部落是这个样子

01:29:36.030 --> 01:29:39.430
部落是这个样子

01:29:39.430 --> 01:29:40.430
那么现在有

01:29:40.430 --> 01:29:41.430
b

01:29:41.430 --> 01:29:43.430
三个节点都不在部落里边

01:29:43.430 --> 01:29:46.450
对不对

01:29:46.450 --> 01:29:48.450
有三个节点都不在部落里边

01:29:48.450 --> 01:29:50.450
那么现在我到底要连哪一个的问题

01:29:50.450 --> 01:29:53.450
懂了意思吧

01:29:53.450 --> 01:29:55.450
那么到底连哪一个的问题

01:29:55.450 --> 01:29:56.450
那么是不是要看

01:29:56.450 --> 01:29:57.450
找最短的

01:29:57.450 --> 01:29:58.450
那又是个求聚小职

01:29:58.450 --> 01:30:00.450
那又来了

01:30:00.450 --> 01:30:01.450
又是一个绿刀子

01:30:01.450 --> 01:30:02.450
求聚小职

01:30:02.450 --> 01:30:04.450
从哪个节点呢

01:30:04.450 --> 01:30:06.450
我也不知道从哪个节点

01:30:06.450 --> 01:30:07.450
到哪个节点呢

01:30:07.450 --> 01:30:08.450
我也不知道到哪个节点

01:30:08.450 --> 01:30:09.450
距离呢

01:30:09.450 --> 01:30:11.450
我也不知道距离

01:30:11.450 --> 01:30:13.450
显写一个默认情况

01:30:13.450 --> 01:30:15.450
那么现在的看

01:30:15.450 --> 01:30:17.450
这个节点不在部落中

01:30:17.450 --> 01:30:19.450
比方说我循环到

01:30:19.450 --> 01:30:20.450
在部落中不看

01:30:20.450 --> 01:30:21.450
c到在部落中不看

01:30:21.450 --> 01:30:22.450
e

01:30:22.450 --> 01:30:23.450
e不在部落中

01:30:23.450 --> 01:30:25.450
不在部落中怎么办呢

01:30:25.450 --> 01:30:26.450
我说利用刚才的一个方法

01:30:26.450 --> 01:30:28.450
get me distance

01:30:28.450 --> 01:30:30.450
把这个节点传进去

01:30:30.450 --> 01:30:31.450
看一下这个节点

01:30:31.450 --> 01:30:34.450
到部落的距离的情况

01:30:34.450 --> 01:30:39.460
就是ctoh

01:30:39.460 --> 01:30:41.460
情况

01:30:43.840 --> 01:30:46.840
看一下这个点

01:30:46.840 --> 01:30:48.840
到部落的情况

01:30:48.840 --> 01:30:49.840
那么这个情况里边

01:30:49.840 --> 01:30:50.840
我们刚才不是测试过吗

01:30:50.840 --> 01:30:52.840
有是不是有三个属性

01:30:52.840 --> 01:30:53.840
对不对有三个属性

01:30:53.840 --> 01:30:54.840
那么看一下

01:30:54.840 --> 01:30:55.840
关键是看距离

01:30:55.840 --> 01:30:57.840
如果说info的距离

01:30:57.840 --> 01:30:58.840
比方说e这个点的

01:30:58.840 --> 01:30:59.840
到部落的距离

01:30:59.840 --> 01:31:00.840
比方说先看的是什么

01:31:00.840 --> 01:31:01.840
比方说先看的是e嘛

01:31:01.840 --> 01:31:02.840
e这个点到部落的

01:31:02.840 --> 01:31:04.840
最短距离

01:31:04.840 --> 01:31:06.840
是不是一个属性叫dc

01:31:06.840 --> 01:31:07.840
对不对

01:31:07.840 --> 01:31:09.840
如果说小渔到目前的dc

01:31:09.840 --> 01:31:11.840
是不是就更好的情况

01:31:11.840 --> 01:31:12.840
这个点比刚才的

01:31:12.840 --> 01:31:14.840
比这种情况好多了

01:31:14.840 --> 01:31:15.840
对吧

01:31:15.840 --> 01:31:17.840
那么我们就把这个情况来更新

01:31:17.840 --> 01:31:18.840
result的什么呢

01:31:18.840 --> 01:31:19.840
from

01:31:19.840 --> 01:31:20.840
等于什么呢

01:31:20.840 --> 01:31:22.840
info的from

01:31:22.840 --> 01:31:23.840
result的to

01:31:23.840 --> 01:31:25.840
等于info的to

01:31:25.840 --> 01:31:27.840
result的什么呢

01:31:27.840 --> 01:31:28.840
dc

01:31:28.840 --> 01:31:32.840
等于info的dc

01:31:32.840 --> 01:31:34.840
或者你把result等于info就完了

01:31:34.840 --> 01:31:36.840
那现在是行政要干嘛的

01:31:36.840 --> 01:31:38.840
result等于info就完事了

01:31:38.840 --> 01:31:40.840
result你开始为闹了

01:31:41.840 --> 01:31:43.840
开始为闹了

01:31:43.840 --> 01:31:44.840
不行

01:31:44.840 --> 01:31:46.840
因为这里边点了out的话

01:31:46.840 --> 01:31:47.840
这要保存

01:31:47.840 --> 01:31:48.840
就这样吧

01:31:48.840 --> 01:31:50.840
把result重新复作为info

01:31:50.840 --> 01:31:51.840
对不对

01:31:51.840 --> 01:31:53.840
总归就是早税小值

01:31:53.840 --> 01:31:55.840
这里就是发现了

01:31:55.840 --> 01:31:58.840
有更短的节点

01:31:58.840 --> 01:31:59.840
这个节点更新到过后

01:31:59.840 --> 01:32:00.840
下一次循环

01:32:00.840 --> 01:32:01.840
表现循环到d

01:32:01.840 --> 01:32:02.840
情况更好

01:32:02.840 --> 01:32:03.840
d的情况是

01:32:03.840 --> 01:32:04.840
它的距离是3

01:32:04.840 --> 01:32:06.840
比刚才的4有好多了

01:32:06.840 --> 01:32:07.840
那么那就更新

01:32:07.840 --> 01:32:08.840
更新这个result

01:32:08.840 --> 01:32:09.840
循环一结束

01:32:09.840 --> 01:32:12.840
是不是result一定是最优的点

01:32:12.840 --> 01:32:17.840
result一定是最优的点

01:32:17.840 --> 01:32:18.840
对不对

01:32:18.840 --> 01:32:20.840
一定是最优的点

01:32:20.840 --> 01:32:21.840
好

01:32:21.840 --> 01:32:22.840
那么如果说result早出来

01:32:22.840 --> 01:32:23.840
过来不要早出来d

01:32:23.840 --> 01:32:24.840
最优的点

01:32:24.840 --> 01:32:25.840
那怎么办

01:32:25.840 --> 01:32:28.840
是不是把d跟谁相连

01:32:28.840 --> 01:32:31.840
就是把result里边from和to相连

01:32:31.840 --> 01:32:32.840
对不对

01:32:32.840 --> 01:32:33.840
不就是把from和to相连吧

01:32:33.840 --> 01:32:34.840
从这个点到这个点

01:32:34.840 --> 01:32:37.840
好那么就是result比from

01:32:37.840 --> 01:32:38.840
这个节点的neighbors

01:32:38.840 --> 01:32:40.840
它的邻居里边要加上什么的

01:32:40.840 --> 01:32:44.730
加上result to

01:32:44.730 --> 01:32:46.730
要把对相用的很熟

01:32:46.730 --> 01:32:48.730
就是json的对相要用的很熟

01:32:48.730 --> 01:32:51.730
这个表达是都看不懂

01:32:51.730 --> 01:32:52.730
这里全是对象对吧

01:32:52.730 --> 01:32:54.730
from是某一个节点对象

01:32:54.730 --> 01:32:56.730
节点对象里面不有邻居吗

01:32:56.730 --> 01:32:58.730
把这个点from这个点

01:32:58.730 --> 01:33:00.730
它的邻居里边要添加什么

01:33:00.730 --> 01:33:02.730
添加to

01:33:02.730 --> 01:33:03.730
to这个点

01:33:03.730 --> 01:33:04.730
那么同样的

01:33:04.730 --> 01:33:06.730
反过来也是一样result to

01:33:06.730 --> 01:33:07.730
这个点的邻居里边

01:33:07.730 --> 01:33:08.730
要添加什么from

01:33:13.920 --> 01:33:14.920
这样子呢

01:33:14.920 --> 01:33:15.920
他们相互就为邻居了

01:33:15.920 --> 01:33:16.920
是不是把连起来了

01:33:16.920 --> 01:33:18.920
同时他们要加入部落

01:33:18.920 --> 01:33:20.920
加入部落

01:33:20.920 --> 01:33:22.920
hold

01:33:22.920 --> 01:33:24.920
push

01:33:24.920 --> 01:33:26.920
result from

01:33:26.920 --> 01:33:27.920
from一开始

01:33:27.920 --> 01:33:28.920
to这个点

01:33:28.920 --> 01:33:29.920
本来就是部落的

01:33:29.920 --> 01:33:30.920
from这个点的一开始

01:33:30.920 --> 01:33:31.920
不是部落的

01:33:31.920 --> 01:33:32.920
把加入部落

01:33:32.920 --> 01:33:33.920
那么我们要保证

01:33:33.920 --> 01:33:34.920
只要一调这个方法

01:33:34.920 --> 01:33:35.920
部落里面就多一项

01:33:35.920 --> 01:33:36.920
而且就连的

01:33:36.920 --> 01:33:37.920
连的非常好

01:33:37.920 --> 01:33:38.920
我们现在调一次

01:33:38.920 --> 01:33:40.920
调用一次的看一下

01:33:40.920 --> 01:33:41.920
调用一次过后

01:33:41.920 --> 01:33:43.920
我们来输出这个hold

01:33:43.920 --> 01:33:44.920
一开始应该是

01:33:44.920 --> 01:33:45.920
一开始正确的结果

01:33:45.920 --> 01:33:46.920
应该是a和c

01:33:46.920 --> 01:33:48.920
我写多了

01:33:48.920 --> 01:33:49.920
一开始只有一个

01:33:49.920 --> 01:33:51.920
部落一开始只有一个

01:33:51.920 --> 01:33:53.920
应该是a和c相连

01:33:53.920 --> 01:33:54.920
看是不是a和c

01:33:54.920 --> 01:33:56.920
a是不是连到c了

01:33:56.920 --> 01:33:57.920
同样的道理

01:33:57.920 --> 01:34:00.920
c是不是有连到a了

01:34:00.920 --> 01:34:01.920
A和c

01:34:01.920 --> 01:34:03.920
那我再调用一次

01:34:03.920 --> 01:34:05.920
再调用一次

01:34:05.920 --> 01:34:07.920
那就应该是连三个acd

01:34:07.920 --> 01:34:09.920
看一下是不是

01:34:09.920 --> 01:34:11.920
所以acd

01:34:11.920 --> 01:34:13.920
连起来

01:34:13.920 --> 01:34:14.920
c跟两个相连

01:34:14.920 --> 01:34:15.920
a和d

01:34:15.920 --> 01:34:16.920
你看c跟两个相连

01:34:16.920 --> 01:34:17.920
a和d

01:34:17.920 --> 01:34:21.450
你会发现

01:34:21.450 --> 01:34:23.450
程序都写完了

01:34:23.450 --> 01:34:28.170
剩下的事情

01:34:28.170 --> 01:34:29.170
你莫名其妙了

01:34:29.170 --> 01:34:30.170
有的时候

01:34:30.170 --> 01:34:31.170
遇到一些复杂的问题

01:34:31.170 --> 01:34:32.170
我们就拆解

01:34:32.170 --> 01:34:33.170
拆解

01:34:33.170 --> 01:34:34.170
拆解成一些小的问题

01:34:34.170 --> 01:34:35.170
写着写着

01:34:35.170 --> 01:34:36.170
我都不知道为什么

01:34:36.170 --> 01:34:38.670
就突然就写完了

01:34:38.670 --> 01:34:40.670
你看是不是写完了

01:34:40.670 --> 01:34:41.670
只要部落里面

01:34:41.670 --> 01:34:42.670
点不够

01:34:42.670 --> 01:34:43.670
就继续连一遍

01:34:43.670 --> 01:34:44.670
连一次不就多一个点

01:34:44.670 --> 01:34:45.670
就看点够不够

01:34:45.670 --> 01:34:46.670
继续连一遍

01:34:46.670 --> 01:34:48.670
连一遍连完了

01:34:48.670 --> 01:34:50.670
普林木算法就出来了

01:34:50.670 --> 01:34:51.670
好

01:34:51.670 --> 01:34:52.670
那么调用

01:34:52.670 --> 01:34:53.670
我们看一下

01:34:53.670 --> 01:34:54.670
调用完了普林木算法

01:34:54.670 --> 01:34:55.670
然后我们来看一下

01:34:55.670 --> 01:34:56.670
这个节点

01:34:56.670 --> 01:34:57.670
漏字

01:34:57.670 --> 01:34:58.670
你不要说

01:34:58.670 --> 01:34:59.670
首先找一个a节点

01:34:59.670 --> 01:35:00.670
a节点应该连到什么

01:35:00.670 --> 01:35:01.670
它连到谁

01:35:01.670 --> 01:35:03.670
连到c和e

01:35:03.670 --> 01:35:08.140
看一下是不是最小的

01:35:08.140 --> 01:35:09.140
a节点

01:35:09.140 --> 01:35:16.020
连到c和e

01:35:16.020 --> 01:35:17.020
好

01:35:17.020 --> 01:35:18.020
又来

01:35:18.020 --> 01:35:19.020
c节点

01:35:19.020 --> 01:35:21.020
是adb

01:35:21.020 --> 01:35:22.020
c节点

01:35:22.020 --> 01:35:28.020
连到的是adb

01:35:28.020 --> 01:35:29.020
所以是最短的

01:35:29.020 --> 01:35:30.020
对吧

01:35:30.020 --> 01:35:31.020
e和d

01:35:31.020 --> 01:35:32.020
要不要相连

01:35:32.020 --> 01:35:33.020
不相连

01:35:33.020 --> 01:35:34.020
看一下e和d

01:35:34.020 --> 01:35:35.020
d有没有连翼呢

01:35:35.020 --> 01:35:36.020
没有

01:35:36.020 --> 01:35:38.020
d只有连c

01:35:38.020 --> 01:35:41.020
d只有连c

01:35:41.020 --> 01:35:42.020
这是普林木算法

01:35:42.020 --> 01:35:45.340
算法就是这样的结果

01:35:45.340 --> 01:35:46.340
大概意思就是说

01:35:46.340 --> 01:35:47.340
以后

01:35:47.340 --> 01:35:51.290
同学们遇到那种复杂问题

01:35:51.290 --> 01:35:53.290
都要回去拆解

01:35:53.290 --> 01:35:54.290
哪怕一开始

01:35:54.290 --> 01:35:55.290
你自己去拆解不了

01:35:55.290 --> 01:35:56.290
那么老师告诉你

01:35:56.290 --> 01:35:57.290
失路过后

01:35:57.290 --> 01:35:58.290
要跟着老师的失路

01:35:58.290 --> 01:36:00.290
把这东西一点点去拆解

01:36:00.290 --> 01:36:01.290
你不拆解的话

01:36:01.290 --> 01:36:02.290
问题太复杂了

01:36:02.290 --> 01:36:03.290
你要先把

01:36:03.290 --> 01:36:04.290
揉住一坨去除

01:36:04.290 --> 01:36:05.290
那肯定有写的

01:36:05.290 --> 01:36:07.290
写的大码一是难看

01:36:07.290 --> 01:36:08.290
二是那里写的

01:36:08.290 --> 01:36:11.290
都不知道自己在写啥了

01:36:11.290 --> 01:36:12.290
好了

01:36:12.290 --> 01:36:13.290
今天有点困难

01:36:13.290 --> 01:36:14.290
是吧

01:36:14.290 --> 01:36:15.290
先把妈妈去消化吧

01:36:15.290 --> 01:36:16.290
因为

01:36:16.290 --> 01:36:17.290
同学们

01:36:17.290 --> 01:36:18.290
基础有高有低

01:36:18.290 --> 01:36:20.290
可能有些人还能听懂

01:36:20.290 --> 01:36:21.290
大妈俩少了

01:36:21.290 --> 01:36:23.290
之前没有系统的学习过

01:36:23.290 --> 01:36:25.290
林林商商学到一点东西

01:36:25.290 --> 01:36:26.290
就学起来

01:36:26.290 --> 01:36:27.290
肯定有点痛苦

01:36:27.290 --> 01:36:28.290
那么算法这个东西

01:36:28.290 --> 01:36:30.290
大家也不用太有心理压力

01:36:30.290 --> 01:36:31.290
为什么呢

01:36:31.290 --> 01:36:33.290
因为如果说你不去

01:36:33.290 --> 01:36:35.290
你不就准备去大厂

01:36:35.290 --> 01:36:36.290
也不准备去

01:36:36.290 --> 01:36:37.290
深入到原码去研究

01:36:37.290 --> 01:36:38.290
一时半会

01:36:38.290 --> 01:36:40.290
现在还没有这个打算

01:36:40.290 --> 01:36:41.290
将来不去大厂

01:36:41.290 --> 01:36:42.290
也不打算

01:36:42.290 --> 01:36:44.290
深入到原码几倍去研究

01:36:44.290 --> 01:36:46.290
也没有打算将来成为大神

01:36:46.290 --> 01:36:48.290
我们先入门

01:36:48.290 --> 01:36:49.290
先就业

01:36:49.290 --> 01:36:51.290
它可以不接触算法

01:36:51.290 --> 01:36:53.290
但是我觉得算法也是一个

01:36:53.290 --> 01:36:55.290
平时没事的训练训练

01:36:55.290 --> 01:36:57.290
训练一下这个思维

01:36:57.290 --> 01:36:59.290
对自己提升程序能力

01:36:59.290 --> 01:37:00.290
编程能力还是很有帮助的

01:37:00.290 --> 01:37:02.290
哪怕你不去进大厂

01:37:02.290 --> 01:37:03.290
你提升一下编程能力

01:37:03.290 --> 01:37:05.290
对你绝对是有帮助的

01:37:05.290 --> 01:37:07.290
因为你平时做一些小的效果

01:37:07.290 --> 01:37:09.290
其实也是在锻炼编程能力

01:37:09.290 --> 01:37:10.290
只不过锻炼起来比较慢

01:37:10.290 --> 01:37:13.290
算法是一种集中训练

01:37:13.290 --> 01:37:15.290
它是见效比较快一点

01:37:15.290 --> 01:37:16.290
但是肯定要痛苦

01:37:16.290 --> 01:37:17.290
要痛苦一点

01:37:18.290 --> 01:37:20.290
好了

01:37:20.290 --> 01:37:22.290
今天时间也不早了

01:37:22.290 --> 01:37:24.290
今天我脱了一块糖

01:37:24.290 --> 01:37:25.290
下去慢慢消化吧

01:37:25.290 --> 01:37:27.290
今天就先把人家打击到这

01:37:27.290 --> 01:37:30.290
接下来就是交给薛老师

01:37:30.290 --> 01:37:31.290
薛老师在吧

