WEBVTT

00:00.000 --> 00:12.000
今天我们基本上是整个课就全部写代吧 啊 全是干货了啊 大家注意集中体

00:12.000 --> 00:20.000
集中经历听啊 首先我要说第一个点的话 就是咱们学习程序做开发

00:20.000 --> 00:30.000
你记住了 无论是什么时候 无论你在哪里学习 你是自学也好 跟着老师学也好 一定要去多想多念

00:30.000 --> 00:39.000
这对你的提升是非常有帮助的 如果说你听完了课 你不去写的话 那这个课可能是等于白听了 听到没有任何意义的

00:39.000 --> 00:47.000
一定要自己去想 自己去写 昨天给他留了一道题啊 这道题呢 我不管你写没写出来

00:47.000 --> 01:02.000
一定要去想 一定要去写 哪怕你写不出来 但是你至少比较多 我花了一个小时 花了一个半小时 在上面去想 去琢磨 去写 一定要比没有去想 没有去写 要好太多太多了

01:02.000 --> 01:09.000
如果说你想了 你去写了 你去尝试了 你再来听老师讲 你的社会的体会是完全不一样的

01:10.000 --> 01:20.000
所以老师给大家留了题啊 包括后边也不一定有题 但是每天的课堂上的这些练习 老师写的代码 一定要去跟着写一遍 这对你们才有收获

01:20.000 --> 01:26.000
因为我们做这个解讯营的 最重要的目的呢 是希望能够帮助到大家 这是最重要的

01:26.000 --> 01:34.000
好 那我说一下 昨天最后一道题啊 就是删除节点 这个东西怪我 我没有给大家说得很清楚

01:34.000 --> 01:48.000
这个函数呢 实际上是要有一个反而回直的 因为如果说你这个函数不写反而回直的话 有一个什么样的问题呢 也会导致手节点删除不掉

01:48.000 --> 01:55.000
我们来看一下 我都不着急写代码 我们来分析一下 我们写代码也是这样子啊 先分析再动手

01:55.000 --> 02:02.000
然后我们来看一下吧 比方这个链表 这个链表呢 你删这个节点好说 我删怎么删 我就这样删呗

02:03.000 --> 02:11.000
我就把这个这个点点动得不动它 对吧 我把它之前那个节点指向它的下一个不就删了吗 这就删除了 通过它是找不到它了

02:11.000 --> 02:20.000
对不就删除掉了吗 这就是删除 那如果说我要删它呢 也是一样 把它之前的那个节点指向它的下一个不就删了吗

02:20.000 --> 02:26.000
对不对 通过它是不是找不到了 好像是没啥问题 但是大家想过一个问题没有

02:26.000 --> 02:38.500
如果说你要删手节点能删吗 你手节点咋删 去不删不掉啊 因为手节点没有之前的节点了 你怎么把之前的节点指向下一个呢

02:38.500 --> 02:48.500
所以删不掉了手节点 怎么删不掉了你自己直接不就删了吗 不好意思 程序里面你不能做这样的操作 没有这样的操作可以让你做

02:48.500 --> 02:57.500
因为在节词 无论是节词语言还是加瓦语言 像那种高级语言里面 你是不能直接操控内存的 你只能操作辨量

02:57.500 --> 03:07.500
所以说这一块你根本就删不掉这个手节点 那怎么办呢 面对这种情况啊 我只能必须要把这个函数呢 要写个返回值 啥意思啊

03:08.500 --> 03:19.500
比方说我删这个节点 那删吧 还是一样 跟之前一样啊 这样子 删完了过后我返回一个节点 返回咋 返回A

03:19.500 --> 03:30.500
返回那个节点通过 返回那个节点A 是不是找不到这个B了 对吧 就删除掉了 那跟之前的是一样的 那么为什么有了返回值就可以删手节点了呢

03:31.500 --> 03:45.500
你看着 如果说我要删这个节点 我怎么删 我直接把B节点返回 对吧 把它的下一个节点返回 一返回了过后 那么调用函数得到的结果 是不是这个B节点

03:45.500 --> 03:54.500
通过这个B节点 是不是找不到A节点了 对吧 那这个节点是不是没了 所以说这个函数得有返回值 你没有返回值的话 会导致个手节点删不掉

03:55.500 --> 04:16.140
如果说昨天很多同学 估计可能很多同学又能够想到有返回值的 没关系啊 就算你想不到有返回值 那手节点就不删了嘛 不删手节点 不删手节点的话 那么后边的节点删除了你得把它做出来 不管你能不能做出来 至少要去思考 要去想过 好 来吧 那我们来看一下这道题啊 该怎么来做

04:16.140 --> 04:45.140
其实这道题呆马了 它倒是不复杂 就是呢 你要把这个逻辑你清楚 现在我们又返回结果了 返回啥 返回删除之后的 返回删除之后的练表的手节点 对不对 要返回这么一个东西 来吧 我们来看一下有哪些情况 有哪些情况啊 我们写一个函数也好 写个功能也好 一定把它所有的情况考虑完 那么这个函数才完整

04:46.140 --> 04:57.460
这里也是一样 有哪些情况呢 首先你给我节点没有 如果说你给节点都没有给我 你说我咋三 你告诉我咋三 我没发三啊

04:59.540 --> 05:03.380
节点都没有 都没有 在搞笑啊

05:05.220 --> 05:13.220
那我咋三吧 没发三对不对 那么这种情况下你觉得应该返回什么 删除之后的练表应该啥 啥节点都没给我

05:14.220 --> 05:20.800
他给我的练表就是一个空的 那我删完之后是什么 就是还是空的对不对 这个能理解啊

05:22.300 --> 05:25.740
没问题吧 这个能理解啊 这里应该返回什么导文奈

05:26.860 --> 05:36.300
对不对 你结论那么给我 你给我一个空的练表 一个删除一个什么 删除一个多少字 我根本就删不掉 哼 所以说我这里直接发文套

05:36.300 --> 05:42.700
接点都没有那么后边的情况是不是有节点了对不对那么这里就是有节点

05:42.700 --> 05:46.800
好那么我们来看一下有节点

05:46.800 --> 05:48.600
又分成什么情况

05:48.600 --> 05:57.040
那么分成什么情况呢就是这个节我只看这个节点因为我们用第1规来做嘛第1规的特点就是我只看当下

05:57.040 --> 06:01.400
后边的动作是一样的后边动作是在重复是一样的

06:01.600 --> 06:08.600
我就看目前这个东西就像我们之前打印一样啊打印的时候是不是我们只看自己对吧自己打印出来

06:08.600 --> 06:11.400
然后后边重复就完成了那么这里也是一样

06:12.600 --> 06:21.700
删除我就看自己这个节点这个节点是还是不是啥叫是呢就这个节点的值啊等于这个值是不是就是

06:23.400 --> 06:24.500
load的点value

06:25.500 --> 06:27.900
等于那什么value

06:29.100 --> 06:32.700
说明说明他这个节点需要

06:33.300 --> 06:34.500
被删除

06:36.300 --> 06:36.800
要是

06:38.300 --> 06:47.300
要是什么情况就这个节点他的值不等于他不等于他说这个节点不用被删除啊这个节点不需要被删除

06:47.300 --> 06:52.300
你看我们这个函数一共就这么煽动情况一个节点没有那我就没法删

06:53.300 --> 06:57.300
有节点的话这个节点是那么这个节点必须要删

06:58.500 --> 07:03.900
不是这个节点就不需要删说这种两种情况这两种情况你写完了这个还是有写完了

07:05.300 --> 07:09.900
来吧我看一下这两种情况一个是这个节点需要被删除

07:12.100 --> 07:13.700
比方说我要删除这个A

07:15.000 --> 07:19.900
这个A节点我看到我现在已经看到这个A点点了啊这个A节点需要被删除

07:20.900 --> 07:21.500
那怎么办

07:22.700 --> 07:24.100
是不是我就反回啥

07:24.300 --> 07:28.900
反回A的下一个对吧删除完A过后他是不是就下一个了

07:29.900 --> 07:32.300
对不对那就反回这个链表了反回一个B就完事了

07:32.900 --> 07:39.700
明儿的意思吧那么如果说我针对这个链表啊现在不看A了啊我针对这个链表我的手节点是B

07:40.500 --> 07:44.900
对吧我们任何一个节点都可以都可以作为手节点手节点是B针对这个链表

07:45.900 --> 07:49.900
我要把B删除掉是不是我就把这个链表反而回一个C

07:50.900 --> 07:51.900
怎么说的意思吧

07:52.900 --> 07:53.900
那我这个节点我不要了

07:54.900 --> 07:56.900
所以说这个节点我只需要反回下一个就完事了

07:57.900 --> 07:58.900
return note the next

07:59.900 --> 08:04.900
对吧就是这个节点我要返回他的下一个

08:05.900 --> 08:13.900
甭管下一个snow也好还是什么玩意也好啊你我要删除我要删除D那么反过来下一个D的下一个反过来就生耗了

08:14.900 --> 08:16.900
我要删除C就反回C的下一个就是D

08:17.900 --> 08:20.900
懂了意思吧就把这个节点去掉反过他的下一个

08:21.900 --> 08:22.900
所以就把这个节点没了

08:23.900 --> 08:26.900
好这是这个节点的值等于这个值

08:27.900 --> 08:32.340
好这样看最后一个补上最后一个就完了

08:33.340 --> 08:36.340
这个节点不需要被删除

08:40.440 --> 08:41.440
想一想这一块咋写了

08:43.750 --> 08:44.750
这个节点他不需要被删除

08:45.750 --> 08:49.750
就比方说我要删除B我先看的是什么先看的是A

08:50.750 --> 08:54.750
对不对看A这个A肯定是他有这个节点

08:55.750 --> 08:57.750
然后呢他他的值不等于B

08:58.750 --> 09:00.750
所以说他不需要被删除那怎么办

09:04.410 --> 09:06.410
是不是又看A的后边这个链表

09:07.410 --> 09:11.410
对吧又重复这个动作呗又看这个链表的第一个节点

09:12.410 --> 09:14.410
就是把A的下一个扔进去就看

09:15.410 --> 09:17.410
那么把这个链表扔进去让他去删

09:18.410 --> 09:23.410
删完了过他是不是是不是都会返回给我一个删除之后的结果

09:24.410 --> 09:26.410
对不对就会返回个删除之后的结果

09:27.410 --> 09:32.410
因此呢我只需要让A的下一个去指向这边删完的链表的

09:33.410 --> 09:34.410
手节点就可以了

09:35.410 --> 09:38.410
所以说这里的代码呢这里的有点少啊代码只有一行

09:39.410 --> 09:40.410
为什么说算法科啊

09:41.410 --> 09:43.410
很多时候你看那个代码一行能看得懂

09:44.410 --> 09:46.410
连起来就不知道啥意思了

09:47.410 --> 09:58.940
这里的解放是这样子的能理解吗

09:59.940 --> 10:02.940
好咱们来看一下啊用一个实际的例子来看一下

10:03.940 --> 10:04.940
比方说我现在要删除这个B节点

10:05.940 --> 10:07.940
首先看到是啥首先看到是A

10:08.940 --> 10:12.940
A有节点吗有节点进不了这个判断吗

10:13.940 --> 10:14.940
对不对进不了吧

10:15.940 --> 10:18.940
然后呢他的值是不是呢不是

10:18.940 --> 10:22.940
不是怎么办呢把A的下一个指向谁

10:23.940 --> 10:28.940
看A的把当前节点的下一个指向谁重新调用这个RM

10:29.940 --> 10:31.940
是不是重新调用这个RM

10:32.940 --> 10:34.940
把刚才A的下一个是不是B把B传进去

10:35.940 --> 10:36.940
又来做重复的过程来看

10:37.940 --> 10:38.940
又看这个节点又看这个链表

10:39.940 --> 10:41.940
这个链表我要删除B对吧那么删除B

10:42.940 --> 10:45.940
B有是不是就是满足条件了满足条件我当时是怎么做的

10:46.940 --> 10:47.940
满足条件是不是反过来的下一个

10:48.940 --> 10:50.940
所以说呢B这里呢

10:51.940 --> 10:53.940
我删这个链表的时候是不是把删除的结果返回

10:54.940 --> 10:56.940
删除结果是不是返回的是啥返回的是C

10:57.940 --> 10:58.940
对不对他返回的是C

10:59.940 --> 11:04.940
于是呢把他的返回结果复制给刚才有个节点的下一个

11:06.940 --> 11:07.940
就变成这样子了

11:10.380 --> 11:13.380
这里会稍微有点绕啊变成这样子了

11:14.380 --> 11:15.380
那么这样一指是不是把B删除掉了

11:17.380 --> 11:18.380
但是最后不要忘记了

11:18.380 --> 11:22.380
你这样子设置完了过后由于当前这个节点是不需要被删除的

11:23.380 --> 11:25.380
所以说你最后得还得返回啊返回当前这个节点

11:26.380 --> 11:27.380
单码的一共就这么多行

11:28.380 --> 11:29.380
极其的简单单码

11:30.380 --> 11:33.380
但是呢这里边呢需要大家好好去理解一下啊

11:34.380 --> 11:36.380
可能对于有些同学来讲呢

11:37.380 --> 11:41.380
不是那么好理解啊慢慢去绕一下慢慢去绕一下

11:42.380 --> 11:43.380
然后最后呢我们来看一下啊

11:44.380 --> 11:45.380
最后来看一下最后的结果

11:46.380 --> 11:47.380
呃这里一定行

11:48.380 --> 11:53.310
好来吧

11:54.310 --> 11:56.310
呃我们来删除removeA

11:59.310 --> 12:01.310
删除A得到节点得到节点是不是B

12:02.310 --> 12:03.310
反过来的结果是B

12:03.310 --> 12:04.310
后面都一样的啊B C D

12:05.310 --> 12:06.310
说都一样

12:06.310 --> 12:08.310
好然后我们来删除重新来刷新一次

12:09.310 --> 12:12.310
remove删除B这个节点

12:13.310 --> 12:15.940
删除B

12:15.940 --> 12:18.940
那你看A过后是不是C C过了是D对吧

12:19.940 --> 12:21.940
好然后呢我们来删除一个不存在的

12:22.940 --> 12:23.940
小心啊删除

12:24.940 --> 12:25.940
K这个节点

12:26.940 --> 12:29.940
那么结果就是啥都没删啊A B C D

12:30.940 --> 12:32.940
那么这种是什么情况呢这种就是啊一开始这样子

12:33.940 --> 12:37.580
一开始这样子对吧先看A

12:38.580 --> 12:41.580
A不是啊那么A的下一个要指向谁

12:41.580 --> 12:43.580
指向后边这个练表的删除结果

12:44.580 --> 12:45.580
那么后边的练表又来

12:46.580 --> 12:48.580
后边这个练表是B B也不是

12:48.580 --> 12:50.580
那必要指向谁

12:50.580 --> 12:52.580
指向后边这个练表的删除结果

12:52.580 --> 12:53.580
那么C

12:54.580 --> 12:56.580
呃你看这个节点C也不是

12:56.580 --> 12:57.580
那么C要指向谁

12:57.580 --> 12:59.580
指向后边这个练表的删除结果

12:59.580 --> 13:00.580
那么D D也不是

13:00.580 --> 13:02.580
指向后边这个练表的删除结果

13:02.580 --> 13:04.580
那么后边这个练表是闹了对吧

13:04.580 --> 13:05.580
是闹了

13:05.580 --> 13:07.580
是不是要进入这了

13:07.580 --> 13:08.580
那就返回闹

13:08.580 --> 13:09.580
那么这里返回闹了

13:09.580 --> 13:10.580
那D就指向谁

13:10.580 --> 13:11.580
指向闹

13:12.580 --> 13:13.580
然后D指向闹过后

13:13.580 --> 13:14.580
他会把D返回

13:14.580 --> 13:15.580
你看啊

13:15.580 --> 13:16.580
他当前节点不是的话

13:16.580 --> 13:17.580
他会把自己返回

13:18.580 --> 13:19.580
那么D返回

13:19.580 --> 13:20.580
那么C还是指向D

13:20.580 --> 13:21.580
你看又回去了

13:21.580 --> 13:23.580
然后D又指向谁

13:23.580 --> 13:24.580
指向C对吧

13:24.580 --> 13:25.580
他都不是嘛

13:25.580 --> 13:26.580
不是就把自己返回

13:27.580 --> 13:28.580
就完事了对不对

13:28.580 --> 13:29.580
那我们再来看一下

13:29.580 --> 13:30.580
删除的情况

13:30.580 --> 13:31.580
有删除的情况

13:31.580 --> 13:32.580
比方说我们删除C

13:33.580 --> 13:34.580
又看A是不是

13:34.580 --> 13:35.580
不是

13:35.580 --> 13:36.580
不是的话就要指向

13:36.580 --> 13:38.580
下一个练秒的删除结果

13:38.580 --> 13:39.580
又看B

13:39.580 --> 13:40.580
B不是又要指向

13:40.580 --> 13:41.580
下一个练秒的删除结果

13:41.580 --> 13:42.580
又看C

13:42.580 --> 13:43.580
C是不是

13:43.580 --> 13:44.580
C是

13:44.580 --> 13:45.580
那么C这里的

13:45.580 --> 13:46.580
他就不会返回C了

13:46.580 --> 13:47.580
他返回谁

13:47.580 --> 13:48.580
他返回的是D

13:48.580 --> 13:49.580
把D返回

13:49.580 --> 13:50.580
好

13:50.580 --> 13:51.580
D返回

13:51.580 --> 13:52.580
那么B就指向谁

13:52.580 --> 13:53.580
指向D

13:53.580 --> 13:54.580
B指向D的过后

13:54.580 --> 13:55.580
他又把B返回

13:55.580 --> 13:56.580
他不是嘛

13:56.580 --> 13:57.580
B不是嘛

13:57.580 --> 13:58.580
还把自己返回

13:58.580 --> 13:59.580
你看

13:59.580 --> 14:00.580
不是的情况下

14:00.580 --> 14:01.580
他指向完了过后

14:01.580 --> 14:02.580
要把自己返回

14:02.580 --> 14:03.580
那么B返回

14:03.580 --> 14:04.580
那么A就指向B

14:05.580 --> 14:06.580
就这么个意思

14:07.580 --> 14:08.580
这样子写出来的

14:08.580 --> 14:09.580
戴马拉就比较尖尖

14:09.580 --> 14:10.580
如果说你没有写

14:10.580 --> 14:11.580
返回值的话

14:11.580 --> 14:12.580
戴马拉

14:12.580 --> 14:13.580
能不能写

14:13.580 --> 14:14.580
肯定能写

14:14.580 --> 14:15.580
但是呢

14:15.580 --> 14:16.580
手节点删除不掉

14:17.580 --> 14:22.490
如果删除节点B

14:22.490 --> 14:23.490
是否最好设置为

14:23.490 --> 14:24.490
B点Nex

14:24.490 --> 14:25.490
等于Low

14:25.490 --> 14:26.490
这样B就和C

14:27.490 --> 14:28.490
彻底断可连接了

14:29.490 --> 14:30.490
可以

14:30.490 --> 14:31.490
但是没必要

14:31.490 --> 14:32.490
但是没必要

14:32.490 --> 14:33.490
是可以的

14:33.490 --> 14:34.490
刚才的朋友说可以的

14:34.490 --> 14:35.490
就说比方说

14:35.490 --> 14:36.490
如果删除节点C

14:37.490 --> 14:38.490
那么就是说

14:38.490 --> 14:39.490
把这个C的Nex

14:39.490 --> 14:41.490
指向谁呢

14:41.490 --> 14:42.490
指向Low

14:44.490 --> 14:45.490
那么这样子

14:45.490 --> 14:46.490
通过C就找不到

14:46.490 --> 14:47.490
这个列表里面的东西了

14:47.490 --> 14:48.490
是这个意思吧

14:48.490 --> 14:49.490
那么

14:49.490 --> 14:50.490
一般来说

14:50.490 --> 14:51.490
我们也没有必要

14:51.490 --> 14:52.490
去这样做

14:52.490 --> 14:53.490
因为我们平时

14:53.490 --> 14:54.490
用链表的时候

14:54.490 --> 14:55.490
关注了只有链表的

14:55.490 --> 14:56.490
手节点

14:56.490 --> 14:57.490
我们一般来说

14:57.490 --> 14:58.490
最后

14:58.490 --> 14:59.490
如果说真耳巴紧的

14:59.490 --> 15:00.490
真耳巴紧的

15:00.490 --> 15:01.490
你要封装一个链表的话

15:01.490 --> 15:02.490
你是要封装成

15:02.490 --> 15:03.490
这么一个函数的

15:04.490 --> 15:05.490
封装成这么一个

15:05.490 --> 15:06.490
构造函数

15:06.490 --> 15:07.490
如果说用JS来说的话

15:07.490 --> 15:08.490
就要说Link

15:08.490 --> 15:09.490
Nex

15:09.490 --> 15:10.490
这么一个构造函数

15:10.490 --> 15:11.490
这个构造函数

15:11.490 --> 15:12.490
里面要保留一个手节点

15:13.490 --> 15:14.490
保留它的手节点

15:14.490 --> 15:15.490
一开始是Low

15:15.490 --> 15:16.490
一开始

15:16.490 --> 15:17.490
慢慢的增加

15:17.490 --> 15:18.490
所有的方法

15:18.490 --> 15:19.490
都要在函数的

15:19.490 --> 15:20.490
圆形里面去写

15:20.490 --> 15:21.490
我之所以

15:21.490 --> 15:22.490
没有这样的写

15:22.490 --> 15:23.490
是因为

15:23.490 --> 15:24.490
我不想把事情搞得太复杂

15:25.490 --> 15:26.490
而且

15:26.490 --> 15:27.490
有些同学

15:27.490 --> 15:28.490
可能对圆形

15:28.490 --> 15:29.490
圆形链这些东西

15:29.490 --> 15:30.490
都还不是很熟悉

15:30.490 --> 15:31.490
所以我没有敢

15:31.490 --> 15:32.490
用这种方式来写

15:32.490 --> 15:33.490
把同学们

15:33.490 --> 15:34.490
就全部蒙逼了

15:34.490 --> 15:35.490
因为我们这个课

15:35.490 --> 15:36.490
主要是锻炼

15:36.490 --> 15:37.490
这个思维逻辑

15:37.490 --> 15:38.490
用最少的知识量

15:38.490 --> 15:39.490
来去锻炼

15:39.490 --> 15:40.490
这个思维逻辑

15:40.490 --> 15:41.490
所以我没有把它

15:41.490 --> 15:42.490
搞得那么复杂

15:42.490 --> 15:43.490
因此

15:43.490 --> 15:44.490
你的手节点

15:44.490 --> 15:45.490
如果说你这样子写了过后

15:45.490 --> 15:46.490
你的手节点

15:46.490 --> 15:47.490
你的手节点

15:47.490 --> 15:48.490
你是没法直接暴露出去的

15:48.490 --> 15:49.490
所以说

15:49.490 --> 15:50.490
你删了过后

15:50.490 --> 15:51.490
这个节点

15:51.490 --> 15:52.490
你是找不到他的

15:52.490 --> 15:53.490
你是找不到的

15:53.490 --> 15:54.490
你也访问不了

15:54.490 --> 15:55.490
他只想谁

15:55.490 --> 15:56.490
不冲扬

15:56.490 --> 15:57.490
因为你已经访问不到他了

15:57.490 --> 15:58.490
这个意思

15:58.490 --> 15:59.490
因为我们目前

15:59.490 --> 16:00.490
倒是能访问

16:00.490 --> 16:01.490
因为目前我们用的是

16:01.490 --> 16:02.490
全局辩量

16:02.490 --> 16:03.490
对吧

16:03.490 --> 16:04.490
ABCD都能够访问

16:04.490 --> 16:05.490
但是实际上

16:05.490 --> 16:06.490
真实的情况里面

16:06.490 --> 16:07.490
你把封装过后

16:07.490 --> 16:08.490
你只有手节点能访问

16:08.490 --> 16:12.020
其他都访问不到

16:12.020 --> 16:13.020
好

16:13.020 --> 16:14.020
那么这是

16:14.020 --> 16:15.020
昨天的删除

16:16.020 --> 16:17.020
今天咱们讲排序

16:17.020 --> 16:23.230
和查照

16:23.230 --> 16:24.230
排序算法

16:24.230 --> 16:25.230
排序算法有很多

16:25.230 --> 16:26.230
超级多

16:26.230 --> 16:27.230
那是不是每个同学

16:27.230 --> 16:28.230
要把这些

16:28.230 --> 16:29.230
所谓的排序算法

16:29.230 --> 16:30.230
全部做一遍呢

16:30.230 --> 16:31.230
没必要

16:32.230 --> 16:33.230
排序这个东西

16:33.230 --> 16:34.230
你们以后在工作中

16:34.230 --> 16:35.230
用不用了

16:36.230 --> 16:37.230
其实不咋用

16:37.230 --> 16:38.230
不咋用

16:38.230 --> 16:39.230
但是一般来说

16:39.230 --> 16:40.230
在骁子的时候

16:40.230 --> 16:41.230
他可能

16:41.230 --> 16:42.230
有可能考算法的时候

16:42.230 --> 16:43.230
就很有可能

16:43.230 --> 16:44.230
可以考虑排序算法

16:46.230 --> 16:48.230
主要是看你的思维逻辑

16:49.230 --> 16:50.230
通过排序算法

16:50.230 --> 16:51.230
今天晚上

16:51.230 --> 16:52.230
你们体验了过后

16:52.230 --> 16:53.230
你会感觉

16:53.230 --> 16:54.230
脑袋热热的

16:54.230 --> 16:55.230
晕晕的

16:55.230 --> 16:57.230
那么有这种感觉对了

16:58.230 --> 16:59.230
因为排序算法

16:59.230 --> 17:00.230
是非常能够训练

17:00.230 --> 17:01.230
思维逻辑的

17:01.230 --> 17:02.230
咱们之前说

17:02.230 --> 17:03.230
学算法

17:03.230 --> 17:04.230
学的是啥

17:05.230 --> 17:07.230
使学的是代码转换能力

17:07.230 --> 17:08.230
啥叫代码转换能力呢

17:08.230 --> 17:09.230
给你一种思维

17:09.230 --> 17:11.230
我把思维方案给你的

17:11.230 --> 17:12.230
你不是没思维吗

17:12.230 --> 17:13.230
我给你思维

17:14.230 --> 17:15.230
你能不能

17:15.230 --> 17:16.230
把它代码写出来

17:17.230 --> 17:18.230
这是个问题

17:18.230 --> 17:19.230
给了你思维过后

17:19.230 --> 17:20.230
你还是代码

17:20.230 --> 17:21.230
还是出不来

17:21.230 --> 17:22.230
那么这个时候你连

17:22.230 --> 17:24.230
初级工程师的要求都没有达到

17:24.230 --> 17:26.230
我都不要求你自己有思维

17:26.230 --> 17:27.230
有方案

17:27.230 --> 17:28.230
我给你的方案

17:28.230 --> 17:30.230
你都还把他写不出来

17:30.230 --> 17:31.230
那么这个能力呢

17:31.230 --> 17:32.230
是一定要通过

17:32.230 --> 17:33.230
不断的去训练的

17:33.230 --> 17:34.230
今天晚上

17:34.230 --> 17:36.230
我们去讲这三种排序算法

17:36.230 --> 17:38.230
就是来训练大家的

17:38.230 --> 17:39.230
这种思维

17:39.230 --> 17:41.230
是要不断的去训练

17:41.230 --> 17:42.230
而重点

17:42.230 --> 17:43.230
不是这些排序算法

17:43.230 --> 17:45.230
我们要去背下代码

17:45.230 --> 17:46.230
背不入的

17:46.230 --> 17:47.230
我告诉你

17:47.230 --> 17:48.230
这么多排序算法

17:48.230 --> 17:49.230
你一个都背不住

17:49.230 --> 17:50.230
你戳一个标减符号

17:50.230 --> 17:52.230
到时候写出来的代码都是有问题的

17:52.230 --> 17:53.230
你背不住的

17:53.230 --> 17:54.230
千万不要去背代码

17:54.230 --> 17:56.230
一定要是把这种思维能力

17:56.230 --> 17:57.230
训练出来

17:57.230 --> 17:59.230
训练出来了过后

18:00.230 --> 18:02.230
无论将来给你出什么排序算法

18:02.230 --> 18:03.230
他只要把的逻辑告诉你

18:03.230 --> 18:04.230
这个排序算法

18:04.230 --> 18:06.230
用什么样的方式来排序的

18:06.230 --> 18:09.230
你就可以把代码写出来

18:09.230 --> 18:10.230
包括我每一次

18:10.230 --> 18:11.230
讲那个算法

18:11.230 --> 18:12.230
这个集训营

18:12.230 --> 18:13.230
讲了这么多次了

18:13.230 --> 18:15.230
这代码我还是一个都背不住

18:15.230 --> 18:17.230
但是从来没有翻过车

18:17.230 --> 18:19.230
好像有一次翻过的一次车

18:19.230 --> 18:21.230
但是很快就把解决了

18:21.230 --> 18:22.230
为什么

18:22.230 --> 18:23.230
因为这个思维存

18:23.230 --> 18:25.230
这个思维力能力底有了之后

18:25.230 --> 18:26.230
逻辑告诉你

18:26.230 --> 18:27.230
方案告诉你

18:27.230 --> 18:28.230
你一定能把它写出来

18:28.230 --> 18:29.230
好

18:29.230 --> 18:30.230
咱们来看一下

18:30.230 --> 18:31.230
今天这三个排序算法

18:31.230 --> 18:33.230
已经了三个查到算法

18:34.230 --> 18:35.230
第一个

18:35.230 --> 18:36.230
咱们要排序

18:36.230 --> 18:38.230
排序我先简单说一下

18:43.400 --> 18:44.400
就说有个数组

18:44.400 --> 18:45.400
电表也好

18:45.400 --> 18:46.400
数组也好

18:46.400 --> 18:47.400
无所谓

18:47.400 --> 18:48.400
总之一个集合

18:49.400 --> 18:50.400
那么

18:50.400 --> 18:51.400
集合

18:52.400 --> 18:57.120
随便写吧

18:57.120 --> 18:58.120
随便写

18:58.120 --> 18:59.120
它是顺序的

18:59.120 --> 19:01.120
可能是乱的

19:01.120 --> 19:02.120
于是我们需要

19:02.120 --> 19:04.120
有一个方法

19:04.120 --> 19:05.120
有一个算法

19:05.120 --> 19:06.120
sort

19:06.120 --> 19:08.120
把这个数组扔进去

19:08.120 --> 19:10.120
调用完这个方法之后

19:10.120 --> 19:11.120
这个数组里边的东西

19:11.120 --> 19:12.120
就变成

19:12.120 --> 19:14.120
生序排序

19:14.120 --> 19:15.120
当然你可以降序

19:15.120 --> 19:16.120
降序的话

19:16.120 --> 19:17.120
改起来很简单

19:17.120 --> 19:19.120
当时你们自己去改一下

19:19.120 --> 19:20.120
总之你把这个数组一扔进去

19:20.120 --> 19:21.120
它剩下的东西

19:21.120 --> 19:23.120
就交给这个函数搞定

19:23.120 --> 19:24.120
函数运行完了

19:24.120 --> 19:26.120
不需要有任何返回值

19:26.120 --> 19:27.120
函数运行完了

19:27.120 --> 19:28.120
这个数组

19:28.120 --> 19:30.120
就全部排序好了

19:30.120 --> 19:31.120
别的意思吧

19:31.120 --> 19:32.120
就是排序

19:32.120 --> 19:33.120
那么排序

19:33.120 --> 19:36.120
就是这个函数的实现方式

19:36.120 --> 19:37.120
多种多样

19:37.120 --> 19:38.120
不同的排序方法

19:38.120 --> 19:40.120
那么它的实现方式不一样

19:40.120 --> 19:41.120
它的应用场景

19:41.120 --> 19:42.120
它的效率高低也不一样

19:42.120 --> 19:44.120
不过这些东西

19:44.120 --> 19:45.120
不是我们所关心的

19:45.120 --> 19:46.120
什么效率高低

19:46.120 --> 19:47.120
应用场景

19:47.120 --> 19:48.120
不是我们所关心的

19:48.120 --> 19:49.120
我们关心的是

19:49.120 --> 19:50.120
你能不能把代码写出来

19:50.120 --> 19:51.120
就关心这个

19:51.120 --> 19:53.120
这是很多初学的

19:53.120 --> 19:54.120
特别限确的

19:54.120 --> 19:56.120
主要训练这个东西

19:56.120 --> 19:57.120
好

19:57.120 --> 19:59.120
然后排序算法

19:59.120 --> 20:01.120
无论是用什么样的排序算法

20:01.120 --> 20:02.120
这里边

20:02.120 --> 20:04.120
十之八九

20:04.120 --> 20:05.120
也不说百分之百吧

20:05.120 --> 20:07.120
都涉及到一个交换

20:07.120 --> 20:08.120
就是把数组里边

20:08.120 --> 20:10.120
两个位置的东西交换

20:10.120 --> 20:11.120
你看前面的什么

20:11.120 --> 20:12.120
选择排序

20:12.120 --> 20:13.120
冒泡排序

20:13.120 --> 20:14.120
以后我们会讲细的讲

20:14.120 --> 20:16.120
它都涉及到一个交换

20:16.120 --> 20:17.120
那么我们这里

20:17.120 --> 20:18.120
为了让后边的排序算法

20:18.120 --> 20:19.120
来写起来简单

20:19.120 --> 20:21.120
我们这里先写这么一个函数

20:21.120 --> 20:22.120
叫swag

20:23.120 --> 20:25.120
你给我一个数组

20:25.120 --> 20:26.120
给我一个下标

20:26.120 --> 20:27.120
一

20:27.120 --> 20:28.120
给我一个下标

20:28.120 --> 20:29.120
二

20:29.120 --> 20:32.580
我打个注释

20:32.580 --> 20:33.580
啥意思

20:33.580 --> 20:36.580
交换数组

20:36.580 --> 20:39.580
两个下标的值

20:39.580 --> 20:41.580
因为一会儿的排序算法

20:41.580 --> 20:42.580
需要用

20:42.580 --> 20:45.580
很多排序算法

20:45.580 --> 20:48.580
都需要用

20:49.580 --> 20:50.580
来吧

20:50.580 --> 20:51.580
那怎么来交换

20:51.580 --> 20:53.580
两个下标的值

20:53.580 --> 20:54.580
比方说我这里

20:54.580 --> 20:55.580
到时候用的时候

20:55.580 --> 20:57.580
怎么用呢swag

20:57.580 --> 20:58.580
把数组传进去

20:58.580 --> 21:00.580
我要传一个零

21:00.580 --> 21:01.580
传一个二

21:01.580 --> 21:02.580
结果是啥呢

21:02.580 --> 21:03.580
几个数组里边

21:03.580 --> 21:04.580
这一项就变成了什么呢

21:04.580 --> 21:06.580
这一项就变成了二了

21:06.580 --> 21:07.580
就把这一位

21:07.580 --> 21:08.580
放过来

21:08.580 --> 21:09.580
然后把刚才的三

21:09.580 --> 21:10.580
放过来

21:10.580 --> 21:11.580
就是交换

21:11.580 --> 21:12.580
比方说我这里

21:12.580 --> 21:13.580
传一个零和三

21:13.580 --> 21:14.580
什么意思呢

21:14.580 --> 21:15.580
那么这一位

21:15.580 --> 21:17.580
就变成了刚才的七

21:17.580 --> 21:18.580
这里变成了三

21:18.580 --> 21:19.580
就是交换

21:19.580 --> 21:21.580
没啥意思啊

21:21.580 --> 21:22.580
那么这个函数怎么写的

21:22.580 --> 21:23.580
这个函数其实很简单

21:23.580 --> 21:24.580
你们都学过变量

21:24.580 --> 21:26.580
交换两个变量的值

21:26.580 --> 21:28.580
要用一个第三个变量

21:28.580 --> 21:31.580
先暂存一下

21:31.580 --> 21:33.580
当然交换

21:33.580 --> 21:35.580
还有很多很少的写法

21:35.580 --> 21:37.580
不过那些东西都

21:37.580 --> 21:38.580
非常影响可读性

21:38.580 --> 21:40.580
我们通常交换的话

21:40.580 --> 21:42.580
就用这种最

21:42.580 --> 21:43.580
最好的就是

21:43.580 --> 21:45.580
约读起来最有好的写法

21:46.580 --> 21:48.580
那么先把它复制为什么呢

21:50.580 --> 21:52.580
然后把这个界复制为type

21:52.580 --> 21:53.580
就完事了

21:53.580 --> 21:54.580
对吧

21:54.580 --> 21:55.580
非常简单

21:55.580 --> 21:56.580
就两个杯子的换水

21:56.580 --> 21:58.580
你得用到第三个杯子

21:58.580 --> 22:00.580
先把其中一个杯子

22:00.580 --> 22:02.580
放到第三个杯子里边去

22:02.580 --> 22:03.580
然后把

22:03.580 --> 22:04.580
刚刚放过去了

22:04.580 --> 22:05.580
这个杯子

22:05.580 --> 22:06.580
填通另一个纸

22:06.580 --> 22:08.580
然后把另一个纸

22:08.580 --> 22:09.580
放过来

22:09.580 --> 22:10.580
这个东西没什么好说的

22:10.580 --> 22:11.580
交换两个变量

22:11.580 --> 22:15.860
好,咱们试一下吧

22:15.860 --> 22:16.860
进行出来

22:21.000 --> 22:22.000
那么

22:22.000 --> 22:25.000
交换零和三

22:25.000 --> 22:26.000
看一下

22:26.000 --> 22:27.000
交换完了之后

22:27.000 --> 22:28.000
这个数组

22:28.000 --> 22:30.000
是不是七和三就交换了

22:30.000 --> 22:31.000
你看

22:31.000 --> 22:32.000
本来是这样子的

22:32.000 --> 22:34.000
七和三是不交换了

22:34.000 --> 22:35.000
非常简单

22:35.000 --> 22:36.000
这就是

22:36.000 --> 22:38.000
这个玩意

22:38.000 --> 22:39.000
有个辅助方法

22:39.000 --> 22:40.000
我们先写一下

22:40.000 --> 22:41.000
好,写好了之后

22:41.000 --> 22:42.000
我们接下来

22:42.000 --> 22:44.000
来看这三种排序算法

22:44.000 --> 22:46.000
第一种选择排序

22:49.460 --> 22:50.460
来吧

22:51.460 --> 22:52.460
同样的

22:52.460 --> 22:53.460
不管这个方法什么名字

22:53.460 --> 22:55.460
总归得给我一个数组

22:55.460 --> 22:56.460
数组给我

22:56.460 --> 22:57.460
然后

22:57.460 --> 22:58.460
剩下的事情交给我了

22:58.460 --> 23:00.460
我来把它排序好

23:00.460 --> 23:01.460
选择排序

23:01.460 --> 23:03.460
那么选择排序

23:03.460 --> 23:05.460
是什么排序呢

23:05.460 --> 23:06.460
看一下这个图

23:06.460 --> 23:10.100
我们在浏览形容打开

23:10.100 --> 23:11.100
这是干嘛

23:11.100 --> 23:12.100
第一次排序

23:12.100 --> 23:13.100
找最小值

23:13.100 --> 23:15.100
找到二了

23:15.100 --> 23:16.100
二是最小值

23:16.100 --> 23:18.100
把二和第一位交换

23:18.100 --> 23:19.100
第一位排好了

23:19.100 --> 23:20.100
第二次

23:20.100 --> 23:21.100
找最小值

23:21.100 --> 23:22.100
五还不是

23:22.100 --> 23:23.100
继续往后找

23:23.100 --> 23:24.100
找到三

23:24.100 --> 23:25.100
最小值

23:25.100 --> 23:27.100
好,把三和这一位交换

23:27.100 --> 23:28.100
第三次

23:28.100 --> 23:29.100
从这里开始

23:29.100 --> 23:32.470
找最小值

23:32.470 --> 23:33.470
找最小值

23:33.470 --> 23:34.470
和

23:34.470 --> 23:36.470
这第三位交换

23:36.470 --> 23:37.470
下一次

23:37.470 --> 23:38.470
找最小值

23:38.470 --> 23:39.470
对吧

23:39.470 --> 23:40.470
是不是挨在那找最小值

23:40.470 --> 23:42.470
比方不找最小值是啥

23:42.470 --> 23:43.470
好,找到了

23:43.470 --> 23:45.470
然后五跟这一位交换

23:45.470 --> 23:48.230
找最小值

23:48.230 --> 23:49.230
看没

23:50.230 --> 23:51.230
交换

23:52.230 --> 23:53.230
看懂没

23:53.230 --> 23:55.230
这就是选择排序

23:55.230 --> 23:57.230
选择排序其实非常简单

23:57.230 --> 23:59.230
就是找最小值

23:59.230 --> 24:01.230
那么这个选择排序

24:01.230 --> 24:02.230
我们刚才看到就是

24:02.230 --> 24:04.230
找最小值的动作

24:04.230 --> 24:06.230
找多好吃呢

24:06.230 --> 24:07.230
你想想找多好吃

24:07.230 --> 24:09.230
跟着我思路走啊

24:09.230 --> 24:11.230
比方说有这么一个数组

24:11.230 --> 24:16.620
六

24:16.620 --> 24:17.620
五

24:17.620 --> 24:18.620
你看啊

24:18.620 --> 24:20.620
首先第一次找最小值

24:20.620 --> 24:22.620
一共长度为

24:22.620 --> 24:24.620
长度为

24:25.620 --> 24:29.180
现在方案已经告诉你了

24:29.180 --> 24:30.180
现在我们要训练

24:30.180 --> 24:31.180
怎么样根据方案

24:31.180 --> 24:33.180
把代码写出来

24:33.180 --> 24:34.180
要先分析

24:34.180 --> 24:36.180
长度为五的数组

24:36.180 --> 24:38.180
要找多少次最小值呢

24:38.180 --> 24:40.180
也就是要循环多少次呢

24:40.180 --> 24:43.180
第一次把最小的

24:43.180 --> 24:45.180
把这整个范围内最小的值

24:45.180 --> 24:46.180
放到第一位

24:46.180 --> 24:47.180
对吧

24:47.180 --> 24:48.180
是不是一次

24:48.180 --> 24:50.180
第二次放到第二位

24:50.180 --> 24:51.180
两次

24:51.180 --> 24:52.180
第三位

24:52.180 --> 24:53.180
三次

24:53.180 --> 24:54.180
第四位

24:54.180 --> 24:55.180
四次

24:55.180 --> 24:57.180
放到四位过后

24:57.180 --> 24:59.180
还需不需要再去找最小值

24:59.180 --> 25:01.180
还需要在后边再去找最小值

25:01.180 --> 25:02.180
这不需要了

25:02.180 --> 25:03.180
因为前边四位

25:03.180 --> 25:05.180
如果说已经排好了的话

25:05.180 --> 25:06.180
前边的四位

25:06.180 --> 25:07.180
已经排

25:07.180 --> 25:08.180
按照顺序

25:08.180 --> 25:09.180
从小到大排好了的话

25:09.180 --> 25:10.180
那么最后一位

25:10.180 --> 25:12.180
一定在正确的位置上

25:12.180 --> 25:13.180
对不对

25:13.180 --> 25:14.180
只能我们只需要循环四次

25:14.180 --> 25:16.180
这个能理解吧

25:16.180 --> 25:18.180
循环四次

25:18.180 --> 25:20.180
这个能不能理解

25:20.180 --> 25:25.950
嗯

25:25.950 --> 25:26.950
这个能不能理解

25:26.950 --> 25:27.950
啊

25:28.950 --> 25:34.250
A加B

25:34.250 --> 25:35.250
对

25:35.250 --> 25:36.250
这种也可以

25:36.250 --> 25:37.250
这种可以

25:37.250 --> 25:39.940
好

25:39.940 --> 25:40.940
那么这里只需要

25:40.940 --> 25:42.940
也就是我们长度

25:42.940 --> 25:43.940
认识的时候

25:43.940 --> 25:45.940
那么循环就长度减一次

25:45.940 --> 25:46.940
啊

25:46.940 --> 25:47.940
因此呢

25:47.940 --> 25:48.940
我们这样子分析

25:48.940 --> 25:49.940
出来的过后

25:49.940 --> 25:50.940
我们就可以把这个

25:50.940 --> 25:51.940
办法的结构写出来

25:51.940 --> 25:52.940
结构是什么呢

25:52.940 --> 25:53.940
循环

25:53.940 --> 25:55.940
是一个循环结构

25:55.940 --> 25:57.940
循环多好吃呢

25:57.940 --> 26:00.940
循环长度减一次

26:02.940 --> 26:03.940
对不对

26:03.940 --> 26:05.940
是不是循环这么多次

26:05.940 --> 26:06.940
好

26:06.940 --> 26:07.940
那么这个循环

26:07.940 --> 26:08.940
你也要能够写出来

26:08.940 --> 26:09.940
这个应该很多时候都没问题

26:09.940 --> 26:10.940
你把分析出来

26:10.940 --> 26:11.940
要循环多少次

26:11.940 --> 26:12.940
好

26:12.940 --> 26:13.940
但是不要忘记了

26:13.940 --> 26:18.470
每一次循环干嘛呀

26:18.470 --> 26:19.470
你如果说

26:19.470 --> 26:20.470
有的时候你写带嘛

26:20.470 --> 26:21.470
搞不清楚

26:21.470 --> 26:22.470
你就打柱式

26:22.470 --> 26:24.470
把它详细的描述好

26:24.470 --> 26:25.470
不然的话

26:25.470 --> 26:27.470
你写着写着蒙的

26:27.470 --> 26:29.470
每一次循环干嘛呢

26:29.470 --> 26:31.470
找到

26:31.470 --> 26:33.470
最小值

26:33.470 --> 26:34.470
然后第一次循环

26:34.470 --> 26:35.470
是不是整个范围内

26:35.470 --> 26:39.470
在整个范围内找到最小值

26:39.470 --> 26:40.470
那么第二次循环

26:40.470 --> 26:42.470
还是整个范围嘛

26:42.470 --> 26:43.470
第二次循环

26:43.470 --> 26:44.470
是不是不看第一位了

26:44.470 --> 26:46.470
是不是看这后边这一位

26:46.470 --> 26:47.470
对不对

26:47.470 --> 26:48.470
那么这里就设计到

26:48.470 --> 26:49.470
第一个问题

26:49.470 --> 26:55.470
在什么范围内找最小值

26:55.470 --> 26:56.470
你看啊

26:56.470 --> 26:58.470
这个分析是一点一点的来的

26:58.470 --> 27:02.470
在什么范围内找最小值

27:03.470 --> 27:05.470
第一次循环

27:05.470 --> 27:06.470
是不是在

27:06.470 --> 27:07.470
什么范围内

27:07.470 --> 27:11.470
是不是在0到

27:11.470 --> 27:14.470
长度减1

27:14.470 --> 27:15.470
啊

27:15.470 --> 27:16.470
这个范围内

27:16.470 --> 27:17.470
对不对

27:17.470 --> 27:18.470
是不是在这个范围内

27:18.470 --> 27:19.470
找最小值

27:19.470 --> 27:20.470
第一次啊

27:20.470 --> 27:21.470
第一次

27:21.470 --> 27:24.470
第二次的时候

27:24.470 --> 27:25.470
是不看第一位了

27:25.470 --> 27:27.470
因为从1这个位置

27:27.470 --> 27:29.470
下表为1这个位置

27:29.470 --> 27:30.470
到最大下表之间

27:30.470 --> 27:31.470
找最小值

27:31.470 --> 27:33.470
是不是这个道理

27:33.470 --> 27:34.470
这是第一次

27:34.470 --> 27:35.470
这是第二次

27:35.470 --> 27:36.470
第三次呢

27:36.470 --> 27:38.470
就是下表为2

27:38.470 --> 27:39.470
到最大下表之间

27:39.470 --> 27:40.470
找最小值

27:40.470 --> 27:41.470
你看

27:41.470 --> 27:42.470
是不是这样子

27:42.470 --> 27:43.470
你看

27:43.470 --> 27:44.470
这就是需要一点一点的

27:44.470 --> 27:45.470
去分析啊

27:45.470 --> 27:46.470
不要不是说

27:46.470 --> 27:47.470
代码就刷的

27:47.470 --> 27:48.470
就写出来了

27:48.470 --> 27:49.470
不是的啊

27:49.470 --> 27:51.470
它是一点一点的分析出来

27:51.470 --> 27:53.470
那么这个问号位置填啥

27:53.470 --> 27:56.490
来

27:56.490 --> 27:57.490
我一个问啊

27:57.490 --> 27:58.490
首先就在这里

27:58.490 --> 28:00.490
问号位置填啥

28:01.490 --> 28:02.490
这个问号位置

28:02.490 --> 28:03.490
我们现在在分析

28:03.490 --> 28:05.800
都还没有写代吗

28:05.800 --> 28:06.800
在哪个范围内

28:06.800 --> 28:11.940
第一次是0到这个范围

28:11.940 --> 28:13.940
哎就非常好啊

28:13.940 --> 28:15.940
是不是I到Ns-1对不对

28:15.940 --> 28:16.940
这个很容易分析出来了

28:16.940 --> 28:17.940
对吧

28:17.940 --> 28:18.940
很多东西是有这个能力的

28:18.940 --> 28:19.940
很多东西写代嘛

28:19.940 --> 28:20.940
特别特别着急

28:20.940 --> 28:22.940
想一下就写出来

28:22.940 --> 28:23.940
写不出来了

28:23.940 --> 28:25.940
你必须要一点点的分析

28:25.940 --> 28:27.940
是不是在这个范围内

28:27.940 --> 28:29.940
找到最小值

28:29.940 --> 28:30.940
对吧

28:30.940 --> 28:32.940
这个我们把这个注写打好

28:32.940 --> 28:33.940
好

28:33.940 --> 28:35.940
那么比方说现在就找到最小值了

28:35.940 --> 28:38.940
找到最小值之后又怎么办

28:40.940 --> 28:41.940
那么比方说我们先写吧

28:41.940 --> 28:42.940
我们现在不是要在这个范围内

28:42.940 --> 28:43.940
找最小值吗

28:43.940 --> 28:44.940
找最小值之后代码

28:44.940 --> 28:45.940
大家都会写

28:45.940 --> 28:46.940
前定一个辩量

28:46.940 --> 28:48.940
对吧

28:48.940 --> 28:49.940
前定一个辩量

28:49.940 --> 28:50.940
最小值吧

28:50.940 --> 28:51.940
先等于

28:51.940 --> 28:52.940
等于一个什么

28:52.940 --> 28:53.940
等于一个-的infinity

28:53.940 --> 28:54.940
然后

28:54.940 --> 28:55.940
等于一个-无穷大

28:55.940 --> 28:56.940
先来一个最小

28:56.940 --> 28:58.940
先来一个-无穷大

28:58.940 --> 28:59.940
对吧

28:59.940 --> 29:00.940
来个-无穷大

29:00.940 --> 29:03.700
随便来一个

29:03.700 --> 29:04.700
然后呢

29:04.700 --> 29:06.700
循环呗

29:06.700 --> 29:10.080
循环呗

29:10.080 --> 29:11.080
从什么开始循环

29:11.080 --> 29:12.080
在这个范围内对吧

29:12.080 --> 29:14.080
是不是从i开始循环

29:14.080 --> 29:15.080
你现在就不要看

29:15.080 --> 29:16.080
歪成的循环了啊

29:16.080 --> 29:17.080
我刚去把歪成的循环

29:17.080 --> 29:19.080
直接给你盖过去

29:19.080 --> 29:20.080
免得跟

29:20.080 --> 29:22.080
有一些同学千套循环写不好

29:22.080 --> 29:23.080
一开始逻辑思维

29:23.080 --> 29:24.080
还没有建立起来的时候

29:24.080 --> 29:25.080
经常会被

29:25.080 --> 29:27.080
歪成循环所干扰

29:27.080 --> 29:28.080
现在跟歪成循环没关系了

29:28.080 --> 29:29.080
你又看这个注写

29:29.080 --> 29:31.080
怎么把这个注写实现

29:31.080 --> 29:32.080
范围高处你的

29:32.080 --> 29:33.080
从哪个范围

29:33.080 --> 29:34.080
i到

29:36.520 --> 29:37.520
lambsterlens

29:37.520 --> 29:38.520
对吧

29:38.520 --> 29:39.520
小于他

29:39.520 --> 29:40.520
小于他就是到人使兼仪嘛

29:40.520 --> 29:41.520
借佳佳

29:41.520 --> 29:42.520
所以在这个范围内循环

29:42.520 --> 29:43.520
你现在要做的就一件事

29:43.520 --> 29:46.520
在这个范围内去找出小值

29:46.520 --> 29:48.520
那么他首先哪一个

29:48.520 --> 29:49.520
他首先他这个边疆的值

29:49.520 --> 29:51.520
一开始是最大的啊

29:51.520 --> 29:52.520
无穷大

29:52.520 --> 29:53.520
然后呢

29:53.520 --> 29:54.520
只要在这个

29:54.520 --> 29:55.520
只要在这个范围内

29:55.520 --> 29:57.520
看到有个值比他小

29:57.520 --> 29:59.520
看到有一个值

29:59.520 --> 30:00.520
比谁小

30:00.520 --> 30:01.520
比这个命小

30:01.520 --> 30:05.150
所以他重新复职就完事了

30:05.150 --> 30:06.150
就重新复职就行了

30:06.150 --> 30:07.150
整个这个代码

30:07.150 --> 30:08.150
这一坨代码

30:08.150 --> 30:11.660
就做了一件事

30:11.660 --> 30:13.660
在这个范围内

30:13.660 --> 30:16.660
找最小值

30:16.660 --> 30:17.660
这样代码运行完了

30:17.660 --> 30:18.660
是不是找出来了

30:18.660 --> 30:20.660
所以找出来了

30:20.660 --> 30:21.660
好找出来了

30:21.660 --> 30:23.660
过后又干嘛

30:23.660 --> 30:26.660
现在找到了最小值

30:26.660 --> 30:28.660
最小值

30:28.660 --> 30:30.660
保存到了哪呢

30:30.660 --> 30:31.660
保存到了

30:31.660 --> 30:32.660
那变量

30:32.660 --> 30:33.660
如果说有些回念

30:33.660 --> 30:35.660
最早最小值都不知道的话

30:35.660 --> 30:37.660
下来好好要去训练一下

30:37.660 --> 30:39.660
基础的好好看一下

30:39.660 --> 30:41.660
这东西太基础了

30:41.660 --> 30:43.660
如果说现在找到最小值

30:43.660 --> 30:44.660
保存到个变量

30:44.660 --> 30:47.220
变量命里边

30:47.220 --> 30:48.220
接下来干嘛

30:48.220 --> 30:51.540
不要因为走了太远就忘记了

30:51.540 --> 30:52.540
为什么出发

30:52.540 --> 30:54.540
找最小值

30:54.540 --> 30:56.540
看啊找最小值

30:56.540 --> 30:57.540
这个最小值你看

30:57.540 --> 30:58.540
只要比他小就交换

30:58.540 --> 31:00.540
只要比他小就记住

31:00.540 --> 31:01.540
干嘛

31:01.540 --> 31:02.540
是不是把他

31:02.540 --> 31:04.540
跟某一个地方进行交换

31:04.540 --> 31:05.540
对吧

31:05.540 --> 31:09.620
把这个这个值

31:09.620 --> 31:10.620
跟某一个地方进行交换

31:10.620 --> 31:11.620
哦这里我写错了啊

31:11.620 --> 31:12.620
这我写错了

31:12.620 --> 31:13.620
应该是找什么

31:13.620 --> 31:14.620
找下标对不对

31:14.620 --> 31:15.620
我要把两个下标的

31:15.620 --> 31:16.620
只交换嘛对不对

31:16.620 --> 31:17.620
我要找最小值

31:17.620 --> 31:18.620
所在的下标

31:18.620 --> 31:20.620
找到最小值

31:20.620 --> 31:22.620
所在的下标

31:22.620 --> 31:23.620
我要找这个

31:23.620 --> 31:24.620
那么我这里

31:24.620 --> 31:25.620
还是用这个变量啊

31:25.620 --> 31:27.620
如果说他比他小的话

31:27.620 --> 31:28.620
那么我要记录这个下标

31:28.620 --> 31:30.620
我要把这个下标记录下来

31:30.620 --> 31:31.620
好那么这里呢

31:31.620 --> 31:32.620
我们写一个下标啊

31:32.620 --> 31:33.620
银这个是

31:33.620 --> 31:36.990
好那么这里呢

31:36.990 --> 31:37.990
银这个是

31:37.990 --> 31:38.990
复词为什么

31:38.990 --> 31:39.990
对不对

31:39.990 --> 31:41.990
没找到一个最小值

31:41.990 --> 31:43.990
没找到一个最小值

31:43.990 --> 31:44.990
你保存他

31:44.990 --> 31:46.990
你保存他就这个格式化了

31:46.990 --> 31:48.990
没找到一个最小值

31:48.990 --> 31:49.990
这个值比之前的小

31:49.990 --> 31:50.990
对吧

31:50.990 --> 31:51.990
那么保存一下这个最小值

31:51.990 --> 31:53.990
然后呢把这个下标记录一下

31:53.990 --> 31:55.990
那么这个循环完了过后

31:55.990 --> 31:56.990
这个下标

31:56.990 --> 31:57.990
银这个是里面

31:57.990 --> 31:58.990
是不是保存了

31:58.990 --> 31:59.990
最小值的

31:59.990 --> 32:00.990
最小值的啥

32:00.990 --> 32:02.990
最小值的位置

32:02.990 --> 32:05.990
找到了最小值的位置

32:05.990 --> 32:06.990
保存了变量

32:06.990 --> 32:08.990
银这个是中

32:08.990 --> 32:09.990
现在干嘛

32:09.990 --> 32:11.990
所以把这个位置

32:11.990 --> 32:12.990
最小的那个位置

32:12.990 --> 32:14.990
跟谁交换

32:14.990 --> 32:16.990
跟i交换

32:16.990 --> 32:18.990
跟i这个位置交换

32:18.990 --> 32:19.990
你看一下

32:19.990 --> 32:20.990
找到最小值

32:20.990 --> 32:21.990
再来

32:21.990 --> 32:22.990
找到最小值

32:22.990 --> 32:23.990
跟谁交换

32:23.990 --> 32:24.990
现在i是

32:24.990 --> 32:25.990
i是几

32:25.990 --> 32:26.990
0 1 2 3 4

32:26.990 --> 32:27.990
i循环到第四次了

32:27.990 --> 32:28.990
对吧

32:28.990 --> 32:29.990
是跟他交换

32:29.990 --> 32:30.990
好就是第五次

32:30.990 --> 32:31.990
i等于5

32:31.990 --> 32:33.990
找最小值

32:33.990 --> 32:34.990
找最小值是

32:34.990 --> 32:35.990
这个下标

32:35.990 --> 32:37.990
这个下标跟5交换

32:37.990 --> 32:38.990
就是啊

32:38.990 --> 32:39.990
所以这里呢

32:39.990 --> 32:43.260
应该跟谁交换

32:43.260 --> 32:44.260
将

32:44.260 --> 32:45.260
index

32:45.260 --> 32:46.260
和

32:46.260 --> 32:47.260
i

32:47.260 --> 32:48.260
交换

32:48.260 --> 32:49.260
怎么交换

32:49.260 --> 32:50.260
刚才写过一个

32:50.260 --> 32:51.260
好像塑料失败

32:51.260 --> 32:53.260
输主是扔进去

32:53.260 --> 32:54.260
输主扔进去

32:54.260 --> 32:55.260
然后呢

32:55.260 --> 32:56.260
两个下标扔进去

32:56.260 --> 32:57.260
i和index

32:57.260 --> 32:58.260
扔进去

32:58.260 --> 33:00.260
两个交换就完成了

33:00.260 --> 33:01.260
逻辑就写完了

33:01.260 --> 33:03.260
写完就写完了

33:03.260 --> 33:05.260
这还是写完了

33:05.260 --> 33:08.260
这个代码是正向出来的

33:08.260 --> 33:09.260
要一点点去分析

33:09.260 --> 33:10.260
好

33:10.260 --> 33:11.260
来我们的运行下

33:11.260 --> 33:13.260
看一下是不是

33:13.260 --> 33:14.260
这个输主呢

33:14.260 --> 33:15.260
是numbers

33:15.260 --> 33:16.260
然后呢

33:16.260 --> 33:17.260
我们这里运行下

33:17.260 --> 33:19.260
叫snexing sort

33:19.260 --> 33:20.260
numbers传进去

33:20.260 --> 33:21.260
好运行完了

33:21.260 --> 33:22.260
我们看一下这个输主

33:22.260 --> 33:24.260
输运排序好了

33:24.260 --> 33:27.260
这就是选择排序

33:27.260 --> 33:28.260
如果说你想

33:28.260 --> 33:29.260
你想知道

33:29.260 --> 33:30.260
每一次排序的结果

33:30.260 --> 33:31.260
是啥的

33:31.260 --> 33:33.260
你在这里输出一下

33:33.260 --> 33:34.260
numbers

33:34.260 --> 33:35.260
交易

33:35.260 --> 33:36.260
都好

33:36.260 --> 33:37.260
每一次输出一下

33:37.260 --> 33:38.260
这个输主

33:38.260 --> 33:39.260
来看一下吧

33:39.260 --> 33:45.900
那么第一次得到的结果

33:45.900 --> 33:46.900
是把1放到最小了

33:46.900 --> 33:47.900
对吧

33:47.900 --> 33:49.900
第二次是把2放到最小

33:49.900 --> 33:50.900
看

33:50.900 --> 33:51.900
然后第三次呢

33:51.900 --> 33:52.900
是把3放到最小

33:52.900 --> 33:53.900
3已经在最小了

33:53.900 --> 33:55.900
所以说这里有个重复输出

33:55.900 --> 33:57.900
第四次是把5放到最小

33:57.900 --> 33:58.900
放到这里

33:58.900 --> 33:59.900
对吧

33:59.900 --> 34:00.900
这里排好了

34:00.900 --> 34:01.900
第六次呢

34:01.900 --> 34:02.900
6已经在这了

34:02.900 --> 34:03.900
对吧

34:03.900 --> 34:04.900
重复输出了一次

34:04.900 --> 34:05.900
其实不需要了

34:05.900 --> 34:08.900
因为它最后以为一定ok的

34:08.900 --> 34:10.900
这是选择排序

34:10.900 --> 34:13.540
没问题吧

34:14.540 --> 34:15.540
还行吗

34:15.540 --> 34:16.540
能轻弄啊

34:16.540 --> 34:22.700
能轻弄QQE啊

34:25.390 --> 34:26.390
加油啊同学们

34:26.390 --> 34:28.700
加油

34:28.700 --> 34:30.700
好 再来啊

34:30.700 --> 34:31.700
下一个

34:31.700 --> 34:36.490
下一个猫炮排序

34:37.490 --> 34:38.490
来看一下

34:38.490 --> 34:39.490
猫炮排序就长排了

34:39.490 --> 34:44.850
我还是在浏览系统打开

34:44.850 --> 34:45.850
它就

34:45.850 --> 34:46.850
这个排序就比较急躁了

34:46.850 --> 34:47.850
对吧

34:47.850 --> 34:49.850
第一次

34:49.850 --> 34:50.850
相宁位置

34:50.850 --> 34:51.850
一次往后比较

34:51.850 --> 34:52.850
大的往前

34:52.850 --> 34:54.850
往后靠

34:54.850 --> 34:55.850
那么这样子

34:55.850 --> 34:56.850
第一次是不是把最大的方向

34:56.850 --> 34:57.850
最后边的

34:57.850 --> 34:58.850
第二次又是同样的

34:58.850 --> 35:00.850
相宁位置比较

35:00.850 --> 35:01.850
大的往后靠

35:01.850 --> 35:02.850
对吧

35:02.850 --> 35:03.850
希望说泡泡往后边冒

35:03.850 --> 35:04.850
对不对

35:04.850 --> 35:06.850
大泡泡就往上面冒

35:06.850 --> 35:07.850
那么第二次完了

35:07.850 --> 35:08.850
最大的排序

35:08.850 --> 35:09.850
排到后边去了

35:09.850 --> 35:11.850
第三次又是相宁的

35:11.850 --> 35:12.850
排

35:13.850 --> 35:14.850
看呗

35:14.850 --> 35:15.850
就这么模式

35:15.850 --> 35:16.850
排在这了

35:16.850 --> 35:17.850
又来

35:18.850 --> 35:19.850
相宁的往后

35:19.850 --> 35:20.850
后边交换

35:20.850 --> 35:23.670
看呗

35:23.670 --> 35:24.670
这一次是不是

35:24.670 --> 35:25.670
这个就

35:25.670 --> 35:26.670
这个就排在这了

35:26.670 --> 35:27.670
后边就不动了对吧

35:28.670 --> 35:29.670
是不是跟那个选择排序

35:29.670 --> 35:30.670
还是有

35:30.670 --> 35:31.670
有一些地方对似的

35:31.670 --> 35:32.670
对不对

35:32.670 --> 35:33.670
好那么我们来看一下

35:33.670 --> 35:34.670
这个是

35:34.670 --> 35:35.670
冒泡排序

35:35.670 --> 35:36.670
叫巴布

35:37.670 --> 35:38.670
巴布

35:39.670 --> 35:40.670
是这样写吧

35:40.670 --> 35:41.670
巴布

35:42.670 --> 35:43.670
巴布

35:43.670 --> 35:45.670
还是一样给我一个数数

35:45.670 --> 35:47.670
我来帮你进一排序

35:47.670 --> 35:48.670
这是冒泡排序

35:49.670 --> 35:52.110
冒泡

35:52.110 --> 35:53.110
好我们首先还是

35:53.110 --> 35:54.110
一个第一个问题

35:54.110 --> 35:55.110
冒泡排序

35:55.110 --> 35:58.490
循环多少次

35:58.490 --> 36:00.490
又来这个问题了

36:00.490 --> 36:02.490
冒泡排序循环多少次

36:02.490 --> 36:04.490
那么我又来分析了

36:04.490 --> 36:06.490
长度为五的数数

36:06.490 --> 36:07.490
循环多少次呢

36:07.490 --> 36:09.490
第一次把最大的放这

36:09.490 --> 36:11.490
第二次把第二大的放这

36:11.490 --> 36:12.490
第三次再放这

36:12.490 --> 36:13.490
第四次放这

36:13.490 --> 36:15.490
第五次是不是不用放了

36:15.490 --> 36:16.490
它一定是最小的了

36:17.490 --> 36:18.490
对不对

36:18.490 --> 36:19.490
是循环数还是四次

36:19.490 --> 36:20.490
它也是循环什么

36:20.490 --> 36:22.490
循环长度减一次

36:23.490 --> 36:24.490
安等于你

36:25.490 --> 36:26.490
安小于

36:26.490 --> 36:28.490
Num's Delance

36:28.490 --> 36:29.490
明白

36:29.490 --> 36:30.490
Delance

36:30.490 --> 36:31.490
点一

36:31.490 --> 36:32.490
再加加

36:32.490 --> 36:35.180
对吧循环这么多次

36:35.180 --> 36:37.180
这是需要去分析啊

36:37.180 --> 36:38.180
又来了

36:38.180 --> 36:40.180
没事循环干嘛

36:40.180 --> 36:44.260
没事循环干嘛呢

36:44.260 --> 36:45.260
第一次循环

36:46.260 --> 36:47.260
是不是从

36:47.260 --> 36:49.260
是不是从这个范围内

36:49.260 --> 36:51.260
相凝两相

36:51.260 --> 36:53.260
进行比较

36:53.260 --> 36:54.260
对吧在这个

36:54.260 --> 36:55.260
第一次

36:55.260 --> 36:56.260
在这个范围内

36:56.260 --> 36:58.260
相凝两相

36:58.260 --> 37:00.260
进行比较

37:00.260 --> 37:02.260
大的往后靠

37:02.260 --> 37:03.260
对吧比方说

37:03.260 --> 37:05.260
三合一比较

37:05.260 --> 37:06.260
那么叫交换

37:06.260 --> 37:07.260
对不对

37:07.260 --> 37:08.260
一和三交换

37:08.260 --> 37:09.260
好

37:09.260 --> 37:10.260
三和二比较

37:10.260 --> 37:11.260
三比二大

37:11.260 --> 37:12.260
前面比后面大

37:12.260 --> 37:14.260
那么就是二和三交换

37:14.260 --> 37:16.260
三和六比较不动

37:16.260 --> 37:18.260
六和五比较交换

37:18.260 --> 37:20.260
第一次就排出来了

37:20.260 --> 37:21.260
这个运气好

37:21.260 --> 37:22.260
第一次就排出来了

37:22.260 --> 37:23.260
但实际上有可能

37:23.260 --> 37:24.260
第一次排不出来了

37:24.260 --> 37:26.260
只能把最大的放在最后边

37:27.260 --> 37:28.260
这就是

37:28.260 --> 37:30.260
每一次循环干嘛呢

37:30.260 --> 37:31.260
第一次循环

37:31.260 --> 37:33.260
在零到

37:34.260 --> 37:35.260
哪个范围内

37:35.260 --> 37:36.260
哪个范围内

37:36.260 --> 37:38.260
零到

37:38.260 --> 37:39.260
这个范围内

37:39.260 --> 37:40.260
认识简移

37:43.600 --> 37:44.600
认识

37:44.600 --> 37:45.600
简移

37:45.600 --> 37:46.600
这个范围内

37:46.600 --> 37:47.600
相凝两相

37:47.600 --> 37:48.600
进行交换

37:48.600 --> 37:49.600
在这个范围内

37:49.600 --> 37:50.600
但是呢

37:50.600 --> 37:51.600
实际上我们在

37:51.600 --> 37:53.600
在具体操作的时候

37:53.600 --> 37:54.600
一位发现

37:54.600 --> 37:55.600
我这一项去跟

37:55.600 --> 37:56.600
后边这一位比较

37:56.600 --> 37:57.600
这一项跟

37:57.600 --> 37:58.600
后边这一位比较

37:58.600 --> 37:59.600
说到这一位就可以了

37:59.600 --> 38:00.600
因为这一位的话

38:00.600 --> 38:01.600
我跟后边这一位比较

38:01.600 --> 38:02.600
就可以了

38:02.600 --> 38:03.600
一张网号

38:03.600 --> 38:04.600
一张网号的话

38:04.600 --> 38:05.600
到这一位

38:05.600 --> 38:06.600
他后面已经没位数了

38:06.600 --> 38:07.600
已经没法比较了

38:07.600 --> 38:08.600
没有必要了

38:08.600 --> 38:09.600
没了意思吗

38:09.600 --> 38:10.600
你看

38:10.600 --> 38:11.600
这两位

38:11.600 --> 38:12.600
一个

38:12.600 --> 38:13.600
两个

38:13.600 --> 38:14.600
三个

38:14.600 --> 38:15.600
四个

38:15.600 --> 38:16.600
所以我们只需要

38:16.600 --> 38:17.600
做什么呢

38:17.600 --> 38:18.600
在零到

38:18.600 --> 38:19.600
认识简二

38:19.600 --> 38:23.130
这个范围内就可以了

38:23.130 --> 38:24.130
你想想是不是有道理

38:25.130 --> 38:26.130
在这个范围内就可以了

38:26.130 --> 38:27.130
为什么

38:27.130 --> 38:28.130
零

38:28.130 --> 38:29.130
跟后边这一位比较

38:29.130 --> 38:30.130
二

38:30.130 --> 38:31.130
跟后边这一位比较

38:31.130 --> 38:32.130
然后

38:32.130 --> 38:33.130
三

38:33.130 --> 38:34.130
下边为三

38:34.130 --> 38:35.130
跟后边这一位比较

38:35.130 --> 38:37.130
没有必要到下边为四了

38:37.130 --> 38:38.130
懂我意思吗

38:38.130 --> 38:39.130
所以循环到

38:39.130 --> 38:41.130
弄得简二就可以了

38:41.130 --> 38:44.270
这是第一次

38:45.270 --> 38:46.270
第一次

38:46.270 --> 38:47.270
整个范围

38:47.270 --> 38:48.270
但是实际上

38:48.270 --> 38:49.270
循环到这就可以了

38:50.270 --> 38:51.270
第二次

38:52.270 --> 38:54.900
第二次是不是

38:54.900 --> 38:55.900
循环到这就可以了

38:55.900 --> 38:56.900
实际上

38:56.900 --> 38:57.900
控制的是这个范围

38:57.900 --> 38:58.900
对不对

38:58.900 --> 38:59.900
是不

39:03.180 --> 39:05.180
那么是

39:05.180 --> 39:06.180
认识简三

39:09.060 --> 39:10.060
第三次

39:11.060 --> 39:12.060
是要控制这个范围

39:12.060 --> 39:13.060
但是实际上

39:13.060 --> 39:14.060
我们只需要

39:14.060 --> 39:15.060
看这

39:15.060 --> 39:16.060
循环这两个就行了

39:16.060 --> 39:17.060
因为它每一个

39:17.060 --> 39:18.060
是往后边举行交的

39:19.060 --> 39:20.060
认识简四

39:25.320 --> 39:26.320
一次

39:27.320 --> 39:28.320
看

39:31.320 --> 39:33.320
什么范围内的

39:35.320 --> 39:36.320
数据

39:36.320 --> 39:43.510
只要它和后

39:43.510 --> 39:44.510
和后边

39:45.510 --> 39:46.510
它比后边

39:46.510 --> 39:48.510
它比后边的大

39:49.510 --> 39:51.510
就交换

39:52.510 --> 39:53.510
那么这个问号为止

39:53.510 --> 39:54.510
添啥

39:54.510 --> 39:55.510
根据这个规律找出来

39:55.510 --> 39:56.510
像你们以后

39:56.510 --> 39:57.510
找公司的区别

39:57.510 --> 39:58.510
面试的时候

39:58.510 --> 39:59.510
一般会发给你一套

39:59.510 --> 40:00.510
比试题

40:00.510 --> 40:01.510
这个比试题

40:01.510 --> 40:02.510
有很多这种逻辑题

40:02.510 --> 40:03.510
就是根据

40:03.510 --> 40:04.510
根据这个东西找规律

40:04.510 --> 40:06.510
你们能把规律找出来

40:06.510 --> 40:07.510
一分析到这种程度了

40:07.510 --> 40:09.510
你应该能够把规律找出来了

40:10.510 --> 40:11.510
问号为止

40:11.510 --> 40:12.510
添啥

40:13.510 --> 40:14.510
问号为止

40:15.510 --> 40:17.510
都是从零开始的

40:17.510 --> 40:18.510
零到啥

40:19.510 --> 40:20.510
零到啥

40:20.510 --> 40:21.510
零到

40:23.510 --> 40:24.510
点点点

40:24.510 --> 40:25.510
剪

40:26.510 --> 40:27.510
剪几呢

40:28.510 --> 40:29.510
剪

40:30.510 --> 40:31.510
二

40:31.510 --> 40:32.510
剪

40:33.510 --> 40:36.980
你看是不是

40:39.480 --> 40:40.480
第一次循环的时候

40:40.480 --> 40:41.480
零到剪

40:41.480 --> 40:42.480
i就是剪

40:42.480 --> 40:43.480
i对于零

40:43.480 --> 40:44.480
第二次循环剪3

40:44.480 --> 40:45.480
第三次循环剪4

40:48.180 --> 40:49.180
是不是只看这个范围的

40:50.180 --> 40:51.180
对不对

40:51.180 --> 40:52.180
好 然后我们循环

40:52.180 --> 40:53.180
那么这个循环是不是可以写出来了

40:53.180 --> 40:54.180
借等于零

40:54.180 --> 40:55.180
从零开始循环

40:55.180 --> 40:57.180
借小维等于多少呢

40:57.180 --> 40:58.180
小维等于

40:59.180 --> 41:00.180
-2-i

41:01.180 --> 41:02.180
当然很多地方

41:02.180 --> 41:03.180
我们这里的

41:03.180 --> 41:04.180
按照习惯写法

41:04.180 --> 41:06.180
一般这里不写等号的话

41:06.180 --> 41:07.180
不写等号的话

41:07.180 --> 41:08.180
是到这里

41:09.180 --> 41:10.180
剪1就可以了

41:10.180 --> 41:11.180
对吧

41:11.180 --> 41:12.180
不写等号的话

41:12.180 --> 41:13.180
剪1

41:13.180 --> 41:14.180
写到等号的话就剪2

41:14.180 --> 41:15.180
所以说不要去背代码

41:15.180 --> 41:16.180
我知道很多地方

41:16.180 --> 41:17.180
它都写的是剪1

41:17.180 --> 41:18.180
因为它这里面写等号

41:18.180 --> 41:19.180
你不要去背这个代码

41:19.180 --> 41:20.180
一定是分析出来了

41:21.180 --> 41:22.180
分析出来一定是没问题的

41:23.180 --> 41:24.180
没意思吧

41:24.180 --> 41:25.180
看你这个等号要不要写

41:25.180 --> 41:26.180
写的等号就是写2

41:26.180 --> 41:27.180
不写的等号就是剪1

41:27.180 --> 41:28.180
借加加

41:32.090 --> 41:33.090
你说一个代码怎么背

41:33.090 --> 41:34.090
根本就背不住

41:35.090 --> 41:36.090
那么这个帽子排序

41:36.090 --> 41:37.090
每一次干嘛呢

41:37.090 --> 41:38.090
刚才说了

41:38.090 --> 41:40.090
把这个位置

41:40.090 --> 41:42.090
跟后边的位置比较

41:42.090 --> 41:44.090
如果说这个位置

41:44.090 --> 41:46.090
比后边的位置大

41:46.090 --> 41:48.530
干嘛

41:48.530 --> 41:50.530
就交换

41:51.530 --> 41:52.530
交换

41:52.530 --> 41:53.530
swap

41:53.530 --> 41:54.530
numbers

41:54.530 --> 41:55.530
诶

41:55.530 --> 41:56.530
诶

41:56.530 --> 41:57.530
诶

41:57.530 --> 41:58.530
借和借加1

41:58.530 --> 42:01.100
看一下

42:02.100 --> 42:03.100
就写完了

42:03.100 --> 42:04.100
这就是个帽子排序

42:04.100 --> 42:05.100
代码没多少

42:05.100 --> 42:06.100
但是你不分析的话

42:06.100 --> 42:07.100
就写不出来

42:07.100 --> 42:10.180
好

42:10.180 --> 42:11.180
再看一下

42:12.180 --> 42:13.180
帽子排序

42:13.180 --> 42:14.180
bub

42:14.180 --> 42:15.180
sort

42:15.180 --> 42:16.180
numbers

42:16.180 --> 42:18.740
好

42:18.740 --> 42:19.740
换一个numbers

42:19.740 --> 42:20.740
看一下

42:21.740 --> 42:22.740
呃

42:24.740 --> 42:27.380
8

42:27.380 --> 42:28.380
13

42:29.380 --> 42:30.380
我看一下

42:31.380 --> 42:32.380
这是

42:32.380 --> 42:33.380
9

42:34.380 --> 42:35.380
7

42:35.380 --> 42:36.380
随便来一个

42:36.380 --> 42:38.750
上去

42:38.750 --> 42:39.750
诶

42:39.750 --> 42:40.750
出问题

42:40.750 --> 42:41.750
我也出问题了

42:41.750 --> 42:42.750
没排序

42:43.750 --> 42:44.750
356789

42:45.750 --> 42:46.750
是不是没问题

42:46.750 --> 42:47.750
好

42:47.750 --> 42:49.750
这就是帽子排序

42:49.750 --> 42:54.820
帽子排序

42:54.820 --> 42:55.820
好

42:55.820 --> 42:56.820
让大家

42:56.820 --> 42:58.820
让大家缓一下啊

42:58.820 --> 42:59.820
我喝口水

42:59.820 --> 43:00.820
让大家缓一下

43:00.820 --> 43:01.820
没问题吧

43:01.820 --> 43:02.820
到现在

43:02.820 --> 43:04.820
下面这个排序有点难啊

43:04.820 --> 43:13.140
快速排序

43:13.140 --> 43:16.670
加油

43:16.670 --> 43:17.670
快排

43:17.670 --> 43:21.820
有点抵不住了啊

43:21.820 --> 43:23.820
加油啊加油

43:23.820 --> 43:25.820
可能前面两个排序呢

43:25.820 --> 43:27.820
还真有这样的同学啊

43:27.820 --> 43:29.820
就是他冒冒排序呢

43:29.820 --> 43:31.820
大部分同学都觉得

43:31.820 --> 43:32.820
应该是选择排序

43:32.820 --> 43:33.820
和冒冒排序呢

43:33.820 --> 43:34.820
比较简单

43:34.820 --> 43:36.820
然后呢快速排序比较难

43:36.820 --> 43:37.820
但是呢

43:37.820 --> 43:39.820
不排出有些同学的思维方式呢

43:39.820 --> 43:40.820
就特别的

43:40.820 --> 43:42.820
比适合地规

43:42.820 --> 43:43.820
啊

43:43.820 --> 43:44.820
所以说呢

43:44.820 --> 43:45.820
有些同学他就会觉得

43:45.820 --> 43:47.820
快排呢反而简单一点

43:47.820 --> 43:48.820
那个冒冒排序呢

43:48.820 --> 43:49.820
选择排序比较难啊

43:49.820 --> 43:51.820
这种同学一到少一点啊

43:51.820 --> 43:52.820
咱们体验一下吧

43:52.820 --> 43:53.820
啊

43:54.820 --> 43:56.820
很多时候就跟那个小码锅合一样

43:56.820 --> 43:57.820
别人说难

43:57.820 --> 43:58.820
有的人说简单

43:58.820 --> 43:59.820
到底难不难

43:59.820 --> 44:00.820
到底简不简单

44:00.820 --> 44:01.820
你自己过了合就知道了

44:02.820 --> 44:03.820
快拍

44:04.820 --> 44:05.820
之前没听懂的

44:06.820 --> 44:08.820
就已达官篇了

44:08.820 --> 44:09.820
后边有路播啊

44:09.820 --> 44:10.820
慢慢去体会

44:10.820 --> 44:11.820
因为这个科呢

44:11.820 --> 44:12.820
这有些同学来说

44:12.820 --> 44:13.820
可能听的呢

44:13.820 --> 44:14.820
稍微有点早啊

44:14.820 --> 44:15.820
因为有些同学

44:15.820 --> 44:16.820
还没有达到五百行的

44:16.820 --> 44:17.820
都没有

44:18.820 --> 44:19.820
好来吧快排

44:19.820 --> 44:23.700
快排是咋排的呢

44:23.700 --> 44:24.700
他是在数组里边

44:24.700 --> 44:26.700
随便选一个数

44:26.700 --> 44:28.700
就像你们你们班

44:28.700 --> 44:29.700
班上

44:29.700 --> 44:30.700
我要把

44:30.700 --> 44:32.700
我要按照年龄来排序

44:32.700 --> 44:33.700
在一个班级里边

44:33.700 --> 44:35.700
按照年龄来排序

44:35.700 --> 44:37.700
或者按照身高来排序

44:37.700 --> 44:38.700
怎么排呢

44:38.700 --> 44:39.700
随便找个人

44:39.700 --> 44:40.700
你给我举手

44:40.700 --> 44:43.020
比他矮的

44:43.020 --> 44:44.020
全部往左边站

44:44.020 --> 44:45.020
比他高的

44:45.020 --> 44:46.020
全部往右边站

44:48.020 --> 44:50.020
然后对他左边那一堆说

44:50.020 --> 44:52.020
在左边那一堆说

44:52.020 --> 44:53.020
以他为基准

44:53.020 --> 44:54.020
已经排好了

44:54.020 --> 44:55.020
然后他不管了

44:55.020 --> 44:57.020
往左边那一堆去看

44:57.020 --> 44:58.020
左边那一堆

44:58.020 --> 44:59.020
我又随便找个同学

44:59.020 --> 45:00.020
来你给我举手

45:00.020 --> 45:02.020
在这一堆里边

45:02.020 --> 45:03.020
比他矮的往左边

45:03.020 --> 45:04.020
比他高的往右边

45:05.020 --> 45:06.020
懂了的意思吗

45:06.020 --> 45:08.020
就是这个意思啊

45:08.020 --> 45:09.020
最终不断的细分

45:09.020 --> 45:10.020
不断的细分

45:10.020 --> 45:13.020
直到把整个数据排序完

45:13.020 --> 45:14.020
提上去就好像很恐怖

45:14.020 --> 45:15.020
我们来看一下

45:15.020 --> 45:16.020
到底有多恐怖

45:16.020 --> 45:20.100
比方说一个数据

45:20.100 --> 45:22.100
随便找一个数

45:22.100 --> 45:24.100
比方我们就找最后一位吧

45:24.100 --> 45:25.100
就找最后一位

45:25.100 --> 45:26.100
来你给我站出来

45:26.100 --> 45:27.100
站出来过

45:27.100 --> 45:28.100
比他小的

45:28.100 --> 45:29.100
全部往左边靠

45:29.100 --> 45:31.100
一和三往左边靠

45:31.100 --> 45:32.100
比他大的

45:32.100 --> 45:33.100
全部往右边靠

45:33.100 --> 45:36.100
六七四五往右边靠

45:36.100 --> 45:38.100
这一个基本排出来了

45:38.100 --> 45:39.100
基本排出来了

45:39.100 --> 45:40.100
一个大根的轮廓了

45:40.100 --> 45:42.100
然后针对左边这一块

45:42.100 --> 45:43.100
右来

45:43.100 --> 45:45.100
三你给我站出来

45:45.100 --> 45:46.100
在这一堆里边

45:46.100 --> 45:47.100
比他小的往左边

45:47.100 --> 45:48.100
他本身就在左边

45:48.100 --> 45:49.100
比他小

45:49.100 --> 45:50.100
比他大的没有

45:50.100 --> 45:51.100
没有就算了

45:51.100 --> 45:52.100
那么这一堆是不是排好了

45:52.100 --> 45:54.100
目前就排好了这三个了

45:55.100 --> 45:56.100
然后右来

45:56.100 --> 45:57.100
右边这一堆

45:57.100 --> 45:58.100
右来

45:58.100 --> 45:59.100
五给我站出来

45:59.100 --> 46:02.410
比他小的往左边站

46:02.410 --> 46:03.410
比他小的没有

46:04.410 --> 46:05.410
比五小的没有

46:05.410 --> 46:06.410
五在这

46:06.410 --> 46:08.410
比他大的往右边

46:08.410 --> 46:09.410
七和六在右边

46:10.410 --> 46:11.410
排完了没有

46:11.410 --> 46:12.410
然后右来

46:12.410 --> 46:13.410
这边

46:13.410 --> 46:14.410
把这一堆里面右来

46:14.410 --> 46:15.410
六站出来

46:15.410 --> 46:16.410
比他小的往左边

46:16.410 --> 46:17.410
比他小的没有

46:17.410 --> 46:18.410
比他大的往右边

46:18.410 --> 46:19.410
七在右边去了

46:19.410 --> 46:21.410
整个数字就排完了

46:21.410 --> 46:22.410
就是快排

46:23.410 --> 46:25.410
问题是

46:25.410 --> 46:26.410
怎么写大一码了

46:26.410 --> 46:27.410
这玩意儿

46:27.410 --> 46:29.410
我们再看一下

46:30.410 --> 46:32.410
有这么一个数字

46:32.410 --> 46:34.410
首先我们把

46:34.410 --> 46:35.410
最后一位

46:35.410 --> 46:36.410
四座为基础

46:36.410 --> 46:37.410
四座为基础

46:37.410 --> 46:39.410
来比他小的往左边

46:39.410 --> 46:40.410
比他大的往右边

46:41.410 --> 46:43.410
然后四座为基础完了过后

46:43.410 --> 46:45.410
然后在这一堆里面

46:45.410 --> 46:46.410
对于三和二

46:46.410 --> 46:47.410
又在这里边找

46:47.410 --> 46:48.410
二站出来

46:48.410 --> 46:49.410
比他小的往左边

46:49.410 --> 46:50.410
比他大的往右边

46:50.410 --> 46:51.410
所以这里排好了

46:51.410 --> 46:53.410
然后对于这一部分

46:53.410 --> 46:54.410
也是一样

46:54.410 --> 46:55.410
五站出来

46:55.410 --> 46:56.410
比他小的往左边

46:56.410 --> 46:57.410
比他大的往右边

46:58.410 --> 46:59.410
排出来了

46:59.410 --> 47:00.410
其实如果说

47:00.410 --> 47:01.410
这个地方还没排出来的话

47:01.410 --> 47:02.410
还要继续

47:02.410 --> 47:03.410
直到把整个数组

47:03.410 --> 47:04.410
全部完成

47:04.410 --> 47:05.410
排序完成

47:06.410 --> 47:07.410
就快排

47:07.410 --> 47:13.920
完书排序

47:20.420 --> 47:21.420
好 给我一个数组

47:21.420 --> 47:22.420
还是一样

47:22.420 --> 47:23.420
给我一个数组

47:24.420 --> 47:27.860
我来帮你进行快排

47:27.860 --> 47:29.860
在做快排的时候

47:29.860 --> 47:33.300
有一个重复的动作

47:33.300 --> 47:34.300
不断的在重复

47:34.300 --> 47:36.300
就是对某一个

47:36.300 --> 47:37.300
范围内的

47:38.300 --> 47:39.300
小的站左边

47:39.300 --> 47:40.300
大的站右边

47:40.300 --> 47:41.300
是不是有这么一个操作

47:41.300 --> 47:42.300
你看

47:42.300 --> 47:43.300
不着急

47:43.300 --> 47:44.300
遇到问题

47:44.300 --> 47:45.300
不要怕

47:45.300 --> 47:46.300
一点一点的分析

47:48.300 --> 47:49.300
你看这里

47:49.300 --> 47:50.300
一开始我是对整个数组

47:50.300 --> 47:51.300
对吧

47:51.300 --> 47:52.300
把诗拿出来

47:52.300 --> 47:53.300
比他小的站左边

47:53.300 --> 47:54.300
比他大的站右边

47:55.300 --> 47:56.300
一会儿我也是

47:56.300 --> 47:57.300
针对这一个部分

47:57.300 --> 47:58.300
数组的这一个部分

47:58.300 --> 48:00.300
它是有范围的

48:00.300 --> 48:02.300
针对这一个部分

48:02.300 --> 48:04.300
我要拿一个基数

48:04.300 --> 48:05.300
然后比他小的站左边

48:05.300 --> 48:06.300
比他大的一个站右边

48:06.300 --> 48:08.300
是不是我们一定有一个动作

48:08.300 --> 48:09.300
这个动作是什么

48:09.300 --> 48:12.300
针对数组某一个范围内

48:13.300 --> 48:15.300
做这个操作

48:16.300 --> 48:17.300
所以这样子

48:17.300 --> 48:18.300
这个能分析的出来了

48:18.300 --> 48:20.300
要一点一点的分析

48:20.300 --> 48:23.300
针对数组某一个范围内

48:24.300 --> 48:25.300
做这么一个操作

48:25.300 --> 48:26.300
而这个操作

48:26.300 --> 48:28.300
是不断的在重复的

48:29.300 --> 48:30.300
想起了啥呢

48:30.300 --> 48:31.300
所以想起了

48:31.300 --> 48:32.300
我们昨天的

48:32.300 --> 48:34.300
写个子函书

48:36.300 --> 48:38.620
数组已经有了

48:38.620 --> 48:40.620
你不用再告诉我了

48:40.620 --> 48:42.620
你只需要告诉我一个范围

48:43.620 --> 48:44.620
起始下标

48:45.620 --> 48:46.620
结束下标

48:48.620 --> 48:49.620
我在这个范围内

48:49.620 --> 48:51.620
给你去做这个操作

48:52.620 --> 48:55.620
在指定的下标范围内

48:56.620 --> 48:57.620
范围内

48:58.620 --> 48:59.620
做

48:59.620 --> 49:00.620
这种

49:01.620 --> 49:03.620
什么操作

49:03.620 --> 49:04.620
就是

49:06.620 --> 49:07.620
就是

49:07.620 --> 49:10.620
以一个数为基数

49:10.620 --> 49:11.620
为基础

49:11.620 --> 49:12.620
基础小的

49:13.620 --> 49:14.620
靠左

49:14.620 --> 49:15.620
大的

49:15.620 --> 49:16.620
靠右

49:16.620 --> 49:17.620
对吧

49:17.620 --> 49:18.620
我不管你小的

49:18.620 --> 49:19.620
小的那边有没有排序

49:19.620 --> 49:20.620
好无所谓

49:20.620 --> 49:21.620
大的靠右

49:22.620 --> 49:23.620
懂了意思吧

49:23.620 --> 49:24.620
之后我们先把这个围移出来

49:24.620 --> 49:26.620
那么你肯定得有个辅助函数

49:27.620 --> 49:28.620
因为这里一开始

49:28.620 --> 49:29.620
没有范围

49:30.620 --> 49:32.620
因此我要做快速排序

49:32.620 --> 49:33.620
实际上我要做的事情

49:33.620 --> 49:34.620
是什么

49:34.620 --> 49:35.620
就是调用这个函数

49:37.620 --> 49:38.620
最开始的时候

49:38.620 --> 49:39.620
是不是下标0开始

49:41.620 --> 49:42.620
到什么下标

49:42.620 --> 49:46.250
到数组长度减1

49:46.250 --> 49:47.250
一开始就做这么一个操作

49:47.250 --> 49:48.250
就完事了

49:48.250 --> 49:49.250
所以我把他这个问题

49:49.250 --> 49:51.250
转换成了这个问题

49:51.250 --> 49:53.250
转换成了一个指示函数

49:53.250 --> 49:54.250
你给我传一个提示下标

49:54.250 --> 49:55.250
一个结束下标

49:55.250 --> 49:56.250
我来这个范围内

49:56.250 --> 49:57.250
做一个操作

49:57.250 --> 49:58.250
只不过一开始

49:58.250 --> 49:59.250
我是整个数组

49:59.250 --> 50:01.820
在围内去做这个操作

50:01.820 --> 50:02.820
你不说别的

50:02.820 --> 50:03.820
我先不说别的

50:03.820 --> 50:04.820
这个玩意能看懂吗

50:04.820 --> 50:05.820
能看懂Q个E

50:09.150 --> 50:10.150
这个应该能理解

50:10.150 --> 50:11.150
这个很好理解的

50:11.150 --> 50:12.150
我都还没有说到后面

50:12.150 --> 50:13.150
不要着急

50:14.150 --> 50:15.150
好

50:15.150 --> 50:16.150
来吧

50:16.150 --> 50:17.150
还是后边打动

50:18.150 --> 50:19.150
这里边打动

50:19.150 --> 50:20.150
这里边

50:20.150 --> 50:21.150
我们也先把一些

50:21.150 --> 50:22.150
简单办法先写出来

50:23.150 --> 50:24.150
就是那种

50:24.150 --> 50:25.150
我没法做了

50:25.150 --> 50:26.150
这个操作

50:26.150 --> 50:27.150
已经一把我逼疯了

50:27.150 --> 50:28.150
已经没法做了

50:28.150 --> 50:29.150
什么情况下

50:29.150 --> 50:30.150
我是没法做

50:30.150 --> 50:31.150
这个操作的呢

50:35.780 --> 50:36.780
比方说

50:36.780 --> 50:38.780
我遇到这么一种情况

50:38.780 --> 50:39.780
我就没有办法

50:39.780 --> 50:40.780
做这个操作了

50:44.540 --> 50:45.540
比方说

50:45.540 --> 50:46.540
这是start

50:47.540 --> 50:48.540
这是

50:48.540 --> 50:49.540
end

50:51.540 --> 50:52.540
如果说你给我

50:52.540 --> 50:54.540
做下标范围

50:54.540 --> 50:55.540
是这个样子的

50:56.540 --> 50:57.540
你告诉我

50:57.540 --> 50:58.540
我咋弄

50:58.540 --> 51:02.050
你说我对这一个范围

51:02.050 --> 51:03.050
这一个范围内

51:03.050 --> 51:04.050
我去做啥操作

51:04.050 --> 51:05.050
没有必要

51:05.050 --> 51:07.050
两个范围都重叠了

51:07.050 --> 51:08.050
什么没有必要

51:08.050 --> 51:09.050
做这个操作了

51:10.050 --> 51:11.050
这个能理解了

51:11.050 --> 51:12.050
或者说

51:12.050 --> 51:13.050
我那个

51:14.050 --> 51:15.050
end的那个作标

51:16.050 --> 51:17.050
跑到start前面去了

51:18.050 --> 51:19.050
那你说

51:19.050 --> 51:20.050
反向操作吗

51:22.050 --> 51:23.050
好像一句话叫反向大招

51:23.050 --> 51:24.050
对吧

51:24.050 --> 51:25.050
你说反向操作

51:25.050 --> 51:26.050
没法操作了

51:26.050 --> 51:28.050
所以我要做这个操作的一个前提条件

51:28.050 --> 51:30.050
就是这个范围是正常的

51:30.050 --> 51:32.050
这样的范围可以

51:32.050 --> 51:34.050
领到这个范围也可以

51:34.050 --> 51:36.050
这个范围也可以

51:36.050 --> 51:38.050
甚至这个范围都可以

51:38.050 --> 51:40.050
但是你一定要是正常的范围

51:40.050 --> 51:41.050
也就是说啥呢

51:41.050 --> 51:43.050
如果说start

51:43.050 --> 51:45.050
小于等于的end

51:45.050 --> 51:47.420
这种情况

51:47.420 --> 51:49.420
我是没法玩的

51:49.420 --> 51:51.420
还有什么情况没法玩呢

51:51.420 --> 51:53.420
就是start小于的0

51:53.420 --> 51:54.420
对吧

51:54.420 --> 51:55.420
我也不知道为什么

51:55.420 --> 51:57.420
你先把这个错误答案去掉

51:58.420 --> 51:59.420
因为这个范围的一块

51:59.420 --> 52:00.420
会边过来边过去

52:00.420 --> 52:01.420
先做这个范围再做这个范围

52:01.420 --> 52:02.420
边来边去

52:02.420 --> 52:03.420
我都搞不清楚

52:03.420 --> 52:04.420
他有没有可能把

52:04.420 --> 52:06.420
把这个范围变到小于0了

52:06.420 --> 52:07.420
最小下边小于0

52:07.420 --> 52:08.420
那肯定不行啊

52:09.420 --> 52:10.420
你如果说不能确定

52:10.420 --> 52:11.420
他有没有这种情况

52:11.420 --> 52:13.420
你干脆把去掉等了

52:13.420 --> 52:14.420
对吧

52:14.420 --> 52:15.420
减少错误答案

52:15.420 --> 52:16.420
或者是end大于的

52:16.420 --> 52:17.420
要什么呢

52:18.420 --> 52:22.250
带到最大下边

52:22.250 --> 52:24.250
这些都是有问题的

52:24.250 --> 52:26.250
范围有问题

52:27.250 --> 52:28.250
有问题怎么办

52:28.250 --> 52:29.250
就不怎么办

52:29.250 --> 52:30.250
就啥都不做

52:31.250 --> 52:32.250
范围有问题就啥都不做

52:32.250 --> 52:33.250
对吧

52:33.250 --> 52:34.250
我们先把这个错误答案去掉

52:34.250 --> 52:35.250
错误答案一去掉

52:35.250 --> 52:36.250
是不是剩下的全是正确范围

52:36.250 --> 52:37.250
一个范围

52:37.250 --> 52:38.250
我不管别的

52:38.250 --> 52:40.250
这个范围至少是正确的

52:41.250 --> 52:42.250
对吧

52:42.250 --> 52:43.250
至少范围是没问题的

52:44.250 --> 52:45.250
好 那么现在

52:45.250 --> 52:47.250
范围没有问题了

52:47.250 --> 52:52.930
没有问题又杂判了

52:52.930 --> 52:53.930
这个时候

52:53.930 --> 52:55.930
先告诉你方案

52:56.930 --> 52:57.930
先告诉你方案

52:57.930 --> 52:58.930
然后呢

52:58.930 --> 52:59.930
我们也把代码写出来

52:59.930 --> 53:01.930
方案你可能想的话

53:01.930 --> 53:03.930
不是很容易想出来

53:03.930 --> 53:04.930
你知道我小的靠左

53:04.930 --> 53:05.930
大的靠右

53:05.930 --> 53:06.930
但是你不知道

53:06.930 --> 53:07.930
怎么去靠左怎么去靠右

53:07.930 --> 53:08.930
我现在给了一个方案

53:09.930 --> 53:10.930
然后呢

53:10.930 --> 53:13.820
我们尝试着把代码写出来

53:13.820 --> 53:14.820
生息口气啊

53:14.820 --> 53:15.820
他们怎么办

53:15.820 --> 53:18.380
什么方案呢

53:19.380 --> 53:20.380
首先找一个

53:20.380 --> 53:22.380
现在范围一定是正确的

53:22.380 --> 53:23.380
一定是正确的范围

53:23.380 --> 53:25.380
因为错误的范围已经去掉了

53:26.380 --> 53:28.380
我先用一个变量low

53:28.380 --> 53:29.380
表示低位

53:30.380 --> 53:31.380
来记录

53:31.380 --> 53:32.380
你这个范围的

53:32.380 --> 53:34.380
一开始是记录这个范围的最小

53:34.380 --> 53:36.380
最小的位置

53:36.380 --> 53:37.380
你说用low呢

53:37.380 --> 53:38.380
就是现在我们用一个变量low

53:38.380 --> 53:40.380
来等于start

53:40.380 --> 53:41.380
然后用个变量的

53:41.380 --> 53:42.380
high

53:42.380 --> 53:44.380
高位等于end

53:44.380 --> 53:45.380
为什么要同心动作

53:45.380 --> 53:46.380
两个变量

53:46.380 --> 53:47.380
因为这两个变量要变

53:47.380 --> 53:48.380
这两个变量不能变

53:48.380 --> 53:50.380
我不希望它变化

53:50.380 --> 53:51.380
以后还要用的

53:51.380 --> 53:52.380
就这两个东西

53:53.380 --> 53:54.380
一个low

53:54.380 --> 53:55.380
一个high

53:55.380 --> 53:56.380
等于这个范围

53:56.380 --> 53:57.380
比方就这个范围

53:57.380 --> 53:59.380
或者是这个范围也行

53:59.380 --> 54:00.380
无所谓

54:00.380 --> 54:01.380
不要等于一个范围

54:03.380 --> 54:05.380
然后还需要一个变量T

54:05.380 --> 54:07.380
来记录一个基准值

54:07.380 --> 54:09.380
不是要一个数为基础吗

54:09.380 --> 54:10.380
对不对

54:10.380 --> 54:12.380
所以还需要一个变量T

54:12.380 --> 54:14.380
来记录它的基准值

54:14.380 --> 54:15.380
基准值是啥呢

54:15.380 --> 54:17.380
基准值就是随便取一个吧

54:17.380 --> 54:18.380
比方就最后一位

54:18.380 --> 54:19.380
最后一位的话

54:19.380 --> 54:20.380
我们可以用

54:20.380 --> 54:21.380
什么

54:22.380 --> 54:24.380
这个范围内的最后一位

54:24.380 --> 54:25.380
这个范围内的最后一位

54:25.380 --> 54:26.380
是不是就是

54:30.380 --> 54:31.380
这是基准值

54:31.380 --> 54:35.820
这是高位

54:35.820 --> 54:37.820
高位游标

54:38.820 --> 54:40.820
它不断的游走的

54:40.820 --> 54:45.350
这是低位游标

54:45.350 --> 54:46.350
这三个东西有了

54:46.350 --> 54:47.350
那么接下来可以玩了

54:47.350 --> 54:48.350
怎么玩

54:48.350 --> 54:51.370
看清楚了

54:51.370 --> 54:52.370
我的目标就是

54:52.370 --> 54:54.370
低位不断的往上

54:54.370 --> 54:56.370
往上靠

54:56.370 --> 54:58.370
高位不断的往下靠

54:58.370 --> 55:00.370
直到两个桌标重合

55:00.370 --> 55:01.370
结束

55:01.370 --> 55:03.370
不要再靠了

55:03.370 --> 55:05.370
凡是低位

55:05.370 --> 55:07.370
低位这个箭头经过了位置

55:07.370 --> 55:09.370
一定要比它小

55:09.370 --> 55:11.370
高位这个箭头经过了位置

55:11.370 --> 55:15.130
一定要比它大

55:15.130 --> 55:17.130
用这个东西往后边扫一遍

55:17.130 --> 55:19.130
前面全部比它小

55:19.130 --> 55:21.130
用这个往前面扫一遍

55:21.130 --> 55:22.130
全部比它大

55:22.130 --> 55:24.130
那具体怎么做呢

55:24.130 --> 55:27.890
第一次

55:27.890 --> 55:30.890
第一次

55:30.890 --> 55:32.890
每一次分成两次移动

55:32.890 --> 55:34.890
每一次先移动低位再移动高位

55:34.890 --> 55:36.890
第一次先移动低位

55:36.890 --> 55:38.890
首先看低位目前的位置

55:38.890 --> 55:39.890
是不是比它小

55:39.890 --> 55:40.890
比它小

55:40.890 --> 55:42.890
继续往后移动

55:42.890 --> 55:44.890
然后再看这个位置

55:44.890 --> 55:45.890
是不是比它小

55:45.890 --> 55:46.890
比它大了

55:46.890 --> 55:47.890
比它大了过后

55:47.890 --> 55:48.890
马上把这一位

55:48.890 --> 55:50.890
因为比它大的

55:50.890 --> 55:52.890
所以把大的往高位扔

55:52.890 --> 55:55.890
把大的往高位这个位置扔

55:55.890 --> 55:56.890
这个玩意儿指向了

55:56.890 --> 55:57.890
它一定是比它大的

55:57.890 --> 55:58.890
往高位这个位置扔

55:58.890 --> 55:59.890
好

55:59.890 --> 56:00.890
它不动了

56:00.890 --> 56:01.890
它等着

56:01.890 --> 56:02.890
因为这一位是不是有问题

56:02.890 --> 56:03.890
低位这里是不是有问题

56:03.890 --> 56:04.890
对不对

56:04.890 --> 56:05.890
有问题就等着

56:05.890 --> 56:07.890
等着高位移动

56:07.890 --> 56:09.890
高位往前面移动

56:09.890 --> 56:10.890
高位目前比它大

56:10.890 --> 56:11.890
比这个是大

56:11.890 --> 56:12.890
不动

56:12.890 --> 56:13.890
往前面移动

56:13.890 --> 56:14.890
7比4大

56:14.890 --> 56:15.890
不动

56:15.890 --> 56:16.890
6比4大

56:16.890 --> 56:17.890
不动

56:17.890 --> 56:19.890
1比4小

56:19.890 --> 56:21.890
那么这一位是不是要往前扔

56:21.890 --> 56:22.890
怎么扔到哪去

56:22.890 --> 56:24.890
刚才低位这里是不是要等着

56:24.890 --> 56:26.890
它说这一位是有问题的

56:26.890 --> 56:27.890
对吧

56:27.890 --> 56:29.890
那么就把这一位的1扔到这边去

56:29.890 --> 56:32.260
好

56:32.260 --> 56:35.260
一次移动结束

56:35.260 --> 56:36.260
一次移动

56:36.260 --> 56:37.260
移动低位移动高位

56:37.260 --> 56:39.260
一次移动结束

56:39.260 --> 56:40.260
好

56:40.260 --> 56:41.260
第二次移动

56:41.260 --> 56:42.260
又重新来

56:42.260 --> 56:43.260
又来

56:43.260 --> 56:44.260
也低位开始

56:44.260 --> 56:45.260
低位目前比它小

56:45.260 --> 56:46.260
ok

56:46.260 --> 56:47.260
继续移动

56:47.260 --> 56:48.260
3比它小

56:48.260 --> 56:49.260
继续移动

56:49.260 --> 56:50.260
好

56:50.260 --> 56:52.260
移动到这了

56:52.260 --> 56:53.260
本来我还想移动的

56:53.260 --> 56:55.260
但是没法移动了

56:56.260 --> 56:58.260
两个下标重合了

56:58.260 --> 57:00.260
重合了过后

57:00.260 --> 57:01.260
别再动了

57:01.260 --> 57:02.260
动也动不了了

57:02.260 --> 57:03.260
这个时候

57:03.260 --> 57:04.260
这一位

57:04.260 --> 57:07.260
就给它把这个几准数字扔过去

57:07.260 --> 57:09.770
好

57:09.770 --> 57:11.770
那么这一次就搞定了

57:11.770 --> 57:13.770
这一次就搞定了

57:13.770 --> 57:14.770
亏个数字就搞定了

57:14.770 --> 57:16.770
那么剩下的就是下一次的事情了

57:16.770 --> 57:17.770
下一次呢

57:17.770 --> 57:19.770
我们就是重新低规了

57:19.770 --> 57:20.770
这一次就搞定了

57:20.770 --> 57:21.770
再来一遍

57:21.770 --> 57:27.700
我现在干嘛呢

57:27.700 --> 57:28.700
我现在呢

57:28.700 --> 57:29.700
我一边

57:29.700 --> 57:30.700
第二次的时候呢

57:30.700 --> 57:31.700
我就一边写代码

57:31.700 --> 57:32.700
一边给它分析了

57:32.700 --> 57:33.700
我这里呢

57:33.700 --> 57:35.700
需要一个循环

57:35.700 --> 57:37.700
低位往上移动

57:37.700 --> 57:38.700
高位往下移动

57:38.700 --> 57:39.700
所以说循环的条件

57:39.700 --> 57:41.700
就是低位小于高位

57:41.700 --> 57:43.700
只要这个条件成立

57:43.700 --> 57:45.700
就还得继续动

57:45.700 --> 57:47.700
只有两个下标重叠

57:47.700 --> 57:48.700
你才能退出

57:48.700 --> 57:49.700
否则不能退出

57:49.700 --> 57:50.700
继续动

57:50.700 --> 57:52.700
每一次循环干嘛呢

57:52.700 --> 57:53.700
第一步

57:53.700 --> 57:54.700
低位

57:54.700 --> 57:57.700
向高位移动

57:58.700 --> 57:59.700
第二步

57:59.700 --> 58:00.700
高位

58:00.700 --> 58:01.700
向

58:01.700 --> 58:03.700
低位移动

58:03.700 --> 58:04.700
好,来吧

58:04.700 --> 58:05.700
第一步

58:05.700 --> 58:06.700
低位向高位移动

58:06.700 --> 58:07.700
怎么弄

58:07.700 --> 58:08.700
低位向高位移动

58:08.700 --> 58:10.700
只要比它小

58:10.700 --> 58:11.700
就加一

58:11.700 --> 58:12.700
只要比它大

58:12.700 --> 58:14.700
就停止

58:14.700 --> 58:15.700
那么低位向高位移动

58:15.700 --> 58:16.700
移动多好次

58:16.700 --> 58:18.700
是不是有得一个循环

58:18.700 --> 58:20.700
只要低位小于高位

58:20.700 --> 58:22.700
你不能移动太多

58:22.700 --> 58:23.700
重叠了

58:23.700 --> 58:24.700
并且

58:24.700 --> 58:26.700
低位的值

58:27.700 --> 58:29.700
目前低位的值

58:29.700 --> 58:30.700
小于

58:30.700 --> 58:31.700
等于也行

58:31.700 --> 58:33.700
小于等于

58:33.700 --> 58:34.700
这个t

58:34.700 --> 58:35.700
怎么办

58:35.700 --> 58:36.700
弄

58:37.700 --> 58:39.700
你看是不是个逻辑

58:39.700 --> 58:41.700
只要低位小于高位

58:41.700 --> 58:43.700
目前低位肯定是小于高位的下标

58:43.700 --> 58:45.700
然后低位的值

58:45.700 --> 58:47.700
小于这个基准值

58:47.700 --> 58:48.700
只要比它小

58:48.700 --> 58:50.700
那么说明个低位是合理的

58:50.700 --> 58:51.700
合理的基准往后看

58:51.700 --> 58:52.700
那比方说

58:52.700 --> 58:54.700
这里是一个2

58:54.700 --> 58:55.700
那么ok

58:55.700 --> 58:56.700
那么这里还是比它小

58:56.700 --> 58:57.700
对吧

58:57.700 --> 58:58.700
还得往后看

58:58.700 --> 58:59.700
还得往后看

58:59.700 --> 59:00.700
还得往后看

59:00.700 --> 59:01.700
直到比它大

59:01.700 --> 59:02.700
对吧

59:02.700 --> 59:03.700
直到比它大

59:03.700 --> 59:04.700
停止

59:04.700 --> 59:05.700
或者是全部都比它小

59:05.700 --> 59:06.700
然后这里3

59:06.700 --> 59:07.700
这里2

59:07.700 --> 59:08.700
全部比它小

59:08.700 --> 59:10.700
那么两个重叠了也得停止了

59:10.700 --> 59:11.700
重叠了也得停止

59:11.700 --> 59:13.700
懂我的意思吗

59:14.700 --> 59:17.700
找到第一个比它大的停止

59:17.700 --> 59:19.700
或者是重叠了停止

59:19.700 --> 59:21.700
停止过后干嘛

59:21.700 --> 59:23.700
停止过后干嘛

59:23.700 --> 59:25.700
因为低位指向这个位置

59:25.700 --> 59:26.700
是有问题的

59:26.700 --> 59:27.700
这个位置不应该在这

59:27.700 --> 59:28.700
对吧

59:28.700 --> 59:29.700
还是比它大的

59:29.700 --> 59:30.700
应该往它右边靠

59:30.700 --> 59:31.700
右边说高位

59:31.700 --> 59:33.700
直接扔到高位去

59:33.700 --> 59:34.700
看看

59:34.700 --> 59:35.700
直接往高位扔就行了

59:35.700 --> 59:37.700
因为高位有个指针在这

59:37.700 --> 59:38.700
所以右边要在这

59:38.700 --> 59:39.700
直接扔就行了

59:39.700 --> 59:40.700
所以说这里该怎么写

59:40.700 --> 59:41.700
那么是

59:41.700 --> 59:42.700
高位这个值

59:42.700 --> 59:44.700
应该等于什么

59:44.700 --> 59:46.700
等于目前低位这个值

59:46.700 --> 59:47.700
就扔过去

59:47.700 --> 59:48.700
对吧

59:48.700 --> 59:51.700
把当前不合理的数字

59:51.700 --> 59:52.700
扔到

59:52.700 --> 59:56.850
高位去

59:56.850 --> 59:57.850
去

59:57.850 --> 59:58.850
好了嘛

59:58.850 --> 59:59.850
低位移动完成

59:59.850 --> 01:00:00.850
好

01:00:00.850 --> 01:00:01.850
这次上面玩

01:00:01.850 --> 01:00:02.850
还有高位还要移动

01:00:02.850 --> 01:00:03.850
对吧

01:00:03.850 --> 01:00:04.850
高位还得移动

01:00:04.850 --> 01:00:05.850
高位得往前移动

01:00:05.850 --> 01:00:06.850
只要比它大

01:00:06.850 --> 01:00:07.850
就可以移动

01:00:07.850 --> 01:00:08.850
只要比它大就可以移动

01:00:08.850 --> 01:00:09.850
那么逻辑是不是一样的

01:00:09.850 --> 01:00:13.890
坏了

01:00:13.890 --> 01:00:14.890
只要这个

01:00:14.890 --> 01:00:15.890
Hi

01:00:15.890 --> 01:00:17.890
大于等于T

01:00:17.890 --> 01:00:20.890
是不是高位得减减

01:00:20.890 --> 01:00:21.890
对吧

01:00:21.890 --> 01:00:23.890
高位得向低位移动

01:00:23.890 --> 01:00:24.890
得减减

01:00:24.890 --> 01:00:25.890
你看

01:00:25.890 --> 01:00:26.890
这里是不是一直的移动

01:00:26.890 --> 01:00:27.890
大移动

01:00:27.890 --> 01:00:28.890
7比4大移动

01:00:28.890 --> 01:00:29.890
6比4大移动

01:00:29.890 --> 01:00:30.890
继续移动

01:00:30.890 --> 01:00:32.890
1比4小

01:00:32.890 --> 01:00:34.890
那么这个时候是不是移不动了

01:00:34.890 --> 01:00:35.890
移不动干嘛

01:00:35.890 --> 01:00:37.890
说明这个位置不合理

01:00:37.890 --> 01:00:39.890
它应该往低位扔

01:00:39.890 --> 01:00:40.890
对不对

01:00:40.890 --> 01:00:41.890
是不是又写过来

01:00:41.890 --> 01:00:44.890
那么等于

01:00:44.890 --> 01:00:45.890
我不知道这个权王

01:00:45.890 --> 01:00:47.890
还有没有比讲的比则更详细的

01:00:47.890 --> 01:00:49.890
我已经是进地了

01:00:49.890 --> 01:00:51.890
应该找不到比则更详细的了

01:00:51.890 --> 01:00:53.890
往低位扔

01:00:53.890 --> 01:00:55.890
那么这个移数扔过去

01:00:55.890 --> 01:00:57.890
第一次移动结束了

01:00:57.890 --> 01:00:58.890
进入下次循环

01:00:58.890 --> 01:01:00.890
但是发现低位还是比高位小

01:01:00.890 --> 01:01:01.890
还没有重叠

01:01:01.890 --> 01:01:02.890
别的重叠又继续

01:01:02.890 --> 01:01:03.890
又重新来一次

01:01:03.890 --> 01:01:05.890
低位移动

01:01:05.890 --> 01:01:06.890
这一次移动

01:01:06.890 --> 01:01:07.890
就重叠了

01:01:07.890 --> 01:01:08.890
那么就重叠了

01:01:08.890 --> 01:01:09.890
一重叠完了过后

01:01:09.890 --> 01:01:10.890
是不是

01:01:10.890 --> 01:01:12.890
这里的条件就结束了

01:01:12.890 --> 01:01:14.890
现在两个位置重叠了

01:01:14.890 --> 01:01:16.890
这个负责等于没负责

01:01:16.890 --> 01:01:18.890
那么这个循环进不去了

01:01:18.890 --> 01:01:19.890
两个位置已经重叠了

01:01:19.890 --> 01:01:22.890
那么外面的循环就推出了

01:01:22.890 --> 01:01:24.890
于是单码是不是到了这

01:01:24.890 --> 01:01:26.890
外面的循环推出了过后

01:01:26.890 --> 01:01:28.890
高位低位

01:01:28.890 --> 01:01:32.460
重叠

01:01:32.460 --> 01:01:34.460
重叠的时候

01:01:34.460 --> 01:01:36.460
是不是重叠的时候就是等这个基准值

01:01:36.460 --> 01:01:37.460
一直在等着对吧

01:01:37.460 --> 01:01:39.460
基准值就要等着了

01:01:39.460 --> 01:01:41.460
就把这个基准值扔过去就行了

01:01:41.460 --> 01:01:43.460
那么这个是高位和低位是相等的

01:01:43.460 --> 01:01:44.460
那无所谓的

01:01:44.460 --> 01:01:45.460
那么这里就是

01:01:45.460 --> 01:01:46.460
这里写开也好

01:01:46.460 --> 01:01:47.460
写楼也好

01:01:47.460 --> 01:01:48.460
无所谓

01:01:48.460 --> 01:01:49.460
都一样

01:01:49.460 --> 01:01:50.460
反而是重叠的

01:01:50.460 --> 01:01:51.460
所以说这里写什么

01:01:51.460 --> 01:01:54.460
把这个气质扔过去

01:01:54.460 --> 01:01:55.460
扔过去

01:01:56.460 --> 01:01:57.460
结束了

01:01:57.460 --> 01:01:59.460
这一次快排就结束了

01:01:59.460 --> 01:02:00.460
基准值比他小的

01:02:00.460 --> 01:02:01.460
全部在左边

01:02:01.460 --> 01:02:04.980
你看没

01:02:04.980 --> 01:02:05.980
比他小的全部在左边

01:02:05.980 --> 01:02:07.980
比他大的全部在右边

01:02:08.980 --> 01:02:14.050
好

01:02:14.050 --> 01:02:15.050
那么这一次完了过后

01:02:15.050 --> 01:02:16.050
整个排序完了吗

01:02:16.050 --> 01:02:17.050
没有

01:02:17.050 --> 01:02:19.050
是不是还得在这个范围内

01:02:19.050 --> 01:02:21.050
重新来一次

01:02:21.050 --> 01:02:23.050
整个过程全部重新来一次

01:02:23.050 --> 01:02:24.050
在这个范围内

01:02:24.050 --> 01:02:25.050
全部重新来一次对吧

01:02:25.050 --> 01:02:26.050
那么也就说

01:02:26.050 --> 01:02:29.050
对左边的范围

01:02:29.050 --> 01:02:31.050
重来一次

01:02:31.050 --> 01:02:34.050
对右边的范围

01:02:34.050 --> 01:02:35.050
重来一次

01:02:35.050 --> 01:02:36.050
那么左边的范围

01:02:36.050 --> 01:02:37.050
重来一次

01:02:37.050 --> 01:02:38.050
那么是不是又重新调问

01:02:38.050 --> 01:02:40.550
这个推个哨子

01:02:40.550 --> 01:02:41.550
其次的目标是什么

01:02:41.550 --> 01:02:42.550
其次目标是什么

01:02:42.550 --> 01:02:44.550
就是以前的start

01:02:44.550 --> 01:02:46.550
所以以前的位置start

01:02:46.550 --> 01:02:48.550
结束桌标是什么

01:02:48.550 --> 01:02:49.550
结束桌标是目前的

01:02:49.550 --> 01:02:50.550
这两个是重叠的

01:02:50.550 --> 01:02:51.550
无所谓

01:02:51.550 --> 01:02:54.550
目前的这个桌标简易

01:02:54.550 --> 01:02:55.550
对不对

01:02:55.550 --> 01:02:56.550
楼简易

01:02:56.550 --> 01:02:57.550
还简易

01:02:57.550 --> 01:02:58.550
都一样

01:02:58.550 --> 01:02:59.550
重叠的

01:03:00.550 --> 01:03:01.550
左边的是不是重来一次

01:03:01.550 --> 01:03:02.550
对右边的也重来一次

01:03:02.550 --> 01:03:03.550
quick sort

01:03:05.550 --> 01:03:06.550
然后呢是

01:03:06.550 --> 01:03:07.550
右边的是什么

01:03:07.550 --> 01:03:08.550
楼加1

01:03:08.550 --> 01:03:09.550
对吧

01:03:09.550 --> 01:03:10.550
从这里开始

01:03:10.550 --> 01:03:11.550
到什么

01:03:11.550 --> 01:03:13.990
到end

01:03:13.990 --> 01:03:14.990
楼加1

01:03:14.990 --> 01:03:15.990
到end

01:03:15.990 --> 01:03:17.990
就写完了

01:03:17.990 --> 01:03:21.200
这是快排

01:03:21.200 --> 01:03:22.200
来吧

01:03:22.200 --> 01:03:25.340
试一下

01:03:25.340 --> 01:03:26.340
quick sort

01:03:26.340 --> 01:03:27.340
那么

01:03:30.740 --> 01:03:32.740
有问题是吧

01:03:32.740 --> 01:03:34.740
看一下那里有问题

01:03:35.740 --> 01:03:39.250
这里没有排序出来

01:03:39.250 --> 01:03:44.220
看一下那里有问题

01:03:44.220 --> 01:03:46.220
低位小于高位

01:03:46.220 --> 01:03:48.220
都小于等于quick

01:03:48.220 --> 01:03:49.220
小于等于quick是没问题的

01:03:49.220 --> 01:03:50.220
楼加加

01:03:51.220 --> 01:03:53.220
低位能过去

01:03:53.220 --> 01:03:55.220
高位大于等于quick

01:03:55.220 --> 01:03:56.220
还简洁

01:03:57.220 --> 01:04:01.300
高位能到低位去

01:04:01.300 --> 01:04:03.300
现在就高低位重叠了

01:04:03.300 --> 01:04:06.000
quick

01:04:06.000 --> 01:04:07.000
没问题

01:04:09.570 --> 01:04:13.420
有问题

01:04:13.420 --> 01:04:14.420
那么这个时候我调试一下

01:04:14.420 --> 01:04:15.420
调试一下

01:04:15.420 --> 01:04:17.420
有没有同学看到我哪里有问题的

01:04:18.420 --> 01:04:20.420
start大于等于end

01:04:20.420 --> 01:04:21.420
low

01:04:25.690 --> 01:04:26.690
start

01:04:27.690 --> 01:04:29.690
衣服循环

01:04:30.690 --> 01:04:32.690
哪里有衣服循环

01:04:32.690 --> 01:04:33.690
没关系

01:04:33.690 --> 01:04:34.690
我调试一下吧

01:04:34.690 --> 01:04:35.690
被找到的话

01:04:35.690 --> 01:04:36.690
就调试一下

01:04:36.690 --> 01:04:37.690
调试一下

01:04:37.690 --> 01:04:38.690
就开始知道哪里有问题了

01:04:38.690 --> 01:04:39.690
找到这个

01:04:39.690 --> 01:04:40.690
调试的时候

01:04:40.690 --> 01:04:41.690
找到这个sources

01:04:41.690 --> 01:04:42.690
就找到我们的原代吧

01:04:42.690 --> 01:04:43.690
原代吧

01:04:43.690 --> 01:04:44.690
这里不是我们先来调用这个函数吗

01:04:44.690 --> 01:04:45.690
quick sort

01:04:45.690 --> 01:04:46.690
对吧

01:04:47.690 --> 01:04:48.690
来吧

01:04:48.690 --> 01:04:50.690
来看一下到底有什么问题

01:04:50.690 --> 01:04:52.690
目前那个数组是这样子的

01:04:53.690 --> 01:04:54.690
快排

01:04:54.690 --> 01:04:57.000
运行到这

01:04:57.000 --> 01:04:58.000
那么这个时候

01:04:58.000 --> 01:04:59.000
start为你

01:04:59.000 --> 01:05:00.000
end为5

01:05:00.000 --> 01:05:01.000
这个都没问题

01:05:01.000 --> 01:05:02.000
然后继续

01:05:04.000 --> 01:05:05.000
返回了

01:05:06.000 --> 01:05:08.000
刚才说返回有问题的

01:05:08.000 --> 01:05:09.000
返回怎么会有问题

01:05:10.000 --> 01:05:11.000
返回是没问题的

01:05:13.000 --> 01:05:14.000
我看一下

01:05:14.000 --> 01:05:15.000
它就返回了

01:05:15.000 --> 01:05:16.000
这里是有问题的

01:05:16.000 --> 01:05:17.000
0小于等于5没问题

01:05:18.000 --> 01:05:19.000
start

01:05:20.000 --> 01:05:21.000
或者是start小于0

01:05:21.000 --> 01:05:22.000
那么这个是不小于0的

01:05:22.000 --> 01:05:23.000
对吧

01:05:29.000 --> 01:05:30.000
这是错误的答案

01:05:30.000 --> 01:05:31.000
错误的范围

01:05:32.000 --> 01:05:33.000
很多同学可能及时的

01:05:33.000 --> 01:05:35.000
早就看出来了

01:05:35.000 --> 01:05:36.000
这是错误的范围

01:05:36.000 --> 01:05:37.000
不过无所谓

01:05:37.000 --> 01:05:38.000
这个调试的话

01:05:38.000 --> 01:05:39.000
总会是能调试得到的

01:05:39.000 --> 01:05:40.000
因为它这里

01:05:40.000 --> 01:05:41.000
不应该进入return的

01:05:41.000 --> 01:05:42.000
但是它进了

01:05:42.000 --> 01:05:43.000
就这么几个条件

01:05:43.000 --> 01:05:44.000
一看就看明白

01:05:44.000 --> 01:05:45.000
好了

01:05:45.000 --> 01:05:46.000
再说一刷新一次

01:05:47.000 --> 01:05:48.000
那么

01:05:49.000 --> 01:05:50.000
这边没问题了

01:05:50.000 --> 01:05:51.000
好

01:05:51.000 --> 01:05:52.000
这就是快速排序

01:05:55.440 --> 01:05:56.440
怎么样还撑得住吗

01:05:58.440 --> 01:05:59.440
快排

01:06:02.070 --> 01:06:04.070
快排能听懂的话可以了

01:06:04.070 --> 01:06:05.070
我看一下

01:06:05.070 --> 01:06:07.070
可能不是很多

01:06:07.070 --> 01:06:12.940
也不会一个都没有吧

01:06:12.940 --> 01:06:16.730
对

01:06:16.730 --> 01:06:17.730
是快排

01:06:17.730 --> 01:06:21.380
有些人感觉

01:06:22.380 --> 01:06:23.380
慢慢就消化吧

01:06:23.380 --> 01:06:25.380
反正后边有杜博

01:06:25.380 --> 01:06:26.380
你如果说

01:06:26.380 --> 01:06:29.380
你能够脱离老舍代码

01:06:30.380 --> 01:06:32.380
能够把快排写出来

01:06:32.380 --> 01:06:33.380
你的思维逻辑

01:06:33.380 --> 01:06:34.380
就已经不错了

01:06:34.380 --> 01:06:35.380
就很强了

01:06:35.380 --> 01:06:36.380
真的就很强了

01:06:36.380 --> 01:06:38.380
你能够完全不看老舍代码

01:06:38.380 --> 01:06:39.380
也就纯粹的

01:06:39.380 --> 01:06:41.380
把听懂之后

01:06:41.380 --> 01:06:43.380
纯粹的根据我们的那个

01:06:44.380 --> 01:06:45.380
方法

01:06:45.380 --> 01:06:46.380
去分析

01:06:46.380 --> 01:06:48.380
然后把代码一行一行

01:06:48.380 --> 01:06:49.380
按照自己的理解

01:06:49.380 --> 01:06:50.380
把它撬出来

01:06:51.380 --> 01:06:52.380
就非常非常厉害了

01:06:53.380 --> 01:06:54.380
那你解决很多以后

01:06:54.380 --> 01:06:55.380
在工作中遇到的

01:06:55.380 --> 01:06:57.380
很多那些效果问题

01:06:57.380 --> 01:06:58.380
都不是不成画

01:06:58.380 --> 01:06:59.380
不再画下了

01:07:00.380 --> 01:07:01.380
说咱们算法的是

01:07:01.380 --> 01:07:03.380
培育大家有这样的

01:07:03.380 --> 01:07:04.380
一种思维能力

01:07:04.380 --> 01:07:05.380
就给力方案的

01:07:05.380 --> 01:07:06.380
方案都给力了

01:07:06.380 --> 01:07:07.380
能不能把代码写出来

01:07:08.380 --> 01:07:09.380
看吧

01:07:09.380 --> 01:07:10.380
你看

01:07:10.380 --> 01:07:11.380
还真有这样的同学

01:07:11.380 --> 01:07:12.380
看吧

01:07:12.380 --> 01:07:13.380
感觉最容易的

01:07:14.380 --> 01:07:15.380
有这样的同学

01:07:15.380 --> 01:07:16.380
他觉得快排很容易

01:07:17.380 --> 01:07:18.380
好 那么排序

01:07:18.380 --> 01:07:19.380
我们今天就讲到这

01:07:20.380 --> 01:07:21.380
讲到这了

01:07:21.380 --> 01:07:22.380
好 接下来

01:07:22.380 --> 01:07:23.380
剩下一点点时间

01:07:23.380 --> 01:07:24.380
十多分钟

01:07:24.380 --> 01:07:25.380
我们来剪一些

01:07:25.380 --> 01:07:26.380
轻松一下

01:07:26.380 --> 01:07:27.380
轻松一下

01:07:27.380 --> 01:07:28.380
查讯算法

01:07:28.380 --> 01:07:29.380
查讯算法是将来

01:07:29.380 --> 01:07:32.270
要说比较简单的

01:07:32.270 --> 01:07:33.270
是

01:07:33.270 --> 01:07:38.850
啥叫查讯算法呢

01:07:42.060 --> 01:07:43.060
就是在一个数组里边

01:07:43.060 --> 01:07:44.060
你去找一个

01:07:44.060 --> 01:07:45.060
我们想要的东西

01:07:45.060 --> 01:07:47.060
看着有没有找到

01:07:47.060 --> 01:07:48.060
找到就返回去

01:07:48.060 --> 01:07:49.060
没有找到就返回force

01:07:49.060 --> 01:07:50.060
就这么简单

01:07:50.060 --> 01:07:51.060
这就是查找

01:07:51.060 --> 01:07:56.740
查到了五遍上

01:07:56.740 --> 01:07:57.740
咱们有三种查到方式

01:07:57.740 --> 01:07:59.740
第一种方式就是顺序查找

01:08:00.740 --> 01:08:01.740
就是穷局法

01:08:01.740 --> 01:08:02.740
啥意思呢

01:08:02.740 --> 01:08:03.740
就是一个一个看

01:08:03.740 --> 01:08:04.740
它是不是

01:08:04.740 --> 01:08:05.740
不是

01:08:05.740 --> 01:08:06.740
它是不是

01:08:06.740 --> 01:08:07.740
不是

01:08:07.740 --> 01:08:08.740
它是不是

01:08:08.740 --> 01:08:09.740
是

01:08:09.740 --> 01:08:10.740
找到了

01:08:10.740 --> 01:08:11.740
返回去

01:08:11.740 --> 01:08:12.740
从穷局法没啥好说的

01:08:12.740 --> 01:08:13.740
我们就

01:08:14.740 --> 01:08:15.740
直接写出来了

01:08:15.740 --> 01:08:16.740
有大部分都知道

01:08:16.740 --> 01:08:17.740
就是

01:08:19.740 --> 01:08:20.740
order

01:08:20.740 --> 01:08:25.750
order search

01:08:25.750 --> 01:08:26.750
你给我一个数组

01:08:26.750 --> 01:08:28.750
给我一个目标值

01:08:28.750 --> 01:08:29.750
我要看一下

01:08:29.750 --> 01:08:30.750
这个目标值

01:08:30.750 --> 01:08:31.750
存不存在

01:08:31.750 --> 01:08:35.130
顺序查找

01:08:35.130 --> 01:08:36.130
看这个数组里边

01:08:36.130 --> 01:08:37.130
有没有存在这个目标值

01:08:37.130 --> 01:08:38.130
存在就返回去

01:08:39.130 --> 01:08:40.130
休息一下

01:08:47.130 --> 01:08:48.130
就循环

01:08:48.130 --> 01:08:49.130
一个一个拿出来看

01:08:49.130 --> 01:08:50.130
如果说

01:08:52.130 --> 01:08:53.130
等于什么

01:08:54.130 --> 01:08:55.130
就找到了

01:08:55.130 --> 01:08:56.130
找到干嘛

01:08:57.130 --> 01:08:58.130
找到了

01:08:59.130 --> 01:09:00.130
return to

01:09:00.130 --> 01:09:01.130
对不对

01:09:01.130 --> 01:09:02.130
就玩笑了

01:09:02.130 --> 01:09:03.130
然后呢

01:09:03.130 --> 01:09:04.130
没有找到的话

01:09:04.130 --> 01:09:05.130
就return force

01:09:05.130 --> 01:09:06.130
这里常见的

01:09:06.130 --> 01:09:08.130
出错的地方在哪呢

01:09:08.130 --> 01:09:09.130
在于初学者

01:09:09.130 --> 01:09:10.130
在初学者

01:09:10.130 --> 01:09:12.130
刚刚接触循环的时候

01:09:12.130 --> 01:09:13.130
遇到这种查找问题

01:09:13.130 --> 01:09:15.130
他很有可能写成这样的代码

01:09:16.130 --> 01:09:17.130
他很有可能写成这样的代码

01:09:17.130 --> 01:09:18.130
那么这样的代码

01:09:18.130 --> 01:09:20.130
逻辑错误在哪呢

01:09:21.130 --> 01:09:22.130
在于他看了第1个

01:09:22.130 --> 01:09:23.130
他就不看了

01:09:24.130 --> 01:09:25.130
就让你找人一样

01:09:25.130 --> 01:09:26.130
对吧

01:09:26.130 --> 01:09:27.130
然后你在学校里边

01:09:27.130 --> 01:09:28.130
找个人

01:09:28.130 --> 01:09:29.130
你在形式里边

01:09:29.130 --> 01:09:30.130
看一下我的好机友

01:09:30.130 --> 01:09:31.130
在哪个形式

01:09:31.130 --> 01:09:32.130
目前在哪个形式

01:09:32.130 --> 01:09:33.130
你这一层楼

01:09:33.130 --> 01:09:34.130
有20个形式

01:09:34.130 --> 01:09:35.130
结果你只看了第1个

01:09:36.130 --> 01:09:37.130
第1个他不在

01:09:37.130 --> 01:09:38.130
他不在你就认为

01:09:38.130 --> 01:09:39.130
他不在这层楼了

01:09:39.130 --> 01:09:40.130
那不对的

01:09:40.130 --> 01:09:41.130
对吧

01:09:41.130 --> 01:09:42.130
你还得继续看后边的

01:09:42.130 --> 01:09:43.130
如果说第1个

01:09:43.130 --> 01:09:44.130
他在

01:09:44.130 --> 01:09:45.130
他在就找到了

01:09:45.130 --> 01:09:46.130
他可以停止

01:09:46.130 --> 01:09:47.130
不用再找了

01:09:47.130 --> 01:09:48.130
还能这么傻

01:09:48.130 --> 01:09:49.130
我第1个

01:09:49.130 --> 01:09:50.130
请示我就看到他了

01:09:50.130 --> 01:09:51.130
结果我还要跑出去

01:09:51.130 --> 01:09:52.130
把世界的请示

01:09:52.130 --> 01:09:53.130
全部看完

01:09:53.130 --> 01:09:56.020
那我疯了

01:09:56.020 --> 01:09:57.020
但是呢

01:09:57.020 --> 01:09:58.020
如果说你第1个

01:09:58.020 --> 01:09:59.020
其实没有找到

01:09:59.020 --> 01:10:00.020
没有找到你是不能停的

01:10:00.020 --> 01:10:01.020
你还得继续往后看

01:10:01.020 --> 01:10:02.020
所以说你这样子

01:10:02.020 --> 01:10:03.020
如果说你这样的代码

01:10:03.020 --> 01:10:04.020
写出来

01:10:04.020 --> 01:10:05.020
你就看了第1个

01:10:05.020 --> 01:10:06.020
第1个找到了

01:10:06.020 --> 01:10:07.020
第1个没有找到

01:10:07.020 --> 01:10:10.020
你得把他看完

01:10:10.020 --> 01:10:12.020
看完了之后

01:10:12.020 --> 01:10:13.020
他都没有返回去

01:10:13.020 --> 01:10:14.020
说明都看完了之后

01:10:14.020 --> 01:10:15.020
整个都没有找到

01:10:15.020 --> 01:10:16.020
找到了

01:10:16.020 --> 01:10:17.020
他已经结束了

01:10:17.020 --> 01:10:18.020
对吧

01:10:18.020 --> 01:10:19.020
一定早就结束了

01:10:19.020 --> 01:10:20.020
循环都结束了

01:10:20.020 --> 01:10:21.020
代码都到了第12行了

01:10:21.020 --> 01:10:22.020
说明一定没有找到你

01:10:22.020 --> 01:10:23.020
你这个时候

01:10:23.020 --> 01:10:24.020
才能返回force

01:10:24.020 --> 01:10:25.020
主要错误在这

01:10:26.020 --> 01:10:27.020
这顺序查照

01:10:27.020 --> 01:10:28.020
顺序查照没啥好说的

01:10:28.020 --> 01:10:30.020
就是1个个去找

01:10:31.020 --> 01:10:32.020
主要说一下

01:10:32.020 --> 01:10:33.020
后边的2个

01:10:33.020 --> 01:10:34.020
一个是2分查照

01:10:34.020 --> 01:10:36.020
一个是差值查照

01:10:36.020 --> 01:10:37.020
因为顺序查照

01:10:37.020 --> 01:10:39.020
绝大部分的情况下

01:10:39.020 --> 01:10:40.020
也没办法

01:10:40.020 --> 01:10:41.020
因为很多时候

01:10:41.020 --> 01:10:42.020
你不顺序查照

01:10:42.020 --> 01:10:43.020
也没办法

01:10:43.020 --> 01:10:44.020
你得一个个看

01:10:44.020 --> 01:10:45.020
你也不知道

01:10:45.020 --> 01:10:46.020
后边的道理有没有

01:10:46.020 --> 01:10:48.020
顺序查照用了很多的

01:10:48.020 --> 01:10:50.020
但是有的时候

01:10:50.020 --> 01:10:51.020
不一样的

01:10:51.020 --> 01:10:52.020
有的时候

01:10:52.020 --> 01:10:53.020
我个数字比较特殊

01:10:53.020 --> 01:10:55.020
它可能是已经排好序的

01:10:55.020 --> 01:10:57.020
它可能是已经排好序的

01:10:57.020 --> 01:10:58.020
比方说

01:10:58.020 --> 01:11:05.020
1 2 3 4 5 6

01:11:05.020 --> 01:11:06.020
比方这么一个数字

01:11:06.020 --> 01:11:08.020
它已经排好序了

01:11:08.020 --> 01:11:09.020
那么这个时候

01:11:09.020 --> 01:11:11.020
你还需要一个一个去看吧

01:11:11.020 --> 01:11:12.020
就是如果说你假设

01:11:12.020 --> 01:11:14.020
这个数字已经是排好序的

01:11:14.020 --> 01:11:21.680
你还需要这样子

01:11:21.680 --> 01:11:25.400
一个一个去看

01:11:25.400 --> 01:11:30.400
这是针对排序好的数字

01:11:30.400 --> 01:11:32.400
2分查照

01:11:32.400 --> 01:11:33.400
杀一生

01:11:34.400 --> 01:11:36.400
就好比说吧

01:11:37.400 --> 01:11:39.400
你要去找人

01:11:39.400 --> 01:11:43.160
这个人呢

01:11:43.160 --> 01:11:46.160
在21号车厢

01:11:46.160 --> 01:11:49.160
你有必要从1号车厢移积去看吗

01:11:49.160 --> 01:11:50.160
没必要对吧

01:11:50.160 --> 01:11:52.160
你只需要快速定位到

01:11:52.160 --> 01:11:54.160
21号车厢在哪儿就行了

01:11:54.160 --> 01:11:55.160
对不对

01:11:55.160 --> 01:11:56.160
它已经是排好序的

01:11:56.160 --> 01:11:58.160
因为车厢都排好序的

01:11:58.160 --> 01:11:59.160
那么这里也是一样

01:11:59.160 --> 01:12:01.160
比方说从这个数组里面

01:12:01.160 --> 01:12:03.160
去找5这个数字

01:12:03.160 --> 01:12:05.160
有必要从1开始找吗

01:12:05.160 --> 01:12:07.160
没必要

01:12:07.160 --> 01:12:09.160
那怎么办呢

01:12:09.160 --> 01:12:10.160
我最好了就是

01:12:10.160 --> 01:12:11.160
比方说

01:12:11.160 --> 01:12:14.160
我们这里是这样子写吧

01:12:14.160 --> 01:12:20.160
5 6 7 8 9 10

01:12:20.160 --> 01:12:22.160
我要找9这个数字

01:12:22.160 --> 01:12:23.160
怎么找呢

01:12:23.160 --> 01:12:26.820
我可以这样

01:12:26.820 --> 01:12:29.820
我先找它中间这个

01:12:29.820 --> 01:12:30.820
我要找9对吧

01:12:30.820 --> 01:12:31.820
我要找它中间这个

01:12:31.820 --> 01:12:32.820
择办

01:12:32.820 --> 01:12:33.820
看这个玩意

01:12:33.820 --> 01:12:35.820
因为它已经排好序的

01:12:35.820 --> 01:12:38.820
我看一下9是比它大呢

01:12:38.820 --> 01:12:41.820
还是比它小呢

01:12:41.820 --> 01:12:45.820
如果说比它9比它小的话

01:12:45.820 --> 01:12:47.820
那我就在这边去找

01:12:47.820 --> 01:12:49.820
如果说9比它大的话

01:12:49.820 --> 01:12:50.820
我就在这边去找

01:12:50.820 --> 01:12:51.820
那么找这边的时候

01:12:51.820 --> 01:12:52.820
又用这种方式

01:12:52.820 --> 01:12:54.820
我这边去找一半

01:12:54.820 --> 01:12:55.820
找中间那个

01:12:55.820 --> 01:12:57.820
我看它9比它大呢

01:12:57.820 --> 01:12:59.820
还是比它小呢

01:12:59.820 --> 01:13:01.820
9比它小

01:13:01.820 --> 01:13:02.820
ok 我就看这

01:13:02.820 --> 01:13:03.820
就这个了

01:13:03.820 --> 01:13:04.820
那我看一下9

01:13:04.820 --> 01:13:05.820
跟它相等吧

01:13:05.820 --> 01:13:06.820
相等就找到了

01:13:06.820 --> 01:13:07.820
没法找不到

01:13:07.820 --> 01:13:09.820
没啥意思吧

01:13:09.820 --> 01:13:11.820
这就是2分插帐

01:13:11.820 --> 01:13:15.580
用2分插帐的模式

01:13:15.580 --> 01:13:17.580
好来吧

01:13:17.580 --> 01:13:19.580
那2分插到大插帐

01:13:19.580 --> 01:13:26.190
我需要有两个下标

01:13:26.190 --> 01:13:29.190
一个是小的下标

01:13:29.190 --> 01:13:31.190
一开始等于0嘛

01:13:31.190 --> 01:13:33.190
一个是大的下标

01:13:33.190 --> 01:13:36.190
一开始等于长度减1嘛

01:13:36.190 --> 01:13:37.190
对吧

01:13:37.190 --> 01:13:41.080
这是两个下标

01:13:41.080 --> 01:13:43.080
小的下标

01:13:43.080 --> 01:13:48.950
一个是大的下标

01:13:48.950 --> 01:13:49.950
只要这两个下

01:13:49.950 --> 01:13:50.950
只要它比它小

01:13:50.950 --> 01:13:51.950
因为这两个下标

01:13:51.950 --> 01:13:52.950
会不断的移动

01:13:52.950 --> 01:13:53.950
一开始小的在这

01:13:53.950 --> 01:13:54.950
大的在这

01:13:54.950 --> 01:13:55.950
结果找到中间

01:13:55.950 --> 01:13:56.950
不行

01:13:56.950 --> 01:13:57.950
这个范围内

01:13:57.950 --> 01:13:58.950
于是小的在这

01:13:58.950 --> 01:13:59.950
大的在这

01:13:59.950 --> 01:14:00.950
要不断的变动

01:14:00.950 --> 01:14:01.950
所以说我这里

01:14:01.950 --> 01:14:02.950
来写个循环

01:14:02.950 --> 01:14:04.950
如果说小的下标

01:14:04.950 --> 01:14:06.950
小的大的下标

01:14:06.950 --> 01:14:08.950
那这个循环还得继续

01:14:08.950 --> 01:14:10.950
还得找

01:14:10.950 --> 01:14:14.100
好

01:14:14.100 --> 01:14:15.100
那么找的时候

01:14:15.100 --> 01:14:17.100
怎么找呢

01:14:17.100 --> 01:14:20.470
找了说咋找呢

01:14:20.470 --> 01:14:21.470
我是不是可以

01:14:21.470 --> 01:14:24.470
去这个小的下标

01:14:24.470 --> 01:14:25.470
还有等于

01:14:25.470 --> 01:14:26.470
大于就不行了

01:14:26.470 --> 01:14:28.850
等于也可以

01:14:28.850 --> 01:14:31.850
我要根据这个小的下标

01:14:31.850 --> 01:14:32.850
和大的下标

01:14:32.850 --> 01:14:34.850
去算出一个中间下标

01:14:34.850 --> 01:14:35.850
你看一开始小的在这

01:14:35.850 --> 01:14:36.850
大的在这

01:14:36.850 --> 01:14:38.850
只不过可以算出一个中间下标

01:14:38.850 --> 01:14:39.850
我们看一下中间这个位置

01:14:39.850 --> 01:14:40.850
到底是比我

01:14:40.850 --> 01:14:42.850
找的数字大还是小

01:14:42.850 --> 01:14:43.850
对吧

01:14:43.850 --> 01:14:44.850
所以我们要算出一个

01:14:44.850 --> 01:14:45.850
中间下标

01:14:45.850 --> 01:14:49.420
列的

01:14:49.420 --> 01:14:55.990
中间下标

01:14:55.990 --> 01:14:57.990
中间下标等于什么呢

01:14:57.990 --> 01:14:58.990
举

01:14:58.990 --> 01:15:00.990
大的下标

01:15:00.990 --> 01:15:01.990
求平均值

01:15:01.990 --> 01:15:03.990
加上小的下标

01:15:03.990 --> 01:15:05.990
是不是除一二

01:15:05.990 --> 01:15:06.990
除一二它可能有小数

01:15:06.990 --> 01:15:08.990
所以说你卖

01:15:08.990 --> 01:15:10.990
除掉小数

01:15:10.990 --> 01:15:11.990
index

01:15:11.990 --> 01:15:12.990
加上

01:15:12.990 --> 01:15:13.990
index

01:15:13.990 --> 01:15:20.440
然后除一二

01:15:20.440 --> 01:15:21.440
除一二

01:15:21.440 --> 01:15:26.100
对不对

01:15:26.100 --> 01:15:29.100
就得到中间下标了

01:15:29.100 --> 01:15:30.100
那么中间下标

01:15:30.100 --> 01:15:31.100
拿到过后

01:15:31.100 --> 01:15:32.100
你看着

01:15:32.100 --> 01:15:34.100
中间下标拿到过后

01:15:34.100 --> 01:15:35.100
有的人可能看不懂

01:15:35.100 --> 01:15:36.100
这个循环

01:15:36.100 --> 01:15:37.100
看不懂循环

01:15:37.100 --> 01:15:38.100
我先不写循环

01:15:38.100 --> 01:15:39.100
我先不写循环

01:15:39.100 --> 01:15:40.100
我先这样子写

01:15:40.100 --> 01:15:41.100
小的下标是里央

01:15:41.100 --> 01:15:42.100
最大的下标是这个

01:15:42.100 --> 01:15:43.100
对吧

01:15:43.100 --> 01:15:44.100
然后呢

01:15:44.100 --> 01:15:45.100
选出中间下标

01:15:45.100 --> 01:15:46.100
拿到中间下标过后

01:15:46.100 --> 01:15:47.100
是不是看中间这个值

01:15:47.100 --> 01:15:48.100
判断一下

01:15:48.100 --> 01:15:50.100
中间这个值

01:15:50.100 --> 01:15:52.100
那么生命

01:15:52.100 --> 01:15:55.660
是不是等于

01:15:55.660 --> 01:15:56.660
等于什么呢

01:15:56.660 --> 01:15:58.660
等于topic

01:15:58.660 --> 01:16:00.660
是不是相等

01:16:00.660 --> 01:16:02.660
如果相等的话

01:16:02.660 --> 01:16:03.660
是不是找到了

01:16:04.660 --> 01:16:06.660
对不对

01:16:06.660 --> 01:16:07.660
就直接结束了

01:16:07.660 --> 01:16:08.660
找到了

01:16:08.660 --> 01:16:12.510
直接找中间

01:16:12.510 --> 01:16:14.510
不用一个一个去看了

01:16:14.510 --> 01:16:15.510
如果说不相等的话

01:16:15.510 --> 01:16:16.510
那看什么情况

01:16:16.510 --> 01:16:17.510
不相等的话

01:16:17.510 --> 01:16:18.510
有可能是中间

01:16:18.510 --> 01:16:19.510
这个位置的值

01:16:19.510 --> 01:16:22.510
比要早的值大

01:16:22.510 --> 01:16:23.510
咋意思

01:16:23.510 --> 01:16:24.510
比方说我要早的值

01:16:24.510 --> 01:16:26.510
是6

01:16:26.510 --> 01:16:28.510
中间这个值是

01:16:28.510 --> 01:16:29.510
8比6大

01:16:29.510 --> 01:16:31.510
是不是要往左边去看

01:16:31.510 --> 01:16:32.510
那是不是要改动

01:16:32.510 --> 01:16:33.510
这个下标范围

01:16:33.510 --> 01:16:35.510
重新来一遍

01:16:35.510 --> 01:16:36.510
对不对

01:16:36.510 --> 01:16:37.510
怎么改动这个范围

01:16:37.510 --> 01:16:38.510
重新来一遍

01:16:38.510 --> 01:16:40.890
好

01:16:40.890 --> 01:16:41.890
那么怎么改的

01:16:41.890 --> 01:16:43.890
是把小的不变

01:16:43.890 --> 01:16:44.890
小的下标不变

01:16:44.890 --> 01:16:45.890
大的下标变成

01:16:45.890 --> 01:16:48.890
中间下标-1

01:16:48.890 --> 01:16:50.890
大的下标是max-1这个设

01:16:50.890 --> 01:16:53.890
变成中间下标-1

01:16:53.890 --> 01:16:55.890
对不对

01:16:55.890 --> 01:16:57.890
重新去找

01:16:57.890 --> 01:16:58.890
那么这里是不是

01:16:58.890 --> 01:16:59.890
看到这是不是

01:16:59.890 --> 01:17:00.890
应该写徐华呢

01:17:00.890 --> 01:17:05.160
只要这个条件成立

01:17:05.160 --> 01:17:07.160
你还得继续找下去

01:17:07.160 --> 01:17:08.160
还得继续往后找

01:17:09.160 --> 01:17:11.160
只要条件不成立为止

01:17:11.160 --> 01:17:14.500
对不对

01:17:14.500 --> 01:17:15.500
那么如果说 else的话

01:17:15.500 --> 01:17:16.500
也就是说

01:17:16.500 --> 01:17:17.500
中间这个位置的值呢

01:17:17.500 --> 01:17:19.500
比较早的值小

01:17:19.500 --> 01:17:20.500
比方说你要早9

01:17:20.500 --> 01:17:22.500
这里是8比9小

01:17:22.500 --> 01:17:23.500
是不是在后边看

01:17:23.500 --> 01:17:24.500
后边看的话

01:17:24.500 --> 01:17:25.500
是不是要把另一个

01:17:25.500 --> 01:17:26.500
重新复制

01:17:26.500 --> 01:17:28.500
完美的-1

01:17:28.500 --> 01:17:29.500
对吧

01:17:29.500 --> 01:17:30.500
等于中间下标-1

01:17:30.500 --> 01:17:31.500
它又重新来

01:17:31.500 --> 01:17:33.500
直到找到为止

01:17:33.500 --> 01:17:34.500
那如果说看完了

01:17:34.500 --> 01:17:35.500
有一天这个

01:17:35.500 --> 01:17:36.500
这个值

01:17:36.500 --> 01:17:37.500
看完了过后

01:17:37.500 --> 01:17:39.500
它都比它大了

01:17:39.500 --> 01:17:40.500
就是循环条件都废除了

01:17:40.500 --> 01:17:41.500
都还没有找到

01:17:41.500 --> 01:17:43.500
这个时候就真找不到了

01:17:43.500 --> 01:17:44.500
真找不到了

01:17:44.500 --> 01:17:45.500
去返回force

01:17:45.500 --> 01:17:47.500
看来就是这样子来找呢

01:17:51.500 --> 01:17:52.500
你看啊

01:17:52.500 --> 01:17:53.500
这样找的话

01:17:53.500 --> 01:17:55.500
会减少很多的查找次数

01:17:55.500 --> 01:17:57.500
比方说你看啊这里

01:17:57.500 --> 01:17:59.500
比方说我要找

01:17:59.500 --> 01:18:00.500
就找12嘛

01:18:00.500 --> 01:18:01.500
就找12

01:18:01.500 --> 01:18:02.500
看一下怎么找的

01:18:02.500 --> 01:18:03.500
先找第1次

01:18:03.500 --> 01:18:04.500
看中间下标比12小

01:18:04.500 --> 01:18:05.500
对不对

01:18:05.500 --> 01:18:06.500
那看这个范围

01:18:06.500 --> 01:18:07.500
这个范围找

01:18:07.500 --> 01:18:08.500
又找中间

01:18:08.500 --> 01:18:09.500
比12小

01:18:09.500 --> 01:18:10.500
又看这个范围

01:18:10.500 --> 01:18:11.500
好

01:18:11.500 --> 01:18:12.500
这个范围的中间下标

01:18:12.500 --> 01:18:13.500
就是它自己

01:18:13.500 --> 01:18:15.500
还比它小

01:18:15.500 --> 01:18:17.500
那么就是

01:18:17.500 --> 01:18:18.500
本来现在的命运这个时候

01:18:18.500 --> 01:18:19.500
等于这个

01:18:19.500 --> 01:18:20.500
等于这个下标

01:18:20.500 --> 01:18:21.500
Maxing那个时候都重叠了

01:18:21.500 --> 01:18:22.500
对吧

01:18:22.500 --> 01:18:23.500
下标都重叠了

01:18:23.500 --> 01:18:24.500
都还比它小

01:18:24.500 --> 01:18:25.500
那么这个时候

01:18:25.500 --> 01:18:26.500
命再加1

01:18:26.500 --> 01:18:27.500
命运这个时候再加1

01:18:27.500 --> 01:18:29.500
超出这个范围就有问题了

01:18:29.500 --> 01:18:30.500
命运这个时候就大于它了

01:18:30.500 --> 01:18:32.500
那么就找不到了

01:18:32.500 --> 01:18:33.500
怎么说的意思吧

01:18:33.500 --> 01:18:35.500
它就用这种方式去找

01:18:36.500 --> 01:18:37.500
好

01:18:37.500 --> 01:18:38.500
那么这是Banner Research

01:18:38.500 --> 01:18:39.500
我们来试一下

01:18:39.500 --> 01:18:49.980
Banner Research

01:18:49.980 --> 01:18:51.980
然后这里Numbers

01:18:51.980 --> 01:18:53.980
这个传进去

01:18:53.980 --> 01:18:54.980
Numbers传进去

01:18:54.980 --> 01:18:56.980
查到了值吗

01:18:56.980 --> 01:18:57.980
查到了值传进去

01:18:57.980 --> 01:18:59.980
比方说查到一个9

01:18:59.980 --> 01:19:01.980
就找到了

01:19:01.980 --> 01:19:02.980
找12

01:19:02.980 --> 01:19:03.980
就找不到

01:19:03.980 --> 01:19:04.980
对不对

01:19:04.980 --> 01:19:06.980
这种查到次数要比这个东西

01:19:06.980 --> 01:19:09.980
要比出去查到少很多次

01:19:09.980 --> 01:19:10.980
出去查到如果说找12的话

01:19:10.980 --> 01:19:11.980
是不是要把整个数捕

01:19:11.980 --> 01:19:12.980
全部看一遍

01:19:12.980 --> 01:19:13.980
这个不用

01:19:13.980 --> 01:19:15.980
它只要一半一半的去看就行了

01:19:15.980 --> 01:19:16.980
都是二分的查账

01:19:18.980 --> 01:19:20.980
写双重循环的话

01:19:20.980 --> 01:19:22.980
写双重循环这样子

01:19:22.980 --> 01:19:24.980
一把外面的循环写好过后

01:19:24.980 --> 01:19:25.980
里面先打注释

01:19:25.980 --> 01:19:26.980
将我之前的样子

01:19:26.980 --> 01:19:28.980
先打好注释

01:19:28.980 --> 01:19:30.980
把注释写出来过后

01:19:30.980 --> 01:19:31.980
万成循环就用这种方式

01:19:31.980 --> 01:19:32.980
不看了

01:19:32.980 --> 01:19:33.980
不要去看外面的东西

01:19:33.980 --> 01:19:36.980
你就把注释的题完成就行了

01:19:36.980 --> 01:19:38.980
完成就直接去写完了

01:19:38.980 --> 01:19:39.980
你把里面的东西完成

01:19:39.980 --> 01:19:40.980
完成过后

01:19:40.980 --> 01:19:41.980
就直接写完了

01:19:42.980 --> 01:19:44.980
这对初选者是一个比较好的方式

01:19:45.980 --> 01:19:46.980
必须要排序好才行

01:19:46.980 --> 01:19:47.980
你不排序好

01:19:47.980 --> 01:19:48.980
肯定是不行的

01:19:48.980 --> 01:19:49.980
你怎么二分呢

01:19:49.980 --> 01:19:51.980
必须要排序好才行

01:19:51.980 --> 01:19:52.980
你想那个道理吗

01:19:55.980 --> 01:19:56.980
二分查到了

01:19:56.980 --> 01:19:58.980
可能都还不够快

01:19:58.980 --> 01:20:01.420
有的是我们还需要

01:20:01.420 --> 01:20:03.420
更快的查到方式

01:20:03.420 --> 01:20:05.420
比方说有这么一个数数

01:20:05.420 --> 01:20:07.420
这个数数是这样子的

01:20:07.420 --> 01:20:09.420
我测试一个数数

01:20:09.420 --> 01:20:15.700
什么叫急讯营

01:20:15.700 --> 01:20:16.700
这叫叫急讯营

01:20:17.700 --> 01:20:20.520
训练

01:20:20.520 --> 01:20:22.520
你如果说学习的过程中

01:20:22.520 --> 01:20:23.520
思维都一点点

01:20:23.520 --> 01:20:24.520
感觉很轻松

01:20:24.520 --> 01:20:26.520
一点感觉都没有

01:20:26.520 --> 01:20:28.520
老来都没有脏脏的感觉

01:20:28.520 --> 01:20:30.520
说明没有学到东西

01:20:30.520 --> 01:20:31.520
学的是咋

01:20:36.390 --> 01:20:38.390
我有这么一个数组

01:20:38.390 --> 01:20:39.390
你看

01:20:39.390 --> 01:20:40.390
有这么一个数组

01:20:40.390 --> 01:20:42.390
一到零到一百

01:20:42.390 --> 01:20:46.540
我要找一百

01:20:46.540 --> 01:20:48.540
我要找97这个数字

01:20:49.540 --> 01:20:51.540
我有必要

01:20:51.540 --> 01:20:52.540
从则办

01:20:52.540 --> 01:20:53.540
先则则办

01:20:53.540 --> 01:20:54.540
再则则办

01:20:54.540 --> 01:20:55.540
有必要的要来吗

01:20:55.540 --> 01:20:57.540
就是说有的数组

01:20:57.540 --> 01:20:58.540
有的数组

01:20:58.540 --> 01:21:00.540
它不仅排好了去

01:21:01.540 --> 01:21:02.540
而且

01:21:02.540 --> 01:21:04.540
他们的部长

01:21:04.540 --> 01:21:05.540
还差不多

01:21:05.540 --> 01:21:06.540
你看

01:21:06.540 --> 01:21:07.540
每个就是相当于是

01:21:07.540 --> 01:21:08.540
一个等差数列

01:21:08.540 --> 01:21:09.540
我不要求你

01:21:09.540 --> 01:21:10.540
一定是等差数列

01:21:10.540 --> 01:21:11.540
但是差不多

01:21:11.540 --> 01:21:12.540
差不多

01:21:14.540 --> 01:21:15.540
你们玩过

01:21:15.540 --> 01:21:16.540
银汉字典吗

01:21:18.540 --> 01:21:19.540
银汉字典

01:21:19.540 --> 01:21:20.540
查字典

01:21:20.540 --> 01:21:22.540
我不知道大家的习惯

01:21:22.540 --> 01:21:23.540
我相信很多同学

01:21:23.540 --> 01:21:24.540
都没有去翻过

01:21:24.540 --> 01:21:26.540
银汉字典的目录

01:21:26.540 --> 01:21:27.540
A开的字母

01:21:27.540 --> 01:21:28.540
B开的字母

01:21:28.540 --> 01:21:29.540
没有去翻过

01:21:30.540 --> 01:21:34.620
比方说你要查Z

01:21:34.620 --> 01:21:35.620
你要查这个单词

01:21:35.620 --> 01:21:36.620
你怎么查的

01:21:36.620 --> 01:21:37.620
同学们

01:21:37.620 --> 01:21:38.620
你们是怎么查的

01:21:38.620 --> 01:21:39.620
所以一定把这字典

01:21:39.620 --> 01:21:40.620
拿起来

01:21:40.620 --> 01:21:41.620
直接往后边翻

01:21:41.620 --> 01:21:42.620
对不对

01:21:42.620 --> 01:21:44.620
直接从字典后边翻

01:21:44.620 --> 01:21:46.620
Z不就在后边吗

01:21:46.620 --> 01:21:47.620
直接从后边翻

01:21:47.620 --> 01:21:49.620
你会不会从中间翻

01:21:49.620 --> 01:21:50.620
你不会吧

01:21:50.620 --> 01:21:51.620
你直接从后边翻

01:21:51.620 --> 01:21:53.620
是不是很快就找到答案了

01:21:55.620 --> 01:21:59.060
我说不止字典

01:21:59.060 --> 01:22:00.060
这个人是

01:22:00.060 --> 01:22:02.060
这个黄同学

01:22:03.060 --> 01:22:04.060
有时候刚进的钱

01:22:04.060 --> 01:22:05.060
你是

01:22:05.060 --> 01:22:07.060
我说字典

01:22:07.060 --> 01:22:09.060
比方说你要查那个Apple

01:22:09.060 --> 01:22:13.140
你要查这个词的话

01:22:13.140 --> 01:22:15.140
你有必要从中间翻吗

01:22:15.140 --> 01:22:17.140
没必要吧

01:22:17.140 --> 01:22:20.140
你直接从开头翻就完事了

01:22:20.140 --> 01:22:22.140
懂我这意思吧

01:22:22.140 --> 01:22:23.140
就说你觉得吧

01:22:23.140 --> 01:22:25.140
这个字典里边

01:22:25.140 --> 01:22:26.140
A到B

01:22:26.140 --> 01:22:27.140
B到C

01:22:27.140 --> 01:22:28.140
C到D

01:22:28.140 --> 01:22:30.140
他们的厚度都差不多

01:22:30.140 --> 01:22:31.140
可能有差异

01:22:31.140 --> 01:22:32.140
但是比较小

01:22:32.140 --> 01:22:34.140
差异比较小

01:22:34.140 --> 01:22:35.140
那么这个时候

01:22:35.140 --> 01:22:37.140
你有更高效的方式

01:22:37.140 --> 01:22:39.140
人其实

01:22:39.140 --> 01:22:40.140
很多时候做这些事

01:22:40.140 --> 01:22:41.140
很聪明的

01:22:41.140 --> 01:22:42.140
你脑袋都不用去想

01:22:42.140 --> 01:22:44.140
你自己去这样做了

01:22:45.140 --> 01:22:46.140
比方说

01:22:46.140 --> 01:22:47.140
现在你有一个数组

01:22:47.140 --> 01:22:49.140
数组里边有一万项

01:22:49.140 --> 01:22:52.830
一万项数据

01:22:52.830 --> 01:22:53.830
从一开始

01:22:54.830 --> 01:22:56.830
到一万

01:22:56.830 --> 01:22:57.830
中间是什么呢

01:22:57.830 --> 01:22:58.830
中间有可能一过了是二

01:22:58.830 --> 01:23:00.830
有可能一过了是三

01:23:00.830 --> 01:23:01.830
但是都差不多

01:23:01.830 --> 01:23:02.830
他们相隔的都差不多

01:23:02.830 --> 01:23:03.830
懂我这意思吧

01:23:03.830 --> 01:23:05.830
现在你要找这个数字

01:23:05.830 --> 01:23:10.870
你会从中间翻吗

01:23:10.870 --> 01:23:11.870
你不会吧

01:23:11.870 --> 01:23:16.020
你会直接就看

01:23:16.020 --> 01:23:17.020
后边的东西

01:23:17.020 --> 01:23:18.020
对不对

01:23:18.020 --> 01:23:19.020
因为你觉得都差不多

01:23:19.020 --> 01:23:21.020
他们的相隔的差不多

01:23:21.020 --> 01:23:22.020
当然不一定

01:23:22.020 --> 01:23:23.020
一定是隔一个

01:23:23.020 --> 01:23:24.020
有可能隔两个隔

01:23:24.020 --> 01:23:25.020
三个隔

01:23:25.020 --> 01:23:26.020
四个隔五个

01:23:26.020 --> 01:23:27.020
但他们相隔的都差不多

01:23:27.020 --> 01:23:29.020
所以你会直接往后边翻

01:23:30.020 --> 01:23:31.020
这就叫做

01:23:31.020 --> 01:23:33.020
差值差早

01:23:34.020 --> 01:23:36.020
它是对二分差早的进一步改进

01:23:37.020 --> 01:23:38.020
二分差早是找中间

01:23:38.020 --> 01:23:39.020
对吧

01:23:39.020 --> 01:23:40.020
它不是找中间

01:23:40.020 --> 01:23:42.020
它是有一个假设前提

01:23:42.020 --> 01:23:43.020
它不仅排好了去

01:23:43.020 --> 01:23:45.020
而且他们都差不多

01:23:45.020 --> 01:23:46.020
不长的差不多

01:23:46.020 --> 01:23:47.020
就是一过了是三

01:23:47.020 --> 01:23:48.020
等差数那边

01:23:48.020 --> 01:23:49.020
等差为二

01:23:49.020 --> 01:23:50.020
对吧

01:23:50.020 --> 01:23:51.020
差值为二

01:23:51.020 --> 01:23:52.020
一三五七九

01:23:52.020 --> 01:23:54.020
有可能有的时候

01:23:54.020 --> 01:23:55.020
一三五七

01:23:55.020 --> 01:23:56.020
十没关系

01:23:56.020 --> 01:23:58.020
多一个少一个也没关系

01:23:58.020 --> 01:23:59.020
都差不多

01:24:00.020 --> 01:24:02.020
不长大致相同

01:24:02.020 --> 01:24:03.020
使用差值曹早会

01:24:03.020 --> 01:24:05.020
更快地找到目标

01:24:05.020 --> 01:24:08.460
那么差值曹早怎么找呢

01:24:08.460 --> 01:24:10.460
跟那个二分差早相比

01:24:10.460 --> 01:24:13.460
差值曹早就一个地方有变动

01:24:14.460 --> 01:24:15.460
就一个地方

01:24:15.460 --> 01:24:16.460
其他都不用改

01:24:16.460 --> 01:24:17.460
改都不用改

01:24:17.460 --> 01:24:24.030
就是差值差早

01:24:24.030 --> 01:24:27.300
就这个地方

01:24:27.300 --> 01:24:30.300
计算这个中间下标的时候

01:24:30.300 --> 01:24:31.300
这个玩意儿有变化

01:24:31.300 --> 01:24:32.300
它不是算中间了

01:24:32.300 --> 01:24:34.300
比如说我算到下标

01:24:34.300 --> 01:24:35.300
二分大的算中间这个下标

01:24:35.300 --> 01:24:36.300
对吧

01:24:36.300 --> 01:24:38.300
差值曹早不是算中间

01:24:38.300 --> 01:24:40.300
它是有一个计算公式

01:24:40.300 --> 01:24:41.300
怎么计算呢

01:24:41.300 --> 01:24:42.300
它认为啊

01:24:42.300 --> 01:24:44.300
你的最大下标

01:24:44.300 --> 01:24:47.870
减去最小下标

01:24:47.870 --> 01:24:49.870
这个下标的差值

01:24:49.870 --> 01:24:54.760
等于我要找的目标那个下标

01:24:54.760 --> 01:24:55.760
我们要的就是这个东西

01:24:55.760 --> 01:24:56.760
对吧

01:24:56.760 --> 01:24:58.760
你要算的就是这个东西

01:24:58.760 --> 01:25:01.760
我们的目标这个下标

01:25:01.760 --> 01:25:04.760
减去小的这一部分

01:25:04.760 --> 01:25:05.760
也就是什么呢

01:25:05.760 --> 01:25:07.760
在下标范围内

01:25:07.760 --> 01:25:11.760
这个玩意儿比上

01:25:11.760 --> 01:25:13.760
这个玩意儿

01:25:13.760 --> 01:25:15.760
下标范围的这个比值

01:25:15.760 --> 01:25:18.760
跟那个数字的比值

01:25:18.760 --> 01:25:22.840
是差不多的

01:25:22.840 --> 01:25:24.840
你看啊

01:25:24.840 --> 01:25:25.840
我们要找的这个下标

01:25:25.840 --> 01:25:27.840
我们要求的这个下标

01:25:27.840 --> 01:25:29.840
减去最小下标

01:25:29.840 --> 01:25:30.840
就这一段

01:25:30.840 --> 01:25:32.840
下标的比值

01:25:32.840 --> 01:25:37.410
比上这个

01:25:37.410 --> 01:25:39.410
最大下标减去最小下标

01:25:39.410 --> 01:25:41.410
比上最短的距离

01:25:41.410 --> 01:25:42.410
这个比值

01:25:42.410 --> 01:25:43.410
这个除以这个

01:25:43.410 --> 01:25:45.410
他们的比值

01:25:45.410 --> 01:25:50.230
和数据的比值差不多

01:25:50.230 --> 01:25:53.230
就d-a除以d-a

01:25:53.230 --> 01:25:57.230
他们的比值是约等于差不多的

01:25:57.230 --> 01:25:58.230
懂我的意思吗

01:25:58.230 --> 01:26:02.250
能不能听懂这个意思啊

01:26:02.250 --> 01:26:07.760
能不能看到那么比值

01:26:07.760 --> 01:26:10.760
这个比值的关系

01:26:10.760 --> 01:26:16.380
能不能看懂啊

01:26:16.380 --> 01:26:18.380
下标范围的比值

01:26:18.380 --> 01:26:20.380
跟数字范围的比值

01:26:20.380 --> 01:26:22.380
是差不多的

01:26:22.380 --> 01:26:23.380
约等于

01:26:23.380 --> 01:26:24.380
不是说一定等于啊

01:26:24.380 --> 01:26:29.770
看不懂吗

01:26:29.770 --> 01:26:35.320
比方说吧

01:26:35.320 --> 01:26:37.320
5 6 7

01:26:37.320 --> 01:26:39.320
我就想想个最简单的场景

01:26:39.320 --> 01:26:41.320
这个

01:26:41.320 --> 01:26:44.320
我要找8这个数字

01:26:44.320 --> 01:26:45.320
我看

01:26:45.320 --> 01:26:46.320
首先我要大

01:26:46.320 --> 01:26:47.320
我要找一个下标

01:26:47.320 --> 01:26:48.320
这个下标不是在中间

01:26:48.320 --> 01:26:50.320
我要大字落在这个位置

01:26:50.320 --> 01:26:52.320
那么大字落在位置等于

01:26:52.320 --> 01:26:53.320
等于多少呢

01:26:53.320 --> 01:26:54.320
我们比方

01:26:54.320 --> 01:26:55.320
他的下标

01:26:55.320 --> 01:26:56.320
我们要找这个下标

01:26:56.320 --> 01:26:57.320
x

01:26:57.320 --> 01:26:59.320
我们假设这个位置就是x

01:26:59.320 --> 01:27:04.320
x减去最小下标0

01:27:04.320 --> 01:27:05.320
最小下标0

01:27:05.320 --> 01:27:07.320
比上最大下标

01:27:07.320 --> 01:27:08.320
最大下标是0

01:27:08.320 --> 01:27:10.320
最大下标是5

01:27:10.320 --> 01:27:12.320
减去最小下标0

01:27:12.320 --> 01:27:13.320
应该约等于

01:27:13.320 --> 01:27:14.320
他不说一定相等啊

01:27:14.320 --> 01:27:16.320
因为他这个位置有可能是

01:27:16.320 --> 01:27:19.320
有可能是7.5

01:27:19.320 --> 01:27:20.320
有可能是这个

01:27:20.320 --> 01:27:21.320
不一定相等

01:27:21.320 --> 01:27:24.700
约等于

01:27:24.700 --> 01:27:25.700
数字的距离比值

01:27:25.700 --> 01:27:26.700
就这个位置的数字

01:27:27.700 --> 01:27:28.700
有这个

01:27:28.700 --> 01:27:29.700
这个目标

01:27:29.700 --> 01:27:30.700
查到了目标数字

01:27:30.700 --> 01:27:31.700
目标数字我们不是要找8吗

01:27:31.700 --> 01:27:32.700
对吧

01:27:32.700 --> 01:27:34.700
8减5

01:27:34.700 --> 01:27:36.700
8减他的最小数字5

01:27:36.700 --> 01:27:37.700
除1

01:27:37.700 --> 01:27:38.700
什么

01:27:38.700 --> 01:27:42.700
最大数字9减5

01:27:42.700 --> 01:27:43.700
那么这个意思

01:27:43.700 --> 01:27:44.700
x减5

01:27:44.700 --> 01:27:45.700
等于什么

01:27:45.700 --> 01:27:46.700
8减5等于3

01:27:46.700 --> 01:27:48.700
9减5等于4

01:27:48.700 --> 01:27:49.700
对吧

01:27:49.700 --> 01:27:50.700
那么

01:27:50.700 --> 01:27:51.700
给你看一下

01:27:51.700 --> 01:27:53.700
x

01:27:53.700 --> 01:27:54.700
这是4

01:27:54.700 --> 01:27:56.700
最大下标为4

01:27:56.700 --> 01:27:57.700
那么x是不是

01:27:57.700 --> 01:27:58.700
应该算出来

01:27:58.700 --> 01:27:59.700
等于3

01:27:59.700 --> 01:28:00.700
那么x0123

01:28:00.700 --> 01:28:01.700
是不是再多了这个位置

01:28:01.700 --> 01:28:03.700
就是下标范围的比值

01:28:03.700 --> 01:28:05.700
跟那个数字的范围的比值差不多

01:28:05.700 --> 01:28:07.700
你就把下标想成什么

01:28:07.700 --> 01:28:08.700
想成成液马

01:28:08.700 --> 01:28:10.700
一把想成液马

01:28:10.700 --> 01:28:11.700
那么数字呢

01:28:11.700 --> 01:28:12.700
就想像成那个

01:28:12.700 --> 01:28:14.700
银汉字典的那个字母

01:28:14.700 --> 01:28:15.700
对吧

01:28:15.700 --> 01:28:17.700
是不是字母越大

01:28:17.700 --> 01:28:19.700
那么他的液马就越大

01:28:19.700 --> 01:28:20.700
对吧

01:28:20.700 --> 01:28:21.700
差不多

01:28:21.700 --> 01:28:22.700
懂我的意思吗

01:28:22.700 --> 01:28:23.700
那么我们这样的

01:28:23.700 --> 01:28:25.700
如果说你能够把这个东西想通

01:28:25.700 --> 01:28:27.700
你就可以把这个灭掉求出来

01:28:27.700 --> 01:28:29.700
灭掉求出来就等于这个

01:28:29.700 --> 01:28:30.700
就等于这个公式

01:28:30.700 --> 01:28:31.700
但他不说一定想等

01:28:31.700 --> 01:28:32.700
写完过我们还得判断

01:28:32.700 --> 01:28:33.700
到到底是不是

01:28:33.700 --> 01:28:36.200
那么这个

01:28:36.200 --> 01:28:37.200
不能用等号了

01:28:37.200 --> 01:28:38.200
小语

01:28:38.200 --> 01:28:39.200
因为不然等号的话

01:28:39.200 --> 01:28:41.200
就想懂他就处于0了

01:28:46.860 --> 01:28:48.860
你看吧

01:28:48.860 --> 01:28:49.860
target

01:28:49.860 --> 01:28:50.860
减什么

01:28:50.860 --> 01:28:51.860
最小的位置

01:28:51.860 --> 01:28:52.860
最小的位置是

01:28:52.860 --> 01:28:53.860
最小的位置是

01:28:53.860 --> 01:28:54.860
namus

01:28:54.860 --> 01:28:56.860
min index

01:28:57.860 --> 01:28:58.860
g-a

01:28:58.860 --> 01:28:59.860
g是啥

01:28:59.860 --> 01:29:00.860
g是最大的数字

01:29:00.860 --> 01:29:01.860
namus

01:29:01.860 --> 01:29:03.860
max index

01:29:03.860 --> 01:29:04.860
s是什么

01:29:04.860 --> 01:29:06.860
s-min index

01:29:07.860 --> 01:29:09.860
公式比较长

01:29:10.860 --> 01:29:11.860
承意什么

01:29:11.860 --> 01:29:12.860
max-min index

01:29:12.860 --> 01:29:13.860
min index

01:29:13.860 --> 01:29:14.860
加上min index

01:29:14.860 --> 01:29:15.860
就是灭掉

01:29:17.860 --> 01:29:19.860
就是我们期望他

01:29:19.860 --> 01:29:20.860
我们认为

01:29:20.860 --> 01:29:22.860
如果说就是个等差数列

01:29:22.860 --> 01:29:23.860
他就一定在这

01:29:23.860 --> 01:29:25.860
一定在这个位置上

01:29:25.860 --> 01:29:26.860
不一定是等差数列

01:29:26.860 --> 01:29:28.860
不一定是等差数列

01:29:28.860 --> 01:29:29.860
好

01:29:29.860 --> 01:29:30.860
算出来

01:29:30.860 --> 01:29:31.860
如果找到就找到了

01:29:31.860 --> 01:29:32.860
如果没有找到

01:29:32.860 --> 01:29:33.860
就是没有找到

01:29:33.860 --> 01:29:34.860
然后这就是

01:29:34.860 --> 01:29:35.860
差值差长

01:29:35.860 --> 01:29:41.620
你看一下吧

01:29:41.620 --> 01:29:42.620
namus

01:29:42.620 --> 01:29:44.620
找99

01:29:44.620 --> 01:29:45.620
找到了

01:29:45.620 --> 01:29:46.620
找了几次

01:29:46.620 --> 01:29:47.620
他只找了一次

01:29:47.620 --> 01:29:48.620
我们看一下

01:29:48.620 --> 01:29:49.620
循环那边

01:29:49.620 --> 01:29:50.620
我们输出一个歪了

01:29:50.620 --> 01:29:51.620
你看他找了几次

01:29:51.620 --> 01:29:52.620
他就找了一次

01:29:52.620 --> 01:29:53.620
一次就找到了

01:29:53.620 --> 01:29:54.620
一次就找到了

01:29:54.620 --> 01:29:55.620
还没算出来

01:29:55.620 --> 01:29:56.620
下边的位置

01:29:56.620 --> 01:29:57.620
就在那个位置

01:29:57.620 --> 01:29:59.620
当然这是比较好的情况

01:29:59.620 --> 01:30:00.620
那有一个情况

01:30:00.620 --> 01:30:02.620
可能比较差的情况

01:30:02.620 --> 01:30:03.620
也比较差的情况

01:30:03.620 --> 01:30:05.620
99不在这个位置

01:30:05.620 --> 01:30:06.620
不在这个位置还怎么办呢

01:30:06.620 --> 01:30:07.620
那就是一样的

01:30:07.620 --> 01:30:08.620
就缩小范围

01:30:08.620 --> 01:30:09.620
跟那个二分差道一样

01:30:09.620 --> 01:30:11.620
重新来找

01:30:11.620 --> 01:30:13.620
重新来找

01:30:13.620 --> 01:30:15.620
就这么回事

01:30:15.620 --> 01:30:16.620
当然这个程序

01:30:16.620 --> 01:30:18.620
里边还有一个小的bug

01:30:18.620 --> 01:30:20.620
bug有的时候

01:30:20.620 --> 01:30:21.620
可能会来回横挑

01:30:21.620 --> 01:30:22.620
啥意思呢

01:30:22.620 --> 01:30:23.620
就是

01:30:23.620 --> 01:30:24.620
如果说他不是一个等差

01:30:24.620 --> 01:30:25.620
这个等差数列

01:30:25.620 --> 01:30:26.620
不是一个

01:30:26.620 --> 01:30:27.620
不一定是个等差数列

01:30:27.620 --> 01:30:28.620
如果说了是9

01:30:28.620 --> 01:30:29.620
9过了是10

01:30:29.620 --> 01:30:31.620
那如果说你要找8

01:30:31.620 --> 01:30:32.620
本来他算出来

01:30:32.620 --> 01:30:33.620
应该在这个位置

01:30:33.620 --> 01:30:34.620
但是这个位置

01:30:34.620 --> 01:30:35.620
不好意思

01:30:35.620 --> 01:30:36.620
他不是吧

01:30:36.620 --> 01:30:37.620
不好意思他不是吧

01:30:37.620 --> 01:30:39.620
表上我就这种情况

01:30:39.620 --> 01:30:51.700
看一下

01:30:51.700 --> 01:30:53.700
找8

01:30:53.700 --> 01:30:54.700
这个时候

01:30:54.700 --> 01:30:55.700
倒是没问题

01:30:55.700 --> 01:30:56.700
倒是没问题

01:30:56.700 --> 01:30:58.700
我找一个

01:30:58.700 --> 01:30:59.700
看一下有没有

01:30:59.700 --> 01:31:00.700
有问题的

01:31:00.700 --> 01:31:03.700
8在这个位置

01:31:03.700 --> 01:31:05.700
这个是

01:31:05.700 --> 01:31:06.700
他就在这个范围内找

01:31:07.700 --> 01:31:09.700
这个范围内找的话

01:31:10.700 --> 01:31:11.700
他找的位置

01:31:11.700 --> 01:31:12.700
我看一下

01:31:12.700 --> 01:31:16.720
输出一下这面

01:31:16.720 --> 01:31:18.720
他这里还有一个小的问题

01:31:18.720 --> 01:31:31.000
我说改错了

01:31:31.000 --> 01:31:32.000
改错了

01:31:32.000 --> 01:31:33.000
改这

01:31:36.140 --> 01:31:41.120
2.4

01:31:41.120 --> 01:31:42.120
得到这么一个结果了

01:31:42.120 --> 01:31:44.120
啥意思呢

01:31:44.120 --> 01:31:45.120
他就是说

01:31:45.120 --> 01:31:46.120
如果说这种情况的话

01:31:46.120 --> 01:31:48.120
他算那个Made

01:31:48.120 --> 01:31:49.120
我这里没有把他

01:31:49.120 --> 01:31:50.120
没有把他

01:31:50.120 --> 01:31:51.120
这个是我的问题

01:31:51.120 --> 01:31:53.120
没有把他用Floor

01:31:53.120 --> 01:31:54.120
向下取整

01:31:54.120 --> 01:31:56.120
要取个整数

01:31:56.120 --> 01:31:57.120
要取个整数的

01:31:57.120 --> 01:31:58.120
好

01:31:58.120 --> 01:31:59.120
你看

01:31:59.120 --> 01:32:02.690
说先入死循环了

01:32:02.690 --> 01:32:03.690
他就来回横跳

01:32:03.690 --> 01:32:04.690
怎么回事呢

01:32:04.690 --> 01:32:05.690
他8

01:32:05.690 --> 01:32:06.690
本来算出来这个位置

01:32:06.690 --> 01:32:07.690
结果了

01:32:07.690 --> 01:32:08.690
这个位置比他大

01:32:08.690 --> 01:32:10.690
于是他缩小范围

01:32:10.690 --> 01:32:11.690
他找这个范围内

01:32:11.690 --> 01:32:12.690
去找8

01:32:12.690 --> 01:32:14.690
结果这个范围内一算

01:32:15.690 --> 01:32:17.690
算出来的这个坐标

01:32:17.690 --> 01:32:18.690
他超出这个范围了

01:32:18.690 --> 01:32:19.690
为什么

01:32:19.690 --> 01:32:20.690
8

01:32:20.690 --> 01:32:21.690
你看他最大值子

01:32:21.690 --> 01:32:22.690
对不对

01:32:22.690 --> 01:32:23.690
因此他这个比例算出来

01:32:23.690 --> 01:32:25.690
他觉得8还在后边

01:32:25.690 --> 01:32:27.690
于是他跑了这个范围内去算

01:32:27.690 --> 01:32:29.690
他把Made算成这个范围了

01:32:29.690 --> 01:32:30.690
于是呢

01:32:30.690 --> 01:32:31.690
算这个范围

01:32:31.690 --> 01:32:33.690
他觉得这个值还是比8大

01:32:33.690 --> 01:32:34.690
又跑了这个范围

01:32:34.690 --> 01:32:35.690
这范围一算出来

01:32:35.690 --> 01:32:37.690
中间值又跑了这个值的

01:32:37.690 --> 01:32:38.690
也就说什么呢

01:32:38.690 --> 01:32:39.690
这个Made值

01:32:39.690 --> 01:32:40.690
这个Made值

01:32:40.690 --> 01:32:42.690
本来算出来应该是

01:32:42.690 --> 01:32:44.690
0,1,2,3

01:32:44.690 --> 01:32:45.690
对不对

01:32:45.690 --> 01:32:47.690
Made值算出来应该是

01:32:47.690 --> 01:32:48.690
5,6,7

01:32:48.690 --> 01:32:50.690
比方说这里是9

01:32:50.690 --> 01:32:55.900
就这样看得更加清楚一点

01:32:55.900 --> 01:32:56.900
这里有点

01:32:56.900 --> 01:33:03.660
就这个位置有点小复杂

01:33:03.660 --> 01:33:07.870
这里还是一样

01:33:07.870 --> 01:33:09.870
你看算出来是0,1,2,3

01:33:09.870 --> 01:33:11.870
他采求的Made值是这个

01:33:11.870 --> 01:33:13.870
但是Made值不好意识比8大

01:33:13.870 --> 01:33:15.870
于是他跑到这个范围内去看

01:33:15.870 --> 01:33:16.870
这个范围内算出来还是3

01:33:16.870 --> 01:33:17.870
下标还是3

01:33:17.870 --> 01:33:18.870
因为8比他最大值大

01:33:18.870 --> 01:33:20.870
因为他跑出一个范围之外的

01:33:20.870 --> 01:33:21.870
也就说这个Made的值

01:33:21.870 --> 01:33:23.870
他算出来有可能在这个范围之外

01:33:23.870 --> 01:33:24.870
说这里呢

01:33:24.870 --> 01:33:25.870
要控制一下

01:33:25.870 --> 01:33:26.870
如果说Made

01:33:26.870 --> 01:33:29.870
小微的Made index

01:33:29.870 --> 01:33:32.870
或者是Made

01:33:32.870 --> 01:33:36.870
大于的Made index

01:33:36.870 --> 01:33:38.870
那么这个是

01:33:38.870 --> 01:33:40.870
怎么又写错了

01:33:40.870 --> 01:33:41.870
写到这

01:33:41.870 --> 01:33:45.760
Made of force

01:33:45.760 --> 01:33:47.760
那么算出来这个值

01:33:47.760 --> 01:33:49.760
目标指引跑出范围之外去了

01:33:49.760 --> 01:33:50.760
那肯定是找不到了

01:33:50.760 --> 01:33:52.760
这个地方控制一下

01:33:52.760 --> 01:33:53.760
其他都没啥

01:33:53.760 --> 01:33:54.760
也就说这个

01:33:54.760 --> 01:33:55.760
差值查到了

01:33:55.760 --> 01:33:56.760
相对于2分

01:33:56.760 --> 01:34:03.060
差值查到了

01:34:03.060 --> 01:34:04.060
相对于2分查到来说

01:34:04.060 --> 01:34:06.060
就是算目标指的方式

01:34:06.060 --> 01:34:07.060
它不再用中间的方式

01:34:07.060 --> 01:34:09.060
而是算出一个

01:34:09.060 --> 01:34:11.060
比较合理的目标指去查

01:34:11.060 --> 01:34:13.060
好

01:34:13.060 --> 01:34:14.060
这就是差值查到

01:34:14.060 --> 01:34:15.060
没有

01:34:15.060 --> 01:34:16.060
这就是今天的

01:34:16.060 --> 01:34:18.060
也就是这个意思

01:34:18.060 --> 01:34:20.060
这个意思

01:34:20.060 --> 01:34:22.060
那就今天的内容

01:34:22.060 --> 01:34:24.060
有点难是吧

01:34:24.060 --> 01:34:25.060
有点难

01:34:25.060 --> 01:34:26.060
今天

01:34:26.060 --> 01:34:27.060
我们的这里上

01:34:27.060 --> 01:34:28.060
打算难度的是这样子

01:34:28.060 --> 01:34:29.060
第一天是最简单的

01:34:29.060 --> 01:34:31.060
第一天和第三天

01:34:31.060 --> 01:34:32.060
就今天

01:34:32.060 --> 01:34:34.060
昨天和明天

01:34:34.060 --> 01:34:35.060
是比较简单的

01:34:35.060 --> 01:34:37.060
然后呢

01:34:37.060 --> 01:34:39.060
今天

01:34:39.060 --> 01:34:40.060
后天

01:34:40.060 --> 01:34:42.060
和最后一天

01:34:42.060 --> 01:34:43.060
是比较复杂的

01:34:43.060 --> 01:34:45.060
是穿它的来的

01:34:45.060 --> 01:34:47.060
大概是这么一个情况

01:34:47.060 --> 01:34:48.060
不管是简单还是复杂

01:34:48.060 --> 01:34:50.060
我也不想给大家讲复杂了

01:34:50.060 --> 01:34:52.060
我也希望所有东西都简单

01:34:52.060 --> 01:34:53.060
大家都轻轻松松就业

01:34:53.060 --> 01:34:54.060
高高兴兴

01:34:54.060 --> 01:34:55.060
打高兴

01:34:55.060 --> 01:34:56.060
但是呢

01:34:56.060 --> 01:34:58.060
我不去残酷的打击你们

01:34:58.060 --> 01:35:00.060
社会就是

01:35:00.060 --> 01:35:02.060
你们就会挨社会的独大

01:35:02.060 --> 01:35:03.060
所以说还是早点

01:35:03.060 --> 01:35:04.060
我来独大里面吧

01:35:04.060 --> 01:35:06.060
比老师独大还要好一点

01:35:06.060 --> 01:35:07.060
然后独大之后

01:35:07.060 --> 01:35:08.060
社会呢

01:35:08.060 --> 01:35:09.060
达力的

01:35:09.060 --> 01:35:11.060
达力的时候呢就没有那么痛了

01:35:13.060 --> 01:35:14.060
学程序呢

01:35:14.060 --> 01:35:15.060
就是看刚开始这个程序

01:35:15.060 --> 01:35:16.060
思维

01:35:16.060 --> 01:35:17.060
建立的时候呢

01:35:17.060 --> 01:35:18.060
确实所有同学

01:35:18.060 --> 01:35:19.060
都是要这样过来的

01:35:19.060 --> 01:35:20.060
以前我读大学的时候

01:35:20.060 --> 01:35:22.060
也是这样过来的

01:35:22.060 --> 01:35:23.060
大学刚刚

01:35:23.060 --> 01:35:24.060
刚开始不要说这个

01:35:24.060 --> 01:35:25.060
就是写那个

01:35:25.060 --> 01:35:27.060
写个99成发表

01:35:27.060 --> 01:35:29.060
把我绕了好久的关键

01:35:29.060 --> 01:35:31.060
绕了超级久

01:35:31.060 --> 01:35:33.060
把这个东西绕出来过后来

01:35:33.060 --> 01:35:34.060
我会发现

01:35:34.060 --> 01:35:36.060
这个千套循环也就那么回事

01:35:36.060 --> 01:35:38.060
好像一下子通了

01:35:38.060 --> 01:35:39.060
每个好

01:35:39.060 --> 01:35:40.060
你会问一下

01:35:40.060 --> 01:35:41.060
很多同学都是这样子

01:35:41.060 --> 01:35:42.060
就是你想到

01:35:42.060 --> 01:35:44.060
一开始纠结了某一个点

01:35:44.060 --> 01:35:45.060
纠结纠结纠结

01:35:45.060 --> 01:35:46.060
然后发现有一天

01:35:46.060 --> 01:35:47.060
通了

01:35:47.060 --> 01:35:48.060
想到一段时间过后

01:35:48.060 --> 01:35:49.060
做了一段时间过后

01:35:49.060 --> 01:35:50.060
你慢慢就通了

01:35:50.060 --> 01:35:51.060
但是

01:35:51.060 --> 01:35:52.060
痛苦的一段时间

01:35:52.060 --> 01:35:53.060
是一定要经过的

01:35:53.060 --> 01:35:54.060
你不经过那段痛苦的话

01:35:54.060 --> 01:35:56.060
你永远不会通的那一天

01:35:56.060 --> 01:35:57.060
当你通了过后

01:35:57.060 --> 01:35:59.060
以后别人就不怕了

01:35:59.060 --> 01:36:00.060
同样内心的东西就不怕了

01:36:00.060 --> 01:36:01.060
因为都是

01:36:01.060 --> 01:36:02.060
你的思维已经

01:36:02.060 --> 01:36:04.060
达到这个能力了

