WEBVTT

00:00.000 --> 00:02.000
好嘞

00:02.000 --> 00:06.000
我们今天晚上讲剩下的五道题

00:06.000 --> 00:08.000
今天晚上的题有一个特点

00:08.000 --> 00:12.000
它看上去好像是比较复杂的

00:12.000 --> 00:16.000
但是实际上它背后比较简单

00:16.000 --> 00:18.000
跟昨天晚上的刚好相反

00:18.000 --> 00:20.000
昨天晚上的题看上去比较简单

00:20.000 --> 00:24.000
实际上背后是比较复杂的

00:24.000 --> 00:26.000
今天晚上的题有一些东西

00:26.000 --> 00:28.000
我可能会有些东西

00:28.000 --> 00:31.000
我会往深入的地方点一下

00:31.000 --> 00:33.000
那到底点多少呢

00:33.000 --> 00:36.000
一是看时间 看咱们的时间

00:36.000 --> 00:40.000
第二是看一下同学们掌握的情况

00:40.000 --> 00:42.000
因为有些东西它要用到ES6

00:42.000 --> 00:44.000
ES6它并不复杂

00:44.000 --> 00:47.000
但是它毕竟有那么多东西

00:47.000 --> 00:49.000
你要说在一节课里边

00:49.000 --> 00:52.000
再把ES6灌进去 拿这节课

00:52.000 --> 00:54.000
那里面发上了

00:54.000 --> 00:56.000
但是它没有ES6了

00:56.000 --> 01:00.000
它也有没有ES6的解释方式

01:00.000 --> 01:03.000
如果说反正我会给大家点一下

01:03.000 --> 01:07.000
先看第六题 第六题

01:07.000 --> 01:12.000
为什么要用void0替换undefend

01:12.000 --> 01:15.000
这个体能一看上去莫名其妙的

01:15.000 --> 01:19.000
首先你要搞清楚void0是个啥

01:19.000 --> 01:23.020
随便找个浏览机吧

01:23.020 --> 01:26.020
void是节课里面的一个关键字

01:26.020 --> 01:29.020
它能够产生这么一个表达式

01:29.020 --> 01:32.020
在void后边跟上任何一个数据

01:32.020 --> 01:33.020
随便查数据都可以

01:33.020 --> 01:35.020
你跟个1跟个0

01:35.020 --> 01:38.020
你跟一个1加1都行

01:38.020 --> 01:40.020
你跟个任何东西都行

01:40.020 --> 01:42.020
那么这个void是啥意思呢

01:42.020 --> 01:45.020
它表示说把后边的东西算一下

01:45.020 --> 01:47.020
算完了 那就完了

01:47.020 --> 01:52.020
然后整个表达式返回一个undefend

01:52.020 --> 01:54.020
得到一个undefend

01:54.020 --> 01:59.020
它这个东西还就是来制造undefend的

01:59.020 --> 02:01.020
就没有什么别的用处了

02:01.020 --> 02:03.020
那么void1也好

02:03.020 --> 02:04.020
void0也好

02:04.020 --> 02:07.020
无非就是来搞一个undefend出来

02:07.020 --> 02:08.020
就这么简单

02:08.020 --> 02:10.020
那么再看一下这道题

02:10.020 --> 02:16.020
它问你为什么没有生意吗

02:16.020 --> 02:24.820
喂喂 有生意吗

02:24.820 --> 02:29.020
有 有什么问题

02:29.020 --> 02:31.020
它问你

02:31.020 --> 02:32.020
说到这个void0

02:32.020 --> 02:35.020
为什么要用void0替换undefend

02:35.020 --> 02:37.020
我都不知道为什么

02:37.020 --> 02:39.020
为什么要用void0替换undefend

02:39.020 --> 02:40.020
它的意思就是说

02:40.020 --> 02:42.020
比方说有个变量

02:42.020 --> 02:44.020
给它复制的时候

02:44.020 --> 02:46.020
有的时候我们会显示的

02:46.020 --> 02:48.020
给它复制为undefend

02:48.020 --> 02:50.020
有的时候我们会这样干

02:50.020 --> 02:52.020
那么它的要求就是

02:52.020 --> 02:54.020
你不能用undefend来复制

02:54.020 --> 02:56.020
应该使用void0

02:56.020 --> 02:59.020
来替代undefend的关键字

02:59.020 --> 03:01.020
很多大厂里边

03:01.020 --> 03:03.020
它会有这样的一个规定

03:03.020 --> 03:04.020
就有的时候

03:04.020 --> 03:06.020
大厂里边的规定挺神经病的

03:06.020 --> 03:08.020
看上去摸不着头脑

03:08.020 --> 03:09.020
这是啥意思

03:09.020 --> 03:11.020
那为什么不能用undefend呢

03:11.020 --> 03:12.020
当然这样子做了

03:12.020 --> 03:13.020
肯定是没问题的

03:13.020 --> 03:15.020
Adex肯定是undefend

03:15.020 --> 03:17.020
那么它为什么有这样的规定呢

03:17.020 --> 03:18.020
是因为这个undefend

03:18.020 --> 03:22.020
它压根就不是关键字

03:22.020 --> 03:24.020
我过去知道这一点的时候

03:24.020 --> 03:27.020
整个人都不好了

03:27.020 --> 03:29.020
介石这个语言

03:29.020 --> 03:32.020
可能是个介石语言的作者

03:32.020 --> 03:34.020
加弯太严重了

03:34.020 --> 03:35.020
然后加速幻觉了

03:35.020 --> 03:37.020
留了这么一个bug

03:37.020 --> 03:39.020
那这个还真是bug

03:39.020 --> 03:40.020
没有什么狡辩的

03:40.020 --> 03:41.020
没有什么洗地的

03:41.020 --> 03:43.020
这个就是bug

03:43.020 --> 03:44.020
存在了多少年了

03:44.020 --> 03:46.020
但是现在你要说要改

03:46.020 --> 03:47.020
改不回去

03:47.020 --> 03:49.020
要改的话影响太过

03:49.020 --> 03:51.020
有这么多程序在跑起来

03:51.020 --> 03:53.020
而且有不同版本的浏览器

03:53.020 --> 03:55.020
在运行要改回去

03:55.020 --> 03:56.020
很难改回去了

03:56.020 --> 03:57.020
只能留在这儿了

03:57.020 --> 03:59.020
所以说很多介石的bug

03:59.020 --> 04:03.020
它被我们细称为feature

04:03.020 --> 04:06.020
就是一个特性

04:06.020 --> 04:07.020
它不是bug

04:07.020 --> 04:08.020
它叫特性

04:08.020 --> 04:10.020
可以这么去解释

04:10.020 --> 04:11.020
这个undefend

04:11.020 --> 04:12.020
它不是关键字

04:12.020 --> 04:14.020
那么这个undefend是啥呢

04:14.020 --> 04:16.020
它是window的一个属性

04:16.020 --> 04:19.020
undefend

04:19.020 --> 04:20.020
它是这么回事

04:20.020 --> 04:22.020
所以我们平时用的undefend

04:22.020 --> 04:24.020
用的实际上是啥呢

04:24.020 --> 04:26.020
实际上是全局对象的一个属性

04:26.020 --> 04:28.020
因为我们知道全局对象的属性

04:28.020 --> 04:30.020
是可以直接使用的对吧

04:30.020 --> 04:33.720
用的是这么一个玩意儿

04:33.720 --> 04:35.720
那既然它是一个属性

04:35.720 --> 04:37.720
那我能不能给它复制呢

04:37.720 --> 04:39.720
试一下吧

04:39.720 --> 04:41.720
undefend给它复制为一

04:41.720 --> 04:43.720
可不可以呢

04:43.720 --> 04:44.720
好像可以复制

04:44.720 --> 04:45.720
它没有爆错

04:45.720 --> 04:47.720
但是呢

04:47.720 --> 04:49.720
遗憾的是它是止毒的

04:49.720 --> 04:50.720
至少呢

04:50.720 --> 04:52.720
这个bug还不算很严重

04:53.720 --> 04:55.720
它是止毒的

04:55.720 --> 04:57.720
所以你复制是无效的

04:58.720 --> 05:00.720
那么它就没有隐患

05:00.720 --> 05:01.720
有什么隐患的

05:01.720 --> 05:02.720
它复制于无效

05:02.720 --> 05:04.720
还真有隐患

05:04.720 --> 05:05.720
比方说

05:05.720 --> 05:07.720
我们到一个寒树里边去

05:07.720 --> 05:09.720
来玩这件事

05:09.720 --> 05:10.720
这个寒树里边

05:10.720 --> 05:11.720
我可能手一抖

05:11.720 --> 05:12.720
不小心的

05:12.720 --> 05:14.720
定义了一个名字叫做

05:14.720 --> 05:16.720
undefend的辩量

05:16.720 --> 05:17.720
可不可以啊

05:17.720 --> 05:18.720
可以

05:18.720 --> 05:19.720
为啥

05:19.720 --> 05:20.720
因为它不是关键字

05:20.720 --> 05:21.720
你可以把它作为辩量名字

05:21.720 --> 05:22.720
没问题

05:23.720 --> 05:25.720
然后给它复制为一个123

05:25.720 --> 05:28.860
那么接下来呢

05:28.860 --> 05:29.860
我再去使用

05:29.860 --> 05:30.860
别的辩量的时候啊

05:30.860 --> 05:31.860
比方说

05:31.860 --> 05:32.860
另外一个辩量

05:33.860 --> 05:35.860
我要给它复制为undefend

05:35.860 --> 05:37.860
由于我这个寒树里边

05:37.860 --> 05:38.860
已经存在了

05:38.860 --> 05:40.860
局部辩量undefend

05:40.860 --> 05:42.860
它就不再使用全局了

05:42.860 --> 05:44.860
比如说这个辩量呢

05:44.860 --> 05:45.860
它用的就是

05:45.860 --> 05:47.860
这个辩量的值123

05:47.860 --> 05:49.860
最后我们打印一下

05:49.860 --> 05:53.240
就写到这么一个寒树

05:53.240 --> 05:54.240
然后再去运行

05:54.240 --> 05:55.240
这个寒树的时候

05:55.240 --> 05:57.240
你会发现它输出了1123

05:57.240 --> 06:00.240
这就是undefend的隐患

06:00.240 --> 06:02.240
由于这个伎业是本身的一个bug

06:02.240 --> 06:05.240
导致了有这么一个隐患产生

06:05.240 --> 06:06.240
这个隐患你要说严重吧

06:06.240 --> 06:08.240
它并不是很严重

06:08.240 --> 06:09.240
因为平时我们写代码

06:09.240 --> 06:10.240
谁会这样写

06:10.240 --> 06:11.240
这样写的话

06:11.240 --> 06:13.240
一定是有点反人类的

06:13.240 --> 06:15.240
可能是

06:15.240 --> 06:16.240
有点要包袱社会了

06:16.240 --> 06:18.240
一般不会这样写代码对吧

06:18.240 --> 06:19.240
但是呢

06:19.240 --> 06:20.240
很多大厂呢

06:20.240 --> 06:21.240
它并不这样想

06:21.240 --> 06:22.240
它认为呢

06:22.240 --> 06:25.240
你有写这种代码的可能

06:25.240 --> 06:28.240
就是有隐患

06:28.240 --> 06:29.240
所以呢

06:29.240 --> 06:30.240
它要要求你

06:30.240 --> 06:32.240
不准用undefend的复制

06:32.240 --> 06:33.240
那么用Void就不会有问题

06:33.240 --> 06:34.240
为什么呢

06:34.240 --> 06:35.240
用我来试一下

06:35.240 --> 06:38.240
把它改成Void

06:38.240 --> 06:39.240
Void0

06:39.240 --> 06:40.240
因为跟那个undefend

06:40.240 --> 06:41.240
跟那个辩量就没关系了

06:41.240 --> 06:42.240
知道吧

06:42.240 --> 06:43.240
这个玩意就是产生

06:43.240 --> 06:45.240
一个值为undefend的东西

06:45.240 --> 06:46.240
这么一个表达是

06:46.240 --> 06:49.240
说这样就不会有问题了

06:49.240 --> 06:51.240
是不是不会有问题了

06:51.240 --> 06:52.240
而且呢

06:52.240 --> 06:53.240
Void还以为是关键字

06:53.240 --> 06:55.240
你也不可能像这样子写

06:55.240 --> 06:56.240
定一个辩量

06:56.240 --> 06:57.240
名字叫Void

06:57.240 --> 06:59.240
也是不可能的

06:59.240 --> 07:00.240
这样子是要报错的

07:00.240 --> 07:01.240
语法错误

07:01.240 --> 07:04.240
懂了意思吧

07:04.240 --> 07:05.240
所以说

07:05.240 --> 07:06.240
用Void0

07:06.240 --> 07:08.240
确实可以避免这个问题

07:08.240 --> 07:10.240
解除掉这个隐患

07:10.240 --> 07:12.240
这就是知道考虑的东西

07:12.240 --> 07:13.240
你说它复杂吗

07:13.240 --> 07:14.240
它并不复杂

07:14.240 --> 07:15.240
但是你

07:15.240 --> 07:16.240
如果说不知道

07:16.240 --> 07:17.240
什么叫Void

07:17.240 --> 07:19.240
你不知道这个undefend的东西

07:19.240 --> 07:20.240
知道这个东西

07:20.240 --> 07:21.240
花的时间也不多

07:21.240 --> 07:22.240
对吧

07:22.240 --> 07:24.240
几分钟时间就搞定了

07:24.240 --> 07:25.240
你不知道的话

07:25.240 --> 07:26.240
这道题就偶尔了

07:26.240 --> 07:27.240
回答不出来

07:27.240 --> 07:29.240
像我们这两天讲的题

07:29.240 --> 07:31.240
很多都是有那种点的题

07:31.240 --> 07:32.240
知识点

07:32.240 --> 07:33.240
只要你知道就没事

07:33.240 --> 07:34.240
啥事没有

07:34.240 --> 07:35.240
你不知道的话

07:35.240 --> 07:36.240
你想过头里都不知道

07:36.240 --> 07:37.240
好 这第一道题

07:37.240 --> 07:39.240
第一道题能听懂吗

07:39.240 --> 07:43.060
能听懂的话就可以

07:43.060 --> 07:44.060
不复值的话

07:44.060 --> 07:45.060
那肯定是undefend

07:45.060 --> 07:47.060
肯定是那个

07:47.060 --> 07:52.100
值为undefend

07:52.100 --> 07:54.100
看第七题

07:54.100 --> 07:56.100
第七题是这样

07:56.100 --> 07:58.100
把代码粘过来

07:58.100 --> 08:07.760
第七题

08:07.760 --> 08:08.760
是这么一个代码

08:08.760 --> 08:10.760
还问你输出多少

08:10.760 --> 08:11.760
同学们看一下吧

08:11.760 --> 08:12.760
这道题

08:12.760 --> 08:14.760
你们认为输出多少

08:14.760 --> 08:22.300
这道题倒是

08:22.300 --> 08:24.300
也涉及不到啥

08:24.300 --> 08:25.300
深入的东西

08:25.300 --> 08:27.300
它就是考了第三个知识点

08:27.300 --> 08:30.300
它就考第三个知识点

08:30.300 --> 08:35.850
并不复杂

08:35.850 --> 08:37.850
都不知道吗

08:37.850 --> 08:39.850
那我开始了

08:39.850 --> 08:40.850
行吧

08:40.850 --> 08:42.850
好大

08:42.850 --> 08:43.850
这道题呢

08:43.850 --> 08:45.850
前面用三句话没什么好说的

08:45.850 --> 08:46.850
定义三个辩量

08:46.850 --> 08:47.850
一个空对象

08:47.850 --> 08:48.850
一个这个对象

08:48.850 --> 08:49.850
一个这个对象

08:49.850 --> 08:50.850
定义了三个对象

08:50.850 --> 08:53.850
关键是第四和第五号

08:53.850 --> 08:55.850
这两句话到底啥意思

08:55.850 --> 08:57.850
有些朋友没见过

08:57.850 --> 08:58.850
这种邪法

08:58.850 --> 09:00.850
其实你肯定是见过的

09:00.850 --> 09:02.850
这种邪法出现在什么时候

09:02.850 --> 09:04.850
我慢慢讲

09:04.850 --> 09:05.850
这道题呢

09:05.850 --> 09:06.850
我就怕你们

09:06.850 --> 09:08.850
因为这是基本知识

09:08.850 --> 09:09.850
考了三个基本知识

09:09.850 --> 09:10.850
我就怕你们的

09:10.850 --> 09:11.850
三个基本知识点

09:11.850 --> 09:12.850
所以有问题的

09:12.850 --> 09:13.850
所以呢

09:13.850 --> 09:16.740
我就慢慢讲

09:16.740 --> 09:18.740
那如果说是咱们都学了

09:18.740 --> 09:19.740
有这个三个知识点

09:19.740 --> 09:20.740
有问题

09:20.740 --> 09:22.740
我要修理人了

09:22.740 --> 09:23.740
比方说

09:23.740 --> 09:24.740
我们这里呢

09:24.740 --> 09:26.740
有一个数组

09:26.740 --> 09:29.050
123

09:29.050 --> 09:30.050
随便吧

09:30.050 --> 09:31.050
我们要输出

09:31.050 --> 09:33.050
输出输出的第一项

09:33.050 --> 09:34.050
是不是这样写的

09:34.050 --> 09:36.050
这样的邪法你能理解吗

09:36.050 --> 09:38.050
你肯定能理解

09:38.050 --> 09:39.050
数组吗

09:39.050 --> 09:41.050
我们这里写下标吗

09:41.050 --> 09:43.050
但是有些同学呢

09:43.050 --> 09:45.050
他可能会误认为

09:45.050 --> 09:48.050
这也是受到一些教程的影响吧

09:48.050 --> 09:49.050
他可能会误认为

09:49.050 --> 09:52.050
只有数组才能有这样的邪法

09:52.050 --> 09:53.050
并不是

09:53.050 --> 09:54.050
这种邪法

09:54.050 --> 09:56.050
就带中国号的这种邪法

09:56.050 --> 09:58.050
并不是数组特有的

09:58.050 --> 10:01.050
反而跟数组就没关系

10:01.050 --> 10:03.050
他是谁的邪法呀

10:03.050 --> 10:05.050
他是对象的邪法

10:05.050 --> 10:07.050
对象在访问属性的时候

10:07.050 --> 10:09.050
就是这样写的

10:09.050 --> 10:11.050
比方说我们来写个对象

10:11.050 --> 10:13.050
OB戒

10:13.050 --> 10:15.050
里面一个属性A等于

10:15.050 --> 10:16.050
非常简单

10:16.050 --> 10:18.050
我要输出这个对象的属性A

10:18.050 --> 10:19.050
比如说我们怎么写的

10:19.050 --> 10:20.050
OB戒叫A

10:20.050 --> 10:21.050
是这样的邪法对吧

10:21.050 --> 10:22.050
这种邪法

10:22.050 --> 10:24.050
其实是一个简写

10:24.050 --> 10:26.050
这种邪法才是特殊的

10:26.050 --> 10:27.050
知道吧

10:27.050 --> 10:30.050
真正的邪法是这样子写的

10:30.050 --> 10:32.940
OB戒

10:32.940 --> 10:33.940
前面是个对象

10:33.940 --> 10:34.940
加上中国号来

10:34.940 --> 10:35.940
访问他的属性

10:35.940 --> 10:36.940
哪个属性呢

10:36.940 --> 10:39.940
这里边写属性的名字

10:39.940 --> 10:41.940
这个名字你可以写个字面量

10:41.940 --> 10:43.940
用个字幅创来表示属性的名字

10:43.940 --> 10:44.940
A

10:44.940 --> 10:46.940
也可以用一个面量

10:46.940 --> 10:50.890
把这个面量放进来

10:50.890 --> 10:51.890
是不是可以

10:51.890 --> 10:54.890
表示把这个面量的值

10:54.890 --> 10:56.890
作为他的属性的名字

10:56.890 --> 10:57.890
我们两个同时都试一下吧

10:57.890 --> 10:58.890
先不用面量

10:58.890 --> 10:59.890
这个能不能访问到

10:59.890 --> 11:01.890
肯定是能访问到的

11:01.890 --> 11:03.890
你能够读取他的属性

11:03.890 --> 11:05.890
也能够给这个属性复职

11:05.890 --> 11:07.890
这才是对象真正的

11:07.890 --> 11:09.890
访问属性的方式

11:09.890 --> 11:11.890
也可以写成一个面量

11:11.890 --> 11:13.890
这个面量的值

11:13.890 --> 11:15.890
把这个面量放过来

11:15.890 --> 11:17.890
表示他表示

11:17.890 --> 11:19.890
面量的值作为属性名

11:19.890 --> 11:21.890
他得到了还是属性A

11:21.890 --> 11:22.890
懂得意思吗

11:22.890 --> 11:26.890
这才是属性的真正的邪法

11:26.890 --> 11:28.890
甚至还可以写表达诗

11:28.890 --> 11:29.890
因为这个中国号里面

11:29.890 --> 11:30.890
你写啥都会说

11:30.890 --> 11:31.890
它是算出来的

11:31.890 --> 11:32.890
你写面量

11:32.890 --> 11:33.890
你把面量的值算出来

11:33.890 --> 11:34.890
你写表达诗

11:34.890 --> 11:35.890
就把表达诗的值算出来

11:35.890 --> 11:36.890
比方说我们这样子写

11:36.890 --> 11:38.890
AB等于1

11:38.890 --> 11:39.890
123

11:39.890 --> 11:40.890
我要访问AB

11:40.890 --> 11:41.890
我可以这样写

11:41.890 --> 11:42.890
可不可以

11:42.890 --> 11:43.890
AB

11:43.890 --> 11:44.890
字面量

11:44.890 --> 11:46.890
得到的是123

11:46.890 --> 11:48.890
我也可以A拼接B

11:48.890 --> 11:49.890
可不可以

11:49.890 --> 11:50.890
也可以

11:50.890 --> 11:52.890
把表达诗的值

11:52.890 --> 11:54.890
表达诗的值没什么好说的

11:54.890 --> 11:55.890
AB

11:55.890 --> 11:57.890
把表达诗的值作为

12:01.890 --> 12:03.890
把表达诗的值作为

12:03.890 --> 12:04.890
他的属性名字

12:05.890 --> 12:06.890
既然是表达诗

12:06.890 --> 12:07.890
是不是能够

12:07.890 --> 12:08.890
还可以加入变量

12:08.890 --> 12:10.890
用变量的值

12:10.890 --> 12:12.890
再拼接这个值

12:12.890 --> 12:13.890
我现在又有点担心

12:13.890 --> 12:15.890
你们表达诗这一块有问题

12:18.890 --> 12:20.890
说学习这些东西

12:20.890 --> 12:22.890
学习这种成体系的知识

12:22.890 --> 12:24.890
真的要体系化的学习

12:24.890 --> 12:26.890
这不能东减一点

12:26.890 --> 12:27.890
西减一点

12:27.890 --> 12:29.890
很麻烦的

12:30.890 --> 12:31.890
就完事了

12:31.890 --> 12:32.890
这就是对象

12:32.890 --> 12:34.890
访问属性真正的方式

12:35.890 --> 12:36.890
那么这种方式

12:36.890 --> 12:38.890
跟那种方式有啥区别呢

12:38.890 --> 12:40.890
叫做我访问这种方式

12:40.890 --> 12:42.890
这种方式是

12:42.890 --> 12:43.890
简写

12:43.890 --> 12:45.890
让你写着方便一点

12:46.890 --> 12:47.890
但是真正的方式

12:47.890 --> 12:48.890
是上面这种方式

12:49.890 --> 12:50.890
在中货号的

12:51.890 --> 12:52.890
懂了意思吧

12:53.890 --> 12:54.890
所以说这个

12:54.890 --> 12:55.890
并不是什么

12:55.890 --> 12:56.890
数主特有的

12:56.890 --> 12:57.890
对象都有

12:57.890 --> 12:58.890
考虑到第一个点

12:59.890 --> 13:00.890
第二个点

13:01.890 --> 13:02.890
属性

13:02.890 --> 13:04.890
它用什么作为属性的

13:04.890 --> 13:05.890
它是不是用一个对象

13:05.890 --> 13:06.890
来作为属性

13:06.890 --> 13:07.890
现在能看懂了吧

13:08.890 --> 13:09.890
哪个属性

13:09.890 --> 13:11.890
不是属性B

13:11.890 --> 13:12.890
而是属性

13:12.890 --> 13:14.890
这个变量B的值

13:14.890 --> 13:15.890
把这个值

13:15.890 --> 13:17.890
作为它的属性的名字

13:17.890 --> 13:21.220
那么

13:21.220 --> 13:22.220
这个值是啥

13:22.220 --> 13:24.220
这个值是一个对象

13:24.220 --> 13:26.220
对象能作为属性的名字吗

13:26.220 --> 13:27.220
不好意思 不行

13:28.220 --> 13:29.220
属性的名字

13:29.220 --> 13:30.220
只能有两种

13:30.220 --> 13:32.220
一种是制服串

13:32.220 --> 13:34.220
一种是ES6的symbol

13:34.220 --> 13:36.220
只能有这两种

13:36.220 --> 13:37.220
不能有别的了

13:38.220 --> 13:39.220
数字能作为属性吗

13:39.220 --> 13:40.220
不好意思

13:40.220 --> 13:42.220
数字是不能作为属性的

13:42.220 --> 13:43.220
好 有人要开始

13:44.220 --> 13:45.220
要举法律了

13:45.220 --> 13:46.220
要来搏倒我了

13:47.220 --> 13:48.220
那说

13:48.220 --> 13:49.220
我们说数主

13:49.220 --> 13:50.220
是不是对象

13:50.220 --> 13:51.220
那数主肯定得是对象

13:52.220 --> 13:53.220
数主是对象

13:53.220 --> 13:54.220
那么我们平时写的这个东西

13:54.220 --> 13:56.220
你说数字不能作为属性

13:56.220 --> 13:57.220
那这个不是属性吗

13:59.220 --> 14:01.220
那这个不是属性吗

14:03.220 --> 14:05.220
他确实是属性

14:05.220 --> 14:07.220
他也是属性

14:08.220 --> 14:09.220
不信的话

14:09.220 --> 14:10.220
我们到刘安琪的里面看一下

14:10.220 --> 14:15.710
看一下这个数主

14:15.710 --> 14:16.710
是不是对象展开

14:16.710 --> 14:17.710
他的属性0

14:17.710 --> 14:18.710
32

14:18.710 --> 14:19.710
属性1

14:19.710 --> 14:20.710
34

14:20.710 --> 14:21.710
25

14:21.710 --> 14:22.710
还有个属性nance

14:22.710 --> 14:23.710
长度

14:23.710 --> 14:24.710
3

14:24.710 --> 14:25.710
他确实是属性

14:25.710 --> 14:26.710
这个没什么疑问

14:27.710 --> 14:28.710
那么这不就是

14:28.710 --> 14:29.710
数字属性吗

14:29.710 --> 14:30.710
还真不是

14:31.710 --> 14:33.710
所有的属性

14:33.710 --> 14:35.710
都只能是字幅串

14:35.710 --> 14:36.710
和symbol

14:36.710 --> 14:37.710
symbol跟的到底没关系

14:37.710 --> 14:39.710
你可以不用去管他

14:39.710 --> 14:41.710
那你填的是数字

14:41.710 --> 14:42.710
他并不是字幅串

14:42.710 --> 14:44.710
也不是symbol怎么办呢

14:44.710 --> 14:47.710
他会把自动转成字幅串

14:48.710 --> 14:49.710
也就是你这样子写

14:49.710 --> 14:50.710
跟这样子写

14:50.710 --> 14:51.710
是一样的

14:52.710 --> 14:53.710
你试一下

14:54.710 --> 14:55.710
数数1对吧

14:55.710 --> 14:57.710
数主的第一项是不是1

14:57.710 --> 14:58.710
看一下数数

14:58.710 --> 14:59.710
数数的第二项

15:00.710 --> 15:01.710
3对不对

15:02.710 --> 15:03.710
说明啥

15:03.710 --> 15:04.710
说明这样的属性

15:04.710 --> 15:05.710
你仍然是可以

15:05.710 --> 15:07.710
访问到他的相应位置的

15:08.710 --> 15:09.710
只不过我们平时

15:09.710 --> 15:11.710
为了写的简单

15:11.710 --> 15:12.710
一般来说

15:12.710 --> 15:13.710
没有哪个变态

15:13.710 --> 15:15.710
会用这种方式来去写

15:15.710 --> 15:16.710
知道吧

15:17.710 --> 15:18.710
我们为了写的简单

15:18.710 --> 15:19.710
我们写个数字

15:19.710 --> 15:20.710
因为他自动转成字幅串

15:21.710 --> 15:23.710
但实际上用的是字幅串

15:23.710 --> 15:24.710
这就产生了一个

15:24.710 --> 15:25.710
经典的面试题

15:25.710 --> 15:43.740
根据刚才袁老师讲的

15:43.740 --> 15:44.740
同学们来告诉我

15:44.740 --> 15:45.740
这道贴答案

15:45.740 --> 15:53.820
所以现在就很清楚了

15:53.820 --> 15:55.820
这道题别小看它

15:55.820 --> 15:57.820
你不知道这个知识点的话

15:57.820 --> 15:59.820
哪里出的人还很多

15:59.820 --> 16:00.820
这种题

16:00.820 --> 16:02.820
这种题的正确率并不高的

16:03.820 --> 16:04.820
其实很多人并不知道

16:04.820 --> 16:05.820
这个知识点

16:06.820 --> 16:07.820
其实因为这里

16:07.820 --> 16:08.820
用的是数字

16:08.820 --> 16:10.820
其实全都会被转成字幅串

16:10.820 --> 16:11.820
这肯定结果是200

16:12.820 --> 16:13.820
早说一下

16:14.820 --> 16:15.820
200

16:15.820 --> 16:16.820
对吧

16:16.820 --> 16:17.820
其实它用的是同一个属性

16:19.820 --> 16:20.820
实际上是这样的

16:21.820 --> 16:22.820
对是吧

16:23.820 --> 16:24.820
这是正当面试题

16:24.820 --> 16:25.820
顺便说一下

16:25.820 --> 16:26.820
回过头来再看这

16:27.820 --> 16:29.820
你不是字幅串

16:29.820 --> 16:31.820
我就得把它转成字幅串

16:31.820 --> 16:32.820
那你是不是字幅串

16:32.820 --> 16:33.820
那肯定不是

16:34.820 --> 16:35.820
它是对象

16:35.820 --> 16:37.820
那现在就说到第三个问题了

16:37.820 --> 16:40.820
对象转成字幅串

16:40.820 --> 16:41.820
是啥

16:42.820 --> 16:43.820
它怎么转的

16:44.820 --> 16:45.820
那怎么转的呢

16:45.820 --> 16:47.820
我们就随便拿个对象来说吧

16:47.820 --> 16:48.820
有个OB界

16:49.820 --> 16:50.820
是一个对象

16:50.820 --> 16:51.820
我要把它转成字幅串

16:51.820 --> 16:52.820
我们字幅串是啥呢

16:53.820 --> 16:54.820
输出一下

16:54.820 --> 16:55.820
怎么来转的

16:55.820 --> 16:58.820
它是雕用对象的toeskin

17:00.820 --> 17:01.820
雕容这个方法

17:02.820 --> 17:03.820
来进行转换

17:04.820 --> 17:05.820
好我们来运行一下

17:05.820 --> 17:06.820
看一下对象转成字幅串

17:06.820 --> 17:07.820
就这个

17:08.820 --> 17:09.820
这才是要转成字幅串的格式

17:09.820 --> 17:10.820
我们给个对象里面

17:10.820 --> 17:12.820
生成一些属性

17:13.820 --> 17:14.820
生成一些属性

17:15.820 --> 17:16.820
我们再来运行

17:16.820 --> 17:17.820
还是一样

17:18.820 --> 17:19.820
没变化

17:19.820 --> 17:20.820
还是这个字幅串

17:20.820 --> 17:22.820
toeskin得到的才是这个

17:23.820 --> 17:24.820
所以呢

17:24.820 --> 17:25.820
我们现在就明白了

17:25.820 --> 17:26.820
再回过来

17:26.820 --> 17:27.820
看这道题就比较简单了

17:28.820 --> 17:29.820
这是在干嘛

17:29.820 --> 17:30.820
这是在读它的属性

17:31.820 --> 17:33.820
属性那个边量B的值作为属性

17:33.820 --> 17:34.820
边量B的值

17:34.820 --> 17:35.820
它不是字幅串

17:35.820 --> 17:36.820
于是它被转成了

17:37.820 --> 17:38.820
字幅串

17:38.820 --> 17:39.820
转成字幅串是啥呢

17:39.820 --> 17:40.820
就是刚才看到那个

17:41.820 --> 17:42.820
就这个外

17:44.820 --> 17:47.190
也就是这里呢

17:47.190 --> 17:48.190
实际上你这样子写

17:48.190 --> 17:49.190
相当于这样写

17:50.190 --> 17:51.190
给它这个玩意

17:51.190 --> 17:52.190
这个玩意

17:52.190 --> 17:54.190
把这个玩意作为属性的名字

17:54.190 --> 17:56.190
然后这个C也是一样

17:57.190 --> 17:58.190
这个B也是一样

17:59.190 --> 18:00.190
所以最后输出啥呀

18:00.190 --> 18:01.190
都是同一个属性

18:01.190 --> 18:03.190
不就是输出456吗

18:04.190 --> 18:05.190
对吧

18:05.190 --> 18:06.190
要推回去

18:06.190 --> 18:07.190
你看一下

18:07.190 --> 18:08.190
最终的结果

18:12.140 --> 18:13.140
456

18:13.140 --> 18:14.140
没问题吧

18:14.140 --> 18:16.140
最后来我们来输出一下A

18:16.140 --> 18:17.140
A里面应该是啥呢

18:17.140 --> 18:18.140
你自己在脑袋里面想一下

18:18.140 --> 18:20.140
A里面长什么样子

18:20.140 --> 18:21.140
这个对象

18:21.140 --> 18:24.030
很简单

18:25.030 --> 18:26.030
它以前是空对象征

18:26.030 --> 18:27.030
是不是加了一个属性的

18:28.030 --> 18:29.030
那个属性的名字

18:29.030 --> 18:30.030
不就是这个名字吗

18:30.030 --> 18:31.030
属性的指

18:32.030 --> 18:33.030
一开始以为123

18:33.030 --> 18:35.030
会不会被改成了456

18:36.030 --> 18:37.030
看懂了吗

18:38.030 --> 18:39.030
非常简单的这道题

18:39.030 --> 18:40.030
你早忘了

18:40.030 --> 18:41.030
这些诸实点了就很简单

18:43.030 --> 18:45.030
然后这种面试题

18:45.030 --> 18:47.030
它可能会有各种

18:47.030 --> 18:48.030
变形

18:48.030 --> 18:49.030
变种

18:49.030 --> 18:50.030
比方说

18:50.030 --> 18:51.030
我们把这个B

18:51.030 --> 18:53.030
给它写上一个突出

18:54.030 --> 18:55.030
这样子一来的话

18:55.030 --> 18:56.030
它是不是就把默认的突出

18:56.030 --> 18:57.030
迅给它覆盖掉了

18:58.030 --> 18:59.030
我给它返回一个B

19:00.030 --> 19:01.030
把B习成这个样子

19:02.030 --> 19:03.030
然后把C

19:03.030 --> 19:04.030
也给它换一个

19:05.030 --> 19:06.030
返回一个C

19:07.030 --> 19:08.030
这样子一来

19:08.030 --> 19:09.030
你们想一想

19:09.030 --> 19:10.030
现在有输出多少

19:11.030 --> 19:14.180
你们来看一下

19:14.180 --> 19:15.180
不同属性的对象

19:15.180 --> 19:17.180
转成字幅串

19:17.180 --> 19:18.180
是相等的吗

19:18.180 --> 19:19.180
只要对象里面

19:19.180 --> 19:20.180
你没有去改它的突出

19:21.180 --> 19:22.180
就是相等的

19:28.840 --> 19:29.840
这个输出多少

19:41.020 --> 19:42.020
还没看出来吗

19:48.050 --> 19:49.050
这输出多少

19:49.050 --> 19:50.050
说显而易见

19:51.050 --> 19:52.050
这个对象

19:52.050 --> 19:53.050
它作为属性

19:53.050 --> 19:54.050
是不是在转成字幅串

19:54.050 --> 19:55.050
转成字幅串是啥

19:56.050 --> 19:57.050
调用突出运吗

19:58.050 --> 19:59.050
突出运现在用的是什么

19:59.050 --> 20:00.050
用的是我们写的个突出运的

20:01.050 --> 20:02.050
那这里反过来是什么

20:02.050 --> 20:03.050
反过来是一个字幅串B

20:03.050 --> 20:04.050
好

20:04.050 --> 20:05.050
那么这句话

20:05.050 --> 20:06.050
就相当于是给对象的A

20:06.050 --> 20:08.050
这个属性复制

20:09.050 --> 20:10.050
那么这句话

20:11.050 --> 20:12.050
突出运

20:12.050 --> 20:13.050
转成字幅串是C

20:13.050 --> 20:14.050
那么这句话

20:14.050 --> 20:15.050
相当于是给属性C复制

20:16.050 --> 20:17.050
这句话就很好说了

20:18.050 --> 20:19.050
就变成这样了

20:19.050 --> 20:20.050
肯定是123

20:21.050 --> 20:22.050
试一下吧

20:22.050 --> 20:23.050
最后A里面说

20:23.050 --> 20:24.050
有两个属性

20:24.050 --> 20:25.050
一个B 一个C

20:25.050 --> 20:27.550
运行

20:27.550 --> 20:28.550
说123

20:28.550 --> 20:29.550
有两个属性

20:29.550 --> 20:30.550
一个B 一个C

20:31.550 --> 20:32.550
说这些东西

20:32.550 --> 20:33.550
都可以用各种各样的变化

20:33.550 --> 20:36.550
如果说你仅去背一道题的话

20:36.550 --> 20:38.550
当然我们学开发

20:38.550 --> 20:40.550
从来不要求大家去背

20:41.550 --> 20:42.550
咱们这方面不是搞什么

20:42.550 --> 20:43.550
政治 历史 地理

20:44.550 --> 20:45.550
不需要去记任何东西

20:45.550 --> 20:46.550
你要去理解

20:47.550 --> 20:48.550
它怎么回事

20:48.550 --> 20:49.550
它的知识点是怎么回事

20:49.550 --> 20:51.550
然后通过这些知识点去推导

20:51.550 --> 20:52.550
包括我们讲的

20:52.550 --> 20:54.550
原型联系链的时候

20:54.550 --> 20:56.550
原型链的图这么复杂

20:57.550 --> 20:59.550
咱们这些同学是怎么记住的

21:00.550 --> 21:01.550
根本就没有记忆

21:01.550 --> 21:02.550
它只需要搞清楚

21:02.550 --> 21:04.550
对象的三角关系

21:04.550 --> 21:05.550
勾造器

21:05.550 --> 21:08.550
对象以及它原型的三角关系

21:08.550 --> 21:10.550
搞得这三角关系

21:10.550 --> 21:11.550
所有东西整个图

21:11.550 --> 21:12.550
全部推导出来

21:13.550 --> 21:15.550
这才是正确的学习程序的方式

21:17.550 --> 21:19.550
好 那么这种题有可能

21:20.550 --> 21:22.550
我自己和一开始就说了

21:22.550 --> 21:23.550
我可能在某些地方

21:23.550 --> 21:24.550
可能会点一下

21:24.550 --> 21:26.550
我现在给你点一下

21:26.550 --> 21:29.550
这种题可能还会有

21:29.550 --> 21:30.550
其他的变形

21:31.550 --> 21:32.550
变成什么呢

21:32.550 --> 21:34.550
因为现在有了ES-6了

21:34.550 --> 21:36.550
ES-6它出现一个东西

21:36.550 --> 21:37.550
叫做符号

21:40.380 --> 21:41.380
有没有不知道符号的

21:41.380 --> 21:42.380
求个1呢

21:42.380 --> 21:43.380
求个1呢

21:44.380 --> 21:45.380
我看有多少

21:45.380 --> 21:51.500
多的话那我这道题只能

21:53.500 --> 21:54.500
好吧

21:54.500 --> 21:55.500
那我真的只能点一下了

21:55.500 --> 21:57.500
因为我再去说符号

21:57.500 --> 21:59.500
事情就变得漫长了

22:00.500 --> 22:01.500
只是得慢慢来

22:01.500 --> 22:02.500
一点点牺牲

22:02.500 --> 22:05.500
你们先搞清楚ES-6之前的

22:05.500 --> 22:06.500
然后慢慢再去学ES-6

22:06.500 --> 22:08.500
我觉得简单说一下

22:09.500 --> 22:11.500
ES-6它提供了一种符号

22:11.500 --> 22:12.500
你用这个符号

22:12.500 --> 22:14.500
就可以介入到对象

22:14.500 --> 22:15.500
转圆式的过程

22:15.500 --> 22:16.500
你看我们刚才

22:16.500 --> 22:17.500
这里是不是在对象

22:17.500 --> 22:18.500
转圆式内形

22:18.500 --> 22:19.500
我们把一个对象

22:19.500 --> 22:21.500
它这里会自动转成字弧串

22:21.500 --> 22:23.500
字弧串是不是圆式内形

22:24.500 --> 22:25.500
对吧

22:26.500 --> 22:28.500
没有那个符号的时候

22:28.500 --> 22:29.500
调的是TOUSGN

22:29.500 --> 22:31.500
当你有这个符号的时候

22:31.500 --> 22:33.500
它调的是那个符号的方法

22:33.500 --> 22:35.500
那么一个符号是这么写的

22:36.500 --> 22:37.500
simple

22:41.460 --> 22:42.460
primity

22:44.960 --> 22:45.960
这种写法有些可能

22:45.960 --> 22:46.960
从来没见过

22:46.960 --> 22:47.960
这叫属性表拉式

22:47.960 --> 22:49.960
这又是另外一个话题

22:49.960 --> 22:51.960
我们只能点到为止了

22:51.960 --> 22:53.960
你用这种写法

22:53.960 --> 22:56.960
出来的效果跟刚才是一样的

22:58.960 --> 22:59.960
刚才是一样的

22:59.960 --> 23:01.960
就是当你写了这个符号之后

23:01.960 --> 23:03.960
它就忽略掉TOUSGN了

23:03.960 --> 23:04.960
它就不管TOUSGN了

23:04.960 --> 23:05.960
它就会调这个方法

23:05.960 --> 23:07.960
来转成圆式内形

23:09.960 --> 23:11.960
对象转圆式

23:11.960 --> 23:14.960
情况可不止这种情况

23:14.960 --> 23:16.960
很多时候都可能会发生

23:16.960 --> 23:18.960
对象转圆式

23:19.960 --> 23:21.960
还有什么情况

23:21.960 --> 23:23.960
会发生对象转圆式

23:24.960 --> 23:26.960
同学们能不能再列举一个

23:27.960 --> 23:29.960
对象转圆式

23:29.960 --> 23:30.960
简单说一下

23:30.960 --> 23:32.960
简单说一下就是这个样子

23:32.960 --> 23:34.960
就这个样子了

23:34.960 --> 23:36.960
我想跟你们说

23:36.960 --> 23:38.960
我要跟你们说的东西

23:38.960 --> 23:40.960
不管不仅仅是技术类的

23:40.960 --> 23:42.960
包括学习方法类的

23:42.960 --> 23:43.960
学习心态上的

23:43.960 --> 23:44.960
学习纪律上的

23:44.960 --> 23:45.960
老说不完的

23:45.960 --> 23:49.980
三天三夜都说不完

23:49.980 --> 23:51.980
对象转圆式同学们

23:51.980 --> 23:52.980
除了这种情况

23:52.980 --> 23:53.980
我们刚刚讲的情况

23:53.980 --> 23:55.980
会自动触发对象

23:55.980 --> 23:57.980
转成制服串的圆式内形

23:57.980 --> 23:59.980
还有什么情况

23:59.980 --> 24:00.980
你们接触到的

24:00.980 --> 24:01.980
或者是你们学到的

24:01.980 --> 24:03.980
或者是你们听过的

24:03.980 --> 24:08.380
对象会转成圆式内形

24:08.380 --> 24:09.380
你说按嘛

24:09.380 --> 24:10.380
对吧 主林同学说得很好

24:10.380 --> 24:16.310
不就你说按嘛

24:16.310 --> 24:18.310
OB界加上一个E

24:18.310 --> 24:20.310
这个OB界不转成圆式

24:20.310 --> 24:21.310
它怎么加

24:21.310 --> 24:24.310
它只能转成圆式过后才能加

24:24.310 --> 24:25.310
对不对

24:25.310 --> 24:27.310
或者是我要把它用过这个东西

24:27.310 --> 24:28.310
前面加个加号

24:28.310 --> 24:30.310
是不是把它转成数字

24:30.310 --> 24:32.310
它也得转成圆式

24:32.310 --> 24:34.310
只要是转圆式

24:34.310 --> 24:36.310
你写的这个符号

24:36.310 --> 24:38.310
它就一定会运行这个函数

24:38.310 --> 24:40.310
就一定会运行

24:40.310 --> 24:45.820
比方说我们这里输出一个A加E

24:45.820 --> 24:47.820
你会发现很有意思

24:47.820 --> 24:48.820
A加E

24:48.820 --> 24:50.820
它本来应该得到的是这个东西

24:51.820 --> 24:53.820
但是由于你有这个函数

24:53.820 --> 24:54.820
这个函数存在

24:54.820 --> 24:56.820
那么它会调这个函数

24:56.820 --> 24:57.820
它就变成了B

24:57.820 --> 24:59.820
制符创B加E

24:59.820 --> 25:00.820
得到的

25:04.020 --> 25:06.020
不是A 应该是B加E

25:06.020 --> 25:08.020
因为B才写了这个符号

25:08.020 --> 25:10.020
看一下

25:12.020 --> 25:16.620
B人拿defend

25:16.620 --> 25:17.620
运行

25:17.620 --> 25:18.620
是不是B1

25:18.620 --> 25:19.620
对吧

25:19.620 --> 25:21.620
它变成了调用这个函数

25:21.620 --> 25:23.620
这是你们以后在ES6的时候

25:23.620 --> 25:24.620
肯定要学的

25:24.620 --> 25:26.620
不管你是什么教程

25:26.620 --> 25:28.620
你肯定要去学这些东西的

25:30.620 --> 25:31.620
现在不扯远了

25:31.620 --> 25:32.620
点一下

25:32.620 --> 25:34.620
你们知道有这么一个东西就行了

25:34.620 --> 25:35.620
它可能会出现在这种

25:35.620 --> 25:38.990
这种题的变种里面

25:38.990 --> 25:40.990
这是关于这个知名符号

25:40.990 --> 25:42.990
什么叫符号就符号

25:42.990 --> 25:43.990
为什么还要知名符号

25:43.990 --> 25:45.990
这些都是你们以后要学的

25:46.990 --> 25:51.780
这是第七题

25:54.780 --> 25:56.780
我就顺便问一个问题

25:56.780 --> 25:57.780
我想到这了

25:57.780 --> 25:58.780
我就顺便问一下

25:58.780 --> 26:00.780
这个还不是ES6的

26:00.780 --> 26:02.780
GS的数据类型有几种

26:02.780 --> 26:04.780
我刚才说到原始类型

26:04.780 --> 26:06.780
我就想问一下

26:06.780 --> 26:08.780
GS的数据类型

26:08.780 --> 26:09.780
这个你应该是你们

26:09.780 --> 26:11.780
第一几课就要学习的

26:11.780 --> 26:17.330
有几种

26:17.330 --> 26:18.330
八种

26:18.330 --> 26:21.330
还有没有别的

26:21.330 --> 26:22.330
三种

26:22.330 --> 26:24.330
哪三种

26:24.330 --> 26:26.330
哪三种

26:26.330 --> 26:29.830
两种

26:29.830 --> 26:30.830
七种

26:30.830 --> 26:35.170
哪七种

26:35.170 --> 26:36.170
这里

26:36.170 --> 26:38.170
如果说你说的是

26:38.170 --> 26:41.170
六种 七种 八种

26:41.170 --> 26:44.170
我觉得面试官他都能接受

26:44.170 --> 26:47.170
六种 七种他能接受的

26:47.170 --> 26:49.170
八种是正确答案

26:49.170 --> 26:52.170
我这里说一下哪八种数据类型

26:52.170 --> 26:54.170
如果说你给你们想的不一样的话

26:54.170 --> 26:56.170
一定以我为准

26:56.170 --> 26:58.170
一个是

26:58.170 --> 27:00.170
原始类型

27:00.170 --> 27:03.170
原始类型一共有七种

27:03.170 --> 27:04.170
Now

27:04.170 --> 27:06.170
Undefend

27:06.170 --> 27:08.170
没错了

27:08.170 --> 27:11.170
Undefend

27:11.170 --> 27:14.170
数字Number

27:14.170 --> 27:16.170
Number

27:16.170 --> 27:20.170
字符串Stune

27:20.170 --> 27:22.170
我还得说一说

27:22.170 --> 27:25.170
不利

27:25.170 --> 27:26.170
一二三四五了

27:26.170 --> 27:28.170
然后symbol

27:29.170 --> 27:31.170
这是es6的符号

27:31.170 --> 27:33.170
然后是begin

27:33.170 --> 27:38.920
后面那个是新版本夹的

27:38.920 --> 27:40.920
原始类型你至少要回答出来

27:40.920 --> 27:43.920
这么五种原始类型

27:43.920 --> 27:44.920
然后呢

27:44.920 --> 27:48.920
对象类型就一种

27:48.920 --> 27:52.920
引用类型就一种对象

27:52.920 --> 27:54.920
所以这一块如果说你回答

27:54.920 --> 27:56.920
既然是数据类型的时候

27:56.920 --> 27:58.920
基本问题是

27:58.920 --> 28:00.920
如果你数据类型哪些

28:00.920 --> 28:02.920
你可以说六种都没事

28:02.920 --> 28:04.920
因为这两个东西可能

28:04.920 --> 28:06.920
symbol你不知道

28:06.920 --> 28:07.920
还是真不合适

28:07.920 --> 28:09.920
你至少得说七种

28:09.920 --> 28:12.920
你原始类型说出这六种

28:12.920 --> 28:13.920
没事

28:13.920 --> 28:15.920
原始官一般可以体谅

28:15.920 --> 28:17.920
因为这个玩意要用的确实是少

28:17.920 --> 28:19.920
可以体谅你

28:19.920 --> 28:20.920
但是你如果说去

28:20.920 --> 28:22.920
说什么函数类型

28:22.920 --> 28:24.920
说什么数据类型那就错了

28:24.920 --> 28:26.920
那就不能体谅了

28:27.920 --> 28:29.920
只能是有一种

28:29.920 --> 28:32.920
什么那个数据

28:32.920 --> 28:34.920
函数都归类为对象

28:34.920 --> 28:39.380
想归类成原始类型

28:39.380 --> 28:41.380
和引用类型没展开

28:41.380 --> 28:42.380
这个呢

28:42.380 --> 28:44.380
你练习官就看

28:44.380 --> 28:45.380
他怎么去想了

28:45.380 --> 28:46.380
他可能觉得这个学生呢

28:46.380 --> 28:48.380
可能比较高冷

28:48.380 --> 28:50.380
不愿意给我多BB

28:50.380 --> 28:51.380
所以说我可能

28:51.380 --> 28:54.380
我也不想给他多BB了

28:54.380 --> 28:56.380
这淘汰展开说一下

28:56.380 --> 28:58.380
毕竟官方文道里面都展开了

29:04.150 --> 29:06.150
好 然后看那个

29:07.150 --> 29:08.150
这是第七题了

29:08.150 --> 29:10.150
第七题 七题说完了

29:10.150 --> 29:16.180
第八题

29:16.180 --> 29:17.180
symbol太难了

29:17.180 --> 29:19.180
symbol有什么好难的

29:19.180 --> 29:21.180
它哪在哪呢

29:22.180 --> 29:24.180
无非就搞了一个新的类型出来

29:24.180 --> 29:25.180
就是一个值

29:25.180 --> 29:27.180
跟那个数字 字幕串

29:27.180 --> 29:28.180
那昂迪汉的

29:28.180 --> 29:29.180
没有什么本质的区别

29:29.180 --> 29:30.180
它就是搞出一种

29:30.180 --> 29:32.180
新的数据类型

29:32.180 --> 29:34.180
用这个值去作为属性名

29:34.180 --> 29:36.180
symbol的数用就是来做属性名的

29:36.180 --> 29:37.180
以前的属性名

29:37.180 --> 29:39.180
全是字无事

29:39.180 --> 29:42.490
现在可以用符号了

29:42.490 --> 29:43.490
你可能 如果说你觉得

29:43.490 --> 29:44.490
symbol难的话

29:44.490 --> 29:45.490
可能啊

29:45.490 --> 29:47.490
我现在不知道你的具体情况

29:47.490 --> 29:50.490
可能是你前边有一些问题

29:50.490 --> 29:51.490
比方说你可能前边

29:51.490 --> 29:53.490
这种东西看不懂

29:53.490 --> 29:58.340
你看不懂这个东西

29:58.340 --> 30:00.340
你看不懂这个东西

30:00.340 --> 30:02.340
你误认为这个东西

30:02.340 --> 30:03.340
是symbol带来的

30:03.340 --> 30:04.340
并不是

30:04.340 --> 30:05.340
用不用symbol

30:05.340 --> 30:07.340
它都有这个东西

30:07.340 --> 30:09.340
这叫用表达式

30:09.340 --> 30:12.340
作为对象的属性名

30:12.340 --> 30:13.340
比方说我有一个属

30:13.340 --> 30:16.340
我有一个变量T等于abc

30:16.340 --> 30:17.340
我想把这个T的值

30:17.340 --> 30:18.340
作为属性名

30:18.340 --> 30:20.340
写到对象字面量里面去

30:20.340 --> 30:22.340
你能听懂我刚才说的话吗

30:22.340 --> 30:24.340
我要把这个属性的值

30:24.340 --> 30:26.340
作为属性名

30:26.340 --> 30:28.340
写到这个对象字面量里面去

30:28.340 --> 30:30.340
对象字面量你听过吗

30:30.340 --> 30:35.060
就可以这样写

30:35.060 --> 30:36.060
这叫属性表达式

30:36.060 --> 30:37.060
就是这里面你可以写任何东西

30:37.060 --> 30:39.060
它会把这个东西算出来

30:39.060 --> 30:40.060
来作为它的属性名字

30:40.060 --> 30:42.060
特别简单

30:42.060 --> 30:44.940
只不过symbol

30:44.940 --> 30:46.940
就借用了这种写法而已

30:46.940 --> 30:50.640
symbol本身没什么难的

30:50.640 --> 30:51.640
好 看一下这道题

30:51.640 --> 30:57.640
这道题考察的是Posint

30:57.640 --> 30:59.640
对Posint的掌握

30:59.640 --> 31:00.640
Posint这个API

31:00.640 --> 31:01.640
虽然说我们不背API

31:01.640 --> 31:03.640
从来不需要背API

31:03.640 --> 31:06.640
但这个API毕竟用的太多了

31:06.640 --> 31:07.640
这个玩意儿是不是经常用

31:07.640 --> 31:10.640
你们都用过吧

31:10.640 --> 31:12.640
但是你们可能

31:12.640 --> 31:14.640
很多同学并没有去看

31:14.640 --> 31:17.640
他的官方文档

31:17.640 --> 31:19.640
官方文档里边有很重要的一句话

31:19.640 --> 31:21.640
以后给你们看一下

31:21.640 --> 31:23.640
Posint

31:23.640 --> 31:25.640
这个map

31:25.640 --> 31:26.640
有没有同学不知道map的

31:26.640 --> 31:27.640
不知道map我可以讲一下

31:27.640 --> 31:29.640
不知道map的Q对E

31:29.640 --> 31:35.280
OK吧

31:35.280 --> 31:36.280
好

31:36.280 --> 31:37.280
我先讲一下map

31:37.280 --> 31:38.280
不然的话你这道题玩不了

31:38.280 --> 31:40.280
你首先得知道map

31:40.280 --> 31:42.280
Posint你们肯定知道

31:42.280 --> 31:44.280
完全是要知道map

31:44.280 --> 31:46.280
这里有一个数组

31:46.280 --> 31:47.280
所有的数组里面

31:47.280 --> 31:50.280
都会有一个函数叫map

31:50.280 --> 31:51.280
这是一个函数

31:51.280 --> 31:54.280
它会传入一个参数

31:54.280 --> 31:57.280
它会返回一个新的数据

31:57.280 --> 32:00.280
这是map函数的作用

32:00.280 --> 32:01.280
传入一个参数

32:01.280 --> 32:03.280
然后返回一个新的数据

32:03.280 --> 32:04.280
就这么个意思

32:04.280 --> 32:05.280
那么map是什么呢

32:05.280 --> 32:07.280
map在英文单词里面叫做

32:07.280 --> 32:09.280
它有很多意思

32:09.280 --> 32:11.280
有地图的意思

32:11.280 --> 32:14.280
那么这里叫做映色

32:14.280 --> 32:16.280
什么叫映色呢

32:16.280 --> 32:18.280
就是我原来数组里面

32:18.280 --> 32:19.280
不是有很多箱吗

32:19.280 --> 32:21.280
一个 两个 三个

32:21.280 --> 32:23.280
我想把第一箱

32:23.280 --> 32:25.280
变成另外一个东西

32:25.280 --> 32:28.280
比方说变成一个

32:28.280 --> 32:30.280
乘以二的数字

32:30.280 --> 32:31.280
变成二

32:31.280 --> 32:32.280
这个变成四

32:32.280 --> 32:33.280
这个变成六

32:33.280 --> 32:34.280
这样子是不是

32:34.280 --> 32:36.280
形成了一个新的数据

32:36.280 --> 32:37.280
二

32:37.280 --> 32:38.280
四

32:38.280 --> 32:39.280
六

32:39.280 --> 32:41.280
能做到这意思吗

32:41.280 --> 32:42.280
那么对于我们

32:42.280 --> 32:43.280
不去看每一项

32:43.280 --> 32:45.280
我们就看它其中一项

32:45.280 --> 32:47.280
是不是产生了一个变化

32:47.280 --> 32:49.280
它变到了它

32:49.280 --> 32:52.280
这个过程就叫做映色

32:52.280 --> 32:54.280
那么对于我们就是

32:54.280 --> 32:56.280
有一个映色规则

32:56.280 --> 32:57.280
每一项

32:57.280 --> 32:59.280
原来的值是啥

32:59.280 --> 33:00.280
我用什么样的规则

33:00.280 --> 33:02.280
把它变成一个新的值

33:02.280 --> 33:04.280
这就是映色规则

33:04.280 --> 33:06.280
懂了意思吧

33:06.280 --> 33:08.280
那么对每一项

33:08.280 --> 33:10.280
对每一项都去使用这个规则

33:10.280 --> 33:12.280
是不是产生了一个新的数据

33:13.280 --> 33:15.280
对不对 这就是映色

33:15.280 --> 33:17.280
能力业吧 能力业Q和E

33:17.280 --> 33:22.380
这个应该好理解吧

33:22.380 --> 33:24.380
就对每一项用一个规则

33:24.380 --> 33:26.380
让它内向发生变化

33:26.380 --> 33:27.380
得到一个新的值

33:27.380 --> 33:29.380
这个过程就叫映色

33:29.380 --> 33:30.380
你要问我为什么叫映色

33:30.380 --> 33:31.380
我也不知道

33:31.380 --> 33:32.380
为什么叫映色

33:32.380 --> 33:36.140
它就叫映色

33:36.140 --> 33:37.140
那么这样子

33:37.140 --> 33:38.140
整个数据都去应用这个规则

33:38.140 --> 33:40.140
就会产生一个新的数据

33:40.140 --> 33:42.140
这就是Map所说的事

33:42.140 --> 33:45.780
那么这里边传的是什么呢

33:45.780 --> 33:48.780
它传的只能是一个叫映色规则

33:49.780 --> 33:53.150
怎么去映色的

33:53.150 --> 33:55.150
那么这个规则具体该怎么写呢

33:55.150 --> 33:57.150
其实写的是一个函数

33:57.150 --> 33:59.150
这里其实要写个函数

33:59.150 --> 34:02.150
你可以写个函数的字面量

34:02.150 --> 34:07.940
所以我们整个前端学习

34:07.940 --> 34:09.940
也好后端学习

34:09.940 --> 34:12.940
最重要的是基础

34:12.940 --> 34:14.940
你基础不恶劳

34:14.940 --> 34:19.570
你连别人说话都听不懂

34:20.570 --> 34:23.570
这个东西叫做函数字面量

34:23.570 --> 34:26.880
这个直接写的

34:26.880 --> 34:28.880
我们也可以称它为匿名函数

34:28.880 --> 34:30.880
或者是函数表达式

34:30.880 --> 34:32.880
都可以

34:32.880 --> 34:34.880
它也叫做函数字面量

34:34.880 --> 34:36.880
当然你也可以去写一个

34:36.880 --> 34:38.880
写一个函数

34:38.880 --> 34:40.880
比如说写一个abc这个函数

34:40.880 --> 34:43.880
这叫做函数声名

34:44.880 --> 34:45.880
它不叫函数表达式

34:45.880 --> 34:46.880
它叫函数声名

34:46.880 --> 34:48.880
然后把函数的名字传过来

34:48.880 --> 34:50.880
也和一样的

34:50.880 --> 34:51.880
反正要给它一个函数

34:51.880 --> 34:53.880
就这么个意思

34:53.880 --> 34:55.880
基础不恶真的是地动山谣

34:55.880 --> 34:56.880
你啥都学不了

34:56.880 --> 34:57.880
你以为自己学会了

34:57.880 --> 34:59.880
其实全面会

34:59.880 --> 35:02.880
你会得那一点点东西

35:02.880 --> 35:04.880
全是背出来的

35:04.880 --> 35:05.880
很不牢靠的

35:05.880 --> 35:06.880
稍微变化一点

35:06.880 --> 35:07.880
你完全就不会了

35:07.880 --> 35:08.880
老实讲过的

35:08.880 --> 35:09.880
必须要一模一样的体力

35:09.880 --> 35:10.880
才能做得出来

35:10.880 --> 35:11.880
稍微变化一点

35:11.880 --> 35:12.880
你又误会了

35:12.880 --> 35:14.880
基础不恶就会有这样的一个问题

35:14.880 --> 35:16.880
我们这一块学习基础

35:16.880 --> 35:17.880
我建议同学们

35:17.880 --> 35:20.880
我们的课程安排是两个月

35:20.880 --> 35:21.880
两个月你啥也别想

35:21.880 --> 35:23.880
你不要就给我想了什么

35:23.880 --> 35:24.880
框架的

35:24.880 --> 35:25.880
想的不要够想

35:25.880 --> 35:27.880
就接触是基础

35:27.880 --> 35:28.880
A.T.M.S.也是基础

35:28.880 --> 35:30.880
说我两个月

35:30.880 --> 35:32.880
我两个月突然过了考试

35:32.880 --> 35:34.880
再给我说后边的事情

35:34.880 --> 35:35.880
你才有资格

35:35.880 --> 35:37.880
去聊后边的事情

35:37.880 --> 35:38.880
后边的事情

35:38.880 --> 35:40.880
要离框架离物又还远的很

35:40.880 --> 35:41.880
我不想你让你们

35:41.880 --> 35:43.880
过早的去接触框架

35:43.880 --> 35:44.880
也结束完了

35:44.880 --> 35:45.880
你看了满天你以为会了

35:45.880 --> 35:46.880
学啥也不会

35:46.880 --> 35:55.070
那么这大学老师就算了吧

35:55.070 --> 35:59.070
我也期望咱们中国有一天

35:59.070 --> 36:00.070
大学讲的东西

36:00.070 --> 36:01.070
真正能够在你们

36:01.070 --> 36:03.070
企业开发里面用上

36:03.070 --> 36:04.070
我也期望咱们有一天

36:04.070 --> 36:06.070
咱们的值高真正发展起来

36:06.070 --> 36:08.070
让我们这些培训机构

36:08.070 --> 36:09.070
完全没有生存的空间

36:09.070 --> 36:12.070
我举双手赞成

36:12.070 --> 36:16.070
就是因为高等教育的缺失

36:16.070 --> 36:18.070
才不得不当我们

36:18.070 --> 36:25.800
继续去弥补这一块

36:25.800 --> 36:27.800
Mab里面传的是一个函数

36:27.800 --> 36:28.800
这个函数

36:28.800 --> 36:29.800
不管你是写到外边

36:29.800 --> 36:30.800
传一个名字进来

36:30.800 --> 36:31.800
还是你直接在这里写个函数

36:31.800 --> 36:34.800
反正它会传一个函数

36:34.800 --> 36:35.800
那么这个函数传进

36:35.800 --> 36:36.800
它怎么会玩呢

36:36.800 --> 36:38.800
你看着它是怎么玩的

36:38.800 --> 36:39.800
你不是用的是元素组吗

36:39.800 --> 36:41.800
你看元素组你不是

36:41.800 --> 36:42.800
硬设吗

36:42.800 --> 36:43.800
好

36:43.800 --> 36:46.800
它会产生一个新数组

36:46.800 --> 36:47.800
这个新数组有几项呢

36:47.800 --> 36:49.800
元素组有几个项

36:49.800 --> 36:50.800
我就有几项

36:50.800 --> 36:51.800
第一项

36:51.800 --> 36:52.800
第二项

36:52.800 --> 36:53.800
第三项

36:53.800 --> 36:55.800
这是会产生的新数组

36:55.800 --> 36:58.110
这样就是硬设了

36:58.110 --> 36:59.110
怎么硬设呢

36:59.110 --> 37:01.110
很简单

37:01.110 --> 37:04.110
它把第一项拿出来

37:04.110 --> 37:07.110
调用这个函数

37:07.110 --> 37:09.110
把这个函数走一遍

37:09.110 --> 37:10.110
你传了一个函数进去

37:10.110 --> 37:12.110
把这个函数走一遍

37:12.110 --> 37:14.110
它会传三个函数进去

37:14.110 --> 37:15.110
比方说有几个例子

37:15.110 --> 37:18.110
这个函数你写的是ABC

37:18.110 --> 37:19.110
假设

37:19.110 --> 37:21.110
它就会调用这个函数ABC

37:21.110 --> 37:22.110
传三个函数进去

37:22.110 --> 37:28.110
第一个函数是第一项的直传进去

37:28.110 --> 37:32.110
第二个函数是它的下标0传进去

37:32.110 --> 37:34.110
第三个函数是整个数组

37:34.110 --> 37:35.110
它可以传进去

37:35.110 --> 37:36.110
当然第三个函数

37:36.110 --> 37:38.110
我们一般来说都不太用得到的

37:38.110 --> 37:40.110
一般来说都不太用得到

37:40.110 --> 37:43.110
我们就看它两个函数吧

37:43.110 --> 37:44.110
第一个函数

37:44.110 --> 37:45.110
看到没有

37:45.110 --> 37:46.110
它怎么来调一个函数呢

37:46.110 --> 37:47.110
它就这样调一遍

37:47.110 --> 37:48.110
非常简单

37:48.110 --> 37:49.110
好好听

37:49.110 --> 37:51.110
把第一项管理的是啥

37:51.110 --> 37:52.110
把它给传进去

37:52.110 --> 37:54.110
作为函数给传进去

37:54.110 --> 37:58.110
第二个函数就是下标0传进去

37:58.110 --> 37:59.110
把这个函数走一遍

37:59.110 --> 38:02.110
然后把这个函数的返回结果

38:02.110 --> 38:04.110
作为它的第一项的直

38:04.110 --> 38:06.110
你看这不就因收了吗

38:06.110 --> 38:07.110
这个玩意儿

38:07.110 --> 38:10.110
这个函数扔进来走一遍

38:10.110 --> 38:11.110
走完了这一遍

38:11.110 --> 38:14.110
不就形成了它的遗乡了吗

38:14.110 --> 38:15.110
它就是因收

38:15.110 --> 38:18.550
因收就这样玩的

38:18.550 --> 38:19.550
那么也就是这个函数

38:19.550 --> 38:20.550
如果说你需要的话

38:20.550 --> 38:23.550
你也可以接收这两个参数

38:23.550 --> 38:24.550
当然你不要第二个

38:24.550 --> 38:26.550
你接收一个也可以

38:26.550 --> 38:27.550
对吧

38:27.550 --> 38:28.550
你随便写个参数的名字

38:28.550 --> 38:29.550
这个参数的名字随便写

38:29.550 --> 38:30.550
我现在又特别担心

38:30.550 --> 38:35.310
你们函数的一块没搞清楚

38:35.310 --> 38:37.310
那我是在我几讯营里边

38:37.310 --> 38:38.310
是真解决不了了

38:38.310 --> 38:40.310
至少我们这一次几讯营

38:40.310 --> 38:41.310
它的时间解决不了了

38:41.310 --> 38:42.310
后面咱们有介事的

38:42.310 --> 38:43.310
零跑计划

38:43.310 --> 38:45.310
那就是从零基础开始

38:45.310 --> 38:47.310
代理学介事

38:47.310 --> 38:48.310
我就怕你们这个

38:48.310 --> 38:49.310
这是形差

38:49.310 --> 38:50.310
这个形差随便的写

38:50.310 --> 38:53.010
好

38:53.010 --> 38:55.010
那么这就相当于是

38:55.010 --> 38:57.010
把这个玩意传给了这个玩意了

38:57.010 --> 38:58.010
当然是吧

38:58.010 --> 39:00.010
当然我第二个参数不需要

39:00.010 --> 39:03.010
我反而回一个item成语2

39:03.010 --> 39:04.010
你看这个刀

39:04.010 --> 39:06.010
你看我先看运行结果

39:06.010 --> 39:07.010
先看运行结果

39:07.010 --> 39:11.700
new numbers

39:11.700 --> 39:12.700
26了

39:12.700 --> 39:13.700
硬色出来是一个新数组

39:13.700 --> 39:15.700
原来的数组不变

39:15.700 --> 39:16.700
它不会改变原来的数组

39:16.700 --> 39:17.700
它会产生一个新数组

39:17.700 --> 39:18.700
就是26

39:18.700 --> 39:20.700
你可以在这里接收

39:20.700 --> 39:21.700
看到没

39:21.700 --> 39:22.700
怎么来了

39:22.700 --> 39:23.700
再来一遍

39:23.700 --> 39:27.700
一拿过来

39:27.700 --> 39:31.020
返回来说什么了

39:31.020 --> 39:33.020
就是这个字书创一乘一二

39:33.020 --> 39:34.020
本来不就是二吗

39:34.020 --> 39:36.020
第一项就出来了

39:36.020 --> 39:38.020
二看到没

39:38.020 --> 39:39.020
好

39:39.020 --> 39:41.020
然后

39:41.020 --> 39:44.020
然后那个

39:44.020 --> 39:45.020
二

39:45.020 --> 39:46.020
第二项

39:46.020 --> 39:47.020
传过来

39:47.020 --> 39:48.020
把这个函数走一遍

39:48.020 --> 39:49.020
返回什么了

39:49.020 --> 39:50.020
返回4

39:50.020 --> 39:51.020
那么第二项就是4

39:51.020 --> 39:53.020
就这么简单

39:53.020 --> 39:55.020
第三项传过来

39:55.020 --> 39:57.020
这个函数走一遍

39:57.020 --> 39:58.020
返回啥

39:58.020 --> 39:59.020
返回了16

39:59.020 --> 40:00.020
那第三项就是6

40:00.020 --> 40:01.020
所以就称成了26了

40:01.020 --> 40:03.020
这就是硬色

40:03.020 --> 40:04.020
硬色是我们以后

40:04.020 --> 40:05.020
在开发中

40:05.020 --> 40:08.020
经常要用到一个数组方法

40:08.020 --> 40:10.020
特别特别好用

40:10.020 --> 40:12.020
以后你们慢慢去体会

40:12.020 --> 40:14.020
这个还要很有用的

40:14.020 --> 40:15.020
我们ES

40:15.020 --> 40:16.020
这是ES5的方法

40:16.020 --> 40:17.020
ES5里边产生了

40:17.020 --> 40:18.020
很多的数组方法

40:18.020 --> 40:19.020
包括什么MAP

40:19.020 --> 40:21.020
包括FILTER

40:21.020 --> 40:22.020
包括ES6的

40:22.020 --> 40:24.020
FEND

40:24.020 --> 40:26.020
包括SUM

40:26.020 --> 40:28.020
还有那些

40:28.020 --> 40:29.020
我一下记不全了

40:29.020 --> 40:30.020
后期课程

40:30.020 --> 40:32.020
我们会有一个完整的文档

40:32.020 --> 40:33.020
给大家列举了数组

40:33.020 --> 40:35.020
比较各种这样的方法

40:35.020 --> 40:37.020
给大家看一下

40:37.020 --> 40:46.860
在课程

40:46.860 --> 40:51.620
基础里的行业手冠

40:51.620 --> 40:53.620
标准枯里边

40:53.620 --> 40:54.620
多啊

40:54.620 --> 40:59.150
数组

40:59.150 --> 41:00.150
像这些东西

41:00.150 --> 41:01.150
你们不用去使进硬背

41:01.150 --> 41:03.150
都是要查越文档的

41:03.150 --> 41:04.150
这里边

41:04.150 --> 41:05.150
我的文档里边

41:05.150 --> 41:07.150
给你们提供了简单的

41:07.150 --> 41:09.530
我的文档里边

41:09.530 --> 41:11.530
提供了简单的解释

41:14.530 --> 41:15.530
也可以点击进去

41:15.530 --> 41:18.530
查看官方文档的完整解释

41:20.530 --> 41:21.530
这还不在这

41:21.530 --> 41:23.530
文档还不在这

41:23.530 --> 41:24.530
在这

41:24.530 --> 41:31.810
在这

41:31.810 --> 41:33.810
数组

41:33.810 --> 41:34.810
新增API

41:34.810 --> 41:36.810
可以我们画了一个图

41:36.810 --> 41:40.950
我的画图

41:40.950 --> 41:41.950
我的画图

41:41.950 --> 41:43.950
是受到同学的一致好评的

41:43.950 --> 41:45.950
你看这个feel

41:45.950 --> 41:47.950
它就是把一个空数组

41:47.950 --> 41:49.950
通过一个函数feel

41:49.950 --> 41:51.950
就可以填充所有相同的东西

41:51.950 --> 41:52.950
通过图很直观的

41:52.950 --> 41:54.950
可以看出它的作用是啥

41:54.950 --> 41:55.950
for each 呢

41:55.950 --> 41:57.950
就是把这个对象

41:57.950 --> 41:59.950
把这个数组便利一遍

41:59.950 --> 42:00.950
把一个一个拿出来

42:00.950 --> 42:02.950
做任何事情可以

42:02.950 --> 42:04.950
Map这个印射

42:04.950 --> 42:05.950
你看了没

42:05.950 --> 42:06.950
你看那个图

42:06.950 --> 42:07.950
看得清楚吗

42:07.950 --> 42:09.950
是不是能够表现出印射

42:09.950 --> 42:10.950
以前的数组里面

42:10.950 --> 42:11.950
是一个圈儿

42:11.950 --> 42:12.950
一个三角

42:12.950 --> 42:13.950
一个各种形状

42:13.950 --> 42:15.950
我通过一个印射规则

42:15.950 --> 42:17.950
往每个形状里面加一个十字下

42:17.950 --> 42:20.950
就产生了一个新的数组

42:20.950 --> 42:23.950
feel是进行筛选的

42:23.950 --> 42:25.950
原数组满足条件的留下

42:25.950 --> 42:27.950
不满足条件的扔掉

42:27.950 --> 42:29.950
比方说像这些满足条件的

42:29.950 --> 42:30.950
我就留下

42:30.950 --> 42:31.950
一些不满足条件的

42:31.950 --> 42:32.950
我就扔掉

42:33.950 --> 42:35.950
Reduce就是汇总

42:35.950 --> 42:36.950
你看我把

42:36.950 --> 42:37.950
这个是一个元素组

42:37.950 --> 42:39.950
汇总出来就只有一项了

42:39.950 --> 42:40.950
就只有一个纸

42:40.950 --> 42:41.950
这个纸里面

42:41.950 --> 42:44.950
包含了元素组里面所有的东西

42:44.950 --> 42:46.950
Reduce

42:46.950 --> 42:48.950
Sum是做那个

42:48.950 --> 42:49.950
判断数组里面

42:49.950 --> 42:52.950
有没有至少存在一个满足条件的

42:52.950 --> 42:54.950
比方说我要至少有三个边

42:54.950 --> 42:55.950
那么这个数组里面

42:55.950 --> 42:56.950
有三个边的是有三个

42:56.950 --> 42:58.950
那么至少有一个满足条件

42:58.950 --> 43:00.950
那得到就是Q

43:00.950 --> 43:02.950
Avery是必须要每一个满足条件

43:02.950 --> 43:04.950
那只有三个满足条件

43:04.950 --> 43:05.950
那就不行

43:05.950 --> 43:06.950
当然你也可以点击进去

43:06.950 --> 43:08.950
查看它的完整的官方文档

43:08.950 --> 43:09.950
也可以

43:10.950 --> 43:12.950
这些玩意就查阅文档的干活

43:12.950 --> 43:13.950
就完事了

43:13.950 --> 43:15.950
真心争了很多的数组方法

43:18.260 --> 43:19.260
文档

43:19.260 --> 43:20.260
文档

43:20.260 --> 43:21.260
那个文档我一会儿

43:21.260 --> 43:23.260
一会儿给你们发下来吧

43:23.260 --> 43:27.470
我觉得无所谓

43:27.470 --> 43:30.470
也就是咱们后期课的文档

43:30.470 --> 43:32.470
反正我发给学老师吧

43:32.470 --> 43:33.470
我觉得无所谓

43:33.470 --> 43:34.470
发给你们吧

43:34.470 --> 43:35.470
没啥事

43:35.470 --> 43:40.510
因为我们后期课的价值

43:41.510 --> 43:43.510
主要在我们的课程里边

43:48.590 --> 43:49.590
说回来

43:49.590 --> 43:50.590
这是印射

43:50.590 --> 43:51.590
听懂了吗

43:51.590 --> 43:52.590
在里面传个韩数

43:52.590 --> 43:53.590
这个就是印射规则

43:53.590 --> 43:55.590
我们说回到这道题

43:56.590 --> 43:58.590
首先这种邪法可不可以

43:58.590 --> 43:59.590
可以

43:59.590 --> 44:01.590
数组有个韩数印射

44:01.590 --> 44:03.590
传的是啥

44:03.590 --> 44:04.590
投资印射你不要告诉我

44:04.590 --> 44:05.590
它不是韩数

44:05.590 --> 44:06.590
投资印射肯定是韩数

44:06.590 --> 44:07.590
传的是韩数

44:07.590 --> 44:09.590
刚刚我们自己写的韩数

44:09.590 --> 44:10.590
是不是都是韩数

44:10.590 --> 44:12.590
只要是韩数就行

44:12.590 --> 44:14.590
那它怎么运行的呢

44:14.590 --> 44:16.590
它这个印射怎么运行的呢

44:16.590 --> 44:18.590
你想那个道理吧

44:18.590 --> 44:19.590
刚才我们是不是

44:19.590 --> 44:21.590
聊过这个韩数怎么运行的

44:21.590 --> 44:24.590
把第一项拿出来

44:24.590 --> 44:26.590
它得到一个新数组对吧

44:26.590 --> 44:28.590
新数组的第一项

44:28.590 --> 44:30.590
新数组的第一项

44:30.590 --> 44:32.590
新数组的第二项

44:32.590 --> 44:34.590
新数组的第三项

44:34.590 --> 44:35.590
什么来自于印射规则

44:35.590 --> 44:36.590
印射规则是啥

44:36.590 --> 44:37.590
第一项是啥

44:37.590 --> 44:38.590
第一项不就是

44:38.590 --> 44:40.590
调用投资印射吗

44:40.590 --> 44:42.590
你传的韩数调用一遍

44:42.590 --> 44:44.590
传几个参数

44:44.590 --> 44:46.590
同学们刚才我说了

44:46.590 --> 44:47.590
几个参数传进去

44:47.590 --> 44:48.590
两个

44:48.590 --> 44:49.590
一个是个数组

44:49.590 --> 44:50.590
第一项的值

44:50.590 --> 44:52.590
这个传进去

44:52.590 --> 44:53.590
然后呢

44:53.590 --> 44:54.590
还要传什么

44:54.590 --> 44:55.590
第二个参数

44:55.590 --> 44:56.590
第二个参数是

44:56.590 --> 44:57.590
下标传进去

44:57.590 --> 45:02.420
第二项投资印射

45:02.420 --> 45:03.420
传什么

45:03.420 --> 45:04.420
传第二项的值

45:04.420 --> 45:06.420
然后传下标传进去

45:06.420 --> 45:09.420
第三项投资印射

45:10.420 --> 45:11.420
三传进去

45:11.420 --> 45:12.420
二传进去

45:14.420 --> 45:15.420
就知道提能力

45:15.420 --> 45:17.420
能等这个Map是啥意思

45:17.420 --> 45:18.420
它传的是两个参数

45:18.420 --> 45:19.420
这是第一个考点

45:19.420 --> 45:21.420
对Map数不数

45:21.420 --> 45:22.420
有些

45:22.420 --> 45:24.420
其实我不是很赞成

45:24.420 --> 45:26.420
公司里边去考API

45:26.420 --> 45:28.420
但是有些常用的API

45:30.420 --> 45:31.420
它考虑常用的API

45:31.420 --> 45:32.420
你做不出来

45:32.420 --> 45:34.420
那就真的是你的问题了

45:34.420 --> 45:36.420
一些比较偏的API

45:36.420 --> 45:37.420
你做不出来

45:37.420 --> 45:38.420
你可以说

45:38.420 --> 45:39.420
我们平时不打用

45:39.420 --> 45:40.420
可能会忘了

45:40.420 --> 45:41.420
它都能够理解

45:41.420 --> 45:42.420
常用的做不出来

45:42.420 --> 45:44.420
顺便一单码量写的不多

45:44.420 --> 45:45.420
没怎么写单码

45:45.420 --> 45:46.420
这种API太常见了

45:46.420 --> 45:47.420
这种API太常见了

45:50.420 --> 45:52.420
现在我们问题转发成了

45:52.420 --> 45:53.420
这个玩意得到值是多少

45:53.420 --> 45:55.420
把这个值作为第一项的值

45:55.420 --> 45:57.420
把这个值作为第二项的值

45:57.420 --> 45:58.420
把这个值作为第三项的值

45:58.420 --> 46:00.420
现在就这个问题了

46:01.420 --> 46:02.420
而Pause印射的同学们

46:02.420 --> 46:03.420
很多时候

46:03.420 --> 46:05.420
用的时候只传一个参数

46:06.420 --> 46:07.420
包括元老师

46:07.420 --> 46:09.420
很多时候也只传一个参数

46:10.420 --> 46:12.420
至少我知道有两个参数

46:12.420 --> 46:17.200
得到一个数字一

46:17.200 --> 46:19.200
那第二个参数是啥意思呢

46:19.200 --> 46:20.200
同学们

46:20.200 --> 46:22.200
第二个参数叫做禁制

46:23.200 --> 46:25.200
比方说我这里11

46:25.200 --> 46:26.200
我这里写个2

46:26.200 --> 46:27.200
说的啥

46:27.200 --> 46:29.200
我在转换成数字的时候

46:29.200 --> 46:31.200
要用22禁制进行转换

46:31.200 --> 46:32.200
就这个意思

46:32.200 --> 46:34.200
除了这个转换出来多少

46:34.200 --> 46:35.200
得到3

46:35.200 --> 46:36.200
看到没

46:36.200 --> 46:37.200
这是22禁制

46:37.200 --> 46:38.200
你要再来一个

46:38.200 --> 46:39.200
16禁制呢

46:44.390 --> 46:45.390
17

46:45.390 --> 46:46.390
16禁制的17

46:46.390 --> 46:47.390
不是17

46:47.390 --> 46:49.390
16禁制的17

46:50.390 --> 46:51.390
就是17

46:51.390 --> 46:53.390
得到10禁制的就是17

46:53.390 --> 46:54.390
懂得意思吗

46:54.390 --> 46:56.390
它把它当成16禁制来转换

46:56.390 --> 46:58.390
它把它当成2禁制来转

46:59.390 --> 47:01.390
好 那么现在我们一个个说

47:02.390 --> 47:05.390
你们觉得有没有0禁制

47:05.390 --> 47:11.860
不行

47:11.860 --> 47:12.860
有人在说

47:12.860 --> 47:13.860
为什么Pause印射不能写成

47:13.860 --> 47:14.860
不是写成这个

47:14.860 --> 47:16.860
那就是基础的问题了

47:16.860 --> 47:17.860
因为你写成这个的话

47:17.860 --> 47:18.860
就相当于是

47:18.860 --> 47:21.860
把这个表达是运行完了

47:21.860 --> 47:23.860
作为参数传进去

47:24.860 --> 47:26.860
这个表达是运行完了是啥呀

47:26.860 --> 47:27.860
是NAN

47:27.860 --> 47:28.860
因为你没有转换任何东西

47:28.860 --> 47:29.860
对吧

47:29.860 --> 47:30.860
那你这样子写的话

47:30.860 --> 47:32.860
就相当于是你传那个NAN进去了

47:32.860 --> 47:35.690
懂得意思吗

47:35.690 --> 47:39.190
而它要传的是什么

47:39.190 --> 47:41.190
它要传的是一个函数

47:41.190 --> 47:43.890
Pause印射

47:43.890 --> 47:44.890
它是不是函数吗

47:44.890 --> 47:45.890
你告诉我

47:45.890 --> 47:46.890
它是不是函数

47:46.890 --> 47:47.890
它肯定是函数

47:47.890 --> 47:49.890
这才叫函数

47:49.890 --> 47:52.890
你听懂吗

47:52.890 --> 47:55.890
你这叫函数调用

47:55.890 --> 47:58.890
这个会产生一个函数调用的结果

47:58.890 --> 48:00.890
懂得意思吗

48:00.890 --> 48:02.890
没有0禁制对吧

48:02.890 --> 48:04.890
说回了刚才的问题

48:04.890 --> 48:06.890
这个玩意没有0禁制

48:06.890 --> 48:07.890
那么没有0禁制

48:07.890 --> 48:08.890
它是一个无销的进制

48:08.890 --> 48:10.890
但是0在Pause印射里面

48:10.890 --> 48:14.200
是比较特殊的

48:14.200 --> 48:16.200
当你传0的时候

48:16.200 --> 48:19.200
或者传Andy Fan的时候

48:19.200 --> 48:21.200
听好吧

48:21.200 --> 48:23.200
Pause印射里面一个很小的细节

48:23.200 --> 48:25.200
当你传的是0

48:25.200 --> 48:28.200
或者传的是Andy Fan的时候

48:28.200 --> 48:32.540
它就当你没传

48:32.540 --> 48:33.540
它就当你没传

48:33.540 --> 48:36.540
没传的话它就相当于是函数调用

48:36.540 --> 48:37.540
这个玩意

48:37.540 --> 48:43.980
它默认

48:43.980 --> 48:45.980
它肯定是1

48:45.980 --> 48:47.980
实际上的官方文档里面

48:47.980 --> 48:49.980
可以有更详细的解释

48:49.980 --> 48:51.980
当你没有传第二个残数的时候

48:51.980 --> 48:53.980
你写0或者是Andy Fan

48:53.980 --> 48:55.980
那斗车相当于是你没传

48:55.980 --> 48:57.980
当你没有传第二个残数的时候

48:57.980 --> 49:01.980
它不一定是实际制转换

49:01.980 --> 49:03.980
有兴趣的同学可以看一下

49:03.980 --> 49:09.020
下面那篇文档

49:09.020 --> 49:18.370
可以看一下一个详细的文档

49:18.370 --> 49:19.370
在哪呢 在这

49:19.370 --> 49:25.860
如果这个禁制传的是Andy Fan

49:25.860 --> 49:26.860
或者是0

49:26.860 --> 49:28.860
或者是没传

49:28.860 --> 49:31.860
它不一定是实际制

49:31.860 --> 49:33.860
价表几种情况

49:33.860 --> 49:35.860
有兴趣的同学可以了解

49:35.860 --> 49:38.860
但目前我还

49:38.860 --> 49:41.860
我见过有在考这个点的

49:41.860 --> 49:43.860
但是很少

49:43.860 --> 49:45.860
有兴趣的可以了解

49:47.860 --> 49:49.860
但这段时间还没有去考它

49:49.860 --> 49:50.860
这个点

49:50.860 --> 49:51.860
就OK了

49:51.860 --> 49:52.860
那相当于是帮助进程

49:52.860 --> 49:53.860
这一项是啥

49:53.860 --> 49:54.860
不用1吗

49:54.860 --> 49:56.860
好 这一项

49:56.860 --> 49:58.860
有没有一禁制

49:59.860 --> 50:00.860
没有啊

50:00.860 --> 50:01.860
一禁制

50:01.860 --> 50:03.860
你怎么弄

50:03.860 --> 50:04.860
你咋禁

50:04.860 --> 50:05.860
只能全是0

50:05.860 --> 50:06.860
因为它不能出现1

50:06.860 --> 50:08.860
要交近位了

50:08.860 --> 50:09.860
怎么弄

50:10.860 --> 50:11.860
没法

50:11.860 --> 50:12.860
最小为二禁制

50:12.860 --> 50:14.860
所以说1是一个无销的禁制

50:14.860 --> 50:16.860
无销的禁制

50:16.860 --> 50:18.860
得到的就是NAN

50:18.860 --> 50:20.860
它没法转换

50:20.860 --> 50:21.860
没法转换

50:21.860 --> 50:24.860
这是因为禁制无销造成的

50:24.860 --> 50:27.860
其实官方文档里边也有详细说明

50:28.860 --> 50:29.860
在哪呢

50:29.860 --> 50:30.860
在这

50:30.860 --> 50:31.860
我们学前端

50:31.860 --> 50:34.860
我们学前端要看什么书啊

50:34.860 --> 50:38.360
不用看书

50:38.360 --> 50:40.360
袁老师从来没去看前端什么书

50:40.360 --> 50:41.360
后端我看了不少

50:41.360 --> 50:42.360
程序设计看了不少

50:42.360 --> 50:44.360
实相内的看了不少

50:44.360 --> 50:46.360
前端我从来不看书

50:46.360 --> 50:48.360
前端特点就是东西多

50:48.360 --> 50:50.360
API多

50:50.360 --> 50:52.360
不需要看书

50:52.360 --> 50:54.360
而且更新比较快

50:54.360 --> 50:55.360
一看书刚看完了

50:55.360 --> 50:57.360
100万一万又更新的

50:57.360 --> 50:58.360
前端要怎么学

50:58.360 --> 51:00.360
一是找一个好的老师看教程

51:00.360 --> 51:02.360
第二看官方文档

51:02.360 --> 51:03.360
两个结合起来

51:03.360 --> 51:06.360
以前的会觉得非常扎实

51:06.360 --> 51:09.360
这个禁制是2到36

51:09.360 --> 51:11.360
如果说你的禁制小于2

51:11.360 --> 51:14.360
或者是搭于36

51:14.360 --> 51:16.360
得到NAN

51:16.360 --> 51:23.000
一进字就说了

51:23.000 --> 51:24.000
刚才看了给他说了

51:24.000 --> 51:25.000
最小就是二进字的

51:25.000 --> 51:26.000
一进字就是个无销进字

51:26.000 --> 51:28.000
得到了12NAN

51:28.000 --> 51:30.000
得到12NAN

51:30.000 --> 51:35.230
要看教程

51:35.230 --> 51:37.230
喜欢看一些资料学院

51:37.230 --> 51:40.230
去看百度里边的一些博客

51:40.230 --> 51:41.230
这就是瘟疫

51:41.230 --> 51:43.230
什么很多同学基础不扎实的

51:43.230 --> 51:44.230
根本原因在那

51:44.230 --> 51:45.230
因为那些博客

51:45.230 --> 51:48.230
就是那些基础不扎实的人写的

51:48.230 --> 51:50.230
然后你把它牺牲过来

51:50.230 --> 51:51.230
当成真理了

51:51.230 --> 51:53.230
而且你去百度上去查

51:53.230 --> 51:55.230
好多有些知识点

51:55.230 --> 51:56.230
有些

51:56.230 --> 51:57.230
特别是

51:57.230 --> 51:59.230
该有元老师特色的知识点

51:59.230 --> 52:01.230
都是从我这边超过去了

52:01.230 --> 52:03.230
有些是我的同学写的

52:03.230 --> 52:05.230
但是他超过去了

52:05.230 --> 52:06.230
或者写的笔记

52:06.230 --> 52:07.230
可能有些地方没有做全

52:07.230 --> 52:12.820
你把它看过去了

52:12.820 --> 52:13.820
所以我有的时候

52:13.820 --> 52:14.820
我就教学

52:14.820 --> 52:17.820
特别是前期教学最痛苦的事

52:17.820 --> 52:18.820
我不是

52:18.820 --> 52:19.820
这教一个白志一样的学生

52:19.820 --> 52:21.820
白志一样的学生还好处

52:21.820 --> 52:23.820
我说啥就是啥

52:23.820 --> 52:24.820
还听我的

52:24.820 --> 52:25.820
而是

52:25.820 --> 52:26.820
特别难的就是

52:26.820 --> 52:27.820
他已经牺牲了

52:27.820 --> 52:29.820
很多错误的想法了

52:29.820 --> 52:30.820
我要一点

52:30.820 --> 52:31.820
我也不知道他错在哪

52:31.820 --> 52:32.820
哪些地方是错的

52:32.820 --> 52:34.820
我得一点点去试

52:34.820 --> 52:35.820
去试探

52:35.820 --> 52:36.820
慢慢去找奥远

52:36.820 --> 52:37.820
这个地方有问题

52:37.820 --> 52:38.820
我得一点点去揪

52:38.820 --> 52:40.820
这个是很麻烦的

52:40.820 --> 52:42.820
第三个

52:42.820 --> 52:43.820
第三个是什么呢

52:43.820 --> 52:44.820
也是

52:44.820 --> 52:45.820
这是二进制

52:45.820 --> 52:46.820
进制是没问题的

52:46.820 --> 52:47.820
同学们

52:47.820 --> 52:49.820
二进制里面能出现山吗

52:49.820 --> 52:54.220
二进制能不能出现山

52:54.220 --> 52:59.610
二进制有啥

52:59.610 --> 53:00.610
不就一个零

53:00.610 --> 53:01.610
一个一吗

53:01.610 --> 53:02.610
他还能是有啥

53:02.610 --> 53:03.610
他不能出现山

53:03.610 --> 53:04.610
所以说二进制

53:04.610 --> 53:05.610
这个转的东西

53:05.610 --> 53:06.610
转不了

53:06.610 --> 53:08.610
转不了怎么办

53:08.610 --> 53:10.610
那就是NAN的

53:10.610 --> 53:11.610
所以这道题的答案

53:11.610 --> 53:12.610
得到的新数组

53:12.610 --> 53:13.610
就是一

53:13.610 --> 53:14.610
NAN

53:14.610 --> 53:16.610
好 又来看一下

53:16.610 --> 53:18.610
就这么出来的

53:18.610 --> 53:20.610
看到没

53:20.610 --> 53:21.610
有的时候

53:21.610 --> 53:22.610
他这种题他会改一下

53:22.610 --> 53:24.610
改成13

53:24.610 --> 53:32.040
二进制能转13吗

53:32.040 --> 53:33.040
同学

53:33.040 --> 53:36.950
觉得能的话

53:36.950 --> 53:37.950
Q个一

53:37.950 --> 53:38.950
觉得不能的话

53:38.950 --> 53:39.950
Q个二

53:39.950 --> 53:41.950
就是Pose硬撑

53:41.950 --> 53:43.950
用二进制能转13吗

53:43.950 --> 53:57.090
觉得不能是吧

53:57.090 --> 53:59.090
这又是咋回事吧

53:59.090 --> 54:00.090
有的时候

54:00.090 --> 54:01.090
确实有挺折磨人的

54:01.090 --> 54:02.090
其实

54:02.090 --> 54:04.090
你好好想一想

54:04.090 --> 54:05.090
他道理呢

54:05.090 --> 54:07.090
他确实是有道理的

54:07.090 --> 54:08.090
同学

54:08.090 --> 54:09.090
我问你

54:09.090 --> 54:11.090
Pose硬撑能转这个吗

54:11.090 --> 54:13.090
Pose硬撑能不能转这个

54:13.090 --> 54:20.240
能吗

54:20.240 --> 54:21.240
是不是能转这个

54:21.240 --> 54:22.240
转成一码段

54:22.240 --> 54:23.240
又为什么他遇到了

54:23.240 --> 54:24.240
一个无销的制服

54:24.240 --> 54:25.240
A

54:25.240 --> 54:27.240
S5凭什么无销

54:27.240 --> 54:28.240
你没有想过这个问题

54:28.240 --> 54:30.240
S5凭什么无销

54:30.240 --> 54:31.240
在16进制里面

54:31.240 --> 54:33.240
S5是有销的

54:33.240 --> 54:34.240
如果说你用16进制的话

54:34.240 --> 54:36.240
S5绝对有销

54:36.240 --> 54:38.240
由于他用的是使进制

54:38.240 --> 54:40.240
所以说S5无销了

54:40.240 --> 54:41.240
听懂了吗

54:41.240 --> 54:43.240
使进制也是一是有销的

54:43.240 --> 54:44.240
使进制里面A是无销的

54:44.240 --> 54:45.240
所以说他就忽略了

54:45.240 --> 54:46.240
后边的

54:46.240 --> 54:48.240
他只看前面的一

54:48.240 --> 54:50.240
那么换句话说

54:50.240 --> 54:52.240
我用二进制

54:52.240 --> 54:53.240
一是不是有销的

54:53.240 --> 54:55.240
三在二进制中是无销的

54:55.240 --> 54:56.240
他就忽略了

54:56.240 --> 54:57.240
后边的三

54:57.240 --> 54:59.240
他只看前面的一

54:59.240 --> 55:01.240
他没想出来是一

55:01.240 --> 55:02.240
你看

55:02.240 --> 55:06.550
画出了各种花

55:08.190 --> 55:10.190
这是关于《第八题》

55:10.190 --> 55:12.190
第9题

55:12.190 --> 55:13.710
《第九题》是T Sir

55:13.710 --> 55:19.000
这是一个考铐尖 Lok

55:19.500 --> 55:20.500
这是一个考耀锁中的这个题

55:20.500 --> 55:21.500
阿这题我是作了一个例子

55:21.500 --> 55:22.500
说一下

55:22.500 --> 55:24.500
有些同节可能都没听过

55:24.500 --> 55:27.500
否造成什么叫科码

55:27.500 --> 55:28.500
我就顺便说一下这个弹

55:28.500 --> 55:29.500
悠宇诚更观看

55:29.500 --> 55:31.380
这里边还跟网络通信

55:31.380 --> 55:34.700
我給你舉個例子

55:34.700 --> 55:37.260
這個頁面上很簡單

55:37.260 --> 55:39.320
就是有一個script元素

55:39.320 --> 55:42.900
它向外引用了一個介石

55:42.900 --> 55:44.440
就是index的介石

55:44.440 --> 55:45.980
引用了一個介石

55:45.980 --> 55:48.020
我們來看一下這個介石裡面寫的是啥

55:48.020 --> 55:52.020
很簡單

55:52.020 --> 55:54.840
創建一個當前時間

55:54.840 --> 55:57.140
寫一個死循環

55:57.140 --> 56:00.770
我不停的看

56:00.770 --> 56:02.810
時間有沒有過兩秒鐘

56:02.810 --> 56:04.090
時間有沒有過兩秒鐘

56:04.090 --> 56:06.390
卡個兩秒鐘

56:06.390 --> 56:08.690
CPU瘋狂的運轉

56:08.690 --> 56:11.010
溫度不斷的升高

56:11.010 --> 56:12.530
卡個兩秒鐘

56:12.530 --> 56:14.590
兩秒鐘又不爆炸的

56:14.590 --> 56:16.630
卡個兩秒鐘

56:16.630 --> 56:18.430
這個代碼就是這個意思

56:18.430 --> 56:21.750
卡個兩秒鐘然後生成一個P元素

56:21.750 --> 56:23.290
給P元素裡面寫個ok

56:23.290 --> 56:24.570
把P元素加到頁面上去

56:24.570 --> 56:26.110
就這個意思

56:26.110 --> 56:28.150
簡單吧

56:28.150 --> 56:29.430
這介石代碼好好看一下啊

56:29.430 --> 56:30.210
就非常簡單

56:30.210 --> 56:32.510
就卡兩秒鐘創建一個P元素ok

56:32.510 --> 56:35.070
放到頁面上去就這個意思

56:35.070 --> 56:37.630
好我們再看這個頁面上

56:37.630 --> 56:39.430
我引用這個介石啊

56:39.430 --> 56:44.790
然後後面是一個1到200的A元素

56:44.790 --> 56:45.570
沒有

56:45.570 --> 56:46.850
頁面就這個樣子

56:46.850 --> 56:48.890
我現在把這個頁面運行出來

56:48.890 --> 56:51.710
你們可以在腦袋裡邊想像一下這個頁面

56:51.710 --> 56:54.530
應該是怎麼去呈現的

56:54.530 --> 56:57.090
它的整個過程應該是什麼感覺

56:57.090 --> 56:58.890
你可以在腦袋裡邊想一想

56:58.890 --> 57:01.430
這個介石的代碼裡邊會卡個兩秒鐘

57:01.430 --> 57:04.250
然後得到一個P元素加到頁面ok

57:04.250 --> 57:07.310
後面是200個A元素

57:07.310 --> 57:14.200
腦袋裡邊想這個玩意你們也不好回答

57:14.200 --> 57:16.240
聽過了是吧

57:16.240 --> 57:18.800
再聽一次

57:18.800 --> 57:21.100
運行看一下

57:21.100 --> 57:24.440
卡卡卡

57:24.440 --> 57:25.460
什麼結果

57:25.460 --> 57:29.460
沒看清楚沒看清楚我們再來一次

57:29.460 --> 57:32.540
卡卡一看在轉看到沒

57:32.540 --> 57:35.860
卡了兩秒鐘出現了這一坨ok在前邊

57:35.860 --> 57:38.680
P元素在前面後面是200個A元素

57:38.680 --> 57:40.460
怎麼回事

57:40.460 --> 57:43.020
這要說到一個瀏覽器執行介石代碼

57:43.020 --> 57:47.600
以及渲染頁面的過程

57:47.600 --> 57:50.420
這是瀏覽器這是服務器

57:50.420 --> 57:54.240
網絡同系裡面沒有學過沒關係也就聽個意思

57:54.240 --> 57:58.260
你能聽懂的不用拍拍拍

57:58.260 --> 58:00.560
瀏覽器開始來執行我們的

58:00.560 --> 58:02.600
開始來渲染頁面

58:02.600 --> 58:04.140
從上到下來渲染頁面

58:04.140 --> 58:06.180
是不是要經過一段時間

58:06.180 --> 58:11.300
讀取那個head head元素讀起body元素是不是

58:11.300 --> 58:15.140
開始來解析嘛讀這些元素

58:15.140 --> 58:17.180
好現在讀到了哪個元素了

58:17.180 --> 58:20.000
讀到了這個元素了

58:20.000 --> 58:22.820
現在讀到了這個元素了

58:22.820 --> 58:25.380
我或者就在這話吧

58:25.380 --> 58:27.940
我就在這話吧

58:27.940 --> 58:30.240
讀到這個元素了現在

58:30.240 --> 58:32.040
那怎麼辦呢

58:32.040 --> 58:36.400
這個元素它要遠程去訪問服務器

58:36.400 --> 58:41.000
來服務器給我這個介石我這沒有給我這個介石

58:41.000 --> 58:44.080
要不要時間要啊

58:44.080 --> 58:47.920
遠程拿這個介石要時間介石不在什麼

58:47.920 --> 58:53.390
這以後學了網絡同系就知道了肯定是遠程去拿的

58:53.390 --> 58:54.670
好

58:54.670 --> 58:56.710
現在瀏覽器幹嘛呀乾等

58:56.710 --> 58:58.250
等著

58:58.250 --> 59:00.550
啥也別幹等著

59:00.550 --> 59:04.390
等這個服務器拿到這個介給他這個介石過後

59:04.390 --> 59:08.750
拿到這個介石了是不是就可以渲染後邊了啊並不是

59:08.750 --> 59:10.530
拿到介石之後

59:10.530 --> 59:13.090
他要運行介石

59:13.090 --> 59:14.370
要不要時間

59:14.370 --> 59:18.990
卡個兩秒鐘介石裡面是不是卡兩秒鐘生成一個P元素OK

59:18.990 --> 59:21.290
運行介石

59:21.290 --> 59:23.590
介石運行完了

59:23.590 --> 59:29.210
再接著往後面解析後面的A元素

59:29.210 --> 59:31.770
說明這就是我們最終看到的過程

59:31.770 --> 59:33.810
卡了兩秒鐘對吧

59:33.810 --> 59:35.610
這裡是不是卡了兩秒鐘

59:35.610 --> 59:37.150
然後介石

59:37.150 --> 59:39.970
得到了一個P元素OK加到一面上去了

59:39.970 --> 59:43.050
OK就在句前邊然後後面再去解析後面的A元素

59:43.050 --> 59:44.570
A元素全部在後面

59:44.570 --> 59:46.110
這是它的默認情況

59:46.110 --> 59:47.890
這默認情況能聽懂嗎

59:47.890 --> 59:49.950
我這樣解釋

59:49.950 --> 59:58.490
能聽懂話Q個E

59:58.490 --> 01:00:01.310
這個你們學基礎部分的時候

01:00:01.310 --> 01:00:02.590
那個解析

01:00:02.590 --> 01:00:05.150
講那個瀏覽器的執行過程都會講

01:00:05.150 --> 01:00:06.690
所以它最後卡

01:00:06.690 --> 01:00:08.730
卡了兩秒鐘OK在前面

01:00:08.730 --> 01:00:10.010
A元素在後面

01:00:10.010 --> 01:00:11.550
好接下來

01:00:11.550 --> 01:00:13.090
我給它加上一個

01:00:13.090 --> 01:00:19.650
Ethink

01:00:19.650 --> 01:00:21.950
Ethink是什麼意思呢表示一步

01:00:21.950 --> 01:00:24.510
加了這個就不一樣了

01:00:24.510 --> 01:00:26.830
好咱們來看一下

01:00:26.830 --> 01:00:28.350
運行

01:00:28.350 --> 01:00:30.650
一開始出來的部分了

01:00:30.650 --> 01:00:32.950
OK在中間

01:00:32.950 --> 01:00:35.770
卡了過後OK在中間後面出現這個

01:00:35.770 --> 01:00:38.070
那這個玩意怎麼解釋呢

01:00:38.070 --> 01:00:40.630
又來

01:00:40.630 --> 01:00:41.910
瀏覽器

01:00:41.910 --> 01:00:43.950
服務器

01:00:43.950 --> 01:00:46.010
從上到下解析

01:00:46.010 --> 01:00:48.810
解析解析解析到這個介石

01:00:48.810 --> 01:00:50.610
幹嘛還是一樣

01:00:50.610 --> 01:00:52.150
來給我這個介石

01:00:52.150 --> 01:00:55.470
但是由於你加了這個Ethink標記

01:00:55.470 --> 01:00:58.550
瀏覽器不會停止解析它不會等

01:00:58.550 --> 01:01:01.110
不會讓你啥等繼續往後解析

01:01:01.110 --> 01:01:02.390
繼續

01:01:02.390 --> 01:01:07.510
好服務器那邊拿到這個介石給你發過來了來

01:01:07.710 --> 01:01:08.750
這個時候

01:01:08.750 --> 01:01:12.590
你看這個時候瀏覽器是不是已經解析了一部分A元素了

01:01:12.590 --> 01:01:15.390
那就說不準是多少了解析幾個我就說不準了

01:01:15.390 --> 01:01:19.020
它肯定是解析了一部分了對吧

01:01:19.020 --> 01:01:19.980
好

01:01:19.980 --> 01:01:24.260
然後拿到這個介石過後轉而去執行介石

01:01:24.260 --> 01:01:26.700
現在開始卡了卡兩秒鐘

01:01:26.700 --> 01:01:30.980
然後生成一個P元素得到OK把它放到一面上去

01:01:30.980 --> 01:01:33.980
看到沒這就是為什麼P元素在中間

01:01:33.980 --> 01:01:37.060
好運行完介石過後接著往後解析

01:01:37.060 --> 01:01:39.620
直到解析結束

01:01:39.620 --> 01:01:43.750
這是加上Ethink這叫逸步

01:01:43.750 --> 01:01:46.310
就拿著瀏覽器拿著過程我不用等

01:01:46.310 --> 01:01:49.390
但是拿到介石過後要馬上執行

01:01:49.390 --> 01:01:50.670
叫Ethink

01:01:50.670 --> 01:01:52.950
你不要想到這個玩意好像沒什麼用

01:01:52.950 --> 01:01:55.790
這個玩意你們以後會經常看到

01:01:55.790 --> 01:01:59.110
現在基本上做的一個頁面裏面報紙都有

01:01:59.110 --> 01:02:02.020
報紙都有

01:02:02.020 --> 01:02:10.880
好這個能聽懂嗎能聽懂就可以

01:02:10.880 --> 01:02:12.680
OK

01:02:12.680 --> 01:02:15.000
但是就解釋清楚了嗎

01:02:15.000 --> 01:02:16.280
同學

01:02:16.280 --> 01:02:19.600
好像還沒有

01:02:19.600 --> 01:02:25.030
那你又怎麽要解釋看清楚同學們看清楚

01:02:25.030 --> 01:02:29.260
我這裏重新運行

01:02:29.260 --> 01:02:32.100
到182說明啥

01:02:32.100 --> 01:02:33.880
重來

01:02:33.880 --> 01:02:35.660
把這個長計

01:02:35.660 --> 01:02:38.740
119到119看到沒

01:02:38.740 --> 01:02:40.540
不對呀

01:02:40.540 --> 01:02:42.060
你們剛才看清楚沒

01:02:42.060 --> 01:02:47.180
先是到了先是卡在這個119對吧

01:02:47.180 --> 01:02:49.220
卡在這個119

01:02:49.220 --> 01:02:51.280
然後再卡在卡兩秒鐘

01:02:51.280 --> 01:02:55.620
卡了兩秒鐘不應該OK不應該在這嗎有沒有同學有這樣的疑問

01:02:55.620 --> 01:02:58.440
你前面說明前面的一個

01:02:58.440 --> 01:02:59.460
看著我們之前的圖面

01:02:59.460 --> 01:03:01.520
之前的圖再畫一下

01:03:01.520 --> 01:03:03.820
從那裏解析

01:03:03.820 --> 01:03:06.900
要去拿介石去拿吧我這裏不停止

01:03:06.900 --> 01:03:09.700
往這接著往後解析那說明啥

01:03:09.700 --> 01:03:13.300
說明解析到這的時候拿到介石開始來卡兩秒鐘執行介石

01:03:13.300 --> 01:03:16.880
說明卡在這裏是自己是不是119

01:03:16.880 --> 01:03:18.680
119在這裏卡了一下對吧

01:03:18.680 --> 01:03:20.460
說119

01:03:20.460 --> 01:03:25.080
然後那麼介石執行完了OK不應該在這嗎

01:03:25.080 --> 01:03:30.460
他為什麼又突然多了一個182呢同學然後才出現OK

01:03:30.460 --> 01:03:35.320
有同學能回答這個問題那裏的基礎就非常非常紮實了

01:03:35.320 --> 01:03:37.620
有沒有同學能回答這樣的問題

01:03:37.620 --> 01:03:44.620
你首先聽到我剛才問題是啥你看再來一次

01:03:44.620 --> 01:03:45.900
又卡在119

01:03:45.900 --> 01:03:52.020
他就瞧了又到182

01:03:52.240 --> 01:03:59.760
介石運行實現不是這個原因

01:03:59.760 --> 01:04:01.280
我解釋一下啊

01:04:01.280 --> 01:04:05.880
為什麼會出現這樣的問題這個如果說問到這種問題的話

01:04:05.880 --> 01:04:09.740
那考察的就對於流量系的原理就必須要很熟了

01:04:09.740 --> 01:04:14.080
解析不等於渲染

01:04:14.080 --> 01:04:15.620
不等於渲染

01:04:15.620 --> 01:04:17.040
也就是說什麼意思呢

01:04:17.040 --> 01:04:18.680
就你這裏啊

01:04:18.680 --> 01:04:22.080
你這裏不是先去解析從上到下解析

01:04:22.080 --> 01:04:24.080
到介石那去拿介石吧

01:04:24.080 --> 01:04:26.640
我不等你啊我現在接著往後解析

01:04:26.640 --> 01:04:29.980
解析到182了

01:04:29.980 --> 01:04:33.300
他解析到182了

01:04:33.300 --> 01:04:38.160
但是並不等於他渲染到182

01:04:38.160 --> 01:04:41.240
什麼叫渲染就把它畫到一面上讓你看得見

01:04:41.240 --> 01:04:44.560
解析是什麼解析是生成動物樹

01:04:44.560 --> 01:04:47.640
當然前提條件你也知道什麼叫動物樹啊

01:04:47.640 --> 01:04:50.180
你學到動物的時候肯定不管你是看什麼教室

01:04:50.180 --> 01:04:51.980
他一定會告訴你一個動物樹

01:04:51.980 --> 01:04:55.300
解析指的是生成動物樹生成動物對象

01:04:55.560 --> 01:04:57.600
但是解析他不等於渲染

01:04:57.600 --> 01:05:01.440
他渲染的時候畫他只畫到了119還沒開始畫完

01:05:01.440 --> 01:05:05.180
現在要去執行介石了

01:05:05.180 --> 01:05:07.240
要去執行介石了

01:05:07.240 --> 01:05:09.280
好介石執行完了過後

01:05:09.280 --> 01:05:10.300
加入了一個P元素

01:05:10.300 --> 01:05:11.840
P元素是不是還在等著畫

01:05:11.840 --> 01:05:14.920
我現在還有1,2,0,1,2,1,2,2,3

01:05:14.920 --> 01:05:16.720
還有一大堆數字都還沒有畫

01:05:16.720 --> 01:05:19.020
你這個P元素排隊吧

01:05:19.020 --> 01:05:19.780
好

01:05:19.780 --> 01:05:21.060
然後再進行解析

01:05:21.060 --> 01:05:23.360
那麼這個時候才有時間來進行渲染

01:05:23.360 --> 01:05:24.900
他都會渲染後邊的東西

01:05:25.100 --> 01:05:27.020
把之前沒有渲染的渲染了

01:05:27.020 --> 01:05:29.200
然後P元素是排到之前

01:05:29.200 --> 01:05:30.220
排到這兒的

01:05:30.220 --> 01:05:32.020
所以在重生意識

01:05:32.020 --> 01:05:33.300
在這個點的時候

01:05:33.300 --> 01:05:36.620
他其實已經解析到182了

01:05:36.620 --> 01:05:38.420
只是他還沒來得及畫出來

01:05:38.420 --> 01:05:40.720
他只畫到119

01:05:40.720 --> 01:05:42.520
轉而去執行介石去了

01:05:42.520 --> 01:05:45.160
是這麼個原因導致的

01:05:45.160 --> 01:05:51.120
但是有詮釋細節

01:05:51.120 --> 01:05:53.160
好再說Devon

01:05:53.160 --> 01:05:55.720
Devon叫做一步延遲

01:05:55.720 --> 01:05:56.760
剛才是一步的吧

01:05:56.760 --> 01:05:58.560
Devon就是延遲

01:05:58.560 --> 01:06:02.180
等一半別著急執行我就這個意思

01:06:02.180 --> 01:06:03.520
那麼這個玩意兒是啥呢

01:06:03.520 --> 01:06:04.820
這個玩意兒呢

01:06:04.820 --> 01:06:07.300
一般來說我們去加載一些

01:06:07.300 --> 01:06:10.500
在目前這個頁面上不是很重要的解析

01:06:10.500 --> 01:06:12.740
但是他要必須要加載

01:06:12.740 --> 01:06:15.140
好解析解析解析到這句話

01:06:15.140 --> 01:06:16.800
然後呢

01:06:16.800 --> 01:06:18.140
去拿這個介石

01:06:18.140 --> 01:06:18.940
我不等你啊

01:06:18.940 --> 01:06:20.800
我接著往後解析了

01:06:20.800 --> 01:06:22.500
這個介石拿到了

01:06:22.500 --> 01:06:23.700
拿到了我也不等你啊

01:06:23.700 --> 01:06:24.620
我現在不著急執行你

01:06:24.620 --> 01:06:27.680
我要把解析全部解析完了過後

01:06:27.680 --> 01:06:29.580
哎呀 我又空了

01:06:29.580 --> 01:06:30.580
我休息了

01:06:30.580 --> 01:06:31.840
來吧你這個介石過來吧

01:06:31.840 --> 01:06:32.740
我來執行你

01:06:32.740 --> 01:06:34.940
在這個時候才會執行

01:06:34.940 --> 01:06:37.620
Devon就是延後

01:06:37.620 --> 01:06:39.180
所以說Devon看到的結果

01:06:39.180 --> 01:06:41.820
同學們應該能夠想像到了

01:06:41.820 --> 01:06:43.460
但是宣然還是要時間的啊

01:06:43.460 --> 01:06:44.300
宣然還是要時間

01:06:44.300 --> 01:06:47.800
他一定在最後

01:06:47.800 --> 01:06:49.480
只這麼個意思

01:06:49.480 --> 01:06:51.520
好就這道題

01:06:51.520 --> 01:06:58.920
第十題完成深度克隆

01:06:58.920 --> 01:07:04.450
這就是常考題了

01:07:04.910 --> 01:07:12.180
完成深度克隆

01:07:12.180 --> 01:07:15.660
什麼叫深度克隆

01:07:15.660 --> 01:07:19.460
就是我們來測試一下吧

01:07:19.460 --> 01:07:20.260
Dit克隆

01:07:20.260 --> 01:07:24.940
一克隆一個E你要給我得到一個E

01:07:24.940 --> 01:07:26.020
這個很簡單對吧

01:07:26.020 --> 01:07:29.540
然後克隆一個克隆嘛

01:07:29.540 --> 01:07:33.020
克隆一個ABC你要給我得到一個ABC

01:07:33.020 --> 01:07:36.900
這個元素指數很簡單的

01:07:37.720 --> 01:07:41.720
然後呢如果說你是對象呢

01:07:41.720 --> 01:07:44.920
對象呢A等於E

01:07:44.920 --> 01:07:47.760
C等於一個另外一個對象

01:07:47.760 --> 01:07:50.400
B等於2

01:07:50.400 --> 01:07:52.040
可能D還等於一個數組

01:07:52.040 --> 01:07:57.440
數組裡可能還有對象

01:07:57.440 --> 01:07:59.680
就是可能千套很深的對象

01:07:59.680 --> 01:08:03.960
然後呢我也要進行深度克隆

01:08:03.960 --> 01:08:05.200
對他進行克隆

01:08:05.200 --> 01:08:09.560
克隆過後產生的是一個新的對象

01:08:09.580 --> 01:08:10.940
它不是原來的對象

01:08:10.940 --> 01:08:13.140
一定是新的對象

01:08:13.140 --> 01:08:15.660
這兩個對象的地址是不一樣的

01:08:15.660 --> 01:08:18.380
而且呢原對象裡邊的有的屬性

01:08:18.380 --> 01:08:21.420
我新對象裡面全有

01:08:21.420 --> 01:08:24.700
而且呢原對象裡面的對象屬性

01:08:24.700 --> 01:08:27.100
新對象裡面的相應屬性

01:08:27.100 --> 01:08:28.420
也是新的對象

01:08:28.420 --> 01:08:33.950
也就是說我如果說克隆出來

01:08:33.950 --> 01:08:35.750
OB借2

01:08:35.750 --> 01:08:38.910
克隆出來你這個OB借呀

01:08:39.370 --> 01:08:44.130
C是不能等於OB借2

01:08:44.130 --> 01:08:47.050
如果想等的話就是淺克隆了

01:08:47.050 --> 01:08:48.650
淺克隆很簡單

01:08:48.650 --> 01:08:50.570
都要深度克隆

01:08:50.570 --> 01:08:52.410
深度克隆看上去很複雜

01:08:52.410 --> 01:08:54.650
其實很簡單

01:08:54.650 --> 01:08:57.410
當然了深度克隆的有一些

01:08:57.410 --> 01:08:58.530
深入的東西

01:08:58.530 --> 01:09:00.210
深入的東西呢

01:09:00.210 --> 01:09:02.650
我建議你呢

01:09:02.650 --> 01:09:05.250
現階段至少現階段不用管了

01:09:05.250 --> 01:09:06.970
後邊你學到後邊的過後

01:09:06.990 --> 01:09:09.950
再跟我來去討論這個深度的東西

01:09:09.950 --> 01:09:11.470
我們現在就看淺度的

01:09:11.470 --> 01:09:12.950
因為公司的話一般考察你

01:09:12.950 --> 01:09:15.870
能夠把淺度的寫出來至少即得了

01:09:15.870 --> 01:09:17.790
有深度的東西呢

01:09:17.790 --> 01:09:20.470
即便你沒有寫至少不能算出

01:09:20.470 --> 01:09:21.910
他可能會在面試的時候問你啊

01:09:21.910 --> 01:09:23.670
你剛才做這個比試體驗

01:09:23.670 --> 01:09:25.110
深入克隆還做得挺好的

01:09:25.110 --> 01:09:26.470
那我們來探討一下吧

01:09:26.470 --> 01:09:27.910
在你這個深入克隆裡面

01:09:27.910 --> 01:09:29.230
如果說遇到這種情況

01:09:29.230 --> 01:09:31.030
是不是不行了呀

01:09:31.030 --> 01:09:33.510
你再去探討

01:09:33.510 --> 01:09:35.430
一般來說你只只要你寫出來了

01:09:35.430 --> 01:09:39.620
這種基本的就沒問題

01:09:39.620 --> 01:09:44.050
喝水

01:09:44.050 --> 01:09:46.390
同學你不要去做這種事情啊

01:09:46.390 --> 01:09:47.790
我知道有些同學取巧啊

01:09:47.790 --> 01:09:49.630
用節省格式去轉

01:09:49.630 --> 01:09:51.430
不要這種做這種事情

01:09:51.430 --> 01:09:53.870
你聽我的就行了

01:09:53.870 --> 01:09:55.350
做這種事情呢

01:09:55.350 --> 01:09:57.870
你待馬倒是挺簡潔的

01:09:57.870 --> 01:09:59.750
但是面試觀考慮這道題

01:09:59.750 --> 01:10:01.830
並不是因為以後在開發中

01:10:01.830 --> 01:10:03.430
要你去寫一個深度可能

01:10:03.430 --> 01:10:04.950
不需要的

01:10:04.950 --> 01:10:06.310
就像你們以後在企業裡面

01:10:06.310 --> 01:10:08.070
不需要你去寫什麼倫波圖

01:10:08.090 --> 01:10:09.890
不需要你去寫什麼沙拉列表

01:10:09.890 --> 01:10:11.890
不需要你去寫什麼手風琴

01:10:11.890 --> 01:10:13.050
不需要你寫

01:10:13.050 --> 01:10:14.010
這是有現成的

01:10:14.010 --> 01:10:15.450
深度克隆有現成的

01:10:15.450 --> 01:10:16.850
寫的挺好的

01:10:16.850 --> 01:10:17.890
你直接拿來用

01:10:17.890 --> 01:10:19.370
那他為什麼要考慮這個

01:10:19.370 --> 01:10:22.610
他考慮的是你思維方式和算法

01:10:22.610 --> 01:10:25.330
但算法的題不止這一種

01:10:25.330 --> 01:10:27.770
而且他根據你寫的東西

01:10:27.770 --> 01:10:29.410
要進行深入的講解

01:10:29.410 --> 01:10:30.450
深入的展開

01:10:30.450 --> 01:10:33.650
可能在剛才我說的面試的時候

01:10:33.650 --> 01:10:35.890
他可能會要跟你做一些深入的探討

01:10:35.910 --> 01:10:37.170
你用剛才那個寫法

01:10:37.170 --> 01:10:39.130
了不下去的

01:10:39.130 --> 01:10:39.790
知道了

01:10:41.790 --> 01:10:46.170
那麼深度克隆怎麼來克隆呢

01:10:46.170 --> 01:10:47.250
我們先看原始值

01:10:47.250 --> 01:10:48.610
原始值很簡單

01:10:48.610 --> 01:10:52.320
直接反圍完事

01:10:52.320 --> 01:10:54.000
這就完了

01:10:54.000 --> 01:10:54.840
你看一下

01:10:54.840 --> 01:10:56.880
你沒克隆肯定克隆了

01:10:56.880 --> 01:10:58.000
那肯定克隆了

01:10:58.000 --> 01:10:59.880
就完事了

01:10:59.880 --> 01:11:02.040
那如果不是原始值呢

01:11:02.040 --> 01:11:03.240
那不是原始值

01:11:03.240 --> 01:11:05.600
他就得是一個對象了

01:11:05.600 --> 01:11:08.200
同學就得是個對象了

01:11:08.260 --> 01:11:09.220
有可能是對象

01:11:09.220 --> 01:11:12.900
有含述我們不考慮

01:11:12.900 --> 01:11:15.700
含述的話一般就把它當成原始值

01:11:15.700 --> 01:11:16.860
對象不有兩種情況

01:11:16.860 --> 01:11:18.260
一個是宿主

01:11:18.260 --> 01:11:20.620
一個是普通對象

01:11:20.620 --> 01:11:22.020
是吧

01:11:22.020 --> 01:11:23.420
我們就判斷

01:11:23.420 --> 01:11:24.820
怎麼判斷他是不是宿主了

01:11:24.820 --> 01:11:26.860
2位1是2位

01:11:26.860 --> 01:11:27.660
Value

01:11:27.660 --> 01:11:33.390
那麼這是宿主的情況

01:11:33.390 --> 01:11:35.870
宿主的情況

01:11:35.870 --> 01:11:36.550
還有這種情況

01:11:36.550 --> 01:11:38.390
那就是對象的情況

01:11:38.490 --> 01:11:39.890
不是宿主就是對象

01:11:39.890 --> 01:11:41.890
不是宿主

01:11:41.890 --> 01:11:44.090
我們用那個Typle

01:11:44.090 --> 01:11:46.330
我們先把個結構畫出來

01:11:46.330 --> 01:11:55.680
並不複雜同學們

01:11:55.680 --> 01:11:58.280
他宿主的情況在這

01:11:58.280 --> 01:12:01.040
普通對象的情況在這

01:12:01.040 --> 01:12:03.560
他那個Typle是object

01:12:03.560 --> 01:12:04.640
並且他不等於now

01:12:04.640 --> 01:12:06.040
為什麼要排出這個情況呢

01:12:06.040 --> 01:12:11.040
因為now的類型

01:12:11.040 --> 01:12:13.160
他也是object

01:12:13.180 --> 01:12:15.980
這是介式bug

01:12:15.980 --> 01:12:16.620
沒辦法

01:12:16.620 --> 01:12:17.420
他已經出現了

01:12:17.420 --> 01:12:18.180
這叫feature

01:12:18.180 --> 01:12:20.300
不叫bug

01:12:20.300 --> 01:12:21.660
這是兩種情況

01:12:21.660 --> 01:12:22.700
我們一個個說吧

01:12:22.700 --> 01:12:24.060
先說宿主的情況

01:12:24.060 --> 01:12:25.180
宿主怎麼克容呢

01:12:25.180 --> 01:12:31.850
比方說你要克容一個宿主

01:12:31.850 --> 01:12:35.240
二三四

01:12:35.240 --> 01:12:36.240
下一項

01:12:36.240 --> 01:12:37.640
下一項還是一個宿主

01:12:37.640 --> 01:12:40.520
假設一共有四項

01:12:40.520 --> 01:12:42.440
一

01:12:42.440 --> 01:12:43.600
假設有這麼一個宿主

01:12:43.600 --> 01:12:45.160
要克容他

01:12:45.180 --> 01:12:46.180
對吧

01:12:46.180 --> 01:12:47.980
R2D

01:12:47.980 --> 01:12:49.580
克容

01:12:49.580 --> 01:12:51.540
克容他

01:12:51.540 --> 01:12:56.050
怎麼克容

01:12:56.050 --> 01:12:58.050
怎麼克容

01:12:58.050 --> 01:13:00.530
肯定要創建一個新宿主返回

01:13:00.530 --> 01:13:02.650
他一定是返回的是一個新宿主

01:13:02.650 --> 01:13:03.490
所以這裡毫不疑問

01:13:03.490 --> 01:13:06.650
之後他一定會寫上

01:13:06.650 --> 01:13:08.490
一個新宿主

01:13:08.490 --> 01:13:09.490
只不過新宿主

01:13:09.490 --> 01:13:11.090
往裡面裝東西

01:13:11.090 --> 01:13:12.450
元宿主有的

01:13:12.450 --> 01:13:13.970
往新宿主就裝就完事了

01:13:13.970 --> 01:13:17.880
是不是循環元宿主

01:13:18.380 --> 01:13:26.780
元宿主有一項就往新宿主裡邊夾

01:13:26.780 --> 01:13:33.180
元宿主把每一項往新宿主裡邊夾

01:13:33.180 --> 01:13:36.580
最後把新宿主返回

01:13:36.580 --> 01:13:37.780
單碼其實很簡單

01:13:37.780 --> 01:13:40.460
但是你夾的東西就在這

01:13:40.460 --> 01:13:41.420
問題就在這

01:13:41.420 --> 01:13:43.620
你知道你夾了是啥嗎

01:13:43.620 --> 01:13:44.660
你不清楚

01:13:44.660 --> 01:13:46.460
他有可能宿主的每一項

01:13:46.460 --> 01:13:47.660
有可能是數字

01:13:47.660 --> 01:13:50.870
也有可能是這麼一個玩意

01:13:50.870 --> 01:13:52.970
也有可能還有對象

01:13:52.970 --> 01:13:54.270
那可能宿主裡邊還套對象

01:13:54.270 --> 01:13:55.110
對象裡邊還套宿主

01:13:55.110 --> 01:13:57.110
可能層次真的很

01:13:57.110 --> 01:13:58.070
那怎麼辦呢

01:13:58.070 --> 01:14:00.910
我管他是啥

01:14:00.910 --> 01:14:04.450
我把這一項帶來一個克容

01:14:04.450 --> 01:14:06.390
就管他是啥玩意

01:14:06.390 --> 01:14:08.590
把這個流程再走一遍

01:14:08.590 --> 01:14:10.350
對吧就完事了

01:14:10.350 --> 01:14:11.290
這要帝規

01:14:11.290 --> 01:14:12.410
在韓說裡邊直接

01:14:12.410 --> 01:14:14.350
或者間接地調用自身

01:14:14.350 --> 01:14:15.510
叫帝規

01:14:15.510 --> 01:14:16.310
說到帝規

01:14:16.310 --> 01:14:17.710
那又是我又一大堆話

01:14:17.810 --> 01:14:19.010
給你們說了

01:14:19.010 --> 01:14:21.610
那時間就沒有了

01:14:21.610 --> 01:14:24.410
但是這個邏輯上就是個邏輯

01:14:24.410 --> 01:14:25.010
對吧

01:14:25.010 --> 01:14:27.510
你要把這個玩意克隆之後

01:14:27.510 --> 01:14:28.810
再加到新宿主裡邊去

01:14:28.810 --> 01:14:30.210
你看是這個意思吧

01:14:30.210 --> 01:14:32.010
二克隆之後

01:14:32.010 --> 01:14:36.690
你看我們再手動演示一下

01:14:36.690 --> 01:14:38.390
二克隆之後加進來

01:14:38.390 --> 01:14:39.890
三克隆之後加進來

01:14:39.890 --> 01:14:41.590
四克隆之後加進來

01:14:41.590 --> 01:14:42.290
後面是個宿主

01:14:42.290 --> 01:14:44.590
克隆之後給我加進來

01:14:44.590 --> 01:14:47.090
對吧走一遍這個克隆流程

01:14:47.090 --> 01:14:49.490
不就完了嗎

01:14:49.490 --> 01:14:54.290
只不過對帝規很難理解的原因

01:14:54.290 --> 01:14:55.390
主要有兩個

01:14:55.390 --> 01:14:58.190
一個是不懂帝規的

01:14:58.190 --> 01:15:01.390
帝規他實際上不屬於命令式編成

01:15:01.390 --> 01:15:02.990
而是屬於生命式編成

01:15:02.990 --> 01:15:04.790
是韓術式編成的翻成

01:15:04.790 --> 01:15:05.890
你可能完全不知道

01:15:05.890 --> 01:15:07.890
我剛才有句話在說啥

01:15:07.890 --> 01:15:09.690
第二個是

01:15:09.690 --> 01:15:10.890
不知道帝規是什麼運行的

01:15:10.890 --> 01:15:13.690
可能對執行站和執行上下文

01:15:13.690 --> 01:15:15.290
那一塊不清楚

01:15:15.290 --> 01:15:16.390
清楚了執行站的話

01:15:16.390 --> 01:15:20.490
他帝規的執行過程還是比較清晰的

01:15:20.490 --> 01:15:21.290
那個的話

01:15:21.290 --> 01:15:23.990
人家不是一兩句話能搞得定的

01:15:23.990 --> 01:15:25.890
反正把流程走一遍

01:15:25.890 --> 01:15:27.290
邏輯是這個邏輯吧

01:15:27.290 --> 01:15:29.190
把元宿主的每一項走一遍這個流程

01:15:29.190 --> 01:15:30.590
走一遍深度克隆的流程

01:15:30.590 --> 01:15:32.890
把克隆的結果加到新宿主裡面去

01:15:32.890 --> 01:15:35.590
完成看一下吧

01:15:35.590 --> 01:15:37.790
運行出來

01:15:37.790 --> 01:15:40.690
這個新宿主是不是AR2

01:15:40.690 --> 01:15:41.490
我們來判斷一下

01:15:41.490 --> 01:15:43.290
AR2跟那個元宿主相等嗎

01:15:43.290 --> 01:15:44.290
肯定是不能相等的

01:15:44.290 --> 01:15:46.590
這樣就不能叫克隆了

01:15:46.590 --> 01:15:49.890
沒有這個也

01:15:49.890 --> 01:15:50.690
Force

01:15:50.690 --> 01:15:51.690
不相等

01:15:51.690 --> 01:15:54.490
我們來看一下新宿主的第3項

01:15:54.490 --> 01:15:56.190
下標3就這一下

01:15:56.190 --> 01:15:59.690
跟元宿主的第3項也不能相等

01:15:59.690 --> 01:16:01.190
這項也得克隆

01:16:01.190 --> 01:16:02.490
肯定是不相等的

01:16:02.490 --> 01:16:04.690
Force

01:16:04.690 --> 01:16:08.710
哪怕你這裡還有深度

01:16:08.710 --> 01:16:09.710
都沒關係

01:16:09.710 --> 01:16:11.910
我們看一下元宿主的第3項就這項

01:16:11.910 --> 01:16:13.010
這項又是個宿主

01:16:13.010 --> 01:16:16.590
這項這個宿主的第2項

01:16:16.590 --> 01:16:18.490
跟元宿主相等嗎

01:16:18.490 --> 01:16:19.590
也不能相等

01:16:19.590 --> 01:16:21.590
不能叫克隆了

01:16:21.590 --> 01:16:22.390
肯定是不相等的

01:16:22.390 --> 01:16:22.990
為什麼呢

01:16:22.990 --> 01:16:24.990
因為我管理千頭多深

01:16:24.990 --> 01:16:27.990
我都要走一遍克隆的流程

01:16:27.990 --> 01:16:29.390
流程走一遍

01:16:29.390 --> 01:16:31.390
宿主就完事了

01:16:31.390 --> 01:16:32.290
宿主完事了

01:16:32.290 --> 01:16:34.190
對象也一樣

01:16:34.190 --> 01:16:35.190
對象的話怎麼弄

01:16:35.190 --> 01:16:37.890
你得創建一個新的對象

01:16:37.890 --> 01:16:40.490
創建一個新的對象

01:16:40.490 --> 01:16:43.490
然後剛才說便利宿主的

01:16:43.490 --> 01:16:45.590
便利元對象

01:16:45.590 --> 01:16:49.860
所以便利元對象

01:16:49.860 --> 01:16:52.660
把對象的每一個屬性拿出來

01:16:52.660 --> 01:16:55.460
夾到新對象裡面去

01:16:55.460 --> 01:16:58.560
剛好可以用上我們今天看的指示

01:16:58.560 --> 01:17:01.060
便利元對象的所有屬性名字

01:17:01.060 --> 01:17:01.760
放到一個邊疆裡面

01:17:01.760 --> 01:17:02.560
把這個邊疆的指

01:17:02.560 --> 01:17:04.060
就屬性的同樣的屬性

01:17:04.060 --> 01:17:05.660
做一個同樣的屬性

01:17:05.660 --> 01:17:08.360
給它負值

01:17:08.360 --> 01:17:10.660
所以他們的宿主其實一取同工

01:17:10.660 --> 01:17:12.360
宿主是把每一項的指克隆

01:17:12.360 --> 01:17:13.660
夾到新宿主裡面去

01:17:13.660 --> 01:17:15.060
這個是把對象的一邊

01:17:15.060 --> 01:17:16.660
每一個屬性克隆

01:17:16.660 --> 01:17:18.760
夾到新對象的相應屬性裡面去

01:17:18.760 --> 01:17:20.760
然後返回新對象

01:17:20.760 --> 01:17:22.760
這個最基本的克隆就寫出來了

01:17:22.760 --> 01:17:25.160
這種克隆拿不掉高分

01:17:25.160 --> 01:17:27.560
但是肯定是可以集合

01:17:27.560 --> 01:17:29.760
過面過比是那一關沒問題

01:17:29.760 --> 01:17:37.280
肯定是沒問題的

01:17:37.280 --> 01:17:41.080
怎麼可能得到True呢

01:17:41.080 --> 01:17:46.360
DeepColumnValueT

01:17:46.360 --> 01:17:48.360
它的指等於Audiates

01:17:48.360 --> 01:17:54.640
並且它不能等於NowC

01:17:54.640 --> 01:17:57.240
obj2.c

01:17:57.240 --> 01:17:58.240
不能等於說

01:17:58.240 --> 01:18:02.730
好 我再調試一下

01:18:02.730 --> 01:18:15.160
直接運行吧

01:18:15.160 --> 01:18:24.630
直接到這兒來 進去

01:18:24.630 --> 01:18:32.080
這是一個克隆新對象

01:18:32.080 --> 01:18:34.380
指K的指是A

01:18:34.380 --> 01:18:36.180
A的屬性沒什麼問題

01:18:36.180 --> 01:18:37.280
直接跳過了

01:18:37.280 --> 01:18:39.280
下一個指C

01:18:39.280 --> 01:18:41.580
C是一個對象

01:18:41.580 --> 01:18:46.680
然後進入到克隆

01:18:46.680 --> 01:18:48.680
克隆

01:18:48.680 --> 01:18:53.770
沒問題啊

01:18:53.770 --> 01:18:56.640
不要的啊

01:18:56.640 --> 01:19:01.850
沒問題啊

01:19:01.850 --> 01:19:07.020
返回新對象 沒問題啊

01:19:07.020 --> 01:19:08.420
可能等於

01:19:08.420 --> 01:19:09.620
我用的是不等於啊

01:19:09.620 --> 01:19:12.120
不等於

01:19:12.120 --> 01:19:15.290
我用的是不等於啊

01:19:15.290 --> 01:19:17.290
為什麼實際工作就是這樣處理的

01:19:17.290 --> 01:19:19.290
就是實際工作可以這樣子處理

01:19:19.290 --> 01:19:21.390
實際工作其實我都不建議你這樣子處理

01:19:21.390 --> 01:19:22.590
直接用那個

01:19:22.590 --> 01:19:23.650
直接用那個

01:19:23.650 --> 01:19:25.090
劉戴琪的褲就行了

01:19:25.090 --> 01:19:26.690
你這樣處理是有隱患的

01:19:26.690 --> 01:19:28.790
實際工作也不應該那樣處理

01:19:28.790 --> 01:19:30.090
然後馬上就可以說這樣

01:19:30.090 --> 01:19:31.090
你這樣的處理的結果

01:19:31.090 --> 01:19:32.990
跟我這種做法的結果是一樣的

01:19:33.090 --> 01:19:34.490
我就告訴你是一樣的

01:19:34.490 --> 01:19:35.390
你這種做法的結果

01:19:35.390 --> 01:19:40.410
跟我這種做法的結果是一樣的

01:19:40.410 --> 01:19:41.610
好吧

01:19:43.110 --> 01:19:45.410
然後現在的問題是啥呢

01:19:45.410 --> 01:19:47.010
現在的問題其實沒啥問題

01:19:47.010 --> 01:19:49.010
你把這樣寫的話就已經幾個了

01:19:49.010 --> 01:19:50.810
深度克隆這一塊就可以了

01:19:50.810 --> 01:19:52.010
但是呢

01:19:52.010 --> 01:19:53.010
我跟你們說

01:19:53.010 --> 01:19:53.810
在面試的時候

01:19:53.810 --> 01:19:57.510
他可能會基於你這個代碼給你聊

01:19:57.510 --> 01:19:58.610
他可以給你聊很多

01:19:58.610 --> 01:20:00.410
然後看你的技術的深度

01:20:00.410 --> 01:20:02.410
同學們你們以後在面試的時候

01:20:02.410 --> 01:20:03.910
有些問題回答不出來

01:20:03.910 --> 01:20:05.210
真的不用他擔心

01:20:05.310 --> 01:20:06.310
因為面試官

01:20:06.310 --> 01:20:08.810
他一定會問到你啞口無言為止

01:20:08.810 --> 01:20:11.210
博士說他想錢擺什麼

01:20:11.210 --> 01:20:12.810
他不把你問到懵

01:20:12.810 --> 01:20:14.910
他就不知道你的深淺

01:20:14.910 --> 01:20:17.310
他不知道你技術到底有多深

01:20:17.310 --> 01:20:18.910
除非你的能力比面試官還強

01:20:18.910 --> 01:20:20.010
各方面都超過面試官

01:20:20.010 --> 01:20:21.910
他問不出來了

01:20:21.910 --> 01:20:22.410
否則的話

01:20:22.410 --> 01:20:24.910
他一定要把你問到懵為止

01:20:24.910 --> 01:20:26.710
他知道這個人能力很強

01:20:26.710 --> 01:20:28.210
已經到這種程度了

01:20:28.210 --> 01:20:31.510
後面不知道我都可以完全可以理解

01:20:31.510 --> 01:20:32.510
所以並不是說

01:20:32.510 --> 01:20:34.010
你必須要回答出沒一個問題

01:20:34.010 --> 01:20:34.710
像這種問題呢

01:20:34.710 --> 01:20:35.910
就是開放性的問題

01:20:35.910 --> 01:20:37.010
開放性的問題

01:20:37.010 --> 01:20:38.910
他會給你聊很多

01:20:38.910 --> 01:20:40.210
他聊啥呀

01:20:40.210 --> 01:20:43.840
他可能會給你這麼聊

01:20:43.840 --> 01:20:45.540
你這個寫的挺好的

01:20:45.540 --> 01:20:47.340
那麼現在呢

01:20:47.340 --> 01:20:49.540
如果說我要科隆這麼一個東西

01:20:49.540 --> 01:21:02.770
怎麼辦

01:21:02.770 --> 01:21:03.370
這是一個啥

01:21:03.370 --> 01:21:09.340
七書數組

01:21:09.340 --> 01:21:12.040
科隆這一課可以聊的東西很多

01:21:12.040 --> 01:21:14.840
你要這把你寫出一個完美的深度科隆

01:21:14.840 --> 01:21:17.640
不簡單的一個代碼

01:21:17.640 --> 01:21:18.940
七八十行水水邊緣

01:21:19.940 --> 01:21:22.740
可能都還圓圓不止

01:21:22.740 --> 01:21:26.740
你這樣的科隆科隆出來的數組是啥

01:21:26.740 --> 01:21:30.680
就不再是七書數組了

01:21:30.680 --> 01:21:31.880
至於為什麼

01:21:31.880 --> 01:21:33.180
你們現在自己去看待吧

01:21:33.180 --> 01:21:34.280
自己去想

01:21:34.280 --> 01:21:35.480
原來的數組是這個樣子

01:21:35.480 --> 01:21:37.480
中間是一個七書數組

01:21:37.480 --> 01:21:38.780
是沒有東西的

01:21:38.780 --> 01:21:41.480
這裡是有個東西想要抵犯的

01:21:41.480 --> 01:21:42.380
那你怎麼解決

01:21:42.380 --> 01:21:43.980
他可能就聊很多

01:21:43.980 --> 01:21:45.980
那麼這些都是開放式的問題

01:21:45.980 --> 01:21:47.580
比方說我要科隆一個對象

01:21:47.580 --> 01:21:49.680
這對象可能是這樣的

01:21:49.680 --> 01:21:51.780
這個是敵方Property

01:21:51.780 --> 01:21:58.780
這個玩意是啥的話

01:21:58.780 --> 01:22:01.580
那就不十一句兩句去扯的玩的了

01:22:01.580 --> 01:22:04.280
只要屬性表述幅

01:22:04.280 --> 01:22:06.980
這樣子也可以給對象定一個屬性

01:22:06.980 --> 01:22:09.480
那麼我們輸出一下ob界點A

01:22:09.480 --> 01:22:11.280
看一下ob界點A是沒問題的

01:22:11.280 --> 01:22:12.280
得到了11

01:22:12.280 --> 01:22:12.980
看到沒

01:22:12.980 --> 01:22:14.280
最後一個輸出了11

01:22:14.280 --> 01:22:15.680
好我來科隆一下這個對象

01:22:15.680 --> 01:22:17.780
這個對象有一個屬性A

01:22:17.780 --> 01:22:19.380
而且你還可以播放來驗證

01:22:19.380 --> 01:22:20.480
有沒有這個屬性A

01:22:20.480 --> 01:22:22.780
A1ob界

01:22:22.880 --> 01:22:24.080
那個硬

01:22:24.080 --> 01:22:26.480
這完全是不知道裡面學過沒有

01:22:26.480 --> 01:22:27.780
好說

01:22:27.780 --> 01:22:28.580
是不是Q

01:22:28.580 --> 01:22:31.080
表示說什麼A是這個對象的屬性

01:22:31.080 --> 01:22:32.480
好他說現在硬硬證了

01:22:32.480 --> 01:22:33.480
A是這個屬性

01:22:33.480 --> 01:22:34.780
它的值為1

01:22:34.780 --> 01:22:43.490
那麼現在我來科隆ob界ob界2

01:22:43.490 --> 01:22:45.490
我們來看一下科隆的ob界2

01:22:45.490 --> 01:22:46.990
裡面有這個屬性嗎

01:22:46.990 --> 01:22:48.090
沒有

01:22:48.090 --> 01:22:51.980
就點一下點A

01:22:51.980 --> 01:22:52.980
抵犯的

01:22:52.980 --> 01:22:55.680
這種屬性就科隆不出來

01:22:55.680 --> 01:22:57.380
你看這裡面很多可以探討的

01:22:57.380 --> 01:22:58.880
那比方說站來

01:22:58.880 --> 01:23:02.280
我可能用勾到函數

01:23:02.280 --> 01:23:08.510
就percent嗎

01:23:08.510 --> 01:23:10.310
勾到器

01:23:10.310 --> 01:23:11.310
一個勾到器

01:23:11.310 --> 01:23:13.110
我都拿著去寫它裡面的東西了

01:23:13.110 --> 01:23:14.310
它原型上一個

01:23:14.310 --> 01:23:16.310
還能拿著寫原型嗎

01:23:16.310 --> 01:23:18.710
寫個

01:23:18.710 --> 01:23:21.510
Prototype C type

01:23:21.510 --> 01:23:24.510
一個函數

01:23:24.510 --> 01:23:25.510
都打得去寫函數

01:23:25.510 --> 01:23:26.910
打的就是一個勾到函數

01:23:26.910 --> 01:23:27.910
那我有一個對象

01:23:27.910 --> 01:23:30.710
p等於6%

01:23:30.710 --> 01:23:33.810
然後來科隆

01:23:33.810 --> 01:23:35.610
p科隆

01:23:35.610 --> 01:23:37.010
把這個p傳進去

01:23:37.010 --> 01:23:38.610
返回一個p2

01:23:38.610 --> 01:23:40.410
我們來輸出一下p2

01:23:40.410 --> 01:23:49.620
得到的結果呢

01:23:49.620 --> 01:23:51.020
肯定是不一樣的

01:23:51.020 --> 01:23:53.020
我們來輸出一下p1

01:23:53.020 --> 01:23:57.220
你看一下輸出的感覺都不一樣

01:23:57.220 --> 01:23:57.820
這是p1

01:23:57.820 --> 01:23:59.620
這是p2

01:23:59.620 --> 01:24:02.420
原型方法跑到對象裡面去了

01:24:02.420 --> 01:24:04.220
如果說你用的是A

01:24:04.220 --> 01:24:06.520
如果說你用的是S6的這種寫法的話

01:24:06.520 --> 01:24:07.720
我現在就是跟它們擴展

01:24:07.720 --> 01:24:08.820
我現在不是講這個

01:24:08.820 --> 01:24:12.720
這個講了就大知識

01:24:12.720 --> 01:24:15.220
就不是一兩天的搞定的事情

01:24:15.220 --> 01:24:17.220
知識太長了

01:24:17.220 --> 01:24:18.620
就扯太遠了

01:24:18.620 --> 01:24:19.220
我就跟你們說

01:24:19.220 --> 01:24:21.420
面試完可能會怎麼去跟你們聊

01:24:21.420 --> 01:24:22.220
那這樣的寫的話

01:24:22.220 --> 01:24:23.820
你可以發現P2

01:24:23.820 --> 01:24:25.620
連這個say hi都沒了

01:24:25.620 --> 01:24:27.020
這些問題全是問題

01:24:27.020 --> 01:24:28.320
它就會跟你們聊

01:24:28.320 --> 01:24:29.720
通過去跟你們聊

01:24:29.720 --> 01:24:31.220
看一下你的基礎

01:24:31.220 --> 01:24:33.320
紮實到什麼程度

01:24:33.320 --> 01:24:34.520
它跟你們聊這個

01:24:34.520 --> 01:24:36.620
如果說你像聊這些事情

01:24:36.620 --> 01:24:40.420
你全部人人對答如流的話

01:24:40.420 --> 01:24:42.620
你絕對穩的

01:24:42.620 --> 01:24:43.420
面試這個過程

01:24:43.420 --> 01:24:44.720
後面的問題它都不想問了

01:24:44.720 --> 01:24:46.020
絕對穩了

01:24:46.020 --> 01:24:47.420
可能問到一個邊界

01:24:47.420 --> 01:24:48.420
還是要問一下

01:24:48.420 --> 01:24:49.020
問一下

01:24:49.020 --> 01:24:50.420
問到你回答不出來為止

01:24:50.420 --> 01:24:52.620
只要後面的正常發揮

01:24:52.620 --> 01:24:54.420
就完全穩了

01:24:54.420 --> 01:24:55.820
因為這裡面牽扯到

01:24:55.820 --> 01:24:56.420
多好東西

01:24:56.420 --> 01:24:58.420
深度可能裡面

01:24:58.420 --> 01:24:59.920
所以說深度可能你

01:24:59.920 --> 01:25:01.020
不能像剛才的同學

01:25:01.020 --> 01:25:02.120
取小的方式

01:25:02.120 --> 01:25:02.620
這個取小的方式

01:25:02.620 --> 01:25:03.820
肯定是有問題的

01:25:03.820 --> 01:25:04.920
它能用取小的方式

01:25:04.920 --> 01:25:06.720
這些東西一個都解決不了

01:25:06.720 --> 01:25:08.320
全都解決不了

01:25:08.320 --> 01:25:09.420
而這種寫法

01:25:09.420 --> 01:25:10.620
它可以在這個寫法

01:25:10.620 --> 01:25:11.920
基礎上進行擴展

01:25:11.920 --> 01:25:13.120
進行深入的探討

01:25:13.120 --> 01:25:14.120
是可以解決的

01:25:14.120 --> 01:25:15.620
很多問題都是可以解決的

01:25:15.620 --> 01:25:21.950
但你這種寫法肯定是要全部改

01:25:21.950 --> 01:25:24.550
好了 那就差不多了

01:25:24.550 --> 01:25:25.350
給大家講到十道題

01:25:25.350 --> 01:25:26.950
這十道題並不能代表

01:25:26.950 --> 01:25:29.150
戒嚴式的全部的那種知識點

01:25:29.150 --> 01:25:30.650
戒嚴式的其他的獨立的知識點

01:25:30.650 --> 01:25:31.750
還有很多

01:25:31.750 --> 01:25:33.450
但是給人拋磚引玉

01:25:33.450 --> 01:25:34.550
讓他們感覺到

01:25:34.550 --> 01:25:36.150
知識點就是這麼回事

01:25:36.150 --> 01:25:37.550
有些東西都看上去簡單

01:25:37.550 --> 01:25:38.550
它背後其實滿複雜的

01:25:38.550 --> 01:25:39.750
就像這種東西

01:25:39.750 --> 01:25:42.350
有些東西都看上去複雜

01:25:42.350 --> 01:25:43.750
其實背後很簡單的

01:25:43.750 --> 01:25:44.950
就是一些API

01:25:44.950 --> 01:25:48.350
你搞清楚了它的原理就很簡單

01:25:48.350 --> 01:25:49.750
那麼前提條件

01:25:49.750 --> 01:25:50.850
基礎的砸死

01:25:50.850 --> 01:25:53.950
基礎的砸死的我才能教你

01:25:53.950 --> 01:25:54.750
那最好了就是

01:25:54.750 --> 01:25:56.250
跟著我把基礎打砸死

01:25:56.250 --> 01:25:57.550
拿我就心態就

01:25:57.550 --> 01:25:58.750
我這邊心態就放寬

01:25:58.750 --> 01:25:59.750
放好了

01:25:59.750 --> 01:26:01.250
不然的話我老是挺心屌感的

01:26:01.250 --> 01:26:03.150
裡面之前是學了什麼東西

01:26:03.150 --> 01:26:03.850
哪些東西有問題

