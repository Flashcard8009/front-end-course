WEBVTT

00:00.000 --> 00:02.000
好嘞 好嘞

00:02.000 --> 00:04.000
好 同学们晚上好

00:04.000 --> 00:06.000
我是独一教育的前段负责人

00:06.000 --> 00:08.000
我习员教我员上师就可以了

00:08.000 --> 00:12.000
咱们这几天晚上呢

00:12.000 --> 00:14.000
在这一次集训里边会给大家讲

00:14.000 --> 00:18.000
实到比较有代表性的面试题

00:18.000 --> 00:20.000
我们的集训营

00:20.000 --> 00:24.000
这一次的集训营其实是咱们

00:24.000 --> 00:28.000
一次新的尝试

00:28.000 --> 00:30.000
因为过去的集训营呢

00:30.000 --> 00:32.000
我们主要是去讲两种内情的东西

00:32.000 --> 00:34.000
一个是知识面

00:34.000 --> 00:37.440
一个是所谓知识面的话

00:37.440 --> 00:39.440
就是一些成体系的知识

00:39.440 --> 00:41.440
包括像什么圆形

00:41.440 --> 00:45.440
圆形链还有作用鱼带

00:45.440 --> 00:47.440
一碰 至少都是仪节课

00:47.440 --> 00:49.440
包括什么网络通信

00:49.440 --> 00:51.440
包括什么那个

00:51.440 --> 00:53.440
无忧原力那就很多节课了

00:53.440 --> 00:55.440
那就是那种大面积的知识

00:55.440 --> 00:57.440
它是成体系的

00:57.440 --> 00:59.440
前面不听 后面就听不懂的这种知识

00:59.440 --> 01:01.440
的知识面

01:01.440 --> 01:03.440
过去咱们集训营经常做了一件事

01:03.440 --> 01:05.440
除了讲知识面之外

01:05.440 --> 01:07.440
我们有的时候集训营

01:07.440 --> 01:09.440
也会讲这种知识的应用

01:09.440 --> 01:11.440
这也很多了

01:11.440 --> 01:13.440
咱们每一次集训营有的时候

01:13.440 --> 01:15.440
讲有什么故宫青少年

01:15.440 --> 01:17.440
好像这个月就有一次

01:17.440 --> 01:19.440
下半个月就有一次咱们这个

01:19.440 --> 01:21.440
知识应用的集训营

01:21.440 --> 01:23.440
包括atema and css的

01:23.440 --> 01:25.440
主要是atema and css

01:25.440 --> 01:27.440
好

01:27.440 --> 01:29.440
的知识应用层面

01:29.440 --> 01:31.440
那么这一次情绪营的

01:31.440 --> 01:33.440
它既不是知识面

01:33.440 --> 01:35.440
也不是知识应用

01:35.440 --> 01:38.940
而是知识点

01:38.940 --> 01:40.940
其实我们在观察整个

01:40.940 --> 01:42.940
就业的过程中

01:42.940 --> 01:44.940
无论是比面试还是之后的

01:44.940 --> 01:46.940
试用期还是以后在企业里干的活

01:46.940 --> 01:48.940
无分就是这三个东西

01:48.940 --> 01:50.940
一个知识面

01:50.940 --> 01:52.940
成体系的一个是知识的应用

01:52.940 --> 01:54.940
挑戴码干活的

01:54.940 --> 01:56.940
第一部分就是知识点

01:56.940 --> 01:58.940
过去的集训营里面

01:58.940 --> 02:00.940
我们没有对知识点去做过多的

02:00.940 --> 02:02.940
阐述和讲解

02:02.940 --> 02:04.940
因为它每一个点它比较独立

02:04.940 --> 02:06.940
这就导致我们讲课的时候

02:06.940 --> 02:08.940
可能会感觉这个上一个点

02:08.940 --> 02:10.940
好像跟下一个点有什么关系

02:10.940 --> 02:12.940
没到底之间好像也没有什么关系

02:12.940 --> 02:14.940
这就是知识点的特点

02:14.940 --> 02:16.940
但是在现实情况下

02:16.940 --> 02:18.940
知识点它仍然会

02:18.940 --> 02:20.940
大面积的出现在

02:20.940 --> 02:22.940
面试体里面

02:22.940 --> 02:24.940
这一次集训营我们打算

02:24.940 --> 02:26.940
讲一讲知识点

02:26.940 --> 02:28.940
每一个点它相对独立

02:28.940 --> 02:30.940
但是它又同时会出现在

02:30.940 --> 02:32.940
面试体里面

02:34.940 --> 02:36.940
这种点的问题

02:36.940 --> 02:38.940
你看我们这个集训营

02:38.940 --> 02:40.940
这几天的题目

02:40.940 --> 02:42.940
一个叫复杂的简单

02:42.940 --> 02:44.940
一个叫简单的复杂

02:44.940 --> 02:46.940
这个文字还是我起的

02:46.940 --> 02:48.940
其实这就是知识点

02:48.940 --> 02:50.940
给我的感觉

02:50.940 --> 02:52.940
有些题给我的感觉

02:52.940 --> 02:54.940
有些题看似很简单

02:54.940 --> 02:56.940
其他背后运藏着

02:56.940 --> 02:58.940
非常复杂的东西

02:58.940 --> 03:00.940
有些题看似很复杂

03:00.940 --> 03:02.940
但是你只要抓住了关键点

03:02.940 --> 03:04.940
能够看得发的本质

03:04.940 --> 03:06.940
那么你会发现这种题其实很简单

03:06.940 --> 03:08.940
那么这两天

03:08.940 --> 03:10.940
学下来同学们

03:10.940 --> 03:12.940
希望同学们跟袁老师一样

03:12.940 --> 03:14.940
也会产生这样的一个感觉

03:14.940 --> 03:16.940
然后我说一下

03:16.940 --> 03:18.940
咱们的

03:18.940 --> 03:20.940
经常纪律

03:20.940 --> 03:22.940
虽然是我们线上课程

03:22.940 --> 03:24.940
虽然是面向的是

03:24.940 --> 03:26.940
并非我们的后期学员

03:26.940 --> 03:28.940
但是我希望把这些学习的精神

03:28.940 --> 03:30.940
和纪律

03:30.940 --> 03:32.940
传达下去

03:32.940 --> 03:34.940
不管你将来是不是咱们的学员

03:34.940 --> 03:36.940
对你以后的学习是肯定有好处的

03:36.940 --> 03:38.940
其实我最重要的一个要求

03:38.940 --> 03:40.940
我有很多要求我在学习里边

03:40.940 --> 03:42.940
我在后期

03:42.940 --> 03:44.940
对后期学员讲学习的纪律

03:44.940 --> 03:46.940
我都要讲一两节课的

03:46.940 --> 03:48.940
我说了

03:48.940 --> 03:50.940
首要的要求

03:50.940 --> 03:52.940
看视频全神关注

03:52.940 --> 03:54.940
看教程

03:54.940 --> 03:56.940
无论是学习挑战

03:56.940 --> 03:58.940
还是看视频全神关注

03:58.940 --> 04:00.940
我过去

04:00.940 --> 04:02.940
刚才还有同学说

04:02.940 --> 04:04.940
喝着啤酒看了视频吧

04:04.940 --> 04:06.940
我觉得呢

04:06.940 --> 04:08.940
你可能遭他的啤酒

04:08.940 --> 04:10.940
喝啤酒最好看什么

04:10.940 --> 04:12.940
看球赛

04:12.940 --> 04:14.940
看一些比赛之类的

04:14.940 --> 04:16.940
这些东西呢并不是很好

04:16.940 --> 04:18.940
我不见你这样做

04:18.940 --> 04:20.940
而且呢我甚至建议

04:20.940 --> 04:22.940
不是我甚至建议我就要求这样

04:22.940 --> 04:24.940
你看视频的时候看教程的时候

04:24.940 --> 04:26.940
不要用手机看

04:26.940 --> 04:28.940
应该在我们电脑拿出来

04:28.940 --> 04:30.940
因为我们要摆出来是很多代码

04:30.940 --> 04:32.940
这代码呢字体比较小

04:32.940 --> 04:34.940
你用手机看不清楚

04:34.940 --> 04:36.940
电脑拿出来手机放到一边

04:36.940 --> 04:38.940
关机或者开飞型模式

04:38.940 --> 04:40.940
拿去充电

04:40.940 --> 04:42.940
有些同学呢学习惯很不好

04:42.940 --> 04:44.940
一边听课

04:44.940 --> 04:46.940
一边玩着王中荣耀

04:46.940 --> 04:48.940
或者听着喝

04:48.940 --> 04:50.940
认为自己学习了

04:50.940 --> 04:52.940
其实你只是一个自我安慰

04:52.940 --> 04:54.940
你根本就没有学习

04:54.940 --> 04:56.940
你还不如真的去好好玩王中荣耀

04:56.940 --> 04:58.940
不要去坑别人

04:58.940 --> 05:00.940
免得袁老师一会儿说话大声

05:00.940 --> 05:02.940
你把你吓一跳

05:02.940 --> 05:04.940
武杀一边拿到

05:04.940 --> 05:06.940
是不是把别人坑了

05:06.940 --> 05:08.940
还不如好好去玩

05:08.940 --> 05:10.940
玩的时候就好好玩

05:10.940 --> 05:12.940
当然你说的一个简量点

05:12.940 --> 05:14.940
要谈开来说的话很多

05:14.940 --> 05:16.940
好,咱们开始今天的内容

05:18.940 --> 05:22.260
喝水

05:24.260 --> 05:26.260
第一题

05:26.260 --> 05:29.630
第一题是一道今天的面试题了

05:29.630 --> 05:31.630
也是我们以后在

05:31.630 --> 05:33.630
企业开发当中会

05:33.630 --> 05:35.630
经常遇到的一个小问题

05:35.630 --> 05:37.630
其实他说他小问题

05:37.630 --> 05:39.630
他背后的东西还蛮复杂的

05:39.630 --> 05:41.630
就是他是有三个问题存在

05:41.630 --> 05:43.630
一个是这个表达是得到是啥

05:43.630 --> 05:45.630
这个题呢,朋友们

05:45.630 --> 05:47.630
提前拿到了,现在应该知道

05:47.630 --> 05:49.630
这个表达是得到的是啥呀

05:49.630 --> 05:52.940
告诉我

05:52.940 --> 05:54.940
Q还是FORCE

05:54.940 --> 05:58.320
FORCE

05:58.320 --> 06:00.320
你这个玩意儿你去

06:00.320 --> 06:02.320
有浏览器去看一下就完事了

06:02.320 --> 06:04.320
这一题的答案其实很好验证的

06:04.320 --> 06:06.320
FORCE

06:06.320 --> 06:08.320
关键是为什么

06:08.320 --> 06:10.320
接下来他第二个问题

06:10.320 --> 06:12.320
就是为什么

06:12.320 --> 06:14.320
如何解决这个问题

06:14.320 --> 06:16.320
那么一个一个看

06:16.320 --> 06:18.320
这个玩意儿已经得到的结论是FORCE

06:18.320 --> 06:20.320
包括除了5.3

06:20.320 --> 06:22.320
其实还有很多

06:22.320 --> 06:24.320
0.3-0.2,是不是等于0.1呢

06:24.320 --> 06:26.320
也是FORCE,因为0.3-0.2

06:26.320 --> 06:28.320
是等于这么一个玩意儿

06:28.320 --> 06:30.320
好,那么为什么

06:30.320 --> 06:32.320
为什么是FORCE

06:32.320 --> 06:34.320
那么这就涉及到

06:34.320 --> 06:36.320
数字的存储问题

06:38.320 --> 06:40.320
两个等号

06:40.320 --> 06:42.320
两个等号也是FORCE

06:42.320 --> 06:46.400
两个等号这个意思

06:46.400 --> 06:48.400
也是FORCE,一样的

06:48.400 --> 06:50.400
是这样啊,你们以后

06:50.400 --> 06:52.400
在企业开发里面是不能用

06:52.400 --> 06:54.400
两个等号的

06:54.400 --> 06:56.400
有些公司规定

06:56.400 --> 06:58.400
规定的稍微宽松一点

06:58.400 --> 07:00.400
顶多批评你两句

07:00.400 --> 07:02.400
有的公司规定的严格

07:02.400 --> 07:04.400
一点,你用两个等号

07:04.400 --> 07:06.400
直接扣工资了

07:06.400 --> 07:08.400
不准用两个等号的

07:08.400 --> 07:10.400
实际上在现实情况下

07:10.400 --> 07:12.400
它会有一些检查工具

07:12.400 --> 07:14.400
直接给你报错了

07:14.400 --> 07:18.400
为什么会得到一个FORCE呢

07:18.400 --> 07:19.400
这就涉及到

07:19.400 --> 07:22.400
GS它是如何来处理数字的

07:22.400 --> 07:24.400
在GS里面

07:24.400 --> 07:26.400
数字啊,它只有一种类型

07:26.400 --> 07:28.400
就是NUMBER

07:28.400 --> 07:32.350
你看别的语言啊

07:32.350 --> 07:34.350
它是一个数字啊,它又会产生

07:34.350 --> 07:36.350
很多的类型

07:36.350 --> 07:38.350
什么整形,短整形

07:38.350 --> 07:40.350
长整形

07:40.350 --> 07:43.350
还有双经度浮炼数

07:43.350 --> 07:45.350
单经度浮炼数一大堆

07:45.350 --> 07:47.350
带符号的长整形

07:47.350 --> 07:49.350
不带符号的长整形

07:49.350 --> 07:51.350
带符号的整形一大堆

07:51.350 --> 07:53.350
它又会有各种各样的类型的数字

07:53.350 --> 07:56.350
但是在GS里面只有一种

07:56.350 --> 07:58.350
那么它也就是说

07:58.350 --> 08:01.350
在GS里面存整数和存小数

08:01.350 --> 08:04.350
都是一种方式

08:04.350 --> 08:06.350
那么在转换成

08:06.350 --> 08:07.350
在存的时候

08:08.350 --> 08:10.350
为什么呢?

08:10.350 --> 08:13.350
是因为GS在存数字的时候

08:13.350 --> 08:15.350
它只能存二净字

08:15.350 --> 08:17.350
它存不了十净字的东西

08:17.350 --> 08:19.350
因为GS整个就是二净字

08:19.350 --> 08:21.350
包括你写的字胡叉啊

08:21.350 --> 08:23.350
包括你用的什么视频、音频

08:23.350 --> 08:25.350
在GS里面全是二净字

08:25.350 --> 08:27.350
那数字肯定不例外了

08:27.350 --> 08:29.350
它肯定是二净字

08:29.350 --> 08:31.350
那这就涉及到

08:31.350 --> 08:33.350
就是十净字的小数

08:33.350 --> 08:35.350
如何转换成二净字

08:35.350 --> 08:36.350
它如何转换呢?

08:36.350 --> 08:38.350
它转换的方式

08:39.350 --> 08:41.350
是乘二取者

08:41.350 --> 08:48.210
怎么乘呢?

08:48.210 --> 08:49.210
举个例子吧

08:49.210 --> 08:51.210
比方说0.125

08:51.210 --> 08:54.210
这是一个十净字的小数

08:54.210 --> 08:57.210
我如何把它转换成二净字的小数呢?

08:58.210 --> 09:01.210
其实你可以在浏览器里面测试一下吧

09:01.210 --> 09:03.210
知道怎么测试吗?

09:03.210 --> 09:05.210
0.125怎么把它变成二净字?

09:05.210 --> 09:07.210
调用数字里面的一个函数

09:07.210 --> 09:09.210
叫toosting

09:09.210 --> 09:10.210
这个函数在做什么呢?

09:10.210 --> 09:14.210
它是把一个数字转换成字幅串

09:14.210 --> 09:15.210
而转换的过程中

09:15.210 --> 09:17.210
你可以在这里写参数

09:17.210 --> 09:20.210
这参数叫radius

09:20.210 --> 09:22.210
它的意思表示净字

09:22.210 --> 09:23.210
比方说你写个二

09:23.210 --> 09:25.210
它就会把它转成二净字

09:25.210 --> 09:28.210
得到的二净字是0.001

09:28.210 --> 09:30.210
怎么转的?

09:30.210 --> 09:32.210
乘一二

09:32.210 --> 09:37.210
乘一二过后是不是得到一个0.25

09:37.210 --> 09:38.210
对不对?

09:38.210 --> 09:41.210
好,乘一二过后干嘛?取整

09:41.210 --> 09:42.210
取它的准数部分

09:42.210 --> 09:43.210
是不是0?

09:43.210 --> 09:45.210
准数部分是0

09:45.210 --> 09:47.210
好,取了准数部分过后

09:47.210 --> 09:50.210
是不是还剩下0.25

09:50.210 --> 09:52.210
又来做同样的操作

09:52.210 --> 09:54.210
乘一二,然后来到0.5

09:54.210 --> 09:55.210
取整0

09:55.210 --> 09:57.210
然后到0.5

09:57.210 --> 10:00.210
乘一二,再得到一个数

10:00.210 --> 10:03.210
就是1.0,取整是不是1

10:03.210 --> 10:05.210
然后还剩下啥?

10:05.210 --> 10:08.210
1.0,整数部分已经被取掉了

10:08.210 --> 10:10.210
是不是只剩下0.0了

10:10.210 --> 10:12.210
那就是0了

10:12.210 --> 10:14.210
那就干嘛?结束

10:14.210 --> 10:16.210
于是到要结束位置的时候

10:16.210 --> 10:19.210
整个二净字就转换出来了

10:19.210 --> 10:21.210
就是001

10:21.210 --> 10:24.210
所以说0.15变成二净字就是0.001

10:24.210 --> 10:26.210
就是这么算出来的

10:26.210 --> 10:27.210
能听懂吗?

10:27.210 --> 10:29.210
这一块能听懂的话就可以

10:29.210 --> 10:38.280
除此之外,你们可以变净字

10:38.280 --> 10:40.280
可以变成别的净字都可以的

10:40.280 --> 10:43.280
最高就是36净字

10:43.280 --> 10:47.280
最多就到达36净字

10:47.280 --> 10:49.280
不能再多了

10:49.280 --> 10:50.280
为啥呢?

10:50.280 --> 10:52.280
因为它数不够了

10:52.280 --> 10:54.280
因为我们知道16净字

10:54.280 --> 10:58.280
16净字0到多少?0到F

10:58.280 --> 11:00.280
超过了10就是用

11:00.280 --> 11:02.280
A,B,C,D,E,F

11:02.280 --> 11:04.280
来表示

11:04.280 --> 11:06.280
那17净字就是7嘛

11:06.280 --> 11:08.280
18净字

11:08.280 --> 11:11.280
A,B,C,D,E,F,C,H

11:11.280 --> 11:12.280
然后就是I

11:12.280 --> 11:15.280
它一共就这么多字母和数字

11:15.280 --> 11:16.280
所以说它不够了

11:16.280 --> 11:19.280
26个英文字母加上10个数字

11:19.280 --> 11:20.280
0到9嘛

11:20.280 --> 11:22.280
是不是刚好36

11:22.280 --> 11:24.280
比36多的话就不够用了

11:24.280 --> 11:26.280
比较容易写37

11:26.280 --> 11:28.280
它告诉你这个净字

11:28.280 --> 11:31.550
它已经搞不定了

11:31.550 --> 11:34.550
对,就是0到Z

11:34.550 --> 11:36.550
好,那么现在我们回过头来

11:36.550 --> 11:38.550
这样转换是没问题的

11:38.550 --> 11:40.550
但是我们换一些数字呢

11:40.550 --> 11:44.550
比方说刚才的0.4

11:44.550 --> 11:45.550
对吧,就5.4了

11:45.550 --> 11:47.550
我们就不考虑了

11:47.550 --> 11:49.550
整数部分转换没有什么问题

11:49.550 --> 11:51.550
小数部分呢

11:51.550 --> 11:52.550
我们来看一下这一块的怎么转换

11:52.550 --> 11:54.550
一样的,乘1,2

11:54.550 --> 11:57.550
乘1,2是个0.8,取整0

11:57.550 --> 11:59.550
然后0.8再乘1,2是个1.6

11:59.550 --> 12:01.550
取整多少?1

12:01.550 --> 12:04.550
剩下多少?剩下0.6

12:04.550 --> 12:06.550
然后再乘1,2多少?1.2

12:06.550 --> 12:08.550
取整1

12:08.550 --> 12:10.550
然后又剩下0.2

12:10.550 --> 12:13.550
乘1,2,0.4,取整0

12:13.550 --> 12:15.550
然后又剩下0.4

12:15.550 --> 12:17.550
看是不是回去了

12:17.550 --> 12:19.550
就回去了

12:19.550 --> 12:21.550
0.80

12:21.550 --> 12:22.550
那也就是这个数字

12:22.550 --> 12:24.550
到最后就变成了这个地方

12:24.550 --> 12:26.550
在循环了

12:26.550 --> 12:28.550
0.4转换成2

12:28.550 --> 12:29.550
净字的小数过后

12:29.550 --> 12:31.550
变成0110

12:31.550 --> 12:33.550
0110

12:33.550 --> 12:35.550
0110

12:35.550 --> 12:37.550
是无线循环

12:37.550 --> 12:40.550
而无线循环的东西

12:40.550 --> 12:43.550
计算机可不说计算机

12:43.550 --> 12:45.550
任何一门计算机语言

12:45.550 --> 12:46.550
它是纯不下的

12:46.550 --> 12:47.550
它无线的,它怎么纯啊?

12:47.550 --> 12:49.550
它纯不下了

12:49.550 --> 12:51.550
怎么办?纯到一定位置

12:51.550 --> 12:53.550
它就扔掉了

12:53.550 --> 12:56.550
所以这就是精度丢失的来源

12:56.550 --> 12:58.550
就在这里丢失了

12:58.550 --> 13:00.550
那么刚才5.4

13:00.550 --> 13:02.550
其实我们不看5的话

13:02.550 --> 13:04.550
就看这个4,是不是有这个情况

13:04.550 --> 13:06.550
那么0.3呢

13:06.550 --> 13:07.550
也有这个情况

13:07.550 --> 13:08.550
0.3再来

13:08.550 --> 13:10.550
0.6取整0

13:10.550 --> 13:12.550
1.2

13:12.550 --> 13:14.550
你看到1.2吧

13:14.550 --> 13:16.550
就懂了

13:16.550 --> 13:19.550
0.6再去乘1.2

13:19.550 --> 13:21.550
所以1.2取整1

13:21.550 --> 13:22.550
那又变成0.2吧

13:22.550 --> 13:24.550
0.2说再乘1.2

13:24.550 --> 13:26.550
0.4,到0.4啊

13:26.550 --> 13:29.550
那是不是后面又要开始循环了

13:29.550 --> 13:31.550
0.3它也是

13:31.550 --> 13:32.550
转换成2净字

13:32.550 --> 13:35.550
它也是有精度丢失的

13:35.550 --> 13:36.550
那么既然有精度丢失

13:36.550 --> 13:37.550
那两个数以运算

13:37.550 --> 13:39.550
那肯定是有问题的

13:39.550 --> 13:45.550
0.5解去0.4解去0.3

13:45.550 --> 13:48.550
所以肯定是有些问题的

13:48.550 --> 13:50.550
懂了意思吧?

13:50.550 --> 13:52.550
好,那么

13:52.550 --> 13:54.550
懂了意思吧?

13:54.550 --> 13:57.550
好,那么再看下一个问题

13:57.550 --> 14:00.550
它如何解决呢?

14:00.550 --> 14:03.550
如何解决这个问题呢?

14:03.550 --> 14:05.550
好,这就涉及到

14:05.550 --> 14:06.550
咱们计算机里边

14:06.550 --> 14:08.550
就是不是计算机

14:08.550 --> 14:10.550
介石里面

14:10.550 --> 14:11.550
纯数字的时候

14:11.550 --> 14:15.550
它最多支持多少精度的问题

14:15.550 --> 14:18.550
它精度到底支持多少

14:18.550 --> 14:20.550
其实要解决这个问题

14:20.550 --> 14:21.550
其实也很简单

14:21.550 --> 14:22.550
怎么解决呢?

14:22.550 --> 14:24.550
就5.4解5.3

14:24.550 --> 14:26.550
是不是等于0.1?

14:26.550 --> 14:27.550
那现在肯定不想等

14:27.550 --> 14:28.550
但是呢

14:28.550 --> 14:29.550
从人类的视角来看

14:29.550 --> 14:30.550
它确实又是相等的

14:30.550 --> 14:32.550
我们如何让计算机

14:32.550 --> 14:33.550
得到的结论

14:33.550 --> 14:35.550
跟我们人类一致呢?

14:35.550 --> 14:37.550
那就用误差呗

14:37.550 --> 14:39.550
比方说你设置一个很小的误差

14:39.550 --> 14:42.550
用了这个0.5

14:42.550 --> 14:45.550
0.5解去0.4

14:45.550 --> 14:50.060
然后再减一个0.1

14:50.060 --> 14:52.060
如果说这样减出来

14:52.060 --> 14:58.100
它的误差很小

14:58.100 --> 15:00.100
它小于某一个误差

15:00.100 --> 15:01.100
比方说这个误差

15:01.100 --> 15:03.100
让我们去很小一点

15:03.100 --> 15:05.100
去一个很小的误差

15:05.100 --> 15:06.100
诶?小于这个误差

15:06.100 --> 15:07.100
我们觉得OK吧

15:07.100 --> 15:09.100
然后我就可以认为

15:09.100 --> 15:11.100
你们两个

15:11.100 --> 15:13.100
就这个玩意儿和这个玩意儿

15:13.100 --> 15:14.100
是相等的

15:14.100 --> 15:16.100
因此在实际的开发中

15:16.100 --> 15:19.920
我们可以写这么一个函数

15:19.920 --> 15:20.920
比方说我们写个函数

15:20.920 --> 15:22.920
叫做

15:22.920 --> 15:24.920
number equal

15:24.920 --> 15:28.680
就是数字间的比较

15:28.680 --> 15:29.680
是否相等

15:29.680 --> 15:31.680
一个传第一个数字

15:31.680 --> 15:32.680
你再给我传第二个数字

15:32.680 --> 15:34.680
或者是N1N2

15:34.680 --> 15:36.680
那么我如何来比较N1N2

15:36.680 --> 15:37.680
是不是相等的呢

15:37.680 --> 15:39.680
如果说我要考虑小数

15:39.680 --> 15:41.680
这个运算精度的问题的话

15:41.680 --> 15:42.680
那么我们只能取一个

15:42.680 --> 15:44.680
合适的误差

15:44.680 --> 15:45.680
所以我们怎么办呢

15:45.680 --> 15:48.680
我就用N1减去N2

15:48.680 --> 15:50.680
看一下这个相减的结果

15:50.680 --> 15:53.680
是不是小于某一个误差

15:53.680 --> 15:56.680
比方说我们把误差取小一点

15:56.680 --> 15:58.680
诶?我觉得只要比这个误差

15:58.680 --> 15:59.680
还要小

15:59.680 --> 16:00.680
那么我们觉得

16:00.680 --> 16:02.680
这个误差是可以估略的

16:02.680 --> 16:04.680
懂了意思吧

16:04.680 --> 16:05.680
那么这一个函数

16:05.680 --> 16:06.680
有没有问题的东西吗

16:06.680 --> 16:07.680
你们觉得个函数

16:07.680 --> 16:08.680
现在有没有问题

16:08.680 --> 16:09.680
那以后我要比较N1N2

16:09.680 --> 16:12.680
是不是相等比较说

16:12.680 --> 16:15.680
number equals

16:15.680 --> 16:17.680
我要比较5.4-5.3

16:17.680 --> 16:19.680
是不是等于0

16:19.680 --> 16:21.680
是不是等于0.1

16:21.680 --> 16:24.680
现在的结论是输出一个true

16:24.680 --> 16:25.680
说明它相等的

16:25.680 --> 16:26.680
这个东西跟这个东西

16:26.680 --> 16:27.680
是相等的

16:27.680 --> 16:28.680
我们以后就不用那个

16:28.680 --> 16:29.680
在这个位置

16:29.680 --> 16:31.680
就不用去用等号来比较了

16:31.680 --> 16:33.680
用函数来比较

16:33.680 --> 16:34.680
诶?是不是可以搞定

16:34.680 --> 16:35.680
但是我告诉你同学们

16:35.680 --> 16:38.680
这个函数是不完美的

16:38.680 --> 16:41.680
至少有一些bug

16:41.680 --> 16:42.680
首先看

16:42.680 --> 16:44.680
这里里边有两个问题

16:44.680 --> 16:45.680
第一个问题

16:45.680 --> 16:47.680
你们看能看出来几个问题

16:47.680 --> 16:58.450
能看出来吗

16:58.450 --> 16:59.450
Trustin不是强制

16:59.450 --> 17:01.450
转换为支付串吗

17:01.450 --> 17:04.450
是啊,是转换为支付串

17:04.450 --> 17:05.450
什么问题啊

17:05.450 --> 17:06.450
有一个比较明显的问题

17:06.450 --> 17:08.450
没看出来吗

17:09.450 --> 17:12.450
有时候就知道了

17:12.450 --> 17:15.450
是不是要用绝对值比较好一点啊

17:15.450 --> 17:16.450
为什么呢

17:16.450 --> 17:18.450
那如果说我用这种写法

17:18.450 --> 17:20.450
5和100

17:20.450 --> 17:22.450
你会发现它也是true

17:22.450 --> 17:24.450
5都等于100了

17:24.450 --> 17:25.450
为什么呢

17:25.450 --> 17:26.450
因为这两个相见

17:26.450 --> 17:28.450
不是负的95

17:28.450 --> 17:30.450
负的95肯定比这个小

17:30.450 --> 17:31.450
负数

17:31.450 --> 17:32.450
说应该怎么样啊

17:32.450 --> 17:33.450
应该把这个玩意儿

17:33.450 --> 17:35.450
再取一个绝对值

17:35.450 --> 17:36.450
对不对

17:39.450 --> 17:40.450
用这个函数

17:40.450 --> 17:42.450
把这个表达式的运算结果

17:42.450 --> 17:44.450
再取一个绝对值

17:44.450 --> 17:45.450
那么这样子的话

17:45.450 --> 17:46.450
你是负数的话

17:46.450 --> 17:47.450
你变成众数了

17:47.450 --> 17:49.450
那95肯定不比它小

17:49.450 --> 17:51.450
那么现在才正常

17:51.450 --> 17:52.450
好,第一个问题

17:52.450 --> 17:54.450
我们把它修不掉

17:54.450 --> 17:56.450
好,第二个问题

17:56.450 --> 17:59.450
这个函数它不能通用

17:59.450 --> 18:01.450
你觉得这个函数挺好的

18:01.450 --> 18:03.450
0.00001

18:03.450 --> 18:04.450
已经很小了

18:04.450 --> 18:06.450
那如果说遇到一些

18:06.450 --> 18:08.450
精度比较高的系统

18:08.450 --> 18:09.450
它很在乎

18:09.450 --> 18:11.450
它的精度可能

18:11.450 --> 18:12.450
平时运算的精度

18:12.450 --> 18:13.450
可能就是小数点

18:13.450 --> 18:15.450
后面有七八位了

18:15.450 --> 18:18.450
那你这个精度肯定是不够的

18:18.450 --> 18:19.450
你还要再小

18:19.450 --> 18:21.450
就是你在写这个函数的时候

18:21.450 --> 18:24.450
你无法保证

18:24.450 --> 18:26.450
在每一个系统里

18:26.450 --> 18:27.450
不要通用

18:27.450 --> 18:28.450
能懂我这个意思吗

18:28.450 --> 18:29.450
可能你做一些

18:29.450 --> 18:30.450
比方说做一些

18:30.450 --> 18:33.450
我们的汇率幻算的系统

18:33.450 --> 18:34.450
那这种精度

18:34.450 --> 18:35.450
要求不高

18:35.450 --> 18:36.450
精确到后边

18:36.450 --> 18:37.450
两位就可以了

18:37.450 --> 18:39.450
那么这个精度就完全够了

18:39.450 --> 18:41.450
如果说物差比这个还小的话

18:41.450 --> 18:43.450
就可以认为相等的

18:43.450 --> 18:45.450
那如果说你要做一些科学

18:45.450 --> 18:47.450
比方说一科研机构里边

18:47.450 --> 18:48.450
一些

18:48.450 --> 18:49.450
苏控机床

18:49.450 --> 18:51.450
一些精度要求非常非常高的

18:51.450 --> 18:53.450
小数点后边要七八位的

18:53.450 --> 18:55.450
比方说一些什么

18:55.450 --> 18:57.450
不知道你们有没有去买过黄金

18:57.450 --> 18:58.450
其实我也没怎么买过黄金

18:58.450 --> 18:59.450
我陪我邪份去买过

18:59.450 --> 19:01.450
什么那个

19:01.450 --> 19:02.450
黄金的那个叫啥

19:02.450 --> 19:03.450
纯度啊

19:03.450 --> 19:04.450
它要精确到小数点里边

19:04.450 --> 19:06.450
好多好多个铃

19:06.450 --> 19:08.450
那如果说遇到这样的一个系统

19:08.450 --> 19:09.450
它精度要求很高

19:09.450 --> 19:10.450
一个精度不够用的

19:10.450 --> 19:12.450
那也就是你现在这个问题是

19:12.450 --> 19:14.450
你在写这个函数的时候

19:14.450 --> 19:16.450
你不知道这个精度要用多少

19:16.450 --> 19:17.450
用什么

19:17.450 --> 19:18.450
多少合适

19:18.450 --> 19:20.450
最好了有人能告诉我一个

19:20.450 --> 19:21.450
最小精度

19:21.450 --> 19:23.450
这是最好的

19:23.450 --> 19:24.450
有没有人能告诉你

19:24.450 --> 19:26.450
最小精度是啥呀

19:26.450 --> 19:28.450
还真有

19:28.450 --> 19:31.450
它的最小精度

19:31.450 --> 19:33.450
是二的

19:33.450 --> 19:35.450
五

19:35.450 --> 19:37.450
腹

19:37.450 --> 19:39.450
五十二四方

19:39.450 --> 19:41.450
好不好要一点点的解释啊

19:41.450 --> 19:43.450
有没有同学不知道这个玩意是啥的

19:43.450 --> 19:44.450
不知道的话就可以

19:44.450 --> 19:51.700
这个玩意是ES6的那个

19:51.700 --> 19:53.700
穷臂运算

19:53.700 --> 19:55.700
穷臂运算

19:55.700 --> 19:58.700
比方说我要做一个二的三四方

19:58.700 --> 20:00.700
非常简单

20:00.700 --> 20:02.700
做一个四的平方

20:02.700 --> 20:04.700
当然以前的写法

20:04.700 --> 20:06.700
可以用这种写法

20:06.700 --> 20:08.700
四的平方可以用这种写法

20:08.700 --> 20:09.700
是一样的效果

20:09.700 --> 20:10.700
现在可以用一个运算符

20:10.700 --> 20:12.700
就是两个系号

20:12.700 --> 20:13.700
四的平方

20:13.700 --> 20:15.700
懂了意思吗

20:15.700 --> 20:17.700
那我现在要做的是什么呢

20:17.700 --> 20:19.700
我要告诉你的最小精度是

20:19.700 --> 20:21.700
二的

20:21.700 --> 20:23.700
多少四方

20:23.700 --> 20:24.700
腹

20:24.700 --> 20:28.980
五十二四方

20:28.980 --> 20:30.980
这是它的最小精度

20:30.980 --> 20:32.980
你们自己刷一刷

20:32.980 --> 20:34.980
得很难刷得出来

20:34.980 --> 20:35.980
二的腹的

20:35.980 --> 20:37.980
五十二四方

20:37.980 --> 20:38.980
那么得到的结果呢

20:38.980 --> 20:39.980
有的人看不懂这个玩意

20:39.980 --> 20:40.980
这个玩意是啥

20:40.980 --> 20:42.980
得到的结果是2.228

20:42.980 --> 20:43.980
成义

20:43.980 --> 20:45.980
这个意思表示十

20:45.980 --> 20:48.980
十的腹十六四方

20:48.980 --> 20:50.980
成出来是这个

20:50.980 --> 20:51.980
得出来的结果是这个

20:51.980 --> 20:52.980
它用个科学技术

20:52.980 --> 20:54.980
因为太多了

20:54.980 --> 20:55.980
二点这么多

20:55.980 --> 20:58.980
成义十的腹十六四方

20:58.980 --> 21:02.980
这就是GS的最小精度

21:02.980 --> 21:03.980
也就是说

21:03.980 --> 21:04.980
你如果说你算出来

21:04.980 --> 21:05.980
精度比这个小的话

21:05.980 --> 21:07.980
肯定是相等的

21:07.980 --> 21:08.980
比这个精度大

21:08.980 --> 21:10.980
那你肯定是不相等

21:10.980 --> 21:11.980
所以这样子一来

21:11.980 --> 21:12.980
我们就解决了

21:12.980 --> 21:14.980
所有系统这些问题了

21:14.980 --> 21:16.980
我就已经用的是最小精度了

21:16.980 --> 21:17.980
好

21:17.980 --> 21:18.980
那么现在呢

21:18.980 --> 21:19.980
五和一板肯定不相等

21:19.980 --> 21:21.980
然后五点三

21:21.980 --> 21:24.980
五点四减去五点三

21:24.980 --> 21:27.980
是不是等于零点一

21:27.980 --> 21:39.580
扩起来

21:39.580 --> 21:41.580
我急错了吧

21:41.580 --> 21:48.990
我看一下

21:48.990 --> 21:57.140
是这个

21:57.140 --> 22:03.340
我试一试

22:03.340 --> 22:04.340
地方写错了

22:04.340 --> 22:05.340
小语等于

22:05.340 --> 22:11.980
小语等于

22:11.980 --> 22:13.980
打脸了

22:13.980 --> 22:14.980
不应该啊

22:14.980 --> 22:19.950
我试一下

22:19.950 --> 22:21.950
前边加了一个五

22:21.950 --> 22:26.160
我来这里测试一下

22:26.160 --> 22:33.560
五点四减去五点三

22:33.560 --> 22:34.560
它

22:34.560 --> 22:35.560
我保存的时候

22:35.560 --> 22:36.560
自动忙我格式化

22:36.560 --> 22:37.560
把扩好区调了

22:37.560 --> 22:43.370
说明它不扩起来也可以

22:43.370 --> 22:49.000
零点四减去零点三

22:49.000 --> 22:51.000
哦

22:51.000 --> 22:56.300
明白了

22:56.300 --> 22:58.300
明白了

22:58.300 --> 23:01.300
整数部分影响到它了

23:01.300 --> 23:04.300
整数部分影响到这个精度了

23:04.300 --> 23:08.890
这就是另外一个话题了

23:08.890 --> 23:14.350
这就是另外一个话题了

23:14.350 --> 23:16.350
我们这里先说零点几吧

23:16.350 --> 23:17.350
我这样子

23:17.350 --> 23:18.350
我们这里先说零点几

23:18.350 --> 23:22.350
如果整数部分有值的情况下

23:22.350 --> 23:26.350
看到老师写完要找发个邮件方式

23:26.350 --> 23:28.350
整数部分有值的情况下

23:28.350 --> 23:31.350
我下来单独的给一个学老师发一份

23:31.350 --> 23:32.350
然后他发到群里边

23:32.350 --> 23:33.350
好吧

23:33.350 --> 23:34.350
我们这里整数部分

23:34.350 --> 23:35.350
我就现在不考虑

23:35.350 --> 23:37.350
不然的话那块的问题就比较复杂了

23:37.350 --> 23:38.350
可以解决的

23:38.350 --> 23:39.350
整数部分那一块

23:39.350 --> 23:42.350
可以解决的代码要重新写一下

23:42.350 --> 23:45.350
我们只考虑整数部分是零的情况

23:45.350 --> 23:46.350
那么这样一减出来的话

23:46.350 --> 23:47.350
就可以使用这种方式来解决

23:47.350 --> 23:49.350
零点是五三 减零点二

23:49.350 --> 23:54.350
零点是减去零点三都可以了

23:54.350 --> 23:56.350
减五

23:56.350 --> 23:58.350
刚才的问题

23:58.350 --> 23:59.350
关节不存在

23:59.350 --> 24:02.350
现在我们不专注搞定这一块的问题

24:02.350 --> 24:03.350
就是这一块

24:03.350 --> 24:07.350
为什么是复的五十二次发

24:07.350 --> 24:08.350
它为什么

24:08.350 --> 24:11.350
因为有的时候你遇到的面识体

24:11.350 --> 24:12.350
它不一定是这种体

24:12.350 --> 24:14.350
它可能又是别的体

24:14.350 --> 24:16.350
比方说是什么体呢

24:16.350 --> 24:18.350
我再给大家举个例子

24:18.350 --> 24:20.350
就是数字这一块

24:20.350 --> 24:22.350
它考察力的话

24:22.350 --> 24:25.350
坑比较深的也就是小数了

24:25.350 --> 24:26.350
什么体呢

24:26.350 --> 24:27.350
它可能是这样的

24:27.350 --> 24:33.500
二的五十三四方

24:33.500 --> 24:40.500
然后n的二的start加上一百

24:40.500 --> 24:42.500
然后循环

24:42.500 --> 24:44.500
i等于0

24:44.500 --> 24:45.500
对不对

24:45.500 --> 24:47.500
i等于start

24:47.500 --> 24:49.500
i小于n

24:49.500 --> 24:51.500
i加加

24:51.500 --> 24:54.500
每一次循环的输出一个路

24:54.500 --> 24:58.500
请问循环多少次

24:58.500 --> 25:00.500
它有提出这样问的

25:00.500 --> 25:02.500
请问循环多少次

25:02.500 --> 25:06.940
a一百次

25:06.940 --> 25:10.940
b九十九次

25:10.940 --> 25:15.760
c爆错

25:15.760 --> 25:18.760
d未知

25:18.760 --> 25:26.180
让你选择abcd

25:26.180 --> 25:27.180
就是面识体

25:27.180 --> 25:28.180
它在考虑数字的时候

25:28.180 --> 25:29.180
它不一定是我刚才说的

25:29.180 --> 25:30.180
一个精度的问题

25:30.180 --> 25:34.180
它可能就连着考察很多体

25:34.180 --> 25:35.180
就看你对数字

25:35.180 --> 25:37.180
有没有深刻的认识

25:37.180 --> 25:38.180
认识深刻了

25:38.180 --> 25:39.180
你啥体都不用怕

25:39.180 --> 25:41.180
认识不深刻你可能值得

25:41.180 --> 25:42.180
老实讲了这道题

25:42.180 --> 25:43.180
你就会说这道题

25:43.180 --> 25:45.180
换一道题就不会了

25:45.180 --> 25:47.180
这道题应该选d

25:47.180 --> 25:49.180
是未知的

25:49.180 --> 25:50.180
它不会爆错

25:50.180 --> 25:52.180
然后我们来运行看一下

25:52.180 --> 25:53.180
它会怎么样呢

25:53.180 --> 25:55.180
它这里已经无限循环了

25:55.180 --> 25:57.180
已经无限循环下去了

25:57.180 --> 25:59.180
我必须要点击右键停止

25:59.180 --> 26:01.180
可能存序不会结束

26:01.180 --> 26:03.180
那么它是为什么呢

26:03.180 --> 26:05.180
这要说到伏点数的存处了

26:05.180 --> 26:09.620
既然是它数字的时候

26:09.620 --> 26:11.620
由于它使用的是伏点数来存处

26:11.620 --> 26:13.620
因此它存处的数字

26:13.620 --> 26:17.900
它会包含三个部分

26:17.900 --> 26:18.900
既然是我们平常说

26:18.900 --> 26:19.900
既然是存数字

26:19.900 --> 26:22.900
是六十四位的伏点数

26:22.900 --> 26:27.340
既然我要解释什么叫六十四位

26:27.340 --> 26:29.340
既然我们数字最终会转成二进字

26:29.340 --> 26:30.340
对吧

26:30.340 --> 26:31.340
转成二进字

26:31.340 --> 26:32.340
一二零一二进去

26:32.340 --> 26:34.340
这样子写法的二进字

26:34.340 --> 26:35.340
最终技术技术里面存的

26:35.340 --> 26:36.340
一定是这种东西

26:36.340 --> 26:39.340
这种东西一共六十四位

26:39.340 --> 26:40.340
那么这六十四位呢

26:40.340 --> 26:42.340
它把它分成三个部分

26:42.340 --> 26:43.340
一个是符号

26:43.340 --> 26:50.160
一个是指数

26:50.160 --> 26:51.160
说小姐

26:51.160 --> 26:52.160
一个是指数

26:52.160 --> 26:54.160
一个是尾数

26:54.160 --> 26:55.160
好那么这个三个部分

26:55.160 --> 26:56.160
它一是吗

26:56.160 --> 26:57.160
我随便举个例子

26:57.160 --> 26:59.160
比方说一个十进字的数字

26:59.160 --> 27:02.160
就随便来吧

27:02.160 --> 27:04.160
二一二三

27:04.160 --> 27:06.160
复的一二三

27:06.160 --> 27:08.160
任何一个十进字的数字

27:08.160 --> 27:10.160
它一定能够把它转换成

27:10.160 --> 27:11.160
这种格式

27:11.160 --> 27:15.470
复一点二三

27:15.470 --> 27:19.470
乘以十的多少次方

27:19.470 --> 27:20.470
几次方呢

27:20.470 --> 27:22.470
是不是平方

27:22.470 --> 27:23.470
对吧

27:23.470 --> 27:24.470
它一定能够把它

27:24.470 --> 27:26.470
转换成这种格式

27:26.470 --> 27:27.470
不能看好啊

27:27.470 --> 27:29.470
这个三个部分就出来了

27:29.470 --> 27:33.470
这个玩意儿就是存的符号

27:33.470 --> 27:38.470
这个玩意儿存的就是指数

27:38.470 --> 27:43.470
这个玩意儿就是尾数

27:43.470 --> 27:44.470
多了意思吧

27:44.470 --> 27:46.470
它是这么去存的

27:46.470 --> 27:47.470
当然存的时候

27:47.470 --> 27:48.470
肯定要转换成二进字

27:48.470 --> 27:49.470
符号的话

27:49.470 --> 27:51.470
就用一位的二进字就可以了

27:51.470 --> 27:52.470
零表示正数

27:52.470 --> 27:54.470
一表示复数

27:54.470 --> 27:58.470
指数是暂时一位

27:58.470 --> 28:01.470
尾数暂五十二位

28:01.470 --> 28:02.470
刚才我们用了什么

28:02.470 --> 28:04.470
二的复五十二次方

28:04.470 --> 28:05.470
对吧

28:05.470 --> 28:07.470
那么是不是困意上了

28:07.470 --> 28:08.470
那么这个尾数

28:08.470 --> 28:09.470
我们单看这个尾数

28:09.470 --> 28:12.470
这个尾数代表着什么呢

28:12.470 --> 28:16.470
它代表着数字的精度

28:16.470 --> 28:17.470
既然是里面

28:17.470 --> 28:18.470
数字可以表示的

28:18.470 --> 28:19.470
数字非常非常大

28:19.470 --> 28:20.470
比方说

28:20.470 --> 28:21.470
看着啊

28:21.470 --> 28:24.470
我要表示一个特别大的数字

28:24.470 --> 28:28.470
能不能表示可以表示

28:28.470 --> 28:32.470
它表示的数字可以很大的

28:32.470 --> 28:33.470
比方说我要表示

28:33.470 --> 28:34.470
一个这么大的数字

28:34.470 --> 28:35.470
能不能表示

28:35.470 --> 28:36.470
绝对能表示一回声

28:36.470 --> 28:37.470
没爆错吗

28:37.470 --> 28:38.470
没出问题吗

28:38.470 --> 28:39.470
它就一起写好了

28:39.470 --> 28:43.470
一乘以十的三十三次方

28:43.470 --> 28:45.470
那我再多一点呢

28:45.470 --> 28:51.540
我数字再大一点呢

28:51.540 --> 28:53.540
一乘以十的六十七次方

28:53.540 --> 28:55.540
没有问题

28:55.540 --> 28:56.540
没有问题

28:56.540 --> 28:57.540
我们既然是能够表示的

28:57.540 --> 28:59.540
最大数字是多少

28:59.540 --> 29:03.620
同学们知道吗

29:03.620 --> 29:04.620
在这里面

29:04.620 --> 29:05.620
叫MaxValue

29:05.620 --> 29:06.620
看一下

29:06.620 --> 29:07.620
做稳的啊

29:07.620 --> 29:11.060
符号做稳的

29:11.060 --> 29:12.060
一点一大堆

29:12.060 --> 29:15.060
乘以十的三百零八次方

29:15.060 --> 29:16.060
你这才拿到哪

29:16.060 --> 29:18.060
它可以表示很大的数字

29:18.060 --> 29:19.060
为什么

29:19.060 --> 29:20.060
它能表示这么大的数字

29:20.060 --> 29:22.060
它怎么装得下的

29:22.060 --> 29:26.430
因为它有指数

29:26.430 --> 29:27.430
是不是

29:27.430 --> 29:28.430
指数代表这一块吗

29:28.430 --> 29:29.430
这块数可以表示很大

29:29.430 --> 29:31.430
因为它有指数啊

29:31.430 --> 29:32.430
说它可以表示的

29:32.430 --> 29:33.430
数字却很大

29:33.430 --> 29:35.430
但是它表示的精度

29:35.430 --> 29:36.430
并没有那么高

29:36.430 --> 29:38.430
因为伪数它有

29:38.430 --> 29:40.430
它占52位

29:40.430 --> 29:41.430
这个伪数

29:41.430 --> 29:42.430
才真正的是精度

29:42.430 --> 29:43.430
什么叫精度啊

29:43.430 --> 29:45.430
再给大家看一个例子

29:45.430 --> 29:46.430
比方说

29:46.430 --> 29:47.430
我们这里面

29:47.430 --> 29:48.430
写的一些数字很大

29:48.430 --> 29:49.430
是吧

29:49.430 --> 29:50.430
数字很大

29:50.430 --> 29:51.430
一回车你会看到

29:51.430 --> 29:53.430
有些数字没了

29:53.430 --> 29:55.430
大小的还是差不多的

29:55.430 --> 29:56.430
等于前面这个

29:56.430 --> 29:58.430
乘以十的33次方

29:58.430 --> 30:00.430
但是有些数字是不是丢失了

30:00.430 --> 30:02.430
这叫精度丢失

30:02.430 --> 30:04.430
因为它纯不下了

30:04.430 --> 30:06.430
这个伪数代表的是精度

30:06.430 --> 30:07.430
它纯不下了

30:07.430 --> 30:08.430
能听懂我的意思吗

30:08.430 --> 30:14.970
能听懂我的意思

30:14.970 --> 30:15.970
我现在跟你讲

30:15.970 --> 30:17.970
非常底层的东西

30:17.970 --> 30:18.970
这些底层的东西

30:18.970 --> 30:19.970
你了解清楚了过

30:19.970 --> 30:20.970
这种蝴蝶

30:20.970 --> 30:22.970
这一题跟我而已

30:22.970 --> 30:24.970
好

30:24.970 --> 30:25.970
那么既然伪数

30:25.970 --> 30:27.970
伪数纯的是这个部分

30:27.970 --> 30:29.970
它不包含前面那个

30:29.970 --> 30:31.970
为什么不包含前面那个呢

30:31.970 --> 30:35.970
是因为它转换成2进制之后

30:35.970 --> 30:37.970
最高位一定是1

30:37.970 --> 30:38.970
这个能理解吗

30:38.970 --> 30:40.970
任何一个十进制数

30:40.970 --> 30:42.970
转换成2进制之后

30:42.970 --> 30:45.970
最高位一定是1

30:45.970 --> 30:46.970
不像十进制

30:46.970 --> 30:47.970
十进制的话

30:47.970 --> 30:49.970
最高位可能是1

30:49.970 --> 30:50.970
可能是2

30:50.970 --> 30:51.970
可能是3

30:51.970 --> 30:52.970
可能是4

30:52.970 --> 30:53.970
1到9

30:53.970 --> 30:54.970
但是由于是2进制

30:54.970 --> 30:56.970
最高位是不是只能是1

30:56.970 --> 30:58.970
它没意义啊

30:58.970 --> 31:00.970
您的话就可以扔掉了

31:00.970 --> 31:02.970
可以不用作为最高位了

31:02.970 --> 31:05.970
最高位它一定是1

31:05.970 --> 31:08.970
所以在纯这个伪数的时候

31:08.970 --> 31:10.970
它会忽略掉最高位

31:10.970 --> 31:11.970
它可以少存1位

31:11.970 --> 31:13.970
这样的话精度更高

31:13.970 --> 31:14.970
伪数就这一部分

31:14.970 --> 31:15.970
它能存多少

31:15.970 --> 31:20.920
能存52位的2进制

31:20.920 --> 31:22.920
那么加上前面的1

31:22.920 --> 31:24.920
是不是刚好是53位

31:24.920 --> 31:26.920
就这个伪数部分

31:26.920 --> 31:28.920
是不是刚好就是

31:28.920 --> 31:29.920
53位了

31:29.920 --> 31:30.920
加上前面的1

31:30.920 --> 31:33.920
这就是GS的最高精度

31:33.920 --> 31:35.920
精度就只能这么多了

31:35.920 --> 31:37.920
53位

31:37.920 --> 31:38.920
53位的2进制

31:38.920 --> 31:42.920
那么现在我们思考一个问题

31:42.920 --> 31:44.920
第一个问题

31:44.920 --> 31:48.920
这53位的2进制

31:48.920 --> 31:53.450
最大是多少

31:53.450 --> 31:55.450
是多少

31:55.450 --> 31:56.450
这很简单吗

31:56.450 --> 31:58.450
53位的2进制最大是多少

31:58.450 --> 31:59.450
就全部为1

31:59.450 --> 32:01.450
就是写53个1不就完了吗

32:01.450 --> 32:03.450
不就最大了吗

32:03.450 --> 32:05.450
如果用这53个1

32:05.450 --> 32:07.450
表达一个整数的话

32:07.450 --> 32:10.450
那么整数的值是多少呢

32:10.450 --> 32:17.450
就是2的53次方减1

32:17.450 --> 32:18.450
就是这个整数的值

32:18.450 --> 32:20.450
就是伪数部分全部为1

32:20.450 --> 32:22.450
那就得到了整数

32:22.450 --> 32:24.450
就是一个2的53次方减1

32:24.450 --> 32:28.460
看一下这个数字是多少

32:28.460 --> 32:32.890
就这个值

32:32.890 --> 32:33.890
这个值呢

32:33.890 --> 32:35.890
在我们的number的构造函数里边

32:35.890 --> 32:38.890
还有一个属性叫做maxsafe integer

32:38.890 --> 32:39.890
来读一下

32:39.890 --> 32:42.890
max最大的safe

32:42.890 --> 32:45.890
安全的integer整数

32:45.890 --> 32:48.890
这些东西你们平时都很少接触到的

32:48.890 --> 32:49.890
但是只要遇到大数字

32:49.890 --> 32:50.890
你没有接触到这些东西

32:50.890 --> 32:51.890
一定出问题

32:51.890 --> 32:54.890
什么时候会有遇到大数字

32:54.890 --> 32:55.890
只要取决你们后端

32:55.890 --> 32:57.890
你们以后开发都是跟后端

32:57.890 --> 32:58.890
协助配合的

32:58.890 --> 32:59.890
有的时候后端

32:59.890 --> 33:01.890
它就会给你一个很大的数字

33:01.890 --> 33:02.890
你这一块处理不好的话

33:02.890 --> 33:04.890
就要出问题

33:04.890 --> 33:06.890
这叫最大安全整数

33:06.890 --> 33:08.890
为什么叫安全整数呢

33:08.890 --> 33:10.890
你想这个道理

33:10.890 --> 33:12.890
伪数部分都全部为1的

33:12.890 --> 33:14.890
还能比这更大吗

33:14.890 --> 33:16.890
再大的话是不是要进位了

33:16.890 --> 33:17.890
这一进位

33:17.890 --> 33:18.890
它的位数是不是要增加

33:18.890 --> 33:20.890
一增加是不是导致

33:20.890 --> 33:21.890
装不下了

33:21.890 --> 33:22.890
装不下是不是要导致丢失

33:22.890 --> 33:24.890
就有可能会导致丢失

33:24.890 --> 33:25.890
这已经都这么大了

33:25.890 --> 33:26.890
没有办法增加了

33:26.890 --> 33:30.890
你要说前面52个0

33:30.890 --> 33:32.890
后面有一个0

33:32.890 --> 33:34.890
到还可以增加一位

33:34.890 --> 33:35.890
但是已经到这种程度了

33:35.890 --> 33:36.890
再加1的话

33:36.890 --> 33:38.890
那是不是要多一位出来了

33:38.890 --> 33:39.890
多一位装不下干嘛

33:39.890 --> 33:40.890
扔掉

33:40.890 --> 33:42.890
如果说扔掉的是0还好说

33:42.890 --> 33:43.890
没有导致精度丢失

33:43.890 --> 33:45.890
但是如果说扔掉的是1

33:45.890 --> 33:46.890
1给你扔掉了

33:46.890 --> 33:48.890
是不是导致精度丢失了

33:48.890 --> 33:51.890
那么就看一下这道题

33:51.890 --> 33:53.890
再回来过来看一下这道题

33:53.890 --> 33:58.520
这道题我们需要一点解释里边

33:58.520 --> 34:05.260
这道题它怎么回事呢

34:05.260 --> 34:07.260
它为什么会死循环呢

34:07.260 --> 34:09.260
因为这个STARS的值

34:09.260 --> 34:12.260
它已经超过了最大安全整数了

34:12.260 --> 34:14.260
已经超过了

34:14.260 --> 34:16.260
在这个最大安全整数上

34:16.260 --> 34:18.260
在进行运算

34:18.260 --> 34:19.260
然后我都不清楚

34:19.260 --> 34:20.260
它的精度有没有丢失了

34:20.260 --> 34:21.260
我搞不清楚

34:21.260 --> 34:22.260
有可能丢失了

34:22.260 --> 34:23.260
有可能没有丢失

34:23.260 --> 34:24.260
但是在这里

34:24.260 --> 34:26.260
它一定会有丢失精度

34:26.260 --> 34:27.260
为什么

34:27.260 --> 34:29.260
因为I是从这个值开始的

34:29.260 --> 34:31.260
然后I加加加1加2加3

34:31.260 --> 34:33.260
我就不信加100加到100

34:33.260 --> 34:34.260
它还没有精度丢失

34:34.260 --> 34:36.260
一定没有某一个房间精度丢失了

34:36.260 --> 34:38.260
然后造成一个什么问题呢

34:38.260 --> 34:41.090
给大家看一下

34:41.090 --> 34:42.090
你看这个值

34:42.090 --> 34:43.090
跟这个值是不是一样的

34:43.090 --> 34:45.090
就是这个值

34:45.090 --> 34:48.090
我用它加1

34:48.090 --> 34:50.090
加1有没有精度丢失

34:50.090 --> 34:51.090
加1没有

34:51.090 --> 34:52.090
为什么没有呢

34:52.090 --> 34:53.090
你想那个道理

34:53.090 --> 34:54.090
前面有多少

34:54.090 --> 34:56.090
53个1

34:56.090 --> 34:58.090
对吧53个1

34:58.090 --> 34:59.090
不行了

34:59.090 --> 35:00.090
然后加了一个1

35:00.090 --> 35:01.090
变成了什么

35:01.090 --> 35:03.090
变成了第1位为1

35:03.090 --> 35:04.090
后边有多少

35:04.090 --> 35:05.090
53个0

35:05.090 --> 35:07.090
是不是一共有54位

35:07.090 --> 35:08.090
就多了一位

35:08.090 --> 35:09.090
多了一位0

35:09.090 --> 35:10.090
扔掉了

35:10.090 --> 35:11.090
扔掉的是谁

35:11.090 --> 35:12.090
扔掉的是0

35:12.090 --> 35:13.090
所以说加1

35:13.090 --> 35:15.090
加1的时候都还没有精度丢失

35:15.090 --> 35:16.090
你看

35:16.090 --> 35:17.090
还能够正确显示

35:17.090 --> 35:18.090
那加2呢

35:18.090 --> 35:20.090
就出问题了

35:20.090 --> 35:22.090
这个玩意要去加2

35:22.090 --> 35:24.090
那么是不是最后一位为1

35:24.090 --> 35:25.090
1被丢掉了

35:25.090 --> 35:27.090
所以说你去看一下加2

35:28.090 --> 35:30.090
这里又出现一道面试题

35:30.090 --> 35:31.090
这个面试题是这么问你的

35:31.090 --> 35:33.090
他问你这个表达是

35:33.090 --> 35:34.090
你看这种题

35:34.090 --> 35:35.090
他可以换找花样来考你

35:35.090 --> 35:37.090
你只搞懂一个题是真的不够

35:37.090 --> 35:39.090
他问你加1跟加2

35:39.090 --> 35:40.090
是不是一样的

35:40.090 --> 35:42.090
它一样的

35:42.090 --> 35:44.090
去

35:44.090 --> 35:46.090
什么神奇

35:46.090 --> 35:48.090
就是这些原因导致的

35:48.090 --> 35:50.090
懂了意思吗

35:50.090 --> 35:51.090
所以呢

35:51.090 --> 35:53.090
为什么这道题会死军环

35:53.090 --> 35:55.090
就说还是从这个值开始的

35:55.090 --> 35:56.090
然后一加加

35:56.090 --> 35:57.090
一加加

35:57.090 --> 35:58.090
你看你跟加1加2

35:58.090 --> 35:59.090
是不是一样的

35:59.090 --> 36:00.090
上不去了

36:00.090 --> 36:01.090
永远都在那个值跑了

36:01.090 --> 36:03.090
上不去了

36:03.090 --> 36:05.090
所以就相当于是这样子的

36:05.090 --> 36:06.090
比方说那个i

36:06.090 --> 36:07.090
等于什么

36:07.090 --> 36:08.090
等于那个number

36:08.090 --> 36:10.090
max safe integer

36:10.090 --> 36:11.090
加1对吧

36:11.090 --> 36:12.090
2.53是吗

36:12.090 --> 36:13.090
i的值是多少

36:13.090 --> 36:15.090
i加加

36:15.090 --> 36:16.090
还是这个值

36:16.090 --> 36:17.090
i加加

36:17.090 --> 36:18.090
还是这个值

36:18.090 --> 36:19.090
i加加

36:19.090 --> 36:20.090
还是这个值

36:20.090 --> 36:21.090
这道题他其实没有考得很深

36:21.090 --> 36:22.090
他要考得很深的话

36:22.090 --> 36:23.090
他就没有那个d

36:23.090 --> 36:24.090
那个选项

36:24.090 --> 36:25.090
他d

36:25.090 --> 36:27.090
他就是无限循环

36:27.090 --> 36:28.090
他d要选项

36:28.090 --> 36:29.090
就不是未知的

36:29.090 --> 36:30.090
他就是无限循环

36:30.090 --> 36:31.090
那就考得很深了

36:31.090 --> 36:32.090
那你要去自己算

36:32.090 --> 36:33.090
算一下那个二进之

36:33.090 --> 36:34.090
是不是这个样子

36:34.090 --> 36:35.090
算出来的话

36:35.090 --> 36:36.090
就是无限循环

36:36.090 --> 36:37.090
懂了意思吗

36:37.090 --> 36:38.090
这个问题

36:38.090 --> 36:40.090
我们总算是把搞清楚了

36:40.090 --> 36:41.090
然后再回报

36:41.090 --> 36:43.090
刚才一个问题

36:43.090 --> 36:44.090
这个玩意

36:44.090 --> 36:45.090
为什么是2的

36:45.090 --> 36:47.090
副5是2四方

36:47.090 --> 36:48.090
就刚好是最小精度

36:48.090 --> 36:50.090
那现在就好解释了

36:50.090 --> 36:51.090
为数多少呢

36:51.090 --> 36:53.090
你刚说为数多少位

36:53.090 --> 36:55.090
为数52位

36:55.090 --> 36:56.090
对吧

36:56.090 --> 36:57.090
最大的数字

36:57.090 --> 36:58.090
我们可以知道了

36:58.090 --> 36:59.090
加上前面那个1

36:59.090 --> 37:00.090
就是53位对吧

37:00.090 --> 37:01.090
但是为数部分

37:01.090 --> 37:02.090
它只占52位

37:02.090 --> 37:04.090
那它最小的数是多少

37:04.090 --> 37:06.090
最小的数

37:06.090 --> 37:08.090
全面全部为0

37:08.090 --> 37:10.090
后面是不是有一个1

37:10.090 --> 37:12.090
但是0是最小的数

37:12.090 --> 37:14.090
但是0代表不了差距

37:14.090 --> 37:16.090
就是从0到1

37:16.090 --> 37:18.090
再多一点点

37:18.090 --> 37:20.090
那多了一点点是多少

37:20.090 --> 37:21.090
那就多这个

37:21.090 --> 37:23.090
不能比这更小了

37:23.090 --> 37:25.090
不能比这更小了

37:25.090 --> 37:27.090
那么这个数是多少呢

37:27.090 --> 37:29.090
这个数

37:29.090 --> 37:31.090
这是一个2的精致

37:31.090 --> 37:33.090
它是52位的

37:33.090 --> 37:34.090
那也说我们要算的是

37:34.090 --> 37:35.090
0点

37:35.090 --> 37:36.090
前面有50

37:36.090 --> 37:39.090
这里有52个0

37:39.090 --> 37:40.090
这里有52个0

37:40.090 --> 37:42.090
那么这个位置

37:42.090 --> 37:43.090
一共有52位

37:43.090 --> 37:45.090
那就是2的

37:45.090 --> 37:49.400
副2的

37:49.400 --> 37:51.400
副5是12四方

37:51.400 --> 37:53.400
这个是怎么出来的

37:53.400 --> 37:55.400
就要涉及到另外一个字

37:57.400 --> 37:58.400
你们知道2精致

37:58.400 --> 38:00.400
是怎么算成使劲字的吗

38:00.400 --> 38:01.400
一个2精致的小数

38:01.400 --> 38:03.400
刚才我们说使劲字小数

38:03.400 --> 38:05.400
使劲字数字怎么算成2精致

38:05.400 --> 38:06.400
那2精致的小数

38:06.400 --> 38:07.400
它怎么算成使劲字

38:07.400 --> 38:09.400
知道吗

38:09.400 --> 38:10.400
这是个2精致的小数

38:10.400 --> 38:11.400
带走数带小数

38:11.400 --> 38:15.740
它是这样算的

38:15.740 --> 38:21.390
1乘以2的

38:21.390 --> 38:22.390
2四方

38:22.390 --> 38:23.390
1四方

38:23.390 --> 38:26.390
加上1乘以2的

38:26.390 --> 38:28.390
0四方

38:28.390 --> 38:29.390
就跟那个

38:29.390 --> 38:30.390
我们使劲字算的

38:30.390 --> 38:32.390
算法是一样的

38:32.390 --> 38:34.390
使劲字是怎么算的

38:34.390 --> 38:36.390
比方说

38:36.390 --> 38:38.390
32点

38:38.390 --> 38:39.390
12点345

38:39.390 --> 38:40.390
比方这个使劲字

38:40.390 --> 38:41.390
它怎么算的

38:41.390 --> 38:43.390
把展开的话

38:43.390 --> 38:44.390
用科学技术

38:44.390 --> 38:45.390
把展开的话

38:45.390 --> 38:46.390
1乘以10的

38:46.390 --> 38:47.390
多少次方

38:47.390 --> 38:48.390
2四方

38:48.390 --> 38:49.390
加上2乘以10的

38:49.390 --> 38:51.390
多少次方

38:51.390 --> 38:52.390
这个是1四方

38:52.390 --> 38:54.390
加上10的0四方

38:54.390 --> 38:55.390
再加上是吧

38:55.390 --> 38:57.390
2乘以10的

38:57.390 --> 38:58.390
多少

38:58.390 --> 38:59.390
-1四方

38:59.390 --> 39:00.390
再加上

39:00.390 --> 39:02.390
2乘以10的

39:02.390 --> 39:03.390
多少

39:03.390 --> 39:04.390
-2四方

39:04.390 --> 39:08.150
3

39:08.150 --> 39:09.150
这是3

39:09.150 --> 39:10.150
3

39:10.150 --> 39:11.150
4乘以10的

39:11.150 --> 39:12.150
-2四方

39:12.150 --> 39:13.150
再加上

39:13.150 --> 39:15.150
5乘以10的

39:15.150 --> 39:16.150
-3四方

39:16.150 --> 39:17.150
那这里是一样的

39:17.150 --> 39:18.150
只不过把10

39:18.150 --> 39:19.150
变成2

39:19.150 --> 39:20.150
所以说

39:20.150 --> 39:21.150
这个位置

39:21.150 --> 39:22.150
它就是乘以

39:22.150 --> 39:23.150
2的

39:23.150 --> 39:24.150
-1

39:24.150 --> 39:25.150
-3

39:25.150 --> 39:26.150
-3四方

39:26.150 --> 39:27.150
这是乘以2的

39:27.150 --> 39:28.150
-4四方

39:28.150 --> 39:29.150
所以说前面

39:29.150 --> 39:30.150
那个一大堆0

39:32.150 --> 39:33.150
这个东西了解就行了

39:33.150 --> 39:34.150
一大堆0

39:34.150 --> 39:35.150
52个0

39:35.150 --> 39:36.150
51个0

39:36.150 --> 39:37.150
后面跟个1

39:37.150 --> 39:39.150
那个1是在第52位

39:39.150 --> 39:40.150
对吧

39:40.150 --> 39:41.150
小数点后面第52位

39:41.150 --> 39:42.150
除了这个1

39:42.150 --> 39:43.150
它的结果就是

39:43.150 --> 39:44.150
2乘以

39:44.150 --> 39:48.300
2的多少次方

39:48.300 --> 39:49.300
-52次方

39:49.300 --> 39:50.300
那么这个

39:50.300 --> 39:51.300
这个最小精度

39:51.300 --> 39:52.300
就是这么来的

39:52.300 --> 39:54.300
看懂了吗

39:54.300 --> 39:55.300
你看着简单的体背后

39:55.300 --> 39:58.300
还有很多身号的东西

39:58.300 --> 39:59.300
这个玩意儿

39:59.300 --> 40:00.300
其实在囊板里面

40:00.300 --> 40:02.300
也有相应的属性

40:02.300 --> 40:04.300
囊板里面有个属性

40:04.300 --> 40:05.300
叫做

40:05.300 --> 40:08.500
怎么度的

40:08.500 --> 40:09.500
Epsom

40:10.500 --> 40:11.500
这个属性

40:11.500 --> 40:12.500
你看

40:12.500 --> 40:13.500
这个只跟那个2

40:13.500 --> 40:14.500
-2

40:14.500 --> 40:15.500
-4的52次方

40:15.500 --> 40:16.500
是不是只是一样的

40:16.500 --> 40:17.500
对吧

40:17.500 --> 40:18.500
这就是介石的最小精度

40:18.500 --> 40:19.500
当然

40:19.500 --> 40:20.500
你可以直接用这个属性

40:20.500 --> 40:21.500
玩意儿

40:21.500 --> 40:22.500
就没有那么多麻烦

40:22.500 --> 40:23.500
所以说我们这里

40:23.500 --> 40:24.500
最后的写法

40:24.500 --> 40:25.500
是把这个玩意儿

40:25.500 --> 40:26.500
写成那个属性

40:26.500 --> 40:27.500
囊板

40:33.500 --> 40:34.500
好

40:34.500 --> 40:35.500
第一体完成

40:41.520 --> 40:43.520
我希望通过第一体

40:43.520 --> 40:44.520
能够解决

40:44.520 --> 40:45.520
同学们

40:45.520 --> 40:46.520
对于小数这一块

40:46.520 --> 40:48.520
所有面试体的疑惑

40:48.520 --> 40:49.520
以后遇到这种

40:49.520 --> 40:50.520
小数音双的面试体

40:50.520 --> 40:51.520
都能搞定的

40:51.520 --> 40:52.520
而不是

40:52.520 --> 40:55.520
单单能搞定这一种体

40:55.520 --> 40:56.520
第二体

40:56.520 --> 40:59.020
第二体就是

40:59.020 --> 41:02.020
特别少脑袋的体

41:02.020 --> 41:04.020
你看有些简单的东西背后

41:04.020 --> 41:06.020
它真的是内有乾坤

41:06.020 --> 41:08.020
第二体

41:08.020 --> 41:11.020
考察的好像是什么值和引用

41:11.020 --> 41:14.020
而实际上的考察的是

41:14.020 --> 41:15.020
预算符

41:15.020 --> 41:17.020
以后没把预算符搞清楚

41:17.020 --> 41:18.020
就预算符

41:18.020 --> 41:19.020
还有什么好清楚的

41:19.020 --> 41:20.020
很简单

41:20.020 --> 41:21.020
加炼成符

41:21.020 --> 41:22.020
互职

41:22.020 --> 41:23.020
有的时候

41:23.020 --> 41:24.020
一些莫名其妙的写法

41:24.020 --> 41:25.020
就出来搞理

41:25.020 --> 41:26.020
哎呀

41:26.020 --> 41:27.020
这个玩意儿没啥意义

41:27.020 --> 41:28.020
没啥意义

41:28.020 --> 41:31.020
平时开发也不会这样写

41:31.020 --> 41:32.020
你说的很好

41:32.020 --> 41:33.020
首先你说的很好

41:33.020 --> 41:35.020
但是你要去对企业说

41:35.020 --> 41:36.020
不要对我说

41:36.020 --> 41:37.020
其他要考

41:37.020 --> 41:38.020
第二

41:38.020 --> 41:39.020
它其实考这个玩意儿

41:39.020 --> 41:41.020
其实有一定道理的

41:41.020 --> 41:42.020
它考虑什么

41:42.020 --> 41:43.020
基本功劳不劳

41:43.020 --> 41:44.020
你以后写代码

41:44.020 --> 41:46.020
确实不会这样写

41:46.020 --> 41:47.020
但是呢

41:47.020 --> 41:49.020
它要用什么办法

41:49.020 --> 41:51.020
才能在短时间里边

41:51.020 --> 41:52.020
能够考察到一个基础

41:52.020 --> 41:53.020
掌握的劳不劳呢

41:53.020 --> 41:55.020
只有这种怪体

41:55.020 --> 41:56.020
你这种怪体都能搞定

41:56.020 --> 41:57.020
那你说明技术

41:57.020 --> 41:58.020
肯定是没问题的

41:58.020 --> 41:59.020
搞定那些常规操作

41:59.020 --> 42:00.020
肯定是没问题的

42:00.020 --> 42:02.020
偶尔遇到一些比较乖

42:02.020 --> 42:04.020
因为我们以后开发

42:04.020 --> 42:05.020
肯定有机会

42:05.020 --> 42:07.020
会遇到很多乖的长期

42:07.020 --> 42:09.020
那么遇到一些乖的长期

42:09.020 --> 42:12.020
你是能够根据已有的知识

42:12.020 --> 42:13.020
发挥自己的能力

42:13.020 --> 42:15.020
去搞定的

42:15.020 --> 42:16.020
他说考的时候

42:16.020 --> 42:17.020
他一定考乖的

42:17.020 --> 42:18.020
普通设计

42:18.020 --> 42:19.020
大家都会搞定

42:19.020 --> 42:21.020
好 来看一下这道题吧

42:21.020 --> 42:22.020
这道题呢

42:22.020 --> 42:27.580
我做了一个PPT

42:27.580 --> 42:29.890
其实也不会

42:30.890 --> 42:31.890
在说没啥吧

42:40.080 --> 42:42.080
最多的结果是

42:42.080 --> 42:43.080
undefend

42:43.080 --> 42:45.080
a.x是undefend

42:45.080 --> 42:47.080
b.x是一个对象

42:47.080 --> 42:48.080
n等于2

42:48.080 --> 42:50.080
那怎么回事呢

42:50.080 --> 42:53.080
你要搞清楚是怎么复职的

42:53.080 --> 42:55.080
复职是怎么复职的呢

42:55.080 --> 42:56.080
原来说是把右边

42:56.080 --> 42:59.080
刷出来往左边写

42:59.080 --> 43:00.080
大部分情况

43:00.080 --> 43:02.080
这样说是没问题的

43:02.080 --> 43:03.080
但是像这道题里面

43:03.080 --> 43:06.080
你不能用这种模糊的说法

43:06.080 --> 43:07.080
复职运算

43:07.080 --> 43:11.080
它仍然是从左到右运算的

43:11.080 --> 43:13.080
只多了运算完了过后

43:13.080 --> 43:16.080
它要把右边的值往左边写

43:16.080 --> 43:17.080
它看的时候

43:17.080 --> 43:20.080
还是要从左 从左到右看

43:20.080 --> 43:21.080
所以第一步找的是谁

43:21.080 --> 43:22.080
找的是左边那个

43:22.080 --> 43:24.080
边量a的内存地址

43:24.080 --> 43:27.520
准备复职

43:27.520 --> 43:28.520
比方说a

43:28.520 --> 43:30.520
里面有个内存地址

43:30.520 --> 43:32.520
随便写个内存地址

43:32.520 --> 43:33.520
意思就行了

43:33.520 --> 43:35.520
准备好内存地址

43:35.520 --> 43:36.520
准备好了

43:36.520 --> 43:37.520
第二步算右边的

43:37.520 --> 43:39.520
因为我这个比较简单

43:39.520 --> 43:41.520
右边就只有一个字面量1

43:41.520 --> 43:42.520
它其实右边

43:42.520 --> 43:43.520
可能是一个表达式

43:43.520 --> 43:44.520
可能是一个函数调用

43:44.520 --> 43:45.520
反正也要够算出来

43:45.520 --> 43:48.520
好 算完了之后呢

43:48.520 --> 43:50.520
再把右边的东西放到

43:50.520 --> 43:52.520
之前准备好的内存地址

43:52.520 --> 43:53.520
立板区

43:53.520 --> 43:55.520
把大象装冰箱

43:55.520 --> 43:56.520
总共赔几步啊

43:56.520 --> 43:57.520
分三步对吧

43:57.520 --> 43:58.520
冰箱门打开

43:58.520 --> 43:59.520
来过来吧

43:59.520 --> 44:00.520
那大象扔进去

44:00.520 --> 44:01.520
冰箱门关上

44:01.520 --> 44:03.520
就有点这个意思放进去

44:03.520 --> 44:05.520
然后第四步

44:05.520 --> 44:08.520
复职是一个表达式

44:08.520 --> 44:09.520
同学们

44:09.520 --> 44:12.520
复职是一个表达式

44:12.520 --> 44:15.520
这个表达式也会有一个结果

44:15.520 --> 44:16.520
我现在就特别担心

44:16.520 --> 44:18.520
同学们表达式那一块

44:18.520 --> 44:22.090
还没有搞清楚

44:22.090 --> 44:23.090
很多人都知道1加1

44:23.090 --> 44:24.090
是一个表达式

44:24.090 --> 44:27.720
它有个结果是2

44:27.720 --> 44:28.720
2×3是一个表达式

44:28.720 --> 44:30.720
它的结果是6

44:30.720 --> 44:32.720
2×3加上1

44:32.720 --> 44:33.720
它也是个表达式

44:33.720 --> 44:37.420
它的结果是7

44:37.420 --> 44:39.420
但是很多人对表达式的理解

44:39.420 --> 44:41.420
也到此结束了

44:41.420 --> 44:42.420
认为表达式

44:42.420 --> 44:43.420
只有这个数学运算

44:43.420 --> 44:44.420
还是表达式

44:44.420 --> 44:45.420
不是

44:45.420 --> 44:47.420
只叫你包含了运算幅

44:47.420 --> 44:49.420
所有东西都是表达式

44:49.420 --> 44:51.420
所有东西

44:51.420 --> 44:52.420
包括那个复职

44:52.420 --> 44:54.420
复职是不是运算幅

44:54.420 --> 44:55.420
你们学运算幅都学过吗

44:55.420 --> 44:57.420
复职肯定是个运算幅嘛

44:57.420 --> 44:58.420
那复职

44:58.420 --> 45:00.420
它就是个表达式

45:00.420 --> 45:01.420
你看

45:01.420 --> 45:02.420
在谷歌浏览器里边

45:02.420 --> 45:03.420
当你写一个表达式的时候

45:03.420 --> 45:04.420
它会告诉你

45:04.420 --> 45:06.420
这个表达式有个结果

45:06.420 --> 45:08.420
你看这个表达式的结果是哪

45:08.420 --> 45:10.420
这个表达式的结果

45:10.420 --> 45:11.420
不就是2嘛

45:11.420 --> 45:12.420
对吧

45:12.420 --> 45:13.420
就是复职符号

45:13.420 --> 45:15.420
右边算出来的结果

45:15.420 --> 45:17.420
就是2

45:18.420 --> 45:19.420
好

45:19.420 --> 45:20.420
这是

45:20.420 --> 45:22.420
在谷歌浏览器里边

45:22.420 --> 45:24.420
第四步

45:24.420 --> 45:26.420
就得到整个表达式的词

45:27.420 --> 45:28.420
好

45:28.420 --> 45:29.420
我们知道一个复职

45:29.420 --> 45:30.420
它是要分成这四个步骤

45:30.420 --> 45:31.420
来完成的

45:31.420 --> 45:32.420
然后我们在谷歌浏览器里边

45:32.420 --> 45:34.420
首先前两步

45:34.420 --> 45:35.420
这要考察你

45:35.420 --> 45:37.420
这个你没什么好考察的

45:37.420 --> 45:39.420
这要考察你那个职合引用

45:39.420 --> 45:40.420
在这个网上考察职合引用

45:40.420 --> 45:42.420
肯定不能这样考察

45:42.420 --> 45:43.420
这考察没什么意义

45:43.420 --> 45:44.420
因为这个太简单了

45:44.420 --> 45:46.420
如果说你对这个职合引用

45:46.420 --> 45:49.420
这一块有问题的话

45:49.420 --> 45:51.420
那也好好把基础的抓

45:51.420 --> 45:53.420
基础的课程抓一抓

45:53.420 --> 45:55.420
这个玩意我就不摊开讲了

45:55.420 --> 45:56.420
因为讲职合引用了

45:56.420 --> 45:58.420
二十一堆的时间去了

45:58.420 --> 45:59.420
好那么就得到两个变量

45:59.420 --> 46:00.420
A和B

46:00.420 --> 46:01.420
A的内存空间里边存了一个地址

46:01.420 --> 46:02.420
然后指向一个对象

46:02.420 --> 46:04.420
对象里边一个N和B

46:04.420 --> 46:06.420
然后B跟A的地址是一样的

46:06.420 --> 46:08.420
所以也指向了对象

46:08.420 --> 46:09.420
就形成那么一个内存结构了

46:09.420 --> 46:11.420
关键看下一步

46:11.420 --> 46:14.420
下一步你得怎么看呢

46:14.420 --> 46:16.420
你要这样看

46:16.420 --> 46:17.420
复制的吗

46:17.420 --> 46:19.420
左边一块右边一块吗

46:19.420 --> 46:21.420
复制怎么算的

46:21.420 --> 46:23.420
第一步找到这个A点

46:23.420 --> 46:24.420
A个4

46:24.420 --> 46:25.420
找到这个地址

46:25.420 --> 46:26.420
冰箱门打开

46:26.420 --> 46:28.420
这个地址在哪

46:28.420 --> 46:29.420
A是啥

46:29.420 --> 46:30.420
A是不是个对象

46:30.420 --> 46:32.420
这个对象有没有一个X属性

46:32.420 --> 46:33.420
没有

46:33.420 --> 46:35.420
没有怎么办呢

46:35.420 --> 46:37.420
既然是没属性还不好说吗

46:37.420 --> 46:38.420
还不好说的

46:38.420 --> 46:40.420
夹一个属性没

46:40.420 --> 46:42.420
这个地址是不是出来了

46:42.420 --> 46:44.420
这个X的地址是不是出来了

46:44.420 --> 46:46.420
只问里边没放的东西

46:46.420 --> 46:48.420
然后算右边

46:48.420 --> 46:49.420
把右边一算出来

46:49.420 --> 46:50.420
往这个冰箱一扔

46:50.420 --> 46:52.420
是不是完事了

46:52.420 --> 46:54.420
那么我们要算右边

46:54.420 --> 46:55.420
右边是个啥

46:55.420 --> 46:57.420
是不是又是一个复制表达式

46:57.420 --> 46:59.420
那又来1234

46:59.420 --> 47:00.420
第一步干嘛

47:00.420 --> 47:02.420
第一步找到A的地址

47:02.420 --> 47:03.420
A的地址是啥

47:03.420 --> 47:04.420
是不是这个玩意

47:04.420 --> 47:06.420
看那个方档了没有

47:06.420 --> 47:08.420
这个冰箱门又打开了

47:08.420 --> 47:10.420
然后算右边

47:10.420 --> 47:11.420
右边是啥

47:11.420 --> 47:12.420
新创建一个对象

47:12.420 --> 47:14.420
N等于2

47:14.420 --> 47:16.420
然后第三步是啥

47:16.420 --> 47:18.420
把大象装进去

47:18.420 --> 47:20.420
把A的地址改变了

47:20.420 --> 47:22.420
只像这个新的对象了

47:22.420 --> 47:24.420
第四步是啥

47:24.420 --> 47:27.420
整个表达式的结果

47:27.420 --> 47:31.730
就是那个对象

47:31.730 --> 47:33.730
对象的地址

47:33.730 --> 47:34.730
不就是这个复制符号

47:34.730 --> 47:35.730
右边那个东西吗

47:35.730 --> 47:36.730
刚才我演示过了

47:36.730 --> 47:37.730
A等于2

47:37.730 --> 47:38.730
整个表达式的结果

47:38.730 --> 47:39.730
不就是这个2吗

47:39.730 --> 47:40.730
N等于N

47:40.730 --> 47:41.730
N等于一个对象

47:41.730 --> 47:42.730
能够对象的地址

47:42.730 --> 47:44.730
不就是那个整个表达式的结果吗

47:44.730 --> 47:46.730
然后把整个表达式的结果

47:46.730 --> 47:48.730
复制给之前

47:48.730 --> 47:50.730
准备好那个冰箱

47:50.730 --> 47:54.300
那个X看到没有一个红色的

47:54.300 --> 47:56.300
之前等着了等了很久了

47:56.300 --> 47:58.300
就等于把大象扔进去了

47:58.300 --> 48:00.300
那大象不就是个对象吗

48:00.300 --> 48:01.300
对象放进去

48:01.300 --> 48:02.300
就是它的地址

48:02.300 --> 48:03.300
也只像一个对象

48:03.300 --> 48:04.300
所以最终出来的内存结构

48:04.300 --> 48:05.300
就是这个结构

48:05.300 --> 48:06.300
根据这个内存结构

48:06.300 --> 48:08.300
你再看那个图

48:08.300 --> 48:10.300
A点X是多少

48:10.300 --> 48:11.300
D算的吗

48:11.300 --> 48:12.300
你看那个图

48:12.300 --> 48:14.300
B点X是多少

48:14.300 --> 48:16.300
是不是一个对象

48:16.300 --> 48:19.300
就解释清楚了

48:19.300 --> 48:20.300
这道题看上去

48:20.300 --> 48:21.300
是在考虑职合引用

48:21.300 --> 48:23.300
实际上考虑的是

48:23.300 --> 48:25.300
复制运算

48:25.300 --> 48:27.300
是在运算

48:27.300 --> 48:28.300
实际上考虑职合引用

48:28.300 --> 48:32.120
不可能考这么简单

48:32.120 --> 48:34.120
第二道题

48:34.120 --> 48:37.500
第二道题能理解吗

48:37.500 --> 48:39.500
第二道题在网上看到很多的

48:39.500 --> 48:42.500
那种就是解析

48:42.500 --> 48:43.500
有些是有问题的

48:43.500 --> 48:45.500
有些是解析的是对的

48:45.500 --> 48:47.500
但是解释要对的

48:47.500 --> 48:49.500
往往说不太容易懂

48:49.500 --> 48:54.470
因为我画了个图

48:54.470 --> 48:56.780
第三题

48:56.780 --> 48:58.780
第三题又是考虑算符的

48:58.780 --> 49:00.780
我们这一次集讯

49:00.780 --> 49:01.780
讲的就是那种点

49:01.780 --> 49:02.780
单独的点

49:02.780 --> 49:03.780
然后拿出来

49:03.780 --> 49:04.780
就这么点知识

49:04.780 --> 49:05.780
一看我一节合

49:05.780 --> 49:06.780
可以讲好几个

49:06.780 --> 49:07.780
它没有成练

49:07.780 --> 49:08.780
但是那种点的

49:08.780 --> 49:09.780
它比较多

49:09.780 --> 49:11.780
数量多的杂牌群

49:11.780 --> 49:14.780
但是你得一个一个去图固

49:14.780 --> 49:16.780
第二题

49:16.780 --> 49:18.780
考虑这个表达式是吧

49:18.780 --> 49:21.780
同时考察了什么

49:21.780 --> 49:24.780
表达式的优先级的运算过程

49:24.780 --> 49:25.780
以及复制运算

49:25.780 --> 49:27.780
以及夹夹运算

49:27.780 --> 49:29.780
关于这个夹夹运算

49:29.780 --> 49:30.780
你们痛苦

49:30.780 --> 49:31.780
我更痛苦

49:31.780 --> 49:32.780
没事讲

49:32.780 --> 49:34.780
讲完了之后

49:34.780 --> 49:35.780
还是琢磨不明白

49:35.780 --> 49:37.780
你得下去好好去练一练

49:37.780 --> 49:38.780
这种鞋法

49:38.780 --> 49:40.780
以后你工作肯定是不用的

49:40.780 --> 49:42.780
但是呢

49:42.780 --> 49:44.780
它就有可能考

49:44.780 --> 49:46.780
搞清楚的倒题

49:46.780 --> 49:47.780
花不了你多少时间

49:47.780 --> 49:48.780
你搞清楚了

49:48.780 --> 49:50.780
这种题永远考不到你了

49:50.780 --> 49:51.780
好 咱们来看一下

49:51.780 --> 49:52.780
这种题该怎么来算

49:52.780 --> 49:55.290
一开始个变量

49:55.290 --> 49:56.290
它的指示一

49:56.290 --> 49:57.290
你们以后怎么算

49:57.290 --> 49:58.290
做这种题的时候

49:58.290 --> 50:00.290
拿出你的超高纸

50:00.290 --> 50:01.290
如果说是上级

50:01.290 --> 50:03.290
在做这个比试题的时候

50:03.290 --> 50:04.290
你就可以打开一个技术碗

50:04.290 --> 50:05.290
像袁老师这样子来算

50:05.290 --> 50:07.290
绝对没有问题

50:07.290 --> 50:10.860
输出的是啥呀

50:10.860 --> 50:13.860
输出的是这个表达式的结果

50:13.860 --> 50:14.860
你再算这个表达式

50:14.860 --> 50:15.860
这是个什么表达式

50:15.860 --> 50:19.170
一个复制的表达式

50:19.170 --> 50:21.170
复制的表达式等于啥

50:21.170 --> 50:22.170
等于右边那个

50:22.170 --> 50:23.170
和算出来的结果

50:23.170 --> 50:24.170
所以关键点就是算什么

50:24.170 --> 50:25.170
算右边

50:25.170 --> 50:26.170
你只要把右

50:26.170 --> 50:27.170
你只要把右边算出来

50:27.170 --> 50:29.170
不就完了吗

50:29.170 --> 50:30.170
放大一点

50:30.170 --> 50:32.170
算右边

50:32.170 --> 50:33.170
右边那个表达式

50:33.170 --> 50:35.170
怎么算呢

50:35.170 --> 50:36.170
这里容易出问题的地方

50:36.170 --> 50:37.170
在哪啊

50:37.170 --> 50:38.170
其实这种算的

50:38.170 --> 50:39.170
运算的过程

50:39.170 --> 50:40.170
每个语言

50:40.170 --> 50:42.170
它有点不一样

50:42.170 --> 50:43.170
所以这里就单说

50:43.170 --> 50:45.170
这也是语言

50:45.170 --> 50:46.170
在这个环境下

50:46.170 --> 50:48.170
它是怎么算的呢

50:48.170 --> 50:49.170
加价的

50:49.170 --> 50:50.170
这个乘号的运算

50:50.170 --> 50:51.170
优先级比较高

50:51.170 --> 50:54.170
所以应该先算乘法

50:54.170 --> 50:56.170
那里把个加价给吃完

50:56.170 --> 50:57.170
加价的优先级比

50:57.170 --> 51:00.610
这个乘法更高

51:00.610 --> 51:04.940
那应该怎么算

51:04.940 --> 51:05.940
是这么算的

51:05.940 --> 51:08.940
它不管你优先级的高低

51:08.940 --> 51:10.940
就是从左到右算

51:10.940 --> 51:11.940
挺好哈

51:11.940 --> 51:13.940
这个法律讲一遍

51:13.940 --> 51:14.940
你习惯完了过后

51:14.940 --> 51:16.940
什么样的动表达式都搞定了

51:16.940 --> 51:18.940
不管你优先级的高低的

51:18.940 --> 51:20.940
就是从左到右算

51:20.940 --> 51:22.940
那它怎么算的呢

51:22.940 --> 51:23.940
看到数据

51:23.940 --> 51:25.940
拿数据

51:25.940 --> 51:26.940
这个很简单

51:26.940 --> 51:28.940
你看到的是什么

51:28.940 --> 51:29.940
从左到右算

51:29.940 --> 51:30.940
拿数据

51:30.940 --> 51:31.940
s说

51:31.940 --> 51:33.940
1

51:33.940 --> 51:34.940
对吧

51:34.940 --> 51:35.940
数据拿出来

51:35.940 --> 51:39.450
看到数据拿数据

51:39.450 --> 51:42.450
看到符号怎么办呢

51:42.450 --> 51:45.450
不着急

51:45.450 --> 51:49.450
它要继续往后看

51:49.450 --> 51:51.450
除非遇到了什么

51:51.450 --> 51:54.450
除非遇到了后边的符号

51:54.450 --> 51:55.450
挺好啊

51:55.450 --> 51:56.450
这话比较糟

51:56.450 --> 51:59.450
除非遇到了后边的符号

51:59.450 --> 52:01.450
优先级是小于等于

52:01.450 --> 52:03.450
当前这个符号的

52:03.450 --> 52:08.530
还会对当前这个符号进行运算

52:08.530 --> 52:11.530
有同学看过我抖音上的东西

52:11.530 --> 52:12.530
抖音上的我说的比较简单

52:12.530 --> 52:14.530
我现在给你们说最真实的情况

52:14.530 --> 52:25.620
我给你举个例子

52:25.620 --> 52:27.620
我随便想起一个表达式

52:27.620 --> 52:31.820
这个表达式咋算的

52:31.820 --> 52:32.820
在数学里边

52:32.820 --> 52:33.820
先算这个

52:33.820 --> 52:34.820
不对

52:34.820 --> 52:36.820
计算机不是这样玩的

52:36.820 --> 52:38.820
它是从左到右看的

52:38.820 --> 52:39.820
先看3

52:39.820 --> 52:40.820
一个数字

52:40.820 --> 52:41.820
没问题

52:41.820 --> 52:42.820
数据拿出来了

52:42.820 --> 52:43.820
一个加号

52:43.820 --> 52:44.820
看到一个5

52:44.820 --> 52:45.820
那么现在算的加吗

52:45.820 --> 52:47.820
不算

52:47.820 --> 52:48.820
看什么

52:48.820 --> 52:49.820
接着往后看

52:49.820 --> 52:51.820
发现后边是一个简法

52:51.820 --> 52:53.820
来比较优先级了

52:53.820 --> 52:55.820
这个简号跟这个加号

52:55.820 --> 52:56.820
优先级是不是一样的

52:56.820 --> 52:57.820
同学们告诉我

52:57.820 --> 52:58.820
是不是一样的

52:58.820 --> 53:02.220
是的话

53:02.220 --> 53:04.220
这个玩意没什么好说的吧

53:04.220 --> 53:06.220
肯定是一样的

53:06.220 --> 53:07.220
加法跟这个简法

53:07.220 --> 53:09.220
优先级是一样的

53:09.220 --> 53:10.220
当遇到这个简

53:10.220 --> 53:12.220
当遇到后边的符号的优先级

53:12.220 --> 53:15.220
是小于等于

53:15.220 --> 53:17.220
前面那个符号的

53:18.220 --> 53:19.220
前面那个符号的优先级

53:19.220 --> 53:21.220
是大于等于这个符号的

53:21.220 --> 53:22.220
就是后面还有

53:22.220 --> 53:23.220
更低的优先级

53:23.220 --> 53:24.220
或者说

53:24.220 --> 53:25.220
后边的优先级跟自己一样

53:25.220 --> 53:28.220
只有这种情况

53:28.220 --> 53:32.300
马上把前面算出来

53:32.300 --> 53:34.300
你看它是这么算的

53:34.300 --> 53:35.300
然后继续往后看

53:35.300 --> 53:37.300
对简号

53:37.300 --> 53:38.300
算简法吗

53:38.300 --> 53:39.300
不着急

53:39.300 --> 53:41.300
接着往后看

53:41.300 --> 53:43.300
发现后面那个优先级

53:43.300 --> 53:45.300
比它高

53:45.300 --> 53:46.300
刚才说的是比它低

53:46.300 --> 53:47.300
对吧

53:47.300 --> 53:48.300
比它低的话

53:48.300 --> 53:49.300
再往前面算出来

53:49.300 --> 53:51.300
比方说

53:51.300 --> 53:52.300
后边是一个加法

53:52.300 --> 53:53.300
前面的简法

53:53.300 --> 53:54.300
我可以马上算了

53:54.300 --> 53:56.300
后面的优先级比较高

53:56.300 --> 53:57.300
那怎么办

53:57.300 --> 53:59.300
又继续往后看

53:59.300 --> 54:01.300
后面没了

54:01.300 --> 54:02.300
后面没了

54:02.300 --> 54:04.300
没了怎么办呢

54:04.300 --> 54:06.300
就开始算这个了

54:06.300 --> 54:07.300
如果说

54:07.300 --> 54:08.300
后面还有的话

54:08.300 --> 54:09.300
那还要往后看

54:09.300 --> 54:10.300
比方说

54:10.300 --> 54:11.300
这里优先级高了

54:11.300 --> 54:12.300
比它高了

54:12.300 --> 54:13.300
但是这个玩意

54:13.300 --> 54:14.300
还说不定

54:14.300 --> 54:15.300
万一后面还有更高的呢

54:15.300 --> 54:16.300
对吧

54:16.300 --> 54:17.300
比方说

54:17.300 --> 54:18.300
那边是个处法

54:18.300 --> 54:20.300
那优先级是不是小于等于它

54:20.300 --> 54:21.300
一样了

54:21.300 --> 54:22.300
有个优先级一样

54:22.300 --> 54:25.300
那就赶快把它算出来

54:25.300 --> 54:27.300
它是这么算的

54:27.300 --> 54:29.870
同学

54:29.870 --> 54:30.870
然后再看

54:30.870 --> 54:31.870
处法的后面还有

54:31.870 --> 54:32.870
运算符吗

54:32.870 --> 54:33.870
没有了

54:33.870 --> 54:34.870
那就可以算了

54:34.870 --> 54:35.870
好

54:35.870 --> 54:36.870
最后就剩下一个人符号了

54:36.870 --> 54:37.870
就可以算了

54:37.870 --> 54:39.870
它是这么算的

54:39.870 --> 54:40.870
那么这里

54:40.870 --> 54:42.870
我们就用这种方式来分析

54:42.870 --> 54:44.870
你看一下

54:44.870 --> 54:45.870
遇到数据

54:45.870 --> 54:46.870
读数据

54:46.870 --> 54:47.870
等于多少

54:47.870 --> 54:48.870
遇到数据

54:48.870 --> 54:50.870
夹法

54:50.870 --> 54:51.870
算吗

54:51.870 --> 54:52.870
不算

54:52.870 --> 54:54.870
遇到夹夹运算符了

54:54.870 --> 54:55.870
算吗

54:55.870 --> 54:56.870
不算

54:56.870 --> 54:57.870
还得

54:57.870 --> 54:58.870
夹夹运算符的优先级

54:58.870 --> 54:59.870
比是不是比夹号高

54:59.870 --> 55:00.870
但是没法算

55:00.870 --> 55:01.870
因为后面

55:01.870 --> 55:03.870
万一还有更高的呢

55:03.870 --> 55:04.870
遇到的惩罚

55:04.870 --> 55:05.870
惩罚的优先级

55:05.870 --> 55:07.870
是不是比夹夹的优先级

55:07.870 --> 55:09.870
要低啊

55:09.870 --> 55:10.870
要低

55:10.870 --> 55:11.870
算什么

55:11.870 --> 55:14.570
算夹夹

55:14.570 --> 55:15.570
它是这么算的

55:15.570 --> 55:16.570
好

55:16.570 --> 55:17.570
那夹夹放前边

55:17.570 --> 55:18.570
是啥意思呢

55:19.570 --> 55:21.570
又在考虑夹夹运算符了

55:22.570 --> 55:23.570
我不知道你们那边

55:23.570 --> 55:24.570
看那些资料是怎么看的

55:24.570 --> 55:25.570
提好

55:25.570 --> 55:27.570
夹夹运算符放前边

55:27.570 --> 55:29.570
分两步

55:29.570 --> 55:31.570
第一步先字争议

55:31.570 --> 55:34.570
夹夹放前面就是先字争议

55:35.570 --> 55:36.570
然后

55:36.570 --> 55:37.570
得到这个表达

55:37.570 --> 55:39.570
这个玩意是表达式

55:39.570 --> 55:41.570
同学也不要搞错了

55:41.570 --> 55:43.570
这个玩意不是什么变量

55:43.570 --> 55:45.570
我觉得这一块技术部分

55:45.570 --> 55:46.570
就学技术的时候

55:46.570 --> 55:47.570
最容易搞错的问题

55:47.570 --> 55:49.570
就是把这个玩意当成一个变量A了

55:49.570 --> 55:50.570
不是 这是个表达式

55:50.570 --> 55:53.570
你能知道这个A加1是一个表达式

55:53.570 --> 55:55.570
你也能知道这个A乘有20个表达式

55:55.570 --> 55:56.570
但是你就不能接受

55:56.570 --> 55:58.570
这个A夹夹是一个表达式

55:58.570 --> 56:00.570
我也不知道为啥

56:00.570 --> 56:03.570
夹夹A它就不能接受是个表达式

56:03.570 --> 56:05.570
表达式就是一个算式

56:05.570 --> 56:07.570
只是它看上去不像一个

56:07.570 --> 56:08.570
不像一个我们常见的

56:08.570 --> 56:09.570
数学运算的算式

56:09.570 --> 56:10.570
它确实是一个算式

56:10.570 --> 56:13.570
它也要算出一个结果的

56:13.570 --> 56:16.570
先字争议再算这个表达式

56:16.570 --> 56:17.570
这个表达式的结果

56:17.570 --> 56:19.570
就跟A的指示一样的

56:19.570 --> 56:22.570
这里是谁在实在进行惩罚

56:22.570 --> 56:26.900
是这个表达式

56:26.900 --> 56:27.900
好 又回不头来

56:27.900 --> 56:29.900
刚才夹号现在能算吗

56:29.900 --> 56:31.900
现在又要继续往后看

56:31.900 --> 56:32.900
这个承号的优先级

56:32.900 --> 56:33.900
是不是大于夹号

56:33.900 --> 56:34.900
那夹号还不能算

56:34.900 --> 56:36.900
还得往后看

56:36.900 --> 56:37.900
那现在能算惩罚吗

56:37.900 --> 56:38.900
二层爷能算吗

56:38.900 --> 56:39.900
不能算

56:39.900 --> 56:40.900
因为还要看

56:40.900 --> 56:42.900
惩罚后面的预算符

56:42.900 --> 56:44.900
是不是夹夹

56:44.900 --> 56:45.900
夹夹的优先级

56:45.900 --> 56:46.900
是不是高于惩罚

56:46.900 --> 56:48.900
A夹夹后面还有预算符吗

56:48.900 --> 56:50.900
没了 那只能算夹夹了

56:50.900 --> 56:52.900
好 这里是夹夹放后面

56:52.900 --> 56:53.900
夹夹放后面怎么算

56:53.900 --> 56:57.900
先算表达式

56:57.900 --> 57:01.540
再字争

57:01.540 --> 57:03.540
以前万不要把A夹夹

57:03.540 --> 57:04.540
或者是夹夹A

57:04.540 --> 57:06.540
你也得到变量的指

57:06.540 --> 57:07.540
不是的

57:07.540 --> 57:10.540
那是个表达式

57:10.540 --> 57:13.540
这个式子就没有什么好说的了

57:13.540 --> 57:14.540
承号后面没东西了

57:14.540 --> 57:16.540
就是那组成一个夹号了

57:16.540 --> 57:17.540
所以说

57:17.540 --> 57:19.540
这个代码得到的结果就是5

57:19.540 --> 57:21.540
虽然我相信很多同学

57:21.540 --> 57:24.540
也能够用他的各种少操作

57:24.540 --> 57:25.540
算出来5

57:25.540 --> 57:27.540
但是这种算法是最正统的

57:27.540 --> 57:29.540
虽然很麻烦

57:29.540 --> 57:32.540
好 我再给大家说一个简单的

57:32.540 --> 57:34.540
除了这种计算方式之外

57:34.540 --> 57:37.540
说一个简单的

57:37.540 --> 57:39.540
简单的就是

57:39.540 --> 57:44.540
没有刚才那么精准

57:44.540 --> 57:45.540
我刚才跟你说的

57:45.540 --> 57:46.540
其实就是

57:46.540 --> 57:50.540
既也是执行引擎底层的计算方式

57:50.540 --> 57:54.540
它底层就是那样算的

57:54.540 --> 57:58.540
但是确实比较绕

57:58.540 --> 57:59.540
比较简单的方式

57:59.540 --> 58:02.540
就是表达式里要找优先级最低的

58:02.540 --> 58:05.540
哪个优先级最低夹号

58:05.540 --> 58:07.540
用优先级最低的来进行分割

58:07.540 --> 58:08.540
整个表达式

58:08.540 --> 58:10.540
分割出来不就是一个东西

58:10.540 --> 58:13.540
加上另一个东西

58:13.540 --> 58:14.540
这个玩意加上

58:14.540 --> 58:16.540
后面看整体就是加上这个

58:16.540 --> 58:17.540
那就把这个东西算出来

58:17.540 --> 58:18.540
这个东西算出来

58:18.540 --> 58:20.540
做个假法就完事了

58:20.540 --> 58:21.540
那这个东西是啥

58:21.540 --> 58:23.540
是1

58:23.540 --> 58:25.540
后面的东西是啥

58:25.540 --> 58:26.540
要算

58:26.540 --> 58:27.540
这个玩意是不是要算

58:27.540 --> 58:32.640
好 那我们要开始算这个

58:32.640 --> 58:33.640
开始算这个

58:33.640 --> 58:34.640
那这个玩意是什么

58:34.640 --> 58:35.640
由于大队预算服

58:35.640 --> 58:38.640
又找优先级最低的

58:38.640 --> 58:40.640
优先级最低是啥

58:40.640 --> 58:41.640
是不是乘号

58:41.640 --> 58:43.640
那就用乘号来进行分割

58:43.640 --> 58:44.640
就变成了啥东西

58:44.640 --> 58:45.640
乘意啥东西

58:45.640 --> 58:47.640
那左边那个啥东西呢

58:47.640 --> 58:48.640
不就这个吗

58:48.640 --> 58:49.640
好 来算加加

58:49.640 --> 58:50.640
加加一个怎么算

58:50.640 --> 58:53.640
先自扔 再算表达式

58:53.640 --> 58:54.640
A加加怎么算

58:54.640 --> 58:57.640
先算表达式 再自扔

58:57.640 --> 58:59.640
好 那个惩罚是不是算出来

58:59.640 --> 59:00.640
是算出来的

59:00.640 --> 59:01.640
这个玩意是不是出来了

59:01.640 --> 59:02.640
是

59:02.640 --> 59:03.640
这个玩意算出来的

59:03.640 --> 59:04.640
就5G出来了

59:04.640 --> 59:05.640
也可以算出来

59:05.640 --> 59:07.640
这种就比较简单的

59:07.640 --> 59:08.640
处理方式

59:08.640 --> 59:10.640
就没有那么绕

59:10.640 --> 59:11.640
两个方式都可以

59:11.640 --> 59:13.640
反正目前来讲

59:13.640 --> 59:16.640
我见过的所有面试题当中

59:16.640 --> 59:17.640
包括学员

59:17.640 --> 59:18.640
反规过来的面试题当中

59:18.640 --> 59:19.640
用第二种方式

59:19.640 --> 59:21.640
能够解决所有问题的

59:21.640 --> 59:24.640
它还没有升到那种程度

59:24.640 --> 59:25.640
就这一块

59:25.640 --> 59:26.640
没有升到那种程度

59:26.640 --> 59:27.640
我觉得你没有什么必要

59:27.640 --> 59:30.400
去升到那种程度

59:30.400 --> 59:31.400
好 算出来的A5

59:31.400 --> 59:32.400
然后别忘了

59:32.400 --> 59:33.400
这还没完

59:33.400 --> 59:35.400
你还得把这个5

59:35.400 --> 59:36.400
这个表达是不是算出来

59:36.400 --> 59:37.400
这个表达式

59:37.400 --> 59:38.400
有一点

59:38.400 --> 59:41.400
认为A是把A复制给A

59:41.400 --> 59:43.400
它是把这个表达式

59:43.400 --> 59:46.400
宣传的结果复制给A

59:46.400 --> 59:47.400
这一复制

59:47.400 --> 59:48.400
这个表达式是5的

59:48.400 --> 59:49.400
A又变成5了

59:49.400 --> 59:50.400
看到没

59:50.400 --> 59:51.400
这一复制过来

59:51.400 --> 59:52.400
好 这样子一来

59:52.400 --> 59:54.400
这个表达式才算完了

59:54.400 --> 59:55.400
算完了过后

59:55.400 --> 59:57.400
整个是一个复制表达式

59:57.400 --> 59:58.400
复制表达式反回

59:58.400 --> 59:59.400
这是什么

59:59.400 --> 01:00:00.400
得到的结果是什么

01:00:00.400 --> 01:00:01.400
就是你所复的值

01:00:01.400 --> 01:00:03.400
所复的值是5

01:00:03.400 --> 01:00:05.400
第一句话输出5

01:00:05.400 --> 01:00:06.400
第二句话输出A

01:00:06.400 --> 01:00:07.400
还是一个5

01:00:07.400 --> 01:00:10.610
第二题

01:00:10.610 --> 01:00:14.070
明显

01:00:14.070 --> 01:00:15.070
这两个5

01:00:16.070 --> 01:00:18.070
就做出来

01:00:18.070 --> 01:00:19.070
利用这种方式

01:00:19.070 --> 01:00:22.070
搞定那个什么复制

01:00:22.070 --> 01:00:26.450
预算这些东西都没问题

01:00:26.450 --> 01:00:27.450
好 第四题

01:00:27.450 --> 01:00:29.450
第四题又在考虑预算符

01:00:29.450 --> 01:00:31.450
它把佳佳这些东西

01:00:31.450 --> 01:00:32.450
你看佳佳现在不用怕了吧

01:00:32.450 --> 01:00:34.450
对吧 也不用怕了吧

01:00:34.450 --> 01:00:36.450
佳佳又在跟那个什么

01:00:36.450 --> 01:00:40.450
并且和货者来进行预算

01:00:40.450 --> 01:00:42.450
它的考虑

01:00:42.450 --> 01:00:45.450
佳佳同时又在考虑并且和货者

01:00:45.450 --> 01:00:47.450
那你就要搞清楚

01:00:47.450 --> 01:00:48.450
并且和货者

01:00:48.450 --> 01:00:49.450
刚才是第几题

01:00:49.450 --> 01:00:50.450
第三题是吧

01:00:50.450 --> 01:00:54.400
你要搞清楚并且和货者

01:00:54.400 --> 01:00:56.400
它是怎么算的

01:00:56.400 --> 01:00:59.400
我不知道你们之前是咋学的

01:00:59.400 --> 01:01:01.400
并且和货者的运算

01:01:01.400 --> 01:01:02.400
它们的含义不一样

01:01:02.400 --> 01:01:03.400
一个是并且

01:01:03.400 --> 01:01:05.400
并且表示两个都必须要为真

01:01:05.400 --> 01:01:06.400
才为真

01:01:06.400 --> 01:01:07.400
然后否则都为假

01:01:07.400 --> 01:01:10.400
或者是你只要有一个为真

01:01:10.400 --> 01:01:12.400
留下

01:01:12.400 --> 01:01:13.400
一个为真留下

01:01:13.400 --> 01:01:15.400
其他的都为假

01:01:15.400 --> 01:01:18.400
其他的一个为真就为真

01:01:18.400 --> 01:01:21.400
两个为假才能为假

01:01:21.400 --> 01:01:22.400
这是并且和货

01:01:22.400 --> 01:01:23.400
这个你们都知道

01:01:23.400 --> 01:01:24.400
关键是这个并且和货

01:01:24.400 --> 01:01:26.400
它到底是怎么算的呢

01:01:26.400 --> 01:01:27.400
它是一个表达式

01:01:27.400 --> 01:01:28.400
你永远不要忘记

01:01:28.400 --> 01:01:31.400
这个运算符联接的东西就是表达式

01:01:31.400 --> 01:01:32.400
一并且二

01:01:32.400 --> 01:01:33.400
是不是表达式

01:01:33.400 --> 01:01:35.400
这是数据

01:01:35.400 --> 01:01:36.400
中间两个运算符

01:01:36.400 --> 01:01:37.400
不就是表达式呢

01:01:37.400 --> 01:01:41.100
它为什么等于二呢

01:01:41.100 --> 01:01:42.100
并且也好

01:01:42.100 --> 01:01:43.100
货者也好

01:01:43.100 --> 01:01:45.100
它是个表达式

01:01:45.100 --> 01:01:46.100
是表达式

01:01:46.100 --> 01:01:48.100
它就一定有运算结果

01:01:48.100 --> 01:01:49.100
始终记住这句话

01:01:49.100 --> 01:01:51.100
只要它是一个表达式

01:01:51.100 --> 01:01:52.100
它一定有结果的

01:01:52.100 --> 01:01:54.100
你们刚才看到很多了

01:01:54.100 --> 01:01:55.100
负值是不是表达式

01:01:55.100 --> 01:01:56.100
是表达式

01:01:56.100 --> 01:01:57.100
它一定有结果

01:01:57.100 --> 01:01:59.100
结果是它就是所付的值

01:01:59.100 --> 01:02:01.100
那个加加是不是表达式

01:02:01.100 --> 01:02:02.100
A加加

01:02:02.100 --> 01:02:03.100
是表达式

01:02:03.100 --> 01:02:04.100
是表达式就有结果

01:02:04.100 --> 01:02:05.100
那么结果是什么呢

01:02:05.100 --> 01:02:07.100
加加放后边

01:02:07.100 --> 01:02:09.100
表达式的结果就是A的值

01:02:09.100 --> 01:02:10.100
加加放前面了

01:02:10.100 --> 01:02:12.100
先自身一过后才是A的值

01:02:13.100 --> 01:02:15.100
喝个水

01:02:15.100 --> 01:02:18.560
只要是表达式

01:02:18.560 --> 01:02:19.560
它一定有结果

01:02:19.560 --> 01:02:21.560
那么并且获得的结果是啥呀

01:02:21.560 --> 01:02:23.560
规则很简单

01:02:23.560 --> 01:02:29.640
并且和获得的结果

01:02:29.640 --> 01:02:34.640
就是最后运算的数据

01:02:34.640 --> 01:02:38.400
能看懂吗

01:02:38.400 --> 01:02:41.670
并且获得怎么算呢

01:02:41.670 --> 01:02:43.670
数据1

01:02:43.670 --> 01:02:46.670
数据2

01:02:46.670 --> 01:02:48.670
数据1

01:02:48.670 --> 01:02:50.670
数据2

01:02:50.670 --> 01:02:51.670
并且获得的结果

01:02:51.670 --> 01:02:54.670
就是最后运算的数据

01:02:54.670 --> 01:02:55.670
它算完了1

01:02:55.670 --> 01:02:56.670
如果它不算2

01:02:56.670 --> 01:02:57.670
2不算了

01:02:57.670 --> 01:02:58.670
为什么

01:02:58.670 --> 01:02:59.670
如果说1为真

01:02:59.670 --> 01:03:01.670
1为假了

01:03:01.670 --> 01:03:02.670
并且的话

01:03:02.670 --> 01:03:03.670
1为假

01:03:03.670 --> 01:03:04.670
1为假的话

01:03:04.670 --> 01:03:06.670
一定是假了

01:03:06.670 --> 01:03:07.670
数据2

01:03:07.670 --> 01:03:08.670
它无论是啥

01:03:08.670 --> 01:03:09.670
它都会假

01:03:09.670 --> 01:03:11.670
它数据2就不算了

01:03:11.670 --> 01:03:12.670
最后运算的是

01:03:12.670 --> 01:03:13.670
运算的数据1

01:03:13.670 --> 01:03:14.670
那么整个表达式

01:03:14.670 --> 01:03:16.670
就得到数据1

01:03:17.670 --> 01:03:20.670
这个数据1为真

01:03:20.670 --> 01:03:22.670
它是获得

01:03:22.670 --> 01:03:23.670
一个为真就行了

01:03:23.670 --> 01:03:24.670
数据2还看吗

01:03:24.670 --> 01:03:25.670
不看了

01:03:25.670 --> 01:03:26.670
最后看的数据是

01:03:26.670 --> 01:03:27.670
数据1

01:03:27.670 --> 01:03:29.670
整个表达式就返回数据1

01:03:29.670 --> 01:03:33.180
它是这么回事

01:03:33.180 --> 01:03:35.180
它不是得到什么真和假

01:03:35.180 --> 01:03:38.180
它是这么回事

01:03:38.180 --> 01:03:39.180
那么现在

01:03:39.180 --> 01:03:40.180
我们再回过头来看这个问题

01:03:40.180 --> 01:03:42.180
这个问题其实考察了蛮多了

01:03:42.180 --> 01:03:43.180
1并且0

01:03:43.180 --> 01:03:45.180
这是啥意思

01:03:46.180 --> 01:03:50.180
数据1并且0

01:03:50.180 --> 01:03:52.180
左边一个数据

01:03:52.180 --> 01:03:54.180
右边一个数据

01:03:54.180 --> 01:03:55.180
数出了是啥

01:03:55.180 --> 01:03:57.180
数出了个表达式的结果

01:03:57.180 --> 01:03:59.180
来不来看一下怎么算的

01:03:59.180 --> 01:04:02.620
1为真还是为假

01:04:02.620 --> 01:04:03.620
数为真

01:04:03.620 --> 01:04:04.620
有人搞不清楚

01:04:04.620 --> 01:04:06.620
到底该怎么来判定真假

01:04:06.620 --> 01:04:11.140
看好

01:04:11.140 --> 01:04:13.140
你就把为假的技术就行了

01:04:13.140 --> 01:04:14.140
now

01:04:14.140 --> 01:04:16.140
indefend

01:04:16.140 --> 01:04:18.140
0

01:04:18.140 --> 01:04:19.140
空字无创

01:04:19.140 --> 01:04:20.140
空的

01:04:20.140 --> 01:04:21.140
不是有空格的

01:04:21.140 --> 01:04:22.140
是空的

01:04:22.140 --> 01:04:23.140
里边啥都没有的

01:04:23.140 --> 01:04:25.970
force

01:04:25.970 --> 01:04:26.970
nan

01:04:26.970 --> 01:04:27.970
做一些权为假

01:04:27.970 --> 01:04:29.970
其他权为真

01:04:29.970 --> 01:04:31.970
其他都是真

01:04:31.970 --> 01:04:37.900
这是布尔潘定为真

01:04:37.900 --> 01:04:38.900
这个表现代考了一下

01:04:38.900 --> 01:04:39.900
布尔潘定

01:04:39.900 --> 01:04:40.900
1为真还是为假

01:04:40.900 --> 01:04:42.900
那就为真

01:04:42.900 --> 01:04:43.900
那1为真

01:04:43.900 --> 01:04:44.900
它是并且

01:04:44.900 --> 01:04:45.900
要不要放后边的

01:04:45.900 --> 01:04:46.900
并且是

01:04:46.900 --> 01:04:47.900
两个都必须要为真

01:04:47.900 --> 01:04:48.900
才为真

01:04:48.900 --> 01:04:49.900
你看到一个还不行

01:04:49.900 --> 01:04:50.900
还要看后边这个

01:04:50.900 --> 01:04:52.900
那它只要一看后边

01:04:52.900 --> 01:04:54.900
我管它是真和假

01:04:54.900 --> 01:04:55.900
它是不是最后一个

01:04:55.900 --> 01:04:56.900
看的数据一定是数据2

01:04:56.900 --> 01:04:57.900
是不是一定是

01:04:57.900 --> 01:04:58.900
最后一个看的一定是0

01:04:58.900 --> 01:05:00.900
那这个表现一定是数据0

01:05:00.900 --> 01:05:04.430
它的结果就是

01:05:04.430 --> 01:05:05.430
最后运算的数据

01:05:05.430 --> 01:05:06.430
最后运算的数据

01:05:06.430 --> 01:05:07.430
是这个

01:05:07.430 --> 01:05:09.430
那表现它一定是数据0

01:05:09.430 --> 01:05:11.430
懂得意思吗

01:05:11.430 --> 01:05:12.430
这么玩的

01:05:12.430 --> 01:05:13.430
那么1

01:05:13.430 --> 01:05:15.430
后边第二题

01:05:15.430 --> 01:05:16.430
直接复制过来

01:05:16.430 --> 01:05:18.430
还是这样

01:05:18.430 --> 01:05:19.430
先复制过来

01:05:19.430 --> 01:05:21.430
慢慢注释

01:05:21.430 --> 01:05:25.770
先把下边注释点

01:05:25.770 --> 01:05:27.770
1或者0

01:05:27.770 --> 01:05:28.770
由来

01:05:28.770 --> 01:05:30.770
数据1数据2

01:05:30.770 --> 01:05:31.770
1是真还是假

01:05:31.770 --> 01:05:32.770
是真

01:05:32.770 --> 01:05:33.770
是或者是不是

01:05:33.770 --> 01:05:34.770
后边不用看了

01:05:34.770 --> 01:05:35.770
短路

01:05:35.770 --> 01:05:36.770
后边不用看了

01:05:36.770 --> 01:05:37.770
你都为真了

01:05:37.770 --> 01:05:38.770
以后边

01:05:38.770 --> 01:05:39.770
死啥都你都为真

01:05:39.770 --> 01:05:40.770
所以后边不用看了

01:05:40.770 --> 01:05:41.770
最后一个看的数据是

01:05:41.770 --> 01:05:42.770
是不是1

01:05:42.770 --> 01:05:44.770
那这个表达是就是1

01:05:44.770 --> 01:05:45.770
它的道理一定是

01:05:45.770 --> 01:05:47.770
最后一个表达是

01:05:47.770 --> 01:05:49.770
好 再看这个

01:05:49.770 --> 01:05:51.770
就连着一起考了

01:05:51.770 --> 01:05:55.660
加加

01:05:55.660 --> 01:05:57.660
前面就是数据1

01:05:57.660 --> 01:05:58.660
这是数据2

01:05:58.660 --> 01:05:59.660
先把数据1

01:05:59.660 --> 01:06:01.660
数据1算出来吧

01:06:01.660 --> 01:06:02.660
同学们

01:06:02.660 --> 01:06:04.660
我们先把数据1算出来

01:06:04.660 --> 01:06:06.660
来吧

01:06:06.660 --> 01:06:08.660
这数据有什么好算的

01:06:08.660 --> 01:06:09.660
加加放后边

01:06:09.660 --> 01:06:10.660
什么意思

01:06:10.660 --> 01:06:11.660
先

01:06:11.660 --> 01:06:14.350
我们还是算一下吧

01:06:14.350 --> 01:06:15.350
A等于1

01:06:15.350 --> 01:06:17.350
A加加大于0

01:06:17.350 --> 01:06:18.350
加加放后边

01:06:18.350 --> 01:06:19.350
应该怎么样

01:06:19.350 --> 01:06:21.350
是不是先算表达是

01:06:21.350 --> 01:06:25.110
再自真

01:06:25.110 --> 01:06:26.110
现在A边2了

01:06:26.110 --> 01:06:29.620
然后呢

01:06:29.620 --> 01:06:31.620
那么这个玩意是真还是假

01:06:31.620 --> 01:06:32.620
是不是真

01:06:32.620 --> 01:06:33.620
那得到的是Q

01:06:33.620 --> 01:06:34.620
好了 变成了Q

01:06:34.620 --> 01:06:36.620
并且这个了

01:06:36.620 --> 01:06:37.620
它变成这个了

01:06:37.620 --> 01:06:39.620
前面算出来是Q

01:06:39.620 --> 01:06:40.620
对吧

01:06:40.620 --> 01:06:41.620
好的

01:06:41.620 --> 01:06:42.620
那Q肯定是真

01:06:42.620 --> 01:06:43.620
对不对

01:06:43.620 --> 01:06:44.620
Q肯定是真

01:06:44.620 --> 01:06:45.620
但是它是并且

01:06:45.620 --> 01:06:47.620
并且是不是要算后边了

01:06:47.620 --> 01:06:48.620
要不要算后边

01:06:48.620 --> 01:06:49.620
要啊

01:06:49.620 --> 01:06:51.620
两个都必须要为真

01:06:51.620 --> 01:06:52.620
那算吧

01:06:52.620 --> 01:06:53.620
A加加放后边

01:06:53.620 --> 01:06:54.620
怎么样

01:06:54.620 --> 01:06:56.620
先得到表达是了直

01:06:56.620 --> 01:07:00.760
再自真一

01:07:00.760 --> 01:07:01.760
这个玩意为啥

01:07:01.760 --> 01:07:02.760
也为Q

01:07:02.760 --> 01:07:03.760
好 那么

01:07:03.760 --> 01:07:04.760
左边的数据

01:07:04.760 --> 01:07:05.760
右边的数据

01:07:05.760 --> 01:07:07.760
最后算的是右边的数据

01:07:07.760 --> 01:07:08.760
右边的数据算出来是Q

01:07:08.760 --> 01:07:15.630
所以说这个表达是得到结果Q

01:07:15.630 --> 01:07:19.460
而且A的直为3

01:07:19.460 --> 01:07:22.460
好 再看下个

01:07:22.460 --> 01:07:28.070
这个表达是又来了

01:07:28.070 --> 01:07:29.070
又来呗

01:07:29.070 --> 01:07:31.070
加加放后边得到表达是的直

01:07:31.070 --> 01:07:33.580
然后自真一

01:07:33.580 --> 01:07:34.580
这个玩意算出来啥

01:07:34.580 --> 01:07:35.580
是Q

01:07:35.580 --> 01:07:36.580
左边的数据出来了

01:07:36.580 --> 01:07:37.580
对吧

01:07:37.580 --> 01:07:38.580
右边还算吗

01:07:38.580 --> 01:07:39.580
这是或者

01:07:39.580 --> 01:07:40.580
算了吗

01:07:40.580 --> 01:07:41.580
是不是不算了

01:07:41.580 --> 01:07:43.580
最后算的数据是Q

01:07:43.580 --> 01:07:45.580
那么整个表达是Q

01:07:45.580 --> 01:07:46.580
所以这个表达是

01:07:46.580 --> 01:07:48.580
它也为Q

01:07:48.580 --> 01:07:49.580
Q

01:07:49.580 --> 01:07:53.940
好 再来

01:07:53.940 --> 01:08:01.940
下一个

01:08:01.940 --> 01:08:02.940
它没有比较了

01:08:02.940 --> 01:08:04.940
来 没比较

01:08:04.940 --> 01:08:06.940
A加加放后边

01:08:06.940 --> 01:08:08.940
算表达是

01:08:08.940 --> 01:08:09.940
再自真

01:08:09.940 --> 01:08:10.940
后边算吗

01:08:10.940 --> 01:08:12.940
不算了

01:08:12.940 --> 01:08:13.940
你会为什么

01:08:13.940 --> 01:08:14.940
是或者

01:08:14.940 --> 01:08:15.940
一定是判定为真

01:08:15.940 --> 01:08:16.940
对吧

01:08:16.940 --> 01:08:17.940
所以这个表达是

01:08:17.940 --> 01:08:18.940
发挥什么

01:08:18.940 --> 01:08:19.940
发挥最后一个

01:08:19.940 --> 01:08:21.940
判定的数据

01:08:21.940 --> 01:08:26.300
发挥是

01:08:26.300 --> 01:08:27.300
最后输出A

01:08:27.300 --> 01:08:28.300
输出解

01:08:28.300 --> 01:08:29.300
输出5

01:08:29.300 --> 01:08:33.320
这问题就做出来了

01:08:33.320 --> 01:08:35.320
只要你基础是砸死的

01:08:35.320 --> 01:08:37.320
这些题随便它怎么饶你

01:08:37.320 --> 01:08:39.320
饶不到的

01:08:39.320 --> 01:08:40.320
它规则你说

01:08:40.320 --> 01:08:42.320
这个规则有多复杂吗

01:08:42.320 --> 01:08:43.320
就这么几条

01:08:43.320 --> 01:08:44.320
你今天多二分钟

01:08:44.320 --> 01:08:45.320
你听了10分钟

01:08:45.320 --> 01:08:46.320
你消化再去

01:08:46.320 --> 01:08:47.320
消化个20分钟

01:08:47.320 --> 01:08:48.320
30分钟

01:08:48.320 --> 01:08:49.320
搞定了

01:08:49.320 --> 01:08:50.320
真的就搞定了

01:08:50.320 --> 01:08:51.320
以后所有的

01:08:51.320 --> 01:08:52.320
这类面试题就不用怕了

01:08:52.320 --> 01:08:53.320
什么并且获得

01:08:53.320 --> 01:08:55.320
你搞定一个就结束一个

01:08:55.320 --> 01:08:57.320
像那种知识点的问题

01:08:57.320 --> 01:08:58.320
要比知识面的问题

01:08:58.320 --> 01:09:00.320
搞定起来舒服多了

01:09:00.320 --> 01:09:01.320
知识面的问题

01:09:01.320 --> 01:09:02.320
它一块一块一块

01:09:02.320 --> 01:09:04.320
它是连续的

01:09:04.320 --> 01:09:05.320
少了一个反应都不行

01:09:05.320 --> 01:09:07.320
但是点的问题是很好突破的

01:09:07.320 --> 01:09:09.320
它是比较独立的对吧

01:09:09.320 --> 01:09:11.320
你学了三个月和学

01:09:11.320 --> 01:09:12.320
一个月都听得我讲

01:09:12.320 --> 01:09:14.320
都能听得懂

01:09:14.320 --> 01:09:15.320
你搞定就完事了

01:09:15.320 --> 01:09:20.100
这个这种题

01:09:20.100 --> 01:09:23.570
对

01:09:23.570 --> 01:09:24.570
这种题应该出来

01:09:24.570 --> 01:09:25.570
容易出来

01:09:25.570 --> 01:09:27.570
它叫一是考虑短路运算

01:09:27.570 --> 01:09:28.570
二是考虑布尔潘丁

01:09:28.570 --> 01:09:29.570
这问题它还有各种辩体

01:09:29.570 --> 01:09:31.570
比方说

01:09:31.570 --> 01:09:32.570
它有的时候

01:09:32.570 --> 01:09:33.570
它这个问题

01:09:33.570 --> 01:09:34.570
是着重在考什么呢

01:09:34.570 --> 01:09:35.570
考短路

01:09:35.570 --> 01:09:37.570
以及并且获得

01:09:37.570 --> 01:09:38.570
它有的时候

01:09:38.570 --> 01:09:40.570
它会考虑布尔潘丁

01:09:40.570 --> 01:09:41.570
比方说它这个

01:09:41.570 --> 01:09:51.820
说说啥

01:09:51.820 --> 01:09:52.820
同学们来说

01:09:52.820 --> 01:09:54.820
自己说

01:09:54.820 --> 01:09:56.820
听了我刚才的解释

01:09:56.820 --> 01:09:58.820
你们来说

01:09:58.820 --> 01:09:59.820
说说啥

01:09:59.820 --> 01:10:10.500
说说说你对吧

01:10:10.500 --> 01:10:12.500
你首先要搞清楚

01:10:12.500 --> 01:10:14.500
这个判定的是真还是假

01:10:14.500 --> 01:10:16.500
判定的是真

01:10:16.500 --> 01:10:20.420
为啥呀

01:10:20.420 --> 01:10:22.420
有的空速乳别东西

01:10:22.420 --> 01:10:23.420
你自己看吧

01:10:23.420 --> 01:10:25.420
布尔潘丁就是这个规则

01:10:25.420 --> 01:10:28.420
除了这些是 false 其他权是真

01:10:28.420 --> 01:10:30.420
其他权是真

01:10:30.420 --> 01:10:31.420
有的说

01:10:31.420 --> 01:10:33.420
考虑就考这些东西

01:10:33.420 --> 01:10:42.550
就考虑这些东西

01:10:42.550 --> 01:10:44.550
说说啥

01:10:44.550 --> 01:10:56.820
这个玩意说说啥

01:10:56.820 --> 01:11:00.220
说说啥

01:11:00.220 --> 01:11:01.220
就管理是布尔潘丁了

01:11:01.220 --> 01:11:03.220
这个玩意是真还是假

01:11:03.220 --> 01:11:05.220
那这是真吗

01:11:05.220 --> 01:11:06.220
你看这个

01:11:06.220 --> 01:11:07.220
你就把假

01:11:07.220 --> 01:11:08.220
这六个技术就完事了

01:11:08.220 --> 01:11:10.220
六个很好记的

01:11:10.220 --> 01:11:11.220
长得这么帅

01:11:11.220 --> 01:11:12.220
你看这六个

01:11:12.220 --> 01:11:13.220
一个比一个帅

01:11:13.220 --> 01:11:15.220
看上去不是什么正常人的

01:11:15.220 --> 01:11:16.220
这种

01:11:16.220 --> 01:11:17.220
长得齐心怪壮的

01:11:17.220 --> 01:11:18.220
那就是假

01:11:18.220 --> 01:11:20.220
其他的都有一真

01:11:20.220 --> 01:11:21.220
那这个玩意

01:11:21.220 --> 01:11:22.220
看上去就是个零

01:11:22.220 --> 01:11:23.220
那它是个制服串的

01:11:23.220 --> 01:11:24.220
它为真

01:11:24.220 --> 01:11:25.220
所谓说有的是货

01:11:25.220 --> 01:11:27.220
它就不会算后边了

01:11:27.220 --> 01:11:29.220
它就把这个玩意就输出了

01:11:29.220 --> 01:11:30.220
整个表达是得到的

01:11:30.220 --> 01:11:32.220
就是个制服串的零

01:11:32.220 --> 01:11:34.220
这是个制服串的零

01:11:34.220 --> 01:11:36.220
有这么回事

01:11:36.220 --> 01:11:38.220
就是这些东西

01:11:38.220 --> 01:11:39.220
你把这个掌握扎实了

01:11:39.220 --> 01:11:40.220
你随便它怎么去绕你

01:11:40.220 --> 01:11:42.220
只要你作题的时候

01:11:42.220 --> 01:11:44.220
不要出心大意

01:11:44.220 --> 01:11:45.220
你小心一点

01:11:45.220 --> 01:11:49.260
它不可能考到你

01:11:49.260 --> 01:11:50.260
第五题

01:11:50.260 --> 01:11:54.540
第五题就是考虑的数字的

01:11:54.540 --> 01:11:56.540
这种题

01:11:56.540 --> 01:11:58.540
就纯粹考虑数字了

01:11:58.540 --> 01:11:59.540
他问

01:11:59.540 --> 01:12:00.540
这些表达

01:12:00.540 --> 01:12:02.540
你都看到了对吧

01:12:02.540 --> 01:12:04.540
他问这些表达是哪些邪法

01:12:04.540 --> 01:12:05.540
是正确的

01:12:05.540 --> 01:12:08.540
哪些邪法是错误的

01:12:08.540 --> 01:12:09.540
正确的话

01:12:09.540 --> 01:12:12.540
它的值是多少

01:12:12.540 --> 01:12:15.540
这种题

01:12:15.540 --> 01:12:16.540
我这里就顺便把这个

01:12:16.540 --> 01:12:18.540
这个体里边

01:12:18.540 --> 01:12:19.540
顺便把解释里边

01:12:19.540 --> 01:12:21.540
所有的数字字面量

01:12:21.540 --> 01:12:25.540
你们知道什么叫字面量吗

01:12:25.540 --> 01:12:26.540
有的时候

01:12:26.540 --> 01:12:27.540
我上级训音

01:12:27.540 --> 01:12:29.540
上的那种对外的公开课

01:12:29.540 --> 01:12:30.540
也挺痛苦的

01:12:30.540 --> 01:12:31.540
因为每个同学的

01:12:31.540 --> 01:12:32.540
题杵不一样

01:12:32.540 --> 01:12:33.540
看的资料也不一样

01:12:33.540 --> 01:12:34.540
我也不知道

01:12:34.540 --> 01:12:35.540
从哪个地方

01:12:35.540 --> 01:12:37.540
习惯了什么样的

01:12:37.540 --> 01:12:38.540
莫名其妙的知识

01:12:38.540 --> 01:12:39.540
我还得去纠正它

01:12:39.540 --> 01:12:41.540
字面量表示说

01:12:41.540 --> 01:12:44.540
直接书写的数据

01:12:44.540 --> 01:12:48.540
表面书写一个数字1

01:12:48.540 --> 01:12:49.540
表面书写个数字1

01:12:49.540 --> 01:12:50.540
这个1就是一个字面量

01:12:50.540 --> 01:12:51.540
书写个字幕刷

01:12:51.540 --> 01:12:53.540
这个字幕刷就是个字面量

01:12:53.540 --> 01:12:54.540
你书写个对象

01:12:54.540 --> 01:12:56.540
对象就是字面量

01:12:56.540 --> 01:12:58.540
这叫对象字面量

01:12:58.540 --> 01:13:00.540
知道吧

01:13:00.540 --> 01:13:02.540
JS里面数字的字面量

01:13:02.540 --> 01:13:04.540
它有很多种书写方式

01:13:04.540 --> 01:13:06.540
平时我们可能没有用到那么多

01:13:06.540 --> 01:13:08.540
但是有的时候你看一些别的人

01:13:08.540 --> 01:13:10.540
特别是一些标心利益的人

01:13:10.540 --> 01:13:12.540
他会喜欢用一些

01:13:12.540 --> 01:13:14.540
奇奇怪怪的书写方式

01:13:14.540 --> 01:13:17.850
看一下吧

01:13:18.850 --> 01:13:19.850
这个玩意肯定是正确的

01:13:19.850 --> 01:13:21.850
你不能说这玩意说了

01:13:21.850 --> 01:13:22.850
他都指示过好了

01:13:22.850 --> 01:13:24.850
他指示肯定是11

01:13:24.850 --> 01:13:25.850
好 第二个

01:13:25.850 --> 01:13:26.850
第二个11

01:13:26.850 --> 01:13:28.850
你们都看到了是吧

01:13:28.850 --> 01:13:30.850
正确的

01:13:30.850 --> 01:13:32.850
省略零 前面的零是可以的

01:13:32.850 --> 01:13:34.850
第二个也是正确的

01:13:34.850 --> 01:13:36.850
第三个11点

01:13:36.850 --> 01:13:38.850
你们也看到了

01:13:38.850 --> 01:13:40.850
它也是可以的

01:13:40.850 --> 01:13:42.850
省略小数点 后面的零

01:13:42.850 --> 01:13:44.850
得到的就整数11

01:13:44.850 --> 01:13:48.610
零11呢

01:13:48.610 --> 01:13:52.750
零11看上去也可以

01:13:52.750 --> 01:13:53.750
是不是

01:13:53.750 --> 01:13:54.750
表示前面是零

01:13:54.750 --> 01:13:55.750
就可以忽略不计

01:13:55.750 --> 01:13:59.320
对吧

01:13:59.320 --> 01:14:00.320
为啥呢

01:14:00.320 --> 01:14:02.320
是因为JS觉得

01:14:02.320 --> 01:14:03.320
你前面写个零

01:14:03.320 --> 01:14:05.320
你实际是写啥零

01:14:05.320 --> 01:14:08.320
你都是写的是字面量的写啥零

01:14:08.320 --> 01:14:11.320
那肯定是因为你是8禁制

01:14:11.320 --> 01:14:13.320
它会把它当成一个8禁制

01:14:13.320 --> 01:14:15.320
8禁制的话11不就是9吗

01:14:15.320 --> 01:14:16.320
对吧

01:14:16.320 --> 01:14:17.320
逢8禁1

01:14:17.320 --> 01:14:18.320
逢8禁1的话

01:14:18.320 --> 01:14:19.320
8就是10

01:14:19.320 --> 01:14:21.320
9不就是11吗

01:14:21.320 --> 01:14:22.320
所以零11得到的是9

01:14:22.320 --> 01:14:25.700
它8禁制

01:14:25.700 --> 01:14:27.700
好 080

01:14:27.700 --> 01:14:28.700
你看

01:14:28.700 --> 01:14:30.700
又得到80了

01:14:30.700 --> 01:14:32.700
那明显又不是8禁制的

01:14:32.700 --> 01:14:33.700
那为啥呢

01:14:33.700 --> 01:14:34.700
是因为8禁制里面

01:14:34.700 --> 01:14:35.700
是不可能出现8代

01:14:35.700 --> 01:14:36.700
逢8叫禁1

01:14:36.700 --> 01:14:37.700
对吧

01:14:37.700 --> 01:14:38.700
就像10禁制里面

01:14:38.700 --> 01:14:39.700
是不可能出现单位

01:14:39.700 --> 01:14:41.700
出现一个10的

01:14:41.700 --> 01:14:43.700
10都是由1和0两位组成的

01:14:43.700 --> 01:14:45.700
它不可能一位出现一个10

01:14:45.700 --> 01:14:46.700
对吧

01:14:46.700 --> 01:14:49.700
8禁制里面是不可能出现8的

01:14:49.700 --> 01:14:51.700
但是你确实写了一个8

01:14:51.700 --> 01:14:52.700
那怎么办呢

01:14:52.700 --> 01:14:54.700
它就把它当成10禁制了

01:14:54.700 --> 01:14:55.700
所以你前面写个零

01:14:55.700 --> 01:14:57.700
它是比较灵活的

01:14:57.700 --> 01:14:58.700
以后你没写代码的时候

01:14:58.700 --> 01:14:59.700
特别是数字字面量

01:14:59.700 --> 01:15:01.700
千万不要为了什么格式

01:15:01.700 --> 01:15:02.700
格式统一

01:15:02.700 --> 01:15:03.700
三位都写

01:15:03.700 --> 01:15:05.700
都写三位前面给我加个0

01:15:05.700 --> 01:15:06.700
那就完蛋了

01:15:06.700 --> 01:15:07.700
把他们8禁制了

01:15:07.700 --> 01:15:10.700
它可能出来的数字都不一样了

01:15:10.700 --> 01:15:12.700
好像在这个0O11

01:15:12.700 --> 01:15:17.390
这就是10大10的8禁制

01:15:17.390 --> 01:15:18.390
这叫0O

01:15:18.390 --> 01:15:19.390
0O

01:15:19.390 --> 01:15:20.390
这是一个前綴

01:15:20.390 --> 01:15:22.390
后边跟上数字11

01:15:22.390 --> 01:15:25.390
11就10大10的8禁制

01:15:25.390 --> 01:15:27.390
什么叫10大10呢

01:15:27.390 --> 01:15:29.390
就是说

01:15:29.390 --> 01:15:30.390
你这个玩意儿写个0O80

01:15:30.390 --> 01:15:32.390
它就直接给你报错了

01:15:32.390 --> 01:15:34.390
看不懂了它

01:15:34.390 --> 01:15:35.390
你都写0O了

01:15:35.390 --> 01:15:37.390
那你肯定不是误写

01:15:37.390 --> 01:15:38.390
你要说你写个0的话

01:15:38.390 --> 01:15:39.390
你可能是误写

01:15:39.390 --> 01:15:40.390
后边可能是10禁制

01:15:40.390 --> 01:15:41.390
那你都写了0O了

01:15:41.390 --> 01:15:44.390
它一定是8禁制

01:15:44.390 --> 01:15:46.390
那你8禁制里面出现一个8

01:15:46.390 --> 01:15:47.390
它就不认识了

01:15:47.390 --> 01:15:49.390
它是什么玩意儿呢

01:15:49.390 --> 01:15:51.390
整句话反应怪就是

01:15:51.390 --> 01:15:52.390
这什么玩意儿

01:15:52.390 --> 01:15:53.390
语法错误

01:15:53.390 --> 01:15:57.020
好 下面这个0B

01:15:57.020 --> 01:15:58.020
哎呦

01:15:58.020 --> 01:16:00.020
0B

01:16:00.020 --> 01:16:02.020
这是2禁制

01:16:02.020 --> 01:16:05.020
0B binary

01:16:05.020 --> 01:16:08.020
后边跟数字是2禁制

01:16:08.020 --> 01:16:15.470
0X1116禁制

01:16:15.470 --> 01:16:17.470
1112

01:16:17.470 --> 01:16:19.470
这是10禁制的

01:16:19.470 --> 01:16:22.470
科学技术法

01:16:22.470 --> 01:16:25.470
等于11成义10到20方

01:16:25.470 --> 01:16:29.680
就是1100

01:16:29.680 --> 01:16:33.720
这个玩意儿

01:16:33.720 --> 01:16:34.720
报错

01:16:34.720 --> 01:16:36.720
那为什么报错呢

01:16:36.720 --> 01:16:37.720
因为它认为

01:16:37.720 --> 01:16:39.720
你想写的是11点

01:16:39.720 --> 01:16:41.720
后边跟的是数字

01:16:41.720 --> 01:16:43.720
就11.1 11.2

01:16:43.720 --> 01:16:44.720
这是什么玩意儿

01:16:44.720 --> 01:16:45.720
它又不认识了

01:16:45.720 --> 01:16:46.720
报错的原因

01:16:46.720 --> 01:16:47.720
这是什么玩意儿

01:16:47.720 --> 01:16:49.720
前面跟着的是一个

01:16:49.720 --> 01:16:52.220
语法错误

01:16:52.220 --> 01:16:54.220
但是你要用下边这种写法

01:16:54.220 --> 01:16:55.220
就不报错了

01:16:55.220 --> 01:16:56.220
为什么呢

01:16:56.220 --> 01:16:58.220
你加了一个空格

01:16:58.220 --> 01:16:59.220
你整长数字

01:16:59.220 --> 01:17:01.220
后边如果说是小数点的话

01:17:01.220 --> 01:17:02.220
你前面这个地方

01:17:02.220 --> 01:17:04.220
是不可能有空格的

01:17:04.220 --> 01:17:05.220
你加了一个空格说没啥

01:17:05.220 --> 01:17:06.220
它懂你

01:17:06.220 --> 01:17:08.220
你想调用方法

01:17:08.220 --> 01:17:10.220
然后调用函数

01:17:10.220 --> 01:17:11.220
它就明白了

01:17:11.220 --> 01:17:12.220
你把它转成字母创

01:17:13.220 --> 01:17:15.220
懂你的意思吧

01:17:15.220 --> 01:17:16.220
既也是在

01:17:16.220 --> 01:17:17.220
所有的字面量的书写

01:17:17.220 --> 01:17:18.220
就全在这了

01:17:18.220 --> 01:17:20.220
没别的了

01:17:20.220 --> 01:17:21.220
以后呢

01:17:21.220 --> 01:17:23.220
遇到了这种字面量书写的

01:17:23.220 --> 01:17:24.220
这种题啊

01:17:24.220 --> 01:17:25.220
它其实不是一道面书题

01:17:25.220 --> 01:17:26.220
这道题不是面书题

01:17:26.220 --> 01:17:27.220
我可以明确告诉你

01:17:27.220 --> 01:17:28.220
但是为什么

01:17:28.220 --> 01:17:29.220
还要讲这道题呢

01:17:29.220 --> 01:17:30.220
因为讲到这道题

01:17:30.220 --> 01:17:32.220
所有的跟字面量

01:17:32.220 --> 01:17:33.220
数字字面量相关的面书题

01:17:33.220 --> 01:17:34.220
全部可以搞定的

01:17:34.220 --> 01:17:35.220
因为有的题

01:17:35.220 --> 01:17:36.220
它就故意耳心理

01:17:36.220 --> 01:17:38.980
知道吧

01:17:38.980 --> 01:17:39.980
它有的时候

01:17:39.980 --> 01:17:40.980
比如说

01:17:40.980 --> 01:17:42.980
可以写个0

01:17:42.980 --> 01:17:43.980
23

01:17:43.980 --> 01:17:45.980
然后后面再去写一些单码

01:17:45.980 --> 01:17:46.980
用这个A的字

01:17:46.980 --> 01:17:47.980
去做一些事

01:17:47.980 --> 01:17:48.980
你如果不知道

01:17:48.980 --> 01:17:49.980
只是拔进字的话

01:17:49.980 --> 01:17:50.980
那就

01:17:50.980 --> 01:17:51.980
被绕进去了

01:17:51.980 --> 01:17:54.980
你把它当成实际世界完蛋了

01:17:54.980 --> 01:17:56.980
它本来考的不是这个

01:17:56.980 --> 01:17:57.980
但是顺带就把

01:17:57.980 --> 01:17:58.980
这个东西考一下

01:17:58.980 --> 01:17:59.980
顺带了

01:17:59.980 --> 01:18:00.980
因为面书题

01:18:00.980 --> 01:18:01.980
很多朋友觉得

01:18:01.980 --> 01:18:02.980
面书题为什么是

01:18:02.980 --> 01:18:03.980
面书招火箭

01:18:03.980 --> 01:18:05.980
工作你逻辑

01:18:05.980 --> 01:18:06.980
你们以后

01:18:06.980 --> 01:18:07.980
成为面书官

01:18:07.980 --> 01:18:09.980
你们也会这样做

01:18:09.980 --> 01:18:11.980
那为什么不面书

01:18:11.980 --> 01:18:12.980
你逻辑

01:18:12.980 --> 01:18:13.980
工作你逻辑呢

01:18:13.980 --> 01:18:15.980
为什么不这样干呢

01:18:15.980 --> 01:18:17.980
他做不到啊

01:18:17.980 --> 01:18:19.980
为什么做不到

01:18:19.980 --> 01:18:21.980
因为他要面试的时候

01:18:21.980 --> 01:18:22.980
能考察你

01:18:22.980 --> 01:18:24.980
到底会不会你逻辑

01:18:24.980 --> 01:18:25.980
最好的方法是

01:18:25.980 --> 01:18:26.980
什么呢

01:18:26.980 --> 01:18:27.980
只有一个办法

01:18:27.980 --> 01:18:28.980
最好的方法就是

01:18:28.980 --> 01:18:29.980
让你做一个月项目

01:18:29.980 --> 01:18:30.980
你做不做

01:18:30.980 --> 01:18:31.980
哪个求职者

01:18:31.980 --> 01:18:32.980
不跑过来

01:18:32.980 --> 01:18:33.980
我都还没有进公司

01:18:33.980 --> 01:18:34.980
你当我做一个项目

01:18:34.980 --> 01:18:35.980
因为只有做一两个月项目

01:18:35.980 --> 01:18:36.980
我才知道你到底

01:18:36.980 --> 01:18:37.980
做得好不好

01:18:37.980 --> 01:18:39.980
而我的面试

01:18:39.980 --> 01:18:40.980
而实际情况

01:18:40.980 --> 01:18:41.980
当面书官的时候

01:18:41.980 --> 01:18:42.980
我面试别人的时间

01:18:42.980 --> 01:18:43.980
就半个小时

01:18:43.980 --> 01:18:44.980
就一个小时

01:18:44.980 --> 01:18:46.980
我要在一个小时里边

01:18:46.980 --> 01:18:48.980
面对前端这么磅大

01:18:48.980 --> 01:18:49.980
的知识体系

01:18:49.980 --> 01:18:50.980
我要怎么样

01:18:50.980 --> 01:18:51.980
我在想办法

01:18:51.980 --> 01:18:52.980
怎么样我才能在

01:18:52.980 --> 01:18:53.980
半个小时里面

01:18:53.980 --> 01:18:54.980
把你的能力考察出来

01:18:54.980 --> 01:18:55.980
我只能揉啊

01:18:55.980 --> 01:18:56.980
把这个知识点

01:18:56.980 --> 01:18:57.980
拎出来

01:18:57.980 --> 01:18:58.980
这个知识点拎出来

01:18:58.980 --> 01:19:00.980
本来他们揉不到一块的

01:19:00.980 --> 01:19:01.980
但是我必须要想办法

01:19:01.980 --> 01:19:02.980
使劲把它揉到一块

01:19:02.980 --> 01:19:04.980
揉出来就是这个鬼样子

01:19:04.980 --> 01:19:07.980
揉出来就是这些鬼样子

01:19:07.980 --> 01:19:08.980
说了吧

01:19:08.980 --> 01:19:09.980
这就是一些鬼样子的

01:19:09.980 --> 01:19:10.980
面试体系怎么来的

01:19:10.980 --> 01:19:11.980
就是要来的

01:19:11.980 --> 01:19:12.980
你们以后成为面试官

01:19:12.980 --> 01:19:14.980
你们也会面对一样的问题

