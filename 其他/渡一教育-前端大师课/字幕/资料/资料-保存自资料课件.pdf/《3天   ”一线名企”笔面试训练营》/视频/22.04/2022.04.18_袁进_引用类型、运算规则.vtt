WEBVTT

00:00.000 --> 00:09.000
好 来吧 我们首先说一下咱们这三天的集训营到底讲一些什么内容

00:09.600 --> 00:11.600
给大家让大家有个初步的了解

00:12.720 --> 00:16.480
我们这三天的集训营呢 实际上主要讲的是笔面实题

00:17.520 --> 00:24.680
同学们应该或多或少的知道咱们前端这个方向 其实无论是前端也好 还是后端也好

00:25.160 --> 00:29.400
还是别的 甚至别的行业 差不多都是这样子

00:29.960 --> 00:34.040
就是你学一个东西的时候 也要分为两个部分来学

00:35.400 --> 00:42.280
这两个部分呢 我多么非常非常希望把它统一起来 但是实际上是不太好统一的 哪两个部分呢 一个是

00:43.920 --> 00:51.700
一个是能干活 说得直白一点啊 就是能干活 什么叫能干活呢 就是你到公司里边

00:52.260 --> 00:58.820
能够用学习道的内容去做开发 做一些初级的开发 或者是一些初级终级的开发

00:59.700 --> 01:05.460
因为毕竟一开始嘛 你要做一些高端的开发 可能比较困难 你还需要积累更多的经验

01:07.020 --> 01:12.180
能干活其实对于我们IT培训来讲的话 其实并不复杂

01:13.140 --> 01:19.580
要达到能干活的目标其实并不复杂 但是另外一层就比较麻烦了 就是能面试

01:21.460 --> 01:23.420
特别是能进行高薪面试

01:24.420 --> 01:31.860
这一部分就比较麻烦了 这一部分需要涉及很多很多的一些基础的理论性质的东西

01:32.380 --> 01:36.940
就这一部分东西呢 你学了之后你会有一种强烈的感觉 他有点复杂

01:37.460 --> 01:42.300
东西呢又有点多 但是呢 他好像又没有什么用 平时开发又用不到他

01:42.860 --> 01:49.740
跟我们干活好像也没有多少关系 会有这么一种感觉 这是我们说的更直白一点的话 就是我们平时经常说

01:50.300 --> 01:51.500
面试照火箭

01:52.100 --> 01:59.220
工作你挪丝 有这么一个现象 它确实存在 那么在不同的行业里面了 它可能存在的情况不一样

01:59.660 --> 02:07.820
对于我们前端来说的话 目前相对于后端而言 好得多 后端的话卷得比较厉害一点

02:08.260 --> 02:14.300
那么这一部分可能比较麻烦 前端来说的话 这部分还稍微好一点 要好一些

02:15.420 --> 02:19.420
于是呢 我们的课程 整个后期的课程都是分为两个部分

02:20.140 --> 02:21.780
首先呢 我要大家能够干活

02:22.580 --> 02:27.140
能够在公司里面做一些开发 这些没问题 给一个功能 你能够把它完成

02:28.740 --> 02:36.420
达到这个目标之后 然后我们再去搞定高新面试 也就是我们第三个阶段 高新面试 那么就分为atman css

02:36.740 --> 02:43.260
以及js 以及各种框架 工程化 网络 还有第三堂库 各种等等等等

02:44.180 --> 02:49.540
包括移动端 那么这些东西呢 我们都是放到第三个阶段去把它完成的

02:50.460 --> 02:54.460
那么我们这三天的集训营讲什么呢 讲的肯定不是能干活

02:55.140 --> 03:00.860
讲的是高新面试 因为我们是比面试的集训营 所以我们讲的是高新面试的东西

03:01.500 --> 03:09.020
那这里边东西到底有多少呢 我这里呢 给大家准备了一个比面试 前端的比面试支持点

03:09.460 --> 03:18.260
那我这里呢 可能总结的比较粗烈啊 可写的不是那么全 我分成每一个块来给大家总结了一下啊 每一个块比较容易考到的一些

03:18.620 --> 03:23.660
比面试的支持点啊 这些东西非常多 那么这些东西大部分呢 都在咱们第三个阶段

03:24.620 --> 03:28.660
那我们这三天讲什么呢 这三天讲的是js 部分

03:29.380 --> 03:36.180
这一块 而这一块在整个js的比面试当中 占比第一它比较大 第二呢

03:37.100 --> 03:38.100
它的难度

03:39.220 --> 03:42.100
适中 它不算很难 也不算很简单

03:42.660 --> 03:45.460
啊 啊 即便是你之前借也是学的

03:46.340 --> 03:52.020
科科碰碰 可能一些基础不是掌握的很好 那么这三天的东西呢依然能够让你有收获

03:52.500 --> 04:00.740
如果你借也是学的很好 这三天的东西同样会有收获啊 所以说我们这里是精心挑选的这一部分支持点 作为这三天的主要内容

04:01.540 --> 04:06.420
啊 知道吧 我再给大家先简单的介绍一下 我们这三天到底是讲什么

04:07.380 --> 04:10.180
那么这三天的每一天 我们会讲两个支持点

04:11.140 --> 04:16.100
并且的不仅是讲两个支持点 讲了之后 我们还会带大家同学们去做一些

04:16.820 --> 04:24.180
面试题 对吧 做了这面试题之后呢 我们可以把灵活的运用 我们学过的支持 看怎么去完成这些

04:24.900 --> 04:30.260
看上去比较恶心的面试题 甚至很多都是大厂的面试题 其实你学了这三天之后 你会发现

04:31.060 --> 04:32.980
大厂的面试题也不过如此

04:34.020 --> 04:37.140
so easy 当然你要前提条件 你要能学懂啊

04:37.860 --> 04:42.420
好 如果说这三天的东西 如果说同学们觉得学习期待比较有困难的话 那可能是

04:42.740 --> 04:48.660
以GS的基础部分 不管是 就是成哥的GS的基础部分 你还需要好好去看一看

04:49.220 --> 04:54.020
好吧 你首先得多多少少能干活 然后再去听这个东西比较好一点

04:55.380 --> 05:06.100
好 然后今天的话 我们是讲的什么呢 讲两个支持点啊 一个是运算规则 一个是职合引用 这是我们今天的讲解内容

05:07.940 --> 05:12.660
嗯 一个是运算规则

05:13.700 --> 05:19.700
一个是职合引用啊 这两个部分 好 我们一个一个说啊 首先说

05:20.500 --> 05:26.500
运算规则 像这些课件这些东西啊 我们都会在课堂结束之后

05:26.820 --> 05:31.140
把他发套群里边啊 我在课堂上课的时候呢 就认真听讲就可以了

05:32.100 --> 05:39.300
运算规则是什么呢 就是我们的GS里边不是有很多的运算符号吗 什么加啊 减啊 除啊

05:39.940 --> 05:50.660
还包括什么求予啊 对吧 还有什么加加 减起来之类的啊 很多很多的 还包括了个并且啊 货责啊 取飞啊 大鱼啊 小鱼啊 两个等号啊 三个等号

05:50.980 --> 05:58.500
哎呀 非常非常多 那么这些不同的运算符 他们这些符号 他们每一个符号的运算规则是什么

05:58.980 --> 06:01.060
比方说加法 我们都知道 他是一个

06:02.020 --> 06:09.860
两个数字相加 对吧 1加1等于2 但是如果说一端是制符创的话 那么他相加起来的话 就变成了一个腰腰变成了制符创拼接

06:10.420 --> 06:18.900
也就是有的时候呢 我们给他不同的类型了 他可能运算结果又不太一样 那有的时候呢 我们可能会给他这么一个东西啊 一个数组呢 加上一个对象

06:19.220 --> 06:25.140
那这个我还要用是啥呢 这是运算规则 我们要解决的问题 那么这一部分问题呢

06:25.540 --> 06:32.260
同学们首先要清楚如何来学习这一块 如何学习呢 首先第一个 你不能备

06:33.540 --> 06:37.300
为什么不能备啊 这里的规则特别特别多 他并不复杂

06:37.860 --> 06:43.540
他首先的每一个规则他其实并不复杂 但他规则特别特别多 地形上你被不住

06:44.420 --> 06:46.660
第二呢 就算你被住了还是要忘

06:47.380 --> 06:52.740
你控制不了的 包括袁老师接触 gs 都有多少年了 都有七八年了

06:53.620 --> 06:59.220
那现在我这些规则记得清楚吗 我都还记不清楚 我讲都讲了无数次了 但是我自己记不住

06:59.940 --> 07:02.660
你没有必要去把记住 那么这一块

07:03.300 --> 07:06.980
如何来应对这一块规则呢 你需要去查询

07:08.340 --> 07:11.780
怎么查询呢 这里我给他有一个思维导徒

07:13.060 --> 07:19.140
你需要在网上去下载一个叫做插卖的这样的一个软件啊 去摆度一下

07:19.460 --> 07:23.940
下载这个插卖的这个软件 下载之后呢 你就可以打开我这个思维导徒了

07:24.420 --> 07:27.300
好 通过这个思维导徒然后

07:28.740 --> 07:33.300
去查阅规则 那么这个思维导徒

07:34.900 --> 07:41.220
我们如何来进行查阅 这就是我们今天晚上第一个知识点 所要讲的重点内容

07:41.940 --> 07:46.260
我要让你知道怎么来查阅这个规则 怎么来查阅这些东西

07:47.060 --> 07:55.220
好 那么我们就多举一些例子来说明 我们的GS里面运算规则到底是怎么运算的

07:55.940 --> 07:57.700
好 我们打开我们的vscode

07:59.380 --> 08:02.020
把这个打开吧 刚才那个文件夹打开

08:05.500 --> 08:10.060
好 比方说 我们这里呢 有一个签个文件夹吧 课堂代码

08:11.740 --> 08:13.740
然后呢 我们这里写个一点GS啊

08:14.700 --> 08:24.380
那个GS里面呢 我们去随便写一些规则吧 我们来看一下如何来应用我们这个思维导徒来进行查阅

08:25.100 --> 08:27.660
比方说啊 我们这里输出一个

08:28.860 --> 08:31.980
先来个简单的啊 1加上1

08:32.540 --> 08:35.820
哎 这个东西应该是等于2还是等于11呢

08:36.540 --> 08:41.820
啊 这个例子呢比较简单 相信很多同学都知道啊 这个玩意应该是一个制服车拼接

08:42.620 --> 08:44.620
结果呢 输出的结果应该是11

08:45.100 --> 08:49.340
好 我们运行看一下 运行的结果呢 得到11 对吧 是一个制服车

08:49.820 --> 08:55.740
那么我们如果说假设 我们不知道他出手到底是什么 好 那怎么来查呢 看着啊

08:56.140 --> 08:57.500
我们把这个地方解个图

08:59.620 --> 09:00.500
然后到这边来

09:01.460 --> 09:06.260
我们这里首先看运算符 这里的运算符是一个什么呀 是一个加号对吧

09:06.580 --> 09:09.300
那么我们再就可以找到 首先展开这个

09:09.780 --> 09:10.580
找到运算

09:11.300 --> 09:16.340
这里我的罗列了三种运算 叫做一个是算数 一个是比较 一个是逻辑

09:16.900 --> 09:20.580
好 我们首先看 那么这里肯定是算数 对吧 加减成说 你看这里是有个加

09:21.140 --> 09:23.940
对不对 能看清楚吗 我要放大一点啊

09:25.220 --> 09:29.780
这里是没有个加啊 这个思维导图 你们在任何地方是找不到的啊 史委员老师

09:30.180 --> 09:31.220
亲自为你们做的

09:31.940 --> 09:36.100
好 那这里有个加号 所以我们把这个展开看一下算数运算是怎么算的

09:36.660 --> 09:40.420
哎 这里有个规则 就是要转换成原始类型

09:40.980 --> 09:44.660
那具体怎么转换的 首先我们就要知道什么叫原始类型

09:45.140 --> 09:48.820
在纪念室里面是不是有两种类型啊 一种是原始类型

09:52.140 --> 09:53.180
原始类型哪些

09:53.980 --> 09:54.380
now

09:55.420 --> 09:56.060
undefend

09:57.500 --> 09:59.100
还有什么呢 还有字符串

09:59.980 --> 10:00.780
还有number

10:01.180 --> 10:03.020
数字 还有什么呢 布林

10:03.980 --> 10:06.220
对吧 是有这么几种原始类型

10:07.180 --> 10:11.340
然后呢 还有一种类型叫做对象类型 或者叫做引用类型

10:13.820 --> 10:16.540
引用类型只有一种 就是对象

10:18.140 --> 10:23.420
同学们 这一块也没有什么疑问 纪念室里面 目前除了es6之外

10:24.140 --> 10:26.700
一共有六种类型

10:27.980 --> 10:29.020
这一块其实

10:29.660 --> 10:31.340
面试题他可能会问到

10:31.980 --> 10:34.780
他问你纪念室有几种数据类型呢

10:35.260 --> 10:36.860
你要回答的是几种呢

10:37.340 --> 10:40.140
如果说es6之前 就是六种

10:40.540 --> 10:44.220
那么以后呢 你们学习了es6之后呢 还会多出来两种

10:44.540 --> 10:45.660
一个是bit int

10:47.020 --> 10:48.060
一个是symbol

10:53.100 --> 10:55.100
后面会多出两种类型 一个是bit int

10:55.580 --> 10:56.300
一个是symbol

10:56.540 --> 11:00.220
好 那么这里就会有疑问了 有人说数组和函数

11:00.620 --> 11:02.620
是不是一种单独的类型 不是

11:03.740 --> 11:07.180
数组和函数仍然属于对象类型

11:08.300 --> 11:11.820
这个不是我瞎说的 这是官方文档给你归类的

11:12.380 --> 11:15.660
所以说这一块呢 其实网上有很多的答案都是错的啊

11:15.900 --> 11:17.900
这才是唯一的正确答案

11:18.220 --> 11:20.300
目前的既es类型一共有八种

11:21.420 --> 11:23.260
这是过去的五种原式类型

11:23.820 --> 11:24.700
后来es6呢

11:25.500 --> 11:27.180
之后又新增了两种

11:27.980 --> 11:29.180
新的原式类型

11:29.980 --> 11:31.820
引用类型只有一个对象

11:32.620 --> 11:33.100
听懂了吧

11:33.660 --> 11:37.340
好 这就是 先把类型这里面 顺便给大家说一下

11:38.540 --> 11:39.820
好 那么我们再回到这儿

11:40.220 --> 11:43.740
算数运算 我们这里有个加号 我们要把它转换到原式类型

11:44.220 --> 11:46.540
那么如何来转换呢 这里展开啊

11:47.020 --> 11:48.060
你看这里怎么转换

11:48.540 --> 11:52.940
先转换为数字然后运算 这是基本的转换规则

11:53.260 --> 11:57.580
但是下面有一个红色的点 红色的点表示特殊情况

11:58.060 --> 11:59.260
特殊情况是什么呢

11:59.500 --> 12:01.420
就是左边和右边

12:01.660 --> 12:04.460
如果有一个是字符串

12:05.260 --> 12:08.060
那么这个时候呢 它的转换规则不一样

12:08.300 --> 12:09.340
它的转换规则是

12:09.820 --> 12:12.140
把两端都转成字符串

12:12.380 --> 12:13.180
然后拼接

12:13.660 --> 12:16.220
那么也就意味着这个玩意儿

12:16.700 --> 12:18.300
转换的结果是什么呢

12:18.540 --> 12:19.820
它转换的结果就是

12:21.100 --> 12:23.660
因为它左右两边有一个是字符串对吧

12:23.900 --> 12:25.740
所以说呢 它左边就保持字符串

12:25.980 --> 12:28.140
右边呢 也要把它转换成字符串

12:28.380 --> 12:30.060
那么一个数字转换的字符串

12:30.300 --> 12:32.860
你可以把理解为加上单一号就完事了

12:33.820 --> 12:35.420
加上单一号就完事了

12:35.660 --> 12:37.980
那么这样子得到的结果呢 就是腰腰

12:38.220 --> 12:40.540
虽然这个答案呢 大家都知道

12:40.780 --> 12:43.100
但是呢 我要给大家说的是如何来查语

12:43.580 --> 12:46.300
好 那么接下来我们再来一些大家可能不太清楚的

12:46.540 --> 12:48.220
比如说 我们要加的是什么呢

12:48.460 --> 12:52.460
NAN加上或者是这样子吧

12:52.700 --> 12:55.900
我NOW加上的一个安迪范的

12:56.460 --> 12:58.220
这又等于多少呢

12:59.180 --> 13:01.820
这又等于多少呢 刚才一个谈了个注释出来

13:01.980 --> 13:02.540
不用管它

13:02.780 --> 13:07.100
好 那么这个等于多少我们也可以用类似的方式来完成查语

13:07.660 --> 13:09.740
好 咱们试一下啊 看怎么来查语

13:11.500 --> 13:13.260
呃 有同学问说

13:14.060 --> 13:17.740
字符串加数字拼接就一定是字符串了

13:17.900 --> 13:18.700
这是规则

13:19.180 --> 13:20.780
这是定死的规则

13:21.740 --> 13:23.020
啊 它没有为什么

13:23.260 --> 13:25.580
就像我们学数学学物理的时候

13:25.820 --> 13:26.860
会有一些功利

13:27.100 --> 13:28.140
那么这就是它

13:28.380 --> 13:29.660
做这个语言的时候

13:29.900 --> 13:31.740
它原本的想法就是这样子

13:32.540 --> 13:34.540
语书它就按照这种方式来做了

13:36.380 --> 13:39.260
呃 当然不同的语言这个处理的不是不一样的

13:39.260 --> 13:41.100
比方有些语言里边它这种做法

13:41.260 --> 13:43.660
比方说拍摄里边这种做法它就会直接包臭

13:44.060 --> 13:46.780
啊 这看语言 这些是个语言的它就是这样做的

13:48.460 --> 13:50.540
好 咱们来看一下这个东西该怎么来转换呢

13:50.540 --> 13:51.820
首先这是一个什么符号

13:51.820 --> 13:53.980
一个数学运算加号 对吧

13:54.140 --> 13:55.340
那么我们还是要看这儿

13:55.580 --> 13:56.780
转换成语言室内行

13:56.780 --> 13:58.300
首先转换成数字

13:58.540 --> 14:00.140
它这两 它不符合

14:00.860 --> 14:02.380
任何一个 你看

14:02.860 --> 14:05.580
这里不符合任何一个特殊情况 对吧

14:05.580 --> 14:07.020
这个特殊情况肯定不符合

14:07.260 --> 14:09.180
这个特殊情况呢 也不符合

14:09.820 --> 14:10.780
那么就看这个了

14:11.340 --> 14:13.660
转换成数字 那么这里就产生疑问了

14:13.900 --> 14:16.220
那我转换成数字是啥呀

14:16.460 --> 14:17.500
unfant

14:17.740 --> 14:20.060
转换成数字又是啥呀

14:20.460 --> 14:22.220
哎 那就不知道了对吧 那怎么办

14:22.220 --> 14:23.660
看下边的转换

14:24.540 --> 14:25.420
看下边转换

14:25.900 --> 14:26.460
打开它

14:27.420 --> 14:28.780
这里说 写的很清楚

14:28.780 --> 14:30.940
原始内行转成数字

14:30.940 --> 14:34.620
因为nau和unfant是原始内行

14:35.260 --> 14:36.620
它要转成数字

14:36.780 --> 14:38.220
怎么转呢 展开它

14:38.940 --> 14:40.300
说得很明白了啊

14:40.540 --> 14:41.420
怎么说呢

14:41.420 --> 14:44.300
unfant转换成数字就是NAN

14:44.700 --> 14:46.460
这是定时的规则啊

14:47.100 --> 14:50.940
unfant转成数字就是NAN

14:51.820 --> 14:54.460
那不就是nau加上NAN

14:54.860 --> 14:57.660
然后nau转成数字呢 就是nau

14:58.940 --> 15:00.620
那么也就是说了

15:00.620 --> 15:03.500
把两边转换成数字之后

15:04.140 --> 15:06.620
那么这里呢 就是0加上NAN

15:06.620 --> 15:09.260
那么0加上NAN 它们现在都是数字的

15:09.740 --> 15:11.340
那接下来都是如何加呢

15:11.340 --> 15:13.420
那又看回去啊 又看回运算

15:14.060 --> 15:15.420
运算这里怎么说的

15:15.420 --> 15:16.620
都是数字的

15:17.260 --> 15:18.700
这里是不是一个特殊情况

15:18.700 --> 15:24.060
NAN和任何内行运算得到的还是NAN

15:24.220 --> 15:25.900
那么这个结果得到的是什么呀

15:25.900 --> 15:27.340
得到的就是NAN

15:27.340 --> 15:29.020
所以说我们最终运行的结果呢

15:29.020 --> 15:32.380
我们知道它的结果应该是NAN

15:32.380 --> 15:33.180
好 运行

15:33.180 --> 15:34.220
是不是NAN

15:34.700 --> 15:35.580
得到这个意思吧

15:35.580 --> 15:38.700
我要教大家如何来查阅这个文档

15:38.940 --> 15:40.940
好 有同学又问 LH同学

15:40.940 --> 15:42.460
那面试官他说

15:42.460 --> 15:44.780
让你闪述原理

15:44.780 --> 15:47.180
只能回答规则没有什么原理

15:47.340 --> 15:49.580
是这样子 他这个东西啊

15:49.580 --> 15:50.860
他不会问你原理的

15:50.860 --> 15:52.380
这个玩意他没有原理

15:53.020 --> 15:53.820
你要问原理了

15:53.820 --> 15:55.820
就是违法引起他怎么实现的了

15:55.820 --> 15:56.860
他这个玩意没有原理

15:56.860 --> 15:58.300
他就是基本规则

15:58.300 --> 16:00.780
他问你原理的地方应该是什么呢

16:00.780 --> 16:02.540
应该是有原理的地方

16:02.540 --> 16:03.980
他才会问你原理

16:03.980 --> 16:05.100
懂不懂意思吧

16:05.100 --> 16:06.700
比方说我问你啊

16:06.700 --> 16:09.740
1加1为什么等于2停产数原理

16:09.740 --> 16:11.260
这个东西没法产数

16:11.260 --> 16:12.540
因为他没有原理

16:12.540 --> 16:13.740
他都是公理

16:13.740 --> 16:14.700
懂不懂意思吧

16:14.700 --> 16:15.580
像有些东西呢

16:15.580 --> 16:16.380
他没有原理的

16:16.380 --> 16:17.500
他就不会问你原理

16:17.500 --> 16:19.420
他有原理的才会问你原理

16:19.420 --> 16:21.580
像这个运算规则这一块

16:21.660 --> 16:22.700
他就没有原理

16:22.700 --> 16:24.140
他就是规则

16:24.140 --> 16:25.580
基本规则

16:25.580 --> 16:26.700
有些东西有原理

16:26.700 --> 16:28.700
比如说我们后边

16:28.700 --> 16:30.060
几天讲的内容里边

16:30.060 --> 16:32.460
他就有一些原理东西在里边了

16:32.460 --> 16:32.940
但是呢

16:32.940 --> 16:34.220
现在这一块是没有的

16:34.220 --> 16:37.540
只纯粹的规则

16:37.540 --> 16:38.660
好

16:38.660 --> 16:40.980
然后这是这个例子

16:40.980 --> 16:42.500
那么再比方说

16:42.500 --> 16:48.820
我们要换一个NAN成义安迪番的

16:48.820 --> 16:50.660
那这个玩意又是啥呢

16:50.660 --> 16:52.020
那还是一样的

16:52.100 --> 16:54.100
来查语这个文档

16:54.100 --> 16:55.220
是不是算数运算

16:55.220 --> 16:56.980
算数运算里面是一个成号

16:56.980 --> 16:58.020
怎么办

16:58.020 --> 16:59.060
转成数字

16:59.060 --> 17:00.500
它不属于两种特殊情况

17:00.500 --> 17:00.980
对吧

17:00.980 --> 17:02.020
转成数字

17:02.020 --> 17:06.660
那么NOW加NOW成义安迪番的

17:06.660 --> 17:07.380
转成数字

17:07.380 --> 17:08.020
刚才看到了

17:08.020 --> 17:09.460
NOW转成数字呢是多少

17:09.460 --> 17:10.580
是0

17:10.580 --> 17:12.020
所以说这里是0

17:12.020 --> 17:13.020
这个玩意是什么

17:13.020 --> 17:14.020
NAN

17:14.020 --> 17:14.340
好

17:14.340 --> 17:15.620
那么现在又回到这个情况

17:15.620 --> 17:17.620
NAN和任何类型运算

17:17.620 --> 17:19.220
得到的还是NAN

17:19.220 --> 17:22.700
那么这个结果就是

17:23.420 --> 17:27.340
所以说我们通过这个文档

17:27.340 --> 17:28.620
通过这个思维导图

17:28.620 --> 17:30.460
就可以很容易去搞定

17:30.460 --> 17:33.660
所有的这种运算

17:33.660 --> 17:35.180
好

17:35.180 --> 17:36.220
接下来我们再来

17:36.220 --> 17:38.060
在里方说

17:38.060 --> 17:42.460
我们去看一个比较典型的一个例子

17:42.460 --> 17:43.980
这个例子呢

17:43.980 --> 17:45.980
我要在浏览器里面比较好演示一点

17:45.980 --> 17:47.260
打开浏览器

17:47.260 --> 17:48.860
控制台

17:48.860 --> 17:50.060
放大一点

17:50.060 --> 17:54.240
这个例子是这样子的

17:54.480 --> 17:56.480
他问你

17:56.480 --> 17:58.320
他给你提供两个表达式

17:58.320 --> 18:00.240
第一个表达式是一个中扩号

18:00.240 --> 18:01.920
加上一个大扩号

18:01.920 --> 18:04.160
他问你这个结果是啥

18:04.160 --> 18:06.720
第二个表达式是一个大扩号

18:06.720 --> 18:08.720
加上一个中扩号

18:08.720 --> 18:10.560
他问你这个结果是啥

18:10.560 --> 18:13.760
这个题出现的频率还是蛮高的

18:13.760 --> 18:15.840
是一道特别有意思

18:15.840 --> 18:17.440
又能够表现

18:17.440 --> 18:19.920
既也是这个神奇语言的一道题

18:19.920 --> 18:20.080
好

18:20.080 --> 18:21.280
我们来看一下

18:21.280 --> 18:22.960
首先是这个

18:23.040 --> 18:24.640
中扩号加上大扩号

18:24.640 --> 18:26.880
那么这个玩意结果是啥呢

18:26.880 --> 18:29.120
我们还是可以利用这个文档

18:29.120 --> 18:30.560
来得到我们想要的答案

18:30.560 --> 18:31.600
他用的是什么符号

18:31.600 --> 18:32.640
用的是加号

18:32.640 --> 18:32.960
好

18:32.960 --> 18:34.480
咱们来看一下

18:34.480 --> 18:35.160
加号是什么

18:35.160 --> 18:36.240
算数运算

18:36.240 --> 18:39.600
其实大家也可以多多少少的感觉得到

18:39.600 --> 18:40.560
这个语

18:40.560 --> 18:42.960
既也是这个语言的设计者

18:42.960 --> 18:44.080
他是怎么想的

18:44.080 --> 18:47.120
他认为加减成除求予加加减减

18:47.120 --> 18:49.280
这些都是属于算数运算

18:49.280 --> 18:51.040
就是我们的数学运算

18:51.040 --> 18:52.640
那既然是数学运算

18:52.720 --> 18:55.840
那就应该转成数字才能运算

18:55.840 --> 18:56.320
对吧

18:56.320 --> 18:58.560
但是有这种特殊情况就是有致富串

18:59.600 --> 19:00.880
致富串是一种特殊情况

19:00.880 --> 19:01.520
有了致富串

19:01.520 --> 19:02.800
他就是拼接了

19:02.800 --> 19:04.720
加号就变成拼接了

19:04.720 --> 19:06.800
还用特殊情况就是有NAN

19:06.800 --> 19:09.120
NAN它不是一个有效的数字

19:09.120 --> 19:10.800
它是数字

19:10.800 --> 19:14.080
它在数学里边没有办法表示的数字

19:14.080 --> 19:17.360
那么这种数字是没有办法参与任何数学运算的

19:17.360 --> 19:19.760
所以算出来的结果它还是NAN

19:19.760 --> 19:20.560
懂了意思吗

19:20.560 --> 19:21.840
好

19:21.920 --> 19:23.280
那么现在我们来看一下

19:23.280 --> 19:24.720
刚才我们写到一个表达式

19:24.720 --> 19:28.880
就是一个中国号加上一个大坑号

19:28.880 --> 19:30.320
那么这个玩意怎么算呢

19:30.320 --> 19:31.600
这是一个数组

19:31.600 --> 19:33.920
数组什么类型对象

19:33.920 --> 19:34.960
这个是什么对象

19:34.960 --> 19:37.440
对象的类型还是对象

19:37.440 --> 19:39.280
那么这里我们要转成原始类型

19:39.280 --> 19:40.400
那就出现一个问题

19:40.400 --> 19:42.160
就是说我那个对象

19:42.160 --> 19:45.200
它怎么转成原始类型呢

19:45.200 --> 19:46.720
接下来我们下砍

19:46.720 --> 19:47.840
你看这里是不是一个转换

19:47.840 --> 19:50.160
这里有个对象转原始

19:50.160 --> 19:51.440
它是什么样的规则呢

19:51.600 --> 19:52.480
转开它

19:53.680 --> 19:54.160
好

19:54.160 --> 19:55.200
怎么转换

19:55.200 --> 19:59.200
首先调用对象的VALUE方法

19:59.200 --> 20:03.360
看这个方法能不能得到一个原始类型

20:03.360 --> 20:03.600
好

20:03.600 --> 20:06.400
咱们来手动的去试一下

20:06.400 --> 20:08.640
比方说我们得到一个数组的

20:08.640 --> 20:10.320
这是一个数组

20:10.320 --> 20:12.480
第二VALUE

20:12.480 --> 20:14.560
我们看一下这个数组得到的VALUE

20:14.560 --> 20:16.720
我到底是一个什么玩意儿

20:16.720 --> 20:18.480
好 运行

20:18.480 --> 20:19.840
你会发现它仍然得到的

20:19.840 --> 20:21.440
仍然是一个数组

20:21.440 --> 20:24.400
得到的仍然是一个数组

20:24.400 --> 20:26.800
它并不是一个原始类型

20:26.800 --> 20:27.840
听到没有意思吧

20:27.840 --> 20:30.400
那么再来看一下对象呢

20:30.400 --> 20:32.000
对象的VALUE

20:32.000 --> 20:34.800
它得到的会是什么呢

20:34.800 --> 20:37.360
它得到的还是一个对象

20:37.360 --> 20:39.680
你看我们这里第一步要做什么

20:39.680 --> 20:42.080
对象转原始怎么做

20:42.080 --> 20:44.960
首先调用VALUE

20:44.960 --> 20:47.360
调用之后有个前提条件

20:47.360 --> 20:50.160
调用之后你必须要得到原始类型

20:50.160 --> 20:51.920
才能继续

20:51.920 --> 20:53.600
就可以了

20:53.600 --> 20:55.120
如果说能得到原始类型

20:55.120 --> 20:58.240
那么就用原始类型进行假法运算

20:58.240 --> 21:00.960
但是如果说你得不到原始类型

21:00.960 --> 21:02.240
怎么办呢

21:02.240 --> 21:04.160
就看第二步

21:04.160 --> 21:05.360
展开它

21:05.360 --> 21:07.520
如果得到的还是一个对象

21:07.520 --> 21:09.120
它不是原始类型

21:09.120 --> 21:12.400
那么就重新调用TOUSTEEN

21:12.400 --> 21:13.520
啥意思

21:13.520 --> 21:15.200
就是说我们这个VALUE

21:15.200 --> 21:16.000
我不行了

21:16.000 --> 21:17.040
搞不定的

21:17.120 --> 21:18.320
得不到原始类型

21:18.320 --> 21:19.040
怎么办呢

21:19.040 --> 21:21.120
我就重新调用TOUSTEEN

21:21.120 --> 21:23.920
那这里也是一样

21:23.920 --> 21:24.960
得不到原始类型

21:24.960 --> 21:26.320
它就调用TOUSTEEN

21:26.320 --> 21:27.280
好

21:27.280 --> 21:28.720
这一调用TOUSTEEN之后

21:28.720 --> 21:29.440
你会看到

21:29.440 --> 21:31.520
数组调用TOUSTEEN之后

21:31.520 --> 21:32.960
由于这是一个空数组

21:32.960 --> 21:35.200
它调用TOUSTEEN之后

21:35.200 --> 21:37.520
就得到了一个空字符串

21:37.520 --> 21:40.640
得到了实际的空字符串

21:40.640 --> 21:43.040
如果说这个数组里边有东西的话

21:43.040 --> 21:43.680
一二三

21:43.680 --> 21:44.480
比方说

21:45.440 --> 21:47.840
得到了就是这么一个字符串

21:47.840 --> 21:48.800
懂了意思

21:48.800 --> 21:50.400
它现在目前是空数组

21:50.400 --> 21:53.760
所以它得到了一个空字符串

21:53.760 --> 21:54.160
好

21:54.160 --> 21:54.880
那么第二个

21:54.880 --> 21:56.880
对象去调用TOUSTEEN

21:56.880 --> 21:58.320
得到了一个字符串

21:58.320 --> 21:59.440
这么一个字符串

21:59.440 --> 22:00.720
所以说这一块得到了

22:00.720 --> 22:03.570
是这么一个字符串

22:03.570 --> 22:04.930
那于于是

22:04.930 --> 22:07.250
转成原始类型之后

22:07.250 --> 22:08.370
再来进行相加

22:08.370 --> 22:09.010
那么这个相加

22:09.010 --> 22:09.970
就可以进行相加了

22:09.970 --> 22:10.610
对吧

22:10.610 --> 22:12.050
我们之前就看过了

22:12.050 --> 22:13.410
原始类型相加

22:13.410 --> 22:15.730
只要有一端是字符串

22:15.810 --> 22:16.690
那么就意味着

22:16.690 --> 22:17.810
它们是一个字符串

22:17.810 --> 22:19.410
拼接于是

22:19.410 --> 22:21.010
这个表达式的结果

22:21.010 --> 22:22.850
就应该是这个

22:22.850 --> 22:23.730
它就应该是这个

22:23.730 --> 22:26.290
咱们来看一下

22:26.290 --> 22:26.610
你看

22:26.610 --> 22:28.690
是不是这个

22:28.690 --> 22:29.410
这就解释了

22:29.410 --> 22:30.290
这个表达式

22:30.290 --> 22:32.290
它的为什么运算结果是这个

22:32.290 --> 22:33.090
能听懂吗

22:33.090 --> 22:43.180
能听懂Q和E

22:43.180 --> 22:43.740
这个下来

22:43.740 --> 22:45.580
还要好好去揣摩一下

22:45.580 --> 22:46.940
其实这个玩意儿的规则

22:46.940 --> 22:48.940
你们不需要去背

22:48.940 --> 22:51.500
只要你们能看懂这个玩意儿

22:51.500 --> 22:52.220
就行了

22:52.220 --> 22:53.820
好

22:53.820 --> 22:54.700
那么接下来

22:54.700 --> 22:57.260
我们会有一些奇怪的做法

22:57.260 --> 22:57.980
比方说

22:57.980 --> 22:59.420
我们有的时候面试

22:59.420 --> 23:01.420
其实它会这样问你

23:01.420 --> 23:02.540
怎么问你呢

23:02.540 --> 23:04.780
我给数组的

23:04.780 --> 23:05.740
我给对象

23:05.740 --> 23:07.500
比方说我们写个对象

23:07.500 --> 23:09.820
ob界

23:09.820 --> 23:11.580
我给对象里面写个函数

23:11.580 --> 23:14.380
tostune

23:14.380 --> 23:16.540
方形

23:16.540 --> 23:17.740
我return一个什么呢

23:17.740 --> 23:19.980
return还是把个ob界return

23:19.980 --> 23:22.220
把个对象返回

23:22.220 --> 23:23.500
那么这样子一来的话

23:23.500 --> 23:25.020
就意味着什么呢

23:25.020 --> 23:29.340
意味着这个ob界去调用tostune了

23:29.340 --> 23:31.260
它得到了结果呢

23:31.260 --> 23:33.100
还是这个对象

23:33.100 --> 23:34.620
好 咱们来看一下

23:34.620 --> 23:36.540
你看是不是还是这个对象

23:36.540 --> 23:37.180
对吧

23:37.180 --> 23:38.540
这个时候会出面试题

23:38.540 --> 23:39.740
这样问你

23:39.740 --> 23:40.700
它怎么问你呢

23:40.700 --> 23:41.340
这样子

23:41.340 --> 23:45.500
ob界成一个二

23:45.500 --> 23:47.900
这个玩意儿得到多少呢

23:47.900 --> 23:49.100
得到什么呢

23:49.100 --> 23:50.460
还是一样

23:50.540 --> 23:54.060
我们这个思维导图能够解决所有的

23:54.060 --> 23:55.580
不是说解决某一个

23:55.580 --> 23:59.420
解决所有的运算这一块的所有问题

23:59.420 --> 24:01.980
那么首先它是一个惩罚

24:01.980 --> 24:03.020
看哪里

24:03.020 --> 24:04.540
看这算数运算

24:04.540 --> 24:05.180
怎么办

24:05.180 --> 24:07.100
转换成数字

24:07.100 --> 24:08.380
它不是哪一种特殊情况

24:08.380 --> 24:09.900
它是转换成数字

24:09.900 --> 24:10.700
看哪里

24:10.700 --> 24:13.020
对象转圆史

24:13.020 --> 24:14.540
首先调用value

24:14.540 --> 24:15.180
我们知道

24:15.180 --> 24:17.740
调用ob界的value

24:17.740 --> 24:18.860
得到了是什么呀

24:18.940 --> 24:20.860
得了是一个对象本身

24:20.860 --> 24:21.180
对吧

24:21.180 --> 24:22.220
就是这个对象本身

24:26.220 --> 24:27.740
得了个对象本身

24:27.740 --> 24:29.100
发现value不行

24:29.100 --> 24:29.900
又调用什么呢

24:29.900 --> 24:31.980
又调用toStream

24:31.980 --> 24:33.740
发现得到的还是不行

24:33.740 --> 24:35.100
它还是这个对象

24:35.100 --> 24:37.500
于是就出现什么情况了

24:37.500 --> 24:38.860
调用value不行

24:38.860 --> 24:41.660
调用toStream也不行

24:41.660 --> 24:42.940
就爆错了

24:42.940 --> 24:45.100
这种情况就没发成一二

24:45.100 --> 24:46.140
它就要爆错

24:46.140 --> 24:48.940
来看一下它的错误是什么

24:48.940 --> 24:50.220
它错误是什么呢

24:50.220 --> 24:52.540
无法cannotconvert

24:52.540 --> 24:53.820
无法转换

24:53.820 --> 24:54.860
什么转换了

24:54.860 --> 24:58.300
把一个对象转换成圆史值

24:58.300 --> 25:00.460
它无法把它转换成一个圆史值

25:00.460 --> 25:03.340
由于它无法转换成圆史值

25:03.340 --> 25:05.580
所以说它无法成一二

25:05.580 --> 25:06.140
对吧

25:06.140 --> 25:06.860
就爆错了

25:06.860 --> 25:08.540
说你只要能够查稳当

25:08.540 --> 25:10.700
就能解决所有的问题

25:10.700 --> 25:11.580
那有的所有面试

25:11.580 --> 25:12.540
你还可能会这样问你

25:12.540 --> 25:14.860
比方说这里发挥一个二

25:14.940 --> 25:22.960
这里再来一个value

25:22.960 --> 25:25.360
返回一个一

25:25.360 --> 25:29.280
然后问你ob借成一二等于多少

25:29.280 --> 25:29.920
那同学们

25:29.920 --> 25:32.960
根据我们刚才的规则

25:32.960 --> 25:37.360
看同学们能不能写出这个答案

25:37.360 --> 25:45.460
对答案是多少

25:45.460 --> 25:48.500
学老师就不要参与回答了

25:48.500 --> 25:51.840
我知道你会的

25:51.840 --> 25:54.640
我看很多同学的答案是二

25:54.720 --> 25:56.160
还是很多同学都理解了

25:56.160 --> 25:58.800
我刚才所说的这个概念了

25:58.800 --> 25:59.760
那它怎么做的呢

25:59.760 --> 26:01.440
还是一样这个玩意儿是惩罚

26:01.440 --> 26:02.320
是数学运算

26:02.320 --> 26:03.760
那转换成数字呢

26:03.760 --> 26:04.640
它变数字

26:04.640 --> 26:05.840
它怎么变数字呢

26:05.840 --> 26:07.200
先来调用value

26:07.200 --> 26:09.120
看能不能得到原始

26:09.120 --> 26:11.600
能得到原始是不得到一

26:11.600 --> 26:13.600
那就不用再去调用通讯了

26:13.600 --> 26:15.600
就得到的就是一成一二

26:15.600 --> 26:16.640
好咱们来运行一下

26:16.640 --> 26:18.720
自然就一个就是二

26:18.720 --> 26:20.560
就这么个意思

26:20.560 --> 26:22.480
好刚才那我解释一大堆

26:22.480 --> 26:23.760
就是为了解释这个玩意儿

26:23.760 --> 26:25.040
为什么是这个玩意儿

26:25.040 --> 26:26.080
现在明白了

26:26.080 --> 26:27.360
那现在问题是

26:27.360 --> 26:31.440
这个玩意儿它加这个玩意儿呢

26:31.440 --> 26:34.640
那就有一点不一样了

26:34.640 --> 26:36.320
为什么会不一样呢

26:36.320 --> 26:37.360
不是一样的吗

26:37.360 --> 26:38.480
它转成原始

26:38.480 --> 26:40.400
你看咱们来理一理

26:40.400 --> 26:41.680
无非就是把这个玩意儿

26:41.680 --> 26:42.720
跟这个玩意儿调换一下

26:42.720 --> 26:44.000
顺序不就完了吗

26:44.000 --> 26:46.560
它为什么会不一样呢

26:46.560 --> 26:51.520
这里有一个不是运算符的规则

26:51.520 --> 26:53.360
它就是既也是把这个代码

26:53.360 --> 26:55.920
理解的理解错了

26:55.920 --> 26:57.200
它理解成什么呢

26:57.200 --> 26:58.480
它理解的这一块呢

26:58.480 --> 26:59.760
是一个代码块

26:59.760 --> 27:01.280
它不是一个对象

27:01.280 --> 27:02.960
就既然是它没有把这个玩意儿

27:02.960 --> 27:04.880
当成一个对象

27:04.880 --> 27:06.400
这个玩意儿它把当成什么呢

27:06.400 --> 27:07.200
就是有的时候

27:07.200 --> 27:08.720
我们在写代码的时候

27:08.720 --> 27:11.920
可以凭空的去写一个大括号

27:11.920 --> 27:13.840
在这边去定一个辨量

27:13.840 --> 27:16.400
表示这里有一个代码段

27:16.400 --> 27:17.680
其实这种写法呢

27:17.680 --> 27:20.480
我们平时很少很少使用

27:20.480 --> 27:21.760
用的不多

27:21.760 --> 27:24.960
很少可以以一两年用不到一次

27:24.960 --> 27:27.440
但是它确实是一个正确的语法

27:27.440 --> 27:29.360
就表示这里有一段代码

27:29.360 --> 27:31.120
没有这么别的意思

27:31.120 --> 27:33.360
将来你们学了ES6之后呢

27:33.360 --> 27:34.400
会有一点变化

27:34.400 --> 27:36.880
就这里是有一个宽儿集作用域

27:36.880 --> 27:38.240
但是同学们现在还不知道

27:38.240 --> 27:39.840
那到底是个什么东西

27:39.840 --> 27:42.000
将来你们学了ES6之后就知道了

27:42.000 --> 27:42.720
这里实际上

27:42.720 --> 27:44.640
它可以生成一个代码宽

27:44.640 --> 27:46.240
没有别的意思了

27:46.240 --> 27:48.400
所以说它把两个大括号呢

27:48.400 --> 27:51.360
它其实有的时候有很多种含义

27:51.360 --> 27:53.040
有的时候呢它表示一个对象

27:53.040 --> 27:55.520
有的时候呢它放到衣服后边

27:55.520 --> 27:57.200
就表示一个代码宽儿了对吧

27:57.200 --> 27:58.720
如果这个玩意儿为真

27:58.720 --> 28:00.080
它就运行这个

28:00.080 --> 28:02.240
它这里肯定不是对象嘛

28:02.240 --> 28:03.920
这个大括号肯定不是对象

28:03.920 --> 28:05.280
所以说大括号呢有的时候

28:05.280 --> 28:07.120
它是有起义的

28:07.120 --> 28:08.000
那么这个时候呢

28:08.000 --> 28:09.760
GS它就理解错了

28:09.760 --> 28:11.200
它把这个东西呀

28:11.200 --> 28:12.480
加上一个中括号

28:12.480 --> 28:13.600
它认为是什么呢

28:13.600 --> 28:15.440
你想你在写啥呢

28:15.440 --> 28:16.560
它认为你这里呢

28:16.560 --> 28:18.720
写了一个代码宽儿

28:18.720 --> 28:20.560
在代码宽里面没有代码

28:20.560 --> 28:21.920
这就执行完了对吧

28:21.920 --> 28:24.000
后边的是一个单读的表达式

28:24.000 --> 28:27.380
它认为你的代码是这样子写的

28:27.380 --> 28:28.980
它认为你是这样子写的

28:28.980 --> 28:30.340
这里一块代码运行完了

28:30.340 --> 28:30.820
结束了

28:30.820 --> 28:32.820
好看一下这个表达式呢

28:32.820 --> 28:34.180
这个表达式什么意思

28:34.180 --> 28:37.300
在中括号前边一个加号

28:37.300 --> 28:38.820
这个加号

28:38.820 --> 28:40.740
有的时候它不一定是加号

28:40.740 --> 28:42.260
它是表示正负的意思

28:42.260 --> 28:44.180
比方说我们写一个正三

28:44.180 --> 28:46.820
负三负二

28:46.820 --> 28:48.260
它有的时候它如果说

28:48.260 --> 28:49.460
后边只跟一个数字

28:49.460 --> 28:50.900
左边又没数字的话

28:50.980 --> 28:51.940
没有没东西的话

28:51.940 --> 28:53.940
它就认为它是一个正号

28:53.940 --> 28:56.020
所以它这个代码理解成什么了

28:56.020 --> 28:58.100
理解成了这里运行的空的代码宽儿

28:58.100 --> 28:58.980
啥都没有

28:58.980 --> 29:01.460
然后运行一个表达式

29:01.460 --> 29:04.980
正数组

29:04.980 --> 29:05.860
那么也就是说

29:05.860 --> 29:06.980
我们整个表达式

29:06.980 --> 29:10.260
它实际上运算的是什么呢

29:10.260 --> 29:13.380
实际上运算的是这么一个玩意儿

29:13.380 --> 29:14.420
那么这么一个玩意儿

29:14.420 --> 29:15.380
又怎么运算呢

29:15.380 --> 29:16.980
还是一样

29:16.980 --> 29:20.020
正和负它也是属于

29:20.100 --> 29:21.780
算数运算

29:21.780 --> 29:24.420
它也是算数运算

29:24.420 --> 29:26.740
它也是一样的转成数字

29:26.740 --> 29:27.940
所以说这个一转数字

29:27.940 --> 29:30.100
我们刚才看到了

29:30.100 --> 29:31.940
转成原始类型

29:31.940 --> 29:33.940
转成原始类型的时候

29:33.940 --> 29:37.220
是不是转成这个玩意儿了

29:37.220 --> 29:38.020
对不对

29:38.020 --> 29:40.340
那这个玩意儿是数字吗

29:40.340 --> 29:42.180
不是

29:42.180 --> 29:43.620
那又或者是制服错拼接

29:43.620 --> 29:44.740
不是哦

29:44.740 --> 29:47.860
制服错拼接是两端都要有东西的

29:47.860 --> 29:48.660
左边要有一个

29:48.660 --> 29:49.940
右边要有一个

29:49.940 --> 29:51.460
像这个只有一端有东西的

29:51.460 --> 29:53.380
它不是什么制服错拼接

29:53.380 --> 29:56.020
它必须要还要把这个东西转成数字

29:56.020 --> 29:57.860
那我们又继续往后看

29:57.860 --> 29:59.620
原始类型转数字

29:59.620 --> 30:01.380
这是一个原始类型吗

30:01.380 --> 30:03.780
它先把它转成原始类型制服错

30:03.780 --> 30:05.860
然后再把原始的制服错

30:05.860 --> 30:08.260
转成数字

30:08.260 --> 30:09.300
原始转制服错

30:09.300 --> 30:10.420
转数字怎么转

30:10.420 --> 30:11.860
使用类型怎么转

30:11.860 --> 30:12.900
打开它

30:12.900 --> 30:14.580
空制服错

30:14.580 --> 30:16.020
含空白制服

30:16.020 --> 30:18.260
就包含里面什么空格这些东西

30:18.260 --> 30:19.620
都是一样转成什么

30:19.620 --> 30:23.380
转成零

30:23.380 --> 30:25.780
其他的情况就是直接去掉引号

30:25.780 --> 30:28.100
不是数字就是NN

30:28.100 --> 30:29.140
就这么简单

30:29.140 --> 30:32.260
所以整个表达是最开始是这个

30:32.260 --> 30:34.740
最终被它转换成了这款

30:34.740 --> 30:35.620
正零

30:35.620 --> 30:37.620
正零不就是零吗

30:37.620 --> 30:39.220
所以说这个表达是

30:39.220 --> 30:43.460
它就变成了零神奇吧

30:43.460 --> 30:45.060
这是介绍

30:45.220 --> 30:46.580
非常

30:46.580 --> 30:50.660
一言难尽的一些奇奇怪怪的现象

30:50.660 --> 30:51.860
但是不管它怎么奇怪

30:51.860 --> 30:56.180
你始终可以用这个文档去解决这些问题

30:56.180 --> 30:56.900
好

30:56.900 --> 31:00.020
那么我们怀着用这种方式

31:00.020 --> 31:01.460
咱们来试一下

31:01.460 --> 31:04.980
做几道面试题

31:04.980 --> 31:05.460
看一下

31:05.460 --> 31:06.980
来试验一下

31:06.980 --> 31:10.820
用这个文档是不是真的能够解决这些问题

31:10.820 --> 31:11.780
到面试题里面去

31:11.940 --> 31:23.060
我们还得把它复制一下

31:23.060 --> 31:24.020
展开

31:24.020 --> 31:25.780
用算规则一共有四道题

31:25.780 --> 31:28.740
第一道题咱们来看一下

31:28.740 --> 31:30.500
全是表达式

31:30.500 --> 31:33.700
问题下边的表达式的结果是啥

31:33.700 --> 31:36.660
一个个来呗

31:36.660 --> 31:38.820
首先这个玩意儿

31:38.820 --> 31:41.540
这个玩意儿的结果是啥呢

31:41.540 --> 31:43.140
打过来

31:43.140 --> 31:45.220
它是一个算数运算加法

31:45.220 --> 31:46.740
那转成数字呗

31:46.740 --> 31:47.860
它本身是数字的

31:47.940 --> 31:49.300
它这个玩意儿是不是数字

31:49.300 --> 31:50.740
不知还不是

31:50.740 --> 31:52.340
不是的话我们怎么办

31:52.340 --> 31:53.620
看这里

31:53.620 --> 31:55.220
原始转数字对吧

31:55.220 --> 31:57.140
孤儿是原始类型转数字

31:57.140 --> 31:59.060
一定要学会怎么去查

31:59.060 --> 32:01.700
其实这个文档你只要做这种题做多了

32:01.700 --> 32:02.420
查多了

32:02.420 --> 32:04.580
其实也好多人都不用查了

32:04.580 --> 32:06.420
不是你强行把它记住的

32:06.420 --> 32:07.940
其实我们学习

32:07.940 --> 32:10.260
很多时候都是这样子

32:10.260 --> 32:14.020
一切都是自然而然发生的

32:14.020 --> 32:15.780
包括你对学习产生兴趣

32:15.780 --> 32:17.460
对前端产生兴趣

32:17.460 --> 32:20.020
都是学者里学习的深入

32:20.020 --> 32:21.700
一步一步慢慢地发生的

32:21.700 --> 32:23.300
就跟你初恋一样对吧

32:23.300 --> 32:24.500
一开始只是一个路人

32:24.500 --> 32:26.020
慢慢接触久了

32:26.020 --> 32:27.860
就会有一些感情了

32:27.860 --> 32:29.220
对前端也是这样子

32:29.220 --> 32:31.380
它不是说我强行对着静止说

32:31.380 --> 32:32.180
我要喜欢它

32:32.180 --> 32:32.820
我要喜欢它

32:32.820 --> 32:34.740
我要学好它

32:34.740 --> 32:36.260
我不希望学习变成一个

32:36.260 --> 32:38.980
咬牙切齿的过程

32:38.980 --> 32:41.300
一天紧转着拳头的话

32:41.300 --> 32:42.420
捍留夹背

32:42.420 --> 32:43.780
然后头悬梁追刺骨

32:43.780 --> 32:44.820
这样子你学的痛苦

32:44.820 --> 32:46.580
其实你效果也不一定好

32:46.580 --> 32:47.540
我希望学习是一个

32:47.540 --> 32:49.700
非常愉悦的一个过程

32:49.700 --> 32:51.460
一切都是自然而然发生的

32:51.460 --> 32:52.900
它会给你带来一些困难

32:52.900 --> 32:54.180
但是这些困难

32:54.180 --> 32:57.540
你都觉得是一种挑战

32:57.540 --> 32:59.220
去迎接这些挑战

32:59.220 --> 33:01.620
是一件非常刺激的事

33:01.620 --> 33:04.340
有的时候你后边甚至会觉得

33:04.340 --> 33:06.100
写个程序它没有什么难度

33:06.100 --> 33:08.420
我都没啥兴趣去写它

33:08.420 --> 33:09.540
它意思

33:09.540 --> 33:11.540
一定要有点坑坑碰碰

33:11.540 --> 33:13.940
一定要有一些boss跟你一起

33:14.020 --> 33:15.300
到各种各样的困难

33:15.300 --> 33:18.100
我才会兴奋起来

33:18.100 --> 33:19.700
包括这些东西

33:19.700 --> 33:21.940
都不需要你强行的去记忆

33:21.940 --> 33:24.260
整个学习期间没有任何一个东西

33:24.260 --> 33:27.380
是需要你强行的去记忆的

33:27.380 --> 33:30.020
没有任何一个东西

33:30.020 --> 33:31.140
你能记得住它

33:31.140 --> 33:32.020
一定是你用了

33:32.020 --> 33:33.060
查了很多次了

33:33.060 --> 33:35.140
或者是用了很多次了

33:35.140 --> 33:36.900
很熟悉了

33:36.900 --> 33:38.260
回到说来说

33:38.260 --> 33:40.180
FORCE加1那么原始转数字

33:40.180 --> 33:42.660
一看FORCE就是0

33:42.660 --> 33:43.460
那就是0加1

33:43.460 --> 33:44.580
它就得到1了

33:44.580 --> 33:46.340
所以说这个表达是

33:46.340 --> 33:48.980
它是1

33:48.980 --> 33:50.820
结果是1

33:50.820 --> 33:54.820
我们可以在浏览器里边看一下

33:54.820 --> 33:55.380
1

33:55.380 --> 33:56.100
再看下一个

33:56.100 --> 34:00.340
CHU加1

34:00.340 --> 34:02.340
CHU加1它也是它转成数字

34:02.340 --> 34:04.100
CHU转成数字是多少呢

34:04.100 --> 34:05.060
是1

34:05.060 --> 34:06.740
所以这里其实得到的结果

34:06.740 --> 34:09.140
是1加1等于2

34:09.140 --> 34:10.660
再看下一个

34:10.660 --> 34:12.820
FORCE加一个制服创意

34:12.820 --> 34:13.620
那有什么意思呢

34:13.620 --> 34:15.620
还是要转成原始

34:15.620 --> 34:17.620
来看

34:17.620 --> 34:19.620
但是这里的转换会有点不一样

34:19.620 --> 34:23.250
算一算

34:23.250 --> 34:24.770
特殊情况

34:24.770 --> 34:27.570
X和Y有一个是制服创意

34:27.570 --> 34:28.690
那么转换的时候

34:28.690 --> 34:31.570
要都转成制服创意

34:31.570 --> 34:34.210
这里是不是有一个是制服创意

34:34.210 --> 34:35.730
所以要把它转

34:35.730 --> 34:37.250
转的不是数字的

34:37.250 --> 34:38.370
要转的是什么

34:38.370 --> 34:40.370
转的是制服创意

34:40.370 --> 34:42.370
那怎么转制服创意呢

34:42.370 --> 34:45.170
原始转制服创意

34:45.650 --> 34:48.000
打开

34:48.000 --> 34:50.000
不一定转成制服创意

34:50.000 --> 34:50.720
怎么转

34:50.720 --> 34:52.720
CHU变成一个FORCE

34:52.720 --> 34:54.720
变成一个FORCE

34:54.720 --> 34:55.440
看到没

34:55.440 --> 34:57.440
所以这个实际的情况就是

34:57.440 --> 35:00.880
FORCE加1就等于FORCE

35:00.880 --> 35:02.720
新节1

35:02.720 --> 35:04.720
所以就等于FORCE1

35:04.720 --> 35:09.520
经用这个文档是无望不利的

35:09.520 --> 35:15.310
我们其实做开发有很少有银带

35:15.310 --> 35:17.310
只要银带

35:17.790 --> 35:19.310
就是一种非常厉害的子弹

35:19.310 --> 35:21.310
它能够解决所有的敌人

35:21.310 --> 35:23.310
那么这个思维导图

35:23.310 --> 35:25.310
至少在运算规则这一块

35:25.310 --> 35:26.590
就是银带

35:26.590 --> 35:28.190
你只需要靠这个思维导图

35:28.190 --> 35:30.190
就能解决所有的运算规则的问题

35:30.190 --> 35:33.150
其实光是这个这一点

35:33.150 --> 35:35.150
你们就已经指挥票价的同学们

35:35.150 --> 35:35.710
真的

35:35.710 --> 35:38.270
因为这个玩意里面在任何地方都找不到的

35:38.270 --> 35:39.790
好

35:39.790 --> 35:41.470
然后是

35:41.470 --> 35:42.910
这个玩意得到的是什么呢

35:42.910 --> 35:44.670
加号FORCE加1

35:44.670 --> 35:45.790
那这个玩意是啥呢

35:45.870 --> 35:47.230
它首先是两部运算

35:47.230 --> 35:48.830
这里是有两个运算符

35:48.830 --> 35:50.430
它首先要算这个

35:50.430 --> 35:53.230
这是一个正负的正号

35:53.230 --> 35:54.590
当然它把它转成数字

35:54.590 --> 35:56.190
FORCE转数字就是0

35:56.190 --> 35:57.070
那就是正0

35:57.070 --> 36:01.090
正0就是0加1

36:01.090 --> 36:02.930
你可以用这种方式的

36:02.930 --> 36:04.770
可以解决很多很多的问题

36:04.770 --> 36:07.090
再看这个

36:07.090 --> 36:08.770
好像重复了是吧

36:08.770 --> 36:16.060
这个玩意Q 除一二的余数

36:16.060 --> 36:19.100
Q除一二的余数是什么呢

36:19.420 --> 36:21.180
你要一步一步算

36:21.180 --> 36:22.780
Q它是一个布尔

36:22.780 --> 36:24.060
它要把它转成数字

36:24.060 --> 36:25.740
Q转成数字的就是1

36:25.740 --> 36:28.380
Q除一二的余数

36:28.380 --> 36:30.300
你去超市

36:30.300 --> 36:30.940
这个东西

36:30.940 --> 36:34.940
怎么说

36:34.940 --> 36:36.300
这个东西2块钱

36:36.300 --> 36:37.900
但是你身上只有一块钱

36:37.900 --> 36:39.020
买得到几个

36:39.020 --> 36:40.780
买得到0个

36:40.780 --> 36:42.540
一个都买不到

36:42.540 --> 36:43.900
然后还剩几块钱了

36:43.900 --> 36:44.860
还剩1

36:44.860 --> 36:46.700
剩的钱就是余数

36:46.700 --> 36:48.140
所以余数有1

36:48.220 --> 36:49.340
1加上字幅串

36:49.340 --> 36:51.420
那么有一端是字幅串

36:51.420 --> 36:52.780
要把它转成字幅串

36:52.780 --> 36:53.820
数字转为字幅串

36:53.820 --> 36:55.980
直接加上双单也好

36:55.980 --> 36:58.620
那就是摇摇

36:58.620 --> 36:59.260
对吧

36:59.260 --> 37:00.620
我还以后也都回答

37:00.620 --> 37:01.580
回答非常正确

37:01.580 --> 37:02.460
这两个是不是说过的

37:02.460 --> 37:03.580
不再说了

37:03.580 --> 37:08.300
但是这个东西为什么要单独再说一下

37:08.300 --> 37:11.180
有个同学有问题

37:11.180 --> 37:12.540
有同学们有任何的问题

37:12.540 --> 37:14.460
都可以在评论区问出来

37:14.460 --> 37:16.060
说这个表达是又是什么呢

37:16.060 --> 37:17.500
还是一样

37:17.580 --> 37:20.220
这是一个什么数学运算

37:20.220 --> 37:21.260
它只有一个符号

37:21.260 --> 37:22.940
后边跟以前摇一步一步算

37:22.940 --> 37:24.700
先把它算出来

37:24.700 --> 37:26.140
这算出来是什么呢

37:26.140 --> 37:27.740
要把它转成数字

37:27.740 --> 37:29.500
因为它不是字幅串拼接

37:29.500 --> 37:30.940
它只有一个后边

37:30.940 --> 37:32.380
左边没有

37:32.380 --> 37:34.220
所以它要把它算出来等于多少呢

37:34.220 --> 37:36.060
要把它转成数字

37:36.060 --> 37:36.860
好 我们来看一下

37:36.860 --> 37:40.060
字幅串如何来转数字

37:40.060 --> 37:41.420
字幅串转数字

37:41.420 --> 37:42.940
空字幅串是什么

37:42.940 --> 37:45.020
是0

37:45.020 --> 37:46.140
它是不是空字幅串

37:46.220 --> 37:47.580
不是

37:47.580 --> 37:48.060
那干嘛

37:48.060 --> 37:49.740
要去掉引号

37:49.740 --> 37:52.300
去掉引号如果说它不是数字

37:52.300 --> 37:53.020
它是不是数字

37:53.020 --> 37:53.980
肯定不是嘛

37:53.980 --> 37:56.540
那就是NAN

37:56.540 --> 37:59.420
那真的NAN它还是NAN

37:59.420 --> 38:01.180
NAN跟任何运算

38:01.180 --> 38:02.140
它都是NAN

38:02.140 --> 38:05.180
为什么NAN和任何类型的运算

38:05.180 --> 38:07.340
得到了还是NAN

38:07.340 --> 38:09.180
所以说这个就是NAN

38:09.180 --> 38:10.940
于是我们可以看一下

38:11.660 --> 38:16.300
加上NAN

38:16.300 --> 38:18.940
好 我们来说一下这个

38:18.940 --> 38:20.700
这个事情比较有意思的

38:20.700 --> 38:21.580
因为我们知道

38:21.580 --> 38:22.780
这个玩意跟这个玩意

38:22.780 --> 38:24.220
区别在哪呢

38:24.220 --> 38:26.380
就是如果说你是这样的写的话

38:26.380 --> 38:27.420
我们之前已经说过了

38:27.420 --> 38:28.540
这样子写的话

38:28.540 --> 38:30.780
它是把这个玩意提出去了

38:30.780 --> 38:32.140
它认为这是一段代码

38:32.140 --> 38:34.700
然后运算的是这个玩意

38:34.700 --> 38:37.260
但是你只要把它用扩扩起来

38:37.260 --> 38:38.940
它就不能提出去了

38:38.940 --> 38:40.220
因为你一扩起来过后

38:40.300 --> 38:42.300
它就认为这是一个整体的

38:42.300 --> 38:44.620
它是一个完整的表达式的

38:44.620 --> 38:46.620
那它有算计算方式

38:46.620 --> 38:50.220
跟这个先写中过号

38:50.220 --> 38:51.020
再写大过号

38:51.020 --> 38:53.820
计算的结果是完全一样的

38:53.820 --> 38:55.020
为什么

38:55.020 --> 38:56.220
这不用多说了

38:56.220 --> 38:58.620
因为你把它扩起来之后

38:58.620 --> 39:00.060
它就变成一个完整的了

39:00.060 --> 39:00.700
完整的过后

39:00.700 --> 39:02.380
这个就变成了

39:02.380 --> 39:06.460
OP解个词

39:06.460 --> 39:07.820
然后是后表是一个空

39:07.820 --> 39:09.660
加上一个空字不错

39:09.740 --> 39:11.260
就变成这个了

39:11.260 --> 39:12.220
懂了意思吗

39:12.220 --> 39:14.220
好 咱们来看下一个

39:14.220 --> 39:15.580
下一个是这样的

39:15.580 --> 39:16.860
这种写法

39:16.860 --> 39:19.420
这种写法又是啥意思呢

39:19.420 --> 39:21.260
它表示说

39:21.260 --> 39:23.580
1加上什么

39:23.580 --> 39:26.940
加上的是一个正的空字不错

39:26.940 --> 39:29.180
加的是这个玩意

39:29.180 --> 39:30.860
那么这个玩意是什么呢

39:30.860 --> 39:33.260
要把空字不错转成数字

39:33.260 --> 39:35.020
是不是转成0

39:35.020 --> 39:35.660
加的是什么

39:35.660 --> 39:36.540
加的是0

39:36.540 --> 39:39.500
所以1加0等于1

39:39.660 --> 39:43.100
再看下一个

39:43.100 --> 39:44.380
懂了意思吗

39:44.380 --> 39:47.680
然后再看这个

39:47.680 --> 39:49.760
这个也是一样

39:49.760 --> 39:51.600
不管它的运输案有多怪

39:51.600 --> 39:53.520
评论们会不会写这种代码

39:53.520 --> 39:54.560
不会

39:54.560 --> 39:55.120
不要怕

39:55.120 --> 39:57.280
根本就不会去写这种代码

39:57.280 --> 39:58.560
但是呢

39:58.560 --> 40:00.000
它如果说出现了

40:00.000 --> 40:02.400
你要知道怎么去搞定它

40:02.400 --> 40:04.000
那么这里也是一个正号

40:04.000 --> 40:05.360
正号后面就对象了

40:05.360 --> 40:06.560
它这里不能是代码断了

40:06.560 --> 40:08.240
不然那个语法就有问题了

40:08.240 --> 40:11.280
它只能把它看成是一个表达式

40:11.440 --> 40:14.320
把这个表达式的结果跟它来运算

40:14.320 --> 40:16.000
也就是正的什么一个对象

40:16.000 --> 40:18.720
那么对象要转成原式类型

40:18.720 --> 40:19.920
转的结果是什么呢

40:19.920 --> 40:21.360
转的结果就是这个玩意

40:21.360 --> 40:23.280
O是O

40:23.280 --> 40:24.720
就转成这个玩意了

40:24.720 --> 40:25.600
一转这个玩意

40:25.600 --> 40:26.640
它前面加个正号

40:26.640 --> 40:28.720
是不是要把它转成数字

40:28.720 --> 40:29.360
怎么转

40:29.360 --> 40:30.480
去掉

40:30.480 --> 40:31.120
单一

40:31.120 --> 40:32.800
看它这个玩意是不是数字

40:32.800 --> 40:33.440
它不是

40:33.440 --> 40:34.800
那就是Nn

40:34.800 --> 40:35.840
那么Nn加1

40:35.840 --> 40:38.000
那还是Nn

40:38.000 --> 40:40.080
懂了意思吗

40:40.240 --> 40:41.040
好 再来

40:43.040 --> 40:44.480
这里有一些变化了

40:46.480 --> 40:47.440
正的这个玩意

40:47.440 --> 40:48.480
我们刚才已经看到了

40:48.480 --> 40:49.840
是一个什么呢

40:49.840 --> 40:50.960
Nan

40:50.960 --> 40:51.760
是吧

40:51.760 --> 40:53.120
F的这个玩意

40:53.120 --> 40:53.680
是什么呢

40:53.680 --> 40:54.960
还是Nan

40:54.960 --> 40:56.720
那么问题是Nan

40:56.720 --> 40:58.800
是不是等于Nan呢

40:59.920 --> 41:01.200
是不是等于Nan呢

41:01.200 --> 41:01.920
咱们来看一下

41:03.520 --> 41:05.360
这里要利用到另外一个运算符了

41:05.360 --> 41:06.960
就是比较运算符

41:07.760 --> 41:08.880
展开它

41:08.880 --> 41:09.840
这里专门来说了

41:09.840 --> 41:10.800
这个等号

41:11.920 --> 41:13.840
只要能够会查这个文档

41:13.840 --> 41:15.440
就无所无望不利

41:16.320 --> 41:17.280
有个特殊情况

41:17.840 --> 41:20.720
两端存在Nan一定是False

41:21.440 --> 41:22.880
只要这两端存在Nan

41:22.880 --> 41:24.080
它一定是False

41:25.200 --> 41:26.480
所以这个结果

41:26.480 --> 41:27.520
它一定是False

41:36.670 --> 41:37.390
好 再来

41:38.510 --> 41:39.230
后边

41:45.740 --> 41:46.540
我们挑的来吧

41:46.540 --> 41:48.380
我们就不一一去说了

41:48.380 --> 41:50.060
同学要学会去看这个文档

41:50.700 --> 41:53.740
我们看一个比较典型的吧

41:53.740 --> 41:54.300
这个

41:55.500 --> 41:56.380
这个是什么意思呢

41:56.380 --> 41:57.420
看上去

41:57.420 --> 41:58.540
好像是什么

41:58.540 --> 41:59.980
好像是一个对象

41:59.980 --> 42:01.740
我要读它的属性A

42:01.740 --> 42:02.460
按你说的话

42:02.460 --> 42:04.300
应该是一个undefined对吧

42:04.300 --> 42:05.260
为什么是undefined呢

42:05.260 --> 42:07.660
因为对象里面是没有这个属性A的

42:07.660 --> 42:08.380
是没有的

42:09.260 --> 42:10.860
那我要读它肯定是读不到

42:10.860 --> 42:11.740
但是呢

42:13.660 --> 42:15.340
它有可能理解有

42:17.340 --> 42:18.540
为什么会爆错

42:18.540 --> 42:19.900
是因为它又把这个玩意

42:19.980 --> 42:21.180
当成代码断了

42:21.900 --> 42:22.860
踢出去了

42:22.860 --> 42:23.740
它算的是什么呢

42:23.740 --> 42:25.020
算的是底而A

42:25.020 --> 42:26.540
这底而A是啥呢

42:26.540 --> 42:27.580
语法错误

42:27.580 --> 42:29.020
你看这两个语法错误

42:29.020 --> 42:30.140
是完全一样的

42:30.140 --> 42:31.820
它又把这个东西踢出去了

42:31.820 --> 42:33.260
所以它这里是爆错的

42:33.260 --> 42:35.260
但是如果说你是这样子写的

42:37.410 --> 42:38.610
那就不一样了

42:41.250 --> 42:42.290
这样写的就不一样了

42:42.290 --> 42:42.930
就表示

42:42.930 --> 42:45.490
你要把它看成一个什么表达式

42:46.210 --> 42:47.090
表达式的话

42:47.090 --> 42:48.130
它只能是对象了

42:48.130 --> 42:49.970
对象里边读一个A

42:49.970 --> 42:51.170
就读的是undefined

42:52.370 --> 42:53.410
懂得意思吗

42:54.610 --> 42:54.930
好

42:54.930 --> 42:56.370
我们再看一下这些表达式

42:56.370 --> 42:58.130
这些不是一些非常神奇的表达式

42:58.130 --> 42:59.170
我就说一个就可以了

43:00.690 --> 43:01.010
好

43:01.010 --> 43:01.650
这个玩意

43:02.290 --> 43:04.850
就是我其实今天晚上教你们的是什么呢

43:05.410 --> 43:09.970
教你们的是方法而不是结果

43:12.000 --> 43:13.840
结果的话是无穷无尽的

43:13.840 --> 43:15.280
因为你也不知道面试完

43:15.280 --> 43:16.240
它会怎么出题

43:16.800 --> 43:18.720
但是你只要掌握到方法的话

43:18.720 --> 43:20.480
你就可以搞定所有的问题

43:20.480 --> 43:21.120
这种问题

43:22.080 --> 43:22.240
好

43:22.240 --> 43:24.160
那么现在我们看一下这个表达式

43:24.720 --> 43:25.520
这个表达式呢

43:25.520 --> 43:27.440
首先它要读它的A

43:27.440 --> 43:28.320
是不是undefined

43:30.080 --> 43:31.680
然后加上一个这个玩意

43:31.680 --> 43:33.120
那全转成数字呗

43:33.120 --> 43:34.400
undefined转成数字

43:34.400 --> 43:36.000
NAA那就不用看了后面

43:36.480 --> 43:37.840
因为它跟任何东

43:40.210 --> 43:40.530
哦

43:40.530 --> 43:41.010
不对哦

43:41.010 --> 43:41.330
好

43:41.330 --> 43:41.970
来看一下

43:41.970 --> 43:43.250
undefined转成数字

43:44.610 --> 43:45.010
不对

43:46.210 --> 43:46.850
它转成原

43:46.850 --> 43:47.970
这是原式类型对吧

43:48.690 --> 43:50.130
这玩意是不是转成原式类型

43:50.130 --> 43:51.570
undefined已经是原式类型了

43:51.570 --> 43:53.810
我们先进一步把它转成原式类型

43:54.210 --> 43:55.810
那么这个玩意要转成原式类型呢

43:58.820 --> 43:59.700
不解释

43:59.700 --> 44:00.580
不解释

44:01.140 --> 44:01.540
是不是

44:02.740 --> 44:03.220
好

44:03.220 --> 44:04.740
两个都变成原式类型了

44:04.740 --> 44:06.180
接下来我们再来看一下规则

44:09.180 --> 44:10.140
规则是什么呢

44:11.660 --> 44:13.420
一端有一个是制服串

44:13.420 --> 44:14.460
是不是它是制服串

44:14.460 --> 44:15.500
那怎么办

44:15.500 --> 44:16.700
都转成制服串

44:16.700 --> 44:17.260
然后拼接

44:17.260 --> 44:19.420
那么现在就不是把它转成数字吧

44:19.420 --> 44:21.100
是要把它转成制服串

44:21.740 --> 44:23.020
那怎么来转制服串呢

44:23.980 --> 44:26.300
看一下原式转制服串

44:26.300 --> 44:27.580
undefined转成什么

44:27.580 --> 44:29.820
转成制一个制服串的undefined

44:31.820 --> 44:32.460
就变成这个了

44:32.460 --> 44:33.900
所以说最终的结构是啥呢

44:34.300 --> 44:35.340
最终的结构是这个

44:36.620 --> 44:37.180
有意思吧

44:37.580 --> 44:37.740
好

44:37.740 --> 44:38.380
咱们来看一下

44:39.100 --> 44:40.700
这个表达是复制

44:41.420 --> 44:43.860
是不是

44:45.700 --> 44:46.020
好

44:46.020 --> 44:47.620
这些东西你们自己下来去玩

44:47.620 --> 44:49.300
可以在群里面充分的去讨论

44:49.780 --> 44:50.500
然后再看这个

44:50.500 --> 44:51.460
这个也很有意思

44:51.460 --> 44:53.460
而且这个玩意是有实际作用的

44:54.420 --> 44:56.500
在我们开发中是有一些实际的用途的

44:56.980 --> 44:58.820
两个感叹号一个对象

44:59.460 --> 44:59.700
好

44:59.700 --> 45:01.140
这个时候我们来看一下这个表达是

45:03.920 --> 45:04.720
这什么意思呢

45:05.120 --> 45:06.240
你要这样子来看

45:10.080 --> 45:11.360
它是分为两个部分

45:12.160 --> 45:13.120
先算它

45:14.960 --> 45:17.920
然后把这个结果再取反

45:18.960 --> 45:20.960
把这个结果再取反

45:21.840 --> 45:23.040
那么我们首先来算它

45:23.040 --> 45:23.840
其他的先不看

45:23.840 --> 45:24.640
首先来算它

45:25.200 --> 45:26.320
怎么算它的呢

45:31.660 --> 45:33.020
这里用到的是什么符号

45:33.020 --> 45:34.940
用到的是逻辑运算

45:36.540 --> 45:37.420
转换成不利

45:39.650 --> 45:42.450
我稍微加快一点节奏了

45:44.450 --> 45:44.690
好

45:44.690 --> 45:45.730
转换成不利

45:45.730 --> 45:46.930
过后再进行运算

45:46.930 --> 45:49.170
我这里说了一个并且和一个货者

45:49.170 --> 45:50.610
但是我并没有说感叹号

45:50.610 --> 45:50.770
对吧

45:50.770 --> 45:51.730
没有说取反

45:51.730 --> 45:52.450
那么就没

45:52.450 --> 45:53.810
取反就没有什么特殊的

45:53.810 --> 45:55.890
我们只需要把它转换成不而就行了

45:55.890 --> 45:57.250
那问题是这个玩意

45:57.250 --> 45:58.610
如何来转换成不而

46:00.290 --> 46:00.770
那就看

46:01.730 --> 46:03.490
对象转什么

46:03.490 --> 46:06.130
转圆转不而

46:06.770 --> 46:08.530
所有的东西转成不而是怎么转的

46:09.570 --> 46:10.610
那我这里怎么写的

46:10.610 --> 46:12.210
那我转成不而force

46:12.210 --> 46:13.810
undefine转成不而force

46:13.810 --> 46:17.090
数字如果说是0转成不而就force

46:19.810 --> 46:21.010
支付串怎么转

46:21.010 --> 46:22.370
目前是对象对吧

46:22.370 --> 46:24.770
对象转成不而一定是处

46:25.330 --> 46:26.370
不管你是一个对象

46:26.370 --> 46:28.050
还是数组还是函数

46:28.050 --> 46:29.250
你转成不而

46:29.250 --> 46:30.290
它就一定是处

46:31.730 --> 46:34.770
那处的取反是什么force

46:34.770 --> 46:36.770
对force的取反是什么

46:36.770 --> 46:37.890
还是比较处

46:37.890 --> 46:40.610
那这个玩意有什么用呢

46:40.610 --> 46:41.490
我们来看一下

46:41.490 --> 46:42.530
它结果肯定是处

46:42.530 --> 46:48.080
那么这个写的两个感叹号有什么用呢

46:48.080 --> 46:49.600
这种写法

46:49.600 --> 46:53.280
它就可以把任何一个类型转成不而

46:53.280 --> 46:55.840
随便什么类型转成不而

46:55.840 --> 46:59.120
比方说我要把0转成不而

46:59.120 --> 46:59.680
我怎么写的

46:59.680 --> 47:00.880
两个感叹号一个0

47:00.880 --> 47:02.880
0转成不而是什么force

47:03.840 --> 47:06.000
我要把1转成不而

47:06.000 --> 47:07.280
就两个感叹号一个1

47:07.280 --> 47:08.400
就变成处

47:08.400 --> 47:10.560
我要把一个数组转成force

47:10.560 --> 47:11.360
两个感叹号

47:11.360 --> 47:12.640
数组是对象

47:12.640 --> 47:13.920
对象是处

47:13.920 --> 47:15.280
得到一个处

47:15.280 --> 47:16.320
先来个取反

47:16.320 --> 47:16.960
再来个取反

47:16.960 --> 47:18.240
反反得真

47:18.240 --> 47:20.160
这样就可以把任何一个东西

47:20.160 --> 47:21.440
转成不而类型

47:21.440 --> 47:22.480
所以这个玩意

47:22.480 --> 47:23.920
在我实战的开发中

47:23.920 --> 47:26.480
还是有一些比较有意思的用处的

47:26.480 --> 47:27.600
只不过这种用处

47:27.600 --> 47:29.520
你们平时可能不太用得到

47:30.480 --> 47:33.520
我们相当于是做这一题

47:33.520 --> 47:36.400
也不能说纯粹是为你的应付面式

47:36.400 --> 47:41.040
这些其实是我们学开发的一个根基

47:41.040 --> 47:44.350
就是我们学开发

47:44.350 --> 47:48.110
它是分为两个

47:48.110 --> 47:49.310
一个是扎根

47:49.310 --> 47:52.670
一个是善意

47:52.670 --> 47:58.000
开发结果

47:58.000 --> 48:04.780
一个是生长

48:04.780 --> 48:08.400
扎根的过程

48:08.400 --> 48:10.160
看上去是比较枯燥的

48:10.160 --> 48:11.600
因为你在地面上

48:11.600 --> 48:13.280
好像看不到任何的变化

48:13.280 --> 48:14.960
一棵树摘下去之后

48:14.960 --> 48:16.320
你可能一年

48:16.320 --> 48:17.600
看上来没有什么动静啊

48:17.600 --> 48:18.240
对吧

48:18.240 --> 48:19.520
但是它其实不断的是

48:19.520 --> 48:21.200
一个不断的扎根的过程

48:21.200 --> 48:23.600
你把它底下的土一挖开的话

48:23.600 --> 48:26.480
你会发现一些大树的根基

48:26.480 --> 48:28.400
长达几百

48:28.400 --> 48:29.280
那么这种扎根

48:29.280 --> 48:30.640
它扎得越深

48:30.640 --> 48:32.000
扎得越广

48:32.000 --> 48:33.680
就决定了这个树

48:33.680 --> 48:35.120
它能生长得多高

48:35.120 --> 48:36.480
其实你们也是一样

48:36.480 --> 48:37.920
这些根基的东西

48:38.000 --> 48:40.800
你们扎得越深越广

48:40.800 --> 48:42.880
你们的天花板就越高

48:42.880 --> 48:44.480
你们可以触碰的

48:44.480 --> 48:47.920
新支上线也就越高

48:47.920 --> 48:50.320
有的朋友觉得很容易就到天花板了

48:50.320 --> 48:52.000
到了瓶颈上不去了

48:52.000 --> 48:54.480
就是因为根基不够

48:54.480 --> 48:56.160
你的根基不允许你

48:56.160 --> 48:58.000
继续往上生长

48:58.000 --> 48:59.440
这东西其实是有动用的

48:59.440 --> 49:01.520
但是一般来说用处的话

49:01.520 --> 49:03.440
要到你工作了几年之后

49:03.440 --> 49:06.160
才会真正的发挥作用

49:06.240 --> 49:08.720
那么下面这些表达式的值

49:08.720 --> 49:11.760
这里是考的是那个等号

49:11.760 --> 49:15.280
我们随便说几个吧

49:15.280 --> 49:16.400
随便说几个

49:16.400 --> 49:17.120
我们再说一下这个

49:17.120 --> 49:18.160
NOW 和NDIFAN

49:18.160 --> 49:19.760
这两个是特别有意思的

49:19.760 --> 49:22.160
下来的同学们可以自己去做一做

49:22.160 --> 49:22.960
可以自己去做一做

49:22.960 --> 49:23.920
在群里边讨论

49:23.920 --> 49:26.560
我在说几个比较有代表性的

49:26.560 --> 49:29.920
NOW 这是一个同训的面试题

49:29.920 --> 49:31.760
你们可以去试试

49:31.760 --> 49:36.080
NOW 是不是大于NDIFAN的

49:36.480 --> 49:37.440
FORCE

49:37.440 --> 49:40.240
NOW 是不是小于NDIFAN的

49:40.240 --> 49:41.120
FORCE

49:41.120 --> 49:45.440
NOW 是不是等于NDIFAN的

49:45.440 --> 49:47.360
FORCE

49:47.360 --> 49:50.320
会有这么神奇的现象

49:50.320 --> 49:53.040
有些人觉得这不太符合逻辑

49:53.040 --> 49:55.040
两个东西要么就是一个比一个大

49:55.040 --> 49:55.760
一个比一个小

49:55.760 --> 49:56.640
要么就相等

49:56.640 --> 49:59.360
它为什么啥都不是呢

49:59.360 --> 50:01.120
其实还有一种情况

50:01.120 --> 50:04.480
就是两个东西根本就无法比较

50:04.480 --> 50:06.720
这就是无法比较的东西

50:06.880 --> 50:12.560
就像孙武鸿和黄中哪个更厉害

50:12.560 --> 50:13.520
没法比较

50:13.520 --> 50:14.560
一个是神话人物

50:14.560 --> 50:17.120
一个是历史人物

50:17.120 --> 50:19.120
没法比较

50:19.120 --> 50:21.760
那么这两个东西

50:21.760 --> 50:22.960
具体是怎么比较的呢

50:22.960 --> 50:23.920
看文档

50:23.920 --> 50:25.120
看这里

50:25.120 --> 50:27.600
比较运算符

50:27.600 --> 50:28.560
哪个运算符

50:28.560 --> 50:30.640
大于等于就这个

50:30.640 --> 50:32.160
转成原始

50:32.160 --> 50:33.280
怎么转成原始

50:33.360 --> 50:36.480
先转成数字

50:36.480 --> 50:38.320
有些特殊情况

50:38.320 --> 50:40.080
现在我们两个都不是特殊情况

50:40.080 --> 50:41.440
先转成数字再说

50:41.440 --> 50:44.960
那么那奥转成数字是什么呢

50:44.960 --> 50:45.440
是什么

50:45.440 --> 50:47.040
是零

50:47.040 --> 50:47.920
在看到过这吧

50:47.920 --> 50:49.120
你如果说忘了的话

50:49.120 --> 50:50.160
又去查

50:50.160 --> 50:52.080
那奥转原始转数字

50:52.080 --> 50:53.440
那奥是不是得了零

50:53.440 --> 50:55.600
NG犯的转数字呢

50:55.600 --> 50:57.920
NAN

50:57.920 --> 50:59.600
是不是这两个东西

50:59.600 --> 51:00.080
好

51:00.080 --> 51:02.080
那么这两个东西

51:03.040 --> 51:06.910
你又是不是大于NAN呢

51:06.910 --> 51:07.630
我们看一下

51:07.630 --> 51:08.990
这就有特殊情况了

51:08.990 --> 51:11.070
两端只要存在NAN

51:11.070 --> 51:12.350
一定为Force

51:12.350 --> 51:13.310
所以说零

51:13.310 --> 51:14.590
它不大于NAN

51:14.590 --> 51:16.830
也不会小于NAN

51:18.110 --> 51:19.150
懂这个意思吗

51:19.150 --> 51:20.270
好

51:20.270 --> 51:21.550
那么等于呢

51:21.550 --> 51:23.310
注意

51:23.310 --> 51:25.630
等于它这里就不是三个等号

51:25.630 --> 51:26.750
是严格相等

51:26.750 --> 51:28.350
这里我顺便说一句

51:28.350 --> 51:30.990
在实际的开发中

51:30.990 --> 51:32.830
永远不要用这个

51:33.390 --> 51:36.270
永远没有任何特殊情况

51:36.270 --> 51:37.230
实际的开发中

51:37.230 --> 51:39.310
禁止使用两个等号

51:39.310 --> 51:42.030
禁止使用一个感叹号一个等号

51:42.030 --> 51:43.470
不准用

51:43.470 --> 51:44.990
它都不是说好不好的问题

51:44.990 --> 51:46.910
根本就不准利用

51:46.910 --> 51:47.630
有些公司呢

51:47.630 --> 51:48.830
它使用了ESLint

51:48.830 --> 51:50.910
作为代码风格检查器

51:50.910 --> 51:52.510
你们以后学工成化

51:52.510 --> 51:54.750
它会学习

51:54.750 --> 51:56.030
你只要使用了这个玩意

51:56.030 --> 51:56.910
直接给你爆出

51:56.910 --> 51:58.270
不准利用

51:58.270 --> 51:59.470
所以说你们以后开发时

51:59.470 --> 52:00.510
实际上就见不到这个了

52:00.590 --> 52:03.230
这个玩意只在面试体中出现

52:03.230 --> 52:04.110
这两个问题

52:04.110 --> 52:05.230
它多的不得了

52:05.230 --> 52:08.430
这两个问题是有严重缺陷的

52:08.430 --> 52:10.510
实际上它都应该把这两个东西删除

52:10.510 --> 52:11.390
但是它不敢删

52:11.390 --> 52:13.390
因为它为了兼容性

52:13.390 --> 52:16.590
只应该保留这个和这个

52:16.590 --> 52:18.430
听懂了吗

52:18.430 --> 52:20.590
那么现在我们是三个等号

52:20.590 --> 52:20.910
注意

52:20.910 --> 52:22.190
现在不是大于小为了

52:22.190 --> 52:23.550
你不能把它转成原始类型了

52:23.550 --> 52:26.190
要看这里的规则

52:26.190 --> 52:28.110
这个规则非常简单

52:28.110 --> 52:30.830
类型和值必须要一样

52:30.830 --> 52:32.590
也就是now和undefined

52:32.590 --> 52:33.230
类型一样

52:33.230 --> 52:35.310
类型都不一样

52:35.310 --> 52:36.830
这是两种原始类型

52:36.830 --> 52:37.630
对吧

52:37.630 --> 52:39.550
说这个一定是force

52:39.550 --> 52:41.790
三个等号一定是force

52:41.790 --> 52:46.930
这就是为什么解释的都是force

52:46.930 --> 52:49.970
那如果说它写的不是三个等号呢

52:49.970 --> 52:51.650
写的是两个等号呢

52:51.650 --> 52:53.490
那又会怎么样呢

52:53.490 --> 52:55.170
那我们就看规则吧

52:55.170 --> 52:58.610
两个等号

52:58.610 --> 52:59.490
一大堆规则

52:59.490 --> 53:01.330
哎 这里有个特殊情况

53:01.410 --> 53:05.890
undefined和now只有与自身比较

53:05.890 --> 53:07.730
或者比较

53:07.730 --> 53:10.290
互相比较时

53:10.290 --> 53:11.570
才会返回处

53:11.570 --> 53:12.850
也就是说

53:12.850 --> 53:15.170
哎 两个等号这个玩意儿

53:15.170 --> 53:16.690
它会返回处

53:16.690 --> 53:18.290
它跟自己比较

53:18.290 --> 53:20.530
或者相互比较会返回处

53:20.530 --> 53:22.530
那么换句话说

53:22.530 --> 53:25.410
now等不等于0呢

53:25.410 --> 53:28.210
我用的是两个等号啊

53:28.210 --> 53:29.730
force

53:29.890 --> 53:32.850
now等不等于force呢

53:32.850 --> 53:34.450
force

53:34.450 --> 53:36.050
这是解释语言

53:36.050 --> 53:38.050
非常神奇的地方

53:38.050 --> 53:39.570
这些规则你要去背的话

53:39.570 --> 53:40.130
你要吐

53:40.130 --> 53:41.490
你绝对要吐

53:41.490 --> 53:42.530
我都要吐

53:42.530 --> 53:43.730
你千万不要去背它

53:43.730 --> 53:46.530
你要去查阅解决问题

53:46.530 --> 53:48.130
好 这是这一课

53:48.130 --> 53:49.490
你们以后面试的时候

53:49.490 --> 53:52.770
很多时候它只能够开卷面试的

53:52.770 --> 53:55.330
你可以查阅人

53:55.330 --> 53:57.890
然后是

53:57.890 --> 53:59.090
昨天是你背不住

53:59.250 --> 54:03.140
你记不住这些玩意儿

54:03.140 --> 54:04.260
好 我们来看一下这个吧

54:04.260 --> 54:05.620
好吧 这些同讯的题

54:05.620 --> 54:06.980
我们来看一下这个玩意儿

54:06.980 --> 54:08.340
其他都没有什么复杂的

54:08.340 --> 54:10.100
你按照这个规则预查就很容易查出来

54:10.100 --> 54:12.980
你会发现大厂的面试题也就这样了

54:12.980 --> 54:14.740
好 我们来看一下这个

54:14.740 --> 54:16.660
这个很有意思

54:16.660 --> 54:18.500
这个玩意儿是啥呢

54:18.500 --> 54:19.620
它是不是等于0

54:19.620 --> 54:22.500
好 我们来看一下两个等号的规则是什么

54:22.500 --> 54:26.080
两个等号的规则

54:26.080 --> 54:28.080
两段内形相同比较值

54:28.080 --> 54:30.160
两段内形肯定不是相同的

54:30.160 --> 54:31.360
不用看了

54:31.360 --> 54:32.880
两段都是原始内形

54:33.040 --> 54:34.800
它确实是原始内形

54:34.800 --> 54:36.400
转成数字比较

54:36.400 --> 54:39.840
好 那么接下来就是要把它转成数字

54:39.840 --> 54:41.040
它怎么转数字呢

54:41.040 --> 54:43.040
你要去看转换

54:43.040 --> 54:45.120
原始转数字

54:45.120 --> 54:45.920
怎么转呢

54:45.920 --> 54:48.320
制服券转数字

54:48.320 --> 54:49.840
只要是空白制服

54:49.840 --> 54:51.040
怎么叫空白制服

54:51.040 --> 54:56.000
空格 制表服 回车

54:56.000 --> 54:59.600
这是换行 空格

54:59.600 --> 55:02.000
它都是属于空白制服

55:02.160 --> 55:03.440
整个都是空白制服

55:03.440 --> 55:04.560
这个玩意儿一转换出来

55:04.560 --> 55:05.600
它就是0

55:05.600 --> 55:06.640
0是个等于0

55:06.640 --> 55:09.200
当然相等于这个玩意儿是true

55:09.200 --> 55:10.960
有意思啊

55:10.960 --> 55:12.320
那如果说是三个等号呢

55:12.320 --> 55:14.400
那肯定是force

55:14.400 --> 55:17.120
为什么 内形都不一样

55:17.120 --> 55:19.840
听懂了吗

55:19.840 --> 55:20.720
好 这是第二道题

55:20.720 --> 55:23.280
第三道题

55:23.280 --> 55:24.880
好 我们看一下第三道题

55:24.880 --> 55:26.000
网易得一道面试题

55:26.000 --> 55:27.680
我们来看一下这个

55:27.680 --> 55:29.600
其他的你们都能自己把它做出来

55:29.600 --> 55:31.440
看一下这个

55:31.440 --> 55:32.160
这个是什么呢

55:32.240 --> 55:34.320
首先 这是一个复合表达式

55:34.320 --> 55:36.800
你要先算这个

55:36.800 --> 55:38.800
这是一个加法 对不对

55:38.800 --> 55:40.240
那么加法的时候

55:40.240 --> 55:41.600
肯定要转成数字

55:41.600 --> 55:43.360
那我转数字 我已经知道了

55:43.360 --> 55:44.560
就是两个0相加

55:44.560 --> 55:47.650
那就是0

55:47.650 --> 55:50.530
undefine的转数字呢

55:50.530 --> 55:51.730
undefine的转数字

55:51.730 --> 55:53.010
那就是NAN

55:53.010 --> 55:54.850
那就是两个NAN相加

55:54.850 --> 55:56.930
两个NAN相加得到的结果

55:56.930 --> 55:59.250
还是NAN

55:59.250 --> 56:01.650
那0和NAN比较

56:01.650 --> 56:05.020
看一下规则

56:05.740 --> 56:07.900
两端存在NAN一定为force

56:07.900 --> 56:12.750
所以这个玩意儿一定是force

56:12.750 --> 56:13.790
去用这种做法

56:13.790 --> 56:14.830
你可以解决任何

56:14.830 --> 56:16.510
管它是大厂还是小厂

56:16.510 --> 56:18.030
所有的面试题都能被搞定

56:18.030 --> 56:20.270
好 这是个新东方的面试题

56:20.270 --> 56:22.670
看一下这道题

56:22.670 --> 56:24.270
这道题考察了说什么呢

56:24.270 --> 56:25.390
考察就是我们刚才说的

56:25.390 --> 56:29.150
对象转圆试类型的规则

56:29.150 --> 56:32.430
它最终问你这个玩意儿是啥

56:32.430 --> 56:33.150
这个玩意儿是啥呢

56:33.150 --> 56:35.310
你首先要把这个玩意儿算出来

56:35.310 --> 56:36.270
这个玩意儿怎么算呢

56:36.350 --> 56:38.670
其实你一看刚才有我们之前的知识

56:38.670 --> 56:39.710
一看就明白了

56:39.710 --> 56:41.470
这就是把一个东西转成布尔

56:41.470 --> 56:43.230
这个表达是

56:43.230 --> 56:44.350
对吧 两个感当号

56:44.350 --> 56:45.550
就是把一个东西转成布尔

56:45.550 --> 56:46.590
那这是个什么东西呢

56:46.590 --> 56:47.390
它是个对象

56:47.390 --> 56:48.990
对象转布尔毫无疑问

56:48.990 --> 56:50.750
它是一件事的true

56:50.750 --> 56:53.230
所以说我怎么懒

56:53.230 --> 56:55.150
我怎么懒得去看它这些玩意儿呢

56:55.150 --> 56:56.590
看它这个玩意儿有什么用呢

56:56.590 --> 56:57.710
没啥用

56:57.710 --> 56:59.310
反正转成布尔

56:59.310 --> 57:02.780
它就是一件事true

57:02.780 --> 57:05.820
好 然后OB界E

57:05.820 --> 57:07.420
OB界E是什么呢

57:07.500 --> 57:10.140
OB界E是一个对象

57:10.140 --> 57:11.340
对象加一个true

57:11.340 --> 57:13.340
那么这就是加法转数字

57:13.340 --> 57:16.140
true转数字为E

57:16.140 --> 57:17.500
不是 现在不早计转

57:17.500 --> 57:19.020
先把它转成原始类型再说

57:19.020 --> 57:20.060
但是对象

57:20.060 --> 57:23.420
转原始先调用value

57:23.420 --> 57:25.180
得到结果是什么呢

57:25.180 --> 57:26.860
1加2

57:26.860 --> 57:29.100
A加上B

57:29.100 --> 57:31.180
1加上2

57:31.180 --> 57:31.980
这等于3

57:31.980 --> 57:33.580
是不是已经得到原始值了

57:33.580 --> 57:34.540
得到原始值之后

57:34.540 --> 57:36.460
它就不会调用true

57:36.540 --> 57:39.180
那么最终结果就是3加上True

57:39.180 --> 57:41.180
3加2True是一个数字相加

57:41.180 --> 57:44.300
那么就要把这东西全转成数字

57:44.300 --> 57:45.260
True转数字E

57:45.260 --> 57:48.620
最终结果14

57:48.620 --> 57:51.580
这就是你搞定了这种规则之后

57:51.580 --> 57:53.660
你做任何的体验就完全不虚了

57:53.660 --> 57:56.540
就非常非常的有信心

57:56.540 --> 57:57.340
你就不需要说

57:57.340 --> 57:59.180
我知道你做过了我才有信心

57:59.180 --> 58:00.220
没做过我就没有信心

58:00.220 --> 58:00.780
不需要了

58:00.780 --> 58:02.300
你只要搞定了规则

58:02.300 --> 58:03.500
这个东西拿到手

58:03.500 --> 58:04.700
你无敌了

58:04.700 --> 58:06.780
所谓的运算规则全部无敌了

58:06.860 --> 58:10.060
这就是咱们第一部分的内容

58:10.060 --> 58:11.580
运算规则

58:11.580 --> 58:13.260
好 看一下同学们有没有什么问题

58:13.260 --> 58:13.900
没问题的话

58:13.900 --> 58:15.260
给袁老师打个一

58:22.670 --> 58:24.670
有问题的话提出来

58:24.670 --> 58:25.790
或者是你现在想不到

58:25.790 --> 58:26.590
有什么样的问题

58:26.590 --> 58:27.150
没关系

58:27.150 --> 58:30.670
以后在群里边也可以把问题提出来

58:30.670 --> 58:31.550
你去做一下

58:31.550 --> 58:33.790
其实这个玩意你听我讲呢

58:33.790 --> 58:36.270
听了半天其实感觉好像可以

58:36.270 --> 58:37.470
好像又不太可以

58:37.470 --> 58:39.550
好像模糊好像明白了

58:39.630 --> 58:41.150
好像又不太明白

58:41.150 --> 58:42.990
所以有这种感觉

58:42.990 --> 58:45.390
你只要下去按照这种方式去做一做

58:45.390 --> 58:47.150
试一试

58:47.150 --> 58:49.550
你觉得原来是这个样子的

58:49.550 --> 58:51.230
就像你第一次玩游戏的时候

58:51.230 --> 58:51.950
别人教你

58:51.950 --> 58:52.910
这个游戏该怎么玩

58:52.910 --> 58:54.190
听了半天好像又懂了

58:54.190 --> 58:54.910
好像也没太懂

58:54.910 --> 58:55.630
好像有点复杂

58:55.630 --> 58:56.750
好像也比较简单

58:56.750 --> 58:58.430
你去试一试

58:58.430 --> 59:00.270
多试几个问题

59:00.270 --> 59:01.950
原来是这个样子

59:01.950 --> 59:04.830
这就是学习了内化的过程

59:04.830 --> 59:08.540
这收到托到时候会发下来

59:08.540 --> 59:09.980
知识的内化

59:09.980 --> 59:11.580
其实就叫消化

59:11.580 --> 59:12.460
就像你在嘴里

59:12.460 --> 59:13.820
你看别人怎么吃饭的

59:13.820 --> 59:15.900
你看了半天你自己也没有吃饱

59:15.900 --> 59:16.940
你要自己去尝试

59:16.940 --> 59:18.780
吃一试你才知道

59:18.780 --> 59:19.900
表现美食博主说

59:19.900 --> 59:21.820
这个菜特别好吃

59:21.820 --> 59:23.260
什么味儿 什么味儿 什么味儿

59:23.260 --> 59:24.780
说了半天你也不太明白

59:24.780 --> 59:25.900
到底什么味儿呢

59:25.900 --> 59:27.820
你自己吃一下你明白

59:27.820 --> 59:29.980
能体验到最真实的感受

59:29.980 --> 59:32.380
现在一定要去试一试

59:32.380 --> 59:34.300
好 第一部分运算规则

59:34.300 --> 59:35.820
如果说这一块还有什么问题的话

59:35.820 --> 59:37.820
同学们先暂时把它放到一边

59:37.820 --> 59:39.100
我们学一个东西的时候

59:39.100 --> 59:42.140
就专心自制的学一个东西

59:42.140 --> 59:46.670
接下来是值和引用

59:46.670 --> 59:50.430
值和引用也是特别容易考察的一个知识点

59:50.430 --> 59:54.110
它跟运算规则没有太多的联系

59:54.110 --> 59:55.150
没有太大的联系

59:55.150 --> 59:57.950
那么这一块的规则是什么呢

59:57.950 --> 01:00:02.350
这里我用一些势力来给大家解释

01:00:02.350 --> 01:00:04.110
刚才我们不是说了吗

01:00:04.110 --> 01:00:06.270
咱们既然是分为两种类型

01:00:06.270 --> 01:00:08.270
对吧 一个是原始类型

01:00:08.270 --> 01:00:10.510
一个是引用类型

01:00:10.590 --> 01:00:12.750
引用类型的数组对象含述

01:00:12.750 --> 01:00:15.150
但是都统称为原始类型

01:00:15.150 --> 01:00:16.670
原始类型是多网设想的全是原始类型

01:00:16.670 --> 01:00:20.910
Mao, Andi Fan, ZifuChuan, Bulin, Shuzi

01:00:20.910 --> 01:00:23.310
这些都是原始类型

01:00:24.590 --> 01:00:28.750
那么它们之间除了运算之外

01:00:28.750 --> 01:00:32.750
在存储上它也是有一些区别的

01:00:32.750 --> 01:00:33.870
我举个例子

01:00:33.870 --> 01:00:35.470
我们先从简单的开始说起

01:00:35.470 --> 01:00:40.030
这一块其实也是出现问题比较多的地方

01:00:40.270 --> 01:00:42.750
比方说我们定一个变量给它复制为一个1

01:00:42.750 --> 01:00:45.950
那么这句话到底是什么意思

01:00:46.830 --> 01:00:49.230
它导致我们计算机里面的内存

01:00:49.230 --> 01:00:50.910
它发生了什么样的变化

01:00:52.270 --> 01:00:53.470
我来画个图就明白了

01:00:55.920 --> 01:00:57.840
好 这句话是什么意思呢

01:00:58.400 --> 01:01:02.800
这句话的意思就是我们新建了一个内存空间

01:01:03.440 --> 01:01:05.760
给这个内存空间的取得一个名字

01:01:06.720 --> 01:01:07.600
放个字体

01:01:07.600 --> 01:01:09.440
取了个名字 大家取了一个A

01:01:10.080 --> 01:01:10.720
能看见吗

01:01:12.400 --> 01:01:15.120
然后我们新建了一块内存空间

01:01:15.920 --> 01:01:19.040
然后往内存空间里面放了一个1

01:01:19.040 --> 01:01:22.320
注意这个1它是原始类型

01:01:23.200 --> 01:01:26.640
原始类型是直接把它的纸直接放进去的

01:01:28.850 --> 01:01:29.330
就是这样

01:01:29.970 --> 01:01:30.930
没有什么特别的

01:01:31.490 --> 01:01:33.170
就直接把它的纸直接放进去了

01:01:34.210 --> 01:01:36.210
好 这就是对这句话的理解

01:01:36.770 --> 01:01:37.810
很简单 对吧

01:01:38.210 --> 01:01:39.650
好 那么接下来我们来看一下

01:01:40.290 --> 01:01:42.050
我们再定一个变量B

01:01:42.130 --> 01:01:44.450
把A复制给B 这又是什么意思呢

01:01:45.330 --> 01:01:48.690
这句话表示新建一个内存空间

01:01:49.810 --> 01:01:51.170
给它取个名字叫做B

01:01:52.210 --> 01:01:53.570
B里面存什么呢

01:01:54.210 --> 01:02:00.050
把A的纸取出来复制粘贴

01:02:00.050 --> 01:02:00.770
听好了

01:02:01.410 --> 01:02:03.410
它不是说把A剪切粘贴

01:02:04.370 --> 01:02:06.290
剪切粘贴这种事也不要去做

01:02:06.850 --> 01:02:08.850
应该是复制粘贴

01:02:10.960 --> 01:02:12.400
好 复制粘贴过来

01:02:14.320 --> 01:02:14.800
记住

01:02:15.760 --> 01:02:20.880
这种数据的传递永远是复制粘贴

01:02:21.440 --> 01:02:22.480
没有变的情况

01:02:23.760 --> 01:02:24.400
再说一次

01:02:24.720 --> 01:02:29.520
这种数据的传递永远是复制粘贴

01:02:30.880 --> 01:02:32.960
就是这种变量给另外一个变量

01:02:33.280 --> 01:02:35.920
就把这个变量的内容复制粘贴过来

01:02:36.880 --> 01:02:40.800
所以说一会儿我给B加1之后

01:02:41.760 --> 01:02:42.480
加到是谁

01:02:42.480 --> 01:02:44.080
加到是这个内存空间的纸

01:02:44.480 --> 01:02:45.440
跟它有关系吗

01:02:45.840 --> 01:02:46.560
没有关系

01:02:47.520 --> 01:02:49.200
所以这个代码最终的结果是啥呀

01:02:56.380 --> 01:02:57.740
输出一个A和B

01:02:57.740 --> 01:02:59.580
那就是直接结果就是1和2

01:02:59.820 --> 01:03:00.140
对吧

01:03:00.540 --> 01:03:01.180
1和2

01:03:03.660 --> 01:03:04.220
能理解吗

01:03:05.100 --> 01:03:06.700
好 咱们再来看

01:03:07.660 --> 01:03:09.820
我把这个协访给它改一下

01:03:10.300 --> 01:03:12.140
A变成了N等于B

01:03:12.860 --> 01:03:14.300
B变成了还是一样

01:03:14.300 --> 01:03:16.460
这里B点N加加

01:03:16.460 --> 01:03:18.060
然后我们输出A点N

01:03:19.260 --> 01:03:20.700
然后再输出B点N

01:03:20.700 --> 01:03:21.900
我们来看一下这个代码

01:03:21.900 --> 01:03:23.260
它又是怎么回事

01:03:23.740 --> 01:03:24.540
给它写个图

01:03:26.460 --> 01:03:26.860
好

01:03:27.900 --> 01:03:28.940
我们把小说点

01:03:33.780 --> 01:03:34.420
看一下这个代码

01:03:35.060 --> 01:03:36.260
首先还是一样

01:03:37.860 --> 01:03:38.740
这句话来干嘛

01:03:38.980 --> 01:03:41.700
这句话在创建的一个变量A

01:03:44.620 --> 01:03:45.820
创建的一个变量A

01:03:45.820 --> 01:03:47.180
最后要仔细听

01:03:49.900 --> 01:03:51.020
给它取个名字叫A

01:03:51.500 --> 01:03:52.540
它里面存的是什么

01:03:52.540 --> 01:03:53.580
这里有区别了

01:03:54.540 --> 01:03:57.820
这里存的是一个对象

01:03:59.820 --> 01:04:02.620
这个对象是什么意思啊

01:04:03.260 --> 01:04:04.140
表示说

01:04:04.140 --> 01:04:06.540
以后你们在代码里面只要看到

01:04:07.420 --> 01:04:09.660
用这种写法写了一个对象

01:04:09.660 --> 01:04:10.540
就两个大话

01:04:10.540 --> 01:04:12.060
里面有一个什么东西

01:04:13.260 --> 01:04:15.260
你只要看到是这种写法

01:04:16.220 --> 01:04:17.740
这个东西有一个名字

01:04:18.380 --> 01:04:19.340
知道什么名字吗

01:04:19.900 --> 01:04:20.620
这种写法

01:04:21.580 --> 01:04:24.780
它叫做对象字面量

01:04:28.380 --> 01:04:29.980
所以说我一定一再强调

01:04:29.980 --> 01:04:31.260
咱们学习知识

01:04:31.260 --> 01:04:32.380
不要东减一个

01:04:32.380 --> 01:04:33.100
西减一个

01:04:33.100 --> 01:04:34.700
减出来全是零碎的

01:04:35.660 --> 01:04:36.860
学的很不扎实

01:04:36.860 --> 01:04:38.140
一定要系统的学习

01:04:38.140 --> 01:04:39.340
你要系统的学习的话

01:04:39.340 --> 01:04:40.940
它非常非常早的时候

01:04:41.740 --> 01:04:43.740
我就会给你们灌输这样的一个概念

01:04:44.380 --> 01:04:44.940
字面量

01:04:46.220 --> 01:04:47.580
什么叫字面量

01:04:47.580 --> 01:04:49.820
就是直接书写的数据

01:04:49.820 --> 01:04:50.780
比方说1

01:04:50.780 --> 01:04:51.580
这不是字面量

01:04:52.300 --> 01:04:53.260
直接写的

01:04:53.260 --> 01:04:55.020
去字面量

01:04:55.020 --> 01:04:55.980
直接写的一个处

01:04:57.100 --> 01:04:57.980
abc

01:04:57.980 --> 01:04:58.460
字面量

01:04:59.180 --> 01:05:00.780
直接写的一个字符创

01:05:00.780 --> 01:05:03.100
对象也可以直接写个对象

01:05:03.100 --> 01:05:04.140
两个大个号

01:05:04.140 --> 01:05:07.180
在里面写个a等于eb等于2等于e

01:05:07.180 --> 01:05:09.100
这就是对象字面量

01:05:09.100 --> 01:05:11.820
你们以后只要看到有对象字面量

01:05:13.580 --> 01:05:14.300
做两件事

01:05:15.100 --> 01:05:15.740
第一件事

01:05:16.700 --> 01:05:19.180
新开辟一块内存空间

01:05:23.200 --> 01:05:25.520
这个内存空间里面放置属性

01:05:26.480 --> 01:05:28.240
n的值等于多少等于e

01:05:30.590 --> 01:05:31.150
能力呀

01:05:31.870 --> 01:05:32.910
放这么一个东西

01:05:34.270 --> 01:05:35.230
这是第一步

01:05:35.230 --> 01:05:35.950
第二步

01:05:35.950 --> 01:05:39.230
这块内存空间会产生一个地址

01:05:40.270 --> 01:05:42.590
就像我们的房间编号一样

01:05:42.590 --> 01:05:44.190
叫几号房几号房几号房

01:05:45.230 --> 01:05:46.270
它会产生一个地址

01:05:46.910 --> 01:05:48.830
它说地址是多少我们并不care

01:05:49.550 --> 01:05:51.230
我们又不是学着c语

01:05:51.230 --> 01:05:51.790
并不care

01:05:52.750 --> 01:05:54.350
我们只需要它知道它有一个地址

01:05:54.350 --> 01:05:55.230
有个编号就行了

01:05:57.070 --> 01:05:58.990
那么现在的问题是

01:05:58.990 --> 01:06:01.310
我们这个玩意要复纸给a

01:06:02.910 --> 01:06:03.790
复纸给a

01:06:03.790 --> 01:06:04.830
那这是什么意思呢

01:06:05.390 --> 01:06:08.270
表示的是把这个地址存到a里面去

01:06:10.030 --> 01:06:10.750
听到了吗

01:06:10.750 --> 01:06:11.790
那么也就是我们意味到

01:06:11.790 --> 01:06:12.910
这个a里面存的是什么

01:06:12.910 --> 01:06:13.950
地址e

01:06:13.950 --> 01:06:16.350
所以有的时候我们为了画图方便

01:06:16.910 --> 01:06:18.510
我直接就会画一个这个玩意

01:06:19.070 --> 01:06:20.030
表示a这个地

01:06:20.030 --> 01:06:21.390
这里面存的是一个地址e

01:06:21.470 --> 01:06:23.550
所以说a指向这个内存空间

01:06:24.590 --> 01:06:26.510
其实根本就没有什么箭头去指

01:06:26.510 --> 01:06:28.030
就是因为它存了地址e

01:06:29.390 --> 01:06:31.070
好那么接下来就有意思了

01:06:31.070 --> 01:06:32.430
就很简单后面是一样的

01:06:33.310 --> 01:06:34.190
一模一样的

01:06:36.560 --> 01:06:37.760
我们还是把箭头画上吧

01:06:39.200 --> 01:06:40.640
就因为箭头做一样的

01:06:40.640 --> 01:06:41.600
里面存了一个地址e

01:06:41.600 --> 01:06:42.480
这里就是地址e

01:06:43.360 --> 01:06:45.440
然后把a复纸给b

01:06:45.440 --> 01:06:46.400
这是啥意思呢

01:06:46.400 --> 01:06:46.960
一样的

01:06:46.960 --> 01:06:48.160
这里是没有区别的

01:06:48.160 --> 01:06:51.200
有没有说这里跟原始内形有区别

01:06:51.200 --> 01:06:52.240
没有区别

01:06:52.320 --> 01:06:52.880
一样的

01:06:54.080 --> 01:06:55.120
原始内形咋做呢

01:06:56.320 --> 01:06:58.640
新建一个没有存空间

01:06:58.640 --> 01:06:59.760
比较取个名字叫b

01:07:02.270 --> 01:07:03.230
里面是空的

01:07:03.230 --> 01:07:06.910
然后把a里面的东西复制粘贴过来

01:07:08.910 --> 01:07:09.470
看到没

01:07:10.910 --> 01:07:11.870
所以说这样子

01:07:11.870 --> 01:07:12.830
a里面存的地址e

01:07:12.830 --> 01:07:14.110
b里面也存的是地址e

01:07:14.110 --> 01:07:15.550
那就不有指过去了吗

01:07:17.950 --> 01:07:19.710
然后是b点n加加

01:07:20.110 --> 01:07:21.070
b点n加加

01:07:21.070 --> 01:07:22.190
b找到这个地址e

01:07:22.190 --> 01:07:23.550
找到的是对象对吧

01:07:23.550 --> 01:07:25.950
n加加加1就变成了2

01:07:26.830 --> 01:07:29.310
问你a点n和b点n是不一样的

01:07:29.950 --> 01:07:30.910
那就是一样的

01:07:31.710 --> 01:07:33.310
你这个玩意千万不要去背

01:07:33.310 --> 01:07:34.750
我要一定要把它背下来

01:07:34.750 --> 01:07:35.870
这道题非常典型

01:07:35.870 --> 01:07:36.510
我要背下来了

01:07:37.150 --> 01:07:38.750
这种题千变完化

01:07:39.310 --> 01:07:41.310
它可以递我出无数种画样出来

01:07:42.030 --> 01:07:42.670
不用去背

01:07:42.670 --> 01:07:44.750
你只需要知道怎么去分析就完事了

01:07:44.750 --> 01:07:45.550
就这样分析

01:07:45.550 --> 01:07:46.110
就完了

01:07:46.670 --> 01:07:48.510
任何题把你搞不定了

01:07:48.510 --> 01:07:49.710
任何题都可以搞定

01:07:50.750 --> 01:07:51.790
你可以搞定任何题了

01:07:52.910 --> 01:07:57.470
那我们又来

01:08:09.420 --> 01:08:09.900
同学们

01:08:12.080 --> 01:08:15.040
这个玩意得到结果也是啥

01:08:29.040 --> 01:08:29.920
又来吧

01:08:29.920 --> 01:08:33.040
你只要学过了分析方法

01:08:33.040 --> 01:08:35.440
你就能搞定所有的这种问题

01:08:36.320 --> 01:08:38.000
千万不要去背题

01:08:38.000 --> 01:08:39.600
背题是注意啥的

01:08:39.600 --> 01:08:40.560
背题啥到什么程度

01:08:40.560 --> 01:08:44.080
就好像我们要去背全世界所有的加法

01:08:44.080 --> 01:08:44.880
或者是惩罚

01:08:45.440 --> 01:08:46.080
何必呢

01:08:46.800 --> 01:08:48.560
惩罚表求就惩罚表学校过后

01:08:48.560 --> 01:08:49.680
全部惩罚都可以搞定的

01:08:50.400 --> 01:08:52.320
然后以及万议我都可以搞定

01:08:52.320 --> 01:08:53.920
只是慢了一点而已

01:08:54.720 --> 01:08:57.760
加法表只要我知道一到十的加法一接

01:08:58.320 --> 01:08:59.040
如何尽位

01:08:59.520 --> 01:09:01.520
我就能搞定所有数字的加法了

01:09:02.320 --> 01:09:03.840
所以你不要去背题

01:09:03.840 --> 01:09:05.040
这太傻了

01:09:05.040 --> 01:09:06.560
一开始是一样的

01:09:06.560 --> 01:09:08.080
地址一 n 等于一

01:09:09.280 --> 01:09:10.640
然后A 里面存那个地址一

01:09:10.640 --> 01:09:12.240
就这一部分的东西是一样的

01:09:12.240 --> 01:09:12.480
对吧

01:09:12.480 --> 01:09:13.360
没有什么区别

01:09:13.760 --> 01:09:15.120
然后接下来还是一样的

01:09:15.120 --> 01:09:16.800
给生成一个B

01:09:17.760 --> 01:09:21.040
然后把一里面的地址复制粘贴过来

01:09:21.040 --> 01:09:23.360
这样子的A的地址指向这个

01:09:23.360 --> 01:09:24.960
B的地址指向这个

01:09:24.960 --> 01:09:25.760
是一样的

01:09:26.320 --> 01:09:27.680
然后接下来有意思了

01:09:31.490 --> 01:09:32.450
这是要干嘛

01:09:33.170 --> 01:09:33.890
这是要干嘛

01:09:34.450 --> 01:09:36.210
对象字面那样

01:09:36.210 --> 01:09:36.770
啥意思啊

01:09:37.650 --> 01:09:40.130
创建一个新的对象

01:09:40.130 --> 01:09:41.010
我说了啊

01:09:41.010 --> 01:09:42.050
看到这个玩意儿

01:09:42.050 --> 01:09:43.810
马上要想到一个新的东西产生了

01:09:45.010 --> 01:09:46.210
一个土区你n得有2

01:09:46.210 --> 01:09:47.410
还有另外一个地址

01:09:47.410 --> 01:09:48.370
叫地址2

01:09:49.330 --> 01:09:50.370
然后干嘛

01:09:50.370 --> 01:09:55.330
把这个对象复制给B

01:09:55.330 --> 01:09:57.410
那么也就是把个地址

01:09:57.410 --> 01:09:59.330
重新给它覆盖到B里面去

01:09:59.330 --> 01:10:01.970
重新复制就是覆盖嘛

01:10:01.970 --> 01:10:04.370
把地址2覆盖过去

01:10:04.370 --> 01:10:06.930
所以说B就不再指向地址1了

01:10:06.930 --> 01:10:08.370
指向的是地址2

01:10:08.370 --> 01:10:09.570
那现在A和B一样嘛

01:10:09.570 --> 01:10:10.370
又不一样了

01:10:10.370 --> 01:10:12.050
A.n等于1

01:10:12.050 --> 01:10:13.250
B.n等于2

01:10:13.250 --> 01:10:15.090
所以后得到的结果是1和2

01:10:15.090 --> 01:10:18.610
你只要学会分析方法

01:10:18.610 --> 01:10:20.450
你还能够复制无敌的这个玩意儿

01:10:20.450 --> 01:10:22.050
你还复制无敌

01:10:22.050 --> 01:10:22.930
随便它怎么玩

01:10:22.930 --> 01:10:24.370
你都玩不动你

01:10:24.370 --> 01:10:28.050
反正你特别不好玩

01:10:28.050 --> 01:10:29.650
那比如说我再来给它变一下

01:10:29.650 --> 01:10:34.370
我再来一个B.n加加

01:10:34.370 --> 01:10:36.130
B.n加加又会怎么样呢

01:10:36.130 --> 01:10:37.090
那就加没

01:10:37.090 --> 01:10:38.450
把那个B的n加1

01:10:38.450 --> 01:10:40.770
那不是E3吗

01:10:40.770 --> 01:10:41.490
那就是E3

01:10:43.490 --> 01:10:44.690
是吧

01:10:44.690 --> 01:10:45.490
懂得意思吗

01:10:46.770 --> 01:10:47.890
那又可能有误解

01:10:48.210 --> 01:10:50.690
如果说我一开始是n等于1呢

01:10:50.690 --> 01:10:52.050
那这两个对象是不是一样的

01:10:52.050 --> 01:10:52.850
是不是一样的

01:10:52.850 --> 01:10:54.610
不是一样的

01:10:54.610 --> 01:10:55.170
为啥呢

01:10:55.170 --> 01:10:56.770
你只要看到字面亮

01:10:56.770 --> 01:10:58.370
它一定是创建一个新的东西

01:10:58.370 --> 01:11:00.210
哪怕它里边的东西一模一样

01:11:00.210 --> 01:11:03.010
它也是创建了一个新的东西

01:11:03.010 --> 01:11:05.090
那后边B的n加加

01:11:05.090 --> 01:11:05.730
它变成2

01:11:05.730 --> 01:11:06.530
它有关系吗

01:11:06.530 --> 01:11:07.890
没关系

01:11:07.890 --> 01:11:11.220
那就是1和2

01:11:11.220 --> 01:11:13.730
1和2

01:11:13.730 --> 01:11:15.330
看到没

01:11:15.330 --> 01:11:16.610
就是这么玩的

01:11:16.610 --> 01:11:17.570
这种题就是这么玩的

01:11:17.570 --> 01:11:18.850
没有什么特别的

01:11:18.930 --> 01:11:21.810
那如果说遇到更复杂的情况

01:11:22.850 --> 01:11:23.970
举个例子

01:11:23.970 --> 01:11:25.250
遇到一个更复杂的情况

01:11:25.250 --> 01:11:26.290
比方说

01:11:26.290 --> 01:11:28.370
原谅身体怎么来解释这个

01:11:29.250 --> 01:11:30.210
你说那个地址呢

01:11:30.210 --> 01:11:32.690
我大概能明白了

01:11:32.690 --> 01:11:35.010
但是你怎么来解释这个东西

01:11:35.010 --> 01:11:35.890
你给我解释一下

01:11:35.890 --> 01:11:37.170
它的内存是怎么分布的

01:11:37.170 --> 01:11:38.210
那我就给你解释

01:11:48.980 --> 01:11:50.740
这个玩意有点意思

01:11:50.740 --> 01:11:51.620
这个是一个对象

01:11:51.620 --> 01:11:52.580
这里又是一个对象

01:11:52.580 --> 01:11:54.260
那这个玩意是怎么解释呢

01:11:54.820 --> 01:11:55.780
它这么解释

01:11:58.340 --> 01:11:59.300
你看着

01:11:59.380 --> 01:12:00.420
这个玩意又咋解释

01:12:03.980 --> 01:12:05.980
首先你看到这个没

01:12:05.980 --> 01:12:06.780
这是一个啥

01:12:06.780 --> 01:12:08.060
对象字面亮

01:12:08.060 --> 01:12:09.260
应该怎么样

01:12:09.260 --> 01:12:12.860
应该先生成一个对象

01:12:14.940 --> 01:12:15.980
这个对象有个地址

01:12:15.980 --> 01:12:16.860
这个地址是啥呢

01:12:16.860 --> 01:12:17.420
随便写个吧

01:12:17.420 --> 01:12:17.900
地址A

01:12:19.180 --> 01:12:20.460
地址E 地址A都行

01:12:21.020 --> 01:12:21.820
它几个属性

01:12:21.820 --> 01:12:22.460
两个属性

01:12:23.180 --> 01:12:23.820
Nem数啥

01:12:25.260 --> 01:12:26.060
Nem数啥

01:12:26.060 --> 01:12:26.860
一个字符串

01:12:26.860 --> 01:12:28.060
原始内形对吧

01:12:28.060 --> 01:12:28.700
直接写

01:12:28.700 --> 01:12:29.180
张三

01:12:30.140 --> 01:12:31.900
原始内形张三

01:12:33.420 --> 01:12:34.620
还有一个什么呢

01:12:34.620 --> 01:12:36.940
还有一个ADDR属性

01:12:38.940 --> 01:12:39.740
每个属性

01:12:39.740 --> 01:12:40.780
因为它每个属性

01:12:40.780 --> 01:12:42.300
也是一块内存空间

01:12:42.860 --> 01:12:43.020
好

01:12:43.020 --> 01:12:43.900
那注意啊

01:12:43.900 --> 01:12:45.740
ADDR这个属性是啥呀

01:12:45.740 --> 01:12:46.220
同学们

01:12:46.700 --> 01:12:47.340
它是啥

01:12:47.740 --> 01:12:48.940
不又是一个对象吗

01:12:50.380 --> 01:12:51.580
这是不是对象字面亮

01:12:52.060 --> 01:12:53.180
这又是对象字面亮

01:12:53.180 --> 01:12:53.900
应该怎么办呀

01:12:53.900 --> 01:12:54.780
对象字面亮

01:12:54.780 --> 01:12:57.420
应该去新建一块内存空间

01:13:00.910 --> 01:13:02.590
新建一块内存空间

01:13:03.550 --> 01:13:04.590
里面有两个属性

01:13:04.590 --> 01:13:05.470
一个是Promise

01:13:06.670 --> 01:13:07.230
江苏

01:13:08.750 --> 01:13:09.550
还有一个属性呢

01:13:09.550 --> 01:13:12.270
是City

01:13:14.690 --> 01:13:15.250
南京

01:13:16.530 --> 01:13:16.770
好

01:13:16.770 --> 01:13:18.050
这个对象是不是有个地址

01:13:18.930 --> 01:13:19.650
有个地址

01:13:21.250 --> 01:13:21.810
地址B

01:13:22.290 --> 01:13:22.450
好

01:13:22.450 --> 01:13:23.490
那么这个是什么意思

01:13:24.130 --> 01:13:25.410
把这个对象给谁

01:13:26.050 --> 01:13:27.970
给这个ADDR这个属性

01:13:27.970 --> 01:13:29.010
是什么意思啊

01:13:29.010 --> 01:13:30.850
就是把这个地址B给谁

01:13:31.010 --> 01:13:32.210
给这个ADDR

01:13:32.850 --> 01:13:35.090
所以说这个ADDR里面写的是什么呀

01:13:35.090 --> 01:13:36.210
谁的是地址B

01:13:36.690 --> 01:13:39.010
我们也可以用一个箭头来表示一下

01:13:39.010 --> 01:13:40.530
地址B指向这个玩意儿

01:13:43.120 --> 01:13:44.320
指向整个这个对象

01:13:44.960 --> 01:13:45.680
看到了吗

01:13:45.680 --> 01:13:46.640
所以我们后边

01:13:47.200 --> 01:13:48.400
然后再把这个OB界

01:13:49.040 --> 01:13:50.320
再创建过内存空间

01:13:50.320 --> 01:13:51.200
这是OB界

01:13:53.040 --> 01:13:54.000
里面存的是什么

01:13:54.000 --> 01:13:55.360
存的是地址A

01:13:56.080 --> 01:13:57.200
所以我们可以认为

01:13:57.200 --> 01:13:59.040
OB界指向这个地址A

01:14:00.480 --> 01:14:01.680
因此我们当时比方说

01:14:01.760 --> 01:14:02.720
我要得到一个属性

01:14:04.960 --> 01:14:08.560
OB界点什么ADDR点City

01:14:09.040 --> 01:14:09.840
什么意思

01:14:09.840 --> 01:14:12.640
OB界里面是什么地址A

01:14:12.640 --> 01:14:13.200
找到谁

01:14:13.200 --> 01:14:14.080
找到这个玩意儿

01:14:15.040 --> 01:14:17.200
然后在点ADDR找到什么

01:14:17.200 --> 01:14:18.000
找到这个玩意儿

01:14:18.720 --> 01:14:19.440
这个玩意儿是啥

01:14:19.440 --> 01:14:20.080
说这个玩意儿

01:14:20.640 --> 01:14:21.920
然后在点City

01:14:22.160 --> 01:14:23.360
说找到这个玩意儿

01:14:23.360 --> 01:14:23.840
南京

01:14:24.800 --> 01:14:25.680
它就是这么找的

01:14:26.480 --> 01:14:28.080
那如果说在四层结构了

01:14:28.080 --> 01:14:29.520
三层结构五层结构了

01:14:29.520 --> 01:14:30.240
一样的

01:14:30.880 --> 01:14:31.200
对吧

01:14:31.200 --> 01:14:32.480
这样子一层一层套下去

01:14:33.280 --> 01:14:34.080
能理解吗

01:14:34.080 --> 01:14:34.880
这就是

01:14:35.520 --> 01:14:37.440
如果来分析这个内存结构图

01:14:37.760 --> 01:14:40.080
就是你们以后在做面试题的时候

01:14:40.080 --> 01:14:42.560
遇到那种值和引用的这种题

01:14:43.440 --> 01:14:46.960
你只要能够把内存结构给它分析出来

01:14:46.960 --> 01:14:48.880
这道题随便它怎么玩的

01:14:50.160 --> 01:14:51.520
你都可以把它做出来

01:14:51.520 --> 01:14:52.640
都可以搞定的

01:15:02.370 --> 01:15:02.850
好

01:15:03.650 --> 01:15:04.370
咱们来看题

01:15:05.730 --> 01:15:07.010
下边那把输出什么

01:15:07.010 --> 01:15:07.730
那就花呗

01:15:08.610 --> 01:15:10.370
花出来该输出啥就输出啥

01:15:11.730 --> 01:15:12.450
好结构图

01:15:13.730 --> 01:15:15.730
这种题你们以后在面试中当中

01:15:16.930 --> 01:15:18.450
你们一定要画图啊

01:15:18.450 --> 01:15:18.850
同学们

01:15:18.850 --> 01:15:19.890
你千万不要那个

01:15:20.690 --> 01:15:21.730
不要忙做

01:15:21.730 --> 01:15:22.930
千万不要忙做

01:15:22.930 --> 01:15:24.290
要忙做很容易出错了

01:15:24.290 --> 01:15:25.330
这种题它一般就可以绕

01:15:25.810 --> 01:15:26.770
各种绕你

01:15:26.770 --> 01:15:27.810
各种噁心你

01:15:27.810 --> 01:15:28.450
故意的

01:15:31.500 --> 01:15:33.180
你只要你只要能把图

01:15:33.180 --> 01:15:34.220
图画出来就无敌

01:15:34.220 --> 01:15:34.620
但是呢

01:15:34.620 --> 01:15:35.180
你不画图

01:15:35.900 --> 01:15:36.860
我都有可能做错

01:15:37.820 --> 01:15:39.580
我都一定要画图啊

01:15:40.860 --> 01:15:41.340
来吧

01:15:43.340 --> 01:15:44.220
画呗

01:15:44.780 --> 01:15:45.820
首先哪一个堆箱

01:15:45.820 --> 01:15:47.340
哪个内存空间

01:15:47.340 --> 01:15:48.220
然后是什么呀

01:15:48.220 --> 01:15:49.340
一边一个附

01:15:51.180 --> 01:15:52.220
你们将来在

01:15:53.180 --> 01:15:54.540
咱们后续的学习啊

01:15:54.540 --> 01:15:56.220
我们这几天可能不设计了

01:15:56.220 --> 01:15:58.220
后续的学习会学习堆盒站

01:15:58.220 --> 01:15:59.820
其实蓝色的就是堆

01:15:59.820 --> 01:16:00.940
蓝色的就是站

01:16:00.940 --> 01:16:02.460
刚才那个黄色的就是堆

01:16:03.340 --> 01:16:05.340
只是我们每次名区给你们说而已

01:16:05.500 --> 01:16:07.500
因为它的回设计到另外一些知识

01:16:08.700 --> 01:16:09.180
好

01:16:09.180 --> 01:16:09.980
这里面是红的

01:16:09.980 --> 01:16:15.020
等着了呀

01:16:15.020 --> 01:16:15.820
等什么呀

01:16:15.820 --> 01:16:16.940
这里有个堆箱

01:16:17.580 --> 01:16:18.380
有个堆箱

01:16:18.380 --> 01:16:22.780
堆箱里面有几个属箱

01:16:22.780 --> 01:16:24.780
两个n等于什么0

01:16:25.500 --> 01:16:26.700
还有个什么k

01:16:27.980 --> 01:16:28.940
k等于什么

01:16:28.940 --> 01:16:30.140
所以又是一个堆箱

01:16:30.780 --> 01:16:31.260
来吧

01:16:31.260 --> 01:16:32.780
又有一个新的堆箱

01:16:33.660 --> 01:16:35.660
堆箱里面就只有一个属箱

01:16:35.660 --> 01:16:36.460
n等于0

01:16:37.340 --> 01:16:38.300
它指向它

01:16:38.300 --> 01:16:39.580
那又意味着

01:16:39.580 --> 01:16:40.860
它这也是一个地址

01:16:40.940 --> 01:16:42.940
我懒得写去写这个地址的

01:16:42.940 --> 01:16:44.460
你们能看得懂就行了

01:16:45.020 --> 01:16:45.980
能看懂吗

01:16:45.980 --> 01:16:47.020
应该能看懂

01:16:47.020 --> 01:16:48.460
我就直接这样

01:16:49.580 --> 01:16:51.020
我就这样写了

01:16:51.020 --> 01:16:52.140
表示这里有个地址

01:16:52.140 --> 01:16:54.850
指向这个

01:16:54.850 --> 01:16:56.450
我又懒得写这个地址了

01:16:56.450 --> 01:16:57.810
然后这里

01:16:57.810 --> 01:16:58.850
附

01:16:59.810 --> 01:17:01.330
它指向整个这个对象

01:17:01.330 --> 01:17:01.890
对吧

01:17:01.890 --> 01:17:03.250
那我就画一个

01:17:03.250 --> 01:17:04.770
我就指到这吧

01:17:04.770 --> 01:17:06.770
指到这表示

01:17:06.770 --> 01:17:08.290
指向整个这个对象

01:17:09.570 --> 01:17:10.690
然后这里

01:17:10.690 --> 01:17:11.970
整个这个对象

01:17:11.970 --> 01:17:13.250
没问题吧

01:17:13.250 --> 01:17:15.570
那就变成这样的一个结构了

01:17:15.570 --> 01:17:17.090
那这里边肯定是一个地址

01:17:17.090 --> 01:17:22.620
这边肯定是一个地址

01:17:22.620 --> 01:17:23.900
变成这种结构

01:17:23.900 --> 01:17:25.420
然后接下来是这句话

01:17:25.420 --> 01:17:27.500
k等于bar

01:17:27.500 --> 01:17:27.980
来吧

01:17:27.980 --> 01:17:32.320
它这里有个bar

01:17:32.320 --> 01:17:33.840
把谁负责给它

01:17:33.840 --> 01:17:34.880
把负掉k

01:17:34.880 --> 01:17:35.520
k是什么

01:17:35.520 --> 01:17:36.400
是不是这个地址

01:17:36.400 --> 01:17:38.080
把k这个地址

01:17:38.080 --> 01:17:39.120
它里面存了一个地址

01:17:39.120 --> 01:17:40.000
负责给到它

01:17:40.000 --> 01:17:41.680
那么也就意味着它里面的地址

01:17:41.680 --> 01:17:42.800
是不是也指向它了

01:17:43.520 --> 01:17:45.040
这是一个对象

01:17:45.040 --> 01:17:46.640
指向它了

01:17:46.640 --> 01:17:48.160
没问题吧

01:17:48.160 --> 01:17:50.000
没问题

01:17:50.000 --> 01:17:51.280
然后再来

01:17:51.280 --> 01:17:53.440
bar点

01:17:53.440 --> 01:17:54.320
n加加

01:17:54.320 --> 01:17:56.000
是不是它加1

01:17:56.000 --> 01:17:58.320
它就加1呗

01:17:58.320 --> 01:17:59.760
然后bar又等于什么

01:17:59.760 --> 01:18:00.960
一个新的对象

01:18:00.960 --> 01:18:03.280
注意 这一定是一个新的对象

01:18:03.280 --> 01:18:06.000
所以说你这里要创建一个新的对象

01:18:06.000 --> 01:18:08.400
n等于10

01:18:08.400 --> 01:18:10.000
然后把这个对象的地址给谁

01:18:10.000 --> 01:18:10.640
给bar

01:18:10.800 --> 01:18:12.400
说bar的地址变了

01:18:12.400 --> 01:18:14.800
变成指向它了

01:18:14.800 --> 01:18:16.400
然后再来

01:18:16.400 --> 01:18:17.840
各种绕点

01:18:17.840 --> 01:18:20.080
负等于bar

01:18:20.080 --> 01:18:22.080
又把bar重新给负责

01:18:22.080 --> 01:18:23.440
负在哪

01:18:23.440 --> 01:18:24.720
负在这

01:18:24.720 --> 01:18:26.640
把负有重新负责给bar

01:18:26.640 --> 01:18:28.560
那么现在bar又指向谁了

01:18:28.560 --> 01:18:31.760
bar又指向它了

01:18:31.760 --> 01:18:33.360
又指向这个对象了

01:18:33.360 --> 01:18:36.160
又指向这个对象了

01:18:36.160 --> 01:18:37.040
反正各种绕点

01:18:37.040 --> 01:18:37.840
随便它怎么绕

01:18:37.840 --> 01:18:39.680
你都能够清楚地搞定

01:18:39.680 --> 01:18:43.120
然后是什么bar点n加加

01:18:43.120 --> 01:18:45.280
bar点n加加bar点n加加

01:18:45.280 --> 01:18:47.760
就它加1呗

01:18:47.760 --> 01:18:49.120
然后又怎么样呢

01:18:49.120 --> 01:18:53.600
然后又是负点n等于bar

01:18:53.600 --> 01:18:55.280
负点n

01:18:55.280 --> 01:18:56.240
n的指是谁

01:18:56.240 --> 01:18:58.000
n的指是1等于bar

01:18:58.000 --> 01:18:59.680
那现在它里面不是对象了

01:18:59.680 --> 01:19:01.600
变成一个数字1了

01:19:01.600 --> 01:19:05.040
bar的指是1

01:19:05.040 --> 01:19:06.000
它各种恶性

01:19:06.000 --> 01:19:08.480
它就是为了恶性力的

01:19:08.560 --> 01:19:11.440
但是你不要让它得逞

01:19:11.440 --> 01:19:12.480
然后干嘛呀

01:19:12.480 --> 01:19:14.400
然后是bar加加

01:19:14.400 --> 01:19:15.440
那就是把谁加1

01:19:15.440 --> 01:19:16.400
把它自身加1

01:19:16.400 --> 01:19:17.600
2

01:19:17.600 --> 01:19:18.800
好 最后输出

01:19:18.800 --> 01:19:19.360
输出谁

01:19:19.360 --> 01:19:20.880
负点n输出解

01:19:20.880 --> 01:19:22.240
输出1

01:19:22.240 --> 01:19:25.520
负点k点n

01:19:25.520 --> 01:19:28.400
负点k点n输出还是1

01:19:28.400 --> 01:19:30.080
就两个1

01:19:30.080 --> 01:19:31.760
那两个1就两个1呗

01:19:31.760 --> 01:19:32.400
好 地道题

01:19:32.400 --> 01:19:36.080
我们输出的结果就是两个1

01:19:36.080 --> 01:19:36.720
你看懂吗

01:19:36.720 --> 01:19:37.920
其实我看得到题

01:19:37.920 --> 01:19:40.560
我都不知道它的结果是多少

01:19:40.560 --> 01:19:41.920
这道题我已经出了

01:19:41.920 --> 01:19:43.840
这个这道地道题是我出的

01:19:43.840 --> 01:19:46.240
还有其他的题是面试题

01:19:46.240 --> 01:19:48.160
那都是好久以前整理的

01:19:48.160 --> 01:19:50.320
我觉得都不知道它的结果是多少

01:19:50.320 --> 01:19:53.040
但是按照这个分析是肯定是没问题的

01:19:53.040 --> 01:19:56.500
知道了

01:19:56.500 --> 01:19:57.460
好 这就是地道题

01:19:57.460 --> 01:19:58.420
那我们来看一下吧

01:19:58.420 --> 01:19:58.820
第二条题

01:19:58.820 --> 01:20:02.020
我们来看大厂的面试题又怎么样

01:20:02.020 --> 01:20:03.140
有多恐怖

01:20:03.140 --> 01:20:06.740
我们来看一下有多恐怖吗

01:20:06.740 --> 01:20:07.540
那当然面试题呢

01:20:07.540 --> 01:20:08.820
考到一些别的知识

01:20:08.820 --> 01:20:09.940
但是它主要考的

01:20:09.940 --> 01:20:12.740
还是对象只合应用的知识

01:20:12.740 --> 01:20:14.740
京东的面试题

01:20:14.740 --> 01:20:16.100
又来呗

01:20:16.100 --> 01:20:18.100
看京东的面试题多可怕

01:20:18.100 --> 01:20:18.820
有多可怕吗

01:20:18.820 --> 01:20:21.140
也没多可怕

01:20:21.140 --> 01:20:23.060
好 来一个首先第一课

01:20:23.060 --> 01:20:24.820
开幕就是什么一个对象

01:20:24.820 --> 01:20:31.360
一个附

01:20:31.360 --> 01:20:32.160
它里面是什么

01:20:32.160 --> 01:20:35.200
它里面是一个对象

01:20:35.200 --> 01:20:38.800
对象里面一个属性n等于1

01:20:38.800 --> 01:20:40.160
知道吧

01:20:40.160 --> 01:20:44.720
然后附里面一个附就指向这个

01:20:44.800 --> 01:20:47.600
它里面存了个地址

01:20:47.600 --> 01:20:49.600
它指向这个东西

01:20:49.600 --> 01:20:50.720
好 接下来

01:20:50.720 --> 01:20:52.080
这是在干啥呀

01:20:52.080 --> 01:20:53.840
同学们知道这是在干啥吧

01:20:53.840 --> 01:20:56.240
这是创建一个数组

01:20:56.240 --> 01:20:58.080
创建数组跟创建对象一样

01:20:58.080 --> 01:21:01.360
一定是开辟一个新的美唇空间

01:21:01.360 --> 01:21:03.520
创建对象跟创建数组跟创建对象一样

01:21:03.520 --> 01:21:06.240
也是开辟新的美唇空间

01:21:06.240 --> 01:21:07.680
数组其实就是对象

01:21:07.680 --> 01:21:08.880
知道吧

01:21:08.880 --> 01:21:09.680
在接也是里面

01:21:09.680 --> 01:21:10.800
数组就是对象

01:21:10.800 --> 01:21:13.920
只不过它的属性0是下标

01:21:14.000 --> 01:21:18.500
属性0是一个下标

01:21:18.500 --> 01:21:20.020
属性的值是什么呢

01:21:20.020 --> 01:21:22.900
下标为0的地方是一个负

01:21:22.900 --> 01:21:25.060
那就相当于是把负的地址

01:21:25.060 --> 01:21:26.500
它里面是存的地址

01:21:26.500 --> 01:21:27.460
把这个地址放到哪儿

01:21:27.460 --> 01:21:28.180
放到这儿

01:21:28.180 --> 01:21:30.420
于是0是不是一个地址

01:21:30.420 --> 01:21:31.620
它是一样的

01:21:31.620 --> 01:21:35.220
它里面的地址放到一个数组的第一项

01:21:35.220 --> 01:21:36.900
放到这个数组的第一项

01:21:36.900 --> 01:21:39.060
它里面也有一个地址吗

01:21:39.060 --> 01:21:40.900
这里存的也是一个地址吗

01:21:40.900 --> 01:21:42.900
那这个地址指向谁

01:21:42.900 --> 01:21:44.180
指向谁

01:21:44.580 --> 01:21:46.180
不也指向它吗

01:21:53.140 --> 01:21:54.180
是不是道理吧

01:21:54.180 --> 01:21:55.780
这0这个位置它也是个地址

01:21:55.780 --> 01:21:56.580
也指向谁啊

01:21:56.580 --> 01:21:58.100
指向它

01:21:58.100 --> 01:22:04.020
把这个样式稍微改动一下

01:22:04.020 --> 01:22:09.230
就这样

01:22:09.230 --> 01:22:11.150
就变成这样的一种格式了

01:22:11.150 --> 01:22:12.990
然后把这个数组给谁

01:22:12.990 --> 01:22:15.310
给辨量ARR

01:22:15.310 --> 01:22:17.070
于是这个辨量ARR

01:22:17.070 --> 01:22:18.030
其实我现在都不知道

01:22:18.030 --> 01:22:21.550
这到底要干什么

01:22:21.550 --> 01:22:22.190
但是无所谓

01:22:22.190 --> 01:22:23.230
就把这个地址画出来

01:22:23.230 --> 01:22:25.390
它肯定就逃不出去了

01:22:25.390 --> 01:22:26.430
然后有三个方法

01:22:26.430 --> 01:22:27.550
这三个方法现在还没有

01:22:27.550 --> 01:22:28.910
这三个方法现在还没有调用

01:22:28.910 --> 01:22:29.870
你都不理它

01:22:29.870 --> 01:22:31.470
我们主要是看调用

01:22:31.470 --> 01:22:35.470
首先没事的E把ARR传进去

01:22:35.470 --> 01:22:38.750
再进入没事的E注意

01:22:38.750 --> 01:22:40.270
进入到没事的E方法

01:22:40.270 --> 01:22:41.310
这里有个参数

01:22:41.310 --> 01:22:43.070
它的名字也叫ARR

01:22:43.070 --> 01:22:45.390
但是这个ARR

01:22:45.390 --> 01:22:49.310
跟这个ARR是不是一个东西

01:22:49.310 --> 01:22:50.670
不是

01:22:50.750 --> 01:22:53.230
它们剩两块内存空间

01:22:53.230 --> 01:22:56.430
这个ARR就涉及到作用预议了

01:22:56.430 --> 01:22:58.110
参数

01:22:58.110 --> 01:23:00.190
跟这个ARR跟外面的权距变量

01:23:00.190 --> 01:23:01.230
是两个东西

01:23:01.230 --> 01:23:02.350
不是一个东西

01:23:02.350 --> 01:23:03.870
一想搞清楚

01:23:03.870 --> 01:23:05.070
那么这里呢

01:23:05.070 --> 01:23:05.710
就有的时候

01:23:05.710 --> 01:23:07.150
这也是里面很多面识体

01:23:07.150 --> 01:23:08.510
它的知识是交叉的

01:23:08.510 --> 01:23:09.390
它不是说

01:23:09.390 --> 01:23:10.510
一到现在只考理

01:23:10.510 --> 01:23:11.870
完全只考理一个知识

01:23:11.870 --> 01:23:12.590
它不会的

01:23:12.590 --> 01:23:15.630
它无论是综合交叉的

01:23:15.630 --> 01:23:16.270
那么这里呢

01:23:16.270 --> 01:23:17.230
也就是说我们这里

01:23:17.230 --> 01:23:19.470
还有一个内存空间

01:23:19.470 --> 01:23:21.070
现在要运行没事的E的

01:23:21.070 --> 01:23:22.670
运行空间就是ARR

01:23:22.670 --> 01:23:24.350
我们把它标准一个

01:23:24.350 --> 01:23:29.070
没事的E运行期间的ARR

01:23:29.070 --> 01:23:31.630
它跟那个权距ARR不是一个东西

01:23:31.630 --> 01:23:33.230
然后这个ARR是啥呢

01:23:33.230 --> 01:23:34.750
它是传递的进去的

01:23:34.750 --> 01:23:36.350
把权距的ARR

01:23:36.350 --> 01:23:37.870
就把这个里面的东西

01:23:37.870 --> 01:23:40.350
传到这里面去了

01:23:40.350 --> 01:23:42.590
也就把它传到它里面去了

01:23:42.590 --> 01:23:44.590
看到没

01:23:44.590 --> 01:23:45.230
下来过后

01:23:45.230 --> 01:23:46.830
这一会模糊的同学

01:23:46.830 --> 01:23:48.270
可能基础不太扎实

01:23:48.350 --> 01:23:51.310
好好下来去多看几遍

01:23:51.310 --> 01:23:53.470
我给你讲还是讲得很清楚了

01:23:53.470 --> 01:23:54.750
那么这里传过去的时候

01:23:54.750 --> 01:23:55.950
这里是不是有个地址

01:23:55.950 --> 01:23:56.910
它指向这个玩意

01:23:56.910 --> 01:23:58.350
然后它里面不也有这个

01:23:58.350 --> 01:23:59.230
也有个地址吗

01:23:59.230 --> 01:24:00.830
它现在不是也指向它吗

01:24:00.830 --> 01:24:02.990
那到底不是一样的吗

01:24:02.990 --> 01:24:04.030
它里面存了个地址

01:24:04.030 --> 01:24:05.790
这个地址就是这个的地址

01:24:05.790 --> 01:24:06.750
那么它里面存了个地址

01:24:06.750 --> 01:24:08.030
也就是这个的地址

01:24:08.030 --> 01:24:09.950
一样的

01:24:09.950 --> 01:24:11.390
然后干嘛

01:24:11.390 --> 01:24:14.750
ARR0等于BAR

01:24:14.750 --> 01:24:16.350
就算局部变量

01:24:16.430 --> 01:24:19.790
那么来变量多嘛

01:24:19.790 --> 01:24:21.310
多的多呗

01:24:21.310 --> 01:24:28.700
没事的一中的BAR

01:24:28.700 --> 01:24:29.500
等于谁

01:24:29.500 --> 01:24:31.340
等于ARR0

01:24:31.340 --> 01:24:33.820
0是不是这个玩意

01:24:33.820 --> 01:24:35.420
这里说一个地址

01:24:35.420 --> 01:24:36.780
然后你对它的分析

01:24:36.780 --> 01:24:38.540
你管它会整成什么样子

01:24:38.540 --> 01:24:42.220
这样的分析肯定是无敌的

01:24:42.220 --> 01:24:43.340
没事的一中的BAR

01:24:43.340 --> 01:24:45.420
它也指向这个玩意了

01:24:45.420 --> 01:24:49.340
然后再来ARPUSHBAR

01:24:49.340 --> 01:24:52.060
往ARR中加入一个BAR

01:24:52.060 --> 01:24:53.020
啥意思

01:24:53.020 --> 01:24:54.060
ARR是啥

01:24:54.060 --> 01:24:55.260
在这

01:24:55.260 --> 01:24:57.100
运行期间的ARR

01:24:57.100 --> 01:24:58.780
AR里面是不是它

01:24:58.780 --> 01:24:59.980
往它里面加了一个谁

01:24:59.980 --> 01:25:00.860
加了一个BAR

01:25:00.860 --> 01:25:01.420
BAR是啥

01:25:01.420 --> 01:25:02.860
BAR是这个玩意

01:25:02.860 --> 01:25:03.900
是不是这个对象

01:25:03.900 --> 01:25:05.580
也就是它里面有多了一个下标了

01:25:05.580 --> 01:25:06.460
结果这么个意思

01:25:06.460 --> 01:25:08.060
加一个就多一个下标嘛

01:25:08.060 --> 01:25:10.940
莫伟添加一个下标嘛

01:25:10.940 --> 01:25:13.180
这是PUSH的本质

01:25:13.180 --> 01:25:13.900
这个下标是啥

01:25:13.900 --> 01:25:15.180
这个下标

01:25:15.180 --> 01:25:17.660
这个下标是BAR的值

01:25:17.660 --> 01:25:18.620
BAR的值是啥

01:25:18.620 --> 01:25:19.900
BAR的值是一个地址

01:25:19.900 --> 01:25:21.180
这个地址还是指向它

01:25:21.180 --> 01:25:22.460
所以这个1这个位置

01:25:22.460 --> 01:25:29.360
它还是指向它

01:25:29.360 --> 01:25:32.190
它还是指向

01:25:32.190 --> 01:25:33.470
这个1这个位置的

01:25:33.470 --> 01:25:34.270
也是一个地址

01:25:34.270 --> 01:25:35.390
它还是指向它

01:25:35.390 --> 01:25:36.670
所以呢

01:25:36.670 --> 01:25:37.070
然后呢

01:25:37.070 --> 01:25:37.870
又来呗

01:25:37.870 --> 01:25:40.270
把BAR点N加加

01:25:40.270 --> 01:25:41.470
你看这个大什么面

01:25:41.470 --> 01:25:42.430
多会绕你

01:25:42.430 --> 01:25:43.470
各种绕你

01:25:43.470 --> 01:25:44.990
但是你只要绘画内循循

01:25:44.990 --> 01:25:45.790
你是无敌的

01:25:45.790 --> 01:25:46.910
随便它怎么绕

01:25:46.910 --> 01:25:48.830
BAR点N加加

01:25:48.830 --> 01:25:51.630
是不是把它这个N加1得几

01:25:51.630 --> 01:25:52.910
得2

01:25:53.630 --> 01:25:55.470
然后干嘛

01:25:55.470 --> 01:25:58.030
然后我又产生一个新的数组

01:25:58.030 --> 01:25:59.310
哎呀

01:25:59.310 --> 01:26:01.870
多会绑啊

01:26:01.870 --> 01:26:03.390
你看它多会绑

01:26:03.390 --> 01:26:07.870
它又产生一个新的数组

01:26:07.870 --> 01:26:09.390
这个数组的第一项是

01:26:09.390 --> 01:26:10.910
这个数组的第一项是一个BAR

01:26:10.910 --> 01:26:11.950
BAR是啥

01:26:11.950 --> 01:26:13.230
BAR是一个地址指向它

01:26:13.230 --> 01:26:15.550
那这个地址它是不是又指向它

01:26:15.550 --> 01:26:17.070
换个尖头边指向它

01:26:17.070 --> 01:26:18.350
一大堆东西指向它

01:26:18.350 --> 01:26:19.630
它就指指指边

01:26:19.630 --> 01:26:21.150
那它1000万个指向它

01:26:21.150 --> 01:26:22.190
也无所谓嘛

01:26:22.270 --> 01:26:26.030
很没变短的能对签复制

01:26:26.030 --> 01:26:27.310
你别看那个尖头复杂

01:26:27.310 --> 01:26:28.590
复杂就复杂了

01:26:28.590 --> 01:26:29.870
你反正就按那个逻辑

01:26:29.870 --> 01:26:31.150
就这样的画出来的

01:26:31.150 --> 01:26:32.430
看一画成啥样就画成啥样

01:26:32.430 --> 01:26:34.990
我都不知道它会画成啥样

01:26:34.990 --> 01:26:36.510
来吧又来吧

01:26:36.510 --> 01:26:40.350
ARAR 铺写点铺写BAR

01:26:40.350 --> 01:26:42.190
哦不是 这里还没完啊

01:26:42.190 --> 01:26:44.510
把这个软件复制给谁

01:26:44.510 --> 01:26:45.870
复制给ARAR

01:26:45.870 --> 01:26:47.310
这里还没完成复制

01:26:47.310 --> 01:26:49.470
我只是创建了这个新数组

01:26:49.470 --> 01:26:50.590
复制给ARAR

01:26:50.590 --> 01:26:51.070
复制给谁

01:26:51.150 --> 01:26:52.990
打个AR 复制给这个AR

01:26:52.990 --> 01:26:54.110
所以这个ARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARA

01:26:54.110 --> 01:26:55.870
不再指向它了

01:26:55.870 --> 01:26:58.930
它指向这个玩意了

01:26:58.930 --> 01:27:00.370
看到没

01:27:00.370 --> 01:27:02.050
稍微涂动一下嘛

01:27:02.050 --> 01:27:02.970
它指向这个玩意了

01:27:02.970 --> 01:27:04.130
你管它画得什么样子

01:27:04.130 --> 01:27:04.850
无所谓

01:27:04.850 --> 01:27:05.850
跟你没什么关系

01:27:05.850 --> 01:27:08.770
到时候只去按照尖头找就完事了

01:27:08.770 --> 01:27:10.290
它画的这个复杂唱天也无所谓

01:27:10.290 --> 01:27:40.860
反正你有箭头的,然后ARPUSH BALL,啥意思?ARPUSH啥?ARPUSH这个玩意儿,那也就是这个玩意儿,地址指向过去的嘛,然后往这里边加一下,是不是又加个1,谁?BALL,BALL是啥?BALL是啥?BALL就是这个玩意儿,这个玩意儿不就是这个玩意儿嘛,那又多了一个箭头了,又多了一个了,看上去好像很复杂的样子,其实你下来自己试一试,

01:27:40.860 --> 01:28:09.240
人家花出来了就无敌了,然后干嘛?AR1.n加加,AR1是啥?AR2是这个玩意儿,AR2实际上也是这个玩意儿,1是啥?1就是这个地址,对吧?一个地址是啥?地址就是它的,它1.n加1就加它,一步一步走,当然它会做的慢一点,像这种题一定要慢慢做,你不可能一下就看到答案的,完了,这函数运行完了,

01:28:09.240 --> 01:28:31.090
运行完了怎么样,函数运行结束,参数消失,拜拜,然后这个东西,函数里边的局部便量消失,拜拜,如果说你们将来学了更多的辨识知识之后,你会发现这个玩意儿也会消失,为什么?

01:28:31.090 --> 01:28:54.090
因为你在程序里边不可能通过任何的辨量能够找到这块内存空间了,这个内存空间在不在呢?在,但是你无法通过辨证来找到它,你怎么找到它吗?通过Fu肯定找不到它,通过ARR也找不到它,那么这个内存空间是无法被访问的,所以说这个内存空间它过一会儿就会被垃圾毁收,毁收掉,当然地方放着也无所谓,跟你没什么关系。

01:28:54.090 --> 01:29:24.530
好,来吧,MES2,怎么样?Fu,现在有一个内存空间是MES2运行期间的Fu,它里边是啥?它里边把Fu传进去了,对吧,把它传给了它,它里边是啥?是地址,也就意味着这个玩意儿的地址跟Fu的地址是一模一样的,就这么回事儿。

01:29:24.530 --> 01:29:37.530
Fu点N加加就找到它,它就是它,N加加就把它变成4,所以说这里就变成了4。方法运行结束了,这个玩意儿也不见了,白白那你呢?

01:29:37.530 --> 01:29:49.530
然后MES3,又来Fu点N,你看这个体都会绕你,这个体出的太好了。Fu点3,MES3又多了一个内存空间。

01:29:49.530 --> 01:30:12.790
N都好,MES3的运行期间的N,来自于哪里?来自于Fu点N,Fu点N是啥?Fu是这个玩意儿,点N是,把4传过来,注意这是Fu之粘贴啊,所有的团体都是Fu之粘贴。那这里面是不是原始值?4,它不是地址了。

01:30:13.790 --> 01:30:29.020
然后怎么样N加加,这是谁的N?MES3运行期间的N,它说它这里去加了一个1,然后方法运行结束,MES3运行结束,运行结束这个玩意儿消失了。

01:30:30.020 --> 01:31:05.040
最后输出Fu点N和AR2点N4,Fu点N是啥?4,AR2点N4,AR2是啥?这个玩意儿,长度了为2,最终结果就是4和2。

01:31:05.040 --> 01:31:29.530
好,咱们来运行看一下啊,是不是4和2,它这个清除不焦呢,我按照什么快捷键呢,就去掉了。

01:31:29.530 --> 01:31:41.530
好,来运行,4和2,分析了一大堆,但是我们不管用了多少时间,最终还是得到了一个正确的结果。

01:31:42.530 --> 01:31:56.530
我可以传递的就是这个东西,就是你遇到这种面试题啊,你管它咋解的,你管它过程是啥,你管它会遇到多少个箭头,会生存多少个内存空间,你就按照这个规则一则的去创建,一则的去画,一步一步看清楚,就不会有任何问题。

01:31:59.930 --> 01:32:04.930
这是京东的面试题,就这样子了,下来至于试一试,第三道题,字节的。

01:32:04.930 --> 01:32:31.350
哎,这些题白天有没有先发给你们啊,同学们,有没有白天先发给你们啊,有没有啊,没发是吧,这些题应该白天先发给同学们,先做一做啊,先体验一下。

01:32:31.350 --> 01:32:43.880
好,这里也是一样一个副,我现在就画快一点了,因为现在已经有前面的那些准备工作了,之前也分析过的。

01:32:43.880 --> 01:32:58.640
那么这个也是个对象,巴里面等于1,然后副指向这个巴,对吧,这个没什么问题吧,然后接下来创建一个数组,这个数组有三个下标,0这个下标为1,

01:32:59.640 --> 01:33:25.880
设置一下,0这个下标为1,然后1这个下标为2,然后2这个下标为一个副,副是啥,副是这个玩意传进来的,对吧,所以说这个2结果就是一个地址,2里面存的是一个什么地址,就这样子的,没问题吧,没有意义吧,

01:33:26.880 --> 01:33:45.880
然后把这个数组给谁,给一个变量,AR1,都是字节面试题,字节面试题里面会有一个非常特别的点,我现在都还不知道是啥,我现在就画起头吧,也没什么大不了的,我又觉得它没有什么好玩的,哦,看到了,接下来还玩了这么个东西,

01:33:48.510 --> 01:34:01.510
哎呀,我这个玩意,好了,然后接下来还玩了这么个东西,就这个东西,这是啥意思呢,不知道同学们有没有学到这,这是切割数组,

01:34:03.510 --> 01:34:15.510
把这个AR1这个数组呢,就这个数组来进行切割,从哪个位置开始切割,从下标1开始切割,也就是什么意思,整个这个表达是,表示说我只要数组的这一部分,

01:34:16.510 --> 01:34:25.510
然后产生一个新数组,所以它一定是产生一个新数组,这个新数组呢,只有元数组的这一部分,所以说,

01:34:26.510 --> 01:34:35.510
这句话的意思,相当于是我这里来的一个新数组,新数组呢,只有元数组的这一部分,

01:34:36.510 --> 01:35:10.610
当然下标的要重新排,就是0为2,然后2是那个地址,懂了意思吗,就这样的,就这样的,来,这里是1,

01:35:12.610 --> 01:35:24.980
就是把这一部分,看没,放到新数组里面来了,这就是这个函数的作用,是nice,然后把产生了这个新数组给谁,给AR2,

01:35:25.980 --> 01:35:34.980
所以呢,目前其实应该就是这个点有技术含量吧,其他也没啥,AR2,你可以说它反朔,你不能说它复杂,这又啥复杂的吗,

01:35:35.980 --> 01:35:43.980
就是这花呗,它哪一步就结了往后花就完事了,然后干嘛,AR20加加,那就是不是把这个加一吗,

01:35:44.980 --> 01:35:53.980
它就几,3,然后AR1.82.加加,什么意思,1是什么,是这个东西,地址,地址是啥,这个玩意儿,

01:35:54.980 --> 01:36:04.980
8,这个玩意儿,把它加1,对了,得到结果,2,然后附点8加加,附是啥,附是这个玩意儿,也就是这个玩意儿,

01:36:05.980 --> 01:36:28.640
8加加,3,然后是AR1,就这个东西,2,地址,8加加,4,加上都是一个东西,然后输出AR1等不等于AR20,AR1是啥,是这个,

01:36:29.640 --> 01:36:41.640
AR20是这个,相等吗,不相等,然后接下来AR2,是不等于AR2,AR1,AR2,就这个地址,

01:36:42.640 --> 01:36:50.640
是不等于AR2,这个地址,两个地址是不是一样的,都只像同一个内存空间一样的,说这个玩意儿,OK,

01:36:51.640 --> 01:37:09.050
第三个,附点8,附点8输出解,附点8输出4,就是force,q和4的字节的,也就这样了,

01:37:10.050 --> 01:37:22.050
不过意思吧,你只要把这些课听懂了,至少你所有的预算规则,就单说预算规则这一块,以及值和引用这一块,那肯定是没有什么问题的,

01:37:23.050 --> 01:37:32.550
至少这两块只是没有什么问题的,OK,这就是我们今天晚上的讲的东西,其实呢,同学们听下来应该是,

01:37:33.550 --> 01:37:42.550
有一个感觉就是,它不需要你去背,就这到底该怎么做,这到底该怎么做,不需要,你就按照这个方式,就可以解决所有的问题了,

01:37:43.550 --> 01:37:48.550
无非就是画,画,画,画,画,你画完之前你也不知道是啥,就说我画完之前我也不知道是啥,但是画完了它,

01:37:49.550 --> 01:37:57.550
为了结果我就按照这个图去看就完事了,就是这样做这个问题的,这样子它怎么去绕,怎么去玩呢,它发现它我不懂你,

01:37:59.550 --> 01:38:07.550
那麽下来,当然这光听,光听是不够的,我因为下来之后一定要去练一练,用一用,诗一诗,感受感受,

01:38:07.550 --> 01:38:19.550
这中间在用的过程中肯定会遇到一些疑问,咱们在群里面讨论,学习的过程就是这样子,先听老师讲,有点感觉了,学习其实就是追求感觉的过程,

01:38:20.550 --> 01:38:27.550
但这个感觉是不够的,就像听别人说,这东西好好吃啊,这个游戏好好玩啊,你没有自己去操作,没有自己去动手,没有自己感受,

01:38:27.550 --> 01:38:44.250
有没有感觉呢,有感觉,但是是不够的,其实老师我觉得老师的最大动向就是让你自己鼓励你自己去动手,一方面只让你规律指方向,另一方面让你自己去动手,你要自己去感觉,

01:38:45.250 --> 01:38:53.250
当然自己去做的过程中肯定会产生问题,这是一定的,然后呢,通过跟同学讨论,跟老师讨论,通过这些讨论的过程中,

