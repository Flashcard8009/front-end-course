WEBVTT

00:00.000 --> 00:05.310
好 今天晚上我们每天晚上两个知识点

00:05.310 --> 00:11.310
我们昨天晚上讲了预算规则和值和引用

00:11.310 --> 00:16.310
就这几天的知识点它的连续性并不是很强

00:16.310 --> 00:21.310
就是昨天晚上的东西跟今天晚上的东西可能没有必然的联系

00:21.310 --> 00:26.310
但是每一天晚上可能多多少少会有一点联系

00:26.310 --> 00:29.310
像这个执行商项文跟作用预练

00:29.310 --> 00:31.310
这是我们今天晚上要讲的内容

00:31.310 --> 00:39.310
那这一块内容他们之间就会有一些联系

00:39.310 --> 00:43.310
今天晚上的内容跟昨天晚上的内容相比呢

00:43.310 --> 00:46.310
它的逻辑性比较强

00:46.310 --> 00:49.310
可能同学们听上去呢

00:49.310 --> 00:52.310
他就会觉得东西没有那么多

00:53.310 --> 00:55.310
但是还是感觉有一点绕

00:55.310 --> 00:57.310
会有这样的一个感觉

00:57.310 --> 00:59.310
就是我们这几天的内容呢

00:59.310 --> 01:01.310
每个同学不一样得到了体会

01:01.310 --> 01:03.310
觉得可能觉得还可以

01:03.310 --> 01:05.310
听得还比较舒服的

01:05.310 --> 01:07.310
一听就应该是没问题了

01:07.310 --> 01:10.310
然后后面练习的自己能做好

01:10.310 --> 01:12.310
另外一部分同学可能会觉得

01:12.310 --> 01:14.310
听了过后的感觉还是很模糊

01:14.310 --> 01:16.310
那么下来过后就需要多去消化

01:16.310 --> 01:21.310
你可能会需要两天三天的时间去把它消化一下

01:21.310 --> 01:24.310
因为每个同学的基础是不一样的

01:24.310 --> 01:26.310
理解能力也是不一样的

01:26.310 --> 01:28.310
这跟我们平时在后期上课的时候

01:28.310 --> 01:30.310
也会出现这样的现象

01:30.310 --> 01:31.310
有的同学学的快

01:31.310 --> 01:32.310
有的同学学的慢

01:32.310 --> 01:33.310
但是没有关系

01:33.310 --> 01:36.310
学的慢的不要去着急

01:36.310 --> 01:38.310
学的快的也不要

01:38.310 --> 01:41.310
你稍微的走得稳固一点

01:41.310 --> 01:44.310
不要基础没有打牢

01:44.310 --> 01:46.310
就是每个同学根据自己的情况

01:46.310 --> 01:50.310
安排自己的学习节奏

01:50.310 --> 01:53.310
你像咱们前端的从零基础到就业

01:53.310 --> 01:56.310
一共就这么接近半年的时间

01:56.310 --> 01:59.310
有些同学可能学个四个月三个月

01:59.310 --> 02:01.310
甚至就能就业了

02:01.310 --> 02:04.310
甚至有同学学习一个月都能就业的

02:04.310 --> 02:07.310
这部分同学比较是什么情况呢

02:07.310 --> 02:09.310
就是之前有一些学

02:09.310 --> 02:10.310
但开发经验

02:10.310 --> 02:12.310
比较做后端的转前端

02:12.310 --> 02:14.310
现在也不少

02:14.310 --> 02:19.310
包括做安卓LS的转前端也不少

02:19.310 --> 02:21.310
像这些同学他学的比较快

02:21.310 --> 02:22.310
有的同学学的慢

02:22.310 --> 02:24.310
就可能是完全的零基础

02:24.310 --> 02:27.310
以前可能读书的时候

02:27.310 --> 02:30.310
经过太多的逻辑训练

02:30.310 --> 02:32.310
包括出数学题

02:32.310 --> 02:33.310
物理题

02:33.310 --> 02:35.310
一些理工科的类型的题

02:35.310 --> 02:37.310
没有经过大脑的训练

02:37.310 --> 02:38.310
虽然咱们这个行业

02:38.310 --> 02:40.310
不太需要高深的数学知识

02:40.310 --> 02:41.310
加建成熟

02:41.310 --> 02:43.310
求鱼就够了

02:43.310 --> 02:45.310
更加不需要什么物理知识

02:45.310 --> 02:48.310
但是你经过那些东西的训练之后

02:48.310 --> 02:49.310
你确实

02:49.310 --> 02:51.310
按照我的教学经验来说

02:51.310 --> 02:53.310
你会学习的比较快

02:53.310 --> 02:54.310
那如果说你没有这些

02:54.310 --> 02:56.310
经过没有经过这些训练的话

02:56.310 --> 02:58.310
那可能你就学的慢一些

02:58.310 --> 02:59.310
慢也慢不了多少

02:59.310 --> 03:01.310
你慢个两个月

03:01.310 --> 03:02.310
三个月毕业

03:02.310 --> 03:03.310
对你的人生来讲

03:03.310 --> 03:05.310
没有任何的影响

03:05.310 --> 03:07.310
但是如果说你着急了

03:07.310 --> 03:10.310
你要去压苗树长

03:10.310 --> 03:13.310
你要自己去提速

03:13.310 --> 03:15.310
导致自己前面的学习的一塌糊涂

03:15.310 --> 03:17.310
那么最终会导致

03:17.310 --> 03:19.310
你整个的学习是完全失败的

03:19.310 --> 03:20.310
你花了时间

03:20.310 --> 03:21.310
结果是失败的

03:21.310 --> 03:22.310
我们可以多花时间

03:22.310 --> 03:23.310
没有关系

03:23.310 --> 03:25.310
说远了

03:25.310 --> 03:27.310
就是我们每一天的课程

03:27.310 --> 03:29.310
一定只有一个目标

03:29.310 --> 03:31.310
同学们要把它消化

03:31.310 --> 03:33.310
成为自己的知识

03:33.310 --> 03:35.310
这是我们课程的目标

03:35.310 --> 03:36.310
不是说

03:36.310 --> 03:38.310
我在这里讲你们听到很爽就完事了

03:38.310 --> 03:39.310
好说回来

03:39.310 --> 03:40.310
咱们今天晚上讲的是

03:40.310 --> 03:41.310
两个重要的知识点

03:41.310 --> 03:42.310
一个是执行上下文

03:42.310 --> 03:45.310
一个是作用预列

03:45.310 --> 03:46.310
先说这个执行上下文

03:46.310 --> 03:48.310
这个玩意儿是啥呢

03:48.310 --> 03:50.310
我从一个例子给大家举例

03:50.310 --> 03:51.310
来说明

03:51.310 --> 03:54.310
这个玩意儿是跟寒树相关的

03:54.310 --> 03:56.310
它跟寒树有什么关系呢

03:56.310 --> 03:57.310
下面有一些例子

03:57.310 --> 03:58.310
比方说

03:58.310 --> 04:00.310
我们的独一的老朋友

04:00.310 --> 04:02.310
我们独一的素材

04:02.310 --> 04:03.310
邓哥

04:03.310 --> 04:07.310
邓哥会跑步

04:07.310 --> 04:08.310
他就表示说

04:08.310 --> 04:11.310
邓哥有这个跑步的能力

04:11.310 --> 04:12.310
那么这个玩意儿叫啥呀

04:12.310 --> 04:15.310
叫寒树的定义

04:15.310 --> 04:17.310
比方说我们平时都定义过寒树

04:17.310 --> 04:18.310
有的时候

04:18.310 --> 04:19.310
寒树可能是这样子写的

04:19.310 --> 04:20.310
一个方形

04:20.310 --> 04:21.310
一个上

04:21.310 --> 04:22.310
A和B

04:22.310 --> 04:24.310
一个最简单的寒树了

04:24.310 --> 04:26.310
然后Return一个A加B

04:26.310 --> 04:27.310
这不就是一个寒树吗

04:27.310 --> 04:28.310
表示什么意思呢

04:28.310 --> 04:31.310
表示我们程序里边

04:31.310 --> 04:32.310
有

04:32.310 --> 04:34.310
把两个数字

04:34.310 --> 04:37.310
相加的能力

04:37.310 --> 04:39.310
并不代表我现在

04:39.310 --> 04:41.310
就要给它相加

04:41.310 --> 04:43.310
这叫寒树的定义

04:43.310 --> 04:47.310
表示说我可以相加

04:47.310 --> 04:50.310
那么我们什么叫做寒树调用呢

04:50.310 --> 04:51.310
比方说我们让邓哥

04:51.310 --> 04:52.310
你不是会跑步吗

04:52.310 --> 04:54.310
你现在去给我跑

04:54.310 --> 04:56.310
这叫寒树的调用

04:56.310 --> 04:57.310
表达的是

04:57.310 --> 05:01.310
邓哥现在就去做这件事

05:01.310 --> 05:02.310
一定要把它分清楚

05:02.310 --> 05:04.310
什么叫寒树的定义

05:04.310 --> 05:06.310
什么叫寒树的调用

05:06.310 --> 05:09.310
比方我们程序里边

05:09.310 --> 05:12.310
可以对两个数字相加

05:12.310 --> 05:15.310
但是它不代表我已经把它相加了

05:15.310 --> 05:16.310
我什么时候相加呢

05:16.310 --> 05:18.310
叫做寒树调用

05:18.310 --> 05:20.310
你给我加一个1和2相加

05:20.310 --> 05:23.310
你给我把3和4相加

05:23.310 --> 05:25.310
这叫寒树调用

05:25.310 --> 05:27.310
先搞清楚这两个概念

05:27.310 --> 05:29.310
那么我们有了这两个概念之后

05:29.310 --> 05:32.310
我们再来看往后边继续看

05:32.310 --> 05:34.310
我们再去做一些事的时候

05:34.310 --> 05:36.310
可能会有一些准备工作

05:36.310 --> 05:38.310
比方说邓哥会跑步

05:38.310 --> 05:40.310
那么现在邓哥

05:40.310 --> 05:42.310
你去给我跑个步

05:42.310 --> 05:44.310
就跑一圈跑三圈

05:44.310 --> 05:45.310
那么这个时候

05:45.310 --> 05:47.310
就是在调用寒树

05:47.310 --> 05:50.310
那么需要做一些准备工作

05:50.310 --> 05:52.310
比方说邓哥跑步的时候

05:52.310 --> 05:54.310
需要准备一些运动服

05:54.310 --> 05:56.310
运动鞋

05:56.310 --> 05:58.310
毛鞋

05:58.310 --> 06:01.310
或者是一些饮料

06:01.310 --> 06:03.310
这是邓哥跑步

06:03.310 --> 06:05.310
需要做的准备工作

06:05.310 --> 06:07.310
那么回到我们代码里边来的话

06:07.310 --> 06:08.310
它类比的就是

06:08.310 --> 06:11.310
我们寒树调用的时候

06:11.310 --> 06:14.310
它需要做一些准备工作

06:14.310 --> 06:15.310
这个同学们可能之前

06:15.310 --> 06:17.310
是完全没有接触过的

06:17.310 --> 06:19.310
说我们的寒树调用就非常简单

06:19.310 --> 06:21.310
这一调用就调用了没

06:21.310 --> 06:23.310
1和2相加反回一个3

06:23.310 --> 06:25.310
然后3和4相加反回一个7

06:25.310 --> 06:27.310
看上去很直接

06:27.310 --> 06:29.310
实际上它不是这样子的

06:29.310 --> 06:31.310
它调用寒树的时候

06:31.310 --> 06:34.310
一定是调用寒树的时候

06:34.310 --> 06:36.310
它会做一些准备工作

06:36.310 --> 06:39.310
这些准备工作做完了之后

06:39.310 --> 06:41.310
它才会真正的运行

06:41.310 --> 06:44.310
这个寒树里边的代码

06:44.310 --> 06:45.310
那么运行完了之后

06:45.310 --> 06:48.310
下一次再调用寒树的时候

06:48.310 --> 06:49.310
它又是从车来

06:49.310 --> 06:51.310
又要做一些准备工作

06:51.310 --> 06:53.310
然后再去运行这个代码

06:53.310 --> 06:55.310
一个登革跑步是一样的

06:55.310 --> 06:56.310
来一个跑参圈

06:56.310 --> 06:58.310
准备工作做完了再跑

06:58.310 --> 06:59.310
跑完了之后

06:59.310 --> 07:00.310
来一个再给我跑7圈

07:00.310 --> 07:02.310
它又要做一些准备工作

07:02.310 --> 07:05.310
就这么个意思

07:05.310 --> 07:06.310
为什么要准备呢

07:06.310 --> 07:07.310
是因为你看

07:07.310 --> 07:09.310
登革为什么要做准备工作

07:09.310 --> 07:12.310
是因为它的跑步的过程中

07:12.310 --> 07:15.310
可能会拥抱这些东西

07:15.310 --> 07:16.310
比如说运动鞋

07:16.310 --> 07:17.310
它要用导板

07:17.310 --> 07:18.310
运动斧运动鞋

07:18.310 --> 07:19.310
还有毛巾擦汗

07:19.310 --> 07:21.310
或者是饮料

07:21.310 --> 07:23.310
补一下水补一下盐分

07:23.310 --> 07:25.310
那么我们包里是一样的

07:25.310 --> 07:27.310
寒树调用的时候

07:27.310 --> 07:31.310
它也需要做准备

07:31.310 --> 07:33.310
它做什么准备呢

07:33.310 --> 07:37.310
浏览器会开一块内存空间

07:37.310 --> 07:38.310
这个另一边量一样

07:38.310 --> 07:39.310
开了一块内存空间

07:39.310 --> 07:42.310
它往内存就像一个储物间一样

07:42.310 --> 07:44.310
往内存里边放了一些

07:44.310 --> 07:46.310
关键性的物品

07:46.310 --> 07:48.310
比如说运动斧运动鞋

07:48.310 --> 07:50.310
它放的肯定不是这个

07:50.310 --> 07:51.310
它放一些关键性的物品

07:51.310 --> 07:53.310
这个物品起什么样的作用呢

07:53.310 --> 07:57.310
它可以让寒树的运行过程中

07:57.310 --> 08:01.310
随时地使用这些物品

08:01.310 --> 08:03.310
就可能我们的跑步是一样的道理

08:03.310 --> 08:05.310
那么具体的到底是什么呢

08:05.310 --> 08:07.310
放了到底放了什么东西进去了

08:07.310 --> 08:09.310
我们随时可以用

08:09.310 --> 08:11.310
可以用什么东西

08:11.310 --> 08:13.310
这就是我们接下来要讲的东西

08:13.310 --> 08:17.310
这个物品就是执行商项问

08:17.310 --> 08:19.310
它英文单词叫做

08:19.310 --> 08:22.310
exclusion context 简称EC

08:22.310 --> 08:23.310
后边看到EC

08:23.310 --> 08:25.310
就表示的是执行商项问

08:25.310 --> 08:27.310
它其实就是一块内存空间

08:27.310 --> 08:29.310
一个储物间

08:29.310 --> 08:31.310
往里边扔了一大的东西

08:31.310 --> 08:33.310
可以随时取用

08:33.310 --> 08:35.310
那么接下来我们再研究

08:35.310 --> 08:37.310
它到底往它里边放了什么东西

08:37.310 --> 08:39.310
下面是一个例子

08:39.310 --> 08:42.310
比方说我们这里定义了一个寒树message

08:42.310 --> 08:45.310
它会产生执行商项问吗

08:45.310 --> 08:46.310
不会

08:46.310 --> 08:47.310
为什么

08:47.310 --> 08:52.310
什么时候我们才会产生执行商项问

08:52.310 --> 08:55.310
它一定要在寒树执行的时候

08:55.310 --> 08:57.310
也就是调用的时候

08:57.310 --> 08:59.310
那么也就是说在这个单码的时候

08:59.310 --> 09:04.310
它才会真正的产生执行商项问

09:04.310 --> 09:06.310
那么这个执行商项问

09:06.310 --> 09:08.310
它其实就是一块内存空间

09:08.310 --> 09:09.310
这个内存空间

09:09.310 --> 09:11.310
你可以把它想象成一个对象

09:11.310 --> 09:13.310
它有很多属性

09:13.310 --> 09:14.310
不过呢

09:14.310 --> 09:15.310
很多属性

09:15.310 --> 09:18.310
我们目前是并不care的

09:18.310 --> 09:20.310
我们只关心这个内存空间里面

09:20.310 --> 09:23.310
其中一个东西叫做AO

09:23.310 --> 09:25.310
它是一个对象

09:25.310 --> 09:28.310
我们只关心这一块里面存了啥

09:28.310 --> 09:30.310
其他有没有存的有存东西

09:30.310 --> 09:31.310
但是呢

09:31.310 --> 09:32.310
我们并不关心

09:32.310 --> 09:34.310
至少我们现在并不关心这一点

09:34.310 --> 09:35.310
我们现在关心的是

09:35.310 --> 09:37.310
它里边有一个关键性的东西

09:37.310 --> 09:40.310
AO

09:40.310 --> 09:42.310
那么这个AO是什么呢

09:42.310 --> 09:45.310
叫做Activation

09:45.310 --> 09:46.310
Objects

09:46.310 --> 09:47.310
Activation什么意思

09:47.310 --> 09:48.310
激活的

09:48.310 --> 09:49.310
对吧

09:49.310 --> 09:52.310
有些所谓是刀板的时候需要激活

09:52.310 --> 09:54.310
就这么个意思

09:54.310 --> 09:57.310
Objects表示它是一个对象

09:57.310 --> 09:58.310
这个玩意儿是一个对象

09:58.310 --> 10:00.310
你看我这里用了个大括号

10:00.310 --> 10:03.310
它被称为活动对象

10:03.310 --> 10:05.310
那么这个玩意儿到底是啥呢

10:05.310 --> 10:07.310
它说里边放了什么东西呢

10:07.310 --> 10:09.310
我继续往后看

10:09.310 --> 10:11.310
在调用函数的时候

10:11.310 --> 10:14.310
它会先往AO里边放一些东西

10:14.310 --> 10:17.310
然后放完之后再执行函数

10:17.310 --> 10:20.310
所以说我们函数里边代码

10:20.310 --> 10:22.310
它执行的时间点

10:22.310 --> 10:24.310
是在AO这个对象里边放完了

10:24.310 --> 10:28.310
所有东西之后才会执行

10:28.310 --> 10:31.310
好 接下来我们就看一步一步看

10:31.310 --> 10:36.310
这个AO里边它到底放了什么东西

10:36.310 --> 10:38.310
一共就三个步骤

10:38.310 --> 10:41.310
你把这三个步骤研究清楚了

10:41.310 --> 10:43.310
那么执行上下文字

10:43.310 --> 10:46.310
或者所有的题也都能做了

10:46.310 --> 10:48.310
当然如果说它综合考察

10:48.310 --> 10:49.310
还考察以别的知识的话

10:49.310 --> 10:50.310
那不一定

10:50.310 --> 10:52.310
但是如果说单考察

10:52.310 --> 10:53.310
执行上下文的话

10:53.310 --> 10:55.310
这一块知识至少没问题了

10:55.310 --> 10:57.310
咱们学技术呢

10:57.310 --> 10:59.310
就好像玩拼图一样

10:59.310 --> 11:01.310
比方说有1000块拼图

11:01.310 --> 11:03.310
你搞定了一块就少一块

11:03.310 --> 11:05.310
搞定一块就少一块

11:05.310 --> 11:06.310
当你把1000块全部搞定的时候

11:06.310 --> 11:08.310
这个技术对你来说

11:08.310 --> 11:09.310
就是小差一疊了

11:09.310 --> 11:11.310
批什么Cake

11:11.310 --> 11:13.310
好 那么一步一步来

11:13.310 --> 11:14.310
首先第一步

11:14.310 --> 11:16.310
这个AO一开始是空的

11:16.310 --> 11:17.310
啥都没有

11:17.310 --> 11:19.310
然后第一步说什么呢

11:19.310 --> 11:22.310
第一步是确定参数

11:22.310 --> 11:23.310
怎么确定参数

11:23.310 --> 11:27.900
你不是在调用函数吗

11:27.900 --> 11:29.900
那你这里是不是有传参

11:29.900 --> 11:30.900
二

11:30.900 --> 11:32.900
跟谁传进来了

11:32.900 --> 11:33.900
传到A 对吧

11:33.900 --> 11:36.860
三

11:36.860 --> 11:37.860
传到了什么

11:37.860 --> 11:38.860
传到A

11:38.860 --> 11:39.860
传到A

11:39.860 --> 11:40.860
传到A

11:40.860 --> 11:41.860
传到A

11:41.860 --> 11:42.860
传到A

11:42.860 --> 11:43.860
传到A

11:43.860 --> 11:44.860
传到A

11:44.860 --> 11:45.860
传到A

11:45.860 --> 11:46.860
传到A

11:46.860 --> 11:47.860
传到A

11:47.860 --> 11:48.860
传到A

11:48.860 --> 11:49.860
传到A

11:49.860 --> 11:50.860
传到A

11:50.860 --> 11:52.860
传到了B

11:52.860 --> 11:53.860
好 那么这里等

11:53.860 --> 11:55.860
我们是不是就可以确定A

11:55.860 --> 11:57.860
等于R

11:57.860 --> 11:59.860
B等于3

11:59.860 --> 12:01.860
是不是可以确定参数了

12:01.860 --> 12:02.860
对吧

12:02.860 --> 12:04.860
那么确定参数的时候

12:04.860 --> 12:05.860
它还要做一件事

12:05.860 --> 12:08.860
就是同时确定Oguments

12:08.860 --> 12:09.860
我们知道

12:09.860 --> 12:11.860
函数里边是不是可以用一个关键字

12:11.860 --> 12:13.860
叫做Oguments

12:13.860 --> 12:14.860
对吧

12:14.860 --> 12:18.860
尽管在ES5之后

12:18.860 --> 12:20.860
就不太推荐使用这个玩意了

12:20.860 --> 12:22.860
特别是ES6之后

12:22.860 --> 12:23.860
甚至很多公司里边

12:23.860 --> 12:25.860
已经禁止使用这个东西了

12:25.860 --> 12:27.860
但它确实存在

12:27.860 --> 12:28.860
我们这里顺便说了

12:28.860 --> 12:29.860
因为它面试的时候

12:29.860 --> 12:31.860
仍然可能会遇到

12:31.860 --> 12:33.860
这个玩意它是一个伪数组

12:33.860 --> 12:35.860
就是它看上去像一个数组

12:35.860 --> 12:37.860
它其实不是数组

12:37.860 --> 12:38.860
伪

12:38.860 --> 12:39.860
数组

12:39.860 --> 12:41.860
有的时候我们把它叫做类数组

12:41.860 --> 12:44.860
类似数组

12:44.860 --> 12:47.860
那么我们就把它当成数组来看吧

12:47.860 --> 12:48.860
那么这个玩意是什么呢

12:48.860 --> 12:50.860
这个玩意就是记录所有的参数

12:50.860 --> 12:51.860
你传了几个参数

12:51.860 --> 12:52.860
就会有记录几个参数

12:52.860 --> 12:54.860
二和三

12:54.860 --> 12:55.860
所以说第一步

12:55.860 --> 12:56.860
它做了什么事

12:56.860 --> 12:58.860
确定参数

12:58.860 --> 13:00.860
每个行参的值

13:00.860 --> 13:01.860
确定下来了

13:01.860 --> 13:03.860
等于传过来了二

13:03.860 --> 13:05.860
实参到行参

13:05.860 --> 13:07.860
实参到行参

13:07.860 --> 13:09.860
实参到行参

13:09.860 --> 13:11.860
行参确定下来

13:11.860 --> 13:13.860
然后Oguments的关键字

13:13.860 --> 13:15.860
确定下来

13:16.860 --> 13:20.860
我顺便说一下

13:20.860 --> 13:22.860
如果说你基础

13:22.860 --> 13:24.860
是经过系统性的学习的话

13:24.860 --> 13:27.860
应该这一块知识你是知道的

13:27.860 --> 13:29.860
就是这个东西

13:29.860 --> 13:30.860
Oguments里面的东西

13:30.860 --> 13:33.860
跟行参是绑定的

13:33.860 --> 13:35.860
怎么绑定的呢

13:35.860 --> 13:36.860
就是如果说

13:36.860 --> 13:39.860
我在这里把它修改为了三

13:39.860 --> 13:43.860
那么这个东西会自动变为三

13:43.860 --> 13:44.860
能理解吗

13:44.860 --> 13:45.860
再试一下

13:45.860 --> 13:46.860
这点我不知道

13:46.860 --> 13:47.860
我们清不清楚这个点

13:47.860 --> 13:48.860
就顺便说一下

13:48.860 --> 13:50.860
因为它有可能会出现在

13:50.860 --> 13:55.130
面试体里边

13:55.130 --> 13:57.130
比方说我这些文件讲

13:57.130 --> 13:58.130
科堂代码

14:02.530 --> 14:04.530
比方说我们这里写个函数

14:04.530 --> 14:08.480
Message

14:08.480 --> 14:12.180
这里写个A和D

14:12.180 --> 14:13.180
这里我们调用它

14:13.180 --> 14:14.180
Message

14:14.180 --> 14:15.180
二和三

14:15.180 --> 14:16.180
好 接下来

14:16.180 --> 14:18.180
我们的函数里面做什么事呢

14:18.180 --> 14:20.180
做一

14:20.180 --> 14:22.180
A++

14:22.180 --> 14:23.180
就A++

14:23.180 --> 14:25.180
然后我们输出一个A

14:25.180 --> 14:28.180
再输出一个Argument0

14:28.180 --> 14:30.180
它会怎么样呢

14:30.180 --> 14:32.180
好 这两个东西

14:32.180 --> 14:33.180
好像没有什么关系对吧

14:33.180 --> 14:36.180
但上面是有关系的

14:36.180 --> 14:37.180
现在是什么情况

14:37.180 --> 14:39.180
现在的AO里面就是这种情况

14:39.180 --> 14:41.180
AO里面就是一块内存空间

14:41.180 --> 14:43.180
它存了一些东西

14:43.180 --> 14:45.180
可以在函数的执行期间

14:45.180 --> 14:47.180
随时使用

14:47.180 --> 14:49.180
那么这里的A用的是什么A

14:49.180 --> 14:51.180
用的就是AO里面的A

14:52.180 --> 14:54.180
这里的Argument0用的是什么

14:54.180 --> 14:55.180
用的就是这个

14:55.180 --> 14:59.550
在调用在确定参数的时候

14:59.550 --> 15:02.550
它会把这个东西跟行参进行绑定

15:02.550 --> 15:04.550
你行参不就A和B吗

15:04.550 --> 15:07.550
那么这个玩意就匹配了这个玩意

15:08.550 --> 15:11.550
这个玩意它就匹配了这个玩意

15:11.550 --> 15:13.550
它只要一变

15:13.550 --> 15:14.550
它就跟着变

15:14.550 --> 15:15.550
它只要一变

15:15.550 --> 15:16.550
它就跟着变

15:16.550 --> 15:18.550
就这么简单

15:18.550 --> 15:20.550
那么我们这里使用了A++

15:20.550 --> 15:22.550
把它变成了3

15:22.550 --> 15:24.550
同时它会自动变成3

15:25.550 --> 15:26.550
运行

15:26.550 --> 15:27.550
说两个3

15:27.550 --> 15:28.550
什么意思

15:28.550 --> 15:30.550
就这么个意思

15:30.550 --> 15:32.550
那么换而言之

15:32.550 --> 15:36.550
那如果说我们这里Argument0

15:36.550 --> 15:38.550
加加了

15:38.550 --> 15:39.550
那是一样的道理

15:39.550 --> 15:41.550
它一开始是2

15:41.550 --> 15:42.550
对吧

15:42.550 --> 15:43.550
那我把它加一

15:43.550 --> 15:44.550
那么它也会加一

15:44.550 --> 15:46.550
这两个玩意是比较特殊的

15:46.550 --> 15:48.550
它会有一个绑定

15:48.550 --> 15:49.550
这一块能理解吗

15:49.550 --> 15:51.550
能理解的话打个1

15:51.550 --> 16:03.590
好

16:03.590 --> 16:04.590
这是第一步

16:04.590 --> 16:08.590
第一步是确定参数

16:08.590 --> 16:10.590
我刚才变成这个样子

16:10.590 --> 16:11.590
把它换回去

16:12.590 --> 16:13.590
好 第二步

16:13.590 --> 16:16.590
提取函数声明

16:16.590 --> 16:18.590
这是什么意思呢

16:19.590 --> 16:20.590
它指的是

16:20.590 --> 16:23.590
我不是要运行这个Mesh的函数吗

16:23.590 --> 16:25.590
这个函数里边

16:25.590 --> 16:28.590
有没有函数声明啊

16:28.590 --> 16:29.590
什么叫做

16:29.590 --> 16:31.590
首先你要搞清楚

16:31.590 --> 16:35.590
什么叫做函数声明

16:35.590 --> 16:38.590
就是孤零零的写了这么一个函数

16:38.590 --> 16:39.590
还有名字

16:39.590 --> 16:42.590
参数 函数体

16:42.590 --> 16:44.590
这就是函数声明

16:44.590 --> 16:46.590
那么除了函数声明之外

16:46.590 --> 16:49.590
还有一种写法叫做函数表达式

16:49.590 --> 16:50.590
你看

16:50.590 --> 16:51.590
我在这里这样子写

16:51.590 --> 16:53.590
它是一个函数声明

16:53.590 --> 16:54.590
对吧

16:54.590 --> 16:55.590
那么还有一种写法

16:55.590 --> 16:57.590
叫做函数表达式

16:57.590 --> 17:02.120
比方说这样子写

17:02.120 --> 17:05.120
它叫做函数表达式

17:05.120 --> 17:07.120
那我们有的时候啊

17:07.120 --> 17:10.120
怎么能够方便的确认

17:10.120 --> 17:12.120
它到底是函数声明

17:12.120 --> 17:14.120
还是函数表达式呢

17:14.120 --> 17:17.120
特别简单

17:17.120 --> 17:19.120
除了这种写法

17:19.120 --> 17:22.120
其他全是函数表达式

17:22.120 --> 17:24.120
除了这种写法

17:24.120 --> 17:26.120
其他全是函数表达式

17:26.120 --> 17:28.120
那就没有任何问题了

17:28.120 --> 17:29.120
对吧

17:29.120 --> 17:30.120
你这里可以加名字

17:30.120 --> 17:31.120
但是你这种写法

17:31.120 --> 17:32.120
而不是这种写法

17:32.120 --> 17:34.120
那就是函数表达式

17:34.120 --> 17:36.120
这个就是函数表达式

17:36.120 --> 17:40.120
所以一定要分清楚概念啊

17:40.120 --> 17:42.120
那么这里我们要提取的是啥

17:42.120 --> 17:46.120
提取的是函数声明

17:46.120 --> 17:48.120
那啥意思呢

17:48.120 --> 17:50.120
就是说我在这个L里面

17:50.120 --> 17:51.120
除了放函数之外

17:51.120 --> 17:54.120
我还要放一些东西

17:54.120 --> 17:55.120
还要放啥呢

17:55.120 --> 17:58.120
还要放函数

17:58.120 --> 18:00.120
比方说这个M

18:00.120 --> 18:02.120
有一个函数声明吗

18:02.120 --> 18:03.120
对不对

18:03.120 --> 18:05.120
好 那我就把M提到这来了

18:05.120 --> 18:06.120
它是一个啥呀

18:06.120 --> 18:08.120
它是一个函数

18:08.120 --> 18:09.120
就放函

18:09.120 --> 18:12.120
就这么简单

18:12.120 --> 18:13.120
就像登革跑步一样

18:13.120 --> 18:15.120
我先要准备一些东西

18:15.120 --> 18:16.120
准备好了过后

18:16.120 --> 18:17.120
我再跑

18:17.120 --> 18:19.120
那么这里也是一个道理

18:19.120 --> 18:21.120
提这个函数声明

18:21.120 --> 18:22.120
放到L里面

18:22.120 --> 18:23.120
第二步

18:23.120 --> 18:24.120
第二步有个情况

18:24.120 --> 18:27.120
就是如果说遇到了同名问题

18:27.120 --> 18:29.120
覆盖啥意思

18:29.120 --> 18:31.120
什么叫遇到同名问题

18:31.120 --> 18:33.120
那么比方说这里的函数

18:33.120 --> 18:34.120
写的不是M

18:34.120 --> 18:36.120
写的是一个A

18:36.120 --> 18:37.120
是不是同名了

18:37.120 --> 18:39.120
跟参数同名了

18:39.120 --> 18:41.120
那怎么办呢

18:41.120 --> 18:42.120
那怎么办

18:42.120 --> 18:44.120
好 咱们比方说来试一下

18:44.120 --> 18:46.120
还是这个情况

18:46.120 --> 18:49.500
那我们现在呢

18:49.500 --> 18:53.500
给它声明一个函数A

18:53.500 --> 18:56.500
好 那这是什么情况呢

18:56.500 --> 18:57.500
你看 第一步

18:57.500 --> 18:59.500
确诊参数没问题吧

18:59.500 --> 19:00.500
第二步

19:00.500 --> 19:01.500
这里是不是一个A了

19:01.500 --> 19:03.500
函数声明

19:03.500 --> 19:05.500
这函数一声明吧

19:05.500 --> 19:07.500
它是不是就

19:07.500 --> 19:10.500
有一个A是一个函数

19:10.500 --> 19:11.500
对吧

19:11.500 --> 19:12.500
但是呢

19:12.500 --> 19:14.500
由于这个A跟这个A同名了

19:14.500 --> 19:16.500
它不能有两个A呗

19:16.500 --> 19:17.500
那于是怎么办

19:17.500 --> 19:18.500
你看这里所有怎么办

19:18.500 --> 19:19.500
覆盖

19:19.500 --> 19:20.500
什么叫覆盖

19:20.500 --> 19:23.500
就是把之前的值给它覆盖掉

19:23.500 --> 19:25.500
相当于它重新复制了一个函数

19:25.500 --> 19:26.500
那么A的变化

19:26.500 --> 19:28.500
它这里要变化

19:28.500 --> 19:30.500
懂这个意思吗

19:30.500 --> 19:32.500
所以

19:32.500 --> 19:33.500
你看一下这个代码

19:33.500 --> 19:35.500
如果说我在这儿

19:35.500 --> 19:37.500
去输出一个A

19:37.500 --> 19:39.500
你会得到一个什么呀

19:39.500 --> 19:40.500
在这里

19:40.500 --> 19:42.500
会得到一个函数

19:42.500 --> 19:45.940
那么我在这里去输出

19:45.940 --> 19:47.940
输出一个Oguments

19:47.940 --> 19:49.940
0

19:49.940 --> 19:51.940
会得到一个什么呀

19:51.940 --> 19:53.940
会得到一个函数

19:53.940 --> 19:54.940
看到没

19:54.940 --> 19:57.940
这就是为什么会有这样的现象

19:57.940 --> 19:59.940
好多是第二步

19:59.940 --> 20:02.940
好第二步搞定了之后呢

20:02.940 --> 20:04.940
继续到第三步

20:04.940 --> 20:07.940
提取变量声明

20:07.940 --> 20:09.940
那么这个变量声明又是什么呢

20:09.940 --> 20:10.940
往上看

20:10.940 --> 20:13.940
比方说这里是不是生理了一个变量

20:13.940 --> 20:15.940
对不对

20:15.940 --> 20:17.940
我说的不是变量复制

20:17.940 --> 20:19.940
是变量声明

20:19.940 --> 20:21.940
就这一部分

20:21.940 --> 20:24.940
变量声明

20:24.940 --> 20:26.940
那么这一块呢

20:26.940 --> 20:28.940
就变成了

20:28.940 --> 20:29.940
提取出来

20:29.940 --> 20:30.940
怎么提取呢

20:30.940 --> 20:32.940
就是直接写上这个变量的名字

20:32.940 --> 20:34.940
然后

20:34.940 --> 20:35.940
给它设置为一个值

20:35.940 --> 20:36.940
值为什么呢

20:36.940 --> 20:38.940
值为undefend

20:38.940 --> 20:43.210
undefend

20:43.210 --> 20:45.210
这完事了

20:45.210 --> 20:46.210
那么第三步

20:46.210 --> 20:48.210
如果说也遇到了同名问题

20:48.210 --> 20:49.210
怎么办

20:49.210 --> 20:51.210
忽略

20:51.210 --> 20:52.210
这是优势啥意思呢

20:52.210 --> 20:53.210
比方说

20:53.210 --> 20:54.210
我举个例子

20:54.210 --> 20:57.210
我这里不是定义的是

20:57.210 --> 21:00.840
我定的是个变量A

21:00.840 --> 21:03.840
那么这里输出一个A

21:03.840 --> 21:07.540
那这会输出什么呢

21:07.540 --> 21:08.540
咱们又来看一下

21:08.540 --> 21:11.540
从到位履一遍

21:11.540 --> 21:12.540
这里一开始是一个二

21:12.540 --> 21:13.540
第一步确定参数

21:13.540 --> 21:14.540
对吧

21:14.540 --> 21:16.540
二和三

21:16.540 --> 21:18.540
然后我们找寒树声明

21:18.540 --> 21:19.540
这里边有寒树声明吗

21:19.540 --> 21:21.540
没有

21:21.540 --> 21:22.540
第三步

21:22.540 --> 21:23.540
找变量声明

21:23.540 --> 21:24.540
这里边有变量声明吗

21:24.540 --> 21:26.540
有一个A

21:26.540 --> 21:27.540
那么我在打算干嘛

21:27.540 --> 21:29.540
打算给A

21:29.540 --> 21:31.540
加上一个undefend

21:31.540 --> 21:32.540
是不是这样子

21:32.540 --> 21:35.540
但是这个A是不是又重明了

21:35.540 --> 21:36.540
重明了

21:36.540 --> 21:37.540
重明了怎么办

21:37.540 --> 21:40.540
这里跟寒树的处理不一样

21:40.540 --> 21:43.540
忽略

21:43.540 --> 21:46.540
重明过后我就忽略了

21:46.540 --> 21:48.540
就当我没写

21:48.540 --> 21:50.540
说到这里输出啥

21:50.540 --> 21:51.540
在这句话的时候

21:51.540 --> 21:54.540
输出一个R

21:54.540 --> 21:56.540
看到没

21:56.540 --> 21:58.540
这是为什么

21:58.540 --> 21:59.540
那换而言是

21:59.540 --> 22:00.540
如果说没有重明了

22:00.540 --> 22:02.540
比方说这里一个D

22:02.540 --> 22:03.540
没有重明了

22:03.540 --> 22:04.540
这里就是有一个D

22:04.540 --> 22:06.540
undefend

22:06.540 --> 22:07.540
那么这里输出D

22:07.540 --> 22:08.540
会得到什么

22:08.540 --> 22:10.540
会得到一个undefend

22:10.540 --> 22:11.540
这其实是我们平时

22:11.540 --> 22:13.540
大家学的啥

22:13.540 --> 22:14.540
就是你们学的那个

22:14.540 --> 22:17.540
什么叫变量提升

22:17.540 --> 22:18.540
对吧

22:18.540 --> 22:19.540
现在明白了吧

22:19.540 --> 22:23.540
什么叫做变量提升

22:23.540 --> 22:24.540
什么叫变量提升

22:24.540 --> 22:27.540
就是把一个变量的声明

22:27.540 --> 22:29.540
放到哪儿了去

22:29.540 --> 22:32.540
把个变量放到了AO里边去了

22:32.540 --> 22:36.540
提到了寒树执行之前去了

22:36.540 --> 22:38.540
这就是提升

22:38.540 --> 22:39.540
我们有的时候

22:39.540 --> 22:40.540
简单说

22:40.540 --> 22:41.540
我们把变量提升

22:41.540 --> 22:43.540
方向那个是

22:43.540 --> 22:44.540
提到了手行

22:44.540 --> 22:45.540
第一行

22:45.540 --> 22:46.540
其实不是第一行

22:46.540 --> 22:49.540
提到了AO里边去了

22:49.540 --> 22:51.540
有这么一回事

22:51.540 --> 22:53.540
一共同就是这么三个步骤

22:53.540 --> 22:55.540
这三个步骤

22:55.540 --> 22:57.540
就共同确定了

22:57.540 --> 22:58.540
一二三走下来

22:58.540 --> 22:59.540
那么AO里边的东西

22:59.540 --> 23:00.540
就确定下来了

23:00.540 --> 23:03.540
AO里边确定下来了之后

23:03.540 --> 23:04.540
就可以执行这个寒树了

23:04.540 --> 23:05.540
就可以开始运行

23:05.540 --> 23:08.540
这里边的代码

23:08.540 --> 23:09.540
以后我们再具体

23:09.540 --> 23:10.540
通过一些题

23:10.540 --> 23:11.540
来详细的描述一下

23:11.540 --> 23:13.540
它是怎么运行的

23:13.540 --> 23:14.540
那么听到这一块

23:14.540 --> 23:16.540
看一下同学有没有什么问题

23:16.540 --> 23:17.540
没问题的话

23:17.540 --> 23:18.540
打个1

23:18.540 --> 23:19.540
有问题的话

23:19.540 --> 23:22.940
打出一个问题

23:22.940 --> 23:23.940
什么

23:23.940 --> 23:26.940
音色关系

23:26.940 --> 23:29.940
不要随便去取名字

23:29.940 --> 23:31.940
不要随便去取名字

23:31.940 --> 23:32.940
哈罗沃尔的同学

23:32.940 --> 23:33.940
哈罗沃尔的同学

23:33.940 --> 23:40.260
也是28期的时候

23:40.260 --> 23:42.260
它是个绑定关系

23:42.260 --> 23:44.260
什么叫绑定关系呢

23:44.260 --> 23:46.260
它们就两个是一个东西

23:46.260 --> 23:48.260
argument 这一块的内存空间

23:48.260 --> 23:49.260
跟这一块的内存空间

23:49.260 --> 23:50.260
是一块内存空间

23:50.260 --> 23:51.260
这在GX代码里边

23:51.260 --> 23:52.260
是绝无仅有的

23:52.260 --> 23:54.260
你们可能是

23:54.260 --> 23:56.260
你们可能以后要到

23:56.260 --> 23:58.260
模块化的时候

23:58.260 --> 23:59.260
才会学到另外一种绑定

23:59.260 --> 24:00.260
叫做符号绑定

24:00.260 --> 24:04.460
那个瓦尔也是

24:04.460 --> 24:06.460
共用一块内存空间

24:06.460 --> 24:08.460
目前GX里边

24:08.460 --> 24:10.460
你找不到任何一个办法

24:10.460 --> 24:11.460
可以让两个东西

24:11.460 --> 24:14.460
共用一块内存空间

24:14.460 --> 24:15.460
对啊

24:15.460 --> 24:17.460
argument0和A

24:17.460 --> 24:20.460
它们是绑定关系

24:20.460 --> 24:21.460
它们绑定的是

24:21.460 --> 24:23.460
一块内存空间

24:23.460 --> 24:25.460
音色的话

24:25.460 --> 24:26.460
在我们GX里边

24:26.460 --> 24:27.460
有别的含义

24:27.460 --> 24:29.460
不要乱测

24:29.460 --> 24:31.460
音制程同学又说

24:31.460 --> 24:32.460
是干的

24:32.460 --> 24:34.460
也不是那个意思

24:34.460 --> 24:36.460
完全不是一一码事

24:36.460 --> 24:38.460
目前我们不用去细咎这个东西

24:38.460 --> 24:39.460
因为我跟你们讲

24:39.460 --> 24:41.460
里边也很难体会

24:41.460 --> 24:43.460
如果说你们学过C语言的话

24:43.460 --> 24:45.460
你们可能会能体会

24:45.460 --> 24:47.460
因为C语言它有取指符号

24:47.460 --> 24:49.460
结果可以取一个辩量

24:49.460 --> 24:51.460
它的地址在哪里

24:51.460 --> 24:53.460
但是GX是没有这个东西的

24:53.460 --> 24:54.460
所以说GX是无法

24:54.460 --> 24:56.460
人为了去制造绑定的

24:56.460 --> 24:57.460
它只能根据语言特性

24:57.460 --> 24:58.460
去制造绑定

24:58.460 --> 24:59.460
不过这些东西

24:59.460 --> 25:01.460
在谈这些东西

25:01.460 --> 25:03.460
是有点过早了

25:03.460 --> 25:04.460
真的有点过早了

25:04.460 --> 25:05.460
而且我这里都说多了

25:05.460 --> 25:07.460
也不知道我在说啥

25:07.460 --> 25:09.460
这两个字玩意是一个内存空间

25:09.460 --> 25:11.460
根本就是一个内存空间

25:11.460 --> 25:13.460
这个在用GX单码

25:13.460 --> 25:15.460
用普通的GX单码是实现不了的

25:15.460 --> 25:16.460
GX没有

25:16.460 --> 25:18.460
高级语言它不提供这样的功能

25:18.460 --> 25:20.460
我记得CXOP语言

25:20.460 --> 25:21.460
可以提供

25:21.460 --> 25:24.460
CXOP语言它有个Rave

25:24.460 --> 25:27.460
来读取一个

25:28.460 --> 25:30.460
辨量的引用

25:30.460 --> 25:32.460
但是加把语言都没有

25:32.460 --> 25:34.460
有的时候说加把语言

25:34.460 --> 25:36.460
它们不是一个

25:36.460 --> 25:39.460
加把中没有引用内存

25:39.460 --> 25:41.460
没有引用传递

25:41.460 --> 25:43.460
它也是有道理的

25:43.460 --> 25:45.460
说远了说远了

25:45.460 --> 25:46.460
说回这

25:47.460 --> 25:49.460
说完了你看

25:49.460 --> 25:51.460
这是那个

25:51.460 --> 25:53.460
这三个步骤

25:53.460 --> 25:55.460
那么这里还有一点

25:55.460 --> 25:57.460
那同学们需要注意

25:57.460 --> 25:59.460
就是一定是

25:59.460 --> 26:01.460
调用函数的

26:02.460 --> 26:05.460
它一定是调用函数的时候

26:05.460 --> 26:08.460
才会有这个AO吗

26:08.460 --> 26:10.460
也不一定

26:10.460 --> 26:11.460
还有一种情况

26:11.460 --> 26:13.460
它不调用函数

26:13.460 --> 26:14.460
也会产生AO

26:14.460 --> 26:16.460
除了调用函数之外

26:16.460 --> 26:18.460
还有一种情况

26:18.460 --> 26:21.460
就是执行全局代码之前

26:21.460 --> 26:23.460
你可以把全局代码

26:23.460 --> 26:26.460
看成是一个特殊的函数调用

26:28.460 --> 26:30.460
那么由全局代码

26:30.460 --> 26:31.460
产生的执行上下文

26:31.460 --> 26:33.460
称之为全局上下文

26:33.460 --> 26:34.460
这啥意思呢

26:34.460 --> 26:35.460
就是说

26:35.460 --> 26:38.460
我们为什么要全局上下文

26:38.460 --> 26:40.460
是因为我要在跑步之前

26:40.460 --> 26:42.460
我要准备一些东西

26:43.460 --> 26:45.460
为什么要执行上下文

26:45.460 --> 26:47.460
是因为我要在运行函数之前

26:47.460 --> 26:48.460
要准备一些东西

26:48.460 --> 26:49.460
才能运行函数

26:49.460 --> 26:51.460
如果说没有函数呢

26:52.460 --> 26:54.460
没有函数呢

26:55.460 --> 26:57.460
不然我就这些简单一点

26:57.460 --> 26:59.460
就去定一个变量吧

26:59.460 --> 27:02.460
那么我就要去执行这些变量

27:02.460 --> 27:04.460
就是执行这些代码

27:04.460 --> 27:06.460
是不是在跑步

27:06.460 --> 27:08.460
是不是也在执行代码

27:08.460 --> 27:11.460
执行任何代码之前

27:11.460 --> 27:13.460
它都要做准备工作

27:13.460 --> 27:15.460
也就是执行这个全局代码之前

27:15.460 --> 27:17.460
它也要做准备工作

27:17.460 --> 27:19.460
怎么准备

27:19.460 --> 27:22.460
产生全局上下文

27:23.460 --> 27:26.460
全局上下文它也是执行上下文

27:27.460 --> 27:29.460
那么一个全局上下文呢

27:29.460 --> 27:31.460
它里面也有L

27:31.460 --> 27:32.460
只不过有的时候

27:32.460 --> 27:34.460
我们把全局上下文的L

27:34.460 --> 27:36.460
叫做既L

27:37.460 --> 27:39.460
包里是一样的

27:39.460 --> 27:41.460
还有什么区别呢

27:41.460 --> 27:43.460
就全局上下文里面

27:43.460 --> 27:44.460
它没有第一步了

27:44.460 --> 27:46.460
没有确定参数这一步了

27:46.460 --> 27:47.460
为啥呢

27:47.460 --> 27:48.460
包里有啥参数

27:48.460 --> 27:49.460
它没有参数

27:49.460 --> 27:51.460
它又不是一个函数

27:51.460 --> 27:52.460
它没有第一步

27:52.460 --> 27:54.460
它只有第二步和第三步

27:55.460 --> 27:56.460
然后比方我们就在这

27:56.460 --> 27:58.460
来看一下第二步和第三步

27:59.460 --> 28:01.460
或者说我们再研究一下这个代码

28:01.460 --> 28:16.550
研究一下这个代码

28:16.550 --> 28:18.550
这个代码到底是啥意思

28:19.550 --> 28:21.550
首先创建一个

28:21.550 --> 28:23.550
我们现在要重生二位还是执行

28:23.550 --> 28:25.550
是不是要执行全局代码

28:25.550 --> 28:28.550
要执行全局代码之前

28:28.550 --> 28:31.550
它就要搞进全局上下文

28:33.550 --> 28:35.550
全局上下文里面有个AO

28:35.550 --> 28:37.550
我们通常把它叫做既O

28:37.550 --> 28:38.550
好 第一步做啥

28:38.550 --> 28:39.550
确定参数

28:39.550 --> 28:40.550
有参数吗

28:40.550 --> 28:42.550
全局没有参数

28:42.550 --> 28:44.550
没有参数怎么办

28:44.550 --> 28:45.550
进入第二步

28:45.550 --> 28:49.550
找到全局里面的函数声明

28:49.550 --> 28:50.550
有没有啊

28:50.550 --> 28:51.550
是不是有个这个

28:51.550 --> 28:54.550
说全局里面的函数声明是什么

28:54.550 --> 28:59.080
是一个函数

29:00.080 --> 29:02.080
它有两个函数B和C

29:03.080 --> 29:05.080
好 第二步完成

29:05.080 --> 29:06.080
第三步

29:06.080 --> 29:09.080
找到全局的变量声明

29:10.080 --> 29:11.080
是不是这个

29:11.080 --> 29:12.080
只有这个嘛

29:12.080 --> 29:14.080
因此得到一个A

29:14.080 --> 29:16.080
等于RDFAN

29:16.080 --> 29:19.710
好 完成

29:19.710 --> 29:21.710
全局上下文准备好了

29:21.710 --> 29:23.710
然后开始执行代码

29:23.710 --> 29:25.710
输出啥

29:25.710 --> 29:26.710
它还能输出啥

29:26.710 --> 29:30.860
它只能输出一个1

29:33.550 --> 29:35.550
哎呀 我的天呐

29:36.550 --> 29:38.550
真的有点烦人

29:38.550 --> 29:47.070
就这样吧

29:47.070 --> 29:49.070
好 一开始只能输出一个1

29:49.070 --> 29:51.070
不 输出一个RDFAN的

29:51.070 --> 29:52.070
对吧

29:52.070 --> 29:53.070
输出S啥

29:53.070 --> 29:56.070
S在GO里面是RDFAN的

29:57.070 --> 29:59.070
好 然后运行第三句话

29:59.070 --> 30:00.070
这啥意思

30:00.070 --> 30:03.070
把A改为1 重新复制给1

30:03.070 --> 30:05.070
重新复制为1

30:05.070 --> 30:07.070
那么这里变成了1

30:08.070 --> 30:09.070
好 接下来我继续往后

30:09.070 --> 30:11.070
第五句话它是不会执行的

30:11.070 --> 30:12.070
为什么呢

30:12.070 --> 30:14.070
因为已经被提出来了

30:14.070 --> 30:16.070
这个M已经被提出来了

30:16.070 --> 30:17.070
提到这了

30:17.070 --> 30:19.070
所以它第五句话是不会执行的

30:19.070 --> 30:21.070
之前已经被提升了

30:21.070 --> 30:23.070
提到那个机油里面去了

30:23.070 --> 30:24.070
然后第七句话

30:24.070 --> 30:26.070
调用M 调用M调用啥

30:26.070 --> 30:27.070
调用是这个

30:27.070 --> 30:30.070
好 那么现在是不是要运行M这个函数

30:30.070 --> 30:31.070
对不对

30:31.070 --> 30:33.070
就要运行M这个函数

30:33.070 --> 30:35.070
好 运行M这个函数呢

30:35.070 --> 30:37.070
它又要产生执行上下文

30:38.070 --> 30:40.070
那么把它叫做AO

30:40.070 --> 30:43.070
会叫做M函数的AO

30:45.070 --> 30:46.070
那怎么做

30:46.070 --> 30:47.070
三步 对吧

30:47.070 --> 30:49.070
第一步 确定参数

30:49.070 --> 30:51.070
2和3

30:51.070 --> 30:53.070
B就等于2

30:53.070 --> 30:55.070
C就等于3

30:56.070 --> 30:57.070
然后了Oc

30:59.070 --> 31:00.070
2和3

31:00.070 --> 31:07.130
对吧 又完成了

31:07.130 --> 31:09.130
好 然后第二步

31:09.130 --> 31:11.130
提取声明它这里边

31:11.130 --> 31:13.130
它这个函数里边没有声明

31:13.130 --> 31:14.130
没有第二步

31:14.130 --> 31:15.130
第三步 提取变量

31:15.130 --> 31:17.130
那这里边没有变量就没有了

31:17.130 --> 31:19.130
好了 函数运行结束

31:20.130 --> 31:21.130
运行结束过后

31:21.130 --> 31:23.130
它AO就会销毁

31:23.130 --> 31:24.130
没了

31:24.130 --> 31:26.130
好 权力大把也运行结束了

31:26.130 --> 31:27.130
那就没了

31:27.130 --> 31:28.130
所以大把很简单

31:28.130 --> 31:30.130
但是我们把过程给它分析一下

31:30.130 --> 31:32.130
就这么一个过程

31:32.130 --> 31:34.130
这就是咱们这一块

31:34.130 --> 31:35.130
第一块知识

31:35.130 --> 31:39.130
就是全局上下文的知识

31:39.130 --> 31:42.130
就是直行上下文的知识

31:42.130 --> 31:44.130
这是第一块知识

31:44.130 --> 31:45.130
看它没有什么问题

31:45.130 --> 31:46.130
没问题的话

31:46.130 --> 31:49.130
那么咱们就直接进入面试题了

31:49.130 --> 31:53.020
没问题

31:53.020 --> 31:54.020
没有

31:54.020 --> 31:56.020
没有 那我们就进入面试题了

31:56.020 --> 31:57.020
来吧

31:58.020 --> 32:09.010
我们还要复制一下

32:09.010 --> 32:11.010
或者我们主席在这里指示

32:11.010 --> 32:13.010
反正我也不在这里边写东西的

32:13.010 --> 32:14.010
好吧

32:14.010 --> 32:16.010
我们就直接在这里弄吧

32:17.010 --> 32:18.010
第一题

32:19.010 --> 32:21.010
来自于B站的面试题

32:22.010 --> 32:24.010
看一下这道题

32:24.010 --> 32:27.010
这道题考察的就是点心的考察了

32:27.010 --> 32:29.010
是直行上下文

32:29.010 --> 32:31.010
怎么来玩的

32:31.010 --> 32:33.010
怎么玩的

32:33.010 --> 32:35.010
折叠一下

32:35.010 --> 32:36.010
首先全局

32:36.010 --> 32:39.010
好像这个问题跟全局也没有什么关系

32:39.010 --> 32:42.010
没有什么关系 对吧

32:42.010 --> 32:44.010
全局里边有一个副等仪

32:44.010 --> 32:46.010
然后把这个副传进去

32:46.010 --> 32:48.010
就相当于传了个一进去

32:48.010 --> 32:50.010
是不是这个道理

32:50.010 --> 32:52.010
这个大法理要会看

32:52.010 --> 32:54.010
不要看它这里干扰你

32:54.010 --> 32:55.010
你说这里边

32:55.010 --> 32:57.010
传输名字跟它相同

32:57.010 --> 32:59.010
但是你这里传的

32:59.010 --> 33:00.010
这里有一个变量

33:00.010 --> 33:01.010
全局变量为一

33:01.010 --> 33:02.010
然后把副传进来

33:02.010 --> 33:07.010
相当于是读取这个变量的值

33:07.010 --> 33:08.010
值是啥

33:08.010 --> 33:09.010
一

33:09.010 --> 33:10.010
把这个一扔进去

33:10.010 --> 33:12.010
然后在这个传输里面去

33:12.010 --> 33:13.010
所以传输里面用的是啥

33:13.010 --> 33:15.010
用的是这个传输跟全局无关

33:15.010 --> 33:18.010
好 来 我们来分析一下它的AO

33:18.010 --> 33:20.010
就是Message的传输的AO

33:20.010 --> 33:22.010
那么现在调用Message的传输了

33:22.010 --> 33:24.010
这一步 第15行来调用

33:24.010 --> 33:25.010
它的AO是啥

33:25.010 --> 33:28.010
第一步 确定传输

33:28.010 --> 33:30.010
传输为副 值是啥

33:30.010 --> 33:31.010
值是一

33:31.010 --> 33:32.010
对吧

33:32.010 --> 33:36.010
把这个全局变量的一传进来了

33:36.010 --> 33:37.010
所以传输的值有了

33:37.010 --> 33:42.980
然后还有一个Oguments

33:42.980 --> 33:43.980
也是一个一

33:43.980 --> 33:45.980
它们两个是绑定的

33:45.980 --> 33:49.680
好 这第一步完成

33:49.680 --> 33:51.680
第二步 第二步看啥

33:51.680 --> 33:53.680
看这个传输里面有没有声明

33:53.680 --> 33:55.680
传输声明 有没有

33:55.680 --> 33:57.680
它不是传输声明

33:57.680 --> 33:58.680
它是传输表达式

33:58.680 --> 34:00.680
有这个玩意是传输表达式

34:00.680 --> 34:02.680
这个玩意是传输声明

34:02.680 --> 34:04.680
怎么办

34:04.680 --> 34:06.680
写下来副

34:06.680 --> 34:07.680
它是一个传输

34:07.680 --> 34:09.680
我们就把它记作

34:09.680 --> 34:11.680
输出C的传输

34:11.680 --> 34:12.680
你这样写都可以

34:12.680 --> 34:15.680
以后作题就可以用这种方式来做

34:15.680 --> 34:17.680
万无一失

34:17.680 --> 34:20.680
好 第二步是不是遇到同名了

34:20.680 --> 34:21.680
同名怎么办

34:21.680 --> 34:23.680
同名还记得吗

34:23.680 --> 34:25.680
第二步 如果说出现同名

34:25.680 --> 34:26.680
怎么办

34:26.680 --> 34:31.660
就是覆盖

34:31.660 --> 34:33.660
那么这一覆盖

34:33.660 --> 34:35.660
就把

34:35.660 --> 34:36.660
它以前是一

34:36.660 --> 34:38.660
现在又变成了这个玩意了

34:38.660 --> 34:39.660
对吧

34:39.660 --> 34:40.660
这个玩意变的

34:40.660 --> 34:42.660
这个东西也变了

34:42.660 --> 34:43.660
是吧

34:43.660 --> 34:44.660
所以这个玩意变了

34:44.660 --> 34:46.660
它们绑定了吗

34:46.660 --> 34:48.660
这道题它也没有考察这个

34:48.660 --> 34:50.660
你写不写这个都无所谓

34:50.660 --> 34:52.660
好 第二步完成

34:52.660 --> 34:53.660
第三步

34:53.660 --> 34:55.660
不要被它其他东西干

34:55.660 --> 34:57.660
就老老实实按个步骤走

34:57.660 --> 34:59.660
就完全没问题

34:59.660 --> 35:01.660
你不要自己在那里瞎想

35:01.660 --> 35:02.660
自己去拆

35:02.660 --> 35:04.660
它这个盖码的指讯

35:04.660 --> 35:07.660
是有非常严格的顺序的

35:07.660 --> 35:08.660
第三步做什么

35:08.660 --> 35:11.660
找辨量

35:11.660 --> 35:12.660
哪些辨量

35:12.660 --> 35:14.660
这里也声明了个负

35:14.660 --> 35:15.660
两个都声明了负

35:15.660 --> 35:17.660
就生成一个

35:17.660 --> 35:18.660
你看它生成几个了

35:18.660 --> 35:20.660
反正都是两个地方的

35:20.660 --> 35:24.290
对不对

35:24.290 --> 35:26.290
好 那么这个时候又遇到重名了

35:26.290 --> 35:30.290
第三步遇到重名怎么办

35:30.290 --> 35:32.290
第三步遇到同名

35:32.290 --> 35:40.490
怎么说呢

35:40.490 --> 35:42.860
忽略

35:42.860 --> 35:43.860
对吧

35:43.860 --> 35:44.860
就忽略

35:44.860 --> 35:45.860
这就当没起

35:45.860 --> 35:47.860
完事了

35:47.860 --> 35:48.860
就这样了

35:48.860 --> 35:49.860
然后我们再来看

35:49.860 --> 35:50.860
来吧

35:51.860 --> 35:52.860
输出负

35:52.860 --> 35:54.860
你说能输出啥呀

35:54.860 --> 35:55.860
输出负了

35:55.860 --> 35:56.860
输出的是一个函数

35:56.860 --> 35:57.860
对吧

35:57.860 --> 35:59.860
输出的是一个函数

36:01.860 --> 36:03.860
就最好输出的是一个函数

36:03.860 --> 36:05.860
然后最好做什么

36:05.860 --> 36:07.860
给负重新负值

36:07.860 --> 36:08.860
负值为一个啥

36:08.860 --> 36:11.860
一个制服串A

36:11.860 --> 36:12.860
这个玩意就不管了

36:12.860 --> 36:14.860
反正跟它没关系的

36:14.860 --> 36:15.860
负质为一个A

36:15.860 --> 36:16.860
它变成A了

36:16.860 --> 36:18.860
然后这一步干嘛

36:18.860 --> 36:19.860
又在负值

36:19.860 --> 36:21.860
所以又在负值

36:21.860 --> 36:23.860
又把它负值为一个函数

36:23.860 --> 36:25.860
它又变成一个函数了

36:25.860 --> 36:27.860
变成一个输出B的函数

36:27.860 --> 36:29.860
输出B的函数

36:29.860 --> 36:30.860
对吧

36:30.860 --> 36:32.860
这个负值了吗

36:32.860 --> 36:33.860
就负值了

36:33.860 --> 36:34.860
你不要把函数

36:34.860 --> 36:36.860
想象成多么神奇的东西

36:36.860 --> 36:37.860
它就是

36:37.860 --> 36:38.860
我在戒严史里边

36:38.860 --> 36:40.860
函数是一等公名

36:40.860 --> 36:42.860
它就是一个对象

36:42.860 --> 36:43.860
它跟对象的区别

36:43.860 --> 36:44.860
又在于函数可以调用

36:44.860 --> 36:46.860
对象不能调用

36:46.860 --> 36:48.860
其实它跟对象是一样的

36:49.860 --> 36:50.860
你把这个东西

36:50.860 --> 36:51.860
把函数给它负值

36:51.860 --> 36:52.860
它就变成一个函数了

36:54.860 --> 36:56.860
然后去调用负

36:58.860 --> 36:59.860
调用了啥

36:59.860 --> 37:00.860
调用这个函数

37:00.860 --> 37:01.860
输出啥

37:01.860 --> 37:02.860
输出B

37:02.860 --> 37:03.860
对吧

37:03.860 --> 37:04.860
这一句话

37:04.860 --> 37:05.860
还会导致这个函数执行一遍

37:05.860 --> 37:06.860
输出B

37:07.860 --> 37:08.860
然后下边这个还运行吗

37:08.860 --> 37:09.860
是不运行的

37:09.860 --> 37:11.860
为什么这是函数声明

37:11.860 --> 37:12.860
函数声明之前

37:12.860 --> 37:14.860
早就提到这了

37:14.860 --> 37:16.860
只不过后面又被覆盖掉了

37:17.860 --> 37:18.860
早就提出去

37:18.860 --> 37:20.860
这句话是不运行的

37:20.860 --> 37:21.860
9到11行

37:22.860 --> 37:24.860
这个代码是不运行的

37:25.860 --> 37:27.860
它被提出去了

37:28.860 --> 37:29.860
然后再运行

37:29.860 --> 37:31.860
还是运行的输出B的函数

37:31.860 --> 37:32.860
输出两个B

37:32.860 --> 37:36.370
这到结果就是这个

37:37.370 --> 37:38.370
好 咱们运行看一下

37:41.000 --> 37:42.000
函数

37:42.000 --> 37:43.000
两个B

37:45.000 --> 37:46.000
这是第一题

37:46.000 --> 37:47.000
你们

37:48.000 --> 37:49.000
仔细评一下

37:51.000 --> 37:53.000
这个要提的干扰点

37:53.000 --> 37:54.000
就在于

37:56.000 --> 37:57.000
一个是

37:57.000 --> 37:58.000
就是主要是在这

37:58.000 --> 37:59.000
如果说你觉得

37:59.000 --> 38:01.000
这一块又要给它重新

38:01.000 --> 38:03.000
把它覆盖成输出C的函数的话

38:03.000 --> 38:04.000
那就错了

38:04.000 --> 38:05.000
因为输出C的函数

38:05.000 --> 38:06.000
早就提出去了

38:07.000 --> 38:08.000
早就提出去了

38:08.000 --> 38:09.000
所以这一块是

38:09.000 --> 38:11.000
不会重新声明一遍

38:11.000 --> 38:12.000
它声明只有一遍

38:12.000 --> 38:14.000
从最开始的时候

38:14.000 --> 38:15.000
就会提出声明

38:17.000 --> 38:18.000
这是第一题

38:21.000 --> 38:22.000
好 第二题

38:23.000 --> 38:24.000
一样的分析方式

38:25.000 --> 38:29.910
第二题的干扰项有点多

38:29.910 --> 38:30.910
它是你要会看

38:31.910 --> 38:33.910
第二题的method123

38:34.910 --> 38:35.910
用来分析AOB

38:35.910 --> 38:37.910
参数A1

38:37.910 --> 38:38.910
B

38:38.910 --> 38:39.910
R

38:39.910 --> 38:40.910
C

38:40.910 --> 38:41.910
3

38:41.910 --> 38:42.910
它这里面好像没有关系

38:42.910 --> 38:43.910
什么archimage

38:43.910 --> 38:44.910
不管了

38:45.910 --> 38:46.910
就ABC

38:47.910 --> 38:48.910
第二步

38:48.910 --> 38:49.910
做什么

38:49.910 --> 38:52.910
提取函数声明

38:52.910 --> 38:54.910
那么这里的关键问题

38:54.910 --> 38:55.910
就在于

38:55.910 --> 38:56.910
这个玩意儿

38:56.910 --> 38:57.910
这个玩意儿

38:57.910 --> 38:59.910
这个玩意儿

38:59.910 --> 39:01.910
是不是函数声明

39:01.910 --> 39:02.910
你们觉得是不是

39:03.910 --> 39:04.910
它干扰向在这儿

39:04.910 --> 39:06.910
因为你把它看成函数声明

39:06.910 --> 39:13.740
和不看成函数声明

39:13.740 --> 39:15.740
得到的结果是完全不一样的

39:17.740 --> 39:18.740
因为它看出来

39:18.740 --> 39:19.740
不就是个立即

39:19.740 --> 39:20.740
执行函数的格式吗

39:20.740 --> 39:21.740
对

39:21.740 --> 39:22.740
它不是函数声明

39:22.740 --> 39:24.740
我再一次重申

39:24.740 --> 39:25.740
函数声明

39:25.740 --> 39:27.740
只有唯一的一种邪法

39:27.740 --> 39:28.740
就是你其他啥也不写

39:28.740 --> 39:30.740
写个函数有个名字

39:30.740 --> 39:32.740
然后有个大国号

39:32.740 --> 39:34.740
只有这种邪法是函数声明

39:34.740 --> 39:35.740
其他全都不是

39:36.740 --> 39:38.740
你在左右加个大国

39:38.740 --> 39:39.740
抓起来加个什么

39:39.740 --> 39:40.740
小国号不是

39:41.740 --> 39:42.740
你前面第一个辩量

39:42.740 --> 39:43.740
不是

39:43.740 --> 39:44.740
只有这种邪法

39:44.740 --> 39:45.740
是函数声明

39:46.740 --> 39:47.740
或者再说了

39:47.740 --> 39:48.740
已经更加

39:48.740 --> 39:49.740
好方便一点

39:49.740 --> 39:51.740
就是你把函数的名字

39:51.740 --> 39:52.740
去掉

39:52.740 --> 39:53.740
它要爆错的

39:54.740 --> 39:55.740
就是函数声明

39:55.740 --> 39:56.740
你去掉名字不爆错的

39:56.740 --> 39:58.740
它就是函数表达式

39:58.740 --> 39:59.740
你看这一大名字

39:59.740 --> 40:00.740
你去掉肯定不爆错

40:00.740 --> 40:01.740
不然你们平时写的

40:01.740 --> 40:03.740
那个立即执行函数

40:03.740 --> 40:04.740
不就有问题了

40:04.740 --> 40:05.740
你看是不不爆错

40:06.740 --> 40:07.740
对吧

40:07.740 --> 40:08.740
但是如果说

40:08.740 --> 40:09.740
就像这种邪法

40:09.740 --> 40:10.740
这种邪法

40:10.740 --> 40:11.740
你把它名字去掉

40:12.740 --> 40:13.740
你看这里出一个红线

40:14.740 --> 40:15.740
出一个红线

40:15.740 --> 40:16.740
就爆错了

40:16.740 --> 40:17.740
只有这种才是函数声明

40:18.740 --> 40:19.740
好 咱们来

40:19.740 --> 40:20.740
由于他们三个

40:20.740 --> 40:24.120
不是函数声明

40:24.120 --> 40:25.120
那么这个函数

40:25.120 --> 40:26.120
里面就没有函数声明

40:27.120 --> 40:28.120
它里面没看有这么多函数

40:28.120 --> 40:29.120
全是表达式

40:30.120 --> 40:31.120
都不是函数声明

40:32.120 --> 40:33.120
那怎么办呢

40:33.120 --> 40:34.120
就凉办

40:34.120 --> 40:35.120
第二步就不进行了

40:35.120 --> 40:36.120
第三步

40:36.120 --> 40:37.120
确定辩量

40:38.120 --> 40:39.120
有哪些辩量呢

40:40.120 --> 40:41.120
定了一个A

40:42.120 --> 40:43.120
那就是安迪函那边

40:44.120 --> 40:45.120
定了一个B

40:45.120 --> 40:46.120
安迪函

40:47.120 --> 40:48.120
还有没有

40:48.120 --> 40:49.120
好像没有定义了

40:49.120 --> 40:50.120
一共就定义了

40:50.120 --> 40:51.120
两个辩量A和B

40:52.120 --> 40:53.120
那不巧的是

40:53.120 --> 40:54.120
这两个辩量

40:54.120 --> 40:55.120
是不是参数都有值了

40:55.120 --> 40:56.120
有同名的

40:56.120 --> 40:57.120
怎么办

40:57.120 --> 40:58.120
辩量有同名

41:00.120 --> 41:01.120
都出头又变成这个样子了

41:02.120 --> 41:04.120
然后输出

41:04.120 --> 41:05.120
输出ABC

41:05.120 --> 41:06.120
输出123

41:07.120 --> 41:08.120
123

41:09.120 --> 41:10.120
然后干嘛

41:10.120 --> 41:12.120
把一个制服串A

41:12.120 --> 41:13.120
重新复始给A

41:13.120 --> 41:14.120
那就复制

41:14.120 --> 41:16.120
它又变成一个制服串A

41:17.120 --> 41:20.120
然后把一个函数B复制给B

41:20.120 --> 41:22.120
它就变成一个函数B

41:24.120 --> 41:25.120
变成一个函数B

41:26.120 --> 41:29.120
然后这里运行了一个空的表达式

41:30.120 --> 41:32.120
我定义了一个函数表达式

41:32.120 --> 41:33.120
但是我啥也没干

41:34.120 --> 41:36.120
那这句话就相当于是啥也没做

41:36.120 --> 41:37.120
你做了啥吗

41:37.120 --> 41:38.120
你啥也没做

41:39.120 --> 41:40.120
你写了一个函数表达式在这

41:41.120 --> 41:42.120
有没有啥也没干

41:42.120 --> 41:43.120
注意一下

41:43.120 --> 41:46.120
你这里千万不要把A给它重新复辍为函数了

41:47.120 --> 41:49.120
因为你要这样子写才行

41:49.120 --> 41:52.120
才是把A重新复制为一个函数

41:53.120 --> 41:55.120
你这有没有给A重新复制

41:55.120 --> 41:56.120
没有

41:56.120 --> 41:58.120
你只是定了一个函数表达式而已

41:59.120 --> 42:02.120
就相当于是你在这里写的一个小括号

42:02.120 --> 42:03.120
1加1

42:03.120 --> 42:06.120
你说这个东西有啥意义

42:06.120 --> 42:08.120
它也是个表达式对吧

42:08.120 --> 42:09.120
你在这里写一个

42:09.120 --> 42:15.120
有什么意义 又没有输出 又没有干嘛 你就写个来加吧加完算了 我接着往下走

42:16.720 --> 42:22.680
你不是那个玩小孩吗 所以这个这三句话是没有任何意义的 这三句话

42:24.160 --> 42:29.600
一定要理解这个不然的话你要做错的 这话就写的跟那些是一样的 最后输出abc

42:30.200 --> 42:35.440
那A是啥一个制服串 制服串AB是啥一个函数 C是啥啥

42:36.320 --> 42:44.580
最终结果就是这个 这是它的最终结果 这题还是比较简单的 关键的

42:45.460 --> 42:48.860
就是有这些干扰下 你要知道怎么去看他 看待他

42:49.820 --> 42:57.500
这个小国号表示我这里边有个表达式 你把这个表达式运行一遍 我运行了怎么样嘛 我定了一个函数又怎么样嘛 我又被调用了

42:58.300 --> 43:01.860
我又没有重新复制了 对吧 这是第二道题啊

43:02.860 --> 43:06.460
好 第三题 第三题

43:09.100 --> 43:14.500
还有点意思啊 因为他有arbitrary名词了

43:15.780 --> 43:18.020
好 来 这题还是有点难度的

43:20.660 --> 43:25.700
调用task还说来吧 调两次啊 我们一次一次分析 第一次创建AO

43:26.820 --> 43:33.020
每一次都要创建哈 不是说第一次创建了 第二次就不创建了 每一次都要创建AO 重新创建全部重来

43:34.020 --> 43:37.020
好 传了一个参数

43:39.020 --> 43:41.020
A等于B

43:41.020 --> 43:45.020
B呢 奥迪凡 是不是这样

43:46.020 --> 43:51.020
B是奥迪凡的嘛 B没有传嘛 对吧 只传了一个E给A 没有传DB

43:52.020 --> 43:56.020
好 那么这个是argument是什么 注意啊 一定要搞清楚 argument是什么

43:58.020 --> 44:02.850
argument是有几个啊 只有一个

44:03.850 --> 44:10.850
因为这个玩意是反映的 真实的传参情况 你传了几个参数

44:11.850 --> 44:20.850
它只有一个D 那也就意味着argument的这个地方跟这个地方是绑定的

44:21.850 --> 44:26.850
跟它没关系 确实没关系 懂了意思吧

44:27.850 --> 44:31.850
它没有跟B形成绑定 它只跟A形成绑定了

44:32.850 --> 44:33.850
懂了意思吧

44:34.850 --> 44:36.850
好 然后我们继续啊

44:37.850 --> 44:42.850
然后就是第二步 第二步确定函数声明

44:44.850 --> 44:46.850
有没有函数声明 有啊 这不是函数声明是啥

44:47.850 --> 44:48.850
是啥 F

44:49.850 --> 44:52.850
这里不是有同名的吗 怎么办 覆盖

44:53.850 --> 44:54.850
覆盖掉

44:55.850 --> 44:59.850
好 第二步完成 第三步确定变量声明

44:59.850 --> 45:02.850
变量声明有几个 只有一个A

45:03.850 --> 45:04.850
只有一个A

45:05.850 --> 45:08.850
好 那么这里就是A 为arndefine

45:09.850 --> 45:11.850
有重名吗 有重名 忽略

45:12.850 --> 45:13.850
好 最终的L就是这样子

45:14.850 --> 45:16.850
L分析出来过后 最后一切都好办了

45:17.850 --> 45:19.850
首先第一句话 argument是0加加

45:20.850 --> 45:22.850
这一加加吧 是不是把它变成了一个啥

45:23.850 --> 45:26.850
变成了一个2 那它是不是也跟它变了 绑定的吗

45:27.850 --> 45:29.850
使用的是同一块内存

45:30.850 --> 45:32.850
然后输出A和B

45:33.850 --> 45:35.850
输出的就是2和F

45:37.850 --> 45:41.850
输出这两个东西 它都是一个函数表 函数

45:42.850 --> 45:46.850
好 接下来 这个玩意儿又把一个函数复制给了A

45:47.850 --> 45:48.850
它是不是变函数了

45:49.850 --> 45:50.850
它变函数了

45:53.990 --> 45:54.990
然后

45:55.990 --> 46:01.840
我看错了吗 我没看错

46:03.840 --> 46:04.840
没看错

46:05.840 --> 46:07.840
A变函数了 那么A变函数了 它是不是也变函数了

46:08.840 --> 46:09.840
A是跟它绑定的

46:10.840 --> 46:13.220
A变化 它就会变化

46:14.220 --> 46:15.220
然后我输出什么

46:16.220 --> 46:18.220
这个玩意儿是不是等于A

46:19.220 --> 46:21.220
跟这个函数是不是一样的 肯定是一样的

46:22.220 --> 46:24.220
两个都是同一个函数 同一块内存

46:25.220 --> 46:26.220
一定是一样的

46:27.220 --> 46:29.220
那么这里呢 第一个就是2

46:29.220 --> 46:31.220
第二个argument1

46:32.220 --> 46:35.220
是不是它的这个输出的第二项 第二项有吗

46:35.220 --> 46:38.220
没有 那么这个玩意儿是啥 是undefend

46:39.220 --> 46:40.220
是不是undefend

46:40.220 --> 46:42.220
是不是等于B呢

46:42.220 --> 46:44.220
B是啥 B是一个函数

46:44.220 --> 46:46.220
undefend跟B 函数肯定是互相等的force

46:47.220 --> 46:49.220
好 就第一次输出

46:51.220 --> 46:54.220
这个函数运行完了 运行完了过后A又消失 拜拜

46:56.910 --> 46:59.910
好 第二次 传了两个参数进来

46:59.910 --> 47:00.910
来 我们就快速分析一下

47:01.910 --> 47:05.910
第一个参数为1 第二个参数为undefend

47:06.910 --> 47:08.910
还是一样 但是这一次不一样

47:08.910 --> 47:11.910
这一次我是手动的给它传了两个参数

47:11.910 --> 47:12.910
因此它的argument

47:14.910 --> 47:16.910
是不是有两个 一个是1 一个是undefend

47:17.910 --> 47:19.910
而且这个玩意儿跟这个玩意儿是绑定的

47:22.290 --> 47:24.290
好 接下来就是不一样的地方

47:25.290 --> 47:28.290
它加1 还没完 函数声明

47:28.290 --> 47:31.290
函数声明是不是一个B 那么把这里覆盖掉了

47:33.290 --> 47:34.290
那这里也可不可以跟着变化

47:36.290 --> 47:37.290
绑定的吗

47:38.290 --> 47:41.290
然后变调声明 变调声明 因为这里有同名的

47:41.290 --> 47:42.290
所以说不动

47:42.290 --> 47:43.290
好 那么接下来

47:44.290 --> 47:47.290
它加加 它变2 它也跟着变成2

47:49.290 --> 47:50.290
然后输出A和B

47:50.290 --> 47:53.290
那输出啥 也是输出一样的2fn

47:55.290 --> 47:57.600
A和B嘛

47:57.600 --> 47:59.600
然后又是把一个函数复制给A

47:59.600 --> 48:01.600
那么A是不是变函数了

48:02.600 --> 48:03.600
变函数了

48:05.600 --> 48:07.600
到这里是不是也变函数了

48:07.600 --> 48:09.600
这个函数跟这个函数是一样的

48:10.600 --> 48:12.600
然后看一下 这个玩意儿跟A是不是相等

48:12.600 --> 48:14.600
那是不是相等 肯定相等

48:15.600 --> 48:17.600
那么第二个位置跟B是不是相等 肯定是相等

48:17.600 --> 48:18.600
它们是绑定的

48:20.600 --> 48:21.600
最多的结果就是这个

48:25.170 --> 48:26.170
看一下

48:28.170 --> 48:32.170
因为发现大厂的面试题也就这样了

48:33.170 --> 48:35.170
你要说它特别难得上天吧

48:35.170 --> 48:36.170
也就这样了 反正

48:37.170 --> 48:38.170
就是大厂的面试题

48:38.170 --> 48:41.170
很多都是类似于这种情况

48:42.170 --> 48:43.170
你没开销的时候

48:43.170 --> 48:44.170
觉得它难很难很难

48:45.170 --> 48:46.170
一旦想同了

48:46.170 --> 48:47.170
它就这样了

48:48.170 --> 48:49.170
它难度其实

48:49.170 --> 48:50.170
我们整个前端的难度

48:50.170 --> 48:52.170
其实是极其有限的

48:52.170 --> 48:54.170
它玩不出太多的新花样出来

48:55.170 --> 48:57.170
好 这是第一部分

48:57.170 --> 48:59.170
执行上下文

48:59.170 --> 49:01.170
你在做这些题的过程中

49:01.170 --> 49:04.170
你只要按照袁老师这种方式去分析

49:04.170 --> 49:05.170
那么这种题

49:05.170 --> 49:07.170
至少在执行上下文这一块支持

49:07.170 --> 49:08.170
你不会遇到任何问题

49:11.170 --> 49:12.170
好 这是第一部分

49:12.170 --> 49:13.170
执行上下文

49:13.170 --> 49:14.170
执行上下文

49:29.080 --> 49:32.080
袁老师的声音其实是非常红亮

49:32.080 --> 49:34.080
而有实性的

49:35.080 --> 49:38.580
这两天赏子不太好

49:38.580 --> 49:39.580
发挥不出来

49:42.150 --> 49:43.150
好 第二部分

49:43.150 --> 49:44.150
作用预列

49:46.150 --> 49:49.150
这个东西倒是有一点点绕

49:51.150 --> 49:52.150
你好好听

49:52.150 --> 49:53.150
你使劲挺

49:53.150 --> 49:55.150
你好好仔细评

49:55.150 --> 49:57.150
你还是能够明白它啥意思

49:59.150 --> 50:01.150
这作用预列是啥呢

50:01.150 --> 50:03.150
它其实就是EC

50:03.150 --> 50:04.150
EC是啥

50:05.150 --> 50:06.150
执行上下文

50:07.150 --> 50:08.150
就是这个玩意

50:09.150 --> 50:11.150
形成的链条

50:12.150 --> 50:13.150
但一定要注意

50:13.150 --> 50:16.150
当函数定义的时候

50:16.150 --> 50:18.150
这个链条它就产生了

50:19.150 --> 50:21.150
这个时间点不太对峻

50:22.150 --> 50:24.150
跟执行上下文

50:24.150 --> 50:27.150
不是要运行函数的时候才会产生吗

50:28.150 --> 50:30.150
你这个函数还没有运行

50:30.150 --> 50:32.150
定义的时候就链条怎么产生了

50:33.150 --> 50:35.150
一刀函数都还没有运行

50:35.150 --> 50:37.150
哪来的EC

50:37.150 --> 50:40.150
连EC都没有哪来的链条呢

50:40.150 --> 50:42.150
就很奇怪了

50:42.150 --> 50:43.150
但是你不着急

50:43.150 --> 50:45.150
你玩的仔细评

50:46.150 --> 50:48.150
就会发现它说的还是有道理的

50:48.150 --> 50:50.150
等一会我们就来评一下

50:50.150 --> 50:52.150
运行函数的时候

50:52.150 --> 50:55.150
如果需要东西不在当前的EC当中

50:55.150 --> 50:59.150
就从作用预列一次寻找

50:59.150 --> 51:00.150
还是很模糊

51:00.150 --> 51:02.150
来看个例子就明白了

51:03.150 --> 51:05.150
这里有一段代码

51:06.150 --> 51:09.150
这是一段全局代码

51:09.150 --> 51:10.150
好那我问大家了

51:10.150 --> 51:12.150
我这个全局代码要运行

51:12.150 --> 51:15.150
不得创建全局的执行上下文吗

51:15.150 --> 51:16.150
对吧

51:16.150 --> 51:18.150
那不得有AO吗

51:18.150 --> 51:19.150
得有吧

51:19.150 --> 51:21.150
那AO里面不得有东西吗

51:21.150 --> 51:22.150
有哪些东西

51:22.150 --> 51:23.150
A等于1

51:23.150 --> 51:24.150
这个很好理解对吧

51:24.150 --> 51:25.150
有个A辨量

51:25.150 --> 51:28.910
我好像写错了

51:28.910 --> 51:30.910
应该是一开始

51:30.910 --> 51:31.910
应该是安迪范

51:31.910 --> 51:33.910
一开始应该是安迪范

51:33.910 --> 51:35.910
但是运行到后边的时候

51:35.910 --> 51:36.910
就运行到这句话的时候

51:36.910 --> 51:37.910
A就等于1了

51:37.910 --> 51:38.910
应该这么说

51:38.910 --> 51:39.910
一开始肯定不能等于1

51:39.910 --> 51:41.910
一开始肯定是安迪范的

51:42.910 --> 51:44.910
还有M1不得是一个函数吗

51:44.910 --> 51:47.910
你首先其他啥也别管

51:47.910 --> 51:49.910
全局的执行上下文

51:49.910 --> 51:51.910
是不是就应该有这两个东西

51:51.910 --> 51:52.910
A和M1

51:52.910 --> 51:54.910
M1是在全局声明的

51:54.910 --> 51:57.910
A也是在全局定义的

51:57.910 --> 51:59.910
不得有你这两个东西吗

51:59.910 --> 52:00.910
好

52:00.910 --> 52:03.910
那么开始执行全局代码

52:03.910 --> 52:05.910
现在还没有这个玩意

52:05.910 --> 52:06.910
没有这个玩意

52:06.910 --> 52:07.910
都没有

52:07.910 --> 52:10.910
现在只有一个全局上下文

52:10.910 --> 52:11.910
来开始执行代码

52:11.910 --> 52:13.910
首先运行这句话

52:13.910 --> 52:16.910
把它一开始从安迪范的

52:16.910 --> 52:17.910
变成1

52:17.910 --> 52:19.910
这个没问题吧

52:19.910 --> 52:20.910
好

52:20.910 --> 52:21.910
接下来

52:21.910 --> 52:24.910
到了这句话

52:24.910 --> 52:25.910
到了这句话

52:25.910 --> 52:26.910
我们刚才说了

52:26.910 --> 52:27.910
这个玩意

52:27.910 --> 52:29.910
由于已经提取出去了

52:29.910 --> 52:30.910
对吧

52:30.910 --> 52:32.910
好像就不运行了

52:32.910 --> 52:34.910
确实它不运行了

52:34.910 --> 52:36.910
它不会重新再声明一遍

52:36.910 --> 52:37.910
因为之前已经提过来了

52:37.910 --> 52:39.910
但是这个时候

52:39.910 --> 52:42.910
它会做一件事

52:42.910 --> 52:44.910
就是确定作用语练

52:44.910 --> 52:45.910
这个时候M1还说

52:45.910 --> 52:47.910
还没有执行

52:47.910 --> 52:50.910
它怎么来确定作用语练呢

52:50.910 --> 52:55.540
很简单很简单

52:55.540 --> 53:00.540
它就把M1所在的那个EC

53:00.540 --> 53:02.540
作为它的作用语练起点

53:02.540 --> 53:04.540
就这么简单

53:04.540 --> 53:06.540
M1在哪里定义的

53:06.540 --> 53:08.540
在全局里边定义的

53:08.540 --> 53:10.540
所以说全局的EC

53:10.540 --> 53:13.540
就是M1的作用语练

53:13.540 --> 53:14.540
简单吗

53:14.540 --> 53:15.540
简单吗

53:15.540 --> 53:17.540
所以说简单

53:17.540 --> 53:20.540
全局的EC

53:20.540 --> 53:22.540
就是M1的作用语练

53:22.540 --> 53:24.540
连条只有一个节点

53:24.540 --> 53:26.540
也很正常

53:26.540 --> 53:27.540
一个锁链

53:27.540 --> 53:29.540
它可能只有一环了

53:29.540 --> 53:31.540
作用语练有什么用

53:31.540 --> 53:32.540
不着急

53:32.540 --> 53:34.540
继续往后看

53:34.540 --> 53:37.540
然后开始雕用M1

53:37.540 --> 53:41.540
这个时候会创建M1的EC

53:41.540 --> 53:43.540
M1的EC又是有一个B

53:43.540 --> 53:44.540
有一个M2

53:44.540 --> 53:48.540
M1里面是不是定了个M2和B

53:48.540 --> 53:49.540
定义好了

53:49.540 --> 53:50.540
一开始它是undefined

53:50.540 --> 53:53.540
B是undefined

53:53.540 --> 53:56.540
然后来运行M1

53:56.540 --> 53:59.540
运行M1的时候

53:59.540 --> 54:02.540
把B伏指为2

54:02.540 --> 54:04.540
又运行到这个了

54:04.540 --> 54:06.540
M2

54:06.540 --> 54:10.540
这个时候有了函数定义

54:10.540 --> 54:14.540
它又要确定作用语练了

54:14.540 --> 54:16.540
那么M2的作用语练在哪呢

54:16.540 --> 54:18.540
M1在哪里定义呢

54:18.540 --> 54:21.540
在M1的EC里面定义的

54:21.540 --> 54:24.540
所以M2的作用语练

54:24.540 --> 54:28.540
它的起点就是M1的EC

54:28.540 --> 54:33.540
M1的EC就是M2的作用语期限

54:36.690 --> 54:39.690
M1它的作用语练在哪呢

54:39.690 --> 54:40.690
在这

54:40.690 --> 54:42.690
我用一个箭头画上来了

54:42.690 --> 54:45.690
M1的作用语练是不是刚才写的

54:45.690 --> 54:46.690
在这

54:46.690 --> 54:47.690
你看啊

54:47.690 --> 54:48.690
这就有意思了

54:48.690 --> 54:51.690
M2这个函数里边

54:51.690 --> 54:54.690
如果说它在运行期间

54:54.690 --> 54:55.690
用一个东西

54:55.690 --> 54:57.690
然后在这里边用到了什么

54:57.690 --> 54:59.690
用到了A

54:59.690 --> 55:03.690
它首先找M2里面有没有A

55:03.690 --> 55:04.690
没有A的话

55:04.690 --> 55:06.690
它就找作用语练

55:06.690 --> 55:08.690
练条从这里开始

55:08.690 --> 55:10.690
看一下这里面有没有A

55:10.690 --> 55:11.690
没有A

55:11.690 --> 55:13.690
又继续往上找

55:13.690 --> 55:14.690
看这里有没有A

55:14.690 --> 55:15.690
这里有A了

55:15.690 --> 55:17.690
它就会用这里的A

55:17.690 --> 55:20.690
这就是作用语练的作用

55:20.690 --> 55:21.690
其实说白了

55:21.690 --> 55:22.690
再说直白一点

55:22.690 --> 55:25.690
就是函数里边的可以用外边的

55:25.690 --> 55:27.690
外边的不能用里边的

55:27.690 --> 55:28.690
说白了就是这么一点

55:28.690 --> 55:29.690
说的那么复杂

55:29.690 --> 55:31.690
但是实际上精确的解释

55:31.690 --> 55:32.690
我要给你解释到位

55:32.690 --> 55:34.690
用的就是它的仪式

55:36.690 --> 55:38.690
那么这里边有两个关键点

55:38.690 --> 55:42.690
一个是查找作用语练的时候

55:42.690 --> 55:43.690
先找自己的

55:43.690 --> 55:44.690
再找这个第一个点

55:44.690 --> 55:46.690
再找第二个练条

55:46.690 --> 55:48.690
一是往上寻找

55:48.690 --> 55:50.690
由尽到远查寻

55:50.690 --> 55:51.690
找到了就停止查

55:51.690 --> 55:53.690
刚才我们找一个辨量A一样

55:53.690 --> 55:55.690
如果说这里面有A

55:55.690 --> 55:56.690
先找自己

55:56.690 --> 55:58.690
然后再找它

55:58.690 --> 56:00.690
由尽到远查寻

56:00.690 --> 56:02.690
找到了就停止

56:02.690 --> 56:04.690
再查到规则

56:04.690 --> 56:06.690
第二个作用语练

56:06.690 --> 56:08.690
产生的时间点

56:08.690 --> 56:11.690
一定是函数定义的时候

56:11.690 --> 56:13.690
而不是函数雕用的时候

56:13.690 --> 56:17.130
这个时间点也要记住

56:17.130 --> 56:18.130
因为它

56:18.130 --> 56:19.130
比面是提

56:19.130 --> 56:20.130
它考的往往就是

56:20.130 --> 56:22.130
跟这个时间点有关系

56:22.130 --> 56:24.500
这个作用语练

56:24.500 --> 56:25.500
我要讲的其实这么多

56:25.500 --> 56:27.500
但是我们要做很多的提

56:27.500 --> 56:28.500
来巩固一下

56:28.500 --> 56:29.500
来练习一下

56:29.500 --> 56:32.500
你才能真正的理解作用语练

56:32.500 --> 56:34.500
就说了半天你会发现

56:34.500 --> 56:36.500
就这样了

56:36.500 --> 56:38.500
这里我就顺便提一句

56:38.500 --> 56:41.500
同学们可能会联想到必包

56:41.500 --> 56:44.500
可能会有所联想必包

56:44.500 --> 56:46.500
那个必包跟作用语练

56:46.500 --> 56:47.500
有什么关系的

56:47.500 --> 56:49.500
他们看上去好像风马流不相接

56:49.500 --> 56:52.500
但是实际上是有一点关系的

56:52.500 --> 56:53.500
必包这件事

56:53.500 --> 56:55.500
我顺便给同学们说一下

56:55.500 --> 56:56.500
很多同学

56:56.500 --> 56:59.500
特别是学前段的同学

56:59.500 --> 57:04.260
一般都会卡在必包

57:04.260 --> 57:05.260
为什么呢

57:05.260 --> 57:07.260
因为必包这个知识点

57:07.260 --> 57:09.260
它其实

57:09.260 --> 57:13.260
不是你们前期应该接触的知识点

57:13.260 --> 57:15.260
必包要学习到必包

57:15.260 --> 57:18.260
它又需要有三个前提条件

57:18.260 --> 57:22.900
一个是你要懂垃圾回收

57:22.900 --> 57:23.900
你不懂垃圾回收

57:23.900 --> 57:24.900
你去扯必包

57:24.900 --> 57:26.900
那就是白扯

57:26.900 --> 57:29.900
一个是你要懂作用语练

57:29.900 --> 57:32.900
一个是你要懂那个回调函数

57:32.900 --> 57:34.900
或者高间函数

57:34.900 --> 57:36.900
因为必包的应用场景

57:36.900 --> 57:38.900
往往都是高间函数

57:38.900 --> 57:39.900
什么叫高间函数

57:39.900 --> 57:41.900
以函数作为参数传进去

57:41.900 --> 57:43.900
以函数作为返回值返回

57:43.900 --> 57:45.900
你这三个东西你玩不赚

57:45.900 --> 57:47.900
你不要去玩必包

57:47.900 --> 57:49.900
那什么时候你才能把

57:49.900 --> 57:51.900
三个东西玩得很溜呢

57:51.900 --> 57:55.900
一般都是你要学了一段时间之后

57:55.900 --> 57:57.900
学到什么时候

57:57.900 --> 57:59.900
一般都是你要做了一个完整的项目

57:59.900 --> 58:00.900
什么叫完整的项目

58:00.900 --> 58:02.900
不是你做一个轮波图

58:02.900 --> 58:05.900
那不叫做一个小的案例

58:05.900 --> 58:06.900
什么叫完整的项目

58:06.900 --> 58:07.900
就是你部署到网站上

58:07.900 --> 58:08.900
别人可以用

58:08.900 --> 58:09.900
你也可以用

58:09.900 --> 58:12.900
是能够真正产生价值的一个应用

58:12.900 --> 58:15.900
它一般会有十多二十个页面

58:15.900 --> 58:18.900
组成有前台有后台

58:18.900 --> 58:20.900
有前端有后端

58:20.900 --> 58:22.900
它是一个完整的东西

58:22.900 --> 58:26.900
这个时候你代码量材上得来

58:26.900 --> 58:28.900
基本的代码量积累之后

58:28.900 --> 58:29.900
你才去玩这些事

58:29.900 --> 58:32.900
那个时候必包就很容易理解

58:32.900 --> 58:35.900
前期你去脱离代码量

58:35.900 --> 58:37.900
脱离你基础能力去谈必包

58:37.900 --> 58:39.900
都是谈得空中楼阁

58:39.900 --> 58:40.900
你以为你自己懂了

58:40.900 --> 58:41.900
你会不会发现你搞得好

58:41.900 --> 58:43.900
你就还是不懂

58:43.900 --> 58:44.900
所以这个必包这件事

58:44.900 --> 58:47.900
首先我让同学们放宽心

58:47.900 --> 58:48.900
你现在真的没有必要

58:48.900 --> 58:50.900
去过早地去接触

58:50.900 --> 58:52.900
你应该等到

58:52.900 --> 58:54.900
就像你们玩的一个游戏一样

58:54.900 --> 58:55.900
最后一关的博士

58:55.900 --> 58:56.900
你为什么第一关

58:56.900 --> 58:58.900
就一定要把它打败呢

58:58.900 --> 58:59.900
这不科学对吧

58:59.900 --> 59:01.900
你应该在前边打小的博士

59:01.900 --> 59:03.900
拿装备学技能

59:03.900 --> 59:05.900
一步一步成长

59:05.900 --> 59:06.900
等你真的变得强大之后

59:06.900 --> 59:08.900
再去面对最后一关的博士

59:08.900 --> 59:10.900
那就像爸爸打儿子一样

59:10.900 --> 59:13.900
那就比较轻松了

59:13.900 --> 59:15.900
就简单说一下吧

59:15.900 --> 59:17.900
那个必包它是一个现象

59:17.900 --> 59:20.900
它是一个

59:20.900 --> 59:21.900
现象它指的是

59:21.900 --> 59:22.900
在定义函数的时候

59:22.900 --> 59:24.900
它其实定义非常简单

59:25.900 --> 59:26.900
周围环终的信息

59:26.900 --> 59:28.900
可以在函数中使用

59:28.900 --> 59:30.900
叫词法必包

59:30.900 --> 59:31.900
作用意念实际上

59:31.900 --> 59:33.900
是实现必包的手段

59:33.900 --> 59:35.900
听得云里雾里的是吧

59:35.900 --> 59:37.900
没关系点到机子嘛

59:37.900 --> 59:39.900
这一块不能说的太多了

59:39.900 --> 59:41.900
现在就不到说这个东西的时候

59:41.900 --> 59:43.900
太早了

59:44.900 --> 59:47.900
这是那个作用意念

59:47.900 --> 59:50.900
咱们来做题

59:50.900 --> 01:00:00.380
第一题

01:00:00.380 --> 01:00:01.380
这种题

01:00:02.380 --> 01:00:03.380
该怎么去分析

01:00:03.380 --> 01:00:04.380
我们还是拿出一个技识本

01:00:04.380 --> 01:00:05.380
弯能的技识本

01:00:05.380 --> 01:00:08.380
都能解决这些问题

01:00:08.380 --> 01:00:09.380
来吧

01:00:09.380 --> 01:00:10.380
你看这个题

01:00:10.380 --> 01:00:11.380
有的时候你提做多了

01:00:11.380 --> 01:00:12.380
其实你瞄这个题

01:00:12.380 --> 01:00:16.380
都知道它大概在考虑什么东西

01:00:16.380 --> 01:00:18.380
那肯定跟作用意义相关

01:00:18.380 --> 01:00:19.380
你不看别的

01:00:19.380 --> 01:00:20.380
就看这个C里边

01:00:20.380 --> 01:00:21.380
C里边有没有自己的i

01:00:21.380 --> 01:00:22.380
没有

01:00:22.380 --> 01:00:23.380
用的是别人的i

01:00:23.380 --> 01:00:24.380
对吧

01:00:24.380 --> 01:00:26.380
十之八就跟作用意义相关

01:00:26.380 --> 01:00:27.380
那里分析的是

01:00:27.380 --> 01:00:30.380
就按照作用意义来分析

01:00:31.380 --> 01:00:33.380
首先有个全局的

01:00:33.380 --> 01:00:34.380
是不是

01:00:34.380 --> 01:00:36.380
全局的g o

01:00:37.380 --> 01:00:39.380
g o里边有什么东西

01:00:39.380 --> 01:00:41.380
有什么东西

01:00:41.380 --> 01:00:44.380
有一个i

01:00:44.380 --> 01:00:45.380
是吧

01:00:45.380 --> 01:00:46.380
是有个i

01:00:46.380 --> 01:00:48.380
有i为啥

01:00:48.380 --> 01:00:50.380
indefend

01:00:51.380 --> 01:00:52.380
有一个什么

01:00:52.380 --> 01:00:53.380
a为啥

01:00:53.380 --> 01:00:54.380
一个函数

01:00:54.380 --> 01:00:56.380
你看说明了还有一个C

01:00:56.380 --> 01:00:58.380
C也是一个函数

01:01:01.380 --> 01:01:02.380
不就是这些东西吧

01:01:02.380 --> 01:01:04.380
有一个变量吗

01:01:04.380 --> 01:01:05.380
有两个函数声明吗

01:01:05.380 --> 01:01:06.380
还有啥没啥了

01:01:06.380 --> 01:01:08.380
到机构就确定下来了

01:01:08.380 --> 01:01:10.380
然后直行

01:01:10.380 --> 01:01:11.380
直行干嘛

01:01:11.380 --> 01:01:13.380
F只为一了

01:01:13.380 --> 01:01:15.380
没问题吧

01:01:15.380 --> 01:01:17.380
没问题吧

01:01:17.380 --> 01:01:18.380
好

01:01:18.380 --> 01:01:19.380
然后运行

01:01:19.380 --> 01:01:20.380
来看这个a

01:01:20.380 --> 01:01:22.380
定义函数a

01:01:22.380 --> 01:01:24.380
这个时候要确定作用意义链了

01:01:24.380 --> 01:01:25.380
也就是说

01:01:25.380 --> 01:01:26.380
意味着

01:01:26.380 --> 01:01:28.380
这个函数a

01:01:28.380 --> 01:01:30.380
它的作用意义

01:01:30.380 --> 01:01:32.380
应该怎么指向呢

01:01:32.380 --> 01:01:33.380
就这个函数

01:01:33.380 --> 01:01:34.380
就在这里写

01:01:34.380 --> 01:01:35.380
这个函数

01:01:35.380 --> 01:01:36.380
它的作用意义链

01:01:36.380 --> 01:01:37.380
指向什么呢

01:01:37.380 --> 01:01:39.380
指向的就是g o

01:01:39.380 --> 01:01:41.380
指向的就是g o

01:01:41.380 --> 01:01:43.380
指向就这样

01:01:43.380 --> 01:01:44.380
有这个函数

01:01:44.380 --> 01:01:45.380
它指向的就是

01:01:45.380 --> 01:01:47.380
作用意义链就在这

01:01:47.380 --> 01:01:49.380
没问题吧

01:01:49.380 --> 01:01:50.380
我们就把

01:01:50.380 --> 01:01:52.380
跟这个函数写到一起

01:01:52.380 --> 01:01:53.380
好

01:01:53.380 --> 01:01:54.380
然后再看函数C

01:01:54.380 --> 01:01:56.380
定义函数C的时候

01:01:56.380 --> 01:01:58.380
那么它是不是也有一个作用意义链

01:01:58.380 --> 01:01:59.380
这个函数

01:01:59.380 --> 01:02:00.380
也有作用意义链

01:02:00.380 --> 01:02:02.380
它也指向g o

01:02:02.380 --> 01:02:06.910
你看再回忆一下我们这儿

01:02:06.910 --> 01:02:08.910
me的作用意义链

01:02:08.910 --> 01:02:09.910
是不是指向的是

01:02:09.910 --> 01:02:10.910
全局的

01:02:10.910 --> 01:02:11.910
上下文

01:02:11.910 --> 01:02:17.210
就g o

01:02:17.210 --> 01:02:18.210
好

01:02:18.210 --> 01:02:20.210
然后第25用a

01:02:20.210 --> 01:02:21.210
现在关于是第25用a

01:02:21.210 --> 01:02:23.210
第25用a

01:02:23.210 --> 01:02:24.210
第25用a的时候

01:02:24.210 --> 01:02:28.030
是不是要产生a的

01:02:28.030 --> 01:02:30.030
a的

01:02:30.030 --> 01:02:34.620
a o

01:02:34.620 --> 01:02:35.620
产生a的是指向上下文

01:02:35.620 --> 01:02:37.620
指向上下文里面不有a o吗

01:02:37.620 --> 01:02:39.620
然后再看一下a里面有什么东西呢

01:02:39.620 --> 01:02:41.620
a里面一首先

01:02:41.620 --> 01:02:42.620
没有参数

01:02:42.620 --> 01:02:43.620
没有参数有没有函数声明呢

01:02:43.620 --> 01:02:44.620
有

01:02:44.620 --> 01:02:45.620
它有一个b

01:02:45.620 --> 01:02:47.620
是一个函数声明

01:02:47.620 --> 01:02:50.620
它有没有变量定义呢

01:02:50.620 --> 01:02:51.620
有没有变量定义

01:02:51.620 --> 01:02:53.620
这个玩意儿是啥

01:02:53.620 --> 01:02:55.620
这个玩意儿也是变量定义啊

01:02:55.620 --> 01:02:56.620
所以呢

01:02:56.620 --> 01:02:57.620
i

01:02:57.620 --> 01:03:00.620
等于ondifant

01:03:00.620 --> 01:03:03.620
没问题吧

01:03:03.620 --> 01:03:04.620
好

01:03:04.620 --> 01:03:09.320
然后再来

01:03:09.320 --> 01:03:11.320
然后开始执行啊

01:03:11.320 --> 01:03:13.320
循环了10次

01:03:13.320 --> 01:03:15.320
然后先从0开始

01:03:15.320 --> 01:03:17.320
0变1变2

01:03:17.320 --> 01:03:20.320
2变3 4 5 6 7 8 9

01:03:20.320 --> 01:03:21.320
10

01:03:21.320 --> 01:03:22.320
到了10过后

01:03:22.320 --> 01:03:24.320
为什么不满足条件呢

01:03:24.320 --> 01:03:26.320
退出循环

01:03:26.320 --> 01:03:28.320
然后干嘛

01:03:28.320 --> 01:03:30.320
定义函数b

01:03:30.320 --> 01:03:32.320
这个函数b是不是

01:03:32.320 --> 01:03:33.320
作用预列要产生了

01:03:33.320 --> 01:03:36.320
在定义的时候产生作用预列

01:03:36.320 --> 01:03:37.320
指向谁

01:03:37.320 --> 01:03:39.320
指向a的aO

01:03:39.320 --> 01:03:41.320
就这个函数

01:03:41.320 --> 01:03:43.320
它的作用预列指向的是谁

01:03:43.320 --> 01:03:45.320
a的aO

01:03:45.320 --> 01:03:47.320
什么意思啊

01:03:47.320 --> 01:03:48.320
好

01:03:48.320 --> 01:03:50.320
然后del用b

01:03:50.320 --> 01:03:51.320
那又来呗

01:03:51.320 --> 01:03:53.320
这里掏得很深啊

01:03:53.320 --> 01:03:55.320
其实你做多了这种题

01:03:55.320 --> 01:03:56.320
我以后

01:03:56.320 --> 01:03:57.320
完整的讲一遍

01:03:57.320 --> 01:03:59.320
然后以后我给你们说

01:03:59.320 --> 01:04:00.320
我看这种题

01:04:00.320 --> 01:04:02.320
这样就可以比较容易看出来

01:04:02.320 --> 01:04:03.320
好

01:04:03.320 --> 01:04:05.320
然后这里是

01:04:05.320 --> 01:04:06.320
del用b

01:04:06.320 --> 01:04:08.320
del用b是不是产生b的aO

01:04:08.320 --> 01:04:10.320
在吧

01:04:10.320 --> 01:04:13.630
b的aO

01:04:13.630 --> 01:04:14.630
好

01:04:14.630 --> 01:04:16.630
b的aO里面有啥

01:04:16.630 --> 01:04:17.630
没有函数声明

01:04:17.630 --> 01:04:19.630
也没有变量定义

01:04:19.630 --> 01:04:20.630
里面啥都没有

01:04:20.630 --> 01:04:23.460
空的

01:04:23.460 --> 01:04:24.460
好

01:04:24.460 --> 01:04:25.460
首先来

01:04:25.460 --> 01:04:26.460
来看的啊

01:04:26.460 --> 01:04:28.460
i加加

01:04:28.460 --> 01:04:29.460
在哪里执行的

01:04:29.460 --> 01:04:31.460
b还说里面执行的

01:04:31.460 --> 01:04:32.460
加的是哪个i

01:04:32.460 --> 01:04:34.460
它自己没有i

01:04:34.460 --> 01:04:36.460
没有i怎么办

01:04:36.460 --> 01:04:38.460
但是我们发现b的aO

01:04:38.460 --> 01:04:39.460
b的函数

01:04:39.460 --> 01:04:41.460
它有作用预列

01:04:41.460 --> 01:04:43.460
b的函数是没有作用预列

01:04:43.460 --> 01:04:44.460
指向的是谁

01:04:44.460 --> 01:04:45.460
指向的是这个

01:04:45.460 --> 01:04:46.460
对吧

01:04:46.460 --> 01:04:47.460
b的函数的作用预列

01:04:47.460 --> 01:04:48.460
指向的是这个

01:04:48.460 --> 01:04:49.460
就看这里面有没有i

01:04:49.460 --> 01:04:50.460
有没有i

01:04:50.460 --> 01:04:51.460
有i呀

01:04:51.460 --> 01:04:53.460
加的是这

01:04:53.460 --> 01:04:55.460
i加加加的是谁

01:04:55.460 --> 01:04:57.460
加的是这个i

01:04:57.460 --> 01:04:58.460
看到没

01:04:58.460 --> 01:05:00.460
加的是这

01:05:00.460 --> 01:05:01.460
我告诉大家简变方法

01:05:01.460 --> 01:05:02.460
其实说那么多

01:05:02.460 --> 01:05:03.460
我里面讲的是

01:05:03.460 --> 01:05:05.460
详细它的执行过程

01:05:05.460 --> 01:05:06.460
做题的时候

01:05:06.460 --> 01:05:10.470
可以比较容易看出来的

01:05:10.470 --> 01:05:14.470
然后又去调用c

01:05:14.470 --> 01:05:16.470
所以是调用c

01:05:16.470 --> 01:05:17.470
调用c的话

01:05:17.470 --> 01:05:22.420
是不是会产生c的aO

01:05:22.420 --> 01:05:23.420
c里面有啥

01:05:23.420 --> 01:05:25.420
c里面也是啥都没有

01:05:25.420 --> 01:05:26.420
妈也没有

01:05:26.420 --> 01:05:30.210
好

01:05:30.210 --> 01:05:31.210
那执行c吗

01:05:31.210 --> 01:05:32.210
执行c一个i加加

01:05:32.210 --> 01:05:33.210
好

01:05:33.210 --> 01:05:34.210
同学们看清楚了

01:05:34.210 --> 01:05:36.210
这个i加加加的是谁

01:05:37.210 --> 01:05:40.210
c可能自己没有i

01:05:40.210 --> 01:05:41.210
加的是谁

01:05:41.210 --> 01:05:42.210
又加这

01:05:42.210 --> 01:05:45.210
你一定要看c的作用预列

01:05:45.210 --> 01:05:46.210
因为它自己没有吗

01:05:46.210 --> 01:05:47.210
那c的作用预列在哪

01:05:47.210 --> 01:05:48.210
就在这

01:05:48.210 --> 01:05:49.210
作用预列在哪

01:05:49.210 --> 01:05:51.210
在gO

01:05:51.210 --> 01:05:52.210
加的是哪一个地方

01:05:52.210 --> 01:05:53.210
加的是这

01:05:53.210 --> 01:05:58.350
看到了吗

01:05:58.350 --> 01:05:59.350
好

01:05:59.350 --> 01:06:00.350
c运行完了

01:06:00.350 --> 01:06:01.350
又回到b这里

01:06:01.350 --> 01:06:02.350
c运行完了

01:06:02.350 --> 01:06:03.350
它消失了

01:06:03.350 --> 01:06:04.350
又回到b这里

01:06:04.350 --> 01:06:06.350
输出i

01:06:06.350 --> 01:06:08.350
b里面i用的是谁

01:06:08.350 --> 01:06:09.350
i用的是这

01:06:09.350 --> 01:06:10.350
输出啥

01:06:10.350 --> 01:06:11.350
输出11

01:06:11.350 --> 01:06:12.350
终于有输出了

01:06:12.350 --> 01:06:14.350
所以第一个输出为11

01:06:14.350 --> 01:06:18.900
好

01:06:18.900 --> 01:06:19.900
输出完了

01:06:19.900 --> 01:06:20.900
b运行完了

01:06:20.900 --> 01:06:21.900
拜拜

01:06:21.900 --> 01:06:22.900
好

01:06:22.900 --> 01:06:23.900
这b调用完了

01:06:23.900 --> 01:06:24.900
调完了过后a也运行完了

01:06:24.900 --> 01:06:25.900
a运行完了

01:06:25.900 --> 01:06:28.920
拜拜

01:06:28.920 --> 01:06:29.920
好

01:06:29.920 --> 01:06:30.920
又回到全局了

01:06:30.920 --> 01:06:31.920
还差一句话

01:06:31.920 --> 01:06:32.920
输出i

01:06:32.920 --> 01:06:33.920
全局的i就是2

01:06:33.920 --> 01:06:35.920
11和2

01:06:35.920 --> 01:06:40.000
这就都蛮

01:06:40.000 --> 01:06:41.000
绕了半天

01:06:41.000 --> 01:06:43.000
就是这个答案

01:06:43.000 --> 01:06:44.000
好

01:06:44.000 --> 01:06:45.000
那么我说一下

01:06:45.000 --> 01:06:46.000
原浪社会怎么来看

01:06:46.000 --> 01:06:47.000
但这个题呢

01:06:47.000 --> 01:06:49.000
我看这个题其实比较简单的

01:06:51.000 --> 01:06:53.000
我一看这个题吧

01:06:53.000 --> 01:06:54.000
我首先看一下

01:06:54.000 --> 01:06:55.000
标了一眼

01:06:55.000 --> 01:06:56.000
我就这样子想

01:06:56.000 --> 01:06:57.000
我在大脑里面

01:06:57.000 --> 01:06:59.000
我就这样子想

01:06:59.000 --> 01:07:00.000
因为这个题肯定是

01:07:00.000 --> 01:07:01.000
到处跟i有关系的

01:07:01.000 --> 01:07:03.000
我就看i就行了

01:07:03.000 --> 01:07:07.590
全局有一个i

01:07:07.590 --> 01:07:08.590
i

01:07:08.590 --> 01:07:09.590
等于1

01:07:09.590 --> 01:07:12.930
好

01:07:12.930 --> 01:07:14.930
a里边呢

01:07:14.930 --> 01:07:16.930
首先a里边用的

01:07:16.930 --> 01:07:17.930
有自己的i

01:07:17.930 --> 01:07:18.930
a有自己的i

01:07:18.930 --> 01:07:19.930
i里边

01:07:19.930 --> 01:07:20.930
经过科学完之后

01:07:20.930 --> 01:07:22.930
i得用i得用10

01:07:22.930 --> 01:07:24.930
这个一眼就看出来了

01:07:24.930 --> 01:07:26.930
经过科学完i得用10

01:07:26.930 --> 01:07:27.930
但是现在还没有调用

01:07:27.930 --> 01:07:28.930
没有调用

01:07:28.930 --> 01:07:29.930
先写到这吧

01:07:29.930 --> 01:07:31.930
a里面是自己有i的

01:07:31.930 --> 01:07:33.930
是自己有i的

01:07:33.930 --> 01:07:36.930
然后c里面是自己没有i的

01:07:36.930 --> 01:07:37.930
好

01:07:37.930 --> 01:07:38.930
那么我看到这呢

01:07:38.930 --> 01:07:40.930
我心里面就有数了

01:07:40.930 --> 01:07:43.930
一会去运行c的时候

01:07:43.930 --> 01:07:45.930
c里面的i

01:07:45.930 --> 01:07:47.930
一定用的是全局的

01:07:47.930 --> 01:07:48.930
一定用的是全局的

01:07:48.930 --> 01:07:49.930
为什么

01:07:49.930 --> 01:07:50.930
因为它的作用预链

01:07:50.930 --> 01:07:53.930
是在定义的时候决定的

01:07:53.930 --> 01:07:54.930
而不是在雕路的时候

01:07:54.930 --> 01:07:56.930
不要看我这里在雕路

01:07:56.930 --> 01:07:58.930
那你这个c是不是用了

01:07:58.930 --> 01:07:59.930
这里的i啊

01:07:59.930 --> 01:08:00.930
不是的

01:08:00.930 --> 01:08:03.930
用的永远是定义位置的

01:08:03.930 --> 01:08:05.930
就把折起来

01:08:05.930 --> 01:08:06.930
就定义位置的

01:08:06.930 --> 01:08:07.930
定义在哪

01:08:07.930 --> 01:08:08.930
定义在全局的

01:08:08.930 --> 01:08:09.930
那这个i用了就去这里

01:08:09.930 --> 01:08:10.930
靠着它的

01:08:10.930 --> 01:08:12.930
全局的

01:08:12.930 --> 01:08:13.930
我心里面就有数了

01:08:13.930 --> 01:08:15.930
我就知道你大概就要考这个玩意儿

01:08:15.930 --> 01:08:17.930
运行a的话

01:08:17.930 --> 01:08:18.930
a里面有个i

01:08:18.930 --> 01:08:19.930
i等于多少

01:08:19.930 --> 01:08:20.930
i等于10

01:08:20.930 --> 01:08:21.930
因为经过了14循环

01:08:21.930 --> 01:08:22.930
i等于10了

01:08:22.930 --> 01:08:24.930
运行的雕路a

01:08:24.930 --> 01:08:25.930
运行10次

01:08:25.930 --> 01:08:27.930
然后雕路b

01:08:27.930 --> 01:08:29.930
b里面有没有自己的i

01:08:29.930 --> 01:08:31.930
没有自己的i用哪里

01:08:31.930 --> 01:08:34.930
用定义位置外面的

01:08:34.930 --> 01:08:35.930
定义位置外面的

01:08:35.930 --> 01:08:37.930
是不是就是a的i

01:08:37.930 --> 01:08:38.930
变成11

01:08:38.930 --> 01:08:40.930
然后雕路用c

01:08:40.930 --> 01:08:41.930
好

01:08:41.930 --> 01:08:42.930
c里面有没有i

01:08:42.930 --> 01:08:43.930
那么用的是哪呢

01:08:43.930 --> 01:08:47.930
用的是定义位置外面的

01:08:47.930 --> 01:08:49.930
它不是运行位置

01:08:49.930 --> 01:08:51.930
这是雕路用位置

01:08:51.930 --> 01:08:54.930
这是定义位置外面的

01:08:54.930 --> 01:08:55.930
用的是哪

01:08:55.930 --> 01:08:56.930
用的是全局的

01:08:56.930 --> 01:08:58.930
变成2

01:08:58.930 --> 01:08:59.930
好

01:08:59.930 --> 01:09:00.930
那么这个运行完了

01:09:00.930 --> 01:09:01.930
回到b这里

01:09:01.930 --> 01:09:02.930
b里面输出i

01:09:02.930 --> 01:09:03.930
这b有没有i

01:09:03.930 --> 01:09:04.930
没有i

01:09:04.930 --> 01:09:05.930
用的是什么

01:09:05.930 --> 01:09:07.930
定义位置外面的

01:09:07.930 --> 01:09:09.930
输出a的i

01:09:09.930 --> 01:09:10.930
11

01:09:10.930 --> 01:09:11.930
好

01:09:11.930 --> 01:09:12.930
那么这一块运行完了

01:09:12.930 --> 01:09:13.930
运行完了

01:09:13.930 --> 01:09:14.930
回到这

01:09:14.930 --> 01:09:16.930
肯定输出的是全局

01:09:16.930 --> 01:09:17.930
输出2

01:09:17.930 --> 01:09:18.930
你做熟练了之后

01:09:18.930 --> 01:09:20.930
你可以不用去画了一些东西

01:09:20.930 --> 01:09:21.930
一大锐

01:09:21.930 --> 01:09:23.930
你都可以把它分析的出来

01:09:23.930 --> 01:09:24.930
听懂了吗

01:09:24.930 --> 01:09:25.930
第一题

01:09:25.930 --> 01:09:33.820
看一下第一题有没有什么问题

01:09:33.820 --> 01:09:34.820
没问题

01:09:34.820 --> 01:09:40.400
打个1

01:09:47.380 --> 01:09:48.380
第二题

01:09:48.380 --> 01:09:50.380
第二题有点难度了

01:09:52.380 --> 01:09:54.380
但是用类似的方式

01:09:54.380 --> 01:09:55.380
哪怕你不用

01:09:55.380 --> 01:09:56.380
写得那么详细

01:09:56.380 --> 01:09:58.380
也可以把它分析的出来

01:09:59.380 --> 01:10:00.380
来我们看一下

01:10:00.380 --> 01:10:02.380
第二题

01:10:02.380 --> 01:10:04.380
这次到百度的bST

01:10:07.080 --> 01:10:08.080
这里有个函数

01:10:08.080 --> 01:10:10.080
然后我运行函数

01:10:10.080 --> 01:10:11.080
得到一个列式

01:10:11.080 --> 01:10:12.080
然后

01:10:12.080 --> 01:10:13.080
好来吧

01:10:13.080 --> 01:10:15.710
先运行函数

01:10:15.710 --> 01:10:16.710
这个函数里面

01:10:16.710 --> 01:10:20.280
定义了一个数组

01:10:20.280 --> 01:10:21.280
a22

01:10:21.280 --> 01:10:23.280
它最后来把这个数组返回了

01:10:23.280 --> 01:10:24.280
这个列式成了

01:10:24.280 --> 01:10:25.280
我们可以看出

01:10:25.280 --> 01:10:26.280
先不看中间那一坨的话

01:10:26.280 --> 01:10:27.280
这个列式

01:10:27.280 --> 01:10:28.280
可以看出是什么

01:10:28.280 --> 01:10:30.280
就是返回到这个函数

01:10:30.280 --> 01:10:31.280
所以我们可以确定

01:10:31.280 --> 01:10:33.280
列式一定是一个什么玩意儿呢

01:10:33.280 --> 01:10:34.280
它一定是一个函数

01:10:34.280 --> 01:10:35.280
是一个数组

01:10:36.280 --> 01:10:37.280
是一个数组

01:10:37.280 --> 01:10:38.280
然后我这里边

01:10:39.280 --> 01:10:40.280
二位

01:10:41.280 --> 01:10:42.280
关键就是个数字

01:10:42.280 --> 01:10:43.280
装的到底是啥

01:10:45.280 --> 01:10:46.280
装的是啥呢

01:10:47.280 --> 01:10:49.280
装的是一个一个的函数

01:10:51.280 --> 01:10:52.280
我循环了5次

01:10:54.280 --> 01:10:56.280
相当于是0到4之间循环

01:10:58.280 --> 01:10:59.280
循环你要会看

01:11:00.280 --> 01:11:01.280
循环你怎么看

01:11:01.280 --> 01:11:04.280
就看爱德曲直范围

01:11:05.280 --> 01:11:06.280
0到4

01:11:08.280 --> 01:11:09.280
0到4之间循环

01:11:09.280 --> 01:11:11.280
那么爱德语0的时候走一遍

01:11:11.280 --> 01:11:13.280
爱德语1的时候走一遍

01:11:13.280 --> 01:11:15.280
爱德语2的时候走一遍

01:11:15.280 --> 01:11:16.280
爱德语3的时候走一遍

01:11:16.280 --> 01:11:17.280
不好意思

01:11:20.170 --> 01:11:21.170
今天上午吃了个腰

01:11:24.170 --> 01:11:26.170
他就一直打个

01:11:33.760 --> 01:11:35.760
0到4之间

01:11:36.760 --> 01:11:37.760
0到4之间

01:11:38.760 --> 01:11:39.760
上这个课太不容易了

01:11:39.760 --> 01:11:40.760
同学们知道

01:11:43.760 --> 01:11:44.760
昨天晚上

01:11:44.760 --> 01:11:45.760
手脖子很不舒服

01:11:45.760 --> 01:11:46.760
今天上午

01:11:46.760 --> 01:11:47.760
还专门去出了个意

01:11:50.760 --> 01:11:51.760
0到4之间循环

01:11:51.760 --> 01:11:53.760
就等于0的时候走一遍

01:11:53.760 --> 01:11:54.760
1的时候走一遍

01:11:54.760 --> 01:11:55.760
2的时候走一遍

01:11:55.760 --> 01:11:56.760
也就是个数组里边有几项呢

01:11:56.760 --> 01:11:57.760
有5项

01:11:58.760 --> 01:11:59.760
0,1,2,3,4

01:12:00.760 --> 01:12:01.760
5项

01:12:03.760 --> 01:12:04.760
现在关键点在这

01:12:05.760 --> 01:12:07.760
每一项是一个函数

01:12:08.760 --> 01:12:11.070
稍等

01:12:11.070 --> 01:12:12.070
等我10秒钟

01:12:32.430 --> 01:12:33.430
做个深呼吸

01:12:34.430 --> 01:12:35.430
一般能管一会儿

01:12:39.060 --> 01:12:40.060
他就是四个函数

01:12:41.060 --> 01:12:42.060
你看吗

01:12:42.060 --> 01:12:44.060
第一项给他负责为一个函数

01:12:44.060 --> 01:12:45.060
第二项

01:12:45.060 --> 01:12:46.060
爱德语1的时候

01:12:46.060 --> 01:12:47.060
第二项给他负责为一个函数

01:12:47.060 --> 01:12:48.060
不就是五个函数吗

01:12:48.060 --> 01:12:52.060
0,1,2,3,4

01:12:52.060 --> 01:12:54.060
0到5,4的下标

01:12:54.060 --> 01:12:55.060
一个就是一个函数

01:12:55.060 --> 01:12:56.060
关键是

01:12:57.060 --> 01:12:58.060
每一个函数反而回啥

01:12:59.060 --> 01:13:00.060
你这个要搞清楚

01:13:01.060 --> 01:13:02.060
反回的是啥呢

01:13:02.060 --> 01:13:03.060
反回的是一个i

01:13:04.060 --> 01:13:05.060
现在还没有掉入这个函数

01:13:05.060 --> 01:13:06.060
我知道

01:13:06.060 --> 01:13:07.060
还没有掉入

01:13:07.060 --> 01:13:08.060
但是你想要分析的出来

01:13:09.060 --> 01:13:10.060
这个函数里边

01:13:10.060 --> 01:13:11.060
他有没有i呀

01:13:12.060 --> 01:13:13.060
他没有i

01:13:14.060 --> 01:13:16.060
那这个函数里边没有i

01:13:16.060 --> 01:13:17.060
他只能用什么

01:13:18.060 --> 01:13:19.060
函数外边的

01:13:20.060 --> 01:13:22.060
这不只能用函数外边的

01:13:23.060 --> 01:13:24.060
那函数外边的

01:13:24.060 --> 01:13:25.060
不就是这个玩意吗

01:13:26.060 --> 01:13:28.060
函数定义位置

01:13:28.060 --> 01:13:30.060
一定要只看定义位置

01:13:30.060 --> 01:13:32.060
他里边用的到底是哪一个的i

01:13:32.060 --> 01:13:33.060
你不要看他

01:13:33.060 --> 01:13:34.060
调用的哪里调用的

01:13:34.060 --> 01:13:35.060
没关系

01:13:35.060 --> 01:13:36.060
你就看他定义位置

01:13:37.060 --> 01:13:38.060
他自己没有i

01:13:38.060 --> 01:13:39.060
他只能看定义位置

01:13:39.060 --> 01:13:40.060
外边的

01:13:40.060 --> 01:13:41.060
就是这个i

01:13:43.060 --> 01:13:44.060
所以他都告诉你

01:13:44.060 --> 01:13:45.060
是什么东西

01:13:45.060 --> 01:13:46.060
他反回的是什么

01:13:46.060 --> 01:13:47.060
他反回的

01:13:47.060 --> 01:13:48.060
这函数反回的

01:13:49.060 --> 01:13:51.060
是fn的i

01:13:52.060 --> 01:13:53.060
不就是这个玩意吗

01:13:55.380 --> 01:13:56.380
对不对

01:13:56.380 --> 01:13:57.380
那么如果说fn

01:13:57.380 --> 01:13:58.380
一旦运行完成

01:13:58.380 --> 01:13:59.380
你看这些东西

01:13:59.380 --> 01:14:00.380
全是一样的

01:14:00.380 --> 01:14:04.140
反回的都是fn的i

01:14:04.140 --> 01:14:05.140
也就是说

01:14:05.140 --> 01:14:06.140
这5个函数

01:14:06.140 --> 01:14:07.140
反回的都是同一个i

01:14:07.140 --> 01:14:09.140
都是fn里面的这个i

01:14:10.140 --> 01:14:11.140
而fn这个函数

01:14:11.140 --> 01:14:12.140
运行完了之后

01:14:12.140 --> 01:14:13.140
他循环是不是结束了

01:14:14.140 --> 01:14:15.140
循环结束的时候

01:14:15.140 --> 01:14:16.140
那个i是多少

01:14:16.140 --> 01:14:17.140
不就是5吗

01:14:17.140 --> 01:14:18.140
说反回的就是他

01:14:18.140 --> 01:14:19.140
全都是5

01:14:21.140 --> 01:14:22.140
反回的全都是5

01:14:23.140 --> 01:14:24.140
他现在我们就清楚了

01:14:24.140 --> 01:14:26.140
列式程里面放了是什么东西

01:14:26.140 --> 01:14:27.140
fn运行完了

01:14:27.140 --> 01:14:28.140
过后给列式程

01:14:28.140 --> 01:14:30.140
把ar给列式程

01:14:30.140 --> 01:14:32.140
里面除了5个函数

01:14:33.140 --> 01:14:34.140
每个函数干嘛

01:14:34.140 --> 01:14:35.140
反回一个5

01:14:36.140 --> 01:14:37.140
所以说在看下面

01:14:37.140 --> 01:14:38.140
就很简单了

01:14:38.140 --> 01:14:39.140
我循环这个数组

01:14:39.140 --> 01:14:40.140
每循环一次

01:14:40.140 --> 01:14:42.140
拿到这个函数

01:14:42.140 --> 01:14:44.140
数组的每一项是一个函数

01:14:44.140 --> 01:14:45.140
如果说

01:14:45.140 --> 01:14:46.140
这个代码你都不认识的话

01:14:46.140 --> 01:14:47.140
拿一个的基础部分

01:14:47.140 --> 01:14:49.140
还好好磨练一下

01:14:50.140 --> 01:14:51.140
这个玩意不就是一个函数吗

01:14:51.140 --> 01:14:52.140
第一项一个函数

01:14:52.140 --> 01:14:53.140
第二项第三项

01:14:53.140 --> 01:14:54.140
第四项第五项

01:14:54.140 --> 01:14:55.140
只要把这个函数

01:14:55.140 --> 01:14:56.140
调用一下

01:14:56.140 --> 01:14:57.140
他调用一下

01:14:57.140 --> 01:14:58.140
反回几啊

01:14:58.140 --> 01:14:59.140
反回5

01:14:59.140 --> 01:15:00.140
说输出的

01:15:00.140 --> 01:15:01.140
全部都是5

01:15:01.140 --> 01:15:02.140
得到的是5个5

01:15:04.450 --> 01:15:05.450
就这百度的

01:15:06.450 --> 01:15:07.450
面试题

01:15:15.080 --> 01:15:16.080
下一道

01:15:16.080 --> 01:15:17.080
下一道是

01:15:19.080 --> 01:15:20.080
我给你加了

01:15:20.080 --> 01:15:21.080
加大的难度

01:15:24.480 --> 01:15:25.480
我觉得大厂的面试题

01:15:25.480 --> 01:15:26.480
也就这样了

01:15:26.480 --> 01:15:27.480
大厂也有感觉

01:15:27.480 --> 01:15:28.480
也就这样了

01:15:29.480 --> 01:15:30.480
再多来点难度

01:15:31.480 --> 01:15:32.480
来看一下这道题

01:15:33.480 --> 01:15:34.480
我就编了一下

01:15:34.480 --> 01:15:36.480
其他都没有编

01:15:36.480 --> 01:15:37.480
就这个位置编了

01:15:38.480 --> 01:15:39.480
就这个位置编了

01:15:41.480 --> 01:15:43.480
那就一切都不一样了

01:15:43.480 --> 01:15:44.480
好

01:15:44.480 --> 01:15:45.480
咱们来分析一下

01:15:47.480 --> 01:15:48.480
来吧

01:15:48.480 --> 01:15:51.370
最终那个类似成了

01:15:51.370 --> 01:15:52.370
还是一个数组

01:15:53.370 --> 01:15:54.370
对吧

01:15:54.370 --> 01:15:55.370
还是得到的是反回的

01:15:55.370 --> 01:15:56.370
还是一个数组

01:15:56.370 --> 01:15:57.370
最后还是要去循环调用

01:15:57.370 --> 01:15:59.370
那我们就来看一下

01:15:59.370 --> 01:16:00.370
这个代码

01:16:00.370 --> 01:16:01.370
它会怎么样

01:16:02.370 --> 01:16:04.370
也是循环了5次

01:16:04.370 --> 01:16:06.370
0,1,2,3,4

01:16:06.370 --> 01:16:09.370
但是每一次循环呢

01:16:09.370 --> 01:16:11.370
我是又生成了

01:16:11.370 --> 01:16:12.370
一个函数

01:16:14.370 --> 01:16:15.370
每一次循环

01:16:15.370 --> 01:16:17.370
我又生成了一个函数

01:16:17.370 --> 01:16:18.370
那我们写的详细点

01:16:18.370 --> 01:16:19.370
就是说

01:16:19.370 --> 01:16:21.370
第一次循环的时候

01:16:22.370 --> 01:16:24.370
R等于0的时候

01:16:24.370 --> 01:16:26.370
我觉得是这个R

01:16:26.370 --> 01:16:27.370
等于0的时候

01:16:27.370 --> 01:16:28.370
我干嘛呀

01:16:28.370 --> 01:16:31.370
我生成了一个函数fn

01:16:31.370 --> 01:16:33.370
是不是函数表达是

01:16:33.370 --> 01:16:35.370
生成了一个函数fn

01:16:35.370 --> 01:16:37.370
这个fn有一个参数i

01:16:39.370 --> 01:16:40.370
是不是有一个参数i

01:16:40.370 --> 01:16:41.370
能看懂吗

01:16:41.370 --> 01:16:42.370
这是个参数

01:16:42.370 --> 01:16:44.370
这个参数来自于哪呢

01:16:44.370 --> 01:16:46.370
来自这个函数调用

01:16:46.370 --> 01:16:48.370
把这个i传递给了这个i

01:16:48.370 --> 01:16:51.680
实际上就是把这个i

01:16:51.680 --> 01:16:53.680
就是fn的i

01:16:53.680 --> 01:16:55.680
传递给了这个参数i

01:16:56.680 --> 01:16:57.680
什么意思啊

01:16:57.680 --> 01:17:00.680
所以这个i等于0

01:17:00.680 --> 01:17:01.680
函数里面的参数

01:17:01.680 --> 01:17:03.680
跟这个i不是一个东西

01:17:04.680 --> 01:17:05.680
比如说这个可以换成别的

01:17:05.680 --> 01:17:06.680
都可以

01:17:06.680 --> 01:17:08.680
换成一个a都可以

01:17:08.680 --> 01:17:10.680
它是把这个i的值给它

01:17:11.680 --> 01:17:13.680
你要好好看懂啊

01:17:13.680 --> 01:17:14.680
比如说

01:17:14.680 --> 01:17:17.680
我们在这边的边量a

01:17:17.680 --> 01:17:19.680
然后一个函数

01:17:19.680 --> 01:17:20.680
那这两个东西

01:17:20.680 --> 01:17:21.680
不是一个东西

01:17:21.680 --> 01:17:22.680
不是一个东西

01:17:22.680 --> 01:17:25.680
比方说我这里写ma传进去

01:17:25.680 --> 01:17:27.680
这个a跟这个a不是一个东西

01:17:27.680 --> 01:17:29.680
那这里是一样的

01:17:29.680 --> 01:17:30.680
我传了一个i进去

01:17:30.680 --> 01:17:32.680
跟这个i不是一个东西

01:17:32.680 --> 01:17:36.440
说了半天就说这个

01:17:36.440 --> 01:17:37.440
第一次循环

01:17:37.440 --> 01:17:39.440
我们用fn1

01:17:39.440 --> 01:17:41.440
或者fn0

01:17:41.440 --> 01:17:42.440
这个函数

01:17:42.440 --> 01:17:44.440
指的是它

01:17:44.440 --> 01:17:45.440
第一次循环

01:17:45.440 --> 01:17:46.440
产生了函数

01:17:46.440 --> 01:17:47.440
这个函数里面

01:17:47.440 --> 01:17:48.440
有没有自己的i

01:17:48.440 --> 01:17:49.440
有

01:17:49.440 --> 01:17:50.440
它有个参数i

01:17:50.440 --> 01:17:51.440
它值为多少

01:17:51.440 --> 01:17:53.440
0传过来的

01:17:53.440 --> 01:17:54.440
看到没

01:17:54.440 --> 01:17:58.930
好

01:17:58.930 --> 01:17:59.930
然后接下来

01:17:59.930 --> 01:18:00.930
这个函数里面

01:18:00.930 --> 01:18:01.930
马上运行了

01:18:01.930 --> 01:18:03.930
那么这里呢

01:18:03.930 --> 01:18:05.930
首先ai用的是啥

01:18:05.930 --> 01:18:06.930
用的是这个0

01:18:06.930 --> 01:18:07.930
用的是这个i

01:18:07.930 --> 01:18:08.930
0

01:18:08.930 --> 01:18:09.930
第一项

01:18:09.930 --> 01:18:10.930
是一个啥呀

01:18:10.930 --> 01:18:15.300
给它复制为一个函数

01:18:15.300 --> 01:18:17.300
关键是这个函数的反应

01:18:17.300 --> 01:18:18.300
会是什么

01:18:19.300 --> 01:18:20.300
这个函数里面

01:18:20.300 --> 01:18:21.300
有没有自己的i

01:18:21.300 --> 01:18:22.300
没有

01:18:22.300 --> 01:18:24.300
它用的是谁的

01:18:24.300 --> 01:18:26.300
用的是定义位置

01:18:26.300 --> 01:18:28.300
外乘的

01:18:28.300 --> 01:18:29.300
外乘是哪个

01:18:29.300 --> 01:18:30.300
外乘是这个函数

01:18:30.300 --> 01:18:31.300
那这个函数

01:18:31.300 --> 01:18:32.300
有没有自己的i

01:18:32.300 --> 01:18:34.300
它有

01:18:34.300 --> 01:18:35.300
它有

01:18:35.300 --> 01:18:36.300
这个i是啥

01:18:36.300 --> 01:18:37.300
i是0

01:18:37.300 --> 01:18:39.300
i会0

01:18:39.300 --> 01:18:41.300
它跟刚才不一样了

01:18:41.300 --> 01:18:42.300
刚才用的是哪个i

01:18:42.300 --> 01:18:43.300
用的是这个i

01:18:43.300 --> 01:18:44.300
这个i会要变的

01:18:44.300 --> 01:18:47.300
这个i还不会变

01:18:47.300 --> 01:18:48.300
好

01:18:48.300 --> 01:18:49.300
第一次循环结束

01:18:49.300 --> 01:18:51.300
第二次循环又来

01:18:51.300 --> 01:18:52.300
第二次循环

01:18:52.300 --> 01:18:53.300
这个i等于1

01:18:53.300 --> 01:18:56.810
于是它又生成了

01:18:56.810 --> 01:18:57.810
一个新的函数

01:18:57.810 --> 01:19:00.810
我鼓起来还叫做f1

01:19:00.810 --> 01:19:01.810
这个新的函数

01:19:01.810 --> 01:19:02.810
又把这个e又传进来了

01:19:02.810 --> 01:19:03.810
对吧

01:19:03.810 --> 01:19:04.810
又把这个外业

01:19:04.810 --> 01:19:05.810
又传到了这

01:19:05.810 --> 01:19:06.810
那就相当于是

01:19:06.810 --> 01:19:09.810
把这个e又传到了这

01:19:09.810 --> 01:19:10.810
那么这里就相当于是

01:19:10.810 --> 01:19:12.810
它有一个自己的i

01:19:12.810 --> 01:19:13.810
它的值位多少

01:19:13.810 --> 01:19:14.810
为1

01:19:14.810 --> 01:19:16.810
能理解到的意思

01:19:17.810 --> 01:19:19.810
然后又给它的

01:19:19.810 --> 01:19:20.810
AR1复制

01:19:20.810 --> 01:19:22.810
那就是第二项

01:19:22.810 --> 01:19:24.810
发挥啥

01:19:24.810 --> 01:19:25.810
给它复制为一个函数

01:19:25.810 --> 01:19:27.810
这个函数它反回一个i

01:19:27.810 --> 01:19:28.810
它函数自己没有i

01:19:28.810 --> 01:19:29.810
用的是哪个i

01:19:29.810 --> 01:19:31.810
用的是f1的这个i

01:19:31.810 --> 01:19:36.140
反回的是e

01:19:36.140 --> 01:19:37.140
其实如果说你

01:19:37.140 --> 01:19:39.140
既也是

01:19:39.140 --> 01:19:40.140
学过一段时间的话

01:19:40.140 --> 01:19:41.140
应该知道的

01:19:41.140 --> 01:19:42.140
这是一个利益执行函数

01:19:42.140 --> 01:19:44.140
通常用于来解决

01:19:44.140 --> 01:19:45.140
页面中

01:19:45.140 --> 01:19:47.140
特别是一些

01:19:47.140 --> 01:19:49.140
循环终带一步的这种情况

01:19:49.140 --> 01:19:51.140
比方循环终去注册事件

01:19:51.140 --> 01:19:52.140
循环终去塞贸车

01:19:52.140 --> 01:19:53.140
这种情况

01:19:53.140 --> 01:19:55.140
它就会产生这样的一个问题

01:19:56.140 --> 01:19:57.140
你们还没学到那里

01:19:57.140 --> 01:19:58.140
你们不说了

01:19:58.140 --> 01:19:59.140
单说这道题

01:19:59.140 --> 01:20:01.140
那么同理可知

01:20:01.140 --> 01:20:03.140
它最后会创建了5个函数

01:20:03.140 --> 01:20:07.540
f2

01:20:07.540 --> 01:20:09.540
f3

01:20:09.540 --> 01:20:13.500
f4

01:20:13.500 --> 01:20:15.500
它会创建这5个函数

01:20:15.500 --> 01:20:16.500
那么

01:20:16.500 --> 01:20:17.500
直到循环结束

01:20:17.500 --> 01:20:18.500
i等于5的时候

01:20:18.500 --> 01:20:20.500
循环条件不满足了

01:20:20.500 --> 01:20:21.500
结束了

01:20:21.500 --> 01:20:22.500
那么这里

01:20:22.500 --> 01:20:24.500
会创建5个函数

01:20:24.500 --> 01:20:25.500
历史里面

01:20:25.500 --> 01:20:26.500
会创建5个函数

01:20:26.500 --> 01:20:27.500
它反回的是谁

01:20:27.500 --> 01:20:29.500
反回的是f0的i

01:20:29.500 --> 01:20:30.500
它反回的是谁

01:20:30.500 --> 01:20:32.500
反回的是f1的i

01:20:32.500 --> 01:20:33.500
它反回的是谁

01:20:33.500 --> 01:20:34.500
反回的是f2的i

01:20:34.500 --> 01:20:36.500
fn2的i

01:20:39.500 --> 01:20:40.500
下一个

01:20:40.500 --> 01:20:43.500
它反回的是fn3的i

01:20:43.500 --> 01:20:47.500
它反回的是fn4的i

01:20:48.500 --> 01:20:50.500
反回的是01234

01:20:50.500 --> 01:20:51.500
那么最终

01:20:51.500 --> 01:20:53.500
我们循环运行这些函数

01:20:53.500 --> 01:20:55.500
得到的就是01234

01:21:01.900 --> 01:21:02.900
就完事了

01:21:03.900 --> 01:21:04.900
这就是

01:21:04.900 --> 01:21:06.900
作用与列

01:21:07.900 --> 01:21:08.900
怎么样了

01:21:08.900 --> 01:21:09.900
今天这节课

01:21:11.900 --> 01:21:12.900
能消化吗

01:21:12.900 --> 01:21:16.620
能听懂吗

01:21:16.620 --> 01:21:19.770
同学

01:21:19.770 --> 01:21:20.770
还是可以是吧

01:21:20.770 --> 01:21:22.770
可能有些朋友觉得很模糊

01:21:22.770 --> 01:21:23.770
模糊的同学呢

01:21:23.770 --> 01:21:25.770
下来好好去消化一下

01:21:25.770 --> 01:21:26.770
特别是你自己去

01:21:26.770 --> 01:21:27.770
做一下一个题

01:21:27.770 --> 01:21:28.770
自己做一下

01:21:28.770 --> 01:21:29.770
不要在脑袋里面想

01:21:29.770 --> 01:21:30.770
自己是拿个

01:21:30.770 --> 01:21:31.770
图画一画

01:21:31.770 --> 01:21:33.770
拿个计识本写一写

01:21:33.770 --> 01:21:34.770
看自己能不能分析一下

01:21:34.770 --> 01:21:35.770
有点思路

01:21:37.770 --> 01:21:38.770
多去消化一下

01:21:39.770 --> 01:21:40.770
这一题呢

01:21:40.770 --> 01:21:42.770
其实你只需要

01:21:42.770 --> 01:21:43.770
理解一次

01:21:43.770 --> 01:21:45.770
你就不太容易忘记

01:21:45.770 --> 01:21:47.770
偶尔回过头来回顾一下

01:21:47.770 --> 01:21:49.770
再做一下这类类似的题

01:21:49.770 --> 01:21:51.770
懂顾一下就可以了

01:21:51.770 --> 01:21:52.770
就第一次理解

01:21:52.770 --> 01:21:53.770
现在可能比较

01:21:53.770 --> 01:21:54.770
比较吃力一点

01:21:56.770 --> 01:21:57.770
好 OK

01:21:57.770 --> 01:21:59.770
作用与列和执行上下文的

01:21:59.770 --> 01:22:00.770
也是咱们技艺师

01:22:00.770 --> 01:22:02.770
比较常考的一个面试点

01:22:02.770 --> 01:22:04.770
就说你现在搞不定

