WEBVTT

00:00.300 --> 00:02.540
没有问题 咱们要开准呗

00:04.140 --> 00:05.940
简单说一下 这个

00:06.700 --> 00:07.460
笔面实体

00:07.980 --> 00:09.020
笔面实体

00:10.020 --> 00:14.380
无论是大厂还是普通的厂 考察的点都非常的多

00:14.900 --> 00:18.220
因为现在大家知道的情况 一个是

00:18.740 --> 00:19.740
经济形势

00:20.540 --> 00:23.860
相比于前几年的话 也要差一点

00:24.620 --> 00:27.180
就业的竞争力呢 会表达

00:27.580 --> 00:31.780
就业竞争力比较大的话 就意味着公司里面对人权的需求

00:32.300 --> 00:33.580
它的要求就比较高

00:33.840 --> 00:35.620
因为可以选择的范围就更广

00:36.400 --> 00:39.980
还有就是咱们前端的发展速度很快

00:40.740 --> 00:44.840
这一块呢 你看前段时间不刚刚五一又三又出来了

00:45.100 --> 00:45.860
还学得动吗

00:46.380 --> 00:48.180
前段速度很快

00:48.940 --> 00:52.260
所以说导致大家学的知识就会主连地生

00:53.040 --> 00:56.360
这是一定是这个趋势 我也不知道什么时候

00:57.080 --> 01:00.400
我觉得应该会有一个时间点 就到达某一个时间点

01:01.180 --> 01:04.500
这种学习前端的人实在是扛不住了 很多后端呢

01:05.280 --> 01:08.340
对前端有误解 我不知道这里边有没有后端开发人员

01:09.120 --> 01:11.160
没有画面吗 没有画面刷新一下

01:12.440 --> 01:16.540
有些后端开发人员觉得前端还跟过去一样 还跟十年前一样

01:17.040 --> 01:18.320
可能觉得很简单

01:18.580 --> 01:22.420
然后一看 我靠怎么这么多东西的 现在前端怎么变成这个样子

01:22.680 --> 01:23.960
东西越来越多

01:24.680 --> 01:29.560
可能将来到达某一个时间点 前端有可能还会为这个分方向

01:30.120 --> 01:32.760
知道吧 有些国外的有些公司啊

01:33.360 --> 01:35.840
已经开始找专门来开发前端角色家的人了

01:36.600 --> 01:38.680
就专门开发构建工具那一块东西

01:39.280 --> 01:40.440
而前端东西越来越多了

01:41.120 --> 01:44.880
所以说大家学的话 尽量找学吧 我觉得这个后面越来越难了

01:45.240 --> 01:46.120
其他东西越来越多了

01:47.600 --> 01:48.840
这几天的比面试题呢

01:49.400 --> 01:52.760
肯定是没有办法去涵盖整个前端的所有知识

01:53.200 --> 01:53.880
那是不可能的

01:54.000 --> 01:56.640
因为整个尔巴基要学整个前端的话

01:56.720 --> 01:59.240
可能得至少得15个月吧

01:59.360 --> 02:01.760
哪怕你参加校招也得15个月

02:02.120 --> 02:04.520
你可能参加社招的话时间更长一点

02:05.360 --> 02:06.240
东西特别多

02:06.680 --> 02:09.880
那么有些东西呢是需要大家有一定知识机类

02:10.560 --> 02:13.840
有了一定的知识机类过后呢 学习起来的比较轻松

02:14.320 --> 02:16.200
现階段学习起来的可能比较麻烦一点

02:16.520 --> 02:17.400
也不是很好学

02:17.960 --> 02:20.800
那么我们这几天呢 就是在咱们后期课里边

02:21.200 --> 02:22.440
给大家精心挑选了一些

02:22.720 --> 02:23.880
你主要是我去挑选的

02:24.760 --> 02:25.920
挑选的这些知识点呢

02:25.960 --> 02:28.280
一是非常容易在面试中出现

02:29.000 --> 02:29.640
这是第一个

02:30.360 --> 02:30.920
第二个呢

02:31.800 --> 02:34.240
不需要太多的知识机类也能听

02:35.120 --> 02:37.000
虽然有些地方大家可能会觉得比较难

02:37.600 --> 02:38.680
但是前几天应该不难

02:39.440 --> 02:40.760
说挑选了这么一些

02:40.920 --> 02:42.320
其实都是来自于咱们后期课程的

02:43.040 --> 02:44.520
比较了今天的事件循环

02:44.800 --> 02:45.440
来自于哪呢

02:45.600 --> 02:47.400
来自于咱们耶十六课程的

02:47.840 --> 02:49.440
耶十六的我提到了事件循环

02:49.680 --> 02:51.560
在那个漏的结实里边也提到事件循环

02:52.040 --> 02:53.800
这个事件循环的话

02:55.600 --> 02:56.760
首先说一下笔记

02:56.760 --> 02:58.240
这个笔记我是用markdown写的

02:59.040 --> 02:59.960
不知道markdown的同学呢

02:59.960 --> 03:00.840
可以去摆度一下

03:01.720 --> 03:02.160
因此呢

03:02.160 --> 03:04.000
我到时候会把这个笔记发下来

03:04.480 --> 03:06.040
大家如果说要打开这个笔记的话

03:06.040 --> 03:06.960
笔记你们不用做

03:07.680 --> 03:08.800
专心听课就行了

03:08.800 --> 03:09.280
不用做

03:10.160 --> 03:10.560
然后呢

03:10.560 --> 03:11.760
你们要打开这个笔记的话

03:11.760 --> 03:13.320
你需要去下载一个软件

03:13.560 --> 03:14.760
其实任何软件都可以啊

03:14.760 --> 03:16.560
只要能能够预览markdown

03:16.840 --> 03:18.200
像我们的vscode的话

03:18.200 --> 03:19.800
它就可以预览那个markdown

03:19.880 --> 03:20.200
不过呢

03:20.200 --> 03:21.000
它的预览呢

03:21.000 --> 03:21.840
有点粗

03:22.040 --> 03:23.560
所以大家建议大家去下载这个啊

03:23.560 --> 03:24.080
typepro

03:24.720 --> 03:25.560
打开这个链接

03:26.680 --> 03:27.280
呃

03:27.280 --> 03:28.200
然后下滑

03:28.200 --> 03:28.520
下滑

03:28.520 --> 03:29.160
下滑

03:29.160 --> 03:30.800
找到这个download下载

03:31.400 --> 03:31.840
对吧

03:32.040 --> 03:32.880
根据你的系统啊

03:32.880 --> 03:34.480
温斗室还是什么玩儿啊

03:34.480 --> 03:35.200
你去下载

03:35.200 --> 03:36.280
下载完了过后安装

03:36.280 --> 03:36.680
下一步

03:36.680 --> 03:37.800
下一步就安装好了

03:37.800 --> 03:38.680
安装好了之后呢

03:38.680 --> 03:40.040
这个笔记发下来过后啊

03:40.040 --> 03:41.120
大家就可以双击

03:41.120 --> 03:42.080
打开这个笔记了

03:42.080 --> 03:42.600
在这

03:44.480 --> 03:44.960
在这啊

03:44.960 --> 03:45.720
双击打开就行了

03:45.720 --> 03:45.880
啊

03:45.880 --> 03:46.800
这是关于笔记

03:47.520 --> 03:47.880
嗯

03:47.880 --> 03:50.080
今天我们讲这个事件循环啊

03:51.200 --> 03:53.440
事件循环这块的知识呢

03:53.440 --> 03:54.320
它牵扯呢

03:54.320 --> 03:55.600
其实比较广的

03:56.160 --> 03:56.360
呃

03:56.360 --> 03:57.640
如果说面试的时候

03:57.640 --> 04:00.400
他仅仅问事件循环这一个点的话

04:01.120 --> 04:01.920
那就简单了

04:01.920 --> 04:03.000
这个面试又简单了

04:03.000 --> 04:04.480
他往往不会这样子做

04:04.480 --> 04:07.760
他会跑跟问底不不断的去牵扯出新的知识

04:08.200 --> 04:09.560
牵扯到哪些知识呢

04:09.560 --> 04:12.320
一个是我们今天要讲的现成和异部啊

04:12.320 --> 04:13.240
所以现成是怎么回事

04:13.240 --> 04:13.920
异部是怎么回事

04:13.920 --> 04:14.880
还有执行站

04:14.880 --> 04:16.120
你没有执行站的知识

04:16.120 --> 04:18.360
是学不了一个事件循环的

04:18.360 --> 04:19.040
而且呢

04:19.040 --> 04:20.640
我们今天讲的事件循环呢

04:20.640 --> 04:23.400
只得是在浏览期段啊

04:23.400 --> 04:25.720
仅仅是在浏览期段的事件循环

04:25.720 --> 04:26.280
那么将来呢

04:26.280 --> 04:27.640
你们还会学习漏的

04:27.640 --> 04:30.680
漏的基本上以前没有硬性的要求

04:30.680 --> 04:31.520
现在呢

04:31.520 --> 04:33.480
如果说你要参加社交啊

04:33.480 --> 04:35.320
或者是你要冲击大厂高薪的话

04:35.320 --> 04:37.720
漏的是必须要挥的啊

04:37.720 --> 04:39.560
而且学着竞争压力越来越大

04:39.560 --> 04:41.240
我觉得漏的这一块知识点呢

04:41.240 --> 04:41.760
这个知识呢

04:41.760 --> 04:42.960
重要性越来越高

04:42.960 --> 04:45.120
说现在但基本上是必学的

04:45.120 --> 04:45.960
漏的这一块呢

04:45.960 --> 04:47.840
他也有他的事件循环

04:47.840 --> 04:48.840
他的事件循环呢

04:48.840 --> 04:51.080
跟那个浏览期就不太一样

04:51.080 --> 04:51.840
那这一块呢

04:51.840 --> 04:52.760
我今天就没法讲了

04:52.760 --> 04:54.800
因为你要学习了漏的之后

04:54.800 --> 04:56.160
你才能够给你讲的

04:56.160 --> 04:57.600
一些漏的的事件循环

04:57.600 --> 04:58.040
知道吧

04:58.040 --> 04:59.840
知道牵制面比较过

04:59.840 --> 05:00.400
所以说呢

05:00.400 --> 05:02.840
我们每天的课啊

05:02.840 --> 05:04.840
虽然说今天的课是讲这个事件循环

05:04.840 --> 05:05.120
但是呢

05:05.120 --> 05:06.720
我们会讲一些全智的知识

05:06.720 --> 05:08.760
现成和异部以及执行站

05:08.760 --> 05:09.840
而每一讲一块呢

05:09.840 --> 05:11.160
都会有相应的面试题

05:11.160 --> 05:12.640
你看今天准备了三道啊

05:12.640 --> 05:13.760
面试题啊

05:13.760 --> 05:14.480
一个十分大题

05:14.480 --> 05:15.920
一个是两个代码题

05:15.920 --> 05:16.360
好吧

05:16.360 --> 05:18.240
那咱们就今天就开始

05:18.240 --> 05:20.160
我们首先看一下地道面试题吧

05:20.160 --> 05:21.320
大家有什么问题的话啊

05:21.320 --> 05:23.720
就可以在这个评论区问我

05:23.720 --> 05:24.240
讲一会儿呢

05:24.240 --> 05:25.160
会打开这个评论区

05:27.040 --> 05:29.280
现在rox还是五幼站主要的

05:29.280 --> 05:30.600
还是五幼站主要的

05:30.600 --> 05:31.720
国内五幼用的多一点

05:31.720 --> 05:34.040
特别是五幼伤出来过后的

05:34.040 --> 05:36.720
rox的一些优势就并不存在了啊

05:38.440 --> 05:40.680
第一个就是第一个面试题

05:40.680 --> 05:41.360
大家看一下啊

05:41.360 --> 05:41.960
这个面试题呢

05:41.960 --> 05:43.760
因为十字八角都会遇到

05:43.760 --> 05:46.120
特别是在笑招的时候

05:46.120 --> 05:46.760
笑招的时候

05:46.760 --> 05:49.200
他考察基础考察的特别多

05:49.200 --> 05:50.400
他问你怎么去理解

05:50.400 --> 05:51.680
解释的异步

05:51.680 --> 05:52.200
我下面呢

05:52.200 --> 05:53.840
给大家写了一个标准的答案

05:53.840 --> 05:54.440
不过这答案呢

05:54.440 --> 05:55.560
大家不要去背

05:55.560 --> 05:56.880
应该在面试的时候

05:56.880 --> 05:58.200
应该用自己的语言

05:58.200 --> 05:59.760
组织出来给他回答

05:59.760 --> 06:00.160
这个答案呢

06:00.160 --> 06:01.960
你现在可能不是很看得懂啊

06:01.960 --> 06:03.480
这是到底说的是啥

06:03.480 --> 06:04.720
那么怎么来理解这个异步呢

06:04.720 --> 06:06.560
我要把第一块知识讲了之后

06:06.560 --> 06:07.760
就能回答了

06:07.760 --> 06:07.880
好

06:07.880 --> 06:09.000
第一块就是那么咱们讲

06:09.000 --> 06:11.640
现成和异步到底是怎么回事

06:11.640 --> 06:12.840
要理解现成

06:12.880 --> 06:15.280
首先我们要讲一个现成的概念

06:15.280 --> 06:15.960
听说过对吧

06:15.960 --> 06:16.680
你们大家如果说

06:16.680 --> 06:17.480
计算机专业的话

06:17.480 --> 06:18.120
肯定听说过

06:18.120 --> 06:19.600
甚至学习过

06:19.600 --> 06:21.120
那么你要理解现成的话

06:21.120 --> 06:23.600
你首先得理解什么叫进程

06:23.600 --> 06:25.000
什么要进程呢

06:25.000 --> 06:26.720
咱们计算机上要运行的

06:26.720 --> 06:27.840
有很多的软件

06:27.840 --> 06:30.440
比方说咱们要运行QQ微信

06:30.440 --> 06:31.640
还有我们打开浏览器

06:31.640 --> 06:32.400
也是个软件

06:32.400 --> 06:33.920
浏览器也是个软件

06:33.920 --> 06:36.000
然后还有WPS Office

06:36.000 --> 06:36.240
对吧

06:36.240 --> 06:37.440
有各种这样的软件

06:37.440 --> 06:39.360
甚至我们的界面

06:39.360 --> 06:40.840
整个操作系统的界面

06:40.840 --> 06:41.720
它都是一个软件

06:41.720 --> 06:42.520
你可以这样理解啊

06:42.520 --> 06:44.280
它是一个应用

06:44.280 --> 06:45.680
那么这些应用呢

06:45.680 --> 06:48.880
他们要在同一个操作系统上运行

06:48.880 --> 06:51.040
而且他们之间要互不干擾

06:51.040 --> 06:53.240
不能说我运行QQ的时候

06:53.240 --> 06:54.360
QQ崩溃了

06:54.360 --> 06:56.320
导致我微信必须要退出

06:56.320 --> 06:57.560
大家没有遇到这种情况吧

06:57.560 --> 06:58.200
对吧

06:58.200 --> 06:59.400
你最终导致蓝屏

06:59.400 --> 07:01.680
蓝屏是一些系统的问题了

07:01.680 --> 07:03.240
就是说如果正常情况下的话

07:03.240 --> 07:04.320
一个软件

07:04.320 --> 07:05.200
它的问题

07:05.200 --> 07:07.560
它不会影响另一个软件

07:07.560 --> 07:10.200
而且一个软件的数据

07:10.200 --> 07:13.160
它不会自动流向另一个软件

07:13.160 --> 07:15.400
那么我们就需要把这些应用之间

07:15.400 --> 07:17.080
那做个隔离

07:17.080 --> 07:19.440
把它的内存空间进行隔离

07:19.440 --> 07:20.680
所以说我们什么要进程呢

07:20.680 --> 07:22.960
当一个应用程序要启动的时候

07:22.960 --> 07:24.000
它需要一些东西吧

07:24.000 --> 07:24.880
需要内存

07:24.880 --> 07:25.080
对吧

07:25.080 --> 07:25.560
我们写来嘛

07:25.560 --> 07:26.920
都是要放到内存里边了

07:26.920 --> 07:29.720
需要内存以及CPU资源

07:29.720 --> 07:30.560
那么这些资源呢

07:30.560 --> 07:32.080
它自己没法获得

07:32.080 --> 07:34.760
它需要是向操作系统去申请

07:34.760 --> 07:36.240
操作系统怎么来分配这个资源呢

07:36.240 --> 07:38.240
它要保证不同的应用程序之间

07:38.240 --> 07:39.080
是隔离的

07:39.080 --> 07:40.720
它们互不干扰的执行

07:40.720 --> 07:43.000
所以操作系统它是以进程的方式

07:43.000 --> 07:44.520
来分配这些资源

07:44.520 --> 07:47.160
给QQ双击运行过后

07:47.160 --> 07:49.920
操作系统就给它分配一个进程

07:49.920 --> 07:52.520
微信双击运行给它分配一个进程

07:52.520 --> 07:53.280
有些应用程序

07:53.280 --> 07:54.560
它可能会分配多个进程

07:54.560 --> 07:56.040
不在咱们的考虑范围之列

07:56.040 --> 07:57.720
我们就以一个进程的模型

07:57.720 --> 07:59.320
比较简单一点

07:59.320 --> 07:59.440
好

07:59.440 --> 08:00.000
什么叫进程

08:00.000 --> 08:01.720
进程就是很简单

08:01.720 --> 08:08.120
就代表着一块独立于其他进程的内存空间

08:08.160 --> 08:10.120
它们自己玩自己的东西互不干扰

08:10.120 --> 08:11.320
就好像两家人一样

08:11.320 --> 08:11.840
对吧

08:11.840 --> 08:12.680
你们是一家人

08:12.680 --> 08:13.640
然后隔壁是一家人

08:13.640 --> 08:15.120
你们两个家人都玩这儿的

08:15.120 --> 08:15.640
互不干扰

08:17.360 --> 08:19.320
一个应用程序要运行的话

08:19.320 --> 08:22.040
必须至少有一个进程启动

08:22.040 --> 08:22.880
一个进程可以认为

08:22.880 --> 08:24.720
就代表一个应用程序

08:24.720 --> 08:25.920
进程的最大特点就是独立

08:27.000 --> 08:29.280
一个进程不能随便访问其他进程的资源

08:29.280 --> 08:30.680
读过进程之间互不干扰

08:30.680 --> 08:32.080
只是进程的概念

08:32.080 --> 08:33.360
没问题吧

08:33.360 --> 08:34.520
咱们进行下个点

08:34.520 --> 08:37.600
现成

08:37.600 --> 08:38.880
现成啥意思呢

08:38.880 --> 08:40.680
现成就是执行代码

08:40.680 --> 08:41.920
我们的代码现在有进程了

08:41.920 --> 08:42.120
对吧

08:42.120 --> 08:43.360
给我们分配了内存资源

08:43.360 --> 08:44.360
内存空间给的

08:44.360 --> 08:45.360
给的一间屋子

08:45.360 --> 08:47.960
现在你要在屋子里边玩

08:47.960 --> 08:49.160
那么这个时候

08:49.160 --> 08:50.160
你需要

08:50.160 --> 08:51.320
需要玩需要什么

08:51.320 --> 08:51.920
需要人

08:51.920 --> 08:52.480
对不对

08:52.480 --> 08:54.320
你需要人才能玩

08:54.320 --> 08:56.400
那么现成就相当于是屋子里边的人

08:58.000 --> 08:59.800
一个应用程序启动的时候

08:59.800 --> 09:01.320
它有一个进程

09:01.320 --> 09:02.160
同时呢

09:02.160 --> 09:05.000
超过系统还会给这个进程的分配一个现成

09:06.200 --> 09:08.440
我们的应用程序的入口函数

09:08.440 --> 09:10.040
就是在这个现成中运行的

09:10.040 --> 09:11.880
这个现成叫做主现成

09:11.880 --> 09:13.280
什么叫入口函数

09:13.280 --> 09:14.840
有没有学过加碼的同学

09:14.840 --> 09:15.640
学过加碼的同学呢

09:15.640 --> 09:16.280
应该知道啊

09:16.280 --> 09:18.120
咱们一个程序启动的时候

09:18.120 --> 09:19.120
它有一个主函数

09:19.120 --> 09:19.320
对吧

09:19.320 --> 09:20.320
叫魅一点

09:20.320 --> 09:21.520
不叫介石

09:21.520 --> 09:22.720
就是个魅函数

09:22.720 --> 09:23.320
对不对

09:23.320 --> 09:24.080
那么那个函数呢

09:24.080 --> 09:26.360
它就在主现成上运行的

09:26.360 --> 09:27.840
有些人他没有学过加碼

09:27.840 --> 09:29.040
没有学过其他语言

09:29.040 --> 09:29.640
没关系

09:29.640 --> 09:31.120
就是说有个函数

09:31.120 --> 09:31.720
他启动的时候

09:31.720 --> 09:33.440
就会自动地执行

09:33.440 --> 09:34.360
介石不是这样的

09:34.360 --> 09:34.880
有些人说

09:34.880 --> 09:37.440
为什么介石不是这样子呢

09:37.440 --> 09:39.760
你们觉得为什么呢

09:39.760 --> 09:41.480
因为介石

09:41.480 --> 09:44.560
它不是一个独立的东西

09:44.560 --> 09:46.120
你写个介石文件

09:46.120 --> 09:47.440
你能不能独立运行呢

09:47.440 --> 09:49.000
是不能的

09:49.000 --> 09:51.600
它必须要有一个数组环境

09:51.600 --> 09:52.520
像我们的浏览

09:52.520 --> 09:53.960
我们的介石在哪里运行的

09:53.960 --> 09:55.760
是不是在浏览器里面运行的

09:55.760 --> 09:56.280
对不对

09:56.280 --> 09:57.840
这个浏览器

09:57.840 --> 10:00.400
就是我们的数组环境

10:00.400 --> 10:03.120
叫做数组环境

10:03.120 --> 10:06.000
数组

10:06.000 --> 10:06.560
操作系统

10:06.560 --> 10:08.520
会不会给这个介石分配一个现成呢

10:08.520 --> 10:09.720
不会的

10:09.720 --> 10:10.720
它给浏览器

10:10.720 --> 10:12.720
浏览器才是真正的应用程序

10:12.720 --> 10:15.320
它给浏览器去分配进程

10:15.320 --> 10:17.520
然后浏览器在执行的过程中

10:17.520 --> 10:20.520
它要运行我们写的介石代码

10:20.520 --> 10:22.520
这个时候它会把

10:22.520 --> 10:23.720
给介石一个现成

10:23.720 --> 10:24.520
让它去执行

10:24.520 --> 10:25.720
是这么一种关系

10:25.720 --> 10:26.520
像江南呢

10:26.520 --> 10:29.120
我们目前学习的是浏览器的数组

10:29.120 --> 10:30.120
江南你们还会学习

10:30.120 --> 10:31.520
漏德环境里面的数组

10:31.520 --> 10:33.120
就是漏德作为数组

10:33.120 --> 10:34.720
那么无论是谁作为数组

10:34.720 --> 10:35.320
总之呢

10:36.320 --> 10:37.320
在我们的运行

10:37.320 --> 10:38.320
运行程序运行过程中

10:38.320 --> 10:41.320
它可能不止一个事情要做

10:41.320 --> 10:42.320
可能有很多的事情

10:42.320 --> 10:44.320
有很多的任务需要同时进行

10:44.320 --> 10:45.320
于是呢

10:45.320 --> 10:47.320
它可以向操作系统的申请

10:47.320 --> 10:48.320
分配更多的现成

10:48.320 --> 10:49.320
来执行不同的人物

10:49.320 --> 10:50.320
这啥意思呢

10:50.320 --> 10:52.320
就好比说

10:52.320 --> 10:54.320
进程与真正进程之间

10:54.320 --> 10:55.320
进程之间

10:55.320 --> 10:56.320
进程之间

10:56.320 --> 10:57.320
进程之间

10:57.320 --> 10:58.320
进程之间

10:58.320 --> 10:59.320
进程之间

10:59.320 --> 11:00.320
进程之间

11:00.320 --> 11:01.320
进程之间

11:01.320 --> 11:02.320
进程之间

11:02.320 --> 11:03.320
进程之间

11:03.320 --> 11:04.320
进程之间

11:04.320 --> 11:05.320
进程之间

11:05.320 --> 11:07.320
相当于是两家人

11:07.320 --> 11:08.320
两间

11:08.320 --> 11:09.320
两个房子

11:09.320 --> 11:10.320
两家人

11:10.320 --> 11:12.320
他们之间互不干擾

11:12.320 --> 11:14.320
但是一家人在房间里面

11:14.320 --> 11:15.320
自己玩的时候

11:15.320 --> 11:17.320
他可能有很多事情要做

11:17.320 --> 11:18.320
比如说一个人要负责做饭

11:18.320 --> 11:20.320
一个人要负责打扫卫生

11:20.320 --> 11:21.320
一个人要负责学习

11:21.320 --> 11:22.320
小儿子

11:22.320 --> 11:24.320
还是要负责学习

11:24.320 --> 11:26.320
一个人还负责赚钱养家

11:26.320 --> 11:27.320
那么有很多人

11:27.320 --> 11:28.320
有不同的事情要做

11:28.320 --> 11:30.320
那么这里边的每一个人呢

11:30.320 --> 11:32.320
就相当于是现成

11:32.320 --> 11:33.320
这么举个例子

11:33.320 --> 11:34.320
今天呢

11:34.320 --> 11:36.320
我们对现成和进程的解释

11:36.320 --> 11:37.320
只能

11:37.320 --> 11:38.320
很多地方只能点到为止

11:38.320 --> 11:39.320
因为很多同学呢

11:39.320 --> 11:41.320
并不是学习后端的

11:41.320 --> 11:42.320
我们学习起码呢

11:42.320 --> 11:43.320
也没有必要去

11:43.320 --> 11:45.320
做过多的深入的去理解

11:45.320 --> 11:46.320
因为这一块

11:46.320 --> 11:48.320
你要彻底的理解清楚的话

11:48.320 --> 11:49.320
你必须要知道

11:49.320 --> 11:50.320
操作系统的原因

11:50.320 --> 11:52.320
那是一个很大一的一块知识

11:52.320 --> 11:53.320
一般来说

11:53.320 --> 11:54.320
工作过三年

11:54.320 --> 11:55.320
四年之后

11:55.320 --> 11:57.320
你再去玩这些方面的事情吧

11:57.320 --> 11:59.320
只要这种意识就行了

11:59.320 --> 12:00.320
比方说

12:00.320 --> 12:01.320
咱们的浏览器

12:01.320 --> 12:02.320
在启动之后

12:02.320 --> 12:04.320
它会开启很多个现成

12:04.320 --> 12:06.320
来处理不同的事情

12:06.320 --> 12:07.320
浏览器里边的现成

12:07.320 --> 12:08.320
我们需要知道

12:08.320 --> 12:10.320
心里边需要清楚

12:10.320 --> 12:11.320
大概有哪些呢

12:11.320 --> 12:13.320
主要的现成有这么五个

12:13.320 --> 12:16.320
第一个叫做直型现成

12:16.320 --> 12:18.320
这个现成是用来干嘛呢

12:18.320 --> 12:20.320
它主要用来直型介石代码

12:20.320 --> 12:21.320
就是我们写的介石代码

12:21.320 --> 12:22.320
实际上在浏览器里边

12:22.320 --> 12:24.320
是通过这个现成完成的

12:24.320 --> 12:25.320
知道吧

12:25.320 --> 12:28.320
第二个现成叫做GUI

12:28.320 --> 12:29.320
这个现成是用来

12:29.320 --> 12:31.320
做汇制渲染的

12:31.320 --> 12:33.320
像我们的页面上

12:33.320 --> 12:35.320
有什么重挥啊

12:35.320 --> 12:36.320
重排

12:36.320 --> 12:37.320
对不对

12:37.320 --> 12:38.320
有的朋友听说过

12:38.320 --> 12:39.320
有的朋友没听说过

12:39.320 --> 12:40.320
总之就是在页面上

12:40.320 --> 12:42.320
把整个网页呈现出来

12:42.320 --> 12:44.320
那么具体怎么呈现出来的

12:44.320 --> 12:45.320
是一个面试考点啊

12:45.320 --> 12:47.320
不过不但我们今天的

12:47.320 --> 12:48.320
好伦堂会支援

12:48.320 --> 12:49.320
那么就是这个现成

12:49.320 --> 12:50.320
来做的事

12:50.320 --> 12:52.320
它叫渲染现成

12:52.320 --> 12:53.320
好

12:53.320 --> 12:54.320
还有就是我们的事件监听

12:54.320 --> 12:56.320
比方说我们注册了一个事件

12:56.320 --> 12:57.320
那么这个事件

12:57.320 --> 12:59.320
需要有根据

12:59.320 --> 13:01.320
它到底有表现一个按钮

13:01.320 --> 13:03.320
不要做这个点击事件

13:03.320 --> 13:05.320
就需要有个人不断的去看

13:05.320 --> 13:06.320
这个按钮点击的没有啊

13:06.320 --> 13:07.320
这个按钮点击的没有啊

13:07.320 --> 13:09.320
这个按钮点击的没有

13:09.320 --> 13:10.320
需要有个人不停地去看

13:10.320 --> 13:11.320
那么这个东西呢

13:11.320 --> 13:12.320
就是一个事件监听现成

13:12.320 --> 13:13.320
在做这个事

13:13.320 --> 13:14.320
它专门的监听事件

13:14.320 --> 13:17.320
是否是触发的

13:17.320 --> 13:18.320
还有个计时现成

13:18.320 --> 13:19.320
比方说我们平时

13:19.320 --> 13:20.320
调用这个计时器

13:20.320 --> 13:21.320
set timeout

13:21.320 --> 13:23.320
还有什么set interval

13:23.320 --> 13:24.320
那么这些呢

13:24.320 --> 13:25.320
都是靠这个计时现成

13:25.320 --> 13:26.320
在计时

13:26.320 --> 13:27.320
它有个表

13:27.320 --> 13:28.320
它不停地算

13:28.320 --> 13:29.320
时间到美 时间到美

13:29.320 --> 13:30.320
没有意思吧

13:30.320 --> 13:31.320
还有很多的现成

13:31.320 --> 13:32.320
来处理不同的事情

13:32.320 --> 13:33.320
我们说

13:33.320 --> 13:35.320
GS是单现成

13:35.320 --> 13:36.320
并不意味着

13:36.320 --> 13:37.320
浏览器是单现成

13:37.320 --> 13:39.320
浏览器一边有很多现成的

13:39.320 --> 13:41.320
还有一些网络通信模块

13:41.320 --> 13:42.320
比方说我们在

13:42.320 --> 13:44.320
浏览器的地址篮里边

13:44.320 --> 13:45.320
输入一个网络地址

13:45.320 --> 13:46.320
一按回车

13:46.320 --> 13:47.320
对吧

13:47.320 --> 13:48.320
所以有网络点的通信

13:48.320 --> 13:49.320
那么它是靠这个现成

13:49.320 --> 13:50.320
来完成的

13:50.320 --> 13:51.320
包括你们

13:51.320 --> 13:52.320
第三天

13:52.320 --> 13:53.320
我们的第三天

13:53.320 --> 13:54.320
会学习网络通信

13:54.320 --> 13:56.320
那么那一块的时候呢

13:56.320 --> 13:58.320
第三天的第四天

13:58.320 --> 14:00.320
也会说到这个现成

14:00.320 --> 14:01.320
它是靠这个现成

14:01.320 --> 14:02.320
去完成的

14:02.320 --> 14:04.320
没问题吧

14:04.320 --> 14:05.320
这是浏览器的

14:05.320 --> 14:07.320
它的主要的现成分布

14:07.320 --> 14:09.320
现成的跟进程有什么区别呢

14:09.320 --> 14:10.320
比如说有的时候

14:10.320 --> 14:11.320
面试的时候

14:11.320 --> 14:13.320
它考虑的这个点的话

14:13.320 --> 14:14.320
有这样回答

14:14.320 --> 14:15.320
怎么有什么区别呢

14:15.320 --> 14:17.320
进程与进程之间

14:17.320 --> 14:19.320
资源是隔离的

14:19.320 --> 14:21.320
他们之间的资源不共享

14:21.320 --> 14:23.320
能不能发生通信的能

14:23.320 --> 14:25.320
比方说遵守一些

14:25.320 --> 14:26.320
什么协议啊

14:26.320 --> 14:27.320
IPC协议之类的

14:27.320 --> 14:28.320
可以发生通信

14:28.320 --> 14:29.320
但是通常情况下呢

14:29.320 --> 14:31.320
他们的资源都是相互隔离的

14:31.320 --> 14:32.320
不发生通信的

14:32.320 --> 14:33.320
对吧

14:33.320 --> 14:34.320
你们玩微信里边的东西

14:34.320 --> 14:36.320
不可能不串到推壳里边去吧

14:36.320 --> 14:37.320
除非你复制粘贴

14:37.320 --> 14:38.320
否则的话

14:38.320 --> 14:39.320
他们软件本身

14:39.320 --> 14:40.320
是没有相互通信的

14:40.320 --> 14:42.320
比方微信和这个浏览器

14:42.320 --> 14:43.320
对吧

14:43.320 --> 14:45.320
他们之间是没有相互通信的

14:45.320 --> 14:47.320
但是现成不一样

14:47.320 --> 14:49.320
现成是自家人的事

14:49.320 --> 14:51.320
是自己一家人在屋子里边玩

14:51.320 --> 14:53.320
为了都是同一个目的

14:53.320 --> 14:54.320
把这个家照顾好

14:55.320 --> 14:57.320
他们虽然说

14:57.320 --> 14:58.320
每个人都有自己的事情

14:58.320 --> 14:59.320
有的人打扫卫生

14:59.320 --> 15:01.320
有的人煮饭

15:01.320 --> 15:02.320
有的人负责学习

15:02.320 --> 15:03.320
有的人负责专产养家

15:03.320 --> 15:04.320
对吧

15:04.320 --> 15:05.320
有的人负责冒乏乳花

15:05.320 --> 15:07.320
虽然每个人都有不同的事

15:07.320 --> 15:08.320
但是他们之间

15:08.320 --> 15:10.320
是肯定是要经常交流的

15:10.320 --> 15:12.320
然后说

15:12.320 --> 15:13.320
打扫卫生的时候

15:13.320 --> 15:14.320
别人正在做饭

15:14.320 --> 15:15.320
那么可以稍微等一等

15:15.320 --> 15:16.320
等他饭做完了过后

15:16.320 --> 15:17.320
一起打扫

15:17.320 --> 15:18.320
对不对

15:18.320 --> 15:20.320
他们之间是有可以相互交流

15:20.320 --> 15:21.320
也就是他们之间

15:21.320 --> 15:22.320
可以有共享数据

15:22.320 --> 15:23.320
可以有共享的东西

15:23.320 --> 15:25.320
而在京城里边

15:25.320 --> 15:27.320
这种情况是比较少的

15:27.320 --> 15:28.320
而现在县城

15:28.320 --> 15:29.320
由于他们都是

15:29.320 --> 15:31.320
为同一个最终目标服务

15:31.320 --> 15:33.320
所以说他们是可以被调度的

15:33.320 --> 15:35.320
就是你可以停一下

15:35.320 --> 15:37.320
等我做一会

15:37.320 --> 15:38.320
我做一会我完了过后

15:38.320 --> 15:40.320
你再继续操作

15:40.320 --> 15:41.320
他们之间是可以

15:41.320 --> 15:42.320
进行各种复杂的调度

15:42.320 --> 15:44.320
不过我们就不去生路研究了

15:44.320 --> 15:47.320
这是县城和京城的区别

15:47.320 --> 15:49.320
比方说咱们在流烂区里边

15:49.320 --> 15:50.320
有这么多个县城

15:50.320 --> 15:52.320
他们之间有没有调度关系

15:52.320 --> 15:54.320
实际上是有的

15:54.320 --> 15:55.320
我们说比较直接的

15:55.320 --> 15:56.320
就是这两个

15:56.320 --> 15:59.320
执行县城和GUI

15:59.320 --> 16:00.320
这两个县城之间

16:00.320 --> 16:02.320
就是有调度关系的

16:02.320 --> 16:03.320
怎么调度关系呢

16:03.320 --> 16:05.320
他们之间是互斥的

16:05.320 --> 16:07.320
这是一个比较深入的知识的

16:07.320 --> 16:09.320
怎么要互斥

16:09.320 --> 16:10.320
你在运行的时候

16:10.320 --> 16:11.320
我不能动

16:11.320 --> 16:12.320
我在等着

16:12.320 --> 16:14.320
我在运行的时候

16:14.320 --> 16:15.320
你不能动

16:15.320 --> 16:16.320
你在等着

16:16.320 --> 16:18.320
就叫互斥关系

16:18.320 --> 16:19.320
也就是他们两个县城

16:19.320 --> 16:21.320
是不可能同事运行的

16:21.320 --> 16:23.320
虽然说他们做的不同的事情

16:23.320 --> 16:24.320
一个在做渲染

16:24.320 --> 16:25.320
一个在做解释

16:25.320 --> 16:26.320
但是呢

16:26.320 --> 16:28.320
他们之间是不会同时运行的

16:28.320 --> 16:30.320
那么怎么来证明这一点呢

16:30.320 --> 16:31.320
大家看下面那个代码

16:34.320 --> 16:35.320
下面那个代码呢

16:35.320 --> 16:36.320
有个HE元素

16:36.320 --> 16:37.320
然后呢

16:37.320 --> 16:39.320
一面上有一个按钮

16:39.320 --> 16:40.320
这个按钮我写的很简单

16:40.320 --> 16:41.320
点击之后呢

16:41.320 --> 16:43.320
我调用一个函数

16:43.320 --> 16:45.320
这个函数干嘛用的呢

16:45.320 --> 16:47.320
我就把这个HE元素的

16:47.320 --> 16:49.320
内容改一下

16:49.320 --> 16:50.320
改成Molika

16:50.320 --> 16:53.320
然后接下来我写了个使循环

16:53.320 --> 16:54.320
会出现什么结果呢

16:54.320 --> 16:56.320
我们来看一下吧

16:56.320 --> 17:00.200
复制一下啊

17:00.200 --> 17:02.200
这一面

17:02.200 --> 17:04.200
这一面就写好了嘛

17:04.200 --> 17:06.200
这个啊

17:06.200 --> 17:07.200
好

17:07.200 --> 17:08.200
咱们运行一下啊

17:08.200 --> 17:12.220
好 接下来咱们看一下啊

17:12.220 --> 17:13.220
我什么都不点开

17:13.220 --> 17:15.220
我们点击这个按钮

17:15.220 --> 17:16.220
看一下这个文字

17:16.220 --> 17:19.220
会不会变成这个Hean字Molika

17:19.220 --> 17:21.790
点一下

17:21.790 --> 17:23.790
有没有变成个Molika呢

17:23.790 --> 17:24.790
没有

17:24.790 --> 17:25.790
为什么

17:25.790 --> 17:26.790
我就解释一下

17:26.790 --> 17:27.790
我关掉啊

17:27.790 --> 17:28.790
已经卡死了啊

17:28.790 --> 17:29.790
为什么没有变成Molika

17:29.790 --> 17:30.790
你看着啊

17:30.790 --> 17:31.790
当我们点了过后

17:31.790 --> 17:32.790
这个函数是不是在运行

17:32.790 --> 17:34.790
哪个线程在执行

17:34.790 --> 17:36.790
是不是咱们的介石执行引擎

17:36.790 --> 17:38.790
在执行这个线程对吧

17:38.790 --> 17:39.790
它执行的过程中你看

17:39.790 --> 17:40.790
把这句话执行完了

17:40.790 --> 17:41.790
是不是该渲染的

17:41.790 --> 17:43.790
但是不好意思

17:43.790 --> 17:45.790
渲染线程现在不能启动

17:45.790 --> 17:46.790
为什么呢

17:46.790 --> 17:47.790
渲染线程不能执行

17:47.790 --> 17:48.790
为什么不能执行

17:48.790 --> 17:50.790
因为执行线程没有结束

17:50.790 --> 17:52.790
执行线程没有暂停

17:52.790 --> 17:53.790
对吧

17:53.790 --> 17:54.790
执行完

17:54.790 --> 17:55.790
因此呢

17:55.790 --> 17:57.790
渲染引擎了得等着

17:57.790 --> 17:59.790
等着它执行完了之后

17:59.790 --> 18:00.790
我才能进行渲染

18:00.790 --> 18:01.790
因此呢

18:01.790 --> 18:02.790
这句话

18:02.790 --> 18:03.790
运行完了过后

18:03.790 --> 18:04.790
本来应该渲染

18:04.790 --> 18:05.790
它只能等

18:05.790 --> 18:06.790
但是不好意思

18:06.790 --> 18:07.790
介石执行线程

18:07.790 --> 18:08.790
这里一个执行完

18:08.790 --> 18:09.790
导致了这个介石执行线程

18:09.790 --> 18:11.790
永远不会结束

18:11.790 --> 18:12.790
那么这个介石执行线程

18:12.790 --> 18:13.790
永远没有结束

18:13.790 --> 18:14.790
没有停止的时候了

18:14.790 --> 18:16.790
就导致了

18:16.790 --> 18:17.790
这个渲染引擎

18:17.790 --> 18:19.790
它没有办法进行渲染

18:19.790 --> 18:20.790
没了意思吧

18:20.790 --> 18:21.790
这就是为什么说

18:21.790 --> 18:22.790
我们平时说

18:22.790 --> 18:24.790
执行它是一步的

18:24.790 --> 18:25.790
它是我们等我们的

18:25.790 --> 18:27.790
这个函数执行完了之后

18:27.790 --> 18:28.790
把我们把这些什么

18:28.790 --> 18:29.790
动物操作

18:29.790 --> 18:30.790
各种操作完了之后

18:30.790 --> 18:31.790
它才会进行渲染

18:31.790 --> 18:32.790
这就是为什么有这个点

18:32.790 --> 18:35.790
因为它们之间是互斥的

18:35.790 --> 18:36.790
因此呢

18:36.790 --> 18:37.790
这里呢会看到一个

18:37.790 --> 18:40.160
浏览器卡实的状态

18:40.160 --> 18:41.160
等着

18:41.160 --> 18:42.160
当我们点击过后

18:42.160 --> 18:43.160
整个浏览器是卡实的

18:43.160 --> 18:44.160
不知道大家

18:44.160 --> 18:45.160
我点击右键也没有反应

18:45.160 --> 18:46.160
左键也没有反应

18:46.160 --> 18:47.160
为什么

18:47.160 --> 18:48.160
它没办法

18:48.160 --> 18:49.160
没有办法渲染

18:49.160 --> 18:50.160
没了意思吧

18:50.160 --> 18:51.160
就这么个回事

18:51.160 --> 18:52.160
同样道理呢

18:52.160 --> 18:53.160
当它进行渲染的时候

18:53.160 --> 18:55.160
它以GS代码也在等着

18:55.160 --> 18:57.160
它不能执行的

18:57.160 --> 19:00.160
大家知不知道为什么

19:00.160 --> 19:02.160
为什么

19:02.160 --> 19:04.160
它在渲染的时候

19:04.160 --> 19:07.160
GS代码不能执行

19:07.160 --> 19:09.160
它为什么要这样设计

19:09.160 --> 19:11.160
当GS代码执行的时候

19:11.160 --> 19:13.160
也在等着渲染

19:13.160 --> 19:14.160
首先

19:14.160 --> 19:16.160
这两个为什么要互斥

19:16.160 --> 19:17.160
执行现在在执行的时候

19:17.160 --> 19:20.160
为什么要渲染要等着

19:20.160 --> 19:21.160
为什么要等着呢

19:21.160 --> 19:22.160
不然的话

19:22.160 --> 19:24.160
它也可能会写很多的操作

19:24.160 --> 19:26.160
因为渲染是比较耗时的

19:26.160 --> 19:28.160
也可能会写很多的操作

19:28.160 --> 19:29.160
包括像这种操作

19:29.160 --> 19:31.160
包括像这种操作

19:31.160 --> 19:32.160
各种样式的操作

19:32.160 --> 19:34.160
那么如果说它没写一句话

19:34.160 --> 19:35.160
就渲染一次

19:35.160 --> 19:36.160
没写一句话就渲染一次

19:36.160 --> 19:37.160
它的效率很低

19:37.160 --> 19:39.160
因此它的操作是

19:39.160 --> 19:41.160
要执行完了过后

19:41.160 --> 19:42.160
我再进行渲染

19:42.160 --> 19:43.160
一起来渲染

19:43.160 --> 19:44.160
这样效率要高一点

19:44.160 --> 19:46.160
那为什么反过来也是一样的

19:46.160 --> 19:47.160
为什么在渲染的时候

19:47.160 --> 19:49.160
它不让你去执行GS代码

19:49.160 --> 19:52.540
有没有朋友能够想到为什么

19:52.540 --> 20:01.400
GS代码执行会影响到GUI

20:01.400 --> 20:04.780
可以

20:04.780 --> 20:05.780
也可以这样说

20:05.780 --> 20:07.780
会改变动

20:09.780 --> 20:10.780
但是你改变动作的话

20:10.780 --> 20:12.780
你要执行完了之后才改变

20:12.780 --> 20:14.780
对它有不影响

20:14.780 --> 20:16.780
要执行完了之后才会改变

20:16.780 --> 20:18.780
对它也没有什么影响

20:18.780 --> 20:19.780
它这一次渲染完了不合理

20:19.780 --> 20:21.780
发现变了又重新渲染一次

20:22.780 --> 20:23.780
为什么呢

20:23.780 --> 20:25.780
是因为容易导致混乱

20:25.780 --> 20:26.780
你看

20:26.780 --> 20:28.780
如果说它一边渲染

20:28.780 --> 20:30.780
一边去执行GS的话

20:30.780 --> 20:31.780
会有一个什么样的问题呢

20:31.780 --> 20:33.780
回答随便写个代码

20:34.780 --> 20:35.780
比方说

20:35.780 --> 20:37.780
我的GS代码是这样写的

20:38.780 --> 20:41.780
叫做GET bounding rate

20:41.780 --> 20:42.780
知道这个还说吧

20:42.780 --> 20:44.780
我把一个动物对上传进去

20:44.780 --> 20:45.780
来得到它什么呢

20:45.780 --> 20:47.780
得到它的一个边界

20:47.780 --> 20:49.780
它的一个举行边界

20:49.780 --> 20:51.780
你左边有多远

20:51.780 --> 20:52.780
你四口左边有多远

20:52.780 --> 20:53.780
你上边有多远

20:53.780 --> 20:54.780
它的宽高是什么

20:54.780 --> 20:58.280
得到它的各种尺寸

20:58.280 --> 21:00.280
你想一想这个函数

21:00.280 --> 21:03.280
这个函数是不是一定要渲染完了之后

21:03.280 --> 21:05.280
我才能得到它的边

21:05.280 --> 21:06.280
它的情况

21:06.280 --> 21:08.280
它的宽高

21:08.280 --> 21:11.280
它的桌标系

21:11.280 --> 21:13.280
是不是一定要渲染完了之后

21:13.280 --> 21:14.280
才能得到

21:14.280 --> 21:16.280
如果说这两个线程同时执行

21:16.280 --> 21:18.280
你看它会出现什么问题

21:18.280 --> 21:20.280
我中间有一大堆代码

21:20.280 --> 21:22.280
中间有一堆代码

21:22.280 --> 21:25.280
然后下面我右进一个边界叫Rx2

21:25.280 --> 21:30.560
同样动物

21:30.560 --> 21:32.560
那么你想一想

21:32.560 --> 21:34.560
这两个得到的情况

21:34.560 --> 21:36.560
是不是有可能不一样

21:36.560 --> 21:37.560
为什么呢

21:37.560 --> 21:38.560
你看

21:38.560 --> 21:41.560
假设它这里渲染的不停地在渲染

21:41.560 --> 21:43.560
这一步

21:43.560 --> 21:44.560
比方渲染到一定程度

21:44.560 --> 21:45.560
这一步得到了东西

21:45.560 --> 21:48.560
是不是得到一个举行的宽高

21:48.560 --> 21:50.560
和坐标

21:50.560 --> 21:52.560
在运行既是继续执行

21:52.560 --> 21:54.560
执行到中间代码的时候

21:54.560 --> 21:55.560
不好意思

21:55.560 --> 21:56.560
不巧的是

21:56.560 --> 21:58.560
这个东西又发生了一次渲染

21:58.560 --> 21:59.560
而这一次渲染

21:59.560 --> 22:00.560
可能会导致

22:00.560 --> 22:03.560
之前的情况就不一样了

22:03.560 --> 22:04.560
那么这个时候

22:04.560 --> 22:06.560
得到的桌标是不是又不一样了

22:06.560 --> 22:09.560
那么就会导致整个介石代码

22:09.560 --> 22:12.560
出现很多不可预测的情况

22:12.560 --> 22:13.560
那么让我们的编写程序

22:13.560 --> 22:15.560
更加困难了

22:15.560 --> 22:16.560
就没法预测了

22:16.560 --> 22:17.560
你根本就不知道

22:17.560 --> 22:18.560
这里会怎么样

22:18.560 --> 22:20.560
因为它有两个性能不同的来执行

22:20.560 --> 22:22.560
而介石是需要获取浏览器里边

22:22.560 --> 22:24.560
多目元素的各种情况的

22:24.560 --> 22:25.560
对不对

22:25.560 --> 22:27.560
但是这种情况不停地在变

22:27.560 --> 22:29.560
有可能会经常发生变化

22:29.560 --> 22:31.560
以无法预期它变成什么样子

22:31.560 --> 22:34.560
因此它会导致很多无法预期的事情

22:34.560 --> 22:35.560
因此它把这两个线程

22:35.560 --> 22:37.560
做成相互隔离的

22:37.560 --> 22:38.560
不过你们编写的时候

22:38.560 --> 22:41.560
如果说问到这种程度的话

22:41.560 --> 22:43.560
只有可能大厂会问到这种程度

22:43.560 --> 22:46.560
这种程度就太细了

22:46.560 --> 22:47.560
最后我说一点

22:47.560 --> 22:48.560
就咱们的介石说

22:48.560 --> 22:51.560
介石是单线程什么意思

22:51.560 --> 22:53.560
指的是在数组环境中

22:53.560 --> 22:56.560
我们浏览器是一个数组环境

22:56.560 --> 22:57.560
我们以后觉得

22:57.560 --> 22:58.560
漏了介石也是个数组环境

22:58.560 --> 23:01.560
指的是在数组环境中

23:01.560 --> 23:04.560
分配给介石执行的

23:04.560 --> 23:05.560
只有一个线程

23:05.560 --> 23:07.560
并不代表

23:07.560 --> 23:09.560
数组环境是单线程的

23:09.560 --> 23:11.560
无论是漏的环境

23:11.560 --> 23:12.560
还是浏览器环境

23:12.560 --> 23:14.560
它都是多线程的

23:14.560 --> 23:17.560
只不过它分配给介石去执行的线程

23:17.560 --> 23:19.560
只有一个

23:19.560 --> 23:22.560
不过这一点在ATM-5出来过后

23:22.560 --> 23:24.560
有稍微的不同

23:24.560 --> 23:25.560
ATM-5之后

23:25.560 --> 23:27.560
会有一个东西叫WebWorker

23:27.560 --> 23:30.560
或者漏的里边有一个东西叫Worker

23:30.560 --> 23:32.560
它会有多线程的情况

23:32.560 --> 23:34.560
不过这个情况比较特殊

23:34.560 --> 23:36.560
当时你们学习到相关的知识点的时候

23:36.560 --> 23:38.560
自然会有讲解

23:38.560 --> 23:39.560
那么这点到为止

23:39.560 --> 23:40.560
大部分时候

23:40.560 --> 23:41.560
我们认为介石的

23:41.560 --> 23:43.560
只有一个线程

23:43.560 --> 23:45.560
就它的执行线程

23:45.560 --> 23:47.560
这是介石单线程的特点

23:47.560 --> 23:48.560
接下来谈异布

23:48.560 --> 23:51.930
前边两个知识

23:51.930 --> 23:53.930
都是为了这个知识准备的

23:53.930 --> 23:55.930
为什么要异布

23:55.930 --> 23:56.930
同学能不能都知道

23:56.930 --> 23:57.930
咱们介石是异布的

23:57.930 --> 23:59.930
它为什么要设计为异布

23:59.930 --> 24:01.930
因为它是单线程的

24:01.930 --> 24:03.930
为什么单线程就会设计到异布呢

24:03.930 --> 24:05.930
你看这里是有逻辑关系的

24:05.930 --> 24:06.930
它是一条线过来的

24:06.930 --> 24:07.930
它不是说理所当然

24:07.930 --> 24:08.930
天成就是异布的

24:08.930 --> 24:10.930
它一定是有它的考虑的

24:10.930 --> 24:11.930
单线程一个什么问题

24:11.930 --> 24:13.930
它的有没有优势呢

24:13.930 --> 24:14.930
有优势

24:14.930 --> 24:15.930
它同样有问题

24:15.930 --> 24:16.930
什么优势

24:16.930 --> 24:18.930
就是你不用考虑线程调度

24:19.930 --> 24:20.930
我和线程调度

24:20.930 --> 24:22.930
是非常掉头发的

24:22.930 --> 24:23.930
你们如果说

24:23.930 --> 24:25.930
去搞什么C和C压加

24:25.930 --> 24:26.930
你不要用线程去搞加瓦

24:26.930 --> 24:27.930
加瓦的话

24:27.930 --> 24:28.930
你们去搞线程调度的话

24:28.930 --> 24:29.930
一般都很少

24:29.930 --> 24:30.930
因为很多框架

24:30.930 --> 24:31.930
给你一封装好的

24:31.930 --> 24:32.930
你不用管了

24:32.930 --> 24:33.930
它把线程的一情况给你安排了

24:33.930 --> 24:34.930
脱落当当的

24:34.930 --> 24:35.930
安排得明白白的

24:35.930 --> 24:36.930
你不用管了

24:36.930 --> 24:39.930
但是你如果顺利去搞C和C压加的话

24:39.930 --> 24:41.930
取写很底层的东西的话

24:41.930 --> 24:42.930
这个线程调度

24:42.930 --> 24:43.930
真的是要人命的

24:43.930 --> 24:45.930
你稍微控制不好

24:45.930 --> 24:47.930
整个就是对整个程序的灾难

24:47.930 --> 24:51.310
单线程的好处在于

24:51.310 --> 24:52.310
你不用去考虑什么线程调度了

24:52.310 --> 24:53.310
已经线程那些

24:53.310 --> 24:54.310
怎么共享啊

24:54.310 --> 24:55.310
这些锁啊

24:55.310 --> 24:56.310
这乱七八糟的事情都不用考虑了

24:56.310 --> 24:58.310
它降低了程序的复杂性

24:58.310 --> 24:59.310
这就是为什么

24:59.310 --> 25:01.310
介绍语言比较好学

25:01.310 --> 25:03.310
但是单线程有没有问题呢

25:03.310 --> 25:04.310
肯定有问题

25:04.310 --> 25:05.310
它如果说

25:05.310 --> 25:06.310
一旦要处理这种

25:06.310 --> 25:08.310
需要等待的任务的时候

25:08.310 --> 25:09.310
它就必须要考虑

25:09.310 --> 25:10.310
组设的问题

25:10.310 --> 25:11.310
下边有个伟贷

25:11.310 --> 25:12.310
什么叫伟贷吗

25:12.310 --> 25:13.310
就不能运行的

25:13.310 --> 25:14.310
把意识说到

25:14.310 --> 25:15.310
看这个贷

25:17.310 --> 25:18.310
它有什么样的问题呢

25:19.310 --> 25:20.310
在它们来做什么事呢

25:20.310 --> 25:21.310
它我第一步

25:21.310 --> 25:24.940
拓取了一个动物元素

25:24.940 --> 25:25.940
第二步

25:25.940 --> 25:26.940
我调了一个函数

25:26.940 --> 25:28.940
假设有这个函数

25:28.940 --> 25:29.940
实际上是没有的

25:29.940 --> 25:30.940
这个函数做什么事情呢

25:30.940 --> 25:31.940
这个关键字

25:31.940 --> 25:32.940
sync

25:32.940 --> 25:33.940
叫synchrist

25:33.940 --> 25:34.940
表示同步的意识

25:34.940 --> 25:35.940
什么叫同步

25:35.940 --> 25:36.940
就是我没做完

25:36.940 --> 25:38.940
你们后面选择等着

25:38.940 --> 25:39.940
是不是

25:39.940 --> 25:40.940
我们所有代码都是同步的

25:40.940 --> 25:41.940
我们目前接触

25:41.940 --> 25:42.940
大部分代码都是同步的

25:42.940 --> 25:43.940
比较说像什么

25:43.940 --> 25:44.940
你这个辩量

25:46.940 --> 25:47.940
我这里输出

25:48.940 --> 25:49.940
上一句代码

25:49.940 --> 25:50.940
没有运行完的时候

25:50.940 --> 25:51.940
下一句代码是不是等着

25:51.940 --> 25:52.940
对吧

25:52.940 --> 25:53.940
叫同步代码

25:53.940 --> 25:54.940
一步一步执行

25:54.940 --> 25:55.940
从上到下意识执行

25:57.940 --> 26:00.940
我们去请求一个网站

26:00.940 --> 26:03.940
从这里去拿到一个名字

26:03.940 --> 26:04.940
拿到一个名字

26:04.940 --> 26:05.940
总之这个服务器

26:05.940 --> 26:06.940
会给我一个名字

26:06.940 --> 26:08.940
你甭管它怎么操作的

26:08.940 --> 26:09.940
跟你没关系

26:09.940 --> 26:10.940
把意识说到就行了

26:10.940 --> 26:12.940
看代码一定要抓大放小

26:12.940 --> 26:13.940
以同步的方式

26:13.940 --> 26:15.940
向服务器过去名字

26:15.940 --> 26:16.940
得到

26:16.940 --> 26:17.940
拿到

26:17.940 --> 26:19.940
放到那个辩量name里边

26:19.940 --> 26:20.940
然后我做什么事

26:20.940 --> 26:22.940
我把这个dom的inline

26:22.940 --> 26:23.940
设置为name

26:23.940 --> 26:24.940
设置为这个名字

26:24.940 --> 26:26.940
很简单对吧

26:26.940 --> 26:27.940
然后我又去调用了

26:27.940 --> 26:28.940
别的函数

26:28.940 --> 26:29.940
就是跟这个东西无关的

26:29.940 --> 26:30.940
无关的其他事情

26:30.940 --> 26:31.940
比如说出车时间

26:31.940 --> 26:32.940
比如说

26:32.940 --> 26:33.940
做什么计算

26:33.940 --> 26:34.940
那些发动的事情

26:34.940 --> 26:36.940
总之跟上面的东西无关

26:36.940 --> 26:38.940
这个代码会有什么问题呢

26:38.940 --> 26:39.940
下面一张图

26:39.940 --> 26:41.940
有额有多恐怖了

26:42.940 --> 26:44.940
这是我们的执行引擎

26:44.940 --> 26:45.940
在crown里边

26:45.940 --> 26:47.940
它是利用那个v8

26:47.940 --> 26:49.940
v8执行引擎

26:49.940 --> 26:51.940
浏览器里边其中一个线程

26:51.940 --> 26:52.940
是执行线程

26:52.940 --> 26:54.940
靠的是v8执行引擎

26:54.940 --> 26:56.940
然后还有另一个线程

26:56.940 --> 26:58.940
就是我们的网络通信线程

26:58.940 --> 26:59.940
刚才说了对吧

26:59.940 --> 27:00.940
浏览器里边有网络线程

27:00.940 --> 27:01.940
我们这里可能会

27:01.940 --> 27:03.940
图里边会有反应

27:03.940 --> 27:05.940
它怎么执行的

27:05.940 --> 27:06.940
第一步

27:06.940 --> 27:08.940
获取的动物元素没问题吧

27:08.940 --> 27:10.940
同步代码

27:10.940 --> 27:11.940
好

27:11.940 --> 27:12.940
第二步

27:12.940 --> 27:14.940
我们去请求这个地址

27:14.940 --> 27:16.940
来拿到一个数据

27:16.940 --> 27:18.940
从服务器拿到一个数据

27:18.940 --> 27:20.940
尽管你们很多人

27:20.940 --> 27:21.940
还不知道怎么去请求

27:21.940 --> 27:22.940
没关系

27:22.940 --> 27:23.940
你们看这个意思就行了

27:23.940 --> 27:25.940
由于它是一个同步代码

27:25.940 --> 27:27.940
那么它的执行过程是这样子的

27:27.940 --> 27:28.940
我这里呢

27:28.940 --> 27:30.940
因为我要请求网络

27:30.940 --> 27:33.940
我肯定要通知网络先程去干活

27:33.940 --> 27:34.940
你去干活吧

27:34.940 --> 27:35.940
我不管了

27:35.940 --> 27:36.940
你去请求

27:36.940 --> 27:37.940
网络先程

27:37.940 --> 27:39.940
就会向服务器发送请求

27:39.940 --> 27:41.940
然后等待服务器的结果

27:41.940 --> 27:43.940
然后最后拿到服务器的结果

27:43.940 --> 27:45.940
大家观察一下

27:45.940 --> 27:47.940
我们的执行宪程会发生什么事

27:47.940 --> 27:50.940
由于执行宪程的请求是同步的

27:50.940 --> 27:51.940
导致了这个时候

27:51.940 --> 27:53.940
能不能在请求的过程中

27:53.940 --> 27:54.940
在等待的过程中

27:54.940 --> 27:56.940
能不能去执行后面的代码

27:56.940 --> 27:57.940
不能

27:57.940 --> 27:58.940
它只能等

27:58.940 --> 27:59.940
等待中啥也干不了

27:59.940 --> 28:00.940
只能等着

28:00.940 --> 28:01.940
干等

28:01.940 --> 28:02.940
那么这

28:02.940 --> 28:03.940
等到什么时候

28:03.940 --> 28:06.940
等到它从服务器拿到结果之后

28:06.940 --> 28:08.940
拿到结果之后

28:08.940 --> 28:10.940
然后才继续往后执行

28:10.940 --> 28:12.940
把这个结果放到辨量lamb里边

28:12.940 --> 28:15.940
然后把这个lamb的设置为init

28:15.940 --> 28:17.940
设置多么元素

28:17.940 --> 28:18.940
然后呢

28:18.940 --> 28:20.940
最无辜的是谁

28:20.940 --> 28:22.940
最无辜的是他

28:22.940 --> 28:23.940
他最无辜的

28:23.940 --> 28:26.940
跟他有啥关系呢

28:26.940 --> 28:28.940
我可能这个任务呢

28:28.940 --> 28:31.940
我只需要执行10毫秒

28:31.940 --> 28:33.940
就能完成

28:33.940 --> 28:34.940
等待了等太多时间了

28:34.940 --> 28:37.940
可能要等待100毫秒

28:37.940 --> 28:38.940
那么跟他有什么关系呢

28:38.940 --> 28:39.940
他只想早一点

28:39.940 --> 28:40.940
赶快把自己执行

28:40.940 --> 28:41.940
那就完事了

28:41.940 --> 28:42.940
但是呢

28:42.940 --> 28:44.940
由于他要等待网络请求

28:44.940 --> 28:45.940
结果他什么也做不了

28:45.940 --> 28:48.940
这有点类似于什么呢

28:48.940 --> 28:50.940
有点类似于你们去吃饭

28:50.940 --> 28:51.940
店里边呢

28:51.940 --> 28:52.940
只有一个服务员

28:52.940 --> 28:54.940
那个服务员就担心什么

28:54.940 --> 28:56.940
整个店里边只有一个服务员

28:56.940 --> 28:58.940
但是个服务员很笨

28:58.940 --> 28:59.940
他怎么操作的

28:59.940 --> 29:01.940
来了一个客人

29:01.940 --> 29:02.940
然后跑到桌面前

29:02.940 --> 29:04.940
让他点餐

29:04.940 --> 29:05.940
好客人点完餐了

29:05.940 --> 29:08.940
他把这个点菜单拿给后厨

29:08.940 --> 29:10.940
然后不做事了

29:10.940 --> 29:12.940
就等在后厨那

29:12.940 --> 29:14.940
后厨就相当于是个网络请求

29:14.940 --> 29:16.940
后厨在做饭嘛

29:16.940 --> 29:18.940
然后这个服务员也跟着等

29:18.940 --> 29:20.940
然后这个时候来了很多

29:20.940 --> 29:21.940
其他的客人

29:21.940 --> 29:23.940
服务员不招呼

29:23.940 --> 29:24.940
就等

29:24.940 --> 29:25.940
等到把菜说好了过后

29:25.940 --> 29:26.940
然后把这个菜

29:26.940 --> 29:28.940
端给客人

29:28.940 --> 29:30.940
之前那个客人

29:30.940 --> 29:32.940
然后等那个客人吃完

29:32.940 --> 29:33.940
吃完了结到账

29:33.940 --> 29:34.940
结完账过后

29:34.940 --> 29:37.940
然后再去招待下一个客人

29:37.940 --> 29:39.940
同步就是这么一种情况

29:39.940 --> 29:41.940
只能浪费了很多的时间

29:41.940 --> 29:42.940
很多的时间

29:42.940 --> 29:43.940
他没有做任何事情

29:43.940 --> 29:45.940
就在那里瞎等

29:45.940 --> 29:46.940
但是实际上是有

29:46.940 --> 29:48.940
很多的任务需要他干的

29:48.940 --> 29:49.940
能明白这个意思吗

29:49.940 --> 29:51.940
担心的就会遇到这样的问题

29:51.940 --> 29:53.940
听懂的话就可以

29:53.940 --> 29:55.940
没听懂的话问问题

29:55.940 --> 30:01.150
OK

30:01.150 --> 30:03.150
好 那么现在呢

30:03.150 --> 30:04.150
都听懂了是吧

30:04.150 --> 30:06.150
好 那接下来我们继续

30:06.150 --> 30:08.150
那接下来是怎么来解决

30:08.150 --> 30:09.150
这个问题呢

30:09.150 --> 30:10.150
它是通过一步来解决的

30:10.150 --> 30:11.150
你看

30:11.150 --> 30:13.150
我们把一步引入过后了

30:13.150 --> 30:14.150
我们带把格式

30:14.150 --> 30:15.150
可能变成这个样子了

30:15.150 --> 30:17.150
同样的功能

30:17.150 --> 30:19.150
获得元素

30:19.150 --> 30:21.150
现在不是synchronized

30:21.150 --> 30:23.150
而synchronized

30:23.150 --> 30:25.150
是异步

30:25.150 --> 30:26.150
好 然后就也去

30:26.150 --> 30:27.150
请求这个地址

30:27.150 --> 30:28.150
但是呢 这个时候呢

30:28.150 --> 30:29.150
我不是用个反规值

30:29.150 --> 30:31.150
我是给它传了一个函数进去

30:31.150 --> 30:32.150
这个函数啥意思呢

30:32.150 --> 30:34.150
等你

30:34.150 --> 30:36.150
等你拿到结果之后

30:36.150 --> 30:38.150
你帮我运行一下这个函数

30:38.150 --> 30:39.150
把这个结果呢

30:39.150 --> 30:42.150
通过这个函数告诉我

30:42.150 --> 30:45.150
好 那么当这个函数运行的时候

30:45.150 --> 30:46.150
是不是就表示

30:46.150 --> 30:48.150
从服务器拿到结果了

30:48.150 --> 30:49.150
那么我把这个结果

30:49.150 --> 30:50.150
放到变量lamb里边

30:50.150 --> 30:51.150
或者是不用放到变量lamb里边

30:51.150 --> 30:53.150
直接复制就完成了

30:53.150 --> 30:54.150
是吧

30:54.150 --> 30:55.150
所以设置它的init秒

30:55.150 --> 30:57.150
就完成了

30:57.150 --> 30:58.150
好 然后在外面去执行

30:58.150 --> 31:00.150
其他五关紧要的任务

31:00.150 --> 31:02.150
跟这个五关的任务

31:02.150 --> 31:03.150
好 看一下这种模式

31:03.150 --> 31:05.150
是什么样的结果

31:05.150 --> 31:07.150
下面一个图

31:07.150 --> 31:08.150
同样的一开始

31:08.150 --> 31:10.150
还是同步过去动

31:10.150 --> 31:11.150
然后这个时候发生了

31:11.150 --> 31:12.150
一个异步的任务

31:12.150 --> 31:13.150
我要去请求网络了

31:13.150 --> 31:14.150
对吧

31:14.150 --> 31:15.150
那么这个时候

31:15.150 --> 31:16.150
就跟之前不一样了

31:16.150 --> 31:17.150
之前是同步等待

31:17.150 --> 31:18.150
现在不用等待了

31:18.150 --> 31:20.150
我去通知网络宪程干活

31:20.150 --> 31:21.150
你去请求吧

31:21.150 --> 31:22.150
我不管了

31:22.150 --> 31:23.150
只要发出一个通知

31:23.150 --> 31:25.150
它管 管都不管

31:25.150 --> 31:26.150
继续往后执行

31:26.150 --> 31:28.150
于是呢

31:28.150 --> 31:29.150
这一句话之

31:29.150 --> 31:31.150
在做什么事情

31:31.150 --> 31:33.150
发出一个通知

31:33.150 --> 31:34.150
通知谁

31:34.150 --> 31:36.150
通知网络宪程

31:36.150 --> 31:38.150
去发送

31:38.150 --> 31:39.150
去处理网络任务

31:39.150 --> 31:40.150
对吧

31:40.150 --> 31:41.150
自己不管了

31:41.150 --> 31:42.150
发出通知过后就不管了

31:42.150 --> 31:43.150
相当于马吧喊一声

31:43.150 --> 31:44.150
不管了

31:44.150 --> 31:45.150
不管了过来

31:45.150 --> 31:46.150
继续执行其他任务

31:46.150 --> 31:47.150
是不是这个东西执行了

31:47.150 --> 31:48.150
对不对

31:48.150 --> 31:49.150
你看这样执行的话

31:49.150 --> 31:50.150
它整个执行过程

31:50.150 --> 31:51.150
是非常密集的

31:51.150 --> 31:52.150
它没有等待

31:52.150 --> 31:54.150
整个过程完全没有等待

31:54.150 --> 31:55.150
好 那么五关任务

31:55.150 --> 31:56.150
执行完了过后

31:56.150 --> 31:57.150
那么比方到这个时候

31:57.150 --> 31:58.150
网络那边

31:58.150 --> 31:59.150
还没有给我结果

31:59.150 --> 32:00.150
这个时候

32:00.150 --> 32:02.150
我确实没有事情可以做了

32:02.150 --> 32:03.150
然后你在服务员那边

32:03.150 --> 32:04.150
那个服务员

32:04.150 --> 32:05.150
你把所有的客人

32:05.150 --> 32:06.150
都在认真地吃饭

32:06.150 --> 32:07.150
这个时候

32:07.150 --> 32:08.150
它确实没有事情可以做了

32:08.150 --> 32:09.150
那就好好休息吧

32:09.150 --> 32:10.150
那么这个时候

32:10.150 --> 32:11.150
能不能休息

32:11.150 --> 32:12.150
当然可以休息

32:12.150 --> 32:13.150
你不然不然

32:13.150 --> 32:14.150
要让它干嘛吧

32:14.150 --> 32:15.150
你相信让它做个

32:15.150 --> 32:16.150
十个服务呈

32:16.150 --> 32:17.150
也不可能吧

32:17.150 --> 32:18.150
那么这个时候

32:18.150 --> 32:19.150
它没有任何事情

32:19.150 --> 32:20.150
可以做了

32:20.150 --> 32:21.150
它只能休息

32:21.150 --> 32:22.150
有一天

32:22.150 --> 32:23.150
网络宪程终于

32:23.150 --> 32:24.150
把服务员的东西

32:24.150 --> 32:26.150
拿到结果之后

32:26.150 --> 32:27.150
然后在这个时候

32:27.150 --> 32:28.150
网络宪程

32:28.150 --> 32:30.150
会发出另外一个通知

32:30.150 --> 32:31.150
通知执行宪程

32:31.150 --> 32:33.150
你之前让我去

32:33.150 --> 32:35.150
从服务员去拿东西

32:35.150 --> 32:36.150
我现在拿到了

32:36.150 --> 32:37.150
把东西交给你

32:37.150 --> 32:39.150
那么一通知这个执行宪程

32:39.150 --> 32:40.150
过后呢

32:40.150 --> 32:42.150
执行宪程重新执行这个函数

32:42.150 --> 32:44.150
没了意思吧

32:44.150 --> 32:45.150
它是变成这么一种模式

32:45.150 --> 32:46.150
这么一种模式要异部

32:46.150 --> 32:48.150
你看这个异部任务

32:48.150 --> 32:49.150
是不是从这里开始

32:49.150 --> 32:50.150
在这里结束

32:50.150 --> 32:51.150
对吧

32:51.150 --> 32:53.150
它是挑约性的

32:53.150 --> 32:54.150
那么这是网络

32:54.150 --> 32:55.150
其实跟那个

32:55.150 --> 32:56.150
这些贸手

32:56.150 --> 32:57.150
是一样的道理

32:57.150 --> 32:58.150
这些贸手

32:58.150 --> 32:59.150
我们有计时嘛

32:59.150 --> 33:00.150
只不过这个

33:00.150 --> 33:01.150
就不是网络宪程

33:01.150 --> 33:02.150
就是计时宪程

33:02.150 --> 33:03.150
等待一段时间

33:03.150 --> 33:04.150
那么个计时

33:04.150 --> 33:05.150
现在它负责计时

33:05.150 --> 33:06.150
时间到了过后

33:06.150 --> 33:09.150
来发出个通知

33:09.150 --> 33:10.150
运行这个回调函数

33:10.150 --> 33:12.150
我们这些贪猫者

33:12.150 --> 33:14.150
里面说一个回调函数

33:14.150 --> 33:16.150
这些贪猫者

33:16.150 --> 33:18.150
这里面不是个回调函数

33:18.150 --> 33:19.150
那么这个代码

33:19.150 --> 33:20.150
就相当于是

33:20.150 --> 33:22.150
发出一个通知

33:22.150 --> 33:23.150
通知谁呢

33:23.150 --> 33:25.150
通知那个计时宪程

33:25.150 --> 33:26.150
你去计时

33:26.150 --> 33:27.150
计时良败好妙

33:27.150 --> 33:28.150
我不管了

33:28.150 --> 33:29.150
我接下来

33:29.150 --> 33:30.150
继续运行其他东西

33:30.150 --> 33:31.150
好

33:31.150 --> 33:32.150
当你计时结束过后

33:32.150 --> 33:33.150
你发出一个通知给我

33:33.150 --> 33:36.150
我就会运行这个回调函数

33:36.150 --> 33:37.150
这就是异部

33:37.150 --> 33:40.150
异部处理的模型

33:40.150 --> 33:43.360
好

33:43.360 --> 33:44.360
那么这一部分

33:44.360 --> 33:45.360
解释清楚过后

33:45.360 --> 33:46.360
我们再来看这个面说

33:46.360 --> 33:47.360
如果说问道理

33:47.360 --> 33:48.360
怎么来理解

33:48.360 --> 33:50.360
解释的异部

33:50.360 --> 33:51.360
你怎么回答呢

33:51.360 --> 33:52.360
你不要一个字

33:52.360 --> 33:53.360
一个字往外面碰

33:53.360 --> 33:54.360
很多同学面试的时候

33:54.360 --> 33:55.360
只老是一个词

33:55.360 --> 33:57.360
一个词往外面碰

33:57.360 --> 33:58.360
怎么理解

33:58.360 --> 34:00.360
解释异部

34:00.360 --> 34:02.360
掩饰之寻

34:02.360 --> 34:03.360
异部

34:03.360 --> 34:04.360
你这样

34:04.360 --> 34:05.360
你一个词

34:05.360 --> 34:06.360
一个词往外碰

34:06.360 --> 34:07.360
他都不知道你

34:07.360 --> 34:08.360
到底理解没有

34:08.360 --> 34:09.360
怎么回答呢

34:09.360 --> 34:10.360
这就是一段

34:10.360 --> 34:11.360
大家下来可以自寻

34:11.360 --> 34:12.360
自寻看一下

34:12.360 --> 34:13.360
我不用去读了

34:13.360 --> 34:14.360
读了没意义

34:14.360 --> 34:15.360
你把前面的东西

34:15.360 --> 34:16.360
理解清楚过后

34:16.360 --> 34:17.360
这一块

34:17.360 --> 34:18.360
一定能理解清楚

34:18.360 --> 34:19.360
什么叫主设

34:19.360 --> 34:20.360
主设就是等待

34:20.360 --> 34:21.360
你可以理解为等待

34:21.360 --> 34:22.360
咋想不了

34:22.360 --> 34:23.360
好

34:23.360 --> 34:24.360
这是第一个

34:24.360 --> 34:25.360
第一个知识

34:25.360 --> 34:26.360
县城和异部

34:26.360 --> 34:27.360
这一块

34:27.360 --> 34:28.360
有没有问题

34:28.360 --> 34:29.360
有问题的问

34:33.720 --> 34:34.720
没问题

34:35.720 --> 34:36.720
好

34:36.720 --> 34:37.720
那么咱们继续

34:37.720 --> 34:38.720
第二个

34:38.720 --> 34:39.720
执行站

34:39.720 --> 34:40.720
这一块

34:40.720 --> 34:41.720
我猜

34:41.720 --> 34:42.720
笔记里面

34:42.720 --> 34:43.720
就不是很好写

34:43.720 --> 34:47.220
我就直接演示吧

34:47.220 --> 34:49.220
这里得给大家看一个代码

34:49.220 --> 34:51.220
什么叫执行站呢

34:51.220 --> 34:53.220
执行站是一块内存空间

34:53.220 --> 34:54.220
既然是执行引擎

34:54.220 --> 34:55.220
就像我们要

34:55.220 --> 34:56.220
越来越细致的

34:56.220 --> 34:58.220
去深入到这里边去

34:58.220 --> 35:00.220
深入到这里边

35:00.220 --> 35:01.220
它到底是怎么去

35:01.220 --> 35:05.360
调度这些任务的

35:05.360 --> 35:07.360
在我们的既然是执行过程中

35:07.360 --> 35:09.360
有很多的函数需要执行

35:09.360 --> 35:10.360
是吧

35:10.360 --> 35:11.360
而且就算没有函数

35:11.360 --> 35:12.360
一开始

35:12.360 --> 35:13.360
也会有一个

35:13.360 --> 35:14.360
全具代码需要执行

35:14.360 --> 35:16.360
那么既然是执行引擎

35:16.360 --> 35:18.360
它到底是怎么去

35:18.360 --> 35:19.360
调度这些代码执行的呢

35:19.360 --> 35:20.360
到底

35:20.360 --> 35:21.360
什么时候执行

35:21.360 --> 35:22.360
什么代码

35:22.360 --> 35:23.360
到底是怎么去调度的

35:23.360 --> 35:24.360
我给大家看一个例子

35:29.110 --> 35:30.110
这里边我们写上

35:30.110 --> 35:31.110
这么一个函数

35:31.110 --> 35:32.110
方形

35:35.680 --> 35:36.680
然后这里边

35:36.680 --> 35:37.680
我们输出一个

35:37.680 --> 35:38.680
非常简单

35:39.680 --> 35:40.680
然后我们再来写一个

35:40.680 --> 35:41.680
调用方形B

35:43.680 --> 35:44.680
这是一个方形B

35:45.680 --> 35:47.680
然后输出B

35:48.680 --> 35:49.680
接下来我们调用

35:51.680 --> 35:52.680
我现在要解释

35:52.680 --> 35:53.680
整个代码的执行过程

35:58.040 --> 35:59.040
这个代码的执行过程

35:59.040 --> 36:00.040
解释清楚了

36:00.040 --> 36:01.040
其实

36:01.040 --> 36:02.040
你有知道执行站

36:02.040 --> 36:03.040
是怎么回事的

36:03.040 --> 36:05.040
执行站叫做Course Deck

36:06.040 --> 36:07.040
当注意开始的时候

36:07.040 --> 36:08.040
我们启动

36:09.040 --> 36:10.040
我们的网页的时候

36:11.040 --> 36:12.040
那么介式执行引擎

36:12.040 --> 36:13.040
也会启动

36:13.040 --> 36:15.040
遇到了介式执行代码

36:15.040 --> 36:16.040
它会启动执行引擎

36:17.040 --> 36:18.040
那么执行县城

36:18.040 --> 36:20.040
它会在我们的内存中

36:20.040 --> 36:21.040
创建这么一个东西

36:21.040 --> 36:22.040
叫做站

36:22.040 --> 36:23.040
一块内存中间

36:23.040 --> 36:24.040
你可以把它想象

36:24.040 --> 36:25.040
成为一个数组

36:26.040 --> 36:27.040
这数组里边

36:27.040 --> 36:28.040
可以装不同的东西

36:29.040 --> 36:30.040
注意开始

36:30.040 --> 36:31.040
它会往这个数组里边

36:31.040 --> 36:32.040
加入一个

36:32.040 --> 36:33.040
你可以把它认为是对象

36:33.040 --> 36:35.040
叫做Global Context

36:35.040 --> 36:37.040
叫做全局上下文

36:39.670 --> 36:40.670
全局上下文

36:42.670 --> 36:43.670
这个上下文

36:43.670 --> 36:44.670
到底存的是啥

36:44.670 --> 36:45.670
有什么东西

36:45.670 --> 36:47.670
大家不用去深究

36:47.670 --> 36:48.670
至少我们

36:48.670 --> 36:49.670
今天晚上不用去深究

36:49.670 --> 36:51.670
这网页里边很重要的

36:51.670 --> 36:52.670
是面试必考的

36:52.670 --> 36:53.670
但是今天晚上

36:53.670 --> 36:54.670
没有这个时间

36:54.670 --> 36:55.670
去讲到了

36:55.670 --> 36:57.670
总之大家记住我一句话

36:57.670 --> 36:59.670
没有执行上下文

36:59.670 --> 37:01.670
你的代码根本就无法执行

37:01.670 --> 37:02.670
你的代码要执行

37:02.670 --> 37:04.670
必须要有执行上下文

37:04.670 --> 37:05.670
这边存了什么呢

37:05.670 --> 37:06.670
简单说一下

37:06.670 --> 37:07.670
就存的是

37:07.670 --> 37:09.670
你执行中要用到了变量

37:09.670 --> 37:10.670
用到了函数

37:10.670 --> 37:11.670
乱七八糟的东西

37:11.670 --> 37:12.670
它必须要有这么个东西

37:12.670 --> 37:13.670
才能执行

37:13.670 --> 37:14.670
所以注意开始

37:14.670 --> 37:15.670
我们的执行站

37:15.670 --> 37:16.670
长这个样子

37:17.670 --> 37:22.260
好 接下来

37:22.260 --> 37:23.260
它看到这个代码

37:23.260 --> 37:24.260
这个代码执行吗

37:24.260 --> 37:25.260
不执行

37:25.260 --> 37:26.260
因为它只是一个函数生命

37:26.260 --> 37:27.260
这个代码执行吗

37:27.260 --> 37:28.260
不执行

37:28.260 --> 37:29.260
只是一个函数生命

37:29.260 --> 37:30.260
诶 遇到这

37:30.260 --> 37:32.260
是不是要执行代码了

37:32.260 --> 37:33.260
执行凡是

37:33.260 --> 37:35.260
我们要执行函数的地方

37:35.260 --> 37:36.260
它开始执行

37:36.260 --> 37:37.260
全局上的文就是

37:37.260 --> 37:38.260
我们可以认为

37:38.260 --> 37:39.260
就整个Screws元素里边

37:39.260 --> 37:40.260
全局代码

37:41.260 --> 37:42.260
执行的过程中

37:42.260 --> 37:44.260
它遇到了函数调用

37:44.260 --> 37:45.260
记住

37:45.260 --> 37:47.260
每一次遇到函数调用

37:47.260 --> 37:48.260
它就会创建一个

37:48.260 --> 37:50.260
新的执行商家文

37:51.260 --> 37:53.260
叫做这个函数调用

37:53.260 --> 37:54.260
执行商家文

37:54.260 --> 37:55.260
什么叫

37:55.260 --> 37:56.260
扣站

37:56.260 --> 37:57.260
执行站呢

37:57.260 --> 37:59.260
就执行函数的意思

37:59.260 --> 38:00.260
那么这个时候

38:00.260 --> 38:01.260
调用的是什么

38:01.260 --> 38:02.260
调用的是函数A

38:02.260 --> 38:03.260
对不对

38:03.260 --> 38:04.260
那么是A

38:04.260 --> 38:05.260
上下文

38:06.260 --> 38:07.260
它会创建一个上下文

38:07.260 --> 38:08.260
好

38:08.260 --> 38:09.260
然后把个上下文放在哪儿呢

38:09.260 --> 38:11.260
我们把它叫做入站

38:11.260 --> 38:12.260
就是把它放到

38:12.260 --> 38:13.260
这个站的顶端

38:13.260 --> 38:14.260
放到这儿

38:14.260 --> 38:16.890
好

38:16.890 --> 38:17.890
比方说

38:17.890 --> 38:18.890
我们这里边

38:18.890 --> 38:19.890
还有一个

38:19.890 --> 38:20.890
数数的Global

38:20.890 --> 38:21.890
你看

38:21.890 --> 38:22.890
现在我们

38:22.890 --> 38:24.890
站里边是这种情况

38:24.890 --> 38:25.890
顶端是A的上下文

38:25.890 --> 38:26.890
对吧

38:26.890 --> 38:27.890
因为我们在这里调用

38:28.890 --> 38:29.890
下边它能运行吗

38:29.890 --> 38:30.890
不能运行

38:30.890 --> 38:31.890
为什么

38:31.890 --> 38:33.890
因为界是执行引擎

38:33.890 --> 38:36.890
只会执行

38:36.890 --> 38:38.890
站顶端的东西

38:38.890 --> 38:39.890
那么现在站的顶端

38:39.890 --> 38:40.890
是什么

38:40.890 --> 38:41.890
变成了A了

38:41.890 --> 38:42.890
说这个时候

38:42.890 --> 38:44.890
它不会再去执行全具代码了

38:44.890 --> 38:46.890
会转而去执行A代码

38:46.890 --> 38:47.890
这是为什么你们

38:47.890 --> 38:48.890
感觉你所当转的

38:48.890 --> 38:49.890
你调用A权力

38:49.890 --> 38:50.890
会执行A代码

38:50.890 --> 38:52.890
它是这么来的

38:52.890 --> 38:53.890
因为它只会执行

38:53.890 --> 38:54.890
站顶端的东西

38:54.890 --> 38:55.890
那么现在顶端是A

38:55.890 --> 38:57.890
于是它会开始执行这个

38:57.890 --> 38:58.890
输出一个什么

38:58.890 --> 38:59.890
输出一个A

38:59.890 --> 39:00.890
你看

39:00.890 --> 39:02.890
这一块是不是函数调用

39:02.890 --> 39:03.890
不要告诉我不是

39:03.890 --> 39:04.890
肯定是个函数调用

39:04.890 --> 39:05.890
对吧

39:05.890 --> 39:06.890
那么于是

39:06.890 --> 39:07.890
只要遇到函数

39:07.890 --> 39:08.890
调用的地方

39:08.890 --> 39:09.890
它一定会新建的

39:09.890 --> 39:10.890
上下位

39:10.890 --> 39:11.890
右手站

39:11.890 --> 39:12.890
干嘛呢

39:12.890 --> 39:13.890
哪个站呢

39:13.890 --> 39:14.890
就是LOG

39:14.890 --> 39:15.890
上下位

39:15.890 --> 39:16.890
对吧

39:16.890 --> 39:17.890
哪个函数

39:17.890 --> 39:18.890
LOG函数

39:18.890 --> 39:20.890
传论一个函数A

39:20.890 --> 39:21.890
开始执行这个函数

39:21.890 --> 39:22.890
对吧

39:22.890 --> 39:23.890
A又暂停了

39:23.890 --> 39:24.890
等待这个函数执行

39:24.890 --> 39:25.890
好

39:25.890 --> 39:26.890
这个函数执行

39:26.890 --> 39:27.890
共产党是不是

39:27.890 --> 39:28.890
控制台就输出了一个A

39:28.890 --> 39:29.890
对不对

39:29.890 --> 39:30.890
控制台里面就输出了一个A

39:30.890 --> 39:31.890
不要意思

39:31.890 --> 39:32.890
好 继续

39:32.890 --> 39:33.890
好

39:33.890 --> 39:34.890
那么现在

39:34.890 --> 39:35.890
LOG是不是执行结束了

39:35.890 --> 39:36.890
控制台里面已经输出了

39:36.890 --> 39:37.890
对吧

39:37.890 --> 39:38.890
这是GSE

39:38.890 --> 39:39.890
浏览器给我们提供了内部的API

39:39.890 --> 39:40.890
好

39:40.890 --> 39:41.890
已经输出了

39:41.890 --> 39:42.890
输出完了过后

39:42.890 --> 39:43.890
是不是要函数执行结束

39:43.890 --> 39:45.890
函数执行结束

39:45.890 --> 39:46.890
出站

39:46.890 --> 39:47.890
就把它从站里面

39:47.890 --> 39:48.890
一出掉

39:48.890 --> 39:49.890
三出掉

39:49.890 --> 39:50.890
出站

39:50.890 --> 39:51.890
那么一出站的话

39:51.890 --> 39:52.890
你看

39:52.890 --> 39:54.890
是不是又回到A了

39:54.890 --> 39:55.890
好

39:55.890 --> 39:56.890
那么继续执行A

39:56.890 --> 39:57.890
好 现在继续执行A

39:57.890 --> 39:58.890
现在运行啥

39:58.890 --> 39:59.890
运行B

39:59.890 --> 40:00.890
所以又是函数调用

40:00.890 --> 40:01.890
又是函数调用

40:01.890 --> 40:02.890
建立B的上下位

40:02.890 --> 40:05.970
我觉得你们很难到了

40:05.970 --> 40:06.970
这么讲的

40:06.970 --> 40:07.970
这么仔细的了

40:07.970 --> 40:09.970
这是讲的是买在镜子

40:09.970 --> 40:10.970
再听不懂

40:10.970 --> 40:11.970
我也不知道怎么办了

40:11.970 --> 40:13.970
现在B

40:13.970 --> 40:14.970
又入站

40:14.970 --> 40:16.970
入站了过后

40:16.970 --> 40:17.970
现在是不是开始执行B的代码

40:17.970 --> 40:18.970
好

40:18.970 --> 40:19.970
B里边去调用什么

40:19.970 --> 40:21.970
console.log

40:21.970 --> 40:24.970
所以又建立log上下位

40:24.970 --> 40:25.970
对不对

40:25.970 --> 40:26.970
好

40:26.970 --> 40:27.970
现在又转而去运行这个函数

40:27.970 --> 40:28.970
log函数

40:28.970 --> 40:29.970
是不是输出了B

40:29.970 --> 40:30.970
好

40:30.970 --> 40:31.970
输出完了B

40:31.970 --> 40:32.970
log是不是执行结束了

40:32.970 --> 40:34.970
出站

40:34.970 --> 40:35.970
好

40:35.970 --> 40:36.970
又回到B了

40:36.970 --> 40:37.970
没东西了

40:37.970 --> 40:38.970
log一执行结束

40:38.970 --> 40:39.970
我又没东西了

40:39.970 --> 40:40.970
没东西的话

40:40.970 --> 40:41.970
B执行完了

40:41.970 --> 40:42.970
出站

40:42.970 --> 40:43.970
所以又回到A了

40:43.970 --> 40:44.970
A

40:44.970 --> 40:45.970
这里B执行结束了

40:45.970 --> 40:46.970
没东西了

40:46.970 --> 40:47.970
没东西的话

40:47.970 --> 40:48.970
又出站

40:48.970 --> 40:49.970
所以又回到全球上下文了

40:49.970 --> 40:50.970
该执行哪了

40:50.970 --> 40:51.970
是不是这

40:51.970 --> 40:52.970
执行这的时候

40:52.970 --> 40:54.970
是不是又要入站

40:54.970 --> 40:56.970
又要log上下文

40:56.970 --> 40:57.970
对吧

40:57.970 --> 40:58.970
上下文

40:58.970 --> 40:59.970
好

40:59.970 --> 41:00.970
然后呢

41:00.970 --> 41:01.970
把Globo输出

41:01.970 --> 41:02.970
输出Globo

41:02.970 --> 41:03.970
好

41:03.970 --> 41:04.970
输出完了过后

41:04.970 --> 41:07.280
log出站

41:07.280 --> 41:08.280
然后就回到全球上下文

41:08.280 --> 41:09.280
还有东西吗

41:09.280 --> 41:11.280
是啥东西没有了

41:11.280 --> 41:12.280
啥东西没有了

41:12.280 --> 41:14.280
这个也出站了

41:14.280 --> 41:15.280
站空了

41:15.280 --> 41:17.280
站空了是什么情况

41:17.280 --> 41:20.280
就这个情况

41:20.280 --> 41:22.280
执行引擎休息了

41:22.280 --> 41:23.280
你他没有事情可以做

41:23.280 --> 41:24.280
他不休息干嘛呢

41:24.280 --> 41:25.280
他只有休息了

41:25.280 --> 41:27.280
这就是执行上下文的

41:27.280 --> 41:29.280
整个执行过程

41:29.280 --> 41:31.280
没问题吧

41:31.280 --> 41:37.950
最后没问题吧

41:37.950 --> 41:38.950
执行站

41:38.950 --> 41:39.950
好

41:39.950 --> 41:40.950
那么执行站呢

41:40.950 --> 41:42.950
他有可能会出一个

41:42.950 --> 41:44.950
怎么样的面试题呢

41:44.950 --> 41:45.950
我看一下边

41:45.950 --> 41:56.170
第二题大家看一下

41:56.170 --> 41:57.170
他问你

41:57.170 --> 42:00.170
这个题其实考了事上了

42:00.170 --> 42:01.170
考了事对你

42:01.170 --> 42:03.170
就是你对执行站到底

42:03.170 --> 42:04.170
了不了解

42:04.170 --> 42:11.940
所以答应的结果是ap

42:11.940 --> 42:13.940
当然是ap

42:13.940 --> 42:15.940
这还有什么问题吗

42:15.940 --> 42:16.940
abglobo

42:16.940 --> 42:18.940
当然是abglobo

42:18.940 --> 42:19.940
还需要看一下吗

42:19.940 --> 42:20.940
要看一下吧

42:20.940 --> 42:25.620
abglobo

42:25.620 --> 42:26.620
这是最基础的

42:26.620 --> 42:28.620
哪怕你没有执行站的

42:28.620 --> 42:33.640
这是你应该知道是ab

42:33.640 --> 42:38.290
第二题看一下这个面试题

42:38.290 --> 42:39.290
现在有两个函数

42:39.290 --> 42:41.290
请问哪个函数会执行爆错

42:41.290 --> 42:45.120
如果爆错会爆怎么错

42:45.120 --> 42:49.200
为什么会出现这种情况

42:49.200 --> 42:50.200
A会爆错是吧

42:50.200 --> 42:53.200
B会不会爆错呢

42:53.200 --> 43:03.230
B会不会爆错呢

43:03.230 --> 43:04.230
我们要搞清楚这个问题

43:04.230 --> 43:07.230
我们用执行站去分析

43:07.230 --> 43:08.230
看着

43:08.230 --> 43:10.230
这个东西肯定会爆错

43:10.230 --> 43:11.230
为什么会爆错呢

43:11.230 --> 43:12.230
咱们来用执行站分析出来

43:12.230 --> 43:14.230
一下就明白了

43:14.230 --> 43:29.340
三里

43:29.340 --> 43:30.340
三里

43:30.340 --> 43:34.870
我执行了吗

43:34.870 --> 43:38.630
我再输出一下

43:38.630 --> 43:40.630
我执行

43:40.630 --> 43:41.630
我没调用啊

43:41.630 --> 43:42.630
我一开始没调用

43:42.630 --> 43:48.720
不输出了

43:48.720 --> 43:49.720
发现

43:49.720 --> 43:50.720
所以爆错了

43:50.720 --> 43:51.720
掉了什么呢

43:51.720 --> 43:52.720
maxima

43:52.720 --> 43:54.720
corsedex.cd

43:54.720 --> 43:55.720
站一出

43:55.720 --> 43:56.720
怎么要站一出呢

43:56.720 --> 43:59.720
我们来看一下这个执行的过程

43:59.720 --> 44:01.720
我的

44:01.720 --> 44:02.720
在这

44:02.720 --> 44:03.720
首先

44:03.720 --> 44:05.720
我们有一个全局上下文

44:05.720 --> 44:07.720
首先有一个全局上下文

44:07.720 --> 44:08.720
然后接下来

44:08.720 --> 44:09.720
我要调用A

44:09.720 --> 44:10.720
调用函数A

44:10.720 --> 44:12.720
于是他创建了一个函数A的上下文

44:12.720 --> 44:13.720
A上下文

44:13.720 --> 44:15.720
我就用个A表示

44:15.720 --> 44:16.720
开始执行A

44:16.720 --> 44:17.720
执行A的时候

44:17.720 --> 44:19.720
是又在调用函数A

44:19.720 --> 44:20.720
那么这个时候怎么办呢

44:20.720 --> 44:21.720
也不能说

44:21.720 --> 44:22.720
因为我有一个A

44:22.720 --> 44:23.720
我就不创建

44:23.720 --> 44:24.720
不是的

44:24.720 --> 44:26.720
甭管你是怎么情况

44:26.720 --> 44:27.720
只要你

44:27.720 --> 44:28.720
调用一个函数

44:28.720 --> 44:31.720
他一定创建一个新的上下文

44:31.720 --> 44:32.720
又创建一个A

44:32.720 --> 44:34.720
然后又去运行A

44:34.720 --> 44:35.720
运行这一次运行A

44:35.720 --> 44:37.720
这一次运行A是又在调用A

44:37.720 --> 44:38.720
又是又创建

44:38.720 --> 44:40.720
这一次运行A又在创建A

44:40.720 --> 44:41.720
又创建

44:41.720 --> 44:43.720
所以无穷的创建下去了

44:43.720 --> 44:45.720
而我们的站的空间是比较小的

44:45.720 --> 44:47.720
执行站的空间是比较小的

44:47.720 --> 44:50.720
很快他就把整个内存空间站满了

44:50.720 --> 44:51.720
那么站满了

44:51.720 --> 44:52.720
过后是什么情况呢

44:52.720 --> 44:55.720
就是达到了站的最大尺寸

44:55.720 --> 44:57.720
最大的站尺寸

44:57.720 --> 44:58.720
一出了

44:58.720 --> 44:59.720
变成这个错误

44:59.720 --> 45:01.720
最大叫站站一出

45:01.720 --> 45:04.720
那就是为什么他这个东西会发生错误

45:04.720 --> 45:08.290
好那么接下来第二个函数

45:08.290 --> 45:09.290
分析B

45:09.290 --> 45:11.290
我写的

45:11.290 --> 45:13.290
我写的是一个N

45:13.290 --> 45:14.290
一个N的余灵

45:14.290 --> 45:15.290
然后那Y

45:15.290 --> 45:17.290
N大余灵的情况下

45:17.290 --> 45:19.290
我们用一个N加加

45:19.290 --> 45:22.290
是不是相当于是个死循环啊

45:22.290 --> 45:23.290
是吧

45:23.290 --> 45:25.290
死循环会不会爆错呢

45:25.290 --> 45:31.550
运行

45:31.550 --> 45:34.550
调用了吗

45:35.550 --> 45:37.550
调用了

45:37.550 --> 45:38.550
有没有爆错呢

45:38.550 --> 45:39.550
是没有爆错

45:39.550 --> 45:42.550
反正可能不觉得这个循环在运行

45:42.550 --> 45:44.550
我写错了

45:44.550 --> 45:45.550
应该是大余灯余灵

45:45.550 --> 45:46.550
是吧

45:46.550 --> 45:47.550
大余灯余灵

45:47.550 --> 45:48.550
大余灯余灵

45:48.550 --> 45:50.550
看一下

45:50.550 --> 45:51.550
我说怎么感觉不对

45:51.550 --> 45:53.550
好 刷新

45:53.550 --> 45:56.550
你看这个圈圈是不是不准的做刷

45:56.550 --> 45:58.550
所以一直在运行

45:58.550 --> 45:59.550
但他有没有爆错

45:59.550 --> 46:01.550
他没有爆错

46:01.550 --> 46:02.550
为什么死循环没有爆错呢

46:02.550 --> 46:04.550
大家我们通过站来分析

46:04.550 --> 46:09.590
首先是全聚上下文

46:09.590 --> 46:11.590
全聚上下文里边说运行了一个函数B

46:11.590 --> 46:13.590
调用了一个函数B

46:13.590 --> 46:15.590
B在执行过程中

46:15.590 --> 46:17.590
那么它的内部建立了一个变量A

46:17.590 --> 46:18.590
然后呢

46:18.590 --> 46:20.590
A是不大于等于04

46:20.590 --> 46:22.590
N是不大于等于04

46:22.590 --> 46:23.590
N加加

46:23.590 --> 46:24.590
对吧

46:24.590 --> 46:25.590
所以不停的加

46:25.590 --> 46:26.590
不停的加

46:26.590 --> 46:28.590
但是有没有站里边有没有变化

46:28.590 --> 46:29.590
站里边是不是完全没有变化

46:29.590 --> 46:31.590
因为它并没有调用别的函数

46:31.590 --> 46:33.590
所以完全没有变化

46:33.590 --> 46:36.590
那么一个站的空间是不是非常稳定的

46:36.590 --> 46:38.590
因此它并不会站一出

46:38.590 --> 46:40.590
虽然站并不会一出

46:40.590 --> 46:41.590
那怎么办呢

46:41.590 --> 46:42.590
不怎么办

46:42.590 --> 46:43.590
就一直运行下去就完事了

46:43.590 --> 46:44.590
你把CPU内到

46:44.590 --> 46:46.590
爆炸了的那一天就不运行了

46:46.590 --> 46:48.590
关机的那一天就不运行了

46:48.590 --> 46:49.590
否则的话一直运行下去

46:49.590 --> 46:51.590
除了它这里一直在运行

46:51.590 --> 46:52.590
这个时候呢

46:52.590 --> 46:54.590
就相当于是CPU高速运转

46:54.590 --> 46:55.590
但是内存空

46:55.590 --> 46:56.590
占用了内存空间

46:56.590 --> 46:57.590
非常的少

46:57.590 --> 46:58.590
不要厉害是吧

46:58.590 --> 46:59.590
说死循环

46:59.590 --> 47:01.590
它并不会导致站一出

47:01.590 --> 47:02.590
这是关于这个题

47:03.590 --> 47:05.590
这是关于执行站

47:05.590 --> 47:09.090
执行站那一块有没有问题

47:10.090 --> 47:12.090
不会发誓的

47:13.090 --> 47:14.090
有没有问题

47:14.090 --> 47:15.090
有问题就问

47:15.090 --> 47:16.090
没问题咱们又继续

47:16.090 --> 47:18.090
开始讲今天的重点了

47:18.090 --> 47:20.090
重点就是世界循环

47:20.090 --> 47:21.090
那么前段东西

47:21.090 --> 47:22.090
如果说理解清楚了

47:22.090 --> 47:24.090
世界循环就比较好讲了

47:24.090 --> 47:26.090
世界循环是怎么回事呢

47:26.090 --> 47:28.090
我们要通过几个例子

47:28.090 --> 47:29.090
给它说明

47:29.090 --> 47:30.090
几个例子一下来过后了

47:30.090 --> 47:31.090
基本上你对世界循环

47:31.090 --> 47:33.090
就了解得比较清楚了

47:36.300 --> 47:37.300
第一个例子

47:46.720 --> 47:47.720
两百毫秒

47:48.720 --> 47:49.720
输出一个

47:49.720 --> 47:54.060
然后我们这里输出一个

47:54.060 --> 47:55.060
二

47:55.060 --> 47:58.370
那么它的输出税率是什么呢

47:58.370 --> 47:59.370
违地规

47:59.370 --> 48:00.370
它是地规的东西

48:01.370 --> 48:02.370
不过呢浏览器里边

48:02.370 --> 48:03.370
违地规

48:04.370 --> 48:05.370
没什么用

48:05.370 --> 48:06.370
没什么用

48:06.370 --> 48:07.370
因为现在呢

48:07.370 --> 48:09.370
至少之前那个浏览器版本

48:09.370 --> 48:10.370
它是不支持违地规的

48:10.370 --> 48:12.370
浏览器支持

48:12.370 --> 48:14.370
漏的环境是不支持的

48:14.370 --> 48:15.370
不知道现在更新了过后

48:15.370 --> 48:16.370
有没有进一步

48:17.370 --> 48:18.370
二一对吧

48:18.370 --> 48:19.370
所以同学都知道

48:19.370 --> 48:20.370
这个没什么好说的

48:20.370 --> 48:24.900
那我这样子呢

48:24.900 --> 48:27.400
这样子呢

48:27.400 --> 48:28.400
还是二一

48:28.400 --> 48:29.400
是吧

48:29.400 --> 48:30.400
还是二一

48:31.400 --> 48:47.070
那我这样子呢

48:47.070 --> 48:50.340
这样子

48:50.340 --> 48:51.340
还是二一

48:51.340 --> 48:52.340
那么就理解清楚了

48:52.340 --> 48:53.340
那么大家就要去

48:53.340 --> 48:54.340
知道它里边

48:54.340 --> 48:55.340
到底是怎么回事

48:55.340 --> 48:57.340
为什么会出现这种情况

48:57.340 --> 49:00.340
这需要用事件循环来解释

49:01.340 --> 49:02.340
怎么回事呢

49:02.340 --> 49:03.340
现在我们看这张图

49:03.340 --> 49:05.340
这张图有三块空间了

49:05.340 --> 49:06.340
刚才呢

49:06.340 --> 49:07.340
左边是我们熟悉的

49:07.340 --> 49:08.340
这个执行站

49:08.340 --> 49:09.340
右边呢

49:09.340 --> 49:10.340
有个东西叫做web API

49:10.340 --> 49:12.340
这个web API是什么呢

49:12.340 --> 49:13.340
你可以把它认为是

49:13.340 --> 49:15.340
浏览器里边的其他线程

49:15.340 --> 49:16.340
比方说

49:16.340 --> 49:17.340
等待事件

49:17.340 --> 49:19.340
等待计时

49:19.340 --> 49:21.340
发出网络通信

49:21.340 --> 49:22.340
对吧

49:22.340 --> 49:23.340
还有些其他线程要处理

49:23.340 --> 49:25.340
我们之前不是有一个图

49:25.340 --> 49:26.340
就是我们要通知

49:26.340 --> 49:27.340
其他线程干活吗

49:27.340 --> 49:28.340
对吧

49:28.340 --> 49:29.340
那么这里就是其他各种线程

49:29.340 --> 49:31.340
去做具体不同的事情

49:31.340 --> 49:32.340
下边还有个空间

49:32.340 --> 49:34.340
我们把它叫做event screen

49:34.340 --> 49:36.340
叫做那个事件对立

49:36.340 --> 49:37.340
我们看这三个空间

49:37.340 --> 49:39.340
是如何来共同协助

49:39.340 --> 49:40.340
共同完成

49:40.340 --> 49:42.340
介石里边的异部操作的

49:42.340 --> 49:43.340
我们前面粗略的说一下

49:43.340 --> 49:44.340
异部操作

49:44.340 --> 49:45.340
那么异部操作具体是怎么玩的

49:45.340 --> 49:46.340
靠着这个玩意儿

49:47.340 --> 49:51.420
咱们来捋一下啊

49:51.420 --> 49:52.420
比方说我这里

49:52.420 --> 49:53.420
从两半毫秒开始

49:53.420 --> 49:54.420
这有一个函数

49:54.420 --> 49:55.420
要给它一个名字

49:55.420 --> 49:56.420
叫做A

49:56.420 --> 49:58.420
就给不给名字都一样

49:58.420 --> 50:00.420
好 首先我们看到了

50:00.420 --> 50:01.420
执行站里边

50:01.420 --> 50:02.420
是不是有一个全聚上下文

50:02.420 --> 50:04.420
然后接下来执行怎么函数

50:04.420 --> 50:06.420
执行的是timeout函数

50:06.420 --> 50:08.420
set timeout

50:08.420 --> 50:09.420
set timeout

50:09.420 --> 50:11.420
会创建一个上下文

50:11.420 --> 50:13.420
那么这个函数会干嘛呢

50:13.420 --> 50:15.420
这个函数它会不会等待了

50:15.420 --> 50:16.420
它不会等待

50:16.420 --> 50:18.420
它不会做任何事情

50:18.420 --> 50:19.420
它就做一件事

50:19.420 --> 50:22.420
它去通知我们另外一个

50:22.420 --> 50:23.420
就是我们的web API

50:23.420 --> 50:25.420
它就通知

50:25.420 --> 50:27.420
浏览器的其他线程

50:27.420 --> 50:28.420
你帮我处理一下

50:28.420 --> 50:29.420
这里我需要计时的

50:29.420 --> 50:31.420
也就是说这个计时操作

50:31.420 --> 50:33.420
不是由计也是完成的

50:33.420 --> 50:36.420
是由浏览器的其他线程完成的

50:36.420 --> 50:37.420
没有意思吧

50:37.420 --> 50:38.420
好 那么这个时候呢

50:38.420 --> 50:39.420
浏览器的其他线程

50:39.420 --> 50:41.420
比方说计时线程

50:41.420 --> 50:42.420
它就会启动

50:42.420 --> 50:43.420
计时就会启动

50:43.420 --> 50:45.420
它就会启动

50:45.420 --> 50:46.420
干嘛呢

50:46.420 --> 50:49.420
它让我等待200毫秒

50:49.420 --> 50:51.420
200毫秒之后呢

50:51.420 --> 50:53.420
我要运行函数A

50:54.420 --> 50:55.420
你看

50:55.420 --> 50:56.420
200毫秒之后

50:56.420 --> 50:57.420
我要运行函数A

50:57.420 --> 50:58.420
没了意思吧

50:58.420 --> 50:59.420
它就去计时去了

50:59.420 --> 51:01.420
然后这边只是发出一个通知

51:01.420 --> 51:03.420
管都不管

51:03.420 --> 51:04.420
这就是异部

51:04.420 --> 51:05.420
你看异部发出通知

51:05.420 --> 51:06.420
就不管了

51:06.420 --> 51:07.420
怎么不管了

51:07.420 --> 51:08.420
它直接就出站了

51:08.420 --> 51:10.420
函数运行结束了

51:10.420 --> 51:11.420
这边还在计时

51:11.420 --> 51:13.420
这边就已经结束了

51:13.420 --> 51:16.420
然后回到权局上下文去执行

51:16.420 --> 51:17.420
执行啥

51:17.420 --> 51:18.420
输出了1

51:18.420 --> 51:19.420
对吧

51:19.420 --> 51:20.420
对吧 输出了2

51:20.420 --> 51:21.420
对不对

51:21.420 --> 51:22.420
那么这个时候呢

51:22.420 --> 51:23.420
权局上下文了

51:23.420 --> 51:24.420
它实际上还要创建个执行啥

51:24.420 --> 51:25.420
然后弄个

51:25.420 --> 51:26.420
然后输出2

51:26.420 --> 51:27.420
然后弄个结束

51:27.420 --> 51:28.420
对吧 我就不说了

51:28.420 --> 51:29.420
那么就输出了2

51:31.420 --> 51:32.420
好 输出完2过后

51:32.420 --> 51:33.420
是不是上下文

51:33.420 --> 51:35.420
权局上下文也出站了

51:35.420 --> 51:36.420
结束了

51:36.420 --> 51:37.420
休息呗

51:37.420 --> 51:38.420
没事的

51:38.420 --> 51:39.420
已经休息了

51:39.420 --> 51:40.420
好 它休息了过后

51:40.420 --> 51:42.420
200毫秒结束了

51:42.420 --> 51:44.420
那么这边的

51:44.420 --> 51:46.420
浏览器的其他线程

51:46.420 --> 51:47.420
它会把做什么事呢

51:47.420 --> 51:49.420
它不会直接扔过来执行

51:49.420 --> 51:51.420
它会把这个函数

51:51.420 --> 51:53.420
你之前不是注册一个函数吗

51:53.420 --> 51:55.420
它会把这个函数推到

51:55.420 --> 51:57.420
一个对立里面去

51:57.420 --> 51:58.420
叫做

51:58.420 --> 52:00.420
事件对立

52:00.420 --> 52:02.420
它会推过来

52:02.420 --> 52:03.420
表示什么呢

52:03.420 --> 52:06.420
表示我这里已经准备好了

52:06.420 --> 52:07.420
我们的服务员

52:07.420 --> 52:08.420
就是这个主线

52:08.420 --> 52:09.420
这是个执行线程

52:09.420 --> 52:10.420
执行站

52:10.420 --> 52:11.420
我们的服务员

52:11.420 --> 52:12.420
你什么时候有空的时候呢

52:12.420 --> 52:14.420
你就把我拿去执行

52:14.420 --> 52:16.420
来做一下我这边的操作

52:16.420 --> 52:17.420
我这里已经处理好了

52:17.420 --> 52:19.420
排队等着

52:19.420 --> 52:21.420
这个时候执行站正好是空着

52:21.420 --> 52:22.420
于是呢

52:22.420 --> 52:24.420
它就把这个函数

52:24.420 --> 52:26.420
又拿过来了

52:26.420 --> 52:28.420
拿过来去执行这个函数

52:28.420 --> 52:29.420
这个时候呢

52:29.420 --> 52:30.420
A就开始执行了

52:30.420 --> 52:31.420
执行这个A

52:31.420 --> 52:33.420
输出了E

52:33.420 --> 52:35.420
它整个执行过程是这样子的

52:38.420 --> 52:39.420
好

52:39.420 --> 52:40.420
那么这是这个例子

52:40.420 --> 52:41.420
能听懂吗

52:41.420 --> 52:42.420
好 今天我们看下一个例子

52:42.420 --> 52:43.420
就刚才的第二个

52:43.420 --> 52:45.420
后面最后一个例子

52:45.420 --> 52:46.420
这个例子

52:46.420 --> 52:47.420
好 看一下这个例子

52:47.420 --> 52:49.420
为什么仍然会输出2.1

52:49.420 --> 52:50.420
需要演示一下吗

52:50.420 --> 52:53.180
离开了

52:53.180 --> 52:54.180
它要循环一会儿

52:54.180 --> 52:55.180
循环完了

52:56.180 --> 52:57.180
仍然会输出2.1

52:57.180 --> 52:58.180
为什么呢

52:58.180 --> 53:00.180
咱们继续用这个例子来看

53:01.180 --> 53:02.180
首先还是一样

53:02.180 --> 53:03.180
全句上下文

53:05.180 --> 53:06.180
接下来运行什么呢

53:12.200 --> 53:13.200
那么这个还说干嘛

53:13.200 --> 53:14.200
发出一个通知

53:14.200 --> 53:15.200
通知

53:15.200 --> 53:16.200
这边

53:16.200 --> 53:18.200
你去帮我计时多少时间

53:18.200 --> 53:19.200
计时零号表

53:19.200 --> 53:21.200
实际上浏览器里面零号表

53:22.200 --> 53:23.200
实际上是4号表

53:23.200 --> 53:24.200
对吧 大家都知道

53:24.200 --> 53:25.200
但是呢

53:25.200 --> 53:26.200
就算是零号表

53:27.200 --> 53:28.200
我们就打比说它是零号表

53:28.200 --> 53:30.200
然后零号表之后呢

53:30.200 --> 53:31.200
我们要运行什么函数呢

53:31.200 --> 53:32.200
运行A这个函数

53:33.200 --> 53:34.200
它这边发出通知

53:34.200 --> 53:35.200
马上就结束了

53:35.200 --> 53:36.200
出山

53:37.200 --> 53:38.200
这边是不是也计时结束了

53:38.200 --> 53:40.200
现成之间是可以同时完成的

53:40.200 --> 53:41.200
它计时也结束了

53:41.200 --> 53:43.200
但是它不会直接把A扔过来

53:43.200 --> 53:44.200
它会排队

53:45.200 --> 53:46.200
日照照排队

53:46.200 --> 53:47.200
排着

53:48.200 --> 53:49.200
什么意思呢

53:49.200 --> 53:50.200
就是说

53:50.200 --> 53:53.200
咱们可爱的执行站

53:53.200 --> 53:54.200
你什么时候有空的时候

53:54.200 --> 53:55.200
拿过来执行

53:55.200 --> 53:57.200
但是现在执行站忙的钥匙

53:57.200 --> 53:58.200
它没空

53:58.200 --> 54:00.200
现在的服务员还在招呼其他客人

54:00.200 --> 54:01.200
忙

54:01.200 --> 54:02.200
它没有空

54:02.200 --> 54:04.200
执行站没有清空

54:04.200 --> 54:06.200
它就不会去看这个世界对列

54:06.200 --> 54:08.200
因此它会继续执行

54:08.200 --> 54:09.200
全局上下文

54:10.200 --> 54:12.200
于是它产生了一个

54:12.200 --> 54:14.200
实意识的循环

54:14.200 --> 54:15.200
内的钥匙

54:15.200 --> 54:17.200
好循环结束过后

54:17.200 --> 54:18.200
又输出了一个二

54:19.200 --> 54:20.200
好不容易

54:20.200 --> 54:21.200
还这个时候

54:21.200 --> 54:22.200
才把整个执行站

54:22.200 --> 54:24.200
所有的东西全部执行完了

54:24.200 --> 54:26.200
执行完了过后清空

54:26.200 --> 54:28.200
这个服务员是不是空下来了

54:28.200 --> 54:29.200
空下来了

54:29.200 --> 54:30.200
那么这个时候一看

54:30.200 --> 54:32.200
这个A已经等了很久了

54:32.200 --> 54:33.200
拿过来执行

54:34.200 --> 54:36.200
于是输出了A里边的E

54:39.200 --> 54:41.200
整个过程就叫做

54:41.200 --> 54:42.200
事件循环

54:43.200 --> 54:45.200
我们的函数

54:45.200 --> 54:47.200
从这跑到这

54:47.200 --> 54:48.200
又从这跑到这

54:48.200 --> 54:49.200
又可能跑到这

54:49.200 --> 54:50.200
而它在执行过程中

54:50.200 --> 54:51.200
执行的过程中

54:51.200 --> 54:53.200
有可能会一说就到其他的异部

54:53.200 --> 54:54.200
那么又可能会里边

54:54.200 --> 54:56.200
又可能会出现一些东西

54:56.200 --> 54:57.200
比方说B

54:57.200 --> 54:58.200
那么B又通知这边

54:58.200 --> 54:59.200
跑过来

54:59.200 --> 55:00.200
又跑过来

55:00.200 --> 55:01.200
又跑过来

55:01.200 --> 55:02.200
这就是个事件循环

55:02.200 --> 55:03.200
原来的意思吧

55:04.200 --> 55:05.200
这个东西不是要解释

55:05.200 --> 55:06.200
我们通过几个例子

55:06.200 --> 55:07.200
就比较清楚了

55:09.200 --> 55:12.760
那接下来我们来看一个例子

55:13.760 --> 55:14.760
再看一个

55:16.760 --> 55:17.760
看个

55:18.760 --> 55:25.470
我们就仔细看面试题吧

55:25.470 --> 55:26.470
看一下这个面试题

55:28.840 --> 55:29.840
这个面试题扶植一下

55:33.370 --> 55:34.370
这个面试题输出什么

55:35.370 --> 55:36.370
大家可以看一下

55:36.370 --> 55:37.370
待会可以看一下

55:38.370 --> 55:40.370
服务器时就不排队

55:40.370 --> 55:41.370
排队啊

55:41.370 --> 55:42.370
它只要那边计时完成

55:42.370 --> 55:43.370
甭管那边

55:43.370 --> 55:45.370
这边是网络任务也好

55:45.370 --> 55:46.370
不要网络通信

55:46.370 --> 55:47.370
达到服务器的数据了

55:47.370 --> 55:49.370
要交一个回调函数

55:49.370 --> 55:51.370
就把函数扔到这个队里边来

55:52.370 --> 55:53.370
就从这里边排队

55:53.370 --> 55:55.370
比方说这边扔很多东西过来

55:55.370 --> 55:57.370
比方说刚才扔了一个A

55:57.370 --> 55:58.370
假设

55:58.370 --> 55:59.370
这个A还没有执行

55:59.370 --> 56:00.370
那么这个时候

56:00.370 --> 56:01.370
这边B又来了

56:02.370 --> 56:03.370
B也扔进来

56:03.370 --> 56:04.370
排队嘛

56:04.370 --> 56:05.370
一个个排队

56:05.370 --> 56:06.370
到时候拿的时候

56:06.370 --> 56:07.370
就从最顶不该是拿

56:08.370 --> 56:11.390
明白意思吧

56:11.390 --> 56:12.390
认证

56:12.390 --> 56:13.390
看一下这个题

56:13.390 --> 56:14.390
这个题会输出什么

56:15.390 --> 56:20.450
这边

56:20.450 --> 56:22.450
服务器它不是函数

56:23.450 --> 56:24.450
它不是函数

56:24.450 --> 56:25.450
你说刚才这个吗

56:25.450 --> 56:27.450
我还要刚才解释清楚

56:28.450 --> 56:29.450
我再来一次

56:30.450 --> 56:31.450
首先

56:31.450 --> 56:32.450
首先是不是拳句上下文

56:33.450 --> 56:36.890
Global Context

56:37.890 --> 56:38.890
说拳句上下文

56:38.890 --> 56:39.890
拳句上下文

56:39.890 --> 56:40.890
过后

56:40.890 --> 56:41.890
这里一个Set Time Mode

56:41.890 --> 56:42.890
这个Set Time Mode

56:42.890 --> 56:43.890
它是一一步的

56:45.890 --> 56:46.890
老我问你

56:47.890 --> 56:48.890
没有这个函数

56:48.890 --> 56:50.890
你能不能写出一个

56:50.890 --> 56:52.890
完全一模一样的等待效果

56:52.890 --> 56:53.890
你自己可以想一想

56:56.400 --> 56:57.400
没有这个函数

56:58.400 --> 56:59.400
你能不能实现

56:59.400 --> 57:00.400
一个一模一样的函数

57:00.400 --> 57:02.400
来实现等待效果

57:02.400 --> 57:05.710
来实现等待多少好秒钟

57:05.710 --> 57:06.710
你能不能

57:06.710 --> 57:07.710
能不能做得到

57:08.710 --> 57:09.710
你怎么实现

57:09.710 --> 57:14.620
我请问你怎么实现

57:14.620 --> 57:15.620
你怎么实现

57:15.620 --> 57:19.250
你不可能实现的

57:20.250 --> 57:21.250
不可能的

57:21.250 --> 57:22.250
为什么呢

57:22.250 --> 57:24.250
因为GSE语言

57:24.250 --> 57:26.250
它只给你提供了同步的能力

57:26.250 --> 57:28.250
它没给你提供一步的能力

57:28.250 --> 57:29.250
一步的能力

57:29.250 --> 57:30.250
是谁给你提供的

57:30.250 --> 57:32.250
全部是由数捉环境

57:32.250 --> 57:33.250
提供的

57:33.250 --> 57:36.330
你看一下这

57:36.330 --> 57:39.330
你们平时开发GSE的时候

57:39.330 --> 57:41.330
遇到哪些异步场景

57:41.330 --> 57:42.330
网络

57:43.330 --> 57:46.330
它是由网络线程给你提供的

57:46.330 --> 57:47.330
计时

57:47.330 --> 57:49.330
它是由计时线程完成的

57:49.330 --> 57:50.330
还有什么事件

57:50.330 --> 57:51.330
事件是异步的

57:51.330 --> 57:52.330
为什么事件是异步的

57:52.330 --> 57:53.330
它要等到点击之后

57:53.330 --> 57:54.330
才会做事

57:54.330 --> 57:55.330
没有点击就不会做事

57:55.330 --> 57:56.330
是不是异步的

57:56.330 --> 57:57.330
它要点击之后

57:57.330 --> 57:58.330
运行那个函数

57:58.330 --> 57:59.330
事件坚定

58:00.330 --> 58:01.330
当然还包括GUI渲染里边

58:01.330 --> 58:02.330
不是有些事件吗

58:02.330 --> 58:03.330
渲染的事件

58:03.330 --> 58:04.330
对吧

58:05.330 --> 58:07.330
都是其他线程完成的

58:07.330 --> 58:09.330
因为由于你在GSE里边

58:09.330 --> 58:11.330
你是没有能力去调度

58:11.330 --> 58:12.330
其他线程的

58:12.330 --> 58:14.330
调度其他线程需要

58:14.330 --> 58:17.330
底层的接口

58:17.330 --> 58:19.330
然后C和Ca加接口

58:19.330 --> 58:20.330
你在GSE里边

58:20.330 --> 58:22.330
是没有这个能力去调度

58:22.330 --> 58:23.330
你学GSE学了这么久了

58:23.330 --> 58:24.330
也没有人告诉你

58:24.330 --> 58:25.330
在GSE里边如何去

58:25.330 --> 58:26.330
调度其他线程

58:26.330 --> 58:28.330
没有吧

58:28.330 --> 58:29.330
我们只能通过什么呢

58:29.330 --> 58:32.330
只能通过浏览器给我们的API

58:32.330 --> 58:33.330
调整啊

58:33.330 --> 58:36.330
什么阿加克斯的相关的对象啊

58:36.330 --> 58:38.330
什么DOM里边的相关的属性

58:38.330 --> 58:39.330
onclick啊对吧

58:39.330 --> 58:41.330
通过这些API

58:41.330 --> 58:44.330
间接的调度其他线程

58:44.330 --> 58:46.330
你自己是没有这个能力的

58:46.330 --> 58:48.330
你会发现所有的异步场景

58:48.330 --> 58:50.330
全是数组环境给你提供的

58:50.330 --> 58:51.330
对不对

58:51.330 --> 58:53.330
是不是这个道理

58:53.330 --> 58:54.330
所以这个C叉帽子就是

58:54.330 --> 58:55.330
浏览器给我们提供了

58:55.330 --> 58:56.330
一个异步函数

58:56.330 --> 58:58.330
这个函数的作用就是

58:58.330 --> 59:00.330
它要通知其他线程

59:00.330 --> 59:02.330
你怎么去通知其他线程

59:02.330 --> 59:03.330
你没有这个能力

59:03.330 --> 59:05.330
它要去通知其他线程

59:05.330 --> 59:07.330
计时0毫秒

59:07.330 --> 59:09.330
然后运小函数A

59:09.330 --> 59:10.330
对不对

59:10.330 --> 59:11.330
就是这个函数

59:11.330 --> 59:13.330
它内部用C和C压加

59:13.330 --> 59:14.330
实现了这一点

59:14.330 --> 59:16.330
你是没法实现的

59:16.330 --> 59:17.330
这个函数是不是执行结束了

59:17.330 --> 59:18.330
在GSE层面是不是

59:18.330 --> 59:19.330
执行结束了

59:19.330 --> 59:20.330
它只是发出个通知

59:20.330 --> 59:22.330
然后这边函数A

59:22.330 --> 59:24.330
0毫秒瞬间就完成了

59:24.330 --> 59:26.330
完成计时了

59:26.330 --> 59:28.330
然后把A推到这个什么

59:29.330 --> 59:31.330
推到执行对立

59:31.330 --> 59:33.330
但是它现在不能执行

59:33.330 --> 59:34.330
为什么因为

59:34.330 --> 59:36.330
全聚三项文还没有执行结束

59:36.330 --> 59:37.330
还要至于

59:37.330 --> 59:38.330
因为这个时候它没有空闲

59:38.330 --> 59:39.330
对吧

59:39.330 --> 59:40.330
为什么没有空闲

59:40.330 --> 59:41.330
因为全聚三项文还在

59:41.330 --> 59:42.330
它还得继续执行

59:42.330 --> 59:44.330
于是它开始执行循环

59:44.330 --> 59:45.330
循环是不是异步带吧

59:45.330 --> 59:46.330
不是

59:46.330 --> 59:48.330
循环是同步的

59:48.330 --> 59:49.330
它就一直执行

59:49.330 --> 59:50.330
一直执行

59:50.330 --> 59:51.330
一直执行

59:51.330 --> 59:52.330
它就执行

59:53.330 --> 59:54.330
执行了十亿次

59:54.330 --> 59:55.330
然后输出

59:55.330 --> 59:56.330
输出二

59:56.330 --> 59:58.330
然后才把全聚三项文执行完了

59:58.330 --> 01:00:00.330
执行完了就出占了

01:00:00.330 --> 01:00:01.330
那么这个时候它又空

01:00:01.330 --> 01:00:03.330
去执行你这个函数A

01:00:07.330 --> 01:00:09.330
这一块能听懂了

01:00:09.330 --> 01:00:10.330
没问题吧

01:00:11.330 --> 01:00:13.330
对 异步是由数组环境提供的

01:00:13.330 --> 01:00:14.330
你既也是自己写

01:00:14.330 --> 01:00:16.330
是写不出来异步的

01:00:16.330 --> 01:00:17.330
写不出来的

01:00:21.090 --> 01:00:23.090
对 一定是要执行占空间

01:00:23.090 --> 01:00:25.090
它才会从这里边去拿

01:00:25.090 --> 01:00:27.090
它不空永远在排队等着

01:00:27.090 --> 01:00:29.090
寶贝说你到饭店里边去吃饭

01:00:29.090 --> 01:00:31.090
那个服务员现在正忙得不可开交

01:00:31.090 --> 01:00:33.090
你不可能直接把它拖过来

01:00:33.090 --> 01:00:35.090
让它先服务你这边

01:00:35.090 --> 01:00:37.090
这个时候保安就过来了

01:00:37.090 --> 01:00:39.090
它一定是要空险下来过后

01:00:39.090 --> 01:00:42.090
它才能够到你这边来服务你

01:00:42.090 --> 01:00:45.090
它得把之前手上的事情做完

01:00:46.090 --> 01:00:47.090
那么现在我们来看一下

01:00:47.090 --> 01:00:49.090
这个面是低

01:00:50.090 --> 01:00:51.090
分析一下

01:00:51.090 --> 01:00:59.970
Promise我们明天讲

01:00:59.970 --> 01:01:00.970
没有进去

01:01:00.970 --> 01:01:03.970
没有 如果刚才是初三过后就没了

01:01:03.970 --> 01:01:08.120
时间肯定不准

01:01:08.120 --> 01:01:09.120
时间肯定是不准的

01:01:09.120 --> 01:01:10.120
无论是set time out

01:01:10.120 --> 01:01:11.120
还是set interval

01:01:11.120 --> 01:01:12.120
这个时间肯定不准的

01:01:12.120 --> 01:01:14.120
你不能完全新认这个时间

01:01:14.120 --> 01:01:16.120
这个时间只能是个大概

01:01:16.120 --> 01:01:18.120
肯定是不准的

01:01:18.120 --> 01:01:23.090
看这个题

01:01:23.090 --> 01:01:24.090
实际上你们在

01:01:24.090 --> 01:01:26.090
在以后面试的过程中

01:01:26.090 --> 01:01:28.090
遇到这个事件循环的题

01:01:28.090 --> 01:01:30.090
它不会这么简单

01:01:30.090 --> 01:01:32.090
它一般会跟Promise一起考

01:01:32.090 --> 01:01:34.090
甚至跟note接式一起考

01:01:34.090 --> 01:01:35.090
但是以后我们现在还没有

01:01:35.090 --> 01:01:36.090
学习Promise

01:01:36.090 --> 01:01:37.090
明天讲

01:01:37.090 --> 01:01:39.090
还更加不可能学习note了

01:01:39.090 --> 01:01:40.090
所以说我这里

01:01:40.090 --> 01:01:42.090
这个题是我自己写的

01:01:42.090 --> 01:01:43.090
明天我可以给大家

01:01:43.090 --> 01:01:44.090
看一下真实的面试题

01:01:44.090 --> 01:01:46.090
3 4 3 2 1

01:01:46.090 --> 01:01:49.530
3 4

01:01:49.530 --> 01:01:51.530
3 4 3 2 1

01:01:54.530 --> 01:01:55.530
4

01:01:55.530 --> 01:01:56.530
看一下

01:01:56.530 --> 01:01:58.530
3 4

01:01:58.530 --> 01:02:01.910
然后呢

01:02:01.910 --> 01:02:03.910
3 2 1

01:02:05.910 --> 01:02:06.910
3 4 1 3 2

01:02:06.910 --> 01:02:09.910
你们是蒙的还是

01:02:11.910 --> 01:02:13.910
3 4 1 3 2是正确的

01:02:13.910 --> 01:02:15.910
3 4 1 3 2是正确的

01:02:15.910 --> 01:02:18.910
3 4 1 3 2

01:02:18.910 --> 01:02:19.910
对了

01:02:19.910 --> 01:02:20.910
3 4 1 3 2是正确的

01:02:20.910 --> 01:02:26.140
怎么来的

01:02:26.140 --> 01:02:29.140
还是用执行占据分析

01:02:29.140 --> 01:02:33.860
首先来一个全聚上下文

01:02:33.860 --> 01:02:34.860
然后运行这什么

01:02:34.860 --> 01:02:35.860
运行这些贪冒者

01:02:35.860 --> 01:02:37.860
这些贪冒者寒书干嘛的

01:02:37.860 --> 01:02:39.860
通知

01:02:39.860 --> 01:02:40.860
通知流烂期的字

01:02:40.860 --> 01:02:41.860
因为它是个异部寒书

01:02:41.860 --> 01:02:43.860
通知流烂期的其他现成

01:02:43.860 --> 01:02:44.860
去计时

01:02:44.860 --> 01:02:45.860
计时多久了

01:02:45.860 --> 01:02:46.860
0

01:02:46.860 --> 01:02:48.860
当然你不写的差数也是一样

01:02:48.860 --> 01:02:51.860
0毫秒后

01:02:51.860 --> 01:02:52.860
0毫秒后

01:02:52.860 --> 01:02:53.860
执行什么

01:02:53.860 --> 01:02:54.860
执行放可一

01:02:54.860 --> 01:02:55.860
放可一

01:02:55.860 --> 01:02:56.860
好

01:02:56.860 --> 01:02:57.860
0毫秒的时候瞬间到了

01:02:57.860 --> 01:03:01.490
放可一排队

01:03:01.490 --> 01:03:03.490
过来排队

01:03:03.490 --> 01:03:04.490
接下来

01:03:04.490 --> 01:03:05.490
这些贪冒者

01:03:05.490 --> 01:03:06.490
这些贪冒者

01:03:06.490 --> 01:03:07.490
可能已经出卖了

01:03:07.490 --> 01:03:08.490
回到全聚上上文

01:03:08.490 --> 01:03:09.490
全聚上文是

01:03:09.490 --> 01:03:10.490
又运行那个寒书A

01:03:10.490 --> 01:03:12.490
运行寒书A

01:03:13.490 --> 01:03:14.490
运行寒书A在过程中

01:03:14.490 --> 01:03:16.490
是不是又运行那个寒冒者

01:03:16.490 --> 01:03:18.490
又运行的寒冒者

01:03:18.490 --> 01:03:19.490
有的时候如果说

01:03:19.490 --> 01:03:20.490
我这个题还比较简单

01:03:20.490 --> 01:03:21.490
如果题比较复杂的话

01:03:21.490 --> 01:03:22.490
就要画图

01:03:22.490 --> 01:03:24.490
运行寒书A是否又通知

01:03:24.490 --> 01:03:26.490
通知过它

01:03:26.490 --> 01:03:27.490
0毫秒

01:03:27.490 --> 01:03:28.490
执行什么

01:03:28.490 --> 01:03:29.490
执行放可二

01:03:29.490 --> 01:03:31.490
0毫秒的时候瞬间结束了

01:03:31.490 --> 01:03:32.490
于是放可二

01:03:32.490 --> 01:03:33.490
又马上跑这儿来了

01:03:33.490 --> 01:03:36.830
放可二

01:03:36.830 --> 01:03:37.830
跑过来了

01:03:37.830 --> 01:03:38.830
好

01:03:38.830 --> 01:03:39.830
这边一样的

01:03:39.830 --> 01:03:40.830
继续执行A

01:03:40.830 --> 01:03:41.830
A这边输出3

01:03:41.830 --> 01:03:43.830
于是我们最先看到的是3

01:03:43.830 --> 01:03:44.830
对不对

01:03:45.830 --> 01:03:49.330
好A执行完了出战

01:03:49.330 --> 01:03:50.330
好继续

01:03:50.330 --> 01:03:51.330
A执行完了过后

01:03:51.330 --> 01:03:52.330
是不是输出4

01:03:52.330 --> 01:03:54.330
我看到了输出4

01:03:54.330 --> 01:03:56.330
最开始看到的是3和4

01:03:56.330 --> 01:03:57.330
接下来继续

01:03:57.330 --> 01:03:58.330
那么这个时候

01:03:58.330 --> 01:03:59.330
权力汉汉问题执行结束了

01:03:59.330 --> 01:04:00.330
对吧

01:04:00.330 --> 01:04:02.330
执行结束了没了

01:04:02.330 --> 01:04:03.330
没了过后

01:04:03.330 --> 01:04:04.330
是不是开始把执行

01:04:04.330 --> 01:04:05.330
执行对列

01:04:05.330 --> 01:04:06.330
有事件对列里边

01:04:06.330 --> 01:04:07.330
都去拿出来执行

01:04:07.330 --> 01:04:09.330
首先执行放可一

01:04:09.330 --> 01:04:10.330
放可一

01:04:10.330 --> 01:04:11.330
是不是执行这儿

01:04:11.330 --> 01:04:12.330
好

01:04:12.330 --> 01:04:13.330
放可一输出它

01:04:13.330 --> 01:04:14.330
输出1

01:04:14.330 --> 01:04:15.330
输出1玩过

01:04:15.330 --> 01:04:17.330
是不是又要执行A

01:04:17.330 --> 01:04:18.330
你看

01:04:19.330 --> 01:04:20.330
放可一在执行的过程中

01:04:20.330 --> 01:04:21.330
又要去执行A

01:04:21.330 --> 01:04:22.330
不好意思

01:04:22.330 --> 01:04:23.330
放可二的排队

01:04:23.330 --> 01:04:24.330
等着吧

01:04:24.330 --> 01:04:25.330
一定要等我执行

01:04:25.330 --> 01:04:26.330
站清空之后

01:04:26.330 --> 01:04:28.330
我才有时间执行A

01:04:28.330 --> 01:04:29.330
而执行A的过程中

01:04:29.330 --> 01:04:30.330
是不是又来了

01:04:30.330 --> 01:04:32.330
又运行谁探帽子

01:04:33.330 --> 01:04:35.330
又运行谁探帽子

01:04:36.330 --> 01:04:37.330
探帽子

01:04:37.330 --> 01:04:39.330
又去通知这边

01:04:39.330 --> 01:04:40.330
又来计时

01:04:40.330 --> 01:04:41.330
0毫秒之后

01:04:41.330 --> 01:04:42.330
运行什么

01:04:42.330 --> 01:04:43.330
运行放可

01:04:44.330 --> 01:04:45.330
放可二

01:04:45.330 --> 01:04:48.840
对不对

01:04:48.840 --> 01:04:49.840
0毫秒之后

01:04:49.840 --> 01:04:50.840
跑了去

01:04:50.840 --> 01:04:52.840
运行放可二

01:04:52.840 --> 01:04:53.840
好放可二

01:04:53.840 --> 01:04:54.840
那么是不是运行完了

01:04:55.840 --> 01:04:56.840
跑转

01:04:56.840 --> 01:04:57.840
放可二排队

01:04:57.840 --> 01:04:58.840
排了两个放可二了

01:04:58.840 --> 01:04:59.840
对不对

01:04:59.840 --> 01:05:01.840
好那么这里A执行完了

01:05:02.840 --> 01:05:04.840
好回到放可一

01:05:04.840 --> 01:05:05.840
还没有执行完

01:05:05.840 --> 01:05:06.840
刚才执行A的过后

01:05:06.840 --> 01:05:07.840
它通知完了

01:05:07.840 --> 01:05:08.840
还要输出一个3

01:05:08.840 --> 01:05:09.840
对吧

01:05:09.840 --> 01:05:11.840
里面还回答的不对

01:05:11.840 --> 01:05:12.840
你们回答的不对

01:05:12.840 --> 01:05:14.840
还要输出一个3

01:05:15.840 --> 01:05:16.840
对不对

01:05:16.840 --> 01:05:19.340
好

01:05:19.340 --> 01:05:20.340
然后回答

01:05:20.340 --> 01:05:22.340
A现在是不是执行完了

01:05:22.340 --> 01:05:23.340
出战

01:05:23.340 --> 01:05:24.340
然后又回到放可一了

01:05:24.340 --> 01:05:25.340
放可一

01:05:25.340 --> 01:05:26.340
之前把A执行完了

01:05:26.340 --> 01:05:27.340
它就结束了

01:05:27.340 --> 01:05:28.340
放可一没了

01:05:28.340 --> 01:05:29.340
放可一又出战

01:05:29.340 --> 01:05:30.340
好这个时候

01:05:30.340 --> 01:05:31.340
你才会发现

01:05:31.340 --> 01:05:32.340
哎哟

01:05:32.340 --> 01:05:33.340
终于空了

01:05:33.340 --> 01:05:36.340
现在把之前等了很久的放可二来执行

01:05:36.340 --> 01:05:37.340
放可二执行的时候

01:05:37.340 --> 01:05:39.840
出什么出出2

01:05:39.840 --> 01:05:40.840
好

01:05:40.840 --> 01:05:42.840
然后放可二出战

01:05:42.840 --> 01:05:43.840
好

01:05:43.840 --> 01:05:44.840
然后这边又来了

01:05:44.840 --> 01:05:45.840
又拿过来执行

01:05:45.840 --> 01:05:46.840
出什么出出2

01:05:46.840 --> 01:05:48.840
那么结果是3 4 1 3 2

01:05:48.840 --> 01:05:55.890
2

01:05:55.890 --> 01:05:56.890
3 4 1 3

01:05:56.890 --> 01:05:57.890
2个2

01:05:57.890 --> 01:05:58.890
原来是

01:05:58.890 --> 01:05:59.890
有的时候像这种题啊

01:05:59.890 --> 01:06:00.890
你如果说面试的时候

01:06:00.890 --> 01:06:02.890
看到了过后

01:06:02.890 --> 01:06:04.890
你用执行战去分析

01:06:04.890 --> 01:06:05.890
用执行战分析

01:06:05.890 --> 01:06:07.890
是万无一失的

01:06:07.890 --> 01:06:08.890
因为你如果说

01:06:08.890 --> 01:06:09.890
就用眼睛去看的话

01:06:09.890 --> 01:06:10.890
稍微不注意就看到了

01:06:10.890 --> 01:06:11.890
对吧

01:06:11.890 --> 01:06:12.890
而且它真实的

01:06:12.890 --> 01:06:13.890
面试体里边

01:06:13.890 --> 01:06:15.890
这种题它会绕很多圈的

01:06:15.890 --> 01:06:17.890
但是你无论它怎么去绕

01:06:17.890 --> 01:06:19.890
你用这个执行战去分析出来

01:06:19.890 --> 01:06:20.890
一定是没有错的

01:06:20.890 --> 01:06:22.890
因为这就是它真实的执行过程

01:06:22.890 --> 01:06:23.890
一旦它真实的执行过程

01:06:23.890 --> 01:06:24.890
走了一遍

01:06:24.890 --> 01:06:26.890
那是一定没错的

01:06:26.890 --> 01:06:27.890
这是执行

01:06:27.890 --> 01:06:29.890
这是个事件循环

01:06:29.890 --> 01:06:30.890
好 最后呢

01:06:30.890 --> 01:06:31.890
给它补充一个事件循环

01:06:31.890 --> 01:06:33.890
里边的一个小知识

01:06:33.890 --> 01:06:34.890
这个小知识呢

01:06:34.890 --> 01:06:35.890
按理说明天讲的

01:06:35.890 --> 01:06:37.890
我们首先给它做个铺垫

01:06:37.890 --> 01:06:39.890
因为明天讲的内容比较多

01:06:39.890 --> 01:06:40.890
什么小知识呢

01:06:40.890 --> 01:06:41.890
就是执行

01:06:41.890 --> 01:06:42.890
执行对列里边呢

01:06:42.890 --> 01:06:44.890
实际上有两个对列

01:06:44.890 --> 01:06:45.890
真实的情况

01:06:45.890 --> 01:06:47.890
更真实的情况是这样子的

01:06:47.890 --> 01:06:48.890
一个呢叫做

01:06:48.890 --> 01:06:49.890
v对列

01:06:49.890 --> 01:06:51.890
这东西叫做v对列

01:06:51.890 --> 01:06:52.890
v对列

01:06:52.890 --> 01:06:56.890
叫做micro taskqueen

01:06:56.890 --> 01:06:59.890
另一个呢叫做红对列

01:06:59.890 --> 01:07:02.890
叫做macro taskqueen

01:07:02.890 --> 01:07:03.890
单词差不多

01:07:03.890 --> 01:07:05.890
一个是v对列 一个是红对列

01:07:05.890 --> 01:07:06.890
就是我们之前的都是

01:07:06.890 --> 01:07:07.890
按照一个对列来算的

01:07:07.890 --> 01:07:09.890
实际上是它有两个对列

01:07:09.890 --> 01:07:10.890
在node里边对列更多

01:07:10.890 --> 01:07:11.890
一大堆的对列

01:07:11.890 --> 01:07:12.890
我们这里呢

01:07:12.890 --> 01:07:14.890
扭烂器里边有两个对列

01:07:14.890 --> 01:07:16.890
扭烂器的长期要简单一点

01:07:16.890 --> 01:07:17.890
这两个对列里面

01:07:17.890 --> 01:07:18.890
怎么 因为我们知道

01:07:18.890 --> 01:07:19.890
这边完成了一个事件

01:07:19.890 --> 01:07:20.890
要等待的时候

01:07:20.890 --> 01:07:21.890
它是先会推到这儿

01:07:21.890 --> 01:07:22.890
是吧

01:07:22.890 --> 01:07:23.890
那么问题来了

01:07:23.890 --> 01:07:25.890
这边的情况下

01:07:25.890 --> 01:07:27.890
它到底会推到哪个对列呢

01:07:27.890 --> 01:07:31.890
目前你们遇到了所有的情况

01:07:31.890 --> 01:07:33.890
所有的一部情况

01:07:33.890 --> 01:07:35.890
我看有这样的有信心的

01:07:35.890 --> 01:07:36.890
里面遇到了所有的

01:07:36.890 --> 01:07:37.890
一部情况

01:07:37.890 --> 01:07:38.890
全推到这个对列的

01:07:38.890 --> 01:07:39.890
红对列

01:07:39.890 --> 01:07:41.890
明天我们学习了之后呢

01:07:41.890 --> 01:07:42.890
会有一个新的情况

01:07:42.890 --> 01:07:43.890
它会到哪儿

01:07:43.890 --> 01:07:44.890
v对列

01:07:44.890 --> 01:07:45.890
那么今天我们由于

01:07:45.890 --> 01:07:46.890
没有学习v对列

01:07:46.890 --> 01:07:48.890
怎么来掩饰呢

01:07:48.890 --> 01:07:51.890
给它看一下这个东西

01:07:51.890 --> 01:07:52.890
这个东西不是一个

01:07:52.890 --> 01:07:54.890
你们必须要了解的技术

01:07:54.890 --> 01:07:57.890
这个东西没有什么用啊

01:07:57.890 --> 01:07:58.890
而且它效率也不好

01:07:58.890 --> 01:07:59.890
没有什么用

01:07:59.890 --> 01:08:00.890
比较说一下

01:08:00.890 --> 01:08:01.890
它是v对列的

01:08:01.890 --> 01:08:02.890
那么这个v对列和红对列

01:08:02.890 --> 01:08:03.890
有什么区别呢

01:08:03.890 --> 01:08:04.890
就在于

01:08:04.890 --> 01:08:06.890
当这边完事之后

01:08:06.890 --> 01:08:07.890
它空弦了

01:08:07.890 --> 01:08:08.890
空弦了

01:08:08.890 --> 01:08:09.890
它会取对列的时候

01:08:09.890 --> 01:08:10.890
它如果说发现

01:08:10.890 --> 01:08:11.890
v对列里面有东西

01:08:11.890 --> 01:08:12.890
然后这里有一个

01:08:12.890 --> 01:08:13.890
这里有一个

01:08:13.890 --> 01:08:14.890
这里有一个

01:08:14.890 --> 01:08:16.890
它会先从v对列里面取

01:08:16.890 --> 01:08:18.890
取得过执行

01:08:18.890 --> 01:08:19.890
再从v对列里面取

01:08:19.890 --> 01:08:20.890
取得过执行完

01:08:20.890 --> 01:08:21.890
执行完了过后

01:08:21.890 --> 01:08:22.890
一直到v对列里面

01:08:22.890 --> 01:08:25.890
没有任何东西的过后

01:08:25.890 --> 01:08:28.890
才会去执行红对列

01:08:28.890 --> 01:08:29.890
明白我的意思吗

01:08:29.890 --> 01:08:31.890
它是这么一回事

01:08:31.890 --> 01:08:32.890
一定是先执行v对列

01:08:32.890 --> 01:08:34.890
然后再去执行红对列

01:08:34.890 --> 01:08:35.890
今天呢

01:08:35.890 --> 01:08:38.890
给大家看一下这个

01:08:38.890 --> 01:08:39.890
浏览器里边

01:08:39.890 --> 01:08:41.890
有这么一个API

01:08:41.890 --> 01:08:42.890
不重要

01:08:42.890 --> 01:08:43.890
我再说一下

01:08:43.890 --> 01:08:44.890
但是由于今天

01:08:44.890 --> 01:08:46.890
我们没有学习Promise

01:08:46.890 --> 01:08:47.890
是我们明天的内容

01:08:47.890 --> 01:08:48.890
所以说

01:08:48.890 --> 01:08:49.890
今天我要掩饰这个v对列

01:08:49.890 --> 01:08:50.890
我就没法掩饰

01:08:50.890 --> 01:08:52.890
我只能用一个这么个东西

01:08:52.890 --> 01:08:58.830
这边就来了吧

01:08:58.830 --> 01:09:02.830
叫做Motation

01:09:02.830 --> 01:09:03.830
Motation什么意思

01:09:03.830 --> 01:09:04.830
突变

01:09:04.830 --> 01:09:05.830
突然的变化

01:09:05.830 --> 01:09:06.830
变异

01:09:06.830 --> 01:09:07.830
Observer

01:09:07.830 --> 01:09:08.830
表示观察

01:09:08.830 --> 01:09:10.830
观察一个变异

01:09:10.830 --> 01:09:12.830
另一个Motation

01:09:12.830 --> 01:09:13.830
Observer

01:09:13.830 --> 01:09:14.830
它是个构造函数

01:09:14.830 --> 01:09:15.830
在构造函数里面传上了

01:09:15.830 --> 01:09:18.830
传的是一个回调

01:09:18.830 --> 01:09:20.830
传的是一个回调

01:09:20.830 --> 01:09:22.830
这个回调是一个函数

01:09:22.830 --> 01:09:24.830
这个函数

01:09:24.830 --> 01:09:26.830
该函数是放到v对列里面

01:09:26.830 --> 01:09:30.830
该函数将在v对列中

01:09:30.830 --> 01:09:31.830
大家现在还有点模糊

01:09:31.830 --> 01:09:32.830
不知道什么意思

01:09:32.830 --> 01:09:33.830
我一会再解释

01:09:33.830 --> 01:09:35.830
v对列中

01:09:35.830 --> 01:09:36.830
好了

01:09:36.830 --> 01:09:37.830
那么这个函数里面

01:09:37.830 --> 01:09:40.830
我们就输出DIV变化了

01:09:40.830 --> 01:09:42.830
就这样一个输出就完事了

01:09:42.830 --> 01:09:44.830
或者就输出

01:09:44.830 --> 01:09:46.830
然后它会产生一个对象

01:09:46.830 --> 01:09:47.830
产生一个对象

01:09:47.830 --> 01:09:49.830
这个函数目前是不会执行的

01:09:49.830 --> 01:09:50.830
产生一个对象叫做

01:09:50.830 --> 01:09:52.830
就随便写一个东西来Observer

01:09:52.830 --> 01:09:54.830
表示观察者

01:09:54.830 --> 01:09:55.830
那么这个观察者

01:09:55.830 --> 01:09:58.830
它有一个函数叫做Observer

01:09:58.830 --> 01:09:59.830
观察什么呢

01:09:59.830 --> 01:10:01.830
观察一个动物元素

01:10:01.830 --> 01:10:04.830
动物元素你可以先获取吧

01:10:04.830 --> 01:10:06.830
APP

01:10:06.830 --> 01:10:07.830
Documents

01:10:07.830 --> 01:10:09.830
It's Animins by ID

01:10:09.830 --> 01:10:10.830
对

01:10:10.830 --> 01:10:11.830
APP

01:10:11.830 --> 01:10:12.830
OK

01:10:13.830 --> 01:10:14.830
什么意思

01:10:14.830 --> 01:10:16.830
它表示观察它的变化

01:10:16.830 --> 01:10:18.830
观察

01:10:18.830 --> 01:10:21.830
APP的变化

01:10:21.830 --> 01:10:24.460
好

01:10:24.460 --> 01:10:25.460
现在我们也运行一下

01:10:25.460 --> 01:10:31.100
这个东西

01:10:31.100 --> 01:10:32.100
好 你看

01:10:47.200 --> 01:10:52.180
这里哪里写出了吗

01:10:54.560 --> 01:10:57.380
Callback

01:10:58.380 --> 01:11:00.380
我这里好像是要返回

01:11:00.380 --> 01:11:02.380
返回一个配置对象

01:11:02.380 --> 01:11:03.380
我查一下吧

01:11:03.380 --> 01:11:05.380
反正这个API也太少

01:11:05.380 --> 01:11:06.380
没什么用

01:11:06.380 --> 01:11:07.380
我查一下MDN

01:11:07.380 --> 01:11:08.380
像这些浴室布局

01:11:08.380 --> 01:11:09.380
像那种API接口的那种

01:11:09.380 --> 01:11:10.380
忘了无所谓

01:11:10.380 --> 01:11:11.380
你查一下MDN

01:11:11.380 --> 01:11:12.380
什么都有了

01:11:16.380 --> 01:11:17.380
看一下它

01:11:18.380 --> 01:11:21.380
它主要的用处就是观察这个变化

01:11:21.380 --> 01:11:23.380
观察一个元素的变化

01:11:23.380 --> 01:11:24.380
变化的时候

01:11:24.380 --> 01:11:27.380
只行你给它传递的函数

01:11:28.380 --> 01:11:32.800
有

01:11:32.800 --> 01:11:33.800
打开了

01:11:33.800 --> 01:11:34.800
打开了

01:11:35.800 --> 01:11:36.800
我不知道

01:11:36.800 --> 01:11:37.800
没问题

01:11:42.650 --> 01:11:46.670
传入这个回调

01:11:46.670 --> 01:11:47.670
明白了

01:11:47.670 --> 01:11:49.670
这里要传递一个

01:11:50.670 --> 01:11:51.670
这里要传递一个

01:11:51.670 --> 01:11:53.670
就是观察它哪些东西

01:11:53.670 --> 01:11:56.670
观察这个元素的哪些东西

01:11:56.670 --> 01:11:58.670
我们就观察它的切组的历史

01:11:58.670 --> 01:12:00.670
观察它的就是

01:12:00.670 --> 01:12:01.670
它的孩子

01:12:01.670 --> 01:12:02.670
孩子里边有文本吧

01:12:02.670 --> 01:12:03.670
说观察它的孩子

01:12:04.670 --> 01:12:05.670
其他都不观察了

01:12:05.670 --> 01:12:06.670
那意思吧

01:12:06.670 --> 01:12:07.670
就是观察API的变化

01:12:07.670 --> 01:12:08.670
观察它的孩子

01:12:10.670 --> 01:12:11.670
我们回到这

01:12:11.670 --> 01:12:15.520
接下来我们看看

01:12:15.520 --> 01:12:17.520
我们给这个APP的Inner

01:12:17.520 --> 01:12:18.520
Inner ATML

01:12:18.520 --> 01:12:19.520
要设置

01:12:19.520 --> 01:12:20.520
设置到API

01:12:21.520 --> 01:12:23.520
你看这个玩意是不是输出了

01:12:23.520 --> 01:12:24.520
DAP变化

01:12:24.520 --> 01:12:25.520
也就是怎么呢

01:12:25.520 --> 01:12:26.520
这个函数是异步的

01:12:26.520 --> 01:12:27.520
它要等

01:12:27.520 --> 01:12:28.520
它不是立即执行了

01:12:28.520 --> 01:12:29.520
它要等

01:12:29.520 --> 01:12:31.520
等到一个时期满足的时候

01:12:32.520 --> 01:12:34.520
就跟我们的计时计时一样

01:12:34.520 --> 01:12:36.520
它要等到一个东西满足的时候

01:12:36.520 --> 01:12:37.520
才会自行这个函数

01:12:37.520 --> 01:12:38.520
那么也就是说

01:12:38.520 --> 01:12:39.520
它是异步的

01:12:40.520 --> 01:12:41.520
不要这意思吧

01:12:41.520 --> 01:12:42.520
那么这个玩意异步的话

01:12:42.520 --> 01:12:44.520
它就会推向微对的

01:12:45.520 --> 01:12:47.520
好 那么现在有意思的东西就完了

01:12:47.520 --> 01:12:49.520
我们今天只能用这个玩意来做了

01:12:49.520 --> 01:12:51.520
本来你们以后在练习的时候

01:12:51.520 --> 01:12:52.520
会用它的

01:12:52.520 --> 01:12:53.520
它一般处理的时候

01:12:53.520 --> 01:12:54.520
更用的是Promise

01:12:54.520 --> 01:12:57.890
那么现在我们来玩这个事情

01:12:57.890 --> 01:13:01.590
我就随便瞎想

01:13:01.590 --> 01:13:02.590
这里一个函数

01:13:03.590 --> 01:13:04.590
一会儿分析

01:13:06.590 --> 01:13:07.590
然后呢

01:13:07.590 --> 01:13:08.590
我们这里一个Set Timeout

01:13:11.220 --> 01:13:12.220
这个函数

01:13:12.220 --> 01:13:13.220
B

01:13:14.220 --> 01:13:15.220
这里输出一个

01:13:16.220 --> 01:13:17.220
1

01:13:17.220 --> 01:13:18.220
这里输出一个

01:13:19.220 --> 01:13:20.220
2

01:13:21.220 --> 01:13:22.220
然后这里边

01:13:22.220 --> 01:13:24.600
再来一个

01:13:24.600 --> 01:13:25.600
App

01:13:25.600 --> 01:13:26.600
InnerATML

01:13:26.600 --> 01:13:27.600
等于1

01:13:30.600 --> 01:13:31.600
这里边来一个

01:13:31.600 --> 01:13:32.600
AppInnerATML

01:13:32.600 --> 01:13:33.600
等于

01:13:39.240 --> 01:13:41.240
这边再来一个

01:13:41.240 --> 01:13:42.240
Set Timeout

01:13:43.240 --> 01:13:44.240
多稍一会吧

01:13:44.240 --> 01:13:45.240
这到底做完了

01:13:45.240 --> 01:13:47.240
咱们今天东西就差不多了

01:13:48.240 --> 01:13:49.240
这个C

01:13:49.240 --> 01:13:51.740
输出3

01:13:51.740 --> 01:13:52.740
好 来了

01:13:52.740 --> 01:14:08.850
你不能去看它的时间差值

01:14:08.850 --> 01:14:10.850
这个东西是绝对不准的

01:14:10.850 --> 01:14:12.850
一定要看它的就是入站

01:14:12.850 --> 01:14:13.850
出站的顺序

01:14:14.850 --> 01:14:17.360
然后进入一个

01:14:17.360 --> 01:14:18.360
事件对立的顺序

01:14:18.360 --> 01:14:19.360
所以今天学校过后

01:14:19.360 --> 01:14:20.360
你就不用用那种

01:14:20.360 --> 01:14:22.360
感性的方式来认识程序了

01:14:22.360 --> 01:14:23.360
一定要准备去认识的

01:14:26.360 --> 01:14:27.360
这个玩意

01:14:27.360 --> 01:14:28.360
我现在都不知道输出啥

01:14:28.360 --> 01:14:32.840
我就瞎写的

01:14:32.840 --> 01:14:33.840
你们按照

01:14:33.840 --> 01:14:34.840
用今天的知识

01:14:34.840 --> 01:14:35.840
把它做出来的

01:14:35.840 --> 01:14:42.440
行了

01:14:42.440 --> 01:14:43.440
咱们课堂上就不等了

01:14:43.440 --> 01:14:44.440
你们下去

01:14:44.440 --> 01:14:45.440
可以自己去写一些

01:14:45.440 --> 01:14:46.440
这种垃圾巴刀的势力

01:14:46.440 --> 01:14:47.440
就继续玩一会

01:14:47.440 --> 01:14:48.440
咱们课堂上呢

01:14:48.440 --> 01:14:49.440
我现在

01:14:49.440 --> 01:14:50.440
我现在我都不知道

01:14:50.440 --> 01:14:51.440
它输出啥

01:14:51.440 --> 01:14:52.440
我只能一步一步分析

01:14:52.440 --> 01:14:53.440
但是我知道

01:14:53.440 --> 01:14:54.440
按照这个事件对立的

01:14:54.440 --> 01:14:55.440
方式分析出来

01:14:55.440 --> 01:14:56.440
一定是对的

01:14:56.440 --> 01:14:57.440
它不可能出现问题的

01:14:58.440 --> 01:14:59.440
不然介石它就

01:14:59.440 --> 01:15:00.440
不是这样

01:15:00.440 --> 01:15:01.440
介石它就

01:15:02.440 --> 01:15:03.440
又不知道怎么回事了

01:15:03.440 --> 01:15:04.440
它一定是这样子行的

01:15:04.440 --> 01:15:06.440
最开始一个拳句上下文

01:15:07.440 --> 01:15:08.440
然后呢

01:15:08.440 --> 01:15:09.440
接下来呢

01:15:09.440 --> 01:15:10.440
运行了一个set timeout

01:15:11.440 --> 01:15:13.440
零毫秒过后

01:15:13.440 --> 01:15:14.440
执行函数b对吧

01:15:14.440 --> 01:15:16.440
按照我们之前的经验

01:15:16.440 --> 01:15:17.440
是不是一个b跑过来

01:15:17.440 --> 01:15:18.440
然后零毫秒就跑过来

01:15:18.440 --> 01:15:19.440
对吧

01:15:19.440 --> 01:15:20.440
我就直接跑过来得了

01:15:20.440 --> 01:15:23.820
是不是函数b跑过来

01:15:23.820 --> 01:15:24.820
这个没问题吧

01:15:24.820 --> 01:15:25.820
跑到红队的

01:15:25.820 --> 01:15:26.820
它要去划拳的话

01:15:26.820 --> 01:15:27.820
就set timeout

01:15:27.820 --> 01:15:28.820
然后跑过来

01:15:28.820 --> 01:15:29.820
零毫秒它跑过来

01:15:29.820 --> 01:15:30.820
那我就直接跑过来得了

01:15:30.820 --> 01:15:31.820
那省略了

01:15:32.820 --> 01:15:33.820
就扔这

01:15:33.820 --> 01:15:34.820
等着

01:15:34.820 --> 01:15:35.820
然后拳句上文继续执行

01:15:35.820 --> 01:15:37.820
创建一个obj

01:15:37.820 --> 01:15:38.820
对吧

01:15:38.820 --> 01:15:39.820
等待

01:15:39.820 --> 01:15:40.820
等待什么呢

01:15:40.820 --> 01:15:41.820
等待initi

01:15:41.820 --> 01:15:42.820
要被设置

01:15:42.820 --> 01:15:43.820
被设置的时候

01:15:43.820 --> 01:15:44.820
运行函数a

01:15:44.820 --> 01:15:46.820
是不是有一个异步

01:15:46.820 --> 01:15:47.820
那么这个时候

01:15:47.820 --> 01:15:48.820
会发生什么事

01:15:48.820 --> 01:15:49.820
是不是这边

01:15:49.820 --> 01:15:50.820
有一个有一个县城

01:15:50.820 --> 01:15:51.820
对吧

01:15:51.820 --> 01:15:52.820
一个县城叫做

01:15:52.820 --> 01:15:53.820
事件监听县城

01:15:53.820 --> 01:15:55.820
等待div

01:15:55.820 --> 01:15:56.820
被改动

01:15:58.820 --> 01:15:59.820
对吧

01:15:59.820 --> 01:16:00.820
然后运行什么呢

01:16:00.820 --> 01:16:01.820
运行函数a

01:16:01.820 --> 01:16:02.820
现在没有改动吗

01:16:02.820 --> 01:16:03.820
没有改动

01:16:03.820 --> 01:16:04.820
没办法等着

01:16:04.820 --> 01:16:05.820
都要等着

01:16:05.820 --> 01:16:07.820
它都没有到事件对立

01:16:07.820 --> 01:16:09.820
然后呢

01:16:09.820 --> 01:16:10.820
接下来观察

01:16:10.820 --> 01:16:11.820
对吧

01:16:11.820 --> 01:16:12.820
观察

01:16:12.820 --> 01:16:13.820
好

01:16:13.820 --> 01:16:14.820
拳句上下文

01:16:14.820 --> 01:16:16.820
里边做了一件事

01:16:16.820 --> 01:16:17.820
拳句上下文

01:16:17.820 --> 01:16:18.820
把它的initi

01:16:18.820 --> 01:16:19.820
设为什么

01:16:19.820 --> 01:16:20.820
设为2的

01:16:20.820 --> 01:16:21.820
在这里

01:16:21.820 --> 01:16:22.820
在这里边

01:16:22.820 --> 01:16:24.820
把div的initi

01:16:24.820 --> 01:16:25.820
设为2

01:16:25.820 --> 01:16:26.820
改动了

01:16:26.820 --> 01:16:28.820
改动了过后

01:16:28.820 --> 01:16:29.820
这个a

01:16:29.820 --> 01:16:30.820
函数

01:16:31.820 --> 01:16:32.820
被推入到什么

01:16:32.820 --> 01:16:38.460
v对立

01:16:38.460 --> 01:16:39.460
因为我刚才说了

01:16:39.460 --> 01:16:40.460
没为什么

01:16:40.460 --> 01:16:41.460
它就是这样定的

01:16:41.460 --> 01:16:42.460
这个玩意儿的东西

01:16:42.460 --> 01:16:43.460
就在v对立

01:16:44.460 --> 01:16:45.460
好

01:16:45.460 --> 01:16:46.460
那么现在呢

01:16:46.460 --> 01:16:47.460
你看这个情况

01:16:47.460 --> 01:16:48.460
b是不是先来的

01:16:49.460 --> 01:16:50.460
他是不是插队了

01:16:50.460 --> 01:16:51.460
他插到v对立里边去了

01:16:51.460 --> 01:16:52.460
对吧

01:16:52.460 --> 01:16:53.460
b只能到红对立

01:16:53.460 --> 01:16:54.460
然后呢

01:16:54.460 --> 01:16:55.460
这边拳句上下文

01:16:55.460 --> 01:16:56.460
确实没有什么东西

01:16:56.460 --> 01:16:57.460
可做了

01:16:57.460 --> 01:16:58.460
休息了

01:16:58.460 --> 01:16:59.460
所以休息不要紧

01:16:59.460 --> 01:17:01.460
这个服务要一看

01:17:01.460 --> 01:17:02.460
我现在排了两列了

01:17:02.460 --> 01:17:03.460
对吧

01:17:03.460 --> 01:17:04.460
vip中p

01:17:04.460 --> 01:17:05.460
你先来

01:17:05.460 --> 01:17:07.460
运行函数a

01:17:07.460 --> 01:17:08.460
好

01:17:08.460 --> 01:17:10.460
运行函数a的时候

01:17:10.460 --> 01:17:11.460
在干嘛呀

01:17:11.460 --> 01:17:12.460
运行函数a的时候

01:17:12.460 --> 01:17:13.460
是不是又

01:17:13.460 --> 01:17:14.460
输出了一个什么

01:17:14.460 --> 01:17:15.460
输出了一个

01:17:15.460 --> 01:17:16.460
这个时候才开始输出

01:17:16.460 --> 01:17:18.460
输出了一个2

01:17:18.460 --> 01:17:19.460
对不对

01:17:19.460 --> 01:17:20.460
然后呢

01:17:20.460 --> 01:17:22.460
又加入了一个什么timeout

01:17:23.460 --> 01:17:24.460
又运行那个timeout

01:17:24.460 --> 01:17:25.460
timeout是不是又来

01:17:25.460 --> 01:17:26.460
横向跳跃

01:17:26.460 --> 01:17:27.460
对吧

01:17:27.460 --> 01:17:28.460
板腹横跳

01:17:28.460 --> 01:17:29.460
c跑过来对不对

01:17:29.460 --> 01:17:30.460
0毫秒过后

01:17:30.460 --> 01:17:31.460
加入到红对立

01:17:31.460 --> 01:17:32.460
c是不是跑这儿来了

01:17:35.800 --> 01:17:36.800
看到没

01:17:36.800 --> 01:17:37.800
好

01:17:37.800 --> 01:17:38.800
a是不是运行完了

01:17:38.800 --> 01:17:39.800
a运行完了

01:17:39.800 --> 01:17:40.800
b

01:17:40.800 --> 01:17:41.800
a还能干嘛呢

01:17:41.800 --> 01:17:42.800
没有什么事情可以干了

01:17:42.800 --> 01:17:43.800
a运行完了

01:17:43.800 --> 01:17:44.800
运行完了过后

01:17:44.800 --> 01:17:45.800
a出战

01:17:45.800 --> 01:17:46.800
好

01:17:46.800 --> 01:17:47.800
出战过后呢

01:17:47.800 --> 01:17:48.800
这边一看

01:17:48.800 --> 01:17:50.800
没啥事情可以做了呀

01:17:50.800 --> 01:17:51.800
没啥事情可以做了

01:17:51.800 --> 01:17:52.800
v对立没东西了

01:17:52.800 --> 01:17:53.800
然后红对立

01:17:53.800 --> 01:17:54.800
b拿过来

01:17:56.800 --> 01:17:57.800
好来执行b

01:17:57.800 --> 01:17:58.800
对吧

01:17:58.800 --> 01:17:59.800
执行b的过程中

01:17:59.800 --> 01:18:00.800
输出了一个什么

01:18:00.800 --> 01:18:01.800
1

01:18:02.800 --> 01:18:03.800
然后呢

01:18:03.800 --> 01:18:05.800
又把它的a就又改了

01:18:05.800 --> 01:18:06.800
对不对

01:18:06.800 --> 01:18:07.800
好这一改不要紧

01:18:07.800 --> 01:18:09.800
这一改是不是a又过来了

01:18:10.800 --> 01:18:12.800
这个c很可怜

01:18:12.800 --> 01:18:13.800
这个a又过来了

01:18:13.800 --> 01:18:19.630
好

01:18:19.630 --> 01:18:21.630
然后b输出了1对啊

01:18:21.630 --> 01:18:22.630
输出了1改了

01:18:22.630 --> 01:18:23.630
好

01:18:23.630 --> 01:18:24.630
那么b自行结束

01:18:24.630 --> 01:18:25.630
自行结束

01:18:25.630 --> 01:18:28.320
好

01:18:28.320 --> 01:18:29.320
接下来看

01:18:29.320 --> 01:18:30.320
一看

01:18:30.320 --> 01:18:31.320
c里还在等一等

01:18:31.320 --> 01:18:33.320
咱们的vip又来了

01:18:33.320 --> 01:18:35.320
执行a

01:18:35.320 --> 01:18:36.320
执行的过程

01:18:36.320 --> 01:18:38.320
就又来输出什么

01:18:38.320 --> 01:18:39.320
输出2

01:18:39.320 --> 01:18:40.320
然后掉一个c太冒水

01:18:40.320 --> 01:18:41.320
要等待3

01:18:41.320 --> 01:18:42.320
c对不对

01:18:42.320 --> 01:18:43.320
那又来一个横整

01:18:43.320 --> 01:18:44.320
反复横挑

01:18:44.320 --> 01:18:45.320
c跑过来

01:18:45.320 --> 01:18:47.320
0毫秒过后跑过来

01:18:47.320 --> 01:18:48.320
对不对

01:18:48.320 --> 01:18:49.320
好a自行结束

01:18:49.320 --> 01:18:51.320
然后剩下就是2个c了

01:18:51.320 --> 01:18:53.320
2个c是不是输出2个3

01:18:53.320 --> 01:18:54.320
对

01:18:54.320 --> 01:18:55.320
所以说最终输出以后

01:18:55.320 --> 01:18:56.320
是21233

01:18:56.320 --> 01:18:58.320
让大家分析出来没有

01:18:58.320 --> 01:18:59.320
非常好啊

01:18:59.320 --> 01:19:00.320
这个

01:19:00.320 --> 01:19:02.320
罗林同学啊非常好

01:19:02.320 --> 01:19:03.320
21233

01:19:03.320 --> 01:19:04.320
您按下来

01:19:04.320 --> 01:19:09.240
21233

01:19:09.240 --> 01:19:11.240
像这种东西肯定是不带错的

01:19:11.240 --> 01:19:12.240
为什么呢

01:19:12.240 --> 01:19:14.240
这就是介绍执行的原本的情况

01:19:14.240 --> 01:19:15.240
那么今天这个课

01:19:15.240 --> 01:19:16.240
去循环了

01:19:16.240 --> 01:19:17.240
大家有没有收获

01:19:17.240 --> 01:19:18.240
我看一下大家有没有收获

01:19:18.240 --> 01:19:19.240
有收获先为后宏

01:19:19.240 --> 01:19:20.240
对一定是的

01:19:20.240 --> 01:19:22.240
为对的就是vip

01:19:22.240 --> 01:19:23.240
有收获q和e

01:19:23.240 --> 01:19:25.240
大家有收获就好啊

01:19:25.240 --> 01:19:27.240
虽然说事件循环

01:19:27.240 --> 01:19:28.240
这一块呢

01:19:28.240 --> 01:19:29.240
你们以后去了node之后

01:19:29.240 --> 01:19:30.240
还有更加细节的东西

01:19:30.240 --> 01:19:32.240
因为node的那个事件循环

01:19:32.240 --> 01:19:33.240
有点恶心

01:19:33.240 --> 01:19:35.240
我当时我讲node的时候

01:19:35.240 --> 01:19:36.240
我讲了一节课

01:19:36.240 --> 01:19:37.240
还是两节课

01:19:37.240 --> 01:19:38.240
我才把个事件循环讲完

01:19:38.240 --> 01:19:39.240
真的有点恶心

01:19:39.240 --> 01:19:40.240
它里边的事件循环太多了

01:19:40.240 --> 01:19:42.240
太恐怖了

01:19:42.240 --> 01:19:44.240
流量器算是简单的了

01:19:44.240 --> 01:19:45.240
就先把流量器你认识好

01:19:45.240 --> 01:19:47.240
对你们以后认识node里边的事件循环

01:19:47.240 --> 01:19:49.240
有非常大的帮助

01:19:49.240 --> 01:19:50.240
OK

01:19:50.240 --> 01:19:51.240
那么

01:19:51.240 --> 01:19:52.240
今天我这里就差不多了

01:19:52.240 --> 01:19:53.240
我这里就差不多了

01:19:53.240 --> 01:19:54.240
时间也跌

01:19:54.240 --> 01:19:56.240
也跌得非常的准

01:19:56.240 --> 01:19:57.240
快九点半了

01:19:57.240 --> 01:20:01.960
一个setter mouse

01:20:01.960 --> 01:20:02.960
三秒入红

01:20:02.960 --> 01:20:03.960
一个setter mouse

01:20:03.960 --> 01:20:04.960
两秒入红

01:20:04.960 --> 01:20:05.960
先执行哪

01:20:05.960 --> 01:20:06.960
哪个先执行

01:20:06.960 --> 01:20:08.960
就看哪一个先入事件对立

01:20:10.960 --> 01:20:11.960
就看哪一个先入事件对立

01:20:11.960 --> 01:20:13.960
两秒钟可能要先入事件对立

01:20:13.960 --> 01:20:15.960
三秒钟是不是要多等一会

01:20:15.960 --> 01:20:18.960
哪个先入事件对立就先执行哪一个

01:20:19.960 --> 01:20:20.960
但是有的时候也不一定

01:20:20.960 --> 01:20:22.960
有的时候说不准的

01:20:22.960 --> 01:20:23.960
你不一定的

01:20:23.960 --> 01:20:25.960
比方说你像这种情况

01:20:25.960 --> 01:20:28.960
你这里前面一个setter mouse

01:20:28.960 --> 01:20:30.960
这里等待

01:20:32.960 --> 01:20:35.520
两毫秒

01:20:35.520 --> 01:20:39.800
这个地方

01:20:39.800 --> 01:20:41.800
这里等待三毫秒

01:20:41.800 --> 01:20:43.800
这里等待两毫秒

01:20:43.800 --> 01:20:46.800
但是中间的插入一些别的代码

01:20:46.800 --> 01:20:48.800
你这个时候就说不出

01:20:48.800 --> 01:20:49.800
就说不清楚了

01:20:49.800 --> 01:20:51.800
到底是这个函数先

01:20:51.800 --> 01:20:53.800
先到达那个

01:20:53.800 --> 01:20:55.800
到达那个就是时间

01:20:55.800 --> 01:20:57.800
还是他先到达时间

01:20:57.800 --> 01:20:58.800
说不准的

01:20:58.800 --> 01:20:59.800
因为中间的好秒

01:20:59.800 --> 01:21:00.800
是不是会刷一段时间

01:21:00.800 --> 01:21:01.800
对吧

01:21:01.800 --> 01:21:02.800
就是说不好了

01:21:02.800 --> 01:21:03.800
这个东西

01:21:03.800 --> 01:21:04.800
那就说不好了

01:21:04.800 --> 01:21:05.800
所以一当

01:21:05.800 --> 01:21:06.800
这种题了

01:21:06.800 --> 01:21:07.800
你不用去关心

01:21:07.800 --> 01:21:08.800
首先我跟大家说一点

01:21:08.800 --> 01:21:10.800
setter mouse里边的时间

01:21:10.800 --> 01:21:11.800
一定不能信任

01:21:11.800 --> 01:21:12.800
你不能绝对信任

01:21:12.800 --> 01:21:14.800
大概是那么多时间就行了

01:21:14.800 --> 01:21:16.800
你不能绝对信任他

01:21:16.800 --> 01:21:18.800
这是第一个点

01:21:18.800 --> 01:21:20.800
第二点是你们在练试的时候

01:21:20.800 --> 01:21:22.800
他一定是基本上是一个

01:21:22.800 --> 01:21:24.800
要么就相同的时间

01:21:24.800 --> 01:21:25.800
要么就是零

01:21:25.800 --> 01:21:26.800
零是居多的

01:21:26.800 --> 01:21:27.800
这个时间不写

01:21:27.800 --> 01:21:28.800
或者是零是居多的

01:21:28.800 --> 01:21:30.800
一般不会去考虑这种情况

01:21:30.800 --> 01:21:32.800
因为这种情况是没有答案的

01:21:32.800 --> 01:21:33.800
他不知道的

01:21:33.800 --> 01:21:34.800
不知道哪个先出来

01:21:34.800 --> 01:21:35.800
哪个后出来

01:21:35.800 --> 01:21:42.560
对他不会出这种题的

01:21:42.560 --> 01:21:43.560
OK

01:21:43.560 --> 01:21:45.560
那么今天

01:21:46.560 --> 01:21:47.560
那个时间是不是到了

01:21:47.560 --> 01:21:49.560
执行战才开始

01:21:49.560 --> 01:21:50.560
执行县城才开始

01:21:50.560 --> 01:21:51.560
不是的

01:21:51.560 --> 01:21:52.560
怎么听得到

01:21:52.560 --> 01:21:53.560
你还没听懂

01:21:53.560 --> 01:21:54.560
执行县城

01:21:54.560 --> 01:21:56.560
执行这个执行战

01:21:56.560 --> 01:21:57.560
执行县城要处理

01:21:57.560 --> 01:21:58.560
纪业时代

01:21:58.560 --> 01:22:00.560
他只能必须要在战里边执行

01:22:01.560 --> 01:22:03.560
他才不管你等了多少时间

01:22:03.560 --> 01:22:05.560
他不管的不管的

01:22:05.560 --> 01:22:06.560
等时间是谁在做

01:22:06.560 --> 01:22:07.560
是这个

01:22:07.560 --> 01:22:08.560
纪实县城在做

01:22:08.560 --> 01:22:09.560
等待的事情

01:22:09.560 --> 01:22:10.560
是纪实县城

01:22:10.560 --> 01:22:12.560
他通知纪实县城去等纪实

01:22:12.560 --> 01:22:13.560
他管的不管

01:22:13.560 --> 01:22:15.560
他只管从对战里面取东西

01:22:15.560 --> 01:22:16.560
输出

01:22:16.560 --> 01:22:17.560
运行

01:22:17.560 --> 01:22:18.560
你这边哪

01:22:18.560 --> 01:22:19.560
维队有就取

01:22:19.560 --> 01:22:20.560
维队的

01:22:20.560 --> 01:22:21.560
维队没有去

01:22:21.560 --> 01:22:22.560
就取了个红队的

01:22:22.560 --> 01:22:23.560
他只管从对战去

01:22:23.560 --> 01:22:24.560
按排队来取就行了

01:22:24.560 --> 01:22:25.560
他管不管的

01:22:25.560 --> 01:22:27.560
这个县城哪来的

01:22:27.560 --> 01:22:28.560
那么这个对战里边哪来的呢

01:22:28.560 --> 01:22:29.560
是其他县城

01:22:29.560 --> 01:22:30.560
因为其他县城

01:22:30.560 --> 01:22:32.560
他没有能力去执行戒士代码

01:22:32.560 --> 01:22:33.560
执行戒士代码

01:22:33.560 --> 01:22:35.560
只有执行县城有能力

01:22:35.560 --> 01:22:36.560
其他县城是没有能力

01:22:36.560 --> 01:22:37.560
执行戒士代码的

01:22:37.560 --> 01:22:38.560
但是他又不能去干扰

01:22:38.560 --> 01:22:39.560
戒士代码执行

01:22:39.560 --> 01:22:40.560
你不能说

01:22:40.560 --> 01:22:42.560
他正在运行一个函数

01:22:42.560 --> 01:22:44.560
强行让他去执行这个

01:22:44.560 --> 01:22:45.560
他就有侵入性

01:22:45.560 --> 01:22:46.560
他会找对战的

01:22:46.560 --> 01:22:49.560
这边的程序执行是一个灾难

01:22:49.560 --> 01:22:51.560
所以说他一定是

01:22:51.560 --> 01:22:53.560
先把这个要等待的函数

01:22:53.560 --> 01:22:55.560
推入到一个对战里面排队

01:22:55.560 --> 01:22:56.560
等你空了过后

01:22:56.560 --> 01:22:57.560
他就会从这边来取

01:22:57.560 --> 01:22:58.560
对吧

01:22:58.560 --> 01:22:59.560
是这么的意思

01:23:00.560 --> 01:23:02.560
那么还要设计

01:23:02.560 --> 01:23:03.560
另外一句话了

01:23:03.560 --> 01:23:04.560
这句话呢

01:23:04.560 --> 01:23:05.560
以前我也是

01:23:05.560 --> 01:23:07.560
跟普遍同学们一直在说的

01:23:07.560 --> 01:23:09.560
在这句话对不对

01:23:09.560 --> 01:23:14.640
在戒士中

01:23:14.640 --> 01:23:19.020
不可能出现

01:23:19.020 --> 01:23:21.020
一个函数执行到一半

01:23:21.020 --> 01:23:23.020
转而去执行起

01:23:23.020 --> 01:23:24.020
什么意思呢

01:23:24.020 --> 01:23:26.020
先把意识说清楚了

01:23:26.020 --> 01:23:28.020
我的意思就是说

01:23:28.020 --> 01:23:29.020
在戒士中

01:23:29.020 --> 01:23:32.020
不可能会出现这种情况

01:23:32.020 --> 01:23:33.020
有没有可能

01:23:33.020 --> 01:23:35.020
就是你觉得这句话对不对

01:23:35.020 --> 01:23:37.720
我就随便写

01:23:37.720 --> 01:23:41.800
加写两个代码吧

01:23:41.800 --> 01:23:42.800
我就问你

01:23:42.800 --> 01:23:43.800
戒士里边有没有可能

01:23:43.800 --> 01:23:44.800
出现这种情况

01:23:44.800 --> 01:23:45.800
这一句执行完了过后

01:23:45.800 --> 01:23:47.800
他可能没有执行这句话

01:23:47.800 --> 01:23:49.800
可能执行别的东西去了

01:23:49.800 --> 01:23:52.800
有没有可能出现这种情况

01:23:52.800 --> 01:23:54.800
在戒士中有没有可能出现这种情况

01:23:54.800 --> 01:23:55.800
这句话执行完了过后

01:23:55.800 --> 01:23:56.800
没有执行下一句

01:23:56.800 --> 01:23:57.800
他执行别的地方玩下去了

01:23:57.800 --> 01:23:58.800
有没有可能

01:23:58.800 --> 01:24:03.580
是绝无可能的

01:24:03.580 --> 01:24:05.580
这就是一步带来的好处

01:24:05.580 --> 01:24:06.580
他一个函数

01:24:06.580 --> 01:24:08.580
一定是完完执行完

01:24:08.580 --> 01:24:09.580
你看这边执行站吧

01:24:09.580 --> 01:24:11.580
不然讲了半天白讲了

01:24:11.580 --> 01:24:12.580
他所以一个函数

01:24:12.580 --> 01:24:13.580
一定要执行完了过后

01:24:13.580 --> 01:24:14.580
出站了过后

01:24:14.580 --> 01:24:15.580
他有空闲了

01:24:15.580 --> 01:24:16.580
他去做其他的事情

01:24:16.580 --> 01:24:17.580
对吧

01:24:17.580 --> 01:24:19.580
他一定是完完执行完了过后

01:24:19.580 --> 01:24:20.580
这一样

01:24:20.580 --> 01:24:22.580
只是给大家带来了很

01:24:22.580 --> 01:24:24.580
减轻了很多的心智负担

01:24:24.580 --> 01:24:26.580
以前你在用什么夹吧

01:24:26.580 --> 01:24:28.580
其他后端语言去开发

01:24:28.580 --> 01:24:29.580
多线场的时候

01:24:29.580 --> 01:24:30.580
也会烦死的

01:24:30.580 --> 01:24:32.580
你每一句代码都不能信任的

01:24:32.580 --> 01:24:33.580
因为这句代码执行

01:24:33.580 --> 01:24:34.580
我们把它叫做

01:24:34.580 --> 01:24:35.580
现成安全

01:24:35.580 --> 01:24:36.580
对不对

01:24:36.580 --> 01:24:37.580
这句代码执行完了过后

01:24:37.580 --> 01:24:38.580
我老实在想

01:24:38.580 --> 01:24:39.580
有没有可能

01:24:39.580 --> 01:24:41.580
会转而去执行其他现成

01:24:41.580 --> 01:24:42.580
有没有可能会转而

01:24:42.580 --> 01:24:44.580
对后边的代码造成影响

01:24:44.580 --> 01:24:46.580
在戒士里边绝不可能

01:24:46.580 --> 01:24:47.580
执行完了过后

01:24:47.580 --> 01:24:48.580
再执行下一个

01:24:48.580 --> 01:24:50.580
它是以含书为单位

01:24:50.580 --> 01:24:51.580
调读人

01:24:51.580 --> 01:24:52.580
没意思

