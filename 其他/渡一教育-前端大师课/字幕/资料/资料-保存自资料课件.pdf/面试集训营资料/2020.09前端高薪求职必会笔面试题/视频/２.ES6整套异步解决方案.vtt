WEBVTT

00:00.000 --> 00:03.000
呃 这几天的面试 这个笔面试题啊

00:03.000 --> 00:07.000
其实我在挑选的时候呢 也是有所考虑的

00:07.000 --> 00:13.000
因为像我们明天的模块画 明天模块画的话 比较相对比较独立一点啊

00:13.000 --> 00:18.000
然后就是像 呃 后天 后天的那个

00:19.000 --> 00:24.000
ATV协议 呃 可能会用到咱们今天的知识啊

00:24.000 --> 00:27.000
然后今天的东西呢 又会用到左上的知识啊

00:27.000 --> 00:31.000
会 虽然说相对独立 也会稍微有点联系了

00:31.000 --> 00:36.000
昨天我们讲了那个 讲那个就是世界循环

00:36.000 --> 00:43.020
世界循环是作为介石基础啊 一个 一个

00:43.020 --> 00:46.020
重点的考 重点的面试点 介石基础

00:46.020 --> 00:49.020
这叫介石基础呢 就是介石语言本身

00:49.020 --> 00:54.020
呃 除了世界循环之外呢 大家下来过后一定要还要去深入的去研究一下这个

00:54.020 --> 00:57.020
呃 原形和原形链

00:57.020 --> 01:03.290
因为五天的时间毕竟有限啊 我没有办法面面俱到

01:03.290 --> 01:07.290
呃 还有就是 作用预订

01:07.290 --> 01:11.290
当然 币包 里面评说的币包啊 就是在作用预订里边

01:11.290 --> 01:15.290
就把这些东西要好好地去研究一下啊 这些东西都是在

01:15.290 --> 01:18.290
面试的时候 非常容易考到的点啊

01:18.290 --> 01:21.290
我们昨天当经出来一个世界循环来讲 讲完了之后呢

01:21.290 --> 01:25.290
今天的东西就比较 呃 就好理解了 其实同学们有的时候

01:26.290 --> 01:30.290
学某一些知识啊 觉得 不是很好学

01:30.290 --> 01:33.290
可能觉得比较难 呃 其实根本的原因呢

01:33.290 --> 01:38.290
在于 你们可能欠缺了一些前置知识

01:38.290 --> 01:42.290
比方说 你在学习Promise的时候

01:42.290 --> 01:46.290
我相信啊 有些同学应该知道 之前已经学过这个Promise了

01:46.290 --> 01:49.290
至少看过了 觉得它比较难的原因呢

01:49.290 --> 01:53.290
是因为你很多概念没有理清楚 你理清楚这些概念的话

01:54.290 --> 01:56.290
基本上就没有什么难度了

01:56.290 --> 02:00.290
其实根本的原因是没有遇到我 你遇到我 你遭会了

02:00.290 --> 02:03.290
呃 这 今天的这一个半小时呢

02:03.290 --> 02:06.290
是咱们在这个后期的ES6部分啊

02:06.290 --> 02:09.290
因为这个Promise是在ES6部分

02:09.290 --> 02:12.290
ES6部分呢 我当时是录了一个章节

02:12.290 --> 02:15.290
一共加起来 包括这个熟悉Promise

02:15.290 --> 02:17.290
一共加起来有史乃杰克吧

02:17.290 --> 02:20.290
从事件学习开始讲 然后呢一直讲到熟悉

02:20.290 --> 02:23.290
最后讲到ES7的而深刻的位置

02:23.290 --> 02:25.290
那么今天只有一个半小时怎么办呢

02:25.290 --> 02:28.290
我就把最基本的东西 最核心的东西给大家讲出来

02:28.290 --> 02:30.290
昨天不是讲了事件循环吗

02:30.290 --> 02:32.290
今天咱们把这两个东西搞定

02:32.290 --> 02:35.290
主要是搞定这两个东西 这三个

02:35.290 --> 02:38.290
这三个东西呢 一个半小时差不多

02:38.290 --> 02:40.290
后边呢 还有一些别的东西啊

02:40.290 --> 02:42.290
一些别的东西的话 我看一下有没有时间吗

02:42.290 --> 02:45.290
有时间的话 就建议给大家讲

02:45.290 --> 02:48.290
好 这是这一部分啊

02:48.290 --> 02:51.290
首先我们在讲这个Promise之前呢

02:51.290 --> 02:55.290
首先要补充一个ES6的知识 叫做箭头函数

02:55.290 --> 02:58.290
因为这个箭头函数呢 咱们之后的代码里边

02:58.290 --> 03:00.290
甚至面试体里边都可能会遇到啊

03:00.290 --> 03:01.290
所以给大家讲一讲

03:01.290 --> 03:03.290
这个箭头函数我没办法讲太多

03:03.290 --> 03:05.290
就给它提这么几句

03:05.290 --> 03:08.290
我们需要用到的 今天需要用到的东西

03:08.290 --> 03:09.290
箭头函数

03:09.290 --> 03:13.240
好 看一下吧

03:13.240 --> 03:16.240
箭头函数呢 就是我们平时写函数的时候

03:16.240 --> 03:19.240
有的时候呢 会写一些函数表达式

03:20.240 --> 03:24.580
什么情况下会写函数表达式

03:24.580 --> 03:26.580
这种情况

03:26.580 --> 03:28.580
这就是函数表达式

03:28.580 --> 03:31.580
求和 两个函数我拿过来

03:31.580 --> 03:34.580
返回一个A加B

03:34.580 --> 03:36.580
对不对 还有什么情况呢

03:36.580 --> 03:39.580
还有给一个动物元素来一个Unclean

03:39.580 --> 03:43.020
Unclean 注册连基事件

03:43.020 --> 03:46.020
这个时候是不是也是一个

03:46.020 --> 03:47.020
就是函数表达式

03:47.020 --> 03:51.020
还有什么呢 还有一个set timeout

03:51.020 --> 03:52.020
对吧 这个时候是不是也是表达式

03:52.020 --> 03:56.020
函数可以写匿名函数的地方

03:56.020 --> 03:59.020
都是属于函数表达式

03:59.020 --> 04:00.020
那么在ES6里面呢

04:00.020 --> 04:03.020
为了减化我们的函数书写

04:03.020 --> 04:05.020
当然还有一些别的目的

04:05.020 --> 04:06.020
其中一个目的呢

04:06.020 --> 04:08.020
是为了减化我们的函数书写呢

04:08.020 --> 04:10.020
给我们除了这个箭头函数

04:10.020 --> 04:12.020
箭头函数其实非常简单

04:12.020 --> 04:13.020
怎么做呢

04:13.020 --> 04:16.020
第一步 方形的关键字去掉

04:16.020 --> 04:18.020
第二步呢 在参数和函数体之间

04:18.020 --> 04:19.020
加个箭头

04:19.020 --> 04:21.020
这就是箭头函数

04:21.020 --> 04:22.020
是不是特别简单

04:22.020 --> 04:24.020
就这么回事

04:24.020 --> 04:25.020
但有的时候呢

04:25.020 --> 04:26.020
箭头函数呢

04:26.020 --> 04:27.020
还有一些简写

04:27.020 --> 04:28.020
大家要看得懂啊

04:28.020 --> 04:29.020
比方说

04:29.020 --> 04:31.020
我们有这么一个函数

04:31.020 --> 04:32.020
但效果是完全一样的

04:32.020 --> 04:33.020
效果是完全一样的

04:33.020 --> 04:34.020
我们输出一下

04:34.020 --> 04:36.020
1 2

04:36.020 --> 04:38.020
运行

04:38.020 --> 04:40.020
3 对不对

04:40.020 --> 04:41.020
没问题

04:41.020 --> 04:43.020
就是说有的时候呢

04:43.020 --> 04:45.020
如果说你的反回语句

04:45.020 --> 04:47.020
只有一条

04:47.020 --> 04:49.020
只有一条唯一的反回语句

04:49.020 --> 04:50.020
没有其他语句的

04:50.020 --> 04:51.020
那么这个时候呢

04:51.020 --> 04:52.020
你可以这样子去

04:52.020 --> 04:54.020
你把这个return去掉

04:54.020 --> 04:56.020
把这个左大货号去掉

04:56.020 --> 04:58.020
右边的大货号去掉

04:58.020 --> 05:00.020
你可以减一些成这个样子

05:00.020 --> 05:01.020
那么这个样子

05:01.020 --> 05:02.020
其实很好理解

05:02.020 --> 05:03.020
怎么意思呢

05:03.020 --> 05:05.020
你给它一个a和b

05:05.020 --> 05:08.020
它就给你一个a加b

05:08.020 --> 05:09.020
就这么简单

05:09.020 --> 05:10.020
那我给它一个e和

05:10.020 --> 05:11.020
它就给我一个3

05:11.020 --> 05:13.020
就非常简单啊

05:13.020 --> 05:15.020
如果说你的参数呢

05:15.020 --> 05:16.020
比方说

05:16.020 --> 05:18.020
我们这里一个大多函数

05:18.020 --> 05:20.020
它是把一个数字乘以2

05:20.020 --> 05:23.020
比方说一个参数n

05:23.020 --> 05:24.020
得到结果呢

05:24.020 --> 05:25.020
是n乘以2

05:25.020 --> 05:26.020
能看懂吗

05:26.020 --> 05:27.020
我给它一个n

05:27.020 --> 05:28.020
它反回给我一个n乘以2

05:28.020 --> 05:29.020
那么比方说

05:29.020 --> 05:30.020
我这里呢

05:30.020 --> 05:31.020
给它写个double

05:31.020 --> 05:33.020
3

05:33.020 --> 05:34.020
运行

05:34.020 --> 05:35.020
准6 对不对

05:35.020 --> 05:37.020
那么这种情况下呢

05:37.020 --> 05:38.020
如果说只有一个参数

05:38.020 --> 05:39.020
实际上是

05:39.020 --> 05:40.020
你可以省略

05:40.020 --> 05:41.020
这个小货号的

05:41.020 --> 05:42.020
可以省略的

05:42.020 --> 05:43.020
不过呢

05:43.020 --> 05:44.020
你们将来

05:44.020 --> 05:45.020
在很多公司里面

05:45.020 --> 05:47.020
它不允许你省略小货号

05:47.020 --> 05:49.020
就涉及到代码风格的问题了

05:49.020 --> 05:51.020
可以省略也可以不省略

05:51.020 --> 05:52.020
唯一的差数的话

05:52.020 --> 05:53.020
是可以省略的

05:53.020 --> 05:55.020
这涉及到一个代码风格的问题

05:55.020 --> 05:57.020
到底应该省略还是不省略呢

05:57.020 --> 05:58.020
还包括

05:58.020 --> 05:59.020
每一句话

05:59.020 --> 06:00.020
后面到底应该加分号还是不加呢

06:00.020 --> 06:01.020
对吧

06:01.020 --> 06:02.020
涉及代码风格的问题

06:02.020 --> 06:03.020
你们以后

06:03.020 --> 06:04.020
到公司里面

06:04.020 --> 06:05.020
一般会通过一个工具

06:05.020 --> 06:06.020
叫做esnint

06:06.020 --> 06:08.020
你们将来一定会学习的

06:08.020 --> 06:10.020
每个人学全程都会学习的

06:10.020 --> 06:11.020
esnint

06:11.020 --> 06:12.020
它会检查代码风格

06:12.020 --> 06:14.020
是不是跟公司的要求一致

06:14.020 --> 06:15.020
我这里呢

06:15.020 --> 06:16.020
因为我这个bscode里边

06:16.020 --> 06:17.020
设计的风格

06:17.020 --> 06:19.020
就是要加小货号的

06:19.020 --> 06:20.020
所以说我这里保存

06:20.020 --> 06:21.020
它一格式的话

06:21.020 --> 06:22.020
可以发小货号给我加上了

06:22.020 --> 06:24.020
实际上是可以不要的

06:24.020 --> 06:25.020
一样的道理

06:25.020 --> 06:28.020
这是建筒函数给大家补充一下

06:28.020 --> 06:31.020
这一块有没什么问题

06:31.020 --> 06:32.020
关于建筒函数

06:32.020 --> 06:33.020
还有些别的知识

06:33.020 --> 06:34.020
还有一些

06:34.020 --> 06:35.020
包括z

06:35.020 --> 06:37.020
还包括建筒函数

06:37.020 --> 06:38.020
寫到对象里边

06:38.020 --> 06:39.020
又是怎么回事

06:39.020 --> 06:40.020
还有一些别的东西

06:40.020 --> 06:41.020
没问题

06:41.020 --> 06:42.020
QQ1

06:42.020 --> 06:43.020
别的东西的话

06:43.020 --> 06:45.020
我们今天就不去车远了

06:45.020 --> 06:47.020
我们开始来学习

06:47.020 --> 06:50.020
es6的异部处理

06:50.020 --> 06:52.020
我们首先学一个知识之权

06:52.020 --> 06:53.020
你要知道

06:53.020 --> 06:55.020
这个东西到底是怎么来的

06:55.020 --> 06:59.420
世界上的所有的技术

06:59.420 --> 07:00.420
每一个技术点

07:00.420 --> 07:01.420
每一个知识点

07:01.420 --> 07:03.420
它出现在有个世界上

07:03.420 --> 07:04.420
它一定有它的原因

07:04.420 --> 07:05.420
有它的背景

07:05.420 --> 07:06.420
它一定是为了

07:06.420 --> 07:08.420
解决某一方面的问题

07:08.420 --> 07:11.420
那么在这个Promise出来之前

07:11.420 --> 07:15.420
它一定是为了解决某一方面的问题

07:15.420 --> 07:17.420
Promise出来之前

07:17.420 --> 07:19.420
有什么样的问题呢

07:19.420 --> 07:20.420
我们昨天学习过

07:20.420 --> 07:22.420
es6它是基于一个异部的语言

07:22.420 --> 07:23.420
对吧

07:23.420 --> 07:25.420
昨天我们不再重复了

07:25.420 --> 07:26.420
那么

07:26.420 --> 07:28.420
昨天的东西

07:28.420 --> 07:30.420
我们只是从原理上

07:30.420 --> 07:32.420
从概念上去讲

07:32.420 --> 07:34.420
es6的异部到底是怎么回事

07:34.420 --> 07:35.420
无非就是通知其他县城

07:35.420 --> 07:37.420
然后自己不管了

07:37.420 --> 07:39.420
一会儿其他县城做完了过后

07:39.420 --> 07:40.420
推到世界对列

07:40.420 --> 07:42.420
然后从对列里面取出来执行

07:42.420 --> 07:44.420
这是它的异部方式

07:44.420 --> 07:46.420
具体到代码里面

07:46.420 --> 07:48.420
就会发现了有一些问题

07:48.420 --> 07:50.420
这个模式本身是没问题的

07:50.420 --> 07:51.420
只要到了代码里面

07:51.420 --> 07:52.420
我们书写的时候

07:52.420 --> 07:53.420
发生了一些问题

07:53.420 --> 07:54.420
有什么样的问题

07:54.420 --> 07:56.420
大家看下面这个代码

07:56.420 --> 07:57.420
下面这个代码

07:57.420 --> 07:58.420
我全是异部的

07:58.420 --> 07:59.420
你看没

07:59.420 --> 08:01.420
出车的一个点击世界

08:01.420 --> 08:03.420
我给它传了一个回调函数

08:03.420 --> 08:04.420
对吧

08:04.420 --> 08:05.420
还有第三个差数

08:05.420 --> 08:07.420
我这里没有配置

08:07.420 --> 08:08.420
第三个差数知道吧

08:08.420 --> 08:09.420
有些选项

08:09.420 --> 08:10.420
我这里没配置

08:10.420 --> 08:12.420
那么这个回调函数

08:12.420 --> 08:14.420
是对异部执行的

08:14.420 --> 08:16.420
它要将来点击了之后

08:16.420 --> 08:18.420
才会执行这个回调函数

08:18.420 --> 08:19.420
那么这个回调函数

08:19.420 --> 08:21.420
是作为第二个差数传辑的

08:21.420 --> 08:24.420
而且函数是有一个差数的

08:24.420 --> 08:26.420
好 咱们再看这个

08:26.420 --> 08:28.420
我们驻车世界的另一种方式

08:28.420 --> 08:30.420
是使用unclean

08:30.420 --> 08:32.420
un什么世界名

08:32.420 --> 08:33.420
那么这种方式

08:33.420 --> 08:35.420
它就不是调用函数了

08:35.420 --> 08:37.420
而是给一个属性复制

08:37.420 --> 08:38.420
复制什么

08:38.420 --> 08:39.420
复制一个回调函数

08:39.420 --> 08:40.420
这个回调函数

08:40.420 --> 08:41.420
仍然是异部的

08:41.420 --> 08:43.420
它是要将来点击了之后

08:43.420 --> 08:44.420
才会执行

08:44.420 --> 08:45.420
那么这个时候

08:45.420 --> 08:47.420
它就不是函数的方式了

08:47.420 --> 08:49.420
然后再看下面这个

08:49.420 --> 08:50.420
下面这个大家没有学习过

08:50.420 --> 08:51.420
你们将来学习

08:51.420 --> 08:52.420
漏的过后呢

08:52.420 --> 08:53.420
你们会接触

08:53.420 --> 08:54.420
什么意思呢

08:54.420 --> 08:55.420
就在漏的环境里边

08:55.420 --> 08:58.420
我要读取一个文件

08:58.420 --> 08:59.420
浏览器里边

08:59.420 --> 09:00.420
是不是没法读文件

09:00.420 --> 09:01.420
漏的里边可以

09:01.420 --> 09:02.420
读取一个文件

09:02.420 --> 09:03.420
那么读文件

09:03.420 --> 09:04.420
需要一段时间

09:04.420 --> 09:06.420
它的时间比较长

09:06.420 --> 09:08.420
像什么读文件

09:08.420 --> 09:10.420
像什么发送网络请求

09:10.420 --> 09:11.420
这些东西呢

09:11.420 --> 09:14.420
统统属于IO操作

09:14.420 --> 09:16.420
Input Output

09:16.420 --> 09:18.420
所以IO操作

09:18.420 --> 09:20.420
IO操作的时间

09:20.420 --> 09:22.420
要远远大于

09:22.420 --> 09:25.420
以代码的执行时间

09:25.420 --> 09:26.420
代码的执行时间

09:26.420 --> 09:27.420
代码就是护循环

09:27.420 --> 09:28.420
一个判断

09:28.420 --> 09:29.420
一个变量

09:29.420 --> 09:31.420
这些代码的执行时间

09:31.420 --> 09:33.420
IO有意是要跟网卡

09:33.420 --> 09:35.420
或者是硬盘打交道的

09:35.420 --> 09:37.420
所以它的时间比较长

09:37.420 --> 09:38.420
因为我们知道

09:38.420 --> 09:39.420
内存的速度很快

09:39.420 --> 09:42.420
网络和硬盘的速度很慢

09:42.420 --> 09:43.420
那么这个数量级

09:43.420 --> 09:45.420
它是有数量级差异的

09:45.420 --> 09:47.420
不是说差几倍的问题

09:47.420 --> 09:49.420
是几千倍的问题

09:49.420 --> 09:50.420
你的代码的执行速度

09:50.420 --> 09:52.420
是大秒级别的

09:52.420 --> 09:53.420
而这个IO的速度

09:53.420 --> 09:55.420
是毫秒级的

09:55.420 --> 09:57.420
所以它是差距很大的

09:57.420 --> 09:58.420
那么这个时候

09:58.420 --> 09:59.420
你读文件

09:59.420 --> 10:00.420
我不能在那啥等的

10:00.420 --> 10:01.420
等你文件读出来

10:01.420 --> 10:02.420
所以说我这里也是一步

10:02.420 --> 10:03.420
那么这个方式

10:03.420 --> 10:06.420
是传入一个文件路径

10:06.420 --> 10:08.420
然后当文件读出来了之后

10:08.420 --> 10:10.420
它给你调用一个回调函数

10:10.420 --> 10:11.420
这个回调函数

10:11.420 --> 10:12.420
是不是一步调用的

10:12.420 --> 10:13.420
那么这个回调函数

10:13.420 --> 10:14.420
有两个参数

10:14.420 --> 10:15.420
第一个参数是错误

10:15.420 --> 10:18.420
第二个参数是文件的内容

10:18.420 --> 10:20.420
你看我现在

10:20.420 --> 10:21.420
这个不是终点

10:21.420 --> 10:23.420
终点你看这些回调

10:23.420 --> 10:25.420
这种千奇百怪

10:25.420 --> 10:26.420
你们将来还会接触

10:26.420 --> 10:27.420
什么set them out

10:27.420 --> 10:28.420
像set them out

10:28.420 --> 10:29.420
你们肯定学习过的

10:29.420 --> 10:31.420
那里边的回调就没有参数

10:31.420 --> 10:32.420
就是我们有的回调

10:32.420 --> 10:33.420
有一个参数

10:33.420 --> 10:35.420
有的回调有两个参数

10:35.420 --> 10:36.420
有的回调

10:36.420 --> 10:38.420
是放到别的函数里边的

10:38.420 --> 10:40.420
有的回调是作为属性传辑的

10:40.420 --> 10:42.420
有的回调是最后一个参数

10:42.420 --> 10:45.420
有的回调是第二个参数

10:45.420 --> 10:46.420
搞不清楚

10:46.420 --> 10:47.420
这个回调

10:47.420 --> 10:49.420
整个虽然说回调

10:49.420 --> 10:51.420
用来实现一步没问题

10:51.420 --> 10:53.420
但是个回调是没有标准的

10:53.420 --> 10:55.420
这会造成一个什么问题呢

10:55.420 --> 10:56.420
第一个问题就是

10:56.420 --> 10:57.420
没有统一的标准

10:57.420 --> 10:58.420
一人一套

10:58.420 --> 11:00.420
这个还是我们那个

11:00.420 --> 11:02.420
你们用它

11:02.420 --> 11:04.420
输出本来的API

11:04.420 --> 11:05.420
数学的回调

11:05.420 --> 11:06.420
对吧

11:06.420 --> 11:07.420
将来我们还可以自己封装一些

11:07.420 --> 11:09.420
比方说你们以后学了阿迦克斯

11:09.420 --> 11:11.420
还可以自己封装一些

11:11.420 --> 11:13.420
具有回调的函数

11:13.420 --> 11:14.420
那么这种封装

11:14.420 --> 11:15.420
就是一个人的一个样子

11:15.420 --> 11:17.420
它没有一套统一的标准

11:17.420 --> 11:19.420
那么不同的代码之间

11:19.420 --> 11:22.420
要协助就比较困难

11:22.420 --> 11:23.420
第二个问题

11:23.420 --> 11:25.420
是容易陷入回调地域

11:25.420 --> 11:27.420
给大家看了一个例子

11:27.420 --> 11:28.420
这个例子

11:28.420 --> 11:30.420
就是用我们昨天那个例子

11:30.420 --> 11:32.420
我们现在要去发送一个网络连接

11:32.420 --> 11:34.420
比方说你给我一个网络的例子

11:34.420 --> 11:36.420
然后我去连接它

11:36.420 --> 11:37.420
得到网络的数据

11:37.420 --> 11:39.420
那么它肯定是一个异部的

11:39.420 --> 11:40.420
假设有这么一个函数

11:40.420 --> 11:41.420
实际上是没有的

11:41.420 --> 11:42.420
假设有这么一个函数

11:42.420 --> 11:44.420
那么我们如果说

11:44.420 --> 11:45.420
有这么样的一个需求

11:45.420 --> 11:47.420
一次发送

11:47.420 --> 11:49.420
七次网络的请求

11:49.420 --> 11:50.420
什么叫一次发送

11:50.420 --> 11:51.420
就第一次请求

11:51.420 --> 11:52.420
到了服务器

11:52.420 --> 11:54.420
服务器给过了一个结果

11:54.420 --> 11:55.420
那么我拿到这个结果之后

11:55.420 --> 11:57.420
我再去发第二个请求

11:57.420 --> 11:58.420
我的代码

11:58.420 --> 12:00.420
就很有可能会写成这个样子

12:01.420 --> 12:04.420
请求

12:04.420 --> 12:06.420
拿到结果

12:06.420 --> 12:08.420
拿到结果之后

12:08.420 --> 12:09.420
没完啊

12:09.420 --> 12:10.420
这是第一次请求完了

12:10.420 --> 12:11.420
我拿到这个结果之后

12:11.420 --> 12:12.420
做一些自己的事

12:12.420 --> 12:13.420
做完了过后

12:13.420 --> 12:15.420
我还要做第二次请求

12:15.420 --> 12:17.420
又拿到结果

12:17.420 --> 12:18.420
然后做一些自己的事

12:18.420 --> 12:19.420
第三次请求

12:19.420 --> 12:20.420
一次内推

12:20.420 --> 12:21.420
你看代码就变成这个样子了

12:21.420 --> 12:23.420
这就是毁掉地球

12:23.420 --> 12:24.420
就是一个毁掉里面

12:24.420 --> 12:26.420
千套另一个毁掉

12:26.420 --> 12:27.420
另一个毁掉里面

12:27.420 --> 12:28.420
继续千套毁掉

12:28.420 --> 12:29.420
变成这个样子

12:29.420 --> 12:30.420
那么这种代码

12:30.420 --> 12:32.420
是极其丑陋和难看的

12:32.420 --> 12:34.420
而且特别不好维护

12:34.420 --> 12:35.420
像中上所述啊

12:35.420 --> 12:36.420
这些问题呢

12:36.420 --> 12:38.420
我们都需要解决

12:38.420 --> 12:39.420
有的人说

12:39.420 --> 12:40.420
到我这个

12:40.420 --> 12:42.420
为什么不能平行写呢

12:42.420 --> 12:43.420
为什么不能这样子写呢

12:43.420 --> 12:44.420
大家看一下啊

12:44.420 --> 12:45.420
能不能这样子写

12:45.420 --> 12:49.110
就刚才一个地址啊

12:49.110 --> 12:53.000
地址一

12:54.000 --> 12:56.000
就地址一啊

12:56.000 --> 12:57.000
然后呢

12:57.000 --> 12:58.000
地址二

12:58.000 --> 12:59.000
这样子写

12:59.000 --> 13:03.400
能不能满足要求

13:03.400 --> 13:05.400
为什么

13:05.400 --> 13:06.400
不写了啊

13:06.400 --> 13:08.400
这样子写能不能满足要求

13:08.400 --> 13:12.860
直接听课啊

13:12.860 --> 13:13.860
行不行

13:13.860 --> 13:21.430
为什么不能呢

13:21.430 --> 13:23.430
这样写为什么不能呢

13:23.430 --> 13:24.430
拿不到数据

13:24.430 --> 13:25.430
能拿到不会啊

13:25.430 --> 13:26.430
拿到不会

13:26.430 --> 13:27.430
能拿到数据啊

13:27.430 --> 13:29.430
当然没有这个函数啊

13:29.430 --> 13:31.430
就假设有这个函数

13:31.430 --> 13:33.430
感觉上不能

13:33.430 --> 13:35.430
要好好看体啊

13:35.430 --> 13:37.430
什么叫一次发送

13:37.430 --> 13:39.430
什么叫一次发送

13:39.430 --> 13:41.430
就是第一次拿到结果之后

13:41.430 --> 13:43.430
再发送第二次请求

13:43.430 --> 13:45.430
第二次请求拿到结果之后

13:45.430 --> 13:46.430
再发送第三次请求

13:46.430 --> 13:48.430
这要一次发送

13:48.430 --> 13:49.430
如果说你这样子写的话

13:49.430 --> 13:51.430
就是同时发送的

13:51.430 --> 13:52.430
因为我们知道

13:52.430 --> 13:53.430
网络通信是需要时间的

13:53.430 --> 13:54.430
对吧

13:54.430 --> 13:56.430
我们昨天学过那个

13:56.430 --> 13:57.430
事件群怀

13:57.430 --> 13:58.430
你看啊

13:58.430 --> 14:00.430
如果说这样子写

14:00.430 --> 14:01.430
那么第一次对吧

14:01.430 --> 14:02.430
调用函数

14:02.430 --> 14:04.430
请求地址一

14:04.430 --> 14:05.430
那么这个函数是要等吗

14:05.430 --> 14:07.430
不等吧

14:07.430 --> 14:08.430
是不是

14:08.430 --> 14:09.430
通知API

14:09.430 --> 14:10.430
你去请求吧

14:10.430 --> 14:11.430
我不管了

14:11.430 --> 14:12.430
你拿到结果过后告诉我

14:12.430 --> 14:13.430
我运行我的回调函数

14:13.430 --> 14:14.430
然后马上

14:14.430 --> 14:15.430
马上又运行

14:15.430 --> 14:16.430
请求地址二

14:16.430 --> 14:17.430
对吧

14:17.430 --> 14:18.430
速度很快的

14:18.430 --> 14:19.430
通知

14:19.430 --> 14:21.430
运行请求地址三

14:21.430 --> 14:22.430
通知对吧

14:22.430 --> 14:23.430
这边还没

14:23.430 --> 14:24.430
可能还没有

14:24.430 --> 14:25.430
第一个请求都还没有发出去

14:25.430 --> 14:26.430
他已经来了一大堆请求了

14:26.430 --> 14:27.430
没了意思吧

14:27.430 --> 14:29.430
他是同事发送出去的

14:29.430 --> 14:30.430
当然如果说你的

14:30.430 --> 14:32.430
需求就是同事发送

14:32.430 --> 14:33.430
那就五面问题

14:33.430 --> 14:34.430
但是如果说你的

14:34.430 --> 14:35.430
需求是一次发送

14:35.430 --> 14:37.430
就变成这样的问题了

14:37.430 --> 14:38.430
所以说

14:38.430 --> 14:39.430
这个东西

14:39.430 --> 14:40.430
虽然说单码没问题

14:40.430 --> 14:43.430
但是是不满足提议的

14:43.430 --> 14:45.430
那么遇到这种情况怎么办呢

14:45.430 --> 14:47.430
我们需要一个明确的方案

14:47.430 --> 14:49.430
来解决这些问题

14:49.430 --> 14:51.430
这个方案最早不是出于官方

14:51.430 --> 14:52.430
是出于民间的

14:52.430 --> 14:54.430
就在咱们的前端社区

14:54.430 --> 14:55.430
大家知道

14:55.430 --> 14:56.430
前端社区

14:56.430 --> 14:59.430
目前整个技术社区里边

14:59.430 --> 15:01.430
应该说

15:01.430 --> 15:03.430
要不要把之一加上

15:03.430 --> 15:04.430
就不要加之一了

15:04.430 --> 15:06.430
应该说是最火月的社区了

15:06.430 --> 15:08.430
当GS社区

15:08.430 --> 15:10.430
还有提出了一个规范

15:10.430 --> 15:11.430
什么要规范呢

15:11.430 --> 15:12.430
就是我不给你写代

15:12.430 --> 15:13.430
我就跟你说

15:13.430 --> 15:15.430
我们以后应该咋做

15:15.430 --> 15:16.430
怎么怎样做呢

15:16.430 --> 15:18.430
大家形成一个共识

15:18.430 --> 15:19.430
就要规范

15:19.430 --> 15:20.430
这是社区提出来的

15:20.430 --> 15:22.430
叫做PromiseA加规范

15:22.430 --> 15:23.430
我在我的博客里边

15:23.430 --> 15:24.430
对PromiseA加规范

15:24.430 --> 15:26.430
有一个原文翻译

15:26.430 --> 15:27.430
不过那个看上去

15:27.430 --> 15:28.430
就恶心

15:28.430 --> 15:29.430
我不也建议大家去看

15:29.430 --> 15:30.430
有些恶心翻译说

15:30.430 --> 15:31.430
我给大家讲

15:31.430 --> 15:32.430
讲出来

15:32.430 --> 15:33.430
大家还要好理解一下

15:33.430 --> 15:35.430
提出一个规范

15:35.430 --> 15:36.430
那么他就希望

15:36.430 --> 15:38.430
这个规范是来处理什么事呢

15:38.430 --> 15:39.430
就是处理

15:39.430 --> 15:41.430
为了把这些异部场景

15:41.430 --> 15:43.430
全部的规范化

15:43.430 --> 15:44.430
我不要求说

15:44.430 --> 15:45.430
能够消除毁掉

15:45.430 --> 15:47.430
这个我做不到的

15:47.430 --> 15:49.430
但是我要把它规范化

15:49.430 --> 15:51.430
尽量的解决这些问题

15:51.430 --> 15:52.430
特别是这种

15:52.430 --> 15:54.430
毁掉地域的问题

15:54.430 --> 15:55.430
不要理他说

15:55.430 --> 15:56.430
他出了一个规范

15:56.430 --> 15:57.430
后来这个规范

15:57.430 --> 15:58.430
得到大家的认可

15:58.430 --> 15:59.430
将你们以后

15:59.430 --> 16:00.430
学习到什么

16:00.430 --> 16:01.430
接query

16:01.430 --> 16:02.430
第三方库

16:02.430 --> 16:03.430
有些第三方库里边

16:03.430 --> 16:04.430
他有些东西

16:04.430 --> 16:06.430
他是使用的是Promise

16:06.430 --> 16:07.430
A加规范

16:07.430 --> 16:08.430
因为那个时候

16:08.430 --> 16:10.430
官方还没有出来

16:10.430 --> 16:12.430
他就使用了A加规范

16:12.430 --> 16:13.430
像这个接query里边的

16:13.430 --> 16:14.430
阿加克斯函数

16:14.430 --> 16:17.430
他就是满足A加规范的

16:17.430 --> 16:18.430
后来官方就站出来

16:18.430 --> 16:19.430
说

16:19.430 --> 16:20.430
这个规范确实不错

16:20.430 --> 16:22.430
大家都比较认可

16:22.430 --> 16:23.430
于是

16:23.430 --> 16:24.430
行

16:24.430 --> 16:25.430
那我就单独

16:25.430 --> 16:26.430
在介石

16:26.430 --> 16:27.430
原生原里边

16:27.430 --> 16:28.430
给你注入一个API

16:28.430 --> 16:29.430
什么叫API

16:29.430 --> 16:30.430
就是什么对象

16:30.430 --> 16:32.430
函数这些东西

16:33.430 --> 16:34.430
那么这套API

16:34.430 --> 16:36.430
就是满足这个规范的

16:36.430 --> 16:37.430
没啥意思吧

16:37.430 --> 16:38.430
那么这套API

16:38.430 --> 16:39.430
叫什么API

16:39.430 --> 16:40.430
叫Promise API

16:40.430 --> 16:43.430
他满足了Promise A加规范

16:43.430 --> 16:44.430
所以说

16:44.430 --> 16:47.430
由于官方他满足A加规范

16:47.430 --> 16:49.430
而且并且

16:49.430 --> 16:50.430
A加规范

16:50.430 --> 16:51.430
他规定了

16:51.430 --> 16:53.430
只要满足我这个规范

16:53.430 --> 16:55.430
甭管是理解的代码

16:55.430 --> 16:56.430
还是他写的代码

16:56.430 --> 16:57.430
无所谓

16:57.430 --> 16:58.430
只要你满足我这个规范

16:58.430 --> 16:59.430
那么你们之间的

16:59.430 --> 17:01.430
异步操作

17:01.430 --> 17:03.430
是可以相互兼容的

17:03.430 --> 17:04.430
以后给大家解释

17:04.430 --> 17:06.430
什么叫你相互兼容

17:06.430 --> 17:08.430
你们是可以相互兼容的

17:08.430 --> 17:09.430
而我们现在

17:09.430 --> 17:12.430
官方有了Promise API

17:12.430 --> 17:13.430
他是满足规范的

17:13.430 --> 17:15.430
因此他可以跟以前

17:15.430 --> 17:17.430
因为官方标准出来之前

17:17.430 --> 17:19.430
还有一些民间的代码实现

17:19.430 --> 17:20.430
他可以跟以前的

17:20.430 --> 17:21.430
民间代码实现

17:21.430 --> 17:23.430
都可以相互兼容

17:23.430 --> 17:25.430
也就是说你们

17:25.430 --> 17:26.430
以后学习到

17:26.430 --> 17:28.430
街块里面的阿扎克斯

17:28.430 --> 17:29.430
那些网络通信的

17:29.430 --> 17:30.430
这些函数

17:30.430 --> 17:32.430
可以跟ES6

17:32.430 --> 17:33.430
官方的Promise API

17:33.430 --> 17:35.430
兼容的没问题的

17:35.430 --> 17:36.430
一点问题都没有

17:36.430 --> 17:37.430
没什么意思吧

17:37.430 --> 17:41.430
这是关于这两个概念

17:41.430 --> 17:43.430
Promise API

17:43.430 --> 17:45.430
那么后来

17:45.430 --> 17:47.430
又发生了变化

17:47.430 --> 17:50.430
由于大家都满足这个规范

17:50.430 --> 17:52.430
于是我们的异步处理

17:52.430 --> 17:54.430
就变得越来越标准化了

17:54.430 --> 17:55.430
说你们以后

17:55.430 --> 17:57.430
基本上是看不到这种代码

17:57.430 --> 17:58.430
我们的异步处理

17:58.430 --> 17:59.430
越来越标准化过后

17:59.430 --> 18:02.430
就变成了一个结果

18:02.430 --> 18:03.430
就是理解的异步

18:03.430 --> 18:04.430
跟它起的异步

18:04.430 --> 18:05.430
都是一样的了

18:05.430 --> 18:07.430
没有什么差异的

18:07.430 --> 18:08.430
因为都是满足规范的

18:08.430 --> 18:11.430
于是官方觉得

18:11.430 --> 18:13.430
我就进一步优化它

18:13.430 --> 18:14.430
于是在ES7

18:14.430 --> 18:15.430
出来了Async

18:15.430 --> 18:17.430
而为止是关键制

18:17.430 --> 18:18.430
今天我不知道

18:18.430 --> 18:19.430
能不能讲到

18:19.430 --> 18:20.430
我尽量讲

18:20.430 --> 18:21.430
因为我们今天的主要任务

18:21.430 --> 18:22.430
是完成Promise

18:22.430 --> 18:23.430
这块的学习

18:23.430 --> 18:24.430
后边有时间的话

18:24.430 --> 18:25.430
给大家讲一讲

18:25.430 --> 18:26.430
因为这个里边

18:26.430 --> 18:27.430
还细节还蛮多的

18:27.430 --> 18:29.430
那么有了这两个关键制过后来

18:29.430 --> 18:31.430
它就更加完美地解决了

18:31.430 --> 18:32.430
异步处理关键

18:32.430 --> 18:33.430
它是一个见尽的过程

18:33.430 --> 18:34.430
最开始

18:34.430 --> 18:35.430
没有任何标准

18:35.430 --> 18:36.430
没有任何规范

18:36.430 --> 18:37.430
大家随意写

18:37.430 --> 18:39.430
然后出现了Asia规范

18:39.430 --> 18:40.430
开始标准化了

18:40.430 --> 18:41.430
然后标准化出来过后

18:41.430 --> 18:43.430
ES6出现了Promise API

18:43.430 --> 18:45.430
满足这个标准

18:45.430 --> 18:46.430
由于大家都标准了

18:46.430 --> 18:48.430
于是ES7出来了两个关键制

18:48.430 --> 18:50.430
如果说标准没有形成

18:50.430 --> 18:51.430
这两个关键制

18:51.430 --> 18:53.430
出来没有任何意义

18:53.430 --> 18:55.430
没有任何意义的

18:55.430 --> 18:56.430
好

18:56.430 --> 18:59.430
它都要整个演化过程

18:59.430 --> 19:00.430
好

19:00.430 --> 19:01.430
接下来我们一个个来

19:01.430 --> 19:02.430
接下来我们要进入

19:02.430 --> 19:03.430
现在我们接下来

19:03.430 --> 19:04.430
就开始具体的学习

19:04.430 --> 19:06.430
这套规范到底是怎么回事

19:06.430 --> 19:08.430
我们就学习Promise API

19:08.430 --> 19:10.430
因为它就满足了这个规范

19:10.430 --> 19:11.430
一边讲这个 API

19:11.430 --> 19:14.430
顺便把这个 Asia规范讲一讲

19:14.430 --> 19:15.430
好 第一个

19:15.430 --> 19:16.430
干净

19:16.430 --> 19:19.940
首先呢

19:19.940 --> 19:20.940
这个规范里边

19:20.940 --> 19:22.940
它就说

19:22.940 --> 19:24.940
我们一个异步任务

19:24.940 --> 19:26.940
我们就把它称之为Promise

19:26.940 --> 19:28.940
为什么称之为这个单词呢

19:28.940 --> 19:33.940
是因为在老外的那些商业合同里边

19:33.940 --> 19:36.940
他们把那种就是

19:36.940 --> 19:39.940
一个任务的适否完成

19:39.940 --> 19:41.940
是不是满足合约

19:41.940 --> 19:42.940
是不是满足合约

19:42.940 --> 19:43.940
那么它就用一个单词

19:43.940 --> 19:44.940
Promise来代替

19:44.940 --> 19:45.940
所以说

19:45.940 --> 19:46.940
它就用这个单词

19:46.940 --> 19:47.940
用它来表示

19:47.940 --> 19:49.940
用它来表示一个异步任务

19:49.940 --> 19:50.940
那么它在企业时

19:50.940 --> 19:52.940
就要表现为一个啥呢

19:52.940 --> 19:53.940
表现为一个对象

19:53.940 --> 19:54.940
我们先不着急携带嘛

19:54.940 --> 19:56.940
先把这些核心概念认识清楚

19:56.940 --> 19:57.940
概念认识清楚了过后

19:57.940 --> 19:59.940
你看代码就非常容易理解了

19:59.940 --> 20:01.940
大家学习Promise的时候

20:01.940 --> 20:02.940
有时候觉得很迷茫

20:02.940 --> 20:04.940
就是因为概念没有这些概念

20:04.940 --> 20:06.940
Promise是一个对象

20:06.940 --> 20:08.940
它表示的是一个异步任务

20:08.940 --> 20:09.940
比方说像咱们

20:09.940 --> 20:10.940
计时对吧

20:10.940 --> 20:11.940
是个异步任务

20:11.940 --> 20:13.940
还有什么网络通信

20:13.940 --> 20:15.940
都是属于异步任务

20:15.940 --> 20:17.940
那么这个对象那一步

20:17.940 --> 20:20.940
它保存了任务的进展状态

20:20.940 --> 20:22.940
因为无论你是什么样的任务

20:22.940 --> 20:24.940
它总会有一个情况

20:24.940 --> 20:25.940
到底是什么情况

20:25.940 --> 20:26.940
对吧

20:26.940 --> 20:27.940
你是正在进行中

20:27.940 --> 20:28.940
还是已经完成了

20:28.940 --> 20:29.940
对吧

20:29.940 --> 20:31.940
你完成了是成功了还是失败了

20:31.940 --> 20:32.940
那么它规定了

20:32.940 --> 20:34.940
我们的异步任务

20:34.940 --> 20:36.940
应该有三种状态

20:36.940 --> 20:37.940
不同的状态

20:37.940 --> 20:39.940
又属于不同的阶段

20:39.940 --> 20:40.940
大家看一下

20:40.940 --> 20:42.940
就这一块

20:42.940 --> 20:44.940
我刚才说一下什么意思

20:44.940 --> 20:45.940
有两个阶段

20:45.940 --> 20:46.940
一个阶段叫做

20:46.940 --> 20:47.940
位绝阶段

20:47.940 --> 20:48.940
叫Unsettled

20:48.940 --> 20:50.940
没有定下来

20:50.940 --> 20:51.940
一个阶段是

20:51.940 --> 20:53.940
位绝阶段叫做Settled

20:53.940 --> 20:55.940
定下来了

20:55.940 --> 20:57.940
位绝阶段里边

20:57.940 --> 20:58.940
它有一个状态

20:58.940 --> 20:59.940
它只有一个状态

20:59.940 --> 21:01.940
尤其只有一个状态

21:01.940 --> 21:02.940
叫做Pending

21:02.940 --> 21:03.940
挂起

21:03.940 --> 21:04.940
挂起

21:04.940 --> 21:05.940
正在进行中

21:05.940 --> 21:07.940
挂起

21:07.940 --> 21:09.940
以绝有两种

21:09.940 --> 21:10.940
一个是Resolve的

21:10.940 --> 21:11.940
记住这些单词

21:11.940 --> 21:12.940
这些单词

21:12.940 --> 21:13.940
甚至可能在面试体里边

21:13.940 --> 21:14.940
直接遇到的

21:14.940 --> 21:15.940
Resolve的

21:15.940 --> 21:17.940
叫做成功

21:17.940 --> 21:18.940
Rejected

21:18.940 --> 21:19.940
拒绝

21:19.940 --> 21:20.940
失败

21:20.940 --> 21:21.940
一个任务

21:21.940 --> 21:25.380
它一共就这么三种状态

21:25.380 --> 21:27.380
而且每一个任务

21:27.380 --> 21:29.380
它某一个时间点

21:29.380 --> 21:31.380
它只能有一种状态

21:31.380 --> 21:32.380
它不可能同时

21:32.380 --> 21:33.380
尤其一种状态

21:33.380 --> 21:34.380
这个不符合逻辑

21:34.380 --> 21:35.380
它不能既成功

21:35.380 --> 21:36.380
又失败

21:36.380 --> 21:37.380
既成功又挂起

21:37.380 --> 21:38.380
它就矛盾了

21:38.380 --> 21:39.380
挂起表示

21:39.380 --> 21:40.380
没有结束

21:40.380 --> 21:41.380
没有结束

21:41.380 --> 21:42.380
你怎么知道

21:42.380 --> 21:43.380
成功还是失败

21:44.380 --> 21:45.380
这是任务的

21:45.380 --> 21:46.380
三种状态

21:46.380 --> 21:47.380
已经两个阶段

21:48.380 --> 21:49.380
好 接下来

21:49.380 --> 21:50.380
继续看下一个

21:50.380 --> 21:51.380
状态的

21:52.380 --> 21:53.380
因为我们一个任务

21:53.380 --> 21:55.380
它不能永远只在一个状态

21:55.380 --> 21:56.380
它有可能会

21:56.380 --> 21:57.380
变得成其他状态

21:57.380 --> 21:58.380
它是怎么转换的

21:58.380 --> 21:59.380
首先

21:59.380 --> 22:01.380
在任务最开始的时候

22:02.380 --> 22:03.380
它处于什么状态呢

22:03.380 --> 22:05.380
处于位决阶段的

22:05.380 --> 22:07.380
挂起状态

22:07.380 --> 22:08.380
能理解吗

22:08.380 --> 22:09.380
你做任何一件事

22:09.380 --> 22:11.380
是不是一最开始的时候

22:11.380 --> 22:13.380
这个事是没有结果的

22:13.380 --> 22:15.380
它是正在进行中的状态

22:15.380 --> 22:16.380
就是挂起

22:17.380 --> 22:18.380
好

22:18.380 --> 22:20.380
然后随着任务的推进

22:20.380 --> 22:22.380
在任务的位决阶段

22:22.380 --> 22:23.380
这个阶段的时候

22:23.380 --> 22:24.380
随着任务的不断前行

22:24.380 --> 22:25.380
比方说

22:25.380 --> 22:26.380
现在我要做一个计时任务

22:26.380 --> 22:27.380
对吧

22:27.380 --> 22:28.380
不断的计时

22:28.380 --> 22:29.380
好

22:29.380 --> 22:31.380
将来有一天计时结束了

22:32.380 --> 22:33.380
是不是这个状态会变化

22:33.380 --> 22:34.380
对不对

22:34.380 --> 22:36.380
或者是网络请求

22:36.380 --> 22:37.380
已经拿到结果了

22:37.380 --> 22:39.380
这个状态会变化

22:39.380 --> 22:40.380
那么在位决阶段的时候

22:40.380 --> 22:42.380
我是有能力

22:42.380 --> 22:44.380
把这个任务推向

22:44.380 --> 22:45.380
已决的

22:45.380 --> 22:47.380
它从

22:47.380 --> 22:48.380
正在进行中

22:48.380 --> 22:50.380
变成了有了一个结果

22:50.380 --> 22:51.380
什么要已决

22:51.380 --> 22:53.380
已经有了一个结果

22:54.380 --> 22:55.380
比方说

22:55.380 --> 22:56.380
咱们从服务器拿到数据之后

22:56.380 --> 22:57.380
对吧

22:57.380 --> 22:58.380
我们就从位决

22:58.380 --> 23:00.380
推向已决的

23:00.380 --> 23:02.380
resolve表示成功

23:02.380 --> 23:03.380
比方说

23:03.380 --> 23:04.380
如果说网络不好

23:04.380 --> 23:06.380
我数据没拿到

23:06.380 --> 23:07.380
或者是服务器那边

23:07.380 --> 23:08.380
不知道什么原因

23:08.380 --> 23:09.380
给我返回那个错误

23:09.380 --> 23:10.380
总之我们没拿到

23:10.380 --> 23:11.380
没拿到

23:11.380 --> 23:12.380
那么这个时候

23:12.380 --> 23:13.380
我就可以从

23:13.380 --> 23:15.380
平定挂起

23:15.380 --> 23:16.380
推向

23:16.380 --> 23:17.380
rejected

23:17.380 --> 23:18.380
失败

23:18.380 --> 23:19.380
没了意思吧

23:19.380 --> 23:20.380
它的状态转换

23:20.380 --> 23:21.380
是这样转换的

23:22.380 --> 23:23.380
我们把这个

23:23.380 --> 23:24.380
从平定状态

23:24.380 --> 23:26.380
转换到成功状态

23:26.380 --> 23:27.380
这个过程

23:27.380 --> 23:29.380
这是形容词

23:29.380 --> 23:30.380
这个叫做动词

23:30.380 --> 23:32.380
把这个过程叫做resolve

23:33.380 --> 23:34.380
然后把这个平定

23:34.380 --> 23:35.380
转换到失败

23:35.380 --> 23:37.380
叫做reject

23:37.380 --> 23:38.380
拒绝

23:38.380 --> 23:40.380
它变成了一个形容词

23:40.380 --> 23:41.380
rejected

23:41.380 --> 23:42.380
没了意思吧

23:42.380 --> 23:44.380
而且大家一定要注意这句话

23:44.380 --> 23:46.380
一定要注意这句话

23:46.380 --> 23:48.380
这种状态和阶段的变化

23:48.380 --> 23:50.380
是不可逆的

23:50.380 --> 23:51.380
啥意思呢

23:51.380 --> 23:52.380
一旦一个状态

23:52.380 --> 23:54.380
从挂起推向了成功

23:54.380 --> 23:55.380
也是永远不可能

23:55.380 --> 23:57.380
把它变成失败了

23:57.380 --> 23:58.380
它只能是成功

23:58.380 --> 23:59.380
它的状态

23:59.380 --> 24:01.380
一旦推向了以绝

24:01.380 --> 24:03.380
它就一定是不能变化了

24:03.380 --> 24:05.380
已经定下来了

24:05.380 --> 24:06.380
你想一想

24:06.380 --> 24:07.380
这是什么逻辑

24:07.380 --> 24:09.380
为什么它不让它变化

24:09.380 --> 24:12.390
因为这个东西

24:12.390 --> 24:14.390
是符合现实逻辑的

24:14.390 --> 24:16.390
时间无法倒流

24:16.390 --> 24:17.390
对吧

24:17.390 --> 24:18.390
你怎么怎么玩

24:18.390 --> 24:19.390
这个时间都没法倒流

24:19.390 --> 24:21.390
比方说你

24:21.390 --> 24:23.390
大家有没有这样的体会

24:23.390 --> 24:24.390
有的时候

24:24.390 --> 24:26.390
你跟别人争论一件事

24:26.390 --> 24:27.390
或者是吵架

24:27.390 --> 24:28.390
吵完了之后

24:28.390 --> 24:30.390
你回去躺在床上

24:30.390 --> 24:31.390
思乃想去

24:31.390 --> 24:33.390
好像之前说的好像不对

24:33.390 --> 24:35.390
哪个地方没有说好

24:35.390 --> 24:37.390
你之前吵架失败了

24:37.390 --> 24:38.390
或者是争论失败了

24:38.390 --> 24:39.390
这个时候

24:39.390 --> 24:40.390
你的状态是什么

24:40.390 --> 24:41.390
状态就是失败的

24:41.390 --> 24:42.390
你能不能回去

24:42.390 --> 24:43.390
把时间倒回去

24:43.390 --> 24:45.390
重新把这些东西说一遍了

24:45.390 --> 24:46.390
不可能

24:46.390 --> 24:47.390
对不对

24:47.390 --> 24:48.390
那如果说你要找回场子

24:48.390 --> 24:49.390
怎么办

24:49.390 --> 24:50.390
你要找回场子的话

24:50.390 --> 24:52.390
只能开启一个新的任务

24:52.390 --> 24:53.390
开启一个新的任务

24:53.390 --> 24:54.390
重新跟它吵一下

24:54.390 --> 24:56.390
重新跟它争论一次

24:56.390 --> 24:57.390
做这个道理

24:57.390 --> 24:58.390
对吧

24:58.390 --> 24:59.390
那么这里也是一样的

24:59.390 --> 25:01.390
如果说你失败了

25:01.390 --> 25:02.390
比方说有一个任务

25:02.390 --> 25:03.390
它失败了

25:03.390 --> 25:04.390
怎么办呢

25:04.390 --> 25:05.390
我重新开启一个新的任务

25:05.390 --> 25:06.390
再来一遍

25:06.390 --> 25:07.390
重新尝试一遍

25:07.390 --> 25:08.390
是可以的

25:08.390 --> 25:09.390
但是你不能把

25:09.390 --> 25:11.390
原来的任务推回去

25:11.390 --> 25:12.390
是不能推回去了

25:13.390 --> 25:15.390
这一块大家能理解我的意思吧

25:15.390 --> 25:16.390
能理解的话

25:16.390 --> 25:17.390
就可以

25:19.390 --> 25:23.430
记住了

25:23.430 --> 25:24.430
这个很重要的

25:25.430 --> 25:26.430
原来

25:27.430 --> 25:28.430
下一个

25:28.430 --> 25:32.830
刚才说到状态的转换

25:32.830 --> 25:33.830
对吧

25:33.830 --> 25:34.830
然后我们再说细节

25:34.830 --> 25:36.830
慢慢的一点点就带入细节

25:36.830 --> 25:37.830
有的时候

25:37.830 --> 25:38.830
我们会发现

25:38.830 --> 25:40.830
一个任务完成之后

25:40.830 --> 25:42.830
或者是失败之后

25:42.830 --> 25:45.830
可能有一些信息需要负担

25:45.830 --> 25:46.830
你看很多

25:46.830 --> 25:48.830
东西不但你要去

25:48.830 --> 25:49.830
许下的API

25:49.830 --> 25:50.830
许他的概念

25:50.830 --> 25:52.830
还要去体会他的思想

25:52.830 --> 25:53.830
你们将来的

25:53.830 --> 25:58.830
每个同学都要向高级开发者努力

25:58.830 --> 25:59.830
那么高级开发者

25:59.830 --> 26:00.830
一定是有大量的

26:00.830 --> 26:01.830
这种程序思想的

26:01.830 --> 26:02.830
那么这些思想

26:02.830 --> 26:03.830
哪来的

26:03.830 --> 26:04.830
就是通过学习别人的东西

26:04.830 --> 26:05.830
一点点去体会

26:05.830 --> 26:07.830
他就怎么去设计的

26:07.830 --> 26:09.830
不要着急去写代

26:09.830 --> 26:11.830
先把这些思想模型建立起来

26:11.830 --> 26:12.830
你看我们一个任务

26:12.830 --> 26:14.830
他完成后

26:14.830 --> 26:16.830
比方说我们跑步

26:16.830 --> 26:17.830
跑步完了过

26:17.830 --> 26:18.830
是不是一个用时

26:18.830 --> 26:19.830
你跑了多少秒

26:19.830 --> 26:20.830
比方说

26:20.830 --> 26:23.830
我们从网络上去拿数据

26:23.830 --> 26:24.830
拿到数据过后

26:24.830 --> 26:25.830
一个数据是啥

26:25.830 --> 26:26.830
是一个学生列表

26:26.830 --> 26:27.830
还是个班级列表

26:27.830 --> 26:28.830
还是个电影列表

26:28.830 --> 26:32.830
还是个省分省市数据

26:32.830 --> 26:34.830
他总有一些数据

26:34.830 --> 26:35.830
他完成之后

26:35.830 --> 26:36.830
可能会用到一些数据

26:36.830 --> 26:37.830
有的时候没有

26:37.830 --> 26:39.830
有的时候就

26:39.830 --> 26:40.830
有的时候失败了

26:40.830 --> 26:41.830
比方说

26:41.830 --> 26:42.830
你这个网络请求失败了

26:42.830 --> 26:43.830
失败了

26:43.830 --> 26:44.830
是网络不好

26:44.830 --> 26:46.830
还是你请求的地址就不存在

26:46.830 --> 26:47.830
能的

26:47.830 --> 26:49.830
他有个失败的原因

26:49.830 --> 26:51.830
因此

26:51.830 --> 26:53.830
他这里继续细化

26:53.830 --> 26:54.830
当我们把任务

26:54.830 --> 26:55.830
从一个状态

26:55.830 --> 26:59.830
从刮辑状态推向成功的时候

26:59.830 --> 27:01.830
我可能会附带一些数据

27:01.830 --> 27:03.830
叫成功的数据

27:03.830 --> 27:04.830
那么这个数据

27:04.830 --> 27:05.830
可以是任何东西

27:05.830 --> 27:06.830
可以是一个数字

27:06.830 --> 27:07.830
可以是一个对象

27:07.830 --> 27:08.830
可以是一个函数

27:08.830 --> 27:09.830
可以是任何东西

27:09.830 --> 27:11.830
推向成功

27:11.830 --> 27:13.830
他当他任务到达成功之后

27:13.830 --> 27:16.830
他内部就会拥有这个数据

27:16.830 --> 27:17.830
你要的意思

27:17.830 --> 27:18.830
这个逻辑是很合理的

27:18.830 --> 27:20.830
如果说一个任务失败

27:20.830 --> 27:22.830
他可能会有一些失败的原因

27:22.830 --> 27:24.830
到底出了什么问题

27:24.830 --> 27:25.830
他可能一个失败的原因

27:25.830 --> 27:27.830
或者是一个错误对象

27:27.830 --> 27:28.830
一个数字

27:28.830 --> 27:29.830
可以是任何数据

27:29.830 --> 27:30.830
那么当他失败的时候

27:30.830 --> 27:32.830
他也会记住这个数据

27:32.830 --> 27:35.830
就是任务完成之后的数据

27:35.830 --> 27:38.830
任务到了以绝过后的数据

27:38.830 --> 27:40.830
今天我们继续往下看

27:41.830 --> 27:45.100
后续处理

27:45.100 --> 27:46.100
完没

27:46.100 --> 27:47.100
没完

27:48.100 --> 27:49.100
比方说我网络

27:49.100 --> 27:51.100
从服务器拿到数据了

27:51.100 --> 27:52.100
对不对

27:52.100 --> 27:53.100
拿到什么数据

27:53.100 --> 27:56.100
拿到一个学生列表

27:56.100 --> 27:58.100
我拿这个学生列表干嘛呢

27:58.100 --> 27:59.100
我有可能会在页面上

27:59.100 --> 28:01.100
生成一个表的

28:01.100 --> 28:02.100
我也有可能

28:02.100 --> 28:03.100
把这个学生列表里边

28:03.100 --> 28:06.100
去找某一个我想要的学生

28:06.100 --> 28:07.100
我也有可能

28:07.100 --> 28:11.100
把这个学生列表拼接到

28:11.100 --> 28:12.100
另外一个数据里边去

28:12.100 --> 28:14.100
可能会做任何处理

28:14.100 --> 28:15.100
对吧

28:15.100 --> 28:16.100
你不知道他要做什么处理

28:16.100 --> 28:18.100
比方说我们即时

28:18.100 --> 28:19.100
即时两秒钟

28:19.100 --> 28:21.100
两秒钟之后做啥呢

28:21.100 --> 28:22.100
我也不知道要做啥

28:22.100 --> 28:24.100
一个按钮点击了

28:24.100 --> 28:25.100
点击到之后做啥

28:25.100 --> 28:27.100
是不是有可能是任何情况

28:27.100 --> 28:28.100
对不对

28:28.100 --> 28:29.100
那么这种情况呢

28:29.100 --> 28:31.100
他这个模型里边

28:31.100 --> 28:32.100
他没有办法知道

28:32.100 --> 28:33.100
你具体又是什么情况

28:33.100 --> 28:34.100
但是呢

28:34.100 --> 28:36.100
他知道一定有那么一个东西

28:36.100 --> 28:38.100
需要做后续处理

28:38.100 --> 28:40.100
那么这个后续处理呢

28:40.100 --> 28:42.100
他把它分成两种

28:42.100 --> 28:44.100
一种是成功之后的后续处理

28:44.100 --> 28:45.100
它称之为

28:45.100 --> 28:47.100
renable

28:47.100 --> 28:48.100
其实这个玩意呢

28:48.100 --> 28:51.100
在GS里边表现成一个函数

28:51.100 --> 28:53.100
一个是失败之后的后续处理

28:53.100 --> 28:54.100
就是任务失败了

28:54.100 --> 28:55.100
你要干嘛

28:55.100 --> 28:56.100
你要重新发起一个新的任务

28:56.100 --> 28:58.100
还是要做什么事情

28:58.100 --> 29:00.100
它称之为开小伯

29:00.100 --> 29:02.100
原来的意思吧

29:02.100 --> 29:03.100
于是呢

29:03.100 --> 29:06.100
它就变成下面这个图了

29:06.100 --> 29:09.100
这一部分是promise

29:09.100 --> 29:11.100
它不关心后续处理

29:11.100 --> 29:12.100
它只关心

29:12.100 --> 29:13.100
我的任务

29:13.100 --> 29:15.100
怎么样从一种状态

29:15.100 --> 29:16.100
变到另一种状态

29:16.100 --> 29:17.100
要附带什么样的数据

29:17.100 --> 29:18.100
对吧

29:18.100 --> 29:19.100
它只处理这个

29:19.100 --> 29:20.100
后续处理

29:20.100 --> 29:22.100
我不管

29:22.100 --> 29:24.100
但是我可以给你提供一个街头

29:24.100 --> 29:27.100
去运行你给我注册的后续处理

29:27.100 --> 29:29.100
表论我成功之后

29:29.100 --> 29:30.100
它可能会有一些后续处理

29:30.100 --> 29:32.100
那么我们就运行

29:32.100 --> 29:33.100
一系列的函数

29:33.100 --> 29:34.100
真的不

29:34.100 --> 29:35.100
它可以是一个函数

29:35.100 --> 29:36.100
也可以没有

29:36.100 --> 29:37.100
也可以是多个函数

29:37.100 --> 29:38.100
好

29:38.100 --> 29:39.100
如果说我失败了

29:39.100 --> 29:41.100
也可能会运行一系列函数

29:41.100 --> 29:43.100
开小伯

29:43.100 --> 29:44.100
同时

29:44.100 --> 29:46.100
把成功过后的数据给它

29:46.100 --> 29:48.100
你拿到学生列表过后

29:48.100 --> 29:49.100
我要争称一个表格

29:49.100 --> 29:51.100
我要把学生列表给你

29:51.100 --> 29:52.100
对不对

29:52.100 --> 29:53.100
如果说失败了

29:53.100 --> 29:54.100
你可能要知道

29:54.100 --> 29:55.100
到底是什么原因失败的

29:55.100 --> 29:56.100
我把原因解决

29:56.100 --> 29:59.100
就形成了这么一张图

29:59.100 --> 30:00.100
支持

30:00.100 --> 30:02.100
promise的核心概念

30:02.100 --> 30:04.100
我们就讲到这儿

30:04.100 --> 30:05.100
大家有什么问题

30:05.100 --> 30:06.100
可以提

30:06.100 --> 30:18.020
没问题

30:18.020 --> 30:20.020
好

30:20.020 --> 30:21.020
接下来

30:21.020 --> 30:23.020
我们看代码组合书写了

30:23.020 --> 30:25.020
你把上面这张图看懂了之后

30:25.020 --> 30:27.020
你会发现代码极其的简单

30:27.020 --> 30:28.020
很多时候

30:28.020 --> 30:29.020
你觉得代码复杂

30:29.020 --> 30:31.020
所以你根本没有理解概念

30:31.020 --> 30:32.020
我很多朋友觉得

30:32.020 --> 30:33.020
article是复杂

30:33.020 --> 30:34.020
因为你没有理解

30:34.020 --> 30:35.020
adb写意它自然复杂

30:35.020 --> 30:37.020
你理解了adb写意它极其简单

30:37.020 --> 30:38.020
你看

30:39.020 --> 30:41.020
es6提供了一套

30:41.020 --> 30:42.020
promise API

30:42.020 --> 30:43.020
来完成

30:43.020 --> 30:45.020
来实现这个模型

30:45.020 --> 30:46.020
那么这个API是什么

30:46.020 --> 30:47.020
就是一个构造函数

30:47.020 --> 30:49.020
6一个promise

30:49.020 --> 30:50.020
得到的是啥

30:50.020 --> 30:52.020
创建一个构造函数

30:52.020 --> 30:53.020
6一个构造函数

30:53.020 --> 30:54.020
得到一个对象

30:54.020 --> 30:55.020
得到就是这么一个玩意

30:55.020 --> 30:57.020
得到就是这个东西

30:57.020 --> 30:58.020
就这么简单

30:59.020 --> 31:01.020
然后构造函数里边有一个参数

31:01.020 --> 31:02.020
这个参数是一个啥

31:02.020 --> 31:03.020
一看一看

31:03.020 --> 31:05.020
这个参数是一个函数

31:06.020 --> 31:08.020
它为什么是一个函数

31:08.020 --> 31:10.020
因为我们的异部

31:10.020 --> 31:11.020
是一个任务

31:11.020 --> 31:12.020
对吧

31:12.020 --> 31:13.020
是不是一个任务

31:13.020 --> 31:14.020
这个任务是不是要启动

31:14.020 --> 31:16.020
这就是任务的启动函数

31:16.020 --> 31:18.020
这个任务开始的时候

31:18.020 --> 31:19.020
要做什么事情

31:20.020 --> 31:22.020
那么这里边单码写啥呢

31:22.020 --> 31:23.020
这单码就是

31:23.020 --> 31:25.020
未决阶段的单码

31:26.020 --> 31:28.020
这些单码就是立即同步执行

31:28.020 --> 31:30.020
表示任务启动之后

31:30.020 --> 31:31.020
马上要做的事情

31:31.020 --> 31:32.020
我给大家写一下

31:35.990 --> 31:36.990
6一个promise

31:37.990 --> 31:39.990
所以返回一个对象

31:39.990 --> 31:40.990
返回一个对象

31:40.990 --> 31:41.990
随便用变量接受一下

31:41.990 --> 31:42.990
对吧

31:42.990 --> 31:43.990
这就是个任务

31:43.990 --> 31:44.990
那么任务启动的时候

31:44.990 --> 31:46.990
不是有一些事情要做吗

31:46.990 --> 31:47.990
比方说你要计时

31:47.990 --> 31:49.990
还是要发送网络请求

31:49.990 --> 31:50.990
等等

31:50.990 --> 31:51.990
对吧

31:51.990 --> 31:52.990
会有一些事情要做

31:52.990 --> 31:53.990
那么怎么来表达

31:53.990 --> 31:54.990
我要做的事情呢

31:54.990 --> 31:56.990
因为事情在戒严式里边

31:56.990 --> 31:57.990
表示一个函数

31:58.990 --> 31:59.990
对不对

31:59.990 --> 32:00.990
就是个函数

32:00.990 --> 32:01.990
这个是

32:01.990 --> 32:03.990
把这个任务启动的

32:04.990 --> 32:05.990
就这么简单

32:05.990 --> 32:06.990
我们再运行一下

32:06.990 --> 32:07.990
看一下

32:08.990 --> 32:09.990
任务启动的

32:09.990 --> 32:10.990
就这么简单

32:10.990 --> 32:12.990
它就会运行你传递进去的函数

32:12.990 --> 32:13.990
明白了意思吗

32:13.990 --> 32:15.990
而且这个函数是立即执行的

32:16.990 --> 32:17.990
也就意味着啥呢

32:17.990 --> 32:18.990
意味着我这里如果说

32:18.990 --> 32:20.990
这里输出一个1

32:20.990 --> 32:22.990
这里输出一个2

32:22.990 --> 32:24.990
那么它的输出顺序是啥

32:25.990 --> 32:29.370
大家觉得输出顺序是啥

32:29.370 --> 32:31.370
传递数据就是网络同性嘛

32:31.370 --> 32:32.370
有些同学还没有学过

32:32.370 --> 32:34.370
没关系你们早晚会学的

32:34.370 --> 32:35.370
非常简单对吧

32:35.370 --> 32:36.370
是不是就21

32:36.370 --> 32:37.370
对不对

32:37.370 --> 32:38.370
就是21

32:38.370 --> 32:39.370
运行看一下

32:39.370 --> 32:40.370
那么你其实都可以想象

32:40.370 --> 32:42.370
它这个扣子函数里边极其简单

32:42.370 --> 32:44.370
我们后边的ES6的课程里边

32:44.370 --> 32:45.370
给大家讲个

32:45.370 --> 32:47.370
它的首写是怎么写的

32:48.370 --> 32:50.370
它是喝到几期简单的

32:50.370 --> 32:52.370
就是你给我传一个函数进来

32:52.370 --> 32:53.370
叫做task

32:53.370 --> 32:55.370
叫做task放弃嘛

32:56.370 --> 32:57.370
然后我这里几期简单

32:57.370 --> 32:59.370
给你调一个函数就完事了

32:59.370 --> 33:01.940
对不对

33:01.940 --> 33:02.940
不着急

33:02.940 --> 33:03.940
不要着急

33:03.940 --> 33:04.940
咱们一步一步看

33:05.940 --> 33:06.940
好 这里

33:06.940 --> 33:07.940
右键

33:07.940 --> 33:08.940
运行

33:08.940 --> 33:09.940
不就是21吗

33:09.940 --> 33:11.940
现在我们用的是我们自己的Promise

33:11.940 --> 33:12.940
对对 就是耳机

33:12.940 --> 33:13.940
非常简单

33:14.940 --> 33:15.940
然后这个函数里边

33:15.940 --> 33:16.940
它做啥呢

33:16.940 --> 33:17.940
这个函数里边要做的事情

33:17.940 --> 33:19.940
就是我任务启动过后要干嘛

33:20.940 --> 33:21.940
比方说我启动过后

33:21.940 --> 33:22.940
我要计时

33:22.940 --> 33:23.940
我要计时的

33:24.940 --> 33:25.940
两秒钟

33:25.940 --> 33:27.940
我这里输出

33:27.940 --> 33:28.940
开始计时

33:32.020 --> 33:33.020
然后计时两秒钟

33:33.020 --> 33:34.020
set time out

33:34.020 --> 33:36.020
两秒钟之后

33:36.020 --> 33:41.500
我输出结束计时

33:41.500 --> 33:42.500
结束

33:42.500 --> 33:43.500
计时

33:44.500 --> 33:45.500
没了意思吧

33:46.500 --> 33:48.500
整个对象是来描述任务的

33:48.500 --> 33:49.500
看一下吧

33:49.500 --> 33:50.500
开始计时

33:50.500 --> 33:51.500
两秒钟之后

33:51.500 --> 33:52.500
结束计时

33:52.500 --> 33:53.500
有问题吧

33:53.500 --> 33:57.140
好 现在问题来了

33:57.140 --> 33:59.140
如果说你这样子写代嘛

33:59.140 --> 34:00.140
导致一个结果就是什么呢

34:00.140 --> 34:02.140
我们刚才看到这个图

34:02.140 --> 34:05.140
任务永远都在挂起

34:05.140 --> 34:06.140
对不对

34:06.140 --> 34:07.140
所以永远在挂起

34:07.140 --> 34:09.140
不信我们来看一下

34:09.140 --> 34:10.140
结束计时过后

34:10.140 --> 34:11.140
我们输出一下

34:11.140 --> 34:12.140
我们在浏览器里边

34:12.140 --> 34:13.140
看得更加清楚一点

34:14.140 --> 34:15.140
我们再把它盖上一个

34:21.220 --> 34:22.220
我们看一下这个

34:22.220 --> 34:23.220
一面上

34:23.220 --> 34:29.350
我们看一下这个变量Pro

34:29.350 --> 34:31.350
就是我们的Promise

34:31.350 --> 34:32.350
Promise的给你看一下

34:32.350 --> 34:33.350
它这里边有两个属性

34:33.350 --> 34:35.350
一个属性就表示任务状态

34:35.350 --> 34:36.350
PromiseState

34:37.350 --> 34:38.350
表示这些状态

34:38.350 --> 34:39.350
一共有三种状态

34:39.350 --> 34:40.350
对吧

34:40.350 --> 34:41.350
还有一个就是PromiseResult

34:41.350 --> 34:42.350
表示什么呢

34:42.350 --> 34:43.350
表示完成

34:43.350 --> 34:44.350
或者是失败之后

34:44.350 --> 34:46.350
它的相关数据

34:46.350 --> 34:47.350
对不对

34:47.350 --> 34:48.350
就这么两个

34:48.350 --> 34:49.350
全然没有什么东西了

34:49.350 --> 34:50.350
就这两个属性

34:50.350 --> 34:51.350
好 那么现在呢

34:51.350 --> 34:52.350
你看它仍然是挂起状态

34:52.350 --> 34:53.350
对不对

34:53.350 --> 34:55.350
因为它不知道任务结束了

34:55.350 --> 34:56.350
它鬼才知道你任务结束了

34:56.350 --> 34:57.350
它不知道

34:57.350 --> 34:58.350
那怎么办呢

34:58.350 --> 35:00.350
你要告诉它

35:00.350 --> 35:01.350
你这里不是在做任务吗

35:01.350 --> 35:04.350
而任务什么时候成功了

35:04.350 --> 35:05.350
怎么告诉它呢

35:05.350 --> 35:06.350
它会往这个

35:06.350 --> 35:08.350
你给它传递了一个函数进去

35:08.350 --> 35:10.350
它会在调用这个函数的时候

35:10.350 --> 35:12.350
给你传一个参数叫Result

35:12.350 --> 35:16.660
参数的名字去是你随便写

35:16.660 --> 35:17.660
从通常情况下呢

35:17.660 --> 35:19.660
就写这个Result

35:19.660 --> 35:20.660
Result是什么意思

35:20.660 --> 35:22.660
是不是这个意思

35:22.660 --> 35:24.660
那么你觉得Result是个啥

35:24.660 --> 35:26.660
是不是应该是一个函数

35:26.660 --> 35:28.660
它可以一调用它

35:28.660 --> 35:29.660
它就可以把这个任务

35:29.660 --> 35:32.660
从挂起推向成功

35:32.660 --> 35:34.660
Result

35:34.660 --> 35:36.660
它就会把这个任务

35:36.660 --> 35:38.660
从挂起推向成功

35:38.660 --> 35:41.660
把它将任务从挂起

35:41.660 --> 35:43.660
从喷底推向

35:43.660 --> 35:47.490
Result

35:47.490 --> 35:48.490
Result

35:48.490 --> 35:51.800
好 你看一下

35:51.800 --> 35:53.800
现在我们来看一下

35:53.800 --> 35:54.800
发行

35:54.800 --> 35:56.800
打什么断点

35:56.800 --> 35:57.800
发行

35:57.800 --> 35:59.800
两秒钟之后 结束计时

35:59.800 --> 36:03.880
看一下这个pro

36:04.880 --> 36:06.880
有改动 现在有改动

36:06.880 --> 36:08.880
这个版本有改动了

36:08.880 --> 36:09.880
现在有改动了

36:09.880 --> 36:12.880
它名字跟Promise A加标准一样了

36:12.880 --> 36:14.880
它名字变成了Fulfilled

36:14.880 --> 36:15.880
之前

36:15.880 --> 36:17.880
之前还是Result的

36:17.880 --> 36:18.880
现在一变了

36:18.880 --> 36:20.880
之前Promise A加规范里面

36:20.880 --> 36:21.880
名字不一样

36:21.880 --> 36:22.880
其实意识完全一样

36:22.880 --> 36:23.880
名字不一样

36:23.880 --> 36:25.880
Promise A加规范里面

36:25.880 --> 36:27.880
这个是叫做Fulfilled

36:27.880 --> 36:28.880
完成了

36:28.880 --> 36:30.880
以前Promise API里面

36:30.880 --> 36:32.880
它的名字叫做Result的

36:32.880 --> 36:33.880
现在都改成统一的了

36:33.880 --> 36:35.880
那么大家就不用纠结了

36:35.880 --> 36:36.880
这个地方

36:36.880 --> 36:38.880
知道就行了

36:38.880 --> 36:39.880
Fulfilled

36:39.880 --> 36:40.880
对吧

36:40.880 --> 36:41.880
变成成功了

36:41.880 --> 36:42.880
就这么简单

36:42.880 --> 36:43.880
那么成功干吗

36:43.880 --> 36:44.880
不管

36:44.880 --> 36:45.880
它只管这个任务的状态

36:45.880 --> 36:47.880
它维护任务的状态

36:47.880 --> 36:48.880
那么如果说我们熟写的话

36:48.880 --> 36:50.880
应该是怎么写的呢

36:50.880 --> 36:51.880
我这里肯定没有时间

36:51.880 --> 36:52.880
给你们熟写

36:52.880 --> 36:53.880
大概这个意思就是说

36:53.880 --> 36:54.880
我这里呢

36:54.880 --> 36:55.880
调用这个函数的时候

36:55.880 --> 36:56.880
应该给你传一个什么呢

36:56.880 --> 36:58.880
传一个函数进去

36:58.880 --> 36:59.880
想不想

36:59.880 --> 37:00.880
这里写了一个函数

37:01.880 --> 37:02.880
然后呢

37:03.880 --> 37:04.880
写了一大堆

37:04.880 --> 37:06.880
然后把这个函数给

37:06.880 --> 37:07.880
就这么简单

37:07.880 --> 37:08.880
这个函数要什么调用

37:08.880 --> 37:09.880
什么时候调用

37:09.880 --> 37:10.880
你自己随便调用

37:10.880 --> 37:12.880
当然我现在完全不讲了

37:13.880 --> 37:14.880
明儿的意思吧

37:14.880 --> 37:15.880
就把这种推向Result

37:15.880 --> 37:16.880
我们之前不是说

37:16.880 --> 37:17.880
推向Result的时候

37:17.880 --> 37:19.880
它会有带一个数据

37:19.880 --> 37:21.880
所以有可能会带一个数据

37:21.880 --> 37:22.880
那如果说你不带的话

37:22.880 --> 37:23.880
就是带的数据

37:23.880 --> 37:25.880
就是Angry Fand

37:25.880 --> 37:26.880
如果说你该带一个数据的话

37:26.880 --> 37:28.880
我们就比方说带一个数据

37:28.880 --> 37:30.880
带数据比方说

37:30.880 --> 37:31.880
带一个数据带啥

37:31.880 --> 37:32.880
随便写吧

37:32.880 --> 37:33.880
Molika

37:34.880 --> 37:35.880
两万多之后

37:35.880 --> 37:37.880
我们Molika给它带过去

37:38.880 --> 37:39.880
小心点看一下

37:40.880 --> 37:41.880
就是结束

37:41.880 --> 37:42.880
我们看一下这个pro

37:43.880 --> 37:45.880
状态为fulfilled

37:46.880 --> 37:48.880
数据为Molika

37:48.880 --> 37:49.880
非常简单

37:49.880 --> 37:51.880
它就是维护状态的

37:52.880 --> 37:53.880
刚才不是说

37:53.880 --> 37:55.880
这个状态有可能推向成功

37:55.880 --> 37:57.880
是不是也有可能会推向失败

37:57.880 --> 37:59.880
那什么时候推向失败呢

37:59.880 --> 38:01.880
这些东西你完全可以自行控制的

38:02.880 --> 38:03.880
怎么推向失败呢

38:03.880 --> 38:04.880
比方说技术结束过后

38:04.880 --> 38:05.880
我不成功

38:05.880 --> 38:06.880
我失败

38:06.880 --> 38:07.880
那怎么办呢

38:07.880 --> 38:08.880
它第二个参数

38:08.880 --> 38:10.880
仍然是一个喊数

38:10.880 --> 38:11.880
叫Result

38:11.880 --> 38:12.880
当然你名字可以随便写

38:12.880 --> 38:14.880
这些东西只是行参

38:15.880 --> 38:16.880
Result

38:16.880 --> 38:17.880
一样的道理

38:17.880 --> 38:19.880
这里边说以前失败的原因

38:19.880 --> 38:20.880
你看一下这边

38:20.880 --> 38:21.880
Result

38:21.880 --> 38:22.880
失败的原因

38:22.880 --> 38:23.880
这样看是不是非常容易理解了

38:24.880 --> 38:25.880
我该传个原因

38:25.880 --> 38:26.880
原因可以是任何东西

38:26.880 --> 38:27.880
一二三

38:27.880 --> 38:28.880
随便出来

38:28.880 --> 38:29.880
保存

38:29.880 --> 38:30.880
你看一下

38:30.880 --> 38:31.880
小心

38:32.880 --> 38:33.880
其实结束

38:33.880 --> 38:35.880
咱们来看一下这个pro

38:35.880 --> 38:36.880
那么在这里

38:36.880 --> 38:37.880
它会打印出一个东西

38:37.880 --> 38:38.880
打印出一个错误

38:39.880 --> 38:40.880
状态为Rate

38:40.880 --> 38:41.880
结极的

38:41.880 --> 38:43.880
数据为一二三

38:43.880 --> 38:44.880
好

38:44.880 --> 38:45.880
听到这一部分有什么问题吗

38:48.450 --> 38:49.450
有问题

38:49.450 --> 38:50.450
有问题

38:50.450 --> 38:51.450
有问题

38:58.920 --> 38:59.920
走开了

39:03.130 --> 39:05.130
为什么是二一

39:05.130 --> 39:09.590
你这个是网络延迟吗

39:09.590 --> 39:10.590
还是你现在才打出来

39:10.590 --> 39:11.590
之前怎么回问呢

39:11.590 --> 39:12.590
为什么是二一

39:12.590 --> 39:13.590
因为它一开始

39:13.590 --> 39:15.590
就会立即执行这个喊数

39:15.590 --> 39:17.590
就你给它传一个喊数进去

39:17.590 --> 39:18.590
它立即执行的

39:18.590 --> 39:19.590
对

39:19.590 --> 39:20.590
状态是自己决定的

39:21.590 --> 39:22.590
因为这个Result

39:22.590 --> 39:23.590
Rate这个喊数是提供给你的

39:23.590 --> 39:24.590
对吧

39:24.590 --> 39:25.590
只有你自己清楚

39:25.590 --> 39:26.590
它鬼知道你要做什么任务

39:26.590 --> 39:27.590
它鬼知道你要计时

39:27.590 --> 39:29.590
还是要网络请求

39:29.590 --> 39:30.590
还是要做任何事情

39:30.590 --> 39:31.590
我不知道你要做啥

39:32.590 --> 39:33.590
那么

39:33.590 --> 39:34.590
到底这个任务有没有结束

39:34.590 --> 39:35.590
你只有你自己知道

39:35.590 --> 39:36.590
对吧

39:36.590 --> 39:38.590
这里不在你来做任务吗

39:38.590 --> 39:39.590
任务结束了

39:39.590 --> 39:40.590
你自然知道了

39:40.590 --> 39:41.590
继续结束了

39:41.590 --> 39:42.590
网络通信结束了

39:42.590 --> 39:43.590
全是自己决定的

39:43.590 --> 39:44.590
任务是成功

39:44.590 --> 39:45.590
还是失败

39:45.590 --> 39:46.590
你自己决定

39:49.590 --> 39:51.590
怎么判断的成功和失败

39:52.590 --> 39:54.590
我现在没有判断成功失败

39:54.590 --> 39:55.590
我没有判断

39:55.590 --> 39:57.590
我只是在描述一个任务

39:57.590 --> 39:59.590
这个喊数就是描述一个任务

39:59.590 --> 40:00.590
我这个任务要做啥

40:00.590 --> 40:01.590
我要计个时

40:01.590 --> 40:02.590
良妙中

40:02.590 --> 40:03.590
计时完成过后

40:03.590 --> 40:04.590
我到底是成功

40:04.590 --> 40:05.590
还是失败

40:05.590 --> 40:06.590
如果说我是成功

40:06.590 --> 40:07.590
我就雕用这个喊数

40:07.590 --> 40:08.590
我是失败

40:08.590 --> 40:09.590
我就雕用这个喊数

40:10.590 --> 40:11.590
对

40:11.590 --> 40:12.590
Promise是同步的

40:12.590 --> 40:13.590
这里边是同步的

40:13.590 --> 40:15.590
这里边是同步的

40:16.590 --> 40:18.590
但是这个喊数不是同步的

40:18.590 --> 40:20.590
这个喊数不是同步的

40:21.590 --> 40:24.590
失败状态用到什么场景

40:24.590 --> 40:26.590
这个场景可以自己定

40:26.590 --> 40:27.590
比方说

40:27.590 --> 40:28.590
有些公司里边

40:28.590 --> 40:29.590
他认为

40:29.590 --> 40:30.590
就说网络通信

40:30.590 --> 40:31.590
就从服务器拿数据

40:31.590 --> 40:32.590
有些公司里边

40:32.590 --> 40:33.590
他认为

40:34.590 --> 40:35.590
持绣

40:35.590 --> 40:36.590
从服务器那边

40:36.590 --> 40:37.590
没有任何想用

40:37.590 --> 40:38.590
就服务器那边

40:38.590 --> 40:39.590
我给服务器

40:39.590 --> 40:40.590
就比方说两个人

40:40.590 --> 40:42.590
有些同学没有学过服务器

40:42.590 --> 40:44.590
比方说服务器是另外一个人

40:44.590 --> 40:45.590
我给他喊一声

40:45.590 --> 40:47.590
说你给我一个东西吧

40:47.590 --> 40:49.590
他没有回答我

40:49.590 --> 40:50.590
那么有些公司认为

40:50.590 --> 40:51.590
这叫做一个错误

40:51.590 --> 40:52.590
你应该用这个

40:53.590 --> 40:55.590
把这个标记一下的任务

40:55.590 --> 40:56.590
出问题了

40:57.590 --> 41:00.590
但是有些公司认为

41:00.590 --> 41:01.590
这种也算错误

41:01.590 --> 41:03.590
就是服务器给我回应了

41:03.590 --> 41:04.590
我说

41:04.590 --> 41:05.590
你给我一个东西

41:05.590 --> 41:06.590
服务器说

41:06.590 --> 41:08.590
我东西不想给你

41:08.590 --> 41:09.590
他至少回了一句话

41:09.590 --> 41:10.590
对吧

41:10.590 --> 41:11.590
有些公司认为他是错误

41:11.590 --> 41:12.590
有些公司认为他不是错误

41:12.590 --> 41:14.590
这个东西可以自己订的

41:14.590 --> 41:15.590
可以自己订的

41:15.590 --> 41:16.590
比方说像你们以后学的

41:16.590 --> 41:17.590
第三方获奖

41:17.590 --> 41:19.590
他就认为这是个错误

41:19.590 --> 41:20.590
服务器那边

41:20.590 --> 41:21.590
只要想一码

41:21.590 --> 41:22.590
不是两百

41:22.590 --> 41:23.590
到三百之前的

41:23.590 --> 41:24.590
他就认为是个错误

41:24.590 --> 41:25.590
这个对象用来干嘛的

41:25.590 --> 41:26.590
他就是用来描述

41:26.590 --> 41:28.590
一个任务状态的

41:28.590 --> 41:29.590
他就是用来描述

41:29.590 --> 41:30.590
一个任务状态的

41:30.590 --> 41:31.590
他没有那么复杂

41:31.590 --> 41:32.590
你不要把他想复杂了

41:32.590 --> 41:33.590
不要想得那么智能

41:33.590 --> 41:34.590
这东西你自己写

41:34.590 --> 41:35.590
都可以写得出来

41:36.590 --> 41:37.590
现在大家可能

41:37.590 --> 41:38.590
要待老师指导下

41:38.590 --> 41:39.590
才能写得出来

41:39.590 --> 41:40.590
没有那么复杂

41:40.590 --> 41:42.590
他就是描述一个任务状态的

41:42.590 --> 41:43.590
我一看

41:43.590 --> 41:44.590
这里边有啥东西

41:44.590 --> 41:45.590
啥都没有

41:45.590 --> 41:46.590
啥都没有

41:46.590 --> 41:47.590
就这么两个

41:47.590 --> 41:48.590
类之属性

41:48.590 --> 41:49.590
这两个类之属性

41:49.590 --> 41:50.590
你还用不到

41:51.590 --> 41:52.590
平时他都用不到

41:52.590 --> 41:53.590
只能观看

41:53.590 --> 41:54.590
你不能用

41:55.590 --> 41:56.590
没了意思吧

41:56.590 --> 41:57.590
还有什么问题

41:57.590 --> 41:58.590
这两个函数行参

41:58.590 --> 41:59.590
可以直接传参

41:59.590 --> 42:00.590
什么意思

42:00.590 --> 42:01.590
没行参

42:02.590 --> 42:03.590
兄弟

42:03.590 --> 42:04.590
你这个是不是有点

42:05.590 --> 42:06.590
基础有点问题

42:07.590 --> 42:08.590
我写个函数

42:13.590 --> 42:14.590
我哪怕有五个行参

42:14.590 --> 42:15.590
我们哪怕没有行参

42:16.590 --> 42:17.590
我调用函数的时候

42:17.590 --> 42:18.590
我不能加传递参数

42:20.590 --> 42:21.590
我不能加传递参数

42:22.590 --> 42:23.590
可以传递

42:23.590 --> 42:24.590
随便传递

42:24.590 --> 42:25.590
行参表示

42:25.590 --> 42:26.590
我要用到哪些

42:26.590 --> 42:27.590
你要用到哪些

42:27.590 --> 42:28.590
你写哪些

42:28.590 --> 42:29.590
而食食菜

42:29.590 --> 42:33.180
才是我食食菜

42:33.180 --> 42:34.180
你这两个自定义

42:34.180 --> 42:36.180
函数乱写的也能执行

42:36.180 --> 42:38.180
是Promise本身

42:38.180 --> 42:39.180
因为这两个地方是函数

42:39.180 --> 42:40.180
不准

42:40.180 --> 42:41.180
什么意思

42:41.180 --> 42:42.180
这两个自定义

42:42.180 --> 42:44.180
函数乱写的也能执行

42:45.180 --> 42:46.180
自定义函数

42:46.180 --> 42:47.180
什么乱写的

42:47.180 --> 42:49.180
你说我刚才写了个Promise吗

42:52.690 --> 42:53.690
你说这个

42:53.690 --> 42:54.690
刚才我写的

42:54.690 --> 42:55.690
刚才我都没写完

42:55.690 --> 42:56.690
不用看刚才的

42:57.690 --> 42:58.690
如果里边

42:58.690 --> 42:59.690
是用RGX请求数据

42:59.690 --> 43:00.690
是先获取到

43:00.690 --> 43:01.690
RGX结果之后

43:01.690 --> 43:02.690
继续运行

43:02.690 --> 43:03.690
还是一步请求期间

43:03.690 --> 43:04.690
继续运行

43:04.690 --> 43:05.690
后边的函数

43:06.690 --> 43:08.690
不是说立即执行函数吗

43:08.690 --> 43:11.580
什么意思

43:12.580 --> 43:14.580
你不要想太多

43:14.580 --> 43:16.580
这就是一个普通的函数

43:16.580 --> 43:17.580
你传进去过后

43:17.580 --> 43:18.580
就立即执行了

43:18.580 --> 43:19.580
你这样子看

43:19.580 --> 43:20.580
你这样子看

43:20.580 --> 43:21.580
这个东西不在Promise里边

43:21.580 --> 43:22.580
它就是个普通的函数

43:22.580 --> 43:24.580
你把这个RGX结果去掉

43:26.580 --> 43:27.580
你把这个去掉

43:27.580 --> 43:28.580
你把这个东西全部去掉

43:28.580 --> 43:29.580
让其把它去掉

43:29.580 --> 43:30.580
它就是一个

43:30.580 --> 43:31.580
注意普通不过的函数了

43:32.580 --> 43:33.580
普通的不能占普通的

43:33.580 --> 43:34.580
跟你们以前学的函数

43:34.580 --> 43:35.580
没有什么任何的区别

43:36.580 --> 43:41.060
这个函数能看得完

43:42.060 --> 43:43.060
它就是在执行这个函数

43:44.060 --> 43:45.060
它就是在执行这个函数

43:45.060 --> 43:46.060
它其他啥都没做

43:47.060 --> 43:48.060
它就是在执行这个函数

43:48.060 --> 43:50.060
它无非就是在个函数里边

43:50.060 --> 43:52.060
你要把任务推向成功和失败

43:52.060 --> 43:53.060
对不对

43:53.060 --> 43:54.060
你是不知道

43:54.060 --> 43:55.060
把任务推向成功和失败

43:55.060 --> 43:56.060
它无非就是

43:56.060 --> 43:58.060
给你传了两个函数进来

43:58.060 --> 43:59.060
第一个函数

43:59.060 --> 44:00.060
给你传了一个resolve的函数

44:00.060 --> 44:01.060
对吧

44:01.060 --> 44:02.060
给你传了一个函数进来

44:04.060 --> 44:05.060
第二个函数

44:05.060 --> 44:07.060
给你传了一个函数进来

44:07.060 --> 44:09.060
我当然不会想一写了

44:09.060 --> 44:10.060
这里

44:10.060 --> 44:11.060
这里是不是有两个函数

44:11.060 --> 44:12.060
resolve,reject

44:13.060 --> 44:14.060
我要成功的时候

44:14.060 --> 44:16.060
我就雕入一下这个函数

44:16.060 --> 44:17.060
我要失败的时候

44:17.060 --> 44:18.060
我就雕入一下这个函数

44:18.060 --> 44:22.060
没有其他东西了

44:27.900 --> 44:29.900
请求那一块

44:29.900 --> 44:30.900
请求那一块

44:30.900 --> 44:31.900
你们以后学到阿加特斯

44:32.900 --> 44:33.900
你应该没有学出阿加特斯

44:33.900 --> 44:34.900
而且可是那边

44:34.900 --> 44:35.900
你可以知道它到底是

44:35.900 --> 44:36.900
请求有没有成功的

44:36.900 --> 44:37.900
你是可以知道的

44:37.900 --> 44:38.900
你成功了

44:38.900 --> 44:39.900
你就雕入resolve

44:39.900 --> 44:40.900
失败了你就雕入reject

44:40.900 --> 44:42.900
你是可以知道的

44:42.900 --> 44:43.900
对

44:43.900 --> 44:44.900
这个resolve是内置函数

44:44.900 --> 44:45.900
它给你传过来的

44:45.900 --> 44:46.900
它通过参数给你传过来的

44:46.900 --> 44:47.900
它没有什么复杂的

44:47.900 --> 44:49.900
它里边其实很简单

44:49.900 --> 44:50.900
它里边给你写到啥呢

44:50.900 --> 44:52.900
它就是把当前的状态

44:52.900 --> 44:55.900
你把当前的状态

44:55.900 --> 44:56.900
当前的promise的状态

44:56.900 --> 44:57.900
比方Status

44:57.900 --> 44:58.900
对吧

44:58.900 --> 44:59.900
我们那个属性

44:59.900 --> 45:00.900
叫做PromiseStates

45:00.900 --> 45:01.900
对吧

45:01.900 --> 45:02.900
那个属性

45:02.900 --> 45:05.900
给它改成resolved fulfilled

45:05.900 --> 45:07.900
没有

45:07.900 --> 45:09.900
当然后面还有些事情

45:09.900 --> 45:10.900
还有些事情

45:10.900 --> 45:12.900
然后这个失败的时候

45:12.900 --> 45:13.900
它就把它状态给你改成

45:13.900 --> 45:14.900
reject

45:14.900 --> 45:15.900
原来意思吧

45:15.900 --> 45:16.900
没有那么复杂

45:16.900 --> 45:17.900
不要把它想复杂了

45:17.900 --> 45:23.680
好 回去吧

45:23.680 --> 45:24.680
好 现在我们知道了

45:24.680 --> 45:26.680
这个函数呢

45:26.680 --> 45:28.680
它是来描述任务状态的

45:28.680 --> 45:29.680
就是任务执行过程中

45:29.680 --> 45:30.680
它不管后续处理

45:30.680 --> 45:31.680
就是我从服务器

45:31.680 --> 45:32.680
拿到数据过后

45:32.680 --> 45:33.680
我接下来干嘛

45:33.680 --> 45:34.680
我不知道

45:34.680 --> 45:35.680
不管

45:35.680 --> 45:36.680
我只管

45:36.680 --> 45:37.680
我这个一一步任务

45:37.680 --> 45:39.680
什么时候成功

45:39.680 --> 45:40.680
什么时候失败

45:40.680 --> 45:41.680
我只管这个

45:42.680 --> 45:43.680
原来意思吧

45:43.680 --> 45:44.680
比方说

45:44.680 --> 45:46.680
你以后一定要写个计时

45:46.680 --> 45:47.680
计时函数

45:47.680 --> 45:48.680
比方说写个函数

45:48.680 --> 45:49.680
叫期待

45:49.680 --> 45:51.680
你给我一个时间

45:51.680 --> 45:54.680
比方说等待多少时间

45:54.680 --> 45:55.680
那么我给你返回一个啥呢

45:55.680 --> 45:57.680
我给你返回一个Promise

45:57.680 --> 45:59.680
表示我给你返回一个一步任务

45:59.680 --> 46:00.680
这个一步任务

46:00.680 --> 46:03.680
当我这么没有失败

46:03.680 --> 46:04.680
我就还是写上了

46:04.680 --> 46:05.680
你记得什么

46:05.680 --> 46:07.990
我用计时的

46:07.990 --> 46:09.990
我开始计时

46:09.990 --> 46:13.940
把它复出过来

46:13.940 --> 46:14.940
开始计时

46:14.940 --> 46:15.940
然后等待多少时间

46:15.940 --> 46:16.940
等待你传的参数

46:16.940 --> 46:17.940
对吧

46:17.940 --> 46:18.940
你传多少时间

46:18.940 --> 46:19.940
我也等待多少时间

46:19.940 --> 46:21.940
然后计时结束过后

46:21.940 --> 46:24.320
我就回座

46:24.320 --> 46:26.320
明白了意思吧

46:26.320 --> 46:27.320
这样子写的过后

46:27.320 --> 46:28.320
你以后用它的时候

46:28.320 --> 46:29.320
你看一下

46:29.320 --> 46:30.320
我怎么来用这个任务

46:30.320 --> 46:31.320
我就可以用

46:31.320 --> 46:35.320
一秒钟传进去

46:35.320 --> 46:36.320
是不是就

46:36.320 --> 46:37.320
相当于是开启的

46:37.320 --> 46:38.320
一个一步任务

46:38.320 --> 46:39.320
开始计时

46:39.320 --> 46:40.320
结束计时

46:40.320 --> 46:41.320
然后完了过后

46:41.320 --> 46:42.320
状态就成功了

46:42.320 --> 46:43.320
对不对

46:43.320 --> 46:44.320
保存个变量力

46:44.320 --> 46:45.320
它得到一个什么

46:45.320 --> 46:46.320
Promise

46:46.320 --> 46:48.320
能看到吗

46:48.320 --> 46:49.320
一样的

46:49.320 --> 46:51.320
完全一样的

46:51.320 --> 46:53.320
Fulfilled

46:53.320 --> 46:54.320
好

46:54.320 --> 46:55.320
咱们继续

46:55.320 --> 46:56.320
我们还没有完

46:56.320 --> 46:57.320
有同学不要着急

46:57.320 --> 46:58.320
我先把这个任务的状态搞定

46:58.320 --> 46:59.320
然后接着

46:59.320 --> 47:00.320
我们要回顾一下

47:00.320 --> 47:01.320
之前说的一个事

47:01.320 --> 47:04.320
状态是不可逆的

47:04.320 --> 47:06.320
也就意味着啥呢

47:06.320 --> 47:07.320
意味着你一旦

47:07.320 --> 47:08.320
状态确定过后

47:08.320 --> 47:09.320
你看这个东西

47:09.320 --> 47:10.320
是不是调用过后

47:10.320 --> 47:11.320
状态就变成了什么

47:11.320 --> 47:12.320
Fulfilled

47:12.320 --> 47:13.320
完成了

47:13.320 --> 47:14.320
这个时候

47:14.320 --> 47:15.320
你再去调用这个锐

47:15.320 --> 47:16.320
借个词

47:16.320 --> 47:17.320
一PUB

47:17.320 --> 47:18.320
没用

47:18.320 --> 47:19.320
你多调用一次

47:19.320 --> 47:20.320
有用吗

47:20.320 --> 47:21.320
没用

47:21.320 --> 47:24.760
没用的

47:24.760 --> 47:25.760
你看

47:26.760 --> 47:28.760
是不是还是Fulfilled

47:28.760 --> 47:30.760
数据还是让你犯

47:30.760 --> 47:31.760
所以说

47:31.760 --> 47:32.760
你后边是要改变状态

47:32.760 --> 47:33.760
没用

47:33.760 --> 47:34.760
那么后边的代码

47:34.760 --> 47:35.760
运不运行呢

47:35.760 --> 47:36.760
运行的

47:36.760 --> 47:37.760
它还是要运行

47:37.760 --> 47:38.760
但是

47:38.760 --> 47:39.760
它没用

47:39.760 --> 47:40.760
没用

47:40.760 --> 47:41.760
你就可以想象

47:41.760 --> 47:42.760
这个锐这个词

47:42.760 --> 47:43.760
里面怎么写的

47:44.760 --> 47:46.760
状态它不是喷顶的话

47:46.760 --> 47:47.760
什么也不做

47:47.760 --> 47:48.760
对吧

47:48.760 --> 47:49.760
它其实代码逻辑呢

47:49.760 --> 47:50.760
并不

47:50.760 --> 47:51.760
其实也复杂

47:51.760 --> 47:52.760
没有那么的复杂

47:52.760 --> 47:53.760
包括

47:53.760 --> 47:54.760
如果说我这里

47:54.760 --> 47:55.760
栽域肉

47:55.760 --> 47:56.760
给它传一个数据山

47:56.760 --> 47:57.760
有用吗

47:57.760 --> 47:58.760
没用

47:58.760 --> 47:59.760
这些全部没用

47:59.760 --> 48:00.760
一旦状态确定下来

48:00.760 --> 48:01.760
任何事情

48:01.760 --> 48:04.900
无法改变

48:05.900 --> 48:07.900
它的数据仍然是undefined

48:09.900 --> 48:10.900
那么现在

48:10.900 --> 48:11.900
就是

48:11.900 --> 48:13.900
就这一块的东西

48:14.900 --> 48:15.900
描述一个任务

48:15.900 --> 48:16.900
任务的运行过程

48:16.900 --> 48:17.900
启动

48:17.900 --> 48:18.900
启动过程要干嘛

48:18.900 --> 48:19.900
你要去做任何事情都可以

48:19.900 --> 48:20.900
你可以技术

48:20.900 --> 48:21.900
你可以甚至什么都不做

48:22.900 --> 48:23.900
全是同步代码都可以

48:24.900 --> 48:25.900
随便你

48:25.900 --> 48:26.900
总之你告诉它任务

48:26.900 --> 48:27.900
到底什么时候成功

48:27.900 --> 48:28.900
什么时候失败就行了

48:29.900 --> 48:30.900
就是描述一个任务

48:30.900 --> 48:31.900
得到的是什么呢

48:31.900 --> 48:32.900
得到的是个任务对象

48:32.900 --> 48:33.900
你看

48:33.900 --> 48:34.900
现在这一部分

48:34.900 --> 48:35.900
是不是已经搞定了

48:35.900 --> 48:36.900
这一部分已经搞定了

48:36.900 --> 48:37.900
还有什么没搞定的

48:37.900 --> 48:38.900
已经全部搞定了

48:40.900 --> 48:41.900
那么现在我们要关注

48:41.900 --> 48:42.900
另外一件事

48:46.470 --> 48:47.470
任务成功之后

48:47.470 --> 48:48.470
我要干嘛

48:48.470 --> 48:49.470
我现在描述了一个任务

48:49.470 --> 48:50.470
在这里面

48:51.470 --> 48:52.470
那么任务成功之后

48:52.470 --> 48:53.470
我要干嘛

48:53.470 --> 48:54.470
失败之后要干嘛

48:54.470 --> 48:56.470
我怎么来描述这一点呢

48:56.470 --> 48:57.470
它不是在任务的

48:57.470 --> 48:58.470
这里描述的

48:58.470 --> 48:59.470
因为这里

48:59.470 --> 49:00.470
就是promise的全部

49:02.470 --> 49:03.470
它是分成两块的

49:03.470 --> 49:05.470
后续处理是后续处理

49:06.470 --> 49:07.470
任务是任务

49:07.470 --> 49:08.470
任务只管状态

49:09.470 --> 49:10.470
那么这个任务

49:10.470 --> 49:11.470
成功之后要干嘛

49:11.470 --> 49:13.470
我怎么来描述它呢

49:13.470 --> 49:17.910
通过这个promise对象里边

49:17.910 --> 49:19.910
它可以提供了一些函数

49:19.910 --> 49:20.910
其中一个函数叫做

49:20.910 --> 49:21.910
任

49:21.910 --> 49:28.630
这个函数里边传啥呢

49:28.630 --> 49:29.630
传的就是

49:29.630 --> 49:30.630
成功之后

49:31.630 --> 49:32.630
你要干嘛

49:32.630 --> 49:38.590
任务

49:39.590 --> 49:41.590
任务完成了

49:41.590 --> 49:42.590
我就说出这么一句话

49:42.590 --> 49:44.590
成功之后我要干嘛

49:45.590 --> 49:46.590
大家想一想

49:47.590 --> 49:48.590
按照逻辑来想一想

49:49.590 --> 49:50.590
这个地方

49:51.590 --> 49:56.180
可不可以有参数

49:56.180 --> 49:57.180
自己想

49:58.180 --> 49:59.180
这个地方

49:59.180 --> 50:03.520
可不可以有参数

50:03.520 --> 50:08.430
那你觉得参数是啥

50:08.430 --> 50:09.430
参数啥意思

50:09.430 --> 50:10.430
这就是数据

50:10.430 --> 50:11.430
对不对

50:11.430 --> 50:12.430
你看这个图

50:12.430 --> 50:13.430
你把概念

50:13.430 --> 50:14.430
你也清楚过

50:14.430 --> 50:15.430
这些东西并不难

50:15.430 --> 50:17.430
那么这个data就是数据

50:17.430 --> 50:19.430
任务数据

50:19.430 --> 50:21.430
数据是咱们的data

50:21.430 --> 50:22.430
那么你觉得

50:22.430 --> 50:23.430
现在data输出什么

50:23.430 --> 50:27.060
你觉得data输出啥

50:27.060 --> 50:28.060
你觉得现在的data输出啥

50:28.060 --> 50:33.900
是不是undefined

50:33.900 --> 50:34.900
对不对

50:34.900 --> 50:35.900
为什么呢

50:35.900 --> 50:36.900
因为我这里完成任务的时候

50:36.900 --> 50:37.900
啥都没给他

50:37.900 --> 50:39.900
那么你这里数据自然啥都没有

50:39.900 --> 50:40.900
你看这个图

50:40.900 --> 50:41.900
新一边装了这个图

50:41.900 --> 50:43.900
以后就不要看我的课件了

50:43.900 --> 50:45.900
但是任务成功之后

50:45.900 --> 50:46.900
这里是undefined

50:46.900 --> 50:47.900
自然这里就是undefined

50:47.900 --> 50:48.900
所以说这里我们看一下

50:48.900 --> 50:49.900
放心

50:49.900 --> 50:50.900
任务完成了

50:50.900 --> 50:51.900
数据undefined

50:51.900 --> 50:52.900
对不对

50:52.900 --> 50:53.900
好

50:53.900 --> 50:54.900
然后如果说我这里

50:54.900 --> 50:55.900
该传那个数据

50:55.900 --> 50:56.900
传一个123

50:56.900 --> 50:57.900
随便写吧

50:58.900 --> 50:59.900
放心

50:59.900 --> 51:00.900
就是123

51:00.900 --> 51:01.900
对吧

51:01.900 --> 51:02.900
你可以传任何东西

51:02.900 --> 51:03.900
你可以传第二类型

51:03.900 --> 51:04.900
你可以传个对象

51:04.900 --> 51:05.900
你可以传任何东西

51:06.900 --> 51:07.900
就是1000

51:07.900 --> 51:08.900
对吧

51:08.900 --> 51:09.900
一千毫秒

51:09.900 --> 51:10.900
我等待了一千毫秒

51:10.900 --> 51:12.900
123是任

51:12.900 --> 51:13.900
那么

51:13.900 --> 51:14.900
开车包呢

51:14.900 --> 51:16.900
你不说任务失败呢

51:16.900 --> 51:18.900
任务失败的函数呢

51:18.900 --> 51:19.900
你可以写为第二个参数

51:20.900 --> 51:21.900
叫做reason

51:22.900 --> 51:24.900
到底为什么失败

51:24.900 --> 51:25.900
我们输出

51:26.900 --> 51:31.210
任务失败

51:31.210 --> 51:32.210
这里是

51:33.210 --> 51:35.210
任务原因

51:36.210 --> 51:37.210
为止

51:37.210 --> 51:38.210
那么我这里任务

51:38.210 --> 51:39.210
是不可能失败的对吧

51:39.210 --> 51:40.210
你会说说这个

51:40.210 --> 51:42.210
这个函数是永远不可能执行的

51:42.210 --> 51:44.210
这个是任务成功之后执行

51:44.210 --> 51:46.210
这个是失败之后执行

51:46.210 --> 51:47.210
相当于是这里的

51:48.210 --> 51:49.210
这里的renable

51:49.210 --> 51:50.210
和catchable

51:50.210 --> 51:51.210
对不对

51:51.210 --> 51:52.210
那么我这里不可能失败

51:52.210 --> 51:53.210
所以说永远不可能执行

51:53.210 --> 51:54.210
那个任务失败

51:54.210 --> 51:55.210
那么我这里

51:55.210 --> 51:56.210
稍微改一下

51:56.210 --> 51:57.210
稍微的随便改一下

51:58.210 --> 51:59.210
判了一下吧

51:59.210 --> 52:00.210
mysred

52:00.210 --> 52:02.210
小于0.5

52:02.210 --> 52:03.210
给他的水击数

52:04.210 --> 52:05.210
50%的击率成功

52:06.210 --> 52:08.210
50%的击率失败

52:08.210 --> 52:09.210
回接个词

52:09.210 --> 52:10.210
这样说

52:10.210 --> 52:12.210
我就随便拿一个吧

52:12.210 --> 52:13.210
一个失败

52:13.210 --> 52:14.210
失败我就随便拿一个

52:16.210 --> 52:17.210
623

52:18.210 --> 52:19.210
好 你看一下吧

52:20.210 --> 52:21.210
放心

52:22.210 --> 52:23.210
失败了 任务原因

52:23.210 --> 52:24.210
123

52:24.210 --> 52:25.210
那么现在是不是没有运行

52:25.210 --> 52:26.210
这个函数

52:26.210 --> 52:27.210
运行这个函数了

52:27.210 --> 52:28.210
就这么简单

52:28.210 --> 52:29.210
有多复杂呢

52:29.210 --> 52:31.210
它的基本使用非常简单

52:31.210 --> 52:32.210
另外呢

52:32.210 --> 52:34.210
这是Promise A加规范

52:34.210 --> 52:35.210
我现在看到的

52:35.210 --> 52:37.210
大家看到的全是Promise A加规范规定的

52:37.210 --> 52:38.210
它必须要有任函数

52:38.210 --> 52:39.210
任函数呢

52:39.210 --> 52:40.210
可以有一个参数

52:40.210 --> 52:41.210
可以有两个参数

52:41.210 --> 52:42.210
都是Promise A加规范规定的

52:42.210 --> 52:43.210
那么其中有一个呢

52:43.210 --> 52:44.210
就是Promise A加规范

52:44.210 --> 52:45.210
没有规定的

52:46.210 --> 52:47.210
但是ES6呢

52:47.210 --> 52:48.210
还觉得

52:48.210 --> 52:50.210
这样子设计比较好一点

52:50.210 --> 52:51.210
它一定做了

52:51.210 --> 52:52.210
什么意思呢

52:52.210 --> 52:53.210
就是说

52:53.210 --> 52:54.210
它还给你提供了

52:54.210 --> 52:55.210
另外一个函数

52:57.900 --> 52:58.900
这个关于

52:58.900 --> 52:59.900
相当于是失败的时候

52:59.900 --> 53:00.900
运行的函数

53:00.900 --> 53:05.200
任务失败

53:06.200 --> 53:07.200
失败原因

53:08.200 --> 53:09.200
一样的

53:11.200 --> 53:12.200
任务失败了

53:13.200 --> 53:14.200
那么这里边

53:14.200 --> 53:15.200
还有一些细微的差异

53:15.200 --> 53:16.200
比方说

53:16.200 --> 53:17.200
调用这个函数的话

53:18.200 --> 53:19.200
仍然会在空置

53:19.200 --> 53:20.200
才可以打印出来

53:20.200 --> 53:21.200
可以打印出来

53:22.200 --> 53:26.200
这就是Promise的基本使用

53:27.200 --> 53:29.510
然后还有吗

53:29.510 --> 53:31.510
还有一个小的点

53:31.510 --> 53:32.510
就是关于这个

53:32.510 --> 53:33.510
拒绝

53:34.510 --> 53:35.510
这个函数

53:35.510 --> 53:36.510
因为这个函数

53:36.510 --> 53:37.510
这个状态有的时候

53:37.510 --> 53:39.510
你没有调用这个函数

53:39.510 --> 53:41.510
但是仍然有可能会导致

53:41.510 --> 53:43.510
它处于被拒绝的状态

53:43.510 --> 53:44.510
什么情况呢

53:44.510 --> 53:45.510
给大家看一个

53:46.510 --> 53:47.510
看个例子

53:48.510 --> 53:50.510
我这里就下写了

53:50.510 --> 53:51.510
就下写一个

53:52.510 --> 53:53.510
今天晚上

53:53.510 --> 53:54.510
可能没有时间

53:54.510 --> 53:55.510
去做实战演练了

53:55.510 --> 53:56.510
就是说

53:56.510 --> 53:57.510
我们举个例子

53:57.510 --> 53:58.510
举个案例

53:58.510 --> 53:59.510
来做一个实战演练

53:59.510 --> 54:00.510
没有时间了

54:00.510 --> 54:01.510
我们主要是为了

54:01.510 --> 54:02.510
一封面试敌

54:02.510 --> 54:03.510
那这个东西

54:03.510 --> 54:04.510
不能光一封面试敌

54:04.510 --> 54:05.510
你们以后

54:05.510 --> 54:06.510
你还得去

54:06.510 --> 54:07.510
这个我们以后

54:07.510 --> 54:08.510
再开发东西

54:08.510 --> 54:09.510
经常使用的

54:10.510 --> 54:11.510
我们这样写

54:11.510 --> 54:12.510
比方说

54:12.510 --> 54:13.510
我就这里写

54:13.510 --> 54:14.510
说

54:14.510 --> 54:15.510
逃出一个异常

54:16.510 --> 54:17.510
你别说

54:18.510 --> 54:19.510
逃出一个异常

54:23.020 --> 54:24.020
好看一下

54:24.020 --> 54:25.020
得到一个Promise

54:25.020 --> 54:26.020
我开始执行任务

54:26.020 --> 54:27.020
但是任务

54:27.020 --> 54:28.020
马上就爆错了

54:28.020 --> 54:29.020
对不对

54:29.020 --> 54:30.020
那么现在

54:30.020 --> 54:31.020
只要一爆错

54:31.020 --> 54:33.020
后边我都不用去看后续了

54:33.020 --> 54:34.020
后续都不用去管

54:34.020 --> 54:35.020
只要一爆错

54:35.020 --> 54:37.020
在任务的执行期间

54:38.020 --> 54:39.020
只要一爆错

54:40.020 --> 54:41.020
那么这个任务的状态

54:41.020 --> 54:42.020
他会自动变成

54:42.020 --> 54:43.020
rejected

54:44.020 --> 54:45.020
数据呢

54:45.020 --> 54:47.020
还有自动变成错误对象

54:47.020 --> 54:48.020
你看这里不是

54:48.020 --> 54:49.020
抛出的错误对象吗

54:49.020 --> 54:50.020
那么这个数据变成错误对象

54:50.020 --> 54:51.020
那你这个抛

54:51.020 --> 54:52.020
抛出来不是错误对象

54:52.020 --> 54:53.020
抛出来是123

54:55.020 --> 54:56.020
那他会变成123的

54:57.020 --> 54:58.020
rejected

54:58.020 --> 54:59.020
数据为123

54:59.020 --> 55:00.020
什么意思

55:00.020 --> 55:01.020
你可以有的时候

55:01.020 --> 55:02.020
你没有交用rejected

55:02.020 --> 55:03.020
他仍然可能会出现

55:03.020 --> 55:04.020
那个拒绝状态

55:04.020 --> 55:05.020
那么如果说

55:05.020 --> 55:06.020
现在现在我们

55:06.020 --> 55:07.020
把这个俩给大家加上

55:07.020 --> 55:08.020
他输出什么

55:08.020 --> 55:09.020
输出任务失败了

55:10.020 --> 55:11.020
对任务失败了

55:11.020 --> 55:12.020
数据为123

55:12.020 --> 55:13.020
就这么简单

55:13.020 --> 55:14.020
还有一种情况

55:14.020 --> 55:15.020
就是你自己没有

55:15.020 --> 55:16.020
抛出错误

55:16.020 --> 55:17.020
但是呢

55:17.020 --> 55:18.020
他代码爆错了

55:18.020 --> 55:19.020
是不是一样的道理

55:20.020 --> 55:21.020
啊

55:21.020 --> 55:22.020
代码什么时候爆错

55:22.020 --> 55:23.020
n

55:23.020 --> 55:24.020
就变了一个纳

55:25.020 --> 55:26.020
不就爆错了吗

55:27.020 --> 55:28.020
对对

55:28.020 --> 55:29.020
不就爆错了吗

55:29.020 --> 55:30.020
任务失败了

55:30.020 --> 55:31.020
数据是什么呢

55:31.020 --> 55:32.020
数据是抛出来的

55:32.020 --> 55:33.020
错误对象

55:33.020 --> 55:34.020
type error

55:34.020 --> 55:35.020
无法从一个码号里边

55:35.020 --> 55:36.020
主题出现

55:36.020 --> 55:37.020
主题

55:37.020 --> 55:39.020
所以说我们总结一下的话

55:39.020 --> 55:40.020
promise

55:42.020 --> 55:43.020
他有可能达到任务

55:43.020 --> 55:44.020
rejected的状态

55:44.020 --> 55:45.020
拿出什么情况

55:45.020 --> 55:46.020
调用rejected

55:46.020 --> 55:47.020
rejected

55:47.020 --> 55:48.020
代码爆错

55:48.020 --> 55:49.020
或者是

55:49.020 --> 55:50.020
抛出错误

55:50.020 --> 55:51.020
对不对

55:51.020 --> 55:52.020
其实这里边还有细节

55:52.020 --> 55:53.020
还有细节

55:53.020 --> 55:54.020
啊

55:54.020 --> 55:55.020
我们今天不去深究了

55:55.020 --> 55:56.020
我们讲最核心的东西

55:57.020 --> 55:58.020
好

55:58.020 --> 55:59.020
这一块有什么问题

55:59.020 --> 56:00.020
我们讲慢一点

56:01.020 --> 56:02.020
没问题QQE

56:02.020 --> 56:03.020
有问题的话就提问题

56:03.020 --> 56:11.410
好了没问题的话

56:11.410 --> 56:13.410
我们来看一下今天的面试题

56:14.410 --> 56:15.410
一共就两道题

56:15.410 --> 56:16.410
两道题做完过后

56:16.410 --> 56:17.410
还有点时间

56:17.410 --> 56:18.410
我们就介绍一下更多的知识

56:18.410 --> 56:20.410
promise还有很多细节知识

56:20.410 --> 56:21.410
地道题

56:21.410 --> 56:22.410
输出啥

56:22.410 --> 56:23.410
promise里边考察的知识

56:23.410 --> 56:25.410
往往是跟事件循环

56:26.410 --> 56:27.410
一起来考的

56:27.410 --> 56:28.410
而且呢

56:28.410 --> 56:29.410
他一般是代码题

56:29.410 --> 56:31.410
他一般不是问答题

56:31.410 --> 56:33.410
问答题考这个有点弱智

56:33.410 --> 56:35.410
一般是代码题

56:35.410 --> 56:36.410
看一下地理

56:36.410 --> 56:42.370
输出啥

56:44.370 --> 56:45.370
一

56:46.370 --> 56:47.370
对

56:47.370 --> 56:48.370
不好意思

56:48.370 --> 56:49.370
不好意思

56:49.370 --> 56:50.370
还有一个点

56:50.370 --> 56:51.370
还有一个点没有讲

56:51.370 --> 56:53.370
不然这个题你抓不出来的

56:53.370 --> 56:54.370
还有点就是

56:55.370 --> 56:57.370
promise的任务

56:57.370 --> 56:59.370
启动函数是同步的

56:59.370 --> 57:00.370
立即执行的

57:02.940 --> 57:03.940
但是

57:03.940 --> 57:05.940
它的后续处理是一步的

57:08.760 --> 57:09.760
它的后续处理

57:10.760 --> 57:11.760
这

57:11.760 --> 57:12.760
这个函数

57:12.760 --> 57:13.760
是一步的

57:14.760 --> 57:15.760
啥意思呢

57:15.760 --> 57:16.760
给他举个例子

57:16.760 --> 57:21.120
看着啊

57:22.120 --> 57:23.120
输出一

57:24.120 --> 57:25.120
这里输出二

57:27.750 --> 57:28.750
然后呢

57:28.750 --> 57:31.510
这里result

57:31.510 --> 57:32.510
proz

57:32.510 --> 57:35.210
输出三

57:36.210 --> 57:37.210
输出四

57:39.210 --> 57:40.210
对他怎么理解

57:40.210 --> 57:41.210
你看着啊

57:41.210 --> 57:42.210
他要这样的理解

57:42.210 --> 57:43.210
首先开启一个任务

57:43.210 --> 57:44.210
马上执行这个任务

57:44.210 --> 57:45.210
输出了一

57:46.210 --> 57:47.210
对不对

57:48.210 --> 57:49.210
我们来打开这个

57:50.210 --> 57:51.210
现在proz

57:51.210 --> 57:52.210
输出了一

57:52.210 --> 57:54.210
现在我们就空彩有个一

57:54.210 --> 57:55.210
然后呢

57:55.210 --> 57:59.930
我们来看一下我们的事件循环

57:59.930 --> 58:00.930
现在呢

58:00.930 --> 58:01.930
我们的红队的

58:02.930 --> 58:03.930
微队的

58:05.930 --> 58:06.930
来吧

58:06.930 --> 58:07.930
输出一个一

58:07.930 --> 58:08.930
现在我们的promise

58:08.930 --> 58:09.930
是什么状态呢

58:09.930 --> 58:11.930
目前还是平顶状态

58:11.930 --> 58:12.930
对不对

58:12.930 --> 58:13.930
平顶状态

58:14.930 --> 58:15.930
接下来result

58:15.930 --> 58:16.930
一定要用是不是

58:16.930 --> 58:17.930
把它状态改了

58:17.930 --> 58:18.930
改成了什么

58:18.930 --> 58:19.930
改成了result

58:20.930 --> 58:21.930
对不对

58:21.930 --> 58:22.930
好

58:22.930 --> 58:23.930
接下来继续运行

58:23.930 --> 58:24.930
输出二

58:26.930 --> 58:27.930
一二

58:27.930 --> 58:28.930
然后现在

58:28.930 --> 58:29.930
现在有一个函数

58:29.930 --> 58:30.930
一个回调函数

58:30.930 --> 58:32.930
任务成功之后

58:32.930 --> 58:34.930
我会运行这个函数

58:34.930 --> 58:35.930
现在任务是不是已经成功了

58:36.930 --> 58:37.930
那现在运行吧

58:37.930 --> 58:38.930
不好意思

58:38.930 --> 58:39.930
现在不能运行

58:39.930 --> 58:40.930
因为它是异步的

58:40.930 --> 58:42.930
它会把这个函数推向微队的

58:43.930 --> 58:44.930
输出三

58:44.930 --> 58:45.930
输出三这个函数

58:45.930 --> 58:46.930
它会推向微队的

58:46.930 --> 58:47.930
因为它已经成功了

58:47.930 --> 58:48.930
对吧

58:48.930 --> 58:49.930
已经成功了

58:49.930 --> 58:50.930
它会到微队的

58:50.930 --> 58:51.930
等待执行

58:51.930 --> 58:52.930
如果它失败了

58:52.930 --> 58:53.930
它就不会推向微队的

58:54.930 --> 58:55.930
因为它已经成功了

58:55.930 --> 58:56.930
所以说

58:56.930 --> 58:57.930
这个时候

58:57.930 --> 58:58.930
它会推向微队的

58:58.930 --> 58:59.930
然后输出四

59:00.930 --> 59:01.930
好

59:01.930 --> 59:02.930
全球范围结束了

59:03.930 --> 59:04.930
发现微队里面有东西

59:04.930 --> 59:05.930
对吧

59:05.930 --> 59:06.930
输出三

59:06.930 --> 59:08.930
所以这个结构是一二四三

59:08.930 --> 59:09.930
再看一下

59:11.930 --> 59:12.930
这是

59:12.930 --> 59:13.930
这个音性

59:17.200 --> 59:18.200
一二四三

59:18.200 --> 59:19.200
完了

59:19.200 --> 59:20.200
咱们再看这个题

59:20.200 --> 59:21.200
刚刚把这个点忘了

59:21.200 --> 59:22.200
再看这个题

59:22.200 --> 59:23.200
变成题

59:35.980 --> 59:39.770
这个时候是哪来的

59:39.770 --> 59:40.770
所以一四A

59:40.770 --> 59:41.770
对不对

59:41.770 --> 59:42.770
就非常简单了

59:42.770 --> 59:43.770
对吧

59:44.770 --> 59:45.770
注意

59:45.770 --> 59:46.770
这个东西你看都不要看

59:46.770 --> 59:47.770
你看都不要看

59:47.770 --> 59:48.770
只要装

59:48.770 --> 59:49.770
不

59:49.770 --> 59:50.770
有问题

59:50.770 --> 59:51.770
应该是什么

59:51.770 --> 59:52.770
一二四A

59:53.770 --> 59:54.770
一二四A

59:54.770 --> 59:55.770
这个

59:55.770 --> 59:56.770
球范围说的是对的

59:56.770 --> 59:57.770
一二四A

59:57.770 --> 59:58.770
你看下来

59:59.770 --> 01:00:00.770
一二四A

01:00:01.770 --> 01:00:02.770
为什么呢

01:00:02.770 --> 01:00:03.770
是一样的

01:00:03.770 --> 01:00:05.770
一开始立即执行

01:00:05.770 --> 01:00:06.770
立即执行

01:00:06.770 --> 01:00:07.770
然后输出什么

01:00:07.770 --> 01:00:08.770
输出一

01:00:08.770 --> 01:00:10.770
然后照状态变成了

01:00:10.770 --> 01:00:11.770
状态变成了Fulfilled

01:00:11.770 --> 01:00:12.770
对吧

01:00:12.770 --> 01:00:13.770
状态变成了Fulfilled

01:00:13.770 --> 01:00:16.140
好

01:00:16.140 --> 01:00:17.140
数据是什么

01:00:17.140 --> 01:00:18.140
数据是A

01:00:18.140 --> 01:00:19.140
那么后边还想改状态

01:00:19.140 --> 01:00:20.140
没用了

01:00:20.140 --> 01:00:21.140
改不了了

01:00:21.140 --> 01:00:22.140
还想改状态

01:00:22.140 --> 01:00:23.140
没用了

01:00:23.140 --> 01:00:24.140
改不了了

01:00:24.140 --> 01:00:25.140
然后呢

01:00:25.140 --> 01:00:26.140
又输出二

01:00:26.140 --> 01:00:27.140
代码还是要执行了

01:00:27.140 --> 01:00:28.140
输出二

01:00:28.140 --> 01:00:29.140
好

01:00:29.140 --> 01:00:30.140
接下来

01:00:30.140 --> 01:00:31.140
也有一个毁掉函数

01:00:31.140 --> 01:00:32.140
对吧

01:00:32.140 --> 01:00:33.140
后续处理

01:00:33.140 --> 01:00:34.140
围队的数第一个

01:00:34.140 --> 01:00:35.140
它成功了

01:00:35.140 --> 01:00:37.140
所以它第一个输出什么

01:00:37.140 --> 01:00:38.140
输出data那个东西

01:00:38.140 --> 01:00:39.140
要进入围队的

01:00:39.140 --> 01:00:40.140
对不对

01:00:40.140 --> 01:00:41.140
好

01:00:41.140 --> 01:00:42.140
于是呢

01:00:42.140 --> 01:00:43.140
继续输出4

01:00:43.140 --> 01:00:44.140
好

01:00:44.140 --> 01:00:45.140
然后现在没东西了

01:00:45.140 --> 01:00:46.140
围队的打出来

01:00:46.140 --> 01:00:47.140
输出data

01:00:47.140 --> 01:00:48.140
data是啥

01:00:48.140 --> 01:00:49.140
data不就是数据A吗

01:00:49.140 --> 01:00:50.140
输出数据A

01:00:50.140 --> 01:00:51.140
一二四A

01:00:51.140 --> 01:00:52.140
没问题吧

01:00:52.140 --> 01:00:53.140
好

01:00:53.140 --> 01:00:54.140
只是这道题

01:00:54.140 --> 01:00:55.140
好

01:00:55.140 --> 01:00:56.140
下面这道题

01:00:56.140 --> 01:00:57.140
又来

01:00:57.140 --> 01:00:58.140
这道题

01:00:58.140 --> 01:01:09.030
第二题

01:01:09.030 --> 01:01:10.030
看一下这道题

01:01:11.030 --> 01:01:12.030
嗯

01:01:12.030 --> 01:01:13.030
它有个谁

01:01:13.030 --> 01:01:14.030
它帽子还是说一起来玩的

01:01:14.030 --> 01:01:18.370
要考时间循环

01:01:18.370 --> 01:01:28.140
二七第三

01:01:28.140 --> 01:01:33.060
二五

01:01:33.060 --> 01:01:35.060
七五一

01:01:35.060 --> 01:01:37.060
答案开始各有不同了

01:01:37.060 --> 01:01:38.060
是吧

01:01:38.060 --> 01:01:41.840
好

01:01:41.840 --> 01:01:42.840
咱们来分析一下

01:01:43.840 --> 01:01:44.840
这东西一定要画图

01:01:44.840 --> 01:01:45.840
特别是用代码多了

01:01:45.840 --> 01:01:46.840
你一定要画图

01:01:46.840 --> 01:01:47.840
不然你蒙的

01:01:48.840 --> 01:01:50.840
一个人一个答案

01:01:50.840 --> 01:01:51.840
可以

01:01:51.840 --> 01:01:52.840
咱们来看一下

01:01:52.840 --> 01:01:53.840
哪个同学是对的

01:01:53.840 --> 01:01:54.840
我也不知道

01:01:55.840 --> 01:01:57.840
首先红队列准备好图

01:01:57.840 --> 01:01:58.840
拿一张纸出来

01:01:58.840 --> 01:01:59.840
以后你做的问题

01:01:59.840 --> 01:02:01.840
千万不要在脑袋里面想

01:02:01.840 --> 01:02:02.840
这种地方你能

01:02:02.840 --> 01:02:04.840
你听到我的就业课

01:02:04.840 --> 01:02:05.840
你能够做得出来的

01:02:05.840 --> 01:02:06.840
你把分丢了

01:02:06.840 --> 01:02:07.840
很划不来的

01:02:07.840 --> 01:02:08.840
它有鬼子道理

01:02:08.840 --> 01:02:09.840
是你出心大意的

01:02:09.840 --> 01:02:10.840
它就认为你不会

01:02:11.840 --> 01:02:12.840
把它画出来

01:02:13.840 --> 01:02:14.840
那么pro的状态

01:02:14.840 --> 01:02:15.840
对吧

01:02:15.840 --> 01:02:16.840
画出来

01:02:16.840 --> 01:02:17.840
红队列

01:02:17.840 --> 01:02:18.840
v队列

01:02:18.840 --> 01:02:19.840
一开始哪个谁拆帽子

01:02:19.840 --> 01:02:20.840
要输出e

01:02:20.840 --> 01:02:21.840
是进红队列

01:02:21.840 --> 01:02:22.840
对不对

01:02:22.840 --> 01:02:23.840
要输出e

01:02:23.840 --> 01:02:24.840
然后继续

01:02:24.840 --> 01:02:25.840
创建了一个promise

01:02:25.840 --> 01:02:27.840
创建了一个promise

01:02:27.840 --> 01:02:28.840
然后马上运行

01:02:28.840 --> 01:02:29.840
就输出

01:02:29.840 --> 01:02:30.840
输出什么

01:02:30.840 --> 01:02:31.840
输出e

01:02:31.840 --> 01:02:32.840
然后状态变成什么

01:02:32.840 --> 01:02:34.840
状态变成fulfilled

01:02:35.840 --> 01:02:37.840
数据是3

01:02:37.840 --> 01:02:38.840
对不对

01:02:38.840 --> 01:02:39.840
数据是3

01:02:39.840 --> 01:02:41.840
那么以后想改变状态不可能了

01:02:41.840 --> 01:02:42.840
继续

01:02:42.840 --> 01:02:43.840
又输出4

01:02:44.840 --> 01:02:45.840
对不对

01:02:45.840 --> 01:02:50.370
继续拋出一个5

01:02:50.370 --> 01:02:51.370
它能够进入

01:02:51.370 --> 01:02:52.370
我问一下大家

01:02:52.370 --> 01:02:54.370
这个地方能改变状态吗

01:02:55.370 --> 01:02:56.370
拋出一个5

01:02:56.370 --> 01:03:01.980
能不能改变状态

01:03:01.980 --> 01:03:03.980
它能不能改变状态

01:03:03.980 --> 01:03:04.980
状态一旦确定

01:03:04.980 --> 01:03:06.980
是永远无法改变的

01:03:06.980 --> 01:03:07.980
不能改变状态

01:03:07.980 --> 01:03:08.980
但这就说代码

01:03:08.980 --> 01:03:09.980
要不要执行

01:03:09.980 --> 01:03:10.980
肯定要执行

01:03:10.980 --> 01:03:11.980
它不可能不执行

01:03:11.980 --> 01:03:12.980
一执行干嘛

01:03:12.980 --> 01:03:13.980
爆出了

01:03:13.980 --> 01:03:14.980
对吧

01:03:14.980 --> 01:03:15.980
爆出了干嘛

01:03:15.980 --> 01:03:16.980
爆出了干嘛

01:03:16.980 --> 01:03:18.980
爆出了就是

01:03:18.980 --> 01:03:20.980
它这个代码停在这

01:03:20.980 --> 01:03:21.980
对不对

01:03:21.980 --> 01:03:22.980
它不再往后执行了

01:03:22.980 --> 01:03:24.980
不再执行后边了

01:03:24.980 --> 01:03:26.980
输出6是不是不执行了

01:03:26.980 --> 01:03:28.980
不执行它爆出了嘛

01:03:28.980 --> 01:03:29.980
然后呢

01:03:29.980 --> 01:03:30.980
输出7

01:03:30.980 --> 01:03:31.980
对吧

01:03:31.980 --> 01:03:33.980
外面来进去输出7

01:03:33.980 --> 01:03:36.490
然后呢

01:03:36.490 --> 01:03:38.490
到这边来

01:03:38.490 --> 01:03:40.490
这边到底是成功还是失败

01:03:40.490 --> 01:03:41.490
成功嘛

01:03:41.490 --> 01:03:42.490
所以说把这个函数推向

01:03:42.490 --> 01:03:43.490
怎么围队的

01:03:43.490 --> 01:03:44.490
输出什么

01:03:44.490 --> 01:03:45.490
也就是输出data

01:03:45.490 --> 01:03:46.490
推向输出3

01:03:46.490 --> 01:03:47.490
推向围队的

01:03:47.490 --> 01:03:48.490
围队那边

01:03:48.490 --> 01:03:49.490
现在东西没了

01:03:49.490 --> 01:03:50.490
对吧

01:03:50.490 --> 01:03:51.490
围队那边拿出来

01:03:51.490 --> 01:03:52.490
输出3

01:03:52.490 --> 01:03:53.490
然后再拿出红队的

01:03:53.490 --> 01:03:54.490
输出1

01:03:54.490 --> 01:04:00.380
2731

01:04:00.380 --> 01:04:02.380
2731

01:04:02.380 --> 01:04:03.380
对不对

01:04:04.380 --> 01:04:05.380
就这一块

01:04:06.380 --> 01:04:07.380
中间这个是

01:04:07.380 --> 01:04:08.380
它反过来对象

01:04:08.380 --> 01:04:09.380
是个浏览器

01:04:09.380 --> 01:04:10.380
它有表达是反过来对象

01:04:10.380 --> 01:04:11.380
你不用管

01:04:11.380 --> 01:04:12.380
它是这一块

01:04:14.700 --> 01:04:15.700
好那么

01:04:15.700 --> 01:04:16.700
你们以后遇到的

01:04:16.700 --> 01:04:17.700
Promise的面试体呢

01:04:17.700 --> 01:04:18.700
基本面试体呢

01:04:18.700 --> 01:04:19.700
就这些

01:04:19.700 --> 01:04:20.700
但是呢

01:04:20.700 --> 01:04:22.700
它有可能比较复杂的面试体

01:04:22.700 --> 01:04:23.700
如果说你要遇到

01:04:23.700 --> 01:04:24.700
比较复杂的面试体

01:04:24.700 --> 01:04:25.700
要会做的话

01:04:25.700 --> 01:04:26.700
还需要更多的

01:04:26.700 --> 01:04:27.700
Promise的细节知识

01:04:27.700 --> 01:04:29.700
我今天肯定是讲不完了

01:04:29.700 --> 01:04:30.700
这个需要

01:04:30.700 --> 01:04:31.700
你看我后边还有好几页课

01:04:31.700 --> 01:04:32.700
才能讲得完的

01:04:32.700 --> 01:04:33.700
Promise里边的一些

01:04:33.700 --> 01:04:34.700
经常函数啊

01:04:34.700 --> 01:04:35.700
还有电视调用啊

01:04:35.700 --> 01:04:36.700
这些东西

01:04:36.700 --> 01:04:37.700
我这里给它过一下

01:04:37.700 --> 01:04:38.700
过一下

01:04:38.700 --> 01:04:39.700
给它感觉一下

01:04:39.700 --> 01:04:40.700
有些东西的话

01:04:40.700 --> 01:04:41.700
还是没有想到

01:04:41.700 --> 01:04:42.700
把最重要的

01:04:42.700 --> 01:04:43.700
后边的重要点

01:04:43.700 --> 01:04:44.700
给它说一下

01:04:44.700 --> 01:04:45.700
就Promise的

01:04:45.700 --> 01:04:46.700
第一个Promise可以

01:04:46.700 --> 01:04:47.700
电视调用

01:04:47.700 --> 01:04:48.700
啥意思呢

01:04:48.700 --> 01:04:49.700
你这个任函数

01:04:49.700 --> 01:04:51.700
它是有返回值的

01:04:51.700 --> 01:04:52.700
你这个任函数

01:04:52.700 --> 01:04:53.700
它是有返回值的

01:04:53.700 --> 01:04:54.700
这个玩意儿

01:04:54.700 --> 01:04:55.700
它会

01:04:55.700 --> 01:04:56.700
这是函数嘛

01:04:56.700 --> 01:04:57.700
调用过是不是有返回

01:04:57.700 --> 01:04:58.700
它返回啥呢

01:04:58.700 --> 01:05:00.700
它返回一个新的Promise

01:05:01.700 --> 01:05:02.700
有意思吧

01:05:02.700 --> 01:05:03.700
它返回一个新的Promise

01:05:03.700 --> 01:05:04.700
这个新

01:05:04.700 --> 01:05:05.700
它听听就行了

01:05:05.700 --> 01:05:06.700
因为这个东西

01:05:06.700 --> 01:05:08.700
还要具体的课程来学习的

01:05:08.700 --> 01:05:10.700
而且还比较糟

01:05:10.700 --> 01:05:11.700
这个新的Promise

01:05:11.700 --> 01:05:13.700
它的状态是什么呢

01:05:13.700 --> 01:05:15.700
取决于

01:05:15.700 --> 01:05:17.700
这个Promise的状态

01:05:17.700 --> 01:05:18.700
它是Pending的时候

01:05:18.700 --> 01:05:20.700
它就是Pending

01:05:20.700 --> 01:05:22.700
而它完成过后呢

01:05:22.700 --> 01:05:23.700
有这么两种情况

01:05:23.700 --> 01:05:24.700
它如果说完成了

01:05:24.700 --> 01:05:25.700
或者是失败了

01:05:25.700 --> 01:05:26.700
它要运行相应的

01:05:26.700 --> 01:05:27.700
回调函数

01:05:27.700 --> 01:05:28.700
对吧

01:05:28.700 --> 01:05:29.700
关键看这个

01:05:29.700 --> 01:05:31.700
回调函数运行的期间

01:05:31.700 --> 01:05:32.700
有没有错误

01:05:32.700 --> 01:05:33.700
有错误

01:05:33.700 --> 01:05:34.700
它就是为解决体的

01:05:34.700 --> 01:05:35.700
没有错误

01:05:35.700 --> 01:05:37.700
它就是Resolved

01:05:37.700 --> 01:05:39.700
而是Fulfilled

01:05:39.700 --> 01:05:40.700
新Promise

01:05:40.700 --> 01:05:42.700
由于这个认函数

01:05:42.700 --> 01:05:43.700
或者是开启函数

01:05:43.700 --> 01:05:45.700
认函数看起来都是一样

01:05:45.700 --> 01:05:48.700
它会返回一个新的Promise

01:05:48.700 --> 01:05:49.700
于是呢

01:05:49.700 --> 01:05:50.700
这是一个Promise

01:05:50.700 --> 01:06:00.630
是不是它也可以认

01:06:00.630 --> 01:06:01.630
那么这又得调认

01:06:01.630 --> 01:06:03.630
那么这又是一个Promise

01:06:03.630 --> 01:06:05.630
是不是它也得认

01:06:05.630 --> 01:06:06.630
没有意思吧

01:06:06.630 --> 01:06:08.630
它是会形成电视调用

01:06:08.630 --> 01:06:11.630
还有这么一个规则

01:06:11.630 --> 01:06:12.630
那么比方说

01:06:12.630 --> 01:06:13.630
许个简单的例子

01:06:13.630 --> 01:06:14.630
你看这个

01:06:14.630 --> 01:06:16.630
我就随便来一个吧

01:06:16.630 --> 01:06:17.630
随便下来一个

01:06:17.630 --> 01:06:18.630
一

01:06:18.630 --> 01:06:21.630
pro

01:06:21.630 --> 01:06:22.630
z

01:06:22.630 --> 01:06:24.940
输出d

01:06:24.940 --> 01:06:25.940
对吧

01:06:25.940 --> 01:06:26.940
第一个Promise

01:06:26.940 --> 01:06:27.940
好 第一个Promise完成了

01:06:27.940 --> 01:06:29.940
而且在完成函数执行期间

01:06:29.940 --> 01:06:30.940
没有错误

01:06:30.940 --> 01:06:31.940
所以说这个Promise

01:06:31.940 --> 01:06:32.940
也是完成的

01:06:32.940 --> 01:06:35.940
R完成之后

01:06:36.940 --> 01:06:37.940
我输出d

01:06:37.940 --> 01:06:38.940
它完成之后

01:06:38.940 --> 01:06:41.940
我也输出d

01:06:41.940 --> 01:06:42.940
所以形成电视调用

01:06:42.940 --> 01:06:43.940
对吧

01:06:43.940 --> 01:06:44.940
怎么来读呢

01:06:44.940 --> 01:06:45.940
这个任务完成过后

01:06:45.940 --> 01:06:47.940
我干这件事情

01:06:47.940 --> 01:06:50.940
然后再干这件事情

01:06:50.940 --> 01:06:53.940
然后沾染后干这件事情

01:06:53.940 --> 01:06:57.450
就这么个意思

01:06:57.450 --> 01:06:58.450
那么为什么后面

01:06:58.450 --> 01:06:59.450
两个是undefined的呢

01:06:59.450 --> 01:07:00.450
因为后面的Promise

01:07:00.450 --> 01:07:01.450
它的数据

01:07:01.450 --> 01:07:02.450
取决于前一个Promise

01:07:02.450 --> 01:07:03.450
执行过程

01:07:03.450 --> 01:07:06.450
执行的返回结果

01:07:06.450 --> 01:07:07.450
我返回2

01:07:07.450 --> 01:07:09.450
我这个返回3

01:07:09.450 --> 01:07:11.450
对不对

01:07:11.450 --> 01:07:13.450
123

01:07:14.450 --> 01:07:15.450
它是这么一个东西

01:07:15.450 --> 01:07:16.450
它取决它的返回结果

01:07:16.450 --> 01:07:18.450
那么如果说你返回的是一个新的Promise

01:07:18.450 --> 01:07:20.450
一返回的又是一个Promise

01:07:20.450 --> 01:07:21.450
那么

01:07:21.450 --> 01:07:23.450
这里边细节特别多

01:07:23.450 --> 01:07:24.450
我就说一下

01:07:24.450 --> 01:07:25.450
里面以后还要

01:07:25.450 --> 01:07:26.450
详细地去学习的

01:07:26.450 --> 01:07:27.450
这东西别玩的

01:07:27.450 --> 01:07:28.450
它不是说几句话的

01:07:28.450 --> 01:07:29.450
有种搞定的

01:07:29.450 --> 01:07:30.450
如果说你返回一个新的Promise

01:07:30.450 --> 01:07:31.450
那么这个表达是

01:07:31.450 --> 01:07:32.450
它又是

01:07:32.450 --> 01:07:33.450
相当于是

01:07:33.450 --> 01:07:34.450
就是你返回的Promise

01:07:34.450 --> 01:07:35.450
其实这个东西

01:07:35.450 --> 01:07:36.450
在后面

01:07:36.450 --> 01:07:37.450
跟着我把Promise

01:07:37.450 --> 01:07:38.450
自己熟悉一边的话

01:07:38.450 --> 01:07:39.450
你啥都明白

01:07:41.450 --> 01:07:42.450
没有熟悉过的话

01:07:42.450 --> 01:07:44.450
你只能去记着这些规则

01:07:44.450 --> 01:07:45.450
有什么意思

01:07:46.450 --> 01:07:48.450
那么如果说你返回的是Promise

01:07:48.450 --> 01:07:49.450
Promise对象的话

01:07:49.450 --> 01:07:50.450
那么这里的数据

01:07:50.450 --> 01:07:52.450
就相当于是个Promise的

01:07:52.450 --> 01:07:53.450
完成的数据

01:07:53.450 --> 01:07:55.450
表示我干一个5

01:07:57.450 --> 01:07:58.450
那么这个就相当于是

01:07:58.450 --> 01:07:59.450
反过这里result的数据

01:07:59.450 --> 01:08:00.450
这一块就比较复杂了

01:08:00.450 --> 01:08:01.450
有点糟了

01:08:01.450 --> 01:08:03.450
它就是链式调用

01:08:03.450 --> 01:08:04.450
有的链式调用过后

01:08:05.450 --> 01:08:06.450
回掉韩数

01:08:06.450 --> 01:08:07.450
回掉地域就消除了

01:08:08.450 --> 01:08:09.450
你看

01:08:09.450 --> 01:08:10.450
这是我们一开始的

01:08:10.450 --> 01:08:11.450
回掉地域

01:08:12.450 --> 01:08:13.450
那么比方说我这里

01:08:13.450 --> 01:08:14.450
来模拟一下吧

01:08:14.450 --> 01:08:16.450
模拟一下个网络请求

01:08:16.450 --> 01:08:17.450
模拟一下个网络请求

01:08:17.450 --> 01:08:19.450
再来一个地面

01:08:19.450 --> 01:08:21.450
我这里就写个韩数

01:08:21.450 --> 01:08:22.450
叫做

01:08:24.450 --> 01:08:25.450
我就模拟一下

01:08:25.450 --> 01:08:26.450
瞎写的

01:08:26.450 --> 01:08:27.450
那么目前

01:08:27.450 --> 01:08:28.450
你们没有学习过

01:08:28.450 --> 01:08:29.450
网络请求对吧

01:08:29.450 --> 01:08:30.450
我现在也不知道

01:08:30.450 --> 01:08:31.450
请求啥地址

01:08:31.450 --> 01:08:32.450
你给我一个地址

01:08:32.450 --> 01:08:33.450
我就瞎写

01:08:33.450 --> 01:08:34.450
我这个韩数

01:08:34.450 --> 01:08:35.450
一个评论

01:08:35.450 --> 01:08:36.450
一个评论

01:08:36.450 --> 01:08:37.450
反归

01:08:37.450 --> 01:08:38.450
解决

01:08:39.450 --> 01:08:40.450
我就不解决

01:08:40.450 --> 01:08:41.450
全部都解决

01:08:42.450 --> 01:08:43.450
模拟这个网络请求

01:08:43.450 --> 01:08:44.450
要等待一段时间

01:08:44.450 --> 01:08:45.450
过后给你一个结果

01:08:45.450 --> 01:08:46.450
对吧

01:08:47.450 --> 01:08:48.450
要等待

01:08:48.450 --> 01:08:49.450
多少时间

01:08:49.450 --> 01:08:51.450
我写一个随机吧

01:08:54.450 --> 01:08:55.450
对对

01:08:55.450 --> 01:08:56.450
乘一个啥

01:08:56.450 --> 01:08:57.450
乘一个

01:08:57.450 --> 01:08:58.450
三秒钟

01:08:58.450 --> 01:08:59.450
对不对

01:08:59.450 --> 01:09:00.450
就三秒钟

01:09:00.450 --> 01:09:01.450
一个随机时间

01:09:01.450 --> 01:09:02.450
能看到吗

01:09:02.450 --> 01:09:03.450
或者是

01:09:04.450 --> 01:09:05.450
这个玩意

01:09:06.450 --> 01:09:07.450
这样

01:09:07.450 --> 01:09:08.450
这样也可以

01:09:08.450 --> 01:09:09.450
不这样

01:09:09.450 --> 01:09:10.450
太难越读了

01:09:10.450 --> 01:09:11.450
这样吧

01:09:11.450 --> 01:09:12.450
随机一个三秒钟

01:09:12.450 --> 01:09:13.450
一到零到三秒钟

01:09:13.450 --> 01:09:14.450
然后随机完了过后

01:09:14.450 --> 01:09:15.450
等待

01:09:15.450 --> 01:09:16.450
等待完了过后

01:09:16.450 --> 01:09:17.450
我就可以做

01:09:17.450 --> 01:09:18.450
网络的数据

01:09:18.450 --> 01:09:19.450
我就随便给你

01:09:19.450 --> 01:09:20.450
瞎给你的数据

01:09:20.450 --> 01:09:21.450
给你一个

01:09:21.450 --> 01:09:22.450
给你一个就是

01:09:22.450 --> 01:09:23.450
Mesh

01:09:24.450 --> 01:09:25.450
我们今天

01:09:25.450 --> 01:09:26.450
网络合讯的评论

01:09:26.450 --> 01:09:27.450
结束了

01:09:28.450 --> 01:09:29.450
等待一段时间过后

01:09:29.450 --> 01:09:30.450
我给你

01:09:30.450 --> 01:09:31.450
随机一个东西

01:09:31.450 --> 01:09:32.450
来模拟

01:09:32.450 --> 01:09:33.450
模拟网络

01:09:33.450 --> 01:09:34.450
研究

01:09:38.760 --> 01:09:39.760
那么现在呢

01:09:39.760 --> 01:09:40.760
我们要连续

01:09:40.760 --> 01:10:02.920
一式发出

01:10:04.760 --> 01:10:08.710
然后拿到数据

01:10:12.710 --> 01:10:14.710
成功之后你会给我一个数据

01:10:14.710 --> 01:10:16.710
我甭管你给我的事啥

01:10:16.710 --> 01:10:18.710
你给我一个数据

01:10:18.710 --> 01:10:19.710
然后呢

01:10:19.710 --> 01:10:20.710
我输出这个数据

01:10:20.710 --> 01:10:22.710
比方说我有些自己的事情要做

01:10:24.710 --> 01:10:25.710
自己的事情要做

01:10:25.710 --> 01:10:27.710
我输出一下这个数据

01:10:27.710 --> 01:10:28.710
输出完了过后

01:10:28.710 --> 01:10:29.710
我还要请求别的地址

01:10:29.710 --> 01:10:30.710
对吧

01:10:30.710 --> 01:10:31.710
是不是又来一个事情

01:10:31.710 --> 01:10:33.710
就return and sink connect

01:10:33.710 --> 01:10:35.710
地址

01:10:36.710 --> 01:10:39.710
那么这个函数是不是又返回一个新的promise

01:10:39.710 --> 01:10:41.710
好 那么这个东西是不是又是一个新的promise

01:10:41.710 --> 01:10:45.280
于是又来z

01:10:45.280 --> 01:10:46.280
z

01:10:46.280 --> 01:10:48.280
地址

01:10:48.280 --> 01:10:50.280
看一下地址29我返回的是什么

01:10:50.280 --> 01:10:51.280
是吧

01:10:51.280 --> 01:10:52.280
2

01:10:52.280 --> 01:10:53.280
对

01:10:53.280 --> 01:10:55.280
然后呢我又去请求

01:10:55.280 --> 01:10:56.280
sink connect

01:10:56.280 --> 01:10:57.280
地址3

01:10:57.280 --> 01:10:59.280
对 任务一直往后面积蓄

01:10:59.280 --> 01:11:01.280
然后又来一个promise

01:11:01.280 --> 01:11:02.280
又来

01:11:02.280 --> 01:11:04.280
输出3

01:11:04.280 --> 01:11:05.280
对

01:11:05.280 --> 01:11:06.280
我就就三次了

01:11:06.280 --> 01:11:07.280
那就三次就行了

01:11:08.280 --> 01:11:09.280
1 2 3

01:11:09.280 --> 01:11:11.280
你看一下现在是不是没有嵌掏了呀至少

01:11:12.280 --> 01:11:14.280
回调消除没

01:11:14.280 --> 01:11:15.280
没有消除

01:11:15.280 --> 01:11:16.280
你不要告诉我以后面试的时候

01:11:16.280 --> 01:11:17.280
为你promise优势在哪里

01:11:17.280 --> 01:11:18.280
你消除了回调

01:11:18.280 --> 01:11:19.280
那就也瞎说了

01:11:19.280 --> 01:11:21.280
promise没有消除回调

01:11:21.280 --> 01:11:23.280
它是让回调变得标准化

01:11:23.280 --> 01:11:24.280
变得可控

01:11:24.280 --> 01:11:26.280
以后你面试的时候就这么回答

01:11:26.280 --> 01:11:28.280
为你promise到底最大的优势在什么

01:11:28.280 --> 01:11:30.280
它让回调变得可控

01:11:30.280 --> 01:11:31.280
变得标准

01:11:31.280 --> 01:11:33.280
就是它最大的好处

01:11:33.280 --> 01:11:34.280
以后我们就可以知道

01:11:34.280 --> 01:11:36.280
它标准过后有什么恐怖的事情发生了

01:11:36.280 --> 01:11:38.280
首先回调地域消除了

01:11:38.280 --> 01:11:40.280
它这种设计回调地域消除了

01:11:44.280 --> 01:11:46.280
第一次

01:11:46.280 --> 01:11:47.280
第二次

01:11:47.280 --> 01:11:48.280
就要依次行求

01:11:48.280 --> 01:11:50.280
第三次

01:11:50.280 --> 01:11:52.280
就是劣势调用

01:11:52.280 --> 01:11:55.280
以为它变得标准了

01:11:55.280 --> 01:12:00.130
大家有什么问题

01:12:00.130 --> 01:12:03.130
以为它变得标准了之后

01:12:03.130 --> 01:12:05.130
ES官方就发现了

01:12:05.130 --> 01:12:08.130
那既然这样的话

01:12:09.130 --> 01:12:11.130
我发现这个promise的后续处理

01:12:11.130 --> 01:12:13.130
现在问题在于promise的后续处理

01:12:13.130 --> 01:12:15.130
这个后续处理仍然有回调

01:12:15.130 --> 01:12:17.130
看上去比以前好多了

01:12:17.130 --> 01:12:19.130
舒服多了

01:12:19.130 --> 01:12:21.130
但是还是有点恶心

01:12:22.130 --> 01:12:24.130
那么既然这个东西是标准的

01:12:24.130 --> 01:12:26.130
我就给它招一个愚法堂

01:12:26.130 --> 01:12:27.130
出来

01:12:27.130 --> 01:12:28.130
于是ES7给你招了一个愚法堂

01:12:28.130 --> 01:12:30.130
咱俩愚法堂

01:12:30.130 --> 01:12:32.130
就是它本质没有什么变化

01:12:32.130 --> 01:12:34.130
就是你写起来更加方便了

01:12:34.130 --> 01:12:38.590
它变成这样子了

01:12:39.590 --> 01:12:48.450
我就把它拿过来

01:12:48.450 --> 01:12:50.450
简单解释一下

01:12:50.450 --> 01:12:52.450
这个网上里边的细节还蛮多的

01:12:52.450 --> 01:12:53.450
简单解释一下

01:12:53.450 --> 01:12:55.450
这啥意思呢

01:12:55.450 --> 01:12:56.450
它将有两个关键

01:12:56.450 --> 01:12:57.450
一个是arwait

01:12:57.450 --> 01:12:58.450
一个是arthink

01:12:58.450 --> 01:13:00.450
arthink是原来标准函数的

01:13:00.450 --> 01:13:04.450
arwait必须要出现在arthink函数里边

01:13:04.450 --> 01:13:06.450
我先说一下arthink啥意思

01:13:06.450 --> 01:13:09.450
arthink反是被arthink标准的函数

01:13:09.450 --> 01:13:11.450
它反回的一定是promise

01:13:11.450 --> 01:13:13.450
你想都不用想

01:13:13.450 --> 01:13:16.450
你看一下我随便写个函数

01:13:16.450 --> 01:13:18.450
我啥都不写

01:13:18.450 --> 01:13:19.450
arthink

01:13:19.450 --> 01:13:20.450
它标准的arthink

01:13:20.450 --> 01:13:22.450
把它看一下吧

01:13:22.450 --> 01:13:23.450
就是你必须要理解

01:13:23.450 --> 01:13:26.450
promise你才有可能理解这个东西

01:13:26.450 --> 01:13:27.450
它只要被这个标准的过后

01:13:27.450 --> 01:13:28.450
你叼一个函数

01:13:28.450 --> 01:13:30.450
它反回的一定是个promise

01:13:30.450 --> 01:13:32.450
一定是个promise

01:13:32.450 --> 01:13:33.450
完成的状态

01:13:33.450 --> 01:13:34.450
它为什么完成

01:13:34.450 --> 01:13:35.450
因为这个函数执行完了

01:13:35.450 --> 01:13:37.450
执行完了它就完成了

01:13:37.450 --> 01:13:38.450
它反回的一定是promise

01:13:38.450 --> 01:13:40.450
比方说这里反回一个1

01:13:40.450 --> 01:13:44.040
咋意思呢

01:13:44.040 --> 01:13:45.040
test

01:13:45.040 --> 01:13:46.040
它反回的是个promise

01:13:46.040 --> 01:13:48.040
它的数据是1

01:13:48.040 --> 01:13:50.040
它们是这么个意思

01:13:50.040 --> 01:13:51.040
只要标准arthink的函数

01:13:51.040 --> 01:13:53.040
它一定反回promise

01:13:53.040 --> 01:13:54.040
那么这个东西

01:13:54.040 --> 01:13:56.040
我们把它叫做一步函数

01:13:56.040 --> 01:13:59.040
这个函数内部

01:13:59.040 --> 01:14:02.040
它可以去调用其它的promise

01:14:02.040 --> 01:14:03.040
可以去等待其它的promise

01:14:03.040 --> 01:14:04.040
你看这个函数

01:14:04.040 --> 01:14:05.040
是不是等待

01:14:05.040 --> 01:14:06.040
是不是这个东西

01:14:06.040 --> 01:14:07.040
得到一个promise

01:14:07.040 --> 01:14:09.040
得到一个promise

01:14:09.040 --> 01:14:12.040
那么我可以用一个arwait关键字

01:14:12.040 --> 01:14:13.040
去等待它

01:14:13.040 --> 01:14:14.040
等待什么

01:14:14.040 --> 01:14:15.040
等待它完成

01:14:15.040 --> 01:14:16.040
完成之后

01:14:16.040 --> 01:14:19.040
把数据复制给这个变量

01:14:19.040 --> 01:14:21.040
它就这么个意思

01:14:21.040 --> 01:14:23.040
这句话就相当于是什么呢

01:14:23.040 --> 01:14:24.040
相当于是

01:14:24.040 --> 01:14:26.040
arthink connect是

01:14:26.040 --> 01:14:27.040
d-1

01:14:27.040 --> 01:14:30.040
然后zin

01:14:30.040 --> 01:14:31.040
zin

01:14:31.040 --> 01:14:32.040
这里有个变量

01:14:32.040 --> 01:14:33.040
are risk

01:14:33.040 --> 01:14:35.040
risk-1

01:14:35.040 --> 01:14:37.040
这里边把risk-1

01:14:37.040 --> 01:14:39.040
复制为这个data

01:14:39.040 --> 01:14:40.040
对吧

01:14:40.040 --> 01:14:42.040
只是鞋线没有那么繁琐了

01:14:42.040 --> 01:14:43.040
就这么个意思

01:14:43.040 --> 01:14:44.040
等待它完成

01:14:44.040 --> 01:14:45.040
完成之后

01:14:45.040 --> 01:14:47.040
把数据复制给这个变量

01:14:47.040 --> 01:14:48.040
然后再进行

01:14:48.040 --> 01:14:50.040
然后再进行后边的代码

01:14:50.040 --> 01:14:51.040
相当于后边的代码

01:14:51.040 --> 01:14:52.040
还在这里

01:14:52.040 --> 01:14:54.040
后边就把这个d-2

01:14:54.040 --> 01:14:55.040
还在这里

01:14:55.040 --> 01:14:56.040
没有意味着

01:14:56.040 --> 01:14:59.040
你打开这么理解就行了

01:14:59.040 --> 01:15:00.040
就变成这样子

01:15:00.040 --> 01:15:01.040
这样子是不是变得

01:15:01.040 --> 01:15:02.040
更加可怕了

01:15:02.040 --> 01:15:03.040
你看一下

01:15:03.040 --> 01:15:04.040
就把这个直接

01:15:04.040 --> 01:15:05.040
都可以运行的

01:15:05.040 --> 01:15:07.670
咱们调一下这个函数

01:15:07.670 --> 01:15:12.970
do request

01:15:12.970 --> 01:15:13.970
这样

01:15:13.970 --> 01:15:14.970
这东西呢

01:15:14.970 --> 01:15:18.750
我看一下

01:15:18.750 --> 01:15:19.750
东西跑哪去了

01:15:19.750 --> 01:15:20.750
我没输出是吧

01:15:20.750 --> 01:15:21.750
我没输出

01:15:21.750 --> 01:15:22.750
risk-1

01:15:22.750 --> 01:15:25.450
risk-2

01:15:25.450 --> 01:15:26.450
我输出三个吧

01:15:26.450 --> 01:15:28.450
三个一和一是就行了

01:15:29.450 --> 01:15:30.450
3

01:15:30.450 --> 01:15:31.450
好

01:15:31.450 --> 01:15:32.450
来了

01:15:32.450 --> 01:15:37.060
request

01:15:37.060 --> 01:15:38.060
对不对

01:15:38.060 --> 01:15:39.060
现在有了

01:15:39.060 --> 01:15:40.060
are think

01:15:40.060 --> 01:15:41.060
are waste

01:15:41.060 --> 01:15:42.060
关键之过后

01:15:42.060 --> 01:15:43.060
它才能真正的

01:15:43.060 --> 01:15:44.060
消除回掉

01:15:44.060 --> 01:15:45.060
你看这里边有回掉吗

01:15:45.060 --> 01:15:46.060
一个回掉都没有

01:15:47.060 --> 01:15:48.060
解决得非常彻底

01:15:48.060 --> 01:15:49.060
甚至你还可以

01:15:49.060 --> 01:15:50.060
把一些要取

01:15:50.060 --> 01:15:51.060
运行里边

01:15:51.060 --> 01:15:52.060
还可以

01:15:52.060 --> 01:15:53.060
还可以这样子写

01:15:53.060 --> 01:15:54.060
这里边还有很多细节

01:15:54.060 --> 01:15:55.060
我就说一下

01:15:55.060 --> 01:15:56.060
t11

01:15:57.060 --> 01:16:00.080
t12

01:16:00.080 --> 01:16:01.080
t13

01:16:01.080 --> 01:16:04.160
urls

01:16:04.160 --> 01:16:06.160
我们用es6的follow循环

01:16:08.920 --> 01:16:09.920
就看一下就行了

01:16:09.920 --> 01:16:10.920
什么意思呢

01:16:10.920 --> 01:16:11.920
就是把这个

01:16:11.920 --> 01:16:12.920
当你用follow循环也行

01:16:12.920 --> 01:16:13.920
就把这个数组里边

01:16:13.920 --> 01:16:14.920
一项一项拿出来

01:16:14.920 --> 01:16:15.920
复制的这个辩量

01:16:15.920 --> 01:16:16.920
然后呢输出

01:16:16.920 --> 01:16:17.920
然后呢await

01:16:17.920 --> 01:16:18.920
await

01:16:18.920 --> 01:16:20.920
are think

01:16:21.920 --> 01:16:22.920
url

01:16:22.920 --> 01:16:24.920
拿到数据

01:16:24.920 --> 01:16:25.920
拿到数据

01:16:25.920 --> 01:16:29.870
尽量用你们

01:16:29.870 --> 01:16:30.870
现在看得懂的

01:16:36.580 --> 01:16:39.850
request

01:16:39.850 --> 01:16:40.850
1

01:16:40.850 --> 01:16:41.850
2

01:16:41.850 --> 01:16:42.850
3

01:16:43.850 --> 01:16:45.850
所以更加舒服了

01:16:46.850 --> 01:16:47.850
有点像Generic

01:16:47.850 --> 01:16:48.850
对吧生存器

01:16:48.850 --> 01:16:49.850
有点像

01:16:49.850 --> 01:16:50.850
有点像

01:16:50.850 --> 01:16:51.850
在那个没有

01:16:51.850 --> 01:16:52.850
Esonc和Orwait

01:16:52.850 --> 01:16:54.850
关键制之前呢

01:16:54.850 --> 01:16:55.850
某些工作呢

01:16:55.850 --> 01:16:56.850
是靠生存器完成的

01:16:56.850 --> 01:16:58.850
咱们后边

01:16:58.850 --> 01:16:59.850
讲那个

01:16:59.850 --> 01:17:00.850
也会讲到这个生存器

01:17:00.850 --> 01:17:01.850
生存器里面以后

01:17:01.850 --> 01:17:02.850
也会用到的

01:17:02.850 --> 01:17:03.850
我这里单独讲了

01:17:03.850 --> 01:17:04.850
一个异部任务控制

01:17:04.850 --> 01:17:05.850
就是如果说

01:17:05.850 --> 01:17:06.850
没有Esonc和Orwait

01:17:06.850 --> 01:17:07.850
我们怎么用生存器

01:17:07.850 --> 01:17:08.850
来搞定

01:17:08.850 --> 01:17:09.850
也是可以的

01:17:09.850 --> 01:17:10.850
好了

01:17:10.850 --> 01:17:11.850
那么我们看一下

01:17:11.850 --> 01:17:12.850
后边这个题

01:17:12.850 --> 01:17:13.850
后面这个两个面子

01:17:13.850 --> 01:17:14.850
这两个面子

01:17:14.850 --> 01:17:15.850
就很有难度了

01:17:15.850 --> 01:17:16.850
非常有难度了

01:17:16.850 --> 01:17:17.850
看一下吧

01:17:17.850 --> 01:17:18.850
我不要去你们

01:17:18.850 --> 01:17:19.850
现在能做出来

01:17:19.850 --> 01:17:20.850
因为毕竟

01:17:20.850 --> 01:17:21.850
毕竟后面

01:17:21.850 --> 01:17:22.850
还有这些知识呢

01:17:22.850 --> 01:17:23.850
还有一些细节

01:17:23.850 --> 01:17:25.850
大家还要磨一磨

01:17:25.850 --> 01:17:27.850
现在尽量做一做吧

01:17:27.850 --> 01:17:28.850
看个意识

01:17:28.850 --> 01:17:29.850
这是真实的面子

01:17:33.860 --> 01:17:34.860
时间有限

01:17:34.860 --> 01:17:38.460
这些面子

01:17:38.460 --> 01:17:39.460
有难度

01:17:39.460 --> 01:17:49.640
这种题

01:17:49.640 --> 01:17:51.640
其实

01:17:51.640 --> 01:17:52.640
你要说特别有难度

01:17:52.640 --> 01:17:54.640
没有很有难度

01:17:54.640 --> 01:17:56.640
它就是比较糟

01:17:56.640 --> 01:17:57.640
一画个图

01:17:57.640 --> 01:17:58.640
把四件循环

01:17:58.640 --> 01:17:59.640
堆裂画出来

01:17:59.640 --> 01:18:00.640
然后根据我们说

01:18:00.640 --> 01:18:02.640
学过的Promise的知识

01:18:02.640 --> 01:18:03.640
当然我们还有很多知识

01:18:03.640 --> 01:18:05.640
你们后面还要学

01:18:05.640 --> 01:18:07.640
你就可以做出来了

01:18:07.640 --> 01:18:08.640
你看吧

01:18:08.640 --> 01:18:10.640
怎么做

01:18:10.640 --> 01:18:12.640
我现在也不知道它是

01:18:12.640 --> 01:18:13.640
来吧

01:18:13.640 --> 01:18:15.640
你用这种方式来分析

01:18:15.640 --> 01:18:16.640
一定不带错过的

01:18:16.640 --> 01:18:17.640
跟你说

01:18:17.640 --> 01:18:18.640
有两个变量

01:18:18.640 --> 01:18:19.640
B

01:18:19.640 --> 01:18:20.640
A一开始为什么

01:18:20.640 --> 01:18:21.640
undefend

01:18:21.640 --> 01:18:22.640
对吧

01:18:22.640 --> 01:18:23.640
undefend

01:18:23.640 --> 01:18:24.640
B呢

01:18:24.640 --> 01:18:25.640
一开始你是不是

01:18:25.640 --> 01:18:26.640
丢了一个Promise

01:18:26.640 --> 01:18:27.640
执行呗

01:18:27.640 --> 01:18:28.640
还等啥呢

01:18:28.640 --> 01:18:29.640
马上执行

01:18:29.640 --> 01:18:30.640
微对列 红对列

01:18:30.640 --> 01:18:32.640
要去掉

01:18:32.640 --> 01:18:33.640
马上执行

01:18:33.640 --> 01:18:36.640
输出Promise1

01:18:36.640 --> 01:18:37.640
然后result

01:18:37.640 --> 01:18:39.640
result过后是什么

01:18:39.640 --> 01:18:41.640
B是变成了fulfill

01:18:41.640 --> 01:18:45.400
没问题吧

01:18:45.400 --> 01:18:46.400
数据呢

01:18:46.400 --> 01:18:48.400
数据是undefend

01:18:48.400 --> 01:18:49.400
对吧

01:18:49.400 --> 01:18:50.400
状态为fulfill的

01:18:50.400 --> 01:18:51.400
数据为undefend

01:18:51.400 --> 01:18:52.400
好 那么这个Promise

01:18:52.400 --> 01:18:53.400
执行结束了

01:18:53.400 --> 01:18:57.160
好像人

01:18:57.160 --> 01:18:58.160
有意思了

01:18:58.160 --> 01:19:01.820
人

01:19:01.820 --> 01:19:02.820
等一下

01:19:02.820 --> 01:19:03.820
不着急

01:19:03.820 --> 01:19:04.820
不着急

01:19:04.820 --> 01:19:05.820
这里有陷阱

01:19:05.820 --> 01:19:07.820
这里有陷阱

01:19:07.820 --> 01:19:10.820
这个B呀

01:19:10.820 --> 01:19:14.380
它是这个Promise吧

01:19:14.380 --> 01:19:16.380
它不是

01:19:16.380 --> 01:19:17.380
它是这个Promise

01:19:17.380 --> 01:19:18.380
调用人过后

01:19:18.380 --> 01:19:19.380
又调用人过后

01:19:19.380 --> 01:19:21.380
又调用人过后

01:19:21.380 --> 01:19:23.380
返回的Promise

01:19:23.380 --> 01:19:26.380
B是这个

01:19:26.380 --> 01:19:28.380
它生成了很多个Promise

01:19:28.380 --> 01:19:30.380
对不对

01:19:30.380 --> 01:19:31.380
有什么意思吧

01:19:31.380 --> 01:19:33.380
好 咱们再来看

01:19:33.380 --> 01:19:34.380
首先输出Promise1

01:19:34.380 --> 01:19:37.380
然后把这个Promise

01:19:37.380 --> 01:19:39.380
这个Promise变成什么

01:19:39.380 --> 01:19:41.380
fulfill状态

01:19:41.380 --> 01:19:42.380
对不对

01:19:42.380 --> 01:19:43.380
于是呢

01:19:43.380 --> 01:19:44.380
这个函数

01:19:44.380 --> 01:19:46.380
输出Promise2的函数

01:19:46.380 --> 01:19:48.380
是不是推向了微对列

01:19:48.380 --> 01:19:50.380
Promise2

01:19:50.380 --> 01:19:52.380
这个函数被推向了微对列

01:19:52.380 --> 01:19:53.380
等着

01:19:53.380 --> 01:19:55.380
它没有执行 对吧

01:19:55.380 --> 01:19:56.380
没有执行

01:19:56.380 --> 01:19:58.380
那它没有执行 它能执行吗

01:19:58.380 --> 01:19:59.380
它不是

01:19:59.380 --> 01:20:01.380
它没有执行 它能执行吗

01:20:01.380 --> 01:20:02.380
对吧

01:20:02.380 --> 01:20:03.380
不能执行

01:20:03.380 --> 01:20:04.380
所以说B的状态是什么

01:20:04.380 --> 01:20:05.380
B的状态是平底

01:20:05.380 --> 01:20:06.380
挂起的

01:20:06.380 --> 01:20:07.380
它等着的

01:20:07.380 --> 01:20:09.380
B是等着的 对吧

01:20:09.380 --> 01:20:11.380
好 继续看A

01:20:11.380 --> 01:20:13.380
现在给A复制了 对吧

01:20:13.380 --> 01:20:14.380
A一开始是Andy发现的

01:20:14.380 --> 01:20:15.380
给A复制了

01:20:15.380 --> 01:20:16.380
复制为一个什么呢

01:20:16.380 --> 01:20:18.380
复制为一个Promise

01:20:18.380 --> 01:20:22.530
传入了一个异部函数

01:20:22.530 --> 01:20:23.530
这个还说立即执行

01:20:23.530 --> 01:20:25.530
输出A

01:20:25.530 --> 01:20:27.530
好 请问现在A是啥

01:20:27.530 --> 01:20:28.530
注意

01:20:28.530 --> 01:20:30.530
这个还在考察复制顺序

01:20:30.530 --> 01:20:33.530
是要把这个玩意儿

01:20:33.530 --> 01:20:35.530
复制给A

01:20:35.530 --> 01:20:37.530
我这个玩意儿是不是得运行啊

01:20:37.530 --> 01:20:39.530
你等我运行完了再说

01:20:39.530 --> 01:20:40.530
现在还没有运行

01:20:40.530 --> 01:20:42.530
那么现在运行输出什么

01:20:42.530 --> 01:20:43.530
现在输出了A

01:20:43.530 --> 01:20:45.530
是不是Andy犯的

01:20:45.530 --> 01:20:47.530
目前A是Andy犯的

01:20:47.530 --> 01:20:48.530
好 现在等待什么

01:20:48.530 --> 01:20:49.530
等待B

01:20:49.530 --> 01:20:50.530
B是什么

01:20:50.530 --> 01:20:51.530
B是平顶 对吧

01:20:51.530 --> 01:20:52.530
那还等啥

01:20:52.530 --> 01:20:53.530
只能等着A

01:20:53.530 --> 01:20:54.530
那么现在运行完了没

01:20:54.530 --> 01:20:55.530
运行完了

01:20:55.530 --> 01:20:57.530
这个还说已经运行完了

01:20:57.530 --> 01:20:58.530
注意

01:20:58.530 --> 01:20:59.530
已经运行完了

01:20:59.530 --> 01:21:00.530
它不是我卡在这

01:21:00.530 --> 01:21:02.530
既也是不会卡在这了

01:21:02.530 --> 01:21:03.530
它是异部的

01:21:03.530 --> 01:21:04.530
永远都是异部的

01:21:04.530 --> 01:21:05.530
这只是一个愚法堂

01:21:05.530 --> 01:21:06.530
它相当于是什么呢

01:21:06.530 --> 01:21:08.530
相当于是

01:21:08.530 --> 01:21:09.530
B点Z

01:21:09.530 --> 01:21:10.530
后边这一大头全的

01:21:10.530 --> 01:21:11.530
全在这里边

01:21:11.530 --> 01:21:12.530
你看那意思吧

01:21:12.530 --> 01:21:14.530
它其实已经运行完了

01:21:14.530 --> 01:21:16.840
好 那么现在A

01:21:16.840 --> 01:21:17.840
是不是有值的

01:21:17.840 --> 01:21:18.840
A变成什么

01:21:18.840 --> 01:21:20.840
变成了一个Promise

01:21:20.840 --> 01:21:21.840
状态是什么 平顶

01:21:21.840 --> 01:21:22.840
为什么是平顶

01:21:22.840 --> 01:21:24.840
因为它里边没有resolve

01:21:24.840 --> 01:21:25.840
没有reject

01:21:25.840 --> 01:21:26.840
所以只能平顶

01:21:26.840 --> 01:21:30.150
因为它要等B 对吧

01:21:30.150 --> 01:21:31.150
好 接下来

01:21:31.150 --> 01:21:32.150
输出什么

01:21:32.150 --> 01:21:36.770
输出And

01:21:36.770 --> 01:21:37.770
好 这是个快手的题

01:21:37.770 --> 01:21:39.770
快手的那个准辩式题

01:21:39.770 --> 01:21:41.770
输出And过后

01:21:41.770 --> 01:21:42.770
没东西了

01:21:42.770 --> 01:21:43.770
维对的拿出来

01:21:43.770 --> 01:21:44.770
输出什么

01:21:44.770 --> 01:21:45.770
输出Promise 2

01:21:45.770 --> 01:21:46.770
是不是输出这个

01:21:46.770 --> 01:21:49.140
Promise 2

01:21:49.140 --> 01:21:51.140
好 输出Promise 2过后

01:21:51.140 --> 01:21:53.140
维对得清空了

01:21:53.140 --> 01:21:54.140
那么这个时候你看一下

01:21:54.140 --> 01:21:55.140
它一完成

01:21:55.140 --> 01:21:57.140
是不是把那个

01:21:57.140 --> 01:22:00.140
这个Promise就完成了

01:22:00.140 --> 01:22:01.140
这个Promise完成了

01:22:01.140 --> 01:22:02.140
是不是它

01:22:02.140 --> 01:22:03.140
就要运行这个了

01:22:03.140 --> 01:22:06.140
Promise 3推向维对点

01:22:06.140 --> 01:22:08.140
推向维对点

01:22:08.140 --> 01:22:10.140
好 那么现在输出Promise 3

01:22:10.140 --> 01:22:12.140
好 同样的道理

01:22:12.140 --> 01:22:13.140
Promise 3输出了过后

01:22:13.140 --> 01:22:15.140
是不是得输出Promise 4

01:22:15.140 --> 01:22:16.140
Promise 4

01:22:16.140 --> 01:22:18.140
Promise 4也输出了

01:22:18.140 --> 01:22:19.140
那么这个时候

01:22:19.140 --> 01:22:21.140
B是不是表示完成了

01:22:24.140 --> 01:22:25.140
B表示完成了

01:22:25.140 --> 01:22:26.140
数据是什么

01:22:26.140 --> 01:22:28.780
数据上地带

01:22:28.780 --> 01:22:29.780
对不对

01:22:29.780 --> 01:22:30.780
它没有返回吗

01:22:30.780 --> 01:22:31.780
说B变成完成了

01:22:31.780 --> 01:22:32.780
而B完成

01:22:32.780 --> 01:22:33.780
是不是这里等待结束了

01:22:33.780 --> 01:22:35.780
之前一直在等B完成

01:22:35.780 --> 01:22:36.780
好 等待结束了

01:22:36.780 --> 01:22:37.780
现在是不是要

01:22:37.780 --> 01:22:39.780
把这两个东西推向维对点

01:22:39.780 --> 01:22:40.780
输出这两个

01:22:40.780 --> 01:22:41.780
输出A

01:22:41.780 --> 01:22:42.780
那么现在A是什么

01:22:42.780 --> 01:22:44.780
还是Promise

01:22:44.780 --> 01:22:45.780
A的状态

01:22:45.780 --> 01:22:47.780
A是一个Promise

01:22:47.780 --> 01:22:48.780
还是一个Promise

01:22:48.780 --> 01:22:49.780
一般来说

01:22:49.780 --> 01:22:50.780
你在面试题里边

01:22:50.780 --> 01:22:52.780
它输出一个Promise对向的时候

01:22:52.780 --> 01:22:53.780
它大概问你

01:22:53.780 --> 01:22:54.780
它的状态是什么

01:22:54.780 --> 01:22:56.780
你刚回答出状态就行了

01:22:56.780 --> 01:22:57.780
好 这是平底

01:22:57.780 --> 01:22:59.780
然后再输出After E

01:22:59.780 --> 01:23:00.780
After E

01:23:00.780 --> 01:23:06.070
然后再等待A

01:23:06.070 --> 01:23:08.070
A是平底

01:23:08.070 --> 01:23:10.070
A能结束吗

01:23:10.070 --> 01:23:11.070
A能完成吗

01:23:11.070 --> 01:23:12.070
永远不可能完成了

01:23:12.070 --> 01:23:14.070
因为它要什么时候完成

01:23:14.070 --> 01:23:15.070
等待自己

01:23:15.070 --> 01:23:18.070
它要什么时候完成

01:23:18.070 --> 01:23:20.070
它只有自己完成了之后才能完成

01:23:20.070 --> 01:23:22.070
但它永远不可能完成

01:23:22.070 --> 01:23:27.070
你跑到医院里边去摆口罩

01:23:27.070 --> 01:23:29.070
它说你必须要有口罩才能进来

01:23:29.070 --> 01:23:31.070
我就是来摆口罩的

01:23:31.070 --> 01:23:33.070
那不行

01:23:33.070 --> 01:23:35.070
你要有口罩才能进来

01:23:35.070 --> 01:23:37.070
意思是它永远不可能完成

01:23:37.070 --> 01:23:38.070
所以报纸就结束了

01:23:38.070 --> 01:23:40.070
后边没了

01:23:40.070 --> 01:23:41.070
你看下一个代码

01:23:41.070 --> 01:23:49.700
你也行

01:23:49.700 --> 01:23:50.700
Promise E

01:23:50.700 --> 01:23:51.700
Undefend

01:23:51.700 --> 01:23:52.700
Promise 2

01:23:52.700 --> 01:23:53.700
3

01:23:53.700 --> 01:23:54.700
4

01:23:54.700 --> 01:23:55.700
Pending

01:23:55.700 --> 01:23:56.700
After E

01:23:56.700 --> 01:23:57.700
结束

01:23:57.700 --> 01:23:58.700
以用这种方式去分析

01:23:58.700 --> 01:24:00.700
永远不带错的

01:24:03.070 --> 01:24:04.070
哇

01:24:04.070 --> 01:24:05.070
最后一道题

01:24:05.070 --> 01:24:06.070
给它讲完吧

01:24:06.070 --> 01:24:09.340
讲完

01:24:09.340 --> 01:24:10.340
这里是不是有点云啊

01:24:10.340 --> 01:24:12.340
这里有点云啊

01:24:12.340 --> 01:24:13.340
因为后边还有一些知识

01:24:13.340 --> 01:24:14.340
你还没有获取到啊

01:24:14.340 --> 01:24:15.340
因为像这个

01:24:15.340 --> 01:24:17.340
电视雕像这一块的知识

01:24:17.340 --> 01:24:18.340
还有而生可而未知的东西

01:24:18.340 --> 01:24:20.340
你还不是很熟悉啊

01:24:20.340 --> 01:24:22.340
因为今天时间确实太有限了

01:24:22.340 --> 01:24:24.340
你看这里

01:24:24.340 --> 01:24:26.340
以前那个集训营的时候

01:24:26.340 --> 01:24:27.340
我都没有讲这个东西

01:24:27.340 --> 01:24:29.340
没有讲这些东西

01:24:29.340 --> 01:24:30.340
就确实时间有限

01:24:30.340 --> 01:24:32.340
今天给它多讲一点

01:24:32.340 --> 01:24:33.340
下面代码输出啥

01:24:33.340 --> 01:24:34.340
这也是到了面试题

01:24:34.340 --> 01:24:36.340
而且非常经典的面试题

01:24:36.340 --> 01:24:37.340
以下入到底啊就来吧

01:24:37.340 --> 01:24:43.340
我快速给大家分析一下

01:24:43.340 --> 01:24:44.340
好

01:24:44.340 --> 01:24:45.340
首先两个函数

01:24:45.340 --> 01:24:46.340
看都不用看

01:24:46.340 --> 01:24:47.340
因为它没有函数调用

01:24:47.340 --> 01:24:48.340
也不要看

01:24:48.340 --> 01:24:50.340
console log script start

01:24:50.340 --> 01:24:51.340
好

01:24:51.340 --> 01:24:52.340
接下来

01:24:52.340 --> 01:24:53.340
是不是进入红队的

01:24:53.340 --> 01:24:54.340
set timeout

01:24:54.340 --> 01:24:55.340
进入红队的

01:24:55.340 --> 01:24:56.340
等着

01:24:56.340 --> 01:24:57.340
而生可一

01:24:57.340 --> 01:24:58.340
调用而生可一

01:24:58.340 --> 01:24:59.340
运行

01:24:59.340 --> 01:25:00.340
输出

01:25:00.340 --> 01:25:01.340
a sync e start

01:25:01.340 --> 01:25:02.340
对不对

01:25:02.340 --> 01:25:03.340
好

01:25:03.340 --> 01:25:04.340
现在等待而生可二

01:25:04.340 --> 01:25:05.340
是不是要调用

01:25:05.340 --> 01:25:06.340
首先调用而生可二

01:25:06.340 --> 01:25:07.340
而生可二是不是要输出

01:25:07.340 --> 01:25:08.340
而生可二

01:25:08.340 --> 01:25:09.340
不好意思

01:25:09.340 --> 01:25:10.340
而生可二

01:25:10.340 --> 01:25:11.340
结束了没有

01:25:11.340 --> 01:25:12.340
结束了

01:25:12.340 --> 01:25:13.340
结束了就完成了

01:25:13.340 --> 01:25:14.340
完成了过后

01:25:14.340 --> 01:25:15.340
是不是后边的输出

01:25:15.340 --> 01:25:16.340
相当于是在任后边的

01:25:16.340 --> 01:25:17.340
对吧

01:25:17.340 --> 01:25:18.340
它不会立即执行

01:25:18.340 --> 01:25:19.340
因为它是异步的

01:25:19.340 --> 01:25:20.340
这一块就相当于是

01:25:20.340 --> 01:25:21.340
任

01:25:21.340 --> 01:25:22.340
任后边要输出一个

01:25:22.340 --> 01:25:23.340
而生可一n的

01:25:23.340 --> 01:25:24.340
没了意思吧

01:25:24.340 --> 01:25:25.340
所以说

01:25:25.340 --> 01:25:26.340
这个是异步的

01:25:26.340 --> 01:25:27.340
而生可一n的

01:25:27.340 --> 01:25:28.340
到围队的

01:25:28.340 --> 01:25:29.340
等着

01:25:29.340 --> 01:25:30.340
好

01:25:30.340 --> 01:25:31.340
继续运行

01:25:31.340 --> 01:25:33.340
而生可二已经完成了

01:25:33.340 --> 01:25:34.340
然后呢

01:25:34.340 --> 01:25:35.340
又来六一个promise

01:25:35.340 --> 01:25:36.340
这里面立即执行

01:25:36.340 --> 01:25:38.340
执行promise一

01:25:38.340 --> 01:25:40.340
promise一

01:25:40.340 --> 01:25:41.340
然后完成了

01:25:41.340 --> 01:25:42.340
它完成了

01:25:42.340 --> 01:25:43.340
那么这个玩意是不是到围队的

01:25:43.340 --> 01:25:44.340
输出promise二

01:25:44.340 --> 01:25:45.340
到围队的

01:25:45.340 --> 01:25:46.340
promise二

01:25:46.340 --> 01:25:47.340
到围队的

01:25:47.340 --> 01:25:48.340
然后呢

01:25:48.340 --> 01:25:50.340
输出script end

01:25:50.340 --> 01:25:51.340
script end

01:25:51.340 --> 01:25:52.340
这道题其实还简单一点

01:25:52.340 --> 01:25:53.340
比上面条题要简单一点

01:25:53.340 --> 01:25:55.340
上面条题有点漏气

01:25:55.340 --> 01:25:56.340
输出script end

01:25:56.340 --> 01:25:57.340
然后呢

01:25:57.340 --> 01:25:58.340
然后就没东西了

01:25:58.340 --> 01:25:59.340
没东西了

01:25:59.340 --> 01:26:00.340
先取出围队的

01:26:00.340 --> 01:26:01.340
这个玩意先输出

01:26:01.340 --> 01:26:02.340
而生可一n的

01:26:02.340 --> 01:26:03.340
对吧

01:26:03.340 --> 01:26:04.340
这个玩意先输出

01:26:04.340 --> 01:26:05.340
好

01:26:05.340 --> 01:26:06.340
这个玩意围队的

01:26:06.340 --> 01:26:07.340
第二个

01:26:07.340 --> 01:26:08.340
这个输出就没了吗

01:26:08.340 --> 01:26:09.340
然后输出这个

01:26:09.340 --> 01:26:10.340
promise二

01:26:10.340 --> 01:26:11.340
输出了就没了

01:26:11.340 --> 01:26:12.340
然后红队的

01:26:12.340 --> 01:26:13.340
红队的一个seton mode

01:26:13.340 --> 01:26:16.100
对

01:26:16.100 --> 01:26:17.100
那它的结构就这样子

01:26:17.100 --> 01:26:19.100
看一下了

01:26:19.100 --> 01:26:20.100
第二题

01:26:20.100 --> 01:26:23.740
嗯

01:26:23.740 --> 01:26:24.740
不是啊

01:26:24.740 --> 01:26:27.240
暂且

01:26:27.240 --> 01:26:29.240
印象

01:26:29.240 --> 01:26:31.240
script是大事的

01:26:31.240 --> 01:26:33.240
看一下吧

01:26:33.240 --> 01:26:35.240
生可二promise一

01:26:35.240 --> 01:26:36.240
对吧

01:26:36.240 --> 01:26:37.240
没问题吧

01:26:37.240 --> 01:26:38.240
OK

01:26:38.240 --> 01:26:39.240
总之呢

01:26:39.240 --> 01:26:40.240
你学会了过后呢

01:26:40.240 --> 01:26:41.240
你就按照这种方式来分析

01:26:41.240 --> 01:26:44.000
是一定不代表

01:26:44.000 --> 01:26:46.000
这个还能看懂对吧

01:26:46.000 --> 01:26:47.000
今天就到这

01:26:47.000 --> 01:26:48.000
拜拜

