WEBVTT

00:00.000 --> 00:01.800
为什么要分析原码

00:01.800 --> 00:04.860
第一个没有任何一个东西比原码

00:04.860 --> 00:06.400
更加深入原理的

00:06.400 --> 00:07.680
它的原理是最深入的

00:07.680 --> 00:10.500
如果说你把一个技术的原码读懂了

00:10.500 --> 00:13.060
或者是你自己能够手写出来

00:13.060 --> 00:17.420
按照它的思想和理念手写出来 可能跟它不一样 没关系

00:17.420 --> 00:19.200
但它的原理

00:19.200 --> 00:21.240
一定是摸得非常的透

00:21.240 --> 00:23.300
那么至少这门技术

00:23.300 --> 00:26.120
它随便怎么着 随便怎么考 它考不到你

00:26.120 --> 00:27.900
就像我们讲魔坏话的那一天

00:27.900 --> 00:29.440
给它看了个魔坏话

00:29.440 --> 00:31.240
就是CommonJet时的

00:31.240 --> 00:34.820
那个require函数到底是怎么回事 它随便怎么出考试题

00:34.820 --> 00:35.840
都考不到你

00:35.840 --> 00:37.640
如果说你不知道这些的话

00:37.640 --> 00:40.440
那么你只能去背各种各样的规则 export

00:40.440 --> 00:43.260
跟modular export连用于什么样的效果

00:43.260 --> 00:45.060
你只能去背 背是背不住的

00:45.060 --> 00:46.340
你没有什么印象的

00:46.340 --> 00:47.620
这是第一个原因

00:47.620 --> 00:50.940
对技术本身底线的足够透彻

00:50.940 --> 00:54.280
第二个原因是我们要从

00:54.280 --> 00:55.300
手写

00:55.300 --> 00:57.600
或者是分析它的原码的过程中呢

00:57.600 --> 01:00.100
去学习各种优质的解决方案

01:00.100 --> 01:02.820
你们以后开发中会遇到各种奇葩的问题

01:02.820 --> 01:04.100
具体有多奇葩

01:04.100 --> 01:05.660
我都想象不出来

01:05.660 --> 01:07.700
一定是超过你的想象的

01:07.700 --> 01:09.260
遇到这些问题

01:09.260 --> 01:10.340
那么这些问题呢

01:10.340 --> 01:12.540
它自然而然又解决办法

01:12.540 --> 01:14.540
那么像一些技术里边的

01:14.540 --> 01:15.820
它的原码过程中

01:15.820 --> 01:17.980
它就遇到了各种各样麻烦的问题

01:17.980 --> 01:20.140
那么这些问题它是怎么去解决的

01:20.140 --> 01:22.380
可以给它提供一个起发式的思维

01:22.380 --> 01:23.820
这也是蛮重要的

01:23.820 --> 01:26.060
你看一些技术的原码看得多了

01:26.060 --> 01:27.720
那么自然而然呢

01:27.720 --> 01:29.960
你就老在里边就有了

01:29.960 --> 01:31.800
很多的开发的感觉了

01:31.800 --> 01:33.160
以后呢遇到一些复杂的问题

01:33.160 --> 01:34.880
也只要该怎么去分析了

01:34.880 --> 01:37.480
当然最实际的意义就是冲击高薪

01:37.480 --> 01:39.520
因为你具备了前面两个点的话

01:39.520 --> 01:42.400
冲击高薪冲击大厂就没有什么问题了

01:42.400 --> 01:45.960
因为高薪和大厂竞争压力是还是蛮大的

01:45.960 --> 01:46.880
说清楚了啊

01:46.880 --> 01:49.120
这原码的意义

01:49.120 --> 01:51.720
当然如果说同学们非常着急就业的话

01:51.720 --> 01:53.720
那么可以在第一阶段

01:53.720 --> 01:54.760
第一期学习的时候呢

01:55.060 --> 01:56.300
不着急开学嘛

01:56.300 --> 01:57.020
将来呢

01:57.020 --> 01:59.380
在工作过程中抽出实验

01:59.380 --> 02:00.620
还是要分析的

02:00.620 --> 02:01.180
不然的话

02:01.180 --> 02:02.500
你以后呢

02:02.500 --> 02:03.500
出去挑巢啊之类的

02:03.500 --> 02:04.620
是没有紧紧力的啊

02:07.900 --> 02:10.900
那么今天课程的自然有点难度

02:10.900 --> 02:11.580
可能呢

02:11.580 --> 02:12.780
某些同学呢

02:12.780 --> 02:14.220
在听今天课的时候啊

02:15.540 --> 02:17.420
会出现头晕

02:17.420 --> 02:18.340
恶心

02:18.340 --> 02:21.660
想吐的这么一种感觉啊

02:21.660 --> 02:22.460
这是正常的啊

02:22.460 --> 02:23.220
大家不要有担心

02:23.220 --> 02:23.940
对你们的身体

02:23.940 --> 02:25.400
不会有任何的影响

02:25.400 --> 02:26.080
嗯

02:26.080 --> 02:28.320
今天的课呢

02:28.320 --> 02:32.120
你可能需要有三千行的开发量

02:32.120 --> 02:33.600
就之前写播的代码

02:33.600 --> 02:35.600
加起来至少得有三千行

02:35.600 --> 02:37.440
你才能勉强听得懂啊

02:37.440 --> 02:38.960
当你代码量越多的话

02:38.960 --> 02:40.960
你听起来就越轻松

02:40.960 --> 02:42.320
如果说你不足三千行的话

02:42.320 --> 02:44.120
其实听起来是非常吃力的

02:44.120 --> 02:44.480
而且呢

02:44.480 --> 02:45.760
今天的代码

02:45.760 --> 02:47.320
你会大概会感可能有种感觉啊

02:47.320 --> 02:49.000
就是每一行我都看得懂

02:49.000 --> 02:51.560
但是连起来就不知道啥意思了啊

02:51.560 --> 02:52.240
没关系

02:52.260 --> 02:53.100
因为这个课呢

02:53.100 --> 02:54.660
反正是有路播的

02:54.660 --> 02:55.140
同学们呢

02:55.140 --> 02:56.140
以后呢

02:56.140 --> 02:57.420
嗯

02:57.420 --> 02:59.140
在学习的后期啊

02:59.140 --> 03:00.140
因为这个这个课呢

03:00.140 --> 03:02.980
咱们的后期课都是非常靠后的了

03:02.980 --> 03:04.140
所以在学习的后期呢

03:04.140 --> 03:05.980
可以再看一看这个路播课

03:05.980 --> 03:07.980
给他一些启发

03:07.980 --> 03:08.180
好

03:08.180 --> 03:09.500
我们来分析这个无诱的原码

03:09.500 --> 03:10.460
现在无诱删出来了

03:10.460 --> 03:11.620
所以说我们做一个对比分析

03:13.380 --> 03:13.900
同学们

03:13.900 --> 03:14.500
有些同学们呢

03:14.500 --> 03:17.100
可能还没有接触过这个无诱啊

03:17.100 --> 03:18.620
我这里简单的说一下

03:18.620 --> 03:20.300
今天晚上我们不是讲无诱

03:20.300 --> 03:21.580
而是分析他的原码

03:21.600 --> 03:22.800
把它的就是一些

03:23.600 --> 03:25.720
核心的问题拿出来分析

03:25.720 --> 03:26.200
我这里呢

03:26.200 --> 03:27.200
有一个文件夹啊

03:27.200 --> 03:28.600
叫无诱二office

03:28.600 --> 03:31.040
就是无诱的官方的提供的介绍

03:31.040 --> 03:32.560
无诱二的啊

03:32.560 --> 03:34.000
那么我们来掩饰一下

03:34.000 --> 03:35.680
这个无诱二大概是个什么功能的

03:36.720 --> 03:37.280
再回说

03:37.280 --> 03:38.800
今天不是讲无诱啊

03:38.800 --> 03:39.600
不是讲无诱

03:39.600 --> 03:41.560
是在分析他的里边的一个一个功能

03:43.920 --> 03:44.480
你用啊

03:44.480 --> 03:45.120
你用这个无诱

03:47.080 --> 03:47.680
然后呢

03:47.680 --> 03:50.200
我们在这个脚本里面就这样写

03:50.260 --> 03:51.260
我们的页面上呢

03:51.260 --> 03:52.300
有一个DIV

03:52.300 --> 03:52.980
给他一个ID

03:52.980 --> 03:55.800
为APP

03:55.800 --> 03:55.920
好

03:55.920 --> 03:56.640
这个DIV呢

03:56.640 --> 03:59.320
我们希望无诱来控制这个DIV

03:59.320 --> 04:00.600
这个DIV一起写是啥呢

04:00.600 --> 04:01.480
先不着急

04:01.480 --> 04:03.320
我怎么让无诱来控制这个DIV呢

04:03.320 --> 04:04.120
非常简单啊

04:04.120 --> 04:04.960
另外一个无诱对象

04:06.120 --> 04:07.760
然后这里边写下写一些配置啊

04:07.760 --> 04:08.520
一个是eO

04:08.520 --> 04:09.400
表示Element

04:09.400 --> 04:10.960
我要控制哪个元素

04:10.960 --> 04:12.400
这里边写CSS选择器

04:12.400 --> 04:13.400
我们就选中

04:13.400 --> 04:15.440
这个ID为APP的元素

04:15.440 --> 04:15.760
于是呢

04:15.760 --> 04:17.840
这个元素就被无诱控制了啊

04:17.840 --> 04:19.000
它里边的内容呢

04:19.000 --> 04:20.000
会被无诱所渲染

04:20.780 --> 04:21.020
好

04:21.020 --> 04:21.780
然后呢

04:21.780 --> 04:23.020
以后做开做前段

04:23.020 --> 04:24.100
他一定要学习无诱的

04:24.100 --> 04:24.700
这个跑不掉的

04:24.700 --> 04:26.500
而且无诱二和无诱三都要学

04:26.500 --> 04:28.500
因为将来的一两年内

04:28.500 --> 04:29.500
他们会长期共存

04:30.660 --> 04:31.140
然后接下来

04:31.140 --> 04:32.180
我这里写一个配置

04:32.180 --> 04:32.700
data

04:32.700 --> 04:33.380
就是我们的

04:33.380 --> 04:34.980
这里边要显示什么样的数据

04:34.980 --> 04:36.300
比方说我们这里简单写一个啊

04:36.300 --> 04:37.300
就是我们的

04:37.300 --> 04:38.180
今天你们是你们的

04:38.180 --> 04:38.940
molika小姐姐

04:38.940 --> 04:40.180
我们就写他的名字啊

04:40.180 --> 04:40.500
molika

04:41.620 --> 04:41.820
好了

04:41.820 --> 04:42.540
就配置好了啊

04:42.540 --> 04:43.500
我们就写这么一点点

04:44.460 --> 04:44.780
然后呢

04:44.780 --> 04:46.460
把它保存到一个变量里面

04:46.460 --> 04:46.700
变

04:47.860 --> 04:49.380
随便取个变量名字

04:49.400 --> 04:50.400
然后这个dm里边

04:50.400 --> 04:51.000
我们写啥呢

04:51.000 --> 04:51.960
我们就随便写一些

04:51.960 --> 04:53.160
随便你想借他就写啥

04:53.160 --> 04:54.680
我们就写个 ac 运输

04:54.680 --> 04:56.560
这个 ac 运输里边显示啥呢

04:56.560 --> 04:58.360
就显示这个名字

04:58.360 --> 04:58.480
好

04:58.480 --> 04:59.280
接下来我们要这里

04:59.280 --> 04:59.920
这样子写啊

04:59.920 --> 05:01.640
这是无诱里边的就是

05:01.640 --> 05:02.320
叫大虎

05:02.320 --> 05:03.200
大虎字语法

05:03.200 --> 05:04.760
Mustache 语法

05:04.760 --> 05:06.520
我们这里都要写上lamb

05:06.520 --> 05:07.560
表啥意思呢

05:07.560 --> 05:08.080
我们在

05:08.080 --> 05:10.160
无诱在渲染这个区域的时候呢

05:10.160 --> 05:12.360
就把我们数据里边的lamb

05:12.360 --> 05:13.720
渲染到这个位置

05:13.720 --> 05:13.880
好

05:13.880 --> 05:14.960
接下来我们来看一下

05:19.890 --> 05:20.850
目前显示一下的molika

05:20.850 --> 05:21.170
对吧

05:21.190 --> 05:23.510
我们的 ac 运输里边显示出来的molika

05:23.510 --> 05:23.870
然后呢

05:23.870 --> 05:24.990
接着一个神奇的现象

05:24.990 --> 05:25.430
我们主要

05:25.430 --> 05:27.230
今天晚上主要是关注这个现象

05:27.230 --> 05:28.030
咱们刚才保存了

05:28.030 --> 05:28.870
那个变量对不对

05:28.870 --> 05:29.550
vm

05:29.550 --> 05:30.470
这个vm呢

05:30.470 --> 05:33.190
他会自动加一个属性叫內

05:33.190 --> 05:33.870
属性哪来的

05:33.870 --> 05:35.510
就是从这来的啊

05:35.510 --> 05:36.990
那么我们来看一下这个属性

05:36.990 --> 05:38.110
是molika

05:38.110 --> 05:40.110
他更加神奇的是这个属性呢

05:41.670 --> 05:42.630
我跟他重新复制

05:42.630 --> 05:43.670
比方说刚复制为中文

05:43.670 --> 05:45.110
molika

05:45.110 --> 05:45.870
一回车

05:45.870 --> 05:48.030
你会发现界面自动变了

05:48.030 --> 05:49.310
我们今天要搞定这件事

05:50.290 --> 05:52.090
他到底是怎么回事

05:52.090 --> 05:52.250
好

05:52.250 --> 05:53.730
那么这就引出了一个问题

05:53.730 --> 05:53.890
啊

05:53.890 --> 05:54.770
大家不要去关注

05:54.770 --> 05:55.850
我这个五又怎么去使用

05:55.850 --> 05:57.210
这不是我们今天的重点

05:57.210 --> 05:58.730
我们今天关注什么重点

05:58.730 --> 06:01.050
关注这么一个很奇怪的现象

06:01.050 --> 06:01.930
我有一个对象

06:01.930 --> 06:03.050
vm

06:03.050 --> 06:04.810
他的属性变了

06:04.810 --> 06:06.810
界面自动重新渲染

06:08.210 --> 06:10.370
那么这个问题切出来的话

06:10.370 --> 06:11.570
他是一个什么样的问题呢

06:11.570 --> 06:12.570
就是说

06:12.570 --> 06:14.010
我有这么一个对象

06:15.770 --> 06:16.370
比方说

06:16.370 --> 06:21.890
比方说等于等于

06:21.890 --> 06:22.490
比方说啊

06:22.490 --> 06:23.370
就例子

06:23.370 --> 06:23.810
然后呢

06:23.810 --> 06:25.210
有一个渲染函数

06:25.210 --> 06:26.010
假设我们今天

06:26.010 --> 06:27.730
渲染函数不在我们今天考虑范围之内

06:27.730 --> 06:29.530
就假设有这么一个函数

06:29.530 --> 06:30.570
我们就这里输出

06:32.610 --> 06:35.590
渲染了

06:35.590 --> 06:36.550
有这么一个函数啊

06:36.550 --> 06:37.070
你看啊

06:37.070 --> 06:38.150
我们现在有一个对象

06:38.150 --> 06:39.230
有一个函数

06:39.230 --> 06:41.110
现在的奇怪的问题是

06:41.110 --> 06:43.510
我给这个对象里边的一个属性复制

06:44.430 --> 06:45.270
怎么样

06:45.270 --> 06:46.630
一复制就掉入那个函数

06:46.630 --> 06:47.870
一复制就掉入那个函数

06:48.850 --> 06:50.130
他是怎么做得到的

06:51.730 --> 06:52.850
你现在怎么做得到

06:52.850 --> 06:54.250
你现在做不到

06:54.250 --> 06:55.050
为什么做不到

06:55.050 --> 06:56.770
因为在GS里边

06:56.770 --> 06:58.690
你给一个变量也好

06:58.690 --> 07:00.730
给一个属性也好复制

07:01.530 --> 07:02.170
其他的

07:02.170 --> 07:04.370
其他代码是无法感知到的

07:04.370 --> 07:06.250
他不知道你复制了

07:06.250 --> 07:07.530
原来意思吧

07:07.530 --> 07:09.570
那么我们现在就必须要找到一个关键点

07:09.570 --> 07:10.730
就是说

07:10.730 --> 07:12.530
我怎么样让他知道

07:12.530 --> 07:14.050
我一个东西变了

07:14.050 --> 07:14.930
怎么样让他知道了

07:14.930 --> 07:16.210
这就需要用到我们

07:16.590 --> 07:19.270
也是无里边的一个API

07:19.270 --> 07:19.990
叫做obj

07:19.990 --> 07:20.750
是Defan property

07:22.310 --> 07:23.470
Defan property

07:23.470 --> 07:24.670
那么这个API什么意思呢

07:24.670 --> 07:25.470
有些同学知道

07:25.470 --> 07:26.070
有些同学不知道

07:26.070 --> 07:26.670
我这里说一下

07:28.510 --> 07:31.350
叫做Defan property

07:33.110 --> 07:33.630
看一下吧

07:34.950 --> 07:36.750
我们比方说有个对象

07:36.750 --> 07:37.350
有个对象

07:37.350 --> 07:38.110
他是个空对象

07:38.110 --> 07:39.510
里边啥都没有

07:39.510 --> 07:40.070
然后呢

07:40.070 --> 07:42.310
我们平时给他加一些属性是怎么加的

07:42.310 --> 07:43.390
我们都是这样加的

07:43.390 --> 07:44.110
对不对

07:44.110 --> 07:45.110
加一个属性A

07:45.170 --> 07:46.490
加一个属性B

07:46.490 --> 07:46.890
好

07:46.890 --> 07:48.770
其实还有一种加属性的方式

07:50.050 --> 07:52.250
或者是改属性的方式

07:52.250 --> 07:53.850
怎么什么方式呢

07:53.850 --> 07:54.970
是使用Object的

07:54.970 --> 07:56.130
Object的一个静态

07:56.130 --> 07:57.290
还需要Defan property

07:58.530 --> 07:59.810
这里边传递几个参数

07:59.810 --> 08:00.650
大家一定要注意听

08:00.650 --> 08:01.850
今天的东西啊

08:01.850 --> 08:04.530
稍微一不留神就听不懂了

08:05.490 --> 08:07.090
第一个参数是ob

08:07.090 --> 08:07.610
就是对象

08:08.650 --> 08:09.530
Defan property什么意思

08:09.530 --> 08:10.210
Defan什么意思

08:10.210 --> 08:12.290
定义Property属性

08:12.290 --> 08:13.210
定义一个属性

08:13.210 --> 08:13.970
给谁定义了

08:13.970 --> 08:15.090
给这个对象

08:15.090 --> 08:16.110
定义什么属性呢

08:16.110 --> 08:17.910
第二个参数写属性的名字

08:17.910 --> 08:19.230
比较定义的属性A

08:20.310 --> 08:20.470
好

08:20.470 --> 08:21.790
第三个参数呢

08:21.790 --> 08:22.590
是一个对象

08:22.590 --> 08:24.190
这个对象叫做属性描述服

08:25.510 --> 08:26.070
描述服

08:28.270 --> 08:29.950
我记得之前我讲这个玩意

08:29.950 --> 08:31.310
讲了一节课

08:31.310 --> 08:32.310
我真的简单说一下

08:32.310 --> 08:32.950
属性描述服

08:32.950 --> 08:35.350
描述服里边有很多东西可以定义

08:35.350 --> 08:37.070
那么其中一个东西啊

08:37.070 --> 08:38.230
叫做get

08:38.230 --> 08:38.950
它是一个方法

08:40.190 --> 08:40.950
这个get的方法呢

08:40.950 --> 08:42.030
我们这样子写吧

08:42.030 --> 08:43.390
用原词写发起

08:43.390 --> 08:44.590
看得懂一点

08:44.610 --> 08:46.330
它是一个方法

08:46.330 --> 08:48.490
那么这个get的方法的反回值

08:48.490 --> 08:50.890
我们要返回一个1

08:50.890 --> 08:51.850
咱们来看一下

08:51.850 --> 08:53.410
一个很神仙的现象就出现了

08:53.410 --> 08:54.530
我们输出一下

08:54.530 --> 08:55.850
OB接点A

08:55.850 --> 08:57.810
你这里不是定义这个属性A吗

08:57.810 --> 08:59.890
也属性A的指示啥呢

08:59.890 --> 09:03.570
当你这样子去定义一个属性描述服的时候

09:03.570 --> 09:05.370
你出现了get的方法

09:05.370 --> 09:06.330
于是呢

09:06.330 --> 09:08.010
这个对象跟你以前的对象不一样

09:08.010 --> 09:10.130
这个属性跟你以前的属性不一样

09:10.130 --> 09:11.490
它不是一个普通属性的

09:11.490 --> 09:12.730
我们把它叫做

09:12.730 --> 09:14.290
访问器

09:14.290 --> 09:16.470
这个属性A叫做一个访问器

09:16.470 --> 09:19.190
当它去读取这个属性的时候

09:19.190 --> 09:21.510
它会自动的运行这个get的方法

09:21.510 --> 09:23.510
返回一个1

09:23.510 --> 09:25.270
它会把它的返回结果

09:25.270 --> 09:26.710
作为这个表达式的结果

09:26.710 --> 09:28.270
因此这个代码输出的结果就是1

09:29.990 --> 09:31.350
别人的意思吧

09:31.350 --> 09:31.870
好

09:31.870 --> 09:32.270
然后呢

09:32.270 --> 09:33.350
它除了有get之外呢

09:33.350 --> 09:34.390
还有一个set的方法

09:36.150 --> 09:38.070
set的方法接受一个参数

09:38.070 --> 09:39.710
那么get是读取值

09:39.710 --> 09:40.150
对吧

09:40.150 --> 09:41.990
那么set的自然然是复值

09:41.990 --> 09:42.590
接受一个参数

09:42.810 --> 09:43.610
就是以复的值

09:45.050 --> 09:45.610
那么这里呢

09:45.610 --> 09:46.490
我们输出一个

09:50.850 --> 09:51.730
复值是

09:54.410 --> 09:55.970
那么如果说这样子一写的话

09:55.970 --> 09:56.490
你看着啊

09:57.650 --> 09:59.410
我们这里给ob接

10:00.130 --> 10:02.210
点A这个属性复值的时候

10:02.210 --> 10:03.490
它就会运行这个函数

10:04.210 --> 10:05.050
看一下

10:05.050 --> 10:05.730
我们这里呢

10:05.730 --> 10:06.650
复值为一个3

10:08.010 --> 10:08.610
点击右键

10:08.610 --> 10:09.170
ROCKED

10:09.170 --> 10:09.610
你看

10:09.610 --> 10:10.650
是不是复值是3

10:11.410 --> 10:11.690
对不对

10:11.690 --> 10:13.010
它就会运行这个函数

10:13.010 --> 10:13.450
于是呢

10:13.450 --> 10:14.810
有了这么一个东西过后

10:14.810 --> 10:18.150
它对属性的读取和对属性的复值

10:18.150 --> 10:19.670
是不是有个函数会运行

10:20.710 --> 10:22.470
那么既然函数会运行

10:22.470 --> 10:23.990
那么我们是不是可以在函数里

10:23.990 --> 10:25.310
比较像刚才那样子

10:25.310 --> 10:27.830
干嘛去调用那个Render函数

10:27.830 --> 10:28.150
对吧

10:28.150 --> 10:28.550
我们在这里

10:28.550 --> 10:29.910
是不是可以调用那个Render函数

10:29.910 --> 10:30.830
重新渲染

10:30.830 --> 10:31.230
对不对

10:31.230 --> 10:32.230
我们就要解决这样的问题

10:33.070 --> 10:33.990
要顺便问一句

10:35.950 --> 10:42.280
我这句话输出什么

10:42.280 --> 10:46.190
这句话输出什么

10:46.190 --> 10:46.550
啊

10:46.550 --> 10:47.630
非常好啊

10:47.630 --> 10:48.310
输出了结果

10:48.310 --> 10:49.230
仍然是1

10:49.230 --> 10:49.670
对不对

10:49.670 --> 10:50.670
仍然是1

10:50.670 --> 10:51.230
为什么呢

10:51.230 --> 10:53.090
因为这两句话实际上运行函数

10:53.090 --> 10:54.370
这句话在运行这个函数

10:54.370 --> 10:55.690
这个函数啥都没说

10:55.690 --> 10:56.490
然后这句话呢

10:56.490 --> 10:57.330
在运行这个函数

10:57.330 --> 10:58.090
这个函数返回1

10:58.090 --> 10:59.050
它就输出1

10:59.050 --> 10:59.610
对吧

10:59.610 --> 11:00.290
看一下

11:00.290 --> 11:01.210
复值是3

11:01.210 --> 11:02.530
这个函数运行了

11:02.530 --> 11:04.650
然后得到的结果还是1

11:04.650 --> 11:06.330
那么如果说我要把它做成一个

11:06.330 --> 11:07.690
稍微正常一点的感觉

11:07.690 --> 11:08.250
是怎么感觉的

11:08.250 --> 11:09.770
我们就可以在这里定一个辩量

11:09.770 --> 11:10.970
Intel

11:10.970 --> 11:12.090
内部的值

11:12.090 --> 11:14.010
Value

11:14.010 --> 11:15.850
比方说默认为1

11:15.850 --> 11:16.330
那么这里呢

11:16.330 --> 11:18.330
我就返回这个值

11:18.330 --> 11:19.810
那么这里复值的时候呢

11:19.810 --> 11:21.750
我就把这个值

11:21.750 --> 11:22.750
复给谁了

11:22.750 --> 11:23.590
Intel

11:23.590 --> 11:23.990
Value

11:23.990 --> 11:25.230
复值之位

11:25.230 --> 11:26.790
那么就变成一个正常属性了

11:26.790 --> 11:27.830
当你给它复值的时候

11:27.830 --> 11:29.910
实际上运行的是这个函数

11:29.910 --> 11:31.710
它把这个3复值给它了

11:31.710 --> 11:32.110
然后呢

11:32.110 --> 11:32.870
读它的值的时候

11:32.870 --> 11:33.950
你把它的值读出来

11:33.950 --> 11:34.110
对吧

11:34.110 --> 11:35.950
我们用一个临时辩量来保存一下

11:35.950 --> 11:36.630
None code

11:36.630 --> 11:38.350
你看得到结果就是3

11:38.350 --> 11:39.830
这是个Define property

11:39.830 --> 11:40.630
在Value2里边

11:40.630 --> 11:42.350
要完成数据想用式

11:42.350 --> 11:43.550
什么叫数据想用式

11:43.550 --> 11:45.110
就是数据一变

11:45.110 --> 11:47.070
有些事情就发生了

11:47.070 --> 11:47.950
有些东西

11:47.950 --> 11:49.230
有些事情就启动了

11:49.230 --> 11:50.450
叫数据想用式

11:50.450 --> 11:52.490
它能监听到数据的变化

11:52.490 --> 11:54.410
那么就靠的是这两个东西

11:54.410 --> 11:54.530
好

11:54.530 --> 11:55.050
接下来

11:55.050 --> 11:56.210
我们来一步一步完成

11:56.210 --> 11:58.210
我们的数据想用系统

11:58.210 --> 11:59.170
那么在Value2里边

11:59.170 --> 12:01.290
我要完成数据想用系统

12:01.290 --> 12:02.730
我们需要做两个练习

12:02.730 --> 12:03.690
三个练习

12:03.690 --> 12:04.770
这三个练习做完了

12:04.770 --> 12:06.890
数据想用系统就完了

12:06.890 --> 12:07.610
第一个练习

12:07.610 --> 12:09.130
大家看一下

12:09.130 --> 12:10.210
我有这么一个函数

12:10.210 --> 12:11.890
叫Observe

12:11.890 --> 12:12.930
观察

12:12.930 --> 12:13.410
观察一下

12:13.410 --> 12:15.170
观察一个东西的变化

12:15.170 --> 12:16.890
你给我传一个对象进来

12:16.890 --> 12:19.350
我不拿做一些事情

12:19.350 --> 12:20.630
那么这个函数有什么作用呢

12:20.630 --> 12:21.830
下面有个测试代码

12:21.830 --> 12:24.750
我们的目的就是把测试跑通

12:24.750 --> 12:25.950
测试代码是什么

12:25.950 --> 12:27.270
有一个对象

12:27.270 --> 12:28.390
对象有个name属性

12:28.390 --> 12:29.270
有一个addr

12:29.270 --> 12:30.390
追时属性

12:30.390 --> 12:31.270
居住地址

12:31.270 --> 12:32.830
它又是一个对象

12:32.830 --> 12:34.670
对象里边有两个属性

12:34.670 --> 12:36.270
pervance和city

12:36.270 --> 12:37.070
对不对

12:37.070 --> 12:37.670
那么现在

12:37.670 --> 12:39.230
我假设这个函数写完了

12:39.230 --> 12:40.470
这里表示实现

12:40.470 --> 12:41.630
假设这个函数写完了

12:41.630 --> 12:43.470
我把对象传进去

12:43.470 --> 12:44.270
那么从此以后

12:44.270 --> 12:46.550
对象变得很神奇了

12:46.570 --> 12:48.010
我只要一读它的名字

12:48.010 --> 12:49.490
它就会输出这么一句话

12:49.490 --> 12:50.930
get name

12:50.930 --> 12:52.530
molika

12:52.530 --> 12:53.690
我一给它名字复词

12:53.690 --> 12:54.890
它就会输出这么一句话

12:54.890 --> 12:56.850
set name

12:56.850 --> 12:58.050
molika

12:58.050 --> 12:59.250
我给这个属性复词

12:59.250 --> 13:00.810
它就会输出这么一句话

13:00.810 --> 13:02.410
我给这个属性读取

13:02.410 --> 13:03.610
它就会输出这么一句话

13:03.610 --> 13:06.290
这就是我们要完成的事情

13:06.290 --> 13:07.290
大家可以想一想

13:07.290 --> 13:10.760
这件事情怎么去做

13:10.760 --> 13:12.560
其实有刚才的支持的话

13:12.560 --> 13:13.840
这件事情其实要做起来

13:13.840 --> 13:15.080
也并不难

13:15.080 --> 13:16.560
我们要做什么事情

13:16.560 --> 13:18.120
它给我传了一个对象过来

13:18.120 --> 13:20.900
我们要做的事情就是循环变立

13:20.900 --> 13:22.780
这个对象的所有属性

13:22.780 --> 13:24.660
把它的每一个属性改了

13:24.660 --> 13:25.380
改成什么

13:25.380 --> 13:27.340
改成我们刚才的那种模式

13:27.340 --> 13:29.340
用这种模式去定义它的属性

13:29.340 --> 13:30.860
它不能是一个普通属性的

13:30.860 --> 13:33.220
如果说它是一个普通的属性的话

13:33.220 --> 13:35.100
你读属性的读属性的词

13:35.100 --> 13:36.140
你能监听到吗

13:36.140 --> 13:37.340
你监听不到

13:37.340 --> 13:39.140
它不会发生任何事情

13:39.140 --> 13:40.900
所以说我们必须要把它改了

13:40.900 --> 13:41.740
那怎么来改呢

13:41.740 --> 13:43.620
其实这件事情很简单

13:43.620 --> 13:46.140
我们就是循环它的每一个属性就行了

13:46.140 --> 13:48.020
那么你可以用佛印循环

13:48.020 --> 13:48.800
那也可以用什么

13:48.800 --> 13:50.360
用ES5的一个API

13:50.360 --> 13:52.240
叫Objects piece

13:52.240 --> 13:54.080
见过没

13:54.080 --> 13:55.160
把一个对象传信来

13:55.160 --> 13:56.120
它会返回什么了

13:56.120 --> 13:59.360
它会返回这个对象的所有的属性的名字

13:59.360 --> 13:59.920
你看一下吧

13:59.920 --> 14:01.520
比较说我们这里有一个对象

14:04.400 --> 14:06.680
今天晚上可能会遇到一些新的API

14:06.680 --> 14:08.840
因为绑络的基础可能比较差

14:08.840 --> 14:10.720
它没有接触到这些API

14:10.720 --> 14:11.920
API其实并不复杂

14:11.920 --> 14:14.120
就是比较多而已东西

14:14.120 --> 14:16.440
你看反过来就是一个数组

14:16.500 --> 14:18.500
看看数组

14:18.500 --> 14:19.540
数组里边有两项

14:19.540 --> 14:20.780
一个是属性名字

14:20.780 --> 14:22.900
属性名字两个字不错嘛

14:22.900 --> 14:23.740
就这么个意思

14:23.740 --> 14:25.060
那么我们知道数组里边

14:25.060 --> 14:27.340
是不是有一个函数叫做4e

14:27.340 --> 14:28.500
是不是可以循环

14:28.500 --> 14:30.580
循环数组里边的每一项

14:30.580 --> 14:31.580
有没有接触到这个函数

14:31.580 --> 14:33.060
这个函数也是ES5的

14:33.060 --> 14:35.020
就数组里边比较123

14:35.020 --> 14:36.620
或者是徐滇习吧

14:36.620 --> 14:38.820
124

14:38.820 --> 14:39.500
这是个数组

14:39.500 --> 14:41.700
数组里边一提供一个函数叫4e

14:41.700 --> 14:43.700
那么这个函数里边传的是什么

14:43.700 --> 14:44.900
传的是一个毁掉函数

14:44.900 --> 14:46.560
我们可以用箭头函数

14:46.560 --> 14:48.960
毁掉函数的第一个参数

14:48.960 --> 14:51.720
就是数组的每一项的值

14:51.720 --> 14:54.080
你说它把第一项拿出来运行这个函数

14:54.080 --> 14:55.880
第二项拿出来运行这个函数

14:55.880 --> 14:58.040
把第一项的值传给它运行一次

14:58.040 --> 15:00.400
然后把第二项的值传给它运行一次

15:00.400 --> 15:00.960
那么这里呢

15:00.960 --> 15:01.440
比较重点

15:01.440 --> 15:02.160
这里console

15:02.160 --> 15:02.960
比较low的

15:02.960 --> 15:04.960
来看一下数据结构

15:04.960 --> 15:06.080
所以1624

15:06.080 --> 15:07.160
这可以循环数组了

15:07.160 --> 15:09.880
当然你可以用缝印循环

15:09.880 --> 15:11.480
那缝印循环

15:11.480 --> 15:12.560
最好不要用缝印循环

15:12.560 --> 15:14.560
因为那里边有一个

15:14.580 --> 15:17.100
有一个编辆作用律提升的问题

15:17.100 --> 15:18.140
用这个比较好一点

15:18.140 --> 15:20.940
当然将来你们学了那个

15:20.940 --> 15:21.660
net

15:21.660 --> 15:23.020
console

15:23.020 --> 15:24.220
那么就不存在这样的问题了

15:24.220 --> 15:25.980
不过我们现在用这个

15:25.980 --> 15:27.100
我们用箭头函数

15:27.100 --> 15:28.780
是不是可以拿到每一个属性

15:28.780 --> 15:29.980
属性值

15:29.980 --> 15:30.540
对不对

15:30.540 --> 15:32.100
输出p

15:32.100 --> 15:32.380
啊

15:32.380 --> 15:33.780
我们调用这个obz

15:33.780 --> 15:35.460
我们把下面去掉

15:35.460 --> 15:36.580
先下面先去掉

15:36.580 --> 15:37.540
然后运行一下

15:37.540 --> 15:39.980
看看能不能输出这个对象的每一个属性

15:39.980 --> 15:40.860
运行

15:40.860 --> 15:41.900
你看是不是name

15:41.900 --> 15:42.460
addr

15:42.460 --> 15:43.940
说两个属性输出了

15:43.960 --> 15:44.600
对不对

15:44.600 --> 15:45.920
两个属性输出了

15:45.920 --> 15:46.480
好

15:46.480 --> 15:49.040
那么拿到每一个属性的名字过后

15:49.040 --> 15:49.760
接下来干嘛呢

15:49.760 --> 15:51.720
我们是不是重新定义一下

15:51.720 --> 15:53.840
这个属性的东西

15:53.840 --> 15:55.240
他不再是一个普通属性了

15:55.240 --> 15:56.960
我们怎么来定义呢

15:56.960 --> 16:00.320
是要重新定义属性

16:00.320 --> 16:02.320
不能再是原来的那种普通属性了啊

16:02.320 --> 16:04.680
也必须要是个很特殊的访问器

16:04.680 --> 16:05.480
obz

16:05.480 --> 16:07.480
define property

16:07.480 --> 16:10.000
对象传进去

16:10.000 --> 16:11.920
这就是传属性的名字

16:11.940 --> 16:12.740
属性的名字是啥

16:12.740 --> 16:13.900
是不是t

16:13.900 --> 16:14.580
对不对

16:14.580 --> 16:15.300
传属性的名字

16:15.300 --> 16:17.020
我重新定一下这个属性

16:17.020 --> 16:19.060
然后这个属性不再是一个普通属性了

16:19.060 --> 16:20.060
变成了一个什么呢

16:20.060 --> 16:21.900
变成了一个一台有访问器的东西

16:21.900 --> 16:23.580
define property

16:23.580 --> 16:24.580
我说

16:24.580 --> 16:27.220
这个代码我实在是看的不是很舒服啊

16:27.220 --> 16:28.340
我给他说一下啊

16:28.340 --> 16:30.820
在es6里边支持

16:30.820 --> 16:31.980
数写方法

16:31.980 --> 16:34.260
就这样的一个方法写法了

16:34.260 --> 16:37.180
你可以把它简化成这个样子

16:37.180 --> 16:38.020
这种写法

16:38.020 --> 16:40.540
等同于这种写法一点不带差的

16:40.560 --> 16:41.920
只是一个缩写

16:41.920 --> 16:43.200
这样写的看上舒服一点啊

16:44.560 --> 16:44.760
好

16:44.760 --> 16:46.360
那么现在我们调用电视的时候

16:47.800 --> 16:48.400
还有一个set

16:50.200 --> 16:50.840
一样的

16:50.840 --> 16:52.720
这种写法等同于这种写法

16:53.840 --> 16:54.440
好

16:54.440 --> 16:56.600
那么现在我们这里边写啥呢

16:56.600 --> 16:58.080
当我要读去这个属性的时候

16:58.080 --> 17:01.760
我给他返回啥呢

17:01.760 --> 17:03.920
根据我们刚才写的东西

17:03.920 --> 17:04.920
是不是有点提示啊

17:06.200 --> 17:07.120
我们是不是可以用它

17:07.120 --> 17:09.000
用它来记录一下

17:09.000 --> 17:10.920
那么我们可以在定义属性之前

17:10.940 --> 17:12.340
就把这个intel

17:12.340 --> 17:13.500
定一个辨量

17:13.500 --> 17:13.980
intel

17:15.060 --> 17:15.460
Value

17:17.260 --> 17:18.180
这是辨历属性

17:18.180 --> 17:18.980
对不对

17:18.980 --> 17:19.940
主持啊

17:19.940 --> 17:20.420
辨历

17:21.380 --> 17:23.780
对象的每一个属性

17:23.780 --> 17:24.100
当然了

17:24.100 --> 17:26.220
我们这里要如果说做严格一点的话

17:26.220 --> 17:27.060
我们最好判断一下

17:27.060 --> 17:28.380
它是不是一个对象

17:28.380 --> 17:29.500
如果说不是一个对象的话

17:29.500 --> 17:30.700
那么我什么都不用干

17:30.700 --> 17:32.060
因此我这些判断一下

17:32.060 --> 17:33.340
我们写一个辅助函数

17:33.340 --> 17:34.380
叫做ease object

17:35.220 --> 17:36.900
判断一个东西是不是一个对象

17:38.580 --> 17:42.270
判断一个东西是不是一个对象

17:43.050 --> 17:44.730
判断一个值

17:44.730 --> 17:47.090
是否是一个普通对象

17:47.090 --> 17:48.850
我们不考虑数据问题啊

17:48.850 --> 17:50.570
在Value里边

17:50.570 --> 17:51.770
数据还有特殊处理

17:51.770 --> 17:53.170
我们不考虑数据问题

17:53.170 --> 17:54.770
我们只关注响应式

17:54.770 --> 17:54.890
好

17:54.890 --> 17:55.890
那么现在我们怎么来判断

17:55.890 --> 17:56.890
它是不是对象的

17:56.890 --> 17:57.370
首先

17:59.210 --> 18:00.730
它不能等于闹

18:02.650 --> 18:04.850
并且它不是一个数据

18:06.130 --> 18:07.450
而为ease而为

18:09.050 --> 18:11.090
这是es6给我们提供的啊

18:11.090 --> 18:12.090
一个静态函数

18:12.110 --> 18:13.510
判断一个值是不是一个数据

18:14.550 --> 18:15.750
那么它不是一个数据

18:16.630 --> 18:17.910
它既不是数据

18:17.910 --> 18:18.750
又不是闹

18:19.630 --> 18:20.790
同时它的title

18:21.750 --> 18:22.950
等于 object

18:23.590 --> 18:25.630
就是判断一个普通对象的方法

18:25.630 --> 18:26.950
它是不是一个对象

18:26.950 --> 18:27.230
好

18:27.230 --> 18:28.390
以为这个辅助函数过后

18:28.390 --> 18:30.150
我们可以先判断一下啊

18:30.150 --> 18:31.350
如果说它不是一个对象

18:32.430 --> 18:33.110
它不是一个对象

18:33.110 --> 18:33.870
我们直接返回

18:33.870 --> 18:34.350
停止

18:35.550 --> 18:36.870
不处理

18:36.870 --> 18:37.510
非对象

18:38.550 --> 18:40.070
而不是对象我就不处理了

18:40.070 --> 18:40.870
我只处理对象

18:41.010 --> 18:42.410
把一个严格性判断一下

18:43.370 --> 18:43.650
好了

18:43.650 --> 18:45.570
那么现在我们回到这来啊

18:45.570 --> 18:46.530
我们这里呢

18:46.530 --> 18:47.770
有一个intel value

18:47.770 --> 18:50.530
一开始是不是要等于这个属性的值啊

18:50.530 --> 18:51.730
我们便利它每一个属性

18:51.730 --> 18:53.290
把每一个属性全部重新来一遍

18:54.170 --> 18:55.330
重新定义一遍

18:55.330 --> 18:56.930
那么我们要这里要得到

18:56.930 --> 18:59.130
一开始得到它属性的值是多少

18:59.130 --> 18:59.930
那么我们怎么来得到

19:00.730 --> 19:01.650
是不是可以用这种方式

19:03.810 --> 19:04.290
这种方式

19:05.130 --> 19:06.050
有的可能在这里

19:06.050 --> 19:07.050
还是产生问题啊

19:07.050 --> 19:07.810
可能要这样的写

19:07.810 --> 19:09.290
这样写就不对了啊

19:09.310 --> 19:11.270
这样的去读它的属性的名字是key

19:12.670 --> 19:13.390
它不是动态的

19:13.390 --> 19:13.830
对吧

19:13.830 --> 19:15.430
它没有这个属性名字啊

19:15.430 --> 19:16.550
应该是用这种写法

19:16.550 --> 19:17.750
叫属性表达式

19:17.750 --> 19:18.750
用表达式的写法

19:18.750 --> 19:20.470
动态的读取该属性的值

19:21.990 --> 19:23.830
换出该属性的值

19:25.230 --> 19:26.430
然后呢

19:26.430 --> 19:27.590
当它更加的时候呢

19:27.590 --> 19:28.990
我就返回这个值

19:28.990 --> 19:30.190
intel value

19:30.190 --> 19:31.310
当c车的时候呢

19:31.310 --> 19:32.350
非常简单

19:32.350 --> 19:35.350
我就intel value等于

19:38.070 --> 19:38.470
对不对

19:38.530 --> 19:39.690
是跟这边的写法是一样的

19:40.930 --> 19:41.970
看没

19:41.970 --> 19:42.370
没问题吧

19:43.570 --> 19:43.770
好

19:43.770 --> 19:45.250
那么咱们为怎么来

19:45.250 --> 19:46.610
才能达到这样的效果呢

19:46.610 --> 19:49.170
你读属性的时候是会运行介绍方法

19:49.170 --> 19:49.490
于是呢

19:49.490 --> 19:50.570
我在这里可以输出一下

19:51.970 --> 19:52.610
介绍

19:52.610 --> 19:53.210
介绍啥

19:53.210 --> 19:53.810
哪个key

19:54.650 --> 19:55.730
拼介绍key就行了

19:55.730 --> 19:56.730
是吧

19:56.730 --> 19:57.810
介绍某个东西

19:57.810 --> 19:58.570
一个冒号

19:58.570 --> 19:59.290
然后呢

19:59.290 --> 20:00.010
是它的值

20:00.010 --> 20:00.650
它的值是什么

20:00.650 --> 20:01.290
intel value

20:02.330 --> 20:04.130
intel value

20:06.370 --> 20:07.290
那么c车的时候

20:07.310 --> 20:08.190
给它复制的时候

20:08.190 --> 20:09.510
我们就会运行一个方法

20:09.510 --> 20:10.510
set

20:10.510 --> 20:11.790
拼介一下key

20:11.790 --> 20:12.870
再拼介一下

20:12.870 --> 20:13.990
冒号

20:13.990 --> 20:14.590
那么这里呢

20:14.590 --> 20:15.150
就是

20:16.430 --> 20:16.790
放

20:16.790 --> 20:17.030
对吧

20:17.030 --> 20:17.790
我们写到后边吧

20:17.790 --> 20:18.790
或者就是写到后边

20:20.230 --> 20:20.550
小证

20:22.230 --> 20:23.470
说可以

20:23.470 --> 20:23.990
你看啊

20:23.990 --> 20:25.230
它读属属性的时候

20:25.230 --> 20:26.710
它就会运行这个函数

20:26.710 --> 20:27.630
给属性复制的时候

20:27.630 --> 20:28.710
就会运行这个函数

20:28.710 --> 20:29.190
于是呢

20:29.190 --> 20:30.190
你看这两行测试

20:30.190 --> 20:30.830
肯定是没

20:30.830 --> 20:32.310
能通过了

20:32.310 --> 20:32.950
来运行一下

20:34.470 --> 20:34.950
你看

20:34.950 --> 20:36.710
我给它读属性的时候

20:36.710 --> 20:37.610
是不是运行到这句话

20:37.610 --> 20:39.250
它就输出了这样的结果

20:39.250 --> 20:39.850
然后呢

20:39.850 --> 20:41.090
给属性复制的时候

20:41.090 --> 20:42.090
是不是输出了这样的结果

20:43.450 --> 20:43.810
对不对

20:45.010 --> 20:46.170
没问题吧

20:46.170 --> 20:46.810
听到这一块

20:46.810 --> 20:47.570
有没有什么问题

20:47.570 --> 20:47.890
没问题

20:47.890 --> 20:48.770
QQ

20:48.770 --> 20:49.770
今天的东西

20:49.770 --> 20:50.690
考试极其简单

20:50.690 --> 20:52.290
不要想的考试推费啊

20:52.290 --> 20:53.730
推费是基本上是

20:53.730 --> 20:55.010
每个同学只要来听了课

20:55.010 --> 20:55.650
你只要来听

20:55.650 --> 20:56.170
不听课了

20:56.170 --> 20:57.010
没办法

20:57.010 --> 20:57.730
你只要来听了课

20:57.730 --> 20:59.450
哪怕你全部都没有听懂

20:59.450 --> 21:00.730
你只要来听了的

21:00.730 --> 21:02.010
你一定能过的啊

21:02.010 --> 21:03.250
基本上是个课程是给大家送的

21:03.250 --> 21:04.890
不要去考虑这个问题

21:04.890 --> 21:05.690
你觉得

21:05.710 --> 21:09.730
今天我讲的东西还不止九十九块钱吗

21:09.730 --> 21:09.970
好

21:09.970 --> 21:11.050
那么这一块没问题吧

21:11.050 --> 21:11.570
没问题的话

21:11.570 --> 21:13.010
咱们继续啊

21:13.010 --> 21:14.810
但是下面下面就出现问题了

21:14.810 --> 21:15.690
下面出现什么问题呢

21:15.690 --> 21:16.370
你看一下

21:16.370 --> 21:17.250
如果说我给它的

21:18.650 --> 21:20.650
属性里边的属性再复制

21:22.250 --> 21:22.890
行不行了

21:24.210 --> 21:24.770
它就不行了

21:25.850 --> 21:26.290
装扣的

21:28.370 --> 21:29.050
你看它下面

21:29.050 --> 21:30.730
这前两行我们刚刚看到的

21:30.730 --> 21:31.610
看到的对吧

21:31.610 --> 21:34.210
第三行它输出的不是set province

21:34.210 --> 21:34.890
输出的是什么呢

21:34.890 --> 21:36.530
一个get ADDR

21:36.530 --> 21:37.550
这个是一定要输出的啊

21:37.550 --> 21:38.150
为什么呢

21:38.150 --> 21:39.830
因为这个表达是

21:39.830 --> 21:41.310
我们的GS代码也可以看出

21:41.310 --> 21:42.430
它是什么运行的

21:42.430 --> 21:44.350
它是先读取这个表达式的指

21:44.350 --> 21:45.310
说要先读

21:45.310 --> 21:46.270
读这个属性

21:46.270 --> 21:48.590
读这个属性是不是被监听到了

21:48.590 --> 21:48.990
get

21:48.990 --> 21:50.190
是不是被监听到了

21:50.190 --> 21:51.950
把这个属性读出来过后

21:51.950 --> 21:54.270
再给它的属性 province 复制

21:54.270 --> 21:55.070
没二点意思吧

21:55.070 --> 21:56.550
但是后边就没有输出了

21:56.550 --> 21:57.950
没有输出这么一句话

21:57.950 --> 21:58.550
为什么呢

21:58.550 --> 22:01.070
因为它没有监听到这个对象里边的

22:01.870 --> 22:02.950
变化

22:02.950 --> 22:04.390
如果说你用浏览器看的话

22:04.410 --> 22:05.610
会看到

22:05.610 --> 22:06.690
非常非常明显

22:06.690 --> 22:08.090
比方说我们这里呢

22:08.090 --> 22:08.890
建立一个页面

22:08.890 --> 22:10.410
prec.tc

22:10.410 --> 22:14.380
1.it

22:14.380 --> 22:15.180
你用一下啊

22:15.180 --> 22:17.300
你用一下这个GS

22:17.300 --> 22:21.740
prec.tc

22:21.740 --> 22:26.020
1

22:26.020 --> 22:27.020
那么我们在这里边呢

22:27.020 --> 22:29.220
可以看到很明显啊

22:29.220 --> 22:29.940
不用这个脚奔

22:31.540 --> 22:32.100
这里不是有个

22:33.380 --> 22:35.780
这里没有定义辨量是吧

22:35.780 --> 22:36.580
我说没有定义辨量

22:36.580 --> 22:37.460
它就在Windows里边

22:38.400 --> 22:39.200
咱们可以看到

22:39.200 --> 22:45.320
打开这个页面看一下

22:45.320 --> 22:47.560
这个set

22:47.560 --> 22:48.600
这个对象你展开

22:48.600 --> 22:50.120
你会发现对象有点奇怪

22:50.120 --> 22:51.480
它跟我们普通的对象

22:51.480 --> 22:52.480
好像不一样

22:52.480 --> 22:53.400
这对象为什么奇怪了

22:53.400 --> 22:55.640
你看这里是有点点

22:55.640 --> 22:56.440
啥意思

22:56.440 --> 22:57.280
它这里指上去

22:57.280 --> 23:01.320
它提示的 evoke property getter

23:01.320 --> 23:02.160
你点一下

23:02.160 --> 23:03.600
它就会运行这个get韩数

23:04.840 --> 23:05.640
你看我点一下

23:06.640 --> 23:07.520
不仅运行到这个韩数

23:07.520 --> 23:08.760
你看这个是不是出来了

23:08.760 --> 23:09.640
这句话是不是出来了

23:09.640 --> 23:10.640
运行了这个韩数

23:10.700 --> 23:11.380
这里点一下

23:11.380 --> 23:12.540
它就会运行这个韩数

23:12.540 --> 23:12.820
对吧

23:12.820 --> 23:13.500
这就是属性

23:14.620 --> 23:15.700
这是属性的访问器

23:16.900 --> 23:17.620
这是大家见过没

23:19.620 --> 23:20.180
见过没

23:20.180 --> 23:24.020
在哪里见过的

23:24.020 --> 23:28.160
有没有同学见过这种三个点

23:28.160 --> 23:32.780
没有同学见过吗

23:32.780 --> 23:35.660
在哪里见过的

23:35.660 --> 23:36.060
或者

23:40.060 --> 23:41.180
不是这种三个点啊

23:41.180 --> 23:44.380
我说的是在这个流量器控制台里边

23:44.380 --> 23:45.300
打开属性

23:45.300 --> 23:47.180
它的属性是三个点

23:47.180 --> 23:47.780
它的属性

23:49.580 --> 23:50.180
它的属性

23:50.180 --> 23:51.220
它没有直接把属性

23:51.220 --> 23:52.020
直接我显示出来

23:52.020 --> 23:52.580
是三个点

23:53.980 --> 23:54.980
后台上回对象

23:54.980 --> 23:55.580
也不是啊

23:57.460 --> 24:05.900
你们没见过吗

24:05.900 --> 24:07.700
我们把body对象打印出来

24:07.700 --> 24:08.300
就是一个普通的

24:08.300 --> 24:09.260
多么对象打印出来

24:14.130 --> 24:15.690
body还不是

24:15.690 --> 24:17.130
我再打印一个什么呢

24:17.130 --> 24:18.970
我们得到一个 document

24:19.970 --> 24:20.770
这上面写个

24:20.770 --> 24:21.810
写个 id

24:26.930 --> 24:27.730
这么一个 div

24:28.630 --> 24:29.830
document

24:29.830 --> 24:31.030
div

24:32.030 --> 24:34.030
div

24:34.030 --> 24:35.030
div

24:35.830 --> 24:36.630
得到一个 div

24:36.630 --> 24:39.440
啊

24:39.440 --> 24:39.840
然后呢

24:39.840 --> 24:40.240
我们这里

24:40.240 --> 24:41.240
console

24:41.240 --> 24:41.940
log

24:41.940 --> 24:42.440
div

24:44.040 --> 24:44.840
console div

24:48.260 --> 24:48.560
哎呦

24:48.560 --> 24:49.160
这个 div

24:49.160 --> 24:51.160
他就把全部给他给我显示出来了

24:53.560 --> 24:54.760
我是怎么

24:54.760 --> 24:55.760
以前是怎么

24:55.760 --> 24:57.260
是用来的console

24:57.260 --> 24:58.160
什么东西呢

24:58.160 --> 24:59.460
如果说找不出来的话

24:59.460 --> 25:00.360
就算了啊

25:04.030 --> 25:05.530
我是用什么东西

25:05.530 --> 25:06.830
把不是第八个

25:06.830 --> 25:07.630
是用什么东西

25:07.630 --> 25:09.330
把他的一个正常的对象

25:09.330 --> 25:10.330
对象属性

25:10.330 --> 25:11.730
给我显示出来了

25:15.600 --> 25:16.500
我好像找不到了

25:16.500 --> 25:16.900
找不到这个

25:16.900 --> 25:17.900
还是我忘了

25:19.200 --> 25:20.100
啥意思呢

25:20.100 --> 25:21.000
其实跟他说的是

25:21.000 --> 25:23.300
就 div 这里面的很多属性里面

25:23.300 --> 25:24.900
发现他很奇怪吗

25:24.900 --> 25:26.900
你给他的一些属性负责的时候

25:27.700 --> 25:30.000
比方说给他 in the tax 负责

25:31.000 --> 25:32.100
就很奇怪

25:32.100 --> 25:33.900
你给一个对象的属性负责

25:33.900 --> 25:35.500
凭什么一页面动了

25:35.500 --> 25:37.200
一页面凭什么变了

25:37.200 --> 25:38.700
是因为这个属性啊

25:38.700 --> 25:41.000
他就是一个访问器

25:41.000 --> 25:42.700
就是一个访问器

25:42.700 --> 25:44.900
啊我如果给大家验证这一点的

25:44.900 --> 25:45.700
我们看不见包的话

25:45.700 --> 25:47.300
我们可以这样子

25:47.300 --> 25:47.700
get

25:49.600 --> 25:50.400
用这个方法

25:50.400 --> 25:52.000
可以得到一个属性的访问器

25:52.000 --> 25:54.200
得到一个得到一个 div 的属性

25:54.200 --> 25:55.700
in the tax

25:55.700 --> 25:56.300
你看一下吧

25:58.700 --> 26:02.380
这还不是个get own

26:02.380 --> 26:03.080
get

26:03.080 --> 26:09.080
啊这是他实在是原型上

26:10.380 --> 26:11.880
应该实在是原型上

26:11.880 --> 26:13.280
我们来看一下他他原型上啊

26:13.280 --> 26:14.180
实在搞不好就算了

26:14.180 --> 26:15.480
我们不用去在这里纠结

26:17.490 --> 26:19.090
原型上啊你看

26:21.650 --> 26:23.050
元素上这些属性啊

26:23.050 --> 26:24.250
全部都是这个

26:24.250 --> 26:25.850
全部都是属性访问器

26:25.850 --> 26:27.150
你看看这些属性

26:27.150 --> 26:28.350
全都是属性访问器

26:28.350 --> 26:29.750
怎么那是child

26:29.750 --> 26:30.650
为什么你的

26:31.750 --> 26:33.250
元素结构一更改

26:33.250 --> 26:34.050
他就自动变了

26:34.050 --> 26:34.950
为什么能自动变

26:34.950 --> 26:36.650
因为他在运行一个函数

26:36.650 --> 26:38.250
函数在动态计算

26:38.250 --> 26:39.350
你看没有这些东西

26:39.350 --> 26:40.750
全是属性访问器

26:41.650 --> 26:42.050
啊

26:43.250 --> 26:45.650
好那么这两回过头来再说到这里啊

26:47.520 --> 26:49.020
那么现在还有一个小的问题

26:50.120 --> 26:50.920
就是这里

26:51.420 --> 26:53.320
那一部的对象还没有还没有解决

26:53.320 --> 26:53.720
为什么呢

26:53.720 --> 26:55.020
你看我们刚才stead

26:55.620 --> 26:57.320
stead 里边这两个属性

26:57.720 --> 26:58.920
本身已经是变成访问器了

26:58.920 --> 26:59.320
对吧

26:59.320 --> 27:01.020
但是我们展开展开这个对象

27:01.020 --> 27:02.320
是不是一个普通对象啊

27:03.120 --> 27:04.120
是不是还有一个普通对象

27:04.120 --> 27:05.320
那么这个问题怎么解决

27:05.920 --> 27:08.020
对他的那种深层次的属性

27:08.020 --> 27:09.120
怎么来处理这个问题

27:10.520 --> 27:11.220
其实很简单

27:13.970 --> 27:15.270
你拿到这个属性值的

27:15.270 --> 27:15.770
对吧

27:15.770 --> 27:16.870
他有可能是对象

27:18.070 --> 27:19.870
他有可能是别的什么玩意

27:19.870 --> 27:20.770
有可能是个数字

27:20.770 --> 27:21.770
有可能是个字不算

27:21.770 --> 27:22.970
他可能是任何东西

27:23.170 --> 27:24.470
管他是什么东西

27:24.570 --> 27:25.770
你也要被监听

27:26.870 --> 27:27.770
第一规一定要用

27:27.770 --> 27:28.270
对吧

27:28.870 --> 27:30.070
第一规监听

27:32.080 --> 27:32.880
该属性

27:33.580 --> 27:34.780
这个属性我甭管你事啥

27:34.780 --> 27:35.780
如果说你不是对象的话

27:35.780 --> 27:37.180
他运行重新运行这个函数

27:37.180 --> 27:38.480
这个函数如果说不是对象的话

27:38.480 --> 27:39.380
不是对象他就返回了

27:39.380 --> 27:40.080
什么都没说

27:40.380 --> 27:41.380
如果他是对象的话

27:41.380 --> 27:42.480
是不是他也会被监听

27:42.780 --> 27:43.280
对不对

27:43.280 --> 27:44.880
云生了这个盖手返回的是不是

27:45.080 --> 27:46.280
被监听过后的

27:47.380 --> 27:47.880
对吧

27:48.180 --> 27:49.980
那么同样到底是谁说的时候

27:49.980 --> 27:51.680
比方你跟他负责为一个对象

27:52.880 --> 27:54.680
那么这个对象是不是也要被监听

27:55.080 --> 27:55.680
说这里

27:56.180 --> 27:56.880
奥布斯

27:58.780 --> 27:59.680
奥布斯五方

28:00.280 --> 28:00.780
对不对

28:00.980 --> 28:02.080
他也要被监听

28:02.480 --> 28:02.680
对吧

28:02.680 --> 28:03.780
我们自己加两行带嘛

28:03.780 --> 28:04.880
是不是就解决这个问题了

28:05.080 --> 28:05.280
好

28:05.280 --> 28:06.180
接下来我们再看一下

28:07.880 --> 28:08.480
State

28:08.680 --> 28:09.080
第二

28:09.980 --> 28:10.480
打开

28:10.480 --> 28:11.080
你看

28:11.580 --> 28:12.380
addr

28:13.580 --> 28:13.980
看没

28:14.280 --> 28:15.080
读取出来了

28:15.280 --> 28:15.980
然后展开

28:15.980 --> 28:17.880
你看这里边是不是也是属性访问题

28:18.680 --> 28:19.080
你看没有

28:19.080 --> 28:20.080
现在是可以输出了

28:20.080 --> 28:21.680
一读取他他就会输出这句话

28:21.780 --> 28:23.180
那么现在我们来看一下这个测试

28:23.180 --> 28:24.080
能不能通过了

28:25.480 --> 28:25.980
运行

28:26.080 --> 28:26.680
run code

28:28.080 --> 28:28.580
啊你看

28:29.180 --> 28:30.180
这两句话输出出来了

28:30.480 --> 28:30.880
因此呢

28:30.880 --> 28:32.380
我们目前的就得到这么一个

28:32.480 --> 28:33.380
非常有用的函数

28:33.380 --> 28:34.080
叫Observe

28:34.280 --> 28:35.080
这个函数写法

28:35.080 --> 28:35.780
其实极其简单

28:35.780 --> 28:37.080
但是真实的vuel

28:37.080 --> 28:38.680
里边还要考虑很多很多的问题啊

28:38.680 --> 28:40.380
我们这里只讲他的最核心的

28:40.680 --> 28:41.780
理念和思路

28:41.880 --> 28:42.980
他实现其实很简单

28:43.280 --> 28:45.280
便利给我的所有属性

28:45.380 --> 28:45.780
然后呢

28:45.780 --> 28:47.480
我一个个把它全部重新经济

28:47.880 --> 28:49.880
啊然后每一个属性的读取

28:49.980 --> 28:51.780
和设置都能够被减薪到

28:51.780 --> 28:52.680
这一块没问题吧

28:57.220 --> 28:57.820
没问题吧

29:00.760 --> 29:01.360
没问题吧

29:01.760 --> 29:03.460
一问题没没问题QQE啊

29:09.600 --> 29:10.400
有同学

29:11.400 --> 29:13.100
直接直接阵亡了吗

29:14.600 --> 29:15.000
我说了

29:15.000 --> 29:15.800
今天晚上的东西啊

29:15.800 --> 29:17.900
需要有一点代码量啊

29:17.900 --> 29:19.500
你没有代码量的话

29:20.900 --> 29:21.900
你看这个东西

29:22.600 --> 29:23.600
肯定是很恼火的

29:23.900 --> 29:25.500
你平时就没有怎么去练习

29:26.300 --> 29:27.400
每行代码都能看懂

29:27.400 --> 29:28.200
也能懂他的意思

29:28.200 --> 29:29.100
连线也不知道

29:29.600 --> 29:31.100
啊这一块完了

29:31.200 --> 29:32.700
但是呢事情还没有结束

29:33.500 --> 29:35.200
接下来我们还要看另外一个问题

29:36.800 --> 29:37.800
因为我们最终要达到一个

29:37.800 --> 29:39.000
非常非常神奇

29:39.700 --> 29:41.200
非常非常感人的现象

29:41.800 --> 29:43.300
第二个问题叫做收集依赖

29:43.300 --> 29:44.300
这一块比较麻烦

29:45.600 --> 29:46.500
我直接给他们

29:46.600 --> 29:47.600
给大家看一个练习

29:47.600 --> 29:48.600
我们要练习要做啥

29:49.600 --> 29:52.800
我们练习需要实现一个构造函数

29:53.300 --> 29:54.700
这个构造函数里边

29:55.000 --> 29:56.900
有两个圆形方法

29:56.900 --> 29:58.000
也就是实力方法

29:58.100 --> 29:59.000
一个Depend

29:59.000 --> 29:59.900
一个楼梯犯

30:00.300 --> 30:01.540
你现在不用管这个世界

30:01.540 --> 30:02.400
我们干嘛的

30:02.400 --> 30:04.200
我先写到这我以后给你解释

30:04.300 --> 30:06.300
我现在还需要一个函数叫做out to run

30:06.300 --> 30:07.000
out to什么意思

30:07.000 --> 30:08.500
自动的run运行

30:08.900 --> 30:10.900
他接收一个参数叫做函数

30:12.200 --> 30:13.700
接收一个函数作为参数

30:14.500 --> 30:15.300
好接下来

30:15.300 --> 30:16.400
下面是我们的测试代码

30:16.500 --> 30:18.500
你看我们要实现一个什么样的效果

30:18.500 --> 30:19.900
比方这就是一道电视题

30:19.900 --> 30:21.000
就问你怎么去实现

30:22.500 --> 30:23.900
现在要实现个神奇的效果

30:24.600 --> 30:26.000
我创建这么一个

30:27.800 --> 30:28.300
Dep

30:28.800 --> 30:30.300
Dep构造函数

30:31.400 --> 30:31.800
然后呢

30:31.800 --> 30:33.300
调用这个out to run方法

30:33.300 --> 30:34.600
传一个函数进去

30:35.700 --> 30:36.700
我在函数里边呢

30:36.700 --> 30:38.300
用了一个Dep Depend

30:38.500 --> 30:39.100
什么意思

30:39.100 --> 30:40.300
表示嫉妒依赖

30:40.700 --> 30:41.300
什么意思啊

30:41.300 --> 30:41.900
就是说

30:42.900 --> 30:45.300
我在这个函数的运行过程中

30:45.400 --> 30:47.000
只要运行到了这句话

30:49.680 --> 30:50.880
我就表示

30:51.080 --> 30:52.880
我目前运行的代码

30:54.580 --> 30:56.380
是被这个函数依赖的

30:57.580 --> 30:58.880
好好理一下这句话

31:00.080 --> 31:02.080
比方说我再给大家举个例子啊

31:02.580 --> 31:03.180
嗯

31:03.480 --> 31:04.280
我们有这么一个

31:04.280 --> 31:05.680
我们把它叫做毁掉函数吗

31:06.080 --> 31:07.380
我们在毁掉函数要运行

31:07.380 --> 31:07.880
对不对

31:07.980 --> 31:09.480
毁掉函数要运行

31:09.780 --> 31:11.280
它在运行的过程中

31:12.680 --> 31:14.180
它调用了A方法

31:14.480 --> 31:15.880
又调用了B方法

31:16.280 --> 31:17.780
又调用了C方法

31:17.780 --> 31:18.780
调用了一大堆方法

31:20.280 --> 31:21.580
比方A调用A

31:21.980 --> 31:23.080
A里边又调用B

31:23.080 --> 31:24.280
B里边又调用C

31:24.780 --> 31:26.580
然后C里边有一句代码

31:26.580 --> 31:27.580
它是这样的写的

31:27.780 --> 31:29.280
Dep Depend

31:30.080 --> 31:31.880
你首先要知道我现在要干吧

31:31.880 --> 31:33.480
不然的话你连目标都不知道

31:33.580 --> 31:34.880
你肯定不知道怎么去写

31:36.480 --> 31:38.880
C里边有一句代码叫Dep Depend

31:40.080 --> 31:41.580
只要这个代码一运行

31:42.480 --> 31:43.280
我就知道了

31:44.280 --> 31:47.180
这个毁掉函数它依赖C

31:49.700 --> 31:50.200
对吧

31:50.200 --> 31:51.200
毁掉函数依赖A

31:51.200 --> 31:51.900
A依赖B

31:51.900 --> 31:52.500
B依赖C

31:52.500 --> 31:54.000
它有很多间接依赖关系

31:54.800 --> 31:55.400
但是呢

31:55.400 --> 31:56.800
只要在C里边一调用这个

31:56.800 --> 31:58.100
那么就表示毁掉函数

31:58.100 --> 31:59.100
依赖这个东西

32:01.000 --> 32:02.400
只要以将来

32:02.400 --> 32:04.600
我调用同一个对象的楼梯范

32:04.700 --> 32:05.600
一调用它

32:06.400 --> 32:07.500
这个毁掉函数

32:07.500 --> 32:08.900
就会重新运行

32:09.600 --> 32:10.600
所以我们回到这里

32:10.600 --> 32:11.500
要看这个代码

32:11.500 --> 32:12.400
再看一下

32:14.370 --> 32:16.270
调用这个Output Run第一次调用

32:16.870 --> 32:17.970
调用这个Depend

32:18.270 --> 32:19.270
表示有依赖了

32:19.470 --> 32:20.770
然后这里输出RUN1

32:21.670 --> 32:23.270
那么这个函数一运

32:23.670 --> 32:24.670
这个函数一执行完

32:24.670 --> 32:25.970
它就会输出RUN1

32:26.470 --> 32:28.770
然后我们又调用一次RUN Output Run

32:28.870 --> 32:30.370
它又用了一次Depend

32:30.370 --> 32:31.570
这里输出RUN2

32:31.570 --> 32:33.070
于是这里就输出RUN2

32:34.570 --> 32:36.270
接下来我们调用这个Dep的楼梯范

32:36.270 --> 32:36.970
通知

32:37.070 --> 32:38.270
发出一个通知

32:39.170 --> 32:40.670
只要这个方法一调用

32:40.770 --> 32:42.770
这两个毁掉函数都会执行

32:43.170 --> 32:44.870
它就会输出RUN1 RUN2

32:46.170 --> 32:47.270
那么再举个例子

32:47.270 --> 32:48.670
比方说这里还有一个RUN3

32:51.820 --> 32:52.720
这里输出RUN3

32:52.720 --> 32:54.320
但是我这一次没有记录依赖

32:54.620 --> 32:55.920
没有记录一个依赖的话

32:55.920 --> 32:57.720
那么这个我到时候通知的时候

32:57.720 --> 32:59.320
这个毁掉函数就不会执行

33:01.020 --> 33:01.720
好好看一下

33:01.820 --> 33:04.120
首先大家能不能理解我的意思

33:04.920 --> 33:06.220
我们先不说怎么去实现

33:06.220 --> 33:07.420
能不能理解我的意思

33:09.910 --> 33:10.810
能理解是吧

33:14.190 --> 33:14.990
加油啊同学们

33:14.990 --> 33:16.390
原码背景肯定是不容易的

33:16.490 --> 33:17.390
绝对是不容易的

33:19.850 --> 33:21.350
好那么现在呢

33:21.750 --> 33:23.450
就是怎么去实现的问题了

33:25.050 --> 33:26.450
我们要实现的最核心的东西

33:26.450 --> 33:27.450
就是个OUTRUN对吧

33:27.450 --> 33:28.750
首先是个OUTRUN的问题

33:29.650 --> 33:30.950
我怎么去实现它呢

33:32.550 --> 33:33.550
我从这个

33:34.350 --> 33:35.750
测试的结果里边

33:35.950 --> 33:36.750
这里要输出

33:36.850 --> 33:38.250
输出RUN3

33:38.750 --> 33:40.350
我从那个测试的结果里边呢

33:40.350 --> 33:42.250
可以非常明确的知道

33:43.250 --> 33:44.850
我至少有一件事需要做

33:44.850 --> 33:47.050
就是一给我传了一个函数进来

33:47.150 --> 33:48.350
对了一看传了一个函数

33:48.350 --> 33:49.350
传了一个函数进来

33:49.750 --> 33:50.650
我至少有一件事要做

33:50.650 --> 33:51.650
就是调用这个函数

33:52.750 --> 33:53.450
我其他啥子不管

33:53.450 --> 33:54.850
我都要调用一下这个函数

33:55.750 --> 33:57.150
好那么这个东西就很简单了

33:57.150 --> 33:58.350
你看一下我们现在运行一下

33:58.750 --> 34:00.150
说输出RUN1 RUN2 RUN3

34:00.150 --> 34:01.550
这个东西是很简单的对不对

34:02.550 --> 34:03.650
那么问题是

34:05.350 --> 34:07.650
我现在只要一调用这个玩意儿

34:09.150 --> 34:11.450
它就会把这个函数记录为依赖

34:13.520 --> 34:16.220
将来一调用上面这个NOTIFI

34:16.520 --> 34:18.620
它就会把这个函数重新运行一遍

34:18.920 --> 34:19.920
这个是很神奇的

34:19.920 --> 34:20.720
非常神奇的

34:21.720 --> 34:23.020
那具体怎么做呢

34:23.020 --> 34:24.520
我觉得要看一张图啊

34:24.820 --> 34:26.520
刚才我们看到数据响应是

34:26.520 --> 34:29.820
就是便利属性一个Object的敌犯property对吧

34:29.820 --> 34:31.320
那么我们看一下依赖收集

34:31.720 --> 34:33.920
这一块呆马倒是不督

34:34.020 --> 34:36.120
但是需要大家好好理解一下

34:36.420 --> 34:38.620
首先我们看到这里有个OUTRUN函数

34:40.320 --> 34:41.820
这个函数要做什么事呢

34:42.220 --> 34:44.920
我就做这么一件事

34:46.420 --> 34:47.220
第一件事

34:47.320 --> 34:48.820
我把这个函数记录一下

34:48.820 --> 34:50.120
我把它叫做顶层函数

34:50.120 --> 34:51.320
其实就是个回掉函数

34:51.420 --> 34:52.220
就这个函数

34:52.420 --> 34:53.820
我把这个函数记录一下

34:53.920 --> 34:54.720
记录到哪呢

34:54.720 --> 34:55.820
记录到一个变量里面

34:55.820 --> 34:57.720
咱许个名字叫InteoUpdate

34:59.020 --> 34:59.720
因为以后呢

34:59.720 --> 35:00.620
我们是提示这个东西

35:00.620 --> 35:02.020
就是跟更新有关系

35:02.320 --> 35:05.420
为什么属性一更新相应的界面就变了

35:06.920 --> 35:08.520
把这个函数记录一下啊

35:09.020 --> 35:10.220
先给它设文号

35:14.560 --> 35:21.260
当前正在收集依赖的函数

35:21.460 --> 35:22.660
其实就是这个玩意儿

35:23.060 --> 35:23.560
好

35:23.560 --> 35:25.360
我在运行这个函数之前

35:25.360 --> 35:27.360
我先把它复制为这个函数

35:28.360 --> 35:29.860
然后运行之后

35:29.860 --> 35:31.660
我再把这个东西设为辣

35:32.360 --> 35:33.260
大家想一想

35:33.260 --> 35:34.760
我只要这样一做

35:34.760 --> 35:36.560
这个函数的运行期间

35:36.560 --> 35:38.060
是不是这个玩意儿一定有值

35:39.260 --> 35:41.760
该函数的运行期间

35:43.260 --> 35:44.060
fn

35:44.060 --> 35:46.360
这个玩意儿一定有值

35:46.860 --> 35:47.760
这个没问题吧

35:48.460 --> 35:49.360
一定有值

35:52.780 --> 35:53.580
是不是这样子

35:53.580 --> 35:55.080
那么我这个函数里面写的是啥

35:55.080 --> 35:55.680
我不知道

35:55.680 --> 35:57.080
但是你在运行期间

35:57.080 --> 35:58.380
这个玩意儿是一定有值的

36:00.280 --> 36:01.880
哎那么就有意思了

36:02.680 --> 36:04.480
既然他的运行期间有值

36:04.480 --> 36:06.780
那么只要他在运行期间运行这句话

36:06.780 --> 36:08.080
我就会把它记录下来

36:08.180 --> 36:08.980
啥意思呢

36:08.980 --> 36:09.880
其实我这里就

36:10.680 --> 36:12.380
大家应该能够想到了啊

36:12.480 --> 36:12.980
其实这里呢

36:12.980 --> 36:14.080
我们就可以干嘛呢

36:14.080 --> 36:15.380
我就可以用一个数组

36:16.680 --> 36:17.580
来记录一下

36:19.180 --> 36:20.680
只要你雕用了

36:20.780 --> 36:22.380
你雕用了这个dipend

36:22.480 --> 36:23.780
就雕用这个函数

36:24.680 --> 36:26.780
我就把你这个玩意儿不是一定有值吗

36:29.680 --> 36:31.080
这个玩意儿不一定有值吗

36:31.080 --> 36:32.280
我就把你这个函数啊

36:32.280 --> 36:33.680
夹到这个数组里边去

36:35.380 --> 36:36.580
就夹到这个数组里边去

36:36.780 --> 36:37.780
把这个函数加进去

36:37.780 --> 36:38.880
这个函数就是fn

36:38.880 --> 36:39.380
对不对

36:39.480 --> 36:40.180
加进去

36:41.180 --> 36:41.580
好

36:41.880 --> 36:43.780
你如果说你下一次再掉了凹车状

36:43.780 --> 36:44.780
我又掉了你dipend的

36:44.780 --> 36:45.880
那么这是不一样的函数了

36:45.880 --> 36:46.280
对吧

36:46.480 --> 36:47.280
不一样的函数了

36:47.280 --> 36:47.980
不一样的函数呢

36:47.980 --> 36:48.880
我又把加进去

36:48.880 --> 36:49.280
是吧

36:50.080 --> 36:50.980
用编号来表示吧

36:50.980 --> 36:51.780
fnf2

36:52.180 --> 36:53.780
那么到时候以notify的时候

36:53.780 --> 36:54.680
雕用这个函数的时候

36:54.680 --> 36:56.080
是不是我只要循环数组

36:56.080 --> 36:56.880
一个函数一个函数

36:56.880 --> 36:58.080
重新调问一下就完事

36:59.280 --> 36:59.780
对不对

36:59.880 --> 37:00.980
是不是这样子就完事了

37:01.980 --> 37:02.180
好

37:02.180 --> 37:02.980
因此呢

37:03.080 --> 37:04.780
我们这里的代码其实就很好写了

37:04.780 --> 37:05.880
这够到函数怎么写

37:06.480 --> 37:07.280
够到函数里边

37:07.280 --> 37:08.780
我就加上一个属性

37:09.080 --> 37:09.780
叫做

37:10.580 --> 37:11.580
一个函数数组

37:11.780 --> 37:12.580
我们把它叫做其实

37:12.580 --> 37:13.780
这就是一个订阅模式啊

37:13.780 --> 37:14.880
发布订阅模式

37:15.480 --> 37:16.280
subscript

37:20.480 --> 37:21.280
带着去对面

37:24.560 --> 37:26.560
subscript

37:29.060 --> 37:29.760
订阅啊

37:31.160 --> 37:31.360
好

37:31.360 --> 37:33.460
那么我一开始要除此画一个空数组

37:33.960 --> 37:35.960
你调用这个depend函数的时候

37:35.960 --> 37:36.660
我干嘛呢

37:37.460 --> 37:38.160
我干嘛呢

37:38.160 --> 37:39.760
我就往那个数组里边加一下

37:39.960 --> 37:40.360
但是呢

37:40.360 --> 37:41.660
有可能会发生这种现象啊

37:41.660 --> 37:42.960
我这里调了两次

37:43.860 --> 37:46.160
那我是不是要记住两个相同的函数进去啊

37:46.960 --> 37:48.360
那到时候运行书的同一个函数

37:48.360 --> 37:49.460
出发了两次

37:50.660 --> 37:51.760
这是不行的啊

37:51.760 --> 37:52.260
因此呢

37:52.260 --> 37:53.560
为了避免重复

37:53.560 --> 37:56.360
我这里会用一个es6以后

37:56.360 --> 37:57.860
es6要学习的叫set

37:58.460 --> 38:00.360
c成你可以想象成为一个什么的

38:00.860 --> 38:01.460
一个

38:02.060 --> 38:03.960
类呃元素

38:03.960 --> 38:06.160
不可重复的数

38:06.360 --> 38:07.460
你可以这样的想象啊

38:07.960 --> 38:09.560
你可以把认为就是一个数组

38:09.560 --> 38:11.360
但是数组里边的东西是不能重复的

38:12.760 --> 38:13.460
原来的意思吧

38:13.560 --> 38:13.760
好

38:13.760 --> 38:14.760
那么我们这里呢

38:14.760 --> 38:16.360
如果说数组里边也可以判断啊

38:16.360 --> 38:17.260
判断它存不存在

38:17.260 --> 38:17.860
不存在的话

38:17.860 --> 38:18.660
往家加一个

38:18.860 --> 38:19.360
对不对

38:19.560 --> 38:19.760
好

38:19.760 --> 38:20.960
当调用这个depend的时候

38:20.960 --> 38:22.160
我们首先判断一下

38:22.360 --> 38:23.260
为了严格

38:23.360 --> 38:24.360
为了判断一下

38:24.360 --> 38:25.360
这东西存不存在

38:26.260 --> 38:27.560
如果说存在的话

38:28.260 --> 38:28.960
将其

38:29.660 --> 38:32.660
将其记录到依赖数组

38:35.260 --> 38:36.760
用于记录依赖

38:38.260 --> 38:40.660
我们就把这个this subscript

38:42.060 --> 38:43.060
set里边啊

38:43.060 --> 38:44.560
set里边有个方法叫add

38:44.560 --> 38:45.660
往里边加一项啊

38:45.660 --> 38:46.660
加一项就完事了

38:47.160 --> 38:47.960
加什么哪一项呢

38:47.960 --> 38:48.660
就加这个

38:49.260 --> 38:49.860
再加一项

38:49.860 --> 38:50.860
那么这个set啊

38:50.860 --> 38:51.460
我再说一下

38:51.460 --> 38:53.360
就是一个你可以把想象成就是一个数组

38:53.360 --> 38:54.760
它不能重复里边东西

38:56.060 --> 38:56.360
好

38:56.360 --> 38:57.260
加一项就完事了

38:57.860 --> 38:59.260
那么楼梯发又干嘛呢

38:59.260 --> 39:00.960
楼梯发起来要做的事情很简单

39:01.160 --> 39:02.260
就是把这个数组拿出来

39:02.260 --> 39:03.060
循环它

39:03.360 --> 39:04.460
执行就完事了

39:04.660 --> 39:04.860
对吧

39:04.860 --> 39:05.860
那怎么来做

39:06.160 --> 39:08.060
还是用刚才的for一起循环

39:08.460 --> 39:09.860
所以把每一个函数拿到

39:10.060 --> 39:11.060
拿到它的每一个函数

39:11.060 --> 39:12.660
这里边是不是记录了一个月的函数

39:12.760 --> 39:13.660
拿到它每一个函数

39:13.660 --> 39:14.960
然后调用它就完事了

39:17.340 --> 39:18.240
调用它就完事了

39:18.540 --> 39:18.940
看没

39:20.140 --> 39:20.840
那楼梯发

39:21.940 --> 39:22.340
好

39:22.540 --> 39:23.540
看一下行不行呢

39:23.640 --> 39:24.840
我们点击右键

39:24.840 --> 39:25.440
装扣的

39:26.240 --> 39:27.140
看一下是不是可以了

39:29.180 --> 39:30.080
后边输出了

39:30.080 --> 39:31.080
装一装二

39:31.580 --> 39:33.180
我们又可以在浏览器里面再看一下

39:33.480 --> 39:34.180
pragties

39:35.480 --> 39:37.080
23.js

39:39.250 --> 39:39.650
来吧

39:39.650 --> 39:40.750
这是2

39:41.150 --> 39:42.350
2.atme

39:43.950 --> 39:46.150
我这直接直接用匹配员数了

39:46.950 --> 39:49.250
找到这个pragties 2.js

39:49.650 --> 39:50.550
然后运行看一下

39:53.750 --> 39:54.550
你看目前

39:54.550 --> 39:55.850
然后我们再再同时一下

39:56.150 --> 39:56.550
deb

39:56.750 --> 39:57.750
点楼梯发

39:58.750 --> 39:59.950
是不是又输出装一装二

40:00.050 --> 40:00.750
一楼梯发

40:00.750 --> 40:01.950
所以可以运行这个函数了

40:02.950 --> 40:03.750
这样就完成了

40:03.850 --> 40:05.250
那么我们也可以看一下这个deb

40:05.250 --> 40:06.150
deb里边的值

40:06.250 --> 40:07.050
deb里边的值

40:07.050 --> 40:08.350
它不是有个订阅器

40:08.350 --> 40:08.750
对吧

40:08.950 --> 40:09.350
是一个set

40:09.350 --> 40:10.750
你看里边是不是有两个

40:10.750 --> 40:11.550
两个函数

40:12.250 --> 40:14.050
是不是把两个函数记录到数组里面去了

40:14.750 --> 40:15.050
对吧

40:15.050 --> 40:16.450
这就是依赖收集的

40:16.550 --> 40:18.450
那么这个依赖收集有什么用的

40:18.450 --> 40:20.650
马上就让大家看到什么器权先前了

40:20.750 --> 40:22.450
他为什么要去设置这个依赖收集

40:22.550 --> 40:24.050
其实你可以看vue2的原码

40:24.150 --> 40:24.750
vue2的原码

40:24.750 --> 40:25.450
你不要找一下

40:25.450 --> 40:26.350
比方说方可信

40:26.950 --> 40:27.450
deb

40:27.850 --> 40:29.350
你看是不是有这么一个deb函数

40:29.350 --> 40:30.650
不过它里面的实现的

40:30.950 --> 40:32.150
有些地方跟我们不一样

40:32.150 --> 40:34.150
但是因为它里面要考虑更多的东西

40:35.250 --> 40:36.950
然后也可以看到那个

40:37.750 --> 40:38.250
deb

40:38.250 --> 40:38.550
对不对

40:38.550 --> 40:39.150
楼梯范

40:40.850 --> 40:41.050
好

40:41.050 --> 40:41.850
咱们回到这

40:44.160 --> 40:45.260
那么这个东西就实现了

40:45.260 --> 40:46.160
这一块也没问题

40:49.060 --> 40:50.560
这为什么就不是计阅模式了

40:51.560 --> 40:52.460
一个订阅器的

40:52.460 --> 40:54.760
往订阅器里边不断去添加订阅

40:55.060 --> 40:55.560
对吧

40:55.660 --> 40:56.960
然后当我们通知的时候

40:56.960 --> 40:58.260
就循环这个订阅器

40:58.460 --> 40:59.060
然后呢

40:59.460 --> 41:00.360
输出一碗小

41:02.160 --> 41:02.960
运行就行了

41:06.020 --> 41:06.320
好

41:06.320 --> 41:07.320
那么现在呢

41:07.320 --> 41:08.720
我们把这个东西搞定了

41:09.320 --> 41:11.520
现在我们再到最后一个问题

41:12.520 --> 41:14.020
就是把两个合起来了

41:14.520 --> 41:16.420
我们要完成一个什么事了

41:17.420 --> 41:18.420
下面一个测试蛋了

41:21.830 --> 41:22.830
有一个状态

41:23.030 --> 41:24.030
我的数据啊

41:24.430 --> 41:25.830
它有很多属性

41:26.630 --> 41:27.830
然后我们去观察它

41:29.230 --> 41:30.630
下边有一个函数

41:31.030 --> 41:32.330
这个函数里边呢

41:32.430 --> 41:33.930
它用到了这些属性

41:34.430 --> 41:34.830
看没

41:34.830 --> 41:36.030
是不是用到了这些属性

41:38.190 --> 41:38.790
然后接下来

41:38.790 --> 41:39.890
我们要做这件事情

41:40.390 --> 41:42.590
当一个属性改变的时候

41:43.190 --> 41:44.790
这个函数就会自动运行

41:46.190 --> 41:48.190
当一个属性改变的时候

41:48.190 --> 41:50.190
这个函数就会自动运行

41:50.690 --> 41:52.590
当一个属性改变的时候

41:52.590 --> 41:53.990
这个函数就会自动运行

41:54.890 --> 41:55.590
但是

41:55.990 --> 41:58.990
当跟这个函数无关的属性改变的时候

41:58.990 --> 42:00.390
比方说我给A级复制

42:00.390 --> 42:02.090
这个函数里边有没有用到A级

42:02.190 --> 42:03.190
并没有用到A级

42:03.190 --> 42:03.690
对吧

42:03.690 --> 42:04.690
它没有用到A级

42:04.890 --> 42:05.890
那么这个时候

42:05.890 --> 42:07.090
什么都不会发生

42:07.090 --> 42:08.190
我们要完成这件事

42:09.090 --> 42:10.590
这是不是要既要观察

42:11.190 --> 42:13.390
要监控这个对象的属性变化

42:13.390 --> 42:15.590
同时又要收集积难

42:15.790 --> 42:16.590
就是这个函数里边

42:16.590 --> 42:17.890
到底用到了哪些属性

42:17.890 --> 42:18.790
而且你收集

42:18.790 --> 42:19.290
对吧

42:19.890 --> 42:21.390
你们以后学到了一个什么

42:22.490 --> 42:24.790
5u里边的什么computer的

42:24.790 --> 42:25.190
对不对

42:25.390 --> 42:26.190
计算属性

42:26.190 --> 42:27.590
它就是用这种方式实现的

42:27.790 --> 42:28.890
表面是个实际问题

42:28.890 --> 42:30.290
计算属性到底是怎么实现的

42:30.290 --> 42:31.390
它怎么来收集积难

42:31.490 --> 42:32.390
它就是这样收集的

42:35.190 --> 42:35.490
好

42:35.490 --> 42:36.190
大家看一下

42:41.140 --> 42:42.240
有没有什么好的想法

42:44.060 --> 42:45.060
其实到这呢

42:45.060 --> 42:46.560
如果说你前边都听懂了的话

42:46.560 --> 42:47.060
到这呢

42:47.060 --> 42:48.060
其实已经不来了

42:51.660 --> 42:52.560
因为什么想法呢

42:54.950 --> 42:55.550
因为

42:56.150 --> 42:57.150
你会发现

42:57.750 --> 42:59.550
这个对象里边的所有属性

42:59.550 --> 43:01.150
会不会被被被我们改掉

43:01.150 --> 43:01.550
对不对

43:01.550 --> 43:02.150
改成

43:02.450 --> 43:04.050
每个属性都改成两个函数

43:04.050 --> 43:04.650
一个get

43:04.650 --> 43:05.150
一个

43:05.150 --> 43:05.750
一个

43:06.050 --> 43:06.250
你看

43:06.250 --> 43:07.050
刚才我们这里实现

43:07.050 --> 43:08.450
你可以自己看一下这个图啊

43:08.650 --> 43:09.350
收集积难

43:09.350 --> 43:10.350
dipend的时候

43:10.750 --> 43:11.550
就把这个夹招

43:11.550 --> 43:12.150
都交到一个数组

43:12.150 --> 43:12.550
里边去

43:12.550 --> 43:13.150
楼梯看的时候

43:13.150 --> 43:14.350
就循环这个数组

43:14.350 --> 43:15.150
一次自行

43:15.250 --> 43:15.850
其实这个东西

43:15.850 --> 43:16.750
你看看图

43:16.750 --> 43:17.750
还不如看我们代码

43:19.150 --> 43:19.650
那么

43:19.650 --> 43:20.950
现在我们要做的事情无非就是

43:20.950 --> 43:22.150
对每一个属性的get

43:22.150 --> 43:23.150
sets进行处理

43:24.550 --> 43:25.650
你get的时候

43:25.850 --> 43:27.450
当你读这个属性的时候

43:27.850 --> 43:29.150
就表示有依赖

43:29.450 --> 43:30.550
对这个属性有依赖

43:30.550 --> 43:31.050
对不对

43:31.050 --> 43:32.050
我们就记录一下

43:32.750 --> 43:33.350
用什么记录

43:33.350 --> 43:34.150
就用这个记录

43:36.850 --> 43:37.950
使用这个东西记录

43:39.050 --> 43:40.850
当你给的属性负值的时候

43:40.850 --> 43:42.050
我们就发出通知

43:42.150 --> 43:44.150
凡是记录到我这个属性的东西

43:44.150 --> 43:44.650
全部

43:45.050 --> 43:45.750
运行一遍

43:46.050 --> 43:47.250
用到我这个属性的依赖

43:47.250 --> 43:48.150
全部运行一遍

43:49.150 --> 43:49.850
那么好了

43:50.150 --> 43:51.350
那这个问题就解决了

43:52.350 --> 43:53.450
我把这个代码

43:54.050 --> 43:54.650
复制过来

44:00.810 --> 44:01.310
你看

44:02.410 --> 44:03.210
这个代码复制过来

44:03.210 --> 44:04.010
一招个几个

44:04.610 --> 44:05.310
下点代码

44:05.510 --> 44:06.010
那么这里呢

44:06.010 --> 44:07.010
我不是输出了

44:07.010 --> 44:07.810
我干嘛呢

44:08.310 --> 44:09.410
我收集依赖

44:09.410 --> 44:10.010
我在这里呢

44:10.010 --> 44:10.810
定于一个

44:11.010 --> 44:11.510
dent

44:11.610 --> 44:12.410
u一个dent

44:15.220 --> 44:15.620
好

44:15.720 --> 44:16.420
然后这里边

44:16.420 --> 44:17.820
是不是费出的时候

44:17.820 --> 44:18.820
收集依赖

44:20.320 --> 44:21.820
我用大白花给他解释一下

44:22.420 --> 44:23.420
看一下

44:23.720 --> 44:25.020
是哪个

44:26.020 --> 44:26.820
函数

44:27.420 --> 44:28.620
用到了

44:28.920 --> 44:30.320
我这个属性

44:31.120 --> 44:31.320
对吧

44:31.320 --> 44:32.320
他准备来用我这个属性

44:32.320 --> 44:32.920
他用的话

44:32.920 --> 44:34.020
我就把他收集一下

44:34.820 --> 44:35.920
啊将函数

44:35.920 --> 44:37.420
那么这个方法的重用是什么

44:37.420 --> 44:38.820
就把这个函数记录一下了

44:39.620 --> 44:41.920
将该函数记录下

44:44.410 --> 44:44.710
好

44:44.710 --> 44:45.110
然后呢

44:45.110 --> 44:46.010
我sys的时候

44:46.010 --> 44:46.910
sys完了过后

44:46.910 --> 44:47.550
我用一下

44:47.550 --> 44:48.210
low defy

44:49.010 --> 44:49.710
low defy

44:50.710 --> 44:51.510
通知

44:52.010 --> 44:54.310
所有用到我

44:54.810 --> 44:55.510
这个

44:56.510 --> 44:58.610
属性的函数

44:59.710 --> 45:01.010
全部重新运行

45:01.710 --> 45:02.710
重新运行

45:04.810 --> 45:05.710
通知一下

45:06.510 --> 45:08.010
我只要做了这么两件事

45:08.010 --> 45:09.310
然后我这个代码不变

45:10.010 --> 45:11.010
下边代码不变

45:20.250 --> 45:21.250
这边付出过来

45:27.280 --> 45:28.280
我再重申一下

45:28.280 --> 45:29.480
今天晚上课程的

45:29.680 --> 45:31.380
你现在如何目前阶段听不懂

45:31.580 --> 45:32.580
没关系啊

45:32.680 --> 45:33.580
你可能要

45:33.780 --> 45:35.180
几个月之后或者是半年

45:35.180 --> 45:36.480
甚至一年过后啊

45:36.480 --> 45:37.180
再慢慢来听

45:37.180 --> 45:37.980
也没关系

45:38.980 --> 45:39.980
好

45:39.980 --> 45:41.380
那么个代码付出过来就完了

45:41.480 --> 45:42.080
就没了

45:42.580 --> 45:43.280
你看啊

45:43.680 --> 45:44.080
现在呢

45:44.080 --> 45:45.080
我们运行这个函数的时候

45:45.080 --> 45:45.880
他一开始就运行

45:45.880 --> 45:46.080
对吧

45:46.080 --> 45:46.880
一开始运行的时候

45:46.880 --> 45:47.980
是不是在收集一带

45:48.080 --> 45:48.580
他一带什么

45:48.580 --> 45:50.180
因为这个name的get社会运行

45:50.880 --> 45:52.280
这个玩意的get社会运行

45:52.380 --> 45:53.680
这个玩意的get社会运行

45:53.880 --> 45:54.180
对不对

45:54.180 --> 45:55.180
他的get社会运行

45:55.480 --> 45:56.380
那么get社运行

45:56.380 --> 45:57.580
是不是把一带收集进来了

45:58.280 --> 45:58.580
对不对

45:58.580 --> 45:59.580
一带就收集进来了

45:59.780 --> 46:00.280
那么到时候

46:00.280 --> 46:01.780
这个相应的属性一变

46:01.780 --> 46:03.380
那么这个属性里边记录了

46:03.380 --> 46:03.980
这个函数

46:03.980 --> 46:06.180
这个函数里边用到这个属性

46:06.180 --> 46:06.480
对吧

46:06.480 --> 46:07.280
那么他里边

46:07.280 --> 46:08.680
他的地铺会把它记录下来

46:08.980 --> 46:09.880
那么他只要一改

46:09.880 --> 46:11.480
他就会让这个函数重新运行

46:11.780 --> 46:12.580
好运行看一下

46:13.480 --> 46:13.980
你看

46:14.380 --> 46:15.780
一开始运行了一次

46:16.580 --> 46:17.280
然后呢

46:17.280 --> 46:18.280
我name

46:18.980 --> 46:19.580
name一变

46:19.580 --> 46:21.180
然后我之前还输出了对吧

46:22.180 --> 46:23.280
这个set

46:23.780 --> 46:24.280
去掉啊

46:24.280 --> 46:25.480
重新来运行

46:28.280 --> 46:29.480
一开始运行了一次

46:29.680 --> 46:31.480
然后我这里给name属性改了

46:31.480 --> 46:32.580
它是不是又运行次

46:32.680 --> 46:34.280
然后给这个promise属性改了

46:34.280 --> 46:35.180
又运行了一次

46:35.280 --> 46:36.880
给ct属性改了又运行次

46:36.880 --> 46:38.180
但是给a技属性更改

46:38.180 --> 46:39.180
他就没有运行了

46:39.180 --> 46:40.080
因为他没有异单

46:40.080 --> 46:41.580
对a技属性是没有异单的

46:42.380 --> 46:43.080
那么同样的道理

46:43.080 --> 46:44.780
比方说我们这里再来一个凹直状

46:45.780 --> 46:46.580
再来一个凹直状

46:46.580 --> 46:47.380
另外一个函数

46:50.730 --> 46:51.230
啊

46:52.430 --> 46:53.530
那么这个函数呢

46:53.930 --> 46:55.430
我就输出啊

46:55.430 --> 46:55.930
a级

46:58.190 --> 46:58.890
连零

47:01.090 --> 47:01.990
states a级

47:01.990 --> 47:03.990
那么这个函数是不是只依赖连零

47:04.390 --> 47:04.890
你看啊

47:04.890 --> 47:05.590
在运行

47:06.790 --> 47:07.990
一开始运行了一次

47:07.990 --> 47:08.490
对吧

47:08.790 --> 47:10.190
后边这些复职

47:10.290 --> 47:11.490
是不是他都没有运行

47:11.690 --> 47:12.590
他都没有运行

47:13.290 --> 47:14.990
然后只有他复职的时候

47:14.990 --> 47:15.790
他才运行

47:17.590 --> 47:18.190
看到没

47:18.790 --> 47:19.890
这说明了啥呀

47:20.490 --> 47:22.690
唯有他个响应式是怎么实现的

47:23.090 --> 47:24.390
他响应式里边

47:24.590 --> 47:26.190
他的模板渲染

47:26.190 --> 47:27.890
其实他就是套在这个函数里边的

47:28.390 --> 47:29.490
我的模板里边

47:29.490 --> 47:30.890
什么叫模板就这个东西啊

47:31.090 --> 47:32.990
这个东西里边用到了哪些数据

47:33.490 --> 47:35.290
我只有这些数据改了

47:35.290 --> 47:36.490
他才会重新渲染

47:36.890 --> 47:38.090
我其他数据改了

47:38.090 --> 47:38.990
他是不动的

47:39.090 --> 47:39.890
动的不轨动

47:40.390 --> 47:41.690
他就是这样子手机一耐

47:41.790 --> 47:44.390
然后了通过响应式完成一脸渲染的

47:44.490 --> 47:45.990
那么他的一个核心模块

47:45.990 --> 47:46.890
就是响应式

47:47.890 --> 47:50.090
这是5月2的响应式实现

47:50.090 --> 47:52.490
那么现在这个响应式有问题吗

47:52.490 --> 47:53.690
其实他还有一些问题

47:54.490 --> 47:55.590
其实还有问题的

47:55.690 --> 47:56.890
那么问题在哪呢

47:58.290 --> 48:00.890
问题在一个可能大家不太容易发现的地方

48:01.990 --> 48:03.690
比方说我给他举个例子啊

48:05.790 --> 48:06.990
比方说我这样子写

48:07.190 --> 48:08.490
把这个这个去掉

48:09.190 --> 48:10.290
我判断一下

48:11.090 --> 48:12.290
Stage的A

48:12.790 --> 48:15.490
除以二级的余数等于0

48:15.490 --> 48:16.090
对吧

48:16.390 --> 48:18.290
我就说年龄是偶数的时候

48:18.390 --> 48:21.290
年龄是或者是年龄是基数的时候

48:22.490 --> 48:26.600
年龄是基数的时候

48:28.400 --> 48:29.100
输出

48:30.200 --> 48:32.100
那么这个韩束是不是一旦年龄了

48:33.800 --> 48:35.800
看看年龄是基数的时候

48:35.800 --> 48:36.600
他就会输出

48:37.200 --> 48:39.000
那么第一次运行输不输出

48:39.300 --> 48:40.200
他不输出

48:40.500 --> 48:41.600
那么问题就出现了

48:41.800 --> 48:43.100
由于第一次运行

48:43.100 --> 48:44.500
他这个代码不会输出

48:45.600 --> 48:47.100
就导致了一个问题

48:47.300 --> 48:48.300
第一次运行

48:48.300 --> 48:50.700
是不是没有把这些属性的依赖收集到

48:52.200 --> 48:52.700
是不是

48:52.700 --> 48:53.700
是不是没有收集到

48:54.800 --> 48:56.000
那么问题就出现了

48:56.900 --> 48:59.100
第一次运行的时候没有收集到

48:59.600 --> 49:02.600
那么我们把一个代码稍微的调换一下位置

49:02.700 --> 49:03.600
你会发现

49:04.300 --> 49:05.200
这个事情呢

49:05.600 --> 49:06.800
就有点麻烦了

49:10.890 --> 49:11.690
好 你看啊

49:12.490 --> 49:13.090
然后

49:14.090 --> 49:15.090
是不是问题麻烦了

49:15.790 --> 49:17.890
我们这里只有第一次输出了新名

49:17.890 --> 49:19.390
毛利卡地址这个东西

49:19.790 --> 49:21.490
然后年龄重新复职了

49:21.590 --> 49:23.190
年龄重新复职了

49:23.990 --> 49:25.390
是不是得重新运行啊

49:26.790 --> 49:27.890
是不是得重新运行

49:27.890 --> 49:29.490
年龄重新复职了

49:29.890 --> 49:31.490
啊我们得重新运行吧

49:32.990 --> 49:34.190
但是他没了

49:35.590 --> 49:36.390
他没东西了

49:38.200 --> 49:39.400
为什么没东西了呢

49:39.400 --> 49:42.300
你看我们后边还给什么那么复职没反应的

49:42.900 --> 49:44.600
promise复职没反应的

49:44.700 --> 49:46.500
City复职没反应的

49:47.200 --> 49:47.800
为什么

49:52.900 --> 49:53.900
这是为什么呢

49:55.100 --> 49:57.600
因为给年我们目前第一次

49:57.900 --> 49:59.500
他只收集到了谁

49:59.800 --> 50:01.300
只收集到了这个年

50:02.100 --> 50:03.900
一开始一开始是技术啊

50:04.400 --> 50:05.000
哎不对啊

50:05.000 --> 50:06.700
我看一下啊这里哪里写的问题

50:07.000 --> 50:08.500
一开始我试一个技术啊

50:09.300 --> 50:11.200
我试一个技术不等于年

50:11.200 --> 50:13.600
除要的余数不等于年是一个技术

50:13.800 --> 50:15.200
那么一开始是收集到了的

50:15.700 --> 50:16.900
他为什么没有

50:17.600 --> 50:18.300
没有那个

50:19.100 --> 50:19.700
我看一下啊

50:19.700 --> 50:20.800
看一下哪里哪里有问题

50:20.800 --> 50:21.900
我看这里输出一个

50:23.100 --> 50:24.000
输出一个一

50:27.580 --> 50:28.680
哎输错了

50:29.080 --> 50:30.180
不对对不对

50:30.180 --> 50:31.380
哪里还写的还有问题

50:32.080 --> 50:33.280
我给Name数

50:33.880 --> 50:34.980
我先把下面去掉

50:35.880 --> 50:38.580
我给A级复职应该要重新重新运行的

50:39.980 --> 50:41.180
哦对了对了对了

50:41.180 --> 50:42.980
啊我后边

50:43.480 --> 50:44.680
我一开始是18

50:45.780 --> 50:46.780
一开始没有进判转

50:46.780 --> 50:48.080
我不重新改改一下啊

50:48.180 --> 50:49.480
一开始没有进判断啊

50:49.580 --> 50:51.380
我要改成一开始没有进判断

50:51.380 --> 50:52.580
然后后边进判断

50:53.580 --> 50:54.280
这样才对

50:55.980 --> 50:56.580
我看一下吧

50:59.920 --> 51:01.820
第一次是不是输出了这个没问题吧

51:01.820 --> 51:03.120
一开始要运行意思吗

51:03.120 --> 51:03.720
一开始

51:04.920 --> 51:06.120
哦一开始没有运行

51:06.120 --> 51:07.820
对吧一开始是他本身是

51:08.720 --> 51:10.420
1818是进不了判断的

51:11.020 --> 51:11.820
他不会运行

51:11.920 --> 51:13.520
然后A级变了过后

51:13.620 --> 51:15.820
这一句话变了过后变成19了

51:15.920 --> 51:17.220
A级是不是通知到他了

51:17.320 --> 51:19.120
因为他一开始收集到A级的一旦

51:19.320 --> 51:20.620
对吧他运行了一次

51:20.720 --> 51:22.320
但是麻烦的地方在于

51:22.320 --> 51:23.820
后边我这些属性改了

51:23.820 --> 51:25.720
按理说年龄还是19啊

51:25.720 --> 51:26.920
他还是能进判断啊

51:27.320 --> 51:28.320
他不会再运行的

51:28.420 --> 51:30.520
就是因为他这些属性的一旦没有收集到

51:30.920 --> 51:31.920
回到老问题了

51:32.020 --> 51:33.720
那么他为什么没有收集到呢

51:33.820 --> 51:34.620
是因为在这里

51:36.860 --> 51:37.760
我记录的是哪个

51:37.760 --> 51:39.360
他最终运行的是哪个函数

51:39.760 --> 51:40.960
最终运行的是这个

51:41.960 --> 51:42.860
这个玩意儿对吧

51:42.860 --> 51:43.560
是不是他

51:44.460 --> 51:45.560
运行的是这个函数

51:46.760 --> 51:49.060
那么重新运行他的时候

51:49.860 --> 51:52.160
重新运行这个函数的时候

51:53.260 --> 51:54.660
他就没有去

51:55.160 --> 51:56.260
做这件事了

51:56.660 --> 51:57.960
因为这个函数内部

51:57.960 --> 51:59.060
他是没有做这件事了

51:59.060 --> 51:59.460
对吧

51:59.460 --> 52:00.860
你在运行这个函数内部的时候

52:00.860 --> 52:02.660
他没有先把它复制为这个

52:02.660 --> 52:04.160
然后再复制为那对不对

52:04.160 --> 52:06.360
由于这个函数内部在运行的时候

52:06.360 --> 52:07.260
他没有去做

52:07.260 --> 52:08.560
他没有这两行代吗

52:09.360 --> 52:10.560
他没有这两行代吗

52:10.960 --> 52:13.260
就导致了他里边的依赖能收集吗

52:13.460 --> 52:14.760
因为我们知道依赖的收集

52:14.760 --> 52:16.060
是不是要依赖这两行代吗

52:17.460 --> 52:19.360
但是这个函数内部运行的时候

52:20.360 --> 52:21.360
他是没有运

52:21.360 --> 52:22.760
他是没有这两行代吗的

52:23.160 --> 52:24.760
就导致了后边的依赖收集

52:24.760 --> 52:25.560
就收集不到了

52:27.430 --> 52:28.330
他怎么办呢

52:28.330 --> 52:29.330
其实这里很简单

52:29.330 --> 52:31.230
我只要把这个函数再包装一下

52:31.530 --> 52:33.130
叫做update

52:33.130 --> 52:33.730
whiter

52:39.310 --> 52:40.310
我这边复制的时候

52:40.310 --> 52:41.110
复什么值呢

52:41.110 --> 52:41.910
我复这个值

52:41.910 --> 52:43.110
我把这个值复过去

52:43.910 --> 52:45.710
我让他之后运行的是哪个

52:45.710 --> 52:46.510
是这个函数

52:47.410 --> 52:48.410
我把它包装一下

52:48.410 --> 52:51.510
那么这样子每一次在运行函数的时候

52:51.510 --> 52:52.910
就在发出通知

52:52.910 --> 52:54.110
运行函数的时候

52:54.310 --> 52:56.710
都要保证他这三行代码全部要运行

52:58.110 --> 52:59.110
那么这三行代码运行的

52:59.110 --> 53:00.510
才能够完成一个完整的

53:00.510 --> 53:01.510
依赖收集过程

53:01.910 --> 53:02.310
对不对

53:02.310 --> 53:03.510
那么现在再看一下

53:04.810 --> 53:05.310
装扣

53:05.810 --> 53:06.510
是不是可以的

53:06.910 --> 53:07.310
对吧

53:08.210 --> 53:09.610
那么第一次没有收集到

53:09.610 --> 53:10.810
那么后边连另一遍

53:10.810 --> 53:11.910
变成几数过后呢

53:12.310 --> 53:13.210
他重新运行的时候

53:13.210 --> 53:14.610
这些依赖就收集到了

53:14.810 --> 53:16.410
那么现在收集依赖是不是动态的

53:16.910 --> 53:18.010
他们每一次收集的依赖

53:18.010 --> 53:19.010
都可能不一样

53:20.110 --> 53:20.910
依赖的意思吧

53:21.110 --> 53:21.710
嗯

53:25.200 --> 53:26.200
到目前为止

53:27.000 --> 53:28.300
听懂了同学QQ音了

53:28.700 --> 53:29.700
我看一下多少了

53:33.170 --> 53:34.470
大家不要有太过有

53:34.670 --> 53:36.670
心理压力不要太大啊

53:37.070 --> 53:38.270
因为这毕竟是

53:38.270 --> 53:39.570
要冲击大场高薪的

53:39.570 --> 53:41.170
那肯定是难度比较高一点

53:41.770 --> 53:42.470
而且呢

53:42.970 --> 53:45.170
可能对某些同学不是现阶段的

53:45.270 --> 53:45.770
学习任务

53:45.770 --> 53:47.070
那是将来你们要拥导的

53:47.370 --> 53:48.370
你早晚都要拥导的

53:48.470 --> 53:50.170
哪怕你现在不去冲击高薪

53:51.270 --> 53:52.170
你以后

53:53.370 --> 53:54.470
你不能永远这样吧

53:54.570 --> 53:56.870
有人说这咱们做开发到了三十多岁

53:57.170 --> 53:58.370
是不是就没有前途了

53:58.370 --> 53:59.070
就被淘汰了

53:59.070 --> 54:00.270
那是你自己被淘汰了

54:00.270 --> 54:02.070
跟你是不是三十多岁没关系

54:02.470 --> 54:04.070
你二十多岁出去的能力

54:04.170 --> 54:05.970
到了三十多岁还是以前的能力

54:06.270 --> 54:08.370
你还要跑去跟二十多岁的人去竞争

54:08.670 --> 54:09.970
那怎么可能竞争那么过呢

54:10.370 --> 54:11.870
你一定是跟同历人竞争

54:11.870 --> 54:13.670
那你看一下同历人三十多岁的

54:13.670 --> 54:14.370
做的好的

54:14.370 --> 54:15.470
他们是什么水平

54:15.670 --> 54:16.670
啊你是因为

54:16.770 --> 54:19.170
一个同学是出去过后呢是没有成长的

54:19.470 --> 54:20.770
你真人早晚得接触的

54:25.560 --> 54:26.560
是动态改变

54:26.560 --> 54:27.760
为什么还需要set

54:27.960 --> 54:29.760
哎这个这个问题问的好啊

54:29.760 --> 54:31.260
就马上要说到这个问题

54:32.060 --> 54:34.060
这个这里会有什么样的问题呢

54:35.060 --> 54:36.360
这里边会有什么问题呢

54:36.460 --> 54:38.760
因为在以前的这个define property里边

54:38.760 --> 54:40.160
有一个很严重的问题

54:40.360 --> 54:41.960
他是要注意开始去

54:42.460 --> 54:43.960
完成数据响应式的对吧

54:43.960 --> 54:45.260
我们在observe里边

54:45.860 --> 54:47.160
我们在observe里边

54:48.060 --> 54:52.060
大家就是便利这个对象的所有属性

54:53.360 --> 54:54.960
然后以此改动这些属性

54:55.060 --> 54:57.160
那万一以后我新增属性怎么办

54:59.500 --> 55:00.900
比方说啊我这几个意思

55:02.000 --> 55:03.500
我这里就做一件简单的事

55:05.200 --> 55:05.900
输出什么呢

55:06.200 --> 55:07.100
毛利卡的性别

55:10.220 --> 55:10.720
stats

55:11.720 --> 55:12.120
6

55:12.420 --> 55:13.320
把他的性别

55:15.400 --> 55:16.900
大家认为这个性别

55:17.200 --> 55:18.300
能不能产生依赖

55:20.000 --> 55:20.700
给他改成

55:20.700 --> 55:22.200
然后一开始安迪旦对不对

55:22.200 --> 55:23.100
把他改成一个女

55:23.300 --> 55:24.800
你觉得会不会产生依赖的

55:26.840 --> 55:27.540
有没有依赖

55:28.740 --> 55:29.640
我又给他改成男

55:30.440 --> 55:31.340
我又给他改成女

55:32.240 --> 55:34.040
看他有没有有没有重新输出吧

55:34.840 --> 55:35.340
没有

55:36.040 --> 55:38.940
是不是得不到得不到任何的依赖收集

55:38.940 --> 55:39.540
为什么呢

55:39.640 --> 55:42.340
因为这个属性在一开始这个对象是不存在的

55:43.040 --> 55:43.340
对不对

55:43.340 --> 55:44.540
是不是不存在这个属性

55:44.940 --> 55:45.840
不存在这个属性

55:45.840 --> 55:48.340
他在便利这个对象的时候是不是便利不到这个属性

55:48.640 --> 55:49.540
便利不到这个属性

55:49.540 --> 55:51.940
他就是无法对这个属性完成响应式

55:52.040 --> 55:53.940
他就无法完成这个get和set

55:54.640 --> 55:55.140
对不对

55:55.140 --> 55:56.440
是不是无法完成这个东西

55:56.740 --> 55:58.240
那么既然无法完成这个东西

55:58.240 --> 56:00.240
那你后边加的就是一个普通属性

56:00.640 --> 56:03.640
除非你再用8个get和set重新写一遍

56:03.940 --> 56:04.640
你看那意思吧

56:05.240 --> 56:07.640
说这个新的属性是收集不到的

56:08.240 --> 56:09.440
还有什么收集不到呢

56:09.540 --> 56:10.840
还有定内置收集不到

56:11.640 --> 56:12.640
比方说我这里呢

56:13.340 --> 56:14.240
用的是连领

56:16.440 --> 56:17.040
但是呢

56:17.240 --> 56:18.740
我这里把连领删掉了

56:18.840 --> 56:20.540
这是用语法去删的对吧

56:20.840 --> 56:22.940
这个玩意他用get和set收集得到吗

56:23.240 --> 56:24.440
get是独去属性

56:25.140 --> 56:26.340
set是负值属性

56:26.340 --> 56:27.540
那这个玩意是啥属性吗

56:27.840 --> 56:29.340
他既不是独去也不是负值

56:29.340 --> 56:30.040
他是删除

56:30.440 --> 56:30.940
不好意思

56:30.940 --> 56:32.040
这个里边没有删除

56:32.240 --> 56:33.340
没有对删除的处理

56:33.840 --> 56:35.340
所以以前的define property啊

56:35.340 --> 56:36.640
是有很多缺陷的

56:36.740 --> 56:37.840
他这个东西收集不到的

56:39.040 --> 56:39.540
看到没

56:39.740 --> 56:40.440
这些都是问题

56:40.440 --> 56:41.540
这就是为什么

56:41.940 --> 56:44.740
五又二里边可以出来什么set这个东西

56:44.740 --> 56:45.040
对吧

56:45.040 --> 56:46.340
当你调用一个函数

56:46.340 --> 56:47.740
不然的话没法收集了

56:48.040 --> 56:49.340
他没法收集这个依赖了

56:49.740 --> 56:51.240
没法进行想用式的

56:51.240 --> 56:52.740
他要这里提个函数

56:52.740 --> 56:53.940
让你去调用这个函数

56:53.940 --> 56:56.340
他的函数里边帮你去收集

56:56.640 --> 56:57.640
不然的话没办法

56:57.840 --> 56:59.640
还有什么还有一个什么定内置

56:59.640 --> 57:00.140
对吧

57:00.340 --> 57:01.940
是不是用来删除属性的

57:02.340 --> 57:04.440
这些都是他的无奈秩序

57:05.640 --> 57:06.440
那么接下来呢

57:06.440 --> 57:07.640
我们来看五又三

57:07.740 --> 57:09.340
五又三这个问题就彻底解决了

57:11.140 --> 57:11.640
为什么呢

57:11.640 --> 57:13.340
五又三为什么可以解决这个问题呢

57:13.340 --> 57:15.240
因为五又三根本就不便宜属性

57:15.240 --> 57:16.540
他根本就不便宜属性

57:17.340 --> 57:19.940
他是利用了es6的一个东西叫做

57:21.440 --> 57:22.040
proxy

57:22.740 --> 57:24.240
啊这是五又三的

57:24.340 --> 57:25.040
五又三里边啊

57:25.040 --> 57:25.640
顺便说一下

57:25.640 --> 57:28.740
五又三里边是把很多的核心模块全部给你提出来了

57:28.840 --> 57:30.540
比方说这个这个解释

57:31.040 --> 57:31.940
这个解释其实

57:32.340 --> 57:33.540
那种并不懂啊

57:34.140 --> 57:34.840
那种并不懂

57:35.340 --> 57:36.040
几半哈

57:36.540 --> 57:37.540
那几半和解释上吧

57:37.540 --> 57:38.740
其实那种很少的

57:38.840 --> 57:39.940
那么这个解释里边

57:39.940 --> 57:42.840
他其实就已经把那个

57:43.740 --> 57:45.340
呃只做了想念事

57:45.740 --> 57:48.140
他把很多的模块分开处处理了

57:48.140 --> 57:49.440
比方说我们这里再用一下

57:49.440 --> 57:50.440
用一下这个解释

57:50.540 --> 57:51.940
我们在这里写个页面吧

57:52.640 --> 57:53.640
呃开始

57:54.440 --> 57:55.940
看一下五又三的想念事

57:57.140 --> 57:58.540
我就不用这个

57:58.940 --> 58:01.440
直接直接用个type module

58:01.740 --> 58:01.940
对吧

58:01.940 --> 58:02.640
我们昨天去

58:02.640 --> 58:04.440
昨天应该是前天还是昨天去了的

58:04.440 --> 58:04.940
对不对

58:05.240 --> 58:05.440
好

58:05.440 --> 58:06.540
然后我们这里导入

58:06.840 --> 58:08.440
他是用es module导出的啊

58:09.340 --> 58:09.740
flaw

58:11.870 --> 58:13.170
叫斜槓reality

58:13.970 --> 58:16.270
好这里边他提供了一个函数啊叫reality

58:16.770 --> 58:17.370
reality

58:18.470 --> 58:20.170
还有一个函数叫做effect

58:21.370 --> 58:21.970
你看哈

58:21.970 --> 58:23.170
五又三是怎么做的

58:24.870 --> 58:28.470
他这里边就是把一个想念事系统单独提出去了啊

58:28.470 --> 58:29.370
给什么宣人啊

58:29.370 --> 58:30.170
给什么界面啊

58:30.170 --> 58:30.870
没有任何关系

58:30.870 --> 58:32.370
他就是纯粹数据想念的

58:32.570 --> 58:33.170
那么以后呢

58:33.170 --> 58:34.670
如果说你要单独来

58:34.670 --> 58:36.270
单独实现一个数据想念效果

58:36.270 --> 58:37.270
你可以就用他的

58:37.270 --> 58:38.070
就用五又的

58:38.070 --> 58:39.370
你可以不用五又其他东西

58:39.370 --> 58:40.170
就用他这个

58:40.670 --> 58:41.070
啊

58:41.070 --> 58:42.070
然后他一回对象哈

58:42.070 --> 58:42.770
对象他传进去

58:42.770 --> 58:44.070
比方说就在对象吧

58:45.670 --> 58:47.070
我们就就这个对象

58:48.470 --> 58:49.670
或者我随便写个吧

58:49.770 --> 58:49.970
啊

58:50.970 --> 58:51.770
等于molec

58:52.970 --> 58:53.370
啊

58:53.570 --> 58:55.470
然后他会返回一个新的对象

58:56.270 --> 58:57.170
一把接受一下

58:57.570 --> 58:59.670
那么这个新的对象属性变化的时候呢

58:59.670 --> 59:00.770
他会搜集到啊

59:00.770 --> 59:01.770
我们写个effect

59:02.270 --> 59:02.770
effect呢

59:02.770 --> 59:04.370
就相当于是我们之前那个out to wrong

59:04.770 --> 59:05.870
就相当于是out to wrong

59:05.970 --> 59:07.070
我们这里啊

59:07.070 --> 59:08.070
输出一下stats

59:08.970 --> 59:09.870
叫念啊

59:09.870 --> 59:11.070
前面就加上一句吧

59:13.270 --> 59:14.370
name is

59:15.370 --> 59:16.670
好来试一下啊

59:17.770 --> 59:18.470
我们这里呢

59:18.470 --> 59:18.970
sets

59:19.570 --> 59:20.270
interval

59:23.460 --> 59:24.860
每隔一段时间啊

59:24.860 --> 59:26.360
每隔一秒钟吧

59:27.360 --> 59:29.360
或者我们把它放到window里面吧

59:29.560 --> 59:30.260
也可以

59:30.760 --> 59:32.060
在浏览器里面测试

59:32.360 --> 59:33.060
window state

59:34.260 --> 59:35.760
因为这个地方你在浏览器里面

59:35.760 --> 59:36.460
发文不到的

59:36.460 --> 59:37.760
他没有污染权局变量

59:38.360 --> 59:39.560
我们把它放到window里面

59:40.260 --> 59:40.660
啊

59:41.160 --> 59:42.060
好看一下啊

59:42.060 --> 59:43.060
一开始输出了

59:43.060 --> 59:44.160
name is modica

59:46.200 --> 59:46.700
对不对

59:47.100 --> 59:47.900
运行了一次

59:48.700 --> 59:49.900
这个effect啊

59:49.900 --> 59:50.700
不要说副作用

59:50.700 --> 59:51.500
他就是

59:51.900 --> 59:53.600
可以理解我就是之前那个out to wrong

59:53.800 --> 59:55.500
然后我们把stats改一下

59:55.600 --> 59:56.900
name改一下改成

59:57.200 --> 59:57.800
modica

01:00:00.000 --> 01:00:00.600
modica

01:00:02.540 --> 01:00:02.940
是不是啊

01:00:02.940 --> 01:00:04.240
这个还是重新运行到一边

01:00:04.840 --> 01:00:05.340
对不对

01:00:06.740 --> 01:00:07.740
同样的效果对不对

01:00:08.040 --> 01:00:10.440
但是现在5u3不一样的地方在哪呢

01:00:11.040 --> 01:00:12.040
更加厉害

01:00:13.740 --> 01:00:15.040
以前没有这个属性

01:00:15.540 --> 01:00:17.040
看着啊以前没有这个属性

01:00:17.340 --> 01:00:18.440
a is undefended

01:00:18.540 --> 01:00:19.840
现在我给他加上这个属性

01:00:21.440 --> 01:00:21.940
是吧

01:00:22.540 --> 01:00:23.440
他照样能运行

01:00:23.440 --> 01:00:24.540
这个函数照样能出发

01:00:24.540 --> 01:00:25.740
我把属性打三除

01:00:28.000 --> 01:00:29.000
他照样能出发

01:00:29.500 --> 01:00:30.200
这是很神奇啊

01:00:30.200 --> 01:00:30.600
对吧

01:00:30.600 --> 01:00:31.200
那么5u3

01:00:31.200 --> 01:00:32.500
以前5u2办不到

01:00:32.500 --> 01:00:34.200
那么5u3为什么可以办刀呢

01:00:34.300 --> 01:00:36.600
就是5u3还不不需要你去搞什么sense的

01:00:37.000 --> 01:00:39.000
那地内扯选择不完全不用了

01:00:39.400 --> 01:00:40.900
那么他为什么能办刀呢

01:00:40.900 --> 01:00:41.800
是因为5u3立表

01:00:41.800 --> 01:00:44.100
他使用了另一种方式来完成的数据相应式

01:00:44.100 --> 01:00:44.900
叫proxy

01:00:44.900 --> 01:00:45.800
啊给他讲一讲啊

01:00:45.800 --> 01:00:47.100
这就是es6的姿势了

01:00:50.140 --> 01:00:50.640
proxy

01:00:51.040 --> 01:00:52.440
那么在es6里面啊

01:00:53.240 --> 01:00:54.240
这东西叫做代理

01:00:54.440 --> 01:00:56.440
啊我是专门拿了两节课来

01:00:56.440 --> 01:00:57.540
在后边讲es6的是

01:00:57.540 --> 01:00:58.640
专门拿了两节课来

01:00:59.040 --> 01:01:00.740
好像拿了一个章节还是两节课

01:01:00.940 --> 01:01:01.640
讲代理的

01:01:01.940 --> 01:01:03.140
我这个简单的说一下

01:01:03.140 --> 01:01:04.440
用最简单的方式来说一下

01:01:04.840 --> 01:01:06.340
他可以把一个

01:01:06.340 --> 01:01:07.840
他可以创建一个代理

01:01:07.940 --> 01:01:08.940
6一个proxy

01:01:09.440 --> 01:01:10.340
创建一个代理

01:01:11.040 --> 01:01:11.940
得到的得到的是什么呢

01:01:11.940 --> 01:01:13.240
得到的是一个代理对象

01:01:13.240 --> 01:01:14.540
那我就用一面

01:01:19.580 --> 01:01:20.480
6一个proxy

01:01:22.180 --> 01:01:23.480
得到的是一个代理对象

01:01:23.680 --> 01:01:25.180
代理对象你的第一个参数

01:01:25.180 --> 01:01:26.880
就是你代理的目标啊

01:01:26.880 --> 01:01:27.880
你代理的哪

01:01:28.580 --> 01:01:30.280
你要代理哪个对象什么要代理

01:01:30.580 --> 01:01:32.780
就是你愿意要访问原来的对象

01:01:32.780 --> 01:01:33.780
你看人老板

01:01:33.780 --> 01:01:35.080
对吧很多事情不知己

01:01:35.080 --> 01:01:36.380
不知己亲自去处理

01:01:36.980 --> 01:01:38.080
找自己的秘书去处理

01:01:38.080 --> 01:01:39.180
那么秘书就是代理

01:01:39.280 --> 01:01:41.780
对吧外线的人是跟他们秘书打交道

01:01:41.980 --> 01:01:43.180
不直接跟老板打交道

01:01:43.180 --> 01:01:44.580
是就这么就这么个意思

01:01:44.580 --> 01:01:45.680
那么这里是一样的

01:01:46.780 --> 01:01:48.680
真正的老板是谁是地的参数

01:01:48.880 --> 01:01:49.680
是一个对象

01:01:51.700 --> 01:01:53.600
老婆比方我就就一个空对象

01:01:53.800 --> 01:01:54.500
就一个空对象

01:01:54.500 --> 01:01:55.500
这是他真正的对象

01:01:56.300 --> 01:01:57.100
代理的对象

01:01:57.300 --> 01:01:58.700
然后呢第二个参数

01:01:59.900 --> 01:02:00.500
就是

01:02:01.600 --> 01:02:03.300
第二个参数是一个配置

01:02:04.400 --> 01:02:06.000
这个配置里面有很多东西啊

01:02:06.000 --> 01:02:07.600
其中就有一个get set

01:02:08.600 --> 01:02:11.200
就这么一个东西get set

01:02:11.500 --> 01:02:13.100
那么这两个get set set

01:02:13.100 --> 01:02:15.300
他里边跟之前的参数不一样

01:02:15.300 --> 01:02:18.200
get set表示独取属性的时候

01:02:18.500 --> 01:02:19.600
那么他有几个参数

01:02:19.600 --> 01:02:21.600
第一个参数原是对象

01:02:22.200 --> 01:02:24.400
第二个参数独取的是哪一个属性

01:02:24.400 --> 01:02:25.400
属性的名字

01:02:26.000 --> 01:02:26.600
传进来

01:02:28.700 --> 01:02:31.800
那么set set有三个参数原来的对象

01:02:32.500 --> 01:02:33.600
就是就是这个东西

01:02:33.760 --> 01:02:34.500
就是这个东西

01:02:35.200 --> 01:02:36.500
啊属性的名字

01:02:37.200 --> 01:02:38.100
属性的值

01:02:38.100 --> 01:02:39.600
他会给你传这么几个参数

01:02:40.300 --> 01:02:42.100
啊比方说我这里输出一下

01:02:42.400 --> 01:02:43.900
pocket p

01:02:44.100 --> 01:02:45.800
读属性的时候他就会运行这个

01:02:46.300 --> 01:02:47.300
设置属性的时候呢

01:02:47.300 --> 01:02:49.500
他就会运行这个pocket p

01:02:50.500 --> 01:02:50.900
对吧

01:02:51.800 --> 01:02:52.500
这是代理的对象

01:02:52.500 --> 01:02:53.400
那么他会返回什么呢

01:02:53.400 --> 01:02:54.400
返回一个新的对象

01:02:54.700 --> 01:02:55.900
这个新的对象就是代理

01:02:56.600 --> 01:02:57.600
好咱们来看一下吧

01:02:57.900 --> 01:02:58.400
印象

01:03:01.810 --> 01:03:02.310
啊

01:03:02.810 --> 01:03:04.310
呃这个set比方说我给他

01:03:04.310 --> 01:03:05.610
随便加一个属性啊

01:03:05.610 --> 01:03:06.310
他以前没有这个属性

01:03:06.310 --> 01:03:06.710
你看一下

01:03:06.710 --> 01:03:08.010
首先看一下这个set set

01:03:08.010 --> 01:03:08.910
他是一个proxy

01:03:09.110 --> 01:03:09.910
他长这个样子

01:03:10.410 --> 01:03:11.610
啥都看不到啊

01:03:12.110 --> 01:03:13.210
啊我们这里set

01:03:13.510 --> 01:03:14.510
我给他加一个属性

01:03:14.510 --> 01:03:14.810
哎

01:03:15.510 --> 01:03:16.510
你看是不是运行到对

01:03:16.710 --> 01:03:18.110
是不是运行到set函数

01:03:18.810 --> 01:03:20.410
输出了什么原字对象

01:03:21.510 --> 01:03:22.510
属性的名字

01:03:23.210 --> 01:03:23.910
属性的值

01:03:24.710 --> 01:03:25.110
pocket p

01:03:25.110 --> 01:03:27.210
新增属性也是可以监听到的

01:03:27.310 --> 01:03:28.610
为什么以前监听不到

01:03:28.610 --> 01:03:29.910
现在这个东西可以监听到了

01:03:29.910 --> 01:03:30.710
因为这个是

01:03:31.310 --> 01:03:32.210
native code

01:03:32.210 --> 01:03:32.910
怎么样native code

01:03:32.910 --> 01:03:33.610
你本地代码

01:03:33.610 --> 01:03:34.410
怎么样本地代码

01:03:35.310 --> 01:03:36.510
在浏览器执行引擎里边

01:03:36.510 --> 01:03:38.810
这叫里边是用C和CA加写的

01:03:39.610 --> 01:03:41.110
他可以调用底层的API

01:03:41.510 --> 01:03:42.310
但是用C也是

01:03:42.310 --> 01:03:44.510
是没法没办法调用底层的API的

01:03:45.110 --> 01:03:45.510
啊

01:03:45.510 --> 01:03:46.810
那么这里边还有很多区别啊

01:03:46.810 --> 01:03:48.110
我这里不移输了

01:03:48.910 --> 01:03:50.010
就这么个意思看来

01:03:50.610 --> 01:03:51.910
而如果说我要读他的属性

01:03:51.910 --> 01:03:52.510
读B

01:03:52.510 --> 01:03:53.310
读B这个属性

01:03:53.310 --> 01:03:54.110
他属性存不存在

01:03:54.110 --> 01:03:54.810
不存在

01:03:54.810 --> 01:03:55.210
你看

01:03:55.210 --> 01:03:56.710
这个还是会运行这些方法

01:03:57.110 --> 01:03:58.310
哪怕你读一个不存在的属性

01:03:58.310 --> 01:03:59.110
他都会运行

01:03:59.510 --> 01:04:00.210
没啥意思吧

01:04:00.410 --> 01:04:01.110
所以说proxy

01:04:01.110 --> 01:04:01.710
为什么能办到

01:04:01.710 --> 01:04:02.810
就就是这个原因

01:04:03.610 --> 01:04:03.710
好

01:04:03.710 --> 01:04:04.310
那么现在我们呢

01:04:04.310 --> 01:04:06.310
又来又来重新写三个练习

01:04:06.310 --> 01:04:08.110
把用5u3来实现一遍

01:04:08.510 --> 01:04:09.910
第一个练习同样的问题

01:04:10.810 --> 01:04:12.510
只是API稍微改了一下

01:04:12.510 --> 01:04:13.610
以前叫Observe

01:04:13.710 --> 01:04:14.310
现在叫什么呢

01:04:14.310 --> 01:04:15.210
叫Reactive

01:04:16.510 --> 01:04:18.710
以前他只是把这个对象属性便利

01:04:18.710 --> 01:04:19.210
对吧

01:04:19.510 --> 01:04:20.110
便利

01:04:20.210 --> 01:04:21.410
那么现在不便利

01:04:21.810 --> 01:04:22.910
根本就不便利

01:04:22.910 --> 01:04:24.110
直接返回一个代理

01:04:24.610 --> 01:04:26.710
说这个函数里边的写法就不一样了

01:04:27.010 --> 01:04:27.510
他怎么写

01:04:27.510 --> 01:04:28.510
直接返回代理

01:04:28.610 --> 01:04:29.210
proxy

01:04:30.210 --> 01:04:31.310
首先当然还是要判断一下

01:04:31.310 --> 01:04:32.310
他是不是对象啊

01:04:32.310 --> 01:04:34.310
我把之前的这个代码拿过来

01:04:37.720 --> 01:04:38.920
首先判断是不是对象

01:04:39.620 --> 01:04:40.020
好

01:04:40.020 --> 01:04:40.820
判断一下啊

01:04:40.920 --> 01:04:42.220
如果说不是对象的话

01:04:43.220 --> 01:04:44.220
你连对象都不是啊

01:04:44.220 --> 01:04:45.020
我现在不用

01:04:45.020 --> 01:04:46.620
我现在不去考虑数组那些东西啊

01:04:46.620 --> 01:04:47.920
数组还要单独来处理的

01:04:49.420 --> 01:04:49.920
嗯

01:04:49.920 --> 01:04:51.320
如果说不是对象的话

01:04:51.820 --> 01:04:52.420
我就给你

01:04:52.620 --> 01:04:53.120
你是啥

01:04:53.120 --> 01:04:53.820
我给你返回啥

01:04:53.820 --> 01:04:55.020
比方说你是个数字一

01:04:55.320 --> 01:04:56.620
你是个是字不需要三

01:04:56.820 --> 01:04:57.420
abc

01:04:57.420 --> 01:04:58.520
我就直接返回了

01:04:58.520 --> 01:04:59.520
然后我啥都不处理

01:04:59.520 --> 01:04:59.920
因为

01:05:00.720 --> 01:05:02.220
代理也只能代理对象啊

01:05:02.920 --> 01:05:03.120
好

01:05:03.120 --> 01:05:03.720
那么现在呢

01:05:03.720 --> 01:05:05.020
如果说你是一个对象的话

01:05:05.020 --> 01:05:06.420
我就给你返回一个代理

01:05:07.320 --> 01:05:07.720
对吧

01:05:07.720 --> 01:05:09.520
这个东西你后边用的全是代理

01:05:10.120 --> 01:05:11.120
那么代理谁呢

01:05:11.120 --> 01:05:12.220
代理就代理这个对象

01:05:12.420 --> 01:05:12.720
对吧

01:05:12.720 --> 01:05:13.520
代理的目标

01:05:13.520 --> 01:05:14.520
后边就是k字的

01:05:16.220 --> 01:05:16.720
get

01:05:17.720 --> 01:05:19.120
当交用get的时候

01:05:19.320 --> 01:05:20.020
一把你

01:05:20.320 --> 01:05:21.420
读到对象给我

01:05:21.720 --> 01:05:23.720
读读个对象的哪个属性给我

01:05:24.220 --> 01:05:24.720
对

01:05:24.720 --> 01:05:25.720
是不是把这个给我

01:05:26.220 --> 01:05:26.920
给我的话

01:05:26.920 --> 01:05:28.520
我这里是不是就可以得到

01:05:28.920 --> 01:05:29.520
哎

01:05:29.620 --> 01:05:30.720
输出一下啊

01:05:31.720 --> 01:05:32.320
get

01:05:32.320 --> 01:05:33.120
get什么呢

01:05:33.720 --> 01:05:34.220
key

01:05:34.920 --> 01:05:35.520
啊好

01:05:36.220 --> 01:05:37.120
值是什么呢

01:05:37.120 --> 01:05:38.920
就是不是就是原是对象的这个值

01:05:39.720 --> 01:05:40.020
对吧

01:05:40.020 --> 01:05:41.220
这就是原是对象的值

01:05:41.420 --> 01:05:41.820
啊

01:05:41.820 --> 01:05:42.620
talkit t

01:05:43.120 --> 01:05:43.720
原理是吧

01:05:43.720 --> 01:05:44.220
好

01:05:44.220 --> 01:05:45.320
同样的啊set

01:05:46.720 --> 01:05:49.120
talkit t value

01:05:50.220 --> 01:05:51.020
那么这里呢

01:05:51.420 --> 01:05:53.220
我是不是就把原是对象这个设置啊

01:05:53.220 --> 01:05:54.420
实际上在真实写法里边

01:05:54.420 --> 01:05:55.520
这样的写是不好的啊

01:05:55.520 --> 01:05:56.820
应该用反射

01:05:56.920 --> 01:05:57.920
应该用reflect啊

01:05:57.920 --> 01:06:00.520
但是我不想理入太多里面陌生的东西了

01:06:01.020 --> 01:06:02.420
我这就这样直接这样说

01:06:03.220 --> 01:06:04.920
说给原是对象加成这个属性

01:06:05.620 --> 01:06:06.120
是吧

01:06:06.520 --> 01:06:08.520
啊然后我们就输出set

01:06:09.620 --> 01:06:11.720
逻辑跟执相逻辑就不一样了

01:06:11.720 --> 01:06:13.320
执相逻辑是不是要便利循环

01:06:13.320 --> 01:06:14.120
现在不便利的

01:06:14.120 --> 01:06:14.920
直接把款代理

01:06:15.320 --> 01:06:16.820
你要用哪个属性的时候

01:06:16.820 --> 01:06:18.020
我才去读那个属性

01:06:18.620 --> 01:06:19.020
你要意思吧

01:06:19.020 --> 01:06:20.220
一看下面这张图

01:06:21.320 --> 01:06:22.120
普通对象

01:06:22.320 --> 01:06:24.620
调用调用这个reactive函数

01:06:26.220 --> 01:06:27.020
他就给你生成个代理

01:06:27.020 --> 01:06:28.020
就要返回一晚上了

01:06:29.020 --> 01:06:30.220
便利属性吗不便利

01:06:30.220 --> 01:06:31.520
是不是效率高很多

01:06:31.620 --> 01:06:33.120
如果说以前5u2的

01:06:33.320 --> 01:06:34.720
有有一些很大的对象

01:06:34.720 --> 01:06:35.520
他的输出啊

01:06:35.520 --> 01:06:36.420
还有包括输出

01:06:36.620 --> 01:06:38.620
还包括那个对象里边还要嵌套对象

01:06:38.620 --> 01:06:39.920
一个非常非常大的对象

01:06:40.720 --> 01:06:42.220
你把这个对象的属性

01:06:42.220 --> 01:06:43.520
全部循环便利出来

01:06:43.720 --> 01:06:45.100
然后一个一个去给它加上

01:06:45.300 --> 01:06:46.160
用difymproperty

01:06:46.160 --> 01:06:46.940
给他加上

01:06:46.940 --> 01:06:48.120
非常的浪费效率

01:06:48.220 --> 01:06:49.020
现在不用了

01:06:49.120 --> 01:06:50.420
直接生成的代理直接返回

01:06:51.620 --> 01:06:52.720
他赌他的属性的时候

01:06:52.720 --> 01:06:54.060
自动会运行g帧c's

01:06:54.260 --> 01:06:56.120
而且代理本身都比要

01:06:56.320 --> 01:06:58.620
本身就要比一个difymproperty效率要高

01:06:59.020 --> 01:07:00.820
啊我这里不展开了

01:07:01.520 --> 01:07:02.820
好放送那个

01:07:02.820 --> 01:07:03.920
读取这个key准啊

01:07:04.020 --> 01:07:05.420
然后呢后边加上一个

01:07:06.020 --> 01:07:06.880
哎哟表哥

01:07:06.880 --> 01:07:08.180
这里加一下一个什么

01:07:08.620 --> 01:07:13.480
60 那么我们来看一下能不能实现啊我先把后边两盒去掉

01:07:14.760 --> 01:07:15.280
装扣

01:07:16.040 --> 01:07:19.120
就可以读取那么的时候运行的get name molika

01:07:19.360 --> 01:07:21.160
设置名字的时候

01:07:22.440 --> 01:07:23.220
是莫莉卡

01:07:23.480 --> 01:07:23.980
是吧

01:07:24.500 --> 01:07:25.260
好那么现在

01:07:25.520 --> 01:07:26.280
这个问题来了

01:07:29.580 --> 01:07:30.340
你看这个问题

01:07:32.140 --> 01:07:33.180
addr

01:07:34.200 --> 01:07:34.700
等于

01:07:35.980 --> 01:07:36.500
set

01:07:36.500 --> 01:07:37.000
pro

01:07:38.040 --> 01:07:39.840
cannot set property province

01:07:40.340 --> 01:07:41.120
of undefend

01:07:41.620 --> 01:07:44.180
get的时候没反馈就说我没反馈

01:07:44.440 --> 01:07:45.460
反馈什么 package

01:07:45.720 --> 01:07:46.220
对了

01:07:46.480 --> 01:07:47.520
反正他原始的字

01:07:48.780 --> 01:07:49.300
这样啊

01:07:49.560 --> 01:07:50.060
运行

01:07:51.890 --> 01:07:54.190
好那么这里是不是又没有输出这个set premise

01:07:56.280 --> 01:07:56.780
为什么

01:07:57.800 --> 01:07:59.080
要知道为什么是不是这个

01:07:59.600 --> 01:08:00.620
又把这个拿过来看一下

01:08:01.400 --> 01:08:03.960
又把拿过来 拿个一面过来看一下就知道了

01:08:05.480 --> 01:08:06.000
为什么不行

01:08:06.760 --> 01:08:07.280
set

01:08:08.280 --> 01:08:14.960
他本身是一个代理对不对本身是个set本身是个代理没问题我们读一下set.addr读出来

01:08:15.220 --> 01:08:17.780
读出来过了他又变成个普通对象了

01:08:18.040 --> 01:08:20.340
把这个addr读出来又变成普通对象了

01:08:20.840 --> 01:08:21.880
所以说这里该怎么办

01:08:23.400 --> 01:08:23.920
该怎么办

01:08:25.200 --> 01:08:26.480
是不是还要把他

01:08:27.760 --> 01:08:32.880
再reactive一次又要地归对吧把这个玩意儿再进行一次reactive

01:08:33.640 --> 01:08:35.180
说这里的做法呢是什么呢

01:08:35.440 --> 01:08:35.940
是

01:08:36.920 --> 01:08:38.200
把这个玩意儿

01:08:38.460 --> 01:08:39.220
把那个

01:08:40.500 --> 01:08:41.260
这个东西

01:08:41.780 --> 01:08:45.260
reactive

01:08:45.520 --> 01:08:46.800
再进行是reactive

01:08:47.700 --> 01:08:51.660
对吧我不管他是不是对象吧他不是对象就把原始字返回给我

01:08:51.920 --> 01:08:52.940
如果他是对象的话

01:08:53.720 --> 01:08:55.520
他就变成一个代理返回

01:08:56.020 --> 01:08:57.820
那么这里边我们就是返回value

01:08:58.580 --> 01:09:00.120
对不对是不是动态的

01:09:00.880 --> 01:09:02.420
那么同样的这里复制的时候

01:09:02.940 --> 01:09:05.240
我管他那么多我先把这个value

01:09:06.000 --> 01:09:07.280
重新来reactive一次

01:09:08.960 --> 01:09:09.460
对不对

01:09:10.400 --> 01:09:11.200
变成这个样子

01:09:11.440 --> 01:09:12.960
哎现在就没问题了你看一下

01:09:14.240 --> 01:09:16.040
是不是现在是pervance

01:09:16.800 --> 01:09:17.640
读ct

01:09:18.800 --> 01:09:19.640
是不是都没问题了

01:09:20.200 --> 01:09:22.040
对吧好这是这一块啊

01:09:32.380 --> 01:09:33.180
有什么问题呢

01:09:38.220 --> 01:09:40.940
好这里边还有个小的细节啊

01:09:43.200 --> 01:09:44.220
一个小的细节

01:09:45.140 --> 01:09:45.780
就是

01:09:47.500 --> 01:09:51.540
你像你像这样子做的话会有一个问题就是你每一次读这个属性

01:09:51.840 --> 01:09:53.200
都要返回一个新的代理

01:09:54.080 --> 01:09:56.400
你看没每一次调调读这个属性

01:09:56.400 --> 01:09:57.920
比较这个属性就是addr

01:09:58.040 --> 01:09:58.640
而最实

01:09:59.520 --> 01:10:00.040
地址

01:10:00.720 --> 01:10:03.680
都要返回一个新的属性都要返回一个新的代理

01:10:04.200 --> 01:10:06.200
那么能不能重用之前的代理呢

01:10:07.320 --> 01:10:07.880
可以的

01:10:08.400 --> 01:10:09.720
可以重用之前的代理

01:10:09.840 --> 01:10:12.120
那我该怎么做才能有重用之前的代理呢

01:10:12.920 --> 01:10:14.240
我可以定一个辩量

01:10:15.160 --> 01:10:16.120
我们把它叫做map

01:10:16.800 --> 01:10:17.520
叫map

01:10:18.040 --> 01:10:19.440
map就是建制队啊

01:10:19.940 --> 01:10:21.740
嗯他跟普通对象有区别啊

01:10:21.980 --> 01:10:22.780
就是建制队

01:10:23.140 --> 01:10:23.740
一个map

01:10:24.100 --> 01:10:24.980
他里面有建

01:10:25.900 --> 01:10:26.860
呃比方说

01:10:27.260 --> 01:10:27.740
兼

01:10:28.140 --> 01:10:30.140
兼可以是任意内想啊可以是任意内想

01:10:30.140 --> 01:10:32.340
像我们普通对象的话属性只能是制服串

01:10:32.340 --> 01:10:32.700
对吧

01:10:32.900 --> 01:10:33.740
嗯那么这里的

01:10:34.260 --> 01:10:35.340
给我问一下大家

01:10:36.380 --> 01:10:37.140
我有点害怕

01:10:40.980 --> 01:10:43.980
对象的属性能否是

01:10:44.540 --> 01:10:45.100
数字

01:10:48.800 --> 01:10:49.680
看一下基础啊

01:10:53.770 --> 01:10:54.170
啊

01:10:55.930 --> 01:10:56.370
对啊

01:10:56.570 --> 01:10:57.570
是不会的对不对

01:10:57.870 --> 01:10:59.670
对象的属性是不可能是数字的

01:10:59.830 --> 01:11:01.310
对象的属性只有两种情况

01:11:01.310 --> 01:11:02.670
一个是制服串

01:11:02.870 --> 01:11:04.270
一个是symbol啊

01:11:04.270 --> 01:11:05.190
是耶稣约的symbol

01:11:05.190 --> 01:11:06.390
啊不可能是其他东西的

01:11:07.590 --> 01:11:09.070
像以后苏主是对象啊

01:11:09.070 --> 01:11:10.430
苏主为什么可以输数字呢

01:11:10.430 --> 01:11:11.190
他不是数字

01:11:11.430 --> 01:11:13.190
苏主的属性仍然是制服串的

01:11:13.470 --> 01:11:14.670
他仍然是制服串啊

01:11:15.030 --> 01:11:16.390
只不过你写出数字的时候

01:11:16.390 --> 01:11:17.870
然后会重新转成制服串啊

01:11:17.870 --> 01:11:18.590
这是基础

01:11:19.390 --> 01:11:20.670
那但是map里面不是啊

01:11:20.670 --> 01:11:22.350
map的key值是可以是任意内想

01:11:22.350 --> 01:11:23.990
哪怕是一个可以是一个对象都可以

01:11:24.670 --> 01:11:24.870
啊

01:11:24.870 --> 01:11:26.470
而且他key值是不重复的

01:11:26.490 --> 01:11:27.170
他是t白的

01:11:27.170 --> 01:11:28.530
就像我们昨天学到的那个

01:11:28.930 --> 01:11:30.690
呃请求投想用投对吧

01:11:30.690 --> 01:11:31.570
说建制队对吧

01:11:31.570 --> 01:11:33.170
一个建一个值一个建一个值

01:11:33.370 --> 01:11:34.970
那么map就是这样的结构啊

01:11:35.290 --> 01:11:36.090
一个建制队

01:11:36.370 --> 01:11:37.970
呃那他的属性啊

01:11:37.970 --> 01:11:39.610
他的件可以是任意内想

01:11:39.610 --> 01:11:41.370
他的值也可以是任意内想

01:11:41.690 --> 01:11:43.170
而且他的件是不重复的

01:11:43.170 --> 01:11:44.570
那么可以利用这样的特点

01:11:44.570 --> 01:11:45.890
我就构造一个map出来

01:11:47.290 --> 01:11:48.730
那么只要某一个对象

01:11:50.330 --> 01:11:52.690
里边以前缓存过proxy

01:11:52.690 --> 01:11:53.890
我就直接给他返回了

01:11:54.570 --> 01:11:55.970
如果他没有缓存过了

01:11:56.070 --> 01:11:56.870
比方说obj2

01:11:56.870 --> 01:11:57.170
啊

01:11:57.170 --> 01:11:58.670
我给他加一个proxy

01:11:58.670 --> 01:11:59.190
对吧

01:11:59.190 --> 01:12:00.190
可以缓存意义下

01:12:00.190 --> 01:12:01.590
达到一个缓存的目的

01:12:01.590 --> 01:12:01.950
于是呢

01:12:01.950 --> 01:12:02.390
这样子呢

01:12:02.390 --> 01:12:03.790
我们就可以在这里写出一个map

01:12:04.270 --> 01:12:04.990
叫proxy

01:12:06.910 --> 01:12:08.030
啊可以留一个map

01:12:09.350 --> 01:12:10.630
啊这是es6的指示啊

01:12:10.630 --> 01:12:11.630
你们以后都要学习的

01:12:12.190 --> 01:12:14.150
那么当我们读他属性的时候呢

01:12:14.150 --> 01:12:14.910
看一下

01:12:15.870 --> 01:12:17.430
以这个以这个talkit

01:12:17.430 --> 01:12:17.910
以这个

01:12:20.230 --> 01:12:21.270
当前属

01:12:21.270 --> 01:12:22.710
当前属性啊

01:12:22.710 --> 01:12:24.350
看一下这个talkit里边

01:12:24.350 --> 01:12:25.270
这个属性

01:12:26.150 --> 01:12:27.430
有没有代理

01:12:27.430 --> 01:12:28.270
啊就是

01:12:28.270 --> 01:12:30.510
以这个属性值看一下

01:12:30.510 --> 01:12:31.630
把个值拿出来

01:12:31.630 --> 01:12:33.070
看一下有没有代理过

01:12:34.670 --> 01:12:35.510
对吧

01:12:35.510 --> 01:12:36.710
首先看一下呢

01:12:36.710 --> 01:12:37.950
值拿出来有没有代理过

01:12:39.470 --> 01:12:40.070
这样子

01:12:40.070 --> 01:12:42.870
我们看一下那个proxy

01:12:42.870 --> 01:12:43.630
map里边

01:12:44.670 --> 01:12:45.870
map里边有一个方法叫get

01:12:47.710 --> 01:12:48.270
以这个东西

01:12:49.270 --> 01:12:53.470
以当前属性值作为件

01:12:54.470 --> 01:12:54.970
对吧

01:12:54.970 --> 01:12:55.970
map是件字对吗

01:12:55.970 --> 01:12:56.770
以它作为件

01:12:56.770 --> 01:12:58.570
看一下有没有这个东西

01:12:59.770 --> 01:13:03.770
看看该属性是否被代理过

01:13:06.340 --> 01:13:07.340
有没有代理过

01:13:08.340 --> 01:13:08.540
好

01:13:08.540 --> 01:13:10.940
如果说我们得到一个得到一个值啊

01:13:11.540 --> 01:13:12.940
就是proxy

01:13:14.740 --> 01:13:16.140
如果说代理过了

01:13:17.340 --> 01:13:17.940
直接反悔

01:13:18.740 --> 01:13:19.140
proxy

01:13:20.140 --> 01:13:20.340
啊

01:13:20.340 --> 01:13:21.140
其实我们可以

01:13:21.140 --> 01:13:22.540
可以其实不要写到这儿啊

01:13:22.540 --> 01:13:23.940
写到这儿许是不是很好

01:13:24.040 --> 01:13:25.240
我们写到川普其实是最好的

01:13:26.240 --> 01:13:28.640
当你对是整个对象作为数据响应识的时候

01:13:28.640 --> 01:13:28.840
对吧

01:13:28.840 --> 01:13:29.840
在这里写是最好的

01:13:30.240 --> 01:13:31.040
来写过来

01:13:34.140 --> 01:13:34.640
绿刀子

01:13:37.640 --> 01:13:39.840
看一下当前的那个对象

01:13:40.440 --> 01:13:45.110
当前对象作为件

01:13:45.110 --> 01:13:47.310
看一下该对象是否被代理过

01:13:48.710 --> 01:13:49.710
是否被代理过

01:13:49.910 --> 01:13:51.010
如果说代理过了

01:13:51.010 --> 01:13:52.310
就对象有值了

01:13:52.310 --> 01:13:52.610
对吧

01:13:52.610 --> 01:13:54.110
它可以根据件来得到值

01:13:55.910 --> 01:13:56.710
那么已经代理过了

01:13:56.710 --> 01:13:58.210
我就把这个绿刀子直接反悔

01:13:58.910 --> 01:14:00.210
好如果说没有代理过了

01:14:00.210 --> 01:14:01.510
那么之前的代码不变啊

01:14:03.110 --> 01:14:04.010
之前代码不变

01:14:05.310 --> 01:14:05.510
好

01:14:05.510 --> 01:14:06.610
如果说没有代理过了

01:14:06.610 --> 01:14:07.610
没有代理过我的话

01:14:07.610 --> 01:14:08.810
我就得到一个新的代理

01:14:10.710 --> 01:14:12.210
绿刀子得到一个新的代理

01:14:13.310 --> 01:14:14.210
然后把个代理

01:14:15.010 --> 01:14:16.010
缓存进

01:14:16.810 --> 01:14:17.110
买

01:14:19.120 --> 01:14:20.320
那就是proxy

01:14:20.520 --> 01:14:20.920
买

01:14:21.320 --> 01:14:21.820
set

01:14:22.620 --> 01:14:22.920
啊

01:14:22.920 --> 01:14:23.520
set的话

01:14:23.520 --> 01:14:24.820
第一个传输传件

01:14:24.820 --> 01:14:25.820
建了就是这个

01:14:26.420 --> 01:14:26.920
obj

01:14:28.220 --> 01:14:28.620
啊

01:14:28.820 --> 01:14:29.320
值呢

01:14:29.320 --> 01:14:30.120
就是这个绿刀子

01:14:30.120 --> 01:14:30.520
对吧

01:14:30.520 --> 01:14:31.620
它的代理对象

01:14:32.120 --> 01:14:32.720
缓存进去

01:14:32.720 --> 01:14:34.320
那么下一次对同一个对象

01:14:35.020 --> 01:14:36.120
就不用再重新代理了

01:14:36.120 --> 01:14:36.520
对吧

01:14:36.520 --> 01:14:38.120
不用再重新返回一个新的代理了

01:14:38.120 --> 01:14:39.520
直接用之前的代理就可以了

01:14:39.720 --> 01:14:39.920
好

01:14:39.920 --> 01:14:41.220
最后把这个绿刀子打回

01:14:41.420 --> 01:14:41.820
对吧

01:14:41.820 --> 01:14:42.720
稍微缓存一下

01:14:42.920 --> 01:14:43.420
搞定了

01:14:44.220 --> 01:14:45.620
那当然效果是完全一样的啊

01:14:45.620 --> 01:14:46.820
只是提高了一下效率

01:14:47.220 --> 01:14:47.420
对吧

01:14:47.420 --> 01:14:48.420
效果是完全一样的

01:14:48.820 --> 01:14:49.120
好

01:14:49.120 --> 01:14:52.120
这是无诱三来做这个代理

01:14:54.640 --> 01:14:55.340
另外呢

01:14:55.340 --> 01:14:56.540
我可以跟大家说一下啊

01:14:56.840 --> 01:14:58.540
实际上无诱三里边的这个地方呢

01:14:58.540 --> 01:14:59.540
它用的不是map

01:14:59.540 --> 01:15:00.640
它用的是weekmap

01:15:02.520 --> 01:15:03.220
哎呀

01:15:03.720 --> 01:15:06.020
那么weekmap跟map有什么区别呢

01:15:07.420 --> 01:15:10.020
我只能说es6是一个非常非常重要的

01:15:10.520 --> 01:15:12.220
应该是注意基础的啊

01:15:12.220 --> 01:15:13.820
除了这些这些之外

01:15:13.820 --> 01:15:15.020
注意基础的一个

01:15:15.320 --> 01:15:16.420
一个大知识啊

01:15:16.620 --> 01:15:18.020
一定要好好学一下

01:15:19.020 --> 01:15:20.420
不然的话你们干活

01:15:20.420 --> 01:15:21.420
或者是看这些代码

01:15:21.420 --> 01:15:22.020
看这些原理

01:15:22.020 --> 01:15:23.720
根本不知道他的说啥啊

01:15:23.720 --> 01:15:24.320
你可以认为

01:15:24.320 --> 01:15:24.820
目前呢

01:15:24.820 --> 01:15:25.720
我就我就给你们说

01:15:25.720 --> 01:15:27.120
我简单说他效率要高一些

01:15:27.820 --> 01:15:28.420
然后呢

01:15:29.420 --> 01:15:30.720
在某些时候啊

01:15:30.820 --> 01:15:31.820
你可以用weekmap

01:15:31.820 --> 01:15:32.620
代替map

01:15:32.720 --> 01:15:33.820
效果是完全一样的

01:15:34.420 --> 01:15:35.520
我只能这样的说了

01:15:35.520 --> 01:15:37.120
这个一讲就不让的话就没完了

01:15:38.220 --> 01:15:39.220
好pragtis2

01:15:39.720 --> 01:15:40.520
第二个问题

01:15:43.930 --> 01:15:44.730
第二个问题

01:15:45.030 --> 01:15:46.830
同样的这是一个outrun函数

01:15:47.730 --> 01:15:48.330
是不是

01:15:48.430 --> 01:15:49.630
是不是跟之前一样的

01:15:50.730 --> 01:15:52.630
啊那么我们用一样的做法呗

01:15:53.030 --> 01:15:54.130
一样的做法就完了

01:15:54.530 --> 01:15:55.130
好来吧

01:15:55.230 --> 01:15:57.230
afig只函数跟之前写法完全一样

01:15:57.530 --> 01:15:58.330
直接扔过来

01:16:04.690 --> 01:16:05.390
pragtis2

01:16:07.090 --> 01:16:07.790
直接扔过来

01:16:08.290 --> 01:16:08.590
然后呢

01:16:08.590 --> 01:16:09.490
这上面定一个

01:16:09.490 --> 01:16:10.090
来个题

01:16:16.600 --> 01:16:17.400
完全一样的对吧

01:16:17.400 --> 01:16:18.400
没有什么区别啊

01:16:18.600 --> 01:16:19.000
这一块呢

01:16:19.000 --> 01:16:20.900
其实在五右三里边也没有什么改动

01:16:21.500 --> 01:16:22.700
他把名字改了一下啊

01:16:23.000 --> 01:16:24.400
然后以前也不叫outrun了啊

01:16:24.400 --> 01:16:26.000
以前他是分成很多的方法

01:16:26.600 --> 01:16:28.700
总之他是这个这一块没什么区别

01:16:30.500 --> 01:16:31.100
然后呢

01:16:31.100 --> 01:16:32.200
关键是上面

01:16:32.300 --> 01:16:33.200
你会发现

01:16:33.600 --> 01:16:34.600
现在的做法呢

01:16:34.600 --> 01:16:36.700
不再是用那个dip构造函数了

01:16:37.000 --> 01:16:39.500
他变五右三里边变成了两个track

01:16:39.800 --> 01:16:40.200
两个方法

01:16:40.200 --> 01:16:41.100
一个叫track

01:16:41.900 --> 01:16:42.900
一个叫trigger

01:16:43.700 --> 01:16:45.700
承担的作用跟以前的dipend

01:16:47.500 --> 01:16:48.100
和

01:16:49.000 --> 01:16:50.700
low t5是一样的

01:16:51.700 --> 01:16:53.200
那么他为什么要这样子设计呢

01:16:53.200 --> 01:16:54.600
以前不用的好好的吗

01:16:54.800 --> 01:16:55.300
啊

01:16:55.500 --> 01:16:57.500
做五右二元吧分析的时候非常经典的

01:16:57.500 --> 01:16:57.700
对吧

01:16:57.700 --> 01:16:58.500
dip对象

01:16:58.500 --> 01:17:00.200
dip构造函数是非常经典的

01:17:00.600 --> 01:17:03.000
那么为什么以前用的好好的他要去改呢

01:17:03.300 --> 01:17:05.500
是为了一个东西叫做学协讯

01:17:06.900 --> 01:17:08.300
那什么又叫做学协讯呢

01:17:08.300 --> 01:17:09.900
这要你们学习构建工具了

01:17:11.500 --> 01:17:12.700
不要小看前端是吧

01:17:13.200 --> 01:17:15.200
很多后端和开发者觉得前端

01:17:15.700 --> 01:17:16.200
很简单吧

01:17:16.200 --> 01:17:17.300
就是学习个节目是吧

01:17:17.900 --> 01:17:18.900
东西多的吓死你

01:17:19.600 --> 01:17:21.300
当然整体上的逻辑上的

01:17:21.300 --> 01:17:23.300
要比那个后端简单一点

01:17:23.500 --> 01:17:25.900
但是知识量上了一点都不少

01:17:28.770 --> 01:17:30.370
每行嘛一夜都不简单啊

01:17:30.970 --> 01:17:32.170
要想啊高薪

01:17:33.170 --> 01:17:33.970
大家加油

01:17:35.370 --> 01:17:35.870
其实

01:17:36.370 --> 01:17:39.070
你也不用考虑的太远有的时候

01:17:39.970 --> 01:17:41.370
你就每天一步一个脚印

01:17:41.370 --> 01:17:42.770
今天我干干干啥

01:17:42.970 --> 01:17:44.770
今天第二天我干学啥

01:17:44.870 --> 01:17:46.570
不要给自己定太高的目标

01:17:46.970 --> 01:17:47.970
不要老盯着

01:17:48.670 --> 01:17:50.370
我马上就要学成一个

01:17:50.370 --> 01:17:51.670
我马上就要去重立大厂

01:17:51.770 --> 01:17:54.070
我今天开始学刚刚才开始学借识

01:17:54.170 --> 01:17:56.070
我就想着下个月我要去你进阿里

01:17:56.470 --> 01:17:58.070
你这样的想法的话你是欺骗自己

01:17:58.070 --> 01:18:00.470
你这样的学的话可以非常非常有负责感

01:18:01.570 --> 01:18:02.470
你学不下去了

01:18:02.970 --> 01:18:04.070
你第一个小目标

01:18:04.170 --> 01:18:05.370
比方说今天今天

01:18:06.070 --> 01:18:07.470
我就搞定函数

01:18:07.470 --> 01:18:09.270
我把函数彻彻底意的搞定

01:18:10.970 --> 01:18:12.470
或者是我用一周的时间吧

01:18:12.470 --> 01:18:14.470
一天搞不定一周的时间把函数彻底搞定

01:18:14.470 --> 01:18:15.470
函数的作用预订

01:18:15.570 --> 01:18:18.170
作用那个作用预订原型链

01:18:18.170 --> 01:18:19.170
这些构造函数

01:18:19.170 --> 01:18:21.070
各种写法认识的指向全部搞定

01:18:21.070 --> 01:18:22.170
一周的时间够了吧

01:18:22.970 --> 01:18:24.370
好下一周我有搞定什么东西

01:18:24.370 --> 01:18:25.670
一件事一件事搞定

01:18:26.370 --> 01:18:27.670
你这样子走一两个月

01:18:27.870 --> 01:18:28.570
你会发现

01:18:29.070 --> 01:18:30.870
已经走了很长很长的路了

01:18:31.070 --> 01:18:32.470
而且学的越来越有劲

01:18:33.270 --> 01:18:35.070
不要给自己定太高的目标啊

01:18:35.070 --> 01:18:36.270
一点一点人去做

01:18:36.770 --> 01:18:37.870
他那时时的去做

01:18:39.270 --> 01:18:41.670
那么这个缺失件是另外一门技术里面的概念

01:18:41.670 --> 01:18:42.670
它是为了这个东西

01:18:42.670 --> 01:18:43.870
它是为了进行优化的

01:18:43.870 --> 01:18:45.570
所以把它写成两个分开的函数

01:18:48.250 --> 01:18:49.050
第一个参数

01:18:49.850 --> 01:18:52.050
你要跟踪哪个对象的哪个属性

01:18:52.850 --> 01:18:53.750
第二个参数

01:18:54.750 --> 01:18:55.550
你要跟踪

01:18:56.450 --> 01:18:58.750
哪你要触发哪个对象的哪个属性

01:18:59.650 --> 01:19:00.950
你看啊我第一个

01:19:01.050 --> 01:19:02.550
out of wrong啊也就是effect

01:19:02.850 --> 01:19:04.750
我是要跟踪这个state的name

01:19:05.350 --> 01:19:06.750
对吧我现在没有做什么代理

01:19:06.750 --> 01:19:07.650
就是一个普通对象

01:19:07.650 --> 01:19:09.450
我告诉他我要跟踪这个微相的name

01:19:10.850 --> 01:19:11.250
好

01:19:11.750 --> 01:19:12.950
他输出了name is Monica

01:19:13.050 --> 01:19:13.950
把这句话输出了

01:19:14.150 --> 01:19:14.950
然后第二个函数

01:19:14.950 --> 01:19:16.250
我要跟踪这个对象的A级

01:19:16.550 --> 01:19:17.550
他把这句话输出了

01:19:17.950 --> 01:19:19.750
好接下来我只要触发

01:19:19.850 --> 01:19:21.450
触发这个对象的name属性

01:19:21.650 --> 01:19:22.950
那么跟他这个name

01:19:22.950 --> 01:19:24.050
这个属性相关的

01:19:24.050 --> 01:19:25.450
之前被跟踪过的函数

01:19:25.950 --> 01:19:26.850
就会被执行

01:19:27.650 --> 01:19:29.050
我触发这个属性A级

01:19:29.450 --> 01:19:31.450
跟之前被跟踪过A级的函数

01:19:31.450 --> 01:19:32.350
就会被执行

01:19:33.150 --> 01:19:34.050
就这么个意思

01:19:34.250 --> 01:19:35.450
那这个东西又怎么做呢

01:19:39.980 --> 01:19:40.780
他需要一张

01:19:41.780 --> 01:19:42.780
很大的地图

01:19:46.010 --> 01:19:47.310
有点像reacts是吧

01:19:47.810 --> 01:19:48.310
嗯

01:19:48.910 --> 01:19:50.010
就是现在那个

01:19:50.010 --> 01:19:51.710
无忧里边的compression api啊

01:19:52.010 --> 01:19:54.010
很多都把他跟那个reaction去比一下

01:19:54.010 --> 01:19:55.710
确实API上确实有点像

01:19:55.710 --> 01:19:57.310
但是他的实现是完全不一样

01:19:59.660 --> 01:20:01.160
看一下无忧三的一代手机

01:20:01.960 --> 01:20:03.060
其他地方都不用看了

01:20:03.060 --> 01:20:03.760
其他地方都是一样

01:20:03.760 --> 01:20:05.260
记录记录记录啊

01:20:05.360 --> 01:20:06.360
trigger怎么样怎么样

01:20:07.260 --> 01:20:08.560
关键看右边这个东西

01:20:09.260 --> 01:20:10.760
由于他现在没有构造函数了

01:20:10.760 --> 01:20:12.160
你不能像之前那样子

01:20:12.160 --> 01:20:13.060
创建一个对象对吧

01:20:13.060 --> 01:20:14.260
每个对象里边有个输出

01:20:14.960 --> 01:20:15.660
现在不行了

01:20:16.660 --> 01:20:19.360
现在呢是有一个很大很大的enlight

01:20:20.460 --> 01:20:21.460
整个就是一张图

01:20:21.460 --> 01:20:22.260
就是一个map

01:20:24.200 --> 01:20:25.100
图里边呢

01:20:25.100 --> 01:20:25.900
键是什么呢

01:20:25.900 --> 01:20:26.700
键是对象

01:20:27.800 --> 01:20:28.800
要跟踪的对象

01:20:29.900 --> 01:20:30.800
只是什么呢

01:20:31.400 --> 01:20:32.700
只又是一个map

01:20:34.200 --> 01:20:35.300
只他又是一个map

01:20:35.800 --> 01:20:37.200
那么这里边的map是什么呢

01:20:37.200 --> 01:20:38.700
是丢下了每一个属性

01:20:39.700 --> 01:20:41.500
那么每一个属性只又是什么呢

01:20:41.700 --> 01:20:42.600
是一个set

01:20:43.000 --> 01:20:44.300
就是我们之前看到一个输入

01:20:44.500 --> 01:20:45.400
就是enlight输入

01:20:46.000 --> 01:20:48.000
看一下这个对象的这个属性

01:20:48.000 --> 01:20:49.100
有哪些还属依赖

01:20:49.400 --> 01:20:50.500
这个对象的这个属性

01:20:50.500 --> 01:20:51.300
有哪些还属依赖

01:20:51.300 --> 01:20:52.700
所以现在更加好理解一点

01:20:53.300 --> 01:20:54.200
这个对象的这个属性

01:20:54.200 --> 01:20:55.200
有哪些还属依赖

01:20:55.200 --> 01:20:56.100
这个对象的这个属性

01:20:56.100 --> 01:20:57.000
有哪些还属依赖

01:20:58.100 --> 01:20:59.400
那么到时候出一个的时候

01:20:59.400 --> 01:21:00.100
比方说我要去个

01:21:00.100 --> 01:21:01.600
这个对象的lame属性

01:21:01.600 --> 01:21:02.600
那么他就找到

01:21:02.600 --> 01:21:03.800
这个对象的lame属性

01:21:03.800 --> 01:21:05.200
把他的输出拿出来

01:21:05.200 --> 01:21:05.760
循环

01:21:05.760 --> 01:21:06.500
依次执行

01:21:08.000 --> 01:21:09.100
我要跟踪的时候

01:21:09.100 --> 01:21:10.300
他就从地图里边找

01:21:10.500 --> 01:21:10.800
对吧

01:21:10.800 --> 01:21:11.900
跟踪的时候也是一样

01:21:11.900 --> 01:21:12.800
我要跟踪

01:21:12.800 --> 01:21:13.600
就是track

01:21:13.800 --> 01:21:14.900
obj2 name

01:21:15.000 --> 01:21:15.900
那么他就把这个

01:21:16.400 --> 01:21:18.800
函数加到这个数组的莫为

01:21:19.800 --> 01:21:21.600
当然这个数组里面不能重复啊

01:21:22.100 --> 01:21:23.300
专程这么一个图

01:21:23.300 --> 01:21:25.500
那么这个图是不是需要个辩量来记录

01:21:27.300 --> 01:21:28.800
我们把它叫做debs map

01:21:30.840 --> 01:21:31.540
它是一个什么呢

01:21:31.540 --> 01:21:32.240
它是个map

01:21:32.240 --> 01:21:33.540
它其实真实的情况下

01:21:33.540 --> 01:21:35.040
是一个weekmap

01:21:35.440 --> 01:21:36.340
是一个weekmap

01:21:37.240 --> 01:21:37.940
这是一个

01:21:38.840 --> 01:21:41.040
很大的enlight地图

01:21:42.340 --> 01:21:43.640
用于记录

01:21:44.040 --> 01:21:45.140
所有

01:21:45.640 --> 01:21:46.640
对象的

01:21:46.640 --> 01:21:49.640
所有属性的enlight

01:21:50.740 --> 01:21:51.240
你看

01:21:51.340 --> 01:21:53.040
每一个对象的所有属性的enlight

01:21:54.640 --> 01:21:55.140
好

01:21:55.240 --> 01:21:55.840
那么我们来看一下

01:21:55.840 --> 01:21:56.740
这个track函数怎么写

01:21:56.740 --> 01:21:57.640
现在就好写了

01:21:59.240 --> 01:21:59.940
怎么写呢

01:22:00.240 --> 01:22:01.140
track函数

01:22:01.340 --> 01:22:01.940
给我一个对象

01:22:01.940 --> 01:22:02.640
给我一个属性

01:22:02.640 --> 01:22:04.240
我首先从这个地图里边去找

01:22:04.840 --> 01:22:05.640
这个对象有

01:22:05.640 --> 01:22:06.640
地图里边有没有

01:22:06.640 --> 01:22:07.140
对吧

01:22:07.740 --> 01:22:08.340
从什么

01:22:08.340 --> 01:22:09.740
从这个debs map

01:22:11.440 --> 01:22:12.240
map里边

01:22:12.640 --> 01:22:13.340
找一下

01:22:13.940 --> 01:22:14.640
get

01:22:14.640 --> 01:22:15.340
talkit

01:22:16.440 --> 01:22:16.840
对吧

01:22:16.840 --> 01:22:17.540
拿出来

01:22:17.640 --> 01:22:18.540
从地图里边找

01:22:19.940 --> 01:22:21.340
从地图中

01:22:22.040 --> 01:22:24.240
取出该对象的

01:22:24.740 --> 01:22:25.740
enlight情况

01:22:26.540 --> 01:22:29.540
对象所有属性的enlight情况

01:22:31.640 --> 01:22:32.140
拿到

01:22:32.340 --> 01:22:33.340
拿到一个什么呢

01:22:33.340 --> 01:22:34.440
拿到一个

01:22:36.540 --> 01:22:37.140
debs

01:22:39.680 --> 01:22:40.780
talkit debs

01:22:41.380 --> 01:22:42.080
换个名字

01:22:44.830 --> 01:22:45.930
这个对象的所有的

01:22:46.230 --> 01:22:47.330
所有的enlight

01:22:48.230 --> 01:22:49.130
那么现在呢

01:22:49.130 --> 01:22:49.730
这个有没有

01:22:49.730 --> 01:22:50.930
是不是有可能是undefined的

01:22:50.930 --> 01:22:51.830
有可能根本就不存在

01:22:51.830 --> 01:22:51.930
对吧

01:22:51.930 --> 01:22:53.030
一开始这个啥都没有

01:22:53.030 --> 01:22:53.330
对不对

01:22:53.330 --> 01:22:54.430
这个地图里边啥都没有

01:22:55.130 --> 01:22:55.730
有可能存在

01:22:55.730 --> 01:22:56.630
有可能不存在

01:22:56.730 --> 01:22:58.130
那么如果说他不存在

01:23:00.030 --> 01:23:00.730
他不存在

01:23:01.230 --> 01:23:02.230
如果不存在

01:23:03.030 --> 01:23:03.730
为其

01:23:04.530 --> 01:23:05.630
创建地图

01:23:07.030 --> 01:23:08.330
那么就是talkit

01:23:08.930 --> 01:23:09.430
debs

01:23:10.230 --> 01:23:10.830
等于什么呢

01:23:10.830 --> 01:23:12.030
给他重新创建一个

01:23:12.130 --> 01:23:13.030
创建一个什么

01:23:13.130 --> 01:23:14.630
这个对象他对的是什么

01:23:14.630 --> 01:23:15.630
又是一个地图

01:23:16.030 --> 01:23:16.730
丢一个nlight

01:23:17.530 --> 01:23:18.030
对吧

01:23:18.130 --> 01:23:18.530
然后呢

01:23:18.530 --> 01:23:19.430
把它设置到

01:23:19.530 --> 01:23:20.630
这个地图里边去

01:23:20.830 --> 01:23:22.930
这个地图的件是obj

01:23:22.930 --> 01:23:23.830
就是这个对象

01:23:24.330 --> 01:23:25.630
他不是不存在吗

01:23:25.630 --> 01:23:26.330
get set

01:23:26.830 --> 01:23:28.330
对象是talkit

01:23:29.330 --> 01:23:30.030
值吗

01:23:30.230 --> 01:23:31.030
建置对吗

01:23:31.030 --> 01:23:32.730
值呢就是这个talkit debs

01:23:34.030 --> 01:23:35.030
这个对象的所有的

01:23:35.230 --> 01:23:35.530
对吧

01:23:35.530 --> 01:23:36.430
为其创建地图

01:23:37.230 --> 01:23:38.530
那么之后是不是就有了

01:23:38.630 --> 01:23:38.830
对吧

01:23:38.830 --> 01:23:39.630
一开始没有嘛

01:23:40.330 --> 01:23:40.530
好

01:23:40.530 --> 01:23:41.930
除了这个判断

01:23:42.330 --> 01:23:43.130
那么除了这个判断

01:23:43.130 --> 01:23:44.330
是不是一定有这个地图了

01:23:44.330 --> 01:23:44.730
他没有

01:23:44.730 --> 01:23:46.130
他没有就创建了嘛

01:23:46.230 --> 01:23:47.630
他有的话他就一定有了

01:23:49.130 --> 01:23:50.130
那么现在干嘛呢

01:23:50.230 --> 01:23:51.430
又要从那个对象的

01:23:51.430 --> 01:23:53.730
对应这个地图里边去找什么

01:23:54.630 --> 01:23:56.130
以属性作为件

01:23:56.130 --> 01:23:57.130
去找这个东西

01:23:58.230 --> 01:23:58.730
对不对

01:23:58.730 --> 01:23:59.730
所以说我们第二步

01:24:00.130 --> 01:24:02.030
要从这个debs

01:24:02.130 --> 01:24:03.830
talkit debs里边

01:24:04.330 --> 01:24:04.930
get

01:24:05.330 --> 01:24:06.330
他不是一个地图吗

01:24:06.330 --> 01:24:06.830
对不对

01:24:06.830 --> 01:24:07.330
max

01:24:07.730 --> 01:24:08.030
好

01:24:08.030 --> 01:24:10.830
那么我们得到以属性作为件

01:24:11.830 --> 01:24:14.030
去找什么属性的debs

01:24:15.970 --> 01:24:16.770
找到

01:24:17.570 --> 01:24:19.570
该属性的

01:24:19.670 --> 01:24:20.170
以那

01:24:20.270 --> 01:24:20.770
集合

01:24:22.370 --> 01:24:23.970
那么属性是不是有可能不存在

01:24:23.970 --> 01:24:24.170
对吧

01:24:24.170 --> 01:24:25.270
他地图可能存在

01:24:25.370 --> 01:24:26.070
但是这个地图

01:24:26.070 --> 01:24:28.170
里边这个属性以前从来没有跟踪过

01:24:28.370 --> 01:24:29.370
以前从来没有跟踪过

01:24:29.370 --> 01:24:30.670
是不是这个属性就不存在

01:24:31.570 --> 01:24:32.670
一开始都是空的

01:24:32.870 --> 01:24:34.470
那么如果说他不存在的话

01:24:35.670 --> 01:24:36.170
debs

01:24:36.870 --> 01:24:37.870
他不存在的话

01:24:38.070 --> 01:24:39.770
那么我就给debs重新复制

01:24:39.770 --> 01:24:40.670
复制为什么呢

01:24:41.870 --> 01:24:44.770
是不是复制为一个set

01:24:44.770 --> 01:24:45.070
对吧

01:24:45.070 --> 01:24:46.670
一个不可重复的集合

01:24:47.770 --> 01:24:48.870
然后同样道理

01:24:48.870 --> 01:24:49.870
我要把这个set

01:24:49.870 --> 01:24:50.670
加到哪去

01:24:50.670 --> 01:24:51.870
加到这个profit debs

01:24:52.470 --> 01:24:53.070
set

01:24:53.070 --> 01:24:53.870
t是什么

01:24:54.170 --> 01:24:54.870
这是个地图

01:24:54.870 --> 01:24:55.470
t是什么

01:24:55.470 --> 01:24:56.670
t就是这个t

01:24:57.270 --> 01:24:57.870
debs

01:24:57.870 --> 01:24:58.670
就这个debs

01:24:59.070 --> 01:24:59.670
加进去

01:24:59.670 --> 01:25:00.870
那么这样的判断出来

01:25:00.870 --> 01:25:01.470
是不是又可以

01:25:01.470 --> 01:25:03.470
这种模式是经常写的

01:25:03.670 --> 01:25:04.870
他不存在就怎么样怎么样

01:25:04.870 --> 01:25:05.870
总之呢

01:25:05.870 --> 01:25:06.670
除了这个判断过后

01:25:06.670 --> 01:25:07.670
就达到一模一样的效果

01:25:07.670 --> 01:25:09.170
他存在和不存在都是这个效果

01:25:10.070 --> 01:25:10.670
好

01:25:11.270 --> 01:25:12.670
然后到下面来

01:25:12.670 --> 01:25:14.270
是不是就一set就营有了

01:25:14.470 --> 01:25:14.970
对吧

01:25:14.970 --> 01:25:15.870
那么我们要做的事情

01:25:15.870 --> 01:25:16.670
就很简单了

01:25:17.670 --> 01:25:18.570
就把这个

01:25:18.970 --> 01:25:20.170
active update

01:25:20.170 --> 01:25:21.570
所以加到这个set里边去

01:25:22.070 --> 01:25:22.370
对吧

01:25:22.370 --> 01:25:23.570
所以加到这个set里边去

01:25:26.940 --> 01:25:27.640
a

01:25:27.640 --> 01:25:28.340
这个debs

01:25:29.740 --> 01:25:30.540
add

01:25:31.240 --> 01:25:31.740
是吧

01:25:32.740 --> 01:25:33.940
active update

01:25:33.940 --> 01:25:34.940
加进去又完成

01:25:35.240 --> 01:25:35.740
当然了

01:25:35.740 --> 01:25:36.740
也可以在之前啊

01:25:36.740 --> 01:25:37.940
判断一下active update

01:25:37.940 --> 01:25:38.640
都是存在

01:25:38.640 --> 01:25:39.140
存在的话

01:25:39.140 --> 01:25:39.840
才做这个事

01:25:39.840 --> 01:25:40.440
不存在的话

01:25:40.440 --> 01:25:41.540
就不用记住了

01:25:46.210 --> 01:25:47.110
来就check

01:25:47.810 --> 01:25:48.110
对吧

01:25:48.110 --> 01:25:48.910
他以前就

01:25:48.910 --> 01:25:49.910
他不是每

01:25:49.910 --> 01:25:51.210
他又不是勾到函数的模式

01:25:51.210 --> 01:25:52.510
他建了一个很大的地图

01:25:53.410 --> 01:25:53.510
好

01:25:53.510 --> 01:25:54.610
然后缺一个的时候了

01:25:54.610 --> 01:25:56.010
触发的时候就很简单了

01:25:56.210 --> 01:25:57.810
那把意思读出来就完成到这边

01:25:58.010 --> 01:25:59.110
我们把这个代码

01:25:59.210 --> 01:25:59.910
复制一下

01:26:05.060 --> 01:26:05.760
重新来呗

01:26:06.560 --> 01:26:07.260
缺一个的话

01:26:07.260 --> 01:26:08.960
首先通过这个地对象

01:26:09.260 --> 01:26:10.360
看一下对象的

01:26:10.660 --> 01:26:12.160
每个属性的依赖地图

01:26:13.060 --> 01:26:14.460
然后对象的依赖地图

01:26:14.460 --> 01:26:14.860
是吧

01:26:15.460 --> 01:26:15.560
好

01:26:15.560 --> 01:26:16.760
如果不存在的话

01:26:16.760 --> 01:26:17.360
不存在的话

01:26:17.360 --> 01:26:18.560
就不要诸任何事情了

01:26:18.560 --> 01:26:19.360
你要触发嘛

01:26:19.360 --> 01:26:20.360
他的对象都没有

01:26:20.360 --> 01:26:21.560
从来没有记住过依赖

01:26:21.560 --> 01:26:22.360
那还触发了

01:26:22.960 --> 01:26:23.560
结束了

01:26:24.260 --> 01:26:24.460
好

01:26:24.460 --> 01:26:25.360
然后又继续了

01:26:25.360 --> 01:26:26.260
如果说没有结束的话

01:26:26.260 --> 01:26:27.560
那都属于地图存在

01:26:27.560 --> 01:26:29.460
那么有拿到这个属性的依赖

01:26:29.460 --> 01:26:29.960
对吧

01:26:29.960 --> 01:26:30.960
这个属性

01:26:31.160 --> 01:26:32.260
比方拿到个内面属性

01:26:32.260 --> 01:26:33.360
有哪些依赖

01:26:34.160 --> 01:26:34.860
好拿到这属性

01:26:34.860 --> 01:26:36.360
如果说没有依赖的话

01:26:36.360 --> 01:26:36.960
那就不存

01:26:37.360 --> 01:26:38.560
那就就结束了

01:26:38.560 --> 01:26:39.060
对吧

01:26:39.960 --> 01:26:40.160
好

01:26:40.160 --> 01:26:42.260
那么如果说之前都没有结束

01:26:42.260 --> 01:26:43.560
是不是一带都一定存在

01:26:43.860 --> 01:26:45.660
那么地里边的一个个拿出来

01:26:46.760 --> 01:26:47.460
所以一个拿出来

01:26:47.460 --> 01:26:48.760
多一起循环

01:26:49.160 --> 01:26:49.860
又又来了

01:26:49.860 --> 01:26:50.160
对吧

01:26:50.160 --> 01:26:50.760
一样的

01:26:51.460 --> 01:26:52.360
调整就完成了

01:26:54.360 --> 01:26:55.860
那就是TRIGGER是Track的写法

01:26:56.260 --> 01:26:57.260
那么现在我们来看一下

01:26:57.360 --> 01:26:58.160
右键运行

01:26:58.860 --> 01:26:59.260
呀

01:26:59.960 --> 01:27:00.560
凹凸装

01:27:00.560 --> 01:27:01.360
这不是凹凸装

01:27:01.360 --> 01:27:01.660
哎

01:27:02.860 --> 01:27:04.860
这边拿哪里还有凹凸装啊

01:27:06.260 --> 01:27:07.060
Private第十二

01:27:07.360 --> 01:27:08.060
看一下啊

01:27:08.460 --> 01:27:09.360
哦这里啊

01:27:09.460 --> 01:27:10.760
这里应该叫Effects

01:27:11.960 --> 01:27:12.460
运行

01:27:12.860 --> 01:27:13.360
呀

01:27:13.760 --> 01:27:14.560
是没问题了

01:27:15.560 --> 01:27:16.360
Ages

01:27:16.860 --> 01:27:17.260
啊

01:27:17.360 --> 01:27:18.260
之后我们TRIGGER

01:27:18.360 --> 01:27:18.660
对吧

01:27:18.660 --> 01:27:20.160
又说出我们Name is MOLICA

01:27:20.560 --> 01:27:22.160
TRIGGER AG AG是17

01:27:22.960 --> 01:27:23.460
trigger

01:27:24.160 --> 01:27:25.160
那既然如此

01:27:25.160 --> 01:27:26.460
最后不用我说了吧

01:27:26.960 --> 01:27:28.560
就是两个代码合并一下

01:27:28.960 --> 01:27:29.460
对不对

01:27:29.460 --> 01:27:30.360
第一块代码

01:27:34.030 --> 01:27:34.830
第一块代码

01:27:36.230 --> 01:27:36.930
暂停过来

01:27:42.710 --> 01:27:44.010
啊第二块代码

01:27:48.540 --> 01:27:49.240
暂停过来

01:27:57.450 --> 01:27:57.950
ok

01:27:59.050 --> 01:28:00.150
那么剩下的事情

01:28:00.650 --> 01:28:01.350
就是

01:28:01.750 --> 01:28:04.350
当我这个属性被读取的时候

01:28:07.500 --> 01:28:08.300
我干嘛呢

01:28:09.000 --> 01:28:09.700
我Track

01:28:10.100 --> 01:28:10.800
跟踪

01:28:11.000 --> 01:28:11.500
talking

01:28:11.700 --> 01:28:12.200
t

01:28:13.100 --> 01:28:15.300
当我属性被设置的时候

01:28:16.500 --> 01:28:17.400
我Trigger

01:28:18.000 --> 01:28:19.300
talking t

01:28:19.800 --> 01:28:20.300
对吧

01:28:20.400 --> 01:28:21.500
那这里边还可以

01:28:21.500 --> 01:28:22.900
还可以做得更细一点啊

01:28:22.900 --> 01:28:26.100
只有属性只跟之前不一样的时候啊

01:28:26.300 --> 01:28:27.800
我才去做这件事情啊

01:28:27.800 --> 01:28:28.900
还可以去判断一下

01:28:28.900 --> 01:28:29.800
我这里拿得弄吗

01:28:33.310 --> 01:28:35.010
那么看一下最后的效果

01:28:40.300 --> 01:28:43.200
啊这里被用到了什么Name Province City

01:28:43.200 --> 01:28:45.900
那么Name和Promise City改变的时候呢

01:28:47.820 --> 01:28:49.220
他们都会相应的变化

01:28:49.220 --> 01:28:50.420
但是A级变化了

01:28:50.420 --> 01:28:51.820
他就不会有通知

01:28:52.420 --> 01:28:52.820
你看

01:28:53.620 --> 01:28:54.820
一开始运行了一遍

01:28:55.320 --> 01:28:56.320
Name改变了

01:28:57.620 --> 01:28:58.720
Promise改变了

01:28:58.920 --> 01:28:59.720
City改变了

01:28:59.720 --> 01:29:00.720
他都会受到通知

01:29:00.820 --> 01:29:01.920
但是A级不会

01:29:02.620 --> 01:29:03.020
对吧

01:29:04.320 --> 01:29:06.720
好那么我们来试一下新增属性行不行

01:29:07.020 --> 01:29:07.920
新增属性

01:29:08.120 --> 01:29:09.520
现在一开始没有A级

01:29:09.720 --> 01:29:11.120
但是这里被用到了A级

01:29:13.090 --> 01:29:13.690
A级

01:29:14.990 --> 01:29:16.190
State A级

01:29:17.490 --> 01:29:18.490
对吧一开始没有A级

01:29:18.490 --> 01:29:19.390
现在用到了A级

01:29:19.590 --> 01:29:21.190
那么后面再把A级给加上

01:29:21.290 --> 01:29:22.890
看一下会不会发生什么事

01:29:24.390 --> 01:29:24.890
然后可以

01:29:25.690 --> 01:29:26.390
所以也可以

01:29:26.990 --> 01:29:27.890
也能受到通知

01:29:27.990 --> 01:29:29.890
那么我们把A级三除看行不行

01:29:32.920 --> 01:29:33.520
A级

01:29:35.320 --> 01:29:36.620
不好意思三除不行

01:29:36.820 --> 01:29:38.920
因为三除你还要加个配置

01:29:40.520 --> 01:29:41.820
除了Gate Set之外啊

01:29:42.120 --> 01:29:44.120
我们的代理科就代理那个

01:29:44.320 --> 01:29:45.720
好像是一个张结果当时

01:29:46.320 --> 01:29:48.220
还有这种配置啊叫Demaze Property

01:29:48.920 --> 01:29:51.020
同样道理他可以传一个他可以传个屁

01:29:51.220 --> 01:29:52.320
当三除有属性的时候

01:29:52.320 --> 01:29:53.420
他会运行这个函数

01:29:53.920 --> 01:29:54.820
那里就三除

01:29:55.520 --> 01:29:58.060
三除他会传去

01:29:58.160 --> 01:29:59.060
那三除就完事了

01:29:59.360 --> 01:30:00.260
然后再缺个

01:30:01.060 --> 01:30:01.460
他会

01:30:03.740 --> 01:30:04.140
对吧

01:30:04.340 --> 01:30:05.440
你把这个一写上就完事了

01:30:05.440 --> 01:30:05.840
对吧

01:30:06.440 --> 01:30:07.840
三除属性他也要触发

01:30:08.740 --> 01:30:10.340
那么现在我们看三除属性

01:30:11.240 --> 01:30:12.140
也可以触发

01:30:12.340 --> 01:30:12.540
对吧

01:30:12.540 --> 01:30:13.240
这就是为什么

01:30:13.440 --> 01:30:15.540
ViuSan你看不到什么现实方法了

01:30:15.740 --> 01:30:16.640
你看不到这个

01:30:17.040 --> 01:30:17.940
看不到这个玩意了

01:30:18.340 --> 01:30:19.140
他给你去了

01:30:19.640 --> 01:30:20.340
不需要了

01:30:23.560 --> 01:30:23.860
好了

01:30:23.860 --> 01:30:25.160
今天我们的东西就讲完了

