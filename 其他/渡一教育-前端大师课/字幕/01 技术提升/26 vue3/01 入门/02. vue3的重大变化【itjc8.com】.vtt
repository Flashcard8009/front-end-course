WEBVTT

00:00.300 --> 00:04.300
这些可能咱们先不着急来做这个案例

00:04.300 --> 00:06.800
因为做这个案例里边呢

00:06.800 --> 00:10.300
它会用到一些5u3的新的知识

00:10.300 --> 00:12.300
这些重大变化呀

00:12.300 --> 00:13.800
你不知道的话

00:13.800 --> 00:15.800
你是写这个案例的时候呢

00:15.800 --> 00:18.300
很多代码你不理解它是什么意思

00:18.300 --> 00:19.800
写代码的时候是懵的

00:19.800 --> 00:23.300
所以说呢我们先把这个5u3的极电重大变化

00:23.300 --> 00:24.800
先给大家讲一讲

00:24.800 --> 00:26.800
第一个重大变化是在这

00:26.800 --> 00:29.300
在上一节后咱们搭建工程的时候

00:29.300 --> 00:31.300
不知道大家有没有留意到啊

00:31.300 --> 00:35.800
我们的启动这个入口文件这里

00:35.800 --> 00:37.800
你会发现它这个地方呢

00:37.800 --> 00:39.800
跟那个5u2是有点区别的

00:39.800 --> 00:42.800
我这里关注还是先开个工程说吧

00:42.800 --> 00:44.800
先开个工程啊

00:44.800 --> 00:47.800
还是使用VIT app

00:47.800 --> 00:54.180
咱们这个项目呢就叫做to do mvc

00:54.180 --> 00:56.180
实际上求名字

00:56.180 --> 00:58.180
然后呢进入这个目录

00:58.180 --> 01:02.620
to do mvc

01:02.620 --> 01:04.620
安装一下依赖

01:04.620 --> 01:08.440
把这个就删掉了

01:08.440 --> 01:09.440
这个地方啊

01:09.440 --> 01:13.440
好咱们来看一下这个Madele介绍

01:13.440 --> 01:16.440
大家回忆一下过去5u2是怎么做的

01:16.440 --> 01:17.440
5u2

01:17.440 --> 01:19.440
5u2是不是这样子写的

01:19.440 --> 01:20.440
6一个5u

01:20.440 --> 01:21.440
一个构造函数

01:21.440 --> 01:23.440
然后呢这里边去写什么

01:23.440 --> 01:26.440
写配置对吧写Obsins配置

01:26.440 --> 01:28.440
然后呢把它保存到

01:28.440 --> 01:30.440
可以保存到一个变量里边

01:30.440 --> 01:33.440
然后呢变量里边用什么Dollar mount

01:33.440 --> 01:36.440
然后呢挂载到一面弄到一个元素里面去

01:36.440 --> 01:38.440
对吧当然了5u2里面的还可以

01:38.440 --> 01:40.440
它一般是这样子写的

01:40.440 --> 01:42.440
是一样的意思

01:42.440 --> 01:45.440
那么在5u3里面的会出现一点差异

01:45.440 --> 01:48.440
5u3里面这个构造函数没了

01:48.440 --> 01:50.440
构造函数没了

01:50.440 --> 01:51.440
5u3

01:51.440 --> 01:53.440
下面是5u3的写卡

01:53.440 --> 01:55.440
5u3的时候呢它就

01:55.440 --> 01:58.440
不存在构造函数

01:58.440 --> 02:00.440
没有了它没这个东西了

02:00.440 --> 02:02.440
也就是说在5u3里面的你要导入

02:02.440 --> 02:04.440
从5u里面导入一个构造函数

02:04.440 --> 02:06.440
不好意思没有

02:06.440 --> 02:08.440
不用紧我们试一下吧

02:08.440 --> 02:10.440
这里输出一下

02:10.440 --> 02:11.440
没有

02:11.440 --> 02:13.440
你们以后面试的时候呢

02:13.440 --> 02:16.440
会问到很多关于5u2和5u3的区别

02:16.440 --> 02:18.440
其实都是去启动一个点

02:18.440 --> 02:20.440
好咱们来看一下

02:20.440 --> 02:24.720
启动起来npm的装垫

02:24.720 --> 02:26.720
进行啊

02:26.720 --> 02:28.720
检查

02:29.720 --> 02:30.720
看一下

02:30.720 --> 02:31.720
打印了是

02:31.720 --> 02:32.720
它告诉你

02:32.720 --> 02:34.720
这个模块呢就这个模块

02:34.720 --> 02:36.720
它导出的结果中呢

02:36.720 --> 02:38.720
没有一个默认导出

02:38.720 --> 02:40.720
没有一个default导出

02:40.720 --> 02:41.720
所以说呢在5u3里面

02:41.720 --> 02:43.720
不存在这种写法了啊

02:43.720 --> 02:45.720
那么这就会给我们带来一些改变

02:45.720 --> 02:47.720
首先第一个问题就是

02:47.720 --> 02:49.720
它没有5u的构造函数了

02:49.720 --> 02:51.720
那我怎么来创建一个5u应用呢

02:51.720 --> 02:53.720
那么它的创建方式呢

02:53.720 --> 02:55.720
它是使用一个居民导出

02:55.720 --> 02:57.720
叫做createApp

02:57.720 --> 02:59.720
它是创建一个应用

02:59.720 --> 03:01.720
那么像这种变化呀

03:01.720 --> 03:03.720
它叫做

03:03.720 --> 03:05.720
我都不知道怎么翻译啊

03:05.720 --> 03:07.720
看一下这个单词

03:07.720 --> 03:09.720
它叫做breaking

03:09.720 --> 03:11.720
breaking式的

03:11.720 --> 03:13.720
就是截断式的

03:13.720 --> 03:15.720
什么叫截断式的变化呢

03:15.720 --> 03:16.720
就它不兼容

03:16.720 --> 03:17.720
以前能用的代码

03:17.720 --> 03:18.720
到了5u3升级过后

03:18.720 --> 03:19.720
它就不能用了

03:19.720 --> 03:21.720
这叫截断式的更新

03:21.720 --> 03:23.720
那么这就是一个截断式的更新

03:23.720 --> 03:25.720
以前的5u各种函数不存在了

03:25.720 --> 03:27.720
你必须要通过这个函数

03:27.720 --> 03:28.720
叫做createApp

03:28.720 --> 03:30.720
来创建一个5u应用

03:30.720 --> 03:32.720
那么这个东西会返回什么呢

03:32.720 --> 03:33.720
当然这里边传的是啥

03:33.720 --> 03:35.720
传到我们通常会传一个跟逐键

03:35.720 --> 03:37.720
你看这个是不是跟逐键

03:37.720 --> 03:39.720
我们把跟逐键传进去

03:39.720 --> 03:42.720
它会给我们返回一个5u实力

03:42.720 --> 03:43.720
5u应用

03:43.720 --> 03:45.720
我们可以用变量接受一下

03:45.720 --> 03:46.720
来看一下5u应用

03:46.720 --> 03:47.720
好,爆出

03:47.720 --> 03:49.720
这边,小心一下

03:49.720 --> 03:52.720
你看,这是不是得到一个对象了

03:52.720 --> 03:53.720
那么这个对象呢

03:53.720 --> 03:55.720
这个对象跟以前的

03:55.720 --> 03:58.720
通过一个5u勾造函数创建的对象

03:58.720 --> 04:00.720
它就不一样

04:00.720 --> 04:02.720
以前我们通过勾造函数创建的

04:02.720 --> 04:03.720
是不是有点类似于

04:03.720 --> 04:05.720
组建实力

04:05.720 --> 04:06.720
它里边有各种各样的东西

04:06.720 --> 04:08.720
好多都是有多的开头

04:08.720 --> 04:11.720
好多也还有以下滑线开头的

04:11.720 --> 04:13.720
那么现在这个东西不是了

04:13.720 --> 04:15.720
它是一个非常纯净的

04:15.720 --> 04:17.720
一个5u实力对象

04:17.720 --> 04:19.720
一个5u应用对象

04:19.720 --> 04:21.720
那么这个5u应用对象里面

04:21.720 --> 04:22.720
有提供的必须

04:22.720 --> 04:24.720
我们就是要用到的方法

04:24.720 --> 04:25.720
那些不太会用到的方法

04:25.720 --> 04:27.720
它就没有给你提供了

04:27.720 --> 04:28.720
它就没有给你提供了

04:28.720 --> 04:30.720
给你去掉了

04:30.720 --> 04:31.720
那包括哪些方法呢

04:31.720 --> 04:33.720
包括我们这里要用到的mult方法

04:35.720 --> 04:36.720
mult

04:36.720 --> 04:40.720
那么把它挂载到id为f的元素里面去

04:40.720 --> 04:41.720
对吧

04:41.720 --> 04:42.720
可以完成一样的事情

04:42.720 --> 04:43.720
好,保存

04:43.720 --> 04:44.720
你看一下

04:44.720 --> 04:45.720
这里出来了

04:45.720 --> 04:47.720
所以说我们在5u3里面

04:47.720 --> 04:48.720
所以这里有区别

04:48.720 --> 04:49.720
那么如果说

04:49.720 --> 04:52.720
我们要使用像以前5u2的样子

04:52.720 --> 04:54.720
要使用一个插件呢

04:54.720 --> 04:57.720
你看5u2里面是怎么去使用插件的

04:57.720 --> 04:58.720
是不是这样子使用的

04:58.720 --> 05:01.720
这里使用app

05:01.720 --> 05:04.720
使用view

05:04.720 --> 05:05.720
对不对

05:05.720 --> 05:06.720
所以在这里使用插件

05:06.720 --> 05:07.720
那么这边呢

05:07.720 --> 05:08.720
我们使用插件的

05:08.720 --> 05:10.720
就不再是通过构造函数了

05:10.720 --> 05:11.720
因为它没有构造函数了

05:11.720 --> 05:13.720
自然没有构造函数里面的

05:13.720 --> 05:14.720
这些乱七八糟的成员了

05:14.720 --> 05:15.720
那怎么办呢

05:15.720 --> 05:17.720
我们要通过这个实力成员

05:17.720 --> 05:19.720
实力对象

05:19.720 --> 05:21.720
通过它去使用优势

05:21.720 --> 05:22.720
来应用一个插件

05:22.720 --> 05:23.720
原来的意思吧

05:23.720 --> 05:25.720
这里边是有一些细微的差别的

05:25.720 --> 05:27.720
那么这些细微的差别呢

05:27.720 --> 05:29.720
我们在后面就业的时候呢

05:29.720 --> 05:30.720
就业阶段的时候呢

05:30.720 --> 05:31.720
再慢慢的去讲

05:31.720 --> 05:33.720
下个节奏就慢慢讲

05:33.720 --> 05:34.720
好,OK

05:34.720 --> 05:36.720
这是关于第1个变化

05:36.720 --> 05:37.720
就是构造函数没了

05:37.720 --> 05:38.720
然后呢

05:38.720 --> 05:39.720
给变成了一个crazy app函数

05:39.720 --> 05:40.720
那么它这里写的

05:40.720 --> 05:42.720
它这种写法就是几年写了

05:42.720 --> 05:43.720
对吧

05:43.720 --> 05:44.720
通过表达式

05:44.720 --> 05:46.720
创建一个5u应用

05:46.720 --> 05:47.720
然后呢

05:47.720 --> 05:48.720
通过这个应用里面的一个函数

05:48.720 --> 05:49.720
mount

05:49.720 --> 05:51.720
挂载到某一个元素里面去

05:51.720 --> 05:54.720
OK,这是第1个问题啊

05:54.720 --> 05:55.720
好,第2个

05:55.720 --> 05:58.720
咱们要生入到组件里面去看

05:58.720 --> 06:00.720
当然这个东西跟vis没关系

06:00.720 --> 06:01.720
你看上节课

06:01.720 --> 06:04.720
无论是vis还是5u cd

06:04.720 --> 06:05.720
它里面

06:05.720 --> 06:06.720
启动函数里面都是这样写的

06:06.720 --> 06:08.720
对吧,它是5u里面的功能

06:08.720 --> 06:10.720
vis只是个销售价

06:10.720 --> 06:14.720
好,咱们再生入到组件里面去

06:14.720 --> 06:16.720
看一下它下一个综合区别

06:16.720 --> 06:20.160
我们把这个区别

06:20.160 --> 06:23.160
这边我写一个

06:23.160 --> 06:24.160
写个什么?

06:24.160 --> 06:26.160
写个许愿数

06:26.160 --> 06:30.160
然后这边我们读一个数据cod

06:30.160 --> 06:31.160
那么这里的写法呢

06:31.160 --> 06:33.160
就是在5u3里面

06:33.160 --> 06:35.160
它大部分的还是兼容

06:35.160 --> 06:36.160
以前5u2的写法

06:36.160 --> 06:38.160
就是使用配置的方式

06:38.160 --> 06:40.160
来进行书写

06:40.160 --> 06:41.160
那么这里也是一样

06:41.160 --> 06:42.160
使用一个配置

06:42.160 --> 06:43.160
来得到一个data

06:43.160 --> 06:45.160
那么这里可以用这种方式来写

06:45.160 --> 06:47.160
也可以用这种方式来写

06:47.160 --> 06:49.160
对吧,都行

06:49.160 --> 06:51.160
返回个对象

06:51.160 --> 06:52.160
那么对象里面

06:52.160 --> 06:54.160
我们比方说给它一个cod

06:54.160 --> 06:57.160
5u2也可以这样写

06:57.160 --> 06:59.160
那么这没问题

06:59.160 --> 07:01.160
然后我们比方说

07:01.160 --> 07:03.160
这里下边还有个按钮

07:07.160 --> 07:09.160
或者我们就直接把它放到按钮里面

07:10.160 --> 07:15.160
然后点一下这个按钮

07:15.160 --> 07:17.160
它数字就往上加

07:17.160 --> 07:18.160
我们要做这么一个效果

07:18.160 --> 07:20.160
点一下它的数字往上加

07:20.160 --> 07:22.160
我们这里给它做这个事件

07:22.160 --> 07:23.160
click

07:23.160 --> 07:25.160
那么这边我们去引用一个方法

07:30.160 --> 07:31.160
非常简单的

07:33.160 --> 07:34.160
你看一下

07:34.160 --> 07:36.160
它能不能支持过去的这种写法

07:40.160 --> 07:41.160
没问题吧

07:41.160 --> 07:42.160
对吧,一样的

07:43.160 --> 07:45.160
那么我这里要说啥呢

07:45.160 --> 07:47.160
我们如果说在方法里面

07:47.160 --> 07:49.160
因为我们知道在以前5u2里面

07:49.160 --> 07:51.160
无论是在方法呀

07:51.160 --> 07:53.160
还是在computed呀

07:53.160 --> 07:55.160
总之在里面各种配置里面

07:55.160 --> 07:57.160
它会设计到一个东西叫z

07:57.160 --> 07:58.160
对不对

07:58.160 --> 08:00.160
那么z的指向

08:00.160 --> 08:01.160
还记得吗

08:01.160 --> 08:03.160
在5u2的时候是指向谁啊

08:03.160 --> 08:06.160
是不是指向整个组建实力

08:06.160 --> 08:07.160
对不对

08:07.160 --> 08:09.160
就指向整个的组建实力

08:09.160 --> 08:10.160
那么组建实力里面

08:10.160 --> 08:11.160
它把它提去

08:11.160 --> 08:12.160
像cult

08:12.160 --> 08:14.160
返回了这个属性啊

08:14.160 --> 08:15.160
data啊

08:15.160 --> 08:17.160
它都会提取到这个实力里面去

08:17.160 --> 08:19.160
把它变成享用式的

08:19.160 --> 08:20.160
那么在5u3里面

08:20.160 --> 08:21.160
这个z是指向谁呢

08:21.160 --> 08:23.160
看上去好像还是指向的是

08:23.160 --> 08:25.160
组建实力对吧

08:25.160 --> 08:26.160
那我们来输出一下

08:26.160 --> 08:28.160
在5u3里面去输出一下这个z

08:28.160 --> 08:29.160
我相信呢

08:29.160 --> 08:31.160
大家在学习5u2的时候

08:31.160 --> 08:33.160
应该每个同学都会去

08:33.160 --> 08:35.160
应该都做过这么一件事

08:35.160 --> 08:37.160
去输出这么一个z

08:37.160 --> 08:38.160
你看一下这个5u2里面

08:38.160 --> 08:39.160
输出的z啊

08:39.160 --> 08:41.160
它是不是一个

08:41.160 --> 08:42.160
比较纯粹的一个对象啊

08:42.160 --> 08:44.160
一个普通的对象

08:44.160 --> 08:45.160
对不对

08:45.160 --> 08:46.160
对象里面你会看到

08:46.160 --> 08:48.160
有这个cult属性

08:48.160 --> 08:49.160
还会看到一些乱七八糟的

08:49.160 --> 08:50.160
其他东西

08:50.160 --> 08:51.160
dolar开头的

08:51.160 --> 08:52.160
对吧

08:52.160 --> 08:53.160
我们不是经常用这个吧

08:53.160 --> 08:54.160
z是dolar ambit

08:54.160 --> 08:55.160
对不对

08:55.160 --> 08:56.160
以dolar开头的

08:56.160 --> 08:57.160
以下环线开头的

08:57.160 --> 08:58.160
会看到很多属性

08:58.160 --> 08:59.160
那么我们看一下

08:59.160 --> 09:00.160
5u3里面

09:00.160 --> 09:01.160
输出这个z啊

09:01.160 --> 09:03.160
它会输出什么环

09:04.160 --> 09:05.160
上键

09:06.160 --> 09:07.160
点一下

09:07.160 --> 09:09.160
看看这个z是会输出啥呀

09:10.160 --> 09:11.160
你会发现

09:11.160 --> 09:13.160
它输出的是个什么玩意呢

09:13.160 --> 09:15.160
它输出的是一个

09:16.160 --> 09:17.160
proxy

09:17.160 --> 09:19.160
这个玩意里面应该学过啊

09:19.160 --> 09:21.160
是在es6课程里面

09:21.160 --> 09:23.160
是不是有一个proxy

09:23.160 --> 09:25.160
也就是说在5u3里面啊

09:25.160 --> 09:26.160
它的z啊

09:26.160 --> 09:28.160
指向的是一个代理

09:28.160 --> 09:29.160
那么代理的谁呢

09:29.160 --> 09:31.160
你看一下这个proxy的talkage

09:31.160 --> 09:32.160
代理的对象

09:33.160 --> 09:34.160
它代理的对象

09:34.160 --> 09:36.160
说有点像我们以前那个东西的

09:36.160 --> 09:37.160
对吧

09:37.160 --> 09:39.160
是不是有点像以前那个组建的

09:39.160 --> 09:40.160
组建实力的

09:40.160 --> 09:42.160
也就是说在5u3跟5u2呢

09:42.160 --> 09:43.160
它出现这么一个区别

09:43.160 --> 09:44.160
大家看课间里面

09:44.160 --> 09:47.750
有一张图

09:47.750 --> 09:49.750
5u2是什么情况呢

09:49.750 --> 09:50.750
一个z呢

09:50.750 --> 09:51.750
直接指向的是5u10

09:52.750 --> 09:53.750
当你通过这个实力

09:53.750 --> 09:55.750
去访问一个属性的时候

09:55.750 --> 09:56.750
那么它就直接得到

09:56.750 --> 09:57.750
这个实力的属性

09:57.750 --> 09:58.750
对吧

09:58.750 --> 09:59.750
因为这个实力上有这个属性

09:59.750 --> 10:00.750
比方说靠着

10:00.750 --> 10:01.750
它有这个属性

10:01.750 --> 10:02.750
对不对

10:02.750 --> 10:03.750
在5u3里面呢

10:03.750 --> 10:04.750
它还掏了一层代理

10:05.750 --> 10:06.750
你访问的z呢

10:06.750 --> 10:07.750
实际上是个代理对象

10:08.750 --> 10:09.750
当你去访问

10:09.750 --> 10:10.750
某个属性的时候

10:10.750 --> 10:11.750
代理对象是不是很能够

10:11.750 --> 10:12.750
收到这个通知

10:12.750 --> 10:13.750
对不对

10:13.750 --> 10:14.750
它做了什么事呢

10:14.750 --> 10:15.750
很多时候呢

10:15.750 --> 10:17.750
它只是简单的做到这么一个处理

10:17.750 --> 10:18.750
然后呢

10:18.750 --> 10:19.750
它就去你访问某个属性

10:19.750 --> 10:20.750
比方说你访问的scot

10:21.750 --> 10:22.750
那么它就把这个通知呢

10:22.750 --> 10:24.750
发到这个组建实力里边去

10:24.750 --> 10:25.750
它内部还是有个组建实力

10:26.750 --> 10:27.750
然后那个组建实力

10:27.750 --> 10:28.750
是不是返回一个属性值

10:28.750 --> 10:29.750
然后代理对象呢

10:29.750 --> 10:30.750
它就把个属性值

10:30.750 --> 10:31.750
返回给调用者

10:31.750 --> 10:33.750
因此呢在5u3里边呢

10:33.750 --> 10:35.750
虽然和z的指向不一样了

10:35.750 --> 10:37.750
它指向的是一个代理对象

10:38.750 --> 10:39.750
但是呢

10:39.750 --> 10:40.750
我们仍然可以使用

10:40.750 --> 10:42.750
像以前的那种做法一样

10:42.750 --> 10:43.750
那么这个是不是

10:43.750 --> 10:45.750
读取代理对象的cot

10:45.750 --> 10:46.750
对不对

10:46.750 --> 10:47.750
那么代理对象呢

10:47.750 --> 10:48.750
它就会发送给

10:48.750 --> 10:49.750
组建实力

10:49.750 --> 10:50.750
组建实力呢

10:50.750 --> 10:51.750
返回这个属性值

10:51.750 --> 10:52.750
代理对象就给我们谈会

10:52.750 --> 10:53.750
所以我们这里仍然可以

10:53.750 --> 10:54.750
得到cot值

10:54.750 --> 10:55.750
也是没问题的

10:56.750 --> 10:57.750
那么它为什么要

10:57.750 --> 10:58.750
做这么一层处理呢

10:58.750 --> 11:00.750
有很多原因

11:00.750 --> 11:01.750
那么其中一个原因呢

11:01.750 --> 11:03.750
我们一会儿就会讲到

11:03.750 --> 11:04.750
好了这是第二个区别

11:04.750 --> 11:06.750
它z不一样

11:07.750 --> 11:09.750
看上去的还是跟过去一样的

11:09.750 --> 11:10.750
那么过去的很多

11:10.750 --> 11:12.750
z里边的用法都可以在这里用

11:12.750 --> 11:16.830
第三个区别

11:17.830 --> 11:18.830
哎呦

11:18.830 --> 11:19.830
这第三个区别变化

11:19.830 --> 11:21.830
就非常非常大了

11:21.830 --> 11:23.830
就是我们

11:23.830 --> 11:26.830
接下来要重点讲的

11:26.830 --> 11:28.830
comparation API

11:28.830 --> 11:30.830
这个东西

11:31.830 --> 11:33.830
comparation API

11:33.830 --> 11:34.830
怎么翻译呢

11:34.830 --> 11:36.830
这个东西叫做组合

11:36.830 --> 11:38.830
可以把它翻译成组合 API

11:38.830 --> 11:40.830
啥意思呢

11:40.830 --> 11:42.830
跟comparation API对应的呢

11:42.830 --> 11:43.830
是过去的这种写法

11:43.830 --> 11:45.830
像这种配置式的

11:45.830 --> 11:46.830
你看

11:46.830 --> 11:47.830
配置一个data

11:47.830 --> 11:48.830
配置一个message

11:48.830 --> 11:50.830
还可以配置什么probs

11:50.830 --> 11:51.830
对吧

11:51.830 --> 11:52.830
还可以配置什么

11:52.830 --> 11:54.830
配置computed

11:54.830 --> 11:56.830
配置式的

11:56.830 --> 11:57.830
配置式的APN

11:57.830 --> 11:58.830
是我们非常熟悉的

11:59.830 --> 12:00.830
那么这样的APN

12:00.830 --> 12:01.830
有什么问题呢

12:01.830 --> 12:02.830
我们把它叫做

12:02.830 --> 12:03.830
首先我们把它叫做

12:03.830 --> 12:04.830
option API

12:05.830 --> 12:06.830
你看我们案例里边

12:06.830 --> 12:08.830
所以一个option API

12:08.830 --> 12:09.830
一个comparation API

12:09.830 --> 12:10.830
对吧

12:10.830 --> 12:11.830
我把同样的一个效果

12:11.830 --> 12:13.830
用两种不同的方式

12:13.830 --> 12:14.830
给大家写出来

12:14.830 --> 12:16.830
大家可以直观的感受一下

12:17.830 --> 12:18.830
使用option API

12:18.830 --> 12:20.830
会有一个什么样的问题呢

12:21.830 --> 12:23.830
如果说组件很简单

12:23.830 --> 12:24.830
像这种简单组件

12:24.830 --> 12:25.830
没有啥问题

12:25.830 --> 12:26.830
挺好的对吧

12:26.830 --> 12:27.830
看了也非常清楚

12:27.830 --> 12:28.830
又好阅读

12:28.830 --> 12:29.830
又好编辑

12:30.830 --> 12:31.830
但是组件一旦

12:31.830 --> 12:33.830
比较复杂了

12:33.830 --> 12:34.830
如果说一个

12:34.830 --> 12:35.830
一不可能说

12:35.830 --> 12:36.830
每个组件都只有这么点代

12:36.830 --> 12:37.830
有些一个组件里边

12:37.830 --> 12:38.830
可能涉及到

12:38.830 --> 12:39.830
上百行代

12:39.830 --> 12:40.830
几百行代

12:41.830 --> 12:42.830
那么组件

12:42.830 --> 12:44.830
变得越来越复杂的时候

12:44.830 --> 12:45.830
我们的组件里边

12:45.830 --> 12:46.830
就会发生一个

12:46.830 --> 12:47.830
很恶心的变化

12:48.830 --> 12:49.830
大家看一下

12:49.830 --> 12:50.830
我这里写了个

12:50.830 --> 12:52.830
todo mvc的效果

12:52.830 --> 12:53.830
这里边

12:53.830 --> 12:55.830
我就是用comparation API写的

12:55.830 --> 12:56.830
这里边

12:56.830 --> 12:57.830
只有一个组件

12:57.830 --> 12:58.830
就是根组件

12:58.830 --> 12:59.830
为了让更好的

12:59.830 --> 13:01.830
让大家看到这个情况了

13:01.830 --> 13:03.830
我这里没有去划分组件

13:03.830 --> 13:04.830
其实也可以不用划分

13:04.830 --> 13:05.830
因为整个

13:05.830 --> 13:07.830
整个功能联系的非常紧密

13:07.830 --> 13:09.830
我就把它作为一个组件

13:09.830 --> 13:11.830
那么在一个组件里边

13:11.830 --> 13:12.830
大家看一下

13:12.830 --> 13:14.830
这就有点恐怖了

13:14.830 --> 13:16.830
他不是说代码多了恐怖

13:16.830 --> 13:17.830
模板我们不看

13:17.830 --> 13:19.830
模板跟他没关系

13:19.830 --> 13:21.830
我们就看这个介石这一部分

13:21.830 --> 13:22.830
你看

13:22.830 --> 13:23.830
大家看一下

13:23.830 --> 13:25.830
这一行是在做什么

13:25.830 --> 13:28.830
是在得到一个todo是列表

13:28.830 --> 13:30.830
当前的要完成的任务

13:30.830 --> 13:33.830
这个东西是为一个文本框准备的

13:33.830 --> 13:35.830
文本框里边要用vmode

13:35.830 --> 13:38.830
来绑定新输入的新的任务

13:38.830 --> 13:39.830
文本

13:39.830 --> 13:42.830
它是为新任务做准备的

13:42.830 --> 13:44.830
那么这个地方

13:44.830 --> 13:47.830
是为修改任务做准备的

13:47.830 --> 13:48.830
那么这个玩意

13:48.830 --> 13:50.830
是为查询任务做准备的

13:50.830 --> 13:52.830
然后我们再往下看

13:52.830 --> 13:53.830
watch

13:53.830 --> 13:55.830
当这个todo是发生变化的时候

13:55.830 --> 13:58.830
我要把它保存起来

13:58.830 --> 14:01.830
比方说我把往这个输足里边

14:01.830 --> 14:02.830
增加一个任务

14:02.830 --> 14:03.830
我要把它保存起来

14:03.830 --> 14:05.830
大概就这么个意思

14:05.830 --> 14:06.830
大家可以看一下这个代码

14:06.830 --> 14:07.830
大概看一下

14:07.830 --> 14:09.830
你不用去细看

14:09.830 --> 14:11.830
你会发现

14:11.830 --> 14:13.830
整个组件里面的代码

14:13.830 --> 14:15.830
是比较淋散的

14:15.830 --> 14:17.830
什么叫淋散的

14:17.830 --> 14:20.830
就是说我新增一个任务的功能

14:20.830 --> 14:23.830
它分布到这个配置

14:23.830 --> 14:26.830
分布到这个配置

14:26.830 --> 14:27.830
新增任务

14:27.830 --> 14:30.830
它分布到不同的配置里面

14:30.830 --> 14:33.830
而我们修改一个任务的东西

14:33.830 --> 14:35.830
它又分配到不同的配置里面

14:35.830 --> 14:37.830
data里面

14:37.830 --> 14:41.830
还包括修改

14:41.830 --> 14:42.830
这个

14:42.830 --> 14:43.830
看到没有

14:43.830 --> 14:44.830
又分到这了

14:44.830 --> 14:45.830
这个大家好

14:45.830 --> 14:48.830
好像还不是看得很直观

14:48.830 --> 14:51.830
那么这里我用了一张图

14:51.830 --> 14:53.830
叫Option API

14:53.830 --> 14:54.830
这个JPG

14:54.830 --> 14:59.120
给大家看一下

14:59.120 --> 15:01.120
这个图你不用去看

15:01.120 --> 15:02.120
不要看不清楚

15:02.120 --> 15:04.120
你不用看清楚

15:04.120 --> 15:06.120
你就看它里面的颜色

15:06.120 --> 15:08.120
我用颜色给它标好了

15:08.120 --> 15:10.120
红色表示的是

15:10.120 --> 15:13.120
跟任务列表相关的

15:13.120 --> 15:14.120
你看是不是分配

15:14.120 --> 15:16.120
分到了不同的配置里面去了

15:16.120 --> 15:18.120
分散的

15:18.120 --> 15:19.120
那么这个绿色

15:19.120 --> 15:21.120
表示是跟新增任务相关的

15:21.120 --> 15:23.120
你看是不是分配到

15:23.120 --> 15:25.120
分到不同的配置里面去了

15:25.120 --> 15:27.120
那么这个纸色

15:27.120 --> 15:28.120
应该叫纸色

15:28.120 --> 15:31.120
纸色是修改任务相关的

15:31.120 --> 15:33.120
是不是在不同的配置里面

15:33.120 --> 15:35.120
这个我也不知道它颜色了

15:35.120 --> 15:37.120
是跟那个查询任务

15:37.120 --> 15:39.120
筛选任务相关的

15:39.120 --> 15:41.120
那么你看分到不同的配置里面

15:41.120 --> 15:43.120
还有生命周期的函数

15:43.120 --> 15:44.120
是不是

15:44.120 --> 15:47.120
它以前的一天代码是这个样子的

15:47.120 --> 15:49.120
那么这样子代码

15:49.120 --> 15:52.120
复杂组建里面经常会出现

15:52.120 --> 15:54.120
这就是为什么

15:54.120 --> 15:57.120
唯有一旦开发复杂应用

15:57.120 --> 16:00.120
大型的项目就显得有点吃力

16:00.120 --> 16:01.120
它不好分

16:01.120 --> 16:03.120
它一个大的项目里面

16:03.120 --> 16:05.120
有很多这种复杂组建

16:05.120 --> 16:07.120
那么这种复杂组建里面

16:07.120 --> 16:09.120
它就会经常导致这个问题

16:09.120 --> 16:10.120
维护起来

16:10.120 --> 16:11.120
阅读起来

16:11.120 --> 16:12.120
极其困难

16:12.120 --> 16:13.120
那些毫不相干的东西

16:13.120 --> 16:15.120
分配到不同的地方去了

16:15.120 --> 16:18.120
这就是Option API的问题

16:18.120 --> 16:20.120
原来的意思吧

16:20.120 --> 16:22.120
那么用了Comparison API

16:22.120 --> 16:24.120
会有一个什么样的效果呢

16:24.120 --> 16:26.120
接下来有另外一张图来看一下

16:26.120 --> 16:28.120
当你使用了Comparison API过后了

16:28.120 --> 16:30.120
它就变成了这边了

16:30.120 --> 16:31.120
这个样子

16:31.120 --> 16:36.720
代码还是那么多代码

16:36.720 --> 16:38.720
单身的它全部把它合并到一起了

16:38.720 --> 16:40.720
以前是不可能做得到的

16:40.720 --> 16:42.720
当然以前倒是有一些方法

16:42.720 --> 16:44.720
比方说用Mixins

16:44.720 --> 16:45.720
混合

16:45.720 --> 16:48.720
但是混合也有一些自己的问题

16:48.720 --> 16:50.720
那么我们就现在在大家看这边

16:50.720 --> 16:52.720
用了Comparison API之后

16:52.720 --> 16:54.720
虽然代码还是那么多

16:54.720 --> 16:56.720
因为有这么多功能

16:56.720 --> 16:58.720
但是它就比较紧凑了

16:58.720 --> 17:00.720
我们把它叫做高内锯

17:00.720 --> 17:02.720
我们软件设计里面不是一个原则吗

17:02.720 --> 17:04.720
Deal和高内锯

17:04.720 --> 17:06.720
那么这就是高内锯

17:06.720 --> 17:08.720
相同的东西聚在一起

17:08.720 --> 17:10.720
那么这是新增的

17:10.720 --> 17:12.720
这是个列表的相关的

17:12.720 --> 17:14.720
这是跟新增相关的

17:14.720 --> 17:16.720
这是跟山储相关的

17:16.720 --> 17:18.720
山选相关的

17:18.720 --> 17:20.720
这是跟修改相关的

17:20.720 --> 17:24.720
这是跟山选相关的

17:24.720 --> 17:26.720
把它合并到一起了

17:26.720 --> 17:28.720
那么这样子维护起来是不是非常方便

17:28.720 --> 17:30.720
更加恐怖的是

17:30.720 --> 17:34.720
它犹豫它聚在一起了

17:34.720 --> 17:36.720
你是不是可以把这一段代码

17:36.720 --> 17:38.720
直接提出去提成一个模块

17:38.720 --> 17:40.720
让这个模块倒出就行了

17:40.720 --> 17:42.720
那么这边只要去雕刻模块里面

17:42.720 --> 17:44.720
提供了函数就可以了

17:44.720 --> 17:46.720
那么这边也是一样

17:46.720 --> 17:48.720
提出去过后这边就变得非常简洁

17:48.720 --> 17:50.720
没啥意思吧

17:50.720 --> 17:52.720
那么这就是Completion API的

17:52.720 --> 17:54.720
它直观上带来的威力

17:54.720 --> 17:56.720
那么在VU3里面

17:56.720 --> 17:58.720
Completion API是一定要学习的

17:58.720 --> 18:00.720
而且是一定是重点

18:00.720 --> 18:02.720
重中之重

18:02.720 --> 18:04.720
那么首先我们这里就开始在认识

18:04.720 --> 18:06.720
Completion API

18:06.720 --> 18:08.720
它到底是一个怎么回事

18:08.720 --> 18:17.440
我们看这个组建

18:17.440 --> 18:19.440
在组建编写的过程中

18:19.440 --> 18:21.440
我们仍然

18:21.440 --> 18:23.440
VU3仍然给我们允许我们使用

18:23.440 --> 18:25.440
VU2的这种方式

18:25.440 --> 18:27.440
就是配置式的Option API

18:27.440 --> 18:29.440
这种方式一般

18:29.440 --> 18:31.440
适用于比较简单的主线

18:31.440 --> 18:33.440
代码不多

18:33.440 --> 18:35.440
而且功能本身就是

18:35.440 --> 18:37.440
只求一个功能

18:37.440 --> 18:39.440
它没有多个功能

18:39.440 --> 18:41.440
不需要去把它用Completion API

18:41.440 --> 18:43.440
聚合起来

18:43.440 --> 18:45.440
那么用配置式仍然没有问题

18:45.440 --> 18:47.440
那如果说遇到功能多了

18:47.440 --> 18:49.440
就用Completion API

18:49.440 --> 18:51.440
不要用于以前那个Mixing

18:51.440 --> 18:54.750
那怎么来用呢

18:54.750 --> 18:56.750
看着

18:56.750 --> 18:58.750
在Completion API里

18:58.750 --> 19:00.750
你倒出了对象里面

19:00.750 --> 19:02.750
你要提供一个函数

19:02.750 --> 19:04.750
叫setup

19:04.750 --> 19:06.750
这个函数它会自动执行

19:06.750 --> 19:08.750
什么时候执行呢

19:08.750 --> 19:10.750
如果说这个组建有属性

19:10.750 --> 19:12.750
当它你在使用这个组建

19:12.750 --> 19:14.750
那么这个组建的属性被复制完成之后

19:14.750 --> 19:16.750
它会立即调用setup函数

19:16.750 --> 19:18.750
也就是这个函数在什么时候调用呢

19:20.750 --> 19:26.750
是在所有生命周期

19:26.750 --> 19:28.750
勾指函数之前调用

19:28.750 --> 19:35.600
所有生命周期函数之前调用

19:35.600 --> 19:37.600
只要属性

19:37.600 --> 19:39.600
这个组建的属性一出也确定完成

19:39.600 --> 19:41.600
但这个属性也没有属性

19:41.600 --> 19:43.600
反正有的话就确定完成

19:43.600 --> 19:45.600
完成之后它就会调用函数

19:45.600 --> 19:47.600
看一下吧

19:47.600 --> 19:52.380
发现

19:52.380 --> 19:54.380
是不是调用函数

19:54.380 --> 19:56.380
而且这是第1个

19:56.380 --> 19:58.380
第2个呢这个函数中的z

19:58.380 --> 20:00.380
是undefined

20:00.380 --> 20:02.380
输出一下z

20:02.380 --> 20:04.380
这里面是不能用z的

20:04.380 --> 20:06.380
你看z是不是undefined

20:10.380 --> 20:12.380
z指向的是undefined

20:12.380 --> 20:14.380
为什么呢

20:14.380 --> 20:16.380
因为它这里面有其更好的方式

20:16.380 --> 20:18.380
来进行处理

20:18.380 --> 20:20.380
不能用z的

20:20.380 --> 20:22.380
也就是说如果说你在setup函数里面

20:22.380 --> 20:24.380
去携带

20:24.380 --> 20:26.380
你是不是能得到这个组建的实力

20:26.380 --> 20:28.380
你至少不能通过z来得到

20:28.380 --> 20:30.380
这个组建的实力

20:30.380 --> 20:32.380
而且我们也很多时候也没有必要

20:32.380 --> 20:34.380
去得到这个组建实力

20:34.380 --> 20:36.380
明白我的意思吗

20:36.380 --> 20:38.380
那么这个setup函数里面写啥呢

20:38.380 --> 20:40.380
注意

20:40.380 --> 20:42.380
这个setup函数它会返回东西

20:42.380 --> 20:44.380
你需要返回东西

20:44.380 --> 20:46.380
你返回的东西

20:46.380 --> 20:48.380
附着在组建实力里面去

20:48.380 --> 20:50.380
就跟那个data属性

20:50.380 --> 20:52.380
我们配置这个data

20:52.380 --> 20:54.380
data返回的东西是不是跑到了

20:54.380 --> 20:56.380
组建实力里面去了

20:56.380 --> 20:58.380
没设置配置这个方法

20:58.380 --> 21:00.380
是不是跑到组建实力里面去了

21:00.380 --> 21:02.380
那么这个setup函数也是一样

21:02.380 --> 21:04.380
你返回到这个对象里面的所有属性

21:04.380 --> 21:06.380
返回的是个对象

21:06.380 --> 21:08.380
对象里面的所有属性都会跑到

21:08.380 --> 21:10.380
组建实力里面去

21:10.380 --> 21:12.380
咱们来比方说看一下

21:12.380 --> 21:14.380
cont

21:14.380 --> 21:16.380
0

21:16.380 --> 21:18.380
然后再

21:18.380 --> 21:20.380
这是个属性嘛对不对

21:20.380 --> 21:22.380
然后我们再返回一个方法吧

21:22.380 --> 21:24.380
方法我们甚至可以写到这

21:24.380 --> 21:26.380
叫increase

21:26.380 --> 21:31.480
increase

21:31.480 --> 21:33.480
我们这里呢

21:33.480 --> 21:38.590
cult定到上面吧

21:38.590 --> 21:40.590
letcult

21:40.590 --> 21:42.590
那么这边呢

21:42.590 --> 21:46.030
cult加加

21:46.030 --> 21:48.030
然后我们这里呢返回这个cult

21:48.030 --> 21:50.030
返回这个increase

21:50.030 --> 21:52.030
那么这两个东西呢

21:52.030 --> 21:54.030
它就会被

21:54.030 --> 21:56.030
附着在组建实力里面去

21:56.030 --> 21:58.030
也就跟之前一样

21:58.030 --> 22:00.030
那么这边呢我们是不是可以得到

22:00.030 --> 22:04.040
cult

22:04.040 --> 22:05.040
那么这边

22:05.040 --> 22:06.040
cult

22:06.040 --> 22:08.040
可以用这个cult

22:08.040 --> 22:10.040
包括我们的

22:10.040 --> 22:12.040
点击的时候呢我们调用increase

22:12.040 --> 22:14.040
为什么可以用这个函数

22:14.040 --> 22:16.040
因为要返回了

22:16.040 --> 22:18.040
不管你返回什么东西

22:18.040 --> 22:20.040
你返回的属性也好

22:20.040 --> 22:22.040
它就会附着在

22:22.040 --> 22:24.040
组建实力里面去

22:24.040 --> 22:26.040
好咱们看一下吧

22:26.040 --> 22:28.040
没爆错吧

22:28.040 --> 22:30.040
0是不是显示出来了

22:30.040 --> 22:32.040
对不对

22:32.040 --> 22:34.040
那么显示出来了0

22:34.040 --> 22:36.040
我们点一下看能不能增加

22:36.040 --> 22:38.040
不能增加

22:38.040 --> 22:40.040
这就奇怪了

22:40.040 --> 22:42.040
那么我们看一下这个函数有没有运行呢

22:42.040 --> 22:44.040
我们输出一下increase

22:44.040 --> 22:46.040
这个函数有没有运行呢

22:46.040 --> 22:48.040
你不是说返回的东西

22:48.040 --> 22:50.040
那么这个函数返回了

22:50.040 --> 22:52.040
那么再调用这个函数

22:52.040 --> 22:54.040
没问题啊对不对

22:54.040 --> 22:57.360
那么这个函数有没有运行呢

22:57.360 --> 22:59.360
是不是运行了这个函数

22:59.360 --> 23:01.360
那问题在哪呢

23:01.360 --> 23:03.360
运行了这个函数

23:03.360 --> 23:05.360
所以这个变量是不是一定增加了

23:05.360 --> 23:07.360
我先问一下这个问题啊

23:07.360 --> 23:09.360
有没有疑问

23:09.360 --> 23:11.360
它运行了这个函数

23:11.360 --> 23:13.360
这个变量的值是不是一定增加了

23:13.360 --> 23:15.360
肯定增加了吧

23:15.360 --> 23:17.360
不可能说这句话运行了

23:17.360 --> 23:19.360
我又还能上天啊

23:19.360 --> 23:21.360
它能截断代码的运行

23:21.360 --> 23:23.360
不可能了对吧

23:23.360 --> 23:25.360
这句话一定是运行了

23:25.360 --> 23:27.360
靠乘值一定增加了

23:27.360 --> 23:29.360
所以你要去学会分析问题

23:29.360 --> 23:31.360
那么现在问题就在于

23:31.360 --> 23:33.360
我这个值增加了

23:33.360 --> 23:35.360
它没有引起

23:35.360 --> 23:37.360
重新渲染

23:37.360 --> 23:39.360
不就是这个问题吗

23:39.360 --> 23:41.360
不就是个破问题吗

23:41.360 --> 23:43.360
说白了是什么意思呢

23:43.360 --> 23:45.360
我的数据不具有响应识

23:45.360 --> 23:47.360
我这个值增加了

23:47.360 --> 23:49.360
我又不知道

23:49.360 --> 23:51.360
对不对

23:51.360 --> 23:53.360
它没有收到通知

23:53.360 --> 23:55.360
那么没有收到通知

23:55.360 --> 23:57.360
它自然没法自行重新渲染

23:57.360 --> 23:59.360
它就是这么个破问题

23:59.360 --> 24:01.360
你看不增加了吗

24:01.360 --> 24:03.360
甚至我还可以输出一下啊

24:03.360 --> 24:05.360
我在这儿吧

24:05.360 --> 24:07.360
我输出一下

24:07.360 --> 24:09.360
原来不在增加吧

24:09.360 --> 24:11.360
它没有重新渲染而已

24:11.360 --> 24:13.360
那么大家想一想

24:13.360 --> 24:17.440
你觉得

24:17.440 --> 24:19.440
如果你自己是五幼的作者

24:19.440 --> 24:21.440
你怎么做这个响应识

24:21.440 --> 24:23.440
它就是一个普通的

24:23.440 --> 24:25.440
不能再普通的变量

24:25.440 --> 24:27.440
而且是个数字

24:27.440 --> 24:29.440
一个普通的变量

24:29.440 --> 24:31.440
你把这个变量的值增加了

24:31.440 --> 24:33.440
五幼能收得到通知吗

24:33.440 --> 24:35.440
它收不到

24:35.440 --> 24:37.440
你看以前五幼二是咋做的

24:37.440 --> 24:39.440
五幼二你是不是说

24:39.440 --> 24:41.440
它配置一个反回一个对象

24:41.440 --> 24:43.440
然后它把对象里面的所有东西

24:43.440 --> 24:45.440
用optic defined property

24:45.440 --> 24:47.440
来完成响应识的

24:47.440 --> 24:49.440
现在的这个地方

24:49.440 --> 24:51.440
要说用的是五幼实力

24:51.440 --> 24:53.440
我还好理解一点

24:53.440 --> 24:55.440
它不是在实力里面的东西

24:55.440 --> 24:57.440
它就是一个普通的变量

24:57.440 --> 24:59.440
它收不到响应识

24:59.440 --> 25:01.440
那怎么办呢

25:01.440 --> 25:03.440
当然不光是这儿

25:03.440 --> 25:05.440
不光是这儿

25:05.440 --> 25:07.440
你要这里写也不行

25:07.440 --> 25:09.440
在这里写也不行呢

25:09.440 --> 25:11.440
试一下吧

25:13.440 --> 25:15.440
试一下吧

25:15.440 --> 25:17.440
比方说这种情况

25:17.440 --> 25:19.440
也不行

25:19.440 --> 25:21.440
它用的还是个变量

25:21.440 --> 25:23.440
它不具有响应识

25:23.440 --> 25:25.440
那怎么办呢

25:25.440 --> 25:27.440
为了达到响应识的效果

25:27.440 --> 25:29.440
比方说这个数据

25:29.440 --> 25:31.440
它是要有响应识的

25:31.440 --> 25:33.440
那么五幼三呢

25:33.440 --> 25:35.440
它就用completion API的方式

25:35.440 --> 25:37.440
给你提供了

25:37.440 --> 25:39.440
那么这个setup海术

25:39.440 --> 25:41.440
是completion API的一个

25:41.440 --> 25:43.440
这样的功能

25:43.440 --> 25:45.440
于是它给你提供了这么一些东西

25:45.440 --> 25:47.440
这里边很多

25:47.440 --> 25:49.440
我们经常用到的

25:49.440 --> 25:51.440
特别是我们这个to do mvc

25:51.440 --> 25:53.440
里面要用到的东西

25:53.440 --> 25:55.440
其中一个东西就是非常重要的rate

25:55.440 --> 25:57.440
这是一个函数

25:57.440 --> 25:59.440
我们现在只需要做一件事

25:59.440 --> 26:03.900
就可以了

26:03.900 --> 26:05.900
那么这样子得到的数据

26:05.900 --> 26:07.900
就是具有响应识的

26:07.900 --> 26:09.900
看一下吧

26:09.900 --> 26:13.720
就这么简单

26:13.720 --> 26:15.720
我要得到一个数据

26:15.720 --> 26:17.720
把默认值传进去

26:17.720 --> 26:19.720
它就给我返回一个具有响应识的数据

26:19.720 --> 26:21.720
那么我们把这个

26:21.720 --> 26:23.720
响应识的数据返回即可

26:23.720 --> 26:25.720
那么这个数据是有响应识的

26:25.720 --> 26:27.720
你给它增加

26:27.720 --> 26:29.720
减少它都能收到通知

26:29.720 --> 26:31.720
然后呢渲染整个页面

26:31.720 --> 26:33.720
渲染整个主线

26:33.720 --> 26:37.800
好下一个问题

26:37.800 --> 26:39.800
你看是一层一层进来的

26:39.800 --> 26:41.800
为什么不能直接用值

26:41.800 --> 26:43.800
因为它不具有响应识

26:43.800 --> 26:45.800
你自己定义了个变量

26:45.800 --> 26:47.800
你在这里直接操作变量

26:47.800 --> 26:49.800
它不具有响应识

26:49.800 --> 26:51.800
那为什么这个东西具有响应识呢

26:51.800 --> 26:53.800
当然我们要一层一层追问

26:53.800 --> 26:55.800
我们输出一下就知道了

27:01.800 --> 27:03.800
你看啊

27:03.800 --> 27:05.800
我们本来以为它是一个数字

27:05.800 --> 27:07.800
结果得到了结果

27:07.800 --> 27:09.800
实际上是一个啥呢

27:09.800 --> 27:11.800
是一个对象

27:11.800 --> 27:13.800
就是说这个函数

27:13.800 --> 27:15.800
它把这个数字

27:15.800 --> 27:17.800
封装到对象里边去了

27:17.800 --> 27:19.800
然后对象里边

27:19.800 --> 27:21.800
有一个属性

27:21.800 --> 27:23.800
叫Value

27:23.800 --> 27:25.800
你看这个Value属性有三个点

27:25.800 --> 27:27.800
啥意思

27:27.800 --> 27:29.800
是不是一个访问器

27:29.800 --> 27:31.800
那么你都可以想象得到

27:31.800 --> 27:33.800
这个Rave函数做了什么事呢

27:33.800 --> 27:35.800
它就是定义了一个对象

27:35.800 --> 27:37.800
对象里边有一个属性

27:37.800 --> 27:39.800
那个属性是一个访问器

27:39.800 --> 27:41.800
叫Value

27:41.800 --> 27:43.800
访问它属性的时候

27:43.800 --> 27:45.800
它就把这个字给你

27:45.800 --> 27:47.800
设置属性的值的时候

27:47.800 --> 27:49.800
它就重新渲染

27:49.800 --> 27:51.800
它就触发响应识

27:51.800 --> 27:53.800
它就是给你封装成一个对象

27:53.800 --> 27:55.800
你看这个属性值

27:55.800 --> 27:57.800
能理解吧

27:57.800 --> 27:59.800
好,问题又来了

27:59.800 --> 28:03.440
你看

28:03.440 --> 28:05.440
那么既然它是一个对象

28:05.440 --> 28:07.440
那我这边是对象咯

28:07.440 --> 28:09.440
对不对,那应该是对象吧

28:09.440 --> 28:11.440
那为什么我这里应该

28:11.440 --> 28:13.440
正确的写法不应该是

28:13.440 --> 28:15.440
Count the Value嘛

28:15.440 --> 28:17.440
对不对,那为什么我能直接写

28:17.440 --> 28:19.440
Count呢

28:19.440 --> 28:21.440
是不是很有意思

28:21.440 --> 28:23.440
甚至我还可以用Type

28:23.440 --> 28:25.440
Count

28:25.440 --> 28:27.440
看一下它类型是啥

28:27.440 --> 28:29.440
那边是Number的

28:29.440 --> 28:31.440
这怎么回事呢,这里不是明明是对象吗

28:31.440 --> 28:33.440
你看,这里打印出来是对象

28:33.440 --> 28:35.440
在模板里边,它类型是Number

28:35.440 --> 28:37.440
这又是怎么回事呢

28:37.440 --> 28:39.440
这里为了让我们写起来

28:39.440 --> 28:41.440
方便,特别是在模板里边

28:41.440 --> 28:43.440
使用这些享用数据的时候

28:43.440 --> 28:45.440
方便,那么每一次要

28:45.440 --> 28:47.440
调整Value是不是很麻烦

28:47.440 --> 28:49.440
对不对,因此它做了一个

28:49.440 --> 28:51.440
特殊处理,那么这个特殊处理

28:51.440 --> 28:53.440
是怎么处理的呢,看科件

28:53.440 --> 28:55.440
5U里面对Count的

28:55.440 --> 28:57.440
特殊处理,你看,就是个Cdb

28:57.440 --> 28:59.440
返回Count

28:59.440 --> 29:01.440
它是个享用数据

29:01.440 --> 29:03.440
当我们去访问这个Count的时候

29:03.440 --> 29:05.440
由于跟过去不一样了,我们访问的是谁

29:05.440 --> 29:06.440
访问的是

29:06.440 --> 29:08.440
组建代理对象,还记得吗

29:08.440 --> 29:10.440
刚才我们说了,对比过的

29:10.440 --> 29:12.440
这是个组建代理对象,现在我们访问的

29:13.440 --> 29:15.440
我们访问Count是个属性

29:15.440 --> 29:17.440
而组建代理对象,一看

29:17.440 --> 29:19.440
你这个属性是一个Rave的

29:19.440 --> 29:21.440
享用数据

29:21.440 --> 29:23.440
那么它是实际上

29:23.440 --> 29:25.440
访问的属性是什么呢

29:25.440 --> 29:27.440
Count的Value

29:27.440 --> 29:28.440
它是个代理

29:28.440 --> 29:30.440
我们通过组建实力去访问

29:30.440 --> 29:31.440
因为我们知道

29:31.440 --> 29:32.440
在模板里边

29:32.440 --> 29:34.440
是不是都是通过实力去访问的

29:35.440 --> 29:37.440
在模板里边,为什么能够直接使用Count

29:37.440 --> 29:39.440
因为实力里边有Count

29:39.440 --> 29:41.440
这以前里面有没有学过的

29:41.440 --> 29:42.440
那么我们访问这个东西的时候

29:42.440 --> 29:43.440
在模板里边

29:43.440 --> 29:45.440
实际上是通过

29:45.440 --> 29:47.440
代理对象去访问的

29:47.440 --> 29:48.440
那么代理对象访问的

29:48.440 --> 29:50.440
实际上是Count的Value

29:50.440 --> 29:52.440
它可以做特殊处理的

29:52.440 --> 29:54.440
于是组建实力就返回来是0

29:54.440 --> 29:55.440
那么这里就返回0

29:55.440 --> 29:57.440
因此我们在模板里边

29:57.440 --> 29:59.440
由于它是实力环境的

29:59.440 --> 30:01.440
通过实力去访问的时候

30:01.440 --> 30:03.440
它就已经是拆开过的

30:03.440 --> 30:05.440
就是一个白柳的纸

30:05.440 --> 30:07.440
但是在这个Count环境里边

30:07.440 --> 30:09.440
因为它这里边不存在实力

30:09.440 --> 30:10.440
你都没有认识

30:10.440 --> 30:12.440
它不存在实力环境

30:12.440 --> 30:14.440
因此还这里边

30:14.440 --> 30:16.440
它是一个对象

30:16.440 --> 30:18.440
牢牢地记住这一点

30:18.440 --> 30:23.410
你可以简单这样子理解

30:23.410 --> 30:27.410
Count还说里边Count

30:27.410 --> 30:29.410
是一个对象

30:30.410 --> 30:32.410
Count中

30:33.410 --> 30:36.410
然后在实力中

30:37.410 --> 30:38.410
实力代理中

30:38.410 --> 30:41.410
通过实力代理去访问Count的时候

30:41.410 --> 30:45.410
是一个Count的Value

30:45.410 --> 30:46.410
那么它是Number

30:46.410 --> 30:47.410
Value是Number

30:47.410 --> 30:48.410
它就是Number

30:50.410 --> 30:51.410
明儿的意思吧

30:52.410 --> 30:53.410
所以说我们刚才可以看到

30:53.410 --> 30:54.410
在Cw函数里边

30:54.410 --> 30:56.410
这里输出的Count

30:56.410 --> 31:00.430
是一个对象

31:00.430 --> 31:01.430
想清楚了

31:01.430 --> 31:03.430
要好好去理一句

31:03.430 --> 31:04.430
那么这个时候

31:04.430 --> 31:06.430
确实并不完美

31:06.430 --> 31:07.430
但是完美的做法

31:07.430 --> 31:08.430
大家确实又想想

31:08.430 --> 31:10.430
不知道该怎么去做完美

31:10.430 --> 31:12.430
最好了

31:12.430 --> 31:13.430
这里边也可以直接

31:13.430 --> 31:14.430
用它的外力就最好

31:14.430 --> 31:16.430
但是目前的情况

31:16.430 --> 31:18.430
是不太办得到的

31:18.430 --> 31:20.430
具体的原因

31:20.430 --> 31:22.430
需要我们在下面一个阶段

31:22.430 --> 31:23.430
来说吧

31:23.430 --> 31:24.430
它为什么要去这样的设计

31:24.430 --> 31:25.430
没办法

31:25.430 --> 31:26.430
确实没办法

31:26.430 --> 31:28.430
你说React Hook

31:28.430 --> 31:29.430
React Hook

31:29.430 --> 31:31.430
它有没有好的办法

31:31.430 --> 31:32.430
它倒是不存在这个问题

31:32.430 --> 31:35.430
它是另外一种处理方式

31:35.430 --> 31:37.430
不过它也有它的问题

31:37.430 --> 31:39.430
它的问题蛮严重的

31:42.430 --> 31:43.430
伤质不是很好

31:43.430 --> 31:47.000
好,我们说到这了

31:47.000 --> 31:49.000
那么Value官方

31:49.000 --> 31:50.000
建议大家

31:50.000 --> 31:52.000
就是说为了避免

31:53.000 --> 31:54.000
写晕了

31:54.000 --> 31:55.000
因为以后在

31:55.000 --> 31:56.000
Ctap函数里边写的时候

31:56.000 --> 31:58.000
它要写个白柳

31:58.000 --> 31:59.000
要获取它的字

31:59.000 --> 32:00.000
要用白柳

32:01.000 --> 32:02.000
要用白柳

32:04.690 --> 32:05.690
有的时候

32:05.690 --> 32:07.690
要在模板里边去使用

32:07.690 --> 32:09.690
它又不需要白柳

32:09.690 --> 32:11.690
有的时候脑袋用晕

32:11.690 --> 32:13.690
所以它建议你

32:13.690 --> 32:14.690
在变量命名的时候

32:14.690 --> 32:16.690
来给它加一个后维

32:16.690 --> 32:18.690
比方它是用Ref

32:18.690 --> 32:20.690
用Ref来创建的一个响应数据

32:20.690 --> 32:21.690
创建响应数据

32:21.690 --> 32:22.690
还有别的方式

32:22.690 --> 32:24.690
我们这里单讲Ref

32:24.690 --> 32:25.690
那么建议你

32:25.690 --> 32:27.690
在后面加上一个Ref

32:27.690 --> 32:28.690
这样子

32:28.690 --> 32:29.690
你心里边就明白了

32:29.690 --> 32:30.690
它是个Ref

32:30.690 --> 32:31.690
那么现在是Ctap管理

32:31.690 --> 32:33.690
那么我们就一定要加上白柳

32:33.690 --> 32:34.690
然后这边

32:34.690 --> 32:35.690
因为它是个Ref

32:35.690 --> 32:37.690
它是个模板环境

32:37.690 --> 32:38.690
就是实力环境

32:38.690 --> 32:39.690
实力环境

32:39.690 --> 32:40.690
我就不用加白柳了

32:40.690 --> 32:42.690
也不能加

32:42.690 --> 32:44.690
要建议这样处理

32:44.690 --> 32:49.030
官方的建议

32:49.030 --> 32:50.030
当然你也可以不用

32:50.030 --> 32:52.030
这个后维也可以

32:52.030 --> 32:54.030
明白了意思吧

32:54.030 --> 32:56.030
那么我现在问问大家一个问题

32:56.030 --> 32:58.030
大家是不是真正的理解了

32:58.030 --> 32:59.030
我现在把这个

32:59.030 --> 33:00.030
Increase还数加上

33:00.030 --> 33:02.790
我请问一下

33:02.790 --> 33:04.790
在这个Increase还数里边

33:07.100 --> 33:09.100
我这里是应该写

33:09.100 --> 33:11.100
CountRef加加

33:11.100 --> 33:15.670
还是CountRef点Value加加

33:15.670 --> 33:16.670
想一下

33:16.670 --> 33:20.620
是不是应该是Value加加

33:20.620 --> 33:21.620
为什么

33:21.620 --> 33:22.620
因为这些Tap环境

33:22.620 --> 33:23.620
这个还数环境

33:23.620 --> 33:25.620
因此呢

33:25.620 --> 33:27.620
必须要加上Value

33:27.620 --> 33:28.620
看一下吧

33:32.060 --> 33:33.060
Increase

33:33.060 --> 33:34.060
没返回对吧

33:37.330 --> 33:38.330
看没

33:38.330 --> 33:39.330
就可以了

33:40.330 --> 33:41.330
有些人觉得

33:41.330 --> 33:43.330
这样子写还没有一切写得方便

33:43.330 --> 33:46.330
那是你现在的组件简单

33:46.330 --> 33:49.330
那么我们刚才也给大家看到过了

33:49.330 --> 33:51.330
这两张对比图

33:51.330 --> 33:53.330
这是用Option API写的

33:53.330 --> 33:55.330
一旦组件复杂了

33:55.330 --> 33:56.330
我们那就会

33:56.330 --> 33:58.330
如果说用过去那种配置式的方式

33:58.330 --> 33:59.330
这东一个配置

33:59.330 --> 34:00.330
西一个配置

34:00.330 --> 34:01.330
然后不同的功能

34:01.330 --> 34:03.330
分拆的不同的配置里边

34:03.330 --> 34:04.330
就变成这样子

34:04.330 --> 34:07.330
但是用了Compression API的时候

34:07.330 --> 34:10.330
你甚至可以完全不用Option API

34:10.330 --> 34:11.330
完全不需要配置的

34:11.330 --> 34:14.330
全部在Ctap函数里边写

34:14.330 --> 34:16.330
包括生命周期函数都可以

34:16.330 --> 34:18.330
我们后面会说到一些生命周期函数

34:18.330 --> 34:20.330
那么都可以在这里边写

34:20.330 --> 34:21.330
一把返回就行了

34:21.330 --> 34:23.330
就是在实力里边需要用的东西

34:23.330 --> 34:24.330
返回就行了

34:24.330 --> 34:26.330
不需要返回的就不返回

34:26.330 --> 34:27.330
那么这样子

34:27.330 --> 34:28.330
我们就可以在Ctap函数里边

34:28.330 --> 34:30.330
形成一块一块的功能

34:30.330 --> 34:31.330
比较这一块

34:31.330 --> 34:33.330
是做新增一个任务

34:33.330 --> 34:34.330
下边这一块

34:34.330 --> 34:36.330
是做了一个修改

34:36.330 --> 34:38.330
比较这个是做新增

34:38.330 --> 34:40.330
这个是做修改

34:40.330 --> 34:42.330
这个是做删除

34:42.330 --> 34:44.330
它是一块一块的

34:44.330 --> 34:46.330
那么新增里边有数据

34:46.330 --> 34:48.330
有享用数据有方法

34:48.330 --> 34:50.330
修改里边有享用数据有方法

34:50.330 --> 34:52.330
删除里边也是一样

34:52.330 --> 34:55.330
最后我们把需要的返回就完了

34:55.330 --> 34:57.330
它就可以高度的聚合

34:57.330 --> 34:58.330
而且更好的地方在于

34:58.330 --> 35:00.330
这东西是可以提出去的

35:00.330 --> 35:01.330
这个玩意是可以提出去的

35:01.330 --> 35:02.330
你看一下

35:02.330 --> 35:04.330
我可以把这两个函数

35:04.330 --> 35:05.330
当然我写到主建里边

35:05.330 --> 35:06.330
当时有个好处就是

35:06.330 --> 35:08.330
每个主建用的是不一样的

35:08.330 --> 35:09.330
那如果说你要通用的话

35:09.330 --> 35:11.330
所有的主建都可以使用一样的话

35:11.330 --> 35:13.330
你可以把它写到外面去

35:13.330 --> 35:16.730
你可以写到外面去

35:16.730 --> 35:18.730
因为这个东西

35:18.730 --> 35:20.730
它是不依赖主建存在

35:20.730 --> 35:22.730
它不需要依赖主建存在

35:22.730 --> 35:24.730
那么这个函数当然更加不依赖主建

35:24.730 --> 35:26.730
就是个普通的函数

35:26.730 --> 35:27.730
原来的意思

35:27.730 --> 35:28.730
你看一下

35:28.730 --> 35:32.560
当然有享用数

35:32.560 --> 35:34.560
它们也是可以提出去的

35:34.560 --> 35:36.560
当然这样提出去的话

35:36.560 --> 35:38.560
那就所有的这个主建

35:38.560 --> 35:40.560
都是同一个数据的

35:40.560 --> 35:41.560
大部分时候

35:41.560 --> 35:43.560
我们一般不会这样去做

35:43.560 --> 35:45.560
那么尽管写到这儿

35:45.560 --> 35:47.560
我们是不是也可以把它

35:47.560 --> 35:49.560
提成一个单独的模块

35:49.560 --> 35:51.560
比方说我们这里

35:51.560 --> 35:53.560
可以写函数

35:53.560 --> 35:54.560
该取个名字

35:54.560 --> 35:56.560
就像Rat Hook那样的命名

35:56.560 --> 35:57.560
Use

35:57.560 --> 35:58.560
当然也可以不用这个命名

35:58.560 --> 36:00.560
只是我们习惯上这样命名

36:00.560 --> 36:02.560
UseCult

36:02.560 --> 36:05.560
我们要用一个Cult的数据

36:05.560 --> 36:07.560
那么跟这个数据的相关的方法

36:07.560 --> 36:08.560
也要用

36:08.560 --> 36:09.560
因此我在这里

36:09.560 --> 36:11.560
可以把这两个代码写下来

36:11.560 --> 36:12.560
看呗

36:12.560 --> 36:14.560
有一个Cult数据

36:14.560 --> 36:15.560
有一个Increase方法

36:15.560 --> 36:17.560
都是跟这个技术相关的

36:17.560 --> 36:19.560
还可以包括一些什么Decrease

36:19.560 --> 36:20.560
方法

36:20.560 --> 36:22.560
对吧

36:22.560 --> 36:23.560
CultRef

36:23.560 --> 36:24.560
点Value

36:24.560 --> 36:26.560
点键

36:26.560 --> 36:27.560
好

36:27.560 --> 36:28.560
然后我们返回

36:28.560 --> 36:30.560
把这个CultRef

36:30.560 --> 36:32.560
和Increase

36:32.560 --> 36:33.560
Decrease

36:33.560 --> 36:34.560
都返回

36:34.560 --> 36:35.560
通通的函数返回

36:35.560 --> 36:36.560
那么这边我们就很简单了

36:36.560 --> 36:37.560
我们就只需要

36:37.560 --> 36:42.660
调用一下这个函数

36:42.660 --> 36:43.660
Cult

36:43.660 --> 36:44.660
那么这得到的结果

36:44.660 --> 36:45.660
是不是

36:45.660 --> 36:47.660
就是跟它的所有相关的东西

36:47.660 --> 36:48.660
对不对

36:48.660 --> 36:49.660
我们可以在这里获取

36:49.660 --> 36:50.660
然后再返回

36:50.660 --> 36:57.040
也可以直接这样

36:57.040 --> 36:58.040
也可以直接这样

36:58.040 --> 36:59.040
对吧

36:59.040 --> 37:00.040
因为解构云酸浮

37:00.040 --> 37:01.040
把这个函数调用过后

37:01.040 --> 37:02.040
返回了对象

37:02.040 --> 37:03.040
解构了

37:03.040 --> 37:04.040
那么这里返回的

37:04.040 --> 37:05.040
是不是就是这三个

37:05.040 --> 37:06.040
好 你看一下

37:06.040 --> 37:07.040
是吧

37:07.040 --> 37:08.040
我们是新增

37:08.040 --> 37:10.040
还可以用简法

37:10.040 --> 37:13.040
那写出来吧

37:14.040 --> 37:15.040
在593里边

37:15.040 --> 37:17.040
是可以有多个更解点的

37:17.040 --> 37:22.280
CultRef

37:22.280 --> 37:24.280
那么这里的是新增

37:24.280 --> 37:25.280
Increase

37:25.280 --> 37:27.280
这是Decrease吧

37:27.280 --> 37:31.740
Decrease

37:31.740 --> 37:35.880
那么这是Increase

37:35.880 --> 37:38.320
Click

37:38.320 --> 37:40.320
Increase

37:40.320 --> 37:41.320
好 保存

37:41.320 --> 37:43.320
你看一下

37:43.320 --> 37:44.320
看来

37:44.320 --> 37:45.320
是不是这样子

37:45.320 --> 37:46.320
可以高度去合

37:46.320 --> 37:47.320
而且这个东西

37:47.320 --> 37:49.320
是不是可以单独提成一个文件

37:49.320 --> 37:50.320
对不对

37:50.320 --> 37:51.320
可以把单独提到

37:51.320 --> 37:52.320
一个模块里面去

37:52.320 --> 37:53.320
那么这样子的话

37:53.320 --> 37:54.320
这个setup

37:54.320 --> 37:56.320
几大都被减化了

37:56.320 --> 37:57.320
对吧

37:57.320 --> 37:58.320
那你看以前的OPIP

37:58.320 --> 37:59.320
APN能做到吗

37:59.320 --> 38:01.320
这个玩意OPIP

38:01.320 --> 38:02.320
OPIPAPN能做到吗

38:02.320 --> 38:04.320
做不到

38:04.320 --> 38:05.320
为什么做不到

38:05.320 --> 38:06.320
因为这些东西是分散的

38:06.320 --> 38:07.320
对吧

38:07.320 --> 38:08.320
这个东西应该配置到哪

38:08.320 --> 38:09.320
配置到Message里边

38:09.320 --> 38:10.320
那么这个东西

38:10.320 --> 38:11.320
应该配置到Data里边

38:11.320 --> 38:12.320
它是分散的

38:12.320 --> 38:14.320
除了用那个Mexing之外

38:14.320 --> 38:15.320
没有别的方法

38:15.320 --> 38:17.320
Mexing它有自己的问题

38:17.320 --> 38:19.320
我们以下个节奏再说

38:20.320 --> 38:21.320
那么以后

38:21.320 --> 38:23.320
在遇到复杂逐渐的时候

38:23.320 --> 38:25.320
我建议大家使用这种方式

38:25.320 --> 38:26.320
你看这里只是一个功能

38:26.320 --> 38:28.320
那如果说这个逐渐功能很多

38:28.320 --> 38:29.320
我们是不是可以提成不同的

38:29.320 --> 38:30.320
这种幼稚方法

38:30.320 --> 38:31.320
一个功能管一块

38:31.320 --> 38:32.320
一个功能管一块

38:32.320 --> 38:33.320
然后这里集体导出

38:33.320 --> 38:34.320
就完成了

38:35.320 --> 38:36.320
那么这就可能

38:36.320 --> 38:37.320
讲到这

38:37.320 --> 38:39.320
很多地方的点到技职

38:39.320 --> 38:41.320
我们先体验一下

38:41.320 --> 38:42.320
comparation API

38:42.320 --> 38:43.320
它到底是怎么玩的

38:43.320 --> 38:44.320
就是一个setup函数

38:44.320 --> 38:45.320
这个函数在最开始的时候

38:45.320 --> 38:46.320
就会执行

38:46.320 --> 38:48.320
而且只需要执行一次

38:50.320 --> 38:51.320
那么这个函数里边

38:51.320 --> 38:52.320
可以通过Rave

38:53.320 --> 38:55.320
来得到一个享用数据

38:55.320 --> 38:56.320
这个数据的变化

38:56.320 --> 38:58.320
会被无忧监控到

38:58.320 --> 39:00.320
然后这个setup函数

39:00.320 --> 39:01.320
返回的东西

39:01.320 --> 39:03.320
会挂载到实力里边去

39:03.320 --> 39:04.320
那么这个Rave的地方

39:04.320 --> 39:05.320
有个小细节

39:05.320 --> 39:07.320
就是setup函数里边

39:07.320 --> 39:08.320
它是一个对象

39:08.320 --> 39:10.320
除了setup

39:10.320 --> 39:11.320
就是实力环境里边

39:11.320 --> 39:13.320
它是一个0.6

39:13.320 --> 39:15.320
你不需要在这里边

39:15.320 --> 39:16.320
再去0.6了

39:17.320 --> 39:18.320
这就是

39:18.320 --> 39:19.320
我们这一颗要介绍的东西

39:19.320 --> 39:20.320
可能有些东西

39:20.320 --> 39:21.320
不太适应

39:21.320 --> 39:23.320
好好看一下这个带吧

39:23.320 --> 39:24.320
好好体会一下

39:24.320 --> 39:25.320
最好了

39:25.320 --> 39:26.320
简单的势力

39:26.320 --> 39:27.320
自己跟着去写一遍

39:27.320 --> 39:28.320
这样子

39:28.320 --> 39:29.320
我们在后边

39:29.320 --> 39:30.320
做安逸的时候

39:30.320 --> 39:32.320
至少不至于太陌生

39:33.320 --> 39:34.320
我们这一颗到这里了

