WEBVTT

00:00.560 --> 00:04.560
上课之前 先补充一下上级课的知识

00:04.560 --> 00:07.560
上级课主要讲的那个异部组件 对吧

00:07.560 --> 00:09.560
异部组件里边的5U3呢

00:09.560 --> 00:13.560
还给你提供了这么一个组件 叫做Suspense

00:13.560 --> 00:18.560
这个组件呢 它也是来处理跟异部相关的

00:18.560 --> 00:22.560
不过呢 目前呢 我还不打算讲这个组件

00:22.560 --> 00:25.560
因为 如果说你去试用一下这个组件的话

00:25.560 --> 00:28.560
你会发现 页面上它会给你一个警告

00:28.560 --> 00:31.560
所以这个组件呢 还在试验阶段

00:31.560 --> 00:34.560
将来的API呢 很有可能会变动

00:34.560 --> 00:38.560
所以说呢 建议你目前呢 暂时不要在生产环境里面去使用

00:38.560 --> 00:40.560
因此呢 我这里等一等吧

00:40.560 --> 00:44.560
等一等这个组件成熟了 发布了正式的版本之后呢

00:44.560 --> 00:46.560
我再给大家补充一节课 就完事了

00:46.560 --> 00:49.560
这个问题我刚刚说一下

00:49.560 --> 00:52.560
好了 这节课咱们介绍啥呢

00:52.560 --> 00:58.130
介绍Reactivity API

00:58.130 --> 01:00.130
它首先打个预防针啊

01:00.130 --> 01:03.130
就这节课的东西 你需要去消化一天啊

01:03.130 --> 01:08.130
因为这一块的东西是五右三里面最复杂的一块

01:08.130 --> 01:12.130
也是五右三功能最强大的一块

01:12.130 --> 01:16.130
也是面试的时候 如果说出彼此题

01:16.130 --> 01:18.130
最难的一块也就在这了

01:18.130 --> 01:21.130
就是这个硬骨头一把捅下去

01:21.130 --> 01:24.130
捅完了过后呢 五右三就没有什么

01:25.130 --> 01:28.130
这一块的知识呢 好好去吸收

01:28.130 --> 01:31.130
听完了这一块比内容比较多 也比较长

01:31.130 --> 01:35.130
听完了之后呢 好好在脑袋里面去消化一下

01:35.130 --> 01:38.130
拿一天的时间 一天不够拿两天

01:38.130 --> 01:41.130
两天不够拿三天 你自己去定这个时间

01:41.130 --> 01:43.130
好好要把它消化完

01:43.130 --> 01:46.130
因为这个没办法 五右三复杂就复杂在这

01:46.130 --> 01:49.130
就是这个响应式API

01:49.130 --> 01:51.130
因为在五右三里面呢

01:51.130 --> 01:54.130
响应式API给你暴露出来了

01:54.130 --> 01:57.130
项目在五右二的时候有没有暴露给你呢

01:57.130 --> 02:00.130
它那没有暴露给你 你看五右二是怎么做的

02:00.130 --> 02:03.130
五右二不就是配置一个data对象吗

02:03.130 --> 02:05.130
就配置一个data吗

02:05.130 --> 02:08.130
这个data里面东西它就会自动的变成响应式

02:08.130 --> 02:11.130
我们把它叫做注入 对不对

02:11.130 --> 02:14.130
注入到什么 注入到组建实力里面去

02:14.130 --> 02:17.130
而在五右三里面我们是不是学习了这个setup

02:18.130 --> 02:21.130
我们把这个东西叫什么 叫comparation API

02:21.130 --> 02:23.130
我们好好来梳理一下

02:23.130 --> 02:26.130
我们在入门阶段的时候用过的 叫comparation API

02:26.130 --> 02:29.130
实际上comparation API

02:29.130 --> 02:33.130
它很简单的 我们下节课就讲comparation API

02:33.130 --> 02:35.130
它实际上很简单的

02:35.130 --> 02:37.130
我们平时在用comparation API的时候

02:37.130 --> 02:40.130
怎么用的呢 是不是导入那个

02:40.130 --> 02:42.130
导入什么呢

02:42.130 --> 02:45.130
amounted对吧 还导入什么

02:45.130 --> 02:48.130
还包括什么呢 还包括我们导入了什么

02:48.130 --> 02:50.130
导入了这个ref

02:50.130 --> 02:53.130
还包括导入了什么呢 导入了computed

02:53.130 --> 02:55.130
对不对 是不是这样子导入了

02:55.130 --> 02:58.130
还记得吧 在五右阶段 入门阶段

02:59.130 --> 03:01.130
导入了这些API当中我告诉大家

03:01.130 --> 03:04.130
这两个生命周期勾字函数

03:04.130 --> 03:05.130
以及这个setup函数

03:05.130 --> 03:08.130
这是属于comparation API的

03:08.130 --> 03:11.130
而这两个函数是属于

03:11.130 --> 03:13.130
reactivity API的

03:13.130 --> 03:16.130
所以说我们从直观的印象看上去

03:16.130 --> 03:19.130
就是我们在用comparation API的时候

03:19.130 --> 03:21.130
有一些API

03:21.130 --> 03:23.130
实际上是用到的是谁呢

03:23.130 --> 03:26.130
reactivity API

03:26.130 --> 03:29.130
原来它是有这么一层关系在里面

03:29.130 --> 03:32.130
那么这什么叫做reactivity API呢

03:32.130 --> 03:35.130
其实就是处理的数据享用式

03:35.130 --> 03:37.130
你想啊

03:37.130 --> 03:40.630
五右要坚持

03:41.630 --> 03:43.630
五右要监控数据的变化

03:43.630 --> 03:45.630
数据变化的时候

03:45.630 --> 03:47.630
我们可能会运行一些东西

03:47.630 --> 03:49.630
包括我们之前用的什么呢

03:49.630 --> 03:52.630
用的那个watch effect

03:52.630 --> 03:53.630
还记得吗

03:53.630 --> 03:57.630
这个玩意其实也是属于享用式API的

03:57.630 --> 03:59.630
当数据变化的时候

03:59.630 --> 04:00.630
我们可能要做一些事

04:00.630 --> 04:01.630
那么这些事呢

04:01.630 --> 04:03.630
包括单不仅限于

04:03.630 --> 04:05.630
包括我们运行一个自定义的回调函数

04:05.630 --> 04:08.630
watch effect里面

04:08.630 --> 04:09.630
包括什么呢

04:09.630 --> 04:12.630
包括我们的界面渲染

04:12.630 --> 04:14.630
界面渲染实际上是个函数

04:14.630 --> 04:15.630
对不对

04:15.630 --> 04:16.630
我们看到那个模板编印的结果

04:16.630 --> 04:18.630
是不是个Render函数

04:18.630 --> 04:19.630
当我们数据

04:19.630 --> 04:20.630
它的一代的数据变化的时候

04:20.630 --> 04:22.630
Render函数会重新运行

04:22.630 --> 04:23.630
重新渲染界面

04:23.630 --> 04:24.630
这些呢

04:24.630 --> 04:26.630
实际上都是要

04:26.630 --> 04:28.630
享用式数据来支撑的

04:28.630 --> 04:30.630
什么叫享用式数据

04:30.630 --> 04:31.630
就是那个数据变化了

04:31.630 --> 04:32.630
我们能知道

04:32.630 --> 04:34.630
如果说你一个普通的对象

04:34.630 --> 04:36.630
比方说我们这里随便写一个普通的对象

04:40.420 --> 04:41.420
随便写一个

04:41.420 --> 04:43.420
那如果说一个普通的对象的话

04:43.420 --> 04:44.420
它有数据享用式吗

04:44.420 --> 04:45.420
没有

04:45.420 --> 04:46.420
对不对

04:46.420 --> 04:49.420
你把个S5像从一个负一个值

04:49.420 --> 04:50.420
谁知道它负了值呢

04:50.420 --> 04:51.420
谁也不知道

04:51.420 --> 04:53.420
这是一个普通的对象

04:53.420 --> 04:54.420
它不具有数据享用式

04:54.420 --> 04:56.420
那么过去5u20怎么做的呢

04:56.420 --> 04:58.420
是用Define property对吧

04:58.420 --> 05:00.420
给它设置了一个Center函数

05:00.420 --> 05:01.420
一个Gator函数

05:01.420 --> 05:03.420
那么当我们给它负值

05:03.420 --> 05:04.420
给它读取它的值的时候

05:04.420 --> 05:06.420
我们可以收到一个通知

05:06.420 --> 05:08.420
5u是这样做的

05:08.420 --> 05:10.420
但是在5u2的时候

05:10.420 --> 05:12.420
它是没有把这些数据享用式

05:12.420 --> 05:14.420
给你暴露出来的

05:14.420 --> 05:15.420
你在5u2用的时候

05:15.420 --> 05:18.420
谁去用过那个数据享用式API呢

05:18.420 --> 05:19.420
没有

05:19.420 --> 05:21.420
都算内部完成的

05:21.420 --> 05:23.420
但是到了5u3

05:23.420 --> 05:25.420
这个情况不一样了

05:25.420 --> 05:27.420
因为到了5u3里边

05:27.420 --> 05:29.420
我们要去用comparation API

05:29.420 --> 05:31.420
它里面不可避免的

05:31.420 --> 05:34.420
你要去定义一些具有享用式的数据

05:34.420 --> 05:36.420
那么它就必须要暴露

05:36.420 --> 05:38.420
享用式的API给力

05:38.420 --> 05:41.420
因此在5u3的设计里边

05:41.420 --> 05:43.420
它实际上是把一个

05:43.420 --> 05:45.420
数据享用系统

05:45.420 --> 05:47.420
给你分离出去了

05:47.420 --> 05:49.420
分离成了一个独立的系统

05:49.420 --> 05:50.420
这个独立系统

05:50.420 --> 05:53.420
跟5u组建没有一毛钱关系

05:53.420 --> 05:56.420
跟5u一个应用没有一毛钱关系

05:56.420 --> 05:58.420
它就是一个独立的

05:58.420 --> 05:59.420
跟任何平台

05:59.420 --> 06:01.420
甚至跟浏览器都没有任何关系

06:01.420 --> 06:03.420
在那种环境里边都可以运行

06:03.420 --> 06:05.420
就是利用GS函数

06:05.420 --> 06:08.420
GS的代理以及一系列的基本操作

06:08.420 --> 06:10.420
给你写出了这么一些函数

06:10.420 --> 06:12.420
我们这几课就来专门来学习

06:12.420 --> 06:15.420
5u3里边给你提供了哪些

06:15.420 --> 06:17.420
跟数据享用式相关的函数

06:17.420 --> 06:20.420
而且这一整节课

06:20.420 --> 06:22.420
不会涉及到任何的5u组建

06:22.420 --> 06:24.420
也不会涉及到5u应用

06:24.420 --> 06:26.420
甚至我们看文的工程里边啥都没有

06:26.420 --> 06:28.420
就一个媒体GS啥都没有

06:28.420 --> 06:30.420
因为它引用这个媒体GS

06:30.420 --> 06:33.420
无论中跟5u一毛钱关系没有

06:33.420 --> 06:36.420
我们就来研究它里面的数据享用式

06:36.420 --> 06:38.420
这一块内容比较多

06:38.420 --> 06:40.420
我慢慢讲

06:40.420 --> 06:42.420
大家需要有点耐心

06:42.420 --> 06:44.420
这一课内容的也比较绕

06:44.420 --> 06:45.420
也比较枯燥

06:45.420 --> 06:48.420
跟它一步一步讲它是怎么回事

06:48.420 --> 06:51.420
首先我们看第一个问题

06:51.420 --> 06:53.420
在5u3里边

06:53.420 --> 06:56.420
我们如何来获取一个享用式数据

06:56.420 --> 06:58.420
比方说我们这里有一个对象

06:58.420 --> 07:00.420
这个对象里边又有一个a等于e

07:00.420 --> 07:01.420
b等于2

07:01.420 --> 07:04.420
那么我们知道这个对象是不具有数据享用式的

07:04.420 --> 07:06.420
那么我们现在要问题就是

07:06.420 --> 07:10.420
如何把这个对象变成一个数据享用式对象

07:10.420 --> 07:12.420
它的属性变化

07:12.420 --> 07:13.420
它的属性读取

07:13.420 --> 07:15.420
能够收到通知

07:15.420 --> 07:16.420
怎么做呢

07:16.420 --> 07:19.420
5u3里边给你提供了这么一些API

07:19.420 --> 07:21.420
这通过这些API

07:21.420 --> 07:25.420
我们都可以得到一个具有享用式的数据

07:25.420 --> 07:26.420
那么这些API

07:26.420 --> 07:28.420
我们之前见过的是

07:28.420 --> 07:30.420
见过computed对吧

07:30.420 --> 07:31.420
还在来说

07:31.420 --> 07:34.420
我们首先看第一个叫reactive

07:35.420 --> 07:36.420
传入的是什么呢

07:36.420 --> 07:37.420
它是一个函数

07:37.420 --> 07:38.420
传入的是一个plane object

07:38.420 --> 07:39.420
什么叫plane object

07:39.420 --> 07:40.420
就是一个普通对象

07:40.420 --> 07:43.420
一个平面对象就这个东西

07:43.420 --> 07:45.420
那么我们来试一下吧

07:45.420 --> 07:46.420
Import你看

07:46.420 --> 07:47.420
我整个过程是不会

07:47.420 --> 07:49.420
不会用到任何5u组件

07:49.420 --> 07:51.420
不会用到任何5u实力的

07:51.420 --> 07:52.420
倒入一个什么呢

07:52.420 --> 07:54.420
reactive

07:54.420 --> 07:56.420
然后我们通过这个reactive函数

07:57.420 --> 07:58.420
把对象传进去

07:58.420 --> 07:59.420
它反而回的是什么呢

07:59.420 --> 08:01.420
反而回的是一个代理

08:01.420 --> 08:02.420
这个其实

08:02.420 --> 08:04.420
原理很简单

08:04.420 --> 08:05.420
它就反而回一个代理

08:05.420 --> 08:08.420
你之后就操作这个代理对象

08:08.420 --> 08:10.420
比方说我们给state

08:10.420 --> 08:12.420
之后我们来输出一下

08:12.420 --> 08:14.420
把它放到window.state里边吧

08:24.360 --> 08:26.360
方便我们查看

08:26.360 --> 08:28.360
state保存到这里边

08:28.360 --> 08:30.360
我们把它运行出来

08:33.360 --> 08:35.360
这里边就跟那个5u组件

08:35.360 --> 08:36.360
没有任何关系

08:36.360 --> 08:38.360
你看完全是脱离组件的

08:38.360 --> 08:40.360
现在我们看一下state

08:40.360 --> 08:42.360
state里边的a数项

08:42.360 --> 08:44.360
1state里边的b数项

08:44.360 --> 08:45.360
是不是2

08:45.360 --> 08:46.360
对不对

08:46.360 --> 08:47.360
你看这个state是个啥

08:47.360 --> 08:48.360
是个proxy

08:48.360 --> 08:49.360
看没

08:49.360 --> 08:50.360
其实很简单

08:50.360 --> 08:51.360
它可以反回一个proxy

08:51.360 --> 08:52.360
代理谁呢

08:52.360 --> 08:54.360
代理传入的普通对象

08:54.360 --> 08:55.360
那么这个是不是

08:55.360 --> 08:56.360
一个数据想用式

08:56.360 --> 08:57.360
因为它是一个proxy

08:57.360 --> 09:00.360
因此你对它的数据独取

09:00.360 --> 09:01.360
和数据复制

09:01.360 --> 09:03.360
是不是它能够收到通知

09:03.360 --> 09:04.360
对吧

09:04.360 --> 09:05.360
非常简单的

09:05.360 --> 09:07.360
那么我们可以

09:07.360 --> 09:10.360
深入到有大大的类型世界

09:10.360 --> 09:11.360
它类型咋想的呢

09:11.360 --> 09:12.360
你看以前不是一个data吗

09:12.360 --> 09:13.360
对吧

09:13.360 --> 09:14.360
以前配置的配置组件的时候

09:14.360 --> 09:15.360
有个data吗

09:15.360 --> 09:16.360
对吧

09:16.360 --> 09:17.360
那个data的数据想用式

09:17.360 --> 09:18.360
是在内部完成的

09:18.360 --> 09:19.360
那现在我们

09:19.360 --> 09:20.360
赶快把抽离出去

09:20.360 --> 09:21.360
一个API叫reactive

09:21.360 --> 09:23.360
那么它反回一个proxy

09:23.360 --> 09:24.360
对吧

09:24.360 --> 09:25.360
它就完成了数据想用式的

09:25.360 --> 09:26.360
那么这个东西

09:26.360 --> 09:27.360
一毛钱关系都没有

09:28.360 --> 09:29.360
对不对

09:29.360 --> 09:31.360
这就是个数据想用式

09:32.360 --> 09:34.360
好 接下来我们继续往下看

09:34.360 --> 09:35.360
下边又有一个

09:35.360 --> 09:36.360
它又给它提供了一个

09:36.360 --> 09:38.360
因为它考虑不同的场景

09:38.360 --> 09:39.360
因为我又是做框架了

09:39.360 --> 09:40.360
它必须要考虑开发

09:40.360 --> 09:41.360
里边不同的场景

09:41.360 --> 09:43.360
它有的时候觉得呢

09:43.360 --> 09:44.360
你这个玩意

09:44.360 --> 09:45.360
你给它反回一个

09:45.360 --> 09:47.360
就是这个proxy

09:47.360 --> 09:48.360
你还可以去修改它

09:48.360 --> 09:49.360
对不对

09:49.360 --> 09:50.360
修改为3

09:50.360 --> 09:51.360
那么现在我们看一下

09:51.360 --> 09:52.360
这个stats里边

09:52.360 --> 09:53.360
不等于3了吗

09:53.360 --> 09:54.360
你可以修改它

09:54.360 --> 09:56.360
有的时候我们可能

09:57.360 --> 09:58.360
需要得到一个

09:58.360 --> 10:00.360
只读的数据

10:00.360 --> 10:02.360
那么这个只读的数据呢

10:03.360 --> 10:04.360
那我怎么来处理呢

10:04.360 --> 10:05.360
它又给你提供了一个

10:05.360 --> 10:07.360
单读的函数叫read only

10:08.360 --> 10:09.360
传入的是什么呢

10:09.360 --> 10:10.360
跟reactive一样啊

10:10.360 --> 10:12.360
传入的是一个plane object

10:12.360 --> 10:13.360
或者是一个代理

10:13.360 --> 10:14.360
对吧

10:14.360 --> 10:15.360
那么反回的是一个

10:15.360 --> 10:16.360
什么呢

10:16.360 --> 10:17.360
反回的是对象代理

10:17.360 --> 10:19.360
这个对象代理比较特殊

10:19.360 --> 10:20.360
因为它是代理

10:20.360 --> 10:21.360
你都能想得到

10:21.360 --> 10:22.360
对吧

10:22.360 --> 10:23.360
它只允许你get

10:23.360 --> 10:25.360
允许你读取set的时候

10:25.360 --> 10:26.360
它就管理

10:26.360 --> 10:27.360
不做任何事情

10:27.360 --> 10:28.360
那么这就是一个

10:28.360 --> 10:30.360
只读的对象

10:30.360 --> 10:31.360
来 我们来试一下吧

10:32.360 --> 10:34.360
我们这里再加上一个

10:34.360 --> 10:36.360
read only

10:36.360 --> 10:38.360
那先让我们来试一下

10:38.360 --> 10:40.360
我们叫做immutable

10:40.360 --> 10:41.360
不可改变的

10:41.360 --> 10:43.360
不可改变的状态

10:43.360 --> 10:45.360
我们这里写个read only

10:45.360 --> 10:46.360
那么这里也是一个

10:46.360 --> 10:48.360
a等e b等于2

10:49.360 --> 10:50.360
好 接下来我们来看一下

10:50.360 --> 10:52.360
我们把这个window里边

10:52.360 --> 10:55.360
这个set放到这个window里边

10:55.360 --> 10:56.360
来看一下

10:56.360 --> 10:58.360
这就是一个只读的数据

10:59.360 --> 11:01.360
好 保证我们来看一下

11:01.360 --> 11:02.360
set

11:02.360 --> 11:04.360
你看a等e b等于2

11:04.360 --> 11:06.360
然后我们尝试把a改成3

11:06.360 --> 11:08.360
说收到一个警告

11:08.360 --> 11:10.360
这个警告告诉你什么呢

11:10.360 --> 11:11.360
告诉你

11:11.360 --> 11:13.360
你再设置一个操作

11:13.360 --> 11:14.360
给谁的

11:14.360 --> 11:16.360
设置的给属性t设置

11:16.360 --> 11:17.360
但是设置失败了

11:17.360 --> 11:19.360
它说设置的目标是只读的

11:20.360 --> 11:22.360
明白了意思吧

11:22.360 --> 11:24.360
而且不管是reactive

11:24.360 --> 11:25.360
还是read only

11:25.360 --> 11:26.360
它们都是深度的

11:26.360 --> 11:27.360
什么叫深度啊

11:27.360 --> 11:29.360
就是说这里边还掏了对象

11:29.360 --> 11:30.360
里边还掏对象没关系

11:30.360 --> 11:32.360
都是全都是数据享用时

11:32.360 --> 11:34.360
read only也是一样

11:34.360 --> 11:35.360
对象里边掏对象都是只读的

11:35.360 --> 11:37.360
全部都是只读的

11:37.360 --> 11:38.360
明白了意思吧

11:38.360 --> 11:40.360
好 那么read only

11:40.360 --> 11:41.360
它不仅仅是可以这样用

11:41.360 --> 11:44.360
你还可以把之前的这个对象

11:44.360 --> 11:45.360
这是个代理 对吧

11:45.360 --> 11:46.360
我们刚才说了

11:46.360 --> 11:49.360
read only里边不仅可以传这个play object

11:49.360 --> 11:50.360
还可以传个代理

11:50.360 --> 11:52.360
为什么要给大家讲那么详细啊

11:52.360 --> 11:54.360
就是害怕

11:54.360 --> 11:56.360
这些比较有难度的这些面试体

11:56.360 --> 11:57.360
里边可能会问到

11:57.360 --> 11:58.360
以后我们会看一些

11:58.360 --> 11:59.360
我想象中的

11:59.360 --> 12:01.360
可能会出现的比较有心的面试体

12:01.360 --> 12:03.360
state

12:03.360 --> 12:05.360
这read only我们后边还会用的

12:05.360 --> 12:07.360
将来在后边的时候我们再说

12:07.360 --> 12:09.360
你看我们传了一个代理

12:09.360 --> 12:10.360
这个玩意是不是代理

12:10.360 --> 12:11.360
传一个代理进去

12:11.360 --> 12:12.360
那么同样道理呢

12:12.360 --> 12:14.360
那么这个read only返回的

12:14.360 --> 12:16.360
又是一个新的代理

12:16.360 --> 12:17.360
你通过这个代理

12:17.360 --> 12:18.360
去访问这个代理的时候

12:18.360 --> 12:20.360
反正我不许你负职

12:20.360 --> 12:21.360
其他都好说

12:21.360 --> 12:23.360
反正不准你负职就完事了

12:23.360 --> 12:24.360
你看啊

12:24.360 --> 12:25.360
我们现在呢

12:25.360 --> 12:26.360
这个玩意啊

12:26.360 --> 12:28.360
能不能等于这个呢

12:28.360 --> 12:29.360
不等

12:29.360 --> 12:30.360
为什么呢

12:30.360 --> 12:31.360
因为这个read only

12:31.360 --> 12:32.360
这个read only寒说

12:32.360 --> 12:34.360
它会返回一个新的代理

12:34.360 --> 12:35.360
这个新的代理

12:35.360 --> 12:36.360
它只允许你

12:36.360 --> 12:38.360
读去只 不允许你负职

12:38.360 --> 12:39.360
明白了意思吧

12:39.360 --> 12:40.360
所以说

12:40.360 --> 12:41.360
这次原来的代理的

12:41.360 --> 12:43.360
相当于外面给掏了一个成代理

12:43.360 --> 12:45.360
它去代理它的时候

12:45.360 --> 12:46.360
你只允许读

12:46.360 --> 12:47.360
不能允许负职

12:47.360 --> 12:48.360
对吧

12:48.360 --> 12:49.360
然后我们来看一下

12:49.360 --> 12:50.360
这个set

12:50.360 --> 12:51.360
是这个值吗

12:51.360 --> 12:52.360
这个原式的值

12:52.360 --> 12:53.360
也是这个值吗

12:53.360 --> 12:54.360
那么现在我们尝试

12:54.360 --> 12:56.360
通过它去改动这个a

12:56.360 --> 12:58.360
这里可以慢慢去消化啊

12:58.360 --> 12:59.360
是不是不能改

12:59.360 --> 13:00.360
不能改了过后

13:00.360 --> 13:01.360
你看一下这个set

13:01.360 --> 13:02.360
是不是还是原来的值

13:02.360 --> 13:03.360
这个玩意set

13:03.360 --> 13:04.360
是不是还是原来的值

13:04.360 --> 13:06.930
因为改不了

13:06.930 --> 13:07.930
但是如果说

13:07.930 --> 13:08.930
我通过这个玩意

13:08.930 --> 13:09.930
能不能改呢

13:09.930 --> 13:10.930
这个是一个

13:10.930 --> 13:11.930
普通的响应识对象

13:11.930 --> 13:12.930
当然能改对不对

13:12.930 --> 13:13.930
当然能改

13:13.930 --> 13:14.930
看一下啊

13:15.930 --> 13:16.930
改了之后

13:16.930 --> 13:17.930
改了之后

13:17.930 --> 13:18.930
那么这个东西改就改了

13:18.930 --> 13:19.930
它也能改了

13:20.930 --> 13:21.930
为什么呢

13:21.930 --> 13:22.930
因为它们两个是一个东西

13:22.930 --> 13:23.930
对吧

13:23.930 --> 13:24.930
它代理的它

13:24.930 --> 13:25.930
它代理的它

13:25.930 --> 13:26.930
对吧

13:26.930 --> 13:27.930
是一串的东西

13:27.930 --> 13:28.930
你看一下

13:28.930 --> 13:29.930
好好去梳理一下

13:29.930 --> 13:30.930
这里就怕出面

13:30.930 --> 13:31.930
各种恶心的面识题

13:31.930 --> 13:32.930
它代理谁

13:32.930 --> 13:33.930
就是它如果说

13:33.930 --> 13:34.930
传普通对象的话

13:34.930 --> 13:35.930
都没啥事

13:35.930 --> 13:37.930
传了这种代理对象的话

13:37.930 --> 13:38.930
它代理它

13:38.930 --> 13:39.930
对吧

13:39.930 --> 13:40.930
它也去代理它

13:40.930 --> 13:41.930
代理这个玩意

13:41.930 --> 13:42.930
我通过它

13:42.930 --> 13:43.930
是不能去改动任何东西的

13:43.930 --> 13:44.930
对吧

13:44.930 --> 13:45.930
但是通过它

13:45.930 --> 13:46.930
是不能改

13:46.930 --> 13:47.930
把它改成山了

13:47.930 --> 13:48.930
改成山了过后

13:48.930 --> 13:49.930
它是不能读

13:49.930 --> 13:50.930
读出来就是山

13:50.930 --> 13:51.930
原来的意思吧

13:51.930 --> 13:52.930
它们平时在骂它

13:52.930 --> 13:53.930
不要这样

13:53.930 --> 13:54.930
一般不会这样子写

13:54.930 --> 13:55.930
一个

13:55.930 --> 13:56.930
但是有的情况也会出现

13:56.930 --> 13:57.930
我们一会儿

13:57.930 --> 13:58.930
可以看到一种题

13:59.930 --> 14:00.930
懂了意思吧

14:00.930 --> 14:01.930
好迅抵啊

14:01.930 --> 14:02.930
因为这一刻

14:02.930 --> 14:03.930
东西有一点绕

14:03.930 --> 14:04.930
但最难的地方

14:04.930 --> 14:06.930
也就是这些东西了

14:06.930 --> 14:07.930
好

14:07.930 --> 14:08.930
接下来我们来看

14:08.930 --> 14:09.930
下面两个

14:09.930 --> 14:10.930
有了这两个东西

14:10.930 --> 14:11.930
它为什么还要去

14:11.930 --> 14:12.930
什么Rave

14:12.930 --> 14:13.930
不挺好的吗

14:13.930 --> 14:14.930
这个玩意

14:14.930 --> 14:15.930
两个玩意够用了

14:15.930 --> 14:16.930
它为什么还可以

14:16.930 --> 14:17.930
设计这个玩意

14:17.930 --> 14:18.930
这是一个新的东西

14:18.930 --> 14:20.930
以前都没有的

14:21.930 --> 14:22.930
那为什么还可以

14:22.930 --> 14:23.930
设计这个玩意呢

14:24.930 --> 14:25.930
那你想一想

14:26.930 --> 14:27.930
我们这个玩意

14:27.930 --> 14:28.930
倒是能代理对象了

14:28.930 --> 14:29.930
那普通值咋办

14:30.930 --> 14:31.930
普通值咋办

14:31.930 --> 14:32.930
请问咋办

14:32.930 --> 14:33.930
人家提

14:33.930 --> 14:34.930
我要代理一个零

14:34.930 --> 14:35.930
咋办

14:36.930 --> 14:40.200
你看啊

14:40.200 --> 14:41.200
你想想这个道理

14:42.200 --> 14:43.200
State

14:43.200 --> 14:44.200
就Cort吧

14:45.200 --> 14:46.200
输出一下Cort

14:46.200 --> 14:47.200
你看啊

14:48.200 --> 14:49.200
它给你包了一个警告

14:49.200 --> 14:50.200
它说

14:51.200 --> 14:52.200
我这个人顶啊

14:52.200 --> 14:53.200
你这个属性

14:53.200 --> 14:54.200
你确实把我拦到了

14:55.200 --> 14:56.200
我真的没法给你做代理

14:57.200 --> 14:58.200
为什么呢

14:58.200 --> 14:59.200
它只能代理对象啊

14:59.200 --> 15:00.200
你看我们学的

15:00.200 --> 15:01.200
ES6里边Proxy

15:01.200 --> 15:02.200
是不是代理的是对象啊

15:02.200 --> 15:03.200
它能代理一个值

15:03.200 --> 15:04.200
值内行吗

15:04.200 --> 15:06.200
一个原式内行吗

15:06.200 --> 15:07.200
代理不了

15:08.200 --> 15:09.200
懂不懂意思吗

15:09.200 --> 15:10.200
它怎么代理嘛

15:10.200 --> 15:11.200
它给你返回个啥

15:11.200 --> 15:12.200
返回个零

15:12.200 --> 15:13.200
你看Cort不就

15:13.200 --> 15:14.200
它这个代理不了

15:14.200 --> 15:15.200
它就是Cort就是一个零

15:15.200 --> 15:16.200
就是个普通数据

15:16.200 --> 15:17.200
那你给这个Cort负值

15:17.200 --> 15:18.200
它能收到通知吗

15:19.200 --> 15:20.200
它就是一个普通数据啊

15:20.200 --> 15:22.200
就是一个普通的一个数字零

15:22.200 --> 15:24.200
它能收到任何通知吗

15:24.200 --> 15:25.200
它不能收到任何通知

15:26.200 --> 15:27.200
Cort

15:27.200 --> 15:29.200
它收到任何通知的

15:30.200 --> 15:31.200
懂了意思吧

15:31.200 --> 15:33.200
因为它不是一个对象

15:33.200 --> 15:34.200
那怎么办呢

15:34.200 --> 15:35.200
这个事情

15:35.200 --> 15:37.200
但是有了comparation API过后

15:37.200 --> 15:38.200
这些东西

15:38.200 --> 15:39.200
我们可能要

15:39.200 --> 15:40.200
把很多不同的数据

15:40.200 --> 15:41.200
分离出去

15:41.200 --> 15:42.200
然后避免的

15:42.200 --> 15:44.200
就会遇到这些原式值对象

15:44.200 --> 15:45.200
比方说

15:45.200 --> 15:46.200
一个字幕串

15:46.200 --> 15:47.200
我要把它做成一个想用式

15:47.200 --> 15:48.200
一个数字

15:48.200 --> 15:49.200
要把它做成想用式

15:49.200 --> 15:50.200
那么这种情况

15:50.200 --> 15:51.200
又怎么办呢

15:51.200 --> 15:52.200
它就给你做了

15:52.200 --> 15:53.200
这么一个东西

15:53.200 --> 15:54.200
出来叫Rave

15:54.200 --> 15:55.200
这个Rave

15:55.200 --> 15:57.200
它就可以代理任何数据

15:57.200 --> 15:59.200
管理是啥

15:59.200 --> 16:00.200
我就把它封装到

16:00.200 --> 16:01.200
一个对象里面去

16:01.200 --> 16:03.200
因为只有对象

16:03.200 --> 16:05.200
访问对象的属性

16:05.200 --> 16:06.200
你去访问

16:06.200 --> 16:07.200
一个对象的属性

16:07.200 --> 16:09.200
那么才有可能

16:09.200 --> 16:11.200
做想用式

16:11.200 --> 16:12.200
如果说你不是一个对象

16:12.200 --> 16:13.200
是一个原式值

16:13.200 --> 16:14.200
根本就做不了想用式

16:14.200 --> 16:16.200
所以这个Rave的作用是什么呢

16:16.200 --> 16:17.200
它就给你封装成了一个对象

16:17.200 --> 16:18.200
你看啊

16:18.200 --> 16:19.200
Rave的作用

16:19.200 --> 16:20.200
可以代理

16:20.200 --> 16:21.200
可以传入任何数据

16:21.200 --> 16:23.200
你传的是随便的传啥

16:23.200 --> 16:24.200
它可以放到一个对象的

16:24.200 --> 16:26.200
比例属性里面去

16:26.200 --> 16:27.200
这是我们之前用过的

16:27.200 --> 16:28.200
是不是

16:28.200 --> 16:29.200
靠着实际上打印出来

16:29.200 --> 16:30.200
是个啥呀

16:30.200 --> 16:31.200
你看

16:31.200 --> 16:32.200
不就是一个对象吧

16:32.200 --> 16:33.200
对象里面有一个什么

16:33.200 --> 16:34.200
一个比例属性

16:34.200 --> 16:35.200
那么这个

16:35.200 --> 16:37.200
通过访问这个比例属性

16:37.200 --> 16:38.200
是一个想用式的

16:38.200 --> 16:39.200
实际上这个白帝属性

16:39.200 --> 16:40.200
是怎么做出来的呢

16:40.200 --> 16:41.200
它是这样的

16:41.200 --> 16:44.200
这个Rave对象大概是这个样子

16:45.200 --> 16:46.200
我们学过ES6

16:47.200 --> 16:49.200
知道这么一个语法

16:50.200 --> 16:51.200
对不对

16:51.200 --> 16:52.200
不就是个访问器吗

16:52.200 --> 16:53.200
对吧

16:53.200 --> 16:54.200
这里边写

16:54.200 --> 16:55.200
这里边是不是收到通知

16:55.200 --> 16:56.200
读它的属性的时候

16:56.200 --> 16:57.200
是不是运行这个方法

16:57.200 --> 16:59.200
设置它的属性的时候

17:01.200 --> 17:03.200
是不是运行这个方法

17:03.200 --> 17:04.200
懂了意思吧

17:04.200 --> 17:05.200
它的白帝属性

17:05.200 --> 17:06.200
就是这样做出来的

17:06.200 --> 17:07.200
那么你读

17:07.200 --> 17:08.200
它会运行这个方法

17:08.200 --> 17:10.200
设置它会运行这个方法

17:10.200 --> 17:11.200
懂了意思吧

17:11.200 --> 17:12.200
就是这么个意思

17:13.200 --> 17:15.200
好 那么你再回过头来看

17:15.200 --> 17:17.200
那么它可以传入任何对象

17:17.200 --> 17:18.200
那么这里边

17:18.200 --> 17:20.200
以前没有讲过一个小的细节

17:20.200 --> 17:22.200
如果你给的Y6值

17:23.200 --> 17:25.200
是一个对象

17:25.200 --> 17:27.200
那它会怎么做呢

17:27.200 --> 17:28.200
你想一想

17:28.200 --> 17:29.200
如果它不处理的话

17:29.200 --> 17:30.200
会怎么样

17:30.200 --> 17:31.200
比方说

17:31.200 --> 17:32.200
你给它的Y6值

17:32.200 --> 17:35.920
它是一个对象

17:35.920 --> 17:36.920
普通时候我们知道了

17:36.920 --> 17:37.920
对吧

17:37.920 --> 17:39.920
我们现在看到过

17:39.920 --> 17:41.920
如果说它不处理的话

17:41.920 --> 17:42.920
它出来的结构

17:42.920 --> 17:43.920
可能是这个样子

17:43.920 --> 17:45.920
你读去这个Caught.b6的时候

17:47.920 --> 17:48.920
它出来的值

17:48.920 --> 17:49.920
不做任何处理的话

17:49.920 --> 17:51.920
那么出来的值是什么呢

17:51.920 --> 17:53.920
出来的值就是一个普通对象

17:53.920 --> 17:54.920
A等于1

17:54.920 --> 17:55.920
B等于2

17:55.920 --> 17:56.920
对吧 是不是

17:56.920 --> 17:57.920
都是一个普通对象

17:57.920 --> 17:59.920
那如果说你给的普通对象的F值

17:59.920 --> 18:00.920
它还有想用式吗

18:00.920 --> 18:02.920
是不是又没有想用式的

18:02.920 --> 18:03.920
给它的F值

18:03.920 --> 18:04.920
读去值

18:04.920 --> 18:05.920
复制 是不是都没有想用式的

18:05.920 --> 18:06.920
所以说当它

18:06.920 --> 18:08.920
如果约对象是有层次结构的

18:08.920 --> 18:09.920
所以它当这里

18:09.920 --> 18:10.920
它做一个特殊处理

18:10.920 --> 18:13.920
当它发现你给它的Y6值

18:13.920 --> 18:14.920
是一个对象

18:14.920 --> 18:15.920
就是这个VR

18:15.920 --> 18:16.920
是一个对象的话

18:16.920 --> 18:17.920
就这个VR

18:17.920 --> 18:18.920
是一个对象的话

18:18.920 --> 18:20.920
那么它会做什么处理呢

18:20.920 --> 18:23.920
它会把它调用一下Reactive

18:24.920 --> 18:25.920
就是它V

18:25.920 --> 18:27.920
它会把它调用这个Reactive

18:27.920 --> 18:28.920
也就是它

18:28.920 --> 18:29.920
会把这个Value变成什么

18:29.920 --> 18:31.920
变成一个Proxy

18:31.920 --> 18:32.920
你看

18:32.920 --> 18:34.920
打印出来是不是一个Proxy

18:34.920 --> 18:35.920
看没

18:35.920 --> 18:36.920
对吧

18:36.920 --> 18:37.920
那么普通值呢

18:37.920 --> 18:38.920
普通值它就是普通值

18:38.920 --> 18:39.920
那么如果说

18:39.920 --> 18:40.920
给它的对象变成一个Proxy

18:40.920 --> 18:42.920
目的是为了让这个Proxy

18:42.920 --> 18:44.920
对象里面的所有东西

18:44.920 --> 18:46.920
仍然是具有想用式的

18:46.920 --> 18:47.920
对吧

18:47.920 --> 18:48.920
所以说

18:48.920 --> 18:49.920
我们通过Rev也好

18:49.920 --> 18:50.920
通过这些东西

18:50.920 --> 18:52.920
得到的数据也好

18:52.920 --> 18:53.920
得到的数据

18:53.920 --> 18:54.920
全都是具有想用式的

18:54.920 --> 18:56.920
无论它属性泡的多么深

18:56.920 --> 18:57.920
全都是具有想用式的

18:57.920 --> 18:58.920
包括新增

18:58.920 --> 18:59.920
包括删除

18:59.920 --> 19:00.920
因为我们知道

19:00.920 --> 19:01.920
这是代理 对不对

19:01.920 --> 19:03.920
都是具有想用式的

19:03.920 --> 19:05.920
懂了那意思吗

19:05.920 --> 19:07.920
这就是Rev的做法

19:07.920 --> 19:11.130
那如果说

19:11.130 --> 19:13.130
这个Rev还有一种情况

19:13.130 --> 19:15.130
如果说你已经是代理了

19:15.130 --> 19:17.130
它就直接使用代理了

19:17.130 --> 19:18.130
啥意思呢

19:18.130 --> 19:19.130
就是说

19:19.130 --> 19:21.130
如果说这种情况

19:21.130 --> 19:23.130
这个玩意本身就是代理了

19:23.130 --> 19:24.130
对吧

19:24.130 --> 19:25.130
我把它变成Rev

19:25.130 --> 19:26.130
那么它这个Value

19:26.130 --> 19:27.130
它就是这个代理

19:27.130 --> 19:29.130
因为你本身就是代理了

19:29.130 --> 19:31.130
我还代理个啥呀

19:31.130 --> 19:32.130
我不是玩玩玩玩

19:32.130 --> 19:33.130
玩玩数据想的是吗

19:33.130 --> 19:34.130
所以Cos的Value

19:34.130 --> 19:35.130
你看一下

19:35.130 --> 19:37.130
是不是跟那个相等的

19:37.130 --> 19:38.130
跟那个State相等的

19:38.130 --> 19:39.130
我们来看一下

19:39.130 --> 19:41.130
保存 是不是Q

19:41.130 --> 19:42.130
对 是不是相等的

19:42.130 --> 19:43.130
对吧

19:43.130 --> 19:44.130
那么这里边都包含了

19:44.130 --> 19:46.130
很多的设计理念在里面

19:46.130 --> 19:48.130
目标只有一个

19:48.130 --> 19:49.130
让我们的所有数据

19:49.130 --> 19:53.130
都正常的能变成想用式

19:53.130 --> 19:55.130
那么Compute的也是一样的

19:55.130 --> 19:56.130
这是一个计算属性

19:56.130 --> 19:57.130
传入的是什么呢

19:57.130 --> 19:59.130
传入的是一个方形

19:59.130 --> 20:00.130
返回了什么呢

20:00.130 --> 20:01.130
返回了仍然是一个

20:01.130 --> 20:02.130
这种格式

20:02.130 --> 20:03.130
也就是Rev这种格式

20:03.130 --> 20:04.130
所以我们的数据想用式

20:04.130 --> 20:05.130
一共就两种格式

20:05.130 --> 20:06.130
一个是代理

20:06.130 --> 20:08.130
一个是这种格式

20:08.130 --> 20:10.130
那么Compute是什么意思呢

20:10.130 --> 20:12.130
就当我们读它的Value的时候

20:12.130 --> 20:14.130
它会根据情况决定

20:14.130 --> 20:15.130
是不是要运行这个函数

20:15.130 --> 20:16.130
来得到结果

20:16.130 --> 20:17.130
啥意思

20:17.130 --> 20:20.630
糟啊 这里可很糟

20:20.630 --> 20:21.630
但是呢

20:21.630 --> 20:24.630
你要就业

20:24.630 --> 20:25.630
那这些问题

20:25.630 --> 20:26.630
你是避不开的

20:26.630 --> 20:27.630
5U3里面最难的

20:27.630 --> 20:29.630
也就是这个地方了

20:29.630 --> 20:31.630
我后边告诉大家

20:31.630 --> 20:33.630
平时做开发的时候

20:33.630 --> 20:34.630
怎么呢 因为规避这些

20:34.630 --> 20:35.630
比较糟了点

20:35.630 --> 20:36.630
怎么去规避

20:36.630 --> 20:37.630
给大家讲一些

20:37.630 --> 20:41.630
如何去降低新制负担

20:41.630 --> 20:42.630
我们来看一下吧

20:42.630 --> 20:45.630
比方说我们这里一个Compute

20:45.630 --> 20:47.630
这边就有一个Reactive

20:47.630 --> 20:48.630
一个对象吧

20:48.630 --> 20:49.630
那么现在呢

20:49.630 --> 20:52.630
我们用一个Compute

20:52.630 --> 20:53.630
这里有一个函数

20:53.630 --> 20:54.630
这个函数的热结果

20:54.630 --> 20:56.630
我们这里输出一下

20:56.630 --> 20:57.630
Compute

20:57.630 --> 20:58.630
计算

20:58.630 --> 20:59.630
然后呢

20:59.630 --> 21:00.630
返回的是一个什么呢

21:00.630 --> 21:01.630
返回的是一个Stats

21:01.630 --> 21:03.630
A加上Stats就B

21:03.630 --> 21:07.140
好 那么我们得到的结果呢

21:07.140 --> 21:09.140
是不是一个Rave

21:09.140 --> 21:10.140
对不对

21:10.140 --> 21:12.140
我们这里得到一个就是

21:12.140 --> 21:15.140
上和 出和

21:15.140 --> 21:16.140
那么我们来看一下

21:16.140 --> 21:17.140
首先这个函

21:17.140 --> 21:18.140
这句话会不会输出呢

21:18.140 --> 21:19.140
它不会输出

21:19.140 --> 21:21.140
什么时候输出呢

21:21.140 --> 21:23.140
当我们要用它的时候

21:23.140 --> 21:24.140
就输出

21:24.140 --> 21:25.140
对吧

21:25.140 --> 21:26.140
但是如果说

21:26.140 --> 21:27.140
我们用了四次

21:27.140 --> 21:28.140
它会输出几次呢

21:28.140 --> 21:29.140
这个玩意儿

21:29.140 --> 21:30.140
它只会输出一次

21:30.140 --> 21:32.140
为什么 因为它有缓存

21:32.140 --> 21:33.140
只会过去这个

21:33.140 --> 21:35.140
计算属性是一样的

21:35.140 --> 21:36.140
有缓存

21:36.140 --> 21:38.140
也就是说根据情况

21:38.140 --> 21:40.140
决定是否要运行这个函数

21:40.140 --> 21:42.140
这个函数第一次运行的时候

21:42.140 --> 21:43.140
它没有缓存

21:43.140 --> 21:44.140
所以它会运行一次函数

21:44.140 --> 21:45.140
得到结果

21:45.140 --> 21:46.140
得到结果就是多少

21:46.140 --> 21:47.140
得到结果就是3

21:47.140 --> 21:48.140
对吧

21:48.140 --> 21:49.140
然后呢

21:49.140 --> 21:51.140
后边反复的用的时候

21:51.140 --> 21:52.140
因为它这里边依赖的东西

21:52.140 --> 21:53.140
依赖什么

21:53.140 --> 21:54.140
依赖A 依赖B

21:54.140 --> 21:55.140
这两个都是响应式数据

21:55.140 --> 21:56.140
那么这两个响应式数据

21:56.140 --> 21:57.140
没有变化

21:57.140 --> 21:58.140
没有变化

21:58.140 --> 21:59.140
它不会重新运行

21:59.140 --> 22:01.140
那什么时候会重新运行呢

22:01.140 --> 22:02.140
当我有一天

22:02.140 --> 22:03.140
把这个State.A

22:03.140 --> 22:07.140
变成了State.B等于

22:07.140 --> 22:09.140
变成这个玩意过后

22:09.140 --> 22:11.140
那么下一次你再读

22:11.140 --> 22:12.140
这个Values的时候

22:12.140 --> 22:14.140
它就会重新运行了

22:16.140 --> 22:17.140
保存你看

22:17.140 --> 22:19.140
是不是重新运行的Computer

22:19.140 --> 22:21.140
后边就不会再运行了

22:21.140 --> 22:22.140
它是这么一回事

22:22.140 --> 22:23.140
就是计算属性

22:23.140 --> 22:24.140
它得到了

22:24.140 --> 22:25.140
我们关键在于

22:25.140 --> 22:26.140
知道它得到的数据格式

22:26.140 --> 22:28.140
仍然是这种Ref格式

22:28.140 --> 22:29.140
我们把这种格式

22:29.140 --> 22:30.140
叫做Ref

22:31.140 --> 22:33.140
我们总结一下

22:33.140 --> 22:34.140
在5u3里面

22:34.140 --> 22:36.140
一共就量这么两种数据

22:36.140 --> 22:37.140
响应式格式

22:37.140 --> 22:38.140
一个是对象代理

22:38.140 --> 22:39.140
一个是Ref

22:39.140 --> 22:41.140
对象代理哪来的

22:41.140 --> 22:42.140
通过Rectin

22:42.140 --> 22:43.140
Pick a read only

22:43.140 --> 22:44.140
得到的

22:44.140 --> 22:45.140
这个代理

22:45.140 --> 22:46.140
那么这种格式

22:46.140 --> 22:47.140
哪来的

22:47.140 --> 22:48.140
通过Ref

22:48.140 --> 22:49.140
或者是Computer

22:49.140 --> 22:50.140
得到的

22:50.140 --> 22:51.140
好

22:51.140 --> 22:52.140
那么我们来看一下

22:52.140 --> 22:53.140
凭是我们写代码的时候

22:53.140 --> 22:54.140
怎么来用

22:54.140 --> 22:55.140
到底用哪一个

22:56.140 --> 22:59.140
如果说你想把整个对象

22:59.140 --> 23:01.140
变成一个响应式数据

23:01.140 --> 23:02.140
你有一个对象

23:02.140 --> 23:03.140
一个用户对象

23:03.140 --> 23:04.140
用户对象有什么

23:04.140 --> 23:05.140
姓名

23:05.140 --> 23:06.140
年龄

23:06.140 --> 23:07.140
大堆

23:07.140 --> 23:08.140
有个用户对象

23:08.140 --> 23:09.140
那么这个时候

23:09.140 --> 23:10.140
你可以使用Rectin

23:12.140 --> 23:13.140
也可以使用Ref

23:14.140 --> 23:16.140
那么你用Rectin得到的

23:16.140 --> 23:17.140
还是一个对象

23:17.140 --> 23:18.140
你用Ref得到的

23:18.140 --> 23:19.140
就要del y6了

23:19.140 --> 23:20.140
对吧

23:20.140 --> 23:21.140
就要del y6了

23:21.140 --> 23:22.140
懂了意思吗

23:22.140 --> 23:23.140
比方说

23:23.140 --> 23:24.140
你有一个用户对象

23:28.220 --> 23:30.220
就随便来个对象

23:31.220 --> 23:33.220
你用Rectin

23:35.220 --> 23:36.220
把它传进去

23:36.220 --> 23:37.220
传进去得到的结果

23:37.220 --> 23:38.220
就是一个proxy

23:39.220 --> 23:40.220
proxy

23:40.220 --> 23:41.220
proxy.a就等于

23:42.220 --> 23:43.220
proxy.b就等于2

23:44.220 --> 23:45.220
那如果说你用Ref

23:45.220 --> 23:46.220
放进去的

23:46.220 --> 23:47.220
把放到Ref里面去的

23:47.220 --> 23:48.220
那等到的就是一个

23:50.220 --> 23:51.220
Value

23:51.220 --> 23:52.220
Value是什么

23:52.220 --> 23:53.220
Value.a

23:54.220 --> 23:55.220
Value.b

23:56.220 --> 23:57.220
对吧

23:57.220 --> 23:58.220
两个不一样的

23:58.220 --> 24:00.220
这个Value是一个proxy

24:01.220 --> 24:02.220
懂了意思吧

24:02.220 --> 24:04.220
它两个格式不一样

24:06.910 --> 24:07.910
如果说

24:07.910 --> 24:08.910
你想要让一个对象的

24:08.910 --> 24:10.910
所有属性制度

24:10.910 --> 24:11.910
那你使用red only

24:13.910 --> 24:14.910
专门来做这个事的

24:14.910 --> 24:15.910
如果说

24:15.910 --> 24:16.910
你想要让一个

24:16.910 --> 24:17.910
非对象的数据

24:17.910 --> 24:18.910
不要一个字无串

24:18.910 --> 24:19.910
一个数字

24:19.910 --> 24:20.910
变成响应式数据

24:20.910 --> 24:21.910
它只能使用Ref

24:21.910 --> 24:22.910
Ref不是办不到

24:22.910 --> 24:23.910
它只能代理对象

24:23.910 --> 24:24.910
代理吗

24:24.910 --> 24:25.910
只能代理对象

24:25.910 --> 24:26.910
但是Ref

24:26.910 --> 24:27.910
它可以把任何东西

24:27.910 --> 24:28.910
封包装一个对象里面

24:29.910 --> 24:30.910
任何数据都可以

24:30.910 --> 24:31.910
变成响应式

24:32.910 --> 24:33.910
好

24:33.910 --> 24:34.910
如果说你要根据

24:34.910 --> 24:35.910
已知的响应式数据

24:35.910 --> 24:36.910
得到一个新的响应式数据

24:36.910 --> 24:38.910
那只能使用compule

24:39.910 --> 24:41.910
这就是这几种场景

24:42.910 --> 24:43.910
好 接下来

24:43.910 --> 24:44.910
我们来看

24:44.910 --> 24:46.910
两道比式题

24:46.910 --> 24:47.910
地道比式题

24:48.910 --> 24:49.910
比较长

24:49.910 --> 24:50.910
这些都是我自己出的

24:50.910 --> 24:51.910
你把这些题

24:51.910 --> 24:52.910
做出来了

24:52.910 --> 24:53.910
后续的题呢

24:53.910 --> 24:54.910
不成问题

24:55.910 --> 24:56.910
看一下吧

24:59.350 --> 25:00.350
来读一下

25:00.350 --> 25:01.350
你可以暂停视频

25:01.350 --> 25:03.350
再看一下这道题

25:03.350 --> 25:04.350
输出什么

25:04.350 --> 25:05.350
我们来分析一下

25:08.430 --> 25:09.430
好 我来分析

25:10.430 --> 25:11.430
首先呢

25:11.430 --> 25:12.430
得到一个数据响应式

25:12.430 --> 25:13.430
对吧

25:13.430 --> 25:14.430
这是一个代理State

25:15.430 --> 25:16.430
然后呢

25:16.430 --> 25:17.430
得到一个什么

25:17.430 --> 25:18.430
得到一个computed

25:18.430 --> 25:19.430
计算属性

25:19.430 --> 25:20.430
那么计算属性里面

25:20.430 --> 25:21.430
有一个输出语趣

25:21.430 --> 25:22.430
对不对

25:22.430 --> 25:23.430
然后返回来

25:23.430 --> 25:24.430
就是NASNAME

25:24.430 --> 25:25.430
凭借上一个first name

25:27.810 --> 25:28.810
接下来

25:28.810 --> 25:29.810
我们首先看这里

25:29.810 --> 25:30.810
这里会不会立即执行

25:32.810 --> 25:33.810
会不会

25:33.810 --> 25:34.810
不会

25:34.810 --> 25:35.810
我们说了

25:35.810 --> 25:36.810
计算属性这个函数

25:36.810 --> 25:37.810
什么时候执行

25:37.810 --> 25:39.810
当你调用计算属性

25:39.810 --> 25:40.810
调value的时候

25:40.810 --> 25:41.810
它才会执行

25:41.810 --> 25:42.810
其他的时候不会执行

25:43.810 --> 25:44.810
所以说这里

25:44.810 --> 25:45.810
不会有任何输出

25:45.810 --> 25:46.810
接下来输出什么

25:46.810 --> 25:47.810
输出State

25:48.810 --> 25:49.810
Ready

25:49.810 --> 25:52.250
好 接下来就输出

25:52.250 --> 25:53.250
Full Name is

25:56.250 --> 25:57.250
输出的时候

25:57.250 --> 25:58.250
这句话是不是要计算

25:58.250 --> 25:59.250
两个表达是

25:59.250 --> 26:00.250
第一个参数

26:00.250 --> 26:01.250
字面亮

26:01.250 --> 26:02.250
以下就出来了

26:02.250 --> 26:03.250
第二个参数是什么

26:03.250 --> 26:04.250
第二参数是不是点value

26:04.250 --> 26:05.250
这个时候在用它的value了

26:05.250 --> 26:06.250
那么这个时候

26:06.250 --> 26:07.250
用它的value

26:07.250 --> 26:08.250
是不是要运行这个函数

26:08.250 --> 26:10.250
那么于是这里输出什么

26:10.250 --> 26:11.250
Change

26:11.250 --> 26:12.250
对吧 运行这个函数

26:12.250 --> 26:14.250
这个函数的运行结果是什么

26:14.250 --> 26:15.250
是不是两个

26:15.250 --> 26:16.250
支不出来拼接

26:16.250 --> 26:17.250
对不对

26:17.250 --> 26:18.250
于是这句话

26:18.250 --> 26:19.250
把第一个参数确定了

26:19.250 --> 26:20.250
第二个参数确定了

26:20.250 --> 26:21.250
第二个参数的指示什么

26:21.250 --> 26:22.250
第二个参数的指示

26:22.250 --> 26:23.250
有灯区名吗

26:24.250 --> 26:25.250
那么于是

26:25.250 --> 26:27.250
输出了Full Name is

26:28.250 --> 26:34.560
灯区名

26:35.560 --> 26:36.560
这是第三句话

26:37.560 --> 26:38.560
好 第四句话

26:38.560 --> 26:39.560
那么这个时候

26:39.560 --> 26:40.560
又在电网上的value

26:40.560 --> 26:41.560
那么这个时候

26:41.560 --> 26:42.560
还要不要运行这个东西

26:42.560 --> 26:43.560
不运行了

26:43.560 --> 26:44.560
因为它有缓存

26:44.560 --> 26:45.560
所以说第四句话

26:45.560 --> 26:46.560
继续输出

26:47.560 --> 26:48.560
不会再运行券迹的

26:49.560 --> 26:50.560
好 这样我们继续

26:50.560 --> 26:52.560
得到的是一个read only

26:52.560 --> 26:54.560
通过它来得到一个read only

26:54.560 --> 26:55.560
止读

26:55.560 --> 26:56.560
那么这两个相不相等

26:56.560 --> 26:57.560
之前是不是给它演示过

26:57.560 --> 26:58.560
不相等

26:58.560 --> 26:59.560
它在外面掏了一层

26:59.560 --> 27:00.560
掏了一层过后

27:00.560 --> 27:01.560
这个代理

27:01.560 --> 27:02.560
你只能

27:02.560 --> 27:03.560
通过这个代理的

27:03.560 --> 27:04.560
只能读

27:05.560 --> 27:06.560
不能写

27:06.560 --> 27:07.560
我们之前是不是

27:07.560 --> 27:09.560
刚才画过这么一个东西

27:10.560 --> 27:11.560
这个玩意

27:11.560 --> 27:13.560
代理State

27:13.560 --> 27:14.560
State就代理

27:14.560 --> 27:15.560
那个对象

27:15.560 --> 27:16.560
对吧

27:16.560 --> 27:17.560
这个对象

27:17.560 --> 27:18.560
通过它是不能

27:19.560 --> 27:20.560
它也是个代理

27:20.560 --> 27:21.560
所以两个东西不一样的

27:21.560 --> 27:22.560
所以这里输出什么

27:22.560 --> 27:23.560
Force

27:24.560 --> 27:26.560
接下来我们又用一个Rave

27:27.560 --> 27:29.560
把State放到Rave里边

27:29.560 --> 27:30.560
Rave的Value

27:30.560 --> 27:31.560
等不等于这个呢

27:32.560 --> 27:33.560
是不相等的

27:33.560 --> 27:34.560
之前也说过

27:34.560 --> 27:35.560
通过Rave里边

27:35.560 --> 27:36.560
如果说

27:36.560 --> 27:37.560
传那个代理的话

27:37.560 --> 27:38.560
本身就代理了

27:38.560 --> 27:39.560
本身就相应式了

27:39.560 --> 27:40.560
那我还搞个毛

27:40.560 --> 27:41.560
不搞了

27:41.560 --> 27:42.560
Value本身就是个相应式

27:42.560 --> 27:43.560
放到一个Value里面就行了

27:46.260 --> 27:47.260
接下来

27:47.260 --> 27:48.260
我又把State

27:48.260 --> 27:49.260
通过它

27:49.260 --> 27:50.260
去改动数据

27:50.260 --> 27:51.260
FirstName

27:52.260 --> 27:53.260
改了过后

27:53.260 --> 27:54.260
首先这个玩意

27:54.260 --> 27:55.260
要不要运行

27:56.260 --> 27:57.260
不运行

27:57.260 --> 27:59.260
什么时候运行得完

27:59.260 --> 28:00.260
要堵

28:00.260 --> 28:01.260
要堵到个计算属性的Value的时候

28:01.260 --> 28:02.260
它才会运行

28:03.260 --> 28:04.260
这个时候不运行

28:04.260 --> 28:05.260
但是改了过后

28:05.260 --> 28:06.260
它那边改了

28:06.260 --> 28:07.260
是不是通过它也改了

28:07.260 --> 28:08.260
对吧

28:08.260 --> 28:09.260
所以通过它去得到

28:09.260 --> 28:10.260
FirstName和LastName的时候

28:10.260 --> 28:11.260
所以也改了

28:11.260 --> 28:12.260
改成什么呢

28:12.260 --> 28:13.260
FirstName等于乘

28:14.260 --> 28:15.260
然后呢

28:15.260 --> 28:16.260
LastName等于G

28:18.260 --> 28:20.260
好 接下来我们又得到ForName

28:20.260 --> 28:21.260
ForName这里

28:21.260 --> 28:22.260
堵它的Value

28:22.260 --> 28:23.260
这个时候要不要重新运行

28:23.260 --> 28:24.260
这个compute的了

28:24.260 --> 28:25.260
就要重新运行了

28:25.260 --> 28:26.260
因为它之前的数据改了

28:26.260 --> 28:27.260
对不对

28:27.260 --> 28:28.260
所以说这里呢

28:28.260 --> 28:29.260
又运行了这个Change

28:30.260 --> 28:31.260
Change运行的过后

28:31.260 --> 28:32.260
是不是得到一个新的FirstName

28:32.260 --> 28:33.260
拼接上LastName

28:33.260 --> 28:34.260
对吧

28:34.260 --> 28:35.260
那么得到的ForName

28:37.260 --> 28:38.260
ForName是什么

28:39.260 --> 28:40.260
G

28:40.260 --> 28:41.260
乘

28:41.260 --> 28:45.300
对不对

28:45.300 --> 28:47.300
好 下一次再得到ForName

28:47.300 --> 28:48.300
的时候呢

28:48.300 --> 28:49.300
因为它数据没变

28:49.300 --> 28:50.300
所以它的依赖没变

28:50.300 --> 28:51.300
所以说继续运行这个

28:52.300 --> 28:53.300
你看全都是脱离

28:53.300 --> 28:54.300
组建存在的

28:54.300 --> 28:55.300
这些响应是系统

28:56.300 --> 28:57.300
关了干嘛

28:57.300 --> 28:58.300
好 接下来继续

29:00.300 --> 29:01.300
下面

29:01.300 --> 29:03.300
我用了一个RateOnly

29:03.300 --> 29:05.300
把这个StateRate

29:06.300 --> 29:08.300
把这个RateV变成RateOnly

29:10.300 --> 29:11.300
你看

29:11.300 --> 29:12.300
这个RateV是啥

29:13.300 --> 29:15.300
你看一下这个StateRateV是啥

29:17.300 --> 29:18.300
不就是这么一个玩意吗

29:18.300 --> 29:19.300
不就是个普通对象吗

29:19.300 --> 29:20.300
普通对象里面一个Value值

29:20.300 --> 29:21.300
对吧

29:21.300 --> 29:22.300
这个Value值是具有想象式的

29:24.300 --> 29:26.300
那么我现在要做的事情

29:26.300 --> 29:28.300
是把这个玩意

29:29.300 --> 29:30.300
变成什么

29:30.300 --> 29:31.300
变成一个RateOnly

29:34.250 --> 29:35.250
那你想一想

29:35.250 --> 29:38.250
这个RateOnly的Value值

29:39.250 --> 29:41.250
这个RateOnly的Value值

29:41.250 --> 29:42.250
是不是等于它呢

29:43.250 --> 29:44.250
是不是等于它呢

29:47.140 --> 29:48.140
我把这个对象

29:48.140 --> 29:50.140
你就是给它一个普通对象

29:50.140 --> 29:53.140
你把普通对象变成一个RateOnly

29:53.140 --> 29:55.140
那么这个NIMState2

29:55.140 --> 29:57.140
不就是代理吗

29:57.140 --> 29:58.140
对不对

29:58.140 --> 29:59.140
代理谁

29:59.140 --> 30:00.140
代理

30:00.140 --> 30:01.140
代理这个玩意

30:02.140 --> 30:03.140
对吧

30:03.140 --> 30:04.140
是不是代理它

30:05.140 --> 30:06.140
那么代理它

30:06.140 --> 30:08.140
通过它去读这个Value值的时候

30:08.140 --> 30:09.140
读出来是啥

30:11.140 --> 30:12.140
读出来是啥

30:12.140 --> 30:13.140
不就是一个代理吗

30:13.140 --> 30:14.140
那么这个代理跟这个代理

30:16.140 --> 30:17.140
有没有区别

30:17.140 --> 30:18.140
肯定有区别的

30:18.140 --> 30:19.140
为什么呢

30:19.140 --> 30:21.140
因为通过它去读任何东西的时候

30:21.140 --> 30:22.140
全都是只读

30:22.140 --> 30:23.140
到底不能设置

30:23.140 --> 30:25.140
而通过它是不是可以设置

30:25.140 --> 30:26.140
它点Value是不是可以设置

30:26.140 --> 30:27.140
它的Value是个代理

30:27.140 --> 30:29.140
也就是你这样想吧

30:29.140 --> 30:31.140
它这个点Value

30:31.140 --> 30:32.140
它里面不是有那是NIM吗

30:32.140 --> 30:33.140
对吧

30:33.140 --> 30:34.140
是不是可以复职的

30:35.140 --> 30:36.140
通过这个玩意

30:36.140 --> 30:37.140
因为我们知道

30:37.140 --> 30:38.140
这个代理是深度代理

30:38.140 --> 30:39.140
因为通过这个玩意

30:39.140 --> 30:40.140
点Value

30:42.140 --> 30:43.140
那是NIM

30:43.140 --> 30:44.140
能不能复职

30:44.140 --> 30:45.140
肯定是不行的

30:45.140 --> 30:46.140
所以说两个肯定不一样

30:46.140 --> 30:47.140
因此得到的结果呢

30:47.140 --> 30:48.140
是False

30:48.140 --> 30:50.140
这是它最终的结果

30:52.140 --> 30:53.140
这种问题比较难

30:53.140 --> 30:54.140
我希望你们以后

30:54.140 --> 30:55.140
不要遇到这么难的问题

30:55.140 --> 30:57.140
但是我希望

30:57.140 --> 30:58.140
不点事

30:58.140 --> 30:59.140
看公司里面怎么

30:59.140 --> 31:01.140
看这个要求有多高了

31:01.140 --> 31:03.140
好了来吧来吧

31:03.140 --> 31:05.140
那我们来看一下这个结果

31:06.140 --> 31:07.140
你自己对到一下

31:08.140 --> 31:09.140
是不是这样子

31:10.140 --> 31:11.140
是不是这样子

31:11.140 --> 31:12.140
这样子这样子

31:13.140 --> 31:14.140
这是第一道面试题

31:14.140 --> 31:15.140
笔试题

31:15.140 --> 31:17.140
第二道笔试题

31:17.140 --> 31:18.140
还有两道笔试题

31:18.140 --> 31:19.140
再来看一下

31:19.140 --> 31:20.140
都是有可能

31:20.140 --> 31:21.140
有些东西那是有可能

31:21.140 --> 31:23.140
在你的开发中会用到的

31:23.140 --> 31:24.140
有些东西

31:24.140 --> 31:25.140
它可能是纯粹出体

31:25.140 --> 31:26.140
在考虑的理解

31:27.140 --> 31:28.140
API并不重要

31:28.140 --> 31:29.140
我们之前反而说了

31:29.140 --> 31:30.140
给大家想了过

31:30.140 --> 31:31.140
什么API不重要

31:31.140 --> 31:32.140
那为什么

31:32.140 --> 31:33.140
这么长一节可来说API呢

31:33.140 --> 31:35.140
所以它里面有很多概念

31:35.140 --> 31:36.140
这概念不理清

31:36.140 --> 31:37.140
要通过这些API

31:37.140 --> 31:39.140
才能把那些概念学习清楚

31:40.140 --> 31:41.140
然后学习清楚这些概念

31:41.140 --> 31:43.140
你才对5U的

31:43.140 --> 31:44.140
享用式数据

31:44.140 --> 31:45.140
以及我们下节课要讲的

31:45.140 --> 31:46.140
康布雷显API

31:46.140 --> 31:48.140
才会有一个深入的了解

31:48.140 --> 31:49.140
笔试题二

31:50.140 --> 31:51.140
那耳心的东西

31:51.140 --> 31:52.140
越来越多了

31:52.140 --> 31:53.140
咱们来看一下吧

31:53.140 --> 31:54.140
这个东西我就扔这

31:57.470 --> 31:59.470
他说有这么一个函数

31:59.470 --> 32:01.470
让你在这里把代码补权

32:02.470 --> 32:03.470
这个函数会返回什么呢

32:03.470 --> 32:04.470
返回三个东西

32:04.470 --> 32:05.470
这三个东西肯定都没有

32:05.470 --> 32:06.470
肯定是在这里

32:06.470 --> 32:08.470
肯定要定义三个东西对吧

32:08.470 --> 32:09.470
定义三个东西

32:09.470 --> 32:10.470
然后了一个什么

32:12.470 --> 32:13.470
肯定要去定义的

32:14.470 --> 32:15.470
然后了一个还有一个

32:16.470 --> 32:17.470
肯定要定义的

32:17.470 --> 32:18.470
那么他可以告诉你一场

32:18.470 --> 32:20.470
他说User是一个

32:20.470 --> 32:21.470
只读的用户对象

32:22.470 --> 32:24.470
是一个享用式数据

32:25.470 --> 32:26.470
那么肯定是通过

32:26.470 --> 32:27.470
read only创建的对吧

32:27.470 --> 32:28.470
默认是一个空对象

32:28.470 --> 32:30.470
来吧我们的一个来

32:30.470 --> 32:31.470
那肯定毫不疑问

32:31.470 --> 32:32.470
要不导入一个read only的

32:35.470 --> 32:37.470
导入一个read only再说

32:39.470 --> 32:40.470
好来吧那这个通过

32:40.470 --> 32:41.470
read only创建的时候

32:41.470 --> 32:42.470
可以这样写read only

32:42.470 --> 32:44.470
一开始个默认是个空对象

32:44.470 --> 32:46.470
只读的对不对

32:46.470 --> 32:47.470
但是那这个玩意呢

32:47.470 --> 32:48.470
又是一个函数

32:48.470 --> 32:50.470
那么这个玩意肯定是个函数

32:50.470 --> 32:52.470
传入什么传入用户姓名

32:52.470 --> 32:53.470
传入个name

32:57.490 --> 32:58.490
这个函数干嘛

32:59.490 --> 33:00.490
用于修改用户的对象

33:00.490 --> 33:01.490
那就矛盾就来了呗

33:02.490 --> 33:03.490
矛盾就来了

33:03.490 --> 33:04.490
这个是个read only

33:04.490 --> 33:05.490
他怎么咋修改

33:06.490 --> 33:07.490
咋修改

33:08.490 --> 33:09.490
你能这样子写吗

33:09.490 --> 33:10.490
你能这样子写吗

33:10.490 --> 33:11.490
你肯定不能这样子写

33:11.490 --> 33:12.490
他不是

33:12.490 --> 33:13.490
他修改不了对吧

33:13.490 --> 33:14.490
修改不了

33:15.490 --> 33:16.490
那好吧

33:17.490 --> 33:18.490
你好好理一下

33:19.490 --> 33:20.490
啥意思

33:20.490 --> 33:21.490
他这样子做的意思

33:21.490 --> 33:23.490
就是我对外暴露的东西

33:23.490 --> 33:24.490
暴露的东西

33:24.490 --> 33:25.490
就是他不能改

33:25.490 --> 33:26.490
你要改他的话

33:26.490 --> 33:28.490
必须要通过我给你提供的函数

33:28.490 --> 33:29.490
才能改

33:29.490 --> 33:30.490
你直接改他是不是行的

33:30.490 --> 33:32.490
也许对外暴露的东西是read only

33:32.490 --> 33:33.490
但是我在那一步

33:34.490 --> 33:35.490
他不是read only

33:36.490 --> 33:37.490
他是一个普通的reality

33:38.490 --> 33:39.490
也就是我们这儿呢

33:41.930 --> 33:42.930
user already

33:42.930 --> 33:44.930
就是一个原式的reality

33:45.930 --> 33:46.930
然后呢

33:46.930 --> 33:47.930
我的read only

33:47.930 --> 33:48.930
是通过他暴露出去的

33:49.930 --> 33:50.930
看呗

33:50.930 --> 33:51.930
我们就从通过这种模式来

33:52.930 --> 33:53.930
通过啥

33:53.930 --> 33:54.930
我用那个user

33:54.930 --> 33:55.930
这个read only

33:55.930 --> 33:56.930
它是代理啥

33:56.930 --> 33:57.930
代理user already

33:58.930 --> 33:59.930
它是代理啥

33:59.930 --> 34:00.930
代理的空对象

34:00.930 --> 34:01.930
对吧

34:01.930 --> 34:02.930
通过他是不是可以改

34:02.930 --> 34:03.930
通过他是不是不能改

34:03.930 --> 34:04.930
我对外暴露的是不是他

34:04.930 --> 34:05.930
那么对外面的人士

34:05.930 --> 34:06.930
他就不能改的

34:06.930 --> 34:07.930
这像啥呀

34:08.930 --> 34:09.930
是不是有点像

34:09.930 --> 34:10.930
vux

34:11.930 --> 34:12.930
像不像

34:13.930 --> 34:14.930
vx是不是不允许你

34:14.930 --> 34:15.930
在外面去直接改数据

34:15.930 --> 34:16.930
必须要通过什么

34:16.930 --> 34:17.930
mortality

34:17.930 --> 34:18.930
x

34:18.930 --> 34:19.930
对不对

34:19.930 --> 34:20.930
我们会不会专门来讲

34:20.930 --> 34:21.930
vx的问题

34:21.930 --> 34:22.930
在vux3里面

34:22.930 --> 34:23.930
那里看一下

34:23.930 --> 34:24.930
我们现在呢

34:24.930 --> 34:25.930
vv

34:25.930 --> 34:26.930
那我这里怎么改呢

34:26.930 --> 34:27.930
是不是通过他去改

34:27.930 --> 34:28.930
就完了吗

34:28.930 --> 34:29.930
通过他去改不就完了

34:30.930 --> 34:31.930
好 那么这里呢

34:31.930 --> 34:32.930
还有什么

34:32.930 --> 34:34.930
set user age

34:34.930 --> 34:35.930
对吧

34:35.930 --> 34:36.930
age 给我传进来

34:37.930 --> 34:39.930
user orange age

34:39.930 --> 34:40.930
等于什么 age

34:40.930 --> 34:41.930
所以可以了

34:41.930 --> 34:42.930
这个函数就不写完了

34:42.930 --> 34:43.930
那如果说

34:43.930 --> 34:44.930
你要测试一下

34:45.930 --> 34:46.930
你要测试的话

34:46.930 --> 34:47.930
我们这里输出一下吧

34:48.930 --> 34:51.930
change user name

34:51.930 --> 34:52.930
都不用去测试

34:52.930 --> 34:53.930
这个就是个函数

34:53.930 --> 34:54.930
我们来看一下吧

34:54.930 --> 34:56.930
调一个use user

35:00.260 --> 35:02.260
好 那么我们比方说

35:02.260 --> 35:03.260
拿到三个东西

35:03.260 --> 35:04.260
一个user

35:04.260 --> 35:06.260
一个set user name

35:06.260 --> 35:08.260
一个什么set user age

35:08.260 --> 35:09.260
对吧

35:09.260 --> 35:10.260
拿到三个东西

35:11.260 --> 35:12.260
好 来吧

35:12.260 --> 35:13.260
我们再输出去

35:13.260 --> 35:14.260
先输出一下这个user

35:15.260 --> 35:16.260
它肯定是read only的

35:16.260 --> 35:17.260
肯定啥都没有

35:17.260 --> 35:18.260
目前啥都没有

35:18.260 --> 35:19.260
然后呢

35:19.260 --> 35:20.260
我们通过什么

35:20.260 --> 35:21.260
user.name

35:21.260 --> 35:22.260
去改动他的东西

35:22.260 --> 35:23.260
能改动吗

35:23.260 --> 35:24.260
随便写

35:25.260 --> 35:26.260
对吧 说改不了

35:26.260 --> 35:27.260
他说怎么还是read only的

35:27.260 --> 35:28.260
你改了也没用

35:29.260 --> 35:30.260
那么我们只能通过

35:30.260 --> 35:32.260
他跟我们提供的函数去改

35:32.260 --> 35:34.260
比方说set user name

35:35.260 --> 35:37.260
比方说molec

35:37.260 --> 35:39.260
然后set user age

35:40.260 --> 35:41.260
比方说18

35:41.260 --> 35:43.260
再输出一下user

35:44.260 --> 35:45.260
是不是只能通过

35:45.260 --> 35:46.260
提供的函数去改

35:47.260 --> 35:48.260
可以完成这么一个东西

35:49.260 --> 35:50.260
跟什么唯有组件

35:50.260 --> 35:51.260
跟那些东西完全没关系

35:51.260 --> 35:52.260
就是一个普通的函数

35:52.260 --> 35:53.260
介绍函数

35:53.260 --> 35:54.260
他把这东西全部抽离出来了

35:56.260 --> 35:57.260
可以玩说很多花样

35:58.260 --> 36:00.260
好 这是第二道彼此题

36:00.260 --> 36:01.260
第三道彼此题

36:03.260 --> 36:04.260
这个题呢

36:04.260 --> 36:05.260
又有点难度了

36:08.150 --> 36:09.150
来吧

36:09.150 --> 36:13.300
这是一个做函数访斗的

36:14.300 --> 36:16.300
对响应式数据访斗的

36:16.300 --> 36:17.300
什么意思呢

36:17.300 --> 36:18.300
就是说

36:18.300 --> 36:19.300
响应式数据里边

36:19.300 --> 36:20.300
有些数据变化了呢

36:22.300 --> 36:23.300
我不立刻应用到

36:23.300 --> 36:24.300
这个数据里边去

36:24.300 --> 36:25.300
我要等一会

36:25.300 --> 36:26.300
等多久呢

36:26.300 --> 36:28.300
这个地方传一个好秒数

36:28.300 --> 36:29.300
啥意思呢

36:29.300 --> 36:31.300
就是说我这里有use debounce

36:31.300 --> 36:33.300
比方说传个对象进去

36:35.300 --> 36:36.300
比方说a等于1

36:36.300 --> 36:37.300
就随便先传

36:37.300 --> 36:38.300
b等于2

36:38.300 --> 36:39.300
我传一个

36:40.300 --> 36:41.300
一秒钟

36:42.300 --> 36:43.300
一秒钟

36:44.300 --> 36:45.300
啥意思呢

36:45.300 --> 36:47.300
我这里最后会得到一个东西

36:47.300 --> 36:48.300
最后得到一个value值

36:49.300 --> 36:50.300
一个什么呢

36:50.300 --> 36:51.300
set value

36:51.300 --> 36:52.300
一个函数

36:53.300 --> 36:54.300
我的value值

36:54.300 --> 36:55.300
其实就是一个

36:55.300 --> 36:56.300
指读的东西

36:56.300 --> 36:57.300
你不能在value值里面改

36:57.300 --> 36:58.300
一个value值得到的结果

36:58.300 --> 36:59.300
就是a等于1b等于2

37:00.300 --> 37:01.300
懂了意思吧

37:01.300 --> 37:02.300
但是它是指读的

37:02.300 --> 37:03.300
你不能改它

37:03.300 --> 37:04.300
value值你不能直接

37:04.300 --> 37:05.300
通过它去改

37:05.300 --> 37:06.300
a等于3

37:06.300 --> 37:07.300
不行的

37:07.300 --> 37:08.300
它是指读的

37:08.300 --> 37:10.300
我要改数据怎么办呢

37:10.300 --> 37:11.300
我要通过set value去改

37:11.300 --> 37:12.300
比方我改成

37:12.300 --> 37:13.300
我怎么改呢

37:13.300 --> 37:14.300
我要把a改成5

37:14.300 --> 37:15.300
就这样改

37:15.300 --> 37:16.300
它会把你传个对象

37:16.300 --> 37:18.300
混入到之前的对象里面去

37:19.300 --> 37:20.300
懂了意思吗

37:20.300 --> 37:22.300
它会这样来处理

37:23.300 --> 37:24.300
那么现在我只能

37:24.300 --> 37:26.300
我只能通过它去改

37:26.300 --> 37:28.300
那么通过它去改了过后

37:28.300 --> 37:29.300
它不是立即改

37:29.300 --> 37:31.300
它是要在一秒钟过后

37:32.300 --> 37:33.300
防抖嘛对吧

37:33.300 --> 37:34.300
那么这个一做过

37:34.300 --> 37:35.300
这里再输出什么

37:35.300 --> 37:37.300
再输出value点a

37:37.300 --> 37:38.300
它还是a

37:38.300 --> 37:39.300
要等一秒钟过后

37:39.300 --> 37:41.300
它才会变成5

37:41.300 --> 37:42.300
就这么个意思

37:42.300 --> 37:43.300
就这么个意思

37:43.300 --> 37:44.300
那么这个还是这么弄

37:47.250 --> 37:48.250
首先value值

37:48.250 --> 37:49.250
它的内部是不是能改

37:49.250 --> 37:51.250
那么还跟刚才一样的

37:51.250 --> 37:52.250
倒入

37:53.250 --> 37:54.250
这里呢

37:54.250 --> 37:55.250
我们倒入reactive

37:55.250 --> 37:56.250
倒入read only

37:56.250 --> 37:57.250
因为它对外

37:57.250 --> 37:58.250
暴露出来是一个read only

37:58.250 --> 37:59.250
对吧

37:59.250 --> 38:00.250
然后这里呢

38:00.250 --> 38:01.250
模具是一样的

38:01.250 --> 38:03.250
通过reactive

38:03.250 --> 38:05.250
默认值是OBG

38:05.250 --> 38:06.250
对吧

38:06.250 --> 38:07.250
得到一个什么

38:07.250 --> 38:08.250
得到一个state

38:08.250 --> 38:10.250
就是state

38:10.250 --> 38:11.250
那就是orange

38:11.250 --> 38:12.250
value

38:12.250 --> 38:13.250
orange

38:13.250 --> 38:14.250
是吧

38:14.250 --> 38:16.250
原式的这个

38:16.250 --> 38:17.250
响应对象

38:17.250 --> 38:18.250
它是可以改的

38:18.250 --> 38:20.250
然后还暴露出一个read only的

38:21.250 --> 38:22.250
read only的

38:22.250 --> 38:23.250
value

38:23.250 --> 38:24.250
orange

38:24.250 --> 38:25.250
对吧

38:25.250 --> 38:26.250
把这个value暴露出去

38:27.250 --> 38:28.250
是吧

38:28.250 --> 38:29.250
还要提供一个

38:29.250 --> 38:30.250
sysvalue函数

38:31.250 --> 38:32.250
这个函数

38:32.250 --> 38:33.250
你给我传一个

38:33.250 --> 38:34.250
什么呢

38:34.250 --> 38:35.250
new value

38:35.250 --> 38:36.250
进来

38:36.250 --> 38:37.250
我要干嘛呢

38:37.250 --> 38:38.250
我要把这个new value

38:38.250 --> 38:39.250
它里边的所有属讯

38:39.250 --> 38:40.250
混入到什么

38:40.250 --> 38:41.250
混入到

38:42.250 --> 38:43.250
原来的属讯里边

38:44.250 --> 38:45.250
对吧

38:45.250 --> 38:46.250
这个地方其实很简单

38:46.250 --> 38:47.250
其实很简单

38:47.250 --> 38:48.250
我有一个object

38:48.250 --> 38:49.250
这个key

38:49.250 --> 38:50.250
intress

38:51.250 --> 38:52.250
intress

38:53.250 --> 38:54.250
intress

38:54.250 --> 38:55.250
new value传进去

38:55.250 --> 38:56.250
new value传进去

38:56.250 --> 38:57.250
是不是对象

38:57.250 --> 38:58.250
拿到是不是一个key

38:58.250 --> 39:00.250
一个原组

39:00.250 --> 39:01.250
对不对

39:03.250 --> 39:04.250
展开key

39:04.250 --> 39:05.250
一个key

39:05.250 --> 39:06.250
一个value

39:06.250 --> 39:07.250
把这个新的对象

39:07.250 --> 39:08.250
所有的属性名

39:08.250 --> 39:09.250
属性值打到

39:10.250 --> 39:11.250
要干嘛呢

39:11.250 --> 39:12.250
然后把这个value

39:12.250 --> 39:13.250
orange

39:13.250 --> 39:14.250
里边的什么

39:14.250 --> 39:15.250
这个key值等于

39:15.250 --> 39:16.250
这个v值

39:16.250 --> 39:17.250
重新复制

39:17.250 --> 39:18.250
它是具有数据想用式的

39:18.250 --> 39:19.250
对吧

39:19.250 --> 39:20.250
那么把这个数据

39:20.250 --> 39:21.250
重新给它复制

39:22.250 --> 39:23.250
能看懂吗

39:23.250 --> 39:24.250
它有混入吗

39:24.250 --> 39:25.250
混入

39:25.250 --> 39:26.250
这没什么好说的

39:27.250 --> 39:28.250
好

39:28.250 --> 39:29.250
那么现在问题是

39:29.250 --> 39:30.250
这件事是不是

39:30.250 --> 39:31.250
第一集做呢

39:31.250 --> 39:32.250
不是

39:32.250 --> 39:33.250
它稍微防抖的

39:33.250 --> 39:34.250
它要在这个时间

39:34.250 --> 39:35.250
判内去做

39:35.250 --> 39:36.250
那是不是我们

39:36.250 --> 39:37.250
定一个time

39:37.250 --> 39:38.250
就完成了

39:38.250 --> 39:39.250
在这里定一个time

39:39.250 --> 39:40.250
等于now

39:40.250 --> 39:41.250
对吧

39:41.250 --> 39:42.250
那如果说

39:42.250 --> 39:43.250
每一次来的过

39:43.250 --> 39:44.250
管它三十二十一

39:44.250 --> 39:45.250
这个timeout该清了

39:45.250 --> 39:46.250
timeout

39:46.250 --> 39:48.250
timeout该清空了

39:48.250 --> 39:49.250
然后呢

39:49.250 --> 39:50.250
我们再重新设置一个

39:50.250 --> 39:51.250
对吧

39:51.250 --> 39:52.250
settimeout

39:52.250 --> 39:53.250
diration

39:53.250 --> 39:54.250
等待这么一段时间

39:54.250 --> 39:55.250
过后

39:55.250 --> 39:56.250
我再去做这个事

39:57.250 --> 39:58.250
对不对

39:58.250 --> 39:59.250
那么我们为了

39:59.250 --> 40:00.250
看到效果

40:00.250 --> 40:01.250
我们在这里输出一下

40:01.250 --> 40:02.250
值

40:02.250 --> 40:05.710
改变了

40:05.710 --> 40:06.710
能看懂吗

40:06.710 --> 40:09.280
好

40:09.280 --> 40:10.280
那么我们来试一下

40:10.280 --> 40:11.280
为了让你们

40:11.280 --> 40:12.280
看到这个效果

40:12.280 --> 40:13.280
我这里

40:13.280 --> 40:14.280
还是一样

40:14.280 --> 40:15.280
把这个value

40:15.280 --> 40:17.910
保存到window里边

40:17.910 --> 40:18.910
然后呢

40:18.910 --> 40:19.910
value呢

40:19.910 --> 40:20.910
也保存了

40:20.910 --> 40:23.860
window里边

40:23.860 --> 40:24.860
好

40:24.860 --> 40:25.860
保存

40:25.860 --> 40:26.860
来看

40:26.860 --> 40:27.860
value呢

40:27.860 --> 40:28.860
我肯定不能直接改

40:28.860 --> 40:29.860
改了没用

40:29.860 --> 40:30.860
它说呢

40:30.860 --> 40:31.860
它是这个指读数据

40:31.860 --> 40:32.860
你看一下这个value

40:32.860 --> 40:33.860
还是没变

40:33.860 --> 40:34.860
那我要改怎么办

40:34.860 --> 40:35.860
那我只能通过

40:35.860 --> 40:36.860
set value去改

40:36.860 --> 40:38.860
表中改了一个a等于3

40:38.860 --> 40:39.860
改了过后

40:39.860 --> 40:40.860
value

40:40.860 --> 40:41.860
你看

40:41.860 --> 40:42.860
一秒钟过后

40:42.860 --> 40:43.860
我把它直传长一点吧

40:43.860 --> 40:44.860
五秒钟

40:45.860 --> 40:46.860
我只能通过这个

40:46.860 --> 40:47.860
set value去改

40:47.860 --> 40:48.860
a等于3

40:48.860 --> 40:49.860
我们来看一下value

40:49.860 --> 40:50.860
还是没变

40:50.860 --> 40:51.860
它要等了5秒钟

40:51.860 --> 40:52.860
做之后

40:52.860 --> 40:53.860
防抖吗

40:53.860 --> 40:54.860
对吧

40:54.860 --> 40:55.860
只才改变了

40:55.860 --> 40:56.860
是吧

40:56.860 --> 40:57.860
那我们现在把它变

40:57.860 --> 40:58.860
又来变成

40:58.860 --> 40:59.860
变成5

40:59.860 --> 41:00.860
但是我们不停的变

41:00.860 --> 41:01.860
不停的变

41:01.860 --> 41:02.860
不停的变

41:02.860 --> 41:03.860
防抖吗

41:03.860 --> 41:04.860
对不对

41:04.860 --> 41:05.860
防抖吗

41:05.860 --> 41:06.860
它是不是一直清空

41:06.860 --> 41:07.860
那个计时器

41:07.860 --> 41:08.860
一直等待5秒

41:08.860 --> 41:09.860
对不对

41:09.860 --> 41:10.860
防抖吗

41:10.860 --> 41:11.860
等了

41:11.860 --> 41:12.860
等5秒钟过后

41:12.860 --> 41:13.860
只改变了

41:13.860 --> 41:14.860
看没

41:14.860 --> 41:15.860
那么这些东西

41:15.860 --> 41:16.860
是不是可以把封装

41:16.860 --> 41:17.860
对吧

41:17.860 --> 41:18.860
我做很多花样子

41:18.860 --> 41:19.860
比方说这是一个

41:19.860 --> 41:20.860
到比斯提

41:21.860 --> 41:22.860
有点难度了

41:22.860 --> 41:23.860
对吧

41:23.860 --> 41:24.860
有点糟了

41:24.860 --> 41:25.860
今天这个课

41:25.860 --> 41:29.300
要慢慢去消化

41:29.300 --> 41:30.300
好

41:30.300 --> 41:31.300
接下来我们下一个

41:31.300 --> 41:32.300
想用数据

41:32.300 --> 41:33.300
一共

41:33.300 --> 41:34.300
获取想用数据

41:34.300 --> 41:35.300
一共就这么几种方式

41:35.300 --> 41:36.300
再看一下

41:36.300 --> 41:39.300
它的格式就这么两种

41:39.300 --> 41:40.300
对吧

41:40.300 --> 41:41.300
前两种获取再代理

41:41.300 --> 41:42.300
后两种获取

41:42.300 --> 41:43.300
Ref

41:43.300 --> 41:44.300
接下来下一个

41:44.300 --> 41:45.300
监听

41:45.300 --> 41:47.810
要监听

41:47.810 --> 41:48.810
就是数据变了

41:48.810 --> 41:49.810
我要做一些事

41:49.810 --> 41:50.810
去监听

41:51.810 --> 41:52.810
我这里

41:52.810 --> 41:53.810
再复制一个吧

41:54.810 --> 41:55.810
去掉

41:56.810 --> 41:58.810
我们之前用过了啥

41:58.810 --> 41:59.810
Waterfee effect

41:59.810 --> 42:00.810
对不对

42:00.810 --> 42:01.810
这是比较常见的

42:01.810 --> 42:03.810
这个顺便说一下

42:03.810 --> 42:04.810
它返回的

42:04.810 --> 42:05.810
是一个函数

42:05.810 --> 42:06.810
这个函数

42:06.810 --> 42:07.810
它返回一个函数

42:07.810 --> 42:08.810
这个函数就停滞监听

42:08.810 --> 42:09.810
就这么简单

42:09.810 --> 42:10.810
一般来说

42:10.810 --> 42:11.810
我们也不会去

42:11.810 --> 42:12.810
怎么停滞监听

42:12.810 --> 42:13.810
有的时候也可以

42:13.810 --> 42:14.810
也可能会需要

42:14.810 --> 42:15.810
无所谓吧

42:15.810 --> 42:16.810
给大家说一下

42:16.810 --> 42:17.810
它返回一个函数

42:17.810 --> 42:18.810
掉那个函数

42:18.810 --> 42:19.810
这函数就停滞监听了

42:19.810 --> 42:20.810
啥意思呢

42:21.810 --> 42:22.810
就这个里边的

42:22.810 --> 42:23.810
传的函数

42:23.810 --> 42:24.810
传那个函数进去

42:24.810 --> 42:25.810
这个函数会立即执行

42:25.810 --> 42:27.810
我们之前用过了对吧

42:30.810 --> 42:31.810
这个函数会立即执行

42:31.810 --> 42:33.810
然后这个函数里边

42:33.810 --> 42:34.810
它有可能会用到

42:34.810 --> 42:35.810
一些响应数据

42:35.810 --> 42:36.810
不管是

42:37.810 --> 42:38.810
不管是哪种响应数据

42:38.810 --> 42:39.810
只要是响应数据

42:39.810 --> 42:40.810
它是但有响应式的

42:41.810 --> 42:42.810
那么它就会收集一难

42:42.810 --> 42:43.810
就表示说

42:44.810 --> 42:45.810
我这个函数

42:45.810 --> 42:47.810
一难了这里边一些东西

42:50.120 --> 42:51.120
导入一个

42:52.120 --> 42:53.120
reactive

42:54.120 --> 42:55.120
from view

42:56.120 --> 42:57.120
reactive

42:58.120 --> 42:59.120
导入一个

42:59.120 --> 43:00.120
ref

43:00.120 --> 43:02.120
再导入一个watch effect

43:03.120 --> 43:04.120
来吧

43:04.120 --> 43:05.120
我们这里有两个

43:05.120 --> 43:06.120
响应数据

43:06.120 --> 43:07.120
一个state

43:07.120 --> 43:08.120
reactive

43:08.120 --> 43:09.120
这里边就a

43:09.120 --> 43:10.120
等于e

43:10.120 --> 43:11.120
b等于2

43:11.120 --> 43:12.120
然后它有一个

43:12.120 --> 43:13.120
called

43:14.120 --> 43:15.120
ref

43:15.120 --> 43:16.120
0

43:17.120 --> 43:18.120
来吧

43:18.120 --> 43:19.120
watch effect

43:22.710 --> 43:23.710
输出

43:23.710 --> 43:24.710
输出state

43:25.710 --> 43:26.710
点a

43:27.710 --> 43:28.710
然后输出

43:28.710 --> 43:29.710
caught

43:29.710 --> 43:30.710
点value

43:31.710 --> 43:32.710
这边有两个响应数据

43:32.710 --> 43:33.710
一个是什么

43:33.710 --> 43:34.710
这个玩意儿

43:34.710 --> 43:35.710
a对吧

43:35.710 --> 43:36.710
a是不响应式的

43:36.710 --> 43:37.710
肯定是响应式的

43:37.710 --> 43:38.710
caught的玩意儿

43:38.710 --> 43:39.710
是不是响应式的

43:39.710 --> 43:40.710
肯定是响应式的

43:40.710 --> 43:42.710
用了两个响应数据数据

43:42.710 --> 43:43.710
因此watch effect

43:43.710 --> 43:44.710
首先第一个特点

43:44.710 --> 43:45.710
它马上会执行一次

43:45.710 --> 43:46.710
一和零

43:47.710 --> 43:48.710
是马上会执行一次

43:48.710 --> 43:49.710
然后了

43:49.710 --> 43:51.710
将来数据变化了之后

43:51.710 --> 43:52.710
比方说

43:52.710 --> 43:53.710
state

43:53.710 --> 43:54.710
第二

43:54.710 --> 43:55.710
b

43:55.710 --> 43:56.710
加加

43:56.710 --> 43:58.710
会不会导致这里变化

43:58.710 --> 43:59.710
不会

43:59.710 --> 44:00.710
因为它里面不依赖b

44:00.710 --> 44:01.710
对吧

44:01.710 --> 44:02.710
不依赖b

44:02.710 --> 44:03.710
那么这里说

44:03.710 --> 44:04.710
要设计到一个问题

44:04.710 --> 44:05.710
它怎么知道依赖谁呢

44:05.710 --> 44:06.710
因为你这里

44:06.710 --> 44:08.710
既然是响应式数据

44:08.710 --> 44:09.710
那么

44:09.710 --> 44:10.710
响应式数据

44:10.710 --> 44:11.710
读取的时候

44:11.710 --> 44:12.710
是不是要运行get方法

44:12.710 --> 44:13.710
get方法里面

44:13.710 --> 44:15.710
会收集这个依赖

44:15.710 --> 44:16.710
这是设计要远吧

44:16.710 --> 44:17.710
成面了

44:18.710 --> 44:19.710
没有用到的数据

44:19.710 --> 44:20.710
它不会管

44:20.710 --> 44:21.710
那么如果说a加加

44:21.710 --> 44:24.280
你看

44:24.280 --> 44:25.280
是不是又会运行

44:25.280 --> 44:26.280
对吧

44:26.280 --> 44:27.280
就是watch effect

44:27.280 --> 44:28.280
非常智能的

44:28.280 --> 44:29.280
它能自动收集依赖

44:30.280 --> 44:31.280
依赖向改变的时候

44:31.280 --> 44:32.280
它会重新运行

44:35.870 --> 44:36.870
注意啊

44:36.870 --> 44:37.870
它如果说数据改变过后

44:37.870 --> 44:39.870
如果说同时改变了很多次

44:40.870 --> 44:41.870
包括cult

44:41.870 --> 44:42.870
给value加加

44:42.870 --> 44:44.870
那么它会运行几次呢

44:44.870 --> 44:45.870
这里要告诉大家

44:45.870 --> 44:47.870
它是一个异部的

44:47.870 --> 44:49.870
它是会到v队里面

44:49.870 --> 44:50.870
因此

44:51.870 --> 44:52.870
把数据变完了过后

44:52.870 --> 44:53.870
它才会运行

44:53.870 --> 44:54.870
6

44:54.870 --> 44:55.870
4

44:55.870 --> 44:56.870
只会运行一次

44:57.870 --> 44:58.870
这是watch effect

45:01.250 --> 45:03.250
下面一个watch

45:03.250 --> 45:04.250
这个东西就相当于

45:04.250 --> 45:05.250
是512的watch

45:05.250 --> 45:06.250
这个用起来

45:06.250 --> 45:07.250
要稍微复杂一点

45:07.250 --> 45:08.250
要稍微绕一点

45:08.250 --> 45:09.250
不过这个东西

45:09.250 --> 45:11.250
用的不多

45:11.250 --> 45:12.250
有的时候

45:12.250 --> 45:13.250
特殊的时候

45:13.250 --> 45:14.250
有可能会用到

45:14.250 --> 45:15.250
我简单说一下

45:17.250 --> 45:18.250
这个watch

45:18.250 --> 45:19.250
它就是

45:19.250 --> 45:20.250
你手动的去指定

45:20.250 --> 45:22.250
要监控哪些指的变化

45:23.250 --> 45:24.250
当变化的时候

45:24.250 --> 45:26.250
它会把新的指

45:26.250 --> 45:29.750
和旧的指一起给力

45:29.750 --> 45:30.750
你看一下

45:30.750 --> 45:34.320
我们在这里直接演示一下吧

45:34.320 --> 45:36.320
现在我们不用watch effect

45:36.320 --> 45:37.320
我用watch

45:37.320 --> 45:39.320
比方说我现在要监控

45:39.320 --> 45:41.320
state A的变化

45:41.320 --> 45:42.320
那我怎么来监控呢

45:42.320 --> 45:46.530
我就不是用watch effect

45:46.530 --> 45:48.530
是用watch

45:49.530 --> 45:50.530
第一个参数

45:50.530 --> 45:53.900
你要监控谁

45:53.900 --> 45:54.900
我们首先看一下

45:54.900 --> 45:55.900
能不能这样子写

46:00.840 --> 46:01.840
第二个参数的这个毁掉函数

46:01.840 --> 46:03.840
就是数据变化的时候

46:03.840 --> 46:05.840
它会运行这个毁掉函数

46:05.840 --> 46:06.840
毁掉函数里面有两个参数

46:06.840 --> 46:07.840
它会提供给力

46:07.840 --> 46:08.840
一个是新的指

46:11.150 --> 46:12.150
一个是旧的指

46:14.150 --> 46:15.150
我们来输出一下

46:16.150 --> 46:18.150
新的指直接来吧

46:18.150 --> 46:19.150
新的指

46:20.150 --> 46:21.150
新

46:21.150 --> 46:22.150
新指是6 value

46:24.150 --> 46:25.150
旧指

46:26.150 --> 46:27.150
是O的value

46:28.150 --> 46:32.740
好了我们来去把个state A

46:32.740 --> 46:33.740
加加

46:34.740 --> 46:36.740
首先watch函数一开始并不会运行

46:36.740 --> 46:38.740
它跟watch effect不一样

46:38.740 --> 46:40.740
watch函数一开始并不会运行

46:40.740 --> 46:42.740
除非你看加上这么一个东西

46:42.740 --> 46:44.740
加上第三个材质一个配置

46:45.740 --> 46:47.740
是不是跟那个v2是一样的

46:47.740 --> 46:48.740
所以也有这个配置

46:48.740 --> 46:49.740
v2是利息的运行

46:49.740 --> 46:52.740
否则它是只有改变之后才会运行

46:53.740 --> 46:55.740
watch effect一开始就会运行

46:56.740 --> 46:57.740
新旧

46:57.740 --> 46:59.740
那为什么全是航地犯

46:59.740 --> 47:01.740
那这个地方有怎么去解释呢

47:01.740 --> 47:02.740
我们先不管这个

47:02.740 --> 47:04.740
我们先把state A改变

47:06.740 --> 47:07.740
它已经有个警告了

47:08.740 --> 47:09.740
它说

47:10.740 --> 47:12.740
它不能去监控这个玩意

47:12.740 --> 47:13.740
啥意思

47:14.740 --> 47:16.740
你这里写的是一个表达式

47:16.740 --> 47:18.740
你在调用方法写的表达式

47:18.740 --> 47:20.740
它是不是得先表达式算出来

47:20.740 --> 47:22.740
这表达式算出来是啥

47:22.740 --> 47:23.740
算出来是个e

47:23.740 --> 47:25.740
那就相当于是传了个e进去

47:25.740 --> 47:26.740
它咋监控

47:26.740 --> 47:27.740
你它传个长辆它咋监控

47:27.740 --> 47:28.740
它没法监控

47:29.740 --> 47:30.740
它必须要监控的是一个

47:30.740 --> 47:32.740
什么想用式的东西

47:32.740 --> 47:33.740
对吧

47:33.740 --> 47:34.740
直接要传个表达式

47:34.740 --> 47:35.740
这个表达式已经

47:35.740 --> 47:36.740
就读出来了

47:36.740 --> 47:37.740
就把个字读出来了

47:37.740 --> 47:38.740
读出来就是个e

47:38.740 --> 47:39.740
不信我们输出一下

47:39.740 --> 47:40.740
state A

47:41.740 --> 47:42.740
你看表达式不就是个e吗

47:42.740 --> 47:43.740
对吧

47:43.740 --> 47:44.740
相当于是把e传了进去

47:44.740 --> 47:45.740
它咋监控一个e吗

47:45.740 --> 47:46.740
咋监控一个数字e

47:46.740 --> 47:47.740
没法监控

47:49.740 --> 47:51.740
只有对象才能监控

47:51.740 --> 47:52.740
那怎么办呢

47:52.740 --> 47:53.740
那么如果说你用这个

47:53.740 --> 47:54.740
active这东西

47:54.740 --> 47:56.740
方式的数据你要监控的话

47:56.740 --> 47:57.740
监控它里面某个属性的话

47:57.740 --> 47:58.740
你在咋写

47:58.740 --> 47:59.740
你在这样子写

47:59.740 --> 48:01.740
第一个参数得写个函数

48:02.740 --> 48:03.740
state A

48:03.740 --> 48:04.740
为啥这样子就可以了

48:05.740 --> 48:06.740
你看啊你看

48:06.740 --> 48:07.740
这样就可以了

48:07.740 --> 48:08.740
改变之后

48:08.740 --> 48:09.740
新的字变成了2了

48:09.740 --> 48:10.740
就的字是e

48:10.740 --> 48:11.740
它为什么这样就可以了呢

48:11.740 --> 48:13.740
因为你传了个函数过后

48:13.740 --> 48:14.740
这个函数是不是现在运行的

48:14.740 --> 48:15.740
不是

48:15.740 --> 48:16.740
这个函数是在

48:16.740 --> 48:18.740
watch里边调用的

48:18.740 --> 48:19.740
而里边调用这个函数

48:19.740 --> 48:20.740
是不是就收集一代了

48:20.740 --> 48:21.740
因为这个是一个

48:21.740 --> 48:22.740
想用式数据

48:22.740 --> 48:23.740
一调用

48:23.740 --> 48:24.740
给它读到这个数据

48:24.740 --> 48:25.740
它就会运行这个数据的date

48:25.740 --> 48:27.740
它就会收集到这个函数的一代

48:27.740 --> 48:29.740
就会收集到问题很深

48:29.740 --> 48:31.740
总之你不能直接传个表达式

48:31.740 --> 48:32.740
传到表达式是不行的

48:32.740 --> 48:33.740
它不知道这个很

48:34.740 --> 48:35.740
它没法收集到这个一代

48:35.740 --> 48:37.740
因为相当于直接传一个e进去了

48:37.740 --> 48:38.740
你得写成一个函数

48:39.740 --> 48:42.890
知道吧

48:42.890 --> 48:43.890
那么现在是不是可以

48:43.890 --> 48:44.890
收集这个一代了

48:45.890 --> 48:47.890
那么现在另一个问题又来了

48:47.890 --> 48:49.890
那如果说我要监控它呢

48:50.890 --> 48:51.890
那一样呗

48:53.890 --> 48:54.890
调什么

48:56.890 --> 48:57.890
那么这里就是

48:58.890 --> 48:59.890
调什么

49:00.890 --> 49:01.890
你看行不行

49:01.890 --> 49:02.890
也可以

49:02.890 --> 49:03.890
对吧

49:03.890 --> 49:04.890
但是我告诉大家的是

49:04.890 --> 49:05.890
这个玩意儿呢

49:05.890 --> 49:06.890
你就可以直接这样子写了

49:09.460 --> 49:10.460
就可以直接这样子写了

49:10.460 --> 49:11.460
但是你不能调白的

49:11.460 --> 49:12.460
对白的的话

49:12.460 --> 49:13.460
调白的的话

49:13.460 --> 49:14.460
相当于又是

49:14.460 --> 49:15.460
给了它一个e

49:15.460 --> 49:16.460
给它一个0

49:16.460 --> 49:17.460
对吧

49:17.460 --> 49:18.460
你可以这样子写

49:18.460 --> 49:19.460
Ref可以这样子写

49:19.460 --> 49:20.460
为什么你把它传了

49:20.460 --> 49:21.460
一个多一箱进去

49:21.460 --> 49:22.460
它可以是不是

49:22.460 --> 49:23.460
可以监控这个

49:23.460 --> 49:24.460
它发现这个是Ref

49:24.460 --> 49:25.460
它是不是可以

49:25.460 --> 49:27.460
调用这个Ref里面的

49:27.460 --> 49:28.460
纸

49:28.460 --> 49:29.460
对不对

49:29.460 --> 49:30.460
那是不是可以收集一代了

49:30.460 --> 49:31.460
它不一样的

49:31.460 --> 49:33.460
这里边细节可多了

49:33.460 --> 49:34.460
你看这样子也可以

49:37.660 --> 49:38.660
有点晕是吧

49:39.660 --> 49:40.660
慢慢去输

49:40.660 --> 49:41.660
因为这里

49:41.660 --> 49:42.660
它传的是一个对象

49:43.660 --> 49:44.660
它没有把那个

49:44.660 --> 49:45.660
纸直接展开

49:45.660 --> 49:46.660
它传的是个对象

49:46.660 --> 49:47.660
对象它是

49:47.660 --> 49:48.660
它里面的外流是

49:48.660 --> 49:49.660
想用式的

49:49.660 --> 49:50.660
它能够收集到它的一代

49:50.660 --> 49:51.660
刚才如果说你

49:51.660 --> 49:52.660
直接调外流的话

49:52.660 --> 49:53.660
调外流的话

49:53.660 --> 49:54.660
它就直接把这个纸

49:54.660 --> 49:55.660
就拿出来了

49:55.660 --> 49:56.660
它就没有想用式

49:57.660 --> 49:58.660
这是Watch

49:58.660 --> 49:59.660
那么Watch还可以监控

49:59.660 --> 50:01.660
多个数据变化

50:01.660 --> 50:03.660
比方说同时监控它的S5

50:03.660 --> 50:04.660
同时监控它

50:04.660 --> 50:05.660
它怎么写的

50:05.660 --> 50:06.660
这里写个数据

50:06.660 --> 50:07.660
你要监控哪些就写

50:07.660 --> 50:08.660
就行了

50:08.660 --> 50:09.660
一次

50:09.660 --> 50:10.660
第一个我要监控State

50:10.660 --> 50:11.660
State是不是必须写成

50:11.660 --> 50:12.660
一个函数

50:12.660 --> 50:13.660
那就写成函数

50:13.660 --> 50:14.660
State A

50:14.660 --> 50:15.660
好

50:15.660 --> 50:16.660
第二个我就监控Cult

50:16.660 --> 50:17.660
对吧

50:17.660 --> 50:18.660
是不是监控两个数据

50:18.660 --> 50:19.660
第一个数据

50:19.660 --> 50:20.660
第二个数据

50:20.660 --> 50:21.660
好

50:21.660 --> 50:22.660
那么编的时候

50:22.660 --> 50:23.660
是不是有两个新的值

50:23.660 --> 50:24.660
对不对

50:24.660 --> 50:25.660
那么我们6V61

50:25.660 --> 50:27.660
6V62

50:27.660 --> 50:28.660
第一个新的值

50:28.660 --> 50:29.660
就是对面

50:29.660 --> 50:30.660
对应了这一项

50:30.660 --> 50:31.660
第二个新的值

50:31.660 --> 50:32.660
就是对应了这一项

50:32.660 --> 50:33.660
所以两个旧的值

50:33.660 --> 50:35.660
O的V61

50:35.660 --> 50:36.660
O的V62

50:36.660 --> 50:37.660
我在这里解构

50:37.660 --> 50:38.660
比如说它

50:38.660 --> 50:39.660
第一个参数是一个数组

50:39.660 --> 50:40.660
第二个参数也是一个数组

50:40.660 --> 50:41.660
那么新的值

50:41.660 --> 50:43.660
所以6V61

50:43.660 --> 50:45.660
同时的6V62

50:45.660 --> 50:46.660
旧的值

50:46.660 --> 50:48.660
6O的V61

50:48.660 --> 50:49.660
同时O的V62

50:49.660 --> 50:50.660
就监控多个

50:50.660 --> 50:51.660
那么V6变化了

50:51.660 --> 50:52.660
还有什么

50:52.660 --> 50:54.660
还有State A变化了

50:54.660 --> 50:55.660
是不是都会变动

50:56.660 --> 50:57.660
你看一下

50:57.660 --> 50:58.660
不都会变动

50:59.660 --> 51:00.660
对不对

51:00.660 --> 51:01.660
而且它也是

51:01.660 --> 51:02.660
延时的

51:02.660 --> 51:03.660
延时执行的

51:04.660 --> 51:05.660
等变化完了过后

51:05.660 --> 51:07.660
然后异部执行这个函数

51:08.660 --> 51:09.660
这是watch

51:10.660 --> 51:11.660
有点绕

51:11.660 --> 51:13.660
那么我们平时在用的时候

51:13.660 --> 51:15.660
到底是用watch effect

51:15.660 --> 51:16.660
还是用watch呢

51:16.660 --> 51:18.660
就无论是这个玩意

51:18.660 --> 51:20.660
首先它们运行都是异部的

51:20.660 --> 51:21.660
微队的

51:22.660 --> 51:24.660
那么我给它说一下场景

51:24.660 --> 51:26.660
一般来说

51:26.660 --> 51:28.660
用这个watch effect是最方便的

51:28.660 --> 51:29.660
它自动跟踪异弹

51:29.660 --> 51:30.660
你要用到哪些

51:30.660 --> 51:31.660
异弹相变它自动会运行

51:31.660 --> 51:32.660
重新运行

51:32.660 --> 51:33.660
但是有的时候

51:33.660 --> 51:35.660
我们不得不去选择watch

51:35.660 --> 51:36.660
比方说呢

51:36.660 --> 51:37.660
第一个

51:37.660 --> 51:38.660
我不希望回掉

51:38.660 --> 51:39.660
还是一开始就执行

51:39.660 --> 51:40.660
你看这个watch effect

51:40.660 --> 51:42.660
一开始是不是会执行一次

51:42.660 --> 51:43.660
我们可能只希望

51:43.660 --> 51:45.660
数据变动之后再执行

51:45.660 --> 51:46.660
那么这个是没办法

51:46.660 --> 51:47.660
你得用watch

51:47.660 --> 51:48.660
还有什么情况呢

51:48.660 --> 51:49.660
就是数据改变

51:49.660 --> 51:50.660
我执行的时候

51:50.660 --> 51:52.660
我要知道旧的数据是啥

51:52.660 --> 51:53.660
要参考旧的

51:53.660 --> 51:54.660
那你只能用watch

51:55.660 --> 51:56.660
还有就是啥呢

51:56.660 --> 51:57.660
还就是我要监控一些

51:57.660 --> 51:58.660
回掉函数中

51:58.660 --> 51:59.660
不会用到的数据

51:59.660 --> 52:00.660
啥意思

52:00.660 --> 52:01.660
我要监控这两个数据

52:01.660 --> 52:02.660
但是我的回掉函数中

52:02.660 --> 52:04.660
不会用到这两个数据

52:04.660 --> 52:05.660
我就可能就输出一句话

52:05.660 --> 52:06.660
变了

52:07.660 --> 52:08.660
输出变化了

52:09.660 --> 52:10.660
那么这种情况下

52:10.660 --> 52:11.660
你看watch effect

52:11.660 --> 52:12.660
能办到吗

52:12.660 --> 52:13.660
是办不到

52:13.660 --> 52:14.660
对吧

52:14.660 --> 52:15.660
watch effect 能办到

52:15.660 --> 52:16.660
watch effect 它自动监控

52:16.660 --> 52:17.660
这里面的函数

52:17.660 --> 52:18.660
里面的遗难

52:18.660 --> 52:19.660
它这里面没有遗难

52:19.660 --> 52:20.660
但是我要监控

52:20.660 --> 52:22.660
我就是要监控这些东西

52:23.660 --> 52:24.660
变化了

52:24.660 --> 52:25.660
这种情况 什么情况呢

52:25.660 --> 52:26.660
就是一些数据变了

52:26.660 --> 52:28.660
我们可能会通知一下服务器

52:28.660 --> 52:30.660
通知一下服务器

52:30.660 --> 52:32.660
那么给它发出一个消息怎么样

52:33.660 --> 52:34.660
可能用不到这些数据

52:34.660 --> 52:35.660
但是我要去监控它

52:35.660 --> 52:36.660
那么这个时候

52:36.660 --> 52:37.660
会需要watch

52:38.660 --> 52:40.660
就这么一些场景

52:41.660 --> 52:42.660
好

52:42.660 --> 52:44.660
那么下面又提又来了

52:44.660 --> 52:47.620
复制

52:48.620 --> 52:49.620
暂停过来

52:49.620 --> 52:50.620
加油

52:50.620 --> 52:51.620
加油

52:52.620 --> 52:53.620
比较难的地方

52:53.620 --> 52:54.620
马上要过完了

52:57.380 --> 52:58.380
来 这些的这个题

52:58.380 --> 52:59.380
输出啥

52:59.380 --> 53:00.380
自己暂停看一下

53:03.380 --> 53:04.380
输出啥

53:04.380 --> 53:07.260
好 来吧

53:07.260 --> 53:08.260
我们分析一下

53:08.260 --> 53:11.830
首先创建了一个响应式数据

53:12.830 --> 53:13.830
响应式数据

53:13.830 --> 53:15.830
然后一个watch effect

53:15.830 --> 53:16.830
watch effect 是不是立即执行的

53:17.830 --> 53:18.830
马上就执行

53:18.830 --> 53:19.830
同步马上执行

53:19.830 --> 53:20.830
所以说这里

53:20.830 --> 53:21.830
运行的是什么

53:21.830 --> 53:23.830
运行的是watch effect

53:23.830 --> 53:24.830
立即执行

53:24.830 --> 53:25.830
得到的数据是什么

53:25.830 --> 53:26.830
暂停

53:26.830 --> 53:28.830
一开始输出这么个玩意

53:28.830 --> 53:29.830
好 那么这两者

53:29.830 --> 53:30.830
watch effect 在这边

53:30.830 --> 53:31.830
实际上有收集一旦了

53:31.830 --> 53:32.830
收集谁的一旦

53:32.830 --> 53:33.830
靠手的一旦

53:33.830 --> 53:34.830
还有自动收集

53:34.830 --> 53:35.830
好 接下来watch

53:35.830 --> 53:36.830
watch effect 是不是立即执行的

53:36.830 --> 53:38.830
除非你配置第三个参数

53:38.830 --> 53:40.830
或者的话不会立即执行

53:40.830 --> 53:41.830
它手动的

53:41.830 --> 53:43.830
给它告诉它一旦是什么

53:43.830 --> 53:44.830
收集的一旦是这个

53:44.830 --> 53:45.830
没问题吧

53:45.830 --> 53:46.830
那么这个

53:46.830 --> 53:47.830
你看这个玩意

53:47.830 --> 53:49.830
它什么都收集同一个一旦

53:49.830 --> 53:50.830
好 那么我们输出的时候

53:50.830 --> 53:52.830
一开始要不要运行这个输出

53:52.830 --> 53:53.830
新的直就的直

53:53.830 --> 53:54.830
它不会运行

53:54.830 --> 53:56.830
好 接下来我们是不是输出这个start

53:58.830 --> 53:59.830
对不对

53:59.830 --> 54:00.830
start

54:00.830 --> 54:01.830
好 那么接下来

54:02.830 --> 54:03.830
看这儿

54:03.830 --> 54:05.830
进入了一个红队里

54:06.830 --> 54:08.830
红队里

54:08.830 --> 54:10.830
里边要输出这个timeout

54:10.830 --> 54:11.830
对吧

54:11.830 --> 54:13.830
红队里 就这个玩意

54:13.830 --> 54:15.830
红队里现在是不是不着急

54:15.830 --> 54:16.830
我们先把代码运行完

54:16.830 --> 54:17.830
那么接下来

54:17.830 --> 54:18.830
全局里边

54:18.830 --> 54:19.830
扣成两次加加

54:19.830 --> 54:20.830
扣成两次加加

54:20.830 --> 54:22.830
是不是变成一和二了

54:22.830 --> 54:23.830
变成二了

54:23.830 --> 54:25.830
但是两次加加过后呢

54:25.830 --> 54:26.830
谁收到通知的

54:26.830 --> 54:27.830
warchy收到通知的

54:27.830 --> 54:29.830
同时warchyfx都收到通知的

54:29.830 --> 54:30.830
它都有一旦监控

54:30.830 --> 54:33.830
但是它们两个都不着急运行

54:33.830 --> 54:36.830
它们会到威对里

54:36.830 --> 54:39.210
那么威对里边

54:39.210 --> 54:40.210
首先有一个effect

54:40.210 --> 54:41.210
对吧

54:41.210 --> 54:42.210
要运行

54:42.210 --> 54:43.210
还有一个warchy要运行

54:43.210 --> 54:45.210
两排队呗

54:46.210 --> 54:47.210
排队

54:47.210 --> 54:48.210
好 那么现在呢

54:48.210 --> 54:49.210
输出什么

54:49.210 --> 54:50.210
输出n

54:50.210 --> 54:52.210
输出n的完了过后

54:52.210 --> 54:56.030
放过来

54:56.030 --> 54:58.030
输出n的完了过后

54:58.030 --> 54:59.030
我们说一下

54:59.030 --> 55:00.030
看得清楚一点

55:00.030 --> 55:01.030
输出n的完了过后

55:01.030 --> 55:03.030
那现在全局上有没有东西了

55:03.030 --> 55:04.030
接下来干嘛呢

55:04.030 --> 55:06.030
接下来是威对里面拿

55:06.030 --> 55:07.030
efx拿出来

55:07.030 --> 55:09.030
是不是输出这个

55:09.030 --> 55:10.030
warchyfx

55:10.030 --> 55:11.030
急呢

55:11.030 --> 55:12.030
现在靠手指数多少了

55:12.030 --> 55:14.030
靠手指音

55:14.030 --> 55:15.030
在这里记录一下吧

55:15.030 --> 55:17.030
靠手指音长到多了

55:17.030 --> 55:18.030
长到二了

55:18.030 --> 55:20.030
变一变二

55:20.030 --> 55:21.030
长到二了

55:21.030 --> 55:22.030
所以说warchyfx2

55:22.030 --> 55:23.030
然后接下来

55:23.030 --> 55:24.030
把这个玩意了

55:24.030 --> 55:25.030
这个威对的玩意了

55:25.030 --> 55:26.030
然后接下来是warchy

55:26.030 --> 55:28.030
warchy是不是要输出

55:28.030 --> 55:29.030
新的值是多少呢

55:29.030 --> 55:30.030
是二

55:30.030 --> 55:31.030
旧的值呢

55:31.030 --> 55:32.030
就是它之前的值

55:32.030 --> 55:33.030
之前的值是不是0

55:33.030 --> 55:34.030
对吧

55:34.030 --> 55:35.030
它是从0变到2的

55:35.030 --> 55:37.030
对warchy来说一开始是0

55:37.030 --> 55:39.030
这次输出变成2的

55:39.030 --> 55:41.030
看不看变成这样子

55:42.030 --> 55:43.030
好 那么威对里面是不是清空了

55:43.030 --> 55:44.030
清空过后

55:44.030 --> 55:45.030
现在红队拿出来

55:45.030 --> 55:46.030
是不是输出timeout

55:46.030 --> 55:48.030
是不是输出这个

55:48.030 --> 55:49.030
然后timeout

55:49.030 --> 55:50.030
然后又是两次加加

55:50.030 --> 55:53.030
那是不是2变到4的

55:53.030 --> 55:54.030
是不是2到4

55:55.030 --> 55:56.030
好 那么现在威对里面

55:56.030 --> 55:57.030
是不是又放了两个

55:57.030 --> 55:58.030
一个是warchyfx

55:58.030 --> 55:59.030
一个是warchy

55:59.030 --> 56:00.030
那么现在就又来了

56:00.030 --> 56:02.030
warchyfx现在输出多少呢

56:02.030 --> 56:03.030
输出4

56:03.030 --> 56:05.030
warch变成4

56:05.030 --> 56:07.030
以前的值是2

56:07.030 --> 56:08.030
就这么一个输出结果

56:10.030 --> 56:12.030
我的负责错了 地方

56:12.030 --> 56:15.540
把这个地方

56:15.540 --> 56:16.540
翻过来

56:16.540 --> 56:17.540
好 咱们来看一下结果

56:18.540 --> 56:19.540
自己对到一下

56:20.540 --> 56:21.540
是不是这样子

56:24.040 --> 56:25.040
这些题要回做

56:26.040 --> 56:28.040
好了 这是

56:28.040 --> 56:29.040
监听数据变化

56:29.040 --> 56:30.040
我们平时用的

56:30.040 --> 56:31.040
真正开发的时候用的

56:31.040 --> 56:33.040
都比较多的是warchyfx

56:33.040 --> 56:34.040
加上判断了

56:35.040 --> 56:36.040
判断的结果

56:36.040 --> 56:37.040
现在的事情就比较轻松一点了

56:37.040 --> 56:38.040
就是说

56:39.040 --> 56:40.040
无忧3觉得

56:40.040 --> 56:41.040
自己觉得

56:41.040 --> 56:43.040
是不是有点恶心了

56:44.040 --> 56:45.040
你看 这个享用数据

56:45.040 --> 56:46.040
有两个

56:46.040 --> 56:47.040
一个是reactive

56:47.040 --> 56:48.040
一个是review

56:48.040 --> 56:49.040
格式也不一样

56:49.040 --> 56:50.040
有的时候我们判断

56:50.040 --> 56:51.040
要判断一下

56:51.040 --> 56:52.040
这个享用数据

56:52.040 --> 56:53.040
到底是这种格式的

56:53.040 --> 56:54.040
还是这种格式

56:54.040 --> 56:55.040
表面你在函数里面

56:55.040 --> 56:56.040
拿到的参数

56:56.040 --> 56:57.040
这个参数是一个享用数据

56:57.040 --> 56:58.040
你是搞不清楚

56:58.040 --> 56:59.040
它是个对象代理

56:59.040 --> 57:00.040
还是这种格式

57:00.040 --> 57:01.040
于是它可以提供的一些方法

57:01.040 --> 57:02.040
变运你判断

57:02.040 --> 57:04.040
方法简单说一下就行了

57:04.040 --> 57:05.040
可以至于试一下

57:06.040 --> 57:07.040
判断某个东西

57:07.040 --> 57:08.040
它怎么用呢

57:08.040 --> 57:09.040
用法很简单

57:09.040 --> 57:10.040
就是个函数

57:10.040 --> 57:11.040
是函数

57:11.040 --> 57:12.040
啥的传进去

57:12.040 --> 57:13.040
它反回q或者是force

57:13.040 --> 57:14.040
怎么

57:14.040 --> 57:15.040
哪来的这个函数在这

57:15.040 --> 57:16.040
导入就行了

57:16.040 --> 57:17.040
你是函数

57:17.040 --> 57:18.040
导入就行了

57:18.040 --> 57:19.040
我这里不掩饰

57:20.040 --> 57:21.040
它就说

57:22.040 --> 57:23.040
通过这个函数

57:23.040 --> 57:24.040
你可以判断

57:24.040 --> 57:25.040
某个数据到底

57:25.040 --> 57:27.040
是不是有这两个东西产生的

57:27.040 --> 57:28.040
它是不是个代理

57:28.040 --> 57:29.040
代理数据

57:29.040 --> 57:30.040
就是不是

57:30.040 --> 57:31.040
要么就是它

57:31.040 --> 57:32.040
要么就是它

57:32.040 --> 57:33.040
所以有它们两个产生的

57:33.040 --> 57:34.040
如果说

57:34.040 --> 57:35.040
它或者是它产生的

57:35.040 --> 57:36.040
就是q

57:36.040 --> 57:37.040
或者是force

57:37.040 --> 57:39.040
is reactive

57:39.040 --> 57:40.040
它就判断

57:40.040 --> 57:41.040
是不是通过reactive

57:41.040 --> 57:42.040
产生的

57:42.040 --> 57:43.040
is read only

57:43.040 --> 57:44.040
是不是通过read only

57:44.040 --> 57:45.040
产生的

57:45.040 --> 57:46.040
就是这么一个

57:46.040 --> 57:47.040
要么是它通过它

57:47.040 --> 57:48.040
要么通过它

57:48.040 --> 57:49.040
要么两个都可以

57:49.040 --> 57:50.040
is rift

57:50.040 --> 57:52.040
判断是不是一个 rift对象

57:52.040 --> 57:53.040
puted 或者是

57:53.040 --> 57:54.040
通过 rift 创建的

57:54.040 --> 57:55.040
都是这个东西

57:55.040 --> 57:56.040
它通过

57:56.040 --> 57:57.040
给你写了这么一些函数

57:57.040 --> 57:58.040
就是判断的

57:58.040 --> 58:00.040
有的时候你可能会用的

58:00.040 --> 58:01.040
用不到就拉倒

58:02.040 --> 58:03.040
还有就是一个

58:03.040 --> 58:04.040
它给你提供了一个

58:04.040 --> 58:05.040
转换的

58:06.040 --> 58:07.040
它有的时候

58:07.040 --> 58:08.040
它可能会遇到这么一场景

58:08.040 --> 58:10.040
就是

58:11.040 --> 58:12.040
我拿到一个数据

58:12.040 --> 58:13.040
我都不知道它是啥

58:13.040 --> 58:14.040
大家还记得

58:14.040 --> 58:15.040
我们在入门阶段吗

58:15.040 --> 58:17.040
是不是写了这么一个函数

58:18.040 --> 58:19.040
它要给我

58:19.040 --> 58:20.040
传一个什么to do is rift

58:20.040 --> 58:21.040
进来

58:21.040 --> 58:22.040
用命名上来区分

58:22.040 --> 58:23.040
但是有的时候

58:23.040 --> 58:24.040
我也搞不清楚

58:24.040 --> 58:25.040
它传的是啥

58:25.040 --> 58:26.040
因为我在写这个函数的时候

58:26.040 --> 58:27.040
我可能考虑不了那么多

58:28.040 --> 58:29.040
我都不知道

58:29.040 --> 58:30.040
还给我传的是啥

58:30.040 --> 58:31.040
到底是一个

58:32.040 --> 58:33.040
proxy呢

58:34.040 --> 58:35.040
还是一个 rift

58:35.040 --> 58:36.040
我都不知道

58:36.040 --> 58:37.040
它是啥

58:37.040 --> 58:38.040
那怎么办呢

58:38.040 --> 58:39.040
我就可以用 on rift

58:40.040 --> 58:41.040
on rift 其实

58:41.040 --> 58:42.040
就是一句话

58:42.040 --> 58:43.040
一个三目云上浮

58:43.040 --> 58:44.040
它如果

58:44.040 --> 58:45.040
就刚才我们看到

58:45.040 --> 58:46.040
is rift 对吧

58:46.040 --> 58:47.040
它如果说

58:47.040 --> 58:48.040
is rift 的话

58:48.040 --> 58:49.040
就把白的读出来

58:49.040 --> 58:50.040
否则的话

58:50.040 --> 58:51.040
就是这么一句话

58:51.040 --> 58:53.040
等同于这个

58:54.040 --> 58:55.040
你自己看一下

58:55.040 --> 58:56.040
好 接下来还有两个

58:56.040 --> 58:57.040
这两个

58:57.040 --> 58:58.040
可能用的稍微多一点

58:58.040 --> 58:59.040
第一个 to rift

59:01.040 --> 59:02.040
你看下面这台

59:02.040 --> 59:04.040
我有一个响应识数据

59:04.040 --> 59:06.040
得到这个proxy 对吧

59:06.040 --> 59:07.040
我可以通过

59:07.040 --> 59:08.040
to rift 这个函数

59:08.040 --> 59:10.040
都是从这里面导入的

59:10.040 --> 59:11.040
都是从这里面导入的

59:11.040 --> 59:13.040
to rift 这个函数

59:14.040 --> 59:15.040
通过to rift 函数

59:15.040 --> 59:17.040
把它的某一个属性

59:17.040 --> 59:18.040
转换成 rift

59:18.040 --> 59:19.040
转换出来过后

59:19.040 --> 59:20.040
是个啥样子的

59:20.040 --> 59:21.040
这个full rift

59:21.040 --> 59:22.040
是啥东西

59:22.040 --> 59:23.040
它就是这么一个东西

59:23.040 --> 59:24.040
一个value

59:25.040 --> 59:26.040
它变成个 rift格式的

59:27.040 --> 59:28.040
那么这个value的值

59:28.040 --> 59:29.040
等于多少呢

59:29.040 --> 59:30.040
它是响应式的

59:30.040 --> 59:31.040
等于多少呢

59:31.040 --> 59:32.040
就等于这个1

59:33.040 --> 59:34.040
就相当于把这个属性

59:34.040 --> 59:36.040
变成了这个玩意了

59:37.040 --> 59:38.040
那么通过

59:38.040 --> 59:39.040
把它的值加1

59:39.040 --> 59:41.040
它也会影响到它的值

59:41.040 --> 59:43.040
有两个是相同的

59:43.040 --> 59:45.040
它就把某一个响应式

59:45.040 --> 59:46.040
对象里面的某一个属性

59:46.040 --> 59:48.040
变成 rift格式

59:49.040 --> 59:50.040
这个东西平时

59:50.040 --> 59:51.040
可能还用的稍微少

59:51.040 --> 59:52.040
少一点

59:52.040 --> 59:53.040
下面这个可能用的比较多了

59:54.040 --> 59:55.040
跟我们开发有关系的

59:56.040 --> 59:59.700
你看

01:00:00.700 --> 01:00:01.700
to rift

01:00:02.700 --> 01:00:03.700
它就是

01:00:03.700 --> 01:00:04.700
把一个整个对象

01:00:04.700 --> 01:00:05.700
刚才是一个属性对吧

01:00:05.700 --> 01:00:06.700
我们现在是要把

01:00:06.700 --> 01:00:07.700
整个对象的

01:00:07.700 --> 01:00:08.700
所有属性

01:00:08.700 --> 01:00:09.700
全部变成 rift格式

01:00:10.700 --> 01:00:11.700
并且返回一个

01:00:11.700 --> 01:00:12.700
play object

01:00:12.700 --> 01:00:13.700
就是返回一个普通对象

01:00:13.700 --> 01:00:14.700
啥意思

01:00:14.700 --> 01:00:15.700
你看 这是一个响应式对象

01:00:15.700 --> 01:00:16.700
一个代理 对吧

01:00:16.700 --> 01:00:17.700
代理扔进去

01:00:17.700 --> 01:00:18.700
to rift

01:00:18.700 --> 01:00:19.700
是不是把里面的

01:00:19.700 --> 01:00:20.700
它也不会把

01:00:20.700 --> 01:00:21.700
代理对象里面的

01:00:21.700 --> 01:00:22.700
所有属性

01:00:22.700 --> 01:00:24.700
转换成 rift格式

01:00:24.700 --> 01:00:25.700
封装到一个对象里面

01:00:25.700 --> 01:00:26.700
返回

01:00:26.700 --> 01:00:27.700
那么这个对象最终的结果

01:00:27.700 --> 01:00:29.700
它不是一个代理的

01:00:29.700 --> 01:00:30.700
它现在就不是一个代理的

01:00:30.700 --> 01:00:31.700
是个普通对象

01:00:31.700 --> 01:00:32.700
普通对象里面

01:00:32.700 --> 01:00:33.700
有很多属性

01:00:33.700 --> 01:00:34.700
每个属性全都是 rift

01:00:34.700 --> 01:00:35.700
你看看

01:00:35.700 --> 01:00:36.700
每个属性全都是 rift

01:00:36.700 --> 01:00:37.700
有什么用

01:00:38.700 --> 01:00:39.700
为啥要这样做

01:00:40.700 --> 01:00:41.700
有啥用

01:00:41.700 --> 01:00:42.700
接下来

01:00:42.700 --> 01:00:43.700
我们看下面这个

01:00:43.700 --> 01:00:44.700
这种情况

01:00:44.700 --> 01:00:45.700
你明白有啥用了

01:00:46.700 --> 01:00:48.700
在setup 喊数里面

01:00:49.700 --> 01:00:50.700
卡普雷写一篇

01:00:50.700 --> 01:00:52.700
入门的阶段学过了

01:00:52.700 --> 01:00:54.700
我通过一个reactive

01:00:54.700 --> 01:00:56.700
得到一个代理

01:00:56.700 --> 01:00:57.700
对吧

01:00:57.700 --> 01:00:58.700
通过它 又得到一个代理

01:00:58.700 --> 01:00:59.700
那么现在呢

01:00:59.700 --> 01:01:00.700
我们要把两个代理

01:01:00.700 --> 01:01:01.700
混合起来

01:01:01.700 --> 01:01:02.700
放到模板里面

01:01:02.700 --> 01:01:03.700
共模板使用

01:01:03.700 --> 01:01:04.700
但是我们这里

01:01:04.700 --> 01:01:06.700
如果说一旦用展开运算

01:01:06.700 --> 01:01:07.700
幅就完蛋了

01:01:08.700 --> 01:01:09.700
因为展开运算

01:01:09.700 --> 01:01:10.700
为展开

01:01:10.700 --> 01:01:11.700
它本来是一个响应式

01:01:11.700 --> 01:01:12.700
是一个响应式对象的

01:01:12.700 --> 01:01:13.700
对吧 是一个代理对象

01:01:13.700 --> 01:01:14.700
它本来是具有响应式的

01:01:14.700 --> 01:01:15.700
但是一展开就没了

01:01:16.700 --> 01:01:17.700
一展开就变成普通属性了

01:01:17.700 --> 01:01:18.700
一看东西一展开

01:01:18.700 --> 01:01:19.700
是不是变成a等于1

01:01:19.700 --> 01:01:20.700
b等于2

01:01:20.700 --> 01:01:21.700
一展开变成这个样子了

01:01:21.700 --> 01:01:23.700
相当于是这里写了一个啥

01:01:23.700 --> 01:01:25.700
这里写了一个a等于1

01:01:26.700 --> 01:01:27.700
b等于2

01:01:27.700 --> 01:01:28.700
你说这个玩意儿有响应式吗

01:01:28.700 --> 01:01:29.700
一展开就没了

01:01:31.700 --> 01:01:33.700
叫做 lost reactivity

01:01:33.700 --> 01:01:34.700
失去了响应式

01:01:36.700 --> 01:01:37.700
懂了意思吧

01:01:37.700 --> 01:01:38.700
好 然后我们再看

01:01:39.700 --> 01:01:40.700
那怎么办呢

01:01:40.700 --> 01:01:41.700
这个时候

01:01:41.700 --> 01:01:42.700
我们就可以这样子

01:01:42.700 --> 01:01:44.700
我们套一个trefs

01:01:44.700 --> 01:01:46.700
你看套了一个trefs

01:01:46.700 --> 01:01:47.700
就不一样了

01:01:47.700 --> 01:01:48.700
那么它

01:01:48.700 --> 01:01:49.700
这个玩意儿变成一个新的对象了

01:01:49.700 --> 01:01:50.700
对吧

01:01:50.700 --> 01:01:51.700
这个对象是什么格式

01:01:51.700 --> 01:01:52.700
这个对象是这么一种格式

01:01:54.700 --> 01:01:55.700
变成了什么

01:01:55.700 --> 01:01:56.700
a是一个什么呢

01:01:56.700 --> 01:01:57.700
是一个ref object

01:01:57.700 --> 01:01:58.700
对吧

01:01:58.700 --> 01:01:59.700
它里面是一个

01:01:59.700 --> 01:02:00.700
它是个对象

01:02:00.700 --> 01:02:01.700
对象里面有value

01:02:01.700 --> 01:02:02.700
对吧

01:02:02.700 --> 01:02:03.700
是不是变成这个种格式的

01:02:03.700 --> 01:02:04.700
a变成这个种格式的

01:02:04.700 --> 01:02:06.700
就是一个ref object

01:02:06.700 --> 01:02:09.700
然后b变成了一个ref object

01:02:09.700 --> 01:02:11.700
那这样一展开过后

01:02:11.700 --> 01:02:13.700
是不是变成这个东西了

01:02:13.700 --> 01:02:14.700
那么它是不是还是具有响应式的

01:02:14.700 --> 01:02:15.700
refs具有响应式的

01:02:15.700 --> 01:02:16.700
是这么一个意思

01:02:16.700 --> 01:02:18.700
同样的state 20也是一样

01:02:18.700 --> 01:02:20.700
那么把它包装成一个ref过后了

01:02:20.700 --> 01:02:22.700
反回展开就没事了

01:02:22.700 --> 01:02:23.700
同样的道理呢

01:02:23.700 --> 01:02:24.700
不仅仅在展开这里

01:02:24.700 --> 01:02:26.700
在解构的时候也是一样

01:02:26.700 --> 01:02:28.700
你不要让我们这里有个这个玩意儿

01:02:29.700 --> 01:02:30.700
有这个玩意儿

01:02:30.700 --> 01:02:31.700
这个玩意儿呢

01:02:31.700 --> 01:02:32.700
我们得到一个响应式的

01:02:32.700 --> 01:02:33.700
这个东西叫做

01:02:33.700 --> 01:02:35.700
叫做comparation

01:02:35.700 --> 01:02:37.700
组合了一个函数

01:02:37.700 --> 01:02:38.700
对吧

01:02:38.700 --> 01:02:39.700
分离出去的一个组合函数

01:02:39.700 --> 01:02:40.700
跟我们之前那个use new

01:02:40.700 --> 01:02:41.700
new to do

01:02:41.700 --> 01:02:43.700
use edit to do

01:02:43.700 --> 01:02:44.700
new to do

01:02:44.700 --> 01:02:45.700
use edit to do

01:02:45.700 --> 01:02:46.700
是不是一样的道理

01:02:46.700 --> 01:02:47.700
不要说我们这里

01:02:47.700 --> 01:02:49.700
给它得到一个响应式数据

01:02:49.700 --> 01:02:50.700
如果说我们啥都不管

01:02:50.700 --> 01:02:52.700
把这个响应式数据直接返回

01:02:52.700 --> 01:02:54.700
那么就有可能会出现那种情况

01:02:54.700 --> 01:02:56.700
use pose

01:02:56.700 --> 01:02:57.700
我这边

01:02:57.700 --> 01:02:58.700
我考虑不到那么多

01:02:58.700 --> 01:03:00.700
一解构就完了

01:03:00.700 --> 01:03:02.700
因为一解构x变成一个普通数据

01:03:02.700 --> 01:03:03.700
变成0了

01:03:03.700 --> 01:03:04.700
就是个普通数据0

01:03:04.700 --> 01:03:06.700
玩意儿变成一个普通数据0了

01:03:06.700 --> 01:03:08.700
以前在512的时候

01:03:08.700 --> 01:03:09.700
是不可能遇到这种场景的

01:03:09.700 --> 01:03:10.700
对不对

01:03:10.700 --> 01:03:11.700
那么这一变成普通数据过

01:03:11.700 --> 01:03:12.700
有响应式吗

01:03:12.700 --> 01:03:13.700
就没有响应式了

01:03:13.700 --> 01:03:15.700
not the reactivity

01:03:15.700 --> 01:03:16.700
那应该怎么办呢

01:03:16.700 --> 01:03:18.700
我应该是用一个to wraps

01:03:18.700 --> 01:03:19.700
包一下对吧

01:03:19.700 --> 01:03:21.700
它反过来是一个响应式对象

01:03:21.700 --> 01:03:22.700
那么把它变成这个

01:03:22.700 --> 01:03:24.700
x变成一个这个东西

01:03:24.700 --> 01:03:25.700
y变成一个这个东西

01:03:25.700 --> 01:03:26.700
那么这一解构

01:03:26.700 --> 01:03:27.700
x变成一个什么

01:03:27.700 --> 01:03:28.700
ref object

01:03:28.700 --> 01:03:30.700
y变成一个ref object

01:03:30.700 --> 01:03:33.700
这边有响应式的

01:03:33.700 --> 01:03:36.700
这就是我到底要讲的全部知识

01:03:36.700 --> 01:03:37.700
有点糟对吧

01:03:37.700 --> 01:03:39.700
慢慢去处理

01:03:39.700 --> 01:03:40.700
主要是

01:03:40.700 --> 01:03:41.700
前面的东西

01:03:41.700 --> 01:03:42.700
主要是还要应对面识题

01:03:42.700 --> 01:03:44.700
这几道面识题

01:03:44.700 --> 01:03:45.700
这个就是

01:03:45.700 --> 01:03:48.700
比识题好好去理一下

01:03:48.700 --> 01:03:49.700
目标是把比识题做出来

01:03:49.700 --> 01:03:50.700
还要知道为什么

01:03:50.700 --> 01:03:52.700
因为它比识题又可能会变的

01:03:52.700 --> 01:03:54.700
你必须要知道为什么

01:03:54.700 --> 01:03:55.700
最后我们来说一下

01:03:55.700 --> 01:03:56.700
平时开发中

01:03:56.700 --> 01:03:59.700
对我们开发会造成什么影响

01:03:59.700 --> 01:04:01.700
新制负担有没有了

01:04:01.700 --> 01:04:02.700
绝对有

01:04:02.700 --> 01:04:04.700
什么叫新制负担

01:04:04.700 --> 01:04:05.700
就是我担心了

01:04:05.700 --> 01:04:06.700
我写大码的时候

01:04:06.700 --> 01:04:07.700
总是担心

01:04:07.700 --> 01:04:08.700
这个玩意儿是 reactivity

01:04:08.700 --> 01:04:10.700
还是个ref

01:04:10.700 --> 01:04:12.700
我这个样子会不会导致

01:04:12.700 --> 01:04:13.700
失去响应是

01:04:13.700 --> 01:04:15.700
有很多担心

01:04:15.700 --> 01:04:18.700
那么如何来将这种新制负担

01:04:18.700 --> 01:04:20.700
那么目前都在讨论

01:04:20.700 --> 01:04:21.700
不光是

01:04:21.700 --> 01:04:24.700
大家都在讨论这个问题

01:04:24.700 --> 01:04:26.700
按照我个人的观点

01:04:26.700 --> 01:04:27.700
我给大家说一下

01:04:27.700 --> 01:04:30.700
这个需要有一种开发纪律

01:04:30.700 --> 01:04:31.700
通过开发纪律

01:04:31.700 --> 01:04:32.700
去规避这种负担

01:04:32.700 --> 01:04:34.700
行李负担

01:04:34.700 --> 01:04:35.700
那怎么用什么样的纪律

01:04:35.700 --> 01:04:37.700
我给大家建议一种方式

01:04:37.700 --> 01:04:39.700
比如说这个就一定好

01:04:39.700 --> 01:04:40.700
别的就一定坏

01:04:40.700 --> 01:04:42.700
因为这个目前没有形成

01:04:42.700 --> 01:04:43.700
一种最佳实践

01:04:43.700 --> 01:04:44.700
大家都在摸鼠

01:04:44.700 --> 01:04:46.700
所以我按照我的开发经验

01:04:46.700 --> 01:04:48.700
给大家说一个方案

01:04:48.700 --> 01:04:50.700
就是我们将来用

01:04:50.700 --> 01:04:51.700
comparation API的时候

01:04:51.700 --> 01:04:52.700
不可避免的

01:04:52.700 --> 01:04:53.700
comparation API里面

01:04:53.700 --> 01:04:55.700
会用到很多响应式 API

01:04:55.700 --> 01:04:56.700
那么这些响应式 API

01:04:56.700 --> 01:04:57.700
你不能说光用ref

01:04:57.700 --> 01:04:58.700
光用 reactivity

01:04:58.700 --> 01:04:59.700
那不一定的

01:04:59.700 --> 01:05:01.700
有的时候该用啥就用啥

01:05:01.700 --> 01:05:02.700
没关系

01:05:02.700 --> 01:05:03.700
那怎么办呢

01:05:03.700 --> 01:05:05.700
我要保证这些分离

01:05:05.700 --> 01:05:06.700
出去的这些函数

01:05:06.700 --> 01:05:09.700
不管你里面用的是啥

01:05:09.700 --> 01:05:10.700
red only 也好

01:05:10.700 --> 01:05:11.700
也是 reactivity 也好

01:05:11.700 --> 01:05:12.700
你给我返回的时候

01:05:12.700 --> 01:05:14.700
全部给我转换成ref

01:05:14.700 --> 01:05:16.700
全部转换成ref 返回

01:05:16.700 --> 01:05:19.700
保证 setup 函数返回的结果中

01:05:19.700 --> 01:05:20.700
不包含任何 reactivity

01:05:20.700 --> 01:05:22.700
或者 red only 直接产生的数据

01:05:22.700 --> 01:05:23.700
咋意思

01:05:23.700 --> 01:05:24.700
一看我下面有三个例子

01:05:24.700 --> 01:05:26.700
我这里有三个分离出去的函数

01:05:26.700 --> 01:05:27.700
这些函数里面

01:05:27.700 --> 01:05:28.700
用了前几百块

01:05:28.700 --> 01:05:29.700
比如说这里我用了ref

01:05:29.700 --> 01:05:31.700
那为ref的话就OK了

01:05:31.700 --> 01:05:32.700
我直接返回一个对象

01:05:32.700 --> 01:05:33.700
对象里面包含ref

01:05:33.700 --> 01:05:34.700
那就OK了

01:05:35.700 --> 01:05:37.700
那不可能就是ref object

01:05:37.700 --> 01:05:38.700
但是这个函数你看

01:05:38.700 --> 01:05:40.700
这个函数里面我用的是 reactivity

01:05:40.700 --> 01:05:41.700
当然是一个proxy 对吧

01:05:41.700 --> 01:05:42.700
内部可没问题

01:05:42.700 --> 01:05:45.700
这个函数内部你只能知道它是什么

01:05:45.700 --> 01:05:46.700
因为大把就在你面前

01:05:46.700 --> 01:05:48.700
当然知道

01:05:48.700 --> 01:05:49.700
但是就怕我将来

01:05:49.700 --> 01:05:50.700
除了这个函数我就不知道了

01:05:50.700 --> 01:05:51.700
我就蒙了

01:05:51.700 --> 01:05:52.700
那怎么办呢

01:05:52.700 --> 01:05:54.700
全部统一转换成ref

01:05:54.700 --> 01:05:56.700
这样子避免的外面

01:05:56.700 --> 01:05:57.700
去乱解构

01:05:57.700 --> 01:05:58.700
一展开就没了

01:05:58.700 --> 01:05:59.700
想起事情没了

01:05:59.700 --> 01:06:01.700
我在这里就可以转换成ref

01:06:01.700 --> 01:06:03.700
把这个 reactivity

01:06:03.700 --> 01:06:04.700
就变成这个了

01:06:04.700 --> 01:06:05.700
你看无论是这个函数

01:06:05.700 --> 01:06:06.700
到这个函数

01:06:06.700 --> 01:06:07.700
它的输出就是返回结果

01:06:07.700 --> 01:06:08.700
是不是全是ref

01:06:08.700 --> 01:06:09.700
一个普通对象里面

01:06:09.700 --> 01:06:10.700
全是包含ref的

01:06:10.700 --> 01:06:12.700
包括这里一个read only

01:06:12.700 --> 01:06:13.700
对吧

01:06:13.700 --> 01:06:14.700
read only

01:06:14.700 --> 01:06:15.700
那么这里也是一个proxy

01:06:15.700 --> 01:06:17.700
但是我还是可以转换成ref

01:06:17.700 --> 01:06:19.700
全部变成ref

01:06:19.700 --> 01:06:20.700
而且这一属性全是止独的

01:06:20.700 --> 01:06:22.700
ref都是全部是止独的

01:06:22.700 --> 01:06:23.700
你不能改的

01:06:23.700 --> 01:06:24.700
那么这样子

01:06:24.700 --> 01:06:25.700
在set up 函数

01:06:25.700 --> 01:06:26.700
就没有什么新字负担了

01:06:26.700 --> 01:06:27.700
你管它是咋反的

01:06:27.700 --> 01:06:28.700
它一定是ref

01:06:28.700 --> 01:06:29.700
大胆的展开

01:06:29.700 --> 01:06:31.700
大胆的去解构

01:06:31.700 --> 01:06:32.700
都没有任何问题

01:06:32.700 --> 01:06:33.700
得到的数据全是ref

01:06:33.700 --> 01:06:34.700
也不用去担心什么

01:06:34.700 --> 01:06:35.700
我要不要点value

01:06:35.700 --> 01:06:36.700
这些东西

01:06:36.700 --> 01:06:37.700
不用去担心

01:06:37.700 --> 01:06:39.700
函是想用的是数据全是ref

01:06:41.700 --> 01:06:42.700
懂我的意思吗

01:06:42.700 --> 01:06:43.700
那么在这些函数里

01:06:43.700 --> 01:06:44.700
不要内部去实现

01:06:44.700 --> 01:06:45.700
到底是reactive

01:06:45.700 --> 01:06:46.700
还是read only

01:06:46.700 --> 01:06:47.700
这些乱七八糟的玩意

01:06:47.700 --> 01:06:48.700
还是compute的

01:06:48.700 --> 01:06:49.700
内部去实现

01:06:49.700 --> 01:06:50.700
在set up 函数里面

01:06:50.700 --> 01:06:51.700
全是ref

01:06:52.700 --> 01:06:53.700
原来的意思

01:06:53.700 --> 01:06:54.700
所以说

01:06:54.700 --> 01:06:56.700
这里我给大家说这么一种方案

01:06:56.700 --> 01:06:57.700
通过这种方案

01:06:57.700 --> 01:06:59.700
可以有效的将你新字负担

01:06:59.700 --> 01:07:01.700
这是我个人的理解

01:07:01.700 --> 01:07:03.700
好了 这就是这节课的内容

01:07:03.700 --> 01:07:04.700
慢慢去消化

01:07:04.700 --> 01:07:05.700
一整天的时间

01:07:05.700 --> 01:07:06.700
慢慢去消化

01:07:06.700 --> 01:07:07.700
目标

01:07:07.700 --> 01:07:09.700
把这些

01:07:09.700 --> 01:07:10.700
笔识体做出来

01:07:10.700 --> 01:07:11.700
然后呢

01:07:11.700 --> 01:07:12.700
其次呢

01:07:12.700 --> 01:07:13.700
理解

01:07:13.700 --> 01:07:15.700
我们将来在开发的时候

01:07:15.700 --> 01:07:17.700
怎么去在complete API里面

01:07:17.700 --> 01:07:18.700
用什么样的方式

01:07:18.700 --> 01:07:19.700
去将你这个新字负担

01:07:19.700 --> 01:07:20.700
当然大家有可能

01:07:20.700 --> 01:07:21.700
有一头有更好

01:07:21.700 --> 01:07:23.700
有出更聪明的方式

01:07:23.700 --> 01:07:25.700
可以互相交流一下

01:07:25.700 --> 01:07:26.700
好了

01:07:26.700 --> 01:07:27.700
这就可以到这里了

