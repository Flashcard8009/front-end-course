WEBVTT

00:00.240 --> 00:04.800
之后在面试题里面问到5又3的相关面试题的话

00:04.800 --> 00:08.200
他还有可能问到一个非常的重要的一个点

00:08.200 --> 00:11.880
就是5又3的效率啊 由于习有大大

00:11.880 --> 00:14.960
说的有很大的提升对吧 官方说的啊

00:14.960 --> 00:19.960
什么渲染效率啊 要比5又2啊 提升了1.3到2倍

00:19.960 --> 00:24.200
SSR效率呢 要比5又2提升了2到3倍

00:24.200 --> 00:27.120
SSR就服务端渲染啊 你们以后都要学的

00:27.320 --> 00:30.920
那么像这些效率的提升啊 其实官方说的这个

00:31.920 --> 00:36.120
这个数据呢 还算是相对保守了啊 实际上有的时候呢

00:36.120 --> 00:40.080
效率还提升了不止这么一些 那么他到底是怎么提升效率的

00:40.080 --> 00:43.120
面试题的 面试题里面可能会问到

00:43.680 --> 00:45.480
那么问到过后你怎么回答呢

00:47.280 --> 00:50.720
简单的回答就是你把这几个点说一下

00:50.720 --> 00:54.200
第一个他用了静态提升 第二个用了预知不错话

00:54.480 --> 00:57.440
第三个呢 缓存了事件处理寒兽 第四个呢 Block Tree

00:57.440 --> 00:58.720
第五个呢 Patch Flag

00:59.760 --> 01:02.160
那你不知道啥意思 就怕他细稳

01:02.720 --> 01:05.640
他怎么细稳的 他说那你详细说一说每一个点呗

01:06.200 --> 01:08.160
说一说 比方说一说那个预知不错话

01:08.720 --> 01:10.000
说一说这个 Block Tree

01:10.640 --> 01:12.440
那他你就不知道怎么怎么说了

01:12.440 --> 01:14.160
所以我们还是要详细的讲一讲啊

01:14.160 --> 01:15.760
他每个方面到底是怎么回事

01:15.760 --> 01:19.600
大家其实也可以通过5U的这些设计啊

01:20.040 --> 01:21.800
初步的去体会一下这种

01:22.760 --> 01:24.920
效率提升的时候 去考虑的点

01:26.480 --> 01:28.040
怎么去把它提升到极致

01:28.040 --> 01:31.720
5U3其实已经把效率 渲染效率已经提升到极致了

01:32.240 --> 01:33.520
很难再进一步提升了

01:34.240 --> 01:35.120
那么这些事情呢

01:35.120 --> 01:37.400
Rex一件都没有做 都没有做的

01:37.920 --> 01:40.920
所以说呢 其实Rex要跟那个5U来比的话

01:40.920 --> 01:42.360
特别是跟5U3来比的话

01:43.280 --> 01:44.680
其实他还不如5U3

01:44.680 --> 01:47.000
特别是你如果说对Rex控制不好

01:47.000 --> 01:50.320
因为5UX很多时候都需要你手动的去优化效率

01:50.800 --> 01:53.000
你控制不好的话 那远远不及5U3

01:53.360 --> 01:54.920
5U上效率做得非常非常好啊

01:55.440 --> 01:56.120
一个说吧

01:57.800 --> 02:00.000
第一个静态提升 啥意思呢

02:00.880 --> 02:03.040
就是说他5U他的编译器啊

02:03.480 --> 02:04.680
咱们不是有个编译器吗

02:05.840 --> 02:06.240
上节课

02:06.880 --> 02:09.200
是不是看到VET里边有这么一个东西

02:09.200 --> 02:12.960
Compatter SFC编译这么单文件组件

02:12.960 --> 02:15.920
实际上这个5UCDCLEE里边

02:15.920 --> 02:17.280
它的内部有VPEC

02:17.800 --> 02:18.880
它里边也用到这个东西

02:18.880 --> 02:20.080
它是一个编译器

02:20.360 --> 02:22.600
是不是我们有个预编译过程上节课说的

02:23.840 --> 02:24.840
有这么一个编译器

02:24.840 --> 02:26.040
它会把我们的什么

02:26.040 --> 02:27.120
把我们的模板

02:28.480 --> 02:29.440
把我们的这个玩意儿

02:30.880 --> 02:31.880
这不是模板吗

02:33.000 --> 02:35.360
把这个模板编译成为什么

02:35.360 --> 02:37.480
编译成为Render函数

02:38.640 --> 02:39.600
做一个编译过程

02:40.080 --> 02:41.520
把模板变成Render函数了

02:41.840 --> 02:43.440
然后这个玩意儿就编译成什么了

02:43.440 --> 02:44.800
编译成了一个Render函数

02:45.360 --> 02:46.520
Render函数里边

02:46.520 --> 02:48.200
以前5U2里边不是个H吗

02:48.400 --> 02:51.840
然后这个创建一个H

02:51.840 --> 02:52.960
一面击

02:52.960 --> 02:53.760
懂不懂的意思

02:53.760 --> 02:55.000
它编译成这个玩意儿了

02:55.600 --> 02:57.600
属性一个Alt属性

02:58.680 --> 02:59.400
就是这么一个意思

02:59.400 --> 03:00.240
我说一下

03:01.480 --> 03:02.480
它有个编译器

03:02.480 --> 03:04.440
把我们的模板编译成渲染函数

03:04.960 --> 03:06.240
那么编译器很智能

03:06.240 --> 03:07.000
现在5U3

03:07.560 --> 03:08.560
它在编译的时候

03:09.600 --> 03:12.160
它可以发现哪些节点是静态节点

03:12.600 --> 03:13.600
什么叫静态节点

03:13.600 --> 03:15.280
就是一个元素节点

03:15.280 --> 03:16.600
比方说像这个节点

03:17.520 --> 03:18.560
一个纯元素节点

03:18.560 --> 03:19.800
它不是用的是组件

03:19.800 --> 03:20.640
它没有用组件

03:20.640 --> 03:21.760
它用的是一个元素

03:22.160 --> 03:23.480
而且这个元素里边

03:23.480 --> 03:24.960
没有任何动态的内容

03:24.960 --> 03:26.800
是不是没有绑定任何的动态属性

03:27.280 --> 03:29.200
那么就是一个纯静态的东西

03:29.440 --> 03:30.320
这叫静态节点

03:30.840 --> 03:32.760
编译器会发现静态节点

03:33.320 --> 03:34.840
然后把它进行提升

03:35.320 --> 03:36.000
怎么来提升呢

03:36.000 --> 03:37.040
大家对比一下

03:37.560 --> 03:38.840
像5U2的时候

03:38.840 --> 03:39.800
它每次有编译器

03:39.800 --> 03:40.920
根本就不管什么静态节点

03:40.920 --> 03:41.640
还是动态节点

03:41.640 --> 03:42.960
全部变成这个样子

03:43.480 --> 03:44.680
我们Render函数里边

03:44.680 --> 03:45.760
刚才那个静态节点

03:45.840 --> 03:47.040
比方说有一个A7

03:47.040 --> 03:48.880
我们的模板里面有个A7元素

03:48.880 --> 03:50.240
这个A7元素

03:50.240 --> 03:51.840
它里边没有任何动态内容

03:51.840 --> 03:52.800
就是一个字幕刷

03:52.800 --> 03:54.240
Hello world

03:55.040 --> 03:57.120
那么在5U2里边编译出来就是

03:58.120 --> 04:00.400
渲染函数里边创建一个虚的节点

04:00.400 --> 04:00.640
对吧

04:00.640 --> 04:03.280
我们说的是V动虚的节点

04:04.280 --> 04:07.600
节点名字A7没有属向内容是Hello world

04:09.040 --> 04:10.080
那么在5U3里边

04:10.080 --> 04:11.960
它觉得这既然是一个静态节点

04:11.960 --> 04:13.440
它是不可能会有变化的

04:13.960 --> 04:15.240
不可能说这一次是A7

04:15.240 --> 04:16.520
就下一次变成H2了

04:16.520 --> 04:18.080
不可能说这一次是Hello world

04:18.080 --> 04:19.520
下一次变成了别的东西了

04:20.120 --> 04:21.360
因为它是静态的

04:21.960 --> 04:23.200
所以5U3它觉得

04:23.200 --> 04:26.520
这个东西没有必要在渲染函数里边进行创建

04:26.520 --> 04:28.920
因为渲染函数会不断的反复运行

04:28.920 --> 04:29.240
对吧

04:29.240 --> 04:30.120
只要数据更赶

04:30.120 --> 04:30.960
它会运行的

04:30.960 --> 04:31.760
重新运行的

04:31.760 --> 04:33.520
那么它就会重新创建新的函数

04:33.520 --> 04:34.400
没必要了

04:35.160 --> 04:36.520
于是为了提升的话

04:36.520 --> 04:37.680
为了提升效率

04:37.680 --> 04:38.360
它怎么样呢

04:38.360 --> 04:39.480
在5U3里边

04:39.480 --> 04:40.600
它会把它提出来了

04:41.200 --> 04:42.320
它编译在编译的时候

04:42.320 --> 04:43.120
它会看

04:44.080 --> 04:45.120
createVeload

04:45.120 --> 04:47.280
A7还是一样的创建一个虚拟节点

04:47.280 --> 04:49.080
然后把它提到上面去了

04:49.080 --> 04:50.680
那么这样子一来

04:50.680 --> 04:53.320
这个节点是不是永远只被创建一次

04:53.840 --> 04:56.600
之后在Render函数里面直接重复使用就完事了

04:57.120 --> 04:57.760
对吧

04:57.760 --> 05:00.000
那这个玩意我们能不能看到这个效果了

05:00.000 --> 05:00.360
可以

05:00.360 --> 05:02.080
其实我们这几颗奖了

05:02.080 --> 05:03.360
都是你们平时

05:03.920 --> 05:05.000
感知不到的

05:05.960 --> 05:07.200
你们平时写代码对吧

05:07.200 --> 05:08.440
写代码你肯定

05:08.800 --> 05:09.720
用不到这些东西

05:09.720 --> 05:11.400
因为它都是内部自动完成的

05:11.680 --> 05:12.760
你都不需要去管

05:12.800 --> 05:13.840
所以你感受不到的

05:13.840 --> 05:16.440
把这些看不见的点给大家说一说

05:16.640 --> 05:18.240
但它实际上是做了优化的

05:18.240 --> 05:18.720
看一下吧

05:18.720 --> 05:19.800
随便看一下

05:19.800 --> 05:20.960
简单的看一下就行了

05:21.800 --> 05:22.400
这wit

05:22.400 --> 05:23.360
随便打开一个

05:23.360 --> 05:23.960
怎么办

05:26.540 --> 05:27.940
这边打开过了是吧

05:28.540 --> 05:28.860
好

05:28.860 --> 05:29.740
让我们打开

05:30.740 --> 05:32.260
点击右键检查

05:32.260 --> 05:33.860
然后我们看一下

05:33.860 --> 05:34.940
随便加一个吧

05:34.940 --> 05:35.980
加一个

05:36.660 --> 05:37.660
A7元素

05:39.020 --> 05:39.780
Hello

05:39.780 --> 05:40.980
你看5U3里边

05:40.980 --> 05:42.580
是不是可以允许多个根元素

05:42.860 --> 05:44.700
这个点了我们之后再说

05:45.260 --> 05:45.900
刷新

05:45.900 --> 05:47.100
然后看一下nestwork

05:47.700 --> 05:50.140
看一下这个APP type template

05:50.140 --> 05:50.340
对吧

05:50.340 --> 05:51.180
这是编译结果

05:51.180 --> 05:52.180
模板的编译结果

05:52.180 --> 05:53.180
上级可提到一下

05:53.820 --> 05:54.420
点击过后

05:54.420 --> 05:55.060
你看一下这边

05:56.100 --> 05:57.060
简单看一下就行了

05:57.060 --> 05:58.140
不用太过于深究

05:58.740 --> 05:59.340
看呗

06:00.540 --> 06:02.500
是不是提到这个Render函数外面去了

06:02.780 --> 06:03.060
对吧

06:03.060 --> 06:04.380
就是静态节点提升

06:05.020 --> 06:06.220
这是这一块

06:07.420 --> 06:07.820
然后呢

06:07.820 --> 06:09.500
其实不仅是静态节点

06:09.500 --> 06:11.580
还有就是静态属性

06:11.580 --> 06:12.500
它也会提升

06:12.700 --> 06:13.900
比方说你像这个玩意儿

06:14.220 --> 06:15.660
这个DEV有一个属性

06:15.660 --> 06:16.260
class

06:16.260 --> 06:18.140
有这么一个属性

06:18.140 --> 06:19.900
哎这个属性呢

06:20.060 --> 06:21.100
它是静态的

06:21.340 --> 06:21.540
对吧

06:21.540 --> 06:23.060
它尽管它这个DEV

06:23.060 --> 06:24.220
这个DEV节点

06:24.220 --> 06:25.140
它不是静态的

06:25.140 --> 06:25.540
为什么

06:25.540 --> 06:26.700
因为它内容是动态的

06:27.140 --> 06:28.180
节点本身不是静态的

06:28.180 --> 06:29.660
但它属性是静态的

06:30.140 --> 06:31.060
那么如果说

06:31.060 --> 06:32.980
我用像5U2那样子

06:32.980 --> 06:34.060
每支双渐节点的时候

06:34.060 --> 06:36.100
都给它一个属性

06:36.700 --> 06:38.260
因为它这个时候5U3也没办法了

06:38.260 --> 06:39.740
必须要再放到Render函数里边

06:39.740 --> 06:39.980
对吧

06:39.980 --> 06:41.420
因为它不是静态的

06:41.740 --> 06:43.300
但是它的属性是静态的

06:43.300 --> 06:47.100
因此它可以把这个属性对象提出来

06:47.340 --> 06:48.580
这样子是不是可以重用

06:48.580 --> 06:50.020
反复的重用这个对象

06:50.220 --> 06:50.700
对不对

06:50.700 --> 06:52.380
就是减少了内存占用

06:52.820 --> 06:53.180
不然的话

06:53.180 --> 06:54.180
你每一次调用Render函数

06:54.180 --> 06:55.420
是不是要创建一个新的对象

06:55.420 --> 06:56.900
如果说你像5U2那样子

06:56.900 --> 06:57.860
这样子写的话

06:58.020 --> 06:59.540
就每次会创建一个新的对象

07:00.060 --> 07:00.500
对吧

07:00.500 --> 07:02.700
它这个地方有一个提升

07:03.020 --> 07:04.140
它的静态提升

07:04.140 --> 07:05.540
指的是这么一个意思

07:06.140 --> 07:07.220
好 下一个点

07:07.500 --> 07:09.100
我下个点超级厉害的

07:09.300 --> 07:10.300
真的超级厉害

07:10.660 --> 07:11.580
我极其佩服

07:11.860 --> 07:13.060
它能够把这一点做到

07:13.580 --> 07:14.380
这一点过去了

07:14.380 --> 07:16.180
只是存在于理想状态下

07:17.060 --> 07:18.340
它是真的把它实现的

07:18.460 --> 07:19.740
叫做预制服创划

07:19.740 --> 07:20.700
相当厉害

07:20.980 --> 07:22.220
其实我们可以回顾一下

07:22.220 --> 07:23.820
咱们平时用5U开发

07:24.020 --> 07:25.260
各种组件的时候

07:26.540 --> 07:29.660
组件里边是真没有多少动态的东西

07:30.020 --> 07:30.900
你回忆一下

07:31.380 --> 07:33.860
组件里边好多元素

07:33.860 --> 07:34.980
都是静态元素

07:36.540 --> 07:38.180
都是做一些央视

07:39.220 --> 07:41.140
做一些布局等等

07:41.300 --> 07:43.820
只有一少量的东西才是动态的

07:44.100 --> 07:45.460
比较说我这里随便举了个例子

07:45.700 --> 07:46.340
这么一个组件

07:46.340 --> 07:47.660
组件的模板里边是这样子

07:47.860 --> 07:49.460
那么模板也要进行编译

07:49.700 --> 07:51.820
你看这个模板的里边东西

07:51.980 --> 07:53.620
几乎全部是静态的

07:54.180 --> 07:55.580
就这个地方有一个动态的

07:55.820 --> 07:57.420
我们把它叫做动静笔

07:58.260 --> 08:00.340
动态的内容比上静态的内容

08:00.740 --> 08:02.060
那么这个比例越小

08:02.060 --> 08:03.300
是不是静态的内容越多

08:03.860 --> 08:04.380
比例越大

08:04.380 --> 08:05.260
动态的内容越多

08:05.260 --> 08:05.540
对吧

08:05.540 --> 08:06.700
其实很多组件都是

08:07.420 --> 08:08.660
很多组件动静笔

08:08.820 --> 08:09.820
都是比较小的

08:10.060 --> 08:11.380
静态的内容是比较多的

08:12.380 --> 08:14.100
那么你看这个组件就是这样子

08:15.740 --> 08:16.660
编译器

08:16.660 --> 08:17.620
5U3的编译器

08:17.620 --> 08:19.980
会非常智能的发现这一点

08:20.220 --> 08:23.140
它发现了我遇到了这些元素

08:23.420 --> 08:27.420
有大量的连续的静态元素

08:28.020 --> 08:28.460
你看

08:29.020 --> 08:30.100
这是一个元素

08:30.100 --> 08:31.380
下面这个也是静态的

08:31.380 --> 08:32.300
这也是静态的

08:32.300 --> 08:33.340
这也是静态的

08:33.580 --> 08:34.860
A元素也是静态的

08:35.100 --> 08:36.740
这个也是静态的

08:36.740 --> 08:37.700
A元素也是静态的

08:37.780 --> 08:40.740
有大量的连续的静态元素

08:41.300 --> 08:43.420
它就做了一个非常不可思议的决定

08:43.940 --> 08:44.780
编译器决定的

08:45.300 --> 08:46.340
它做什么收拾呢

08:46.860 --> 08:48.820
编译成这个样子

08:51.190 --> 08:52.630
这是5U2里面没有的

08:52.990 --> 08:54.510
它直接把它变成一个制服串了

08:54.710 --> 08:56.710
因为它知道这些东西永远不会变化的

08:56.710 --> 08:57.310
它是静态的

08:58.510 --> 08:59.830
以前5U2很傻的

08:59.830 --> 09:01.990
5U2里面它要变成一个虚拟节点

09:01.990 --> 09:02.910
它要变成一个虚拟节点

09:02.910 --> 09:04.270
它还要变成一个虚拟节点

09:04.590 --> 09:05.390
它是个虚拟节点

09:05.390 --> 09:07.230
它是一个它还是一个

09:07.230 --> 09:08.150
一大堆虚拟节点

09:08.190 --> 09:09.350
但是这些东西全是静态的

09:09.350 --> 09:09.910
不会变的

09:10.510 --> 09:12.430
5U3会智能的发现这一点

09:12.630 --> 09:13.950
于是在编译的结果里面

09:13.950 --> 09:15.230
直接变成一个制服串了

09:15.950 --> 09:17.950
叫做Static VLOG的静态节点

09:17.950 --> 09:18.990
其实我们可以马上看一下

09:20.230 --> 09:23.450
这个地方复制一下

09:24.450 --> 09:25.850
就放到这个APP里面吧

09:25.850 --> 09:26.410
就放在这

09:28.050 --> 09:29.410
这U2.0没有是吧

09:30.290 --> 09:31.810
没有我们就是写一个吧

09:33.010 --> 09:33.410
V2

09:35.810 --> 09:36.210
U2

09:36.890 --> 09:37.210
Lin

09:37.650 --> 09:38.210
Mole

09:39.690 --> 09:40.410
保存

09:42.410 --> 09:44.450
干脆我还是不要改动上级课的东西了

09:45.090 --> 09:46.410
还是不要改动上级课的东西

09:48.250 --> 09:49.730
我把他放到这几课吧

09:51.050 --> 09:51.730
VetsAPP

09:52.810 --> 09:53.370
放到这一课

09:55.880 --> 09:56.360
重新打开

10:00.780 --> 10:01.660
这里重新打开

10:04.100 --> 10:06.100
NpnRender

10:08.260 --> 10:09.420
我重新安装一下移轮

10:17.920 --> 10:18.720
重新安装一下移轮

10:19.360 --> 10:20.720
这个一般拷贝工程的话

10:20.720 --> 10:22.040
不要拷贝的Rodemodus

10:31.920 --> 10:32.120
打开

10:32.920 --> 10:34.360
现在我们在这边改一下

10:35.160 --> 10:35.720
复制一下

10:36.520 --> 10:37.080
到这边来

10:38.680 --> 10:39.160
APP

10:40.360 --> 10:42.520
在这边把个模板改一下

10:42.520 --> 10:43.640
看他编译的结果

10:43.880 --> 10:45.160
然后在这边我们给他一个数据

10:45.160 --> 10:46.400
随便给一下一个数据

10:47.200 --> 10:47.800
Return

10:48.440 --> 10:51.280
UserNameMole

10:52.400 --> 10:53.120
保存

10:53.640 --> 10:54.560
先让大家刷新一下

10:55.560 --> 10:56.720
看一下编译的模板

10:57.600 --> 10:58.680
你看是不是个静态节

10:59.000 --> 11:00.320
前面一大堆静态的这种

11:00.320 --> 11:01.600
全部编译成个字不错的

11:01.880 --> 11:03.080
我们可以通过这张图

11:03.080 --> 11:04.320
可以非常清晰的看到

11:04.800 --> 11:06.400
5u2就同样的模板

11:06.680 --> 11:08.040
5u2编译出来了

11:08.320 --> 11:09.800
它是一大堆的虚拟节点

11:10.160 --> 11:12.320
它还不知道这些哪些节点是动态的

11:12.320 --> 11:13.360
哪些节点是静态的

11:13.800 --> 11:15.040
它全部一视同仁

11:16.160 --> 11:17.280
那么这样子到时候

11:17.440 --> 11:18.480
对比的时候

11:18.600 --> 11:19.520
重新选用的时候

11:19.520 --> 11:21.680
是不是又重新会生成一大堆虚拟节点

11:22.400 --> 11:24.000
这样子极其的浪费效率

11:24.720 --> 11:25.800
但5u3你看一下

11:26.360 --> 11:27.320
它变成一个字无窜了

11:27.880 --> 11:29.000
只有动态的节点

11:29.000 --> 11:29.800
我们需要记住

11:30.360 --> 11:31.720
静态的节点变成个字无窜了

11:31.840 --> 11:32.480
这样子

11:33.120 --> 11:34.440
节点数是不是降低了

11:34.440 --> 11:35.320
非常非常多

11:35.520 --> 11:35.760
对吧

11:35.760 --> 11:36.920
只虚拟节点的处理

11:39.460 --> 11:39.780
好

11:39.780 --> 11:40.740
然后这是第二个

11:40.820 --> 11:41.700
预制服窍化

11:41.940 --> 11:42.820
把变成个字无窜

11:43.420 --> 11:45.260
这一点在SSR里面

11:45.260 --> 11:46.420
作用特别明显

11:46.940 --> 11:47.700
服务端

11:48.340 --> 11:50.220
我们把它预制服窍化过后

11:51.060 --> 11:51.860
只是往客户端

11:51.860 --> 11:52.860
不到那发送一个字无窜

11:52.860 --> 11:53.460
做一个字无窜

11:53.460 --> 11:54.300
凭借就完事了

11:54.540 --> 11:56.180
所以在SSR里面

11:56.340 --> 11:57.300
它的作用非常明显

11:57.300 --> 11:58.580
效率提升是非常明显

11:59.980 --> 12:01.060
那看第三个

12:01.660 --> 12:03.420
缓存事件处理函数

12:03.820 --> 12:04.700
这啥意思呢

12:04.700 --> 12:05.460
你看一下

12:05.460 --> 12:06.980
咱们以前的编译

12:06.980 --> 12:08.140
还是说模板编译

12:08.580 --> 12:09.180
有一个模板

12:09.180 --> 12:10.180
模板里面是button

12:10.420 --> 12:11.860
button里面有个事件click

12:12.100 --> 12:13.100
这动态内容对吧

12:13.100 --> 12:14.940
有一个处理函数靠扯加加

12:16.500 --> 12:17.660
那么在5u2里边

12:17.660 --> 12:18.980
它怎么编译的呢

12:18.980 --> 12:19.540
它会吧

12:19.860 --> 12:21.780
这样子变成一个虚拟节点

12:21.780 --> 12:22.700
名字是button

12:22.700 --> 12:23.380
然后呢

12:23.380 --> 12:25.180
它的属性里边多了一个事件

12:25.180 --> 12:25.980
onclick

12:26.300 --> 12:27.220
它有个函数

12:27.620 --> 12:29.580
函数里边内容就是

12:30.260 --> 12:30.980
靠扯加加

12:31.980 --> 12:33.580
这是5u2的处理方式

12:34.540 --> 12:36.340
那么5u3的处理方式呢

12:37.100 --> 12:38.340
它就有缓存了

12:38.340 --> 12:40.180
它认为了这个事件处理

12:40.180 --> 12:41.660
你这里的事件处理

12:41.660 --> 12:43.260
实际上它是不会变化的

12:43.940 --> 12:45.580
你不是说这一次渲染的时候

12:45.580 --> 12:46.780
它是一个事件函数

12:47.020 --> 12:47.820
下一次渲染的时候

12:47.820 --> 12:49.340
就变成另外一个事件函数了

12:50.100 --> 12:51.500
是不是不会遇到这种情况

12:51.500 --> 12:52.940
至少这个模板

12:52.940 --> 12:53.820
不会遇到这种情况

12:54.300 --> 12:56.500
于是5u3会智能的发现这一点

12:56.700 --> 12:57.780
它会做缓存

12:58.380 --> 12:59.980
你看5u3的渲染函数里边

13:00.460 --> 13:02.820
5u3的渲染函数里边实际上有参数非常多

13:02.820 --> 13:04.260
它其中一个参数就是catch

13:04.860 --> 13:06.060
一个缓存对象

13:07.100 --> 13:10.460
那么我在写这个onclick函数的时候

13:10.460 --> 13:12.180
它会把这个人编译成一个函数

13:12.620 --> 13:13.940
它看一下这个缓存对象里边

13:13.940 --> 13:14.940
有没有这个函数

13:14.940 --> 13:16.220
有的话直接返回了

13:16.700 --> 13:17.700
没有的话

13:17.700 --> 13:19.340
我就给这个这一项复职

13:19.340 --> 13:20.460
复职为一个函数

13:20.460 --> 13:21.700
这个函数就是靠扯加加

13:23.220 --> 13:25.860
有信任同学可以把这个模板拿过去试一试

13:25.860 --> 13:26.540
试一试

13:26.540 --> 13:27.780
看一下它的编译结果

13:28.260 --> 13:28.780
对吧

13:29.420 --> 13:30.860
好都是缓存处理函数

13:30.860 --> 13:31.740
它有一个缓存

13:31.740 --> 13:34.380
那么保证了事件处理函数只生成一次

13:34.380 --> 13:35.660
下一次就不用再生存了

13:37.180 --> 13:37.820
好下一个

13:38.900 --> 13:40.580
这一点更新也是非常

13:40.860 --> 13:42.060
一个非常大的更新

13:42.060 --> 13:43.660
只是我们平时感觉不到而已

13:43.660 --> 13:44.980
因为它是自动完成的

13:45.300 --> 13:46.100
要block tree

13:47.420 --> 13:49.420
这个问题它不是

13:50.100 --> 13:51.340
跟编译有一点关系

13:51.340 --> 13:52.820
跟运行还有一点关系

13:54.740 --> 13:55.700
block tree

13:56.420 --> 13:57.580
是为了解决什么问题

13:57.940 --> 14:01.460
是为了解决新旧两棵树在堆笔的时候

14:03.540 --> 14:05.540
为了提升堆笔的效率

14:05.540 --> 14:08.180
我们把这个堆笔的在维尤里面叫做patch

14:08.180 --> 14:08.740
对不对

14:09.300 --> 14:11.300
patch过程就是个堆笔的过程

14:13.020 --> 14:14.740
那么过去是怎么堆笔的呢

14:15.220 --> 14:15.940
看一下啊

14:15.940 --> 14:17.340
我们比方说有这么一个模板

14:18.340 --> 14:19.580
有这么一个DVA里面

14:20.580 --> 14:21.620
有这个动态节点

14:21.940 --> 14:22.940
有这个动态节点

14:23.460 --> 14:26.220
过去它生成了这么一个树

14:26.700 --> 14:27.140
看呗

14:27.820 --> 14:28.860
生成了这么一个树

14:30.180 --> 14:30.540
对

14:30.540 --> 14:31.820
我之前还忘了说一件

14:31.820 --> 14:33.100
预制不说话

14:33.100 --> 14:36.460
这里只有连续的大量的连续的静态节点

14:36.460 --> 14:37.860
才会预制不说话

14:38.260 --> 14:41.100
目前是连续20个节点

14:41.460 --> 14:43.340
有连续20个静态节点

14:43.340 --> 14:44.340
它就会制不说话

14:44.820 --> 14:46.900
如果说不是大量连续的话

14:46.900 --> 14:48.020
它还是用原来的方式

14:48.020 --> 14:49.660
我们回头到这

14:50.660 --> 14:52.220
那么这个时候呢

14:52.820 --> 14:54.820
维尤2和维尤3生成的树

14:54.820 --> 14:55.700
是不是一样的

14:55.700 --> 14:56.380
蓄力树

14:57.100 --> 14:58.100
结构都是一样的

14:59.220 --> 15:00.660
关键在派起算法这里

15:02.100 --> 15:03.700
在对比新旧两棵树的时候

15:03.700 --> 15:04.500
维尤2

15:04.500 --> 15:05.620
它会做这么一个对比

15:06.780 --> 15:07.580
先对比它

15:08.380 --> 15:09.140
再对比它

15:09.140 --> 15:09.780
对吧

15:09.780 --> 15:10.860
它跟它

15:11.260 --> 15:12.340
再对比它

15:12.340 --> 15:13.060
跟它

15:13.620 --> 15:15.060
再对比它跟它

15:16.060 --> 15:18.660
你看是不是做了很多没有意义的对比

15:19.540 --> 15:21.460
这些是静态节点

15:22.180 --> 15:24.220
静态节点有可能变化吗

15:24.740 --> 15:26.380
它们永远不可能变化

15:26.620 --> 15:27.140
对不对

15:27.140 --> 15:28.220
这对比它干嘛呢

15:28.940 --> 15:30.220
最终对比出来

15:30.220 --> 15:31.340
发现这个音铺车

15:31.340 --> 15:32.780
跟这个音铺车的植物一样

15:32.780 --> 15:33.180
对吧

15:33.180 --> 15:34.140
这个才做更新

15:34.540 --> 15:35.020
但是呢

15:35.020 --> 15:37.100
实际上很多是没有意义的对比

15:38.140 --> 15:39.780
那么维尤3是怎么来处理的呢

15:39.780 --> 15:40.580
你看维尤3

15:41.980 --> 15:42.860
维尤3的边

15:42.860 --> 15:44.740
一拖它的强大的边义器

15:45.420 --> 15:48.860
边义器能够对每一个节点进行标记

15:49.100 --> 15:51.660
标记它到底是一个动态的节点

15:51.660 --> 15:52.700
还是个静态的节点

15:53.260 --> 15:53.700
对吧

15:54.100 --> 15:55.740
动态节点它就会做标记

15:56.420 --> 15:58.060
静态的节点它就会做标记

15:58.340 --> 15:59.060
没人意识吧

15:59.540 --> 16:00.980
你看标志用随便找一个

16:02.100 --> 16:03.700
维尤3里边我这里

16:04.460 --> 16:06.460
写上一个下面写上一个A器嘛

16:09.560 --> 16:10.200
你看一下吧

16:14.200 --> 16:15.240
A器

16:16.040 --> 16:16.440
上级

16:18.810 --> 16:19.730
我的A器呢

16:19.930 --> 16:20.930
在这啊在这

16:21.570 --> 16:24.050
它这里可以看一下创建vlog的时候

16:24.050 --> 16:25.050
是不是多了一个标记

16:25.050 --> 16:25.250
对吧

16:25.250 --> 16:26.370
这个数字就是个标记

16:26.650 --> 16:28.530
表示这个A器一样

16:32.890 --> 16:34.210
我这里还要写个动态那种

16:35.170 --> 16:36.170
我不用写A器

16:36.170 --> 16:36.810
就是个Span

16:36.810 --> 16:38.090
这个Span就看得很清楚了

16:39.250 --> 16:39.810
好再来

16:40.610 --> 16:41.330
Span元素

16:42.330 --> 16:43.370
创建

16:44.970 --> 16:46.090
我打开了诗这个吧

16:46.730 --> 16:47.570
Span元素

16:49.090 --> 16:51.810
Span元素

16:52.170 --> 16:53.410
你看这里是不是写了个E

16:53.930 --> 16:55.010
表示什么意思呢

16:55.130 --> 16:56.530
表示它的内容啊

16:56.810 --> 16:58.130
它是一个动态节点

16:59.090 --> 17:00.090
它的内容

17:00.290 --> 17:01.850
动态的是哪个地方的text

17:01.850 --> 17:02.850
我们以后再说

17:03.210 --> 17:03.890
就这个地方

17:04.090 --> 17:05.650
因为它会做一个标记啊

17:05.650 --> 17:07.570
标记它是一个动态节点

17:08.330 --> 17:09.250
还是静态节点

17:09.490 --> 17:10.450
而且呢

17:10.450 --> 17:12.650
它会把所有的动态节点

17:12.650 --> 17:13.770
提取到

17:14.530 --> 17:15.650
跟节点里面去

17:15.970 --> 17:18.170
就是说我们这个form节点里面啊

17:18.170 --> 17:20.130
它实际上里面内部有一个数组

17:20.410 --> 17:21.770
这个数组记录了

17:21.770 --> 17:24.450
我的所有后代节点中

17:24.850 --> 17:26.370
哪些是动态的

17:27.610 --> 17:28.370
懂我的意思吧

17:28.690 --> 17:30.610
我刚才好像讲超超前了啊

17:30.610 --> 17:32.090
讲到Patch flag里面去了

17:32.090 --> 17:33.410
这个玩意叫做Patch flag

17:33.450 --> 17:34.370
我们以后再说了

17:34.370 --> 17:35.650
我这里讲超超前了

17:35.650 --> 17:36.450
回到这来

17:36.650 --> 17:38.210
就是说在5u2的时候

17:38.210 --> 17:39.690
它会所有节点都是一样的

17:39.690 --> 17:40.690
它会一次对比

17:40.770 --> 17:42.290
但是呢在5u3里面

17:42.290 --> 17:42.930
不是的

17:43.250 --> 17:45.370
它会在跟节点里面就会记录

17:45.810 --> 17:46.690
这个节点

17:46.690 --> 17:48.610
所后代的所有节点中

17:48.610 --> 17:49.890
哪些是动态的

17:50.090 --> 17:51.690
编译器就会把它记录下来

17:53.560 --> 17:55.160
记录下来有什么好处呢

17:55.160 --> 17:56.440
到时候对比的时候

17:56.440 --> 17:58.280
它不是整个数一次对比

17:58.560 --> 17:59.680
直接找到跟节点

18:00.600 --> 18:01.920
我们把它叫做block节点

18:02.440 --> 18:04.040
就是凡是记录了

18:04.800 --> 18:06.200
有哪些动态节点的节点

18:06.200 --> 18:07.280
就是block节点

18:07.520 --> 18:08.560
整个是一个block

18:08.880 --> 18:09.680
一个core

18:10.560 --> 18:12.040
它对比两个core的时候

18:12.040 --> 18:13.360
它不用把每个core里面的

18:13.360 --> 18:14.360
每个节点去对比

18:14.560 --> 18:15.520
它直接找到它的

18:16.000 --> 18:16.960
block的跟节点

18:17.520 --> 18:19.440
然后呢去找到一个数组

18:19.440 --> 18:21.080
那个数组里面就记录了两个音铺册

18:21.080 --> 18:21.440
对吧

18:21.440 --> 18:23.640
这边的数组里面也记录了两个音铺册

18:24.400 --> 18:25.400
循环数组

18:26.320 --> 18:27.840
一时对比数组的每一下

18:28.560 --> 18:29.600
那么是不是就略过了

18:29.600 --> 18:31.000
全部的静态节点

18:31.280 --> 18:33.040
因为它这个block数组里面

18:33.120 --> 18:34.480
只记录动态节点

18:35.480 --> 18:36.240
写个伟大码

18:36.760 --> 18:37.880
左边的那个数里边

18:38.200 --> 18:38.880
左边的

18:39.160 --> 18:40.600
左边的block里边

18:41.720 --> 18:42.480
有一个数组

18:43.240 --> 18:44.240
第一个音铺

18:44.400 --> 18:45.240
第二个音铺

18:45.880 --> 18:47.160
只有这两个节点是动态的

18:47.680 --> 18:49.360
右边的block里边

18:51.620 --> 18:52.260
也是一样

18:53.900 --> 18:54.780
音铺是1

18:54.780 --> 18:55.620
音铺是2

18:55.620 --> 18:57.420
因此到时候它对比的时候

18:57.660 --> 18:58.540
找到block

18:59.900 --> 19:00.740
循环数组

19:00.740 --> 19:02.620
是不是这样子的数字是非常非常快

19:03.380 --> 19:05.060
不涉及什么数的遍地了

19:05.340 --> 19:07.380
不涉及数的什么深度遍地

19:07.380 --> 19:08.060
广度遍地的

19:08.060 --> 19:08.980
不涉及这个东西了

19:09.380 --> 19:11.860
那么也同时有挑过了静态节点

19:12.380 --> 19:14.260
这个效率体称是非常非常大

19:15.220 --> 19:15.860
懂了那意思吧

19:15.860 --> 19:18.340
而且还是一个动静比

19:18.700 --> 19:19.860
静态内容越多

19:19.860 --> 19:21.060
这个效率体称就越大

19:22.060 --> 19:23.220
远远不止两倍

19:24.460 --> 19:25.420
挑过了很多节点

19:26.300 --> 19:27.780
当然这里边还有很多细节的问题

19:27.780 --> 19:28.860
我们不去深究了

19:28.980 --> 19:29.580
比方说

19:29.580 --> 19:31.100
那有些同学说这个数不稳定

19:32.020 --> 19:33.140
就是有的时候

19:33.460 --> 19:34.380
更新之前是

19:34.660 --> 19:35.860
一个分支更新之后

19:35.860 --> 19:36.900
变成三个分支了

19:37.060 --> 19:38.060
或者是少了一个分支

19:38.500 --> 19:40.060
数不稳定的时候要出问题的

19:40.740 --> 19:41.300
数不稳定的时候

19:41.300 --> 19:42.460
就可能导致之前

19:42.740 --> 19:43.620
数组里面有两项

19:43.620 --> 19:44.940
之后的数组里面只有一项了

19:44.940 --> 19:45.820
或者有三项了

19:45.940 --> 19:46.700
就是要出问题

19:47.100 --> 19:48.460
那么数不稳定的时候

19:48.700 --> 19:49.700
它有特殊的处理

19:50.060 --> 19:51.220
凡是不稳定的地方

19:51.220 --> 19:52.220
它全部要变成块

19:52.700 --> 19:54.660
比如这个分支

19:54.820 --> 19:56.260
这个分支里面的分支不稳定

19:56.260 --> 19:57.620
那么这个地方要变成一个块

19:58.100 --> 19:58.820
要变成一个block

20:00.100 --> 20:00.620
是这么个意思

20:00.780 --> 20:02.220
它里面具体处理过程

20:02.220 --> 20:03.060
还是蛮复杂的

20:03.060 --> 20:04.300
就大概是这么个意思

20:04.500 --> 20:05.780
它会挑过很多的

20:05.900 --> 20:07.420
没有必要去比较的节点

20:08.020 --> 20:09.220
真的是优化到极致的

20:10.740 --> 20:12.260
好 最后一个是 patch flag

20:14.140 --> 20:15.740
那这个仪式变态了

20:16.180 --> 20:17.700
前面的仪式是优化到极致的

20:17.700 --> 20:19.900
这个地方就是优化到变态的程度了

20:21.660 --> 20:22.300
它觉得呢

20:22.300 --> 20:23.180
吴又山觉得

20:23.580 --> 20:25.460
我在对比某一个节点的时候

20:25.460 --> 20:26.540
还是在浪费效率

20:26.900 --> 20:28.620
尽管我挑过了所有没有

20:28.780 --> 20:29.740
不需要比对的节点

20:29.780 --> 20:31.020
吴又山真的能做到

20:32.020 --> 20:34.020
对所有不需要比对的节点

20:34.020 --> 20:35.820
他可以不进行比对

20:36.260 --> 20:36.820
他做到了

20:37.220 --> 20:38.540
真的做到这一点

20:39.220 --> 20:40.180
但是在对比

20:40.780 --> 20:42.220
某一个节点的时候

20:43.100 --> 20:44.140
他对比哪些内容呢

20:44.140 --> 20:45.900
他对比他的属性有没有变化

20:46.260 --> 20:47.620
节点内容有没有变化

20:48.020 --> 20:49.660
节点的内容有没有变化

20:49.860 --> 20:50.220
对吧

20:50.220 --> 20:51.900
这要对比很多东西

20:52.540 --> 20:54.340
那么对单个节点的对比的时候

20:54.340 --> 20:55.940
它进一步进行的优化

20:55.940 --> 20:56.700
它怎么来优化呢

20:56.700 --> 20:57.740
靠这个 patch flag

20:58.700 --> 21:00.740
这个还是要依托于吴又山

21:00.740 --> 21:02.220
强大的编译器

21:02.380 --> 21:04.260
在吴又山编译的内容中

21:04.260 --> 21:06.300
他会得记录这个节点

21:06.940 --> 21:08.620
哪一块是动态内容

21:08.780 --> 21:10.060
你看他如果是写个1

21:10.060 --> 21:11.340
编译的结果是个1

21:11.340 --> 21:12.700
就表示这个节点呢

21:12.700 --> 21:15.380
他的元素内容是动态的

21:16.820 --> 21:17.580
懂了意思吧

21:17.580 --> 21:17.820
好

21:17.820 --> 21:18.980
那如果说这个地方

21:19.380 --> 21:20.020
随便过去

21:20.020 --> 21:20.620
随便举个例子

21:20.620 --> 21:21.260
下举个例子

21:21.780 --> 21:22.460
优要表现

21:23.460 --> 21:23.660
好

21:23.660 --> 21:24.460
如果说你这样子写的话

21:24.460 --> 21:25.260
我们看一下模板

21:31.610 --> 21:32.770
没了

21:32.770 --> 21:34.050
就在DIV里面去了

21:35.490 --> 21:35.850
好

21:36.210 --> 21:36.770
你看

21:38.810 --> 21:40.450
这个DIV你看是不是就2

21:40.450 --> 21:41.410
表示他的class

21:41.410 --> 21:43.210
他的内容式是动态的

21:43.610 --> 21:43.850
好了

21:43.850 --> 21:44.850
如果说span里边

21:44.850 --> 21:45.770
我有加个class

21:46.250 --> 21:46.970
有这个点零

21:46.970 --> 21:48.730
你看他编译结果里面是会记录的

21:48.730 --> 21:50.170
他到底哪一块是动态的

21:51.450 --> 21:52.290
变成3

21:52.290 --> 21:52.690
对吧

21:53.330 --> 21:56.210
text和class都是动态的

21:57.250 --> 21:58.090
他里面实际上

21:58.530 --> 22:00.450
有记录的编译结果里面有记录

22:00.850 --> 22:02.490
那么有了这个记录过后

22:02.490 --> 22:04.370
以前5u2在比对的时候

22:04.370 --> 22:06.010
两个节点在比对的时候

22:06.370 --> 22:07.370
所以一个一个比对

22:07.370 --> 22:08.970
比对节点内形

22:09.730 --> 22:11.290
比对他的每一个属性

22:11.290 --> 22:12.530
比对他的内容

22:13.290 --> 22:14.490
在5u3里面不用了

22:15.330 --> 22:17.330
如果他就可以通过这个patch flag

22:18.130 --> 22:19.090
patch就一对

22:19.490 --> 22:21.050
比对这个标记

22:21.450 --> 22:22.210
来看一下

22:22.210 --> 22:24.690
我发现patch flag是一

22:24.690 --> 22:26.690
说明了前后变化

22:26.690 --> 22:28.370
只有可能是内容变化

22:29.090 --> 22:30.090
其他的一概不看

22:30.370 --> 22:31.530
就看内容有没有变化

22:32.010 --> 22:32.490
就像了

22:33.290 --> 22:35.010
就是这么一个意识

22:35.610 --> 22:36.570
所以有了这个东西过后

22:37.650 --> 22:40.210
在推比某一个节点的时候

22:40.210 --> 22:41.970
销物率进一步提升了

22:42.730 --> 22:44.570
你看5u3做了这么一些事情

22:44.570 --> 22:45.370
来提升销物

22:45.690 --> 22:46.970
销物率提升是非常大的

22:47.330 --> 22:48.090
非常明显的

22:48.090 --> 22:50.450
特别是销物越大越复杂

22:50.650 --> 22:51.170
动静

22:51.170 --> 22:52.290
精彩内容越多

22:52.530 --> 22:53.930
销物率提升越高

22:54.810 --> 22:58.050
这是5u3对销物率方面做了优化

22:58.050 --> 22:59.610
那你知道这些东西过后

22:59.650 --> 23:01.890
你看面试题就很好回答了

23:01.890 --> 23:03.090
他无论你问什么

23:03.090 --> 23:04.690
你都可以详细的给他描述

23:04.690 --> 23:05.770
他到底是怎么去做的

23:06.690 --> 23:07.410
那么这几刻

23:07.410 --> 23:09.010
就把5u3效率的提升

23:09.010 --> 23:09.890
给大家讲清楚

