WEBVTT

00:00.180 --> 00:02.580
上一个阶段学完了

00:02.580 --> 00:05.880
在入门阶段 咱们做了一个小的demo

00:05.880 --> 00:10.280
通过这个demo对五又三 有了一个特别是它的completion API

00:10.280 --> 00:12.180
有了一个初步的认识

00:12.180 --> 00:16.180
那么有了入门阶段之后 并不能就业

00:16.180 --> 00:19.180
为什么呢 因为五又三里面还有很多很多其他的东西

00:19.180 --> 00:21.680
我们一个个说吧

00:21.680 --> 00:25.180
首先说这个随着五又三的发布

00:25.180 --> 00:28.680
他带了一个新的小玩具 叫做Vit

00:28.680 --> 00:31.180
这是个法语 表示快的意思

00:31.180 --> 00:34.680
那么这个玩意可以帮助我们搭建一个五又三的工程

00:34.680 --> 00:36.180
实际上这个Vit

00:36.180 --> 00:38.680
它不仅仅可以搭建五又三的工程

00:38.680 --> 00:39.680
还可以搭建Rect

00:39.680 --> 00:43.180
还可以搭建一个普通的多叶应用程序 其实都可以

00:43.180 --> 00:44.680
它就是一个脚手架

00:44.680 --> 00:46.680
一个搭建工程的一个脚手架

00:46.680 --> 00:48.680
搭建什么工程都可以

00:48.680 --> 00:51.680
它的就是目前的Github地址在这

00:51.680 --> 00:53.180
大家可以去看一下

00:53.180 --> 00:55.180
不过好像没有什么中文

00:55.180 --> 00:57.680
你可以去看一下 我说一下

00:58.180 --> 00:59.680
然后这里就涉及到一个问题

00:59.680 --> 01:02.180
就是咱们以后在面试的时候

01:02.180 --> 01:06.680
对于这个小玩具很有可能会出面试题的

01:06.680 --> 01:10.180
因为尽管目前Vit还不是很成熟

01:10.180 --> 01:12.680
很有可能就在现阶段

01:12.680 --> 01:15.680
在真实的项目里边还不会上它

01:15.680 --> 01:19.680
但是它的理念是比较超前的

01:19.680 --> 01:22.680
它其实也不是它原创的理念了

01:22.680 --> 01:25.680
它很多地方也是吸取了一些其他技术的理念

01:25.680 --> 01:28.680
总之它的理念比较超前

01:28.680 --> 01:30.680
有可能这是未来

01:30.680 --> 01:34.180
特别是教授架工具的这种一个趋势

01:34.180 --> 01:35.680
所以说面试的时候

01:35.680 --> 01:37.680
很有可能会遇到这个Vit的面试题

01:37.680 --> 01:38.680
它会怎么问呢?

01:38.680 --> 01:40.180
那我压一个题吧

01:40.180 --> 01:42.180
它很有可能会这样子问你

01:42.180 --> 01:44.180
谈谈对Vit的理解

01:44.180 --> 01:46.680
你是怎么去看待这个工具的

01:46.680 --> 01:49.180
那么最好了对比一下同类型的

01:49.180 --> 01:52.180
像VPAC这样的工具来进行对比

01:52.180 --> 01:54.680
那么如果说你要应对Vit的面试题

01:54.680 --> 01:56.680
不管它怎么去猪蹄

01:56.680 --> 01:57.680
你要能够应对的话

01:57.680 --> 01:59.680
那么你就必须要对Vit的原理

01:59.680 --> 02:00.680
要有利益认知

02:00.680 --> 02:02.680
像我们在入门阶段

02:02.680 --> 02:04.680
是不是用Vit达监的工程

02:04.680 --> 02:05.680
做了一些效果对吧

02:05.680 --> 02:06.680
大家可以体会得到

02:06.680 --> 02:08.680
这个Vit的速度确实挺快的

02:08.680 --> 02:10.680
那它为什么会这样快

02:10.680 --> 02:12.680
那么到底是怎么回事

02:12.680 --> 02:13.680
我们来对比一下

02:13.680 --> 02:15.680
我们这里对比主要是对比VPAC

02:15.680 --> 02:18.680
那么我们看一下VPAC它是怎么做的

02:18.680 --> 02:20.680
它的做法就比较传统了

02:20.680 --> 02:22.680
因为它要考虑浏览期兼容的问题

02:22.680 --> 02:23.680
它怎么做的呢

02:23.680 --> 02:24.680
给它一个入口文件

02:24.680 --> 02:26.680
回顾一下以前学过的

02:26.680 --> 02:28.680
给它一个入口文件对吧

02:28.680 --> 02:30.680
然后它通过入口文件去找依赖

02:30.680 --> 02:32.680
所以找了很多的模块出来

02:32.680 --> 02:33.680
这些模块里边

02:33.680 --> 02:34.680
包含什么GS模块

02:34.680 --> 02:36.680
包含CSS模块还包含图片

02:36.680 --> 02:38.680
总之一大堆模块

02:38.680 --> 02:40.680
然后VPAC进打包对吧

02:40.680 --> 02:41.680
通过什么loader

02:41.680 --> 02:43.680
通过plugging等等等等

02:43.680 --> 02:44.680
进打包

02:44.680 --> 02:45.680
打包完了过

02:45.680 --> 02:46.680
是不是就变成了

02:46.680 --> 02:48.680
非常非常少量的

02:48.680 --> 02:49.680
打包之后的文件了

02:49.680 --> 02:51.680
对吧可能是一个可能是多个

02:51.680 --> 02:54.680
但是肯定不是原始的模块文件了

02:54.680 --> 02:55.680
没了意思吧

02:55.680 --> 02:56.680
这是VPAC的打包方式

02:56.680 --> 02:58.680
好打包完了过后

02:58.680 --> 02:59.680
在开发阶段

02:59.680 --> 03:01.680
它是不是还要启动一个开发服务器

03:01.680 --> 03:03.680
对吧我们需要配置一下

03:03.680 --> 03:05.680
然后启动一个开发服务器

03:05.680 --> 03:07.680
那么我们通过访问这个开发服务器

03:07.680 --> 03:09.680
它就会把打包结果给我们

03:09.680 --> 03:11.680
咱们来演示一下吧

03:11.680 --> 03:13.680
这里边我用view city

03:13.680 --> 03:16.680
写这个正确的图法叫view clean

03:16.680 --> 03:18.680
我尽量纠正一下自己吧

03:18.680 --> 03:21.680
我有点单纯的不是很标准

03:21.680 --> 03:23.680
那么这个通过view clean

03:23.680 --> 03:24.680
搭建的工程呢

03:24.680 --> 03:25.680
打开啊

03:25.680 --> 03:27.680
我们把它运行出来

03:27.680 --> 03:29.680
装设

03:29.680 --> 03:31.680
这也是view 3搭建的工程

03:31.680 --> 03:33.680
通过view clean搭建的

03:33.680 --> 03:34.680
你看是不是打包

03:34.680 --> 03:35.680
对不对

03:35.680 --> 03:36.680
找模块一带关系

03:36.680 --> 03:37.680
打包出来了

03:37.680 --> 03:38.680
启动了一个开发服务器

03:38.680 --> 03:39.680
然后呢

03:39.680 --> 03:41.680
通过这个地址去访问开发服务器

03:41.680 --> 03:44.680
那么我们来看一下就预见检查

03:44.680 --> 03:46.680
我们找到我们的网页

03:46.680 --> 03:47.680
网页里面呢

03:47.680 --> 03:48.680
是不是他访问的GS

03:48.680 --> 03:50.680
还是我们原来的GS吗

03:50.680 --> 03:51.680
并不是的

03:51.680 --> 03:52.680
对吧

03:52.680 --> 03:53.680
访问的是咋打包之后的GS

03:53.680 --> 03:55.680
我们可以通过网络通信啊

03:55.680 --> 03:57.680
看一下跟那个开发服务器之间

03:57.680 --> 03:58.680
它的通信结果

03:58.680 --> 03:59.680
刷新一下

03:59.680 --> 04:01.680
你看这个APP的GS

04:01.680 --> 04:02.680
你看是不是打包之后的

04:02.680 --> 04:04.680
创可

04:04.680 --> 04:05.680
这个玩意

04:05.680 --> 04:06.680
是不是打包之后的

04:06.680 --> 04:08.680
它生成了打包之后的结果

04:08.680 --> 04:10.680
然后访问开发服务器

04:10.680 --> 04:12.680
给我们打包之后的结果

04:12.680 --> 04:13.680
那么这样子就说

04:13.680 --> 04:15.680
一个问题是不是比较慢啊

04:15.680 --> 04:16.680
我们

04:16.680 --> 04:18.680
如果说模块比较多了

04:18.680 --> 04:19.680
特别是大项目里面

04:19.680 --> 04:20.680
模块超级超级多

04:20.680 --> 04:22.680
它包括一些一带的第三方裤啊

04:22.680 --> 04:24.680
第三方就依赖其他的裤

04:24.680 --> 04:26.680
那么一带关系非常复杂

04:26.680 --> 04:27.680
那么通过这样打包的话

04:27.680 --> 04:29.680
打包过程会非常的慢

04:29.680 --> 04:31.680
我之前给大家举个例子

04:31.680 --> 04:34.680
有些公司的一个大项目比较大了

04:34.680 --> 04:35.680
有些同学到公司里面

04:35.680 --> 04:36.680
首先第一件事呢

04:36.680 --> 04:37.680
先打包

04:37.680 --> 04:38.680
然后再开会

04:38.680 --> 04:39.680
开会完了

04:39.680 --> 04:40.680
打包结束

04:40.680 --> 04:41.680
打包过程非常慢

04:41.680 --> 04:42.680
而且呢

04:42.680 --> 04:43.680
它的热替换啊

04:43.680 --> 04:44.680
微拍是不是有热替换

04:44.680 --> 04:45.680
改动代码过后呢

04:45.680 --> 04:46.680
不用刷新页面

04:46.680 --> 04:48.680
替换你改动过后的代码

04:48.680 --> 04:50.680
但是它的热替换很麻烦啊

04:50.680 --> 04:52.680
因为你改动了一个模块之后呢

04:52.680 --> 04:54.680
其他跟这个模块相关的模块

04:54.680 --> 04:55.680
有依赖关系的模块

04:55.680 --> 04:56.680
说都要进行打包

04:56.680 --> 04:57.680
重新打包

04:57.680 --> 04:58.680
要打包

04:58.680 --> 04:59.680
本来只改动了一个很小的地方

04:59.680 --> 05:00.680
结果呢

05:00.680 --> 05:02.680
导致打包一大堆重新打包

05:02.680 --> 05:04.680
然后重新把改动过后的包呢

05:04.680 --> 05:05.680
重新发送到

05:05.680 --> 05:06.680
啊

05:06.680 --> 05:07.680
我们的浏览器里边去

05:07.680 --> 05:08.680
对吧

05:08.680 --> 05:09.680
它的热替换也比较慢

05:09.680 --> 05:11.680
这是微拍的原理

05:11.680 --> 05:12.680
那么V2

05:12.680 --> 05:13.680
为什么这么快呢

05:13.680 --> 05:14.680
我们来看一下V2的原理啊

05:14.680 --> 05:16.680
它的做法就完全不一样

05:16.680 --> 05:18.680
它是怎么做的呢

05:18.680 --> 05:20.680
我们来看一下下面的工程

05:20.680 --> 05:21.680
V2

05:21.680 --> 05:23.680
点击右键

05:23.680 --> 05:25.680
第一次呢它有个缓存的过程啊

05:25.680 --> 05:27.680
所以说稍微要慢一点

05:27.680 --> 05:29.680
运行

05:29.680 --> 05:30.680
其实速度也很快了

05:30.680 --> 05:31.680
你看

05:31.680 --> 05:32.680
就完成了

05:32.680 --> 05:34.680
因为V2它根本就没有打包

05:34.680 --> 05:36.680
它没有这个打包过程了

05:36.680 --> 05:37.680
是有点颠覆认知

05:37.680 --> 05:38.680
对吧

05:38.680 --> 05:39.680
所有的开发中

05:39.680 --> 05:40.680
所有的这个构建工具都有打包过程

05:40.680 --> 05:41.680
为什么它没有呢

05:41.680 --> 05:44.680
它是直接就启动了一个开发服务器

05:44.680 --> 05:46.680
启动服务器是不是很快

05:46.680 --> 05:47.680
啊

05:47.680 --> 05:49.680
如果说你学过了漏德街市

05:49.680 --> 05:50.680
漏德街市

05:50.680 --> 05:52.680
我们会自己启动一个服务器

05:52.680 --> 05:54.680
不管你是用Express

05:54.680 --> 05:55.680
还是用KOA

05:55.680 --> 05:56.680
啊

05:56.680 --> 05:57.680
其实V2啊

05:57.680 --> 05:58.680
是用KOA启动的一个服务器啊

05:58.680 --> 05:59.680
你可以看一下

05:59.680 --> 06:01.680
它里边是包含KOA的

06:01.680 --> 06:02.680
看没

06:02.680 --> 06:03.680
啊

06:03.680 --> 06:05.680
你们以后学到漏的阶段

06:05.680 --> 06:06.680
你们会学习到

06:06.680 --> 06:07.680
啊

06:07.680 --> 06:09.680
因此它就是启动一个服务器

06:09.680 --> 06:10.680
完了

06:10.680 --> 06:12.680
什么事情都没有做了

06:12.680 --> 06:13.680
啊

06:13.680 --> 06:14.680
重要的事情呢

06:14.680 --> 06:16.680
就是启动了一个服务器

06:16.680 --> 06:17.680
啊

06:17.680 --> 06:18.680
所以它速度非常非常快

06:18.680 --> 06:19.680
还没有打包

06:19.680 --> 06:20.680
因此呢

06:20.680 --> 06:21.680
我们说

06:21.680 --> 06:22.680
V2啊

06:22.680 --> 06:23.680
它跟你的项目大小

06:23.680 --> 06:24.680
没有任何关系

06:24.680 --> 06:26.680
哪怕你有1亿个模块

06:26.680 --> 06:27.680
它还是这么快

06:27.680 --> 06:28.680
因为它什么都没有做

06:28.680 --> 06:30.680
就是启动一个服务器

06:30.680 --> 06:32.680
然后接下来做什么事呢

06:32.680 --> 06:33.680
你就访问服务器

06:33.680 --> 06:34.680
它给你东西

06:34.680 --> 06:35.680
那么你怎么来访问服务器

06:35.680 --> 06:36.680
它怎么来给你东西呢

06:36.680 --> 06:37.680
比方说

06:37.680 --> 06:39.680
我们访问服务器的这个地址

06:39.680 --> 06:41.680
直接访问这个地址

06:41.680 --> 06:42.680
那么这个地址呢

06:42.680 --> 06:44.680
它就会把项目跟目录下面的

06:44.680 --> 06:45.680
index掉

06:45.680 --> 06:46.680
ATM页面给力

06:46.680 --> 06:47.680
完了

06:47.680 --> 06:49.680
把文件读出来

06:49.680 --> 06:50.680
东西给力

06:50.680 --> 06:51.680
响应过来

06:51.680 --> 06:52.680
就玩笑了

06:52.680 --> 06:53.680
所以说大家可以看到

06:53.680 --> 06:55.680
这不就是一个index页面吗

06:55.680 --> 06:56.680
对不对

06:56.680 --> 06:57.680
你看

06:57.680 --> 06:58.680
index页面不就是这个东西吗

06:58.680 --> 07:00.680
它里面给你注入了一些

07:00.680 --> 07:02.680
注入了一些GS

07:02.680 --> 07:03.680
这些我们不管

07:03.680 --> 07:04.680
我们看它的关键信息

07:04.680 --> 07:06.680
这不就是一个index页面

07:06.680 --> 07:08.680
然后这个页面上

07:09.680 --> 07:11.680
入口文件是啥呢

07:11.680 --> 07:12.680
你写的是啥就是啥

07:12.680 --> 07:13.680
所以说在位置啊

07:13.680 --> 07:14.680
这个项目里边

07:14.680 --> 07:15.680
你要改入口文件的名字

07:15.680 --> 07:17.680
比方说你不想用

07:17.680 --> 07:18.680
index的GS

07:18.680 --> 07:19.680
行不行

07:19.680 --> 07:20.680
可以啊

07:20.680 --> 07:21.680
你在页面上直接

07:21.680 --> 07:22.680
修改为index的GS

07:22.680 --> 07:23.680
不就完了吗

07:23.680 --> 07:24.680
就这么简单啊

07:24.680 --> 07:25.680
极其的简单

07:25.680 --> 07:27.680
你看不就变成index的GS了

07:27.680 --> 07:28.680
它就是把这个页面给力

07:28.680 --> 07:30.680
说速度快不快

07:30.680 --> 07:31.680
而且呢

07:31.680 --> 07:32.680
它没有打包

07:32.680 --> 07:33.680
你看到没有

07:33.680 --> 07:34.680
这个页面上引用的GS

07:34.680 --> 07:35.680
是靠一个什么东西

07:35.680 --> 07:37.680
靠一个type module

07:37.680 --> 07:38.680
那么这个东西是不是

07:38.680 --> 07:40.680
要以现代浏览器支持

07:40.680 --> 07:41.680
对吧

07:41.680 --> 07:42.680
新版本的浏览器

07:42.680 --> 07:43.680
它都支持

07:43.680 --> 07:45.680
ES module

07:45.680 --> 07:46.680
ES模块

07:46.680 --> 07:47.680
所以说你这样子呢

07:47.680 --> 07:48.680
导入这个GS

07:48.680 --> 07:50.680
它本身就是一个模块

07:50.680 --> 07:51.680
导入哪个路径呢

07:51.680 --> 07:52.680
导入就是这个路径

07:52.680 --> 07:53.680
所以说呢

07:53.680 --> 07:54.680
它这样子的浏览器

07:54.680 --> 07:55.680
是不是会自动的去发出

07:55.680 --> 07:57.680
发出请求

07:57.680 --> 07:58.680
自动的去发出请求

07:58.680 --> 08:00.680
你看这个错课啊

08:00.680 --> 08:01.680
请求谁

08:01.680 --> 08:03.680
请求我们的index的GS

08:03.680 --> 08:04.680
你看一下

08:04.680 --> 08:05.680
index的GS

08:05.680 --> 08:06.680
那么这个设计说

08:06.680 --> 08:07.680
又请求到了

08:07.680 --> 08:09.680
又请求到了这

08:09.680 --> 08:13.440
device2

08:13.440 --> 08:15.440
我们请求一个模块

08:15.440 --> 08:17.440
页面自动发出的请求

08:17.440 --> 08:18.440
然后呢

08:18.440 --> 08:19.440
这个device2呢

08:19.440 --> 08:20.440
它就把这个模块内容

08:20.440 --> 08:21.440
给力就完事了

08:21.440 --> 08:22.440
那么看一下

08:22.440 --> 08:23.440
index的GS啊

08:23.440 --> 08:24.440
你看这个模块

08:24.440 --> 08:25.440
这个内容不就是

08:25.440 --> 08:26.440
我们这里写的内容吗

08:26.440 --> 08:27.440
对不对

08:27.440 --> 08:29.440
看就这么简单

08:29.440 --> 08:30.440
当然呢

08:30.440 --> 08:31.440
你看这里边

08:31.440 --> 08:32.440
这里边又去请求了什么

08:32.440 --> 08:34.440
请求了这个app.5u

08:34.440 --> 08:35.440
看到没

08:35.440 --> 08:36.440
app.5u

08:36.440 --> 08:37.440
那么它这里呢

08:37.440 --> 08:38.440
又发出一个请求啊

08:38.440 --> 08:39.440
因为我们浏览器

08:39.440 --> 08:40.440
读到这个东西的时候

08:40.440 --> 08:42.440
浏览器看到这行代码

08:42.440 --> 08:43.440
所以又有请求发生

08:43.440 --> 08:44.440
于是呢

08:44.440 --> 08:45.440
它就去请求这个

08:45.440 --> 08:46.440
又把一个app.5u

08:46.440 --> 08:47.440
拿出来了

08:47.440 --> 08:49.440
你看它就这种模式

08:49.440 --> 08:50.440
当然呢

08:50.440 --> 08:51.440
这个地方呢

08:51.440 --> 08:52.440
你会发现呢

08:52.440 --> 08:53.440
它没有把语言

08:53.440 --> 08:54.440
它并不是把语言

08:54.440 --> 08:56.440
代码原封不动的给力

08:56.440 --> 08:58.440
发送给浏览器

08:58.440 --> 08:59.440
而是呢

08:59.440 --> 09:01.440
改动了一些东西

09:01.440 --> 09:02.440
比方说改动了一些路径

09:02.440 --> 09:03.440
比方说我们这里写的是什么

09:03.440 --> 09:05.440
写的是5u对吧

09:05.440 --> 09:07.440
它可以改成这个路径

09:07.440 --> 09:09.440
为什么可以改成这个路径呢

09:09.440 --> 09:11.440
它方便服务器来

09:11.440 --> 09:14.440
方便服务器来就是判断

09:14.440 --> 09:17.440
当服务器就是我们的开发服务器啊

09:17.440 --> 09:18.440
我们去请求开发服务器

09:18.440 --> 09:19.440
因为你看这儿啊

09:19.440 --> 09:21.440
写到model.5u的一些事

09:21.440 --> 09:22.440
浏览器是不是

09:22.440 --> 09:23.440
会发出这个请求

09:23.440 --> 09:25.440
到服务器对吧

09:25.440 --> 09:26.440
那么服务器一看

09:26.440 --> 09:27.440
你是以这个开头的

09:27.440 --> 09:28.440
于是呢

09:28.440 --> 09:29.440
我从哪里去找呢

09:29.440 --> 09:30.440
我就从漏的model.5u

09:30.440 --> 09:31.440
里面去找

09:31.440 --> 09:32.440
意思是说

09:32.440 --> 09:33.440
它是方便那个

09:33.440 --> 09:35.440
开发服务器来做这个事的

09:35.440 --> 09:36.440
包括呢

09:36.440 --> 09:37.440
我们这个

09:37.440 --> 09:38.440
相对路径啊

09:38.440 --> 09:39.440
它会把它改成绝对路径啊

09:39.440 --> 09:41.440
你看改成这个

09:41.440 --> 09:42.440
对不对

09:42.440 --> 09:43.440
把model.in CSS

09:43.440 --> 09:44.440
又改成这个

09:44.440 --> 09:45.440
总之它会做一些改动啊

09:45.440 --> 09:47.440
特别是对路径的

09:47.440 --> 09:48.440
做一些改动

09:48.440 --> 09:49.440
那么这些路径的改动

09:49.440 --> 09:51.440
是为了方便开发服务器

09:51.440 --> 09:52.440
来分析

09:52.440 --> 09:53.440
下一个模块

09:53.440 --> 09:55.440
你要找哪一个地方

09:55.440 --> 09:56.440
v-sir的基本原理

09:56.440 --> 09:57.440
就是这样子

09:57.440 --> 09:59.440
非常非常简单

09:59.440 --> 10:01.440
我们请求页面

10:01.440 --> 10:02.440
把页面给我

10:02.440 --> 10:03.440
页面中它自己

10:03.440 --> 10:04.440
本身引用了一个GS

10:04.440 --> 10:05.440
然后就请求这个GS

10:05.440 --> 10:07.440
整个过程没有任何打包

10:07.440 --> 10:08.440
那么只有

10:08.440 --> 10:10.440
它只是把某些路径

10:10.440 --> 10:11.440
给我们改了一下啊

10:11.440 --> 10:12.440
稍微的改了一下

10:12.440 --> 10:14.440
把某些关键的东西给我们改了一下

10:14.440 --> 10:15.440
那么这里呢

10:15.440 --> 10:16.440
它是有编译的

10:16.440 --> 10:17.440
也就是说

10:17.440 --> 10:18.440
我们请求一个模块

10:18.440 --> 10:19.440
到开发服务器

10:19.440 --> 10:21.440
开发服务器编印了过后呢

10:21.440 --> 10:23.440
把编印的结果

10:23.440 --> 10:24.440
给我们页面

10:24.440 --> 10:25.440
你看啊

10:25.440 --> 10:27.440
再看一下整个过程

10:27.440 --> 10:29.440
先请求页面

10:29.440 --> 10:31.440
页面中自动发出一个请求

10:31.440 --> 10:33.440
到index.gs

10:33.440 --> 10:34.440
这个GS

10:34.440 --> 10:35.440
是被编译过后的

10:35.440 --> 10:36.440
那么这个GS

10:36.440 --> 10:37.440
是不是又遗难了

10:37.440 --> 10:38.440
这个东西

10:38.440 --> 10:39.440
这个东西

10:39.440 --> 10:40.440
这个东西

10:40.440 --> 10:41.440
对不对

10:41.440 --> 10:42.440
于是呢

10:42.440 --> 10:43.440
它又发出了这么几个请求

10:43.440 --> 10:44.440
请求v6.gs

10:44.440 --> 10:47.440
请求app.v6

10:47.440 --> 10:48.440
请求什么

10:48.440 --> 10:49.440
index.sss

10:49.440 --> 10:50.440
对吧

10:50.440 --> 10:51.440
一发

10:51.440 --> 10:52.440
浏览器自动发出三个请求

10:52.440 --> 10:55.750
就这么个意思

10:55.750 --> 10:56.750
那么它对CSS

10:56.750 --> 10:57.750
怎么处理的呢

10:57.750 --> 10:58.750
CSS处理的方式

10:58.750 --> 10:59.750
就是把它变成一个字五串

10:59.750 --> 11:00.750
对吧

11:00.750 --> 11:01.750
把编印成一个字五串

11:01.750 --> 11:03.750
变成一个GS代码

11:03.750 --> 11:04.750
把我们的CSS那种

11:04.750 --> 11:05.750
变成一个字五串

11:05.750 --> 11:08.190
好

11:08.190 --> 11:09.190
然后对这个东西

11:09.190 --> 11:10.190
又怎么处理的呢

11:10.190 --> 11:11.190
对这个

11:11.190 --> 11:12.190
组件又怎么处理的呢

11:12.190 --> 11:13.190
你看我们请求

11:13.190 --> 11:14.190
app.v6

11:14.190 --> 11:15.190
它又把它变成

11:15.190 --> 11:16.190
变成了一个存介式

11:16.190 --> 11:17.190
对吧

11:17.190 --> 11:19.190
那么这个是谁的做功能呢

11:19.190 --> 11:20.190
它是这个

11:20.190 --> 11:21.190
这个依赖

11:21.190 --> 11:22.190
叫做

11:22.190 --> 11:23.190
v6.compiler

11:23.190 --> 11:24.190
sfc

11:24.190 --> 11:26.190
sfc什么意思

11:26.190 --> 11:29.190
single file component

11:29.190 --> 11:31.190
单文件组件

11:31.190 --> 11:32.190
单文件组件的编译器

11:33.190 --> 11:34.190
那么通过这个编译器呢

11:34.190 --> 11:36.190
在微程内不会调用啊

11:36.190 --> 11:37.190
通过这个编译器呢

11:37.190 --> 11:39.190
当我们请求这个东西的时候

11:39.190 --> 11:40.190
它会把这个玩意

11:40.190 --> 11:41.190
编译成什么

11:41.190 --> 11:42.190
编译成一个

11:42.190 --> 11:43.190
存缺的GS

11:43.190 --> 11:45.190
它并没有打包合并的过程

11:45.190 --> 11:46.190
它只有一个编译

11:46.190 --> 11:47.190
这样子速度是不是

11:47.190 --> 11:48.190
超级超级快

11:48.190 --> 11:49.190
你没有用到

11:49.190 --> 11:50.190
这个模块的时候

11:50.190 --> 11:51.190
它根本就不管它

11:51.190 --> 11:52.190
用到了过后呢

11:52.190 --> 11:53.190
你自然会发出请求

11:53.190 --> 11:54.190
到开发服务器

11:54.190 --> 11:55.190
开发服务器编译

11:55.190 --> 11:56.190
把编译结果给你

11:56.190 --> 11:58.190
说这个速度就很快了

11:58.190 --> 11:59.190
那么跟你有多少模块

11:59.190 --> 12:00.190
是不是没有什么关系

12:00.190 --> 12:01.190
对吧

12:01.190 --> 12:02.190
好

12:02.190 --> 12:03.190
然后呢

12:03.190 --> 12:04.190
那么我们可以看到

12:04.190 --> 12:05.190
这个组件里面的

12:05.190 --> 12:06.190
它还做了很多特殊处理

12:06.190 --> 12:07.190
比方说我们的模板

12:07.190 --> 12:08.190
模板呢

12:08.190 --> 12:09.190
它单独又发出了

12:09.190 --> 12:10.190
另外一个请求

12:10.190 --> 12:11.190
加上一个地址兰参数

12:11.190 --> 12:12.190
Type等于Templates

12:12.190 --> 12:13.190
又发出了这么一个请求

12:13.190 --> 12:14.190
这个请求呢

12:14.190 --> 12:15.190
就是模板编译的结果

12:15.190 --> 12:17.190
就是这一块

12:17.190 --> 12:19.190
这一块编译的结果

12:19.190 --> 12:21.190
它把编译编译成了GS

12:21.190 --> 12:22.190
把它编译成什么

12:22.190 --> 12:23.190
编译成了Render函数

12:23.190 --> 12:25.190
就大家知道吧

12:25.190 --> 12:27.190
无论是你使用UCD也好

12:27.190 --> 12:28.190
还是使用VCR也好

12:28.190 --> 12:29.190
它有一个东西

12:29.190 --> 12:30.190
叫做预编译

12:30.190 --> 12:34.840
我们知道模板

12:34.840 --> 12:35.840
是不是可以写三个地方

12:35.840 --> 12:37.840
写两个地方

12:37.840 --> 12:39.840
一个是写到页面上

12:39.840 --> 12:41.840
我们最开始学习

12:41.840 --> 12:42.840
无忧的时候

12:42.840 --> 12:44.840
模板是不是可以写到页面上

12:44.840 --> 12:46.840
写到这里边

12:46.840 --> 12:47.840
对吧

12:47.840 --> 12:48.840
这里边写模板

12:48.840 --> 12:49.840
然后呢

12:49.840 --> 12:50.840
还有可以写到什么

12:50.840 --> 12:51.840
还可以写到一个

12:51.840 --> 12:53.840
配置的字母串里边

12:53.840 --> 12:54.840
这么可以写到这

12:54.840 --> 12:55.840
Type等于Templates

12:55.840 --> 12:57.840
写到这写个字母串

12:57.840 --> 12:58.840
对吧

12:58.840 --> 13:00.840
那么在

13:00.840 --> 13:02.840
教授架工具里边呢

13:02.840 --> 13:04.840
你写到哪都不好使

13:04.840 --> 13:05.840
你只能写到这

13:05.840 --> 13:06.840
对不对

13:06.840 --> 13:07.840
那么写到这过后呢

13:07.840 --> 13:08.840
如果说

13:08.840 --> 13:10.840
它把这个地方

13:10.840 --> 13:12.840
给你编译成了这个玩意儿

13:12.840 --> 13:13.840
合不合适呢

13:13.840 --> 13:14.840
不合适

13:14.840 --> 13:15.840
为什么呢

13:15.840 --> 13:16.840
你在运行的时候

13:16.840 --> 13:18.840
是不是还是得把它编译成Render函数

13:18.840 --> 13:19.840
那么这样子呢

13:19.840 --> 13:20.840
它就必须要在

13:20.840 --> 13:22.840
打包结果里边

13:22.840 --> 13:25.840
加上编译的功能

13:25.840 --> 13:29.160
那么另外一种做法就是

13:29.160 --> 13:32.530
我把模板写到这

13:32.530 --> 13:33.530
然后呢

13:33.530 --> 13:35.530
一生成打包结果

13:35.530 --> 13:36.530
我还没有运行

13:36.530 --> 13:37.530
对吧

13:37.530 --> 13:38.530
先打包再运行吧

13:38.530 --> 13:40.530
我生成打包结果之后

13:40.530 --> 13:42.530
它就已经把这个东西

13:42.530 --> 13:43.530
变成了Render函数了

13:43.530 --> 13:44.530
你看着

13:44.530 --> 13:48.040
是不是把我们的模板

13:48.040 --> 13:49.040
变成了一个Render函数

13:49.040 --> 13:50.040
你看

13:50.040 --> 13:51.040
这是我们的脚本

13:51.040 --> 13:52.040
脚本里边一个对象

13:52.040 --> 13:53.040
主建对象吧

13:53.040 --> 13:54.040
主建对象里边

13:54.040 --> 13:55.040
一个Render函数给它复制了

13:55.040 --> 13:57.040
它把它变成Render函数了

13:57.040 --> 13:58.040
那么这样子一来

13:58.040 --> 14:00.040
在最多的打包结果里边

14:00.040 --> 14:01.040
是不是就不需要

14:01.040 --> 14:02.040
我们的编译代码了

14:02.040 --> 14:03.040
那么这样子

14:03.040 --> 14:05.040
可以减少打包体积

14:05.040 --> 14:07.040
这个其实不是5又3

14:07.040 --> 14:08.040
5又3的功能

14:08.040 --> 14:09.040
5又2就用

14:09.040 --> 14:10.040
我顺便说一下

14:10.040 --> 14:11.040
不知道讨论人们知不知道

14:11.040 --> 14:13.040
有预编译

14:13.040 --> 14:14.040
所以说呢

14:14.040 --> 14:15.040
我们的模板

14:15.040 --> 14:16.040
它也编一层介绍的

14:16.040 --> 14:17.040
总之让我们

14:17.040 --> 14:18.040
抓大放小

14:18.040 --> 14:19.040
这些细节

14:19.040 --> 14:20.040
让我们不谈

14:20.040 --> 14:22.040
整个V程的作用就是

14:22.040 --> 14:24.040
整个实现的实用就是

14:24.040 --> 14:25.040
我直接启动一个服务器

14:25.040 --> 14:26.040
啥都不用管

14:26.040 --> 14:27.040
不管你有几千个模块

14:27.040 --> 14:28.040
先启动服务器再说

14:28.040 --> 14:30.040
根据你不同的请求

14:30.040 --> 14:32.040
然后给力不同的东西

14:32.040 --> 14:33.040
那么请求谁发出的

14:33.040 --> 14:34.040
页面发出的

14:34.040 --> 14:35.040
页面为什么会发出

14:35.040 --> 14:36.040
因为页面

14:36.040 --> 14:38.040
它必须要支持ES module

14:38.040 --> 14:40.040
它就会自动发出请求

14:40.040 --> 14:42.040
它充分利用了现代浏览器

14:42.040 --> 14:44.040
那么有人还说

14:44.040 --> 14:45.040
我用位置开发

14:45.040 --> 14:47.040
不用现代浏览器行不行呢

14:47.040 --> 14:50.040
能不能用过去很久的浏览器

14:50.040 --> 14:51.040
Ie7 Ie8

14:51.040 --> 14:53.040
那肯定是不行的

14:53.040 --> 14:55.040
它必须要浏览器支持

14:55.040 --> 14:56.040
支持什么呢

14:56.040 --> 14:59.040
支持那个ES module

15:00.040 --> 15:01.040
那是不是问题又来了

15:01.040 --> 15:03.040
解农性

15:03.040 --> 15:05.040
那说我们用位置开发的程序

15:05.040 --> 15:06.040
是不是只能给

15:06.040 --> 15:08.040
现代浏览器使用的

15:08.040 --> 15:09.040
也不是这样说的

15:09.040 --> 15:13.040
我们这里说的全是开发阶段

15:13.040 --> 15:15.040
你想一想

15:15.040 --> 15:18.040
生产环境下还有这个玩意吗

15:18.040 --> 15:20.040
所以一定没有这个玩意了

15:20.040 --> 15:23.040
DevServer什么开发服务器对吧

15:23.040 --> 15:25.040
它解决的问题是什么

15:25.040 --> 15:28.040
解决的问题是我们开发阶段的时候

15:28.040 --> 15:30.040
速度太慢

15:30.040 --> 15:31.040
特别是项目大胆过后

15:31.040 --> 15:33.040
打包助销率极低

15:33.040 --> 15:35.040
它干脆不打包了

15:35.040 --> 15:36.040
充分利用现代浏览器

15:36.040 --> 15:37.040
因为开发阶段

15:37.040 --> 15:39.040
既然你是程序而

15:39.040 --> 15:41.040
你不可能说你用个Ie8来做开发

15:41.040 --> 15:42.040
那不是扯淡吗

15:42.040 --> 15:44.040
那肯定是搞笑的

15:44.040 --> 15:45.040
就很幽默

15:45.040 --> 15:47.040
我们肯定是用现代浏览器做开发

15:47.040 --> 15:50.040
这个点肯定不成问题的

15:50.040 --> 15:53.040
支持ES module肯定不成问题

15:53.040 --> 15:55.040
而且由于是开发阶段

15:55.040 --> 15:57.040
尽管说我们ES module

15:57.040 --> 15:58.040
它有个什么问题呢

15:58.040 --> 16:01.040
它会导致出现非常多的请求

16:01.040 --> 16:03.040
是不是有大堆请求

16:03.040 --> 16:05.040
这个一代这个它又会去请求

16:05.040 --> 16:06.040
这个一代这个又会去请求

16:06.040 --> 16:09.040
它出现了一大堆的端起拔刀的请求

16:09.040 --> 16:10.040
请求数量是不是变多了

16:10.040 --> 16:13.040
它是不是开发阶段效率变低的呢

16:13.040 --> 16:15.040
也不能这样子说

16:15.040 --> 16:16.040
虽然说请求多了

16:16.040 --> 16:18.040
确实会慢一点

16:18.040 --> 16:19.040
但是你要不要忘记了

16:19.040 --> 16:21.040
开发阶段是不是在本地

16:21.040 --> 16:22.040
你的服务器

16:22.040 --> 16:24.040
开发服务器是不是本地

16:24.040 --> 16:26.040
服务器在本地的话

16:26.040 --> 16:27.040
速度是非常快的

16:27.040 --> 16:28.040
尽管请求数量很多

16:28.040 --> 16:31.040
但速度仍然是非常快

16:31.040 --> 16:33.040
至少比这个玩意

16:33.040 --> 16:35.040
比这个打包过程要快的很多

16:35.040 --> 16:37.040
你之前做入门的时候

16:37.040 --> 16:40.040
大家应该能够体会到

16:40.040 --> 16:43.040
V程基本上就是这么个情况

16:43.040 --> 16:45.040
能理解了吧

16:45.040 --> 16:47.040
好 那么我们再来看

16:47.040 --> 16:49.040
谈谈对V程的理解

16:49.040 --> 16:50.040
最好会比一下VPype

16:50.040 --> 16:53.040
那么下面这段话

16:53.040 --> 16:54.040
我不需要给大家练一遍了吧

16:54.040 --> 16:55.040
不需要练了吧

16:55.040 --> 16:58.040
你们可以自己去看一下

16:58.040 --> 17:00.040
至于看一下

17:00.040 --> 17:02.040
模块越多 项目越复杂

17:02.040 --> 17:04.040
V程在开发阶段

17:04.040 --> 17:06.040
优势就越明显

17:06.040 --> 17:07.040
那有些东西说

17:07.040 --> 17:10.040
如果说我要在生产环境怎么办呢

17:10.040 --> 17:11.040
不能永远在开发阶段

17:11.040 --> 17:12.040
开发完了

17:12.040 --> 17:13.040
我要部署到生产环境

17:13.040 --> 17:15.040
那么部署到生产环境

17:15.040 --> 17:17.040
有两种做法

17:17.040 --> 17:19.040
第一种你直接就在这里

17:19.040 --> 17:20.040
因为这是SRC目的嘛

17:20.040 --> 17:22.040
就在这里安穿一个VPype

17:22.040 --> 17:25.040
我们手动用VPype来打包

17:25.040 --> 17:26.040
打包到生产环境

17:26.040 --> 17:27.040
可以吗 可以啊

17:27.040 --> 17:28.040
没问题

17:28.040 --> 17:29.040
还有一种做法

17:29.040 --> 17:31.040
就是V程里边自带了

17:31.040 --> 17:32.040
一个打包工具

17:32.040 --> 17:33.040
叫做Rollup

17:33.040 --> 17:37.600
叫做Rollup

17:37.600 --> 17:39.600
这是一个非常传统的

17:39.600 --> 17:41.600
打包工具

17:41.600 --> 17:42.600
所以有时候没结束

17:42.600 --> 17:43.600
没关系啊

17:43.600 --> 17:45.600
这东西都成绩很简单的

17:45.600 --> 17:46.600
它就是一个传统的打包工具

17:46.600 --> 17:47.600
那么通过它

17:47.600 --> 17:48.600
就把它变成一个

17:48.600 --> 17:49.600
非常非常传统

17:49.600 --> 17:50.600
就可以类似于

17:50.600 --> 17:52.600
VPype那种模式

17:53.600 --> 17:55.600
因为毕竟是部署到生产环境

17:55.600 --> 17:56.600
这种次数很少

17:56.600 --> 17:57.600
对吧

17:57.600 --> 17:59.600
平时结束最多的就是开发环境

17:59.600 --> 18:01.600
打包的时候我们运行

18:02.600 --> 18:04.600
那么实际上运行的是哪个命令呢

18:04.600 --> 18:05.600
运行的是这个命令

18:07.600 --> 18:12.940
那么通过它来进行生产环境的打包

18:12.940 --> 18:13.940
OK

18:13.940 --> 18:14.940
生产环境打包完成了

18:14.940 --> 18:15.940
那么生产环境打包过后

18:15.940 --> 18:16.940
就跟之前差不多了

18:16.940 --> 18:17.940
是不是合并过的

18:17.940 --> 18:18.940
压缩过后的

18:18.940 --> 18:19.940
还包含缺些K

18:19.940 --> 18:20.940
对吧 都有

18:20.940 --> 18:22.940
那么这就是跟以前一样

18:22.940 --> 18:24.940
只是在开发模式下面

18:24.940 --> 18:25.940
出现了区别

18:25.940 --> 18:27.940
记住是这么回事

18:27.940 --> 18:29.940
那么当然在开发模式下面

18:29.940 --> 18:32.940
我们要对DevServer进行配置

18:32.940 --> 18:33.940
那么这些事情怎么做呢

18:33.940 --> 18:35.940
你可以查看它的官方文档

18:35.940 --> 18:36.940
比方说

18:38.940 --> 18:39.940
看一下官方文档吧

18:41.940 --> 18:43.940
其实你这种东西怎么查

18:43.940 --> 18:44.940
我告诉大家怎么来查

18:44.940 --> 18:45.940
全是英文对吧

18:45.940 --> 18:47.940
那么比方说我要配置

18:47.940 --> 18:48.940
开发阶段的代理

18:48.940 --> 18:49.940
是不是很常见的一个功能

18:49.940 --> 18:50.940
那怎么来配置呢

18:51.940 --> 18:53.940
康硕加F来收一下吧

18:53.940 --> 18:54.940
Proxy

18:55.940 --> 18:57.940
你看是不是有DevServerProxy

18:57.940 --> 18:58.940
就这样子去查文档

18:58.940 --> 19:00.940
就说你非常明确你的目标

19:00.940 --> 19:01.940
是啥的话

19:01.940 --> 19:02.940
你收写关键字

19:03.940 --> 19:04.940
看一下它怎么配置的

19:04.940 --> 19:05.940
它就告诉你在

19:05.940 --> 19:06.940
visconfig.js

19:06.940 --> 19:07.940
也在这里呢

19:07.940 --> 19:09.940
去建立一个配置文件

19:10.940 --> 19:12.940
visconfig.js

19:12.940 --> 19:13.940
然后呢这里边

19:14.940 --> 19:16.940
导出一个配置

19:16.940 --> 19:17.940
其中的Proxy是什么

19:17.940 --> 19:19.940
这个东西知道了

19:19.940 --> 19:20.940
以前是不是配置过啊

19:20.940 --> 19:21.940
配置方式是一样的

19:22.940 --> 19:23.940
好那么我问一下

19:23.940 --> 19:24.940
大家一个问题啊

19:25.940 --> 19:26.940
看大家是不是对这几课

19:26.940 --> 19:28.940
有所理解

19:28.940 --> 19:32.760
在微扯的这些代码里边

19:32.760 --> 19:33.760
能不能使用

19:34.760 --> 19:35.760
common.js

19:38.460 --> 19:39.460
你觉得能不能使用common.js

19:41.460 --> 19:42.460
我有这种方式

19:42.460 --> 19:43.460
可不可以

19:43.460 --> 19:46.090
可不可以呢

19:46.090 --> 19:48.400
你想啊

19:48.400 --> 19:49.400
肯定是不行的啊

19:49.400 --> 19:50.400
肯定是不行的

19:50.400 --> 19:51.400
你看一下吧

19:52.400 --> 19:53.400
我也没启动啊

19:53.400 --> 19:55.400
npm.dev

19:57.400 --> 19:58.400
说说我以前没有演示过

19:58.400 --> 19:59.400
但是你知道

19:59.400 --> 20:00.400
它原理过后了

20:00.400 --> 20:01.400
你自然就明白

20:01.400 --> 20:02.400
肯定是不行的啊

20:02.400 --> 20:03.400
css

20:03.400 --> 20:04.400
css出不来的

20:05.400 --> 20:06.400
为什么他告诉你

20:06.400 --> 20:07.400
request.dev

20:07.400 --> 20:08.400
为什么出不来

20:08.400 --> 20:09.400
为什么他不能使用common.js

20:09.400 --> 20:10.400
为啥呢

20:10.400 --> 20:12.400
是因为这个时候呢

20:12.400 --> 20:13.400
这个代码是会发出

20:13.400 --> 20:14.400
到浏览器的

20:14.400 --> 20:16.400
浏览器是不是不认识这个呀

20:17.400 --> 20:18.400
对不对浏览器

20:18.400 --> 20:19.400
它能够认识es module

20:19.400 --> 20:21.400
它不认识这个玩意啊

20:21.400 --> 20:22.400
没啥意思吧

20:22.400 --> 20:23.400
说浏览器拿到这个

20:23.400 --> 20:24.400
代码一看就懵了

20:25.400 --> 20:26.400
这是啥啊

20:26.400 --> 20:27.400
浏览器一看

20:27.400 --> 20:28.400
不认识了

20:28.400 --> 20:29.400
它就可以爆出了

20:29.400 --> 20:30.400
request.dev

20:30.400 --> 20:31.400
request.hansu

20:31.400 --> 20:32.400
没有定义

20:32.400 --> 20:33.400
是吧

20:33.400 --> 20:34.400
遇到这么一个问题

20:34.400 --> 20:35.400
所以说这里边

20:35.400 --> 20:36.400
是不能用common.js的

20:36.400 --> 20:37.400
那以前那个

20:37.400 --> 20:38.400
vipack

20:38.400 --> 20:39.400
就是vucd

20:39.400 --> 20:40.400
vucd

20:40.400 --> 20:42.400
它为什么能够用呢

20:42.400 --> 20:44.400
因为它不是在浏览器里面

20:44.400 --> 20:45.400
执行的

20:45.400 --> 20:46.400
它是要打包的

20:46.400 --> 20:47.400
先打包

20:47.400 --> 20:48.400
打包完了过后

20:48.400 --> 20:49.400
它就没有这些东西了

20:49.400 --> 20:50.400
变成了一个立即执行函数了

20:50.400 --> 20:51.400
所以说

20:51.400 --> 20:52.400
这些es module

20:52.400 --> 20:53.400
还有common.js

20:53.400 --> 20:54.400
都不存在了

20:54.400 --> 20:56.400
所以说浏览器都能认识

20:56.400 --> 20:57.400
那意思吧

20:57.400 --> 20:58.400
尽管你的

20:58.400 --> 20:59.400
以前在里边

20:59.400 --> 21:00.400
无论是你用common.js

21:00.400 --> 21:01.400
还是用es module

21:01.400 --> 21:02.400
它最终会打包的

21:02.400 --> 21:03.400
但是这里没有打包

21:03.400 --> 21:05.400
是直接发送给浏览器的

21:05.400 --> 21:07.400
所以说它这里有区别啊

21:07.400 --> 21:08.400
好 这就是

21:08.400 --> 21:09.400
viz这一块的原理啊

21:09.400 --> 21:11.400
应该是讲得非常清楚了啊

