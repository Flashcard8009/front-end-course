WEBVTT

00:00.180 --> 00:03.180
好了 各位同学 我们从这节课开始

00:03.180 --> 00:06.580
就要用我们之前学习过的所有的网络知识

00:06.580 --> 00:09.780
来做一个完整的小项目

00:09.780 --> 00:11.980
这个项目就是聊天机器人

00:11.980 --> 00:16.180
这个聊天机器人 同学们可以通过效果访问地址

00:16.180 --> 00:19.580
这里面有一个地址 通过这个地址可以看到这个效果

00:19.580 --> 00:23.580
不过我在讲课的时候这个地址还不存在的

00:23.580 --> 00:26.380
所以说我在商课的时候会用另外一个地址

00:26.380 --> 00:29.980
这个地址你们不要用 你们用的地址是这个

00:30.180 --> 00:32.580
我可以说清楚 明天套车又来问

00:32.580 --> 00:34.980
那么效果是一样的 进去过后

00:34.980 --> 00:37.980
它说你为登录 请先登录 点击确定

00:37.980 --> 00:41.980
就跑到登录界面 然后这边我们写个账号

00:41.980 --> 00:43.980
如果说你没有账号的话 点击这里注册

00:43.980 --> 00:47.980
这里可以注册 有账号的话就点击这里登录

00:47.980 --> 00:50.980
不要说 1 2 3 1 2 3登录

00:51.980 --> 00:53.980
这就是它首先会有一些显示

00:53.980 --> 00:55.980
当前的一些聊天的历史记录

00:55.980 --> 00:58.980
那么这里可以发送一个聊天消息

00:58.980 --> 01:03.980
比如说今天成都天气如何

01:04.980 --> 01:06.980
看一下它怎么回答吧

01:07.980 --> 01:10.980
它还可以 是吧 还可以

01:10.980 --> 01:12.980
这就是一个聊天机权

01:12.980 --> 01:14.980
然后点这里可以退出登录

01:14.980 --> 01:17.980
点击过后它就退出登录了

01:17.980 --> 01:19.980
好 就这么一个效果

01:19.980 --> 01:22.980
这个效果 一节课做不完

01:22.980 --> 01:24.980
我们得分好几节课来讲

01:24.980 --> 01:26.980
一节课 每节课做 每节课该做的事

01:27.980 --> 01:30.980
这节课我们先不涉及到任何的界面

01:30.980 --> 01:33.980
我们先写一些函数 写什么函数呢

01:33.980 --> 01:36.980
就是把我们之前在Postman里边

01:36.980 --> 01:39.980
不是有很多的网络接口吗

01:39.980 --> 01:42.980
通过把这些网络接口 每一个把它写成一个函数

01:42.980 --> 01:44.980
那么写成函数之后

01:44.980 --> 01:46.980
将来要用的时候就比较方便了

01:46.980 --> 01:49.980
我一调函数就可以实现网络通信

01:49.980 --> 01:52.980
因为这个效果里边你不管你怎么做

01:52.980 --> 01:54.980
你要做什么样的界面

01:54.980 --> 01:56.980
你要做成用不用文本夸

01:56.980 --> 01:58.980
按钮什么样子都无所谓的

01:58.980 --> 02:00.980
其实最重要的是

02:00.980 --> 02:02.980
要有网络通信

02:02.980 --> 02:04.980
你没有网络通信 这些都是瞎吻

02:04.980 --> 02:06.980
对吧 所以说我们这节课

02:06.980 --> 02:08.980
既然一定要用到网络通信

02:08.980 --> 02:10.980
那么我们就把这些每一个接口

02:10.980 --> 02:12.980
全部给它封装了

02:12.980 --> 02:13.980
那么在封装的时候

02:13.980 --> 02:16.980
你可以根据我们之前写的Postman

02:16.980 --> 02:17.980
来进行封装

02:17.980 --> 02:20.980
因为这个网页就是按照接口文档

02:20.980 --> 02:21.980
做出来的

02:21.980 --> 02:23.980
当然也可以不用Postman

02:23.980 --> 02:25.980
比如以后到了公司

02:25.980 --> 02:27.980
先弄个Postman再去封装网络接口

02:27.980 --> 02:28.980
是不是太麻烦了

02:28.980 --> 02:30.980
这里完全可以不用Postman

02:30.980 --> 02:31.980
直接看接口文档

02:31.980 --> 02:33.980
根据接口文档里边的写的内容

02:33.980 --> 02:35.980
直接去封装接口

02:35.980 --> 02:36.980
就可以了

02:36.980 --> 02:38.980
所以我们这一步做的就是

02:38.980 --> 02:41.980
接口的封装

02:41.980 --> 02:43.980
就是把每一个接口写成一个函数

02:44.980 --> 02:46.980
那么这里我们就在这里新建一个

02:46.980 --> 02:47.980
我把这个复制一下

02:47.980 --> 02:48.980
这里有静态页面

02:48.980 --> 02:52.540
看一下这个静态页面吧

02:55.540 --> 02:56.540
这是我们的静态页面

02:56.540 --> 02:59.540
然后还有几个Logging

02:59.540 --> 03:00.540
它都没有功能的

03:00.540 --> 03:01.540
都是静态的页面

03:01.540 --> 03:02.540
它都没有功能的

03:02.540 --> 03:03.540
点的是没用的

03:03.540 --> 03:06.540
然后Rate都是注册

03:06.540 --> 03:08.540
这是静态页面

03:08.540 --> 03:09.540
静态页面提供给你的

03:09.540 --> 03:11.540
然后这里CSS也写好了

03:11.540 --> 03:12.540
你不用管

03:12.540 --> 03:14.540
有兴趣的同学也可以完全

03:14.540 --> 03:16.540
重新自己写一下

03:16.540 --> 03:17.540
这里边有图片

03:17.540 --> 03:19.540
你可以自己弄一下吧

03:19.540 --> 03:20.540
当然没必要

03:20.540 --> 03:23.540
你直接用我的就可以了

03:23.540 --> 03:25.540
然后这个静态页面

03:25.540 --> 03:27.540
我这边就新copy一下

03:27.540 --> 03:30.540
然后重新拎个名字叫客棠代码

03:30.540 --> 03:34.180
里面就根据这个静态页面去做

03:34.180 --> 03:36.180
你可以新建一个根木炉

03:36.180 --> 03:37.180
把静态页面的内容

03:37.180 --> 03:38.180
copy到根木炉里边去

03:38.180 --> 03:40.180
然后用VSCode

03:40.180 --> 03:41.180
打开根木炉

03:41.180 --> 03:43.180
然后跟着我一步一步去做

03:43.180 --> 03:45.180
客棠代码里边

03:45.180 --> 03:46.180
我们这里新建一个

03:46.180 --> 03:48.180
JS文件夹

03:48.180 --> 03:50.180
然后在这里边写上

03:50.180 --> 03:51.180
这么一个JS

03:51.180 --> 03:54.180
我们把它取名为API.JS

03:54.180 --> 03:56.180
那么这个API

03:56.180 --> 03:58.180
这个API这个东西有不同的

03:59.180 --> 04:00.180
语境下边

04:00.180 --> 04:02.180
它有不同的含义

04:02.180 --> 04:04.180
有的时候我们说API

04:04.180 --> 04:05.180
它指的是

04:05.180 --> 04:07.180
应用程序编程接口

04:07.180 --> 04:09.180
就是提供一些对象

04:09.180 --> 04:11.180
提供一些方法

04:11.180 --> 04:12.180
这些东西

04:12.180 --> 04:14.180
将我们在网络环境里边说

04:14.180 --> 04:16.180
API又指的是接口通信

04:16.180 --> 04:19.180
跟网络之间的接口通信

04:19.180 --> 04:22.180
所以说不同的反应有不同的含义

04:22.180 --> 04:24.180
那么这里我们就写上

04:24.180 --> 04:25.180
封装一些方法

04:25.180 --> 04:27.180
那么这里边我们只去关注

04:27.180 --> 04:30.180
用户接口和聊天接口即可

04:30.180 --> 04:32.180
用户接口、聊天接口

04:32.180 --> 04:34.180
我们每一个就封上几个函数

04:34.180 --> 04:35.180
比如说用户接口里边

04:35.180 --> 04:36.180
不有注册吗

04:36.180 --> 04:37.180
我们就写一个函数

04:37.180 --> 04:38.180
reg

04:38.180 --> 04:39.180
那注册的时候

04:39.180 --> 04:41.180
你不得给我提供

04:41.180 --> 04:42.180
什么

04:42.180 --> 04:44.180
那个账号、里程和密码

04:44.180 --> 04:45.180
对吧

04:45.180 --> 04:46.180
那么你给我提供一个

04:46.180 --> 04:47.180
用户对象吧

04:48.180 --> 04:49.180
提供一个对象

04:49.180 --> 04:50.180
那么对象里边包含了

04:50.180 --> 04:51.180
这三个东西

04:51.180 --> 04:54.180
那我就帮你去完成注册

04:54.180 --> 04:56.180
这就是这个函数的注册

04:56.180 --> 04:58.180
然后登录

04:58.180 --> 04:59.180
登录的时候

04:59.180 --> 05:01.180
你不得给我提供一个

05:01.180 --> 05:02.180
账号密码吗

05:02.180 --> 05:03.180
对吧

05:03.180 --> 05:04.180
我们把它叫做

05:05.180 --> 05:06.180
一个对象

05:06.180 --> 05:07.180
那么我去完成登录

05:07.180 --> 05:08.180
就是每一个地方

05:08.180 --> 05:10.180
每个接口写成一个函数

05:10.180 --> 05:12.180
所以后面就把这些函数完成

05:12.180 --> 05:13.180
有点机械

05:13.180 --> 05:15.180
有一点体力活的意思

05:16.180 --> 05:17.180
验证账号

05:17.180 --> 05:18.180
这个是

05:20.180 --> 05:23.550
你给我传一个locking id

05:23.550 --> 05:24.550
就是账号

05:24.550 --> 05:25.550
我看一下这个账号

05:25.550 --> 05:26.550
是不是存在的

05:27.550 --> 05:28.550
这是验证账号

05:28.550 --> 05:30.550
当前登录的用户信息

05:30.550 --> 05:33.550
那么我们先把函数签名写好

05:33.550 --> 05:35.550
就是profile

05:35.550 --> 05:37.550
你不需要给我传任何参数

05:37.550 --> 05:38.550
我直接调用这个

05:38.550 --> 05:39.550
你只要一调用这个函数

05:39.550 --> 05:41.550
我就会返回给你一个

05:41.550 --> 05:43.550
当前登录的用户信息

05:43.550 --> 05:44.550
然后还有什么

05:44.550 --> 05:46.550
发送聊天消息

05:52.550 --> 05:54.550
发送一个聊天消息

05:54.550 --> 05:55.550
聊天消息里面有什么

05:55.550 --> 05:56.550
聊天消息里面

05:56.550 --> 05:58.550
好像就只有一个内容

05:58.550 --> 05:59.550
就给我传个内容就行了

05:59.550 --> 06:01.550
其他什么都不用传递

06:02.550 --> 06:03.550
然后还有什么

06:03.550 --> 06:05.550
还有就是获取聊天记录

06:05.550 --> 06:06.550
这个不需要你

06:06.550 --> 06:07.550
给我传递任何东西

06:07.550 --> 06:08.550
get the history

06:13.550 --> 06:14.550
就行了

06:14.550 --> 06:15.550
我们一共就这节课

06:15.550 --> 06:17.550
就写这么六个函数

06:17.550 --> 06:18.550
把它完成就OK了

06:19.550 --> 06:20.550
当然同学们也可以

06:20.550 --> 06:21.550
现在可以暂停视频

06:21.550 --> 06:22.550
你天不管

06:22.550 --> 06:23.550
不管我我现在把

06:23.550 --> 06:24.550
函数签名给你写好了

06:24.550 --> 06:25.550
你自己写一下

06:25.550 --> 06:26.550
试一下

06:26.550 --> 06:27.550
我看你写成什么样子

06:27.550 --> 06:28.550
没关系

06:28.550 --> 06:29.550
你自己尝试一下

06:29.550 --> 06:30.550
然后再来听

06:30.550 --> 06:32.550
你会发现受益

06:32.550 --> 06:33.550
会破多

06:34.550 --> 06:36.550
好那么接下来我们开始写

06:36.550 --> 06:37.550
注册

06:37.550 --> 06:38.550
那么这个地方

06:38.550 --> 06:39.550
他就要提交一个

06:39.550 --> 06:40.550
网络请求

06:40.550 --> 06:41.550
对不对

06:41.550 --> 06:42.550
表扬注册

06:42.550 --> 06:43.550
我们看一下

06:43.550 --> 06:44.550
这个是Pose请求

06:44.550 --> 06:45.550
那么我们这里

06:45.550 --> 06:46.550
直接写一个Fetch

06:46.550 --> 06:47.550
请求什么地址呢

06:47.550 --> 06:49.550
都是我们之前说过的

06:49.550 --> 06:50.550
你们那边要请求

06:50.550 --> 06:51.550
这个地址

06:51.550 --> 06:55.550
A-T-B-S-R-D-E-E-D-U

06:55.550 --> 06:57.550
然后后面就是路径

06:57.550 --> 06:59.550
就这个地址路径

07:00.550 --> 07:01.550
但是我这边

07:01.550 --> 07:02.550
就不能请求这个地址了

07:02.550 --> 07:03.550
因为现在的地址

07:03.550 --> 07:05.550
还不存在

07:05.550 --> 07:07.550
我这边要请求这个地址

07:07.550 --> 07:09.550
localhost701

07:09.550 --> 07:10.550
你会发现

07:10.550 --> 07:12.550
在不同的环境里边

07:12.550 --> 07:13.550
就是现在我们还没有部署

07:13.550 --> 07:15.550
它这个前边这一坨

07:15.550 --> 07:16.550
是不是有点区别

07:16.550 --> 07:18.550
有点不太一样

07:18.550 --> 07:19.550
对不对

07:19.550 --> 07:20.550
是不是有这么一个问题

07:20.550 --> 07:21.550
那么像这个地方

07:21.550 --> 07:23.550
将来有可能会变动

07:23.550 --> 07:24.550
而且你可以想象的到

07:24.550 --> 07:25.550
其他的函数里面

07:25.550 --> 07:27.550
是不是都会出现这个东西

07:27.550 --> 07:28.550
那么其实

07:28.550 --> 07:29.550
这个玩意我们可以把

07:29.550 --> 07:30.550
提取出去

07:30.550 --> 07:31.550
怎么提取出去

07:31.550 --> 07:32.550
我们给他写上一个

07:32.550 --> 07:37.550
BaseURIO

07:37.550 --> 07:39.550
就把这个前面这一坨

07:39.550 --> 07:40.550
提取出去

07:40.550 --> 07:41.550
提成一个制服串

07:41.550 --> 07:42.550
对吧

07:42.550 --> 07:43.550
可以吧

07:43.550 --> 07:44.550
这个没问题吧

07:44.550 --> 07:45.550
然后我们把制服串

07:45.550 --> 07:46.550
拼接到这

07:47.550 --> 07:49.550
都可以拼接到这

07:49.550 --> 07:50.550
对吧

07:50.550 --> 07:51.550
那么这样子

07:51.550 --> 07:52.550
将来要改的话

07:52.550 --> 07:53.550
是不是就直接改

07:53.550 --> 07:54.550
这个辩量就可以了

07:54.550 --> 07:55.550
对不对

07:55.550 --> 07:56.550
这样子很方便一些

07:56.550 --> 07:58.550
那么这里顺便给他说一下

07:58.550 --> 07:59.550
像这种地方

07:59.550 --> 08:00.550
全部大显

08:00.550 --> 08:03.550
其实也是一个命名规范吧

08:03.550 --> 08:04.550
一个命名习惯

08:04.550 --> 08:06.550
就是我们把一些长量

08:06.550 --> 08:08.550
通过辩量名字全部大写

08:08.550 --> 08:09.550
这样子

08:09.550 --> 08:10.550
我们将来看到这个名字

08:10.550 --> 08:12.550
就知道这是一个长量了

08:12.550 --> 08:14.550
这是一种

08:14.550 --> 08:15.550
就是全局的

08:15.550 --> 08:16.550
长量的

08:16.550 --> 08:18.550
它不太会变化的

08:18.550 --> 08:19.550
通用的

08:19.550 --> 08:21.550
那么我们把全部大写

08:21.550 --> 08:23.550
这是一种命名规范

08:23.550 --> 08:24.550
也不是说

08:24.550 --> 08:25.550
所有的长量都要这样子命名

08:25.550 --> 08:26.550
比如有的时候

08:26.550 --> 08:28.550
我们做一个临时辩量的话

08:29.550 --> 08:30.550
就是像这种

08:30.550 --> 08:31.550
全局的

08:31.550 --> 08:32.550
到处要使用的

08:32.550 --> 08:34.550
我们通过使用一个名字

08:34.550 --> 08:35.550
规范

08:35.550 --> 08:36.550
那可以很明显的看出

08:36.550 --> 08:37.550
它到底说什么意思

08:38.550 --> 08:39.550
那么这是请求这个地址

08:39.550 --> 08:40.550
什么请求呢

08:40.550 --> 08:41.550
它是一个Pose请求

08:41.550 --> 08:42.550
所以说第二个参数

08:42.550 --> 08:44.550
我们要用MessorPose

08:45.550 --> 08:47.550
Pose请求要发送请求

08:47.550 --> 08:48.550
是不是要请求一个body

08:48.550 --> 08:49.550
那么这里时候

08:49.550 --> 08:51.550
我们要设置Headers

08:51.550 --> 08:53.550
把这个ContentType

08:53.550 --> 08:55.550
设置为IPK请节省

08:55.550 --> 08:56.550
然后

08:56.550 --> 08:57.550
同时把body

08:57.550 --> 08:58.550
设置为什么呢

08:58.550 --> 08:59.550
设置把这个对象

08:59.550 --> 09:00.550
解析成什么

09:00.550 --> 09:01.550
解析成

09:02.550 --> 09:03.550
接胜格式

09:03.550 --> 09:04.550
对吧

09:05.550 --> 09:06.550
那么这样子

09:06.550 --> 09:07.550
请求是不是可以发出去了

09:08.550 --> 09:09.550
发出请求过后

09:09.550 --> 09:10.550
这个函数要做什么呢

09:10.550 --> 09:11.550
这个函数要返回

09:11.550 --> 09:13.550
服务器的想应结果

09:14.550 --> 09:15.550
是吧

09:15.550 --> 09:16.550
服务器的想应结果

09:16.550 --> 09:17.550
要返回

09:17.550 --> 09:18.550
对吧

09:18.550 --> 09:19.550
那么这怎么返回呢

09:19.550 --> 09:20.550
我们这里就可以使用

09:20.550 --> 09:21.550
之前写的

09:22.550 --> 09:23.550
然后

09:23.550 --> 09:25.550
解析接省

09:25.550 --> 09:26.550
解析想应体

09:26.550 --> 09:27.550
那么这样子

09:27.550 --> 09:28.550
想应体解析完成之后

09:28.550 --> 09:30.550
等待它解析完成

09:30.550 --> 09:31.550
解析完成之后

09:31.550 --> 09:32.550
是不是就可以拿到

09:32.550 --> 09:33.550
这个想应结果了

09:33.550 --> 09:34.550
对吧

09:34.550 --> 09:35.550
我们Return

09:35.550 --> 09:36.550
直接把这一坨全部返回

09:36.550 --> 09:38.550
等待它的解析完成

09:38.550 --> 09:39.550
解析完成过后

09:39.550 --> 09:40.550
把服务器的想应结果

09:40.550 --> 09:41.550
直接返回

09:41.550 --> 09:43.550
那么这就完成了一个

09:43.550 --> 09:44.550
Rig函数

09:44.550 --> 09:45.550
当然那你这里使用了

09:45.550 --> 09:46.550
而为者说明了这个

09:46.550 --> 09:47.550
Rig函数

09:47.550 --> 09:48.550
它也是异布的

09:48.550 --> 09:49.550
对吧

09:49.550 --> 09:50.550
它是需要一段时间完成的

09:50.550 --> 09:51.550
我跟大家说

09:51.550 --> 09:53.550
你们写到个代码的时候

09:53.550 --> 09:54.550
你就把网络通信

09:54.550 --> 09:56.550
想象成一年才能完成

09:56.550 --> 09:57.550
一年之后

09:57.550 --> 09:59.550
这个函数才能完成

09:59.550 --> 10:01.550
要不然那么长时间

10:01.550 --> 10:02.550
那么写完了之后

10:02.550 --> 10:04.550
我怎么来测试呢

10:04.550 --> 10:05.550
首先大家要知道

10:05.550 --> 10:06.550
废棋这个函数

10:06.550 --> 10:07.550
在漏的环境里面

10:07.550 --> 10:08.550
是不能运行的

10:08.550 --> 10:09.550
漏的环境里面

10:09.550 --> 10:10.550
是没有这个函数的

10:10.550 --> 10:11.550
这是浏览器

10:11.550 --> 10:12.550
环境里面才有

10:12.550 --> 10:13.550
所以说你必须要在

10:13.550 --> 10:14.550
浏览器端进行测试

10:14.550 --> 10:16.550
那你随便找一个页面吧

10:16.550 --> 10:18.550
你或者是自己新建一个

10:18.550 --> 10:19.550
测试页面也可以

10:19.550 --> 10:21.550
都无所谓的

10:21.550 --> 10:22.550
你就随便找一个吧

10:22.550 --> 10:23.550
比方说找一个Logging页面

10:23.550 --> 10:24.550
然后在页面上去

10:24.550 --> 10:26.550
引入这个介绍

10:26.550 --> 10:27.550
这个介绍是所有页面

10:27.550 --> 10:29.550
都必须要引入的

10:29.550 --> 10:31.550
引入这个介绍

10:31.550 --> 10:32.550
API介绍

10:32.550 --> 10:34.550
好,我们再试一下吧

10:34.550 --> 10:37.550
我们刚才不是写了一个

10:39.550 --> 10:41.550
Rig函数吧,对不对

10:41.550 --> 10:42.550
让它传入一个对象

10:42.550 --> 10:44.550
对象里面写三个属性

10:44.550 --> 10:47.550
Logging ID写上一个什么呢

10:47.550 --> 10:48.550
ABC

10:48.550 --> 10:50.550
Logging password

10:50.550 --> 10:52.550
密码了123123

10:52.550 --> 10:54.550
Nickname

10:54.550 --> 10:56.550
你称了写

10:59.550 --> 11:00.550
我们来试一下

11:00.550 --> 11:01.550
能不能拿到浮规的响应结果

11:01.550 --> 11:02.550
因为这个函数

11:02.550 --> 11:03.550
它本身是异部的

11:03.550 --> 11:04.550
对吧,我们把参数

11:04.550 --> 11:05.550
传进去了之后

11:05.550 --> 11:07.550
我要等待它完成

11:07.550 --> 11:08.550
然后会拿到一个浮规的

11:08.550 --> 11:09.550
响应结果

11:09.550 --> 11:10.550
我这里就把这个

11:10.550 --> 11:12.550
响应结果输出

11:13.550 --> 11:14.550
回车

11:14.550 --> 11:16.550
它告诉我账号已存在

11:16.550 --> 11:17.550
这个ABC的账号已存在

11:17.550 --> 11:18.550
说明什么

11:18.550 --> 11:19.550
说明网络通信是

11:19.550 --> 11:20.550
正常运行的

11:20.550 --> 11:21.550
对吧,你可以通过

11:21.550 --> 11:22.550
这个network

11:22.550 --> 11:24.550
看一下这个阿迦克斯请求

11:24.550 --> 11:25.550
你发出去的

11:25.550 --> 11:26.550
发出去的是什么

11:26.550 --> 11:27.550
payload的

11:27.550 --> 11:29.550
发出去的消息

11:29.550 --> 11:30.550
然后你可以收到

11:30.550 --> 11:31.550
浮规的响应

11:31.550 --> 11:33.550
响应是response

11:33.550 --> 11:34.550
浮规的响应

11:34.550 --> 11:35.550
你可以在这里

11:35.550 --> 11:36.550
更加油耗的格式

11:36.550 --> 11:38.550
可以看到浮规的响应结果

11:38.550 --> 11:40.550
说明这个接口

11:40.550 --> 11:42.550
这个函数封装的是没问题的

11:42.550 --> 11:43.550
对吧

11:44.550 --> 11:45.550
然后我们这里

11:45.550 --> 11:47.550
其实也有很多种写法了

11:47.550 --> 11:48.550
不是说

11:48.550 --> 11:49.550
这个代码其实是很灵活的

11:49.550 --> 11:50.550
你完全可以

11:50.550 --> 11:52.550
用你学过的知识

11:52.550 --> 11:55.550
来用不同的习惯

11:55.550 --> 11:56.550
来书写这个代码

11:56.550 --> 11:57.550
比方说有些朋友看

11:57.550 --> 11:58.550
这样写也挺好的

11:58.550 --> 12:00.550
就是我不想写这个回调了

12:00.550 --> 12:01.550
回调看起来丑陋的

12:01.550 --> 12:02.550
那我怎么写呢

12:02.550 --> 12:05.550
我先来而为得到这个

12:05.550 --> 12:07.550
你浮规去的响应

12:07.550 --> 12:08.550
这个时候

12:08.550 --> 12:09.550
还没有拿到响应体

12:09.550 --> 12:10.550
对吧,只是响应头

12:10.550 --> 12:12.550
全部过来了

12:12.550 --> 12:13.550
好,接下来呢

12:13.550 --> 12:14.550
我再来解析

12:14.550 --> 12:15.550
用接审

12:15.550 --> 12:16.550
是吧,是不是

12:16.550 --> 12:17.550
一样的道理吗

12:17.550 --> 12:19.550
一切到这个回调里边

12:19.550 --> 12:20.550
起到这儿

12:20.550 --> 12:21.550
而为得到这儿

12:21.550 --> 12:22.550
是不是一样的

12:22.550 --> 12:23.550
然后对它进行解析

12:23.550 --> 12:24.550
这个解析的过程

12:24.550 --> 12:25.550
是不是也是异步的

12:25.550 --> 12:28.550
因为它收获这个响应体

12:28.550 --> 12:29.550
是不是也需要一段时间

12:29.550 --> 12:31.550
对吧,先拿到响应头

12:31.550 --> 12:32.550
再拿到响应体

12:32.550 --> 12:34.550
好,我等它解析完成之后

12:34.550 --> 12:35.550
那么把这个解析解过返回

12:35.550 --> 12:37.550
这样子它就没有回调了

12:37.550 --> 12:39.550
这样子写也挺好

12:39.550 --> 12:41.550
都可以

12:41.550 --> 12:42.550
懂了意思吧

12:42.550 --> 12:43.550
都可以的

12:43.550 --> 12:44.550
根据你自己的书写习惯

12:44.550 --> 12:47.550
那么这个注册这个函数

12:47.550 --> 12:48.550
就算书写完成

12:48.550 --> 12:51.550
说到这儿

12:51.550 --> 12:52.550
我倒是想起一个事

12:52.550 --> 12:54.550
順便给大家说一下吧

12:54.550 --> 12:55.550
想起这么一个事

12:55.550 --> 12:57.550
这件事可以让你们

12:57.550 --> 12:58.550
更加清楚的看到

12:58.550 --> 13:00.550
ATDP协议的请求响应

13:00.550 --> 13:03.550
你在VSCode里面安装一个插件

13:03.550 --> 13:04.550
叫做

13:04.550 --> 13:08.060
ATDP

13:08.060 --> 13:09.060
啥的

13:09.060 --> 13:11.060
叫啥来着

13:11.060 --> 13:17.530
找一找

13:17.530 --> 13:18.530
在这里

13:18.530 --> 13:20.530
Rest Client

13:20.530 --> 13:22.530
Rest是啥呢

13:22.530 --> 13:23.530
我们之后再说吧

13:23.530 --> 13:24.530
Rest Client

13:24.530 --> 13:26.530
把这个安装上

13:26.530 --> 13:27.530
安装上之后

13:27.530 --> 13:29.530
你可以在VSCode里面

13:29.530 --> 13:31.530
就类似于Postman

13:31.530 --> 13:32.530
那样子

13:32.530 --> 13:34.530
给你发送请求和得到响应

13:34.530 --> 13:36.530
你可以更加清楚的看到

13:36.530 --> 13:38.530
请求和响应的原式格式

13:38.530 --> 13:39.530
你随便找一个地方

13:39.530 --> 13:41.530
你写上这么一个文件

13:41.530 --> 13:42.530
比方说Test

13:42.530 --> 13:44.530
后维名为就位ATDP

13:44.530 --> 13:46.530
你在这里面写啥呢

13:46.530 --> 13:48.530
非常简单

13:48.530 --> 13:49.530
你就写他的

13:49.530 --> 13:51.530
请求原式格式就可以了

13:51.530 --> 13:52.530
有些地方

13:52.530 --> 13:53.530
它可以省略

13:53.530 --> 13:54.530
它会自动帮你补充

13:54.530 --> 13:55.530
比方说

13:55.530 --> 13:56.530
我举个例子

13:56.530 --> 13:57.530
你们在Postman

13:57.530 --> 13:59.530
你边不是有个什么

13:59.530 --> 14:00.530
热门电影列表吗

14:00.530 --> 14:01.530
对吧

14:01.530 --> 14:02.530
我就写这个

14:02.530 --> 14:03.530
比方说我就写这个

14:03.530 --> 14:06.670
我就写

14:06.670 --> 14:07.670
Gate请求

14:07.670 --> 14:09.670
请求什么地址呢

14:09.670 --> 14:10.670
请求

14:10.670 --> 14:12.670
你们那边要换一个地址

14:12.670 --> 14:13.670
我这边使用的是

14:13.670 --> 14:15.670
Local Host 701

14:15.670 --> 14:16.670
你们那边要换

14:16.670 --> 14:20.670
你才是darty.edu.com

14:20.670 --> 14:21.670
好

14:21.670 --> 14:22.670
请求这个地址

14:22.670 --> 14:23.670
你看上面是个按钮

14:23.670 --> 14:24.670
叫Synth Request

14:24.670 --> 14:25.670
那么这样子

14:25.670 --> 14:27.670
就可以把请求发过去

14:27.670 --> 14:28.670
那你可以看到

14:28.670 --> 14:29.670
服务器的响应结果

14:29.670 --> 14:30.670
看到没

14:30.670 --> 14:31.670
这就服务器响应

14:31.670 --> 14:32.670
响应行

14:32.670 --> 14:33.670
响应头

14:33.670 --> 14:35.670
这是响应的消息体

14:35.670 --> 14:36.670
一个节省格式

14:36.670 --> 14:37.670
对吧

14:37.670 --> 14:38.670
这就是一个完整的

14:38.670 --> 14:40.670
响应的文本

14:40.670 --> 14:42.670
这是你发出去的请求

14:42.670 --> 14:43.670
请求的时候

14:43.670 --> 14:44.670
你还可以带一些头部

14:44.670 --> 14:45.670
比方说

14:45.670 --> 14:49.670
A1 B2的都可以发出去

14:49.670 --> 14:51.670
这个头部的服务器

14:51.670 --> 14:53.670
是不会甩你的

14:53.670 --> 14:54.670
可以发动Pose请求

14:54.670 --> 14:56.670
比方说我们要登录

14:56.670 --> 14:57.670
登录的话

14:57.670 --> 14:58.670
好像是这个结果

14:58.670 --> 15:01.670
user login登录

15:01.670 --> 15:02.670
登录的时候

15:02.670 --> 15:03.670
我们是不是要

15:03.670 --> 15:05.670
请求头好像没有什么

15:05.670 --> 15:06.670
再回车

15:06.670 --> 15:09.670
这个地方前请求T

15:09.670 --> 15:10.670
请求T里边是不是要写

15:10.670 --> 15:12.670
login id

15:12.670 --> 15:13.670
等于

15:15.670 --> 15:16.670
你们那边要换

15:16.670 --> 15:18.670
就抄着老师带

15:18.670 --> 15:20.670
老师这边有这个用户

15:20.670 --> 15:22.670
你们那边不一定有

15:23.670 --> 15:24.670
发动请求

15:25.670 --> 15:26.670
你看

15:28.670 --> 15:29.670
他说什么

15:29.670 --> 15:34.260
那么发动请求发过去

15:34.260 --> 15:35.260
发过去之后

15:35.260 --> 15:36.260
这是服务器的响应

15:36.260 --> 15:37.260
服务器告诉我

15:37.260 --> 15:38.260
login id

15:38.260 --> 15:39.260
要填写的

15:39.260 --> 15:40.260
login id没有填写

15:40.260 --> 15:41.260
这是怎么回事呢

15:41.260 --> 15:42.260
这是因为我没有

15:42.260 --> 15:43.260
少写个请求头

15:43.260 --> 15:44.260
确实还少写个请求头

15:44.260 --> 15:45.260
叫content type

15:45.260 --> 15:46.260
叫IPTK型

15:46.260 --> 15:47.260
结设

15:48.260 --> 15:49.260
后边这个配不用写

15:49.260 --> 15:50.260
好那么这样子

15:50.260 --> 15:51.260
你看这就是个

15:51.260 --> 15:52.260
原式的请求格式

15:52.260 --> 15:53.260
这是请求行

15:53.260 --> 15:54.260
这是请求头

15:54.260 --> 15:55.260
当然请求行

15:55.260 --> 15:56.260
你可以把它写完整一点

15:56.260 --> 15:58.260
还有AKGP 1.1

15:58.260 --> 16:00.260
把它写完整一点

16:00.260 --> 16:01.260
但是你不写的话

16:01.260 --> 16:02.260
它会自动帮你补充

16:02.260 --> 16:03.260
这样子的话

16:03.260 --> 16:04.260
更加有利于你们的学习

16:04.260 --> 16:05.260
你看

16:05.260 --> 16:06.260
响应结果里边

16:06.260 --> 16:07.260
一个Oscarization

16:07.260 --> 16:08.260
响应头

16:08.260 --> 16:09.260
你看

16:09.260 --> 16:10.260
是不是把这个令牌

16:10.260 --> 16:11.260
给带过来了

16:11.260 --> 16:12.260
然后告诉你

16:12.260 --> 16:13.260
登录成功了

16:13.260 --> 16:14.260
这登录的这些东西

16:14.260 --> 16:16.260
这就是原式的响应格式

16:16.260 --> 16:17.260
其实网络特别简单

16:17.260 --> 16:18.260
就是你发过过去

16:18.260 --> 16:19.260
它可以发过回来

16:19.260 --> 16:20.260
就是这样子

16:21.260 --> 16:22.260
那么我们可以去

16:22.260 --> 16:23.260
试一下这个插件

16:23.260 --> 16:24.260
还是挺好的

16:25.260 --> 16:26.260
那么其实这里的

16:26.260 --> 16:27.260
无非就是用阿迪克斯

16:27.260 --> 16:28.260
用我们代码去发生

16:28.260 --> 16:29.260
这个请求

16:29.260 --> 16:30.260
拿到响应结果

16:30.260 --> 16:31.260
那么所谓的

16:31.260 --> 16:33.260
说这个玩意到底是啥

16:33.260 --> 16:36.580
那么在这里就很好解释了

16:36.580 --> 16:37.580
把这个东西

16:37.580 --> 16:38.580
服务器要传输

16:38.580 --> 16:39.580
它不是一起传输过来的

16:39.580 --> 16:41.580
它是一条流将流水

16:41.580 --> 16:43.580
就像水一样

16:43.580 --> 16:44.580
慢慢流过来的

16:44.580 --> 16:45.580
当它把这个东西

16:45.580 --> 16:46.580
这个网络传输

16:46.580 --> 16:47.580
它实际上是

16:47.580 --> 16:49.580
从上到下一直流过来的

16:49.580 --> 16:50.580
把这个东西

16:50.580 --> 16:51.580
把传输完了之后

16:51.580 --> 16:52.580
它就会

16:52.580 --> 16:53.580
就这个

16:53.580 --> 16:55.580
这一步就会完成

16:55.580 --> 16:56.580
这个Promise就会完成

16:56.580 --> 16:57.580
就达到这个

16:57.580 --> 16:58.580
所以在这里呢

16:58.580 --> 16:59.580
你可以获取响应头

16:59.580 --> 17:01.580
可以状态码都可以获取

17:01.580 --> 17:02.580
但是你现在获取不到

17:02.580 --> 17:03.580
响应体

17:03.580 --> 17:04.580
因为响应体还没有传输完成

17:04.580 --> 17:06.580
那么这个地方在等待什么呢

17:06.580 --> 17:08.580
等待响应体传输完成

17:08.580 --> 17:09.580
一边传输

17:09.580 --> 17:11.580
一边解析为结成格式

17:11.580 --> 17:12.580
看到没

17:12.580 --> 17:13.580
就这么个意思

17:13.580 --> 17:14.580
那么这个解析完了

17:14.580 --> 17:15.580
传输完了

17:15.580 --> 17:16.580
那么会

17:16.580 --> 17:17.580
那么这个Promise就完成了

17:17.580 --> 17:18.580
它反回的是什么呢

17:18.580 --> 17:19.580
得到的就是

17:19.580 --> 17:20.580
这个东西

17:20.580 --> 17:21.580
它的对象

17:22.580 --> 17:23.580
懂了意思吧

17:23.580 --> 17:26.580
那么这就是注册函书

17:26.580 --> 17:27.580
那么接下来呢

17:27.580 --> 17:29.580
是Login登录

17:29.580 --> 17:31.580
登录函书呢

17:31.580 --> 17:32.580
怎么来登录呢

17:32.580 --> 17:33.580
还是一样

17:33.580 --> 17:34.580
我们再复制一下吧

17:34.580 --> 17:35.580
再稍微改一改就行了

17:35.580 --> 17:37.580
其实这里好多都是体力活的

17:37.580 --> 17:38.580
请求什么地址

17:38.580 --> 17:39.580
请求Login

17:39.580 --> 17:40.580
这个地址

17:44.590 --> 17:45.590
不好意思

17:45.590 --> 17:47.590
经常就要稍稍电话

17:47.590 --> 17:48.590
那么现在登录的话

17:48.590 --> 17:50.590
这里其他都没什么变化

17:50.590 --> 17:51.590
后说请求

17:51.590 --> 17:52.590
请求这个地址

17:52.590 --> 17:54.590
然后都没什么变化

17:54.590 --> 17:55.590
然后就把这个地方换一下

17:55.590 --> 17:57.590
换一下变两名字

17:57.590 --> 17:58.590
好

17:58.590 --> 17:59.590
登录完成之后

17:59.590 --> 18:00.590
是不是这里呢

18:00.590 --> 18:01.590
就可以拿到服务系的

18:01.590 --> 18:03.590
响应结果对吧

18:03.590 --> 18:04.590
响应结果呢

18:04.590 --> 18:06.590
就是我们用Results吧

18:06.590 --> 18:07.590
拿到服务系响应结果

18:07.590 --> 18:08.590
那又可以说

18:08.590 --> 18:10.590
这里为什么要改呢

18:10.590 --> 18:12.590
这里就涉及到这个话题了

18:12.590 --> 18:13.590
就登录成功之后

18:13.590 --> 18:15.590
我们是不是有一些事情要做

18:15.590 --> 18:17.590
什么事情要做

18:17.590 --> 18:19.590
是不是再把这个令牌

18:19.590 --> 18:21.590
保存到保存起来

18:21.590 --> 18:22.590
你还记得吗

18:22.590 --> 18:24.590
当时我们用Pose Man的时候

18:24.590 --> 18:25.590
登录成功了

18:25.590 --> 18:27.590
是不是服务系那个令牌

18:27.590 --> 18:28.590
我们当时用一个计识本

18:28.590 --> 18:29.590
保存下来了对吧

18:29.590 --> 18:30.590
因为一会要用的

18:30.590 --> 18:32.590
有些结果要把个令牌带过去的

18:32.590 --> 18:34.590
那么在我们代码里面

18:34.590 --> 18:36.590
你不能在这里开个计识本

18:36.590 --> 18:37.590
你怎么办

18:37.590 --> 18:38.590
你不能说

18:38.590 --> 18:39.590
用户你在登录的时候

18:39.590 --> 18:40.590
你能不能自己拿个计识本

18:40.590 --> 18:42.590
我把这个信息给你提示出来

18:42.590 --> 18:43.590
给弹框弹出来

18:43.590 --> 18:44.590
你把它保存一下

18:44.590 --> 18:46.590
这不合适吧对吧

18:46.590 --> 18:47.590
所以说我们这里呢

18:47.590 --> 18:48.590
要把它手

18:48.590 --> 18:50.590
用戴码的形式把它保存起来

18:50.590 --> 18:51.590
所以说我这里呢

18:51.590 --> 18:52.590
就没有直接返回来

18:52.590 --> 18:53.590
我还要做一些额外的事情

18:53.590 --> 18:54.590
做什么事呢

18:54.590 --> 18:58.540
就是将

18:58.540 --> 19:00.540
响应头中的

19:00.540 --> 19:02.540
token就令牌

19:02.540 --> 19:03.540
保存起来

19:03.540 --> 19:05.540
保存到哪呢

19:05.540 --> 19:06.540
保存到哪

19:06.540 --> 19:08.540
保存到

19:08.540 --> 19:10.540
local storage里边

19:10.540 --> 19:12.540
local storage

19:12.540 --> 19:14.540
保存到这

19:14.540 --> 19:15.540
那么就把它保存起来

19:15.540 --> 19:16.540
怎么保存呢

19:16.540 --> 19:17.540
就非常简单的

19:17.540 --> 19:19.540
首先你要拿到这个

19:19.540 --> 19:20.540
怎么拿到

19:20.540 --> 19:21.540
还记得吗

19:21.540 --> 19:23.540
wisp headers

19:23.540 --> 19:25.540
是不是响应对象

19:25.540 --> 19:27.540
一开始响应头传输完成之后

19:27.540 --> 19:28.540
它这个地方就已经

19:28.540 --> 19:29.540
可以拿到响应头了

19:29.540 --> 19:31.540
这里空了get

19:31.540 --> 19:32.540
拿什么

19:32.540 --> 19:34.540
拿OSREization

19:34.540 --> 19:36.540
是不是可以拿到这个token

19:36.540 --> 19:37.540
当然前提条件

19:37.540 --> 19:38.540
你得登录

19:38.540 --> 19:39.540
登录成功

19:39.540 --> 19:40.540
你如果登录失败了

19:40.540 --> 19:42.540
比方说扣的必须是0才行

19:42.540 --> 19:43.540
对吧

19:43.540 --> 19:44.540
登录成功了

19:44.540 --> 19:45.540
如果登录失败了

19:45.540 --> 19:46.540
那还有这个令牌吗

19:46.540 --> 19:47.540
那肯定是没有令牌了

19:47.540 --> 19:49.540
所以说你这里主要判断一下

19:49.540 --> 19:50.540
result

19:50.540 --> 19:51.540
code

19:51.540 --> 19:52.540
应该等于什么

19:52.540 --> 19:53.540
等于0

19:53.540 --> 19:55.540
这个时候表示什么

19:55.540 --> 19:58.920
表示登录成功

19:58.920 --> 19:59.920
这个时候

19:59.920 --> 20:01.920
你才需要把它保存起来

20:01.920 --> 20:09.360
说哪里写错了

20:09.360 --> 20:11.360
这个时候啊

20:11.360 --> 20:12.360
我看哪里写错了

20:12.360 --> 20:14.360
说哪里少个什么

20:16.360 --> 20:17.360
前边

20:17.360 --> 20:18.360
一步函数

20:18.360 --> 20:20.360
我说怎么回事

20:20.360 --> 20:21.360
要保存

20:21.360 --> 20:22.360
我现在没写完

20:22.360 --> 20:23.360
那如果说你登录失败的话

20:24.360 --> 20:25.360
那么后面就直接返回了

20:25.360 --> 20:26.360
对吧

20:26.360 --> 20:27.360
把响应结果直接返回

20:28.360 --> 20:29.360
只有登录成功之后

20:29.360 --> 20:31.360
的时候我要额外的去做一件事

20:31.360 --> 20:33.360
就是把这个令牌保存起来

20:34.360 --> 20:36.360
拿到这个令牌之后

20:36.360 --> 20:37.360
那么我怎么保存呢

20:37.360 --> 20:38.360
就用local storage吧

20:38.360 --> 20:40.360
local storage

20:40.360 --> 20:41.360
set item

20:42.360 --> 20:44.360
这是那个建筑队吗

20:44.360 --> 20:45.360
建

20:45.360 --> 20:46.360
你自己随便取一个

20:46.360 --> 20:47.360
名字可以就叫token

20:47.360 --> 20:48.360
然后呢

20:48.360 --> 20:50.360
把这个变量token里面的制服串

20:50.360 --> 20:51.360
存到这个变量里面去了

20:51.360 --> 20:52.360
把保存到token里面去

20:53.360 --> 20:54.360
当然这个名字呢

20:54.360 --> 20:56.360
你也可以写一个

20:56.360 --> 20:58.360
长量叫做token

20:58.360 --> 20:59.360
t

21:00.360 --> 21:01.360
名字就要token

21:02.360 --> 21:04.360
这样子的方便你以后更改

21:04.360 --> 21:05.360
像这种一般不会更改的

21:05.360 --> 21:07.360
就是全局这种配置的

21:08.360 --> 21:09.360
写死的

21:09.360 --> 21:10.360
以后要更改的话

21:10.360 --> 21:11.360
只能从代码里面更改的

21:11.360 --> 21:12.360
像这种东西

21:12.360 --> 21:14.360
我们就可以用全大写

21:15.360 --> 21:16.360
把这写进去

21:17.360 --> 21:19.670
好了来试一下吧

21:19.670 --> 21:20.670
这样子

21:20.670 --> 21:22.670
看到底能不能登录成功

21:22.670 --> 21:24.670
好到浏览器里面去

21:24.670 --> 21:26.670
试一下这个locking方法

21:26.670 --> 21:27.670
传入什么呢

21:27.670 --> 21:28.670
传入一个对象

21:28.670 --> 21:29.670
帐号

21:29.670 --> 21:30.670
先来一个

21:31.670 --> 21:32.670
错误的吧

21:32.670 --> 21:34.670
写随便写一个错误的

21:34.670 --> 21:35.670
locking password

21:35.670 --> 21:37.670
随便写一个错误的

21:37.670 --> 21:38.670
然后呢

21:38.670 --> 21:39.670
我们得到

21:40.670 --> 21:41.670
这个函数的

21:43.670 --> 21:44.670
结果

21:45.670 --> 21:46.670
于是我们拿到这个

21:46.670 --> 21:47.670
这个服务器的响应结果

21:47.670 --> 21:48.670
你看这就输出的是

21:48.670 --> 21:49.670
服务器响应结果

21:49.670 --> 21:50.670
那么这个玩意是啥呢

21:50.670 --> 21:52.670
这个玩意是整个函数返回的

21:52.670 --> 21:53.670
就这个任函数返回的

21:53.670 --> 21:55.670
是一个promise pending

21:55.670 --> 21:56.670
之前在等待

21:56.670 --> 21:58.670
那么现在肯定是没有等待了

21:58.670 --> 21:59.670
展开过后

21:59.670 --> 22:00.670
现在是已经fulfilled的了

22:00.670 --> 22:02.670
之前运行的时候是在等待

22:02.670 --> 22:04.670
那么现在得到一个

22:04.670 --> 22:05.670
400帐号密码错误

22:05.670 --> 22:06.670
我们再试一下

22:06.670 --> 22:07.670
放一个帐号密码

22:08.670 --> 22:09.670
哈哈

22:09.670 --> 22:11.670
123 123

22:11.670 --> 22:12.670
好 回车

22:12.670 --> 22:14.670
诶 是不是登录成功了

22:14.670 --> 22:15.670
登录成功之后

22:15.670 --> 22:17.670
拿到这个用户的

22:17.670 --> 22:19.670
所有的信息

22:19.670 --> 22:20.670
拿到了

22:20.670 --> 22:21.670
对吧

22:21.670 --> 22:22.670
让我们来看一下

22:22.670 --> 22:23.670
local storage里面

22:23.670 --> 22:24.670
有没有存出

22:24.670 --> 22:25.670
我们的东西呢

22:25.670 --> 22:26.670
找到

22:27.670 --> 22:29.670
application

22:30.670 --> 22:32.670
这里面有个local storage

22:33.670 --> 22:34.670
这里

22:34.670 --> 22:36.670
我怎么存了这么多东西

22:36.670 --> 22:37.670
之前存的

22:37.670 --> 22:38.670
不用管它

22:38.670 --> 22:40.670
这里应该是有一个token

22:40.670 --> 22:41.670
token

22:41.670 --> 22:43.670
key值为token

22:43.670 --> 22:44.670
我自己取了个名字

22:44.670 --> 22:45.670
然后后面是不是存

22:45.670 --> 22:46.670
把东西存进去了

22:46.670 --> 22:47.670
对吧

22:47.670 --> 22:48.670
就这么意思

22:48.670 --> 22:51.670
好 那么存进去之后

22:51.670 --> 22:52.670
那其他的接口

22:52.670 --> 22:54.670
是不是我们要做一个处理

22:54.670 --> 22:55.670
就是你只要有

22:55.670 --> 22:57.670
我就其他所有的接口

22:57.670 --> 22:59.670
我都做一个统一的处理

22:59.670 --> 23:02.670
只要你带有这个token

23:02.670 --> 23:03.670
就是local storage里面

23:03.670 --> 23:05.670
你只要有这个token

23:05.670 --> 23:07.670
我就把它附加到

23:07.670 --> 23:08.670
请求投里面

23:08.670 --> 23:09.670
给它带过去

23:09.670 --> 23:11.670
有些接口服务器不要

23:11.670 --> 23:12.670
不要也可以带过去

23:12.670 --> 23:14.670
你要不要是你的事

23:14.670 --> 23:15.670
你可以说你不要

23:15.670 --> 23:16.670
但是你不能说我没有

23:16.670 --> 23:17.670
反正我就统一处理了

23:17.670 --> 23:20.670
这样子写代码就比较简便

23:20.670 --> 23:21.670
比较方便一点

23:21.670 --> 23:22.670
懂的意思吧

23:22.670 --> 23:23.670
就其他所有的接口

23:23.670 --> 23:24.670
我只要发现

23:24.670 --> 23:25.670
local storage里面有这个东西

23:25.670 --> 23:26.670
我就可以带到

23:26.670 --> 23:27.670
请求投里面去

23:27.670 --> 23:28.670
带过去

23:28.670 --> 23:30.670
那这个代码怎么写呢

23:32.670 --> 23:33.670
比方说Rig

23:33.670 --> 23:34.670
Rig我就要检查一下

23:34.670 --> 23:35.670
local storage里面

23:35.670 --> 23:36.670
有没有这个东西

23:36.670 --> 23:37.670
有的话我在黑道里面

23:37.670 --> 23:38.670
就要给加一个

23:38.670 --> 23:39.670
加一个什么

23:40.670 --> 23:41.670
token

23:41.670 --> 23:42.670
当然这个地方你不能写识

23:42.670 --> 23:44.670
因为你既然使用了这个变量

23:44.670 --> 23:45.670
那你就这里最好

23:45.670 --> 23:46.670
放变量

23:46.670 --> 23:47.670
那怎么放变量的

23:47.670 --> 23:48.670
两个通话号

23:49.670 --> 23:50.670
token

23:50.670 --> 23:51.670
这个什么意思呢

23:51.670 --> 23:52.670
就是把这个变量的值

23:52.670 --> 23:55.670
作为属性的名字放这

23:55.670 --> 23:56.670
对吧

23:56.670 --> 23:58.670
叫动态属性名

23:58.670 --> 24:00.670
那么这里就放了一个什么

24:00.670 --> 24:02.670
放了个local storage里面的东西

24:02.670 --> 24:03.670
当然首先要判断

24:03.670 --> 24:04.670
你到底有没有这个东西

24:04.670 --> 24:05.670
到底有没有

24:05.670 --> 24:06.670
懂的意思吧

24:06.670 --> 24:08.670
是不是所有地方都要加

24:08.670 --> 24:09.670
如果说你觉得

24:09.670 --> 24:10.670
这一步是比较麻烦

24:10.670 --> 24:11.670
每个地方都要加

24:11.670 --> 24:13.670
你看其他的寒说也要加

24:13.670 --> 24:14.670
有点麻烦的话

24:14.670 --> 24:16.670
那么你就可以怎么样

24:16.670 --> 24:18.670
你就可以把这个废棋寒说

24:18.670 --> 24:19.670
做一个封装

24:21.670 --> 24:22.670
做一个二次封装

24:22.670 --> 24:23.670
那怎么来封装呢

24:23.670 --> 24:24.670
比方说

24:24.670 --> 24:26.670
我们就把它封装成两个寒说吧

24:27.670 --> 24:28.670
一个寒说的是

24:29.670 --> 24:30.670
get addp

24:31.670 --> 24:32.670
就叫get寒说

24:33.670 --> 24:34.670
你给我传一个uild地址

24:34.670 --> 24:36.670
或者给我传一个task吧

24:36.670 --> 24:38.670
前面那段我自动帮你拼接

24:39.670 --> 24:42.670
然后其他好像也不需要传递什么了

24:42.670 --> 24:44.670
我们这里做一个简单的封装

24:44.670 --> 24:45.670
其实这个封装

24:45.670 --> 24:47.670
随着通用性的增加

24:47.670 --> 24:48.670
就是你们以后

24:48.670 --> 24:50.670
会发现这么一个感觉

24:50.670 --> 24:51.670
就是你封装

24:51.670 --> 24:52.670
某一个寒说

24:52.670 --> 24:53.670
或者是某一个对象的时候

24:54.670 --> 24:56.670
它越需要通用

24:56.670 --> 24:58.670
它难度就越高

24:58.670 --> 24:59.670
代码就越多

24:59.670 --> 25:01.670
越不通用

25:01.670 --> 25:02.670
它难度就越低

25:02.670 --> 25:03.670
代码就越少

25:03.670 --> 25:04.670
比方说这里呢

25:05.670 --> 25:07.670
我只是针对我这个项目

25:07.670 --> 25:08.670
做一个封装

25:08.670 --> 25:09.670
所以说很多时候

25:09.670 --> 25:11.670
我就处理一些就比较简单了

25:11.670 --> 25:14.180
再来一个post寒说吧

25:14.180 --> 25:16.180
你看我们这个系统里面

25:16.180 --> 25:17.180
就有两个寒说

25:17.180 --> 25:18.180
你给我传一个这个

25:18.180 --> 25:20.180
然后给我传一个保底

25:22.180 --> 25:23.180
保底Objects

25:23.180 --> 25:24.180
一个传一个Objects

25:24.180 --> 25:26.180
那么我就给你

25:26.180 --> 25:28.180
用post寄球发过去

25:28.180 --> 25:29.180
好来吧

25:29.180 --> 25:30.180
这个寒说我怎么封装

25:31.180 --> 25:32.180
我怎么封装

25:32.180 --> 25:34.180
我就直接来一个fetch

25:35.180 --> 25:40.700
前面就是bsurl加上pass

25:40.700 --> 25:42.700
就你只需要把这个传过来就行了

25:42.700 --> 25:43.700
我自动给你加上这个

25:46.700 --> 25:48.700
然后配置一下

25:50.700 --> 25:51.700
headers

25:52.700 --> 25:54.700
那么headers要不要加上这个

25:54.700 --> 25:55.700
要不要加上那个token

25:55.700 --> 25:57.700
那取决于local storage里面

25:57.700 --> 25:59.700
本地存储里面有没有token

25:59.700 --> 26:01.700
所以说这个header到底传啥

26:01.700 --> 26:02.700
这个header到底传啥

26:02.700 --> 26:03.700
传的是一个空队箱

26:03.700 --> 26:04.700
还是传一个这个东西

26:04.700 --> 26:06.700
那么要判断

26:06.700 --> 26:07.700
所以呢

26:07.700 --> 26:09.700
这里我们就这样子写别

26:09.700 --> 26:10.700
你看着

26:10.700 --> 26:13.700
我就写一个headers

26:14.700 --> 26:15.700
写个空队箱吧

26:15.700 --> 26:16.700
先来个空队箱

26:16.700 --> 26:18.700
如果说

26:18.700 --> 26:19.700
先从local storage里面

26:19.700 --> 26:20.700
拿这个token

26:20.700 --> 26:22.700
去拿local storage

26:22.700 --> 26:23.700
gass item

26:23.700 --> 26:24.700
把这个token寄传进去

26:24.700 --> 26:26.700
这个没问题吧

26:26.700 --> 26:27.700
把这个键传进去

26:28.700 --> 26:30.700
把个键的名字传进去

26:30.700 --> 26:32.700
我看一下你有没有

26:32.700 --> 26:34.700
传进去过后呢

26:35.700 --> 26:36.700
是不是拿到这个结果

26:36.700 --> 26:37.700
拿了好指

26:37.700 --> 26:38.700
它只有可能为空

26:38.700 --> 26:39.700
没有

26:39.700 --> 26:41.700
那么如果说你有指的话

26:41.700 --> 26:42.700
怎么样呢

26:42.700 --> 26:44.700
我就往headers里面加一个属性

26:44.700 --> 26:46.700
这个header不就是个属性吗

26:46.700 --> 26:47.700
对吧

26:47.700 --> 26:48.700
那个token对吧

26:48.700 --> 26:50.700
不就是个属性

26:50.700 --> 26:52.700
属性名字叫osr來人形

26:52.700 --> 26:54.700
之前都说错了

26:54.700 --> 26:56.700
叫osr来人形

26:57.700 --> 26:58.700
你看

26:59.700 --> 27:00.700
header

27:00.700 --> 27:02.700
我们要传的是osr来人形

27:02.700 --> 27:03.700
刚才说错了

27:03.700 --> 27:04.700
传的不是token

27:04.700 --> 27:05.700
是吧

27:05.700 --> 27:06.700
是不是我们把这个带过去

27:06.700 --> 27:08.700
osr来人形

27:08.700 --> 27:09.700
听见一下制服串

27:09.700 --> 27:10.700
这个制服串是什么呢

27:10.700 --> 27:11.700
就是这个格式

27:11.700 --> 27:13.700
前面有一个固定的

27:14.700 --> 27:21.240
就是这个

27:21.240 --> 27:22.240
前面是一个固定的

27:22.240 --> 27:24.240
固定的和空格

27:24.240 --> 27:25.240
后面填什么

27:25.240 --> 27:26.240
填了个token

27:27.240 --> 27:29.240
是把服务器那边给我

27:29.240 --> 27:30.240
之前存的令牌就带过去

27:31.240 --> 27:32.240
对吧

27:32.240 --> 27:33.240
好 那么最后配置的时候呢

27:33.240 --> 27:35.240
我就把这个header传进来

27:36.240 --> 27:37.240
能看懂的代码吧

27:37.240 --> 27:38.240
好 履履

27:38.240 --> 27:40.240
就是非常简单的逻辑

27:40.240 --> 27:42.240
我给的方法就是这样子

27:42.240 --> 27:44.240
这个发过去

27:44.240 --> 27:45.240
有一个

27:46.240 --> 27:47.240
看一下本地有没有这个token

27:47.240 --> 27:48.240
有token的话

27:48.240 --> 27:49.240
就给header里面加一个

27:50.240 --> 27:51.240
对吧

27:51.240 --> 27:52.240
header里面加一个

27:52.240 --> 27:53.240
然后把header放进去

27:53.240 --> 27:54.240
如果说没有token的话

27:54.240 --> 27:55.240
header就是空对象

27:55.240 --> 27:56.240
当然那意思吧

27:56.240 --> 27:57.240
就这么一个意思

27:59.240 --> 28:00.240
当然你也可以

28:01.240 --> 28:02.240
单独的在写

28:02.240 --> 28:03.240
封装一个函数

28:03.240 --> 28:04.240
再得到一个header

28:04.240 --> 28:05.240
反正都无所谓

28:05.240 --> 28:06.240
反正就是这样子

28:06.240 --> 28:07.240
然后最后呢

28:07.240 --> 28:08.240
我们把这个废棋返回

28:08.240 --> 28:10.240
废棋的奖励结果返回

28:10.240 --> 28:11.240
其实这里都不用逸步了

28:11.240 --> 28:12.240
因为这个废棋返回的

28:12.240 --> 28:13.240
就是一个promise

28:14.240 --> 28:15.240
对吧

28:15.240 --> 28:16.240
好 把它返回

28:17.240 --> 28:19.240
好 那么再封装一下posed函数

28:19.240 --> 28:21.240
posed函数的话也是一样的

28:21.240 --> 28:22.240
把单码扶植一下

28:23.240 --> 28:24.240
什么地方不一样呢

28:25.240 --> 28:26.240
什么地方不一样

28:26.240 --> 28:27.240
不就是这里吗

28:27.240 --> 28:28.240
是不是这里

28:28.240 --> 28:30.240
除了这个header之外呢

28:30.240 --> 28:31.240
还要配置什么

28:31.240 --> 28:32.240
message的为什么

28:32.240 --> 28:33.240
post

28:33.240 --> 28:34.240
还要配置什么

28:34.240 --> 28:36.240
header里面还必须要有

28:36.240 --> 28:37.240
一个固定的

28:37.240 --> 28:38.240
content type

28:38.240 --> 28:39.240
为fdk型节省

28:40.240 --> 28:41.240
对吧 这是固定的

28:41.240 --> 28:42.240
然后body为什么呢

28:42.240 --> 28:43.240
body为

28:43.240 --> 28:45.240
节省

28:45.240 --> 28:46.240
syncing

28:46.240 --> 28:47.240
把这个东西

28:48.240 --> 28:49.240
变成一个节省格式

28:50.240 --> 28:51.240
发过去完事

28:51.240 --> 28:52.240
不就这样吗

28:52.240 --> 28:53.240
就posed请求

28:54.240 --> 28:55.240
什么意思啊

28:56.240 --> 28:58.240
就封装完了

28:58.240 --> 28:59.240
就封装完了

28:59.240 --> 29:00.240
好 封装完了之后了

29:00.240 --> 29:01.240
之后

29:01.240 --> 29:02.240
当然这里面

29:02.240 --> 29:03.240
有一些重复代码

29:03.240 --> 29:04.240
就标上这里

29:04.240 --> 29:06.240
你可以再去提个函数出去

29:06.240 --> 29:07.240
那么现在

29:07.240 --> 29:08.240
这个reg函数

29:08.240 --> 29:09.240
就可以使用我们之前的

29:09.240 --> 29:10.240
posed函数

29:10.240 --> 29:11.240
对吧

29:11.240 --> 29:12.240
posed函数

29:12.240 --> 29:13.240
你只需要传递这个就行了

29:15.740 --> 29:16.740
然后传递有什么

29:16.740 --> 29:17.740
传递有者营发进去

29:18.740 --> 29:19.740
其他的事情不用你管

29:21.740 --> 29:22.740
posed函数

29:22.740 --> 29:23.740
那么得到的结果是一样的

29:23.740 --> 29:24.740
其他的说法是一样的

29:26.740 --> 29:27.740
reg函数

29:27.740 --> 29:28.740
login函数也是一样

29:28.740 --> 29:29.740
你只需要传递这个

29:31.740 --> 29:32.740
然后呢

29:32.740 --> 29:33.740
login一发

29:34.740 --> 29:35.740
就传过去

29:36.740 --> 29:37.740
这里换成posed

29:38.740 --> 29:39.740
对吧

29:39.740 --> 29:40.740
是意思

29:40.740 --> 29:42.740
那么后边的代码都一样了

29:42.740 --> 29:43.740
如果说服务器那边

29:43.740 --> 29:44.740
响应了有一个token的话

29:44.740 --> 29:45.740
那我就把它存到

29:45.740 --> 29:46.740
loginstore里面去

29:48.740 --> 29:50.740
其实这件事

29:50.740 --> 29:51.740
不用说

29:51.740 --> 29:52.740
这件事也可以在

29:52.740 --> 29:53.740
封装里面直接把它做

29:55.740 --> 29:56.740
不过呢

29:56.740 --> 29:57.740
这个只有登录

29:57.740 --> 29:58.740
在我们这个场景里面

29:58.740 --> 29:59.740
只有登录的时候

29:59.740 --> 30:01.740
才会有服务器响应的

30:01.740 --> 30:02.740
的token过来

30:02.740 --> 30:03.740
只有在登录的时候

30:03.740 --> 30:04.740
服务器才会

30:04.740 --> 30:05.740
给我有这么一个响应

30:05.740 --> 30:06.740
所以说

30:06.740 --> 30:07.740
这个地方倒不会有重复代

30:08.740 --> 30:09.740
所以我直接就去了

30:09.740 --> 30:10.740
这也没有什么问题

30:11.740 --> 30:12.740
好

30:12.740 --> 30:13.740
我们现在再来试一下

30:14.740 --> 30:15.740
再来试一下

30:15.740 --> 30:16.740
那么现在呢

30:16.740 --> 30:17.740
我们去

30:17.740 --> 30:18.740
再来登录一次

30:18.740 --> 30:19.740
你会发现

30:19.740 --> 30:20.740
这个地方是没问题的

30:20.740 --> 30:21.740
对吧

30:22.740 --> 30:23.740
然后接下来

30:23.740 --> 30:24.740
我们看一下这个

30:24.740 --> 30:26.740
比方说这个函数吧

30:26.740 --> 30:27.740
profile

30:28.740 --> 30:29.740
这个函数就直接发出

30:29.740 --> 30:30.740
一个get请求就完事了

30:31.740 --> 30:32.740
非常简单

30:33.740 --> 30:34.740
只剩下一个get请求

30:35.740 --> 30:36.740
先来一个sync

30:38.740 --> 30:39.740
get请求

30:39.740 --> 30:40.740
请求什么地址呢

30:41.740 --> 30:42.740
请求的地址

30:42.740 --> 30:43.740
是

30:43.740 --> 30:44.740
就这个地址

30:46.740 --> 30:47.740
请求过去完事了

30:47.740 --> 30:49.740
为什么就可以这么方便

30:49.740 --> 30:50.740
为什么

30:50.740 --> 30:52.740
因为我们用了封装的函数

30:52.740 --> 30:53.740
这个封装的函数里边

30:53.740 --> 30:54.740
它发现你是get请

30:55.740 --> 30:56.740
它会自动把那个

30:56.740 --> 30:57.740
OSR人形给带过去

30:58.740 --> 30:59.740
对吧

30:59.740 --> 31:00.740
因为这个结果

31:00.740 --> 31:01.740
我们之前用过

31:01.740 --> 31:02.740
它就是

31:02.740 --> 31:03.740
它的作用就是

31:03.740 --> 31:04.740
把个令牌给它带过去

31:04.740 --> 31:05.740
服务器告诉你

31:05.740 --> 31:06.740
你这个令牌

31:06.740 --> 31:07.740
是哪个用户的

31:07.740 --> 31:08.740
就说明你

31:08.740 --> 31:09.740
是什么

31:09.740 --> 31:10.740
就这么个意思

31:10.740 --> 31:11.740
所以这个函数

31:11.740 --> 31:12.740
就变得非常简单

31:13.740 --> 31:14.740
请求这个地址

31:15.740 --> 31:16.740
然后接下来

31:16.740 --> 31:17.740
要做的事情是一样的

31:17.740 --> 31:18.740
给我一次

31:19.740 --> 31:26.410
好,来试一下这个函数

31:26.410 --> 31:27.410
profile

31:28.410 --> 31:29.410
profile

31:30.410 --> 31:31.410
不用传传说

31:31.410 --> 31:32.410
它就是把自动

31:32.410 --> 31:33.410
把头捧给它带过去

31:35.410 --> 31:36.410
服务器告诉我

31:36.410 --> 31:37.410
你是谁

31:37.410 --> 31:38.410
服务器不就告诉我了吗

31:38.410 --> 31:39.410
你是这个

31:39.410 --> 31:40.410
然后我们看一下

31:40.410 --> 31:41.410
网络传说

31:41.410 --> 31:43.410
是不是Header里边

31:43.410 --> 31:44.410
request

31:44.410 --> 31:45.410
下面

31:45.410 --> 31:47.410
是不是带过去了

31:47.410 --> 31:48.410
就带过去了

31:49.410 --> 31:50.410
对吧

31:50.410 --> 31:51.410
怎么带过去的

31:52.410 --> 31:53.410
该产还是带过去的

31:53.410 --> 31:54.410
它首先检查

31:54.410 --> 31:55.410
都会Story机里面有没有

31:55.410 --> 31:56.410
Story有的

31:56.410 --> 31:57.410
把读出来

31:57.410 --> 31:58.410
放到Header里面带过去

31:59.410 --> 32:00.410
好

32:00.410 --> 32:02.410
当前账号是否存在

32:03.410 --> 32:04.410
是不是一样的

32:04.410 --> 32:05.410
月子请求

32:06.410 --> 32:07.410
验证账号

32:09.410 --> 32:10.410
这里要传一个什么

32:10.410 --> 32:12.410
传一个就是参数

32:14.410 --> 32:15.410
月子请求

32:16.410 --> 32:17.410
就是把这个地方改一下

32:17.410 --> 32:18.410
改成啥

32:19.410 --> 32:20.410
改成

32:20.410 --> 32:21.410
拼接

32:22.410 --> 32:23.410
不就完了吗

32:23.410 --> 32:24.410
还有啥

32:24.410 --> 32:25.410
没啥了

32:25.410 --> 32:26.410
页能账号说了存在

32:27.410 --> 32:28.410
那么这里就一参了

32:30.410 --> 32:34.260
这些太晚了

32:34.260 --> 32:35.260
你写的写的

32:36.260 --> 32:37.260
慢慢就写错误了

32:37.260 --> 32:38.260
一开始觉得

32:38.260 --> 32:39.260
这个挺有技术含量的

32:39.260 --> 32:41.260
后面写的就写错误了

32:41.260 --> 32:42.260
天哪这是写这些东西

32:43.260 --> 32:44.260
一个项目来了过

32:44.260 --> 32:45.260
理想二话不说

32:45.260 --> 32:46.260
拿着看它有什么功能

32:46.260 --> 32:47.260
我先把这个接口

32:47.260 --> 32:48.260
一个个写完再说

32:48.260 --> 32:49.260
一个个测试完了

32:49.260 --> 32:50.260
没问题再说

32:50.260 --> 32:51.260
见面看

32:51.260 --> 32:52.260
现在看都不着急看

32:53.260 --> 32:54.260
这里要把它变成一部

32:55.260 --> 32:56.260
那么后面

32:56.260 --> 32:57.260
我们直接用这些函数

32:57.260 --> 32:58.260
是不是可以搞定

32:58.260 --> 32:59.260
这一刻就做这个事

32:59.260 --> 33:00.260
一个list

33:00.260 --> 33:01.260
来试一下吧

33:01.260 --> 33:02.260
哪个账号

33:02.260 --> 33:03.260
哈哈看一下存不存在呢

33:03.260 --> 33:05.260
这个肯定应该是存在的

33:05.260 --> 33:06.260
来测试一下

33:08.260 --> 33:09.260
看一下符记的响应结果

33:11.260 --> 33:12.260
是存在的

33:12.260 --> 33:13.260
有这个账号

33:13.260 --> 33:14.260
那么再来一个

33:14.260 --> 33:15.260
随便再来一个

33:16.260 --> 33:17.260
然后符记告诉我

33:17.260 --> 33:18.260
是force

33:18.260 --> 33:19.260
没有这个账号

33:19.260 --> 33:20.260
就这么简单

33:20.260 --> 33:22.260
好那么这个send chart

33:22.260 --> 33:24.260
发送聊天消息

33:24.260 --> 33:25.260
来吧

33:25.260 --> 33:27.260
发送聊天消息是

33:27.260 --> 33:29.260
pose请求请求这个地址

33:32.080 --> 33:33.080
pose请求

33:34.080 --> 33:35.080
请求这个地址

33:35.080 --> 33:36.080
然后呢

33:37.080 --> 33:38.080
内容

33:38.080 --> 33:39.080
发送的内容是一个对象

33:39.080 --> 33:41.080
对象里面有个content属性

33:41.080 --> 33:42.080
对吧你看

33:42.080 --> 33:43.080
有content属性

33:43.080 --> 33:44.080
那么这里呢

33:44.080 --> 33:46.080
你把个制服刷content传过来

33:46.080 --> 33:47.080
就按哨了

33:48.080 --> 33:49.080
是不是

33:49.080 --> 33:50.080
对

33:50.080 --> 33:52.080
很简单的是吧

33:55.860 --> 33:57.860
这里把标记为sink

33:58.860 --> 34:00.860
好来试一下个send chart

34:00.860 --> 34:04.820
发送个聊天消息

34:04.820 --> 34:05.820
发到啥

34:05.820 --> 34:06.820
讲个消耗

34:06.820 --> 34:08.820
你几岁了

34:08.820 --> 34:09.820
对吧

34:09.820 --> 34:11.820
你是男是女

34:15.190 --> 34:17.190
看一下符记的响应结果

34:18.190 --> 34:21.850
好符记跟我们响应了

34:22.850 --> 34:23.850
他说的

34:25.850 --> 34:26.850
好

34:26.850 --> 34:27.850
this is history

34:27.850 --> 34:30.850
得到聊天的历史消息记录

34:32.850 --> 34:33.850
不就这个结合吗

34:33.850 --> 34:34.850
get this請求

34:34.850 --> 34:35.850
请求这个地址接口就完事了

34:35.850 --> 34:36.850
对吧

34:36.850 --> 34:38.850
你不需要告诉他是哪一个用户

34:38.850 --> 34:39.850
跟机械人聊天接口

34:39.850 --> 34:41.850
虽然我们符记可以支持很多用户

34:41.850 --> 34:42.850
对

34:42.850 --> 34:43.850
请求

34:43.850 --> 34:44.850
你不需要知道哪个用户的

34:44.850 --> 34:45.850
为什么呢

34:45.850 --> 34:46.850
因为黑的里面该带过去了

34:46.850 --> 34:47.850
他头很该带过去了

34:47.850 --> 34:48.850
带过去了就符记就知道

34:48.850 --> 34:49.850
哎呀

34:49.850 --> 34:50.850
原来你是这个用户

34:50.850 --> 34:51.850
你是哈哈这个用户

34:52.850 --> 34:54.850
你在问你跟机器人之间的

34:54.850 --> 34:56.850
聊天历史记录

34:56.850 --> 34:58.850
你问的不是别人跟机器人的

34:58.850 --> 35:01.850
你问的是你自己跟机器人聊天记录

35:01.850 --> 35:03.850
所以说这个地方我只要

35:03.850 --> 35:05.850
只要做这么几件事就完事了

35:05.850 --> 35:07.850
当然了我还得

35:07.850 --> 35:15.450
解析一下啊

35:15.450 --> 35:17.450
提提伙真的是提提伙

35:17.450 --> 35:19.450
你看到后面全是提提伙

35:19.450 --> 35:20.450
叫网络男吗

35:20.450 --> 35:22.450
你只要把概念理解清楚了

35:22.450 --> 35:24.450
这些玩意跟我儿似的

35:24.450 --> 35:26.450
跟我儿似的

35:27.450 --> 35:33.960
看一下解析

35:33.960 --> 35:34.960
当然如果说你没有登录

35:34.960 --> 35:38.960
那就另外一说了啊

35:38.960 --> 35:39.960
你看

35:39.960 --> 35:41.960
这不是说聊天记录消息吗

35:41.960 --> 35:44.960
这是最后一条聊天记录

35:44.960 --> 35:46.960
这第一条你几岁了

35:46.960 --> 35:48.960
他给你回

35:48.960 --> 35:50.960
然后我给他发

35:50.960 --> 35:52.960
他给我回

35:52.960 --> 35:53.960
就这个意思

35:53.960 --> 35:55.960
好那么现在我们把

35:55.960 --> 35:56.960
当然你也试一下

35:56.960 --> 35:57.960
没有登录

35:57.960 --> 35:59.960
那我说怎么来退出登录呢

35:59.960 --> 36:02.960
要同学问你个很有技术含量的问题

36:02.960 --> 36:03.960
怎么退出登录

36:03.960 --> 36:05.960
退出登录就是把这个玩意

36:05.960 --> 36:07.960
一删他就退出登录了

36:07.960 --> 36:09.960
你想把你这个头坑没了

36:09.960 --> 36:10.960
你请求的时候

36:10.960 --> 36:12.960
是不是就不会带头坑了

36:12.960 --> 36:13.960
不会带头坑的服务器

36:13.960 --> 36:14.960
就不知道你登不登录了

36:14.960 --> 36:16.960
他就认为你没登录

36:16.960 --> 36:18.960
要实现

36:18.960 --> 36:19.960
助销特别简单

36:19.960 --> 36:21.960
都不用一步了

36:21.960 --> 36:23.960
挪行二字

36:23.960 --> 36:24.960
就有的接口了

36:24.960 --> 36:25.960
他还会

36:25.960 --> 36:26.960
就是有的服务器

36:26.960 --> 36:27.960
他会给你提供一个接口

36:27.960 --> 36:29.960
你请求那个接口

36:29.960 --> 36:30.960
来实现助销

36:30.960 --> 36:31.960
因为助销的时候

36:31.960 --> 36:33.960
可能服务器还要做一些别的事

36:33.960 --> 36:34.960
比方说日制纪录啊

36:34.960 --> 36:36.960
把你的登录状态更改啊

36:36.960 --> 36:37.960
之类的啊

36:37.960 --> 36:38.960
但是有些服务器

36:38.960 --> 36:40.960
他就根本就不管你

36:40.960 --> 36:41.960
你助销你自己助销

36:41.960 --> 36:42.960
你把你衣衫

36:42.960 --> 36:44.960
头坑衣衫就助销了

36:44.960 --> 36:45.960
那就这么简单

36:47.960 --> 36:48.960
好

36:48.960 --> 36:49.960
locking out

36:49.960 --> 36:50.960
那么

36:50.960 --> 36:51.960
都提示你

36:51.960 --> 36:53.960
remove it

36:53.960 --> 36:54.960
把这个key

36:54.960 --> 36:55.960
把这个

36:55.960 --> 36:56.960
存到本地的东西

36:56.960 --> 36:57.960
干啥呢

36:57.960 --> 36:58.960
那就完事了

36:58.960 --> 36:59.960
好

36:59.960 --> 37:00.960
当然试一下啊

37:00.960 --> 37:01.960
助销

37:01.960 --> 37:03.960
locking out

37:03.960 --> 37:04.960
好

37:04.960 --> 37:05.960
助销之后

37:05.960 --> 37:06.960
我们再来发送聊天

37:06.960 --> 37:07.960
在那得到的历史记录

37:07.960 --> 37:08.960
你看

37:08.960 --> 37:09.960
他告诉你没有登录

37:09.960 --> 37:10.960
登录一过期

37:10.960 --> 37:11.960
我再看一下

37:11.960 --> 37:12.960
IPK信件里面

37:12.960 --> 37:13.960
也头坑是不是没了

37:13.960 --> 37:14.960
这些什么

37:14.960 --> 37:15.960
哎呀

37:15.960 --> 37:16.960
这些记录的

37:16.960 --> 37:17.960
什么

37:17.960 --> 37:19.960
我以前做一些

37:19.960 --> 37:20.960
讲课的时候

37:20.960 --> 37:21.960
记录一些东西

37:21.960 --> 37:23.960
啥啥啥啥

37:23.960 --> 37:24.960
按D类子

37:25.960 --> 37:27.960
那登录之后又有了

37:27.960 --> 37:29.960
说你又有没有登录

37:29.960 --> 37:30.960
关键是看你本地

37:30.960 --> 37:31.960
有没有那个头坑

37:31.960 --> 37:32.960
有没有令牌

37:32.960 --> 37:33.960
你令牌丢了

37:33.960 --> 37:34.960
那就没有登录了

37:34.960 --> 37:35.960
你搬到那个卡没了

37:35.960 --> 37:37.960
那就不是会员了

37:37.960 --> 37:38.960
就这么简单

37:40.960 --> 37:41.960
好

37:41.960 --> 37:42.960
包括我们再去寻求

37:42.960 --> 37:43.960
那个short

37:43.960 --> 37:44.960
哪能寻求

37:44.960 --> 37:45.960
试一下吧

37:45.960 --> 37:46.960
short

37:46.960 --> 37:47.960
没有登录

37:47.960 --> 37:49.960
你无法完成这个接口的调用

37:49.960 --> 37:50.960
再来试一下这个

37:51.960 --> 37:52.960
一个z还可以

37:52.960 --> 37:53.960
一个z

37:53.960 --> 37:54.960
它是不需要登录的

37:55.960 --> 37:56.960
这个

37:57.960 --> 37:58.960
还有什么

37:58.960 --> 37:59.960
pro-file

37:59.960 --> 38:00.960
pro-file是必须要登录的

38:00.960 --> 38:01.960
这个接口

38:03.960 --> 38:05.960
我们这里就做完了

38:05.960 --> 38:06.960
还有一点点

38:06.960 --> 38:08.960
就是把这个函数封装一下

38:08.960 --> 38:10.960
那么这里还有一些小问题

38:10.960 --> 38:12.960
你这样子写了函数之后

38:12.960 --> 38:13.960
会污染全局

38:13.960 --> 38:14.960
就是让这个东西

38:14.960 --> 38:15.960
污染全局

38:15.960 --> 38:16.960
对吧

38:16.960 --> 38:17.960
这个没什么好说的吧

38:17.960 --> 38:20.960
那么这里有两种处理办法

38:20.960 --> 38:21.960
一种处理办法

38:21.960 --> 38:30.200
就是你用这种书写方式

38:30.200 --> 38:32.200
你用这种书写方式

38:32.200 --> 38:34.200
就把刚才代码

38:34.200 --> 38:35.200
就把刚才代码复制过来

38:35.200 --> 38:36.200
因为我们知道

38:36.200 --> 38:37.200
concert定义的东西

38:37.200 --> 38:39.200
它是不会挂载到温度上边的

38:42.020 --> 38:43.020
对吧

38:43.020 --> 38:45.020
但是这不是一个

38:45.020 --> 38:46.020
很好做法

38:46.020 --> 38:47.020
最好的就是

38:47.020 --> 38:48.020
我们目前还没有学习模块化

38:48.020 --> 38:50.020
你们后面会学习模块化

38:50.020 --> 38:51.020
有了模块化之后

38:51.020 --> 38:53.020
这个代码就没有任何问题了

38:53.020 --> 38:54.020
但是现在还没有学习模块化

38:54.020 --> 38:56.020
我们还得用那种传统的办法

38:56.020 --> 38:58.020
立即执行函数是最好的

38:58.020 --> 39:01.940
用立即执行函数

39:01.940 --> 39:03.940
这个玩意说过的

39:04.940 --> 39:06.940
你把保到立即执行函数里边

39:07.940 --> 39:08.940
全部放进去

39:08.940 --> 39:09.940
这样子所有的东西

39:09.940 --> 39:11.940
不会污染全局

39:11.940 --> 39:12.940
然后呢

39:12.940 --> 39:14.940
但是你这样子搞的话

39:14.940 --> 39:15.940
那别的介石

39:15.940 --> 39:16.940
它就用不了这些函数了

39:16.940 --> 39:17.940
对不对

39:17.940 --> 39:18.940
你要把这些函数放出去

39:18.940 --> 39:19.940
让别人使用

39:19.940 --> 39:20.940
怎么样

39:20.940 --> 39:21.940
单对向模式

39:26.380 --> 39:27.380
几个大写吧

39:29.380 --> 39:31.380
我把这个函数执行完成之后

39:31.380 --> 39:33.380
你最好给我返回一个东西

39:33.380 --> 39:34.380
我把它保存到这里边

39:34.380 --> 39:36.380
这个玩意是污染全局的

39:36.380 --> 39:37.380
那么这样子我在这里边

39:37.380 --> 39:38.380
就可以通过API

39:39.380 --> 39:40.380
保存一下

39:40.380 --> 39:41.380
目前是NDPI

39:41.380 --> 39:42.380
为什么

39:42.380 --> 39:43.380
因为它这个函数没返回

39:43.380 --> 39:45.380
那么把这个函数返回的结果

39:45.380 --> 39:46.380
保存到这里边

39:46.380 --> 39:47.380
比方说我给它返回一个对象

39:49.380 --> 39:50.380
返回一个对象

39:50.380 --> 39:51.380
那么这样子的对象

39:51.380 --> 39:53.380
就返回到API里边去了

39:53.380 --> 39:54.380
那么这样子

39:54.380 --> 39:55.380
有没有污染全局有

39:55.380 --> 39:57.380
但是只污染了一个影子叫API

39:57.380 --> 39:58.380
这样子的

39:58.380 --> 40:00.380
可以最大程度的避免聪明

40:00.380 --> 40:01.380
那么在对象里面

40:01.380 --> 40:02.380
你就放东西

40:02.380 --> 40:03.380
你想放哪些

40:03.380 --> 40:04.380
就放进去

40:04.380 --> 40:05.380
比方说我们的

40:05.380 --> 40:06.380
这些函数都要放进去

40:06.380 --> 40:07.380
Rig

40:07.380 --> 40:08.380
Login

40:08.380 --> 40:09.380
都放进去吧

40:09.380 --> 40:10.380
Rig

40:10.380 --> 40:11.380
Login

40:12.380 --> 40:13.380
Exist

40:13.380 --> 40:14.380
还有什么

40:14.380 --> 40:15.380
Profile

40:15.380 --> 40:16.380
还有什么

40:16.380 --> 40:17.380
Zenchot

40:17.380 --> 40:18.380
还有什么

40:18.380 --> 40:19.380
Gitry

40:19.380 --> 40:20.380
还有什么

40:20.380 --> 40:21.380
Loginout

40:21.380 --> 40:23.380
好就把这些放进去

40:23.380 --> 40:24.380
这样子的

40:24.380 --> 40:25.380
对象里面就有东西了

40:25.380 --> 40:26.380
那么别的介绍

40:26.380 --> 40:27.380
是不是可以用这个

40:27.380 --> 40:28.380
用这些函数

40:29.380 --> 40:30.380
就这么简单

40:30.380 --> 40:31.380
这就我们就封装了

40:31.380 --> 40:32.380
一个API

40:32.380 --> 40:33.380
就是这样封装的

40:34.380 --> 40:35.380
你们下台这几课

40:35.380 --> 40:36.380
就做这件事

40:36.380 --> 40:37.380
把他封装好

40:38.380 --> 40:39.380
其他的

40:39.380 --> 40:40.380
没啥了

40:40.380 --> 40:41.380
你做到做到

40:41.380 --> 40:42.380
你把这个玩意

40:42.380 --> 40:43.380
这个玩意做完了

40:43.380 --> 40:44.380
其实网络就完了

40:44.380 --> 40:45.380
真的

40:45.380 --> 40:46.380
这剩下的事情

40:46.380 --> 40:47.380
我就按不就完了

40:47.380 --> 40:48.380
用以前学过了

40:48.380 --> 40:50.380
这跟网络就没关系了

40:50.380 --> 40:52.380
就是用以前学过的知识

40:52.380 --> 40:54.380
然后把这个项目完成

40:54.380 --> 40:56.380
把网络已经提供给你了

40:56.380 --> 40:58.380
你想什么时候用

40:58.380 --> 41:00.380
就去调用相关的函数

41:00.380 --> 41:02.380
就按稍儿了

41:02.380 --> 41:03.380
OK

41:03.380 --> 41:04.380
就这一回

