WEBVTT

00:00.000 --> 00:03.160
好了 网络部分的代码

00:04.320 --> 00:07.800
其实你只要把之前的东西你学懂了之后

00:07.800 --> 00:10.760
你在看这个代码其实非常非常的简单

00:11.200 --> 00:14.640
这个代码我们把它统称为阿加克斯

00:14.640 --> 00:16.160
它到底是什么呢

00:16.160 --> 00:18.240
我们抛弃它的官方解释

00:18.240 --> 00:20.800
因为它官方解释不太容易看得懂

00:21.000 --> 00:22.800
它其实非常简单

00:22.800 --> 00:25.200
它就是浏览器

00:25.200 --> 00:27.200
它不是能够网络通信吗

00:27.200 --> 00:29.680
对吧 能够发送网络请求

00:29.840 --> 00:31.680
这是我们之前讲过的

00:31.680 --> 00:33.480
那么在过去的时候

00:33.480 --> 00:35.880
它并没有把这种能力

00:37.280 --> 00:38.880
暴露给介石

00:38.880 --> 00:40.880
所以介石在过去的时候

00:40.880 --> 00:43.280
是不能发送网络请求的

00:43.280 --> 00:46.680
那么现在它已经暴露给了介石

00:46.680 --> 00:50.280
所以说我们可以利用介石里面的一套API

00:50.280 --> 00:52.280
什么叫API 就是一些对象

00:52.280 --> 00:53.880
一些函数

00:53.880 --> 00:56.280
给你弄好的 你直接使用

00:56.280 --> 00:57.880
通过这套API

00:57.880 --> 01:01.480
你就可以让介石具备网络通信的能力

01:01.480 --> 01:03.880
那么这个玩意就是阿加克斯

01:03.880 --> 01:06.680
阿加克斯简单来说就是在介石里面

01:06.680 --> 01:10.280
使用一套API发送网络请求

01:10.280 --> 01:12.680
能够获得服务器的响应结果

01:12.680 --> 01:13.880
就这么一个东西

01:13.880 --> 01:15.880
那么我们对照上面这张图

01:15.880 --> 01:17.480
就是我们上节课这张图

01:18.480 --> 01:20.680
阿加克斯发生在什么时候呢

01:20.680 --> 01:22.880
你看浏览器里面不是可以去

01:22.880 --> 01:25.080
请求服务器 对吧

01:25.080 --> 01:27.680
拿到这个服务器的响应结果

01:27.880 --> 01:29.880
然后阿加克斯发生在什么时候

01:30.880 --> 01:33.480
你看去拿他这个CSS代码

01:33.480 --> 01:35.680
去拿那个图片 去拿介石

01:35.680 --> 01:37.080
就发生在这个时候

01:38.280 --> 01:40.280
当我们拿到介石之后

01:40.280 --> 01:41.880
是不是会运行介石

01:41.880 --> 01:43.680
会执行这个介石 对吧

01:43.680 --> 01:45.880
那么在执行的过程中

01:45.880 --> 01:48.480
如果说执行到了一段代码

01:49.280 --> 01:51.880
就是你使用阿加克斯那套API

01:51.880 --> 01:54.480
某些函数去发送请求的代码

01:54.480 --> 01:56.680
那么在执行介石代码的过程中

01:56.680 --> 01:58.680
他又会去访问服务器

01:58.680 --> 02:00.680
拿到服务器的响应结果

02:00.680 --> 02:02.680
就这么个东西

02:02.680 --> 02:05.680
当然这个介石代码并不一定是

02:05.680 --> 02:06.680
一开始就执行

02:06.680 --> 02:08.680
比方说你完全可以把它写到一个

02:08.680 --> 02:09.680
点击事件里面

02:09.680 --> 02:12.680
浏览器加在完成之后等待用户的操作

02:12.680 --> 02:14.680
用户在这个时候进行了点击

02:14.680 --> 02:17.680
你在点击事件里面写了一段代码

02:17.680 --> 02:20.680
写了某一个函数去发一个请求用介石

02:20.680 --> 02:23.680
于是浏览器又会去发一个请求

02:23.680 --> 02:24.680
拿到这个响应结果

02:25.680 --> 02:26.680
就这么个玩意儿

02:26.680 --> 02:27.680
所以说我们选阿加克斯

02:27.680 --> 02:29.680
觉得就特别简单了

02:29.680 --> 02:32.680
他其实就是把PoseMan里面这套东西

02:32.680 --> 02:34.680
放到介石里面去了

02:34.680 --> 02:36.680
就是我们在介石里面

02:36.680 --> 02:38.680
可以拿到服务器响应的结果

02:38.680 --> 02:40.680
可以发出请求就是这个玩意儿

02:40.680 --> 02:42.680
那么我们接下来学习一下

02:42.680 --> 02:44.680
首先来了解一下他的历史

02:45.680 --> 02:47.680
浏览器它本身就是用来做

02:47.680 --> 02:48.680
网络通信的

02:48.680 --> 02:50.680
所以说我们通常的把浏览器交作

02:50.680 --> 02:52.680
用户代理

02:52.680 --> 02:54.680
就帮着用户去进行网络通信

02:54.680 --> 02:56.680
拿一天没有解析

02:56.680 --> 02:58.680
一天没有去拿CSS

02:58.680 --> 03:00.680
然后解析CSS

03:00.680 --> 03:02.680
然后去拿介石

03:02.680 --> 03:04.680
执行介石

03:04.680 --> 03:06.680
这种网络通信的能力

03:06.680 --> 03:07.680
在早期的时候

03:07.680 --> 03:08.680
浏览器并没有把这个能力

03:08.680 --> 03:09.680
开放给介石

03:09.680 --> 03:10.680
所以说那个时候

03:10.680 --> 03:13.680
介石它是完成不了网络通信的

03:13.680 --> 03:15.680
它只能做一些

03:15.680 --> 03:17.680
跟网络无关的一些特效

03:17.680 --> 03:18.680
所以那个时候

03:18.680 --> 03:20.680
前段地位很低

03:20.680 --> 03:21.680
就是这个原因

03:21.680 --> 03:23.680
它能做的事情特别有限

03:23.680 --> 03:25.680
那么这件事呢

03:25.680 --> 03:27.680
其实在很早的时候

03:27.680 --> 03:29.680
在2000年左右吧

03:29.680 --> 03:31.680
微软在IE浏览器里边

03:31.680 --> 03:32.680
就开放了一个功能

03:32.680 --> 03:35.680
就是把浏览器的网络通信的能力

03:35.680 --> 03:38.680
部分的开放给介石

03:38.680 --> 03:41.680
让介石可以在代码的运行过程中

03:41.680 --> 03:42.680
发送请求

03:42.680 --> 03:44.680
拿到响应结果

03:44.680 --> 03:45.680
那么这项基础

03:45.680 --> 03:46.680
在2005年的时候

03:46.680 --> 03:48.680
被正式命名为阿迪克斯

03:48.680 --> 03:50.680
特别有长串说些叫做

03:50.680 --> 03:52.680
Ansynchronous

03:52.680 --> 03:54.680
一部的JavaScript

03:54.680 --> 03:56.680
介石

03:56.680 --> 03:58.680
and XML

03:58.680 --> 04:00.680
这个玩意我们就不去具体解释了

04:00.680 --> 04:02.680
这个介石全然可以

04:02.680 --> 04:04.680
涉及到很多历史的一些东西

04:04.680 --> 04:06.680
就不去具体解释

04:06.680 --> 04:07.680
你反正就认为

04:07.680 --> 04:08.680
就是阿迪克斯什么意思

04:08.680 --> 04:09.680
就是给介石

04:09.680 --> 04:11.680
让介石可以发送网络请求

04:11.680 --> 04:13.680
拿到浏览器的响应结果

04:13.680 --> 04:15.680
IE在IE里边呢

04:15.680 --> 04:17.680
它使用的是一套API

04:17.680 --> 04:20.680
一套东西来完成请求的发送

04:20.680 --> 04:21.680
那么这套API

04:21.680 --> 04:23.680
它是通过一个构造函数完成的

04:23.680 --> 04:24.680
构造函数的名称叫做

04:24.680 --> 04:25.680
XML

04:25.680 --> 04:27.680
ATDP Request

04:27.680 --> 04:30.680
就是你去留一个对象

04:30.680 --> 04:33.680
就可以去完成网络请求了

04:33.680 --> 04:35.680
那么一会我们就会学习这个玩意

04:35.680 --> 04:38.680
那么简称为XHR

04:38.680 --> 04:40.680
这个玩意就简写吧

04:40.680 --> 04:43.680
XHR

04:43.680 --> 04:44.680
所以这套API

04:44.680 --> 04:47.680
称之为XHR API

04:47.680 --> 04:50.680
但是这套API已经比较古老了

04:50.680 --> 04:52.680
这个套API有诸多的缺陷

04:52.680 --> 04:55.680
因为在用起来不是很方便

04:55.680 --> 04:57.680
当然还有一些别的原因的

04:57.680 --> 04:59.680
在H5和ES6发布之后

04:59.680 --> 05:00.680
它就产生了一套

05:00.680 --> 05:03.680
更加完善更加舒服的API

05:03.680 --> 05:05.680
也是我们这些课要学习的

05:05.680 --> 05:06.680
那么这套API

05:06.680 --> 05:09.680
主要使用一个废起函数来实现的

05:09.680 --> 05:12.680
那么这套API又称之为废起API

05:12.680 --> 05:14.680
无论是你过去的老办法

05:14.680 --> 05:16.680
还是这个废起新的废起API

05:16.680 --> 05:18.680
它们都是实现阿迪克斯的技术手段

05:18.680 --> 05:20.680
只是API还不一样而已

05:20.680 --> 05:22.680
它其实都叫阿迪克斯

05:22.680 --> 05:23.680
不是说有些人

05:23.680 --> 05:24.680
有些同学可能不知道

05:24.680 --> 05:26.680
在哪里去看了一些别的博客

05:26.680 --> 05:27.680
我跟你们说

05:27.680 --> 05:29.680
少去看了一些乱七八糟的博客

05:29.680 --> 05:31.680
给你们关注了很多错误的

05:31.680 --> 05:33.680
或者是不准确的一些概念

05:33.680 --> 05:35.680
说现在阿迪克斯已经弃用了

05:35.680 --> 05:36.680
我们现在用的是废起

05:36.680 --> 05:38.680
但简直是乱说

05:38.680 --> 05:40.680
阿迪克斯它是一套技术理念

05:40.680 --> 05:42.680
就是把那个

05:42.680 --> 05:44.680
网络请求的能力开放给介石

05:44.680 --> 05:46.680
就这么一套东西

05:46.680 --> 05:49.680
它用什么样的API其实都无所谓的

05:49.680 --> 05:52.680
它只要能够实现同样的效果就可以了

05:52.680 --> 05:55.680
那么这些可能我们两个都会学习

05:55.680 --> 05:57.680
因为你们以后到公司里边去

05:57.680 --> 05:58.680
我也不清楚

05:58.680 --> 05:59.680
你如果说你用的是一些

05:59.680 --> 06:01.680
比较老旧的项目的话

06:01.680 --> 06:03.680
可能会用的是一些老旧的API

06:03.680 --> 06:05.680
就是这种格式的

06:05.680 --> 06:06.680
早期的

06:06.680 --> 06:08.680
一些新的项目里边

06:08.680 --> 06:10.680
肯定是全线都使用了这套API了

06:10.680 --> 06:12.680
两个都要学习

06:12.680 --> 06:13.680
就是并不复杂

06:13.680 --> 06:14.680
你看这个代码才多少

06:14.680 --> 06:15.680
就这么的代码

06:15.680 --> 06:17.680
它不像我们学标准库

06:17.680 --> 06:19.680
学那个DOM BOM

06:19.680 --> 06:20.680
还有大队API

06:20.680 --> 06:21.680
还要去查文

06:21.680 --> 06:22.680
这又是冒查的

06:22.680 --> 06:23.680
就这个玩意

06:23.680 --> 06:24.680
其实你把这段代码

06:24.680 --> 06:25.680
一复制过去

06:25.680 --> 06:26.680
稍微改一改

06:26.680 --> 06:27.680
你都能够完成一个

06:27.680 --> 06:28.680
网络的请求了

06:28.680 --> 06:30.680
好 咱们马上来试一下吧

06:30.680 --> 06:31.680
特别简单

06:31.680 --> 06:34.680
我们这里去新建一个页面

06:34.680 --> 06:37.680
为什么我不去直接建一个介石来写

06:37.680 --> 06:38.680
是因为这样子的

06:38.680 --> 06:39.680
因为这套

06:39.680 --> 06:40.680
这些API

06:40.680 --> 06:41.680
无论是哪一个API

06:41.680 --> 06:44.680
它指的是浏览器环境里边的API

06:44.680 --> 06:46.680
就是你在漏的环境里边

06:46.680 --> 06:48.680
你就没法运行的代码

06:48.680 --> 06:49.680
你还直接爆错了

06:49.680 --> 06:50.680
车子什么玩意这是

06:50.680 --> 06:51.680
不认识的

06:51.680 --> 06:53.680
这是在浏览器环境里面才用的

06:53.680 --> 06:55.680
当然你再去新建个页面

06:55.680 --> 06:56.680
然后去引入这个介石

06:56.680 --> 06:57.680
也是可以的

06:57.680 --> 06:59.680
我这里就直接新建个页面了吧

06:59.680 --> 07:00.680
demo1

07:02.680 --> 07:03.680
把这个介石

07:03.680 --> 07:04.680
扣皮一下

07:05.680 --> 07:07.680
把这个介石粘掉吧

07:07.680 --> 07:12.460
好 我们在页面上去

07:12.460 --> 07:13.460
创建一个页面

07:13.460 --> 07:16.460
这页面里边我们去写一段介石

07:16.460 --> 07:18.460
当然你也可以去写到介石文件里面

07:18.460 --> 07:19.460
都无所谓

07:19.460 --> 07:20.460
反正就是一段介石代

07:20.460 --> 07:21.460
它有什么特别的

07:21.460 --> 07:22.460
没有什么特别的

07:22.460 --> 07:24.460
运行到的段代

07:24.460 --> 07:26.460
它就会发送到网络的请求

07:26.460 --> 07:28.460
我来解释一下

07:28.460 --> 07:30.460
首先解释一下这个老的API

07:30.460 --> 07:31.460
非常地简单

07:31.460 --> 07:32.460
来看吧

07:34.460 --> 07:36.460
这里是首先第1步

07:36.460 --> 07:38.460
创建一个

07:38.460 --> 07:39.460
通过一个构造函数

07:39.460 --> 07:42.460
就是XHR这个构造函数

07:42.460 --> 07:45.460
来创建一个对象

07:45.460 --> 07:46.460
对象

07:46.460 --> 07:47.460
就是一个对象而已

07:47.460 --> 07:48.460
你不要把它想复杂了

07:48.460 --> 07:50.460
就创建一个对象

07:50.460 --> 07:51.460
创建对象的时候

07:51.460 --> 07:52.460
之后

07:52.460 --> 07:53.460
对象里面有一个事件

07:53.460 --> 07:56.460
叫做unready state change

07:56.460 --> 07:57.460
它这个地方

07:57.460 --> 07:59.460
没有使用妥妨的名法

07:59.460 --> 08:01.460
所以说你自己看一下

08:01.460 --> 08:02.460
un 当什么的时候

08:02.460 --> 08:05.460
ready state change

08:05.460 --> 08:07.460
对这么一个事件

08:07.460 --> 08:08.460
这个事件

08:08.460 --> 08:09.460
给它复制为一个函数

08:09.460 --> 08:11.460
有点像动物的那个意思

08:11.460 --> 08:13.460
当什么时候发生的时候

08:13.460 --> 08:14.460
当某件事发生的时候

08:14.460 --> 08:16.460
它会运行这个函数

08:16.460 --> 08:17.460
这个函数

08:17.460 --> 08:18.460
我们先放一边

08:18.460 --> 08:19.460
我们一会再说

08:19.460 --> 08:20.460
这里给它注册一个事件

08:20.460 --> 08:21.460
一会我再说这个事件

08:21.460 --> 08:23.460
什么时候会运行

08:23.460 --> 08:24.460
然后接下来

08:24.460 --> 08:26.460
你就要准备发送网络请求了

08:26.460 --> 08:27.460
那么这个时候

08:27.460 --> 08:28.460
有没有发送网络请求

08:28.460 --> 08:29.460
还没有

08:29.460 --> 08:30.460
那么接下来

08:30.460 --> 08:32.460
这句话是

08:32.460 --> 08:34.460
去设置一下请求头

08:34.460 --> 08:35.460
这是一会

08:35.460 --> 08:37.460
我要发送网络请求的时候

08:37.460 --> 08:39.460
有没有什么头部

08:39.460 --> 08:40.460
因为我们知道

08:40.460 --> 08:42.460
请求的时候不是要设置头部吗

08:42.460 --> 08:43.460
当然要看情况

08:43.460 --> 08:44.460
要看一个接客文档

08:44.460 --> 08:45.460
里面怎么说的

08:45.460 --> 08:46.460
需要设置头部

08:46.460 --> 08:47.460
于设置头部

08:47.460 --> 08:48.460
有的时候

08:48.460 --> 08:50.460
请求比方说像这个地方

08:50.460 --> 08:51.460
请求的时候

08:51.460 --> 08:52.460
不是不会去设置

08:52.460 --> 08:53.460
于这么一个头部吗

08:53.460 --> 08:54.460
你看

08:55.460 --> 08:56.460
对吧

08:56.460 --> 08:57.460
如果说需要设置头部的话

08:57.460 --> 08:58.460
你就写上这么一句话

08:58.460 --> 08:59.460
设置请求头

08:59.460 --> 09:01.460
请求头的建置位

09:01.460 --> 09:02.460
建和直

09:02.460 --> 09:03.460
没什么好说的

09:03.460 --> 09:05.460
就通过这个方法去设置就完事了

09:05.460 --> 09:06.460
你要设置其他的请求头

09:06.460 --> 09:07.460
你继续设置

09:07.460 --> 09:09.460
它可以运行很多次的

09:09.460 --> 09:10.460
你运行一次

09:10.460 --> 09:12.460
它就设置了一个请求头

09:12.460 --> 09:14.460
当然如说你没有什么

09:14.460 --> 09:15.460
额外的请求头

09:15.460 --> 09:16.460
需要设置的话

09:16.460 --> 09:17.460
你把注射掉就完事了

09:17.460 --> 09:18.460
你不需要这句话

09:18.460 --> 09:19.460
三个就完事了

09:20.460 --> 09:21.460
那么到现在

09:21.460 --> 09:22.460
请求有没有发送了

09:22.460 --> 09:23.460
还没有

09:23.460 --> 09:24.460
因为你要发送请求

09:24.460 --> 09:25.460
你不得告诉他

09:25.460 --> 09:26.460
第一个就是

09:26.460 --> 09:27.460
请求头

09:27.460 --> 09:28.460
确实请求头

09:29.460 --> 09:30.460
我这个代码好像

09:30.460 --> 09:31.460
这里写的有点问题

09:32.460 --> 09:33.460
这个请求头

09:33.460 --> 09:35.460
应该是在Open下面

09:35.460 --> 09:36.460
写到这

09:36.460 --> 09:38.460
应该写到这的

09:39.460 --> 09:40.460
这个请求头

09:40.460 --> 09:41.460
应该在这的

09:42.460 --> 09:43.460
我们要发送一个请求

09:43.460 --> 09:44.460
你想一想

09:44.460 --> 09:45.460
逻辑上来说

09:45.460 --> 09:46.460
你用Postman发送请求

09:46.460 --> 09:48.460
你是不是得填UIL地址

09:48.460 --> 09:49.460
你是不是得选择

09:49.460 --> 09:50.460
请求方法

09:50.460 --> 09:51.460
这是必须的

09:52.460 --> 09:53.460
要不要设置请求头

09:53.460 --> 09:54.460
都是额外的

09:54.460 --> 09:55.460
所以说这句话

09:55.460 --> 09:56.460
你是必须要调用的

09:57.460 --> 09:58.460
Open

09:58.460 --> 09:59.460
这是配置请求

09:59.460 --> 10:00.460
请求方法

10:00.460 --> 10:01.460
要用一个Gate请求

10:02.460 --> 10:03.460
请求什么地址呢

10:03.460 --> 10:04.460
我比方说

10:04.460 --> 10:06.460
就请求的是这个

10:06.460 --> 10:07.460
这个啥

10:08.460 --> 10:09.460
论文念一念吧

10:09.460 --> 10:10.460
就请求这个地址

10:12.460 --> 10:14.460
当然要写权

10:14.460 --> 10:15.460
前面的要写权

10:15.460 --> 10:16.460
前边写啥

10:16.460 --> 10:18.460
我这里写的是这个

10:18.460 --> 10:20.460
Local House 701

10:21.460 --> 10:22.460
你们不能写这个

10:22.460 --> 10:23.460
你们前面的

10:23.460 --> 10:24.460
请求地址

10:24.460 --> 10:25.460
你再写这个

10:26.460 --> 10:27.460
Study

10:27.460 --> 10:29.460
DoEdeo

10:29.460 --> 10:31.460
你得写这个东西

10:31.460 --> 10:32.460
就是这一部分

10:32.460 --> 10:34.460
你再把它替换成这个

10:34.460 --> 10:35.460
因为我现在

10:35.460 --> 10:36.460
为什么不替换成这个呢

10:36.460 --> 10:38.460
是因为我现在在授课期间

10:38.460 --> 10:40.460
这个服务器是我写的

10:40.460 --> 10:41.460
目前还在本地

10:41.460 --> 10:43.460
我还没有把它部署上去

10:43.460 --> 10:44.460
部署上去了过后

10:44.460 --> 10:45.460
就变成这个地址了

10:45.460 --> 10:46.460
所以你们那边

10:46.460 --> 10:47.460
看这个视频的时候

10:47.460 --> 10:49.460
你们要把它换成这个地址

10:49.460 --> 10:50.460
你用这个

10:50.460 --> 10:51.460
你肯定是请求不了的

10:51.460 --> 10:52.460
因为你那边本地

10:52.460 --> 10:53.460
这是本地对吧

10:53.460 --> 10:55.460
你本地都没有服务器程序

10:55.460 --> 10:56.460
所以说我这边

10:56.460 --> 10:57.460
服务器程序你看

10:57.460 --> 10:58.460
这边是开着的

10:58.460 --> 10:59.460
所以说我这边

10:59.460 --> 11:00.460
是可以请求的

11:00.460 --> 11:01.460
里面那边

11:01.460 --> 11:02.460
请求这个地址

11:02.460 --> 11:03.460
这就盖着请求

11:03.460 --> 11:04.460
去请求这个地址

11:04.460 --> 11:05.460
跟Pose麦有啥去变呢

11:05.460 --> 11:06.460
就把它变到代码里面

11:06.460 --> 11:07.460
对吧

11:07.460 --> 11:08.460
然后如果说

11:08.460 --> 11:09.460
你需要收拾什么请求

11:09.460 --> 11:10.460
就写到这

11:10.460 --> 11:11.460
就完了

11:11.460 --> 11:12.460
然后这里是

11:12.460 --> 11:13.460
这句话

11:13.460 --> 11:15.460
才是真正的去发送请求

11:15.460 --> 11:17.460
发送请求到服务器

11:17.460 --> 11:18.460
那么盖着请求

11:18.460 --> 11:19.460
它是这里

11:19.460 --> 11:21.460
这里边参数点的是什么

11:21.460 --> 11:23.460
点的是请求体

11:25.460 --> 11:26.460
就是你

11:26.460 --> 11:27.460
比方说你Pose请求

11:27.460 --> 11:29.460
是不是有请求体

11:29.460 --> 11:30.460
对吧

11:30.460 --> 11:31.460
你就把这个制服串

11:31.460 --> 11:33.460
这是个制服串

11:33.460 --> 11:34.460
你是不是就放到这

11:34.460 --> 11:35.460
对吧

11:35.460 --> 11:36.460
就完事了

11:36.460 --> 11:37.460
那如果说你是盖着请求

11:37.460 --> 11:38.460
没有请求体

11:38.460 --> 11:39.460
怎么办

11:39.460 --> 11:40.460
没有请求体就嫌辣了

11:40.460 --> 11:42.460
就这么简单

11:42.460 --> 11:43.460
又意思多说

11:43.460 --> 11:45.460
跟Pose麦道理是一样的

11:45.460 --> 11:46.460
配置好

11:46.460 --> 11:47.460
创建对象

11:47.460 --> 11:49.460
然后配置好请求

11:49.460 --> 11:50.460
UROD指请求方法

11:50.460 --> 11:51.460
然后发送请求体

11:51.460 --> 11:52.460
如果说

11:52.460 --> 11:53.460
需要收拾请求

11:53.460 --> 11:54.460
就写到这

11:54.460 --> 11:55.460
那么这一步

11:55.460 --> 11:57.460
才是真正的发送请求

11:57.460 --> 11:58.460
好

11:58.460 --> 11:59.460
咱们马上就来试一下

11:59.460 --> 12:00.460
看一下请求

12:00.460 --> 12:02.460
到底有没有发出去

12:02.460 --> 12:04.460
右键Open with left server

12:04.460 --> 12:06.460
这里一定要用left server

12:06.460 --> 12:07.460
去打开

12:07.460 --> 12:10.290
好

12:10.290 --> 12:11.290
那么现在

12:12.290 --> 12:13.290
打开我们的浏览器

12:19.780 --> 12:20.780
我们换个地址

12:20.780 --> 12:21.780
这个地址

12:21.780 --> 12:22.780
这个地址不要去请求

12:22.780 --> 12:23.780
这个地址不要去请求

12:23.780 --> 12:24.780
我们换个地址

12:24.780 --> 12:25.780
为什么呢

12:25.780 --> 12:26.780
这个是之后

12:26.780 --> 12:27.780
才能给你解释

12:27.780 --> 12:29.780
换别的地址吧

12:29.780 --> 12:30.780
比方说我们之前有一个

12:30.780 --> 12:32.780
什么王者荣耀英雄

12:32.780 --> 12:33.780
查询那个地址

12:33.780 --> 12:34.780
看一下啊

12:34.780 --> 12:35.780
结构那里边有

12:35.780 --> 12:38.730
进去看一下

12:40.730 --> 12:41.730
我的水呢

12:46.230 --> 12:49.380
其他结构

12:49.380 --> 12:51.380
这里边有一个

12:51.380 --> 12:53.380
王者荣耀英雄结构

12:53.380 --> 12:55.380
把路径复制一下

12:55.380 --> 12:57.380
换上这个地址吧

12:58.380 --> 12:59.380
保存

12:59.380 --> 13:00.380
那么接下来

13:00.380 --> 13:01.380
我们回到这边一面

13:01.380 --> 13:02.380
刷新

13:02.380 --> 13:03.380
空置还好像啥也没有

13:03.380 --> 13:04.380
对吧

13:04.380 --> 13:05.380
什么啥也没有

13:05.380 --> 13:06.380
因为我根本就

13:06.380 --> 13:07.380
压根就没有输出

13:07.380 --> 13:08.380
没有做任何输出

13:08.380 --> 13:09.380
所以说空置还打

13:09.380 --> 13:10.380
当然没有

13:10.380 --> 13:11.380
你要看什么

13:11.380 --> 13:12.380
看network

13:12.380 --> 13:13.380
好

13:13.380 --> 13:14.380
我们这里选择

13:14.380 --> 13:15.380
选择这里

13:15.380 --> 13:16.380
所有的

13:16.380 --> 13:18.380
这个网列当所有的请求

13:18.380 --> 13:19.380
那么网列当所有的请求

13:19.380 --> 13:20.380
我之前也说过

13:20.380 --> 13:21.380
这两个东西是不用看的

13:21.380 --> 13:22.380
这两个东西

13:22.380 --> 13:23.380
这两个东西

13:23.380 --> 13:24.380
是跟

13:24.380 --> 13:26.380
是有些是

13:26.380 --> 13:27.380
咱们安装的

13:27.380 --> 13:28.380
粒子的插件

13:28.380 --> 13:29.380
给搞出来的

13:29.380 --> 13:30.380
有些是流量器

13:30.380 --> 13:31.380
为了调试

13:31.380 --> 13:32.380
给搞出来的

13:32.380 --> 13:33.380
这两个东西

13:33.380 --> 13:34.380
发现这个页面中

13:34.380 --> 13:35.380
发出了两个请求

13:35.380 --> 13:37.380
流量器发出了两个请求

13:37.380 --> 13:38.380
那么第一个请求

13:38.380 --> 13:39.380
我们当然知道

13:39.380 --> 13:40.380
它是请求页面

13:40.380 --> 13:41.380
对吧

13:41.380 --> 13:43.380
这是我们之前讲过的

13:43.380 --> 13:44.380
流量器的页面处理流程

13:44.380 --> 13:45.380
对吧

13:45.380 --> 13:47.380
它是捐请求页面

13:47.380 --> 13:48.380
拿到页面文档之后

13:48.380 --> 13:50.380
有CSS就拿CSS

13:50.380 --> 13:51.380
但我这个页面

13:51.380 --> 13:52.380
里面没有CSS

13:52.380 --> 13:54.380
有图片就拿图片

13:54.380 --> 13:56.380
有介石就拿介石

13:56.380 --> 13:58.380
那么我这里都没有

13:58.380 --> 13:59.380
那么就直接

13:59.380 --> 14:00.380
因为我这个介石

14:00.380 --> 14:01.380
是直接写到页面里面去了

14:01.380 --> 14:03.380
那么直接写介石代码

14:03.380 --> 14:05.380
执行介石代码的过程中

14:05.380 --> 14:07.380
是不是就遇到了我们那个代码

14:08.380 --> 14:10.380
在最开始执行介石代码的时候

14:10.380 --> 14:12.380
就遇到我们那个代码了

14:12.380 --> 14:13.380
那么运行运行运行

14:13.380 --> 14:14.380
运行到哪句话

14:14.380 --> 14:16.380
27行的时候

14:16.380 --> 14:17.380
它这个时候

14:17.380 --> 14:18.380
它就会发送一个请求

14:18.380 --> 14:19.380
你看这里

14:20.380 --> 14:21.380
是不是就发送了一个请求

14:21.380 --> 14:22.380
那么这个请求

14:22.380 --> 14:23.380
就是一个

14:23.380 --> 14:24.380
这个是请求

14:24.380 --> 14:25.380
看一下

14:25.380 --> 14:27.380
请求是不是这个地址

14:27.380 --> 14:28.380
然后服务器有没有响应

14:28.380 --> 14:29.380
你看服务器响应了

14:29.380 --> 14:30.380
对吧

14:30.380 --> 14:32.380
把响应的结果

14:32.380 --> 14:34.380
好看一点在这边

14:34.380 --> 14:35.380
你看

14:35.380 --> 14:36.380
是王志龙的英雄数据

14:36.380 --> 14:37.380
就全部在这了

14:38.380 --> 14:39.380
懂了意思吗

14:39.380 --> 14:40.380
那么至于说

14:40.380 --> 14:42.380
你拿这个到这个英雄数据

14:42.380 --> 14:44.380
你要去干什么

14:44.380 --> 14:46.380
那么这里就是要一个问题

14:46.380 --> 14:48.380
你怎么在代码里面

14:48.380 --> 14:50.380
拿到这个英雄数据

14:50.380 --> 14:51.380
这个时候

14:51.380 --> 14:53.380
就需要看这个函数了

14:54.380 --> 14:55.380
这个函数

14:55.380 --> 14:57.380
它就是当发生某件事的时候

14:57.380 --> 14:59.380
它会运行这个函数

15:00.380 --> 15:02.380
那发生什么时候

15:02.380 --> 15:04.380
事的时候它会运行这个函数呢

15:04.380 --> 15:06.380
它有很多种情况

15:06.380 --> 15:08.380
有这么几种情况

15:08.380 --> 15:09.380
它会运行这个函数

15:09.380 --> 15:11.380
第一种情况是

15:11.380 --> 15:13.380
刚刚创建好了这个对象

15:13.380 --> 15:15.380
但是还没有配置请求

15:15.380 --> 15:16.380
没有调用

15:16.380 --> 15:17.380
配置你就是Open方法

15:17.380 --> 15:18.380
还没有调用Open方法

15:18.380 --> 15:20.380
它会运行这个函数

15:20.380 --> 15:21.380
不过这种情况

15:21.380 --> 15:22.380
现在浏览器好像

15:22.380 --> 15:24.380
我看好多浏览器都没有

15:24.380 --> 15:25.380
它又没有明说

15:25.380 --> 15:27.380
但是这种情况好像是没有发生

15:27.380 --> 15:28.380
了解就行了吧

15:28.380 --> 15:30.380
我们也不用去研究那么细

15:30.380 --> 15:31.380
那么接下来就是

15:31.380 --> 15:33.380
Open方法调用之后

15:33.380 --> 15:34.380
Open方法调用之后

15:34.380 --> 15:38.380
它也会运行这个函数

15:38.380 --> 15:40.380
生的方法被调用之后

15:40.380 --> 15:41.380
就发动请求调用之后

15:41.380 --> 15:43.380
它也会运行这个函数

15:44.380 --> 15:45.380
那么接下来就是

15:45.380 --> 15:47.380
正在接收服务器的

15:47.380 --> 15:48.380
响应消息题

15:48.380 --> 15:49.380
那么这是什么意思

15:49.380 --> 15:50.380
事时候呢

15:50.380 --> 15:53.380
就是我的请求已经发过去了

15:53.380 --> 15:55.380
我的请求发过去了

15:55.380 --> 15:57.380
那么服务器在响应的时候

15:57.380 --> 15:58.380
我会响应很多东西

15:58.380 --> 16:00.380
一个是响应的

16:00.380 --> 16:01.380
响应

16:01.380 --> 16:03.380
你看 响应行

16:03.380 --> 16:05.380
然后是响应头

16:05.380 --> 16:06.380
对吧

16:06.380 --> 16:08.380
这是服务器的响应头

16:08.380 --> 16:09.380
就是接收完了

16:09.380 --> 16:12.380
服务器的响应头之后

16:12.380 --> 16:14.380
它就会运行这个函数

16:14.380 --> 16:17.380
它还没有接收服务器的响应题

16:17.380 --> 16:19.380
它只是把响应头接收完了

16:19.380 --> 16:20.380
你可以把服务器

16:20.380 --> 16:21.380
响应的结果

16:21.380 --> 16:22.380
整体结果想象成

16:22.380 --> 16:23.380
一道水流一样

16:23.380 --> 16:25.380
流到刻骨端

16:25.380 --> 16:26.380
那流的过程中是不是

16:26.380 --> 16:27.380
它需要时间

16:27.380 --> 16:28.380
对吧

16:28.380 --> 16:31.380
先流过来的是响应行

16:31.380 --> 16:32.380
是这个行

16:32.380 --> 16:33.380
然后再流过来的

16:33.380 --> 16:34.380
慢慢流 慢慢流

16:34.380 --> 16:37.380
慢慢流 流过来的是这个响应题

16:37.380 --> 16:38.380
响应头

16:38.380 --> 16:40.380
然后响应头流完了之后

16:40.380 --> 16:42.380
再去流这个响应题

16:42.380 --> 16:46.380
那么当我们响应头流完之后

16:46.380 --> 16:47.380
流到刻骨端之后

16:47.380 --> 16:48.380
那么这个时候

16:48.380 --> 16:49.380
刻骨端就可以拿到

16:49.380 --> 16:51.380
响应头里面所有东西了

16:51.380 --> 16:52.380
那么这个时候

16:52.380 --> 16:55.380
也会触发这个函数的运行

16:55.380 --> 16:57.380
然后就是服务器的

16:57.380 --> 16:58.380
所有的响应内容

16:58.380 --> 16:59.380
就包括响应题

16:59.380 --> 17:01.380
全部都流过来之后

17:01.380 --> 17:02.380
它就会一物会触发

17:02.380 --> 17:03.380
这个函数的运行

17:03.380 --> 17:04.380
那这个函数

17:04.380 --> 17:06.380
它会反复的触发运行

17:06.380 --> 17:07.380
那么我们怎么知道

17:07.380 --> 17:09.380
是什么情况下运行的

17:09.380 --> 17:10.380
这个函数呢

17:10.380 --> 17:12.380
通过这个属性就可以知道

17:12.380 --> 17:13.380
这个对象有一个属性

17:13.380 --> 17:14.380
叫radius state

17:14.380 --> 17:16.380
就是准备的状态

17:16.380 --> 17:17.380
它是一个数字

17:17.380 --> 17:18.380
这个数字就对应到这

17:18.380 --> 17:19.380
1234

17:19.380 --> 17:21.380
那么我们来再打印一下

17:22.380 --> 17:25.380
radius hr

17:25.380 --> 17:28.140
radius state

17:28.140 --> 17:29.140
好保存

17:29.140 --> 17:31.140
当我们控制台里面的训练会发现

17:31.140 --> 17:32.140
刷新

17:32.140 --> 17:35.140
打印了一个1234

17:35.140 --> 17:36.140
虽然很快

17:36.140 --> 17:37.140
但是呢

17:37.140 --> 17:39.140
实际上它是需要一段时间

17:39.140 --> 17:40.140
才打印出来的

17:40.140 --> 17:41.140
因为我们这里的

17:41.140 --> 17:42.140
是在本地

17:42.140 --> 17:43.140
网络通信的速度很快

17:43.140 --> 17:45.140
1234就打印出来了

17:45.140 --> 17:46.140
说明一啥呢

17:46.140 --> 17:48.140
说明这个函数运行了四次

17:48.140 --> 17:49.140
对吧

17:49.140 --> 17:50.140
那么我们知道

17:50.140 --> 17:51.140
每一个数字代表到含义

17:51.140 --> 17:53.140
这个有可能面试题的时候

17:53.140 --> 17:54.140
会考

17:54.140 --> 17:55.140
1234

17:55.140 --> 17:56.140
它代表什么含义

17:56.140 --> 17:58.140
如果说考这个的话

17:58.140 --> 18:00.140
现在考的几率也不高了

18:00.140 --> 18:02.140
因为这种API已经很少使用了

18:02.140 --> 18:04.140
只在一些旧的项目里面使用

18:04.140 --> 18:06.140
我们一般都用新的废弃API

18:06.140 --> 18:08.140
但是我们还是要了解

18:08.140 --> 18:09.140
那么在这里面

18:09.140 --> 18:10.140
我们通常

18:10.140 --> 18:12.140
并不太关心这些东西

18:12.140 --> 18:13.140
我们比较关心的就是

18:13.140 --> 18:15.140
因为我要拿服务器的响应结果

18:15.140 --> 18:16.140
对吧

18:16.140 --> 18:17.140
那我比较关心的就是

18:17.140 --> 18:20.140
我怎么去拿服务器的响应结果

18:20.140 --> 18:22.140
那我这里就可以做个判断的

18:22.140 --> 18:24.140
ReadyStats等于什么呢等于4

18:24.140 --> 18:25.140
说明啥

18:25.140 --> 18:27.140
说明服务器的响应结果

18:27.140 --> 18:28.140
已经全部拿到了

18:28.140 --> 18:29.140
我们直接输出一下

18:29.140 --> 18:32.140
服务器的响应结果

18:32.140 --> 18:35.140
已经全部收到

18:35.140 --> 18:36.140
好保存

18:36.140 --> 18:37.140
你看服务器的响应结果

18:37.140 --> 18:40.140
已经全部收到了

18:40.140 --> 18:41.140
在这里面

18:41.140 --> 18:42.140
我们也可以看到

18:42.140 --> 18:43.140
服务器是有响应的

18:43.140 --> 18:44.140
对吧

18:44.140 --> 18:45.140
这就顺便说一下

18:45.140 --> 18:46.140
在我们这个network

18:46.140 --> 18:47.140
这个调试工具里面

18:47.140 --> 18:48.140
你可以

18:48.140 --> 18:49.140
这里可以选择分类

18:49.140 --> 18:51.140
就是它传输的GS

18:51.140 --> 18:52.140
传输的CSS

18:52.140 --> 18:54.140
可以分类来查看

18:54.140 --> 18:56.140
网络请求

18:56.140 --> 18:57.140
那么我们这里

18:57.140 --> 18:59.140
你看这里有一个费期

18:59.140 --> 19:01.140
或者是XHR

19:01.140 --> 19:02.140
对吧

19:02.140 --> 19:03.140
这是不是阿迦克斯的

19:03.140 --> 19:04.140
两套API

19:04.140 --> 19:05.140
对不对

19:05.140 --> 19:06.140
那么通过这套

19:06.140 --> 19:07.140
两套API发送的网络请求

19:07.140 --> 19:08.140
你点一下

19:08.140 --> 19:09.140
你会发现只有一个

19:09.140 --> 19:10.140
他给你筛选了一下

19:10.140 --> 19:11.140
其他的就可以过滤掉了

19:11.140 --> 19:12.140
欧的话

19:12.140 --> 19:13.140
就是查看

19:13.140 --> 19:14.140
所有的发送的请求

19:14.140 --> 19:15.140
这个只看发送了

19:15.140 --> 19:17.140
阿迦克斯请求

19:17.140 --> 19:18.140
你看

19:18.140 --> 19:19.140
这就是我们刚才发送的请求

19:21.140 --> 19:23.140
其实那你也可以在工具里面

19:23.140 --> 19:24.140
调这个

19:24.140 --> 19:26.140
这里有个nose 30

19:26.140 --> 19:27.140
这是表示那个

19:29.140 --> 19:30.140
这个单词

19:30.140 --> 19:31.140
我怎么翻译了这个单词

19:33.140 --> 19:36.140
叫做调节法门

19:36.140 --> 19:37.140
就是它可以像

19:37.140 --> 19:38.140
水管水浓头一样

19:38.140 --> 19:40.140
调节它的水流的

19:40.140 --> 19:41.140
那么这个玩意是什么呢

19:41.140 --> 19:43.140
你默认是

19:43.140 --> 19:45.140
选中的是没有调节水流

19:45.140 --> 19:47.140
那么你还可以做更多的调节

19:47.140 --> 19:48.140
比方说

19:48.140 --> 19:49.140
你可以调节这个水流大小

19:49.140 --> 19:51.140
相当于是模拟网速

19:51.140 --> 19:52.140
当然只是模拟

19:52.140 --> 19:54.140
它并不会真正的影响你的网速

19:54.140 --> 19:56.140
模拟网速

19:56.140 --> 19:58.140
这是一个快的3G网络

19:58.140 --> 20:00.140
慢的3G网络

20:00.140 --> 20:01.140
还有直接离线

20:01.140 --> 20:02.140
就是没有网络

20:02.140 --> 20:03.140
你可以模拟

20:03.140 --> 20:04.140
比方说

20:04.140 --> 20:05.140
这里把模拟成3G

20:05.140 --> 20:07.140
snow3G表示

20:07.140 --> 20:08.140
慢的3G网络

20:08.140 --> 20:09.140
好

20:09.140 --> 20:10.140
我们接下来到控制台

20:10.140 --> 20:11.140
再统一刷新

20:11.140 --> 20:12.140
刷新你看

20:12.140 --> 20:14.140
传输页面的速度都很慢

20:14.140 --> 20:16.140
你看阿加克斯是不是等了一会

20:16.140 --> 20:18.140
才拿到服务器的响应结果

20:18.140 --> 20:20.140
这样子可以模拟网络慢的情况

20:20.140 --> 20:22.140
是什么情况

20:22.140 --> 20:24.140
其实同学们在开发的过程中

20:24.140 --> 20:26.140
把阿加克斯这一块

20:26.140 --> 20:28.140
一定要想象成慢

20:28.140 --> 20:29.140
脑袋里面

20:29.140 --> 20:31.140
虽然它有的时候确实很快

20:31.140 --> 20:32.140
响应结果一下就出来了

20:32.140 --> 20:33.140
但是你一定要

20:33.140 --> 20:35.140
把它想象成为很慢的

20:35.140 --> 20:37.140
我这里都有说

20:37.140 --> 20:39.140
特别注意的是

20:39.140 --> 20:41.140
你可以把每一次的网络

20:41.140 --> 20:43.140
传输时间想象的夸张一点

20:43.140 --> 20:45.140
每一次请求和响应都要经过一年

20:45.140 --> 20:47.140
才能完成

20:47.140 --> 20:48.140
这样子做呢

20:48.140 --> 20:49.140
主要的目的

20:49.140 --> 20:51.140
是为了帮助你更好的理解

20:51.140 --> 20:53.140
网络是异步的

20:53.140 --> 20:54.140
为什么呢

20:54.140 --> 20:55.140
你想一想

20:55.140 --> 20:56.140
同学们想一想

20:56.140 --> 20:59.700
他为什么要用这种方式来写

20:59.700 --> 21:01.700
这种方式来写到

21:01.700 --> 21:02.700
写到事件里面

21:02.700 --> 21:04.700
他为什么要这样去设计的

21:04.700 --> 21:05.700
他本来不用这种设计

21:05.700 --> 21:06.700
不要这东西

21:06.700 --> 21:08.700
我配置请求

21:08.700 --> 21:09.700
像Postman一样

21:09.700 --> 21:10.700
配置请求

21:10.700 --> 21:11.700
URO地址方法

21:11.700 --> 21:12.700
然后发动一个请求

21:12.700 --> 21:13.700
发动请求完了之后

21:13.700 --> 21:14.700
你能不能我在这里

21:14.700 --> 21:16.700
就直接能够拿到

21:16.700 --> 21:17.700
服务器的响应结果

21:17.700 --> 21:18.700
多好啊对不对

21:20.700 --> 21:21.700
拿服务器的响应结果

21:21.700 --> 21:22.700
通过这个属性

21:22.700 --> 21:23.700
通过这个属性

21:25.700 --> 21:26.700
刚才忘了演示了

21:26.700 --> 21:27.700
我们再试一下吧

21:30.780 --> 21:31.780
这些输出

21:31.780 --> 21:33.780
如果说要拿服务器的响应头的话

21:33.780 --> 21:35.780
通过这个方法

21:35.780 --> 21:37.780
响应头的名字

21:37.780 --> 21:38.780
建筑队

21:38.780 --> 21:39.780
给它一个键

21:39.780 --> 21:40.780
它得到一个值

21:40.780 --> 21:41.780
这都比较简单

21:41.780 --> 21:43.780
我们去拿服务器的响应结果

21:44.780 --> 21:45.780
这是服务器给我们的响应结果

21:45.780 --> 21:46.780
保存看一下

21:48.780 --> 21:49.780
就拿到了

21:49.780 --> 21:50.780
是一个完整的制服串

21:50.780 --> 21:51.780
对吧

21:51.780 --> 21:52.780
拿到的是一个制服串

21:52.780 --> 21:53.780
很长的一个制服串

21:53.780 --> 21:54.780
当然这个制服串

21:54.780 --> 21:55.780
我们不是很好用

21:55.780 --> 21:56.780
我们一般来说

21:56.780 --> 21:59.780
会把它解析成为节省

21:59.780 --> 22:01.780
就是我们把它解析一下吧

22:01.780 --> 22:03.780
这个玩意就跟网络无关了

22:03.780 --> 22:04.780
就是服务器

22:04.780 --> 22:05.780
已经把一个制服串给你了

22:05.780 --> 22:06.780
至于你要怎么去用

22:06.780 --> 22:08.780
就是前端的事情了

22:08.780 --> 22:10.780
那么我们可以用Postman

22:10.780 --> 22:12.780
把服务器的响应结果拿到

22:12.780 --> 22:14.780
它反回不是一个对象吗

22:14.780 --> 22:15.780
对对

22:20.720 --> 22:21.720
保存

22:21.720 --> 22:23.720
你看是否拿到服务器的响应结果了

22:24.720 --> 22:25.720
对吧

22:25.720 --> 22:26.720
那你至于说拿到对象之后

22:26.720 --> 22:28.720
你要干嘛拿随便你

22:28.720 --> 22:30.720
比方说你拿到一个属性Data

22:30.720 --> 22:32.720
它是一个数组

22:32.720 --> 22:34.720
包含所有的英雄

22:34.720 --> 22:35.720
那比方说我就可以这么做

22:35.720 --> 22:38.720
拿到一个Harrows

22:38.720 --> 22:39.720
OB戒戒Data

22:39.720 --> 22:41.720
我们就循环这个数组

22:41.720 --> 22:42.720
对吧

22:42.720 --> 22:43.720
用ForObe循环

22:44.720 --> 22:45.720
循环这个数组

22:45.720 --> 22:46.720
然后每次循环

22:46.720 --> 22:49.720
我就创建一个Li

22:49.720 --> 22:51.720
Documents

22:51.720 --> 22:53.720
跟那个网络就没有关系了

22:53.720 --> 22:54.720
就知道吧

22:54.720 --> 22:55.720
是不是就没有关系了

22:56.720 --> 22:57.720
你们之前不是做过

22:57.720 --> 22:59.720
英雄联盟的

23:00.720 --> 23:03.720
王者荣耀的英雄查询

23:03.720 --> 23:04.720
效果对吧

23:04.720 --> 23:06.720
只是你没有做那个网络

23:06.720 --> 23:07.720
通信的一块

23:07.720 --> 23:08.720
你拿到这个数组之后

23:08.720 --> 23:09.720
你是不是

23:09.720 --> 23:10.720
剩下的事情都可以玩了

23:10.720 --> 23:11.720
对不对

23:11.720 --> 23:12.720
我们这里

23:12.720 --> 23:14.720
我就把英雄的名字

23:15.720 --> 23:19.610
然后把Li加到

23:19.610 --> 23:21.610
页面上的一个EL里面去

23:21.610 --> 23:22.610
就完事了

23:23.610 --> 23:24.610
找到这个EL

23:24.610 --> 23:29.580
现在你们学了ES6的

23:29.580 --> 23:33.580
应该是用ES6的定义辩量的方式

23:34.580 --> 23:39.430
把这个加到EL里面去

23:41.430 --> 23:42.430
保存

23:42.430 --> 23:44.430
页面上不就全部有了吗

23:44.430 --> 23:45.430
英雄都有了

23:46.430 --> 23:47.430
就这么意思

23:47.430 --> 23:48.430
就是服务其他指负者

23:48.430 --> 23:49.430
网络通信

23:49.430 --> 23:50.430
阿迦克斯这一块

23:50.430 --> 23:51.430
他指负者

23:51.430 --> 23:52.430
发送寻求

23:52.430 --> 23:53.430
拿到响应结果

23:53.430 --> 23:54.430
拿到响应结果之后

23:54.430 --> 23:55.430
你挨做啥做啥

23:55.430 --> 23:57.430
根据你自己的需求

23:57.430 --> 23:59.430
你自己去完成

24:00.430 --> 24:01.430
最后明白了吧

24:01.430 --> 24:02.430
好

24:02.430 --> 24:03.430
我们接下来解释一下

24:03.430 --> 24:05.430
为什么他要用这种模式

24:06.430 --> 24:07.430
他为什么不用这种模式呢

24:07.430 --> 24:09.430
就是我发送一个网络寻求

24:09.430 --> 24:10.430
接下来

24:10.430 --> 24:11.430
我就可以直接拿到这个响应结果

24:11.430 --> 24:12.430
那多好啊

24:14.430 --> 24:15.430
你想一想

24:15.430 --> 24:16.430
他为什么不用这种模式

24:16.430 --> 24:18.430
如果说他用这种模式

24:18.430 --> 24:19.430
他会出现一个什么样的结果

24:19.430 --> 24:20.430
我跟你们说

24:20.430 --> 24:21.430
网络这一块

24:21.430 --> 24:22.430
你一定要把他想象的夸张一点

24:22.430 --> 24:23.430
便于理解

24:25.430 --> 24:27.430
这一次寻求发送出去

24:27.430 --> 24:29.430
如果说他需要在这里

24:29.430 --> 24:31.430
拿到服务其的响应结果

24:31.430 --> 24:33.430
那是不是在这里卡住

24:34.430 --> 24:35.430
因为发送网络寻求

24:35.430 --> 24:36.430
得要时间啊

24:36.430 --> 24:37.430
网络传说要时间的

24:37.430 --> 24:39.430
我让你想象的夸张一点

24:39.430 --> 24:40.430
比方说网络不好

24:40.430 --> 24:41.430
他要一年

24:42.430 --> 24:43.430
才能拿到服务其的响应结果

24:43.430 --> 24:45.430
那代码是不是在这里卡一年

24:45.430 --> 24:46.430
那就意味着

24:46.430 --> 24:48.430
流量器你啥也别干了

24:48.430 --> 24:49.430
等着吧

24:50.430 --> 24:51.430
用户里别操作了

24:51.430 --> 24:52.430
我们就等着

24:52.430 --> 24:53.430
因为我戴介石弹码

24:53.430 --> 24:54.430
还没有执行完

24:54.430 --> 24:55.430
你必须要等着

24:55.430 --> 24:56.430
介石弹码的执行

24:56.430 --> 24:59.430
跟那个流量器的渲染是互赤的

25:01.430 --> 25:02.430
同一个人干的

25:02.430 --> 25:03.430
我在执行介石弹码

25:03.430 --> 25:04.430
流量器就必须要等着

25:04.430 --> 25:05.430
卡住

25:05.430 --> 25:06.430
卡死

25:06.430 --> 25:08.430
然后用户在里不要操作了

25:08.430 --> 25:09.430
后面戴码

25:09.430 --> 25:10.430
后面一些无关的戴码里

25:10.430 --> 25:11.430
不要运行了

25:11.430 --> 25:12.430
等一年

25:12.430 --> 25:13.430
一年之后

25:13.430 --> 25:15.430
我拿到服务其响应结果了

25:15.430 --> 25:16.430
然后呢

25:16.430 --> 25:17.430
再来操作

25:17.430 --> 25:19.430
这个是不是太夸张了一点

25:20.430 --> 25:21.430
就有点类似于什么

25:21.430 --> 25:23.430
我们用set timeout的时候

25:23.430 --> 25:25.430
他为什么不这样子设计呢

25:25.430 --> 25:27.430
等待一秒钟就好了呀

25:27.430 --> 25:28.430
等一秒钟过后

25:28.430 --> 25:29.430
我再去运行

25:29.430 --> 25:30.430
后面戴码多好啊

25:30.430 --> 25:31.430
你不用写回调寒书了

25:31.430 --> 25:32.430
多好

25:32.430 --> 25:33.430
他为什么不这样设计

25:33.430 --> 25:34.430
就是因为他怕

25:34.430 --> 25:36.430
戴码在这里卡住

25:36.430 --> 25:37.430
导致了后续戴码

25:37.430 --> 25:39.430
根本就没法运行

25:39.430 --> 25:40.430
在那里干等

25:40.430 --> 25:41.430
所以说介石呢

25:41.430 --> 25:43.430
它是一个一步的语言

25:43.430 --> 25:44.430
他就是不用等

25:44.430 --> 25:45.430
一秒钟之后

25:45.430 --> 25:46.430
回过头来

25:46.430 --> 25:47.430
就做了执行这个寒书

25:47.430 --> 25:48.430
就完事了

25:48.430 --> 25:49.430
我后续戴码不影响

25:49.430 --> 25:51.430
继续往后执行

25:51.430 --> 25:53.430
绝过事件循环吧

25:53.430 --> 25:54.430
就什么意思

25:54.430 --> 25:55.430
他不用去等

25:55.430 --> 25:57.430
那么这里到底是一样的

25:57.430 --> 25:59.430
由于网络通信

25:59.430 --> 26:01.430
它是一个需要耗费大量

26:01.430 --> 26:03.430
时间的一个过程

26:03.430 --> 26:04.430
他不能在那里干等

26:04.430 --> 26:05.430
因此呢

26:05.430 --> 26:07.430
他把它设计成一步的

26:07.430 --> 26:08.430
就你后边戴码

26:08.430 --> 26:09.430
就这里

26:09.430 --> 26:11.430
这里是同步戴码对吧

26:11.430 --> 26:12.430
你发动网络行修

26:12.430 --> 26:13.430
我不等你

26:13.430 --> 26:14.430
我马上往后继续运行

26:14.430 --> 26:17.430
等你到某一个阶段之后

26:17.430 --> 26:19.430
我再去运行这个回调寒书

26:19.430 --> 26:21.430
它是用这种模式去运行的

26:21.430 --> 26:23.430
所以你要网络通信

26:23.430 --> 26:25.430
它是一步的

26:25.430 --> 26:27.430
懂了意思吧

26:27.430 --> 26:28.430
那么接下来

26:28.430 --> 26:31.430
这就是过去的那套老的一篇

26:31.430 --> 26:34.430
XHR一篇

26:34.430 --> 26:36.430
这是过去的那一套

26:36.430 --> 26:37.430
然后呢

26:37.430 --> 26:39.430
我们接下来要学习

26:39.430 --> 26:40.430
下一套一篇

26:40.430 --> 26:41.430
废邪一篇

26:41.430 --> 26:42.430
废邪一篇

26:42.430 --> 26:43.430
我就这里就不直接看这了

26:43.430 --> 26:45.430
不直接看这了

26:45.430 --> 26:47.430
我们直接在这里解释了

26:47.430 --> 26:50.940
这套一篇发动网络行修

26:50.940 --> 26:51.940
会更加的方便

26:51.940 --> 26:53.940
比发动我们这里还是一样

26:53.940 --> 26:55.940
创建一个介石代码

26:55.940 --> 26:57.940
我们现在同样的

26:57.940 --> 26:58.940
做一模一样的效果

26:58.940 --> 27:00.940
我要去发动一个网络行修

27:00.940 --> 27:02.940
然后实现这个一模一样的效率

27:02.940 --> 27:04.940
会发现代码会少很多

27:04.940 --> 27:06.940
怎么来发动行修呢

27:06.940 --> 27:07.940
它不用去创建什么对象

27:07.940 --> 27:09.940
不用去注册这个什么

27:09.940 --> 27:11.940
这些玩意儿

27:11.940 --> 27:13.940
这些那个回调

27:13.940 --> 27:15.940
它直接使用一个函数角废棋

27:15.940 --> 27:18.940
填写UAL地址

27:18.940 --> 27:20.940
UAL地址是它

27:20.940 --> 27:22.940
里面那边要把换成这个

27:22.940 --> 27:25.940
就把这个地址填过来

27:25.940 --> 27:27.940
这就发送了一个介石寝球过去了

27:27.940 --> 27:28.940
就已经发送了

27:28.940 --> 27:30.940
就这一句话就已经发过去了

27:30.940 --> 27:31.940
介石寝球

27:31.940 --> 27:33.940
因为它默认就是介石寝球

27:33.940 --> 27:34.940
好 咱们来试一下

27:34.940 --> 27:37.940
看一下寝球有没有发过去

27:37.940 --> 27:39.940
好 我们看Letsworth

27:39.940 --> 27:40.940
刷新

27:40.940 --> 27:41.940
你看 阿迦克斯这一块

27:41.940 --> 27:42.940
是不是有个寝球发过去了

27:43.940 --> 27:45.940
你看 之前要选你大蕊带

27:45.940 --> 27:47.940
现在是不是特别简洁

27:47.940 --> 27:49.940
好 那么接下来我来说一下

27:49.940 --> 27:52.940
我如何拿到服务器的响应结果呢

27:52.940 --> 27:56.940
这个函数 它返回的是一个Promise

27:56.940 --> 27:59.940
它返回的是一个Promise

27:59.940 --> 28:08.130
这个Promise什么时候完成呢

28:08.130 --> 28:16.130
当收到服务器的响应头之后

28:17.130 --> 28:19.130
Promise完成

28:20.130 --> 28:23.130
具有点类似于这里的3

28:24.130 --> 28:26.130
对吧 响应头我接受完了

28:26.130 --> 28:29.130
我即将接受响应体的时候

28:29.130 --> 28:31.130
那么Promise完成

28:31.130 --> 28:33.130
好 那么也就意味着

28:33.130 --> 28:35.130
我这里是不是可以写个Z

28:35.130 --> 28:38.130
对吧 当这个完成之后

28:39.130 --> 28:41.130
当服务器这一块完成之后

28:41.130 --> 28:42.130
我是不是可以

28:42.130 --> 28:44.130
那么这里我就输出一个

28:45.130 --> 28:52.130
以全部接收到服务器的响应头

28:52.130 --> 28:54.130
在这里

28:54.130 --> 28:56.130
我们打印一下

28:56.130 --> 28:58.130
刷新 你看 是不是打印了

28:58.130 --> 29:00.130
因为我这里网速很快

29:00.130 --> 29:02.130
如果你把网络调慢一点

29:03.130 --> 29:06.130
再来刷新 再转一转

29:06.130 --> 29:08.130
好 等待一会

29:08.130 --> 29:10.130
是不是收到所有的响应头了

29:10.130 --> 29:12.130
对不对

29:12.130 --> 29:13.130
拿到响应头

29:13.130 --> 29:15.130
也就意味着

29:15.130 --> 29:18.130
在这个地方也是可以拿到响应头的

29:18.130 --> 29:20.130
那怎么来拿这个响应头呢

29:20.130 --> 29:23.130
它完成之后会给你一个数据

29:23.130 --> 29:25.130
这个数据通常把命名为Response

29:25.130 --> 29:27.130
表示响应的 响应对象

29:27.130 --> 29:29.130
它其实就是一个响应对象

29:29.130 --> 29:31.130
我这里打个注射

29:31.130 --> 29:33.130
完成之后

29:33.130 --> 29:39.130
会给予一个响应对象

29:39.130 --> 29:41.130
也就是在这个东西

29:42.130 --> 29:44.130
这个东西我们里边有一些方法

29:44.130 --> 29:46.130
我们可以通过这个东西

29:46.130 --> 29:48.130
打印一下就知道了

29:48.130 --> 29:50.130
非常简单

29:50.130 --> 29:52.130
打印一下你啥都知道

29:53.130 --> 29:55.130
等一会 拿到服务器的响应头

29:55.130 --> 29:57.130
打印出来了

29:57.130 --> 29:59.130
你看一下对象里面有什么东西吗

29:59.130 --> 30:01.130
不过现在还拿不到

30:01.130 --> 30:03.130
因为还要接收那个响应题

30:03.130 --> 30:05.130
这个表示状态

30:05.130 --> 30:06.130
状态的文本

30:06.130 --> 30:07.130
这些东西都有

30:07.130 --> 30:09.130
你请求的URL地址

30:09.130 --> 30:11.130
然后呢 这里有个Headers

30:11.130 --> 30:13.130
是不是可以表示响应头

30:13.130 --> 30:15.130
那么这是也是一个对象

30:15.130 --> 30:17.130
对象里面它里面没属性

30:17.130 --> 30:19.130
但是有一些方法

30:19.130 --> 30:20.130
介绍方法

30:20.130 --> 30:22.130
可以拿响应头

30:22.130 --> 30:24.130
还是判断有没有某一个响应头

30:24.130 --> 30:26.130
得到响应头里面所有的Kiss

30:26.130 --> 30:28.130
其实我们用一下就知道了

30:28.130 --> 30:30.130
Headers

30:30.130 --> 30:32.130
它有一个方法叫Kiss

30:32.130 --> 30:35.130
拿到所有响应头的键

30:35.130 --> 30:37.130
好 保存

30:37.130 --> 30:39.130
有了 你看

30:39.130 --> 30:41.130
好 等待 等待 拿响应头

30:41.130 --> 30:43.130
它是个迭代器

30:43.130 --> 30:45.130
你们还没有学过迭代器

30:45.130 --> 30:47.130
我们可以用那个

30:47.130 --> 30:51.660
forov来循环它

30:51.660 --> 30:53.660
它可以循环这个东西

30:53.660 --> 30:55.660
这个玩意可以用forov循环

30:55.660 --> 30:57.660
循环这个东西去输出一下

30:57.660 --> 31:01.480
把这个网络调一下

31:01.480 --> 31:06.050
这是我们目前可以获取到的响应头

31:06.050 --> 31:08.050
contentlens content type

31:08.050 --> 31:10.050
表示我们要拿一个content type

31:10.050 --> 31:11.050
等于多少呢

31:11.050 --> 31:13.050
就是我们输出

31:13.050 --> 31:14.050
headers

31:14.050 --> 31:15.050
gates 用gates的方法

31:15.050 --> 31:17.050
可以拿到一个响应头

31:17.050 --> 31:18.050
content type

31:18.050 --> 31:19.050
保存

31:19.050 --> 31:20.050
就是你看 响应头里面

31:20.050 --> 31:22.050
是不是有这么一个东西

31:22.050 --> 31:24.050
可以拿到某一个响应头的纸

31:24.050 --> 31:25.050
当然这里布局面大小写

31:25.050 --> 31:27.050
一些小写依然可以是

31:27.050 --> 31:29.050
可以拿到的 都没问题

31:29.050 --> 31:31.050
好 就是获取响应头

31:31.050 --> 31:33.050
但是我们很多时候并不太关心

31:33.050 --> 31:35.050
怎么去获取响应头

31:35.050 --> 31:37.050
我们比较关心的是

31:37.050 --> 31:40.050
我如何获取响应体

31:40.050 --> 31:41.050
对吧 像这边一样

31:41.050 --> 31:43.050
我如何获取这个东西

31:43.050 --> 31:45.050
这是我们比较关心的

31:45.050 --> 31:46.050
因为我们需要的数据

31:46.050 --> 31:48.050
好多都在响应体里面

31:48.050 --> 31:49.050
那么怎么做呢

31:49.050 --> 31:51.050
又要用到这个对象

31:51.050 --> 31:54.050
这个对象里面有一个函数

31:54.050 --> 31:55.050
有一些函数

31:55.050 --> 32:00.380
我们再把这个对象打印一下

32:00.380 --> 32:02.380
首先我们看逻辑上

32:02.380 --> 32:03.380
逻辑上在这里

32:03.380 --> 32:04.380
能不能获取响应体

32:04.380 --> 32:06.380
你讲一下

32:06.380 --> 32:08.380
先去我刚才讲的

32:08.380 --> 32:10.380
根据逻辑上在这里

32:10.380 --> 32:12.380
这些代码就是从14行开始

32:12.380 --> 32:13.380
就在这个函数里面

32:13.380 --> 32:15.380
这个箭头函数里面

32:15.380 --> 32:17.380
能不能获取到响应体

32:17.380 --> 32:19.380
你是获取不到的

32:19.380 --> 32:20.380
为什么

32:20.380 --> 32:22.380
因为这个Promise完成的

32:22.380 --> 32:24.380
完成的时间点是什么

32:24.380 --> 32:26.380
收到响应头之后

32:26.380 --> 32:28.380
这个时候还没有接收响应体

32:28.380 --> 32:29.380
所以说你这个时候

32:29.380 --> 32:31.380
拿不到响应体的

32:31.380 --> 32:33.380
那么怎么才能拿到响应体呢

32:33.380 --> 32:36.380
就得让它继续接收响应体

32:36.380 --> 32:38.380
直到响应体接收完毕

32:38.380 --> 32:39.380
那到底怎么让它

32:39.380 --> 32:41.380
继续接收响应体呢

32:41.380 --> 32:43.380
它这里面有些函数

32:43.380 --> 32:46.380
我们主要用到的是这两个函数

32:46.380 --> 32:47.380
一个是Text

32:47.380 --> 32:49.380
一个是接生

32:49.380 --> 32:52.380
这两个函数都表达同一个意思

32:52.380 --> 32:54.380
就是继续接收

32:54.380 --> 32:56.380
响应体

32:56.380 --> 32:58.380
这两个函数的区别又在于

32:58.380 --> 33:01.380
我怎么来看待这个响应体

33:01.380 --> 33:03.380
我是把它当成接生格式来看待呢

33:03.380 --> 33:05.380
我还是把它当成一个

33:05.380 --> 33:07.380
纯文闷格式来看待

33:07.380 --> 33:08.380
如果说你把它当成一个

33:08.380 --> 33:10.380
接生格式来看待的话

33:10.380 --> 33:14.380
当我收到收完一张响应体之后

33:14.380 --> 33:16.380
它得到的就是一个接生对象

33:16.380 --> 33:18.380
就是介石对象

33:18.380 --> 33:19.380
如果说你把它当成一个

33:19.380 --> 33:20.380
纯文闷格式来看待的话

33:20.380 --> 33:21.380
它收完响应体之后呢

33:21.380 --> 33:23.380
得到的就是个字母参

33:23.380 --> 33:25.380
就像我们之前上一个APL的一个

33:25.380 --> 33:26.380
那样子对吧

33:26.380 --> 33:27.380
拿到的是一个字母参

33:27.380 --> 33:29.380
那么现在它给你多种选择

33:29.380 --> 33:30.380
那么我们这里呢

33:30.380 --> 33:32.380
我们知道这个接口

33:32.380 --> 33:34.380
拿到的其实就是一个

33:34.380 --> 33:36.380
接生格式的对象

33:36.380 --> 33:38.380
你能去调用接生

33:38.380 --> 33:40.380
那么这个函数会返回什么呢

33:40.380 --> 33:42.380
你猜它会返回啥

33:42.380 --> 33:45.380
你猜它会返回个对象

33:45.380 --> 33:47.380
那不一碗独自了吗

33:47.380 --> 33:49.380
它接收响应体要不要时间

33:49.380 --> 33:51.380
你把时间想得夸张一点

33:51.380 --> 33:52.380
那么这句话

33:52.380 --> 33:54.380
接收响应体解析响应体

33:54.380 --> 33:55.380
是不是得需要一段时间

33:55.380 --> 33:56.380
那需要一年

33:56.380 --> 33:57.380
那是不代表又要卡一年

33:57.380 --> 33:59.380
它肯定不会这么做

33:59.380 --> 34:00.380
它会怎么样呢

34:00.380 --> 34:04.700
它会返回一个Promise

34:04.700 --> 34:07.700
这个玩意它会返回一个Promise

34:07.700 --> 34:09.700
那么这个Promise

34:09.700 --> 34:10.700
它返回的Promise

34:10.700 --> 34:11.700
是什么时候完成

34:11.700 --> 34:14.700
当我收完了响应体之后

34:14.700 --> 34:16.700
我把讲运体也解析成了

34:16.700 --> 34:17.700
解析对象之后

34:17.700 --> 34:19.700
Promise就完成了

34:19.700 --> 34:21.700
所以说这个玩意返回的是Promise

34:21.700 --> 34:22.700
所以我们怎么办

34:22.700 --> 34:23.700
我们通常情况下

34:23.700 --> 34:25.700
都是把这个Promise直接返回

34:25.700 --> 34:26.700
你看这个逻辑

34:26.700 --> 34:28.700
发出请求

34:28.700 --> 34:30.700
等等等等等等

34:30.700 --> 34:31.700
等完了之后

34:31.700 --> 34:33.700
拿到了一个响应头

34:33.700 --> 34:35.700
运行这个函数

34:35.700 --> 34:36.700
别着急

34:36.700 --> 34:38.700
你继续给我等

34:38.700 --> 34:40.700
返回一个Promise

34:40.700 --> 34:41.700
那么这里返回了过后

34:41.700 --> 34:43.700
就相当于是这个Zend

34:43.700 --> 34:44.700
Promise的状态了

34:44.700 --> 34:45.700
那么这里返回之后

34:45.700 --> 34:46.700
就比方说

34:46.700 --> 34:48.700
我现在我要继续

34:48.700 --> 34:49.700
接收响应体了

34:49.700 --> 34:51.700
然后我再继续写个证

34:51.700 --> 34:55.700
当我接收到响应体之后

34:55.700 --> 34:56.700
那么这个地方

34:56.700 --> 34:58.700
它就会把响应体的内容

34:58.700 --> 34:59.700
传给我

34:59.700 --> 35:00.700
那传的是什么内容呢

35:00.700 --> 35:02.700
你用的是接受解析

35:02.700 --> 35:04.700
那么这个Promise完成之后

35:04.700 --> 35:06.700
给我的就是一个

35:06.700 --> 35:09.700
完整的服务器的响应的结果对象

35:09.700 --> 35:14.100
我们打印一下就知道了

35:14.100 --> 35:15.100
运行

35:15.100 --> 35:17.100
你看拿了服务器的响应结果对象

35:17.100 --> 35:18.100
就说了半天

35:18.100 --> 35:20.100
说了秘密码码说了半天

35:20.100 --> 35:21.100
非常简单

35:21.100 --> 35:22.100
发动请求

35:22.100 --> 35:24.100
这里可以拿请求头

35:24.100 --> 35:26.100
这里可以拿响应体

35:26.100 --> 35:27.100
不就是两部吗

35:27.100 --> 35:28.100
你看这里不就是两部吗

35:28.100 --> 35:29.100
先拿

35:29.100 --> 35:31.100
这里可以拿响应头

35:31.100 --> 35:33.100
这里可以拿响应体

35:33.100 --> 35:34.100
发动请求

35:34.100 --> 35:36.100
这里可以拿响应头

35:36.100 --> 35:38.100
然后继续接收响应体

35:38.100 --> 35:40.100
这里就可以拿响应体了

35:40.100 --> 35:42.100
就不是两个Promise

35:42.100 --> 35:43.100
都要等待的

35:43.100 --> 35:44.100
发动请求

35:44.100 --> 35:45.100
你要等待吗

35:45.100 --> 35:47.100
拿到响应头了

35:47.100 --> 35:49.100
你要去接收响应体

35:49.100 --> 35:50.100
就等待吧

35:50.100 --> 35:51.100
拿到响应体了

35:51.100 --> 35:53.100
那如果说你用的是Tag

35:53.100 --> 35:56.100
那么这里拿到的就是一个支付串

35:56.100 --> 35:58.100
就这么简单

35:58.100 --> 35:59.100
就这么简单

35:59.100 --> 36:00.100
你用接受的格式

36:00.100 --> 36:03.100
你就拿到的是一个对象

36:03.100 --> 36:04.100
没啥问题吧

36:04.100 --> 36:06.100
你看这个简头含书

36:06.100 --> 36:07.100
它里面只有一句代码

36:07.100 --> 36:08.100
而且是直接返回的

36:08.100 --> 36:12.470
那是不是我们可以去掉这个小货号

36:12.470 --> 36:14.470
现在这种格式

36:14.470 --> 36:15.470
对吧

36:15.470 --> 36:16.470
就完事了

36:16.470 --> 36:18.470
就完事了

36:18.470 --> 36:20.470
之前一大堆代码

36:20.470 --> 36:22.470
现在的代码非常的简洁

36:22.470 --> 36:25.470
而且你看我们像

36:25.470 --> 36:27.470
获取英雄列表的东西

36:27.470 --> 36:28.470
有时候还要抬杠

36:28.470 --> 36:29.470
说那这个玩意

36:29.470 --> 36:30.470
怎么来做成这个

36:30.470 --> 36:31.470
这边的效果呢

36:31.470 --> 36:33.470
那还不简单吗

36:33.470 --> 36:35.470
你都把阿迦克斯都实现了

36:35.470 --> 36:37.470
那你要拿到这个响应结果之后

36:37.470 --> 36:38.470
你要去做什么

36:38.470 --> 36:40.470
那就看具体的前端需求了

36:40.470 --> 36:41.470
你要做

36:41.470 --> 36:42.470
现在把数据给你了

36:42.470 --> 36:43.470
一个数组给你了

36:43.470 --> 36:45.470
你要去做什么样的界面

36:45.470 --> 36:46.470
那就随便你做了吧

36:46.470 --> 36:48.470
你把个代码直接复制一下

36:48.470 --> 36:51.850
我们过来不就完事了吗

36:51.850 --> 36:53.850
不就完事了吗

36:53.850 --> 37:02.980
那个数据在哪了

37:02.980 --> 37:04.980
点data

37:04.980 --> 37:05.980
从data这个属性里面

37:05.980 --> 37:07.980
拿到这个数组

37:07.980 --> 37:08.980
拿到这个数组

37:08.980 --> 37:10.980
然后循环这个数组

37:10.980 --> 37:11.980
点li

37:11.980 --> 37:12.980
把夹到一位里面去

37:12.980 --> 37:13.980
保存

37:13.980 --> 37:14.980
你看效果不是一样

37:14.980 --> 37:15.980
不一样的吗

37:15.980 --> 37:16.980
对不对

37:16.980 --> 37:17.980
代码有多少

37:17.980 --> 37:18.980
并不多对不对

37:18.980 --> 37:19.980
当然了

37:19.980 --> 37:20.980
这个代码呢

37:20.980 --> 37:21.980
其实还有各种各样的写法

37:21.980 --> 37:22.980
很多时候呢

37:22.980 --> 37:24.980
像包括每下一个开始

37:24.980 --> 37:26.980
就要做一个完整的

37:26.980 --> 37:28.980
网络的一个项目

37:28.980 --> 37:29.980
小项目啊

37:29.980 --> 37:31.980
那么我们常见的一些做法就是

37:31.980 --> 37:32.980
把这些接口

37:32.980 --> 37:33.980
封装成一个函数

37:33.980 --> 37:34.980
比方说

37:34.980 --> 37:36.980
我们要拿到英雄的列表

37:36.980 --> 37:38.980
我就最好了写这么一个函数

37:38.980 --> 37:39.980
heros

37:41.980 --> 37:43.980
由这个函数来帮我发出请求

37:43.980 --> 37:45.980
他返回一个英雄的数组

37:45.980 --> 37:47.980
当然这个函数毫无疑问

37:47.980 --> 37:48.980
是一步的

37:48.980 --> 37:49.980
不然的话

37:49.980 --> 37:51.980
他拿这个英雄数组得一年

37:51.980 --> 37:53.980
那我等到什么时候去

37:53.980 --> 37:55.980
他肯定是一步的

37:55.980 --> 37:56.980
那这个代码就直接

37:56.980 --> 37:57.980
copy过来对吧

37:59.980 --> 38:01.980
直接copy过来

38:01.980 --> 38:02.980
那怎么来写这个代码

38:02.980 --> 38:04.980
后边的代码就不要了

38:04.980 --> 38:06.980
拿到一个英雄数组

38:07.980 --> 38:08.980
那怎么来写这个代码

38:08.980 --> 38:09.980
你看着

38:09.980 --> 38:12.980
我们通常都可以有好几种写法

38:12.980 --> 38:13.980
别忘了这个地方

38:13.980 --> 38:15.980
我们就可以删掉

38:15.980 --> 38:17.980
然后在前面写上一个await

38:23.130 --> 38:24.130
大家能看懂吗

38:24.130 --> 38:26.130
发送请求

38:27.130 --> 38:29.130
这里是不是想用头接收完了

38:29.130 --> 38:30.130
想用头接收完了

38:30.130 --> 38:31.130
我继续接收想应体

38:31.130 --> 38:34.130
等待这一个任结束

38:34.130 --> 38:36.130
这个任结束的时间

38:36.130 --> 38:37.130
不就是他想应体

38:37.130 --> 38:38.130
接收完成的时间吗

38:38.130 --> 38:40.130
因为你返回的是一个promise

38:40.130 --> 38:42.130
这个返回的是一个promise

38:42.130 --> 38:43.130
那么这个promise完成之后

38:43.130 --> 38:44.130
这个rin

38:44.130 --> 38:46.130
他的promise他就会完成

38:46.130 --> 38:47.130
对吧

38:47.130 --> 38:48.130
就是我们之前学过promise

38:48.130 --> 38:49.130
对吧

38:49.130 --> 38:50.130
我们之前学的promise

38:50.130 --> 38:52.130
最大的用处就是写这种代码

38:52.130 --> 38:54.130
基本上都是一个机械式的写法

38:54.130 --> 38:55.130
你写一万次

38:55.130 --> 38:57.130
基本上也是这种写法

38:57.130 --> 38:58.130
基本上不会有什么变化的

38:58.130 --> 38:59.130
就是这种写法

38:59.130 --> 39:00.130
你哪怕现在理解不了

39:00.130 --> 39:02.130
你现在把直接写出来

39:02.130 --> 39:04.130
基本上就固定的这种写法了

39:05.130 --> 39:07.130
那么等他拿到这个想应结果之后

39:09.130 --> 39:10.130
我们把这个想应结果

39:10.130 --> 39:11.130
保存了一个变量

39:11.130 --> 39:12.130
Risper里边

39:12.130 --> 39:13.130
最后我们把Risper返回

39:13.130 --> 39:14.130
就完了嘛

39:14.130 --> 39:16.130
直接封装成了一个Gate Hero 函数

39:16.130 --> 39:18.130
好咱们马上又来试一下

39:18.130 --> 39:19.130
用了这个函数之后

39:19.130 --> 39:21.130
让我之后要发送一个

39:21.130 --> 39:22.130
不要拿到英雄说掉函数就完事了

39:22.130 --> 39:24.130
注意这个函数返回的是promise

39:24.130 --> 39:26.130
等到这个promise完成之后

39:26.130 --> 39:31.740
我是不是就可以拿到

39:31.740 --> 39:32.740
效果不是一样吗

39:32.740 --> 39:33.740
对吧

39:33.740 --> 39:34.740
一啥区别呢

39:34.740 --> 39:35.740
效果是完全一样的

39:35.740 --> 39:37.740
当然你也可以把循环这里

39:37.740 --> 39:39.740
在这里均一循环

39:40.740 --> 39:41.740
都可以

39:41.740 --> 39:43.740
而且这个函数的写法有很多了

39:43.740 --> 39:45.740
那比方说我也可以这样子来呗

39:47.740 --> 39:48.740
怎么样

39:48.740 --> 39:50.740
我一开始可以等待

39:50.740 --> 39:52.740
那么这一次的等待就不一样了

39:52.740 --> 39:53.740
等待的是什么

39:53.740 --> 39:55.740
等待的是想应头结束完成

39:57.740 --> 39:59.740
等待的是想应头结束完成

39:59.740 --> 40:01.740
那么这里还没有修想硬体

40:01.740 --> 40:03.740
所以我接下来继续接受

40:03.740 --> 40:05.740
我继续等待修想硬体

40:05.740 --> 40:06.740
把这样子没有回掉了

40:06.740 --> 40:07.740
看到更加舒服

40:10.180 --> 40:12.180
这是等待想应头结束完成

40:12.180 --> 40:13.180
好完成了

40:13.180 --> 40:14.180
我又等待接收想硬体

40:14.180 --> 40:17.180
把它解析成一个对象返回这个包底

40:17.180 --> 40:19.180
当然你也可以直接在这里

40:19.180 --> 40:20.180
直接把这一块返回

40:20.180 --> 40:22.180
都行

40:22.180 --> 40:25.180
结果是完全一样的

40:26.180 --> 40:28.180
这个函数就封装成了一个

40:28.180 --> 40:30.180
其实你回看一下我们之前的

40:30.180 --> 40:33.180
王者荣耀老师给你写的那块代码

40:33.180 --> 40:35.180
其实就是这种代码

40:35.180 --> 40:36.180
你直接去看一下吧

40:36.180 --> 40:37.180
你现在就应该能看的动作

40:37.180 --> 40:38.180
就是这种代码

40:38.180 --> 40:40.180
类似的

40:40.180 --> 40:42.180
函数被特别简单

40:42.180 --> 40:43.180
你只要能够拿到

40:43.180 --> 40:44.180
伏辑的想应数据

40:44.180 --> 40:45.180
那接下来的东西

40:45.180 --> 40:47.180
就跟你以前学的知识有关系了

40:47.180 --> 40:49.180
就跟网络就没关系了

40:49.180 --> 40:51.180
然后就拿这个数据

40:51.180 --> 40:53.180
该干嘛干嘛去

40:53.180 --> 40:54.180
去对照一下之前的

40:54.180 --> 40:55.180
做个什么省事

40:55.180 --> 40:57.180
那个网络

40:57.180 --> 40:59.180
就是那个王者荣耀

40:59.180 --> 41:00.180
或者是歌词

41:00.180 --> 41:03.180
对吧都是一样的含义

41:03.180 --> 41:05.180
懂不懂意思吗

41:05.180 --> 41:07.180
这种网络型球

41:08.180 --> 41:09.180
好那么

41:09.180 --> 41:10.180
我们刚才都说了

41:10.180 --> 41:13.180
Po 这是Po色型球

41:13.180 --> 41:15.180
那那个

41:15.180 --> 41:16.180
这是Gate型球

41:16.180 --> 41:18.180
那Po色型球呢

41:18.180 --> 41:19.180
Po色型球怎么办呢

41:19.180 --> 41:20.180
好我们就马上来

41:20.180 --> 41:23.180
演示一个Po色型球

41:23.180 --> 41:25.180
这节课呢你们的作业很简单

41:25.180 --> 41:26.180
就是把老师课堂上写的

41:26.180 --> 41:27.180
有123

41:27.180 --> 41:29.180
自己去写一遍

41:29.180 --> 41:31.180
熟悉一下这些API

41:31.180 --> 41:33.180
下节课呢我们

41:33.180 --> 41:34.180
这些API非常简单

41:34.180 --> 41:35.180
写到后边

41:35.180 --> 41:37.180
你现在觉得好像很有技术含量的样子

41:37.180 --> 41:38.180
我给你们说

41:38.180 --> 41:40.180
跟ACM和CSS是一样

41:40.180 --> 41:41.180
你们过了一段时间

41:41.180 --> 41:42.180
你觉得这种代码要写得兔

41:42.180 --> 41:44.180
纯体立火

41:44.180 --> 41:46.180
写这种代码是纯体立火

41:46.180 --> 41:48.180
没有任何的技术含量

41:48.180 --> 41:50.180
你写的一段时间就知道了

41:50.180 --> 41:52.180
写得一想兔

41:54.180 --> 41:56.180
现在我们来做一个登录吧

41:56.180 --> 41:57.180
我们来试一下

41:57.180 --> 41:58.180
做一个登录

41:58.180 --> 41:59.180
非常简单的登录

41:59.180 --> 42:01.180
当然不是一个完善的登录功能

42:01.180 --> 42:02.180
完善登录功能

42:02.180 --> 42:04.180
我们后边做了个聊天机会

42:04.180 --> 42:05.180
会做

42:05.180 --> 42:07.180
比方说这里

42:07.180 --> 42:09.180
我们写一个账号

42:09.180 --> 42:15.760
给他一个ID吧

42:17.760 --> 42:19.760
txt-login-id

42:20.760 --> 42:22.760
然后一个密码

42:22.760 --> 42:29.530
给他一个ID

42:29.530 --> 42:32.530
txt-login-password

42:32.530 --> 42:33.530
账号密码

42:33.530 --> 42:34.530
然后加一个按钮

42:35.530 --> 42:36.530
登录

42:36.530 --> 42:37.530
OK

42:38.530 --> 42:40.530
我们就写出了这么一个玩意儿

42:40.530 --> 42:41.530
调整一下

42:47.170 --> 42:48.170
好了

42:48.170 --> 42:50.170
那么我们如何来实现登录呢

42:50.170 --> 42:52.170
首先我们可以做什么呢

42:52.170 --> 42:54.170
我们可以去

42:54.170 --> 42:56.170
要去注册一个事件

42:56.170 --> 42:58.170
什么时候登录

42:58.170 --> 42:59.170
你首先要搞清楚

42:59.170 --> 43:01.170
刚才在第1个按钮

43:01.170 --> 43:03.170
第1个页面和第2个页面里边

43:03.170 --> 43:05.170
我们是一开始就发生网络请求

43:05.170 --> 43:07.170
那么第3个按钮里边

43:07.170 --> 43:09.170
是要点击按钮之后

43:09.170 --> 43:11.170
我才把用户填写的

43:11.170 --> 43:12.170
用户填写的账号

43:12.170 --> 43:14.170
填写的密码

43:14.170 --> 43:16.170
发送到服务器去完成登录

43:16.170 --> 43:17.170
对不对

43:17.170 --> 43:19.170
是不是这个意思

43:19.170 --> 43:20.170
那么也就是说

43:20.170 --> 43:22.170
我们什么时候发送网络请求呢

43:22.170 --> 43:24.170
是不是点击按钮的时候

43:24.170 --> 43:25.170
发送网络请求

43:25.170 --> 43:26.170
对吧

43:26.170 --> 43:27.170
所以说

43:27.170 --> 43:28.170
到底什么时候发送网络请求

43:28.170 --> 43:29.170
你看一下

43:29.170 --> 43:30.170
再看一下这个图

43:30.170 --> 43:31.170
我们的阿强赫斯

43:31.170 --> 43:32.170
是在什么时候运行的

43:32.170 --> 43:34.170
执行接待码的时候

43:34.170 --> 43:36.170
那什么时候执行那个接待码

43:36.170 --> 43:37.170
有可能一开始就执行

43:37.170 --> 43:39.170
有可能是点击某一个按钮的时候

43:39.170 --> 43:40.170
或者是鼠标

43:40.170 --> 43:42.170
离开某一个门框的时候

43:42.170 --> 43:44.170
或者是鼠标移动的时候

43:44.170 --> 43:46.170
都有可能执行接待码

43:46.170 --> 43:47.170
那接待码

43:47.170 --> 43:49.170
只要你执行到了某一句话

43:49.170 --> 43:51.170
你不要把阿基克斯想得那么复杂

43:51.170 --> 43:52.170
他只要执行到了这么一句话

43:52.170 --> 43:53.170
他就会发送网络请求

43:53.170 --> 43:54.170
他没有执行

43:54.170 --> 43:55.170
他就不会发送

43:55.170 --> 43:57.170
那什么时候你要去写这句话

43:57.170 --> 43:58.170
那就看具体的需求了

43:58.170 --> 43:59.170
然后像这里

43:59.170 --> 44:02.670
点击按钮的时候

44:02.670 --> 44:03.670
稍等

44:03.670 --> 44:04.670
好

44:04.670 --> 44:05.670
那么在

44:05.670 --> 44:06.670
我们这个效果里面

44:06.670 --> 44:07.670
是点击按钮的时候

44:07.670 --> 44:08.670
我们才会有

44:08.670 --> 44:09.670
跟网络请求有关系

44:09.670 --> 44:10.670
对吧

44:10.670 --> 44:11.670
而且呢

44:11.670 --> 44:12.670
我们整个的效果

44:12.670 --> 44:13.670
也本身就是点击按钮的时候

44:13.670 --> 44:15.670
才去得到帐号密码

44:15.670 --> 44:16.670
因此呢

44:16.670 --> 44:17.670
我们这里拿到这个门框

44:17.670 --> 44:18.670
拿到这个按钮

44:18.670 --> 44:19.670
Documents

44:24.500 --> 44:25.500
然后呢

44:25.500 --> 44:26.500
在顺便拿到两个门框

44:26.500 --> 44:27.500
login

44:29.500 --> 44:30.500
tst

44:30.500 --> 44:31.500
login

44:31.500 --> 44:35.790
id

44:35.790 --> 44:36.790
嗯

44:36.790 --> 44:37.790
tst

44:37.790 --> 44:38.790
login

44:38.790 --> 44:39.790
id

44:39.790 --> 44:40.790
好

44:40.790 --> 44:41.790
然后还有一个就是

44:42.790 --> 44:43.790
tst

44:43.790 --> 44:44.790
login

44:44.790 --> 44:48.230
tst

44:48.230 --> 44:49.230
login

44:49.230 --> 44:50.230
tst

44:50.230 --> 44:51.230
login

44:51.230 --> 44:52.230
tst

44:52.230 --> 44:54.230
好拿到这三个动物元素

44:54.230 --> 44:55.230
接下来注册实践

44:55.230 --> 44:57.230
btn click

44:57.230 --> 45:00.230
当我点击的时候

45:00.230 --> 45:02.230
点击的时候干嘛呢

45:02.230 --> 45:04.230
我要拿到用户的账号

45:04.230 --> 45:05.230
和用户填写的密码

45:05.230 --> 45:06.230
这个是必须要拿的对吧

45:06.230 --> 45:07.230
这个时候毫无疑问的

45:07.230 --> 45:08.230
我写写

45:09.230 --> 45:10.230
就是有的时候我上课

45:10.230 --> 45:11.230
都上得快进成分链了

45:11.230 --> 45:13.230
上公开课的时候呢

45:13.230 --> 45:15.230
或者上集训的时候

45:15.230 --> 45:16.230
然后呢

45:16.230 --> 45:17.230
然后呢

45:17.230 --> 45:18.230
上付费课

45:18.230 --> 45:19.230
上付费课前期的时候呢

45:19.230 --> 45:20.230
我也得用吧

45:20.230 --> 45:21.230
然后呢

45:21.230 --> 45:23.230
相互后期的课的时候

45:23.230 --> 45:25.230
就es6之后的课的时候

45:25.230 --> 45:26.230
我要用const

45:26.230 --> 45:27.230
真的人靠

45:27.230 --> 45:28.230
搞得进我精神分链

45:29.230 --> 45:30.230
好

45:30.230 --> 45:31.230
现在呢

45:31.230 --> 45:32.230
我们去拿到这些账号密码

45:32.230 --> 45:33.230
首先是账号

45:33.230 --> 45:34.230
login

45:34.230 --> 45:35.230
id

45:35.230 --> 45:36.230
tst

45:36.230 --> 45:37.230
login

45:37.230 --> 45:38.230
id的Value

45:38.230 --> 45:39.230
对吧

45:39.230 --> 45:40.230
然后login

45:40.230 --> 45:41.230
password

45:41.230 --> 45:42.230
tst

45:42.230 --> 45:43.230
login

45:43.230 --> 45:44.230
password

45:44.230 --> 45:45.230
拿到

45:45.230 --> 45:46.230
打印一下吧

45:46.230 --> 45:47.230
现在跟网络有关系吗

45:47.230 --> 45:48.230
都还没关系

45:50.230 --> 45:51.230
password

45:51.230 --> 45:52.230
好

45:52.230 --> 45:53.230
保存啊

45:53.230 --> 45:54.230
你看看登录

45:55.230 --> 45:56.230
随便写一些吧

45:56.230 --> 45:58.230
这个网络是啥

45:58.230 --> 46:05.900
就这个网络是啥

46:05.900 --> 46:07.900
这个网络是我流量器的一个插件

46:07.900 --> 46:08.900
你们不用去管它

46:08.900 --> 46:09.900
点登录

46:09.900 --> 46:10.900
你看

46:10.900 --> 46:11.900
是不是拿到账号密码了

46:11.900 --> 46:12.900
那么接下来

46:12.900 --> 46:13.900
我要验证这个账号密码

46:13.900 --> 46:14.900
是不是正确

46:14.900 --> 46:16.900
是不是要用postman

46:16.900 --> 46:17.900
要用这个接口

46:17.900 --> 46:18.900
是吧

46:18.900 --> 46:19.900
网络请求

46:19.900 --> 46:20.900
他来帮助我看一下

46:20.900 --> 46:21.900
这个网络到底是不是正确

46:21.900 --> 46:22.900
好来吧

46:22.900 --> 46:23.900
fetch

46:23.900 --> 46:24.900
哪个UIL地址

46:24.900 --> 46:26.900
地址是哪一个

46:26.900 --> 46:27.900
我们知道

46:27.900 --> 46:28.900
login是这个对吧

46:28.900 --> 46:30.900
地址前面地址是这个

46:30.900 --> 46:31.900
你们那边要改一下

46:31.900 --> 46:32.900
前面地址

46:32.900 --> 46:33.900
要改一下

46:33.900 --> 46:34.900
好

46:34.900 --> 46:35.900
但是现在发生的

46:35.900 --> 46:36.900
不是get请求

46:36.900 --> 46:37.900
是post请求

46:37.900 --> 46:38.900
怎么办

46:38.900 --> 46:39.900
传第二个参数

46:39.900 --> 46:40.900
第二参数是一个对象

46:40.900 --> 46:41.900
进行配置

46:41.900 --> 46:44.900
对请求在进一步进行配置

46:44.900 --> 46:46.900
那么这里个对象里面

46:46.900 --> 46:47.900
有个属性叫master

46:47.900 --> 46:48.900
是配置请求的方法

46:48.900 --> 46:49.900
默认为get

46:49.900 --> 46:50.900
你可以把它写为post

46:50.900 --> 46:51.900
大写

46:53.900 --> 46:54.900
就post请求

46:54.900 --> 46:57.900
然后除了这个东西之外

46:57.900 --> 47:00.900
比方我还要配置请求投

47:00.900 --> 47:01.900
请求投的话

47:01.900 --> 47:02.900
比方这个content type

47:02.900 --> 47:04.900
为application接受

47:04.900 --> 47:05.900
这个是要配置的

47:05.900 --> 47:06.900
这个不配置的话

47:06.900 --> 47:07.900
默认不是这个字

47:07.900 --> 47:08.900
在postman里面

47:08.900 --> 47:09.900
你不用配置的

47:09.900 --> 47:10.900
因为他默认给你

47:10.900 --> 47:11.900
根据

47:11.900 --> 47:12.900
他会自动根据你的

47:12.900 --> 47:13.900
这个东西

47:13.900 --> 47:15.900
来设置请求投的content type

47:16.900 --> 47:17.900
这里不会

47:17.900 --> 47:18.900
要配置

47:20.900 --> 47:21.900
这个headline

47:21.900 --> 47:22.900
配置请求投

47:22.900 --> 47:24.900
请求方法就是请求投

47:24.900 --> 47:25.900
如果说你有顾外的

47:25.900 --> 47:26.900
请求投的话

47:26.900 --> 47:27.900
那么就写到对象里面

47:27.900 --> 47:29.900
这里是建置对

47:29.900 --> 47:31.900
那么请求投的名字叫

47:31.900 --> 47:33.900
content type

47:33.900 --> 47:34.900
但是不好意思

47:34.900 --> 47:35.900
这个不是一个

47:35.900 --> 47:36.900
有效的属性名字

47:36.900 --> 47:37.900
它有个横纲

47:37.900 --> 47:38.900
那怎么办

47:38.900 --> 47:40.900
根据你学过的基础知识

47:40.900 --> 47:41.900
都不是什么

47:41.900 --> 47:42.900
网络部分的知识

47:42.900 --> 47:43.900
网络部分

47:43.900 --> 47:44.900
跟这里没有什么关系

47:44.900 --> 47:45.900
当属性名

47:45.900 --> 47:46.900
不符合那个命名规范的时候

47:46.900 --> 47:47.900
你是不是可以

47:47.900 --> 47:48.900
把它加上一个双硬号

47:48.900 --> 47:49.900
对吧

47:49.900 --> 47:50.900
然后把它写上

47:50.900 --> 47:51.900
IPK性接受

47:51.900 --> 47:52.900
这配置请求投

47:52.900 --> 47:53.900
当然

47:53.900 --> 47:54.900
如果说你还有别的

47:54.900 --> 47:55.900
请求投的话

47:55.900 --> 47:56.900
你还可以继续配置

47:56.900 --> 47:57.900
都可以

47:57.900 --> 47:58.900
配置请求投

47:58.900 --> 47:59.900
好

47:59.900 --> 48:00.900
那么接下来

48:00.900 --> 48:01.900
请求体

48:01.900 --> 48:02.900
你看

48:02.900 --> 48:03.900
一共两个参数

48:03.900 --> 48:04.900
UID

48:04.900 --> 48:05.900
进一步的请求配置

48:05.900 --> 48:07.900
请求体

48:07.900 --> 48:08.900
请求体的话

48:08.900 --> 48:10.900
通过这个属性的配置

48:10.900 --> 48:11.900
包底

48:11.900 --> 48:13.900
你家父子为一个制服串

48:13.900 --> 48:14.900
为什么是制服串

48:14.900 --> 48:15.900
那就是制服串

48:15.900 --> 48:16.900
这个玩意是不是制服串

48:16.900 --> 48:17.900
就是制服串

48:17.900 --> 48:19.900
节省格式的制服串

48:19.900 --> 48:20.900
那么现在呢

48:20.900 --> 48:21.900
我要做的事情

48:21.900 --> 48:22.900
就是

48:22.900 --> 48:24.900
我要把一个对象

48:24.900 --> 48:26.900
我要把一个对象

48:26.900 --> 48:27.900
就这个对象

48:27.900 --> 48:29.900
locking ID

48:29.900 --> 48:30.900
locking它所有的

48:30.900 --> 48:31.900
对吧

48:31.900 --> 48:33.900
就这两个属性的对象

48:33.900 --> 48:34.900
这是属性书写

48:34.900 --> 48:36.900
也是丢的

48:36.900 --> 48:37.900
把这个属性

48:37.900 --> 48:38.900
把这个对象

48:38.900 --> 48:39.900
把它序列化成一个

48:39.900 --> 48:41.900
节省格式的制服串

48:41.900 --> 48:42.900
那怎么写

48:42.900 --> 48:44.900
节省军体犯

48:44.900 --> 48:46.900
额比节

48:46.900 --> 48:47.900
是吧

48:47.900 --> 48:48.900
就把它序列化成一个

48:48.900 --> 48:49.900
节省格式的制服串

48:49.900 --> 48:50.900
好了

48:50.900 --> 48:52.900
那么就这个一段代

48:52.900 --> 48:53.900
一共

48:53.900 --> 48:54.900
五六行代

48:54.900 --> 48:55.900
就把请求发过去了

48:55.900 --> 48:56.900
那无非就是

48:56.900 --> 48:57.900
我要现在要等待

48:57.900 --> 48:59.900
请求头接收完毕

48:59.900 --> 49:00.900
是吧

49:00.900 --> 49:01.900
那你这个方法

49:01.900 --> 49:03.900
要得写成一步的

49:03.900 --> 49:04.900
我等待

49:04.900 --> 49:06.900
请求头接收完毕

49:06.900 --> 49:08.900
然后再等待

49:09.900 --> 49:11.900
请求体接收完毕

49:11.900 --> 49:12.900
对吧

49:12.900 --> 49:13.900
跟之前也不一样吗

49:13.900 --> 49:14.900
拿到这个保底

49:14.900 --> 49:15.900
然后输出这个保底

49:15.900 --> 49:17.900
那么服务器不就告诉我了

49:17.900 --> 49:19.900
你到底登陆成功没用了

49:19.900 --> 49:20.900
一共才几行代吗

49:20.900 --> 49:21.900
就没几行代

49:21.900 --> 49:23.900
就完成了一个姿势的请求

49:23.900 --> 49:24.900
数据也发过去了

49:24.900 --> 49:25.900
对吧

49:25.900 --> 49:26.900
请求头也发过去了

49:26.900 --> 49:27.900
好咱们来试一下

49:27.900 --> 49:28.900
那么一开始

49:28.900 --> 49:29.900
一开始有没有发送网络请求

49:29.900 --> 49:30.900
你看

49:30.900 --> 49:31.900
一开始没有吧

49:31.900 --> 49:32.900
这两个玩意儿

49:32.900 --> 49:33.900
不用去管它

49:33.900 --> 49:34.900
不用去管它

49:34.900 --> 49:36.900
一开始没有发送网络请求吧

49:36.900 --> 49:37.900
然后接下来

49:37.900 --> 49:38.900
写个账号吧

49:38.900 --> 49:40.900
这个账号

49:41.900 --> 49:42.900
之前有个注册个账号

49:42.900 --> 49:43.900
好

49:43.900 --> 49:44.900
123

49:44.900 --> 49:45.900
好 点登录

49:47.900 --> 49:48.900
你看

49:49.900 --> 49:50.900
有个罗品出来了

49:50.900 --> 49:51.900
对吧

49:51.900 --> 49:52.900
登录数出来了

49:52.900 --> 49:54.900
你看发送的请求

49:55.900 --> 49:57.900
看来请求这个地址

49:57.900 --> 49:58.900
请求头里边

49:58.900 --> 50:00.900
是不是还给它加了一个A123

50:00.900 --> 50:01.900
这个A

50:01.900 --> 50:02.900
我给它加了一个这个东西

50:02.900 --> 50:03.900
说明这个请求头

50:03.900 --> 50:04.900
是可以随意配置的

50:04.900 --> 50:05.900
只不过它加了一个东西

50:05.900 --> 50:06.900
服务器也不甩我

50:06.900 --> 50:07.900
反正你

50:07.900 --> 50:08.900
干嘛呀你

50:08.900 --> 50:09.900
不认识

50:09.900 --> 50:10.900
也不甩我

50:10.900 --> 50:11.900
给它加了这个东西

50:11.900 --> 50:13.900
content app 给它接受

50:13.900 --> 50:14.900
然后呢

50:14.900 --> 50:15.900
payload

50:15.900 --> 50:17.900
就是请求体

50:17.900 --> 50:19.900
带了个制服刷过去

50:19.900 --> 50:20.900
对吧

50:20.900 --> 50:21.900
格式化之后就变这个

50:21.900 --> 50:22.900
其实就是一个

50:22.900 --> 50:24.900
接受格式的东西

50:24.900 --> 50:26.900
然后服务器给我了个响应

50:26.900 --> 50:27.900
这个服务器的响应

50:27.900 --> 50:28.900
登录成功了

50:28.900 --> 50:29.900
你看

50:29.900 --> 50:30.900
这是登录的用户

50:30.900 --> 50:31.900
你看控制台

50:31.900 --> 50:33.900
都打印出来了

50:33.900 --> 50:35.900
控制台是不是打印出来了

50:35.900 --> 50:36.900
就这么简单

50:38.900 --> 50:39.900
好

50:39.900 --> 50:40.900
那么我们就可以根据

50:40.900 --> 50:41.900
如果说你登录失败了

50:41.900 --> 50:42.900
比方说我们这里写个

50:42.900 --> 50:43.900
取面前写个登录失败

50:43.900 --> 50:44.900
是不是这个

50:44.900 --> 50:45.900
照明码错过

50:45.900 --> 50:46.900
那么在这个场景下边

50:46.900 --> 50:47.900
我们是不是可以根据个

50:47.900 --> 50:48.900
扣的的值

50:48.900 --> 50:50.900
来确定到底有没有登录成功

50:50.900 --> 50:51.900
如果说

50:51.900 --> 50:53.900
保护的扣的

50:53.900 --> 50:54.900
有值

50:54.900 --> 50:55.900
说明它

50:55.900 --> 50:56.900
说明登录失败了

50:56.900 --> 50:57.900
对吧

50:57.900 --> 50:58.900
扣的为0的时候

50:58.900 --> 50:59.900
才表示的成功

50:59.900 --> 51:00.900
扣的有值

51:00.900 --> 51:01.900
就表示失败了

51:01.900 --> 51:02.900
那么我这就

51:02.900 --> 51:03.900
alert

51:04.900 --> 51:05.900
它的message

51:05.900 --> 51:07.900
就alert这个message属性

51:08.900 --> 51:09.900
else

51:09.900 --> 51:10.900
我就alert

51:11.900 --> 51:12.900
登录成功

51:14.900 --> 51:15.900
当然登录成功之后

51:15.900 --> 51:16.900
要干嘛

51:16.900 --> 51:17.900
那就看区体需求了

51:20.210 --> 51:21.210
先来个错误的

51:22.210 --> 51:23.210
照好密码错误

51:23.210 --> 51:24.210
对吧

51:27.100 --> 51:28.100
登录成功

51:30.100 --> 51:31.100
就这么简单

51:31.100 --> 51:32.100
这就是我们

51:32.100 --> 51:34.100
阿迦克斯的全部内容了

51:34.100 --> 51:35.100
全部内容

51:36.100 --> 51:37.100
只要前面你学懂了

51:37.100 --> 51:38.100
你无非就是

51:38.100 --> 51:39.100
把poser

51:39.100 --> 51:40.100
man这一套东西

51:40.100 --> 51:42.100
搬到介石代码里边来了

51:42.100 --> 51:44.100
没有其他没有那么复杂

51:44.100 --> 51:46.100
变成代码来处理了

51:47.100 --> 51:48.100
由于代码处理

51:48.100 --> 51:49.100
它就会变得更加灵活

51:49.100 --> 51:50.100
把代码

51:50.100 --> 51:51.100
写到时间里边

51:51.100 --> 51:52.100
也可以一开始就运行

51:52.100 --> 51:54.100
那么到底什么时候运行

51:54.100 --> 51:56.100
那就看你的区体需求

51:57.100 --> 51:58.100
区体的场景

51:59.100 --> 52:01.100
脱离场景去谈这些东西

52:01.100 --> 52:03.100
你现在只需要认识清楚

52:03.100 --> 52:04.100
我现在

52:04.100 --> 52:06.100
如果说我现在要发生一个网络请求

52:06.100 --> 52:08.100
你看怎么去写代码

52:08.100 --> 52:09.100
阿迦克斯其实

52:09.100 --> 52:11.100
并不包含这些东西

52:11.100 --> 52:12.100
不包含这些东西

52:12.100 --> 52:13.100
这是我们以前的指示

52:13.100 --> 52:15.100
他就是一个请求发过去

52:15.100 --> 52:16.100
拿到这个结果

52:17.100 --> 52:18.100
什么时候发

52:18.100 --> 52:19.100
看需求

52:19.100 --> 52:20.100
拿到这个结果

52:20.100 --> 52:21.100
后边干啥

52:21.100 --> 52:22.100
看需求

52:22.100 --> 52:23.100
我是儿纳扯呢

52:23.100 --> 52:24.100
我是用儿纳扯

52:24.100 --> 52:25.100
谈出消息呢

52:25.100 --> 52:26.100
还是跳转页面呢

52:26.100 --> 52:27.100
还是要干嘛干嘛

52:27.100 --> 52:28.100
看需求

52:28.100 --> 52:29.100
然后王者荣耀

52:29.100 --> 52:31.100
我一开始就要发出请求

52:31.100 --> 52:32.100
拿到这个英雄宿主

52:32.100 --> 52:33.100
然后我就循环宿主

52:33.100 --> 52:34.100
创建元素

52:34.100 --> 52:35.100
生成页面

52:35.100 --> 52:36.100
登录的时候

52:36.100 --> 52:37.100
我是要点击之后

52:37.100 --> 52:38.100
我再发出请求

52:38.100 --> 52:39.100
把数据带过去

52:39.100 --> 52:40.100
带到服务器

52:40.100 --> 52:41.100
然后拿到服务器的结果

52:41.100 --> 52:42.100
我根据你服务器

52:42.100 --> 52:43.100
到底有没有登录成功

52:43.100 --> 52:45.100
我再去做后一步的处理

52:45.100 --> 52:46.100
要看需求

52:46.100 --> 52:48.100
你现在要做的唯一的一件事

52:48.100 --> 52:50.100
就是你要学会

52:50.100 --> 52:52.100
我让你发网络请求的时候

52:52.100 --> 52:53.100
你要能把代码写出来

52:54.100 --> 52:55.100
不要代码写不出来

52:55.100 --> 52:57.100
请求发不过去

52:57.100 --> 52:58.100
或者是请求

52:58.100 --> 52:59.100
你不知道

52:59.100 --> 53:01.100
在联系网里面去调试

53:01.100 --> 53:02.100
不知道在这里

53:02.100 --> 53:04.100
如何去观察这个请求过程

53:04.100 --> 53:05.100
你看每一次点击过来

53:05.100 --> 53:06.100
他都会发出一个请求

53:07.100 --> 53:08.100
又发了一次

53:10.100 --> 53:11.100
要会调试

53:11.100 --> 53:12.100
要会把请求发出去

53:12.100 --> 53:14.100
要会接收服务器的响应结果

53:14.100 --> 53:15.100
对的要求现在就是这个

53:16.100 --> 53:18.100
这就是这节课的全部内容了

53:18.100 --> 53:20.100
最后我再特别提醒一点

53:20.100 --> 53:22.100
所有的IOS都是一步的

53:22.100 --> 53:23.100
你看

53:23.100 --> 53:24.100
飞鞋就更加不要说了

53:24.100 --> 53:26.100
飞鞋它是返回的就是Promise

53:26.100 --> 53:27.100
它肯定是一步的

53:27.100 --> 53:28.100
什么时候完成

53:28.100 --> 53:30.100
我都给你们告诉你们了

53:30.100 --> 53:31.100
它分为两步

53:32.100 --> 53:33.100
收完请求头

53:33.100 --> 53:34.100
和收完请求体

53:35.100 --> 53:36.100
它一定是一步的

53:36.100 --> 53:38.100
你们在做这种联系的时候

53:38.100 --> 53:40.100
一定要可以把它想象得夸张一点

53:40.100 --> 53:42.100
网络请求可能要一年

53:42.100 --> 53:43.100
才能完成

53:44.100 --> 53:47.100
这样子有助于理解网络是一步

53:47.100 --> 53:48.100
这一点

53:48.100 --> 53:49.100
其他都没有什么好说的了

53:50.100 --> 53:51.100
同学们下来之后

53:51.100 --> 53:52.100
把这三个页面都去写一些

53:52.100 --> 53:53.100
练一点

53:53.100 --> 53:54.100
熟悉一下

53:54.100 --> 53:55.100
主要是熟悉一下

53:55.100 --> 53:56.100
废起API

53:56.100 --> 53:57.100
咱们下一个开始

53:57.100 --> 53:59.100
就开始来做一个完整的项目了

