WEBVTT

00:00.300 --> 00:02.300
好 同学们 我是袁老师

00:02.300 --> 00:07.300
那么你们现在的学习已经到了最后的冲刺阶段了

00:07.300 --> 00:11.300
我们的目标就是要学习这一块框架

00:11.300 --> 00:13.300
但是在学习框架之前

00:13.300 --> 00:16.300
如果说你一点工程化的知识都没有的话

00:16.300 --> 00:19.300
那学习这个框架是非常非常困难的

00:19.300 --> 00:21.300
因此我们在学习框架之前

00:21.300 --> 00:23.300
是要学习一些工程化的知识

00:23.300 --> 00:25.300
而工程化这一块的东西呢

00:25.300 --> 00:29.300
其实最重要的就是模块化和包管理器

00:29.300 --> 00:31.300
因为这两块东西啊

00:31.300 --> 00:34.300
跟你们将来天天写的单码都有关系

00:34.300 --> 00:36.300
你们写单码的时候

00:36.300 --> 00:39.300
几乎是天天都要用到这两块的知识

00:39.300 --> 00:42.300
所以说这两块是你们学习工程化的重点

00:42.300 --> 00:44.300
那么后边这个东西呢

00:44.300 --> 00:46.300
你跟着过一遍就可以了

00:46.300 --> 00:48.300
了解一下就OK了

00:48.300 --> 00:50.300
而前面两个东西是重点

00:50.300 --> 00:53.300
前面两个东西呢 并不复杂

00:53.300 --> 00:55.300
而且呢我们可以很快速地掌握它

00:55.300 --> 00:57.300
我们今天学习模块化

00:57.300 --> 00:59.300
明天的学习这个保管理器

00:59.300 --> 01:01.300
那就OK了

01:01.300 --> 01:03.300
好了 我们大概介绍一下

01:03.300 --> 01:05.300
目前的学习进度和学习的知识结构

01:05.300 --> 01:09.300
接下来我们进入模块化的学习

01:09.300 --> 01:11.300
那么我们首先呢

01:11.300 --> 01:14.300
给大家提一个问题啊

01:14.300 --> 01:16.300
就说你们之前呢

01:16.300 --> 01:18.300
写过很多的戒指文件了

01:18.300 --> 01:20.300
就是我们做了一些小的效果

01:20.300 --> 01:21.300
对吧 各种的

01:21.300 --> 01:24.300
轮波图啊 什么下纳列表啊

01:24.300 --> 01:26.300
几年下纳列表之类的一些效果

01:26.300 --> 01:28.300
我们写过很多的戒指文件

01:28.300 --> 01:30.300
那么我想问大家一个问题

01:30.300 --> 01:32.300
这个戒指文件

01:32.300 --> 01:35.300
你能够掌控多少行的代码

01:35.300 --> 01:37.300
就啥意思呢

01:37.300 --> 01:39.300
就是你觉得你这个戒指文件

01:39.300 --> 01:42.300
超过了代码数量 超过了多少行过后

01:42.300 --> 01:46.300
你就很难阅读 很难维护 很难掌控它了

01:46.300 --> 01:48.300
你觉得你能掌控多少行

01:48.300 --> 01:51.300
一百行 两百行 三百行

01:51.300 --> 01:53.300
实际上是这样子

01:54.300 --> 01:57.300
一个正常的开发者

01:57.300 --> 01:59.300
一个普通的开发者

01:59.300 --> 02:01.300
对单个代码文件

02:01.300 --> 02:04.300
如果说它的代码在五百行以内

02:04.300 --> 02:06.300
我们是可以掌控的

02:06.300 --> 02:09.300
如果说当然你们现在还是学生嘛

02:09.300 --> 02:10.300
可能掌控能力弱一点

02:10.300 --> 02:13.300
可能在两百行以内 三百行以内

02:13.300 --> 02:16.300
一旦超过了一定的行数

02:16.300 --> 02:18.300
代码数量一旦多起来

02:18.300 --> 02:20.300
以用单个戒指文件

02:20.300 --> 02:22.300
就很难很难掌控的

02:23.300 --> 02:25.300
所有人都是这样子 我也是这样子

02:25.300 --> 02:27.300
包括一些大神也是这样子

02:27.300 --> 02:29.300
他们可能掌控的行数多一点

02:29.300 --> 02:31.300
但是呢 他们都不希望看到

02:31.300 --> 02:33.300
单个代码文件

02:33.300 --> 02:35.300
装载了太多的代码

02:35.300 --> 02:37.300
因为代码数量一旦多起来

02:37.300 --> 02:39.300
你这个代码首先阅读性就不好

02:39.300 --> 02:41.300
你要不停的去

02:41.300 --> 02:44.300
用滚动条去切换到相应的位置

02:44.300 --> 02:46.300
很难看

02:46.300 --> 02:48.300
第二 你这个代码数量多起来的话

02:48.300 --> 02:50.300
你的功能一定很扎

02:50.300 --> 02:53.300
一块另一块功能 你很难去寻找

02:53.300 --> 02:55.300
因此呢 我们往往希望

02:55.300 --> 02:58.300
单个代码文件 代码不要太多

02:58.300 --> 03:00.300
少一点

03:00.300 --> 03:01.300
那么问题就来了

03:01.300 --> 03:03.300
我有一个工程

03:03.300 --> 03:04.300
这工程可能很复杂

03:04.300 --> 03:06.300
比较一个很复杂的页面

03:06.300 --> 03:07.300
很大的页面

03:07.300 --> 03:09.300
就参考一些微博页面

03:09.300 --> 03:11.300
比方说知乎的首页

03:11.300 --> 03:12.300
比方说微博首页

03:12.300 --> 03:14.300
那么像这些页面的东西

03:14.300 --> 03:15.300
特别特别多

03:15.300 --> 03:16.300
又比较复杂

03:16.300 --> 03:18.300
那么必定导致

03:18.300 --> 03:19.300
代码很多

03:19.300 --> 03:21.300
那代码多了怎么办

03:21.300 --> 03:22.300
我一个文件

03:22.300 --> 03:24.300
如果全部寻到一个文件里边

03:24.300 --> 03:25.300
是不是很难掌控

03:25.300 --> 03:26.300
大概怎么办

03:26.300 --> 03:28.300
分成多个文件

03:28.300 --> 03:29.300
对不对

03:29.300 --> 03:31.300
那么我们就完全可以把它分成

03:31.300 --> 03:33.300
一个文件 另一个文件

03:33.300 --> 03:37.000
另一个文件

03:37.000 --> 03:39.000
然后再来一个文件

03:39.000 --> 03:41.000
可以把它分成很多很多个文件

03:41.000 --> 03:43.000
但是你这样以来的话

03:43.000 --> 03:45.000
又会造成一个新的问题

03:45.000 --> 03:47.000
你觉得会有造成什么问题

03:47.000 --> 03:49.000
大家可以思考一下

03:49.000 --> 03:51.000
如果代码文件多了

03:51.000 --> 03:53.000
又会造成什么问题

03:53.000 --> 03:56.400
什么问题呢

03:56.400 --> 03:57.400
你代码文件多了

03:57.400 --> 04:00.400
你就会导致两个问题的产生

04:00.400 --> 04:02.400
第一个问题

04:02.400 --> 04:09.270
就是全局变量污染的问题

04:09.270 --> 04:10.270
啥意思

04:10.270 --> 04:11.270
比方说

04:11.270 --> 04:13.270
我这个Adder GS

04:13.270 --> 04:16.270
我这个GS就负责提供一些函数

04:16.270 --> 04:20.270
提供一些工具函数

04:20.270 --> 04:23.270
给其他GS使用

04:23.270 --> 04:26.270
那我是不是得污染全局变量

04:26.270 --> 04:27.270
你不污染全局变量

04:27.270 --> 04:29.270
其他GS是怎么使用的

04:29.270 --> 04:31.270
所以有个全局变量污染的问题

04:31.270 --> 04:33.270
比方说我提供一个函数

04:33.270 --> 04:35.270
我这里定一个函数

04:35.270 --> 04:36.270
得到一个水积数

04:36.270 --> 04:38.270
我跟这里写一个面

04:38.270 --> 04:39.270
写一个max

04:39.270 --> 04:41.270
给我两个范围

04:41.270 --> 04:42.270
一个最小值

04:42.270 --> 04:43.270
一个最大值

04:43.270 --> 04:44.270
我给你返回一个

04:44.270 --> 04:46.270
在此之间的一个水积函数

04:46.270 --> 04:47.270
那么这里

04:47.270 --> 04:49.270
我就是定了一个全局变量

04:49.270 --> 04:51.270
我们要用这种方式

04:51.270 --> 04:52.270
加到什么

04:52.270 --> 04:54.270
加到Windows里面

04:54.270 --> 04:55.270
对不对

04:55.270 --> 04:56.270
因为这样子

04:56.270 --> 04:57.270
加到Windows里面

04:57.270 --> 04:58.270
其他GS是什么可以用的

04:58.270 --> 05:00.270
可以用函数了

05:00.270 --> 05:02.270
但是你想

05:02.270 --> 05:03.270
你在写GS的时候

05:03.270 --> 05:05.270
你给函数取什么名字

05:05.270 --> 05:08.970
你说GGS不是挺好的吗

05:08.970 --> 05:10.970
但是你担不担心

05:10.970 --> 05:11.970
你担不担心

05:11.970 --> 05:13.970
别的GS也用了这个名字

05:13.970 --> 05:14.970
它也有一个全局变量

05:14.970 --> 05:16.970
它也是给GS

05:16.970 --> 05:17.970
因为我们的页面上

05:17.970 --> 05:19.970
用了GS非常非常多

05:19.970 --> 05:21.970
有些GS是别的同时写的

05:21.970 --> 05:22.970
你搞不清楚

05:22.970 --> 05:23.970
它用了什么样的全局变量

05:23.970 --> 05:25.970
所以就造成这么一个问题

05:25.970 --> 05:26.970
你连定义的变量

05:26.970 --> 05:28.970
你都不敢定义了

05:28.970 --> 05:30.970
这是第一个问题

05:30.970 --> 05:32.970
那么第二个问题

05:32.970 --> 05:35.970
就是依赖

05:35.970 --> 05:38.970
依赖混乱的问题

05:38.970 --> 05:39.970
为什么呢

05:39.970 --> 05:40.970
就是我们现在

05:40.970 --> 05:41.970
GS很多

05:41.970 --> 05:42.970
我这里就写了四个

05:42.970 --> 05:43.970
实际上

05:43.970 --> 05:45.970
我们真实的一个项目里边

05:45.970 --> 05:46.970
这个GS有好多少呢

05:46.970 --> 05:48.970
就有可能写出

05:48.970 --> 05:49.970
一百多个

05:49.970 --> 05:50.970
二百多个

05:50.970 --> 05:52.970
甚至上千个

05:52.970 --> 05:53.970
一些大的项目

05:53.970 --> 05:54.970
好几千个

05:54.970 --> 05:56.970
都是完全有可能的

05:56.970 --> 05:57.970
那里说的一个页面上

05:57.970 --> 06:00.970
引用的顺序是什么

06:00.970 --> 06:01.970
因为有可能

06:01.970 --> 06:03.970
B点GS用到了A

06:03.970 --> 06:05.970
C它又用到了B

06:05.970 --> 06:07.970
C它又用到了A

06:07.970 --> 06:12.970
然后D又用到了B

06:12.970 --> 06:14.970
就是当我们的依赖

06:14.970 --> 06:15.970
非常复杂的时候

06:15.970 --> 06:16.970
依赖的深度

06:16.970 --> 06:17.970
非常深的时候

06:17.970 --> 06:18.970
形成了一个依赖链过后

06:18.970 --> 06:20.970
那我们的引用顺序

06:20.970 --> 06:22.970
该怎么去引用

06:22.970 --> 06:24.970
你就很难处理

06:24.970 --> 06:25.970
你不要认为这个问题

06:25.970 --> 06:27.970
是一个小问题

06:27.970 --> 06:30.970
在以前没有模块化的年代

06:30.970 --> 06:31.970
让前端开发者

06:31.970 --> 06:32.970
其实那个时候

06:32.970 --> 06:34.970
前端开发者写GS还少

06:34.970 --> 06:35.970
那个豪楼GS

06:35.970 --> 06:36.970
还是后端开发者写的

06:36.970 --> 06:37.970
我当时做后端

06:37.970 --> 06:39.970
也写过GS

06:39.970 --> 06:41.970
那个依赖关系混乱

06:41.970 --> 06:42.970
真的是非常非常头痛

06:42.970 --> 06:44.970
一般上只要引一大堆GS

06:44.970 --> 06:45.970
先引哪个

06:45.970 --> 06:46.970
再引哪个

06:46.970 --> 06:47.970
后来加了一个GS

06:47.970 --> 06:49.970
我都不知道放哪了

06:49.970 --> 06:50.970
所以说这两个问题

06:50.970 --> 06:51.970
就导致了

06:51.970 --> 06:53.970
我们以前的前端程序

06:53.970 --> 06:55.970
就不可能太复杂

06:55.970 --> 06:57.970
不是说它不能复杂

06:57.970 --> 06:59.970
像你们学的这些知识

06:59.970 --> 07:01.970
学的网络学的阿迦克斯

07:01.970 --> 07:02.970
那么其实已经可以

07:02.970 --> 07:03.970
做很复杂的东西了

07:03.970 --> 07:04.970
但是以前的前端程序

07:04.970 --> 07:06.970
不能太复杂了

07:06.970 --> 07:07.970
因为一旦复杂

07:07.970 --> 07:08.970
这个工程就管理不了了

07:08.970 --> 07:09.970
这个代码时间

07:09.970 --> 07:11.970
结构就不好划分了

07:11.970 --> 07:13.970
直到什么时候出现了

07:13.970 --> 07:15.970
直到模块化出现

07:15.970 --> 07:16.970
才解决了这个问题

07:16.970 --> 07:17.970
让我们的前端程序

07:17.970 --> 07:19.970
一下子可以写很复杂

07:19.970 --> 07:21.970
很大的一个应用

07:21.970 --> 07:22.970
那么我们这一刻

07:22.970 --> 07:24.970
就开始来学习这个模块化

07:24.970 --> 07:25.970
它是怎么做的

07:25.970 --> 07:26.970
模块化的出现

07:26.970 --> 07:28.970
就让我们可以把GS

07:28.970 --> 07:31.970
分成很多很多细小的文件

07:31.970 --> 07:33.970
你不要认为文件多了就复杂

07:33.970 --> 07:34.970
实际上文件多了

07:34.970 --> 07:36.970
反而变得简单了

07:36.970 --> 07:38.970
每个文件就做一件事

07:38.970 --> 07:40.970
比方说你们以前

07:40.970 --> 07:41.970
做一个小效果

07:41.970 --> 07:42.970
已经过了内观了

07:42.970 --> 07:43.970
已经没有什么问题了

07:43.970 --> 07:45.970
或者是写一个小的函数

07:45.970 --> 07:46.970
都是比较简单的

07:46.970 --> 07:48.970
而一个大的复杂的系统

07:48.970 --> 07:50.970
往往都是有这些小的东西

07:50.970 --> 07:51.970
一个一个组成的

07:51.970 --> 07:52.970
我们只要能够

07:52.970 --> 07:54.970
把这些小的东西分开

07:54.970 --> 07:57.970
让一些一个同事

07:57.970 --> 07:59.970
负责一些小的GS文件

07:59.970 --> 08:01.970
一个同事负责一些小的GS文件

08:01.970 --> 08:02.970
我们慢慢的

08:02.970 --> 08:03.970
一个GS文件

08:03.970 --> 08:04.970
一个GS文件

08:04.970 --> 08:05.970
编写就像做题一样

08:05.970 --> 08:06.970
一道题一道题

08:06.970 --> 08:07.970
做完了

08:07.970 --> 08:08.970
整个系统就完成了

08:08.970 --> 08:09.970
那么这样子

08:09.970 --> 08:12.970
反而把事情变得简单了

08:12.970 --> 08:14.970
模块化就要起这么一个作用

08:14.970 --> 08:16.970
当然它要解决

08:16.970 --> 08:17.970
分成很多文件过后

08:17.970 --> 08:19.970
产生了全面让污染问题

08:19.970 --> 08:21.970
和一旦混乱的问题

08:21.970 --> 08:22.970
我们来看一下

08:22.970 --> 08:24.970
我们如何来使用模块化

08:24.970 --> 08:26.970
能切分文件

08:26.970 --> 08:27.970
那么这里首先

08:27.970 --> 08:29.970
给它介绍的第一个知识

08:29.970 --> 08:32.970
就是模块化

08:32.970 --> 08:33.970
你们不用记

08:33.970 --> 08:34.970
因为这些东西

08:34.970 --> 08:35.970
都在课堂笔记里面

08:35.970 --> 08:37.970
我只是没有把课堂笔记

08:37.970 --> 08:39.970
打开按钮它来讲

08:39.970 --> 08:40.970
都在这里面

08:40.970 --> 08:41.970
你们下来可以自己看一下

08:41.970 --> 08:42.970
我这里就按照

08:42.970 --> 08:44.970
我的节奏来讲

08:44.970 --> 08:50.970
模块化的标准分类

08:50.970 --> 08:54.470
你现在目前

08:54.470 --> 08:55.470
模块化有两种标准

08:55.470 --> 08:56.470
什么叫标准

08:56.470 --> 08:57.470
就是说

08:57.470 --> 08:58.470
我跟你说

08:58.470 --> 08:59.470
你应该怎么样的

08:59.470 --> 09:00.470
用什么样的代码

09:00.470 --> 09:02.470
来实现这个模块化的功能

09:02.470 --> 09:04.470
那么目前有两种方式

09:04.470 --> 09:05.470
一种叫做

09:05.470 --> 09:07.470
common介石

09:07.470 --> 09:09.470
又简称为setment

09:09.470 --> 09:12.470
它是一个社区标准

09:12.470 --> 09:14.470
就是官方

09:14.470 --> 09:15.470
也是官方

09:15.470 --> 09:16.470
它一直不搞

09:16.470 --> 09:18.470
那个模块化标准出来

09:18.470 --> 09:20.470
因此我们明显

09:20.470 --> 09:22.470
实在是受不了了

09:22.470 --> 09:24.470
因此在前端社区

09:24.470 --> 09:26.470
就形成了这么一个

09:26.470 --> 09:27.470
社区标准

09:27.470 --> 09:29.470
叫common介石

09:29.470 --> 09:30.470
目前

09:30.470 --> 09:31.470
common介石这个标准

09:31.470 --> 09:33.470
还有很多程序在用

09:33.470 --> 09:36.470
因此我们还是必须要学习的

09:36.470 --> 09:37.470
我们这节课

09:37.470 --> 09:38.470
就学习的是

09:38.470 --> 09:39.470
common介石

09:39.470 --> 09:40.470
我们今天不是学习模块化吗

09:40.470 --> 09:41.470
我们就学习两个

09:41.470 --> 09:43.470
一个是common介石

09:43.470 --> 09:44.470
一个是下节课的

09:44.470 --> 09:45.470
官方标准

09:45.470 --> 09:46.470
叫做

09:46.470 --> 09:48.470
ES模具

09:48.470 --> 09:49.470
模具什么意思

09:49.470 --> 09:50.470
就是模块化的意思

09:50.470 --> 09:51.470
ES是什么

09:51.470 --> 09:53.470
就是我们的ecma script

09:53.470 --> 09:55.470
那么我们把它简称为

09:55.470 --> 09:56.470
ESM

09:56.470 --> 09:58.470
它是官方标准

09:58.470 --> 10:00.470
官方标准是后来出来的

10:00.470 --> 10:02.470
社区标准出现的时间比较早

10:02.470 --> 10:04.470
我们这节课学习

10:04.470 --> 10:05.470
common介石

10:05.470 --> 10:07.470
下节课学习ESM

10:07.470 --> 10:08.470
你们以后

10:08.470 --> 10:10.470
以后我们到底哪一个

10:10.470 --> 10:11.470
用的多呢

10:11.470 --> 10:14.470
肯定是官方标准用的多

10:14.470 --> 10:16.470
但是common介石你肯定

10:16.470 --> 10:18.470
会接触的

10:18.470 --> 10:19.470
肯定会接触的

10:19.470 --> 10:20.470
它虽然用的少一点

10:20.470 --> 10:21.470
应该说

10:21.470 --> 10:22.470
百分之

10:22.470 --> 10:23.470
它占百分之十

10:23.470 --> 10:24.470
它占百分之九十

10:24.470 --> 10:26.470
应该是这么一个结构

10:26.470 --> 10:27.470
两个都还是得学

10:27.470 --> 10:28.470
而且面试体里面

10:28.470 --> 10:30.470
common介石也问的比较多

10:30.470 --> 10:32.470
虽然说我们现在还不着急

10:32.470 --> 10:34.470
去讲面试体里面的一些

10:34.470 --> 10:35.470
作题的方式 细节

10:35.470 --> 10:36.470
我们之后会有专门

10:36.470 --> 10:38.470
在最后的阶段

10:38.470 --> 10:40.470
在专门来讲这个面试体

10:40.470 --> 10:41.470
就准备这一会

10:41.470 --> 10:42.470
大家讲面试体

10:42.470 --> 10:43.470
现在不着急

10:43.470 --> 10:44.470
但是我们现在

10:44.470 --> 10:46.470
common介石你至少知道怎么会用

10:46.470 --> 10:47.470
怎么去用它

10:47.470 --> 10:49.470
用它其实非常简单

10:51.470 --> 10:52.470
那么我们来开始来看

10:52.470 --> 10:53.470
这个common介石

10:53.470 --> 10:54.470
首先我要告诉大家

10:54.470 --> 10:56.470
common介石的模块化标准的

10:56.470 --> 10:59.470
它必须在漏的环境

11:01.470 --> 11:02.470
漏的环境才支持

11:02.470 --> 11:04.470
也就是说你在浏览器里面用

11:04.470 --> 11:06.470
不行了

11:06.470 --> 11:09.470
那原来说那我又不开发漏的

11:09.470 --> 11:10.470
对吧

11:10.470 --> 11:11.470
漏的我又没有学过

11:11.470 --> 11:12.470
我不开发这个漏的

11:12.470 --> 11:15.470
我干嘛要去学习这个common介石呢

11:15.470 --> 11:18.470
是因为这个样子

11:18.470 --> 11:20.470
我这里也不太好给你解释

11:20.470 --> 11:22.470
因为你们要学到

11:22.470 --> 11:23.470
这的话你才明白

11:23.470 --> 11:24.470
要学到后边这个

11:24.470 --> 11:27.470
构建工具这一块你才明白

11:27.470 --> 11:28.470
那现在你不用管

11:28.470 --> 11:29.470
我就告诉

11:29.470 --> 11:31.470
我就不会骗你的

11:31.470 --> 11:32.470
这个common介石

11:32.470 --> 11:34.470
你肯定还要知道

11:34.470 --> 11:36.470
肯定至少要会用

11:36.470 --> 11:38.470
然后后边有些代码你才能写

11:38.470 --> 11:40.470
我就给你说到这

11:40.470 --> 11:42.470
至于漏的环境的代码

11:42.470 --> 11:43.470
你是不用写的

11:43.470 --> 11:44.470
但是common介石

11:44.470 --> 11:45.470
你还是必须要学习

11:45.470 --> 11:46.470
至于为什么呢

11:46.470 --> 11:48.470
看了构建工具你就明白了

11:48.470 --> 11:49.470
那么现在呢

11:49.470 --> 11:52.470
由于我们还没有学习构建工具

11:52.470 --> 11:54.470
它又这个common介石的模块化

11:54.470 --> 11:56.470
又只支持漏的环境

11:56.470 --> 11:57.470
所以说我们这里

11:57.470 --> 11:59.470
就必须安装漏的环境

11:59.470 --> 12:00.470
在漏的环境里面

12:00.470 --> 12:02.470
给你们掩饰common介石

12:02.470 --> 12:03.470
怎么去使用

12:03.470 --> 12:04.470
那么这里呢

12:04.470 --> 12:06.470
就设计到一个安装漏的

12:06.470 --> 12:08.470
漏的我相信大家其实都已经安装了

12:08.470 --> 12:10.470
保险体现了

12:10.470 --> 12:12.470
你可以打开你的中端

12:12.470 --> 12:13.470
来看一下你的漏的

12:13.470 --> 12:15.470
是不是已经安装好了

12:15.470 --> 12:17.470
比方说在中端里面输入一个mini

12:17.470 --> 12:19.470
叫做load.v

12:19.470 --> 12:21.470
输入这个mini

12:21.470 --> 12:22.470
这样子是查看

12:22.470 --> 12:24.470
你目前漏的版本

12:24.470 --> 12:27.470
如果说你这边输出这么一种格式

12:27.470 --> 12:28.470
你们那边的版本

12:28.470 --> 12:29.470
可能跟我的不一样

12:29.470 --> 12:30.470
没关系

12:30.470 --> 12:31.470
没有任何关系

12:31.470 --> 12:32.470
不影响学习

12:32.470 --> 12:33.470
只要你能够输出这种格式

12:33.470 --> 12:35.470
说明漏的安装成功了

12:35.470 --> 12:37.470
如果说你没有输出这种格式

12:37.470 --> 12:38.470
说明漏的呢

12:38.470 --> 12:40.470
你在电脑上呢

12:40.470 --> 12:41.470
除了一些问题

12:41.470 --> 12:42.470
或者是根本就没有安装

12:42.470 --> 12:43.470
那么你可以在这里

12:43.470 --> 12:44.470
漏的去官网

12:44.470 --> 12:49.060
去下载一个

12:49.060 --> 12:52.060
在这里下载一个长期支持吧

12:52.060 --> 12:53.060
那么接下来呢

12:53.060 --> 12:55.060
大家做的第一件事情

12:55.060 --> 12:57.060
就是查看一下

12:57.060 --> 12:59.060
漏的有没有安装

12:59.060 --> 13:01.060
没有安装下载安装

13:01.060 --> 13:02.060
下载的地址呢

13:02.060 --> 13:04.060
在我的课堂笔记里边

13:10.570 --> 13:11.570
在这儿

13:11.570 --> 13:12.570
给大家一点时间

13:12.570 --> 13:13.570
大家暂停视频

13:13.570 --> 13:15.570
先把漏的这个环境搞定

13:16.570 --> 13:17.570
搞定没

13:17.570 --> 13:18.570
搞定了吧

13:18.570 --> 13:19.570
搞定了之后呢

13:19.570 --> 13:20.570
我们接下来

13:20.570 --> 13:22.570
来掩饰一下

13:22.570 --> 13:24.570
这个漏的环境怎么去使用

13:24.570 --> 13:25.570
漏的环境呢

13:25.570 --> 13:27.570
我们有这里一张图

13:27.570 --> 13:29.570
这个图之前大家是看过的

13:29.570 --> 13:30.570
简单再看一下

13:30.570 --> 13:32.570
就是我们介石呢

13:32.570 --> 13:34.570
它是包含了一个外表API和

13:34.570 --> 13:35.570
夜视对吧

13:35.570 --> 13:36.570
夜视是教你怎么说话

13:36.570 --> 13:37.570
什么循环啊

13:37.570 --> 13:38.570
判断啊

13:38.570 --> 13:39.570
输主啊

13:39.570 --> 13:40.570
怎么写

13:40.570 --> 13:41.570
对象咋写

13:41.570 --> 13:42.570
像这些

13:42.570 --> 13:43.570
函数咋写

13:43.570 --> 13:45.570
这些就是语法规则了

13:45.570 --> 13:46.570
还有一些

13:46.570 --> 13:47.570
基本的API呢

13:47.570 --> 13:49.570
在这个夜视里面包含了

13:49.570 --> 13:50.570
然后呢

13:50.570 --> 13:51.570
还有一部分就是外表API

13:51.570 --> 13:52.570
什么DOM呀

13:52.570 --> 13:53.570
BOOM呀

13:53.570 --> 13:54.570
还有什么那个

13:54.570 --> 13:56.570
事件注册呀

13:56.570 --> 13:57.570
set time out

13:57.570 --> 13:58.570
set interview呀

13:58.570 --> 13:59.570
这些东西呢

13:59.570 --> 14:01.570
都是浏览器给你提供的

14:01.570 --> 14:03.570
那么两个合起来了

14:03.570 --> 14:04.570
就是我们的介石

14:04.570 --> 14:05.570
而漏的介石呢

14:05.570 --> 14:07.570
都是用浏览器的环境啊

14:07.570 --> 14:08.570
那漏的环境里面呢

14:08.570 --> 14:09.570
谁是差不多的

14:09.570 --> 14:10.570
夜视呢

14:10.570 --> 14:12.570
就是我们怎么去说话

14:12.570 --> 14:13.570
那么这一部分的东西

14:13.570 --> 14:14.570
是完全一样的

14:14.570 --> 14:15.570
也就是写个输主啊

14:15.570 --> 14:16.570
写个判断

14:16.570 --> 14:17.570
写个循环

14:17.570 --> 14:18.570
在漏的环境里面

14:18.570 --> 14:19.570
用介石写

14:19.570 --> 14:20.570
完全一样

14:20.570 --> 14:21.570
然后另外一部分呢

14:21.570 --> 14:22.570
就是这个东西变了

14:22.570 --> 14:24.570
它不再是浏览器的API了

14:24.570 --> 14:25.570
而是漏的API

14:25.570 --> 14:27.570
漏的API的功能非常强大

14:27.570 --> 14:28.570
可以用它开发服务器的

14:28.570 --> 14:30.570
不过我们现在还不着急啊

14:30.570 --> 14:32.570
现在还不去接触这个服务器

14:33.570 --> 14:34.570
那么这一块呢

14:34.570 --> 14:35.570
我们不用去管

14:35.570 --> 14:36.570
我们只需要知道

14:36.570 --> 14:37.570
我们的ES

14:37.570 --> 14:38.570
是在漏的环境里面

14:38.570 --> 14:39.570
可以使用的

14:40.570 --> 14:41.570
好吧

14:41.570 --> 14:42.570
那么这是漏的环境

14:42.570 --> 14:43.570
简单介绍一下

14:43.570 --> 14:44.570
那么接下来就是

14:44.570 --> 14:46.570
我们怎么去用这个漏的环境

14:47.570 --> 14:48.570
以前呢

14:48.570 --> 14:50.570
在浏览器环境里面

14:50.570 --> 14:52.570
我们得写个页面

14:52.570 --> 14:54.570
在页面上去引用介石

14:54.570 --> 14:56.570
才能去运行它

14:56.570 --> 14:57.570
运行的实际上是页面

14:57.570 --> 14:59.570
然后页面上去引用介石

14:59.570 --> 15:01.570
跑在浏览器环境里面

15:01.570 --> 15:02.570
现在有了漏的之后呢

15:02.570 --> 15:04.570
我们的介石代码

15:04.570 --> 15:05.570
可以脱离浏览器

15:05.570 --> 15:06.570
直接运行

15:06.570 --> 15:08.570
那咋运行的

15:08.570 --> 15:09.570
我们比方说

15:09.570 --> 15:10.570
到这个银盒子里面

15:10.570 --> 15:11.570
就是一个简单的事情

15:11.570 --> 15:12.570
就输出一句话

15:14.570 --> 15:15.570
输出一个

15:15.570 --> 15:16.570
Hello

15:17.570 --> 15:18.570
漏的

15:19.570 --> 15:20.570
好

15:20.570 --> 15:21.570
那么现在我要运行它

15:21.570 --> 15:23.570
不需要页面

15:23.570 --> 15:24.570
也不需要浏览器

15:24.570 --> 15:25.570
咋运行

15:25.570 --> 15:26.570
点击右键

15:26.570 --> 15:27.570
这里一个装扣

15:28.570 --> 15:29.570
点这个

15:29.570 --> 15:30.570
是不是可以看到了

15:30.570 --> 15:31.570
这个玩意大家用过吧

15:31.570 --> 15:32.570
应该用过吧

15:33.570 --> 15:35.570
输出了这个东西过后呢

15:35.570 --> 15:36.570
因为其实

15:36.570 --> 15:38.570
这就是在漏的环境里面

15:38.570 --> 15:39.570
运行出来的

15:40.570 --> 15:42.570
因此里面安装了个插件

15:42.570 --> 15:43.570
叫做扣的装那

15:44.570 --> 15:45.570
其实它就是

15:45.570 --> 15:47.570
把我们的介石代码

15:47.570 --> 15:48.570
在漏的环境里面运行

15:50.570 --> 15:51.570
大家可以试一下

15:51.570 --> 15:52.570
这个东西

15:52.570 --> 15:54.570
应该你们都用过很多次了

15:55.570 --> 15:58.570
那如果说不安装这个插件

16:00.570 --> 16:01.570
不安装这个插件

16:01.570 --> 16:02.570
我们也可以运行它

16:02.570 --> 16:03.570
怎么运行的

16:03.570 --> 16:05.570
只要我们能够打开中端

16:05.570 --> 16:07.570
进入我们当前的目录

16:07.570 --> 16:09.570
我在这里就用

16:09.570 --> 16:11.570
VSCO的集成中端了

16:12.570 --> 16:13.570
进入中端

16:13.570 --> 16:15.570
然后我们去运行一下

16:15.570 --> 16:16.570
漏的命令

16:16.570 --> 16:18.570
后边跟上我们的文件名

16:18.570 --> 16:19.570
介石文件名

16:19.570 --> 16:20.570
就是

16:20.570 --> 16:21.570
index的介石

16:22.570 --> 16:23.570
一回车

16:23.570 --> 16:24.570
就看到了

16:25.570 --> 16:26.570
大家马上试一下

16:26.570 --> 16:27.570
暂停视频

16:27.570 --> 16:29.570
用这个中端环境

16:29.570 --> 16:30.570
用漏的命令

16:30.570 --> 16:32.570
去运行一下这个介石文件

16:34.570 --> 16:35.570
好了没问题吧

16:35.570 --> 16:36.570
非常简单

16:36.570 --> 16:37.570
因此可以看到

16:37.570 --> 16:38.570
我们漏的环境里面

16:38.570 --> 16:40.570
是不需要浏览器参与的

16:40.570 --> 16:41.570
直接运行

16:41.570 --> 16:42.570
而且也写的

16:42.570 --> 16:43.570
也是介石代码

16:44.570 --> 16:46.570
那么简单的介绍了一下

16:46.570 --> 16:47.570
漏的环境

16:47.570 --> 16:49.570
现在回到我们的主题

16:50.570 --> 16:51.570
我们的主题是

16:51.570 --> 16:52.570
学习的这个

16:52.570 --> 16:53.570
common介石

16:53.570 --> 16:54.570
因为common介石

16:54.570 --> 16:56.570
必须要在漏的环境里面

16:56.570 --> 16:57.570
才能有效

16:57.570 --> 16:58.570
因此我们要安装一个

16:58.570 --> 16:59.570
准备好一个漏的环境

16:59.570 --> 17:00.570
并且要知道

17:00.570 --> 17:01.570
一个漏的环境

17:01.570 --> 17:02.570
怎么运行的

17:03.570 --> 17:04.570
好那么接下来

17:05.570 --> 17:06.570
我们来看一下

17:06.570 --> 17:07.570
common介石啥意思

17:07.570 --> 17:08.570
common介石

17:08.570 --> 17:09.570
要解决的问题

17:09.570 --> 17:10.570
其实就是我们

17:10.570 --> 17:11.570
在课堂

17:11.570 --> 17:12.570
本节课开始的时候

17:12.570 --> 17:13.570
提出的问题

17:13.570 --> 17:14.570
怎么问题呢

17:14.570 --> 17:15.570
就是我要分成

17:15.570 --> 17:16.570
多个介石文件

17:17.570 --> 17:18.570
来吧

17:18.570 --> 17:19.570
我们这里

17:19.570 --> 17:20.570
不用A了吗

17:21.570 --> 17:22.570
我们再建一个

17:22.570 --> 17:23.570
叫做mess

17:23.570 --> 17:24.570
叫介石

17:25.570 --> 17:26.570
我们分割一下

17:30.900 --> 17:31.900
现在有两个介石文件

17:32.900 --> 17:33.900
那么因这个

17:33.900 --> 17:34.900
介石文件

17:34.900 --> 17:35.900
它充当的指责

17:35.900 --> 17:36.900
当然文件名是

17:36.900 --> 17:37.900
随便命的

17:37.900 --> 17:38.900
它充当的指责

17:38.900 --> 17:39.900
就是

17:39.900 --> 17:40.900
叫做

17:40.900 --> 17:41.900
启动文件

17:41.900 --> 17:43.900
什么叫启动文件

17:43.900 --> 17:44.900
就是我在命令行里边

17:44.900 --> 17:45.900
通过漏的

17:45.900 --> 17:46.900
运行的文件

17:46.900 --> 17:48.900
这个叫做启动文件

17:49.900 --> 17:50.900
或者叫做入口文件

17:50.900 --> 17:51.900
入口文件

17:51.900 --> 17:53.900
漏的环境跟浏览器不一样

17:53.900 --> 17:54.900
浏览器可以在页面上

17:54.900 --> 17:55.900
引用多个介石

17:55.900 --> 17:56.900
但是漏的里边

17:56.900 --> 17:57.900
只能运行一个介石

17:58.900 --> 17:59.900
这样吧

17:59.900 --> 18:00.900
那么现在

18:00.900 --> 18:01.900
我们做个

18:01.900 --> 18:02.900
这个就是启动文件

18:02.900 --> 18:03.900
就是通过漏的命令

18:03.900 --> 18:04.900
写详细点

18:04.900 --> 18:06.900
通过漏的命令

18:06.900 --> 18:08.900
运行的文件

18:09.900 --> 18:11.900
另外一个mess.js

18:11.900 --> 18:12.900
我们举个例子

18:12.900 --> 18:13.900
我们通过这个例子

18:13.900 --> 18:14.900
来说明这个common介石

18:14.900 --> 18:16.900
这个文件

18:16.900 --> 18:18.900
它是提供一些

18:18.900 --> 18:21.900
数学相关的函数

18:21.900 --> 18:22.900
我们要编写的

18:22.900 --> 18:24.900
就是模拟我们在真实项目里边

18:24.900 --> 18:26.900
把很多事情的

18:26.900 --> 18:27.900
拆分成不同的文件去处理

18:28.900 --> 18:29.900
那么现在呢

18:29.900 --> 18:30.900
大家跟着我做

18:30.900 --> 18:32.900
建立好两个文件

18:32.900 --> 18:34.900
index.js和mess.js

18:35.900 --> 18:36.900
没问题吧

18:36.900 --> 18:37.900
那么接下来

18:37.900 --> 18:39.900
我们要开始来书写了

18:39.900 --> 18:41.900
第一个

18:42.900 --> 18:43.900
mess.js里边

18:43.900 --> 18:44.900
比方说

18:44.900 --> 18:46.900
我要提供两个函数

18:46.900 --> 18:48.900
给别的介石文件使用

18:49.900 --> 18:50.900
提供哪两个函数呢

18:50.900 --> 18:51.900
一个函数呢

18:51.900 --> 18:52.900
是判断一个数

18:53.900 --> 18:54.900
是不是击数

18:54.900 --> 18:56.900
做一个非常简单的函数

18:56.900 --> 18:57.900
比方说

18:57.900 --> 18:58.900
我们这里来定一个const

18:58.900 --> 19:00.900
或者叫做方形

19:01.900 --> 19:02.900
isOd

19:02.900 --> 19:03.900
是不是击数

19:03.900 --> 19:04.900
结果一个数字n

19:04.900 --> 19:06.900
我来判断它是不是击数

19:06.900 --> 19:07.900
是不是很简单

19:07.900 --> 19:08.900
反而这个n除以2的渔数

19:08.900 --> 19:10.900
是不是不等于0就行了

19:10.900 --> 19:12.900
不等于0就是击数

19:12.900 --> 19:14.900
所以提供了一个函数

19:14.900 --> 19:15.900
然后第二个

19:15.900 --> 19:17.900
我们还要提供一个函数叫做

19:18.900 --> 19:20.900
上求和

19:20.900 --> 19:21.900
你给我两个数 a和b

19:21.900 --> 19:23.900
我给你返回一个a和b之合

19:24.900 --> 19:25.900
大家跟着我写一遍

19:25.900 --> 19:27.900
把这两个函数写出来

19:29.900 --> 19:30.900
写出来了没

19:30.900 --> 19:31.900
接下来

19:31.900 --> 19:33.900
我们现在在index.js文件里边

19:33.900 --> 19:35.900
你看我们就要模拟现实情况

19:35.900 --> 19:36.900
有多个文件

19:36.900 --> 19:37.900
我这个文件里边

19:37.900 --> 19:39.900
要用到这个文件里边的东西

19:39.900 --> 19:40.900
过去怎么用的

19:40.900 --> 19:42.900
过去是不是要污染权具面料

19:42.900 --> 19:43.900
你看我这样定义函数

19:43.900 --> 19:45.900
是不是就污染权具面料

19:45.900 --> 19:46.900
污染权具面料

19:46.900 --> 19:47.900
我是不是这边

19:47.900 --> 19:48.900
是不是就可以直接使用了

19:48.900 --> 19:49.900
对吧

19:50.900 --> 19:51.900
肯定是做不到的

19:51.900 --> 19:52.900
R的漏的环境里边

19:52.900 --> 19:54.900
比方说在index.js

19:54.900 --> 19:55.900
这里边我们

19:55.900 --> 19:56.900
输出一下e4-2的

19:56.900 --> 19:57.900
看一下行不行

20:00.540 --> 20:01.540
从那里边我们运行漏的

20:01.540 --> 20:02.540
这些也是

20:03.540 --> 20:04.540
是不是报错了

20:04.540 --> 20:07.540
e4-2 is not defined

20:07.540 --> 20:09.540
根本就没有定义

20:10.540 --> 20:11.540
啥意思

20:11.540 --> 20:12.540
也就是根本不存在

20:12.540 --> 20:13.540
这个e4-2

20:15.540 --> 20:17.540
那么这一块我

20:17.540 --> 20:18.540
就要给你说一下

20:18.540 --> 20:20.540
在漏的环境里边

20:20.540 --> 20:21.540
你听好了

20:21.540 --> 20:27.410
先解

20:27.410 --> 20:28.410
规范

20:29.410 --> 20:31.410
就是我们的common.js

20:31.410 --> 20:32.410
它有哪些规范

20:32.410 --> 20:33.410
第一个规范

20:33.410 --> 20:35.410
因为目前的

20:35.410 --> 20:36.410
只有漏的环境

20:36.410 --> 20:37.410
支持的common.js

20:37.410 --> 20:38.410
它们是结合的

20:38.410 --> 20:39.410
非常紧密的

20:39.410 --> 20:40.410
所以说common.js的规范

20:40.410 --> 20:41.410
是被漏的完整实现了的

20:42.410 --> 20:43.410
它第一个规范就是

20:43.410 --> 20:45.410
所有的js文件

20:45.410 --> 20:47.410
均是一个模块

20:48.410 --> 20:49.410
什么样的模块

20:49.410 --> 20:50.410
模块就是一个独立的

20:50.410 --> 20:51.410
功能单元

20:51.410 --> 20:52.410
比如说一个数学模块

20:53.410 --> 20:54.410
master.js

20:54.410 --> 20:55.410
那么我们把它就

20:55.410 --> 20:56.410
作为一个

20:56.410 --> 20:57.410
专门来提供各种

20:57.410 --> 20:58.410
数学函数的模块

20:58.410 --> 20:59.410
这个index.js

20:59.410 --> 21:00.410
我们就把它作为一个

21:00.410 --> 21:01.410
专门来提供

21:01.410 --> 21:03.410
直接运行的入口模块

21:03.410 --> 21:04.410
就每一个模块

21:04.410 --> 21:06.410
都有自己的功能

21:06.410 --> 21:08.410
我们把它不同的功能

21:08.410 --> 21:10.410
就是集中在一个模块里面

21:11.410 --> 21:12.410
这样子的

21:12.410 --> 21:13.410
每个模块的代码

21:13.410 --> 21:14.410
就没有那么多

21:14.410 --> 21:15.410
比较少

21:16.410 --> 21:17.410
每个js文件都是一个模块

21:17.410 --> 21:18.410
因为我们现在

21:18.410 --> 21:19.410
目前的系统里面

21:19.410 --> 21:20.410
就两个模块

21:20.410 --> 21:21.410
master.js

21:21.410 --> 21:22.410
index.js

21:23.410 --> 21:24.410
而且

21:24.410 --> 21:25.410
我们通过load命令

21:25.410 --> 21:26.410
运行的模块

21:26.410 --> 21:27.410
叫做入口模块

21:27.410 --> 21:28.410
所以说你要知道

21:28.410 --> 21:30.410
运行的模块

21:30.410 --> 21:32.410
叫做入口模块

21:33.410 --> 21:34.410
你们不用去记

21:34.410 --> 21:35.410
不用去背这些东西

21:35.410 --> 21:36.410
我们这在课件里面都有

21:37.410 --> 21:42.410
也就是我们刚才

21:43.410 --> 21:44.410
load index.js

21:44.410 --> 21:46.410
哪个是入口模块

21:46.410 --> 21:47.410
哪个

21:47.410 --> 21:48.410
是不是它

21:48.410 --> 21:49.410
对不对

21:49.410 --> 21:50.410
它就是入口模块

21:51.410 --> 21:53.410
也就是说我们运行的时候

21:53.410 --> 21:55.410
它只运行了

21:55.410 --> 21:56.410
只运行了index.js

21:56.410 --> 21:57.410
它又没有运行

21:58.410 --> 21:59.410
我们这里比方说

21:59.410 --> 22:00.410
去输出一个

22:01.410 --> 22:02.410
master

22:02.410 --> 22:03.410
它又会不会有运行

22:03.410 --> 22:04.410
它不会运行的

22:05.410 --> 22:06.410
有没有输出这个master

22:06.410 --> 22:07.410
没有

22:07.410 --> 22:08.410
它并不会运行

22:08.410 --> 22:09.410
它只运行了

22:09.410 --> 22:11.410
我们给它指定的入口

22:11.410 --> 22:12.410
也就是说

22:12.410 --> 22:13.410
我们现在通过

22:13.410 --> 22:14.410
这个入口文件

22:15.410 --> 22:16.410
然后

22:18.410 --> 22:19.410
只运行它

22:19.410 --> 22:20.410
但是它运行的过程中

22:20.410 --> 22:21.410
我们可能会去

22:21.410 --> 22:23.410
使用到别的文件的功能

22:23.410 --> 22:25.410
应该是这么去理解

22:25.410 --> 22:26.410
好 那么接下来

22:26.410 --> 22:27.410
我们俩看

22:32.190 --> 22:33.190
第二个

22:33.190 --> 22:35.190
所有的介石文件

22:35.190 --> 22:39.190
所有的模块中的

22:39.190 --> 22:40.190
全局

22:41.190 --> 22:42.190
辨量

22:43.190 --> 22:44.190
函数

22:44.190 --> 22:45.190
均

22:45.190 --> 22:46.190
不会产生诬战

22:47.190 --> 22:48.190
这是它规范的

22:48.190 --> 22:49.190
第二个要求

22:49.190 --> 22:51.190
漏的是实现了的

22:51.190 --> 22:52.190
啥意思

22:52.190 --> 22:53.190
也就是说

22:53.190 --> 22:54.190
我们在这个index

22:54.190 --> 22:55.190
比方说我们目前的运行

22:55.190 --> 22:56.190
是它

22:56.190 --> 22:57.190
如果说它里边定一个

22:57.190 --> 22:58.190
全局辨量

22:58.190 --> 22:59.190
我们用bar来定

22:59.190 --> 23:00.190
比方说a等于1

23:01.190 --> 23:03.190
然后再定一个函数

23:03.190 --> 23:04.190
方形n

23:05.190 --> 23:06.190
那么按理说

23:06.190 --> 23:07.190
像我们过去的

23:07.190 --> 23:08.190
浏览器里边

23:08.190 --> 23:10.190
是不是在window里边

23:10.190 --> 23:11.190
就会多了一个n

23:11.190 --> 23:12.190
在window里边

23:12.190 --> 23:13.190
是不是多了一个n

23:13.190 --> 23:14.190
对不对

23:14.190 --> 23:15.190
那么我们看漏的环境里边会吧

23:15.190 --> 23:16.190
首先漏的环境里边

23:16.190 --> 23:17.190
是没有window

23:17.190 --> 23:18.190
根本就没有window

23:18.190 --> 23:20.190
你如果说输出window的话

23:20.190 --> 23:21.190
就会包错了

23:23.190 --> 23:24.190
没有window

23:24.190 --> 23:25.190
那么它里边倒是有一个

23:25.190 --> 23:26.190
全局

23:26.190 --> 23:28.190
全局对象叫做global

23:28.190 --> 23:30.190
我们来看一下global

23:30.190 --> 23:31.190
里面有没有n

23:34.910 --> 23:35.910
这里面

23:35.910 --> 23:36.910
整个就是global对象

23:36.910 --> 23:37.910
你看一下

23:37.910 --> 23:38.910
有没有没有

23:38.910 --> 23:39.910
对吧

23:39.910 --> 23:40.910
那么我们可以在这里

23:40.910 --> 23:41.910
再打印一下

23:41.910 --> 23:42.910
global

23:48.360 --> 23:49.360
是没有

23:49.360 --> 23:50.360
两个都是on define

23:50.360 --> 23:51.360
所以说

23:51.360 --> 23:52.360
我们第二个规则

23:52.360 --> 24:00.110
是没问题的对吧

24:00.110 --> 24:01.110
好

24:02.110 --> 24:03.110
第三条规则

24:08.050 --> 24:09.050
我们在模块里边

24:09.050 --> 24:11.050
它不能污染全局辨量

24:11.050 --> 24:12.050
那么就产生了一个问题

24:13.050 --> 24:14.050
我这个模块里边

24:14.050 --> 24:15.050
提供了函数

24:15.050 --> 24:17.050
我怎么给别的模块使用呢

24:18.050 --> 24:20.050
那么第三个规则就是

24:20.050 --> 24:22.050
当一个模块

24:22.050 --> 24:25.050
需要提供一些东西

24:25.050 --> 24:28.050
给别的函数使用时

24:30.810 --> 24:31.810
需要

24:31.810 --> 24:33.810
把这些东西

24:34.810 --> 24:35.810
导出

24:36.810 --> 24:37.810
有个新的概念了

24:37.810 --> 24:38.810
叫导出

24:38.810 --> 24:40.810
那么怎么来导出呢

24:40.810 --> 24:42.810
导出的方式

24:42.810 --> 24:43.810
特别简单

24:43.810 --> 24:45.810
比方说在这个文件里边

24:45.810 --> 24:46.810
我可能定义了很多

24:46.810 --> 24:47.810
内部的变量

24:47.810 --> 24:49.810
定义了abcd

24:49.810 --> 24:50.810
那么像这些变量

24:50.810 --> 24:52.810
会不会污染其他模块

24:52.810 --> 24:53.810
会不会对其他模块

24:53.810 --> 24:54.810
造成影响

24:54.810 --> 24:56.810
完全不会

24:56.810 --> 24:57.810
我这边也可以定义abcd

24:57.810 --> 24:59.810
你这边也可以定义abcd

24:59.810 --> 25:01.810
我们互补冲突

25:01.810 --> 25:02.810
是不是

25:02.810 --> 25:03.810
这样的一个环境之后

25:03.810 --> 25:04.810
首先我在写

25:04.810 --> 25:05.810
介石文件的时候

25:05.810 --> 25:07.810
我不用担心了

25:07.810 --> 25:08.810
我爱定义啥变量

25:08.810 --> 25:09.810
就定义啥变量

25:09.810 --> 25:10.810
无所谓

25:10.810 --> 25:11.810
根本就不会冲突

25:11.810 --> 25:13.810
完全不会冲突

25:13.810 --> 25:14.810
所以说呢

25:14.810 --> 25:16.810
首先这个问题就解决了

25:16.810 --> 25:17.810
那么另一个问题就出现了

25:17.810 --> 25:18.810
就是我怎么样

25:18.810 --> 25:20.810
把这两个函数给它使用了

25:20.810 --> 25:21.810
我可能里边

25:21.810 --> 25:22.810
还有一些很多函数

25:22.810 --> 25:23.810
但是我不想

25:23.810 --> 25:24.810
把所有东西给它

25:24.810 --> 25:25.810
我们只需要

25:25.810 --> 25:26.810
把这两个给它就行了

25:26.810 --> 25:28.810
那怎么办呢

25:28.810 --> 25:30.810
我们非常简单

25:30.810 --> 25:31.810
就必须要导出

25:31.810 --> 25:33.810
你就再把它完成

25:33.810 --> 25:34.810
mode

25:34.810 --> 25:36.810
模块

25:36.810 --> 25:37.810
export

25:37.810 --> 25:38.810
导出的意思

25:38.810 --> 25:39.810
加上一个s

25:39.810 --> 25:40.810
表示复数

25:40.810 --> 25:42.810
我要可以导出很多东西

25:42.810 --> 25:44.810
那么给它复值就行了

25:44.810 --> 25:46.810
你给它复什么值

25:46.810 --> 25:48.810
你就导出了什么东西

25:48.810 --> 25:49.810
就这么简单

25:49.810 --> 25:50.810
那么比方说

25:50.810 --> 25:51.810
你给它复值为123

25:51.810 --> 25:52.810
那它导出了一个数字

25:52.810 --> 25:53.810
123

25:53.810 --> 25:55.810
你给它复值为一个abc

25:55.810 --> 25:56.810
它就导出了一个制服创

25:56.810 --> 25:57.810
abc

25:57.810 --> 25:58.810
你给它复值为一个对象

25:58.810 --> 25:59.810
它就导出了一个对象

25:59.810 --> 26:00.810
你给它复值为一个方形

26:00.810 --> 26:02.810
然后还导出了一个函数

26:02.810 --> 26:03.810
就这么简单

26:03.810 --> 26:04.810
你给它复值就行了

26:04.810 --> 26:06.810
这代码写到任何地方都可以

26:06.810 --> 26:08.810
只要这个模块运行完成

26:08.810 --> 26:09.810
完成之后

26:09.810 --> 26:11.810
它的值

26:11.810 --> 26:13.810
就是导出的东西

26:13.810 --> 26:15.810
那么现在大家想一想

26:15.810 --> 26:17.810
我现在要导出这两个函数

26:17.810 --> 26:18.810
你们开动脑筋

26:18.810 --> 26:20.810
我应该给它复值什么值

26:22.810 --> 26:24.810
你们可以自己尝试的去写一下

26:24.810 --> 26:30.490
好嘞

26:30.490 --> 26:32.490
你们怎么做的

26:32.490 --> 26:33.490
我要导出两个函数

26:33.490 --> 26:34.490
你肯定不能这样子写

26:34.490 --> 26:36.490
你要导出一个函数很简单

26:36.490 --> 26:38.490
我把这个函数给它复值就完事了

26:38.490 --> 26:40.490
那么它的值就变成一个函数

26:40.490 --> 26:43.490
这样子导出一个函数很简单

26:43.490 --> 26:44.490
它导出两个函数

26:44.490 --> 26:45.490
你不能这样子写

26:45.490 --> 26:46.490
你不能这样子写的

26:46.490 --> 26:47.490
为什么你后面的值

26:47.490 --> 26:49.490
就把前面的值给它复盖掉了

26:49.490 --> 26:50.490
对不对

26:50.490 --> 26:51.490
因为它就是一个属性

26:51.490 --> 26:52.490
它的属性的最终的值

26:52.490 --> 26:54.490
就是它导出的结果

26:54.490 --> 26:55.490
那你给它复值

26:55.490 --> 26:56.490
一开始给它复值个函数

26:56.490 --> 26:57.490
后来一该复值另一个函数

26:57.490 --> 26:59.490
所以最终它的值就是另一个函数

26:59.490 --> 27:00.490
它导出的是它

27:00.490 --> 27:01.490
而不是它

27:01.490 --> 27:02.490
所以说呢

27:02.490 --> 27:03.490
你得怎么写呢

27:03.490 --> 27:05.490
哎呀有个对象嘛

27:05.490 --> 27:06.490
对不对

27:06.490 --> 27:08.490
对象里面是不是可以有很多属性

27:08.490 --> 27:10.490
我可以这里写个一字二的

27:12.490 --> 27:13.490
然后呢

27:13.490 --> 27:14.490
上

27:14.490 --> 27:15.490
对吧

27:15.490 --> 27:16.490
是不是可以这样子写

27:16.490 --> 27:17.490
是不是导出了一个对象

27:17.490 --> 27:18.490
对象里面两个属性

27:18.490 --> 27:19.490
第一个属性是一个函数

27:19.490 --> 27:20.490
第二个属性也是一个函数

27:20.490 --> 27:21.490
对吧

27:21.490 --> 27:22.490
就导出了

27:22.490 --> 27:23.490
大家写一遍

27:23.490 --> 27:24.490
现在我们就

27:24.490 --> 27:25.490
一旧代码

27:25.490 --> 27:26.490
就完成了

27:26.490 --> 27:28.490
对这个模块里面东西的导出

27:28.490 --> 27:29.490
跟着写一遍

27:29.490 --> 27:31.990
暂停视频

27:31.990 --> 27:32.990
好了没

27:32.990 --> 27:34.990
好那么这个模块导出了

27:34.990 --> 27:36.990
问题还没有解决呀

27:36.990 --> 27:38.990
因为我现在运行的是谁

27:38.990 --> 27:40.990
运行的是他呀

27:40.990 --> 27:42.990
运行的是index

27:42.990 --> 27:43.990
对吧

27:43.990 --> 27:44.990
index跟他有关系吗

27:44.990 --> 27:45.990
是不是还是没关系啊

27:45.990 --> 27:46.990
对吧

27:46.990 --> 27:47.990
index里面跟他有什么关系呢

27:47.990 --> 27:48.990
所以说

27:48.990 --> 27:50.990
现在我们还要做另外一件事

27:50.990 --> 27:52.990
就是导入

27:52.990 --> 27:57.460
当一个模块

27:57.460 --> 27:59.460
它不一定是入口模块

27:59.460 --> 28:01.460
不一定是这个启动模块

28:01.460 --> 28:02.460
我们把启动文件

28:02.460 --> 28:03.460
叫做启动模块

28:03.460 --> 28:05.460
或者叫入口模块

28:05.460 --> 28:07.460
当一个模块

28:07.460 --> 28:13.460
需要用到别的模块的东西的时候

28:13.460 --> 28:14.460
比方说

28:14.460 --> 28:16.460
它这个模块要用它

28:16.460 --> 28:17.460
干嘛呢

28:17.460 --> 28:20.150
需要导入

28:20.150 --> 28:22.150
刚才我们看到导出

28:22.150 --> 28:24.150
就当我们和导入

28:24.150 --> 28:25.150
非常的简单

28:25.150 --> 28:27.150
比方说我这个index

28:27.150 --> 28:28.150
我们要说

28:28.150 --> 28:29.150
我们运行一下

28:29.150 --> 28:32.150
index start

28:32.150 --> 28:33.150
表示入口模块开始了

28:34.150 --> 28:35.150
接下来

28:35.150 --> 28:36.150
我们要用到

28:36.150 --> 28:38.150
这个模块里面提供的

28:38.150 --> 28:39.150
一个函数

28:39.150 --> 28:40.150
可能两个函数

28:40.150 --> 28:41.150
它提供了两个函数

28:41.150 --> 28:42.150
但是我不一定要用到那么多

28:42.150 --> 28:43.150
我只需要用到这个函数

28:43.150 --> 28:45.150
那么非常简单

28:45.150 --> 28:47.150
我们只需要使用一个代码

28:47.150 --> 28:49.150
叫做require

28:49.150 --> 28:50.150
require什么意思

28:50.150 --> 28:51.150
需要

28:51.150 --> 28:52.150
我需要你

28:52.150 --> 28:53.150
对吧

28:53.150 --> 28:54.150
require

28:54.150 --> 28:56.150
里面是一个制模串

28:56.150 --> 28:58.150
这个制模串填啥呢

28:58.150 --> 29:00.150
填这个模块的路径

29:00.150 --> 29:01.150
因为我要用它

29:01.150 --> 29:02.150
所以我就填它的路径

29:02.150 --> 29:04.150
但是有一个细节要注意

29:04.150 --> 29:07.150
它的路径书写必须以

29:07.150 --> 29:10.150
底尔斜杠和

29:10.150 --> 29:12.150
底尔底尔斜杠开头

29:12.150 --> 29:17.450
这个很重要

29:17.450 --> 29:20.450
模块路径必须以

29:20.450 --> 29:23.450
底尔斜杠或

29:23.450 --> 29:26.450
底尔底尔斜杠开头

29:26.450 --> 29:27.450
因为我知道

29:27.450 --> 29:28.450
底尔斜杠表示什么意思

29:28.450 --> 29:29.450
表示当前目睹

29:29.450 --> 29:31.450
底尔斜杠反回上级目睹

29:31.450 --> 29:32.450
在浏览器里边

29:32.450 --> 29:34.450
是不是可以省略掉底尔斜杠

29:34.450 --> 29:35.450
对吧

29:35.450 --> 29:36.450
当前目睹是可以省略的

29:36.450 --> 29:37.450
但是呢

29:37.450 --> 29:39.450
在这个模块的书写require

29:39.450 --> 29:40.450
含书里边是不能省略的

29:40.450 --> 29:42.450
至于为什么不能省略

29:42.450 --> 29:43.450
你们

29:43.450 --> 29:45.450
后边很快就知道了

29:45.450 --> 29:46.450
但是现在呢

29:46.450 --> 29:47.450
不好解释

29:47.450 --> 29:48.450
但是你就解它就行了

29:48.450 --> 29:49.450
那么我们发现

29:49.450 --> 29:51.450
这个index和mess

29:51.450 --> 29:53.450
它们的目录是一样的

29:53.450 --> 29:55.450
它的结构

29:55.450 --> 29:56.450
是不是同一个目录的

29:56.450 --> 29:57.450
因此呢

29:57.450 --> 29:58.450
我们是不是用底尔斜杠

29:58.450 --> 29:59.450
底尔斜杠什么

29:59.450 --> 30:00.450
mess

30:00.450 --> 30:01.450
底尔斜

30:01.450 --> 30:02.450
那么就写完了

30:02.450 --> 30:04.450
而且那个底尔斜杠是可以省略的

30:04.450 --> 30:05.450
如果说你没有省略

30:05.450 --> 30:06.450
没有写后维名

30:06.450 --> 30:08.450
它默认的后维名就是斜斜

30:08.450 --> 30:10.450
所以说你可以这样写

30:10.450 --> 30:12.450
require

30:12.450 --> 30:13.450
mess

30:13.450 --> 30:15.450
这就是一个导入

30:15.450 --> 30:16.450
导入模块

30:19.450 --> 30:20.450
那么它会怎么样呢

30:20.450 --> 30:21.450
其实非常简单

30:21.450 --> 30:23.450
这个代码结构就已经出来了

30:23.450 --> 30:24.450
它会

30:24.450 --> 30:25.450
它是这么一个逻辑

30:25.450 --> 30:27.450
当你运行这个require

30:27.450 --> 30:28.450
含书的时候

30:28.450 --> 30:31.450
它就会找到这个mess

30:31.450 --> 30:32.450
解释这个文件

30:32.450 --> 30:34.450
把这个文件从头到尾

30:34.450 --> 30:36.450
给它运行一遍

30:36.450 --> 30:37.450
运行完了过后

30:37.450 --> 30:39.450
这个玩意儿的值

30:39.450 --> 30:41.450
就是我们这个模块的导出

30:41.450 --> 30:43.450
而导出的是什么

30:43.450 --> 30:46.450
导出的是一个对象

30:46.450 --> 30:48.450
导出的就是这个东西

30:48.450 --> 30:49.450
是不是一个对象

30:49.450 --> 30:51.450
这个对象

30:51.450 --> 30:53.450
它就会作为require

30:53.450 --> 30:56.450
含书的反而回结构

30:56.450 --> 30:57.450
明白的意思吗

30:57.450 --> 30:58.450
也就是说我这个require

30:58.450 --> 31:00.450
含书执行完了

31:00.450 --> 31:02.450
它就把这个模块执行完了

31:02.450 --> 31:03.450
同时这个require含书

31:03.450 --> 31:05.450
返回什么东西

31:05.450 --> 31:08.450
返回的就是这个对象

31:08.450 --> 31:09.450
懂了吧

31:09.450 --> 31:10.450
就这么一个简单

31:10.450 --> 31:11.450
看这边require含书

31:11.450 --> 31:13.450
现在我问你返回什么

31:13.450 --> 31:15.450
返回就是这个对象

31:15.450 --> 31:16.450
那么你要做的事情

31:16.450 --> 31:18.450
是不是就随意的去做了

31:18.450 --> 31:19.450
你想做啥就做啥

31:19.450 --> 31:20.450
比方说你不是

31:20.450 --> 31:21.450
要用里边的东西吗

31:21.450 --> 31:23.450
它返回了一个对象

31:23.450 --> 31:25.450
我就给你打上注释

31:25.450 --> 31:26.450
返回啥

31:26.450 --> 31:31.980
它就返回这个玩意儿

31:31.980 --> 31:33.980
它就返回一个1-2的属线

31:33.980 --> 31:34.980
是一个含书

31:34.980 --> 31:36.980
然后上是一个含书

31:36.980 --> 31:38.980
它就返回了这么一个对象

31:38.980 --> 31:39.980
那么这个对象

31:39.980 --> 31:40.980
你要拿去怎么用

31:40.980 --> 31:41.980
随便你怎么用

31:41.980 --> 31:43.980
你可以把它保存在一个变量里边

31:43.980 --> 31:44.980
比方说变量名字

31:44.980 --> 31:45.980
我就随便去

31:45.980 --> 31:47.980
后面跟我们以前学的介石

31:47.980 --> 31:49.980
是完全一样的

31:49.980 --> 31:50.980
没有什么特殊的语法

31:50.980 --> 31:52.980
这里边没有什么特殊的语法

31:52.980 --> 31:53.980
那么这里就是

31:53.980 --> 31:54.980
求免取合名字

31:54.980 --> 31:55.980
那么这个名字就是个对象

31:55.980 --> 31:56.980
当然你可以

31:56.980 --> 31:57.980
我们注意好了

31:57.980 --> 31:58.980
命名规范上

31:58.980 --> 31:59.980
一般来说

31:59.980 --> 32:00.980
这个名字

32:01.980 --> 32:03.980
跟模块相同的名字

32:03.980 --> 32:04.980
一般来说是这样子

32:04.980 --> 32:06.980
名字是可以随便去的

32:06.980 --> 32:07.980
那么接下来

32:07.980 --> 32:09.980
我们再输出一下Mesh

32:10.980 --> 32:12.980
这个流程其实就已经走通了

32:12.980 --> 32:13.980
你看到没有

32:13.980 --> 32:15.980
运行了index的start

32:15.980 --> 32:18.980
然后我们拿到了这个对象

32:18.980 --> 32:19.980
对不对

32:19.980 --> 32:20.980
那么接下来

32:20.980 --> 32:21.980
我要做两个数求合

32:21.980 --> 32:22.980
是不是特别简单

32:22.980 --> 32:26.980
Mesh上求合1-2

32:26.980 --> 32:30.290
这就输出了3

32:30.290 --> 32:31.290
也就是说

32:31.290 --> 32:32.290
我们现在通过这么一个

32:32.290 --> 32:33.290
非常简单的例子

32:33.290 --> 32:35.290
是不是就把两个模块关联起来了

32:35.290 --> 32:37.290
我们通过运行入口模块

32:37.290 --> 32:39.290
它在运行过程中

32:39.290 --> 32:42.290
依赖了其他模块

32:42.290 --> 32:44.290
使用到了其他模块

32:44.290 --> 32:46.290
那么把其他模块的导出结果

32:46.290 --> 32:48.290
拿到我们用它里面导出的东西

32:48.290 --> 32:49.290
对吧

32:49.290 --> 32:50.290
我就不知道

32:50.290 --> 32:52.290
不需要知道你具体怎么写的

32:52.290 --> 32:54.290
因为那是你自己模块的事情

32:54.290 --> 32:55.290
我只需要用就行了

32:56.290 --> 32:57.290
而其他模块的时候

32:57.290 --> 32:58.290
在运行的过程中

32:58.290 --> 32:59.290
又可能用到别的模块

32:59.290 --> 33:00.290
那么就可能会形成

33:00.290 --> 33:02.290
很多的模块依赖

33:02.290 --> 33:03.290
我用你

33:03.290 --> 33:04.290
你用它

33:04.290 --> 33:05.290
它用它

33:05.290 --> 33:06.290
是不是就可以形成

33:06.290 --> 33:07.290
很多复杂的依赖

33:07.290 --> 33:08.290
我们就可以把整个工程

33:08.290 --> 33:09.290
切分成

33:09.290 --> 33:11.290
很多很多细小的文件

33:12.290 --> 33:13.290
好

33:13.290 --> 33:14.290
现在大家练习一下

33:14.290 --> 33:15.290
就把我们的代码

33:15.290 --> 33:16.290
写成这个样子

33:16.290 --> 33:17.290
一个模块导出

33:17.290 --> 33:20.980
一个模块导入

33:20.980 --> 33:21.980
好了没

33:21.980 --> 33:22.980
好了

33:22.980 --> 33:23.980
那么最后

33:23.980 --> 33:24.980
我给大家说一个点

33:24.980 --> 33:26.980
其实就可以了

33:26.980 --> 33:27.980
非常非常简单

33:27.980 --> 33:28.980
没有那么复杂

33:28.980 --> 33:29.980
就是你要知道

33:29.980 --> 33:30.980
怎么去导出一个东西

33:30.980 --> 33:32.980
怎么去导入一个东西

33:32.980 --> 33:33.980
我这里呢

33:33.980 --> 33:35.980
给大家说一个细节的点

33:35.980 --> 33:36.980
就是

33:36.980 --> 33:38.980
模块是有缓存的

33:38.980 --> 33:40.980
规范里面说了

33:41.980 --> 33:42.980
每个模块

33:42.980 --> 33:43.980
紧

33:45.980 --> 33:46.980
运行

33:46.980 --> 33:47.980
每个模块

33:48.980 --> 33:49.980
应该这样说

33:49.980 --> 33:50.980
模块有缓存

33:51.980 --> 33:53.980
第一次运行模块后

33:55.980 --> 33:56.980
导出结果

33:57.980 --> 33:58.980
结果

33:59.980 --> 34:02.980
之后再使用

34:02.980 --> 34:03.980
该模块

34:04.980 --> 34:06.980
直接使用缓存结果

34:07.980 --> 34:08.980
好

34:08.980 --> 34:09.980
啥意思

34:09.980 --> 34:10.980
就这个意思

34:10.980 --> 34:11.980
比方说Mesh

34:11.980 --> 34:12.980
Mesh这个模块里面

34:12.980 --> 34:13.980
我输出一句话

34:13.980 --> 34:15.980
叫做Mesh

34:15.980 --> 34:16.980
弱

34:17.980 --> 34:18.980
假设这样子

34:18.980 --> 34:19.980
那么首先我问大家

34:19.980 --> 34:20.980
这句话

34:20.980 --> 34:21.980
现在我运行

34:21.980 --> 34:22.980
index的介绍文件

34:22.980 --> 34:23.980
它会不会输出

34:24.980 --> 34:28.380
会不会

34:28.380 --> 34:29.380
那肯定会吗

34:29.380 --> 34:30.380
为什么不会呢

34:30.380 --> 34:31.380
先运行它嘛

34:31.380 --> 34:33.380
然后再运行到这句话

34:33.380 --> 34:34.380
运行这句话

34:34.380 --> 34:35.380
刚才是不是解释了

34:35.380 --> 34:36.380
它会找到这个模块

34:36.380 --> 34:37.380
把它运行一遍

34:37.380 --> 34:38.380
那运行的时候

34:38.380 --> 34:39.380
是不是就输出了它

34:39.380 --> 34:40.380
对不对

34:40.380 --> 34:41.380
就跟调函数一样了

34:41.380 --> 34:42.380
是不是就输出了它

34:42.380 --> 34:43.380
好

34:43.380 --> 34:44.380
那么输出完了过后

34:44.380 --> 34:45.380
它导出结果了

34:45.380 --> 34:46.380
就会作为函数的反回结果

34:46.380 --> 34:47.380
那么保持到这儿

34:47.380 --> 34:48.380
然后我们就输出了3

34:48.380 --> 34:49.380
肯定会运行

34:49.380 --> 34:51.380
那如果说

34:51.380 --> 34:52.380
我后边

34:52.380 --> 34:53.380
再用Require去

34:54.380 --> 34:55.380
这样做呢

34:55.380 --> 34:56.380
我再来几次呢

34:56.380 --> 34:58.380
它会不会多次运行这个呢

35:00.380 --> 35:01.380
我们来看一下吧

35:02.380 --> 35:03.380
是不是不会

35:03.380 --> 35:04.380
为什么

35:04.380 --> 35:05.380
就是因为缓存

35:05.380 --> 35:07.380
当我们第一次Require它的时候

35:08.380 --> 35:09.380
整个程序

35:09.380 --> 35:10.380
第一次Require它的时候

35:10.380 --> 35:11.380
它发现

35:11.380 --> 35:12.380
我之前没有缓存过

35:12.380 --> 35:13.380
我就运行一遍

35:13.380 --> 35:14.380
那么运行完了过后

35:14.380 --> 35:15.380
这个结果

35:15.380 --> 35:16.380
这个导出结果

35:16.380 --> 35:18.380
就会缓存起来

35:18.380 --> 35:19.380
它怎么缓存的

35:19.380 --> 35:22.380
其实它里面就用了一张表

35:22.380 --> 35:24.380
这个模块的路径

35:24.380 --> 35:26.380
是卖

35:26.380 --> 35:27.380
是叫介石

35:27.380 --> 35:28.380
那么这个模块

35:28.380 --> 35:30.380
第一次运行

35:30.380 --> 35:31.380
运行过后

35:31.380 --> 35:32.380
它导出了一个对象

35:32.380 --> 35:33.380
是这么一个东西

35:33.380 --> 35:34.380
叫做Esored

35:34.380 --> 35:35.380
fn

35:35.380 --> 35:36.380
sum

35:36.380 --> 35:37.380
fn

35:37.380 --> 35:39.380
那么它就会把这个对象缓存起来

35:39.380 --> 35:40.380
而下一次

35:40.380 --> 35:41.380
又去Require的时候

35:41.380 --> 35:42.380
它发现

35:42.380 --> 35:43.380
我之前有缓存

35:43.380 --> 35:44.380
我不用去运行这个模块了

35:44.380 --> 35:46.380
直接把它都缓存结果

35:46.380 --> 35:47.380
作为这个函数的反回结果

35:47.380 --> 35:48.380
没了意思吧

35:48.380 --> 35:50.380
就这么简单

35:51.380 --> 35:52.380
好

35:52.380 --> 35:53.380
那么这就是

35:53.380 --> 35:54.380
咱们第一节课

35:54.380 --> 35:56.380
common.js的知识

35:56.380 --> 35:57.380
好

35:57.380 --> 35:59.380
接下来我们来做一个

35:59.380 --> 36:00.380
综合练习

36:00.380 --> 36:04.210
因为这个模块化

36:04.210 --> 36:07.030
它是这样

36:07.030 --> 36:10.030
如果说你的工程比较简单的话

36:10.030 --> 36:12.030
比如说你工程整个代码

36:12.030 --> 36:13.030
不到100行

36:13.030 --> 36:15.030
你有必要去使用模块化吗

36:15.030 --> 36:16.030
实际上没有必要的

36:16.030 --> 36:17.030
没有必要的

36:17.030 --> 36:18.030
一般来说

36:18.030 --> 36:20.030
工程要到了一定的规模

36:20.030 --> 36:21.030
比如说整个工程里面

36:21.030 --> 36:22.030
代码量

36:22.030 --> 36:24.030
到成千上万行的时候

36:24.030 --> 36:25.030
你没有模块化

36:25.030 --> 36:27.030
那个代码是很难写的

36:27.030 --> 36:28.030
所以说

36:28.030 --> 36:29.030
但是我这里的练习题

36:29.030 --> 36:31.030
不可能给你搞成千上万行的代码

36:31.030 --> 36:32.030
那你可能等你做完了过

36:32.030 --> 36:33.030
或几天就过去了

36:33.030 --> 36:34.030
所以说我们这里

36:34.030 --> 36:36.030
就用一个简单的东西

36:36.030 --> 36:38.030
来模拟的体验一下就行了

36:38.030 --> 36:40.030
来做一个导入导出练习

36:41.030 --> 36:42.030
那么这个地方

36:42.030 --> 36:43.030
我当你

36:43.030 --> 36:44.030
根据我的要求

36:44.030 --> 36:46.030
我会让你写很多的模块

36:46.030 --> 36:47.030
有些模块

36:47.030 --> 36:48.030
我给你就是代码都给你写好了

36:48.030 --> 36:50.030
你直接去把导出就完事了

36:50.030 --> 36:51.030
有些模块

36:51.030 --> 36:53.030
需要你自己去写一下代码

36:53.030 --> 36:54.030
跟着我写

36:54.030 --> 36:55.030
跟着我的要求去做

36:55.030 --> 36:56.030
做完了过后

36:56.030 --> 36:57.030
你会获得一个

36:57.030 --> 36:58.030
非常有趣的效果

36:59.030 --> 37:00.030
接下来我们在这里

37:00.030 --> 37:01.030
去建立一个文件

37:01.030 --> 37:02.030
跟着我做

37:02.030 --> 37:03.030
建立一个文件

37:03.030 --> 37:04.030
叫做

37:04.030 --> 37:05.030
代码吧

37:07.030 --> 37:08.030
我们把所有的模块

37:08.030 --> 37:09.030
都放到这个文件里面

37:11.030 --> 37:12.030
第一道题

37:13.030 --> 37:15.030
它让你去写一个配置文件

37:15.030 --> 37:16.030
配置模块

37:16.030 --> 37:17.030
叫做config.js

37:18.030 --> 37:19.030
那么我们就首先

37:19.030 --> 37:20.030
第一步

37:20.030 --> 37:21.030
建立一个文件

37:21.030 --> 37:23.030
叫做config.js

37:24.030 --> 37:26.030
建立之后

37:26.030 --> 37:27.030
它要让你

37:27.030 --> 37:28.030
它说这个模块

37:28.030 --> 37:29.030
需要导出一个对象

37:30.030 --> 37:31.030
规格如像

37:31.030 --> 37:32.030
就导出一个对象

37:32.030 --> 37:33.030
来吧

37:33.030 --> 37:34.030
把这道题

37:34.030 --> 37:35.030
应该是非常非常简单的

37:36.030 --> 37:37.030
你就把这个对象导出就行了

37:38.030 --> 37:39.030
完成这道题

37:40.030 --> 37:41.030
这对象有什么用

37:41.030 --> 37:42.030
没关系

37:42.030 --> 37:43.030
你不用管

37:43.030 --> 37:44.030
你跟着我的题作

37:44.030 --> 37:46.600
就会完成一个完整的效果

37:46.600 --> 37:47.600
完了没

37:47.600 --> 37:48.600
那我现在

37:48.600 --> 37:49.600
给大家演示一下

37:50.600 --> 37:51.600
module.export

37:52.600 --> 37:53.600
完了

37:53.600 --> 37:54.600
没了

37:55.600 --> 37:56.600
非常简单

37:57.600 --> 37:58.600
那么这个对象

37:58.600 --> 37:59.600
什么意思呢

37:59.600 --> 38:00.600
其实它是一个配置对象

38:00.600 --> 38:02.600
来做一些基本配置的

38:03.600 --> 38:04.600
我们可以打个措施

38:05.600 --> 38:07.600
这是一个配置对象

38:08.600 --> 38:09.600
配置模块

38:11.600 --> 38:13.600
后面你就会知道

38:13.600 --> 38:14.600
这样去分化

38:14.600 --> 38:16.600
分成不同那么小模块

38:16.600 --> 38:17.600
有什么样的好处

38:18.600 --> 38:19.600
好 接下来

38:19.600 --> 38:20.600
下一步

38:21.600 --> 38:22.600
有一个模块叫做延迟模块

38:22.600 --> 38:23.600
这个模块

38:23.600 --> 38:24.600
只有一个函数

38:24.600 --> 38:25.600
你需要做的就是

38:25.600 --> 38:26.600
创建这个模块

38:26.600 --> 38:27.600
把这个函数导出

38:27.600 --> 38:28.600
函数已经给你写出来了

38:30.600 --> 38:31.600
来做一下

38:33.600 --> 38:34.600
好 接下来

38:34.600 --> 38:35.600
我也来做一下

38:36.600 --> 38:38.600
叫做delay.js

38:39.600 --> 38:40.600
这个函数

38:40.600 --> 38:43.600
大家以前有可能看到过

38:44.600 --> 38:45.600
这个函数啥意思呢

38:45.600 --> 38:46.600
你不用去管

38:46.600 --> 38:47.600
它这个函数怎么去实现的

38:49.600 --> 38:50.600
这个关于Promise

38:50.600 --> 38:52.600
如何去创建Promise的一些细节

38:53.600 --> 38:55.600
我们将来可以在就业阶段

38:55.600 --> 38:57.600
详细给大家去讲解

38:57.600 --> 38:58.600
我们现在不用管它

38:58.600 --> 38:59.600
你现在只需要知道

38:59.600 --> 39:01.600
这个函数它返回一个Promise

39:04.170 --> 39:06.170
这个Promise什么时候完成了

39:06.170 --> 39:08.170
取决于你给它传的参数

39:08.170 --> 39:09.170
你给它传1000

39:09.170 --> 39:12.170
那么它就在1000毫秒内之后

39:12.170 --> 39:14.170
完成这个Promise

39:14.170 --> 39:16.170
对吧 就是这个delay函数

39:16.170 --> 39:17.170
那有这个函数过后

39:17.170 --> 39:20.170
我们按照我们以前学过的Promise的指示

39:20.170 --> 39:21.170
我们该怎么去用

39:21.170 --> 39:22.170
举个例子

39:22.170 --> 39:23.170
我现在试一下

39:23.170 --> 39:24.170
而sync

39:26.860 --> 39:28.860
不要用写个函数弱

39:30.860 --> 39:32.860
我希望先输出一个1

39:32.860 --> 39:34.860
一秒钟之后再输出一个2

39:34.860 --> 39:35.860
我不用set timeout

39:35.860 --> 39:37.860
我用这个函数来搞定

39:37.860 --> 39:38.860
那怎么做

39:38.860 --> 39:40.860
我就可以雕用这个函数

39:40.860 --> 39:42.860
给它传入一个1000

39:43.860 --> 39:45.860
它就会等待1000毫秒过后

39:45.860 --> 39:46.860
它返回一个Promise

39:46.860 --> 39:47.860
这个Promise什么时候完成

39:47.860 --> 39:49.860
1000毫秒之后完成

39:49.860 --> 39:51.860
那我是不是会等待Promise完成

39:52.860 --> 39:54.860
什么可以用Always

39:54.860 --> 39:55.860
对吧

39:55.860 --> 39:56.860
等待Promise完成

39:56.860 --> 39:57.860
因为Promise什么时候完成

39:57.860 --> 39:59.860
1000毫秒之后

39:59.860 --> 40:01.860
我们使用Always

40:01.860 --> 40:03.860
是不是可以加上一个sync

40:03.860 --> 40:05.860
输出一个2

40:05.860 --> 40:07.860
那你看这样的写了过后

40:07.860 --> 40:09.860
这边就可以没有回掉了

40:09.860 --> 40:10.860
对吧

40:10.860 --> 40:11.860
看上去比较舒服

40:11.860 --> 40:12.860
runcode

40:13.860 --> 40:14.860
对吧 你看

40:14.860 --> 40:15.860
这边1 2

40:15.860 --> 40:16.860
我们在这边

40:16.860 --> 40:17.860
测试一下

40:17.860 --> 40:18.860
load

40:18.860 --> 40:19.860
load

40:20.860 --> 40:22.860
demo 下面的

40:22.860 --> 40:23.860
D内

40:24.860 --> 40:26.860
一二

40:26.860 --> 40:27.860
对吧

40:27.860 --> 40:28.860
也就是这里

40:28.860 --> 40:30.860
我们就提供了这么一个函数

40:30.860 --> 40:31.860
大家可以

40:31.860 --> 40:33.860
把魔幻喜欢可以测试一下

40:33.860 --> 40:35.860
用这种方式测试一下

40:35.860 --> 40:37.860
来 暂停视频测试一下

40:37.860 --> 40:41.820
好了 那么你现在了解了

40:41.820 --> 40:42.820
这个D内函数的作用

40:42.820 --> 40:44.820
接下来我们要做的事情

40:44.820 --> 40:46.820
就是把这个D内函数导出

40:46.820 --> 40:47.820
怎么导出

40:47.820 --> 40:48.820
module

40:48.820 --> 40:49.820
export

40:50.820 --> 40:52.820
对吧 第二道题就完了

40:52.820 --> 40:55.820
今天这个课特别简单

40:55.820 --> 40:56.820
第三题

40:56.820 --> 40:57.820
打印魔幻

40:57.820 --> 40:59.820
这个单码需要你自己去

40:59.820 --> 41:00.820
我们需要书写一下

41:00.820 --> 41:01.820
我跟你说一下

41:01.820 --> 41:02.820
也就是现在

41:02.820 --> 41:04.820
我们需要建立一个新的魔幻

41:04.820 --> 41:05.820
叫Print

41:05.820 --> 41:06.820
要解释

41:06.820 --> 41:07.820
这个魔幻里面

41:07.820 --> 41:08.820
有一个函数

41:11.380 --> 41:13.380
你需要做的事情是

41:13.380 --> 41:14.380
完成这个函数

41:14.380 --> 41:15.380
并且

41:15.380 --> 41:17.380
把这个函数导出

41:17.380 --> 41:18.380
要导出的单码

41:18.380 --> 41:19.380
已经非常简单了

41:19.380 --> 41:20.380
export

41:20.380 --> 41:21.380
print

41:22.380 --> 41:23.380
把导出

41:23.380 --> 41:25.380
关键是函数怎么去做

41:25.380 --> 41:26.380
那么我们讲一下

41:26.380 --> 41:27.380
这个函数

41:27.380 --> 41:28.380
它要做两件事

41:28.380 --> 41:30.380
第一件事

41:30.380 --> 41:31.380
清空控制台

41:31.380 --> 41:33.380
那么你不知道怎么去

41:33.380 --> 41:34.380
清空控制台

41:34.380 --> 41:35.380
我这里有段单码

41:35.380 --> 41:36.380
console clear

41:36.380 --> 41:38.380
它就可以清空控制台

41:38.380 --> 41:39.380
我举个例子

41:39.380 --> 41:40.380
不要说这里

41:40.380 --> 41:41.380
我们输

41:41.380 --> 41:42.380
clear

41:42.380 --> 41:44.380
那么我们来测试一下

41:44.380 --> 41:46.380
我们在这里

41:46.380 --> 41:48.380
控制台里边去

41:48.380 --> 41:50.380
输出了一个

41:50.380 --> 41:51.380
1

41:51.380 --> 41:52.380
2

41:52.380 --> 41:53.380
3

41:53.380 --> 41:54.380
然后呢

41:54.380 --> 41:56.380
再来调用一下这个print

41:56.380 --> 41:58.380
然后再来输出一个4

41:58.380 --> 41:59.380
我们来看一下

41:59.380 --> 42:01.380
控制台的输出结果

42:01.380 --> 42:03.380
我现在直接运行这个魔幻

42:03.380 --> 42:05.380
load

42:05.380 --> 42:06.380
这里不要用

42:06.380 --> 42:07.380
run code了

42:07.380 --> 42:09.380
因为清空控制台的功能

42:09.380 --> 42:11.380
run code是在这里输出的

42:11.380 --> 42:12.380
所以说这个玩意

42:12.380 --> 42:13.380
它不是一个正经的控制台

42:13.380 --> 42:15.380
我们还是要在中端里面

42:15.380 --> 42:17.380
load demo

42:17.380 --> 42:19.380
print

42:19.380 --> 42:21.380
因为发现它只输出了4

42:21.380 --> 42:22.380
为什么前面

42:22.380 --> 42:24.380
输出了1 2 3过后

42:24.380 --> 42:25.380
调用它的时候

42:25.380 --> 42:27.380
控制台被清空了

42:27.380 --> 42:28.380
比方说再举个例子

42:28.380 --> 42:30.380
我前面不输出

42:30.380 --> 42:31.380
也不输出4

42:31.380 --> 42:36.040
我就清空一下控制台

42:36.040 --> 42:39.480
接下来我们运行

42:39.480 --> 42:40.480
print

42:40.480 --> 42:42.480
你要控制台是不是清空了

42:42.480 --> 42:43.480
还有其他每个作用

42:43.480 --> 42:44.480
第一步

42:44.480 --> 42:46.480
要清空控制台

42:46.480 --> 42:47.480
第二步

42:47.480 --> 42:50.480
关键里面要写第二步

42:50.480 --> 42:53.480
第二步是要读取另外一个魔幻

42:53.480 --> 42:54.480
就这个魔幻

42:54.480 --> 42:59.370
读取它里面的这个东西

43:01.370 --> 43:03.370
就是一个文本

43:03.370 --> 43:06.370
把这个文本打印到

43:06.370 --> 43:07.370
index的制服位置

43:07.370 --> 43:10.370
比方说index传的是3

43:10.370 --> 43:12.370
那么就要打印哪些制服

43:12.370 --> 43:15.370
打印西 风 列 斗号

43:15.370 --> 43:16.370
明白吧

43:16.370 --> 43:18.370
就要打印这个

43:18.370 --> 43:19.370
一个控制台

43:19.370 --> 43:20.370
我们先清空

43:20.370 --> 43:22.370
然后打印出这个

43:22.370 --> 43:24.370
如果说index传的是1

43:24.370 --> 43:28.370
那么就是01

43:28.370 --> 43:36.100
就是01

43:36.100 --> 43:38.100
打印这两个字

43:38.100 --> 43:40.100
如果说index传的是5

43:40.100 --> 43:41.100
那么我来看

43:41.100 --> 43:43.100
就是01

43:43.100 --> 43:44.100
2

43:44.100 --> 43:45.100
3

43:45.100 --> 43:46.100
4

43:46.100 --> 43:47.100
5

43:47.100 --> 43:48.100
后面还有一个换行

43:48.100 --> 43:49.100
换行要算一个

43:49.100 --> 43:50.100
应该打印到长这里

43:50.100 --> 43:51.100
明白了意思吧

43:51.100 --> 43:53.100
就是说

43:53.100 --> 43:55.100
传入的index是多少

43:55.100 --> 43:57.100
我们就把这个制服传

43:57.100 --> 43:59.100
从0打印到那个制服位置

43:59.100 --> 44:01.100
就这么个意思

44:01.100 --> 44:03.100
那么这个问题

44:03.100 --> 44:04.100
大家可以去做一做

44:04.100 --> 44:06.100
其实并不复杂

44:06.100 --> 44:08.100
再点视频

44:08.100 --> 44:09.100
好了

44:09.100 --> 44:10.100
那我再来演示一下

44:10.100 --> 44:12.100
怎么去的也操作

44:12.100 --> 44:14.100
那么我们首先要打印这个Tag

44:14.100 --> 44:16.100
我们是不是得拿到Tag

44:16.100 --> 44:17.100
对不对

44:17.100 --> 44:19.100
你不拿到Tag怎么打印的

44:19.100 --> 44:20.100
所以说我们这里

44:20.100 --> 44:22.100
得用Require

44:22.100 --> 44:23.100
正当我说一下

44:23.100 --> 44:24.100
一般情况下

44:24.100 --> 44:27.100
我们书写习惯上了

44:27.100 --> 44:28.100
是把这个Require

44:28.100 --> 44:30.100
写到最上面

44:30.100 --> 44:31.100
这样子我们可以

44:31.100 --> 44:32.100
通过看这个文件

44:32.100 --> 44:33.100
最上面的就可以看到

44:33.100 --> 44:34.100
这个文件

44:34.100 --> 44:36.100
用到了其他的哪些模块

44:36.100 --> 44:37.100
有这么一个书写习惯

44:37.100 --> 44:38.100
当你写到这里

44:38.100 --> 44:40.100
也是完全没有问题的

44:40.100 --> 44:41.100
要用的时候在Require

44:41.100 --> 44:42.100
也是没问题的

44:42.100 --> 44:44.100
我们就写到这吧

44:44.100 --> 44:45.100
哪个模块

44:45.100 --> 44:46.100
注意一定要一点

44:46.100 --> 44:47.100
鞋杠开头

44:47.100 --> 44:49.100
就是config这个模块

44:49.100 --> 44:50.100
它反回了什么

44:50.100 --> 44:51.100
反回了一个对象

44:51.100 --> 44:54.100
我们保存一下config

44:54.100 --> 44:55.100
好那么我们这里

44:55.100 --> 44:59.100
就输出一下config.txt

44:59.100 --> 45:00.100
看一下吧

45:00.100 --> 45:03.100
load print

45:03.100 --> 45:04.100
所以打印出来了

45:04.100 --> 45:05.100
当然这个txt

45:05.100 --> 45:07.100
是完整的一个文本

45:07.100 --> 45:08.100
目前我们现在要做的事情

45:08.100 --> 45:10.100
就是打印这个文本

45:10.100 --> 45:12.100
到index的位置

45:12.100 --> 45:14.100
从零开始到index的位置

45:14.100 --> 45:15.100
是不是我们

45:15.100 --> 45:16.100
做一个字幕出来

45:16.100 --> 45:17.100
拼接就完事了

45:17.100 --> 45:18.100
我们定一个辨量

45:18.100 --> 45:19.100
spr

45:19.100 --> 45:20.100
它是一个空置无事

45:20.100 --> 45:21.100
然后接下来

45:21.100 --> 45:25.100
我就循环这个config.txt

45:25.100 --> 45:26.100
对吧

45:26.100 --> 45:27.100
循环它

45:27.100 --> 45:28.100
我们循环一下

45:28.100 --> 45:31.100
let's i等于0

45:31.100 --> 45:33.100
i小于什么呢

45:33.100 --> 45:35.100
小于等于index

45:35.100 --> 45:37.100
就从零这个位置

45:37.100 --> 45:39.100
一直加到这个index的位置

45:39.100 --> 45:41.100
把它拼接到这个str里面去

45:41.100 --> 45:43.100
i加加

45:43.100 --> 45:45.100
每一次循环

45:45.100 --> 45:47.100
是不是在str加一个字幕算

45:47.100 --> 45:50.180
加什么呢

45:50.180 --> 45:52.180
我好像神经病的

45:52.180 --> 45:54.180
我干嘛要这样做

45:54.180 --> 45:55.180
我要打印的文本

45:55.180 --> 45:59.180
不就是config.txt substream

45:59.180 --> 46:00.180
我怎么逢了

46:00.180 --> 46:01.180
我要把这样做

46:01.180 --> 46:02.180
from

46:02.180 --> 46:04.180
从哪个位置开始

46:04.180 --> 46:06.180
用那个substream

46:06.180 --> 46:08.180
哪个位置开始

46:08.180 --> 46:09.180
零

46:09.180 --> 46:10.180
到哪个字幕

46:10.180 --> 46:11.180
到index的字幕

46:11.180 --> 46:13.180
不过substream的话

46:13.180 --> 46:14.180
index是取不到的

46:14.180 --> 46:16.180
所以说我们要用index加1

46:16.180 --> 46:18.180
因为index取不到

46:18.180 --> 46:20.180
就完了

46:20.180 --> 46:21.180
我们这里

46:21.180 --> 46:23.180
这就是我们要打印的字符

46:23.180 --> 46:24.180
保持一下

46:24.180 --> 46:26.180
就是txt

46:26.180 --> 46:27.180
最后我们输出一下txt

46:27.180 --> 46:28.180
就完事了

46:28.180 --> 46:29.180
这就是我们print的

46:29.180 --> 46:30.180
还需要做的事

46:30.180 --> 46:31.180
试一下

46:31.180 --> 46:32.180
看一下正不正确

46:32.180 --> 46:34.180
我们这里调用一下print

46:34.180 --> 46:36.180
给它传入一个2

46:36.180 --> 46:40.540
是不是正确的

46:40.540 --> 46:42.540
三个字符012

46:42.540 --> 46:45.980
再传入一个1

46:45.980 --> 46:46.980
再传入一个0

46:46.980 --> 46:47.980
那就打印第

46:47.980 --> 46:50.980
只打印第1个

46:50.980 --> 46:51.980
对吧

46:51.980 --> 46:52.980
再传入一个10

46:52.980 --> 46:56.860
这就可以

46:56.860 --> 46:57.860
没问题了

46:57.860 --> 46:59.860
print这个函数也写好了

46:59.860 --> 47:01.860
这个模块就完成了

47:01.860 --> 47:03.860
接下来下一个要提

47:03.860 --> 47:05.860
主模块

47:05.860 --> 47:06.860
主模块什么意思

47:06.860 --> 47:08.860
一般指的是启动模块

47:08.860 --> 47:13.620
新建一个made-ins

47:13.620 --> 47:15.620
现在好了之后

47:15.620 --> 47:16.620
这个模块要做什么事

47:16.620 --> 47:18.620
这个模块要提供一个函数

47:18.620 --> 47:19.620
叫jong

47:19.620 --> 47:23.580
就是运行这个函数

47:23.580 --> 47:25.580
这个模块就没有导出了

47:26.580 --> 47:28.580
这个模块就没有导出了

47:28.580 --> 47:29.580
这个模块要做的事情

47:29.580 --> 47:30.580
就是运行一个函数

47:30.580 --> 47:31.580
因为它是主模块

47:31.580 --> 47:33.580
它导出干嘛呢

47:33.580 --> 47:35.580
运行这个函数

47:35.580 --> 47:38.580
能够实现什么样的效果呢

47:38.580 --> 47:40.580
会把这个tags

47:40.580 --> 47:42.580
配置里面tags的东西

47:42.580 --> 47:44.580
逐字打印出来

47:46.580 --> 47:47.580
什么意思

47:47.580 --> 47:49.580
我就先打印一个字

47:49.580 --> 47:51.580
然后再打印它

47:51.580 --> 47:55.660
是啥意思

47:56.660 --> 47:57.660
我先打印它

47:57.660 --> 47:58.660
再打印它

47:58.660 --> 47:59.660
再打印它

47:59.660 --> 48:00.660
再打印斗号

48:00.660 --> 48:01.660
再打印换行

48:01.660 --> 48:02.660
再打印它

48:02.660 --> 48:03.660
再打印它

48:03.660 --> 48:04.660
再打印它

48:04.660 --> 48:06.660
每个字打印之间

48:06.660 --> 48:08.660
有多少时间间隔呢

48:08.660 --> 48:10.660
有300毫秒

48:10.660 --> 48:12.660
就做这么一件事

48:12.660 --> 48:13.660
大家可以想一想

48:13.660 --> 48:14.660
这个函数呢

48:14.660 --> 48:16.660
稍微有那么一丢丢的难度

48:16.660 --> 48:18.660
大家可以想一想

48:18.660 --> 48:19.660
怎么样利用我们

48:19.660 --> 48:20.660
已经存在的模块

48:20.660 --> 48:22.660
来完成这个功能

48:22.660 --> 48:23.660
就是很多功能

48:23.660 --> 48:24.660
这些模块都提供了

48:24.660 --> 48:28.860
有没有失落

48:28.860 --> 48:29.860
没有失落

48:29.860 --> 48:31.860
我给你们提供一个失落

48:31.860 --> 48:33.860
其实要做的事情

48:33.860 --> 48:34.860
并不复杂

48:34.860 --> 48:39.520
做什么事

48:39.520 --> 48:40.520
就是我们这里

48:40.520 --> 48:42.520
有这么一些模块

48:42.520 --> 48:43.520
有一个delay函数

48:43.520 --> 48:44.520
你看

48:44.520 --> 48:45.520
我们要做什么事

48:45.520 --> 48:47.520
我们一开始

48:47.520 --> 48:49.520
就打印第零个字符

48:50.520 --> 48:52.520
调用这个print函数

48:52.520 --> 48:54.520
打印第零个字符

48:54.520 --> 48:56.520
然后等一会

48:56.520 --> 48:57.520
怎么等

48:57.520 --> 48:58.520
我们就利用delay函数

48:58.520 --> 49:00.520
来等待一段时间

49:00.520 --> 49:01.520
对吧

49:01.520 --> 49:02.520
等多久

49:02.520 --> 49:04.520
等300毫秒

49:04.520 --> 49:05.520
把这个读出来

49:05.520 --> 49:06.520
等300毫秒

49:06.520 --> 49:07.520
好

49:07.520 --> 49:08.520
等了300毫秒之后

49:08.520 --> 49:10.520
我一路调用print函数

49:10.520 --> 49:12.520
打印两个字符

49:12.520 --> 49:13.520
因为它每一次打印

49:13.520 --> 49:15.520
都会把之前的清空

49:15.520 --> 49:16.520
所以说

49:16.520 --> 49:17.520
就相当于是

49:17.520 --> 49:18.520
第一次打印了C

49:18.520 --> 49:20.520
相当于是这样子

49:20.520 --> 49:22.520
打印一个C

49:22.520 --> 49:25.520
然后300毫秒过后

49:25.520 --> 49:28.520
清空打印C封

49:28.520 --> 49:29.520
对吧

49:29.520 --> 49:30.520
因为它程序的速度很快

49:30.520 --> 49:31.520
就感觉上

49:31.520 --> 49:32.520
这个C没有动力一样

49:32.520 --> 49:33.520
实际上C是变

49:33.520 --> 49:35.520
也是被清空了的

49:35.520 --> 49:37.520
然后又等待300毫秒过后

49:37.520 --> 49:39.520
打印出C封立

49:39.520 --> 49:40.520
直到把整个字符出来

49:40.520 --> 49:41.520
打印完成

49:41.520 --> 49:43.520
整个的示威模式就这样子

49:43.520 --> 49:44.520
大家可以尝试一下

49:44.520 --> 49:46.520
看自己能不能写出来

49:46.520 --> 49:47.520
写不出来的话

49:47.520 --> 49:48.520
没关系

49:48.520 --> 49:49.520
以后就看一下我写

49:49.520 --> 49:50.520
因为我们毕竟是

49:50.520 --> 49:51.520
练习模块画

49:51.520 --> 49:52.520
这些聚德函数

49:53.520 --> 49:54.520
好了没

49:54.520 --> 49:55.520
那我们尝试一下

49:55.520 --> 49:56.520
自己写一下

49:57.520 --> 49:58.520
怎么写

49:58.520 --> 49:59.520
我们要打印

49:59.520 --> 50:00.520
就不断的打印

50:00.520 --> 50:01.520
不断的打印

50:01.520 --> 50:02.520
那么我们首先

50:02.520 --> 50:03.520
要用到的三个模块

50:03.520 --> 50:04.520
都要用到

50:05.520 --> 50:06.520
一个是

50:06.520 --> 50:07.520
config

50:08.520 --> 50:09.520
config

50:09.520 --> 50:10.520
require

50:10.520 --> 50:13.090
吊写稿

50:15.090 --> 50:16.090
还有一个是

50:16.090 --> 50:17.090
print

50:17.090 --> 50:18.090
require

50:19.090 --> 50:21.590
吊写稿

50:21.590 --> 50:22.590
print

50:22.590 --> 50:23.590
含书

50:23.590 --> 50:24.590
还有一个是

50:24.590 --> 50:25.590
迪内

50:26.590 --> 50:27.590
这些我们都需要用

50:28.590 --> 50:29.590
好

50:29.590 --> 50:30.590
把这些模块

50:30.590 --> 50:31.590
导出的东西导出进来

50:31.590 --> 50:32.590
接下来

50:32.590 --> 50:33.590
我们在壮含书里边

50:34.590 --> 50:36.590
我们要写个循环

50:36.590 --> 50:37.590
不断的打印

50:37.590 --> 50:38.590
那个循环的条件

50:38.590 --> 50:39.590
是什么呢

50:39.590 --> 50:41.590
就是当前打印的位置

50:43.590 --> 50:44.590
小于等于

50:44.590 --> 50:46.590
数组的下标

50:46.590 --> 50:48.590
就是小于这个

50:48.590 --> 50:49.590
不是数组

50:49.590 --> 50:50.590
小于字不算的长度

50:50.590 --> 50:51.590
这个字不算

50:51.590 --> 50:52.590
还没有打印完

50:52.590 --> 50:53.590
因此

50:53.590 --> 50:54.590
因这个

50:55.590 --> 50:56.590
从零开始

50:56.590 --> 50:57.590
只要什么情况呢

50:57.590 --> 50:59.590
只要因这个

50:59.590 --> 51:00.590
小于了

51:00.590 --> 51:01.590
字不算的长度

51:02.590 --> 51:03.590
那么就是什么

51:03.590 --> 51:06.590
config.txt.lens

51:07.590 --> 51:08.590
是不是从推子里边

51:08.590 --> 51:09.590
拿到这个字不算

51:09.590 --> 51:10.590
它的长度

51:10.590 --> 51:11.590
小于这个长度

51:11.590 --> 51:12.590
那么我们就能打印

51:12.590 --> 51:13.590
因这个时候是合法的

51:13.590 --> 51:15.590
是一个有效的下标

51:15.590 --> 51:16.590
怎么打印呢

51:16.590 --> 51:17.590
是不是雕用那个print

51:17.590 --> 51:18.590
含书

51:18.590 --> 51:19.590
把因这个时候传进去

51:19.590 --> 51:20.590
对吧

51:20.590 --> 51:22.590
打印到这个位置

51:22.590 --> 51:25.590
打印到这个位置

51:25.590 --> 51:27.590
打印到它这个位置

51:27.590 --> 51:28.590
因为它每次打印

51:28.590 --> 51:29.590
都会清空屏幕

51:29.590 --> 51:30.590
对吧

51:30.590 --> 51:31.590
打印到过后

51:31.590 --> 51:32.590
是不是我们要等待

51:32.590 --> 51:33.590
需要等待

51:33.590 --> 51:35.590
怎么等待呢

51:35.590 --> 51:36.590
是不是雕用那个

51:36.590 --> 51:37.590
dn寒书

51:38.590 --> 51:39.590
等待多久

51:39.590 --> 51:40.590
等待多久

51:40.590 --> 51:41.590
是不是等待300毫秒

51:41.590 --> 51:42.590
是不是config里边的

51:42.590 --> 51:44.590
word duration

51:44.590 --> 51:46.590
虽然说这个程序很小

51:46.590 --> 51:47.590
但是里边还是用了

51:47.590 --> 51:48.590
很多的程序

51:48.590 --> 51:49.590
设计思想在里边

51:50.590 --> 51:52.590
而位置

51:52.590 --> 51:53.590
是不是等待

51:53.590 --> 51:56.290
那么等待

51:56.290 --> 51:57.290
他用了而位置

51:57.290 --> 51:58.290
是不是要把这个寒书

51:58.290 --> 51:59.290
设置为l sync

52:00.290 --> 52:01.290
好

52:01.290 --> 52:02.290
等待完了过后

52:02.290 --> 52:03.290
是不是因这个时候加加

52:03.290 --> 52:05.290
等待了3秒毫秒

52:05.290 --> 52:06.290
那么下一次

52:06.290 --> 52:07.290
就是因这个时候加加

52:07.290 --> 52:08.290
加加过后

52:08.290 --> 52:09.290
再循环

52:09.290 --> 52:10.290
判断因这个时候

52:10.290 --> 52:11.290
还有效

52:11.290 --> 52:12.290
那么就打印到下一个位置

52:12.290 --> 52:13.290
就写完了

52:15.290 --> 52:16.290
好

52:16.290 --> 52:19.110
咱们来运行看一下

52:19.110 --> 52:21.110
load demo

52:22.110 --> 52:28.780
是不是很有意思

52:28.780 --> 52:29.780
对吧

52:29.780 --> 52:31.780
我们可以按config加c

52:31.780 --> 52:33.780
强制停滞程序

52:33.780 --> 52:34.780
config加c

52:34.780 --> 52:35.780
那么这里如果说

52:35.780 --> 52:36.780
你觉得

52:36.780 --> 52:37.780
你看好这个程序

52:37.780 --> 52:38.780
有多好维护

52:39.780 --> 52:40.780
将来如果说

52:40.780 --> 52:41.780
有一天

52:41.780 --> 52:43.780
你觉得你打印的速度

52:43.780 --> 52:44.780
太慢了

52:44.780 --> 52:45.780
调什么

52:45.780 --> 52:46.780
调配置

52:46.780 --> 52:47.780
其他我看得难的看

52:47.780 --> 52:48.780
到这个模块里边

52:48.780 --> 52:49.780
调一下配置

52:49.780 --> 52:50.780
比方说我给你

52:50.780 --> 52:51.780
调到100毫秒

52:51.780 --> 52:52.780
然后呢

52:52.780 --> 52:53.780
我们运行程序

52:53.780 --> 52:54.780
重新运行那个

52:55.780 --> 52:56.780
就变快了

52:56.780 --> 52:57.780
如果说

52:57.780 --> 52:58.780
我有一天想打印

52:58.780 --> 52:59.780
别的文本

52:59.780 --> 53:00.780
在这里

53:00.780 --> 53:01.780
是不是我可以

53:01.780 --> 53:02.780
换一段文本

53:02.780 --> 53:03.780
对吧

53:03.780 --> 53:07.790
如果有一天呢

53:07.790 --> 53:08.790
你看这个无程序

53:08.790 --> 53:10.790
我这个打印

53:10.790 --> 53:11.790
这个函数

53:11.790 --> 53:12.790
是不是还可以

53:12.790 --> 53:13.790
给别的模块使用

53:13.790 --> 53:14.790
不一定要给

53:14.790 --> 53:15.790
灭掉介绍

53:15.790 --> 53:16.790
将来如果说

53:16.790 --> 53:17.790
我们有类似的功能

53:17.790 --> 53:18.790
打印到某一个地方

53:18.790 --> 53:19.790
要清光屏幕的话

53:19.790 --> 53:20.790
我们是不是可以

53:20.790 --> 53:21.790
重用这个函数

53:21.790 --> 53:22.790
如果说这个函数

53:22.790 --> 53:23.790
重用度

53:23.790 --> 53:24.790
还不是那么高的话

53:24.790 --> 53:25.790
看一下这个函数

53:26.790 --> 53:27.790
这个函数

53:27.790 --> 53:28.790
这个函数

53:28.790 --> 53:29.790
我们要等待一段时间

53:29.790 --> 53:30.790
是不是他跟这个

53:30.790 --> 53:31.790
具体的功能

53:31.790 --> 53:32.790
没有关系的

53:32.790 --> 53:33.790
将来如果说

53:33.790 --> 53:34.790
我们只要用到

53:34.790 --> 53:35.790
需要用等一段时间

53:35.790 --> 53:36.790
这么一个功能

53:36.790 --> 53:37.790
就可以重复的

53:37.790 --> 53:38.790
利用这个模块

53:38.790 --> 53:39.790
对吧

53:39.790 --> 53:40.790
那么整个程序

53:40.790 --> 53:41.790
虽然说功能很简单

53:41.790 --> 53:42.790
但是我们把它

53:42.790 --> 53:43.790
模块化之后

53:43.790 --> 53:44.790
可维护信亚

53:44.790 --> 53:45.790
可阅读信亚

53:45.790 --> 53:46.790
你看代码的掌控力

53:46.790 --> 53:47.790
这个代码

53:47.790 --> 53:49.790
就这么实际上代码

53:49.790 --> 53:50.790
这个代码更少

53:50.790 --> 53:51.790
这个代码也很少

53:51.790 --> 53:52.790
这个代码也很少

53:52.790 --> 53:53.790
对吧

53:53.790 --> 53:54.790
但是每一个GS

53:54.790 --> 53:55.790
都非常的简单

53:55.790 --> 53:57.790
都非常的好控制

53:57.790 --> 53:58.790
眼下就阅读完了

53:58.790 --> 53:59.790
就不是把它全部

53:59.790 --> 54:00.790
挤在一堆

54:00.790 --> 54:01.790
写成一个很大很大的

54:01.790 --> 54:02.790
GS文件

54:02.790 --> 54:04.790
这就是模块化的好处

54:05.790 --> 54:06.790
好了

54:06.790 --> 54:07.790
大家把这个效果

54:07.790 --> 54:08.790
把它做完

54:08.790 --> 54:09.790
做完过后

54:09.790 --> 54:10.790
本节课

54:10.790 --> 54:11.790
CommonGS就结束了

54:11.790 --> 54:12.790
CommonGS里边

54:12.790 --> 54:13.790
你需要学到了

54:13.790 --> 54:14.790
东西其实非常简单

54:14.790 --> 54:15.790
你就需要知道

54:15.790 --> 54:17.790
怎么去导出模块

54:17.790 --> 54:19.790
怎么去导入一个模块

54:19.790 --> 54:21.790
那么就OK了

54:22.790 --> 54:23.790
好

54:23.790 --> 54:24.790
那么这里可以到这了

54:24.790 --> 54:25.790
拜拜

