WEBVTT

00:00.110 --> 00:03.110
上节课了 咱们聊了这个数组 对吧

00:03.110 --> 00:06.110
现在这节课了 咱们了解要对象的改动

00:06.110 --> 00:11.110
跟你说一下 这个ES6啊 它改了很多东西

00:11.110 --> 00:14.110
但是呢 不是说你们要学了之后

00:14.110 --> 00:17.110
要买一个东西就一定要想方设法去使用

00:17.110 --> 00:21.110
那就背离了ES6的初衷了

00:21.110 --> 00:23.110
ES6为什么会出现

00:23.110 --> 00:28.110
它是为了让你代码写的舒服 写的踏实 写的爽

00:28.110 --> 00:31.110
不是来恶心你的 如果说你学了ES6之后

00:31.110 --> 00:33.110
你发现一个代码写写得更加恶心了

00:33.110 --> 00:36.110
那里就推回去呗 你不要用ES6

00:36.110 --> 00:40.110
说明了 你道行还不够 你以后再慢慢用吧

00:40.110 --> 00:44.110
因为这个ES6呢 它并没有功能性质的改变

00:44.110 --> 00:46.110
有没有 有 很少很少

00:46.110 --> 00:52.110
大部分呢 属于整容 相当于是给GS整了个容

00:52.110 --> 00:54.110
让它看上去更加好看一点

00:54.110 --> 00:56.110
两个眼睛还是两个眼睛

00:56.110 --> 00:58.110
一个鼻子 一个嘴巴 两只耳朵

00:58.110 --> 01:00.110
功能性并没有变化

01:00.110 --> 01:02.110
它不是把这个GS变成了钢铁匣

01:02.110 --> 01:04.110
以前不能干的事 现在还是不能干

01:04.110 --> 01:06.110
以前能干的事 现在还能干

01:06.110 --> 01:11.110
它只是让这个GS看上去更加舒服了一点

01:11.110 --> 01:13.110
就取得每个作用

01:13.110 --> 01:15.110
所以说呢 不要有那么大的心力压力

01:15.110 --> 01:17.110
这些东西你看一遍 过一遍

01:17.110 --> 01:20.110
过了之后 之后在开发中能用上

01:20.110 --> 01:22.110
你想起来那里就用

01:22.110 --> 01:25.110
想不起来就算了 就拿倒

01:25.110 --> 01:27.110
其实你看了一些东西过后

01:27.110 --> 01:29.110
其实你还是会有一些感觉的

01:29.110 --> 01:31.110
确实过去的代码确很丑

01:31.110 --> 01:32.110
因为过去你没有对比

01:32.110 --> 01:34.110
没有对比就没有伤害

01:34.110 --> 01:38.110
没有对比就好比说你没见过大美女

01:38.110 --> 01:41.110
那村里边的村姑就是最好看的

01:41.110 --> 01:43.110
你天天看过的当然

01:43.110 --> 01:44.110
郭大冈长得也挺帅的

01:44.110 --> 01:47.110
当你看到过帅哥 看到过美女之后

01:47.110 --> 01:49.110
那之前的东西就不能看了

01:49.110 --> 01:50.110
就这么一回事

01:50.110 --> 01:52.110
所以说咱们快速的把它过一遍

01:52.110 --> 01:54.110
过了之后能用哪些印象

01:54.110 --> 01:55.110
就有哪些印象

01:55.110 --> 01:57.110
不要去使劲你背不住的

01:57.110 --> 01:58.110
然后之后开发中

01:58.110 --> 01:59.110
你想起来就用

01:59.110 --> 02:00.110
想不起来用以前的方法

02:00.110 --> 02:01.110
一点问题没有

02:01.110 --> 02:03.110
好 咱们来看一下

02:03.110 --> 02:05.110
它对象做了哪些改动

02:05.110 --> 02:07.110
首先第一个对象成员数学

02:07.110 --> 02:09.110
非常简单 每一个点都非常简单

02:09.110 --> 02:11.110
都是为了方便的 你看

02:11.110 --> 02:12.110
怎么方便法呢

02:12.110 --> 02:13.110
过去我们有的时候

02:13.110 --> 02:15.110
会出现一些变量这些东西

02:15.110 --> 02:19.110
有些变量是直播车 数字 函数

02:19.110 --> 02:21.110
有的时候我们把它组装成一个对象

02:21.110 --> 02:23.110
我们组装的时候

02:23.110 --> 02:24.110
可能会这样的写

02:24.110 --> 02:26.110
属性名

02:26.110 --> 02:28.110
属性的值来出于变量的

02:28.110 --> 02:30.110
两个虽然是一样的名字

02:30.110 --> 02:31.110
但是含义不一样

02:31.110 --> 02:33.110
这是属性名

02:33.110 --> 02:35.110
这是一个变量的值放过来

02:35.110 --> 02:37.110
Bamalika这个放过来

02:37.110 --> 02:39.110
A级Sahalo也是一样

02:39.110 --> 02:41.110
Sahalo就是属性名

02:41.110 --> 02:43.110
Sahalo属性值是一个函数

02:43.110 --> 02:44.110
把函数放过来

02:44.110 --> 02:46.110
这就是过去的写法

02:46.110 --> 02:47.110
是不是有点啰嗦

02:47.110 --> 02:49.110
当然过去不觉得啰嗦

02:49.110 --> 02:50.110
没有对比

02:50.110 --> 02:51.110
来看一下S6怎么写的

02:51.110 --> 02:53.110
S6遇到这种情况

02:53.110 --> 02:55.110
你就直接这样的写

02:55.110 --> 02:56.110
写一个就完事了

02:56.110 --> 02:58.110
一个Doha

02:58.110 --> 02:59.110
A级Doha

02:59.110 --> 03:00.110
Sahalo完了

03:00.110 --> 03:03.110
这就是成员的书写

03:03.110 --> 03:04.110
这样的书写

03:04.110 --> 03:06.110
跟上面的功能是完全一样的

03:06.110 --> 03:08.110
一点区别都没有

03:08.110 --> 03:09.110
只是写上去了

03:09.110 --> 03:10.110
看上去更加舒服了

03:10.110 --> 03:11.110
看上去更加爽了

03:11.110 --> 03:13.110
少写了一些单词

03:13.110 --> 03:14.110
就这么一个效果

03:14.110 --> 03:16.110
当你的属性名

03:16.110 --> 03:17.110
和后边的变量名

03:17.110 --> 03:18.110
是一样的时候

03:18.110 --> 03:19.110
你可以用这种方式

03:19.110 --> 03:20.110
然后下面

03:20.110 --> 03:22.110
还有一种就是方法的书写

03:22.110 --> 03:24.110
方法的书写你看上面

03:24.110 --> 03:25.110
咱们有个对象

03:25.110 --> 03:26.110
然后里面有些方法

03:26.110 --> 03:28.110
过去是这样的写法

03:28.110 --> 03:29.110
有点多说

03:29.110 --> 03:31.110
所以说S6给你改成了

03:31.110 --> 03:32.110
这样的写法

03:32.110 --> 03:33.110
当在一个对象里面

03:33.110 --> 03:35.110
你要去写一个方法的时候

03:35.110 --> 03:37.110
你可以把这种写法

03:37.110 --> 03:38.110
换成这种写法

03:38.110 --> 03:40.110
效果是一模一样的

03:40.110 --> 03:41.110
一点区别都没有

03:41.110 --> 03:42.110
就是写法变

03:42.110 --> 03:45.110
这就是方法书写

03:45.110 --> 03:47.110
和成员书写

03:47.110 --> 03:49.110
复杂不复杂吧

03:49.110 --> 03:50.110
需要击吗

03:50.110 --> 03:51.110
不需要击

03:51.110 --> 03:52.110
你之后你觉得

03:52.110 --> 03:54.110
还是过去那个好看

03:54.110 --> 03:56.110
那你还是过去写得爽

03:56.110 --> 03:57.110
那你就用过去的写法

03:57.110 --> 03:58.110
没人会说什么

03:58.110 --> 04:00.110
只是看感觉丑了一点而已

04:00.110 --> 04:02.110
没有人会说什么

04:02.110 --> 04:03.110
其实美和丑也是自己的

04:03.110 --> 04:04.110
一种感觉

04:04.110 --> 04:05.110
有的人就觉得

04:05.110 --> 04:06.110
上面那个好看

04:06.110 --> 04:08.110
就用上面那种写法写

04:08.110 --> 04:10.110
好 下一个

04:10.110 --> 04:12.110
展开运算符

04:12.110 --> 04:13.110
三个点

04:13.110 --> 04:14.110
过去

04:14.110 --> 04:16.110
之前还没有见过三个点

04:16.110 --> 04:18.110
那么这三个点是啥意思

04:18.110 --> 04:20.110
表示的是

04:20.110 --> 04:21.110
我把这个

04:21.110 --> 04:22.110
某一个书主

04:22.110 --> 04:24.110
某一个对象展开

04:24.110 --> 04:25.110
看一下吧

04:25.110 --> 04:26.110
比方说

04:26.110 --> 04:28.110
我们有一个Mass Max

04:28.110 --> 04:30.110
求最大值对吧

04:30.110 --> 04:31.110
这么多都还说

04:31.110 --> 04:36.900
这里有一个Mass Max

04:36.900 --> 04:38.900
123

04:38.900 --> 04:40.900
122

04:40.900 --> 04:41.900
对这些东西中

04:41.900 --> 04:43.900
求一个最大值返回

04:43.900 --> 04:47.210
来输出一下

04:47.210 --> 04:48.210
6

04:48.210 --> 04:49.210
对不对

04:49.210 --> 04:50.210
最大值16

04:50.210 --> 04:52.210
那比方说有的时候

04:52.210 --> 04:53.210
我们可能会有这么一个情况

04:53.210 --> 04:55.210
就是我一个书主

04:55.210 --> 04:57.210
然后我一个书主

04:57.210 --> 04:59.210
里边我要求一个最大值

04:59.210 --> 05:00.210
我们怎么来使用

05:00.210 --> 05:01.210
跟Mass Max说

05:01.210 --> 05:02.210
肯定不能把书主传进去

05:02.210 --> 05:03.210
因为它的传法

05:03.210 --> 05:04.210
是一个书主的传递

05:04.210 --> 05:05.210
不是吧

05:05.210 --> 05:06.210
它传的是

05:06.210 --> 05:07.210
书主展开之后

05:07.210 --> 05:09.210
一个一个的传递进去

05:09.210 --> 05:10.210
那怎么办呢

05:10.210 --> 05:12.210
我们就可以利用展开运算符

05:12.210 --> 05:13.210
你写三个点

05:13.210 --> 05:14.210
在书主前面

05:14.210 --> 05:16.210
相当于是把这个书主展开

05:16.210 --> 05:17.210
展开之后就相当于是

05:17.210 --> 05:18.210
这边你把这个书主的

05:18.210 --> 05:19.210
每一项的值

05:19.210 --> 05:20.210
一次展开了

05:20.210 --> 05:21.210
放这儿

05:21.210 --> 05:22.210
就这么简单

05:22.210 --> 05:23.210
展开运算符

05:23.210 --> 05:24.210
展开运算符可以用到

05:24.210 --> 05:25.210
各种各样的场景

05:25.210 --> 05:26.210
咱们来看一下

05:26.210 --> 05:27.210
下边的一个例子

05:27.210 --> 05:28.210
针对对象的展开

05:28.210 --> 05:30.210
你看我这有两个对象

05:30.210 --> 05:34.210
O1 O2 A1 B2 A3 C4

05:34.210 --> 05:35.210
然后呢

05:35.210 --> 05:36.210
我想把这两个对象

05:36.210 --> 05:38.210
合并成一个新的对象

05:38.210 --> 05:39.210
我们也可以利用

05:39.210 --> 05:40.210
展开运算符

05:40.210 --> 05:41.210
怎么写呢

05:41.210 --> 05:43.210
O3是一个新的对象

05:43.210 --> 05:44.210
两个大方号

05:44.210 --> 05:45.210
然后呢

05:45.210 --> 05:47.210
O1的所有东西展开

05:47.210 --> 05:48.210
把这个对象展开

05:48.210 --> 05:49.210
展开之后变成什么呢

05:49.210 --> 05:50.210
变成这里就相当于

05:50.210 --> 05:54.210
是你写的一个A1 B2

05:54.210 --> 05:55.210
知道吧

05:55.210 --> 05:59.950
我们把复制过来吧

05:59.950 --> 06:00.950
你看啊

06:00.950 --> 06:02.950
我们这里把O1展开

06:02.950 --> 06:03.950
展开之后相当于是

06:03.950 --> 06:04.950
把里边的东西

06:04.950 --> 06:05.950
一个个拿出来

06:05.950 --> 06:07.950
A1 B2

06:07.950 --> 06:09.950
然后再把O2展开

06:09.950 --> 06:10.950
就相当于是把这里

06:10.950 --> 06:15.950
A3 C4

06:15.950 --> 06:16.950
那里说的东西

06:16.950 --> 06:17.950
输出O3等于多少

06:19.950 --> 06:20.950
印象

06:20.950 --> 06:21.950
是不是

06:22.950 --> 06:23.950
后边的A

06:23.950 --> 06:24.950
就把前面的A覆盖了

06:24.950 --> 06:26.950
把A等于3B等于2C等于4

06:26.950 --> 06:28.950
这就是展开运算符

06:28.950 --> 06:29.950
简单吧

06:29.950 --> 06:30.950
就写三个点

06:30.950 --> 06:31.950
它就可以把一个对象

06:31.950 --> 06:32.950
一个数组展开

06:32.950 --> 06:33.950
好

06:33.950 --> 06:34.950
咱们再来看

06:34.950 --> 06:35.950
我写了很多的例子

06:35.950 --> 06:36.950
比方说我一个数组

06:36.950 --> 06:40.780
我可以这样子写

06:40.780 --> 06:42.780
我这个数组的2参4

06:42.780 --> 06:43.780
然后呢

06:43.780 --> 06:44.780
我要生成一个新数组

06:44.780 --> 06:45.780
新数组的第一项为1

06:45.780 --> 06:46.780
最后一项为5

06:46.780 --> 06:47.780
中间

06:47.780 --> 06:48.780
把原来这个数组

06:48.780 --> 06:49.780
放在中间

06:49.780 --> 06:50.780
那怎么写呢

06:50.780 --> 06:51.780
你看这个数组

06:51.780 --> 06:52.780
第一个位置放1

06:52.780 --> 06:53.780
然后接下来

06:53.780 --> 06:54.780
把上面那个数组展开

06:54.780 --> 06:55.780
那相当于是

06:55.780 --> 06:56.780
这里写的个2参4

06:57.780 --> 06:58.780
对吧

06:58.780 --> 06:59.780
然后最后一个为5

06:59.780 --> 07:00.780
是非常舒服

07:00.780 --> 07:01.780
展开运算符

07:04.150 --> 07:05.150
看没

07:05.150 --> 07:06.150
就这么回事

07:06.150 --> 07:07.150
展开

07:07.150 --> 07:08.150
然后还有个例子

07:08.150 --> 07:09.150
咱们再来看这个例子

07:11.150 --> 07:12.150
有一个用户对象

07:12.150 --> 07:13.150
有两个用户对象

07:13.150 --> 07:14.150
第一个用户对象

07:14.150 --> 07:15.150
有一个Name属性

07:15.150 --> 07:16.150
有一个A级属性

07:16.150 --> 07:17.150
那么第二个用户对象

07:17.150 --> 07:18.150
我想这样子

07:18.150 --> 07:20.150
我想保留

07:20.150 --> 07:21.150
就是其他的属性

07:21.150 --> 07:22.150
跟它一样

07:22.150 --> 07:23.150
但是我想把Name属性

07:23.150 --> 07:24.150
改一下

07:25.150 --> 07:26.150
那过去咋写呢

07:26.150 --> 07:27.150
过去还有一点麻烦

07:27.150 --> 07:28.150
对吧

07:28.150 --> 07:29.150
就是其他的属性

07:29.150 --> 07:30.150
跟这个上面的属性一样

07:30.150 --> 07:31.150
但是我要把Name属性

07:31.150 --> 07:32.150
改一下

07:32.150 --> 07:33.150
比方说我这里

07:33.150 --> 07:34.150
只写了两个属性

07:34.150 --> 07:35.150
当然他有可能

07:35.150 --> 07:36.150
会有十几二十个属性

07:37.150 --> 07:38.150
那我不想一一复职了

07:38.150 --> 07:39.150
我就想

07:39.150 --> 07:40.150
其他的属性都保持一样

07:40.150 --> 07:41.150
我就把Name改一下

07:41.150 --> 07:42.150
怎么写呢

07:42.150 --> 07:43.150
我就可以这样写

07:43.150 --> 07:44.150
我把这个U2展开

07:45.150 --> 07:46.150
这一展开

07:46.150 --> 07:47.150
这里边是不是全

07:47.150 --> 07:48.150
全部出来了

07:48.150 --> 07:49.150
相当于是把这两个

07:49.150 --> 07:50.150
是不是写到这了

07:51.150 --> 07:52.150
对吧

07:52.150 --> 07:53.150
然后我下面再重新

07:53.150 --> 07:54.150
修改一下Name

07:55.150 --> 07:56.150
不就完事了吗

07:56.150 --> 07:57.150
所以说呢

07:57.150 --> 07:58.150
这样子一写

07:58.150 --> 07:59.150
得到最终结果了

07:59.150 --> 08:00.150
U2

08:01.150 --> 08:02.150
你看

08:02.150 --> 08:03.150
不是这个字吗

08:04.150 --> 08:05.150
就展开运算

08:06.150 --> 08:07.150
下边解构

08:08.150 --> 08:09.150
解构呢

08:09.150 --> 08:10.150
又是一种什么东西呢

08:10.150 --> 08:11.150
比方说我这里

08:11.150 --> 08:12.150
有个对象

08:12.150 --> 08:13.150
拿过来

08:13.150 --> 08:15.460
我这里有个对象

08:15.460 --> 08:16.460
这个对象里边

08:16.460 --> 08:17.460
有个乱七八糟的一大堆属性

08:17.460 --> 08:18.460
但是这一属性

08:18.460 --> 08:19.460
可能有很多

08:19.460 --> 08:20.460
我这里写了几个

08:20.460 --> 08:21.460
可能有十几二十段

08:21.460 --> 08:22.460
但是呢

08:22.460 --> 08:24.460
我不想用那么多

08:24.460 --> 08:25.460
我可能只需要

08:25.460 --> 08:26.460
用其中一部分

08:27.460 --> 08:28.460
那以前我再打写了

08:28.460 --> 08:29.460
比方说我要用这个Name属性

08:29.460 --> 08:31.460
和这个Province属性

08:31.460 --> 08:32.460
那我以前我打写

08:32.460 --> 08:34.460
我说得写个U2.Name

08:34.460 --> 08:35.460
没问题吧

08:35.460 --> 08:36.460
但是当然一点的

08:36.460 --> 08:37.460
问题都没有啊

08:37.460 --> 08:38.460
OK的

08:38.460 --> 08:39.460
然后或者是写ADDR

08:39.460 --> 08:40.460
Province

08:40.460 --> 08:41.460
我要取这两个

08:42.460 --> 08:43.460
但是如果说

08:43.460 --> 08:44.460
我后边

08:44.460 --> 08:45.460
很多地方都要用到

08:45.460 --> 08:46.460
这两个东西

08:46.460 --> 08:48.460
那每一次都写这么一长串

08:48.460 --> 08:49.460
有点麻烦

08:49.460 --> 08:50.460
所以说一月十六

08:50.460 --> 08:51.460
然后就说

08:51.460 --> 08:52.460
那你要不然这样子

08:52.460 --> 08:53.460
你直接取出来呗

08:53.460 --> 08:54.460
那你怎么写呢

08:54.460 --> 08:55.460
你就可以这样子写

08:55.460 --> 08:56.460
把这个Name取出来

08:56.460 --> 08:57.460
对吧

08:57.460 --> 08:58.460
然后呢

08:58.460 --> 09:00.460
把这个Province取出来

09:00.460 --> 09:01.460
取出来之后

09:01.460 --> 09:02.460
是不是就可以使用变量了

09:02.460 --> 09:03.460
对吧

09:03.460 --> 09:05.460
以前的得这么写

09:05.460 --> 09:06.460
那么现在呢

09:06.460 --> 09:07.460
有那种新的写法

09:07.460 --> 09:09.460
可以直接取出来

09:09.460 --> 09:10.460
怎么取呢

09:10.460 --> 09:11.460
你看我这样子写

09:11.460 --> 09:12.460
把U字放这

09:12.460 --> 09:15.460
我要从这边取啥呀

09:15.460 --> 09:16.460
我定一个长量

09:16.460 --> 09:17.460
然后你用变量的话

09:17.460 --> 09:18.460
这里边就可以修改

09:18.460 --> 09:19.460
用长量的话

09:19.460 --> 09:20.460
这里边就不能修改

09:21.460 --> 09:22.460
我用这种

09:22.460 --> 09:23.460
两个大户号

09:23.460 --> 09:24.460
这种新语法

09:24.460 --> 09:25.460
叫做解构

09:25.460 --> 09:26.460
把解开

09:26.460 --> 09:28.460
它里边不是我要取什么

09:28.460 --> 09:29.460
取Name和2A级吗

09:29.460 --> 09:30.460
对吧

09:30.460 --> 09:31.460
Name,A级取出来

09:31.460 --> 09:32.460
于是呢

09:32.460 --> 09:33.460
就生成了两个长量

09:33.460 --> 09:34.460
一个Name长量

09:34.460 --> 09:35.460
一个A级长量

09:35.460 --> 09:36.460
它的值呢

09:36.460 --> 09:37.460
跟U字里面的

09:37.460 --> 09:39.460
对应到U字里面的Name和A级

09:39.460 --> 09:40.460
对吧

09:40.460 --> 09:41.460
就输出Name和A级

09:41.460 --> 09:42.460
再输出这两个

09:42.460 --> 09:43.460
看你明白

09:44.460 --> 09:45.460
那如果说

09:45.460 --> 09:47.460
我要取这个Ct呢

09:47.460 --> 09:48.460
Ct在哪

09:48.460 --> 09:49.460
是不是在ADDR里边

09:49.460 --> 09:50.460
那里解构的时候

09:50.460 --> 09:51.460
得这样子写

09:51.460 --> 09:53.460
由这儿写到这边

09:53.460 --> 09:54.460
然后前边呢

09:54.460 --> 09:55.460
ADDR

09:55.460 --> 09:57.460
从ADDR里边冒号

09:57.460 --> 09:58.460
对它里边的东西

09:58.460 --> 09:59.460
进行解构

09:59.460 --> 10:00.460
解出来Ct

10:00.460 --> 10:02.460
那么你就可以拿到Ct了

10:02.460 --> 10:03.460
那如果说

10:03.460 --> 10:04.460
我要同时拿到Ct

10:04.460 --> 10:05.460
要拿到Name

10:05.460 --> 10:06.460
就这样子写

10:07.460 --> 10:08.460
关于解构更多的

10:08.460 --> 10:09.460
更详细的文档

10:09.460 --> 10:10.460
这里有个MDN

10:10.460 --> 10:12.460
其实平时我们也

10:12.460 --> 10:13.460
就用这些简单

10:13.460 --> 10:14.460
那就完全够了

10:15.460 --> 10:16.460
这是解构

10:16.460 --> 10:17.460
然后这项下面再有个例子

10:17.460 --> 10:19.460
对数组也可以解构

10:19.460 --> 10:20.460
你看啊

10:22.460 --> 10:24.460
我说了1234有这么一个数组

10:24.460 --> 10:25.460
我想把这个数组的每一项

10:25.460 --> 10:26.460
放到BnA里边

10:26.460 --> 10:28.460
第二项放到BnB里边

10:28.460 --> 10:29.460
第三项放到Cd

10:29.460 --> 10:30.460
四项放到D

10:30.460 --> 10:31.460
以前我要得写四行

10:31.460 --> 10:32.460
对不对

10:32.460 --> 10:33.460
每一行一个复职

10:33.460 --> 10:34.460
那么现在呢

10:34.460 --> 10:36.460
我们直接一句话写完

10:37.460 --> 10:38.460
AR放这儿

10:38.460 --> 10:39.460
然后对数组的解构

10:39.460 --> 10:40.460
就用中扩号

10:40.460 --> 10:41.460
对对象的解构呢

10:41.460 --> 10:43.460
就用大扩号

10:43.460 --> 10:44.460
很好理解

10:44.460 --> 10:45.460
对象就大扩号

10:45.460 --> 10:46.460
数组融扩号

10:46.460 --> 10:47.460
然后呢

10:47.460 --> 10:48.460
一次放就完事了

10:48.460 --> 10:49.460
A B C D

10:49.460 --> 10:50.460
那么他就把

10:50.460 --> 10:51.460
他就这样子

10:51.460 --> 10:52.460
他就把这个1呢

10:52.460 --> 10:53.460
复职给了A

10:53.460 --> 10:54.460
把2呢

10:54.460 --> 10:55.460
复职给了B

10:55.460 --> 10:56.460
把C

10:56.460 --> 10:57.460
3复职给了C

10:57.460 --> 10:58.460
4复职给了D

10:58.460 --> 10:59.460
完成解构了

10:59.460 --> 11:00.460
是不是很舒服

11:00.460 --> 11:02.460
以之后想写了就用

11:02.460 --> 11:04.460
想不写就拉到

11:04.460 --> 11:05.460
就这么一个东西

11:05.460 --> 11:07.460
然后我们运行看一下

11:07.460 --> 11:09.460
两边就一样算是吗

11:10.460 --> 11:11.460
好那么下面

11:11.460 --> 11:12.460
我们还有一些例子

11:12.460 --> 11:14.460
比方说我要这样子

11:14.460 --> 11:16.460
我只要只是

11:16.460 --> 11:17.460
把2复职给A

11:17.460 --> 11:18.460
3复职给B

11:18.460 --> 11:19.460
那又怎么写呢

11:19.460 --> 11:20.460
你第一个位置

11:20.460 --> 11:21.460
控着直接写个头号

11:21.460 --> 11:22.460
就前面不写

11:22.460 --> 11:23.460
第二个位置A

11:23.460 --> 11:25.460
那么就相当于是

11:25.460 --> 11:27.460
什么1没有

11:27.460 --> 11:29.460
2复职给A

11:29.460 --> 11:31.460
3复职给B

11:31.460 --> 11:32.460
后边不要了

11:32.460 --> 11:34.460
那么得到就是A和B

11:34.460 --> 11:35.460
那就是2和3

11:35.460 --> 11:37.460
好既然那么还有

11:37.460 --> 11:38.460
还有很多的写法

11:38.460 --> 11:39.460
比方说你像这个地方

11:39.460 --> 11:41.460
我要把2和复职给A

11:41.460 --> 11:42.460
4复职给B

11:42.460 --> 11:44.460
那么我可以这样子写

11:44.460 --> 11:46.460
A

11:46.460 --> 11:48.460
2复职给A

11:48.460 --> 11:49.460
4复职给B

11:49.460 --> 11:50.460
你看中间空了对吧

11:50.460 --> 11:51.460
说空了

11:51.460 --> 11:52.460
空了对吧

11:52.460 --> 11:54.460
这个地方空了对吧

11:54.460 --> 11:55.460
相当于是站位

11:55.460 --> 11:57.460
那我们还有很多玩法

11:57.460 --> 11:58.460
比方说我这里呢

11:58.460 --> 12:00.460
把前两项复职给A和B

12:00.460 --> 12:02.460
然后后边的东西呢

12:02.460 --> 12:04.460
放到一个新的数组里边

12:04.460 --> 12:05.460
以前怎么能做

12:05.460 --> 12:07.460
以前可以用循环

12:07.460 --> 12:08.460
一个个写写

12:08.460 --> 12:09.460
那现在一句话写完

12:09.460 --> 12:10.460
你看

12:10.460 --> 12:11.460
第一个位置A

12:11.460 --> 12:12.460
对应到这

12:12.460 --> 12:13.460
第二个位置B

12:13.460 --> 12:14.460
对应到这

12:14.460 --> 12:15.460
后边的位置

12:15.460 --> 12:18.460
我全部放到那个AR里边

12:18.460 --> 12:20.460
我进入了一个展开运算幅

12:20.460 --> 12:22.460
你看

12:22.460 --> 12:23.460
像是一个展开运算幅

12:23.460 --> 12:25.460
那么把

12:25.460 --> 12:26.460
相当于是这个

12:26.460 --> 12:27.460
这个展开运算幅的意思呢

12:27.460 --> 12:28.460
就相当于是收集

12:28.460 --> 12:29.460
收集后边的东西

12:29.460 --> 12:32.460
放到这个数组AR里边

12:32.460 --> 12:33.460
那意思吧

12:33.460 --> 12:34.460
它就完事了

12:34.460 --> 12:35.460
我们来看一下

12:35.460 --> 12:37.460
输出A和B和AR

12:38.460 --> 12:39.460
试一下

12:40.460 --> 12:41.460
你看

12:41.460 --> 12:42.460
后边AR

12:42.460 --> 12:43.460
是不是三合四

12:43.460 --> 12:44.460
对对

12:44.460 --> 12:46.460
这就是那个

12:46.460 --> 12:47.460
解构

12:47.460 --> 12:48.460
还有写好玩的

12:48.460 --> 12:49.460
比较说这里

12:49.460 --> 12:50.460
这样解构可以玩

12:50.460 --> 12:51.460
说很多有意思的东西

12:51.460 --> 12:53.460
比方说我要交换两个变量

12:53.460 --> 12:55.460
以前得写三句代码

12:55.460 --> 12:56.460
对不对

12:56.460 --> 12:57.460
第一句放一个零食

12:57.460 --> 12:58.460
然后放过去

12:58.460 --> 12:59.460
放回来

12:59.460 --> 13:00.460
现在我们一句话写完

13:00.460 --> 13:01.460
怎么写呢

13:01.460 --> 13:03.460
你看我这有两个变量A和B

13:03.460 --> 13:04.460
我要交换他们

13:04.460 --> 13:06.460
我把A放到第一个

13:06.460 --> 13:07.460
B放到第二个

13:07.460 --> 13:08.460
那相当于是不是

13:08.460 --> 13:09.460
这里就放了一个1

13:09.460 --> 13:10.460
这里就放了一个2

13:10.460 --> 13:12.460
然后对这个数组进行解构

13:12.460 --> 13:13.460
解构出来

13:13.460 --> 13:15.460
把第一个放到B

13:15.460 --> 13:17.460
第二个放到A

13:17.460 --> 13:18.460
不就完了吗

13:18.460 --> 13:19.460
对吧

13:19.460 --> 13:20.460
就解构出来了

13:21.460 --> 13:22.460
之前的我要在前面

13:22.460 --> 13:23.460
加那个concept

13:23.460 --> 13:24.460
现在这是定义变量

13:24.460 --> 13:25.460
定义变量并负责

13:25.460 --> 13:26.460
现在我们不用定义变量

13:26.460 --> 13:28.460
直接给变量负责

13:28.460 --> 13:29.460
也可以

13:29.460 --> 13:30.460
那么现在输出A和B

13:30.460 --> 13:31.460
就交换过来

13:32.460 --> 13:33.460
A和B

13:33.460 --> 13:34.460
当然这里不要写A和B

13:34.460 --> 13:35.460
没问题的

13:36.460 --> 13:37.460
就交换两个变量

13:38.460 --> 13:39.460
好 再来

13:39.460 --> 13:40.460
下边势力4

13:40.460 --> 13:44.740
在参数位置

13:44.740 --> 13:45.740
对传统的对象进行解构

13:45.740 --> 13:46.740
我们来看一下

13:46.740 --> 13:48.740
我们解构的不一定发生在

13:48.740 --> 13:49.740
定义变量

13:49.740 --> 13:51.740
给变量负责的位置

13:51.740 --> 13:52.740
还可以在参数的位置

13:52.740 --> 13:54.740
反而是传递数据的地方

13:54.740 --> 13:55.740
传递的是对象

13:55.740 --> 13:56.740
传递的是数组

13:56.740 --> 13:57.740
都可以进行解构

13:58.740 --> 13:59.740
比方说我们这里

13:59.740 --> 14:00.740
有个函数

14:00.740 --> 14:02.740
这个函数要传一个对象进来

14:02.740 --> 14:03.740
那么比方说

14:03.740 --> 14:05.740
A1 B2 C3

14:05.740 --> 14:06.740
然后把对象传进去

14:06.740 --> 14:07.740
传了对象过去

14:07.740 --> 14:08.740
那么在这里

14:08.740 --> 14:10.740
就可以对这个对象进行解构

14:10.740 --> 14:11.740
你看这个解构

14:11.740 --> 14:12.740
可以写到很多地方

14:12.740 --> 14:14.740
只要有数据传递

14:14.740 --> 14:16.740
负责数据传递

14:16.740 --> 14:19.740
参数传递也是数据传递

14:19.740 --> 14:20.740
都可以解构

14:20.740 --> 14:22.740
那么在这里可以解构

14:22.740 --> 14:23.740
把这个对象解出来

14:23.740 --> 14:25.740
只需要里面的A和B就可以了

14:25.740 --> 14:27.740
那么这里输出A和B

14:27.740 --> 14:29.740
你看一下就输出一和二

14:29.740 --> 14:30.740
走了

14:30.740 --> 14:32.740
把这个对象传到这边

14:32.740 --> 14:33.740
怎么这边

14:33.740 --> 14:34.740
A

14:34.740 --> 14:35.740
解构出来

14:35.740 --> 14:36.740
B

14:36.740 --> 14:37.740
解构出来

14:38.740 --> 14:39.740
可以用到很多地方

14:39.740 --> 14:41.740
比方说4.5

14:42.740 --> 14:44.740
我这就举了很多例子

14:44.740 --> 14:45.740
这个箭头函数

14:45.740 --> 14:46.740
大家还没有学过

14:46.740 --> 14:47.740
没有学过的话

14:47.740 --> 14:48.740
那就算了吧

14:48.740 --> 14:49.740
这个东西

14:49.740 --> 14:51.740
我们以后学箭头函数

14:51.740 --> 14:52.740
再回过来看看吧

14:52.740 --> 14:53.740
4.6

14:54.740 --> 14:56.740
你看我们负责二五循环的时候

14:56.740 --> 14:58.740
也可以进行解构

14:58.740 --> 15:01.430
看着

15:01.430 --> 15:04.430
比方说我这里有个对象数组

15:04.430 --> 15:05.430
有名字

15:05.430 --> 15:06.430
有属性

15:06.430 --> 15:07.430
有姓名

15:07.430 --> 15:08.430
有年龄

15:08.430 --> 15:09.430
姓名年龄

15:09.430 --> 15:10.430
那么之前

15:10.430 --> 15:11.430
我们再用负责二五循环的时候

15:11.430 --> 15:13.430
这里是不是写了一个

15:13.430 --> 15:14.430
变量对吧

15:14.430 --> 15:15.430
一个item

15:15.430 --> 15:17.430
那么这个item是不是对象

15:17.430 --> 15:18.430
把这个东西

15:18.430 --> 15:19.430
先给这个item

15:19.430 --> 15:20.430
然后运行一次

15:20.430 --> 15:21.430
把这个玩意儿

15:21.430 --> 15:22.430
先运行一下item

15:22.430 --> 15:23.430
运行这个

15:23.430 --> 15:24.430
负责二五循环

15:24.430 --> 15:25.430
负责给item

15:25.430 --> 15:26.430
那么之前

15:26.430 --> 15:27.430
我要输出姓名和年龄

15:27.430 --> 15:28.430
怎么输出

15:28.430 --> 15:29.430
就这样子

15:30.430 --> 15:32.430
item.name

15:32.430 --> 15:34.430
item.ed

15:34.430 --> 15:36.430
就得这样循环输出

15:37.430 --> 15:38.430
对吧没问题吧

15:38.430 --> 15:39.430
那么现在其实在这里

15:39.430 --> 15:40.430
也可以解构

15:40.430 --> 15:42.430
凡是遇到那种

15:42.430 --> 15:43.430
数据传递的地方

15:43.430 --> 15:44.430
都可以解构

15:45.430 --> 15:46.430
循环urus

15:46.430 --> 15:47.430
每一个循环像

15:47.430 --> 15:49.430
在这里是一个数据传递

15:49.430 --> 15:50.430
他把第一项传给谁

15:50.430 --> 15:51.430
传给他

15:51.430 --> 15:52.430
传给他的时候

15:52.430 --> 15:53.430
我就在这里可以解构

15:53.430 --> 15:54.430
直接解构出来item.ed

15:54.430 --> 15:55.430
那么这边

15:55.430 --> 15:56.430
我们输出item.ed

15:56.430 --> 15:57.430
就这样子

15:57.430 --> 15:58.430
更加舒服一点

15:58.430 --> 15:59.430
当然如果说

15:59.430 --> 16:00.430
你觉得上面干嘛

16:00.430 --> 16:01.430
看上去不爽

16:01.430 --> 16:02.430
我就喜欢上面的

16:02.430 --> 16:03.430
那你又写上面的

16:03.430 --> 16:04.430
又别人说什么

16:04.430 --> 16:06.430
不要给自己那么大的压力

16:06.430 --> 16:07.430
像这种东西的

16:07.430 --> 16:08.430
都是为了方便你的

16:08.430 --> 16:09.430
如果说你之前看的不爽

16:09.430 --> 16:10.430
觉得麻烦

16:10.430 --> 16:11.430
那就用新的

16:11.430 --> 16:12.430
如果说你之前

16:12.430 --> 16:14.430
觉得还可以

16:14.430 --> 16:15.430
挺好的

16:15.430 --> 16:16.430
我还不喜欢新的

16:16.430 --> 16:17.430
那你用之前的

16:17.430 --> 16:18.430
对吧

16:18.430 --> 16:19.430
萝卜青菜客有所爱嘛

16:21.430 --> 16:22.430
好这是解构

16:22.430 --> 16:24.430
好下边这个

16:24.430 --> 16:26.430
属性描述服务

16:26.430 --> 16:27.430
这个地方

16:27.430 --> 16:28.430
我给他说一下

16:28.430 --> 16:29.430
这个玩意儿

16:29.430 --> 16:30.430
为什么要学习

16:30.430 --> 16:31.430
它

16:31.430 --> 16:32.430
这是ES5的

16:32.430 --> 16:34.430
要喝喝水

16:34.430 --> 16:38.660
为什么要学习

16:38.660 --> 16:40.660
这个属性描述服务呢

16:42.660 --> 16:43.660
实际上

16:43.660 --> 16:45.660
在咱们平时开发中

16:45.660 --> 16:46.660
这个玩意儿

16:46.660 --> 16:48.660
根本就用不到

16:48.660 --> 16:49.660
绝大部分代码

16:49.660 --> 16:51.660
你都不会用这个玩意儿

16:51.660 --> 16:52.660
那为什么要学习它呢

16:52.660 --> 16:53.660
是因为

16:53.660 --> 16:56.660
你们之后要学习无忧

16:56.660 --> 16:57.660
学习无忧的时候

16:57.660 --> 16:59.660
你得应付面试吧

16:59.660 --> 17:00.660
面试干嘛

17:00.660 --> 17:01.660
还要招火箭吧

17:01.660 --> 17:02.660
招火箭的时候

17:02.660 --> 17:04.660
叫温无忧的各种原理

17:04.660 --> 17:06.660
其中一个无忧的原理

17:06.660 --> 17:08.660
它就涉及到这个东西

17:08.660 --> 17:09.660
你没有这个知识的话

17:09.660 --> 17:10.660
到时候你听那个

17:10.660 --> 17:12.660
原理的课你就听不懂

17:12.660 --> 17:13.660
所以说这里呢

17:13.660 --> 17:14.660
给大家介绍一下

17:14.660 --> 17:15.660
其实它跟你们平时开发

17:15.660 --> 17:17.660
没有多少关系

17:17.660 --> 17:18.660
它要复杂吗

17:18.660 --> 17:19.660
也没有那么复杂

17:19.660 --> 17:21.660
它只是有点奇怪而已

17:21.660 --> 17:23.660
这是一个新的功能

17:23.660 --> 17:24.660
就是以前

17:24.660 --> 17:25.660
你不知道这个东西

17:25.660 --> 17:26.660
也是办不到的

17:26.660 --> 17:28.660
有些功能你是说不出来的

17:28.660 --> 17:29.660
好 比方说

17:29.660 --> 17:30.660
我们来看一下

17:30.660 --> 17:31.660
这个属性描述服务

17:31.660 --> 17:33.660
是啥意思啊

17:33.660 --> 17:34.660
比方说一个对象

17:35.660 --> 17:37.660
它是针对对象的

17:37.660 --> 17:38.660
有个对象

17:38.660 --> 17:39.660
有点它里面有两个属性

17:39.660 --> 17:40.660
Name和A级

17:40.660 --> 17:43.660
实际上在介绍内部

17:43.660 --> 17:45.660
它对这个对象来示意

17:45.660 --> 17:46.660
它对这个对象

17:46.660 --> 17:47.660
是有所描述的

17:47.660 --> 17:49.660
它怎么来描述啊

17:49.660 --> 17:51.660
它说我这里有个对象

17:51.660 --> 17:52.660
有两个属性

17:52.660 --> 17:53.660
第一个属性的名字

17:53.660 --> 17:55.660
那叫做Name

17:55.660 --> 17:56.660
第二个属性的名字

17:56.660 --> 17:57.660
那叫做A级

17:57.660 --> 17:59.660
那么针对这个Name属性

17:59.660 --> 18:01.660
是有四个什么情况呢

18:01.660 --> 18:03.660
它是用对象来描述

18:03.660 --> 18:05.660
说这个Name属性

18:05.660 --> 18:07.660
它的纸是Molica

18:07.660 --> 18:12.100
这个属性你不能重新的

18:12.100 --> 18:14.100
去更改这个描述服务

18:14.100 --> 18:15.100
你看每个描述服务

18:15.100 --> 18:16.100
就是个对象

18:16.100 --> 18:18.100
描述服务这样做什么呢

18:18.100 --> 18:19.100
来描述一个属性的

18:19.100 --> 18:20.100
这就是一个属性

18:20.100 --> 18:21.100
来描述它

18:21.100 --> 18:22.100
它的值

18:22.100 --> 18:23.100
它的名字是Name

18:23.100 --> 18:24.100
值呢

18:24.100 --> 18:25.100
是Molica

18:25.100 --> 18:27.100
那么这是个描述服务

18:27.100 --> 18:28.100
那么这个配置

18:28.100 --> 18:29.100
表示说

18:29.100 --> 18:31.100
这个描述服务能不能更改

18:31.100 --> 18:33.100
能不能改

18:34.100 --> 18:35.100
能改

18:35.100 --> 18:36.100
默认为错

18:36.100 --> 18:38.100
Name而不什么意思呢

18:38.100 --> 18:40.100
就说这个属性啊

18:40.100 --> 18:41.100
我们在用Folding循环

18:41.100 --> 18:42.100
在遍地的时候

18:42.100 --> 18:44.100
它能否被遍地

18:44.100 --> 18:46.100
它会影响到一些东西

18:46.100 --> 18:47.100
它默认为错

18:47.100 --> 18:48.100
所以说呢

18:48.100 --> 18:50.100
我们平时写一个代码

18:50.100 --> 18:51.100
比方说我们这里有个优势

18:51.100 --> 18:53.100
我们去使用Folding循环

18:53.100 --> 18:54.100
去遍地它

18:55.100 --> 18:56.100
遍地这个优势

18:56.100 --> 18:58.100
那么我们这里输出这个T

18:58.100 --> 19:00.100
是不是能够把Name和A级

19:00.100 --> 19:01.100
输出出来

19:01.100 --> 19:03.100
那么为什么能输出出来

19:03.100 --> 19:04.100
知道吗

19:04.100 --> 19:05.100
为什么能输出出来

19:05.100 --> 19:07.100
就是因为它的属性

19:07.100 --> 19:08.100
描述服务里边

19:08.100 --> 19:10.100
有个配置叫Enumerable

19:10.100 --> 19:11.100
告诉他

19:11.100 --> 19:13.100
这个属性是能够

19:13.100 --> 19:15.100
被遍地的

19:15.100 --> 19:16.100
为错

19:16.100 --> 19:17.100
Ritable

19:17.100 --> 19:18.100
什么意思

19:18.100 --> 19:19.100
这个属性能不能改

19:19.100 --> 19:20.100
能不能更改

19:20.100 --> 19:21.100
这个属性的值

19:21.100 --> 19:22.100
默认为错

19:22.100 --> 19:23.100
所以说你

19:23.100 --> 19:24.100
正因为它默认为错

19:24.100 --> 19:25.100
所以说你这里

19:25.100 --> 19:26.100
去改这个Name

19:26.100 --> 19:28.100
是能改的

19:28.100 --> 19:29.100
知道吧

19:29.100 --> 19:30.100
有一些朋友觉得

19:30.100 --> 19:31.100
是理所当然的

19:31.100 --> 19:32.100
所以他不是理所当然的

19:32.100 --> 19:34.100
是因为他属性描述服务里边

19:34.100 --> 19:35.100
他有这么一个配置

19:35.100 --> 19:37.100
你才能改

19:37.100 --> 19:39.100
那你看A级属性是一样的

19:39.100 --> 19:41.100
A级属性我这里写错了

19:41.100 --> 19:43.100
是一样的

19:44.100 --> 19:45.100
那么知道了

19:45.100 --> 19:46.100
这个属性描述服务

19:46.100 --> 19:47.100
是什么东西

19:47.100 --> 19:48.100
就是每一个东西

19:48.100 --> 19:49.100
来描述一个属性

19:49.100 --> 19:51.100
每一个东西来描述一个属性

19:51.100 --> 19:53.100
它是在内部生成的

19:53.100 --> 19:55.100
以前你是不能动这个玩意儿的

19:55.100 --> 19:57.100
你都看不见

19:57.100 --> 19:59.100
到ES5之后

19:59.100 --> 20:01.100
它提供了一个接口

20:01.100 --> 20:03.100
让你可以去改这个东西

20:03.100 --> 20:06.100
针对这个属性的描述可以改

20:06.100 --> 20:07.100
那怎么改呢

20:07.100 --> 20:08.100
它提供了一些方法

20:08.100 --> 20:10.100
首先是能够获取

20:10.100 --> 20:13.100
Guess OM Property Descriptor

20:13.100 --> 20:15.100
这么一个静态方法

20:15.100 --> 20:18.060
咱们来看一下吧

20:18.060 --> 20:20.060
第一个参数传对相

20:20.060 --> 20:21.060
一把对相传进去

20:21.060 --> 20:22.060
第二个参数

20:22.060 --> 20:23.060
它传属性的名字

20:23.060 --> 20:25.060
比方说传在Name

20:25.060 --> 20:26.060
我们就可以拿到

20:26.060 --> 20:28.060
针对这个对相的Name属性

20:28.060 --> 20:30.060
它的描述符

20:30.060 --> 20:32.060
我们来输出一下

20:32.060 --> 20:34.060
这个描述符是啥

20:34.060 --> 20:36.060
你看

20:36.060 --> 20:37.060
它的值

20:37.060 --> 20:39.060
属性的值

20:39.060 --> 20:40.060
属性能改吗

20:40.060 --> 20:41.060
能改

20:41.060 --> 20:42.060
属性能便利吗

20:42.060 --> 20:44.060
可以便利

20:44.060 --> 20:45.060
这个描述符对相

20:45.060 --> 20:46.060
能够重新配置吗

20:46.060 --> 20:48.060
可以的

20:48.060 --> 20:49.060
是不是

20:49.060 --> 20:51.060
就得到这么一个描述符对相

20:51.060 --> 20:53.060
凭什么开发都用不到了

20:53.060 --> 20:54.060
我就过一遍

20:54.060 --> 20:56.060
看一看就行了

20:56.060 --> 20:57.060
因为有些东西

20:57.060 --> 20:59.060
你一点儿不知道

20:59.060 --> 21:00.060
也不合适

21:00.060 --> 21:01.060
你知道了

21:01.060 --> 21:03.060
你用不用它是一回事

21:03.060 --> 21:05.060
但是你得知道一下

21:05.060 --> 21:06.060
然后呢

21:06.060 --> 21:07.060
第二个方法就很重要了

21:07.060 --> 21:08.060
它说你可以改

21:08.060 --> 21:10.060
通过这个方法

21:10.060 --> 21:12.060
你可以改它的属性描述符

21:12.060 --> 21:13.060
咋改呢

21:13.060 --> 21:15.060
比方说我这里先改

21:15.060 --> 21:17.060
通过Object的DefineProperty

21:17.060 --> 21:19.060
对相传进去

21:20.060 --> 21:22.060
属性名传进去

21:23.060 --> 21:25.060
第三个就是属性描述符

21:26.060 --> 21:28.060
这里可以改的

21:28.060 --> 21:29.060
第三个是个对相

21:29.060 --> 21:30.060
怎么写

21:30.060 --> 21:31.060
就这种写法

21:31.060 --> 21:33.060
比方你把它Venue改成什么呢

21:33.060 --> 21:34.060
改成了

21:37.060 --> 21:39.060
然后把它的Retable

21:39.060 --> 21:41.060
改成了Force

21:41.060 --> 21:43.060
然后把它Enumerable改成Force

21:43.060 --> 21:45.060
Configurable改成了Force

21:45.060 --> 21:46.060
你看一下

21:46.060 --> 21:47.060
它之前不都是True吗

21:47.060 --> 21:48.060
把它改成Force

21:48.060 --> 21:49.060
看一下

21:49.060 --> 21:51.060
好改了之后你看

21:51.060 --> 21:53.060
重新修改了这个对相的属性

21:53.060 --> 21:55.060
这个Name属性的描述符

21:55.060 --> 21:56.060
修改了之后

21:56.060 --> 21:57.060
我们再得到描述符

21:57.060 --> 21:58.060
你看一下

21:58.060 --> 21:59.060
所以凳格了

21:59.060 --> 22:01.060
这有点变Force

22:01.060 --> 22:04.060
变Force有什么用呢

22:04.060 --> 22:06.060
看着有什么用

22:07.060 --> 22:10.060
首先我们输出一下User.name

22:10.060 --> 22:12.060
它的值变成了凳格

22:12.060 --> 22:14.060
这个没问题吧

22:14.060 --> 22:16.060
属性描述符居然描述属性了

22:16.060 --> 22:19.060
然后我们再看一下

22:19.060 --> 22:22.060
我要把User.name改一下

22:23.060 --> 22:26.690
它能不能改回来

22:26.690 --> 22:27.690
你看改了没用

22:27.690 --> 22:28.690
为什么没用呢

22:28.690 --> 22:29.690
Retable为Force

22:29.690 --> 22:31.690
这个属性不能更改

22:31.690 --> 22:33.690
以前你能想象吗

22:33.690 --> 22:34.690
想象不到吧

22:34.690 --> 22:36.690
那现在有了这么个东西发现

22:36.690 --> 22:38.690
也属性是可以

22:38.690 --> 22:40.690
只读了不能更改

22:40.690 --> 22:41.690
Enumerable为Force

22:41.690 --> 22:43.690
那么这会影响啥呢

22:43.690 --> 22:44.690
呼应循环里边

22:44.690 --> 22:46.690
你再去循环它

22:46.690 --> 22:48.690
我们能看到的属性

22:48.690 --> 22:51.640
只有A级

22:51.640 --> 22:53.640
Name没了

22:53.640 --> 22:54.640
为什么呢

22:54.640 --> 22:56.640
因为这个Name属性是不能变异的

22:56.640 --> 22:58.640
Configurable为Force

22:58.640 --> 22:59.640
说明了啥

22:59.640 --> 23:02.640
你再一想去改这个属性描述符

23:02.640 --> 23:03.640
哦哦

23:03.640 --> 23:04.640
不能改了

23:04.640 --> 23:06.640
比方说你要把值改成什么

23:06.640 --> 23:08.640
改成123

23:08.640 --> 23:10.640
那么输出一下User.name

23:10.640 --> 23:14.850
它直接爆错了

23:14.850 --> 23:17.850
它说不能定义属性Name

23:17.850 --> 23:18.850
为什么不能定义呢

23:18.850 --> 23:20.850
因为之前是配置过

23:20.850 --> 23:22.850
它不能再重新配置了

23:23.850 --> 23:24.850
默认为粗

23:24.850 --> 23:25.850
如果你是作为粗的话

23:25.850 --> 23:26.850
那就OK

23:26.850 --> 23:27.850
它就可以改

23:27.850 --> 23:28.850
但是你把它作为Force

23:28.850 --> 23:30.850
它之后就不能再

23:30.850 --> 23:31.850
通过这种方式

23:31.850 --> 23:33.850
重新修改属性描述符了

23:33.850 --> 23:34.850
大概了解一下

23:34.850 --> 23:36.850
就OK了

23:36.850 --> 23:37.850
终点在这

23:37.850 --> 23:39.850
属性描述符里边可以

23:39.850 --> 23:40.850
除了上面这些

23:40.850 --> 23:41.850
碰断起八道的配置之外

23:41.850 --> 23:43.850
还有getter和setter

23:43.850 --> 23:44.850
这个玩意才有

23:44.850 --> 23:45.850
真的有意思

23:45.850 --> 23:46.850
这是啥玩意呢

23:46.850 --> 23:51.380
我给大家看一下

23:51.380 --> 23:53.380
你们之后学习为用

23:53.380 --> 23:54.380
讲原理的时候

23:54.380 --> 23:56.380
重点就在这

23:56.380 --> 23:58.380
就是个属性描述符里边

23:58.380 --> 23:59.380
除了之前的那些

23:59.380 --> 24:01.380
碰断起八道的东西之外

24:01.380 --> 24:02.380
除了这些东西之外

24:02.380 --> 24:04.380
还有两个东西

24:04.380 --> 24:05.380
一个叫做getter

24:05.380 --> 24:06.380
它实际上是一个配置函数

24:06.380 --> 24:08.380
你看我给一个对象

24:08.380 --> 24:10.380
配置一个属性A

24:10.380 --> 24:11.380
它可以没有一个属性

24:11.380 --> 24:13.380
给它加一个属性A就行了

24:13.380 --> 24:14.380
在这里

24:14.380 --> 24:15.380
配置了一个A

24:15.380 --> 24:16.380
这个属性描述符

24:16.380 --> 24:18.380
我没有用Value

24:18.380 --> 24:19.380
我用的是什么呢

24:19.380 --> 24:20.380
两个函数

24:20.380 --> 24:21.380
这两个函数

24:21.380 --> 24:22.380
分别叫做getter

24:22.380 --> 24:26.650
和setter

24:26.650 --> 24:27.650
getter

24:27.650 --> 24:29.650
和setter

24:29.650 --> 24:30.650
好了

24:30.650 --> 24:32.650
那么这两个函数呢

24:32.650 --> 24:34.650
get 函数是什么意思呢

24:34.650 --> 24:37.650
凡是以后读这个A属性

24:37.650 --> 24:39.650
它就会运行这个函数

24:39.650 --> 24:41.650
把这个函数的返回结果

24:41.650 --> 24:43.650
作为属性值

24:44.650 --> 24:45.650
然后你比方说

24:45.650 --> 24:46.650
你现在去看一下

24:46.650 --> 24:47.650
输出一下OB界叫A

24:47.650 --> 24:49.650
它会得到啥呀

24:49.650 --> 24:51.650
它会运行get 函数

24:51.650 --> 24:53.650
get 函数 函数 它返回1

24:53.650 --> 24:56.650
那么这个属性值就是1

24:57.650 --> 24:58.650
知道了

24:58.650 --> 24:59.650
有意思吧

24:59.650 --> 25:02.650
所以说这里有了getter之后

25:02.650 --> 25:04.650
之后再用这个属性了

25:04.650 --> 25:06.650
它相当于是雕用了

25:06.650 --> 25:08.650
这个get 函数

25:08.650 --> 25:09.650
也就是说现在

25:09.650 --> 25:10.650
相当于是在这里

25:10.650 --> 25:12.650
雕用了一次get 函数

25:12.650 --> 25:13.650
没什么意思吧

25:13.650 --> 25:14.650
当然这里不能直接运行

25:14.650 --> 25:16.650
这是描述符里边的东西

25:16.650 --> 25:17.650
要通过属性

25:17.650 --> 25:18.650
读这个属性

25:18.650 --> 25:20.650
它就会运行get

25:20.650 --> 25:21.650
那么如果说在get

25:22.650 --> 25:23.650
输出一句话

25:23.650 --> 25:24.650
它还会输出一句话

25:24.650 --> 25:26.650
你看是不是运行到get

25:26.650 --> 25:27.650
对不对

25:27.650 --> 25:28.650
以后无用

25:28.650 --> 25:31.650
它会用到这个特点

25:31.650 --> 25:32.650
那么这个set

25:32.650 --> 25:34.650
它就相当于复制了

25:34.650 --> 25:36.650
当你给这个属性复制的时候

25:36.650 --> 25:40.650
比方说复制为456

25:40.650 --> 25:42.650
那么就相当于是

25:42.650 --> 25:43.650
雕用这个set

25:43.650 --> 25:45.650
把456传进去

25:45.650 --> 25:47.650
就这么回事

25:47.650 --> 25:48.650
它雕用这个set

25:48.650 --> 25:50.650
函数把456传进去

25:50.650 --> 25:51.650
这句话你就可以看到

25:51.650 --> 25:52.650
输出了什么

25:52.650 --> 25:54.650
输出了456

25:54.650 --> 25:57.650
好那么大家问大家一个问题

25:57.650 --> 25:58.650
我给这个

25:58.650 --> 25:59.650
我先输出一下

25:59.650 --> 26:00.650
这个obget

26:00.650 --> 26:01.650
演示过了对吧

26:01.650 --> 26:02.650
输出什么

26:02.650 --> 26:03.650
输出1

26:03.650 --> 26:05.650
然后我再给这个obget

26:05.650 --> 26:06.650
复制为1

26:06.650 --> 26:08.650
然后我再输出这个obget

26:08.650 --> 26:10.650
或者是我前面就不写了

26:10.650 --> 26:11.650
你们觉得

26:11.650 --> 26:13.650
这句话会输出多少

26:13.650 --> 26:16.650
会输出多少

26:16.650 --> 26:18.650
是不是得输出100

26:18.650 --> 26:19.650
是吧

26:20.650 --> 26:21.650
不是的

26:21.650 --> 26:22.650
同学

26:23.650 --> 26:25.650
只要有了getter和setter

26:25.650 --> 26:27.650
它就不暂时一个正常的属性了

26:27.650 --> 26:30.650
你读属性运行get

26:30.650 --> 26:32.650
复制运行set

26:32.650 --> 26:34.650
它实际上这句话

26:34.650 --> 26:36.650
根本就运行的不是这两句话

26:36.650 --> 26:37.650
运行的是啥

26:37.650 --> 26:39.650
运行的是set

26:39.650 --> 26:41.650
运行的是set

26:41.650 --> 26:42.650
100

26:42.650 --> 26:45.650
然后再运行输出get

26:45.650 --> 26:47.650
你觉得是多少

26:47.650 --> 26:48.650
set100

26:48.650 --> 26:49.650
这里输出100

26:49.650 --> 26:51.650
当然这里会有输出

26:51.650 --> 26:53.650
把这句话去了

26:53.650 --> 26:54.650
运行set

26:54.650 --> 26:55.650
它就把个喊出运行一遍

26:55.650 --> 26:56.650
啥也没做

26:56.650 --> 26:58.650
然后再输出get

26:58.650 --> 26:59.650
得到了是1

26:59.650 --> 27:00.650
对吧

27:00.650 --> 27:01.650
所以得到的结果还是1

27:01.650 --> 27:03.650
你不要被表面献像

27:03.650 --> 27:04.650
我们疑惑了

27:04.650 --> 27:05.650
这是getter

27:05.650 --> 27:07.650
set非常

27:07.650 --> 27:08.650
奇特的一点

27:08.650 --> 27:10.650
得到的还是1

27:10.650 --> 27:11.650
但如果说你要把它

27:11.650 --> 27:12.650
用这种方式

27:12.650 --> 27:13.650
变成一个正常的属性

27:13.650 --> 27:14.650
你可以复制为100

27:14.650 --> 27:15.650
你就要输出100

27:15.650 --> 27:17.650
那么怎么做呢

27:17.650 --> 27:19.650
那里需要一个变量

27:19.650 --> 27:21.650
比方我们这里有个变量

27:21.650 --> 27:22.650
intel

27:22.650 --> 27:26.090
随便取个名字

27:26.090 --> 27:28.090
内部的值

27:28.090 --> 27:30.090
默认为1

27:30.090 --> 27:31.090
或者默认为NOW

27:31.090 --> 27:32.090
indefine都行

27:32.090 --> 27:33.090
indefine

27:33.090 --> 27:34.090
那么这边我们返回

27:34.090 --> 27:35.090
intel

27:35.090 --> 27:36.090
set的时候

27:36.090 --> 27:38.090
把它设置为化

27:38.090 --> 27:40.090
那之后现在就可以了

27:40.090 --> 27:41.090
你看吧

27:41.090 --> 27:43.090
我运行set100传进去

27:43.090 --> 27:45.090
这句话相当于是运行set100

27:45.090 --> 27:46.090
它进去

27:46.090 --> 27:48.090
它就把100复制给它

27:48.090 --> 27:49.090
保存到一个中间变量

27:49.090 --> 27:50.090
intel里边

27:50.090 --> 27:52.090
那么它里边就是什么100

27:52.090 --> 27:53.090
对吧

27:53.090 --> 27:54.090
然后我再去输出

27:54.090 --> 27:55.090
obd.a的时候

27:55.090 --> 27:56.090
返回的是什么

27:56.090 --> 27:57.090
返回的是intel

27:57.090 --> 27:58.090
返回的是多少

27:58.090 --> 27:59.090
100

27:59.090 --> 28:01.090
所以这里可以输出100

28:01.090 --> 28:04.590
得这样子玩

28:04.590 --> 28:05.590
没了意思吧

28:05.590 --> 28:07.590
这是属性描述服

28:07.590 --> 28:09.590
你也不用去想它的

28:09.590 --> 28:10.590
运用场景

28:10.590 --> 28:11.590
你想不到的

28:11.590 --> 28:13.590
将来你们学习的伍诱

28:13.590 --> 28:15.590
讲到原理部分

28:16.590 --> 28:17.590
帮你们回应

28:17.590 --> 28:18.590
好了

28:18.590 --> 28:19.590
这是属性描述服

28:19.590 --> 28:21.590
下一个建值队

28:21.590 --> 28:22.590
这里边是有些API

28:22.590 --> 28:23.590
就是我们其实

28:23.590 --> 28:25.590
我们本质上的一个对象

28:25.590 --> 28:26.590
它里边都是建值队

28:26.590 --> 28:27.590
怎么叫建值队

28:27.590 --> 28:29.590
你之前学习好像学那个

28:29.590 --> 28:30.590
local storage就说过了

28:30.590 --> 28:31.590
对吧

28:31.590 --> 28:32.590
就是一个东西对一个东西

28:32.590 --> 28:33.590
属性名字就是建

28:33.590 --> 28:34.590
唯一的

28:34.590 --> 28:35.590
值呢

28:35.590 --> 28:36.590
就是属性的值

28:36.590 --> 28:37.590
就是建值队

28:38.590 --> 28:39.590
那么其实建值队

28:39.590 --> 28:40.590
可以通过一些

28:40.590 --> 28:42.590
API来进行拆解

28:42.590 --> 28:44.590
比方说通过obd

28:45.590 --> 28:46.590
来看一下

28:46.590 --> 28:49.100
非常简单

28:49.100 --> 28:50.100
有一个对象

28:50.100 --> 28:52.100
然后通过这个objects

28:52.100 --> 28:53.100
key

28:53.100 --> 28:54.100
对象传进去

28:54.100 --> 28:56.100
它会返回一个数组

28:56.100 --> 28:59.100
能拿到它的所有的属性名

28:59.100 --> 29:00.100
对不对

29:00.100 --> 29:02.100
就能拿到它所谓的属性名

29:03.100 --> 29:04.100
然后通过这个object

29:04.100 --> 29:06.100
key values

29:06.100 --> 29:07.100
可以拿到它所谓的属性值

29:07.100 --> 29:09.100
返回一个数组

29:09.100 --> 29:10.100
entress

29:10.100 --> 29:11.100
有点传进去

29:11.100 --> 29:13.100
能够拿到这么一个东西

29:13.100 --> 29:14.100
因为这是拿到所有的属性名

29:14.100 --> 29:15.100
这拿到所有的属性值

29:15.100 --> 29:16.100
这个玩意是拿到

29:16.100 --> 29:19.100
所有的属性名和属性值

29:20.100 --> 29:22.100
那你看这里怎么来的

29:22.100 --> 29:23.100
得到一个数组

29:23.100 --> 29:24.100
这是第一个属性

29:24.100 --> 29:25.100
这是第二个属性

29:25.100 --> 29:27.100
每一个属性又是一个数组

29:27.100 --> 29:29.100
数组的第一项是属性名

29:29.100 --> 29:30.100
第二项是属性值

29:30.100 --> 29:31.100
第一项是属性名

29:31.100 --> 29:32.100
第二项是属性值

29:32.100 --> 29:34.100
是这么一种格式

29:34.100 --> 29:36.100
然后 from interest

29:36.100 --> 29:38.100
就相当于是把这种格式

29:38.100 --> 29:40.100
还原成一个对象

29:40.100 --> 29:42.100
把这个玩意还原成一个对象

29:42.100 --> 29:44.100
就这么回事

29:44.100 --> 29:46.100
就是

29:46.100 --> 29:47.100
那么我们来看

29:47.100 --> 29:48.100
比方说我们现在要辨历

29:48.100 --> 29:50.100
他所有的属性名和属性值

29:50.100 --> 29:52.100
你咋辨历呢

29:53.100 --> 29:56.100
辨历他所谓的属性名和属性值

29:57.100 --> 29:58.100
虽然我要输出

29:58.100 --> 30:00.100
输出这么一个格式

30:01.100 --> 30:03.100
模办制服车吧

30:03.100 --> 30:05.100
name

30:05.100 --> 30:09.110
帽号

30:09.110 --> 30:11.110
name的值

30:11.110 --> 30:13.110
就这里

30:13.110 --> 30:14.110
就这个东西

30:14.110 --> 30:15.110
就这么一种格式

30:15.110 --> 30:16.110
第一个属性的名字

30:16.110 --> 30:17.110
帽号

30:17.110 --> 30:18.110
后边属性的值

30:18.110 --> 30:19.110
我要输出这么一种格式

30:19.110 --> 30:20.110
怎么输出

30:20.110 --> 30:22.110
我是不是可以用 for or 不循环

30:22.110 --> 30:23.110
循环啥

30:23.110 --> 30:24.110
循环

30:24.110 --> 30:26.110
这个 object

30:26.110 --> 30:27.110
interest

30:27.110 --> 30:28.110
由而传进去

30:28.110 --> 30:29.110
这个由而传进去

30:29.110 --> 30:31.110
是不是形成这么一个数组了

30:31.110 --> 30:33.110
数组是不是可以用 for or 不循环

30:33.110 --> 30:34.110
这个表达是

30:34.110 --> 30:36.110
是不是就相当于是

30:36.110 --> 30:37.110
这个数组

30:37.110 --> 30:39.110
这个数组是不是可以用 for or 不循环

30:39.110 --> 30:41.110
那么每一项给他的是啥

30:41.110 --> 30:42.110
每一项

30:42.110 --> 30:44.110
第一项给他的这么一个东西

30:44.110 --> 30:45.110
对吧

30:45.110 --> 30:46.110
那么第二项呢

30:46.110 --> 30:48.110
给他的是这么一个东西

30:48.110 --> 30:49.110
所以是吧

30:49.110 --> 30:50.110
对吧

30:50.110 --> 30:51.110
那么给他的是一个数组

30:51.110 --> 30:53.110
输出了第一项呢

30:53.110 --> 30:56.190
输出

30:56.190 --> 30:57.190
输出了第一项

30:57.190 --> 30:58.190
是不是属性名

30:58.190 --> 31:00.190
第二项是属性值

31:01.190 --> 31:02.190
好厉害

31:02.190 --> 31:03.190
输出了

31:03.190 --> 31:04.190
当然你可以用拼

31:04.190 --> 31:05.190
你可以拼箭一下

31:08.190 --> 31:10.190
item0

31:10.190 --> 31:11.190
帽号

31:11.190 --> 31:15.700
item1

31:16.700 --> 31:18.700
是不是输出这么一种格式

31:18.700 --> 31:21.700
当然你也可以利用我们解构的姿势

31:21.700 --> 31:23.700
数组能不能解构

31:23.700 --> 31:25.700
数组能不能解构在这里

31:25.700 --> 31:26.700
它不会解构

31:26.700 --> 31:27.700
解呗

31:27.700 --> 31:29.700
我第一项t

31:29.700 --> 31:30.700
第二项value

31:30.700 --> 31:31.700
放到边量t

31:31.700 --> 31:32.700
放到边量value 里边

31:32.700 --> 31:35.700
那这里是看上去更加清爽了

31:35.700 --> 31:36.700
tvalue

31:36.700 --> 31:38.700
可以非常方便的去

31:38.700 --> 31:40.700
编辑所有的属性名和属性值

31:40.700 --> 31:42.700
这就是

31:42.700 --> 31:43.700
这几个API

31:43.700 --> 31:44.700
非常简单的API

31:44.700 --> 31:46.700
可以配合一些别的语法来用

31:48.700 --> 31:49.700
冻结看一下就行了

31:49.700 --> 31:50.700
了解就行了

31:50.700 --> 31:51.700
后边的东西

31:51.700 --> 31:52.700
平时都用不上的

31:52.700 --> 31:54.700
了解即可

31:54.700 --> 31:56.700
你不能说完全不知道

31:56.700 --> 31:58.700
freeze

31:58.700 --> 31:59.700
有这么一个方法

31:59.700 --> 32:00.700
它可以冻结一个对象

32:00.700 --> 32:01.700
啥意思

32:01.700 --> 32:03.700
就是对象一旦被冻结之后

32:03.700 --> 32:06.700
它里边的所有属性不能更改

32:06.700 --> 32:07.700
比方说对象

32:07.700 --> 32:08.700
通过freeze

32:08.700 --> 32:09.700
把对象冻结了

32:09.700 --> 32:11.700
你看给a重新复制为2

32:11.700 --> 32:12.700
不好意思

32:12.700 --> 32:13.700
我不抱错

32:13.700 --> 32:14.700
代码无效

32:14.700 --> 32:16.700
给k重新复制为4

32:16.700 --> 32:17.700
增加一个属性

32:17.700 --> 32:18.700
不好意思

32:18.700 --> 32:19.700
无效

32:19.700 --> 32:20.700
不能增加

32:20.700 --> 32:22.700
删除一个属性a

32:22.700 --> 32:23.700
不好意思

32:23.700 --> 32:24.700
无效

32:24.700 --> 32:25.700
它不发删除

32:25.700 --> 32:27.700
然后呢

32:27.700 --> 32:28.700
给b重新复制

32:28.700 --> 32:29.700
不好意思

32:29.700 --> 32:30.700
b也是对象的属性

32:30.700 --> 32:31.700
这个对象被冻结了

32:31.700 --> 32:33.700
所以说不能重新复制

32:33.700 --> 32:35.700
但是如果你给b里边的c复制

32:35.700 --> 32:36.700
是可以的

32:36.700 --> 32:38.700
因为这个对象没冻结

32:38.700 --> 32:40.700
它冻结的是这个对象

32:40.700 --> 32:41.700
这个对象里边的所有属性

32:41.700 --> 32:42.700
能被冻结了

32:42.700 --> 32:44.700
但是这个对象没被冻结

32:44.700 --> 32:45.700
没意思吧

32:45.700 --> 32:47.700
所以你给b复制可以

32:47.700 --> 32:49.700
但是你给b对象里边的东西复制

32:49.700 --> 32:51.700
是ok的

32:51.700 --> 32:52.700
给b复制是不可以的

32:52.700 --> 32:54.700
但是给b对象里边的东西复制

32:54.700 --> 32:55.700
是ok的

32:55.700 --> 32:56.700
了解就行了

32:56.700 --> 32:57.700
这玩意儿

32:57.700 --> 32:59.700
你不能说你完全不知道

32:59.700 --> 33:00.700
那么最后输出OBG

33:00.700 --> 33:01.700
你会发现

33:01.700 --> 33:02.700
所有的属性

33:02.700 --> 33:04.700
缘分不动

33:04.700 --> 33:05.700
但是这个对象里边的东西

33:05.700 --> 33:07.700
是可以变的

33:07.700 --> 33:10.700
这是冻结

33:10.700 --> 33:11.700
有的时候呢

33:11.700 --> 33:12.700
你可以判断一个对象

33:12.700 --> 33:13.700
有没有冻结呢

33:13.700 --> 33:14.700
可以使用Objects

33:14.700 --> 33:15.700
Ease Frozen

33:15.700 --> 33:18.700
来判断它到底有没被冻结过

33:18.700 --> 33:19.700
相同性判断

33:19.700 --> 33:20.700
就是以前

33:20.700 --> 33:21.700
我们判断两个东西

33:21.700 --> 33:22.700
是不是相等

33:22.700 --> 33:23.700
用三个等号

33:23.700 --> 33:24.700
严格等于

33:24.700 --> 33:26.700
或者用两个等号算了吧

33:26.700 --> 33:28.700
以后你们在公司里边

33:28.700 --> 33:29.700
基本上不会使用

33:29.700 --> 33:31.700
两个等号去判断

33:31.700 --> 33:33.700
这是一个开发习惯

33:33.700 --> 33:34.700
而且有些公司

33:34.700 --> 33:35.700
有硬性要求的

33:35.700 --> 33:36.700
它一定要用

33:36.700 --> 33:37.700
使用三个等号去判断

33:37.700 --> 33:39.700
严格相等

33:39.700 --> 33:41.700
其实它是有一些

33:41.700 --> 33:43.700
问题的

33:43.700 --> 33:45.700
什么问题呢

33:47.700 --> 33:52.030
NAN

33:52.030 --> 33:54.030
真是老问题的

33:54.030 --> 33:56.030
not a number

33:56.030 --> 33:58.030
是不是等于 not a number

33:58.030 --> 34:00.030
它为 force

34:00.030 --> 34:01.030
这不很整齐吗

34:01.030 --> 34:02.030
这个问题

34:02.030 --> 34:04.030
这个 bug 是哪来的

34:04.030 --> 34:05.030
这是个 bug

34:05.030 --> 34:06.030
哪来的呢

34:06.030 --> 34:07.030
是NAN

34:07.030 --> 34:09.030
这个数字的存储形式决定了

34:09.030 --> 34:11.030
我不去多说了

34:12.030 --> 34:13.030
这里边一说了

34:13.030 --> 34:14.030
说到二进去

34:14.030 --> 34:15.030
里边去了

34:15.030 --> 34:17.030
反正就是这么一个情况

34:17.030 --> 34:19.030
这是语言设计的缺陷

34:19.030 --> 34:21.030
这不很怪吗

34:21.030 --> 34:24.030
然后它的正灵和负灵

34:24.030 --> 34:25.030
在计算机里边

34:25.030 --> 34:27.030
正灵和负灵是不一样的

34:27.030 --> 34:28.030
零和零可以是

34:28.030 --> 34:29.030
认为是一样的

34:29.030 --> 34:31.030
但是你跟零加了符号

34:31.030 --> 34:33.030
它的数字存储格式

34:33.030 --> 34:35.030
是不一样的

34:35.030 --> 34:36.030
这个

34:36.030 --> 34:37.030
它以前是处

34:37.030 --> 34:39.030
按你说不应该是处

34:39.030 --> 34:40.030
就是你要判断

34:40.030 --> 34:41.030
两个是不是零

34:41.030 --> 34:42.030
相等

34:42.030 --> 34:43.030
那你不应该去写两个符号

34:43.030 --> 34:44.030
对吧

34:44.030 --> 34:45.030
你写了两个符号

34:45.030 --> 34:47.030
说明它就已经有区别了

34:47.030 --> 34:48.030
它为粗

34:48.030 --> 34:49.030
就过去呢

34:49.030 --> 34:50.030
就有这么两个问题

34:50.030 --> 34:52.030
那么于是呢

34:52.030 --> 34:54.030
ES6出来之后

34:54.030 --> 34:55.030
它觉得吧

34:55.030 --> 34:56.030
这两个问题呢

34:56.030 --> 34:58.030
我要去改这个

34:58.030 --> 35:00.030
严格相等

35:00.030 --> 35:01.030
不合适

35:01.030 --> 35:02.030
因为我一改了

35:02.030 --> 35:03.030
过后呢

35:03.030 --> 35:04.030
你说我把这个

35:04.030 --> 35:06.030
我修正之前的错误

35:06.030 --> 35:08.030
之前这个玩意不是为

35:08.030 --> 35:09.030
不是为啥

35:09.030 --> 35:11.030
不是为Force吗

35:11.030 --> 35:12.030
我把它修正为处

35:12.030 --> 35:13.030
可不可以啊

35:13.030 --> 35:14.030
可以

35:14.030 --> 35:15.030
它不敢

35:15.030 --> 35:16.030
为什么不敢呢

35:16.030 --> 35:18.030
就会造成兼容性问题

35:18.030 --> 35:19.030
因为以前

35:19.030 --> 35:20.030
我们都是默认

35:20.030 --> 35:22.030
这两个是不相等的

35:22.030 --> 35:24.030
结果你现在把它变成相等的

35:24.030 --> 35:25.030
以前有些办法

35:25.030 --> 35:26.030
可能就不能用了

35:26.030 --> 35:28.030
导致兼容性问题

35:28.030 --> 35:29.030
所以说不敢干

35:29.030 --> 35:31.030
于是它给你新增了一个

35:31.030 --> 35:32.030
API叫OBGX

35:32.030 --> 35:33.030
来判断

35:33.030 --> 35:35.030
两个东西是不是不相等

35:35.030 --> 35:36.030
跟三个等号

35:36.030 --> 35:37.030
完全一样

35:37.030 --> 35:39.030
就是两个区别

35:39.030 --> 35:41.030
一个是NIN

35:41.030 --> 35:43.030
它们返回去

35:43.030 --> 35:46.620
了解就行了

35:46.620 --> 35:47.620
你们平时写代码

35:47.620 --> 35:49.620
不会用到这些东西的

35:50.620 --> 35:52.620
了解即可

35:52.620 --> 35:53.620
为处

35:53.620 --> 35:54.620
好

35:54.620 --> 35:56.620
然后是一个争灵和负灵

35:56.620 --> 35:57.620
它为Force

35:57.620 --> 35:59.620
就这两个地方有区别

35:59.620 --> 36:00.620
其他没区别

36:00.620 --> 36:05.090
为Force

36:05.090 --> 36:07.090
所以说在ES6之后

36:07.090 --> 36:10.090
它在内部做一些实现的时候

36:10.090 --> 36:11.090
凡事要遇到

36:11.090 --> 36:13.090
判断两个东西是不是相等

36:13.090 --> 36:16.090
它就都用的是OBGX

36:16.090 --> 36:17.090
知道了

36:18.090 --> 36:19.090
我记得之前

36:19.090 --> 36:22.090
我在讲一个什么玩意的时候

36:22.090 --> 36:23.090
之前我在讲那个

36:23.090 --> 36:25.090
输主API Inclusive的时候

36:25.090 --> 36:26.090
判断一个输主里边

36:26.090 --> 36:27.090
是不是包含这一项

36:27.090 --> 36:28.090
它怎么判断的

36:28.090 --> 36:29.090
内部

36:29.090 --> 36:30.090
就是通过OBGX

36:30.090 --> 36:31.090
一直在判断的

36:31.090 --> 36:33.090
它把输主的第一项拿出来

36:33.090 --> 36:34.090
看一下这个第一项

36:34.090 --> 36:35.090
OBGX的意思

36:35.090 --> 36:37.090
第一项传进去

36:37.090 --> 36:38.090
把这个item传进去

36:38.090 --> 36:39.090
相不相等

36:39.090 --> 36:40.090
那整个含书判断出

36:40.090 --> 36:41.090
而不相等

36:41.090 --> 36:42.090
看第二项

36:42.090 --> 36:43.090
第二项拿出来

36:43.090 --> 36:44.090
然后

36:45.090 --> 36:46.090
把这两个进行比较

36:46.090 --> 36:47.090
用OBGX的意思比较

36:47.090 --> 36:48.090
是不是一样的

36:48.090 --> 36:49.090
一样的

36:49.090 --> 36:50.090
那就判断出

36:50.090 --> 36:52.090
它就用这种方式来进行判断

36:53.090 --> 36:54.090
这相同性判定

36:54.090 --> 36:56.090
之后凡事新增的一些API

36:56.090 --> 36:58.090
反而是要判断相等的地方

36:59.090 --> 37:00.090
ES6

37:00.090 --> 37:02.090
我们的官方都是使用

37:02.090 --> 37:03.090
OBGX的意思来判断的

37:03.090 --> 37:05.090
它不会再使用严格相等

37:05.090 --> 37:08.530
当然你平时写代码的时候

37:08.530 --> 37:09.530
看你自己

37:10.530 --> 37:12.530
当然你也可以使用

37:12.530 --> 37:13.530
OBGX的意思来判断

37:13.530 --> 37:15.530
也可以使用三个等号

37:15.530 --> 37:16.530
只要你的

37:17.530 --> 37:18.530
这两个东西你不care

37:18.530 --> 37:19.530
那就无所谓

37:19.530 --> 37:20.530
其他都一样的

37:23.970 --> 37:24.970
就是我们这里讲

37:24.970 --> 37:25.970
对象的新增的一东西

37:27.970 --> 37:28.970
除了前三个

37:29.970 --> 37:31.970
跟我们开发是有密切关系的

37:31.970 --> 37:32.970
后边我们都是了解

37:32.970 --> 37:33.970
都属于了解

37:34.970 --> 37:35.970
set a map

37:35.970 --> 37:36.970
你们平时根本用不到

37:36.970 --> 37:38.970
那么我们这里也要了解

37:38.970 --> 37:39.970
不能完全不知道

37:39.970 --> 37:40.970
这个不合适

37:41.970 --> 37:42.970
set这里有MDN文档

37:43.970 --> 37:44.970
它是一个数据集合

37:45.970 --> 37:47.970
用于保存一系列唯一的值

37:48.970 --> 37:49.970
啥意思

37:49.970 --> 37:50.970
它不像数组

37:50.970 --> 37:51.970
数组里边可以出现重复的

37:51.970 --> 37:52.970
对吧

37:52.970 --> 37:53.970
它里边是不可能重复的

37:54.970 --> 37:55.970
那么它怎么来用呢

37:55.970 --> 37:56.970
你看MDN官方文档

37:57.970 --> 37:58.970
我们这里来吧

38:02.370 --> 38:04.370
set我们来看一下怎么来用

38:05.370 --> 38:07.370
它让你通过构造函数

38:07.370 --> 38:08.370
来创建一个set

38:08.370 --> 38:09.370
那就创建一个set

38:09.370 --> 38:11.370
这就是一个集合

38:11.370 --> 38:12.370
集合一开始

38:13.370 --> 38:14.370
啥都没有

38:15.370 --> 38:16.370
然后可以往里边

38:16.370 --> 38:17.370
添东西

38:17.370 --> 38:18.370
比方说add

38:20.370 --> 38:21.370
sadd

38:21.370 --> 38:22.370
加一个1

38:22.370 --> 38:23.370
我们再看一下集合

38:23.370 --> 38:24.370
里边说一个1

38:24.370 --> 38:25.370
再加一个

38:26.370 --> 38:27.370
2

38:28.370 --> 38:29.370
再加一个

38:29.370 --> 38:30.370
3

38:30.370 --> 38:31.370
再加一个

38:31.370 --> 38:32.370
5

38:32.370 --> 38:33.370
你看集合里边

38:33.370 --> 38:34.370
是不是就有了

38:34.370 --> 38:35.370
1235

38:36.370 --> 38:37.370
对不对

38:37.370 --> 38:39.370
就看add加一个

38:39.370 --> 38:40.370
对吧

38:40.370 --> 38:41.370
就可以看到集合里边

38:41.370 --> 38:42.370
有很多的方法

38:42.370 --> 38:43.370
属性

38:43.370 --> 38:44.370
你看通过set

38:44.370 --> 38:45.370
可以看到集合里边

38:45.370 --> 38:46.370
有多少东西

38:46.370 --> 38:47.370
对吧

38:47.370 --> 38:48.370
有四个东西

38:49.370 --> 38:50.370
它有什么特点呢

38:50.370 --> 38:52.370
这个集合是不能加重复的

38:52.370 --> 38:53.370
比方说你再加个3

38:53.370 --> 38:54.370
你会发现无效

38:54.370 --> 38:55.370
它加不进去

38:55.370 --> 38:57.370
因为它之前已经有个3了

38:57.370 --> 38:58.370
它就是起这么一个作用

38:58.370 --> 38:59.370
它是唯一纸

38:59.370 --> 39:00.370
它里边东西全是唯一的

39:00.370 --> 39:01.370
不管你纸存的是对象

39:01.370 --> 39:02.370
数字还是不算

39:02.370 --> 39:03.370
反正是唯一

39:03.370 --> 39:04.370
它怎么来判断

39:04.370 --> 39:05.370
有没有重复的

39:05.370 --> 39:06.370
通过R不几个车

39:06.370 --> 39:07.370
意思

39:08.370 --> 39:09.370
你看你这里可以删除

39:09.370 --> 39:10.370
删除某一个纸

39:11.370 --> 39:12.370
它没有下标

39:12.370 --> 39:13.370
你不要去找它的下标

39:13.370 --> 39:14.370
它没有下标

39:14.370 --> 39:16.370
你不能说我要通过0去取

39:16.370 --> 39:17.370
这是啥玩意

39:17.370 --> 39:19.370
你不能用这样子的玩意

39:19.370 --> 39:20.370
它没有下标的

39:20.370 --> 39:22.370
它都是dnit

39:22.370 --> 39:23.370
可以通过这种方式

39:23.370 --> 39:24.370
来删除一个纸

39:24.370 --> 39:25.370
比方说删除一个3

39:26.370 --> 39:27.370
那么s

39:27.370 --> 39:28.370
它就把3删除了

39:29.370 --> 39:30.370
对吧

39:30.370 --> 39:31.370
就这么一回事

39:31.370 --> 39:32.370
那么我们可以通过

39:32.370 --> 39:33.370
这个manus

39:33.370 --> 39:35.370
来得到它所有的纸的数组

39:35.370 --> 39:39.130
它其实还不是数组

39:39.130 --> 39:40.130
得到的是个迭代器

39:40.130 --> 39:41.130
你现在不用去管迭代器

39:41.130 --> 39:43.130
这是进阶部分的知识

39:43.130 --> 39:45.130
总之你可以把类似为数组

39:45.130 --> 39:46.130
类似为数组

39:48.130 --> 39:50.130
这就是set

39:50.130 --> 39:51.130
那么这里面

39:51.130 --> 39:52.130
就会遇到一个经典的问题

39:52.130 --> 39:54.130
我们看一下练习题

39:54.130 --> 39:55.130
数组去从

39:58.080 --> 39:59.080
这是个面试题

39:59.080 --> 40:00.080
它问你有个数组

40:00.080 --> 40:01.080
这个数组里面

40:01.080 --> 40:03.080
有可能有一些重复的东西

40:04.080 --> 40:05.080
那么我如何把这些

40:05.080 --> 40:06.080
重复的东西去掉

40:06.080 --> 40:08.080
只保留不重复的东西呢

40:09.080 --> 40:10.080
那么这里

40:10.080 --> 40:11.080
你可以使用set

40:11.080 --> 40:12.080
利用这个set

40:13.080 --> 40:14.080
具体咋写呢

40:14.080 --> 40:15.080
你看着

40:15.080 --> 40:16.080
我们可以这样

40:16.080 --> 40:19.780
溜一个set

40:19.780 --> 40:20.780
然后在溜set的时候

40:20.780 --> 40:21.780
它可以进行初始化

40:21.780 --> 40:22.780
就这里边

40:22.780 --> 40:23.780
可以传一个数组

40:23.780 --> 40:24.780
不要让你传一个123

40:25.780 --> 40:26.780
那么就相当于是

40:26.780 --> 40:27.780
创家的一个set

40:28.780 --> 40:29.780
这个set里边

40:29.780 --> 40:30.780
有个数据

40:30.780 --> 40:31.780
就直接是123

40:31.780 --> 40:32.780
然后可以初始化的

40:33.780 --> 40:34.780
哪里直接把这个数

40:34.780 --> 40:35.780
数组扔进去

40:37.780 --> 40:38.780
是不是

40:38.780 --> 40:39.780
自动去从了

40:39.780 --> 40:40.780
自动就把a重复直去掉了

40:40.780 --> 40:41.780
因为set里边是

40:41.780 --> 40:42.780
可能有重复的

40:43.780 --> 40:44.780
然后你看很多语言

40:44.780 --> 40:45.780
它都有set

40:45.780 --> 40:46.780
比方说像那个

40:46.780 --> 40:47.780
java语言也好

40:48.780 --> 40:49.780
cjava语言

40:49.780 --> 40:50.780
都有这个set这个结构

40:50.780 --> 40:51.780
以前届是没有

40:51.780 --> 40:52.780
现在再补上了

40:53.780 --> 40:54.780
没有重复

40:54.780 --> 40:55.780
那么但是呢

40:55.780 --> 40:56.780
这个题的要求是什么

40:56.780 --> 40:57.780
要求是你

40:58.780 --> 41:01.780
返回一个新的数组

41:03.780 --> 41:04.780
返回要的不是

41:04.780 --> 41:05.780
这个set对象

41:05.780 --> 41:06.780
我要的是数组

41:06.780 --> 41:07.780
所以说你这里

41:07.780 --> 41:08.780
还要把这个set

41:08.780 --> 41:09.780
转换成数组

41:10.780 --> 41:11.780
那咋转换呢

41:12.780 --> 41:13.780
你找一找看一下

41:13.780 --> 41:15.780
这里边有没有什么

41:15.780 --> 41:16.780
API

41:16.780 --> 41:17.780
好像是没有

41:17.780 --> 41:19.780
没有它转换成数组的API

41:20.780 --> 41:21.780
好那怎么转呢

41:21.780 --> 41:22.780
我们就可以利用

41:22.780 --> 41:24.780
es6的展开运算幅

41:25.780 --> 41:26.780
set仍然是可以展开的

41:27.780 --> 41:28.780
比方说我这里

41:28.780 --> 41:29.780
就这样写

41:31.780 --> 41:32.780
neuARR

41:32.780 --> 41:33.780
等于什么呢

41:33.780 --> 41:34.780
一个新的数组

41:34.780 --> 41:35.780
数组里边有啥呢

41:35.780 --> 41:37.780
把这个set展开

41:38.780 --> 41:39.780
就写完了

41:40.780 --> 41:41.780
就是之前还要

41:41.780 --> 41:42.780
去写什么循环

41:42.780 --> 41:43.780
对吧

41:43.780 --> 41:44.780
不用了

41:45.780 --> 41:46.780
都到新的数组了

41:47.780 --> 41:48.780
那么这句话还可以

41:48.780 --> 41:49.780
一句话写完

41:49.780 --> 41:50.780
新的东西等于什么

41:50.780 --> 41:51.780
展开s

41:51.780 --> 41:53.780
展开s不就是展开它吗

41:53.780 --> 41:54.780
那么你只把它

41:54.780 --> 41:55.780
放过来

41:56.780 --> 41:57.780
对吧

41:57.780 --> 42:00.340
是用完事了

42:00.340 --> 42:01.340
一样

42:01.340 --> 42:02.340
这就是数据循

42:02.340 --> 42:03.340
有这么一条面子

42:03.340 --> 42:04.340
不能把这个

42:04.340 --> 42:06.340
不能把面子提这样子

42:07.340 --> 42:08.340
面具提的

42:08.340 --> 42:09.340
参考

42:09.340 --> 42:12.490
不能改这个

42:12.490 --> 42:15.380
好

42:15.380 --> 42:16.380
这是set

42:17.380 --> 42:18.380
平时开发用不到了

42:18.380 --> 42:19.380
然后如果说

42:19.380 --> 42:20.380
你特别需要去

42:20.380 --> 42:21.380
同的时候

42:21.380 --> 42:22.380
就可以用这种方式

42:22.380 --> 42:23.380
mab

42:23.380 --> 42:24.380
mab就是一个

42:24.380 --> 42:26.380
纯粹的时候建置队了

42:27.380 --> 42:28.380
它是一种数据集合

42:28.380 --> 42:30.380
用于保存一系列的建置队

42:30.380 --> 42:31.380
它跟对象差不多

42:31.380 --> 42:32.380
对象不也是建置队吗

42:33.380 --> 42:34.380
它跟对象的

42:34.380 --> 42:36.380
最大区别在什么呢

42:36.380 --> 42:38.380
在于对象的键

42:38.380 --> 42:40.380
它必定是

42:41.380 --> 42:42.380
制服串

42:42.380 --> 42:43.380
对大家知道吧

42:44.380 --> 42:45.380
我觉得有些可能

42:45.380 --> 42:46.380
也可能还不知道

42:47.380 --> 42:48.380
对象里面的

42:48.380 --> 42:50.380
所有的属性名

42:50.380 --> 42:52.380
它只能是制服串

42:53.380 --> 42:54.380
你见过是

42:54.380 --> 42:55.380
还有别的内容吗

42:56.380 --> 42:57.380
它只能是制服串

42:59.380 --> 43:00.380
对象里面的

43:00.380 --> 43:01.380
所有的属性名

43:01.380 --> 43:02.380
只能是制服串

43:02.380 --> 43:03.380
它原来说不对啊

43:04.380 --> 43:05.380
那输主不也是对象吗

43:06.380 --> 43:07.380
输主的属性

43:08.380 --> 43:09.380
它不是数字吗

43:11.380 --> 43:12.380
你确定输主的属性

43:12.380 --> 43:13.380
真的是数字吗

43:14.380 --> 43:18.930
随便写写

43:19.930 --> 43:21.930
我要便利对象的

43:21.930 --> 43:22.930
所有属性

43:22.930 --> 43:23.930
用什么便利

43:23.930 --> 43:24.930
是不是用FORING便利

43:27.370 --> 43:28.370
便利对象的所有属性

43:29.370 --> 43:30.370
按理说

43:30.370 --> 43:31.370
对象的

43:31.370 --> 43:32.370
第一个属性名是0

43:32.370 --> 43:34.370
属性值是54

43:34.370 --> 43:36.370
第二个属性名是1

43:36.370 --> 43:38.370
属性值是23

43:38.370 --> 43:39.370
对吧

43:39.370 --> 43:40.370
大概应该是这个样子

43:41.370 --> 43:42.370
0

43:42.370 --> 43:43.370
对应什么

43:43.370 --> 43:44.370
54

43:44.370 --> 43:45.370
第一个属性名

43:45.370 --> 43:46.370
建置对吗

43:46.370 --> 43:47.370
1对应23

43:48.370 --> 43:49.370
2对应这个

43:49.370 --> 43:50.370
忘记发达到ASDF

43:52.740 --> 43:53.740
那我这里循环

43:53.740 --> 43:54.740
它的所有的属性名

43:54.740 --> 43:55.740
不应该是

43:55.740 --> 43:56.740
每一个属性名

43:56.740 --> 43:57.740
都应该是数字吗

43:57.740 --> 43:58.740
那我们输出一下T

43:58.740 --> 44:04.060
和它的Type

44:04.060 --> 44:05.060
是啥

44:06.060 --> 44:07.060
是制服串

44:08.060 --> 44:09.060
那就要开

44:09.060 --> 44:10.060
颠覆三关了

44:10.060 --> 44:11.060
那我们平时写的

44:11.060 --> 44:12.060
这个东西

44:12.060 --> 44:14.060
它写的不是数字吗

44:15.060 --> 44:16.060
它会自动转

44:17.060 --> 44:18.060
它会把你这个玩意儿

44:18.060 --> 44:20.060
给你转换成制服串

44:21.060 --> 44:22.060
所以说你这样子写

44:23.060 --> 44:24.060
是一样的

44:30.340 --> 44:31.340
是一样的

44:31.340 --> 44:32.340
知道吧

44:32.340 --> 44:34.340
属性名只能是制服串

44:34.340 --> 44:36.340
不可能是别的玩意儿

44:37.340 --> 44:38.340
ES6呢

44:38.340 --> 44:39.340
它给你出了一个新的

44:39.340 --> 44:40.340
格式叫做symbol

44:40.340 --> 44:41.340
叫符号

44:41.340 --> 44:42.340
我们不学

44:42.340 --> 44:44.340
在基础切断不学

44:44.340 --> 44:45.340
进阶部份

44:45.340 --> 44:46.340
它去看吧

44:46.340 --> 44:47.340
你说那个玩意儿

44:47.340 --> 44:48.340
你们确实八杆子

44:48.340 --> 44:49.340
打不着

44:49.340 --> 44:50.340
跟你们没关系

44:50.340 --> 44:51.340
除此之外

44:51.340 --> 44:52.340
只能是制服串

44:53.340 --> 44:54.340
这就是

44:54.340 --> 44:56.340
它跟map的最大区别

44:56.340 --> 44:58.340
对象里面的key

44:58.340 --> 44:59.340
键就是属性名

44:59.340 --> 45:00.340
它只能是制服串

45:00.340 --> 45:01.340
属性值都无所谓

45:01.340 --> 45:03.340
但是map里面的key

45:03.340 --> 45:05.340
它可以是任何类型

45:05.340 --> 45:07.340
你可以把一个对象当中key

45:07.340 --> 45:08.340
都有解释清楚了

45:08.340 --> 45:09.340
为什么有了对象之后

45:09.340 --> 45:11.340
还需要map这个结构呢

45:12.340 --> 45:13.340
它的key

45:13.340 --> 45:14.340
key当然是唯一的

45:14.340 --> 45:15.340
key一定是唯一的

45:15.340 --> 45:16.340
无论什么键声归

45:16.340 --> 45:17.340
它key一定唯一

45:17.340 --> 45:19.340
只后无所谓

45:19.340 --> 45:20.340
key已经唯一

45:20.340 --> 45:22.340
但是key可以是任何类型

45:22.340 --> 45:23.340
那我们来玩一玩吧

45:23.340 --> 45:24.340
这个平时跟你们开发

45:24.340 --> 45:25.340
也没什么关系

45:25.340 --> 45:27.340
只是你必须得了解

45:29.340 --> 45:30.340
map这个结构

45:30.340 --> 45:34.420
很多东西

45:34.420 --> 45:36.420
你不去开发框架

45:36.420 --> 45:39.420
你不去写一些公共的库

45:39.420 --> 45:41.420
跟你确实没什么关系

45:41.420 --> 45:43.420
平时就写一些小功能

45:43.420 --> 45:44.420
跟你们真没关系

45:44.420 --> 45:45.420
但是你要了解

45:46.420 --> 45:47.420
后来你们

45:47.420 --> 45:49.420
不能永远就是开发业务功能

45:49.420 --> 45:51.420
你得去写一些框架

45:51.420 --> 45:52.420
写一些库

45:52.420 --> 45:53.420
那么那个时候就复杂了

45:53.420 --> 45:55.420
就可能需要各种各样的东西了

45:56.420 --> 45:58.420
不是说这些东西没用

45:58.420 --> 46:00.420
它只是线接段对你们来说

46:00.420 --> 46:01.420
意义不大

46:01.420 --> 46:02.420
它以后是有用的

46:06.780 --> 46:10.670
咱们来看一下

46:10.670 --> 46:11.670
怎么来用

46:11.670 --> 46:15.430
创建一个map

46:16.430 --> 46:17.430
创立一个map

46:20.380 --> 46:21.380
这里还可以

46:21.380 --> 46:23.380
比较了一下arbitra的map

46:23.380 --> 46:24.380
自己去看

46:25.380 --> 46:26.380
这里说key的类型

46:26.380 --> 46:27.380
map的key

46:28.380 --> 46:30.380
那么它怎么来用呢

46:30.380 --> 46:32.380
它可以通过lens来得到

46:32.380 --> 46:34.380
它目前有几个键子队

46:37.380 --> 46:38.380
应该是size

46:39.380 --> 46:40.380
size

46:40.380 --> 46:41.380
里面有几个键子队

46:41.380 --> 46:42.380
0个

46:42.380 --> 46:43.380
一个都没用

46:43.380 --> 46:45.380
那么怎么来加呢

46:45.380 --> 46:49.380
可以通过m.set

46:49.380 --> 46:51.380
设置一个键子队

46:51.380 --> 46:52.380
设置set

46:52.380 --> 46:54.380
那么建了比方说给它一个数字

46:54.380 --> 46:55.380
12

46:55.380 --> 46:56.380
值呢

46:56.380 --> 46:58.380
给它一个hello

46:59.380 --> 47:00.380
于是呢

47:00.380 --> 47:01.380
这里就出现了一个键子队

47:01.380 --> 47:02.380
你看

47:02.380 --> 47:03.380
12是键

47:03.380 --> 47:04.380
值呢

47:04.380 --> 47:05.380
是hello

47:05.380 --> 47:07.380
那你说要修改怎么办呢

47:07.380 --> 47:08.380
你修改就修改呗

47:08.380 --> 47:10.380
只要键一相同

47:10.380 --> 47:11.380
它就可以修改

47:11.380 --> 47:12.380
值呢

47:12.380 --> 47:13.380
可以修改

47:13.380 --> 47:14.380
东西

47:14.380 --> 47:15.380
你看是不是修改了

47:16.380 --> 47:17.380
对吧

47:17.380 --> 47:18.380
键是唯一的

47:18.380 --> 47:20.380
然后如果说你要加呢

47:20.380 --> 47:21.380
你又来来

47:21.380 --> 47:22.380
设置一个不同的键

47:22.380 --> 47:23.380
就完事了

47:24.380 --> 47:26.380
请问大家

47:26.380 --> 47:29.380
我这样子能够加一个键子队吗

47:29.380 --> 47:31.380
是加还是修改

47:31.380 --> 47:35.660
是加

47:35.660 --> 47:36.660
为什么呢

47:36.660 --> 47:38.660
这个玩意儿跟这个玩意儿一样吗

47:38.660 --> 47:40.660
这东西说要自动转换

47:40.660 --> 47:41.660
你别学晕了

47:41.660 --> 47:43.660
那是对相里边

47:43.660 --> 47:44.660
对相里边

47:44.660 --> 47:45.660
因为它只能是

47:45.660 --> 47:46.660
字无错作为属性

47:46.660 --> 47:47.660
它才自动转换

47:47.660 --> 47:48.660
这里是map

47:48.660 --> 47:50.660
map是映射

47:50.660 --> 47:52.660
它没有自动转换的

47:52.660 --> 47:53.660
任何东西都可以作为键

47:53.660 --> 47:55.660
数字可以作为键

47:57.660 --> 47:58.660
数字可以作为键

47:58.660 --> 47:59.660
字无错也可以作为键

47:59.660 --> 48:00.660
对相都可以作为键

48:00.660 --> 48:01.660
韩数可以作为键

48:01.660 --> 48:02.660
任何东西都可以作为键

48:03.660 --> 48:04.660
这两个键

48:05.660 --> 48:06.660
就这么一个东西

48:06.660 --> 48:08.660
然后呢可以

48:08.660 --> 48:09.660
你要删除的话

48:09.660 --> 48:10.660
可以用地内子

48:10.660 --> 48:11.660
传入一个key

48:11.660 --> 48:13.660
根据键去删除

48:13.660 --> 48:14.660
接着呢

48:14.660 --> 48:15.660
根据键去得到时

48:15.660 --> 48:16.660
还是呢

48:16.660 --> 48:17.660
有没有这样的key

48:18.660 --> 48:19.660
就是这些东西

48:20.660 --> 48:21.660
了解就行了

48:21.660 --> 48:22.660
这是map

48:22.660 --> 48:23.660
好了

48:23.660 --> 48:24.660
我们就快速的过完了

48:24.660 --> 48:25.660
这个对象

48:25.660 --> 48:27.660
跟我们平时开发有关系的

48:27.660 --> 48:28.660
线阶段

48:28.660 --> 48:29.660
说得严谨一点

48:29.660 --> 48:30.660
线阶段

48:30.660 --> 48:32.660
跟我们开发有关系的

48:33.660 --> 48:34.660
前三个

48:35.660 --> 48:36.660
其他的

48:36.660 --> 48:37.660
没有什么关系

48:38.660 --> 48:39.660
然后

48:39.660 --> 48:40.660
后边的东西了解就行了

48:41.660 --> 48:42.660
接下来我们来做练习

48:42.660 --> 48:43.660
第一道题

48:43.660 --> 48:47.930
你们先做

48:47.930 --> 48:48.930
因为这些体呢

48:49.930 --> 48:51.930
哪怕你没有学过es6

48:51.930 --> 48:52.930
没有学过这些课

48:52.930 --> 48:53.930
你也能完成

48:54.930 --> 48:56.930
那么你们尝试了做

48:56.930 --> 48:58.930
你可以用以前的

48:58.930 --> 48:59.930
一点问题都没有

48:59.930 --> 49:00.930
然后呢

49:00.930 --> 49:01.930
也可以用

49:01.930 --> 49:02.930
如果说你想到了

49:02.930 --> 49:03.930
就可以用

49:03.930 --> 49:04.930
我们本节课学过的

49:04.930 --> 49:06.930
想不到就用以前的

49:06.930 --> 49:07.930
但是你

49:07.930 --> 49:08.930
自己做完了过后

49:08.930 --> 49:09.930
要听我讲一讲

49:09.930 --> 49:10.930
好没

49:10.930 --> 49:11.930
做完了没

49:11.930 --> 49:12.930
好那我来说一下

49:12.930 --> 49:13.930
他让你创建一个

49:13.930 --> 49:14.930
用户对象

49:14.930 --> 49:15.930
你说这个函说

49:15.930 --> 49:16.930
他要返回一个用户对象

49:17.930 --> 49:18.930
返回一个用户对象

49:18.930 --> 49:19.930
对象里面有哪些属性呢

49:19.930 --> 49:20.930
有first name

49:20.930 --> 49:21.930
他的职呢

49:21.930 --> 49:22.930
就来自于参数

49:22.930 --> 49:23.930
first name

49:24.930 --> 49:26.930
那你这里是不是可以

49:26.930 --> 49:27.930
可以利用数学属性

49:27.930 --> 49:28.930
直接就写了

49:28.930 --> 49:29.930
对吧

49:29.930 --> 49:30.930
last name

49:30.930 --> 49:31.930
好还有一个富二名

49:31.930 --> 49:32.930
那么富二名呢

49:32.930 --> 49:34.930
哪里的老老实实写了

49:34.930 --> 49:35.930
富二名呢

49:35.930 --> 49:36.930
一般就是

49:36.930 --> 49:37.930
我用模板做个算吧

49:37.930 --> 49:39.930
拼接first name

49:39.930 --> 49:40.930
last name

49:40.930 --> 49:41.930
中间加个空格

49:41.930 --> 49:42.930
对吧拼接一下

49:43.930 --> 49:45.930
好然后还有一个say hello

49:45.930 --> 49:47.930
say hello是一个函数

49:47.930 --> 49:49.930
那么我们就用函数的数形

49:49.930 --> 49:50.930
就输出一个

49:50.930 --> 49:51.930
哈喽

49:51.930 --> 49:53.930
哈喽啥啥

49:54.930 --> 49:55.930
就随便写吧

49:55.930 --> 49:56.930
这个东西

49:56.930 --> 49:57.930
hello

49:57.930 --> 50:00.930
my name is

50:01.930 --> 50:02.930
first name

50:03.930 --> 50:04.930
行了就这样

50:04.930 --> 50:05.930
随便写一写

50:05.930 --> 50:06.930
就练习一下

50:06.930 --> 50:10.930
那个数学属性和数学方法

50:10.930 --> 50:11.930
好下边

50:11.930 --> 50:12.930
雕用这个函数

50:12.930 --> 50:15.930
使用解构得到富二名

50:15.930 --> 50:16.930
那雕用这个函数

50:16.930 --> 50:18.930
传入一个

50:21.930 --> 50:22.930
last name

50:22.930 --> 50:23.930
go

50:23.930 --> 50:24.930
反复的是什么

50:24.930 --> 50:25.930
反复的是一个对象

50:25.930 --> 50:32.210
对吧

50:32.210 --> 50:33.210
我们来看一下

50:33.210 --> 50:35.210
反复的是不是一个对象

50:35.210 --> 50:36.210
然后呢

50:36.210 --> 50:38.210
让你得到一个对象的富二名数形

50:38.210 --> 50:39.210
那你如果说不用

50:39.210 --> 50:40.210
不用我们新知识的话

50:40.210 --> 50:41.210
这个样子

50:41.210 --> 50:42.210
可不可以

50:42.210 --> 50:43.210
当然可以啊

50:43.210 --> 50:44.210
没有任何问题的

50:44.210 --> 50:46.210
但是我们也可以利用解构

50:46.210 --> 50:47.210
怎么解构呢

50:47.210 --> 50:49.210
这个玩意反复的是不是对象

50:49.210 --> 50:51.210
就在U里边

50:51.210 --> 50:53.210
那我们是不是可以利用一个富二名

50:53.210 --> 50:55.210
等于什么

50:55.210 --> 50:56.210
等于

50:56.210 --> 50:57.210
对

50:58.210 --> 50:59.210
U

51:00.210 --> 51:02.840
富二名

51:02.840 --> 51:03.840
说可以这样子写

51:03.840 --> 51:04.840
那么在后边

51:04.840 --> 51:06.840
是不是可以直接使用富二名

51:06.840 --> 51:07.840
解构

51:07.840 --> 51:08.840
对吧

51:08.840 --> 51:09.840
那我解构

51:09.840 --> 51:10.840
这个U跟解构

51:10.840 --> 51:11.840
函数的反复结构

51:11.840 --> 51:12.840
不一样吧

51:12.840 --> 51:13.840
有啥区别呢

51:13.840 --> 51:15.840
所以说我可以这样子写

51:15.840 --> 51:16.840
说不可以

51:16.840 --> 51:18.840
这里反复一个用户对象

51:18.840 --> 51:19.840
对象里面有个属性叫富二名

51:19.840 --> 51:21.840
我直接在这里解构不完

51:21.840 --> 51:22.840
反而是发生数据

51:22.840 --> 51:24.840
传递的位置都可以解构

51:24.840 --> 51:26.840
这个地方传递个数据过来了

51:26.840 --> 51:28.840
我在这里可以解构

51:28.840 --> 51:30.840
是一样的

51:30.840 --> 51:32.840
我怎么U在这里写

51:32.840 --> 51:33.840
不好意思

51:33.840 --> 51:35.840
我怎么U在这里写

51:35.840 --> 51:46.830
第二题

51:46.830 --> 51:50.170
基本练习

51:50.170 --> 51:52.170
基本操作全是机操

51:52.170 --> 51:54.170
这里边有个对象

51:54.170 --> 51:57.170
然后让你便利对象的所有的属性名字

51:57.170 --> 51:58.170
我只要名字

51:58.170 --> 51:59.170
你不要给我指

51:59.170 --> 52:00.170
我只要名字

52:00.170 --> 52:02.170
我要输出ABC

52:02.170 --> 52:03.170
那怎么输出呢

52:03.170 --> 52:04.170
这里的写法真的是

52:04.170 --> 52:06.170
我都不知道有多少东西写法了

52:06.170 --> 52:08.170
你们自己写一写

52:08.170 --> 52:10.170
试一试

52:10.170 --> 52:13.670
看能写出几种写法

52:13.670 --> 52:15.670
佛印循环试一种

52:15.670 --> 52:17.670
你们这些题都做一做

52:17.670 --> 52:18.670
这些东西都做一做

52:18.670 --> 52:19.670
你们自己做一做

52:19.670 --> 52:22.670
看一下你们能写出来多少东西

52:22.670 --> 52:23.670
好嘞

52:23.670 --> 52:24.670
然后听一听我来讲

52:24.670 --> 52:27.670
什么便利对象的所有的属性名

52:27.670 --> 52:29.670
我可以用什么呢

52:29.670 --> 52:30.670
佛印循环

52:30.670 --> 52:31.670
我就不讲了

52:31.670 --> 52:33.670
那我还可以用什么呢

52:33.670 --> 52:35.670
还可以用arbitics

52:35.670 --> 52:37.670
是不是拿到对象的所有的属性名

52:37.670 --> 52:38.670
组成的数组

52:38.670 --> 52:41.670
然后用FOR循环去循环这个数组

52:41.670 --> 52:42.670
对吧

52:42.670 --> 52:44.670
当然我也可以用FOR循环去循环

52:44.670 --> 52:48.670
循环它所有的属性名

52:48.670 --> 52:49.670
可不可以

52:49.670 --> 52:50.670
可以啊

52:50.670 --> 52:51.670
这个是不是拿到一个数组

52:51.670 --> 52:52.670
数组里边

52:52.670 --> 52:53.670
是不是ABC

52:53.670 --> 52:55.670
循环这个数组

52:55.670 --> 52:56.670
是吧

52:56.670 --> 52:57.670
可以吗

52:57.670 --> 52:58.670
那我也可以怎么办呢

52:58.670 --> 53:00.670
我也可以拿到这个数组之后

53:00.670 --> 53:02.670
调用这个数组的FOR一起方法

53:02.670 --> 53:03.670
我们之前学过的

53:03.670 --> 53:04.670
对吧

53:05.670 --> 53:07.670
然后可以拿到一个数组的每一项的值

53:10.670 --> 53:11.670
不一样吗

53:12.670 --> 53:14.670
做法太多了

53:14.670 --> 53:16.670
便利所有的属性名

53:16.670 --> 53:17.670
好

53:17.670 --> 53:18.670
又来啊

53:18.670 --> 53:20.670
便利对象的所有的属性值

53:20.670 --> 53:22.670
我都不知道这两个

53:22.670 --> 53:27.900
在写法上有多大的区别

53:27.900 --> 53:29.900
不就便利所有的属性值了吗

53:30.900 --> 53:32.900
便利对象的所有的属性名和属性值

53:32.900 --> 53:34.900
是不是写过的

53:35.900 --> 53:37.900
之前用FOR不循环写过的一次

53:37.900 --> 53:38.900
那么现在呢

53:38.900 --> 53:39.900
我要

53:39.900 --> 53:41.900
FOR一起

53:42.900 --> 53:43.900
通过什么N确实

53:43.900 --> 53:45.900
是不是拿到所有的属性名和属性值

53:46.900 --> 53:47.900
这里是V

53:47.900 --> 53:48.900
V

53:48.900 --> 53:50.900
密名还在注意

53:51.900 --> 53:52.900
那么这样子

53:52.900 --> 53:54.900
这一块拿到的是什么

53:54.900 --> 53:56.900
拿到的是一个人一个人的对象

53:56.900 --> 53:58.900
你输出看一下吧

53:58.900 --> 54:07.910
拿到的是这么一个东西

54:07.910 --> 54:08.910
所以说你现在在干嘛呀

54:08.910 --> 54:10.910
你现在在循环这个数组

54:10.910 --> 54:11.910
这是第一数组的第一项

54:11.910 --> 54:12.910
这是数组的第二项

54:12.910 --> 54:14.910
所以说那数组的每一项是个啥

54:15.910 --> 54:16.910
是不是N确

54:17.910 --> 54:18.910
这是什么东西

54:19.910 --> 54:23.380
你看

54:24.380 --> 54:25.380
BND

54:25.380 --> 54:26.380
拿到了每一项

54:26.380 --> 54:27.380
D

54:27.380 --> 54:28.380
这是数组的第一项

54:28.380 --> 54:29.380
数组的第二项

54:29.380 --> 54:30.380
数组的第三项

54:30.380 --> 54:33.380
我要把里边的东西拿出来怎么办呢

54:33.380 --> 54:34.380
在这个位置

54:34.380 --> 54:36.380
参数位置有传递吗

54:36.380 --> 54:37.380
有传递

54:37.380 --> 54:39.380
第一项传递给了N确

54:39.380 --> 54:41.380
第二项传递给了N确

54:41.380 --> 54:42.380
所以在这里的位置

54:42.380 --> 54:43.380
也可以解构

54:43.380 --> 54:44.380
解构无处不在

54:44.380 --> 54:46.380
可以发生任何时候

54:46.380 --> 54:47.380
数组的第一项就T

54:47.380 --> 54:48.380
第二项就是G

54:49.380 --> 54:51.380
那么输出TB

54:54.260 --> 54:55.260
然后你要输出一个字无窗

54:55.260 --> 54:56.260
评拼接也可以

54:58.260 --> 54:59.260
下面这个

54:59.260 --> 55:01.260
复制对象OBG的所有的属性

55:01.260 --> 55:02.260
到一个新的对象

55:04.260 --> 55:05.260
6OBG

55:05.260 --> 55:07.260
等于一个新的对象

55:07.260 --> 55:08.260
其他对象里边所有的属性

55:08.260 --> 55:09.260
来自于OBG

55:10.260 --> 55:11.260
一句话就写完了

55:11.260 --> 55:12.260
还需要去用话吗

55:12.260 --> 55:13.260
不需要

55:13.260 --> 55:16.600
然后我们来看一下

55:16.600 --> 55:18.600
新对象跟旧对象是不一样的

55:18.600 --> 55:19.600
你不要搞错了

55:19.600 --> 55:21.600
他们俩对象的地址都不一样

55:23.600 --> 55:25.600
只是复制的所有的属性

55:25.600 --> 55:26.600
对的

55:26.600 --> 55:28.600
这是这一块

55:28.600 --> 55:29.600
然后复制OBG

55:29.600 --> 55:31.600
除A以外的属性

55:31.600 --> 55:32.600
就A我不要

55:32.600 --> 55:34.600
A这个属性我不要

55:35.600 --> 55:37.600
其他的属性我全要

55:37.600 --> 55:39.600
然后放到一个新的对象里边去

55:39.600 --> 55:41.600
知道大姐吗

55:42.600 --> 55:43.600
当然了

55:43.600 --> 55:44.600
这里边写法有很多

55:44.600 --> 55:46.600
比如6OBG

55:46.600 --> 55:48.600
你把所有的东西复制过来

55:48.600 --> 55:49.600
然后去删除

55:49.600 --> 55:50.600
可不可以呢

55:50.600 --> 55:51.600
当然可以

55:51.600 --> 55:52.600
你不能说这个代码是错的

55:52.600 --> 55:53.600
也不能说这个代码不好

55:53.600 --> 55:54.600
也没有什么不好的

55:54.600 --> 55:56.600
挺好的我觉得

55:56.600 --> 55:57.600
一眼就看清楚了

55:57.600 --> 55:58.600
对吧

55:58.600 --> 55:59.600
没有什么问题

56:01.600 --> 56:03.600
当然还有一些别的写法

56:03.600 --> 56:04.600
就是我们选择很多

56:04.600 --> 56:06.600
写代码选择是很多的

56:06.600 --> 56:07.600
目标一致

56:07.600 --> 56:08.600
但是我们写的

56:08.600 --> 56:10.600
时间的过程是不可以

56:10.600 --> 56:11.600
多懂多样的

56:11.600 --> 56:12.600
然后我可以怎么写

56:12.600 --> 56:13.600
我可以这样的写

56:15.600 --> 56:18.600
复制除A以外的属性

56:18.600 --> 56:20.600
到一个新的对象

56:22.600 --> 56:23.600
好像

56:23.600 --> 56:25.600
其他的写法我想一想

56:26.600 --> 56:27.600
我可以这样子写

56:28.600 --> 56:31.360
我用解构来写

56:31.360 --> 56:32.360
你看着

56:32.360 --> 56:33.360
我把这个OBG放过来

56:33.360 --> 56:34.360
我在这里解构

56:35.360 --> 56:36.360
我解构出一个属性A

56:36.360 --> 56:38.360
生于的属性

56:40.360 --> 56:41.360
放到一个牛OBG

56:42.360 --> 56:43.360
这样子写也是可以的

56:46.120 --> 56:47.120
也是可以的

56:47.120 --> 56:48.120
然后再把A输出

56:49.120 --> 56:51.120
就是我把对象的解构

56:51.120 --> 56:52.120
解构出来

56:52.120 --> 56:53.120
它不是有三个属性吗

56:53.120 --> 56:54.120
ABC A

56:54.120 --> 56:55.120
一个放这

56:55.120 --> 56:56.120
其他的属性

56:56.120 --> 56:57.120
一个放这

56:57.120 --> 56:59.120
你看之前我在解构的时候

56:59.120 --> 57:00.120
解构的时候

57:00.120 --> 57:01.120
是对数组是做了这么一种

57:01.120 --> 57:02.120
稍稍做的

57:03.120 --> 57:04.120
对数组这一块

57:05.120 --> 57:06.120
是做的这种稍稍

57:06.120 --> 57:07.120
对象也可以

57:08.120 --> 57:09.120
这倒题

57:10.120 --> 57:11.120
好 下倒题

57:11.120 --> 57:14.460
先看懂题

57:14.460 --> 57:15.460
就是说

57:15.460 --> 57:16.460
我这里

57:16.460 --> 57:17.460
希望你写一个函数

57:17.460 --> 57:18.460
你自己要给我写个

57:18.460 --> 57:19.460
函数出来

57:20.460 --> 57:21.460
函数出来

57:22.460 --> 57:23.460
然后

57:23.460 --> 57:24.460
这个函数是这么一种情况

57:24.460 --> 57:25.460
我一定要用它

57:26.460 --> 57:27.460
它给我返回一个对象

57:27.460 --> 57:28.460
这是它返回的对象

57:28.460 --> 57:29.460
你甭管对象是什么

57:29.460 --> 57:30.460
无所谓吧

57:30.460 --> 57:31.460
反正给我返回一个对象

57:32.460 --> 57:33.460
但是我也

57:33.460 --> 57:34.460
我不喘参举给我返回这个

57:35.460 --> 57:36.460
我传参

57:36.460 --> 57:37.460
我就可以修改

57:37.460 --> 57:39.460
你给我返回的对象里面的东西

57:39.460 --> 57:41.460
比方说我传入一个Time 500

57:41.460 --> 57:42.460
那你给我返回的对象

57:42.460 --> 57:43.460
其他就保持默认值

57:44.460 --> 57:45.460
SPE的为50

57:45.460 --> 57:46.460
TX为

57:46.460 --> 57:47.460
空之不串

57:47.460 --> 57:48.460
Time变成了你的配置

57:48.460 --> 57:51.460
其实这是一种非常非常经典的

57:52.460 --> 57:53.460
配置处理

57:55.460 --> 57:56.460
那么在配置的时候

57:56.460 --> 57:57.460
我们会给它

57:57.460 --> 57:58.460
传一个配置对象

57:59.460 --> 58:01.460
我们不用把全部的配置给它

58:01.460 --> 58:02.460
它每一个配置都有默认值

58:02.460 --> 58:03.460
你没有给我传

58:03.460 --> 58:04.460
我就使用默认值

58:04.460 --> 58:05.460
你给我传

58:05.460 --> 58:06.460
我就使用你一个我的值

58:07.460 --> 58:08.460
写这么一个函数

58:08.460 --> 58:09.460
你让我下面

58:09.460 --> 58:10.460
把它传两个

58:11.460 --> 58:12.460
那么就把这个改了

58:12.460 --> 58:13.460
把这个改了

58:13.460 --> 58:14.460
这个东西保持默认值

58:15.460 --> 58:16.460
好 你们尝试写一下

58:17.460 --> 58:19.460
你可以用之前的任何技术来写都可以

58:21.460 --> 58:22.460
好了 让我讲一下

58:22.460 --> 58:23.460
这一块怎么写呢

58:24.460 --> 58:25.460
那肯定得有一个参数吧

58:25.460 --> 58:26.460
这个参数是啥呀

58:26.460 --> 58:28.460
不得是一个对象吗

58:28.460 --> 58:29.460
对吧

58:30.460 --> 58:31.460
你看我这里怎么来写

58:33.460 --> 58:35.460
你有可能没有啥都没给我传

58:35.460 --> 58:37.460
没有给我传的话

58:37.460 --> 58:39.460
我就认为你是一个空对象

58:45.460 --> 58:46.460
对吧

58:46.460 --> 58:47.460
如果说你啥都没给我传

58:47.460 --> 58:48.460
你给我传一个undefined

58:48.460 --> 58:49.460
那我就认为

58:49.460 --> 58:50.460
你是给我传的是个空对象

58:52.460 --> 58:53.460
就是这样的写

58:53.460 --> 58:54.460
跟这样的写是一样的

58:56.460 --> 58:57.460
好 接下来呢

58:57.460 --> 58:59.460
我要设置一个默认配置

58:59.460 --> 59:01.460
default options

59:02.460 --> 59:03.460
默认配置是啥呀

59:03.460 --> 59:05.460
默认配置就不是这个玩意吗

59:07.460 --> 59:08.460
这是它的默认配置

59:08.460 --> 59:10.460
好 接下来我要做啥

59:10.460 --> 59:13.460
我要让这个配置去覆盖默认配置

59:14.460 --> 59:15.460
然后得到一个新的对象

59:17.460 --> 59:18.460
一句话就可以写

59:20.460 --> 59:22.460
先展开默认配置

59:22.460 --> 59:24.460
再展开 options

59:24.460 --> 59:25.460
完了

59:25.460 --> 59:26.460
那你想一想

59:26.460 --> 59:28.460
你这样子一展开

59:28.460 --> 59:29.460
默认配置这三个属性

59:29.460 --> 59:30.460
是不是都在这了

59:31.460 --> 59:33.460
那么你给我传的配置里边

59:33.460 --> 59:34.460
如果说有没有的话

59:34.460 --> 59:35.460
就啥都没有

59:35.460 --> 59:36.460
这里就啥都没有

59:36.460 --> 59:37.460
如果说这里面有属性

59:37.460 --> 59:38.460
是不是覆盖了之前的

59:39.460 --> 59:40.460
对吧 返回这么一个对象

59:40.460 --> 59:41.460
就完事了

59:41.460 --> 59:42.460
好 咱们来试一下

59:43.460 --> 59:44.460
你看我这里啥都没传

59:50.800 --> 59:51.800
我们这里呢

59:51.800 --> 59:52.800
给他复职

59:52.800 --> 59:53.800
然后输出

59:54.800 --> 59:58.200
好 我们看一下

59:59.200 --> 01:00:00.200
这句话得到了

01:00:00.200 --> 01:00:01.200
是不是这个没问题吧

01:00:02.200 --> 01:00:03.200
我这里啥都没干传

01:00:03.200 --> 01:00:04.200
啥都没干传的话

01:00:04.200 --> 01:00:05.200
我们这里呢

01:00:05.200 --> 01:00:06.200
就得到空对象

01:00:06.200 --> 01:00:07.200
相当于是这里的

01:00:07.200 --> 01:00:08.200
展开的是一个空对象

01:00:10.200 --> 01:00:11.200
相当于是啥都没展开

01:00:13.200 --> 01:00:14.200
这个第一个没问题吧

01:00:14.200 --> 01:00:15.200
然后来看第二个

01:00:18.540 --> 01:00:19.540
第二个

01:00:19.540 --> 01:00:20.540
是不是把这个改了

01:00:20.540 --> 01:00:21.540
Time改了

01:00:21.540 --> 01:00:22.540
其他都没动

01:00:22.540 --> 01:00:23.540
为什么呢

01:00:23.540 --> 01:00:24.540
对象进去

01:00:24.540 --> 01:00:26.540
把这个对象一展开

01:00:27.540 --> 01:00:29.540
把这个对象一展开

01:00:29.540 --> 01:00:30.540
一展开的话

01:00:30.540 --> 01:00:32.540
是不是把Time就覆盖了之前的

01:00:32.540 --> 01:00:33.540
对吧

01:00:33.540 --> 01:00:34.540
覆盖了之前的

01:00:34.540 --> 01:00:35.540
Time为1000

01:00:37.540 --> 01:00:38.540
同理

01:00:38.540 --> 01:00:40.540
那么后边的都没问题了

01:00:40.540 --> 01:00:42.540
这是一种非常经典的

01:00:42.540 --> 01:00:44.540
配置处理

01:00:44.540 --> 01:00:46.540
就是有可能有很多的配置

01:00:46.540 --> 01:00:47.540
有默认配置

01:00:47.540 --> 01:00:49.540
也可以当用户传一些配置

01:00:49.540 --> 01:00:50.540
传了就使用用户的

01:00:50.540 --> 01:00:52.540
没传就使用默认

01:00:52.540 --> 01:00:53.540
几句话就可以写了

01:00:53.540 --> 01:00:54.540
以前还挺麻烦

01:00:55.540 --> 01:00:56.540
好 下一道题

01:00:57.540 --> 01:01:01.380
便利对象优势

01:01:02.380 --> 01:01:04.380
把每一个属性变成getter和setter

01:01:06.380 --> 01:01:07.380
保持读写功能

01:01:07.380 --> 01:01:08.380
这条题有点难度

01:01:09.380 --> 01:01:10.380
第五题已经说完了

01:01:10.380 --> 01:01:11.380
咱们这几课的最后道题

01:01:12.380 --> 01:01:13.380
有点难度

01:01:13.380 --> 01:01:14.380
同学们

01:01:14.380 --> 01:01:15.380
研究研究

01:01:15.380 --> 01:01:16.380
就是啥意思

01:01:17.380 --> 01:01:19.380
我这边有个对象

01:01:19.380 --> 01:01:20.380
我要让你呢

01:01:20.380 --> 01:01:21.380
在这里写段代码

01:01:22.380 --> 01:01:24.380
把他的每一个属性

01:01:24.380 --> 01:01:25.380
变成getter和setter

01:01:26.380 --> 01:01:27.380
忘记了

01:01:27.380 --> 01:01:28.380
就差跃

01:01:30.380 --> 01:01:31.380
保持读写功能不变

01:01:31.380 --> 01:01:32.380
就是说

01:01:32.380 --> 01:01:34.380
如果说我给他的内敏属性

01:01:34.380 --> 01:01:35.380
复制为啥啥啥啥

01:01:35.380 --> 01:01:37.380
他要真能够复制过去

01:01:37.380 --> 01:01:38.380
只要真能够变动

01:01:39.380 --> 01:01:40.380
读的属性的是

01:01:40.380 --> 01:01:41.380
但是呢

01:01:41.380 --> 01:01:42.380
我有一个要求

01:01:42.380 --> 01:01:44.380
凡是以后在读属性的时候

01:01:44.380 --> 01:01:46.380
甭管是读内敏属性

01:01:46.380 --> 01:01:47.380
还是读A级属性

01:01:47.380 --> 01:01:49.380
读啥属性都无所谓

01:01:49.380 --> 01:01:51.380
凡是在读属性的时候

01:01:52.380 --> 01:01:54.380
你要给我输出这么一句话

01:01:55.380 --> 01:01:57.380
凡是给属性复制的时候

01:01:57.380 --> 01:01:59.380
你要给我输出这么一句话

01:02:00.380 --> 01:02:01.380
就是啥意思

01:02:01.380 --> 01:02:02.380
就是说我这边

01:02:02.380 --> 01:02:03.380
优热内敏高科

01:02:03.380 --> 01:02:05.380
他复制为凳哥

01:02:06.380 --> 01:02:07.380
那么

01:02:07.380 --> 01:02:08.380
就这一句话

01:02:08.380 --> 01:02:09.380
你必须后边

01:02:09.380 --> 01:02:11.380
要产生一个输出

01:02:12.380 --> 01:02:13.380
控制台产生一个输出

01:02:13.380 --> 01:02:15.380
正在

01:02:15.380 --> 01:02:17.380
设置内敏属性

01:02:18.380 --> 01:02:20.380
新的值为

01:02:21.380 --> 01:02:22.380
凳哥

01:02:23.380 --> 01:02:25.380
要产生这么一句输出

01:02:25.380 --> 01:02:26.380
然后呢

01:02:26.380 --> 01:02:27.380
我如果说

01:02:27.380 --> 01:02:29.380
在读这个内敏属性的时候

01:02:29.380 --> 01:02:31.380
你要给我输出

01:02:31.380 --> 01:02:33.380
正在

01:02:33.380 --> 01:02:36.380
读取内敏属性

01:02:36.380 --> 01:02:38.380
值为凳哥

01:02:39.380 --> 01:02:41.380
对每一个属性都是如此

01:02:45.380 --> 01:02:46.380
好 那咱们再试一下

01:02:47.380 --> 01:02:49.380
把每一个属性变为getter

01:02:49.380 --> 01:02:50.380
setter

01:02:50.380 --> 01:02:52.380
那时候要变异所有的属性

01:02:52.380 --> 01:02:53.380
变异属性怎么办

01:02:53.380 --> 01:02:55.380
这是一个综合练习

01:02:59.380 --> 01:03:00.380
每一个属性的名

01:03:00.380 --> 01:03:01.380
每一个属性值

01:03:01.380 --> 01:03:02.380
所以全拿到了

01:03:02.380 --> 01:03:03.380
对象团进去

01:03:04.380 --> 01:03:05.380
然后呢

01:03:05.380 --> 01:03:07.380
for each 循环它

01:03:07.380 --> 01:03:08.380
每一次循环

01:03:08.380 --> 01:03:09.380
拿到的是什么呢

01:03:09.380 --> 01:03:10.380
拿到的是一个数组

01:03:10.380 --> 01:03:11.380
不要诱惑了

01:03:11.380 --> 01:03:13.380
我们又来看一下

01:03:13.380 --> 01:03:17.080
每一次循环是不是拿到一个数组

01:03:17.080 --> 01:03:18.080
对吧

01:03:18.080 --> 01:03:19.080
对一个数组是不是可以解构

01:03:19.080 --> 01:03:20.080
解构出什么

01:03:21.080 --> 01:03:22.080
属性名

01:03:22.080 --> 01:03:23.080
属性值

01:03:24.080 --> 01:03:25.080
属性名

01:03:25.080 --> 01:03:26.080
属性值

01:03:26.080 --> 01:03:29.420
你看

01:03:29.420 --> 01:03:30.420
属解构出来了

01:03:30.420 --> 01:03:32.420
好 接下来拿到

01:03:32.420 --> 01:03:33.420
每一个属性干嘛呀

01:03:33.420 --> 01:03:35.420
对该属性

01:03:35.420 --> 01:03:38.420
重新定义

01:03:38.420 --> 01:03:39.420
描述服

01:03:39.420 --> 01:03:40.420
因为我要对每一个属性

01:03:40.420 --> 01:03:41.420
变成getter

01:03:41.420 --> 01:03:42.420
setter

01:03:42.420 --> 01:03:43.420
得重新定义描述服

01:03:43.420 --> 01:03:44.420
怎么定义描述服

01:03:44.420 --> 01:03:45.420
objects

01:03:45.420 --> 01:03:46.420
define

01:03:46.420 --> 01:03:47.420
property

01:03:47.420 --> 01:03:48.420
对象是什么

01:03:48.420 --> 01:03:49.420
user

01:03:49.420 --> 01:03:50.420
属性名是什么

01:03:50.420 --> 01:03:51.420
key

01:03:51.420 --> 01:03:52.420
描述服

01:03:53.420 --> 01:03:54.420
描述服

01:03:54.420 --> 01:03:55.420
我要不是一个普通的描述服

01:03:55.420 --> 01:03:56.420
是带有getter

01:03:56.420 --> 01:03:57.420
setter

01:03:57.420 --> 01:03:58.420
所以说我都要写两个函数

01:03:58.420 --> 01:03:59.420
get

01:03:59.420 --> 01:04:00.420
和set

01:04:01.420 --> 01:04:05.650
get是什么时候

01:04:05.650 --> 01:04:06.650
什么情况运行

01:04:06.650 --> 01:04:09.650
读这个对象的属性的时候

01:04:09.650 --> 01:04:10.650
它就会运行get

01:04:11.650 --> 01:04:12.650
运行get的时候要干嘛呀

01:04:12.650 --> 01:04:13.650
读属性的时候

01:04:13.650 --> 01:04:14.650
是不是要输出这么一句话

01:04:14.650 --> 01:04:15.650
那我就输出呗

01:04:16.650 --> 01:04:17.650
读属性的时候

01:04:17.650 --> 01:04:18.650
输出什么

01:04:18.650 --> 01:04:19.650
这句话

01:04:20.650 --> 01:04:21.650
正在读什么属性

01:04:21.650 --> 01:04:22.650
这里要填什么

01:04:22.650 --> 01:04:23.650
属性的名字

01:04:23.650 --> 01:04:24.650
属性的名字就是key

01:04:25.650 --> 01:04:26.650
这里填什么

01:04:26.650 --> 01:04:27.650
属性的值

01:04:27.650 --> 01:04:28.650
属性的值是什么

01:04:28.650 --> 01:04:29.650
这道题啊

01:04:29.650 --> 01:04:30.650
尽量听啊

01:04:30.650 --> 01:04:31.650
听不懂就算了

01:04:31.650 --> 01:04:33.650
我出色道题的目的

01:04:33.650 --> 01:04:34.650
是为了以后

01:04:34.650 --> 01:04:35.650
讲无忧这个原理的时候

01:04:35.650 --> 01:04:36.650
买下伏笔

01:04:37.650 --> 01:04:38.650
跟你们平时开发

01:04:38.650 --> 01:04:39.650
没有什么关系的

01:04:39.650 --> 01:04:40.650
如果实在听不懂

01:04:40.650 --> 01:04:41.650
放跑嘛

01:04:41.650 --> 01:04:42.650
以后再说吧

01:04:42.650 --> 01:04:43.650
没关系的

01:04:43.650 --> 01:04:44.650
不影响后边学习

01:04:46.650 --> 01:04:47.650
正在读取这个属性

01:04:47.650 --> 01:04:48.650
值为什么

01:04:48.650 --> 01:04:49.650
值为Value

01:04:49.650 --> 01:04:50.650
这是属性的值吗

01:04:50.650 --> 01:04:51.650
好你get的时候

01:04:51.650 --> 01:04:52.650
得到的时候

01:04:52.650 --> 01:04:54.650
是不是要我返回这个值

01:04:54.650 --> 01:04:55.650
返回这个属性的值

01:04:55.650 --> 01:04:56.650
你要读属性吗

01:04:56.650 --> 01:04:57.650
你不返回的话

01:04:57.650 --> 01:04:58.650
他就得读

01:04:58.650 --> 01:04:59.650
所谓的属性的返回

01:04:59.650 --> 01:05:00.650
得到的是NG犯的

01:05:01.650 --> 01:05:02.650
要把这个属性值返回

01:05:03.650 --> 01:05:04.650
好set的时候

01:05:04.650 --> 01:05:05.650
我是不要输出另外一句话

01:05:11.540 --> 01:05:12.540
正在设置什么属性呢

01:05:13.540 --> 01:05:14.540
这个属性

01:05:14.540 --> 01:05:15.540
新的值

01:05:15.540 --> 01:05:16.540
新的值是不是这个

01:05:17.540 --> 01:05:18.540
set的时候

01:05:18.540 --> 01:05:19.540
相当于负值的时候

01:05:19.540 --> 01:05:20.540
把新的值通为参数传进来

01:05:20.540 --> 01:05:21.540
这是新的值

01:05:22.540 --> 01:05:23.540
当然你设置的时候

01:05:23.540 --> 01:05:24.540
是不是还要

01:05:24.540 --> 01:05:25.540
把这个value

01:05:25.540 --> 01:05:26.540
设置为Value

01:05:26.540 --> 01:05:27.540
不然的话

01:05:27.540 --> 01:05:28.540
get的值

01:05:28.540 --> 01:05:29.540
那就相当于

01:05:29.540 --> 01:05:30.540
你没有设置

01:05:30.540 --> 01:05:31.540
只是运行的一丝函数

01:05:31.540 --> 01:05:32.540
不然的话

01:05:32.540 --> 01:05:34.540
之后再去运行get的时候

01:05:34.540 --> 01:05:36.540
得到还是值钱的值

01:05:37.540 --> 01:05:39.540
对每一个属性

01:05:39.540 --> 01:05:40.540
做了这么一个操作

01:05:41.540 --> 01:05:42.540
循环属性

01:05:42.540 --> 01:05:43.540
对每一个属性

01:05:43.540 --> 01:05:44.540
做这么一个操作

01:05:44.540 --> 01:05:45.540
那么这段操作

01:05:45.540 --> 01:05:46.540
做完了之后

01:05:46.540 --> 01:05:50.460
你会发现有点意思

01:05:50.460 --> 01:05:51.460
读属性

01:05:51.460 --> 01:05:52.460
你看

01:05:52.460 --> 01:05:55.150
读属性

01:05:56.150 --> 01:05:57.150
你看

01:05:58.150 --> 01:06:00.150
加3

01:06:01.150 --> 01:06:02.150
你看

01:06:02.150 --> 01:06:04.460
是不是还是在读

01:06:05.460 --> 01:06:07.460
然后给属性负值

01:06:08.460 --> 01:06:09.460
6

01:06:09.460 --> 01:06:10.460
没有

01:06:11.460 --> 01:06:14.350
设置6是属性

01:06:14.350 --> 01:06:15.350
新的值为没有

01:06:16.350 --> 01:06:17.350
你看

01:06:17.350 --> 01:06:18.350
那如果说我这样子

01:06:18.350 --> 01:06:19.350
有点A级

01:06:20.350 --> 01:06:21.350
等于

01:06:21.350 --> 01:06:22.350
加等于

01:06:23.350 --> 01:06:24.350
10

01:06:24.350 --> 01:06:25.350
他会说出啥

01:06:26.350 --> 01:06:28.350
他先读取再设置

01:06:28.350 --> 01:06:29.350
为啥

01:06:29.350 --> 01:06:30.350
约这个

01:06:30.350 --> 01:06:31.350
预算符

01:06:31.350 --> 01:06:32.350
他的本质是这样子

01:06:33.350 --> 01:06:34.350
所以先把他的值

01:06:34.350 --> 01:06:35.350
读出来

01:06:35.350 --> 01:06:36.350
触发这个get的方法

01:06:38.350 --> 01:06:39.350
返回的是什么

01:06:39.350 --> 01:06:40.350
返回的是17

01:06:40.350 --> 01:06:41.350
17加10

01:06:41.350 --> 01:06:42.350
是不是27

01:06:42.350 --> 01:06:43.350
再把27负值给他

01:06:43.350 --> 01:06:45.350
是不是相当于运行set

01:06:46.350 --> 01:06:48.350
相当于运行set

01:06:48.350 --> 01:06:50.350
这里传入27

01:06:50.350 --> 01:06:52.350
然后运行这么一句话

01:06:53.350 --> 01:06:54.350
了解就行了

01:06:55.350 --> 01:06:56.350
好了就没啥了

01:06:56.350 --> 01:06:57.350
这就是

01:06:57.350 --> 01:06:59.350
那个对象的更改

01:06:59.350 --> 01:07:01.350
再说一次东西都

01:07:01.350 --> 01:07:03.350
我们跟我们平时开发相关的

01:07:03.350 --> 01:07:04.350
前三个

01:07:05.350 --> 01:07:06.350
后边的作业了解

01:07:07.350 --> 01:07:08.350
多的时候

01:07:08.350 --> 01:07:09.350
他有那么一点印象

01:07:09.350 --> 01:07:10.350
可以了

01:07:11.350 --> 01:07:12.350
这是

01:07:12.350 --> 01:07:13.350
咱们对象的方式改动

01:07:13.350 --> 01:07:15.350
你把能够把作业听懂

01:07:15.350 --> 01:07:16.350
就这到底除外

01:07:16.350 --> 01:07:18.350
其他题能做出来

01:07:18.350 --> 01:07:19.350
就ok了

01:07:19.350 --> 01:07:20.350
哪怕你用过去的方式

01:07:20.350 --> 01:07:21.350
做出来都ok

01:07:21.350 --> 01:07:23.350
好都是咱们这一刻的内容

