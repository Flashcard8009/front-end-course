WEBVTT

00:00.000 --> 00:02.000
来 寒树

00:03.200 --> 00:07.680
你看前面对这个对象树主这些东西都做了很大的变化了

00:08.200 --> 00:11.000
但是变了变去了其实没有增加什么新的功能

00:11.000 --> 00:15.360
只是我们有的时候写代码的变得比较简洁了

00:16.120 --> 00:18.600
寒树也一样 寒树这一块东西呢

00:18.920 --> 00:20.600
它没有增加任何的新功能

00:20.600 --> 00:24.400
就是以前你怎么写寒树还可以怎么写

00:25.240 --> 00:26.840
以前能办到的事 现在能办到

00:26.840 --> 00:28.800
以前办不到的事 现在还是办不到

00:29.280 --> 00:32.000
因此 这个寒树这一块 它只是给你做了一些

00:33.040 --> 00:36.240
语法上的升级 让你写寒树变得更加简单

00:36.800 --> 00:39.560
好 咱们来看一下吧 第一个 箭头寒树

00:40.560 --> 00:46.240
叫啥意思呢 就是我们平时有的时候啊 会经常写一些寒树表达式

00:47.040 --> 00:49.120
什么叫寒树表达式啊 回来看一下

00:50.760 --> 00:54.720
以后我们这样子写的话 是一个寒树声明 对吧 叫寒树声明

00:55.160 --> 00:57.680
什么叫寒树表达式呢 比较跟你这样子写

00:58.880 --> 01:00.160
这就是一个寒树表达式

01:00.960 --> 01:03.840
它把这个寒树表达式复制给变量A

01:04.520 --> 01:07.280
一看一个寒树表达式 它其实跟其他表达式

01:07.280 --> 01:10.000
并没有什么本质的区别 比方说我们像那个

01:10.520 --> 01:13.480
有的时候会这样子写 ADD event listener

01:15.520 --> 01:16.080
比方说Click

01:18.360 --> 01:21.000
你看这 这是不是也是一个寒树表达式

01:21.760 --> 01:23.800
对吧 还包括我们有的时候怎么写呢

01:23.800 --> 01:27.120
比方说我们这里呢 可以多 unclick

01:29.720 --> 01:32.360
你看这个地方 它也是一个寒树表达式

01:32.880 --> 01:35.880
这叫寒树声明 其他都是寒树表达式

01:37.280 --> 01:40.840
好 那么这个寒树表达式的协访呢 它觉得有点枯燥乏味

01:41.360 --> 01:43.160
因此呢 它给你做了一个语法上的更新

01:43.880 --> 01:47.280
它有一种更加简洁的寒树表达式的书写

01:48.040 --> 01:50.480
你看我们以前的寒树表达式书写 它怎么写的

01:50.760 --> 01:52.520
它这样写的 一个方个形

01:53.080 --> 01:55.480
然后里边写上参数列表 对吧

01:56.480 --> 02:00.160
然后呢 后边两个大括号 里边的是寒树体

02:01.240 --> 02:02.360
那我们来对比一下啊

02:02.760 --> 02:04.960
它给你增加了一个叫箭头寒树的东西

02:04.960 --> 02:07.840
它专门用来写这个寒树表达式

02:08.520 --> 02:11.120
那咋写呢 方个形可以省略掉了

02:11.600 --> 02:13.960
直接是参数列表 然后呢 一个箭头

02:13.960 --> 02:15.880
一个等号 一个大笔符号 有箭头

02:16.160 --> 02:17.440
然后这里边写寒树体

02:18.840 --> 02:20.880
而且我们来看一下吧 我们再试验一下

02:21.120 --> 02:22.760
比方说我们就写一个球盒的寒树

02:22.920 --> 02:24.800
我们可以怎么写呢 比方说我们可以这样写

02:26.040 --> 02:27.800
参数列表 A B

02:28.280 --> 02:30.920
然后一个箭头 两个大括号 寒树体

02:31.120 --> 02:33.640
发而回 A加B 不就是个球盒吗

02:34.080 --> 02:35.160
对吧 我们来试一下啊

02:35.960 --> 02:37.560
输出 1 2

02:39.480 --> 02:40.680
运行 说不得了啊 三

02:41.600 --> 02:42.440
就这么简单

02:42.880 --> 02:45.960
那么这里呢 其实本质上跟这个方个形的

02:45.960 --> 02:48.280
这种寒树表达式呢 其实本质上差不多

02:48.520 --> 02:50.520
有一些区别 我们一会再慢慢说

02:51.560 --> 02:53.000
那么这就是一个箭头寒树

02:53.320 --> 02:55.840
两个小括号 里边写参数 一个箭头

02:56.400 --> 02:57.960
大括号 里边写寒树体

02:58.960 --> 03:04.840
这个箭头寒树呢 它其实上还有一些简略的写法

03:05.000 --> 03:07.360
比方说这个参数 如果说只有一个的话

03:07.480 --> 03:09.880
那么你是可以省略掉这个大括号的

03:10.160 --> 03:10.720
可以省略的

03:11.440 --> 03:14.760
如果说你的寒树体 只有一条返回语句的话

03:14.880 --> 03:17.080
你可以省略掉大括号和return

03:17.320 --> 03:19.000
啥意思 比方说像这个寒树体

03:19.240 --> 03:21.920
这个寒树体呢 里边是不是只有一句返回语句

03:22.560 --> 03:24.240
那么你可以省略掉这个大括号

03:24.840 --> 03:26.200
同时把这个return去掉

03:27.040 --> 03:28.520
更加简洁了 对吧 我们来看一下

03:29.640 --> 03:30.480
结果仍然是一样

03:30.920 --> 03:33.760
那么这样子其实更加好理解 怎么好理解呢 你看

03:35.440 --> 03:37.160
你给我一个A和B

03:38.400 --> 03:40.480
我给你一个A加B

03:41.160 --> 03:42.200
对吧 这不就是一个寒树吗

03:42.320 --> 03:45.360
寒树不就是输入一个东西 然后返回一个东西吗

03:45.840 --> 03:48.440
输入一些参数 然后返回给你一个东西

03:48.800 --> 03:51.280
那么这一块就是一个寒树

03:52.120 --> 03:53.240
然后这就是箭头和树

03:53.840 --> 03:56.680
如果说你只有一个蚕蜀 比方说我要把一个数字翻倍

03:57.040 --> 03:58.280
那么我们可以这样子写

03:58.520 --> 03:59.000
达堡

04:00.080 --> 04:02.360
你给我一个数字n 我给你翻倍

04:02.640 --> 04:03.600
2乘以n

04:04.400 --> 04:08.520
对吧 那么这条语句呢就相当于是方形

04:09.480 --> 04:10.800
相当于是以前的这种写法

04:10.960 --> 04:11.360
达堡

04:12.600 --> 04:15.120
放个心 你给我一个n 我给你返回一个

04:15.640 --> 04:16.400
2乘以n

04:16.680 --> 04:19.160
那么你看上面那个写法是不是更加简洁一些

04:20.120 --> 04:21.840
如果说你只有一个参数的话

04:21.840 --> 04:23.600
实际上是可以省略这个小货号的

04:23.600 --> 04:26.720
因为我这边我做了一个格式化

04:26.720 --> 04:28.760
一格式化的话 还把小货号给我加上了

04:28.760 --> 04:29.840
实际上是可以省略的

04:30.440 --> 04:32.600
那么这就是这个箭头寒树

04:32.720 --> 04:34.080
这个箭头寒树其实

04:34.320 --> 04:37.080
它不仅仅是可以方便我们去书写

04:37.760 --> 04:38.680
寒树表达式

04:38.960 --> 04:41.120
它其实还有一些别的特点

04:41.480 --> 04:42.400
好 咱们来看一下吧

04:44.800 --> 04:47.400
比方说我们这里

04:48.400 --> 04:51.560
这里1234不能使用6来调用

04:51.560 --> 04:53.960
就这个箭头寒树

04:54.280 --> 04:57.080
它跟以前的一些普通的那个寒树表达式

04:57.240 --> 04:58.960
有这么1234的区别

04:59.160 --> 05:00.720
第一个区别就是不能使用6

05:00.720 --> 05:02.280
就说你这一块不能这样子写

05:02.280 --> 05:03.280
6一个上

05:03.600 --> 05:04.280
你不行

05:04.400 --> 05:05.680
要是它是一个寒树

05:05.680 --> 05:07.280
它肯定可以使用6来调用

05:07.280 --> 05:07.680
对吧

05:07.760 --> 05:10.440
但是那个箭头寒树是不可以的

05:10.440 --> 05:11.640
这样子是要爆出的

05:12.080 --> 05:12.840
它告诉你

05:13.000 --> 05:14.440
它不是一个勾兆器

05:15.400 --> 05:17.360
下一个它没有圆形

05:17.360 --> 05:18.760
它没有Prototype属性

05:18.760 --> 05:20.600
有时候你要找一个箭头寒树的

05:20.600 --> 05:22.240
上点Prototype

05:22.240 --> 05:22.800
不好意思

05:22.800 --> 05:23.560
它是没有的

05:24.240 --> 05:25.040
Undefined

05:25.320 --> 05:26.320
然后你看每一个寒树

05:26.320 --> 05:27.440
它是不是都有一个圆形

05:27.440 --> 05:28.040
它没有

05:29.160 --> 05:31.000
然后它没有Orgument

05:31.000 --> 05:32.880
你说这些箭头寒树里边

05:33.760 --> 05:35.760
你是不能使用Orgument的

05:35.760 --> 05:37.240
比方说我举个例子

05:37.560 --> 05:40.080
这一块也比较容易出面是提

05:40.080 --> 05:41.640
将来我们在面试阶段

05:42.160 --> 05:43.120
对这个箭头寒树

05:43.120 --> 05:44.320
我还会做一些

05:45.640 --> 05:46.560
做一些总结

05:46.800 --> 05:48.480
比方说我这里写个箭头寒树

05:48.960 --> 05:50.520
我这里这样子写吧

05:50.520 --> 05:51.600
我写个寒树声明

05:51.600 --> 05:52.080
颜色的

05:52.080 --> 05:53.280
这是一个普通寒树

05:54.560 --> 05:57.440
然后我在这里边有一个箭头寒树

06:01.180 --> 06:01.820
没有参数

06:01.820 --> 06:02.380
没有参数的话

06:02.380 --> 06:03.580
就两个小过号就可以了

06:04.060 --> 06:06.620
然后我在箭头寒树里边输出Orgument

06:08.980 --> 06:10.420
Orgument

06:11.740 --> 06:12.220
好

06:12.220 --> 06:14.580
接下来我们在这里边调用这个M

06:14.700 --> 06:15.780
给它传一个1

06:15.780 --> 06:16.180
2

06:18.180 --> 06:19.860
接下来我们再来调用Mather

06:20.740 --> 06:21.820
再传一个123

06:22.340 --> 06:23.260
咱们来看一下

06:23.940 --> 06:24.500
你看

06:24.860 --> 06:26.820
我们调用Mather的寒树

06:28.220 --> 06:29.260
它里边会调用什么

06:29.260 --> 06:29.940
调用M

06:30.380 --> 06:31.940
那么这个M给它传了几个参数

06:32.180 --> 06:33.100
就传了两个

06:33.820 --> 06:35.420
按理说的话

06:35.420 --> 06:37.140
这个M这个寒树

06:37.140 --> 06:38.140
它是一个寒树对不对

06:38.820 --> 06:40.860
那么这个寒树给它传了两个参数进去

06:41.220 --> 06:42.740
那么这边输出Orgument

06:42.780 --> 06:43.860
应该长度也级

06:43.860 --> 06:45.100
所以说长度为2

06:45.380 --> 06:47.460
而且它的值是1和2

06:47.780 --> 06:49.100
那么来看一下是不是这样子

06:51.380 --> 06:51.860
它告诉你

06:51.860 --> 06:54.740
它的值有三个

06:54.740 --> 06:56.100
1 2 3

06:56.100 --> 06:58.180
那为什么不是1和2是123

06:58.180 --> 06:59.540
那如果说我们这里传一个

07:00.140 --> 07:00.860
7和8

07:03.690 --> 07:04.370
大概看一下

07:04.370 --> 07:07.490
这些玩意我们以后在做Mather的手都会总结

07:08.290 --> 07:10.250
你看得到了还是123

07:11.090 --> 07:12.450
下标0的地方是1

07:12.450 --> 07:13.690
下标1的地方是2

07:13.690 --> 07:14.370
然后是3

07:14.570 --> 07:15.050
123

07:16.130 --> 07:17.250
那它就起来乖了

07:17.250 --> 07:19.330
那我这里不是传了7和8吗

07:19.330 --> 07:20.970
Orgument为什么得到123

07:20.970 --> 07:24.290
是因为箭头寒树里面根本就没有Orgument

07:24.290 --> 07:25.050
根本就没有

07:25.450 --> 07:27.130
那这里的Orgument用的是啥

07:27.130 --> 07:29.290
用的是外面这个寒树的Orgument

07:29.610 --> 07:30.370
明儿这意思吧

07:30.970 --> 07:33.090
外面这个寒树传入了123

07:33.090 --> 07:36.290
那么外面这个寒树的Orgument

07:36.530 --> 07:38.690
是不是就是123

07:39.170 --> 07:42.810
所以说这里箭头寒树里边用的是外面这个寒树的Orgument

07:42.810 --> 07:44.090
它们自己没有Orgument

07:44.610 --> 07:45.610
好 这是它的第一个特点

07:46.170 --> 07:47.890
那么下一个特点就是

07:47.890 --> 07:50.210
面试的时候比较常见的一个问题

07:50.210 --> 07:52.690
就是关于箭头寒树的Z指向

07:53.410 --> 07:54.210
那么你记住

07:54.410 --> 07:57.490
箭头寒树里边根本就没有Z

07:57.810 --> 07:58.930
它这边是没有Z

08:00.090 --> 08:03.610
于是如果说你在箭头寒树里边用到了Z

08:03.810 --> 08:05.130
它是外面的Z

08:05.850 --> 08:07.250
比方说感觉的Z

08:08.650 --> 08:10.370
我这里有一个对象吧

08:10.610 --> 08:12.050
obc或者是user

08:13.050 --> 08:14.010
有点一个Name

08:15.530 --> 08:16.530
然后了一个寒树

08:16.530 --> 08:18.290
say hello

08:19.330 --> 08:20.450
好 我们这里输出

08:20.850 --> 08:23.250
这个寒树里边我们再套一个寒树吧

08:23.410 --> 08:26.330
比方说我们这里再套一个

08:27.890 --> 08:28.610
sitem out

08:29.890 --> 08:32.330
好 sitem out里边我用了一个箭头寒树

08:32.330 --> 08:33.690
然后一秒钟之后

08:34.010 --> 08:36.290
我输出一个Z

08:36.730 --> 08:40.170
你看看我们过去的戒指这一块是要出问题的

08:40.650 --> 08:44.210
因为这个寒树里边Z指向的是window

08:44.210 --> 08:44.690
对吧

08:44.690 --> 08:46.130
指向的是权局对象

08:47.130 --> 08:48.050
这是之前的事实

08:48.210 --> 08:50.130
但是用了箭头寒树过后就不一样了

08:50.130 --> 08:50.890
咱们再试一下

08:51.290 --> 08:53.050
user say hello

08:53.690 --> 08:55.810
看一秒钟之后是不是能够输出Name呢

08:56.650 --> 08:57.130
运行

08:57.930 --> 08:59.810
一秒钟之后你看是不是输出了Malika

09:00.130 --> 09:01.130
那这是为什么呢

09:01.730 --> 09:05.050
是因为箭头寒树里边根本就没有Z

09:05.690 --> 09:06.250
没有

09:07.010 --> 09:08.530
那么它这里的Z使用的是啥

09:08.690 --> 09:10.330
用的是外面的Z使

09:10.770 --> 09:12.290
用的是这里的Z使

09:12.290 --> 09:13.330
这里的Z使指向啥

09:13.330 --> 09:14.170
只要的是U字

09:15.050 --> 09:15.610
明儿Z是吧

09:15.610 --> 09:16.970
所以说这里的Z使指向U字

09:17.530 --> 09:18.770
这是它最根本的原因

09:19.130 --> 09:21.650
那么有的教程里边的它可能说法不一样

09:21.810 --> 09:23.330
它说箭头寒树的Z使呢

09:23.690 --> 09:26.370
永远指向箭头寒树定义位置的Z使

09:26.370 --> 09:28.050
就是箭头寒树有Z使绑定

09:28.850 --> 09:30.730
它说箭头寒树在这里定义的

09:30.730 --> 09:31.090
对吧

09:31.090 --> 09:33.250
那么就相当于是这里的Z使是啥

09:34.930 --> 09:36.850
箭头寒树里边的Z使就是啥

09:37.210 --> 09:38.170
它有个Z使绑定

09:38.330 --> 09:39.490
实际上它本质的原因

09:39.490 --> 09:41.450
是因为箭头寒树里边根本就没有Z使

09:41.450 --> 09:42.210
用的是外面

09:43.250 --> 09:43.370
好

09:43.370 --> 09:44.890
这关于这个箭头寒树

09:45.650 --> 09:47.010
大概了解一下这些东西

09:47.810 --> 09:48.970
这一集最重要的是

09:48.970 --> 09:50.370
你要知道箭头寒树怎么写

09:51.370 --> 09:52.370
其他的这些东西

09:52.370 --> 09:54.250
我们以后的面试的时候再慢慢说

09:55.210 --> 09:55.490
好吧

09:55.490 --> 09:56.370
这是箭头寒树

09:57.410 --> 09:57.650
好

09:57.650 --> 09:59.050
我这里插播一句

09:59.690 --> 10:00.610
关于箭头寒树

10:00.730 --> 10:02.530
我一开始说了这么一句话

10:03.050 --> 10:05.370
任何寒树表达式

10:05.610 --> 10:08.210
都可以被替代为箭头寒树

10:08.810 --> 10:09.730
严格来说的话

10:09.730 --> 10:11.170
这句话不是很准确

10:11.530 --> 10:14.010
会有一些非常特殊的情况

10:14.010 --> 10:15.690
我这里给大家做一个说明

10:16.570 --> 10:19.850
地动特殊情况就是关于这个语法层面的

10:20.570 --> 10:23.890
就是我们在使用寒树表达式的时候

10:23.890 --> 10:25.610
特别像一些立即执行寒树

10:26.130 --> 10:28.170
我们可能会这样去写

10:28.890 --> 10:29.330
对吧

10:29.330 --> 10:32.930
这样子它就会把这个寒树当成一个表达式

10:32.930 --> 10:35.250
因为前面的一个表达式的运算服务

10:36.050 --> 10:37.330
但是这种情况下

10:37.330 --> 10:39.130
不能适用于箭头寒树

10:39.650 --> 10:40.730
因为用箭头寒树

10:40.730 --> 10:42.250
它会出现一个奇异

10:42.770 --> 10:43.850
比方说我们这样子写

10:43.850 --> 10:46.250
它告诉你有语法错误

10:46.650 --> 10:49.010
为什么它会判定有语法错误呢

10:49.010 --> 10:51.650
是因为箭头寒树在书写的时候

10:52.490 --> 10:54.810
如果说只有一个参数的情况下

10:55.330 --> 10:55.850
那么

10:56.810 --> 10:58.730
它是可以不用写这两个小货号的

10:58.730 --> 11:00.570
比方说我们写这么一个箭头寒树

11:00.970 --> 11:01.930
它是合法的

11:01.930 --> 11:03.490
因为它的参数名字是A

11:04.050 --> 11:06.410
但是如果说利用这种方式来写的话

11:06.410 --> 11:07.570
它会误认为

11:07.570 --> 11:10.530
前面这一坨是那个参数名字

11:10.970 --> 11:11.650
懂了意思吧

11:11.650 --> 11:15.130
但是这个参数名字又不是合法的名字

11:15.130 --> 11:17.050
它就会给你报一个语法错误

11:17.050 --> 11:20.210
它说一个错误的箭头寒树参数列表

11:20.690 --> 11:22.490
所以说它会分析

11:22.770 --> 11:24.290
语法分析上会有错误

11:24.290 --> 11:25.810
这是其中一个例子

11:25.810 --> 11:27.330
还有一种情况

11:27.330 --> 11:29.650
就是我们写寒树表达式

11:29.650 --> 11:31.850
你们将来会学习一个东西

11:31.850 --> 11:33.890
叫做generator vaccine

11:33.890 --> 11:35.010
你们现在还没有学习

11:35.010 --> 11:36.010
将来会学习

11:36.010 --> 11:37.810
叫做生成器寒树

11:37.810 --> 11:38.610
它的

11:39.050 --> 11:40.930
如果说用寒树表达式的写法

11:40.930 --> 11:41.930
它是这样子写的

11:42.450 --> 11:43.610
比方说一个寒树

11:43.610 --> 11:48.010
它写出少量的参数列表

11:49.010 --> 11:50.170
这里就是加一个新号

11:50.170 --> 11:51.410
你现在不知道什么意思

11:51.410 --> 11:51.810
没关系

11:51.810 --> 11:53.010
以后你会知道

11:53.530 --> 11:56.410
但是这种写法是不能使用一箭头寒树的

11:56.410 --> 11:57.450
也就是箭头寒树的

11:57.450 --> 12:00.770
它是没有生成器的那种寒树书写方式的

12:01.250 --> 12:02.090
你这样子写的话

12:02.090 --> 12:02.970
还会保护

12:03.490 --> 12:04.330
懂得意思吧

12:04.330 --> 12:06.730
就是这两种特殊情况

12:06.730 --> 12:08.930
就是一些特殊的符号

12:08.930 --> 12:12.290
作用于一个普通的寒树表达式

12:12.290 --> 12:14.610
但是可能箭头寒树就不行了

12:14.610 --> 12:16.890
但其他的绝大部分情况下

12:16.890 --> 12:18.490
都是可以替代的

12:18.490 --> 12:19.970
我给大家做这个说明

12:20.650 --> 12:23.010
下一个生于参数

12:24.530 --> 12:25.530
这个生于参数

12:25.530 --> 12:27.890
它的做法是用来替代Oguments

12:27.890 --> 12:28.610
就是原来说

12:28.610 --> 12:30.330
Oguments我以后能不能用了

12:30.330 --> 12:31.250
你能用

12:31.250 --> 12:34.410
但是它推荐你不要再使用Oguments了

12:34.410 --> 12:38.650
以后使用生于参数来代替

12:38.650 --> 12:39.730
比方说我举个例子

12:39.730 --> 12:41.290
比方说你要做一个球盒

12:42.290 --> 12:44.090
你要写个球盒的寒树

12:44.090 --> 12:46.850
这个球盒的寒树里面写个1

12:49.610 --> 12:51.210
我要有这么一个用法

12:51.210 --> 12:52.810
就是我要对这样子写

12:52.810 --> 12:53.890
我对1球盒

12:54.930 --> 12:56.610
对1和2球盒

12:57.170 --> 12:58.410
对2

12:58.410 --> 12:59.210
3

12:59.210 --> 12:59.890
4

12:59.890 --> 13:00.610
都可以球盒

13:00.610 --> 13:02.570
就是它的参数数量是不一定的

13:03.370 --> 13:04.930
因为参数数量不一定

13:04.930 --> 13:06.370
那应该可以传个数组

13:06.370 --> 13:07.090
那可以

13:07.090 --> 13:09.090
如果说你要把参数作为数组的话

13:09.090 --> 13:11.610
它的使用方式是这样子的

13:11.610 --> 13:12.890
你每一次要加个

13:13.610 --> 13:15.450
把它变成数组传进去

13:15.450 --> 13:16.450
但是如果说你希望

13:16.450 --> 13:19.010
通过这个参数列表的形式传进去的话

13:20.090 --> 13:21.450
那就不好办了

13:21.450 --> 13:22.690
那以前的怎么做呢

13:22.690 --> 13:25.050
以前是不是要利用到这个Oguments

13:25.130 --> 13:26.570
我们要循环Oguments

13:26.570 --> 13:28.930
然后一个一个把它数量哪家起来

13:28.930 --> 13:29.410
对吧

13:29.410 --> 13:30.170
以前的这么做

13:31.210 --> 13:32.610
ES6出现之后

13:32.610 --> 13:34.570
它提供了一个叫做圣语参数

13:34.570 --> 13:35.210
它就说

13:36.330 --> 13:38.690
Oguments最好不要使用了

13:38.690 --> 13:39.690
你用也可以

13:39.690 --> 13:43.050
但是我给你提供一个更加优质的方式

13:43.050 --> 13:44.410
就是圣语参数

13:45.090 --> 13:47.250
因为Oguments这个东西

13:47.250 --> 13:49.930
它是无法通过这个函数定义看出来的

13:49.930 --> 13:51.850
比方说我这里边使用Oguments

13:51.850 --> 13:53.650
我在看这个函数定义的时候

13:53.690 --> 13:56.610
我能看出它里边需要几个参数吗

13:56.610 --> 13:57.330
你看不出来

13:58.570 --> 14:01.130
它只能看这个函数实现才看得出来

14:01.130 --> 14:03.650
所以说它建议你不要使用Oguments

14:03.650 --> 14:05.730
应该使用函数的参数声明

14:05.730 --> 14:06.610
怎么声明呢

14:06.610 --> 14:08.530
你可以这样子写三个点

14:08.530 --> 14:10.010
有点像那个解构

14:10.010 --> 14:11.090
但是它不至解构

14:11.090 --> 14:12.570
它叫做圣语参数

14:12.570 --> 14:13.850
它起到一个什么作用

14:13.850 --> 14:16.370
起到一个收集参数的作用

14:16.370 --> 14:18.530
比方说像这种方式在调用

14:18.530 --> 14:22.570
它相当于是把E传递给了Oguments

14:22.610 --> 14:25.130
Oguments里边的东西变成了一个数组

14:26.410 --> 14:29.010
这个东西相当于是Oguments是一个数组

14:29.010 --> 14:29.690
1和2

14:30.530 --> 14:32.290
这里相当于是Oguments是一个数组

14:32.290 --> 14:33.050
2、3、4

14:33.690 --> 14:34.330
原来的意思吧

14:35.010 --> 14:37.610
它就相当于是一个收集参数的作用

14:38.290 --> 14:40.370
把收集的东西全部收集起来

14:40.370 --> 14:41.530
形成一个数组

14:41.530 --> 14:44.410
所以说这边我要求合怎么办

14:44.410 --> 14:45.570
那很简单吧

14:45.570 --> 14:48.690
Oguments我们可以使用之前的Reduce

14:48.690 --> 14:49.650
它是个数组吗

14:49.690 --> 14:51.250
当里也可以用forOguments循环

14:51.250 --> 14:52.570
循环它去求合都可以

14:53.690 --> 14:55.610
这里把我们可以使用箭头函数了

14:55.610 --> 14:58.290
之前我们写的是A、B

14:58.970 --> 15:00.290
然后了A加B

15:02.330 --> 15:02.890
你看懂吗

15:03.730 --> 15:04.210
Reduce

15:05.610 --> 15:06.970
这里有传一个箭头函数进去

15:06.970 --> 15:08.490
传的箭头函数看不懂的话

15:08.490 --> 15:09.570
你先把它写成这样子

15:10.530 --> 15:13.170
箭头函数如果说离一开始写的不习惯

15:14.250 --> 15:16.170
那么你可以先把它写成普通函数

15:25.290 --> 15:26.490
把它写成普通函数

15:27.690 --> 15:29.490
你可以先把它写成普通函数

15:29.490 --> 15:31.610
然后再把它写成箭头函数

15:31.610 --> 15:33.490
做法就是方可行去掉

15:33.490 --> 15:34.890
这里变成一个箭头

15:35.610 --> 15:37.890
发现它这里只有一条return预计

15:37.890 --> 15:41.650
所以说我这边可以手绿整个大光

15:43.130 --> 15:44.050
咱们来看一下

15:44.450 --> 15:44.930
你行

15:45.170 --> 15:45.610
是吧

15:45.810 --> 15:47.290
相加都没问题了

15:47.970 --> 15:49.730
这就是圣语参数

15:49.730 --> 15:51.810
它用来收集其他的参数的

15:51.810 --> 15:52.890
那么这里有些例子

15:53.010 --> 15:53.890
比方说我这里

15:54.890 --> 15:56.610
这个函数写了三个参数

15:56.610 --> 15:57.410
a和b

15:57.650 --> 15:59.530
然后圣语的参数

15:59.530 --> 16:01.050
它就收集到这个数组里面

16:01.650 --> 16:02.570
然后这里输出

16:02.570 --> 16:04.050
比方说我用这种的方式调用

16:04.050 --> 16:05.490
1传递给谁

16:05.490 --> 16:06.210
传递给a

16:11.010 --> 16:12.210
1传递给a

16:12.410 --> 16:14.010
然后2传递给b

16:14.410 --> 16:18.890
剩下的这些34567一起作为数组传递给

16:19.050 --> 16:19.690
包围名字

16:20.250 --> 16:21.210
提到这么一个作用

16:21.250 --> 16:22.530
所以它这里输出12

16:22.530 --> 16:23.330
后面是个数组

16:25.250 --> 16:26.050
然后这边

16:26.050 --> 16:29.690
下面1传递给a

16:31.010 --> 16:32.290
2传递给b

16:32.570 --> 16:33.690
然后剩下的没有

16:33.690 --> 16:35.330
它就是一个空数组

16:35.730 --> 16:36.690
它就是个空数组

16:37.770 --> 16:40.250
这就是圣语参数

16:41.770 --> 16:43.690
这东西都比较简单

16:43.690 --> 16:45.130
而且我再重生一次

16:45.450 --> 16:47.130
它没有带来新的功能

16:47.930 --> 16:48.850
以前那里说

16:48.850 --> 16:50.490
以前能不能用Ockerman出来做

16:50.490 --> 16:50.970
可以

16:51.930 --> 16:53.170
不是说一定要用它

16:53.610 --> 16:55.090
只是它出现之后

16:55.090 --> 16:57.250
官方建议你就不要使用Ockerman

16:57.250 --> 16:58.330
成那么Low的东西了

16:58.650 --> 16:59.610
建议是用它

16:59.810 --> 17:00.770
因为通过它

17:00.770 --> 17:02.410
就可以通过这个函数

17:02.410 --> 17:03.530
声明就可以看出

17:03.530 --> 17:04.850
原来你需要这么

17:05.290 --> 17:06.890
你的参数格式是这样子的

17:06.890 --> 17:07.570
第一个

17:07.570 --> 17:08.170
第二个

17:08.170 --> 17:09.090
后面就是

17:09.650 --> 17:11.850
所谓的列表都会收集成一个数组

17:12.010 --> 17:13.690
那么后面可以传无限多

17:14.090 --> 17:14.330
对吧

17:14.330 --> 17:15.130
它是这么个意思

17:15.610 --> 17:17.530
其实我们在开发的过程中

17:17.930 --> 17:19.770
有的时候也会看到

17:19.850 --> 17:21.650
既也是原生的一些函数

17:21.650 --> 17:24.090
它也是使用了这个圣语参数

17:24.090 --> 17:24.770
比方说

17:25.530 --> 17:26.650
这个Mass

17:28.170 --> 17:28.770
Mass

17:29.450 --> 17:32.170
求一系列值当中的最大值

17:32.370 --> 17:33.290
比方说不要传一个

17:33.290 --> 17:34.130
12356

17:34.130 --> 17:35.250
随便传一个

17:35.690 --> 17:38.410
它求这一系列值当中的最大值

17:38.530 --> 17:39.970
得到一个结果

17:42.540 --> 17:43.380
那里看一下

17:44.260 --> 17:44.980
这一块

17:44.980 --> 17:46.900
它是不是参数数量是不固定的

17:48.260 --> 17:50.220
以前只能用Ockerman来做

17:50.220 --> 17:51.100
现在可以用什么

17:51.140 --> 17:51.900
圣语参数

17:53.340 --> 17:53.980
你看

17:53.980 --> 17:55.980
这个参数数量是可以不固定的

17:56.820 --> 17:57.300
对吧

17:57.300 --> 17:58.700
这就是圣语参数

18:00.620 --> 18:02.220
下一个参数默认值

18:02.220 --> 18:03.740
这个玩意就比较简单了

18:04.100 --> 18:05.060
就是说有的时候

18:05.060 --> 18:06.100
我们调用一个函数

18:06.620 --> 18:07.820
它有的时候有些参数

18:07.820 --> 18:08.940
我可以不传递

18:09.060 --> 18:09.940
不传递的时候

18:09.940 --> 18:11.660
它会自动的使用默认值

18:12.780 --> 18:14.140
比方说像这个函数

18:14.260 --> 18:16.020
里面有两个参数A和B

18:16.100 --> 18:17.660
B我有一个特殊的语法

18:17.660 --> 18:18.780
给它写个等于1

18:18.780 --> 18:19.420
啥意思

18:19.540 --> 18:21.660
就是说如果说你没有传递B

18:22.300 --> 18:24.180
或者是你传递一个ond犯

18:25.180 --> 18:26.940
那么它就得到了值就是1

18:27.740 --> 18:27.940
好

18:27.940 --> 18:29.340
咱们试一下比方Message的

18:29.740 --> 18:31.180
1,2传递进去

18:31.620 --> 18:32.460
都传递了

18:32.460 --> 18:34.380
那么就用它里面的A和B

18:34.380 --> 18:35.220
就是1和2

18:35.860 --> 18:37.420
如果说你只传递了一个1

18:37.420 --> 18:38.300
那B没有传递

18:38.300 --> 18:38.500
对吧

18:38.500 --> 18:39.980
没有传递就使用默认值

18:39.980 --> 18:40.820
那B就是1

18:40.820 --> 18:41.940
所以输出1和1

18:42.780 --> 18:43.780
那你传递一个1

18:43.780 --> 18:45.660
后面第二个传递到一个ond犯的

18:46.100 --> 18:48.420
传递ond犯就相当于是没传递

18:48.500 --> 18:49.860
那得到了还是默认值

18:50.860 --> 18:51.340
对吧

18:51.340 --> 18:52.900
就是参数默认值

18:54.580 --> 18:55.380
下面还有个例子

18:55.380 --> 18:56.380
我用了一个箭头函数

18:56.380 --> 18:57.500
箭头函数

18:57.860 --> 18:59.220
它也可以使用参数默认值

18:59.220 --> 18:59.740
都一样

19:00.860 --> 19:01.860
不要到这里面设得

19:02.180 --> 19:04.140
我有4个参数A

19:04.340 --> 19:05.180
B有默认值

19:05.180 --> 19:06.100
C有默认值

19:06.100 --> 19:07.060
D没有默认值

19:07.700 --> 19:08.660
输出A,B,C,D

19:08.660 --> 19:08.860
好

19:08.860 --> 19:09.700
咱们试一下

19:09.700 --> 19:11.220
传递一个1和2

19:11.580 --> 19:12.380
那你看一下

19:12.380 --> 19:13.820
1是不是传递给了A

19:13.820 --> 19:14.860
那么A就是1

19:15.180 --> 19:16.540
2是不是传递给了B

19:16.540 --> 19:17.420
有值吗

19:17.660 --> 19:18.580
B就是2

19:19.020 --> 19:19.980
C没有传递

19:19.980 --> 19:21.220
那么使用默认值2

19:21.220 --> 19:22.060
D没有传递

19:22.060 --> 19:22.780
没有默认值

19:22.780 --> 19:23.300
ond犯

19:23.300 --> 19:24.620
所以说输出1,2

19:25.620 --> 19:26.020
2

19:26.460 --> 19:27.060
ond犯

19:27.260 --> 19:28.260
自己体会一下

19:28.580 --> 19:29.900
只传递到第一个参数

19:29.900 --> 19:32.260
那么后边B和C使用默认值D

19:32.260 --> 19:33.020
ond犯

19:33.300 --> 19:34.100
那么就是1

19:34.260 --> 19:34.820
12

19:34.820 --> 19:35.500
ond犯

19:36.100 --> 19:37.180
传递到第一个参数

19:37.180 --> 19:39.380
第二个和第三个使用ond犯的

19:39.580 --> 19:40.220
那么就是

19:40.220 --> 19:42.020
那告诉他们直接使用默认值

19:42.180 --> 19:43.740
然后第四个参数使用4

19:43.980 --> 19:44.900
那么就124

19:44.900 --> 19:45.700
把自己看一下

19:45.700 --> 19:46.420
对到看一下

19:46.580 --> 19:47.500
非常简单的

19:47.820 --> 19:49.140
这些东西都不复杂

19:49.700 --> 19:50.740
就是有点多

19:51.260 --> 19:52.220
还是那句话

19:52.380 --> 19:53.820
你以后开发的时候

19:53.820 --> 19:54.740
不要老想着

19:54.740 --> 19:56.580
我一定要把这个ES6的东西

19:56.580 --> 19:57.580
一定要用上

19:58.140 --> 20:00.180
不要这样子强迫自己

20:00.340 --> 20:01.660
强确的刮铺

20:01.660 --> 20:02.660
这是一个

20:03.820 --> 20:05.180
循序监禁的过程

20:05.180 --> 20:06.980
那感情也是慢慢培养的

20:06.980 --> 20:07.580
对不对

20:08.100 --> 20:09.180
有一天你觉得

20:09.180 --> 20:10.620
普通的寒暑写的烦了

20:10.740 --> 20:11.740
你突然觉得

20:12.060 --> 20:13.460
要不要我试一下建筑寒暑

20:13.460 --> 20:14.980
也试着试着你就适应了

20:15.420 --> 20:17.220
而且像咱们以后的开发中

20:17.380 --> 20:18.900
去做一些练习的时候

20:19.460 --> 20:20.300
不轻易的

20:20.300 --> 20:21.180
我不轻易的

20:21.180 --> 20:22.940
就会使用到一些ES6的东西

20:22.940 --> 20:23.860
你慢慢看了多了

20:23.860 --> 20:24.860
你自己也就会了

20:25.020 --> 20:25.820
所以说我们这里

20:26.020 --> 20:27.100
就是我们这个阶段

20:27.100 --> 20:28.980
就是快速的把这些东西过一下

20:28.980 --> 20:29.780
做一些练习

20:29.780 --> 20:30.780
有那么一个印象

20:30.860 --> 20:32.060
忘记了都没关系

20:32.180 --> 20:33.940
后面我们再做其他的项目

20:34.460 --> 20:35.420
写一些代码的时候

20:35.420 --> 20:36.780
用到了ES6的地方

20:36.900 --> 20:37.900
那么你再去

20:38.380 --> 20:39.940
把这个地方敲一下

20:39.940 --> 20:41.420
慢慢的去适应这些语法

20:42.940 --> 20:44.340
下一个内语法

20:44.500 --> 20:45.420
这个玩意

20:45.420 --> 20:46.740
我们以后你要说

20:46.740 --> 20:47.900
你的开发当中

20:47.900 --> 20:49.100
用到很多的话

20:49.100 --> 20:50.300
到谈不上

20:50.300 --> 20:52.100
因为你们以后用框架做开发

20:52.100 --> 20:53.020
这一块

20:53.500 --> 20:54.740
可能用的不是很多

20:54.740 --> 20:55.900
除非你使用reacts

20:55.900 --> 20:56.580
reacts的话

20:56.580 --> 20:57.260
可能要多一点

20:58.500 --> 20:59.340
使用无诱的话

20:59.340 --> 21:00.740
这一块内语法用的倒是不多

21:00.740 --> 21:02.500
但是我们还是要作为一个了解

21:03.180 --> 21:03.420
好

21:03.420 --> 21:04.580
内语法我们看一下

21:06.690 --> 21:08.570
它主要的未来解决什么问题呢

21:08.930 --> 21:10.130
就我们以前

21:10.970 --> 21:13.090
所以有个构造函数的写法

21:13.450 --> 21:14.050
对吧

21:14.130 --> 21:15.530
我们通常命名上了

21:15.530 --> 21:17.650
我们会把构造函数的手字母大写

21:17.970 --> 21:19.010
这是个构造函数

21:19.010 --> 21:20.610
然后我可以直接调用它

21:20.610 --> 21:22.290
也可以通过6的方式

21:22.410 --> 21:23.570
创建一个对架

21:24.250 --> 21:26.490
实际上以前的任何一个函数都可以

21:27.010 --> 21:28.610
不是说必须要大写

21:28.730 --> 21:29.850
任何一个函数

21:29.850 --> 21:31.410
它都可以用这种方式调用

21:31.410 --> 21:32.890
也可以用这种方式调用

21:33.850 --> 21:35.610
只是我们命名过一番上的

21:35.850 --> 21:36.930
把它手字母大写

21:37.770 --> 21:39.650
所以说以前它出现一个问题

21:39.650 --> 21:41.210
就是构造函数和普通函数

21:41.210 --> 21:42.290
没有做区分的

21:42.650 --> 21:43.610
任何函数

21:43.810 --> 21:44.770
它既可以当做

21:44.850 --> 21:45.970
构造函数来使用

21:46.210 --> 21:48.450
又可以当做普通函数来使用

21:49.450 --> 21:51.170
于是呢ES-6呢

21:51.170 --> 21:53.090
他给我们提供了一种新的语法

21:53.090 --> 21:54.130
就是内语语法

21:54.370 --> 21:57.050
他就把构造函数和普通函数做了的区分

21:57.050 --> 21:58.050
他建议啊

21:58.050 --> 21:59.850
以后你要写构造函数

21:59.850 --> 22:01.730
你就用使用内语语法来写

22:01.850 --> 22:03.410
不要使用普通函数来写

22:03.530 --> 22:04.930
但本质上是一样的

22:05.370 --> 22:05.530
好

22:05.530 --> 22:06.490
咱们来试一下

22:07.010 --> 22:07.370
看一下

22:07.370 --> 22:08.650
看一下一个例子就行了

22:12.760 --> 22:13.440
不要说

22:13.760 --> 22:15.040
这里我写了个构造函数

22:15.040 --> 22:16.000
旧的写法

22:16.200 --> 22:17.880
是不是我们要写个函数

22:17.920 --> 22:18.840
然后有两个参数

22:18.840 --> 22:20.360
发生那么大声的两个名字

22:20.960 --> 22:21.720
我给他复制了

22:21.720 --> 22:22.440
给这次复制

22:22.440 --> 22:23.680
然后给他一个附货链

22:24.240 --> 22:26.200
拼接成一个完整的名字

22:27.200 --> 22:29.160
我可以给他加上两个

22:29.320 --> 22:30.200
加上一个方法

22:30.200 --> 22:31.520
这个叫做静态方法

22:31.680 --> 22:32.280
知道吧

22:32.720 --> 22:34.240
这个玩意叫静态方法

22:35.520 --> 22:36.600
怎么叫静态方法

22:36.800 --> 22:37.880
就是这个方法啊

22:37.880 --> 22:39.240
它附着的位置

22:39.240 --> 22:41.200
是在这个函数本身上的

22:41.800 --> 22:42.840
叫静态方法

22:43.080 --> 22:44.520
那么调的时候怎么调用了

22:44.520 --> 22:45.760
调用的时候就要这样调用

22:46.200 --> 22:46.960
优势

22:47.160 --> 22:47.920
意思优势

22:47.920 --> 22:49.040
要这样的方式来调用

22:49.040 --> 22:50.080
就要静态方法

22:50.280 --> 22:52.440
直接通过这个构造函数本身去调用的

22:53.720 --> 22:55.160
那么这里边代码无所谓

22:55.160 --> 22:56.480
代码写什么无所谓

22:56.640 --> 22:57.440
反正就是

22:57.560 --> 22:59.520
这是他语法静态方法

22:59.640 --> 23:00.960
然后设置为一个函数

23:01.680 --> 23:01.960
好

23:01.960 --> 23:02.760
另外呢

23:02.760 --> 23:04.480
还有一个叫做圆形方法

23:05.840 --> 23:07.640
他放他放到圆形上的

23:07.880 --> 23:09.480
那么这样的方法怎么来调用呢

23:09.480 --> 23:10.720
我们到时候要这样调用

23:11.160 --> 23:12.960
要创建一个优势

23:13.960 --> 23:15.360
传一些参数进去

23:15.640 --> 23:17.600
然后呢通过u点c hello

23:17.600 --> 23:18.960
通过这种方式来调用

23:18.960 --> 23:21.480
所以说这种方法叫做圆形方法

23:21.480 --> 23:23.000
也叫做实力方法

23:25.180 --> 23:25.860
实力

23:27.660 --> 23:28.580
什么叫实力

23:29.060 --> 23:31.100
就是一个构造函数的对象

23:31.860 --> 23:32.740
比较多这个

23:34.020 --> 23:36.620
这个玩意儿就是优者的一个实力

23:36.780 --> 23:39.340
那你看一个优者是不是可以产生很多个实力

23:40.100 --> 23:42.420
一个优者可以产生无数个实力

23:42.420 --> 23:42.900
对吧

23:43.180 --> 23:46.140
那么他必须要通过某一个实力去调用

23:46.180 --> 23:47.220
这叫实力方法

23:49.140 --> 23:50.620
这是个基本常识

23:50.820 --> 23:52.220
如果你之前不知道的话

23:52.220 --> 23:53.260
现在知道一下就行了

23:54.100 --> 23:55.380
因为这一块代码呢

23:55.820 --> 23:57.380
他其实涉及到面向对象

23:58.540 --> 24:00.740
而作为前端开发的面向对象

24:01.940 --> 24:04.260
你干脆工作了几年之后吧

24:04.260 --> 24:05.660
你再来慢慢去了解吧

24:05.820 --> 24:07.420
那个玩意儿东西太多了

24:07.740 --> 24:09.860
所以说现在呢就作为一个了解就行了

24:10.700 --> 24:11.580
你平时开发的话

24:11.580 --> 24:13.820
你也不会去想到去使用这种方式的

24:13.980 --> 24:14.900
很难想得到的

24:15.380 --> 24:17.100
我们就看一下那个语法的变化

24:17.340 --> 24:19.460
就是以前的可以是这样子写的对吧

24:19.460 --> 24:20.220
那么现在呢

24:20.220 --> 24:21.020
ES6之后呢

24:21.020 --> 24:22.140
他建议你这样子写

24:22.940 --> 24:24.980
我效果是完全一样的

24:25.460 --> 24:26.580
就是写法的变了

24:26.900 --> 24:27.460
你看

24:27.700 --> 24:30.060
使用关键字class表示一个内

24:30.220 --> 24:32.700
那么这就相当于是跟那个加瓦呀

24:32.820 --> 24:35.060
C-Sharp呀是一个意思了

24:36.220 --> 24:37.700
这是构造函数的名字

24:38.260 --> 24:40.740
然后通过一个特殊的名字要constructor

24:42.060 --> 24:43.740
来表示他的构造器

24:44.900 --> 24:45.940
表示他的构造器

24:45.940 --> 24:46.940
你看是不是一样的

24:48.140 --> 24:51.500
通过关键字static表示静态方法

24:52.860 --> 24:53.980
你看是不是一样的

24:54.260 --> 24:55.940
里边具体写啥无所谓

24:57.060 --> 24:59.300
然后呢通过直接写这个方法名字

24:59.300 --> 25:00.820
表示他的实力方法

25:01.500 --> 25:01.980
对吧

25:01.980 --> 25:03.020
而且从写法上看

25:03.020 --> 25:04.620
下面那个写法肯定要舒服一些

25:04.740 --> 25:05.780
因为上面那个写法呢

25:05.780 --> 25:08.140
他们这三条语句本来都是一样的

25:08.940 --> 25:11.700
都是都是代表着代表着是一块功能

25:11.700 --> 25:11.900
对吧

25:11.900 --> 25:13.260
他只是把它分开写了

25:13.740 --> 25:15.820
而下面的写法是不是更加整体一些

25:16.180 --> 25:17.660
都是放了那个有点里面的

25:18.380 --> 25:19.420
效果是一样的

25:19.420 --> 25:20.340
就是写法变的

25:21.220 --> 25:22.420
比方说还有继承

25:22.420 --> 25:23.860
继承以前是很麻烦的

25:24.220 --> 25:26.060
我这里用了一个比较简单的方式

25:26.380 --> 25:28.820
实际上要使用一个深北模式来继承的话

25:28.820 --> 25:29.660
是比较麻烦的

25:29.900 --> 25:31.660
下面的代码你可以自己去看一下

25:31.900 --> 25:32.860
那么新的方式呢

25:32.860 --> 25:34.180
其实继承非常简单

25:34.620 --> 25:36.380
继承无非就是两个构造函数嘛

25:36.860 --> 25:37.900
这只构造函数

25:37.900 --> 25:39.100
复构造函数对不对

25:39.340 --> 25:40.580
那么新的写方呢

25:40.580 --> 25:42.580
就是写个复构造函数叫复内

25:44.140 --> 25:44.620
然后呢

25:44.620 --> 25:47.060
纸内去继承复内

25:47.380 --> 25:47.900
完了

25:49.020 --> 25:50.980
然后你可以自行去对比一下

25:51.260 --> 25:51.980
自行去对比

25:51.980 --> 25:53.500
我这里的就不再展开说了

25:53.940 --> 25:54.140
好

25:54.140 --> 25:54.900
这是内与法

25:55.340 --> 25:55.740
最后呢

25:55.740 --> 25:57.500
我们来看一下这个函数的API

25:59.740 --> 26:02.740
每一个函数它都会包含这么三个方法

26:02.740 --> 26:03.420
一个score

26:04.220 --> 26:05.020
不解释了吧

26:05.540 --> 26:07.260
绑定第一个参数为ZS

26:07.860 --> 26:08.620
后边呢

26:09.300 --> 26:10.660
你可以写任意多的参数

26:10.660 --> 26:13.060
表示我调用的时候要上这个函数

26:13.060 --> 26:14.180
传递哪些参数

26:14.700 --> 26:15.540
而Ply呢

26:16.300 --> 26:17.540
要不然我还是说一下

26:19.140 --> 26:20.460
比方说我们这里

26:21.820 --> 26:22.700
用个啥呢

26:23.460 --> 26:24.740
我们就用一个数组吧

26:26.300 --> 26:27.340
数组里边不是

26:27.460 --> 26:28.860
元凶里边不是一个方法吗

26:28.860 --> 26:30.260
叫Snice对吧

26:30.340 --> 26:31.660
来切割数组的

26:35.490 --> 26:35.930
这里呢

26:35.930 --> 26:37.410
我们写个数组吧

26:39.170 --> 26:40.570
一二三四

26:41.610 --> 26:42.290
长度为5

26:42.770 --> 26:44.290
我想把这个数组进行切割

26:44.290 --> 26:45.730
当然我有很多那种调用方式

26:45.730 --> 26:47.050
我可以用这种方式来调用

26:47.050 --> 26:47.730
比较常见的

26:47.730 --> 26:48.330
Snice

26:50.250 --> 26:51.610
从哪个位置开始切割

26:51.610 --> 26:52.970
从第一个位置开始切割

26:53.690 --> 26:54.410
取几个呢

26:54.410 --> 26:55.130
取三个

26:55.690 --> 26:57.210
那么得到会得到一个新的数数

26:58.890 --> 27:00.090
输出一下新的数数

27:01.650 --> 27:02.330
好 咱们看一下

27:03.250 --> 27:03.930
就得到二

27:04.770 --> 27:05.570
不是第三个

27:05.570 --> 27:07.170
就是到下标三

27:07.170 --> 27:08.690
从下标一到加标三

27:08.690 --> 27:09.650
下标一

27:09.770 --> 27:10.570
二三

27:10.570 --> 27:11.570
第三取不到对吧

27:11.570 --> 27:12.410
得到二三

27:12.770 --> 27:14.130
所以切割成这么一部分

27:14.130 --> 27:15.130
得到一个新数据

27:15.770 --> 27:17.010
好 我们也可以呢

27:17.010 --> 27:18.610
使用call的方式来调用

27:18.610 --> 27:20.450
比方说我们通过这个snice

27:20.450 --> 27:21.890
snice是在数组元凶里边

27:21.890 --> 27:22.450
对吧

27:22.450 --> 27:23.050
那因此呢

27:23.050 --> 27:25.130
我们可以通过这个数组元凶里边的snice

27:25.970 --> 27:26.770
使用call

27:27.770 --> 27:29.370
第一个传递Z的绑定

27:29.370 --> 27:30.370
绑定哪个Z呢

27:30.370 --> 27:31.770
绑定这个数组为Z

27:32.970 --> 27:33.490
然后呢

27:33.490 --> 27:34.690
后面是传输列表

27:34.690 --> 27:35.650
我就传一三

27:35.650 --> 27:37.250
就把这个传输列表传进去

27:37.610 --> 27:37.850
好

27:37.850 --> 27:38.450
那么这样子呢

27:38.450 --> 27:39.650
也可以得到一个新数据

27:39.650 --> 27:40.290
哎哟哟哟哟

27:40.290 --> 27:41.370
这个玩意有啥用吗

27:41.370 --> 27:42.690
我直接用上面方式多好啊

27:42.690 --> 27:43.770
是

27:43.770 --> 27:46.250
99%的情况下你都不会用这种方式

27:46.250 --> 27:47.090
但是你要知道

27:48.090 --> 27:49.770
在某些特殊场景下可能会失用

27:51.570 --> 27:53.050
所以得到一样的

27:53.050 --> 27:53.210
好

27:53.210 --> 27:53.610
另外呢

27:53.610 --> 27:54.570
还有一个东西叫做

27:55.370 --> 27:55.850
apply

27:58.350 --> 28:00.590
那么这他的区别跟那个call的区别

28:00.590 --> 28:01.910
唯一的区别就在于

28:01.910 --> 28:03.070
他后面的传输列表了

28:03.070 --> 28:04.870
必须要做一个数组来进行传递

28:07.230 --> 28:07.950
效果是一样的

28:09.350 --> 28:09.590
好

28:09.590 --> 28:10.550
es6之后呢

28:10.550 --> 28:12.390
好给你加了一个方法叫band

28:13.190 --> 28:14.310
绑定z

28:14.870 --> 28:16.390
那么他的用法呢跟call一样

28:17.350 --> 28:18.310
啊跟call一样

28:18.670 --> 28:19.190
只不过呢

28:19.190 --> 28:20.710
他返回的是一个函数

28:22.310 --> 28:23.110
可以补偿函数

28:24.070 --> 28:25.070
绑定z之后

28:25.070 --> 28:26.590
他返回的不是一个新的数组

28:26.910 --> 28:28.150
返回的是一个函数

28:28.670 --> 28:29.910
他只是绑定z

28:30.270 --> 28:31.470
那么这个新的函数比较多

28:31.470 --> 28:32.750
我们就名字叫做snice

28:33.470 --> 28:34.150
好ok

28:34.150 --> 28:35.990
那么这里返回这个函数呢

28:35.990 --> 28:39.990
他的z是永远指向之前绑定的z

28:40.910 --> 28:41.670
绑定的l

28:41.670 --> 28:43.150
随说我们这里直接可以使用

28:43.390 --> 28:43.750
1

28:44.430 --> 28:44.790
3

28:45.150 --> 28:46.070
做到一个新数组

28:48.810 --> 28:50.730
这是es6给我们带来的一些变化

28:51.010 --> 28:53.690
那么这个玩意以后再学习react的时候

28:53.930 --> 28:54.730
可能会有点用

28:55.050 --> 28:56.490
现在呢给你们讲的这些

28:56.890 --> 28:57.690
你们也记不住

28:57.690 --> 28:59.610
就很了解一下就行了

28:59.610 --> 29:00.810
因为这个关系上你们

29:02.170 --> 29:03.010
可能

29:03.770 --> 29:06.210
几个月之内都不会用到这些东西

29:07.170 --> 29:07.410
好

29:07.410 --> 29:10.210
这是这个函数的一些更新

29:10.450 --> 29:12.250
对于我们平时开发

29:13.490 --> 29:15.450
用的比较多的也就是箭头函数

29:16.210 --> 29:16.890
生于函数

29:16.890 --> 29:18.210
函数默认值对你们来说

29:18.210 --> 29:19.290
可能都用的少一些

29:19.530 --> 29:20.810
就是箭头函数用的最多

29:21.530 --> 29:21.690
好

29:21.690 --> 29:23.530
咱们来做一下这一本的一些电影题

29:23.530 --> 29:23.770
啊

29:25.330 --> 29:25.450
好

29:25.450 --> 29:25.970
地道题

29:32.320 --> 29:35.000
让你写一个球合函数

29:35.640 --> 29:37.120
要用箭头函数的语法

29:38.160 --> 29:40.440
那么下面如何来去调用那个函数给你写好了

29:41.120 --> 29:43.800
你只需要把那个函数定义好就行了

29:43.800 --> 29:45.000
在这里去写定义

29:46.000 --> 29:46.200
好

29:46.200 --> 29:46.640
同学们

29:47.240 --> 29:48.000
自己写一下

29:48.400 --> 29:49.000
再评视频

29:50.960 --> 29:51.400
好了没

29:51.400 --> 29:51.680
好

29:51.680 --> 29:52.600
我给大家写一下啊

29:52.600 --> 29:54.280
其实我们都写过了对不对

29:54.280 --> 29:55.080
就是一个上

29:56.080 --> 29:56.920
那么箭头函数

29:57.760 --> 29:58.480
两个参数

29:59.160 --> 29:59.440
哎呦

29:59.440 --> 30:01.360
喂参数是不是不一定的

30:01.360 --> 30:02.320
还有可能是0个

30:02.320 --> 30:03.080
有可能是1个

30:03.080 --> 30:04.080
有可能是2个

30:04.080 --> 30:04.840
有可能是3个

30:04.840 --> 30:05.600
对吧

30:05.600 --> 30:06.080
那怎么办

30:07.040 --> 30:08.560
参数列表不固定

30:08.560 --> 30:10.760
我们可以使用生于参数来收集

30:12.240 --> 30:12.400
啊

30:12.400 --> 30:13.800
箭头函数也可以写生于的参数

30:14.760 --> 30:15.920
那我们这样子写吧

30:15.920 --> 30:17.520
我们先把箭头函数的格式写好

30:18.440 --> 30:18.840
对不对

30:19.520 --> 30:20.880
你开始写的不熟练的话

30:20.880 --> 30:22.080
可以先把这个东西写好

30:22.080 --> 30:23.120
然后参数写到这

30:24.360 --> 30:25.680
那么有几个参数不一定

30:25.680 --> 30:26.920
不一定的话就是生于参数

30:29.180 --> 30:31.340
0个那么这个数据是空的啊

30:31.340 --> 30:32.380
长度为0

30:32.380 --> 30:33.980
传入一个1数据长度为1

30:34.820 --> 30:36.700
传传入1号2长度为2

30:36.700 --> 30:37.980
传入123长度为3

30:39.380 --> 30:40.100
好那么接下来

30:40.100 --> 30:42.020
我这个箭头函数返回的是什么呢

30:42.020 --> 30:43.740
返回的不就是求和吗

30:43.740 --> 30:45.180
循环这个数据求和

30:46.060 --> 30:48.260
那如果说你实在不习惯这个

30:48.260 --> 30:49.540
维旧是这个写法

30:49.540 --> 30:51.580
那你完全可以用过去的写法呀

30:51.580 --> 30:52.420
缝而无循环

30:53.140 --> 30:53.980
循环这个数据

30:53.980 --> 30:55.340
这不就是个数据吗

30:55.340 --> 30:57.100
这个完全是个数据啊

30:57.100 --> 31:00.180
然后每一次循环去哪家

31:00.180 --> 31:00.700
可不可以呢

31:00.700 --> 31:02.300
当然可以啊

31:02.300 --> 31:04.260
不是说我再一次重生啊

31:04.260 --> 31:06.740
我们这个阶段讲了很多的新语法

31:06.740 --> 31:07.900
新的API

31:07.900 --> 31:11.460
不是说没有人任何人比你一定要用新的

31:12.380 --> 31:13.540
用救者叫出人命

31:13.540 --> 31:14.860
没有不会出人命的

31:14.860 --> 31:15.780
救者仍然可以用

31:15.780 --> 31:16.500
你这个返回

31:16.500 --> 31:17.700
那用来说我缝而无循环

31:17.700 --> 31:19.060
也用关单机用缝而无循环的

31:20.340 --> 31:20.940
那你用缝而无循

31:20.940 --> 31:21.940
你只要写得不

31:21.940 --> 31:22.980
你自己不想恶心

31:22.980 --> 31:23.940
那恶心的就是别人

31:23.940 --> 31:24.340
知道吧

31:29.570 --> 31:30.610
你只要自己不恶心

31:30.610 --> 31:31.410
他就恶心别人

31:32.330 --> 31:32.810
可以啊

31:32.810 --> 31:33.850
可以啊

31:33.850 --> 31:35.250
没问题啊

31:35.250 --> 31:36.530
但是你总有一天

31:36.530 --> 31:38.410
你会觉得恶心这个代表

31:38.410 --> 31:39.330
所以说总有一天呢

31:39.330 --> 31:42.290
你会觉得袁老师还是那个

31:42.290 --> 31:44.090
Reduce还是要爽一些

31:44.090 --> 31:45.530
因为一开始不习惯

31:45.530 --> 31:46.410
慢慢习惯了

31:46.410 --> 31:47.770
就对他有感情了

31:47.770 --> 31:50.210
所以说你慢慢就会写成这样的写法

31:50.210 --> 31:50.730
Reduce

31:52.170 --> 31:53.410
这边A

31:55.250 --> 31:56.490
以前是这样写的

31:56.490 --> 31:56.850
对吧

31:56.850 --> 31:57.930
A和D

31:57.930 --> 31:59.530
返回一个A加D

31:59.530 --> 32:01.690
然后这里默认之为你用

32:01.690 --> 32:02.610
以前这样的写

32:02.610 --> 32:04.170
现在有了箭头函数之后呢

32:04.170 --> 32:05.210
我这个地方

32:05.210 --> 32:07.050
就可以改成这个样子了

32:12.060 --> 32:14.060
就一句话就写完了就修合了

32:14.060 --> 32:15.740
而且像这个函数

32:15.740 --> 32:17.660
这个箭头函数本身

32:17.660 --> 32:19.700
它是不是只有一条返回语决

32:19.700 --> 32:20.460
那就这样写的

32:22.180 --> 32:23.740
一条就写完了

32:23.740 --> 32:24.740
慢慢就适应了

32:24.740 --> 32:25.900
一开始不适应

32:25.900 --> 32:27.900
其实这个读起来就非常好读

32:27.900 --> 32:30.420
就是你给我一系列参数

32:30.420 --> 32:32.180
我给你什么呢

32:32.180 --> 32:35.220
我给你把这些参数求和的结果

32:35.220 --> 32:36.780
箭头函数就是给我啥

32:36.780 --> 32:38.060
我给你啥

32:38.060 --> 32:39.300
就箭头函数

32:39.300 --> 32:40.700
好 咱们来试一下

32:40.700 --> 32:42.740
运行 你看什么都要0 136

32:45.220 --> 32:47.540
好 那么下面这个题

32:47.540 --> 32:49.220
这个题还有一个问题

32:49.220 --> 32:51.460
让你调用这个Sum函数

32:51.460 --> 32:54.900
将这个数组里面的所有数字求和

32:54.900 --> 32:56.780
这一会需要有点想象力

32:56.780 --> 32:58.860
看你怎么去调用

32:58.860 --> 33:01.100
要用到之前学到一些语法

33:01.100 --> 33:03.820
你们试着想想一些办法

33:03.820 --> 33:05.300
就是我要调用这个函数

33:05.300 --> 33:06.980
我要把这里面的所有数字

33:06.980 --> 33:07.940
一次传进去

33:07.940 --> 33:10.060
当然你不肯定不能传这个

33:10.060 --> 33:11.260
传这个相当于是什么

33:11.260 --> 33:13.300
相当于你传了一个数组

33:13.300 --> 33:14.340
你传了几个参数

33:14.340 --> 33:15.740
传了一个参数

33:15.740 --> 33:17.500
那么你如果说你这样调用的话

33:17.500 --> 33:19.100
这个argue是里面是什么

33:19.100 --> 33:20.100
它的格式是什么

33:20.100 --> 33:22.820
它只有一个参数

33:22.820 --> 33:24.260
这个参数是啥

33:24.260 --> 33:25.820
是一个数组

33:25.820 --> 33:27.860
argue的格式是这样子的

33:27.860 --> 33:28.900
它只有一个参数

33:28.900 --> 33:30.420
参数的格式是数组

33:30.420 --> 33:32.100
而我们希望它是什么格式

33:32.100 --> 33:34.660
是这种格式

33:34.660 --> 33:36.220
有六个参数

33:36.220 --> 33:37.260
对吧

33:37.260 --> 33:38.100
那就怎么办

33:42.660 --> 33:44.980
完了

33:44.980 --> 33:46.580
这个玩意

33:46.580 --> 33:48.020
这个地方的三个点

33:48.020 --> 33:50.100
它表示的是展开运算幅

33:50.100 --> 33:51.660
是不是我们之前学的

33:51.700 --> 33:53.140
相当于是把这个数组的内容

33:53.140 --> 33:55.940
全部展开一次放到这个位置

33:55.940 --> 33:56.780
原来的意思

33:56.780 --> 33:58.620
所以说这样子写就完事了

33:58.620 --> 34:00.380
这需要点想想理

34:00.380 --> 34:01.500
写不出来没关系

34:01.500 --> 34:02.860
如果说一开始不知道的话

34:02.860 --> 34:03.340
没关系

34:03.340 --> 34:05.260
这个很正常

34:05.260 --> 34:08.420
你看最后是不是得到21

34:08.420 --> 34:09.020
原来的意思

34:09.020 --> 34:10.820
相当于是把这里就展开了

34:10.820 --> 34:12.300
123456

34:12.300 --> 34:14.660
那是不是可以得到正确的结果

34:14.660 --> 34:16.820
这就是地道题

34:16.820 --> 34:17.940
把写一次

34:17.940 --> 34:20.420
把这个地方写一次

34:20.460 --> 34:21.660
第二题

34:21.660 --> 34:26.810
第二题是我们之前的学生那个数组

34:26.810 --> 34:27.570
你想做过的样题

34:27.570 --> 34:27.810
对吧

34:27.810 --> 34:29.930
我们练习了很多的数组API

34:29.930 --> 34:31.850
然后下面的功能

34:31.850 --> 34:34.010
让你使用箭头函数完成

34:34.010 --> 34:35.570
就是就练习一下

34:35.570 --> 34:38.450
我们之前学习的那些数组的API

34:38.450 --> 34:41.690
很多我们都是使用的是箭头函数

34:41.690 --> 34:43.410
百分之百

34:43.410 --> 34:44.810
当然你不使用箭头函数

34:44.810 --> 34:45.690
我们之前也做过

34:45.690 --> 34:51.500
完全是可以的

34:51.500 --> 34:52.300
好

34:52.300 --> 34:53.060
一个问题

34:53.060 --> 34:55.740
得到电话号码唯一结尾的学生

34:55.780 --> 34:57.060
其实都是做过的

34:57.060 --> 34:59.580
只是让你把它用箭头函数写一遍

34:59.580 --> 35:00.100
好

35:00.100 --> 35:00.700
咋写呢

35:02.180 --> 35:03.580
你们可以先尝试着做

35:03.580 --> 35:04.420
做不出来没关系

35:04.420 --> 35:05.220
但是尝试一下

35:07.340 --> 35:09.500
找到所谓的学生的数组

35:09.500 --> 35:11.460
得到电话号码唯一结尾

35:11.460 --> 35:12.620
是不是要筛选

35:14.100 --> 35:15.220
就要筛选

35:15.220 --> 35:15.620
好

35:15.620 --> 35:16.220
怎么筛选

35:16.220 --> 35:16.620
肥肉头

35:17.820 --> 35:19.140
我们以前咋写的

35:21.220 --> 35:23.260
是不是写个函数进去

35:23.260 --> 35:24.340
三个的条件是什么

35:24.380 --> 35:26.580
什么什么学生我保留了

35:26.580 --> 35:28.620
学生的电话号码

35:29.420 --> 35:31.020
Android

35:31.020 --> 35:33.220
以一结尾

35:33.220 --> 35:34.700
对我们之前说写过这样的东西

35:36.180 --> 35:38.060
那么如果说用箭头还是怎么写的

35:38.060 --> 35:38.860
方式性去掉

35:40.300 --> 35:41.420
打上箭头

35:41.420 --> 35:43.500
这里只有一条反回语句

35:43.500 --> 35:44.220
大功耗去掉

35:44.780 --> 35:45.420
大功耗去掉

35:46.820 --> 35:47.740
那你看

35:47.740 --> 35:49.060
这代码是不是简洁的太多了

35:50.260 --> 35:50.820
我们来看一下

35:57.290 --> 35:59.410
那电话号码都是一结尾

35:59.450 --> 35:59.890
对吧

36:01.290 --> 36:02.490
给我一个学生

36:03.370 --> 36:04.970
我给你反回一个布尔

36:04.970 --> 36:05.810
布尔

36:05.810 --> 36:06.890
True and Force

36:08.090 --> 36:09.330
什么学生我要保留的

36:09.330 --> 36:11.490
电话号码唯一结尾

36:11.490 --> 36:12.370
对学生我保留

36:13.290 --> 36:13.570
好的

36:13.570 --> 36:14.290
这第一档体

36:15.810 --> 36:20.330
下面得到所有学生姓名组成的数组

36:20.330 --> 36:22.130
用箭头喊数学生非常舒服

36:23.290 --> 36:24.450
学生数组

36:26.210 --> 36:27.130
都是个对象数组

36:27.130 --> 36:27.890
我要得到什么

36:27.930 --> 36:30.130
学生姓名组成的数组是要硬设

36:30.130 --> 36:33.290
把一个学生对象硬设成为一个制服串

36:33.290 --> 36:34.410
我只取他的name

36:35.690 --> 36:36.410
怎么硬设

36:38.250 --> 36:38.450
好

36:38.450 --> 36:40.050
现在就直接用箭头喊数写了

36:40.050 --> 36:41.490
你给我一个学生

36:41.490 --> 36:43.770
我给力的是什么学生的名字

36:43.770 --> 36:44.930
反回的是学生名字

36:44.930 --> 36:46.930
你看CVB过去的写法

36:46.930 --> 36:48.050
要简单太多了

36:49.490 --> 36:50.490
数数学生的名字

36:53.890 --> 36:54.130
你看

36:55.010 --> 36:55.290
对不对

36:56.410 --> 36:56.690
好

36:56.690 --> 36:57.250
谢谢

36:57.250 --> 36:57.810
下一道题

36:58.770 --> 36:59.810
这个主持人了

37:01.010 --> 37:02.930
得到所有女生的姓名和电话号码

37:02.930 --> 37:04.010
这都是说过的

37:04.010 --> 37:04.490
对吧

37:04.490 --> 37:07.250
我们就把它用成箭头喊数就完事了

37:07.250 --> 37:10.850
首先拿到所有的女生名词的里车

37:10.850 --> 37:13.490
得用fielder过滤一下

37:13.490 --> 37:14.650
把每一个学生拿到

37:15.530 --> 37:16.570
哪些学生保留呢

37:17.890 --> 37:18.370
看一下

37:18.370 --> 37:19.570
女生的就sex

37:21.130 --> 37:23.050
学生的sex

37:23.050 --> 37:24.570
就是姓别等于

37:25.850 --> 37:27.850
回答所有的女生了吗

37:27.850 --> 37:28.050
好

37:28.050 --> 37:29.330
这是一个数组

37:29.370 --> 37:31.770
这个数组我们继续要进行映射

37:31.770 --> 37:33.850
因为我拿到了不是每一个学生对象

37:33.850 --> 37:35.690
我拿到是一个新的对象

37:35.690 --> 37:36.210
对吧

37:36.210 --> 37:37.730
所以说我们这里都要卖

37:37.730 --> 37:38.930
要进行映射

37:38.930 --> 37:41.490
把每一个原始的学生对象拿到

37:41.490 --> 37:44.290
然后把它转换成这样的一个对象

37:44.290 --> 37:44.690
注意

37:44.690 --> 37:46.370
这里有个小的细节

37:47.810 --> 37:49.650
如果说你直接这样的写

37:49.650 --> 37:51.130
这样写不停

37:51.130 --> 37:52.050
不重要的吗

37:52.050 --> 37:53.450
没问题啊

37:53.450 --> 37:54.930
你给我一个学生对象

37:54.930 --> 37:57.210
我给你返回一个新的对象

37:57.210 --> 37:58.410
就像你之前

37:58.450 --> 37:59.770
你给我一个学生对象

37:59.770 --> 38:01.930
我给你返回学生的姓名

38:01.930 --> 38:02.330
对吧

38:02.330 --> 38:03.410
我这里给我一个学生对象

38:03.410 --> 38:04.650
我给你返回一个新的对象

38:04.650 --> 38:06.250
但是这样的写的话

38:06.250 --> 38:07.810
浏览器要蒙

38:07.810 --> 38:09.010
为什么要蒙呢

38:09.010 --> 38:10.050
因为他这个语法

38:10.050 --> 38:11.690
他就神经错乱了

38:11.690 --> 38:13.210
因为你这一块

38:13.210 --> 38:13.890
大扩号

38:13.890 --> 38:15.730
他有两个意思

38:15.730 --> 38:16.610
一个意思呢

38:16.610 --> 38:17.810
是他是一个对象

38:17.810 --> 38:18.850
另外一个意思呢

38:18.850 --> 38:20.130
他是一个寒树蹄

38:21.690 --> 38:21.930
对吧

38:21.930 --> 38:24.730
你看那个箭头寒树里边是不是可以

38:24.730 --> 38:25.530
加上大扩号

38:25.530 --> 38:27.170
变成一个寒树蹄

38:27.170 --> 38:28.250
那么这个寒树蹄里面

38:28.250 --> 38:29.610
你写上这么一句话

38:29.610 --> 38:30.250
他出去蒙了

38:30.250 --> 38:31.850
你这是啥呀

38:31.850 --> 38:32.410
所以说呢

38:32.410 --> 38:35.770
为了避免让浏览器造成误解

38:35.770 --> 38:36.730
让浏览器知道

38:36.730 --> 38:39.050
我这一块不是一个寒树蹄

38:39.050 --> 38:40.130
而是一个对象

38:40.130 --> 38:40.890
怎么办呢

38:40.890 --> 38:41.770
非常简单

38:41.770 --> 38:43.210
加上一个小扩号

38:43.210 --> 38:44.610
因为你加了一个小扩号之后

38:44.610 --> 38:46.610
你会把它变成一个表达式

38:46.610 --> 38:48.890
像我们之前写的一个立即执行寒树

38:48.890 --> 38:50.650
就是把寒树用小扩号扩起来

38:50.650 --> 38:51.930
就这么个意思

38:51.930 --> 38:52.850
加上小扩号之后呢

38:52.850 --> 38:55.090
他就知道这里边是个表达式

38:55.090 --> 38:55.810
这个表达式呢

38:55.810 --> 38:56.810
是一个对象

38:56.850 --> 38:57.770
那他就明白了

38:57.770 --> 38:58.850
这个小的细节

38:59.610 --> 39:01.210
那么新闻是什么呢

39:01.210 --> 39:03.250
新闻就来自于学生的新闻了

39:03.250 --> 39:04.690
你给我一个原式的学生对象

39:04.690 --> 39:05.970
我给你反复一个新的对象

39:05.970 --> 39:07.770
新的对象里面有两个属性

39:07.770 --> 39:12.190
学生的姓名和学生的电话

39:12.190 --> 39:15.830
这样子就拿到一个学生列表了

39:17.470 --> 39:18.470
好我们输出一下

39:18.470 --> 39:18.950
学生列表

39:20.230 --> 39:20.590
运行

39:22.070 --> 39:23.030
你拿到了

39:23.030 --> 39:23.990
对吧

39:23.990 --> 39:25.550
好这是这道题

39:25.550 --> 39:26.030
下一个

39:27.030 --> 39:29.950
将每一个学生变成一个Li元素

39:31.350 --> 39:32.910
元素的内容为学生姓名

39:32.910 --> 39:34.670
拼接所谓的元素形成个常词支付状

39:35.510 --> 39:35.950
啥意思

39:35.950 --> 39:37.590
就是把这个学生数组

39:37.590 --> 39:39.470
每一个学生对象

39:39.470 --> 39:41.550
他给他变成一个Li

39:42.550 --> 39:43.630
是不要做印射

39:43.950 --> 39:44.230
对吧

39:44.230 --> 39:47.430
然后把每一个学生对象的Li拼接起来

39:47.430 --> 39:49.870
结果这个事我们是以前是做过的

39:49.870 --> 39:53.630
我们现在用一个更加简洁的写法

39:53.630 --> 39:54.750
你看我们怎么写

39:55.110 --> 39:55.830
students

39:56.590 --> 39:57.830
然后我们是用map

39:57.830 --> 39:59.950
把每一个学生对象变成什么

39:59.950 --> 40:01.950
变成一个制服创

40:01.950 --> 40:04.030
这个制服创就是一个Li

40:05.110 --> 40:09.150
我们来拼接一下学生的理容之战一半

40:09.150 --> 40:10.390
那这样子的一块拿到了

40:10.390 --> 40:11.870
是不是相当于是

40:13.950 --> 40:14.630
我们输出一下

40:15.630 --> 40:16.830
拿到了一个新的数组

40:16.830 --> 40:18.510
这个数组的每一项是一个制服创

40:19.750 --> 40:20.150
是吧

40:20.150 --> 40:21.430
拼接成了每个Li

40:21.430 --> 40:23.590
然后我们把这些Li全部拼接到一起

40:23.630 --> 40:25.030
所以用一个教练就完成了

40:26.030 --> 40:27.030
一修画就写完了

40:28.470 --> 40:29.710
就拼接出来这么一个东西

40:30.310 --> 40:34.430
这个是不是非常有助于我们在网页上去拼接一些A天秒

40:34.430 --> 40:36.870
把一个数组转换一段A天秒拼接进去

40:37.750 --> 40:37.910
好

40:37.910 --> 40:38.590
这是这道题

40:39.150 --> 40:39.910
把它做完

40:40.270 --> 40:42.190
能自己写出来就自己写

40:42.190 --> 40:42.830
写不出来的话

40:42.830 --> 40:43.790
听了老师讲之后

40:44.270 --> 40:45.350
脱离老舍代码

40:45.350 --> 40:46.270
把自己写一遍

40:46.790 --> 40:48.430
熟悉一下这些常见的

40:48.670 --> 40:50.030
将来我们常见的这些用法

40:51.110 --> 40:51.350
好

40:51.350 --> 40:51.990
下一道题

40:52.270 --> 40:52.670
p3

40:54.070 --> 40:56.310
这个题是让你完成这个函数

40:56.550 --> 40:57.750
这里有一个对象 counter

40:58.190 --> 40:59.110
是一个技术器

40:59.630 --> 41:01.550
它里面目前的数字是0

41:02.310 --> 41:05.230
这里有个函数叫做方法

41:05.230 --> 41:06.550
叫做start increase

41:06.910 --> 41:08.630
开始增加这个数字

41:09.230 --> 41:10.550
这个函数调用之后

41:10.550 --> 41:12.270
它就会不断的增加这个数字

41:12.670 --> 41:13.750
每增加一次

41:14.430 --> 41:15.670
隔一秒就增加一次

41:15.670 --> 41:16.390
然后输出它

41:16.670 --> 41:18.110
其实这个函数其实特别好写

41:18.470 --> 41:18.990
怎么写呢

41:18.990 --> 41:20.910
就是sets interval

41:21.150 --> 41:21.510
对吧

41:22.270 --> 41:23.950
每隔一段时间

41:23.950 --> 41:24.950
每个多少时间的

41:24.950 --> 41:26.270
每隔一秒钟

41:27.270 --> 41:28.230
然后干嘛

41:28.470 --> 41:31.110
把当前的这个codes属性增加

41:31.110 --> 41:32.870
zcodes加加

41:32.870 --> 41:34.670
然后输出一下zcodes

41:35.870 --> 41:36.150
好

41:36.150 --> 41:39.950
接下来我们来用一下 counter start increase

41:40.510 --> 41:42.350
我们来看一下启动开始

41:42.470 --> 41:43.270
启动之后

41:43.270 --> 41:45.230
每隔一秒它就会增加这个数字

41:45.630 --> 41:46.990
那么增加能增加吗

41:47.230 --> 41:47.750
你行

41:49.350 --> 41:50.430
得到全是NAN

41:50.430 --> 41:52.830
那么这个问题是一个非常非常经典的

41:52.830 --> 41:53.710
一个问题了

41:53.870 --> 41:55.110
这个问题是怎么来的呢

41:55.110 --> 41:57.510
是因为这个z的指向出现了问题

41:57.510 --> 41:58.750
因为sets interval里边

41:58.750 --> 42:00.790
这个函数z是指向指向什么window

42:00.790 --> 42:01.750
短选举对象

42:02.270 --> 42:03.390
那这就是出问题了

42:03.550 --> 42:04.590
那怎么办呢

42:05.310 --> 42:06.510
编为监头函数

42:06.510 --> 42:07.710
直接就解决这个问题了

42:08.270 --> 42:10.790
因为监头函数里边是没有z的

42:10.910 --> 42:12.270
因此它的z使用的是什么

42:12.270 --> 42:13.390
外边的z

42:13.550 --> 42:15.030
这里的z是不是正常的

42:15.030 --> 42:16.070
指向的 counter

42:16.430 --> 42:16.790
对吧

42:16.790 --> 42:18.150
所以说我们只要把它变成键了

42:18.150 --> 42:18.870
还去玩事了

42:18.870 --> 42:20.390
实际上你们以后

42:20.870 --> 42:24.470
凡是使用函数表达式的地方

42:24.790 --> 42:26.230
都可以使用监头函数

42:27.310 --> 42:29.470
凡是使用函数表达式的地方

42:29.470 --> 42:30.670
都可以使用监头函数

42:32.310 --> 42:32.870
运行

42:35.350 --> 42:36.790
这个能停止吗

42:38.470 --> 42:39.230
咋停止了

42:43.560 --> 42:44.480
那是咋停止的

42:44.480 --> 42:44.920
我还

42:47.920 --> 42:48.800
我发现stop

42:48.800 --> 42:49.520
投资了

42:49.840 --> 42:50.400
停止了

42:51.200 --> 42:52.160
再重新一下

42:53.840 --> 42:54.080
对了

42:54.080 --> 42:54.840
现在是正常了

42:54.840 --> 42:55.240
对不对

42:58.240 --> 42:58.400
好

42:58.400 --> 42:59.120
这这道题

42:59.120 --> 42:59.800
下一道题

42:59.800 --> 43:00.240
提示

43:01.840 --> 43:03.840
根据下面的调用势力

43:03.840 --> 43:05.680
完成函数给data

43:07.560 --> 43:10.120
有现在需要的一去写个函数给data

43:13.460 --> 43:14.900
然后这个函数的情况

43:14.900 --> 43:15.940
是这么一个情况

43:16.260 --> 43:18.340
就是它里边可以没有参数

43:18.740 --> 43:19.860
也可以有一个参数

43:19.860 --> 43:21.060
也可以有两个参数

43:21.220 --> 43:22.300
那么什么意思呢

43:22.900 --> 43:24.500
调用这个函数之后

43:25.660 --> 43:27.460
它就会获取

43:27.460 --> 43:29.460
它会输出一段东西

43:29.460 --> 43:30.740
我就这里

43:31.380 --> 43:32.300
这里应该这样子写

43:32.300 --> 43:32.860
不好意思

43:32.860 --> 43:34.180
把这个题稍微的

43:34.980 --> 43:35.580
改一下

43:36.900 --> 43:37.980
这里没有concept

43:41.110 --> 43:41.510
这样子

43:43.030 --> 43:43.950
做一个小的练习

43:43.950 --> 43:45.430
就是锻炼的是什么

43:45.430 --> 43:46.430
练习的是

43:46.830 --> 43:47.710
你看就知道了

43:50.070 --> 43:50.870
就这道题

43:50.870 --> 43:52.990
让你去写这么一个函数给data

43:53.150 --> 43:54.550
它里边可以接收

43:54.550 --> 43:55.950
最多两个参数

43:56.750 --> 43:58.350
第一个参数表示

43:58.350 --> 43:59.110
夜嘛

43:59.110 --> 44:00.630
第二个参数表示夜容量

44:00.630 --> 44:01.510
什么叫夜容量呢

44:01.510 --> 44:03.030
就是每夜减是多少条

44:03.310 --> 44:05.030
当然我们现在也不去做这个分页

44:05.030 --> 44:06.470
分页我们之后都会做的

44:06.470 --> 44:07.750
我们只是练习一个

44:07.750 --> 44:09.710
非常非常小的一个

44:10.510 --> 44:10.990
戏

44:12.350 --> 44:13.750
就是函数的书写细节

44:14.590 --> 44:15.870
我们就用箭统函数写吧

44:15.870 --> 44:16.470
多练一下

44:16.950 --> 44:17.750
这个函数

44:17.750 --> 44:18.950
它最多有两个参数

44:18.950 --> 44:20.350
第一个参数表示夜嘛

44:20.350 --> 44:21.630
比方说你不传参数

44:21.630 --> 44:22.510
那么共产参数的话

44:22.550 --> 44:23.550
默认就是第一

44:23.550 --> 44:24.710
它就输出这么一句话

44:25.710 --> 44:26.830
你传一个参数的话

44:26.830 --> 44:27.990
它就输出这么一句话

44:28.310 --> 44:29.030
那么也就说

44:29.030 --> 44:30.550
二就覆盖了夜嘛

44:31.150 --> 44:31.990
不传夜嘛

44:31.990 --> 44:34.070
它就认为是第一页

44:34.070 --> 44:35.310
每夜减是十条

44:35.990 --> 44:37.150
传了夜嘛的话

44:37.150 --> 44:37.950
那么就认为

44:37.950 --> 44:39.510
就使用你传递的夜嘛

44:39.990 --> 44:41.550
传了夜嘛和夜容量

44:41.550 --> 44:44.510
那么就同时使用你传递的夜嘛和夜容量

44:44.950 --> 44:46.750
这个函数无非就是一句话输出

44:47.070 --> 44:48.190
关键练的是什么

44:48.190 --> 44:49.630
练的是默认参数

44:49.630 --> 44:50.630
就这么简单

44:50.630 --> 44:51.590
它有几个参数

44:52.310 --> 44:53.190
一个是夜嘛

44:53.190 --> 44:53.990
一个是夜容量

44:53.990 --> 44:56.630
夜容量我们一般用的内面词来表示

44:56.630 --> 44:57.790
或者是用配级赛词

44:57.790 --> 44:58.630
都是一个意思

44:59.270 --> 45:00.470
就是每夜减多少条

45:00.790 --> 45:02.750
配级赛词或者是内面词都可以看

45:03.910 --> 45:05.750
那么它其实就是输出一句话

45:06.270 --> 45:06.870
输出

45:08.790 --> 45:09.270
什么呢

45:09.910 --> 45:10.790
获取

45:11.190 --> 45:12.150
把这句话输出

45:12.790 --> 45:15.390
第几页来自于参数配级

45:15.990 --> 45:17.070
每夜减多少条呢

45:17.510 --> 45:19.230
来自于内面词

45:20.230 --> 45:21.270
对

45:21.270 --> 45:22.310
就是写上这么一个

45:22.550 --> 45:23.590
建筒函数

45:24.110 --> 45:26.030
刚刚这两个参数是有默认值的

45:26.030 --> 45:27.430
因为它没有传递的话

45:27.430 --> 45:28.390
夜嘛就为1

45:28.390 --> 45:29.470
传递的话

45:29.470 --> 45:31.230
没有传递的夜容量的话

45:31.230 --> 45:32.150
默认就为10

45:32.790 --> 45:32.950
好

45:32.950 --> 45:33.950
咱们来运行看一下

45:34.950 --> 45:35.350
你看

45:35.910 --> 45:37.510
就达到一个参数默认值的效果

45:38.870 --> 45:39.110
好

45:39.110 --> 45:39.670
这是这道题

45:39.830 --> 45:40.630
非常简单

45:41.190 --> 45:42.190
下一道题

45:42.710 --> 45:45.430
根据下面的调用势力完成函数给data4

45:45.430 --> 45:46.470
又差不多了

45:46.710 --> 45:48.150
那么刚才我们是

45:48.190 --> 45:50.990
把夜嘛和夜容量作为两个参数来传递

45:50.990 --> 45:51.990
那么现在的做法

45:51.990 --> 45:52.470
有的时候

45:52.470 --> 45:53.710
我们会发现前端的

45:54.550 --> 45:55.870
有一些常见的做法

45:55.870 --> 45:57.110
就是传一个配置对象

45:57.350 --> 45:58.750
就一个参数

45:59.790 --> 46:01.350
如果说你不传参数的话

46:01.350 --> 46:02.870
那么还是默认第一页

46:02.870 --> 46:04.070
每夜减是10条

46:04.070 --> 46:05.950
然后这里多了一个查询关键字

46:05.950 --> 46:06.670
为空

46:07.750 --> 46:07.950
好

46:07.950 --> 46:09.150
如果说你传的参数

46:09.150 --> 46:10.510
我这里不好意思

46:10.510 --> 46:12.790
我这里又去写了一个什么康斯洛尔德

46:13.310 --> 46:14.470
把康斯洛尔德都去掉

46:19.100 --> 46:19.980
这样子差不多

46:20.980 --> 46:21.980
复制在下

46:21.980 --> 46:22.980
屁股

46:22.980 --> 46:25.300
好

46:25.700 --> 46:26.700
看一下

46:26.700 --> 46:28.300
就是你不传参数

46:28.300 --> 46:29.620
它就输出第一页

46:29.620 --> 46:31.500
每夜10条查询关键字为空

46:31.500 --> 46:32.660
你传参数的时候

46:32.660 --> 46:33.820
现在跟刚才不一样了

46:33.820 --> 46:36.300
刚才我们是把每一个参数分开的

46:36.300 --> 46:38.020
现在都合并成一个对象

46:38.020 --> 46:40.300
通过对象里面的属性来进行配置

46:40.300 --> 46:42.700
我们通常把这种对象的叫做配置对象

46:43.700 --> 46:44.700
你传了一个对象进去

46:44.700 --> 46:45.700
给它传了一个配置

46:45.700 --> 46:47.500
那么就覆盖了之前的默认值了

46:47.900 --> 46:49.700
我们就过去第二页的数据

46:49.700 --> 46:50.700
每一页是10条

46:50.700 --> 46:52.100
月容量还是默认的

46:52.100 --> 46:53.700
查询关键字默认为空

46:54.300 --> 46:55.700
你传了两个配置

46:55.700 --> 46:57.300
那么就过去的第二页

46:57.300 --> 46:58.500
每一页是30条

46:58.500 --> 46:59.700
查询关键字为空

46:59.700 --> 47:01.500
如果说你传了T-word

47:01.500 --> 47:03.100
表示的是查询关键字

47:03.100 --> 47:04.500
那么夜码默认

47:04.500 --> 47:05.500
夜容量默认

47:05.500 --> 47:07.700
查询关键字的使用你的关键字

47:08.300 --> 47:09.700
我们就写出这么一个格式

47:09.700 --> 47:11.300
这个函数要做的事情特别简单

47:11.300 --> 47:12.700
就是输出就完事了

47:12.700 --> 47:13.700
给datas

47:14.900 --> 47:16.900
有几个参数我首先问大家

47:16.900 --> 47:18.100
它有几个参数

47:19.100 --> 47:20.100
有几个参数

47:20.100 --> 47:22.100
是不是只有一个参数

47:22.100 --> 47:23.100
对不对

47:23.100 --> 47:24.500
我们按过去的写法写一遍

47:24.500 --> 47:26.100
先按了老的写法写一遍

47:26.100 --> 47:27.500
是不是只有一个参数

47:27.500 --> 47:29.100
我们通常把它叫做Options

47:29.100 --> 47:30.100
叫做配置

47:30.100 --> 47:31.100
Port叫做Config

47:31.100 --> 47:32.100
叫做配置

47:33.100 --> 47:37.100
如果说你不传递这个配置的话

47:38.100 --> 47:39.100
你看这里是不是没有传递

47:39.100 --> 47:41.100
我是不是给它一个默认值

47:41.100 --> 47:42.100
默认什么呢

47:42.100 --> 47:43.100
我就给它默认一个空对象

47:44.100 --> 47:45.100
按照以前的写法

47:45.100 --> 47:46.100
我们可以这样的写

47:46.100 --> 47:47.100
你没有传递的话

47:47.100 --> 47:48.100
我就给它一个空对象

47:48.100 --> 47:50.100
接下来我就得到每一块的值

47:50.100 --> 47:51.100
首先得到配级

47:51.100 --> 47:52.100
配级的话

47:52.100 --> 47:53.100
如果说你传递的配级

47:54.100 --> 47:55.100
没有传递的配级的话

47:55.100 --> 47:56.100
我就使用1

47:57.100 --> 47:58.100
还有就是一个Limits

47:58.100 --> 48:00.100
如果说你没有传递Limits的话

48:01.100 --> 48:02.100
我就使用10

48:03.100 --> 48:05.100
这是以前非常非常常见的一个做法

48:06.100 --> 48:07.100
没有传递Q2的话

48:07.100 --> 48:08.100
我就扔

48:08.100 --> 48:10.100
我就给它一个空置补串

48:11.100 --> 48:12.100
没了意思吧

48:12.100 --> 48:15.100
我就用这种方式来过去默认值

48:16.100 --> 48:18.100
接下来我们再得输出

48:20.100 --> 48:22.100
获取第几页的数据

48:22.100 --> 48:23.100
第几页配级

48:24.100 --> 48:26.100
每页显示几条呢

48:26.100 --> 48:28.100
每页显示Limits

48:28.100 --> 48:29.100
这么多条

48:29.100 --> 48:30.100
查询关键之为什么呢

48:30.100 --> 48:32.100
这里我们可以用个三目运算符

48:32.100 --> 48:34.100
如果说Q2的有值吗

48:34.100 --> 48:36.100
因为它有可能是空置补串

48:36.100 --> 48:37.100
它有可能有值吗

48:37.100 --> 48:39.100
有值的话我就使用你的值

48:39.100 --> 48:40.100
如果说没有值的话

48:40.100 --> 48:41.100
我就是写了空

48:42.100 --> 48:43.100
好了

48:43.100 --> 48:44.100
我们看一下

48:44.100 --> 48:46.100
效果肯定是没有任何问题的

48:47.100 --> 48:48.100
你看自己对一下

48:48.100 --> 48:49.100
没有任何问题

48:49.100 --> 48:50.100
这是过去的写法

48:50.100 --> 48:51.100
过去的写法

48:51.100 --> 48:52.100
这种写法可不可以的

48:52.100 --> 48:53.100
当然可以

48:53.100 --> 48:54.100
没有任何问题

48:54.100 --> 48:56.100
当然我们也可以利用

48:57.100 --> 48:59.100
ES6的一些新的写法

48:59.100 --> 49:00.100
我们来看一下新的写法

49:00.100 --> 49:01.100
getdatas

49:01.100 --> 49:03.100
这个我们之前好像没接触过

49:05.100 --> 49:06.100
我们可以改造的

49:06.100 --> 49:07.100
首先我们这里用到的箭头函数

49:07.100 --> 49:08.100
这个没什么好说的

49:08.100 --> 49:10.100
用到的默认参数

49:11.100 --> 49:12.100
但是我这里默认参数

49:12.100 --> 49:13.100
只是能给这个参数

49:13.100 --> 49:15.100
整体付一个默认值

49:16.100 --> 49:17.100
比较整体付一个默认值

49:17.100 --> 49:19.100
我没有办法细化到

49:19.100 --> 49:21.100
里边每一个去付默认值

49:21.100 --> 49:22.100
原来说

49:22.100 --> 49:23.100
为什么不在这里边写

49:23.100 --> 49:25.100
这个配几1

49:25.100 --> 49:26.100
nm10

49:26.100 --> 49:28.100
Q2的为空置补串

49:28.100 --> 49:29.100
为什么不用这种方式

49:29.100 --> 49:30.100
来配置默认值的

49:30.100 --> 49:31.100
可不可以

49:31.100 --> 49:32.100
可以

49:32.100 --> 49:34.100
但是没有什么意义

49:34.100 --> 49:35.100
为什么没有意义

49:36.100 --> 49:38.100
因为你这样的写了过后

49:39.100 --> 49:40.100
请问这种情况

49:42.100 --> 49:43.100
它会使用

49:44.100 --> 49:45.100
这里的默认值吗

49:45.100 --> 49:46.100
不会

49:46.100 --> 49:47.100
一个都不会

49:47.100 --> 49:48.100
为什么我来梳理一下

49:48.100 --> 49:50.100
因为它只有一个参数

49:51.100 --> 49:52.100
你这里如果说

49:52.100 --> 49:53.100
没有一个参数都没传

49:54.100 --> 49:55.100
就相当于是传了个

49:55.100 --> 49:56.100
nm10

49:56.100 --> 49:57.100
对吧

49:57.100 --> 49:58.100
那么这个参数

49:58.100 --> 49:59.100
这个没问题

49:59.100 --> 50:00.100
它会使用这个默认值

50:00.100 --> 50:01.100
这个对象作为默认值

50:01.100 --> 50:02.100
但是如果说

50:02.100 --> 50:04.100
你传了一个对象进去

50:05.100 --> 50:06.100
不好意思

50:06.100 --> 50:07.100
那么这样子的情况下

50:07.100 --> 50:09.100
这个config

50:09.100 --> 50:12.880
它就使用的是

50:12.880 --> 50:13.880
这个默认值了

50:13.880 --> 50:14.880
它就使用的是它了

50:14.880 --> 50:15.880
因为你传递的是

50:15.880 --> 50:16.880
这个对象

50:16.880 --> 50:17.880
言而言

50:17.880 --> 50:18.880
你传递的这个对象

50:18.880 --> 50:19.880
它就不会使用

50:19.880 --> 50:20.880
这个默认值了

50:20.880 --> 50:21.880
它会使用这个对象

50:21.880 --> 50:22.880
作为它的值

50:22.880 --> 50:23.880
那么这个对象

50:23.880 --> 50:24.880
里面是不是缺少了属性

50:24.880 --> 50:25.880
缺少了内面词

50:25.880 --> 50:26.880
缺少了keyword

50:26.880 --> 50:27.880
所以说你用

50:27.880 --> 50:29.880
这种做法还不行

50:29.880 --> 50:31.880
这种做法

50:31.880 --> 50:32.880
只能适用于

50:32.880 --> 50:33.880
上面那种情况

50:33.880 --> 50:34.880
就第四道提到

50:34.880 --> 50:35.880
这种情况

50:35.880 --> 50:36.880
它多个参数分开的

50:36.880 --> 50:37.880
但是如果说

50:37.880 --> 50:38.880
你适用一个参数

50:38.880 --> 50:39.880
一个对象传进来的话

50:39.880 --> 50:40.880
不行

50:40.880 --> 50:41.880
当然我们是可以

50:41.880 --> 50:42.880
用这种方式

50:42.880 --> 50:43.880
但是上面的方式

50:43.880 --> 50:44.880
完全没问题

50:44.880 --> 50:45.880
一点问题都没有

50:45.880 --> 50:46.880
我们可以使用

50:46.880 --> 50:47.880
一个这个语法

50:47.880 --> 50:49.880
解构

50:49.880 --> 50:50.880
我不仅给它

50:50.880 --> 50:51.880
付一个默认值

50:51.880 --> 50:52.880
这种默认值

50:52.880 --> 50:53.880
我应对什么情况

50:53.880 --> 50:54.880
应对你没有

50:54.880 --> 50:55.880
传参数的情况

50:55.880 --> 50:56.880
不然的话

50:56.880 --> 50:57.880
它就是

50:57.880 --> 50:58.880
Defend

50:58.880 --> 50:59.880
这个东西不好办

50:59.880 --> 51:00.880
我们给它一个

51:00.880 --> 51:01.880
默认值

51:01.880 --> 51:02.880
是一个空对象

51:02.880 --> 51:03.880
你没有传参数

51:03.880 --> 51:04.880
我就给你一个空对象

51:04.880 --> 51:06.880
然后我们尝试着

51:06.880 --> 51:08.880
无论是从它里边

51:08.880 --> 51:09.880
还是从这里边

51:09.880 --> 51:10.880
的东西进行解构

51:10.880 --> 51:12.880
我们在这里可以解构的

51:12.880 --> 51:13.880
你看这两个大过号的意识

51:13.880 --> 51:15.880
是完全不一样的

51:15.880 --> 51:17.880
等号后面的大过号表示

51:17.880 --> 51:18.880
这个参数

51:18.880 --> 51:19.880
如果说你没有传递

51:19.880 --> 51:20.880
我就使用一个空对象

51:20.880 --> 51:21.880
你传递的

51:21.880 --> 51:22.880
我就使用你传递的

51:22.880 --> 51:23.880
这个对象

51:23.880 --> 51:24.880
比方说你这种情况

51:24.880 --> 51:26.880
那么这个参数

51:26.880 --> 51:27.880
这种情况

51:27.880 --> 51:28.880
康菲格是什么

51:28.880 --> 51:29.880
就是一个空对象

51:29.880 --> 51:30.880
我来看一下

51:30.880 --> 51:36.690
情况一

51:36.690 --> 51:37.690
就是一个默认值

51:37.690 --> 51:38.690
空对象

51:38.690 --> 51:39.690
都是默认值

51:39.690 --> 51:40.690
就是第1种情况

51:40.690 --> 51:41.690
第2种情况

51:41.690 --> 51:42.690
你传了一个对象

51:42.690 --> 51:43.690
我就不会使用默认值了

51:43.690 --> 51:44.690
对吧

51:44.690 --> 51:45.690
所以第2种情况

51:45.690 --> 51:46.690
就是情况2

51:46.690 --> 51:50.380
还有是情况3

51:50.380 --> 51:52.380
情况3的话就康菲格

51:52.380 --> 51:53.380
后面我就不再举例了

51:53.380 --> 51:55.380
情况3是不是这样子的

51:55.380 --> 51:57.950
对吧

51:57.950 --> 51:58.950
就是这么一种情况

51:58.950 --> 51:59.950
总之它得是一个对象

51:59.950 --> 52:01.950
它不可能是上帝犯的

52:01.950 --> 52:03.950
那么不管它是哪一个对象

52:03.950 --> 52:04.950
这个对象也好

52:04.950 --> 52:05.950
这个对象也好

52:05.950 --> 52:06.950
这个对象也好

52:06.950 --> 52:07.950
我们是不是都可以

52:07.950 --> 52:08.950
对这个对象

52:08.950 --> 52:09.950
本身进行解构

52:09.950 --> 52:10.950
就可以解构

52:10.950 --> 52:12.950
你看这个邪法就有意思了

52:12.950 --> 52:13.950
好

52:13.950 --> 52:14.950
解构我们得到

52:14.950 --> 52:15.950
大级数据

52:15.950 --> 52:16.950
我们是不是得到配级

52:16.950 --> 52:18.950
Nemez和Q2

52:18.950 --> 52:19.950
是不是解构出来这种

52:19.950 --> 52:20.950
但是你要搞清楚

52:20.950 --> 52:21.950
是不是解构出来的

52:21.950 --> 52:22.950
有的时候

52:22.950 --> 52:24.950
我们它没有这个熟悉了

52:24.950 --> 52:25.950
比方说像这种情况

52:25.950 --> 52:27.950
它是不是只有一个配级

52:27.950 --> 52:29.950
它只传了这么一个对象进来

52:29.950 --> 52:30.950
它没有Nemez

52:30.950 --> 52:31.950
没有Q2的

52:32.950 --> 52:33.950
那么

52:33.950 --> 52:34.950
像这种情况

52:34.950 --> 52:36.950
它只传了一个Q2的进来

52:36.950 --> 52:37.950
它没有配级

52:37.950 --> 52:38.950
没有Nemez

52:38.950 --> 52:39.950
那解构出来是什么

52:39.950 --> 52:40.950
解构出来就是NOW

52:40.950 --> 52:42.950
不然就是Undefined

52:42.950 --> 52:43.950
就没东西

52:43.950 --> 52:44.950
没啥意思吧

52:44.950 --> 52:45.950
那怎么办呢

52:45.950 --> 52:47.950
实际上在解构的时候

52:47.950 --> 52:49.950
是可以给默认值的

52:49.950 --> 52:51.950
这个之前我咱们没有讲

52:51.950 --> 52:53.950
但是官方文档里面是有

52:53.950 --> 52:55.950
解构的时候是可以给默认值的

52:55.950 --> 52:56.950
那怎么来着

52:56.950 --> 52:57.950
给这个默认值的

52:57.950 --> 52:59.950
直接写的很好

52:59.950 --> 53:01.950
就这么简单

53:01.950 --> 53:06.950
是Q2的空

53:06.950 --> 53:07.950
就是说

53:07.950 --> 53:08.950
如果说

53:08.950 --> 53:09.950
比方说你给的

53:09.950 --> 53:10.950
传的是这个对象

53:10.950 --> 53:11.950
这种情况

53:11.950 --> 53:12.950
你传的是这个对象

53:12.950 --> 53:13.950
那么这个对象里面

53:13.950 --> 53:14.950
只有一个配级

53:14.950 --> 53:15.950
那么配级不会使用默认值

53:15.950 --> 53:16.950
配级就为2

53:16.950 --> 53:17.950
但是没有Nemez

53:17.950 --> 53:18.950
没有Q2

53:18.950 --> 53:20.950
那么他们就会使用默认值

53:20.950 --> 53:21.950
明白了意思吧

53:21.950 --> 53:22.950
好

53:22.950 --> 53:23.950
那么这种情况

53:23.950 --> 53:24.950
这种情况你没有传参数

53:24.950 --> 53:25.950
没有传参数的话

53:25.950 --> 53:27.950
这里就是一个空对象

53:27.950 --> 53:29.950
康菲格就是个空对象

53:29.950 --> 53:30.950
那么对这个空对象解构

53:30.950 --> 53:31.950
那么空对象里面

53:31.950 --> 53:32.950
肯定没有配级

53:32.950 --> 53:33.950
肯定没有Nemez

53:33.950 --> 53:34.950
肯定没有Q2

53:34.950 --> 53:35.950
他们都会使用默认值

53:35.950 --> 53:36.950
所以说

53:36.950 --> 53:37.950
这样子

53:37.950 --> 53:38.950
我们在这里边

53:38.950 --> 53:39.950
只需要一句话就完事了

53:39.950 --> 53:47.360
是不是一句话就完事了

53:47.360 --> 53:48.360
好

53:48.360 --> 53:49.360
我们来看一下

53:49.360 --> 53:50.360
效果是完全一样的

53:50.360 --> 53:51.360
当然了

53:51.360 --> 53:52.360
这里的箭头函数

53:52.360 --> 53:53.360
你可以省

53:53.360 --> 53:54.360
因为只有一句话

53:54.360 --> 53:55.360
所以说

53:55.360 --> 53:56.360
虽然不是返回

53:56.360 --> 53:59.760
但是你可以省略这个大括号

53:59.760 --> 54:01.760
没问题

54:01.760 --> 54:02.760
这也是以后

54:02.760 --> 54:04.760
你们可能看到别人写的代码了

54:04.760 --> 54:07.760
也可能会出现这种格式

54:07.760 --> 54:08.760
这是第五题

54:08.760 --> 54:10.760
自己去写一下

54:10.760 --> 54:12.760
就是你们以后自己写的话

54:12.760 --> 54:13.760
就看你们自己的

54:13.760 --> 54:14.760
你可以用上面那种写法

54:14.760 --> 54:16.760
比较好理解一点

54:16.760 --> 54:17.760
下面那种写法

54:17.760 --> 54:18.760
你看多了

54:23.820 --> 54:24.820
下面这道题

54:24.820 --> 54:25.820
下面这道题的话

54:25.820 --> 54:27.820
主要是练习一下

54:27.820 --> 54:30.820
就是熟悉一下这个内的语法

54:30.820 --> 54:32.820
你们可以参照咱们的文档

54:32.820 --> 54:33.820
把它写出来

54:33.820 --> 54:35.820
就让你写一个构造函数

54:35.820 --> 54:36.820
这个构造函数里面

54:36.820 --> 54:37.820
有个方法

54:37.820 --> 54:38.820
非常非常简单

54:38.820 --> 54:40.820
就说出一句话

54:40.820 --> 54:41.820
你可以建议大家

54:41.820 --> 54:43.820
先用老的写法写

54:43.820 --> 54:45.820
就最原始的写法写

54:45.820 --> 54:47.820
再用我们新的内的写法写

54:47.820 --> 54:48.820
自己去做一个对比

54:48.820 --> 54:50.820
熟悉一下内语法

54:50.820 --> 54:51.820
虽然说你们以后

54:51.820 --> 54:52.820
自己写内的话

54:52.820 --> 54:54.820
现阶段了不会太多

54:54.820 --> 54:56.820
将来可能会遇到不少

54:56.820 --> 54:58.820
但现在还不会太多

54:58.820 --> 54:59.820
好我们给大家写一下

54:59.820 --> 55:01.820
从里面自己先去尝试的

55:01.820 --> 55:02.820
做一下

55:02.820 --> 55:04.820
首先我们用老的写法写

55:04.820 --> 55:05.820
怎么写

55:05.820 --> 55:06.820
方个写

55:06.820 --> 55:07.820
有点

55:07.820 --> 55:08.820
两个参数

55:08.820 --> 55:10.820
一个是账号

55:10.820 --> 55:11.820
一个是密码

55:11.820 --> 55:13.820
然后我们复职

55:13.820 --> 55:14.820
这些我就不担

55:14.820 --> 55:15.820
多说了

55:16.820 --> 55:20.460
然后他需要有一个

55:20.460 --> 55:22.460
实力方法

55:22.460 --> 55:23.460
通过对象去调用的实力方法

55:23.460 --> 55:24.460
对吧

55:24.460 --> 55:25.460
所以说帮到圆形上面

55:25.460 --> 55:26.460
shallow

55:28.460 --> 55:30.460
主要圆形方法是不要用

55:30.460 --> 55:31.460
那个箭头函数的

55:33.770 --> 55:35.770
shallow我们就说出一句话

55:35.770 --> 55:37.770
就这么一句话

55:37.770 --> 55:40.210
有没有同学知道

55:40.210 --> 55:42.210
为什么这里不要用箭头函数

55:42.210 --> 55:43.210
同学们

55:44.210 --> 55:50.630
为什么这里不要用箭头函数

55:50.630 --> 55:51.630
知道吗

55:51.630 --> 55:52.630
你用了箭头函数

55:52.630 --> 55:54.630
这个Z就出问题了

55:54.630 --> 55:55.630
同学们

55:55.630 --> 55:56.630
因为箭头函数里面

55:56.630 --> 55:57.630
是没有Z

55:57.630 --> 55:58.630
那么就相当于是

55:58.630 --> 55:59.630
这里没有Z

55:59.630 --> 56:00.630
导致什么

56:00.630 --> 56:01.630
导致他的Z

56:01.630 --> 56:02.630
用的是啥

56:02.630 --> 56:03.630
用的是在外面的Z

56:03.630 --> 56:05.630
在外面的Z是指向上

56:05.630 --> 56:06.630
不用多说了

56:06.630 --> 56:07.630
所以说在这里

56:07.630 --> 56:08.630
不要虚拟Z

56:08.630 --> 56:09.630
Z就是

56:09.630 --> 56:10.630
其实箭头函数

56:10.630 --> 56:11.630
我们一般用在哪

56:11.630 --> 56:13.630
就是一些零食需要函数的地方

56:13.630 --> 56:14.630
用零食的哪一个函数

56:14.630 --> 56:16.630
比方说注册一个视线

56:16.630 --> 56:18.630
我就是一个零食的函数

56:18.630 --> 56:19.630
对吧

56:19.630 --> 56:21.630
或者说我定一个零食的函数

56:21.630 --> 56:23.630
就是为了简单调用一下

56:23.630 --> 56:25.630
跟Z是没有什么关系

56:25.630 --> 56:27.630
像跟Z是那些东西有关系的

56:27.630 --> 56:28.630
你不要用箭头函数

56:28.630 --> 56:30.630
不要用像一个对象里面的方法

56:30.630 --> 56:31.630
一个实力方法

56:31.630 --> 56:32.630
你千万不能用这种箭头函数

56:33.630 --> 56:34.630
就这么一个回事

56:35.630 --> 56:36.630
就完事了

56:36.630 --> 56:37.630
你看一下

56:37.630 --> 56:38.630
这是过去的旧的写法

56:38.630 --> 56:39.630
没问题吧

56:40.630 --> 56:41.630
输出了

56:41.630 --> 56:43.630
然后我们也可以利用

56:43.630 --> 56:44.630
新的写法

56:44.630 --> 56:45.630
新的语法就是Class

56:46.630 --> 56:47.630
新的语法的写法

56:47.630 --> 56:49.630
就看上去更加舒服一点

56:49.630 --> 56:50.630
如果说你感觉

56:50.630 --> 56:52.630
不出来他很舒服的话

56:52.630 --> 56:53.630
说明你跟他的感情

56:53.630 --> 56:54.630
还没到位

56:54.630 --> 56:56.630
慢慢去培养感情

56:58.630 --> 57:02.070
如果说你学过什么

57:02.070 --> 57:04.070
其他的一个后端语言的话

57:04.070 --> 57:06.070
你就觉得这个东西很舒服

57:06.070 --> 57:07.070
Say hello

57:07.070 --> 57:08.070
对吧

57:08.070 --> 57:09.070
他们是聚合在一起的

57:09.070 --> 57:10.070
或者够着气

57:10.070 --> 57:11.070
和这些实力方法

57:11.070 --> 57:12.070
是放在一堆的

57:12.070 --> 57:14.070
它不是像这样的分开的

57:14.070 --> 57:15.070
很舒服的

57:15.070 --> 57:17.070
那么这里直接输出

57:17.070 --> 57:18.070
就完事了

57:19.070 --> 57:20.070
就完事了

57:21.070 --> 57:22.070
一样的效果

57:23.070 --> 57:24.070
好

57:24.070 --> 57:25.070
这是那个

57:25.070 --> 57:26.070
这道题

57:27.070 --> 57:28.070
好

57:28.070 --> 57:29.070
把这前面的六道题

57:29.070 --> 57:30.070
做完啊

57:30.070 --> 57:31.070
做完了之后

57:31.070 --> 57:33.070
咱们再聊一个

57:33.070 --> 57:34.070
别的东西

57:34.070 --> 57:36.070
叫做寒树黄豆

57:36.070 --> 57:37.070
为啥要聊这个呢

57:37.070 --> 57:39.070
因为我们后边有

57:39.070 --> 57:41.070
那么一两个地方要用

57:41.070 --> 57:43.070
而且这个玩意也挺实用的

57:44.070 --> 57:45.070
而且这个玩意面试的时候

57:45.070 --> 57:46.070
也经常考

57:47.070 --> 57:48.070
虽然说咱们还不是的

57:48.070 --> 57:49.070
还没有开始

57:49.070 --> 57:51.070
说我们特别

57:51.070 --> 57:52.070
去注重面试体

57:52.070 --> 57:53.070
我们后边再说

57:53.070 --> 57:54.070
但是呢

57:54.070 --> 57:55.070
这个东西要用

57:55.070 --> 57:56.070
而且它特别好用

57:56.070 --> 57:58.070
我们还是把它讲了

57:59.070 --> 58:01.070
这个玩意大一码不多

58:02.070 --> 58:03.070
只要写一遍

58:03.070 --> 58:05.070
你只要能够写出来一遍

58:05.070 --> 58:06.070
就OK了

58:07.070 --> 58:09.070
一开始你肯定写不出来的

58:09.070 --> 58:10.070
你可以尝试着

58:10.070 --> 58:12.070
听完我解释之后

58:12.070 --> 58:13.070
你可以尝试着写一下

58:13.070 --> 58:14.070
写这个玩意

58:14.070 --> 58:16.070
一开始还是挺

58:16.070 --> 58:17.070
对初学者而言

58:17.070 --> 58:18.070
还是挺难的

58:18.070 --> 58:19.070
其实它大一码没有几行

58:20.070 --> 58:21.070
可能两三行大一码

58:21.070 --> 58:22.070
就可以搞定

58:22.070 --> 58:23.070
就是你想不到

58:23.070 --> 58:25.070
寒树防斗是一个什么东西呢

58:25.070 --> 58:26.070
它是让某

58:26.070 --> 58:28.070
它可以让某个寒树的执行推迟

58:29.070 --> 58:31.070
如果说在推迟期间执行寒树

58:31.070 --> 58:33.070
会将寒树进一步推迟

58:33.070 --> 58:34.070
啥意思

58:34.070 --> 58:35.070
我给大家举个例子

58:35.070 --> 58:37.070
你们都说过电梯吧

58:37.070 --> 58:38.070
对吧

58:38.070 --> 58:39.070
进去一个人

58:39.070 --> 58:41.070
电梯会有一个

58:41.070 --> 58:42.070
相当于电梯会干嘛

58:42.070 --> 58:43.070
会关门

58:44.070 --> 58:46.070
我就把关门当成一个寒树

58:46.070 --> 58:47.070
关门是个动作

58:47.070 --> 58:48.070
把当成一个寒树

58:48.070 --> 58:50.070
它是不是立即关门

58:50.070 --> 58:51.070
不是吧

58:51.070 --> 58:52.070
它一般会等个两三秒

58:53.070 --> 58:54.070
比方说三秒钟

58:55.070 --> 58:56.070
人一进去

58:56.070 --> 58:58.070
相当于是掉用了关门寒树

59:01.070 --> 59:02.070
人一进去

59:02.070 --> 59:03.070
比方说我们这里

59:03.070 --> 59:04.070
这是时间

59:05.070 --> 59:06.070
然后这个地方

59:06.070 --> 59:07.070
进来一个人

59:07.070 --> 59:09.070
它就掉用了关门寒树

59:09.070 --> 59:10.070
但它不是立即关门

59:10.070 --> 59:12.070
它需要等个三秒钟

59:12.070 --> 59:13.070
可能时间点在这

59:14.070 --> 59:15.070
这个时候才真正的开始关门

59:16.070 --> 59:17.070
那么这个时候

59:17.070 --> 59:18.070
还没有开始关门对吧

59:18.070 --> 59:20.070
但是这个时候又进来的一个人

59:21.070 --> 59:22.070
又进来一个人

59:22.070 --> 59:23.070
他会怎么样呢

59:23.070 --> 59:25.070
他会打断之前的等待过程

59:26.070 --> 59:27.070
相当于是这个关门

59:27.070 --> 59:28.070
进一步被推迟了

59:29.070 --> 59:31.070
以这个人为基准

59:31.070 --> 59:32.070
再等待三秒钟

59:34.070 --> 59:35.070
然后这个时候

59:35.070 --> 59:37.070
突然本来的马上要关门了

59:37.070 --> 59:39.070
然后这个是又进来一个人

59:39.070 --> 59:41.070
那么之前的关门动作取消

59:42.070 --> 59:44.070
然后现在以这个最后一个人

59:44.070 --> 59:45.070
进来的时间点

59:45.070 --> 59:47.070
继续往后推迟三秒钟

59:47.070 --> 59:49.070
你看电梯明不就是这样子吗

59:49.070 --> 59:50.070
对吧

59:50.070 --> 59:51.070
这样子解释能理解了

59:51.070 --> 59:53.070
就是把一个寒树的运行推迟

59:53.070 --> 59:55.070
如果说推迟的期间

59:55.070 --> 59:57.070
又沾一次运行的这个寒树

59:57.070 --> 01:00:00.070
那么它会以最后一次为基准

01:00:00.070 --> 01:00:02.070
来进一步推迟

01:00:02.070 --> 01:00:04.070
停上去好像很高端的样子

01:00:04.070 --> 01:00:06.070
其实代码写不了几条

01:00:06.070 --> 01:00:08.070
就这么一个东西

01:00:08.070 --> 01:00:10.070
那么具体到我们代码里边

01:00:10.070 --> 01:00:12.070
是什么玩意呢

01:00:12.070 --> 01:00:14.070
我就希望你有这么一个寒树

01:00:14.070 --> 01:00:15.070
叫迪邦斯

01:00:16.070 --> 01:00:17.070
比方说我这里有个寒树

01:00:17.070 --> 01:00:18.070
比方说它就是关门寒树

01:00:18.070 --> 01:00:20.070
我们就

01:00:20.070 --> 01:00:22.070
我这里写了一个A和B

01:00:22.070 --> 01:00:24.070
比方说我们就

01:00:24.070 --> 01:00:25.070
A和B无所谓

01:00:25.070 --> 01:00:27.070
我就写了关门

01:00:27.070 --> 01:00:29.070
关门然后把A加B

01:00:29.070 --> 01:00:31.070
就是A和B无所谓的

01:00:31.070 --> 01:00:32.070
无所谓的

01:00:32.070 --> 01:00:34.070
要不然为了大家好理解的话

01:00:36.070 --> 01:00:38.070
我就把这个寒树改造一下

01:00:38.070 --> 01:00:40.070
再改造一下

01:00:40.070 --> 01:00:44.280
再重新来一个

01:00:46.280 --> 01:00:47.280
我有一个寒树

01:00:47.280 --> 01:00:49.280
这个寒树没有参数

01:00:49.280 --> 01:00:51.280
它就是输出一个关门

01:00:54.280 --> 01:00:55.280
但是呢

01:00:55.280 --> 01:00:56.280
现在的问题就是

01:00:56.280 --> 01:00:57.280
我一雕这个寒树

01:00:57.280 --> 01:00:58.280
它马上就关门了

01:00:58.280 --> 01:01:00.280
它没有等待时间

01:01:00.280 --> 01:01:02.280
我希望你提供这么一个寒树

01:01:02.280 --> 01:01:04.280
迪邦斯就要防斗

01:01:04.280 --> 01:01:05.280
防斗什么

01:01:05.280 --> 01:01:07.280
防止这个寒树

01:01:07.280 --> 01:01:09.280
雕用的速率过高

01:01:10.280 --> 01:01:12.280
我把寒树传进去

01:01:12.280 --> 01:01:14.280
请你给我

01:01:14.280 --> 01:01:16.280
后面还给一个时间

01:01:16.280 --> 01:01:18.280
比方说传递个2秒钟

01:01:18.280 --> 01:01:19.280
3秒钟吧

01:01:19.280 --> 01:01:21.280
3秒钟之后

01:01:21.280 --> 01:01:22.280
关门

01:01:22.280 --> 01:01:24.280
请你给我返回一个新的寒树

01:01:24.280 --> 01:01:26.280
返回的是一个新的寒树

01:01:26.280 --> 01:01:29.280
当我雕用一个新的寒树的时候

01:01:29.280 --> 01:01:31.280
实际上是雕用了它

01:01:31.280 --> 01:01:32.280
只不过呢

01:01:32.280 --> 01:01:34.280
它不是立即雕用它

01:01:34.280 --> 01:01:36.280
请你延迟3秒钟之后

01:01:36.280 --> 01:01:37.280
雕用它

01:01:37.280 --> 01:01:38.280
这样子一来

01:01:38.280 --> 01:01:40.280
如果说我雕用的寒树非常频繁

01:01:40.280 --> 01:01:42.280
你看瞬间雕用5次

01:01:42.280 --> 01:01:43.280
不好意思

01:01:43.280 --> 01:01:46.280
我旨意最后一次为基础

01:01:46.280 --> 01:01:48.280
前面的事实就作废了

01:01:48.280 --> 01:01:49.280
就相当于没雕用

01:01:49.280 --> 01:01:51.280
我旨意最后一次为基准

01:01:51.280 --> 01:01:52.280
等待3秒钟

01:01:52.280 --> 01:01:54.280
雕用这个关门

01:01:54.280 --> 01:01:55.280
原来就是这么个意思

01:01:55.280 --> 01:01:57.280
那么希望的是

01:01:57.280 --> 01:02:00.280
3秒后输出5

01:02:00.280 --> 01:02:02.280
就这么个意思

01:02:02.280 --> 01:02:04.280
那么下面的例子是一样的

01:02:04.280 --> 01:02:05.280
我用一个寒树

01:02:05.280 --> 01:02:06.280
这个寒树可能不是关门

01:02:06.280 --> 01:02:07.280
它是把两个树相加

01:02:07.280 --> 01:02:08.280
然后输出

01:02:08.280 --> 01:02:10.280
然后我雕用这个地棒式

01:02:10.280 --> 01:02:13.280
我要这里面写的就是这个地棒式

01:02:13.280 --> 01:02:15.280
把这个寒树传进去

01:02:15.280 --> 01:02:16.280
传一个一秒

01:02:16.280 --> 01:02:18.280
返回一个新的寒树

01:02:18.280 --> 01:02:19.280
当我去雕用新的寒树的时候

01:02:19.280 --> 01:02:20.280
我可以传参

01:02:20.280 --> 01:02:21.280
其实就是雕用原来的寒树

01:02:21.280 --> 01:02:22.280
传一个一二

01:02:22.280 --> 01:02:23.280
它应该输出3

01:02:23.280 --> 01:02:25.280
但是它不是立即雕用原来的寒树

01:02:25.280 --> 01:02:27.280
等待3秒钟之后

01:02:27.280 --> 01:02:28.280
等待一秒钟之后

01:02:28.280 --> 01:02:30.280
因为说这里传的是1嘛

01:02:30.280 --> 01:02:31.280
等待一秒钟之后

01:02:31.280 --> 01:02:32.280
输出3

01:02:32.280 --> 01:02:34.280
然后马上就去雕用这个寒树

01:02:34.280 --> 01:02:36.280
那么之前的雕用作废

01:02:36.280 --> 01:02:37.280
又重新等待

01:02:37.280 --> 01:02:38.280
一秒钟之后

01:02:38.280 --> 01:02:39.280
输出5

01:02:39.280 --> 01:02:40.280
所以说最终只会看到输出5

01:02:40.280 --> 01:02:41.280
不会看到输出3

01:02:41.280 --> 01:02:42.280
那它到底有什么用

01:02:42.280 --> 01:02:43.280
以后我们在一个页面里面

01:02:43.280 --> 01:02:45.280
就可以看到它有什么用了

01:02:45.280 --> 01:02:47.280
好 咱们看一下这个地方

01:02:47.280 --> 01:02:48.280
怎么写

01:02:48.280 --> 01:02:50.280
你们能写出来吗

01:02:50.280 --> 01:02:52.280
你们有兴趣的同学

01:02:52.280 --> 01:02:54.280
可以去尝试一下

01:02:54.280 --> 01:02:56.280
但是我估计

01:02:56.280 --> 01:02:58.280
90%以上的同学

01:02:58.280 --> 01:03:00.280
都是自己写不出来的

01:03:00.280 --> 01:03:02.280
那么我们

01:03:02.280 --> 01:03:03.280
因为这个很正常

01:03:03.280 --> 01:03:04.280
这个寒树防刀

01:03:04.280 --> 01:03:05.280
对初学者还是很难的

01:03:05.280 --> 01:03:07.280
所以它代码没几

01:03:07.280 --> 01:03:09.280
这其实也从另一个方面

01:03:09.280 --> 01:03:10.280
就印证了咱们的开发

01:03:10.280 --> 01:03:11.280
并不是说你代码写的

01:03:11.280 --> 01:03:14.280
越多 你的能力就越强

01:03:14.280 --> 01:03:17.280
而是你能不能解决问题

01:03:17.280 --> 01:03:18.280
你的能力强不强到

01:03:18.280 --> 01:03:20.280
去学习能不能解决问题

01:03:20.280 --> 01:03:21.280
比如说解决问题

01:03:21.280 --> 01:03:23.280
它可能不需要解放代码

01:03:23.280 --> 01:03:25.280
但是你就是写不出来

01:03:25.280 --> 01:03:26.280
好 比方说咱们需要一个

01:03:26.280 --> 01:03:29.280
这么一个寒树叫D-Bounce

01:03:29.280 --> 01:03:30.280
这个寒树

01:03:30.280 --> 01:03:31.280
首先我们来考虑一下

01:03:31.280 --> 01:03:33.280
它有几个寒树

01:03:33.280 --> 01:03:35.280
你看一下怎么调用的吧

01:03:35.280 --> 01:03:36.280
它有几个寒树

01:03:36.280 --> 01:03:37.280
是不是有两个

01:03:37.280 --> 01:03:38.280
两个寒树对吧

01:03:38.280 --> 01:03:39.280
第一个寒树是什么

01:03:39.280 --> 01:03:42.280
一个我传一个寒树进来

01:03:42.280 --> 01:03:44.280
第二个参数

01:03:44.280 --> 01:03:45.280
你是什么

01:03:45.280 --> 01:03:47.280
一个我传一个时间进来

01:03:47.280 --> 01:03:50.280
等待多少时间调用这个寒树

01:03:50.280 --> 01:03:51.280
这时间

01:03:51.280 --> 01:03:52.280
其实我们也可以把

01:03:52.280 --> 01:03:53.280
设计的更合理一点

01:03:53.280 --> 01:03:54.280
你可以不传

01:03:54.280 --> 01:03:55.280
不传的话我就使用

01:03:55.280 --> 01:03:56.280
默认值一秒钟

01:03:56.280 --> 01:03:58.280
你当你传力的话

01:03:58.280 --> 01:03:59.280
比方说这里传三千

01:03:59.280 --> 01:04:00.280
那我就使用三千

01:04:00.280 --> 01:04:01.280
这里传了一千

01:04:01.280 --> 01:04:03.280
我就使用一千

01:04:03.280 --> 01:04:04.280
你不传的话

01:04:04.280 --> 01:04:05.280
我就默认就一千

01:04:05.280 --> 01:04:07.280
当然这个可以控制的

01:04:08.280 --> 01:04:10.280
接下来我们这里的

01:04:10.280 --> 01:04:12.280
这个寒树体怎么写的

01:04:12.280 --> 01:04:15.280
请问它返回的是啥

01:04:15.280 --> 01:04:18.280
这个寒树返回的是啥

01:04:18.280 --> 01:04:20.280
返回的是啥

01:04:20.280 --> 01:04:21.280
要不然我就先用那个

01:04:21.280 --> 01:04:23.280
方正音写吧

01:04:23.280 --> 01:04:24.280
写完之后再变成

01:04:24.280 --> 01:04:25.280
见到寒树

01:04:25.280 --> 01:04:27.280
没什么看着有点懵

01:04:27.280 --> 01:04:28.280
返回的是啥

01:04:28.280 --> 01:04:29.280
返回的是不是

01:04:29.280 --> 01:04:31.280
一个新的寒树

01:04:31.280 --> 01:04:33.280
对不对

01:04:33.280 --> 01:04:34.280
返回的是不是

01:04:34.280 --> 01:04:35.280
你看低棒是返回的

01:04:35.280 --> 01:04:36.280
一个新的寒树

01:04:36.280 --> 01:04:37.280
这里返回的是什么

01:04:37.280 --> 01:04:39.280
返回的是一个寒树

01:04:39.280 --> 01:04:41.280
对吧

01:04:41.280 --> 01:04:43.280
这个寒树有没有参数

01:04:43.280 --> 01:04:44.280
有可能有

01:04:44.280 --> 01:04:45.280
有可能没有

01:04:45.280 --> 01:04:46.280
你看这里

01:04:46.280 --> 01:04:47.280
这里就

01:04:47.280 --> 01:04:48.280
这个寒树就没有参数

01:04:48.280 --> 01:04:49.280
这个这里就是

01:04:49.280 --> 01:04:50.280
寒树就可能给它

01:04:50.280 --> 01:04:51.280
传了一些寒树

01:04:51.280 --> 01:04:52.280
这个低棒是寒树

01:04:52.280 --> 01:04:53.280
它并不知道

01:04:53.280 --> 01:04:54.280
返回的这个寒树

01:04:54.280 --> 01:04:55.280
有几个寒树

01:04:55.280 --> 01:04:56.280
那说不好了

01:04:56.280 --> 01:04:57.280
你看这个低棒是

01:04:57.280 --> 01:04:58.280
返回这个寒树

01:04:58.280 --> 01:04:59.280
叼了的时候

01:04:59.280 --> 01:05:00.280
它就没有传寒树

01:05:00.280 --> 01:05:01.280
那有的时候

01:05:01.280 --> 01:05:02.280
我低棒是这个寒树

01:05:02.280 --> 01:05:03.280
返回了过后

01:05:03.280 --> 01:05:04.280
叼了的时候

01:05:04.280 --> 01:05:05.280
它就传了寒树

01:05:05.280 --> 01:05:06.280
传几个寒树不知道

01:05:06.280 --> 01:05:07.280
那干嘛

01:05:07.280 --> 01:05:09.280
用圣语的寒树来接受

01:05:09.280 --> 01:05:11.280
那么这个寒树是对应什么的

01:05:11.280 --> 01:05:13.280
只要搞清楚

01:05:13.280 --> 01:05:18.380
这个寒树

01:05:18.380 --> 01:05:23.720
这个寒树相当于是

01:05:23.720 --> 01:05:24.720
你看

01:05:24.720 --> 01:05:28.290
这里传进去了

01:05:28.290 --> 01:05:29.290
对吧

01:05:29.290 --> 01:05:30.290
传进去了一个寒树

01:05:30.290 --> 01:05:31.290
那也是吧

01:05:31.290 --> 01:05:32.290
就是我们要掉用的

01:05:32.290 --> 01:05:33.290
目标寒树

01:05:33.290 --> 01:05:35.290
那么这个玩意是时间

01:05:35.290 --> 01:05:36.290
我尽量给你们讲

01:05:36.290 --> 01:05:38.290
你实在理解不了的话

01:05:38.290 --> 01:05:40.290
那很可能还需要一段时间的力量

01:05:40.290 --> 01:05:42.290
将来你们再回过头来看这个问题

01:05:42.290 --> 01:05:45.290
然后这个寒树

01:05:45.290 --> 01:05:47.290
是不是就相当于是

01:05:47.290 --> 01:05:49.290
它这里返回的这个寒树

01:05:49.290 --> 01:05:52.290
对吧

01:05:52.290 --> 01:05:53.290
雕用这个寒树

01:05:53.290 --> 01:05:56.290
是不是在雕用它

01:05:56.290 --> 01:05:58.290
对不对

01:05:58.290 --> 01:06:02.290
然后我们下面

01:06:02.290 --> 01:06:05.290
这里传递到一和二

01:06:05.290 --> 01:06:06.290
是不是相当于是

01:06:06.290 --> 01:06:09.290
把这个一和二传到这儿来了

01:06:09.290 --> 01:06:10.290
对吧

01:06:10.290 --> 01:06:12.290
那么这个寒树要干嘛

01:06:12.290 --> 01:06:14.290
你觉得这个寒树要干嘛

01:06:14.290 --> 01:06:16.290
这个寒树是不是目标就是雕用它呀

01:06:16.290 --> 01:06:18.290
但不是立即雕用

01:06:18.290 --> 01:06:19.290
什么时候雕用啊

01:06:19.290 --> 01:06:25.200
等待一段时间

01:06:25.200 --> 01:06:26.200
等待多久啊

01:06:26.200 --> 01:06:27.200
等待这么段时间

01:06:27.200 --> 01:06:29.200
然后雕用什么

01:06:29.200 --> 01:06:34.220
雕用fn的寒树

01:06:34.220 --> 01:06:36.220
不就这样吗

01:06:36.220 --> 01:06:38.220
是不是要雕用这个fn寒树

01:06:38.220 --> 01:06:39.220
等断一段时间之后

01:06:39.220 --> 01:06:40.220
雕用这个fn

01:06:40.220 --> 01:06:43.220
那么雕用fn的时候

01:06:43.220 --> 01:06:45.220
这个fn是不是有可能有参数啊

01:06:45.220 --> 01:06:46.220
你看这里没有参数

01:06:46.220 --> 01:06:47.220
但这里会有a和b

01:06:47.220 --> 01:06:48.220
是不是有可能有参数

01:06:48.220 --> 01:06:50.220
那么这里的几个参数

01:06:50.220 --> 01:06:52.220
是不是就相当于是这边传递来的

01:06:52.220 --> 01:06:56.220
一和二就传到这个a和b里面

01:06:56.220 --> 01:06:57.220
对吧

01:06:57.220 --> 01:06:59.220
这二和三就传到a和b里面

01:06:59.220 --> 01:07:00.220
对不对

01:07:00.220 --> 01:07:01.220
所以说呢

01:07:01.220 --> 01:07:03.220
我这个参数应该传啥

01:07:03.220 --> 01:07:04.220
是把这一部分传输传递来的

01:07:04.220 --> 01:07:08.720
而这个寒树是一个树树

01:07:08.720 --> 01:07:09.720
是不是收集

01:07:09.720 --> 01:07:10.720
一个要传到一个一和二

01:07:10.720 --> 01:07:11.720
那么就相当于是

01:07:11.720 --> 01:07:12.720
一和二变到一个树里面了

01:07:12.720 --> 01:07:14.720
但是我要把这个树树展开

01:07:14.720 --> 01:07:15.720
又变成一和二传进去

01:07:15.720 --> 01:07:17.720
是不是我们要把这个树树展开

01:07:17.720 --> 01:07:19.720
你看就写成这个样子

01:07:19.720 --> 01:07:21.720
单码其实不多

01:07:21.720 --> 01:07:23.720
就是不好理解

01:07:23.720 --> 01:07:26.720
完美 还有没完

01:07:26.720 --> 01:07:27.720
你这样做的话

01:07:27.720 --> 01:07:28.720
就会导致一个什么情况呢

01:07:28.720 --> 01:07:29.720
你看吧

01:07:29.720 --> 01:07:30.720
我们这样做了

01:07:30.720 --> 01:07:32.720
其实效果其实有可以看到的

01:07:32.720 --> 01:07:35.160
三秒钟

01:07:35.160 --> 01:07:36.160
三秒钟过了

01:07:36.160 --> 01:07:37.160
五个关门是不是输出了

01:07:37.160 --> 01:07:38.160
输出了五个关门

01:07:38.160 --> 01:07:39.160
因为我们调弄了五次

01:07:39.160 --> 01:07:41.160
每一次调弄关

01:07:41.160 --> 01:07:42.160
为什么会有五次

01:07:42.160 --> 01:07:44.160
第一次调弄这个6FN函数

01:07:44.160 --> 01:07:45.160
是不是相当于调弄它

01:07:45.160 --> 01:07:48.160
然后它等待了三秒钟

01:07:48.160 --> 01:07:50.160
三秒钟传件的

01:07:50.160 --> 01:07:51.160
等待了三秒钟

01:07:51.160 --> 01:07:52.160
然后调弄FN

01:07:52.160 --> 01:07:54.160
FN是不是就调弄关门

01:07:54.160 --> 01:07:55.160
那么也就是我们调弄了五次

01:07:55.160 --> 01:07:57.160
那么这一次等待三秒输出关门

01:07:57.160 --> 01:07:59.160
这一次等待三秒输出关门

01:07:59.160 --> 01:08:00.160
它是不是没有把

01:08:00.160 --> 01:08:01.160
后边调弄的时候

01:08:01.160 --> 01:08:02.160
没有把前面调弄清空啊

01:08:02.160 --> 01:08:04.160
那怎么清空

01:08:04.160 --> 01:08:08.160
是不是就停止之前的开门

01:08:08.160 --> 01:08:10.160
因此我们在这里的

01:08:10.160 --> 01:08:13.160
定议一个开门

01:08:13.160 --> 01:08:16.160
每一次调弄这个函数的时候

01:08:16.160 --> 01:08:18.160
我首先做了第一件事

01:08:18.160 --> 01:08:21.160
把这个开门清空

01:08:21.160 --> 01:08:23.160
也可能之前还有计时器

01:08:23.160 --> 01:08:24.160
如果说你之前

01:08:24.160 --> 01:08:25.160
下面下次用的是

01:08:25.160 --> 01:08:27.160
之前那个调弄

01:08:27.160 --> 01:08:28.160
三秒钟还没有等到

01:08:28.160 --> 01:08:29.160
没有等到的话

01:08:29.160 --> 01:08:30.160
你就继续给我等

01:08:30.160 --> 01:08:33.160
你就把之前的计时器清空

01:08:33.160 --> 01:08:34.160
那么之前的计时器

01:08:34.160 --> 01:08:35.160
清空是不是这个函数

01:08:35.160 --> 01:08:37.160
就不会执行了

01:08:37.160 --> 01:08:38.160
然后我们每一次

01:08:38.160 --> 01:08:40.160
这次开门的时候

01:08:40.160 --> 01:08:42.160
把一个开门复制

01:08:42.160 --> 01:08:44.160
不是很好理解啊

01:08:44.160 --> 01:08:46.160
函数防斗呢

01:08:46.160 --> 01:08:49.160
是介绍的一个设计模式

01:08:49.160 --> 01:08:50.160
设计模式对初学者来说

01:08:50.160 --> 01:08:53.160
都是难度极高的

01:08:53.160 --> 01:08:54.160
你尽量看吧

01:08:54.160 --> 01:08:56.160
你说实在不理解的话

01:08:56.160 --> 01:08:58.160
你也不太会影响

01:08:58.160 --> 01:09:00.160
你后边的学习

01:09:00.160 --> 01:09:01.160
但是呢这个函数

01:09:01.160 --> 01:09:02.160
写完了之后

01:09:02.160 --> 01:09:04.160
有一个要求就是

01:09:04.160 --> 01:09:05.160
你在知道怎么用

01:09:05.160 --> 01:09:06.160
不然的话一些效果

01:09:06.160 --> 01:09:07.160
你做不出来

01:09:07.160 --> 01:09:08.160
就是你这个函数

01:09:08.160 --> 01:09:09.160
不知道怎么写没关系

01:09:09.160 --> 01:09:11.160
你实在听不懂

01:09:11.160 --> 01:09:12.160
那么现在听不懂的话

01:09:12.160 --> 01:09:13.160
你将来可以尝试一下

01:09:13.160 --> 01:09:15.160
有了一定代码量之后

01:09:15.160 --> 01:09:16.160
你可以尝试一下

01:09:16.160 --> 01:09:17.160
因为现在的可能同学们

01:09:17.160 --> 01:09:18.160
有一些同学连

01:09:18.160 --> 01:09:20.160
三千行代码都没有写到

01:09:20.160 --> 01:09:21.160
拿你这个代码量

01:09:21.160 --> 01:09:22.160
你要听懂这个

01:09:22.160 --> 01:09:24.160
那太难为你了

01:09:24.160 --> 01:09:25.160
做不到的

01:09:25.160 --> 01:09:27.160
你走到哪一个阶段

01:09:27.160 --> 01:09:28.160
你才能听懂哪一些

01:09:28.160 --> 01:09:30.160
概念和原因

01:09:30.160 --> 01:09:31.160
你看既然没到

01:09:31.160 --> 01:09:32.160
到了一个阶段

01:09:32.160 --> 01:09:33.160
你可能就听不懂

01:09:33.160 --> 01:09:34.160
有些代码量写的

01:09:34.160 --> 01:09:35.160
比较多的话

01:09:35.160 --> 01:09:38.160
就有那么一种感觉了

01:09:38.160 --> 01:09:39.160
现在听不懂没关系

01:09:39.160 --> 01:09:40.160
但是呢

01:09:40.160 --> 01:09:42.160
这个函数就是拿给你之后

01:09:42.160 --> 01:09:43.160
你或者是网上去

01:09:43.160 --> 01:09:44.160
收一下函数房子

01:09:44.160 --> 01:09:45.160
一大堆

01:09:45.160 --> 01:09:46.160
把口笔进来过后

01:09:46.160 --> 01:09:47.160
你要知道怎么用

01:09:47.160 --> 01:09:49.160
这个很重要

01:09:49.160 --> 01:09:51.160
好那么现在我们来看一下

01:09:51.160 --> 01:09:54.160
效果就打到了

01:09:54.160 --> 01:09:55.160
三秒钟之后

01:09:55.160 --> 01:09:56.160
输出一个画面

01:09:56.160 --> 01:09:59.860
之前的画面都被清除掉了

01:09:59.860 --> 01:10:00.860
好那么现在我们再看一下

01:10:00.860 --> 01:10:01.860
下面的

01:10:01.860 --> 01:10:06.770
下面的行不行

01:10:06.770 --> 01:10:08.770
一秒钟之后输出

01:10:08.770 --> 01:10:11.770
一和二的相架就没了

01:10:11.770 --> 01:10:17.140
至于他具体怎么在一秒钟使用

01:10:17.140 --> 01:10:19.140
我们一会儿会说

01:10:19.140 --> 01:10:20.140
好那么接下来

01:10:20.140 --> 01:10:21.140
我们把它改造成箭头函数

01:10:21.140 --> 01:10:22.140
你看

01:10:22.140 --> 01:10:28.270
方可信去掉

01:10:28.270 --> 01:10:29.270
是吧

01:10:29.270 --> 01:10:30.270
箭头函数了

01:10:30.270 --> 01:10:31.270
那么这个玩意

01:10:31.270 --> 01:10:34.270
也可以把它变成箭头函数

01:10:34.270 --> 01:10:35.270
对吧

01:10:35.270 --> 01:10:38.270
那么这是一个箭头函数

01:10:38.270 --> 01:10:39.270
那你看

01:10:39.270 --> 01:10:41.270
我们这里有一个天梦

01:10:41.270 --> 01:10:42.270
对吧

01:10:43.270 --> 01:10:45.270
就显成这样子吧

01:10:45.270 --> 01:10:46.270
我不想再进一步减化了

01:10:46.270 --> 01:10:47.270
进一步减化的话

01:10:47.270 --> 01:10:48.270
这个单看上去有点难看

01:10:48.270 --> 01:10:50.270
算了我就这样吧

01:10:50.270 --> 01:10:52.270
OK把改成箭头函数就这样子

01:10:53.270 --> 01:10:57.270
好了那么这是函数防斗

01:10:57.270 --> 01:10:58.270
写完了

01:10:58.270 --> 01:10:59.270
那么怎么用了

01:10:59.270 --> 01:11:00.270
这个函数已经写好了

01:11:00.270 --> 01:11:01.270
地棒式

01:11:01.270 --> 01:11:03.270
下面这道题就可以使用了

01:11:03.270 --> 01:11:05.270
这是一个页面

01:11:05.270 --> 01:11:07.270
这个页面中有一个文本框

01:11:07.270 --> 01:11:08.270
你看

01:11:08.270 --> 01:11:11.740
有一个文本框

01:11:11.740 --> 01:11:13.740
我们会在文本框里面

01:11:13.740 --> 01:11:15.740
去输入一些文字

01:11:15.740 --> 01:11:16.740
现在的要求是

01:11:16.740 --> 01:11:19.740
我要监听文本框文字的变化

01:11:20.740 --> 01:11:21.740
然后呢

01:11:21.740 --> 01:11:22.740
当文字发生变化的时候

01:11:22.740 --> 01:11:23.740
我可能要把这个文字

01:11:23.740 --> 01:11:25.740
拿到去做一些别的事

01:11:25.740 --> 01:11:26.740
那这里呢

01:11:26.740 --> 01:11:27.740
我就把这个文字输出就完成了

01:11:27.740 --> 01:11:29.740
我们也可以写个P元数

01:11:29.740 --> 01:11:31.740
或者是写个什么元数

01:11:31.740 --> 01:11:32.740
把它文字放到元数里面

01:11:32.740 --> 01:11:33.740
也可以

01:11:33.740 --> 01:11:34.740
那么比方说

01:11:34.740 --> 01:11:35.740
写个P元数吧

01:11:35.740 --> 01:11:36.740
我就不输出了

01:11:36.740 --> 01:11:38.740
当然输出也没问题

01:11:38.740 --> 01:11:39.740
都是一样的效果

01:11:39.740 --> 01:11:40.740
那么现在呢

01:11:40.740 --> 01:11:41.740
我们去拿到两个元数

01:11:41.740 --> 01:11:42.740
一个是文本框

01:11:43.740 --> 01:11:47.180
Document

01:11:47.180 --> 01:11:48.180
Curry

01:11:48.180 --> 01:11:50.180
Input

01:11:50.180 --> 01:11:52.180
一个是P元数

01:11:52.180 --> 01:11:54.620
好

01:11:54.620 --> 01:11:55.620
接下来

01:11:55.620 --> 01:11:56.620
我干嘛

01:11:56.620 --> 01:11:57.620
如果说我们不进行

01:11:57.620 --> 01:11:58.620
寒宿防抖的话

01:11:58.620 --> 01:11:59.620
我们要做什么呢

01:11:59.620 --> 01:12:01.620
就是文本框的

01:12:01.620 --> 01:12:02.620
给它添加一个时间

01:12:02.620 --> 01:12:03.620
LTT

01:12:03.620 --> 01:12:04.620
什么时间呢

01:12:04.620 --> 01:12:05.620
就是Input的时间

01:12:05.620 --> 01:12:06.620
我们框内容

01:12:06.620 --> 01:12:07.620
时时间精

01:12:07.620 --> 01:12:09.620
它变化的时间

01:12:09.620 --> 01:12:10.620
变化的时候

01:12:10.620 --> 01:12:11.620
我们这里就可以用那个

01:12:11.620 --> 01:12:12.620
建筒寒宿吧

01:12:12.620 --> 01:12:13.620
我们之前一直用的是

01:12:13.620 --> 01:12:14.620
防折型的

01:12:14.620 --> 01:12:15.620
这一种建筒寒宿

01:12:15.620 --> 01:12:16.620
好

01:12:16.620 --> 01:12:18.620
当发生变化的时候呢

01:12:18.620 --> 01:12:20.620
我把这个文本框的东西拿到

01:12:20.620 --> 01:12:21.620
但是注意

01:12:21.620 --> 01:12:22.620
这里边Z就出问题了

01:12:22.620 --> 01:12:23.620
因为是建筒寒宿

01:12:23.620 --> 01:12:24.620
Z用的是什么

01:12:24.620 --> 01:12:25.620
用的是外面的Z

01:12:25.620 --> 01:12:27.620
所以这里的Z是指向谁

01:12:27.620 --> 01:12:28.620
指向的是Windows

01:12:28.620 --> 01:12:32.340
你看一下

01:12:32.340 --> 01:12:33.340
这里

01:12:33.340 --> 01:12:34.340
你看指向的Windows

01:12:34.340 --> 01:12:35.340
对吧

01:12:35.340 --> 01:12:37.340
这些Z是要注意

01:12:37.340 --> 01:12:38.340
你可以使用建筒寒宿

01:12:38.340 --> 01:12:39.340
Z是指向里面的

01:12:39.340 --> 01:12:41.340
那么这边我们就

01:12:41.340 --> 01:12:42.340
给什么

01:12:42.340 --> 01:12:45.340
给P元数的InnerText

01:12:45.340 --> 01:12:46.340
复制

01:12:46.340 --> 01:12:47.340
复制为什么呢

01:12:47.340 --> 01:12:48.340
复制为P

01:12:48.340 --> 01:12:51.340
复制为Input的Value

01:12:51.340 --> 01:12:53.340
是不是我这里一写

01:12:53.340 --> 01:12:55.340
去演书就变化了

01:12:55.340 --> 01:12:56.340
对吧

01:12:56.340 --> 01:12:57.340
我这里一写

01:12:57.340 --> 01:12:58.340
去演书就变化了

01:12:58.340 --> 01:13:02.860
对不对

01:13:02.860 --> 01:13:03.860
好

01:13:03.860 --> 01:13:04.860
但是这样子做好不好

01:13:04.860 --> 01:13:05.860
这样做

01:13:05.860 --> 01:13:07.860
实际上是不好的

01:13:07.860 --> 01:13:08.860
为什么不好呢

01:13:08.860 --> 01:13:10.860
因为我这个文本框

01:13:10.860 --> 01:13:12.860
变化太快了

01:13:12.860 --> 01:13:13.860
我比方说有些手术很快

01:13:13.860 --> 01:13:14.860
大家不停的打字

01:13:14.860 --> 01:13:15.860
手术很快

01:13:15.860 --> 01:13:17.860
变化太快了

01:13:17.860 --> 01:13:19.860
我文本框都还没有写完

01:13:19.860 --> 01:13:20.860
你就很着急的去

01:13:20.860 --> 01:13:21.860
设置个P元数的内容

01:13:21.860 --> 01:13:23.860
是不是会影响效率

01:13:23.860 --> 01:13:24.860
通常出现在什么时候呢

01:13:24.860 --> 01:13:26.860
比方你在百度里边

01:13:26.860 --> 01:13:28.860
去做一些搜索的时候

01:13:28.860 --> 01:13:29.860
你说他等会

01:13:29.860 --> 01:13:30.860
等你打完了之后

01:13:30.860 --> 01:13:32.860
才会给你显示

01:13:32.860 --> 01:13:33.860
那他是怎么做到的呢

01:13:33.860 --> 01:13:35.860
他就是用函数房等

01:13:35.860 --> 01:13:37.860
我在这里变化内容的时候

01:13:37.860 --> 01:13:39.860
不要那么着急的去

01:13:39.860 --> 01:13:40.860
做一些事

01:13:40.860 --> 01:13:41.860
我稍微的等一下

01:13:41.860 --> 01:13:42.860
万一等的这段时间

01:13:42.860 --> 01:13:44.860
又有别的设计来了呢

01:13:44.860 --> 01:13:45.860
比方在电梯里边

01:13:45.860 --> 01:13:46.860
刚进来一个人

01:13:46.860 --> 01:13:47.860
我马上就关门了

01:13:47.860 --> 01:13:49.860
那后面的人就进不来了

01:13:49.860 --> 01:13:50.860
所以我稍微等一下

01:13:50.860 --> 01:13:51.860
等一下之后的人

01:13:51.860 --> 01:13:52.860
进来了过后

01:13:52.860 --> 01:13:53.860
我重新计时

01:13:53.860 --> 01:13:55.860
这就是用函数房等

01:13:55.860 --> 01:13:57.860
好 那么具体怎么做的呢

01:13:57.860 --> 01:14:06.140
我们把函数房的楼单拿过来

01:14:06.140 --> 01:14:08.140
拿过来 人在那就行了

01:14:08.140 --> 01:14:09.140
比方说我这里

01:14:09.140 --> 01:14:10.140
使时间设置的

01:14:10.140 --> 01:14:11.140
就夸张一点

01:14:11.140 --> 01:14:12.140
就一秒钟

01:14:12.140 --> 01:14:13.140
我希望你每一次

01:14:13.140 --> 01:14:16.140
自变化的时候

01:14:16.140 --> 01:14:17.140
运行一个函数

01:14:17.140 --> 01:14:18.140
那个函数的做的事

01:14:18.140 --> 01:14:19.140
不是立即做

01:14:19.140 --> 01:14:21.140
它是等一秒钟之后再做

01:14:21.140 --> 01:14:22.140
那怎么办

01:14:22.140 --> 01:14:23.140
你看着

01:14:23.140 --> 01:14:25.140
我就这样子写

01:14:25.140 --> 01:14:26.140
第一棒是

01:14:26.140 --> 01:14:27.140
第一个函数

01:14:27.140 --> 01:14:28.140
传函数

01:14:28.140 --> 01:14:30.140
我就把这个函数

01:14:30.140 --> 01:14:31.140
传进去

01:14:31.140 --> 01:14:33.140
你不就是要运行这个函数吗

01:14:33.140 --> 01:14:35.140
然后等待的时间

01:14:35.140 --> 01:14:36.140
就一秒

01:14:36.140 --> 01:14:37.140
就默认为一秒

01:14:37.140 --> 01:14:38.140
我就不传第二个函数

01:14:38.140 --> 01:14:39.140
当然你要改时间的话

01:14:39.140 --> 01:14:40.140
你可以传第二个函数

01:14:40.140 --> 01:14:41.140
不要传成500

01:14:41.140 --> 01:14:42.140
传成1500

01:14:42.140 --> 01:14:43.140
都可以

01:14:43.140 --> 01:14:44.140
第一个函数

01:14:44.140 --> 01:14:45.140
是一个函数

01:14:45.140 --> 01:14:46.140
给它传进去

01:14:46.140 --> 01:14:47.140
第二个函数

01:14:47.140 --> 01:14:48.140
是一个时间

01:14:48.140 --> 01:14:49.140
当然这个函数

01:14:49.140 --> 01:14:50.140
你可以把

01:14:50.140 --> 01:14:51.140
老师

01:14:51.140 --> 01:14:53.140
你刚才不是这样子写的吗

01:14:53.140 --> 01:14:54.140
有啥区别

01:14:54.140 --> 01:14:56.140
同学

01:14:56.140 --> 01:14:57.140
有啥区别

01:14:57.140 --> 01:14:58.140
你说这个玩意

01:14:58.140 --> 01:15:00.140
你把这个变量放这

01:15:00.140 --> 01:15:01.140
变量里面不就是个函数吗

01:15:01.140 --> 01:15:02.140
好吧

01:15:02.140 --> 01:15:03.140
函数表达是直接放这

01:15:03.140 --> 01:15:04.140
有啥区别呢

01:15:04.140 --> 01:15:05.140
都一下

01:15:06.140 --> 01:15:07.140
学程序学蒙了

01:15:10.140 --> 01:15:12.140
它返回啥

01:15:12.140 --> 01:15:14.140
所以返回一个新的函数

01:15:15.140 --> 01:15:17.140
对不对

01:15:17.140 --> 01:15:19.140
用变量接收一下

01:15:20.140 --> 01:15:22.140
那么我们只要把这个新的函数

01:15:22.140 --> 01:15:23.140
放这

01:15:23.140 --> 01:15:24.140
就完了

01:15:24.140 --> 01:15:27.140
你文本框内容改变的时候

01:15:27.140 --> 01:15:28.140
去调这个函数

01:15:28.140 --> 01:15:30.140
你去给我调这个函数

01:15:31.140 --> 01:15:32.140
这个函数有什么特点

01:15:32.140 --> 01:15:34.140
它不会立即执行它

01:15:35.140 --> 01:15:37.140
而是会等1500毫秒

01:15:37.140 --> 01:15:38.140
再去执行

01:15:38.140 --> 01:15:39.140
比方说得写个A

01:15:40.140 --> 01:15:41.140
别保持了

01:15:41.140 --> 01:15:42.140
写个A

01:15:43.140 --> 01:15:45.140
等1500毫秒才会执行

01:15:45.140 --> 01:15:46.140
一执行这个函数

01:15:46.140 --> 01:15:47.140
是不是就设置到这个文本

01:15:48.140 --> 01:15:49.140
对吧

01:15:49.140 --> 01:15:50.140
如果说

01:15:50.140 --> 01:15:51.140
我在这里边不停的写

01:15:51.140 --> 01:15:52.140
不停的写

01:15:53.140 --> 01:15:54.140
写完了

01:15:54.140 --> 01:15:56.140
等1500毫秒才会执行

01:15:57.140 --> 01:15:58.140
那么跟这边的搜索

01:15:58.140 --> 01:15:59.140
是不是一样的效果

01:15:59.140 --> 01:16:00.140
它会等你

01:16:01.140 --> 01:16:03.140
这个没有这样的提示

01:16:03.140 --> 01:16:04.140
它会等你

01:16:05.140 --> 01:16:07.140
等你写完了之后

01:16:07.140 --> 01:16:13.530
它的时间比较短而已

01:16:13.530 --> 01:16:15.530
等你写完了之后

01:16:15.530 --> 01:16:16.530
才会去做一些事

01:16:16.530 --> 01:16:17.530
那么这里是一样的

01:16:18.530 --> 01:16:19.530
它会等你1500毫秒

01:16:19.530 --> 01:16:20.530
当然我们平时的开发

01:16:20.530 --> 01:16:22.530
一般不会射那么长的时间

01:16:22.530 --> 01:16:23.530
一般是个100毫秒

01:16:23.530 --> 01:16:24.530
为了300毫秒

01:16:24.530 --> 01:16:25.530
差不多

01:16:29.630 --> 01:16:31.630
这样子的函数的执行次数

01:16:31.630 --> 01:16:33.630
它就没有那么平准反了

01:16:34.630 --> 01:16:35.630
来提高效率

01:16:35.630 --> 01:16:36.630
那么这种情况

01:16:36.630 --> 01:16:38.630
还不仅用在文本框的

01:16:38.630 --> 01:16:39.630
事件里边

01:16:39.630 --> 01:16:40.630
还用的时候用的一些

01:16:40.630 --> 01:16:42.630
滚动事件里边也可以

01:16:42.630 --> 01:16:44.630
滚动事件里边也可以

01:16:44.630 --> 01:16:45.630
比方说没在随便举个例子

01:16:45.630 --> 01:16:47.630
我就把这个白马扶着

01:16:47.630 --> 01:16:48.630
啤酒

01:16:49.630 --> 01:16:52.630
我这页面上多加一些内容

01:16:53.630 --> 01:16:54.630
100个吧

01:16:55.630 --> 01:17:01.210
有的时候

01:17:01.210 --> 01:17:02.210
我们可能要监听

01:17:02.210 --> 01:17:03.210
页面上的滚动事件

01:17:03.210 --> 01:17:04.210
你知道滚动事件

01:17:04.210 --> 01:17:06.210
触发的是非常非常平凡的

01:17:06.210 --> 01:17:07.210
对不对

01:17:07.210 --> 01:17:08.210
而滚动的时候

01:17:08.210 --> 01:17:09.210
我们可能要去做一些

01:17:09.210 --> 01:17:10.210
比较耗时的操作

01:17:10.210 --> 01:17:11.210
比方说

01:17:11.210 --> 01:17:12.210
我们这里

01:17:12.210 --> 01:17:13.210
监听什么

01:17:13.210 --> 01:17:14.210
监听滚动事件

01:17:14.210 --> 01:17:15.210
Windows

01:17:15.210 --> 01:17:16.210
Eddy Inventor

01:17:16.210 --> 01:17:17.210
Unscrew

01:17:17.210 --> 01:17:18.210
滚动事件

01:17:18.210 --> 01:17:19.210
而滚动的时候

01:17:19.210 --> 01:17:20.210
我们可能要去做一些

01:17:20.210 --> 01:17:21.210
比较耗时的操作

01:17:21.210 --> 01:17:23.210
我这里就用输出代替了

01:17:23.210 --> 01:17:24.210
滚动了

01:17:25.210 --> 01:17:27.210
咱们来看一下滚动事件

01:17:27.210 --> 01:17:28.210
触发的特别平凡

01:17:28.210 --> 01:17:29.210
你看

01:17:30.210 --> 01:17:31.210
但是我

01:17:31.210 --> 01:17:32.210
不需要你触发的那么

01:17:32.210 --> 01:17:33.210
不需要那么平凡的

01:17:33.210 --> 01:17:34.210
去做这件事

01:17:34.210 --> 01:17:36.210
我只需要稍微等一下

01:17:36.210 --> 01:17:38.210
而你等你滚动停下来之后

01:17:38.210 --> 01:17:39.210
我再去做这个事

01:17:39.210 --> 01:17:40.210
那怎么办

01:17:40.210 --> 01:17:42.210
就可以使用寒暑防斗

01:17:42.210 --> 01:17:43.210
比方说我要做的事

01:17:43.210 --> 01:17:44.210
我就可以把它用

01:17:44.210 --> 01:17:45.210
地棒室处理一下

01:17:47.710 --> 01:17:48.710
滚动了

01:17:48.710 --> 01:17:49.710
时间的话

01:17:49.710 --> 01:17:51.710
就让它默认值1000

01:17:51.710 --> 01:17:52.710
返回一个新的寒暑

01:17:53.710 --> 01:17:54.710
Handle

01:17:55.710 --> 01:17:56.710
把这个Handle放进去

01:17:56.710 --> 01:17:57.710
就这么简单

01:17:58.710 --> 01:17:59.710
这样子

01:17:59.710 --> 01:18:00.710
它每一次滚动

01:18:00.710 --> 01:18:01.710
运行的是它

01:18:01.710 --> 01:18:02.710
运行的是它

01:18:02.710 --> 01:18:03.710
它会说什么

01:18:03.710 --> 01:18:04.710
它会等一秒钟

01:18:04.710 --> 01:18:05.710
才会运行它

01:18:06.710 --> 01:18:07.710
如果说等待的期间

01:18:07.710 --> 01:18:08.710
又触发

01:18:08.710 --> 01:18:09.710
又掉入这个寒暑

01:18:09.710 --> 01:18:10.710
又被滚动了

01:18:10.710 --> 01:18:11.710
那么它就会取消

01:18:11.710 --> 01:18:12.710
之前的计时

01:18:12.710 --> 01:18:13.710
重新计时

01:18:13.710 --> 01:18:14.710
那你看

01:18:14.710 --> 01:18:15.710
现在

01:18:16.710 --> 01:18:17.710
一开始有触发了一次

01:18:17.710 --> 01:18:18.710
然后既然我滚动

01:18:18.710 --> 01:18:19.710
你看有没有触发

01:18:19.710 --> 01:18:20.710
我不停地在滚动

01:18:21.710 --> 01:18:22.710
它会等你停下来之后

01:18:23.710 --> 01:18:24.710
才会触发一次

01:18:24.710 --> 01:18:25.710
一秒钟之后

01:18:25.710 --> 01:18:26.710
才会触发

01:18:26.710 --> 01:18:27.710
像这样子

01:18:27.710 --> 01:18:28.710
降低了这个寒暑

01:18:29.710 --> 01:18:30.710
的运行频率

01:18:30.710 --> 01:18:31.710
提高了小率

01:18:32.710 --> 01:18:34.710
这就是这么一个寒暑防斗

01:18:35.710 --> 01:18:36.710
好了

01:18:36.710 --> 01:18:37.710
同学们

01:18:37.710 --> 01:18:38.710
这个地棒是写不出来

01:18:38.710 --> 01:18:39.710
实在写不出来

01:18:39.710 --> 01:18:40.710
没关系

01:18:40.710 --> 01:18:41.710
但是我给你写出来之后

01:18:41.710 --> 01:18:42.710
你要知道

01:18:42.710 --> 01:18:44.710
怎么去用

01:18:44.710 --> 01:18:46.710
以后用要学会

01:18:46.710 --> 01:18:48.710
因为你们以后的公司

01:18:48.710 --> 01:18:49.710
这个玩意儿是真的有用的

01:18:49.710 --> 01:18:50.710
它不是说

01:18:50.710 --> 01:18:52.710
仅仅是为了面试着火箭

01:18:52.710 --> 01:18:53.710
它是真儿八经有用

01:18:54.710 --> 01:18:55.710
刚才例子

01:18:56.710 --> 01:18:58.710
这就是咱们这几课的内容

01:18:58.710 --> 01:18:59.710
这几课咱们学的寒暑

01:18:59.710 --> 01:19:00.710
就跟我们比较相关的

01:19:00.710 --> 01:19:01.710
也就是

01:19:01.710 --> 01:19:02.710
见到寒暑

01:19:02.710 --> 01:19:03.710
生云寒暑和寒暑末人籽

01:19:03.710 --> 01:19:04.710
其实最

01:19:04.710 --> 01:19:05.710
用了最多的就是见到寒暑

01:19:05.710 --> 01:19:06.710
这两个东西

01:19:07.710 --> 01:19:09.710
跟你们目前没有多少关系

01:19:09.710 --> 01:19:10.710
以后肯定是有关系的

01:19:11.710 --> 01:19:12.710
目标

01:19:12.710 --> 01:19:13.710
就是把作业题完成

01:19:15.710 --> 01:19:16.710
没问题吧

01:19:16.710 --> 01:19:17.710
把这些题完成

01:19:17.710 --> 01:19:18.710
好

01:19:18.710 --> 01:19:19.710
那么咱们这几课

01:19:19.710 --> 01:19:20.710
就到这了

01:19:20.710 --> 01:19:21.710
拜拜

