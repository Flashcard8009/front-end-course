WEBVTT

00:00.560 --> 00:06.960
从这节开始 咱们后边几节课啊 讲的都是一些烧烧作啊

00:06.960 --> 00:13.360
这些烧烧作呢 对我们后边进行开发呢 很多时候呢 能够起到不少的帮助

00:13.360 --> 00:17.960
咱们这节课呢 现在讲这么两个操作啊 都是用已有的知识啊

00:17.960 --> 00:22.960
不再有什么新知识了 可能有一点点新知识啊 可能很少很少了啊

00:22.960 --> 00:26.560
这一课呢 讲的是对象混合和对象克农

00:26.960 --> 00:31.560
好 咱们呢 比方说啊 先说这个对象混合吧 先说对象混合

00:31.560 --> 00:36.960
什么叫对象混合了 就是说我们有两个对象啊 有两 有两个对象

00:37.960 --> 00:45.560
两个对象 混合后啊 混合后产生一个新对象啊 新对象

00:46.360 --> 00:49.960
这个解释起来呢 比较的抽象 我们这里直接用例子来解释吧

00:50.760 --> 00:52.960
比方说 我们这里呢 有一个对象e

00:53.960 --> 01:01.360
obj1 他有一些属性啊 比方说x 啊 随便写写属性吗 y 3 z

01:01.960 --> 01:05.960
5 啊 随便写写属性 然后呢 还有个对象2

01:07.360 --> 01:07.960
obj2

01:08.960 --> 01:13.360
然后呢 他里边有哪些属性的 比方说也有一个x x呢 是abc

01:13.960 --> 01:19.360
也有一个z z的话是bcd 随便写啊 还有一个就是

01:19.960 --> 01:23.960
h 啊 h 啊 随便写啊 a a a

01:24.960 --> 01:30.360
啊 这里呢就写了两个对象 现在呢我们要把obj1和obj2混合

01:30.860 --> 01:36.660
混合之后呢产生一个新的对象 产生一个新的对象 那么混合的方式呢是这样子

01:37.160 --> 01:39.660
就是他涉及到哪个在前哪个在后

01:40.460 --> 01:44.660
就是说我们可以这样子说把obj2混合到obj1中

01:45.660 --> 01:49.260
如果玩 如果是这种说法的话 是什么意思呢 就是obj2

01:49.560 --> 01:53.160
如果里边跟obj1有同名属性的话 进行覆盖

01:53.860 --> 01:58.460
如果没有同名属性的话 那么只是直接复制过去 好比方说啊

01:58.860 --> 02:05.060
如果obj2 混合到 混合到obj1 那么我们

02:06.260 --> 02:09.060
这样子混合的结果是什么呢 混合的结果就应该是这样子

02:09.560 --> 02:11.960
x呢等于多少 abc

02:12.860 --> 02:17.060
就是混合的结果一个新的对象啊obj3 混合的结果呢应该是这样子

02:17.860 --> 02:20.860
x呢 x呢等于abc

02:20.860 --> 02:23.860
你看x不是同名的对吧 就把之前的覆盖掉了

02:24.360 --> 02:25.160
好然后呢

02:27.760 --> 02:31.760
y y没动对吧 y没有同名没动就不变啊3

02:32.360 --> 02:36.460
然后呢z z是不是同名的啊 z同名的话覆盖掉bcd

02:37.160 --> 02:39.960
好 h呢 h不同名啊就是 a a

02:40.360 --> 02:41.760
看没有 这就是混合的结果

02:42.560 --> 02:44.560
懂这个意思吧 这叫对象混合

02:44.860 --> 02:50.060
把obj2 混合到obj1 那么obj2里边有的obj1也有的

02:50.060 --> 02:53.360
那么obj2覆盖obj1 没有的话就全部保留

02:54.060 --> 02:57.760
那如果反过来obj1 混合到obj2呢啊

02:58.260 --> 03:01.360
如果混合到obj2呢 那这种情况呢 是不是相反的对吧

03:01.560 --> 03:04.060
如果是这种情况的话 那就是x为1

03:04.460 --> 03:08.760
然后 y呢 w3 z呢 w5

03:09.360 --> 03:12.360
然后呢 这边是h呢 w a

03:12.860 --> 03:15.460
对吧 这就是对象混合

03:15.860 --> 03:19.160
混合呢 我们通常有一个单词 在js里面混合

03:19.860 --> 03:22.560
其实是一个经常发生的事情 经常要用到的

03:22.560 --> 03:25.360
我们一会会说它的一些场景

03:26.460 --> 03:27.760
mixing表示混合

03:28.460 --> 03:31.860
好 因此呢 我们这里呢 干脆直接在插件里边

03:32.260 --> 03:35.460
在这个插件里边加一个js 加一个js

03:35.560 --> 03:36.660
给它加到这个什么

03:37.360 --> 03:38.860
helps

03:39.160 --> 03:40.960
我们之前写过继承 对吧 在这里边

03:41.260 --> 03:42.460
这里写的是继承

03:43.560 --> 03:44.060
继承

03:46.260 --> 03:46.760
继承

03:47.060 --> 03:49.260
那么这里呢 我们再写一些 再写一些

03:49.860 --> 03:52.260
js.myplugin

03:52.760 --> 03:55.660
再加一个 加一个什么呢 mixin 混合

03:56.360 --> 03:58.860
混合呢 它也是个函数 也是一个函数

03:59.260 --> 04:01.660
这个函数呢 我们给它两个参数

04:01.760 --> 04:03.560
两个对象吧 对吧 两个对象

04:04.060 --> 04:06.060
一个是obj

04:06.360 --> 04:08.260
obj1obj2

04:09.360 --> 04:10.160
写这么两个对象

04:11.060 --> 04:13.260
好 对这两个对象来进行混合

04:13.460 --> 04:14.360
来进行混合

04:14.460 --> 04:17.960
把obj2混合到obj1 产生一个新的对象

04:18.860 --> 04:26.260
obj2混合到obj1 产生新的对象

04:27.460 --> 04:29.260
看一下这个该怎么来写的代码呢

04:29.660 --> 04:30.460
该怎么来写呢

04:30.960 --> 04:33.460
就是obj2的是不是所有属性都要保留

04:33.460 --> 04:35.660
对吧obj2的所有属性保留

04:35.860 --> 04:37.760
然后obj1里面有的属性

04:37.760 --> 04:39.660
但是obj2里面没有的呢

04:39.960 --> 04:41.060
也保留 对吧

04:41.160 --> 04:44.060
其实就是基本的思路就很简单

04:44.160 --> 04:46.860
就是obj2里面的所有属性全部保留

04:46.960 --> 04:50.860
然后obj1里面有的属性呢obj2里面没有

04:50.860 --> 04:52.960
那么obj1的这些属性也要保留

04:53.460 --> 04:54.760
就完了 对不对 就完了

04:54.860 --> 04:55.760
这就是一个混合

04:56.960 --> 04:58.060
好 那么咱们来做吧

04:58.360 --> 04:59.260
咱们来做一下

05:00.260 --> 05:02.360
首先obj2的属性全部保留

05:02.460 --> 05:04.760
那么有些同学可能会这样子写obj3

05:05.460 --> 05:06.760
就是产生那个新对象吧 对吧

05:06.760 --> 05:07.560
liuobj

05:09.560 --> 05:11.160
他可能直接等于obj2

05:11.160 --> 05:13.060
但是你这样做了过后会有风险

05:13.060 --> 05:13.460
为什么呢

05:13.460 --> 05:15.860
后边我们肯定是要给他要加属性对吧

05:15.960 --> 05:16.760
加什么属性

05:16.860 --> 05:18.460
加那些obj1里面有

05:18.460 --> 05:20.060
但是obj2里面没有的属性

05:20.060 --> 05:21.060
还有加这些属性

05:21.160 --> 05:23.360
那么这样子一加obj2是不是也变了

05:23.660 --> 05:24.660
也会发生变化

05:24.660 --> 05:26.060
所以说最好不要这样子写

05:26.560 --> 05:27.560
我们最好怎么写呢

05:27.660 --> 05:29.260
最好是这样子

05:29.860 --> 05:30.560
这样子写

05:30.760 --> 05:31.260
对吧

05:31.660 --> 05:33.460
建立一个新的空对象

05:33.560 --> 05:34.760
建立一个新的空对象

05:34.760 --> 05:36.660
然后来依次给他加属性

05:37.160 --> 05:38.160
好 怎么加呢

05:38.160 --> 05:39.260
是不是 for in 循环

05:39.260 --> 05:40.460
对吧 for in 循环

05:40.860 --> 05:43.160
prob in obj2

05:43.760 --> 05:46.160
得到obj2的所有的什么属性

05:46.160 --> 05:48.360
得到obj2的所有属性循环

05:48.660 --> 05:50.260
好 每循环一次

05:50.360 --> 05:51.460
是不是把ob

05:51.660 --> 05:53.560
把这个属性也加到他的这个

05:54.360 --> 05:55.560
这个对象里面 对吧

05:55.860 --> 05:57.060
我们为什么要用中央号

05:57.060 --> 05:58.760
因为这里是属性表达式

05:58.860 --> 06:00.860
这种表达式的计算结果

06:01.360 --> 06:02.460
作为他的属性名

06:02.560 --> 06:04.260
这个变量里面记录了他的属性

06:04.260 --> 06:04.660
对吧

06:04.760 --> 06:06.560
记录了obj2的所有属性

06:06.860 --> 06:07.760
属性的名称

06:07.760 --> 06:08.660
好 把这个

06:08.760 --> 06:10.060
这个变量的值呢

06:10.060 --> 06:11.260
放放到这里

06:11.360 --> 06:12.360
作为他的属性名

06:12.560 --> 06:14.360
好 他的属性值等于啥呢

06:14.660 --> 06:16.860
是不是跟obj2的属性值是一样的

06:16.960 --> 06:17.460
对吧

06:17.860 --> 06:19.260
好 这样子还完成复制

06:19.360 --> 06:19.860
还没有

06:20.060 --> 06:22.660
这样子呢 就把obj2的所有属性

06:23.260 --> 06:24.460
记录到了obj

06:24.660 --> 06:26.060
就记录到这里

06:26.060 --> 06:27.260
对吧 记录到了这里

06:28.260 --> 06:29.560
好 记录过来过后

06:29.660 --> 06:30.560
是不是还没完

06:30.560 --> 06:32.860
对吧 这是复制obj2的属性

06:33.460 --> 06:36.160
复制obj2的属性

06:37.260 --> 06:37.960
还没完

06:37.960 --> 06:39.060
还有什么事情呢

06:39.160 --> 06:40.060
还要做一些事情

06:40.060 --> 06:40.760
比方说

06:40.760 --> 06:45.760
还要就是找到obj1中有

06:46.060 --> 06:51.760
但是obj2中没有的属性

06:52.160 --> 06:55.860
找到这里obj1中有obj2里面没有的属性

06:55.960 --> 06:57.860
把这些属性也要加到这里边

06:58.160 --> 06:59.460
你看一下我们这里混合

06:59.460 --> 06:59.860
对吧

07:00.060 --> 07:03.860
比方说这里我们刚才是obj2混合到obj1

07:03.960 --> 07:06.260
你看 是不是把obj2的属性全部拿过来

07:06.260 --> 07:06.660
对吧

07:06.660 --> 07:08.560
xdH拿过来

07:08.660 --> 07:10.660
然后再找到obj1中没有的属

07:10.660 --> 07:12.960
obj1中有obj2里面没有的属性

07:13.260 --> 07:14.360
好 就这样子来找

07:15.260 --> 07:16.360
好 那这里怎么找呢

07:16.360 --> 07:17.260
具体怎么找呢

07:18.060 --> 07:18.860
具体怎么找呢

07:19.060 --> 07:20.660
我们这里可以循环什么

07:20.660 --> 07:23.560
循环obj1的所有属性

07:23.860 --> 07:25.360
循环obj1的所有属性

07:25.660 --> 07:26.660
判断一下

07:26.960 --> 07:32.960
如果这个属性不在obj2中

07:33.260 --> 07:34.860
怎么来判断不在obj2中

07:35.160 --> 07:35.960
我们怎么判断

07:36.360 --> 07:38.660
我们之前不是学过一个硬关键字吗

07:38.660 --> 07:38.960
对吧

07:38.960 --> 07:39.860
硬关键字

07:39.960 --> 07:41.160
判断某一个东西

07:41.360 --> 07:44.660
某一个属性名字是不是在一个对象中

07:44.660 --> 07:46.160
我们之前学过这么一个关键字

07:46.160 --> 07:47.160
可能有些朋友忘了

07:47.560 --> 07:48.860
好 我们加上这个判断

07:48.860 --> 07:49.660
对吧 判断

07:49.860 --> 07:51.560
好 给它取一个反

07:51.660 --> 07:52.860
把它扩起来 取一个反

07:53.960 --> 07:54.560
为什么扩起来

07:54.560 --> 07:55.460
这有一个优先级

07:55.460 --> 07:56.460
这有一个优先级的问题

07:56.660 --> 07:57.660
如果你不扩的话

07:57.660 --> 07:58.760
那么这个感叹号

07:59.760 --> 08:01.460
这个感叹号表示的是

08:01.960 --> 08:02.960
把这个东西取反

08:03.860 --> 08:05.060
把它扩起来 取反

08:05.260 --> 08:06.460
那么这样子一取反的话

08:06.460 --> 08:07.860
你看什么意思

08:07.860 --> 08:11.560
就表示这个属性不在obj2中

08:11.960 --> 08:13.860
它不在obj2中 那就好办了

08:13.860 --> 08:14.960
这个属性是比较负责

08:14.960 --> 08:15.960
6obj

08:16.460 --> 08:17.760
prob 等于什么

08:17.860 --> 08:20.860
等于obj1的prob

08:21.060 --> 08:22.560
把obj1的属性保留下来了

08:22.660 --> 08:24.860
最后我们返回这个6obj

08:24.960 --> 08:26.060
是不是就完成混合了

08:26.260 --> 08:26.860
对不对

08:27.760 --> 08:28.960
好 这就完成了

08:28.960 --> 08:29.660
就完成了

08:30.060 --> 08:31.360
好 就这样来我们看一下

08:31.360 --> 08:32.160
来试一下

08:32.360 --> 08:33.360
把这两个

08:33.660 --> 08:35.160
把这两个进行混合

08:35.160 --> 08:36.260
看一下能不能混合

08:36.260 --> 08:37.460
我先引用这个GS

08:37.860 --> 08:38.460
scripts

08:38.760 --> 08:39.260
src

08:39.260 --> 08:40.760
这个东西要写到helper里面

08:40.760 --> 08:42.260
写到我们的插件里面

08:42.360 --> 08:43.860
将来我们有用

08:44.660 --> 08:45.960
好 写到common

08:46.260 --> 08:46.960
common

08:47.360 --> 08:47.860
helper

08:48.460 --> 08:48.860
写到什么

08:48.860 --> 08:49.660
myplunging

08:49.660 --> 08:50.360
plunging

08:51.660 --> 08:52.260
helpers

08:52.960 --> 08:54.060
好 这里我们使用

08:55.260 --> 08:55.860
使用啥

08:56.160 --> 08:57.060
那就是

08:57.560 --> 08:58.160
objects

08:58.960 --> 08:59.460
不是

08:59.860 --> 09:01.460
使用那个myplunging

09:01.660 --> 09:02.360
myplunging

09:02.460 --> 09:03.460
然后del

09:03.860 --> 09:04.660
del那个

09:05.260 --> 09:05.860
mixing

09:06.160 --> 09:06.660
mixing

09:06.860 --> 09:07.960
obj1传进去

09:07.960 --> 09:09.060
obj2传进去

09:09.160 --> 09:10.760
然后两个对象混合

09:10.960 --> 09:12.260
然后得到一个新的对象

09:12.660 --> 09:13.860
输出obj

09:13.860 --> 09:15.060
我们来看一下输出的结果

09:18.690 --> 09:19.990
好 这里关上其他的

09:21.590 --> 09:22.290
好 看一下

09:23.590 --> 09:24.090
刷新

09:24.390 --> 09:25.790
你看一下是不是完成混合了

09:25.790 --> 09:26.290
对不对

09:26.690 --> 09:27.790
这就完成混合了

09:28.490 --> 09:29.390
这是我们自己写

09:30.290 --> 09:32.390
那么GS里面有没有跟我们提供了

09:32.390 --> 09:34.390
所以说这就可能有一点点新知识

09:34.490 --> 09:35.990
所以说GS实际上GS里面

09:35.990 --> 09:37.690
已经跟我们提供了一个东西

09:37.690 --> 09:39.690
来能够帮助我们来进行混合了

09:39.790 --> 09:40.590
已经能够提供

09:40.590 --> 09:41.690
它已经提供了一个东西

09:41.690 --> 09:42.690
来帮助我们混合了

09:42.890 --> 09:43.690
什么东西呢

09:43.790 --> 09:44.490
它是这样子

09:45.790 --> 09:46.790
我们这里说一下

09:47.390 --> 09:48.790
GS里面已经提供了一个东西

09:48.790 --> 09:50.290
但是这种写法一定要汇写

09:50.290 --> 09:51.390
你至少得汇写

09:52.190 --> 09:53.590
GS里面跟我们提供了一个东西

09:53.590 --> 09:54.790
叫做obj2

09:55.190 --> 09:55.790
esan

09:56.490 --> 09:56.990
esan

09:57.390 --> 09:58.590
通过这个函数

09:58.890 --> 09:59.890
来进行混合

10:00.190 --> 10:01.590
可以进行混合两个对象

10:01.990 --> 10:03.090
那么怎么混合呢

10:03.090 --> 10:03.790
它这样子

10:04.090 --> 10:07.290
用法了差不多obj1obj2

10:07.890 --> 10:10.890
它会把obj2混合到obj1里面去

10:11.190 --> 10:12.190
返回一个新的

10:12.190 --> 10:12.990
返回一个对象

10:13.090 --> 10:13.890
返回一个对象

10:13.990 --> 10:14.790
6obj

10:14.990 --> 10:15.990
就obj

10:16.490 --> 10:17.390
好 我们来看一下

10:17.690 --> 10:19.390
这样子是不是也能完成混合了

10:20.190 --> 10:20.790
保存

10:21.090 --> 10:22.090
这是个精彩方法

10:22.590 --> 10:23.190
你看一下

10:23.490 --> 10:24.590
是不是也可以完成混合

10:24.790 --> 10:25.190
对吧

10:25.190 --> 10:26.390
也可以完成混合

10:26.590 --> 10:27.590
仍然是没问题的

10:27.790 --> 10:29.190
所以说我们可以使用它

10:29.590 --> 10:30.790
但是大家要注意

10:31.090 --> 10:31.890
大家要注意

10:32.190 --> 10:35.290
这个函数它有一个缺陷

10:35.290 --> 10:36.390
虽然用起来很好用

10:36.390 --> 10:38.990
但是它有一个小小的缺陷

10:39.290 --> 10:40.790
就是这样子一混合之后

10:41.190 --> 10:42.190
obj1

10:43.090 --> 10:44.290
它也发生了变化

10:44.890 --> 10:45.890
它也发生了变化

10:45.890 --> 10:46.390
你看看

10:46.690 --> 10:48.490
obj2混合到obj1

10:48.490 --> 10:49.590
它也发生了变化

10:50.090 --> 10:51.790
它会导致obj1发生变化

10:51.790 --> 10:54.090
而我们这个函数里面obj1和obj2

10:54.090 --> 10:54.990
它不会变化的

10:55.590 --> 10:57.190
它只是产生一个新对象

10:57.390 --> 10:58.690
而这里它是这样子

10:58.690 --> 10:59.590
它是这样子处理的

10:59.790 --> 11:00.990
把后边的对象

11:01.390 --> 11:03.690
复制到前面的对象

11:04.090 --> 11:05.390
复制到前面的对象

11:05.790 --> 11:06.590
是这么个意思

11:06.790 --> 11:09.590
把后边的对象复制到前面的对象

11:10.390 --> 11:11.290
然后

11:11.990 --> 11:14.190
然后把前面的对象返回

11:14.190 --> 11:16.590
所以说得到的结果是obj

11:16.590 --> 11:18.190
等于obj1

11:18.190 --> 11:19.790
你看两个对象是一样的

11:20.490 --> 11:21.790
它相当于是返回的是

11:21.790 --> 11:23.090
返回的是obj1

11:24.090 --> 11:25.690
那能不能处理一下呢

11:25.690 --> 11:27.690
能不能处理成返回一个新对象呢

11:27.690 --> 11:28.690
实际上是可以的

11:28.690 --> 11:29.490
可以的

11:29.490 --> 11:30.590
因为这个函数

11:30.590 --> 11:32.190
它支持多个参数

11:32.290 --> 11:33.490
它不仅是两个

11:33.890 --> 11:35.290
它还可以支持多个参数

11:35.390 --> 11:36.690
那比方说还有个对象

11:36.890 --> 11:37.690
obj3

11:38.390 --> 11:39.190
obj3

11:39.290 --> 11:40.690
x又等于

11:41.190 --> 11:41.890
中文了

11:41.890 --> 11:42.490
中文了

11:42.690 --> 11:43.490
随便写吧

11:44.490 --> 11:46.390
然后有自己的一个属性

11:46.590 --> 11:48.190
g123

11:49.090 --> 11:50.990
比方说这里再加一个obj3

11:51.590 --> 11:52.990
你看它又可以写多个对象

11:53.490 --> 11:54.090
保存

11:54.190 --> 11:56.390
那么始终是后边的覆盖前面的

11:56.490 --> 11:57.990
这样子一层一层覆盖过去

11:58.090 --> 12:00.690
obj3先跟obj2进行混合

12:00.690 --> 12:01.690
混合完了结果

12:01.690 --> 12:03.190
然后再跟obj1混合

12:03.190 --> 12:04.790
始终是后边覆盖前面的

12:05.090 --> 12:06.090
我们来看一下

12:06.190 --> 12:07.690
那么现在就x又变了

12:07.690 --> 12:07.890
对吧

12:07.890 --> 12:08.490
变成这个了

12:09.090 --> 12:10.990
它可以有多个对象混合

12:10.990 --> 12:12.590
于是我们就可以这样子写

12:13.090 --> 12:14.490
当然凭什么用的比较多的

12:14.490 --> 12:15.290
可能就两个

12:15.290 --> 12:16.490
一般就是两个对象

12:16.690 --> 12:18.090
我们这里是不是可以这样子写

12:18.090 --> 12:19.290
这个地方写啥

12:20.390 --> 12:22.290
如果我们要混合obj1

12:22.390 --> 12:23.190
和obj2

12:23.190 --> 12:25.990
又不希望obj1和obj2发生改变

12:26.190 --> 12:26.690
混啥

12:27.190 --> 12:27.790
怎么写

12:28.390 --> 12:30.190
用一个非常巧妙的办法

12:30.190 --> 12:31.490
这里写个新对象

12:32.090 --> 12:32.790
可不可以

12:33.390 --> 12:34.090
可不可以

12:34.290 --> 12:35.590
能不能写个对象字面量吗

12:35.590 --> 12:35.990
可以啊

12:36.390 --> 12:37.190
字面量又怎么了

12:37.790 --> 12:38.790
不一定非要式变量

12:39.190 --> 12:39.590
对不对

12:39.590 --> 12:40.490
可以直接写字面量

12:40.490 --> 12:41.390
包括这些地方

12:41.390 --> 12:42.790
是不是都可以写字面量对象

12:42.890 --> 12:43.290
对不对

12:43.790 --> 12:45.090
这里我写个新对象

12:45.090 --> 12:45.590
看到没

12:45.990 --> 12:47.190
那么就是里面是空的

12:47.190 --> 12:47.490
对吧

12:47.590 --> 12:49.890
把obj2和obj1进行混合

12:49.890 --> 12:50.490
混合完了过

12:50.490 --> 12:51.890
再跟那个空对象进行混合

12:51.990 --> 12:52.990
那就相当于是把

12:53.890 --> 12:54.690
这个空对象

12:54.690 --> 12:55.790
以前的空对象

12:55.790 --> 12:56.990
它的引用返回了

12:56.990 --> 12:58.390
那么就相当于是个新对象了

12:58.390 --> 12:58.890
对不对

12:58.990 --> 13:00.490
我们可以用这种方式来处理

13:01.390 --> 13:01.890
那么这样子

13:01.890 --> 13:02.590
obj1

13:02.590 --> 13:04.890
它或是obj1是不会发生变化的

13:04.890 --> 13:06.390
obj2也不会发生变化

13:07.090 --> 13:07.690
因此

13:08.090 --> 13:09.990
基于有这么一个函数

13:10.190 --> 13:12.090
所以说我们这个helps

13:12.090 --> 13:14.090
这个混合就非常非常简单了

13:14.590 --> 13:15.690
我们自己

13:15.690 --> 13:16.990
这种写法一带汇写

13:16.990 --> 13:17.790
一带汇写

13:17.890 --> 13:19.590
然后这里面我们直接就返回

13:19.590 --> 13:20.090
返回啥

13:20.090 --> 13:20.690
返回这个

13:21.590 --> 13:22.190
你要这意思

13:22.190 --> 13:23.590
我们直接就返回就完事了

13:23.790 --> 13:25.190
因为它可以传入多个参数

13:25.190 --> 13:25.690
三个参数

13:25.690 --> 13:26.090
四个参数

13:26.090 --> 13:27.090
五个参数都可以

13:27.090 --> 13:28.590
后边直接覆盖前边了

13:29.390 --> 13:31.490
为了保证obj1和obj2

13:31.490 --> 13:32.390
不发生改变

13:32.390 --> 13:34.090
所以说我们可以加住一个新对象

13:34.090 --> 13:35.390
放到第一个参数

13:35.390 --> 13:37.290
因为它返回的就是第一个参数的值

13:38.290 --> 13:38.690
好吧

13:38.690 --> 13:39.890
这是关于对象混合

13:39.990 --> 13:41.790
那么对象混合有什么用了

13:41.990 --> 13:43.190
将来能我们写一些

13:43.190 --> 13:44.290
复杂的应用的时候

13:44.290 --> 13:44.990
它会有用

13:45.390 --> 13:46.690
比方说我们写一个函数

13:48.090 --> 13:49.090
比方说写一个函数

13:49.590 --> 13:50.490
函数呢

13:51.490 --> 13:52.690
complete

13:53.390 --> 13:54.390
complicate

13:54.990 --> 13:55.690
是这样写吧

13:55.690 --> 13:56.390
复杂的

13:56.990 --> 13:57.690
是这样写吧

13:58.590 --> 13:59.290
我的天啊

13:59.490 --> 14:00.390
我这个英语

14:00.590 --> 14:02.890
英语的首写真的是包括复杂的

14:02.890 --> 14:03.590
复杂的

14:05.590 --> 14:06.490
比方说有这么一个函数

14:06.490 --> 14:07.690
一个复杂的函数

14:07.690 --> 14:09.990
这个复杂的函数有很多很多的参数

14:10.290 --> 14:11.490
它参数超级多

14:11.590 --> 14:12.990
可能有十几二十个参数

14:13.690 --> 14:14.290
那么这里呢

14:14.290 --> 14:15.490
我们怎么写呢

14:15.490 --> 14:16.290
这里的参数呢

14:16.290 --> 14:17.890
你可能肯定不能给

14:18.190 --> 14:19.890
把参数列表写成二十个

14:19.990 --> 14:20.790
那样子太多了

14:20.790 --> 14:21.890
雕用起来很麻烦

14:22.490 --> 14:22.890
而且呢

14:22.890 --> 14:23.890
这里有些参数呢

14:23.890 --> 14:24.690
是可以忽略的

14:24.690 --> 14:25.890
它是有默认值的

14:26.290 --> 14:27.890
有些参数是有默认值的

14:28.290 --> 14:30.090
那么像这种情况非常非常多

14:30.090 --> 14:31.190
超级超级多

14:31.990 --> 14:33.890
那么像这种比方说我们之前讲的那个

14:35.090 --> 14:37.090
有些同学可能没看过这节课

14:37.090 --> 14:38.690
就是属性描述服在里边

14:38.690 --> 14:40.090
属性描述服是不是个对象

14:40.090 --> 14:40.290
对吧

14:40.290 --> 14:41.290
它作为一个参数

14:41.290 --> 14:42.890
对象里边有些东西可以配置

14:42.890 --> 14:43.690
可以不配置

14:43.890 --> 14:45.290
不配置的话会有默认值

14:45.890 --> 14:46.890
那么像这种情况的

14:46.890 --> 14:49.490
我们往往可以可以用一个对象作为参数

14:49.490 --> 14:50.890
就是OB型的是个对象

14:51.890 --> 14:52.890
我再打个主事

14:53.090 --> 14:55.490
OB型参数是一个对象

14:56.890 --> 14:59.090
可表示配置对象

14:59.490 --> 15:01.090
就是有的时候我们写一个函数

15:01.090 --> 15:02.890
这个函数需要很多的参数

15:02.890 --> 15:05.090
那么我们就可以把这些参数合并为一个对象

15:05.290 --> 15:06.690
作为对象的属性存在

15:06.690 --> 15:07.090
对吧

15:07.090 --> 15:08.490
我们就不用去

15:08.890 --> 15:10.290
一个一个去传递这些参数了

15:10.290 --> 15:11.290
把它放到对象里边

15:11.690 --> 15:14.290
而且这些这里的很多参数

15:14.290 --> 15:15.690
可以说可以这样说吧

15:15.690 --> 15:17.290
所有的参数都有默认值

15:17.890 --> 15:19.490
这我们怎么写呢

15:19.490 --> 15:21.690
就是说它调用的时候可能会这样调用

15:22.490 --> 15:24.890
看着它调用函数的时候可能会这样调用

15:24.890 --> 15:25.890
这里传个对象进来

15:25.890 --> 15:28.290
传个对象作为一个参数

15:28.490 --> 15:29.890
一个对象作为一个参数

15:29.890 --> 15:30.090
好

15:30.090 --> 15:31.490
这个参数可能会这样调用

15:31.490 --> 15:33.890
比方说它里边有五个属性

15:34.090 --> 15:35.690
比方说有五个属性ABCDE

15:36.290 --> 15:37.090
ABCDE

15:38.890 --> 15:39.490
都要传递

15:39.490 --> 15:40.290
都要传递

15:40.890 --> 15:43.290
CD

15:44.290 --> 15:48.090
然后E比方说吧

15:48.090 --> 15:49.090
有这么五个参数

15:49.490 --> 15:51.490
那么这样传递传递过来的话

15:51.490 --> 15:52.290
当然很简单

15:52.290 --> 15:52.690
对不对

15:52.690 --> 15:54.090
传递过来当然很简单

15:54.090 --> 15:54.890
我们这里输出

15:55.890 --> 15:56.290
看一下

15:57.890 --> 15:59.090
传递过来当然很简单

15:59.090 --> 16:01.290
但是如果它有一些配置

16:01.290 --> 16:02.290
有一些属性

16:02.290 --> 16:04.290
属性它没有传递怎么办呢

16:04.890 --> 16:06.290
我们要给它默认值

16:07.290 --> 16:08.890
我们要给它默认值

16:09.290 --> 16:11.290
也就是说我们这里要这样子处理

16:12.290 --> 16:14.690
如果没有传递

16:15.090 --> 16:17.290
则使用默认值

16:17.290 --> 16:18.690
使用默认值

16:19.290 --> 16:19.490
好

16:19.490 --> 16:20.690
首先我们来判断

16:20.690 --> 16:21.290
这个OB型

16:21.290 --> 16:23.290
整个OB型有没有传递

16:23.890 --> 16:25.090
首先来判断这个东西

16:25.090 --> 16:26.490
整个OB型有没有传递

16:27.490 --> 16:28.890
甚至我们先不着急判断这个

16:28.890 --> 16:29.890
先不着急判断这个

16:29.890 --> 16:31.490
我们先写出一个对象

16:31.490 --> 16:34.290
这个对象里边包含了所有的默认配置

16:34.690 --> 16:36.290
default option

16:36.290 --> 16:38.290
包含了所有的默认配置

16:38.290 --> 16:39.290
哪些默认配置呢

16:39.290 --> 16:40.290
比方说A这个配置

16:40.290 --> 16:42.290
A这个属性是default

16:42.290 --> 16:46.290
A比方说B这个配置是default

16:46.290 --> 16:49.290
B C C

16:49.290 --> 16:50.290
我们这样子写

16:50.290 --> 16:53.290
D D E

16:53.290 --> 16:55.290
这里我们这样子

16:55.290 --> 16:57.290
default

16:57.290 --> 17:00.290
比方说这是它的默认配置

17:00.290 --> 17:02.290
每个属性都有默认值

17:02.290 --> 17:03.290
你给我传过后

17:03.290 --> 17:05.290
我要使用你传递的字

17:05.290 --> 17:07.290
是什么意思

17:07.290 --> 17:08.290
我要使用你传递的字

17:08.290 --> 17:10.290
而不是不使用默认值的

17:10.290 --> 17:11.290
如果你没有传递的话

17:11.290 --> 17:12.290
使用默认值

17:12.290 --> 17:13.290
好 那这么怎么办呢

17:13.290 --> 17:15.290
是不是就是对象混合

17:15.290 --> 17:17.290
把这个对象混合到这个对象

17:17.290 --> 17:19.290
它有的东西进行覆盖掉

17:19.290 --> 17:21.290
就变成这么个意思了

17:21.290 --> 17:22.290
那么这里呢

17:22.290 --> 17:23.290
我们怎么写呢

17:23.290 --> 17:24.290
是不是就可以利用我们的

17:24.290 --> 17:26.290
对象混合那个方法

17:26.290 --> 17:27.290
OPT

17:27.290 --> 17:29.290
最终的配置

17:29.290 --> 17:30.290
最终的配置就是

17:30.290 --> 17:34.290
myplugin mixing

17:34.290 --> 17:36.290
第一个是啥

17:36.290 --> 17:37.290
第一个混合的

17:37.290 --> 17:39.290
是default

17:39.290 --> 17:41.290
第二个混合的是OPT

17:41.290 --> 17:43.290
最后我们输出最终的配置OPT

17:43.290 --> 17:45.290
包存 你看一下

17:45.290 --> 17:46.290
你看

17:46.290 --> 17:48.290
它如果传的都使用它传递的

17:48.290 --> 17:50.290
如果它有些东西没传

17:50.290 --> 17:52.290
比方它只传了A和B

17:52.290 --> 17:53.290
它为了方便

17:53.290 --> 17:55.290
因为其他东西都是默认值

17:55.290 --> 17:56.290
它只传两个

17:56.290 --> 17:57.290
你看

17:57.290 --> 17:59.290
那么其他都是不是使用默认值

17:59.290 --> 18:00.290
对吧

18:00.290 --> 18:02.290
这种场景

18:02.290 --> 18:03.290
非常常见

18:03.290 --> 18:04.290
在后边我们

18:04.290 --> 18:05.290
做一些功能的时候

18:05.290 --> 18:06.290
非常非常常见

18:06.290 --> 18:08.290
你给我传一个配置进来

18:08.290 --> 18:09.290
配个配置里面有很多

18:09.290 --> 18:10.290
但是你不用全部传递

18:10.290 --> 18:11.290
你只能传

18:11.290 --> 18:12.290
只需要传递一部分

18:12.290 --> 18:14.290
其他的我使用默认值就完事了

18:14.290 --> 18:15.290
没有这个意思吧

18:15.290 --> 18:16.290
我们这里就可以用

18:16.290 --> 18:18.290
这种模式来进行处理

18:18.290 --> 18:19.290
看不看

18:19.290 --> 18:21.290
好 那如果它没有传递呢

18:21.290 --> 18:22.290
没有传递这个Option

18:22.290 --> 18:23.290
是不是undefine

18:23.290 --> 18:24.290
我们来看一下

18:24.290 --> 18:25.290
如果undefine的话

18:25.290 --> 18:26.290
它不影响

18:26.290 --> 18:27.290
看不看不看

18:27.290 --> 18:28.290
它这个Object车

18:28.290 --> 18:29.290
因为我们使用的

18:29.290 --> 18:30.290
最终使用的是Object车

18:30.290 --> 18:31.290
如果这个参数是undefine的话

18:31.290 --> 18:32.290
它不会有影响的

18:32.290 --> 18:33.290
不会影响的

18:33.290 --> 18:34.290
那就没有覆盖

18:34.290 --> 18:35.290
就没有任何覆盖

18:36.290 --> 18:37.290
看没

18:37.290 --> 18:38.290
我们就可以用这种模式

18:38.290 --> 18:39.290
来进行处理的

18:40.290 --> 18:41.290
那么以后

18:41.290 --> 18:42.290
我这样的方式

18:42.290 --> 18:43.290
对于雕用函数的人

18:43.290 --> 18:45.290
是非常舒服的

18:45.290 --> 18:46.290
我只需要传递

18:46.290 --> 18:47.290
我想改变的东西

18:47.290 --> 18:48.290
不想改变的东西

18:48.290 --> 18:50.290
我就不用传递了

18:50.290 --> 18:51.290
这对象混合了

18:51.290 --> 18:53.290
一个最常见 最常见的应用

18:53.290 --> 18:55.290
这是关于对象混合

18:56.290 --> 18:58.290
另外一块是对象克龙

18:58.290 --> 19:00.290
什么叫对象克龙呢

19:00.290 --> 19:01.290
就是把一个对象

19:01.290 --> 19:03.290
克龙成为一个新的对象

19:03.290 --> 19:04.290
比方说

19:07.290 --> 19:09.290
Object

19:11.290 --> 19:12.290
克龙

19:13.290 --> 19:14.290
Object

19:14.290 --> 19:15.290
比方说

19:15.290 --> 19:16.290
对象

19:16.290 --> 19:18.290
对象里面的X1

19:18.290 --> 19:19.290
Y2

19:19.290 --> 19:21.290
现在我要产生一个新的对象

19:21.290 --> 19:22.290
跟它一模一样

19:22.290 --> 19:23.290
长得一模一样

19:23.290 --> 19:24.290
那怎么做呢

19:24.290 --> 19:26.290
你当然不能这样做

19:26.290 --> 19:28.290
这样做不叫克龙

19:28.290 --> 19:29.290
这样做用的

19:29.290 --> 19:30.290
是不是还是同一个对象

19:30.290 --> 19:31.290
将来我改它

19:31.290 --> 19:32.290
他也跟着改了

19:32.290 --> 19:34.290
他也改它的时候

19:34.290 --> 19:35.290
他也跟着改了

19:35.290 --> 19:37.290
所以有些情况下

19:37.290 --> 19:38.290
有些情况下

19:38.290 --> 19:39.290
我们当然希望这样子

19:39.290 --> 19:40.290
但是有些情况下

19:40.290 --> 19:41.290
这样子不好

19:41.290 --> 19:43.290
后面我会举个例子

19:43.290 --> 19:44.290
会举个例子

19:44.290 --> 19:45.290
那么

19:45.290 --> 19:47.290
如果

19:47.290 --> 19:49.290
我要产生一个新的对象

19:49.290 --> 19:50.290
就全新的对象

19:50.290 --> 19:52.290
只是跟它长得一模一样

19:52.290 --> 19:53.290
这叫做克龙

19:53.290 --> 19:54.290
克龙是什么

19:54.290 --> 19:55.290
就是两份东西

19:57.290 --> 19:59.290
就是把一个数据

19:59.290 --> 20:00.290
复制一份

20:00.290 --> 20:02.290
到另外一块数据

20:02.290 --> 20:03.290
叫对象克龙

20:03.290 --> 20:04.290
克龙的话

20:04.290 --> 20:06.290
即使他没有给我们提供方法

20:06.290 --> 20:08.290
我们Object里面

20:08.290 --> 20:10.290
Clone没有这个方法

20:10.290 --> 20:11.290
所以说

20:11.290 --> 20:12.290
我们得自己写

20:12.290 --> 20:14.290
对象克龙得自己写

20:14.290 --> 20:15.290
那么怎么写呢

20:15.290 --> 20:17.290
其实我们刚才写过这个混合

20:17.290 --> 20:18.290
对吧

20:18.290 --> 20:19.290
克龙其实写起来很简单

20:19.290 --> 20:21.290
我们这里写吧

20:21.290 --> 20:22.290
Rest

20:22.290 --> 20:24.290
Myplunging

20:24.290 --> 20:26.290
这里写什么

20:26.290 --> 20:27.290
Clone

20:27.290 --> 20:29.290
克龙就是克龙的意思

20:29.290 --> 20:30.290
给我一个对象

20:30.290 --> 20:32.290
我来对它进行克龙

20:34.290 --> 20:35.290
克龙

20:35.290 --> 20:37.290
一个对象

20:37.290 --> 20:38.290
克龙一个对象

20:39.290 --> 20:40.290
好

20:40.290 --> 20:41.290
然后这里边杂写

20:41.290 --> 20:42.290
这边杂写

20:42.290 --> 20:43.290
我们可以这样子

20:44.290 --> 20:45.290
我们这里

20:48.290 --> 20:49.290
循环

20:49.290 --> 20:50.290
产生一个新的对象

20:50.290 --> 20:51.290
刚才写过了

20:51.290 --> 20:52.290
类似的代码

20:52.290 --> 20:53.290
产生一个新的对象

20:53.290 --> 20:55.290
然后循环它

20:55.290 --> 20:56.290
循环它的所有属性

20:56.290 --> 20:58.290
循环它的所有属性

20:58.290 --> 20:59.290
好

20:59.290 --> 21:00.290
循环每一个属性

21:00.290 --> 21:02.290
每一个属性

21:02.290 --> 21:03.290
我们给它加上这个

21:03.290 --> 21:04.290
所以写一样的

21:04.290 --> 21:05.290
对不对

21:05.290 --> 21:06.290
没啥区别

21:06.290 --> 21:07.290
最后我们把新的对象返回

21:07.290 --> 21:08.290
就完成了

21:08.290 --> 21:09.290
对吧

21:09.290 --> 21:10.290
因为这里我们使用了

21:10.290 --> 21:11.290
字面量对象

21:11.290 --> 21:12.290
对吧

21:12.290 --> 21:13.290
就是个新的对象

21:13.290 --> 21:14.290
没问题吧

21:14.290 --> 21:15.290
这样子说完成克龙了

21:15.290 --> 21:16.290
对不对

21:16.290 --> 21:17.290
就完成克龙了

21:17.290 --> 21:18.290
好

21:18.290 --> 21:20.290
然后我们这里再看一下

21:20.290 --> 21:21.290
能不能完成克龙

21:21.290 --> 21:22.290
script

21:22.290 --> 21:23.290
src

21:26.290 --> 21:27.290
回到上级目录

21:27.290 --> 21:28.290
再回到上级目录

21:28.290 --> 21:29.290
plugin

21:29.290 --> 21:30.290
这里呢

21:30.290 --> 21:31.290
web

21:31.290 --> 21:32.290
我们来试一下

21:32.290 --> 21:33.290
myplugin

21:33.290 --> 21:34.290
第二

21:34.290 --> 21:35.290
clone

21:35.290 --> 21:36.290
obj

21:36.290 --> 21:37.290
克龙这个对象

21:37.290 --> 21:38.290
包村

21:38.290 --> 21:39.290
咱们来看一下

21:39.290 --> 21:44.650
这里没运行出来

21:44.650 --> 21:45.650
这里呢

21:45.650 --> 21:47.650
我们打印出6obj

21:47.650 --> 21:48.650
你看

21:48.650 --> 21:49.650
然后obj

21:49.650 --> 21:50.650
两个是不是一样的

21:50.650 --> 21:51.650
对吧

21:51.650 --> 21:52.650
一样的

21:52.650 --> 21:53.650
6obj

21:53.650 --> 21:54.650
是不是等于obj

21:54.650 --> 21:55.650
你看

21:55.650 --> 21:56.650
不等

21:56.650 --> 21:57.650
两个不是一个对象

21:57.650 --> 21:58.650
因此

21:58.650 --> 21:59.650
改变它里面的东西

21:59.650 --> 22:00.650
那么obj

22:00.650 --> 22:02.650
它不会发生变化

22:02.650 --> 22:04.650
这就是对象克龙

22:04.650 --> 22:05.650
好

22:05.650 --> 22:06.650
现在我们这个写完了

22:06.650 --> 22:07.650
那么

22:07.650 --> 22:08.650
不一定了

22:08.650 --> 22:10.650
其实你我们真正完成

22:10.650 --> 22:11.650
这个函数

22:11.650 --> 22:13.650
还有一段距离

22:13.650 --> 22:14.650
比方说

22:14.650 --> 22:16.650
我们还没考虑到其他情况

22:16.650 --> 22:17.650
它如果是一个数字

22:17.650 --> 22:18.650
怎么办

22:18.650 --> 22:19.650
如果是一个数字

22:19.650 --> 22:20.650
你看一下

22:20.650 --> 22:21.650
克龙出来是个啥

22:21.650 --> 22:22.650
当然

22:22.650 --> 22:23.650
谁会用去

22:23.650 --> 22:24.650
用把数字进行克龙了

22:24.650 --> 22:25.650
因为以为的时候

22:25.650 --> 22:27.650
你可能会遇到这种情况

22:27.650 --> 22:28.650
就是我不知道obj

22:28.650 --> 22:29.650
到底是个啥

22:29.650 --> 22:30.650
我可能是从别的地方

22:30.650 --> 22:31.650
拿到的

22:31.650 --> 22:32.650
可能是从一个函数的

22:32.650 --> 22:33.650
返回值里面拿到的

22:33.650 --> 22:34.650
我不知道它是啥

22:34.650 --> 22:35.650
不管它是啥

22:35.650 --> 22:37.650
我都希望对它进行克龙

22:37.650 --> 22:38.650
对吧

22:38.650 --> 22:39.650
有可能是这么一种场景

22:39.650 --> 22:40.650
那么这种时候

22:40.650 --> 22:41.650
如果它不是一个对象

22:41.650 --> 22:42.650
它是一个数字

22:42.650 --> 22:44.650
那你看克龙出来是个啥

22:44.650 --> 22:46.650
是个对象

22:46.650 --> 22:47.650
为什么是个对象

22:47.650 --> 22:48.650
因为你看我们在待

22:48.650 --> 22:49.650
是不是直接创建了

22:49.650 --> 22:50.650
创建了一个对象

22:50.650 --> 22:51.650
对吧

22:51.650 --> 22:52.650
好

22:52.650 --> 22:53.650
如果它是个字不创

22:53.650 --> 22:54.650
它克龙出来是个啥

22:54.650 --> 22:55.650
你看

22:55.650 --> 22:56.650
它是个字不创的话

22:56.650 --> 22:58.650
克龙出来是个东西

22:58.650 --> 22:59.650
字不创里面有属性

22:59.650 --> 23:00.650
对吧

23:00.650 --> 23:01.650
有属性

23:01.650 --> 23:02.650
你看变成这个样子了

23:02.650 --> 23:04.650
属性它是一个

23:04.650 --> 23:05.650
字不创本身是一个尾数组

23:05.650 --> 23:06.650
对吧

23:06.650 --> 23:07.650
一个内数组

23:07.650 --> 23:08.650
因此它克龙出来是这个样子

23:08.650 --> 23:10.650
它也不符合逻辑

23:10.650 --> 23:11.650
字不创克龙出来

23:11.650 --> 23:12.650
应该就是个字不创

23:12.650 --> 23:13.650
对吧

23:13.650 --> 23:14.650
好

23:14.650 --> 23:16.650
那么如果它是一个数组的话

23:16.650 --> 23:17.650
它是一个数组的话

23:17.650 --> 23:18.650
你看一下

23:18.650 --> 23:20.650
比方说随便写

23:20.650 --> 23:21.650
它是一个数组的话

23:21.650 --> 23:23.650
你看一下

23:23.650 --> 23:24.650
那这里呢

23:24.650 --> 23:25.650
克龙出来

23:25.650 --> 23:27.650
它就变成了一个尾数组了

23:27.650 --> 23:29.650
而且这个类似属性你还得不到

23:29.650 --> 23:31.650
因为我们循环的时候

23:31.650 --> 23:34.650
是循环不到这个数组的类似属性

23:34.650 --> 23:35.650
如果你看了我之前的

23:35.650 --> 23:36.650
扩展课程

23:36.650 --> 23:37.650
属性描述服的话

23:37.650 --> 23:39.650
你就知道为什么循环不到

23:39.650 --> 23:40.650
好

23:40.650 --> 23:43.650
你看这些场景是不是要特殊处理

23:43.650 --> 23:45.650
我们刚才写的代码

23:45.650 --> 23:48.650
所有代码基于的假设是什么

23:48.650 --> 23:50.650
假设OBG是个对象

23:50.650 --> 23:51.650
是个普通对象

23:51.650 --> 23:52.650
还不是一个数组对象

23:52.650 --> 23:54.650
因为数组本身也是对象

23:54.650 --> 23:55.650
它是一个普通对象

23:55.650 --> 23:57.650
我们都是基于这么一个假设

23:57.650 --> 23:59.650
但是实际上情况是很多的

23:59.650 --> 24:00.650
那这里是不是要判断

24:00.650 --> 24:02.650
判断OBG的类型

24:02.650 --> 24:03.650
对吧

24:03.650 --> 24:04.650
那我们写判断

24:04.650 --> 24:05.650
判断啥

24:05.650 --> 24:07.650
而首先判断是不是数组

24:07.650 --> 24:08.650
数组

24:08.650 --> 24:10.650
如果它是一个数组的话

24:10.650 --> 24:11.650
怎么样呢

24:11.650 --> 24:12.650
我们可以利用这个

24:12.650 --> 24:13.650
OBG

24:13.650 --> 24:14.650
它是个数组

24:14.650 --> 24:16.650
SNIFF

24:16.650 --> 24:17.650
对吧

24:17.650 --> 24:18.650
这是不是复制一个数组

24:18.650 --> 24:19.650
我们之前学过了

24:19.650 --> 24:22.650
复制数组

24:22.650 --> 24:23.650
复制数组

24:23.650 --> 24:24.650
还有什么情况

24:24.650 --> 24:25.650
L是一符

24:25.650 --> 24:26.650
如果它是个普通对象

24:26.650 --> 24:27.650
普通对象

24:27.650 --> 24:29.650
我们用这种方式来判断

24:29.650 --> 24:30.650
不解释

24:30.650 --> 24:32.650
那么除开数组之外

24:32.650 --> 24:33.650
我们为什么要先判断数组

24:33.650 --> 24:34.650
再判断这个

24:34.650 --> 24:35.650
因为数组本身也是对象

24:35.650 --> 24:36.650
所以我们先判断

24:36.650 --> 24:37.650
特殊情况的数组

24:37.650 --> 24:38.650
然后是数组的话

24:38.650 --> 24:39.650
复制一个

24:39.650 --> 24:41.650
如果不是数组的话

24:41.650 --> 24:43.650
那么我们

24:43.650 --> 24:44.650
它是一个普通对象的话

24:44.650 --> 24:45.650
我们再用这种方式

24:45.650 --> 24:48.650
所以刚才代码是基于这个假设

24:48.650 --> 24:50.650
再L是什么情况

24:50.650 --> 24:52.650
是不是就是函数

24:52.650 --> 24:54.650
什么原始类型这些情况

24:54.650 --> 24:55.650
对吧

24:55.650 --> 24:58.650
函数我们不管

24:58.650 --> 25:00.650
你怎么去克农一个函数呢

25:00.650 --> 25:02.650
函数我们不管

25:02.650 --> 25:03.650
函数不管

25:03.650 --> 25:04.650
我们只把它函数了

25:04.650 --> 25:05.650
直接返回就完事了

25:05.650 --> 25:07.650
函数你怎么克农呢

25:07.650 --> 25:08.650
它里边有代码

25:08.650 --> 25:09.650
不同的函数

25:09.650 --> 25:11.650
函数里边的代码都不一样

25:11.650 --> 25:12.650
所以说这一块

25:12.650 --> 25:13.650
我们这样子

25:13.650 --> 25:14.650
函数

25:14.650 --> 25:15.650
这里情况就是函数

25:15.650 --> 25:17.650
原始类型

25:17.650 --> 25:18.650
原始类型

25:18.650 --> 25:19.650
那么这种情况下

25:19.650 --> 25:20.650
我们直接把它返回

25:20.650 --> 25:21.650
直接返回

25:21.650 --> 25:22.650
来

25:22.650 --> 25:23.650
我们做了一个判断

25:23.650 --> 25:24.650
好

25:24.650 --> 25:25.650
做了判断之后

25:25.650 --> 25:26.650
我们再来看

25:26.650 --> 25:27.650
现在我克农一个数组

25:27.650 --> 25:28.650
看一下是不是能克农了

25:28.650 --> 25:29.650
欧比戒

25:29.650 --> 25:30.650
你看是不是克农了

25:30.650 --> 25:32.650
数组变成一个函数组了

25:32.650 --> 25:33.650
然后再判断一下

25:33.650 --> 25:34.650
是不是等于欧比戒了

25:34.650 --> 25:35.650
还不等于

25:35.650 --> 25:36.650
因为我们用Slice

25:36.650 --> 25:37.650
返回的是一个新数组

25:37.650 --> 25:38.650
好

25:38.650 --> 25:39.650
然后再看

25:39.650 --> 25:40.650
再看

25:40.650 --> 25:42.650
我们如果是一个字幕串

25:42.650 --> 25:43.650
一个字幕串

25:43.650 --> 25:44.650
我们来看一下

25:44.650 --> 25:46.650
它克农出来了

25:46.650 --> 25:47.650
就是一个字幕串

25:47.650 --> 25:49.650
看到没

25:49.650 --> 25:50.650
两个字幕串

25:50.650 --> 25:51.650
但是

25:51.650 --> 25:52.650
原始类型

25:52.650 --> 25:53.650
你懂的

25:53.650 --> 25:54.650
原始类型

25:54.650 --> 25:55.650
你重新给它复制

25:55.650 --> 25:56.650
是不是跟之前没啥关系

25:56.650 --> 25:57.650
对不对

25:57.650 --> 25:58.650
跟之前没啥关系

25:58.650 --> 26:00.650
本身就是克农的

26:00.650 --> 26:01.650
原始类型

26:01.650 --> 26:02.650
那么数字

26:02.650 --> 26:03.650
我就不看了

26:03.650 --> 26:04.650
都是一样的

26:04.650 --> 26:05.650
因此

26:05.650 --> 26:06.650
这个方法是不是

26:06.650 --> 26:07.650
更加优化了一点

26:07.650 --> 26:08.650
完了吗

26:08.650 --> 26:10.650
都还没有完

26:10.650 --> 26:11.650
好

26:11.650 --> 26:12.650
我们还要看到

26:12.650 --> 26:13.650
这种情况

26:13.650 --> 26:15.650
欧比戒里边

26:15.650 --> 26:16.650
可能是这种场景

26:16.650 --> 26:18.650
现在事情变得复杂了

26:18.650 --> 26:20.650
它有个属性

26:20.650 --> 26:22.650
有个属性

26:22.650 --> 26:25.650
有一个sub.obg

26:25.650 --> 26:26.650
你看

26:26.650 --> 26:27.650
它里边可能还有对象

26:27.650 --> 26:29.650
它的属性可能是个对象

26:29.650 --> 26:31.650
它的属性可能是个对象

26:31.650 --> 26:32.650
它有这么一种场景

26:32.650 --> 26:34.650
那么我们之前克农的

26:34.650 --> 26:36.650
它能克农这个属性吗

26:36.650 --> 26:37.650
这个属性是直接复制的

26:37.650 --> 26:38.650
你看我们之前

26:38.650 --> 26:39.650
对对象的处理上

26:39.650 --> 26:41.650
这个属性是不是直接复制的

26:41.650 --> 26:42.650
对不对

26:42.650 --> 26:43.650
直接复制的

26:43.650 --> 26:44.650
好

26:44.650 --> 26:46.650
直接复制是把对象的地址复制过去了

26:46.650 --> 26:48.650
那么现在就会产生另外一种场景

26:48.650 --> 26:50.650
这个6obg得到了结果

26:50.650 --> 26:52.650
跟这个obg差不多一样的

26:52.650 --> 26:53.650
是一样的

26:53.650 --> 26:57.650
但是并且obg

26:57.650 --> 26:59.650
并且6obg

26:59.650 --> 27:02.650
它本身是不等于obg的

27:02.650 --> 27:03.650
因为是克农

27:03.650 --> 27:04.650
产生了新的对象

27:04.650 --> 27:05.650
你看

27:05.650 --> 27:07.650
这里产生的是新的对象

27:07.650 --> 27:08.650
对不对

27:08.650 --> 27:09.650
所以它本身是不等的

27:09.650 --> 27:12.650
但是它里边的属性是一样的

27:12.650 --> 27:13.650
里边的属性

27:13.650 --> 27:14.650
sub.obg

27:14.650 --> 27:16.650
和这个obg的sub.obg

27:16.650 --> 27:17.650
这个东西是一样的

27:17.650 --> 27:18.650
它的地址是一样的

27:18.650 --> 27:20.650
这会导致一个什么问题呢

27:20.650 --> 27:22.650
当然如果你就希望这样子的话

27:22.650 --> 27:23.650
常常不会导致问题

27:23.650 --> 27:25.650
如果你不希望这样子的话

27:25.650 --> 27:26.650
它就会导致这个问题

27:26.650 --> 27:28.650
如果我给这个f复制了

27:28.650 --> 27:31.650
你会发现obg的sub.obg

27:31.650 --> 27:32.650
它也被复制了

27:32.650 --> 27:33.650
因为它

27:33.650 --> 27:34.650
这个东西

27:34.650 --> 27:35.650
这个东西

27:35.650 --> 27:37.650
跟这个东西是一个地址

27:37.650 --> 27:38.650
看到没

27:38.650 --> 27:40.650
我们把这种

27:40.650 --> 27:42.650
目前我们写的这种方式

27:42.650 --> 27:44.650
叫做潜度可能

27:44.650 --> 27:46.650
叫做潜度可能

27:47.650 --> 27:49.650
潜度可能

27:49.650 --> 27:52.650
也就是我们对它里边的属性

27:52.650 --> 27:53.650
不做任何处理

27:53.650 --> 27:54.650
对对象里边的属性

27:54.650 --> 27:55.650
不做任何处理

27:55.650 --> 27:56.650
包括数组也是

27:56.650 --> 27:57.650
数组里边

27:57.650 --> 27:58.650
它有可能

27:58.650 --> 28:00.650
每个数组的每一项是一个对象

28:00.650 --> 28:02.650
对象里边还可能有一个数组

28:02.650 --> 28:03.650
数组里边还可能有一个对象

28:03.650 --> 28:05.650
它的深度不知道有多少

28:05.650 --> 28:07.650
但是我们如果啥都不管

28:07.650 --> 28:09.650
对它的属性进行可能的话

28:09.650 --> 28:11.650
这种可能叫做潜度可能

28:11.650 --> 28:14.650
还有另外一种可能叫做深度可能

28:14.650 --> 28:15.650
深度可能

28:15.650 --> 28:18.650
就对它的属性也要做同样的处理

28:18.650 --> 28:19.650
哪怕你只要遇到对象

28:19.650 --> 28:20.650
遇到数组

28:20.650 --> 28:22.650
我们也要进行可能

28:22.650 --> 28:24.650
那么这种情况叫做深度可能

28:24.650 --> 28:25.650
所以说这个函数

28:25.650 --> 28:26.650
我们还没有写完

28:26.650 --> 28:28.650
还需要一个参数

28:28.650 --> 28:30.650
这个参数叫做deep

28:30.650 --> 28:31.650
这个类似于什么

28:31.650 --> 28:32.650
dome对象

28:32.650 --> 28:33.650
dome对象是不是有可能

28:33.650 --> 28:34.650
它是不是有个deep参数

28:34.650 --> 28:37.650
dip参数我们打个注射

28:37.650 --> 28:40.650
打个注射

28:40.650 --> 28:41.650
它是布林

28:41.650 --> 28:42.650
它是个布尔雷修

28:42.650 --> 28:44.650
是否深度可能

28:44.650 --> 28:47.650
是否深度可能

28:47.650 --> 28:49.650
它的默认值呢

28:49.650 --> 28:50.650
为force

28:50.650 --> 28:51.650
比方说给它个默认值

28:51.650 --> 28:52.650
或者不给它默认值

28:52.650 --> 28:53.650
你只要传一个处

28:53.650 --> 28:54.650
就表示深度可能

28:54.650 --> 28:56.650
否则没有传递的话

28:56.650 --> 28:57.650
就是angdifan

28:57.650 --> 28:58.650
没有传递angdifan的话

28:58.650 --> 29:00.650
那么它就是一个潜度可能

29:00.650 --> 29:01.650
这就是潜度可能的代码

29:01.650 --> 29:02.650
对吧

29:02.650 --> 29:05.650
深度可能还没有写

29:05.650 --> 29:06.650
好 接下来我们来分析一下

29:06.650 --> 29:09.650
分析一下怎么来深度可能

29:10.650 --> 29:11.650
你看一下

29:11.650 --> 29:13.650
不管你是不是深度可能

29:13.650 --> 29:14.650
如果你这个obj

29:14.650 --> 29:15.650
是一个原始内形

29:15.650 --> 29:16.650
是一个函数

29:16.650 --> 29:17.650
是不是

29:17.650 --> 29:18.650
这个做法是一样的

29:18.650 --> 29:19.650
对吧

29:19.650 --> 29:20.650
这种做法是不是一样的

29:20.650 --> 29:22.650
它一定是直接返回

29:22.650 --> 29:23.650
一定是直接返回

29:23.650 --> 29:25.650
如果它是一个函数

29:25.650 --> 29:27.650
或者是原始内形的话

29:27.650 --> 29:28.650
是不是直接返回

29:28.650 --> 29:29.650
直接返回就完成了

29:29.650 --> 29:31.650
对不对

29:31.650 --> 29:32.650
好

29:32.650 --> 29:35.650
那么如果它是一个对象的话

29:35.650 --> 29:37.650
当然你肯定要新加个对象

29:37.650 --> 29:38.650
这个是毫无疑问的

29:38.650 --> 29:39.650
但是如果是个对象的话

29:39.650 --> 29:40.650
它肯定要新加对象

29:40.650 --> 29:41.650
然后循环它的属性

29:41.650 --> 29:42.650
这个是毫无疑问的

29:42.650 --> 29:44.650
关键是这里是不是要判断

29:44.650 --> 29:46.650
是不是要判断了

29:46.650 --> 29:48.650
如果你是深度克隆的话

29:48.650 --> 29:49.650
那么我们怎么样

29:49.650 --> 29:51.650
深度克隆

29:51.650 --> 29:53.650
好 如果你是浅度克隆的话

29:53.650 --> 29:54.650
浅度克隆很简单

29:54.650 --> 29:56.650
浅度克隆直接复制就完成了

29:56.650 --> 29:57.650
我们之前就用的是浅度克隆

29:57.650 --> 29:58.650
对吧

29:58.650 --> 29:59.650
是不是要判断了

29:59.650 --> 30:00.650
对它的属性

30:00.650 --> 30:01.650
然后进行判断

30:01.650 --> 30:03.650
好 那么深度克隆咋写呢

30:03.650 --> 30:05.650
因为它的属性呢

30:05.650 --> 30:06.650
又可能是对象

30:06.650 --> 30:10.650
又可能是

30:10.650 --> 30:12.650
那么这一块咋写呢

30:12.650 --> 30:14.650
你这里不能再判断吧

30:14.650 --> 30:15.650
再判断了签套太深了

30:15.650 --> 30:17.650
而且你判断完了过后

30:17.650 --> 30:18.650
如果它是对象怎么办

30:18.650 --> 30:19.650
你是不是还得循环它对象

30:19.650 --> 30:21.650
那如果对象里边还有对象

30:21.650 --> 30:22.650
你是不是还得循环

30:22.650 --> 30:23.650
那你要签到多少次呢

30:23.650 --> 30:25.650
你不知道要签到多少次了

30:25.650 --> 30:27.650
我们这里这样子写

30:27.650 --> 30:28.650
看着

30:28.650 --> 30:30.650
非常神奇的写法

30:30.650 --> 30:32.650
怎么写呢

30:32.650 --> 30:34.650
克隆

30:34.650 --> 30:36.650
就是z点克隆

30:36.650 --> 30:37.650
z是啥

30:37.650 --> 30:38.650
z就表示当前对象

30:38.650 --> 30:39.650
当前对象买plugin

30:39.650 --> 30:42.650
z点克隆

30:42.650 --> 30:43.650
然后呢

30:43.650 --> 30:45.650
我们现在要把什么克隆

30:45.650 --> 30:48.650
如果是深度克隆的话

30:48.650 --> 30:49.650
如果是深度克隆的话

30:49.650 --> 30:51.650
我们是不是要把属性的值

30:51.650 --> 30:52.650
再克隆一遍

30:52.650 --> 30:55.650
把属性的值再克隆一遍

30:55.650 --> 30:56.650
把这里传什么

30:56.650 --> 30:57.650
传地圖

30:57.650 --> 30:58.650
传地圖

30:58.650 --> 30:59.650
当然

30:59.650 --> 31:01.650
这里可以直接传出

31:01.650 --> 31:02.650
因为我们这里已经判断了

31:02.650 --> 31:03.650
对不对

31:03.650 --> 31:05.650
这里可以直接传出

31:05.650 --> 31:06.650
当然传的地圖也是一样

31:06.650 --> 31:07.650
因为它判断里边

31:07.650 --> 31:08.650
它是为去嘛

31:08.650 --> 31:09.650
对吧

31:09.650 --> 31:10.650
它为去

31:10.650 --> 31:12.650
所以说这里传过来还是去

31:12.650 --> 31:13.650
对这个属性

31:13.650 --> 31:15.650
再深度克隆一遍

31:15.650 --> 31:16.650
你看这是啥

31:16.650 --> 31:17.650
这是不是地规

31:17.650 --> 31:18.650
对吧

31:18.650 --> 31:19.650
地规的时候呢

31:19.650 --> 31:21.650
你不要去想的太多

31:21.650 --> 31:22.650
你不要去想的太多

31:22.650 --> 31:23.650
你想太多

31:23.650 --> 31:24.650
用云

31:24.650 --> 31:25.650
你就看那个逻辑

31:25.650 --> 31:26.650
是不是合理的

31:26.650 --> 31:27.650
逻辑是不是合理的呢

31:27.650 --> 31:28.650
如果你是前度克隆

31:28.650 --> 31:29.650
我直接复制就完事了

31:29.650 --> 31:30.650
如果你深度克隆

31:30.650 --> 31:31.650
OK

31:31.650 --> 31:32.650
那我把这个值

31:32.650 --> 31:33.650
去深度克隆

31:33.650 --> 31:35.650
那你一定要去想的话

31:35.650 --> 31:36.650
你想啊

31:36.650 --> 31:37.650
如果这个东西是对象

31:37.650 --> 31:38.650
那么是不是下一次

31:38.650 --> 31:39.650
调用这个函数的时候

31:39.650 --> 31:40.650
这里是不是要

31:40.650 --> 31:41.650
又要调用一次函数

31:41.650 --> 31:42.650
对吧

31:42.650 --> 31:43.650
重新调用函数

31:43.650 --> 31:44.650
下一次调用函数的时候

31:44.650 --> 31:45.650
是不是又要重新来

31:45.650 --> 31:46.650
重新来创建一个新的对象

31:46.650 --> 31:47.650
对吧

31:47.650 --> 31:48.650
它自己会完成克隆

31:48.650 --> 31:49.650
如果对象这个属性

31:49.650 --> 31:50.650
如果那个对象的属性里边

31:50.650 --> 31:51.650
还是对象的话

31:51.650 --> 31:52.650
它是不是又会去调用

31:52.650 --> 31:53.650
可能

31:53.650 --> 31:54.650
对吧

31:54.650 --> 31:55.650
直到它调用到什么

31:55.650 --> 31:56.650
调用到原始类型为止

31:56.650 --> 31:57.650
直到它发现这个东西

31:57.650 --> 31:58.650
是原始类型

31:58.650 --> 31:59.650
它就会返回

32:00.650 --> 32:01.650
这一部分就是

32:01.650 --> 32:03.650
帝规的中止条件

32:03.650 --> 32:06.650
中止条件

32:06.650 --> 32:07.650
好

32:07.650 --> 32:08.650
咱们来看一下吧

32:08.650 --> 32:09.650
看一下

32:09.650 --> 32:10.650
是不是能够导导导导导效果

32:10.650 --> 32:11.650
好

32:11.650 --> 32:12.650
这样子

32:12.650 --> 32:13.650
我们写了之后

32:13.650 --> 32:14.650
我们再来看一下

32:14.650 --> 32:15.650
6OB借

32:15.650 --> 32:16.650
这里还没有

32:16.650 --> 32:17.650
目前是浅度克隆

32:17.650 --> 32:18.650
目前是浅度克隆

32:18.650 --> 32:19.650
所以说

32:19.650 --> 32:20.650
6OB借的什么

32:20.650 --> 32:21.650
12OB借

32:21.650 --> 32:22.650
等于

32:22.650 --> 32:23.650
OB借的12OB借

32:23.650 --> 32:24.650
是相当的

32:24.650 --> 32:25.650
目前是浅度克隆

32:25.650 --> 32:26.650
因为我没有传第二个参数

32:26.650 --> 32:27.650
好

32:27.650 --> 32:28.650
我现在传第二个参数

32:29.650 --> 32:30.650
保存看一下

32:30.650 --> 32:31.650
好

32:31.650 --> 32:32.650
传到第二个参数过后

32:32.650 --> 32:33.650
我们再来看6OB借

32:33.650 --> 32:34.650
什么

32:34.650 --> 32:35.650
是不是等于

32:36.650 --> 32:37.650
它就不相等了

32:37.650 --> 32:39.650
两个就不一样了

32:39.650 --> 32:40.650
你看一下

32:40.650 --> 32:41.650
虽然它们都有

32:41.650 --> 32:42.650
看没有

32:42.650 --> 32:43.650
但是两个就不一样了

32:43.650 --> 32:44.650
两个是

32:44.650 --> 32:45.650
地址是不一样的

32:45.650 --> 32:46.650
那么这个时候

32:46.650 --> 32:47.650
你再去改变

32:47.650 --> 32:48.650
6OB借的

32:48.650 --> 32:49.650
什么

32:49.650 --> 32:50.650
7OB借的

32:50.650 --> 32:51.650
把它改成

32:51.650 --> 32:52.650
随便写

32:52.650 --> 32:53.650
然后再看

32:53.650 --> 32:54.650
OB借的

32:54.650 --> 32:55.650
7OB借

32:55.650 --> 32:56.650
是不是没变

32:56.650 --> 32:57.650
因为它是深度克隆

32:57.650 --> 32:58.650
好

32:58.650 --> 32:59.650
这样子可以适应各种场景

32:59.650 --> 33:00.650
那么比方说

33:00.650 --> 33:02.650
SUB

33:02.650 --> 33:03.650
SUB

33:03.650 --> 33:04.650
OB借

33:04.650 --> 33:05.650
下面还有一个数项

33:05.650 --> 33:06.650
还有一个数项

33:06.650 --> 33:07.650
比方说

33:07.650 --> 33:08.650
X

33:08.650 --> 33:09.650
3

33:09.650 --> 33:10.650
Y4

33:10.650 --> 33:11.650
这样子

33:11.650 --> 33:12.650
无所谓的

33:12.650 --> 33:13.650
因为它是地规

33:13.650 --> 33:14.650
它是地规

33:14.650 --> 33:15.650
它只要循环到

33:15.650 --> 33:16.650
它只要是深度克隆

33:16.650 --> 33:17.650
它会重新调整一次

33:17.650 --> 33:18.650
这个函数

33:18.650 --> 33:19.650
每一次调整这个函数

33:19.650 --> 33:20.650
是不是遇到对象

33:20.650 --> 33:21.650
就是新建对象

33:21.650 --> 33:22.650
遇到原生类型

33:22.650 --> 33:23.650
直接返回

33:23.650 --> 33:24.650
所以说

33:24.650 --> 33:25.650
就不用去担心

33:25.650 --> 33:26.650
不用担心

33:26.650 --> 33:27.650
地规这一块

33:27.650 --> 33:28.650
为什么很多同学学到

33:28.650 --> 33:29.650
地规这一块

33:29.650 --> 33:30.650
难理解了

33:30.650 --> 33:31.650
是因为

33:31.650 --> 33:32.650
他们觉得这个地规

33:32.650 --> 33:33.650
很难去想象

33:33.650 --> 33:35.650
程序是怎么执行的

33:35.650 --> 33:36.650
其实你不用去想

33:36.650 --> 33:37.650
程序是怎么执行的

33:37.650 --> 33:39.650
你就想拿合不合理就行了

33:39.650 --> 33:40.650
它是合理的就行了

33:40.650 --> 33:41.650
你看

33:41.650 --> 33:42.650
这两个仍然不相得

33:42.650 --> 33:44.650
这就是深度克隆

33:45.650 --> 33:46.650
好 针对数组

33:46.650 --> 33:47.650
再来

33:47.650 --> 33:48.650
针对数组怎么来深度克隆

33:48.650 --> 33:49.650
来吧

33:49.650 --> 33:50.650
判断

33:51.650 --> 33:52.650
如果是浅度克隆

33:53.650 --> 33:54.650
如果是深度克隆怎么样

33:54.650 --> 33:55.650
是深度克隆

33:56.650 --> 33:57.650
浅度克隆的话

33:57.650 --> 33:59.650
else

33:59.650 --> 34:00.650
如果是浅度克隆的话

34:00.650 --> 34:01.650
是不是直接这样子返回

34:01.650 --> 34:02.650
对不对

34:02.650 --> 34:03.650
浅度克隆直接返回

34:03.650 --> 34:04.650
又行了

34:04.650 --> 34:05.650
复制数组

34:05.650 --> 34:06.650
复制数组本身就行了

34:06.650 --> 34:08.650
如果数组里边还有东西

34:08.650 --> 34:09.650
还有东西是不是要

34:09.650 --> 34:10.650
一代循环数组

34:10.650 --> 34:11.650
对不对

34:11.650 --> 34:12.650
对循环数组

34:12.650 --> 34:13.650
new

34:13.650 --> 34:14.650
等于什么

34:14.650 --> 34:15.650
一个新的数组

34:15.650 --> 34:16.650
一代循环数组

34:16.650 --> 34:17.650
循环什么

34:17.650 --> 34:19.650
循环原来的数组

34:19.650 --> 34:20.650
i等于0

34:20.650 --> 34:21.650
i小于什么

34:21.650 --> 34:23.650
obj的nance

34:23.650 --> 34:24.650
i++

34:24.650 --> 34:25.650
对不对

34:25.650 --> 34:27.650
你在这样子循环数组

34:27.650 --> 34:28.650
循环数组

34:28.650 --> 34:29.650
那么每一次循环的时候

34:29.650 --> 34:30.650
是不是往新数组里边

34:30.650 --> 34:31.650
铺起一个

34:31.650 --> 34:32.650
加一个东西

34:32.650 --> 34:33.650
对吧

34:33.650 --> 34:34.650
加一个东西

34:34.650 --> 34:35.650
加什么东西呢

34:35.650 --> 34:37.650
加什么东西呢

34:37.650 --> 34:38.650
你在网上

34:38.650 --> 34:39.650
里边加一个东西

34:39.650 --> 34:41.650
关于是加什么东西

34:41.650 --> 34:42.650
加什么东西

34:42.650 --> 34:43.650
加的东西

34:43.650 --> 34:44.650
是不是

34:44.650 --> 34:45.650
还在克隆一边

34:45.650 --> 34:46.650
对不对

34:46.650 --> 34:47.650
你怎么知道

34:47.650 --> 34:48.650
他加的是什么

34:48.650 --> 34:49.650
比方说你不能这样子写

34:49.650 --> 34:50.650
那万一这个是个对象

34:50.650 --> 34:52.650
你是不是地址又一样了

34:52.650 --> 34:53.650
对不对

34:53.650 --> 34:54.650
数组里面存在对象的地址

34:54.650 --> 34:55.650
所以说你这里呢

34:55.650 --> 34:57.650
是不是还得把它克隆一边加进去

34:57.650 --> 34:58.650
对不对

34:58.650 --> 34:59.650
那么这里呢

34:59.650 --> 35:00.650
我们可以

35:06.650 --> 35:07.650
把克隆一边加进去

35:07.650 --> 35:08.650
把这个东西

35:08.650 --> 35:10.650
克隆一边加到数组里边去

35:10.650 --> 35:11.650
那么到时候克隆的时候

35:11.650 --> 35:12.650
如果他还是一个数组

35:12.650 --> 35:14.650
是不是他又要经过这么一次循环

35:14.650 --> 35:15.650
对吧

35:15.650 --> 35:16.650
如果他是一个对象的话

35:16.650 --> 35:17.650
是不是要经过这儿

35:17.650 --> 35:18.650
对不对

35:18.650 --> 35:19.650
总之让他去完成

35:19.650 --> 35:20.650
这个是合理的就行了

35:20.650 --> 35:21.650
对吧

35:21.650 --> 35:22.650
这个逻辑是合理的就行了

35:22.650 --> 35:23.650
你不要想太多

35:23.650 --> 35:25.650
不要去想他程序怎么执行的

35:25.650 --> 35:26.650
因为地规这个东西

35:26.650 --> 35:29.650
它是寒树式编程领域里边的东西

35:29.650 --> 35:31.650
我们后边还会多多少少

35:31.650 --> 35:33.650
涉及到一点点寒树式编程

35:33.650 --> 35:35.650
叫做寒树式编程

35:35.650 --> 35:37.650
寒树式编程

35:37.650 --> 35:38.650
寒树式编程

35:38.650 --> 35:40.650
它不是说你写寒树

35:40.650 --> 35:42.650
就叫做寒树式编程的

35:42.650 --> 35:43.650
跟面向对象一样

35:43.650 --> 35:44.650
面向对象呢

35:44.650 --> 35:45.650
就是不是说你写了对象

35:45.650 --> 35:47.650
你就是面向对象开发了

35:47.650 --> 35:48.650
那纯粹扯答案

35:48.650 --> 35:49.650
对吧

35:49.650 --> 35:50.650
寒树呢

35:50.650 --> 35:52.650
寒树是一种语法

35:52.650 --> 35:53.650
是一种语法规则

35:53.650 --> 35:54.650
寒树式编程

35:54.650 --> 35:56.650
它是一种程序思想

35:56.650 --> 35:58.650
它是一道思想层面了

35:58.650 --> 35:59.650
再说高大商业点

35:59.650 --> 36:01.650
它是一道哲学层面了

36:01.650 --> 36:02.650
它指的是一种方法论

36:02.650 --> 36:04.650
指的是我用一种什么样的

36:04.650 --> 36:06.650
切入点来思考程序

36:06.650 --> 36:07.650
寒树式编程有个特点

36:07.650 --> 36:09.650
你不要去考虑程序是怎么运行的

36:09.650 --> 36:11.650
你考虑要运

36:11.650 --> 36:12.650
你只需要考虑

36:12.650 --> 36:14.650
这个计算是不是符合逻辑就行了

36:14.650 --> 36:16.650
那这里的计算是符合逻辑的

36:16.650 --> 36:19.650
地规是寒树式编程领域里边的一个概念

36:20.650 --> 36:21.650
你不是

36:21.650 --> 36:22.650
如果你是深度客龙

36:22.650 --> 36:23.650
是不是还得客龙一边对它

36:23.650 --> 36:24.650
那客龙呗

36:24.650 --> 36:26.650
客龙就完事了

36:26.650 --> 36:27.650
这就是深度客龙

36:27.650 --> 36:29.650
那咱们来看一下数组

36:29.650 --> 36:30.650
数组这一块

36:31.650 --> 36:32.650
比方说

36:32.650 --> 36:33.650
比方说有这么一个数组

36:33.650 --> 36:35.650
这个数组很奇特

36:35.650 --> 36:36.650
里边有一个

36:36.650 --> 36:37.650
第一个是数字吧

36:37.650 --> 36:38.650
第二个是一个

36:38.650 --> 36:40.650
第二个又是个数组

36:40.650 --> 36:41.650
又是个数组

36:41.650 --> 36:42.650
第三个是一个对象

36:42.650 --> 36:43.650
这个对象里边

36:43.650 --> 36:45.650
x它又是个数组

36:45.650 --> 36:46.650
咱们看一下

36:46.650 --> 36:48.650
现在能不能深度客龙

36:48.650 --> 36:49.650
保存

36:49.650 --> 36:50.650
诶

36:50.650 --> 36:52.650
客龙有点抵犯

36:52.650 --> 36:53.650
这里这里这里

36:53.650 --> 36:54.650
z

36:54.650 --> 36:55.650
z的客龙

36:56.650 --> 36:57.650
看一下

36:57.650 --> 36:58.650
6ob界

36:59.650 --> 37:00.650
抵犯

37:00.650 --> 37:01.650
没返回

37:01.650 --> 37:03.650
return new ar

37:03.650 --> 37:05.650
return new ar

37:05.650 --> 37:06.650
好

37:06.650 --> 37:07.650
保存

37:07.650 --> 37:08.650
看一下

37:11.730 --> 37:12.730
看一下

37:12.730 --> 37:14.730
这个新的对象里边

37:14.730 --> 37:15.730
新的数组里边

37:15.730 --> 37:16.730
你看是不是

37:16.730 --> 37:17.730
有这些东西的

37:17.730 --> 37:18.730
都有了

37:18.730 --> 37:19.730
好

37:19.730 --> 37:20.730
看一下

37:20.730 --> 37:21.730
6ob界

37:21.730 --> 37:22.730
它的d

37:22.730 --> 37:23.730
下标为1的

37:23.730 --> 37:24.730
是不是等于

37:24.730 --> 37:26.730
ob界下标为1的呢

37:26.730 --> 37:27.730
不相等

37:27.730 --> 37:28.730
说明这个数组也被客龙

37:28.730 --> 37:29.730
客龙了一次

37:29.730 --> 37:30.730
好

37:30.730 --> 37:31.730
然后6ob界

37:31.730 --> 37:32.730
然后下标为2的

37:32.730 --> 37:33.730
它里边是个对象

37:33.730 --> 37:34.730
对吧

37:34.730 --> 37:35.730
对象里边

37:35.730 --> 37:36.730
看一下是不是相等

37:36.730 --> 37:37.730
ob界2

37:37.730 --> 37:38.730
不相等

37:38.730 --> 37:39.730
好

37:39.730 --> 37:40.730
再来

37:40.730 --> 37:41.730
6ob界

37:41.730 --> 37:42.730
它的下标为2

37:42.730 --> 37:43.730
它是个对象

37:43.730 --> 37:44.730
对象里边还有一个x属性

37:44.730 --> 37:45.730
它是不是跟这个

37:45.730 --> 37:47.730
ob界

37:47.730 --> 37:48.730
2里边的x是相等的

37:48.730 --> 37:49.730
也不相等

37:49.730 --> 37:50.730
看看全都客龙了一遍

37:50.730 --> 37:51.730
你看这个寒树里边

37:51.730 --> 37:53.730
只有原始内详是直接返回的

37:53.730 --> 37:55.730
其他的都要进行客龙

37:55.730 --> 37:56.730
对不对

37:56.730 --> 37:57.730
好吧

37:57.730 --> 37:58.730
这是关于这一块

37:58.730 --> 38:00.730
如何来进行深度客龙

38:00.730 --> 38:01.730
最终代码形成这种格式了

38:01.730 --> 38:02.730
代码量并不多

38:02.730 --> 38:03.730
只是这个代码

38:03.730 --> 38:04.730
对初学者很难理解

38:04.730 --> 38:05.730
关键是寒树这边

38:05.730 --> 38:06.730
关键是这个

38:06.730 --> 38:07.730
就是

38:07.730 --> 38:08.730
地规

38:08.730 --> 38:09.730
地规这里呢

38:09.730 --> 38:10.730
你一定不要去

38:10.730 --> 38:11.730
生想

38:11.730 --> 38:12.730
它的程序是怎么执行的

38:12.730 --> 38:13.730
因为它是寒树这边

38:13.730 --> 38:14.730
里面的概念

38:14.730 --> 38:15.730
寒树这边

38:15.730 --> 38:16.730
它一个特点就是

38:16.730 --> 38:18.730
你不要去想程序是怎么运行的

38:18.730 --> 38:19.730
你只要去想

38:19.730 --> 38:20.730
这个邪法是不是合理的

38:20.730 --> 38:21.730
就行了

38:21.730 --> 38:22.730
是不是正确的就行了

38:22.730 --> 38:24.730
原来这个意思吧

38:24.730 --> 38:25.730
OK

38:27.730 --> 38:28.730
寒树这边层

38:28.730 --> 38:29.730
其实我带多说一点

38:29.730 --> 38:30.730
寒树这边层

38:30.730 --> 38:32.730
它是一个边层范式

38:32.730 --> 38:33.730
什么范式呢

38:33.730 --> 38:34.730
叫做生明式边层

38:34.730 --> 38:36.730
生明式边层

38:36.730 --> 38:38.730
生明式边层

38:39.730 --> 38:41.730
还有一种边层范式呢

38:41.730 --> 38:43.730
叫做命令式边层

38:43.730 --> 38:45.730
命令式边层

38:45.730 --> 38:46.730
生明式边层里面

38:46.730 --> 38:47.730
除了寒树式边层之外呢

38:47.730 --> 38:48.730
还有什么

38:48.730 --> 38:50.730
还有什么atma

38:50.730 --> 38:51.730
和CSS

38:51.730 --> 38:53.730
这些东西都是生明式边层

38:53.730 --> 38:54.730
生明式边层有个特点就是

38:54.730 --> 38:56.730
我只描述我要干嘛

38:56.730 --> 38:57.730
我不太care

38:57.730 --> 38:58.730
不太关心

38:58.730 --> 39:00.730
它到底具体是怎么干的

39:00.730 --> 39:01.730
包括我们之前学的

39:01.730 --> 39:02.730
atma和CSS就是

39:02.730 --> 39:04.730
我说这里有个元素

39:04.730 --> 39:05.730
我咋知道这个元素

39:05.730 --> 39:06.730
是怎么显示在页面上的

39:06.730 --> 39:07.730
它怎么显示的

39:07.730 --> 39:08.730
我说这里要

39:08.730 --> 39:09.730
颜色变成红色

39:09.730 --> 39:10.730
它为什么

39:10.730 --> 39:11.730
它怎么把颜色变成红色的

39:11.730 --> 39:13.730
我不用去考虑

39:13.730 --> 39:15.730
这是生明式边层的特点

39:15.730 --> 39:16.730
你管它是怎么变的呢

39:16.730 --> 39:18.730
我只需要把atma写出来就行了

39:18.730 --> 39:20.730
寒树式边层也是这样子

39:20.730 --> 39:22.730
它就是说我只要描述我要干嘛

39:22.730 --> 39:23.730
就行了

39:23.730 --> 39:25.730
我不用去管它具体是怎么干的

39:25.730 --> 39:27.730
第一规就是这样一个概念

39:27.730 --> 39:28.730
命令式边层的就是

39:28.730 --> 39:30.730
我给计算机下达指令

39:30.730 --> 39:31.730
所以说我就必须要知道

39:31.730 --> 39:32.730
计算机的工作原理

39:32.730 --> 39:33.730
因此我们讲介事的时候

39:33.730 --> 39:34.730
是不是讲了很多

39:34.730 --> 39:35.730
什么内存

39:35.730 --> 39:36.730
什么底层的

39:36.730 --> 39:38.730
什么圆形圆形链这些东西

39:38.730 --> 39:40.730
这是命令式边层的特点

39:40.730 --> 39:41.730
命令式边层的它的语言

39:41.730 --> 39:42.730
比如说什么

39:42.730 --> 39:44.730
绝大部分语言都是命令式边层

39:44.730 --> 39:45.730
比如说C++

39:45.730 --> 39:46.730
Java

39:46.730 --> 39:47.730
Csharp

39:47.730 --> 39:49.730
还有什么介事都是命令式边层的语言

39:49.730 --> 39:51.730
但它里面能不能写寒树式边层的

39:51.730 --> 39:53.730
这种方式可以写

39:53.730 --> 39:54.730
介事是支持

39:54.730 --> 39:57.730
我们说介事是支持的是多范式边层

39:57.730 --> 39:59.730
它既可以用寒树式

39:59.730 --> 40:01.730
也可以用命令式

40:01.730 --> 40:03.730
刚才我们就用的是寒树式

40:03.730 --> 40:04.730
它只是要找一个文儿

40:04.730 --> 40:06.730
你再自己写个寒树而已

40:06.730 --> 40:07.730
然后呢

40:07.730 --> 40:09.730
比方说还咱们的边层思想里面

40:09.730 --> 40:11.730
面向对象编程

40:11.730 --> 40:12.730
还有什么

40:12.730 --> 40:14.730
还有就是

40:14.730 --> 40:15.730
面向过程

40:15.730 --> 40:17.730
面向过程就是指的是先做什么

40:17.730 --> 40:18.730
再做什么

40:18.730 --> 40:19.730
面向对象就是

40:19.730 --> 40:21.730
我怎么把程序划分为多个对象

40:21.730 --> 40:22.730
这些东西

40:22.730 --> 40:25.730
这些思维的都是命令式边层里面的东西

40:25.730 --> 40:26.730
了解一下就行了

40:26.730 --> 40:28.730
因为这是边层思想的范畴

40:28.730 --> 40:31.730
边层思想是可以作为一面课程的

40:31.730 --> 40:35.040
这里就写完了

40:35.040 --> 40:36.040
就写完了

40:36.040 --> 40:37.040
就没啥了

40:37.040 --> 40:38.040
没啥了

40:38.040 --> 40:39.040
这就是对象克隆

40:39.040 --> 40:40.040
大家下来了

40:40.040 --> 40:42.040
把这两个东西写好

40:42.040 --> 40:44.040
对象克隆又有什么用呢

40:44.040 --> 40:46.040
有什么用呢

40:46.040 --> 40:47.040
比方说

40:47.040 --> 40:48.040
我们写个例子

40:48.040 --> 40:49.040
当这个例子

40:49.040 --> 40:50.040
我们后来不太会写

40:50.040 --> 40:52.040
就是给大家说一下

40:52.040 --> 40:53.040
说一下

40:53.040 --> 40:54.040
因为这个例子也是把它复杂的

40:54.040 --> 40:55.040
比方说

40:55.040 --> 40:57.040
我们做一个

40:57.040 --> 40:58.040
中国象棋

40:58.040 --> 40:59.040
或者是五字棋

40:59.040 --> 41:00.040
或者是什么棋

41:00.040 --> 41:02.040
棋的这个游戏

41:02.040 --> 41:03.040
我们往往会有一个对象

41:03.040 --> 41:04.040
叫做棋盘

41:04.040 --> 41:06.040
棋盘布的

41:06.040 --> 41:07.040
棋盘里边

41:07.040 --> 41:08.040
会有很多棋子

41:08.040 --> 41:10.040
会有很多棋子

41:10.040 --> 41:11.040
然后我们

41:11.040 --> 41:12.040
每个棋子是一个对象

41:12.040 --> 41:13.040
对吧

41:13.040 --> 41:14.040
棋子有什么坐标

41:14.040 --> 41:15.040
对不对

41:15.040 --> 41:16.040
棋子有坐标

41:16.040 --> 41:17.040
每个棋子是一个对象

41:17.040 --> 41:18.040
所以说棋盘

41:18.040 --> 41:19.040
可以认为是一个数组

41:19.040 --> 41:22.040
比方说是一个数组

41:22.040 --> 41:23.040
它里边有很多棋子

41:23.040 --> 41:24.040
每个棋子里边

41:24.040 --> 41:25.040
它有坐标

41:25.040 --> 41:26.040
棋子的坐标

41:26.040 --> 41:27.040
比方随便写

41:27.040 --> 41:28.040
随便写写

41:28.040 --> 41:29.040
棋子的名字

41:29.040 --> 41:30.040
比方说

41:30.040 --> 41:31.040
中国象棋里边的匠

41:31.040 --> 41:32.040
对不对

41:32.040 --> 41:33.040
棋子的名字

41:33.040 --> 41:34.040
这是一个棋子

41:34.040 --> 41:35.040
一个棋子

41:35.040 --> 41:36.040
然后

41:36.040 --> 41:37.040
肯定还有多个棋子

41:37.040 --> 41:38.040
对吧

41:38.040 --> 41:39.040
肯定还有多个棋子

41:39.040 --> 41:40.040
我就不写了

41:40.040 --> 41:41.040
我就不写了

41:41.040 --> 41:42.040
我先我就说一下这里

41:42.040 --> 41:43.040
这里的情况

41:43.040 --> 41:45.040
那么这个时候

41:45.040 --> 41:46.040
比方说

41:46.040 --> 41:48.040
比方说

41:48.040 --> 41:49.040
用户

41:49.040 --> 41:50.040
他要做这么一个操作

41:50.040 --> 41:51.040
将某一个棋子

41:51.040 --> 41:53.040
移动到某一个位置

41:53.040 --> 41:55.040
移动到某一个位置

41:55.040 --> 41:56.040
好

41:56.040 --> 41:57.040
那么这个时候

41:57.040 --> 41:58.040
我们可以用这种方式

41:58.040 --> 41:59.040
来处理

41:59.040 --> 42:00.040
就是比方说

42:00.040 --> 42:01.040
改变他的XY坐标

42:01.040 --> 42:02.040
对吧

42:02.040 --> 42:03.040
比方说这里是车

42:03.040 --> 42:05.040
它也要移动一个棋子

42:05.040 --> 42:06.040
到某一个位置

42:06.040 --> 42:07.040
可以改变

42:07.040 --> 42:08.040
到时候就可以改变

42:08.040 --> 42:09.040
这个棋子的坐标

42:09.040 --> 42:10.040
3

42:10.040 --> 42:11.040
2

42:11.040 --> 42:12.040
比方改变一下他的坐标

42:12.040 --> 42:13.040
你要这意思吧

42:13.040 --> 42:14.040
好

42:14.040 --> 42:15.040
改变了坐标之后

42:15.040 --> 42:17.040
改变了坐标之后

42:17.040 --> 42:18.040
会有一个问题

42:18.040 --> 42:20.040
就是这个移动

42:20.040 --> 42:21.040
他移动

42:21.040 --> 42:22.040
如果移动过去了

42:22.040 --> 42:23.040
那么这个棋局

42:23.040 --> 42:25.040
会发生变化

42:25.040 --> 42:26.040
但是有的时候

42:26.040 --> 42:27.040
它是不能移动过去的

42:27.040 --> 42:28.040
比方说

42:28.040 --> 42:29.040
根据一些棋子的规则

42:29.040 --> 42:30.040
它是不能移动到

42:30.040 --> 42:31.040
这个位置的

42:31.040 --> 42:32.040
如果移动到的位置的话

42:32.040 --> 42:33.040
这个棋局

42:33.040 --> 42:35.040
会不满足规则

42:35.040 --> 42:36.040
比方说

42:36.040 --> 42:37.040
中国相机里边

42:37.040 --> 42:38.040
两个网见面了

42:38.040 --> 42:39.040
对吧

42:39.040 --> 42:40.040
你车就移不开

42:40.040 --> 42:41.040
移开了过后

42:41.040 --> 42:42.040
两个网就见面了

42:42.040 --> 42:43.040
但是我们在程序里边

42:43.040 --> 42:44.040
处理的时候

42:44.040 --> 42:45.040
会怎么处理呢

42:45.040 --> 42:48.040
我们先假设它能移开

42:48.040 --> 42:50.040
假设它移动成功了

42:50.040 --> 42:51.040
移动成功过后

42:51.040 --> 42:52.040
我们来分析一下

42:52.040 --> 42:53.040
这个棋局

42:53.040 --> 42:54.040
是不是合理的

42:54.040 --> 42:55.040
是不是正确的

42:55.040 --> 42:56.040
是不是满足规则

42:56.040 --> 42:57.040
如果不满足规则

42:57.040 --> 42:59.040
说明这个移动是失败的

42:59.040 --> 43:01.040
那么这就会产生问题

43:01.040 --> 43:02.040
如果既然是

43:02.040 --> 43:03.040
我要先假设

43:03.040 --> 43:04.040
它能够移动过去

43:04.040 --> 43:05.040
先假设它移动过去了

43:05.040 --> 43:06.040
那么

43:06.040 --> 43:07.040
如果我直接改变了

43:07.040 --> 43:08.040
这个对象里边的属性的话

43:08.040 --> 43:10.040
它就已经完成移动了

43:10.040 --> 43:11.040
它就已经完成移动了

43:11.040 --> 43:13.040
到时候我们再看这个对象

43:13.040 --> 43:15.040
这个规则不满足了

43:15.040 --> 43:17.040
这个棋盘的规则不满足了

43:17.040 --> 43:18.040
两个网见面了

43:18.040 --> 43:19.040
那怎么办呢

43:19.040 --> 43:20.040
这个时候已经移动了

43:20.040 --> 43:21.040
已经成事实了

43:21.040 --> 43:22.040
因为你改变了

43:22.040 --> 43:23.040
这个对象

43:23.040 --> 43:24.040
对吧

43:24.040 --> 43:25.040
已经成为事实了

43:25.040 --> 43:26.040
所以说

43:26.040 --> 43:27.040
到时候你就不太好处理的

43:27.040 --> 43:28.040
不太好处理的

43:28.040 --> 43:29.040
因此

43:29.040 --> 43:30.040
我们这里往往会怎么做呢

43:30.040 --> 43:31.040
就它进行刻龙

43:31.040 --> 43:33.040
刻龙一个棋盘出来

43:33.040 --> 43:34.040
就像你下棋的时候

43:34.040 --> 43:35.040
那假设

43:35.040 --> 43:37.040
我要做移动这一步棋

43:37.040 --> 43:38.040
我先把它的原封不动

43:38.040 --> 43:39.040
刻龙一个新的棋盘出来

43:39.040 --> 43:40.040
在新的棋盘里边

43:40.040 --> 43:41.040
我去走这一步

43:41.040 --> 43:42.040
而走到之后

43:42.040 --> 43:43.040
我去判断一下

43:43.040 --> 43:44.040
新的棋盘

43:44.040 --> 43:45.040
是不是能够移动

43:45.040 --> 43:47.040
是不是能够完成这个移动

43:47.040 --> 43:48.040
是不是满足规则的

43:48.040 --> 43:49.040
如果不满足的话

43:49.040 --> 43:50.040
那我这个对象就不动

43:50.040 --> 43:51.040
如果能满足的话

43:51.040 --> 43:53.040
我再去动这个对象

43:53.040 --> 43:54.040
对吧

43:54.040 --> 43:56.040
可能会遇到这么一些场景

43:56.040 --> 43:58.040
那么就需要用到刻龙

43:59.040 --> 44:02.040
这是关于对象刻龙和对象混合

44:02.040 --> 44:04.480
好

44:04.480 --> 44:05.480
下来把这两个圈完成

44:05.480 --> 44:07.480
把这个复杂棋里边

44:07.480 --> 44:08.480
加上这两个函数

44:08.480 --> 44:09.480
一个是Mixing

44:09.480 --> 44:10.480
表示混合

44:10.480 --> 44:11.480
一个是刻龙

