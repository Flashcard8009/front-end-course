WEBVTT

00:00.000 --> 00:03.840
原始内形包装器

00:13.220 --> 00:20.380
就是我们之前上一张韩束的张结说过的就是那个

00:21.160 --> 00:23.700
对原始内形啊 什么Number

00:23.960 --> 00:26.520
Number它有一个对应的构造韩束

00:26.780 --> 00:28.060
然后有一个Steam

00:28.320 --> 00:29.600
有构造韩束

00:29.860 --> 00:30.880
有一个什么布林

00:31.140 --> 00:32.160
有构造韩束

00:32.420 --> 00:34.460
咱们把这个两个先讲这两个吧

00:35.480 --> 00:37.280
其实这些可能就主要是讲这三个

00:37.680 --> 00:41.380
之前我也说过啊 对于这三个原始内形啊

00:41.640 --> 00:43.680
我们可以把它当成对象来使用

00:43.940 --> 00:46.500
当我们去把它当成对象使用的时候

00:46.760 --> 00:49.320
比如说我写一个数字 这里见个页面吧

00:50.080 --> 00:52.120
再回忆一下啊 帮大家回忆一下

00:52.640 --> 00:56.480
就是说呢我这里呢比方说啊我写了一个数字啊变量

00:56.740 --> 00:58.020
变量一个数字

00:58.280 --> 01:04.420
然后呢去通过这个原始内形一个数字的原始内形把它当成对象去使用

01:04.680 --> 01:05.960
是可以使用的

01:06.420 --> 01:07.460
为什么可以使用呢

01:07.700 --> 01:12.580
是因为是因为这个对象这个原始内形呢你把它当成对象使用

01:12.820 --> 01:14.360
它去调用它的属性

01:14.620 --> 01:15.900
或者是方法的时候呢

01:16.420 --> 01:17.940
这里呢它会自动的

01:18.200 --> 01:20.500
把这个位置呢转换成对应的

01:22.040 --> 01:25.100
对象 把它转换成对应的对象 它会这样子自动进行转换

01:25.360 --> 01:26.140
它是这么回事

01:26.660 --> 01:28.180
我们这里呢学习的就是

01:28.440 --> 01:29.220
关于这个

01:29.720 --> 01:33.040
构造韩束 关于这个构造韩束里边用哪些静态属性

01:33.300 --> 01:34.840
有哪些静态的方法

01:35.420 --> 01:38.120
这个东西呢就是专门来针对原始内形

01:38.380 --> 01:40.420
它给它做的一个对应的构造韩束

01:40.680 --> 01:43.500
我们把它叫做包装内或者叫做包装器

01:44.260 --> 01:46.820
好 我们一个个说吧啊 先说这个Number

01:47.580 --> 01:48.220
还是一样啊

01:48.460 --> 01:50.140
咱们在百度里边去搜索一下

01:51.940 --> 01:54.500
搜索什么呢 怎么说呢 就是Number

01:54.760 --> 01:55.780
然后MNDN

01:56.040 --> 01:58.060
有些同学说可能有一问啊

01:58.060 --> 02:00.140
为什么我老是去查这个MNDN

02:00.400 --> 02:01.820
而没有去查什么呢

02:02.080 --> 02:04.740
没有去查这个官方文档

02:05.140 --> 02:06.620
好 我这里给大家看一下啊

02:06.880 --> 02:08.180
看一下这个官方文档

02:08.420 --> 02:10.980
很投通的啊 它官方文档看着

02:11.240 --> 02:12.020
acma script

02:14.060 --> 02:15.580
看它的官网啊 官网

02:16.360 --> 02:17.900
在这 这它的官网

02:19.180 --> 02:19.940
我们看一下啊

02:20.460 --> 02:24.820
这官网看上去很投通的 不要说不是中文的问题啊 倒不是中文

02:25.060 --> 02:28.660
这是看上去它的格式啊 排版这种啊 是非常非常投通的

02:28.900 --> 02:31.720
这个组织呢 它有出了很多的标准啊

02:31.980 --> 02:34.020
届时呢 是它其中一个标准啊

02:34.220 --> 02:35.500
是它其中一个的标准

02:35.760 --> 02:36.540
acma这个组织

02:37.040 --> 02:41.900
看中就很投通 所以说呢 我们看一个比较友好一点的一个网站

02:42.160 --> 02:43.440
它写的也非常详细

02:43.700 --> 02:46.520
另外呢 为什么我不去看W3C啊

02:46.780 --> 02:47.800
为什么不去看这个呢

02:48.060 --> 02:51.640
我知道啊 咱们国内呢 有个东西叫W3School

02:53.420 --> 02:58.300
这个网站呢 其实也可以啊 也不错 特别是对于初学者呢 非常友好

02:58.800 --> 03:02.640
但是呢 这个网站有个问题啊 它就是它写的很简略

03:02.680 --> 03:06.420
它写的不全 很多东西呢 解释起来 解释了很模糊

03:06.700 --> 03:10.780
所以说呢 我也没有打算去看这个 我平时呢 看了最多的就是个MDN

03:11.300 --> 03:16.060
MDN它写的继详细 而且呢 看上去的一个排版啊 之类的东西也比较友好啊

03:16.340 --> 03:18.380
所以咱们看这个 好 进去看一下啊

03:20.490 --> 03:22.970
看一下啊 这个Number啊 Number

03:23.450 --> 03:28.530
啊 它怎么用呢 它这里有两种用法啊 一种是呢 新建一个构造函数啊

03:28.530 --> 03:33.090
就是六一个 把构造函数放在 放在这 然后呢 参数放在这

03:33.450 --> 03:39.350
参数来传什么呢 就传原式内想 原式内想 一个数字嘛 当然你可以传别的内想

03:39.870 --> 03:44.110
它会把它转换成数字啊 它这个东西呢 它有个作用就是把它转换成数字

03:44.510 --> 03:50.990
这是第一种调用方式 还有另外一种调用方式呢 它这里说到了啊 如果无法转换成数字的话 反回NN

03:52.310 --> 03:58.550
如果它有另外一种用法 就是直接用这个函数啊 就两种用法 咱们来看一下啊 这两种用法

03:59.410 --> 04:03.170
不光是这啊 不光是这 一会呢 我们讲到其他的那个就是

04:04.130 --> 04:06.730
包装器的时候呢 也是同样的啊 同样的道理

04:07.490 --> 04:13.490
对 刷新一下啊 比方说啊 我有一个数字1啊 把它转换成 用一个Number

04:14.090 --> 04:21.050
把它转换成一个对象啊 你看 得到的结果呢 就是一个对象啊 得到的结果就是一个对象 你看 这种格式就是个对象

04:21.830 --> 04:28.630
好 如果我直接使用number 把1传进去 你看 得到的是原始类型啊 得到的是原始类型

04:29.350 --> 04:38.470
所以说了这两种啊 我们这里说一下吧 包装器呢 它的用法有两种啊 一种是呢 什么6一个包装器

04:40.830 --> 04:48.270
6一个包装器 传一个值 它会自动进行转换 比方说这里是数字 number 那么它就把它转换成数字 转换不了的话 就是NN

04:48.850 --> 04:54.050
如果是什么玩意了 如果是一个 如果这里写的是布定 它就把它转换成布而

04:54.770 --> 05:02.770
如果是Skin了 它就把它转换成字符串啊 它就可以帮你转换 它这个东西返回的啊 返回的是一个对象

05:04.130 --> 05:09.970
好 另外一种用法呢 是包装器 就是不显6啊 直接调用函数 你把值传进去

05:10.530 --> 05:16.850
那么这个东西呢 它也可以转换成相应的类型 比方说啊 比方说我们刚才这里 我们这样的写啊 number

05:17.310 --> 05:23.310
一个字符串啊 或者是一个布尔吧 一个布尔 你看 它也可以帮你进行转换啊 那重用是转换类型

05:23.870 --> 05:28.670
那么它可以转换类型 但是它返回的是一个原始类型

05:29.510 --> 05:32.350
注意下这两个的区别啊 6呢 它返回的是一个对象

05:33.150 --> 05:36.950
这个东西呢 返回的是一个原始类型啊 它这个构造函数里面进行了处理的

05:37.630 --> 05:43.550
好吧 这里先说一下这个 好 今天我们在具体的研究啊 囊边里边有哪些成员可以跟我们使用

05:44.490 --> 05:49.370
也是经常用的啊 首先看到的静态的静态的成员就静态属性

05:50.090 --> 05:57.250
静态属性的这里我们已经介绍过一些了的话 n a n 啊 如果你看我看过我的扩展课程的话 你可以看到这个max value对吧

05:57.490 --> 06:02.250
和max safe integer啊 当然如果你不了解的话 其实也无所谓啊 其实也无所谓

06:02.890 --> 06:08.010
好 咱们看一下它的静态方法啊 这都是静态方法 所以介绍过的意思 n a n

06:08.750 --> 06:15.230
只不过呢 这些静态方法呢 它一般呢 为了让你使用方便啊 浏览器呢

06:16.030 --> 06:23.230
把它挂到了哪儿了 把它挂到了全局对象 全局对象温度里边 我现在怎么回事 吐司不清楚

06:24.190 --> 06:31.510
就是你看这个n a n 啊 它可以在Number里边当成静态函数直接使用 你看没有 它可以这样子啊 得到这个函数

06:31.910 --> 06:35.350
也可以呢 在温度对象里边也有这个东西啊 也有这个东西

06:36.010 --> 06:41.490
看没 也有 所以说我们两 因为由于温度对象里边有 说说你是不是可以直接使用

06:42.010 --> 06:48.130
对吧 你用的这个意思 n a n 实际上跟什么 实际上就是温度里边的这个意思 n a n

06:48.770 --> 06:54.930
实际上用的就是这个玩意 你看这个意思啊 它是吧 为了让你用的方便可以 它把它挂到这个全局对象里边

06:55.290 --> 07:01.730
那么你可以直接使用 这是关于一些Number里边一些常见的静态函数啊 它把它挂到温度里边了

07:02.110 --> 07:14.830
啊 但是呢 这个不是标准啊 标准是在Number里边 标准里边没有什么温度对象啊 温度对象字里无难器环境里边给你注入的 咱们之前说过对吧 咱们学的意思呢 是一个语言标准

07:15.870 --> 07:24.390
在不同的环境下面呢 这些数组环境呢会给你 给你加注一些东西 比方说全局对象温度 它就是数组环境给你加注的

07:25.370 --> 07:38.850
但是标准里边呢 它是放到Number里边的 这说一下啊 一是NAN判断一个值是不是NAN 这个没什么好说的 一是INFINIT 表示判断一个数字呢 是不是有限的数字

07:39.570 --> 07:49.210
是不是有限的数字 如果你看过我这个 关于运算符这个扩展课程啊 这个数字的存储这一块的话 你就知道了啊 什么叫做有限 什么叫做无限啊

07:50.190 --> 08:06.430
这里呢 一是INTAGAR 这个是判断啥呢 判断的 你给的值啊 它是不是一个整数 因为我们的数字呢 还分为整数和小数嘛 对吧 那么这个一是INTAGAR INTAGAR就是整数的意思啊

08:06.990 --> 08:12.830
INTAGAR就是整数的意思 有些语言里边呢 它有个关键字叫int 就表示INTAGAR的意思啊 表示整数

08:13.490 --> 08:18.570
介式里面呢 它没有进行区分 它都是number 啊 都是数字 无论整数还是小数都是数字

08:18.930 --> 08:22.610
只不过它提供了一个函数来判断 邦里判断它是不是一个整数

08:23.130 --> 08:29.730
有的时候呢 我们可能要对整数进行操作 不允许它传小数 那么我们就可以利用这个函数来进行处理 比方说啊 咱们这里

08:30.130 --> 08:36.770
number里边啊 一个INTAGAR 啊 INTAGAR 这里呢 3.14传进去 你看是force

08:37.630 --> 08:41.510
3传进去 就是true 那么3.0呢 传进去 仍然是true

08:42.270 --> 08:46.270
因为这个东西呢 它认为跟这个3是一样的啊 跟这个3是一样的 它认为

08:46.470 --> 08:51.070
因为介式里面 它没有区分小数和整数 它只要直式整数就行了

08:51.790 --> 08:57.230
明白了意思吧啊 这是INTAGAR 这个INTAGAR能不能直接用了 这个INTAGAR 它是不能直接用的啊

08:57.230 --> 09:02.350
温度里边INTAGAR 是不存在的啊 是不存在的 这个函数呢 它没有把它提出来

09:02.930 --> 09:08.170
好吧 这是关于这个 这个函数 咱们再看一下啊 静态函数里边 好 这两个

09:08.770 --> 09:14.770
哇 用的是实在是太多太多了啊 一个是posed int 一个是posed float

09:15.690 --> 09:18.650
什么意思呢 float 表示小数啊 浮电数 表示小数

09:19.210 --> 09:25.130
posed int 表示整数啊 那么这两个函数分别表示posed float

09:25.830 --> 09:35.550
表示的是将一个数据转换为 转换为什么的小数啊 转换为小数

09:36.110 --> 09:43.710
posed int是将一个数据转换为整数 转换为整数

09:44.550 --> 09:50.510
这上面是判断一个数据是否是整数 好 这里我要说一下啊

09:51.310 --> 09:54.470
就是这两个函数呢 这些都是静态的啊

09:55.910 --> 10:01.900
嗯 静态成员 这里我要说这个

10:03.060 --> 10:06.660
将一个一个数据

10:09.100 --> 10:16.060
这两个函数呢 它可以进行转换 如果你给的参数是数字的话 它就直接转换 这个很简单 咱们来看一下啊

10:16.460 --> 10:25.980
posed float啊 这个函数 这个函数它也在温度对象里边啊 它也把它提到了温度对象里边 当然你可以使用number点啊 是一样的啊 是一样的

10:26.360 --> 10:34.200
比方说啊 我们这里随便写一个啊 随便写个小数啊 你看 它就没变化 对吧 它就没变化 那如果你写的是个整数呢

10:34.800 --> 10:40.960
如果你写的整数呢 它也没变化 因为在介石里边 整数跟小数呢 它本质上是一样的啊 纯粹的方式都是一样的

10:41.200 --> 10:48.600
你看整数三它怎么转换的小数呢 转换的小数就3.0000对吧 3.0000跟3是一样的啊 跟3是一样的 比方说我们比较

10:48.880 --> 10:55.240
3.0000是不是等于3 你看是不是true 对吧 对他来说是一样的啊 是一样的 最后得到结果呢

10:55.540 --> 11:01.220
认为是3 好是posed float啊 另外一个呢posed int呢 我们用的比较多posed int

11:01.860 --> 11:12.020
表示把它转换成整数 3.14 你看转成整数就是3啊 比方说啊 原来同学可能会认为它是四蛇五蛾啊 他可能会认为是四蛇五蛾 比方说3.6

11:12.540 --> 11:19.660
他可能会认为是4 但是实际上不是的啊 还是3 那如果是负数呢 我们看负3.6 那就是负3

11:20.160 --> 11:26.640
实际上是怎么回事了 实际上呢 他是直接舍去小数啊 直接舍去

11:27.520 --> 11:32.680
小数部分啊 小数部分直接不要了啊 扔掉 是这么个意思啊 这么个意思

11:33.680 --> 11:40.640
能理解啊 能理解啊 这是关于这两个函数 但是这两个函数大家要注意的就是就是呢

11:41.080 --> 11:47.080
他可能里边的参数呢 不是一个数字 他里边的参数可能不是一个数字

11:47.500 --> 11:53.700
那如果不是数字的话 他又是怎么转换的啊 如果不是数字的话 他又是怎么转换的

11:54.580 --> 11:59.620
那么这里呢 我们来看一下啊 他这里说到这个问题 他说的话 如果这个pose映成了

12:00.060 --> 12:04.060
他这里的参数呢 实际上呢 他要求的是一个制服串

12:05.220 --> 12:07.060
他要求的是一个制服串 还不是数字

12:08.100 --> 12:16.260
那如果你传数字的话 他会先把它转换成制服串啊 他会把他先转换成制服串 然后呢

12:17.000 --> 12:26.800
再进行转换啊 把它转换成数字 所以他要求的是一个制服串 也就是说啥呢 如果你这里边pose映成啊pose float是一样的

12:27.480 --> 12:36.560
如果你这里边传的是别的类型 ok 他会把它先转换成制服串啊 然后呢 再进行啊 再进行就是

12:37.320 --> 12:43.800
转换成数字 那么他制服串的转换规则是什么样子的 比方说你传一个空的制服串 我们之前说

12:44.060 --> 12:49.820
一个空的制服串呢 他如果是自动完成转换 在运算的时候 对吧

12:51.020 --> 12:57.540
自动完成转换的时候呢 他是得到了是零 但是你看现在这里 他得到了是n a n

12:58.100 --> 13:02.980
对吧 他不太一样啊 跟我们之前的运算符类一块的转换规则呢 他不太一样

13:03.420 --> 13:07.900
那他具体是怎么转换的呢 我们来看一下他这里啊 这里他这里的说法

13:08.840 --> 13:17.440
嗯 上面看有没有具体的描述啊 没具体的描述啊 没有具体的描述的啊 他没有写具体的描述 ok 那我就直接说吧 我就直接说

13:17.960 --> 13:18.920
他这里是怎么转换的呢

13:20.040 --> 13:20.880
pose int

13:22.240 --> 13:24.200
和pose float

13:24.880 --> 13:30.960
他要求了参数 是一个制服串 如果不是制服串

13:31.620 --> 13:38.660
则会先转换为制服串啊 然后再进行转换啊 他是这样一个要求

13:39.580 --> 13:45.780
好了 那他具体是怎么转换的呢 他是从制服串啊 从制服串开始位置

13:46.700 --> 13:47.900
进行查找

13:49.140 --> 13:54.020
找到第一个有效的数字啊 进行转换

13:55.100 --> 13:57.380
第一个有效的数字进行转换 如果

13:58.360 --> 14:06.120
如果没有找到 则返回 n a n 返回 n a n 好 咱们来看一下啊

14:07.720 --> 14:09.720
比方说 咱们这里呢 number

14:10.400 --> 14:12.320
pose float

14:12.800 --> 14:14.480
pose float 这里给个字路串

14:15.280 --> 14:19.280
好 先写这么一些空格啊 先写这么一个空格 然后呢

14:19.960 --> 14:21.880
3.14 我们来看一下转换的结果是什么

14:22.860 --> 14:26.180
转换结果是3.14 他怎么转换的呢 他从开始查找

14:26.700 --> 14:31.220
前面的空白制服啊 这里还有空白制服啊 左右空白制服

14:32.380 --> 14:38.380
空白制服会忽略啊 他会忽略左右的空白制服 咱们再看一下啊pose

14:39.180 --> 14:41.900
flows 空格3.14

14:42.780 --> 14:49.980
你看 能转换对吧 前面的空白制服忽略掉 然后忽略掉过后就是一个制服串 相当于是就是一个制服串

14:50.040 --> 14:56.720
3.14的就相当于是他了 好 那怎么转换呢 他一次看呗 第一个数字 正常的 第二次正常的

14:56.880 --> 15:02.200
一是正常的 四是正常的 对吧 全是正常的 ok 那就转换的数字了 3.14 很简单

15:02.600 --> 15:05.240
然后咱们再来看一下 后面如果加一个abc呢

15:05.960 --> 15:09.200
哎 你会发现他仍然可以转换 为什么呢 你看

15:09.840 --> 15:16.800
他找到第一个有效数字进行转换 所以说他他不会管那些无效的东西 他就往前找啊 往后找

15:17.100 --> 15:25.300
三可以别问题 第二没问题 一没问题 四没问题 到了a不行了 对吧 就取前面这一部分进行转换 传来出来就去3.14

15:26.100 --> 15:31.300
明白这个意思吧 那比方说后边写空格了 当然也是一样的啊 写个abc呢也一样啊 不影响

15:32.220 --> 15:35.940
但是如果你这样子写 你前边写个abc

15:36.580 --> 15:42.820
一看就出问题了 为什么呢 他从做到要进行看呗 对吧 哎一看一开始就出问题了 看到没

15:43.240 --> 15:50.960
他一开始就出问题了 好一开始就出问题了 他就没法转换了 没法往后看了啊 于是呢 他就直接得到结果n a n

15:52.600 --> 15:55.040
明白这个意思吧 好 那比方说再来看啊

15:56.080 --> 16:02.240
那是这样子写了啊 3.1点这些东西 这样子写了 来看呗 他是这样子理解的啊

16:02.640 --> 16:08.840
看3 三没问题 点没问题 1没问题 哎 又是点 是不是已经出现过一个点了 这个点就是无效的了

16:09.140 --> 16:15.860
好 那么就把前标这一部分进行转换 他是用这种转换方式的 包括这个posed硬扯也是一样啊posed硬扯

16:16.460 --> 16:26.860
比方说3点一式 这样子也是一样的 找数字呗 找数字 找数字 三没问题 对吧 底也没问题 后边是小数都没问题 都没问题

16:27.140 --> 16:36.940
然后呢 这里的制服呢 就不是一个有效的数字的 对吧 他持续前标这一部分 然后扔掉小数点后标这一部分 那么只剩下三了 对吧 当然你也可以认为

16:37.520 --> 16:43.480
直接找到3 后面底就是无效的了 也可以这样子去想象 也可以没问题 那得到结果是一样的 就是3

16:45.000 --> 16:50.720
明白吧 就这么回事 这就是 注意啊 控制不错啊 控制不错注意 他得到的结果是NAN

16:51.520 --> 17:01.120
好吧 这是关于posed硬扯和posed float 这两个函数呢 他还可以传第二个参数 是可以传第二个参数的 看这个posed float

17:03.790 --> 17:10.830
这个posed float只能传一个参数啊 这个posed硬扯 他可以传两个参数的 这个posed硬扯 再说一下

17:11.870 --> 17:19.710
这个posed硬扯 可以传入第二个参数 这个参数什么意思呢 表示

17:21.390 --> 17:28.590
将 给定的制服创 识别为 识别为什么呢 多少进字

17:29.570 --> 17:30.890
识别为多少进字

17:31.690 --> 17:41.370
来进行转换 最终返回的都是一个使进字的数字 但是呢 他在识别的时候 他要把它当成多少进字 什么意思呢 给他看一下啊

17:43.090 --> 17:50.450
posed硬扯 比如说啊 我给他一个数字三点一次 给他一个整数嘛

17:51.430 --> 18:01.550
100100或者是101嘛 然后呢 如果你不写第二个参数 那结果就是101对吧 但是如果你写上第二个参数

18:02.070 --> 18:09.030
看着啊 如果你写上第二个参数 写上个二是什么意思呢 他指的是 把这个东西呢 当成一个二进字

18:09.670 --> 18:13.670
当成一个二进字 当然也可以是制服创啊 他本来就可以转换 本来就是转换制服创了

18:14.090 --> 18:21.530
他会把这个东西呢 当成一个二进字 好 当成二进字过后呢 你看101是多少

18:22.130 --> 18:29.370
101二进字 你板子头算呗 二进字的1就是1 二进字的2呢 就是10 二进字的3就是11 二进字的4呢 就是10

18:29.970 --> 18:38.290
这个东西是5 二进字的这个数字是5 当然如果你提供的不是一个有效的二进字啊 如果你提供的比方说啊 二进字里边

18:38.870 --> 18:39.550
二进字里边

18:41.110 --> 18:45.510
你写了一些其他的数字 对吧 其他的数字 那么转换出来就是NAN

18:46.110 --> 18:51.910
但是这里面呢 有一个现象啊 有一个现象 他一个细节很多在这里边转换了 如果你写的是103呢

18:53.550 --> 18:55.950
如果你写的是103呢 他是怎么理解的呢

18:56.750 --> 19:05.470
他是这样是理解的啊 你看他这样子看啊 第一个有效数字没问题 第二个是有效数字没问题 哎 这个不是一个有效数字的 对吧 有问题了

19:06.050 --> 19:11.690
只取前边两个部分 他只取前边这一部分 明白这个意思吧 他只取一和零

19:12.210 --> 19:16.410
因此呢 一和零就是二 他是这样子理解的啊 包括了你给一个数字

19:17.090 --> 19:23.290
给一个数字103 是不是一样的啊 他会先把他转换的字五串大进行转换 这里非常容易出面是挺我给说

19:24.090 --> 19:26.370
他考虑这些细节 很容易出面是挺

19:27.010 --> 19:33.410
一看好像看的是103 好像不是一个有效的二进字 二进字他只能有数字零和一 对吧 他不能有别的东西

19:33.990 --> 19:36.830
好像不是一个有效的二进字 但是他是从左到右看的

19:37.470 --> 19:41.390
看到一个无效数字终止 那为什么这个东西转换不了了 因为第一个数字就无效了

19:41.830 --> 19:47.630
明白这个意思吧 他第一个数字就无效了 转换不了 那如果你这样子写了前面写个一呢 他又可以转换了

19:48.270 --> 19:50.630
他就是他就是只看这一部分 就是一

19:51.670 --> 20:01.150
他是这么回事啊 这个耳朵是静字啊 这是静字啊 比方说他还可以用别的静字啊 是一样的 别的静字 比方说用的也用这个

20:01.770 --> 20:12.970
A F 或者是A嘛 就一个数字A 看十六性质啊 十六音质 十六性质里边的A就是十

20:14.490 --> 20:19.730
没问题吧 ok啊 这是关于这个转换 那如果是小数呢 看一下小数啊

20:20.810 --> 20:25.930
Pose音质 3.14 3.14 看一下把它转换成

20:26.110 --> 20:27.110
嗯

20:28.430 --> 20:28.830
这样子吧

20:30.630 --> 20:35.030
1.101啊 转换成二镜子 看一下他还是1 怎么理解

20:35.670 --> 20:40.470
人人说小数怎么转呢 小数怎么转 你看一下这是啥 这是Pose音质

20:41.190 --> 20:49.950
他是转换的结果是整数 因此呢 你这个1.101实际上是一个制幅圈 1.101对吧 他是不是把这个

20:50.570 --> 20:59.370
底耳后面的就省去掉了 就不看了 你可以就这样理解 他从头到尾看 看到第一个是有效数字 哎 底耳就是无效数字的 对吧 无效的

20:59.610 --> 21:02.970
因为他是整数嘛 他只转化整数 他后面就不看了 他只看这个1

21:03.570 --> 21:09.330
你看这个意思吧 所以说小数呢 你可以写但是你写的好小数点后面的东西呢 写的等于白写啊 没用

21:10.450 --> 21:12.290
好 这是Pose音质啊 Pose音质

21:13.370 --> 21:15.930
ok 这是关于这两个函数啊

21:16.910 --> 21:27.830
啊 这两个函数啊 这里面呢 我们就说一个说一个例子了啊 说一个例子啊 这个例子呢 我们之后会经常使用啊 经常使用

21:28.190 --> 21:29.710
就是得到一个随机数

21:30.910 --> 21:33.510
随机数 我们之前说过这个随机数啊

21:34.350 --> 21:41.390
我们之前呢 说过有这么一个函数 这个函数呢 我们后边啊 后边的可能还会还会介绍 就是Mass Ritem

21:42.250 --> 21:45.450
这个函数其实已经讲完了 就是产生一个0到1之间的随机数

21:46.490 --> 21:49.530
好 接下来呢 我要求你呢 写这么一个函数

21:50.210 --> 21:56.490
这个函数要每个同学都要会写 因为很重要 我们后边做各种各样的效果 都会用到这样的函数

21:57.090 --> 21:59.210
给他取个名字啊 叫做Guess Ritem

22:01.010 --> 22:05.210
或者叫做Ritem Number 都行 Ritem Number

22:06.190 --> 22:12.710
产生一个随机 随机的数字 传入两个函数 一个是最小值 一个是最大值

22:13.350 --> 22:14.350
我打上个注释

22:16.230 --> 22:19.990
这个函数做什么用呢 我不写到这了 我写到这儿

22:21.630 --> 22:23.110
边上方形 这里

22:27.230 --> 22:29.270
好 这里呢 我再写个函数啊 再写个函数

22:30.750 --> 22:33.190
取个名字叫Guess Ritem

22:34.790 --> 22:36.470
这个函数非常非常的实用

22:37.870 --> 22:44.120
max 什么意思 就表示的是得到一个

22:45.680 --> 22:50.960
最小值到最大值之间的随机整数

22:51.720 --> 22:57.040
我要得到一个最小值到最大值之间的随机整数 这是最小值

22:57.880 --> 23:01.000
这是最大值 大家注意一下 最大值是取不到的 取不到

23:01.840 --> 23:03.120
取不到最大值

23:04.480 --> 23:06.960
好 那么这个函数怎么写 这个函数咋写

23:07.380 --> 23:11.780
怎么写呢 我们现在可以清楚的知道

23:12.700 --> 23:13.900
就是这个max

23:15.220 --> 23:22.540
delighted这个函数 它的取值范围是多少呢 因为我每次讲公开课的时候 很多同学在问这个东西啊 所以说

23:23.660 --> 23:24.860
我们在课程里面就把讲了

23:25.860 --> 23:32.740
好 他取值范围是0到1 对吧 取不到1啊 他取不到1 他只能取到0到1之间啊 无限接近于1

23:33.100 --> 23:34.940
但是他取不到 他肯定是小数嘛

23:35.920 --> 23:40.320
好 那么我们来想一想 这个玩意如果乘1个2

23:41.200 --> 23:45.160
如果把这个东西 这个表达是乘1个2 他产生的范围是多少

23:46.640 --> 23:55.480
想一想 那这个表达是他的最最小值就是0嘛 对吧 那如果他取到0的时候 那么整个是最小 最小是不是0 对吧 到多少了

23:56.280 --> 23:56.680
是不是到

23:57.660 --> 24:00.300
2之间 对吧 0到2

24:01.140 --> 24:05.220
没问题吧 如果乘12的话就0到2 那如果是乘1

24:07.660 --> 24:11.220
11呢 是不是你就0到11 没问题吧

24:12.340 --> 24:16.780
他的取值范围就是0到11 这个应该知道吧 取不到11啊 他取不到11

24:17.260 --> 24:24.180
他因为他取不到1嘛 他假设他取到1的时候 他就能取到11啊 这也是无限接近于11

24:24.760 --> 24:26.360
好 咱们再来看 如果

24:28.160 --> 24:35.480
如果这个 后面再加上一个1呢 那这个表达是的取值范围呢 你看一下 那如果这个是0

24:36.240 --> 24:40.240
他取 最小的值是多少 如果这个是0最小的值是1

24:41.040 --> 24:51.080
如果这个东西为1 假设他取到1了 那么整个表达是呢 是12 所以说这个表达是的取值范围是1到12 看到没

24:52.060 --> 24:54.740
哎 这是不是最小值啊 这最大值

24:55.460 --> 25:01.180
好 如果高数里最小值最大值 我们怎么来反向的 把这一块推到出来了

25:01.820 --> 25:08.460
好 咱们再来一个例子吧 再来一个例子 比方说加3这里是7 这里是7

25:09.100 --> 25:15.180
好 再来看一下这个例子 他的取值范围啊 他的取值范围是不是3到多少10

25:15.840 --> 25:23.480
看了规律没有啊 你们以后面试的时候 在做比试题的时候可能会遇到类似的这种题啊 他告诉你一些

25:23.880 --> 25:28.880
情况 然后让你推到出他的规律 看到规律没有 如果现在高数里这个东西

25:29.600 --> 25:31.680
现在我们反过来推啊 反过来推

25:32.640 --> 25:36.200
就是说如果高数里命 我的取值范围是命到max

25:37.320 --> 25:40.600
啊 就这个东西是命 这个东西是max 那么前边的该咋写

25:41.580 --> 25:47.380
前面的该咋写了 前边的他写法就变成就这样子 这里这个地方是不是写命

25:48.580 --> 25:53.220
这个地方写啥 max 减命

25:54.740 --> 25:59.900
减这个命 没问题吧 这就是他的表达式 这个表达式他就返回来结果就是

26:00.820 --> 26:06.700
最小值到最大值之间的水几数 所以说这个函数写法非常简单 返回啥 返回就

26:07.040 --> 26:09.240
就返回这个玩意

26:10.600 --> 26:16.200
就返回这个玩意 但是你要注意 这个玩意他得到了是啥 得到了是小数

26:16.520 --> 26:23.040
他有可能是小数 因为这个max点 它是零到一之间的小数 所以这个乘出来的可能仍然是小数

26:23.600 --> 26:29.880
因此我需要把小数点后面的给他抹掉 把小数点后面的东西给他抹掉 去掉

26:30.620 --> 26:38.740
于是我前面加这个啥 把小数点后面的给他去掉就完事了

26:40.500 --> 26:47.540
没问题吧 把小数点去掉就完事了 这就是这个函数的写法 这个函数的写法

26:49.300 --> 26:56.900
好 然后我们来试验一下 试验一下这个函数 我们在这里呢 这里就直接引用这个解释了

26:57.440 --> 27:01.840
引用这个解释 就是返回上级

27:03.880 --> 27:06.800
返回上级目录 再返回comment

27:08.040 --> 27:10.200
better方形 好来测试一下

27:11.640 --> 27:12.640
console log

27:14.200 --> 27:20.160
那个叫啥 我是单对下模式当时用的 买方形式 买方形式

27:21.020 --> 27:29.060
get writer get writer 最小值 比方说最小值是5 最大值是8 最大值是8 看一下啊

27:33.520 --> 27:35.800
得到7 你看6 5

27:37.600 --> 27:44.600
刷新6 你看就随机 5到8之间的随机数 但是取不到吧 取不到吧 那如果你希望取到8怎么办

27:45.240 --> 27:51.560
如果你希望取到8 那还不简单吗 如果你要取到最大值的话 那么就这里先把这个max加加 对吧

27:51.860 --> 27:54.500
先把加1 对不对 加1过后再进行运算

27:55.460 --> 28:02.500
就这么简单啊 或者是在这里加1 在这里加1也可以 加1解密 对吧 这个很简单啊 比方说我们

28:03.140 --> 28:06.580
如果你觉得习惯上我希望他取到最大值 ok 那我这里

28:07.620 --> 28:11.820
就把他这样子写 那么他现在就能取到8了啊 就能取到8了啊 我这里

28:12.380 --> 28:14.180
哪能去测试的啊 肯定是能取到的

28:15.780 --> 28:18.140
嗯 不过大家注意一下就是这个函数啊

28:18.920 --> 28:22.200
这个函数呢 他会有一个bug啊 会有一个小问题

28:23.000 --> 28:27.760
什么小问题呢 就是如果是复数的时候呢 他可能会出问题

28:29.000 --> 28:36.120
其实复数的时候这个公式是没问题的啊 公式是正确的 没问题 比方说咱们取到 取一个复5到复3的随机数

28:37.400 --> 28:44.000
复5到复3之间的随机数 这个公式是没问题的啊 这个公式我来看一下呗 把复子过来

28:44.460 --> 28:50.860
你会发现公式是完全没问题的啊 最小值是复5 对吧 那这里就是减5呗 对不对

28:51.460 --> 28:59.740
最大值是复3 复3减复5就这里就是2 对吧 就是2 你看一下 那公式是没问题的 如果他取到0 是不是最小值

29:01.660 --> 29:05.340
复5对不对 他取到0的话就最小值复5 如果他取到1

29:06.140 --> 29:10.780
就是最大值多少 最大值复3 但他取不到最大值啊 取不到最大值

29:11.280 --> 29:19.160
但是这个公式虽然没问题 但是我一旦去掉 直接去掉小数点就可能会产生问题 为什么会产生问题呢 来看一下啊

29:20.280 --> 29:29.000
如果我直接去掉小数点就可能会产生问题 那比方说这个复5到复3之间的随机数啊 随机数 那他可能会取到哪些值呢

29:29.800 --> 29:35.840
比方说他是不是有可能会取到这个值 复3点几啊 比方说复3点几 没问题吧

29:36.500 --> 29:45.780
复3点几是不是复5到复3之间的数字 对吧 复5到复3之间的数字 没问题吧 他可能会取到这个值

29:46.500 --> 29:51.740
那么这个值呢 如果我一旦去掉小数点 后边是不是变成复3了

29:52.580 --> 29:56.500
他是不是变成复3了 但是这个公式我之前说了 这个公式呢

29:57.100 --> 29:59.100
他是不能取到最大值的

30:00.080 --> 30:08.360
这个公式我们一直都在说 这个0到11取不到 0到11取不到 1到12取不到 他是不能取到最大值的

30:09.320 --> 30:12.360
那是不是跟帧数那边就不一样了 对吧 就不一样了

30:12.760 --> 30:18.200
有些同学说 同学说 那我就是想取到最大值的 就是想取到最大值 那你想 那你这个地方

30:18.600 --> 30:21.720
能取到最大值的 但是帧数又取不到 是不是就不太一样了

30:22.280 --> 30:26.440
你要取到最大值的话 你最好在这里加个1 在这个加个1 这才是正确的做法

30:26.900 --> 30:30.900
明白这个意思吧 这才是正确的做法 保持帧数和复数是统一的

30:31.300 --> 30:39.060
要么都能取到最大值 要么都不能取到 你不能一会是帧数能 帧数取不到 复数可以取到 那就很乖了 对吧 很乖

30:39.580 --> 30:46.740
所以说这一块呢 复3本来是取不到的 但是他可以取到 原因就是他是直接去掉小数

30:47.500 --> 30:54.460
因此呢 这里的正确做法啊 还不是直接去掉小数 应该是向下取整

30:54.760 --> 30:59.640
他正确的做法应该是 向下取整

31:00.400 --> 31:03.640
取整 那怎么向下取整呢 是什么意思呢

31:04.400 --> 31:08.040
就是找到比这个小的数的

31:09.040 --> 31:11.560
第一个整数 哪个整数比他小

31:12.600 --> 31:15.400
复3比他小吗 复3不比他小 复3比他大

31:16.200 --> 31:20.320
应该是复4比他小 对吧 所以说这个向下取整应该得到复4

31:20.860 --> 31:22.460
就找到比他小的

31:23.580 --> 31:30.300
第一个整数 对于帧数而言 去掉小数点和向下取整是一样的 比方说3点几

31:31.140 --> 31:37.460
和3 你去掉小数和进行向下取整是不是都是一样的 但是对于复数而言就不一样了

31:37.900 --> 31:39.260
对于复数而言就不一样了

31:40.140 --> 31:42.460
不要这个意思吧 复数向下取整的话 这里是复4

31:43.340 --> 31:47.140
这里正确做法呢 应该是向下取整 这才是正确做法

31:47.800 --> 31:52.360
那么这里怎么向下取整呢 要么去加判断 要么呢 你听一下我们后边

31:54.000 --> 31:57.160
我要不然这这里和就一起讲了吧 我以后在这里和就一起讲了

31:58.040 --> 32:02.920
关于另外一个 算了算了 还是单独开一些课来讲 我们后边会讲哪一页 讲一个

32:03.480 --> 32:08.280
对象啊 就是Mass对象 就这个对象 这个对象里边给你提供了一个函数来进行向下取整

32:08.520 --> 32:12.160
那么我们这里先说了吧 我们后边再说 后边再具体的讲

32:12.420 --> 32:15.180
FloorFloor什么意思 就地板的意思

32:16.060 --> 32:23.460
通过这个函数来进行向下取整 给它传一个数字 它向帮你向下取整 那么现在的复数就没问题了

32:24.380 --> 32:30.460
这才是这个函数最正确的写法 这里呢 我们说到这了 就顺便把它说一下 我们后边会专门来讲这个对象

32:32.060 --> 32:36.140
好 这是关于这个PoseInt和PoseFloat 这是两个都是静态成员

32:37.000 --> 32:39.400
记得看看 Number里边还有啥呢

32:40.640 --> 32:44.920
看一下 Number实力 实力 实力这一块啊

32:46.440 --> 32:52.320
他这里就没翻译了 我们就直接给大家说一下 实力 第一个函数是不是说过的 to fix

32:52.640 --> 32:58.120
他说 返回一个字部串 返回一个字部串 什么字部串呢 他是用来展现

32:58.840 --> 33:05.720
这个Number什么呢 固定微 就是固定小数点位数的一个字部串数字 一个字部串

33:06.880 --> 33:12.040
我这里翻译的比较乱 再重新翻译一次 就是得到一个字部串

33:12.640 --> 33:17.040
然后呢 他把这个数字呢 用一个固定小数位数的

33:18.120 --> 33:21.440
数字字部串展示出来 咱们还是举例子吧

33:22.680 --> 33:25.160
其实我都说过的 对吧 这是实力成员

33:26.280 --> 33:32.960
实力 实力成员 其中一个叫to fix to fix

33:33.860 --> 33:36.340
这里传入一个数字 这是个方法

33:38.220 --> 33:41.900
好 咱们举例子 比方说这里Number

33:43.820 --> 33:50.700
就不能这样这样用了啊 就不能Number to fix了啊 没有这个了 它是它是实力方法 所以说呢 我们比方说定一个面量

33:52.220 --> 33:55.140
A里面存一个数字 存一个数字

33:56.300 --> 34:02.900
好 然后呢A点你看 fix 本来还是原式内形 但是呢 你把它当成对象使用

34:02.980 --> 34:06.740
是可以的 因为它有包装器 把它变成了对象

34:07.220 --> 34:11.100
好 这里呢 我们写一个2 表示什么意思呢 保留两位小数

34:11.700 --> 34:16.060
保留两位小数 你看 用一个制服串的形式 用一个固定位数的

34:16.780 --> 34:20.460
小数来表示这个数字 好 那如果你是一个整数呢

34:21.500 --> 34:25.740
你是一个整数呢 好来看一下啊 to fix 把它写成2 你看

34:27.020 --> 34:32.460
这个对我们有的时候呢 显示一些价格呀 显示一些标准格式的数字 非常有帮助

34:33.540 --> 34:42.660
没问题吧 那如果你比方说啊 3.151415926 好 咱们来看

34:44.020 --> 34:48.860
我给F值啊 这里说明说一下 你如果是个字面量的话 你是不能调用的啊

34:49.420 --> 34:54.460
如果你是字面量的话 是不能这样调用的 你必须要是一个变量啊 至少是个变量才行

34:54.660 --> 34:58.540
你字面量是不能这样的写的 字面量就是一个彻彻底地的原式内容

34:59.400 --> 35:02.680
咱们再看啊 给F值为3.1415926

35:03.680 --> 35:06.480
重新来 15926

35:07.520 --> 35:14.520
然后呢 对A使用to fix 主要是看它会不会是四舌五入 我们保留小数点后面四位

35:15.920 --> 35:20.360
你看会不会是四舌五入 对吧 会四舌五入 对不对 比方说我们取三

35:21.160 --> 35:28.940
你看四舌五入 这种做法呢 它会导致四舌五入 会有四舌

35:30.500 --> 35:36.860
四舌五入 对这个函数呢 它会有四舌五入啊 大家注意一下

35:37.860 --> 35:39.060
好 再看一下下一个啊

35:40.940 --> 35:41.220
这个

35:42.180 --> 35:50.860
这个呢 它表示的是也是返回一个制服串啊 这个函数它也是返回一个制服串啊 它是表示呢 以指定的精度

35:51.780 --> 35:52.580
来得到一个

35:54.140 --> 35:54.780
数字制服串

35:55.740 --> 35:59.180
这里记彼啊 主要是看例子 这个不看例子的话很难理解

36:00.420 --> 36:06.540
以指定的精度 就是多少个有效数字 有多少个数字 指定的精度

36:08.620 --> 36:13.340
返回一个数字制服串 主要是看例子啊

36:14.380 --> 36:21.420
好 比方说啊 还在这里 有一个数字A 随便去吧 1234.1234

36:22.380 --> 36:26.100
它有几个数字啊 它是有八个数字 好 我们就认为这个

36:26.720 --> 36:33.720
变量A 它的数字的精度是八 我们就可以这样认为 它是八的精度 有八个有效数字

36:35.120 --> 36:37.040
好 那么现在呢 我们调用它的这个to

36:38.320 --> 36:45.200
precision 啊precision 这就是精度的意思啊 它就是精度的意思 好 那么这里面我们比方说 传入一个五

36:45.600 --> 36:46.000
看一下

36:48.220 --> 36:53.300
那么应该这个意思吧 它就表示我最终得到的这个数字呢 只有五个有效数字

36:54.160 --> 37:00.160
只有五个有效数字啊 那比方说我传入的是10啊 那看 它会多加两个0在后边

37:00.880 --> 37:03.000
你看这意思吧 那比方说

37:04.040 --> 37:10.040
我这里传入的是2呢 哎 你看 它会用这种方式 这种方式表示叫做科学技术法

37:10.800 --> 37:17.120
啊 就是1.2×10的三次方啊 1.2×10的三次方 这个1呢 你可以把它理解为10

37:17.580 --> 37:23.340
这个加三就表示正三啊 是正三的意思 实的正三次方 是这么个意思

37:23.860 --> 37:29.900
1.2×10的正三次方 那你看现在有效数字说是只有1和2了 精度变成两个了

37:30.300 --> 37:32.580
你看这个意思吧 它可以用这种方式啊

37:33.540 --> 37:41.380
用这种方式 这是关于设置精度 有些人在一些跟数学相关的一些系统里边我们可能会用的

37:42.140 --> 37:43.340
好吧 这是关于这个函数

37:44.660 --> 37:46.860
其他都没啥了 其他就真没啥了

37:48.100 --> 37:49.500
真没啥了 真没啥了

37:50.660 --> 37:54.420
好吧 ok 这是关于这个数字这一块

37:55.460 --> 38:02.940
number 好 现在我们看另外一个啊 不另不另好 这个不另很简单东西不多很少不另

38:04.620 --> 38:14.780
好 看一下吧 他也是个包装器对象啊 你给他一个纸啊 给他一个纸呢 他可以帮你创建一个对象 同样的道理啊 同样的道理

38:15.000 --> 38:25.640
我们之前说过啊 这个布尔了 他有个判定对吧 他可以进行任何类型都可以把它转换成布尔进行来判定 那么这里转换的规则是一样的啊 规则是一样的 比方说

38:26.520 --> 38:32.160
比方说我们通过 直接通过这个函数来转换 他得到的是原始类型啊 得到是原始类型

38:32.640 --> 38:36.120
比方说你给一个now force 给一个undefend

38:37.320 --> 38:41.720
undefend force 对吧 还有什么空之无窗啊 对不对 force

38:42.700 --> 38:47.940
这些都是force 那么其他都为true 好 那么这里一个问题就是 如果你写一个字不串force呢

38:48.740 --> 38:54.380
他得到的是true 得到的是true 就跟我们之前说的一样 就是说除了那几种

38:54.940 --> 39:02.100
回忆一下吧 我们当时讲运算符的时候 讲了的逻辑运算符的时候 经过这个笔记对吧 除了这些东西之外

39:02.300 --> 39:08.700
判断为force 其他都判定为真 其他都判定为真 那么在转换的时候也是一样的

39:09.280 --> 39:11.440
他也会转换成对应的真

39:12.520 --> 39:20.520
好吧 那是这个布尔 构造函数 那它里面有没有那些属性和方法可以用了 没啥属性方法可以用

39:21.040 --> 39:26.920
基本上没啥属性方法可以用 大家只需要知道它的toosting 就是一布尔内详的数据

39:27.320 --> 39:32.960
你把它转成字无窗了 它就转换成true和force就完事了 其他都没啥 它里面没什么方法可以用

39:33.420 --> 39:37.260
这是关于这个布定 了解一下就行了 了解一下就行了

39:38.260 --> 39:45.940
好 下边这个才是我们这里和的终点 这里和中间有两个 一个是Number里边这个PoseInt和PoseFloat 以后经常用的

39:46.300 --> 39:52.060
还有一个就是字无窜 好 字无窜这个包装器呢 它里边提供了很多很多的成员

39:53.460 --> 39:54.940
跟我们使用 来看一下

39:59.980 --> 40:00.300
失去

40:02.260 --> 40:03.260
好 看一下啊 这里面

40:04.200 --> 40:12.760
首先它这里说到 出到了什么转译制服 对吧 说到这个转译制服 转译制服呢 我们都讲过的 都讲过的 我们这里往下看

40:14.760 --> 40:15.160
好 这里

40:19.000 --> 40:24.960
这里长字无窜说一下啊 关于长字无窜换行的话 换行的话 我建议大家直接使用

40:25.640 --> 40:26.360
模板字无窜

40:27.000 --> 40:29.840
好 如果你不使用模板字无窜 也想要

40:30.220 --> 40:30.540
就是

40:31.460 --> 40:39.260
就是你想用一行字无窜 你不想字无窜真正的换行 只是在写代码的时候 写得太长了 你想换行 那么这个时候呢

40:39.660 --> 40:41.060
这个时候呢 你可以用这种方式

40:41.660 --> 40:49.180
用加号拼接对吧 加号是拼接字无窜的 因为运算服务位置呢 是可以换行的啊 运算服务位置是可以换行的

40:49.900 --> 40:53.340
有问题吧 好 也可以怎么样呢 也可以

40:53.700 --> 40:57.580
你这样子写 用双一号的字无窜这样子写 写到后边呢 给一个反斜杠

40:58.440 --> 41:04.720
给一个反斜杠 反斜杠后边也可以换行 也可以换行 比方说 比方说举个例子

41:06.200 --> 41:12.280
我们来对比一下有什么区别啊 比方说我们这里有个字无窜1

41:14.720 --> 41:15.280
字无窜1

41:16.160 --> 41:20.400
我们这里写abc一个反斜杠 一个反斜杠 换行

41:22.320 --> 41:26.560
就是bcd bcd 好 这是两 第一个字无窜 第二个字无窜

41:27.540 --> 41:32.400
用模板字无窜 abc 直接换行 bcd 输出

41:33.540 --> 41:35.380
stre 再输出

41:36.100 --> 41:43.240
str2 看一下两个有什么区别 好 你会发现

41:44.320 --> 41:52.680
第一个字无窜啊 第一个字无窜是不是并没有换行 对吧 并没有换行 那么他这里呢 为什么会出现空白呢 是因为他这里有空白

41:53.120 --> 41:55.120
如果你把这里空白去了 你看一下

41:56.120 --> 42:02.160
abcabcd 是不是连着的 对吧 这两个 这个都字无窜 跟这个字无窜是连着的 是连着的

42:02.720 --> 42:11.560
而这里呢 你写了换行 他就真正的换行了 这里你写了换行 他就真正换行了 保证看一下 这是第二种 这就是他们的区别

42:13.600 --> 42:19.400
你根据你的情况啊 到时候以后在应用的时候 根据你的情况 如果你真的需要他换行的话 你就

42:19.800 --> 42:24.760
用这种方式 如果你不希望他换行 只是在代码书写上 我写不下了 我想换行写

42:25.320 --> 42:31.920
那么你可以用这种方式啊 这种方式 那么在模板字无窜里面能不能用写钢呢 能不能用写钢也用这种方式呢 你保存一下

42:32.280 --> 42:38.240
你看 是不是也可以啊 也可以 所以说呢 模板字无窜呢 目前啊 这是也是六星出来的语法啊

42:38.680 --> 42:45.520
目前这个模板字无窜的功能很强大啊 如果你比较习惯于用模板字无窜的话 我建议大家都尽量使用这个

42:46.840 --> 42:51.600
好吧 这是关于啊 这个字无窜的书写啊 顺便提一下 之前也没有想到

42:52.480 --> 42:55.040
好 这里呢 我们主要说下面啊 主要说下面

42:55.360 --> 42:59.840
它的有哪些给你提供了哪些属相啊 好 第一个

43:00.720 --> 43:07.840
这是静态方法啊 静态方法 属下没有啥 主要是静态方法 静态方法呢 这里呢 有这么一个方法 大家需要知道

43:08.320 --> 43:19.360
from char code code啊 from char code 下面是一个实验的方法啊 我们现在暂时不去用 它真真变成标准之后再用 我们一会说一下这个方法吧

43:19.800 --> 43:26.090
好 第一个from char code 好 这是静态成员

43:28.500 --> 43:31.460
from char code

43:32.260 --> 43:36.380
from char code 表示什么意思呢 它是根据一串unicode

43:36.940 --> 43:43.460
编码 我们知道字无窜还有编码对吧 一个字符对应一个数字 它是根据它其中一种编码方式叫做unicode编码

43:43.700 --> 43:48.340
我们之前讲过的对吧 叫做弯国吗 它包含这个全世界所有的字符

43:49.340 --> 43:51.860
它通过这个编码来创建一个字符串

43:52.820 --> 43:57.700
有的时候 这个东西很关用 from char code 好 比方说

43:59.380 --> 44:07.860
通过unicode编码创建字符串 好 比方说举个例子 我们这里呢

44:09.460 --> 44:15.460
有一个编码啊 我们可以用这个字符串的静态方法 from char code

44:16.420 --> 44:25.180
一个编码 编码的值呢 是60 65 看一下

44:26.020 --> 44:31.180
是不是得到一个字符A 对吧 A的编码就是65 那如果我这里65

44:31.700 --> 44:36.500
66 写两个参数呢 你看 是不是得到A B 对吧 就这么简单就这么简单

44:37.540 --> 44:42.500
好 于是呢 我们就可以搞搞出一个什么事呢 我们就可以这样走着了

44:43.380 --> 44:50.020
啊 我们要输出 我们要得到一个字符串A到Z之间的字符串 我们不用自己

44:50.660 --> 44:59.620
自己手写手写abcdefg啊 这样子手写 我们可以用循环搞定了 哎 我们可以用循环了 好 怎么来写呢 看着啊

45:01.300 --> 45:04.620
我可以这样子写 呃

45:04.780 --> 45:10.620
呃 一个循环 I等于65 I加加

45:11.100 --> 45:23.620
I小于等于65 26个英文字母嘛 对吧 26个英文字母加上26小于26 包含包含65 大家刚好26个 I加加

45:24.340 --> 45:27.620
好 然后呢怎么样了 我每一次

45:28.500 --> 45:33.540
循环我就输出啥了 输出stream from charcode啊 charcode

45:34.020 --> 45:39.860
然后这里把I传进去 你看 把I当成编码 把这个编码呢 转换成字符串

45:40.620 --> 45:43.180
那么每一次就输出了一个字母 看一下

45:44.460 --> 45:51.140
你看 是不是这样子就可以把26个英文字母全部输出来了 没问题吧 好 我当然呢还可以把它拼接成一个字符串

45:52.060 --> 45:52.940
拼接成一个字符串

45:54.540 --> 46:01.220
好 每一次运行的 我往这个字符串连 拼接一下 拼接一下 拼接什么呢 拼接stream from charcode

46:02.180 --> 46:08.260
来 好 那这个字符串拼完了之后 再输出这个字符串啊 str 看一下

46:09.220 --> 46:17.420
就是输出了A到Z的所有制服 没问题吧 哎 我们就可以这样子玩了啊 就可以这样子玩 你通过编码的方式来进行处理

46:18.140 --> 46:19.540
好 这是关于这个charcode

46:20.260 --> 46:28.620
好 另外一个from code point 那这个东西是什么意思呢 它是通过一串码点来创建字符串

46:29.380 --> 46:35.740
其实这个玩意儿呢 跟上面这个玩意儿是一样的 用法都是完全一样的 就一个区别 就是它呢

46:36.500 --> 46:43.020
会进行有效性检查 因为码点什么意思 码点表示有效的编码 有效的数字

46:43.340 --> 46:48.980
因为编码的这个数字 它有编码 它是数字嘛 对吧 它数字呢 它是有个范围的 它不可能是无线的

46:49.380 --> 46:55.300
这个码点呢 它表示有先的 就是有效的一些数字 就有些数字它没有对应对应制服

46:55.900 --> 47:02.220
都没法转换 上面这个函数呢 它没有进行有效性检查 而下面这个函数呢 进行有效性检查 就这个区别

47:02.740 --> 47:07.100
没啥其他其他都一样啊 其他都一样啊 比方说啊 咱们来看一下这个例子

47:09.100 --> 47:11.660
from charcode 我给他写这么个东西 隐肥的体

47:12.140 --> 47:20.940
隐肥的体 它转换出来了 是一个空白制服 空白制服 你看这个东西是一个非常非常大的数字啊 它肯定不是一个有效的编码

47:21.340 --> 47:25.020
不是一个有效的编码 那么它为什么可以转换呢 它就是进行结断

47:26.220 --> 47:29.500
把把这个数字呢 它只取什么呢 你看一下这里

47:31.260 --> 47:37.380
它这里说到这个东西 它取得值 它取得的范围呢 它只介于零到这么多 这个数字之间

47:38.180 --> 47:45.700
只介于零到这个数字之间 超过了这个数字 或者是小微的零 或者是你写了什么乱七八糟的小数 那么它会

47:46.500 --> 47:52.980
自动的给你解决断 什么要解断 你要理解决断的话 你就必须要看这个东西 你就必须要看这个

47:54.340 --> 47:59.620
就是数字的存储 你不看的话 你很难理解决断 你要知道数字是怎么存储的

48:00.020 --> 48:05.860
存储的 你知道数字怎么存储过后呢 它只取这一部分 那么剩下的存储的东西不要了 直接抛弃掉了

48:06.260 --> 48:10.340
直接抛弃掉了 当然你不看这个东西也没关系 你只需要知道

48:10.980 --> 48:15.860
如果超错这个范围 它仍然能转换 那它转换的值呢 你也不太清楚什么值

48:16.500 --> 48:21.380
它会按照这个数字的存储 这个其实是一个数字 它在内存里边 它是有一种存储方案的

48:21.780 --> 48:29.700
它会进行截断 把不要不需要的东西 超过这个范围的东西给你去掉 去掉过后 它得到的就是什么 得到的就是一个控制不错的

48:30.660 --> 48:35.860
明白这个意思吧 但是另外一个 如果你使用另外一个转换方式呢 就是from charpoint

48:37.700 --> 48:41.380
你使用这种方式呢 它爆错 因为它不是一个有效的麻点

48:42.100 --> 48:46.020
这个就不是一个有效的麻点 没有这个意思吧 这就这两个函数就这个区别

48:46.660 --> 48:52.580
下面这个函数呢 还在实验阶段 所以说还不是成为 还没有成为正式的标准

48:53.140 --> 48:55.380
所以说呢 谨慎使用 谨慎使用

48:56.180 --> 49:00.580
好 这是关于这个字不错的静态方法 好 下面

49:02.100 --> 49:09.860
看实力的啊 看实力方法 好 实力方法里边 第一个有属性nense 实力成员里边有很多重要的东西了

49:12.350 --> 49:15.150
实力成员 一个是nense

49:16.190 --> 49:22.270
这个表示的是字符错长度 得到的是字符错长度

49:23.710 --> 49:26.110
好 那么我们来看一下 随便写个字不错

49:27.470 --> 49:31.810
随便写个啊 包含中文

49:35.280 --> 49:42.000
看一下 a.nense 你看得到是 对吧 字不错的长度 这个东西是不是有点像数组啊

49:42.960 --> 49:49.200
是不是有点像数组 哎 我们字符错呢其实就是一个伪数组

49:50.880 --> 49:57.840
字符错是一个伪数组 为什么这样子说呢 因为它有一个长度属性

49:58.240 --> 50:06.640
并且呢 它的包装器里边啊 包 因为它是肯定是使用了包装器嘛 对吧 包装器里边 比方说啊

50:09.360 --> 50:12.160
包装器里边 你看一下 它产生了对象

50:13.280 --> 50:18.560
是不是有索引 对吧 索引0的位置是制服 a 索引1的位置是制服这个制服

50:18.960 --> 50:25.120
2 3 你看对应的一个制服有长度 是不是一个伪数组啊 制服错实际上就是一个伪数组

50:25.600 --> 50:35.700
因此呢 制服错能不能这样子玩呢 大家看一下 我能不能去循环一个制服错 输出它每一个制服呢 可不可以呢

50:38.660 --> 50:49.540
可不可以 当然可以啊 因为它有下标对吧 所以说就就可以循环了啊 只要有下标就好循环了 哎小鱼什么str.nse 哎加加

50:50.500 --> 50:59.060
啊 然后呢输出啥了stri 看没有 我可以这样子写 因为它的有下标 有下标就可以这样子玩啊 保存看一下

51:00.020 --> 51:07.380
是不是可以 没问题吧 哎 这样子可以这样子玩的啊 这是这个nse这个属性啊

51:08.420 --> 51:15.220
好 下边这个 好 接下来了一个是charite啊charite 这里面很多啊 东西很多 我们一个个说

51:15.700 --> 51:21.220
charite 返回指定位置的制服啊 返回指定位置的制服

51:22.580 --> 51:29.790
记住一下 charite 得到指定位置的制服

51:31.390 --> 51:37.630
啊 今天我们完了之后呢 会有个制服串的作业啊 看一下 我们这样子写 比方说有个制服串

51:39.790 --> 51:45.620
s 好 我们可以使用charite

51:46.340 --> 51:51.060
比方说我们这里写个0 其实就类似于这种写法 对吧

51:52.900 --> 52:00.660
哎 我写错了啊 s0 类似于这种写法 对吧 好 我们接着写啊 接着写啊 比方说s charite

52:01.300 --> 52:05.060
charite 0 1 2 3 4啊 4

52:06.020 --> 52:09.940
你看得到最后一个 对吧 得到最后一个 好咱们超速的索引呢

52:10.660 --> 52:18.100
就是空白制服串了啊 超出这个索引就空白制服串 那么这个地方呢 跟索引就不太一样了 跟索引的话 它超出了是什么

52:19.220 --> 52:24.500
哎 怎么又写了 它超出了是什么 是不是undefined 对吧 跟数主是一样的 它没有这个属性

52:24.900 --> 52:27.220
没有5这个属性 所以说它得到的是undefined

52:28.020 --> 52:32.500
但是这里呢 它超过了 它是一个空制服串啊 比方说charite

52:34.100 --> 52:37.540
11啊 你看得到的是空制服串 就这个区别啊 就这个区别

52:38.260 --> 52:39.220
好吧 这是关于

52:40.340 --> 52:41.300
啊 这个charite

52:42.100 --> 52:51.140
好 另外一个charcodeite 表示什么意思呢 表示得到指定位置的制服的ulicode编码

52:51.780 --> 52:56.260
啊 得到制服的ulicode编码 好 看一下

52:57.220 --> 52:57.860
有个制服串

52:59.780 --> 53:00.340
abc

53:01.140 --> 53:02.180
啊 然后中文

53:03.540 --> 53:04.100
啊 成哥

53:06.190 --> 53:09.070
好 接下来我们使用charcodeite

53:09.630 --> 53:10.430
比方说0

53:11.390 --> 53:14.910
得到编码是97 小写字母a 编码是97

53:15.870 --> 53:16.110
1

53:16.910 --> 53:17.710
编码98

53:18.270 --> 53:21.390
好 然后呢 我给它写个中文呢 0 1 2 3

53:21.950 --> 53:24.030
啊 3 它的编码是25104

53:24.910 --> 53:25.870
4呢 中文呢

53:26.350 --> 53:30.670
25 21733 5呢 没有这个东西 没有这个东西是nan

53:31.230 --> 53:34.910
它是这么的玩的啊 得到某一个位置的制服的编码

53:35.550 --> 53:38.030
它得到的不是制服 得到的是制服的编码

53:38.670 --> 53:39.310
应该是这个意思吧

53:40.030 --> 53:42.910
OK啊 好 那么咱们呢 就这里

53:44.270 --> 53:49.150
这几笔charcodeite 这个函数

53:49.790 --> 53:50.910
得到的是制服编码

53:52.190 --> 53:55.070
好 下面这个啊

53:55.950 --> 53:58.030
这个就不说了 我们就说常用的

53:59.470 --> 54:00.030
concrete

54:00.670 --> 54:04.190
跟输主差不多 跟输主差不多 但是跟输主没有关系啊

54:04.270 --> 54:06.270
它是写了一个同名的函数

54:06.670 --> 54:09.070
跟输主没有关系 只是名字抽小相同而已

54:09.550 --> 54:14.590
表示连接 连接两个文本反而回一个新的制服圈

54:15.310 --> 54:18.990
跟那个什么呢 跟那个制服圈用加号拼接差不多

54:19.310 --> 54:22.350
只不过这里呢 可以拼接多个 可以拼接多个 我们进去看一下

54:25.390 --> 54:28.510
它可以拼接多个制服圈 反而回一个新的制服圈

54:28.910 --> 54:30.990
反回一个新的制服圈 就这么回事

54:31.870 --> 54:34.830
这是concrete 没什么好说的啊 我们举个例子就完事了

54:35.150 --> 54:37.870
比方说 con 随便写吧

54:38.510 --> 54:40.350
随便写 写个制服圈 s

54:42.510 --> 54:42.990
随便写

54:43.950 --> 54:44.750
就这个

54:44.750 --> 54:46.270
然后呢 sconcrete

54:47.470 --> 54:47.870
一

54:49.230 --> 54:49.550
二

54:50.510 --> 54:50.990
abc

54:51.630 --> 54:52.110
你看一下

54:53.070 --> 54:54.590
是吧 就可以把它拼接了啊

54:54.590 --> 54:56.670
这个表达是反回一个新的制服圈

54:56.670 --> 54:58.430
这个新的制服圈呢 就是拼接的结果

54:59.390 --> 55:00.270
好 这个很简单啊

55:00.910 --> 55:01.870
好 这是concrete

55:04.340 --> 55:04.980
继续看啊

55:05.940 --> 55:08.660
include 表示判断一个制服圈里面

55:08.660 --> 55:10.420
是否包含其他制服圈

55:10.420 --> 55:11.940
是否包含其他制服圈

55:11.940 --> 55:15.060
然后这个函数呢 是不是跟数组又类似啊 对吧

55:15.060 --> 55:15.780
又类似

55:15.780 --> 55:18.100
只不过它这里边呢 传的是制服圈

55:18.100 --> 55:19.460
你要查的制服圈是什么

55:19.460 --> 55:20.500
你在这里边写

55:20.900 --> 55:23.540
好 这里边还可以给一个 你从哪个位置开始查照

55:23.780 --> 55:27.380
比方说啊 这里 s 我们看一下这里边是否包含

55:28.580 --> 55:29.620
1这个制服呢

55:30.500 --> 55:32.740
force s 里边还没有1这个制服

55:33.700 --> 55:35.380
好 有人说不是拼接了吗

55:35.380 --> 55:37.380
拼接 它是没有改变原来的制服圈

55:37.380 --> 55:38.900
它是反回一个新的制服圈啊

55:39.460 --> 55:41.700
include 比方说 这里传一个a

55:42.340 --> 55:43.460
你看 就包含了a

55:44.260 --> 55:44.740
没问题吧

55:45.860 --> 55:47.780
嗯 这是关于这个include

55:48.900 --> 55:51.940
好 这个android 表示什么意思呢

55:51.940 --> 55:54.980
表示是判断一个制服圈是否以

55:55.780 --> 55:58.340
某个制服结尾啊 某个制服圈结尾

55:58.900 --> 56:01.220
是这么个意思 这个先记一下include

56:01.780 --> 56:03.220
我先记在这里的作用就是

56:03.220 --> 56:05.540
以后你们看笔记的时候知道我讲了这个东西了

56:05.540 --> 56:06.580
要有这么个印象

56:07.540 --> 56:08.660
好 比方说啊

56:08.660 --> 56:13.220
这个android s 还是来

56:14.820 --> 56:19.940
android s 我看一下这个制服圈是不是以成歌结尾

56:21.540 --> 56:22.980
cue 看没有 没问题吧

56:24.020 --> 56:27.380
那如果我加上一个是不是abc

56:27.380 --> 56:28.660
是不是也abc结尾了

56:28.660 --> 56:29.620
那就是force

56:29.700 --> 56:31.220
是不是以空制服圈结尾了

56:31.220 --> 56:32.900
那这个东西永远为处 对吧

56:32.900 --> 56:33.700
永远为处

56:33.700 --> 56:35.540
因为它一定是以空制服圈结尾

56:35.540 --> 56:36.740
空制服圈表示没有嘛

56:37.300 --> 56:39.540
就后边最后一个位置是空制服圈

56:39.540 --> 56:40.340
就啥都没有

56:41.460 --> 56:43.540
这个地方是cue 这个地方永远为处

56:44.340 --> 56:45.300
好 这是android s

56:47.140 --> 56:48.740
我们这里讲了android s

56:50.340 --> 56:51.220
好 像这些东西啊

56:51.220 --> 56:52.500
都是焦虑怎么去用

56:52.500 --> 56:54.260
我们不用去自己写了

56:54.260 --> 56:56.340
就有这么个印象

56:56.340 --> 56:58.740
我们在标准的 语言标准里边呢

56:58.820 --> 57:00.020
给你提供了这些东西

57:00.020 --> 57:00.980
有这么个印象就行了

57:02.260 --> 57:03.860
好 然后下面是index f

57:03.860 --> 57:06.100
表示的是找到制服圈里边

57:06.100 --> 57:08.020
某一个制服的锁印

57:08.420 --> 57:09.460
某个制服的锁印

57:10.020 --> 57:10.740
看一下 又来吧

57:11.860 --> 57:12.900
这个s已经有了

57:12.900 --> 57:13.780
这个s已经有了

57:14.500 --> 57:15.700
s index f

57:16.340 --> 57:17.380
比方说c

57:17.940 --> 57:19.220
它传入了一个制服圈c

57:19.940 --> 57:21.620
c的位置在哪呢

57:21.620 --> 57:22.980
在下标2这个位置

57:22.980 --> 57:24.580
怎么样 0 1 2

57:24.580 --> 57:25.620
下标2这个位置

57:25.620 --> 57:27.060
再来 index f

57:27.780 --> 57:29.620
比方说 乘哥

57:31.380 --> 57:32.580
看一下在哪呢

57:32.580 --> 57:34.100
0 1 2 3

57:34.100 --> 57:35.780
乘哥在3这个位置

57:35.780 --> 57:36.820
下标位3这个位置

57:36.820 --> 57:37.860
他找的是第一个制服

57:38.660 --> 57:39.220
第一个制服

57:39.220 --> 57:40.100
把它当成个整体

57:40.660 --> 57:42.500
然后看第一个制服出现了位置

57:44.180 --> 57:44.580
然后呢

57:44.580 --> 57:46.180
如果你找到没找到怎么办呢

57:46.180 --> 57:47.060
你觉得是啥

57:47.060 --> 57:47.780
如果没找到

57:49.300 --> 57:50.100
如果你没找到

57:50.100 --> 57:51.220
他没找到的话

57:51.220 --> 57:52.260
那么找到的是-1

57:52.260 --> 57:53.220
找到-1

57:53.860 --> 57:55.220
跟这个制服圈差不多

57:55.220 --> 57:56.500
跟那个输主差不多

57:56.500 --> 57:57.460
那就是index f

57:59.390 --> 58:00.910
制服圈里面有很多处理函数

58:01.550 --> 58:02.110
好

58:02.110 --> 58:02.910
这个不用说了吧

58:03.550 --> 58:06.030
index f是表示首次出现的索引

58:06.030 --> 58:07.790
nars index f呢

58:07.790 --> 58:10.110
表示是最后一次出现的索引

58:10.910 --> 58:12.350
nars index f

58:12.990 --> 58:13.550
是一样的

58:14.990 --> 58:16.030
好 然后再往下看

58:17.150 --> 58:18.830
关于这个什么争折表拿式

58:18.830 --> 58:20.750
我们后边会专门有个课程来讲

58:20.750 --> 58:22.350
就是我们这门课里边

58:22.350 --> 58:24.030
会专门有一个章节

58:24.030 --> 58:24.990
专门专门有一个课

58:24.990 --> 58:25.870
来讲这个东西

58:25.870 --> 58:26.510
现在还没讲

58:26.510 --> 58:27.390
所以说现在先不管

58:28.430 --> 58:29.550
好 咱们再来看

58:29.550 --> 58:30.110
再来看

58:30.670 --> 58:33.310
好 这个pand end和pand start

58:33.310 --> 58:34.350
这两个函数很有用

58:34.910 --> 58:35.710
非常非常有用

58:36.190 --> 58:37.310
它是指的是什么呢

58:37.310 --> 58:39.870
它是指的是在制服圈的开始

58:39.870 --> 58:41.870
或者是制服圈的末尾

58:41.870 --> 58:43.470
填充一些东西

58:43.470 --> 58:45.630
来达到指定的长度

58:46.270 --> 58:47.470
在制服圈的开始

58:47.470 --> 58:48.990
或者是制服圈的末尾

58:48.990 --> 58:50.430
填充一些东西

58:50.430 --> 58:51.310
达到指定的长度

58:51.310 --> 58:52.510
它有参数

58:52.510 --> 58:53.710
第一个参数的传长度

58:53.710 --> 58:55.150
第二个参数的传

58:55.150 --> 58:56.830
你填充的制服圈

58:56.830 --> 58:57.550
咱们来举个例子

58:58.830 --> 59:00.750
我们后边经常会用到

59:00.750 --> 59:01.310
这么一些东西

59:01.310 --> 59:02.990
比如说10分秒

59:02.990 --> 59:03.950
10分秒

59:03.950 --> 59:04.670
我们在这里写

59:04.670 --> 59:09.950
比如说小时

59:09.950 --> 59:11.310
小时

59:11.310 --> 59:12.670
比如说2点

59:12.670 --> 59:13.950
2点

59:13.950 --> 59:15.150
然后分钟

59:15.150 --> 59:16.510
分钟呢

59:16.510 --> 59:18.110
我们比方说是1

59:18.110 --> 59:20.350
比方说是8吧

59:20.350 --> 59:21.950
2.8分

59:21.950 --> 59:23.310
秒了

59:23.310 --> 59:25.070
秒了

59:25.070 --> 59:26.990
比方说是20秒

59:26.990 --> 59:27.950
20秒

59:27.950 --> 59:29.710
好 现在我要把它

59:29.710 --> 59:30.830
用这种格式输出

59:31.790 --> 59:32.910
输出这个

59:32.910 --> 59:34.590
02

59:34.590 --> 59:36.590
08

59:36.590 --> 59:37.550
020

59:37.550 --> 59:38.590
这才是时间的显

59:38.590 --> 59:39.870
正常的显示格式

59:39.870 --> 59:41.390
好 那怎么来输出呢

59:41.390 --> 59:42.590
它前面要加0

59:42.590 --> 59:43.950
就是它有可能加0

59:43.950 --> 59:45.150
有可能不加0

59:45.150 --> 59:46.590
它如果超过了

59:46.590 --> 59:48.110
它如果是两位数的话

59:48.110 --> 59:49.150
它就不用加0了

59:49.150 --> 59:50.830
它如果不是两位数就要加0

59:50.830 --> 59:52.350
这个我们通常要自于去判断

59:52.350 --> 59:53.070
很麻烦

59:53.070 --> 59:54.670
其实我们完全可以

59:54.670 --> 59:56.110
使用制服圈的方式

59:56.110 --> 59:57.710
来解决这个问题

59:57.710 --> 59:58.590
怎么来做呢

59:58.590 --> 59:59.230
看着

01:00:00.830 --> 01:00:01.790
它最终的结果

01:00:01.790 --> 01:00:03.150
我们直接输出结果

01:00:03.150 --> 01:00:05.390
直接输出结果

01:00:05.390 --> 01:00:06.670
首先把这个

01:00:06.670 --> 01:00:07.390
hour

01:00:07.390 --> 01:00:08.030
第一个部分

01:00:08.030 --> 01:00:08.990
把hour

01:00:08.990 --> 01:00:10.590
转换成制服圈

01:00:10.590 --> 01:00:13.230
把它转换成制服圈

01:00:13.230 --> 01:00:16.430
好 转换成制服圈过后

01:00:16.430 --> 01:00:17.630
然后呢

01:00:17.630 --> 01:00:19.470
制服圈里面不是一个函数吗

01:00:19.470 --> 01:00:22.110
叫做什么

01:00:22.110 --> 01:00:24.670
pand

01:00:24.670 --> 01:00:26.350
叫什么

01:00:26.350 --> 01:00:28.990
叫做pand start

01:00:28.990 --> 01:00:30.590
pand start

01:00:30.590 --> 01:00:32.350
start

01:00:32.350 --> 01:00:32.910
好

01:00:32.910 --> 01:00:33.950
然后第一个位置

01:00:33.950 --> 01:00:35.710
填长度

01:00:35.710 --> 01:00:37.230
长度为2

01:00:37.230 --> 01:00:38.350
长度为2

01:00:38.350 --> 01:00:39.310
如果不足

01:00:39.310 --> 01:00:40.270
不足两位

01:00:40.270 --> 01:00:41.070
填冲杂了

01:00:41.070 --> 01:00:42.350
填冲零

01:00:42.350 --> 01:00:46.560
运行看一下

01:00:46.560 --> 01:00:48.480
你看得到结果是不是零二了

01:00:48.480 --> 01:00:48.800
对吧

01:00:48.800 --> 01:00:50.000
是零二

01:00:50.000 --> 01:00:51.200
好 我们再来演示一下

01:00:51.200 --> 01:00:52.160
再来演示一下

01:00:52.160 --> 01:00:55.360
比方说一个s

01:00:55.360 --> 01:00:56.560
s呢

01:00:56.560 --> 01:01:00.000
我调用它的pand start

01:01:00.000 --> 01:01:01.760
比方说一个长度为7

01:01:01.760 --> 01:01:03.200
如果不足7的话

01:01:03.280 --> 01:01:07.520
我给你填冲一个新号

01:01:07.520 --> 01:01:08.720
你看得到结果就是这样

01:01:08.720 --> 01:01:10.960
它一定把它填冲到7位

01:01:10.960 --> 01:01:12.400
如果一定把它填冲到7位

01:01:12.400 --> 01:01:13.680
如果不足7位的话

01:01:13.680 --> 01:01:15.760
前边有用的是start

01:01:15.760 --> 01:01:19.920
所以它前边用新号来进行代替

01:01:19.920 --> 01:01:22.880
好 如果它已经满足7位呢

01:01:22.880 --> 01:01:25.600
如果它已经满足7位

01:01:25.600 --> 01:01:26.960
好 再来看

01:01:26.960 --> 01:01:29.760
spand start

01:01:29.760 --> 01:01:30.800
已经满足7位

01:01:30.800 --> 01:01:31.920
那前边填冲新号

01:01:31.920 --> 01:01:32.640
还能填冲吗

01:01:32.640 --> 01:01:33.600
这不能填冲了

01:01:33.600 --> 01:01:34.000
对吧

01:01:34.000 --> 01:01:34.880
不满7位

01:01:34.880 --> 01:01:37.680
前边填冇一个字符

01:01:37.680 --> 01:01:39.600
好 如果这个字符比方说

01:01:39.600 --> 01:01:40.320
比方说

01:01:40.320 --> 01:01:42.080
再来一个例子

01:01:42.080 --> 01:01:42.640
s呢

01:01:42.640 --> 01:01:43.200
是这个字

01:01:46.080 --> 01:01:47.360
就一个a

01:01:47.360 --> 01:01:51.600
spand start

01:01:51.600 --> 01:01:52.640
7个字符

01:01:52.640 --> 01:01:54.480
好 这里我写两个

01:01:54.480 --> 01:01:55.680
我写两个

01:01:55.680 --> 01:01:57.600
或者说写三个吧

01:01:57.600 --> 01:01:58.640
写三个

01:01:58.640 --> 01:02:00.320
或者说写四个吧

01:02:00.400 --> 01:02:02.000
温号 感叹号

01:02:02.000 --> 01:02:02.960
大阔号

01:02:02.960 --> 01:02:04.000
写四个

01:02:04.000 --> 01:02:04.960
你看它怎么填冲

01:02:04.960 --> 01:02:06.960
它就这样子循环填冲

01:02:06.960 --> 01:02:08.400
填冲一部分

01:02:08.400 --> 01:02:09.520
然后再填冲

01:02:09.520 --> 01:02:10.400
诶 填冲完了

01:02:10.400 --> 01:02:10.960
刚好满了

01:02:10.960 --> 01:02:11.200
对吧

01:02:11.200 --> 01:02:12.640
就不再填冲了

01:02:12.640 --> 01:02:13.520
你看这意思吧

01:02:13.520 --> 01:02:15.920
但是我们这种情况遇到比较少

01:02:15.920 --> 01:02:16.640
我们总之呢

01:02:16.640 --> 01:02:19.360
我们通过这个例子的告诉大家

01:02:19.360 --> 01:02:20.240
通常情况下

01:02:20.240 --> 01:02:22.480
会在这里经常会用的

01:02:22.480 --> 01:02:24.080
就是它必须要满足多少位

01:02:24.080 --> 01:02:25.280
如果不满的话

01:02:25.280 --> 01:02:26.960
填冲某个东西

01:02:26.960 --> 01:02:28.720
好 这里把它装成字符串

01:02:28.800 --> 01:02:30.320
然后pan to start

01:02:30.320 --> 01:02:31.920
至少有点两位

01:02:31.920 --> 01:02:33.040
一定点两位

01:02:33.040 --> 01:02:34.160
那么不满两位的话

01:02:34.160 --> 01:02:35.360
我就填冲某

01:02:35.360 --> 01:02:37.040
你看这个位置是不是写好了

01:02:37.040 --> 01:02:37.920
这个位置写好了

01:02:37.920 --> 01:02:41.920
然后接下来小时分钟

01:02:41.920 --> 01:02:43.200
我们这个换个行吧

01:02:43.200 --> 01:02:43.840
这样子换行

01:02:47.280 --> 01:02:48.080
分钟

01:02:48.080 --> 01:02:49.600
minutes

01:02:49.600 --> 01:02:50.960
小时分钟

01:02:50.960 --> 01:02:51.520
然后呢

01:02:53.280 --> 01:02:53.520
秒

01:02:58.030 --> 01:02:58.430
second

01:02:59.150 --> 01:03:00.430
保存看一下

01:03:00.430 --> 01:03:02.430
那么每家冒号

01:03:02.430 --> 01:03:04.990
看一下

01:03:04.990 --> 01:03:06.030
这边完事了

01:03:06.030 --> 01:03:06.590
这样子呢

01:03:06.590 --> 01:03:07.470
我们小时分钟

01:03:07.470 --> 01:03:08.590
不管是什么样的数字

01:03:08.590 --> 01:03:09.790
它的格式都是正确的

01:03:09.790 --> 01:03:11.390
格式永远是正确的

01:03:11.390 --> 01:03:12.910
这个东西很有用

01:03:12.910 --> 01:03:14.270
这是pan to start

01:03:14.270 --> 01:03:15.230
pan to start

01:03:15.230 --> 01:03:16.910
对应一个是pan to end

01:03:16.910 --> 01:03:17.790
什么意思

01:03:17.790 --> 01:03:19.310
就算莫为填冲

01:03:19.310 --> 01:03:20.990
start是表示在手

01:03:20.990 --> 01:03:22.750
字不算开始的位置填冲

01:03:22.750 --> 01:03:24.190
pan to end

01:03:24.190 --> 01:03:25.710
表示在莫为填冲

01:03:25.710 --> 01:03:26.510
就这个区别

01:03:26.510 --> 01:03:27.390
其他的没啥了

01:03:27.710 --> 01:03:29.870
好

01:03:29.870 --> 01:03:30.670
接下来下一个

01:03:30.670 --> 01:03:32.110
返回

01:03:32.110 --> 01:03:33.150
嗯

01:03:33.150 --> 01:03:34.190
对

01:03:34.190 --> 01:03:34.830
下一个

01:03:34.830 --> 01:03:35.710
repeat

01:03:35.710 --> 01:03:38.350
返回指定重复次数的

01:03:38.350 --> 01:03:41.150
由元素组成的字不算对象

01:03:41.150 --> 01:03:43.310
这个函数很有意思

01:03:43.310 --> 01:03:44.910
非常非常简单

01:03:44.910 --> 01:03:46.670
这就可以有点长了时间

01:03:46.670 --> 01:03:48.750
因为它这里的API确实比较多

01:03:48.750 --> 01:03:51.070
比方说咱们有个abc

01:03:51.070 --> 01:03:51.790
abc

01:03:51.790 --> 01:03:54.110
字不算这个字面量比较特殊

01:03:54.110 --> 01:03:56.110
字不算这个字面量比较特殊

01:03:56.190 --> 01:03:57.710
你可以直接把字面量了

01:03:57.710 --> 01:04:00.350
当它这个字不算包装器的对象使用

01:04:00.350 --> 01:04:02.590
跟数字的布尔不太一样

01:04:02.590 --> 01:04:02.830
好

01:04:02.830 --> 01:04:04.830
这里我们直接使用

01:04:04.830 --> 01:04:05.630
这个

01:04:05.630 --> 01:04:07.550
叫做repeat

01:04:07.550 --> 01:04:09.070
3

01:04:09.070 --> 01:04:10.190
返回一个新的字不算

01:04:10.190 --> 01:04:12.190
把这个字不算重复三次

01:04:12.190 --> 01:04:12.830
重复三次

01:04:12.830 --> 01:04:13.870
就这么回事

01:04:13.870 --> 01:04:15.310
非常非常简单

01:04:15.310 --> 01:04:18.350
就repeat

01:04:18.350 --> 01:04:20.350
repeat

01:04:20.350 --> 01:04:20.510
好

01:04:20.510 --> 01:04:22.670
下一个

01:04:22.670 --> 01:04:25.150
下一个

01:04:25.310 --> 01:04:26.110
replace

01:04:26.110 --> 01:04:27.310
替换

01:04:27.310 --> 01:04:29.310
这个地方它涉及到振折表达式

01:04:29.310 --> 01:04:29.790
但是呢

01:04:29.790 --> 01:04:30.430
振折表达式

01:04:30.430 --> 01:04:31.790
我们现在还没有讲

01:04:31.790 --> 01:04:32.510
还没有讲

01:04:32.510 --> 01:04:32.910
所以说呢

01:04:32.910 --> 01:04:33.470
这个函数呢

01:04:33.470 --> 01:04:34.030
先放一放

01:04:34.030 --> 01:04:34.910
这个函数很有用

01:04:34.910 --> 01:04:35.230
但是呢

01:04:35.230 --> 01:04:36.510
我们先放一放

01:04:36.510 --> 01:04:36.990
涉及了

01:04:36.990 --> 01:04:38.750
它也涉及到一个振折表达式

01:04:38.750 --> 01:04:39.070
所以说

01:04:39.070 --> 01:04:40.350
我们先放一放

01:04:40.350 --> 01:04:40.590
好

01:04:40.590 --> 01:04:41.870
下面这个

01:04:41.870 --> 01:04:42.830
snice

01:04:42.830 --> 01:04:45.150
栽取一个字不算区域

01:04:45.150 --> 01:04:47.550
返回一个新的字不算

01:04:47.550 --> 01:04:48.510
新的字不算

01:04:48.510 --> 01:04:49.870
这个跟数组差不多

01:04:49.870 --> 01:04:50.670
数组差不多

01:04:50.670 --> 01:04:51.710
咱们来看一下

01:04:51.710 --> 01:04:51.950
比方

01:04:51.950 --> 01:04:53.550
abcd

01:04:53.550 --> 01:04:54.910
snice

01:04:55.870 --> 01:04:57.390
跟数组是不一样的

01:04:57.390 --> 01:04:58.430
如果你啥都不写的话

01:04:58.430 --> 01:04:59.790
返回的就是

01:04:59.790 --> 01:05:00.990
当前的这个字不算

01:05:00.990 --> 01:05:02.030
如果你写个1的话

01:05:02.030 --> 01:05:02.750
返回的就是

01:05:02.750 --> 01:05:04.110
从1这个位置开始取

01:05:04.110 --> 01:05:05.390
bcd

01:05:05.390 --> 01:05:07.790
如果你写的是

01:05:07.790 --> 01:05:09.310
1和3的话

01:05:09.310 --> 01:05:10.430
那么它是怎么取呢

01:05:10.430 --> 01:05:11.710
它是取1和2

01:05:11.710 --> 01:05:12.990
下表1和2这个位置

01:05:12.990 --> 01:05:13.710
取不到3

01:05:13.710 --> 01:05:14.750
取不到3

01:05:14.750 --> 01:05:15.550
就这么回事

01:05:15.550 --> 01:05:16.510
就这么回事

01:05:16.510 --> 01:05:17.550
这是

01:05:17.550 --> 01:05:19.790
snice

01:05:19.790 --> 01:05:20.670
跟数组一样

01:05:20.670 --> 01:05:21.710
怎么记一笔

01:05:21.710 --> 01:05:23.150
snice

01:05:23.150 --> 01:05:23.390
好

01:05:23.390 --> 01:05:24.830
下一个

01:05:25.550 --> 01:05:26.430
start位置

01:05:26.430 --> 01:05:30.190
start位置是跟Android对应的

01:05:30.190 --> 01:05:31.630
一个是判断的是

01:05:31.630 --> 01:05:33.390
Android它判断的是什么呢

01:05:33.390 --> 01:05:34.030
判断的是

01:05:34.030 --> 01:05:36.750
是否以某个东西结尾

01:05:36.750 --> 01:05:37.950
而start位置

01:05:37.950 --> 01:05:38.670
判断的是

01:05:38.670 --> 01:05:41.230
是否是以某个东西开始

01:05:41.230 --> 01:05:43.230
这个说一下就行了

01:05:43.230 --> 01:05:44.670
好 下表这两个

01:05:44.670 --> 01:05:46.750
这两个超级常用

01:05:46.750 --> 01:05:48.430
一个是substream

01:05:48.430 --> 01:05:50.510
一个是substr

01:05:50.510 --> 01:05:51.630
一个是substream

01:05:51.630 --> 01:05:52.910
两个都差不多

01:05:52.990 --> 01:05:54.990
STR其实就是stune的缩写

01:05:54.990 --> 01:05:56.430
stune是支付串的意思

01:05:56.430 --> 01:05:58.510
那这两个函数它做什么事情呢

01:05:58.510 --> 01:06:00.990
都是来节取支付串的

01:06:00.990 --> 01:06:03.070
都是来节取支付串的

01:06:03.070 --> 01:06:04.990
好 我们Idea再说一下

01:06:04.990 --> 01:06:07.630
第一个subatr

01:06:07.630 --> 01:06:09.070
subatr

01:06:09.070 --> 01:06:10.830
还有一个就是substream

01:06:10.830 --> 01:06:12.750
其实这三个东西都很像

01:06:12.750 --> 01:06:13.390
都很像

01:06:13.390 --> 01:06:15.470
我们来个Idea看一下

01:06:15.470 --> 01:06:18.110
好 咱们看一下这里

01:06:18.110 --> 01:06:19.950
abcd

01:06:19.950 --> 01:06:20.990
然后snice

01:06:20.990 --> 01:06:22.270
首先看snice

01:06:22.270 --> 01:06:25.150
1和3

01:06:25.150 --> 01:06:26.110
这结果是什么

01:06:26.110 --> 01:06:28.750
取下标为1和下标为2的地方

01:06:28.750 --> 01:06:30.750
对吧 bc

01:06:30.750 --> 01:06:32.110
还是同样的支付串

01:06:32.110 --> 01:06:35.870
然后我们是取substr1和3

01:06:35.870 --> 01:06:37.550
1和3

01:06:37.550 --> 01:06:38.670
那它什么意思呢

01:06:38.670 --> 01:06:40.910
这个3指的是长度

01:06:40.910 --> 01:06:42.510
从1这个位置开始

01:06:42.510 --> 01:06:45.070
取长度为3的

01:06:45.070 --> 01:06:46.670
长度为3取3个

01:06:46.670 --> 01:06:47.950
比方说再来

01:06:47.950 --> 01:06:50.110
如果从2这里开始取3

01:06:50.110 --> 01:06:51.150
是没有3个了

01:06:51.230 --> 01:06:52.430
下标为2这个位置

01:06:52.430 --> 01:06:53.710
它取3个没有3个了

01:06:53.710 --> 01:06:54.910
它就取到c和d

01:06:54.910 --> 01:06:55.310
对吧

01:06:55.310 --> 01:06:56.110
它第二个参数

01:06:56.110 --> 01:06:57.950
它不是结束位置的下标

01:06:57.950 --> 01:06:58.990
它指的是长度

01:06:58.990 --> 01:06:59.470
看没

01:06:59.470 --> 01:07:01.630
nance指的是长度

01:07:01.630 --> 01:07:02.750
这么个意思

01:07:02.750 --> 01:07:05.950
好 接下来我们再看另外一个substream

01:07:05.950 --> 01:07:09.550
这个跟snice非常非常的像

01:07:09.550 --> 01:07:12.270
非常非常像

01:07:12.270 --> 01:07:13.390
你看

01:07:13.390 --> 01:07:14.590
得到了也是bc

01:07:14.590 --> 01:07:15.390
它这个东西

01:07:15.390 --> 01:07:16.590
它第一个是骑士位置

01:07:16.590 --> 01:07:18.350
第二个是结束位置

01:07:18.350 --> 01:07:19.470
是结束位置

01:07:19.550 --> 01:07:21.790
它跟snice非常的像

01:07:21.790 --> 01:07:24.270
那这个东西有什么区别呢

01:07:24.270 --> 01:07:25.390
我们这里对比一下

01:07:25.390 --> 01:07:29.230
这个地方可能会出面试题

01:07:29.230 --> 01:07:30.910
这个substream

01:07:30.910 --> 01:07:32.270
substr

01:07:32.270 --> 01:07:35.390
我们一个来对比一下

01:07:35.390 --> 01:07:37.230
它指的是

01:07:37.230 --> 01:07:40.910
从某个位置开始取

01:07:40.910 --> 01:07:43.870
取指定的长度

01:07:43.870 --> 01:07:46.270
它这个喊出的意思

01:07:46.270 --> 01:07:47.630
snice是

01:07:47.630 --> 01:07:51.470
从某个位置取到

01:07:51.470 --> 01:07:52.510
某个位置

01:07:52.510 --> 01:07:55.470
它在两个位置之间进行结束

01:07:55.470 --> 01:07:56.990
substream也是一样

01:07:56.990 --> 01:07:59.070
从某个位置取到某个位置

01:07:59.070 --> 01:08:01.070
好 咱们来看一下它的区别

01:08:01.070 --> 01:08:03.630
区别首先第一个

01:08:03.630 --> 01:08:05.710
就是snice

01:08:05.710 --> 01:08:07.230
snice和substream

01:08:07.230 --> 01:08:09.870
它的位置可以是附属

01:08:09.870 --> 01:08:12.990
位置可以是附属

01:08:12.990 --> 01:08:14.670
这里也是位置

01:08:14.670 --> 01:08:16.830
可以是附属

01:08:16.830 --> 01:08:19.390
但是substream位置是不能是附属的

01:08:19.390 --> 01:08:20.190
我们之前说过

01:08:20.190 --> 01:08:22.750
所引的位置是附属

01:08:22.750 --> 01:08:24.110
它就从导着牌 对吧

01:08:24.110 --> 01:08:25.470
导着牌

01:08:25.470 --> 01:08:26.670
比方说附一就是

01:08:26.670 --> 01:08:27.790
取最后一个字符

01:08:27.790 --> 01:08:29.630
从最后一个字符开始

01:08:29.630 --> 01:08:30.830
就这么个意思

01:08:30.830 --> 01:08:33.790
substream它是不能是附属

01:08:33.790 --> 01:08:35.150
不可以是附属

01:08:35.150 --> 01:08:36.670
如果它是附属的话

01:08:36.670 --> 01:08:39.310
会被自动转换成0

01:08:39.310 --> 01:08:41.150
看着

01:08:41.150 --> 01:08:42.870
abcd

01:08:42.870 --> 01:08:43.950
snice

01:08:43.950 --> 01:08:45.230
可以是附属

01:08:45.310 --> 01:08:47.310
比方说我们从c开始取

01:08:47.310 --> 01:08:48.270
我们可以写附二

01:08:48.270 --> 01:08:49.790
倒数第二个

01:08:49.790 --> 01:08:50.430
取到哪了

01:08:50.430 --> 01:08:51.470
取到倒数第一个

01:08:51.470 --> 01:08:53.550
那就取到c 看到没

01:08:53.550 --> 01:08:53.830
好

01:08:53.830 --> 01:08:56.150
然后我们再来看这个

01:08:56.150 --> 01:08:57.630
abcd

01:08:57.630 --> 01:08:59.790
substream

01:08:59.790 --> 01:09:01.150
附二

01:09:01.150 --> 01:09:02.670
从附二开始取

01:09:02.670 --> 01:09:03.750
取到哪了

01:09:03.750 --> 01:09:05.030
取到附一

01:09:05.030 --> 01:09:05.790
看一下

01:09:05.790 --> 01:09:06.830
空字符串

01:09:06.830 --> 01:09:07.550
为什么呢

01:09:07.550 --> 01:09:10.070
因为你这样子写相当于是

01:09:10.070 --> 01:09:13.430
你这样子写0

01:09:13.430 --> 01:09:15.150
相当于是这样子写

01:09:15.350 --> 01:09:16.150
第一个位置

01:09:16.150 --> 01:09:18.270
从第一个位置开始取

01:09:18.270 --> 01:09:19.110
到结束位置

01:09:19.110 --> 01:09:20.470
结束位置也是0

01:09:20.470 --> 01:09:21.230
也是取到这

01:09:21.230 --> 01:09:21.990
那不是干AA吗

01:09:21.990 --> 01:09:22.870
但是要注意

01:09:22.870 --> 01:09:24.150
它取不到结束位置

01:09:24.150 --> 01:09:25.270
所以它只能是空字不出来

01:09:25.270 --> 01:09:26.230
取不出来

01:09:26.230 --> 01:09:27.950
取不出来

01:09:27.950 --> 01:09:30.150
比方说abcd

01:09:30.150 --> 01:09:31.270
abcd

01:09:31.270 --> 01:09:32.990
snice

01:09:32.990 --> 01:09:36.230
我们只写一个附二

01:09:36.230 --> 01:09:37.110
取出来是不是cd

01:09:37.110 --> 01:09:37.550
对吧

01:09:37.550 --> 01:09:38.750
从这个位置开始取

01:09:38.750 --> 01:09:40.470
取完就是cd

01:09:40.470 --> 01:09:42.870
如果我abcd

01:09:42.910 --> 01:09:45.270
就是用substream

01:09:45.270 --> 01:09:46.950
附二

01:09:46.950 --> 01:09:48.550
那就是把整个都取出来了

01:09:48.550 --> 01:09:50.830
因为它把当当当成领埃处理

01:09:50.830 --> 01:09:52.510
把当成领埃处理

01:09:52.510 --> 01:09:53.630
同样的规则

01:09:53.630 --> 01:09:56.870
也在substr里面也可以

01:09:56.870 --> 01:09:58.070
它也是可以去复苏的

01:09:58.070 --> 01:10:01.230
它的规则跟snice是一致的

01:10:01.230 --> 01:10:01.950
明白我的意思

01:10:01.950 --> 01:10:03.550
这是它的第一个区别

01:10:03.550 --> 01:10:04.750
另外一个区别

01:10:04.750 --> 01:10:06.070
就是关于snice

01:10:06.070 --> 01:10:06.750
substream

01:10:06.750 --> 01:10:08.990
它的位置是不可换的

01:10:08.990 --> 01:10:09.830
就是substream

01:10:09.830 --> 01:10:11.710
它的参数位置不可换

01:10:11.750 --> 01:10:13.470
参数位置是

01:10:13.470 --> 01:10:15.670
substream参数位置是可换的

01:10:15.670 --> 01:10:19.670
参数位置是可调换的

01:10:19.670 --> 01:10:21.630
好看一下

01:10:21.630 --> 01:10:23.990
比方说我们abcd

01:10:23.990 --> 01:10:26.310
snice

01:10:26.310 --> 01:10:27.750
我们1

01:10:27.750 --> 01:10:28.470
3

01:10:28.470 --> 01:10:29.110
取出来多少

01:10:29.110 --> 01:10:29.950
取出来是b和c

01:10:29.950 --> 01:10:30.190
对吧

01:10:30.190 --> 01:10:30.990
这个没问题

01:10:30.990 --> 01:10:33.270
那如果我写的是3和1呢

01:10:33.270 --> 01:10:33.950
它能取吗

01:10:33.950 --> 01:10:35.310
是不是不能取了

01:10:35.310 --> 01:10:37.510
从这个位置

01:10:37.510 --> 01:10:38.350
取到这个位置

01:10:38.350 --> 01:10:38.950
咱们取了

01:10:38.950 --> 01:10:39.670
它导致了

01:10:39.670 --> 01:10:40.110
没法了

01:10:40.110 --> 01:10:41.190
它不可能导致来

01:10:41.230 --> 01:10:42.990
所以说它取不到了

01:10:42.990 --> 01:10:45.470
你的骑士位置比结束位置大了

01:10:45.470 --> 01:10:46.590
所以取不到了

01:10:46.590 --> 01:10:47.670
但是呢

01:10:47.670 --> 01:10:49.990
我们使用substream

01:10:49.990 --> 01:10:51.750
你看一下3和1

01:10:51.750 --> 01:10:52.910
是不是可以取

01:10:52.910 --> 01:10:54.870
当结束位置

01:10:54.870 --> 01:10:57.350
骑士位置比结束位置大的时候呢

01:10:57.350 --> 01:10:58.990
它会自动帮你调换过来

01:10:58.990 --> 01:11:00.990
它相当于是你这样的鞋了

01:11:00.990 --> 01:11:03.310
它会自动帮你调换过来

01:11:03.310 --> 01:11:04.670
所以说你的参数

01:11:04.670 --> 01:11:05.630
这个两个位置

01:11:05.630 --> 01:11:06.910
你是可以随便调换的

01:11:06.910 --> 01:11:08.390
是无所谓的

01:11:08.390 --> 01:11:09.630
这是它们的区别

01:11:09.630 --> 01:11:10.550
这就是区别

01:11:11.110 --> 01:11:12.190
我们平时用的是

01:11:12.190 --> 01:11:12.990
用的比较多的

01:11:12.990 --> 01:11:13.990
其实是这两个

01:11:13.990 --> 01:11:15.990
这两个用了稍微多一点

01:11:15.990 --> 01:11:18.710
这个基本上

01:11:18.710 --> 01:11:19.790
有的时候还是会用

01:11:19.790 --> 01:11:21.030
用的比较少一点

01:11:21.030 --> 01:11:22.910
用这两个比较多

01:11:22.910 --> 01:11:23.750
好

01:11:23.750 --> 01:11:27.270
这是关于这个制服创结局

01:11:27.270 --> 01:11:28.030
好

01:11:28.030 --> 01:11:29.830
下边

01:11:29.830 --> 01:11:32.310
to lowercase和to uppercase

01:11:32.310 --> 01:11:34.750
to lowercase和to uppercase

01:11:34.750 --> 01:11:38.550
这两个呢

01:11:38.590 --> 01:11:42.350
这两个是将制服创转换成大小鞋的

01:11:42.350 --> 01:11:43.630
记录一笔

01:11:43.630 --> 01:11:46.830
一个是to lowercase

01:11:46.830 --> 01:11:47.950
lower什么意思

01:11:47.950 --> 01:11:51.390
小鞋to uppercase大鞋

01:11:51.390 --> 01:11:52.750
将制服创转换成小鞋

01:11:52.750 --> 01:11:54.910
将制服创转换成大鞋

01:11:54.910 --> 01:11:56.350
咱们随便看一下吧

01:11:56.350 --> 01:11:57.670
在这

01:11:57.670 --> 01:12:02.950
abcd to lowercase

01:12:02.950 --> 01:12:04.310
你看

01:12:04.310 --> 01:12:05.750
小鞋本来就是小鞋的

01:12:05.750 --> 01:12:06.670
我们写个大鞋的

01:12:07.670 --> 01:12:10.590
to lowercase

01:12:10.590 --> 01:12:12.110
小鞋了对吧

01:12:12.110 --> 01:12:13.030
没问题吧

01:12:13.030 --> 01:12:16.470
abcd to uppercase

01:12:16.470 --> 01:12:18.030
转换成大鞋

01:12:18.030 --> 01:12:19.230
变大鞋了

01:12:19.230 --> 01:12:20.310
这是这两个还说

01:12:20.310 --> 01:12:21.550
可以得到一个新的制服创

01:12:21.550 --> 01:12:24.950
新的制服创是转换之后的制服创

01:12:24.950 --> 01:12:25.710
下一个

01:12:25.710 --> 01:12:27.670
tune

01:12:27.670 --> 01:12:28.710
这两个

01:12:28.710 --> 01:12:30.750
这个函数也非常有用

01:12:30.750 --> 01:12:33.670
表示去掉守卫控格

01:12:33.670 --> 01:12:34.670
它是一个新的函数

01:12:34.670 --> 01:12:36.350
是也是里面出来的

01:12:36.430 --> 01:12:38.030
比方说咱们一个制服创

01:12:38.030 --> 01:12:39.230
前面有些空格

01:12:39.230 --> 01:12:40.430
中间有些空格

01:12:40.430 --> 01:12:41.430
后边有些空格

01:12:41.430 --> 01:12:43.230
使用tune

01:12:43.230 --> 01:12:45.590
你看守卫的空格给你去掉了

01:12:45.590 --> 01:12:46.910
它这个函数有什么好处呢

01:12:46.910 --> 01:12:52.030
就是以后用户在我们的网页上去写一些东西

01:12:52.030 --> 01:12:53.430
写的东西它可能不小心

01:12:53.430 --> 01:12:56.030
比方说账号密码前边加了一些空格

01:12:56.030 --> 01:12:57.110
那么你可以通过这个函数

01:12:57.110 --> 01:12:58.830
把它守卫空格去掉

01:12:58.830 --> 01:13:00.510
去掉之后再进行比较

01:13:00.510 --> 01:13:03.230
我们忽略它的空格来进行比较

01:13:03.230 --> 01:13:06.150
这样子是我们常见的一种方式

01:13:06.150 --> 01:13:08.470
这是关于tune

01:13:08.470 --> 01:13:09.750
好下面还有两个

01:13:09.750 --> 01:13:11.990
一个是去掉左边的空格

01:13:11.990 --> 01:13:14.470
一个是去掉制服创右边的空格

01:13:14.470 --> 01:13:16.430
它两种调用方式都是一样的

01:13:16.430 --> 01:13:18.310
第一个方式是第二个方式的别名

01:13:18.310 --> 01:13:19.230
是一样的

01:13:19.230 --> 01:13:20.230
就是tune start

01:13:20.230 --> 01:13:21.710
表示去掉左边的空格

01:13:21.710 --> 01:13:22.470
tune end

01:13:22.470 --> 01:13:23.750
表示去掉右边的空格

01:13:23.750 --> 01:13:24.950
咱们来看一下

01:13:24.950 --> 01:13:25.630
还是这个

01:13:25.630 --> 01:13:26.910
还是这个制服创

01:13:26.910 --> 01:13:30.550
我们调用tune start

01:13:30.550 --> 01:13:31.310
看一下

01:13:31.310 --> 01:13:33.030
去掉左边的空格

01:13:33.030 --> 01:13:33.750
空白

01:13:33.750 --> 01:13:35.110
去掉左边的空白

01:13:35.110 --> 01:13:38.390
然后如果我们调一个tune left

01:13:38.390 --> 01:13:39.070
是一样的

01:13:39.070 --> 01:13:40.670
两个还说是一模一样的

01:13:40.670 --> 01:13:41.830
一模一样的

01:13:41.830 --> 01:13:43.910
没有任何区别

01:13:43.910 --> 01:13:45.910
就是给你提供两个

01:13:45.910 --> 01:13:47.550
就是你方便你记忆一点

01:13:47.550 --> 01:13:48.910
有的时候记忆成左右

01:13:48.910 --> 01:13:50.590
有的时候记忆成开始结束

01:13:50.590 --> 01:13:51.470
都可以

01:13:51.470 --> 01:13:52.070
tune right

01:13:52.070 --> 01:13:53.430
去掉右边

01:13:53.430 --> 01:13:55.910
tune end

01:13:55.910 --> 01:13:56.710
去掉右边

01:13:56.710 --> 01:13:57.550
去掉结束

01:13:57.550 --> 01:13:58.430
都是一样的

01:13:58.430 --> 01:13:59.590
是一样的

01:13:59.590 --> 01:14:01.190
只不过这两个东西

01:14:01.190 --> 01:14:03.030
目前还没有成为正式的标准

01:14:03.070 --> 01:14:04.350
所以说谨慎使用

01:14:06.070 --> 01:14:07.510
这里我还有一个地方

01:14:07.510 --> 01:14:09.390
我现在想起来了

01:14:09.390 --> 01:14:10.510
所以我把视频剪了一下

01:14:10.510 --> 01:14:11.350
我现在想起来了

01:14:11.350 --> 01:14:12.790
给大家补充一下

01:14:12.790 --> 01:14:13.510
还有这个函数

01:14:13.510 --> 01:14:15.390
这个函数我都居然忘了讲了

01:14:15.390 --> 01:14:16.790
这个函数很重要

01:14:16.790 --> 01:14:19.630
split表示分割制服创

01:14:19.630 --> 01:14:21.110
记忆比

01:14:21.110 --> 01:14:22.110
作业我已经写好了

01:14:22.110 --> 01:14:23.430
以后我们看

01:14:23.430 --> 01:14:24.150
记忆比

01:14:24.150 --> 01:14:25.670
split

01:14:25.670 --> 01:14:27.470
它是用来分割制服创的

01:14:27.470 --> 01:14:30.590
它是可以把制服创分割成为数组

01:14:30.590 --> 01:14:32.030
咱们来看一下

01:14:32.030 --> 01:14:32.990
split

01:14:33.030 --> 01:14:34.470
比方说咱们

01:14:34.470 --> 01:14:35.830
我们这里有个制服创

01:14:35.830 --> 01:14:36.950
一个制服创

01:14:36.950 --> 01:14:44.070
abcdefg

01:14:44.070 --> 01:14:45.510
随便了

01:14:45.510 --> 01:14:48.670
然后我们这里调用一个函数叫split

01:14:48.670 --> 01:14:51.030
这里边我们写上一个分割服

01:14:51.030 --> 01:14:52.790
写上一个分割服

01:14:52.790 --> 01:14:54.630
分割服我们就写个豆号

01:14:54.630 --> 01:14:55.470
看一下

01:14:55.470 --> 01:14:56.710
你会得到一个数组

01:14:56.710 --> 01:14:58.870
看没得到个数组

01:14:58.870 --> 01:14:59.910
这是个真的数组

01:14:59.910 --> 01:15:01.030
这是一个真实的数组

01:15:01.030 --> 01:15:01.790
看没

01:15:01.830 --> 01:15:03.230
这个数组分割出来了

01:15:03.230 --> 01:15:05.510
它就把按照这个豆号来进行分割

01:15:05.510 --> 01:15:07.430
分割成一个数组

01:15:07.430 --> 01:15:09.950
数组的每一项是一个分割之后的制服创

01:15:09.950 --> 01:15:11.630
注意看你看这里还有空格

01:15:11.630 --> 01:15:12.350
为什么有空格呢

01:15:12.350 --> 01:15:13.990
因为分割出来这里有空格

01:15:13.990 --> 01:15:16.070
那如果你加上一个豆号

01:15:16.070 --> 01:15:18.350
如果你加上一个豆号空格来分割

01:15:18.350 --> 01:15:20.270
你看分割出来过后

01:15:20.270 --> 01:15:21.950
这里就没有空格了

01:15:21.950 --> 01:15:22.870
另外这个意思

01:15:22.870 --> 01:15:24.710
它就可以用来分割制服创

01:15:24.710 --> 01:15:25.630
非常非常好用

01:15:25.630 --> 01:15:27.190
这个玩意非常好用

01:15:27.190 --> 01:15:28.870
于是分割制服创

01:15:28.870 --> 01:15:31.910
就有的时候我们就可以联合起来

01:15:31.910 --> 01:15:32.670
跟某一些东西

01:15:32.670 --> 01:15:35.990
跟之前的数组里边的东西就形成互动了

01:15:35.990 --> 01:15:37.590
我们之前数组学了那么多函数

01:15:37.590 --> 01:15:38.030
对吧

01:15:38.030 --> 01:15:39.190
就可以形成互动

01:15:39.190 --> 01:15:42.390
有的时候可以达到一些巧妙的解决办法

01:15:42.390 --> 01:15:44.230
比方说咱们刚才这个例子

01:15:44.230 --> 01:15:45.390
刚才这个例子里边

01:15:45.390 --> 01:15:47.670
你看我们比方说要去掉这些空格

01:15:47.670 --> 01:15:48.070
对吧

01:15:48.070 --> 01:15:49.870
要去掉这些地方的空格

01:15:49.870 --> 01:15:50.510
怎么去掉呢

01:15:50.510 --> 01:15:51.790
我们可以用这种方式

01:15:51.790 --> 01:15:53.790
比方说要去掉空格

01:15:53.790 --> 01:15:56.030
同时要把这个豆号换成炖号

01:15:56.790 --> 01:15:57.590
怎么办呢

01:15:57.670 --> 01:16:00.470
我们可以先用豆号空格来进行分割

01:16:00.470 --> 01:16:01.790
分割出来是不是个数组

01:16:01.790 --> 01:16:02.230
对吧

01:16:02.230 --> 01:16:03.710
我们再去调用数组里边

01:16:03.710 --> 01:16:04.830
它不是一个交印吗

01:16:04.830 --> 01:16:05.270
对吧

01:16:05.270 --> 01:16:06.910
数字里面不是有交印吗

01:16:06.910 --> 01:16:10.950
交印再把它用炖号来连接

01:16:10.950 --> 01:16:12.150
就变成了这样子了

01:16:13.230 --> 01:16:14.190
这是关于分割

01:16:14.190 --> 01:16:14.990
分割非常好用

01:16:14.990 --> 01:16:16.750
因为它可以跟数组关联起来

01:16:17.830 --> 01:16:18.550
好了

01:16:18.550 --> 01:16:18.910
OK

01:16:18.910 --> 01:16:20.870
咱们这一课就差不多了

01:16:22.550 --> 01:16:24.470
如果还有一些没讲到的

01:16:24.470 --> 01:16:25.190
应该没有了

01:16:25.190 --> 01:16:25.790
应该没有了

01:16:25.830 --> 01:16:27.990
我是看着官方文章还在这讲的

01:16:27.990 --> 01:16:28.630
应该没有了

01:16:28.630 --> 01:16:30.910
如果假设还有一些没讲到的

01:16:30.910 --> 01:16:33.030
我们以后遇到了再单独说吧

01:16:33.790 --> 01:16:35.230
字幕创里边还有一些

01:16:35.230 --> 01:16:36.470
就是关于政策表达式的

01:16:36.470 --> 01:16:38.990
政策表达式需要专门来一些课

01:16:38.990 --> 01:16:40.070
专门来一些课来讲

01:16:40.070 --> 01:16:41.390
那个东西比较多

01:16:41.390 --> 01:16:43.710
我们这里先不管什么政策表达式

01:16:43.710 --> 01:16:44.870
今天我们的作业

01:16:44.870 --> 01:16:46.030
作业有五道题

01:16:46.030 --> 01:16:48.550
这五道题多多少少会有一些难度

01:16:49.230 --> 01:16:50.670
好好去想一想

01:16:50.670 --> 01:16:51.910
我们现在学习了这么东西

01:16:51.910 --> 01:16:52.550
把用起来

01:16:52.550 --> 01:16:54.390
你不用的话很快就会忘记了

01:16:55.390 --> 01:16:56.990
想一想这些东西该怎么去做

01:16:56.990 --> 01:16:57.710
我们下几课了

01:16:57.710 --> 01:16:58.950
去把这些题讲一遍

01:16:58.950 --> 01:16:59.310
好吧

01:16:59.310 --> 01:17:00.270
这几课时间有点长

01:17:01.550 --> 01:17:02.390
大家很不错

01:17:02.390 --> 01:17:04.110
有这个耐心把听完

01:17:04.110 --> 01:17:05.310
因为讲API

01:17:05.310 --> 01:17:06.470
就是讲这个标准库

01:17:06.470 --> 01:17:08.950
确实多多少少会有一些枯燥

01:17:08.950 --> 01:17:11.030
因为我们自己没有去写东西

01:17:11.030 --> 01:17:12.670
都是用别人写好的东西

01:17:12.670 --> 01:17:14.830
我们只是去看一下它有哪些功能

01:17:14.830 --> 01:17:15.830
一用这个标准库

01:17:15.830 --> 01:17:16.470
学这个标准库

01:17:16.470 --> 01:17:19.270
就好像是在阅读这个产品的说明书

01:17:19.270 --> 01:17:20.470
告诉你这个地方怎么用

01:17:20.470 --> 01:17:21.670
这个地方又怎么用

01:17:21.670 --> 01:17:23.470
所以多多少少会有一些枯燥

01:17:23.550 --> 01:17:24.790
但是你不学又不行

01:17:24.790 --> 01:17:26.310
你如果一点印象都没有

01:17:26.310 --> 01:17:28.630
以后做一些练习做效果的时候

01:17:28.630 --> 01:17:30.350
你根本就不知道如何下手

01:17:30.350 --> 01:17:31.830
你首先得有这么个印象

01:17:31.830 --> 01:17:32.790
它有这个东西

01:17:32.790 --> 01:17:34.710
可能我以后忘了怎么去用了

01:17:34.710 --> 01:17:35.350
都没关系

01:17:35.350 --> 01:17:37.270
但是你首先得有印象

01:17:37.270 --> 01:17:37.870
好吧

01:17:37.870 --> 01:17:38.950
这是关于这个包装

01:17:38.950 --> 01:17:40.030
原始类型包装器

01:17:40.030 --> 01:17:40.910
讲了Number

01:17:40.910 --> 01:17:41.910
讲了字幕刷

01:17:41.910 --> 01:17:44.350
布尔那个东西没啥东西

01:17:44.350 --> 01:17:45.430
把这个练习题完成

01:17:45.430 --> 01:17:46.510
我们下几课来讲练习

