WEBVTT

00:00.000 --> 00:15.450
咱们继续来学习一些烧烤桌

00:16.150 --> 00:18.350
这节课咱们学习两个东西

00:18.350 --> 00:21.250
一个是寒树防斗 一个是寒树结流

00:21.750 --> 00:23.550
我们先说寒树防斗

00:24.250 --> 00:26.050
寒树防斗是什么意思呢

00:27.050 --> 00:29.650
大家见过那个电梯都见过吧

00:30.350 --> 00:33.850
现在的电梯它都有一个红外线对吧

00:33.850 --> 00:35.450
电梯门内的一个红外线

00:35.950 --> 00:39.350
然后人进去过后电梯它会在比方说

00:39.450 --> 00:41.250
三秒钟之后关闭

00:42.150 --> 00:45.050
然后人进去过后如果这三秒钟之内

00:45.550 --> 00:47.650
又有人进来了是不是又要等三秒钟

00:47.650 --> 00:47.950
对吧

00:47.950 --> 00:50.750
之前的关闭这个行为就消失了

00:50.850 --> 00:52.350
又要重新等三秒钟

00:52.650 --> 00:53.550
然后再关闭

00:53.950 --> 00:55.750
如果这三秒钟又有人进来了

00:55.750 --> 00:56.650
是不是又要重新等

00:56.650 --> 00:56.950
对吧

00:56.950 --> 00:59.050
又要重新等三秒钟又关闭

00:59.350 --> 01:00.350
是这么一回事

01:00.550 --> 01:03.150
这个行为就叫做寒树防斗

01:03.250 --> 01:05.250
就是寒树是什么 就是做一件事

01:05.550 --> 01:07.150
做这件事不是立即做

01:07.550 --> 01:08.450
不是立即做

01:08.650 --> 01:09.650
而是等到什么呢

01:09.750 --> 01:11.650
等到一段时间之后再做

01:11.950 --> 01:15.550
如果这段时间内有个东西又触发了

01:15.850 --> 01:17.350
那么就再等一段时间

01:17.750 --> 01:18.450
是这么回事

01:18.450 --> 01:20.050
这就叫做寒树防斗

01:20.550 --> 01:21.750
寒树防斗

01:22.150 --> 01:23.950
应用场景还是蛮多的

01:24.150 --> 01:25.050
什么应用场景的

01:25.050 --> 01:27.450
比方说咱们就随便看个百度吧

01:28.450 --> 01:29.250
好 看着

01:30.650 --> 01:32.550
我们在百度里边输入一个东西

01:32.550 --> 01:34.050
输入一个关键字比方说ATML

01:35.050 --> 01:36.450
好 输入过后

01:36.450 --> 01:38.450
你看现在下面的搜索结果是不是出来了

01:38.650 --> 01:39.050
对吧

01:39.250 --> 01:40.650
这个搜索结果出来

01:40.650 --> 01:42.650
它是要经过一个网络请求

01:42.650 --> 01:44.650
需要经过网络传输的

01:44.850 --> 01:46.250
那么你可以想象一下

01:46.250 --> 01:47.750
它监听的事件是什么

01:48.050 --> 01:49.850
是不是文闷框的Input事件

01:49.850 --> 01:50.250
对吧

01:50.250 --> 01:52.650
文闷框内容发生变化的时候

01:52.650 --> 01:54.150
它会触发这个事件

01:54.450 --> 01:56.950
但是这个事件触发的非常非常频繁

01:57.250 --> 01:59.050
如果我们每输入一个

01:59.250 --> 02:01.350
它都去重新搜索的话

02:01.450 --> 02:04.750
那么整个对销率也好

02:04.750 --> 02:07.450
对网络的占用也好

02:07.650 --> 02:09.050
都不太理想

02:09.450 --> 02:10.650
所以说它会怎么做呢

02:10.650 --> 02:12.550
它会等我们把字打完

02:12.550 --> 02:14.050
打完了之后再进行搜索

02:14.050 --> 02:15.450
比方说我们打谷歌

02:16.750 --> 02:17.350
那么你看

02:17.350 --> 02:18.750
是不是等了一下才出来的

02:18.750 --> 02:19.050
对吧

02:19.050 --> 02:20.350
它等了一下才出来

02:20.450 --> 02:21.850
为什么它会等

02:21.850 --> 02:22.650
我们字打完了没有

02:22.650 --> 02:23.650
我们字打完了没有

02:23.650 --> 02:24.950
打完了之后再出来

02:25.250 --> 02:27.350
这就有点类似有一个电梯关门

02:27.550 --> 02:28.850
我们每按下一个键

02:28.850 --> 02:29.850
它要等一下

02:29.950 --> 02:30.850
如果等的过程中

02:30.850 --> 02:32.050
我们又按下了一个键

02:32.250 --> 02:33.250
它又要重新等

02:33.750 --> 02:35.350
如果过程中又按了一个键

02:35.350 --> 02:36.150
它又要重新等

02:36.150 --> 02:37.850
直到我们按完了过后

02:37.850 --> 02:38.850
没有再按了

02:38.850 --> 02:40.350
它发现时间等到了

02:40.350 --> 02:41.950
然后再去执行某一个东西

02:42.950 --> 02:45.350
再包括我们之前学习过的什么

02:46.350 --> 02:46.850
Window

02:48.150 --> 02:48.950
我们之前学习过的

02:48.950 --> 02:50.450
就是一个事件叫Window

02:50.750 --> 02:52.350
什么Unresized对吧

02:54.050 --> 02:55.850
叫做Window Unresized

02:56.750 --> 02:59.250
当窗口发生变化的时候

02:59.350 --> 03:00.350
它运行的时间

03:00.350 --> 03:02.250
窗口尺寸发生变化的时候

03:02.250 --> 03:02.950
运行的时间

03:03.250 --> 03:05.350
但这个事件运行的非常平凡

03:06.350 --> 03:07.150
太平凡了

03:07.750 --> 03:09.450
有的时候我们可能希望

03:09.450 --> 03:11.050
你不要运行那么平凡

03:11.150 --> 03:12.750
可能你稍微等一下

03:12.750 --> 03:13.950
你稍微的等一下

03:14.050 --> 03:15.550
等它没动的时候

03:15.550 --> 03:16.150
你再去运行

03:16.150 --> 03:17.750
你看你现在我们来

03:18.250 --> 03:18.750
你看

03:18.750 --> 03:20.150
这个事件是不是运行的太平凡了

03:20.150 --> 03:21.350
我们就这样拉动几次

03:21.350 --> 03:23.150
你看它运行的快100次了

03:23.250 --> 03:23.750
对不对

03:23.750 --> 03:25.350
事件运行的过于平凡

03:25.450 --> 03:26.550
所以说我们有的时候

03:26.550 --> 03:28.750
希望我们窗口变化的时候

03:28.850 --> 03:30.150
你能不能稍微等一下

03:30.350 --> 03:32.550
如果等的过程中又发生了变化

03:32.550 --> 03:32.850
OK

03:32.850 --> 03:36.250
那么你再等一下再重新等

03:36.250 --> 03:37.650
等到它没有变的时候

03:37.650 --> 03:38.650
你再去运行

03:39.150 --> 03:40.250
这就是函数防斗

03:40.950 --> 03:42.250
函数防斗有一个单词

03:42.250 --> 03:44.450
它叫做Debounce

03:44.950 --> 03:47.050
Debounce叫做防斗

03:47.350 --> 03:48.450
这个单词什么意思呢

03:48.750 --> 03:49.750
我写都没有

03:50.450 --> 03:52.250
怎么老 老担心自己单词写错

03:52.950 --> 03:54.150
就是Debounce

03:54.550 --> 03:56.750
一会我们解留的地方就是缩头

03:57.350 --> 03:58.650
我们这里看一下

03:59.050 --> 04:00.650
函数防斗我们这里以后

04:00.650 --> 04:01.550
也会经常

04:02.150 --> 04:03.050
也不说经常吧

04:03.150 --> 04:04.350
有的时候可能会用到

04:04.350 --> 04:06.150
特别是在窗体改变事件

04:06.350 --> 04:07.950
或者是文本框输入事件

04:07.950 --> 04:11.350
这些事件触发的太过于平凡的事件

04:11.350 --> 04:12.450
不要说滚动条滚动

04:12.450 --> 04:12.650
对吧

04:12.650 --> 04:14.550
也是频率非常非常高

04:15.350 --> 04:16.450
像这些事件里面

04:16.450 --> 04:18.150
我们都可以应用函数防斗

04:18.650 --> 04:20.150
因此我们会把函数防斗

04:20.650 --> 04:21.750
这个东西写到这

04:22.250 --> 04:22.750
写到这

04:24.450 --> 04:25.550
比方说Z

04:26.050 --> 04:27.050
点My Plonging

04:27.250 --> 04:28.250
给他加一个函数

04:28.250 --> 04:29.050
叫Debounce

04:30.050 --> 04:30.550
防斗

04:30.850 --> 04:31.550
函数防斗

04:34.500 --> 04:35.200
函数

04:36.300 --> 04:37.300
函数防斗

04:38.100 --> 04:39.300
好 这是什么意思呢

04:39.300 --> 04:41.100
其实他要做的事情很简单

04:41.300 --> 04:43.500
就是过了一段时间之后

04:43.800 --> 04:45.100
再去运行这个函数

04:45.500 --> 04:47.000
他要做的事情非常非常简单

04:47.100 --> 04:47.700
比方说

04:47.700 --> 04:49.900
咱们Resize的时候不是要做一件事吗

04:49.900 --> 04:50.200
对吧

04:50.200 --> 04:51.000
要做一件事

04:51.000 --> 04:51.500
OK

04:51.500 --> 04:52.500
做这件事的时候

04:52.500 --> 04:55.000
我们就可以利用函数防斗

04:55.300 --> 04:56.400
利用函数防斗

04:57.300 --> 04:59.000
过一段时间之后再去做

04:59.500 --> 05:01.200
我们把这个引用函数防斗

05:02.200 --> 05:02.900
src

05:03.600 --> 05:05.300
引用函数防斗

05:06.300 --> 05:07.400
回到Plonging

05:07.900 --> 05:08.600
函数防斗

05:08.600 --> 05:09.200
Happiness

05:09.700 --> 05:11.200
这里边我们这样子来处理

05:11.400 --> 05:12.400
My Plonging

05:13.500 --> 05:14.300
My Plonging

05:15.300 --> 05:17.100
函数防斗就是叫做Debounce

05:17.400 --> 05:18.000
Debounce

05:19.900 --> 05:20.800
调用这个函数

05:20.900 --> 05:22.600
好 这个函数里边比方说

05:22.600 --> 05:23.900
我给他传两个函数

05:24.200 --> 05:25.400
第一个参数的就是

05:25.800 --> 05:26.600
就是什么呢

05:26.800 --> 05:28.400
就是我要做的事情

05:28.500 --> 05:29.800
第二个参数是什么

05:29.800 --> 05:32.200
是多少时间之后我来做这个事

05:32.500 --> 05:33.100
比方说

05:33.400 --> 05:34.100
一秒钟

05:34.200 --> 05:34.700
有些人说

05:34.700 --> 05:35.400
那这个东西

05:35.500 --> 05:36.800
你干嘛要去写个Debounce呢

05:36.800 --> 05:37.400
你直接用这些

05:37.400 --> 05:38.200
太貓是不完了吗

05:38.200 --> 05:38.700
对不对

05:39.200 --> 05:41.100
那肯定是有原因的

05:41.100 --> 05:43.600
我们先用这个Debounce来处理一下

05:43.700 --> 05:44.500
来处理一下

05:44.600 --> 05:45.300
然后比方说

05:45.300 --> 05:46.800
我们就输出一个A

05:47.000 --> 05:47.800
输出一个A

05:48.600 --> 05:49.100
好吧

05:49.700 --> 05:51.500
接下来我们来实现这个函数

05:51.500 --> 05:52.500
这个函数要做什么事

05:52.500 --> 05:53.700
他有两个参数

05:53.800 --> 05:56.000
一个参数的就是我要执行的东西

05:56.000 --> 05:58.500
另一个参数的表示多少时间后

05:58.800 --> 06:00.800
多少时间后我来执行这个东西

06:01.100 --> 06:02.100
因此他有两个参数

06:02.100 --> 06:02.900
第一个参数是什么

06:03.000 --> 06:04.000
是不是一个毁掉函数

06:04.000 --> 06:04.400
对吧

06:04.500 --> 06:04.900
funk

06:05.200 --> 06:06.500
或者把它称为callback

06:06.600 --> 06:07.500
一个毁掉函数

06:07.500 --> 06:10.200
我们通常把函数作为参数的这种场景呢

06:10.200 --> 06:11.300
叫做毁掉函数

06:11.500 --> 06:12.900
就作为参数来传递的函数

06:12.900 --> 06:14.000
叫做毁掉函数

06:14.000 --> 06:15.100
就等一会再调用

06:15.400 --> 06:16.300
等到实际体

06:16.400 --> 06:17.900
等到实际满足的时候再调用

06:18.200 --> 06:19.200
好 第二个参数是什么

06:19.200 --> 06:19.900
时间

06:19.900 --> 06:20.300
对吧

06:20.400 --> 06:22.800
多少时间之后再调用这个函数

06:23.500 --> 06:25.000
好 接下来我们来写一下这个代码

06:25.000 --> 06:25.800
来写一下

06:26.200 --> 06:27.000
好 这个代码呢

06:27.000 --> 06:29.000
我们set

06:31.100 --> 06:31.700
timeout

06:34.100 --> 06:34.900
set timeout

06:35.100 --> 06:35.700
多少时间呢

06:35.700 --> 06:36.200
time

06:36.600 --> 06:39.600
等待这个时间之后再去运行什么

06:39.600 --> 06:40.500
运行这个函数

06:40.800 --> 06:41.300
那么这里呢

06:41.300 --> 06:42.500
我们去运行这个函数

06:42.600 --> 06:43.300
callback

06:43.600 --> 06:43.900
对吧

06:43.900 --> 06:44.900
我们去运行一下

06:45.300 --> 06:46.200
运行一下这个函数

06:47.500 --> 06:50.000
假设我们先写这么一个最简单的版本

06:50.100 --> 06:51.200
就把它封装一下

06:51.200 --> 06:51.900
封装一下

06:51.900 --> 06:53.200
封装成一个防斗函数

06:53.200 --> 06:55.400
多少时间之后再去运行这个函数

06:55.500 --> 06:56.300
执行这个函数

06:56.900 --> 06:58.100
好 接下来我们来看一下

06:58.400 --> 06:59.900
好 我们看一下能不能达到效果

07:00.900 --> 07:01.400
看一下吧

07:03.890 --> 07:04.790
运行了两次

07:07.920 --> 07:08.420
看一下

07:08.420 --> 07:09.720
是不是还是运行了很多

07:10.120 --> 07:11.220
还是运行了很多次

07:11.220 --> 07:11.620
对吧

07:11.720 --> 07:13.320
还是运行了相当多次

07:13.520 --> 07:14.220
只不过呢

07:14.220 --> 07:15.720
它把这些事件的运行呢

07:15.720 --> 07:17.320
推迟到了一秒钟之后

07:18.020 --> 07:18.820
那么这个时候呢

07:18.820 --> 07:20.320
就发生问题了

07:20.320 --> 07:21.720
你这个东西没有解决这个问题啊

07:21.720 --> 07:22.920
没有并没有解决啊

07:23.320 --> 07:24.320
因为我

07:24.520 --> 07:25.420
我这里说好了

07:25.420 --> 07:27.420
一秒钟之内只运行一次

07:27.420 --> 07:27.920
对吧

07:27.920 --> 07:28.720
只运行一次

07:28.720 --> 07:29.220
但是呢

07:29.220 --> 07:30.420
你只是给他推迟

07:30.420 --> 07:32.120
把这个事件运行的推迟了

07:32.120 --> 07:33.220
他并没有保证

07:33.220 --> 07:34.820
他只运行一次这个效果

07:35.320 --> 07:36.620
那么这个时候怎么做呢

07:37.320 --> 07:37.520
好

07:37.520 --> 07:38.120
这个时候呢

07:38.120 --> 07:39.920
我们可以利用这种方式来处理

07:40.720 --> 07:42.220
每一次产生计时

07:42.220 --> 07:43.420
不是有个计时器吗

07:43.420 --> 07:44.120
对不对

07:44.120 --> 07:45.220
是不是有个计时器

07:45.220 --> 07:45.720
ok

07:45.720 --> 07:46.920
那么比方说啊

07:46.920 --> 07:48.020
比方说这里有个变量

07:48.020 --> 07:48.920
一个全具变量

07:49.420 --> 07:50.220
是个计时器

07:50.520 --> 07:51.320
一个计时器

07:51.820 --> 07:52.620
它保存什么

07:52.620 --> 07:54.120
保存计时器的id

07:54.320 --> 07:54.720
好

07:55.720 --> 07:57.820
每一次set timeout的时候

07:57.820 --> 07:58.620
我给他复制

07:58.620 --> 07:59.020
对吧

07:59.020 --> 08:00.420
给他这个计时器复制

08:00.620 --> 08:02.520
那么在进行计时之前

08:02.520 --> 08:03.920
我们是不是可以判断一下

08:03.920 --> 08:05.220
这个计时器存不存在

08:05.620 --> 08:07.320
如果这个计时器存在的话

08:07.320 --> 08:09.020
那么之前是不是之前还有东西

08:09.020 --> 08:09.420
对吧

08:09.720 --> 08:11.020
之前还有东西

08:11.020 --> 08:11.420
对不对

08:11.620 --> 08:12.920
这计时器存在嘛

08:12.920 --> 08:15.020
所以说它之前是有东西的

08:15.020 --> 08:16.020
那么有东西的话

08:16.020 --> 08:16.520
他就

08:16.520 --> 08:17.820
他正要去做某件事

08:17.820 --> 08:20.020
比方说电梯还在等待关门

08:20.320 --> 08:22.120
那么这个时候又新进来一个人

08:22.120 --> 08:23.620
是不是要重新开始计时

08:23.620 --> 08:24.120
对吧

08:24.320 --> 08:25.420
重新开始计时

08:25.420 --> 08:28.020
于是你再把之前的计时器给给他清除掉

08:28.720 --> 08:30.220
清除掉之前的计时器

08:30.520 --> 08:32.520
清除之前的计时

08:33.120 --> 08:34.220
之前就不要计了

08:34.320 --> 08:35.120
你不要等了

08:35.220 --> 08:35.820
你不用等了

08:35.820 --> 08:37.220
因为现在我们又触发了

08:37.220 --> 08:38.120
又触发了

08:38.520 --> 08:40.320
所以说得重新清除计时

08:40.620 --> 08:40.920
好

08:40.920 --> 08:42.320
清除计时之后

08:42.320 --> 08:43.920
我们去调用回调函数

08:43.920 --> 08:44.120
好

08:44.120 --> 08:45.220
调用回调函数之后

08:45.220 --> 08:47.920
我们再把什么timer设为什么now

08:48.220 --> 08:49.320
再把它设置为now

08:49.920 --> 08:51.020
那把这个计时器就没了

08:51.020 --> 08:51.420
对吧

08:51.420 --> 08:52.820
那下一次重新计时的时候

08:52.820 --> 08:53.320
是不是

08:54.620 --> 08:55.520
这个就不用清除了

08:55.520 --> 08:55.820
对不对

08:55.820 --> 08:56.720
就不用清除了

08:57.820 --> 08:58.620
或者说

08:59.320 --> 09:01.320
或者说我们这里就懒得判断了

09:01.320 --> 09:02.220
懒得判断了

09:02.520 --> 09:04.620
直接清除之前的计时

09:04.620 --> 09:05.120
对吧

09:05.120 --> 09:06.420
可不可以

09:06.720 --> 09:07.420
也可以

09:07.720 --> 09:08.520
保存看一下

09:09.120 --> 09:10.620
那现在我们写成这样子格式过后

09:10.620 --> 09:11.120
你看

09:12.320 --> 09:12.820
一个

09:13.620 --> 09:14.520
运行很多次

09:14.620 --> 09:15.920
你看是不是都不动了

09:16.320 --> 09:18.520
相当于是不停的电梯都有人进来

09:18.520 --> 09:19.920
那个电梯门是没法关的

09:19.920 --> 09:22.120
因为之前的计时器会不断的被清空

09:22.320 --> 09:23.520
不断的重新计时

09:23.620 --> 09:24.820
好等我们不动的时候

09:25.420 --> 09:26.620
你看是不是再出出一个

09:26.820 --> 09:27.220
对吧

09:27.420 --> 09:28.020
再来看

09:28.120 --> 09:28.620
再来看

09:29.420 --> 09:30.320
无论怎么变化

09:30.320 --> 09:31.020
怎么变化

09:31.420 --> 09:32.920
因为你触犯的太频繁了

09:32.920 --> 09:34.320
这个事件时间段内

09:34.320 --> 09:36.220
它不断的触发这个事件

09:36.220 --> 09:37.120
不断的调用这个函数

09:37.120 --> 09:39.020
那么之前的计时器不断的被清空

09:39.020 --> 09:39.620
于是呢

09:40.220 --> 09:41.220
就变成这个样子了

09:42.220 --> 09:42.820
没问题吧

09:43.220 --> 09:45.120
但是这样子写的有个坏处在于

09:45.120 --> 09:46.320
你污染了选举变量

09:46.720 --> 09:47.120
你看没有

09:47.120 --> 09:48.220
是不是污染了选举变量

09:49.520 --> 09:51.520
因为你这个东西写到外边去了

09:51.620 --> 09:52.420
那么导致

09:52.420 --> 09:53.820
那么其他地方如果再写一个

09:53.820 --> 09:56.320
檯面变量是不是就把它覆盖掉了

09:56.520 --> 09:57.020
对不对

09:57.220 --> 09:58.220
好那该怎么写了

09:58.820 --> 10:00.520
那这个东西能不能写里边的

10:00.820 --> 10:01.820
它又不能写里边

10:01.820 --> 10:03.020
为啥不能写里边的

10:03.020 --> 10:05.120
因为你写里边的话就意味着

10:05.420 --> 10:07.820
每一次函数调用是不是一个新的计时器

10:07.820 --> 10:08.320
对吧

10:08.320 --> 10:10.620
每一次函数调用都是一个新的计时器

10:10.620 --> 10:12.220
我们之前学过什么指行上下文

10:12.520 --> 10:14.120
每一次函数调用都是新的计时器

10:14.120 --> 10:15.720
所以说那又跟之前一样了

10:15.720 --> 10:16.120
你看看

10:16.420 --> 10:17.320
又跟之前一样了

10:18.320 --> 10:19.220
那也不行

10:19.220 --> 10:20.320
那这里怎么处理呢

10:21.320 --> 10:22.020
看着啊

10:22.120 --> 10:24.720
这里用一种非常神奇的处理方式

10:25.520 --> 10:26.120
return

10:26.620 --> 10:27.420
返回啥

10:27.520 --> 10:29.020
返回一个函数

10:29.420 --> 10:30.920
我给你返回一个函数

10:31.420 --> 10:34.320
我们之前学过那个作用预练的一块

10:34.320 --> 10:36.620
我们好像当时也讲到这么一个场景

10:36.920 --> 10:39.820
就是我们可以利用必包这种现象

10:40.420 --> 10:41.820
你调用这个函数的时候

10:41.820 --> 10:44.220
我给你返回的是一个新的函数

10:44.420 --> 10:46.720
你到时候去调用这个新的函数

10:46.920 --> 10:47.820
这样之一来了

10:47.820 --> 10:49.920
由于这个变量在函数里边定义的

10:49.920 --> 10:53.020
所以说他不会不会武断权局变量

10:53.720 --> 10:56.320
而且的这个函数本身的可以返回一个新的函数

10:56.420 --> 10:57.520
返回一个新的函数

10:57.620 --> 10:58.720
你将来用的时候呢

10:58.720 --> 10:59.820
去调用新的函数

10:59.920 --> 11:01.120
由于新的函数

11:01.520 --> 11:02.620
每次都会返

11:02.720 --> 11:03.520
就是每一

11:03.520 --> 11:04.820
他返回的是一个新的函数

11:04.920 --> 11:06.220
那么每一次调用新的函数

11:06.220 --> 11:07.420
用的是不是同一个台门

11:07.420 --> 11:07.920
对不对

11:08.320 --> 11:09.320
用的是外层的吗

11:09.320 --> 11:10.520
用的是同一个台门

11:10.720 --> 11:11.620
因此的这边呢

11:11.620 --> 11:13.320
他会要求你这样调用

11:13.820 --> 11:15.120
会要求你这样调用

11:16.320 --> 11:17.820
好这里写个Db

11:18.120 --> 11:18.920
写个Db

11:19.720 --> 11:20.320
那么这里呢

11:20.320 --> 11:21.320
他返回的是一个什么

11:21.320 --> 11:23.120
这个函数返回的是一个新的函数

11:24.420 --> 11:25.120
新的函数

11:25.220 --> 11:25.720
handle

11:25.720 --> 11:27.520
比方说一个处理函数

11:27.720 --> 11:29.720
好那么每一次事件运行的时候呢

11:29.720 --> 11:30.920
你去运行这个函数

11:31.820 --> 11:32.920
是这么个意思啊

11:33.620 --> 11:34.420
仔细看一下

11:34.420 --> 11:35.520
先把这个东西理解

11:35.720 --> 11:36.820
调用这个函数

11:37.020 --> 11:38.320
他只这个函数的作用

11:38.320 --> 11:40.420
只是给你给你创建了一个台门

11:40.620 --> 11:42.120
只是给你创建了这个台门

11:42.120 --> 11:43.720
然后会给你一个新的函数

11:43.720 --> 11:45.420
你用一个变量去接受一下

11:45.620 --> 11:46.220
那么到时候呢

11:46.220 --> 11:47.620
你去调用这个新的函数

11:47.720 --> 11:49.020
调用新的函数的时候

11:49.020 --> 11:50.820
才能才真正的去实现了这个效果

11:51.020 --> 11:52.620
才是真正的实现这个效果

11:52.820 --> 11:53.620
明白这个意思吧

11:54.320 --> 11:55.820
我们用这种方式来处理

11:56.220 --> 11:57.620
那么像这种啊

11:57.720 --> 12:00.720
在函数内部返回一个新的函数

12:00.720 --> 12:01.520
这种处理方式呢

12:01.520 --> 12:03.120
我们把它叫做高阶函数

12:04.320 --> 12:05.220
高阶函数

12:05.520 --> 12:08.120
就是在函数内部

12:08.220 --> 12:10.320
返回一个新的函数

12:10.320 --> 12:11.620
这叫做高阶函数

12:11.820 --> 12:13.120
其实高阶函数也没什么特别的

12:13.120 --> 12:14.820
因为我们知道函数是一等公铭

12:14.820 --> 12:15.220
对吧

12:15.220 --> 12:15.920
一等公铭

12:16.020 --> 12:18.120
所以说它可以作为返回至返回

12:18.520 --> 12:20.220
那么这里就反得到了一个新的函数

12:20.220 --> 12:22.220
那么我们这里每一次窗口改变

12:22.220 --> 12:23.620
去运行新的函数就可以了

12:23.620 --> 12:24.220
你看一下

12:24.220 --> 12:26.120
现在我们既没有污染权力变量

12:26.320 --> 12:27.020
并且呢

12:27.120 --> 12:28.320
也能实现同样的效果

12:30.480 --> 12:30.980
你看一下

12:31.180 --> 12:31.680
没触发吧

12:31.680 --> 12:32.480
没触发对吧

12:32.680 --> 12:33.780
停止触发

12:34.580 --> 12:35.280
没有触发

12:35.480 --> 12:35.980
停止

12:36.680 --> 12:37.180
触发

12:37.380 --> 12:37.780
对吧

12:38.280 --> 12:38.880
至于完事了

12:38.880 --> 12:39.480
对不对

12:39.880 --> 12:41.180
这就是一个函数防斗

12:41.480 --> 12:41.980
再看一下

12:41.980 --> 12:43.480
再再再来处理一下啊

12:43.480 --> 12:44.880
咱们调用地棒式

12:45.280 --> 12:46.380
它的目的呢

12:46.780 --> 12:47.980
不是说啊

12:47.980 --> 12:50.180
不是说我来给你处理防斗

12:50.380 --> 12:52.480
而是我只是给你开启一个计时器

12:53.780 --> 12:55.980
边于后边的函数函数使用

12:56.480 --> 12:58.180
那么会给你返回一个新的函数

12:58.180 --> 12:59.180
你需要去接收

12:59.380 --> 13:01.280
那么你后边每一次调用的是啥

13:01.380 --> 13:03.080
每一次调用的是这个新的函数

13:03.180 --> 13:04.680
那么这个新的函数里边是不是用的是

13:04.680 --> 13:05.480
就是这个timer

13:05.480 --> 13:05.780
对不对

13:05.780 --> 13:07.280
它就没有污染权力变量了

13:08.680 --> 13:09.680
但写完了吗

13:10.480 --> 13:12.180
其实还没没太写完

13:12.380 --> 13:13.080
没有写完

13:13.480 --> 13:14.680
为什么还没有写完了

13:14.680 --> 13:17.280
因为我还没有考虑到参数的情况

13:17.880 --> 13:19.080
那比方说啊

13:19.280 --> 13:21.380
窗口每一次改变的时候

13:21.480 --> 13:24.080
我要输出当前窗口的值

13:24.480 --> 13:27.280
我要输出当前改变之后窗口的值

13:27.280 --> 13:28.280
那我调用这个函数

13:28.280 --> 13:29.680
是不是要传参数进去啊

13:30.280 --> 13:31.280
是不是要传参数啊

13:31.580 --> 13:32.680
我调用这个函数的时候

13:32.680 --> 13:35.080
是不是要传一个参数进去

13:35.380 --> 13:35.880
对吧

13:35.880 --> 13:37.280
要传一个参数进去

13:38.280 --> 13:38.980
所以说呢

13:39.080 --> 13:41.480
我们这里呢需要传递参数进来

13:41.780 --> 13:43.080
需要传递参数进来

13:43.380 --> 13:43.680
好

13:43.680 --> 13:44.680
这个参数呢

13:46.080 --> 13:47.380
我们比方说吧

13:47.580 --> 13:49.980
传一个窗口的四口的大小嘛

13:49.980 --> 13:51.380
document document

13:51.480 --> 13:53.280
animate client weight

13:53.880 --> 13:54.880
窗口的宽度

13:55.180 --> 13:56.780
我们可能要输出窗口的宽度

13:56.780 --> 13:57.680
要达到一些东西

13:57.680 --> 13:58.080
对吧

13:58.080 --> 13:58.980
可能有一个参数

13:58.980 --> 13:59.780
可能有两个参数

13:59.780 --> 14:00.880
可能有多个参数

14:00.980 --> 14:02.280
你说不准有几个参数

14:02.880 --> 14:03.980
然后另外一边

14:03.980 --> 14:05.180
那就是我们的处理函数

14:05.180 --> 14:06.580
这是我们最终的处理函数

14:06.580 --> 14:06.980
对吧

14:06.980 --> 14:09.280
在一开始就定义好的最终的处理函数

14:09.380 --> 14:11.180
这里的处理函数是不是可以接受参数了

14:11.180 --> 14:11.680
对吧

14:11.980 --> 14:13.580
我们这里呢把宽度值输出

14:13.780 --> 14:14.980
你看一下现在能输出吗

14:15.780 --> 14:17.180
我就是这里的调用的时候

14:17.180 --> 14:18.380
来把参数传进去

14:18.480 --> 14:19.080
传到谁呢

14:19.080 --> 14:19.880
传到这来

14:19.880 --> 14:20.380
对吧

14:21.080 --> 14:22.680
那么我们的处理函数里边

14:22.680 --> 14:24.480
就需要能够接受这个参数

14:24.480 --> 14:25.680
能够进行处理

14:25.680 --> 14:26.480
处理

14:26.680 --> 14:27.680
保存我们看一下

14:29.080 --> 14:29.780
那么这个时候呢

14:29.780 --> 14:30.580
我们看一下

14:31.080 --> 14:32.880
能输出这个宽度吗

14:33.280 --> 14:34.280
为什么不能输出

14:34.280 --> 14:35.080
为什么没有扬底范

14:35.080 --> 14:36.480
我这里不是传进去了嘛

14:36.780 --> 14:37.780
但是你要注意啊

14:37.780 --> 14:39.580
我这里参数是传给谁的

14:39.680 --> 14:41.280
是传给这个函数的

14:41.580 --> 14:43.280
是把参数传给这个函数的

14:43.880 --> 14:44.880
有没有传给他呀

14:44.880 --> 14:45.780
他才是

14:45.880 --> 14:47.280
他这个callback

14:47.380 --> 14:48.680
才是这里的函数对吧

14:49.080 --> 14:50.480
一开始调用debounce的时候

14:50.480 --> 14:51.680
把这个callback传进去了

14:52.280 --> 14:53.480
这个callback才是

14:53.580 --> 14:55.480
才是我们这里的函数

14:55.780 --> 14:56.880
对应到这里的函数

14:57.080 --> 14:58.780
那么我们调用callback的时候

14:58.780 --> 14:59.680
有没有传参数

14:59.880 --> 15:01.080
是不是没有传参数

15:01.680 --> 15:02.980
那么这个时候怎么办了

15:03.580 --> 15:04.480
这个时候咋办了

15:04.880 --> 15:05.480
咋办

15:06.080 --> 15:08.280
我们怎么样把这个函数的参数

15:08.280 --> 15:09.080
传到这边来

15:09.080 --> 15:10.280
有人说那简单呀

15:10.280 --> 15:11.480
这里写个宽度吧

15:11.580 --> 15:13.180
那么我们把这个宽度传进来

15:13.280 --> 15:15.280
但是你只考虑到这一个参数的情况

15:15.380 --> 15:16.580
那如果他没有参数呢

15:16.580 --> 15:17.580
如果他是三个参数呢

15:17.580 --> 15:18.280
四个参数呢

15:18.280 --> 15:19.080
十个参数呢

15:19.380 --> 15:20.580
那你怎么怎么写呢

15:20.780 --> 15:21.580
你没法写

15:22.180 --> 15:22.780
所以说这里呢

15:22.780 --> 15:23.980
我们可以用这种方式看着

15:25.580 --> 15:26.580
在函数里边

15:26.580 --> 15:27.880
我们之前不是讲过一个东西吗

15:27.880 --> 15:28.980
叫做argument

15:28.980 --> 15:29.480
对吧

15:30.180 --> 15:31.280
他是不是参数

15:31.980 --> 15:32.780
你告诉我

15:32.780 --> 15:33.680
他是不是参数

15:34.380 --> 15:35.380
他是不是就是参数

15:35.380 --> 15:35.880
对不对

15:35.980 --> 15:37.480
argument是不是就是参数

15:38.180 --> 15:39.280
那么到时候呢

15:39.280 --> 15:40.880
我这样子来调用

15:41.180 --> 15:42.580
看着啊callback

15:43.380 --> 15:45.080
不是由于每一个函数

15:45.080 --> 15:45.780
这是个函数吗

15:45.780 --> 15:46.680
callback肯定是个函数

15:46.680 --> 15:47.080
对不对

15:47.380 --> 15:48.380
callback每一个函数

15:48.380 --> 15:49.180
不是有一个方法吗

15:49.180 --> 15:49.980
叫做apply

15:50.480 --> 15:51.080
apply

15:51.580 --> 15:52.180
apply方法

15:52.180 --> 15:53.480
他可以绑定Z是对吧

15:53.480 --> 15:54.280
可以绑定Z是

15:54.280 --> 15:55.680
那这里Z是没啥好绑定的

15:55.680 --> 15:56.480
刚才传个LOL

15:56.780 --> 15:57.680
没有什么Z是

15:58.080 --> 15:59.480
主要是后边的参数

15:59.580 --> 16:00.680
参数是不是个数组

16:01.080 --> 16:01.480
对不对

16:01.480 --> 16:03.080
apply里边是传参数的时候

16:03.080 --> 16:04.080
传一个数组进来

16:04.280 --> 16:04.380
好

16:04.380 --> 16:05.680
那么这个地方是伪数组

16:05.680 --> 16:06.380
是不是个传进来

16:07.080 --> 16:08.480
但是你能这样子写吗

16:08.480 --> 16:09.580
你也不能这样子写

16:09.580 --> 16:10.180
为啥呢

16:10.180 --> 16:10.980
你这样写的话

16:10.980 --> 16:12.980
这个argument是在这个函数里边

16:13.980 --> 16:14.480
没问题吧

16:14.480 --> 16:15.780
是在这个函数里边

16:16.080 --> 16:16.980
因此呢

16:17.380 --> 16:19.280
你这个argument代表的是这个函数的传输

16:19.280 --> 16:20.280
这个函数哪有传输

16:20.580 --> 16:21.180
没有传输

16:21.580 --> 16:22.180
所以说呢

16:22.180 --> 16:23.580
你得在之前呢

16:23.580 --> 16:25.380
把它保留到一个变量里边

16:25.580 --> 16:26.280
arguess

16:26.680 --> 16:27.780
保留到一个变量里边

16:28.680 --> 16:30.180
把这个argument保留到一个变量里边

16:30.180 --> 16:31.580
这是不是利用必包

16:31.680 --> 16:32.180
对不对

16:32.480 --> 16:33.480
这个函数运行的时候

16:33.480 --> 16:35.180
它可以访问外层的变量

16:35.880 --> 16:36.080
好

16:36.080 --> 16:38.480
这里是利用必包

16:39.280 --> 16:40.080
保存

16:40.880 --> 16:41.480
参数

16:41.880 --> 16:42.780
参数数组

16:42.880 --> 16:43.880
这是个伪数组

16:44.080 --> 16:45.480
然后把这个参数传进来

16:45.980 --> 16:46.380
对吧

16:46.380 --> 16:47.580
是不是把参数传进来了

16:47.880 --> 16:48.280
这样子呢

16:48.280 --> 16:49.880
就把这个函数的参数

16:50.080 --> 16:51.480
带到了这个函数

16:52.280 --> 16:52.680
看到没

16:52.880 --> 16:53.080
好

16:53.080 --> 16:53.480
保存

16:53.580 --> 16:54.280
我们来看一下

16:55.080 --> 16:55.680
运行

16:56.280 --> 16:57.080
看一下参数

16:57.580 --> 16:58.480
说出来了参数

16:58.480 --> 16:58.880
对吧

16:58.880 --> 16:59.480
运行

17:00.680 --> 17:01.680
出来了对吧

17:01.880 --> 17:02.280
这样子呢

17:02.280 --> 17:03.780
我们就可以传递参数了

17:04.380 --> 17:05.080
没问题吧

17:05.980 --> 17:06.480
哎

17:06.580 --> 17:07.380
就行了对吧

17:08.380 --> 17:08.680
好

17:08.680 --> 17:09.780
那么接下来呢

17:09.880 --> 17:10.980
还有一个问题

17:11.580 --> 17:13.380
就是关于Z

17:13.880 --> 17:16.180
Z是关于Z时的绑定

17:16.480 --> 17:17.780
关于Z时的绑定

17:17.980 --> 17:18.480
然后这里呢

17:18.480 --> 17:19.580
我们没有绑定Z时

17:19.580 --> 17:19.880
对吧

17:19.980 --> 17:21.180
没有绑定Z时

17:21.380 --> 17:21.680
好

17:21.680 --> 17:22.980
那么这个时候呢

17:23.880 --> 17:24.980
Z时这一块呢

17:24.980 --> 17:26.380
我们这里就不处理了

17:26.380 --> 17:27.080
这里不处理的

17:27.080 --> 17:28.080
因为我们直接传到

17:28.280 --> 17:29.480
Z时的让外面处理

17:29.580 --> 17:30.580
你要绑定Z时的话

17:30.580 --> 17:31.280
利用band

17:31.280 --> 17:31.480
对吧

17:31.480 --> 17:32.380
我们之前学过

17:32.680 --> 17:34.080
比方说这是一个函数

17:34.180 --> 17:34.980
这是一个函数

17:35.380 --> 17:36.980
比方说我们这里是funk

17:37.480 --> 17:38.280
这是个函数

17:38.580 --> 17:40.080
利用这个函数不是有个band吗

17:40.080 --> 17:40.380
对吧

17:40.380 --> 17:40.880
band

17:40.880 --> 17:42.080
去自己去绑定Z时

17:42.080 --> 17:43.280
比方说绑定window

17:44.480 --> 17:45.280
然后这里传

17:45.280 --> 17:46.680
传这个funk进去

17:46.980 --> 17:47.380
对吧

17:48.380 --> 17:49.380
传这个funk进去

17:51.080 --> 17:51.880
是这么回事啊

17:51.880 --> 17:52.580
这么回事

17:53.480 --> 17:55.080
这是关于Z时

17:55.080 --> 17:56.880
Z时我们就让它在外面处理

17:57.680 --> 17:58.880
这就是一个函数方的

17:59.080 --> 17:59.580
看没

18:00.580 --> 18:01.380
好好再看一下啊

18:01.380 --> 18:02.480
好好再看一下这个代码

18:02.480 --> 18:02.980
这个代码呢

18:02.980 --> 18:03.880
有点糟啊

18:03.880 --> 18:05.280
你不太理得清楚

18:05.280 --> 18:07.280
首先说为什么要写这个反回一个函数

18:07.280 --> 18:09.580
因为我要处理这个权距变量污染的问题

18:09.580 --> 18:10.480
我要处理timer

18:10.480 --> 18:11.680
所以我得反回一个函数

18:11.980 --> 18:13.580
好我怎么来处理参数

18:13.580 --> 18:16.480
我这边写参数的时候呢

18:16.480 --> 18:17.580
把参数传给了谁

18:17.580 --> 18:18.680
传给了这个函数

18:18.680 --> 18:20.780
于是我把参数的保存到这个数组里面

18:20.780 --> 18:22.180
保存了这个变量里面

18:22.180 --> 18:22.580
因此呢

18:22.580 --> 18:24.180
我当时调用这个回调函数的时候

18:24.180 --> 18:25.580
把参数给它传进来就完事了

18:26.580 --> 18:26.780
好吧

18:26.780 --> 18:28.180
这是一个函数防斗啊

18:28.180 --> 18:29.580
我们来看一下函数防斗

18:29.580 --> 18:31.880
不仅是可以在什么resize里面使用

18:31.880 --> 18:33.980
还有可以在很多地方比方说input

18:35.080 --> 18:35.980
一个文本花

18:36.980 --> 18:37.980
文本框里面

18:40.780 --> 18:41.880
给文本框注册事件

18:42.280 --> 18:42.880
注册事件

18:43.680 --> 18:46.180
input document query signature

18:46.880 --> 18:47.880
然后input

18:48.280 --> 18:49.080
给它注册什么

18:49.080 --> 18:49.880
input事件

18:50.080 --> 18:50.880
input事件

18:51.280 --> 18:51.980
比方说

18:52.280 --> 18:54.680
当它文本改变的时候

18:54.680 --> 18:55.680
我要去搜索

18:55.680 --> 18:57.680
我要去对这个文本框进行搜索

18:58.180 --> 18:59.480
好怎么来搜索呢

18:59.880 --> 19:02.080
由于它文本框打字的速度太快了

19:02.080 --> 19:03.880
我要等它打停了之后再搜索

19:03.880 --> 19:04.880
再进行搜索

19:04.980 --> 19:06.380
我们就可以利用函数防斗

19:08.180 --> 19:10.580
我们先把我们要做的事情规定好

19:10.780 --> 19:12.580
myplugin debunk

19:13.580 --> 19:14.780
我们要做什么事呢

19:14.980 --> 19:16.580
我们要得到文本框的纸

19:16.580 --> 19:16.980
对不对

19:16.980 --> 19:18.280
得到文本框的纸

19:18.980 --> 19:19.580
然后呢

19:19.980 --> 19:20.380
但是呢

19:20.380 --> 19:22.080
要在500毫秒之后

19:22.080 --> 19:23.180
我再去进行搜索

19:24.080 --> 19:24.880
或者是一秒钟

19:24.880 --> 19:25.280
一秒钟

19:25.280 --> 19:26.380
大家看得清楚一点

19:26.580 --> 19:28.080
一秒钟之后再进行搜索

19:28.080 --> 19:28.180
好

19:28.180 --> 19:28.480
这里呢

19:28.480 --> 19:29.180
我们输出

19:29.780 --> 19:30.380
输出

19:30.380 --> 19:31.580
搜索

19:32.680 --> 19:33.280
搜索啥呢

19:33.280 --> 19:34.080
搜索这个

19:35.080 --> 19:36.080
搜索这个发

19:36.080 --> 19:37.080
搜索这个关键字

19:37.880 --> 19:37.980
好

19:37.980 --> 19:38.580
那这里边呢

19:38.580 --> 19:39.580
我们就这样子写

19:39.580 --> 19:40.680
这里会得到一个函数

19:40.680 --> 19:41.080
对不对

19:41.080 --> 19:42.080
得到一个函数

19:42.480 --> 19:42.580
好

19:42.580 --> 19:43.080
我们这里

19:43.080 --> 19:43.980
这里就这样子写

19:43.980 --> 19:44.780
每一次

19:45.580 --> 19:46.180
每一次

19:46.180 --> 19:47.180
就是文本框

19:47.180 --> 19:48.280
文本改变的时候呢

19:48.280 --> 19:49.180
运行这个函数

19:49.180 --> 19:50.880
然后把文本框的纸传进去

19:51.080 --> 19:51.880
this value

19:52.680 --> 19:53.980
把文本框的纸传进去

19:54.780 --> 19:55.380
没问题吧

19:55.680 --> 19:56.080
保存

19:56.080 --> 19:56.880
我们再看一下

19:57.880 --> 19:58.080
好

19:58.080 --> 19:58.680
接下来我们打印

19:58.680 --> 19:59.280
看打打

19:59.480 --> 20:00.280
是不是没有触发

20:00.280 --> 20:00.680
对吧

20:00.680 --> 20:01.680
不是没有触发

20:01.680 --> 20:02.780
事件肯定是触发的

20:02.780 --> 20:03.980
但是这个函数没有运行

20:04.080 --> 20:05.680
因为它不断的清空计时器了

20:05.880 --> 20:07.480
我们写到停了

20:07.680 --> 20:08.080
不动了

20:08.080 --> 20:08.480
你看

20:08.680 --> 20:09.780
才进行搜索

20:09.880 --> 20:12.080
那么就是类似于百度这里的效果

20:12.280 --> 20:12.580
对吧

20:12.580 --> 20:13.980
就类似于它这里的效果了

20:14.880 --> 20:15.080
好

20:15.080 --> 20:16.080
然后我们继续写

20:16.080 --> 20:16.680
继续写

20:16.980 --> 20:17.080
好

20:17.080 --> 20:17.680
继续写

20:18.180 --> 20:18.280
好

20:18.280 --> 20:19.380
你看是不是运行了

20:20.580 --> 20:21.280
没问题吧

20:21.580 --> 20:22.280
没问题吧

20:23.280 --> 20:23.480
好

20:23.480 --> 20:24.080
就这一块

20:24.180 --> 20:24.880
就这一块

20:25.880 --> 20:26.080
好

20:26.080 --> 20:27.080
另外呢

20:27.080 --> 20:29.080
就是说如果你一定要

20:29.480 --> 20:30.980
你一定要解决

20:31.180 --> 20:32.480
这个z的问题

20:32.480 --> 20:33.280
比方说你像在这里

20:33.280 --> 20:34.180
不要应用z

20:34.380 --> 20:36.380
你一定一定想解决这个问题的话

20:36.480 --> 20:37.580
那么你可以

20:37.580 --> 20:38.580
那可以进一步处理

20:38.580 --> 20:39.780
就看你具体的情况

20:39.780 --> 20:41.280
这个函数反正已经写好了

20:41.280 --> 20:42.380
你要考虑z的话

20:42.380 --> 20:44.480
你就自己自行进行处理

20:44.580 --> 20:45.280
那怎么处理呢

20:45.280 --> 20:46.780
比方说我们这里呢

20:46.980 --> 20:47.980
比方说规定

20:48.280 --> 20:48.880
约定

20:48.980 --> 20:51.080
约定最后一个参数为z的值

20:51.580 --> 20:52.080
保利啥

20:52.080 --> 20:52.780
保利z

20:53.680 --> 20:54.880
那现在看一下这边

20:54.880 --> 20:57.380
这边输出z

20:57.380 --> 20:57.980
看一下

20:58.480 --> 20:58.980
看一下

20:59.180 --> 21:00.180
这边输出z

21:01.080 --> 21:02.080
他输出的是Angdi犯

21:02.080 --> 21:02.480
对吧

21:02.980 --> 21:03.980
输出的是window

21:03.980 --> 21:04.780
权具调用的

21:04.780 --> 21:05.080
对不对

21:05.080 --> 21:05.880
权具调用的

21:05.980 --> 21:06.980
输出的是window

21:07.280 --> 21:10.280
那么如果你真的想要绑定z的话

21:10.280 --> 21:11.780
那么我们可以规定

21:11.780 --> 21:13.480
这个函数的最后一个参数

21:13.780 --> 21:15.280
这个函数的最后一个参数

21:15.280 --> 21:16.680
为绑定的z是值

21:17.380 --> 21:19.080
最后参数为绑定的z是值

21:19.180 --> 21:20.280
那么这个z呢

21:20.680 --> 21:21.880
我们怎么来写呢

21:22.080 --> 21:22.880
怎么来写呢

21:23.580 --> 21:25.680
我们这里就可以利用这种方式

21:25.780 --> 21:26.680
利用这种方式

21:26.880 --> 21:28.580
就是把这一块

21:28.880 --> 21:29.680
就这个东西

21:29.780 --> 21:30.880
最后一个参数拿出来

21:30.880 --> 21:31.880
作为z是值

21:31.980 --> 21:34.180
然后前边的作为数组

21:34.280 --> 21:36.180
我们就可以用这种方式来进行处理

21:36.480 --> 21:37.980
当然要进行各种判断

21:38.080 --> 21:39.280
要进行各种判断

21:39.580 --> 21:40.680
其实呢你这样子写

21:40.680 --> 21:42.480
你还不如写啥呢

21:42.480 --> 21:43.480
传两个参数

21:43.680 --> 21:44.780
一个就是z的指向

21:44.780 --> 21:46.580
z的指向不就是一个对象

21:46.580 --> 21:47.080
对不对

21:47.080 --> 21:48.580
好那这边来接收吧

21:48.880 --> 21:49.680
是不是来接收

21:49.680 --> 21:50.180
对不对

21:50.480 --> 21:51.880
z不就是事件员吗

21:51.880 --> 21:52.380
对不对

21:52.580 --> 21:53.880
这边就不用z了

21:53.880 --> 21:54.980
就直接来接收

21:55.080 --> 21:55.880
接收这个对象

21:55.880 --> 21:57.180
是不是可以达到一样的效果

21:57.280 --> 21:58.780
这样子写反而方便一点

21:58.980 --> 22:00.080
我这里习惯上

22:00.080 --> 22:01.480
把函数防到的z

22:01.480 --> 22:02.680
对z的处理呢

22:02.680 --> 22:04.280
习惯上的就是用到

22:04.780 --> 22:06.680
用到就是外面调用者来决定

22:06.880 --> 22:07.280
我不用

22:07.280 --> 22:08.480
我不在这里边处理

22:08.780 --> 22:09.080
对吧

22:09.080 --> 22:10.880
我们可以用这种传统的方式

22:10.880 --> 22:11.980
也可以轻松搞定

22:12.680 --> 22:14.680
就避免了证明这里边在码写的很复杂

22:14.680 --> 22:15.380
当然能不能写

22:15.380 --> 22:16.180
肯定可以写

22:17.180 --> 22:17.380
好

22:17.380 --> 22:18.880
这是关于函数防斗

22:18.880 --> 22:19.780
函数防斗

22:20.580 --> 22:22.880
好另外一个呢是函数截流

22:23.380 --> 22:24.480
函数截流呢

22:24.480 --> 22:26.980
跟函数防斗是非常非常类似的

22:27.380 --> 22:28.580
函数防斗是什么

22:28.580 --> 22:30.080
启动一个计时器对吧

22:30.180 --> 22:31.380
在多少时间之后

22:31.480 --> 22:33.480
我们来进行来运行

22:33.780 --> 22:34.780
它是这么一个意思

22:35.080 --> 22:36.980
而函数截流是什么意思呢

22:37.080 --> 22:39.580
函数截流是某一个时间

22:39.680 --> 22:41.180
它只执行一次

22:41.380 --> 22:42.580
它不会重新计时

22:42.780 --> 22:43.880
不会重新计时

22:43.880 --> 22:45.980
它只是保证执行一次

22:47.180 --> 22:49.380
保证一个时间段内

22:50.080 --> 22:52.480
一个时间段内执行一次

22:54.280 --> 22:55.080
执行一次

22:56.080 --> 22:56.480
好

22:56.480 --> 22:57.480
那比方说

22:57.480 --> 22:59.780
比方说我们这里有一个函数

23:00.780 --> 23:01.780
有一个函数

23:02.280 --> 23:03.080
test

23:05.980 --> 23:06.580
log

23:08.280 --> 23:09.280
就随便写个函数

23:09.680 --> 23:11.980
那比方说我要用函数截流来做的话

23:11.980 --> 23:13.080
我们可以用这种方式

23:13.080 --> 23:14.380
比方说myplunging里边

23:14.380 --> 23:15.580
我们这里还没有引用

23:16.980 --> 23:17.880
src

23:21.550 --> 23:22.250
carefus

23:23.250 --> 23:24.650
好 myplunging里边

23:25.650 --> 23:27.150
它里边有一个函数截流

23:27.150 --> 23:27.350
对吧

23:27.350 --> 23:30.150
叫做srotor

23:31.050 --> 23:31.750
叫这个单词

23:31.750 --> 23:32.450
我写对没有

23:33.850 --> 23:34.350
srotor

23:34.350 --> 23:34.750
对了

23:36.050 --> 23:37.250
那么它有这么一个东西

23:37.250 --> 23:40.450
那么用法跟函数防抖是一样的

23:40.550 --> 23:41.450
一样的用法

23:41.850 --> 23:43.250
就是我给你订个函数

23:43.250 --> 23:43.550
对吧

23:43.550 --> 23:44.350
订个函数

23:44.450 --> 23:45.350
多少时间段内

23:45.350 --> 23:46.550
比方说1000毫秒内

23:46.550 --> 23:47.650
就是一秒钟之内

23:47.750 --> 23:49.450
这个函数只能执行一次

23:49.450 --> 23:50.150
只能执行一次

23:50.150 --> 23:51.750
或者我直接把这个函数传过来

23:51.950 --> 23:53.250
把这个test的函数传过来

23:53.850 --> 23:55.650
一秒钟之内只能执行一次

23:55.650 --> 23:56.950
本贯里调用多少次

23:56.950 --> 23:58.850
它返回的也是一个函数

23:59.150 --> 24:00.450
它返回的也是一个函数

24:00.550 --> 24:02.350
本贯里这个函数调用多少次

24:02.350 --> 24:03.850
你调用1000次1万次

24:03.850 --> 24:04.950
只要在这个时间段内

24:04.950 --> 24:06.150
我都不做任何处理

24:06.150 --> 24:07.250
不做任何处理

24:07.250 --> 24:08.350
只要这个时间没到

24:09.050 --> 24:09.950
我都不做任何处理

24:09.950 --> 24:10.950
是这么个意思

24:11.350 --> 24:12.150
这么个意思

24:13.050 --> 24:15.250
这里的函数函流

24:15.250 --> 24:16.750
它有两种做法

24:16.850 --> 24:18.450
一种做法跟函数防抖一样

24:18.450 --> 24:20.750
就是我等一秒钟之后再去执行

24:21.450 --> 24:22.450
如果这一秒钟之内

24:22.450 --> 24:23.750
来了新的东西的话

24:24.550 --> 24:26.550
我不像函数防抖那样子

24:26.550 --> 24:27.450
给你重新计时

24:27.450 --> 24:28.550
我不会重新计时

24:29.050 --> 24:30.850
不会影响目前的防

24:30.850 --> 24:31.750
目前的结果

24:32.450 --> 24:33.950
然后我还是之前的一秒钟

24:33.950 --> 24:34.750
还是继续等

24:35.250 --> 24:36.150
它是这种写法

24:36.150 --> 24:36.950
这种写法

24:38.150 --> 24:39.550
那么还有另外一种写法

24:39.550 --> 24:40.450
是立即执行

24:41.050 --> 24:42.250
只不过了下一次执行的

24:42.250 --> 24:43.150
要等一段时间

24:43.150 --> 24:44.950
我们两种写法都写一遍

24:45.150 --> 24:45.850
都写一遍

24:46.450 --> 24:47.750
我们先看第一种写法

24:48.350 --> 24:48.950
第一种写法

24:48.950 --> 24:50.150
我们这里要定一个

24:50.850 --> 24:51.550
定一个函数

24:51.550 --> 24:52.650
Z is myplunging

24:53.350 --> 24:54.150
叫做soto

24:58.260 --> 24:58.960
soto怎么意思呢

24:58.960 --> 25:00.760
这个函数相当于是

25:00.760 --> 25:02.760
咱们家里面的水管一个

25:02.960 --> 25:03.760
发对吧

25:03.760 --> 25:04.260
发

25:04.260 --> 25:05.960
然后把那个发关紧一点

25:05.960 --> 25:07.960
那么水流就变得小一点了

25:07.960 --> 25:09.660
就像水龙头刊棺一样

25:09.660 --> 25:11.460
把它稍微动一下

25:11.460 --> 25:13.160
水的水流就很小

25:13.160 --> 25:15.260
就是不要让函数执行的那么平准

25:15.260 --> 25:17.160
函就是函数截流

25:18.460 --> 25:19.860
这里也一样的

25:19.860 --> 25:20.960
它的格式是一样的

25:20.960 --> 25:24.560
碳多少时间内进行执行

25:24.560 --> 25:26.360
这是函数截流

25:27.260 --> 25:28.260
看一下函数截流

25:29.060 --> 25:29.760
函数截流

25:29.760 --> 25:30.860
它这里有两种做法

25:30.860 --> 25:31.960
我们先说第一种做法

25:31.960 --> 25:34.160
第一种做法跟函数的防抖是差不多的

25:34.160 --> 25:35.160
我们直接复制过来

25:35.960 --> 25:37.360
有一点点区别

25:37.360 --> 25:38.060
什么区别呢

25:38.060 --> 25:38.460
就这

25:39.560 --> 25:42.360
如果发现当前已经有计时了

25:42.960 --> 25:44.060
已经有计时了

25:44.060 --> 25:45.160
我啥都不做

25:45.860 --> 25:46.660
啥都不做

25:47.160 --> 25:48.160
你想做事没门

25:48.160 --> 25:50.060
因为之前还有计时

25:50.060 --> 25:50.260
对吧

25:50.260 --> 25:51.760
跟那个函数防抖也不太一样了

25:51.760 --> 25:52.960
就是这个地方不太一样

25:52.960 --> 25:54.060
函数防抖是

25:54.060 --> 25:54.860
之前有计时

25:54.860 --> 25:56.060
直接清空重新计时

25:56.060 --> 25:57.760
那这里不会重新计时

25:57.760 --> 25:59.760
你只要有计时期

25:59.760 --> 26:01.160
我就给你直接结束

26:01.260 --> 26:02.360
就给你直接结束

26:02.360 --> 26:03.260
不做任何事情

26:04.060 --> 26:05.260
只要有计时期

26:05.260 --> 26:07.560
除非你没有计时期的情况下

26:07.560 --> 26:10.260
我才给你去设置一个计时期

26:10.260 --> 26:11.660
然后等待一段时间

26:11.660 --> 26:12.460
等待一段时间

26:12.460 --> 26:13.260
然后呢

26:13.260 --> 26:14.160
这里去执行

26:14.160 --> 26:14.760
执行完了过后

26:14.760 --> 26:17.260
你要记住函数截流的时候

26:17.260 --> 26:18.660
你得把计时期清空

26:18.660 --> 26:19.660
你不清空的话

26:19.660 --> 26:21.460
以后就永远执行不了了

26:21.460 --> 26:22.260
永远执行不了了

26:22.260 --> 26:23.760
因为它发现有计时期存在

26:23.760 --> 26:25.560
你得把自己的计时期清空

26:25.560 --> 26:26.760
保证没有计时期了

26:26.760 --> 26:28.260
就是下一次那就没有计时期了

26:28.260 --> 26:28.660
对吧

26:28.660 --> 26:29.960
下一次就没有计时期了

26:29.960 --> 26:30.960
然后呢

26:30.960 --> 26:31.960
变成这个样子了

26:33.060 --> 26:33.260
好

26:33.260 --> 26:34.560
接下来我们来看一下

26:34.560 --> 26:35.660
函数截流

26:35.660 --> 26:37.260
它是一个什么样的场景

26:38.860 --> 26:40.060
我们这里一秒钟

26:40.060 --> 26:40.760
一秒钟

26:41.760 --> 26:42.460
看着啊

26:43.260 --> 26:44.260
我们这里不是一个handle吗

26:44.260 --> 26:44.860
对吧

26:44.860 --> 26:45.760
调用这个handle

26:50.340 --> 26:51.340
看着啊

26:51.340 --> 26:51.940
调用handle

26:51.940 --> 26:52.540
接着handle

26:52.540 --> 26:53.240
哎哎哎

26:54.340 --> 26:54.740
这样子

26:54.740 --> 26:55.240
这样子

26:55.240 --> 26:56.640
我还在这里写吧

26:57.340 --> 26:58.640
这里运行到这么多次的handle

26:58.640 --> 26:59.240
你看一下

27:00.240 --> 27:00.940
这是啥

27:01.840 --> 27:02.940
我是上级课的

27:02.940 --> 27:03.740
上级课的

27:04.240 --> 27:04.540
好

27:04.540 --> 27:05.340
我们刷新一下

27:06.440 --> 27:07.640
是不是只运行了一次

27:07.640 --> 27:07.940
对吧

27:07.940 --> 27:08.940
只运行了一次

27:08.940 --> 27:10.640
它在一秒钟之后

27:10.640 --> 27:11.640
运行了一次

27:11.640 --> 27:12.740
运行了一次

27:12.740 --> 27:12.940
好

27:12.940 --> 27:13.540
咱们看一下

27:13.540 --> 27:15.740
函数截流跟函数防斗有什么区别

27:15.740 --> 27:16.140
好

27:16.140 --> 27:16.440
咱们呢

27:16.440 --> 27:17.340
就是根据

27:17.340 --> 27:18.740
到时候里面做

27:18.740 --> 27:20.140
到时候做项目啊

27:20.140 --> 27:21.340
做效果的时候呢

27:21.340 --> 27:22.840
根据具体的情况

27:22.840 --> 27:24.040
来进行选择

27:24.040 --> 27:25.440
比方说这里window

27:25.440 --> 27:26.140
on

27:26.140 --> 27:26.940
resize

27:27.640 --> 27:28.740
还是用这个

27:28.740 --> 27:29.940
这个事件

27:29.940 --> 27:32.040
当窗口发生改变的时候的事件

27:32.040 --> 27:33.340
那么我们这里呢

27:33.340 --> 27:33.940
看一下吧

27:33.940 --> 27:34.740
我们调用啥

27:34.740 --> 27:36.140
调用handle

27:36.140 --> 27:36.940
调用handle

27:37.640 --> 27:37.940
好

27:37.940 --> 27:38.740
保存看一下吧

27:39.640 --> 27:39.840
好

27:39.840 --> 27:40.440
你看运行了

27:40.440 --> 27:41.040
对吧

27:41.040 --> 27:41.740
运行了

27:41.740 --> 27:43.140
窗口改变的事件运行了

27:43.140 --> 27:43.340
好

27:43.340 --> 27:44.940
现在我们改变窗口

27:44.940 --> 27:45.740
你是不是看

27:45.740 --> 27:46.740
是不是固定在运行

27:46.740 --> 27:47.340
对吧

27:47.340 --> 27:48.940
你如果一直触发时间的话

27:48.940 --> 27:50.440
它是固定频率运行

27:50.440 --> 27:51.740
如果是函数防斗的话

27:51.740 --> 27:52.640
它就不是固定的

27:52.640 --> 27:54.440
它就一定要等到你完了之后

27:54.440 --> 27:56.540
因为它每次在重新计时

27:56.540 --> 27:57.940
它一定要等到完了之后呢

27:57.940 --> 27:58.940
在运行

27:58.940 --> 27:59.440
看没有

28:00.340 --> 28:01.540
你不动的时候

28:01.540 --> 28:02.340
它就运行完了

28:03.240 --> 28:04.240
这就是函数节流

28:04.240 --> 28:05.540
跟函数防斗的区别

28:05.540 --> 28:07.640
如果你将来要处理一些问题

28:07.640 --> 28:11.040
一定至少得每隔一段时间去执行一次

28:11.040 --> 28:12.340
不管它事件

28:12.340 --> 28:14.140
事件如果再触发的非常非常频繁

28:14.140 --> 28:15.940
你不是说等它触发完了在运行

28:15.940 --> 28:17.540
而是每隔一段时间运行一次

28:17.540 --> 28:18.940
如果遇到这样的场景

28:18.940 --> 28:20.140
你就可以使用函数节流

28:21.040 --> 28:23.140
如果你遇到一种场景就是

28:23.140 --> 28:24.240
就是每

28:24.240 --> 28:26.540
我一定要等它动作结束之后在运行

28:26.540 --> 28:27.540
那么就是函数防斗

28:28.540 --> 28:30.340
这就是凉数的区别

28:30.340 --> 28:31.240
那么你看再看一次

28:32.240 --> 28:33.440
你看是不是固定在执行

28:33.440 --> 28:33.940
对吧

28:33.940 --> 28:34.640
固定在执行

28:36.240 --> 28:37.640
再看一下它的协法

28:37.640 --> 28:38.640
它是用这种协法

28:39.640 --> 28:41.540
这是第一种协法

28:41.540 --> 28:43.340
用计时器的这种方式

28:43.340 --> 28:43.940
第一种协法

28:44.940 --> 28:47.140
那么还有没有别的协法呢

28:47.140 --> 28:49.040
还有这种方式的协法呢

28:49.040 --> 28:51.740
就是你看一下它的触发

28:53.340 --> 28:54.040
刷新

28:54.040 --> 28:55.240
一开始它会触发一次

28:55.240 --> 28:56.040
一开始会触发一次

28:56.040 --> 28:57.140
我要关了

28:57.140 --> 28:58.040
你看它的触发

28:58.040 --> 28:58.740
表面马上来

28:59.740 --> 29:01.440
是不是等了一秒钟

29:01.440 --> 29:02.840
等了一秒钟才会触发

29:02.840 --> 29:04.240
等了一秒钟才会触发

29:04.240 --> 29:05.440
那么还有一种协法呢

29:05.440 --> 29:07.040
就是马上触发

29:07.040 --> 29:08.440
但是下一次的触发呢

29:08.440 --> 29:09.940
要等一秒钟

29:09.940 --> 29:10.640
还有一种协法呢

29:10.640 --> 29:11.440
是这种

29:11.440 --> 29:13.340
就是下一次的触发还要等一秒钟

29:13.340 --> 29:14.340
但是这一次呢

29:14.340 --> 29:15.140
马上触发

29:16.040 --> 29:17.840
那么这种怎么写呢

29:17.840 --> 29:18.740
这种又咋写呢

29:20.040 --> 29:21.140
看着我们可以用

29:21.140 --> 29:21.940
那这种呢

29:21.940 --> 29:23.040
就不是用计时器的

29:24.440 --> 29:26.140
它就不是用计时器的

29:26.140 --> 29:26.940
而是用什么呢

29:26.940 --> 29:28.140
用时间戳

29:30.340 --> 29:31.340
用时间戳

29:32.940 --> 29:33.440
怎么写

29:34.540 --> 29:36.140
我们可以用这种方式

29:36.140 --> 29:37.940
这里呢定义一个时间

29:37.940 --> 29:39.140
时间

29:39.140 --> 29:39.940
当前时间嘛

29:39.940 --> 29:40.940
就是Time

29:40.940 --> 29:41.540
Time

29:41.540 --> 29:43.040
调用这个函数的时候

29:43.040 --> 29:44.540
我们定义这么一个时间

29:44.540 --> 29:45.540
Time

29:45.540 --> 29:46.140
这个时间呢

29:46.140 --> 29:47.940
会被后边返回的函数共用

29:47.940 --> 29:48.540
对吧

29:48.540 --> 29:50.740
每次交用都可以用这个时间

29:50.740 --> 29:51.740
定一个时间

29:51.740 --> 29:53.140
定一个时间

29:53.140 --> 29:53.640
然后呢

29:53.640 --> 29:54.940
这个时间默认为NOW

29:54.940 --> 29:55.440
没有值

29:55.440 --> 29:56.440
默认为NOW

29:56.440 --> 29:57.440
没有值

29:57.440 --> 29:57.740
好

29:57.740 --> 29:59.440
这里我们返回一个函数

29:59.440 --> 30:00.840
返回一个函数

30:00.840 --> 30:01.440
好

30:01.440 --> 30:02.040
什么

30:02.040 --> 30:04.440
当我们调用这个函数的时候

30:04.440 --> 30:06.440
什么情况下可以立即执行了

30:06.440 --> 30:07.440
就是这个时间

30:07.440 --> 30:08.540
如果没有值

30:08.540 --> 30:09.540
对吧

30:09.540 --> 30:11.140
就是之前还没有计过值

30:11.140 --> 30:12.640
还没有进行过任何计时

30:12.640 --> 30:13.640
没有值

30:13.640 --> 30:15.740
没有值是不是可以执行了

30:15.740 --> 30:16.140
对不对

30:16.140 --> 30:17.540
是不是可以执行函数了

30:17.540 --> 30:19.140
只要你这个时间没有值

30:19.140 --> 30:20.640
是不是就可以执行函数了

30:20.640 --> 30:21.740
对不对

30:21.740 --> 30:22.040
然后呢

30:22.040 --> 30:22.940
我们就可以执行函数

30:22.940 --> 30:23.340
执行函数

30:23.340 --> 30:24.940
我们就用这种方式

30:24.940 --> 30:26.340
那么这里就不用Apply了

30:26.340 --> 30:27.440
就不用Apply了

30:27.440 --> 30:28.140
可以用Apply

30:28.140 --> 30:28.740
这里传

30:28.740 --> 30:30.840
直接传入Archimage就行了

30:30.840 --> 30:32.940
把函数传进来就完事了

30:32.940 --> 30:33.140
好

30:33.140 --> 30:35.140
如果没有时间

30:35.140 --> 30:38.040
之前没有计时

30:38.040 --> 30:39.540
那么说明就是第一次调用

30:39.540 --> 30:40.440
第一次调用这个函数

30:40.440 --> 30:41.640
那就立即执行

30:41.640 --> 30:43.140
立即执行

30:43.140 --> 30:43.440
好

30:43.440 --> 30:44.440
执行完了过后

30:44.440 --> 30:46.140
是不是现在要把时间记录一下

30:46.140 --> 30:47.440
就这一次调用的时间

30:47.440 --> 30:48.840
是不是要记录一下

30:48.840 --> 30:48.940
哦

30:48.940 --> 30:50.640
这里不能用这个Time

30:50.640 --> 30:51.140
重明了

30:51.140 --> 30:51.440
对不对

30:51.440 --> 30:52.140
用T嘛

30:52.140 --> 30:54.140
用T

30:55.140 --> 30:55.940
好

30:55.940 --> 30:56.740
执行之后

30:56.740 --> 30:58.640
是不是把这个函数的执行时间

30:58.640 --> 30:59.540
要记录一下

30:59.540 --> 31:00.140
怎么记录了

31:00.140 --> 31:01.140
是不是当前时间

31:01.140 --> 31:01.840
对不对

31:01.840 --> 31:02.740
当前时间

31:02.740 --> 31:03.540
丢Dat

31:03.540 --> 31:03.740
啊

31:03.740 --> 31:04.640
Dat

31:04.640 --> 31:05.840
或者是使用什么

31:05.840 --> 31:07.140
Dat里边一个静态方法

31:07.140 --> 31:08.040
闹啊

31:08.040 --> 31:09.340
也可以得到当前的时间

31:09.340 --> 31:10.440
不过这个得到的是什么

31:10.440 --> 31:11.940
得到的是时间戳啊

31:11.940 --> 31:13.340
这是得到的

31:13.340 --> 31:14.840
当前时间戳

31:14.840 --> 31:16.340
我们之前说过时间戳

31:16.340 --> 31:18.040
表示1971年1月1号

31:18.040 --> 31:19.540
1970年1月1号

31:19.540 --> 31:20.640
到现在的

31:20.640 --> 31:21.840
经过了毫秒数

31:21.840 --> 31:22.740
当前的时间戳

31:24.640 --> 31:24.840
好

31:24.840 --> 31:25.640
把记录一下

31:26.840 --> 31:26.940
好

31:26.940 --> 31:28.940
那么下一次什么时候可以执行的

31:28.940 --> 31:29.940
下一次

31:29.940 --> 31:31.440
下一次是不是要等到

31:32.940 --> 31:34.340
现在这个时间

31:34.340 --> 31:36.840
减去之前记录的时间

31:36.840 --> 31:38.440
比方说过了一会又来调用

31:38.440 --> 31:39.140
又来调用的时候

31:39.140 --> 31:40.140
是不是要判断一下

31:40.140 --> 31:41.340
你现在的时间

31:41.340 --> 31:43.040
说减去这个时间

31:43.040 --> 31:45.440
是不是要刚好等于啥

31:45.440 --> 31:47.440
要大于等于这个毫秒数

31:47.440 --> 31:47.940
对不对

31:47.940 --> 31:49.140
要大于等于这个毫秒数

31:49.140 --> 31:50.140
所以说这里呢

31:50.140 --> 31:50.940
加上一个

31:50.940 --> 31:52.440
或者

31:52.440 --> 31:53.340
判断

31:53.440 --> 31:54.340
你没有指

31:54.340 --> 31:55.540
我立即执行

31:55.540 --> 31:56.340
还有什么情况下

31:56.340 --> 31:57.240
我可以执行的

31:57.240 --> 31:58.740
就是可以执行的情况

31:58.740 --> 31:59.940
之前没有计时

31:59.940 --> 32:00.840
还有就是

32:00.840 --> 32:01.340
或

32:02.640 --> 32:03.640
时间

32:03.640 --> 32:04.540
以

32:04.540 --> 32:05.140
就是

32:06.140 --> 32:06.940
时间

32:08.040 --> 32:11.840
就距离上次执行的时间

32:11.840 --> 32:13.340
以超过

32:13.340 --> 32:14.340
以超过

32:15.540 --> 32:16.340
规定的指

32:17.940 --> 32:20.340
这两种情况下都可以执行

32:20.340 --> 32:20.940
怎么来算

32:20.940 --> 32:21.940
就是

32:23.840 --> 32:25.340
当前的时间戳

32:25.340 --> 32:26.140
减去什么

32:26.140 --> 32:27.140
之前的时间戳

32:27.140 --> 32:28.040
你现在不是有指吗

32:28.040 --> 32:28.440
对吧

32:28.440 --> 32:29.340
如果这个是没有指

32:29.340 --> 32:29.940
这个为处了

32:29.940 --> 32:32.040
它就不会进入后面的判断了

32:32.040 --> 32:34.140
两个时间相减

32:34.140 --> 32:36.340
两个时间相减

32:36.340 --> 32:39.540
那么如果时间相减的差值

32:39.540 --> 32:40.540
大于了

32:40.540 --> 32:41.440
当然不用写口号

32:41.440 --> 32:42.140
对吧

32:42.140 --> 32:43.340
它一定是算数运算

32:43.340 --> 32:44.040
先运行

32:44.040 --> 32:45.240
再进行比较

32:45.240 --> 32:46.640
相减的差值大于了

32:46.640 --> 32:47.440
大于等于了

32:47.440 --> 32:48.440
什么这个时间

32:48.440 --> 32:48.940
对吧

32:48.940 --> 32:50.540
这个时候是不是也可以执行

32:50.540 --> 32:51.040
对不对

32:51.040 --> 32:51.740
也可以执行

32:52.740 --> 32:54.540
就写成了这么一种格式的

32:54.540 --> 32:56.340
写成这么一种格式的

32:56.340 --> 32:56.940
保存

32:56.940 --> 32:57.140
保存

32:57.140 --> 32:58.040
我们来看一下

32:58.040 --> 32:59.640
这种格式它写出来的

32:59.640 --> 33:00.140
刷新

33:00.140 --> 33:01.540
你看一下是不是马上运行的

33:01.540 --> 33:02.140
对不对

33:02.140 --> 33:02.740
一改变

33:02.740 --> 33:03.940
你看什么马上运行

33:03.940 --> 33:04.540
对吧

33:04.540 --> 33:05.740
一改变的马上运行

33:05.740 --> 33:06.740
但它频率是有限的

33:06.740 --> 33:07.140
对吧

33:07.140 --> 33:08.540
距离下一次运行的

33:08.540 --> 33:09.940
是有段时间的

33:09.940 --> 33:10.340
你看

33:10.340 --> 33:11.440
我停止

33:11.440 --> 33:12.340
是不再运行的

33:12.340 --> 33:12.540
对吧

33:12.540 --> 33:13.640
不再运行的

33:13.640 --> 33:14.540
就这种特点

33:14.540 --> 33:15.540
就是用计时器

33:15.540 --> 33:17.540
它能够马上运行

33:17.540 --> 33:18.540
它是触发的

33:18.540 --> 33:19.240
触发的时间

33:19.240 --> 33:20.640
那第一次触发的时间

33:20.640 --> 33:21.940
是在开始

33:21.940 --> 33:23.740
如果我们用一个数轴来划的话

33:23.740 --> 33:24.840
比方说

33:24.840 --> 33:26.240
我们用个PBT来划一下

33:26.240 --> 33:29.240
用计时器跟那个

33:29.240 --> 33:31.240
跟那个就是

33:31.240 --> 33:32.440
用那个Timer

33:32.440 --> 33:35.240
计时器和那个就是时间戳有什么样的区别

33:35.240 --> 33:36.940
比方说这是时间的流逝

33:36.940 --> 33:38.540
这是时间的轴

33:38.540 --> 33:40.440
这是时间轴

33:40.440 --> 33:41.240
如果是

33:41.240 --> 33:43.240
我们这里是触发时间

33:43.240 --> 33:46.840
从这里开始触发时间

33:46.840 --> 33:49.740
这里是开始触发时间

33:49.740 --> 33:51.440
比方说规定一秒钟

33:51.440 --> 33:53.340
频率是一秒钟运行一次

33:53.340 --> 33:54.440
那么触发时间的话

33:54.440 --> 33:55.940
我们用这个线

33:55.940 --> 33:57.740
这个红色的线表示它

33:57.740 --> 33:59.740
真实函数的运行

33:59.740 --> 34:01.140
是这样子的

34:01.140 --> 34:02.540
如果你是用时间

34:02.540 --> 34:03.940
如果你是用计时器的话

34:03.940 --> 34:05.440
它是这样子

34:05.440 --> 34:06.240
你这里触发时间

34:06.240 --> 34:07.540
后面是不断的触发

34:07.540 --> 34:09.340
后面就是不断的触发了

34:09.340 --> 34:10.940
刚才我们用一个举行

34:10.940 --> 34:12.340
用一个举行来表示

34:12.340 --> 34:14.740
这里不断的在触发时间

34:17.740 --> 34:19.540
表示这里不断的在触发时间

34:19.540 --> 34:21.240
那么如果使用计时器的话

34:21.240 --> 34:23.240
它的触发频率是这样子的

34:23.240 --> 34:25.140
这里触发

34:25.140 --> 34:25.440
对吧

34:25.440 --> 34:27.240
它的频率是这样子的

34:27.240 --> 34:28.940
如果你用的是时间戳的话

34:28.940 --> 34:30.540
它的频率是从这里开始的

34:30.540 --> 34:31.040
还没有

34:31.040 --> 34:33.240
是从这里开始的

34:33.240 --> 34:34.740
然后一次延伸

34:34.740 --> 34:35.140
对不对

34:35.140 --> 34:37.140
一次延伸

34:37.140 --> 34:38.240
还有一个特点就是

34:38.240 --> 34:41.340
如果你使用的是计时器这种做法

34:41.340 --> 34:42.640
如果你使用的是计时器的话

34:42.640 --> 34:43.740
它还有一个特点

34:43.740 --> 34:45.440
就是最后停止的过后

34:45.440 --> 34:46.840
它还有最后一次触发

34:46.840 --> 34:47.640
因为它用的是计时器

34:47.740 --> 34:48.740
它要等待时间到达

34:48.740 --> 34:50.140
对吧

34:50.140 --> 34:51.140
停止

34:51.140 --> 34:52.440
你看是不是还触发了一次

34:52.440 --> 34:53.040
对吧

34:53.040 --> 34:54.740
因为它有个计时器在那里

34:54.740 --> 34:56.540
如果是用上面的那种方式的话

34:56.540 --> 34:58.240
那么就不会

34:58.240 --> 34:58.540
你看一下

34:58.540 --> 34:59.640
它是立即触发的

34:59.640 --> 35:00.340
你看

35:00.340 --> 35:01.340
它立即能触发就触发

35:01.340 --> 35:03.340
不能触发就不能触发

35:03.340 --> 35:03.840
你看停止

35:03.840 --> 35:05.140
马上就停止了

35:05.140 --> 35:07.740
它不会再多触发一次

35:07.740 --> 35:08.940
这是两种的区别

35:08.940 --> 35:11.040
能不能把两种混合起来了

35:11.040 --> 35:12.340
可以

35:12.340 --> 35:13.840
那么比方说第三个参数

35:13.840 --> 35:15.720
加上叫做immediate

35:16.720 --> 35:18.220
完了

35:18.220 --> 35:20.120
我又不知道这个单词咋写了

35:20.120 --> 35:21.720
翻译

35:21.720 --> 35:26.420
是不是立即触发

35:26.420 --> 35:28.920
立即

35:28.920 --> 35:29.920
就这里

35:29.920 --> 35:31.820
immediate

35:31.820 --> 35:33.220
是不是立即触发

35:33.220 --> 35:34.420
如果是立即触发的话

35:34.420 --> 35:36.320
我就用时间戳

35:36.320 --> 35:36.620
对吧

35:36.620 --> 35:38.820
它就可以达到立即触发的效果

35:38.820 --> 35:40.320
如果不是立即触发的话

35:40.320 --> 35:42.720
那么我们就可以用那个计时器

35:42.720 --> 35:44.220
就是两种方式

35:44.220 --> 35:45.720
这里使用两种方式

35:45.720 --> 35:47.720
因此我们这里定义两个变量

35:47.720 --> 35:49.920
t和timer

35:49.920 --> 35:52.020
两个都定义

35:52.020 --> 35:54.220
那么根据这个值来确定用哪一个

35:54.220 --> 35:57.020
那么这里我们可以这样

35:57.020 --> 35:59.520
可以这样

35:59.520 --> 36:01.320
这个给它一个默认值

36:01.320 --> 36:03.020
默认为比方说为处

36:03.020 --> 36:04.120
默认为处

36:04.120 --> 36:04.820
immediate成立

36:04.820 --> 36:06.020
如果等于untyfan

36:06.020 --> 36:07.520
如果你没有传递的话

36:07.520 --> 36:10.320
那么就表示

36:10.320 --> 36:11.920
表示没有传递这个参数

36:11.920 --> 36:12.920
没有传递这个参数的话

36:12.920 --> 36:14.320
我们把它设为处

36:14.520 --> 36:15.920
给它个默认值

36:15.920 --> 36:16.420
好吧

36:16.420 --> 36:17.320
给它个默认值

36:17.320 --> 36:18.320
ok

36:18.320 --> 36:18.520
好

36:18.520 --> 36:19.420
那么接下来

36:19.420 --> 36:21.420
这里边我们是不是可以控制的

36:21.420 --> 36:21.620
对吧

36:21.620 --> 36:22.620
判断一下不完

36:22.620 --> 36:23.720
那么对不对

36:23.720 --> 36:24.720
好判断一下

36:24.720 --> 36:27.120
如果是immediate成立

36:27.120 --> 36:28.920
如果是这种模式的话

36:28.920 --> 36:30.520
那么用这种方式

36:30.520 --> 36:31.120
如果是这种模式

36:31.120 --> 36:32.120
用这种方式

36:32.120 --> 36:34.120
要是如果是别的模式的话

36:34.120 --> 36:35.420
就用下面那种方式

36:35.420 --> 36:36.220
你看一下

36:36.220 --> 36:38.820
是不是两种都可以了

36:38.820 --> 36:39.920
对吧

36:39.920 --> 36:41.720
两种都行

36:41.720 --> 36:43.020
都行

36:43.020 --> 36:43.720
没问题吧

36:43.820 --> 36:44.520
对吧

36:44.520 --> 36:45.320
反悔一个函数

36:45.320 --> 36:46.220
我们判断这个东西

36:47.520 --> 36:48.120
好了

36:48.120 --> 36:49.620
当然那也可以根据不同的情况

36:49.620 --> 36:50.920
反悔不同的函数

36:50.920 --> 36:52.120
也可以

36:52.120 --> 36:53.120
也可以

36:53.120 --> 36:54.920
就是它写法很多的

36:54.920 --> 36:56.320
不是说只有一种写法

36:56.320 --> 36:57.920
比方说我们再看一下另一种写法

36:57.920 --> 36:58.620
另一种写法

36:58.620 --> 37:00.020
但是另一种写法我觉得更好一点

37:00.020 --> 37:00.720
因为

37:00.720 --> 37:02.120
你如果只反悔一个函数的话

37:02.120 --> 37:03.320
每次都要进行判断

37:03.320 --> 37:03.920
对于什么意义

37:03.920 --> 37:05.520
没有必要进行判断了

37:05.520 --> 37:06.820
因为这个判断已经固定下来了

37:06.820 --> 37:08.120
这个参数已经固定了

37:08.120 --> 37:09.720
所以说我们这里

37:09.720 --> 37:10.520
比方说

37:10.520 --> 37:11.620
我们这里

37:11.620 --> 37:12.620
判断

37:12.620 --> 37:13.220
immediate成立

37:13.220 --> 37:14.920
如果它为处

37:14.920 --> 37:15.420
immediate成立

37:15.420 --> 37:16.820
如果为处

37:16.820 --> 37:17.920
如果为处的话

37:17.920 --> 37:19.120
那么我们干嘛呢

37:19.120 --> 37:20.520
我们使用这种方式

37:20.520 --> 37:20.920
对吧

37:20.920 --> 37:22.620
反悔这个函数

37:22.620 --> 37:24.020
对不对

37:24.020 --> 37:25.120
我们反悔这个函数

37:25.120 --> 37:25.520
甚至呢

37:25.520 --> 37:26.020
我们把这个

37:27.220 --> 37:28.920
上面这个T定应到这

37:28.920 --> 37:30.120
定应到这

37:30.120 --> 37:30.420
好

37:30.420 --> 37:31.420
l是

37:31.420 --> 37:32.720
如果不是这种情况的话

37:32.720 --> 37:35.120
我们反悔另外一个函数

37:35.120 --> 37:36.020
就反悔这一部分

37:37.420 --> 37:38.120
对吧

37:38.120 --> 37:38.920
这也可以搞定

37:38.920 --> 37:40.220
对不对

37:40.220 --> 37:42.120
那么一个完整的函数捷流

37:42.220 --> 37:42.720
就写完了

37:44.620 --> 37:45.420
我是不是写错了

37:45.420 --> 37:45.820
哦

37:45.820 --> 37:46.420
你要在这

37:47.420 --> 37:47.920
你要在这

37:51.020 --> 37:51.220
这里

37:52.420 --> 37:52.620
好

37:52.620 --> 37:53.320
这样子

37:53.320 --> 37:54.220
那么根据

37:54.220 --> 37:55.820
你要的处理方式

37:55.820 --> 37:57.720
我们可以返回不同的函数

37:57.720 --> 37:59.420
就判断一下就完事了

37:59.420 --> 37:59.620
好

37:59.620 --> 38:00.020
那么现在呢

38:00.020 --> 38:01.020
我们就具备了

38:01.020 --> 38:02.320
它既可以立即执行

38:02.320 --> 38:03.220
看一下啊

38:03.220 --> 38:04.020
哎

38:04.020 --> 38:04.520
这边啊

38:05.720 --> 38:07.420
既可以立即执行看没有

38:07.420 --> 38:08.720
它可以立即执行

38:08.720 --> 38:11.020
也可以什么等一段时间之后执行

38:11.020 --> 38:12.220
比方说我们这里

38:12.220 --> 38:13.120
啊

38:13.120 --> 38:14.220
这个这里给它传

38:14.220 --> 38:15.020
第三个参数啊

38:15.020 --> 38:17.220
force表示不是立即执行

38:17.220 --> 38:17.420
好

38:17.420 --> 38:19.120
那么它就会使用计时器

38:19.120 --> 38:19.520
你看没有

38:20.620 --> 38:21.620
它是等等之后

38:21.620 --> 38:22.520
完了之后再执行

38:23.620 --> 38:23.720
好

38:23.720 --> 38:24.620
这是这一块啊

38:24.620 --> 38:26.220
函数捷流和函数防斗

38:26.220 --> 38:26.920
我们以后呢

38:26.920 --> 38:29.720
在用到什么滚动条滚动事件

38:29.720 --> 38:31.720
窗口改变事件

38:31.720 --> 38:33.420
闻闷框输入变化事件

38:33.420 --> 38:35.720
这些触发非常非常频繁的事件的时候

38:35.720 --> 38:37.720
我们就很有可能会使用到

38:37.720 --> 38:40.520
函数捷流或者是函数防斗

38:40.520 --> 38:40.720
好吧

38:40.720 --> 38:41.420
这两个弄邪法

38:41.420 --> 38:42.020
一定要协会

38:42.020 --> 38:42.920
学会啊

38:43.220 --> 38:43.820
接下来

38:43.820 --> 38:45.020
下面下去过后了

38:45.020 --> 38:47.520
把这个防斗和捷流秩序写一遍

