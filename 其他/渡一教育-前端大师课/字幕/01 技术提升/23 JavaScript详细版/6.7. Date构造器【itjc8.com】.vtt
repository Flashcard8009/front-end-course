WEBVTT

00:00.000 --> 00:15.120
这节课呢 咱们讲时间

00:15.120 --> 00:19.120
就是关于这个DET 构造器 也叫构造函数嘛

00:19.120 --> 00:23.120
构造函数

00:23.120 --> 00:28.120
在讲这个东西之前呢 首先呢 我们来介绍一些常识啊

00:28.120 --> 00:31.120
以后同学 我相信很多同学可能不太知道啊

00:31.120 --> 00:34.120
就咱们时间这一块 它的一些专业数据

00:34.120 --> 00:37.120
因为我们平时说时间时间

00:37.120 --> 00:40.120
平时都只有这么一个抽象概念

00:40.120 --> 00:43.120
其实在这里边还是有一些专业数据的啊

00:43.120 --> 00:46.120
我们第一个数据呢 说一下时间的单位

00:46.120 --> 00:49.120
专业数据 免得我后边说到这些数据的时候

00:49.120 --> 00:51.120
你都不知道什么意思啊

00:51.120 --> 00:54.120
就是一个是时间单位

00:54.120 --> 00:56.120
一个时间单位

00:56.120 --> 00:59.120
单位呢 有什么 有小时 对不对

00:59.120 --> 01:02.120
分钟 秒 对不对

01:02.120 --> 01:05.120
还有什么 连月日啊 这些大家都知道啊

01:05.120 --> 01:08.120
连月日

01:08.120 --> 01:11.120
除了这些之外呢 还有一个叫做好妙

01:11.120 --> 01:14.120
好妙 我们用这个单词呢 叫做mini second

01:14.120 --> 01:17.120
mini second

01:17.120 --> 01:19.120
mini second

01:19.120 --> 01:21.120
用这个单词呢 表示好妙

01:21.120 --> 01:24.120
有的时候呢 就简写为MS

01:24.120 --> 01:27.120
我们把单词也介绍一下吧

01:27.120 --> 01:29.120
专业单词都不知道啊

01:29.120 --> 01:32.120
连呢 是用year 对吧 year

01:32.120 --> 01:34.120
是什么 months 对不对

01:34.120 --> 01:35.120
month

01:35.120 --> 01:37.120
一年有12个月嘛

01:37.120 --> 01:39.120
日呢 使用date

01:39.120 --> 01:41.120
date呢 表示日

01:41.120 --> 01:44.120
小时呢 使用hour

01:44.120 --> 01:48.120
分钟呢 使用的是minute

01:48.120 --> 01:50.120
秒呢 使用的是什么呢

01:50.120 --> 01:54.120
秒使用的是second

01:54.120 --> 01:56.120
这单词要记住啊 这单词很重要的

01:56.120 --> 01:58.120
好妙呢 使用mini second

01:58.120 --> 02:01.120
有的时候呢 简称它为MS

02:02.120 --> 02:04.120
好妙这个单位呢 它是这样子

02:04.120 --> 02:06.120
跟秒之间的关系呢 它是一秒中

02:06.120 --> 02:08.120
等于1000好妙

02:08.120 --> 02:10.120
一秒 等于1000好妙

02:10.120 --> 02:12.120
一秒 等于1000好妙

02:12.120 --> 02:15.120
然后 下边呢 还有这个辣妙

02:15.120 --> 02:17.120
辣妙

02:17.120 --> 02:20.820
辣妙

02:20.820 --> 02:21.820
哦 不对不对 不对

02:21.820 --> 02:23.820
辣妙前面还有个东西啊 叫做微妙

02:23.820 --> 02:24.820
微妙

02:24.820 --> 02:27.820
微妙呢 称之为叫做micro

02:27.820 --> 02:30.820
micro second

02:31.820 --> 02:33.820
那么 下面呢 才是辣妙

02:33.820 --> 02:37.820
辣妙是nanosecond

02:37.820 --> 02:38.820
这是这么一些秒

02:38.820 --> 02:41.820
平时呢 我们接触到的最小单位

02:41.820 --> 02:43.820
一般到好妙就可以了

02:43.820 --> 02:44.820
到好妙就可以了

02:44.820 --> 02:46.820
一般计算机的话 不再去接触微妙啊

02:46.820 --> 02:48.820
辣妙 不再去接触了

02:48.820 --> 02:49.820
但是我们了解一下就行了

02:49.820 --> 02:52.820
一好妙呢 等于1000

02:52.820 --> 02:54.820
一千微妙

02:54.820 --> 02:57.820
微妙 它这个单位记住的是这个

02:57.820 --> 02:59.820
这个字大不出来啊 这个字

02:59.820 --> 03:01.820
有点像这个u

03:01.820 --> 03:03.820
有点像这个u 但是前面呢 有一飘

03:03.820 --> 03:05.820
前面有一飘 打不出来

03:05.820 --> 03:06.820
打不出来

03:06.820 --> 03:08.820
我们就用u吧

03:08.820 --> 03:10.820
us

03:10.820 --> 03:13.450
微妙

03:13.450 --> 03:15.450
然后呢 一微妙呢 等于一千辣妙

03:15.450 --> 03:17.450
辣妙 ns

03:17.450 --> 03:19.450
这是辣妙

03:19.450 --> 03:21.450
这是平 其实下面呢 还有

03:21.450 --> 03:22.450
还有什么平妙

03:22.450 --> 03:24.450
还有一平妙 我们就不说了

03:24.450 --> 03:25.450
太小了这单位

03:25.450 --> 03:27.450
这是时间的 常见的时间单位

03:27.450 --> 03:28.450
时间单位

03:28.450 --> 03:29.450
我们计算机里边呢

03:29.450 --> 03:31.450
我们通常到好妙这一块就够了

03:31.450 --> 03:33.450
到好妙这一块就够了

03:33.450 --> 03:35.450
好 这是关于时间单位

03:35.450 --> 03:37.450
好 第二个书语呢 是关于这个

03:37.450 --> 03:39.450
就是UTC

03:39.450 --> 03:41.450
和GMT

03:41.450 --> 03:43.450
说一下正东西

03:43.450 --> 03:47.450
什么叫UTC呢 它叫做世界协调室

03:47.450 --> 03:49.450
世界协调室

03:49.450 --> 03:52.450
GMT呢 叫做

03:52.450 --> 03:54.450
格林威治

03:54.450 --> 03:56.450
世界室

03:56.450 --> 03:58.450
格林威治世界室

03:58.450 --> 04:00.450
一个是世界协调室 一个叫世界室

04:00.450 --> 04:02.450
这两个呢 其实我们很多时候

04:02.450 --> 04:04.450
就把它当成一个东西来看

04:04.450 --> 04:05.450
就没事了

04:05.450 --> 04:07.450
但是他们实际上是有一点点区别的

04:07.450 --> 04:09.450
只不过呢 在我们开发层面呢

04:09.450 --> 04:11.450
这些区别呢 跟我们没多少关系

04:11.450 --> 04:13.450
我们了解一下就行了

04:13.450 --> 04:15.450
格林威治世界室呢 格林威治是个地方

04:15.450 --> 04:17.450
是在英国的一个地方

04:17.450 --> 04:19.450
它表示了整个世界的零食区

04:19.450 --> 04:21.450
我们世界是花分为24个食区

04:21.450 --> 04:22.450
对吧

04:22.450 --> 04:26.450
世界花分为24个食区

04:26.450 --> 04:29.450
你要出国的时候 你是不是要重新调表

04:29.450 --> 04:31.450
下了飞机过后要重新调表 对不对

04:31.450 --> 04:33.450
当然呢 显得很多手机呢 它会自动帮你调

04:33.450 --> 04:36.450
你只要到了一个地方 它会自动帮你调

04:36.450 --> 04:38.450
世界上分为24个食区

04:38.450 --> 04:41.450
我们现在中国呢 使用的是北京的食区对吧

04:41.450 --> 04:42.450
北京

04:42.450 --> 04:45.450
北京呢 是在东巴区

04:45.450 --> 04:47.450
东巴区

04:47.450 --> 04:49.450
东巴区

04:49.450 --> 04:51.450
格林威治呢

04:51.450 --> 04:53.450
格林威治呢 就是英国那个地方

04:53.450 --> 04:55.450
是在零食区

04:55.450 --> 04:57.450
格林威治

04:57.450 --> 04:59.450
在零食区

04:59.450 --> 05:02.450
就是我们其实其他的食区的时间

05:02.450 --> 05:05.450
都是根据格林威治的时间来调的

05:05.450 --> 05:08.450
来调的 那么格林威治的时间又是怎么出来的呢

05:08.450 --> 05:11.450
它是按照地球的自传和

05:11.450 --> 05:13.450
太阳的公传

05:13.450 --> 05:15.450
按照这样的方式来记录的时间

05:15.450 --> 05:17.450
它能精确到好秒

05:17.450 --> 05:20.450
它是太阳石

05:20.450 --> 05:23.450
它是根据地球的自传和太阳的公传

05:23.450 --> 05:25.450
通过这种方式

05:25.450 --> 05:26.450
太阳跟地面的角度

05:26.450 --> 05:28.450
通过这种方式来进行即时的

05:28.450 --> 05:30.450
来算这个时间的

05:30.450 --> 05:34.660
它是精确到好秒

05:34.660 --> 05:36.660
这是格林威治时间

05:36.660 --> 05:38.660
但后来呢 大家发现了 这个格林威治时间呢

05:38.660 --> 05:40.660
它记录起来呢 不是那么的精确

05:40.660 --> 05:42.660
因为到了好秒呢 有些特别特别

05:42.660 --> 05:45.660
要求精细的一些系统呢

05:45.660 --> 05:47.660
它可能要求的更加精确的时间

05:47.660 --> 05:50.660
因此呢 又出来了世界协调石

05:50.660 --> 05:53.660
世界协调石呢 是以原子

05:53.660 --> 05:57.660
原子时间为即时标准

05:57.660 --> 05:59.660
为即时标准

05:59.660 --> 06:01.660
但我也不是学什么 微观物理的

06:01.660 --> 06:03.660
在这里边的那些稍稍作举太多了

06:03.660 --> 06:05.660
我就不知道它具体是怎么玩的了

06:05.660 --> 06:07.660
它是以某一个原子

06:07.660 --> 06:09.660
哪种原子我一点忘了

06:09.660 --> 06:11.660
之前看过一篇科普文章

06:11.660 --> 06:13.660
它是以某个原子

06:13.660 --> 06:15.660
它的衰变 衰变的时候发生浮射

06:15.660 --> 06:18.660
那个浮射的那个振动频率

06:18.660 --> 06:20.660
它是以那个东西来计时的

06:20.660 --> 06:21.660
用那个东西来计时的

06:21.660 --> 06:24.660
它能精确到 精确到那秒

06:24.660 --> 06:25.660
当然我不是搞微观物理的

06:25.660 --> 06:28.660
我也不知道这些乱七八糟的玩意

06:28.660 --> 06:30.660
聊一下就行了

06:30.660 --> 06:32.660
这两个的计时的方式不一样

06:32.660 --> 06:34.660
但它们的时间是非常接近的

06:34.660 --> 06:36.660
就是UTC这个时间呢

06:36.660 --> 06:39.660
UTC和GMT这个时间之间

06:39.660 --> 06:43.660
误差不超过0.9秒

06:43.660 --> 06:46.660
一旦它发现快要超过0.9秒了

06:46.660 --> 06:49.660
之后了UTC它会自动调整时间

06:49.660 --> 06:51.660
调整时间

06:51.660 --> 06:53.660
它会用加一个0.9

06:53.660 --> 06:54.660
或者加一个时间

06:54.660 --> 06:56.660
或者是减一个时间

06:56.660 --> 06:57.660
来保证基本上呢

06:57.660 --> 06:59.660
跟这个世界是一致的

06:59.660 --> 07:02.660
跟基本上跟世界是一致的

07:02.660 --> 07:04.660
那咱们平时开发的时候

07:04.660 --> 07:06.660
用的是什么时间呢

07:06.660 --> 07:08.660
用的是这个UTC

07:08.660 --> 07:10.660
因为UTC它的精确度更高

07:10.660 --> 07:12.660
更加适合计算机系统

07:12.660 --> 07:14.660
虽然我们开发的时候

07:14.660 --> 07:15.660
没有用到什么纳秒

07:15.660 --> 07:16.660
维码都没有用到

07:16.660 --> 07:18.660
但是呢

07:18.660 --> 07:19.660
但是呢

07:19.660 --> 07:20.660
它在系统内部啊

07:20.660 --> 07:22.660
它这个时间即时更加精确

07:22.660 --> 07:24.660
用这种UTC的方式

07:24.660 --> 07:25.660
它即时更加精确

07:25.660 --> 07:26.660
是这么回事

07:26.660 --> 07:28.660
我们平时以后看到这两种

07:28.660 --> 07:29.660
你可以基本上在问

07:29.660 --> 07:30.660
它们是一样的

07:30.660 --> 07:31.660
但是它们有这么一些

07:31.660 --> 07:33.660
细微的差异

07:33.660 --> 07:35.660
这是关于这两个时间

07:35.660 --> 07:36.660
就是有的时候呢

07:36.660 --> 07:38.660
我们说时趋啊

07:38.660 --> 07:39.660
说的时趋呢

07:39.660 --> 07:40.660
是相对于隔离维制的

07:40.660 --> 07:41.660
因此呢

07:41.660 --> 07:42.660
我们很多时候

07:42.660 --> 07:43.660
在隔离时趋的时候呢

07:43.660 --> 07:45.660
都可能会这样子记

07:45.660 --> 07:46.660
比方说我们会记住

07:46.660 --> 07:48.660
GMT

07:48.660 --> 07:50.660
加零八

07:50.660 --> 07:52.660
如果要精确一点的话

07:52.660 --> 07:54.660
后面加零零

07:54.660 --> 07:55.660
表示的是

07:55.660 --> 07:57.660
东八区

07:57.660 --> 07:59.660
加号表示的是

07:59.660 --> 08:00.660
东边

08:00.660 --> 08:02.660
简号的表示西边

08:02.660 --> 08:03.660
东八区

08:03.660 --> 08:04.660
就表示这个是

08:04.660 --> 08:06.660
用这种记录方式

08:06.660 --> 08:08.660
来表示时趋

08:08.660 --> 08:10.660
这个GMT它实际上表示的单词

08:10.660 --> 08:11.660
就是

08:11.660 --> 08:12.660
Green

08:12.660 --> 08:13.660
Green

08:13.660 --> 08:14.660
Wish

08:14.660 --> 08:15.660
隔离维制

08:15.660 --> 08:16.660
Mintan

08:16.660 --> 08:18.660
Mintan

08:18.660 --> 08:20.660
这是GMT

08:20.660 --> 08:21.660
下面这个UTC

08:21.660 --> 08:23.660
它表示的是Universal

08:23.660 --> 08:26.660
Universal

08:26.660 --> 08:27.660
然后

08:27.660 --> 08:28.660
Time

08:28.660 --> 08:31.660
Coordinated

08:31.660 --> 08:32.660
Coordinated

08:32.660 --> 08:33.660
Coordinated 单词

08:33.660 --> 08:34.660
它表示协调的意思

08:34.660 --> 08:35.660
世界协调式

08:35.660 --> 08:36.660
这是宇宙的意思

08:36.660 --> 08:37.660
世界的意思

08:37.660 --> 08:39.660
世界协调式

08:39.660 --> 08:40.660
这两个单词

08:40.660 --> 08:41.660
平时我们对于

08:41.660 --> 08:42.660
我们开发者而言的话

08:42.660 --> 08:43.660
这两个东西

08:43.660 --> 08:44.660
你可以看成是一个玩意

08:44.660 --> 08:45.660
可以看成是一个玩意

08:45.660 --> 08:47.660
这是标准时间

08:47.660 --> 08:49.660
ok

08:49.660 --> 08:50.660
下面这个

08:50.660 --> 08:52.660
叫做时间戳

08:52.660 --> 08:53.660
时间戳

08:53.660 --> 08:55.660
它是一个数字

08:55.660 --> 08:56.660
一个数字

08:56.660 --> 08:57.660
它表示什么意思呢

08:57.660 --> 09:00.660
表示从1970年

09:00.660 --> 09:02.660
指的是零十区

09:02.660 --> 09:03.660
就隔离维制时间

09:03.660 --> 09:05.660
1970年1月1号

09:05.660 --> 09:07.660
就是元旦零层

09:08.660 --> 09:10.660
到某个时间

09:10.660 --> 09:11.660
某个时间点

09:11.660 --> 09:12.660
比方说到现在

09:12.660 --> 09:15.660
现在2019年6月8号

09:15.660 --> 09:16.660
6月18号

09:16.660 --> 09:18.660
到某一个时间

09:18.660 --> 09:21.660
所经过的毫秒数

09:21.660 --> 09:23.660
注意它是毫秒数

09:23.660 --> 09:24.660
那么这就是表示时间戳

09:24.660 --> 09:25.660
也就是因此

09:25.660 --> 09:26.660
我们说时间戳

09:26.660 --> 09:27.660
是一个数字

09:27.660 --> 09:28.660
当然你可以想象到

09:28.660 --> 09:30.660
肯定是一个很大的数字

09:30.660 --> 09:31.660
对吧

09:31.660 --> 09:32.660
一秒钟得于1000毫秒

09:32.660 --> 09:33.660
那从1970年

09:33.660 --> 09:34.660
到现在

09:34.660 --> 09:35.660
经过了这么长时间了

09:35.660 --> 09:36.660
肯定表的话

09:36.660 --> 09:37.660
都是一个很大的数字的

09:37.660 --> 09:38.660
还不要说毫秒

09:38.660 --> 09:39.660
肯定是一个很大的数字

09:39.660 --> 09:40.660
那么它为什么选择

09:40.660 --> 09:43.660
选择的是1970年1月1号呢

09:43.660 --> 09:45.660
这是一个历史的原因造成的

09:45.660 --> 09:47.660
当时是1971年的时候

09:47.660 --> 09:49.660
第一个操作系统

09:49.660 --> 09:50.660
叫Unix操作系统

09:50.660 --> 09:52.660
我们现在都用的是Windows

09:52.660 --> 09:53.660
什么iOS

09:53.660 --> 09:54.660
Windows

09:54.660 --> 09:55.660
Linux

09:55.660 --> 09:57.660
其实在这些操作系统之前

09:57.660 --> 09:59.660
还有一个操作系统

09:59.660 --> 10:00.660
单身很早

10:00.660 --> 10:01.660
在1971年单身的

10:01.660 --> 10:03.660
叫做Unix操作系统

10:03.660 --> 10:04.660
单身的时候

10:04.660 --> 10:05.660
当时贝尔实验室

10:05.660 --> 10:06.660
做这个操作系统

10:06.660 --> 10:07.660
是贝尔实验室做的

10:07.660 --> 10:09.660
这个操作系统单身的时候

10:09.660 --> 10:10.660
他们需要计时

10:10.660 --> 10:11.660
当时呢

10:11.660 --> 10:13.660
他们由于计算机的内存很小

10:13.660 --> 10:14.660
非常非常小

10:14.660 --> 10:15.660
还是一KB算的

10:15.660 --> 10:16.660
还不是现在

10:16.660 --> 10:17.660
多少G的内存

10:17.660 --> 10:18.660
它是一KB算的

10:18.660 --> 10:20.660
因此它内存里面空间

10:20.660 --> 10:22.660
那就必须要节约空间

10:22.660 --> 10:24.660
那它怎么来计时呢

10:24.660 --> 10:26.660
它就用一个时间搓来计

10:26.660 --> 10:27.660
就是我要经过的毫秒数

10:27.660 --> 10:28.660
多少毫秒

10:28.660 --> 10:30.660
用一个数字来表示时间

10:30.660 --> 10:31.660
因为我们知道

10:31.660 --> 10:32.660
计算机里边

10:32.660 --> 10:34.660
它什么东西都必须要用数字表示

10:34.660 --> 10:35.660
不然它没发办

10:35.660 --> 10:36.660
就像我们的文字

10:36.660 --> 10:37.660
要用编码

10:37.660 --> 10:38.660
对吧

10:38.660 --> 10:39.660
要用数字来表示

10:39.660 --> 10:40.660
包括时间也是

10:40.660 --> 10:42.660
它也得用一个数字来表示

10:42.660 --> 10:44.660
那么它就要选取一个参考点

10:44.660 --> 10:45.660
参考哪个时间

10:45.660 --> 10:47.660
当然肯定要精确一点

10:47.660 --> 10:48.660
对吧

10:48.660 --> 10:49.660
所以说它精确到毫秒

10:49.660 --> 10:50.660
那参考哪个时间呢

10:50.660 --> 10:52.660
它不能参考得太靠前

10:52.660 --> 10:53.660
因为太靠前的话

10:53.660 --> 10:54.660
当时的计算机的内存有限

10:54.660 --> 10:55.660
它那个数字呢

10:55.660 --> 10:57.660
是32位的数字

10:57.660 --> 10:58.660
给大家讲讲历史吧

10:58.660 --> 11:00.660
32位

11:00.660 --> 11:02.660
什么叫32位的数字呢

11:02.660 --> 11:03.660
就是它的这个数字

11:03.660 --> 11:04.660
二净字格式

11:04.660 --> 11:05.660
计算机里面数字的存处都是

11:05.660 --> 11:06.660
二净字格式

11:06.660 --> 11:08.660
32位就指的是

11:08.660 --> 11:09.660
32位的二净字

11:09.660 --> 11:10.660
就是这里

11:11.660 --> 11:12.660
有32位的

11:12.660 --> 11:14.660
它最多可以存32位

11:14.660 --> 11:16.660
它这样子约定了

11:16.660 --> 11:18.660
最多可以存32位的数字

11:18.660 --> 11:20.660
就这么个意思

11:20.660 --> 11:21.660
因此它存的数字的

11:21.660 --> 11:23.660
最大值就是有限的

11:23.660 --> 11:24.660
最大值是多少

11:25.660 --> 11:26.660
最大值是多少呢

11:26.660 --> 11:29.660
是2的32次方

11:30.660 --> 11:32.660
32次方

11:33.660 --> 11:34.660
2的32次方

11:34.660 --> 11:36.660
它在表示这个最大的数字

11:36.660 --> 11:38.660
所以说它一算

11:38.660 --> 11:39.660
这个时间

11:39.660 --> 11:41.660
如果选一个参考点的话

11:41.660 --> 11:43.660
它大概在

11:43.660 --> 11:45.660
68年后

11:45.660 --> 11:47.660
68年后就嫉妒不下了

11:47.660 --> 11:49.660
所以它选了参考点

11:49.660 --> 11:50.660
不能以公园什么

11:50.660 --> 11:51.660
公园零年

11:51.660 --> 11:52.660
对吧

11:52.660 --> 11:53.660
以公园为参考点

11:53.660 --> 11:54.660
它不能以这个为参考点

11:54.660 --> 11:56.660
如果以这个参考点的话

11:56.660 --> 11:57.660
它顶多到公园

11:57.660 --> 11:59.660
68年就结束了

11:59.660 --> 12:00.660
所以说

12:00.660 --> 12:01.660
它选择了一个比较靠后的参考点

12:01.660 --> 12:03.660
当时它就选择了

12:03.660 --> 12:05.660
当时是1971年

12:05.660 --> 12:07.660
它选择的是1970年

12:07.660 --> 12:09.660
1970年作为参考点

12:09.660 --> 12:10.660
1月1号

12:10.660 --> 12:12.660
以这个参考点来进行

12:12.660 --> 12:13.660
来进行推演这个时间

12:13.660 --> 12:14.660
于是呢

12:14.660 --> 12:16.660
它的最大的年份能到哪儿了

12:16.660 --> 12:17.660
它能到哪儿了

12:17.660 --> 12:19.660
它能到1970

12:19.660 --> 12:22.660
1970加上68

12:22.660 --> 12:23.660
到多少

12:23.660 --> 12:24.660
加算多少

12:24.660 --> 12:28.660
就是2038年

12:28.660 --> 12:29.660
到了2038年

12:29.660 --> 12:30.660
8年过后

12:30.660 --> 12:32.660
这个时间就要出问题

12:32.660 --> 12:34.660
只要到了2038年过后

12:34.660 --> 12:35.660
1月1号过后

12:35.660 --> 12:37.660
这个时间就会归零

12:37.660 --> 12:38.660
就会归零

12:38.660 --> 12:40.660
就是说2039年

12:40.660 --> 12:41.660
表示不了了

12:41.660 --> 12:42.660
到了2039年

12:42.660 --> 12:43.660
这个时间纯不下了

12:43.660 --> 12:44.660
它表示不了了

12:44.660 --> 12:45.660
当时没有想那么多

12:45.660 --> 12:46.660
当时68年

12:46.660 --> 12:48.660
它觉得68年的时间够长了

12:48.660 --> 12:49.660
因为68年里面

12:49.660 --> 12:51.660
肯定会发生一些技术变化

12:51.660 --> 12:52.660
能够解决这些问题

12:52.660 --> 12:53.660
没有想那么多

12:53.660 --> 12:55.660
于是到了2039年之后

12:55.660 --> 12:57.660
这个时间全部在清零

12:57.660 --> 13:00.660
2039年就相当于是1971年

13:00.660 --> 13:01.660
它时间在归零

13:01.660 --> 13:03.660
到时候时间会出问题

13:03.660 --> 13:04.660
但是没关系

13:04.660 --> 13:05.660
现在不用怕了

13:05.660 --> 13:06.660
为什么呢

13:06.660 --> 13:07.660
因为现在的计算机

13:07.660 --> 13:08.660
存储数字

13:08.660 --> 13:10.660
它不再是32位了

13:10.660 --> 13:13.660
现在用的是64位来存储

13:13.660 --> 13:15.660
用的是64位存储

13:15.660 --> 13:16.660
那64位就是

13:16.660 --> 13:17.660
2的64次方

13:17.660 --> 13:18.660
它不是两倍

13:18.660 --> 13:20.660
它不是100多年了

13:20.660 --> 13:21.660
64次方

13:21.660 --> 13:22.660
这个很恐怖的

13:22.660 --> 13:23.660
那到了多少呢

13:23.660 --> 13:24.660
这样说吧

13:24.660 --> 13:26.660
应该在2001年之后

13:26.660 --> 13:29.660
1970年到2001年之后

13:29.660 --> 13:30.660
2001年之后

13:30.660 --> 13:31.660
又地球爆炸了

13:31.660 --> 13:33.660
可能太阳都变成一个红爱心了

13:33.660 --> 13:34.660
变成黑冬了

13:34.660 --> 13:35.660
这个纪念都还不会结束

13:35.660 --> 13:37.660
所以大家不用担心

13:37.660 --> 13:39.660
不过这个习惯已经保留下来了

13:39.660 --> 13:40.660
因为很多系统

13:40.660 --> 13:42.660
都是以基于这个的时间点

13:42.660 --> 13:44.660
来进行记录时间的

13:44.660 --> 13:46.660
所以说这个习惯保留下来了

13:46.660 --> 13:47.660
因此我们现在的记录时间

13:47.660 --> 13:51.660
都是从1970年1月1号来记录

13:51.660 --> 13:53.660
我们把它叫做时间戳

13:54.660 --> 13:56.660
这是关于这个数语

13:56.660 --> 13:57.660
我们了解一下这些数语

13:57.660 --> 13:59.660
然后我们再来说戴扯

13:59.660 --> 14:00.660
关于这个戴扯

14:00.660 --> 14:01.660
怎么来处理时间

14:02.660 --> 14:04.660
接下来我们来说戴扯

14:05.660 --> 14:06.660
我们首先说

14:06.660 --> 14:10.660
如何创建时间对象

14:10.660 --> 14:12.660
就是利用这个构造函数

14:12.660 --> 14:13.660
来创建时间对象

14:13.660 --> 14:14.660
而这个构造函数

14:14.660 --> 14:16.660
它是可以直接用的

14:16.660 --> 14:18.660
也就是说你可以不写6

14:18.660 --> 14:19.660
你可以不写6

14:19.660 --> 14:21.660
它可以直接用

14:21.660 --> 14:24.660
直接调用函数

14:24.660 --> 14:25.660
就是不使用6

14:25.660 --> 14:27.660
不使用6关键词

14:27.660 --> 14:29.660
那么这种情况

14:29.660 --> 14:31.660
它会忽略所有的参数

14:31.660 --> 14:33.660
忽略所有参数

14:34.660 --> 14:35.660
我们尽量不要用这种方式

14:35.660 --> 14:36.660
这种方式

14:36.660 --> 14:38.660
讲了解一下就行了

14:38.660 --> 14:39.660
忽略构造函数里面

14:39.660 --> 14:40.660
所有的参数

14:40.660 --> 14:41.660
直接返回

14:41.660 --> 14:44.660
当前时间的制服串

14:44.660 --> 14:45.660
返回一个制服串

14:45.660 --> 14:47.660
咱们来举个例子

14:47.660 --> 14:49.660
这里新建个一面

14:50.660 --> 14:52.660
直接写出来

14:52.660 --> 14:54.660
我们就在控制台里面写吧

14:54.660 --> 14:55.660
运行出来

14:55.660 --> 14:59.670
看着咱们

14:59.670 --> 15:02.670
我们这里直接使用函数

15:02.670 --> 15:04.670
直接调用函数

15:04.670 --> 15:05.670
直接回车

15:05.670 --> 15:07.670
得到了一个制服串

15:07.670 --> 15:09.670
这个制服串怎么来读呢

15:09.670 --> 15:11.670
首先是中国标准时间

15:11.670 --> 15:12.670
它会把它

15:12.670 --> 15:14.670
这个我们时间

15:14.670 --> 15:16.670
得到了都是零时区

15:16.670 --> 15:17.670
就是隔离位置时间

15:17.670 --> 15:19.670
但是它显示出来了

15:19.670 --> 15:20.670
它会把它阻碍

15:20.670 --> 15:21.670
换成

15:21.670 --> 15:22.670
就是我们东巴区的时间

15:22.670 --> 15:24.670
因为我们目前的操作系统

15:24.670 --> 15:26.670
它是读的操作系统

15:26.670 --> 15:27.670
咱们操作系统

15:27.670 --> 15:29.670
使用的是中文操作系统

15:29.670 --> 15:31.670
并且设置的时区

15:31.670 --> 15:32.670
设置的是东巴区

15:32.670 --> 15:33.670
我们是可以设置的

15:33.670 --> 15:34.670
你看

15:34.670 --> 15:35.670
这里的时间

15:35.670 --> 15:37.670
这个调整日期时间

15:37.670 --> 15:38.670
看没有

15:38.670 --> 15:39.670
这里是可以设置的

15:39.670 --> 15:40.670
看 时区这里

15:40.670 --> 15:41.670
是可以设置的

15:41.670 --> 15:43.670
它是按照操作系统的时间来的

15:43.670 --> 15:44.670
因此这里得到了

15:44.670 --> 15:45.670
是东巴区的时间

15:45.670 --> 15:46.670
怎么来读

15:46.670 --> 15:47.670
Tuesday

15:47.670 --> 15:48.670
对吧

15:48.670 --> 15:49.670
Tuesday

15:49.670 --> 15:50.670
Tuesday

15:50.670 --> 15:51.670
星期二

15:51.670 --> 15:52.670
Tuesday

15:52.670 --> 15:53.670
星期二

15:53.670 --> 15:54.670
今天是星期二

15:54.670 --> 15:55.670
Tuesday

15:55.670 --> 15:56.670
表示六月

15:56.670 --> 15:57.670
对吧

15:57.670 --> 15:58.670
六月十八号

15:58.670 --> 16:00.670
2019年

16:00.670 --> 16:01.670
17点

16:01.670 --> 16:02.670
50分

16:02.670 --> 16:03.670
57秒

16:03.670 --> 16:08.670
然后这里有个 GMT

16:08.670 --> 16:09.670
表示的是

16:09.670 --> 16:10.670
隔离位置时间

16:10.670 --> 16:11.670
加上08

16:11.670 --> 16:12.670
08

16:12.670 --> 16:13.670
后边有两个精确的位数

16:13.670 --> 16:14.670
00

16:14.670 --> 16:15.670
表示的是东巴区

16:15.670 --> 16:16.670
看没有

16:16.670 --> 16:17.670
它是用这样的一个

16:17.670 --> 16:22.430
中国标准时间 用这样的一个标准的字幕说格是来表示这么一个时间

16:22.790 --> 16:24.870
这是直接调用这个函数 大家注意一下啊

16:25.910 --> 16:34.030
就调用这个函数 那里传参数是没用的啊 比方说你传2015年1月2号 你这样子写 你看没用 他还是得到的是当前时间

16:34.670 --> 16:40.550
一个参数呢 是会直接被忽略的 直接返回当前时间的字幕串 这种方式呢 我们不太会用

16:41.350 --> 16:42.350
不太会用这种方式

16:43.150 --> 16:44.350
好吧 我们说一下后边了

16:45.350 --> 16:53.190
好 new date new date 好 用这种方式来创建一个日期对象 这是创建日期对象

16:54.550 --> 17:02.230
那对象里边说的就各种属性 各种方法可以使用了 对吧 创建日期对象 这是创建日期对象

17:02.710 --> 17:10.190
好 这个对象呢 这个构造函数里边是可以写参数的啊 我们这里主要说一下这个创建参数的写法

17:10.910 --> 17:13.430
如果第一种情况是没有参数 无参

17:14.510 --> 17:20.750
无参的话得到的是当前时间啊 当前时间的对象 所以它是对象啊 不是字幕串 看一下呗

17:22.190 --> 17:24.830
比方说咱们呢 订一个变量 new date

17:26.150 --> 17:31.510
创建一个日期对象 得到的就是当前时间啊 我们来看一下这个地啊 这个地

17:32.950 --> 17:37.710
他输出的是一个字幕串啊 他相当于是什么呢 相当于是我们地点突出

17:38.670 --> 17:45.910
你看 相当于是调用了地点突出运啊 他有一个转换成字幕串的方法 对吧 我们之前说过啊 这个方法呢 是可以覆盖

17:46.230 --> 17:53.830
op几个车的 这是op几个车的方法啊 是可以覆盖掉的 我们日期对象这里呢 他有一个成员 成员方法就是

17:54.110 --> 17:58.470
突出运 他覆盖了op几个车的方法 因此他得到这么一种标准格式

17:59.430 --> 18:03.750
其实你直接看了一下这个地的 地的指呢 他得到的就是一个字幕串格式

18:04.390 --> 18:08.470
当然他里边还有很多的成员 他是个对象啊 得到的就是当前时间

18:09.110 --> 18:16.750
好 那有没有其他的情况呢 如果是一个参数 一个参数参数为数字 参数必须要为数字

18:18.270 --> 18:23.390
那么如果是一个参数的话 表示的是什么呢 表示的是传入的是

18:24.150 --> 18:32.830
时间戳 传入的是时间戳 比方说什么意思呢 看看一下一个例子啊 还是这个变量地给他复职

18:33.310 --> 18:36.310
6一个戴子 我们这里写上一个1000

18:37.590 --> 18:45.550
1000是多少 是不是一秒钟 对吧 1000毫秒 指的是什么意思呢 指的是从1970年1月1号凌晨

18:46.710 --> 18:55.670
到啊 就是加上1000毫秒 加上1000毫秒 得到了时间 我们来看一下这个时间得到了结果 看一下这个结果

18:56.190 --> 19:05.390
就是1970年啊 January啊 就是1月1月1号啊 这是经济级啊 Thursday对吧 星期三

19:06.670 --> 19:13.350
然后呢 1月1号对不对 为什么是8点呢 不是凌晨吗 一向转换成东巴区的时间是不是8点

19:13.950 --> 19:17.470
格令位置时间是凌晨 但是东巴区的时间是不是8点钟 对不对

19:18.430 --> 19:23.350
8点钟 然后一秒钟 看没有 多了一个一秒 这个一秒哪来的 就是这里

19:23.990 --> 19:31.910
啊 就这里啊 你看这意思吧 那如果能不能传复数呢 可以传复数啊 这里是可以传复数的 那就往前推呗

19:32.190 --> 19:40.870
那就往前推啊 你看一下 得到是什么呢 得到是1970年啊 本来是啊 如果是格令位置时间的话 就是1969年了

19:41.630 --> 19:50.030
1969年最后一天快要接近凌晨了 对吧 快马上经过一秒过后就接近凌晨了 但是东巴区的时间还是1970年

19:50.430 --> 19:54.070
转换成东巴区的时间 就是7点59分59秒

19:55.550 --> 19:58.870
另外这个意思吧 比方说我们还可以写复数 敢多写几个零

20:00.190 --> 20:06.750
那么就是1969年多少多少多少 这就是传一个参数的情况 这里是填的是时间戳

20:07.550 --> 20:13.670
好吧 这是第一个啊 就是一个参数 好 两个参数呢 两个参数

20:14.670 --> 20:25.470
几多个参数 就是两个参数以上 两个参数以上 那么他表那些参数呢 表示的是什么意思呢 分别表示

20:26.830 --> 20:33.470
连月日时分秒

20:34.310 --> 20:42.670
分别表示连月日时分秒 还有个好秒 好秒 分别表示这些东西 当然你可以写全也可以只写一部分 咱们来看一下

20:43.910 --> 20:52.750
六 两个参数 以及多个参数 二零一五年五月一号啊 二零一五年五月一号 注意这里的时间 用的是

20:53.590 --> 21:00.510
东巴区的时间 用的是东巴区的时间 二零一五年五月一号 然后十三点

21:01.190 --> 21:05.430
14分15秒200毫秒 看一下

21:06.230 --> 21:09.390
200毫秒 你看得到就这个 二零一五年

21:09.990 --> 21:10.110
啊

21:11.150 --> 21:20.270
就啊 哦 这里不是五啊 这里是六 我们之后再说啊 这个月份是从零开始的啊 月份是从零开始的 我现在说一下吧

21:21.110 --> 21:22.430
这里说一下 注意

21:23.710 --> 21:28.070
这是比较容易翻出的地方 月份的数字

21:28.990 --> 21:36.150
从零开始啊 计算 比方说我们这里写一指的是二月啊 写二呢指的是三月

21:36.830 --> 21:42.230
他为什么写零呢 指的是一月 他为什么要这样子呢 因为在英文的世界里边

21:43.430 --> 21:44.670
从来没有一种说法

21:45.590 --> 21:52.110
用数字来表示月 数字表示月是中文环境里边的说法 是我们说一月二月三月对吧 用数字来表示月

21:52.470 --> 22:00.350
但是在英文的世界里边从来没有用数字来表示过月 他们的文化习惯不同 他们表示月的是用单词 对吧 单词

22:00.990 --> 22:12.070
一月呢 是什么 January February 什么 March 对吧 May April 对吧 四月 妹 五月 九 六月 七月了 九奈 对吧 August 还是什么

22:12.350 --> 22:14.270
October 10月

22:15.310 --> 22:18.990
Lovember 11月 December 12月 他是用单词来表示的

22:19.630 --> 22:22.550
因此他转移换到数字的时候呢 他从零开始的啊

22:23.390 --> 22:28.030
但是我们中文世界里面是用数字来表示月份的 这里有差异啊 大家注意一下

22:28.350 --> 22:40.030
我这里写的五呢 实际上表示的是六月啊 六月一号啊 六月一号 你看东巴区的时间13点14分15秒 这里没有显示毫秒啊 这里没有显示毫秒 那如果你要显示毫秒 咋办呢

22:40.750 --> 22:48.990
你要显示毫秒 这样子写啊 这样子写 D2ISO Street 我们之后会说这个函数啊

22:49.510 --> 22:57.750
ISO Street 这个函数呢表示的意思呢 就是把它转换成国际标准 就是ISO是个国际标准组织 对吧

22:58.070 --> 23:03.270
这个国际标准组织里面规定的日期格式 转换成这种规定的日期格式

23:03.950 --> 23:10.710
啊 转换出来就这样子啊 当然他得到的是啥呢 得到的是零时区的数据啊 得到的是零时区的

23:11.270 --> 23:19.870
你看本来写的是13点对吧 减了8 减8是不等于5 凌乘5点啊 得到的是零时区的日期

23:20.710 --> 23:24.910
好吧 但是那你可以看到这个200毫秒在这 200毫秒在这

23:25.270 --> 23:35.230
你看前面是年月日 中间一个T呢 表示后边是时间啊 这是零成5点14分15秒 然后200毫秒 后面加了一个Z

23:35.790 --> 23:35.910
Z

23:37.070 --> 23:45.670
你看这意思吧 这是国际标准组织规定的时间格式啊 这个用的比较少啊 了解一下就行了 我们通可以通过它呢来得到这个毫秒数 可以看到这个200毫秒

23:46.670 --> 23:50.470
好吧 都是这一个 两个参数以上 他是怎么回事

23:51.230 --> 24:02.310
好 那如果你写两个参数以上 你可不可以不写呢 可不可以缺失 就是缺失一些数据呢 可以 可以缺失一些数据 比方说我们后边不写

24:03.470 --> 24:12.510
我只写一个联合月啊 只写一个联合月 那后边东西怎么办呢 我们来看一下这个D点 to iso stream

24:13.510 --> 24:19.710
看一下这个后面的东西怎么办 他怎么办的呢 我们不用他吧 我们还是用to stream

24:20.870 --> 24:30.750
看一下 后边东西呢 他全部补充零 日期部分呢 就是默认值为1 就是1号嘛 某个月的1号 对吧 某个月的1号

24:31.110 --> 24:36.870
好 那么后边呢 就全部是零 小时是零 分钟是零 秒是零 毫秒也是零

24:37.470 --> 24:53.070
好 所以说咱们记一笔 就是如果缺失缺失参数 日期部分默认为1 其他就是什么 就是十分秒

24:54.870 --> 24:59.910
毫秒默认为零 如果你缺失了这参数 他的默认值就是零

25:00.910 --> 25:05.390
那有些朋友说 那我能不能缺失 能不能缺失这个约呢

25:06.950 --> 25:12.950
同学 如果你缺失了约会变成什么 变成什么了 缺失了约是不是一个参数的情况

25:14.310 --> 25:20.950
一个参数的情况 这里传的是时间戳 这里传的是时间戳 看到没 还在1970年

25:21.710 --> 25:31.590
一穿越了 得不到2015年的 瞄到意思吧 好吧 这是关于这个NewDate 这个函数怎么用 它这参数是什么意思

25:32.670 --> 25:38.710
好 这里面呢 还有一个点我要说一下 可以传递附属 可以传递附属

25:40.270 --> 25:50.230
就是 月 日 时 分 秒 毫秒 均可以传递附属

25:51.270 --> 26:00.310
如果传递附属的话 如果传递附属 会根据当前日期进行计算

26:00.830 --> 26:08.030
计算 不是当前日期 会根据指定日期进行计算 比方说咱们举个例子

26:09.350 --> 26:14.910
还是一个变量地 NewDate 2015年

26:15.910 --> 26:18.470
然后呢 这里我写个副一月

26:20.150 --> 26:26.270
副一月 月份是从零开始的 对吧 那零表示一月嘛 副一月是啥意思呢 看一下

26:27.110 --> 26:30.510
他就表示的是2014年12月

26:31.630 --> 26:36.830
12月1号 12月1号就减了一个月了 明儿这个意思吧 就减了一个月

26:37.270 --> 26:43.550
那当前年份上减一个月 好 那比方说我们写的205年2月

26:44.110 --> 26:50.230
负一天 负一天 什么意思呢 就是变成了2月的27号 看到没

26:51.230 --> 26:57.670
减了一天 减了一天 本来是2月1号的 本来是2月1号的 但是我这里写的是

26:58.310 --> 27:02.350
本来是3月1号的 本来是3月1号的 但是我这里写的是负一

27:02.870 --> 27:08.670
表示什么呢 表示我减了两天 减了两天 因为如果我写零的话

27:09.950 --> 27:13.790
如果我写零的话 是减一天 看没有 2月28号

27:14.390 --> 27:20.550
28号是减一天 因为日期部分是从一开始的 对吧 一开始的 你写零的话

27:20.790 --> 27:24.830
表示减一天 写负一的话 表示减两天 明儿这个意思吧

27:25.430 --> 27:31.430
相当于是减了两天 就这里的是可以写负数的 那么十分秒了 毫秒是一样的 是一样的

27:32.190 --> 27:36.870
好了 目前呢 我们讲了如何来创建一个日期对象

27:38.030 --> 27:43.550
好了 那么接下来 咱们就来看这个对象里边有哪些东西可以用了啊 这个对象里边有哪些东西可以用

27:44.270 --> 27:46.350
好 咱们来看一下它的成员

27:47.910 --> 27:52.950
就是实力成员 就创建对象过后 这个对象里边哪些东西可以用 哇 这里面的东西太多了

27:54.350 --> 27:58.710
啊 就是日期 它可以提供了非常丰富的使用方式

27:59.710 --> 28:00.710
好 看一下啊 来面点

28:02.790 --> 28:04.990
主要看那个成员啊 主要看那个成员

28:08.910 --> 28:09.910
好 这里

28:10.910 --> 28:16.670
好 一个来吧 一个来 首先是个get date get date 得到一个对象的

28:17.630 --> 28:21.550
某一月中的哪一天 某一月中的哪一天 它的取之半位是一到三十一

28:21.950 --> 28:25.670
一个月还不可能有三十二天吧 对吧 也不可能有零天吧 得到

28:26.310 --> 28:32.790
这一天是这一个月的第几天 就是日期部分 得到日期部分 get date

28:34.270 --> 28:35.270
这是方法

28:38.870 --> 28:42.110
得到日期部分 保存看一下

28:43.670 --> 28:51.270
比方说啊 咱们有一个时间 get date get date 得到日期部分 你看 二十七 二月二十七嘛

28:51.470 --> 28:54.070
啊 所以说得到二十七 比方这一次吧

28:54.870 --> 29:01.470
啊 我们这里最好把这里写出来啊 方便我们 方便我们调用测试 我们这里随便写个d new date

29:02.110 --> 29:04.790
得到当前日期吗 得到当前日期 好 再来看啊

29:05.390 --> 29:11.190
d get date 啊 今天呢 我们得到的是18号啊 6月18号嘛 所以这里得到的是18

29:12.630 --> 29:19.830
好 然后呢 它有个对应的叫做get utc date 啊 看一下get utc date

29:20.230 --> 29:27.910
你看我们后边讲了一些函数啊 怎么得到时 得到小时 得到分钟 得到秒 得到毫秒 都有这个加一个 utc中间

29:28.710 --> 29:32.710
utc是什么呢 得到了是隔离微质 就是零时区的那个

29:33.590 --> 29:39.910
日期啊 它把它换成零时区 我们目前是东巴区嘛 换成零时期 就是在隔离微质那一块

29:40.390 --> 29:43.910
它是什么时间啊 指的是这么个意思 他目前的也是18号

29:44.710 --> 29:49.430
明白这个意思吧 我们后边就不说了啊 因为我们平时很少用这个 但是你要知道就行了

29:49.670 --> 29:54.150
那么后面我们说得到小时得到分钟了 都有加这个东西的啊 都有这个加utc的

29:55.430 --> 29:58.870
好 这是关于get date啊get date啊get date啊get date

30:00.310 --> 30:08.230
下面这个 记住一笔啊get date 方法 它得到的是星期啊 得到了星期

30:09.990 --> 30:18.310
我们看一下get date 是得到这个星期中的第几天 它的曲子范围是零到六 星期天是零啊 大家注意一下啊

30:18.550 --> 30:29.110
星期天是零 得到当是星期几啊 得到星期几啊 零表示星期天

30:30.790 --> 30:37.910
好 我们平时 我们中国喜欢的表示方式是零 星期天那表示七 对吧 但是它呢 是用零来表示的 这是国外的

30:38.230 --> 30:49.510
习惯啊 第get date啊 今天星期几呢 调用啊 调用 得到星期几呢 星期二啊 今天是星期二 零呢 表示星期天啊 如果是星期天的话就是零

30:50.230 --> 30:55.590
好 是get date啊 好 下面这个get full year啊get full year 得到

30:56.550 --> 31:03.110
完整的连份 它为什么有个full呢 因为它以前呢有一个get year啊 我们来查一下get year

31:03.910 --> 31:12.150
但是现在的已经不再推荐使用了啊 因为以前呢 它只得到两到三位数的数字来表示年 因为年呢以前

31:13.270 --> 31:20.310
像尽量用少的存储啊来表示一个年 不像把个数字变多了 尽量因为以前的内存很吃紧

31:20.630 --> 31:28.070
所以说的尽量用少的连份存储 但是呢现在呢没关系了啊 现在我们计算就内存大得很 完全那一点东西完全不用考虑的

31:28.230 --> 31:32.710
所以说我们直接使用get full year啊 得到完整的四位数的连份

31:33.350 --> 31:37.990
好 我们来看一下啊 get full year 方法

31:38.870 --> 31:41.830
得到连份 得到连份 保证看一下啊

31:43.110 --> 31:49.270
这边 第2get full year 看一下今年是哪一年 2019年 一个数字啊 这是数字

31:50.790 --> 31:57.030
好 再往下看啊 get hours 表示什么意思呢 得到当前这个日期对象的小时部分

31:57.510 --> 32:00.710
get hours 方法 得到小时

32:01.670 --> 32:02.390
小时部分

32:03.750 --> 32:04.790
好 保存看一下啊

32:05.910 --> 32:13.910
第2get hours 得到小时 目前呢是18点了啊 就是下午时间18点

32:15.030 --> 32:19.030
啊 就是24小时字啊 24小时字 好 然后呢

32:19.670 --> 32:22.150
还有什么呢 我们就一次说了啊 get minutes

32:22.710 --> 32:25.190
minutes 得到分钟 18.07分

32:25.750 --> 32:28.630
好 然后呢 还有什么get seconds

32:29.110 --> 32:34.310
second 秒 56秒啊 然后呢 get many seconds

32:35.030 --> 32:38.790
minutes seconds 得到什么好秒部分啊 目前呢是2毫秒啊

32:39.350 --> 32:42.630
得到好秒部分啊 不是目前啊 不是当前 因为

32:43.590 --> 32:46.390
是这个日期啊 得到这个日期对象 这是

32:46.870 --> 32:52.150
创建这个 就是运行这个代码的时候 它的日期是多少 那么这个对象里面保存的日期

32:52.470 --> 32:56.790
后面不会变化了啊 不是说去随着时间的变化 它会跟着变化不会的

32:57.270 --> 33:01.110
它是运行这个代码的时候 得到了日期 它就已经固定下来了

33:01.510 --> 33:04.790
啊 如果你要得到一个新的日期的话 你要重新去创建对象来得到

33:05.430 --> 33:07.670
明白吧 啊 比方说我们重新创建一个

33:08.790 --> 33:12.710
这里 关闭啊 第new date 又重新创建一个日期

33:13.270 --> 33:18.070
运行这个代码啊 就把当 就把运行这个代码的时候的时间保存到了这个对象里边

33:18.390 --> 33:21.510
啊 我们再看一下get many seconds

33:22.070 --> 33:23.270
啊 979

33:25.030 --> 33:28.390
好 这是关于这几个函数啊 咱们把记忆

33:29.990 --> 33:31.350
get manage

33:33.350 --> 33:35.590
得到分分钟部分

33:36.870 --> 33:37.990
get seconds

33:39.510 --> 33:41.670
得到秒啊部分

33:42.550 --> 33:43.910
get many

33:45.990 --> 33:46.550
second

33:48.950 --> 33:50.470
得到毫秒部分

33:51.430 --> 33:53.350
好了 这是这么几个啊 这么几个方法

33:54.950 --> 33:59.350
好了 那我们再来看啊 它里边还有哪些东西呢 还有这个东西叫get time

33:59.910 --> 34:00.390
get time

34:00.950 --> 34:03.750
好get time呢 是得到的是时间戳

34:05.110 --> 34:05.830
get time

34:06.950 --> 34:10.870
方法得到时间戳 有的是这个东西非常有用

34:10.870 --> 34:13.990
你可能觉得时间税有啥用了 有的是非常有用

34:14.550 --> 34:16.630
特别是计算两个日期之间的差

34:17.510 --> 34:21.270
我们就可以用时间戳来相减 就得到它相差的好秒数

34:22.230 --> 34:28.230
这是得到时间戳 咱们来看一下啊 我们目前这个时刻get time得到的时间戳是多少呢

34:28.790 --> 34:34.390
也就是1970年1月1号到现在呢 经过了这么多好秒 一共经过了这么多好秒

34:35.350 --> 34:38.870
这是按零时去来算的啊 时间戳全是按零时去来算的

34:39.750 --> 34:41.350
好 这是关于这个get time

34:41.830 --> 34:48.790
好 下面呢就是全是得到零时去的什么日期啊 day啊 four year啊 都是一样的了啊 都是得到零时去的

34:49.590 --> 34:56.150
好了 这是前面的get得到某一些东西啊 get得到某些东西 下面呢是设置

34:57.190 --> 34:58.230
设置某一些东西

34:58.950 --> 35:03.910
好 我们来看一下设置啊 其实是对应的啊 设置呢就是设置日期中的某一个部分

35:04.230 --> 35:11.270
它的值是多少 好 第一个呢是set date啊 set date 表示设置日期 就是设置日期部分

35:11.430 --> 35:15.270
就设置天子的一部分 set date 方法

35:15.990 --> 35:20.310
设置日期 你看这是对应的对吧 set date 啊 咱们来看一下啊

35:20.870 --> 35:26.950
比方说目前呢 我们这个日期呢是多少呢 是2019年6月18号对吧

35:27.350 --> 35:32.230
好 咱们呢 我们把这个18啦改成17 我们来看一下啊 d set date

35:33.350 --> 35:35.350
改成17啊 改成17

35:36.150 --> 35:39.990
啊 改成17过后了 它反回的是什么 反回的是新的时间的

35:40.230 --> 35:43.670
就设置之后这个日期的时间戳 我们再看一下这个日期

35:43.990 --> 35:48.150
这变成17号了 对吧 就设置日期部分啊 非常非常简单

35:48.470 --> 35:52.070
那这里呢 我们可以设置为复数啊 复一 就表示这个月

35:53.270 --> 35:59.590
减 就是在1号之前减两天啊 减两天 设置为零呢 就是减一天 对吧 减一天

35:59.830 --> 36:04.470
那么咱们来看一下啊 这个d 就变成了5月的31号 看到没

36:05.030 --> 36:08.390
啊 变成了5月的31号啊 就这么简单啊 非常非常简单

36:08.950 --> 36:10.470
好 这是set date啊 set date

36:12.570 --> 36:18.010
哦 前面我们还少写一个啊 还少写一个啊 guess months啊 guess months 还没有说

36:18.890 --> 36:22.010
得到月 注意啊 是从零开始计算的

36:23.690 --> 36:28.490
月是从零开始计算的啊 比方说前面 我们 d guess months

36:29.210 --> 36:33.610
得到月 你看明明是6月 但是得到的是5啊 是从零开始计算的

36:34.170 --> 36:42.090
那么同样的道理呢 我们可以设置月啊 设置月 set months 方法 是设置月份

36:43.130 --> 36:46.810
设置月份 同样的可以设为复数啊 复数呢 就是往去年

36:47.210 --> 36:52.010
就是就今年的1月往去年再减一个月啊 就再减一个月就跑到去年去了

36:52.570 --> 36:54.890
好 比方说啊 d set months

36:55.370 --> 37:00.810
比方说我们设置为多少月呢 设置为2月啊 设置为2月好 看一下这个d

37:01.530 --> 37:07.690
不是2月应该设为1对吧 2月经常写出啊 包括我也经常写出 说大家注意一下

37:08.570 --> 37:10.730
2月设置为1 February February

37:11.610 --> 37:16.090
ok 那么就是2月了 好 这是关于设置月啊 设置月

37:16.730 --> 37:20.410
好 然后呢 我们再来看啊 6 4 year 设置年

37:22.330 --> 37:29.530
6 4 year 方法啊 这个也没什么好说的啊 设置年 好 保存看一下啊 我们这里呢 把它设置为

37:31.370 --> 37:34.730
d sets year 4 year 4 year

37:35.770 --> 37:43.130
好 把它设置为0 看一下啊 把它设置为0 得到结果是什么呢 得到结果就是公元00000啊 公元零年

37:44.170 --> 37:50.330
好 当时呢是星期天啊 当时呢公元零年6月18号是星期天 蛮奇妙的一种感觉 是吧

37:51.130 --> 37:56.970
好 然后呢 这里呢 我们还可以把它设为复数啊 设为复数 就是公元前吧 公元前

37:57.370 --> 38:04.810
2022年啊 2022年2022年是啥 我记得是198年啊 公元前19

38:05.610 --> 38:11.530
198年 好像是什么 山谷毛炉 是吧 以前玩一个游戏 山谷这里的游戏啊 有点忘了啊 这时间

38:12.490 --> 38:14.810
啊 这是公元前的某一天啊 当天是星期五

38:15.930 --> 38:23.610
好 这是设置年啊 其实这个函数呢 他还可以用作啊 他还可以就是设置多个参数 就是set four year

38:24.490 --> 38:33.610
还可以设置年 比方说20000年5月1号啊 重新设置年月日还可以 还可以重新设置年月日 看没有

38:34.010 --> 38:39.850
啊 这里是变成6月1号了啊 老是忘记啊 老是忘记 这是6月1号啊 还可以设置年月日

38:41.210 --> 38:47.850
这是这个啊 set four year six hours six minutes seconds six minutes 是不一样的 对吧

38:48.570 --> 38:55.210
一样的啊 set months set seconds 啊一样的啊 咱们就一次写了啊 还有这么一些set minutes

38:56.170 --> 39:02.010
啊 minutes啊 不说了吧 不用说了啊 你们下去自己去试验一下啊 set seconds set many

39:02.970 --> 39:08.570
mini seconds 我这里就把它记录到这样就行了啊 还有一个set months 写到的

39:09.610 --> 39:14.330
还有set time啊 set time 就设置时间戳 重新设置时间戳

39:14.410 --> 39:18.810
啊 重新设置时间戳

39:20.650 --> 39:28.090
啊 那么这样子呢 他就用一个新的时间戳来覆盖之前的时间了 保存啊 看一下啊 主要是看一下set time

39:28.730 --> 39:34.410
好 第一点set time 比较说这为一啊 他又变成了什么 变成了1970年了

39:35.450 --> 39:42.410
好 ok啊 这是关于这些设置啊 那么对应的他也有设置utc 就是你设置的时间呢 是一个临时区的

39:42.730 --> 39:49.610
隔离微制时间啊 是世界标准时啊 你可以用这个utc的方式 不过我们平时呢 一般都是开发的本地系统

39:50.490 --> 39:57.130
开发的就是本地的 就是按照你计算机环境里面的系统 那么我们一般都是使用的 就是这种方式 上面的这种方式

39:57.770 --> 40:05.050
好吧 这是关于 他有个set year啊 这个set year呢 这个不要用啊 已经已经不再推荐使用了啊

40:06.090 --> 40:08.330
好 下面啊 下面是

40:09.290 --> 40:14.090
转换成制补创啊 转换制补创 他有很多的就是转换方式

40:14.970 --> 40:24.490
啊 我们一个个看吧 首先是这个转换制补创啊 to death stream 他什么意思呢 下面这个啊 下面这一坨都是转换制补创的 to death stream

40:25.050 --> 40:29.930
方法 他是转换为啊 转换为什么呢 转换为

40:31.770 --> 40:37.130
日期啊 将日期部分啊 将日期部分转换为

40:38.890 --> 40:40.570
可读的制服创

40:42.250 --> 40:43.530
好 看一下 看一下这个方法

40:45.050 --> 40:53.850
D to death stream啊 这个方法 你看 他只是转换了日期部分 看没 他只是转换了日期部分

40:54.890 --> 41:05.770
好 下面这个 to iso stream 他是用 iso的这个8601啊 iso里边每一个就是标准啊 他就有个编号 他是按照这个标准

41:06.250 --> 41:14.570
来进行转换为这个标准格式的制服创啊 to iso stream啊 这个用的很少啊 我们了解一下 因为不太符合中国人的阅读习惯

41:16.010 --> 41:19.850
这是转换的这种标准的制服创啊 to iso

41:20.650 --> 41:22.570
记下吧 to iso stream

41:24.970 --> 41:32.730
啊 将日将整个对象转换为 iso标准的制服创格式

41:33.450 --> 41:35.610
他这么一回事 好 下面再看啊

41:37.050 --> 41:47.850
下面再看 这个不太使用了啊 不推荐使用了 因为这个gmt呢 他现在推荐使用的是utc啊 推荐使用的是utc 我们一会看到 可以看到 好这个

41:48.570 --> 41:53.130
to locale locale是表示什么意思 表示本地的 就是根据你操作系统

41:53.610 --> 41:57.450
你是中文操作系统 他就按照中文的表达方式来转换成日期制服创

41:58.170 --> 42:07.990
我们看一下这个函数 to stream这个方法啊 将日期部分只转换日期部分啊 转换为可读的

42:09.270 --> 42:09.670
制服创

42:11.830 --> 42:20.870
应该这样说 前面加一个句 根据当前系统 就是你这个网页在哪个在哪个计算机运行的 那么就根据哪个计算机的

42:21.910 --> 42:25.510
日期展示方式来进行转换 因为当前系统的设置

42:26.150 --> 42:31.030
地区设置 将这个日期呢 转换成可读的制服创 好 我们来看一下这个

42:32.550 --> 42:41.750
d to locale locale 本地的日期制服创 你看一下 是不是更加好阅读了 咱们中国人的阅读习惯是这样子 对吧

42:42.630 --> 42:52.550
好 再看我们下面的啊 好 to locale stream 表示的是将整个日期 刚才是只转换了日期部分啊 没有包含10分秒 那么现在下面这个方法呢

42:52.950 --> 42:56.870
是根据当前系统的地区设置 凡是你加了这个东西

42:57.830 --> 43:08.550
凡是加了这个locale 都表示的是根据当前的地区的设置啊 然后呢 将整个日期对象转换为可读的制服创

43:10.390 --> 43:11.190
好 看一下

43:12.150 --> 43:29.270
d to locale stream 你看 它就包含了什么连月日啊 还有加上一个中文下午 对吧 因为我们是中文操作系统 所谓的到的是中文下午六点钟 是不是更加符合我们中国人的阅读习惯 对吧

43:29.590 --> 43:38.390
就这么个意思啊 好 然后下面这个是根据时间的啊 根据时间的 你看这看名字就知道什么意思了啊 你猜这啥意思

43:38.790 --> 43:46.550
根据当前系统的地区设置啊 将整个日期啊 将日期 将时间部分

43:47.670 --> 43:51.270
啊 它只转换时间啊 将时间部分

43:52.550 --> 43:57.510
转换为可读的制服创啊 是这么个意思 老师们看一下啊 d点 to

43:59.670 --> 44:03.030
什么locale locale time stream

44:03.990 --> 44:07.510
啊 看 指得到时间部分 好 下面再个啊

44:08.790 --> 44:15.270
to stream啊 to stream的话 它默认的情况下呢 就是这个跟这个是一样的啊 to utc stream 是一样的

44:16.070 --> 44:21.670
指的是什么呢 把一个日期对象转换为以utc这种计时标准的 就是制服创格式

44:22.390 --> 44:25.750
你看一下 d点 to utc stream

44:26.470 --> 44:30.310
啊 这这种格式 然后to stream呢 你看

44:31.350 --> 44:39.750
是不是一样的啊 差不多的吧 是一样的啊 有一些微 有一些细微的差异 但是基本上的是是符合这样的格式的啊 基本上是符合这样的格式的

44:40.150 --> 44:44.070
啊 这是to stream和to utc stream 我都难得记了 我们就直接看吧

44:44.310 --> 44:49.670
然后to times stream呢 就指得到日期部分啊 指得到日期部分 to times stream

44:50.630 --> 44:57.030
啊 指得到日期部分 但是它是那种标准的转换方式 其实像这些方式啊 我们平时呢

44:57.430 --> 45:06.710
不符合我们中国人的阅读习惯 因此呢 我们平时呢 要把这个日期啊转换成制服创 我们往往会自自己写函数

45:07.350 --> 45:13.990
啊 自己写函数来进行转换 好 因此呢 我们现在学到这么多东西了 对吧 我们就可以来自己写个函数了

45:14.630 --> 45:15.270
好 这里

45:16.230 --> 45:19.430
有好的日期制服创

45:20.710 --> 45:31.670
我们往往会自己写函数来进行转换 这些 因为它这个函数得到制服创了 都不是很好用啊 但是它这个制服创里边还有很多很多的功能啊 我都不讲了 因为我们平时基本上不打用它个

45:31.990 --> 45:37.910
因为它这个转换的格式呢 不是那么灵活啊 不是可以 不像可以配置的啊 他不能配置

45:38.230 --> 45:44.070
因此呢 我们这里呢 往往会写自己的函数来转换这个日期 好 比方说给它写个函数啊 get

45:44.870 --> 45:54.150
dead stream get dead stream 好 你给我传一个什么呢 传一个日期对象啊 你给我传一个日期对象 我来帮你转成制服创

45:55.510 --> 45:57.270
输出 get dead stream

45:59.270 --> 46:05.430
这个函数是每个同学都必须要学会写的 给你一个日期对象 你要把它转换成你想要的制服创

46:05.830 --> 46:07.990
好 比方说我们想要的制服创这么一种格式

46:08.470 --> 46:20.150
连越连横杠越日空格时冒号分冒号秒 我们希望是这种这么一种格式

46:20.630 --> 46:27.350
那怎么写呢 我们可以用这种方式来写啊 首先呢 我们得到分别得到连越日时分秒对吧 好得到连

46:28.150 --> 46:36.390
连怎么来得到 是不是 get for year 对吧 来得到它的连 但是得到的是数字对不对 得到的是数字

46:37.270 --> 46:44.550
我们呢 要保持格式的统一嘛 前面如果比方说得到的是公元1010年

46:44.950 --> 46:51.350
那前面是不是要填充一个年 保持这个年是四位数 好 因此呢 我们可以再连起来 我们用这种处理方式

46:52.070 --> 46:56.790
啊 你不是一个数字吗 对吧 把这个数字呢 转换成制服创

46:57.430 --> 47:01.430
啊 转换成制服创 制服创过后呢 是不是有一个东西 叫做pad

47:02.150 --> 47:11.350
start 对吧 拍个start 至少有四位 那么填充零 如果不足四位的话 填充零 最完事了 好 咱们越是不是用同样的方式

47:11.910 --> 47:12.870
that get

47:13.910 --> 47:20.150
month 但是注意越 它是从零开始的 因此你要怎么样呢 加一 对不对 你要加一

47:20.710 --> 47:25.910
好 加一之后 把这个数字呢 转换成制服创 然后pan start

47:26.630 --> 47:33.430
至少有两位 填充零 好 咱们来最后返回看一下啊 先返回两个 好 年

47:34.470 --> 47:37.430
一二 横杠 月

47:38.310 --> 47:40.310
啊 你看一下 目前的结果啊

47:41.750 --> 47:49.030
往往我们会自己写函数来进行转换啊 发新 这里说 没有传日期 对吧 没有传日期 敢溜一个dead

47:49.830 --> 47:52.230
溜一个dead 新建一个对象给他传进去

47:52.950 --> 47:56.470
好 保存看一下啊 你看2019年6月

47:57.830 --> 48:02.870
没问题吧 好 咱们可以用同样的方式啊 同样的方式来得到什么 天 对不对

48:03.750 --> 48:05.510
get date get

48:06.950 --> 48:13.030
dead得到天啊 然后小时呢 这是dead 小时呢 hour

48:13.990 --> 48:17.030
dead get date 后面get hours

48:17.830 --> 48:25.050
啊 后面一样了啊 后面一样了啊 这是小时啊分钟秒

48:26.650 --> 48:28.650
分钟 minute

48:29.770 --> 48:33.530
秒second 分钟的是get minute

48:36.490 --> 48:37.770
秒是get second

48:39.450 --> 48:41.610
好 是不是喜欢了啊 一次我们来拼接啊

48:42.170 --> 48:44.890
年月日小日的话 待

48:45.610 --> 48:47.130
空格小时

48:48.090 --> 48:49.050
hour

48:49.050 --> 48:50.010
冒号

48:50.010 --> 48:51.050
分钟

48:51.050 --> 48:52.090
manage

48:52.090 --> 48:52.890
manage

48:52.890 --> 48:54.250
然后冒号秒

48:54.970 --> 48:55.930
second

48:55.930 --> 48:58.010
你看我们自己写函数的好处就在于 我们可以

48:58.650 --> 49:03.690
自行的控制啊 自由的控制 它的时间格式啊 完全可以自由的控制了

49:04.570 --> 49:06.410
啊 你看每次刷新时间都不一样

49:07.130 --> 49:10.250
好吧 我们往往会自己写函数来得到它的这个制补刷格式啊

49:10.570 --> 49:13.530
不太会用它这种方式啊 它的方式 有的时候呢 我们只是

49:13.690 --> 49:17.610
用它这些函数呢 我们只是做一些测试啊 往往是做一些测试

49:17.930 --> 49:19.450
通常情况下我们会自己写

49:21.050 --> 49:27.050
好吧 好 这是关于这个日期这一块啊 它的一些这些常见的操作

49:27.930 --> 49:32.010
好 接下来呢 我们说一下这个日期啊 它是可以进行运算的

49:32.410 --> 49:35.930
为什么可以进行运算呢 是因为这个日期对象啊

49:37.370 --> 49:41.530
就是日期的运算啊 因为日期对象呢

49:42.010 --> 49:44.250
呃 重写了

49:45.290 --> 49:46.810
object中的

49:47.530 --> 49:48.090
value

49:48.810 --> 49:52.410
啊 我们之前说过对吧 object里面有个 value of 函数啊

49:52.970 --> 49:59.290
重写了这个方法 既然它重写了过后呢 我们之前说过一个对象呢 进行数学运算的时候

49:59.290 --> 50:01.770
它怎么做的呢 它先调用 value

50:02.410 --> 50:05.450
然后再把它转换成字不串 然后再把它转换成数字

50:06.410 --> 50:11.370
通过这种方式 如果 value 得到的就是原始类型的话 那么它就直接把它转换成数字了

50:12.010 --> 50:14.810
因此呢 日期在进行数学的运算的时候

50:15.930 --> 50:22.250
这个 value of 方法 它返回的是一个数字 表示时间戳

50:23.050 --> 50:25.050
咱们先看一下吧 先看一下

50:26.490 --> 50:30.010
比方说啊 我们这里呢 有个日期啊 有个日期

50:30.570 --> 50:35.370
好 这个日期呢 我刚才把刚才的关了 重新打开一次啊

50:37.910 --> 50:43.270
好 有这么一个日期对象 d 我们调了它的 value of 你看一下 是返回的是一个数字

50:44.070 --> 50:46.710
时间戳 对吧 那么这就意味着

50:47.430 --> 50:55.350
什么呢 日期对象可以进行数学运算 是可以进行数学运算的 比方说像

50:56.070 --> 51:01.430
进行求 两个日期相乘 两个日期呢 相处 两个日期相减

51:01.910 --> 51:05.590
一般的话 相减用的比较多啊 一般相减用的比较多

51:05.910 --> 51:07.350
是可以进行数学运算的

51:08.470 --> 51:11.110
但是加号不一样啊 加号是字无算 我们以后再说吧

51:11.590 --> 51:15.190
它可以进行数学运算 因为它的 value of 方法呢 返回的就是一个数字

51:15.350 --> 51:19.590
我们之前说过啊 一个对象 它进行数学运算的时候 它会雕用 value of

51:19.910 --> 51:25.510
如果 value of 方法 返回的就是一个原式值的话 那么它就直接把这个原式值转换成数字

51:26.150 --> 51:27.590
好 咱们再看一下啊 看一下

51:29.430 --> 51:34.070
比方说我这里写两个日期 我这里一个日期 对吧 再写个日期

51:34.790 --> 51:42.950
第 第 new date new date 还是当前日期啊 一个是第1 一个是第2 好 第2的话 我给它加上

51:43.910 --> 51:46.470
set set second

51:48.550 --> 51:51.270
秒钟啊 秒分钟吧 分钟

51:52.550 --> 51:54.710
set 什么

51:55.670 --> 51:57.670
manage 设置分钟

51:58.630 --> 52:00.310
为20啊 为20

52:01.110 --> 52:05.670
保存看一下啊 咱们来看一下两个 两个日期 第1和第2

52:07.190 --> 52:08.870
你看一下时间是不是差了

52:09.990 --> 52:16.230
差了就是19分钟 对吧 差了19分钟 好 咱们可以用这样的方式 第1 减去第2

52:17.110 --> 52:23.350
你看是可以相减的 为什么可以相减 它相当于是两个对象相减 是不是进行算数运算

52:23.750 --> 52:26.710
算数运算的时候 它会怎么样呢 它会雕用 value

52:27.430 --> 52:29.990
啊 它会雕用 value 来进行相减

52:31.110 --> 52:36.790
对吧 value 它反回来本身就是一个 本身就是一个就是原始类型了 它就不会再雕用突出并了

52:37.350 --> 52:39.510
你看 它是用这种方式来进行相减的

52:40.390 --> 52:45.990
但是如果是相加不一样啊 如果是相加的话 它就制不出来拼接了 因为相加我们之前说过啊

52:46.390 --> 52:49.190
相加的话是雕用的是制不错的突出运方法

52:49.910 --> 52:54.950
雕用制不错的突出运对象的突出运方法把它转化成制不错 然后再进行拼接

52:55.510 --> 52:56.630
那就不一样了

52:57.270 --> 53:04.150
如果是进行其他的运算 算数运算 相减相处这些都可以 它会把它转换成数字来进行进行算数运算

53:04.950 --> 53:08.550
于是呢 我们就可以怎么样了 我们就可以

53:09.910 --> 53:11.110
有这么一些操作了

53:12.150 --> 53:17.990
比方说得到两个日 两个日期的时间的差 表示两个日期差了多少个小时

53:18.390 --> 53:20.550
差多少个小时呢 我们就可以这样子来处理

53:21.110 --> 53:22.710
第一 减去第二

53:25.430 --> 53:28.230
然后处理什么呢 一个小时多少毫秒

53:28.870 --> 53:29.830
一个小时多少毫秒

53:31.750 --> 53:37.190
我们想呗一个小时60分钟嘛 一分钟呢 60秒啊 一秒钟呢

53:38.070 --> 53:42.230
1000毫秒 对吧 这样子也一算出来啊 你看

53:42.630 --> 53:45.190
它们相差多少个小时呢 0.3个小时

53:45.670 --> 53:51.510
它们相差0.3个小时 我们就可以用这种算数运算的方式啊 来算出来两个日期之间的差值

53:52.470 --> 53:57.510
我们知道这个特点之后呢 我们还可以做一些运算

53:57.910 --> 54:00.470
比方说 第一个日期啊 有这么一个日期

54:01.990 --> 54:04.070
这个日期拿到之后呢 我们要做这么一个处理

54:04.870 --> 54:10.310
你看一下这个日期啊 我要在这个日期基础上加上一天

54:10.790 --> 54:16.390
是加上一天啊 我要在这个日期基础上加上一天 那怎么加呢

54:17.350 --> 54:18.950
怎么加上一天呢

54:20.870 --> 54:25.110
看着啊 我们可以用这种方式 首先呢得到它的get time

54:25.830 --> 54:28.310
得到它的时间戳 没问题吧

54:28.950 --> 54:32.630
然后加上一天的时间戳 1000的一天的毫秒数是多少

54:33.110 --> 54:37.030
一天的毫秒数是啊 一天嘛 一天24个小时

54:37.590 --> 54:41.830
一小时呢 60分钟 一分钟啊 60秒 一秒钟啊 1000毫秒

54:42.630 --> 54:45.910
对吧 好 加上这个数字是不是一个新的时间戳产生了

54:46.950 --> 54:50.470
new time 一个新的时间戳产生了

54:50.950 --> 54:54.550
然后呢 重新设置这个日期的set time

54:55.110 --> 54:59.350
把它设置为new time 你看 这样子啊 是不是就得到了一个新的日期了

54:59.910 --> 55:01.910
所以加了一天了 刚好是加一天

55:02.550 --> 55:06.870
没问题吧 我们可以用这种双书运算的方式来对它进行处理

55:07.030 --> 55:09.750
你看双书运算的时候 是不是就用用到这个时间戳

55:10.310 --> 55:13.110
不然的话你怎么算了 你咋算了 对不对

55:13.590 --> 55:17.190
当然呢 你也可以用这种方式啊 这种方式加一天也行

55:17.430 --> 55:23.350
就是D new date 就是D gets date

55:24.310 --> 55:26.230
得到一个日期啊 得到一个日期

55:26.630 --> 55:31.350
然后呢 我去设置它的日期set date为new date

55:31.750 --> 55:33.750
也可以啊 也可以

55:34.710 --> 55:39.750
看是不是也行 对吧 但是呢 你就这就要要要求你肯定是要添的整数 对吧

55:40.710 --> 55:44.150
我写错了啊 应该是new date啊 new date

55:45.030 --> 55:51.030
等于D的get date加1 加1 然后呢 D set date set date

55:51.510 --> 55:55.590
然后 new date new date啊 这样子

55:56.390 --> 55:59.590
你看是不是也可以加一天啊 刚才是19现在变成20了

56:00.790 --> 56:06.630
也行 只不过呢 我们用这种get time的这种方式来对日期进行处理的更加灵活

56:06.710 --> 56:11.590
比方说我加半天 我在这里把它改成12 对吧 我加三分之一天 我把这里改成8

56:12.310 --> 56:14.710
对不对 我可以更加精确的进行计算

56:15.670 --> 56:23.110
没问题吧 ok啊 这就是关于日期对象的运算 始终记住啊日期对象运算的时候呢 实际上是运算的是好

56:23.510 --> 56:29.350
运算的是时间戳 我们只要掌握了时间戳这个点 那么我就可以对各种日期进行运算

56:30.390 --> 56:32.470
好吧 作业啊作业

56:33.110 --> 56:43.110
日期部分的作业呢 有这么一些 大家下来去把完成啊 练习一下日期对象日期对象用的也蛮常见的啊

56:43.750 --> 56:44.310
第一道题

56:45.270 --> 56:45.670
是

56:46.470 --> 56:52.390
就是我们之前课堂上做过的啊 我就讲的时候呢不再讲了 就是编写一个函数

56:53.830 --> 56:55.350
用于返回一个

56:56.310 --> 57:00.470
有好的日期制符创格式

57:01.510 --> 57:02.390
格式就是这样子

57:03.510 --> 57:04.150
就这个东西

57:05.430 --> 57:06.070
就这种格式

57:07.190 --> 57:08.550
使用这种格式来返回一个日期

57:09.030 --> 57:12.630
大家去写一遍啊 一定要去写一遍啊 因为这个函数呢以后蛮常见的

57:13.830 --> 57:17.590
这个不用把它写成通用函数啊 以后呢我们学了这么多表达式之后呢

57:18.070 --> 57:21.830
我们还会用更好的就是优化这个函数的方式

57:22.790 --> 57:23.990
好 第二个啊 第二个

57:26.150 --> 57:26.710
给定

57:27.670 --> 57:35.030
给定用户的生日啊 生日告诉我连月日 你是哪一年哪一月出生的啊 连月日

57:36.230 --> 57:42.870
计算该用户的年龄啊 根据生日计算年龄 你可以用个函数来编写

57:43.830 --> 57:45.990
给生日然后然后算年龄

57:46.790 --> 57:48.950
好 第二题啊 继续想想怎么做

57:49.750 --> 57:50.710
好 第三题啊

57:51.270 --> 57:55.670
是根据系统当前的月份

57:57.430 --> 58:02.070
输出这一个月啊 这一个月每一天

58:02.790 --> 58:06.310
每一天的星期 最是每一天的星期哦

58:06.550 --> 58:10.150
那输出的格式是这样子啊 比方说2019年

58:10.630 --> 58:15.750
2019年6月18号 对吧 6月1号 我们现在是6月嘛 对吧

58:16.070 --> 58:20.230
输出2019年6月1日 比方说啊 星期几啊

58:20.950 --> 58:23.350
星期六月1号 星期六啊 星期六

58:24.230 --> 58:31.670
这样输出啊 这样输出 好 然后呢 2019年6月2日 那么星期天 对吧

58:32.150 --> 58:38.310
星期日啊 不显得吧 后边一直输出到多少 一直输出到2019年6月

58:38.870 --> 58:41.750
30号啊 30号星期几呢

58:42.710 --> 58:47.750
星期日啊 星期日啊 这个题呢 大家好好去想一想啊 怎么去做

58:48.470 --> 58:56.470
因为我们目前系统时间是6月 所以说呢 你要输出6月的 如果系统时间是2月 你要输出2月的 系统时间是7月 你要输出7月的

58:57.030 --> 59:01.110
原来的意思吧啊 同样的 连份的也是根据系统时间来定的

59:01.590 --> 59:05.430
好 就这三道题 这三道题就可以练习很多很多的知识

59:05.910 --> 59:09.110
好 现在大家去把它做一遍啊 做一遍 我下节课来讲

