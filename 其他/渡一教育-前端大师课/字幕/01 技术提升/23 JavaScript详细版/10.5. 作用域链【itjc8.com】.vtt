WEBVTT

00:00.000 --> 00:19.820
这节课的东西 它是建立在执行上下文基础上的

00:19.820 --> 00:24.820
所以说你要学习这节课了 你得先理解执行上下文

00:24.820 --> 00:29.820
如果你还对执行上下文那一块有点模糊的话 那么你再去看一下

00:29.820 --> 00:32.820
关键的目的是要能够做各种各样的面试题

00:32.820 --> 00:36.820
就是我们当时不是出了四道面试题吗 对吧 执行上下文那一章

00:36.820 --> 00:39.820
面试题也要能做 也要能自行把它做出来

00:39.820 --> 00:44.820
要能够自己画图来分析出VO 它的指向 它里边有哪些东西

00:44.820 --> 00:48.820
才能学习作用运念 作用运念这一块是讲的是啥呢

00:48.820 --> 00:52.820
它是解释一个现象 解释什么现象呢 币包现象

00:52.820 --> 00:57.820
我们说函数里边可以用外边的东西叫做币包 对吧 叫做币包

00:57.820 --> 01:01.820
那么为什么会产生币包 它是怎么来的

01:01.820 --> 01:04.820
这是作用运念要解释的东西

01:04.820 --> 01:09.820
这里边有很多的细节 讲的内容也比较多 而且比较绕

01:09.820 --> 01:14.820
不过这一块学校之后对我们做面试题的时候会有帮助

01:14.820 --> 01:18.820
因为这一块也容易出面试题 咱们先来看

01:18.820 --> 01:22.820
现在认识一个点 第一个点就是要认识到的就是

01:22.820 --> 01:25.820
上节可能没有讲 因为上节可能不需要讲这个点

01:25.820 --> 01:32.820
但是这节可可以讲了 就是VO中包含一个属相

01:32.820 --> 01:36.820
包含一个属相 一个额外的属相

01:36.820 --> 01:44.820
该属相 该属相怎么样呢 该属相指向

01:44.820 --> 01:50.820
创建VO的函数本身

01:50.820 --> 01:52.820
你要理解这么一个知识点

01:52.820 --> 01:54.820
VO中包含一个额外的属相

01:54.820 --> 01:56.820
因为我们知道VO都是由函数调用产生的 对吧

01:56.820 --> 01:59.820
你调用一个函数 它会产生一个指形上下文

01:59.820 --> 02:01.820
指形上下文里边会有个VO

02:01.820 --> 02:05.820
那么这个VO里边除了有什么参数 有变量 里边的函数

02:05.820 --> 02:10.820
还会有一个什么一个地址 它会指向那个函数本身

02:10.820 --> 02:14.820
注意是VO中里边有的 而不是上下文里边有的

02:14.820 --> 02:16.820
当然VO就在上下文里边

02:16.820 --> 02:18.820
也可以认为是上下文里边有的

02:18.820 --> 02:22.820
你要这意思吧 你先把这个东西理解了

02:22.820 --> 02:24.820
好 然后这个东西我们来画个图

02:24.820 --> 02:27.820
那现在图又不一样了

02:27.820 --> 02:29.820
当然全举上下文除外

02:29.820 --> 02:31.820
全举上下文 它里边没有这个东西

02:31.820 --> 02:35.900
比方说TESLA1

02:35.900 --> 02:37.900
看一下

02:39.900 --> 02:43.900
好 这里边我们写这么一个代码

02:43.900 --> 02:45.900
方形A

02:45.900 --> 02:47.900
方形B

02:47.900 --> 02:49.900
方形A里边有个属相

02:49.900 --> 02:51.900
有个属相A等于1

02:51.900 --> 02:54.900
方形B有个属相B等于2

02:54.900 --> 02:56.900
方形C

02:56.900 --> 02:58.900
C的话我们这样子创建吧

02:58.900 --> 02:59.900
这样子创建

02:59.900 --> 03:01.900
方形C

03:01.900 --> 03:03.900
换一种花样

03:03.900 --> 03:05.900
这里边有个变量 C

03:05.900 --> 03:07.900
3

03:07.900 --> 03:08.900
在这里边的输出啥呢

03:08.900 --> 03:11.900
输出A B C

03:11.900 --> 03:13.900
输出这么个东西

03:13.900 --> 03:16.900
好 最后我们这里去调用C

03:16.900 --> 03:18.900
这里去调用B

03:18.900 --> 03:20.900
外面的调用A

03:20.900 --> 03:22.900
没问题吧

03:22.900 --> 03:25.900
A里边在全举加一个变量

03:25.900 --> 03:27.900
这个变量G

03:27.900 --> 03:28.900
G等于0

03:28.900 --> 03:31.900
那么这里边去输出G

03:31.900 --> 03:33.900
形成这么一个代码格式

03:33.900 --> 03:36.900
掏了很多 还是掏了很深

03:36.900 --> 03:38.900
没关系 我们来分析一下它整个的过程

03:38.900 --> 03:41.900
这里我们还是要创建一个就是PVT

03:41.900 --> 03:43.900
好 其实这个PVT

03:43.900 --> 03:45.900
重点在于理解

03:45.900 --> 03:47.900
我光发这个PVT的

03:47.900 --> 03:48.900
这个PVT不发

03:48.900 --> 03:49.900
光发这个PVT

03:49.900 --> 03:50.900
我觉得也没有啥用

03:50.900 --> 03:52.900
重点在于理解

03:53.900 --> 03:56.900
好 看一下这个PVT里边

03:56.900 --> 03:58.900
这一边就是执行站

03:58.900 --> 03:59.900
这是执行站

03:59.900 --> 04:01.900
上几个我们画了很多次的

04:01.900 --> 04:03.900
Core Stack

04:03.900 --> 04:05.900
执行站

04:05.900 --> 04:08.900
好 然后开始执行这个代码

04:08.900 --> 04:09.900
首先创建啥

04:09.900 --> 04:11.900
创建全举环境

04:11.900 --> 04:13.900
全举环境

04:13.900 --> 04:15.900
好 这是全举环境

04:15.900 --> 04:18.900
全举环境

04:18.900 --> 04:21.900
好 全举环境里边是不是也一定有VO

04:21.900 --> 04:22.900
它叫做G-O 对不对

04:22.900 --> 04:24.900
对VO本质是一样的

04:24.900 --> 04:25.900
就是交法不一样而已

04:25.900 --> 04:27.900
这是个全举环境

04:27.900 --> 04:29.900
好 G-O是不是要指向一个东西

04:29.900 --> 04:30.900
要指向一个东西

04:30.900 --> 04:31.900
我们之前说过

04:31.900 --> 04:33.900
它指向啥 指向一个对象

04:33.900 --> 04:34.900
G-O它指向一个对象

04:34.900 --> 04:35.900
当然还会有啥

04:35.900 --> 04:37.900
环境里边当然就上下文

04:37.900 --> 04:39.900
上下文

04:39.900 --> 04:40.900
上下文里边是不是

04:40.900 --> 04:41.900
还有什么Zis

04:41.900 --> 04:43.900
Zis我就不画了

04:45.900 --> 04:46.900
它指向一个对象

04:46.900 --> 04:47.900
指向什么对象呢

04:47.900 --> 04:49.900
指向的是一个G-O对象

04:49.900 --> 04:50.900
对不对

04:50.900 --> 04:52.900
我们知道G-O它指向的是谁

04:52.900 --> 04:53.900
指向的就是温斗对象

04:53.900 --> 04:54.900
温斗

04:55.900 --> 04:56.900
好 接下来开始执行

04:56.900 --> 04:58.900
开始执行代码

04:58.900 --> 05:00.900
然后首先把这个

05:00.900 --> 05:01.900
不是执行代码

05:01.900 --> 05:03.900
先把什么变量啊

05:03.900 --> 05:05.900
字面量函数啊

05:05.900 --> 05:06.900
提出来对不对

05:06.900 --> 05:07.900
先提出来

05:07.900 --> 05:08.900
提出来这个

05:08.900 --> 05:09.900
这个变量是多少

05:09.900 --> 05:10.900
变量G

05:10.900 --> 05:12.900
变量G是多少

05:12.900 --> 05:13.900
变量G的值是不是你

05:13.900 --> 05:14.900
对吧

05:14.900 --> 05:16.900
温斗的其他属性

05:16.900 --> 05:18.900
因为它就是温斗对象

05:18.900 --> 05:19.900
所以说

05:19.900 --> 05:20.900
它就是其他属性

05:20.900 --> 05:22.900
还有一个属性就是G等于0

05:22.900 --> 05:23.900
所以它变成了温的对象的一个属性

05:23.900 --> 05:24.900
我们上级课说了

05:24.900 --> 05:26.900
然后还有一个什么呢

05:26.900 --> 05:28.900
是不是还有一个函数A

05:28.900 --> 05:29.900
对不对

05:29.900 --> 05:30.900
还有一个函数A

05:30.900 --> 05:31.900
它不是0

05:31.900 --> 05:32.900
是undefined

05:32.900 --> 05:34.900
函数是不是要指向一个函数对象

05:34.900 --> 05:36.900
上级课我们就直接这样子写了

05:36.900 --> 05:38.900
因为上级课我们不care这个东西

05:38.900 --> 05:39.900
但是这几课要care了

05:39.900 --> 05:41.900
它会创建一个函数对象

05:41.900 --> 05:43.900
会创建一个函数对象

05:43.900 --> 05:45.900
好 那么这个时候呢

05:46.900 --> 05:47.900
我要说一下

05:47.900 --> 05:49.900
这个函数对象

05:49.900 --> 05:50.900
是吗

05:51.900 --> 05:52.900
它是个对象

05:52.900 --> 05:55.900
这个函数对象里边有一个东西

05:55.900 --> 05:56.900
我们这里

05:56.900 --> 05:57.900
马上把第二个字件说了

05:57.900 --> 05:59.900
说了过后我们也一起来讲

05:59.900 --> 06:00.900
就是它是一套的

06:00.900 --> 06:02.900
每一个函数

06:02.900 --> 06:05.900
每一个函数在创建时

06:05.900 --> 06:08.900
在创建时会怎么样呢

06:08.900 --> 06:11.900
每一个函数在创建的时候

06:11.900 --> 06:15.900
会有一个

06:15.900 --> 06:19.900
就是一个隐藏属性

06:19.900 --> 06:21.900
这个属性的名字叫做scope

06:21.900 --> 06:23.900
会有这么一个属性

06:28.430 --> 06:30.430
好 这个隐藏属性有什么用呢

06:30.430 --> 06:31.430
它是一个地址

06:31.430 --> 06:33.430
我们知道它存的地址的都是

06:33.430 --> 06:35.430
一些对象 它存的是地址 对吧

06:35.430 --> 06:37.430
它指向

06:37.430 --> 06:39.430
这个隐藏属性你是访问不了的

06:39.430 --> 06:41.430
所以说这一刻我没办法

06:41.430 --> 06:42.430
没有办法打印出来

06:42.430 --> 06:43.430
给你看一下这个属性

06:43.430 --> 06:44.430
没有办法

06:44.430 --> 06:45.430
它指向谁呢

06:45.430 --> 06:47.430
它指向

06:47.430 --> 06:51.430
创建该函数时

06:51.430 --> 06:52.430
你要创建一个函数

06:52.430 --> 06:54.430
它肯定得有一个上下文

06:54.430 --> 06:55.430
得有一个就是上下文

06:55.430 --> 06:56.430
执行上下文

06:56.430 --> 06:58.430
所有的代码都在执行上下文

06:58.430 --> 06:59.430
那边执行的

06:59.430 --> 07:00.430
你创建函数也不例外

07:00.430 --> 07:01.430
你创建函数的时候

07:01.430 --> 07:03.430
一定有一个上下文

07:03.430 --> 07:04.430
那么这个时候

07:04.430 --> 07:05.430
创建了这个函数之后

07:05.430 --> 07:08.430
它有个属性叫做scope

07:08.430 --> 07:13.430
它指向创建该函数时的VO

07:13.430 --> 07:15.430
就是正在执行上下文

07:15.430 --> 07:17.430
就当前这个执行上下文

07:17.430 --> 07:19.430
于是这个函数里边

07:19.430 --> 07:21.430
是不是一个属性scope

07:21.430 --> 07:22.430
有一个属性scope

07:22.430 --> 07:24.430
这个属性它指向谁呢

07:24.430 --> 07:27.430
它指回来

07:27.430 --> 07:28.430
它指回来

07:28.430 --> 07:29.430
指向谁

07:29.430 --> 07:30.430
指向它

07:30.430 --> 07:32.430
没问题吧

07:32.430 --> 07:33.430
这个scope它指向谁

07:33.430 --> 07:35.430
指向它

07:35.430 --> 07:36.430
没问题吧

07:36.430 --> 07:37.430
当然这个A

07:37.430 --> 07:38.430
它指向谁

07:38.430 --> 07:39.430
这个A呢

07:39.430 --> 07:40.430
我就画一个浅色的

07:40.430 --> 07:41.430
因为这个东西一看就明白了

07:41.430 --> 07:42.430
对吧

07:42.430 --> 07:43.430
浅色的箭头

07:43.430 --> 07:44.430
这个A没啥问题吧

07:44.430 --> 07:45.430
对吧

07:45.430 --> 07:46.430
指向它

07:46.430 --> 07:47.430
指向这个函数

07:47.430 --> 07:50.430
我画一个稍微浅一点的

07:50.430 --> 07:51.430
这个没啥问题吧

07:51.430 --> 07:52.430
它是一个变良A嘛

07:52.430 --> 07:53.430
对吧

07:53.430 --> 07:54.430
函数

07:54.430 --> 07:55.430
函数是个对象

07:55.430 --> 07:56.430
所以它里面存的是地址

07:56.430 --> 07:57.430
它是地址的指向这个函数

07:57.430 --> 07:58.430
而函数里面有个scope

07:58.430 --> 07:59.430
它又指回来

07:59.430 --> 08:01.430
指向整个这个对象

08:01.430 --> 08:03.430
指向整个这个对象

08:03.430 --> 08:05.430
有什么用了这东西

08:05.430 --> 08:06.430
有啥用呢

08:06.430 --> 08:07.430
现在还看不出来有啥用

08:07.430 --> 08:08.430
对吧

08:08.430 --> 08:09.430
没关系

08:09.430 --> 08:10.430
慢一点

08:10.430 --> 08:11.430
不着急

08:11.430 --> 08:12.430
它是不是

08:12.430 --> 08:13.430
这是我们上级课没讲的

08:13.430 --> 08:14.430
因为上级课

08:14.430 --> 08:15.430
对我们上级课来说

08:15.430 --> 08:16.430
不重要这一块

08:16.430 --> 08:18.430
但是现在很重要了

08:18.430 --> 08:19.430
好 接下来了

08:19.430 --> 08:20.430
我们来看

08:20.430 --> 08:21.430
开始执行代码了

08:21.430 --> 08:22.430
把G复制为0

08:22.430 --> 08:24.430
把它的VO里面的G复制为0

08:24.430 --> 08:25.430
这个没啥问题

08:25.430 --> 08:26.430
然后呢

08:26.430 --> 08:27.430
这句话运不运行

08:27.430 --> 08:28.430
它不运行的

08:28.430 --> 08:29.430
已经创建好了

08:29.430 --> 08:30.430
对吧

08:30.430 --> 08:31.430
然后执行A

08:31.430 --> 08:32.430
开始执行函数了

08:32.430 --> 08:33.430
执行函数的时候

08:33.430 --> 08:34.430
是不是

08:34.430 --> 08:35.430
创建函数上下文

08:35.430 --> 08:36.430
对不对

08:36.430 --> 08:37.430
执行啥

08:37.430 --> 08:39.430
执行函数A

08:39.430 --> 08:40.430
执行函数A

08:41.430 --> 08:43.430
函数A里面是不是有VO

08:43.430 --> 08:44.430
当然也叫做AO了

08:44.430 --> 08:45.430
对吧

08:45.430 --> 08:46.430
因为目前执行的就是它

08:46.430 --> 08:47.430
我们就用VO

08:47.430 --> 08:49.430
它里面是不是有VO

08:49.430 --> 08:50.430
好

08:50.430 --> 08:51.430
VO里面是不是要找

08:51.430 --> 08:52.430
找里面是有啥

08:52.430 --> 08:53.430
是不是有两个函数

08:53.430 --> 08:54.430
一个函数一个变量

08:54.430 --> 08:55.430
对不对

08:55.430 --> 08:56.430
好 来呗

08:56.430 --> 08:58.430
它里面有啥

08:58.430 --> 09:00.430
有一个函数一个变量

09:00.430 --> 09:01.430
一个函数是啥

09:01.430 --> 09:02.430
函数是B

09:02.430 --> 09:03.430
好 变量是啥

09:03.430 --> 09:04.430
变量是

09:04.430 --> 09:06.430
变量是A

09:06.430 --> 09:07.430
变量是A

09:07.430 --> 09:09.430
A等于安迪范

09:09.430 --> 09:10.430
当然以后

09:10.430 --> 09:11.430
以后就把它复制为一了

09:11.430 --> 09:12.430
对吧

09:12.430 --> 09:13.430
直接写一

09:13.430 --> 09:14.430
那么函数

09:14.430 --> 09:15.430
函数是啥

09:15.430 --> 09:16.430
函数是B

09:16.430 --> 09:17.430
函数是B

09:17.430 --> 09:18.430
没问题吧

09:18.430 --> 09:20.430
这个没问题吧

09:20.430 --> 09:21.430
这我们上级课的知识

09:21.430 --> 09:23.430
所以上级课的知识很重要的

09:23.430 --> 09:25.430
于是得到这么一个东西

09:25.430 --> 09:27.430
得到这么一个东西之后

09:27.430 --> 09:28.430
是不是个B

09:28.430 --> 09:29.430
又是个函数

09:29.430 --> 09:30.430
是不是要创建个函数B

09:30.430 --> 09:31.430
对吧

09:31.430 --> 09:32.430
当这个函数

09:32.430 --> 09:33.430
这个名字在这

09:33.430 --> 09:34.430
名字在这

09:34.430 --> 09:35.430
函数B

09:35.430 --> 09:37.430
好 那么这里

09:37.430 --> 09:38.430
用个灰色的箭头

09:38.430 --> 09:39.430
过去

09:39.430 --> 09:40.430
函数B

09:40.430 --> 09:41.430
我们主要是看黑色的箭头

09:41.430 --> 09:43.430
好 那么这里

09:43.430 --> 09:45.430
Sculpt是不是要指回来

09:45.430 --> 09:47.430
函数里面的Sculpt这个属性

09:47.430 --> 09:49.430
它一定指向的是

09:49.430 --> 09:51.430
哪个商项文里面

09:51.430 --> 09:52.430
创建的它

09:52.430 --> 09:54.430
它就指向哪个商项文的VO

09:54.430 --> 09:55.430
你看

09:55.430 --> 09:56.430
是不是在这个商项文里面

09:56.430 --> 09:57.430
执行的过程中创建的

09:57.430 --> 09:58.430
对吧

09:58.430 --> 09:59.430
在这个VO里面创建的

09:59.430 --> 10:00.430
它就指向这个VO

10:00.430 --> 10:02.430
就这么简单

10:02.430 --> 10:03.430
好

10:03.430 --> 10:04.430
然后我们刚才说

10:04.430 --> 10:05.430
还有这个点

10:05.430 --> 10:07.430
VO中包含一个额外的属性

10:07.430 --> 10:08.430
这个属性指向

10:08.430 --> 10:10.430
创建该VO的函数本身

10:10.430 --> 10:11.430
那你看一下

10:11.430 --> 10:12.430
这个VO是谁创建的

10:12.430 --> 10:13.430
哪个函数创建的

10:13.430 --> 10:14.430
这个VO

10:14.430 --> 10:15.430
哪个函数创建的

10:15.430 --> 10:16.430
是不是函数A创建的

10:16.430 --> 10:17.430
对吧

10:17.430 --> 10:18.430
调用函数A创建的这个VO

10:18.430 --> 10:20.430
所以它里面会有个地址

10:20.430 --> 10:21.430
会有个地址

10:21.430 --> 10:22.430
我们就直接用个箭头了

10:22.430 --> 10:25.430
会有个地址指回来

10:25.430 --> 10:27.430
它会有个地址指回来

10:27.430 --> 10:30.060
你看

10:30.060 --> 10:32.060
它会有个地址指回来

10:32.060 --> 10:33.060
你知道这个意思吧

10:33.060 --> 10:34.060
这些都用灰色箭头

10:34.060 --> 10:36.060
这些对我们不是很care的事情

10:36.060 --> 10:37.060
我们用灰色箭头

10:37.060 --> 10:38.060
我们现在主要看黑色箭头

10:39.060 --> 10:40.060
没问题吧

10:40.060 --> 10:41.060
通过Sculpt

10:41.060 --> 10:42.060
是不是可以找到它

10:42.060 --> 10:44.060
通过它是不是可以找到这个方形A

10:44.060 --> 10:46.060
通过方形A是不是找到Sculpt

10:46.060 --> 10:47.060
这个东西

10:47.060 --> 10:48.060
对吧

10:48.060 --> 10:50.060
其实作用与念的

10:50.060 --> 10:51.060
一种概念

10:51.060 --> 10:53.060
一种感觉是不是就已经出来了

10:53.060 --> 10:54.060
好 接下来我们继续看

10:54.060 --> 10:55.060
继续看

10:55.060 --> 10:57.060
好 于是创建好了之后

10:57.060 --> 10:58.060
现在接下来干嘛呢

10:58.060 --> 11:00.060
它接下来是不是又运行那个函数B

11:00.060 --> 11:02.060
对不对 运行函数B

11:02.060 --> 11:03.060
函数B

11:03.060 --> 11:04.060
是不是一样的

11:04.060 --> 11:06.060
函数B里面有个啥

11:06.060 --> 11:07.060
一个B 变量B

11:07.060 --> 11:08.060
对吧 等于2

11:08.060 --> 11:09.060
我就不看了

11:09.060 --> 11:10.060
那么里面有个函数C

11:10.060 --> 11:12.060
它是不是又一样的

11:12.060 --> 11:13.060
对吧 函数C

11:13.060 --> 11:15.060
函数C里面是不是有Sculpt

11:15.060 --> 11:16.060
对吧

11:16.060 --> 11:18.060
函数C的Sculpt

11:18.060 --> 11:19.060
指向这

11:19.060 --> 11:20.060
好 那么这个上下文里面

11:20.060 --> 11:22.060
它也有一个东西

11:22.060 --> 11:24.060
它指向函数B

11:24.060 --> 11:25.060
对吧 指向函数B

11:25.060 --> 11:26.060
好 那么这里

11:26.060 --> 11:28.060
这边我用灰色箭头了

11:28.060 --> 11:29.060
没问题吧

11:29.060 --> 11:31.060
函数B里面是不是有C

11:31.060 --> 11:32.060
对吧

11:32.060 --> 11:34.060
C 那它这里还有一个箭头

11:35.060 --> 11:37.060
C它指向这

11:37.060 --> 11:38.060
对吧

11:38.060 --> 11:39.060
我们现在只管一些黑色的

11:39.060 --> 11:40.060
或者我们用红色

11:40.060 --> 11:42.060
看得亮眼一点

11:42.060 --> 11:44.060
用红色

11:44.060 --> 11:45.060
红色还没不如黑色

11:45.060 --> 11:47.060
就用黑色

11:47.060 --> 11:49.060
好 于是函数B的上下文

11:49.060 --> 11:50.060
创建完了

11:50.060 --> 11:51.060
函数B嘛 对吧

11:51.060 --> 11:52.060
好 B的上下文

11:52.060 --> 11:53.060
创建完了过后

11:53.060 --> 11:54.060
是不是要开始执行函数B了

11:54.060 --> 11:55.060
执行函数B的时候

11:55.060 --> 11:56.060
复指 复指为2

11:56.060 --> 11:57.060
然后呢

11:57.060 --> 11:59.060
这里函数C它不是

11:59.060 --> 12:01.060
函数C不是字面量

12:01.060 --> 12:03.060
函数C不是字面量

12:03.060 --> 12:04.060
函数C呢

12:04.060 --> 12:05.060
它是一开始是undefined

12:05.060 --> 12:06.060
它是个普通辨量

12:06.060 --> 12:07.060
它是个普通辨量

12:07.060 --> 12:08.060
一开始是undefined

12:08.060 --> 12:09.060
然后呢

12:09.060 --> 12:10.060
复指的时候

12:10.060 --> 12:11.060
运行到这句话的时候

12:11.060 --> 12:13.060
才会创建函数

12:13.060 --> 12:14.060
不过是一样的

12:14.060 --> 12:15.060
结果是一样的

12:15.060 --> 12:16.060
结果没有什么差异

12:16.060 --> 12:18.060
但是过程会有些变化

12:18.060 --> 12:19.060
它不是一开始就有

12:19.060 --> 12:20.060
它是一开始为undefined

12:20.060 --> 12:21.060
它是个普通辨量嘛

12:21.060 --> 12:23.060
所以把它复指为一个函数

12:23.060 --> 12:24.060
是一样的

12:24.060 --> 12:26.060
最终还是一个这样的效果

12:27.060 --> 12:28.060
好好看一下

12:28.060 --> 12:29.060
把这个东西先理解了

12:29.060 --> 12:30.060
把这个东西先理解了

12:30.060 --> 12:31.060
再说

12:31.060 --> 12:32.060
再往后面说

12:33.060 --> 12:35.060
好 接下来

12:35.060 --> 12:36.060
这个C创建好了过了

12:36.060 --> 12:37.060
现在运行C

12:37.060 --> 12:39.060
运行C这个函数

12:39.060 --> 12:40.060
好 C这个函数里边

12:40.060 --> 12:41.060
我们来看一下

12:41.060 --> 12:42.060
又创建那个函数C

12:42.060 --> 12:43.060
对吧

12:43.060 --> 12:44.060
前面都还没有执行完

12:44.060 --> 12:46.060
现在就创建函数C了

12:46.060 --> 12:47.060
C里边是不是又有一个VO

12:47.060 --> 12:48.060
对吧

12:48.060 --> 12:49.060
这些都是一样的

12:49.060 --> 12:51.060
并没有什么区别

12:51.060 --> 12:53.060
这个函数C的上下文里边有啥

12:53.060 --> 12:54.060
是不是只有一个变量C

12:54.060 --> 12:55.060
对吧 只有一个变量C

12:55.060 --> 12:56.060
没啥东西了

12:56.060 --> 12:57.060
只有一个变量C

12:57.060 --> 12:58.060
C的值是多少

12:58.060 --> 12:59.060
是3

12:59.060 --> 13:01.060
C的值是3

13:01.060 --> 13:02.060
看没 没问题吧

13:04.060 --> 13:05.060
就完了对吧

13:05.060 --> 13:06.060
就完了

13:06.060 --> 13:07.060
那么接下来就有意思了

13:07.060 --> 13:09.060
这里还有一个箭头

13:09.060 --> 13:11.060
因为这个上下文是函数C创建的

13:11.060 --> 13:12.060
它会指向这里

13:12.060 --> 13:14.060
好 接下来就有意思了

13:14.060 --> 13:16.060
接下来我们看第三个支持点

13:16.060 --> 13:18.060
前面两个支持点已经讲完了

13:18.060 --> 13:20.060
如果你这个图还是感觉很模糊的话

13:20.060 --> 13:21.060
好好把看一遍

13:21.060 --> 13:22.060
看个10分钟

13:22.060 --> 13:24.060
保证就结合这个代码来看

13:24.060 --> 13:25.060
这代码你们

13:25.060 --> 13:27.060
应该手上都有

13:27.060 --> 13:28.060
应该手上都有

13:28.060 --> 13:29.060
结合这个代码来看

13:30.060 --> 13:32.060
确保自己能理解这么一种结构

13:32.060 --> 13:33.060
然后我再说

13:33.060 --> 13:35.060
接下来它发生了什么事情

13:36.060 --> 13:39.060
当访问一个变量C

13:39.060 --> 13:40.060
当然也包含什么

13:40.060 --> 13:41.060
长出来都是一样的意思

13:41.060 --> 13:43.060
当含访问一个变量C

13:43.060 --> 13:45.060
会先查找

13:45.060 --> 13:48.060
自身VO中的

13:48.060 --> 13:50.060
中是否存在

13:50.060 --> 13:52.060
如果不存在

13:52.060 --> 13:56.060
则一次查找

14:00.060 --> 14:03.530
scope属性

14:03.530 --> 14:04.530
这个scope属性什么意思呢

14:04.530 --> 14:06.530
scope就表示作用语的意思

14:06.530 --> 14:09.530
就表示的是作用语一个范围

14:09.530 --> 14:11.530
一次查到是不是形成一个链条了

14:11.530 --> 14:13.530
就是作用语件

14:13.530 --> 14:15.530
好 咱们来看一下

14:15.530 --> 14:19.100
比方说在含书C的

14:19.100 --> 14:20.100
上下文里边

14:20.100 --> 14:22.100
比方说在含书C里边

14:22.100 --> 14:24.100
我要输出G A B C

14:24.100 --> 14:25.100
或者我们反正来说出

14:25.100 --> 14:29.100
C B A G

14:29.100 --> 14:30.100
比方说我们这样子输出

14:30.100 --> 14:32.100
先输出C

14:32.100 --> 14:34.100
那么首先查找自己的上下文

14:34.100 --> 14:36.100
因为它现在在含书C里边

14:36.100 --> 14:37.100
执行含书C

14:37.100 --> 14:38.100
所以它先查到自己的

14:38.100 --> 14:39.100
上下文里边有没有C

14:39.100 --> 14:40.100
再执行吧

14:40.100 --> 14:42.100
在这个上下文里边执行

14:42.100 --> 14:43.100
执行上下文里边

14:43.100 --> 14:44.100
首先有没有C呢

14:44.100 --> 14:45.100
有

14:45.100 --> 14:46.100
于是输出了多少

14:46.100 --> 14:48.100
第一个输出了3 没问题吧

14:48.100 --> 14:49.100
所以说这次说明了

14:49.100 --> 14:50.100
含书里边

14:50.100 --> 14:51.100
可不可以使用自己的变量

14:51.100 --> 14:53.100
当然可以

14:53.100 --> 14:54.100
好 接下来输出B

14:54.100 --> 14:55.100
你看一下

14:55.100 --> 14:57.100
C的上下文里边

14:57.100 --> 14:58.100
有没有变量B

14:58.100 --> 14:59.100
有没有

14:59.100 --> 15:00.100
没有

15:00.100 --> 15:01.100
没有怎么办

15:01.100 --> 15:03.100
你看 根据黑色箭头来找

15:03.100 --> 15:04.100
黑色箭头

15:04.100 --> 15:05.100
找到含书C

15:05.100 --> 15:06.100
对吧

15:06.100 --> 15:07.100
含书C本身

15:07.100 --> 15:09.100
这是执行上下文

15:09.100 --> 15:11.100
是执行的时候才会创建

15:11.100 --> 15:13.100
而这个是含书本身

15:13.100 --> 15:14.100
管它执不执行

15:14.100 --> 15:15.100
它一直在的

15:15.100 --> 15:16.100
好

15:16.100 --> 15:17.100
然后找到这个含书C

15:17.100 --> 15:19.100
C里边是不是有一个属性Sculpt

15:19.100 --> 15:20.100
对吧

15:20.100 --> 15:21.100
通过这个Sculpt

15:21.100 --> 15:22.100
它之前

15:22.100 --> 15:23.100
创建含书C的时候

15:23.100 --> 15:24.100
它的上下文

15:24.100 --> 15:26.100
就找到这个上下文了

15:26.100 --> 15:27.100
那么能不能找到B

15:27.100 --> 15:28.100
就找到了

15:28.100 --> 15:29.100
输出G

15:29.100 --> 15:30.100
输出2

15:30.100 --> 15:32.100
它是用这种方式来找的

15:32.100 --> 15:33.100
好

15:33.100 --> 15:34.100
又来看

15:34.100 --> 15:35.100
你看这个里边没有

15:35.100 --> 15:36.100
这个里边没有

15:36.100 --> 15:37.100
是不是又继续找

15:37.100 --> 15:39.100
又看到这个VO里边

15:39.100 --> 15:40.100
它又指向了这个含书

15:40.100 --> 15:41.100
它是这个含书创建的

15:41.100 --> 15:43.100
于是又找到这个含书

15:43.100 --> 15:45.100
这个含书里边又有一个Sculpt

15:45.100 --> 15:47.100
又找到它之前的上下文

15:47.100 --> 15:48.100
它之前那个

15:48.100 --> 15:49.100
于是得到它

15:49.100 --> 15:51.100
得到了就是A

15:51.100 --> 15:52.100
看到没

15:52.100 --> 15:53.100
好 那么这个G

15:53.100 --> 15:54.100
是不是一样的

15:54.100 --> 15:55.100
对吧

15:55.100 --> 15:56.100
又从它开始找

15:56.100 --> 15:57.100
它找到这个含书

15:57.100 --> 15:58.100
通过这个含书找到Sculpt

15:58.100 --> 15:59.100
找到什么

15:59.100 --> 16:00.100
找到G

16:00.100 --> 16:01.100
看到没

16:01.100 --> 16:03.100
这就是为什么在含书里边

16:03.100 --> 16:05.100
可以使用外边的东西

16:05.100 --> 16:07.100
就是这个原因

16:07.100 --> 16:08.100
就是这么个原因

16:08.100 --> 16:11.100
含书里边可以使用外边的东西

16:11.100 --> 16:13.100
明白这个意思吧

16:13.100 --> 16:14.100
一定要区分开这两个

16:14.100 --> 16:16.100
这是含书本身的对象

16:16.100 --> 16:17.100
含书本身就是个对象

16:17.100 --> 16:18.100
我们说过了

16:18.100 --> 16:21.100
这是含书雕用的时候的对象

16:21.100 --> 16:23.100
执行上下文

16:23.100 --> 16:26.100
那么我们这样子问个问题

16:26.100 --> 16:27.100
是不是这两个是不是

16:27.100 --> 16:28.100
一一对应的关系

16:28.100 --> 16:30.100
是一一对应的关系吗

16:30.100 --> 16:31.100
这两个

16:31.100 --> 16:32.100
不是

16:32.100 --> 16:34.100
如果你调用多次

16:34.100 --> 16:35.100
是不是产生多个上下文

16:35.100 --> 16:36.100
我们之前讲过

16:36.100 --> 16:37.100
地规对吧

16:37.100 --> 16:38.100
产生多次上下文

16:38.100 --> 16:39.100
你反复调用

16:39.100 --> 16:40.100
反复的产生

16:40.100 --> 16:42.100
产生这个上下文

16:42.100 --> 16:43.100
但是这个东西

16:43.100 --> 16:44.100
是不是只有一个

16:44.100 --> 16:46.100
对吧 这含书对象本身

16:46.100 --> 16:47.100
一定要搞清楚

16:47.100 --> 16:48.100
这个过程

16:48.100 --> 16:49.100
这就是作用于链

16:49.100 --> 16:50.100
我就讲完了

16:50.100 --> 16:51.100
我就已经讲完了

16:51.100 --> 16:52.100
为什么含书里边

16:52.100 --> 16:53.100
可以用外面的

16:53.100 --> 16:55.100
就是因为它形成一条链了

16:55.100 --> 16:56.100
在含书创建的时候

16:56.100 --> 16:57.100
它就会有这么一个属性

16:57.100 --> 16:59.100
它记录了之前的围油

16:59.100 --> 17:00.100
那围油中的东西

17:00.100 --> 17:01.100
它都可以使用了

17:02.100 --> 17:03.100
好 接下来

17:03.100 --> 17:05.100
我们来看很多的细节

17:05.100 --> 17:07.100
我们看一下TES2

17:08.100 --> 17:09.100
TES2里面

17:09.100 --> 17:12.410
我们写这么一个代码

17:12.410 --> 17:14.410
比方说一个含书

17:14.410 --> 17:16.410
它里边有个变量COT

17:16.410 --> 17:18.410
等于0

17:18.410 --> 17:20.410
返回一个含书

17:20.410 --> 17:21.410
返回一个地名含书

17:21.410 --> 17:22.410
一个含书表老师

17:22.410 --> 17:23.410
对不对

17:23.410 --> 17:24.410
好 这里边

17:24.410 --> 17:25.410
COT++

17:26.410 --> 17:27.410
然后输出COT

17:30.040 --> 17:31.040
然后外面

17:31.040 --> 17:33.040
你看它含书能不能作为返回值

17:34.040 --> 17:36.040
含书是GS里面的一等公名

17:36.040 --> 17:38.040
它怎么不可能作为返回值的

17:38.040 --> 17:39.040
它一定可以

17:39.040 --> 17:41.040
任何包括什么参数

17:41.040 --> 17:43.040
返回值 什么都可以

17:43.040 --> 17:45.040
所以含书本质就是个对象

17:45.040 --> 17:46.040
你返回一个对象可不可以

17:46.040 --> 17:47.040
当然可以

17:47.040 --> 17:48.040
所以它返回一个含书

17:48.040 --> 17:49.040
那么接下来

17:49.040 --> 17:50.040
我们随便用个变量

17:50.040 --> 17:51.040
来接受一下

17:52.040 --> 17:53.040
调用A

17:53.040 --> 17:54.040
得到A的返回结果

17:54.040 --> 17:55.040
返回结果是不是含书

17:55.040 --> 17:56.040
它是不是含书

17:56.040 --> 17:57.040
它也是个含书 对吧

17:57.040 --> 17:58.040
然后调用TES

17:58.040 --> 17:59.040
调用3次

18:00.040 --> 18:01.040
然后我们在外面

18:01.040 --> 18:02.040
再输出COT

18:02.040 --> 18:03.040
看一下

18:04.040 --> 18:05.040
这个程序

18:05.040 --> 18:06.040
会得到什么样的结果

18:06.040 --> 18:07.040
这很有可能

18:07.040 --> 18:08.040
就是你们将来

18:08.040 --> 18:09.040
做到一道面试题

18:09.040 --> 18:10.040
可能原题不是这样子

18:10.040 --> 18:11.040
但是结构

18:11.040 --> 18:12.040
可能就差不多是这样子

18:15.040 --> 18:16.040
接下来我们来看一下

18:17.040 --> 18:20.250
复制

18:20.250 --> 18:21.250
接下来

18:21.250 --> 18:22.250
我们把这些东西

18:22.250 --> 18:23.250
全部删了

18:23.250 --> 18:24.250
就这一块保留

18:24.250 --> 18:28.990
这一块保留

18:28.990 --> 18:29.990
删了

18:30.990 --> 18:31.990
这个不能删

18:31.990 --> 18:34.560
好 删掉

18:34.560 --> 18:35.560
删掉

18:35.560 --> 18:36.560
好 接下来

18:36.560 --> 18:37.560
我们来挨在这里看

18:37.560 --> 18:39.560
首先是全局环境

18:39.560 --> 18:40.560
全局环境里边

18:40.560 --> 18:41.560
我们先别看别的

18:41.560 --> 18:42.560
就看全局环境

18:42.560 --> 18:44.560
有变量和含书 对吧

18:44.560 --> 18:45.560
变量含书

18:45.560 --> 18:46.560
变量是啥

18:46.560 --> 18:47.560
变量是TES

18:47.560 --> 18:48.560
含书是A

18:48.560 --> 18:49.560
OK 来吧

18:49.560 --> 18:50.560
变量是啥

18:50.560 --> 18:51.560
变量是TES

18:51.560 --> 18:52.560
TES

18:52.560 --> 18:53.560
怎么

18:53.560 --> 18:54.560
Undefined

18:54.560 --> 18:55.560
含书是啥

18:55.560 --> 18:56.560
含书是A

18:56.560 --> 18:57.560
那是不是创建了个含书

18:57.560 --> 18:58.560
没问题吧

18:58.560 --> 18:59.560
创建个含书

18:59.560 --> 19:00.560
含书是啥

19:00.560 --> 19:01.560
方个型

19:01.560 --> 19:03.560
A

19:03.560 --> 19:04.560
含书A

19:04.560 --> 19:05.560
含书A里边是U啥

19:05.560 --> 19:06.560
是不是又Sculpt

19:06.560 --> 19:07.560
对吧

19:07.560 --> 19:08.560
Sculpt

19:09.560 --> 19:10.560
好 接下来了

19:10.560 --> 19:11.560
剑头直播去

19:11.560 --> 19:12.560
这个含书

19:12.560 --> 19:14.560
这个A指向这个含书

19:14.560 --> 19:15.560
这个剑头不是很重要

19:15.560 --> 19:16.560
这个不是很重要

19:16.560 --> 19:18.560
它肯定是指向这个含书

19:18.560 --> 19:19.560
我们主要是看这

19:19.560 --> 19:21.560
看这个玩意

19:21.560 --> 19:23.560
就是Sculpt

19:23.560 --> 19:24.560
是不是就指回来

19:24.560 --> 19:25.560
指向这个上下文

19:25.560 --> 19:26.560
对吧

19:26.560 --> 19:27.560
因为它是在全局上下文里边创建的

19:27.560 --> 19:28.560
所以它会指回来

19:28.560 --> 19:29.560
它会指回来

19:29.560 --> 19:30.560
这是啥玩意

19:30.560 --> 19:37.230
这是啥呀

19:37.230 --> 19:38.230
管它了

19:38.230 --> 19:39.230
管它了

19:39.230 --> 19:40.230
你在这个意识就行了

19:41.230 --> 19:42.230
有PBT有的是

19:42.230 --> 19:43.230
算了

19:43.230 --> 19:44.230
我真的强迫症

19:44.230 --> 19:47.440
真的受不了

19:47.440 --> 19:49.440
PBT还有时候会出问题

19:49.440 --> 19:50.440
好 形成这么一种结构

19:50.440 --> 19:51.440
对吧

19:51.440 --> 19:52.440
好 现在开始执行

19:52.440 --> 19:53.440
开始执行

19:53.440 --> 19:54.440
那么第一句话

19:54.440 --> 19:55.440
是不是就在调用A

19:55.440 --> 19:56.440
对不对

19:56.440 --> 19:57.440
就在调用

19:57.440 --> 19:58.440
边

19:58.440 --> 19:59.440
就在调用含书A

19:59.440 --> 20:00.440
那是不是创建一个新的上下文

20:00.440 --> 20:01.440
对吧

20:01.440 --> 20:02.440
含书A的上下文

20:02.440 --> 20:04.440
含书A

20:04.440 --> 20:05.440
它的上下文

20:06.440 --> 20:07.440
这里边是什么

20:07.440 --> 20:08.440
AO

20:08.440 --> 20:09.440
或者是VO

20:09.440 --> 20:10.440
都一个意思

20:10.440 --> 20:11.440
好

20:11.440 --> 20:13.440
那么AO里边是不是要指向

20:13.440 --> 20:14.440
指向一块东西

20:14.440 --> 20:15.440
对吧

20:15.440 --> 20:16.440
来开始创建AO了

20:17.440 --> 20:18.440
上几课的知识了

20:18.440 --> 20:19.440
怎么创建的

20:19.440 --> 20:20.440
它里边有哪些东西

20:20.440 --> 20:21.440
A里边

20:21.440 --> 20:22.440
含书A里边

20:22.440 --> 20:23.440
你看一下

20:23.440 --> 20:24.440
有一个辨量COT

20:24.440 --> 20:25.440
还有啥

20:25.440 --> 20:26.440
有没有含书

20:26.440 --> 20:27.440
有没有含书字面量

20:28.440 --> 20:29.440
没有吧

20:29.440 --> 20:30.440
这是含书表达式

20:30.440 --> 20:31.440
它没有含书字面量

20:31.440 --> 20:33.440
所以说它只有一个属性

20:33.440 --> 20:34.440
一个属性COT

20:34.440 --> 20:35.440
对吧

20:35.440 --> 20:36.440
就没了

20:36.440 --> 20:37.440
没其他的了

20:37.440 --> 20:38.440
然后运行这个含书

20:38.440 --> 20:40.440
把COT扣成了副字为0

20:40.440 --> 20:42.440
把它副字为0

20:42.440 --> 20:44.440
没问题吧

20:44.440 --> 20:46.440
好 接下来返回啥呢

20:46.440 --> 20:47.440
返回一个表达式

20:47.440 --> 20:48.440
这个表达式是一个含书

20:48.440 --> 20:50.440
是不是新创建的那个含书

20:50.440 --> 20:51.440
对吧

20:51.440 --> 20:52.440
相当于在这里什么

20:52.440 --> 20:53.440
溜了一个方形

20:53.440 --> 20:55.440
新创建的一个含书

20:55.440 --> 20:56.440
于是这里是不是

20:56.440 --> 20:57.440
有一个新的含书产生了

20:57.440 --> 20:58.440
我们把它叫做匿名含书

20:58.440 --> 20:59.440
没有名字

20:59.440 --> 21:00.440
匿名

21:00.440 --> 21:01.440
含书

21:01.440 --> 21:02.440
它是不是有SGOP

21:02.440 --> 21:03.440
对吧

21:03.440 --> 21:04.440
是不是匿名含书

21:04.440 --> 21:05.440
它肯定有SGOP

21:05.440 --> 21:06.440
肯定有这个属性

21:06.440 --> 21:07.440
于是SGOP是不是指向

21:07.440 --> 21:09.440
创建这个含书的上下文

21:09.440 --> 21:10.440
是不是指向这个上下文

21:10.440 --> 21:11.440
对吧

21:11.440 --> 21:12.440
没问题吧

21:12.440 --> 21:13.440
那么另外一方面

21:13.440 --> 21:16.440
由于这个上下文的VO

21:16.440 --> 21:17.440
它这个VO

21:17.440 --> 21:20.440
是由调用A含书的创建的

21:20.440 --> 21:22.440
所以说它会有个地址

21:22.440 --> 21:23.440
它会指向A

21:23.440 --> 21:25.440
形成了这么一种结构

21:25.440 --> 21:26.440
好好看一下

21:26.440 --> 21:27.440
跟之前是不是一样的

21:27.440 --> 21:28.440
有啥区别呢

21:28.440 --> 21:29.440
接下来

21:29.440 --> 21:31.440
我们继续看

21:31.440 --> 21:32.440
继续看

21:32.440 --> 21:34.440
那么这个创建好的含书过后

21:34.440 --> 21:35.440
它干了什么事情呢

21:35.440 --> 21:37.440
它把这个含书返回

21:37.440 --> 21:39.440
现在还没有调用这个含书

21:39.440 --> 21:40.440
你不要去管含书里边的东西

21:40.440 --> 21:42.440
它把这个含书返回了

21:42.440 --> 21:43.440
好

21:43.440 --> 21:44.440
返回了过后

21:44.440 --> 21:47.440
那么这个A调用是不是结束了

21:47.440 --> 21:48.440
A执行是不是结束了

21:48.440 --> 21:49.440
含书执行

21:49.440 --> 21:50.440
是不是结束了

21:50.440 --> 21:51.440
它返回了

21:51.440 --> 21:52.440
含书A结束了

21:52.440 --> 21:53.440
是不是它这个AO消失

21:53.440 --> 21:54.440
对吧

21:54.440 --> 21:55.440
它这个含书指向上下文消失

21:55.440 --> 21:56.440
不见了

21:56.440 --> 21:57.440
对不对

21:57.440 --> 21:58.440
不见了

21:58.440 --> 22:00.440
但是这个东西是不是还存在

22:00.440 --> 22:01.440
这个东西是不是还存在

22:01.440 --> 22:02.440
这个AO是不是还存在

22:02.440 --> 22:04.440
因为它是另外困的存空间

22:04.440 --> 22:06.440
本来它应该消失的

22:06.440 --> 22:08.440
本来它也应该跟着消失的

22:08.440 --> 22:09.440
因为我们之前说过

22:09.440 --> 22:11.440
GS里边有垃圾回收器

22:11.440 --> 22:12.440
它发现找不到的对象

22:12.440 --> 22:14.440
它就会把它回收掉

22:14.440 --> 22:15.440
但是这个对象还找得到

22:15.440 --> 22:17.440
它可以通过它来找到

22:17.440 --> 22:18.440
看见没

22:18.440 --> 22:19.440
这个对象它不会消失的

22:19.440 --> 22:20.440
它会保留进来

22:20.440 --> 22:21.440
看到没

22:21.440 --> 22:22.440
好

22:22.440 --> 22:23.440
那么接下来

22:23.440 --> 22:24.440
把这个对象复制给谁呢

22:24.440 --> 22:25.440
把这个返回的含书

22:25.440 --> 22:26.440
这个含书是返回值

22:26.440 --> 22:27.440
把它复制给谁呢

22:27.440 --> 22:28.440
复制给TES

22:28.440 --> 22:30.440
又回到拳句环境了

22:30.440 --> 22:31.440
你看这里

22:31.440 --> 22:33.440
又回到拳句上向文执行的

22:33.440 --> 22:34.440
它把这个含书复制给谁

22:34.440 --> 22:35.440
复制个TES

22:35.440 --> 22:36.440
于是TES指向了谁

22:36.440 --> 22:38.440
是不是指向了这个含书

22:38.440 --> 22:39.440
对吧

22:39.440 --> 22:41.440
TES它又指向了这个含书

22:41.440 --> 22:45.900
看着

22:45.900 --> 22:46.900
它又指向了这个含书

22:46.900 --> 22:47.900
看没

22:47.900 --> 22:49.900
它把这个含书的引用

22:49.900 --> 22:50.900
就是它的含书地址

22:50.900 --> 22:51.900
是不是复制给它

22:51.900 --> 22:52.900
它又指向了这个含书

22:52.900 --> 22:53.900
好 现在还在拳句上向文

22:53.900 --> 22:55.900
上向文只有一个了

22:55.900 --> 22:56.900
但是之前的那个VO

22:56.900 --> 22:57.900
是不是保留下来了

22:57.900 --> 22:58.900
被它保留下来了

22:58.900 --> 22:59.900
对吧

22:59.900 --> 23:00.900
为什么它不能消失

23:00.900 --> 23:01.900
为什么垃圾毁收器

23:01.900 --> 23:02.900
不法毁收掉

23:02.900 --> 23:03.900
你看一下是不是能找到

23:03.900 --> 23:04.900
这个对象

23:04.900 --> 23:05.900
怎么找

23:05.900 --> 23:06.900
拳句上向文那边

23:06.900 --> 23:07.900
不是有个变量TES吗

23:07.900 --> 23:08.900
通了TES是不是找到它

23:08.900 --> 23:09.900
通了它的SCOPE

23:09.900 --> 23:10.900
是不是可以找到它

23:10.900 --> 23:11.900
对不对

23:11.900 --> 23:12.900
所以它不能消失的

23:12.900 --> 23:13.900
它不能消失的

23:13.900 --> 23:14.900
好 接下来

23:14.900 --> 23:15.900
我们调用TES

23:15.900 --> 23:16.900
调用TES是不是

23:16.900 --> 23:17.900
执行那边的代码

23:17.900 --> 23:18.900
对吧

23:18.900 --> 23:19.900
Court加加

23:19.900 --> 23:20.900
好

23:20.900 --> 23:22.900
现在开始执行这个含书

23:22.900 --> 23:24.900
但是在执行含书之前

23:24.900 --> 23:25.900
你在调用含书

23:25.900 --> 23:27.900
要不要创建上向文

23:27.900 --> 23:28.900
要不要

23:28.900 --> 23:29.900
肯定要

23:29.900 --> 23:30.900
每一次看到调用含书

23:30.900 --> 23:31.900
都要创建一个上下文

23:31.900 --> 23:32.900
于是这一块

23:32.900 --> 23:34.900
它创建了一个上下文TES

23:34.900 --> 23:35.900
含书

23:35.900 --> 23:36.900
那么这里是VO

23:36.900 --> 23:37.900
也叫做AO

23:37.900 --> 23:38.900
都行

23:38.900 --> 23:39.900
当前执行的含书

23:39.900 --> 23:40.900
也叫做AO

23:40.900 --> 23:41.900
好 那么这里

23:41.900 --> 23:42.900
是不是有个新的内存空间

23:42.900 --> 23:43.900
对吧

23:43.900 --> 23:44.900
它要存东西

23:44.900 --> 23:45.900
存这个含书执行

23:45.900 --> 23:46.900
所需要的一些信息

23:46.900 --> 23:47.900
当然了

23:47.900 --> 23:48.900
这个内存空间

23:48.900 --> 23:49.900
它又会指向这个含书

23:49.900 --> 23:50.900
为什么会指向它

23:50.900 --> 23:51.900
因为你现在调用的是

23:51.900 --> 23:52.900
TES含书

23:52.900 --> 23:53.900
TES含书是不是就是它

23:53.900 --> 23:54.900
对不对

23:54.900 --> 23:55.900
就是它

23:55.900 --> 23:56.900
它是存在地址

23:56.900 --> 23:57.900
本质上就是它

23:57.900 --> 23:58.900
它也会指向这个

23:58.900 --> 24:00.900
含书的对象

24:00.900 --> 24:01.900
好 接下来

24:01.900 --> 24:02.900
我们把连过来

24:03.900 --> 24:04.900
于是形成了这么一种结构

24:04.900 --> 24:05.900
好好看一下

24:05.900 --> 24:06.900
给你看五分钟

24:06.900 --> 24:07.900
把这个结构先理解

24:09.900 --> 24:10.900
没问题吧

24:11.900 --> 24:12.900
好 接下来

24:12.900 --> 24:13.900
我们再开始执行

24:13.900 --> 24:14.900
这个含书

24:14.900 --> 24:15.900
VO创建好了

24:15.900 --> 24:16.900
执行这个含书的时候

24:16.900 --> 24:17.900
它里边

24:18.900 --> 24:19.900
有变量吗

24:19.900 --> 24:20.900
没有

24:20.900 --> 24:21.900
有含书吗

24:21.900 --> 24:22.900
没有

24:22.900 --> 24:23.900
有参数吗

24:23.900 --> 24:24.900
没有

24:24.900 --> 24:25.900
所以说这里是空的

24:25.900 --> 24:26.900
当然还有一个

24:27.900 --> 24:28.900
这边啥都没有

24:28.900 --> 24:29.900
没关系

24:29.900 --> 24:30.900
不影响执行

24:30.900 --> 24:31.900
然后这里边

24:31.900 --> 24:32.900
再使用什么变量

24:32.900 --> 24:33.900
Cort

24:33.900 --> 24:35.900
对吧 再使用Cort这个变量

24:35.900 --> 24:37.900
好 使用它这个变量的时候

24:37.900 --> 24:39.900
那么我们来开始找

24:39.900 --> 24:41.900
它里边有Cort吗

24:41.900 --> 24:43.900
先找当前你执行的

24:43.900 --> 24:44.900
执行的东西的

24:44.900 --> 24:45.900
上下文

24:45.900 --> 24:46.900
就是AO

24:46.900 --> 24:47.900
先找AO

24:47.900 --> 24:48.900
AO里边有没有Cort

24:48.900 --> 24:49.900
没有吧

24:49.900 --> 24:50.900
没有从电上找

24:50.900 --> 24:51.900
你看这个箭头

24:51.900 --> 24:53.900
是不是形成一条电了

24:53.900 --> 24:55.900
从电上找

24:55.900 --> 24:57.900
然后找这边的Cort

24:57.900 --> 24:58.900
当然你可以

24:58.900 --> 24:59.900
甚至有些教程里面

24:59.900 --> 25:00.900
就直接画过来了

25:00.900 --> 25:01.900
就直接画过来了

25:01.900 --> 25:02.900
但是我们这里

25:02.900 --> 25:03.900
实际上是经过了一步

25:03.900 --> 25:06.900
找这个指向含书的Cort

25:06.900 --> 25:08.900
找这个Cort属性

25:08.900 --> 25:10.900
找它Cort属性指向了啥

25:10.900 --> 25:11.900
指向了

25:11.900 --> 25:12.900
之前的VO

25:12.900 --> 25:13.900
找到它之前的VO

25:13.900 --> 25:14.900
就是创建

25:14.900 --> 25:16.900
之前创建这个含书的时候的VO

25:16.900 --> 25:17.900
找到这个

25:18.900 --> 25:19.900
这个里边有Cort吗

25:19.900 --> 25:20.900
所以有 对不对

25:20.900 --> 25:21.900
有

25:21.900 --> 25:23.900
那就不需要继续往后找了吧

25:23.900 --> 25:24.900
不需要了吧

25:24.900 --> 25:25.900
那么就找到了

25:25.900 --> 25:26.900
把它加1

25:26.900 --> 25:27.900
它是不是变成1了

25:27.900 --> 25:28.900
对不对

25:28.900 --> 25:29.900
好 变成1之后

25:29.900 --> 25:31.900
那么输出就输出1

25:31.900 --> 25:32.900
对不对

25:32.900 --> 25:34.900
好 那么这个含书是不是运行完了

25:34.900 --> 25:35.900
运行完了之后

25:35.900 --> 25:36.900
那这个是不是消失

25:36.900 --> 25:37.900
对不对

25:37.900 --> 25:38.900
这个消失

25:38.900 --> 25:39.900
好 那你看一下

25:39.900 --> 25:40.900
这块内存空间

25:40.900 --> 25:41.900
内存空间里边

25:41.900 --> 25:42.900
还有没有东西指向它

25:42.900 --> 25:43.900
是没有了

25:43.900 --> 25:45.900
没有任何东西指向它了

25:45.900 --> 25:47.900
因此它也会跟着消失

25:47.900 --> 25:48.900
好 第二次执行

25:48.900 --> 25:50.900
是不是有点重新来一遍

25:50.900 --> 25:52.900
第二次执行是不是重新来一遍

25:52.900 --> 25:53.900
又来一遍

25:53.900 --> 25:54.900
重新这个含书

25:54.900 --> 25:55.900
又创建一块新的内存空间

25:55.900 --> 25:56.900
VO

25:56.900 --> 25:57.900
然后又来找Cort

25:57.900 --> 25:58.900
又没有找到

25:58.900 --> 25:59.900
对吧

25:59.900 --> 26:00.900
又加1

26:00.900 --> 26:01.900
找了找好了

26:01.900 --> 26:02.900
加1

26:02.900 --> 26:03.900
好 你看一下

26:03.900 --> 26:04.900
就形成了这么一种

26:04.900 --> 26:05.900
这么一种情况了

26:05.900 --> 26:06.900
又消失

26:06.900 --> 26:07.900
好 第三次调用

26:07.900 --> 26:08.900
是不是又来

26:08.900 --> 26:09.900
又来一次

26:09.900 --> 26:10.900
变成3

26:10.900 --> 26:12.900
然后这里又消失

26:12.900 --> 26:13.900
又消失

26:13.900 --> 26:14.900
看没有

26:14.900 --> 26:15.900
形成这么一种结构

26:16.900 --> 26:17.900
没问题吧

26:17.900 --> 26:18.900
那么这里输出多少

26:18.900 --> 26:19.900
123

26:19.900 --> 26:20.900
对不对

26:20.900 --> 26:21.900
123

26:21.900 --> 26:22.900
每次调用

26:22.900 --> 26:25.900
好 最后在全局上下文里边输出Cort

26:25.900 --> 26:26.900
能输出吗

26:26.900 --> 26:29.900
全局上下文里边能输出Cort吗

26:29.900 --> 26:30.900
看一下吧

26:30.900 --> 26:31.900
当然你可以看这个代码

26:31.900 --> 26:32.900
这个代码Cort在哪里定你的

26:32.900 --> 26:33.900
在这里定你的

26:33.900 --> 26:34.900
对吧

26:34.900 --> 26:35.900
所以说肯定不能输出

26:35.900 --> 26:37.900
但是我们来看一下这个图

26:37.900 --> 26:39.900
现在继续执行全局上下文

26:39.900 --> 26:40.900
那么先找自己

26:40.900 --> 26:41.900
对吧

26:41.900 --> 26:42.900
自己里边有没有Cort

26:42.900 --> 26:43.900
没有

26:43.900 --> 26:44.900
没有还能找吗

26:44.900 --> 26:45.900
你看这个箭头还能找吗

26:45.900 --> 26:46.900
没法找了

26:46.900 --> 26:47.900
它没法找了

26:47.900 --> 26:48.900
没有办法找了

26:48.900 --> 26:50.900
所以说它这里就结束了

26:50.900 --> 26:52.900
就得不到 找不到了

26:52.900 --> 26:53.900
所以说这里输出啥

26:53.900 --> 26:56.900
123和不是ND犯报错

26:56.900 --> 26:58.900
报错也是这种答案

26:58.900 --> 26:59.900
报错

26:59.900 --> 27:01.900
你看最后一个是报错的

27:01.900 --> 27:02.900
Cortis not Defend

27:03.900 --> 27:04.900
这是啥呀

27:04.900 --> 27:06.900
这就是必报现象

27:07.900 --> 27:09.900
必报现象从广义上来说

27:09.900 --> 27:11.900
就是一个函数里边用外面的东西

27:11.900 --> 27:12.900
就是必报

27:13.900 --> 27:14.900
从狭义上来说

27:14.900 --> 27:16.900
就是外边的东西已经消失了

27:16.900 --> 27:18.900
外边的上下文已经消失了

27:18.900 --> 27:21.900
但是这个函数还把它的东西保留了下来

27:21.900 --> 27:22.900
你看这个函数

27:22.900 --> 27:24.900
把它之前的唯有保留了下来

27:24.900 --> 27:25.900
因为它还有引用

27:25.900 --> 27:26.900
它还有这个地址

27:26.900 --> 27:27.900
所以说它不能消失

27:27.900 --> 27:28.900
不能把它清除掉

27:28.900 --> 27:30.900
尽管它的这个函数

27:30.900 --> 27:32.900
创建Cortis这个函数

27:32.900 --> 27:33.900
早就没了

27:33.900 --> 27:34.900
早就执行结束了

27:34.900 --> 27:35.900
但是呢

27:35.900 --> 27:37.900
这个东西被保留下来了

27:38.900 --> 27:39.900
这个特点

27:39.900 --> 27:41.900
在咱们之后

27:41.900 --> 27:43.900
做一些特别的模式的时候

27:43.900 --> 27:45.900
后面我们会讲一些

27:45.900 --> 27:47.900
介石里边的一些模式

27:47.900 --> 27:49.900
做一些很特别的东西的时候

27:49.900 --> 27:51.900
非常非常有用

27:51.900 --> 27:53.900
就是返回一个函数

27:53.900 --> 27:55.900
这个函数用的它是一个局部辨量

27:55.900 --> 27:57.900
用这个函数内部的局部辨量

27:57.900 --> 27:58.900
那么这个局部辨量

27:58.900 --> 27:59.900
它就会保留下来

27:59.900 --> 28:01.900
延长了它的生命周期

28:01.900 --> 28:03.900
它的生命被延长了

28:03.900 --> 28:05.900
本来应该被变成垃圾

28:05.900 --> 28:06.900
被毁受掉的

28:06.900 --> 28:07.900
被处理掉的

28:07.900 --> 28:08.900
但是呢

28:08.900 --> 28:09.900
由于这个函数的原因

28:09.900 --> 28:10.900
把它保留下来了

28:12.900 --> 28:13.900
那如果将来

28:13.900 --> 28:15.900
我们做这么一件事

28:15.900 --> 28:16.900
如果说将来

28:17.900 --> 28:19.900
这个tess负责为垃圾了

28:20.900 --> 28:21.900
那又看

28:21.900 --> 28:22.900
tess如果变成垃圾了

28:22.900 --> 28:24.900
它是不是不再指向这个了

28:24.900 --> 28:25.900
对吧

28:25.900 --> 28:26.900
那么我们现在找不到

28:26.900 --> 28:27.900
任何一个辨量

28:27.900 --> 28:28.900
可以找到这个东西

28:28.900 --> 28:29.900
找不到任何一个辨量

28:29.900 --> 28:30.900
可以找到这个东西了

28:30.900 --> 28:31.900
对不对

28:31.900 --> 28:32.900
这个东西是不是消失了

28:32.900 --> 28:33.900
那这个东西消失了

28:33.900 --> 28:34.900
是不是找不到任何东西

28:34.900 --> 28:35.900
可以找到它了

28:35.900 --> 28:36.900
是不是它也跟着消失了

28:36.900 --> 28:37.900
对吧

28:37.900 --> 28:38.900
它也会被清除掉

28:38.900 --> 28:40.900
但是如果你没有把它负责为垃圾

28:40.900 --> 28:41.900
它会一直在

28:41.900 --> 28:43.900
它会一直在

28:43.900 --> 28:44.900
因为通过tess

28:44.900 --> 28:45.900
可以找到它

28:45.900 --> 28:46.900
那么它

28:46.900 --> 28:47.900
是不是可以找到它

28:47.900 --> 28:48.900
对不对

28:48.900 --> 28:49.900
会一直在

28:49.900 --> 28:50.900
这就是一个必包现象

28:50.900 --> 28:51.900
从广音上来说

28:51.900 --> 28:52.900
必包很简单

28:52.900 --> 28:53.900
就是里边用外面的东西

28:53.900 --> 28:55.900
从详意上来说的话

28:55.900 --> 28:56.900
就是这种现象

28:56.900 --> 28:57.900
就是说有的时候

28:57.900 --> 28:59.900
我们利用必包来干一些什么事

28:59.900 --> 29:00.900
就可以用

29:00.900 --> 29:02.900
就是可以做这么一个操作

29:02.900 --> 29:04.900
把函数里边的局部辨量

29:04.900 --> 29:05.900
保留到了

29:05.900 --> 29:07.900
保留到了另外一个函数里边

29:07.900 --> 29:08.900
之前的函数早就消失了

29:08.900 --> 29:11.900
但是它的vo被保留下来了

29:12.900 --> 29:13.900
这是这么一个特点

29:13.900 --> 29:14.900
好

29:14.900 --> 29:15.900
再问大家一个问题

29:15.900 --> 29:17.900
那如果这里写caught

29:17.900 --> 29:21.470
现在又输出啥

29:21.470 --> 29:23.470
现在又输出啥

29:23.470 --> 29:26.470
又输出啥呢

29:26.470 --> 29:29.470
又输出啥

29:29.470 --> 29:30.470
那么现在关键点在于

29:30.470 --> 29:31.470
这里的caught

29:31.470 --> 29:32.470
加加这里的caught

29:32.470 --> 29:34.470
用的是全局的

29:34.470 --> 29:35.470
还是用的是这个

29:35.470 --> 29:37.470
用的是哪一个呢

29:37.470 --> 29:39.470
用的是哪一个呢

29:39.470 --> 29:43.470
用的一定是函数声明的时候

29:43.470 --> 29:46.470
它的vo里边的东西

29:46.470 --> 29:49.470
你看一下我们刚才这个例子

29:49.470 --> 29:51.470
现在又找caught

29:51.470 --> 29:53.470
一开始是0

29:53.470 --> 29:54.470
那么接下来找

29:54.470 --> 29:55.470
自己里边没有

29:55.470 --> 29:57.470
没有是不是找到它了

29:57.470 --> 29:58.470
现在这里边有个caught

29:58.470 --> 29:59.470
那有用吗

29:59.470 --> 30:01.470
还找不到它

30:01.470 --> 30:02.470
还找不到它

30:02.470 --> 30:03.470
因为找到这里就停止了

30:03.470 --> 30:05.470
但是如果函数a里边

30:05.470 --> 30:06.470
没有这个东西的话

30:06.470 --> 30:07.470
肯定找到了它了

30:07.470 --> 30:08.470
函数a里边有这个东西

30:08.470 --> 30:09.470
是不是

30:09.470 --> 30:10.470
就找到函数a里边的东西

30:10.470 --> 30:12.470
一定找到它离它最近的

30:12.470 --> 30:13.470
这个caught

30:13.470 --> 30:14.470
你这样子感知就可以

30:14.470 --> 30:16.470
这样子从感性上认识的话

30:16.470 --> 30:18.470
也行

30:18.470 --> 30:19.470
好

30:19.470 --> 30:20.470
比方说

30:20.470 --> 30:22.470
再来个例子

30:22.470 --> 30:23.470
再来个例子

30:23.470 --> 30:26.470
这个例子就非常具有迷惑性的

30:26.470 --> 30:28.470
比方说

30:28.470 --> 30:30.470
咱们写这么一个

30:30.470 --> 30:32.470
我想写啥

30:32.470 --> 30:34.470
写一个变两a嘛

30:34.470 --> 30:35.470
写个变两a

30:35.470 --> 30:39.040
然后写这么一个函数

30:39.040 --> 30:41.040
函数a

30:41.040 --> 30:43.040
输出变两a

30:43.040 --> 30:45.040
就输出变两a就完事了

30:45.040 --> 30:47.040
非常简单

30:47.040 --> 30:49.040
然后的话

30:49.040 --> 30:51.040
我们

30:51.040 --> 30:53.040
再写个函数

30:55.040 --> 30:57.040
special

30:57.040 --> 30:59.040
一个特殊的函数

30:59.040 --> 31:01.040
也没啥特殊的

31:01.040 --> 31:02.040
然后这个函数里边

31:02.040 --> 31:04.040
我们把这个a

31:04.040 --> 31:06.040
a复制给b

31:06.040 --> 31:08.040
然后在这里定一个a

31:08.040 --> 31:09.040
等于5

31:09.040 --> 31:10.040
好

31:10.040 --> 31:12.040
这里掉用函数b

31:12.040 --> 31:14.040
就特别具有迷惑性

31:14.040 --> 31:15.040
这个东西

31:15.040 --> 31:17.040
special

31:19.040 --> 31:21.040
关键是他输出1还是5

31:21.040 --> 31:24.800
关键是输出1

31:24.800 --> 31:26.800
还是5

31:26.800 --> 31:29.180
我告诉大家

31:29.180 --> 31:30.180
他输出1

31:30.180 --> 31:31.180
他输出1

31:31.180 --> 31:32.180
而不是5

31:32.180 --> 31:33.180
这就奇怪了

31:33.180 --> 31:35.180
不是说理他最近的吗

31:35.180 --> 31:37.180
所以我说的理他最近的意思是

31:37.180 --> 31:39.180
他声明的时候

31:39.180 --> 31:41.180
理他最近的

31:41.180 --> 31:43.180
因为我们这个b寶寶

31:44.180 --> 31:46.180
就这个属性

31:46.180 --> 31:48.180
他一定是看他声明的时候

31:48.180 --> 31:49.180
声明这个函数的时候

31:49.180 --> 31:51.180
就创建这个函数的时候

31:51.180 --> 31:53.180
他所在的作用欲

31:53.180 --> 31:55.180
而不是他运行的时候的作用欲

31:55.180 --> 31:57.180
他一定是他声明的时候的作用欲

31:57.180 --> 31:59.180
咱们再来看一下他过程

31:59.180 --> 32:01.180
他的过程比较复杂

32:01.180 --> 32:03.180
但是你理解起来其实很简单

32:03.180 --> 32:05.180
你看这个函数声明的时候

32:05.180 --> 32:06.180
a是谁

32:06.180 --> 32:07.180
a是谁

32:07.180 --> 32:08.180
对不对

32:08.180 --> 32:09.180
那就是他

32:09.180 --> 32:11.180
咱们来看一下吧

32:11.180 --> 32:14.450
看一下

32:14.450 --> 32:15.450
好

32:15.450 --> 32:16.450
于是我们这里

32:16.450 --> 32:17.450
一个群聚环境

32:17.450 --> 32:18.450
一个群聚环境

32:18.450 --> 32:19.450
来吧

32:24.720 --> 32:26.720
温度里面的属性

32:26.720 --> 32:27.720
然后有啥

32:27.720 --> 32:29.720
有一个函数a和一个函数special

32:29.720 --> 32:30.720
对吧

32:30.720 --> 32:32.720
还有一个函数special

32:34.720 --> 32:35.720
一个函数a和一个函数special

32:35.720 --> 32:36.720
有变量吗

32:36.720 --> 32:37.720
有个变量a

32:37.720 --> 32:39.720
有个变量a

32:39.720 --> 32:41.720
变量a的值多少

32:41.720 --> 32:42.720
多少

32:42.720 --> 32:43.720
是不是1

32:43.720 --> 32:45.720
另外a和special

32:45.720 --> 32:46.720
都是一个函数

32:46.720 --> 32:47.720
好

32:47.720 --> 32:48.720
首先special

32:48.720 --> 32:49.720
a指向这

32:49.720 --> 32:50.720
a指向这

32:50.720 --> 32:51.720
有个函数

32:51.720 --> 32:52.720
对吧

32:52.720 --> 32:53.720
a的scope指向谁呢

32:53.720 --> 32:55.720
a的scope又指回来

32:55.720 --> 32:56.720
对不对

32:56.720 --> 32:57.720
我们先把图画出来

32:57.720 --> 32:59.720
就是如果你说面词题遇到这种题

32:59.720 --> 33:01.720
他想着理

33:01.720 --> 33:02.720
那么你自己觉得

33:02.720 --> 33:03.720
又没有什么信心

33:03.720 --> 33:04.720
直接看不出来

33:04.720 --> 33:06.720
那么你就把图画好

33:06.720 --> 33:07.720
scope是不是指向

33:07.720 --> 33:08.720
scope是不是指回来

33:08.720 --> 33:09.720
对不对

33:09.720 --> 33:10.720
指回来

33:10.720 --> 33:11.720
还有什么

33:11.720 --> 33:12.720
还有special

33:12.720 --> 33:13.720
还有special函数

33:13.720 --> 33:15.720
刚刚说special

33:15.720 --> 33:16.720
这个special

33:16.720 --> 33:17.720
它也有个scope

33:17.720 --> 33:18.720
是不是也要指回来

33:18.720 --> 33:19.720
对不对

33:19.720 --> 33:20.720
也要指回来

33:20.720 --> 33:21.720
总之在哪里创建的

33:21.720 --> 33:23.720
就指向哪个

33:23.720 --> 33:24.720
就是

33:24.720 --> 33:25.720
上下文的VO

33:25.720 --> 33:26.720
好

33:26.720 --> 33:27.720
那么special还指过去

33:27.720 --> 33:29.720
又指过去

33:29.720 --> 33:31.720
形成这么种结构

33:31.720 --> 33:32.720
没问题吧

33:32.720 --> 33:33.720
目前没问题吧

33:33.720 --> 33:35.720
形成这么种结构

33:35.720 --> 33:36.720
好

33:36.720 --> 33:37.720
接下来开始干嘛

33:37.720 --> 33:38.720
开始执行代码了

33:38.720 --> 33:39.720
先把f作为1

33:39.720 --> 33:40.720
已经写了

33:40.720 --> 33:41.720
把f作为1

33:41.720 --> 33:42.720
我就一起写了

33:42.720 --> 33:43.720
然后呢

33:43.720 --> 33:44.720
这里就相当于没写了

33:44.720 --> 33:45.720
对吧

33:45.720 --> 33:46.720
相当于没写了

33:46.720 --> 33:47.720
因为已经提出来了

33:47.720 --> 33:48.720
然后运行special

33:48.720 --> 33:50.720
是不是要建立上下文

33:50.720 --> 33:51.720
对吧

33:51.720 --> 33:52.720
运行special

33:52.720 --> 33:54.720
建立上下文

33:54.720 --> 33:56.720
运行special

33:56.720 --> 33:58.720
special的上下文

33:58.720 --> 33:59.720
好

33:59.720 --> 34:00.720
那么这里是VO

34:00.720 --> 34:01.720
对吧

34:01.720 --> 34:02.720
也叫做AO

34:02.720 --> 34:03.720
都行

34:03.720 --> 34:04.720
一个意思

34:04.720 --> 34:05.720
就不同的教法而已

34:05.720 --> 34:06.720
好

34:06.720 --> 34:07.720
然后呢

34:07.720 --> 34:08.720
有两个辩量

34:08.720 --> 34:09.720
A和B

34:09.720 --> 34:10.720
A和大写的B

34:10.720 --> 34:11.720
对吧

34:12.720 --> 34:13.720
有一个

34:14.720 --> 34:16.720
A和大写的B

34:16.720 --> 34:17.720
有一个A和大写的B

34:17.720 --> 34:18.720
A的值是多少

34:18.720 --> 34:19.720
我们就直接复职了

34:19.720 --> 34:20.720
A的值是5

34:21.720 --> 34:22.720
A的值是5

34:24.720 --> 34:25.720
那么这个B呢

34:25.720 --> 34:26.720
整个这个上下文呢

34:26.720 --> 34:27.720
它由于是雕用函数嘛

34:27.720 --> 34:29.720
所以说它会指向谁

34:29.720 --> 34:31.720
整个这个上下文会指向

34:32.720 --> 34:33.720
会指向这

34:33.720 --> 34:34.720
对吧

34:34.720 --> 34:35.720
没问题吧

34:35.720 --> 34:36.720
雕用special嘛

34:36.720 --> 34:37.720
它会指向这个函数

34:37.720 --> 34:38.720
好

34:38.720 --> 34:39.720
那么这里是它的上下文VO

34:39.720 --> 34:40.720
指过来

34:41.720 --> 34:42.720
好

34:42.720 --> 34:43.720
接下来雕用函

34:43.720 --> 34:44.720
就是函数B

34:44.720 --> 34:45.720
关键是看函数B

34:45.720 --> 34:46.720
函数B呢

34:46.720 --> 34:47.720
它运行到这就代码的时候

34:47.720 --> 34:48.720
会给它复职

34:48.720 --> 34:49.720
对不对

34:49.720 --> 34:50.720
它不是新建函数

34:50.720 --> 34:51.720
是把之前的函数D值复职给它

34:51.720 --> 34:53.720
那么把A的D值复职给B

34:53.720 --> 34:54.720
好

34:54.720 --> 34:55.720
我们来看一下

34:55.720 --> 34:57.720
这里怎么来得到辩量A

34:57.720 --> 34:58.720
这个A能不能得到

34:58.720 --> 34:59.720
好

34:59.720 --> 35:00.720
你看一下自己的上下文里边

35:00.720 --> 35:01.720
是没有这个A的

35:01.720 --> 35:02.720
对吧

35:02.720 --> 35:03.720
那么找呗

35:03.720 --> 35:04.720
从这个链上找

35:04.720 --> 35:05.720
看这个箭头呗

35:05.720 --> 35:06.720
从这个链上找呗

35:07.720 --> 35:08.720
那找到谁

35:08.720 --> 35:09.720
找到谁

35:09.720 --> 35:10.720
是不是找到A了

35:10.720 --> 35:11.720
对不对

35:11.720 --> 35:12.720
找到A了

35:12.720 --> 35:13.720
看一下这样过来

35:13.720 --> 35:14.720
是不是找到A了

35:14.720 --> 35:15.720
好

35:15.720 --> 35:16.720
找到A

35:16.720 --> 35:17.720
这个A的地址是啥

35:17.720 --> 35:18.720
这个A的地址是不是它

35:18.720 --> 35:19.720
对不对

35:19.720 --> 35:20.720
它的地址

35:20.720 --> 35:21.720
把它的地址复职给B

35:21.720 --> 35:22.720
于是B指向谁

35:22.720 --> 35:23.720
B指向谁了

35:23.720 --> 35:24.720
B是不是指向

35:24.720 --> 35:25.720
指向这个

35:25.720 --> 35:26.720
对不对

35:26.720 --> 35:28.720
B指向这个玩意了

35:28.720 --> 35:29.720
没问题吧

35:29.720 --> 35:30.720
当然我们可以用

35:30.720 --> 35:31.720
浅数的箭头

35:31.720 --> 35:33.720
B指向这个玩意了

35:33.720 --> 35:34.720
好

35:34.720 --> 35:35.720
接下来

35:35.720 --> 35:36.720
我们再来

35:36.720 --> 35:37.720
B指向

35:37.720 --> 35:38.720
然后再调用B

35:38.720 --> 35:39.720
好

35:39.720 --> 35:40.720
调用B

35:40.720 --> 35:41.720
好了

35:41.720 --> 35:42.720
接下来我们调用B

35:42.720 --> 35:43.720
看一下吧

35:43.720 --> 35:44.720
调用B

35:44.720 --> 35:46.720
寒数B的上下文

35:46.720 --> 35:47.720
也就是说

35:47.720 --> 35:48.720
其实调用B是调用谁

35:48.720 --> 35:49.720
是不是调用它

35:49.720 --> 35:50.720
对不对

35:50.720 --> 35:51.720
那无所谓

35:51.720 --> 35:52.720
调用B这个寒数上下文

35:52.720 --> 35:53.720
因为本质上都是一样的

35:53.720 --> 35:54.720
好

35:54.720 --> 35:55.720
那么它里边是不是也有VO

35:55.720 --> 35:56.720
对不对

35:56.720 --> 35:57.720
也有VO

35:57.720 --> 35:58.720
那么这里

35:58.720 --> 35:59.720
B指向的是啥

35:59.720 --> 36:00.720
B指向是不是它

36:00.720 --> 36:01.720
那么它是不是这个代码

36:01.720 --> 36:02.720
对不对

36:02.720 --> 36:03.720
那看这里边变量

36:03.720 --> 36:04.720
寒数都没有

36:04.720 --> 36:05.720
没有变量没有寒数

36:05.720 --> 36:06.720
啥都没有

36:07.720 --> 36:08.720
看着

36:08.720 --> 36:09.720
这里边是空的

36:09.720 --> 36:12.290
好

36:12.290 --> 36:13.290
这里边你看没

36:13.290 --> 36:14.290
是空的

36:14.290 --> 36:15.290
好

36:15.290 --> 36:16.290
那么同样的道理

36:16.290 --> 36:17.290
那么这个上下文是谁创建的

36:17.290 --> 36:18.290
谁创建的

36:18.290 --> 36:19.290
是不是这个寒数创建的

36:19.290 --> 36:20.290
对吧

36:20.290 --> 36:21.290
是不是要指向这个寒数

36:21.290 --> 36:22.290
没问题吧

36:22.290 --> 36:23.290
好

36:23.290 --> 36:24.290
那么来吧

36:24.290 --> 36:25.290
来吧

36:25.290 --> 36:26.290
你看一下这个过程

36:26.290 --> 36:27.290
先找里边的

36:27.290 --> 36:29.290
我们现在要输出啥

36:29.290 --> 36:30.290
输出A

36:30.290 --> 36:31.290
先找当前上下文里面

36:31.290 --> 36:32.290
有没有A

36:32.290 --> 36:33.290
有A吗

36:34.290 --> 36:35.290
有A吗

36:35.290 --> 36:36.290
是不是没有A

36:36.290 --> 36:37.290
没有A找谁

36:37.290 --> 36:39.290
是不是按照箭头来找

36:39.290 --> 36:40.290
箭头为什么指向这个

36:40.290 --> 36:41.290
因为它是

36:41.290 --> 36:43.290
这个上下文是有它创建的吗

36:43.290 --> 36:45.290
B就指向的是A

36:45.290 --> 36:46.290
对吧

36:46.290 --> 36:47.290
指向的是它

36:47.290 --> 36:48.290
要调用B是不是就要调用它

36:48.290 --> 36:49.290
对不对

36:49.290 --> 36:50.290
是由它来创建的

36:50.290 --> 36:51.290
所以它指向它

36:51.290 --> 36:53.290
那么按照箭头来找

36:53.290 --> 36:54.290
它里边没有箭头

36:54.290 --> 36:55.290
是不是指向这

36:55.290 --> 36:56.290
对不对

36:56.290 --> 36:57.290
指向这

36:57.290 --> 36:58.290
那么通过这个Sculpt

36:58.290 --> 36:59.290
是不是找到这

36:59.290 --> 37:00.290
找到全球汤阳纹了

37:00.290 --> 37:01.290
那这里得到了S

37:01.290 --> 37:03.290
得到了S1

37:03.290 --> 37:04.290
而不会找到这里的5

37:04.290 --> 37:05.290
你看怎么才能找到

37:05.290 --> 37:06.290
这里的5

37:06.290 --> 37:07.290
找不到的

37:07.290 --> 37:08.290
找不到这里的5的

37:09.290 --> 37:10.290
通俗来讲的话

37:10.290 --> 37:12.290
就是你这个边量

37:12.290 --> 37:15.290
它是在什么时候

37:15.290 --> 37:16.290
形成B包的

37:16.290 --> 37:18.290
就是在创建函数的时候

37:18.290 --> 37:19.290
形成B包的

37:19.290 --> 37:20.290
创建函数的时候

37:20.290 --> 37:21.290
它就把它这个

37:21.290 --> 37:22.290
当前的作用语里边的A

37:22.290 --> 37:23.290
就保留下来了

37:23.290 --> 37:25.290
而不是在运行函数的时候

37:25.290 --> 37:27.290
是在创建函数的时候

37:27.290 --> 37:28.290
就已经形成了

37:29.290 --> 37:30.290
把这个东西搞清楚

37:32.290 --> 37:34.290
另外最后我再说一个点

37:34.290 --> 37:35.290
其实就影响完了

37:35.290 --> 37:36.290
就没什么知识

37:37.290 --> 37:38.290
就影响完了

37:38.290 --> 37:39.290
最后说一个点

37:39.290 --> 37:43.290
就是关于某些浏览器

37:43.290 --> 37:44.290
某些浏览器

37:45.290 --> 37:46.290
会优化

37:47.290 --> 37:48.290
会优化作用语念

37:50.290 --> 37:52.290
它怎么来优化呢

37:52.290 --> 37:56.290
就是函数的Sculpt中

37:57.290 --> 37:59.290
Sculpt属性中

38:00.290 --> 38:01.290
中

38:02.290 --> 38:05.290
仅保留需要用到的数据

38:05.290 --> 38:07.290
它只保留需要用到的数据

38:07.290 --> 38:08.290
啥意思呢

38:08.290 --> 38:09.290
就比方说

38:09.290 --> 38:10.290
我们这个代码里边

38:11.290 --> 38:12.290
这个代码里边

38:12.290 --> 38:13.290
比方说这里没有用到A

38:14.290 --> 38:15.290
这里没有用到A

38:16.290 --> 38:18.290
比方说我们输出的是一个Hello

38:19.290 --> 38:20.290
没有用到A

38:20.290 --> 38:21.290
假設是这么种情况

38:21.290 --> 38:23.290
那么它发现这个函数A里边

38:23.290 --> 38:24.290
没有用到这个A

38:24.290 --> 38:25.290
于是

38:26.290 --> 38:27.290
它会认为

38:27.290 --> 38:29.290
你这个函数没有必要

38:29.290 --> 38:30.290
没有必要就是

38:30.290 --> 38:32.290
用到这个A对吧

38:32.290 --> 38:34.290
所以说它这个Sculpt里边

38:34.290 --> 38:37.290
这个方形ASculpt里边

38:37.290 --> 38:39.290
它就不再保留A了

38:39.290 --> 38:40.290
它会进行特殊处理

38:40.290 --> 38:41.290
这个了解下就行了

38:41.290 --> 38:42.290
它不会保留这个A

38:42.290 --> 38:44.290
它尽量函减属性

38:44.290 --> 38:45.290
尽量的函减属性

38:45.290 --> 38:47.290
是这么个意思

38:47.290 --> 38:49.290
它就不会再保留这个A了

38:49.290 --> 38:51.290
了解下就行了

38:51.290 --> 38:53.290
它为了就是解约内存空间

38:53.290 --> 38:54.290
当然这个东西

38:54.290 --> 38:55.290
我们不用关系

38:55.290 --> 38:56.290
跟我们做体没有任何关系

38:56.290 --> 38:57.290
对我们理解姿势

38:57.290 --> 38:58.290
跟我们理解姿势

38:58.290 --> 38:59.290
也没有任何关系

38:59.290 --> 39:00.290
了解一下就行了

39:01.290 --> 39:02.290
好 最后来面试题

39:02.290 --> 39:03.290
来 第一题

39:07.290 --> 39:08.290
看一下

39:08.290 --> 39:18.450
第一题 看速速啥

39:18.450 --> 39:19.450
把它删掉

39:19.450 --> 39:20.450
一会儿便于分析

39:21.450 --> 39:23.450
好 第一题

39:23.450 --> 39:25.450
来呗 我们先啥都不管

39:25.450 --> 39:28.450
直接来画图

39:28.450 --> 39:29.450
好 第一题

39:29.450 --> 39:31.450
有一个副

39:31.450 --> 39:32.450
它是个对象

39:32.450 --> 39:33.450
N等于1

39:33.450 --> 39:35.450
那么全句上下文里边

39:35.450 --> 39:37.450
就是有一个副

39:37.450 --> 39:39.450
我们就直接写到这了

39:39.450 --> 39:40.450
直接写到这了

39:41.450 --> 39:42.450
我们来看一下吧

39:42.450 --> 39:43.450
行 没问题

39:43.450 --> 39:44.450
就直接写到这

39:44.450 --> 39:45.450
N等于1

39:45.450 --> 39:46.450
N等于1

39:46.450 --> 39:49.020
这是副

39:50.020 --> 39:51.020
当然我们也可以画一个对象

39:51.020 --> 39:53.020
因为实际上不是这样子画的

39:53.020 --> 39:55.020
实际上不是这样子画的

39:55.020 --> 39:56.020
我们还是画出来吧

39:56.020 --> 39:57.020
还是画出来吧

39:57.020 --> 39:58.020
这个副呢

39:58.020 --> 39:59.020
它肯定是个对象

39:59.020 --> 40:00.020
对象肯定是一个

40:00.020 --> 40:02.020
它里边存的肯定是个地址

40:02.020 --> 40:03.020
肯定是个地址

40:03.020 --> 40:04.020
副

40:04.020 --> 40:06.020
那么这个是X

40:06.020 --> 40:08.020
等于多少呢

40:08.020 --> 40:10.020
N等于1

40:10.020 --> 40:12.020
有个属性N等于1

40:12.020 --> 40:14.020
有这么一个对象

40:14.020 --> 40:15.020
好 那么

40:15.020 --> 40:16.020
这个对象的地址

40:16.020 --> 40:18.020
它肯定是指向这

40:18.020 --> 40:21.520
它里边存的是个地址

40:21.520 --> 40:22.520
这是副

40:22.520 --> 40:23.520
然后呢

40:23.520 --> 40:25.520
这里写了一个寒朔表达式

40:25.520 --> 40:26.520
全句上下文里边

40:26.520 --> 40:27.520
只有一个边量

40:27.520 --> 40:28.520
它没有这个寒朔

40:28.520 --> 40:29.520
它是个表达式

40:29.520 --> 40:31.520
它不是一个字面量寒朔

40:31.520 --> 40:32.520
好 因为这么一个寒朔

40:32.520 --> 40:33.520
对吧 是不是在创建寒朔

40:33.520 --> 40:35.520
是不是在创建寒朔这一块

40:35.520 --> 40:36.520
那肯定是吗

40:36.520 --> 40:37.520
肯定是在创建寒朔吗

40:37.520 --> 40:39.520
那得了 来呗

40:39.520 --> 40:41.520
只要在创建寒朔

40:41.520 --> 40:43.520
就会有一个啥

40:43.520 --> 40:45.520
就会有一个

40:45.520 --> 40:47.520
scope出来

40:47.520 --> 40:48.520
方可行

40:48.520 --> 40:49.520
匿名寒朔

40:49.520 --> 40:50.520
这是没有名字的

40:50.520 --> 40:51.520
它有一个参数

40:51.520 --> 40:52.520
有一个参数 副

40:52.520 --> 40:53.520
好 然后呢

40:53.520 --> 40:54.520
这里

40:54.520 --> 40:56.520
什么呢 就是

40:56.520 --> 40:58.520
一个scope

40:59.520 --> 41:01.520
scope 指向谁

41:01.520 --> 41:02.520
scope 指向谁

41:02.520 --> 41:04.520
是不是当前的

41:04.520 --> 41:06.520
当前的l 对不对

41:06.520 --> 41:08.520
也就是这个全句上下文的

41:08.520 --> 41:09.520
g o

41:09.520 --> 41:10.520
对吧 指向这

41:10.520 --> 41:11.520
对不对

41:11.520 --> 41:13.520
它上下文里边就没有这个

41:13.520 --> 41:14.520
匿名寒朔了

41:14.520 --> 41:15.520
它里面不保存匿名寒朔了

41:15.520 --> 41:17.520
它只保存字面量寒朔

41:17.520 --> 41:18.520
这也解释了

41:18.520 --> 41:20.520
为什么寒朔的这个字面量

41:20.520 --> 41:21.520
它不会保存

41:21.520 --> 41:23.520
它不会保留下来

41:23.520 --> 41:24.520
就是这样立即执行寒朔

41:24.520 --> 41:25.520
它不会污染全句边量

41:25.520 --> 41:26.520
就是这个原因

41:26.520 --> 41:27.520
它里面不保存

41:27.520 --> 41:28.520
不保存的

41:28.520 --> 41:29.520
因为它是表达式

41:29.520 --> 41:31.520
它没有把它复制到边量里面

41:31.520 --> 41:35.520
所以说它没有污染任何全句边量

41:35.520 --> 41:37.520
形成这么一种结构了

41:37.520 --> 41:38.520
没问题吧

41:38.520 --> 41:39.520
接下来

41:39.520 --> 41:41.520
立即把这个寒朔执行一下

41:41.520 --> 41:42.520
执行一下这个寒朔

41:42.520 --> 41:44.520
给它传了一个参数进去

41:44.520 --> 41:46.520
来吧

41:46.520 --> 41:47.520
执行这个寒朔

41:47.520 --> 41:49.520
这是匿名寒朔的执行

41:49.520 --> 41:51.520
匿名寒朔执行

41:51.520 --> 41:52.520
管它什么寒朔

41:52.520 --> 41:53.520
只要你在执行寒朔

41:53.520 --> 41:54.520
它一定要创建v o

41:54.520 --> 41:55.520
这里画a o嘛

41:55.520 --> 41:57.520
都是一个意思

41:57.520 --> 41:58.520
这里呢

41:58.520 --> 42:00.520
我们是不是要创建a o

42:00.520 --> 42:01.520
对不对

42:01.520 --> 42:02.520
要创建a o

42:02.520 --> 42:05.520
肯定要创建吧

42:05.520 --> 42:06.520
创建a o

42:06.520 --> 42:07.520
那么这个地方

42:07.520 --> 42:08.520
是不是一定的

42:08.520 --> 42:09.520
它会指回来

42:09.520 --> 42:10.520
对不对

42:10.520 --> 42:11.520
因为它会指向

42:11.520 --> 42:12.520
创建它的寒朔

42:12.520 --> 42:13.520
它会指回来

42:13.520 --> 42:14.520
好

42:14.520 --> 42:15.520
那么我们来看一下

42:15.520 --> 42:17.520
这个a o里面有哪些东西

42:17.520 --> 42:18.520
哪些东西有参数

42:18.520 --> 42:19.520
对不对

42:19.520 --> 42:20.520
是不是有参数

42:20.520 --> 42:21.520
参数负

42:21.520 --> 42:22.520
对吧

42:22.520 --> 42:23.520
先确定参数值

42:23.520 --> 42:24.520
参数负的值

42:24.520 --> 42:25.520
为啥呢

42:25.520 --> 42:26.520
是不是传递过来的

42:26.520 --> 42:27.520
你看这里全句

42:27.520 --> 42:28.520
这里传递过来的

42:28.520 --> 42:29.520
传递过来的

42:29.520 --> 42:30.520
这个变量

42:30.520 --> 42:32.520
把这个变量的地址传递过来

42:32.520 --> 42:33.520
就相当于是把

42:33.520 --> 42:34.520
全句这里的负

42:34.520 --> 42:35.520
传递给这个参数

42:35.520 --> 42:36.520
看到没

42:36.520 --> 42:37.520
传递给这个参数

42:37.520 --> 42:38.520
名字一样而已嘛

42:38.520 --> 42:39.520
那么它是不是

42:39.520 --> 42:41.520
也指向内存

42:41.520 --> 42:42.520
也指向它了

42:42.520 --> 42:43.520
对不对

42:43.520 --> 42:44.520
指向同一块内存空间

42:44.520 --> 42:45.520
指向这了

42:45.520 --> 42:46.520
好 接着来

42:46.520 --> 42:47.520
然后呢

42:47.520 --> 42:48.520
输出啥呢

42:48.520 --> 42:49.520
输出负点

42:49.520 --> 42:50.520
这个输出啥

42:50.520 --> 42:51.520
这个输出肯定是一嘛

42:51.520 --> 42:52.520
对不对

42:52.520 --> 42:53.520
输出啥

42:53.520 --> 42:54.520
看一下这里边

42:54.520 --> 42:55.520
还有什么东西

42:55.520 --> 42:56.520
还有个变量

42:56.520 --> 42:57.520
这里还有个变量

42:57.520 --> 42:58.520
不着急

42:58.520 --> 42:59.520
变量负

42:59.520 --> 43:00.520
变量负跟参数名字

43:00.520 --> 43:01.520
是不是重复了

43:01.520 --> 43:02.520
怎么办

43:02.520 --> 43:03.520
怎么办

43:03.520 --> 43:04.520
变量名字跟参数名字

43:04.520 --> 43:05.520
重复

43:05.520 --> 43:06.520
这不动

43:06.520 --> 43:07.520
对不对

43:07.520 --> 43:08.520
不动

43:08.520 --> 43:09.520
不会把这里

43:09.520 --> 43:10.520
复辞成亡敌范的

43:10.520 --> 43:11.520
不动

43:11.520 --> 43:12.520
就完事了

43:12.520 --> 43:13.520
那就没其他东西了

43:13.520 --> 43:14.520
咱们输出

43:14.520 --> 43:15.520
这里是不是输出1

43:15.520 --> 43:16.520
对吧

43:16.520 --> 43:17.520
通过这个负

43:17.520 --> 43:18.520
得到啥

43:18.520 --> 43:19.520
得到这个n

43:19.520 --> 43:20.520
对吧

43:20.520 --> 43:21.520
是不是输出1

43:21.520 --> 43:22.520
没问题吧

43:22.520 --> 43:23.520
应该没问题吧

43:24.520 --> 43:25.520
因为负

43:25.520 --> 43:26.520
它里面有嘛

43:26.520 --> 43:27.520
有这个负

43:27.520 --> 43:29.520
又把负点n负之为3

43:29.520 --> 43:31.520
那么是不是找负

43:31.520 --> 43:32.520
当前他在文里面说

43:32.520 --> 43:33.520
已经有负了

43:33.520 --> 43:34.520
把n负之为3

43:34.520 --> 43:35.520
对吧

43:35.520 --> 43:36.520
负之为3

43:36.520 --> 43:37.520
接下来继续找

43:37.520 --> 43:38.520
然后又把负负之为

43:38.520 --> 43:39.520
一个新的对象

43:39.520 --> 43:41.520
n等于2

43:41.520 --> 43:43.520
一个新的对象产生了

43:43.520 --> 43:45.520
n等于2

43:45.520 --> 43:46.520
这个对象

43:46.520 --> 43:47.520
它又指向这个

43:47.520 --> 43:48.520
它指向这个

43:48.520 --> 43:50.520
它是这样子指向的

43:50.520 --> 43:52.520
又指向新的对象了

43:52.520 --> 43:53.520
跟之前有啥关系

43:53.520 --> 43:54.520
没啥关系

43:54.520 --> 43:55.520
对吧

43:55.520 --> 43:57.520
把它负负

43:57.520 --> 43:58.520
这个新的对象

43:58.520 --> 43:59.520
然后再输出负点

43:59.520 --> 44:00.520
就是负点n

44:00.520 --> 44:02.520
那是不是输出了2

44:02.520 --> 44:03.520
那么这个函数

44:03.520 --> 44:04.520
是不是结束了

44:04.520 --> 44:05.520
执行结束

44:05.520 --> 44:06.520
函数执行结束

44:06.520 --> 44:07.520
那么这里

44:07.520 --> 44:08.520
这里还没有用到

44:08.520 --> 44:09.520
作用语练

44:09.520 --> 44:10.520
但是

44:10.520 --> 44:12.520
它为了让你明白

44:12.520 --> 44:13.520
其实这个题

44:13.520 --> 44:14.520
它间接的考它的

44:14.520 --> 44:15.520
作用语练

44:15.520 --> 44:16.520
就看你能不能

44:16.520 --> 44:17.520
体会得到

44:17.520 --> 44:18.520
它不会往上找了

44:18.520 --> 44:19.520
因为它自己有

44:19.520 --> 44:20.520
它就不会往上找了

44:20.520 --> 44:21.520
那么现在

44:21.520 --> 44:23.520
这个执行结束了

44:23.520 --> 44:24.520
执行结束了

44:24.520 --> 44:25.520
没了

44:25.520 --> 44:26.520
没了

44:26.520 --> 44:27.520
这个对象也没了

44:27.520 --> 44:28.520
找不到这个对象了

44:28.520 --> 44:30.520
到这个地方了

44:30.520 --> 44:31.520
也没了

44:31.520 --> 44:32.520
跟匿名还说是不是也没了

44:32.520 --> 44:33.520
找不到了

44:33.520 --> 44:34.520
找不到它了

44:34.520 --> 44:35.520
没了

44:35.520 --> 44:36.520
又变成这样子了

44:36.520 --> 44:37.520
那么现在

44:37.520 --> 44:38.520
输出什么

44:38.520 --> 44:39.520
所以说匿名对象

44:39.520 --> 44:40.520
它不会污染全局边量的

44:40.520 --> 44:41.520
就是一个原因

44:41.520 --> 44:42.520
这里输出啥

44:42.520 --> 44:43.520
负点n

44:43.520 --> 44:44.520
输出啥

44:44.520 --> 44:45.520
输出3

44:45.520 --> 44:47.520
输出的结果是1 2 3

44:47.520 --> 44:50.340
看一下吧

44:50.340 --> 44:51.340
1 2 3

44:51.340 --> 44:52.340
好 这是第一题

44:52.340 --> 44:56.100
第二题

44:56.100 --> 44:57.100
类似

44:57.100 --> 44:58.100
都差不多

44:58.100 --> 45:00.100
你只要搞清楚了过后

45:00.100 --> 45:01.100
你就明白了

45:01.100 --> 45:03.100
第二题

45:03.100 --> 45:04.100
好 第二题

45:04.100 --> 45:05.100
又来吧

45:05.100 --> 45:06.100
这里怎么用这个呢

45:06.100 --> 45:07.100
用挖

45:07.100 --> 45:08.100
用挖

45:08.100 --> 45:09.100
我看一下上一道题

45:09.100 --> 45:10.100
有没有用挖

45:10.100 --> 45:11.100
因为这个关键字

45:11.100 --> 45:13.100
你们还没有学习过

45:13.100 --> 45:14.100
所以用挖

45:14.100 --> 45:15.100
好 下面我们要改一下

45:15.100 --> 45:16.100
改一下

45:16.100 --> 45:18.860
OK

45:18.860 --> 45:19.860
看第二题

45:20.860 --> 45:21.860
第二题

45:21.860 --> 45:22.860
我们还是要画图

45:22.860 --> 45:23.860
还是要画图

45:23.860 --> 45:24.860
这样子要画吧

45:24.860 --> 45:28.750
这样子要画

45:28.750 --> 45:29.750
还是在这里画

45:29.750 --> 45:30.750
这里画

45:30.750 --> 45:32.750
看得更加清楚一点

45:32.750 --> 45:33.750
负的

45:33.750 --> 45:35.750
就是一开始全局环境

45:35.750 --> 45:36.750
全局环境里边有啥

45:36.750 --> 45:37.750
有几个东西

45:37.750 --> 45:39.750
有几个变量

45:39.750 --> 45:40.750
两个变量对吧

45:40.750 --> 45:41.750
负的

45:41.750 --> 45:42.750
eat

45:42.750 --> 45:43.750
负的

45:43.750 --> 45:44.750
eat

45:44.750 --> 45:45.750
eat成了是undefined的

45:45.750 --> 45:46.750
都是undefined的

45:46.750 --> 45:47.750
都是undefined的

45:47.750 --> 45:48.750
undefined的

45:48.750 --> 45:50.750
都是undefined的

45:50.750 --> 45:51.750
对象没了

45:51.750 --> 45:52.750
好 接下来

45:52.750 --> 45:53.750
负的是什么

45:53.750 --> 45:54.750
Rice对吧

45:54.750 --> 45:56.750
Rice大米

45:56.750 --> 45:57.750
好 eat成了是啥

45:57.750 --> 45:58.750
eat成了是啥

45:58.750 --> 45:59.750
给它负责

45:59.750 --> 46:00.750
负责为一个函数

46:00.750 --> 46:02.750
好 是不是有新的函数创建了

46:02.750 --> 46:04.750
一个新的函数出来了

46:04.750 --> 46:07.190
函数

46:08.190 --> 46:10.190
这是函数啊 这是

46:11.190 --> 46:12.190
就表示eat成函数嘛

46:12.190 --> 46:14.190
就表示eat成函数

46:14.190 --> 46:15.190
函数

46:15.190 --> 46:17.190
好 那么这里边是不是有个scope

46:17.190 --> 46:18.190
对不对

46:18.190 --> 46:20.190
那个scope是不是指向指回来

46:20.190 --> 46:21.190
指回来

46:21.190 --> 46:23.190
scope指回来

46:23.190 --> 46:24.190
OK

46:24.190 --> 46:25.190
好 接下来

46:25.190 --> 46:26.190
然后这边eat成了

46:26.190 --> 46:27.190
它指向这个函数

46:27.190 --> 46:28.190
eat指向这个函数

46:28.190 --> 46:29.190
eat指向这个函数

46:31.570 --> 46:32.570
eat指向这个函数

46:32.570 --> 46:33.570
好了 讲好了

46:33.570 --> 46:34.570
差不多了

46:35.570 --> 46:36.570
这里是支不错Rice

46:37.570 --> 46:38.570
这里我打不出来

46:38.570 --> 46:40.570
这个支不错Rice

46:40.570 --> 46:41.570
就这样吧

46:42.570 --> 46:43.570
好 接下来

46:44.570 --> 46:46.570
然后呢 又来一个函数了对吧

46:46.570 --> 46:48.570
又来一个新的函数

46:48.570 --> 46:49.570
又来一个新的函数

46:49.570 --> 46:50.570
虽然是个利民函数

46:50.570 --> 46:51.570
但是肯定创建了一个函数了

46:51.570 --> 46:53.570
这是个利民函数

46:55.570 --> 46:56.570
利民函数

46:56.570 --> 46:57.570
这个利民函数scope

46:57.570 --> 46:58.570
是不是也是指向它

46:58.570 --> 46:59.570
对吧

46:59.570 --> 47:00.570
也是指向它

47:02.940 --> 47:03.940
好 这样子

47:03.940 --> 47:04.940
形成这样的一个结构

47:04.940 --> 47:05.940
好 接下来干嘛呢

47:05.940 --> 47:07.940
马上执行这个利民函数

47:07.940 --> 47:09.940
是不是创建新的上下文

47:09.940 --> 47:10.940
对吧 新的上下文

47:10.940 --> 47:12.940
就是利民函数的上下文

47:12.940 --> 47:15.960
VO

47:15.960 --> 47:17.960
好 这里上下文出来了

47:17.960 --> 47:18.960
这个上下文里边有哪些东西呢

47:18.960 --> 47:20.960
看一下这个利民函数里边有哪些东西

47:20.960 --> 47:22.960
当然这个东西肯定要指回来

47:22.960 --> 47:23.960
肯定要指回来了

47:23.960 --> 47:27.170
指回来

47:27.170 --> 47:29.170
好 然后这边指过来

47:31.800 --> 47:33.800
看一下这个利民函数里边有哪些东西

47:33.800 --> 47:34.800
有变量吗

47:34.800 --> 47:35.800
有一个变量

47:35.800 --> 47:36.800
有一个变量负的

47:36.800 --> 47:37.800
有一个变量负的

47:37.800 --> 47:39.800
最后会把它负之为啥呢

47:39.800 --> 47:41.800
把它负之为

47:41.800 --> 47:42.800
noodle

47:42.800 --> 47:45.370
面条

47:45.370 --> 47:46.370
noodle

47:46.370 --> 47:47.370
好了 还有啥呢

47:47.370 --> 47:48.370
还有啥

47:48.370 --> 47:49.370
没了 对吧

47:49.370 --> 47:50.370
没了

47:50.370 --> 47:52.370
好 接下来呢

47:52.370 --> 47:54.370
在这个利民函数里边

47:54.370 --> 47:56.370
他做了这么一件事

47:56.370 --> 47:58.370
调用意识

47:58.370 --> 47:59.370
在这里调用意识

47:59.370 --> 48:01.370
他在考虑啥呢

48:01.370 --> 48:03.370
就是我们之前讲的这道题

48:03.370 --> 48:04.370
考虑的是啥

48:04.370 --> 48:07.370
考虑的就是看你这个作用意念的知识

48:07.370 --> 48:08.370
相关知识

48:08.370 --> 48:09.370
你看一下

48:09.370 --> 48:10.370
调用函数

48:10.370 --> 48:12.370
我们说之前还说过

48:12.370 --> 48:14.370
作用意念里面必包

48:14.370 --> 48:16.370
就是它保存的保留到现场

48:16.370 --> 48:17.370
保留到什么现场呢

48:17.370 --> 48:19.370
是创建函数的时候现场

48:19.370 --> 48:20.370
跟执行的时候无关

48:20.370 --> 48:22.370
好 这个时候是执行意识

48:22.370 --> 48:23.370
你看一下

48:23.370 --> 48:24.370
首先来找意识

48:24.370 --> 48:25.370
看能不能找到意识

48:25.370 --> 48:26.370
能不能找到了

48:26.370 --> 48:27.370
它自己的上向文里面没有

48:27.370 --> 48:28.370
对吧

48:28.370 --> 48:29.370
从链条里面找

48:29.370 --> 48:30.370
你看这里是不是有意识

48:30.370 --> 48:31.370
对吧 找到这个函数了

48:31.370 --> 48:33.370
好 执行这个意识函数

48:34.370 --> 48:35.370
意识函数

48:35.370 --> 48:37.370
这个意识函数里面

48:37.370 --> 48:39.370
看一下这个意识函数里面有啥

48:39.370 --> 48:41.370
没啥就是输出一个负的 对吧

48:41.370 --> 48:43.370
它里面有啥东西都没有

48:43.370 --> 48:44.370
空的

48:44.370 --> 48:45.370
空的

48:45.370 --> 48:46.370
一个空的上向文

48:46.370 --> 48:47.370
里面啥东西都没有

48:47.370 --> 48:49.370
这个尖头还是该连过去

48:49.370 --> 48:50.370
还是该连过去

48:50.370 --> 48:52.370
当然这个东西肯定要指回来

48:52.370 --> 48:53.370
对不对

48:53.370 --> 48:54.370
肯定要指回来

48:54.370 --> 48:55.370
谁在

48:55.370 --> 48:56.370
它调用哪个函数

48:56.370 --> 48:57.370
它就指向哪个函数

48:57.370 --> 48:58.370
调用了这个函数

48:58.370 --> 48:59.370
它就指向这个函数

48:59.370 --> 49:01.370
好 那么现在找执行意识

49:01.370 --> 49:03.370
执行意识这个函数

49:03.370 --> 49:05.370
好 那么这个函数里面输出啥

49:05.370 --> 49:07.370
输出的是负的

49:07.370 --> 49:08.370
它自己有负的吗

49:08.370 --> 49:09.370
没有

49:09.370 --> 49:10.370
看箭头

49:10.370 --> 49:11.370
往这边过来

49:11.370 --> 49:12.370
是不是找到这个负的

49:12.370 --> 49:13.370
对吧

49:13.370 --> 49:14.370
能找到这个负的吗

49:14.370 --> 49:15.370
不能

49:15.370 --> 49:16.370
找到是这个负的

49:16.370 --> 49:17.370
Rise

49:17.370 --> 49:18.370
输出的是Rise

49:18.370 --> 49:19.370
它就考虑这个

49:19.370 --> 49:20.370
其实你也不用

49:20.370 --> 49:21.370
就是太过于纠结

49:21.370 --> 49:22.370
是不是每一次要画这么多图呢

49:22.370 --> 49:23.370
我告诉你一个关键点

49:23.370 --> 49:24.370
你就看函数

49:24.370 --> 49:25.370
什么时候定义的

49:25.370 --> 49:26.370
你看这个

49:26.370 --> 49:27.370
肯定要输出

49:27.370 --> 49:28.370
对吧 肯定要输出

49:28.370 --> 49:29.370
关键是看输出的是

49:29.370 --> 49:30.370
Noodle还是Rise

49:30.370 --> 49:31.370
那么你就看这个函数

49:31.370 --> 49:32.370
不要看它运行

49:32.370 --> 49:34.370
看它什么时候定义的

49:34.370 --> 49:35.370
定义的时候

49:35.370 --> 49:36.370
那个负的是谁

49:36.370 --> 49:37.370
就是谁

49:37.370 --> 49:38.370
就是谁

49:38.370 --> 49:39.370
输出的就是用的

49:39.370 --> 49:40.370
就是哪个负的

49:40.370 --> 49:41.370
就是这么个意思

49:41.370 --> 49:42.370
所以说你这里

49:42.370 --> 49:43.370
把负字粘贴过来

49:43.370 --> 49:44.370
看一下

49:44.370 --> 49:45.370
肯定是Rise

49:47.370 --> 49:48.370
好 这倒题

49:48.370 --> 49:49.370
好像倒题

49:50.370 --> 49:51.370
现在我们又来吧

49:51.370 --> 49:52.370
我现在不画了

49:52.370 --> 49:53.370
不画了

49:53.370 --> 49:54.370
能知道结果吗

49:54.370 --> 49:55.370
我这都写出来了

49:55.370 --> 49:56.370
对吧

49:56.370 --> 49:57.370
我的天啊

49:57.370 --> 49:59.370
我这里都写出来了

49:59.370 --> 50:00.370
那这里是不是Noodle

50:00.370 --> 50:01.370
对不对

50:01.370 --> 50:02.370
其实你要判断的是

50:02.370 --> 50:03.370
输出的是啥

50:03.370 --> 50:05.370
一定是函数定义的时候

50:05.370 --> 50:06.370
这个东西哪来的

50:06.370 --> 50:07.370
乃至于这 对吧

50:07.370 --> 50:09.370
所以说跟外面的没啥关系

50:09.370 --> 50:10.370
输出的是Noodle

50:10.370 --> 50:12.370
好 然后第四题

50:12.370 --> 50:17.380
好 第四题

50:17.380 --> 50:19.380
好 第四题怎么来理解呢

50:19.380 --> 50:20.380
第四题

50:20.380 --> 50:22.380
第四题就是我们之前说的

50:22.380 --> 50:23.380
这个就是

50:23.380 --> 50:25.380
这里会出现的问题

50:26.380 --> 50:27.380
第四题是一道面试题

50:27.380 --> 50:28.380
它面试你

50:28.380 --> 50:30.380
它问你输出啥结果

50:30.380 --> 50:31.380
那么如果我要得

50:31.380 --> 50:33.380
希望得到正常的结果的话

50:33.380 --> 50:35.380
我应该怎么来做

50:35.380 --> 50:37.380
好 看下来这道题

50:37.380 --> 50:38.380
这道题是面试的时候

50:38.380 --> 50:40.380
非常容易考到的

50:40.380 --> 50:42.380
循环十次

50:42.380 --> 50:44.380
每循环一次

50:44.380 --> 50:46.380
每循环一次

50:46.380 --> 50:48.380
然后呢

50:48.380 --> 50:49.380
set time out

50:49.380 --> 50:50.380
設置一个计时器

50:50.380 --> 50:52.380
一秒钟之后输出

50:52.380 --> 50:54.380
看一下吧

50:54.380 --> 50:58.200
看一下这道题

50:59.200 --> 51:01.200
好 接下来我来演示一下

51:01.200 --> 51:04.200
这道题它用两种考法

51:04.200 --> 51:07.200
第一种考法是这种考法

51:07.200 --> 51:10.200
这里两种考法都说一下吧

51:10.200 --> 51:11.200
都说一下

51:11.200 --> 51:12.200
先把这个注释掉

51:12.200 --> 51:14.200
先看这个

51:14.200 --> 51:17.200
先看 直接看这个

51:17.200 --> 51:19.200
好 怎么来理解呢

51:19.200 --> 51:21.200
这里还有一个碗

51:21.200 --> 51:22.200
还有一个碗

51:22.200 --> 51:23.200
首先是拳

51:23.200 --> 51:27.660
首先是拳举上下文

51:27.660 --> 51:29.660
再画一个

51:29.660 --> 51:31.660
好 这里

51:31.660 --> 51:33.660
删除掉

51:33.660 --> 51:35.660
好 拳举上下文里边有哪些东西

51:35.660 --> 51:36.660
有没有定义函数

51:36.660 --> 51:37.660
没有

51:37.660 --> 51:38.660
有没有定义变量

51:38.660 --> 51:39.660
有 有一个变量

51:39.660 --> 51:40.660
i

51:40.660 --> 51:41.660
对吧 有一个变量

51:41.660 --> 51:42.660
i

51:42.660 --> 51:43.660
所以说拳举上下文里边

51:43.660 --> 51:44.660
有是不是有一个变量i

51:44.660 --> 51:46.660
没问题吧

51:46.660 --> 51:47.660
有个变量i

51:47.660 --> 51:49.660
i的值是多少呢

51:49.660 --> 51:50.660
一开始是ond犯

51:50.660 --> 51:51.660
但是马上把负责为零了

51:51.660 --> 51:53.660
对吧

51:53.660 --> 51:55.660
这是拳举

51:55.660 --> 51:56.660
好 接下来开始运行了

51:56.660 --> 51:57.660
对吧 开始运行了

51:57.660 --> 51:58.660
你看这里没别的东西了

51:58.660 --> 51:59.660
没别的东西了

51:59.660 --> 52:00.660
开始运行

52:00.660 --> 52:01.660
一开始i等于零

52:01.660 --> 52:02.660
对吧

52:02.660 --> 52:03.660
然后运行这个函数

52:03.660 --> 52:04.660
是不是在调用函数

52:04.660 --> 52:05.660
对不对

52:05.660 --> 52:06.660
调用函数

52:06.660 --> 52:07.660
什么函数

52:07.660 --> 52:09.660
就是set time out

52:09.660 --> 52:10.660
调用函数

52:10.660 --> 52:12.660
函数里面是不是有vo

52:12.660 --> 52:13.660
对不对

52:13.660 --> 52:14.660
当然函数里面

52:14.660 --> 52:15.660
它写的啥东西

52:15.660 --> 52:16.660
我们并不知道

52:16.660 --> 52:17.660
我假设它里面没东西吧

52:17.660 --> 52:18.660
表示它里面没东西

52:18.660 --> 52:20.660
但是它vo里面是不是有参数

52:20.660 --> 52:21.660
它参数肯定有

52:21.660 --> 52:22.660
对不对

52:22.660 --> 52:23.660
参数是一个函数

52:23.660 --> 52:24.660
一个时间

52:24.660 --> 52:25.660
参数是一个函数

52:25.660 --> 52:26.660
一个时间

52:26.660 --> 52:27.660
那么参数呢

52:27.660 --> 52:29.660
我们把funk

52:29.660 --> 52:30.660
它是一个函数

52:30.660 --> 52:31.660
然后还有一个什么

52:31.660 --> 52:32.660
时间

52:32.660 --> 52:33.660
对不对

52:33.660 --> 52:34.660
时间

52:34.660 --> 52:35.660
时间是多少

52:35.660 --> 52:36.660
一秒钟

52:36.660 --> 52:37.660
duration

52:37.660 --> 52:39.660
一秒钟

52:39.660 --> 52:40.660
一千毫秒

52:40.660 --> 52:41.660
这个不是重点

52:41.660 --> 52:42.660
我们要看这个函数

52:42.660 --> 52:43.660
那这里面

52:43.660 --> 52:45.660
你是不是创建了一个函数

52:45.660 --> 52:46.660
这个函数在哪里创建的

52:46.660 --> 52:48.660
是不是全局环境里面创建的

52:48.660 --> 52:50.660
你不能认为在函数里面创建的

52:50.660 --> 52:53.660
函数里面的创建是这种写法

52:53.660 --> 52:56.660
这种写法在函数里面创建的函数

52:56.660 --> 52:58.660
你这里呢

52:58.660 --> 52:59.660
是把它作为参数

52:59.660 --> 53:01.660
传到这个函数里面去

53:01.660 --> 53:02.660
所以说这个函数

53:02.660 --> 53:03.660
是在外面创建的

53:03.660 --> 53:05.660
是在全局环境里面创建的

53:05.660 --> 53:07.660
于是这里有个函数

53:07.660 --> 53:09.660
多了一个函数

53:09.660 --> 53:10.660
这个函数是它

53:10.660 --> 53:12.660
这个函数是

53:12.660 --> 53:14.660
就是匿名函数

53:14.660 --> 53:16.660
匿名函数1

53:16.660 --> 53:17.660
表示第一次循环

53:17.660 --> 53:18.660
创建的函数

53:18.660 --> 53:20.660
它创建的一个函数

53:20.660 --> 53:21.660
没问题吧

53:21.660 --> 53:22.660
这是表拉式

53:22.660 --> 53:23.660
创建一个函数

53:23.660 --> 53:24.660
然后这个函数里面

53:24.660 --> 53:26.660
是有scope

53:26.660 --> 53:27.660
scope

53:27.660 --> 53:28.660
那么这个scope记录的是

53:28.660 --> 53:30.660
记录的是不是这个东西

53:30.660 --> 53:31.660
对不对

53:31.660 --> 53:33.660
它记录的是这个东西

53:33.660 --> 53:34.660
看没

53:34.660 --> 53:36.660
它记录的是这个东西

53:36.660 --> 53:37.660
没问题吧

53:37.660 --> 53:39.660
那么这个方可指向啥

53:39.660 --> 53:40.660
方可指向啥

53:40.660 --> 53:42.660
方可指向的是

53:42.660 --> 53:44.660
指向的是这一块

53:44.660 --> 53:45.660
是这个函数

53:45.660 --> 53:46.660
对吧

53:46.660 --> 53:47.660
然后这是VO

53:47.660 --> 53:49.660
这是VO

53:49.660 --> 53:50.660
没问题吧

53:50.660 --> 53:51.660
我们主要是看这个函数的

53:51.660 --> 53:52.660
scope指向谁

53:52.660 --> 53:54.660
主要是看这个

53:54.660 --> 53:55.660
那么第一次循环

53:55.660 --> 53:56.660
是不是结束了

53:56.660 --> 53:57.660
这个函数马上就交完了

53:57.660 --> 53:59.660
它不是要等

53:59.660 --> 54:00.660
不是要运行疫苗

54:00.660 --> 54:01.660
它不是要运行疫苗

54:01.660 --> 54:02.660
它瞬间就完成了

54:02.660 --> 54:04.660
瞬间就完成了

54:04.660 --> 54:05.660
只是等到疫苗之后

54:05.660 --> 54:06.660
再雕用这个函数

54:06.660 --> 54:08.660
只是等到疫苗之后

54:08.660 --> 54:09.660
雕用这个函数

54:09.660 --> 54:10.660
是这么个意思

54:10.660 --> 54:11.660
好

54:11.660 --> 54:12.660
那么这是函数交易

54:12.660 --> 54:13.660
马上就完了

54:13.660 --> 54:14.660
马上就完了

54:14.660 --> 54:15.660
结束了

54:15.660 --> 54:16.660
有些人说

54:16.660 --> 54:17.660
这个函数不消失吗

54:17.660 --> 54:18.660
它没有指向了

54:18.660 --> 54:19.660
没有任何东西指向它

54:19.660 --> 54:20.660
它不消失吗

54:20.660 --> 54:21.660
它不消失

54:21.660 --> 54:22.660
有东西指向它

54:22.660 --> 54:23.660
有东西

54:23.660 --> 54:24.660
但是什么东西呢

54:24.660 --> 54:25.660
是这个scope

54:25.660 --> 54:26.660
它们函数函数

54:26.660 --> 54:27.660
里边有东西指向它

54:27.660 --> 54:28.660
它里边咋写的

54:28.660 --> 54:29.660
就不知道

54:29.660 --> 54:30.660
所以它不会消失的

54:30.660 --> 54:31.660
它等一秒钟

54:31.660 --> 54:32.660
一秒钟之后

54:32.660 --> 54:33.660
开始运行这个函数

54:33.660 --> 54:34.660
是这么个意思

54:35.660 --> 54:36.660
那么现在还到了一秒吗

54:36.660 --> 54:37.660
还早得很

54:37.660 --> 54:39.660
现在可能也一毫秒都不到

54:39.660 --> 54:40.660
还要不要说一秒钟了

54:40.660 --> 54:42.660
于是是不是下一次循环

54:42.660 --> 54:43.660
下一次循环啥

54:43.660 --> 54:44.660
挨家家

54:44.660 --> 54:45.660
还要变成了几

54:45.660 --> 54:46.660
变成了一

54:46.660 --> 54:47.660
对不对

54:47.660 --> 54:48.660
还变成了一

54:48.660 --> 54:49.660
是不是又要运行这些碳帽子

54:49.660 --> 54:50.660
是不是

54:50.660 --> 54:51.660
又要运行这些碳帽子

54:51.660 --> 54:52.660
是不是又要运行

54:52.660 --> 54:53.660
一个匿名函数

54:53.660 --> 54:54.660
又要创建一个匿名函数

54:54.660 --> 54:55.660
scope2

54:55.660 --> 54:56.660
对不对

54:56.660 --> 54:57.660
是不是又要运行这个

54:57.660 --> 54:58.660
又要创建一个新的函数

54:58.660 --> 55:00.660
每次循环创建一个新的函数

55:00.660 --> 55:01.660
它是表达式

55:01.660 --> 55:02.660
它是表达式

55:02.660 --> 55:05.660
每一次循环都要创建一个新的函数

55:05.660 --> 55:07.660
是不是又指向它

55:07.660 --> 55:08.660
于是呢

55:08.660 --> 55:09.660
第二次循环又结束

55:09.660 --> 55:10.660
然后挨家家

55:10.660 --> 55:11.660
2

55:11.660 --> 55:12.660
懂我这个意思吗

55:12.660 --> 55:14.660
是不是到时候会创建多少个函数

55:14.660 --> 55:16.660
匿名函数是不是会创建10个

55:16.660 --> 55:17.660
对吧

55:17.660 --> 55:18.660
10个

55:18.660 --> 55:19.660
后面中间我不写了

55:19.660 --> 55:20.660
中间我不写了

55:23.980 --> 55:24.980
中间我不写了

55:27.420 --> 55:29.420
匿名函数它会创建10个

55:29.420 --> 55:30.420
那么这里

55:30.420 --> 55:31.420
又来一个

55:31.420 --> 55:33.420
都会指向的是啥

55:33.420 --> 55:34.420
都会指向的是这个

55:34.420 --> 55:35.420
同一个

55:35.420 --> 55:37.420
同一个就是VO

55:37.420 --> 55:38.420
指向的是它

55:38.420 --> 55:39.420
对吧

55:39.420 --> 55:40.420
没问题吧

55:40.420 --> 55:42.420
因为都是在这个环境下面创建的

55:42.420 --> 55:43.420
于是呢

55:43.420 --> 55:44.420
这个循环结束的时候

55:44.420 --> 55:45.420
I的值是多少

55:45.420 --> 55:46.420
I的值是不是等于10

55:46.420 --> 55:47.420
对吧

55:47.420 --> 55:48.420
I的值等于10

55:48.420 --> 55:49.420
好

55:49.420 --> 55:50.420
我告诉你

55:50.420 --> 55:51.420
这段单码运行完了

55:51.420 --> 55:53.420
I的值等于10的时候

55:53.420 --> 55:55.420
现在连一毫秒都不到

55:55.420 --> 55:57.420
连一毫秒都不到

55:57.420 --> 55:58.420
不信的话我们看

55:58.420 --> 55:59.420
我们来看一下

55:59.420 --> 56:00.420
这里

56:00.420 --> 56:01.420
我们写一个什么

56:01.420 --> 56:02.420
console我们之前学过的

56:02.420 --> 56:03.420
对吧

56:03.420 --> 56:04.420
碳

56:04.420 --> 56:05.420
计时

56:05.420 --> 56:06.420
碳

56:06.420 --> 56:07.420
然后这里

56:07.420 --> 56:08.420
写一个console

56:08.420 --> 56:09.420
n碳

56:09.420 --> 56:10.420
太Mand

56:10.420 --> 56:11.420
太Mand

56:11.420 --> 56:12.420
好

56:12.420 --> 56:13.420
复制一下

56:14.420 --> 56:15.420
张过来

56:15.420 --> 56:16.420
你看一下

56:16.420 --> 56:18.420
是不是0.1毫秒

56:18.420 --> 56:20.420
0.1毫秒

56:20.420 --> 56:21.420
就这么短

56:21.420 --> 56:24.420
所以你一秒钟还差得远的很

56:24.420 --> 56:26.420
还要等很久

56:26.420 --> 56:27.420
等很久过后

56:27.420 --> 56:29.420
这些函数是不可以执行的

56:29.420 --> 56:31.420
时间到了这些函数是不可以执行的

56:31.420 --> 56:32.420
那执行这些函数的时候

56:32.420 --> 56:34.420
它的I的值是不是已经是10了

56:34.420 --> 56:35.420
对不对

56:35.420 --> 56:36.420
它就已经是10了

56:36.420 --> 56:38.420
就变成了这个问题了

56:38.420 --> 56:40.420
明白的意思吧

56:40.420 --> 56:41.420
没问题吧

56:41.420 --> 56:43.420
所以这个I的值

56:43.420 --> 56:45.420
你得不到什么123456789

56:45.420 --> 56:46.420
得到的全是10

56:46.420 --> 56:48.420
是这么个原因

56:48.420 --> 56:49.420
好

56:49.420 --> 56:50.420
那么上面这道题是一样的道理

56:50.420 --> 56:51.420
是一样的道理

56:51.420 --> 56:52.420
只剩我把它放到函数里边了

56:52.420 --> 56:53.420
是一样的道理

56:53.420 --> 56:54.420
我只是说明一个啥

56:54.420 --> 56:56.420
其实在执行这个函数的时候

56:56.420 --> 56:57.420
是一样的问题

56:57.420 --> 56:58.420
对吧

56:58.420 --> 56:59.420
一样的问题

56:59.420 --> 57:00.420
我只是这里没有用这个变量

57:00.420 --> 57:02.420
没有用这个神明关键字VAR

57:02.420 --> 57:03.420
那我刚才说了

57:03.420 --> 57:04.420
如果你在函数里边

57:04.420 --> 57:06.420
没有使用这个关键字VAR

57:06.420 --> 57:07.420
那么这个I是在哪

57:07.420 --> 57:08.420
是在全局环境

57:08.420 --> 57:09.420
就是温度对象里边

57:09.420 --> 57:10.420
所以说这里是得到的

57:10.420 --> 57:12.420
能得到这个I

57:12.420 --> 57:13.420
运行完这个A之后

57:13.420 --> 57:14.420
能得到这个I的

57:14.420 --> 57:16.420
I的值就是10

57:16.420 --> 57:20.180
因为这是一个全局环境

57:20.180 --> 57:22.180
I的值是10

57:22.180 --> 57:25.180
这个I就是在全局环境里边

57:25.180 --> 57:27.180
那如果这里写个VAR

57:27.180 --> 57:28.180
这个I是在哪

57:28.180 --> 57:30.180
是在函数A的环境里边

57:30.180 --> 57:31.180
是在它的环境里边

57:31.180 --> 57:32.180
那外面能得到吗

57:32.180 --> 57:33.180
什么得不到

57:33.180 --> 57:34.180
对吧

57:34.180 --> 57:35.180
外面就得不到

57:35.180 --> 57:37.680
我这里复制

57:37.680 --> 57:38.680
三处

57:38.680 --> 57:39.680
那一看

57:39.680 --> 57:40.680
外面I就 is not defined

57:40.680 --> 57:41.680
但是里边可以得到

57:41.680 --> 57:42.680
对吧

57:42.680 --> 57:43.680
运行这个函数可以得到

57:43.680 --> 57:44.680
还有B包

57:44.680 --> 57:46.680
对吧

57:46.680 --> 57:47.680
好

57:47.680 --> 57:48.680
那么现在的问题

57:48.680 --> 57:49.680
如何来解决这个问题

57:49.680 --> 57:50.680
关键是

57:50.680 --> 57:52.680
关键是如何来解决这个问题

57:52.680 --> 57:53.680
我就希望一秒钟之后

57:53.680 --> 57:55.680
输出1 2 3 4 5 6 7 8 9 10

57:55.680 --> 57:57.680
那我怎么来解决这个问题

57:57.680 --> 57:58.680
怎么解决呢

57:58.680 --> 58:00.680
我们可以这样解决

58:00.680 --> 58:01.680
我们之前也说过

58:01.680 --> 58:02.680
也说过这种解决办法

58:02.680 --> 58:03.680
那么现在呢

58:03.680 --> 58:05.680
以前能不做强制要求

58:05.680 --> 58:06.680
现在做

58:06.680 --> 58:07.680
干嘛呢

58:07.680 --> 58:09.680
现在做强制要求了

58:09.680 --> 58:11.680
用立即执行函数

58:11.680 --> 58:15.250
用立即执行函数

58:15.250 --> 58:17.250
这里现在是强制要求了

58:17.250 --> 58:23.250
这样子写

58:23.250 --> 58:25.250
为什么这样子写就可以了

58:25.250 --> 58:26.250
我先看结果

58:26.250 --> 58:29.840
你看

58:29.840 --> 58:30.840
是不是可以了

58:30.840 --> 58:32.840
为什么这样子写就可以了

58:32.840 --> 58:34.840
咱们履一下吧

58:34.840 --> 58:35.840
履一下

58:35.840 --> 58:36.840
我们就用三个嘛

58:36.840 --> 58:37.840
三个

58:37.840 --> 58:38.840
三个也不多

58:38.840 --> 58:39.840
零一二嘛

58:39.840 --> 58:40.840
属数零一二

58:40.840 --> 58:42.840
好 接下来我们来看吧

58:42.840 --> 58:43.840
好

58:43.840 --> 58:44.840
一开始的循环

58:44.840 --> 58:46.840
循环

58:46.840 --> 58:47.840
I的值

58:47.840 --> 58:48.840
I的值是不是还是全局的

58:48.840 --> 58:49.840
对吧

58:49.840 --> 58:50.840
I的值还是全局的

58:50.840 --> 58:52.840
I一开始等于0嘛

58:52.840 --> 58:53.840
开始等于0

58:53.840 --> 58:54.840
然后调用谁

58:54.840 --> 58:55.840
调用

58:55.840 --> 58:56.840
你看

58:56.840 --> 58:57.840
每一次循环干嘛

58:57.840 --> 58:58.840
是不是创建了一个函数

58:58.840 --> 58:59.840
每一次循环

58:59.840 --> 59:00.840
创建了一个立民函数

59:00.840 --> 59:01.840
对不对

59:01.840 --> 59:03.840
创建了一个立民函数

59:03.840 --> 59:05.840
我们把它叫做立即执行函数

59:05.840 --> 59:06.840
对吧

59:06.840 --> 59:07.840
我们把它叫做立即函数嘛

59:07.840 --> 59:09.840
立即函数

59:09.840 --> 59:10.840
立即函数1

59:10.840 --> 59:12.840
第一次循环创建的

59:12.840 --> 59:15.840
好 立即函数1里边

59:15.840 --> 59:17.840
是不是有个scope

59:17.840 --> 59:18.840
对吧

59:18.840 --> 59:19.840
一个scope

59:19.840 --> 59:20.840
但这个scope呢

59:20.840 --> 59:21.840
我们都不用画了

59:21.840 --> 59:22.840
都不用画这个scope了

59:22.840 --> 59:23.840
都不用画了

59:23.840 --> 59:24.840
你就马上

59:24.840 --> 59:25.840
你很快就明白什么意思了

59:25.840 --> 59:26.840
好

59:26.840 --> 59:27.840
有一个立即执行函数1

59:27.840 --> 59:28.840
创建了

59:28.840 --> 59:29.840
对吧

59:29.840 --> 59:30.840
当然一个scope指向这

59:30.840 --> 59:32.840
然后马上运行这个函数

59:32.840 --> 59:34.840
马上运行

59:34.840 --> 59:37.840
好 马上运行的话

59:37.840 --> 59:42.790
那么这个立即执行函数1

59:42.790 --> 59:44.790
它里边是不是有vo

59:44.790 --> 59:45.790
有vo

59:45.790 --> 59:46.790
对不对

59:46.790 --> 59:48.790
那么它是不是有vo对象

59:48.790 --> 59:50.790
有vo对象

59:50.790 --> 59:51.790
有个对象

59:51.790 --> 59:52.790
它里边有啥了

59:52.790 --> 59:53.790
是不是有个参数

59:53.790 --> 59:54.790
你看

59:54.790 --> 59:56.790
这个函数是不是有个参数i

59:56.790 --> 59:57.790
同名的嘛

59:57.790 --> 59:58.790
对不对

59:58.790 --> 59:59.790
参数i

59:59.790 --> 01:00:00.790
i的值是多少了

01:00:00.790 --> 01:00:01.790
i的值

01:00:01.790 --> 01:00:03.790
i的值你看我怎么写的

01:00:03.790 --> 01:00:05.790
我调用这个函数

01:00:05.790 --> 01:00:08.790
把当前全局环境里边的i传过来

01:00:08.790 --> 01:00:10.790
作为参数传到这个i里边去

01:00:10.790 --> 01:00:11.790
虽然它名字一样

01:00:11.790 --> 01:00:12.790
但是它含义完全不一样

01:00:12.790 --> 01:00:14.790
这个i表示它是它的参数

01:00:14.790 --> 01:00:16.790
这个i是全局环境里边的变量

01:00:16.790 --> 01:00:18.790
把全局环境里边的变量的传过来

01:00:18.790 --> 01:00:19.790
是不是它等于0了

01:00:19.790 --> 01:00:20.790
对吧

01:00:20.790 --> 01:00:22.790
原始内形是值串定

01:00:22.790 --> 01:00:24.790
它等于0了

01:00:24.790 --> 01:00:27.790
你看一下吧

01:00:27.790 --> 01:00:29.790
指向这个

01:00:29.790 --> 01:00:30.790
没问题吧

01:00:30.790 --> 01:00:32.790
没问题吧

01:00:32.790 --> 01:00:33.790
当然了

01:00:33.790 --> 01:00:35.790
这个地方还会指向这个

01:00:35.790 --> 01:00:36.790
还会指向这里

01:00:36.790 --> 01:00:37.790
这里有scope

01:00:37.790 --> 01:00:38.790
但是这个东西不重要了

01:00:38.790 --> 01:00:40.790
已经不重要了

01:00:40.790 --> 01:00:41.790
然后我们看

01:00:41.790 --> 01:00:43.790
在这个函数的执行过程中

01:00:43.790 --> 01:00:45.790
是不是又运行了一个set timeout

01:00:45.790 --> 01:00:46.790
你看

01:00:46.790 --> 01:00:48.790
是不是又运行了一个函数出来

01:00:48.790 --> 01:00:50.790
那么这个时候你会发现

01:00:50.790 --> 01:00:51.790
这个函数

01:00:51.790 --> 01:00:53.790
问大家一个问题

01:00:53.790 --> 01:00:55.790
这个函数是在全局环境里边

01:00:55.790 --> 01:00:56.790
创建的

01:00:56.790 --> 01:00:57.790
还是说

01:00:57.790 --> 01:00:59.790
在那个

01:00:59.790 --> 01:01:00.790
这个函数里边创建的

01:01:00.790 --> 01:01:01.790
那肯定是这个函数

01:01:01.790 --> 01:01:02.790
对不对

01:01:02.790 --> 01:01:04.790
它不是在全局环境里边创建的

01:01:04.790 --> 01:01:06.790
它是这个函数里边创建的

01:01:06.790 --> 01:01:07.790
所以说

01:01:07.790 --> 01:01:08.790
我们这一块

01:01:08.790 --> 01:01:10.790
新建的那个匿名函数

01:01:10.790 --> 01:01:11.790
新建的那个匿名函数

01:01:11.790 --> 01:01:13.790
就等一秒钟之后

01:01:13.790 --> 01:01:15.790
执行那个匿名函数

01:01:15.790 --> 01:01:17.790
它里面的scope指向谁

01:01:17.790 --> 01:01:19.790
你看它指向的是谁

01:01:19.790 --> 01:01:23.790
它里面的scope指向的是这

01:01:23.790 --> 01:01:25.790
它指向的是这

01:01:25.790 --> 01:01:26.790
看到没

01:01:26.790 --> 01:01:28.790
指向的是这个地方

01:01:28.790 --> 01:01:29.790
那一秒钟之后

01:01:29.790 --> 01:01:30.790
它执行的时候

01:01:30.790 --> 01:01:32.790
是不是找到的是这个i

01:01:32.790 --> 01:01:33.790
那么这个匿名函数

01:01:33.790 --> 01:01:35.790
马上就执行完了

01:01:35.790 --> 01:01:36.790
但是

01:01:36.790 --> 01:01:38.790
它把这个东西保留下来了

01:01:38.790 --> 01:01:39.790
这就是必保

01:01:39.790 --> 01:01:41.790
它把这个东西保留下来了

01:01:41.790 --> 01:01:42.790
那么这个匿名函数

01:01:42.790 --> 01:01:44.790
它就保留到这个空间

01:01:44.790 --> 01:01:45.790
本来它是应该随着

01:01:45.790 --> 01:01:47.790
它一起消失的

01:01:47.790 --> 01:01:48.790
但是

01:01:48.790 --> 01:01:49.790
有别人还需要它

01:01:49.790 --> 01:01:50.790
它不能消失

01:01:50.790 --> 01:01:52.790
所以说它保留下来了

01:01:52.790 --> 01:01:53.790
那么一秒钟之后

01:01:53.790 --> 01:01:54.790
它是不是得到的是这个i

01:01:54.790 --> 01:01:55.790
那以后改来改去

01:01:55.790 --> 01:01:56.790
是不是改的是这个东西

01:01:56.790 --> 01:01:58.790
是不是不是一个东西

01:01:58.790 --> 01:01:59.790
那以后i加i

01:01:59.790 --> 01:02:00.790
它变成了i了

01:02:00.790 --> 01:02:01.790
然后又马上

01:02:01.790 --> 01:02:03.790
新建一个立即执行函数2

01:02:03.790 --> 01:02:04.790
你看

01:02:04.790 --> 01:02:05.790
每一次循环都创建一个

01:02:05.790 --> 01:02:06.790
立即执行函数

01:02:06.790 --> 01:02:07.790
于是

01:02:07.790 --> 01:02:08.790
到时候是不是

01:02:08.790 --> 01:02:09.790
这个立即执行函数

01:02:09.790 --> 01:02:10.790
它里面的

01:02:10.790 --> 01:02:11.790
它又是一款新的空间

01:02:11.790 --> 01:02:12.790
它里面是不是把i又传过来了

01:02:12.790 --> 01:02:13.790
对吧

01:02:13.790 --> 01:02:14.790
i又传过来了

01:02:14.790 --> 01:02:15.790
然后这里面

01:02:15.790 --> 01:02:16.790
是不是又有一个匿名函数

01:02:16.790 --> 01:02:17.790
这个匿名函数

01:02:17.790 --> 01:02:18.790
就指向这个

01:02:18.790 --> 01:02:19.790
对吧

01:02:19.790 --> 01:02:20.790
看到没

01:02:20.790 --> 01:02:21.790
它就形成了这么一种效果

01:02:21.790 --> 01:02:22.790
以后它消失

01:02:22.790 --> 01:02:23.790
但是它不会消失

01:02:23.790 --> 01:02:24.790
你要这意思吧

01:02:24.790 --> 01:02:25.790
好

01:02:25.790 --> 01:02:26.790
最终

01:02:26.790 --> 01:02:27.790
到时候执行

01:02:27.790 --> 01:02:28.790
它每一个函数

01:02:28.790 --> 01:02:29.790
有自己的i

01:02:29.790 --> 01:02:30.790
所以说

01:02:30.790 --> 01:02:32.790
我们可以用立即执行函数

01:02:32.790 --> 01:02:33.790
这种方式

01:02:33.790 --> 01:02:36.790
把这个作用语保留下来

01:02:36.790 --> 01:02:37.790
你看一下这个过程

01:02:37.790 --> 01:02:38.790
其实关键点就在于

01:02:38.790 --> 01:02:39.790
我把这个

01:02:39.790 --> 01:02:41.790
全局变量i

01:02:41.790 --> 01:02:42.790
传递给了它的参数

01:02:42.790 --> 01:02:43.790
于是

01:02:43.790 --> 01:02:44.790
这个函数是在这个

01:02:44.790 --> 01:02:46.790
这个立即执行函数

01:02:46.790 --> 01:02:47.790
这个立即执行函数

01:02:47.790 --> 01:02:49.790
是在这个函数里边定义的

01:02:49.790 --> 01:02:50.790
所以说这个立即执行函数

01:02:50.790 --> 01:02:51.790
它保留的就是

01:02:51.790 --> 01:02:52.790
上下文的

01:02:52.790 --> 01:02:53.790
是这个函数的上下文

01:02:53.790 --> 01:02:55.790
它用的是这个函数的i

01:02:55.790 --> 01:02:56.790
理它最近的

01:02:56.790 --> 01:02:57.790
我们之前说过

01:02:57.790 --> 01:02:58.790
创业函数的时候

01:02:58.790 --> 01:02:59.790
它理它最近的

01:02:59.790 --> 01:03:00.790
用的是这个i

01:03:00.790 --> 01:03:01.790
所以说这个i

01:03:01.790 --> 01:03:02.790
已经被保留下来了

01:03:02.790 --> 01:03:03.790
之前把0传过来

01:03:03.790 --> 01:03:04.790
还有保留到0

01:03:04.790 --> 01:03:05.790
下一次

01:03:05.790 --> 01:03:06.790
把它把1传过来

01:03:06.790 --> 01:03:07.790
还有保留到1

01:03:07.790 --> 01:03:08.790
看到没

01:03:08.790 --> 01:03:09.790
它是用这种模式

01:03:09.790 --> 01:03:10.790
就能解决这个问题

01:03:10.790 --> 01:03:12.790
这种方式一定要学会

01:03:12.790 --> 01:03:13.790
一定要学会

01:03:14.790 --> 01:03:15.790
好了

01:03:15.790 --> 01:03:16.790
你不仅要知道这个题

01:03:16.790 --> 01:03:17.790
该怎么去解

01:03:17.790 --> 01:03:18.790
而且要知道

01:03:18.790 --> 01:03:19.790
怎么来处理这个问题

01:03:19.790 --> 01:03:20.790
OK

01:03:20.790 --> 01:03:21.790
这就是作用语练

01:03:21.790 --> 01:03:22.790
其实说了半天

01:03:22.790 --> 01:03:23.790
说的是

01:03:23.790 --> 01:03:25.790
其实最终的结论很简单

01:03:26.790 --> 01:03:27.790
就是函数

01:03:27.790 --> 01:03:28.790
可以用外边的东西

01:03:29.790 --> 01:03:30.790
用外边的什么东西

01:03:30.790 --> 01:03:31.790
它生命的时候

01:03:31.790 --> 01:03:32.790
外边的东西就可以使用

01:03:32.790 --> 01:03:34.790
使用的是它生命的时候

01:03:34.790 --> 01:03:35.790
它外边的东西

01:03:36.790 --> 01:03:37.790
这就是这一块的知识

01:03:37.790 --> 01:03:38.790
当然

01:03:38.790 --> 01:03:39.790
我们这一块讲得比较详细

01:03:39.790 --> 01:03:40.790
会详细的讲了

01:03:40.790 --> 01:03:41.790
它整个过程

01:03:42.790 --> 01:03:43.790
这一块

01:03:44.790 --> 01:03:45.790
这一块学习到之后

01:03:46.790 --> 01:03:48.790
基本上你最难的关系就过了

01:03:49.790 --> 01:03:50.790
最难的这一块

01:03:50.790 --> 01:03:51.790
就是作用语练

01:03:51.790 --> 01:03:52.790
和执行函文

01:03:53.790 --> 01:03:54.790
这两块就涉及到

01:03:54.790 --> 01:03:55.790
GS最核心

01:03:55.790 --> 01:03:56.790
最底层的原理了

01:03:57.790 --> 01:03:58.790
当然还有没有再底层的

01:03:58.790 --> 01:03:59.790
还有

01:03:59.790 --> 01:04:00.790
那就要涉及到

01:04:00.790 --> 01:04:01.790
就是什么

01:04:01.790 --> 01:04:02.790
GS引擎的执行原理的

01:04:02.790 --> 01:04:03.790
这个东西

01:04:03.790 --> 01:04:04.790
跟我们没什么关系

01:04:04.790 --> 01:04:05.790
没什么关系

01:04:05.790 --> 01:04:06.790
你把这东西搞清楚

01:04:06.790 --> 01:04:08.790
就足够应付面试题的

01:04:08.790 --> 01:04:09.790
啥面试题都可以了

01:04:10.790 --> 01:04:11.790
好吧

01:04:11.790 --> 01:04:12.790
就这两块

