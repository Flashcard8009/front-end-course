WEBVTT

00:00.000 --> 00:14.700
讲一下这两个作业

00:14.700 --> 00:15.900
地道体

00:15.900 --> 00:17.500
这里有两个UAL元素

00:17.500 --> 00:19.300
一个是NASER1 一个是NASER2

00:19.300 --> 00:21.300
然后你准备了两个数组

00:21.300 --> 00:25.300
用来保存这两个UAL里面的A元素

00:25.300 --> 00:26.900
咱们来练习一下

00:26.900 --> 00:28.500
为什么要用两个呢

00:28.500 --> 00:32.500
就是避免你使用GETELEMENT牌TagName

00:32.500 --> 00:34.100
如果你用TagName的话

00:34.100 --> 00:35.500
那这里得到起来就比较麻烦了

00:35.500 --> 00:36.300
对吧

00:36.300 --> 00:37.900
咱们来这样子吧

00:38.100 --> 00:39.900
我们来写一个函数

00:39.900 --> 00:41.900
来写一个函数

00:41.900 --> 00:42.900
方可形

00:42.900 --> 00:44.100
这个方可形的函数

00:44.100 --> 00:45.900
我们来做什么事呢

00:45.900 --> 00:48.700
就是GETELEMENT

00:48.700 --> 00:49.900
NINX

00:49.900 --> 00:51.900
NINX CONTENT

00:51.900 --> 00:54.700
得到A元素里面的所有内容

00:54.700 --> 00:56.300
形成一个数组

00:56.300 --> 00:58.500
打个注射

00:58.500 --> 00:59.500
打成个注射

00:59.500 --> 01:02.300
得到

01:02.300 --> 01:05.100
得到某个元素

01:05.100 --> 01:11.300
下面的所有A元素的内容数组

01:11.300 --> 01:12.700
得到这么一个东西

01:12.700 --> 01:14.100
你要告诉我啥呢

01:14.100 --> 01:15.500
你肯定要告诉我一个元素

01:15.500 --> 01:15.900
对吧

01:15.900 --> 01:17.400
我要得到某个元素

01:17.400 --> 01:18.900
下面的所有A元素的数组

01:18.900 --> 01:20.400
所以说你要告诉我一个元素

01:20.400 --> 01:21.500
那么这里比方说

01:21.500 --> 01:22.900
你告诉我一个洞

01:22.900 --> 01:24.300
给我一个元素吧

01:24.300 --> 01:25.100
给我一个元素

01:25.100 --> 01:26.100
我就得到这个元素

01:26.100 --> 01:29.100
下面所有A元素的数组

01:29.100 --> 01:30.500
比方说咱们拿到这个元素

01:30.500 --> 01:31.800
到时候我怎么调用呢

01:31.800 --> 01:32.600
我这样调用

01:32.600 --> 01:33.900
看着

01:33.900 --> 01:34.800
我GETELEMENT

01:34.900 --> 01:36.200
NINX CONTENT

01:36.200 --> 01:37.300
你不是要给个元素吗

01:37.300 --> 01:37.900
对吧

01:37.900 --> 01:39.300
那我就这样子给里边

01:39.300 --> 01:41.000
Documents, Quarries, Nectar

01:41.000 --> 01:44.000
或者是GETELEMENTS by ID

01:44.000 --> 01:45.700
把这个什么ID列捨1

01:45.700 --> 01:46.200
对吧

01:46.200 --> 01:47.200
把这个元素得到

01:47.200 --> 01:49.200
把第一个EOL元素得到

01:49.200 --> 01:50.500
得到第一个EOL元素

01:50.500 --> 01:52.000
ID纹列捨1

01:52.000 --> 01:53.700
把这个元素给里

01:53.700 --> 01:54.400
传给里

01:54.400 --> 01:55.400
那么你来帮我得到

01:55.400 --> 01:58.600
这个元素下面的所有A元素

01:58.600 --> 01:59.400
当然你也可以把它

01:59.400 --> 02:01.200
先保存到一个变量里边

02:01.200 --> 02:02.600
列捨1

02:02.600 --> 02:04.300
然后再怎么样呢

02:04.300 --> 02:05.900
再把这个列捨1传进去

02:05.900 --> 02:07.400
都行都一样

02:07.400 --> 02:09.000
这些东西不用冲了吧

02:09.000 --> 02:11.300
这是以前的什么表达式的知识

02:11.300 --> 02:11.800
只不过呢

02:11.800 --> 02:13.900
就是我们学的web API

02:13.900 --> 02:15.700
它无非给提供了一些对象

02:15.700 --> 02:17.100
一些函数帮你使用

02:17.100 --> 02:18.900
规则跟以前是一样的

02:18.900 --> 02:20.400
是一样的

02:20.400 --> 02:22.000
然后它返回什么

02:22.000 --> 02:23.500
它返回一个新的数组

02:23.500 --> 02:24.000
对吧

02:24.000 --> 02:25.000
返回一个数组

02:25.000 --> 02:25.800
那么这个数组呢

02:25.800 --> 02:26.700
我就可以用这个

02:26.700 --> 02:27.500
把接收起来

02:27.500 --> 02:27.700
对吧

02:27.700 --> 02:28.500
这两个

02:28.500 --> 02:30.400
一开始都没有必要复制的

02:30.400 --> 02:31.800
都没有必要复制的

02:31.800 --> 02:33.600
就这里就直接接收就完事了

02:33.600 --> 02:36.100
列捨1 links接受一下

02:36.100 --> 02:36.300
好

02:36.300 --> 02:37.900
咱们用控制台

02:37.900 --> 02:39.900
在控制台里边把输出

02:39.900 --> 02:41.400
看一下这个数组

02:41.400 --> 02:42.800
它肯定是一个字不错的数组吧

02:42.800 --> 02:43.200
对吧

02:43.200 --> 02:44.500
我得到了是A元数的内容

02:44.500 --> 02:46.100
得到一个字不错的数组

02:46.100 --> 02:47.200
接着我们写

02:47.200 --> 02:49.300
那么这个函数里边怎么写呢

02:49.300 --> 02:50.300
dome

02:50.300 --> 02:51.200
什么

02:51.200 --> 02:52.300
什么东西

02:52.300 --> 02:53.800
我们是不是可以在里边使用

02:53.800 --> 02:55.400
query selector

02:55.400 --> 02:55.900
哦

02:55.900 --> 02:57.300
对不对

02:57.300 --> 02:58.600
找到这个dome元数

02:58.600 --> 03:00.000
下边的所有什么

03:00.000 --> 03:01.600
所有的A元数

03:01.700 --> 03:03.600
当然你也可以使用什么get

03:03.600 --> 03:08.900
animate by tag name

03:08.900 --> 03:09.600
找到这个元数

03:09.600 --> 03:13.200
下边的所有的元数名称为A的元数

03:13.200 --> 03:14.200
它得到是不是个数组

03:14.200 --> 03:14.500
对吧

03:14.500 --> 03:15.300
一个内数组

03:15.300 --> 03:16.300
对不对

03:16.300 --> 03:17.700
得到一个内数组

03:17.700 --> 03:17.900
好

03:17.900 --> 03:19.100
然后怎么样

03:19.100 --> 03:19.800
然后怎么样

03:19.800 --> 03:21.600
你是不是要再循环

03:21.600 --> 03:23.300
是不是得循环啊

03:23.300 --> 03:24.500
循环这个数组

03:24.500 --> 03:25.100
然后呢

03:25.100 --> 03:26.900
I再看这些A数组

03:26.900 --> 03:27.800
把这个A

03:27.800 --> 03:30.100
把这个A元数里边的什么东西拿出来

03:30.100 --> 03:31.700
把它的文本

03:31.700 --> 03:33.700
把它里边的文本拿出来就完事了

03:33.700 --> 03:34.700
对不对

03:34.700 --> 03:37.100
那么我们这里准备好一个新数组

03:37.100 --> 03:37.600
新数组

03:37.600 --> 03:38.600
来装

03:38.600 --> 03:39.500
装什么呢

03:39.500 --> 03:41.300
来装它里边的文本

03:41.300 --> 03:41.700
对吧

03:41.700 --> 03:42.900
来装它里边的文本

03:42.900 --> 03:43.600
好

03:43.600 --> 03:45.300
咱们来写一下吧

03:45.300 --> 03:46.300
for循环

03:46.300 --> 03:47.100
i等于0

03:47.100 --> 03:49.800
i小于ar.nance

03:49.800 --> 03:52.000
i加加

03:52.000 --> 03:54.200
循环这个所有A的数组

03:54.200 --> 03:55.100
A元数

03:55.100 --> 03:56.000
数组

03:56.000 --> 03:57.100
循环这个数组

03:57.100 --> 03:57.900
没循环意思

03:57.900 --> 03:59.400
是不是拿出一个A元数

03:59.400 --> 04:00.300
没问题吧

04:00.300 --> 04:02.800
没有循环意思拿出一个A元数

04:02.800 --> 04:04.200
跟以前的写法是一样的

04:04.200 --> 04:07.000
只不过现在就多了这么一些API而已

04:07.000 --> 04:07.800
好

04:07.800 --> 04:08.800
拿到这个A元数过后

04:08.800 --> 04:10.600
怎么来获取它的文本

04:10.600 --> 04:12.000
怎么来获取文本

04:12.000 --> 04:13.800
是不是找到它里边的什么

04:13.800 --> 04:15.700
A元数里边是不是只有一个东西啊

04:15.700 --> 04:17.600
我们这里A元数里边是不是只有文本

04:17.600 --> 04:18.200
对吧

04:18.200 --> 04:19.200
找到它的什么

04:19.200 --> 04:20.200
指节点

04:20.200 --> 04:21.100
对不对

04:21.100 --> 04:22.200
找到它第一个指节点

04:22.200 --> 04:23.500
或者是最后一个指节点

04:23.500 --> 04:24.700
是一样的

04:24.700 --> 04:25.800
first child

04:25.800 --> 04:26.200
对吧

04:26.200 --> 04:27.700
找到它的文本节点

04:27.800 --> 04:31.200
文本节点里边使用loaded value

04:31.200 --> 04:33.000
文本节点里边是不是可以使用loaded value

04:33.000 --> 04:34.100
咱们来看一下吧

04:34.100 --> 04:35.500
这里运行处来看一下吧

04:39.100 --> 04:41.400
早点咱们看一下啊

04:41.400 --> 04:42.000
随便找啊

04:42.000 --> 04:42.400
随便找

04:42.400 --> 04:45.000
找一个document query selector

04:45.000 --> 04:46.700
先随便找一个A元数

04:46.700 --> 04:48.500
随便找一个A元数

04:48.500 --> 04:51.500
前面我们用一个辩量接受一下

04:51.500 --> 04:51.600
好

04:51.600 --> 04:54.300
这个A元数得到它的什么first child

04:54.300 --> 04:54.900
对吧

04:54.900 --> 04:56.200
是不是个文本节点

04:56.200 --> 04:56.500
对吧

04:56.500 --> 04:57.300
文本节点

04:57.300 --> 04:59.300
文本节点里面是不是有loaded value

04:59.300 --> 04:59.700
对不对

04:59.700 --> 05:00.300
loaded value

05:00.300 --> 05:01.900
给看是不是文本的值

05:01.900 --> 05:03.400
没问题吧

05:03.400 --> 05:05.300
你自己去测试一下就知道了

05:05.300 --> 05:07.100
那么得到它的loaded value

05:07.100 --> 05:08.100
得到它之后

05:08.100 --> 05:09.300
把它加到哪里

05:09.300 --> 05:10.800
把这个文本加到哪

05:10.800 --> 05:11.900
就加到这里面

05:11.900 --> 05:12.800
对吧

05:12.800 --> 05:14.000
poosh

05:14.000 --> 05:16.400
把加入到新数组里边去

05:16.400 --> 05:16.600
好

05:16.600 --> 05:18.300
最后循环完成之后

05:18.300 --> 05:19.800
把这个新数组返回

05:19.800 --> 05:21.000
是不是完了

05:21.000 --> 05:21.200
好

05:21.200 --> 05:22.100
咱们看一下啊

05:22.100 --> 05:23.200
第一个数组

05:23.200 --> 05:24.400
第一个数组我们得到

05:24.400 --> 05:26.600
得到这个元数下面的所有A元数的内容

05:26.700 --> 05:27.900
保存看一下

05:27.900 --> 05:29.300
你看是不是得到了

05:29.300 --> 05:30.200
数组里面什么是水

05:30.200 --> 05:30.900
全是字不串

05:30.900 --> 05:31.100
对吧

05:31.100 --> 05:33.100
现在就全是字不串了

05:33.100 --> 05:33.700
OK

05:33.700 --> 05:34.700
那第二个还用说吗

05:34.700 --> 05:35.800
是不是不用说了

05:35.800 --> 05:36.700
对吧

05:36.700 --> 05:36.900
好

05:36.900 --> 05:37.400
这里

05:37.400 --> 05:39.100
列是2

05:41.200 --> 05:42.200
列是2

05:42.200 --> 05:43.300
这里

05:43.300 --> 05:44.500
列是2

05:44.500 --> 05:45.500
列是

05:45.500 --> 05:46.000
输出

05:46.000 --> 05:46.600
列是2

05:46.600 --> 05:47.500
列是

05:47.500 --> 05:47.600
好

05:47.600 --> 05:48.100
你看

05:48.100 --> 05:48.700
就完事了

05:48.700 --> 05:49.800
就完事了

05:49.800 --> 05:49.900
好

05:49.900 --> 05:51.100
这是第一道题

05:51.100 --> 05:52.100
第一道题其实这里边

05:52.100 --> 05:53.500
还有别的写法

05:53.500 --> 05:54.200
有没有别的写法

05:54.200 --> 05:55.500
当然有别的写法

05:55.500 --> 05:55.700
好

05:55.700 --> 05:56.300
看怎么写

05:56.300 --> 05:58.100
我可能会这样子写

05:58.100 --> 05:59.400
就这一部分了

05:59.400 --> 06:00.500
我就需要了

06:00.500 --> 06:01.800
我可能会这样子写

06:01.800 --> 06:03.000
我一句话写完

06:03.000 --> 06:04.400
看着啊

06:04.400 --> 06:05.800
二位

06:05.800 --> 06:07.000
from

06:07.000 --> 06:08.000
把什么东西

06:08.000 --> 06:12.500
把这个碗样下边的A元数

06:12.500 --> 06:14.100
全部转换成真数组

06:14.100 --> 06:15.300
这个是不是真数组

06:15.300 --> 06:15.600
对吧

06:15.600 --> 06:16.800
真的数组

06:16.800 --> 06:18.600
然后再怎么样呢

06:18.600 --> 06:20.100
再什么用map

06:20.100 --> 06:20.700
映射

06:20.700 --> 06:21.300
对吧

06:21.300 --> 06:23.500
把这个数组里边每一项是啥

06:23.500 --> 06:25.700
这个数组里边每一项是不是个A元数

06:25.700 --> 06:26.700
一个动物对象

06:26.700 --> 06:27.100
对吧

06:27.100 --> 06:29.200
这数组里边每一项是个动物对象

06:29.200 --> 06:30.300
是个A元数

06:30.300 --> 06:30.500
好

06:30.500 --> 06:33.700
把这个A元数的映射成字无串

06:33.700 --> 06:36.100
映射方形

06:36.100 --> 06:37.200
得到数组的每一项

06:37.200 --> 06:38.100
这个A

06:38.100 --> 06:39.900
然后返回啥呢

06:39.900 --> 06:40.700
返回啥

06:40.700 --> 06:46.300
返回这个A的first child node value

06:46.300 --> 06:47.700
一句话写完

06:47.700 --> 06:49.100
把整个返回

06:49.100 --> 06:49.900
完事了

06:49.900 --> 06:50.900
完事了

06:50.900 --> 06:51.800
这样子写也可以

06:51.800 --> 06:53.500
就是利用数组里边的方法

06:53.500 --> 06:55.100
当然你不能直接这样子map

06:55.100 --> 06:56.300
你是不能直接这样的map的

06:56.300 --> 06:57.500
因为它是伪数组

06:57.500 --> 06:59.900
伪数组里边是没有这个玩意儿的

06:59.900 --> 07:01.200
你这样子写可以

07:01.200 --> 07:01.800
保存看一下

07:01.800 --> 07:02.500
是不是一样的

07:02.500 --> 07:03.300
对吧

07:03.300 --> 07:04.500
这两种方式随便

07:04.500 --> 07:05.300
你看着这种拿中

07:05.300 --> 07:06.700
就用拿中

07:06.700 --> 07:08.200
这是第一道题

07:08.200 --> 07:10.100
第二题

07:10.100 --> 07:11.100
写一个函数

07:11.100 --> 07:12.600
传入一个动物对象

07:12.600 --> 07:16.100
这个对象返回的是第一个DIV容器

07:16.100 --> 07:17.300
得到的是第一个DIV容器

07:17.300 --> 07:18.900
就是随便给我传个对象

07:18.900 --> 07:21.900
我一定要找到它的第一个DIV容器往上找

07:21.900 --> 07:22.800
如果它没有的话

07:22.800 --> 07:25.800
当然就返回ondefine或者是返回nau

07:25.800 --> 07:26.400
好吧

07:26.400 --> 07:28.300
这里咱们写个函数

07:28.300 --> 07:31.300
这个函数getDIVcontainer

07:31.300 --> 07:33.200
得到第一个DIV容器

07:33.200 --> 07:34.200
给我一个什么参数

07:34.200 --> 07:36.300
给我一个动物对象

07:36.300 --> 07:37.600
比方说到时候我调用的时候

07:37.600 --> 07:40.200
怎么调用呢

07:40.200 --> 07:43.300
我这样调用DIVcontainer

07:43.300 --> 07:45.200
比方说传一个动物进去

07:45.200 --> 07:46.400
随便传一个吧

07:46.400 --> 07:47.900
随便传一个

07:47.900 --> 07:53.500
我就传这个DIV里边的第三个A元数

07:53.500 --> 07:54.100
好吧

07:54.100 --> 07:56.400
我就传DIV里边的第三个A元数

07:56.400 --> 07:58.500
document query selector

07:58.500 --> 08:00.300
找到这个DIVcontainer

08:00.300 --> 08:08.000
下边的再继续get element tag name

08:08.000 --> 08:09.000
得到A元数

08:09.000 --> 08:09.800
得到第几个呢

08:09.800 --> 08:10.600
第三个

08:10.600 --> 08:11.700
下边为二

08:11.700 --> 08:13.600
总之里把这个A元数传给它就完事了

08:13.600 --> 08:14.700
不管这个代码有多长

08:14.700 --> 08:17.000
当然你可以把它分成几步来写

08:17.000 --> 08:17.900
先得到这个玩意

08:17.900 --> 08:19.100
再得到这个玩意都一样

08:19.100 --> 08:19.800
都一样

08:19.800 --> 08:21.800
总之得到第二个A元数

08:21.800 --> 08:22.700
第二个A元数

08:22.700 --> 08:24.400
得到这个DIV

08:24.400 --> 08:26.600
下边的第三个A元数

08:26.600 --> 08:27.600
得到它

08:27.600 --> 08:28.700
那么去测试一下

08:28.700 --> 08:29.900
主要是测试一下

08:29.900 --> 08:31.000
最后输出这个DIV

08:31.000 --> 08:32.900
看得到是不是正确的结果

08:32.900 --> 08:34.300
看一下吧

08:34.300 --> 08:36.100
咱们来写这个函数

08:36.100 --> 08:38.600
那这个函数怎么写呢

08:38.600 --> 08:39.900
我现在已知一个动物对象

08:39.900 --> 08:41.700
这个动物对象可能是它

08:41.700 --> 08:42.300
也可能是它

08:42.300 --> 08:43.100
可能是任何东西

08:43.100 --> 08:43.500
对吧

08:43.500 --> 08:44.800
可能是它

08:44.800 --> 08:45.800
我怎么办

08:45.800 --> 08:47.100
我要找它歪一层的

08:47.100 --> 08:49.000
就是它的主纤元数的

08:49.000 --> 08:50.400
第一个DIV元数

08:50.400 --> 08:51.800
那怎么找呢

08:51.800 --> 08:53.800
看着我们可以用这种方式来写

08:53.800 --> 08:55.500
这种方式来写

08:55.500 --> 08:58.000
就是一层一层往上找

08:58.000 --> 08:59.000
对不对

08:59.000 --> 08:59.300
好

08:59.300 --> 09:02.800
首先我得到它的副元数

09:02.800 --> 09:04.100
得到它的副元数

09:04.100 --> 09:04.800
看着

09:06.000 --> 09:07.500
首先我得到它的副元数

09:07.500 --> 09:08.700
parent

09:08.700 --> 09:12.000
dom.parentElement

09:12.000 --> 09:14.400
或者是parent load都行

09:14.400 --> 09:15.700
只不过你要注意一下

09:15.700 --> 09:17.300
load的话一直往上找

09:17.300 --> 09:18.900
是不是可能会找到

09:18.900 --> 09:19.700
document

09:19.700 --> 09:20.800
对吧

09:20.800 --> 09:22.300
那么如果是用Element的话

09:22.300 --> 09:23.900
它是找不到document

09:23.900 --> 09:26.800
再注意一下

09:26.800 --> 09:28.000
所以先看它的副元数

09:28.000 --> 09:28.500
对吧

09:28.500 --> 09:30.900
是不是看它的副元数是满足要求

09:30.900 --> 09:32.300
副元数什么叫满足要求

09:32.300 --> 09:35.300
什么叫做满足要求

09:35.300 --> 09:37.400
或者说什么叫做

09:37.400 --> 09:39.600
就说什么叫做满足要求

09:39.600 --> 09:42.600
就是parent有值对不对

09:42.600 --> 09:44.400
parent有值

09:44.400 --> 09:46.900
并且它有副元数

09:46.900 --> 09:48.400
比方说找到atm元数过后

09:48.400 --> 09:50.300
atm元数是不是没有副元数了

09:50.300 --> 09:51.700
它有副元数

09:51.700 --> 09:54.500
并且副元数的元数名称

09:54.500 --> 09:55.400
load name

09:55.400 --> 09:56.100
是啥

09:56.100 --> 09:57.000
注意大小写

09:57.000 --> 09:58.400
大写的div

09:58.400 --> 10:01.100
元数的名称一定是大写的div

10:01.100 --> 10:02.500
那是不是找到了

10:02.500 --> 10:03.500
那是不是没问题了

10:03.500 --> 10:04.400
没问题怎么办

10:04.400 --> 10:05.600
把parent返回就完事了

10:05.600 --> 10:06.900
对吧

10:06.900 --> 10:07.400
是不是这种

10:07.400 --> 10:08.700
这是一种情况

10:08.700 --> 10:10.200
没问题吧

10:10.200 --> 10:11.200
再看一下

10:11.200 --> 10:13.100
我得到它的副元数

10:13.100 --> 10:14.900
看一下这个副元数是不是有

10:14.900 --> 10:15.900
它有没有副元数

10:15.900 --> 10:17.500
有的话

10:17.500 --> 10:18.700
就这里有值

10:18.700 --> 10:20.300
你不用去写不等于闹

10:20.300 --> 10:21.500
不用去写这种东西

10:21.500 --> 10:22.900
因为它只要是一个正常的对象

10:22.900 --> 10:24.900
它就一定是判定为去

10:24.900 --> 10:26.100
如果它有值

10:26.100 --> 10:27.100
并且

10:27.100 --> 10:29.100
副元数的名称div

10:29.100 --> 10:30.400
是不是已经找到了

10:30.400 --> 10:32.700
就把副元数返回就完事了

10:32.700 --> 10:34.600
如果没有找到怎么办

10:34.600 --> 10:37.100
没有找到是不是要找副元数的副元数

10:37.100 --> 10:39.100
没问题吧

10:39.100 --> 10:40.000
如果没有找到

10:40.000 --> 10:42.000
是不是要找副元数的副元数

10:42.000 --> 10:43.600
又重新给它复职

10:43.600 --> 10:44.600
复职为啥

10:44.600 --> 10:47.100
副元数的副元数

10:47.100 --> 10:48.900
好好理解一下

10:48.900 --> 10:49.900
如果没有找到的话

10:49.900 --> 10:50.900
那还要往上找

10:50.900 --> 10:52.200
继续往上找

10:52.200 --> 10:53.000
又要找什么

10:53.000 --> 10:54.200
找副元数的副元数

10:54.200 --> 10:55.400
是不是又要判断

10:55.400 --> 10:55.800
对吧

10:55.800 --> 10:56.700
又要判断

10:56.700 --> 10:58.000
如果正确的话

10:58.000 --> 10:59.100
那又返回

10:59.100 --> 11:00.200
如果还是没有找到

11:00.200 --> 11:01.900
是不是又要继续找

11:01.900 --> 11:03.600
你看这里是不是要循环

11:03.600 --> 11:04.700
这里是不是要循环

11:04.700 --> 11:06.400
你都不知道要写多少次

11:06.400 --> 11:08.200
都肯定要循环

11:08.200 --> 11:09.800
所以说这一块我们怎么写

11:09.800 --> 11:11.100
我们可以这样子写

11:11.200 --> 11:13.200
看着循环

11:13.200 --> 11:14.200
循环什么呢

11:14.200 --> 11:15.900
条件是什么呢

11:15.900 --> 11:18.200
把写成y哦

11:18.200 --> 11:19.500
条件是

11:19.500 --> 11:21.600
parent

11:21.600 --> 11:23.000
等于那

11:23.000 --> 11:24.000
不等于

11:24.000 --> 11:26.500
parent不等于那

11:26.500 --> 11:29.300
有副元数

11:29.300 --> 11:30.100
它有副元数

11:30.100 --> 11:30.800
不是没有哦

11:30.800 --> 11:32.100
它有副元数

11:32.100 --> 11:32.600
但是呢

11:32.600 --> 11:34.800
副元数的名字不等于DIV

11:34.800 --> 11:36.600
是不是要继续找

11:36.600 --> 11:37.600
循环条件吗

11:37.600 --> 11:39.300
就是要一直往上找

11:39.300 --> 11:40.600
循环条件

11:40.700 --> 11:41.800
只要它等于那了

11:41.800 --> 11:42.800
就表示没有副元数了

11:42.800 --> 11:44.000
没有副元数自然不糟了

11:44.000 --> 11:44.700
对吧

11:44.700 --> 11:46.700
没有副元数自然不糟了

11:46.700 --> 11:48.300
只要它有副元数

11:48.300 --> 11:49.400
就是它不等于那

11:49.400 --> 11:50.800
它有副元数

11:50.800 --> 11:53.700
或者说你这里加上什么

11:53.700 --> 11:55.100
加上

11:55.100 --> 11:56.500
就是直接写个parent

11:56.500 --> 11:57.100
对吧

11:57.100 --> 11:59.100
它有副元数

11:59.100 --> 12:00.200
然后呢

12:00.200 --> 12:01.700
副元数的名称

12:01.700 --> 12:02.900
但是不等于DIV

12:02.900 --> 12:04.300
是不是要继续找

12:04.300 --> 12:05.600
继续找怎么找

12:05.600 --> 12:07.300
parent是不是重新复制

12:07.300 --> 12:08.400
复制为什么parent

12:09.000 --> 12:11.300
no parent

12:11.300 --> 12:12.700
animate

12:12.700 --> 12:14.100
找副元数的副元数

12:14.100 --> 12:15.100
然后又来判断

12:15.100 --> 12:16.900
这个副元数的副元数有没有值呢

12:16.900 --> 12:18.300
如果还是有值

12:18.300 --> 12:19.800
并且还是不等于DIV

12:19.800 --> 12:20.800
是不是继续找

12:20.800 --> 12:22.100
找到什么时候停止

12:22.100 --> 12:24.400
要么没有副元数了

12:24.400 --> 12:25.800
要么呢

12:25.800 --> 12:27.700
副元数就已经是DIV了

12:27.700 --> 12:29.000
所以找到这里就停止了

12:29.000 --> 12:30.100
那么找完了之后

12:30.100 --> 12:31.300
出了这个循环

12:31.300 --> 12:32.700
是不是一定找完了

12:32.700 --> 12:33.700
要么就没有副元数了

12:33.700 --> 12:34.700
全部都找完了

12:34.700 --> 12:35.100
要么呢

12:35.100 --> 12:37.300
就是找到了这个DIV

12:37.400 --> 12:40.200
最后我们返回parent

12:40.200 --> 12:40.700
保存

12:40.700 --> 12:41.900
用这种写法写

12:41.900 --> 12:43.500
这种写法以前可能没见过

12:43.500 --> 12:45.000
只是你好好理一下这个逻辑

12:45.000 --> 12:46.700
确实应该用这种写法

12:46.700 --> 12:47.900
保存看一下

12:47.900 --> 12:50.700
这里运行出来

12:50.700 --> 12:51.300
运行

12:51.300 --> 12:52.200
F10看一下

12:52.200 --> 12:53.200
看一下答案

12:53.200 --> 12:54.300
那你看是不是找到了

12:54.300 --> 12:54.900
container

12:54.900 --> 12:55.300
对不对

12:55.300 --> 12:56.100
找到了

12:56.100 --> 12:57.100
再看

12:57.100 --> 12:58.300
那如果换一个元数

12:58.300 --> 12:59.900
比方说这个副元数

12:59.900 --> 13:02.100
加上id test

13:02.100 --> 13:03.400
找下这个副元数

13:03.400 --> 13:04.700
比方说这里我为了方便

13:04.700 --> 13:05.800
然后就直接写个test

13:05.800 --> 13:06.700
因为我们知道id

13:06.700 --> 13:10.400
它会成为全局的对象的属性

13:10.400 --> 13:10.900
你看一下

13:10.900 --> 13:12.200
所以也可以找到c3

13:12.200 --> 13:12.700
看没有

13:12.700 --> 13:13.600
c3

13:13.600 --> 13:13.800
好

13:13.800 --> 13:15.500
那如果我找这个c3

13:15.500 --> 13:17.700
document query

13:17.700 --> 13:19.100
query signature

13:19.100 --> 13:22.300
找这个c3

13:22.300 --> 13:22.900
这个DIV

13:22.900 --> 13:24.300
找他的容器

13:24.300 --> 13:25.100
找一下

13:25.100 --> 13:26.800
找出来是不是container2

13:26.800 --> 13:27.600
看没

13:27.600 --> 13:28.900
找出来就是他container2

13:28.900 --> 13:29.700
没问题吧

13:29.700 --> 13:31.900
就找到了

13:31.900 --> 13:33.300
比方说我们再回去

13:33.300 --> 13:34.800
变成那个test

13:34.800 --> 13:36.800
那如果把这里写成span

13:36.800 --> 13:39.800
把这里写成什么呢

13:39.800 --> 13:40.900
写成header元数

13:40.900 --> 13:42.300
就瞎写

13:42.300 --> 13:43.200
写成个header元数

13:43.200 --> 13:43.900
那找

13:43.900 --> 13:45.300
找到是不是container2

13:45.300 --> 13:46.700
看没有

13:46.700 --> 13:48.700
找到就是container2

13:48.700 --> 13:48.900
好

13:48.900 --> 13:49.700
就这种写法

13:49.700 --> 13:50.200
这种写法

13:50.200 --> 13:51.500
测试一下就行了

13:51.500 --> 13:52.300
就这么一个函数

13:52.300 --> 13:53.300
都主要是锻炼一下

13:53.300 --> 13:54.500
大家的逻辑思维

13:54.500 --> 13:55.300
二呢

13:55.300 --> 13:56.000
是锻炼一下

13:56.000 --> 13:58.100
大家对这个API的熟悉程度

13:58.100 --> 13:59.000
熟悉一下

13:59.000 --> 14:00.900
其实这里我们还可以用这种写法

14:00.900 --> 14:03.100
还可以用一种写法

14:03.100 --> 14:04.500
看着

14:04.600 --> 14:07.400
非常神奇的写法

14:07.400 --> 14:09.700
这句代码只运行一次

14:09.700 --> 14:11.200
是不是只运行一次

14:11.200 --> 14:13.200
这个代码是不是循环条件

14:13.200 --> 14:13.700
这个代码

14:13.700 --> 14:16.400
是不是每次循环之后要做的事

14:16.400 --> 14:17.400
4

14:17.400 --> 14:19.300
4循环其实很灵活的

14:19.300 --> 14:20.500
我们之前说过

14:20.500 --> 14:24.600
任何循环都可以转换成4循环

14:24.600 --> 14:25.400
你看

14:25.400 --> 14:27.200
4循环第一段是不是

14:27.200 --> 14:29.300
循环一开始运行一次的代码

14:29.300 --> 14:30.100
对吧

14:30.100 --> 14:33.100
然后中间这部分是不是循环条件

14:33.300 --> 14:34.900
中间这部分循环条件

14:34.900 --> 14:38.500
后边这部分是不是循环结束过后

14:38.500 --> 14:40.700
不要老是写哀家家

14:40.700 --> 14:41.700
写熟了过后

14:41.700 --> 14:44.000
都不知道自己自己在写啥了

14:44.000 --> 14:45.600
都不知道自己在写啥了

14:45.600 --> 14:47.700
循环体流空

14:47.700 --> 14:49.500
循环体啥都不写

14:49.500 --> 14:51.300
啥都不写

14:51.300 --> 14:52.500
就是没有什么循环体

14:52.500 --> 14:53.400
根本就没有循环体

14:53.400 --> 14:54.800
我也不需要做啥

14:54.800 --> 14:55.800
就是循环边

14:55.800 --> 14:57.000
循环结束过后

14:57.000 --> 14:57.600
返回什么

14:57.600 --> 14:58.500
parent

14:58.500 --> 14:59.900
返回parent

14:59.900 --> 15:01.300
保存看一下

15:01.300 --> 15:04.300
你看是不是还是可以得到结果

15:04.300 --> 15:06.400
那么歧视我这里顺便说一下

15:06.400 --> 15:08.500
如果没有循环体的话

15:08.500 --> 15:10.000
我这里换个行

15:10.000 --> 15:11.900
大家看不清楚

15:11.900 --> 15:12.500
如果

15:13.800 --> 15:15.000
一格式化的话

15:15.000 --> 15:16.500
可以回去了

15:16.500 --> 15:19.000
如果循环没有循环体的话

15:19.000 --> 15:20.600
按理说

15:20.600 --> 15:22.800
是可以去掉这个大货号的

15:22.800 --> 15:23.800
是可以去掉的

15:23.800 --> 15:24.600
没问题

15:24.600 --> 15:26.400
保存看一下

15:26.400 --> 15:28.400
但是你这里就不能去掉了

15:28.400 --> 15:30.400
按理说是可以去掉的

15:30.400 --> 15:32.500
因为他是这样子

15:32.500 --> 15:33.600
如果你去掉过后

15:33.600 --> 15:35.900
他认为现在的代码是这样的格式

15:35.900 --> 15:39.070
他认为是这样的格式

15:39.070 --> 15:41.370
他认为代码是这样的格式

15:41.370 --> 15:43.270
你的循环体在这

15:43.270 --> 15:45.270
就是什么情况下可以去掉大货号

15:45.270 --> 15:47.070
就是循环体中没有语句

15:47.070 --> 15:49.670
或者是只有一条语句

15:49.670 --> 15:51.270
循环体里边没有语句

15:51.270 --> 15:53.270
或者是只有一条语句的时候

15:53.270 --> 15:54.270
复循环是可以

15:54.270 --> 15:55.070
这些循环

15:55.070 --> 15:56.670
这大货号是可以去掉的

15:56.670 --> 15:57.470
包括这个while循环

15:57.470 --> 15:57.970
这里也是

15:57.970 --> 15:58.670
只有一条语句

15:58.670 --> 16:00.170
可以去掉大货号

16:00.170 --> 16:01.670
但是他只能识别一条语句

16:01.670 --> 16:02.770
你去掉大货号过后

16:02.770 --> 16:04.570
他只会读取下一条语句

16:04.570 --> 16:06.970
把下一条语句当成循环体

16:06.970 --> 16:07.970
你看这个意思

16:07.970 --> 16:09.970
所以说这种情况下就不能去掉了

16:09.970 --> 16:11.170
在这里就不能去掉了

16:11.170 --> 16:12.470
如果后边没有语句的话

16:12.470 --> 16:13.270
是可以去掉的

16:13.270 --> 16:14.870
可以不要这个循环体

16:14.870 --> 16:16.170
你看这个意思

16:16.170 --> 16:19.370
一格式他就变成这样子了

16:19.370 --> 16:20.770
那就这样子

16:20.770 --> 16:21.670
好吧

16:21.670 --> 16:22.770
用这种写法也可以

16:22.770 --> 16:24.170
这种写法更加简洁

16:24.170 --> 16:25.370
其实是一样的

16:25.370 --> 16:26.370
无所谓

16:26.370 --> 16:28.170
这种写法也可以

16:28.170 --> 16:29.570
就写法有很多

16:29.570 --> 16:29.970
好吧

16:30.070 --> 16:30.770
讲一下

16:30.770 --> 16:31.970
这是这两条题

16:31.970 --> 16:32.570
练习一下

16:32.570 --> 16:33.370
一定要去练习一下

