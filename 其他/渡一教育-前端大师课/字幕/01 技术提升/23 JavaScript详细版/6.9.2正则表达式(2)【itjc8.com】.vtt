WEBVTT

00:00.000 --> 00:17.020
第一题 匹配手机号 手机号第一位十一 一共十一位

00:17.020 --> 00:22.020
这个很简单 我们第一个就 直播开始呗 开始

00:22.020 --> 00:26.020
然后写一个一 然后后边是 随便什么数字都行啊

00:26.020 --> 00:31.020
就是写杠地 随便什么数字都行 这个数字呢 出现十次

00:31.020 --> 00:36.020
就完了嘛 对吧 就完了呗 这就是一个手机号

00:37.020 --> 00:43.020
写一个呗 这样子肯定不能匹配的 这必须要这样子写

00:43.020 --> 00:48.020
这样子可以匹配的 对吧 OK啊 这是第一题 非常简单

00:48.020 --> 00:51.020
第二题是不是写过了 对吧 写过不写了啊

00:51.020 --> 00:55.020
第三题 密码必须是六到十二位的制服

00:55.020 --> 01:00.020
只能包含数字字母下滑线 数字字母下滑线 是不是单词制服

01:00.020 --> 01:05.020
对吧 单词制服呢 就这样子呗 下滑线

01:05.020 --> 01:08.020
就这样子呗 写杠W W

01:08.020 --> 01:13.020
然后呢 加上一个六到十二位 说他就写完了吧 对吧

01:13.020 --> 01:17.020
就写完了啊 现在能匹配对吧 能匹配 现在是十一位的手机号

01:17.020 --> 01:21.020
然后呢 这数字母呢 也能匹配啊 也能匹配

01:21.020 --> 01:24.020
啊 如果你少于六位的话 是匹配不了的 对吧

01:24.020 --> 01:28.020
但是一定要加上开始和结束啊 整体上进行匹配

01:28.020 --> 01:31.020
好吧 这是第一个 第二个 第三个题啊

01:31.020 --> 01:34.020
下一个题 写个证则表达是来匹配油箱

01:34.020 --> 01:39.020
OK 这个油箱呢 就稍微 稍微的复杂一点啊

01:39.020 --> 01:44.020
好 怎么来匹配油箱呢 油箱我们可以看到一开始

01:44.020 --> 01:47.020
一开始呢 写的是一些单词制服 就是可能有字母

01:47.020 --> 01:50.020
可能有数字 可能有下滑线 对吧

01:50.020 --> 01:52.020
一开始呢 写的是一些单词制服 OK

01:52.020 --> 01:55.020
我们一开始呢 就可以认为他前面说

01:55.020 --> 01:59.020
啊 单词制服 开始啊 W

01:59.020 --> 02:03.020
啊 单词制服 出现多少次呢 出现一次或多次

02:03.020 --> 02:07.020
他不能出现零次嘛 对吧 他可以出现一次 可以出现多次

02:07.020 --> 02:09.020
然后后边呢 有一个ata OK

02:09.020 --> 02:12.020
我们后边就写上一个ata就完事了啊

02:12.020 --> 02:15.020
然后前边是一串单词制服 然后后边一个ata

02:15.020 --> 02:19.020
ata后边呢 这一部分啊 这一部分是不是又是一个单词制服

02:19.020 --> 02:22.020
对吧 一般是网站的域名 比如新浪QQ对吧

02:22.020 --> 02:25.020
一般是网站的域名 好 所以说这一块呢

02:25.020 --> 02:28.020
一般就是一个就是单词制服啊 单词制服

02:28.020 --> 02:32.020
不过域名的话 有可能有横杠 还是有可能有横杠的

02:32.020 --> 02:35.020
所以说我们写上一个单词制服吧 单词制服

02:35.020 --> 02:39.020
出现一次或多次 单词制服出现一次或多次

02:39.020 --> 02:44.020
好 然后呢 接下来就是什么呢 接下来就是这一部分看

02:44.020 --> 02:49.020
是不是出现一次和两次 这一部分出现一次或两次

02:49.020 --> 02:51.020
好 那么这一部分呢 我们把它当成一个整体

02:51.020 --> 02:54.020
给大家算个小货号 当上一个整体

02:54.020 --> 02:58.020
这个整体呢 出现多少呢 出现一次或两次

02:58.020 --> 03:02.020
一次或两次 好 那么这个整体里边呢 写的是啥呢

03:02.020 --> 03:06.020
整体里边写的是 里边是什么呢 一个底

03:06.020 --> 03:09.020
然后呢 后边是什么 单词制服 对吧

03:09.020 --> 03:13.020
好 里边一个底 但是底注意啊 你要转移

03:13.020 --> 03:17.020
你要转移 不转移的话 他就是一个匹配正义制服了

03:17.020 --> 03:21.020
好 转移一个底 然后呢 在写上什么 就是

03:22.020 --> 03:26.020
单词制服多个 多个单词制服

03:26.020 --> 03:30.020
整体上出现一到两次 最后多的结束就写完了

03:30.020 --> 03:34.020
这就是一个最简单的一个邮箱的政策表达式

03:34.020 --> 03:37.020
比方说 随便写一个 随便写一个 这个肯定不能匹配

03:37.020 --> 03:40.020
加上个A塔还是不能匹配 还是不能匹配

03:40.020 --> 03:44.020
那加上QQ的抗 可以匹配了

03:44.020 --> 03:47.020
吊声N 这个也可以匹配 也能匹配

03:47.020 --> 03:50.020
这就是一个邮箱的政策表达式

03:51.020 --> 03:54.020
咱们继续往下看 匹配一个座几号

03:54.020 --> 03:58.020
匹配一个座几号 座几号前边是一到三个数字

03:58.020 --> 04:02.020
后边是四到八个数字 来呗 前边

04:02.020 --> 04:05.020
一到三个数字 数字嘛 对吧 一到三个

04:05.020 --> 04:09.020
然后中间一个横杠 然后后边一个数字

04:09.020 --> 04:13.020
四到八个 结束了 写完了

04:13.020 --> 04:16.020
现在不能匹配 如果是这样子写

04:17.020 --> 04:21.020
是不是可以匹配了 诶 几个 四到八个 多了一个

04:21.020 --> 04:24.020
多了一个 可以匹配了

04:24.020 --> 04:27.020
就这么简单 非常简单

04:27.020 --> 04:31.020
下一个 匹配一个正数 正数

04:31.020 --> 04:34.020
正数就直接写 对吧 直接写

04:35.020 --> 04:38.020
正数是不是至少得有一个数字 对吧

04:38.020 --> 04:40.020
至少得有一个数字吧

04:40.020 --> 04:43.020
开始过后 至少得有一个数字

04:43.020 --> 04:46.020
出现一次或多次 一次或多次

04:46.020 --> 04:49.020
当然也可以写 这样子也可以写

04:49.020 --> 04:52.020
总之出现一次或多次

04:52.020 --> 04:55.020
正数后边有可能是小数 也就是有可能会出现点

04:55.020 --> 04:58.020
有可能会出现点 斜杠点

04:58.020 --> 05:01.020
底儿出现了零次或一次

05:01.020 --> 05:04.020
底儿出现零次或一次 可以不出现

05:04.020 --> 05:07.020
可以不出现 也可以出现

05:07.020 --> 05:11.020
然后后边有数字 对吧 后边有数字

05:11.020 --> 05:14.020
后边的数字出现多好呢

05:14.020 --> 05:17.020
后边的数字出现一次或多次

05:17.020 --> 05:20.020
看一下这样子写行不行

05:20.020 --> 05:22.020
这样子写行不行 咱们来看一下呗

05:22.020 --> 05:24.020
这个肯定是匹配不了 有个横杠

05:24.020 --> 05:27.020
比方说234 能不能匹配 能不能匹配

05:27.020 --> 05:30.020
2.34 也能匹配

05:30.020 --> 05:33.020
0.34 也能匹配

05:33.020 --> 05:37.020
0.01 也能匹配

05:37.020 --> 05:39.020
也能匹配

05:39.020 --> 05:41.020
后边再写上一个数字能不能匹配 不能匹配了

05:41.020 --> 05:43.020
因为它一定是数字结束

05:43.020 --> 05:48.020
然后后边是 如果后边是

05:48.020 --> 05:51.020
0.1 这种能匹配吗 也不能匹配

05:51.020 --> 05:54.020
因为它只能出现零次或一次

05:54.020 --> 05:56.020
但是这个写法会有一个问题

05:56.020 --> 05:58.020
有什么问题呢 就这种写法

05:58.020 --> 06:01.020
如果直接写个1 它就不能匹配了

06:01.020 --> 06:02.020
为什么呢 你看一下呗

06:02.020 --> 06:05.020
一开始出现一个数字一次或多次

06:05.020 --> 06:07.020
是不是匹配到它 接着往后面匹配

06:07.020 --> 06:09.020
点可以没有 可以没有

06:09.020 --> 06:13.020
然后呢 后边的数字又必须出现一次或多次

06:13.020 --> 06:15.020
对吧 如果你只有一个数字的话

06:15.020 --> 06:17.020
那么这一部分匹配不上了

06:17.020 --> 06:18.020
这个部分匹配不上了

06:18.020 --> 06:20.020
那怎么办呢 有人说这里

06:20.020 --> 06:22.020
我写个新号 写个新号

06:22.020 --> 06:24.020
它又会遇到这种情况

06:24.020 --> 06:27.020
这种情况 3.2 它也能匹配

06:27.020 --> 06:30.020
因为后边的数字可以出现零次或多次

06:30.020 --> 06:32.020
那这个东西怎么办呢 这个东西

06:32.020 --> 06:35.020
到底怎么办呢

06:35.020 --> 06:36.020
好 那么这个玩意呢

06:36.020 --> 06:39.020
我们可以这样子来处理 看着

06:39.020 --> 06:41.020
如果你这样子写

06:41.020 --> 06:44.020
如果你出现点的话

06:44.020 --> 06:46.020
那么数字呢 必须是一次或多次

06:46.020 --> 06:48.020
把它扩起来 就这一部分

06:48.020 --> 06:50.020
如果出现一个点的话

06:50.020 --> 06:53.020
你的数字呢 是可能会出现一次或多次

06:53.020 --> 06:54.020
一次或多次

06:54.020 --> 06:57.020
好 在扩号里边 把扩号当成一个整体

06:57.020 --> 06:59.020
在扩号里边呢 加上一个或者

06:59.020 --> 07:01.020
或者呢 出现

07:01.020 --> 07:03.020
写杠地

07:03.020 --> 07:05.020
写杠地

07:05.020 --> 07:08.020
不用不用不用

07:08.020 --> 07:11.020
扩起来过后面写上一个问号

07:11.020 --> 07:13.020
这样子写 你看一下

07:13.020 --> 07:16.020
也就是说后边这个点 点数字

07:16.020 --> 07:19.020
点数字 这整个这一部分出现零次

07:19.020 --> 07:22.020
或一次 可以不出现这一部分

07:22.020 --> 07:24.020
不出现这一部分 前面就全部匹配完了

07:24.020 --> 07:26.020
前面就全部匹配完了

07:26.020 --> 07:29.020
那看一下 这样子现在就不能匹配了

07:29.020 --> 07:31.020
你要么出现点 出现点的话

07:31.020 --> 07:33.020
就必须要紧跟上一些数字

07:33.020 --> 07:35.020
整个这个部分出现零次或一次

07:35.020 --> 07:37.020
就点多少

07:37.020 --> 07:41.020
就这一个部分出现零次或一次

07:41.020 --> 07:43.020
现在是不是写完了

07:43.020 --> 07:45.020
就可以匹配了

07:45.020 --> 07:47.020
好 这这一块

07:47.020 --> 07:49.020
旗席匹配一个小数

07:49.020 --> 07:51.020
必须要匹配一个小数 那就更加简单了

07:51.020 --> 07:53.020
匹配小数的话

07:53.020 --> 07:55.020
那就意味着前边一定有个数字

07:55.020 --> 07:57.020
小数点前边是不是一定有数字

07:57.020 --> 07:59.020
然后匹配一个小数点

07:59.020 --> 08:01.020
然后再匹配什么呢

08:01.020 --> 08:03.020
再匹配后边的数字 是不是就写完了

08:03.020 --> 08:05.020
对不对 就写完了

08:05.020 --> 08:07.020
这可以匹配 如果你是个整数的话

08:07.020 --> 08:09.020
是不能匹配的 那必须要写小数才行

08:11.020 --> 08:13.020
这是这一块

08:13.020 --> 08:15.020
再来 匹配一个整数

08:17.020 --> 08:19.020
哦 对 还不对

08:19.020 --> 08:21.020
匹配一个小数还要考虑复数的情况

08:21.020 --> 08:23.020
还要考虑复数的情况

08:23.020 --> 08:25.020
就是最开始可能有一个复号

08:25.020 --> 08:27.020
可能有一个复号 出现凝次或一次

08:27.020 --> 08:29.020
可以没有复号 也可以有复号

08:29.020 --> 08:31.020
你看 这样子可以匹配

08:31.020 --> 08:33.020
如果是复数的话 是不是也可以匹配

08:33.020 --> 08:35.020
对吧 这个复号出现凝次或一次

08:35.020 --> 08:37.020
好 匹配一个整数就很简单了

08:37.020 --> 08:39.020
首先是一个复号

08:39.020 --> 08:41.020
可以出现凝次或一次

08:41.020 --> 08:43.020
后面就直接写上数字就完了

08:43.020 --> 08:45.020
出现多次数字

08:45.020 --> 08:47.020
那现在这个不能匹配

08:47.020 --> 08:49.020
这样子可以匹配了

08:49.020 --> 08:51.020
没问题吧 没问题

08:51.020 --> 08:53.020
这匹配整数

08:53.020 --> 08:55.020
如果

08:55.020 --> 08:57.020
你要把这个东西

08:57.020 --> 08:59.020
也当成整数的话

08:59.020 --> 09:01.020
如果它也需要能匹配的话

09:01.020 --> 09:03.020
该怎么写呢

09:03.020 --> 09:05.020
我们可以这样子写

09:05.020 --> 09:07.020
就是这一部分出现凝次或一次

09:07.020 --> 09:09.020
也就意味着我们可以这样子写

09:09.020 --> 09:11.020
这一部分是个底儿

09:11.020 --> 09:13.020
后面跟上啥

09:13.020 --> 09:15.020
后面跟的是凝 凝出现一次或多次

09:15.020 --> 09:17.020
后面出现凝次或多次

09:17.020 --> 09:19.020
那么整个这个部分

09:19.020 --> 09:21.020
出现凝次或一次

09:21.020 --> 09:23.020
就这一个部分 掉凝凝

09:23.020 --> 09:25.020
出现凝次或一次

09:25.020 --> 09:27.020
现在这个可以匹配了

09:27.020 --> 09:29.020
那如果这里写的不是凝的

09:29.020 --> 09:31.020
如果写的一个一就不能匹配了

09:31.020 --> 09:33.020
因为我这里写的是凝出现一次或多次

09:33.020 --> 09:35.020
通过这一题练习一下

09:35.020 --> 09:37.020
练习一下正式表达式

09:37.020 --> 09:39.020
好了 我们接着来讲新知识

09:39.020 --> 09:41.020
我们现在看一下

09:41.020 --> 09:43.020
这个正式表达式在JS里写的

09:43.020 --> 09:45.020
我们之前只是讲解了

09:45.020 --> 09:47.020
如何去书写这个规则

09:47.020 --> 09:49.020
正式表达式的规则本身

09:49.020 --> 09:51.020
JS里边怎么去书写的

09:51.020 --> 09:53.020
好 我们在JS中

09:53.020 --> 09:55.020
正式表达式

09:57.020 --> 09:59.020
表现为一个对象

09:59.020 --> 10:01.020
一个对象

10:01.020 --> 10:03.020
这个对象

10:03.020 --> 10:05.020
该对象是通过

10:05.020 --> 10:07.020
勾造函数创建的

10:07.020 --> 10:09.020
通过勾造函数 哪个勾造函数呢

10:09.020 --> 10:11.020
是这个 叫做Rig

10:11.020 --> 10:13.020
Expression 这是个缩写

10:13.020 --> 10:15.020
Rigular 代表

10:15.020 --> 10:17.020
正式表达式

10:17.020 --> 10:19.020
通过这个勾造函数创建的对象

10:19.020 --> 10:21.020
好 那么这里呢

10:21.020 --> 10:23.020
我们首先说一下

10:23.020 --> 10:25.020
创建正式表达式对象

10:25.020 --> 10:27.020
创建正则对象

10:27.020 --> 10:29.020
看怎么来创建

10:29.020 --> 10:31.020
创建对象有两种方式

10:31.020 --> 10:33.020
第一种方式 正式表达式这一款

10:33.020 --> 10:35.020
它给你做了一些愚法堂

10:35.020 --> 10:37.020
让你更加方便的创建对象

10:37.020 --> 10:39.020
一种是字面量模式

10:39.020 --> 10:41.020
其实本质都是一样的

10:41.020 --> 10:43.020
本质都是通过Rig

10:43.020 --> 10:45.020
RigExpression来创建的

10:45.020 --> 10:47.020
但是写法上有两种写法

10:47.020 --> 10:49.020
一种是字面量模式

10:49.020 --> 10:51.020
第二种是勾造函数模式

10:51.020 --> 10:53.020
勾造函数模式

10:53.020 --> 10:55.020
两种方式都可以创建这个对象

10:55.020 --> 10:57.020
好 咱们来看一下

10:57.020 --> 11:03.750
这一面里面

11:03.750 --> 11:05.750
我们要创建两个正式表达式

11:05.750 --> 11:07.750
两个正式表达式

11:07.750 --> 11:09.750
第一种方式是使用字面量

11:09.750 --> 11:11.750
字面量的方式很简单的写两个写杠

11:11.750 --> 11:13.750
写杠里面写规则

11:13.750 --> 11:15.750
规则写到写杠里面

11:15.750 --> 11:17.750
这就是个正式表达式

11:17.750 --> 11:19.750
一个正式表达式就创建好了

11:19.750 --> 11:21.750
没问题吧

11:21.750 --> 11:23.750
比方这个规则我们可以这样写

11:23.750 --> 11:25.750
比方说随便找吧

11:25.750 --> 11:27.750
就把这个规则拿过来吧

11:27.750 --> 11:29.750
匹配一个整数

11:29.750 --> 11:31.750
这样就是个正式表达式

11:31.750 --> 11:33.750
当然如果你中间不写东西就是注释了

11:33.750 --> 11:35.750
两个写杠表示单上注释

11:35.750 --> 11:37.750
中间必须要写东西的

11:37.750 --> 11:39.750
这就是个正式表达式对象

11:39.750 --> 11:41.750
它这种写法跟下边这种写法

11:41.750 --> 11:43.750
是效果是一样的NewRigExpression

11:43.750 --> 11:45.750
这里面传入一个规则制服串

11:45.750 --> 11:47.750
传入一个规则制服串

11:47.750 --> 11:49.750
把这个规则当成一个制服串

11:49.750 --> 11:51.750
传进来

11:51.750 --> 11:53.750
这两种写法效果是一样的

11:53.750 --> 11:55.750
是一样的

11:55.750 --> 11:57.750
其实官方文档里边还说到了这种方式

11:57.750 --> 11:59.750
RigExpression直接调用

11:59.750 --> 12:01.750
直接调用

12:01.750 --> 12:03.750
传一个这个东西进来

12:03.750 --> 12:05.750
直接调用传进来

12:05.750 --> 12:07.750
这种方式也可以

12:07.750 --> 12:09.750
那这种方式跟这种方式

12:09.750 --> 12:11.750
有什么样的区别呢

12:11.750 --> 12:13.750
它有什么样的区别呢

12:13.750 --> 12:15.750
就一点点区别了

12:15.750 --> 12:17.750
了解一下就行了

12:17.750 --> 12:19.750
这个玩意面试体的话

12:19.750 --> 12:21.750
估计都不会问到什么区别

12:21.750 --> 12:23.750
我们来看一下吧

12:23.750 --> 12:25.750
反正要看官方文档的

12:25.750 --> 12:27.750
我们把官方文档打开

12:27.750 --> 12:29.750
Expression

12:29.750 --> 12:35.620
看一下

12:35.620 --> 12:37.620
表别很中文

12:37.620 --> 12:39.620
下边我们看一下

12:39.620 --> 12:41.620
它这里说到了

12:41.620 --> 12:43.620
这三种方式的创建都是可以的

12:43.620 --> 12:45.620
两个写杠你看

12:45.620 --> 12:47.620
这种方式

12:47.620 --> 12:49.620
和这种方式Pattern

12:49.620 --> 12:51.620
Pattern的单词也通常用来表示

12:51.620 --> 12:53.620
正的表达式的意思

12:53.620 --> 12:55.620
表正的表达式的一个

12:55.620 --> 12:57.620
符号 规则

12:57.620 --> 12:59.620
好

12:59.620 --> 13:01.620
这两种方式有什么样的区别呢

13:01.620 --> 13:03.620
我们来看一下

13:03.620 --> 13:05.620
看一下下面有说到

13:05.620 --> 13:07.620
有说到

13:09.620 --> 13:11.620
它这里面有说到吗

13:11.620 --> 13:13.620
应该有

13:13.620 --> 13:15.620
直接说吧

13:15.620 --> 13:17.620
这两种有什么样的区别呢

13:17.620 --> 13:19.620
它是这样子 如果你给的规则是一个制服创的话

13:19.620 --> 13:21.620
那没有区别 两个都是一样的

13:21.620 --> 13:23.620
新建一个正的表达式对象

13:23.620 --> 13:25.620
那如果你这里给的是这种呢

13:25.620 --> 13:27.620
给的是这种

13:27.620 --> 13:29.620
给的是这种

13:29.620 --> 13:31.620
就是你把另外一个

13:31.620 --> 13:33.620
正的表达式对象作为参数传进来

13:33.620 --> 13:35.620
这样是可以的

13:35.620 --> 13:37.620
你把另外一个

13:37.620 --> 13:39.620
正的表达式的参数传进来

13:39.620 --> 13:41.620
这个地方有一点点区别

13:41.620 --> 13:43.620
我们来看一下

13:43.620 --> 13:47.130
如果你根据另外一个正的表达式对象

13:47.130 --> 13:49.130
来创建一个新的正的表达式对象呢

13:49.130 --> 13:51.130
用这种方式

13:51.130 --> 13:53.130
会得到一个新的对象

13:53.130 --> 13:55.130
只不过规则一样

13:55.130 --> 13:57.130
只不过规则跟这个正的表达式的规则是一样的

13:57.130 --> 13:59.130
其他没有什么区别

13:59.130 --> 14:01.130
就是创建了一个新的对象

14:01.130 --> 14:03.130
因此我们在比较的时候

14:03.130 --> 14:05.130
这两个对象

14:05.130 --> 14:07.130
这两个变量里面的地址是不一样的

14:07.130 --> 14:09.130
你看一下

14:09.130 --> 14:11.130
你看 是不是不一样的

14:11.130 --> 14:13.130
这两个正的表达式对象

14:13.130 --> 14:15.130
地址是不一样的

14:15.130 --> 14:17.130
因为它是用了6新建的一个对象

14:17.130 --> 14:19.130
但是如果你用这种方式的话

14:19.130 --> 14:21.130
如果你传到一个正的表达式对象

14:21.130 --> 14:23.130
进来的话

14:23.130 --> 14:25.130
它反回的就是对象本身

14:25.130 --> 14:27.130
因此

14:27.130 --> 14:29.130
这种方式得到了2个

14:29.130 --> 14:31.130
Rig1和Rig3是一样的

14:31.130 --> 14:33.130
就这个区别

14:33.130 --> 14:35.130
其他没有什么区别

14:35.130 --> 14:37.130
平时我们也不太会用这种方式来创建

14:37.130 --> 14:39.130
也不太会用这种方式来创建

14:39.130 --> 14:41.130
如果你要用6的话

14:41.130 --> 14:43.130
我们一般就是写一个支付串

14:43.130 --> 14:45.130
这种方式

14:45.130 --> 14:47.130
这是关于创建的那种表达式

14:47.130 --> 14:49.130
那么平时我们开发的时候

14:49.130 --> 14:51.130
到底用哪一种呢

14:51.130 --> 14:53.130
我的建议是这样子

14:53.130 --> 14:55.130
如果你这个规则

14:55.130 --> 14:57.130
你是非常清楚的

14:57.130 --> 14:59.130
规则是固定的

14:59.130 --> 15:01.130
如果你的规则是固定的话

15:01.130 --> 15:03.130
那你肯定用第1种方便写

15:03.130 --> 15:05.130
直接写 多方便

15:05.130 --> 15:07.130
两个写杠 写就完事了

15:07.130 --> 15:09.130
如果你的规则不固定

15:09.130 --> 15:11.130
就是你的规则是别人给你提供的

15:11.130 --> 15:13.130
就比方说像这个网页

15:13.130 --> 15:15.130
如果这个网页是理解的

15:15.130 --> 15:17.130
你看这个规则是

15:17.130 --> 15:19.130
拥护提供的对吧

15:19.130 --> 15:21.130
是网页的使用者 就是拥护

15:21.130 --> 15:23.130
拥护给你提供的规则

15:23.130 --> 15:25.130
因此你在写单码的时候

15:25.130 --> 15:27.130
你是不知道规则是啥的

15:27.130 --> 15:29.130
你可能来自于别的地方

15:29.130 --> 15:31.130
那里没办法了

15:31.130 --> 15:33.130
因为这种协访叫做字面量

15:33.130 --> 15:35.130
你必须要直接输写

15:35.130 --> 15:37.130
可以给变量

15:37.130 --> 15:39.130
可以给变量

15:39.130 --> 15:41.130
比方说变量

15:41.130 --> 15:43.130
我写个字符创

15:43.130 --> 15:45.130
这个字符创可能来自于

15:45.130 --> 15:47.130
用户的输入对不对

15:47.130 --> 15:49.130
是用户输入的这个字符创

15:49.130 --> 15:51.130
那么就必须要用这种方式了

15:51.130 --> 15:53.130
看情况 根据情况你自己来定

15:53.130 --> 15:55.130
这是关于

15:55.130 --> 15:57.130
郑德表拉斯的创建

15:57.130 --> 15:59.130
很简单

15:59.130 --> 16:01.130
创建的时候实际上他还可以给一些东西

16:01.130 --> 16:03.130
什么东西呢

16:03.130 --> 16:05.130
就是关于标志

16:05.130 --> 16:07.130
标志叫flag

16:07.130 --> 16:09.130
我们平时说的例flag对吧

16:09.130 --> 16:11.130
就是

16:11.130 --> 16:13.130
这个怎么翻译啊

16:13.130 --> 16:15.130
怎么翻译啊

16:15.130 --> 16:17.130
就是标志

16:17.130 --> 16:19.130
这个flag呢是一个

16:19.130 --> 16:21.130
你可以认为它就是一个字符创

16:21.130 --> 16:23.130
如果你用这种方式创建的话

16:23.130 --> 16:25.130
这个flag呢就写到这后边

16:25.130 --> 16:27.130
flag有什么用呢

16:27.130 --> 16:29.130
flag呢我们目前介绍两个吧

16:29.130 --> 16:31.130
你看这里

16:31.130 --> 16:33.130
全局搜索比方说搜索到了

16:33.130 --> 16:35.130
比方说这里写简单一点

16:35.130 --> 16:37.130
abc

16:37.130 --> 16:39.130
或者是数字出现三次

16:39.130 --> 16:41.130
出现三次数字

16:41.130 --> 16:45.660
看一下啊

16:45.660 --> 16:47.660
如果是全局搜索的话

16:47.660 --> 16:49.660
你看一下

16:49.660 --> 16:51.660
是不是得到三处匹配

16:51.660 --> 16:53.660
如果我把全局搜索关掉

16:53.660 --> 16:55.660
它只能匹配一处

16:55.660 --> 16:57.660
它只能得到匹配位置零

16:57.660 --> 16:59.660
从第一个位置就匹配了对吧匹配的一处

16:59.660 --> 17:01.660
它只能得到匹配的第一个

17:01.660 --> 17:03.660
全局搜索搜索到第一个就不再搜索了

17:03.660 --> 17:05.660
全局搜索和非全局搜索

17:05.660 --> 17:07.660
全局搜索的话就要搜索全部

17:07.660 --> 17:09.660
非全局搜索的话

17:09.660 --> 17:11.660
那么只搜索第一个

17:11.660 --> 17:13.660
这就是个标志位

17:13.660 --> 17:15.660
你看一下它这里可以说到了

17:15.660 --> 17:17.660
全局搜索用什么

17:17.660 --> 17:19.660
用计

17:19.660 --> 17:21.660
它默认不是全局搜索

17:21.660 --> 17:23.660
所以说如果你希望全局搜索的话

17:23.660 --> 17:25.660
那么你这里加上一个计

17:25.660 --> 17:27.660
就这么简单

17:27.660 --> 17:29.660
就是标志位

17:29.660 --> 17:31.660
标志位

17:31.660 --> 17:33.660
完了

17:33.660 --> 17:35.660
这就是一个标志位

17:35.660 --> 17:37.660
然后比方说

17:37.660 --> 17:39.660
这里还有一个忽略大条写

17:39.660 --> 17:41.660
比方说把忽略大条写购上

17:41.660 --> 17:43.660
比方说我们访问的是

17:45.660 --> 17:47.660
访问的是ABC

17:47.660 --> 17:49.660
ABC出现三次

17:49.660 --> 17:51.660
不是ABC出现三次

17:51.660 --> 17:53.660
应该是这个匹配ABC

17:53.660 --> 17:55.660
匹配ABC

17:55.660 --> 17:57.660
匹配这个东西

17:57.660 --> 17:59.660
比方说匹配这个玩意

17:59.660 --> 18:01.660
那么我们看一下

18:01.660 --> 18:03.660
数字ABC

18:03.660 --> 18:06.970
ABC

18:06.970 --> 18:08.970
如果是全局搜索的话

18:08.970 --> 18:10.970
你看一下

18:10.970 --> 18:12.970
但是如果你这边写的大写

18:12.970 --> 18:14.970
ABC

18:14.970 --> 18:16.970
它默认是要区分大条写的

18:16.970 --> 18:18.970
如果你希望不要区分大条写的话

18:18.970 --> 18:20.970
你把这个构权上

18:20.970 --> 18:22.970
你看它就不区分大条写了

18:22.970 --> 18:24.970
就这么简单

18:24.970 --> 18:26.970
那么如何来忽略大条写

18:26.970 --> 18:28.970
它叫做I

18:28.970 --> 18:30.970
那么这个I

18:30.970 --> 18:32.970
我们就直接写到这

18:32.970 --> 18:34.970
你看两个标识的全局匹配

18:34.970 --> 18:36.970
并且忽略大条写

18:36.970 --> 18:38.970
I就是一个NOR

18:38.970 --> 18:40.970
G就是Global

18:40.970 --> 18:42.970
G就是Global

18:42.970 --> 18:44.970
I表示一个NOR

18:44.970 --> 18:46.970
K is忽略大条写

18:46.970 --> 18:48.970
那么这里写法也是一样的

18:48.970 --> 18:50.970
忽略大条写

18:50.970 --> 18:52.970
这是标志位

18:52.970 --> 18:54.970
还有一个标志位是M

18:54.970 --> 18:56.970
是多航匹配

18:56.970 --> 18:58.970
就是匹配的时候

18:58.970 --> 19:00.970
匹配的时候

19:00.970 --> 19:02.970
它这个开始

19:02.970 --> 19:04.970
我们不是有一个开始标志吗

19:04.970 --> 19:06.970
匹配开始

19:06.970 --> 19:08.970
这个开始默认情况下指的是

19:08.970 --> 19:10.970
制服创开始

19:10.970 --> 19:12.970
如果你给上这个标志服

19:12.970 --> 19:14.970
如果你给上这个标志服

19:14.970 --> 19:16.970
比方说给上这个M

19:16.970 --> 19:18.970
那么它会意味着

19:18.970 --> 19:20.970
它也能匹配什么航的开始

19:20.970 --> 19:22.970
它也能匹配航的开始

19:22.970 --> 19:24.970
这样多了表示制服创结束

19:24.970 --> 19:26.970
如果你给上这个M

19:26.970 --> 19:28.970
它表示的是航的结束

19:28.970 --> 19:30.970
它也能匹配

19:30.970 --> 19:32.970
航的结束也能匹配

19:32.970 --> 19:34.970
有这么一个意思

19:34.970 --> 19:36.970
多航匹配

19:36.970 --> 19:38.970
其他都没啥了

19:38.970 --> 19:40.970
M这里的测试工具

19:40.970 --> 19:42.970
测试工具里面它没有这个选项

19:42.970 --> 19:44.970
但是我们是可以指定的

19:44.970 --> 19:46.970
可以指定的

19:46.970 --> 19:48.970
没问题吧

19:48.970 --> 19:50.970
这是标志位

19:50.970 --> 19:52.970
两种方式都可以创建对象

19:52.970 --> 19:54.970
这是第一个

19:54.970 --> 19:56.970
如何来创建一个正载表达式对象

19:56.970 --> 19:58.970
接下来我们来看看

19:58.970 --> 20:00.970
正载表达式对象的应用

20:00.970 --> 20:02.970
正载成员

20:02.970 --> 20:04.970
正载成员

20:04.970 --> 20:06.970
正载表达式里有哪些成员

20:06.970 --> 20:08.970
成员

20:08.970 --> 20:10.970
实力成员

20:10.970 --> 20:12.970
对象里有哪些成员

20:12.970 --> 20:14.970
可以用

20:14.970 --> 20:16.970
咱们看一下这个

20:16.970 --> 20:18.970
标志服

20:18.970 --> 20:20.970
这些都跟我们没关系

20:20.970 --> 20:22.970
不用管了

20:22.970 --> 20:24.970
我们看一下成员

20:24.970 --> 20:26.970
他正面介绍了一些规则

20:26.970 --> 20:28.970
我们都讲过的规则了

20:28.970 --> 20:30.970
看一下

20:30.970 --> 20:32.970
这里边有这么一些东西

20:32.970 --> 20:34.970
一个是Global

20:34.970 --> 20:36.970
表示的是判断

20:36.970 --> 20:38.970
就是得到了一个布尔

20:38.970 --> 20:40.970
它是个属性

20:40.970 --> 20:42.970
表示的是是否Global

20:42.970 --> 20:44.970
是否开启了全局匹配

20:44.970 --> 20:46.970
有的时候你要判断

20:46.970 --> 20:48.970
全局匹配

20:48.970 --> 20:50.970
可以通过这个属性来判断

20:50.970 --> 20:52.970
比方说

20:52.970 --> 20:54.970
我们这个正载表达式

20:54.970 --> 20:56.970
Global

20:56.970 --> 20:58.970
表示开启了

20:58.970 --> 21:00.970
当然你可以设置为Force

21:00.970 --> 21:02.970
设置为Force过后再看

21:02.970 --> 21:04.970
有用吗?是没用

21:04.970 --> 21:06.970
因为这个规则

21:06.970 --> 21:08.970
是一开始有指定的

21:08.970 --> 21:10.970
设置是没有用的

21:10.970 --> 21:12.970
只能读取

21:12.970 --> 21:14.970
Global

21:14.970 --> 21:16.970
它是个指读属性

21:16.970 --> 21:18.970
你只能读取

21:18.970 --> 21:20.970
一设置是没用的

21:20.970 --> 21:22.970
这是关于Global

21:22.970 --> 21:24.970
下面这些都是一样的

21:24.970 --> 21:26.970
是否开启了忽略大条鞋

21:26.970 --> 21:28.970
是否开启了忽略大条鞋

21:30.970 --> 21:32.970
我这里都开启了

21:32.970 --> 21:34.970
是否开启了多航匹配

21:34.970 --> 21:36.970
Multi

21:36.970 --> 21:38.970
Rig1

21:38.970 --> 21:40.970
Multi9

21:40.970 --> 21:42.970
这些属性可以判断

21:42.970 --> 21:44.970
这种情况

21:44.970 --> 21:46.970
我们这里随便记一笔

21:46.970 --> 21:48.970
这些我们都用的不多

21:48.970 --> 21:50.970
用的很少

21:50.970 --> 21:52.970
了解一下就行了

21:52.970 --> 21:54.970
这些东西

21:54.970 --> 21:56.970
这些都是属性

21:56.970 --> 21:58.970
再一个

21:58.970 --> 22:00.970
Source

22:00.970 --> 22:02.970
表示的是

22:02.970 --> 22:04.970
目前的规则

22:04.970 --> 22:06.970
看一下Rig1Source

22:06.970 --> 22:08.970
你看

22:08.970 --> 22:10.970
得到规则制服串

22:10.970 --> 22:12.970
我们了解一下就行了

22:12.970 --> 22:14.970
主要是他下面两个方法

22:14.970 --> 22:16.970
这两个方法我们经常用

22:16.970 --> 22:18.970
首先我们说这个方法

22:18.970 --> 22:20.970
Test

22:20.970 --> 22:22.970
表示什么意思呢

22:22.970 --> 22:24.970
这个方法很重要

22:24.970 --> 22:26.970
方法

22:26.970 --> 22:28.970
它指的是

22:28.970 --> 22:30.970
验证某个制服串

22:30.970 --> 22:32.970
是否满足规则

22:32.970 --> 22:34.970
你不是现在有一个规则对象吗

22:34.970 --> 22:36.970
这是个规则对象

22:36.970 --> 22:38.970
那么你要去验证一下

22:38.970 --> 22:40.970
是不是满足这个规则

22:40.970 --> 22:42.970
就去验证每个作用

22:42.970 --> 22:44.970
我们怎么写呢

22:44.970 --> 22:46.970
我们这里直接输出

22:46.970 --> 22:48.970
Test

22:48.970 --> 22:50.970
测试

22:50.970 --> 22:52.970
测试某一个制服串

22:52.970 --> 22:54.970
是否满足规则

22:54.970 --> 22:56.970
我给它设置一个制服串

22:56.970 --> 22:58.970
这里比方说

22:58.970 --> 23:00.970
这里写的是一个

23:00.970 --> 23:02.970
整数的

23:02.970 --> 23:04.970
ABC看一下是否满足规则

23:04.970 --> 23:06.970
保存看一下

23:06.970 --> 23:08.970
是否满足

23:08.970 --> 23:10.970
不满足

23:10.970 --> 23:12.970
如果你写的是123

23:12.970 --> 23:14.970
2表示满足规则

23:14.970 --> 23:16.970
这就是Test

23:16.970 --> 23:18.970
只不过Test

23:18.970 --> 23:20.970
大家要注意一下

23:20.970 --> 23:22.970
在全局匹配模式下

23:22.970 --> 23:24.970
和非全局匹配模式下

23:24.970 --> 23:26.970
它是不一样的

23:26.970 --> 23:28.970
全局匹配模式下和非全局匹配模式下

23:28.970 --> 23:30.970
它是不一样的

23:30.970 --> 23:32.970
比方说

23:32.970 --> 23:34.970
现在是全局匹配

23:34.970 --> 23:36.970
我们现在多输出几次

23:36.970 --> 23:38.970
保存看一下

23:38.970 --> 23:40.970
你会发现

23:40.970 --> 23:42.970
它是to force

23:42.970 --> 23:44.970
这什么东西呢

23:44.970 --> 23:46.970
它是这样子

23:46.970 --> 23:48.970
你看着它怎么匹配的

23:48.970 --> 23:50.970
当你是全局匹配的时候

23:50.970 --> 23:52.970
它是这样的匹配的

23:52.970 --> 23:54.970
它首先来找看一下

23:54.970 --> 23:56.970
1满足规则

23:56.970 --> 23:58.970
2满足规则

23:58.970 --> 24:00.970
找到了123满足规则

24:00.970 --> 24:02.970
满足规则

24:02.970 --> 24:04.970
那么它就输出

24:04.970 --> 24:06.970
找到了满足规则的

24:06.970 --> 24:08.970
123满足规则

24:08.970 --> 24:10.970
因此输出

24:10.970 --> 24:12.970
然后

24:12.970 --> 24:14.970
后边它还要继续

24:14.970 --> 24:16.970
继续往后面匹配

24:16.970 --> 24:18.970
所以说当你下一次再匹配它的时候

24:18.970 --> 24:20.970
下一次再进行匹配的时候

24:20.970 --> 24:22.970
它会根据

24:22.970 --> 24:24.970
之前的那一次匹配

24:24.970 --> 24:26.970
结果接着往后面匹配

24:26.970 --> 24:28.970
接着往后面匹配

24:28.970 --> 24:30.970
接着往后面

24:30.970 --> 24:32.970
它就不匹配了

24:32.970 --> 24:34.970
你看我现在光标所在的位置

24:34.970 --> 24:36.970
光标所在的位置已经没东西了

24:36.970 --> 24:38.970
后面就不匹配了

24:38.970 --> 24:40.970
不匹配它就返回了Force

24:40.970 --> 24:42.970
它第二次返回了Force

24:42.970 --> 24:44.970
也就是说这个Test

24:44.970 --> 24:46.970
如果开启了全局匹配之后

24:46.970 --> 24:48.970
它会接着上一次来进行匹配

24:48.970 --> 24:50.970
当它这里匹配不了的时候

24:50.970 --> 24:52.970
它又把它复位了

24:52.970 --> 24:54.970
又从最开始开始了

24:54.970 --> 24:56.970
于是下一次匹配

24:56.970 --> 24:58.970
它又从最开始来进行匹配了

24:58.970 --> 25:00.970
这个例子看的不是很明显

25:00.970 --> 25:02.970
看的不是很明显

25:02.970 --> 25:04.970
我给大家换一个例子

25:04.970 --> 25:06.970
看的非常非常明显

25:06.970 --> 25:08.970
匹配什么匹配ABC

25:08.970 --> 25:10.970
这种我们这样子写

25:10.970 --> 25:12.970
前面随便写ABC

25:12.970 --> 25:14.970
ABC

25:14.970 --> 25:16.970
看着

25:16.970 --> 25:18.970
我们把下面改一下

25:18.970 --> 25:20.970
看一下

25:20.970 --> 25:22.970
它匹配的结果

25:22.970 --> 25:24.970
它就是匹配出来

25:24.970 --> 25:26.970
它到底是能不能匹配

25:26.970 --> 25:28.970
ForceQQ

25:28.970 --> 25:30.970
你可以预见到下一次再来的话

25:30.970 --> 25:32.970
又是Force了

25:32.970 --> 25:34.970
下一次再来又是Force了

25:34.970 --> 25:36.970
怎么回事呢

25:36.970 --> 25:38.970
它是这样的匹配的

25:38.970 --> 25:40.970
匹配什么匹配ABC

25:40.970 --> 25:42.970
全局匹配

25:42.970 --> 25:44.970
全局匹配的话

25:44.970 --> 25:46.970
匹配ABC没问题

25:46.970 --> 25:48.970
是不是匹配了

25:48.970 --> 25:50.970
这个输出Q

25:50.970 --> 25:52.970
但是

25:52.970 --> 25:54.970
它这个时候没完

25:54.970 --> 25:56.970
然后它现在知道

25:56.970 --> 25:58.970
下一次再匹配的时候

25:58.970 --> 26:00.970
要从这个位置开始了

26:00.970 --> 26:02.970
于是下一次匹配的时候

26:02.970 --> 26:04.970
它从这个位置开始

26:04.970 --> 26:06.970
不能匹配吧

26:06.970 --> 26:08.970
到这儿是不是能匹配

26:08.970 --> 26:10.970
又匹配了是不是还是Q

26:10.970 --> 26:12.970
因此它前两项输出Q

26:12.970 --> 26:14.970
前两项输出Q

26:14.970 --> 26:16.970
然后下一次

26:16.970 --> 26:18.970
它又从这里开始匹配了

26:18.970 --> 26:20.970
又从这里开始匹配了

26:20.970 --> 26:22.970
这里是不能匹配

26:22.970 --> 26:24.970
只要它匹配不到了

26:24.970 --> 26:26.970
于是它重新复位了

26:26.970 --> 26:28.970
于是下一次它又从这个开始

26:28.970 --> 26:30.970
又从地位开始

26:30.970 --> 26:32.970
又是Q又是Force

26:32.970 --> 26:34.970
又没了

26:34.970 --> 26:36.970
它是用这种模式来匹配的

26:36.970 --> 26:38.970
在全局模式下

26:38.970 --> 26:40.970
它里面提供了一个属性

26:40.970 --> 26:42.970
还可以帮助我们来理解这一点

26:42.970 --> 26:44.970
这个属性叫做

26:44.970 --> 26:46.970
NastIndex

26:46.970 --> 26:48.970
表示的是

26:48.970 --> 26:50.970
下一次匹配开始的

26:50.970 --> 26:52.970
这里

26:52.970 --> 26:54.970
我们这里

26:54.970 --> 26:56.970
在前面再输出一个东西

26:56.970 --> 26:58.970
前面输出一个

26:58.970 --> 27:00.970
RigNastIndex

27:00.970 --> 27:02.970
不能汇车

27:02.970 --> 27:04.970
汇车把后面覆盖掉了

27:04.970 --> 27:06.970
看着

27:06.970 --> 27:10.470
保存

27:10.470 --> 27:12.470
第一次匹配之前

27:12.470 --> 27:14.470
这个是先输出

27:14.470 --> 27:16.470
这个先输出

27:16.470 --> 27:18.470
第一次匹配之前

27:18.470 --> 27:20.470
它匹配的位置

27:20.470 --> 27:22.470
我再把制服创输出

27:22.470 --> 27:24.470
再把制服创输出

27:24.470 --> 27:29.190
制服创写到这

27:29.190 --> 27:31.190
这里就写S

27:31.190 --> 27:33.190
这里就写S

27:33.190 --> 27:35.190
看一下

27:35.190 --> 27:37.190
我们把制服创再输出

27:37.190 --> 27:39.190
就可以看得很清楚了

27:39.190 --> 27:41.190
看着

27:41.190 --> 27:43.190
第一次匹配的时候

27:43.190 --> 27:45.190
它知道

27:45.190 --> 27:47.190
它非常清楚

27:47.190 --> 27:49.190
我现在下一次要从什么位置开始匹配

27:49.190 --> 27:51.190
从制服创所应为0的位置

27:51.190 --> 27:53.190
从这个位置开始匹配

27:53.190 --> 27:55.190
匹配完了过后

27:55.190 --> 27:57.190
它立马就把这个数字改了

27:57.190 --> 27:59.190
你看当我下一次匹配的时候变成6了

27:59.190 --> 28:01.190
再输出

28:01.190 --> 28:03.190
改动之后的字

28:03.190 --> 28:05.190
改动之后的字再输出

28:05.190 --> 28:07.190
从这里复制

28:07.190 --> 28:09.190
复制

28:09.190 --> 28:11.190
改动之后的字

28:11.190 --> 28:13.190
从0这个位置开始匹配

28:13.190 --> 28:15.190
0,1,2都不满足条件

28:15.190 --> 28:17.190
到了ABC是不是满足了

28:17.190 --> 28:19.190
你看

28:19.190 --> 28:21.190
匹配完了之后下一个匹配位置

28:21.190 --> 28:23.190
变成6了

28:23.190 --> 28:25.190
0,1,2,3,4,5,6

28:25.190 --> 28:27.190
看没

28:27.190 --> 28:29.190
下一次就从这个地方开始了

28:29.190 --> 28:31.190
它非常清楚

28:31.190 --> 28:33.190
这就是为什么它下一次是接着上一次匹配的

28:33.190 --> 28:35.190
它是靠这个什么

28:35.190 --> 28:37.190
靠这个last index

28:37.190 --> 28:39.190
靠它来控制的

28:39.190 --> 28:41.190
它每一匹配一次

28:41.190 --> 28:43.190
它就把它往后面移动几位

28:43.190 --> 28:45.190
移动到下一个位置

28:45.190 --> 28:47.190
于是下一次是从6这个制服开始匹配的

28:47.190 --> 28:49.190
匹配到这匹配完成

28:49.190 --> 28:51.190
得到2

28:51.190 --> 28:53.190
然后下一次还有记录了

28:53.190 --> 28:55.190
又记录下一次从这个位置开始

28:55.190 --> 28:57.190
从这个位置开始匹配的时候

28:57.190 --> 28:59.190
你看没有匹配到任何东西

28:59.190 --> 29:01.190
匹配为force过后

29:01.190 --> 29:03.190
它会把它重新把它复制为0

29:03.190 --> 29:05.190
它就是这种模式

29:05.190 --> 29:07.190
没问题吧

29:07.190 --> 29:09.190
就这种模式

29:09.190 --> 29:11.190
因此我们可以利用这种模式

29:11.190 --> 29:13.190
可以利用这种模式来做一个什么样的效果呢

29:13.190 --> 29:15.190
比方说

29:15.190 --> 29:18.570
我们这里

29:18.570 --> 29:20.570
写个代码

29:20.570 --> 29:22.570
判断匹配了多少处

29:22.570 --> 29:24.570
多少处

29:24.570 --> 29:26.570
有多少处是匹配的

29:26.570 --> 29:28.570
怎么来判断

29:28.570 --> 29:30.570
嗯

29:30.570 --> 29:32.570
怎么判断了

29:32.570 --> 29:34.570
n记住一个变量

29:34.570 --> 29:36.570
n对吧

29:36.570 --> 29:38.570
n等于0表示匹配了多少处

29:38.570 --> 29:40.570
一开始匹配0处

29:40.570 --> 29:42.570
好,why我循环

29:42.570 --> 29:44.570
循环啥呢

29:44.570 --> 29:46.570
reg test

29:46.570 --> 29:48.570
reg test

29:48.570 --> 29:50.570
没问题吧

29:50.570 --> 29:52.570
去测试这个字幕算是否能匹配

29:52.570 --> 29:54.570
因为它是全具匹配嘛

29:54.570 --> 29:56.570
匹配一处过它自动往前

29:56.570 --> 29:58.570
往前进

29:58.570 --> 30:00.570
往后面移动

30:00.570 --> 30:02.570
如果它为force

30:02.570 --> 30:04.570
假的时候是不是退出循环

30:04.570 --> 30:06.570
就退出循环了

30:06.570 --> 30:08.570
为假的时候就退出循环了

30:08.570 --> 30:10.570
为真的时候是不是匹配了一处

30:10.570 --> 30:12.570
匹配了一处加1

30:13.570 --> 30:16.570
匹配了多少处呢

30:16.570 --> 30:18.570
n次

30:18.570 --> 30:20.570
匹配了n次

30:20.570 --> 30:24.970
好,看一下吧

30:24.970 --> 30:26.970
匹配了两次,你看没

30:26.970 --> 30:28.970
我就可以用这种方式来得到它匹配了几次

30:28.970 --> 30:30.970
没问题吧

30:30.970 --> 30:32.970
这是利用它这个特点

30:32.970 --> 30:34.970
当然了,如果

30:34.970 --> 30:36.970
你没有开启全具匹配

30:36.970 --> 30:38.970
那一切都不一样了

30:38.970 --> 30:40.970
如果你没有开启全具匹配的话

30:40.970 --> 30:42.970
我们来看一下

30:42.970 --> 30:44.970
全是你,它不会移动的

30:44.970 --> 30:46.970
每一次都是从最开始来进行匹配

30:46.970 --> 30:48.970
每一次都是从最开始来进行匹配

30:48.970 --> 30:50.970
每一次都是从最开始来进行匹配

30:50.970 --> 30:52.970
我们刚才说的前提条件

30:52.970 --> 30:54.970
是开启了全具匹配

30:54.970 --> 30:56.970
在全具匹配的时候

30:56.970 --> 30:58.970
你甚至还可以这样做

30:58.970 --> 31:00.970
你手动的更改这个垃圾index

31:00.970 --> 31:02.970
手动的更改

31:02.970 --> 31:04.970
可以的

31:04.970 --> 31:06.970
保存力看一下

31:06.970 --> 31:08.970
看前两次匹配

31:08.970 --> 31:10.970
你看前两次匹配是不是都是从0开始

31:10.970 --> 31:12.970
因为我手动更改了

31:12.970 --> 31:14.970
这个是可以手动更改的

31:14.970 --> 31:16.970
更改它的匹配位置

31:16.970 --> 31:18.970
好了,这是关于

31:18.970 --> 31:20.970
Test这个函数

31:20.970 --> 31:22.970
它是在做什么事情呢

31:22.970 --> 31:24.970
它是来判断

31:24.970 --> 31:26.970
一个制服创是否匹配

31:26.970 --> 31:28.970
并且在全具匹配的模式下面

31:28.970 --> 31:30.970
它会导致

31:30.970 --> 31:32.970
每一次匹配

31:32.970 --> 31:34.970
往后边移动

31:34.970 --> 31:36.970
导致下一次匹配

31:36.970 --> 31:38.970
会影响下一次匹配

31:38.970 --> 31:40.970
我们位置开始

31:40.970 --> 31:42.970
这是关于这个

31:42.970 --> 31:44.970
另外一个我要说的是什么呢

31:44.970 --> 31:46.970
是说的是那个

31:46.970 --> 31:48.970
就是关于匹配的

31:48.970 --> 31:50.970
方式,比方说

31:50.970 --> 31:52.970
我说这个东西

31:52.970 --> 31:54.970
一个写干W

31:54.970 --> 31:56.970
一个数字

31:56.970 --> 31:58.970
出现一次或多次

31:58.970 --> 32:06.820
看着

32:06.820 --> 32:08.820
一个数字出现一次或多次

32:08.820 --> 32:10.820
那么现在是有起义的

32:10.820 --> 32:12.820
现在是有起义的

32:12.820 --> 32:14.820
什么叫什么起义呢

32:14.820 --> 32:16.820
就是说呢

32:16.820 --> 32:18.820
它这里输出的时候

32:18.820 --> 32:20.820
就匹配的时候,它到底是咋匹配的

32:20.820 --> 32:22.820
匹配在哪一部分

32:22.820 --> 32:24.820
它可能是匹配在1234

32:24.820 --> 32:26.820
对吧,1234是不是能匹配这个东西

32:26.820 --> 32:28.820
也可以匹配1

32:28.820 --> 32:30.820
1是不是也是一次或多次

32:30.820 --> 32:32.820
对吧,它是咋匹配的呢

32:32.820 --> 32:34.820
咱们来把它的输出看一下,你就明白了

32:34.820 --> 32:36.820
把它输出看一下,保存

32:36.820 --> 32:38.820
你看输出,它第一次匹配完了

32:38.820 --> 32:40.820
它的移动到哪了

32:40.820 --> 32:42.820
第一次的这个位置,自己移动到这了

32:42.820 --> 32:44.820
说明它匹配的是啥

32:44.820 --> 32:46.820
匹配的是1234,这叫做贪婪匹配模式

32:48.820 --> 32:50.820
这叫做

32:52.820 --> 32:54.820
账者

32:54.820 --> 32:56.820
账者表达是

32:56.820 --> 32:58.820
默认情况下

32:58.820 --> 33:00.820
使用贪婪模式

33:00.820 --> 33:02.820
什么叫贪婪,我尽可能多一点

33:02.820 --> 33:04.820
多一点

33:04.820 --> 33:06.820
就是贪婪模式,我能多匹配我就不少匹配

33:06.820 --> 33:08.820
就是贪婪模式

33:08.820 --> 33:10.820
每一次匹配的是尽可能多

33:10.820 --> 33:12.820
你看这个1234也是

33:12.820 --> 33:14.820
从这个位置开始匹配

33:14.820 --> 33:16.820
这个不行,后面是1234可以匹配的

33:16.820 --> 33:18.820
那么就移动到了这个位置

33:18.820 --> 33:20.820
下表为实了

33:20.820 --> 33:22.820
它尽可能多,就是贪婪模式

33:22.820 --> 33:24.820
能不能改呢,是可以改的

33:24.820 --> 33:26.820
这种模式可以改的

33:26.820 --> 33:28.820
怎么改呢,非常简单

33:28.820 --> 33:30.820
你像这种

33:30.820 --> 33:32.820
在量尺后边

33:32.820 --> 33:34.820
加上一个问号

33:34.820 --> 33:36.820
这个问号的意思不一样了

33:36.820 --> 33:38.820
直接把问号作为量尺的话

33:38.820 --> 33:40.820
是零次或一次

33:40.820 --> 33:42.820
如果你在量尺后边

33:42.820 --> 33:44.820
加上一个问号的话

33:44.820 --> 33:46.820
它表示非贪婪模式

33:46.820 --> 33:48.820
表示匹配的是非贪婪模式

33:48.820 --> 33:50.820
保存看一下结果

33:50.820 --> 33:52.820
你看一下,它变成了非贪婪模式的

33:52.820 --> 33:54.820
它每次尽可能少得匹配

33:54.820 --> 33:56.820
零,一,对吧

33:56.820 --> 33:58.820
到这个位置

33:58.820 --> 34:00.820
再一次匹配二,再一次匹配三

34:00.820 --> 34:02.820
再一次匹配四

34:02.820 --> 34:04.820
再一次匹配这个一

34:04.820 --> 34:06.820
变成了匹配这个二,看到没

34:06.820 --> 34:08.820
它变成了非贪婪模式了

34:08.820 --> 34:10.820
也就是说,我们这里记一笔

34:10.820 --> 34:12.820
在量尺后

34:12.820 --> 34:14.820
加上问号

34:14.820 --> 34:16.820
注意,一定是在量尺后边

34:16.820 --> 34:18.820
你不能直接,什么位置加问号

34:18.820 --> 34:20.820
你认为都是这样的规则,不是的

34:20.820 --> 34:22.820
因为贪婪是什么,只得是量尺

34:22.820 --> 34:24.820
量尺是不一定的

34:24.820 --> 34:26.820
就是有一些可变化的长度

34:26.820 --> 34:28.820
是不一定的,所以才会有贪婪

34:28.820 --> 34:30.820
那你在量尺后边加上问号

34:30.820 --> 34:32.820
表示

34:32.820 --> 34:34.820
非贪婪模式

34:34.820 --> 34:38.140
非贪婪模式

34:38.140 --> 34:40.140
贪婪的反应是啥

34:40.140 --> 34:42.140
贪婪的反应是

34:42.140 --> 34:44.140
还真想不到,它叫做

34:44.140 --> 34:46.140
非贪婪模式

34:46.140 --> 34:48.140
OK,这是关于TES,这个函数

34:48.140 --> 34:50.140
好,另外一个

34:50.140 --> 34:52.140
另外一个函数呢,叫做

34:52.140 --> 34:54.140
这个

34:54.140 --> 34:56.140
XQ型

34:56.140 --> 34:58.140
XQ型,它是个缩写

34:58.140 --> 35:00.140
叫做

35:00.140 --> 35:02.140
Xx

35:02.140 --> 35:04.140
在缩写的时候,我们读做

35:04.140 --> 35:06.140
Xx

35:06.140 --> 35:08.140
但是呢,它的全型叫做

35:08.140 --> 35:10.140
XQ,表示直行

35:10.140 --> 35:12.140
它是什么意思呢

35:12.140 --> 35:14.140
它指的是,直行

35:14.140 --> 35:16.140
是什么意思呢

35:16.140 --> 35:18.140
它会告诉你匹配的结果

35:18.140 --> 35:20.140
它会告诉你

35:20.140 --> 35:22.140
匹配的结果

35:22.140 --> 35:24.140
咱们再看一下吧,看一下就明白了

35:24.140 --> 35:26.140
直行匹配

35:26.140 --> 35:28.140
得到匹配结果

35:28.140 --> 35:30.140
得到匹配结果,看一下就明白了

35:30.140 --> 35:32.140
咱们呢,我们在这里呢

35:32.140 --> 35:34.140
换一个吧

35:34.140 --> 35:36.140
TES2,还是这个玩意儿

35:36.140 --> 35:38.140
还是这个玩意儿

35:38.140 --> 35:40.140
咱们呢,我们就不加问号了

35:40.140 --> 35:42.140
不加问号,我们这里输出啥呢

35:42.140 --> 35:44.140
输出的是这个

35:44.140 --> 35:46.140
直接输出

35:46.140 --> 35:48.140
RIG

35:48.140 --> 35:50.140
XQ

35:50.140 --> 35:52.140
这里呢,写上S

35:52.140 --> 35:54.140
直接输出这个玩意儿

35:54.140 --> 35:56.140
看一下

35:56.140 --> 36:01.050
你看它每次输出啥

36:01.050 --> 36:03.050
这个没啥问题

36:03.050 --> 36:05.050
输出的是一个数组

36:05.050 --> 36:07.050
这是数组吗?

36:07.050 --> 36:09.050
这是真数组还是伪数组

36:09.050 --> 36:11.050
你看一下,是真数组还是伪数组

36:11.050 --> 36:13.050
它是个真数组

36:13.050 --> 36:15.050
Sorry,它是个真数组

36:15.050 --> 36:17.050
因为好像是伪数组

36:17.050 --> 36:19.050
因为它有下标嘛

36:19.050 --> 36:21.050
它有nose,还有一些乱七八糟的属性

36:21.050 --> 36:23.050
好像是一个伪数组

36:23.050 --> 36:25.050
实际上它是一个真数组

36:25.050 --> 36:27.050
为什么,怎么来判定呢

36:27.050 --> 36:29.050
其实你可以这样的判定

36:29.050 --> 36:31.050
你判定啥呢

36:31.050 --> 36:33.050
判定这个耳锐

36:33.050 --> 36:35.050
我们之前说过的耳锐里面有个净态

36:35.050 --> 36:37.050
净态方法,意识耳锐

36:37.050 --> 36:39.050
是不是一个真数组

36:39.050 --> 36:41.050
你把这个东西扔进去,看它是不是一个真数组

36:41.050 --> 36:43.050
你看一下

36:43.050 --> 36:45.050
看一下是不是个真数组

36:45.050 --> 36:47.050
得到的结果是不是true

36:47.050 --> 36:49.050
它确实是一个真数组

36:49.050 --> 36:51.050
只不过,它做了一点手脚

36:51.050 --> 36:53.050
在这个数组里面加了一些属性

36:53.050 --> 36:55.050
那有些人就觉得很奇怪

36:55.050 --> 36:57.050
干嘛用数组这种结构呢

36:57.050 --> 36:59.050
干嘛要去用数组这种结构呢

36:59.050 --> 37:01.050
直接匹配不行吗

37:01.050 --> 37:03.050
直接匹配不行吗

37:03.050 --> 37:05.050
我们写两个嘛

37:05.050 --> 37:07.050
直接返回对象不行吗

37:07.050 --> 37:09.050
用数组是什么意思呢

37:09.050 --> 37:11.050
咱们来看一下数组里面有哪些东西

37:11.050 --> 37:13.050
目前先不管它为什么不用对象

37:13.050 --> 37:15.050
我们之后呢,遇到一个情况就知道了

37:15.050 --> 37:17.050
要讲到进阶部份你才明白

37:17.050 --> 37:19.050
它为什么要用数组

37:19.050 --> 37:21.050
它为什么没有用对象

37:21.050 --> 37:23.050
好,先看一下这个结构吧

37:23.050 --> 37:25.050
这里面表示什么意思

37:25.050 --> 37:27.050
这个结构的结构

37:27.050 --> 37:29.050
把它放到数组的第1项

37:29.050 --> 37:31.050
表示匹配结构

37:31.050 --> 37:33.050
没问题吧,匹配到了

37:33.050 --> 37:35.050
它就返回一个数组

37:35.050 --> 37:37.050
返回一个数组吧,匹配到了结构

37:37.050 --> 37:39.050
放到数组的第1项

37:39.050 --> 37:41.050
因此我们可以从数组的第1项

37:41.050 --> 37:43.050
拿到这个匹配结构

37:43.050 --> 37:45.050
后边这个group,我们现在不管

37:45.050 --> 37:47.050
这个因这个是什么意思呢

37:47.050 --> 37:49.050
这个因这个表示的是

37:49.050 --> 37:51.050
这一次匹配

37:51.050 --> 37:53.050
我是从哪个位置开始匹配的

37:53.050 --> 37:55.050
从哪个位置,从下表为0的这个位置

37:55.050 --> 37:57.050
开始匹配的

37:57.050 --> 37:59.050
匹配到这个东西

37:59.050 --> 38:01.050
好,这个input

38:01.050 --> 38:03.050
这个不用输出了

38:03.050 --> 38:05.050
s不用输出了

38:05.050 --> 38:07.050
好,第1是匹配

38:07.050 --> 38:09.050
这个input表示

38:09.050 --> 38:11.050
匹配的制服串,它去验证的制服串

38:11.050 --> 38:13.050
整个制服串拿过来了

38:13.050 --> 38:15.050
没问题吧,就这么一些属性

38:15.050 --> 38:17.050
没有啥属性了

38:17.050 --> 38:19.050
我们可以通过这个方法

38:19.050 --> 38:21.050
就得到它每一次匹配的结果

38:21.050 --> 38:23.050
从哪个位置开始匹配的也得到了

38:23.050 --> 38:25.050
好,下面这个

38:25.050 --> 38:27.050
你看,第2次匹配的结果

38:27.050 --> 38:29.050
就得到了

38:29.050 --> 38:31.050
第二次匹配的结果拿到了

38:31.050 --> 38:33.050
然后呢

38:33.050 --> 38:35.050
匹配的下标是从7开始的

38:35.050 --> 38:37.050
也从这个位置开始的

38:37.050 --> 38:39.050
匹配的下标

38:39.050 --> 38:41.050
这个是匹配的下标

38:41.050 --> 38:43.050
匹配的下标就是

38:43.050 --> 38:45.050
这个制服串在原来的这个制服串中

38:45.050 --> 38:47.050
出现了下标,就这么个意思

38:47.050 --> 38:49.050
就是匹配的制服串

38:49.050 --> 38:51.050
在整个制服串里面出现了下标

38:51.050 --> 38:53.050
这么个意思

38:53.050 --> 38:55.050
匹配的下标

38:55.050 --> 38:57.050
没有这个意思吧,刚才说的好像有点问题

38:57.050 --> 38:59.050
我说是从哪个位置开始匹配的,不太对

38:59.050 --> 39:01.050
应该说是匹配到的制服串

39:01.050 --> 39:03.050
是在原始制服串里面

39:03.050 --> 39:05.050
它的下标位置是从哪个下标开始的

39:05.050 --> 39:07.050
从这个下标开始的

39:07.050 --> 39:09.050
这就是

39:09.050 --> 39:11.050
每一次匹配得到了对象

39:11.050 --> 39:13.050
当然了,这个东西它也会受到

39:13.050 --> 39:15.050
nast index的影响

39:15.050 --> 39:17.050
比方说,我在匹配之前

39:17.050 --> 39:19.050
nast index这个时候,设为0

39:19.050 --> 39:21.050
设为0

39:21.050 --> 39:23.050
保存,你看一下

39:23.050 --> 39:25.050
你看一下

39:25.050 --> 39:27.050
那是不是每一次,第二次匹配也跟第四次是一样的

39:27.050 --> 39:29.050
对吧,是一样的

39:29.050 --> 39:31.050
它也会受到这个属性的影响

39:31.050 --> 39:33.050
好吧,那如果没有匹配到了

39:33.050 --> 39:35.050
比方说,我们再一匹配

39:35.050 --> 39:37.050
再一匹配,是不是没有匹配到了

39:37.050 --> 39:39.050
匹配不到,返回闹

39:39.050 --> 39:41.050
返回闹

39:41.050 --> 39:43.050
这就是这个函数的意思

39:43.050 --> 39:45.050
匹配不到,返回闹

39:45.050 --> 39:47.050
那如果是非权匹配

39:47.050 --> 39:49.050
看一下

39:49.050 --> 39:51.050
如果得到了是非权匹配,会怎么样了

39:51.050 --> 39:53.050
看着

39:53.050 --> 39:55.050
非权匹配,每一次都是一样的

39:55.050 --> 39:57.050
每一次都是一样的

39:57.050 --> 39:59.050
跟那个test是一样的

39:59.050 --> 40:01.050
只是这个东西可以得到结果

40:01.050 --> 40:03.050
没问题吧,应该没问题吧

40:03.050 --> 40:05.050
好了,那么接下来

40:05.050 --> 40:07.050
我们来做一个练习

40:07.050 --> 40:09.050
就比方说权匹配

40:09.050 --> 40:11.050
我们要得到

40:11.050 --> 40:14.420
所有的匹配

40:14.420 --> 40:16.420
所有的匹配结果

40:16.420 --> 40:18.420
和位置

40:18.420 --> 40:20.420
和位置,字幕刷的位置

40:20.420 --> 40:22.420
好,那么这里怎么写呢

40:22.420 --> 40:24.420
得到所有的匹配结果和位置

40:24.420 --> 40:26.420
看着,我们写个

40:26.420 --> 40:28.420
Rig

40:28.420 --> 40:30.420
xqt

40:30.420 --> 40:32.420
xqt s

40:32.420 --> 40:34.420
好,然后我们看着这样的写

40:34.420 --> 40:36.420
这样的写

40:36.420 --> 40:38.420
我们先写一个大家容易理解的吧

40:38.420 --> 40:40.420
我先写一个大家容易理解的

40:40.420 --> 40:42.420
然后我再写这个

40:42.420 --> 40:44.420
好,订一个变量

40:44.420 --> 40:46.420
这是个匹配结果

40:46.420 --> 40:48.420
来,匹配

40:48.420 --> 40:50.420
得到匹配结果

40:50.420 --> 40:52.420
什么情况下就不要再匹配了

40:52.420 --> 40:54.420
什么情况下,就是results

40:54.420 --> 40:56.420
等于now的时候

40:56.420 --> 40:58.420
没东西嘛,对不对

40:58.420 --> 41:00.420
或者说呢,这个results

41:00.420 --> 41:02.420
它不存在,对吧

41:02.420 --> 41:04.420
now是不是panning with force

41:04.420 --> 41:06.420
加上个感叹号是不是panning with true

41:06.420 --> 41:08.420
如果不存在的话,break

41:08.420 --> 41:10.420
结束循环,没问题吧

41:10.420 --> 41:12.420
好,接下来

41:12.420 --> 41:14.420
如果反向得知

41:14.420 --> 41:16.420
s22行

41:16.420 --> 41:18.420
22行,是不是一定匹配了

41:18.420 --> 41:20.420
一定匹配了,还没结束嘛

41:20.420 --> 41:22.420
它一定匹配了,匹配怎么办呢

41:22.420 --> 41:24.420
我们输出

41:24.420 --> 41:26.420
输出

41:26.420 --> 41:28.420
匹配

41:28.420 --> 41:30.420
结果,匹配结果是啥呢

41:30.420 --> 41:32.420
匹配结果就是results

41:32.420 --> 41:34.420
是不是连下标为你

41:34.420 --> 41:36.420
这个位置就匹配结果

41:36.420 --> 41:38.420
然后呢,位置

41:38.420 --> 41:40.420
匹配的位置

41:40.420 --> 41:42.420
出现位置

41:42.420 --> 41:44.420
出现在字幕圈里面的位置

41:44.420 --> 41:46.420
是什么呢

41:46.420 --> 41:48.420
就是results的index

41:48.420 --> 41:50.420
输出不就是个对象嘛

41:50.420 --> 41:52.420
它里面也有这些属效

41:52.420 --> 41:54.420
好吧,你看就写完了

41:54.420 --> 41:56.420
来看一下,我们就可以做出这个网页

41:56.420 --> 41:58.420
类似的效果,你看

41:58.420 --> 42:00.420
以后呢,我们学到页面过后

42:00.420 --> 42:02.420
这个效果非常容易做出来

42:02.420 --> 42:04.420
它只不过显示到页面的

42:04.420 --> 42:06.420
我只不过显示到控制台的

42:06.420 --> 42:08.420
所以可以匹配了

42:08.420 --> 42:10.420
对不对,没问题吧

42:10.420 --> 42:12.420
OK,甚至我还可以得到匹配的几次

42:12.420 --> 42:14.420
对吧,得到匹配的几次

42:14.420 --> 42:16.420
都可以

42:16.420 --> 42:18.420
你看,匹配出来了

42:18.420 --> 42:20.420
好,这是

42:20.420 --> 42:22.420
这种协法

42:22.420 --> 42:24.420
那么这种协法可以换一种协法

42:24.420 --> 42:26.420
看着,可以换一种协法

42:26.420 --> 42:33.160
我们这样子写

42:33.160 --> 42:35.160
你看,仍然可以

42:35.160 --> 42:37.160
甚至我不定这个变量

42:37.160 --> 42:39.160
都可以

42:39.160 --> 42:41.160
没问题

42:41.160 --> 42:43.160
怎么来理解,定应这个变量

42:43.160 --> 42:45.160
然后呢,这是个表达式嘛

42:45.160 --> 42:47.160
把它的值付给它

42:47.160 --> 42:49.160
那么整个表达式

42:49.160 --> 42:51.160
整个表达式返回啥

42:51.160 --> 42:53.160
就返回它的值

42:53.160 --> 42:55.160
那就判断的是啥

42:55.160 --> 42:57.160
判断的是这个东西有值

42:57.160 --> 42:59.160
有值它就不为force

42:59.160 --> 43:01.160
输主它是对象,对象是不可能为force的

43:01.160 --> 43:03.160
除非它没有值,除非它是low

43:03.160 --> 43:05.160
或者是undefend

43:05.160 --> 43:07.160
那么有值

43:07.160 --> 43:09.160
它有值说明匹配到了结果

43:09.160 --> 43:11.160
你看这句话

43:11.160 --> 43:13.160
既完成了复制

43:13.160 --> 43:15.160
复制之后,又当成了条件来进行判断

43:15.160 --> 43:17.160
如果有值的话,输出结果

43:17.160 --> 43:19.160
反而言之,如果这个

43:19.160 --> 43:21.160
复制完了过后,没有值就退出循环

43:21.160 --> 43:23.160
这是条件嘛

43:23.160 --> 43:25.160
为什么连这句话都可以不写呢

43:25.160 --> 43:27.160
因为我们之前说过,这个变量可以

43:27.160 --> 43:29.160
定义变量的时候,可以不写挖

43:29.160 --> 43:31.160
可以不写挖,不写挖的话

43:31.160 --> 43:33.160
它就表示的是

43:33.160 --> 43:35.160
附着在undefend对象上面

43:35.160 --> 43:37.160
权绝对象的属性负责

43:37.160 --> 43:39.160
相当于是这句话,就这样写的

43:39.160 --> 43:41.160
温柔点

43:41.160 --> 43:43.160
就这个意思

43:43.160 --> 43:45.160
但是你这里不能写挖

43:45.160 --> 43:47.160
你这里是不能写挖的

43:47.160 --> 43:49.160
这里写挖的语法都错了

43:49.160 --> 43:51.160
因为定义的语句是不能放到这里的

43:51.160 --> 43:53.160
是不能放到这个表达式里面的

43:53.160 --> 43:55.160
定义语句,它是语句

43:55.160 --> 43:57.160
它不是一个正常的表达式

43:57.160 --> 43:59.160
只有复制才是表达式

43:59.160 --> 44:01.160
因为挖,它不是一个运算符嘛

44:01.160 --> 44:03.160
我们之前说表达式是什么

44:03.160 --> 44:05.160
做数和操作符的结合

44:05.160 --> 44:07.160
它不是运算符,你不能这样写

44:07.160 --> 44:09.160
好吧

44:09.160 --> 44:11.160
这样写没问题,这是匹配

44:11.160 --> 44:13.160
得到匹配结果

44:13.160 --> 44:15.160
这是关于这个

44:15.160 --> 44:17.160
正载表达式对象里面的

44:17.160 --> 44:19.160
两个实力方法,这两个方法

44:19.160 --> 44:21.160
非常非常重要,它能够拿到匹配结果

44:21.160 --> 44:23.160
好,除了讲这个之外

44:23.160 --> 44:25.160
我们还要讲一讲

44:25.160 --> 44:27.160
回过头去

44:27.160 --> 44:29.160
讲一讲制符创中

44:29.160 --> 44:31.160
制符创对象中的

44:31.160 --> 44:33.160
正载

44:33.160 --> 44:35.160
什么意思呢

44:35.160 --> 44:37.160
就是说

44:37.160 --> 44:39.160
我们的以前之前不是讲过

44:39.160 --> 44:41.160
制符创吗,对吧

44:41.160 --> 44:43.160
原始内容包装器里面,我们讲过制符创

44:43.160 --> 44:45.160
制符创里面当时有一些

44:45.160 --> 44:47.160
方法,我们当时是没有讲的

44:47.160 --> 44:49.160
因为我当时说,它跟

44:49.160 --> 44:51.160
正载表达式相关

44:51.160 --> 44:53.160
现在我们学了这种表达式了

44:53.160 --> 44:55.160
就可以看一下制符创对象中的

44:55.160 --> 44:57.160
这些正载方法

44:57.160 --> 44:59.160
这里面说几个

44:59.160 --> 45:03.690
制符创打开

45:03.690 --> 45:07.770
SDN,打开

45:07.770 --> 45:09.770
看一下制符创里面

45:09.770 --> 45:11.770
有哪些跟正载相关的方法

45:11.770 --> 45:13.770
一个个看

45:13.770 --> 45:15.770
第一个march

45:15.770 --> 45:17.770
我喝喝水,喝喝水,嗓子有点干了

45:19.770 --> 45:21.770
第一个march

45:21.770 --> 45:23.770
march什么意思呢,其实就是匹配的意思

45:23.770 --> 45:25.770
匹配一个正载表达式

45:25.770 --> 45:27.770
得到结果

45:27.770 --> 45:29.770
你看我们之前是把

45:29.770 --> 45:31.770
正载表达式拿去跟

45:31.770 --> 45:33.770
制符创匹配,对吧

45:33.770 --> 45:35.770
其实也可以反过来,反过来是一样的

45:35.770 --> 45:37.770
就是把制符创拿去跟

45:37.770 --> 45:39.770
正载表达式来匹配,是一样的

45:39.770 --> 45:41.770
我们来看一下吧

45:41.770 --> 45:43.770
我们反过来

45:43.770 --> 45:45.770
smarch

45:45.770 --> 45:47.770
正载表达式

45:47.770 --> 45:49.770
传进去,当然也可以直接把正载表达式写进来

45:49.770 --> 45:51.770
直接写到这,也可以

45:51.770 --> 45:53.770
对吧,也可以

45:53.770 --> 45:55.770
然后来得到一个匹配结果

45:55.770 --> 45:57.770
看一下这个结果是个啥

45:57.770 --> 45:59.770
看一下是个啥吧

46:00.770 --> 46:02.770
好,运行出来

46:02.770 --> 46:04.770
就这些东西,你不用去背

46:04.770 --> 46:06.770
你不用去背

46:06.770 --> 46:08.770
你只需要去把打印出来,一看就明白了

46:08.770 --> 46:10.770
看这东西能看不懂吗

46:11.770 --> 46:13.770
没问题吧,应该看得懂吧

46:13.770 --> 46:15.770
把制符创来输出,你看一下

46:15.770 --> 46:17.770
能看懂吗

46:17.770 --> 46:19.770
匹配这个制符创

46:19.770 --> 46:21.770
用这个制符创去匹配

46:21.770 --> 46:23.770
匹配啥呢,匹配这个正载表达式

46:23.770 --> 46:25.770
它是全具匹配,于是匹配出来多个

46:25.770 --> 46:27.770
看没有,匹配出来多个

46:27.770 --> 46:29.770
这两项都是匹配结果

46:29.770 --> 46:31.770
你看我们这个网页里面,是不是

46:31.770 --> 46:33.770
它就是这样做的,对吧

46:33.770 --> 46:35.770
你可以想象得到,这个网页里面的操作方式

46:35.770 --> 46:37.770
就是得到这个结果,把它显示到网页上

46:37.770 --> 46:39.770
就完事了,对不对

46:39.770 --> 46:41.770
没问题吧,这是

46:41.770 --> 46:43.770
得到它的匹配结果

46:43.770 --> 46:45.770
那如果不是全具匹配的话

46:45.770 --> 46:47.770
如果不是全具匹配的话

46:47.770 --> 46:49.770
它得到的是单个输出

46:49.770 --> 46:51.770
因为不是全具匹配,它只匹配一次

46:51.770 --> 46:53.770
这个匹配一次的话,就类似于啥呢

46:53.770 --> 46:55.770
就类似于我们之前那个excus了

46:55.770 --> 46:57.770
就是正载表达式里面

46:57.770 --> 46:59.770
exec这个方法

46:59.770 --> 47:01.770
它匹配出来就是这个样子

47:01.770 --> 47:03.770
出来一样的,对吧,一样的

47:03.770 --> 47:05.770
没问题吧,ok

47:05.770 --> 47:07.770
这就是这个函数,它是可以

47:07.770 --> 47:09.770
进行匹配的

47:09.770 --> 47:11.770
好,下一个

47:11.770 --> 47:13.770
下一个search

47:13.770 --> 47:15.770
search

47:15.770 --> 47:17.770
表示的是,与正载表达式

47:17.770 --> 47:19.770
进行匹配

47:19.770 --> 47:23.770
得到第一个出现的匹配项的下标

47:23.770 --> 47:25.770
得到匹配项的下标

47:25.770 --> 47:27.770
咱们来看一下

47:27.770 --> 47:29.770
我们把它换成

47:29.770 --> 47:34.550
换成另外一个

47:34.550 --> 47:36.550
换一下

47:36.550 --> 47:38.550
把它换成search

47:38.550 --> 47:40.550
还是给一个正载表达式

47:40.550 --> 47:42.550
它是在这个制服串里面去搜索

47:42.550 --> 47:44.550
搜索满足条件的

47:44.550 --> 47:46.550
第一个的下标,咱们来看一下

47:46.550 --> 47:48.550
保存

47:48.550 --> 47:50.550
看一下,0,对吧

47:50.550 --> 47:52.550
0这个下标是不是匹配的

47:52.550 --> 47:54.550
那如果我们现在开启全具呢

47:54.550 --> 47:56.550
开启全具会怎么样呢

47:56.550 --> 47:58.550
保存,你看还是得到了0

47:58.550 --> 48:00.550
看到没,还是得到了0

48:00.550 --> 48:02.550
说明这一次匹配的匹配的是这个东西

48:02.550 --> 48:04.550
还是得到了0

48:04.550 --> 48:06.550
那如果我们运行两次呢

48:06.550 --> 48:08.550
如果运行两次,开启全具匹配

48:08.550 --> 48:10.550
运行两次,你看一下

48:10.550 --> 48:12.550
还是得到了0

48:12.550 --> 48:14.550
它始终得到的是第一次,整个制服串

48:14.550 --> 48:16.550
第一次匹配的下标

48:16.550 --> 48:18.550
这是search

48:18.550 --> 48:20.550
很简单,非常简单

48:20.550 --> 48:22.550
好,下一个

48:22.550 --> 48:24.550
分割制服串

48:24.550 --> 48:26.550
分割制服串的第一个

48:26.550 --> 48:28.550
就是它的参数

48:28.550 --> 48:30.550
它的参数我们之前说过

48:30.550 --> 48:32.550
可以用一个制服来分割制服串

48:32.550 --> 48:34.550
那么这个地方呢,其实是可以写

48:34.550 --> 48:36.550
证则表达式的

48:36.550 --> 48:38.550
可以给一个证则表达式对象

48:38.550 --> 48:41.990
好,咱们来看一下

48:41.990 --> 48:43.990
还是这个制服串,我们写到上面吧

48:43.990 --> 48:45.990
还是这个制服串,我们来得到结果

48:45.990 --> 48:47.990
s,split,分割

48:47.990 --> 48:49.990
我们按什么分割呢,比方说

48:49.990 --> 48:51.990
我们这里

48:52.990 --> 48:54.990
空格

48:54.990 --> 48:56.990
然后呢,或者是

48:56.990 --> 48:58.990
横杠

48:58.990 --> 49:00.990
或者是

49:00.990 --> 49:02.990
制表服

49:02.990 --> 49:04.990
有些同学说,制表服能不能这样打

49:04.990 --> 49:06.990
等一下

49:06.990 --> 49:08.990
哎呦,我的天哪

49:08.990 --> 49:10.990
我再打一个吧,打一个夫子过来

49:10.990 --> 49:12.990
能不能这样子写呢,制表服

49:12.990 --> 49:14.990
能不能这样子写呢

49:14.990 --> 49:16.990
本来是可以的

49:16.990 --> 49:17.990
本来是可以的

49:17.990 --> 49:19.990
但是在VSCode的这个编辑器里边

49:19.990 --> 49:21.990
它有这么一个东西

49:21.990 --> 49:23.990
它会自动的把你

49:23.990 --> 49:25.990
键盘上的制表服

49:25.990 --> 49:27.990
这个Type按键

49:27.990 --> 49:29.990
会自动给你转换成空格

49:29.990 --> 49:31.990
实际上这里是空格,看没

49:31.990 --> 49:33.990
实际上是空格

49:33.990 --> 49:35.990
所以说它会有这个问题

49:35.990 --> 49:37.990
因此你到时候匹配制表服,匹配不到的

49:37.990 --> 49:39.990
这里我们写个写个问题

49:39.990 --> 49:41.990
好,那么现在我们要分割

49:41.990 --> 49:43.990
按这样的来分割

49:43.990 --> 49:45.990
按照

49:45.990 --> 49:47.990
逗号

49:47.990 --> 49:49.990
狠杠

49:49.990 --> 49:51.990
狠杠

49:51.990 --> 49:53.990
狠杠

49:53.990 --> 49:55.990
制表服

49:55.990 --> 49:57.990
进行分割

49:57.990 --> 49:59.990
就是这些东西都可以分割

49:59.990 --> 50:01.990
它可以是个逗号

50:01.990 --> 50:03.990
也可以是个空格

50:03.990 --> 50:05.990
也可以是个狠杠,也可以是个制表服

50:05.990 --> 50:07.990
都可以分割

50:07.990 --> 50:09.990
因此,这里我们要写正常表达式的

50:09.990 --> 50:11.990
你写,如果你写之前的制服创是不行的

50:11.990 --> 50:13.990
是没办法的

50:13.990 --> 50:15.990
制服创它不能表示规则,对吧

50:15.990 --> 50:17.990
要写规则,要写正常表达式

50:17.990 --> 50:19.990
好,规则就是什么呢?

50:19.990 --> 50:21.990
逗号可以

50:21.990 --> 50:23.990
对吧,然后什么呢?

50:23.990 --> 50:25.990
空格可以,看这些都是制服级

50:25.990 --> 50:27.990
行杠可以

50:27.990 --> 50:29.990
写杠T也可以

50:29.990 --> 50:31.990
这些制服都可以

50:31.990 --> 50:33.990
按照这些制服来进行分割

50:33.990 --> 50:35.990
我们来打印出分割结果

50:35.990 --> 50:37.990
打印出s和result

50:37.990 --> 50:41.370
保存看一下

50:41.370 --> 50:43.370
我哪里写错了

50:43.370 --> 50:45.370
我哪里写错了

50:45.370 --> 50:47.370
在中扩号里边,这个横杠有特殊含义

50:47.370 --> 50:49.370
所以说横杠在中扩号里边

50:49.370 --> 50:51.370
要加上转译服

50:51.370 --> 50:53.370
加上转译服

50:53.370 --> 50:55.370
保存看一下

50:55.370 --> 50:57.370
你看分割出来,是五个,对吧

50:57.370 --> 50:59.370
它既可以按照逗号分割

50:59.370 --> 51:01.370
也可以按照空格分割,也可以按照

51:01.370 --> 51:03.370
这个横杠分割

51:03.370 --> 51:05.370
没问题吧,对不对

51:05.370 --> 51:07.370
比方说换行,换行也可以分割

51:07.370 --> 51:09.370
起杠N

51:09.370 --> 51:11.370
换行服也可以分割

51:11.370 --> 51:13.370
或者说我们这里写杠

51:13.370 --> 51:15.370
写杠S

51:15.370 --> 51:17.370
所有的空白制服都可以分割

51:17.370 --> 51:19.370
对吧,所有的空白制服都可以分割

51:19.370 --> 51:21.370
你看,分割出来了

51:21.370 --> 51:23.370
如果你这里有换行,比方说

51:23.370 --> 51:25.370
这制服圈里边有换行

51:25.370 --> 51:27.370
某些地方有换行

51:27.370 --> 51:29.370
保存,你看一下

51:29.370 --> 51:31.370
分割出来的,当然它有一个地方是空白制服圈

51:31.370 --> 51:33.370
也稍后要进行处理

51:33.370 --> 51:35.370
因为按照这个分割之后

51:35.370 --> 51:37.370
有一个地方,这个和换行之间

51:37.370 --> 51:39.370
这个制服,这个横杠和换行之间

51:39.370 --> 51:41.370
你看这里是不是换行

51:41.370 --> 51:43.370
换行之间中间没有制服

51:43.370 --> 51:45.370
所以要得到一个空制服圈

51:45.370 --> 51:47.370
你看,这样子是不是可以分割

51:47.370 --> 51:49.370
当然这个东西很简单,对吧

51:49.370 --> 51:51.370
你筛选一下吧

51:51.370 --> 51:53.370
用fielder来筛选一下就完事了

51:53.370 --> 51:55.370
这样子可以用振折表达4

51:55.370 --> 51:57.370
来进行分割

51:57.370 --> 51:59.370
没问题吧

51:59.370 --> 52:01.370
没问题吧

52:01.370 --> 52:03.370
接下来,咱们再看

52:03.370 --> 52:05.370
分割这里可以传第二个参数

52:05.370 --> 52:07.370
是一个先定分割片段的数量

52:07.370 --> 52:09.370
那么

52:09.370 --> 52:11.370
它每一次倒到这个数量过后

52:11.370 --> 52:13.370
还有停止,这个参数没多少用

52:13.370 --> 52:15.370
比方说分割你该写个三

52:15.370 --> 52:17.370
它只能分割成三部分

52:17.370 --> 52:19.370
后面就不再分割了,就这么回事

52:19.370 --> 52:21.370
举个例子

52:21.370 --> 52:23.370
比方说,我们第二个参数

52:23.370 --> 52:25.370
给它写个三

52:25.370 --> 52:27.370
保存看一下

52:27.370 --> 52:29.370
不是,后面就不再分割了

52:29.370 --> 52:31.370
它只得到前面三个部分

52:31.370 --> 52:33.370
只分割得到前面三个部分

52:33.370 --> 52:35.370
这个东西

52:35.370 --> 52:37.370
这个很少用

52:37.370 --> 52:39.370
了解就行了

52:39.370 --> 52:41.370
下一个

52:41.370 --> 52:43.370
下一个就是

52:43.370 --> 52:45.370
replace

52:45.370 --> 52:47.370
replace

52:47.370 --> 52:49.370
这个玩意

52:49.370 --> 52:51.370
替换支付串

52:51.370 --> 52:53.370
这个东西很有用

52:53.370 --> 52:55.370
替换支付串

52:55.370 --> 52:57.370
很多的面试题

52:57.370 --> 52:59.370
都跟它有关系

52:59.370 --> 53:01.370
好,咱们来看一下

53:01.370 --> 53:03.370
表示替换

53:03.370 --> 53:05.370
替换支付串

53:05.370 --> 53:07.370
比方说

53:07.370 --> 53:09.370
我要把这些东西

53:09.370 --> 53:11.370
全部替换成

53:11.370 --> 53:13.370
替换成斗号

53:13.370 --> 53:15.370
什么换行,这些空白支付

53:15.370 --> 53:17.370
全部替换成斗号

53:17.370 --> 53:19.370
比方说,我们要做这么一件事

53:19.370 --> 53:21.370
好,接下来,我们来看一下

53:21.370 --> 53:23.370
把空白支付替换成斗号

53:23.370 --> 53:25.370
将

53:25.370 --> 53:27.370
空白支付

53:27.370 --> 53:29.370
替换为

53:29.370 --> 53:31.370
斗号

53:31.370 --> 53:33.370
好,怎么来替换呢

53:33.370 --> 53:35.370
看着

53:35.370 --> 53:37.370
我们这里

53:37.370 --> 53:39.370
s

53:39.370 --> 53:41.370
replace

53:41.370 --> 53:43.370
表示替换

53:43.370 --> 53:45.370
它要传两个参数

53:45.370 --> 53:47.370
第一个参数是一个正的表达式

53:47.370 --> 53:49.370
正的表达式,当然你可以传支付串

53:49.370 --> 53:51.370
比方说

53:51.370 --> 53:53.370
我把空格替换成斗号

53:53.370 --> 53:55.370
假设

53:55.370 --> 53:57.370
咱们把空格替换成斗号

53:57.370 --> 53:59.370
再看一下,我们输出这个s

53:59.370 --> 54:01.370
输出前后的两个s

54:01.370 --> 54:03.370
我等一下

54:03.370 --> 54:05.370
之前输出一次

54:05.370 --> 54:07.370
替换之前输出一次

54:07.370 --> 54:09.370
替换之后输出一次

54:09.370 --> 54:15.620
看一下

54:15.620 --> 54:17.620
哦,不行不行

54:17.620 --> 54:19.620
它不会改变原来的支付串

54:19.620 --> 54:21.620
它不会改变原来的支付串

54:21.620 --> 54:23.620
所以它会返回一个新支付串

54:23.620 --> 54:25.620
新支付串你要重新接收

54:25.620 --> 54:27.620
我重新给s复制

54:27.620 --> 54:29.620
它不会改变原来的支付串

54:29.620 --> 54:31.620
我再保存看一下

54:31.620 --> 54:33.620
你看,它只把第1个空格

54:33.620 --> 54:35.620
替换成斗号

54:35.620 --> 54:37.620
它后面就没有再替配了

54:37.620 --> 54:39.620
就没有再替换了

54:39.620 --> 54:41.620
这就是,如果你直接把第1个参数

54:41.620 --> 54:43.620
写支付串的话,它只会替换一次

54:43.620 --> 54:45.620
替换一次就停止

54:45.620 --> 54:47.620
好,其实是怎么回事呢

54:47.620 --> 54:49.620
其实它是把第1个参数支付串

54:49.620 --> 54:51.620
给你转换成了啥

54:51.620 --> 54:53.620
给你转换成了

54:53.620 --> 54:55.620
正的表达式

54:55.620 --> 54:57.620
它用这种方式给你转换成正的表达式

54:57.620 --> 54:59.620
它是不是只匹配一次

54:59.620 --> 55:01.620
没问题吧,它只匹配一次

55:01.620 --> 55:03.620
因为它不是全局匹配嘛

55:03.620 --> 55:05.620
它只匹配一次

55:05.620 --> 55:07.620
那么这里呢,我们一般通常写的是什么

55:07.620 --> 55:09.620
写的是正的表达式

55:09.620 --> 55:11.620
把空白支付

55:11.620 --> 55:13.620
全局匹配

55:13.620 --> 55:15.620
全局匹配

55:15.620 --> 55:17.620
匹配成斗号

55:17.620 --> 55:19.620
只要空白支付变成斗号

55:19.620 --> 55:21.620
保存看一下

55:21.620 --> 55:23.620
就完成了,就完成匹配了

55:23.620 --> 55:25.620
你看,这样是不是很强大

55:25.620 --> 55:27.620
可以用一个正的表达式

55:27.620 --> 55:29.620
来进行匹配

55:29.620 --> 55:31.620
然后呢,把匹配的结果替换成

55:31.620 --> 55:33.620
把匹配的结果替换成这个东西

55:33.620 --> 55:35.620
好,那么有时候呢

55:35.620 --> 55:37.620
我们可能会希望

55:37.620 --> 55:39.620
可能会希望

55:39.620 --> 55:41.620
把匹配的结果呢

55:41.620 --> 55:43.620
怎么样呢

55:43.620 --> 55:45.620
进行一些处理

55:45.620 --> 55:47.620
进行一些处理

55:47.620 --> 55:49.620
比方说

55:49.620 --> 55:51.620
我们这里有个支付串

55:51.620 --> 55:53.620
支付串

55:53.620 --> 55:55.620
Hello World

55:55.620 --> 55:57.620
我要干嘛呢

55:57.620 --> 55:59.620
我要把单词手字母大写

55:59.620 --> 56:01.620
我要把单词的

56:01.620 --> 56:03.620
手字母大写

56:03.620 --> 56:05.620
那怎么办呢

56:05.620 --> 56:07.620
是不是我要匹配单词的手字母

56:07.620 --> 56:09.620
没问题吧

56:09.620 --> 56:11.620
我要匹配单词的手字母

56:11.620 --> 56:13.620
好,怎么来匹配单词的手字母呢

56:13.620 --> 56:15.620
写杠币

56:15.620 --> 56:17.620
是不是单词边界

56:17.620 --> 56:19.620
前边是单词边界

56:19.620 --> 56:21.620
后边紧接上第一个字母

56:21.620 --> 56:23.620
第一个字母是什么

56:23.620 --> 56:25.620
A到Z

56:25.620 --> 56:27.620
我们只匹配小写字母

56:27.620 --> 56:29.620
没问题吧

56:29.620 --> 56:31.620
因为大写字母它已经大写了

56:31.620 --> 56:33.620
我们不管了,只匹配小写字母

56:33.620 --> 56:35.620
这样子匹配出来是不是单词手字母

56:35.620 --> 56:37.620
比方说咱们把它变成兜号看一下

56:37.620 --> 56:39.620
看一下

56:39.620 --> 56:41.620
你看单词手字母是变成兜号了

56:41.620 --> 56:43.620
那么现在我要做的就是

56:43.620 --> 56:45.620
这一块我要把它变成大写怎么办

56:45.620 --> 56:47.620
好,第二个参数

56:47.620 --> 56:49.620
第二个参数是可以写函数的

56:49.620 --> 56:51.620
哎,第二个参数是可以写函数的

56:51.620 --> 56:53.620
replace看一下吧

56:53.620 --> 56:55.620
它这里有说明

56:55.620 --> 56:57.620
第二个参数

56:57.620 --> 56:59.620
它说你可以写一个新的字母串

56:59.620 --> 57:01.620
也可以写什么呢

57:01.620 --> 57:03.620
也可以写函数

57:03.620 --> 57:05.620
只定一个函数作为参数

57:05.620 --> 57:07.620
我们点击去看一下

57:07.620 --> 57:09.620
函数是函数

57:09.620 --> 57:11.620
这个函数它有很多参数

57:11.620 --> 57:13.620
其中第一个参数就是匹配的字母串

57:13.620 --> 57:15.620
就是匹配的字母串

57:15.620 --> 57:17.620
好,咱们来看一下

57:17.620 --> 57:19.620
这里可以写函数

57:19.620 --> 57:21.620
第一个参数就是匹配的字母串

57:21.620 --> 57:23.620
我们来打印这个字母串看一下

57:23.620 --> 57:25.620
merge

57:25.620 --> 57:27.620
打印看一下

57:27.620 --> 57:29.620
现在不用管NT犯

57:29.620 --> 57:31.620
你看匹配出来是不是H和W

57:31.620 --> 57:33.620
对吧,函数运行了两次

57:33.620 --> 57:35.620
H和W

57:35.620 --> 57:37.620
你看在这个函数里边可以得到匹配的字母串

57:37.620 --> 57:39.620
没问题吧

57:39.620 --> 57:41.620
好,那么这个匹配的字母串,这个函数要做什么呢

57:41.620 --> 57:43.620
这个函数要返回一个东西

57:43.620 --> 57:45.620
你返回什么,它就给你替换成什么

57:45.620 --> 57:47.620
不要返回一个A

57:49.620 --> 57:51.620
它就给你替换成A了

57:51.620 --> 57:53.620
你返回一个东西

57:53.620 --> 57:55.620
好,那这里返回啥呢

57:55.620 --> 57:57.620
那还不简单吧

57:59.620 --> 58:01.620
把它变成大写

58:01.620 --> 58:03.620
把之前的匹配结果变成大写

58:03.620 --> 58:05.620
保存,你看,手是不是大写了

58:05.620 --> 58:07.620
这种方式

58:07.620 --> 58:09.620
进行大写

58:09.620 --> 58:11.620
处理

58:11.620 --> 58:13.620
是不是要比例

58:13.620 --> 58:15.620
就是用那个,之前用什么循环的那种方式

58:15.620 --> 58:17.620
要强大的多

58:17.620 --> 58:19.620
而且要简洁的多

58:19.620 --> 58:21.620
没问题吧

58:21.620 --> 58:23.620
这就是把手字母变大写

58:23.620 --> 58:25.620
手字母变大写

58:25.620 --> 58:27.620
好,那么再想一想

58:27.620 --> 58:29.620
再想一想

58:29.620 --> 58:31.620
如果

58:31.620 --> 58:33.620
我还要干嘛呢

58:33.620 --> 58:35.620
我还要把空白去掉,怎么办呢

58:35.620 --> 58:37.620
比方说,这里有些空白制服

58:39.620 --> 58:41.620
Hello World

58:41.620 --> 58:43.620
script

58:43.620 --> 58:45.620
还有些空白制服,还有换行

58:47.620 --> 58:49.620
yes,随便写了

58:51.620 --> 58:55.620
我不仅要把手字母变成大写

58:55.620 --> 58:57.620
这些手字母变成大写了

58:57.620 --> 58:59.620
单词边界变成大写了

58:59.620 --> 59:01.620
还要把空白制服全部去掉

59:01.620 --> 59:03.620
把它转换成

59:03.620 --> 59:05.620
妥封命名法

59:05.620 --> 59:07.620
把它转换成妥封命名法

59:07.620 --> 59:09.620
那怎么办呢

59:09.620 --> 59:11.620
还要把空白去掉

59:11.620 --> 59:13.620
好,一看着,我这样子写

59:13.620 --> 59:15.620
我这样子写

59:15.620 --> 59:17.620
前边加上一个空白制服

59:17.620 --> 59:19.620
加上空白制服

59:19.620 --> 59:21.620
出现

59:21.620 --> 59:23.620
出现什么呢

59:23.620 --> 59:25.620
零次

59:25.620 --> 59:27.620
零次或多次

59:27.620 --> 59:29.620
后边加上空白制服

59:29.620 --> 59:31.620
出现零次或多次

59:31.620 --> 59:33.620
咱们把这个march输出看一下

59:33.620 --> 59:35.620
把march输出看一下

59:35.620 --> 59:37.620
再把march的长度输出

59:37.620 --> 59:39.620
它匹配出来是什么结果

59:39.620 --> 59:41.620
你看,它匹配出来了

59:41.620 --> 59:43.620
匹配了4个东西,H

59:43.620 --> 59:45.620
长度为1,它前面没有空白

59:45.620 --> 59:47.620
W的长度为2,它前面有个空白

59:47.620 --> 59:49.620
有个空格

59:49.620 --> 59:51.620
J的长度为2

59:51.620 --> 59:53.620
前面有个字表

59:53.620 --> 59:55.620
Y的长度为2,前面有个换行

59:55.620 --> 59:57.620
都匹配出来了

59:57.620 --> 59:59.620
然后我要做的事情

59:59.620 --> 01:00:01.620
我把它转换成大写之后

01:00:01.620 --> 01:00:03.620
我去掉所谓空白

01:00:03.620 --> 01:00:05.620
你看,去掉所谓空白之后

01:00:05.620 --> 01:00:07.620
是不是就完事了

01:00:07.620 --> 01:00:09.620
就变成了妥妨命运法了吧

01:00:09.620 --> 01:00:11.620
没问题吧

01:00:11.620 --> 01:00:13.620
就转换成为了妥妨命运法

01:00:13.620 --> 01:00:15.620
用这种方式来转换妥妨命运法

01:00:15.620 --> 01:00:17.620
是不是非常非常简洁

01:00:17.620 --> 01:00:19.620
非常简洁吧

01:00:19.620 --> 01:00:21.620
没问题吧

01:00:21.620 --> 01:00:23.620
OK

01:00:23.620 --> 01:00:25.620
这是关于这一块

01:00:25.620 --> 01:00:27.620
关于这一块

01:00:27.620 --> 01:00:31.260
好,然后

01:00:31.260 --> 01:00:33.260
这是之不错的replace

01:00:33.260 --> 01:00:35.260
还有啥呢

01:00:35.260 --> 01:00:37.260
好像就没啥了

01:00:37.260 --> 01:00:39.260
我这里记一笔吧

01:00:39.260 --> 01:00:41.260
split,它跟正转表的是相关

01:00:41.260 --> 01:00:43.260
还有什么replace

01:00:43.260 --> 01:00:45.260
跟正转表的是相关,替换

01:00:45.260 --> 01:00:47.260
还有什么呢

01:00:47.260 --> 01:00:49.260
还举了什么例子

01:00:49.260 --> 01:00:51.260
还举了search和march

01:00:51.260 --> 01:00:53.260
search

01:00:53.260 --> 01:00:55.260
得到下标,march得到匹配结果

01:00:55.260 --> 01:00:57.260
就这么一些函数

01:00:57.260 --> 01:00:59.260
是之不错里面的函数

01:00:59.260 --> 01:01:01.260
它跟正转表的是相关的

01:01:01.260 --> 01:01:03.260
这就是我们这个

01:01:03.260 --> 01:01:05.260
是关于制服串里面

01:01:05.260 --> 01:01:07.260
以及这么表示对象里面

01:01:07.260 --> 01:01:09.260
有哪些东西可以帮助我们写代吗

01:01:09.260 --> 01:01:11.260
好,来,作业

01:01:11.260 --> 01:01:14.630
来吧

01:01:14.630 --> 01:01:16.630
第一题

01:01:16.630 --> 01:01:18.630
就随便

01:01:18.630 --> 01:01:20.630
书写一个正转表的是

01:01:20.630 --> 01:01:22.630
书写一个正转表的是

01:01:22.630 --> 01:01:24.630
然后呢

01:01:24.630 --> 01:01:26.630
去匹配

01:01:26.630 --> 01:01:28.630
去匹配

01:01:28.630 --> 01:01:30.630
一个制服串

01:01:30.630 --> 01:01:32.630
去匹配一个制服串

01:01:32.630 --> 01:01:34.630
得到匹配的次数

01:01:34.630 --> 01:01:36.630
和匹配的结果

01:01:36.630 --> 01:01:38.630
我们是做过的

01:01:38.630 --> 01:01:40.630
有哪些地方是匹配的

01:01:40.630 --> 01:01:42.630
匹配的匹配一共匹配了多少次

01:01:42.630 --> 01:01:44.630
随便你用什么方式做

01:01:44.630 --> 01:01:46.630
当然

01:01:46.630 --> 01:01:48.630
这东西肯定是全具匹配

01:01:48.630 --> 01:01:50.630
如果你不是全具匹配的话

01:01:50.630 --> 01:01:52.630
那肯定只有一次

01:01:52.630 --> 01:01:54.630
关于这是第一个

01:01:54.630 --> 01:01:56.630
第二题

01:01:56.630 --> 01:01:58.630
第二题是什么呢

01:01:58.630 --> 01:02:00.630
匹配

01:02:00.630 --> 01:02:02.630
一个制服串中的

01:02:02.630 --> 01:02:04.630
中文制服

01:02:04.630 --> 01:02:06.630
中文制服

01:02:06.630 --> 01:02:08.630
得到

01:02:08.630 --> 01:02:10.630
应该这样说

01:02:10.630 --> 01:02:12.630
得到一个制服串中

01:02:12.630 --> 01:02:14.630
中文制服的

01:02:14.630 --> 01:02:16.630
的数量

01:02:16.630 --> 01:02:18.630
这是上面的实体

01:02:18.630 --> 01:02:20.630
好,第三题

01:02:20.630 --> 01:02:22.630
过滤关键制

01:02:22.630 --> 01:02:24.630
过滤敏感词

01:02:24.630 --> 01:02:26.630
有一个

01:02:26.630 --> 01:02:28.630
敏感词

01:02:28.630 --> 01:02:30.630
敏感词

01:02:30.630 --> 01:02:32.630
数组

01:02:32.630 --> 01:02:34.630
有一个敏感词数组

01:02:34.630 --> 01:02:36.630
需要将制服串中

01:02:36.630 --> 01:02:38.630
出现的敏感词

01:02:38.630 --> 01:02:40.630
敏感词

01:02:40.630 --> 01:02:42.630
替换为

01:02:42.630 --> 01:02:44.630
四个新号

01:02:44.630 --> 01:02:46.630
只要你出现了敏感词

01:02:46.630 --> 01:02:48.630
我就会替换成四个新号

01:02:48.630 --> 01:02:50.630
没问题吧

01:02:50.630 --> 01:02:52.630
只要你出现了敏感词

01:02:52.630 --> 01:02:54.630
我就替换成四个新号

01:02:54.630 --> 01:02:56.630
首先你要有个敏感词数组

01:02:56.630 --> 01:02:58.630
啊

01:02:58.630 --> 01:03:01.940
啊

01:03:01.940 --> 01:03:03.940
既然是敏感词

01:03:03.940 --> 01:03:05.940
共产党

01:03:05.940 --> 01:03:07.940
啊

01:03:07.940 --> 01:03:09.940
啊

01:03:09.940 --> 01:03:11.940
图样

01:03:11.940 --> 01:03:13.940
啊

01:03:13.940 --> 01:03:15.940
图simple

01:03:15.940 --> 01:03:19.380
啊

01:03:19.380 --> 01:03:21.380
营销

01:03:21.380 --> 01:03:23.380
像这些敏感词

01:03:23.380 --> 01:03:25.380
准备好一个数组

01:03:25.380 --> 01:03:27.380
以后我改动这个数组

01:03:27.380 --> 01:03:29.380
让我完成新的轨轴的替换

01:03:29.380 --> 01:03:31.380
你有一个敏感词数组

01:03:31.380 --> 01:03:33.380
凡是数组里边

01:03:33.380 --> 01:03:35.380
就是制服串中出现的敏感词

01:03:35.380 --> 01:03:37.380
都会替换成这个

01:03:37.380 --> 01:03:39.380
这个东西在国外没什么暖用

01:03:39.380 --> 01:03:41.380
但是在国内非常有用

01:03:41.380 --> 01:03:43.380
非常非常有用

01:03:43.380 --> 01:03:45.380
你们自己去想

01:03:45.380 --> 01:03:47.380
第三题

01:03:47.380 --> 01:03:49.380
第四题

01:03:49.380 --> 01:03:51.380
第四题是得到一个

01:03:51.380 --> 01:03:53.380
atema制服串中出现的

01:03:53.380 --> 01:03:55.380
章节数量

01:03:55.380 --> 01:03:57.380
比方说

01:03:57.380 --> 01:03:59.380
有一个atema制服串

01:03:59.380 --> 01:04:01.380
我这里直接写到这吧

01:04:01.380 --> 01:04:03.380
写到这

01:04:03.380 --> 01:04:05.380
啊

01:04:05.380 --> 01:04:07.380
test

01:04:07.380 --> 01:04:09.380
4.atema

01:04:09.380 --> 01:04:11.380
比方说一个atema制服串

01:04:11.380 --> 01:04:13.380
它章节是有一个特殊的

01:04:13.380 --> 01:04:15.380
元素

01:04:15.380 --> 01:04:17.380
就是H2元素

01:04:17.380 --> 01:04:19.380
H2元素

01:04:19.380 --> 01:04:21.380
章节的内容是

01:04:21.380 --> 01:04:23.380
第

01:04:23.380 --> 01:04:25.380
多少章

01:04:25.380 --> 01:04:27.380
章节它一定是这种格式

01:04:27.380 --> 01:04:29.380
一定是这种格式

01:04:29.380 --> 01:04:31.380
一个H2元素

01:04:31.380 --> 01:04:33.380
然后第多少章

01:04:33.380 --> 01:04:35.380
这个

01:04:35.380 --> 01:04:37.380
打在这

01:04:37.380 --> 01:04:39.380
这样子的

01:04:39.380 --> 01:04:41.380
它一定是这么一种格式

01:04:41.380 --> 01:04:43.380
一定是这么一种格式

01:04:43.380 --> 01:04:45.380
比方说第1章

01:04:45.380 --> 01:04:47.380
然后章节下边有很多P元素

01:04:47.380 --> 01:04:49.380
很多P元素

01:04:49.380 --> 01:04:51.380
就随便写个

01:04:51.380 --> 01:04:53.380
罗瑞斯跟乱书讲完

01:04:53.380 --> 01:04:55.380
就是随机生成一些文字

01:04:55.380 --> 01:04:57.380
咱们来看一下

01:04:57.380 --> 01:04:59.380
整个这一块

01:04:59.380 --> 01:05:01.380
出现

01:05:01.380 --> 01:05:03.380
实识

01:05:03.380 --> 01:05:05.380
能不能这样子写吗

01:05:05.380 --> 01:05:07.380
我看一下

01:05:07.380 --> 01:05:09.380
应该可以这样子写吧

01:05:09.380 --> 01:05:11.380
我这里

01:05:11.380 --> 01:05:16.230
这里扩起来

01:05:16.230 --> 01:05:18.230
扩起来

01:05:18.230 --> 01:05:20.230
习惯了

01:05:20.230 --> 01:05:22.230
你看这就是章节

01:05:22.230 --> 01:05:24.230
第1章第2章第3章第4章

01:05:24.230 --> 01:05:26.230
一共章节的数量

01:05:26.230 --> 01:05:28.230
就是一个字符串

01:05:28.230 --> 01:05:30.230
整个字符串比方说

01:05:30.230 --> 01:05:32.230
咱们这里

01:05:32.230 --> 01:05:34.230
介石

01:05:34.230 --> 01:05:36.230
它是个字符串

01:05:38.230 --> 01:05:40.230
起到这了

01:05:40.230 --> 01:05:42.230
你自己去复制一下

01:05:42.230 --> 01:05:44.230
这是个字符串

01:05:44.230 --> 01:05:46.230
你拿到字符串过后要进行匹配

01:05:46.230 --> 01:05:48.230
匹配它有多少章

01:05:48.230 --> 01:05:50.230
我现在把字符串给力了

01:05:50.230 --> 01:05:52.230
给力到这个字符串

01:05:52.230 --> 01:05:54.230
然后你要告诉我它一共有几章

01:05:54.230 --> 01:05:56.230
从这个字符串中去判断它有多少章节

01:05:56.230 --> 01:05:58.230
一共4道题

01:05:58.230 --> 01:06:00.230
这4道题都是对我们今后

01:06:00.230 --> 01:06:02.230
无论是对我们今后开发也好

01:06:02.230 --> 01:06:04.230
还是对我们面试也好

01:06:04.230 --> 01:06:06.230
都是非常非常有帮助的4道题

01:06:06.230 --> 01:06:08.230
好吧 把它做一遍

01:06:08.230 --> 01:06:10.230
下集后再讲

