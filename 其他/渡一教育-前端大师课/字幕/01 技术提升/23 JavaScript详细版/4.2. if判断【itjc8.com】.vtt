WEBVTT

00:00.000 --> 00:16.520
这节课呢 咱们来看一下第一个流程控制的手段

00:16.520 --> 00:18.220
就是衣服判断

00:18.220 --> 00:21.020
好 衣服判断的是一种代码结构

00:21.020 --> 00:25.220
它的代码结构呢 我先把它写出来啊

00:25.220 --> 00:27.520
它代码结构是这样子

00:27.520 --> 00:30.320
衣服 关键字 关键词

00:30.320 --> 00:32.320
然后两个小括号

00:32.320 --> 00:36.020
这里边写的是表达式

00:36.620 --> 00:40.320
表达式衣 有时候我们也把它称之为条件衣

00:40.320 --> 00:43.320
就是看条件衣适逢满足

00:43.320 --> 00:45.420
也就是说做什么 做布尔判定

00:45.420 --> 00:48.120
关于布尔判定我们之前是不是讲过的

00:48.120 --> 00:50.520
在运算符内章节就讲过了

00:50.520 --> 00:54.720
什么NOW啊 undefend啊 数字零啊

00:54.720 --> 00:57.620
什么空的制服圈啊 就没有任何内容的制服圈啊

00:57.620 --> 01:00.220
像这些东西啊 它判定的结果呢 都是假

01:00.220 --> 01:01.920
其他的都是真 对吧

01:01.920 --> 01:03.820
我们当时再回一下啊

01:03.920 --> 01:06.720
运算符这一块啊 就是在什么

01:06.720 --> 01:09.820
比较运算符这一块 应该是在逻辑运算符这一块啊

01:09.820 --> 01:12.520
当时我讲了这个布尔判定

01:12.520 --> 01:16.620
除了这些东西为假之外 其他的全部为真

01:16.620 --> 01:18.520
好了 这是布尔判定

01:18.520 --> 01:21.120
好 首先它判断这个条件适逢为真

01:21.120 --> 01:24.920
如果为真的话 执行这一块代码

01:24.920 --> 01:26.620
代码块

01:26.620 --> 01:29.320
代码块 好 代码块里面就是

01:29.320 --> 01:30.920
可以是一句代码

01:30.920 --> 01:33.720
也可以是十句代码 可以是多句代码 对吧

01:33.820 --> 01:36.220
代码块里面可以是任何数量的代码

01:36.220 --> 01:37.820
就是可以写很多语句

01:37.820 --> 01:40.620
如果这个条件为真 就执行这个代码块

01:40.620 --> 01:42.220
这是它最简单的写法

01:42.220 --> 01:44.620
但是它的完整格式呢 还有很多啊

01:44.620 --> 01:46.220
还有L11符

01:46.220 --> 01:48.220
L11符

01:48.220 --> 01:49.720
L11符什么意思啊

01:49.720 --> 01:50.620
L什么意思啊

01:50.620 --> 01:52.220
L11就是否则

01:52.220 --> 01:55.220
否则的话 又去判断

01:55.220 --> 01:57.820
条件2 就是我们怎么来读呢

01:57.820 --> 01:59.920
如果条件1为真

01:59.920 --> 02:02.720
如果判断出来为真 那么执行它

02:02.720 --> 02:04.520
如果条件1不为真的话

02:04.520 --> 02:07.020
我们转而去判断条件2

02:07.020 --> 02:08.920
看条件2是不是满足呢

02:08.920 --> 02:11.320
如果条件2满足的话 执行这个代码块

02:14.020 --> 02:15.820
然后如果条件2不满足

02:15.820 --> 02:17.520
又是又来L11符

02:17.520 --> 02:20.220
看条件3是不是满足

02:20.220 --> 02:22.620
如果条件3满足呢 又执行这个代码块

02:23.720 --> 02:25.520
非常简单啊

02:25.520 --> 02:28.420
我们这里还可以写很多很多的L11符

02:28.420 --> 02:30.220
可以写很多很多 我就不写了啊

02:30.220 --> 02:32.420
就不写了 可以写很多

02:32.420 --> 02:35.420
好 然后呢 最后一个是L11

02:35.420 --> 02:38.220
就是以上条件

02:38.220 --> 02:40.020
以上条件

02:41.920 --> 02:43.920
以上条件都不满足

02:45.820 --> 02:47.620
执行的代码块

02:47.620 --> 02:49.720
就执行最后一个L11

02:49.720 --> 02:54.220
这就是一个完整的义父判断的结构

02:54.220 --> 02:56.220
注意啊 这不是多个义父判断

02:56.220 --> 02:58.620
是一个义父判断的结构

02:58.620 --> 03:00.020
条件1满足吗

03:00.020 --> 03:01.220
如果满足执行它

03:01.220 --> 03:03.020
剩下的全部不看了

03:03.020 --> 03:04.920
如果条件1满足的话

03:04.920 --> 03:07.020
剩下的全部不看

03:07.020 --> 03:09.420
好 这里我们看一下第一个细节

03:09.420 --> 03:11.220
条件1如果满

03:11.220 --> 03:14.620
就是如果某个条件满足

03:15.820 --> 03:22.420
则直接忽略后边的所有所有条件

03:22.420 --> 03:24.220
包括这个L11就全部不看了

03:24.220 --> 03:25.420
一个都不看了

03:25.420 --> 03:26.720
只要其中一个条件满足

03:26.720 --> 03:28.420
后边的全部不看了

03:28.420 --> 03:30.420
好 第二个

03:30.420 --> 03:35.420
L11L11可以有多个

03:35.420 --> 03:36.720
可以有多个

03:36.720 --> 03:37.920
你可以随便写多少个

03:37.920 --> 03:40.120
100个都可以

03:40.120 --> 03:41.320
也可以有多个

03:41.320 --> 03:44.420
多个就是包含0个

03:44.420 --> 03:46.620
也就是说L11你可以不写

03:46.620 --> 03:48.420
不写的话就变成这个样子

03:48.420 --> 03:49.620
不写就变成这个样子

03:49.620 --> 03:50.820
这个样子表示什么意思呢

03:50.820 --> 03:53.220
如果条件1满足执行它

03:53.220 --> 03:54.820
否则执行它

03:54.820 --> 03:56.320
就不满足的话就执行它

03:56.320 --> 03:57.620
就这么个意思了

03:57.620 --> 04:00.020
L11可以有多个

04:00.020 --> 04:07.020
第三个细节是L11可以有1个或0个

04:07.020 --> 04:09.920
L11你可写可不写

04:09.920 --> 04:11.320
就是如果你没有L11的话

04:11.320 --> 04:12.720
可以这样写

04:12.720 --> 04:14.020
条件1满足执行它

04:14.020 --> 04:15.320
条件2满足执行它

04:15.320 --> 04:16.920
条件3满足执行它

04:16.920 --> 04:18.420
如果前面都不满足

04:18.420 --> 04:19.420
都不满足的话

04:19.420 --> 04:21.120
啥都不做

04:21.120 --> 04:23.920
程序继续往后边运行

04:23.920 --> 04:26.820
这就是一个衣服判断的代码块

04:26.920 --> 04:29.120
好了这就是冠军衣服判断

04:29.120 --> 04:30.720
其实很简单很简单

04:30.720 --> 04:32.120
还有一些细节

04:32.120 --> 04:37.720
L11可以换行可以不换行

04:37.720 --> 04:39.120
这个看具体公司

04:39.120 --> 04:41.020
看具体公司的要求

04:41.020 --> 04:42.520
有些公司他喜欢这样子写

04:42.520 --> 04:44.320
他的代码风格喜欢这样子写

04:44.320 --> 04:47.720
可以没有任何问题的

04:47.720 --> 04:49.220
就是不换行

04:49.220 --> 04:51.720
这样子再写

04:51.720 --> 04:53.820
有些公司他喜欢换行

04:53.820 --> 04:55.020
看个人习惯

04:55.020 --> 04:57.220
同时也要看公司里面的要求

04:57.220 --> 04:59.320
公司里面往往对他代码的风格

04:59.320 --> 05:00.520
有一些要求

05:00.520 --> 05:01.620
我个人的话

05:01.620 --> 05:04.020
我个人的话习惯于换行

05:04.020 --> 05:05.820
我个人习惯换行

05:05.820 --> 05:08.320
这是关于L11和L11衣服

05:08.320 --> 05:10.420
然后还有个规则就是

05:10.420 --> 05:12.620
如果代码块

05:12.620 --> 05:14.220
什么叫代码块

05:14.220 --> 05:16.020
代码块就是多条语句

05:16.020 --> 05:19.320
如果代码块只有一条语句

05:19.320 --> 05:22.720
可以省略大扣号

05:22.720 --> 05:25.220
就是花扣号

05:25.220 --> 05:26.620
就是如果这里面要代码

05:26.620 --> 05:28.420
比方代码块只有一条语句

05:28.420 --> 05:29.920
这个大扣号是可以不写的

05:29.920 --> 05:31.820
可以不写

05:31.820 --> 05:33.320
这样子他也能识别

05:33.320 --> 05:35.220
但是不推荐这样做

05:35.220 --> 05:36.720
不推荐

05:36.720 --> 05:38.820
因为这样子对于阅读来说

05:38.820 --> 05:40.020
不是那么好阅读

05:40.020 --> 05:42.420
不推荐

05:42.420 --> 05:45.220
有些公司有强制要求是绝对不允许的

05:45.220 --> 05:48.420
也少写这个花扣号的

05:48.420 --> 05:49.720
其他的就没啥了

05:49.720 --> 05:52.120
这就是一个衣服判断

05:52.120 --> 05:52.620
非常简单

05:52.620 --> 05:54.220
咱们来做个例子

05:54.220 --> 05:56.620
TES-1

05:56.620 --> 05:58.020
TES-1

05:58.020 --> 06:00.820
比方说

06:00.820 --> 06:02.320
我们有一个分数

06:02.320 --> 06:03.520
有一个分数

06:03.520 --> 06:05.920
一个变量

06:05.920 --> 06:07.420
里面存了一个分数

06:07.420 --> 06:08.020
这个分数

06:08.020 --> 06:10.820
我们给他随便写一个

06:10.820 --> 06:12.720
接下来我们来判断

06:12.720 --> 06:14.120
这个分数

06:14.120 --> 06:16.420
比方说有这么一个规则

06:16.420 --> 06:18.820
不及格就是或者是这样子

06:18.820 --> 06:19.820
把它分成成绩

06:19.820 --> 06:21.820
成绩的四个等级

06:22.720 --> 06:23.720
D级

06:23.720 --> 06:25.120
先说A

06:25.120 --> 06:29.120
A级的成绩是要大于等于90分

06:29.120 --> 06:29.920
这是成绩

06:29.920 --> 06:31.920
就是A的情况

06:31.920 --> 06:33.120
B的情况是要

06:33.120 --> 06:38.720
这个成绩是要在70分

06:38.720 --> 06:41.120
在70分

06:41.120 --> 06:43.420
大于等于70

06:43.420 --> 06:44.720
大于等于70分

06:44.720 --> 06:47.920
然后要小于90分

06:47.920 --> 06:49.120
这是B的情况

06:49.120 --> 06:50.420
就是70到90

06:50.520 --> 06:52.120
70到90

06:52.120 --> 06:54.420
然后C的情况是

06:54.420 --> 06:56.520
比方说是50

06:56.520 --> 06:59.820
大于等于50

06:59.820 --> 07:05.720
然后小于70

07:05.720 --> 07:07.520
然后D的情况是不其他的

07:07.520 --> 07:08.320
其他情况

07:08.320 --> 07:09.420
D的情况就是啥

07:09.420 --> 07:12.120
就是小于50分

07:12.120 --> 07:13.520
我们要根据这个分数

07:13.520 --> 07:15.320
你这里边我之前说过

07:15.320 --> 07:17.220
变量里面存了什么东西

07:17.220 --> 07:18.720
你不能做任何的假设

07:18.720 --> 07:20.620
你不能认为它里面存的就是87

07:20.620 --> 07:22.220
它里面存的87

07:22.220 --> 07:24.120
你直接给我输出一个B

07:24.120 --> 07:25.020
那有什么意义呢

07:25.020 --> 07:26.820
它的东西有可能会变化的

07:26.820 --> 07:28.520
有可能会来自于用户输入

07:28.520 --> 07:32.220
我们这一课一会就会讲到用户的输入

07:32.220 --> 07:34.220
那么这里我们怎么来判断呢

07:34.220 --> 07:35.120
怎么来判断呢

07:35.120 --> 07:36.920
我们可以这样做

07:36.920 --> 07:37.920
用衣服判断

07:37.920 --> 07:38.720
直接写衣服了

07:38.720 --> 07:40.520
衣服结构开始

07:40.520 --> 07:41.720
判断什么呢

07:41.720 --> 07:43.120
判断Score

07:43.120 --> 07:44.320
这个变量

07:44.320 --> 07:48.120
是不是大于等于90

07:48.120 --> 07:50.420
是不是大于等于90

07:50.420 --> 07:51.920
如果大于等于90的话

07:51.920 --> 07:52.920
我们写一条语句

07:52.920 --> 07:54.320
输出A

07:54.320 --> 07:56.220
输出成绩为A

07:56.220 --> 07:57.420
就这么简单

07:57.420 --> 07:59.620
你看这里是不是个表达式

07:59.620 --> 08:00.020
对吧

08:00.020 --> 08:02.220
这个表达式进行布尔判定

08:02.220 --> 08:02.820
布尔判定

08:02.820 --> 08:05.420
这个表达式本来就比较运算服嘛

08:05.420 --> 08:06.820
本来就返回的是布尔

08:06.820 --> 08:08.420
你看我们之前说的是

08:08.420 --> 08:10.220
运算服相当于是主持

08:10.220 --> 08:10.820
对吧

08:10.820 --> 08:13.320
咱们流程控制的相当于是招具了

08:13.320 --> 08:16.320
招具招出一个一个的句子

08:16.320 --> 08:17.520
那么这里的这个表达式

08:17.520 --> 08:19.120
它判断的是是不是大于等于90

08:19.120 --> 08:20.620
如果这个判断为真

08:20.620 --> 08:21.520
如果它为真

08:21.520 --> 08:23.220
那么就运行这个代码

08:23.220 --> 08:23.320
好

08:23.320 --> 08:24.320
咱们直接运行看一下

08:26.720 --> 08:29.460
运行看一下

08:29.460 --> 08:33.900
F12打开

08:33.900 --> 08:35.000
按错了

08:35.000 --> 08:35.700
按错了

08:35.700 --> 08:37.100
刷新词

08:37.100 --> 08:37.300
好

08:37.300 --> 08:38.300
现在没有任何输出

08:38.300 --> 08:38.700
对吧

08:38.700 --> 08:39.400
没有任何输出

08:39.400 --> 08:40.400
为什么没有输出呢

08:40.400 --> 08:41.900
因为它的成绩不是A

08:41.900 --> 08:42.500
不是A

08:42.500 --> 08:44.000
比方说我这里写个90

08:44.000 --> 08:45.300
保存一下

08:45.300 --> 08:46.300
就输出了A

08:46.300 --> 08:48.100
它的成绩是A

08:48.100 --> 08:49.000
没问题吧

08:49.100 --> 08:50.700
OK

08:50.700 --> 08:50.900
好

08:50.900 --> 08:54.100
接下来我们又可以继续写LCV

08:54.100 --> 08:55.500
LCV

08:55.500 --> 08:56.500
LCV

08:56.500 --> 08:57.600
我们来写一下

08:57.600 --> 08:58.800
score

08:58.800 --> 09:00.700
大于等于多少呢

09:00.700 --> 09:02.300
70

09:02.300 --> 09:04.100
并且score

09:04.100 --> 09:05.300
小于90

09:05.300 --> 09:05.600
对吧

09:05.600 --> 09:06.800
这是第二个条件

09:06.800 --> 09:07.800
大于等于70

09:07.800 --> 09:09.500
并且小于90

09:09.500 --> 09:10.600
你千万不要这样子写

09:10.600 --> 09:13.000
我之前看到有同学这样子写的

09:13.000 --> 09:14.300
把我吓一跳

09:14.300 --> 09:14.900
就这样子写的

09:17.000 --> 09:18.300
没有这种写法

09:18.300 --> 09:20.300
他现在为什么不报错

09:20.300 --> 09:22.300
他现在为啥不报错

09:22.300 --> 09:24.300
他啥意思呢

09:24.300 --> 09:26.300
他是认为你在比较啥呢

09:26.300 --> 09:28.300
你是把这个表达式算出来

09:28.300 --> 09:30.300
把这个表达式算出来

09:30.300 --> 09:32.300
然后跟90进行比较

09:32.300 --> 09:34.300
他是认为这个意思

09:34.300 --> 09:35.300
把这个表达式算出来

09:35.300 --> 09:36.300
这个表达式是啥

09:36.300 --> 09:37.300
这个表达式是不是true

09:37.300 --> 09:38.300
true

09:38.300 --> 09:39.300
true跟90比较

09:39.300 --> 09:40.300
他认为是这个意思

09:40.300 --> 09:41.300
千万不要这样写

09:41.300 --> 09:43.300
意思是不一样的

09:43.300 --> 09:45.300
你要用并且

09:46.300 --> 09:47.800
那么如果是这种情况

09:47.800 --> 09:49.300
输出B

09:49.300 --> 09:50.300
输出B

09:50.300 --> 09:53.300
又来LCF

09:53.300 --> 09:54.300
score

09:54.300 --> 09:56.300
如果是大于等于50

09:56.300 --> 09:58.300
并且score

09:58.300 --> 09:59.300
小于70

09:59.300 --> 10:01.300
如果是这种情况

10:01.300 --> 10:02.300
他为什么自动跑上去了呢

10:02.300 --> 10:03.300
因为我格式化了

10:03.300 --> 10:05.300
Orc加Sheff加F

10:05.300 --> 10:06.300
格式化了

10:06.300 --> 10:07.300
他默认的格式呢

10:07.300 --> 10:09.300
他就是不换行

10:09.300 --> 10:10.300
默认格式是不换行

10:10.300 --> 10:11.300
这个是可以调的

10:11.300 --> 10:13.300
我只是没有去调而已

10:13.300 --> 10:16.300
我之前其实是调过的

10:16.300 --> 10:17.300
然后呢

10:17.300 --> 10:18.300
后来升级到过后就没调了

10:18.300 --> 10:19.300
无所谓

10:19.300 --> 10:20.300
这个无所谓的

10:20.300 --> 10:21.300
然后呢

10:21.300 --> 10:22.300
这里是大于等于50

10:22.300 --> 10:23.300
小于70

10:23.300 --> 10:24.300
这是啥呢

10:24.300 --> 10:25.300
这是C对吧

10:25.300 --> 10:26.300
这是C

10:26.300 --> 10:27.300
好

10:27.300 --> 10:28.300
最后一种情况

10:28.300 --> 10:30.300
最后一种情况就是L

10:30.300 --> 10:31.300
前边都不满足

10:31.300 --> 10:32.300
都不满足是啥呢

10:32.300 --> 10:34.300
都不满足

10:34.300 --> 10:35.300
console

10:35.300 --> 10:37.300
都不满足就是D

10:37.300 --> 10:39.300
因为只有这种情况

10:39.300 --> 10:40.300
前边都不满足条件

10:40.300 --> 10:42.300
那么就是出出D

10:42.300 --> 10:43.300
咱们来看一下

10:43.300 --> 10:45.300
目前他输出的就是B

10:45.300 --> 10:47.300
输出的就是B

10:47.300 --> 10:48.300
接着再看

10:48.300 --> 10:50.300
如果我把分数改一下

10:50.300 --> 10:51.300
改成67

10:51.300 --> 10:53.300
保存

10:53.300 --> 10:55.300
输出C

10:55.300 --> 10:57.300
他就是根据不同的情况

10:57.300 --> 10:58.300
去运行不同的代码

10:58.300 --> 11:00.300
当然这里边的代码

11:00.300 --> 11:01.300
可以不止一行

11:01.300 --> 11:02.300
可以有很多行

11:02.300 --> 11:03.300
当然我之前说过

11:03.300 --> 11:04.300
如果你只有一行代码的话

11:04.300 --> 11:06.300
是可以省略掉大国号的

11:06.300 --> 11:07.300
大框是可以省略的

11:07.300 --> 11:08.300
但是不建议大家省略

11:08.300 --> 11:09.300
这样子看上去

11:09.300 --> 11:10.300
更加舒服一点

11:10.300 --> 11:11.300
更加清楚一点

11:11.300 --> 11:13.300
比方说30分

11:13.300 --> 11:14.300
保存

11:14.300 --> 11:15.300
看一下30分

11:15.300 --> 11:17.300
就得到的是D

11:17.300 --> 11:18.300
得到的是D

11:18.300 --> 11:20.300
非常非常简单

11:20.300 --> 11:22.300
其实大家仔细观察

11:22.300 --> 11:24.300
仔细观察

11:24.300 --> 11:27.300
这里边其实还可以简写

11:27.300 --> 11:29.300
有些地方可以省略的

11:29.300 --> 11:31.300
比方说这个代码

11:31.300 --> 11:32.300
你看一下

11:32.300 --> 11:33.300
能不能省略

11:33.300 --> 11:35.300
这块代码能不能省略

11:35.300 --> 11:37.300
能不能省略呢

11:37.300 --> 11:39.300
咱们来先看结果

11:39.300 --> 11:40.300
保存看一下

11:40.300 --> 11:41.300
得到了D

11:41.300 --> 11:42.300
没问题吧

11:42.300 --> 11:43.300
好

11:43.300 --> 11:44.300
来看一下90

11:44.300 --> 11:46.300
保存得到了A

11:46.300 --> 11:47.300
没问题吧

11:47.300 --> 11:50.300
再看一下80

11:50.300 --> 11:52.300
看一下得到了B

11:52.300 --> 11:53.300
没问题吧

11:53.300 --> 11:54.300
再看一下60

11:54.300 --> 11:56.300
保存得到的是C

11:56.300 --> 11:57.300
都没有问题

11:57.300 --> 11:58.300
说明这样子

11:58.300 --> 11:59.300
也是可以的对吧

11:59.300 --> 12:00.300
我们试验了一下

12:00.300 --> 12:01.300
是可以的

12:01.300 --> 12:03.300
为什么它可以呢

12:03.300 --> 12:04.300
大家想一想

12:04.300 --> 12:06.300
如果这个条件满足

12:06.300 --> 12:08.300
是不是直接输出A就结束了

12:08.300 --> 12:09.300
后面的是不是不看了

12:09.300 --> 12:10.300
对吧

12:10.300 --> 12:11.300
一个都不看了

12:11.300 --> 12:13.300
什么条件都不去运行了

12:13.300 --> 12:14.300
好

12:14.300 --> 12:15.300
如果这个条件不满足

12:15.300 --> 12:17.300
是不是就隐含了

12:17.300 --> 12:19.300
如果这个条件不满足

12:19.300 --> 12:22.300
当条件判断到这的时候

12:22.300 --> 12:24.300
当条件判断到这的时候

12:24.300 --> 12:26.300
是不是就隐含一个分数

12:26.300 --> 12:28.300
一定是小于90的

12:28.300 --> 12:29.300
没问题吧

12:29.300 --> 12:30.300
对吧

12:30.300 --> 12:32.300
当运行到第2个条件的时候

12:32.300 --> 12:34.300
分数一定是小于90的

12:34.300 --> 12:35.300
否则的话

12:35.300 --> 12:36.300
它根本就不会运行

12:36.300 --> 12:37.300
第2个条件

12:38.300 --> 12:39.300
这个意思

12:39.300 --> 12:40.300
因此第2个条件

12:40.300 --> 12:42.300
我们没有必要再去写一次

12:42.300 --> 12:43.300
分数小于90了

12:43.300 --> 12:44.300
运行到这个条件

12:44.300 --> 12:45.300
它一定是小于90的

12:45.300 --> 12:47.300
不然早就结束了

12:47.300 --> 12:48.300
所以说

12:48.300 --> 12:49.300
这个地方我们只看

12:49.300 --> 12:51.300
在小于90的大前提下

12:51.300 --> 12:53.300
是不是大于90

12:53.300 --> 12:54.300
好

12:54.300 --> 12:56.300
如果条件运行到这

12:56.300 --> 12:58.300
是不是就隐含了一个条件

12:58.300 --> 13:00.300
前面这个一定是小于70的

13:00.300 --> 13:01.300
对吧

13:01.300 --> 13:02.300
如果是大于70

13:02.300 --> 13:03.300
要么就进了第1个条件

13:03.300 --> 13:05.300
要么就进了第2个条件

13:05.300 --> 13:06.300
不会进第3个条件

13:06.300 --> 13:07.300
所以说

13:07.300 --> 13:09.300
如果进行了这里的判断

13:09.300 --> 13:10.300
进行了这里的条件

13:10.300 --> 13:11.300
说明了啥呢

13:11.300 --> 13:13.300
说明了前边一定是小于70的

13:13.300 --> 13:15.300
它大前提因是小于70的

13:15.300 --> 13:17.300
因此我们没有必要再去加个条件

13:17.300 --> 13:19.300
它小于70的

13:19.300 --> 13:20.300
好

13:20.300 --> 13:21.300
那么 else 也没什么好说的

13:21.300 --> 13:22.300
都不满足

13:22.300 --> 13:24.300
都不满足就是小于50的情况

13:24.300 --> 13:25.300
前面的条件都不满足

13:25.300 --> 13:26.300
自然是小于50

13:27.300 --> 13:28.300
所以说

13:28.300 --> 13:30.300
我们这里可以减一些

13:31.300 --> 13:32.300
好

13:32.300 --> 13:34.300
这里容易犯的错误是啥呢

13:35.300 --> 13:37.300
把这一块复制一下

13:37.300 --> 13:39.300
按住鼠标中间

13:39.300 --> 13:41.300
按住鼠标滚轮按下去

13:41.300 --> 13:43.300
可以这样的框圈复制

13:43.300 --> 13:45.300
复制 张天

13:45.300 --> 13:47.300
格式化一下

13:47.300 --> 13:49.300
看一下如果我们这样子写的

13:49.300 --> 13:51.300
如果我们这样子写

13:51.300 --> 13:55.890
这样子写会怎么样

13:55.890 --> 13:57.890
首先大家分析一下

13:57.890 --> 13:59.890
如果你这样子写

13:59.890 --> 14:01.890
它是几个义父结构

14:01.890 --> 14:03.890
是不是一个义父结构呢

14:03.890 --> 14:05.890
是不是一个义父结构呢

14:05.890 --> 14:06.890
不是

14:06.890 --> 14:08.890
你看我们这里说的语法

14:08.890 --> 14:10.890
这个可以出现多个

14:10.890 --> 14:12.890
这个可以出现凝个或一个

14:12.890 --> 14:14.890
但是这个只能出现一个

14:14.890 --> 14:16.890
只能出现一个

14:16.890 --> 14:17.890
好 这里记一下

14:17.890 --> 14:18.890
义父

14:18.890 --> 14:19.890
义父框

14:20.890 --> 14:21.890
只能出现

14:21.890 --> 14:23.890
义父只能出现一次

14:23.890 --> 14:25.890
只能出现一次

14:25.890 --> 14:27.890
也就是说这里呢

14:27.890 --> 14:29.890
是有三个义父框

14:29.890 --> 14:31.890
三个义父判断

14:31.890 --> 14:32.890
这是第一个

14:32.890 --> 14:33.890
就写完了

14:33.890 --> 14:34.890
它没有写 else 义父

14:34.890 --> 14:35.890
没有写 else

14:35.890 --> 14:37.890
那么这个这个框就完了

14:37.890 --> 14:38.890
好 这个框

14:38.890 --> 14:39.890
这个框

14:39.890 --> 14:40.890
就是三个义父框

14:40.890 --> 14:42.890
好 那么它怎么运行的呢

14:42.890 --> 14:43.890
它这样的运行的

14:43.890 --> 14:45.890
首先判断一下分数

14:45.890 --> 14:47.890
是不是大约等于90

14:47.890 --> 14:50.890
如果条件成立运行它

14:50.890 --> 14:53.890
如果条件不成立

14:53.890 --> 14:55.890
结束了 啥都不做

14:55.890 --> 14:56.890
啥都不做

14:56.890 --> 14:59.890
好 第一个义父框结束

14:59.890 --> 15:01.890
好 接下来再运行第二个义父框

15:01.890 --> 15:03.890
你看他们之间是互不干扰的

15:03.890 --> 15:05.890
不能说他的条件不满足

15:05.890 --> 15:07.890
会影响他的条件判断 不会的

15:07.890 --> 15:09.890
因为他们是不同的义父框

15:09.890 --> 15:11.890
他是一个是独立的

15:11.890 --> 15:13.890
所以说他们会独立的进行判断

15:13.890 --> 15:15.890
然后再判断条件

15:15.890 --> 15:17.890
不管他们满不满足

15:17.890 --> 15:18.890
不管第一个条件满不满足

15:18.890 --> 15:20.890
他都会判断第二个条件

15:20.890 --> 15:23.890
因为他是不同的代码框

15:23.890 --> 15:24.890
好 那么第二个条件判断

15:24.890 --> 15:25.890
那你想啊

15:25.890 --> 15:28.890
如果一个用户的分数是95分

15:28.890 --> 15:30.890
你想这个道理

15:30.890 --> 15:32.890
他是不是会进这个义父

15:32.890 --> 15:33.890
判断为真

15:33.890 --> 15:35.890
如果分数大于等于90

15:35.890 --> 15:37.890
那么他会进这个书出A

15:37.890 --> 15:39.890
然后又去判断这个玩意儿

15:39.890 --> 15:41.890
是不是又会书出B

15:41.890 --> 15:44.890
因为95是大于等于70的

15:44.890 --> 15:46.890
所以说也会书出B

15:46.890 --> 15:48.890
好 第三个义父框

15:48.890 --> 15:49.890
是不是也会书出C

15:49.890 --> 15:51.890
对吧 也会书出C

15:51.890 --> 15:53.890
会不会书出D呢

15:53.890 --> 15:54.890
不会 不会

15:54.890 --> 15:55.890
为什么不会呢

15:55.890 --> 15:57.890
因为95大于等于50

15:57.890 --> 15:58.890
没问题 书出C

15:58.890 --> 15:59.890
好 这个条件满足了

15:59.890 --> 16:02.890
这个AOS是属于这个条件判断框的

16:02.890 --> 16:04.890
属于这个义父判断框的

16:04.890 --> 16:05.890
所以说呢

16:05.890 --> 16:06.890
这个条件满足了

16:06.890 --> 16:08.890
他就不会去运行AOS

16:08.890 --> 16:09.890
不会去运行AOS

16:09.890 --> 16:11.890
这是一块 要搞清楚

16:11.890 --> 16:13.890
所以这个会书出什么呢

16:13.890 --> 16:15.890
会书出ABC

16:15.890 --> 16:17.890
保存看一下

16:17.890 --> 16:19.890
书出ABC

16:19.890 --> 16:21.890
好 这是这个点

16:21.890 --> 16:22.890
大家要注意一下

16:22.890 --> 16:24.890
如果你要用三个义父代码框

16:24.890 --> 16:25.890
来判断的话

16:25.890 --> 16:27.890
那里只能牢牢实实

16:27.890 --> 16:29.890
把这些条件写全

16:29.890 --> 16:30.890
写全

16:30.890 --> 16:31.890
因为他们是独立判断的

16:31.890 --> 16:32.890
互补影响

16:32.890 --> 16:34.890
你得把这些东西写全

16:34.890 --> 16:35.890
写全上就可以了

16:35.890 --> 16:37.890
写全上过后就没问题了

16:37.890 --> 16:38.890
保存看一下

16:38.890 --> 16:40.890
还有D

16:40.890 --> 16:41.890
还有D

16:41.890 --> 16:43.890
D呢 我们这里要用AOS义父

16:43.890 --> 16:44.890
AOS义父

16:44.890 --> 16:46.890
或者直接再写个义父吧

16:46.890 --> 16:47.890
再写个义父

16:47.890 --> 16:49.890
如果score小于的50

16:49.890 --> 16:51.890
再写个义父

16:51.890 --> 16:53.890
保存看一下

16:53.890 --> 16:54.890
那么现在就没问题了

16:54.890 --> 16:55.890
你要这样子写

16:55.890 --> 16:57.890
就是每一个条件的独立判断

16:57.890 --> 16:58.890
独立判断

16:58.890 --> 16:59.890
当然这种写法

16:59.890 --> 17:01.890
肯定是没有前面的写法好

17:01.890 --> 17:03.890
因为前面的本来逻辑上

17:03.890 --> 17:04.890
从逻辑上来讲

17:04.890 --> 17:05.890
本来就应该

17:05.890 --> 17:07.890
本来就应该就是

17:07.890 --> 17:08.890
他们是一块逻辑

17:08.890 --> 17:09.890
一块的条件判断

17:09.890 --> 17:10.890
而不是分开的

17:10.890 --> 17:12.890
没有必要分开

17:12.890 --> 17:14.890
所以第一种写法更好一点

17:14.890 --> 17:15.890
而第二种写法

17:15.890 --> 17:17.890
它还会影响执行效率

17:17.890 --> 17:19.890
会稍微的影响一下执行效率

17:19.890 --> 17:20.890
因为你看

17:20.890 --> 17:21.890
就第一个条件已经满足了

17:21.890 --> 17:23.890
是不是结果已经确定了

17:23.890 --> 17:25.890
但是它仍然会去判断这个条件

17:25.890 --> 17:27.890
仍然会去判断这个条件

17:27.890 --> 17:29.890
以及这个条件都会去判断

17:29.890 --> 17:30.890
它会影响执行效率

17:30.890 --> 17:33.890
它判断的条件更多

17:33.890 --> 17:36.890
这是关于这一块

17:37.890 --> 17:39.890
这个条件判断这里

17:39.890 --> 17:41.890
由于它这个特点

17:41.890 --> 17:42.890
还容易出面试题

17:42.890 --> 17:44.890
给它看一下

17:44.890 --> 17:47.890
之前有道面试题是这样子

17:47.890 --> 17:48.890
大概意思是这样子

17:48.890 --> 17:49.890
原题我记不清楚了

17:49.890 --> 17:50.890
大概意思是这样子

17:50.890 --> 17:52.890
一个X

17:52.890 --> 17:54.890
为1

17:54.890 --> 17:56.890
然后判断

17:56.890 --> 17:58.890
X++是否是大于等于1

17:58.890 --> 18:01.890
如果大于等于1的话

18:01.890 --> 18:03.890
X++

18:03.890 --> 18:04.890
然后Ls

18:04.890 --> 18:05.890
if

18:05.890 --> 18:06.890
++X

18:06.890 --> 18:08.890
是不是大于等于2

18:08.890 --> 18:09.890
如果4的话

18:09.890 --> 18:10.890
X++

18:10.890 --> 18:11.890
好

18:11.890 --> 18:13.890
Ls

18:13.890 --> 18:15.890
Ls的话

18:15.890 --> 18:17.890
X-

18:17.890 --> 18:18.890
好

18:18.890 --> 18:20.890
最后输出X

18:20.890 --> 18:23.890
看一下这个代码

18:23.890 --> 18:24.890
分析一下

18:24.890 --> 18:26.890
这个代码输出啥

18:26.890 --> 18:27.890
它为你

18:27.890 --> 18:28.890
大概是这个意思

18:28.890 --> 18:29.890
原题我记不清楚了

18:29.890 --> 18:31.890
它考察的就是这个点

18:31.890 --> 18:33.890
它输出啥

18:33.890 --> 18:34.890
好

18:34.890 --> 18:36.890
我们来看一下

18:36.890 --> 18:38.890
X的值是1

18:38.890 --> 18:40.890
首先运行这个判断

18:40.890 --> 18:42.890
这个判断里边有条件

18:42.890 --> 18:43.890
运行这个条件

18:43.890 --> 18:44.890
表达是拿出来

18:44.890 --> 18:45.890
表达是拿出来

18:45.890 --> 18:47.890
看一下表达是

18:47.890 --> 18:48.890
X++

18:48.890 --> 18:49.890
然后自征1

18:49.890 --> 18:50.890
返回之前的值1

18:50.890 --> 18:51.890
对吧

18:51.890 --> 18:53.890
1是不大于等于1

18:53.890 --> 18:54.890
对不对

18:54.890 --> 18:55.890
说明了

18:55.890 --> 18:57.890
第一个条件满足

18:57.890 --> 18:58.890
第一个条件满足

18:58.890 --> 19:00.890
于是又运行了X++

19:00.890 --> 19:01.890
满足

19:01.890 --> 19:02.890
它就运行里边的东西

19:02.890 --> 19:04.890
运行了X++

19:04.890 --> 19:06.890
又运行X++

19:06.890 --> 19:07.890
它就加1的

19:07.890 --> 19:08.890
变成3

19:08.890 --> 19:09.890
好

19:09.890 --> 19:10.890
接下来的问题是

19:10.890 --> 19:11.890
问题是啥

19:11.890 --> 19:13.890
这个条件看不看

19:13.890 --> 19:15.890
要不要运行这个条件

19:15.890 --> 19:17.890
是不是不运行的

19:17.890 --> 19:19.890
后边的条件已经满足了

19:19.890 --> 19:20.890
后边的条件就不运行的

19:20.890 --> 19:21.890
运都不运行的

19:21.890 --> 19:22.890
看都不看了

19:22.890 --> 19:23.890
直接看不见

19:23.890 --> 19:24.890
直接扔掉

19:24.890 --> 19:25.890
好

19:25.890 --> 19:26.890
最后输出X

19:26.890 --> 19:27.890
X的值是多少呢

19:27.890 --> 19:28.890
是多少呢

19:28.890 --> 19:32.100
保存

19:32.100 --> 19:33.100
看一下

19:33.100 --> 19:34.100
看一下

19:34.100 --> 19:35.100
是不是3

19:35.100 --> 19:36.100
对不对

19:36.100 --> 19:37.100
结果就是3

19:37.100 --> 19:38.100
好

19:38.100 --> 19:39.100
有些题呢

19:39.100 --> 19:40.100
它可能会这样子

19:40.100 --> 19:41.100
可能会这样子

19:41.100 --> 19:43.100
我们来看一下

19:43.100 --> 19:45.100
它这样子来写

19:45.100 --> 19:46.100
就怎么写呢

19:46.100 --> 19:47.100
给它写一下

19:47.100 --> 19:49.100
它这样子写

19:50.100 --> 19:51.100
我们这里

19:51.100 --> 19:53.100
这样子看一下

19:55.100 --> 19:56.100
然后这上面

19:56.100 --> 19:57.100
我们这样子写

19:57.100 --> 19:59.100
判断X

19:59.100 --> 20:01.100
感叹号

20:01.100 --> 20:03.100
然后X等于1

20:03.100 --> 20:04.100
看一下

20:04.100 --> 20:05.100
看一下这道题

20:05.100 --> 20:06.100
这道题

20:06.100 --> 20:08.100
我们首先判断它

20:08.100 --> 20:10.100
会不会爆错

20:10.100 --> 20:12.100
会不会爆错

20:12.100 --> 20:14.100
扎一看

20:14.100 --> 20:15.100
好像是应该爆错

20:15.100 --> 20:17.100
因为你使用了一个

20:17.100 --> 20:19.100
并没有声明的变量

20:19.100 --> 20:20.100
程序运行到这的时候呢

20:20.100 --> 20:22.100
变量还没有声明

20:22.100 --> 20:23.100
所以说它会爆错

20:23.100 --> 20:24.100
但是那你实际上

20:24.100 --> 20:26.100
你指着X看一下

20:26.100 --> 20:27.100
它都在提示里的

20:27.100 --> 20:28.100
这个变量有声明

20:28.100 --> 20:29.100
它的声明呢

20:29.100 --> 20:31.100
它的值是undefend

20:31.100 --> 20:32.100
它的值是undefend

20:32.100 --> 20:34.100
怎么回事呢

20:34.100 --> 20:36.100
我们之前讲过这个问题的

20:36.100 --> 20:38.100
在哪里讲过

20:38.100 --> 20:40.100
在语法基础这一块就讲过了

20:40.100 --> 20:42.100
我怎么说的

20:42.100 --> 20:43.100
我说

20:43.100 --> 20:45.100
在我们的解释程序里边呢

20:45.100 --> 20:47.100
有一个变量提升

20:47.100 --> 20:49.100
你声明的变量

20:49.100 --> 20:51.100
它会被提升到

20:51.100 --> 20:54.100
脚笨块的第一行

20:54.100 --> 20:55.100
会被提升到

20:55.100 --> 20:56.100
脚笨块的第一行

20:56.100 --> 20:58.100
相当于是这样子写

20:58.100 --> 21:00.100
那这样子写的过后

21:00.100 --> 21:01.100
X是不是undefend的

21:01.100 --> 21:02.100
没复制嘛

21:02.100 --> 21:04.100
没复制就是undefend的

21:04.100 --> 21:05.100
没问题吧

21:05.100 --> 21:06.100
就没有问题

21:06.100 --> 21:07.100
你看它有变量提升

21:07.100 --> 21:08.100
虽然说你

21:08.100 --> 21:10.100
好像变量定义在这一块的

21:10.100 --> 21:12.100
如果没有进这个判断的话

21:12.100 --> 21:13.100
如果没有进这个判断的话

21:13.100 --> 21:15.100
好像这里的X运行不了

21:15.100 --> 21:16.100
运行不了

21:16.100 --> 21:18.100
那么它就没有X

21:18.100 --> 21:20.100
它不是这样子看的

21:20.100 --> 21:22.100
哪怕你把X设为0

21:22.100 --> 21:23.100
设为0

21:23.100 --> 21:25.100
它就算进不了这个判断

21:25.100 --> 21:26.100
它也会提升

21:26.100 --> 21:28.100
提升到坠上面去

21:28.100 --> 21:29.100
所以说呢

21:29.100 --> 21:31.100
我们就假设设为0嘛

21:31.100 --> 21:32.100
所以说呢

21:32.100 --> 21:34.100
这一块

21:34.100 --> 21:38.100
应该是存在的

21:38.100 --> 21:40.100
它的值是undefend的

21:40.100 --> 21:42.100
首先我们来确定

21:42.100 --> 21:43.100
X的值

21:43.100 --> 21:45.100
它是undefend的

21:45.100 --> 21:47.100
undefend的时候呢

21:47.100 --> 21:49.100
我们首先运行这个判断

21:49.100 --> 21:50.100
这是两个义父判断

21:50.100 --> 21:51.100
这是第一个

21:51.100 --> 21:52.100
第二个

21:52.100 --> 21:53.100
两个义父判断

21:53.100 --> 21:54.100
先运行它

21:54.100 --> 21:56.100
运行它的时候

21:56.100 --> 21:58.100
感叹号X

21:58.100 --> 22:00.100
感叹号X怎么看呢

22:00.100 --> 22:02.100
进行布尔判定

22:02.100 --> 22:04.100
对它取反吧

22:04.100 --> 22:05.100
进行布尔判定

22:05.100 --> 22:07.100
它的布尔判定是什么呢

22:07.100 --> 22:08.100
X的布尔判定

22:08.100 --> 22:09.100
是不是force

22:09.100 --> 22:10.100
对吧

22:10.100 --> 22:11.100
force

22:11.100 --> 22:13.100
加上个感叹号是不是true

22:13.100 --> 22:14.100
取反

22:14.100 --> 22:15.100
就是true

22:15.100 --> 22:17.100
所以说第一个条件满足

22:17.100 --> 22:19.100
你应该怎么来读这个代码呢

22:19.100 --> 22:20.100
读的话非常简单

22:20.100 --> 22:23.100
其实我们这个代码以后会经常见到

22:23.100 --> 22:25.100
就是如果X不存在

22:25.100 --> 22:26.100
或者是

22:26.100 --> 22:27.100
如果X没有值

22:27.100 --> 22:28.100
或者是

22:28.100 --> 22:30.100
如果X没有被负值

22:30.100 --> 22:31.100
就是这个意思

22:31.100 --> 22:33.100
你这样一读就读通了

22:33.100 --> 22:35.100
如果X没有负值

22:35.100 --> 22:37.100
X不存在

22:37.100 --> 22:38.100
那么怎么办呢

22:38.100 --> 22:40.100
给它负值为0

22:40.100 --> 22:41.100
给它负值为0

22:41.100 --> 22:43.100
它就变成0了

22:43.100 --> 22:44.100
好

22:44.100 --> 22:45.100
接下来再来判断

22:45.100 --> 22:48.100
下面的这个结构

22:48.100 --> 22:49.100
好

22:49.100 --> 22:50.100
然后再来判断

22:50.100 --> 22:51.100
X加加

22:51.100 --> 22:53.100
是不是大于等于1呢

22:53.100 --> 22:55.100
是不是大于等于1呢

22:55.100 --> 22:57.100
X加加就是它自征1

22:57.100 --> 22:58.100
自征1

22:58.100 --> 22:59.100
然后这里去自征之前的值

22:59.100 --> 23:00.100
就是0

23:00.100 --> 23:01.100
0是不是大于等于1

23:01.100 --> 23:02.100
是不是force

23:02.100 --> 23:03.100
对吧

23:03.100 --> 23:05.100
这个条件不满足

23:05.100 --> 23:06.100
不满足

23:06.100 --> 23:07.100
然后又看LC

23:07.100 --> 23:08.100
又看这

23:08.100 --> 23:10.100
又看这个条件

23:10.100 --> 23:11.100
好

23:11.100 --> 23:12.100
这个条件

23:12.100 --> 23:13.100
加加X自征1

23:13.100 --> 23:14.100
变成2

23:14.100 --> 23:16.100
返回自征之后的值

23:16.100 --> 23:17.100
就是2

23:17.100 --> 23:19.100
2是不是大于等于2呢

23:19.100 --> 23:20.100
4

23:20.100 --> 23:21.100
所以说

23:21.100 --> 23:23.100
进入这个判断

23:23.100 --> 23:24.100
进入这个判断

23:24.100 --> 23:25.100
X加加

23:25.100 --> 23:26.100
又自征1

23:26.100 --> 23:27.100
变成了3

23:27.100 --> 23:28.100
变成了3

23:28.100 --> 23:29.100
变成了3

23:29.100 --> 23:30.100
好

23:30.100 --> 23:31.100
最终LC看不看

23:31.100 --> 23:32.100
就不看了

23:32.100 --> 23:33.100
那么最终就输出3

23:33.100 --> 23:35.100
保存看一下

23:35.100 --> 23:37.100
结果还是3

23:37.100 --> 23:38.100
没问题吧

23:38.100 --> 23:39.100
这是这一块

23:39.100 --> 23:41.100
不要被绕晕了

23:41.100 --> 23:43.100
这一块有变量作用率提升

23:43.100 --> 23:45.100
提升到第1行

23:45.100 --> 23:47.100
这是关于这一块

23:47.100 --> 23:48.100
好

23:48.100 --> 23:50.100
其实我们讲了目前为止

23:50.100 --> 23:52.100
判断这一块就讲完了

23:52.100 --> 23:53.100
非常非常简单

23:53.100 --> 23:55.100
然后我们这里补充一个知识

23:55.100 --> 23:57.100
补充知识

23:57.100 --> 23:59.100
补充

23:59.100 --> 24:01.100
就是关于用户输入

24:01.100 --> 24:02.100
因为我们今天的作业里边

24:02.100 --> 24:04.100
有用户输入

24:04.100 --> 24:06.100
用户输入使用什么语句呢

24:06.100 --> 24:08.100
使用这个语句

24:08.100 --> 24:10.100
叫propt

24:10.100 --> 24:11.100
好

24:11.100 --> 24:12.100
这里边

24:12.100 --> 24:13.100
它是一个函数

24:13.100 --> 24:16.410
我们之前也用过很多函数

24:16.410 --> 24:18.410
console log

24:18.410 --> 24:20.410
两个小课号里边写的东西

24:20.410 --> 24:21.410
它就能输出

24:21.410 --> 24:23.410
那么这个propt

24:23.410 --> 24:25.410
它是这么一个函数

24:25.410 --> 24:27.410
这个函数里边

24:27.410 --> 24:29.410
它是用来输入的

24:29.410 --> 24:31.410
用来输入的

24:31.410 --> 24:32.410
好

24:32.410 --> 24:34.410
这个小课号里边可以传啥呢

24:34.410 --> 24:36.410
这个小课号里边

24:37.410 --> 24:39.410
这个小课号里边可以传啥呢

24:39.410 --> 24:40.410
可以啥都不传

24:40.410 --> 24:41.410
啥都不传

24:41.410 --> 24:43.410
我们来看一下函数调整的结果

24:43.410 --> 24:44.410
看一下

24:44.410 --> 24:46.410
你看就坦出这么个东西

24:46.410 --> 24:47.410
这是它的作用

24:47.410 --> 24:48.410
非常非常简单

24:48.410 --> 24:49.410
就坦出这么个东西

24:49.410 --> 24:50.410
让用户输入

24:50.410 --> 24:51.410
用户输入

24:51.410 --> 24:52.410
好

24:52.410 --> 24:54.410
函数也是个表达式

24:54.410 --> 24:56.410
这也是个表达式

24:56.410 --> 24:57.410
也是个表达式

24:57.410 --> 24:58.410
好

24:58.410 --> 24:59.410
我们来说一下

24:59.410 --> 25:00.410
propt

25:00.410 --> 25:04.110
这样子写

25:04.110 --> 25:05.110
好

25:05.110 --> 25:07.110
我这里先说一个点

25:07.110 --> 25:10.110
就这里个小课号里边还可以写东西

25:10.110 --> 25:11.110
还可以写东西

25:11.110 --> 25:13.110
就是小课号里边不写的话

25:13.110 --> 25:14.110
就什么就是这样子

25:14.110 --> 25:15.110
就这个样子

25:15.110 --> 25:17.110
小课号里边什么都不写的话就这样子

25:17.110 --> 25:18.110
可以写东西

25:18.110 --> 25:19.110
写什么东西呢

25:19.110 --> 25:20.110
写一个字符串

25:20.110 --> 25:23.110
一个字符串表示的是提示文本

25:23.110 --> 25:24.110
提示文本

25:24.110 --> 25:25.110
好

25:25.110 --> 25:26.110
咱们来看一下

25:26.110 --> 25:28.110
这里我写个字符串

25:28.110 --> 25:30.110
提示文本

25:30.110 --> 25:31.110
我要请输入啥

25:31.110 --> 25:33.110
请输入你的年龄

25:33.110 --> 25:35.110
比方说请输入你的年龄

25:35.110 --> 25:36.110
好

25:36.110 --> 25:37.110
保存看一下

25:37.110 --> 25:38.110
看一下

25:38.110 --> 25:39.110
我们这里先取消

25:39.110 --> 25:40.110
再重新刷新

25:40.110 --> 25:41.110
重新刷新

25:41.110 --> 25:42.110
刷新

25:42.110 --> 25:43.110
你看

25:43.110 --> 25:44.110
能看清楚吗

25:44.110 --> 25:46.110
请输入你的年龄

25:46.110 --> 25:47.110
我这里没发放大

25:47.110 --> 25:48.110
能看清楚吗

25:48.110 --> 25:49.110
请输入你的年龄

25:49.110 --> 25:51.110
这个提示文本就出来了

25:51.110 --> 25:52.110
就这么个简单

25:52.110 --> 25:53.110
非常简单

25:53.110 --> 25:54.110
好

25:54.110 --> 25:55.110
那么这个东西

25:55.110 --> 25:57.110
我怎么来获取用户的输入呢

25:57.110 --> 25:58.110
用户输入过后点确定

25:58.110 --> 25:59.110
我怎么来获取呢

25:59.110 --> 26:01.110
比方说用户在这里输入一些东西

26:01.110 --> 26:02.110
点确定

26:02.110 --> 26:03.110
好

26:03.110 --> 26:05.110
我怎么来获取用户的输入呢

26:05.110 --> 26:06.110
好

26:06.110 --> 26:07.110
这里

26:07.110 --> 26:09.110
该表达是

26:09.110 --> 26:11.110
该表达是

26:11.110 --> 26:13.110
返回结果

26:13.110 --> 26:15.110
情况有三种

26:15.110 --> 26:16.110
第一种了

26:16.110 --> 26:17.110
返回闹

26:17.110 --> 26:19.110
返回闹表示什么意思呢

26:19.110 --> 26:22.110
表示用户点击了取消

26:22.110 --> 26:24.110
用户点击了取消

26:24.110 --> 26:25.110
好

26:25.110 --> 26:26.110
比方说

26:26.110 --> 26:27.110
比方说我们这里点取消

26:27.110 --> 26:30.110
那么这个表达是返回的就是闹

26:30.110 --> 26:32.110
这同时也说明了啥呢

26:32.110 --> 26:34.110
同时也说明了一个问题

26:34.110 --> 26:36.110
就是这个表达是

26:36.110 --> 26:38.110
就是这个函数调用表达是

26:38.110 --> 26:39.110
它会卡代码

26:39.110 --> 26:41.110
它会把代码卡住

26:41.110 --> 26:43.110
不让代码往后边运行

26:43.110 --> 26:44.110
不让代码往后边运行

26:44.110 --> 26:46.110
必须要等到用户操作之后

26:46.110 --> 26:48.110
它才会继续运行

26:48.110 --> 26:50.110
是这么个意思

26:50.110 --> 26:51.110
那么我们现在知道了

26:51.110 --> 26:53.110
这个表达是返回的是一个制幅串

26:53.110 --> 26:54.110
因此

26:54.110 --> 26:55.110
返回的是有可能返回一个闹

26:55.110 --> 26:57.110
我们可以用变量来接受一下

26:57.110 --> 26:58.110
比方说

26:58.110 --> 27:01.110
用户的输入结果

27:01.110 --> 27:02.110
这个绿绕是什么意思呢

27:02.110 --> 27:03.110
我们打个注释

27:03.110 --> 27:04.110
这注释打一下

27:04.110 --> 27:05.110
所以什么意思

27:05.110 --> 27:07.110
就是提示

27:07.110 --> 27:10.110
等待用户输入

27:10.110 --> 27:13.110
这是等待用户输入

27:13.110 --> 27:17.110
将用户操作的结果

27:17.110 --> 27:19.110
应该说等待用户操作

27:19.110 --> 27:21.110
什么叫做用户操作

27:21.110 --> 27:22.110
就是点确定

27:22.110 --> 27:23.110
点取消

27:23.110 --> 27:24.110
就是操作

27:24.110 --> 27:26.110
确定取消

27:26.110 --> 27:28.110
如果用户没有点的话

27:28.110 --> 27:29.110
会一直卡住

27:29.110 --> 27:30.110
会一直卡住

27:30.110 --> 27:32.110
不会往后面运行

27:32.110 --> 27:33.110
等待用户操作

27:33.110 --> 27:35.110
点确定或者是取消

27:35.110 --> 27:37.110
将用户操作的结果

27:37.110 --> 27:39.110
保存到变量

27:39.110 --> 27:41.110
result中

27:41.110 --> 27:43.610
就这么个意思

27:43.610 --> 27:44.610
保存看一下

27:44.610 --> 27:46.610
看一下我们这里输出

27:46.610 --> 27:49.610
输出这个result

27:49.610 --> 27:50.610
保存看一下

27:50.610 --> 27:52.610
我们先点取消

27:52.610 --> 27:53.610
重新刷新也是

27:53.610 --> 27:55.610
把f12打开

27:55.610 --> 27:57.610
点击刷新

27:57.610 --> 27:58.610
这个时候你看一下

27:58.610 --> 28:00.610
代码里边有没有任何输出

28:00.610 --> 28:01.610
有没有输出

28:01.610 --> 28:03.610
控制台里边有没有输出

28:03.610 --> 28:04.610
是不是没有输出

28:04.610 --> 28:05.610
为什么没有输出

28:05.610 --> 28:07.610
现在代码还卡住的

28:07.610 --> 28:08.610
卡在哪

28:08.610 --> 28:09.610
卡在这一句话

28:09.610 --> 28:11.610
现在没有往后运行

28:11.610 --> 28:13.610
代码从上到下进行运行的

28:13.610 --> 28:15.610
上一句话没有运行完

28:15.610 --> 28:17.610
下一句话一定要等着

28:17.610 --> 28:19.610
等着它运行完

28:19.610 --> 28:20.610
现在我框住这一部分

28:20.610 --> 28:21.610
还没有运行完

28:21.610 --> 28:23.610
现在连复制都还没有复制

28:23.610 --> 28:25.610
现在都还没有复制

28:25.610 --> 28:26.610
因为要等它运行完了

28:26.610 --> 28:27.610
过后才能完成复制

28:27.610 --> 28:29.610
这就是我之前说的

28:29.610 --> 28:31.610
js是一个单线程的

28:31.610 --> 28:33.610
同步运用程序

28:33.610 --> 28:35.610
前面都没运行完

28:35.610 --> 28:36.610
后面一直要等着

28:36.610 --> 28:38.610
这句话一直卡住了

28:38.610 --> 28:39.610
等在里运行

28:39.610 --> 28:41.610
如果你点击了取消

28:41.610 --> 28:43.610
看一下

28:43.610 --> 28:45.610
点击了取消过后

28:45.610 --> 28:47.610
这个表达是得到的结果是

28:47.610 --> 28:48.610
nau

28:48.610 --> 28:50.610
它就把nau的复制给它result

28:50.610 --> 28:52.610
然后我们输出result得到的是什么

28:52.610 --> 28:54.610
得到的就是nau

28:54.610 --> 28:56.610
就这么简单

28:56.610 --> 28:57.610
这是关于

28:57.610 --> 28:59.610
当用户点击取消的时候

28:59.610 --> 29:00.610
是nau

29:00.610 --> 29:02.610
第二个

29:02.610 --> 29:04.610
如果用户

29:04.610 --> 29:06.610
应该这样说

29:06.610 --> 29:08.610
第二种情况就是

29:08.610 --> 29:10.610
制服串

29:10.610 --> 29:12.610
用户输入的制服串

29:12.610 --> 29:14.610
表示

29:14.610 --> 29:16.610
用户点击了确定

29:16.610 --> 29:21.610
得到用户输入的结果

29:21.610 --> 29:23.610
那么这个输入结果是什么类型

29:23.610 --> 29:24.610
是一个制服串

29:24.610 --> 29:25.610
是一个制服串

29:25.610 --> 29:27.610
咱们来看一下

29:27.610 --> 29:29.610
这里边我们输入一些东西随便一些

29:29.610 --> 29:30.610
点确定

29:30.610 --> 29:31.610
你看

29:31.610 --> 29:33.610
得到了用户的输入

29:33.610 --> 29:34.610
看到没

29:34.610 --> 29:35.610
这个表达是

29:35.610 --> 29:37.610
因为一开始为什么没讲这个东西呢

29:37.610 --> 29:39.610
因为一开始还没有学习表达是

29:39.610 --> 29:41.610
你都不知道反回类型是什么

29:41.610 --> 29:42.610
那么现在我可以告诉你

29:42.610 --> 29:44.610
这个地方的反回类型

29:44.610 --> 29:45.610
是一个制服串

29:45.610 --> 29:47.610
制服串会nau或者是nau

29:47.610 --> 29:49.610
所以说它的反回类型

29:49.610 --> 29:50.610
反回类型

29:50.610 --> 29:51.610
这个表达是反回类型

29:51.610 --> 29:53.610
是nau

29:53.610 --> 29:55.610
或者是制服串

29:55.610 --> 29:56.610
只有这两种情况

29:56.610 --> 29:57.610
没有其他情况

29:57.610 --> 29:58.610
要么是nau

29:58.610 --> 29:59.610
要么是制服串

29:59.610 --> 30:01.610
比方说

30:01.610 --> 30:02.610
随便输个数字

30:02.610 --> 30:03.610
好像是一个数字

30:03.610 --> 30:04.610
但是你看一下

30:04.610 --> 30:05.610
它是黑色的对吧

30:05.610 --> 30:06.610
黑色的我们知道

30:06.610 --> 30:07.610
是一个制服串

30:07.610 --> 30:08.610
是一个制服串

30:08.610 --> 30:09.610
我们也可以这样子

30:09.610 --> 30:10.610
也可以这样子

30:11.610 --> 30:12.610
都好

30:12.610 --> 30:13.610
Type

30:13.610 --> 30:16.610
Type result

30:16.610 --> 30:18.610
保存看一下

30:18.610 --> 30:19.610
如果点击取消

30:19.610 --> 30:20.610
是nau

30:20.610 --> 30:21.610
我们之前说过nau

30:21.610 --> 30:22.610
比较特殊

30:22.610 --> 30:23.610
它本来是一个特殊类型的

30:23.610 --> 30:24.610
但是呢

30:24.610 --> 30:25.610
用Type算出来

30:25.610 --> 30:27.610
它是一个object

30:27.610 --> 30:28.610
比方再刷新

30:28.610 --> 30:29.610
再刷新

30:29.610 --> 30:30.610
重新来一次

30:30.610 --> 30:31.610
输入一个123点确定

30:31.610 --> 30:32.610
你看是一个制服串

30:32.610 --> 30:34.610
注意它是个制服串

30:34.610 --> 30:35.610
好吧

30:35.610 --> 30:36.610
这是关于这一块

30:36.610 --> 30:37.610
这一块

30:38.610 --> 30:40.610
如果你啥都不甜呢

30:40.610 --> 30:41.610
如果你啥都不甜呢

30:41.610 --> 30:43.610
直接点确定了

30:43.610 --> 30:44.610
还是一个制服串

30:44.610 --> 30:45.610
就是一个空制服串

30:45.610 --> 30:46.610
空制服串

30:46.610 --> 30:47.610
是不是还是制服串

30:47.610 --> 30:48.610
你看这个

30:48.610 --> 30:50.610
这是个空制服串吧

30:50.610 --> 30:51.610
而没有写任何东西

30:51.610 --> 30:52.610
它还是一个制服串

30:52.610 --> 30:53.610
还是个制服串

30:53.610 --> 30:54.610
所以这里呢

30:54.610 --> 30:55.610
反回它只有两种情况

30:55.610 --> 30:57.610
制服串或者是nau

30:58.610 --> 30:59.610
好了

30:59.610 --> 31:00.610
那么接下来

31:00.610 --> 31:01.610
我们有的时候

31:01.610 --> 31:02.610
有可能

31:02.610 --> 31:03.610
有可能呢

31:03.610 --> 31:05.610
我们会需要

31:05.610 --> 31:08.610
对这个制服串进行转换

31:08.610 --> 31:09.610
进行转换

31:10.610 --> 31:11.610
这里说一下

31:12.610 --> 31:14.610
再补充一个知识

31:14.610 --> 31:15.610
就是对制服串

31:15.610 --> 31:18.610
对制服串进行

31:18.610 --> 31:19.610
转换

31:19.610 --> 31:20.610
转换成数字

31:20.610 --> 31:21.610
转换成数字

31:21.610 --> 31:22.610
以前呢

31:22.610 --> 31:23.610
它都是自动转换的

31:23.610 --> 31:24.610
对吧有的时候

31:24.610 --> 31:25.610
我们需要手动转换

31:25.610 --> 31:29.610
将制服串转换成数字

31:29.610 --> 31:30.610
转换成数字

31:30.610 --> 31:32.610
怎么转呢

31:32.610 --> 31:34.610
有一种非常非常巧妙的办法

31:34.610 --> 31:35.610
进行转换

31:35.610 --> 31:37.610
什么办法呢

31:37.610 --> 31:39.610
就这样子

31:39.610 --> 31:40.610
制服串

31:40.610 --> 31:42.610
前面加上一个正数

31:42.610 --> 31:43.610
加上一个正号

31:43.610 --> 31:45.610
所以转换了

31:45.610 --> 31:46.610
之前我们讲运算服的

31:46.610 --> 31:47.610
是不是说过的

31:47.610 --> 31:48.610
对吧

31:48.610 --> 31:50.610
这是一个算数运算服

31:50.610 --> 31:52.610
表示这个数字是正数

31:52.610 --> 31:53.610
那么后边

31:53.610 --> 31:54.610
如果是其他内行的话

31:54.610 --> 31:56.610
它直接转换成数字

31:56.610 --> 31:58.610
直接转换成数字

31:58.610 --> 31:59.610
就这么个意思

31:59.610 --> 32:00.610
咱们来看一下

32:01.610 --> 32:02.610
我们这里比方说

32:02.610 --> 32:04.610
一个正号加上一个制服串

32:04.610 --> 32:06.610
加上一个制服串

32:06.610 --> 32:07.610
如果是一个空的制服串

32:07.610 --> 32:09.610
就相当于是转换的结果是0

32:09.610 --> 32:12.610
如果是一个

32:12.610 --> 32:14.610
转换的结果就是123

32:14.610 --> 32:16.610
如果是一个制服串

32:16.610 --> 32:18.610
比方说加了一些空格123

32:18.610 --> 32:20.610
它会忽略空格

32:20.610 --> 32:21.610
会忽略空格

32:21.610 --> 32:22.610
前后的空格会忽略

32:22.610 --> 32:23.610
变成123

32:23.610 --> 32:24.610
然后

32:24.610 --> 32:25.610
如果这里边是123

32:25.610 --> 32:26.610
ABC

32:26.610 --> 32:28.610
转换出来的是NAN

32:28.610 --> 32:29.610
因为是转换不了

32:29.610 --> 32:30.610
对吧

32:30.610 --> 32:31.610
转换不了

32:31.610 --> 32:32.610
如果是这样子

32:32.610 --> 32:33.610
一空格

32:33.610 --> 32:34.610
二

32:34.610 --> 32:35.610
三

32:35.610 --> 32:36.610
中间的空格是不能忽略的

32:36.610 --> 32:38.610
转换出来的是NAN

32:38.610 --> 32:39.610
有的时候

32:39.610 --> 32:40.610
我们可以判断

32:40.610 --> 32:41.610
一个东西是不是NAN

32:41.610 --> 32:42.610
我们之前也讲过

32:42.610 --> 32:43.610
用这个函数

32:43.610 --> 32:44.610
意思NAN

32:44.610 --> 32:45.610
来判断

32:45.610 --> 32:47.610
有个东西是不是NAN

32:47.610 --> 32:48.610
比方说

32:48.610 --> 32:49.610
比方说

32:49.610 --> 32:52.610
123

32:52.610 --> 32:53.610
是不是NAN

32:53.610 --> 32:54.610
它就是去

32:54.610 --> 32:55.610
就是去

32:55.610 --> 32:56.610
对吧

32:56.610 --> 32:57.610
我们就可以用这种方式来判断

32:57.610 --> 32:58.610
它转换的

32:58.610 --> 32:59.610
有没有成功

32:59.610 --> 33:01.610
有没有成功转换

33:01.610 --> 33:02.610
转换很简单

33:02.610 --> 33:03.610
很简单

33:03.610 --> 33:04.610
比方说

33:04.610 --> 33:05.610
比方说

33:05.610 --> 33:06.610
我们这里就可以直接

33:06.610 --> 33:07.610
把Redout进行转换

33:07.610 --> 33:08.610
转换怎么转换

33:08.610 --> 33:10.610
就写个加Redout

33:10.610 --> 33:11.610
就完事了

33:11.610 --> 33:12.610
非常非常简单

33:12.610 --> 33:13.610
或者是你在前边

33:13.610 --> 33:14.610
直接加上个加

33:14.610 --> 33:15.610
这样子写也可以

33:15.610 --> 33:17.610
因为我们表达式的姿势

33:17.610 --> 33:18.610
大家都学过的

33:18.610 --> 33:20.610
把这个表达式

33:20.610 --> 33:22.610
将这个表达式

33:22.610 --> 33:23.610
转换成数字

33:23.610 --> 33:25.610
加个加好就完事了

33:25.610 --> 33:26.610
转换成数字

33:26.610 --> 33:28.610
咱们看一下

33:28.610 --> 33:29.610
现在点取消

33:29.610 --> 33:30.610
得到了是0

33:30.610 --> 33:32.610
取消的结果是NOW

33:32.610 --> 33:33.610
是NOW

33:33.610 --> 33:35.610
得到的结果是0

33:35.610 --> 33:36.610
再刷新

33:36.610 --> 33:38.610
然后我们这里写个123

33:38.610 --> 33:40.610
得到的结果是123NUM

33:40.610 --> 33:41.610
看没

33:41.610 --> 33:42.610
好

33:42.610 --> 33:44.610
现在比方说有这么个例子

33:46.610 --> 33:49.610
让用户输入一个数字

33:49.610 --> 33:51.610
输入一个数字

33:53.610 --> 33:55.610
如果输入的

33:55.610 --> 33:57.610
如果输入的

33:57.610 --> 33:58.610
如果点击了取消

33:58.610 --> 34:00.610
点击了取消

34:00.610 --> 34:02.610
输出取消

34:02.610 --> 34:04.610
就输出取消的两个字

34:04.610 --> 34:06.610
如果

34:06.610 --> 34:08.610
点击了确定

34:08.610 --> 34:09.610
根据

34:09.610 --> 34:10.610
根据什么呢

34:10.610 --> 34:12.610
根据就是输入的内容

34:12.610 --> 34:14.610
判断输入

34:14.610 --> 34:16.610
是否正确

34:16.610 --> 34:18.610
是否正确

34:18.610 --> 34:19.610
什么意思呢

34:19.610 --> 34:20.610
如果用户点击的取消

34:20.610 --> 34:21.610
我们就输出你取消了

34:21.610 --> 34:23.610
如果点击了确定

34:23.610 --> 34:24.610
如果输出了

34:24.610 --> 34:26.610
输入的东西正确的

34:26.610 --> 34:28.610
我就把你正确的东西输出就完了

34:28.610 --> 34:30.610
如果你输入的东西不正确

34:30.610 --> 34:31.610
比方说

34:31.610 --> 34:32.610
让你输入数字

34:32.610 --> 34:34.610
结果给我来一个ABC

34:34.610 --> 34:36.610
ABC或者3.1.2

34:36.610 --> 34:38.610
这种不是输出的东西

34:38.610 --> 34:41.610
我们就输出错误

34:41.610 --> 34:42.610
那么怎么做呢

34:42.610 --> 34:43.610
看着

34:43.610 --> 34:45.610
我们可以这样来写

34:45.610 --> 34:47.610
一共就这么几种情况

34:47.610 --> 34:49.610
得到用户的输入

34:49.610 --> 34:51.610
来判断一下

34:51.610 --> 34:54.610
如果results等于now

34:54.610 --> 34:56.610
是不是用户点了取消

34:56.610 --> 34:57.610
用户点了取消

34:57.610 --> 34:59.610
我们就输出

34:59.610 --> 35:02.610
点击了取消

35:02.610 --> 35:04.610
用户你点了取消

35:04.610 --> 35:06.610
如果用户没有点取消

35:06.610 --> 35:08.610
是不是else

35:08.610 --> 35:10.610
else里边用户没有点取消

35:10.610 --> 35:13.610
没有点取消又怎么办呢

35:13.610 --> 35:15.610
没有点取消是不是又有情况了

35:15.610 --> 35:16.610
如果你没有点取消的话

35:16.610 --> 35:18.610
是不是又有情况了

35:18.610 --> 35:19.610
那么这里来

35:19.610 --> 35:21.610
我们又分情况来看

35:21.610 --> 35:24.610
哪些情况呢

35:24.610 --> 35:26.610
判断一下

35:26.610 --> 35:28.610
你看这里又可以写判断

35:28.610 --> 35:30.610
就是说没有谁规定

35:30.610 --> 35:31.610
说衣服里边

35:31.610 --> 35:32.610
他就不能再写衣服了

35:32.610 --> 35:34.610
一旁当成一个整体

35:34.610 --> 35:36.610
如果他为真

35:36.610 --> 35:37.610
运行这一块

35:37.610 --> 35:38.610
如果他为假

35:38.610 --> 35:40.610
else否则的话运行这一块

35:40.610 --> 35:42.610
这一块管理写啥都行

35:42.610 --> 35:43.610
随便的写啥

35:43.610 --> 35:45.610
你可以再来一个判断

35:45.610 --> 35:46.610
再来判断

35:46.610 --> 35:48.610
如果results是一个空的制服串

35:48.610 --> 35:50.610
是一个空的制服串

35:50.610 --> 35:52.610
那么表示没有内容对吧

35:52.610 --> 35:53.610
表示没有内容

35:53.610 --> 35:54.610
没有内容的话

35:54.610 --> 35:56.610
我们输出

35:56.610 --> 35:58.610
应该这样子

35:58.610 --> 36:00.610
不用去判断空制服串了对吧

36:00.610 --> 36:02.610
results等于

36:03.610 --> 36:05.610
把它转换成数字

36:05.610 --> 36:07.610
转换为数字

36:07.610 --> 36:08.610
对吧 我之前说过

36:08.610 --> 36:10.610
这样子可以转换成数字

36:10.610 --> 36:12.610
判断一下

36:12.610 --> 36:15.610
如果意思NAN

36:15.610 --> 36:16.610
意思NAN

36:16.610 --> 36:18.610
如果这个数字是一个非数字

36:18.610 --> 36:20.610
不是一个正常的数字

36:20.610 --> 36:21.610
不是正常的数字

36:21.610 --> 36:22.610
是不是转换失败

36:22.610 --> 36:24.610
不是正常的数字

36:24.610 --> 36:25.610
转换失败

36:25.610 --> 36:26.610
转换失败的话

36:26.610 --> 36:27.610
我们就输出

36:27.610 --> 36:30.610
输入有误

36:30.610 --> 36:32.610
results

36:32.610 --> 36:34.610
那么表示的是

36:34.610 --> 36:36.610
是正常的数字

36:36.610 --> 36:37.610
是正常的数字

36:37.610 --> 36:38.610
我们直接输出

36:38.610 --> 36:40.610
就完事了

36:40.610 --> 36:41.610
你看一下这个结构

36:41.610 --> 36:43.610
好好理解一下这个结构

36:43.610 --> 36:44.610
保存之后

36:44.610 --> 36:46.610
咱们来看一下

36:46.610 --> 36:48.610
如果我点了取消

36:48.610 --> 36:50.610
你看我点进来取消

36:50.610 --> 36:51.610
再来

36:51.610 --> 36:53.610
如果我点了确定

36:53.610 --> 36:54.610
那么得到的是0

36:54.610 --> 36:56.610
它转换结构是0

36:56.610 --> 36:58.610
如果我输入的是

36:59.610 --> 37:01.610
输入有误

37:01.610 --> 37:02.610
各种情况我们都能控制的

37:02.610 --> 37:04.610
如果输入正常的一个数字

37:04.610 --> 37:05.610
没问题

37:05.610 --> 37:06.610
正常的数字

37:06.610 --> 37:07.610
什么3.14没问题

37:07.610 --> 37:08.610
或者是

37:08.610 --> 37:10.610
但是如果输入3.1.2.2

37:10.610 --> 37:11.610
比较随便写

37:11.610 --> 37:14.610
那么就输入有误了

37:14.610 --> 37:17.610
看一下这个结构

37:17.610 --> 37:19.610
再来说一次

37:19.610 --> 37:20.610
其实这种结构

37:20.610 --> 37:21.610
以后就没什么好说的了

37:21.610 --> 37:22.610
但是现在

37:22.610 --> 37:23.610
刚开始结束

37:23.610 --> 37:24.610
可以好好理解一下

37:24.610 --> 37:27.610
就是得到用户的输入的东西

37:27.610 --> 37:28.610
如果输入为NOW

37:28.610 --> 37:30.610
表示的是你点了取消

37:30.610 --> 37:31.610
如果输入的不是NOW的话

37:31.610 --> 37:32.610
就正常的情况

37:32.610 --> 37:33.610
正常的情况的话

37:33.610 --> 37:35.610
我们来优点分情况来判断

37:35.610 --> 37:36.610
把它转换成数字

37:36.610 --> 37:37.610
转换成数字之后

37:37.610 --> 37:39.610
判断你是不是NAN

37:39.610 --> 37:41.610
是不是一个非数字

37:41.610 --> 37:42.610
转换成功没有

37:42.610 --> 37:43.610
如果你是一个NAN

37:43.610 --> 37:44.610
你看这个函数

37:44.610 --> 37:45.610
我们之前说过

37:45.610 --> 37:47.610
这个函数反而回的结果是啥

37:47.610 --> 37:49.610
反而回的结果是一个布尔

37:49.610 --> 37:50.610
它判断一个数字

37:50.610 --> 37:52.610
是不是NAN

37:52.610 --> 37:54.610
如果是NAN的话

37:54.610 --> 37:55.610
那么就是输入有误

37:55.610 --> 37:56.610
否则的话就把它输出

37:56.610 --> 37:58.610
把这个数字输出

37:58.610 --> 37:59.610
OK

37:59.610 --> 38:00.610
这是关于这一块

38:00.610 --> 38:01.610
好

38:01.610 --> 38:02.610
接下来是

38:02.610 --> 38:04.610
咱们这里和着作业

38:04.610 --> 38:06.610
作业

38:06.610 --> 38:07.610
好

38:07.610 --> 38:08.610
作业这一块

38:08.610 --> 38:10.610
有点觉得有点多

38:10.610 --> 38:12.610
这才哪到哪

38:12.610 --> 38:14.610
我们后边还要学循环

38:14.610 --> 38:15.610
循环过后

38:15.610 --> 38:18.610
你再来给我说什么作业多

38:18.610 --> 38:19.610
一定要做

38:19.610 --> 38:20.610
我们之前反目强调

38:20.610 --> 38:21.610
作业的时间

38:21.610 --> 38:24.610
最好是大于等于你听课的时间

38:24.610 --> 38:26.610
一定要大于等于你听课的时间

38:26.610 --> 38:28.610
前边运算幅那个章节

38:28.610 --> 38:30.610
没有多少作业

38:30.610 --> 38:32.610
但是这个章节作业多起来了

38:32.610 --> 38:33.610
多起来了

38:33.610 --> 38:35.610
这些作业我现在一个不讲

38:35.610 --> 38:36.610
一个不讲

38:36.610 --> 38:38.610
你们根据你自己的理解

38:38.610 --> 38:40.610
根据你自己的理解

38:40.610 --> 38:42.610
然后进行处理

38:42.610 --> 38:44.610
根据你自己的理解进行处理

38:44.610 --> 38:45.610
看一下

38:45.610 --> 38:46.610
总之你不用完全

38:46.610 --> 38:48.610
就是有些同学问的很细

38:48.610 --> 38:49.610
就是说输入的格式

38:49.610 --> 38:50.610
输入的时候

38:50.610 --> 38:51.610
这个要不要换行

38:51.610 --> 38:52.610
你不用问那么细

38:52.610 --> 38:53.610
整体功能做出来就行了

38:53.610 --> 38:55.610
整体功能做出来就行了

38:55.610 --> 38:57.610
一共有五道题

38:57.610 --> 38:58.610
一共有五道题

38:58.610 --> 39:01.610
第五题的话需要用一个新知识

39:01.610 --> 39:02.610
需要用一个新知识

39:02.610 --> 39:03.610
这个新知识让我讲一讲

39:03.610 --> 39:06.610
也是个补充知识

39:06.610 --> 39:10.610
第五题有一个新知识

39:10.610 --> 39:11.610
补充一下

39:11.610 --> 39:13.610
这是第1个

39:13.610 --> 39:16.610
这是第2个我要补充的

39:16.610 --> 39:17.610
第3个要补充的

39:17.610 --> 39:19.610
就是一个新知识

39:19.610 --> 39:21.610
得到一个水积数

39:21.610 --> 39:23.610
它怎么写呢

39:23.610 --> 39:24.610
它代码是这样子

39:24.610 --> 39:28.610
Mass-red

39:28.610 --> 39:29.610
直接这样写就完事了

39:29.610 --> 39:31.610
Mass是一个对象

39:31.610 --> 39:34.610
这个对象里边有一个函数

39:34.610 --> 39:35.610
我们会不会学习函数

39:35.610 --> 39:37.610
现在知道怎么用就行了

39:37.610 --> 39:39.610
要用这个函数

39:39.610 --> 39:40.610
整个是个表达式

39:40.610 --> 39:43.610
该表达式

39:43.610 --> 39:47.610
返回一个0-1之间的

39:47.610 --> 39:49.610
水积数字

39:49.610 --> 39:50.610
也就是这个表达式

39:50.610 --> 39:52.610
返回的是一个数字

39:52.610 --> 39:53.610
是一个水积数字

39:53.610 --> 39:55.610
0-1之间的水积数字

39:55.610 --> 39:57.610
它不能取到1

39:57.610 --> 40:00.610
无法取到1

40:00.610 --> 40:03.610
大概就这么一种情况

40:03.610 --> 40:05.610
好吧

40:05.610 --> 40:06.610
这里关了

40:06.610 --> 40:08.610
咱们来看一下

40:08.610 --> 40:09.610
这里我们先见个页面

40:09.610 --> 40:13.180
TES4

40:13.180 --> 40:16.180
看一下这里我们就

40:16.180 --> 40:17.180
输出

40:17.180 --> 40:18.180
直接输出

40:18.180 --> 40:19.180
输出啥呢

40:19.180 --> 40:21.180
输出Mass-red

40:21.180 --> 40:22.180
输出这个表达式

40:22.180 --> 40:23.180
这个表达式

40:23.180 --> 40:25.180
就是一个水积的数字

40:25.180 --> 40:29.840
看一下

40:29.840 --> 40:31.840
F12

40:31.840 --> 40:33.840
刷新

40:33.840 --> 40:36.840
你看刷新

40:36.840 --> 40:38.840
你看什么每次都不一样

40:38.840 --> 40:39.840
每次都不一样

40:39.840 --> 40:41.840
我们可以在这里测试一下

40:41.840 --> 40:42.840
Mass-red

40:42.840 --> 40:44.840
你看得到这个值

40:44.840 --> 40:46.840
然后我们按一下光标的上

40:46.840 --> 40:47.840
重复这个代码

40:47.840 --> 40:49.840
你看每次得到是不一样的

40:49.840 --> 40:50.840
得到是不一样的

40:50.840 --> 40:52.840
这就是一个水积数

40:52.840 --> 40:54.840
得到一之间的水积数

40:54.840 --> 40:56.840
我们做第五题的时候

40:56.840 --> 40:58.840
可能要用到这个水积数

40:58.840 --> 41:00.840
大家下去思考一下

41:00.840 --> 41:01.840
每道题

41:01.840 --> 41:02.840
前面的题

41:02.840 --> 41:03.840
应该都比较简单

41:03.840 --> 41:04.840
一般前面的题都比较简单

41:04.840 --> 41:05.840
像第二题

41:05.840 --> 41:06.840
我都是做过的

41:06.840 --> 41:07.840
大家下去

41:07.840 --> 41:08.840
把这个题完成

41:08.840 --> 41:09.840
这五道题完成

41:09.840 --> 41:10.840
完成之后

41:10.840 --> 41:11.840
不管你能不能完成

41:11.840 --> 41:13.840
但是你一定要每道题

41:13.840 --> 41:14.840
认真思考

41:14.840 --> 41:15.840
尽自己最大的努力

41:15.840 --> 41:16.840
去完成

41:16.840 --> 41:17.840
你花的精力越多

41:17.840 --> 41:19.840
哪怕你做不出来

41:19.840 --> 41:20.840
最多没有做出来

41:20.840 --> 41:21.840
但是你花的精力

41:21.840 --> 41:22.840
就没有白费

41:22.840 --> 41:24.840
一定是没有白费的

41:24.840 --> 41:25.840
你花的精力

41:25.840 --> 41:27.840
会对你后面

41:27.840 --> 41:30.840
听我讲解这个作业大有帮助

41:30.840 --> 41:32.840
会对你理解这个程序的运行

41:32.840 --> 41:33.840
大有帮助

41:33.840 --> 41:34.840
所以一定要花

41:34.840 --> 41:35.840
自己最大的努力

41:35.840 --> 41:36.840
去把这些题完成

41:36.840 --> 41:37.840
就算完不成

41:37.840 --> 41:38.840
没关系

41:38.840 --> 41:39.840
很正常

41:39.840 --> 41:40.840
那么听了我来

41:40.840 --> 41:41.840
进行作业讲解

41:41.840 --> 41:42.840
当然那里完成

41:42.840 --> 41:43.840
就是最好的

41:43.840 --> 41:44.840
完成了过后

41:44.840 --> 41:45.840
我建议

41:45.840 --> 41:46.840
一开始

41:46.840 --> 41:47.840
还是要听我一下

41:47.840 --> 41:48.840
作业讲解

41:48.840 --> 41:49.840
看我的实度是怎么做的

41:49.840 --> 41:50.840
完成了

