WEBVTT

00:00.000 --> 00:15.330
这一课我们来说一下这个卫运算

00:15.590 --> 00:17.890
也是扩展课程

00:18.390 --> 00:23.270
卫运算这一课我们以后用的不多 非常非常少

00:23.530 --> 00:27.870
但是有的时候卫运算可以给我们的开发量带来一些方便

00:28.130 --> 00:30.690
并且卫运算的执行效率

00:30.950 --> 00:33.510
就是程序的运行速度是非常非常快的

00:34.270 --> 00:36.310
什么叫做卫运算指的是

00:36.570 --> 00:38.110
将一个整数

00:39.590 --> 00:43.030
整数的二净字格式进行运算

00:43.290 --> 00:46.870
在卫运算的时候它有这么一个在介石里面

00:47.110 --> 00:47.890
介石中

00:48.150 --> 00:50.710
如果对一个数字

00:50.950 --> 00:53.010
如果对一个数据

00:53.510 --> 00:55.570
进行卫运算

00:55.830 --> 00:56.850
它会怎么样呢

00:57.110 --> 00:58.130
它首先

00:58.630 --> 00:59.670
会将其

00:59.910 --> 01:01.970
会将其转换为

01:02.470 --> 01:03.510
一个整数

01:03.750 --> 01:05.030
转换为一个整数

01:05.490 --> 01:08.050
怎么来转换呢如果这个数字它有小数

01:08.050 --> 01:09.590
小数直接磨掉

01:09.590 --> 01:12.150
直接把小数磨掉直接把它变成一个整数

01:12.410 --> 01:14.450
这个整数呢并且是一个

01:14.710 --> 01:16.250
并且

01:16.510 --> 01:19.830
按照32位的整数

01:20.090 --> 01:21.630
二净字排列

01:21.890 --> 01:23.150
什么意思呢

01:23.410 --> 01:24.170
这啥意思

01:24.430 --> 01:25.710
比方说举个例子

01:25.970 --> 01:26.730
举个例子

01:26.990 --> 01:29.050
我们有一个数字

01:29.810 --> 01:30.590
假设

01:30.850 --> 01:33.650
一个数字是1.3

01:33.950 --> 01:36.670
那么它首先会把它转换成整数

01:36.930 --> 01:38.530
会把它转换成整数

01:38.770 --> 01:39.490
就是转换成1

01:40.010 --> 01:42.050
首先把它转换成整数

01:42.310 --> 01:43.070
转换成1

01:43.330 --> 01:47.170
然后按照32位的整数二净字排列

01:47.690 --> 01:51.270
如果你听了我之前的课程的话会发现有差异的

01:51.530 --> 01:52.450
之前的课程

01:52.690 --> 01:55.870
就是第10階课的时候我说了数字的存储

01:55.870 --> 01:57.150
如果你没看也没关系

01:57.650 --> 01:59.470
我说了数字的存储说的是

01:59.730 --> 02:02.270
介石里面的存数字整数也好

02:02.430 --> 02:03.350
小数也好

02:03.430 --> 02:07.230
都是按照双净度64位进行存储的

02:07.670 --> 02:09.750
但是这里未运算的时候

02:09.990 --> 02:11.950
它首先要把它转换成整数

02:12.190 --> 02:15.550
然后按照32位的整数进行排列

02:15.790 --> 02:17.470
然后再把它转换成这种格式

02:17.710 --> 02:18.630
32位

02:18.870 --> 02:21.150
1的话转换成二净字

02:21.310 --> 02:21.870
比方说2吧

02:22.110 --> 02:22.630
比方说2

02:22.710 --> 02:23.310
2.3

02:23.630 --> 02:25.110
先把它转换成整数2

02:25.350 --> 02:26.910
然后再把它转换成什么

02:27.150 --> 02:29.350
转换成32位的二净字排列

02:29.790 --> 02:31.990
二净字的二是不是一和零

02:32.670 --> 02:33.990
二净字的零就是零

02:34.030 --> 02:35.470
二净字的一就是一

02:35.470 --> 02:37.750
二净字的二就是要进一了

02:37.750 --> 02:39.670
缝二进一就是一和零

02:40.190 --> 02:40.870
就是一零

02:41.070 --> 02:42.430
那么现在不足32位

02:42.430 --> 02:42.670
对吧

02:42.670 --> 02:44.590
现在才两位不足32位

02:44.670 --> 02:46.030
于是前边补零

02:46.310 --> 02:46.910
把补齐

02:46.910 --> 02:47.990
把补齐

02:48.510 --> 02:49.270
零零零零

02:49.790 --> 02:50.470
零零零

02:50.470 --> 02:51.030
这是八位了

02:51.910 --> 02:52.510
八位

02:53.310 --> 02:55.230
然后八位

02:55.270 --> 02:56.270
这是16位

02:57.190 --> 02:57.870
46位

02:58.190 --> 02:58.990
这是32位

02:59.590 --> 03:00.110
OK

03:01.110 --> 03:02.270
把它补成这个样子

03:02.430 --> 03:03.510
把它补成这个样子

03:03.510 --> 03:06.870
这就是它的二净字32位的整数格式

03:07.030 --> 03:08.350
所以说我们这一节课

03:09.110 --> 03:10.550
学习的卫运算

03:10.910 --> 03:13.110
全部是针对整数的

03:13.150 --> 03:14.070
不存在小数

03:14.070 --> 03:15.110
不存在小数

03:15.150 --> 03:16.310
如果有小数的话

03:16.310 --> 03:17.750
先把它转换成整数

03:18.190 --> 03:19.390
不是四舍五入

03:19.470 --> 03:20.830
不是四舍五入

03:20.830 --> 03:23.390
比方说2.7得到的整数还是2

03:23.590 --> 03:24.830
直接把小数扔掉

03:25.070 --> 03:25.830
直接扔掉

03:26.590 --> 03:27.230
OK

03:28.110 --> 03:30.230
那么这里把它转换成32位的整数

03:30.230 --> 03:30.990
进行排列

03:31.230 --> 03:32.790
然后再来进行运算

03:33.790 --> 03:34.710
那么第1个

03:34.710 --> 03:36.550
就是32位的总数里面

03:36.670 --> 03:38.070
第1个是符号位

03:38.350 --> 03:39.990
第1个数字是符号位

03:40.030 --> 03:41.350
就是说这里是0的话

03:41.350 --> 03:42.390
表示整数

03:42.390 --> 03:43.390
表示正数

03:43.590 --> 03:44.630
这里是1的话

03:44.630 --> 03:45.710
表示附属

03:45.950 --> 03:47.430
就第1个位置比较特殊

03:47.630 --> 03:48.710
第1个位置比较特殊

03:48.750 --> 03:50.190
它是0的话表示正数

03:50.230 --> 03:51.710
是1的话表示附属

03:51.950 --> 03:54.110
先把这个基本知识的给大家说一下

03:54.190 --> 03:55.910
就是我们今天就这节课

03:55.950 --> 03:57.630
会讲很多的未运算

03:57.670 --> 03:58.990
无论是什么未运算

03:58.990 --> 04:00.230
它首先要做的第一件事

04:00.230 --> 04:01.070
肯定是这个事

04:01.590 --> 04:03.110
先把你要运算的东西

04:03.310 --> 04:06.110
转换成32位的二净之格式

04:06.590 --> 04:07.030
好吧

04:07.030 --> 04:08.150
这是我要说的一个点

04:08.550 --> 04:10.630
那么这里面还有一些情况

04:10.950 --> 04:12.550
就是什么NAN

04:13.230 --> 04:14.470
还有一些特殊的数字

04:14.910 --> 04:15.910
像一些制服创意

04:15.910 --> 04:17.070
你要把它进行未运算

04:17.070 --> 04:18.870
它是不是要把它转换成数字

04:19.390 --> 04:21.150
有可能会转换成NAN

04:21.990 --> 04:23.270
还有什么Infinity

04:23.590 --> 04:25.350
像这些特殊的数字

04:25.830 --> 04:27.710
还有什么附的Infinity

04:29.390 --> 04:30.430
像这些数字

04:30.550 --> 04:32.030
全部当做0

04:32.630 --> 04:34.030
全部当做0来考虑

04:35.790 --> 04:37.230
全部把它看作是0

04:37.390 --> 04:38.950
如果进行未运算的时候

04:39.790 --> 04:40.830
前提条件

04:41.070 --> 04:42.870
如果是进行未运算的时候

04:42.910 --> 04:44.070
全部把它看作0

04:44.870 --> 04:46.430
什么制服创意

04:46.630 --> 04:48.950
什么布尔没关系

04:49.030 --> 04:50.790
先把它转换成数字

04:51.350 --> 04:52.510
然后再转换成整数

04:52.630 --> 04:54.070
如果转换不了就是NAN

04:54.270 --> 04:55.350
NNN就是0

04:56.910 --> 05:00.190
我们首先把这个基础概念先说清楚

05:00.390 --> 05:03.910
然后再来说未运算里边有哪些未运算

05:04.550 --> 05:06.750
一个个说这里面很多

05:07.430 --> 05:09.470
我这就可能不光要说这些未运算

05:09.510 --> 05:10.390
它有什么功能

05:10.430 --> 05:12.710
还要说它有一些常见的用法

05:13.230 --> 05:15.270
其实也不叫常见的用法了

05:15.390 --> 05:17.670
我们平时写单码了也不太会这样子用

05:17.750 --> 05:20.750
但是它确实可以利用未运算

05:20.750 --> 05:22.710
达到一些特殊的效果

05:23.190 --> 05:25.710
比方说第一个运算叫做

05:26.350 --> 05:27.430
语运算

05:27.630 --> 05:29.750
语运算我们之前说过的对吧

05:30.070 --> 05:31.830
就是并且

05:32.110 --> 05:35.390
但是这里的语运算叫做未语

05:36.030 --> 05:39.270
就是未运算中的语运算

05:39.590 --> 05:40.550
它怎么写

05:40.590 --> 05:43.430
它的运算符号是and

05:43.470 --> 05:44.630
就写一个就行了

05:44.670 --> 05:45.470
不能写两个

05:45.470 --> 05:47.630
写两个的话就是我们之前讲的并且了

05:48.110 --> 05:49.150
好只写一个

05:49.310 --> 05:50.270
它什么意思呢

05:50.390 --> 05:51.950
它的用法写法

05:52.950 --> 05:55.190
写法是数字

05:55.310 --> 05:56.270
就整数

05:56.590 --> 05:57.670
整数1

05:58.190 --> 06:00.190
与整数2

06:00.230 --> 06:01.230
整数2

06:02.070 --> 06:04.350
或者是表达是1表达是2

06:04.350 --> 06:05.390
你总归是一个数字

06:05.390 --> 06:06.590
总归要把它转换成数字

06:06.590 --> 06:07.270
前面说了

06:07.830 --> 06:09.350
总归要把它转换成整数

06:09.630 --> 06:10.710
什么意思呢

06:10.990 --> 06:13.070
它指的是将两个整数

06:13.390 --> 06:15.190
将两个整数

06:15.670 --> 06:18.230
每一位进行比较

06:18.470 --> 06:19.430
进行比较

06:19.670 --> 06:21.310
因为他们一定是32位的

06:21.310 --> 06:22.590
甭管这个数字是啥

06:22.630 --> 06:24.350
它一定是32位的整数

06:24.630 --> 06:25.710
二进制的格式

06:25.990 --> 06:28.390
那么1是来进行位置的比较

06:28.590 --> 06:29.830
每一位进行比较

06:30.230 --> 06:31.070
如果

06:31.390 --> 06:31.910
什么呢

06:32.030 --> 06:33.510
如果相同

06:34.270 --> 06:35.630
如果都为1

06:36.390 --> 06:37.230
都为1

06:39.230 --> 06:40.470
结果为1

06:41.110 --> 06:42.790
1的话你可以把它认为是真

06:42.990 --> 06:43.990
你可以认为是真

06:44.270 --> 06:45.150
真真为真

06:46.270 --> 06:47.150
否则

06:47.470 --> 06:48.990
结果为0

06:49.470 --> 06:51.390
0的话你可以认为是假

06:51.550 --> 06:53.070
真真为真其他为假

06:53.070 --> 06:53.630
对吧

06:54.030 --> 06:55.150
这就是未运算

06:55.150 --> 06:57.110
这个与运算的效果

06:57.270 --> 06:58.310
比方说几个例子

06:59.710 --> 07:00.590
这里新建个文件

07:00.590 --> 07:01.110
Test

07:03.830 --> 07:04.990
咱们写个例子

07:05.630 --> 07:06.670
这里我其实都不写了

07:06.710 --> 07:07.870
直接控制台里边看

07:08.270 --> 07:09.390
直接在控制台里边看

07:12.080 --> 07:13.600
或者我们还是写一下吧

07:13.600 --> 07:14.560
还是写一下吧

07:15.360 --> 07:18.000
这里边我们有这么两个数字

07:18.240 --> 07:19.480
比方说我们这里输出啥

07:19.920 --> 07:22.120
输出两个数字进行与运算

07:22.600 --> 07:23.120
1

07:23.600 --> 07:24.080
2

07:24.840 --> 07:26.000
这就是与运算

07:26.560 --> 07:27.680
得到的结果是啥

07:27.680 --> 07:28.920
咱们来分析一下

07:29.080 --> 07:31.120
1到2进字格是啥

07:31.760 --> 07:33.360
1到2进字格是啥

07:33.520 --> 07:35.160
1到2进字格是

07:35.640 --> 07:36.480
这里看一下

07:36.480 --> 07:37.880
1到2进字格是

07:38.280 --> 07:40.320
前面8个0

07:40.520 --> 07:41.280
后边

07:44.280 --> 07:45.600
我之前是不是写错了

07:45.960 --> 07:47.480
12345678

07:47.480 --> 07:48.560
这还不够是吧

07:48.560 --> 07:49.160
还不够

07:49.160 --> 07:50.200
还在写4个

07:50.720 --> 07:51.720
中间还有4个

07:52.280 --> 07:53.000
是这样子吧

07:53.400 --> 07:55.920
8个16个32个

07:55.920 --> 07:56.280
对了

07:56.280 --> 07:57.120
这才是32个

07:57.120 --> 07:57.520
对吧

07:57.680 --> 07:58.720
这才是32个

08:00.160 --> 08:01.240
然后我们这样子写

08:01.400 --> 08:02.000
这样子写

08:02.800 --> 08:03.320
你看

08:03.320 --> 08:04.640
这是第一个1

08:04.640 --> 08:04.960
对吧

08:04.960 --> 08:06.160
1是01

08:06.160 --> 08:07.760
前面全是0

08:07.760 --> 08:08.600
后面有一个1

08:08.920 --> 08:09.520
好2

08:10.840 --> 08:11.760
2的结果是啥

08:12.160 --> 08:14.160
2的结果是10

08:14.160 --> 08:14.520
对吧

08:14.520 --> 08:15.200
10

08:16.320 --> 08:17.840
然后我们1是来比较

08:17.840 --> 08:18.120
对吧

08:18.120 --> 08:18.880
1是来比较

08:18.880 --> 08:20.120
一位进行比较

08:20.120 --> 08:21.360
你看这一位比较

08:21.440 --> 08:23.080
然后这一位进行比较

08:23.080 --> 08:23.400
看没

08:23.400 --> 08:24.640
一位进行比较

08:24.640 --> 08:26.240
如果两个为1

08:26.920 --> 08:28.240
结果就是1

08:28.920 --> 08:30.320
如果两个

08:30.640 --> 08:32.640
如果其他的情况都是0

08:32.840 --> 08:34.240
所以说结果等于啥呢

08:34.240 --> 08:35.000
就等于

08:35.640 --> 08:36.240
结果

08:36.480 --> 08:37.360
结果是啥呢

08:37.720 --> 08:38.480
结果就是这个

08:39.360 --> 08:40.680
1111

08:41.280 --> 08:41.640
好

08:41.640 --> 08:43.080
那么这个结果是多少呢

08:43.080 --> 08:44.360
这个二进字的结果

08:44.520 --> 08:45.320
就是3

08:45.480 --> 08:46.160
就是3

08:46.520 --> 08:47.760
如果你不太清楚

08:47.760 --> 08:48.960
怎么把二进字

08:48.960 --> 08:50.120
转换为十进字

08:50.160 --> 08:51.680
你可以看一下我上一节课

08:51.680 --> 08:53.000
上一节课里边说到了

08:53.000 --> 08:56.200
如何对十进字和二进字进行手动转换

08:56.440 --> 08:57.760
那么这个结果就是3

08:57.760 --> 08:59.560
当然你也可以利用计算器

08:59.800 --> 09:02.000
计算器里边有一个程序儿

09:02.000 --> 09:02.280
对吧

09:02.280 --> 09:03.080
一个程序儿

09:03.080 --> 09:05.280
程序儿里边你可以在这里

09:05.280 --> 09:06.680
我们目前的是十进字

09:06.680 --> 09:07.000
你看

09:07.000 --> 09:08.280
目前是这个

09:08.280 --> 09:10.480
这个单词DEC表示十进字

09:11.240 --> 09:12.440
那么选动十进字

09:12.440 --> 09:15.560
目前的比方说我写个3

09:15.560 --> 09:17.360
你看一下二进字的格式

09:17.360 --> 09:18.800
你看二进字的格式点一下

09:18.800 --> 09:19.520
就是摇摇

09:20.000 --> 09:21.480
最后两位就是摇摇

09:21.480 --> 09:22.720
十进字那就是3

09:22.720 --> 09:23.320
看没

09:23.320 --> 09:24.720
这是八进字

09:24.720 --> 09:26.000
这是十六进字

09:26.000 --> 09:26.720
看没

09:26.720 --> 09:27.560
OK

09:27.560 --> 09:28.760
这是3

09:28.760 --> 09:29.560
那么同样的

09:29.560 --> 09:32.080
我在二进字这里写个摇摇

09:32.080 --> 09:32.800
写个摇摇

09:32.800 --> 09:34.760
那么得到了十进字那就是3

09:34.760 --> 09:35.400
看没

09:35.400 --> 09:37.280
用这个计算器也可以看得出来

09:37.280 --> 09:37.880
好

09:37.880 --> 09:39.120
咱们来运行看一下

09:39.840 --> 09:41.080
F12转到DEC

09:42.080 --> 09:42.840
没保存

09:42.840 --> 09:43.480
保存

09:45.160 --> 09:46.080
怎么是0呢

09:46.880 --> 09:47.560
怎么是0呢

09:48.040 --> 09:49.160
对是0

09:49.160 --> 09:50.280
是0

09:50.280 --> 09:51.160
我怎么说错了

09:51.160 --> 09:51.840
是0

09:51.840 --> 09:52.880
1和0

09:52.880 --> 09:54.160
你看比较出来是0

09:54.160 --> 09:54.680
对吧

09:54.680 --> 09:56.280
必须要两个都为1

09:56.280 --> 09:57.320
结果我才是1

09:57.320 --> 10:00.360
所以说1和2取与运算了

10:00.360 --> 10:01.160
结果是0

10:01.760 --> 10:02.280
结果是0

10:03.360 --> 10:03.680
看没

10:04.680 --> 10:06.240
如果是1和3

10:07.480 --> 10:08.240
1和3

10:08.240 --> 10:09.160
它就变成这个样子了

10:09.160 --> 10:09.840
看没

10:09.840 --> 10:11.440
1和3就变成这个样子了

10:11.440 --> 10:13.480
其实如果前边权是0的话

10:13.480 --> 10:15.800
前边权是0的话可以省略

10:15.800 --> 10:16.760
就看这个

10:16.800 --> 10:18.400
前边权是0的话可以省略的

10:19.200 --> 10:20.200
你看

10:20.200 --> 10:21.000
这个结果

10:21.000 --> 10:21.800
好

10:21.800 --> 10:23.160
一次来比较吧

10:23.160 --> 10:24.440
一次来比较

10:24.440 --> 10:26.240
1和1是不是得到1

10:26.240 --> 10:26.600
对吧

10:26.600 --> 10:27.360
得到1

10:27.360 --> 10:28.960
0和1得到什么

10:28.960 --> 10:29.920
得到0

10:29.920 --> 10:30.760
那么结果就是0

10:30.760 --> 10:31.040
1

10:31.040 --> 10:32.440
也就是结果就是啥

10:32.440 --> 10:33.360
结果就是1

10:34.120 --> 10:34.840
结果就是1

10:36.280 --> 10:37.320
没问题吧

10:37.320 --> 10:38.960
这是关于语运算

10:38.960 --> 10:40.240
非常非常简单

10:40.240 --> 10:42.840
但是我们平时的没咋用

10:42.840 --> 10:44.120
语运算

10:44.120 --> 10:44.320
好

10:44.320 --> 10:45.200
下一个

10:45.240 --> 10:45.960
获运算

10:47.280 --> 10:47.520
好

10:47.520 --> 10:48.480
获运算的话

10:48.480 --> 10:49.360
它的符号

10:49.360 --> 10:51.200
它的符号是这个

10:51.200 --> 10:52.560
只写一个就行了

10:52.560 --> 10:53.520
只写一个

10:53.520 --> 10:54.760
这就是获运算

10:54.760 --> 10:55.040
好

10:55.040 --> 10:56.640
写法是两个整数

10:56.640 --> 10:58.480
然后进行获运算

10:58.480 --> 10:59.600
什么意思呢

10:59.600 --> 11:00.840
将两个整数

11:00.840 --> 11:02.360
每一位进行比较

11:02.360 --> 11:04.120
如果都为1

11:04.120 --> 11:07.200
如果都为0

11:07.200 --> 11:08.120
结果为0

11:08.120 --> 11:09.920
否则的话结果为1

11:09.920 --> 11:10.440
啥意思

11:11.560 --> 11:13.320
就是只要有一个为1

11:13.320 --> 11:14.960
那么结果就是1

11:15.000 --> 11:16.000
其他的都是0

11:16.000 --> 11:17.160
两个为0

11:17.160 --> 11:18.520
那么结果就是0

11:18.520 --> 11:19.920
其他的都是1

11:19.920 --> 11:20.120
好

11:20.120 --> 11:20.520
看一下

11:21.640 --> 11:22.760
我们再来一个例子

11:22.760 --> 11:23.280
这里注释掉

11:24.600 --> 11:26.040
console log

11:26.040 --> 11:28.000
1获3

11:28.000 --> 11:29.080
1获3

11:29.080 --> 11:30.360
进行获运算

11:30.360 --> 11:30.960
咱们来看一下

11:32.960 --> 11:34.760
1就是011

11:34.760 --> 11:35.280
那就是3

11:35.280 --> 11:36.160
对吧

11:36.160 --> 11:36.720
等于什么呢

11:36.720 --> 11:38.000
1是来比较

11:38.000 --> 11:39.360
只要有一位是1

11:39.360 --> 11:39.960
就是1

11:39.960 --> 11:41.800
那么结果就是11

11:41.800 --> 11:42.680
没问题吧

11:42.680 --> 11:43.600
那么结果是啥

11:43.640 --> 11:44.720
结果就是3

11:44.720 --> 11:45.440
对不对

11:45.440 --> 11:45.600
好

11:45.600 --> 11:46.800
结果就是3

11:46.800 --> 11:47.200
好

11:47.200 --> 11:47.560
看一下

11:48.280 --> 11:48.800
结果就是3

11:49.920 --> 11:50.880
没问题吧

11:50.880 --> 11:51.320
好吧

11:52.520 --> 11:53.600
那么接下来

11:53.600 --> 11:54.000
比较说

11:54.000 --> 11:54.560
再来一个吧

11:54.560 --> 11:55.000
再来一个

11:57.520 --> 11:59.600
4的话是100

11:59.600 --> 12:00.680
100

12:00.680 --> 12:02.000
对齐

12:02.000 --> 12:02.840
对齐来比较

12:02.840 --> 12:04.600
实际上它真实的比较的时候

12:04.600 --> 12:06.480
是32位进行比较

12:06.480 --> 12:07.960
那么我这里就难得写了

12:07.960 --> 12:09.000
难得写了

12:09.000 --> 12:10.320
4是100

12:10.320 --> 12:12.720
那么这里14001

12:12.760 --> 12:14.320
比较出来就是101

12:14.320 --> 12:15.600
101是多少呢

12:15.600 --> 12:16.400
就是5

12:16.400 --> 12:17.520
就是5

12:17.520 --> 12:18.360
保存看一下

12:19.280 --> 12:20.440
就是5

12:20.440 --> 12:22.760
这就是获运算

12:22.760 --> 12:23.280
获运算

12:24.880 --> 12:25.160
好

12:25.160 --> 12:25.720
再来

12:25.720 --> 12:26.080
再来

12:27.120 --> 12:28.320
下一个

12:28.320 --> 12:29.720
否运算

12:29.720 --> 12:31.720
也就是叫做非运算

12:31.720 --> 12:32.120
有的时候

12:32.120 --> 12:33.960
拿一把称之为非运算

12:33.960 --> 12:34.800
就是与获非

12:34.800 --> 12:35.360
对吧

12:35.360 --> 12:36.280
否运算

12:36.280 --> 12:38.280
它的符号是这个

12:38.280 --> 12:40.040
符号是这个玩意

12:40.040 --> 12:40.280
好

12:40.280 --> 12:41.840
它的协法呢

12:41.880 --> 12:43.080
协法的是什么

12:43.080 --> 12:45.760
整数

12:45.760 --> 12:47.320
它是一个一连运算符

12:47.320 --> 12:49.240
直接在整数前边写上一个这个东西

12:50.360 --> 12:50.880
好

12:50.880 --> 12:53.080
然后它得到的结果是

12:53.080 --> 12:55.320
将该整数

12:55.320 --> 12:56.840
该整数

12:56.840 --> 12:58.200
按位

12:58.200 --> 13:00.040
取反

13:00.040 --> 13:01.120
也就是1变0

13:01.120 --> 13:01.720
0变1

13:01.720 --> 13:03.120
就是取相反的

13:03.120 --> 13:03.720
1变0

13:03.720 --> 13:05.280
0变1

13:05.280 --> 13:05.640
好

13:05.640 --> 13:06.440
我们来看一下

13:06.440 --> 13:07.040
我们来看一下

13:09.120 --> 13:10.360
这个地方有一个知识

13:10.360 --> 13:11.280
我再说一下

13:11.320 --> 13:12.440
再说一下

13:12.440 --> 13:13.800
这里比方说

13:13.800 --> 13:18.040
我取1的

13:18.040 --> 13:19.360
把1取反

13:19.360 --> 13:20.760
把1取反

13:20.760 --> 13:22.000
把1取反等于啥呢

13:23.360 --> 13:24.000
看一下

13:24.000 --> 13:25.200
这里一块知识

13:25.200 --> 13:26.720
首先是32位

13:26.720 --> 13:28.680
12345678

13:28.680 --> 13:29.840
8位了

13:29.840 --> 13:31.640
再来复制

13:31.640 --> 13:32.640
16位

13:32.640 --> 13:34.120
24位

13:34.120 --> 13:35.480
32位

13:35.480 --> 13:36.240
这里是1

13:36.240 --> 13:36.920
对吧

13:36.920 --> 13:39.480
把1取反取反

13:39.480 --> 13:40.520
取反等于什么呢

13:40.520 --> 13:41.760
是不是0变1

13:41.760 --> 13:42.400
1变0

13:42.400 --> 13:42.760
对吧

13:42.760 --> 13:44.000
包括符号位

13:44.000 --> 13:45.520
包括第一位的符号位

13:45.520 --> 13:47.360
那么前边是不是全是1了

13:47.360 --> 13:48.680
全是1了

13:48.680 --> 13:49.960
那全是1是不是复数

13:49.960 --> 13:50.360
对不对

13:50.360 --> 13:51.320
第一位是1

13:51.320 --> 13:52.600
表示是复数

13:52.600 --> 13:54.120
全是复数

13:54.120 --> 13:55.400
看一下

13:55.400 --> 13:56.000
看一下这个复数

13:56.000 --> 13:58.200
最后一位是0

13:58.200 --> 13:59.240
看一下这个复数

13:59.240 --> 14:00.040
该怎么来看

14:00.040 --> 14:02.320
怎么来看这个复数的结果

14:02.320 --> 14:03.200
这里有个规则

14:03.200 --> 14:03.800
有个规则

14:05.280 --> 14:07.760
就是大家可能会认为

14:07.760 --> 14:09.320
可能会认为

14:09.360 --> 14:10.680
在计算基底边

14:10.680 --> 14:12.400
复数的存储方式

14:12.400 --> 14:14.920
再说一下

14:14.920 --> 14:18.440
复数的存储方式

14:18.440 --> 14:19.520
可能会认为

14:19.520 --> 14:20.960
比方说复1

14:20.960 --> 14:22.920
它的存法是怎么存的呢

14:22.920 --> 14:25.000
可能大家会认为它的存法

14:25.000 --> 14:26.400
比方32位

14:26.400 --> 14:28.960
它的存法可能是这样子存的

14:28.960 --> 14:29.480
你看

14:29.480 --> 14:30.320
这个表示1

14:30.320 --> 14:30.720
对吧

14:30.720 --> 14:31.720
这个表示1

14:31.720 --> 14:32.800
那么把它变成复数

14:32.800 --> 14:33.840
加上一个符号位

14:33.840 --> 14:35.440
把它写成1就行了

14:35.440 --> 14:36.400
把第一位写成1

14:36.400 --> 14:37.520
表示它是个复数

14:37.520 --> 14:38.680
那么剩下的位置

14:38.680 --> 14:39.640
表示它的数字

14:39.640 --> 14:40.600
数字为1

14:40.600 --> 14:41.200
加上一个复数

14:41.200 --> 14:42.520
就是复一了

14:42.520 --> 14:43.680
好像是

14:43.680 --> 14:45.080
感觉上应该是这样子写的

14:45.080 --> 14:45.480
对吧

14:45.480 --> 14:46.920
感觉上应该是这样子存的

14:46.920 --> 14:48.680
实际上不是的

14:48.680 --> 14:50.560
这种写法

14:50.560 --> 14:52.960
它叫做真骂

14:52.960 --> 14:55.360
真骂

14:55.360 --> 14:57.120
真骂计算机

14:57.120 --> 14:58.320
它不会这样子存

14:58.320 --> 14:59.560
但是人阅读起来

14:59.560 --> 15:00.400
非常好阅读

15:00.400 --> 15:02.200
就是我们看这个二镜子的话

15:02.200 --> 15:04.400
哪怕我们现在没有怎么看二镜子

15:04.400 --> 15:05.600
也能够轻松的看出

15:05.600 --> 15:06.680
它是一个复一

15:06.680 --> 15:08.200
真骂对于人来说

15:08.200 --> 15:09.200
很好阅读

15:09.200 --> 15:11.600
但计算机不会这样子存

15:11.600 --> 15:13.720
为啥计算机不会这样子存呢

15:13.720 --> 15:15.760
这个说起来就很复杂了

15:15.760 --> 15:17.920
跟计算机的构造原理有关系

15:17.920 --> 15:19.880
计算机是做不了减法的

15:19.880 --> 15:20.880
大家明白吧

15:20.880 --> 15:22.320
计算机没法做减法

15:22.320 --> 15:23.880
它只能做加法

15:23.880 --> 15:25.800
它加的时候

15:25.800 --> 15:28.480
它会把这个符号位一起来相加

15:28.480 --> 15:29.880
把这个符号位一起来相加

15:29.880 --> 15:31.920
总之一大堆乱七八糟的原因

15:31.920 --> 15:33.160
我们不用去管

15:33.160 --> 15:35.000
跟我们没啥关系

15:35.000 --> 15:35.720
总之计算机

15:35.720 --> 15:37.320
因为一大堆乱七八糟的原因

15:37.360 --> 15:38.480
它不能这样存

15:38.480 --> 15:39.120
它就存不了

15:39.120 --> 15:39.800
这样子存

15:39.800 --> 15:41.520
这样存会导致很多问题

15:41.520 --> 15:43.400
导致它连加法都做不了了

15:43.400 --> 15:44.880
所以计算机它不这样存

15:44.880 --> 15:46.280
它咋存呢

15:46.280 --> 15:49.080
它首先把它的真骂拿出来

15:49.080 --> 15:50.280
拿出它的真骂

15:50.280 --> 15:53.400
然后接下来取反

15:53.400 --> 15:55.720
它怎么来存复数的

15:55.720 --> 15:57.120
计算机怎么来存复数的

15:57.120 --> 15:58.440
先拿出它的真骂

15:58.440 --> 16:00.160
然后来取反

16:00.160 --> 16:01.800
除了符号位之外

16:01.800 --> 16:03.360
除了符号位之外

16:03.360 --> 16:04.560
全部取反

16:04.560 --> 16:07.520
摇摇摇

16:07.520 --> 16:08.120
这里也是

16:08.120 --> 16:09.920
摇摇摇

16:09.920 --> 16:12.520
那么这边也要全部取反

16:12.520 --> 16:15.080
这里取反

16:15.080 --> 16:17.720
把其他的位置全部取反

16:17.720 --> 16:19.160
取反

16:19.160 --> 16:20.680
这里取反

16:20.680 --> 16:22.680
最后一位就是你

16:22.680 --> 16:24.640
那么这个东西叫做反骂

16:24.640 --> 16:26.720
反骂

16:26.720 --> 16:28.280
先得到真骂

16:28.280 --> 16:30.240
然后再得到反骂

16:30.240 --> 16:31.440
得到反骂过后

16:31.440 --> 16:33.360
还不够

16:33.400 --> 16:35.600
又因为一大堆乱七八糟的原因

16:35.600 --> 16:37.360
我们没有必要去了解

16:37.360 --> 16:38.200
没有必要去了解

16:38.200 --> 16:39.520
看我以后

16:39.520 --> 16:42.440
以后有机会讲夹吧课程

16:42.440 --> 16:43.720
夹吧课程我也不会讲这个

16:43.720 --> 16:45.760
也不会

16:45.760 --> 16:47.920
以后有机会我讲C语言课程的时候

16:47.920 --> 16:49.680
我可以讲讲

16:49.680 --> 16:51.760
像学夹吧学这个GS

16:51.760 --> 16:53.480
了解这个网上有啥意义呢

16:53.480 --> 16:55.400
没啥意义

16:55.400 --> 16:56.800
不去申诺讲解了

16:56.800 --> 16:58.800
这跟计算机的组成原理有关系

16:58.800 --> 17:00.040
你们大学的

17:00.040 --> 17:01.600
就是有些同学是计算机专业的

17:01.600 --> 17:03.000
你们应该学过的

17:03.000 --> 17:03.960
计算机组成原理

17:03.960 --> 17:05.280
对吧计算机组成原理

17:05.280 --> 17:06.800
你们不是要上个实验课吗

17:06.800 --> 17:08.560
实验课里边不是让你做个实验吗

17:08.560 --> 17:10.040
做一个加法期出来

17:10.040 --> 17:11.840
有没有让你做减法期

17:11.840 --> 17:13.080
没有吧

17:13.080 --> 17:14.680
如果让你做减法期的时候

17:14.680 --> 17:16.800
你会发现减法期就是加法期

17:16.800 --> 17:18.520
就是存出的数据

17:18.520 --> 17:19.920
把复述的那个地方

17:19.920 --> 17:21.080
给他处理了一下

17:21.080 --> 17:22.600
就用这种方式来处理

17:22.600 --> 17:24.520
做加法就相当于是做减法了

17:24.520 --> 17:25.880
你不用去管

17:25.880 --> 17:26.280
好

17:26.280 --> 17:28.200
得到反骂过后还不够

17:28.200 --> 17:29.000
还要做什么呢

17:29.000 --> 17:31.040
做补骂

17:31.040 --> 17:32.000
反骂是什么呢

17:32.000 --> 17:33.600
是真骂

17:33.600 --> 17:34.720
真骂取反

17:34.720 --> 17:35.760
就是反骂

17:35.760 --> 17:37.160
补骂是什么呢

17:37.160 --> 17:40.160
补骂是反骂加一

17:40.160 --> 17:41.440
反骂加一

17:41.440 --> 17:43.640
变成补骂

17:43.640 --> 17:44.880
紧针对复述

17:44.880 --> 17:46.000
真数据正常的

17:46.000 --> 17:46.960
真数据正常的

17:46.960 --> 17:48.800
只针对复述

17:48.800 --> 17:49.600
补骂是什么呢

17:49.600 --> 17:51.960
就是在反骂基础上的加个一

17:51.960 --> 17:53.200
这就是反骂

17:53.200 --> 17:56.520
这才是真正的复一的处理方式

17:56.520 --> 17:58.200
复一是这样存的

17:58.200 --> 18:00.600
复一是这样子的存数据的

18:00.720 --> 18:02.720
你把这个意思吧

18:02.720 --> 18:06.720
这就是最终的存处方案

18:06.720 --> 18:08.640
存处方案

18:08.640 --> 18:10.320
基础基础里面要存复一

18:10.320 --> 18:12.080
他们都是这样存的

18:12.080 --> 18:12.440
好吧

18:12.440 --> 18:14.040
这就是补骂

18:14.040 --> 18:16.000
当然跟上节课不冲突

18:16.000 --> 18:17.360
如果有些同学看到上节课的

18:17.360 --> 18:19.240
上节课他没有按照什么真骂

18:19.240 --> 18:20.280
补骂反骂来存

18:20.280 --> 18:21.880
他存的不是反骂和补骂

18:21.880 --> 18:22.720
上节课没有

18:22.720 --> 18:24.240
但是我就说这节课

18:24.240 --> 18:25.240
未运算这一块

18:25.240 --> 18:27.680
他要把它转换成32位的整数

18:27.680 --> 18:29.280
这种存处方式

18:29.320 --> 18:30.760
跟上节课不太一样了

18:30.760 --> 18:31.560
在物运算的时候

18:31.560 --> 18:33.680
还把它转换成这种存处方式

18:33.680 --> 18:34.360
那么这个时候

18:34.360 --> 18:36.120
就涉及到反骂和补骂了

18:36.120 --> 18:36.920
因为涉及到复数

18:38.160 --> 18:40.400
所以说如果我们拿到这个

18:40.400 --> 18:42.120
如果我们拿到这个二进制

18:42.120 --> 18:43.640
该怎么来看呢

18:43.640 --> 18:45.280
该怎么来看这个二进制呢

18:45.280 --> 18:46.240
怎么把它转换

18:46.240 --> 18:47.960
怎么知道这个二进制

18:47.960 --> 18:49.160
就是一个复一呢

18:49.160 --> 18:50.120
我们这样子简单

18:50.120 --> 18:51.680
反正来操作一次

18:51.680 --> 18:53.080
反正来操作一次

18:53.080 --> 18:55.120
先把它简一

18:55.120 --> 18:57.560
先把它简一变成零

18:57.560 --> 18:58.440
变成这个样子

18:58.440 --> 18:59.400
得到反骂

18:59.400 --> 19:01.880
然后再取反得到真骂

19:02.720 --> 19:04.520
得到真骂过来是不是就看出来了

19:04.520 --> 19:05.800
看出来它就是一了

19:05.800 --> 19:06.320
复一了

19:06.320 --> 19:06.640
对吧

19:06.640 --> 19:08.120
就看出来了

19:08.120 --> 19:10.640
当然它还有一种更简单的方式

19:10.640 --> 19:12.320
就是所以

19:12.320 --> 19:14.000
更简单的方式是啥呢

19:14.000 --> 19:16.720
就是复数

19:21.000 --> 19:22.800
怎么说

19:22.800 --> 19:25.560
复数二进制

19:26.520 --> 19:29.280
二进制简一

19:29.280 --> 19:31.280
先把它二进制简一

19:31.280 --> 19:32.680
得到反骂

19:32.680 --> 19:35.600
然后将零看作一

19:35.600 --> 19:38.360
一看作零

19:38.360 --> 19:40.560
就除了第一位符号位之外

19:40.560 --> 19:41.600
将零看作一

19:41.600 --> 19:42.200
一看作零

19:42.200 --> 19:42.960
比方说这个

19:42.960 --> 19:43.440
这一部分

19:43.440 --> 19:43.800
对吧

19:43.800 --> 19:44.880
得到反骂过后

19:44.880 --> 19:46.040
你把零看作是一

19:46.040 --> 19:47.560
一看作是零就完事了

19:47.560 --> 19:49.760
也可以这样子来处理

19:49.760 --> 19:50.440
总之呢

19:50.440 --> 19:52.680
你得到二进制的就是取反过后

19:52.680 --> 19:53.320
变成这个样子

19:53.320 --> 19:53.640
对吧

19:53.640 --> 19:54.520
变成这个样子

19:54.560 --> 19:55.840
过后了你怎么来看呢

19:55.840 --> 19:57.400
我们首先得到反骂

19:57.400 --> 19:58.120
反骂

19:59.880 --> 20:01.560
就是得到取反过后

20:01.560 --> 20:02.200
它是个复数

20:02.200 --> 20:03.320
这个复数到底是多少

20:03.320 --> 20:04.640
我们先得到反骂

20:04.640 --> 20:06.040
反骂得到的结果是啥呢

20:06.040 --> 20:06.720
就是简一

20:06.720 --> 20:07.280
对吧

20:07.280 --> 20:08.040
简一的话

20:08.040 --> 20:09.800
你看这里向前进一位

20:09.800 --> 20:10.120
对吧

20:10.120 --> 20:12.000
向前进一位就变成了零一

20:12.000 --> 20:13.720
这里变成了零一

20:13.720 --> 20:16.200
然后得到反骂过后

20:16.200 --> 20:17.400
一变零零变一

20:17.400 --> 20:17.760
对吧

20:17.760 --> 20:18.760
一变零零变一

20:18.760 --> 20:19.560
就是零了

20:19.560 --> 20:19.880
对吧

20:19.880 --> 20:21.560
零是不是三

20:21.560 --> 20:23.240
是不是三

20:24.560 --> 20:25.400
对吧

20:25.400 --> 20:26.240
是二对吧

20:26.240 --> 20:27.240
妖龄就是二

20:27.240 --> 20:27.800
就是二

20:27.800 --> 20:29.400
所以说最终的结果是富二

20:30.400 --> 20:32.000
最终的结果是富二

20:32.000 --> 20:33.240
看一下保存一下

20:34.440 --> 20:35.160
富二

20:35.160 --> 20:36.200
你要这样子看

20:36.200 --> 20:37.120
你要这样子看

20:37.880 --> 20:39.520
当然还有一种更加取反

20:39.520 --> 20:41.240
更加简洁的办法

20:41.240 --> 20:46.040
取反的快速运算

20:46.800 --> 20:47.640
取反的快速运算

20:47.640 --> 20:48.480
是怎么来运算的

20:48.480 --> 20:50.560
就是如果你要以后比试的时候

20:50.560 --> 20:53.200
万一遇到的未运算

20:53.200 --> 20:53.800
不太可能

20:53.800 --> 20:54.400
不太可能

20:54.440 --> 20:56.280
所以说把它作为扩展课程

20:56.280 --> 20:58.040
万一遇到了未运算

20:58.040 --> 21:00.520
那么它有一种快速运算的方式

21:00.520 --> 21:03.120
就在面试的比试的时候

21:03.120 --> 21:04.360
那么怎么来看呢

21:04.360 --> 21:10.740
就是取反的数字

21:10.740 --> 21:12.980
把它变成复数

21:12.980 --> 21:15.140
然后减一就完事了

21:15.140 --> 21:16.340
这是你的数字

21:16.340 --> 21:17.660
数字它要取反吗

21:17.660 --> 21:18.780
对这个数字取反

21:18.780 --> 21:20.460
把它变成给它前面加个复号

21:20.460 --> 21:21.780
然后减一就完事了

21:21.780 --> 21:22.220
看一下呗

21:23.540 --> 21:25.340
这个一变成富一

21:25.340 --> 21:26.780
富一减一是不是富二

21:26.780 --> 21:27.220
对吧

21:27.220 --> 21:28.260
富一减一富二

21:28.260 --> 21:31.500
那么二富二减一富三

21:31.500 --> 21:33.100
看一下富三

21:33.100 --> 21:34.580
这是最简单的看法

21:34.580 --> 21:35.380
富三

21:35.380 --> 21:37.020
至于数学原理的话

21:37.020 --> 21:38.340
你自己去想

21:38.340 --> 21:40.580
我数学也没那么好

21:40.580 --> 21:41.300
也没那么好

21:41.300 --> 21:42.820
我证明不出来为什么会这样子

21:42.820 --> 21:44.540
它确实是这样子

21:44.540 --> 21:45.500
然后比方说

21:45.500 --> 21:47.660
一对富二取反

21:47.660 --> 21:48.860
富二取反是什么呢

21:48.860 --> 21:51.340
在富二前面加一个复号

21:51.340 --> 21:52.580
变成振二了

21:52.580 --> 21:54.020
振二减一

21:54.060 --> 21:55.380
振二减一多少

21:55.380 --> 21:57.580
振二减一就是一

21:57.580 --> 21:59.740
富二取反等于一

21:59.740 --> 22:02.060
比方说你对零取反

22:02.060 --> 22:05.140
对零取反是不是富零减一

22:05.140 --> 22:07.860
就是富一

22:07.860 --> 22:10.900
比方说你对NAN取反

22:10.900 --> 22:13.820
NAN你直接看作是零就完事了

22:13.820 --> 22:15.060
你看得到富一

22:15.060 --> 22:16.180
一样的

22:18.940 --> 22:20.380
刚才写的是一

22:20.380 --> 22:21.780
对吧

22:21.780 --> 22:23.780
其实这里我们有一个技巧

22:23.820 --> 22:25.060
关于这个否认算

22:25.060 --> 22:26.300
一个技巧

22:26.300 --> 22:28.660
就是届始终

22:28.660 --> 22:32.580
最快速的取整

22:32.580 --> 22:34.940
最快速取整的方式

22:34.940 --> 22:35.940
最快速取整的方式

22:35.940 --> 22:36.700
什么方式呢

22:36.700 --> 22:37.340
这样子写呆

22:40.460 --> 22:41.660
整数

22:41.660 --> 22:44.100
这是最快速取整的方式

22:44.100 --> 22:46.580
比方说

22:46.580 --> 22:50.900
我们这里快速取整

22:50.980 --> 22:54.580
它的执行速度是超级快的

22:54.580 --> 22:57.700
因为微运算的执行效率非常非常高

22:57.700 --> 23:01.580
它是直接经过CPU一个加发器一下就完了

23:01.580 --> 23:03.300
或者是取反器一下就完了

23:03.300 --> 23:04.460
瞬间就完成了

23:04.460 --> 23:06.300
没有比这个更快的了

23:06.300 --> 23:07.180
快速取整

23:07.180 --> 23:08.060
怎么取整呢

23:08.060 --> 23:10.420
比方说我有一个小数

23:10.420 --> 23:11.500
随便写个小数

23:11.500 --> 23:12.620
我要给它取整

23:12.620 --> 23:13.100
好

23:13.100 --> 23:15.860
我先给它加一个取反

23:15.860 --> 23:16.740
加取反了过后

23:16.740 --> 23:18.460
它是不是一定要把它转换成整数

23:18.460 --> 23:19.140
对吧

23:19.180 --> 23:21.220
把它转换成三来进行取反

23:21.220 --> 23:21.500
好

23:21.500 --> 23:22.540
取反过后是多少

23:22.540 --> 23:24.180
就是负三减一是负四

23:24.180 --> 23:24.860
对吧

23:24.860 --> 23:25.220
好

23:25.220 --> 23:26.940
然后再对负四再取反

23:28.380 --> 23:31.100
那么就是加了再加个负号的前面

23:31.100 --> 23:32.620
我们一个个来吧

23:32.620 --> 23:33.940
看一下这个表达式

23:33.940 --> 23:35.180
看一下这个表达式

23:35.180 --> 23:37.820
那么这个表达式等于啥呢

23:37.820 --> 23:39.540
首先对这一部分

23:39.540 --> 23:40.940
对这一部分

23:40.940 --> 23:42.900
首先把它转换成整数

23:42.900 --> 23:44.660
三对吧

23:44.660 --> 23:46.300
然后再干嘛呢

23:46.300 --> 23:47.420
又等于啥呢

23:47.460 --> 23:50.100
又等于把这一部分运算出来

23:50.100 --> 23:50.900
对三取反

23:50.900 --> 23:52.460
对三取反是不是负四

23:52.460 --> 23:52.740
对吧

23:52.740 --> 23:54.380
负四

23:54.380 --> 23:55.620
对负四又取反

23:55.620 --> 23:57.220
那就是四减一

23:57.220 --> 23:57.500
对吧

23:57.500 --> 23:58.460
四减一

23:58.460 --> 24:00.100
负四前面加个负号

24:00.100 --> 24:01.620
就是四减一

24:01.620 --> 24:02.980
就是三

24:02.980 --> 24:04.340
你看快速取整

24:04.340 --> 24:05.620
就用这种方式

24:05.620 --> 24:08.420
当然我不建议大家在公司里面

24:08.420 --> 24:09.340
用这种方式

24:09.340 --> 24:11.100
其实你如果上午的公开课的话

24:11.100 --> 24:14.180
你会知道我是从来不喜欢炫技的

24:14.180 --> 24:16.660
因为我觉得把单码这个东西

24:16.660 --> 24:17.860
你是给人看的

24:17.860 --> 24:19.220
我反复强调

24:19.220 --> 24:21.380
不是给神仙看的

24:21.380 --> 24:22.420
不是给上帝看的

24:22.420 --> 24:23.540
是给人看的

24:23.540 --> 24:26.020
一定要让他知道你到底是啥意思

24:26.020 --> 24:28.300
以后我们取整数有更好的方式

24:28.300 --> 24:30.020
更加容易阅读的方式

24:30.020 --> 24:31.820
虽然说这种做法

24:31.820 --> 24:32.700
效率很高

24:32.700 --> 24:34.180
而且学习来也简单

24:34.180 --> 24:35.980
但是别人不一定看得懂

24:35.980 --> 24:37.740
不知道你要干嘛

24:37.740 --> 24:39.700
你说你这个东西

24:39.700 --> 24:40.900
你这个单码

24:40.900 --> 24:42.540
能一下子看出来在取整吗

24:42.540 --> 24:43.660
看不出来

24:43.660 --> 24:45.700
看不出来在干嘛

24:45.740 --> 24:47.740
最好是什么样的阅读

24:47.740 --> 24:49.740
比方说取整

24:49.740 --> 24:50.980
你看

24:50.980 --> 24:52.620
比方说以后我们可能是

24:52.620 --> 24:54.580
可能会写成这种格式

24:54.580 --> 24:56.740
这种格式实际下就看明白了

24:56.740 --> 24:57.900
对这个数字进行什么

24:57.900 --> 24:58.500
取整

24:58.500 --> 25:00.500
这才是容易阅读的单码

25:00.500 --> 25:03.500
尽管我们有的地方确实可以炫技

25:03.500 --> 25:06.420
但是不建议大家一定要去使用它

25:06.420 --> 25:08.500
我只是告诉你有这么个东西

25:08.500 --> 25:09.460
你可以面试的时候

25:09.460 --> 25:12.420
吹吹牛只是取这么一个作用

25:13.300 --> 25:15.300
这是关于否运算

25:15.300 --> 25:16.580
好

25:16.580 --> 25:18.580
还有一个议算

25:18.580 --> 25:20.580
叫易获运算

25:20.580 --> 25:22.260
易获运算

25:22.260 --> 25:23.420
这啥意思呢

25:23.420 --> 25:24.100
它指的是

25:24.100 --> 25:25.780
它符号是这个

25:25.780 --> 25:27.020
是一个小三角

25:27.020 --> 25:28.900
向上的小三角

25:28.900 --> 25:30.700
表示啥意思呢

25:30.700 --> 25:31.300
写法

25:31.300 --> 25:33.700
它是这样的写的

25:33.700 --> 25:35.940
写法是数字1

25:35.940 --> 25:38.100
数字1

25:38.100 --> 25:40.140
这叫做易获

25:40.140 --> 25:41.980
数字2

25:41.980 --> 25:43.780
易获数字2

25:43.780 --> 25:45.180
那么它是什么写的呢

25:45.180 --> 25:49.140
它是将数字1和数字2

25:49.140 --> 25:50.580
按位比较

25:50.580 --> 25:52.580
还是一位未来

25:52.580 --> 25:57.580
不同取一

25:57.580 --> 25:58.140
对的

25:58.140 --> 25:59.540
我想想

25:59.540 --> 25:59.820
对

25:59.820 --> 26:02.820
不同取一

26:02.820 --> 26:06.740
相同取零

26:06.740 --> 26:07.500
不同取一

26:07.500 --> 26:08.380
相同取零

26:08.380 --> 26:10.660
比方说

26:10.700 --> 26:11.820
这里呢

26:11.820 --> 26:13.420
看一下

26:13.420 --> 26:18.060
log1

26:18.060 --> 26:21.340
易获3

26:21.340 --> 26:22.620
那么这怎么算的呢

26:22.620 --> 26:23.540
1是零1

26:23.540 --> 26:24.180
对吧

26:24.180 --> 26:25.820
3是11

26:25.820 --> 26:27.420
得到的结果是啥呢

26:27.420 --> 26:28.620
按位来呗

26:28.620 --> 26:29.700
1

26:29.700 --> 26:30.340
相同

26:30.340 --> 26:31.380
是不是取零

26:31.380 --> 26:31.700
对吧

26:31.700 --> 26:32.620
取零

26:32.620 --> 26:33.540
相同取零

26:33.540 --> 26:34.660
不同取一

26:34.660 --> 26:35.900
前面的不同取一

26:35.900 --> 26:37.340
得到的结果就是2

26:37.340 --> 26:38.540
得到的结果是2

26:38.540 --> 26:39.980
保存看一下

26:40.060 --> 26:41.140
结果是12

26:41.140 --> 26:42.700
这就是易获运算

26:42.700 --> 26:43.940
易获运算

26:43.940 --> 26:46.780
易获运算里边有一个可以炫技的小技巧

26:46.780 --> 26:47.260
但是呢

26:47.260 --> 26:48.220
我不体常炫技

26:48.220 --> 26:49.580
但是我会告诉你们

26:49.580 --> 26:50.740
因为

26:50.740 --> 26:52.940
我记得有一个同学

26:52.940 --> 26:54.220
他在面试的时候

26:54.220 --> 26:56.500
那个面试官给他炫技你知道吗

26:56.500 --> 27:00.460
他问他交换两个变量有哪些方式

27:00.460 --> 27:03.820
他问他交换两个变量有哪些方式

27:03.820 --> 27:05.860
其实我们平时交换变量

27:05.860 --> 27:08.020
一般就写一种方式是最好理解的

27:08.020 --> 27:10.060
我不觉得这种方式有什么问题

27:10.060 --> 27:11.020
但是呢

27:11.020 --> 27:13.060
有些人他就喜欢炫技

27:13.060 --> 27:14.180
比方两个变量

27:14.180 --> 27:15.900
两个变量交换

27:15.900 --> 27:17.020
我们写到这边

27:17.020 --> 27:19.660
这边来吧

27:19.660 --> 27:20.820
这里

27:20.820 --> 27:22.980
交换变量

27:22.980 --> 27:27.580
交换变量

27:27.580 --> 27:28.780
好看一下吧

27:30.700 --> 27:30.900
好

27:30.900 --> 27:31.900
第一个变量

27:31.900 --> 27:33.460
等于5

27:33.460 --> 27:34.620
b等于3

27:34.620 --> 27:36.100
好交换变量方式

27:36.100 --> 27:37.900
以最好的方式

27:37.900 --> 27:40.140
反正我最推崇的方式就是这样子

27:40.180 --> 27:43.180
别人一看就知道你在交换变量

27:43.180 --> 27:44.340
不用去想

27:44.340 --> 27:45.700
不用去拍脑袋

27:45.700 --> 27:46.460
不用去纠结

27:46.460 --> 27:47.980
一看就知道你在交换变量

27:47.980 --> 27:49.100
先把a保存下来

27:49.100 --> 27:49.660
对吧

27:49.660 --> 27:51.660
然后把b的值付给a

27:51.660 --> 27:54.180
然后把之前保存的f给b

27:54.180 --> 27:55.260
这就是交换了

27:55.260 --> 27:56.700
交换两个变量了

27:56.700 --> 27:58.300
这是我个人觉得

27:58.300 --> 28:01.100
这是最好的交换方式

28:01.100 --> 28:02.260
大家都看得懂

28:02.260 --> 28:03.500
好

28:03.500 --> 28:07.340
给你看一下

28:07.340 --> 28:07.820
35

28:07.820 --> 28:09.660
看没交换出来就变了

28:09.660 --> 28:12.100
本来是53的变成了35

28:12.100 --> 28:12.420
好吧

28:12.420 --> 28:13.580
这是方式一

28:13.580 --> 28:13.820
好

28:13.820 --> 28:14.700
还有没有别的方式

28:14.700 --> 28:16.180
还有一些别的方式

28:16.180 --> 28:18.060
比方说方式二

28:18.060 --> 28:19.060
方式二

28:19.060 --> 28:20.740
方式二是这样子写的

28:20.740 --> 28:22.100
这样子写的

28:22.100 --> 28:25.540
让a等于a加b

28:25.540 --> 28:26.900
a加b

28:26.900 --> 28:31.180
然后让b等于a减b

28:31.180 --> 28:31.660
不对

28:31.660 --> 28:32.460
我想想

28:32.460 --> 28:34.100
这样子

28:34.100 --> 28:37.020
a等于a加b

28:37.060 --> 28:46.980
然后让b等于a减去b

28:46.980 --> 28:47.460
什么意思

28:47.460 --> 28:48.620
你看前面

28:48.620 --> 28:50.700
a里边保存了什么两个数之和

28:50.700 --> 28:50.980
对吧

28:50.980 --> 28:53.740
现在a里边保存的是两个数之和了

28:53.740 --> 28:56.900
然后a里边保存的是两个数之和

28:56.900 --> 28:58.260
把b减掉

28:58.260 --> 28:59.060
b的值也减掉

28:59.060 --> 29:00.300
是不是就剩下a了

29:00.300 --> 29:01.660
那么就相当于是把a的值

29:01.660 --> 29:03.380
保存到b里边去了

29:03.380 --> 29:04.700
当然你不能这样子写

29:04.700 --> 29:05.700
你现在不能这样子写了

29:05.740 --> 29:07.100
因为a里已经变了

29:07.100 --> 29:09.500
它里边保存的是两个数之和了

29:09.500 --> 29:10.620
然后把b减掉

29:10.620 --> 29:12.620
那么就剩下之前a的值了

29:12.620 --> 29:15.100
之前a的值就保存到b里边

29:15.100 --> 29:17.220
当然这个前提条件

29:17.220 --> 29:20.740
前提条件是两个都是数字

29:20.740 --> 29:21.660
那么第一种方式

29:21.660 --> 29:23.020
不管是不是数字

29:23.020 --> 29:24.500
支付创二其他类型

29:24.500 --> 29:26.340
什么对象类型都可以交换

29:26.340 --> 29:28.100
所以说这种方式更好

29:28.100 --> 29:29.300
第二种方式

29:29.300 --> 29:30.820
它前提条件必须要都是数字

29:30.820 --> 29:32.500
因为要做加减法

29:32.500 --> 29:33.940
要做加减法

29:33.980 --> 29:36.100
那么b里边就保存了a了

29:36.100 --> 29:38.860
然后让a等于什么

29:38.860 --> 29:39.940
再减b

29:41.220 --> 29:42.460
这个声音有意思的

29:42.460 --> 29:45.780
现在b里边保存的是之前a的值了

29:45.780 --> 29:48.020
现在b里边保存的是之前a的值

29:48.020 --> 29:50.260
而a里边保存的是两个数之和

29:50.260 --> 29:52.780
把两个数之和减去之前a的值

29:52.780 --> 29:55.140
是不是剩下之前b的值了

29:55.140 --> 29:56.620
这样子也能完成交换

29:58.540 --> 30:00.580
a和b数出出来就是三和五

30:00.580 --> 30:00.900
看一下

30:02.020 --> 30:03.300
三和五

30:03.300 --> 30:04.260
没问题吧

30:04.260 --> 30:04.900
ok

30:04.900 --> 30:06.140
这种方式

30:06.140 --> 30:08.380
除了方式之外还有一种

30:09.100 --> 30:10.100
还有一种方式

30:10.100 --> 30:11.180
还一种方式

30:12.580 --> 30:14.220
方式3

30:14.220 --> 30:16.380
方式3是怎么写的呢

30:16.380 --> 30:17.660
方式3这样写的

30:19.180 --> 30:22.100
a等于a

30:22.100 --> 30:25.860
e或b

30:25.860 --> 30:28.500
b等于a

30:28.500 --> 30:32.140
e或b

30:32.140 --> 30:37.860
然后a再等于a的e或b

30:37.860 --> 30:39.340
这是啥

30:39.340 --> 30:40.460
咱们来看一下吧

30:40.460 --> 30:43.900
a等于5b等于3

30:43.900 --> 30:45.140
a5是多少呢

30:45.140 --> 30:47.900
5的话就101

30:47.900 --> 30:48.860
b等于3

30:48.860 --> 30:50.420
b等于3就是011

30:50.420 --> 30:51.700
b等于3就是011

30:51.700 --> 30:54.020
好第一步完成过后

30:54.020 --> 30:56.740
取e或a的值是多少

30:56.740 --> 30:57.820
a的值你看呗

30:57.820 --> 31:00.740
这两个取e或a和b取e或

31:00.780 --> 31:03.940
取e或的话相同取0不同取1

31:03.940 --> 31:05.620
那就是110

31:05.620 --> 31:06.260
对吧

31:06.260 --> 31:07.700
a里面是不是110

31:07.700 --> 31:09.340
你甭管110等于多少

31:09.340 --> 31:10.940
110等于6

31:10.940 --> 31:12.260
等于6

31:12.260 --> 31:13.620
110是等于6的

31:13.620 --> 31:14.540
甭管是多少

31:14.540 --> 31:16.700
反正总之它里面存到110

31:16.700 --> 31:18.300
好第二步

31:18.300 --> 31:20.380
再把这个110

31:20.380 --> 31:22.220
然后来e或啥

31:22.220 --> 31:23.540
来e或b

31:23.540 --> 31:24.340
b的值是什么

31:24.340 --> 31:25.540
b的值现在还没变

31:25.540 --> 31:27.180
011

31:27.180 --> 31:28.620
110e或011

31:28.620 --> 31:29.980
得到的结果是啥

31:30.100 --> 31:31.500
得到的结果

31:31.500 --> 31:32.740
看一下是啥

31:32.740 --> 31:35.420
是不是101

31:35.420 --> 31:37.380
b里面是不是保存了a

31:37.380 --> 31:38.780
a之前不就是101吗

31:38.780 --> 31:39.460
对吧

31:39.460 --> 31:40.180
101是多少

31:40.180 --> 31:41.860
101不就是5吗

31:41.860 --> 31:42.620
对不对

31:42.620 --> 31:45.220
b里面就保存了101了

31:45.220 --> 31:47.460
好现在b里面保存了101了

31:47.460 --> 31:48.780
保存了之前a的值了

31:48.780 --> 31:50.420
然后又来

31:50.420 --> 31:51.900
又把a和b取e或

31:51.900 --> 31:53.180
a的值现在还没变

31:53.180 --> 31:54.220
还是110

31:54.220 --> 31:55.460
再e或什么

31:55.460 --> 31:56.940
101

31:56.940 --> 31:58.260
再e或101

31:58.260 --> 31:59.580
e或101过后

31:59.580 --> 32:01.060
得到的结果是什么了

32:01.060 --> 32:03.020
又变成了什么

32:03.020 --> 32:05.060
1 1

32:05.060 --> 32:06.220
是不是3

32:06.220 --> 32:07.300
对不对

32:07.300 --> 32:08.740
你不要问我数学

32:08.740 --> 32:09.900
数学原理是啥

32:09.900 --> 32:11.460
让我给你用数学来证明

32:11.460 --> 32:13.660
我证明不出来

32:13.660 --> 32:14.580
我只能告诉你

32:14.580 --> 32:16.740
这种方式是可以的

32:16.740 --> 32:19.460
这也是一种交换辨量的方式

32:19.460 --> 32:22.180
也输出

32:22.180 --> 32:23.860
log a b

32:23.860 --> 32:25.820
保存

32:25.820 --> 32:28.060
3和5

32:28.060 --> 32:30.420
好那么我们这里学了这么几个运算

32:30.460 --> 32:32.460
就是与运算或运算

32:32.460 --> 32:34.620
否运算以及易获运算

32:34.620 --> 32:36.580
这里我们说一个运用

32:36.580 --> 32:38.740
一个比较

32:38.740 --> 32:40.340
算是这个运运算这里

32:40.340 --> 32:42.300
我们在以后的实际开发中

32:42.300 --> 32:44.980
算是一个相对来说

32:44.980 --> 32:46.420
比较长的场景

32:46.420 --> 32:48.700
当然你如果做一些简单的项目的话

32:48.700 --> 32:50.420
也遇不到

32:50.420 --> 32:51.700
可能做一些复杂的项目

32:51.700 --> 32:53.940
可能会遇到一个运用场景

32:53.940 --> 32:54.940
当然你不用它

32:54.940 --> 32:57.660
也可以用其他方式照样没问题

32:57.700 --> 33:00.940
只是因为运运算可以极大的提高效率

33:00.940 --> 33:02.500
好这个运用场景还蛮常见的

33:02.500 --> 33:04.020
而且很多开发者都知道

33:04.020 --> 33:05.420
所以给大家说一下

33:05.420 --> 33:10.020
就是比方说我们这里有一个

33:10.020 --> 33:11.500
应该这样说

33:11.500 --> 33:15.540
就是这个运用场景应该怎么来说呢

33:15.540 --> 33:18.100
应该说

33:18.100 --> 33:19.300
叠加

33:19.300 --> 33:21.100
就是未的叠加

33:21.100 --> 33:23.420
叠加

33:23.420 --> 33:25.540
有的时候也叫做未的开关

33:25.540 --> 33:27.540
未的开关

33:27.540 --> 33:29.140
好这个场景是什么样的场景

33:29.140 --> 33:30.420
给大家举个例子

33:30.420 --> 33:32.220
这里

33:32.220 --> 33:35.500
未的开关

33:35.500 --> 33:36.900
比方说

33:36.900 --> 33:38.500
我们做了一个系统的时候

33:38.500 --> 33:41.020
可能这个系统里边会有一些权限

33:41.020 --> 33:43.420
针对某些资源会有一些权限

33:43.420 --> 33:45.340
一共就这么几个权限

33:45.340 --> 33:47.500
比方说咱们用一个对象来

33:47.500 --> 33:49.020
把它表述出来

33:49.020 --> 33:49.900
表示了

33:49.900 --> 33:52.740
permint性

33:52.740 --> 33:53.660
permint什么意思

33:53.660 --> 33:54.740
就表示权限

33:54.740 --> 33:55.900
就表示权限的意思

33:55.940 --> 33:56.860
我就简写吧

33:56.860 --> 33:59.220
permint一个对象

33:59.220 --> 34:01.020
这个对象里边保存

34:01.020 --> 34:02.300
保存

34:02.300 --> 34:06.260
保存了所有可能的权限

34:06.260 --> 34:07.180
所谓的可能的权限

34:07.180 --> 34:08.420
保存了对象里边

34:08.420 --> 34:09.180
有哪些权限

34:09.180 --> 34:10.700
比方说独权限

34:10.700 --> 34:12.700
red独这个权限

34:12.700 --> 34:13.860
好给它复制

34:13.860 --> 34:14.980
复制的时候

34:14.980 --> 34:16.460
我们就这样复制

34:16.460 --> 34:18.180
看着

34:18.180 --> 34:20.180
把它复制为1

34:20.180 --> 34:21.620
好写权限

34:21.620 --> 34:22.460
right

34:22.460 --> 34:25.700
把它复制为2

34:25.700 --> 34:27.220
然后还有什么

34:27.220 --> 34:28.620
除了独和写之外

34:28.620 --> 34:29.700
还有改

34:29.700 --> 34:30.940
修改权限

34:30.940 --> 34:32.420
修改权限把它复制为4

34:32.420 --> 34:34.340
你看始终是2的多次方

34:34.340 --> 34:35.420
2的0次方

34:35.420 --> 34:36.380
2的1次方

34:36.380 --> 34:37.780
2到2次方

34:37.780 --> 34:39.940
以后告诉大家为什么要这样写

34:39.940 --> 34:42.900
这是修改权限

34:42.900 --> 34:44.020
修改权限

34:44.020 --> 34:47.780
这个是写权限

34:47.780 --> 34:51.900
就是有些资源你可以写它

34:51.900 --> 34:53.340
写其实就是修改

34:53.540 --> 34:54.660
那么我们换一下

34:54.660 --> 34:57.140
create

34:57.140 --> 34:59.620
表示这个是创建权限

34:59.620 --> 35:00.620
有些资源

35:00.620 --> 35:01.740
比方说文件

35:01.740 --> 35:03.180
对某个文件

35:03.180 --> 35:05.580
我们可能有一些权限

35:05.580 --> 35:06.540
创建权限

35:06.540 --> 35:07.980
创建一个文件的权限

35:07.980 --> 35:11.060
或者是修改文件的权限

35:11.060 --> 35:13.940
也叫做修改权限

35:13.940 --> 35:16.420
那么独就是把它取出来

35:16.420 --> 35:17.500
看这个文件内容

35:17.500 --> 35:19.420
这是独权限

35:19.420 --> 35:21.260
就是有些权限位

35:21.260 --> 35:22.780
当然不一定是文件

35:22.820 --> 35:24.740
有可能是针对某一篇文章

35:24.740 --> 35:27.580
或者是针对了某一个评论之类的

35:27.580 --> 35:29.580
我们总是有一些权限控制

35:29.580 --> 35:31.420
我们可以用个对象来表述它里边

35:31.420 --> 35:33.140
有这么一些权限

35:33.140 --> 35:35.700
有的时候我们需要对这些权限进行组合

35:35.700 --> 35:36.300
对吧

35:36.300 --> 35:38.140
就是你可以读又可以写

35:38.140 --> 35:39.500
有的时候你可以读

35:39.500 --> 35:40.380
你可以创建

35:40.380 --> 35:41.460
但是你不能改

35:41.460 --> 35:42.860
有的时候你可以改

35:42.860 --> 35:43.620
你可以创建

35:43.620 --> 35:44.660
但是你不能读

35:44.660 --> 35:46.460
它可以进行组合的

35:46.460 --> 35:48.340
那我怎么来描述这个组合关系

35:48.340 --> 35:49.820
我们可以这样来做

35:49.860 --> 35:53.100
看着非常一个非常取巧的办法

35:53.100 --> 35:55.500
为什么我要把它设置成124

35:55.500 --> 35:56.660
大家看一下

35:56.660 --> 35:58.860
1的二净字格式是啥

35:58.860 --> 36:01.900
1的二净字格式是不是0001

36:01.900 --> 36:04.700
2的二净字格式是啥

36:04.700 --> 36:06.300
0010

36:06.300 --> 36:08.060
4的二净字格式呢

36:08.060 --> 36:10.100
0100

36:10.100 --> 36:11.820
发现规律没

36:11.820 --> 36:13.340
每一个基础权限

36:13.340 --> 36:15.340
是不是占了二净字其中的一位

36:15.340 --> 36:15.780
对吧

36:15.780 --> 36:17.060
一位就为1

36:17.060 --> 36:18.900
那么我们就可以通过这个位置上

36:18.980 --> 36:21.460
有没有1来判断

36:21.460 --> 36:23.300
它有没有这个权限

36:23.300 --> 36:24.060
明白这个意思吧

36:24.060 --> 36:25.180
我们可以通过这个位置上

36:25.180 --> 36:26.300
有没有1来判断

36:26.300 --> 36:27.580
这个有没有一个权限

36:27.580 --> 36:28.820
当然我们在GS

36:28.820 --> 36:30.260
在GS里面我们知道

36:30.260 --> 36:32.260
GS可以直接用二净字来表示数字

36:32.260 --> 36:34.060
前面加个0B就行了

36:34.060 --> 36:36.300
就表示它的是二净字

36:36.300 --> 36:38.820
好 咱们把这个对象打印出来

36:38.820 --> 36:40.020
Purr

36:40.020 --> 36:41.820
打印出来 看一下这个对象

36:41.820 --> 36:44.020
运行

36:44.020 --> 36:44.820
之前我说过

36:44.820 --> 36:45.980
字面量表示的时候

36:45.980 --> 36:47.580
你看 是不是124 对吧

36:47.580 --> 36:48.700
124

36:48.700 --> 36:50.220
它的实净字就是124

36:50.220 --> 36:51.260
我们直接用二净字

36:51.260 --> 36:52.220
为来表示

36:52.220 --> 36:54.220
我们也可以直接写三位

36:54.220 --> 36:55.820
因为四位好像用不到

36:55.820 --> 36:56.260
看呗

36:56.260 --> 36:57.780
我们就可以用二净字这个为

36:57.780 --> 36:59.860
来表示它的各种权限

36:59.860 --> 37:00.820
好了 接下来

37:00.820 --> 37:02.700
我们用变量来组合权限

37:02.700 --> 37:03.540
来组合权限

37:03.540 --> 37:05.220
看着

37:05.220 --> 37:06.940
变量P

37:06.940 --> 37:08.220
变量P中

37:08.220 --> 37:12.420
保存可读可写

37:12.420 --> 37:14.420
它既要可读又要可写

37:14.420 --> 37:16.300
我们会怎么来玩这个事呢

37:16.300 --> 37:17.460
Purr

37:17.460 --> 37:18.580
点锐的 对吧

37:18.620 --> 37:20.020
这是读权限

37:20.020 --> 37:22.740
用祸运算加上一个

37:22.740 --> 37:24.660
right

37:24.660 --> 37:25.300
你看一下

37:25.300 --> 37:26.980
这两者之间进行祸运算

37:26.980 --> 37:29.180
这两个二净字进行祸运算

37:29.180 --> 37:31.180
是不是得到结果就是011了

37:31.180 --> 37:32.900
我们来输出这个P

37:32.900 --> 37:33.780
输出这个P

37:33.780 --> 37:35.660
那么得到它的二净字格式

37:35.660 --> 37:37.060
二净字结果就是三

37:37.060 --> 37:37.900
实净字是三

37:37.900 --> 37:39.180
二净字就是

37:39.180 --> 37:40.700
111 对不对

37:40.700 --> 37:41.820
011

37:41.820 --> 37:43.180
是不是两个位置都有1了

37:43.180 --> 37:44.860
都有1了 对不对

37:44.860 --> 37:45.940
就两个位置都有1了

37:45.940 --> 37:46.940
我们可以用这种方式

37:46.980 --> 37:48.580
轻松的添加权限

37:48.580 --> 37:50.140
轻松的添加权限

37:50.140 --> 37:50.580
对吧

37:50.580 --> 37:52.260
比方说我要可读可写

37:52.260 --> 37:53.420
又要可以创建

37:53.420 --> 37:55.140
我们再加个祸

37:55.140 --> 37:56.620
再加个祸运算

37:56.620 --> 37:58.300
Purr

37:58.300 --> 37:59.540
create

37:59.540 --> 38:00.860
create表示创建的意思

38:00.860 --> 38:02.540
注意命名

38:02.540 --> 38:03.380
看一下

38:03.380 --> 38:05.540
那么两个祸起来就变成7了

38:05.540 --> 38:06.460
变成7了

38:06.460 --> 38:08.940
那么就表示三个位置都有1了

38:08.940 --> 38:11.660
那么它就有这个权限了

38:11.660 --> 38:13.220
那么现在我组合的权限

38:13.220 --> 38:14.420
问题是我怎么来判断

38:14.420 --> 38:15.660
它有没有权限呢

38:15.700 --> 38:17.180
看判断权限

38:17.180 --> 38:18.220
看怎么来判断

38:18.220 --> 38:19.100
贼简单

38:19.100 --> 38:20.500
贼简单

38:20.500 --> 38:22.020
比方说我要看一下

38:22.020 --> 38:23.820
它有没有可读

38:23.820 --> 38:27.820
P中是否有可读权限

38:27.820 --> 38:29.820
有可读权限

38:29.820 --> 38:30.700
怎么来判断呢

38:30.700 --> 38:32.700
我们这样来写

38:32.700 --> 38:35.500
把这个P这个变量

38:35.500 --> 38:40.580
然后跟这个可读取语运算

38:40.580 --> 38:42.700
跟这个可读取语运算

38:42.700 --> 38:44.300
那你想一想

38:44.340 --> 38:45.780
与这个读里面

38:45.780 --> 38:47.340
是不是其他就位置全是0

38:47.340 --> 38:48.020
对吧

38:48.020 --> 38:49.580
其他的位置全是0

38:49.580 --> 38:51.820
那么甭管你的权限里面

38:51.820 --> 38:52.900
其他位置是啥

38:52.900 --> 38:54.420
那么你前边是不是全是0

38:54.420 --> 38:54.780
对吧

38:54.780 --> 38:56.500
因为读里面前面全是0

38:56.500 --> 38:57.420
而语运算的话

38:57.420 --> 38:59.900
必须要两个E才能得到一个E

38:59.900 --> 39:01.500
所以说由于读运算

39:01.500 --> 39:03.900
这个基础权限前面全是0

39:03.900 --> 39:05.300
所以说它0的位置

39:05.300 --> 39:07.060
是不是一定是0

39:07.060 --> 39:08.540
它里面有带0的位置

39:08.540 --> 39:11.340
是不是得到的结果一定是0

39:11.340 --> 39:11.820
没问题吧

39:11.820 --> 39:13.300
你好好理解这句话

39:13.340 --> 39:14.580
因为这个基础权限里面

39:14.580 --> 39:16.300
只有一位是以其他权是0

39:16.300 --> 39:18.380
所以说它原来是0的位置

39:18.380 --> 39:20.380
跟它一群语运算得到的结果

39:20.380 --> 39:21.860
结果里面它是0的地方

39:21.860 --> 39:23.380
肯定是0

39:23.380 --> 39:26.340
那么关键的问题是

39:26.340 --> 39:28.780
它里面对音的位置

39:28.780 --> 39:30.380
有没有E呢

39:30.380 --> 39:30.980
怎么来判断

39:30.980 --> 39:35.100
它对音的位置有没有E呢

39:35.100 --> 39:36.700
这样判断

39:36.700 --> 39:39.780
如果两个取了语运算过后

39:39.780 --> 39:42.900
跟它自己是一样的

39:42.900 --> 39:44.020
你想这个道理

39:44.060 --> 39:47.420
甭管这个权限其他位置是啥

39:47.420 --> 39:49.380
它这个位置一定有E

39:49.380 --> 39:50.060
对吧

39:50.060 --> 39:51.180
这个位置一定有E

39:51.180 --> 39:52.660
其他的位置全部会变成0

39:52.660 --> 39:53.500
但是这个位置

