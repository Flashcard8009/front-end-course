WEBVTT

00:00.370 --> 00:05.370
接下来我们之前学了圆形以及圆形链

00:05.370 --> 00:09.370
这节课咱们就利用圆形链的这些特点

00:09.370 --> 00:15.370
以及利用这个GS里边 语言标准里边给我们提供的一些基础方法

00:15.370 --> 00:17.370
我们来实现一些应用效果

00:17.370 --> 00:21.370
首先我们来学习 先来学习它的基础方法

00:21.370 --> 00:26.370
就是我看用一下我们GS里面提供了哪些基础方法跟我们使用

00:26.370 --> 00:32.370
然后能够去控制或者是获取圆形或者是圆形链上的一些信息

00:32.370 --> 00:34.370
这里我们首先说一点

00:34.370 --> 00:38.370
就是W3C它不推荐直接使用系统成员

00:38.370 --> 00:42.370
以凡是看到什么两个下滑线开头的系统成员

00:42.370 --> 00:44.370
这种系统成员它不推荐你使用

00:44.370 --> 00:46.370
尽管我们现在在浏览器里边可以用

00:46.370 --> 00:51.370
说不准的将来某一天W3C就直接把它抛弃掉了

00:51.370 --> 00:52.370
不准利用了

00:52.370 --> 00:54.370
所以说我们尽量在开发的时候

00:54.370 --> 00:56.370
不要直接使用这个系统成员

00:56.370 --> 00:58.370
我们有的时候为了测试一下可以用它

00:58.370 --> 01:02.370
但是开发的时候真的写代码的时候不要去使用这个成员

01:02.370 --> 01:03.370
圆形是可以使用的

01:03.370 --> 01:06.370
但是隐私圆形这个属性是不能用的

01:06.370 --> 01:08.370
这W3C的官方的说法

01:08.370 --> 01:12.370
所以说我们之后如果要获得一些隐私圆形

01:12.370 --> 01:15.370
或者说要设置一些隐私圆形的东西的时候

01:15.370 --> 01:18.370
要使用相应的方法而不要直接使用它

01:18.370 --> 01:19.370
这是第一个

01:19.370 --> 01:22.370
而且它说到还有一个原因就是你直接使用它的话

01:22.370 --> 01:23.370
会有效率问题

01:23.370 --> 01:25.370
就是你直接更改一个圆形

01:25.370 --> 01:26.370
特别是做更改的时候

01:26.370 --> 01:28.370
更改它的隐私圆形的话

01:28.370 --> 01:30.370
它是可以更改的

01:30.370 --> 01:31.370
它是可以改的

01:31.370 --> 01:33.370
但是你更改的时候会有严重的效率问题

01:33.370 --> 01:35.370
所以说尽量不要去使用它

01:35.370 --> 01:36.370
好吧 第一个

01:36.370 --> 01:39.370
我们看一下哪些基础的方法可以使用

01:39.370 --> 01:43.370
第一个是Object车里边有一个静态方法

01:43.370 --> 01:44.370
就是它对象里边

01:44.370 --> 01:45.370
现在我们要

01:45.370 --> 01:47.370
我们说到这个什么静态方法的时候

01:47.370 --> 01:48.370
你马上要想到什么东西

01:48.370 --> 01:51.370
就是说我们这个Object车第二Prototype

01:51.370 --> 01:53.370
说到这个东西的时候

01:53.370 --> 01:56.370
你应该看到想到的是它是写到这里的

01:56.370 --> 01:57.370
它是写到这里的

01:57.370 --> 02:01.370
就是Object车对象里边的

02:01.370 --> 02:03.370
那如果一个普通对象

02:03.370 --> 02:05.370
表面里创建了一个Object对象

02:05.370 --> 02:06.370
那你能不能使用它

02:06.370 --> 02:07.370
肯定不行

02:07.370 --> 02:10.370
它必须要通过Object车第二

02:10.370 --> 02:11.370
它的属性名来使用

02:11.370 --> 02:13.370
必须要通过 因为它是写到这的

02:13.370 --> 02:14.370
你还在意是吧

02:14.370 --> 02:16.370
比方说就拿这个方法举例吧

02:16.370 --> 02:18.370
要理解这个意思

02:18.370 --> 02:20.370
你现在得理解什么静态

02:20.370 --> 02:22.370
它的意思

02:22.370 --> 02:28.500
咱们直接运行出来

02:28.500 --> 02:33.280
咱们看一下

02:33.280 --> 02:35.280
就每次这个错误

02:35.280 --> 02:36.280
第一次打开页面的时候

02:36.280 --> 02:38.280
那个错误是我这个插件造成的

02:38.280 --> 02:39.280
没有这个插件的话

02:39.280 --> 02:40.280
它不会有这个错误的

02:40.280 --> 02:41.280
不管它

02:41.280 --> 02:42.280
那个不重要

02:42.280 --> 02:45.280
比方说我们这里创建一个对象

02:45.280 --> 02:46.280
一个对象

02:46.280 --> 02:48.280
这个对象里边有没有什么意思

02:48.280 --> 02:50.280
这个什么

02:50.280 --> 02:52.280
Prototype

02:52.280 --> 02:55.280
GetPrototype

02:55.280 --> 02:56.280
有没有这个呢

02:56.280 --> 02:58.280
GetPrototype

02:58.280 --> 02:59.280
有没有呢

02:59.280 --> 03:01.280
我看一下 写对没有

03:01.280 --> 03:03.280
复制一下吧 直接复制过来

03:03.280 --> 03:05.280
有没有呢 是不是Undefined

03:05.280 --> 03:06.280
没有

03:06.280 --> 03:07.280
它是在哪的

03:07.280 --> 03:10.280
它是在Object这个函数里边的

03:10.280 --> 03:11.280
写到这个对象里边的

03:11.280 --> 03:13.280
所以说它创建的对象有没有呢

03:13.280 --> 03:14.280
肯定没有

03:14.280 --> 03:16.280
它创建的对象肯定没有

03:16.280 --> 03:17.280
它不在原型里边

03:17.280 --> 03:18.280
它在这个函数里边

03:18.280 --> 03:20.280
我们把它叫做静态

03:20.280 --> 03:21.280
静态成员

03:21.280 --> 03:23.280
所以我们要静态调用

03:23.280 --> 03:24.280
以后我换句话说

03:24.280 --> 03:25.280
如果说

03:25.280 --> 03:27.280
它在原型里边一个函数

03:27.280 --> 03:28.280
Prototype里边一个函数

03:28.280 --> 03:30.280
那是不是它的对象也可以使用

03:30.280 --> 03:32.280
对吧 因为它对象的隐私原象指向它

03:32.280 --> 03:33.280
比如说下面这个

03:33.280 --> 03:35.280
EasePrototype

03:35.280 --> 03:36.280
那么

03:36.280 --> 03:37.280
就可以使用了

03:37.280 --> 03:38.280
这个就可以使用了

03:38.280 --> 03:39.280
你要这个意思吧

03:39.280 --> 03:40.280
是这么个意思

03:40.280 --> 03:41.280
好 第一个

03:41.280 --> 03:43.280
就是GetPrototype

03:43.280 --> 03:44.280
它是个静态方法

03:44.280 --> 03:45.280
那么它是怎么意思呢

03:45.280 --> 03:48.280
它是获取对象的隐私原型

03:48.280 --> 03:49.280
就是你给它传一个参数

03:49.280 --> 03:50.280
传一个对象进去

03:50.280 --> 03:53.280
它能够得到对象的隐私原象是谁

03:53.280 --> 03:54.280
好 咱们比方说吧

03:54.280 --> 03:55.280
比方说

03:55.280 --> 03:56.280
就这么一个Object

03:56.280 --> 03:57.280
OB借 对吧

03:57.280 --> 03:58.280
我们刚才创建了一个对象

03:58.280 --> 04:00.280
对吧 我想知道它的隐私原象是谁

04:00.280 --> 04:01.280
我们就可以用Object

04:01.280 --> 04:03.280
GetPrototype

04:03.280 --> 04:04.280
把OB借传进去

04:04.280 --> 04:08.280
它就能得到它的隐私原象是谁

04:08.280 --> 04:09.280
我们通过它的隐私原象

04:09.280 --> 04:10.280
就是说

04:10.280 --> 04:12.280
这句代码就相当于是啥呢

04:12.280 --> 04:15.280
这句代码就相当于是OB借

04:15.280 --> 04:16.280
第二 什么

04:16.280 --> 04:17.280
就这个东西

04:17.280 --> 04:18.280
相当于是这个东西

04:18.280 --> 04:20.280
只是我们不准这样的写代

04:20.280 --> 04:22.280
因此我们以后要获得它的隐私原象

04:22.280 --> 04:25.280
我们可以用这种方式来获得

04:25.280 --> 04:26.280
这个意思吧

04:26.280 --> 04:28.280
这是获取它的隐私原象

04:28.280 --> 04:30.280
就是把这种写法拋弃掉了

04:30.280 --> 04:32.280
转而用这种写法

04:32.280 --> 04:34.280
如果我要获取它的構造函数

04:34.280 --> 04:36.280
是不是该这样子写

04:36.280 --> 04:37.280
它隐私原象里面

04:37.280 --> 04:38.280
它指向它的原型

04:38.280 --> 04:40.280
原型里面是对于構造函数

04:40.280 --> 04:42.280
就是Objects

04:42.280 --> 04:43.280
我们甚至可以得到

04:43.280 --> 04:44.280
構造函数的名字

04:44.280 --> 04:45.280
Objects

04:45.280 --> 04:46.280
没问题吧

04:46.280 --> 04:47.280
这是第一个

04:47.280 --> 04:48.280
非常简单

04:48.280 --> 04:49.280
第二个

04:49.280 --> 04:51.280
第二个是实力成员

04:51.280 --> 04:52.280
对吧

04:52.280 --> 04:53.280
它在原型里面的成员

04:53.280 --> 04:55.280
我们把它叫做实力成员

04:55.280 --> 04:56.280
就是对象都可以使用

04:56.280 --> 04:57.280
判断啥呢

04:57.280 --> 04:58.280
判断当前对象

04:58.280 --> 04:59.280
就是谁在调用它

04:59.280 --> 05:01.280
谁在调用它就判断谁

05:01.280 --> 05:02.280
就判断认识

05:02.280 --> 05:05.280
是否在指定的对象的

05:05.280 --> 05:07.280
原型链上

05:07.280 --> 05:09.280
什么意思

05:09.280 --> 05:10.280
什么意思

05:10.280 --> 05:12.280
好 看一下

05:12.280 --> 05:14.280
比方说我们这里

05:14.280 --> 05:15.280
用这种方式吧

05:15.280 --> 05:17.280
我们这里写个函数

05:17.280 --> 05:18.280
函数A

05:18.280 --> 05:19.280
一个函数

05:19.280 --> 05:21.280
然后我们创建一个

05:21.280 --> 05:22.280
函数的对象

05:22.280 --> 05:23.280
创建一个对象

05:23.280 --> 05:26.280
然后咱们看一下这个

05:26.280 --> 05:29.280
看一下Objects的Prototype

05:29.280 --> 05:32.280
然后意思Prototype

05:32.280 --> 05:33.280
Object

05:33.280 --> 05:34.280
得到的是True

05:34.280 --> 05:35.280
它什么意思

05:35.280 --> 05:36.280
判断的是啥呢

05:36.280 --> 05:38.280
判断的是这个东西

05:38.280 --> 05:39.280
这个东西

05:39.280 --> 05:43.280
是不是在Object的原型链上

05:43.280 --> 05:45.280
你看Object是这个东西

05:45.280 --> 05:47.280
我们指定函数的对象

05:47.280 --> 05:48.280
它的原型链是不是

05:48.280 --> 05:49.280
这样子

05:49.280 --> 05:51.280
这是一个原型链的第一条

05:51.280 --> 05:52.280
原型链的第二个节点

05:52.280 --> 05:53.280
对不对

05:53.280 --> 05:54.280
原型链它就是这个东西

05:54.280 --> 05:56.280
原型链的第一个节点

05:56.280 --> 05:57.280
原型链的第二个节点

05:57.280 --> 05:58.280
那么我看的是啥呢

05:58.280 --> 05:59.280
看的是你这个东西

05:59.280 --> 06:01.280
Object的Prototype

06:01.280 --> 06:03.280
Object的Prototype说这个

06:03.280 --> 06:05.280
看它是不是在它的

06:05.280 --> 06:07.280
这个对象的原型链上

06:07.280 --> 06:08.280
只是这么个意思

06:08.280 --> 06:09.280
这么个意思

06:09.280 --> 06:11.280
当然为True

06:11.280 --> 06:12.280
好 那比方说

06:12.280 --> 06:14.280
我来看一下方形的Prototype

06:14.280 --> 06:15.280
方形的原型是不是在它的

06:15.280 --> 06:16.280
原型链上的

06:16.280 --> 06:20.280
方形的Prototype

06:20.280 --> 06:21.280
意思Prototype

06:21.280 --> 06:22.280
Object

06:22.280 --> 06:23.280
看它在它的原型链上

06:23.280 --> 06:24.280
就变成Force了

06:24.280 --> 06:25.280
对吧

06:25.280 --> 06:26.280
变成了Force

06:26.280 --> 06:27.280
看没

06:27.280 --> 06:28.280
我们可以通过这种方式来判断

06:28.280 --> 06:29.280
方形的原型

06:29.280 --> 06:30.280
它肯定不在它的

06:30.280 --> 06:31.280
原型链上

06:31.280 --> 06:32.280
明白这个意思吗

06:32.280 --> 06:34.280
这是这个

06:34.280 --> 06:36.280
直接看某一个对象

06:36.280 --> 06:37.280
它的原型

06:37.280 --> 06:38.280
那比方说

06:38.280 --> 06:39.280
我们再来

06:39.280 --> 06:40.280
我们绕一点

06:40.280 --> 06:41.280
继续绕一下

06:41.280 --> 06:42.280
Object是A的对象

06:42.280 --> 06:43.280
对吧

06:43.280 --> 06:44.280
A的对象

06:44.280 --> 06:45.280
然后我们再来一个

06:45.280 --> 06:46.280
O

06:46.280 --> 06:47.280
这个O

06:47.280 --> 06:50.280
O是一个普通对象

06:50.280 --> 06:51.280
我们来看一下

06:51.280 --> 06:52.280
O

06:52.280 --> 06:53.280
意思Prototype

06:53.280 --> 06:54.280
是不是Object的

06:54.280 --> 06:56.280
原型链上的原型呢

06:56.280 --> 06:57.280
是不是呢

06:57.280 --> 06:58.280
来 告诉我

06:58.280 --> 06:59.280
比方说

06:59.280 --> 07:00.280
这是一道面试题

07:00.280 --> 07:01.280
真用可能成为一道面试题

07:01.280 --> 07:02.280
面试题的话

07:02.280 --> 07:03.280
它可能不会这样直接考虑

07:03.280 --> 07:04.280
但是可能会直接

07:04.280 --> 07:05.280
间接地考虑这个点

07:05.280 --> 07:07.280
在不在它原型�上呢

07:07.280 --> 07:08.280
不在

07:08.280 --> 07:09.280
为什么呢

07:09.280 --> 07:10.280
我们的O是通过它

07:10.280 --> 07:11.280
直接创建的对象

07:11.280 --> 07:12.280
对吧

07:12.280 --> 07:13.280
比方说这一块

07:13.280 --> 07:14.280
创建的对象

07:14.280 --> 07:15.280
这个对象的指向

07:15.280 --> 07:16.280
它的引式原型

07:16.280 --> 07:17.280
原型指向它

07:17.280 --> 07:18.280
但它本身

07:18.280 --> 07:19.280
这个对象本身

07:19.280 --> 07:21.280
它不在它的原型链上

07:21.280 --> 07:22.280
所以说

07:22.280 --> 07:23.280
那么但是我们这样

07:23.280 --> 07:24.280
换动写法

07:24.280 --> 07:26.280
Object

07:26.280 --> 07:28.280
Prototype

07:28.280 --> 07:29.280
O

07:29.280 --> 07:30.280
得到O的引式原型

07:30.280 --> 07:31.280
那么看一下

07:31.280 --> 07:32.280
这个引式原型

07:32.280 --> 07:33.280
在不在

07:33.280 --> 07:35.280
它的原型链上

07:35.280 --> 07:36.280
是变成出了

07:36.280 --> 07:37.280
为什么变成出了

07:37.280 --> 07:38.280
那么比方说

07:38.280 --> 07:39.280
Object穿的一个对象

07:39.280 --> 07:40.280
O在这

07:40.280 --> 07:41.280
那么它的引式原型

07:41.280 --> 07:42.280
是不是指向它

07:42.280 --> 07:43.280
对吧 指向它

07:43.280 --> 07:44.280
那么我们获得

07:44.280 --> 07:45.280
它的引式原型

07:45.280 --> 07:46.280
是不是获取到它了

07:46.280 --> 07:47.280
那它是不是在

07:47.280 --> 07:48.280
它的原型链上

07:48.280 --> 07:49.280
对吧

07:49.280 --> 07:51.280
不要被造云了

07:51.280 --> 07:53.280
它是得到的是一个

07:53.280 --> 07:54.280
判断

07:54.280 --> 07:55.280
总之判断什么呢

07:55.280 --> 07:56.280
判断某一个对象

07:56.280 --> 07:57.280
它是不是在

07:57.280 --> 07:58.280
它的原型链上

08:01.280 --> 08:02.280
有的时候呢

08:02.280 --> 08:03.280
我们可以通过它

08:03.280 --> 08:04.280
来判断一个东西

08:04.280 --> 08:05.280
是不是一个帧数组

08:05.280 --> 08:06.280
看它是不是一个帧数组

08:06.280 --> 08:07.280
怎么来判断

08:07.280 --> 08:08.280
这个帧数组的

08:08.280 --> 08:09.280
现在我们倒是

08:09.280 --> 08:10.280
有了什么

08:10.280 --> 08:11.280
easy array了

08:11.280 --> 08:12.280
对吧

08:12.280 --> 08:13.280
以前没有这个函数的

08:13.280 --> 08:14.280
以前没有的

08:14.280 --> 08:15.280
那么以前怎么来判断呢

08:15.280 --> 08:16.280
我们可以用

08:16.280 --> 08:17.280
这种方式来判断

08:17.280 --> 08:18.280
判断

08:18.280 --> 08:19.280
easy prototype

08:19.280 --> 08:21.280
get

08:21.280 --> 08:22.280
easy prototype

08:22.280 --> 08:24.280
是不是某一个东西

08:24.280 --> 08:25.280
比方说

08:25.280 --> 08:26.280
document

08:26.280 --> 08:28.280
get element

08:28.280 --> 08:30.280
by tagline

08:30.280 --> 08:31.280
by tagline

08:31.280 --> 08:33.280
比方说a元数

08:33.280 --> 08:34.280
看一下

08:34.280 --> 08:35.280
它是不是一个帧数组

08:35.280 --> 08:36.280
可以用这种方式来判断

08:36.280 --> 08:37.280
我们看一下

08:37.280 --> 08:39.280
数组的原型

08:39.280 --> 08:41.280
就是它这个东西

08:41.280 --> 08:42.280
它这个东西肯定是个对象

08:42.280 --> 08:43.280
它肯定有原型

08:43.280 --> 08:44.280
有原型链

08:44.280 --> 08:45.280
看它的原型链

08:45.280 --> 08:46.280
再不在

08:47.280 --> 08:48.280
它的原型链上

08:48.280 --> 08:49.280
有没有数组这个原型

08:49.280 --> 08:50.280
如果有的话

08:50.280 --> 08:51.280
肯定是个帧数组

08:51.280 --> 08:52.280
但是很遗憾它没有

08:52.280 --> 08:54.280
所以它不是一个帧数组

08:56.280 --> 08:57.280
下面这个

08:57.280 --> 08:58.280
对象

08:58.280 --> 08:59.280
上面这个是个语法了

08:59.280 --> 09:00.280
不是方法

09:00.280 --> 09:01.280
是个语法

09:01.280 --> 09:03.280
对象instance of关键字

09:03.280 --> 09:05.280
instance of寒数

09:05.280 --> 09:06.280
这个代码

09:06.280 --> 09:07.280
就可以这样读

09:07.280 --> 09:08.280
读作

09:08.280 --> 09:09.280
某一个东西

09:09.280 --> 09:11.280
是不是某一个东西

09:11.280 --> 09:12.280
可以这样读

09:12.280 --> 09:13.280
某个东西

09:13.280 --> 09:14.280
是不是某个东西

09:14.280 --> 09:15.280
它判断的是啥呢

09:15.280 --> 09:17.280
判断的是寒数的原型

09:17.280 --> 09:19.280
是否在对象的原型链上

09:19.280 --> 09:21.280
跟上面这个非常类似

09:21.280 --> 09:22.280
但是也有区别

09:22.280 --> 09:23.280
比方说

09:23.280 --> 09:24.280
上面这个

09:24.280 --> 09:25.280
我们用er-re

09:25.280 --> 09:26.280
意思

09:26.280 --> 09:27.280
不要说

09:27.280 --> 09:28.280
比方说我们这个

09:28.280 --> 09:29.280
OB几个车

09:29.280 --> 09:33.280
e-zproto-obj

09:33.280 --> 09:34.280
判定结果为force

09:34.280 --> 09:36.280
因为我们这里判定的是

09:36.280 --> 09:37.280
判定的是这个

09:37.280 --> 09:38.280
看一下这个东西

09:38.280 --> 09:39.280
是不是在它的原型链上

09:39.280 --> 09:40.280
那肯定不在

09:40.280 --> 09:41.280
对吧

09:41.280 --> 09:42.280
看这个东西

09:42.280 --> 09:43.280
是不是在它的原型链上

09:43.280 --> 09:44.280
但是我们换种邪法

09:44.280 --> 09:45.280
换这样的邪法

09:45.280 --> 09:46.280
obj

09:46.280 --> 09:48.280
instance of

09:48.280 --> 09:49.280
obj

09:49.280 --> 09:50.280
它就是true

09:50.280 --> 09:51.280
为什么呢

09:51.280 --> 09:52.280
这种邪法它什么意思呢

09:52.280 --> 09:53.280
它指的是

09:53.280 --> 09:55.280
看一下这个obj的原型链上

09:55.280 --> 09:56.280
原型链上

09:56.280 --> 09:57.280
看一下这个obj

09:57.280 --> 09:59.280
它的原型�上

09:59.280 --> 10:00.280
有没有啥呢

10:00.280 --> 10:02.280
有没有这个目标寒数的

10:02.280 --> 10:03.280
原型

10:03.280 --> 10:05.280
它会得到这个目标寒数的原型

10:05.280 --> 10:06.280
所以说

10:06.280 --> 10:07.280
右边必须要传寒数

10:07.280 --> 10:09.280
我们读怎么读呢

10:09.280 --> 10:10.280
obj

10:10.280 --> 10:11.280
是不是一个对象

10:11.280 --> 10:12.280
那肯定是吧

10:12.280 --> 10:13.280
对吧

10:13.280 --> 10:14.280
读出来非常简单

10:14.280 --> 10:15.280
比方说我们一个数组

10:15.280 --> 10:16.280
数字是对象吧

10:16.280 --> 10:17.280
instance of

10:17.280 --> 10:18.280
什么

10:18.280 --> 10:19.280
是不是一个数组

10:19.280 --> 10:20.280
对吧

10:20.280 --> 10:21.280
所以也可以判断

10:21.280 --> 10:22.280
这也是一种判断

10:22.280 --> 10:23.280
是不是真数组的方式

10:23.280 --> 10:24.280
但是不推荐使用

10:24.280 --> 10:25.280
因为这种邪法

10:25.280 --> 10:26.280
在那个

10:26.280 --> 10:27.280
在什么

10:27.280 --> 10:28.280
在那个

10:28.280 --> 10:30.280
如果一个页面有多个

10:30.280 --> 10:31.280
ifreem

10:31.280 --> 10:32.280
ifreem

10:32.280 --> 10:33.280
这个元素

10:33.280 --> 10:34.280
ifreem

10:34.280 --> 10:35.280
如果有这个ifreem的话

10:35.280 --> 10:36.280
不推荐这样子使用

10:36.280 --> 10:38.280
不推荐在ifreem里边这样子使用

10:38.280 --> 10:40.280
除非你可以保证你这个页面

10:40.280 --> 10:41.280
没有ifreem

10:41.280 --> 10:42.280
不然的话会出问题的

10:42.280 --> 10:44.280
因为它跨越了窗口之间

10:44.280 --> 10:45.280
之后

10:45.280 --> 10:47.280
它数组的指向就不一样了

10:47.280 --> 10:49.280
这个戏程了解一下就行了

10:49.280 --> 10:50.280
了解一下就行了

10:50.280 --> 10:51.280
就这个东西呢

10:51.280 --> 10:52.280
不太推荐使用

10:52.280 --> 10:53.280
不太推荐使用

10:53.280 --> 10:54.280
如果

10:54.280 --> 10:55.280
如果页面上没有ifreem

10:55.280 --> 10:56.280
那大大能用

10:56.280 --> 10:57.280
没问题

10:57.280 --> 10:59.280
这样子也可以判断一个东西

10:59.280 --> 11:00.280
是不是真数组

11:00.280 --> 11:01.280
因为我们以后

11:01.280 --> 11:02.280
是不是真数组

11:02.280 --> 11:03.280
其实我们都用

11:03.280 --> 11:04.280
这种新的方式

11:04.280 --> 11:05.280
以至而为

11:05.280 --> 11:06.280
都会用这种方式

11:06.280 --> 11:07.280
这种方式是最好的

11:08.280 --> 11:09.280
这是

11:09.280 --> 11:11.280
关于這個instance

11:11.280 --> 11:12.280
instance

11:12.280 --> 11:13.280
好

11:13.280 --> 11:14.280
我们再来看

11:14.280 --> 11:15.280
很简单

11:15.280 --> 11:16.280
都很简单

11:16.280 --> 11:18.280
object是create

11:18.280 --> 11:20.280
给一个对象进去

11:20.280 --> 11:21.280
它把这个对象

11:21.280 --> 11:23.280
它产生一个新的对象

11:23.280 --> 11:24.280
返回一个新的对象

11:24.280 --> 11:26.280
这个新的对象的隐释原形

11:26.280 --> 11:27.280
指向这个对象

11:27.280 --> 11:28.280
是这么个意思

11:28.280 --> 11:30.280
比方说

11:30.280 --> 11:31.280
连写的OB界

11:31.280 --> 11:32.280
两个中国号

11:32.280 --> 11:33.280
两个大括号

11:33.280 --> 11:34.280
两个大括号

11:34.280 --> 11:35.280
创建了一个

11:35.280 --> 11:37.280
创建了一个就是

11:38.280 --> 11:40.280
创建了一个就是

11:40.280 --> 11:41.280
普通对象

11:41.280 --> 11:42.280
那么这种写法

11:42.280 --> 11:44.280
就相当于是这样子写的

11:44.280 --> 11:47.280
objects create

11:47.280 --> 11:48.280
创建一个什么

11:48.280 --> 11:50.280
创建一个objects

11:50.280 --> 11:51.280
objects

11:51.280 --> 11:53.280
点proto type

11:53.280 --> 11:55.280
以objects的原形

11:55.280 --> 11:57.280
作为新对象的隐释原形

11:57.280 --> 11:59.280
产生一个对象

11:59.280 --> 12:00.280
你看这两个是

12:00.280 --> 12:01.280
效果看

12:01.280 --> 12:02.280
是不是一样的

12:02.280 --> 12:03.280
效果都是一样的

12:03.280 --> 12:04.280
看没

12:04.280 --> 12:05.280
效果都是一样的

12:05.280 --> 12:06.280
明白这个意思吧

12:06.280 --> 12:07.280
就是找到

12:07.280 --> 12:09.280
用objects的原形

12:09.280 --> 12:11.280
作为隐释原形

12:11.280 --> 12:12.280
来创建一个对象

12:12.280 --> 12:14.280
那是不是就是objects的对象

12:14.280 --> 12:15.280
你留一个objects

12:15.280 --> 12:16.280
它是不是隐释原形

12:16.280 --> 12:17.280
也指向它

12:17.280 --> 12:18.280
是这么个意思

12:18.280 --> 12:19.280
这么个意思

12:19.280 --> 12:20.280
比方说

12:20.280 --> 12:21.280
比方说

12:21.280 --> 12:22.280
如果我们这里

12:22.280 --> 12:24.280
有一些花的

12:24.280 --> 12:25.280
比方说

12:25.280 --> 12:27.280
有一个P

12:27.280 --> 12:28.280
它是个对象

12:28.280 --> 12:30.280
x1y等于3

12:30.280 --> 12:31.280
它是3

12:31.280 --> 12:32.280
有一些花的

12:32.280 --> 12:33.280
那么我们这里

12:33.280 --> 12:34.280
创建一个新对象

12:34.280 --> 12:36.280
objects create

12:36.280 --> 12:37.280
创建一个新对象

12:37.280 --> 12:38.280
这个新对象

12:38.280 --> 12:39.280
以P作为隐释原形

12:39.280 --> 12:40.280
那么你看

12:40.280 --> 12:41.280
这个对象就有意思了

12:41.280 --> 12:42.280
这个对象

12:42.280 --> 12:43.280
它本身没有任何东西

12:43.280 --> 12:44.280
但是它的隐释原象

12:44.280 --> 12:45.280
指向的是P

12:45.280 --> 12:46.280
看到没

12:46.280 --> 12:47.280
指向的是P

12:47.280 --> 12:48.280
明白这个意思吧

12:48.280 --> 12:49.280
它现在的结构

12:49.280 --> 12:50.280
是怎么样子的

12:50.280 --> 12:51.280
我把它画一下吧

12:51.280 --> 12:52.280
不画的话

12:52.280 --> 12:53.280
有些人脑袋都

12:53.280 --> 12:54.280
都快炸了

12:54.280 --> 12:57.170
对吧

12:57.170 --> 12:58.170
然后这里

12:58.170 --> 12:59.170
惊姐

12:59.170 --> 13:01.170
惊姐是这个样子

13:01.170 --> 13:02.170
我们这里有个对象P

13:02.170 --> 13:03.170
对吧

13:03.170 --> 13:04.170
对象P

13:05.170 --> 13:06.170
对象P

13:06.170 --> 13:07.170
这个P里面是不是有

13:07.170 --> 13:08.170
包含了什么

13:08.170 --> 13:09.170
包含了什么

13:09.170 --> 13:10.170
x等于什么

13:10.170 --> 13:11.170
这些是

13:11.170 --> 13:12.170
1和33

13:12.170 --> 13:13.170
y等于33

13:13.170 --> 13:14.170
有对象P

13:14.170 --> 13:15.170
对吧

13:15.170 --> 13:16.170
它是不是有隐释原形

13:16.170 --> 13:17.170
它有隐释原形

13:17.170 --> 13:18.170
任何对象都有隐释原形

13:18.170 --> 13:19.170
对吧

13:19.170 --> 13:21.170
它的隐释原形指向谁

13:21.170 --> 13:22.170
它的隐释原形指向谁

13:22.170 --> 13:23.170
它的隐释原形

13:23.170 --> 13:24.170
是不是指向objects的原形

13:24.170 --> 13:25.170
对吧

13:25.170 --> 13:26.170
没问题吧

13:26.170 --> 13:27.170
这个应该

13:27.170 --> 13:28.170
上去可以搞清楚的

13:28.170 --> 13:29.170
对吧

13:29.170 --> 13:30.170
它是通过objects的

13:30.170 --> 13:31.170
构造寒树创建的

13:31.170 --> 13:32.170
因此它的隐释原形

13:32.170 --> 13:35.170
它指向的是objects的原形

13:35.170 --> 13:36.170
所以它指向的是谁

13:36.170 --> 13:37.170
它的隐释原形

13:37.170 --> 13:39.170
它指向的是objects的原形

13:39.170 --> 13:41.170
objects的proto type

13:41.170 --> 13:43.170
它指向了这个

13:43.170 --> 13:45.170
但是它的隐释原形

13:45.170 --> 13:46.170
它的隐释原形

13:46.170 --> 13:47.170
是不是指向鬧了

13:47.170 --> 13:48.170
我们画一下吧

13:48.170 --> 13:49.170
画一下

13:50.170 --> 13:52.170
它指向的是这

13:52.170 --> 13:55.990
这个P是指向的是这

13:55.990 --> 13:57.990
这个寒树还蛮有用的

13:57.990 --> 13:58.990
objects可以指这个寒树

13:58.990 --> 14:00.990
不过它是耶稣武的寒树

14:00.990 --> 14:02.990
如果很老的乳烂器里边

14:02.990 --> 14:03.990
它不会支持的

14:03.990 --> 14:04.990
它不能支持的

14:04.990 --> 14:05.990
那么它上面

14:05.990 --> 14:06.990
就指向的是啥的

14:06.990 --> 14:07.990
指向的是鬧了

14:07.990 --> 14:09.990
它指向的是就是鬧了

14:09.990 --> 14:15.290
它的隐释原形

14:15.290 --> 14:17.290
我这个剑头指的是隐释原形

14:17.290 --> 14:18.290
隐释原形指向的是鬧了

14:18.290 --> 14:19.290
好

14:19.290 --> 14:20.290
那么这个时候

14:20.290 --> 14:21.290
我们用crazy P

14:21.290 --> 14:23.290
把P作为隐释原形

14:23.290 --> 14:24.290
来创建一个新对象

14:24.290 --> 14:26.290
那么创建的新对象

14:26.290 --> 14:28.290
创建的新对象

14:28.290 --> 14:30.290
这里是新对象

14:30.290 --> 14:32.290
新对象里面本身没有任何东西

14:32.290 --> 14:33.290
没有任何东西

14:33.290 --> 14:35.290
但是新对象的隐释原形

14:35.290 --> 14:36.290
它就指向了P了

14:36.290 --> 14:38.290
它指向P这个对象

14:38.290 --> 14:39.290
是这么个意思

14:39.290 --> 14:40.290
这么个意思

14:41.290 --> 14:42.290
它变成这个样子了

14:42.290 --> 14:43.290
新对象它就指向在了

14:43.290 --> 14:44.290
就说新对象

14:44.290 --> 14:45.290
它既能用P里边的东西

14:45.290 --> 14:47.290
又能用objects

14:47.290 --> 14:48.290
Prototype里边的东西

14:48.290 --> 14:49.290
没问题吧

14:50.290 --> 14:51.290
新对象

14:52.290 --> 14:53.290
我没有得到是吧

14:53.290 --> 14:54.290
得到一下吧

14:54.290 --> 14:55.290
obj

14:56.290 --> 14:57.290
obj它既能用X

14:57.290 --> 14:59.290
obj也能用Y

14:59.290 --> 15:02.290
因为obj它指向了

15:02.290 --> 15:03.290
隐释原象指向了它

15:03.290 --> 15:04.290
所以它能用这里边的东西

15:04.290 --> 15:05.290
能不能用objects

15:05.290 --> 15:06.290
所以也能用

15:06.290 --> 15:07.290
对吧

15:07.290 --> 15:08.290
也能用obj

15:08.290 --> 15:10.290
它也能用objects里边的土石菌

15:10.290 --> 15:12.290
这都可以使用

15:12.290 --> 15:13.290
是这么个意思

15:13.290 --> 15:14.290
这么个意思

15:15.290 --> 15:16.290
然后我们再看一下

15:16.290 --> 15:17.290
再看一下obj

15:17.290 --> 15:18.290
再看一下obj

15:18.290 --> 15:20.290
obj在里边的隐释原象里边

15:20.290 --> 15:21.290
你会发现了

15:21.290 --> 15:22.290
这个隐释原象里边

15:22.290 --> 15:23.290
它比较特殊

15:23.290 --> 15:24.290
它没有什么

15:24.290 --> 15:26.290
隐释原象一般都是指向原型的

15:26.290 --> 15:28.290
但是经过我们这么一操作

15:28.290 --> 15:29.290
它这里边

15:29.290 --> 15:30.290
这个隐释原象里边

15:30.290 --> 15:31.290
居然没有constructor

15:31.290 --> 15:32.290
对吧

15:32.290 --> 15:33.290
你看一下之前的时候

15:33.290 --> 15:34.290
所谓的隐释原象

15:34.290 --> 15:36.290
怎么P对象

15:36.290 --> 15:37.290
它的隐释原象

15:37.290 --> 15:38.290
指向的是objects

15:38.290 --> 15:39.290
它一定有constructor

15:39.290 --> 15:40.290
对吧

15:40.290 --> 15:41.290
它一定有这个东西的

15:41.290 --> 15:43.290
因为隐释原象一般的话

15:43.290 --> 15:44.290
都会指向啥

15:44.290 --> 15:46.290
都会指向原型对象

15:46.290 --> 15:47.290
而原型对象我们之前说过

15:47.290 --> 15:48.290
是不是

15:48.290 --> 15:50.290
都有什么constructor

15:50.290 --> 15:51.290
但是你这样子

15:51.290 --> 15:52.290
一操作是不是没了

15:52.290 --> 15:54.290
因为我们这里是个普通对象

15:54.290 --> 15:55.290
普通对象里面没有constructor

15:55.290 --> 15:56.290
而我把普通对象

15:56.290 --> 15:58.290
作为它原型链上的东西了

15:58.290 --> 15:59.290
因此这个原型

15:59.290 --> 16:01.290
这个隐释原象里边

16:01.290 --> 16:03.290
它就没有constructor

16:03.290 --> 16:06.290
就是我们操作的结果

16:06.290 --> 16:07.290
这里还有一个操作

16:07.290 --> 16:09.290
就是可以使用objects to create

16:09.290 --> 16:11.290
这里填一个

16:11.290 --> 16:12.290
必须要写参数

16:12.290 --> 16:13.290
不写参数要爆错的

16:13.290 --> 16:15.290
它说

16:15.290 --> 16:18.290
objects必须要拥有一个

16:18.290 --> 16:20.290
必须要拥有一个对象作为参数

16:20.290 --> 16:21.290
或者是now

16:21.290 --> 16:22.290
now也是支持的

16:22.290 --> 16:23.290
我们这里就说

16:23.290 --> 16:24.290
另外一个操作就是now

16:25.290 --> 16:27.290
我这里拿传一个now进去

16:27.290 --> 16:28.290
传一个now进去是什么意思呢

16:28.290 --> 16:30.290
就告诉产生这个新对象

16:30.290 --> 16:32.290
你产生这个新对象

16:32.290 --> 16:34.290
它的隐释原型是now

16:34.290 --> 16:35.290
于是你看一下

16:35.290 --> 16:37.290
那么于是就变成这样的操作了

16:37.290 --> 16:40.290
变成这样的结果了

16:40.290 --> 16:41.290
这个新的对象

16:41.290 --> 16:43.290
它的隐释原象是now

16:43.290 --> 16:47.110
隐释原象是now

16:47.110 --> 16:49.110
那么这个新对象

16:49.110 --> 16:51.110
新对象你还能

16:51.110 --> 16:52.110
干嘛呢

16:52.110 --> 16:53.110
这个新对象你还能

16:53.110 --> 16:54.110
这个就是

16:54.110 --> 16:55.110
得了它的东西

16:55.110 --> 16:56.110
你看啥都没有

16:56.110 --> 16:57.110
连隐释原象都没有

16:57.110 --> 16:58.110
那它里面有图示军吗

16:58.110 --> 16:59.110
有没有

16:59.110 --> 17:00.110
有没有图示军

17:00.110 --> 17:01.110
肯定没有

17:01.110 --> 17:02.110
对吧

17:02.110 --> 17:03.110
肯定没有

17:03.110 --> 17:04.110
所以说有的时候呢

17:04.110 --> 17:05.110
面试体呢

17:05.110 --> 17:06.110
它特别刁砖

17:06.110 --> 17:07.110
它可能会问你

17:07.110 --> 17:08.110
问你啥了

17:08.110 --> 17:09.110
是不是

17:09.110 --> 17:11.110
所有的对象

17:11.110 --> 17:14.110
原型链最终一定是objects

17:14.110 --> 17:15.110
是不是一定呢

17:15.110 --> 17:17.110
由于它的存在就不一定了

17:17.110 --> 17:18.110
对吧

17:18.110 --> 17:19.110
它可能就给玩些操作

17:19.110 --> 17:20.110
它可能给你加了一些now进去

17:20.110 --> 17:21.110
那么它的

17:21.110 --> 17:22.110
像这种对象

17:22.110 --> 17:23.110
它是不是对象

17:23.110 --> 17:24.110
肯定是对象

17:24.110 --> 17:25.110
肯定是对象

17:25.110 --> 17:27.110
但它的没有隐释原型了

17:27.110 --> 17:29.110
那么它只有它自身的东西了

17:29.110 --> 17:30.110
是这么回事

17:31.110 --> 17:32.110
好 下一个

17:32.110 --> 17:34.110
下一个是在原型上的方法

17:34.110 --> 17:35.110
它说

17:37.110 --> 17:38.110
它是一个判断

17:38.110 --> 17:39.110
判断什么呢

17:39.110 --> 17:40.110
这里传个属性名

17:40.110 --> 17:41.110
判断一个对象

17:41.110 --> 17:42.110
就谁在调用它

17:42.110 --> 17:44.110
判断一个对象

17:44.110 --> 17:45.110
自身

17:45.110 --> 17:47.110
是否拥有

17:47.110 --> 17:48.110
某个属性

17:48.110 --> 17:49.110
比方说

17:49.110 --> 17:51.110
刚才我们玩了一些操作的

17:51.110 --> 17:52.110
对吧

17:52.110 --> 17:53.110
我们刚才玩了

17:53.110 --> 17:54.110
玩了啥操作

17:54.110 --> 17:55.110
不是创造一个P吗

17:55.110 --> 17:56.110
对吧

17:57.110 --> 17:58.110
创造一个P

17:58.110 --> 17:59.110
P

17:59.110 --> 18:00.110
然后我们

18:00.110 --> 18:01.110
又来了一个这个

18:01.110 --> 18:02.110
对吧

18:02.110 --> 18:03.110
Object

18:03.110 --> 18:04.110
Create

18:04.110 --> 18:05.110
P

18:05.110 --> 18:06.110
对吧

18:06.110 --> 18:07.110
P这个对象

18:07.110 --> 18:08.110
作为它的隐释原型

18:08.110 --> 18:09.110
创造一个对象

18:09.110 --> 18:11.110
就形成了这么一种结构

18:11.110 --> 18:12.110
好

18:12.110 --> 18:13.110
然后

18:13.110 --> 18:14.110
对象里边

18:14.110 --> 18:15.110
比方说

18:15.110 --> 18:16.110
OB借角

18:16.110 --> 18:17.110
X是不是可以使用的

18:17.110 --> 18:18.110
OB借角

18:18.110 --> 18:19.110
Y是不是也可以使用

18:19.110 --> 18:20.110
对吧

18:20.110 --> 18:21.110
但是这个XY

18:21.110 --> 18:23.110
是它原型链上的属性

18:23.110 --> 18:25.110
它是不是它自身的属性

18:25.110 --> 18:26.110
不是

18:26.110 --> 18:27.110
那么我们有的时候

18:27.110 --> 18:28.110
需要判断

18:28.110 --> 18:29.110
它是不是自身的属性

18:29.110 --> 18:30.110
那怎么来判断呢

18:30.110 --> 18:31.110
怎么来判断呢

18:31.110 --> 18:32.110
我们可以通过

18:32.110 --> 18:33.110
OB借里面

18:33.110 --> 18:34.110
Object是原型里面有

18:34.110 --> 18:35.110
对吧

18:35.110 --> 18:36.110
所有的对象都有

18:36.110 --> 18:37.110
就是

18:37.110 --> 18:38.110
Has

18:38.110 --> 18:39.110
On

18:39.110 --> 18:40.110
Property

18:40.110 --> 18:41.110
On什么意思

18:41.110 --> 18:42.110
就是自己的

18:42.110 --> 18:43.110
Has什么意思

18:43.110 --> 18:44.110
就是有

18:44.110 --> 18:45.110
拥有自己的属性

18:45.110 --> 18:46.110
Property是属性的意思

18:46.110 --> 18:47.110
这里写属性名

18:47.110 --> 18:48.110
X看有没有呢

18:48.110 --> 18:49.110
Force

18:49.110 --> 18:50.110
是这么个意思

18:50.110 --> 18:51.110
判断自己是不是

18:51.110 --> 18:52.110
拥有没有属性

18:52.110 --> 18:53.110
那如果你

18:53.110 --> 18:54.110
给OB借X

18:54.110 --> 18:55.110
加了一个属性

18:55.110 --> 18:56.110
那现在它自己

18:56.110 --> 18:57.110
就有X属性了

18:57.110 --> 18:58.110
它不会用原型链上的

18:58.110 --> 18:59.110
于是

18:59.110 --> 19:00.110
现在再去判断

19:00.110 --> 19:01.110
它就有了

19:01.110 --> 19:02.110
好

19:02.110 --> 19:03.110
这个东西会影响到啥呢

19:03.110 --> 19:04.110
就是有的时候

19:04.110 --> 19:05.110
我们写循环

19:05.110 --> 19:07.110
特别是循环对象的属性

19:07.110 --> 19:08.110
我们以前讲过

19:08.110 --> 19:10.110
循环对象的属性的时候

19:10.110 --> 19:11.110
对象

19:11.110 --> 19:12.110
属性

19:12.110 --> 19:14.110
循环的时候

19:14.110 --> 19:16.110
它实际上是会循环

19:16.110 --> 19:17.110
循环它这个

19:17.110 --> 19:18.110
原型链上的东西的

19:18.110 --> 19:19.110
实际上会循环原型链

19:19.110 --> 19:20.110
好

19:20.110 --> 19:22.110
咱们来看一下吧

19:22.110 --> 19:23.110
比方说吧

19:23.110 --> 19:24.110
咱们这个P元数

19:24.110 --> 19:25.110
P元数去

19:25.110 --> 19:27.110
这个对象

19:27.110 --> 19:28.110
X

19:28.110 --> 19:29.110
123

19:29.110 --> 19:30.110
Y

19:30.110 --> 19:31.110
456

19:31.110 --> 19:32.110
比方说

19:32.110 --> 19:33.110
我们有这么一个对象

19:33.110 --> 19:34.110
那么这个对象

19:34.110 --> 19:35.110
我把它作为

19:35.110 --> 19:36.110
它的

19:36.110 --> 19:37.110
作为一个原型

19:37.110 --> 19:38.110
作为一个影视原型

19:38.110 --> 19:39.110
创建一个对象

19:39.110 --> 19:40.110
Object

19:40.110 --> 19:41.110
Create

19:41.110 --> 19:42.110
Create

19:42.110 --> 19:43.110
把P传进去

19:43.110 --> 19:44.110
创建这么一个对象

19:44.110 --> 19:45.110
接下来我们来循环

19:45.110 --> 19:46.110
这个

19:46.110 --> 19:47.110
循环OB借

19:47.110 --> 19:48.110
OB借

19:49.110 --> 19:50.110
硬

19:50.110 --> 19:51.110
还记得吗

19:51.110 --> 19:52.110
这个

19:52.110 --> 19:53.110
循环对象的所有属性

19:53.110 --> 19:55.110
它会把属性的名字拿出来

19:55.110 --> 19:56.110
我们把输出

19:56.110 --> 19:57.110
看一下

20:00.110 --> 20:01.110
看一下输出

20:01.110 --> 20:02.110
你看会不会输出

20:02.110 --> 20:03.110
XY对不对

20:03.110 --> 20:04.110
它会输出

20:04.110 --> 20:05.110
对不对

20:05.110 --> 20:06.110
它一定会输出

20:06.110 --> 20:07.110
XY

20:07.110 --> 20:08.110
因此我们这里

20:08.110 --> 20:09.110
得到这么一个结果了

20:09.110 --> 20:10.110
对不对

20:10.110 --> 20:11.110
但是这个XY

20:11.110 --> 20:12.110
它并不是它自己的

20:12.110 --> 20:13.110
它是原型链上的

20:13.110 --> 20:14.110
就是有的时候

20:14.110 --> 20:15.110
我们在便利对象

20:15.110 --> 20:16.110
属性的时候

20:16.110 --> 20:17.110
它便利到

20:17.110 --> 20:18.110
原型链上的东西

20:18.110 --> 20:19.110
我们只需要得到

20:19.110 --> 20:20.110
它自己的东西

20:20.110 --> 20:21.110
于是我们这里

20:21.110 --> 20:22.110
就可以加个判断

20:22.110 --> 20:24.110
加什么判断呢

20:24.110 --> 20:25.110
就是加一个

20:25.110 --> 20:26.110
如果

20:27.110 --> 20:29.110
我们这里先这样子吧

20:29.110 --> 20:30.110
现在OB借

20:30.110 --> 20:31.110
还有自己的属性

20:31.110 --> 20:32.110
ABC

20:32.110 --> 20:33.110
等于

20:33.110 --> 20:34.110
随便写过

20:35.110 --> 20:37.110
你看现在都可以循环出来

20:37.110 --> 20:38.110
ABC属性

20:38.110 --> 20:39.110
A和XY属性

20:39.110 --> 20:40.110
都可以循环出来

20:40.110 --> 20:41.110
如果你不希望

20:41.110 --> 20:42.110
循环这些东西

20:42.110 --> 20:43.110
你加个判断

20:44.110 --> 20:45.110
就是

20:45.110 --> 20:46.110
OB借

20:51.110 --> 20:53.110
然后这里面填上了

20:54.110 --> 20:55.110
把属性名传进去

20:55.110 --> 20:56.110
看一下

20:56.110 --> 20:57.110
是不是自己的属性

20:57.110 --> 20:58.110
是自己的属性

20:58.110 --> 20:59.110
我在循环

21:00.110 --> 21:01.110
我们通常写一个

21:01.110 --> 21:02.110
Full-in循环

21:02.110 --> 21:03.110
就是循环

21:03.110 --> 21:05.110
便利对象的属性的时候

21:05.110 --> 21:06.110
通常都会加这个判断

21:06.110 --> 21:07.110
通常都会加

21:07.110 --> 21:08.110
你看它只便利了

21:08.110 --> 21:09.110
自身能成员

21:09.110 --> 21:10.110
因为很多时候

21:10.110 --> 21:11.110
我们只需要它自身能成员

21:11.110 --> 21:12.110
它原型链上的东西

21:12.110 --> 21:13.110
我们不想管

21:13.110 --> 21:14.110
也不想理它

21:14.110 --> 21:16.110
而其实这里还有一个疑问

21:16.110 --> 21:18.110
如果C型的同学应该发现了

21:18.110 --> 21:20.110
我没有加这个判断的时候

21:20.110 --> 21:21.110
它很奇怪

21:21.110 --> 21:22.110
它为什么没有把

21:22.110 --> 21:23.110
OB几个字上面的东西

21:23.110 --> 21:24.110
打印出来了

21:24.110 --> 21:25.110
它的原型链上

21:25.110 --> 21:27.110
不是有OB几个字吗

21:27.110 --> 21:28.110
有这个东西吗

21:28.110 --> 21:29.110
它为什么没把它打印出来了

21:29.110 --> 21:31.110
是因为它做了特殊处理

21:31.110 --> 21:33.110
它做了什么样的特殊处理

21:33.110 --> 21:35.110
我们后边很快就会学习到

21:35.110 --> 21:37.110
叫做属性描述服

21:37.110 --> 21:38.110
它做了特殊处理的

21:39.110 --> 21:40.110
这个世界上

21:40.110 --> 21:42.110
所有的事情都有原因的

21:42.110 --> 21:43.110
这些现象都有原因的

21:43.110 --> 21:44.110
它没有什么魔法

21:44.110 --> 21:45.110
我们后面学习过后就到了

21:45.110 --> 21:46.110
原来是这么回事

21:47.110 --> 21:48.110
这是这一块

21:49.110 --> 21:51.110
那么支持这一部分就讲完了

21:51.110 --> 21:52.110
了解一下这些方法

21:52.110 --> 21:53.110
有这么一个印象

21:53.110 --> 21:55.110
知道在对原型的处理上

21:55.110 --> 21:57.110
有这么一些方式可以进行处理

21:58.110 --> 21:59.110
我们后边

21:59.110 --> 22:00.110
现在要说

22:00.110 --> 22:02.110
我给大家做什么应用的话

22:02.110 --> 22:04.110
还真做不出来什么应用

22:04.110 --> 22:05.110
真做不出来什么应用

22:05.110 --> 22:06.110
但是有这么一个印象就行了

22:07.110 --> 22:08.110
这是基础方法

22:08.110 --> 22:10.110
接下来我们看一下两个应用

22:11.110 --> 22:12.110
更加多的应用

22:12.110 --> 22:15.110
我们目前的支持都还少一些

22:15.110 --> 22:16.110
不过我们现在可以做

22:16.110 --> 22:18.110
说这么两个应用了

22:18.110 --> 22:19.110
一个是我们之前说过的

22:19.110 --> 22:21.110
就是内数组

22:21.110 --> 22:23.110
转换为真数组

22:23.110 --> 22:24.110
什么叫内数组

22:24.110 --> 22:25.110
就是一个假的数组

22:25.110 --> 22:26.110
它有下标

22:26.110 --> 22:29.110
就是有锁印作为属性

22:29.110 --> 22:30.110
有什么内式属性

22:30.110 --> 22:31.110
我们就说它

22:31.110 --> 22:32.110
看起来像一个数组

22:32.110 --> 22:33.110
可以用副循环循环它

22:33.110 --> 22:35.110
看起来像一个数组

22:35.110 --> 22:36.110
但它不是一个真数组

22:36.110 --> 22:37.110
真的数组是什么

22:37.110 --> 22:38.110
什么叫真数组

22:38.110 --> 22:39.110
真数组

22:39.110 --> 22:40.110
它的原型链上

22:40.110 --> 22:42.110
一定要有Array的Prototype

22:42.110 --> 22:43.110
它一定要有这个东西

22:43.110 --> 22:45.110
这才是真数组

22:45.110 --> 22:46.110
只要没有这个东西

22:46.110 --> 22:47.110
它都不叫真数组

22:47.110 --> 22:49.110
你看这个意思吧

22:49.110 --> 22:50.110
那么这就内数组

22:50.110 --> 22:51.110
内数组那么也需要

22:51.110 --> 22:52.110
转换成真数组

22:52.110 --> 22:53.110
我们之前说过

22:53.110 --> 22:54.110
什么转换方式

22:54.110 --> 22:55.110
Array

22:55.110 --> 22:56.110
Front

22:56.110 --> 22:57.110
对不对

22:57.110 --> 22:58.110
这是一种很好的转换方式

22:58.110 --> 22:59.110
不过这是在

22:59.110 --> 23:01.110
ES6里面才出现的

23:01.110 --> 23:02.110
以前没有的

23:02.110 --> 23:03.110
以前没有

23:03.110 --> 23:04.110
那么以前咋做的呢

23:04.110 --> 23:05.110
以前是用

23:05.110 --> 23:06.110
我们之前说过

23:06.110 --> 23:07.110
以前用这种方式来做

23:07.110 --> 23:08.110
对吧

23:08.110 --> 23:09.110
Sniper

23:09.110 --> 23:10.110
Sniper

23:10.110 --> 23:11.110
创建一个新数组

23:11.110 --> 23:12.110
调了它的Sniper方法

23:12.110 --> 23:13.110
Sniper方法里面

23:13.110 --> 23:14.110
不是一个Core

23:14.110 --> 23:15.110
对吧

23:15.110 --> 23:16.110
一个Core

23:16.110 --> 23:17.110
然后传一个Z

23:17.110 --> 23:18.110
以什么作为Z

23:18.110 --> 23:19.110
把内数组传进去

23:19.110 --> 23:20.110
对吧

23:20.110 --> 23:21.110
以前我们说过这种方式

23:21.110 --> 23:22.110
这种方式不是很好

23:22.110 --> 23:23.110
为什么不是很好呢

23:23.110 --> 23:24.110
是因为这个地方

23:24.110 --> 23:26.110
我们创建了一个新数组

23:26.110 --> 23:27.110
有必要吗

23:27.110 --> 23:28.110
我要转换这个数组

23:28.110 --> 23:29.110
为干嘛

23:29.110 --> 23:30.110
我要创建一个新数组

23:30.110 --> 23:31.110
没有这个必要

23:31.110 --> 23:32.110
我们以前的

23:32.110 --> 23:33.110
创建新数组的目的呢

23:33.110 --> 23:34.110
主要是为了得到这个函数

23:34.110 --> 23:35.110
得到这个方法

23:35.110 --> 23:36.110
Sniper

23:36.110 --> 23:37.110
然后调了它的Core

23:37.110 --> 23:38.110
我们主要的目的是这个

23:38.110 --> 23:39.110
但是现在我们学到

23:39.110 --> 23:40.110
圆形过后就没必要了

23:40.110 --> 23:42.110
没必要去创建新数组了

23:42.110 --> 23:44.110
直接使用Aridial Prototype

23:44.110 --> 23:45.110
因为我们知道

23:45.110 --> 23:46.110
数组里面的方法

23:46.110 --> 23:47.110
全在它的圆形里面

23:47.110 --> 23:48.110
我们直接从圆形里面

23:48.110 --> 23:49.110
去找到这个方法就完事了

23:49.110 --> 23:50.110
对吧

23:50.110 --> 23:51.110
找到这个方法

23:51.110 --> 23:52.110
然后调了它的Core

23:52.110 --> 23:53.110
对吧

23:53.110 --> 23:54.110
所有的东西都有Core

23:54.110 --> 23:55.110
对吧

23:55.110 --> 23:56.110
因为Core在哪Core在这

23:56.110 --> 23:57.110
对不对

23:57.110 --> 23:58.110
所有的函数里面都有Core

23:58.110 --> 23:59.110
所以说Core在这

23:59.110 --> 24:00.110
因此我们Core

24:00.110 --> 24:01.110
调那个方法

24:01.110 --> 24:02.110
Core是用来做什么

24:02.110 --> 24:03.110
绑定Z的

24:03.110 --> 24:05.110
把这个内数组传进去

24:05.110 --> 24:06.110
它就会用这个东西

24:06.110 --> 24:07.110
作为Z式

24:07.110 --> 24:08.110
来进行剪切数组

24:08.110 --> 24:09.110
我又没有给它传

24:09.110 --> 24:10.110
额外的参数

24:10.110 --> 24:11.110
它就把整个数组

24:11.110 --> 24:12.110
剪切出来了

24:12.110 --> 24:13.110
返回一个真数组

24:13.110 --> 24:14.110
大家来看一下吧

24:16.110 --> 24:17.110
比方说吧

24:17.110 --> 24:18.110
Document是

24:21.110 --> 24:23.110
Carry's Nectar

24:23.110 --> 24:24.110
哦

24:24.110 --> 24:25.110
得到一面上所有的A元数

24:25.110 --> 24:26.110
尽管没有A元数

24:26.110 --> 24:27.110
尽管没有A元数

24:27.110 --> 24:28.110
但是我可以

24:28.110 --> 24:29.110
这样子写一杯

24:29.110 --> 24:30.110
对吧

24:30.110 --> 24:31.110
AR

24:32.110 --> 24:33.110
你看一下AR

24:33.110 --> 24:34.110
它是一个伪数组

24:34.110 --> 24:36.110
它的内型是load list

24:36.110 --> 24:37.110
那么我现在知道了

24:37.110 --> 24:38.110
这个东西是

24:38.110 --> 24:39.110
构造函数

24:39.110 --> 24:40.110
构造函数

24:40.110 --> 24:41.110
我们可以看到

24:41.110 --> 24:42.110
AR Instance

24:43.110 --> 24:44.110
load list

24:44.110 --> 24:45.110
你看一下

24:45.110 --> 24:46.110
是不是true

24:46.110 --> 24:47.110
对吧

24:47.110 --> 24:48.110
所以它是一个函数

24:48.110 --> 24:49.110
它的函数的原型在这

24:49.110 --> 24:50.110
对吧

24:50.110 --> 24:52.110
我都看得非常非常清楚了

24:52.110 --> 24:53.110
然后AR

24:53.110 --> 24:54.110
那么我把它

24:54.110 --> 24:55.110
把它转成真数组

24:55.110 --> 24:56.110
怎么转换呢

24:56.110 --> 24:57.110
我们就可以使用

24:57.110 --> 24:58.110
重新给它复辞

24:58.110 --> 24:59.110
重新给它复辞

24:59.110 --> 25:00.110
Array

25:00.110 --> 25:01.110
Prototype

25:01.110 --> 25:02.110
Sniice

25:02.110 --> 25:03.110
我们以前经常这样做

25:03.110 --> 25:05.110
现在直接用Array

25:05.110 --> 25:06.110
Prototype就更加方便了

25:06.110 --> 25:07.110
Call

25:07.110 --> 25:08.110
或者是Apply都行

25:08.110 --> 25:09.110
两个都是一样的意思

25:09.110 --> 25:11.110
AR传进去

25:11.110 --> 25:13.110
AR现在变成一个真数组了

25:13.110 --> 25:14.110
看一下

25:14.110 --> 25:15.110
Array

25:15.110 --> 25:16.110
Ease

25:16.110 --> 25:17.110
Array

25:17.110 --> 25:18.110
AR

25:18.110 --> 25:19.110
变成一个真数组了

25:19.110 --> 25:20.110
看没

25:20.110 --> 25:21.110
那现在这个AR

25:21.110 --> 25:22.110
还是这个东西吗

25:22.110 --> 25:23.110
那肯定不是了

25:23.110 --> 25:24.110
肯定不是了

25:24.110 --> 25:25.110
那现在它变成了啥了

25:25.110 --> 25:26.110
它变成了数组了

25:26.110 --> 25:27.110
Instance

25:28.110 --> 25:29.110
Array

25:29.110 --> 25:30.110
变成了数组了

25:30.110 --> 25:31.110
看没

25:32.110 --> 25:33.110
这是这一块

25:33.110 --> 25:34.110
内数组的转真数组

25:34.110 --> 25:35.110
这个代码你得汇

25:35.110 --> 25:36.110
你得汇

25:36.110 --> 25:37.110
尽管你可以不这样的写

25:37.110 --> 25:38.110
现在我们有更好的写法

25:38.110 --> 25:39.110
但是你得汇

25:41.110 --> 25:42.110
好 终点来了

25:42.110 --> 25:43.110
实现继承

25:45.110 --> 25:46.110
我这里说一下

25:46.110 --> 25:48.110
我要达到一个什么样的效果

25:48.110 --> 25:49.110
什么要继承

25:49.110 --> 25:52.110
继承的是一边向对象里面的一个概念

25:52.110 --> 25:53.110
它指的是

25:54.110 --> 25:56.110
构造函数之间

25:56.110 --> 25:58.110
这个构造函数有的东西

25:58.110 --> 25:59.110
我也要有

25:59.110 --> 26:00.110
有的东西我也要有

26:00.110 --> 26:02.110
就是SB的负类

26:02.110 --> 26:03.110
就是负轻

26:03.110 --> 26:04.110
所以说A的东西

26:04.110 --> 26:05.110
我也得有

26:05.110 --> 26:06.110
这就是继承

26:06.110 --> 26:07.110
我能继承它的东西

26:08.110 --> 26:09.110
那么在GS里边

26:09.110 --> 26:11.110
它怎么来实现继承呢

26:11.110 --> 26:12.110
我们来举个例子

26:12.110 --> 26:14.110
看一下这个图

26:14.110 --> 26:15.110
这个图里边

26:15.110 --> 26:17.110
这个自定义函数你看一下

26:17.110 --> 26:19.110
它的原型

26:19.110 --> 26:21.110
是不是它的隐私原型

26:21.110 --> 26:23.110
指向Object的原型

26:23.110 --> 26:24.110
那么在GS里边

26:24.110 --> 26:25.110
这种现象

26:25.110 --> 26:26.110
我们就认为

26:26.110 --> 26:27.110
这个自定义函数

26:27.110 --> 26:29.110
继承至Object

26:29.110 --> 26:31.110
所以我们有这么一种说法

26:31.110 --> 26:33.110
要知道这个说法

26:33.110 --> 26:34.110
这是面向对象语言里边

26:34.110 --> 26:36.110
它带过来的这种说法

26:36.110 --> 26:38.110
就是我们这里的自定义函数

26:38.110 --> 26:40.110
就是这张图里边的

26:40.110 --> 26:41.110
自定义函数

26:41.110 --> 26:42.110
继承至

26:42.110 --> 26:44.110
如果这个自定函数叫做Ur

26:44.110 --> 26:45.110
比方说

26:45.110 --> 26:46.110
这个函数的名字叫做Ur

26:46.110 --> 26:49.110
Ur继承至Object

26:49.110 --> 26:51.110
我们也可以称之为

26:51.110 --> 26:56.110
Object是Ur的负类

26:56.110 --> 26:57.110
就是有的时候

26:57.110 --> 26:58.110
我们把函数

26:58.110 --> 27:00.110
构造函数也称之为内

27:00.110 --> 27:02.110
Object是Ur的负类

27:02.110 --> 27:04.110
或者叫做Ur是

27:04.110 --> 27:07.110
Object的指内

27:07.110 --> 27:09.110
为什么这样说呢

27:09.110 --> 27:10.110
你看一下

27:10.110 --> 27:12.110
这样子的关系一旦形成

27:12.110 --> 27:13.110
那么自定义函数

27:13.110 --> 27:14.110
创建的对象

27:14.110 --> 27:15.110
就它创建的对象

27:15.110 --> 27:18.110
是不是一定拥有负类里边的东西

27:18.110 --> 27:19.110
对吧

27:19.110 --> 27:20.110
负类原型里边的东西

27:20.110 --> 27:21.110
没问题吧

27:21.110 --> 27:22.110
就这么个意思

27:22.110 --> 27:24.110
它就会自动拥有它里边的东西

27:24.110 --> 27:26.110
因此在默认情况下

27:26.110 --> 27:28.110
默认情况下

27:28.110 --> 27:29.110
这个东西

27:29.110 --> 27:30.110
下一句话我们记到这

27:30.110 --> 27:35.110
默认情况下

27:35.110 --> 27:39.110
所有对象

27:39.110 --> 27:40.110
所有的

27:40.110 --> 27:44.110
所有构造函数的负类

27:44.110 --> 27:48.110
都是Objects

27:48.110 --> 27:50.110
它有这么一个说法

27:50.110 --> 27:52.110
Objects它就没有负类的

27:52.110 --> 27:53.110
它是根

27:53.110 --> 27:54.110
它是所有继承的根

27:55.110 --> 27:56.110
这是关于这一点

27:56.110 --> 27:57.110
这就是为什么

27:57.110 --> 27:58.110
所有的对象它都有

27:58.110 --> 28:00.110
Objects里边的东西

28:00.110 --> 28:02.110
就是这个原因

28:02.110 --> 28:03.110
好 那么我们

28:03.110 --> 28:05.110
如果要自己来实现继承的话

28:05.110 --> 28:06.110
那怎么办呢

28:06.110 --> 28:07.110
这里有个例子

28:07.110 --> 28:08.110
我们看一下

28:08.110 --> 28:10.110
这里我们会产生一个

28:10.110 --> 28:12.110
就是有一个公共的函数

28:12.110 --> 28:14.110
通用的

28:14.110 --> 28:15.110
比方说

28:15.110 --> 28:18.110
我有这么一个构造函数

28:18.110 --> 28:22.000
什么函数呢

28:23.000 --> 28:25.000
优点

28:25.000 --> 28:27.000
一个优的构造函数

28:27.000 --> 28:29.000
它有什么呢

28:29.000 --> 28:31.000
有姓名

28:31.000 --> 28:32.000
有年龄

28:32.000 --> 28:33.000
有姓别

28:33.000 --> 28:35.000
三个函数

28:35.000 --> 28:36.000
构造函数

28:36.000 --> 28:37.000
三个函数

28:37.000 --> 28:38.000
来负责Name

28:38.000 --> 28:39.000
Name

28:39.000 --> 28:40.000
这是A级

28:40.000 --> 28:41.000
等于

28:41.000 --> 28:42.000
或者是这样子吧

28:42.000 --> 28:43.000
这样子

28:43.000 --> 28:45.000
我们写的好玩一点

28:45.000 --> 28:47.000
写的有实际意义一点

28:47.000 --> 28:48.000
First Name

28:48.000 --> 28:50.000
The Last Name

28:51.000 --> 28:52.000
一个姓

28:52.000 --> 28:53.000
一个名

28:53.000 --> 28:54.000
一个年龄

28:54.000 --> 28:55.000
没问题吧

28:55.000 --> 28:56.000
是一样的

28:58.000 --> 28:59.000
然后年龄

29:03.000 --> 29:04.000
年龄 负责

29:04.000 --> 29:06.000
然后再加个属性

29:06.000 --> 29:07.000
Full Name

29:07.000 --> 29:08.000
自动加上一个属性

29:08.000 --> 29:09.000
这个属性等于啥呢

29:09.000 --> 29:11.000
等于ZS.First Name

29:11.000 --> 29:12.000
拼接上

29:12.000 --> 29:13.000
一个空格

29:13.000 --> 29:15.000
再拼接上ZS.Last Name

29:15.000 --> 29:16.000
这是个构造函数

29:16.000 --> 29:17.000
没问题吧

29:18.000 --> 29:19.000
没问题吧

29:19.000 --> 29:20.000
然后给它加上一个

29:20.000 --> 29:22.000
Prototype里边加上一个

29:22.000 --> 29:23.000
Say Hello

29:25.000 --> 29:26.000
这是一个函数

29:26.000 --> 29:27.000
咱们这个函数里边

29:27.000 --> 29:28.000
输出啥呢

29:28.000 --> 29:29.000
输出

29:31.000 --> 29:32.000
大家好

29:33.000 --> 29:36.000
我叫易中天

29:36.000 --> 29:38.000
ZS.First Name

29:38.000 --> 29:39.000
ZS.Full Name

29:40.000 --> 29:41.000
然后干嘛呢

29:43.000 --> 29:45.000
今年多大了

29:45.000 --> 29:46.000
ZS.A级

29:47.000 --> 29:48.000
水呢

29:48.000 --> 29:50.000
好了 写好了

29:50.000 --> 29:52.000
于是我们现在

29:52.000 --> 29:54.000
这个结构是什么样子

29:54.000 --> 29:55.000
我们先把我画出来

29:55.000 --> 29:57.000
画出这个结构

29:57.000 --> 29:59.000
目前这个User

30:01.000 --> 30:03.000
目前我们画出这个结构

30:03.000 --> 30:05.000
这样子吧

30:05.000 --> 30:07.000
这是Object的Prototype

30:07.000 --> 30:08.000
这个没啥好说的

30:08.000 --> 30:10.000
Object的Prototype

30:10.000 --> 30:13.000
然后下边是User

30:13.000 --> 30:15.000
User的Prototype

30:20.140 --> 30:24.140
这是User.Prototype

30:24.140 --> 30:26.140
这是User的原型

30:27.140 --> 30:28.140
这个原型里边

30:28.140 --> 30:30.140
它有一个方法叫Say Hello

30:32.140 --> 30:33.140
形成这么一种结构

30:33.140 --> 30:35.140
然后还有一个User的构造函数

30:35.140 --> 30:37.140
User的构造函数在这

30:37.140 --> 30:39.140
User的构造函数

30:40.140 --> 30:41.140
没问题吧

30:41.140 --> 30:42.140
那么现在创建的User对象

30:42.140 --> 30:44.140
它是不是一定指向

30:44.140 --> 30:46.140
User的原型

30:46.140 --> 30:48.140
如果你创建一个User对象

30:48.140 --> 30:50.140
比方说我们用绿色来表示

30:50.140 --> 30:52.140
绿色来表示创建的对象

30:54.140 --> 30:57.710
那么如果是一个User对象

30:57.710 --> 30:59.710
通过它六一个User对象的话

30:59.710 --> 31:00.710
那么它是不是

31:00.710 --> 31:02.710
它的隐私原型一定指向它

31:02.710 --> 31:03.710
对不对

31:03.710 --> 31:04.710
一定指向它

31:04.710 --> 31:05.710
没问题吧

31:05.710 --> 31:06.710
原型一定指向它

31:06.710 --> 31:07.710
所以说

31:07.710 --> 31:08.710
六的User对象里边

31:08.710 --> 31:09.710
它不仅有了啥

31:09.710 --> 31:10.710
不仅有了这些属性

31:10.710 --> 31:11.710
对吧

31:11.710 --> 31:12.710
因为它创建的过程函数运行

31:12.710 --> 31:14.710
它会给它加上这些属性

31:14.710 --> 31:15.710
它不仅有了这些属性

31:15.710 --> 31:18.710
而且它会有原型里边的方法

31:18.710 --> 31:19.710
没问题吧

31:19.710 --> 31:21.710
这是目前这么一种结构

31:21.710 --> 31:22.710
目前这么一种结构

31:22.710 --> 31:24.710
通过它来创建一个User对象

31:24.710 --> 31:26.710
好 接下来我们还有一个

31:26.710 --> 31:27.710
还有一个函数

31:27.710 --> 31:29.710
叫做VIPUser

31:30.710 --> 31:31.710
VIP用户

31:31.710 --> 31:33.710
VIP用户肯定

31:33.710 --> 31:35.710
它不仅有用户里边的所有属性

31:35.710 --> 31:36.710
所有方法对吧

31:36.710 --> 31:37.710
它肯定功能还更多

31:37.710 --> 31:38.710
对不对

31:38.710 --> 31:39.710
这里我们

31:39.710 --> 31:40.710
比方说有这么一个构造函数

31:40.710 --> 31:41.710
叫VIPUser

31:41.710 --> 31:43.710
咱们大家来看一下

31:43.710 --> 31:44.710
方形

31:44.710 --> 31:46.710
VIPUser

31:47.710 --> 31:48.710
它要传哪些参数呢

31:48.710 --> 31:49.710
还是一样的

31:49.710 --> 31:50.710
它有first-line有那是line

31:50.710 --> 31:51.710
是一样的

31:51.710 --> 31:52.710
A级

31:52.710 --> 31:53.710
还有啥呢

31:53.710 --> 31:55.710
还有目前的VIP用户肯定

31:56.710 --> 31:58.710
目前的充值金额

31:58.710 --> 31:59.710
充值金额

31:59.710 --> 32:00.710
盲利

32:00.710 --> 32:02.710
它多了一个属性了

32:02.710 --> 32:03.710
它除了有之前的属性之外

32:03.710 --> 32:04.710
多了一个属性了

32:04.710 --> 32:06.710
那么首先我们遇到了第一个问题

32:07.710 --> 32:08.710
我们遇到了第一个问题

32:08.710 --> 32:09.710
什么问题呢

32:09.710 --> 32:11.710
就是我们现在

32:11.710 --> 32:13.710
我是不是又得重新复制一遍

32:13.710 --> 32:15.710
我又得重新写个单

32:15.710 --> 32:17.710
如果这个构造函数里面代码有100

32:17.710 --> 32:19.710
我是不是又得重新写一遍

32:19.710 --> 32:20.710
有没有办法

32:20.710 --> 32:22.710
能够降低这样的重复代码

32:22.710 --> 32:23.710
这里是个小问题

32:23.710 --> 32:25.710
这个问题很好解决

32:25.710 --> 32:26.710
来

32:26.710 --> 32:28.710
但是有些人可能都还要蒙

32:28.710 --> 32:29.710
来吧

32:29.710 --> 32:31.710
因为我们以前学过的知识

32:31.710 --> 32:33.710
有没有办法

32:33.710 --> 32:35.710
解决这样的问题

32:35.710 --> 32:37.710
有没有办法呢

32:37.710 --> 32:38.710
有没有办法

32:38.710 --> 32:40.710
这不是又是个函数吗

32:40.710 --> 32:42.710
你雕用一次不就完了吗

32:42.710 --> 32:43.710
你雕用一次

32:43.710 --> 32:44.710
把first-line传进去

32:44.710 --> 32:45.710
那是line传进去

32:45.710 --> 32:46.710
什么A级传进去

32:46.710 --> 32:47.710
雕用一次不就完了吗

32:47.710 --> 32:49.710
让它运行一次函数就完了

32:50.710 --> 32:51.710
真的吗

32:51.710 --> 32:54.220
真的吗

32:54.220 --> 32:55.220
如果真的是这样子的话

32:55.220 --> 32:56.220
它会有问题

32:56.220 --> 32:57.220
为什么

32:57.220 --> 32:59.220
因为你这个函数是直接调用的

32:59.220 --> 33:01.220
直接调用的话函数

33:01.220 --> 33:02.220
认识指向谁

33:02.220 --> 33:03.220
指向谁

33:03.220 --> 33:05.220
是不是指向全就对象了

33:05.220 --> 33:06.220
它把温度对象里面

33:06.220 --> 33:07.220
去加这些东西了

33:07.220 --> 33:08.220
那肯定不行

33:08.220 --> 33:10.220
所以说你不能直接调用

33:10.220 --> 33:11.220
那咋调用了

33:11.220 --> 33:17.340
是这样子吧

33:17.340 --> 33:18.340
游热是个函数

33:18.340 --> 33:19.340
它是不是有call

33:19.340 --> 33:21.340
call是不是可以绑定res

33:21.340 --> 33:23.340
那么我把当前的res绑进去

33:23.340 --> 33:25.340
当前就是创建的当前对象

33:25.340 --> 33:27.340
把当前对象绑进去

33:27.340 --> 33:29.340
然后把参数给它传过去

33:29.340 --> 33:30.340
是不是就运行了

33:30.340 --> 33:32.340
刚才5分就是res出问题

33:32.340 --> 33:33.340
对吧

33:33.340 --> 33:34.340
res出问题会好解决

33:34.340 --> 33:35.340
call

33:35.340 --> 33:36.340
apply

33:36.340 --> 33:37.340
都可以解决这个问题

33:37.340 --> 33:38.340
对吧

33:38.340 --> 33:39.340
那这样子是不是

33:39.340 --> 33:40.340
就把之前的属性复制了

33:40.340 --> 33:43.340
我们没有必要去重新写一遍

33:43.340 --> 33:44.340
把之前的属性复制

33:44.340 --> 33:45.340
这是个小问题

33:45.340 --> 33:47.340
重新运行游热这个函数

33:47.340 --> 33:49.340
然后去重新复制就完成了

33:49.340 --> 33:50.340
现在关系多了一个属性

33:50.340 --> 33:51.340
money

33:51.340 --> 33:52.340
money复制

33:52.340 --> 33:53.340
复制

33:54.340 --> 33:55.340
好 没了

33:55.340 --> 33:56.340
没了

33:56.340 --> 33:57.340
然后VIP游热

33:57.340 --> 33:59.340
它里边也有一个独特的方法

33:59.340 --> 34:00.340
有一个独特的方法

34:00.340 --> 34:01.340
比方说

34:04.340 --> 34:05.340
upgrade

34:05.340 --> 34:06.340
提升等级

34:07.340 --> 34:08.340
提升等级

34:10.340 --> 34:11.340
升级了

34:11.340 --> 34:12.340
然后

34:13.340 --> 34:15.340
使用游热

34:15.340 --> 34:17.340
使用了多少钱

34:17.340 --> 34:18.340
对吧

34:18.340 --> 34:20.340
使用了多少钱的

34:20.340 --> 34:23.340
每一次升级比方说100块吧

34:23.340 --> 34:25.340
使用了100元

34:25.340 --> 34:26.340
100元

34:26.340 --> 34:28.340
软妹币

34:28.340 --> 34:31.720
升级了

34:31.720 --> 34:32.720
举个例子

34:32.720 --> 34:33.720
举个例子

34:33.720 --> 34:34.720
有这么个意思就行了

34:34.720 --> 34:35.720
然后

34:35.720 --> 34:37.720
res

34:37.720 --> 34:39.720
我没有去判断游热

34:39.720 --> 34:40.720
对吧

34:40.720 --> 34:41.720
无所谓举个例子就行了

34:41.720 --> 34:42.720
有这么个例子就行了

34:42.720 --> 34:44.720
只是它有这么一个函数

34:44.720 --> 34:45.720
好 咱们来

34:45.720 --> 34:46.720
咱们来

34:48.720 --> 34:49.720
user

34:49.720 --> 34:51.720
创建一个VIP用户

34:51.720 --> 34:52.720
VIP user

34:52.720 --> 34:54.720
咱们把first name

34:56.720 --> 34:57.720
传进去

34:57.720 --> 35:01.540
first name 写成

35:01.540 --> 35:02.540
成

35:04.540 --> 35:05.540
然后

35:05.540 --> 35:07.540
年龄的话

35:08.540 --> 35:09.540
然后

35:09.540 --> 35:10.540
盲礼

35:10.540 --> 35:11.540
钱

35:11.540 --> 35:13.540
金额的话100块钱

35:13.540 --> 35:14.540
传进去

35:14.540 --> 35:16.540
创建了这么一个VIP用户

35:17.540 --> 35:18.540
好

35:18.540 --> 35:19.540
我们现在看一下

35:19.540 --> 35:21.540
现在成了一个什么样的结果

35:21.540 --> 35:22.540
看内存

35:23.540 --> 35:24.540
VIP用户

35:24.540 --> 35:25.540
它有没有原型

35:25.540 --> 35:26.540
它肯定有原型

35:26.540 --> 35:27.540
对吧

35:27.540 --> 35:28.540
它肯定有原型

35:28.540 --> 35:29.540
VIP用户也有原型

35:29.540 --> 35:30.540
它不就是个用户

35:30.540 --> 35:31.540
对吧

35:31.540 --> 35:32.540
它一个勾导海朔品

35:32.540 --> 35:33.540
这么没有原型

35:33.540 --> 35:34.540
有原型

35:34.540 --> 35:35.540
它里边有啥方法

35:35.540 --> 35:36.540
有啥方法

35:36.540 --> 35:37.540
它里边有啥方法

35:37.540 --> 35:39.540
它里边是不是就有

35:41.540 --> 35:42.540
upgrade

35:42.540 --> 35:43.540
upgrade的方法

35:43.540 --> 35:44.540
它有这个

35:44.540 --> 35:46.540
它有没有say hello

35:46.540 --> 35:47.540
它如果你这里要say hello

35:47.540 --> 35:49.540
是不是又得重新写一遍

35:49.540 --> 35:50.540
麻不麻烦

35:50.540 --> 35:51.540
肯定麻烦

35:51.540 --> 35:53.540
那这里我只写了一个函数

35:53.540 --> 35:55.540
那要是这里有十几二十个函数

35:55.540 --> 35:57.540
我得全部重新写一遍

35:57.540 --> 35:58.540
要凡是

35:58.540 --> 36:00.540
所以说我们只写自己的

36:00.540 --> 36:02.540
就写新的方法就行了

36:02.540 --> 36:03.540
然后

36:03.540 --> 36:04.540
这个原型

36:04.540 --> 36:06.540
当然它这个指向是没有什么问题的

36:06.540 --> 36:07.540
这个指向没什么问题

36:07.540 --> 36:08.540
好

36:08.540 --> 36:09.540
这个原型

36:09.540 --> 36:10.540
它指向谁

36:11.540 --> 36:12.540
它指向谁

36:12.540 --> 36:13.540
又啥区别了

36:13.540 --> 36:14.540
它是不是还是这样的

36:14.540 --> 36:16.540
还是指向的objects

36:16.540 --> 36:17.540
对吧

36:17.540 --> 36:18.540
它这个原型

36:18.540 --> 36:19.540
还是指向的objects

36:19.540 --> 36:20.540
所以说这一块

36:20.540 --> 36:22.540
它指向的还是objects

36:22.540 --> 36:24.540
指向的还是objects

36:24.540 --> 36:26.540
这里我们换一个线

36:26.540 --> 36:27.540
换一个曲线

36:31.540 --> 36:33.540
换一个曲线

36:33.540 --> 36:34.540
这样子

36:34.540 --> 36:36.540
从这里连接过去

36:36.540 --> 36:37.540
连过去

36:38.540 --> 36:39.540
它也是指向的objects

36:39.540 --> 36:40.540
对吧

36:40.540 --> 36:41.540
因此它充电的对象

36:41.540 --> 36:43.540
这个vuser

36:43.540 --> 36:44.540
穿了这个对象

36:44.540 --> 36:45.540
是这个对象吧

36:46.540 --> 36:47.540
那么它的格式

36:47.540 --> 36:48.540
是不是这样子

36:55.540 --> 36:56.540
这里

36:56.540 --> 36:57.540
是这样子

36:58.540 --> 36:59.540
没问题吧

36:59.540 --> 37:00.540
这样子向的

37:00.540 --> 37:01.540
能看懂吧

37:01.540 --> 37:02.540
目前是这样子的

37:02.540 --> 37:04.540
那么vuser里边有哪些属性的

37:04.540 --> 37:05.540
是不是除了

37:05.540 --> 37:06.540
它自己的属性

37:06.540 --> 37:07.540
还有vuser的属性

37:07.540 --> 37:08.540
因为我这里运行了一次

37:08.540 --> 37:09.540
vuser函数

37:09.540 --> 37:10.540
对吧

37:10.540 --> 37:11.540
运行了一次vuser函数

37:11.540 --> 37:12.540
它当然会有vuser的属性

37:12.540 --> 37:14.540
这个没啥问题

37:14.540 --> 37:15.540
就是它对象

37:15.540 --> 37:16.540
本身的属性是没问题的

37:16.540 --> 37:18.540
关键是圆形上面会出问题

37:18.540 --> 37:19.540
圆形上面

37:19.540 --> 37:20.540
它只有什么upgrade

37:20.540 --> 37:21.540
它有没有say hello

37:21.540 --> 37:22.540
没有

37:22.540 --> 37:23.540
它凭什么没有呢

37:23.540 --> 37:24.540
你看一下

37:24.540 --> 37:25.540
我们刚刚之前说的

37:25.540 --> 37:26.540
基层的关系

37:26.540 --> 37:27.540
它现在只能说

37:27.540 --> 37:29.540
vipvuser是objects的子内

37:29.540 --> 37:30.540
对吧

37:30.540 --> 37:32.540
objects是vipvuser的附内

37:32.540 --> 37:34.540
他们两个有没有关系

37:34.540 --> 37:35.540
是没啥关系

37:35.540 --> 37:36.540
对吧

37:36.540 --> 37:37.540
但是他们两个

37:37.540 --> 37:38.540
应不应该有关系

37:38.540 --> 37:39.540
它是应该有关系的

37:39.540 --> 37:40.540
因为vip用户

37:40.540 --> 37:41.540
一定是一个用户

37:41.540 --> 37:43.540
所以说vip用户

37:43.540 --> 37:44.540
它是它的子内

37:44.540 --> 37:46.540
就是我们在描述的时候

37:46.540 --> 37:47.540
我们怎么描述呢

37:47.540 --> 37:48.540
就是能用

37:48.540 --> 37:50.540
是不是的关系在描述的话

37:50.540 --> 37:52.540
那么前者就是后者的子内

37:52.540 --> 37:53.540
比方说

37:54.540 --> 37:55.540
猫是动物

37:55.540 --> 37:56.540
猫就是动物的子内

37:58.540 --> 37:59.540
狗是动物

37:59.540 --> 38:00.540
狗就是动物的子内

38:00.540 --> 38:01.540
哈斯奇是狗

38:01.540 --> 38:03.540
那么哈斯奇就是狗的子内

38:04.540 --> 38:05.540
反过来就不行了

38:05.540 --> 38:06.540
你看狗是不是哈斯奇

38:06.540 --> 38:07.540
那不一定

38:07.540 --> 38:08.540
对不对

38:08.540 --> 38:09.540
所以说我们能用

38:09.540 --> 38:10.540
是不是来描述的话

38:10.540 --> 38:12.540
前者就是后者的子内

38:12.540 --> 38:14.540
那么vip它是一个用户

38:14.540 --> 38:16.540
因此vip逻辑上

38:16.540 --> 38:18.540
就是优热的子内

38:18.540 --> 38:19.540
因此呢

38:19.540 --> 38:20.540
vip优热有的东西

38:20.540 --> 38:21.540
它必须要有

38:21.540 --> 38:22.540
它有的东西呢

38:22.540 --> 38:23.540
优热不一定有

38:23.540 --> 38:24.540
对吧

38:24.540 --> 38:25.540
应该形成这么一种关系

38:26.540 --> 38:27.540
所以说呢

38:27.540 --> 38:28.540
我们目前的关系呢

38:28.540 --> 38:29.540
是不合理的

38:29.540 --> 38:30.540
我们打开看一下

38:30.540 --> 38:31.540
看一下这个这里

38:32.540 --> 38:33.540
我们

38:34.540 --> 38:36.540
我们这里的vuser

38:36.540 --> 38:37.540
你看一下

38:37.540 --> 38:38.540
它里边这些属性倒是有

38:38.540 --> 38:40.540
这些属性运行的

38:40.540 --> 38:41.540
它这些是有的

38:41.540 --> 38:42.540
但是呢

38:42.540 --> 38:44.540
它里边什么upgrade的也有

38:44.540 --> 38:46.540
upgrade的也有

38:46.540 --> 38:48.540
然后但是它里边没啥呢

38:48.540 --> 38:50.540
没有这个say hello

38:50.540 --> 38:51.540
它没有这个东西

38:51.540 --> 38:53.540
有的这些基本的

38:53.540 --> 38:54.540
基本的成员它没有

38:54.540 --> 38:55.540
对吧

38:55.540 --> 38:57.540
我们现在就要解决这个问题

38:57.540 --> 38:58.540
我们这里说的继承

38:58.540 --> 38:59.540
就是要解决这个问题

38:59.540 --> 39:00.540
怎么解决呢

39:00.540 --> 39:01.540
我们注意中

39:01.540 --> 39:02.540
希望它

39:02.540 --> 39:04.540
希望它变成这个样子

39:04.540 --> 39:06.540
变成下面这个样子

39:07.540 --> 39:09.540
这个ppt我不发的

39:09.540 --> 39:10.540
因为这个东西

39:10.540 --> 39:12.540
它存在于讲解过程中

39:12.540 --> 39:13.540
你不听讲解

39:13.540 --> 39:14.540
观看这个ppt没意义

39:14.540 --> 39:15.540
观看这个ppt

39:15.540 --> 39:16.540
你脱离的讲解

39:16.540 --> 39:17.540
它是没有意义的

39:17.540 --> 39:18.540
所以说不发的

39:18.540 --> 39:20.540
是不是应该形成这种结构

39:20.540 --> 39:22.540
这种结构是不是合理的

39:22.540 --> 39:23.540
没问题吧

39:23.540 --> 39:25.540
最终应该形成这种结构

39:25.540 --> 39:26.540
就对了

39:26.540 --> 39:27.540
问题是

39:27.540 --> 39:29.540
怎么来形成这种结构呢

39:29.540 --> 39:31.540
现在我们就要解决这个问题

39:31.540 --> 39:32.540
一开始是这种结构

39:32.540 --> 39:33.540
我们要最终形成

39:33.540 --> 39:34.540
把它形成这种结构

39:35.540 --> 39:36.540
于是我们这里

39:36.540 --> 39:37.540
可以专门写一个函数

39:37.540 --> 39:38.540
来做这件事

39:38.540 --> 39:39.540
我们在pronging里边

39:39.540 --> 39:40.540
加一个解释

39:41.540 --> 39:42.540
我们专门来

39:42.540 --> 39:43.540
做这么一个解释

39:43.540 --> 39:44.540
以后遇到这种问题

39:44.540 --> 39:46.540
只需要去雕容相关的东西

39:46.540 --> 39:47.540
就行了

39:47.540 --> 39:49.540
这里我们写一个就是

39:52.540 --> 39:54.540
一些帮助的函数

39:54.540 --> 39:56.540
加一些帮助的函数

39:56.540 --> 39:57.540
这里边我们之前写过

39:57.540 --> 39:58.540
这么类似的代码

39:58.540 --> 39:59.540
对吧

39:59.540 --> 40:01.540
这里我们也可以这样子写

40:01.540 --> 40:02.540
windowmypronging

40:02.540 --> 40:03.540
windowmypronging

40:04.540 --> 40:05.540
就是这样子

40:05.540 --> 40:06.540
如果有这个属性的话

40:06.540 --> 40:07.540
没有这个属性的话

40:07.540 --> 40:08.540
给它加上一个

40:08.540 --> 40:09.540
把它变成一个对象

40:09.540 --> 40:11.540
之后就用什么

40:11.540 --> 40:12.540
mypronging

40:12.540 --> 40:13.540
给它加上什么

40:13.540 --> 40:15.540
加上一些东西就完事了

40:15.540 --> 40:17.540
加上一些东西就完事了

40:17.540 --> 40:18.540
加上比如说

40:18.540 --> 40:20.540
我们这里要做什么inherit

40:20.540 --> 40:21.540
inherit什么意思

40:21.540 --> 40:22.540
这个单词

40:22.540 --> 40:23.540
表示继承的意思

40:23.540 --> 40:24.540
给它写这么一个东西

40:24.540 --> 40:25.540
就行了

40:25.540 --> 40:27.540
这里我顺便说一下

40:27.540 --> 40:29.540
因为我之前写这个解释的时候

40:29.540 --> 40:31.540
因为它是跟

40:31.540 --> 40:32.540
环境密切相关的

40:32.540 --> 40:33.540
就是它跟浏览器

40:33.540 --> 40:34.540
肯定密切相关

40:34.540 --> 40:35.540
为啥

40:35.540 --> 40:36.540
因为它这里边在用什么

40:36.540 --> 40:37.540
div对吧

40:37.540 --> 40:38.540
创建div document

40:38.540 --> 40:39.540
在用这些东西

40:39.540 --> 40:40.540
它肯定是跟浏览器相关的

40:40.540 --> 40:41.540
因此我这里

40:41.540 --> 40:43.540
可以认为它的权具变量

40:43.540 --> 40:44.540
一定是温的

40:44.540 --> 40:45.540
你不是浏览器环境

40:45.540 --> 40:46.540
你用我这个干嘛

40:46.540 --> 40:48.540
我这个是弹层的

40:48.540 --> 40:50.540
弹那个弹确认框的

40:50.540 --> 40:52.540
那你肯定是浏览器环境

40:52.540 --> 40:53.540
对吧

40:53.540 --> 40:54.540
不是浏览器环境

40:54.540 --> 40:55.540
你不要用我这个

40:55.540 --> 40:56.540
但是这边不一样

40:56.540 --> 40:57.540
这边我们做的是

40:57.540 --> 40:58.540
写的是一些通用的

40:58.540 --> 40:59.540
就是一些方法

40:59.540 --> 41:00.540
通用的一些方法

41:00.540 --> 41:01.540
它跟浏览器环境

41:01.540 --> 41:02.540
是不是浏览器环境

41:02.540 --> 41:03.540
没有什么关系

41:03.540 --> 41:05.540
因此我们这里不能假设

41:05.540 --> 41:07.540
就是我尽量给大家说的

41:07.540 --> 41:08.540
细致一点

41:08.540 --> 41:09.540
尽量就是我们

41:09.540 --> 41:10.540
考虑的周全一点

41:10.540 --> 41:11.540
我们这里就不能假设

41:11.540 --> 41:12.540
它为浏览器环境

41:12.540 --> 41:13.540
你们以后

41:13.540 --> 41:14.540
肯定要学习其他环境

41:14.540 --> 41:16.540
比方说服务器环境

41:16.540 --> 41:17.540
比方说手机端环境

41:17.540 --> 41:18.540
对吧

41:18.540 --> 41:19.540
那我这里不能用浏览器环境

41:19.540 --> 41:20.540
不能把它当成浏览器环境

41:20.540 --> 41:21.540
那这里该怎么写呢

41:21.540 --> 41:23.540
也就是不能写温斗

41:23.540 --> 41:24.540
该咋写呢

41:24.540 --> 41:25.540
我们这样子写

41:25.540 --> 41:26.540
用z

41:27.540 --> 41:29.540
z是不是指向全局环境的

41:29.540 --> 41:30.540
对吧

41:30.540 --> 41:31.540
z是指向全局环境

41:31.540 --> 41:33.540
我们这里用z

41:33.540 --> 41:34.540
对吧

41:34.540 --> 41:35.540
管理是啥环境

41:35.540 --> 41:36.540
我反正我全局

41:36.540 --> 41:39.540
往全局对象里面加上这个东西

41:40.540 --> 41:41.540
写这么东西

41:41.540 --> 41:42.540
给它设置为一个函数

41:42.540 --> 41:43.540
这个函数

41:43.540 --> 41:44.540
能传两个参数进来

41:44.540 --> 41:45.540
就是上

41:45.540 --> 41:46.540
儿子

41:47.540 --> 41:48.540
一个是父亲

41:48.540 --> 41:49.540
发招

41:49.540 --> 41:50.540
我干嘛呢

41:50.540 --> 41:52.540
传的是两个构造函数进来

41:52.540 --> 41:54.540
我会帮你来完成

41:54.540 --> 41:55.540
这个圆形链的操作

41:55.540 --> 41:57.540
我把它最终变成这种格式

41:57.540 --> 41:59.540
把儿子的

41:59.540 --> 42:01.540
把儿子的就是这个

42:01.540 --> 42:02.540
圆形指向它

42:02.540 --> 42:04.540
我最终把它完成这样的一个操作

42:04.540 --> 42:05.540
我就要完成这件事

42:05.540 --> 42:06.540
这个意思吧

42:07.540 --> 42:08.540
我们写这么一个函数

42:08.540 --> 42:09.540
OK

42:09.540 --> 42:10.540
我们在这里

42:10.540 --> 42:11.540
就调用这个函数

42:11.540 --> 42:12.540
就调用一下

42:12.540 --> 42:13.540
那么这个函数

42:13.540 --> 42:14.540
最好在一开始就调用

42:14.540 --> 42:16.540
后面还加自己的东西

42:16.540 --> 42:18.540
最好是一开始写了之后再调用

42:18.540 --> 42:19.540
我们以后写的

42:19.540 --> 42:20.540
你就知道为什么了

42:20.540 --> 42:22.540
因为你要改这个圆形

42:22.540 --> 42:23.540
你这里刚

42:23.540 --> 42:24.540
如果你在后面调用的话

42:24.540 --> 42:25.540
比方说

42:26.540 --> 42:27.540
比方说我们这里先写

42:27.540 --> 42:28.540
先把引用进来

42:31.540 --> 42:32.540
mypronging

42:34.540 --> 42:35.540
这里买pronging

42:39.540 --> 42:40.540
里边inherit

42:42.540 --> 42:43.540
表示继承

42:43.540 --> 42:44.540
儿子是谁

42:44.540 --> 42:45.540
vip user

42:45.540 --> 42:46.540
父亲是谁

42:46.540 --> 42:47.540
user

42:48.540 --> 42:49.540
对吧

42:49.540 --> 42:50.540
把这个继承关系

42:50.540 --> 42:51.540
把这两个函数

42:51.540 --> 42:52.540
函数的继承关系处理好

42:52.540 --> 42:53.540
处理好之后

42:53.540 --> 42:54.540
我们创建vip user的时候

42:54.540 --> 42:55.540
它自动就变成了

42:55.540 --> 42:56.540
它的纸

42:56.540 --> 42:57.540
纸内的对象了

42:57.540 --> 42:58.540
好

42:58.540 --> 42:59.540
关键是这个函数在什么时候调用

42:59.540 --> 43:01.540
一定要在最开始调用

43:01.540 --> 43:02.540
为什么呢

43:02.540 --> 43:03.540
因为这个函数你现在没有写

43:03.540 --> 43:04.540
但是你可以想象得到

43:04.540 --> 43:06.540
它一定会改动它的圆形

43:06.540 --> 43:07.540
对吧

43:07.540 --> 43:08.540
它一定会改动

43:08.540 --> 43:10.540
它这里的圆形结构

43:10.540 --> 43:11.540
圆形

43:11.540 --> 43:12.540
也就是说

43:12.540 --> 43:13.540
如果你后面调用了

43:13.540 --> 43:15.540
它会导致一个问题

43:15.540 --> 43:16.540
它之前的这个圆形对象

43:16.540 --> 43:17.540
是不是

43:17.540 --> 43:18.540
可能会被覆改掉

43:19.540 --> 43:20.540
你刚才改

43:20.540 --> 43:21.540
刚刚改了圆形

43:21.540 --> 43:22.540
我又改了一次

43:22.540 --> 43:23.540
那是不是后边改的

43:23.540 --> 43:25.540
会把前面的可能覆改掉了

43:25.540 --> 43:26.540
因此这里要最好

43:26.540 --> 43:28.540
这个继承关系一开始要写好

43:28.540 --> 43:30.540
一开始就写好

43:30.540 --> 43:32.540
怎么样就意思吧

43:32.540 --> 43:33.540
比方说

43:33.540 --> 43:35.540
我们已经把传进去了

43:35.540 --> 43:36.540
我们现在的目标

43:36.540 --> 43:38.540
就是要改动这个结构

43:38.540 --> 43:39.540
好

43:39.540 --> 43:40.540
怎么改动呢

43:40.540 --> 43:41.540
这里有很多

43:41.540 --> 43:43.540
各种花式的改法

43:43.540 --> 43:44.540
怎么改动呢

43:44.540 --> 43:45.540
有一种最容易理解

43:45.540 --> 43:47.540
也是最简单的

43:47.540 --> 43:49.540
就是把儿子的proto type

43:49.540 --> 43:50.540
就不说改动吧

43:50.540 --> 43:52.540
直接设为发热的

43:52.540 --> 43:55.540
发热的proto type

43:55.540 --> 43:57.540
直接这样子设置

43:57.540 --> 43:58.540
这样子设置过后

43:58.540 --> 44:00.540
又变成了啥结构了

44:00.540 --> 44:04.540
就是VIP user

44:04.540 --> 44:06.540
它的proto type

44:06.540 --> 44:09.860
直接变成了它了

44:09.860 --> 44:11.860
变成了这样的结构了

44:11.860 --> 44:12.860
这样的结构

44:12.860 --> 44:13.860
是我们想要的吗

44:13.860 --> 44:16.860
是不是我们想要的

44:16.860 --> 44:18.860
不是我们想要的

44:18.860 --> 44:19.860
为什么不是我们想要的呢

44:19.860 --> 44:22.860
这样子容易造成圆形污染

44:22.860 --> 44:24.860
为什么会造成圆形污染呢

44:24.860 --> 44:26.860
因为一会我VIP user

44:26.860 --> 44:27.860
他现在指向了

44:27.860 --> 44:28.860
他跟user现在

44:28.860 --> 44:30.860
是不是指向了同一个的圆形了

44:30.860 --> 44:31.860
这样子一改

44:31.860 --> 44:32.860
是不是指向同一个圆形了

44:32.860 --> 44:34.860
那么指向同一个圆形之后

44:34.860 --> 44:36.860
一会我在VIP user里面

44:36.860 --> 44:37.860
加了一个upgrade

44:37.860 --> 44:38.860
它会导致一个问题

44:38.860 --> 44:41.860
它会导致这里多了一个upgrade

44:41.860 --> 44:43.860
它会导致这里多了一个upgrade

44:43.860 --> 44:45.860
能理解这个意思吧

44:45.860 --> 44:47.860
那么一会把user给污染掉了

44:47.860 --> 44:49.860
这不是我们想看到的

44:49.860 --> 44:50.860
所以说

44:50.860 --> 44:52.860
我们不希望是这么一种格式

44:52.860 --> 44:53.860
不希望这么一种格式

44:53.860 --> 44:55.860
这种方式用不了

44:55.860 --> 44:57.860
那么怎么办呢

44:57.860 --> 44:59.860
我们可以这样做

44:59.860 --> 45:00.860
看着

45:00.860 --> 45:02.860
我们用什么objects

45:02.860 --> 45:03.860
create

45:03.860 --> 45:04.860
学过了对吧

45:04.860 --> 45:05.860
fuzzer

45:05.860 --> 45:06.860
第二

45:06.860 --> 45:08.860
prototype

45:08.860 --> 45:10.860
啥意思

45:10.860 --> 45:11.860
啥意思

45:11.860 --> 45:13.860
你看着

45:13.860 --> 45:15.860
这里在干嘛

45:15.860 --> 45:16.860
是不是通过fuzzer

45:16.860 --> 45:19.860
就是复物类的

45:19.860 --> 45:21.860
就是复构造函数的圆形

45:21.860 --> 45:23.860
复构造函数的圆形是啥

45:23.860 --> 45:24.860
是不是它

45:24.860 --> 45:26.860
通过它来创建一个对象

45:26.860 --> 45:28.860
这个对象的隐私圆形指向它

45:28.860 --> 45:29.860
对不对

45:29.860 --> 45:30.860
指向你传递的参数

45:30.860 --> 45:31.860
你传递的参数就是这个嘛

45:31.860 --> 45:32.860
对不对

45:32.860 --> 45:33.860
那么通过

45:33.860 --> 45:36.860
它就是新建的对象的隐私圆形

45:36.860 --> 45:37.860
所以说我们这里

45:37.860 --> 45:40.860
这一步做了一件什么事呢

45:40.860 --> 45:42.860
这一步做了这么一件事

45:42.860 --> 45:44.860
就是我创建了一个对象

45:44.860 --> 45:49.740
创建了一个对象

45:49.740 --> 45:50.740
一个对象

45:50.740 --> 45:51.740
这个对象呢

45:51.740 --> 45:53.740
它的隐私圆形指向谁了

45:53.740 --> 45:55.740
它的隐私圆形是不是指向它了

45:55.740 --> 45:56.740
对吧

45:56.740 --> 45:58.740
指向它了

45:58.740 --> 45:59.740
对不对

45:59.740 --> 46:00.740
创建了这么一个对象

46:00.740 --> 46:02.740
它的隐私圆形指向它了

46:02.740 --> 46:03.740
没问题吧

46:03.740 --> 46:04.740
这是我们之前学过的objects

46:04.740 --> 46:05.740
create

46:05.740 --> 46:06.740
好

46:06.740 --> 46:07.740
然后干嘛呢

46:07.740 --> 46:09.740
把这个对象复制给什么

46:09.740 --> 46:11.740
额字的圆形

46:11.740 --> 46:13.740
于是这样子一来

46:13.740 --> 46:14.740
vipuzzer

46:14.740 --> 46:17.740
vipuzzer它是指内

46:17.740 --> 46:18.740
对吧

46:18.740 --> 46:20.740
它的圆形是不是不在指向以前的了

46:20.740 --> 46:21.740
对吧

46:21.740 --> 46:22.740
指向了它对不对

46:22.740 --> 46:23.740
没问题吧

46:23.740 --> 46:24.740
没问题吧

46:24.740 --> 46:26.740
是不是指向了它

46:26.740 --> 46:28.740
那么这个东西还有用吗

46:28.740 --> 46:29.740
这东西没用了对吧

46:29.740 --> 46:30.740
没用了

46:30.740 --> 46:32.740
它就变成了这么一种格式了

46:32.740 --> 46:33.740
看没

46:33.740 --> 46:35.740
它就变成了这么一种格式了

46:35.740 --> 46:36.740
它是不是就完成了

46:36.740 --> 46:37.740
完成这个结构了

46:37.740 --> 46:38.740
对不对

46:38.740 --> 46:39.740
就完成了呗

46:39.740 --> 46:40.740
就这么简单

46:40.740 --> 46:41.740
没有多复杂

46:41.740 --> 46:42.740
就这么简单

46:42.740 --> 46:43.740
好

46:43.740 --> 46:45.740
就做这么一个简单的操作过后

46:45.740 --> 46:46.740
我们再来看

46:46.740 --> 46:48.740
现在这个vipuzzer

46:48.740 --> 46:49.740
vipuzzer的啥

46:49.740 --> 46:50.740
它的什么A级

46:50.740 --> 46:51.740
这些东西是不是都有

46:51.740 --> 46:53.740
这些东西肯定是有的对吧

46:53.740 --> 46:54.740
这些东西没什么好说的

46:54.740 --> 46:56.740
主要是看say hello看有没有

46:56.740 --> 46:57.740
有没有

46:57.740 --> 46:58.740
是不是有了

46:58.740 --> 46:59.740
对吧有了

46:59.740 --> 47:00.740
然后它自己的东西有没有upgrade

47:00.740 --> 47:01.740
有没有

47:01.740 --> 47:02.740
是不是也有

47:02.740 --> 47:03.740
对不对

47:03.740 --> 47:04.740
也有

47:04.740 --> 47:05.740
看没有

47:05.740 --> 47:06.740
这就完成了继承了

47:06.740 --> 47:07.740
就这么简单

47:07.740 --> 47:08.740
当然还有一些细节

47:08.740 --> 47:09.740
我们还没处理

47:09.740 --> 47:10.740
但是呢

47:10.740 --> 47:12.740
基本的逻辑是不是就完了

47:12.740 --> 47:14.740
基本的逻辑就已经完成了

47:14.740 --> 47:15.740
就已经完成了

47:15.740 --> 47:17.740
这是这种方式

47:17.740 --> 47:19.740
就改变它的圆形

47:19.740 --> 47:20.740
改变它的圆形

47:20.740 --> 47:24.740
然后它负累的圆形就完事了

47:24.740 --> 47:25.740
好

47:25.740 --> 47:26.740
但是那里面有些细节

47:26.740 --> 47:27.740
有些细节

47:27.740 --> 47:28.740
首先呢

47:28.740 --> 47:29.740
这个对象里边呢

47:29.740 --> 47:30.740
它没有

47:30.740 --> 47:31.740
它没有啥

47:31.740 --> 47:32.740
它没有一个constructor

47:32.740 --> 47:33.740
它没有这个东西

47:33.740 --> 47:34.740
你看一下

47:34.740 --> 47:35.740
我们的就是

47:35.740 --> 47:37.740
这个vuzzer里边

47:37.740 --> 47:39.740
它的影视圆形里边

47:39.740 --> 47:40.740
影视圆形指向谁

47:40.740 --> 47:41.740
是不是指向这个

47:41.740 --> 47:42.740
这个新的对象

47:42.740 --> 47:43.740
这个对象里边呢

47:43.740 --> 47:44.740
它没有啥

47:44.740 --> 47:45.740
它缺少了一个constructor

47:45.740 --> 47:46.740
哎

47:46.740 --> 47:47.740
对

47:47.740 --> 47:48.740
有这个constructor

47:48.740 --> 47:49.740
现在有

47:49.740 --> 47:50.740
但是这个constructor

47:50.740 --> 47:51.740
它是指向谁的呢

47:51.740 --> 47:52.740
它默认情况

47:52.740 --> 47:53.740
它是指向这的

47:53.740 --> 47:55.740
因为你通过vuzzer的圆形

47:55.740 --> 47:56.740
来创建的

47:56.740 --> 47:58.740
你是让它指向的vuzzer圆形

47:58.740 --> 48:00.740
因此它的constructor指向这

48:00.740 --> 48:01.740
对吧

48:01.740 --> 48:02.740
没问题吧

48:02.740 --> 48:03.740
因为它是

48:03.740 --> 48:04.740
用的是vuzzer的圆形

48:04.740 --> 48:05.740
因此它的constructor

48:05.740 --> 48:06.740
它是指向这的

48:06.740 --> 48:07.740
这不太合理

48:07.740 --> 48:09.740
因为constructor的话

48:09.740 --> 48:10.740
一般来说

48:10.740 --> 48:11.740
我们constructor的话

48:11.740 --> 48:12.740
都要指回来

48:12.740 --> 48:13.740
对吧都要指回来

48:13.740 --> 48:14.740
指向自己

48:14.740 --> 48:15.740
对不对

48:15.740 --> 48:16.740
所以说呢

48:16.740 --> 48:17.740
我们这里要调整一下

48:17.740 --> 48:18.740
它的constructor

48:18.740 --> 48:19.740
调整一下

48:19.740 --> 48:20.740
这个很简单

48:20.740 --> 48:21.740
调整一下

48:21.740 --> 48:22.740
它的constructor

48:22.740 --> 48:23.740
等于啥呢

48:23.740 --> 48:24.740
等于啥

48:24.740 --> 48:25.740
constructor

48:25.740 --> 48:27.740
等于

48:27.740 --> 48:28.740
哦不对不对

48:28.740 --> 48:29.740
不对不对

48:29.740 --> 48:30.740
刚才不是这样说的

48:30.740 --> 48:31.740
不是这样说的

48:31.740 --> 48:32.740
我们来看一下

48:32.740 --> 48:33.740
constructor

48:33.740 --> 48:34.740
vuzer

48:34.740 --> 48:35.740
vuzer的

48:35.740 --> 48:36.740
打印出来

48:36.740 --> 48:37.740
vuzer的

48:37.740 --> 48:38.740
它的protype里边

48:38.740 --> 48:39.740
它是没有constructor的

48:39.740 --> 48:40.740
我们刚才用的constructor

48:40.740 --> 48:42.740
是它在圆形链上找的

48:42.740 --> 48:44.740
它是在圆形链上找的

48:44.740 --> 48:45.740
这里没有对吧

48:45.740 --> 48:46.740
它的圆形对象里边没有

48:46.740 --> 48:48.740
这个对象里边没有

48:48.740 --> 48:49.740
没有的话

48:49.740 --> 48:50.740
那么它会从圆形链上找

48:50.740 --> 48:52.740
它会找到它的constructor

48:52.740 --> 48:53.740
它的constructor

48:53.740 --> 48:54.740
是不是指向它的

48:54.740 --> 48:55.740
对吧

48:55.740 --> 48:56.740
是这样子的

48:56.740 --> 48:57.740
就它的constructor

48:57.740 --> 48:58.740
是指向它的

48:58.740 --> 48:59.740
这里

48:59.740 --> 49:00.740
画一个吧

49:00.740 --> 49:01.740
画一个

49:01.740 --> 49:02.740
对吧

49:02.740 --> 49:03.740
那么我们现在

49:03.740 --> 49:04.740
要在它里边

49:04.740 --> 49:05.740
加一个constructor

49:05.740 --> 49:06.740
对不对

49:06.740 --> 49:07.740
那直接加就行了

49:07.740 --> 49:08.740
对不对

49:08.740 --> 49:09.740
它已经看到了

49:09.740 --> 49:10.740
这里边有啥东西呢

49:10.740 --> 49:12.740
这里边已经有了一个upgrade

49:12.740 --> 49:13.740
对吧

49:13.740 --> 49:16.740
那我们之后upgrade

49:16.740 --> 49:18.740
以后我们在VIP的圆形里边加

49:18.740 --> 49:19.740
是不是不会影响到vuzer

49:19.740 --> 49:21.740
它有自己独立的对象

49:21.740 --> 49:22.740
有自己独立的房间

49:22.740 --> 49:23.740
虽然说我是儿子

49:23.740 --> 49:24.740
但是我也不可能

49:24.740 --> 49:26.740
跟老爸同住一个房间

49:26.740 --> 49:27.740
我有自己的生活空间

49:27.740 --> 49:29.740
我往自己对象里边加东西

49:29.740 --> 49:31.740
因此我们也可以往对象里边加

49:31.740 --> 49:33.740
加一个什么constructor

49:33.740 --> 49:34.740
constructor

49:34.740 --> 49:35.740
等于啥

49:36.740 --> 49:37.740
是不是应该

49:37.740 --> 49:39.740
是不是应该等于这个

49:39.740 --> 49:40.740
等于这个东西

49:40.740 --> 49:41.740
对吧

49:41.740 --> 49:42.740
应该等于上

49:42.740 --> 49:43.740
上传令的时候

49:43.740 --> 49:45.740
保存看一下

49:45.740 --> 49:46.740
那么现在这个

49:46.740 --> 49:48.740
这个东西就没问题了

49:48.740 --> 49:49.740
你看

49:51.740 --> 49:52.740
别逗我

49:52.740 --> 49:53.740
别逗我

49:53.740 --> 49:54.740
刷新一下

49:55.740 --> 49:58.740
vuzer.protoconstructor

49:58.740 --> 50:02.180
我这里是不是写错了

50:02.180 --> 50:03.180
没写错

50:03.180 --> 50:04.180
没写错

50:04.180 --> 50:05.180
哦哦哦

50:05.180 --> 50:06.180
这里写错了

50:06.180 --> 50:07.180
这里应该写什么

50:07.180 --> 50:08.180
上点

50:09.180 --> 50:10.180
应该是这个

50:10.180 --> 50:11.180
应该是这个

50:11.180 --> 50:12.180
就是我们要通过啥

50:12.180 --> 50:13.180
通过这个

50:13.180 --> 50:15.180
纸内找到它的什么

50:15.180 --> 50:17.180
找到它的圆形对象

50:17.180 --> 50:18.180
找到它这个

50:18.180 --> 50:20.180
然后给它复制constructor

50:20.180 --> 50:21.180
刚才我是直接把constructor

50:21.180 --> 50:22.180
写到这里边去了

50:22.180 --> 50:24.180
那肯定出问题了

50:24.180 --> 50:25.180
保存

50:25.180 --> 50:26.180
现在看一下

50:26.180 --> 50:27.180
是不是没问题了

50:27.180 --> 50:28.180
那么现在constructor

50:28.180 --> 50:29.180
指向也正确了

50:29.180 --> 50:30.180
对吧

50:30.180 --> 50:31.180
指向也正确了

50:31.180 --> 50:33.180
就模拟这么一个效果出来

50:33.180 --> 50:34.180
那就跟那个

50:34.180 --> 50:35.180
平时文写的

50:35.180 --> 50:36.180
是不是一样的

50:36.180 --> 50:37.180
constructor只回来

50:38.180 --> 50:40.180
然后我们继续

50:40.180 --> 50:41.180
然后有的时候

50:41.180 --> 50:44.180
我们还可能会给它加一个属性

50:44.180 --> 50:46.180
有的时候我们为了操作方便

50:46.180 --> 50:48.180
我们还会给它加上这个东西

50:48.180 --> 50:50.180
看着一个非常有意思的东西

50:50.180 --> 50:51.180
有个属性叫super

50:51.180 --> 50:53.180
但是我这里super什么意思

50:53.180 --> 50:54.180
就表示父亲的意思

50:54.180 --> 50:56.180
就是超级的意思

50:56.180 --> 50:57.180
超级就是父内的意思

50:57.180 --> 50:59.180
就是表示父内的意思

50:59.180 --> 51:01.180
但是我们这里的super的关键字

51:01.180 --> 51:02.180
很遗憾

51:02.180 --> 51:04.180
已经变成了保留字了

51:04.180 --> 51:05.180
是一个保留字

51:05.180 --> 51:06.180
我们不能用

51:06.180 --> 51:07.180
那么我们这里换一个名字

51:08.180 --> 51:09.180
uber

51:09.180 --> 51:11.180
类似于把这个p

51:11.180 --> 51:12.180
把这个p保写

51:12.180 --> 51:13.180
把s去掉

51:13.180 --> 51:14.180
变成uber

51:14.180 --> 51:15.180
uber也有超级的意思

51:15.180 --> 51:17.180
也有超级的意思

51:18.180 --> 51:19.180
变成这个属性

51:19.180 --> 51:21.180
再加上就是在元雄上面

51:21.180 --> 51:22.180
这个元雄上面

51:22.180 --> 51:24.180
给它加一个属性

51:24.180 --> 51:26.180
这个属性我首先说一下

51:26.180 --> 51:28.180
很多写这种写法

51:28.180 --> 51:29.180
这种写法是一种

51:29.180 --> 51:32.180
叫做圣北模式的写法

51:32.180 --> 51:34.180
圣北模式

51:34.180 --> 51:35.180
它为什么叫圣北模式

51:35.180 --> 51:36.180
我真不知道

51:36.180 --> 51:37.180
我之前查过

51:37.180 --> 51:38.180
查了半天都不知道

51:38.180 --> 51:39.180
它为什么叫圣北模式

51:39.180 --> 51:40.180
我真不知道

51:40.180 --> 51:42.180
但它名字确实叫圣北模式

51:42.180 --> 51:44.180
就是来实现继承这种模式

51:44.180 --> 51:46.180
它只有短短几行代吗

51:46.180 --> 51:47.180
并不多

51:47.180 --> 51:49.180
那么它圣北模式里边

51:49.180 --> 51:51.180
它的标准写法是

51:51.180 --> 51:52.180
Fuzzer

51:52.180 --> 51:53.180
它是这样子写的

51:53.180 --> 51:55.180
Fuzzer就是Prototype

51:55.180 --> 51:57.180
就是它为了方便来获取

51:57.180 --> 51:59.180
方便纸内来获取

51:59.180 --> 52:01.180
它的附内的元型

52:01.180 --> 52:02.180
它加了这么一个属性

52:02.180 --> 52:04.180
也就是它加了一个属性uber

52:04.180 --> 52:06.180
我们看一下吧

52:06.180 --> 52:08.180
加了这么一个属性uber

52:10.180 --> 52:11.180
这个uber它指向谁呢

52:11.180 --> 52:12.180
指向这个附内

52:12.180 --> 52:14.180
它这个uber它指向这个附内

52:14.180 --> 52:16.180
它加了这么一个属性

52:16.180 --> 52:17.180
那么以后所有的对象

52:17.180 --> 52:18.180
是不是全都有了

52:18.180 --> 52:19.180
对不对

52:19.180 --> 52:21.180
全都有这个属性了

52:21.180 --> 52:23.180
但是呢

52:23.180 --> 52:24.180
我觉得这个东西

52:24.180 --> 52:25.180
这是我个人觉得

52:25.180 --> 52:26.180
我个人觉得

52:26.180 --> 52:27.180
我先跟你说明

52:27.180 --> 52:29.180
它的标准写法是这样的写法

52:29.180 --> 52:30.180
但是我个人觉得

52:30.180 --> 52:31.180
在我们目前

52:31.180 --> 52:33.180
借识这个ES5

52:33.180 --> 52:35.180
这个版本之后呢

52:35.180 --> 52:37.180
我们已经可以非常方便的

52:37.180 --> 52:38.180
来获取它的

52:38.180 --> 52:40.180
就是隐释元型了

52:40.180 --> 52:41.180
我们之前学习过对吧

52:41.180 --> 52:42.180
怎么来获取

52:42.180 --> 52:43.180
Objects

52:43.180 --> 52:44.180
Objects

52:44.180 --> 52:45.180
Gate

52:45.180 --> 52:47.180
Gate Prototype

52:47.180 --> 52:48.180
对不对

52:48.180 --> 52:49.180
我们可以非常方便的

52:49.180 --> 52:50.180
比方说

52:50.180 --> 52:51.180
指类的什么

52:51.180 --> 52:52.180
Prototype的

52:52.180 --> 52:54.180
就是隐释元型

52:54.180 --> 52:55.180
我们可以非常方便的

52:55.180 --> 52:56.180
来获取的

52:56.180 --> 52:57.180
虽然我们会多写些代嘛

52:57.180 --> 52:58.180
但是呢

52:58.180 --> 52:59.180
就是

52:59.180 --> 53:00.180
当然这样子

53:00.180 --> 53:01.180
写是肯定是一种

53:01.180 --> 53:02.180
兼容性写法

53:02.180 --> 53:03.180
就是一些

53:03.180 --> 53:04.180
9%的流量器呢

53:04.180 --> 53:06.180
它很难获取到它的

53:06.180 --> 53:07.180
这个就是负累的东西

53:07.180 --> 53:09.180
负累的元型很难获取

53:09.180 --> 53:10.180
那么现在呢

53:10.180 --> 53:11.180
有了这个属性了之后呢

53:11.180 --> 53:12.180
我们就可以非常方便的

53:12.180 --> 53:13.180
获取了

53:13.180 --> 53:14.180
你看一下吧

53:14.180 --> 53:15.180
我们这样子写的之后呢

53:15.180 --> 53:17.180
我们就可以通过什么

53:17.180 --> 53:19.180
通过这个Vuser

53:19.180 --> 53:21.180
得到它的Wubber对吧

53:26.180 --> 53:28.180
这什么鬼啊这是

53:28.180 --> 53:29.180
Vuser

53:29.180 --> 53:31.180
等到它的Wubber

53:31.180 --> 53:32.180
你看

53:32.180 --> 53:34.180
能得到负累的元型

53:34.180 --> 53:36.180
能得到它的元型

53:36.180 --> 53:38.180
就可以非常方便的获取了

53:38.180 --> 53:40.180
但是我个人觉得

53:40.180 --> 53:42.180
这东西没什么暖字用

53:42.180 --> 53:43.180
所以说我一般呢

53:43.180 --> 53:45.180
如果我写生美模式的话

53:45.180 --> 53:47.180
我一般会这样子写

53:47.180 --> 53:49.180
让这个Wubber指向谁呢

53:49.180 --> 53:51.180
我会让他去指向这个

53:51.180 --> 53:53.180
指向这个User

53:53.180 --> 53:55.180
我会让这个Wubber去指向User

53:55.180 --> 53:57.180
我给他画一个箭头嘛

53:58.180 --> 53:59.180
这样做

53:59.180 --> 54:01.180
告诉大家有什么样的用处

54:01.180 --> 54:03.180
为什么我要去这样做

54:03.180 --> 54:05.180
我会让他去指向这个User

54:05.180 --> 54:06.180
指向了负累

54:06.180 --> 54:08.180
这样做了有什么用了这个Wubber

54:08.180 --> 54:10.180
指向了他的负累过后

54:10.180 --> 54:11.180
好

54:11.180 --> 54:13.180
就直接指向构造函数啊

54:13.180 --> 54:14.180
那这样做了过后

54:14.180 --> 54:15.180
我们可以这样子玩了

54:15.180 --> 54:16.180
看着

54:16.180 --> 54:17.180
我们可以这样子玩了

54:17.180 --> 54:19.180
只要你使用生背模式

54:19.180 --> 54:20.180
使用我们这种模式

54:20.180 --> 54:21.180
那么我这里就不可以

54:21.180 --> 54:23.180
这句话可以这样子写

54:23.180 --> 54:27.390
ZSWubber

54:28.390 --> 54:30.390
Forsenly

54:30.390 --> 54:31.390
Narsenly

54:31.390 --> 54:32.390
对吧

54:32.390 --> 54:33.390
是不是可以这样子写

54:33.390 --> 54:35.390
因为这个是不是构造函数

54:35.390 --> 54:36.390
对吧它的构造函数

54:36.390 --> 54:37.390
我们通过ZS去调用构造函数

54:37.390 --> 54:38.390
为什么现在有了

54:38.390 --> 54:39.390
为什么现在ZS有了

54:39.390 --> 54:41.390
你看一下这个图版

54:41.390 --> 54:42.390
ZS现在表示它对吧

54:42.390 --> 54:43.390
新创代的对象

54:43.390 --> 54:44.390
ZS里面是不是有Wubber

54:44.390 --> 54:46.390
我们通过ZS去调用这个东西

54:46.390 --> 54:48.390
那么我们直接可以绑进ZS了

54:48.390 --> 54:50.390
就不用这种写法了

54:50.390 --> 54:51.390
看了没

54:51.390 --> 54:52.390
这样子

54:52.390 --> 54:53.390
一来我操作起来

54:53.390 --> 54:55.390
那就会非常的方便

54:56.390 --> 54:57.390
会非常的方便

54:57.390 --> 54:58.390
看了没

54:59.390 --> 55:00.390
没问题吧

55:00.390 --> 55:01.390
我一般会这样写

55:01.390 --> 55:02.390
但是我给你说明

55:02.390 --> 55:03.390
标准的写法

55:03.390 --> 55:04.390
它不是这样子写的

55:04.390 --> 55:05.390
标准的写法是指向的

55:05.390 --> 55:06.390
是圆形

55:06.390 --> 55:08.390
但是我没有这样子写

55:08.390 --> 55:09.390
如果当然

55:09.390 --> 55:10.390
要跟公司里面沟通

55:10.390 --> 55:11.390
你要沟通

55:11.390 --> 55:12.390
因为我在以前公司里面

55:12.390 --> 55:13.390
17数从前

55:13.390 --> 55:16.390
我就要让他们这样子写

55:16.390 --> 55:17.390
有权利吧

55:17.390 --> 55:18.390
那怎么办

55:18.390 --> 55:19.390
但是

55:19.390 --> 55:20.390
如果你在公司里面

55:20.390 --> 55:21.390
你是一个小弟

55:21.390 --> 55:22.390
你要沟通的

55:22.390 --> 55:23.390
不然的话

55:23.390 --> 55:24.390
别人都是用这个

55:24.390 --> 55:26.390
都认为它是指向的是圆形

55:26.390 --> 55:27.390
那就完蛋了

55:27.390 --> 55:28.390
所以你要沟通的

55:29.390 --> 55:30.390
我个人觉得这样子写

55:30.390 --> 55:31.390
更加舒服一点

55:31.390 --> 55:33.390
当然到了ES-6的时候

55:33.390 --> 55:34.390
有更加好的写法了

55:34.390 --> 55:35.390
但是ES-5

55:35.390 --> 55:36.390
就是在兼容性的写法了

55:36.390 --> 55:37.390
可能这样子好一点

55:38.390 --> 55:39.390
我这里再说一个点

55:39.390 --> 55:41.390
就是关于这一块

55:41.390 --> 55:43.390
这一块是ES-5的东西

55:44.390 --> 55:46.390
ES-5才有这个objects

55:46.390 --> 55:47.390
以前没有的

55:47.390 --> 55:48.390
以前没有的

55:48.390 --> 55:50.390
那么以前咋写的

55:50.390 --> 55:51.390
以前咋写的

55:51.390 --> 55:52.390
以前得用这种写法

55:53.390 --> 55:55.770
建立一个函数

55:55.770 --> 55:57.770
这个函数没啥用

55:57.770 --> 55:58.770
完之用没有

55:58.770 --> 55:59.770
啥用都没有

55:59.770 --> 56:00.770
这个函数来干嘛呢

56:00.770 --> 56:02.770
这个函数用来创建对象的

56:02.770 --> 56:04.770
它主要是用来创建对象的

56:04.770 --> 56:05.770
temp

56:05.770 --> 56:06.770
一个函数

56:07.770 --> 56:08.770
那么它的用处

56:08.770 --> 56:09.770
主要是用来什么呢

56:09.770 --> 56:10.770
用来创建对象

56:12.770 --> 56:13.770
六一个temp

56:13.770 --> 56:15.770
它是用来创建对象的

56:15.770 --> 56:16.770
比方说

56:16.770 --> 56:17.770
以前的

56:17.770 --> 56:18.770
我先说一下

56:18.770 --> 56:20.770
以前的写法是怎么写的

56:21.770 --> 56:22.770
把它复制过来

56:22.770 --> 56:23.770
这是原式的情况

56:23.770 --> 56:25.770
那么现在我创建了一个函数

56:25.770 --> 56:26.770
temp

56:26.770 --> 56:27.770
这个函数

56:28.770 --> 56:29.770
我们这里

56:29.770 --> 56:31.770
创建了一个函数

56:31.770 --> 56:32.770
这个函数的名字叫做

56:33.770 --> 56:34.770
temp

56:35.770 --> 56:36.770
创建这么一个函数

56:36.770 --> 56:37.770
我们把它画下来了

56:41.550 --> 56:42.550
创建这么一个函数

56:42.550 --> 56:43.550
这个函数

56:43.550 --> 56:44.550
它是不是有原型

56:44.550 --> 56:46.550
函数肯定有原型

56:46.550 --> 56:48.550
但是它的原型跟我们没啥关系

56:49.550 --> 56:51.550
它的原型跟我们没啥关系

56:51.550 --> 56:53.550
我们不用管它的原型

56:53.550 --> 56:55.550
现在我们创建了这个函数的对象

56:56.550 --> 56:57.550
我们来看一下

56:58.550 --> 56:59.550
我们还是把它画一下

56:59.550 --> 57:00.550
画一下这个函数的原型

57:01.550 --> 57:03.550
temp.prototype

57:04.550 --> 57:05.550
以前是用这种巧妙的办法

57:05.550 --> 57:06.550
以前没有这个create

57:07.550 --> 57:08.550
以前是这么玩的

57:10.550 --> 57:11.550
因为你们以后

57:11.550 --> 57:13.550
可能会看到这种以前的代码

57:13.550 --> 57:15.550
所以说必须要跟你们说一下

57:15.550 --> 57:16.550
它有这个原型对吧

57:16.550 --> 57:17.550
然后

57:17.550 --> 57:19.550
它这个原型指向肯定是这样子指向的

57:21.550 --> 57:22.550
创建这么一个函数

57:22.550 --> 57:23.550
它指向肯定是这样子指向的

57:25.550 --> 57:26.550
没问题吧

57:26.550 --> 57:27.550
这是以前的做法

57:27.550 --> 57:29.550
然后我们创建了一个NewTemp

57:29.550 --> 57:31.550
创建一个它的对象

57:31.550 --> 57:36.340
创建一个对象

57:36.340 --> 57:38.340
New一个Temp

57:38.340 --> 57:39.340
Temp对象

57:40.340 --> 57:41.340
创建它的对象

57:41.340 --> 57:42.340
那么对象

57:42.340 --> 57:44.340
它的影视原型指向谁

57:44.340 --> 57:45.340
指向谁

57:45.340 --> 57:47.340
它的影视原型指向谁

57:47.340 --> 57:49.340
是不是指向的是

57:51.340 --> 57:52.340
复制一下

57:52.340 --> 57:54.340
创建一个NewTemp

57:54.340 --> 57:56.340
它的影视原型就指向了它

57:56.340 --> 57:57.340
没问题吧

57:59.340 --> 58:00.340
是吧

58:00.340 --> 58:01.340
它指向它

58:01.340 --> 58:02.340
对不对

58:02.340 --> 58:03.340
没问题吧

58:03.340 --> 58:04.340
能看懂吗

58:05.340 --> 58:07.340
通过它来创建的对象

58:07.340 --> 58:08.340
那么它的影视原型

58:08.340 --> 58:09.340
是不是指向它

58:09.340 --> 58:10.340
对不对

58:10.340 --> 58:11.340
好

58:11.340 --> 58:12.340
然后接下来

58:12.340 --> 58:14.340
我们这么来玩

58:14.340 --> 58:16.340
这个桶划得有点乱

58:16.340 --> 58:19.340
我先把他换一种划法

58:19.340 --> 58:21.340
把换一种划法

58:21.340 --> 58:22.340
这样子

58:22.340 --> 58:24.340
划得有点乱

58:24.340 --> 58:26.340
我这里把他移下来一点

58:26.340 --> 58:27.340
移下来一点

58:27.340 --> 58:29.340
然后这个玩意儿过来

58:29.340 --> 58:30.340
这个玩意儿过来

58:30.340 --> 58:32.340
然后这个玩意儿过来

58:32.340 --> 58:33.340
它过来

58:34.340 --> 58:36.340
然后这个东西指向它

58:36.340 --> 58:37.340
指向它

58:37.340 --> 58:39.340
然后这个地方指向它

58:39.340 --> 58:40.340
对吧

58:40.340 --> 58:41.340
应该是这样子

58:41.340 --> 58:42.340
这样子的话

58:42.340 --> 58:44.340
稍微好一点点

58:44.340 --> 58:45.340
稍微好一点点

58:49.630 --> 58:50.630
没问题吧

58:50.630 --> 58:51.630
现在是这样子对吧

58:51.630 --> 58:52.630
好看一下

58:52.630 --> 58:53.630
好看一下

58:53.630 --> 58:54.630
现在变成这样子了

58:54.630 --> 58:56.630
它们是个空函数

58:56.630 --> 58:57.630
它的原型里面啥都没有

58:57.630 --> 58:58.630
啥都没有

58:58.630 --> 58:59.630
没问题吧

59:01.630 --> 59:02.630
没问题吧

59:02.630 --> 59:03.630
好

59:03.630 --> 59:04.630
那么接下来

59:04.630 --> 59:06.630
我们来玩意儿一些花样出来

59:06.630 --> 59:08.630
来玩意儿一些花样出来

59:08.630 --> 59:10.630
怎么来玩这个东西呢

59:10.630 --> 59:13.630
我这里先这么来处理

59:13.630 --> 59:15.630
我们这里上面在

59:15.630 --> 59:16.630
往上面移动一点吧

59:16.630 --> 59:18.630
不然真的有点乱了

59:19.630 --> 59:21.630
这个移上来一点

59:21.630 --> 59:22.630
上来一点

59:23.630 --> 59:25.630
把这里有点乱了

59:25.630 --> 59:26.630
这样子好多了

59:26.630 --> 59:27.630
这样子好多了

59:27.630 --> 59:28.630
移上来

59:29.630 --> 59:34.250
这个点

59:34.250 --> 59:35.250
真的是个精细的活

59:36.250 --> 59:37.250
好

59:37.250 --> 59:38.250
目前是这个样子对吧

59:38.250 --> 59:39.250
好

59:39.250 --> 59:41.250
那么目前我们这样子来点

59:41.250 --> 59:43.250
我让这个Prototype

59:43.250 --> 59:45.250
就这个东西指向它

59:45.250 --> 59:46.250
对吧

59:46.250 --> 59:47.250
我把User的Prototype

59:47.250 --> 59:49.250
复制给Temple的Prototype

59:49.250 --> 59:50.250
这个可不可以

59:50.250 --> 59:51.250
这个多简单吗

59:51.250 --> 59:52.250
对吧

59:52.250 --> 59:53.250
这个多简单吗

59:53.250 --> 59:54.250
这个很简单对不对

59:54.250 --> 59:55.250
好

59:55.250 --> 59:56.250
这个我们来直接来复制

59:56.250 --> 59:57.250
以前只能这么玩

59:57.250 --> 59:58.250
没办法

59:58.250 --> 59:59.250
以前没办法

59:59.250 --> 01:00:02.250
首先让Temple的Prototype

01:00:02.250 --> 01:00:04.250
等于Fuzzer

01:00:04.250 --> 01:00:05.250
点Prototype

01:00:06.250 --> 01:00:07.250
对吧

01:00:07.250 --> 01:00:08.250
复制过来

01:00:08.250 --> 01:00:09.250
复制过来

01:00:09.250 --> 01:00:10.250
那么这样

01:00:11.250 --> 01:00:12.250
这样子

01:00:12.250 --> 01:00:13.250
还不是这样子

01:00:13.250 --> 01:00:14.250
是让Temple的Prototype

01:00:14.250 --> 01:00:15.250
直接变到这了

01:00:15.250 --> 01:00:16.250
直接变到这了

01:00:16.250 --> 01:00:17.250
看没

01:00:17.250 --> 01:00:18.250
Temple的Prototype

01:00:18.250 --> 01:00:19.250
直接指向这了

01:00:19.250 --> 01:00:20.250
那么这个东西

01:00:20.250 --> 01:00:21.250
是不是没了

01:00:21.250 --> 01:00:22.250
就消失了

01:00:22.250 --> 01:00:24.250
然后由于Temple的Prototype

01:00:24.250 --> 01:00:25.250
指向这了

01:00:25.250 --> 01:00:26.250
所以Temple对象

01:00:26.250 --> 01:00:27.250
是不是也跟着

01:00:27.250 --> 01:00:28.250
跟着指向这了

01:00:28.250 --> 01:00:29.250
对吧

01:00:29.250 --> 01:00:30.250
它的隐私原先也跟着指向这了

01:00:30.250 --> 01:00:31.250
看到没

01:00:31.250 --> 01:00:33.250
是不是得到类似的结构出来了

01:00:33.250 --> 01:00:34.250
类似的结构已经出来了

01:00:34.250 --> 01:00:35.250
对吧

01:00:35.250 --> 01:00:37.250
之前我们是用Object Creator

01:00:37.250 --> 01:00:38.250
来实现这种方式

01:00:38.250 --> 01:00:39.250
现在是不是直接可以

01:00:39.250 --> 01:00:40.250
用这种方式来实现

01:00:40.250 --> 01:00:41.250
也可以

01:00:41.250 --> 01:00:42.250
对不对

01:00:42.250 --> 01:00:43.250
没办法

01:00:43.250 --> 01:00:44.250
以前它没有Object Creator

01:00:44.250 --> 01:00:46.250
我把User的Prototype

01:00:46.250 --> 01:00:48.250
就Fuzzer的Prototype

01:00:48.250 --> 01:00:50.250
给它复制为Temple的Prototype

01:00:50.250 --> 01:00:51.250
两个是不是一样了

01:00:51.250 --> 01:00:52.250
好

01:00:52.250 --> 01:00:53.250
我们先做这么一件事

01:00:53.250 --> 01:00:54.250
然后我们通过Temple的

01:00:54.250 --> 01:00:55.250
创建了一个对象

01:00:55.250 --> 01:00:56.250
对不对

01:00:56.250 --> 01:00:57.250
相当于是不是

01:00:57.250 --> 01:00:58.250
就是User的对象

01:00:58.250 --> 01:00:59.250
对不对

01:00:59.250 --> 01:01:00.250
相当于就是User的对象

01:01:00.250 --> 01:01:02.250
相当于就是User的对象

01:01:02.250 --> 01:01:03.250
那为什么我干嘛

01:01:03.250 --> 01:01:04.250
不直接创建User对象了

01:01:04.250 --> 01:01:05.250
因为我不知道

01:01:05.250 --> 01:01:06.250
它有多少参数

01:01:06.250 --> 01:01:07.250
它不知道

01:01:07.250 --> 01:01:08.250
它勾兆的函数

01:01:08.250 --> 01:01:09.250
需要参数

01:01:09.250 --> 01:01:10.250
所以我必须要通过一个

01:01:10.250 --> 01:01:11.250
临时的函数

01:01:11.250 --> 01:01:12.250
才能搞定这件事

01:01:12.250 --> 01:01:13.250
好

01:01:13.250 --> 01:01:14.250
我的目的是

01:01:14.250 --> 01:01:15.250
创建这么一个对象

01:01:15.250 --> 01:01:16.250
然后接下来的事情

01:01:16.250 --> 01:01:17.250
是不是知道了

01:01:17.250 --> 01:01:18.250
把这个对象

01:01:18.250 --> 01:01:19.250
复制给谁

01:01:19.250 --> 01:01:21.250
VIPUser

01:01:21.250 --> 01:01:23.250
把这个对象

01:01:23.250 --> 01:01:24.250
是吧

01:01:24.250 --> 01:01:25.250
把这个对象

01:01:25.250 --> 01:01:27.250
就是这个纸内的Prototype

01:01:27.250 --> 01:01:28.250
复制给它

01:01:28.250 --> 01:01:29.250
那这样一来

01:01:29.250 --> 01:01:30.250
VIPUser它的Prototype

01:01:30.250 --> 01:01:31.250
是不是指向它了

01:01:31.250 --> 01:01:32.250
对吧

01:01:32.250 --> 01:01:33.250
那这个东西是不是没了

01:01:33.250 --> 01:01:34.250
对吧

01:01:34.250 --> 01:01:35.250
没了

01:01:35.250 --> 01:01:36.250
而且是不是又形成

01:01:36.250 --> 01:01:37.250
这种结构了

01:01:37.250 --> 01:01:38.250
对不对

01:01:38.250 --> 01:01:39.250
那是不是一样的

01:01:39.250 --> 01:01:40.250
一样的

01:01:40.250 --> 01:01:41.250
那最后呢

01:01:41.250 --> 01:01:42.250
这些东西是不是一样的

01:01:42.250 --> 01:01:43.250
后边的他们

01:01:43.250 --> 01:01:44.250
给这个

01:01:44.250 --> 01:01:45.250
原型里边去加

01:01:45.250 --> 01:01:47.250
加什么upgrade的

01:01:47.250 --> 01:01:48.250
对吧

01:01:48.250 --> 01:01:49.250
是一样的

01:01:49.250 --> 01:01:50.250
最后就是一样的了

01:01:50.250 --> 01:01:51.250
实现一模一样的效果

01:01:51.250 --> 01:01:52.250
只是多了一个

01:01:52.250 --> 01:01:53.250
辅助函数而已

01:01:53.250 --> 01:01:54.250
当然这个辅助函数

01:01:54.250 --> 01:01:55.250
最后没啥用了

01:01:55.250 --> 01:01:56.250
最后没啥用

01:01:56.250 --> 01:01:57.250
明白这个意思吧

01:01:57.250 --> 01:01:58.250
最后没啥用了

01:01:58.250 --> 01:01:59.250
好

01:01:59.250 --> 01:02:00.250
然后我们看一下

01:02:00.250 --> 01:02:01.250
最终的结果是一样的

01:02:01.250 --> 01:02:02.250
VIPUser

01:02:02.250 --> 01:02:03.250
对不对

01:02:03.250 --> 01:02:04.250
是一样的

01:02:04.250 --> 01:02:05.250
完全一样的

01:02:05.250 --> 01:02:07.250
看没

01:02:07.250 --> 01:02:08.250
好

01:02:08.250 --> 01:02:09.250
这种协防呢

01:02:09.250 --> 01:02:11.250
在以前还可以进行优化

01:02:11.250 --> 01:02:12.250
为什么可以优化呢

01:02:12.250 --> 01:02:13.250
你看这个

01:02:13.250 --> 01:02:14.250
每一次

01:02:14.250 --> 01:02:15.250
来继承的时候

01:02:15.250 --> 01:02:16.250
都要创建一个临时函数

01:02:16.250 --> 01:02:18.250
其实这个函数没啥用

01:02:18.250 --> 01:02:19.250
这个函数没啥用

01:02:19.250 --> 01:02:21.250
它就是用来辅助的

01:02:21.250 --> 01:02:22.250
来做一个转接的

01:02:22.250 --> 01:02:23.250
对吧

01:02:23.250 --> 01:02:25.250
它本身是没啥用的

01:02:25.250 --> 01:02:26.250
所以说

01:02:26.250 --> 01:02:27.250
后面出现这种协防

01:02:27.250 --> 01:02:28.250
我觉得挺屌的

01:02:28.250 --> 01:02:29.250
这种协防

01:02:29.250 --> 01:02:30.250
这里

01:02:30.250 --> 01:02:31.250
它是这样子写的

01:02:31.250 --> 01:02:32.250
来看一下吧

01:02:32.250 --> 01:02:34.250
它是写了一个立即执行函数

01:02:34.250 --> 01:02:36.250
立即执行函数

01:02:36.250 --> 01:02:38.250
这个立即执行函数里边

01:02:38.250 --> 01:02:40.250
立即执行函数

01:02:40.250 --> 01:02:42.250
然后这个立即执行函数里边

01:02:42.250 --> 01:02:43.250
有这么一个

01:02:43.250 --> 01:02:45.250
就是函数

01:02:45.250 --> 01:02:46.250
变量

01:02:46.250 --> 01:02:47.250
有这么一个函数

01:02:47.250 --> 01:02:48.250
变量

01:02:48.250 --> 01:02:49.250
然后再返回

01:02:49.250 --> 01:02:51.250
再返回这么一个东西

01:02:51.250 --> 01:02:52.250
以前是用

01:02:52.250 --> 01:02:53.250
有这种协防

01:02:53.250 --> 01:02:54.250
我记得是哪个公司

01:02:54.250 --> 01:02:55.250
雅虎的公司

01:02:55.250 --> 01:02:56.250
流出来的一个代码

01:02:56.250 --> 01:02:57.250
反正

01:02:57.250 --> 01:02:59.250
网上基本上

01:02:59.250 --> 01:03:01.250
一直是觉得这个代码

01:03:01.250 --> 01:03:03.250
觉得非常非常牛逼

01:03:03.250 --> 01:03:04.250
为什么它这个代码流呢

01:03:04.250 --> 01:03:06.250
因为它写了个立即执行函数之后

01:03:06.250 --> 01:03:08.250
这个函数是马上执行

01:03:08.250 --> 01:03:09.250
马上执行马上消毁

01:03:09.250 --> 01:03:11.250
马上执行马上消毁

01:03:11.250 --> 01:03:12.250
马上执行的时候

01:03:12.250 --> 01:03:14.250
是不是就创建了一个变量

01:03:14.250 --> 01:03:16.250
一个就是一个函数对象

01:03:16.250 --> 01:03:17.250
temp

01:03:17.250 --> 01:03:18.250
就创建了它

01:03:18.250 --> 01:03:19.250
其他啥都没创建

01:03:19.250 --> 01:03:20.250
其他啥都没有

01:03:20.250 --> 01:03:21.250
就创建了一个它

01:03:21.250 --> 01:03:23.250
然后我们返回的是啥呢

01:03:23.250 --> 01:03:24.250
返回另外一个函数

01:03:24.250 --> 01:03:25.250
这个函数里边

01:03:25.250 --> 01:03:27.250
是不是可以用外面的东西

01:03:27.250 --> 01:03:28.250
是不是可以用外面的temp

01:03:28.250 --> 01:03:29.250
对吧

01:03:29.250 --> 01:03:30.250
是不是可以用它

01:03:30.250 --> 01:03:31.250
也就是这个代码

01:03:31.250 --> 01:03:32.250
是不是永远只运行一次

01:03:32.250 --> 01:03:34.250
永远不会再运行的

01:03:34.250 --> 01:03:35.250
也就是说

01:03:35.250 --> 01:03:36.250
我们自始至终

01:03:36.250 --> 01:03:37.250
就创建了一个函数temp

01:03:37.250 --> 01:03:39.250
甭管你这个函数

01:03:39.250 --> 01:03:40.250
调用多少次

01:03:40.250 --> 01:03:41.250
因为这个函数

01:03:41.250 --> 01:03:42.250
实际上得到的是啥

01:03:42.250 --> 01:03:43.250
得到的是返回的这个函数

01:03:43.250 --> 01:03:45.250
得到的是返回的这个函数

01:03:45.250 --> 01:03:46.250
而不是整个函数

01:03:46.250 --> 01:03:48.250
得到的是返回的这个函数

01:03:48.250 --> 01:03:49.250
因此

01:03:49.250 --> 01:03:51.250
这个函数无论调用多少次

01:03:51.250 --> 01:03:53.250
它不会再运行这句话了

01:03:53.250 --> 01:03:55.250
不会再新创建这个函数对象了

01:03:55.250 --> 01:03:56.250
它都是反复用之前

01:03:56.250 --> 01:03:57.250
创建的函数对象

01:03:57.250 --> 01:03:58.250
对吧

01:03:58.250 --> 01:03:59.250
我们之前叫做B包

01:03:59.250 --> 01:04:00.250
对不对

01:04:00.250 --> 01:04:01.250
函数里边可以使用外边的东西

01:04:01.250 --> 01:04:03.250
叫做B包

01:04:03.250 --> 01:04:04.250
这是一种非常非常优质的

01:04:04.250 --> 01:04:05.250
创建办法

01:04:05.250 --> 01:04:06.250
好

01:04:06.250 --> 01:04:07.250
那么这个东西

01:04:07.250 --> 01:04:09.250
调用多次会不会出问题呢

01:04:09.250 --> 01:04:10.250
不会出问题

01:04:10.250 --> 01:04:11.250
我告诉你

01:04:11.250 --> 01:04:12.250
不会出问题

01:04:12.250 --> 01:04:13.250
比方说第1次调用

01:04:13.250 --> 01:04:14.250
第1次调用

01:04:14.250 --> 01:04:15.250
形成这么一种结构

01:04:15.250 --> 01:04:16.250
第2次调用的时候

01:04:16.250 --> 01:04:17.250
第2次调用

01:04:17.250 --> 01:04:18.250
围忧已经固定了

01:04:18.250 --> 01:04:19.250
这样子的

01:04:19.250 --> 01:04:20.250
好

01:04:20.250 --> 01:04:21.250
第2次调用的时候

01:04:21.250 --> 01:04:22.250
现在又把这个temp

01:04:22.250 --> 01:04:23.250
又重新指向了

01:04:23.250 --> 01:04:24.250
你看

01:04:24.250 --> 01:04:25.250
第2次调用的时候

01:04:25.250 --> 01:04:26.250
是不是要重新指向

01:04:26.250 --> 01:04:27.250
pro-type要重新改

01:04:27.250 --> 01:04:28.250
对吧

01:04:28.250 --> 01:04:29.250
改成函数的值

01:04:29.250 --> 01:04:30.250
所以第2次调用的时候

01:04:30.250 --> 01:04:31.250
它又去指向别的了

01:04:31.250 --> 01:04:32.250
但是它指向别的

01:04:32.250 --> 01:04:34.250
跟之前的有啥关系呢

01:04:34.250 --> 01:04:36.250
之前的指向已经完全正确了

01:04:36.250 --> 01:04:37.250
对吧

01:04:37.250 --> 01:04:38.250
之前的指向已经完全正确了

01:04:38.250 --> 01:04:39.250
跟后边的指向已经没啥关系了

01:04:39.250 --> 01:04:41.250
它又去指向另外一个东西

01:04:41.250 --> 01:04:43.250
比方说另外一个东西

01:04:43.250 --> 01:04:44.250
又去指向它

01:04:44.250 --> 01:04:45.250
然后它又创建对象

01:04:45.250 --> 01:04:46.250
对吧

01:04:46.250 --> 01:04:47.250
又创建对象

01:04:47.250 --> 01:04:48.250
又去指向新的东西了

01:04:48.250 --> 01:04:50.250
又去指向新的东西

01:04:50.250 --> 01:04:51.250
但是跟之前的已经没关系了

01:04:51.250 --> 01:04:52.250
对吧

01:04:52.250 --> 01:04:54.250
之前的关系已经固定下来了

01:04:54.250 --> 01:04:55.250
你看这个意思吧

01:04:55.250 --> 01:04:57.250
然后之后的指内

01:04:57.250 --> 01:04:58.250
之后的指内

01:04:58.250 --> 01:05:00.250
又去指向这个东西

01:05:00.250 --> 01:05:01.250
所以不会影响的

01:05:01.250 --> 01:05:02.250
不会影响的

01:05:02.250 --> 01:05:04.250
你看这个意思吧

01:05:04.250 --> 01:05:05.250
就是这种邪法

01:05:05.250 --> 01:05:06.250
这种邪法

01:05:06.250 --> 01:05:07.250
OK

01:05:07.250 --> 01:05:08.250
这就是关于基层这一块

01:05:08.250 --> 01:05:09.250
我们该如何来

01:05:09.250 --> 01:05:10.250
书写代码来解决这个问题

01:05:10.250 --> 01:05:12.250
其实你到了ES6之后

01:05:12.250 --> 01:05:13.250
ES6里边

01:05:13.250 --> 01:05:14.250
有更好的

01:05:14.250 --> 01:05:15.250
更加優雅

01:05:15.250 --> 01:05:17.250
更加爽的那种

01:05:17.250 --> 01:05:18.250
继承书写方式

01:05:18.250 --> 01:05:20.250
但是目前的情况下

01:05:20.250 --> 01:05:22.250
这种邪法的代会

01:05:22.250 --> 01:05:23.250
因为面试的时候

01:05:23.250 --> 01:05:25.250
很有可能会问到你

01:05:25.250 --> 01:05:26.250
很有可能会问到你

01:05:26.250 --> 01:05:27.250
关于基层

01:05:27.250 --> 01:05:28.250
关于顺便模式

01:05:28.250 --> 01:05:29.250
它的逻辑是什么

01:05:29.250 --> 01:05:30.250
它是为

01:05:30.250 --> 01:05:31.250
它是怎么来实现的

01:05:31.250 --> 01:05:32.250
它的过程是什么

01:05:32.250 --> 01:05:33.250
甚至让你把代码写出来

01:05:33.250 --> 01:05:35.250
说你一定得会

01:05:35.250 --> 01:05:36.250
而且你们以后

01:05:36.250 --> 01:05:37.250
到公司里边

01:05:37.250 --> 01:05:38.250
还有可能会看到

01:05:38.250 --> 01:05:39.250
特别是一些

01:05:39.250 --> 01:05:40.250
之前的项目

01:05:40.250 --> 01:05:41.250
你不能说到了公司里边

01:05:41.250 --> 01:05:42.250
一定是新项目

01:05:42.250 --> 01:05:43.250
你到了公司

01:05:43.250 --> 01:05:44.250
就等着你来了

01:05:44.250 --> 01:05:45.250
之前公司一直没动工

01:05:45.250 --> 01:05:46.250
就等着你来了

01:05:46.250 --> 01:05:47.250
两个过后

01:05:47.250 --> 01:05:48.250
我们开发一个新项目

01:05:48.250 --> 01:05:49.250
不会的

01:05:49.250 --> 01:05:50.250
一般到了公司过后

01:05:50.250 --> 01:05:52.250
首先会让你去熟悉

01:05:52.250 --> 01:05:53.250
以前的项目

01:05:53.250 --> 01:05:54.250
那么你会看到

01:05:54.250 --> 01:05:55.250
很多这种旧的邪法

01:05:55.250 --> 01:05:57.250
说你一定得会

01:05:57.250 --> 01:05:58.250
那么今天的作业

01:05:58.250 --> 01:05:59.250
就写个顺便模式

01:05:59.250 --> 01:06:00.250
就把这个 helpers

01:06:00.250 --> 01:06:01.250
这里边加上一个继承

01:06:01.250 --> 01:06:02.250
把它写好

01:06:03.250 --> 01:06:04.250
就是这里

01:06:04.250 --> 01:06:05.250
我告诉过你

01:06:05.250 --> 01:06:07.250
这个地方

01:06:07.250 --> 01:06:09.250
它的标准邪法是这个

01:06:09.250 --> 01:06:10.250
Prototype

01:06:10.250 --> 01:06:11.250
算了

01:06:11.250 --> 01:06:12.250
我就写标准邪法

01:06:12.250 --> 01:06:13.250
我就写标准邪法

01:06:14.250 --> 01:06:16.250
我这里也不装逼了

01:06:16.250 --> 01:06:18.250
就写标准邪法

01:06:19.250 --> 01:06:20.250
行了

01:06:20.250 --> 01:06:21.250
这就是顺便模式

01:06:22.250 --> 01:06:24.250
好 这里我再多说几句吧

01:06:24.250 --> 01:06:26.250
就是我们在浏览器

01:06:26.250 --> 01:06:27.250
什么多目

01:06:27.250 --> 01:06:29.250
这里遇到了很多地方

01:06:29.250 --> 01:06:30.250
都有继承

01:06:30.250 --> 01:06:31.250
到时都有继承

01:06:31.250 --> 01:06:33.250
比方说我们可以看一下这个

01:06:33.250 --> 01:06:34.250
我们之前说过

01:06:36.250 --> 01:06:37.250
多目里边

01:06:37.250 --> 01:06:39.250
所有的东西都是节点

01:06:39.250 --> 01:06:40.250
都是一个 load对象

01:06:40.250 --> 01:06:41.250
一个 load

01:06:42.250 --> 01:06:43.250
load 是个啥

01:06:43.250 --> 01:06:44.250
load 就是个构造函数

01:06:44.250 --> 01:06:46.250
你看一下 type of load

01:06:46.250 --> 01:06:47.250
它是个构造函数

01:06:47.250 --> 01:06:48.250
看没有

01:06:48.250 --> 01:06:50.250
好 我们还学过什么

01:06:50.250 --> 01:06:51.250
就是有元素节点对吧

01:06:51.250 --> 01:06:52.250
anyment

01:06:54.250 --> 01:06:55.250
anyment

01:06:55.250 --> 01:06:56.250
你看一下

01:06:56.250 --> 01:06:57.250
它也是个函数

01:06:57.250 --> 01:06:58.250
对吧

01:06:58.250 --> 01:06:59.250
anyment 它也是个函数

01:07:00.250 --> 01:07:02.250
还有什么注释节点对吧

01:07:02.250 --> 01:07:03.250
comment

01:07:03.250 --> 01:07:04.250
注释节点是不是也是个函数

01:07:05.250 --> 01:07:07.250
我们看一下它的继承关系

01:07:07.250 --> 01:07:09.250
来看一下它的继承关系

01:07:09.250 --> 01:07:10.250
来看一下

01:07:10.250 --> 01:07:12.250
一个元素它是不是

01:07:12.250 --> 01:07:13.250
load

01:07:13.250 --> 01:07:14.250
它是不是load

01:07:14.250 --> 01:07:15.250
我们来看一下

01:07:15.250 --> 01:07:16.250
随便得到一个元素

01:07:16.250 --> 01:07:17.250
我们这个页面上有啥呢

01:07:17.250 --> 01:07:18.250
有body吗

01:07:18.250 --> 01:07:19.250
document

01:07:19.250 --> 01:07:20.250
body

01:07:20.250 --> 01:07:21.250
是个元素对吧

01:07:21.250 --> 01:07:22.250
我们来打黑

01:07:22.250 --> 01:07:23.250
这样打一步行

01:07:23.250 --> 01:07:24.250
console

01:07:25.250 --> 01:07:26.250
怎么回事

01:07:26.250 --> 01:07:27.250
console

01:07:27.250 --> 01:07:28.250
dir

01:07:28.250 --> 01:07:29.250
document

01:07:29.250 --> 01:07:30.250
body

01:07:30.250 --> 01:07:31.250
你看一下

01:07:32.250 --> 01:07:34.250
body里边我们就找它的隐私元型

01:07:34.250 --> 01:07:36.250
看它的隐私元型指向谁

01:07:36.250 --> 01:07:37.250
指向

01:07:37.250 --> 01:07:38.250
atmybody element

01:07:38.250 --> 01:07:40.250
它是有这个构造函数创建的

01:07:40.250 --> 01:07:41.250
看没

01:07:41.250 --> 01:07:42.250
一往下找

01:07:42.250 --> 01:07:43.250
又看它的隐私元型

01:07:43.250 --> 01:07:45.250
隐私元型它会形成一条链

01:07:45.250 --> 01:07:47.250
它会形成一条链

01:07:48.250 --> 01:07:50.250
atmy element对吧

01:07:50.250 --> 01:07:51.250
它的负类

01:07:51.250 --> 01:07:52.250
相当于是构造函数的负类

01:07:52.250 --> 01:07:54.250
就是atmy element

01:07:54.250 --> 01:07:55.250
就相当于是这里

01:07:55.250 --> 01:07:57.250
一条链形成的

01:07:57.250 --> 01:07:59.250
body的隐私元型

01:07:59.250 --> 01:08:01.250
它的隐私元型是atmy element

01:08:01.250 --> 01:08:02.250
对吧

01:08:04.250 --> 01:08:06.250
然后就看它展开

01:08:06.250 --> 01:08:08.250
它形成了一个很长的一层继承结构

01:08:08.250 --> 01:08:10.250
这就是为什么很多属性是通用的

01:08:10.250 --> 01:08:12.250
有些属性它又是特别实用的

01:08:12.250 --> 01:08:13.250
你看

01:08:13.250 --> 01:08:14.250
负类 element

01:08:14.250 --> 01:08:15.250
又展开

01:08:15.250 --> 01:08:16.250
又看

01:08:16.250 --> 01:08:17.250
又看

01:08:17.250 --> 01:08:18.250
负类 load

01:08:18.250 --> 01:08:19.250
对吧

01:08:19.250 --> 01:08:21.250
所有的东西都是节点

01:08:21.250 --> 01:08:23.250
因此节点里面的东西是不是都可以用

01:08:23.250 --> 01:08:24.250
对吧

01:08:24.250 --> 01:08:25.250
都可以用

01:08:25.250 --> 01:08:26.250
节点里面的东西都可以用

01:08:26.250 --> 01:08:27.250
看没有 load

01:08:27.250 --> 01:08:28.250
我们再看 load 的隐私元型

01:08:28.250 --> 01:08:30.250
叫做 event target

01:08:30.250 --> 01:08:31.250
事件对象

01:08:31.250 --> 01:08:32.250
事件对象的隐私元型

01:08:32.250 --> 01:08:34.250
隐私元型就是Object

01:08:34.250 --> 01:08:35.250
到Object

01:08:35.250 --> 01:08:37.250
隐私元型就变成load了

01:08:37.250 --> 01:08:39.250
它形成了很长的一条继承关系

01:08:39.250 --> 01:08:41.250
包括我们的事件

01:08:41.250 --> 01:08:43.250
事件对象里面的Event

01:08:43.250 --> 01:08:45.250
Event它也会形成一条继承关系

01:08:45.250 --> 01:08:47.250
比方说咱们来创建一个

01:08:47.250 --> 01:08:49.250
6个MouseEvent

01:08:49.250 --> 01:08:51.250
创建一个鼠标

01:08:51.250 --> 01:08:52.250
Click

01:08:52.250 --> 01:08:53.250
创建一个鼠标事件

01:08:53.250 --> 01:08:55.250
我们看一下这个E

01:08:55.250 --> 01:08:56.250
你看

01:08:56.250 --> 01:08:57.250
MouseEvent

01:08:57.250 --> 01:08:59.250
它的隐私元型

01:08:59.250 --> 01:09:00.250
MouseEvent

01:09:00.250 --> 01:09:01.250
再看它的隐私元型

01:09:01.250 --> 01:09:02.250
UIEvent

01:09:02.250 --> 01:09:04.250
就是用户界面的事件

01:09:04.250 --> 01:09:05.250
隐私元型

01:09:05.250 --> 01:09:06.250
Event 再看

01:09:06.250 --> 01:09:07.250
它是不是形成了继承关系

01:09:07.250 --> 01:09:08.250
然后最后是Object

01:09:08.250 --> 01:09:09.250
它形成了一条链

01:09:09.250 --> 01:09:10.250
这就是为什么

01:09:10.250 --> 01:09:12.250
我们在动物对象操作的时候

01:09:12.250 --> 01:09:13.250
有些属性

01:09:13.250 --> 01:09:14.250
你会发现到处都可以用

01:09:14.250 --> 01:09:15.250
因为它有继承

01:09:15.250 --> 01:09:16.250
它没有继承的话

01:09:16.250 --> 01:09:17.250
那么你像它这个鞋

01:09:17.250 --> 01:09:18.250
在代码的多老火

01:09:18.250 --> 01:09:20.250
有多少的重复代码

01:09:20.250 --> 01:09:21.250
对吧

01:09:21.250 --> 01:09:22.250
它每个对象不一样

01:09:22.250 --> 01:09:23.250
但是它有共同的东西

01:09:23.250 --> 01:09:24.250
它只能靠继承

01:09:24.250 --> 01:09:26.250
它形成了一条继承关系

01:09:26.250 --> 01:09:27.250
好吧

01:09:27.250 --> 01:09:29.250
这里多说一点

01:09:29.250 --> 01:09:30.250
好了

01:09:30.250 --> 01:09:31.250
那这就是我们的

01:09:31.250 --> 01:09:32.250
原型和原性量

01:09:32.250 --> 01:09:33.250
这一块的知识

01:09:33.250 --> 01:09:34.250
都没了

01:09:34.250 --> 01:09:35.250
原型量和原型链的话

01:09:35.250 --> 01:09:36.250
就这么两节合

01:09:36.250 --> 01:09:37.250
就可以讲完了

01:09:37.250 --> 01:09:38.250
好

01:09:38.250 --> 01:09:39.250
那后边的话

01:09:39.250 --> 01:09:40.250
就是别的知识了

01:09:40.250 --> 01:09:41.250
下来你把这个

01:09:41.250 --> 01:09:43.250
顺便模式一定要去写一遍

01:09:43.250 --> 01:09:44.250
好吧

