WEBVTT

00:00.000 --> 00:03.000
寒树管道

00:03.000 --> 00:13.950
咱们来看下一个

00:13.950 --> 00:16.950
就是关于寒树管道

00:16.950 --> 00:19.950
寒树管道啥意思呢

00:19.950 --> 00:22.950
它是将多个寒树

00:22.950 --> 00:23.950
应该就是这样说吧

00:23.950 --> 00:26.950
严格来说是将多个单参

00:26.950 --> 00:29.950
单参寒树组合起来

00:29.950 --> 00:33.950
形成一个新的寒树

00:33.950 --> 00:35.950
这多个寒树呢

00:35.950 --> 00:37.950
它每一个寒树的输出

00:37.950 --> 00:40.950
变成另后一个寒树的输入

00:40.950 --> 00:43.950
这些寒树

00:43.950 --> 00:45.950
每个寒树的

00:45.950 --> 00:46.950
应该这样说

00:46.950 --> 00:47.950
这些寒树中

00:47.950 --> 00:50.950
前一个寒树的输出

00:50.950 --> 00:55.950
是后一个寒树的输入

00:55.950 --> 00:57.950
这也是寒树式变成里边

00:57.950 --> 00:59.950
一种常见的做法

00:59.950 --> 01:00.950
寒树管道

01:00.950 --> 01:01.950
这里边有个图例

01:01.950 --> 01:03.950
给大家看一下吧

01:03.950 --> 01:05.950
这个圈圈

01:05.950 --> 01:06.950
相当于是啥呢

01:06.950 --> 01:08.950
相当于是参树

01:08.950 --> 01:11.950
把这个圈圈传给第一个寒树

01:11.950 --> 01:13.950
第一个寒树会得到一个反回直

01:13.950 --> 01:15.950
一个反回直就是个正方形

01:15.950 --> 01:17.950
一个圆角举行

01:17.950 --> 01:19.950
然后再把这个圆角举行

01:19.950 --> 01:21.950
作为参树传到第二个寒树

01:21.950 --> 01:23.950
它也有一个反回直

01:23.950 --> 01:24.950
经过第二个寒树的处理

01:24.950 --> 01:25.950
它又变成了这个样子

01:25.950 --> 01:27.950
然后又把它作为参树

01:27.950 --> 01:29.950
传到第三个寒树

01:29.950 --> 01:31.950
第三个寒树得到这么个东西

01:31.950 --> 01:33.950
于是我与其反复的

01:33.950 --> 01:34.950
去调用这些寒树

01:34.950 --> 01:36.950
我不如把这些寒树组合起来

01:36.950 --> 01:38.950
形成一个寒树管道

01:38.950 --> 01:40.950
就形成一个新的寒树

01:40.950 --> 01:41.950
这个白色的虚现框

01:41.950 --> 01:43.950
相当于是一个新的寒树

01:43.950 --> 01:46.950
我以后只需要去用新的寒树

01:46.950 --> 01:47.950
把这东西输入进来

01:47.950 --> 01:48.950
那么这个东西输出

01:48.950 --> 01:50.950
是不是就完事了

01:50.950 --> 01:52.950
那么这里来我们来举个例子

01:52.950 --> 01:54.950
假设

01:54.950 --> 01:56.950
我们的系统里边

01:56.950 --> 01:57.950
已经有这么一些寒树了

01:57.950 --> 01:58.950
就已经有这么一些寒树了

01:58.950 --> 02:00.950
这些寒树早就写好了

02:00.950 --> 02:01.950
比方说

02:01.950 --> 02:03.950
第一个寒树是

02:03.950 --> 02:05.950
first nether

02:05.950 --> 02:07.950
first nether up

02:07.950 --> 02:11.330
给我一个制服串

02:11.330 --> 02:13.330
我会怎么样呢

02:13.330 --> 02:15.330
将该制服串

02:15.330 --> 02:17.330
将制服串中

02:17.330 --> 02:19.330
每一个单词

02:19.330 --> 02:21.330
手字母大写

02:21.330 --> 02:23.330
将制服串中

02:23.330 --> 02:25.330
每一个单词手字母大写

02:25.330 --> 02:27.330
那么这个寒树咋写了

02:27.330 --> 02:29.330
这个寒树咋写

02:29.330 --> 02:31.330
寒树是不是可以用这么的表达式

02:31.330 --> 02:33.330
怎么办

02:33.330 --> 02:35.330
replace

02:35.330 --> 02:37.330
替换

02:37.330 --> 02:38.330
这里写个证则表达式

02:38.330 --> 02:40.330
我们找单词

02:40.330 --> 02:42.330
找单词

02:42.330 --> 02:44.330
找到

02:44.330 --> 02:46.330
一开始是单词边界

02:46.330 --> 02:48.330
单词边界用B

02:48.330 --> 02:50.330
要是单词边界

02:50.330 --> 02:51.330
全局查找

02:51.330 --> 02:52.330
查到单词

02:52.330 --> 02:53.330
那么中间的这一部分

02:53.330 --> 02:54.330
是不是单词

02:54.330 --> 02:56.330
单词

02:56.330 --> 02:57.330
中间这一部分

02:57.330 --> 02:59.330
是任意制服

02:59.330 --> 03:01.330
比方说

03:01.330 --> 03:03.330
应该说任意非空制服

03:03.330 --> 03:05.330
任意非空制服

03:05.330 --> 03:07.330
一个或多个

03:07.330 --> 03:08.330
对吧

03:08.330 --> 03:09.330
或者说

03:09.330 --> 03:11.330
查斜杠W表示

03:11.330 --> 03:13.330
单词制服

03:13.330 --> 03:15.330
单词制服一个或多个

03:15.330 --> 03:16.330
或者说这样子

03:16.330 --> 03:18.330
我们之前都写过很多次了

03:18.330 --> 03:20.330
把他扩起来变成一个分组

03:20.330 --> 03:22.330
第一个是单词制服

03:22.330 --> 03:24.330
第一个是单词制服

03:24.330 --> 03:26.330
后边还跟了一些单词制服

03:26.330 --> 03:28.330
因为单词肯定有第一个字母

03:28.330 --> 03:30.330
后边肯定还跟了一些单词制服

03:30.330 --> 03:31.330
因为后边用信号

03:31.330 --> 03:32.330
对吧

03:32.330 --> 03:33.330
我们写个这么的表达是

03:33.330 --> 03:35.330
前后匹配单词边界

03:35.330 --> 03:37.330
然后中间这一部分

03:37.330 --> 03:39.330
至少有一个会一个以上

03:39.330 --> 03:41.330
你看这样子写是不是一个一个以上

03:41.330 --> 03:42.330
只不过我们前面做了一个分组

03:42.330 --> 03:43.330
对不对

03:43.330 --> 03:44.330
前面做了一个分组

03:44.330 --> 03:45.330
然后来替换

03:45.330 --> 03:47.330
后边有一个函数来替换

03:47.330 --> 03:49.330
函数我们这里写上

03:49.330 --> 03:51.330
多了表示整个匹配的

03:51.330 --> 03:52.330
多了一表示的是

03:52.330 --> 03:54.330
第一个分组的东西

03:54.330 --> 03:56.330
第一个分组的东西

03:56.330 --> 03:58.330
或者说我们把第二个也进行分组

03:58.330 --> 04:00.330
那么就多了二

04:00.330 --> 04:01.330
看一下吧

04:01.330 --> 04:02.330
多了二

04:02.330 --> 04:04.330
我们这里输出多了一

04:04.330 --> 04:05.330
这是以前的东西

04:05.330 --> 04:06.330
我们顺便复习一下

04:06.330 --> 04:08.330
多了二

04:08.330 --> 04:10.330
我们这里运行一下这个函数

04:10.330 --> 04:12.330
比方说咱们

04:12.330 --> 04:14.330
我们

04:14.330 --> 04:16.330
我们给他一个这么一个

04:16.330 --> 04:18.330
制服串

04:18.330 --> 04:19.330
比方说咱们

04:19.330 --> 04:21.330
这里制服串写到前面吧

04:21.330 --> 04:22.330
写到前面

04:22.330 --> 04:23.330
ST2

04:23.330 --> 04:25.330
制服串是这样子的

04:26.330 --> 04:28.330
My

04:29.330 --> 04:31.330
First

04:31.330 --> 04:33.330
Turname

04:33.330 --> 04:35.770
这样子

04:35.770 --> 04:37.770
我们把制服串传进去

04:37.770 --> 04:38.770
传进去

04:38.770 --> 04:40.770
看一下

04:40.770 --> 04:42.770
他这里输出啥

04:42.770 --> 04:44.770
从我这个正的表的是匹配

04:47.770 --> 04:48.770
看一下

04:48.770 --> 04:50.770
你看是不是匹配了四次

04:50.770 --> 04:51.770
匹配了三次

04:51.770 --> 04:53.770
第一次匹配

04:53.770 --> 04:54.770
整个匹配是My

04:54.770 --> 04:55.770
My

04:55.770 --> 04:56.770
第一个单词

04:56.770 --> 04:57.770
第一个字母是M

04:57.770 --> 04:59.770
第二个后边的字母是Y

04:59.770 --> 05:00.770
第二次匹配的是这个

05:00.770 --> 05:01.770
整体匹配的是这个

05:01.770 --> 05:03.770
第一个分组是F

05:03.770 --> 05:05.770
第二个分组是后边的

05:05.770 --> 05:07.770
第三个匹配是匹配的这一部分

05:07.770 --> 05:08.770
第一个分组是这个

05:08.770 --> 05:10.770
第二个分组是这个

05:10.770 --> 05:11.770
那么怎么办

05:11.770 --> 05:12.770
第一个分组大写

05:12.770 --> 05:13.770
然后拼接上第二个就完事了

05:13.770 --> 05:14.770
对不对

05:14.770 --> 05:15.770
那么这里返回

05:15.770 --> 05:16.770
返回啥

05:16.770 --> 05:18.770
返回就是第一个大写

05:18.770 --> 05:20.770
ToUpperCase

05:20.770 --> 05:23.770
大写拼接上第二个就完事了

05:23.770 --> 05:24.770
我们把整个返回

05:24.770 --> 05:25.770
整个返回

05:25.770 --> 05:27.770
整个替换的结果返回

05:27.770 --> 05:29.770
那么就形成了这么一个函数了

05:29.770 --> 05:30.770
这个函数你甭管砸写的

05:30.770 --> 05:32.770
总之你肯定可以搞定对不对

05:32.770 --> 05:34.770
把每一个单词手这么大写

05:34.770 --> 05:35.770
咱们来看一下

05:35.770 --> 05:36.770
咱们来看一下

05:36.770 --> 05:37.770
我们这里去调用一下

05:37.770 --> 05:39.770
第一个函数

05:39.770 --> 05:41.770
first letter up

05:41.770 --> 05:43.770
这里拿STR传进去

05:43.770 --> 05:44.770
你看一下得到的是不是

05:44.770 --> 05:45.770
第一个手这么大写了

05:45.770 --> 05:47.770
对吧 单词手这么大写了

05:47.770 --> 05:49.770
我们再来写个函数

05:49.770 --> 05:51.770
这个函数它的作用是

05:51.770 --> 05:53.770
将每一个单词中

05:53.770 --> 05:55.770
除第一个手字母之外的

05:55.770 --> 05:57.770
所有字母小写

05:59.770 --> 06:01.770
other letter

06:01.770 --> 06:03.770
lower

06:03.770 --> 06:05.770
它的作用是

06:05.770 --> 06:07.770
将字母错终

06:07.770 --> 06:09.770
除

06:09.770 --> 06:11.770
手字母外的

06:11.770 --> 06:13.770
其他

06:13.770 --> 06:15.770
字母

06:15.770 --> 06:16.770
小写

06:16.770 --> 06:17.770
它做这么一个用处的

06:17.770 --> 06:19.770
用法是不是差不多的

06:19.770 --> 06:20.770
一样的对吧

06:20.770 --> 06:21.770
我们把它复制一下

06:21.770 --> 06:23.770
这个函数具体的实现

06:23.770 --> 06:24.770
不是重点

06:24.770 --> 06:25.770
这个东西不是重点

06:25.770 --> 06:27.770
重点是我们后边讲的东西

06:27.770 --> 06:29.770
第一个字符不动

06:29.770 --> 06:30.770
然后后边的匹配

06:30.770 --> 06:32.770
我们把它变成小写

06:32.770 --> 06:33.770
to lower

06:33.770 --> 06:34.770
case

06:34.770 --> 06:36.770
咱们来看一下吧

06:36.770 --> 06:38.770
我们这里调用这个

06:38.770 --> 06:39.770
other letter lower

06:39.770 --> 06:40.770
把STR传进去

06:40.770 --> 06:41.770
你看一下

06:41.770 --> 06:43.770
除了第一个字母之外

06:43.770 --> 06:44.770
后面的字母全部小写了

06:44.770 --> 06:45.770
对不对

06:45.770 --> 06:47.770
本来STR是这样子的

06:47.770 --> 06:48.770
现在通过它一变化

06:48.770 --> 06:50.770
变成这样子的

06:50.770 --> 06:52.770
这是第二个函数

06:52.770 --> 06:54.770
有同学可能知道我要干嘛了

06:54.770 --> 06:55.770
放弃

06:55.770 --> 06:57.770
接下来第三个函数

06:57.770 --> 06:59.770
remove empty

06:59.770 --> 07:01.770
去掉字母错终

07:01.770 --> 07:03.770
所有的空白字符

07:03.770 --> 07:05.770
去掉字母错终

07:05.770 --> 07:08.770
所有的空白字符

07:08.770 --> 07:10.770
那么这个函数怎么显的

07:10.770 --> 07:12.770
我们返回STR replace

07:12.770 --> 07:13.770
是一样的

07:13.770 --> 07:14.770
用挣折表达是匹配啥

07:14.770 --> 07:16.770
匹配所有的空白字符

07:16.770 --> 07:18.770
空白字母是不是邪纲的

07:18.770 --> 07:19.770
对吧

07:19.770 --> 07:20.770
只要出现一次

07:20.770 --> 07:22.770
或多次的空白字母都匹配啥

07:22.770 --> 07:24.770
匹配上过后把它变成空字母串

07:24.770 --> 07:25.770
就完事了

07:25.770 --> 07:26.770
咱们来看一下吧

07:26.770 --> 07:28.770
比方说这里多写个空白

07:28.770 --> 07:29.770
多写个空白

07:29.770 --> 07:30.770
保存

07:30.770 --> 07:31.770
前面有空白

07:31.770 --> 07:33.770
保存看一下

07:33.770 --> 07:34.770
这里呢

07:34.770 --> 07:36.770
remove empty str

07:36.770 --> 07:38.770
你看一去掉空白

07:38.770 --> 07:39.770
变成这样子了

07:39.770 --> 07:40.770
对吧

07:40.770 --> 07:41.770
好

07:41.770 --> 07:43.770
然后除了这个东西还有啥呢

07:43.770 --> 07:45.770
还有啥呢

07:46.770 --> 07:49.770
把单词手这么变小写

07:49.770 --> 07:53.460
再来

07:53.460 --> 07:55.460
first

07:55.460 --> 07:57.460
应该这样子说

07:59.460 --> 08:01.460
把单词手这么变小写

08:01.460 --> 08:04.460
first letter lower

08:04.460 --> 08:05.460
这个东西呢

08:05.460 --> 08:06.460
但是这样的命名呢

08:06.460 --> 08:07.460
跟第一个好像

08:07.460 --> 08:08.460
意识含义呢

08:08.460 --> 08:09.460
会有点区别

08:09.460 --> 08:10.460
第一个是

08:10.460 --> 08:11.460
每一个单词

08:11.460 --> 08:13.460
这个是第一个单词

08:13.460 --> 08:14.460
every

08:14.460 --> 08:15.460
这样吧

08:15.460 --> 08:17.460
我们把变一个名字

08:17.460 --> 08:18.460
我真的受不了这个

08:18.460 --> 08:20.460
every first letter

08:20.460 --> 08:22.460
每一个手字母大写

08:22.460 --> 08:24.460
这个是第1个

08:24.460 --> 08:27.460
将制服串中

08:27.460 --> 08:31.460
第1个单词制服小写

08:31.460 --> 08:33.460
那这个东西怎么做呢

08:33.460 --> 08:34.460
是不是还是

08:34.460 --> 08:37.460
还是一样的 str replace

08:37.460 --> 08:38.460
匹配啥

08:38.460 --> 08:39.460
只匹配一次

08:39.460 --> 08:40.460
不要拳句匹配了

08:40.460 --> 08:41.460
匹配什么

08:41.460 --> 08:42.460
写干w

08:42.460 --> 08:43.460
只需要匹配第1个

08:43.460 --> 08:44.460
写干w就行了

08:44.460 --> 08:45.460
把它变成什么呢

08:45.460 --> 08:46.460
放进去

08:46.460 --> 08:47.460
把匹配的结果

08:47.460 --> 08:50.460
return dollar to lower case

08:50.460 --> 08:52.460
把它变成小写

08:52.460 --> 08:54.460
试一下

08:54.460 --> 08:55.460
比方说

08:55.460 --> 08:58.460
第1个手字母是m大写的

08:58.460 --> 08:59.460
咱们来试一下

08:59.460 --> 09:01.460
str你看第1个手字母大写的

09:01.460 --> 09:02.460
我们通过这个函数

09:02.460 --> 09:06.460
通过这个first letter lower

09:06.460 --> 09:07.460
把str传进去

09:07.460 --> 09:10.460
你看下第1个字母是变小写的

09:10.460 --> 09:13.460
咱们就有这么4个函数

09:13.460 --> 09:15.460
现在我们要完成这么一功能

09:15.460 --> 09:16.460
一同也可能已经猜到了

09:16.460 --> 09:17.460
我要干嘛了

09:17.460 --> 09:20.460
我要将制服串

09:20.460 --> 09:23.460
就这个制服串

09:23.460 --> 09:26.460
将一个制服串

09:26.460 --> 09:31.460
变为小陀封密迷法

09:31.460 --> 09:32.460
那会怎么做呢

09:32.460 --> 09:33.460
是不是可以

09:33.460 --> 09:34.460
比方说这些函数

09:34.460 --> 09:35.460
早就写好了

09:35.460 --> 09:36.460
是一些通用的函数

09:36.460 --> 09:38.460
我们把它帮到函数库里边的

09:38.460 --> 09:39.460
通用函数已经写好了

09:39.460 --> 09:41.460
那我们要怎么做什么呢

09:41.460 --> 09:43.460
是不是把函数组合起来

09:43.460 --> 09:44.460
比方说我们要做的话

09:44.460 --> 09:45.460
怎么来做

09:45.460 --> 09:49.460
我们首先可以得到一个str1

09:49.460 --> 09:51.460
我们先把str得到

09:51.460 --> 09:55.460
就是every first letter up

09:55.460 --> 09:57.460
把所有的单词

09:57.460 --> 09:59.460
第1个字母大写

09:59.460 --> 10:00.460
然后呢

10:00.460 --> 10:02.460
我们这里就重新给它复制

10:02.460 --> 10:04.460
把返回的结果重新给它复制

10:04.460 --> 10:06.460
然后把str传进去

10:06.460 --> 10:08.460
然后我们又继续来处理

10:08.460 --> 10:12.460
把第1个单词的手字母小写

10:12.460 --> 10:14.460
first letter lower

10:14.460 --> 10:16.460
把第1个单词的手字母小写

10:16.460 --> 10:18.460
然后又重新给它复制

10:18.460 --> 10:21.460
你看每一步是不是完成一件事

10:21.460 --> 10:22.460
那有些同学说

10:22.460 --> 10:24.460
为什么我不怕全部写到一起呢

10:24.460 --> 10:26.460
我们之前不是写过小陀封密迷法吗

10:26.460 --> 10:27.460
一下就写完了

10:27.460 --> 10:28.460
为什么要分开呢

10:28.460 --> 10:29.460
那是因为我们要通用

10:29.460 --> 10:30.460
这些函数要通用

10:30.460 --> 10:31.460
那以后呢

10:31.460 --> 10:32.460
我不做什么小陀封

10:32.460 --> 10:35.460
我的目的不是要做小陀封密迷法

10:35.460 --> 10:36.460
而是要把这些

10:36.460 --> 10:37.460
比方说有些时候

10:37.460 --> 10:39.460
我们只是要把手这么大写

10:39.460 --> 10:40.460
而不做任何其他事情

10:40.460 --> 10:42.460
那你是不是又得写个函数呢

10:42.460 --> 10:43.460
因此我当这里呢

10:43.460 --> 10:44.460
是把为了通用

10:44.460 --> 10:46.460
把这些函数全部拆分开了

10:46.460 --> 10:48.460
只不过这里碰巧了

10:48.460 --> 10:49.460
我要做小封密迷法

10:49.460 --> 10:51.460
我们可以利用之前写的这些函数

10:51.460 --> 10:52.460
来进行制作

10:52.460 --> 10:54.460
是这么个意思

10:54.460 --> 10:55.460
然后再把手字母小写

10:55.460 --> 10:57.460
然后呢再干嘛呢

10:57.460 --> 10:59.460
再把其他字母小写

10:59.460 --> 11:01.460
阿扎雷特尔小写

11:01.460 --> 11:03.460
然后再去掉所有的空白制服

11:03.460 --> 11:04.460
STR

11:04.460 --> 11:06.460
最后呢输出这个STR

11:06.460 --> 11:07.460
看一下

11:07.460 --> 11:08.460
保存

11:08.460 --> 11:09.460
你看

11:09.460 --> 11:11.460
这变成小通封密迷法了

11:11.460 --> 11:12.460
当然这样子

11:12.460 --> 11:13.460
可不可以实验功能

11:13.460 --> 11:14.460
可以

11:14.460 --> 11:15.460
但是会显得有些麻烦

11:15.460 --> 11:17.460
因为我们会

11:17.460 --> 11:18.460
一个

11:18.460 --> 11:19.460
我们会调用多次

11:19.460 --> 11:20.460
这些函数

11:20.460 --> 11:21.460
对吧

11:21.460 --> 11:22.460
会反复的去调用它

11:22.460 --> 11:23.460
形成了一种

11:23.460 --> 11:24.460
还必须按照顺序来

11:24.460 --> 11:25.460
还不用乱来

11:25.460 --> 11:26.460
对吧

11:26.460 --> 11:27.460
如果你先去掉空白的话

11:27.460 --> 11:28.460
会不会就分布清楚

11:28.460 --> 11:29.460
哪些是单词了

11:29.460 --> 11:31.460
还不能随便改变它的顺序

11:31.460 --> 11:32.460
而且这个需求

11:32.460 --> 11:33.460
一旦重复出现

11:33.460 --> 11:34.460
那你是不是

11:34.460 --> 11:35.460
我们会

11:35.460 --> 11:37.460
导致重复的去写这些代码

11:37.460 --> 11:38.460
对不对

11:38.460 --> 11:39.460
那一定会造成

11:39.460 --> 11:40.460
后边难以维护的问题

11:40.460 --> 11:42.460
而且很容易出错

11:42.460 --> 11:44.460
那么我们仔细观察一下

11:44.460 --> 11:45.460
这些函数都有个特点

11:45.460 --> 11:47.460
就是它只有一个参数

11:47.460 --> 11:48.460
并且呢

11:48.460 --> 11:49.460
它每个函数都有个反回值

11:49.460 --> 11:50.460
并且呢

11:50.460 --> 11:51.460
我们按照一个

11:51.460 --> 11:52.460
一定的调用顺序

11:52.460 --> 11:54.460
前一个的反回值

11:54.460 --> 11:55.460
它会作为

11:55.460 --> 11:56.460
第二个函数的参数

11:56.460 --> 11:57.460
那么是不是形成

11:57.460 --> 11:58.460
这种这么一种结构了

11:58.460 --> 11:59.460
我们就可以利用

11:59.460 --> 12:02.460
函数管道来实现

12:02.460 --> 12:03.460
那么怎么来利用

12:03.460 --> 12:04.460
函数管道来实现呢

12:04.460 --> 12:05.460
我们先假设

12:05.460 --> 12:07.460
假设这个函数管道

12:07.460 --> 12:09.460
已经写好了

12:09.460 --> 12:11.460
我们还是写到plunging里面

12:11.460 --> 12:13.460
函数管道已经写好了

12:13.460 --> 12:15.460
我们只需要做这么一件事

12:15.460 --> 12:18.460
myplunging

12:18.460 --> 12:19.460
plunging

12:19.460 --> 12:21.460
然后里面一个函数叫pipe

12:21.460 --> 12:22.460
pipe就是管道的意思

12:22.460 --> 12:23.460
我们把我们

12:23.460 --> 12:24.460
需要调用的函数

12:24.460 --> 12:25.460
依次传进去

12:25.460 --> 12:27.460
这就是我们要调用的函数

12:28.460 --> 12:29.460
第二个

12:29.460 --> 12:30.460
换个行

12:31.460 --> 12:32.460
第三个

12:34.460 --> 12:35.460
第四个

12:35.460 --> 12:37.460
我们把这些函数依次传进去

12:37.460 --> 12:38.460
于是呢

12:38.460 --> 12:40.460
它会返回给我们一个新的函数

12:40.460 --> 12:41.460
一个新的函数

12:41.460 --> 12:42.460
small

12:42.460 --> 12:44.460
camel

12:44.460 --> 12:46.460
小头风秘密法的函数

12:46.460 --> 12:47.460
有时候把这些函数

12:47.460 --> 12:48.460
组合起来形成一个管道

12:48.460 --> 12:50.460
就形成了这个虚线框

12:50.460 --> 12:52.460
来产生一个新的函数

12:52.460 --> 12:53.460
那么我们以后呢

12:53.460 --> 12:54.460
只需要去调用新的函数

12:54.460 --> 12:55.460
就完了

12:55.460 --> 12:56.460
我们要实现小头风秘密法

12:56.460 --> 12:57.460
很简单

12:57.460 --> 12:58.460
我们这里调用这个

12:58.460 --> 12:59.460
就完事了

12:59.460 --> 13:00.460
把字幕刷传进去

13:00.460 --> 13:01.460
就完事了

13:01.460 --> 13:03.460
这样子写的好处在于

13:03.460 --> 13:05.460
我们把它的顺序就固定下来了

13:05.460 --> 13:07.460
固定下来它的调用顺序

13:07.460 --> 13:08.460
而且我们以后就

13:08.460 --> 13:09.460
而且没有什么重复代码

13:09.460 --> 13:11.460
也没有降低到复杂度

13:11.460 --> 13:13.460
我们以后就要做小头风秘密法

13:13.460 --> 13:15.460
直接使用它就完事了

13:15.460 --> 13:17.460
并且我们没有重新去写一个函数

13:17.460 --> 13:19.460
并没有重新去写一个函数

13:19.460 --> 13:20.460
只是利用之前的函数

13:20.460 --> 13:23.460
来组合成为了一个新的函数

13:23.460 --> 13:26.460
这是一种非常非常强大的功能

13:26.460 --> 13:27.460
那么后边呢

13:27.460 --> 13:29.460
我要反而是要做小头风秘密法

13:29.460 --> 13:30.460
是不是就直接调用它就完事了

13:30.460 --> 13:31.460
对吧

13:31.460 --> 13:32.460
我们利用之前的函数

13:32.460 --> 13:34.460
做出来的一个新的函数

13:34.460 --> 13:35.460
都通过组合

13:35.460 --> 13:37.460
按照一定的顺序组合就完事了

13:37.460 --> 13:38.460
好

13:38.460 --> 13:40.460
接下来我们来写一下这个东西

13:40.460 --> 13:41.460
好

13:41.460 --> 13:42.460
这里呢

13:42.460 --> 13:44.460
我们写上

13:44.460 --> 13:46.460
这是一个函数

13:46.460 --> 13:47.460
好

13:47.460 --> 13:48.460
这里边呢

13:48.460 --> 13:49.460
它要传入多个函数

13:49.460 --> 13:50.460
对吧

13:50.460 --> 13:51.460
那到底有多好个呢

13:51.460 --> 13:52.460
我也不知道有多好个

13:52.460 --> 13:53.460
不写了

13:53.460 --> 13:54.460
不写形态了

13:54.460 --> 13:55.460
我们直接从什么

13:55.460 --> 13:56.460
argument里面

13:56.460 --> 13:57.460
可以拿到所有的函数

13:57.460 --> 13:58.460
对吧

13:58.460 --> 13:59.460
我们这里是通过什么

13:59.460 --> 14:00.460
array

14:00.460 --> 14:01.460
from

14:01.460 --> 14:02.460
拿到这里边的

14:02.460 --> 14:04.460
argument

14:04.460 --> 14:06.460
拿到这里边的所有参数

14:06.460 --> 14:09.460
拿到这里边的所有参数

14:09.460 --> 14:10.460
好

14:10.460 --> 14:11.460
每一个参数是不是函数

14:11.460 --> 14:12.460
对吧

14:12.460 --> 14:13.460
你看这里

14:13.460 --> 14:14.460
每一个参数就是一个函数

14:14.460 --> 14:15.460
好

14:15.460 --> 14:16.460
这里要做的就是把这些函数

14:16.460 --> 14:17.460
组合起来

14:17.460 --> 14:18.460
好

14:18.460 --> 14:19.460
它会返回什么呢

14:19.460 --> 14:20.460
是不是返回一个新的函数

14:20.460 --> 14:21.460
对吧

14:22.460 --> 14:24.460
只要你雕用这个新的函数

14:24.460 --> 14:25.460
那么怎么样呢

14:25.460 --> 14:26.460
这个函数

14:26.460 --> 14:27.460
这个函数

14:27.460 --> 14:28.460
这个函数会有个参数

14:28.460 --> 14:29.460
对不对

14:29.460 --> 14:30.460
会有个参数

14:30.460 --> 14:31.460
为什么会有参数呢

14:31.460 --> 14:32.460
因为我们这里组合的函数

14:32.460 --> 14:33.460
都是单参

14:33.460 --> 14:34.460
看不看

14:34.460 --> 14:35.460
都是单参函数

14:35.460 --> 14:37.460
我们做函数管道的时候

14:37.460 --> 14:38.460
有个前提条件

14:38.460 --> 14:40.460
必须要是单参函数

14:40.460 --> 14:41.460
如果你是多个函数

14:41.460 --> 14:42.460
比方说

14:42.460 --> 14:43.460
这个函数

14:43.460 --> 14:44.460
它需要两个函数

14:44.460 --> 14:45.460
那这里怎么办呢

14:45.460 --> 14:46.460
因为第一个函数

14:46.460 --> 14:47.460
只有一个返回结果

14:47.460 --> 14:48.460
它不可能有两个返回结果

14:48.460 --> 14:49.460
所以说

14:49.460 --> 14:50.460
那你不好

14:50.460 --> 14:51.460
所以我们这里有个前提条件

14:51.460 --> 14:52.460
就是

14:52.460 --> 14:53.460
它一定是单参

14:53.460 --> 14:54.460
这些函数都是单参

14:54.460 --> 14:55.460
所以说

14:55.460 --> 14:56.460
我们这里

14:56.460 --> 14:57.460
雕用的时候

14:57.460 --> 14:58.460
传一个参数进去

14:58.460 --> 14:59.460
就是初始参数

14:59.460 --> 15:01.460
就是把初始参数传进去

15:01.460 --> 15:02.460
好

15:02.460 --> 15:03.460
所以说

15:03.460 --> 15:04.460
这里一定是有一个参数的

15:04.460 --> 15:05.460
我们可以直接写

15:05.460 --> 15:06.460
好

15:06.460 --> 15:07.460
那么这里边做啥呢

15:07.460 --> 15:09.460
这里大概做啥

15:09.460 --> 15:11.460
这是函数管道

15:11.460 --> 15:12.460
函数管道

15:12.460 --> 15:13.460
好

15:13.460 --> 15:14.460
那这里边做啥呢

15:14.460 --> 15:15.460
这里边做的

15:15.460 --> 15:17.460
实际上是非常非常简单

15:17.460 --> 15:18.460
就是循环

15:18.460 --> 15:19.460
循环啥

15:20.460 --> 15:22.460
是不是循环

15:22.460 --> 15:23.460
这个

15:24.460 --> 15:26.460
循环这个所有的

15:26.460 --> 15:28.460
函数

15:28.460 --> 15:29.460
对不对

15:29.460 --> 15:30.460
是不是循环这个参数列表

15:30.460 --> 15:31.460
参数列表

15:31.460 --> 15:32.460
参数里面每一个是不是函数

15:32.460 --> 15:33.460
对吧

15:33.460 --> 15:34.460
每一个就是个函数

15:34.460 --> 15:35.460
循环

15:35.460 --> 15:37.460
把它的每一个函数拿到

15:37.460 --> 15:38.460
然后呢

15:38.460 --> 15:39.460
干嘛呢

15:39.460 --> 15:41.460
把这个参数是不是扔进去

15:41.460 --> 15:42.460
对吧

15:42.460 --> 15:43.460
参数扔进去执行

15:43.460 --> 15:44.460
放

15:44.460 --> 15:46.460
参数扔进去执行

15:46.460 --> 15:47.460
执行完了过后

15:47.460 --> 15:48.460
是不是会返回一个结果

15:48.460 --> 15:49.460
返回一个结果

15:49.460 --> 15:51.460
再用这个参数来接收

15:51.460 --> 15:52.460
你看每一次循环

15:52.460 --> 15:53.460
雕用一个函数

15:53.460 --> 15:55.460
把之前的参数扔进去

15:55.460 --> 15:56.460
然后得到一个新的值

15:56.460 --> 15:57.460
保存到这里边

15:57.460 --> 15:58.460
下一次循环了

15:58.460 --> 16:00.460
又把它新的值扔进去

16:00.460 --> 16:01.460
又得到一个新的值

16:01.460 --> 16:02.460
又保存到这里边

16:02.460 --> 16:03.460
那么运行完了是不是就完了

16:03.460 --> 16:04.460
对不对

16:04.460 --> 16:05.460
运行完了之后

16:05.460 --> 16:06.460
那么最后的这个WOW

16:06.460 --> 16:08.460
是不是就追动了值

16:08.460 --> 16:09.460
对吧

16:09.460 --> 16:10.460
这其实很简单

16:10.460 --> 16:11.460
很简单

16:11.460 --> 16:12.460
函数管道就做出来了

16:12.460 --> 16:13.460
大家看一下吧

16:13.460 --> 16:14.460
保存

16:14.460 --> 16:15.460
你看一下

16:15.460 --> 16:16.460
是不是小通通秘密法

16:16.460 --> 16:17.460
这个好处在于

16:17.460 --> 16:19.460
我们以后它是通用的

16:19.460 --> 16:20.460
这个函数是自动做出来的

16:20.460 --> 16:22.460
它没有自己去写

16:22.460 --> 16:23.460
比方说我们这里

16:23.460 --> 16:32.000
还可以继续写

16:32.000 --> 16:33.000
保存

16:33.000 --> 16:34.000
你看

16:34.000 --> 16:35.000
现在变成这个样子了

16:35.000 --> 16:37.000
就是个小通通秘密法

16:37.000 --> 16:38.000
懂这个意思吗

16:38.000 --> 16:40.000
它可以重复使用

16:40.000 --> 16:41.000
好 那这边呢

16:41.000 --> 16:43.000
这边其实还有别的写法

16:43.000 --> 16:45.000
不知道大家能不能想到别的写法

16:45.000 --> 16:47.000
我估计是很难的

16:47.000 --> 16:48.000
你们都学过的

16:48.000 --> 16:50.000
但是你肯定很难想得到

16:50.000 --> 16:52.000
你想能想到这种写法了

16:52.000 --> 16:54.000
你真的是天才了

16:54.000 --> 16:56.000
还可以砸血呢

16:56.000 --> 16:58.000
这是个数组

16:58.000 --> 17:00.000
这是个数组

17:00.000 --> 17:01.000
这个数组里边

17:01.000 --> 17:02.000
它是我们以前学过的

17:02.000 --> 17:04.000
是不是一个reduce

17:04.000 --> 17:05.000
reduce当时我们来用来干嘛的

17:05.000 --> 17:07.000
用来求和的 对吧

17:07.000 --> 17:09.000
当时是用来求和的

17:09.000 --> 17:10.000
实际上

17:10.000 --> 17:11.000
我们这里还可以这样来做

17:11.000 --> 17:13.000
results

17:14.000 --> 17:17.000
这里是WOW

17:17.000 --> 17:19.000
这里我们还可以这样子玩

17:20.000 --> 17:21.000
怎么玩呢

17:21.000 --> 17:23.000
就是说这里是初始值

17:23.000 --> 17:25.000
求和的初始值

17:25.000 --> 17:27.000
这种写法能听懂就听

17:27.000 --> 17:29.000
听不懂就实在听不懂就算了

17:29.000 --> 17:31.000
不做强制要求

17:31.000 --> 17:34.000
这种写法确实不太好理解

17:34.000 --> 17:35.000
那么这里呢

17:35.000 --> 17:37.000
它会把数组的每一项

17:37.000 --> 17:38.000
传过来

17:38.000 --> 17:44.550
然后把累计的结果传到这儿

17:44.550 --> 17:45.550
完了

17:45.550 --> 17:47.550
写完了

17:47.550 --> 17:49.550
第一次掉那个函数

17:49.550 --> 17:51.550
它是把数组的第一项传过来

17:51.550 --> 17:53.550
数组的第一项是不是个函数

17:53.550 --> 17:54.550
然后这个地方是

17:54.550 --> 17:55.550
这个地方就是默认值

17:55.550 --> 17:57.550
默认值就是这个参数

17:57.550 --> 17:58.550
默认值传过来

17:58.550 --> 18:00.550
然后我们调用这个函数

18:00.550 --> 18:02.550
把这个参数的值放进去

18:02.550 --> 18:04.550
是不是返回一个新的值

18:04.550 --> 18:05.550
返回的新的值

18:05.550 --> 18:07.550
它会作为第二次调用的时候

18:07.550 --> 18:08.550
这个得值

18:08.550 --> 18:09.550
那么第二次调用的时候

18:09.550 --> 18:10.550
这是数组的第二项

18:10.550 --> 18:12.550
然后把之前累计的结果

18:12.550 --> 18:13.550
放到这儿

18:13.550 --> 18:14.550
之前返回的结果放到这儿

18:14.550 --> 18:15.550
那么是不是又来一次

18:15.550 --> 18:16.550
又把之前返回的结果

18:16.550 --> 18:17.550
作为参数人进去

18:17.550 --> 18:18.550
又返回 对吧

18:18.550 --> 18:20.550
这样的结果是一样的

18:20.550 --> 18:21.550
是一样的

18:21.550 --> 18:23.550
两种写法都想

18:23.550 --> 18:24.550
看你用哪一种都想

18:24.550 --> 18:27.550
哪一种能理解就有写那一种

18:28.550 --> 18:29.550
好 那不这边

18:29.550 --> 18:31.550
如果还遇到这种情况

18:31.550 --> 18:32.550
将来还可能遇到这种情况

18:32.550 --> 18:33.550
我们说

18:33.550 --> 18:35.550
以后做小陀封命名法的时候

18:35.550 --> 18:36.550
还要做一个处理

18:36.550 --> 18:37.550
就是说

18:37.550 --> 18:39.550
你要解取这个制服段

18:39.550 --> 18:40.550
不能名字不能太长了

18:40.550 --> 18:41.550
一共就十个制服

18:41.550 --> 18:42.550
比方说

18:42.550 --> 18:44.550
一共它的小陀封命名法

18:44.550 --> 18:45.550
就十个制服

18:45.550 --> 18:46.550
那么比方说

18:46.550 --> 18:47.550
我们这里还有一个函数

18:47.550 --> 18:49.550
叫做卡池俊

18:49.550 --> 18:51.550
传入一个制服创

18:51.550 --> 18:52.550
传入一个制服创

18:52.550 --> 18:54.550
还要传入一个什么呢

18:54.550 --> 18:56.550
还要传入一个就是

18:57.550 --> 18:59.550
数字 传入一个数字

18:59.550 --> 19:01.550
哎呗 不能直接这样的

19:01.550 --> 19:02.550
Lumber

19:02.550 --> 19:04.550
就是解取一个制服创

19:04.550 --> 19:05.550
解取多少位呢

19:05.550 --> 19:07.550
解取这么多位

19:07.550 --> 19:08.550
那么我们直接返回

19:08.550 --> 19:09.550
STR 是吧

19:09.550 --> 19:10.550
Subs俊 对吧

19:10.550 --> 19:11.550
Subs俊

19:13.550 --> 19:16.550
从零开始

19:16.550 --> 19:17.550
从零开始

19:18.550 --> 19:19.550
然后解取多长呢

19:19.550 --> 19:20.550
Lumber

19:20.550 --> 19:21.550
解取这么多

19:21.550 --> 19:22.550
对吧

19:22.550 --> 19:23.550
我们传入这么一个

19:23.550 --> 19:24.550
返回这么一个东西就行了

19:24.550 --> 19:25.550
就解取制服创

19:25.550 --> 19:26.550
从制服创一开始

19:26.550 --> 19:28.550
解取这么多位

19:28.550 --> 19:30.550
这是解取

19:30.550 --> 19:31.550
假设

19:31.550 --> 19:32.550
假设

19:32.550 --> 19:33.550
有这么一个函数

19:33.550 --> 19:34.550
这些函数具体的实现

19:34.550 --> 19:35.550
不是重点

19:35.550 --> 19:36.550
那么关键是

19:36.550 --> 19:37.550
我们怎么来拼呢

19:37.550 --> 19:38.550
我能不能最终

19:38.550 --> 19:39.550
直接把这个东西拼进去

19:39.550 --> 19:40.550
组合到管道里边去

19:40.550 --> 19:41.550
能不能自己

19:41.550 --> 19:42.550
直接这样子写

19:42.550 --> 19:43.550
能不能

19:43.550 --> 19:44.550
它不能这样子写

19:44.550 --> 19:45.550
不能这样子写

19:45.550 --> 19:46.550
这里要出问题的

19:46.550 --> 19:47.550
这里是要出问题的

19:47.550 --> 19:48.550
为什么要出问题呢

19:48.550 --> 19:49.550
因为这里是

19:49.550 --> 19:50.550
有两个参数

19:50.550 --> 19:52.550
它这里是有两个参数

19:52.550 --> 19:53.550
比方说

19:54.550 --> 19:55.550
反正在写吧

19:55.550 --> 19:56.550
反正在写

19:57.550 --> 19:58.550
因为这个场景

19:58.550 --> 19:59.550
我们要说明一下

19:59.550 --> 20:00.550
这要反正在写

20:02.550 --> 20:03.550
好 那么假设

20:03.550 --> 20:04.550
已经写好了

20:04.550 --> 20:05.550
那么现在呢

20:05.550 --> 20:06.550
我们怎么办呢

20:06.550 --> 20:07.550
它有两个参数

20:07.550 --> 20:08.550
不适配对吧

20:08.550 --> 20:09.550
这里每个参数

20:09.550 --> 20:10.550
必须要只能有一个参数

20:10.550 --> 20:11.550
我们这里

20:11.550 --> 20:12.550
可以利用颗粒的话

20:13.550 --> 20:14.550
买普通键

20:14.550 --> 20:15.550
是不是上级课的东西

20:15.550 --> 20:16.550
对吧

20:17.550 --> 20:18.550
颗粒话

20:18.550 --> 20:19.550
颗粒话

20:19.550 --> 20:21.550
函数的名字叫做Costume

20:21.550 --> 20:22.550
固定一个参数

20:22.550 --> 20:23.550
十个字符

20:23.550 --> 20:24.550
那这个东西

20:24.550 --> 20:25.550
返回来是不是

20:25.550 --> 20:26.550
就是单参函数了

20:26.550 --> 20:27.550
所以颗粒话

20:27.550 --> 20:28.550
在函数的编程里面

20:28.550 --> 20:29.550
很有用

20:29.550 --> 20:30.550
它的用处又是这样子

20:30.550 --> 20:32.550
它可以把它变成单参函数

20:32.550 --> 20:33.550
这样进来的话

20:33.550 --> 20:34.550
那么就没问题了

20:34.550 --> 20:35.550
那你看

20:36.550 --> 20:37.550
是不是就解决了

20:37.550 --> 20:38.550
对不对

20:38.550 --> 20:39.550
每个字解决了十个字符

20:39.550 --> 20:40.550
明白这个意思吧

20:41.550 --> 20:43.550
OK 这是关于这一块

20:43.550 --> 20:44.550
这一块

20:44.550 --> 20:46.550
好 下来还是把它写一下吧

20:46.550 --> 20:48.550
既然你在听这个扩展课程

20:48.550 --> 20:49.550
你还是把它写一下

20:49.550 --> 20:50.550
好吧

