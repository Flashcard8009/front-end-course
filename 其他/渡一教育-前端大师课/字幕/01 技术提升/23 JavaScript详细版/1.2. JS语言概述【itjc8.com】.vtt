WEBVTT

00:00.000 --> 00:18.930
这一课我们来介绍一下 关于介事语言的一些概念 特点 历史这些东西

00:18.930 --> 00:25.430
做一个简单的概述 这一课仍然很重要 因为如果你不了解介事的一些历史

00:25.430 --> 00:31.930
一些特点的话 那么以后你遇到一些数语 或者是跟同事聊天的时候 别人在说什么你可能就不知道了

00:31.930 --> 00:37.930
我们还是简单的了解一下 首先是关于介事语言的解释

00:38.930 --> 00:47.930
就是说这一块我们简单的介绍一下 介事语言它从开始出现到目前的发展整个过程

00:47.930 --> 00:52.930
顺便介绍一些概念和一些版本号 简单的说一下

00:52.930 --> 00:55.930
因为我这里介绍的比较简单 因为我只讲关键点

00:55.930 --> 01:04.930
如果你想了解整个介事语言的完整的历史的话 可以去看一下成歌的介事语言的课程第1节课

01:04.930 --> 01:08.930
它花了一个小时左右的时间 介绍了整个浏览器的发展历史

01:08.930 --> 01:13.930
好吧 我这里就简单介绍一下就行了 主要是分为4个步骤

01:13.930 --> 01:19.930
第一个步骤是关于介事语言的起源 它怎么来的

01:19.930 --> 01:23.930
这里就说到一个公司 这个公司的名字叫做王景

01:23.930 --> 01:28.930
它的权称叫做net scape

01:28.930 --> 01:34.930
然后是communication

01:34.930 --> 01:41.930
communication corporation

01:41.930 --> 01:44.930
表示王景通信公司

01:44.930 --> 01:57.930
这个公司在1994年推出第一款商用浏览器

01:57.930 --> 02:01.930
这个浏览器就是王景浏览器

02:01.930 --> 02:06.930
它的权称叫做net scape

02:06.930 --> 02:09.930
navigator 就是浏览器的意思

02:09.930 --> 02:11.930
浏览器也叫做用户代理 对吧

02:11.930 --> 02:13.930
如果听过我etimel和css课程的话 你应该知道

02:13.930 --> 02:16.930
浏览器有的时候也把它叫做用户代理

02:16.930 --> 02:19.930
那么它在1994年推出了第一款商用浏览器

02:19.930 --> 02:25.930
但是那个时候浏览器它只有一个功能 就是渲染静态页面

02:25.930 --> 02:28.930
就是我们之前学习的etimel和css

02:28.930 --> 02:30.930
它只能渲染静态页面

02:30.930 --> 02:34.930
它不能做任何的跟用户之间的交互效果

02:34.930 --> 02:38.930
比方说轮波图 比方说表单验证

02:38.930 --> 02:42.930
比方说一些动画这些东西以前都做不了

02:42.930 --> 02:44.930
它只能做静态页面

02:44.930 --> 02:46.930
就是你们之前学的etimel和css那一块

02:46.930 --> 02:50.930
你们学的哪些东西 你们能做啥 它只能做啥

02:50.930 --> 02:52.930
它只能完成这么一个效果

02:52.930 --> 02:55.930
所以说当时的功能是非常做的

02:55.930 --> 02:56.930
但是你现在回想一下

02:56.930 --> 02:58.930
如果我们出生在

02:58.930 --> 03:00.930
如果我们是在那个时候

03:00.930 --> 03:02.930
就已经开始参加工作了

03:02.930 --> 03:04.930
进入互联网领域

03:04.930 --> 03:07.930
那么那个时候我们需要的技能真的非常非常少

03:07.930 --> 03:09.930
只需要你会静态页面就完事了

03:09.930 --> 03:11.930
静态页面需要学多久呢

03:11.930 --> 03:13.930
无非就是一两周吧 最多就一两周

03:13.930 --> 03:15.930
一两周就把静态页面学会了

03:15.930 --> 03:16.930
能够做静态页面

03:16.930 --> 03:18.930
那个时候就已经非常非常了不起了

03:18.930 --> 03:20.930
因为那个时候在浏览器这一段

03:20.930 --> 03:21.930
它不需要什么东西

03:21.930 --> 03:23.930
它只能识别静态页面

03:23.930 --> 03:27.930
当然这个现象持续到1995年

03:27.930 --> 03:28.930
就有发生了变化

03:28.930 --> 03:30.930
1995年的时候

03:31.930 --> 03:33.930
网景公司

03:33.930 --> 03:37.930
决定在浏览器中

03:37.930 --> 03:41.930
加入一门语言

03:41.930 --> 03:43.930
可以做交互效果

03:43.930 --> 03:45.930
交互效果

03:45.930 --> 03:47.930
提高用户体验

03:48.930 --> 03:50.930
它决定在自己开发的浏览器

03:50.930 --> 03:54.930
就是网景浏览器里边能够去执行一门语言

03:54.930 --> 03:57.930
那么这种语言可以在浏览器端执行

03:57.930 --> 03:59.930
它不需要跟服务器之间做任何的交互

03:59.930 --> 04:01.930
你们现在可能还不知道什么叫服务器

04:01.930 --> 04:03.930
没关系 你们以后会学习

04:03.930 --> 04:04.930
就是远程通信

04:04.930 --> 04:05.930
跟服务器之间远程通信

04:05.930 --> 04:07.930
它不需要做任何的交互效果

04:07.930 --> 04:09.930
不需要跟服务器之间进行通信

04:09.930 --> 04:13.930
只是在浏览器这一边做一些动画效果

04:13.930 --> 04:15.930
或者是跟用户交互了一些东西

04:15.930 --> 04:17.930
那么这样子就可以提高一些用户体验了

04:17.930 --> 04:19.930
像咱们现在浏览网页的时候

04:19.930 --> 04:21.930
有很多很多的交互效果

04:21.930 --> 04:22.930
非常非常多

04:22.930 --> 04:25.930
比如说点一下一个菜单就展开了

04:25.930 --> 04:28.930
或者是点一下一个东西就消失了

04:28.930 --> 04:29.930
另外的东西就出来了

04:29.930 --> 04:31.930
像这些交互效果

04:31.930 --> 04:33.930
静态一面能做吗 是不是不能做

04:33.930 --> 04:35.930
我们之前都学过静态一面

04:35.930 --> 04:36.930
是不能做的

04:36.930 --> 04:38.930
就是必须要有一个新的语言

04:38.930 --> 04:41.930
来可以实现这种跟用户之间的交互效果

04:41.930 --> 04:43.930
来提高用户体验

04:44.930 --> 04:46.930
于是它有了这个决定之后

04:46.930 --> 04:47.930
它开始寻找

04:47.930 --> 04:49.930
到底用什么样的语言比较合适

04:49.930 --> 04:50.930
后来它早来早去

04:50.930 --> 04:52.930
发现什么语言都不合适

04:52.930 --> 04:54.930
有些语言倒是蛮合适的

04:54.930 --> 04:55.930
比方说加把

04:55.930 --> 04:57.930
加把当时也很火

04:57.930 --> 04:58.930
刚刚出来不久

04:58.930 --> 05:01.930
那个时候语言在市场上非常火

05:01.930 --> 05:04.930
当时王锦公甚至跟加把的高层

05:04.930 --> 05:05.930
有一个接触

05:05.930 --> 05:07.930
想一想能不能把一个加把语言

05:07.930 --> 05:09.930
放到我的浏览器端

05:09.930 --> 05:11.930
后来研究了一下

05:11.930 --> 05:12.930
发现这也不行

05:12.930 --> 05:14.930
因为加把语言太庞大了

05:14.930 --> 05:18.930
放在浏览器端不便于用户学习

05:18.930 --> 05:19.930
因为当时开发一面的

05:19.930 --> 05:22.930
很多都是没有多少基础的开发人员

05:22.930 --> 05:25.930
你要让它去开发一个动画效果

05:25.930 --> 05:26.930
一个交互效果

05:26.930 --> 05:29.930
就要去学习一门完整的加把语言

05:29.930 --> 05:30.930
这个太重了

05:30.930 --> 05:32.930
不利于市场宣传

05:32.930 --> 05:33.930
所以说它需要的是一门

05:33.930 --> 05:35.930
非常非常简洁的语言

05:35.930 --> 05:37.930
可以很快地上手

05:37.930 --> 05:38.930
很快地做出效果

05:38.930 --> 05:40.930
因为它做的效果很少

05:40.930 --> 05:41.930
它不需要那么强大的功能

05:41.930 --> 05:43.930
它只需要完成一些小的效果

05:43.930 --> 05:44.930
就完事了

05:44.930 --> 05:47.930
所以说它最后决定

05:47.930 --> 05:51.930
最终决定独立开发一门

05:51.930 --> 05:53.930
新的语言

05:53.930 --> 05:55.930
谁负责新的语言的开发

05:55.930 --> 05:57.930
专门聘请了一个人

05:57.930 --> 05:58.930
是一个大神

05:58.930 --> 06:00.930
叫做聘请

06:01.930 --> 06:03.930
Brandon

06:07.930 --> 06:08.930
大小的B

06:11.750 --> 06:12.750
H

06:13.750 --> 06:15.750
叫做布兰登爱奇

06:15.750 --> 06:17.750
聘请了这么一个人

06:17.750 --> 06:19.750
来负责新的语言的开发

06:19.750 --> 06:21.750
这个人很强

06:21.750 --> 06:22.750
他是个大神

06:22.750 --> 06:24.750
他在十天后

06:24.750 --> 06:26.750
十天内就完成新的语言的开发

06:26.750 --> 06:28.750
十天后

06:28.750 --> 06:30.750
新的语言

06:30.750 --> 06:32.750
诞生

06:32.750 --> 06:33.750
这个语言呢

06:33.750 --> 06:35.750
他借鉴了很多其他的语言

06:35.750 --> 06:37.750
比方说借鉴了什么C语言

06:37.750 --> 06:39.750
借鉴了什么

06:39.750 --> 06:41.750
self语言

06:41.750 --> 06:42.750
scammer语言

06:42.750 --> 06:43.750
java语言

06:43.750 --> 06:44.750
他都有借鉴

06:44.750 --> 06:46.750
这里我顺便说一下

06:46.750 --> 06:47.750
实际上呢

06:47.750 --> 06:49.750
布兰登爱奇这个人

06:49.750 --> 06:51.750
他挺讨厌java语言的

06:51.750 --> 06:54.750
因为他是一个韩束式编程的拥护者

06:54.750 --> 06:56.750
他不喜欢面向对象编程

06:56.750 --> 06:57.750
java语言

06:57.750 --> 06:59.750
我们都知道是个面向对象编程对吧

06:59.750 --> 07:01.750
这些东西我后面简单介绍一下就行了

07:01.750 --> 07:02.750
现在不管

07:02.750 --> 07:03.750
就是集中编程方式

07:03.750 --> 07:05.750
他比较喜欢韩束式编程

07:05.750 --> 07:06.750
所以说呢

07:06.750 --> 07:08.750
他比较讨厌java语言

07:08.750 --> 07:09.750
但是呢公司呢

07:09.750 --> 07:10.750
王靖公司呢

07:10.750 --> 07:11.750
当时看到

07:11.750 --> 07:13.750
java刚刚推出不久

07:13.750 --> 07:15.750
而且市场非常非常火热

07:15.750 --> 07:17.750
他想去蹭这个热点

07:17.750 --> 07:19.750
所以说呢希望brandonH这个人呢

07:19.750 --> 07:21.750
在开发这个语言的时候呢

07:21.750 --> 07:23.750
多去借鉴一下java

07:23.750 --> 07:25.750
把他的java的一些语法特征呢

07:25.750 --> 07:26.750
借鉴过来

07:26.750 --> 07:27.750
这样子好处呢

07:27.750 --> 07:29.750
就是在以后推广的时候呢

07:29.750 --> 07:30.750
比较容易推广

07:30.750 --> 07:32.750
也就是说出于商业的考虑

07:32.750 --> 07:35.750
公司要求brandonH

07:35.750 --> 07:37.750
加入一些java的特性

07:37.750 --> 07:39.750
我这里顺便说一下

07:39.750 --> 07:40.750
brandonH实际上他

07:40.750 --> 07:42.750
真的不想去支持什么面向对象的

07:42.750 --> 07:44.750
真的不想去支持的

07:44.750 --> 07:46.750
只是出于无奈

07:46.750 --> 07:48.750
公司强行要求他这样做

07:48.750 --> 07:51.750
所以说他加入了一些面向对象的东西

07:51.750 --> 07:52.750
所以说现在我们介石里边

07:52.750 --> 07:54.750
才能使用面向对象

07:54.750 --> 07:56.750
这里顺便说一点

07:56.750 --> 07:57.750
总之当时在十天后呢

07:57.750 --> 07:58.750
这个新的语言就诞生了

07:58.750 --> 08:00.750
这个新的语言的名字呢

08:00.750 --> 08:02.750
叫做leave script

08:02.750 --> 08:03.750
leave script

08:03.750 --> 08:06.750
后来呢也是出于商业的考虑

08:06.750 --> 08:08.750
把它更名为java script

08:08.750 --> 08:10.750
也就是简称的介石

08:10.750 --> 08:11.750
我们说介石

08:11.750 --> 08:12.750
说的就是什么

08:12.750 --> 08:13.750
java script 对吧

08:13.750 --> 08:15.750
后面更名为java script

08:15.750 --> 08:16.750
那么这个点呢

08:16.750 --> 08:17.750
主要是出于商业考虑

08:17.750 --> 08:19.750
因为当时java很火

08:19.750 --> 08:21.750
于是呢王靖公司呢跟

08:21.750 --> 08:23.750
上公司呢就是java的

08:23.750 --> 08:24.750
这个公司啊

08:24.750 --> 08:26.750
他们之间的打成合作啊合作

08:26.750 --> 08:29.750
你不是写程序很厉害吗

08:29.750 --> 08:30.750
java

08:30.750 --> 08:31.750
你不是

08:31.750 --> 08:32.750
这个王靖呢

08:32.750 --> 08:34.750
浏览器这一块很厉害

08:34.750 --> 08:36.750
当时占了市场很大的分额

08:36.750 --> 08:38.750
所以说这两家公司呢就合作了

08:38.750 --> 08:40.750
然后呢决定了最终呢

08:40.750 --> 08:43.750
把这个脚本语言呢叫做java script

08:43.750 --> 08:45.750
主要是为了推广

08:45.750 --> 08:47.750
其他跟java没有任何的关系

08:47.750 --> 08:48.750
没有一毛钱关系

08:48.750 --> 08:49.750
就有的时候

08:49.750 --> 08:51.750
很多同学都在问啊

08:51.750 --> 08:53.750
java语言和java script

08:53.750 --> 08:54.750
到底有什么区别

08:54.750 --> 08:56.750
有什么关系啊什么关系

08:56.750 --> 08:58.750
他们有什么关系呢

08:58.750 --> 08:59.750
就相当于是

08:59.750 --> 09:01.750
葡萄和葡萄牙的关系

09:02.750 --> 09:04.750
夫妻和夫妻妃妃的关系

09:04.750 --> 09:05.750
你自己去想呗

09:05.750 --> 09:06.750
没有任何关系啊

09:06.750 --> 09:07.750
一毛钱关系没有

09:07.750 --> 09:09.750
只是呢里边可能有一点点借鉴

09:09.750 --> 09:11.750
借鉴的更多的还是谁语言啊

09:11.750 --> 09:13.750
什么schema这种语言啊

09:13.750 --> 09:15.750
你看后面我们讲到什么借是原型

09:15.750 --> 09:17.750
就从这些语言里面借鉴的

09:17.750 --> 09:19.750
总之

09:19.750 --> 09:21.750
这里最终的把它改变成

09:21.750 --> 09:23.750
就是把它更名成了java script

09:23.750 --> 09:25.750
后来呢我记得在

09:25.750 --> 09:27.750
零零五年的时候啊

09:27.750 --> 09:29.750
就2005年的时候

09:29.750 --> 09:31.750
有一次java script开发大会

09:31.750 --> 09:33.750
十年的纪念大会

09:33.750 --> 09:36.750
当时呢Brandon H出席了这个大会

09:36.750 --> 09:39.750
那么在这个大会上呢他就说到啊

09:39.750 --> 09:41.750
以后呢大家在设计语言啊

09:41.750 --> 09:44.750
就是如果去设计明新的语言的时候

09:44.750 --> 09:47.750
千万千万不要把这个语言的命名

09:47.750 --> 09:49.750
交给商业公司

09:49.750 --> 09:52.750
不能出于商业的考虑去给这个语言命名

09:52.750 --> 09:54.750
导致了后边这个java script

09:54.750 --> 09:56.750
好像永远是java的附属品一样

09:56.750 --> 09:57.750
其实他们完全是独立的

09:57.750 --> 09:58.750
没有任何关系的

09:58.750 --> 10:00.750
但是跟人的感知一直是这样子

10:00.750 --> 10:01.750
就很不好

10:01.750 --> 10:03.750
好吧这是关于第一个java

10:03.750 --> 10:05.750
java介绍语言的起源

10:05.750 --> 10:07.750
起源是怎么来的

10:07.750 --> 10:09.750
当然呢我这里顺便说一下

10:09.750 --> 10:11.750
既然呢这个语言是

10:11.750 --> 10:13.750
十天内就开发出来的

10:13.750 --> 10:14.750
你想吧

10:14.750 --> 10:16.750
十天开发出来的语言

10:16.750 --> 10:19.750
它里边绝对有很多很多的问题

10:19.750 --> 10:21.750
哪怕它是一个大神

10:21.750 --> 10:23.750
十天就要开发一个新的语言出来

10:23.750 --> 10:25.750
肯定有非常非常多的问题

10:25.750 --> 10:27.750
那么这些问题

10:27.750 --> 10:30.750
后来后面呢根据就是有了不同的版本更新

10:30.750 --> 10:32.750
解决了很多问题了

10:32.750 --> 10:33.750
但是有一些问题呢

10:33.750 --> 10:35.750
依然是引流至今

10:35.750 --> 10:38.750
就是现在我们今天仍然可以看到过去

10:38.750 --> 10:40.750
java script 这个语言起源的时候

10:40.750 --> 10:41.750
引流到一些问题

10:41.750 --> 10:43.750
我们后面讲这个语言的时候

10:43.750 --> 10:44.750
大家就知道了

10:44.750 --> 10:45.750
有一些引流问题

10:45.750 --> 10:46.750
那么这些引流问题呢

10:46.750 --> 10:47.750
现在都不叫问题了

10:47.750 --> 10:49.750
以前的把它叫做问题叫做缺先

10:49.750 --> 10:51.750
你怎么这样去设计啊好怪啊

10:51.750 --> 10:53.750
但是呢现在的都不叫问题了

10:53.750 --> 10:54.750
把它叫做什么

10:54.750 --> 10:55.750
把它叫做特征

10:55.750 --> 10:56.750
特征啊

10:56.750 --> 10:58.750
把它叫做特征

10:58.750 --> 11:00.750
为什么现在改不过来了呢

11:00.750 --> 11:01.750
没法改了

11:01.750 --> 11:03.750
因为以前呢很多的开发者

11:03.750 --> 11:04.750
已经用这些特征啊

11:04.750 --> 11:06.750
就是利用这些缺先

11:06.750 --> 11:08.750
写了不少代码了

11:08.750 --> 11:09.750
那么你现在改回去了

11:09.750 --> 11:11.750
过去的代码又不能执行了

11:11.750 --> 11:12.750
所以说呢

11:12.750 --> 11:13.750
现在呢要去改它的

11:13.750 --> 11:14.750
已经很难了啊很难了

11:14.750 --> 11:15.750
我们只能把它当成

11:15.750 --> 11:17.750
java的语言的特征

11:17.750 --> 11:18.750
其实你看一下这个特征

11:18.750 --> 11:19.750
有的时候呢

11:19.750 --> 11:20.750
是双刃剑啊

11:20.750 --> 11:21.750
它不好

11:21.750 --> 11:23.750
其实它也会带来一些好的地方

11:23.750 --> 11:24.750
ok啊

11:24.750 --> 11:26.750
这里说一下

11:26.750 --> 11:27.750
因为这个语言

11:27.750 --> 11:28.750
为什么这么短的时间呢

11:28.750 --> 11:29.750
意思呢

11:29.750 --> 11:31.750
它本来就是打算把它做成一个

11:31.750 --> 11:33.750
非常非常简洁的语言

11:33.750 --> 11:34.750
容易上手的啊

11:34.750 --> 11:35.750
一开始的定位就是

11:35.750 --> 11:36.750
这个语言呢

11:36.750 --> 11:37.750
面向的人群

11:37.750 --> 11:39.750
是那些没有什么开发经验的人群

11:39.750 --> 11:40.750
它只会做网页

11:40.750 --> 11:41.750
做一个静态网页

11:41.750 --> 11:42.750
然后呢

11:42.750 --> 11:44.750
那个时候都还没有css

11:44.750 --> 11:45.750
css后面出来的

11:45.750 --> 11:47.750
只会做一个atmai网页

11:47.750 --> 11:48.750
然后呢

11:48.750 --> 11:49.750
就可以利用这个js

11:49.750 --> 11:50.750
在网页上写电东西

11:50.750 --> 11:51.750
写点交互效果

11:51.750 --> 11:53.750
当然以前的代码非常非常少啊

11:53.750 --> 11:55.750
最多就10多20

11:55.750 --> 11:56.750
30行左右

11:56.750 --> 11:57.750
就很简单的代码

11:57.750 --> 11:59.750
稍微写一下就完事了

11:59.750 --> 12:00.750
ok吧

12:00.750 --> 12:03.750
这是关于js语言的起源

12:03.750 --> 12:04.750
第一部分呢

12:04.750 --> 12:05.750
大家记住一个关键点啊

12:05.750 --> 12:07.750
记住一个关键点就是关于

12:07.750 --> 12:09.750
js语言之父

12:09.750 --> 12:11.750
语言之父

12:11.750 --> 12:12.750
是谁呢

12:12.750 --> 12:14.750
branding edge

12:14.750 --> 12:15.750
branding edge

12:15.750 --> 12:16.750
好以后呢

12:16.750 --> 12:17.750
我在markdown里边

12:17.750 --> 12:19.750
就这个记笔记工具里边

12:20.750 --> 12:22.750
加出了这个东西

12:22.750 --> 12:23.750
加出了这个两个新号

12:23.750 --> 12:24.750
前后两个新号

12:24.750 --> 12:25.750
表啥意思呢

12:25.750 --> 12:27.750
表示的意思啊就是

12:28.750 --> 12:30.750
这里是一个加出的

12:30.750 --> 12:31.750
加出的文字

12:31.750 --> 12:32.750
表示这是个重点啊

12:32.750 --> 12:33.750
大家需要

12:33.750 --> 12:34.750
需要掌握的知识

12:34.750 --> 12:35.750
ok啊

12:35.750 --> 12:38.750
这是关于这一块啊

12:38.750 --> 12:40.750
js语言的解释

12:40.750 --> 12:42.750
起源这一块

12:42.750 --> 12:43.750
第二部分呢

12:43.750 --> 12:46.750
是关于第一次浏览器大战

12:46.750 --> 12:48.750
说一下第二部分

12:48.750 --> 12:50.750
也设计到一些关键点

12:50.750 --> 12:52.750
这是什么东西呢

12:52.750 --> 12:54.750
是王静这个公司啊

12:54.750 --> 12:57.750
他在1994年推出了浏览器之后呢

12:57.750 --> 12:59.750
很快就占领市场了

12:59.750 --> 13:00.750
占领市场过后呢

13:00.750 --> 13:01.750
他有了这么一个动作

13:01.750 --> 13:04.750
他想了在这个浏览器里边

13:04.750 --> 13:06.750
去加入一个操作系统

13:06.750 --> 13:08.750
叫做网络操作系统

13:08.750 --> 13:10.750
就是王静公司

13:10.750 --> 13:14.750
公司打算在浏览器中

13:14.750 --> 13:16.750
加入网络操作系统

13:16.750 --> 13:18.750
你看真敢想啊

13:18.750 --> 13:19.750
真敢想

13:19.750 --> 13:21.750
那个时候网速这么慢

13:21.750 --> 13:22.750
他就敢去想这件事

13:22.750 --> 13:24.750
其实很多的概念啊

13:24.750 --> 13:25.750
咱们软件开发领域

13:25.750 --> 13:28.750
很多的概念都不是最新的

13:28.750 --> 13:29.750
不是刚刚出来了

13:29.750 --> 13:31.750
都是好久好久以前

13:31.750 --> 13:33.750
别人写的论文啊

13:33.750 --> 13:34.750
一些比如说博士论文啊

13:34.750 --> 13:36.750
或者是一些研究所的

13:36.750 --> 13:38.750
一些论文资料啊

13:38.750 --> 13:39.750
其实就已经有设计了啊

13:39.750 --> 13:40.750
包括一些公司呢

13:40.750 --> 13:42.750
已经提出来了

13:42.750 --> 13:45.750
像这个浏览器中加入操作系统

13:45.750 --> 13:47.750
目前都还没有实现

13:47.750 --> 13:48.750
以前谷歌搞过

13:48.750 --> 13:49.750
我记得我在读大学的时候

13:49.750 --> 13:51.750
08年的时候啊记得

13:51.750 --> 13:52.750
谷歌他想搞这个东西

13:52.750 --> 13:53.750
后来了失败了啊

13:53.750 --> 13:54.750
当然这个失败了

13:54.750 --> 13:56.750
也不是完全失败

13:56.750 --> 13:58.750
他记得了很多的技术和经验

13:58.750 --> 13:59.750
将来肯定有用处

13:59.750 --> 14:01.750
将来这个一定会实现的

14:01.750 --> 14:02.750
你想啊

14:02.750 --> 14:03.750
20多年前

14:03.750 --> 14:05.750
王静就还开始打这个注意了

14:05.750 --> 14:08.750
那么这个会影响到谁的利益啊

14:08.750 --> 14:10.750
是不是会触犯

14:10.750 --> 14:12.750
你不能叫触犯啊

14:12.750 --> 14:14.750
会影响到了

14:14.750 --> 14:17.750
啊到微软的利益

14:17.750 --> 14:19.750
啊

14:19.750 --> 14:20.750
所以说呢

14:20.750 --> 14:23.750
引起了啊微软的注意

14:23.750 --> 14:24.750
就微软发现这个问题了

14:24.750 --> 14:25.750
因为微软

14:25.750 --> 14:26.750
他是做操作系统的

14:26.750 --> 14:27.750
对吧

14:27.750 --> 14:28.750
咱们用的文静式操作系统

14:28.750 --> 14:29.750
全是微软的

14:29.750 --> 14:30.750
基本上是在

14:30.750 --> 14:31.750
涵盖了整个市场

14:31.750 --> 14:33.750
90%以上的就是

14:33.750 --> 14:35.750
个人电脑的操作系统

14:35.750 --> 14:36.750
所以说微软的

14:36.750 --> 14:38.750
他肯定不愿意去啊

14:38.750 --> 14:40.750
有任何的潜在竞争者

14:40.750 --> 14:42.750
像我们这像自己这块蛋糕

14:42.750 --> 14:43.750
就是发起挑战

14:43.750 --> 14:44.750
他是不允许的

14:44.750 --> 14:46.750
于是呢微软了这个时候呢

14:46.750 --> 14:50.750
他就去跟这个网警公司谈啊

14:50.750 --> 14:52.750
首先谈了一下

14:52.750 --> 14:53.750
谈一下没谈通

14:53.750 --> 14:54.750
没谈通

14:54.750 --> 14:55.750
于是呢他发布了

14:55.750 --> 14:56.750
第一款自己的浏览器

14:56.750 --> 14:57.750
就是IE浏览器

14:57.750 --> 14:58.750
微软发布

14:58.750 --> 15:00.750
也是在1995年

15:00.750 --> 15:02.750
1995年

15:02.750 --> 15:05.750
微软发布IE浏览器

15:05.750 --> 15:07.750
发布IE浏览器

15:07.750 --> 15:09.750
IE浏览器大家都知道对吧

15:09.750 --> 15:10.750
顶进大名的

15:10.750 --> 15:11.750
跟操作系统绑在一块的

15:11.750 --> 15:13.750
当时呢还不是跟操作系统绑在一块的

15:13.750 --> 15:15.750
当时需要独立安装的

15:15.750 --> 15:17.750
这种软件的东西啊

15:17.750 --> 15:19.750
不是你说绑定就能绑定的

15:19.750 --> 15:21.750
因为他涉及到一些法律的问题

15:21.750 --> 15:24.750
当时呢你要安装完操作系统

15:24.750 --> 15:26.750
再去安装这个浏览器

15:26.750 --> 15:28.750
所以说当时不是绑定的

15:28.750 --> 15:29.750
于是呢他发布了

15:29.750 --> 15:30.750
第一款IE浏览器

15:30.750 --> 15:31.750
因此呢就宣告了

15:31.750 --> 15:33.750
第一次浏览器大战的开始

15:33.750 --> 15:35.750
就两家开始竞争

15:35.750 --> 15:37.750
对吧以前我在ATM和CSS课程的时候

15:37.750 --> 15:39.750
你简单的说了一下

15:39.750 --> 15:41.750
就两家公司呢开始竞争

15:41.750 --> 15:43.750
竞争到最激烈的是什么程度呢

15:43.750 --> 15:45.750
就是大家都要不断的出新东西

15:45.750 --> 15:47.750
不断的去吸引用户

15:47.750 --> 15:49.750
最激烈的时候

15:49.750 --> 15:51.750
就是一周一个新版本

15:51.750 --> 15:52.750
一周一个新版本

15:52.750 --> 15:53.750
李德版本过来了

15:53.750 --> 15:55.750
李又新的东西马上超过来

15:55.750 --> 15:57.750
超过来过后我又加了一些新东西

15:57.750 --> 15:58.750
然后我又去

15:58.750 --> 16:00.750
超里的我又加一些新东西

16:00.750 --> 16:02.750
基本上就这种反复的混账

16:03.750 --> 16:05.750
那么在这个GS语言推出过后

16:05.750 --> 16:07.750
当时微软发布IE浏览器的时候

16:07.750 --> 16:08.750
还没有GS

16:08.750 --> 16:09.750
GS都还没有推出

16:09.750 --> 16:11.750
后来GS推出来之后

16:11.750 --> 16:13.750
GS语言推出来之后

16:13.750 --> 16:15.750
一下子王锦

16:15.750 --> 16:17.750
获得了巨大的竞争优势

16:17.750 --> 16:19.750
GS语言

16:19.750 --> 16:21.750
推出之后

16:21.750 --> 16:22.750
之后

16:22.750 --> 16:23.750
王锦

16:23.750 --> 16:25.750
获得

16:25.750 --> 16:28.750
极大的竞争优势

16:28.750 --> 16:29.750
你想啊

16:29.750 --> 16:31.750
这个改变是非常非常巨大的

16:31.750 --> 16:33.750
以前只能写镜台一面

16:33.750 --> 16:35.750
你玩的话你只能玩什么样子

16:35.750 --> 16:37.750
当然那个时候还没有样子

16:37.750 --> 16:38.750
只能玩什么一天元素对吧

16:38.750 --> 16:40.750
那个有什么好玩的

16:40.750 --> 16:41.750
玩大玩戏就这么回事

16:41.750 --> 16:43.750
但是一旦出了GS语言

16:43.750 --> 16:45.750
天翻地覆的变化

16:45.750 --> 16:47.750
哪怕当时GS语言非常非常简单

16:47.750 --> 16:49.750
也有很多问题

16:49.750 --> 16:50.750
但是一切都不一样了

16:50.750 --> 16:52.750
因为我可以在网页里面

16:52.750 --> 16:53.750
做一些效果了

16:53.750 --> 16:54.750
做一些动画了

16:54.750 --> 16:55.750
那微软怎么受得了吗

16:55.750 --> 16:56.750
肯定受不了

16:56.750 --> 16:57.750
那这个时候呢

16:57.750 --> 16:58.750
微软这个时候慌了

16:58.750 --> 17:01.750
他又去找这个王锦公司台

17:01.750 --> 17:03.750
这个这一次直接谈收购了

17:03.750 --> 17:04.750
就是我直接把你收购了

17:04.750 --> 17:05.750
买了得了

17:05.750 --> 17:07.750
你全部整个团团直接过来

17:07.750 --> 17:11.750
但是当时的王锦的野心非常大

17:11.750 --> 17:12.750
他肯定是不愿意

17:12.750 --> 17:14.750
不愿意的被微软公司收购的

17:14.750 --> 17:15.750
于是谈崩了

17:15.750 --> 17:17.750
这个时候微软回去

17:17.750 --> 17:19.750
一路之下做了一件事

17:19.750 --> 17:22.750
对整个GS语言进行反变役

17:22.750 --> 17:26.750
微软对GS语言反变役

17:26.750 --> 17:27.750
什么叫反变役呢

17:27.750 --> 17:29.750
就是你可以这样理解

17:29.750 --> 17:32.750
就是把那个语言整个代码

17:32.750 --> 17:33.750
他一开始不是开源的

17:33.750 --> 17:35.750
GS语言不是开源的

17:35.750 --> 17:36.750
他整个代码

17:36.750 --> 17:38.750
他怎么写的这个代码

17:38.750 --> 17:41.750
全部拿到进行反变役

17:41.750 --> 17:42.750
变役的话就是什么意思呢

17:42.750 --> 17:44.750
变役的话就是指的是

17:44.750 --> 17:45.750
把你写的代码

17:45.750 --> 17:47.750
翻译成另外一个机器

17:47.750 --> 17:49.750
可以识别的状态叫做变役

17:49.750 --> 17:50.750
叫做变役

17:50.750 --> 17:51.750
什么叫反变役呢

17:51.750 --> 17:55.750
就是把你最终翻译过来的代码

17:55.750 --> 17:57.750
又还原成之前的代码

17:57.750 --> 17:59.750
你可以这样理解

17:59.750 --> 18:01.750
变役是什么呢

18:01.750 --> 18:04.750
就好必说你拿一本英文书

18:04.750 --> 18:07.750
把这个英文书翻译成一本中文书

18:07.750 --> 18:08.750
这叫变役

18:08.750 --> 18:09.750
怎么叫反变役呢

18:09.750 --> 18:10.750
你把这个中文书

18:10.750 --> 18:11.750
又翻译回英文书

18:11.750 --> 18:12.750
叫反变役

18:12.750 --> 18:13.750
当然反变役过后

18:13.750 --> 18:14.750
跟原来的代码

18:14.750 --> 18:15.750
跟原来的语言文

18:15.750 --> 18:16.750
肯定是有点差异的

18:16.750 --> 18:17.750
有点差异的

18:17.750 --> 18:18.750
不过反变役过后

18:18.750 --> 18:19.750
微软基本上就搞清楚了

18:19.750 --> 18:21.750
这个语言是怎么实现的

18:21.750 --> 18:22.750
这个语言

18:22.750 --> 18:23.750
它到底是怎么回事

18:23.750 --> 18:24.750
基本上搞清楚了

18:24.750 --> 18:25.750
于是呢

18:25.750 --> 18:28.750
它微软就借鉴

18:29.750 --> 18:31.750
说的好听一点是借鉴

18:31.750 --> 18:32.750
说的不好听一点

18:32.750 --> 18:34.750
就是基本上是照抄

18:34.750 --> 18:37.750
借鉴借识语言

18:37.750 --> 18:41.750
推出了G script

18:41.750 --> 18:44.750
然后又推出了一个VB script

18:44.750 --> 18:46.750
它会推出两个版本

18:46.750 --> 18:47.750
两个语言

18:47.750 --> 18:48.750
一个是G script

18:48.750 --> 18:49.750
一个是VB script

18:49.750 --> 18:50.750
G script

18:50.750 --> 18:51.750
就基本上跟Java script

18:51.750 --> 18:52.750
很像是

18:52.750 --> 18:54.750
基本上是一样的

18:54.750 --> 18:55.750
VB script

18:55.750 --> 18:57.750
是为了照顾当时的

18:57.750 --> 18:59.750
微软的很多开发者

18:59.750 --> 19:00.750
因为当时微软的

19:00.750 --> 19:01.750
主流的开发语言

19:01.750 --> 19:02.750
是VB嘛

19:02.750 --> 19:03.750
VB

19:03.750 --> 19:04.750
所以说

19:04.750 --> 19:05.750
为了照顾一些VB的程序言

19:05.750 --> 19:06.750
能够快速的

19:06.750 --> 19:08.750
转入到网页的开发

19:08.750 --> 19:09.750
它又出现了这个语言

19:09.750 --> 19:10.750
这两个语言

19:10.750 --> 19:11.750
都可以在

19:11.750 --> 19:13.750
IE扭烂期里边执行

19:13.750 --> 19:14.750
都可以在

19:14.750 --> 19:15.750
IE扭烂期里边执行

19:15.750 --> 19:16.750
这两个语言

19:16.750 --> 19:17.750
包括现在

19:17.750 --> 19:19.750
在IE扭烂期里边

19:19.750 --> 19:20.750
也可以执行这个玩意

19:20.750 --> 19:22.750
VB script

19:22.750 --> 19:23.750
也可以执行的

19:23.750 --> 19:24.750
这里说一下

19:26.750 --> 19:27.750
除了说现在微软很痛苦

19:27.750 --> 19:28.750
它没法升级而已了

19:28.750 --> 19:29.750
因为有很多

19:29.750 --> 19:30.750
历史遗留问题

19:30.750 --> 19:31.750
有历史遗留问题

19:31.750 --> 19:32.750
很难升级的

19:32.750 --> 19:33.750
于是它发布了

19:33.750 --> 19:34.750
新的扭烂期A级

19:35.750 --> 19:36.750
好

19:36.750 --> 19:38.750
推出了这两个语言

19:38.750 --> 19:39.750
于是呢

19:39.750 --> 19:41.750
又跟介石形成竞争

19:41.750 --> 19:42.750
形成竞争

19:42.750 --> 19:43.750
这是一次竞争的是什么呢

19:43.750 --> 19:45.750
第一次

19:45.750 --> 19:48.750
扭烂期大战

19:48.750 --> 19:49.750
是

19:49.750 --> 19:51.750
标准之争

19:51.750 --> 19:52.750
就是按照

19:52.750 --> 19:53.750
谁的标准来

19:53.750 --> 19:55.750
ATM and CSS

19:55.750 --> 19:56.750
按照谁的扭烂期来

19:56.750 --> 19:57.750
GS这一块

19:57.750 --> 19:59.750
又按照谁的扭烂期标准来

19:59.750 --> 20:00.750
标准之争

20:00.750 --> 20:01.750
那段时间的程序

20:01.750 --> 20:03.750
从天堂一下跌落到地域

20:03.750 --> 20:05.750
非常非常痛苦

20:05.750 --> 20:06.750
为啥呢

20:06.750 --> 20:07.750
这两个扭烂期

20:07.750 --> 20:09.750
可以说当时

20:10.750 --> 20:11.750
不相上下

20:11.750 --> 20:13.750
歌有自己的市场竞争份额

20:13.750 --> 20:15.750
因此你开发网页的话

20:15.750 --> 20:16.750
不能说

20:16.750 --> 20:17.750
我只考虑王继扭烂期

20:17.750 --> 20:18.750
或者说

20:18.750 --> 20:19.750
我只考虑IE扭烂期

20:19.750 --> 20:20.750
不行

20:20.750 --> 20:22.750
你必须要两个扭烂期都要考虑

20:22.750 --> 20:23.750
那问题来了

20:23.750 --> 20:24.750
啥一个语言

20:24.750 --> 20:25.750
你要疯

20:25.750 --> 20:26.750
真的你要疯

20:26.750 --> 20:27.750
你王继扭烂期

20:27.750 --> 20:28.750
在用GS语言写

20:28.750 --> 20:30.750
GS语言写代吗

20:30.750 --> 20:33.750
那个微软的IE扭烂期

20:33.750 --> 20:34.750
你在用GScript

20:34.750 --> 20:36.750
或者是vbscript

20:36.750 --> 20:37.750
用这个东西写代

20:37.750 --> 20:39.750
所以当时的程序

20:39.750 --> 20:41.750
开发者非常非常痛苦

20:41.750 --> 20:42.750
就是因为没有标准

20:42.750 --> 20:43.750
就是个语言

20:43.750 --> 20:44.750
他到底应该怎么来写

20:44.750 --> 20:45.750
才是正确的

20:45.750 --> 20:46.750
大家都统一来

20:46.750 --> 20:47.750
没有标准

20:47.750 --> 20:49.750
于是呢

20:50.750 --> 20:51.750
于是呢

20:51.750 --> 20:52.750
这个问题一定要得到解决

20:52.750 --> 20:54.750
接下来就出了这么一个事

20:54.750 --> 20:55.750
什么事呢

20:55.750 --> 20:57.750
是在1997年

20:57.750 --> 20:59.750
香港回归这一年

20:59.750 --> 21:01.750
网警公司

21:01.750 --> 21:03.750
当时的他的javascript版本

21:03.750 --> 21:05.750
介绍的版本是1.1

21:05.750 --> 21:07.750
javascript

21:07.750 --> 21:09.750
1.1这个版本

21:09.750 --> 21:11.750
提交给

21:11.750 --> 21:13.750
一个欧洲的一个

21:13.750 --> 21:14.750
非引力性组织

21:14.750 --> 21:15.750
叫ACMA

21:15.750 --> 21:17.750
叫做欧洲

21:17.750 --> 21:18.750
欧洲

21:18.750 --> 21:21.750
计算机协会

21:21.750 --> 21:24.750
应该是欧洲计算机制造协会

21:24.750 --> 21:26.750
制造协会

21:26.750 --> 21:28.750
叫做ACMA这个组织

21:28.750 --> 21:30.750
实在欧洲的不是美国

21:30.750 --> 21:31.750
然后呢

21:31.750 --> 21:33.750
他希望这个协会呢

21:33.750 --> 21:34.750
把他采纳成为标准

21:34.750 --> 21:35.750
把这个javascript

21:35.750 --> 21:36.750
1.1这个版本

21:36.750 --> 21:37.750
采纳成为标准

21:37.750 --> 21:38.750
这件事呢

21:38.750 --> 21:39.750
在当时

21:39.750 --> 21:41.750
并没有引起什么样的注意

21:41.750 --> 21:43.750
甚至在新闻报道上

21:43.750 --> 21:44.750
版面都非常非常少

21:44.750 --> 21:45.750
就做了这么一件事

21:45.750 --> 21:46.750
但是这件事

21:46.750 --> 21:47.750
埋下了一个种子

21:47.750 --> 21:49.750
会对后边的

21:49.750 --> 21:50.750
javascript的发展造成

21:50.750 --> 21:51.750
深远的影响

21:51.750 --> 21:52.750
但是现在的

21:52.750 --> 21:53.750
当时来说

21:53.750 --> 21:54.750
当时来说

21:54.750 --> 21:55.750
没有引起太大的注意

21:55.750 --> 21:56.750
因为当时呢

21:56.750 --> 21:57.750
他们两家公司

21:57.750 --> 21:58.750
微软和网景

21:58.750 --> 22:00.750
处于激烈的竞争

22:00.750 --> 22:01.750
竞争的环境

22:01.750 --> 22:02.750
所以说呢

22:02.750 --> 22:03.750
他们也没有办法

22:03.750 --> 22:04.750
去适应这个标准

22:04.750 --> 22:05.750
标准太慢了

22:05.750 --> 22:06.750
因为我们知道

22:06.750 --> 22:07.750
标准组织里边

22:07.750 --> 22:09.750
很多的工作人员

22:09.750 --> 22:10.750
都不是全职的

22:10.750 --> 22:11.750
都是坚职的

22:11.750 --> 22:12.750
他们在别的公司上班

22:12.750 --> 22:14.750
然后坚职

22:14.750 --> 22:17.750
来在标准里边开个会

22:17.750 --> 22:18.750
审议一下

22:18.750 --> 22:19.750
怎么去制作标准

22:19.750 --> 22:20.750
非常非常慢

22:20.750 --> 22:21.750
他们的进度非常非常慢

22:21.750 --> 22:22.750
没有那么多时间

22:22.750 --> 22:23.750
因为他们本身

22:23.750 --> 22:25.750
也不是商业组织

22:25.750 --> 22:26.750
没有多少钱的

22:26.750 --> 22:27.750
所以说呢

22:27.750 --> 22:28.750
他们制定标准的

22:28.750 --> 22:29.750
速度很慢

22:29.750 --> 22:30.750
而当时又处于激烈的

22:30.750 --> 22:31.750
竞争环境下边

22:31.750 --> 22:32.750
我们说过

22:32.750 --> 22:33.750
一周最快

22:33.750 --> 22:34.750
竞争最激烈的时候

22:34.750 --> 22:36.750
一直都要出一个新版本

22:36.750 --> 22:37.750
哪等到标准

22:37.750 --> 22:39.750
标准的至少至少

22:39.750 --> 22:40.750
注意理想的状况

22:40.750 --> 22:42.750
就是现在这个状况

22:42.750 --> 22:43.750
就是我们现在这个状况

22:43.750 --> 22:45.750
都是一年发布一个

22:45.750 --> 22:47.750
就是起草一个标准

22:47.750 --> 22:48.750
还不是发布

22:48.750 --> 22:49.750
只是起草

22:49.750 --> 22:50.750
起草一个标准

22:50.750 --> 22:51.750
当时就是好几年

22:51.750 --> 22:53.750
才完成一个标准的制定

22:53.750 --> 22:54.750
那能等吗

22:54.750 --> 22:55.750
肯定等不了

22:55.750 --> 22:56.750
所以说要不断的去

22:56.750 --> 22:57.750
加入新特性

22:57.750 --> 22:58.750
因此呢

22:58.750 --> 22:59.750
当时的王靖公司

22:59.750 --> 23:01.750
只是留了一个种子

23:01.750 --> 23:02.750
放到就是

23:02.750 --> 23:04.750
把它提交给ECMA这个组织

23:04.750 --> 23:05.750
对于之后

23:05.750 --> 23:06.750
会造成什么影响

23:06.750 --> 23:08.750
他们也无法预计

23:08.750 --> 23:09.750
当时呢

23:09.750 --> 23:11.750
做了这么一件小事

23:11.750 --> 23:12.750
不过这件小事

23:12.750 --> 23:14.750
对以后影响就可大了

23:14.750 --> 23:15.750
非常非常大了

23:15.750 --> 23:17.750
当时没有什么

23:17.750 --> 23:18.750
喧起什么样的波澜

23:18.750 --> 23:19.750
他们继续竞争

23:19.750 --> 23:20.750
后来呢

23:20.750 --> 23:21.750
就是大家都知道了

23:21.750 --> 23:23.750
结果是咋了

23:23.750 --> 23:24.750
IE3发布

23:24.750 --> 23:26.750
IE3发布

23:26.750 --> 23:28.750
并并绑定

23:28.750 --> 23:30.750
Windows操作系统

23:30.750 --> 23:32.750
就微软使用杀手键了

23:32.750 --> 23:34.750
这有点像什么

23:34.750 --> 23:35.750
像腾讯对吧

23:35.750 --> 23:36.750
腾讯游戏里边

23:36.750 --> 23:38.750
跟QQ一结合

23:38.750 --> 23:40.750
这就是杀手键

23:40.750 --> 23:41.750
IE3发布过后

23:41.750 --> 23:42.750
直接绑立到Windows操作系统

23:42.750 --> 23:43.750
也就是说

23:43.750 --> 23:44.750
用户安装好操作系统过后

23:44.750 --> 23:46.750
就直接有IE浏览器了

23:46.750 --> 23:48.750
包括我们到现在看到都是

23:48.750 --> 23:49.750
安装完操作系统

23:49.750 --> 23:50.750
就直接有浏览器了

23:50.750 --> 23:52.750
这样一击对

23:52.750 --> 23:54.750
网景公司是致命打击

23:54.750 --> 23:56.750
因为当时Windows的操作系统

23:56.750 --> 23:59.750
它的市场份额非常非常大

23:59.750 --> 24:00.750
但是你要说

24:00.750 --> 24:02.750
IE浏览器和网景公司的浏览器

24:02.750 --> 24:04.750
哪家更好了

24:04.750 --> 24:05.750
又不相上下

24:05.750 --> 24:06.750
各有各的优势

24:06.750 --> 24:07.750
各有各的好处

24:07.750 --> 24:09.750
所以当对于用户而言

24:09.750 --> 24:10.750
我就没有那么麻烦了

24:10.750 --> 24:11.750
安装完操作系统过后

24:11.750 --> 24:13.750
我也没有必要去安装

24:13.750 --> 24:15.750
一个网景浏览器了

24:15.750 --> 24:17.750
因为当时安装软件还是蛮麻烦的

24:17.750 --> 24:19.750
你要去买一个磁盘

24:19.750 --> 24:21.750
叫3.5英寸磁盘

24:21.750 --> 24:23.750
还不是现在的光盘

24:23.750 --> 24:24.750
光盘现在都没有了

24:24.750 --> 24:25.750
都直接是用网络下载的

24:25.750 --> 24:26.750
比较现在的笔记本

24:26.750 --> 24:27.750
哪有什么光盘的

24:27.750 --> 24:28.750
都没有了

24:28.750 --> 24:30.750
但是以前的光盘都没有

24:30.750 --> 24:33.750
都只是3.5英寸磁盘

24:34.750 --> 24:36.750
安装软件是非常非常麻烦的

24:36.750 --> 24:37.750
所以说

24:37.750 --> 24:38.750
当我安装完操作系统过后

24:38.750 --> 24:39.750
诶 浏览器就自带了

24:39.750 --> 24:41.750
我干嘛还要去安装别的浏览器了

24:41.750 --> 24:43.750
所以说这件事情过后

24:43.750 --> 24:45.750
网警公司的市场份额

24:45.750 --> 24:47.750
就不断的下滑

24:47.750 --> 24:48.750
除了一些

24:48.750 --> 24:49.750
到了后来

24:49.750 --> 24:50.750
只有一些忠实的拥护者

24:50.750 --> 24:52.750
在使用网警的浏览器

24:52.750 --> 24:53.750
到后边基本上是

24:53.750 --> 24:55.750
难以维持的这公司

24:55.750 --> 24:56.750
于是1998年

24:56.750 --> 24:58.750
公司宣布破产

24:58.750 --> 25:00.750
1998年

25:00.750 --> 25:02.750
网警公司破产

25:03.750 --> 25:05.750
被收购

25:06.750 --> 25:09.750
那么之前的浏览器开发团队

25:09.750 --> 25:11.750
就是以Brandon H

25:11.750 --> 25:13.750
就是接受的创始人开发的团队

25:13.750 --> 25:15.750
就直接解散了

25:15.750 --> 25:16.750
留了一些

25:16.750 --> 25:18.750
留了一些这些的无关警要

25:18.750 --> 25:19.750
都不说了

25:19.750 --> 25:21.750
这是第一次浏览器大战

25:21.750 --> 25:23.750
以谁胜利高中呢

25:23.750 --> 25:25.750
以微软的胜利高中

25:25.750 --> 25:26.750
当然微软这个胜利

25:26.750 --> 25:27.750
也很惨痛

25:27.750 --> 25:29.750
因为他又陷入了

25:29.750 --> 25:32.750
长达7年的反垄断竞争法

25:32.750 --> 25:34.750
因为他这样一个行为

25:34.750 --> 25:35.750
是垄断行为对吧

25:35.750 --> 25:37.750
后来还赔了很多很多的钱

25:37.750 --> 25:39.750
这是后话了

25:39.750 --> 25:41.750
第一次浏览器大战

25:41.750 --> 25:43.750
我们要记住一个关键点

25:43.750 --> 25:45.750
就是1997年

25:45.750 --> 25:47.750
标准正式被提出

25:47.750 --> 25:49.750
所以第一次浏览器大战

25:49.750 --> 25:51.750
一件无关警要的事

25:51.750 --> 25:53.750
反而会对后世产生

25:53.750 --> 25:55.750
深远的影响

25:55.750 --> 25:59.130
就是重要的一件事

25:59.130 --> 26:00.130
重要的一件事

26:00.130 --> 26:02.130
就是Akma

26:02.130 --> 26:04.130
Akma

26:05.130 --> 26:06.130
收录了

26:06.130 --> 26:08.130
收录了JavaScript

26:10.130 --> 26:12.130
并提交给

26:12.130 --> 26:14.130
ISO

26:14.130 --> 26:16.130
国际标准组织

26:16.130 --> 26:18.130
这就是鼎鼎有名的国际标准组织

26:18.130 --> 26:20.130
并提交给ISO

26:20.130 --> 26:23.130
ISO也收录了JavaScript的语言标准

26:23.130 --> 26:25.130
并且经过修改

26:27.130 --> 26:28.130
成为了

26:28.130 --> 26:30.130
第一个

26:30.130 --> 26:32.130
解释的标准版本

26:32.130 --> 26:33.130
标准版本

26:33.130 --> 26:35.130
名称为

26:35.130 --> 26:37.130
Akma

26:37.130 --> 26:39.130
AkmaScript

26:39.130 --> 26:41.130
简称

26:41.130 --> 26:43.130
IS

26:43.130 --> 26:44.130
这就提出一个概念了

26:44.130 --> 26:45.130
我们都是说

26:45.130 --> 26:47.130
一会说GS

26:47.130 --> 26:48.130
一会说ES

26:48.130 --> 26:49.130
ES是啥

26:49.130 --> 26:51.130
ES就来自于AkmaScript

26:51.130 --> 26:52.130
它的标准组织

26:52.130 --> 26:54.130
制定了语言标准

26:54.130 --> 26:55.130
而JavaScript

26:55.130 --> 26:57.130
是属于网警公司的

26:57.130 --> 26:59.130
ES是属于标准组织的

26:59.130 --> 27:01.130
而Akma标准组织的

27:01.130 --> 27:03.130
属于的是Akma标准组织

27:03.130 --> 27:04.130
这是他们的区别

27:04.130 --> 27:06.130
实际上到现在为止

27:06.130 --> 27:08.130
我们经常说GS

27:08.130 --> 27:10.130
ES已经没有什么区别了

27:10.130 --> 27:11.130
已经没有什么区别了

27:11.130 --> 27:13.130
现在我们交的GS

27:13.130 --> 27:15.130
跟ES都是一个意思

27:15.130 --> 27:16.130
都是一个意思的

27:16.130 --> 27:18.130
因为现在GS和ES

27:18.130 --> 27:20.130
本来就不是说

27:20.130 --> 27:21.130
各自为战的

27:21.130 --> 27:22.130
因为网警公司已经不存在了

27:22.130 --> 27:23.130
已经不存在了

27:23.130 --> 27:24.130
说的都是标准

27:24.130 --> 27:25.130
说的都是标准

27:25.130 --> 27:26.130
ES

27:26.130 --> 27:28.130
这是关于第一次浏览其他战

27:29.130 --> 27:31.130
第二次浏览其他战

27:31.130 --> 27:32.130
大家记住一个点

27:32.130 --> 27:34.130
就是关于ES是怎么来的

27:34.130 --> 27:36.130
ES是一个简称

27:36.130 --> 27:37.130
它叫做AkmaScript

27:37.130 --> 27:39.130
目前我们说GS

27:39.130 --> 27:41.130
其实说的意思就是ES

27:42.130 --> 27:44.130
后面还有一些

27:44.130 --> 27:45.130
细微的区别

27:45.130 --> 27:46.130
我再详细说

27:48.130 --> 27:49.130
第三点

27:49.130 --> 27:50.130
第三个阶段

27:50.130 --> 27:52.130
就是第二次浏览其大战

27:52.130 --> 27:57.100
第一次浏览其大战

27:57.100 --> 27:59.100
结束之后

27:59.100 --> 28:00.100
微软基本上

28:00.100 --> 28:02.100
就处于农端地位了

28:02.100 --> 28:04.100
它又相继推出了

28:04.100 --> 28:05.100
IE6

28:05.100 --> 28:06.100
IE4

28:06.100 --> 28:08.100
然后又推出了IE5

28:08.100 --> 28:10.100
又推出了IE6

28:10.100 --> 28:12.100
IE6是捆绑到哪个操作系统

28:12.100 --> 28:14.100
是捆绑到Windows XP操作系统

28:15.100 --> 28:16.100
这个操作系统

28:16.100 --> 28:17.100
应该很多同学都知道

28:17.100 --> 28:18.100
应该很多同学都知道

28:18.100 --> 28:20.100
它捆绑到这个操作系统

28:20.100 --> 28:21.100
IE6

28:21.100 --> 28:22.100
到了IE6过后

28:22.100 --> 28:24.100
就是整个浏览其

28:24.100 --> 28:25.100
微软自认为

28:25.100 --> 28:26.100
确实也是这样子

28:26.100 --> 28:27.100
微软自认为

28:27.100 --> 28:29.100
这个浏览器

28:29.100 --> 28:30.100
已经做到头了

28:30.100 --> 28:32.100
已经没有任何开发的必要了

28:32.100 --> 28:33.100
因为IE6

28:33.100 --> 28:35.100
确实是一个跨时代的版本

28:35.100 --> 28:36.100
IE3也是

28:36.100 --> 28:38.100
IE3其实做得非常非常好

28:38.100 --> 28:39.100
然后到了IE6过后

28:39.100 --> 28:41.100
又来到一次极大的提升

28:41.100 --> 28:43.100
因为当时已经处于农端地位了

28:43.100 --> 28:44.100
所以慢慢的

28:44.100 --> 28:46.100
它的更新速度就慢慢缓下来了

28:46.100 --> 28:47.100
IE6我记得用了

28:47.100 --> 28:49.100
好多年好多年都没有更新

28:49.100 --> 28:51.100
因为当时微软觉得

28:51.100 --> 28:54.100
浏览器已经没有开发的必要了

28:54.100 --> 28:56.100
以后也不会有谁

28:56.100 --> 28:58.100
挑战微软的浏览器地位了

28:58.100 --> 29:01.100
所以说他做了一件非常让人

29:01.100 --> 29:04.100
现在想来非常匪夷所思的事情就是

29:04.100 --> 29:06.100
微软决定

29:06.100 --> 29:09.100
解散浏览器团队

29:09.100 --> 29:12.100
我现在想起来真真的是不可思议

29:12.100 --> 29:14.100
他居然干了这样的事

29:14.100 --> 29:16.100
因为当时这个团队很庞大

29:16.100 --> 29:17.100
不是说几个人

29:17.100 --> 29:18.100
自己是个几百号人

29:18.100 --> 29:20.100
团队很庞大

29:20.100 --> 29:21.100
占了很多成本

29:21.100 --> 29:22.100
但是微软同时又觉得

29:22.100 --> 29:23.100
这个浏览器

29:23.100 --> 29:25.100
确实没有什么开发的必要了

29:25.100 --> 29:26.100
已经垄断地位了

29:26.100 --> 29:29.100
所以他解散了整个浏览器团队

29:29.100 --> 29:31.100
这是微软这一边

29:31.100 --> 29:32.100
然后另外一边

29:32.100 --> 29:34.100
我们要说到这个人了

29:34.100 --> 29:39.100
Brandon H

29:39.100 --> 29:42.100
这个人他在网警公司

29:42.100 --> 29:44.100
被收购之后

29:44.100 --> 29:45.100
被解散之后

29:45.100 --> 29:47.100
他带领一帮人

29:47.100 --> 29:50.100
成立了这么一个组织

29:50.100 --> 29:54.100
成立带领团队

29:54.100 --> 29:55.100
成立了什么呢

29:55.100 --> 29:57.100
承认了就顶顶大名的

29:57.100 --> 30:02.100
Mosella基金会

30:02.100 --> 30:03.100
成立了这个组织

30:03.100 --> 30:06.100
在这个组织里面并决定

30:06.100 --> 30:11.100
将Navicate

30:11.100 --> 30:13.100
就是网警浏览器

30:13.100 --> 30:16.100
网警浏览器开源

30:16.100 --> 30:17.100
之前的网警公司

30:17.100 --> 30:19.100
不是出品了网警浏览器吗

30:19.100 --> 30:20.100
公司都没了

30:20.100 --> 30:21.100
这个浏览器没什么用了

30:21.100 --> 30:23.100
他就直接把浏览器开源了

30:23.100 --> 30:25.100
同时开源的还有什么

30:25.100 --> 30:26.100
还有JavaScript

30:26.100 --> 30:27.100
这些都开源了

30:27.100 --> 30:28.100
全部开源

30:28.100 --> 30:30.100
开源过后

30:30.100 --> 30:32.100
这个事情就有意思了

30:32.100 --> 30:33.100
我们现在赚不到钱了

30:33.100 --> 30:34.100
也没什么钱可以赚

30:34.100 --> 30:35.100
这个Mosella基金会

30:35.100 --> 30:36.100
也是一个非引力型组织

30:36.100 --> 30:38.100
所以没什么钱可以赚了

30:38.100 --> 30:39.100
但是呢

30:39.100 --> 30:41.100
引起了很多技术爱好者的

30:41.100 --> 30:44.100
就是一些情怀吧

30:44.100 --> 30:45.100
我们这个浏览器

30:45.100 --> 30:46.100
以前这么火

30:46.100 --> 30:47.100
曾经几乎是占领了

30:47.100 --> 30:49.100
整个市场的浏览器

30:49.100 --> 30:50.100
我们来看一下他的原代码

30:50.100 --> 30:52.100
把原代码下下来一看

30:52.100 --> 30:54.100
有些地方代码写的

30:54.100 --> 30:55.100
确实不太合理

30:55.100 --> 30:56.100
于是呢给他打补钉

30:56.100 --> 30:58.100
进行维护修修补补

30:58.100 --> 30:59.100
修修补补

30:59.100 --> 31:00.100
就是接下来

31:00.100 --> 31:02.100
就是长时间内

31:02.100 --> 31:05.100
长时间内

31:05.100 --> 31:11.670
世界的技术爱好者

31:11.670 --> 31:14.670
对网警浏览器

31:14.670 --> 31:17.670
浏览器

31:17.670 --> 31:22.670
进行维护和打补钉

31:22.670 --> 31:23.670
打补钉

31:23.670 --> 31:25.670
所以说这件事

31:25.670 --> 31:27.670
让我想起了一句诗

31:27.670 --> 31:29.670
这首诗呢叫做一切

31:29.670 --> 31:31.670
具体是谁写的

31:31.670 --> 31:32.670
我忘了

31:32.670 --> 31:33.670
里边有这么一句话

31:33.670 --> 31:35.670
就结尾的时候有这么一句话

31:35.670 --> 31:36.670
叫做一切的爆发

31:36.670 --> 31:39.670
都有片刻的零尽

31:39.670 --> 31:40.670
一切的死亡

31:40.670 --> 31:43.670
都有荣尝的回升

31:43.670 --> 31:44.670
微卵认为

31:44.670 --> 31:46.670
这个亡静浏览器

31:46.670 --> 31:48.670
已经是死人一个了

31:48.670 --> 31:49.670
怕他干嘛呢

31:49.670 --> 31:50.670
对吧

31:50.670 --> 31:51.670
但是不知道

31:51.670 --> 31:53.670
亡静浏览器在慢慢的发展

31:53.670 --> 31:54.670
慢慢的积累

31:54.670 --> 31:55.670
当微卵解散了

31:55.670 --> 31:57.670
整个浏览器团队之后

31:57.670 --> 32:00.670
IE已经停止不前了

32:00.670 --> 32:01.670
停止不前了

32:01.670 --> 32:02.670
但是亡静浏览器

32:02.670 --> 32:03.670
还在继续的发展

32:03.670 --> 32:04.670
虽然他已经死了

32:04.670 --> 32:05.670
但是没有撤离的死去

32:05.670 --> 32:06.670
还有荣尝的回升

32:06.670 --> 32:08.670
于是终于有一天

32:08.670 --> 32:09.670
他引难了新生

32:09.670 --> 32:11.670
2002年

32:11.670 --> 32:14.670
Mozena推出

32:14.670 --> 32:16.670
当然他已经不再是商用公司了

32:16.670 --> 32:18.670
他已经不再是商用公司了

32:18.670 --> 32:19.670
推出什么

32:19.670 --> 32:22.670
推出Firefox火乎浏览器

32:22.670 --> 32:23.670
这个火乎浏览器

32:23.670 --> 32:26.670
其实就是以前的亡静浏览器

32:26.670 --> 32:27.670
对他进行的

32:27.670 --> 32:28.670
不断的升级

32:28.670 --> 32:29.670
不断的打布五丁

32:29.670 --> 32:31.670
然后最终推出了这个浏览器

32:31.670 --> 32:33.670
当时这个浏览器

32:33.670 --> 32:35.670
如果从什么性能

32:35.670 --> 32:36.670
安全性

32:36.670 --> 32:38.670
对标准的支持

32:38.670 --> 32:39.670
等等的角度

32:39.670 --> 32:41.670
都是很多地方都完胜

32:41.670 --> 32:43.670
IE6这个浏览器

32:43.670 --> 32:44.670
但是当时

32:44.670 --> 32:46.670
并没有引起用户的注意

32:46.670 --> 32:47.670
因为我们知道

32:47.670 --> 32:48.670
IE6这个浏览器

32:48.670 --> 32:50.670
已经绑定到操作系统上面去了

32:50.670 --> 32:51.670
用户难得去更换了

32:51.670 --> 32:53.670
所以说并没有对IE6这个浏览器

32:53.670 --> 32:55.670
形成挑战

32:55.670 --> 32:56.670
微软的当时也不在意

32:56.670 --> 32:58.670
尽管你这个浏览器做得好

32:58.670 --> 32:59.670
我反正讨论都解散了

32:59.670 --> 33:00.670
你们自己玩吧

33:00.670 --> 33:01.670
我这个浏览器

33:01.670 --> 33:03.670
已经跟那个系统绑定起来了

33:03.670 --> 33:04.670
也不可能

33:04.670 --> 33:06.670
对我造成太大的影响

33:06.670 --> 33:07.670
他也没有在意

33:07.670 --> 33:10.670
时间进一步推移

33:10.670 --> 33:13.670
到了2008年

33:13.670 --> 33:17.670
谷歌推出

33:17.670 --> 33:18.670
什么呢

33:18.670 --> 33:21.670
推出的是谷歌

33:21.670 --> 33:23.670
谷歌推

33:23.670 --> 33:25.670
谷歌推出

33:25.670 --> 33:27.670
Chrome浏览器

33:27.670 --> 33:29.670
Chrome浏览器

33:29.670 --> 33:35.110
还有什么苹果推出

33:35.110 --> 33:37.110
推出就是Safari

33:37.110 --> 33:38.110
Safari浏览器

33:38.110 --> 33:40.110
还有另外一个小巧的叫做

33:40.110 --> 33:42.110
Oprah浏览器

33:42.110 --> 33:44.110
Oprah

33:44.110 --> 33:45.110
Oprah这个浏览器

33:45.110 --> 33:48.110
是一个名字叫做ASA这个公司

33:48.110 --> 33:50.110
推出

33:50.110 --> 33:53.110
用于手机端的Oprah浏览器

33:53.110 --> 33:55.110
好一下子到了2008年

33:55.110 --> 33:57.110
一下子市面上就多了

33:57.110 --> 33:59.110
很多很多的浏览器了

33:59.110 --> 34:01.110
当时最出众的

34:01.110 --> 34:05.680
当时最出众的夜空中的一盏心

34:05.680 --> 34:06.680
对吧

34:06.680 --> 34:07.680
就是谷歌浏览器

34:07.680 --> 34:09.680
因为谷歌浏览器里边

34:09.680 --> 34:11.680
搭载了一个GS

34:11.680 --> 34:13.680
执行引擎

34:13.680 --> 34:16.680
执行引擎V8

34:16.680 --> 34:18.680
就是顶顶大名的V8引擎

34:19.680 --> 34:20.680
V8引擎就是介石

34:20.680 --> 34:21.680
它是个语言

34:21.680 --> 34:22.680
还要编写代码

34:22.680 --> 34:23.680
我们用介石写代码

34:23.680 --> 34:25.680
写了代码之后需要执行

34:25.680 --> 34:27.680
在浏览器里边执行

34:27.680 --> 34:28.680
那么谁执行呢

34:28.680 --> 34:32.680
执行这个代码的东西叫做介石执行引擎

34:32.680 --> 34:35.680
以前的引擎是非常非常落后的

34:35.680 --> 34:37.680
甚至在最早的时候都没有引擎

34:37.680 --> 34:38.680
都没有引擎

34:38.680 --> 34:39.680
后来才把这个引

34:39.680 --> 34:40.680
专门来分出一个块

34:40.680 --> 34:42.680
来专门来执行介石代码

34:42.680 --> 34:44.680
那么这一块叫做介石执行引擎

34:44.680 --> 34:47.680
这些执行引擎过去是非常落后的

34:47.680 --> 34:49.680
因为介石它自身的特点

34:49.680 --> 34:50.680
我们一会就会讲

34:50.680 --> 34:52.680
介石自身的执行特点

34:52.680 --> 34:54.680
就决定了介石语言

34:54.680 --> 34:55.680
它的执行速度比较慢

34:55.680 --> 34:58.680
但是这个V8引擎就不一样了

34:58.680 --> 35:01.680
它可以直接把介石的代码

35:01.680 --> 35:04.680
直接变成字节码

35:04.680 --> 35:05.680
简单说一下

35:05.680 --> 35:14.310
V8引擎可以将介石代码

35:14.310 --> 35:18.310
直接转换为字节码

35:18.310 --> 35:20.310
字节码的话你可以认为就是机器代码

35:20.310 --> 35:21.310
你可以这样认为

35:21.310 --> 35:22.310
但它不完全是

35:22.310 --> 35:25.310
你可以认为就是一个1010这样的机器代码

35:25.310 --> 35:26.310
以前不行

35:26.310 --> 35:28.310
以前音乐种种原因很难的

35:28.310 --> 35:30.310
这个东西不是想得那么简单的

35:30.310 --> 35:31.310
以前我们写的代码

35:31.310 --> 35:33.310
它要经过几层几层的转换

35:33.310 --> 35:35.310
才能最终转换成机器码

35:35.310 --> 35:36.310
交给计判机执行

35:36.310 --> 35:38.310
但是V8引擎可以直接转换成字节码

35:38.310 --> 35:41.310
它突破了很多的技术障碍

35:41.310 --> 35:43.310
最终完成了这个壮举

35:43.310 --> 35:45.310
一下子到了一个什么程度呢

35:45.310 --> 35:46.310
理论上

35:46.310 --> 35:47.310
当然是理论上

35:47.310 --> 35:49.310
理论上

35:49.310 --> 35:51.310
GS代码的执行速度

35:51.310 --> 35:55.310
已经接近汇边语言了

35:55.310 --> 35:57.310
汇边语言

35:57.310 --> 35:59.310
汇边语言应该是

35:59.310 --> 36:01.310
从执行效率上来说

36:01.310 --> 36:03.310
只是从执行效率上来说

36:03.310 --> 36:05.310
一定是最快的执行语言

36:05.310 --> 36:07.310
但它编写起来很恶心

36:07.310 --> 36:08.310
非常非常恶心

36:08.310 --> 36:09.310
你编写一个惩罚

36:09.310 --> 36:12.310
都要写好多好多东西

36:12.310 --> 36:14.310
但是GS语言有了这么一个东西

36:14.310 --> 36:15.310
V8引擎过后

36:15.310 --> 36:17.310
它的执行速度大幅度提升

36:17.310 --> 36:19.310
执行速度提升了

36:19.310 --> 36:20.310
不是简单的那么一个

36:20.310 --> 36:23.310
就是速度快的那种感觉

36:23.310 --> 36:24.310
于是呢

36:24.310 --> 36:28.310
于是GS具备了什么

36:28.310 --> 36:35.310
具备了编写大型应用程序的能力

36:35.310 --> 36:37.310
以前GS不行

36:37.310 --> 36:38.310
以前GS只能做一些小效果

36:38.310 --> 36:39.310
你单码一写多

36:39.310 --> 36:41.310
网易就会变得很卡

36:41.310 --> 36:42.310
就变得非常非常卡

36:42.310 --> 36:44.310
但是有了V8引擎过后

36:44.310 --> 36:47.310
GS就可以玩出很多很多花样了

36:47.310 --> 36:49.310
大型应用都可以开发了

36:49.310 --> 36:53.310
甚至服务器应用

36:53.310 --> 36:55.310
服务器应用

36:55.310 --> 36:56.310
服务器我们现在还没有学

36:56.310 --> 36:58.310
我们只是在学浏览器

36:58.310 --> 36:59.310
学浏览器这一端的

36:59.310 --> 37:00.310
服务器我们以后

37:00.310 --> 37:02.310
哪怕你学前端也会学习的

37:02.310 --> 37:05.310
我们这里顺面介绍一下吧

37:05.310 --> 37:07.310
其中有一个人呢

37:07.310 --> 37:12.310
叫做Ran

37:12.310 --> 37:13.310
怎么读啊

37:13.310 --> 37:14.310
我也不知道怎么读啊

37:14.310 --> 37:16.310
反正这个人呢

37:16.310 --> 37:18.310
他准备书写一个

37:18.310 --> 37:25.310
准备写一个服务器端的框架

37:25.310 --> 37:28.310
准备写一个服务器端的框架

37:28.310 --> 37:29.310
这个时候呢

37:29.310 --> 37:30.310
当然我们现在还没有结束服务器

37:30.310 --> 37:32.310
不管了解一下听相声

37:32.310 --> 37:34.310
听一下单口相声

37:34.310 --> 37:36.310
听一下故事就行了

37:36.310 --> 37:38.310
当时他选择语言

37:38.310 --> 37:40.310
就是他选择用什么样的语言

37:40.310 --> 37:42.310
来写这个服务器端的框架

37:42.310 --> 37:43.310
他其实本人的话

37:43.310 --> 37:46.310
是非常喜欢介绍这个语言的特点

37:46.310 --> 37:48.310
但是由于介绍的执行速度太慢了

37:48.310 --> 37:49.310
太慢了

37:49.310 --> 37:51.310
没有一个合适的引擎来执行介绍

37:51.310 --> 37:52.310
他甚至想过

37:52.310 --> 37:54.310
要不要自己来写一个引擎

37:54.310 --> 37:55.310
来执行来介绍

37:55.310 --> 37:57.310
他都开始准备写了

37:57.310 --> 37:59.310
刚刚开始准备写的时候

37:59.310 --> 38:00.310
2008年

38:00.310 --> 38:01.310
微软

38:01.310 --> 38:03.310
谷歌发布了

38:03.310 --> 38:04.310
V8这个引擎

38:04.310 --> 38:05.310
他一看

38:05.310 --> 38:06.310
V8这个引擎不错啊

38:06.310 --> 38:07.310
执行速度这么快

38:07.310 --> 38:08.310
而且呢

38:08.310 --> 38:09.310
他还开圆的

38:09.310 --> 38:11.310
V8引擎是开圆的

38:11.310 --> 38:12.310
所以说呢

38:12.310 --> 38:15.310
就直接利用

38:15.310 --> 38:17.310
V8引擎

38:17.310 --> 38:19.310
完成了

38:19.310 --> 38:21.310
该框架

38:21.310 --> 38:23.310
他直接用这个V8引擎

38:23.310 --> 38:24.310
来运行介绍

38:24.310 --> 38:25.310
就完成了

38:25.310 --> 38:26.310
把整个框架就写完了

38:26.310 --> 38:27.310
所以说里面

38:27.310 --> 38:28.310
后边如果学前端的话

38:28.310 --> 38:30.310
你会学习一个东西

38:30.310 --> 38:32.310
叫做该框架

38:32.310 --> 38:34.310
称为

38:34.310 --> 38:35.310
称为

38:35.310 --> 38:36.310
露的介绍

38:36.310 --> 38:38.310
就是鼎鼎大名的露的介绍

38:38.310 --> 38:41.310
包括现在整个前端环境里边

38:41.310 --> 38:43.310
如果你真正学到前端之后

38:43.310 --> 38:44.310
以后出去工作

38:44.310 --> 38:46.310
一定是离不开的露的介绍的

38:46.310 --> 38:48.310
因为很多的前端工程环境

38:48.310 --> 38:50.310
都要用到露的介绍

38:50.310 --> 38:52.310
这个框架就这么来的

38:52.310 --> 38:54.310
就是因为V8引擎的出现

38:54.310 --> 38:55.310
所以说我们

38:55.310 --> 38:57.310
第二次浏览机大战

38:57.310 --> 38:59.310
第二次浏览机大战

38:59.310 --> 39:00.310
出现在什么时候

39:00.310 --> 39:02.310
我们历史上认为

39:02.310 --> 39:03.310
在2008年

39:03.310 --> 39:04.310
真正宣起了

39:04.310 --> 39:05.310
第二次浏览机大战

39:05.310 --> 39:07.310
因为谷歌浏览机推出过后

39:07.310 --> 39:08.310
搭载了V8引擎

39:08.310 --> 39:10.310
它不仅侵蚀的

39:10.310 --> 39:11.310
火火浏览机的市场

39:11.310 --> 39:13.310
并且同时在侵蚀

39:13.310 --> 39:14.310
IE的市场

39:14.310 --> 39:15.310
你看一下目前

39:15.310 --> 39:17.310
整个全世界范围内

39:17.310 --> 39:19.310
市场占有绿球最高的

39:19.310 --> 39:20.310
就是谷歌浏览机了

39:20.310 --> 39:21.310
就是谷歌浏览机

39:21.310 --> 39:22.310
有些人说

39:22.310 --> 39:23.310
我怎么没有用谷歌浏览机呢

39:23.310 --> 39:25.310
我用的是什么QQ浏览机

39:25.310 --> 39:26.310
对吧

39:26.310 --> 39:27.310
用的是什么360浏览机

39:27.310 --> 39:28.310
对不起

39:28.310 --> 39:29.310
你用的就是V8引擎

39:29.310 --> 39:31.310
用的就是谷歌浏览机的内核

39:31.310 --> 39:32.310
我们之前说过

39:32.310 --> 39:33.310
浏览机里面

39:33.310 --> 39:34.310
最关键的是什么

39:34.310 --> 39:35.310
是内核

39:35.310 --> 39:37.310
而这个介式执行引擎

39:37.310 --> 39:38.310
它是内核的一部分

39:38.310 --> 39:40.310
是内核不可分割的一部分

39:40.310 --> 39:41.310
内核里面还有渲染引擎

39:41.310 --> 39:42.310
对吧

39:42.310 --> 39:43.310
渲染一面的

39:43.310 --> 39:44.310
还有介式执行引擎

39:44.310 --> 39:45.310
介式执行引擎

39:45.310 --> 39:47.310
就是内核的一部分

39:47.310 --> 39:49.310
这里说一下

39:49.310 --> 39:50.310
我们后边

39:50.310 --> 39:51.310
一定会学习这个漏的介式

39:51.310 --> 39:52.310
但是我们这个课

39:52.310 --> 39:53.310
不涉及

39:54.310 --> 39:56.310
在第二次浏览机大战里面

39:56.310 --> 39:57.310
大家记住一个关键点

39:57.310 --> 39:58.310
什么关键点呢

39:58.310 --> 40:01.310
就是关于V8引擎

40:01.310 --> 40:05.310
将介式的执行

40:05.310 --> 40:09.310
推向了一个新的台阶

40:09.310 --> 40:11.310
新的台阶

40:11.310 --> 40:12.310
好了

40:12.310 --> 40:14.310
这是关于这个

40:14.310 --> 40:16.310
第二次浏览机大战

40:16.310 --> 40:18.310
好

40:18.310 --> 40:19.310
第四个

40:19.310 --> 40:20.310
第四个阶段

40:20.310 --> 40:22.310
就是关于介式

40:22.310 --> 40:25.310
介式标准的发展

40:25.310 --> 40:27.310
介式标准的发展

40:27.310 --> 40:29.310
我们之前说过

40:29.310 --> 40:31.310
在1997年的时候

40:31.310 --> 40:32.310
买下了一个种子

40:32.310 --> 40:34.310
像那个

40:34.310 --> 40:35.310
ACMA组织提交了

40:35.310 --> 40:37.310
JavaScript的标准

40:37.310 --> 40:38.310
那么接下来

40:38.310 --> 40:39.310
王岐东是死的

40:39.310 --> 40:40.310
但是标准组织还没死

40:40.310 --> 40:42.310
标准组织还在继续工作

40:42.310 --> 40:44.310
虽然他工作的很慢

40:44.310 --> 40:45.310
但是他还在继续工作

40:45.310 --> 40:46.310
对吧

40:46.310 --> 40:48.310
他慢慢的开始推行

40:48.310 --> 40:49.310
ES的版本

40:49.310 --> 40:50.310
他也别管

40:50.310 --> 40:51.310
在市场上

40:51.310 --> 40:52.310
别人用不用

40:52.310 --> 40:53.310
但是他慢慢的在推行

40:53.310 --> 40:54.310
ES的版本

40:55.310 --> 40:56.310
那么GS

40:56.310 --> 40:57.310
他经历了这么几个版本

40:57.310 --> 40:58.310
几个关键版本

40:58.310 --> 40:59.310
大家记住

40:59.310 --> 41:01.310
第一个版本是ES1

41:01.310 --> 41:03.310
ES1这个版本

41:03.310 --> 41:06.310
他是发布于1997年

41:06.310 --> 41:07.310
1997年

41:07.310 --> 41:08.310
因为就是

41:08.310 --> 41:09.310
刚刚提交标准的那一年

41:09.310 --> 41:11.310
他就发布了ES1这个版本

41:11.310 --> 41:12.310
当时正在进行

41:12.310 --> 41:13.310
第一次浏览其大战

41:13.310 --> 41:14.310
对吧

41:14.310 --> 41:15.310
没人甩他

41:15.310 --> 41:16.310
真的是没人甩他

41:16.310 --> 41:17.310
他的版本太之后了

41:17.310 --> 41:18.310
太慢了

41:18.310 --> 41:20.310
然后是在ES2

41:20.310 --> 41:22.310
也是发布于1998年

41:22.310 --> 41:25.310
1998年发布了ES2这个版本

41:25.310 --> 41:27.310
当时王锦

41:27.310 --> 41:28.310
王锦公司

41:28.310 --> 41:29.310
已经是支撑不住了

41:29.310 --> 41:30.310
已经支撑不住了

41:30.310 --> 41:32.310
微软也是各搞各的

41:32.310 --> 41:33.310
他也不太甩这个标准

41:33.310 --> 41:34.310
当然他有些地方

41:34.310 --> 41:35.310
还是按照标准来了

41:35.310 --> 41:37.310
但是不是全部按照标准来

41:37.310 --> 41:38.310
而且他还有自己

41:38.310 --> 41:39.310
很多很多的功能

41:39.310 --> 41:40.310
都是标准里面没有的

41:40.310 --> 41:42.310
所以说还是比较之后

41:42.310 --> 41:45.310
然后ES3是1999年

41:45.310 --> 41:46.310
1999年

41:46.310 --> 41:48.310
ES3这个版本持续了很久

41:48.310 --> 41:50.310
持续了非常非常久

41:50.310 --> 41:52.310
ES3这个版本出来过后

41:52.310 --> 41:54.310
还是老样子

41:54.310 --> 41:57.310
还是老样子

41:57.310 --> 41:59.310
然后这个时候

41:59.310 --> 42:01.310
ES这个标准组织

42:01.310 --> 42:03.310
就开始痛定失痛了

42:03.310 --> 42:05.310
为什么咱们的标准

42:05.310 --> 42:06.310
这么之后

42:06.310 --> 42:08.310
而且之前的很多问题

42:08.310 --> 42:09.310
我们只想知道

42:09.310 --> 42:10.310
ES这个语言

42:10.310 --> 42:12.310
他有很多的引流问题

42:12.310 --> 42:13.310
因为他毕竟是

42:13.310 --> 42:14.310
十天就涉及出来的语言

42:14.310 --> 42:16.310
所以他有很多的引流问题

42:16.310 --> 42:17.310
那么标准里面

42:17.310 --> 42:18.310
需要把这些引流问题

42:18.310 --> 42:19.310
慢慢解决

42:19.310 --> 42:20.310
但是又不能直接拋弃

42:20.310 --> 42:21.310
因为之前已经发布了

42:21.310 --> 42:22.310
这个标准了

42:22.310 --> 42:23.310
发布过了三个版本了

42:23.310 --> 42:24.310
又不能直接拋弃

42:24.310 --> 42:25.310
于是他已经过了

42:25.310 --> 42:27.310
漫长漫长的讨论

42:27.310 --> 42:29.310
该怎么来解决这些问题

42:29.310 --> 42:30.310
我们后续的标准

42:30.310 --> 42:32.310
应该用什么样的方式来做

42:32.310 --> 42:33.310
这个讨论有多少时间了

42:33.310 --> 42:35.310
讨论了好几年

42:35.310 --> 42:37.310
一直就在争论争论

42:37.310 --> 42:39.310
没有一个合适的结果

42:39.310 --> 42:41.310
但是这里这个时候

42:41.310 --> 42:43.310
我们之前说过

42:43.310 --> 42:44.310
微软的

42:44.310 --> 42:46.310
它解散了浏览器的环队

42:46.310 --> 42:48.310
它终于不再疯狂了更新了

42:48.310 --> 42:50.310
它更新了停滞了

42:50.310 --> 42:51.310
基本上是停滞的

42:51.310 --> 42:52.310
到了Ie6过后

42:52.310 --> 42:53.310
就是一些小的改动

42:53.310 --> 42:55.310
留了这么几个人

42:55.310 --> 42:56.310
小的改动

42:56.310 --> 42:57.310
处理一下就完事了

42:57.310 --> 42:58.310
它基本上没有对

42:58.310 --> 42:59.310
与法规则这些东西

42:59.310 --> 43:00.310
进行更新了

43:00.310 --> 43:02.310
这就给标准组织了

43:02.310 --> 43:03.310
进行了喘息的时间

43:03.310 --> 43:05.310
它终于可以慢慢过来商量了

43:05.310 --> 43:06.310
不用着急了

43:06.310 --> 43:07.310
之前没办法

43:07.310 --> 43:09.310
他们人面竞争那么激烈

43:09.310 --> 43:10.310
我必须要不断的去

43:10.310 --> 43:11.310
迎合他们的

43:11.310 --> 43:13.310
就是这个市场环境

43:13.310 --> 43:15.310
必须要不断的推出新标准

43:15.310 --> 43:16.310
但是现在不用着急

43:16.310 --> 43:17.310
我们慢慢讨论

43:17.310 --> 43:18.310
于是讨论出来的

43:18.310 --> 43:20.310
ES4这个版本

43:20.310 --> 43:21.310
但是很遗憾

43:21.310 --> 43:23.310
ES4这个版本没有发布

43:23.310 --> 43:24.310
最终没有发布

43:24.310 --> 43:26.310
因为发现太激进了

43:26.310 --> 43:27.310
讨论过后

43:27.310 --> 43:28.310
经过了好几年的讨论

43:28.310 --> 43:30.310
最终发现这个标准

43:30.310 --> 43:31.310
里边还是有些东西

43:31.310 --> 43:32.310
不适合推出

43:32.310 --> 43:35.310
有些太过于激进

43:35.310 --> 43:36.310
所以说ES4这个版本

43:36.310 --> 43:37.310
是没有的

43:37.310 --> 43:39.310
不要以后说ES4

43:39.310 --> 43:40.310
没有这个版本

43:40.310 --> 43:43.310
是直接推出的ES5

43:43.310 --> 43:45.310
什么时候呢

43:45.310 --> 43:47.310
2009年

43:47.310 --> 43:50.310
过去了10年推出了ES5

43:50.310 --> 43:51.310
所以说ES3这个版本

43:51.310 --> 43:53.310
存在了很长很长一段时间

43:53.310 --> 43:55.310
包括我毕业的时候

43:55.310 --> 43:57.310
我是09年毕业的

43:57.310 --> 43:59.310
我是09年毕业的

43:59.310 --> 44:01.310
包括我毕业的时候

44:01.310 --> 44:03.310
当时市面上都是用的是ES3

44:03.310 --> 44:04.310
ES5刚刚推出

44:04.310 --> 44:06.310
还有一段时间的

44:06.310 --> 44:08.310
就是过渡的过程对吧

44:08.310 --> 44:09.310
所以说

44:09.310 --> 44:11.310
当时用的基本上都是ES3

44:11.310 --> 44:13.310
2009年ES5才推出

44:13.310 --> 44:15.310
但是ES5推出来过后

44:15.310 --> 44:17.310
整个市场都不一样了

44:17.310 --> 44:19.310
ES5推出的那一瞬间

44:19.310 --> 44:21.310
发现i-1浏览器

44:21.310 --> 44:24.310
当时骁傲群雄的i-1-6浏览器

44:24.310 --> 44:26.310
已经是远远的落伍了

44:26.310 --> 44:28.310
无论是安全性

44:28.310 --> 44:29.310
还是执行速度

44:29.310 --> 44:31.310
还是愈法的规则的支持

44:31.310 --> 44:34.310
还是呆马的优雅性等等等等

44:34.310 --> 44:36.310
都已经完全落伍了

44:36.310 --> 44:37.310
那个时候微软台

44:37.310 --> 44:38.310
真的着急了

44:38.310 --> 44:41.310
我居然比标准的还要落后了

44:41.310 --> 44:43.310
于是开始疯狂的赶

44:43.310 --> 44:44.310
但是已经赶不上来了

44:44.310 --> 44:45.310
因为它的团队已经没了

44:45.310 --> 44:46.310
我们公司里面

44:46.310 --> 44:47.310
最重要的是什么

44:47.310 --> 44:48.310
最重要的是人才对吧

44:48.310 --> 44:50.310
这些人才已经流失掉了

44:50.310 --> 44:52.310
你再想去逐渐那个团队

44:52.310 --> 44:53.310
已经很难很难了

44:53.310 --> 44:55.310
所以说i-1慢慢的丢失了

44:55.310 --> 44:56.310
整个的市场分合

44:56.310 --> 44:58.310
最终的都没有现在这个样子了

44:58.310 --> 45:01.310
微软自己都把i-1放弃了

45:01.310 --> 45:02.310
所以说很多时候

45:02.310 --> 45:04.310
微软有些决策

45:04.310 --> 45:06.310
真的不知道是怎么回事

45:06.310 --> 45:09.310
反正微软内部有些官僚的作风

45:09.310 --> 45:11.310
挺不好的

45:11.310 --> 45:13.310
然后ES6

45:13.310 --> 45:15.310
ES6是在2015年发布的

45:15.310 --> 45:17.310
这也是一个跨时代意义的标准

45:17.310 --> 45:19.310
里面又讲了很多很多的新东西

45:19.310 --> 45:20.310
我们之前说过对吧

45:20.310 --> 45:22.310
我们这个课了讲到什么

45:22.310 --> 45:24.310
讲到ES5

45:24.310 --> 45:26.310
ES6会设计到那么一点点东西

45:26.310 --> 45:28.310
可能会设计一点点东西

45:28.310 --> 45:29.310
但不会着重的去讲ES6

45:29.310 --> 45:30.310
因为这里面东西

45:30.310 --> 45:32.310
新标准里面东西太多了

45:32.310 --> 45:34.310
需要专门哪一门课来讲

45:34.310 --> 45:37.310
我们只讲到ES5

45:37.310 --> 45:39.310
ES5也非常非常重要

45:39.310 --> 45:43.310
目前很多浏览器

45:43.310 --> 45:44.310
有些浏览器

45:44.310 --> 45:45.310
不是很多吧

45:45.310 --> 45:46.310
有些就版面的浏览器

45:46.310 --> 45:48.310
它是不支持ES6的

45:48.310 --> 45:50.310
比如说2015年之前的浏览器

45:50.310 --> 45:51.310
它不支持ES6

45:51.310 --> 45:52.310
它支持的是ES5

45:52.310 --> 45:54.310
所以说你考虑监动性问题的话

45:54.310 --> 45:55.310
你还得学习ES5

45:55.310 --> 45:58.310
ES5也是一个必不可少的知识

45:58.310 --> 45:59.310
ES6

45:59.310 --> 46:02.310
然后ES7

46:02.310 --> 46:04.310
ES7是2016年

46:04.310 --> 46:07.310
真的我顺便说一下

46:07.310 --> 46:10.310
就是到了ES5之后

46:10.310 --> 46:15.310
就不再区分

46:16.310 --> 46:21.310
区分JavaScript和EchemaScript

46:21.310 --> 46:23.310
Echema在这么写

46:23.310 --> 46:24.310
前面是说写

46:24.310 --> 46:26.310
就不再区分这两个东西了

46:26.310 --> 46:28.310
就是我们习惯上

46:28.310 --> 46:30.310
习惯上

46:30.310 --> 46:32.310
不再区分这个东西了

46:32.310 --> 46:33.310
因为以前我们知道

46:33.310 --> 46:35.310
JavaScript是网景公司推出的

46:35.310 --> 46:36.310
是商用的

46:36.310 --> 46:38.310
后来JavaScript是开源了

46:38.310 --> 46:40.310
并且完全是符合标准的

46:40.310 --> 46:41.310
我们都按照标准来了

46:41.310 --> 46:42.310
包括火狐的暗器

46:42.310 --> 46:43.310
谷歌的暗器

46:43.310 --> 46:44.310
都按照EchemaScript的标准来了

46:44.310 --> 46:46.310
因为网景公司已经不存在了

46:46.310 --> 46:47.310
所以说我们习惯上

46:47.310 --> 46:49.310
还沿用JavaScript这个词

46:49.310 --> 46:50.310
但是严格来说

46:50.310 --> 46:52.310
现在应该叫做EchemaScript

46:52.310 --> 46:53.310
无所谓

46:53.310 --> 46:56.310
我们习惯上也可以称它为JavaScript

46:56.310 --> 46:58.310
ESJavaScript都行

46:58.310 --> 47:00.310
但是它的含义

47:00.310 --> 47:02.310
已经不再做严格的区分了

47:02.310 --> 47:05.310
含义上已经不再做严格的区分了

47:05.310 --> 47:07.310
这里我要说一下

47:07.310 --> 47:10.310
另外我再说一下

47:10.310 --> 47:13.310
ES这个标准

47:13.310 --> 47:17.310
ES的语言标准

47:17.310 --> 47:19.310
就是它是制定这个语言的标准

47:19.310 --> 47:21.310
你该怎么去写代

47:21.310 --> 47:26.310
不涉及语言的运行环境

47:26.310 --> 47:27.310
这什么意思

47:27.310 --> 47:29.310
这个点非常非常重要

47:29.310 --> 47:31.310
我都想要打十颗心了

47:31.310 --> 47:33.310
没法只能打两颗心

47:33.310 --> 47:34.310
加出

47:34.310 --> 47:37.310
非常非常重要

47:37.310 --> 47:39.310
理解这个东西非常重要

47:39.310 --> 47:41.310
什么意思呢

47:41.310 --> 47:42.310
我举个例子吧

47:42.310 --> 47:44.310
我们说的是什么语言呢

47:44.310 --> 47:46.310
说的是中文

47:46.310 --> 47:48.310
咱们从小学的时候

47:48.310 --> 47:50.310
就要学中文

47:50.310 --> 47:52.310
学中文的时候我们学的是啥

47:52.310 --> 47:54.310
学的是拼音

47:54.310 --> 47:56.310
然后呢

47:56.310 --> 47:58.310
什么音调

47:58.310 --> 48:00.310
生母 孕母

48:00.310 --> 48:02.310
还有什么偏旁部手

48:02.310 --> 48:04.310
这是啥

48:04.310 --> 48:06.310
这是语言规则

48:06.310 --> 48:08.310
这叫语言标准

48:08.310 --> 48:10.310
仔细听

48:10.310 --> 48:12.310
我们学的中文

48:12.310 --> 48:14.310
什么拼音 生调

48:14.310 --> 48:16.310
还有什么偏旁部手

48:16.310 --> 48:18.310
这些属于语言标准

48:18.310 --> 48:20.310
后来呢你读了大学

48:20.310 --> 48:22.310
选择了一个拨音主持的专业

48:22.310 --> 48:24.310
在拨音主持的专业里边

48:24.310 --> 48:26.310
用的是不是还是中文

48:26.310 --> 48:28.310
对吧 用的还是中文

48:28.310 --> 48:30.310
用的仍然是中文那套标准

48:30.310 --> 48:32.310
什么拼音啊

48:32.310 --> 48:34.310
就是汉字的偏旁部手

48:34.310 --> 48:36.310
用的还是这些标准

48:36.310 --> 48:38.310
但是呢

48:38.310 --> 48:40.310
在这个环境下边

48:40.310 --> 48:42.310
在这个拨音主持的环境下边

48:42.310 --> 48:44.310
是不是给你加了一些新东西

48:44.310 --> 48:46.310
给你加了一些专业术语

48:46.310 --> 48:48.310
比如说你学的是导演

48:48.310 --> 48:50.310
以后去当导演

48:50.310 --> 48:52.310
就是导电影

48:52.310 --> 48:54.310
那么电影里面不是一个杀青吗

48:54.310 --> 48:56.310
表示一个演员的戏演完了

48:56.310 --> 48:58.310
那么他的戏结束了叫杀青

48:58.310 --> 49:00.310
那么这个词

49:00.310 --> 49:02.310
是不是中文里面的词汇呢

49:02.310 --> 49:04.310
它不是

49:04.310 --> 49:06.310
它是那个行业里面的词汇

49:06.310 --> 49:08.310
就是一些新的东西

49:08.310 --> 49:10.310
明白这个意思吧

49:10.310 --> 49:12.310
它就跟我们这里的意思是一样的

49:12.310 --> 49:14.310
ES呢

49:14.310 --> 49:16.310
它指定

49:16.310 --> 49:18.310
语言标准

49:18.310 --> 49:20.310
指定语言标准

49:20.310 --> 49:22.310
就是说我这个

49:22.310 --> 49:24.310
我怎么去说话让计算机能听得懂

49:24.310 --> 49:26.310
我怎么去写代嘛

49:26.310 --> 49:28.310
语法是什么

49:28.310 --> 49:30.310
它的关键词是什么

49:30.310 --> 49:32.310
怎么去定义辨量等等

49:32.310 --> 49:34.310
我们后面都会学习

49:34.310 --> 49:36.310
计算机就是一个语言嘛对吧

49:36.310 --> 49:38.310
语言无非就是计算机语言嘛

49:38.310 --> 49:40.310
语言的作用是什么沟通嘛

49:40.310 --> 49:42.310
计算机语言的作用是什么

49:42.310 --> 49:44.310
人跟计算机之间进行沟通

49:44.310 --> 49:46.310
我要怎么说话让计算机能听得懂

49:46.310 --> 49:48.310
它就不在乎这个语言

49:48.310 --> 49:50.310
到底是不是在浏览器里面执行

49:50.310 --> 49:52.310
明白这个意思吗

49:52.310 --> 49:54.310
能不能明白这个意思

49:54.310 --> 49:56.310
它只是让我只是告诉你怎么去说话

49:56.310 --> 49:58.310
让计算机能听得懂

49:58.310 --> 50:00.310
它指定这个标准就行了

50:00.310 --> 50:02.310
它不管你这个语言

50:02.310 --> 50:04.310
在环境里面执行

50:04.310 --> 50:06.310
这一点非常非常重要

50:06.310 --> 50:08.310
正是因为

50:08.310 --> 50:10.310
标准组织这种

50:10.310 --> 50:12.310
这叫什么深谋远虑

50:12.310 --> 50:14.310
这种前瞻性的眼光

50:14.310 --> 50:16.310
它才让这个解释

50:16.310 --> 50:18.310
成为了一个通用语言

50:20.310 --> 50:22.310
正是因为

50:22.310 --> 50:24.310
夜市

50:24.310 --> 50:26.310
避免了

50:26.310 --> 50:28.310
就是浏览器

50:28.310 --> 50:30.310
就是运行环境

50:31.310 --> 50:33.310
避免了运行环境

50:33.310 --> 50:35.310
就是它考虑这个语言标准的时候

50:35.310 --> 50:38.750
完全不考虑它的运行环境

50:38.750 --> 50:40.750
就让

50:40.750 --> 50:42.750
夜市有机会

50:42.750 --> 50:44.750
至少有这个机会了

50:44.750 --> 50:46.750
在各种环境里面执行

50:46.750 --> 50:48.750
在各种环境中执行

50:49.750 --> 50:52.750
所以说我们今天看到了

50:52.750 --> 50:55.750
夜市只能在浏览器里面执行吗

50:55.750 --> 50:56.750
不是哦

50:56.750 --> 50:58.750
你们以后学前端的话学到后边

50:58.750 --> 51:00.750
做手机应用开发

51:00.750 --> 51:02.750
也可以使用介石

51:02.750 --> 51:04.750
做服务器开发也可以使用介石

51:04.750 --> 51:06.750
大家看到我这个软件没

51:06.750 --> 51:08.750
我这个vscode的这个软件

51:08.750 --> 51:10.750
它是用介石写的

51:10.750 --> 51:12.750
安装到本地

51:12.750 --> 51:14.750
它是用介石语言写的

51:14.750 --> 51:16.750
也就是说做一些本地的应用软件

51:16.750 --> 51:18.750
哪怕你做个qq

51:18.750 --> 51:20.750
也可以用介石语言写

51:20.750 --> 51:22.750
因为你只要说话的方式没有变

51:22.750 --> 51:24.750
只是你环境变了

51:24.750 --> 51:26.750
环境变了我给你加了一些新东西

51:26.750 --> 51:28.750
我们只需要去学习这个新东西就行了

51:28.750 --> 51:30.750
都没有发生变化

51:30.750 --> 51:32.750
所以说

51:32.750 --> 51:34.750
真是因为

51:34.750 --> 51:36.750
这样的考虑

51:36.750 --> 51:38.750
让介石

51:38.750 --> 51:40.750
也叫做夜市

51:40.750 --> 51:42.750
夜市

51:42.750 --> 51:44.750
成为了通用

51:44.750 --> 51:46.750
编程语言

51:46.750 --> 51:48.750
它是通用的

51:48.750 --> 51:50.750
以后我们说现在什么大前端

51:50.750 --> 51:52.750
什么叫大前端

51:52.750 --> 51:54.750
前端是啥 就是沟通人和设备

51:54.750 --> 51:56.750
只要是

51:56.750 --> 51:58.750
人直接和设备沟通了

51:58.750 --> 52:00.750
设备上的这些软件开发

52:00.750 --> 52:02.750
都可以用介石来做

52:02.750 --> 52:04.750
不管这个设备是啥

52:04.750 --> 52:06.750
哪怕以后是个什么车载系统

52:06.750 --> 52:08.750
智能音箱 什么扫地机器的

52:08.750 --> 52:10.750
都可以用介石来写

52:10.750 --> 52:12.750
当然现在还不行

52:12.750 --> 52:14.750
现在还需要一个过程

52:14.750 --> 52:16.750
但是以后一定会发生成为这个样子

52:16.750 --> 52:18.750
但是不一定是介石的

52:18.750 --> 52:20.750
可能前端又被另外一个语言统一的

52:20.750 --> 52:22.750
以后的事情都说不准

52:22.750 --> 52:24.750
但是至少目前来看来

52:24.750 --> 52:26.750
网页能写什么

52:26.750 --> 52:28.750
能在浏览器里面运行

52:28.750 --> 52:30.750
能在手机端运行 能在PC端

52:30.750 --> 52:32.750
就是电脑本地运行

52:32.750 --> 52:34.750
能在服务器端运行都可以运行

52:34.750 --> 52:36.750
它成为了一个通用的编程语言

52:36.750 --> 52:38.750
这个点就是我们第四个部分

52:38.750 --> 52:40.750
一定要了解的

52:40.750 --> 52:42.750
ES是一个通用的语言

52:42.750 --> 52:44.750
只不过我们这门课

52:44.750 --> 52:46.750
本课成

52:46.750 --> 52:48.750
学习

52:48.750 --> 52:50.750
学习的是什么

52:50.750 --> 52:52.750
学习的是

52:52.750 --> 52:54.750
首先我们先学习ES

52:54.750 --> 52:56.750
就是不管它的环境

52:56.750 --> 52:58.750
跟什么浏览器环境没有什么关系

52:58.750 --> 53:00.750
就是ES的通用语法

53:00.750 --> 53:02.750
的通用语法

53:02.750 --> 53:04.750
相当于是学习的啥呢

53:04.750 --> 53:06.750
相当于是小学的时候

53:06.750 --> 53:08.750
咱们学的中文

53:08.750 --> 53:10.750
从评一开始

53:10.750 --> 53:12.750
然后生调 生母 孕母

53:12.750 --> 53:14.750
然后什么偏旁部手

53:14.750 --> 53:16.750
学习了这么一些东西

53:16.750 --> 53:18.750
教你怎么去说话

53:18.750 --> 53:20.750
让电脑能听得懂

53:20.750 --> 53:22.750
用它的标准来进行说话

53:22.750 --> 53:24.750
让电脑能看得懂

53:24.750 --> 53:26.750
先学习这个东西

53:26.750 --> 53:28.750
然后再学习浏览器环境里边

53:28.750 --> 53:30.750
环境

53:30.750 --> 53:32.750
再学习浏览器环境

53:32.750 --> 53:34.750
就是在浏览器环境里边

53:34.750 --> 53:36.750
它会发生哪些变化

53:36.750 --> 53:38.750
其实没有什么变化

53:38.750 --> 53:40.750
就是加了一些东西

53:40.750 --> 53:42.750
浏览器环境

53:42.750 --> 53:44.750
为其注入的

53:44.750 --> 53:46.750
新功能

53:46.750 --> 53:48.750
因为在浏览器里边

53:48.750 --> 53:50.750
大学

53:50.750 --> 53:52.750
学的是波音主持专业

53:52.750 --> 53:54.750
或者是软件开发行业

53:54.750 --> 53:56.750
它会给你加一些数语

53:56.750 --> 53:58.750
都是用中文

53:58.750 --> 54:00.750
只不过往中文里边加一些词

54:00.750 --> 54:02.750
我们就学习在浏览器环境里边

54:02.750 --> 54:04.750
给你加了哪些词

54:04.750 --> 54:06.750
就学习这个东西

54:06.750 --> 54:08.750
先学习通用语法

54:08.750 --> 54:10.750
然后再学习注入的新功能

54:10.750 --> 54:12.750
我们主要是按照这样的步骤来学习

54:12.750 --> 54:14.750
那么通用语法这一块呢

54:14.750 --> 54:16.750
通用语法这一块

54:16.750 --> 54:18.750
大概是七到十五天

54:18.750 --> 54:20.750
不要着急啊这一块

54:20.750 --> 54:22.750
你看不到什么效果

54:22.750 --> 54:24.750
因为我们现在

54:24.750 --> 54:26.750
在学习这一块的时候

54:26.750 --> 54:28.750
没有学习跟浏览器相关的功能

54:28.750 --> 54:30.750
所以说你看不到浏览器里边的效果

54:30.750 --> 54:32.750
但是我们学的是什么

54:32.750 --> 54:34.750
相当于是小学的学的是中文

54:34.750 --> 54:36.750
你中文都没有学清楚

54:36.750 --> 54:38.750
让你去写篇文章里能写吗

54:38.750 --> 54:40.750
写不出来

54:40.750 --> 54:42.750
你中文都没有学清楚

54:42.750 --> 54:44.750
让你去做主持人行吗

54:44.750 --> 54:46.750
多少岁啊

54:46.750 --> 54:48.750
半岁吧

54:48.750 --> 54:50.750
六个月

54:50.750 --> 54:52.750
来吧你来教他

54:52.750 --> 54:54.750
做一个主持人来吧

54:54.750 --> 54:56.750
他连话都不会说

54:56.750 --> 54:58.750
他这样的说话

54:58.750 --> 55:00.750
你怎么去教他呢

55:00.750 --> 55:02.750
你得先把语言学好

55:02.750 --> 55:04.750
先学会说话

55:04.750 --> 55:06.750
然后再去学习

55:06.750 --> 55:08.750
在不同的环境里边该怎么去说话

55:08.750 --> 55:10.750
而我们这门课学习的环境是浏览器环境

55:10.750 --> 55:12.750
以后的课程呢

55:12.750 --> 55:14.750
手机环境里边用介石怎么说话

55:14.750 --> 55:16.750
在那个

55:16.750 --> 55:18.750
服务系环境里边用介石怎么说话

55:18.750 --> 55:20.750
等等都会学习的

55:20.750 --> 55:22.750
我们这门课只学习浏览器环境

55:22.750 --> 55:24.750
解释清楚没有

55:24.750 --> 55:26.750
我们把这个环境

55:26.750 --> 55:28.750
其实还可以称为

55:28.750 --> 55:30.750
这个环境

55:30.750 --> 55:32.750
通常

55:32.750 --> 55:34.750
通常

55:34.750 --> 55:36.750
把ES

55:36.750 --> 55:38.750
当然也是介石

55:38.750 --> 55:40.750
现在都是一个意思

55:40.750 --> 55:42.750
进行的环境

55:42.750 --> 55:44.750
称之为

55:44.750 --> 55:46.750
数主环境

55:46.750 --> 55:48.750
数主环境

55:48.750 --> 55:50.750
就很形象

55:50.750 --> 55:52.750
就像一些昆虫

55:52.750 --> 55:54.750
它要技术在别人的身上

55:54.750 --> 55:56.750
才能看到效果

55:56.750 --> 55:58.750
你光有一个ES标准

55:58.750 --> 56:00.750
光知道怎么说话

56:00.750 --> 56:02.750
你是看不到效果的

56:02.750 --> 56:04.750
你只会中文

56:04.750 --> 56:06.750
那你写不出来一篇文章

56:06.750 --> 56:08.750
你还得学习语文的环境

56:08.750 --> 56:10.750
看到效果

56:10.750 --> 56:12.750
因此我们在一开始学习通用语法的时候

56:12.750 --> 56:14.750
会设计到那么一点点

56:14.750 --> 56:16.750
一丢丢浏览器环境

56:16.750 --> 56:18.750
到时候学习的时候我会告诉大家

56:18.750 --> 56:20.750
这个东西

56:20.750 --> 56:22.750
这个代码不是ES标准里边的

56:22.750 --> 56:24.750
是浏览器环境里边给你提供的

56:24.750 --> 56:26.750
我会给你说明

56:26.750 --> 56:28.750
如果没有特别说明的话

56:28.750 --> 56:30.750
那么它就是标准里边的语法

56:30.750 --> 56:32.750
当时我会说明的

56:32.750 --> 56:34.750
ES它在运行的环境称为数主环境

56:34.750 --> 56:36.750
我们这门课只学习浏览器这个数主环境

56:36.750 --> 56:38.750
和手机端的数主环境

56:38.750 --> 56:40.750
都可以用ES

56:40.750 --> 56:42.750
这三个点非常重要

56:42.750 --> 56:44.750
一定要去理解清楚

56:44.750 --> 56:46.750
那么这里刚才说到

56:46.750 --> 56:48.750
2009年对吧

56:48.750 --> 56:50.750
之后就不再区分介石和ES了

56:50.750 --> 56:52.750
其实你要严格来说

56:52.750 --> 56:54.750
一定要严格来说要去扣字眼

56:54.750 --> 56:56.750
有什么区别呢

56:56.750 --> 56:58.750
往往我们说介石

56:58.750 --> 57:02.750
指的是在浏览器环境里边运行的ES代码

57:02.750 --> 57:04.750
往往是指的是在浏览器环境里边

57:04.750 --> 57:06.750
而说的是ES

57:06.750 --> 57:08.750
它指的是可以用于各种环境

57:08.750 --> 57:10.750
当然其实也不是

57:10.750 --> 57:12.750
现在我们都是一个意思的

57:12.750 --> 57:14.750
不用去纠结

57:14.750 --> 57:16.750
这块不用去纠结

57:16.750 --> 57:18.750
都应该是一个意思的

57:18.750 --> 57:20.750
因为介石早就不存在了

57:20.750 --> 57:22.750
介石已经不存在了

57:22.750 --> 57:24.750
ES6 2015年

57:24.750 --> 57:26.750
这一年也很重要

57:26.750 --> 57:28.750
就是ACMA宣布

57:28.750 --> 57:30.750
之后

57:30.750 --> 57:32.750
从ES6

57:32.750 --> 57:34.750
ES6开始

57:34.750 --> 57:36.750
开始

57:36.750 --> 57:38.750
版本号

57:38.750 --> 57:40.750
不在版本号使用

57:40.750 --> 57:42.750
应该这样说

57:42.750 --> 57:44.750
使用联号

57:44.750 --> 57:46.750
作为版本号

57:46.750 --> 57:48.750
也就是说ES6

57:48.750 --> 57:50.750
只是我们习惯上的称呼

57:50.750 --> 57:52.750
ES6的真正

57:52.750 --> 57:54.750
称呼

57:54.750 --> 57:56.750
为什么呢

57:56.750 --> 57:58.750
ES2015

57:58.750 --> 58:00.750
ES7

58:00.750 --> 58:02.750
真正的称呼为ES2016

58:02.750 --> 58:04.750
以后

58:04.750 --> 58:06.750
我们ES7

58:06.750 --> 58:08.750
后面还说ES8

58:08.750 --> 58:10.750
ES6-ES7

58:10.750 --> 58:12.750
其实不是标准的叫法

58:12.750 --> 58:14.750
标准的叫法叫做ES2015和ES2016

58:14.750 --> 58:16.750
之后就是ES2017

58:16.750 --> 58:18.750
ES2018-ES2019

58:18.750 --> 58:20.750
就是用这样的称呼来进行的

58:20.750 --> 58:22.750
这里我说一下

58:22.750 --> 58:24.750
好了

58:24.750 --> 58:26.750
这也就是关于简单的介绍

58:26.750 --> 58:28.750
其实我用的时间还是蛮多的

58:28.750 --> 58:30.750
介绍的语言解释

58:30.750 --> 58:32.750
主要是通过介绍历史

58:32.750 --> 58:34.750
认识到一些关键的词汇

58:34.750 --> 58:36.750
关键的词汇

58:36.750 --> 58:38.750
以及一些关键的知识点

58:38.750 --> 58:40.750
什么V8

58:40.750 --> 58:42.750
ES

58:42.750 --> 58:44.750
GS支付

58:44.750 --> 58:46.750
ACPA组织

58:46.750 --> 58:48.750
接下来我们来说一下介事的特点

58:48.750 --> 58:50.750
介事的

58:50.750 --> 58:52.750
介事语言特性

58:52.750 --> 58:56.380
有这么几个点

58:56.380 --> 58:58.380
大家要知道

58:58.380 --> 59:00.380
介事语言里面有哪些特点

59:00.380 --> 59:02.380
第一个特点

59:02.380 --> 59:04.380
它是一个解释性的语言

59:04.380 --> 59:06.380
解释性语言

59:06.380 --> 59:08.380
好

59:08.380 --> 59:10.380
以后在Markdown里面

59:10.380 --> 59:12.380
我们写了一个横杠

59:12.380 --> 59:14.380
这个横杠表示一个无序列表

59:14.380 --> 59:16.380
在Markdown里面写这个横杠

59:16.380 --> 59:18.380
表示一个无序列表

59:18.380 --> 59:20.380
大家看一下

59:20.380 --> 59:22.380
伸出来就这个样子

59:22.380 --> 59:24.380
一个无序列表

59:24.380 --> 59:26.380
很简单

59:26.380 --> 59:28.380
这样说

59:28.380 --> 59:30.380
解释性语言

59:30.380 --> 59:32.380
解释性语言是什么意思呢

59:32.380 --> 59:34.380
就是有些语言

59:34.380 --> 59:36.380
它是编译型语言

59:36.380 --> 59:38.380
编译型语言

59:38.380 --> 59:40.380
比方说

59:40.380 --> 59:42.380
C语言

59:42.380 --> 59:44.380
Java语言

59:44.380 --> 59:46.380
C-Sharp语言

59:46.380 --> 59:48.380
编语型语言

59:48.380 --> 59:50.380
我这里说一下

59:50.380 --> 59:52.380
关于Java语言这些东西

59:52.380 --> 59:54.380
还有C++

59:54.380 --> 59:56.380
在有些教程里面

59:56.380 --> 59:58.380
也说到Java语言

59:58.380 --> 01:00:00.380
不算一个严格意义上的

01:00:00.380 --> 01:00:02.380
编译型语言

01:00:02.380 --> 01:00:04.380
它在编译型和解释型

01:00:04.380 --> 01:00:06.380
和解释型之间

01:00:06.380 --> 01:00:08.380
解语型和解释型之间

01:00:08.380 --> 01:00:10.380
C-Sharp也是

01:00:10.380 --> 01:00:12.380
这个东西不用去纠结

01:00:12.380 --> 01:00:14.380
看你怎么去看待

01:00:14.380 --> 01:00:16.380
什么叫编译呢

01:00:16.380 --> 01:00:18.380
我这里说一下这个编译

01:00:18.380 --> 01:00:20.380
编译大家理解一下就行了

01:00:20.380 --> 01:00:22.380
就毫必说你拿到一本英文书

01:00:22.380 --> 01:00:24.380
现在你看不懂英文

01:00:24.380 --> 01:00:26.380
看不懂英文

01:00:26.380 --> 01:00:28.380
需要有一个人来帮你把

01:00:28.380 --> 01:00:30.380
这本英文书呢

01:00:30.380 --> 01:00:32.380
翻译成一个完整的中文

01:00:32.380 --> 01:00:34.380
中文书籍

01:00:34.380 --> 01:00:36.380
它会形成一个结果

01:00:36.380 --> 01:00:38.380
翻译的结果就是一个中文书籍

01:00:38.380 --> 01:00:40.380
那么你去看什么呢

01:00:40.380 --> 01:00:42.380
看这个翻译的结果

01:00:42.380 --> 01:00:44.380
看这个中文书籍

01:00:44.380 --> 01:00:46.380
就包括我很喜欢一本小说

01:00:46.380 --> 01:00:48.380
叫做《冰与火之歌》

01:00:48.380 --> 01:00:50.380
它每次出来过后

01:00:50.380 --> 01:00:52.380
翻译都要翻译一年多

01:00:52.380 --> 01:00:54.380
所以它会经过一个翻译的过程

01:00:54.380 --> 01:00:56.380
编译型语言

01:00:58.380 --> 01:01:00.380
会经过一个

01:01:00.380 --> 01:01:02.380
翻译的过程

01:01:02.380 --> 01:01:04.380
那么

01:01:04.380 --> 01:01:06.380
负责翻译的

01:01:06.380 --> 01:01:08.380
叫做

01:01:08.380 --> 01:01:10.380
编译器

01:01:10.380 --> 01:01:12.380
就是翻译者表示我们书籍里面的

01:01:12.380 --> 01:01:14.380
译者叫做编译器

01:01:14.380 --> 01:01:16.380
它是负责翻译的

01:01:16.380 --> 01:01:18.380
翻译的结果

01:01:18.380 --> 01:01:20.380
叫做

01:01:20.380 --> 01:01:22.380
编译结果

01:01:22.380 --> 01:01:24.380
翻译的结果叫做编译结果

01:01:24.380 --> 01:01:26.380
它会有一个翻译结果

01:01:26.380 --> 01:01:28.380
编译型语言一个特点就是

01:01:28.380 --> 01:01:30.380
它会有一个编译结果

01:01:30.380 --> 01:01:32.380
比方说咱们的C语言

01:01:32.380 --> 01:01:34.380
C语言编译过后是啥呢

01:01:34.380 --> 01:01:36.380
编译过后就直接是汇编了

01:01:36.380 --> 01:01:38.380
或者是机器码了

01:01:38.380 --> 01:01:40.380
加把语言和C下部语言不一样

01:01:40.380 --> 01:01:42.380
加把语言和C下部语言不一样

01:01:42.380 --> 01:01:44.380
它翻译的结果不是最终的机器码

01:01:44.380 --> 01:01:46.380
它是什么呢

01:01:46.380 --> 01:01:47.380
字节码

01:01:47.380 --> 01:01:49.380
C下部语言翻译结果叫做

01:01:49.380 --> 01:01:50.380
中间代码

01:01:50.380 --> 01:01:53.380
它有一个另外一种代码形式

01:01:53.380 --> 01:01:55.380
那么那种形式还需要经过一次翻译

01:01:55.380 --> 01:01:57.380
还需要经过一次翻译

01:01:57.380 --> 01:01:58.380
不过呢

01:01:58.380 --> 01:02:00.380
如果把编译这样理解的话

01:02:00.380 --> 01:02:02.380
如果你把编译是

01:02:02.380 --> 01:02:04.380
从一个代码状态翻译成另外一个代码状态

01:02:04.380 --> 01:02:06.380
那就叫翻译的话

01:02:06.380 --> 01:02:08.380
那么这些都是编译型语言

01:02:08.380 --> 01:02:10.380
如果理解的编译

01:02:10.380 --> 01:02:12.380
是把它编译成为机器码

01:02:12.380 --> 01:02:14.380
字节码的话

01:02:15.380 --> 01:02:18.380
那么C下部语言和加把语言

01:02:18.380 --> 01:02:20.380
都不能算是编译型语言

01:02:20.380 --> 01:02:21.380
无所谓

01:02:21.380 --> 01:02:23.380
这个东西不用去纠结

01:02:23.380 --> 01:02:25.380
我们这里就按照这样的说法来说

01:02:25.380 --> 01:02:28.380
把它叫做编译型语言

01:02:28.380 --> 01:02:30.380
什么叫解释型语言呢

01:02:30.380 --> 01:02:32.380
解释型语言

01:02:33.380 --> 01:02:35.380
解释型语言就是类似于

01:02:35.380 --> 01:02:37.380
介石对吧

01:02:37.380 --> 01:02:39.380
类似于介石或者是PGP

01:02:40.380 --> 01:02:42.380
这些都是解释型语言

01:02:42.380 --> 01:02:43.380
解释型语言有个特点

01:02:43.380 --> 01:02:46.380
它没有一个明显的翻译过程

01:02:46.380 --> 01:02:48.380
它有没有翻译肯定有翻译

01:02:48.380 --> 01:02:49.380
没有翻译的话没法执行

01:02:49.380 --> 01:02:51.380
因为电脑它只能执行零和一

01:02:51.380 --> 01:02:53.380
就是二镜制的代码

01:02:53.380 --> 01:02:55.380
它不能执行我们这些单词

01:02:55.380 --> 01:02:56.380
都不认识的

01:02:56.380 --> 01:02:57.380
它必须要有翻译

01:02:57.380 --> 01:02:59.380
但是它没有一个明显的翻译过程

01:02:59.380 --> 01:03:01.380
并且没有翻译结果

01:03:01.380 --> 01:03:03.380
解释型语言

01:03:03.380 --> 01:03:05.380
没有翻译的结果

01:03:05.380 --> 01:03:07.380
也就是没有编译结果

01:03:07.380 --> 01:03:09.380
你看不到编译结果

01:03:09.380 --> 01:03:11.380
比方说

01:03:11.380 --> 01:03:13.380
还是哪一本书为例

01:03:13.380 --> 01:03:15.380
编译型语言是把这本书

01:03:15.380 --> 01:03:16.380
翻译过后

01:03:16.380 --> 01:03:18.380
经过了一段时间

01:03:18.380 --> 01:03:19.380
翻译过后

01:03:19.380 --> 01:03:21.380
翻译成为一个就是

01:03:21.380 --> 01:03:22.380
一本新的书对不对

01:03:22.380 --> 01:03:23.380
一本新的书

01:03:23.380 --> 01:03:25.380
而解释型语言是怎么做的呢

01:03:25.380 --> 01:03:28.380
它不会给你翻译成一本书

01:03:28.380 --> 01:03:30.380
你就看这句话

01:03:30.380 --> 01:03:32.380
我们直接看英文书起

01:03:32.380 --> 01:03:33.380
第一句话不认识对吧

01:03:33.380 --> 01:03:34.380
不认识

01:03:34.380 --> 01:03:35.380
ok 查词典

01:03:35.380 --> 01:03:37.380
这个查单词

01:03:37.380 --> 01:03:38.380
查完了过后

01:03:38.380 --> 01:03:39.380
第一句话我看懂了

01:03:39.380 --> 01:03:40.380
接下来直接看第二句话

01:03:40.380 --> 01:03:42.380
第二句话一看

01:03:42.380 --> 01:03:44.380
不认识查单词就看懂了

01:03:44.380 --> 01:03:46.380
它是一句一句翻译

01:03:46.380 --> 01:03:48.380
不会形成一个编译结果

01:03:48.380 --> 01:03:49.380
你明白这个意思吗

01:03:49.380 --> 01:03:51.380
这就是解释型语言

01:03:51.380 --> 01:03:53.380
解释它是个解释型语言

01:03:53.380 --> 01:03:54.380
所以说解释

01:03:54.380 --> 01:03:56.380
它不会有一个编译结果

01:03:56.380 --> 01:03:58.380
它不会有一个编译结果

01:03:58.380 --> 01:03:59.380
它有没有翻译

01:03:59.380 --> 01:04:00.380
有翻译它是一点点翻译的

01:04:00.380 --> 01:04:01.380
看一句翻译一下

01:04:01.380 --> 01:04:02.380
看一句翻译一下

01:04:02.380 --> 01:04:04.380
它是用这种方式的

01:04:04.380 --> 01:04:07.380
那么哪种好哪种差呢

01:04:07.380 --> 01:04:09.380
不能这样子说

01:04:09.380 --> 01:04:10.380
是各有优势

01:04:10.380 --> 01:04:11.380
各有优势

01:04:11.380 --> 01:04:12.380
我得简单说一下吧

01:04:12.380 --> 01:04:13.380
简单说一下

01:04:13.380 --> 01:04:16.380
就是编译型语言的优势在哪呢

01:04:16.380 --> 01:04:18.380
它的优势在于

01:04:18.380 --> 01:04:21.380
它的执行速度很快

01:04:21.380 --> 01:04:22.380
你想啊

01:04:22.380 --> 01:04:23.380
我直接给你拿

01:04:23.380 --> 01:04:24.380
执行是什么意思

01:04:24.380 --> 01:04:25.380
执行就是看书

01:04:25.380 --> 01:04:26.380
看书

01:04:26.380 --> 01:04:27.380
我直接拿给你

01:04:27.380 --> 01:04:28.380
一本就是中文书

01:04:28.380 --> 01:04:29.380
你是不是看得很快

01:04:29.380 --> 01:04:30.380
对不对

01:04:30.380 --> 01:04:31.380
我给你拿一本英文书

01:04:31.380 --> 01:04:32.380
你是不是看得很慢

01:04:32.380 --> 01:04:33.380
你要自己一点点去翻译

01:04:33.380 --> 01:04:34.380
对不对

01:04:34.380 --> 01:04:35.380
一点点翻译

01:04:35.380 --> 01:04:36.380
说看得很慢

01:04:36.380 --> 01:04:37.380
哪怕有个同生传译在那里

01:04:37.380 --> 01:04:38.380
也看得慢

01:04:38.380 --> 01:04:39.380
对不对

01:04:39.380 --> 01:04:40.380
一个同生传译

01:04:40.380 --> 01:04:41.380
他马上给你翻译出来

01:04:41.380 --> 01:04:42.380
你看一句话

01:04:42.380 --> 01:04:43.380
指着这句话

01:04:43.380 --> 01:04:44.380
他马上给你翻译出来

01:04:44.380 --> 01:04:45.380
也看得很慢

01:04:45.380 --> 01:04:46.380
我们还是记一下吧

01:04:46.380 --> 01:04:47.380
记一下吧

01:04:47.380 --> 01:04:52.380
就是编译型语言的优势

01:04:52.380 --> 01:04:54.380
优点

01:04:54.380 --> 01:04:55.380
优点

01:04:55.380 --> 01:04:57.380
就是执行速度快

01:04:57.380 --> 01:04:58.380
速度快

01:04:58.380 --> 01:05:00.380
那么它的缺点有没有呢

01:05:00.380 --> 01:05:01.380
它肯定有缺点

01:05:01.380 --> 01:05:02.380
肯定有缺点

01:05:02.380 --> 01:05:03.380
比方说一本书

01:05:03.380 --> 01:05:04.380
给你翻译成中文了

01:05:04.380 --> 01:05:05.380
翻译成中文了

01:05:05.380 --> 01:05:06.380
那么这个时候

01:05:06.380 --> 01:05:07.380
又跑来另外一个东西

01:05:07.380 --> 01:05:09.380
跑来一个就是阿拉伯人

01:05:09.380 --> 01:05:10.380
他又看不懂中文

01:05:10.380 --> 01:05:11.380
他看不懂英文

01:05:11.380 --> 01:05:12.380
也看不懂中文

01:05:12.380 --> 01:05:13.380
是不是又得编译一次

01:05:13.380 --> 01:05:14.380
又得重新编译一次

01:05:14.380 --> 01:05:15.380
对吧

01:05:15.380 --> 01:05:16.380
编译成阿拉伯文

01:05:16.380 --> 01:05:17.380
对吧

01:05:17.380 --> 01:05:18.380
所以说呢

01:05:18.380 --> 01:05:19.380
某一个编译结果

01:05:19.380 --> 01:05:21.380
某个编译结果

01:05:21.380 --> 01:05:23.380
就是翻译的结果

01:05:23.380 --> 01:05:28.380
不能适用于各种环境

01:05:28.380 --> 01:05:31.380
难以应该说难以适用于

01:05:31.380 --> 01:05:33.380
难以适用于各种环境

01:05:33.380 --> 01:05:35.380
他有这么一个问题

01:05:35.380 --> 01:05:37.380
我们把这个问题叫做

01:05:37.380 --> 01:05:39.380
跨平台

01:05:39.380 --> 01:05:42.380
跨平台障碍

01:05:42.380 --> 01:05:43.380
在语言里面

01:05:43.380 --> 01:05:44.380
啥是这么回事

01:05:44.380 --> 01:05:46.380
就是你编译的结果

01:05:46.380 --> 01:05:47.380
编译成为一个

01:05:47.380 --> 01:05:48.380
就是最终代码

01:05:48.380 --> 01:05:49.380
那么这个就最终代码了

01:05:49.380 --> 01:05:51.380
在这个操作系统

01:05:51.380 --> 01:05:52.380
这个版本里面

01:05:52.380 --> 01:05:53.380
执行没问题

01:05:53.380 --> 01:05:54.380
到了另外一个操作系统

01:05:54.380 --> 01:05:55.380
另外一个版本

01:05:55.380 --> 01:05:57.380
或者是CPU型号一遍

01:05:57.380 --> 01:05:59.380
什么那些

01:05:59.380 --> 01:06:01.380
硬件设备的环境一遍

01:06:01.380 --> 01:06:03.380
你可能就不能执行了

01:06:03.380 --> 01:06:04.380
因为不同的硬件设备

01:06:04.380 --> 01:06:08.380
不同的就是操作系统

01:06:08.380 --> 01:06:09.380
它能够识别代码

01:06:09.380 --> 01:06:10.380
是不太一样的

01:06:10.380 --> 01:06:11.380
是有区别的

01:06:11.380 --> 01:06:13.380
它会造成这么一个问题

01:06:13.380 --> 01:06:15.380
不过这个问题倒是可以解决

01:06:15.380 --> 01:06:17.380
像加把语言和C-SAP语言

01:06:17.380 --> 01:06:18.380
就解决这个问题

01:06:18.380 --> 01:06:19.380
它怎么解决的呢

01:06:19.380 --> 01:06:21.380
它是先编译的时候

01:06:21.380 --> 01:06:23.380
先不要编译成最终代码

01:06:23.380 --> 01:06:24.380
先不要编译成

01:06:24.380 --> 01:06:25.380
直接可以执行的代码

01:06:25.380 --> 01:06:26.380
先编译成一种

01:06:26.380 --> 01:06:28.380
中间状态的代码

01:06:28.380 --> 01:06:29.380
然后再等到执行的时候

01:06:29.380 --> 01:06:31.380
再经过一段翻译

01:06:31.380 --> 01:06:32.380
翻译成最终代码

01:06:32.380 --> 01:06:34.380
它是经过这么一种方式的

01:06:34.380 --> 01:06:35.380
在执行的时候

01:06:35.380 --> 01:06:37.380
根据当前的执行环境

01:06:37.380 --> 01:06:39.380
再经过一个编译

01:06:39.380 --> 01:06:41.380
所以说C-SAP语言和加把语言

01:06:41.380 --> 01:06:43.380
它第一次运行的速度要慢一些

01:06:43.380 --> 01:06:45.380
因为它有一个再翻译的过程

01:06:45.380 --> 01:06:47.380
有一个再翻译的过程

01:06:47.380 --> 01:06:49.380
了解一下就行了

01:06:49.380 --> 01:06:50.380
它有一个缺点

01:06:50.380 --> 01:06:51.380
缺点就是难以跨平台

01:06:51.380 --> 01:06:54.380
还有一个就是

01:06:54.380 --> 01:06:57.380
部属繁琐

01:06:57.380 --> 01:06:59.380
因为你部属的时候

01:06:59.380 --> 01:07:01.380
这个部属我怎么讲

01:07:01.380 --> 01:07:02.380
现在还没有想到部属

01:07:02.380 --> 01:07:03.380
就是我们很多东西

01:07:03.380 --> 01:07:04.380
写的代码很多东西

01:07:04.380 --> 01:07:06.380
我们写的这个环境

01:07:06.380 --> 01:07:07.380
叫做开发环境

01:07:07.380 --> 01:07:09.380
最终我们程序运行

01:07:09.380 --> 01:07:11.380
不是在我们这个电脑上运行的

01:07:11.380 --> 01:07:12.380
比方说你写的一个网站

01:07:12.380 --> 01:07:15.380
你在自己的什么

01:07:15.380 --> 01:07:17.380
3000多4000多的笔记本上写完了

01:07:17.380 --> 01:07:19.380
我们要放到好几万的

01:07:19.380 --> 01:07:20.380
好几10万的服务器上运行的

01:07:20.380 --> 01:07:22.380
不是在你这个电脑上运行的

01:07:22.380 --> 01:07:24.380
所以运行的时候

01:07:24.380 --> 01:07:25.380
你要部属

01:07:25.380 --> 01:07:27.380
这个部属的过程比较繁琐

01:07:27.380 --> 01:07:28.380
因为比方说

01:07:28.380 --> 01:07:30.380
你把它部属到服务器上

01:07:30.380 --> 01:07:31.380
把你的代码放到服务器上了

01:07:31.380 --> 01:07:32.380
你放的是什么

01:07:32.380 --> 01:07:33.380
放的是编译结果

01:07:33.380 --> 01:07:34.380
对吧

01:07:34.380 --> 01:07:36.380
你肯定放的不是你的元代

01:07:36.380 --> 01:07:37.380
你肯定要执行的

01:07:37.380 --> 01:07:39.380
因为要执行的是这个编译结果

01:07:39.380 --> 01:07:41.380
所以你肯定是把编译结果放上去

01:07:41.380 --> 01:07:42.380
放上去过后

01:07:42.380 --> 01:07:43.380
你到时候有一天

01:07:43.380 --> 01:07:46.380
你就做了一个改动

01:07:46.380 --> 01:07:48.380
做了一点小小的改动

01:07:48.380 --> 01:07:49.380
非常非常小的改动

01:07:49.380 --> 01:07:50.380
就改动了一个文件的一个制服

01:07:50.380 --> 01:07:51.380
但对不起

01:07:51.380 --> 01:07:53.380
你需要整个过程

01:07:53.380 --> 01:07:54.380
要全部走一遍

01:07:54.380 --> 01:07:56.380
又要重新编译

01:07:56.380 --> 01:07:58.380
又要把重新把编译结果

01:07:58.380 --> 01:07:59.380
要全部重新替换到服务器上的

01:07:59.380 --> 01:08:00.380
服务器上去

01:08:00.380 --> 01:08:02.380
所以说它部属起来比较繁琐

01:08:02.380 --> 01:08:04.380
这是它的缺点

01:08:04.380 --> 01:08:05.380
对了

01:08:05.380 --> 01:08:06.380
编译型语言

01:08:06.380 --> 01:08:07.380
它的缺点

01:08:07.380 --> 01:08:08.380
解释型语言

01:08:08.380 --> 01:08:11.380
它刚好相反

01:08:11.380 --> 01:08:16.380
它的缺点是执行速度慢

01:08:16.380 --> 01:08:17.380
不能说很慢

01:08:17.380 --> 01:08:18.380
稍慢

01:08:18.380 --> 01:08:19.380
慢那么一点点

01:08:19.380 --> 01:08:21.380
因为现在的解释型语言

01:08:21.380 --> 01:08:22.380
速度已经快多了

01:08:22.380 --> 01:08:23.380
我们之前说过

01:08:23.380 --> 01:08:24.380
V8引擎对吧

01:08:24.380 --> 01:08:25.380
甚至在某些时候

01:08:25.380 --> 01:08:26.380
都甚至超过了编译型语言了

01:08:26.380 --> 01:08:28.380
在某些时候

01:08:28.380 --> 01:08:30.380
它的速度稍慢

01:08:30.380 --> 01:08:31.380
但是这个慢

01:08:31.380 --> 01:08:33.380
几乎是可以忽略不及

01:08:33.380 --> 01:08:39.080
然后它的优点是

01:08:39.080 --> 01:08:41.080
它的优点是跨平台

01:08:41.080 --> 01:08:45.080
因为它是根据你的实际情况

01:08:45.080 --> 01:08:46.080
根据你的实际情况

01:08:46.080 --> 01:08:47.080
它没有一个编译结果

01:08:47.080 --> 01:08:48.080
你是看一句翻译一句

01:08:48.080 --> 01:08:49.080
你是阿拉伯人

01:08:49.080 --> 01:08:50.080
你看一句这句

01:08:50.080 --> 01:08:52.080
马上给你翻译成阿拉伯文

01:08:52.080 --> 01:08:53.080
明白这个意思吧

01:08:53.080 --> 01:08:54.080
它所谓是跨平台

01:08:54.080 --> 01:08:56.080
跨越各种计算机硬件

01:08:56.080 --> 01:08:58.080
和软件环境都可以用

01:08:58.080 --> 01:09:00.080
然后部署简单

01:09:00.080 --> 01:09:02.080
部署非常非常简单

01:09:02.080 --> 01:09:03.080
因为你改了代码过后

01:09:03.080 --> 01:09:05.080
你只需要把这个

01:09:05.080 --> 01:09:06.080
你扔到服务器上的

01:09:06.080 --> 01:09:07.080
就是你的原代码

01:09:07.080 --> 01:09:09.080
就直接把你的代码扔到服务器上

01:09:09.080 --> 01:09:10.080
没有什么编译过程

01:09:10.080 --> 01:09:11.080
你本地怎么写的

01:09:11.080 --> 01:09:13.080
扔到服务器就是什么样子

01:09:13.080 --> 01:09:14.080
然后你比如说

01:09:14.080 --> 01:09:16.080
你改动了其中一个文件

01:09:16.080 --> 01:09:17.080
你只需要去替换那个文件就行了

01:09:17.080 --> 01:09:19.080
你其他不用去替换

01:09:19.080 --> 01:09:21.080
它部署很简单

01:09:21.080 --> 01:09:24.080
这是关于介事员的特点

01:09:24.080 --> 01:09:26.080
介事它是个解释型语言

01:09:27.080 --> 01:09:29.080
好 第二个特点

01:09:31.080 --> 01:09:33.080
它是一个若类型

01:09:33.080 --> 01:09:35.080
若类型语言

01:09:35.080 --> 01:09:37.080
什么叫若类型呢

01:09:37.080 --> 01:09:38.080
首先我们要说一下类型

01:09:38.080 --> 01:09:40.080
其实我们后边有专门一节课

01:09:40.080 --> 01:09:41.080
专门来讲数据类型

01:09:41.080 --> 01:09:43.080
就是咱们现实世界里边

01:09:43.080 --> 01:09:44.080
有各种各样的数据

01:09:44.080 --> 01:09:45.080
注意是数据

01:09:45.080 --> 01:09:46.080
不是数字

01:09:46.080 --> 01:09:48.080
两者是千差万别的

01:09:48.080 --> 01:09:49.080
数据是什么意思呢

01:09:49.080 --> 01:09:50.080
就是信息

01:09:50.080 --> 01:09:52.080
有用的信息

01:09:52.080 --> 01:09:54.080
一个电脑是数据

01:09:54.080 --> 01:09:56.080
一个烟灰缸是数据

01:09:56.080 --> 01:09:57.080
一个桌子是数据

01:09:57.080 --> 01:09:58.080
一个人是数据

01:09:58.080 --> 01:09:59.080
一手音乐是数据

01:09:59.080 --> 01:10:00.080
一个电影是数据

01:10:00.080 --> 01:10:01.080
这些都是信息

01:10:01.080 --> 01:10:04.080
它包含了信息的东西都是数据

01:10:04.080 --> 01:10:06.080
但是现实世界里边不同的数据

01:10:06.080 --> 01:10:07.080
它有不同的类型

01:10:07.080 --> 01:10:09.080
为什么要区分类型呢

01:10:09.080 --> 01:10:11.080
比方说你吃饭

01:10:11.080 --> 01:10:13.080
吃饭得用碗吧

01:10:13.080 --> 01:10:14.080
不管是大碗还是小碗

01:10:14.080 --> 01:10:15.080
你得用碗吧

01:10:15.080 --> 01:10:16.080
你不能包一个马桶吃饭吧

01:10:16.080 --> 01:10:17.080
对吧

01:10:17.080 --> 01:10:18.080
那么碗和马桶之间

01:10:18.080 --> 01:10:19.080
是不是不同的数据类型

01:10:19.080 --> 01:10:21.080
它类型是不一样的

01:10:21.080 --> 01:10:22.080
不同类型的数据

01:10:22.080 --> 01:10:24.080
它能做的事情是不一样的

01:10:24.080 --> 01:10:25.080
它们的特点也不一样

01:10:25.080 --> 01:10:26.080
比方说数字

01:10:26.080 --> 01:10:28.080
数字是一种数据

01:10:28.080 --> 01:10:30.080
那么数字有什么特点

01:10:30.080 --> 01:10:31.080
它可以进行数学运算

01:10:31.080 --> 01:10:33.080
比方说咱们

01:10:33.080 --> 01:10:35.080
比方说哪里的身高

01:10:35.080 --> 01:10:36.080
加上你的体重

01:10:36.080 --> 01:10:38.080
你甭管这个是有什么意义

01:10:38.080 --> 01:10:39.080
没什么意义

01:10:39.080 --> 01:10:40.080
但是可不可以相加

01:10:40.080 --> 01:10:41.080
最可以相加

01:10:41.080 --> 01:10:42.080
那我现在再说

01:10:42.080 --> 01:10:44.080
哪里的名字去加上你的

01:10:44.080 --> 01:10:46.080
就是体重

01:10:46.080 --> 01:10:48.080
有没有意义呢

01:10:48.080 --> 01:10:49.080
也没有什么意义

01:10:49.080 --> 01:10:50.080
但是它能不能相加

01:10:50.080 --> 01:10:51.080
它不能相加

01:10:51.080 --> 01:10:52.080
一个是

01:10:52.080 --> 01:10:53.080
它们两个的数据类型

01:10:53.080 --> 01:10:54.080
是不一样的

01:10:54.080 --> 01:10:55.080
比方说

01:10:55.080 --> 01:10:57.080
我们的就是

01:10:57.080 --> 01:10:59.080
姓名

01:10:59.080 --> 01:11:00.080
是一个字符串

01:11:00.080 --> 01:11:01.080
一个字符

01:11:01.080 --> 01:11:02.080
是一些文字

01:11:02.080 --> 01:11:03.080
那么这些文字

01:11:03.080 --> 01:11:04.080
是没法跟数

01:11:04.080 --> 01:11:05.080
跟数字之间进行

01:11:05.080 --> 01:11:06.080
数学运算的

01:11:06.080 --> 01:11:07.080
就算要运算

01:11:07.080 --> 01:11:08.080
你得把它转化

01:11:08.080 --> 01:11:10.080
成数字才能进行运算

01:11:10.080 --> 01:11:11.080
所以不同的类型

01:11:11.080 --> 01:11:12.080
有不同的特点

01:11:12.080 --> 01:11:14.080
什么叫做类型语言呢

01:11:14.080 --> 01:11:16.080
什么叫做类型语言呢

01:11:16.080 --> 01:11:18.080
就是存放的数据

01:11:18.080 --> 01:11:20.080
类型可变

01:11:20.080 --> 01:11:22.080
就是弱类型语言

01:11:22.080 --> 01:11:24.080
JS是个弱类型语言

01:11:24.080 --> 01:11:26.780
什么意思呢

01:11:26.780 --> 01:11:27.780
就是我们之后

01:11:27.780 --> 01:11:28.780
会学习什么辨量

01:11:28.780 --> 01:11:29.780
长量这些东西

01:11:29.780 --> 01:11:30.780
比方辨量

01:11:30.780 --> 01:11:31.780
辨量是做什么呢

01:11:31.780 --> 01:11:32.780
存数据的

01:11:32.780 --> 01:11:33.780
对吧

01:11:33.780 --> 01:11:34.780
在JS里边

01:11:34.780 --> 01:11:35.780
这个辨量里边

01:11:35.780 --> 01:11:36.780
它存数据

01:11:36.780 --> 01:11:38.780
它一会儿可以存一个数字

01:11:38.780 --> 01:11:40.780
同一个辨量

01:11:40.780 --> 01:11:41.780
它一会儿呢

01:11:41.780 --> 01:11:42.780
又可以存一个

01:11:42.780 --> 01:11:43.780
一个文字

01:11:43.780 --> 01:11:44.780
一串文本

01:11:44.780 --> 01:11:45.780
一会儿呢

01:11:45.780 --> 01:11:46.780
又可以存一个

01:11:46.780 --> 01:11:47.780
就是

01:11:47.780 --> 01:11:48.780
还存啥

01:11:48.780 --> 01:11:49.780
但是有些人

01:11:50.780 --> 01:11:51.780
但是有些东西

01:11:51.780 --> 01:11:52.780
你们现在没学过

01:11:52.780 --> 01:11:53.780
没法去理的

01:11:53.780 --> 01:11:54.780
总之它的类型

01:11:54.780 --> 01:11:55.780
是可以变化的

01:11:55.780 --> 01:11:56.780
它存的东西的类型

01:11:56.780 --> 01:11:57.780
是可以变化的

01:11:57.780 --> 01:11:58.780
这是弱类型语言

01:11:58.780 --> 01:11:59.780
而对应的呢

01:11:59.780 --> 01:12:00.780
叫做强类型语言

01:12:00.780 --> 01:12:02.780
强类型语言呢

01:12:02.780 --> 01:12:04.780
它存放的数据

01:12:04.780 --> 01:12:06.780
存

01:12:06.780 --> 01:12:08.780
存放的数据

01:12:08.780 --> 01:12:10.780
就是类型

01:12:10.780 --> 01:12:11.780
不可变

01:12:11.780 --> 01:12:12.780
那就对应的

01:12:12.780 --> 01:12:13.780
不可变

01:12:13.780 --> 01:12:14.780
你之前存放的数字

01:12:14.780 --> 01:12:15.780
对不起

01:12:15.780 --> 01:12:17.780
以后永远只能存数字

01:12:17.780 --> 01:12:18.780
就这个区

01:12:18.780 --> 01:12:19.780
只能存数字

01:12:19.780 --> 01:12:20.780
你要存其他东西

01:12:20.780 --> 01:12:21.780
ok

01:12:21.780 --> 01:12:22.780
你再开一个变量

01:12:22.780 --> 01:12:23.780
再开一个内存空间

01:12:23.780 --> 01:12:24.780
去存其他数据

01:12:24.780 --> 01:12:25.780
那么这一块内存空间

01:12:25.780 --> 01:12:26.780
只能存数字的

01:12:27.780 --> 01:12:28.780
弱类型和强类型

01:12:28.780 --> 01:12:29.780
各有各的优势

01:12:29.780 --> 01:12:30.780
各有各的缺点

01:12:30.780 --> 01:12:32.780
咱们来说一下

01:12:32.780 --> 01:12:34.780
就直接在这里写吧

01:12:34.780 --> 01:12:35.780
优点

01:12:35.780 --> 01:12:36.780
优点是什么呢

01:12:36.780 --> 01:12:37.780
灵活

01:12:37.780 --> 01:12:39.780
非常非常灵活

01:12:39.780 --> 01:12:40.780
你看一会儿可以存

01:12:40.780 --> 01:12:41.780
变这个数

01:12:41.780 --> 01:12:42.780
这个数据

01:12:42.780 --> 01:12:43.780
一会儿是那个数据

01:12:43.780 --> 01:12:44.780
它非常灵活

01:12:44.780 --> 01:12:45.780
而且呢

01:12:45.780 --> 01:12:46.780
易上手

01:12:46.780 --> 01:12:47.780
它没有对你

01:12:47.780 --> 01:12:48.780
没有什么限制

01:12:48.780 --> 01:12:49.780
没有限制

01:12:49.780 --> 01:12:51.780
但是不严谨

01:12:51.780 --> 01:12:52.780
不严谨

01:12:52.780 --> 01:12:54.780
开发大型应用的时候

01:12:54.780 --> 01:12:55.780
可能会出问题

01:12:55.780 --> 01:12:57.780
会遇到很多很多的问题

01:12:57.780 --> 01:12:58.780
它不严谨

01:12:58.780 --> 01:12:59.780
但是那介石

01:12:59.780 --> 01:13:00.780
虽然是弱类型语言

01:13:00.780 --> 01:13:02.780
它也肯定有这个问题

01:13:02.780 --> 01:13:03.780
它不严谨

01:13:03.780 --> 01:13:04.780
它天生

01:13:04.780 --> 01:13:06.780
就不是用来开发大型应用的

01:13:06.780 --> 01:13:07.780
所以说在前几年

01:13:07.780 --> 01:13:08.780
前几年一个技术

01:13:08.780 --> 01:13:09.780
叫做TypeScript

01:13:10.780 --> 01:13:11.780
这门课程呢

01:13:11.780 --> 01:13:12.780
我也录了的

01:13:12.780 --> 01:13:13.780
专门录成一个视频的

01:13:13.780 --> 01:13:14.780
是一个后期的课程

01:13:14.780 --> 01:13:15.780
也要学到很多知识过

01:13:15.780 --> 01:13:16.780
才能看

01:13:16.780 --> 01:13:18.780
当时那个大会上的就说

01:13:18.780 --> 01:13:19.780
第一句话就说

01:13:19.780 --> 01:13:20.780
介石天生

01:13:20.780 --> 01:13:22.780
就不是用来构建大型应用的

01:13:22.780 --> 01:13:23.780
因为它就是呢

01:13:23.780 --> 01:13:25.780
做一些页面的动画效果的

01:13:25.780 --> 01:13:26.780
一些动态效果

01:13:26.780 --> 01:13:27.780
用户交户的

01:13:27.780 --> 01:13:28.780
一些提高用户体验的效果的

01:13:28.780 --> 01:13:29.780
做一些小的功能

01:13:29.780 --> 01:13:31.780
它不是来开发大型应用的

01:13:31.780 --> 01:13:32.780
但是现在介石

01:13:32.780 --> 01:13:34.780
由于执行速度这么快了

01:13:34.780 --> 01:13:35.780
它已经具备了开发

01:13:35.780 --> 01:13:36.780
大型应用的能力了

01:13:36.780 --> 01:13:38.780
所以说就有很多的工具啊

01:13:38.780 --> 01:13:40.780
很多的插件啊

01:13:40.780 --> 01:13:41.780
很多的语言

01:13:41.780 --> 01:13:42.780
新的语言出来

01:13:42.780 --> 01:13:43.780
帮它完善

01:13:43.780 --> 01:13:44.780
这个不严谨的问题

01:13:44.780 --> 01:13:47.780
介石本身是不严谨的

01:13:47.780 --> 01:13:49.780
但是有很多工具呢

01:13:49.780 --> 01:13:51.780
可以帮你解决这个问题

01:13:51.780 --> 01:13:52.780
来解决这个问题

01:13:52.780 --> 01:13:53.780
这个问题是可以解决的

01:13:53.780 --> 01:13:55.780
这是弱类型语言的

01:13:55.780 --> 01:13:56.780
这是缺点对吧

01:13:56.780 --> 01:13:58.780
这是缺点

01:13:58.780 --> 01:14:00.780
缺点

01:14:00.780 --> 01:14:02.780
强类型的是不是刚好相反

01:14:02.780 --> 01:14:03.780
对不对

01:14:03.780 --> 01:14:04.780
强类型

01:14:04.780 --> 01:14:05.780
它的优点呢

01:14:05.780 --> 01:14:06.780
就是严谨

01:14:06.780 --> 01:14:08.780
它适合用来开发大型应用

01:14:08.780 --> 01:14:09.780
比方说什么C语言

01:14:09.780 --> 01:14:10.780
C++

01:14:10.780 --> 01:14:11.780
C sharp

01:14:11.780 --> 01:14:13.780
这些都是强类型语言

01:14:13.780 --> 01:14:15.780
弱类型语言比方说介石

01:14:15.780 --> 01:14:16.780
PGP

01:14:16.780 --> 01:14:17.780
这些都是弱类型

01:14:17.780 --> 01:14:18.780
强类型语言

01:14:18.780 --> 01:14:19.780
它一个是严谨

01:14:19.780 --> 01:14:20.780
用于开发

01:14:20.780 --> 01:14:22.780
可以适合开发大型应用

01:14:22.780 --> 01:14:25.780
它的缺点呢就是

01:14:25.780 --> 01:14:27.780
缺点就是不灵活

01:14:27.780 --> 01:14:29.780
不灵活

01:14:29.780 --> 01:14:31.780
我们说加法语言

01:14:31.780 --> 01:14:33.780
最大的购并是啥呢

01:14:33.780 --> 01:14:34.780
你去查一下

01:14:34.780 --> 01:14:35.780
网上说加法语言

01:14:35.780 --> 01:14:37.780
批评加法语言的就是

01:14:37.780 --> 01:14:38.780
啰唆

01:14:38.780 --> 01:14:39.780
啰唆

01:14:39.780 --> 01:14:40.780
本来多简单一个事

01:14:40.780 --> 01:14:42.780
它要写很多很多代码

01:14:42.780 --> 01:14:44.780
才能去把它说清楚

01:14:44.780 --> 01:14:45.780
语言是做什么

01:14:45.780 --> 01:14:46.780
就是表达的

01:14:46.780 --> 01:14:48.780
它表达起来很啰唆

01:14:48.780 --> 01:14:49.780
为什么呢

01:14:49.780 --> 01:14:50.780
因为它严谨

01:14:50.780 --> 01:14:51.780
但是缺点就是

01:14:51.780 --> 01:14:52.780
不灵活

01:14:52.780 --> 01:14:53.780
不灵活

01:14:53.780 --> 01:14:54.780
啰唆

01:14:54.780 --> 01:14:55.780
然后呢

01:14:55.780 --> 01:14:56.780
不易上手

01:14:56.780 --> 01:14:57.780
对亲手不太友好

01:14:57.780 --> 01:14:58.780
亲手学的这个

01:14:58.780 --> 01:14:59.780
限制太多了

01:14:59.780 --> 01:15:01.780
对于各种各样的限制太多了

01:15:01.780 --> 01:15:04.780
这是关于这两种语言的对比

01:15:04.780 --> 01:15:05.780
这是

01:15:05.780 --> 01:15:06.780
第二个特点

01:15:06.780 --> 01:15:07.780
弱类型语言

01:15:07.780 --> 01:15:10.780
这里我顺便说一句

01:15:10.780 --> 01:15:11.780
通常

01:15:11.780 --> 01:15:13.780
还有一种说法就是

01:15:13.780 --> 01:15:16.780
将弱类型的

01:15:16.780 --> 01:15:19.780
就是解释型

01:15:19.780 --> 01:15:21.780
语言

01:15:21.780 --> 01:15:22.780
称为

01:15:22.780 --> 01:15:24.780
脚本语言

01:15:24.780 --> 01:15:25.780
脚本语言

01:15:25.780 --> 01:15:27.780
像PGP脚本语言

01:15:27.780 --> 01:15:29.780
解释脚本语言

01:15:29.780 --> 01:15:30.780
我们通常这样子写

01:15:30.780 --> 01:15:31.780
通常这样子说

01:15:31.780 --> 01:15:33.780
把它称为脚本语言

01:15:33.780 --> 01:15:36.780
这是第二个特点

01:15:36.780 --> 01:15:38.780
第三个特点

01:15:38.780 --> 01:15:40.780
单线程

01:15:41.780 --> 01:15:42.780
这些概念

01:15:42.780 --> 01:15:43.780
现在接触起来

01:15:43.780 --> 01:15:45.780
都是有点模糊的

01:15:45.780 --> 01:15:46.780
没关系

01:15:46.780 --> 01:15:48.780
反正我尽量用通俗的话

01:15:48.780 --> 01:15:49.780
给你解释清楚

01:15:49.780 --> 01:15:50.780
有这么个印象

01:15:50.780 --> 01:15:52.780
有这么个印象就行了

01:15:52.780 --> 01:15:54.780
单线程是什么意思呢

01:15:54.780 --> 01:15:58.780
单线程的意思就是

01:15:58.780 --> 01:16:00.780
上一件事情没有做完

01:16:00.780 --> 01:16:04.780
下一件事情必须等待

01:16:04.780 --> 01:16:09.780
上一件事情没有做完

01:16:10.780 --> 01:16:17.780
下一件事情必须等待

01:16:17.780 --> 01:16:19.780
就单线程

01:16:19.780 --> 01:16:20.780
我们到时候写代码

01:16:20.780 --> 01:16:23.780
写代码是从上到下进行执行的

01:16:23.780 --> 01:16:25.780
上一句代码没有执行完

01:16:25.780 --> 01:16:26.780
下一句代码必须等着

01:16:26.780 --> 01:16:27.780
你必须要等

01:16:27.780 --> 01:16:29.780
等他上一句代码执行完了过后

01:16:29.780 --> 01:16:30.780
才能下一步

01:16:30.780 --> 01:16:31.780
才能执行

01:16:31.780 --> 01:16:33.780
这个现象叫做同步

01:16:33.780 --> 01:16:35.780
叫做同步

01:16:35.780 --> 01:16:37.780
同步现象

01:16:37.780 --> 01:16:38.780
同步的

01:16:38.780 --> 01:16:41.780
你上一个没完

01:16:41.780 --> 01:16:42.780
上一个没完

01:16:42.780 --> 01:16:43.780
就是下一个必须要等待

01:16:43.780 --> 01:16:45.780
就是同步的

01:16:45.780 --> 01:16:47.780
我们把这个现象叫做同步现象

01:16:47.780 --> 01:16:49.780
单线程就有这么一个同步现象

01:16:49.780 --> 01:16:51.780
如果是多线程的话

01:16:51.780 --> 01:16:54.780
那么几件事情可以一起做

01:16:54.780 --> 01:16:55.780
但是多线程一个不好的地方

01:16:55.780 --> 01:16:56.780
在于什么呢

01:16:56.780 --> 01:16:57.780
好像听起来很合理

01:16:57.780 --> 01:16:58.780
很合理

01:16:58.780 --> 01:16:59.780
几件事情一起做

01:16:59.780 --> 01:17:00.780
很难控制程序

01:17:00.780 --> 01:17:03.780
程序经常写代码会写出问题

01:17:03.780 --> 01:17:06.780
为什么之前我说到这个人

01:17:06.780 --> 01:17:08.780
在监视里面不说到这个人吗

01:17:08.780 --> 01:17:10.780
开发肉的解释这个人

01:17:10.780 --> 01:17:11.780
就这个人

01:17:11.780 --> 01:17:14.780
他为什么想用解释来写服务器

01:17:14.780 --> 01:17:16.780
就是因为看中了

01:17:16.780 --> 01:17:18.780
解释单线程这个特点

01:17:18.780 --> 01:17:19.780
单线程这个特点

01:17:19.780 --> 01:17:21.780
你看很多其他语言

01:17:21.780 --> 01:17:22.780
像加瓦、C元、C家家

01:17:22.780 --> 01:17:24.780
C shop的语言都是多线程的

01:17:24.780 --> 01:17:27.780
程序一旦策略到多个线程

01:17:27.780 --> 01:17:29.780
就会遇到很多很多的问题

01:17:29.780 --> 01:17:31.780
程序的复杂度一下子飙升

01:17:31.780 --> 01:17:33.780
但是单线程的复杂度很简单

01:17:33.780 --> 01:17:34.780
上去执行完了过后

01:17:34.780 --> 01:17:35.780
下雨执行

01:17:35.780 --> 01:17:36.780
下雨再执行完了过后

01:17:36.780 --> 01:17:37.780
下雨执行

01:17:37.780 --> 01:17:38.780
变得很简单

01:17:38.780 --> 01:17:40.780
整个程序的模式非常非常清晰

01:17:40.780 --> 01:17:43.780
这就是单线程的优势

01:17:43.780 --> 01:17:45.780
那么单线程一个不好的地方

01:17:45.780 --> 01:17:46.780
在于什么呢

01:17:46.780 --> 01:17:47.780
在于它的效率

01:17:47.780 --> 01:17:48.780
执行效率

01:17:48.780 --> 01:17:49.780
又是执行效率的问题了

01:17:49.780 --> 01:17:50.780
执行效率还会变低

01:17:50.780 --> 01:17:52.780
因为有些事情可能要做很久

01:17:52.780 --> 01:17:54.780
那么做这些事情的时候

01:17:54.780 --> 01:17:55.780
比方说前面这句话

01:17:55.780 --> 01:17:56.780
前面一句代码

01:17:56.780 --> 01:17:57.780
它要等待三秒钟过后

01:17:57.780 --> 01:17:58.780
才能执行完

01:17:58.780 --> 01:18:00.780
那么下面的代码就一直要等

01:18:00.780 --> 01:18:01.780
等三秒钟

01:18:01.780 --> 01:18:02.780
那么这三秒钟之内

01:18:02.780 --> 01:18:03.780
我们能不能去做别的事呢

01:18:04.780 --> 01:18:05.780
所以说

01:18:05.780 --> 01:18:07.780
JS又多了一个特点

01:18:07.780 --> 01:18:08.780
叫做异步

01:18:09.780 --> 01:18:10.780
异步

01:18:10.780 --> 01:18:12.780
这个异步现在我们没法解释

01:18:12.780 --> 01:18:13.780
没法解释

01:18:13.780 --> 01:18:14.780
我们只能简单的理解为

01:18:14.780 --> 01:18:18.780
提高单线程的执行效率

01:18:18.780 --> 01:18:20.780
它可以解决这个问题

01:18:20.780 --> 01:18:22.780
之前开放肉的JS

01:18:23.780 --> 01:18:25.780
那个小伙伴

01:18:25.780 --> 01:18:27.780
他为什么看到肉的JS

01:18:27.780 --> 01:18:28.780
不仅因为它是单线程

01:18:28.780 --> 01:18:29.780
并且它有异步

01:18:29.780 --> 01:18:31.780
来解决这个执行效率的问题

01:18:31.780 --> 01:18:32.780
我们后面会讲异步

01:18:32.780 --> 01:18:33.780
都很后边了

01:18:33.780 --> 01:18:34.780
我们现在不用管

01:18:34.780 --> 01:18:35.780
现在不用管

01:18:36.780 --> 01:18:38.780
这是JS这么一些特点

01:18:38.780 --> 01:18:39.780
解释型语言

01:18:39.780 --> 01:18:42.780
弱内型语言单线程异步

01:18:42.780 --> 01:18:43.780
单线程异步

01:18:43.780 --> 01:18:44.780
看一下还有啥呢

01:18:44.780 --> 01:18:45.780
还有啥

01:18:47.780 --> 01:18:50.780
好像就没啥了

01:18:50.780 --> 01:18:52.780
好像就没啥了

01:18:53.780 --> 01:18:54.780
之前一个重要点

01:18:54.780 --> 01:18:55.780
本期课非常非常重要点

01:18:55.780 --> 01:18:57.780
我之前也反复强调过

01:18:57.780 --> 01:18:58.780
就是JS也好

01:18:58.780 --> 01:18:59.780
EX也好

01:18:59.780 --> 01:19:00.780
他们都一个意思

01:19:01.780 --> 01:19:02.780
他们是一个通用

01:19:02.780 --> 01:19:03.780
编程语言

01:19:03.780 --> 01:19:04.780
现在

01:19:04.780 --> 01:19:05.780
它不再是说

01:19:05.780 --> 01:19:07.780
只能在浏览期段执行

01:19:08.780 --> 01:19:10.780
它可以在各种环境里边执行

01:19:10.780 --> 01:19:12.780
因为在标准里边

01:19:12.780 --> 01:19:14.780
在标准里边

01:19:14.780 --> 01:19:15.780
它只规定了这个语言

01:19:15.780 --> 01:19:17.780
怎么去说话

01:19:17.780 --> 01:19:18.780
毫必是中文一样

01:19:18.780 --> 01:19:19.780
怎么去说话

01:19:19.780 --> 01:19:20.780
它没有说

01:19:20.780 --> 01:19:21.780
这个话

01:19:21.780 --> 01:19:23.780
在不同的环境里边怎么办

01:19:23.780 --> 01:19:24.780
因此它是一个

01:19:24.780 --> 01:19:25.780
通用的编程语言

01:19:25.780 --> 01:19:26.780
我们这门课学习

01:19:26.780 --> 01:19:28.780
先学习怎么说话

01:19:28.780 --> 01:19:29.780
它的语法规则

01:19:29.780 --> 01:19:30.780
有哪些特点

01:19:30.780 --> 01:19:32.780
这个语言有哪些规范

01:19:32.780 --> 01:19:33.780
学习的是EX标准

01:19:33.780 --> 01:19:34.780
先学习这个东西

01:19:34.780 --> 01:19:35.780
EX5

01:19:36.780 --> 01:19:37.780
然后后边

01:19:38.780 --> 01:19:39.780
再学习

01:19:39.780 --> 01:19:41.780
再把它放到浏览期环境里边

01:19:41.780 --> 01:19:43.780
怎么去进行操作

01:19:43.780 --> 01:19:45.780
浏览期给它加入了哪些新东西

01:19:45.780 --> 01:19:47.780
我们来学习浏览期环境里边怎么操作

01:19:47.780 --> 01:19:48.780
最核心的是啥

01:19:48.780 --> 01:19:50.780
最核心的是不是前面的

01:19:50.780 --> 01:19:51.780
所以说

01:19:51.780 --> 01:19:52.780
为什么说EX

01:19:52.780 --> 01:19:54.780
就是学习技艺是前边难的

01:19:54.780 --> 01:19:55.780
因为前边一是

01:19:55.780 --> 01:19:56.780
我看不到丰富的效果

01:19:56.780 --> 01:19:58.780
因为还没有学习到浏览期的一块

01:19:58.780 --> 01:20:00.780
只是语言本身

01:20:00.780 --> 01:20:01.780
一是还没有看到丰富的效果

01:20:01.780 --> 01:20:02.780
第二个呢

01:20:02.780 --> 01:20:03.780
它规则非常非常多

01:20:03.780 --> 01:20:04.780
但是

01:20:04.780 --> 01:20:06.780
如果你把前面这个砍过去

01:20:06.780 --> 01:20:07.780
你想一下这个刀

01:20:07.780 --> 01:20:08.780
想一下这个现象

01:20:08.780 --> 01:20:09.780
是不是很恐怖

01:20:09.780 --> 01:20:11.780
你把语言学会了

01:20:11.780 --> 01:20:12.780
后边放到浏览期

01:20:12.780 --> 01:20:14.780
学习一下浏览期里边

01:20:14.780 --> 01:20:15.780
给你提供了哪些新东西

01:20:15.780 --> 01:20:16.780
学到之后

01:20:16.780 --> 01:20:17.780
浏览期搞定

01:20:17.780 --> 01:20:18.780
以后学习漏的接识

01:20:18.780 --> 01:20:19.780
学习一下漏的接识

01:20:19.780 --> 01:20:20.780
给你提供了哪些新东西

01:20:20.780 --> 01:20:21.780
漏的接识搞定

01:20:21.780 --> 01:20:22.780
以后学习手机端

01:20:22.780 --> 01:20:23.780
又学习下手机端

01:20:23.780 --> 01:20:25.780
给你提供了哪些东西

01:20:25.780 --> 01:20:26.780
手机端搞定

01:20:28.780 --> 01:20:29.780
就很简单了

01:20:29.780 --> 01:20:30.780
但是它有没有难度

01:20:30.780 --> 01:20:31.780
有一些难度

01:20:31.780 --> 01:20:32.780
但是它难度

01:20:32.780 --> 01:20:33.780
你学说话的难度

01:20:33.780 --> 01:20:34.780
是不一样的

01:20:34.780 --> 01:20:35.780
明白这个意思吗

01:20:36.780 --> 01:20:37.780
OK

01:20:37.780 --> 01:20:38.780
咱们这一块呢

01:20:38.780 --> 01:20:39.780
简单介绍了一下

01:20:39.780 --> 01:20:40.780
就是介绍了蛮多了

01:20:41.780 --> 01:20:42.780
就加了接识

01:20:42.780 --> 01:20:44.780
语言的概述

01:20:44.780 --> 01:20:45.780
了解这些东西

01:20:45.780 --> 01:20:47.780
还是非常非常重要的

01:20:47.780 --> 01:20:48.780
OK

01:20:48.780 --> 01:20:49.780
咱们这一块呢

01:20:49.780 --> 01:20:50.780
就到这了

01:20:50.780 --> 01:20:51.780
拜拜

