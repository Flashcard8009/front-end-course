WEBVTT

00:00.000 --> 00:15.760
这节课呢 咱们来聊一聊 关于作用域和币包

00:16.400 --> 00:21.160
这也是韩束他带来的一个现象 咱们首先来说作用域

00:22.760 --> 00:30.000
啊 因为这一块呢 要讲的东西呢 稍微有一点点多啊 所以说呢 我们这里呢 专门拿一些课来讲

00:31.000 --> 00:40.080
好 介石中啊 他有两种作用域 其实我们以后 你们以后学了这个ES6 就是新版本之后呢 还有三种作用域了

00:40.920 --> 00:45.280
现在呢 我们介石里边有两种作用域 一种是有两种

00:46.680 --> 00:54.000
作用域 什么叫作用域啊 作用域就是一块区域啊 一块区域一个环境啊 一个运行环境啊 作用域

00:55.000 --> 01:11.280
表示一个代码区域啊 也表示一个运行环境啊 在这个环境中有些东西呢 是可以用的 有些东西那是不能用的啊 我们主要说的是变量啊 有些变量能用 有些变量不能用

01:12.000 --> 01:19.680
好 介石里边的有两种作用域 分别是全局作用域 什么叫全局作用域呢 就是直接在

01:20.400 --> 01:28.800
就像我们之前写的代码 在学函数之前写的代码全部是全局环境 因为直接在脚奔坡里边写的代码就是全局作用域

01:30.160 --> 01:34.200
直接书写的代码 直接在脚奔中

01:35.240 --> 01:40.160
书写的 书写的代码 他们所处的位置呢 就是全局作用域

01:40.960 --> 01:48.680
好 另外一个作用域呢 叫做函数作用域 函数作用域 次指的是什么呢 函数中的代码

01:50.240 --> 01:54.440
函数里边的代码是在函数作用域里边 好 比方说咱们举个例子

01:56.320 --> 02:11.480
这是这是一 咱们看一下啊 比方说我们这里写一块代码啊 随便写写写写一个变量 a 随便写啊 一个变量b 写写啊 ok

02:13.080 --> 02:20.200
这些代码呢 他们所处的作用域啊 所处的环境叫做全局作用域啊 全局作用域

02:21.120 --> 02:24.120
然后呢 比方说这里一个函数啊 一个函数test

02:25.680 --> 02:35.960
test 好 那么这里边的代码呢 这里边的代码他所处的环境呢 是函数作用域啊 介石里边就这两种作用域啊 其实就这两种作用域

02:36.560 --> 02:41.960
好 这是全局作用域 这是函数作用域 函数作用域

02:42.880 --> 02:47.000
好 全局作用域有什么样的特点呢 在全局

02:48.000 --> 02:51.880
在全局作用域中生命的变量

02:53.520 --> 02:56.240
会被提升到 提升到到哪呢

02:57.640 --> 03:02.080
到全局作用就是这提升到脚奔块

03:04.640 --> 03:07.520
脚奔块的顶部啊

03:08.520 --> 03:15.320
这是我们之前说过的 对吧 他会被提升到脚奔块的顶部啊 比方说哪怕你这个两个变量是在这里生命的

03:15.600 --> 03:19.000
也相当于是啥呢 相当于是在这里生命的A和B

03:19.880 --> 03:24.160
那么下面下边给他复制而已 他会被提升到脚奔块的顶部

03:25.240 --> 03:30.520
并且呢 并且还有什么呢 我们之前讲过了 并且会做 并且

03:32.800 --> 03:35.080
会成为什么 会成为

03:36.080 --> 03:39.640
全局对象的属性 全局对象的属性

03:40.240 --> 03:43.200
这是我们之前讲过的 对吧 他会成为温斗对象的属性

03:44.520 --> 03:46.480
好 另外一个呢 是函数作用域

03:47.360 --> 03:57.000
在函数作用域啊 作用域中生命的变量啊 生命的变量会被提升到函数的顶部

03:57.200 --> 04:04.680
而不是缺而不是脚奔块的顶部了啊 会被提升到函数的顶部 比方说啊函数这里边啊 函数这里边

04:05.160 --> 04:09.560
生命的变量啊 生命的变量A和B 他会被提升到哪呢 看着啊

04:10.560 --> 04:12.160
比方 随便瞎写

04:13.320 --> 04:20.840
他会被这两面 这里边的A和B 他会被提升到哪呢 他会被提升到函数的顶部 他只在函数里边啊 他没跑出去

04:21.400 --> 04:25.120
他会被提升到这 看没啊 相当于是你这样的写了

04:25.840 --> 04:29.880
他会被提升到函数的顶部 所以说这里两个叔叔啊 肯定饭啊 肯定饭

04:31.040 --> 04:36.440
你看这意思啊 这是两种作用域啊 他会被提升到函数的顶部 并且

04:37.440 --> 04:41.040
不会成为 啊 权局对象的属性

04:42.760 --> 04:46.240
他不会成为权局对象的属性 也就是说说啥呢

04:47.080 --> 04:50.880
就这边呢 我把比方说啊 C和D嘛 换个名字

04:53.240 --> 04:54.120
把变成C和D

04:55.760 --> 05:02.400
这个C和D啊 他并不会成为温度对象的属性啊 比方说啊 咱们运行一下这个test 运行一下这个函数

05:02.880 --> 05:06.200
好像是运行到过后了 这两个 有两个变量嘛 C和D

05:06.480 --> 05:14.850
看他能不能成为温度对象的属性 看一下啊 刷新啊 刷新

05:15.490 --> 05:18.170
啊 这个叔叔能明白吧 这个叔叔没问题吧啊

05:18.730 --> 05:28.410
二三四 你看这个字母创意吧 叔叔A和B 对吧 这里边叔出两个undefined 为什么呢 他会提升对吧 他不会爆错的啊 他会提升到函数的顶部啊 函数的顶部

05:29.050 --> 05:35.450
好 那么这里呢 我们看一下温度对象里边有没有C这个属性 是没有 有没有D这个属性 是没有

05:35.930 --> 05:45.530
对吧 我们也可以这样判断 C啊 C 这个属性在不在温度对象中啊 是没有啊 相反的A和B 是不是在温度对象里边

05:47.130 --> 05:51.530
温度啊 你看A这个属性在温度对象里边 看没

05:52.650 --> 05:55.290
啊 这里面啊 就是这个这个这个地方的含义

05:56.010 --> 05:59.690
他这里边定义了变量 他不会成为温度对象的属性 所以

06:00.650 --> 06:07.850
啊 因此 函数中声明的内容啊 声明的东西啊 声明的变量

06:09.370 --> 06:13.450
不会导致全局对象的污染

06:14.250 --> 06:16.810
我们说之前好像说过这个问题 对吧 说过这个问题

06:17.130 --> 06:22.090
就是说 我们声明的变量呢 会污染全局变量 但是函数它不一样

06:22.570 --> 06:27.290
函数里边声明的变量它不会污染全局变量 污染会有什么问题呢

06:27.530 --> 06:33.130
如果你想啊 你的代码写多了 你会给全局对象里边加了很多很多东西 加一大堆东西

06:33.690 --> 06:39.530
那么加一大堆东西过后呢 就有可能会倒成名称的冲突啊 比方说你到时候写了10个接式文件

06:40.010 --> 06:45.450
那你能保证这个10个接式文件里边 全局环境里边 它变量没有冲突吗 它肯定有冲突啊

06:45.850 --> 06:50.010
两个变量的名字一样的 那么就会导致之后的变量了 把之前的覆盖掉了

06:50.490 --> 06:54.490
啊 就会导致这个问题 那之前的有些功能呢 就可能会出问题啊 所以说

06:55.130 --> 06:59.530
函数终于的好处在于 它不会导致全局对象的污染

07:00.410 --> 07:05.610
也因为如此啊 也因为如此 就是尽量的把功能

07:07.530 --> 07:14.330
装在函数中啊 应该叫封装啊 封装 就是把功能封装在函数里边

07:15.050 --> 07:19.530
函数中 这样子呢 就是尽可能的啊 减少

07:20.090 --> 07:23.290
全局对象的污染 能不能消灭全局对象的污染的

07:24.010 --> 07:31.530
消灭不了啊 你总归要污染的啊 你总归要污染的 因为哪怕你写的这个函数啊 你这些东西全在函数里边啊

07:31.770 --> 07:38.170
假设全在函数里边 哪怕你写了这个函数啊 哪怕你写了这个函数 这个函数呢也会变成啥呢

07:38.730 --> 07:40.890
他也会变成啥呢 他也会变成

07:42.650 --> 07:47.690
变成什么呢 变成温度对象的一个属性 因为我们之前说过函数他本身也有提升对吧

07:47.850 --> 07:50.170
他也会变成温度对象的属性 你看这个test

07:52.490 --> 07:55.290
看一下这个test 看是不是温度对象的属性啊 温度

07:55.930 --> 07:58.730
你看是不是true 对吧 我们可以打印出温度

07:59.450 --> 08:05.370
温度第二test 你看没问题吧啊 所以说函数本身啊

08:05.610 --> 08:10.810
他会成为温度对象的属性 但是函数内部的东西他不会不会污染全局

08:11.450 --> 08:14.250
呃 全局对象 但是函数本身会污染

08:15.210 --> 08:20.810
那么这里呢 有一种巧妙的做法啊 有一种巧妙的做法 是什么做法呢 这里要介绍一下啊

08:22.570 --> 08:23.610
呃 但是

08:24.730 --> 08:29.370
当函数成为啊 成为一个表达事实

08:31.370 --> 08:32.490
成为一个表达事实

08:33.130 --> 08:36.810
他既不会提升啊 既不会提升

08:37.530 --> 08:40.570
也不会污染全局对象

08:41.050 --> 08:46.650
啊 如果一个函数成为表达事的时候 他既不会提升也不会污染全局对象

08:47.050 --> 08:49.290
什么情况下他会成为一个表达事

08:50.650 --> 08:54.410
什么情况下会成为一个表达事呢 成为表达事的方式啊

08:55.850 --> 09:05.130
将函数变为一个函数表达事的方式之一啊 其中一种方式是什么呢

09:06.090 --> 09:12.010
啊 就是将函数用小扩号扩起来

09:13.930 --> 09:19.850
在JS语言他的语法判定里边 他只要发现了两端有个小扩号 他就会把它当成表达事

09:20.330 --> 09:26.170
啊 如果这个函数本身是一个表达事的话 他就不会提升也不会污染全局对象

09:26.570 --> 09:28.970
好 比方说 咱们再一个例子 换一个

09:30.570 --> 09:33.850
啊 比方说啊 这个函数 你看这个函数对吧 test

09:34.810 --> 09:38.010
啊 这个函数里边我们随便说出嘛 说出一个东西

09:38.490 --> 09:44.890
啊 这么一个函数 好 这个函数是不是会污染全局变量对吧 我们说尽量的少去污染全局变量

09:45.210 --> 09:48.490
好 那么现在呢 这个函数呢 它会污染全局变量 你看windle

09:48.970 --> 09:50.490
test 你看能得到这个函数

09:51.530 --> 09:53.930
好 接下来呢 我把这个函数变成表达事 你看着

09:54.810 --> 09:55.930
加上一个小扩号

09:56.970 --> 09:59.850
好 加上了小扩号过后 它就变成了一个表达事了

10:00.570 --> 10:02.090
好 咱们再来看 保存

10:02.490 --> 10:08.810
windle test 回彻

10:09.770 --> 10:15.130
你看就没了 就没这个函数了 再来看啊 test是不是在windle当中呢 inwindle

10:15.450 --> 10:19.770
你看 force 它就不会有提升 它既不会有提升

10:20.330 --> 10:24.890
也不会有什么 也不会有就是变成那个windle对象的属性了

10:25.530 --> 10:29.610
我说了没有 它既不会提升 也不会污染全局变对象

10:30.570 --> 10:32.330
但是这样子也会有一个问题

10:32.970 --> 10:41.610
然而 这样一来函数啊 无法通过名称调用了

10:41.930 --> 10:44.410
它无法通过名称调用了 因为它已经不存在了啊

10:44.490 --> 10:48.090
这个表达事执行完了就没了啊 这个表达事 这是个表达事啊

10:48.170 --> 10:51.050
这个表达事执行一个 这不是执行函数啊 生命一个函数

10:51.050 --> 10:53.210
然后表达事结束 表达事结束

10:53.770 --> 10:57.050
这个表达事里边东西就全部消失了啊 就全部消失了

10:57.370 --> 11:00.250
比方说你在后边还想调用这个函数 能调用吗

11:00.570 --> 11:02.810
你看一下啊 我们得去调用这个函数 保存

11:03.690 --> 11:06.970
它告诉你 函数不存在啊 函数不存在

11:07.530 --> 11:09.370
这个函数不能调用了 不能调用了

11:10.170 --> 11:12.890
那这有什么意义呢 这个东西 有啥意义呢

11:13.450 --> 11:16.250
看上去呢 好像没啥意义啊 好像没啥意义

11:16.490 --> 11:18.570
但是呢 有的时候啊 我们你想想

11:18.970 --> 11:21.370
我们有的时候要运行一些东西对吧 比方说啊

11:21.690 --> 11:23.210
比方说我们要运行这么一些东西

11:24.170 --> 11:26.970
运行要输出 输出这么一个制服串啊 输出A

11:27.690 --> 11:28.810
然后呢再输出B

11:29.930 --> 11:32.490
然后呢再输出C 假设我们要运行这些东西

11:32.970 --> 11:37.530
又定义了一些变量 比方说A A等于1 B等于2 C等于3

11:38.250 --> 11:41.930
那么比方说这里啊 输出A 输出A B C

11:42.650 --> 11:44.890
假设啊 假设我们要做这么一些事

11:45.370 --> 11:48.570
啊 我们在全局以前我们是在全局环境里边做的对吧

11:49.130 --> 11:51.930
在全局环境里边做 是不是会污染全局变量

11:52.410 --> 11:56.490
会污染全局变量 当然如果功能很少的话 倒是无所谓啊 影响不大

11:56.890 --> 11:58.330
但是如果功能一旦很多

11:58.890 --> 12:02.170
一旦很多功能的话 就会导致一个问题 污染全局变量越来越多

12:02.410 --> 12:04.250
那么导致后面的名称可能会冲突

12:04.890 --> 12:08.330
你写一个变 定一个变量的时候 声明一个变量的时候 你都非常糾结

12:08.650 --> 12:09.370
你生怕

12:10.170 --> 12:12.490
这个变量的名字 跟其他的名字重复了

12:12.810 --> 12:15.610
越写到后面越糾结 连声明一个变量都不敢声明了

12:16.010 --> 12:16.730
他就会导致

12:17.210 --> 12:18.650
污染全局对象

12:19.370 --> 12:24.570
那么怎么办呢 我们得想办法把他放到函数里边 把他放到函数里边去执行

12:24.970 --> 12:28.250
于是呢 我们就写了这么一个函数 看我再解释了这个过程

12:28.730 --> 12:31.850
我们就写了这个函数 让函数去执行这个东西

12:32.410 --> 12:35.690
这个函数没有啥参数 就把它当成一个全局环境来执行

12:36.010 --> 12:37.290
就是执行一个东西

12:37.690 --> 12:42.570
因为我们全局函数 全局环境里边 全局作用域里边本来就

12:43.850 --> 12:46.250
没有什么 就是一直执行 对吧 一开始就执行

12:46.730 --> 12:49.050
一开始就执行的东西 就是全局环境 对吧

12:49.850 --> 12:52.810
我把它放到函数里边 然后去调用函数来执行

12:53.130 --> 12:56.410
但是这样子一来又会有一个问题 就是这个函数本身

12:57.050 --> 12:59.210
它又会污染全局 全局作用域

12:59.690 --> 13:01.290
因此呢 我就把它当成表达式

13:01.770 --> 13:04.570
但是当成表达式之后呢 又会出现一个问题

13:04.730 --> 13:07.850
我调用不了这个函数了 你看 这个问题是一层一层导致过来的

13:09.210 --> 13:12.890
你也这个问题啊 你看现在调用不了这个函数了

13:13.210 --> 13:15.930
那么这个时候怎么办呢 我们这样子来处理

13:16.250 --> 13:18.650
你看着啊 非常巧妙的一种方式

13:19.610 --> 13:21.610
这是一个函数表达式 对吧

13:22.730 --> 13:26.090
这个表达式反会什么 我们知道表达式它总会反回一个东西

13:27.290 --> 13:30.330
这个表达式反会什么呢 反回的就是这个函数

13:30.810 --> 13:33.690
不是函数的执行结果啊 现在都没有执行

13:34.650 --> 13:38.650
这个表达式反回的是这个函数本身

13:39.210 --> 13:41.210
反回的是函数本身 就是这个特色本身

13:42.090 --> 13:45.210
好 于是呢 我们把它当成一个整体

13:45.690 --> 13:50.330
这是一个函数啊 这是一个函数 我们这样子来雕用

13:50.330 --> 13:54.890
你看 把它当成一个整体啊 这是一个函数 我们这样子来雕用

13:56.920 --> 14:00.680
下面不写了 你看 前边是一个函数

14:01.240 --> 14:04.520
后边两个小货号是不是雕用函数 对吧 雕用函数

14:05.000 --> 14:08.600
好 雕用函数的时候 你这里是传参数 这个没有参数 对吧

14:08.840 --> 14:11.800
没有参数 所以说不用传递了 不用传递参数 你看

14:12.360 --> 14:15.160
前面本来该写函数名的 是该写函数名的 对吧

14:15.480 --> 14:18.760
不用写函数名的 因为这个就把它当成一个整体 当成一个整体

14:18.760 --> 14:21.480
它就是个函数 然后这样子来雕用

14:21.960 --> 14:27.160
哎 这个写法很奇怪 对吧 很奇怪 但是呢 这样子能不能执行函数呢 我们来看一下 保存

14:28.280 --> 14:29.880
你看 是不是能执行函数

14:30.680 --> 14:34.680
并且呢 有没有五转全具变量 你看 abc 是不是 abc 是不是都没有

14:35.240 --> 14:40.040
a 没有 b 没有 还有什么 因为abc是在函数里边定义的

14:40.520 --> 14:44.920
它是函数作用于 它并不会五转全具 不会五转全具对象

14:45.960 --> 14:52.520
abc 是在函数里边生命的变量 它不会提升 它会提升到函数顶部 但是呢 不会成为全具对象的属性

14:54.600 --> 15:00.040
好 那么 abc 没有五转全具全具对象 那么它有没有五转全具对象呢 我们来看一下啊

15:02.760 --> 15:09.880
看一下它啊 太子本身有没有五转 所以也没五转 这样子呢 就最大的减少了全具对象的五转

15:10.760 --> 15:18.760
好 这个小括号呢 可以写到这里 皆是能识别 表示凋用这个函数啊 定一个函数 马上就凋用它 凋用一次就完事了

15:19.080 --> 15:26.600
啊 后边 你后边还能不能凋用它 永远凋用不了啊 因为你后边已经找不到它了啊 你找不到它了啊 你看 后边在凋用的时候

15:26.920 --> 15:33.560
保存 后边就凋用不了了啊 那么就可以把它当成一个全局环境来执行 因为我们的全局代码就是

15:33.960 --> 15:38.360
直接执行的 对吧 那么这个函数也是 我把它写到函数里边 直接执行这个函数

15:38.760 --> 15:44.600
是不是减少了全局对象的五转啊 那么这个小括号啊 它也可以写到这里边啊 也可以写到这里边

15:44.920 --> 15:54.120
你看 也一样啊 两种写法都可以 看你自己习惯的啊 看你习惯书写哪种 都可以啊 都可以啊 写到这里边也行啊 也行啊 你看 保存

15:55.240 --> 16:01.480
好 就这样子 好 像这种函数啊 我们把它叫做立即执行函数

16:01.800 --> 16:16.360
如果书写一个函数啊 书写一个函数 然后将其作为表达式 立即表达式

16:18.680 --> 16:28.520
进行调用 调用 把这个如果书写一个表达式函数啊 或者叫做函数表达式 然后将然后将其调用啊 立即调用

16:29.240 --> 16:38.760
立即调用啊 该函数呢啊 称之为 我们习惯上称之为立即执行函数啊 执行函数

16:40.680 --> 16:45.960
啊 它的单词的叫做IIFE啊 它的全程的叫写作啊

16:46.200 --> 16:56.600
我们把写过来啊 叫做immediate 厕力immediate 厕力immediate 厕力

16:57.880 --> 17:07.720
我写对没有 immediate 厕力 是这样写吗 查一下 查一下单词 就是立即啊 有点单词连忘了

17:08.680 --> 17:09.320
啊 翻译

17:12.520 --> 17:22.280
我单词呢 就是读啊 写啊 都不太行啊 都不太行啊 就是写不太行 读还可以啊 因为一篇英文稳当我能读 但是你让我写一下有点难读

17:22.760 --> 17:25.560
immediate 厕力啊 立即执行invoked

17:26.120 --> 17:29.640
invoked 表示执行 invoked 的意思呢 就是执行

17:30.920 --> 17:36.200
加上一个意地 加上一个地呢 表示被执行 对吧 立即被执行的什么呢 方可形

17:36.920 --> 17:38.920
方可形 expression

17:39.640 --> 17:43.640
expression 什么意思 方可形我们知道是函数的意思 对吧 expression 呢 表示的表达是

17:44.200 --> 17:54.360
立即被执行的函数表达是 称作为if e 有的时候我们说if e 啊 或者说立即执行函数 都是一个意思啊 这就是一个立即执行函数

17:55.240 --> 18:03.480
那么以后呢 我们写代码的时候 特别是一些全聚代码 我们都可以用这种方式来写啊 都可以用这种方式来写 包括我们之前做的作业对吧 做的作业你看这些

18:03.960 --> 18:06.920
啊 这些函数对吧 我们可以怎么写呢 我们可以这样子写

18:07.800 --> 18:08.600
啊 我们可以这样子写

18:11.160 --> 18:15.640
啊 就不用去写这个函数了啊 就这样子啊 就这样子 就不用去调用这个函数了

18:16.040 --> 18:22.440
把他放到一个表达式里边啊 把他放到一个表达式里边啊 这样子呢 尽量的减少全聚对象的污染啊 这样子执行

18:23.240 --> 18:32.680
啊 也可以把这个小货号写里边都可以啊 我们之前的代码就可以变成这个样子 这样子呢 就没有一个东西污染了全聚变量啊 全聚变量里边没有任何东西污染

18:33.880 --> 18:43.000
好 缺这个函数表达式啊 还不仅仅可以用在这个地方啊 以后呢 我们还会说到更多的地方 包括这个立即执行函数 还有更多的地方都可以使用它

18:44.520 --> 18:47.960
好 这是关于立即执行函数和函数表达式 好 这里我们再说一点

18:48.840 --> 18:52.520
含由于啊 由于大部分情况下

18:53.960 --> 19:03.320
函数表达式的函数名没有实际意义啊 他没有实际意义 因此呢 可以省略函数名

19:03.960 --> 19:08.120
函数的名字是可以省略的啊 比方说这里 你看这个函数表达式

19:08.840 --> 19:16.600
他的名字有意义吗 你之后能用这个名字来调用函数吗 是不能啊 这个名字没有任何意义这个函数的名字啊 他

19:16.920 --> 19:23.960
我运行的是就直接这样运行了 可能我就直接这样运行了 我也没有使用他的名字 因此他的名字没有什么意义啊 没有什么意义

19:24.440 --> 19:28.520
因此呢 他的名字是可以省略的 你看 这可以不写名字的

19:29.240 --> 19:34.040
这种函数呢 叫做匿名函数 没有名字的函数

19:36.280 --> 19:43.640
没有名字的函数只能出现在函数表达式里面啊 你带什么函数字面量啊 如果你是个正常的函数 你是不能这样写的啊 你是个正常的函数

19:44.440 --> 19:51.160
你不能这样写的啊 他要抱错的 他愚法都有问题啊 愚法都有问题啊 只有在函数表达式里面可以省略函数名

19:52.680 --> 19:57.160
函数表达式的函数名是没有什么实际意义的 可以省略函数名 我们以后呢还会学习

19:57.400 --> 20:03.320
其他的表达式的用法 函数表达式的其他用法 没有名字的函数 没有名字的函数

20:04.040 --> 20:06.680
称之为 称之为

20:07.800 --> 20:09.800
匿名函数 匿名函数

20:10.600 --> 20:13.000
这个函数没有名字 他称之为匿名函数

20:13.960 --> 20:17.400
啊 这就是啊 这就是这个函数表达式

20:18.440 --> 20:23.800
啊 那么他的作用与呢 跟普通函数是一样的啊 也是一样的 他内部的东西呢 只在内

20:24.680 --> 20:29.560
会提升到内就是函数里边的顶部啊 会提升到函数内部的顶部啊

20:29.880 --> 20:31.720
然后呢 出了这个区呢 就无效了 对吧

20:32.520 --> 20:35.160
啊 这是关于作用与这一块的知识

20:36.360 --> 20:37.960
好 下一个问题

20:40.520 --> 20:45.880
全局作用与啊 全作用与中可以使用的变量啊 作用与中

20:46.840 --> 20:53.050
作用与中可以使用的变量啊 可以使用的变量

20:55.900 --> 20:59.980
那么这里一个规则啊 其实我们上节课都讲过了 什么规则呢 就是啊

21:00.780 --> 21:04.940
全局作用与只能使用

21:05.740 --> 21:06.940
全局作用与

21:08.860 --> 21:11.420
作用与中生命的

21:12.700 --> 21:18.060
生命的变量啊 当然包括函数啊 包括函数 我说的变量呢 也包括函数啊 包括函数

21:18.380 --> 21:25.740
全局作用与里边只能使用全局作用与中生命的

21:26.220 --> 21:30.060
所以是生命的啊 就用挖关键制来生命的变量啊 包括函数

21:31.180 --> 21:34.060
好 函数作用与呢 不一样了

21:34.780 --> 21:43.500
函数作用与中不仅能使用自身作用与中生命的变量

21:44.220 --> 21:45.420
啊 包括函数

21:48.540 --> 21:52.540
还能使用外部环境中的

21:53.580 --> 21:58.220
外部环境啊 这里呢 注意我的用词是外部环境 而不是全局作用与

21:58.220 --> 22:01.100
啊 我们以后再说 还能使用外部环境的

22:02.220 --> 22:04.060
变量啊 包括函数

22:05.900 --> 22:08.540
好 什么意思 什么意思 我这里来讲一讲

22:10.380 --> 22:12.940
好 看着啊 我这里呢 写个函数

22:13.580 --> 22:15.660
函数名字叫做A 一个函数A

22:16.460 --> 22:18.620
这里边呢 有一个变量啊 有一个变量

22:19.180 --> 22:23.740
A啊 A 好 给它复制为234 234

22:24.940 --> 22:27.900
好 外面的全局作用与里边有一个变量

22:29.020 --> 22:33.580
啊 这个变量的名字呢 叫做G global

22:34.620 --> 22:38.140
啊 给它复制为abc 好 看着啊

22:39.100 --> 22:43.820
我在全局作用与里边能不能使用这个变量A呢

22:44.700 --> 22:46.380
能不能呢 不能

22:47.100 --> 22:52.220
全局作用与里边只能使用啥 全局作用与里边的变量

22:52.220 --> 22:55.100
它用不到这里边东西 用不到这里边东西

22:55.100 --> 22:58.380
好 这里边东西 它跟对于全局作用与来说

22:58.380 --> 23:01.420
这里边东西就好像是不存在一样

23:02.060 --> 23:03.980
所以说 我们这里输出A 会输出什么了

23:04.460 --> 23:06.460
会输出什么了 有一个同学说输出Andy Fan

23:07.020 --> 23:10.300
它会爆错 它会爆错 为什么会爆错呢

23:10.300 --> 23:12.460
因为你使用了一个并没有声明的变量

23:12.460 --> 23:14.620
所以说A is not defend 它爆错

23:15.020 --> 23:17.420
所以说全局作用与 它是不能使用这个玩意的

23:18.460 --> 23:22.460
诶 这里边就不一样了啊 韩束作用与里边就不一样了

23:22.460 --> 23:26.780
韩束作用与里边 它除了可以使用自身生命的东西之外

23:27.420 --> 23:30.860
还能使用外部环境 就是这个外部环境里边

23:30.860 --> 23:33.660
声明的东西 它能使用外部环境声明的东西

23:33.820 --> 23:37.660
所以说它这里边能使用A 也能使用什么了

23:37.660 --> 23:39.660
G 它也能使用G

23:39.660 --> 23:41.660
好 我们来调用这个韩束试一下

23:43.660 --> 23:45.660
看一下

23:45.660 --> 23:47.660
看 234 ABC

23:47.660 --> 23:49.660
这个ABC 是不是外部环境的

23:49.660 --> 23:53.660
外部环境的 这个外部环境的它可能是全局作用与

23:53.660 --> 23:55.660
也可能是别的东西

23:55.660 --> 23:57.660
为什么有可能是别的东西呢 咱们再来看

23:58.860 --> 24:01.660
我在这个A里边再声明一个韩束

24:01.660 --> 24:03.660
哇 可以这样的写 可以这样的写

24:03.660 --> 24:05.660
可以这样的写 韩束没什么特殊的

24:05.660 --> 24:08.660
它跟变量一样 它可以生命在任何位置

24:08.660 --> 24:11.660
它也可以生命在韩束里边

24:11.660 --> 24:13.660
也可以生命在韩束里边

24:13.660 --> 24:16.660
好 那么现在让我们看环境

24:16.660 --> 24:19.660
这个韩束B的外部环境是韩束A 对吧

24:19.660 --> 24:23.660
韩束A的外部环境呢 是全局作用与

24:23.660 --> 24:25.660
是全局作用与

24:25.660 --> 24:28.660
看一下 韩束B里边有个变量C

24:28.660 --> 24:32.660
有个变量B嘛 这个变量B

24:32.660 --> 24:34.660
5 6 7 随便写

24:34.660 --> 24:36.660
好 输出什么呢 它能不能使用B

24:36.660 --> 24:39.660
可以 它自己的东西对吧 自己的东西

24:39.660 --> 24:41.660
然后呢 能不能使用A

24:41.660 --> 24:44.660
可以 它的外部环境的东西可以使用

24:44.660 --> 24:46.660
能不能使用G呢 也可以

24:46.660 --> 24:48.660
也是它外部的环境

24:48.660 --> 24:51.660
那么外部的环境呢 都可以在B里边使用

24:51.660 --> 24:53.660
你看B里边可以使用这三个变量

24:53.660 --> 24:56.660
A里边能不能使用 B呢

24:56.660 --> 24:58.660
A里边能不能使用B

24:58.660 --> 24:59.660
它就不行

24:59.660 --> 25:01.660
A里边就不能使用B 看着啊

25:01.660 --> 25:04.660
保存 它说Bis not defined

25:04.660 --> 25:06.660
B没有定义

25:06.660 --> 25:08.660
A里边是不能使用B的

25:08.660 --> 25:10.660
但是A里边可以使用啥呢

25:10.660 --> 25:13.660
可以使用A 可以使用G

25:13.660 --> 25:15.660
所以还有这个韩束对吧

25:15.660 --> 25:16.660
还可以使用这个韩束

25:16.660 --> 25:17.660
还可以调用韩束

25:17.660 --> 25:19.660
在A里边可以调用这个韩束

25:19.660 --> 25:21.660
看一下啊

25:21.660 --> 25:23.660
先输出A的东西 再输出B的东西

25:23.660 --> 25:25.660
看一下

25:25.660 --> 25:27.660
你看 B里边都可以用

25:27.660 --> 25:30.660
A里边只能用自己的和外部环境的

25:30.660 --> 25:32.660
而全局里边它能用

25:32.660 --> 25:34.660
它可以得到A 你看可以调用A

25:34.660 --> 25:36.660
它能不能调用B的全局环境

25:36.660 --> 25:38.660
全局环境里边能不能调用B呢

25:38.660 --> 25:41.660
它就不能 因为B是A里边的东西

25:41.660 --> 25:44.660
A是在全局环境中生命的

25:44.660 --> 25:46.660
因此全局环境中可以调用

25:46.660 --> 25:49.660
但是B呢 它是在A里边生命的

25:49.660 --> 25:51.660
只有A能调用

25:51.660 --> 25:54.660
只有A里边能用 外边就用不了了

25:54.660 --> 25:57.660
你看 B是NOT DEFEND

25:57.660 --> 26:00.660
在全局环境中是不能使用这个B的

26:00.660 --> 26:03.660
其实这就是环境 看没有 这就是环境

26:03.660 --> 26:06.660
它无论是哪个韩束

26:06.660 --> 26:08.660
韩束的环境呢

26:08.660 --> 26:11.660
它只能用它里边的东西

26:11.660 --> 26:13.660
在这个韩束里边生命的东西

26:13.660 --> 26:15.660
这个韩束里边生命了啥

26:15.660 --> 26:17.660
生命了一个变量 生命了一个韩束 对吧

26:17.660 --> 26:18.660
所以说这个A里边能用啥

26:18.660 --> 26:19.660
能用A和B

26:19.660 --> 26:21.660
然后加上它外部的东西

26:21.660 --> 26:23.660
外部的东西可以用

26:23.660 --> 26:25.660
那么对于B而言 B里边生命了啥

26:25.660 --> 26:27.660
生命了变量B

26:27.660 --> 26:29.660
然后呢 它就可以用变量B

26:29.660 --> 26:32.660
并且呢 可以用什么呢 可以用外部的东西

26:32.660 --> 26:34.660
外部的东西可以用A

26:34.660 --> 26:36.660
可以用A 可以用G 看到没

26:36.660 --> 26:39.660
这就是作用语 作用语

26:40.660 --> 26:43.660
好 那么知道这个东西有什么意义呢

26:43.660 --> 26:44.660
知道这个东西呢

26:44.660 --> 26:46.660
我们就可以这样子 这样来处理

26:46.660 --> 26:48.660
就是有的时候

26:49.660 --> 26:51.660
有的时候

26:53.660 --> 26:55.660
某个韩束比较复杂

26:55.660 --> 26:56.660
比较复杂

26:56.660 --> 26:58.660
它可能代码很多很多

27:00.660 --> 27:03.660
在编写的过程中

27:03.660 --> 27:07.660
可能需要另外一些韩束

27:07.660 --> 27:09.660
来辅助

27:09.660 --> 27:13.660
来辅助它完成一些功能

27:13.660 --> 27:15.660
来辅助它来完成一些功能

27:15.660 --> 27:17.660
而这些韩束呢

27:17.660 --> 27:20.660
而这些韩束 我现在讲应用了

27:20.660 --> 27:23.660
而这些韩束仅仅

27:24.660 --> 27:28.660
会被该韩束使用

27:28.660 --> 27:31.660
不会在其他位置使用

27:31.660 --> 27:33.660
在其他位置使用

27:34.660 --> 27:37.660
位置使用

27:37.660 --> 27:40.660
则可以将这些韩束

27:40.660 --> 27:44.660
作为该韩束

27:44.660 --> 27:46.660
可以将这些韩束

27:46.660 --> 27:50.660
声明到该韩束的内部

27:50.660 --> 27:51.660
啥意思

27:51.660 --> 27:52.660
啥意思呢

27:52.660 --> 27:54.660
比方说 这个韩束

27:54.660 --> 27:56.660
这个韩束可能比较复杂

27:56.660 --> 27:58.660
它非常非常复杂

27:58.660 --> 27:59.660
非常复杂的韩束

27:59.660 --> 28:01.660
你这样想一下没

28:01.660 --> 28:03.660
非常复杂的韩束

28:03.660 --> 28:04.660
我们再换一个

28:04.660 --> 28:05.660
干脆换一个

28:05.660 --> 28:06.660
不把这个插掉了

28:06.660 --> 28:08.660
换一个

28:08.660 --> 28:09.660
比方说一个韩束

28:09.660 --> 28:11.660
它贼复杂

28:11.660 --> 28:13.660
哪怕它是一个韩束表达式

28:13.660 --> 28:14.660
也无所谓

28:14.660 --> 28:15.660
如果是一个立即执行韩束

28:15.660 --> 28:16.660
其实也可以

28:16.660 --> 28:17.660
无所谓

28:17.660 --> 28:18.660
总之它很复杂

28:18.660 --> 28:21.660
它很复杂

28:21.660 --> 28:23.660
这么一个韩束

28:23.660 --> 28:24.660
这个韩束里边

28:24.660 --> 28:26.660
在实现的过程中

28:26.660 --> 28:28.660
它是非常复杂的

28:28.660 --> 28:29.660
有的时候

28:29.660 --> 28:30.660
我们要用到其他韩束

28:30.660 --> 28:32.660
需要一些韩束

28:32.660 --> 28:33.660
需要声明一些韩束

28:33.660 --> 28:34.660
来完成功能

28:34.660 --> 28:37.660
需要声明韩束完成功能

28:37.660 --> 28:38.660
那么怎么办呢

28:38.660 --> 28:40.660
按照以前的做法的话

28:40.660 --> 28:41.660
我们会怎么做

28:41.660 --> 28:42.660
我们会在外边

28:42.660 --> 28:43.660
去定义韩束

28:43.660 --> 28:44.660
对吧

28:44.660 --> 28:46.660
我们会在外边去定义韩束

28:46.660 --> 28:47.660
比方说

28:47.660 --> 28:48.660
这一下

28:48.660 --> 28:50.660
这个韩束B

28:50.660 --> 28:52.660
或者叫Helper

28:52.660 --> 28:55.660
帮助韩束

28:55.660 --> 28:56.660
再来一个Helper

28:56.660 --> 28:58.660
可能会需要一些韩束

28:58.660 --> 28:59.660
那么这些韩束

28:59.660 --> 29:00.660
我们以前的做法

29:00.660 --> 29:01.660
是把定义到外边

29:01.660 --> 29:02.660
定义到外边里边

29:02.660 --> 29:03.660
能不能使用

29:03.660 --> 29:04.660
我们刚才说了

29:04.660 --> 29:05.660
韩束里边

29:05.660 --> 29:06.660
可以使用外边的东西

29:06.660 --> 29:07.660
这个韩束

29:07.660 --> 29:09.660
虽然在全具重用率里边定义的

29:09.660 --> 29:10.660
但是韩束里边

29:10.660 --> 29:11.660
是可以使用的

29:11.660 --> 29:12.660
可以使用外部的东西

29:12.660 --> 29:13.660
所以说

29:13.660 --> 29:14.660
这些韩束

29:14.660 --> 29:15.660
但是

29:15.660 --> 29:16.660
这些韩束

29:16.660 --> 29:19.660
可能仅仅是为这个韩束服务的

29:19.660 --> 29:20.660
其他地方也不会用

29:20.660 --> 29:21.660
也说我们在全具里边

29:21.660 --> 29:23.660
不会去调用这个韩束

29:23.660 --> 29:24.660
不会去调用这个韩束

29:24.660 --> 29:25.660
全具里边

29:25.660 --> 29:26.660
不会去调用的

29:26.660 --> 29:27.660
因此

29:27.660 --> 29:28.660
这些韩束

29:28.660 --> 29:29.660
定义到外边

29:29.660 --> 29:30.660
没有意义

29:30.660 --> 29:32.660
因为它只为这个韩束服务

29:32.660 --> 29:33.660
它是为了实现

29:33.660 --> 29:34.660
这个韩束里边

29:34.660 --> 29:35.660
非常复杂的功能

29:35.660 --> 29:36.660
为它来服务的

29:36.660 --> 29:37.660
所以说

29:37.660 --> 29:38.660
我们完全可以

29:38.660 --> 29:39.660
把这个东西

29:39.660 --> 29:40.660
定义到里边

29:40.660 --> 29:42.660
这样子的好处在于

29:42.660 --> 29:44.660
外边就不能使用了

29:44.660 --> 29:45.660
不能使用是好处

29:45.660 --> 29:47.660
还是坏事

29:47.660 --> 29:48.660
是好处还是坏事

29:48.660 --> 29:50.660
有些人可能觉得是坏事

29:50.660 --> 29:51.660
外边能使用的东西

29:51.660 --> 29:53.660
越多不是越好吗

29:53.660 --> 29:56.660
我实际上给你举个例子吧

29:56.660 --> 29:58.660
你买了一个微波炉

29:58.660 --> 30:00.660
这个微波炉上面

30:00.660 --> 30:02.660
只有

30:02.660 --> 30:04.660
两个旋钮

30:04.660 --> 30:05.660
一个旋钮了调时间

30:05.660 --> 30:08.660
一个旋钮了调火力

30:08.660 --> 30:09.660
这个微波炉

30:09.660 --> 30:10.660
是不是很好用

30:10.660 --> 30:11.660
对吧

30:11.660 --> 30:12.660
很简单

30:12.660 --> 30:13.660
虽然它功能简单

30:13.660 --> 30:14.660
但很好用

30:14.660 --> 30:15.660
那么另外一个微波炉

30:15.660 --> 30:17.660
大家选择一下

30:17.660 --> 30:18.660
这是正常的微波炉

30:18.660 --> 30:19.660
另外一个微波炉

30:19.660 --> 30:20.660
它是这样子

30:20.660 --> 30:21.660
它外边

30:21.660 --> 30:23.660
给你放了1000个按钮

30:23.660 --> 30:25.660
这1000个按钮

30:25.660 --> 30:26.660
功能贼强大

30:26.660 --> 30:28.660
你可以通过这1000个按钮

30:28.660 --> 30:29.660
控制微波炉里边的温度

30:29.660 --> 30:30.660
可以精确到多少度

30:30.660 --> 30:32.660
而且可以控制它里边的电路板

30:32.660 --> 30:34.660
电路板的电流流动

30:34.660 --> 30:35.660
什么二级管

30:35.660 --> 30:36.660
三级管都可以控制

30:36.660 --> 30:37.660
通过这1000个按钮

30:37.660 --> 30:39.660
还可以进行编程

30:39.660 --> 30:40.660
你会买第二个吗

30:40.660 --> 30:42.660
加个一样

30:42.660 --> 30:43.660
而且它给你配了一本

30:43.660 --> 30:44.660
厚厚的说明书

30:44.660 --> 30:46.660
然后告诉你这个微波炉

30:46.660 --> 30:47.660
怎么去使用

30:47.660 --> 30:48.660
功能非常强大

30:48.660 --> 30:49.660
而且这1000个按钮里边

30:49.660 --> 30:51.660
还给你非常贴心的

30:51.660 --> 30:53.660
给你增加了自爆功能

30:53.660 --> 30:55.660
但是还给你提示

30:55.660 --> 30:57.660
尽量少许用它

30:57.660 --> 30:59.660
你会用第二个吗

30:59.660 --> 31:01.660
你是不是一定不会用第二个

31:01.660 --> 31:03.660
你需要知道那么多东西干嘛了

31:03.660 --> 31:05.660
尽量少的

31:05.660 --> 31:07.660
尽量简单就行了

31:07.660 --> 31:09.660
我只需要

31:09.660 --> 31:11.660
我只需要一个加热和时间

31:11.660 --> 31:13.660
就够了

31:13.660 --> 31:15.660
我需要那么多东西干嘛了

31:15.660 --> 31:17.660
这么多东西给我反而会干扰我

31:17.660 --> 31:18.660
干扰我的操作

31:18.660 --> 31:20.660
那么这里也是一样的

31:20.660 --> 31:22.660
你可以外部去暴露这么多的函数

31:22.660 --> 31:24.660
反而会干扰外部

31:24.660 --> 31:27.660
会让它变得无所事从

31:27.660 --> 31:29.660
你还不如把它隐藏起来

31:29.660 --> 31:31.660
只在这个函数里边

31:31.660 --> 31:33.660
让外面调用不了

31:33.660 --> 31:34.660
调用不了

31:34.660 --> 31:35.660
这不是你该调用的东西

31:35.660 --> 31:37.660
你就不会去犯这个错误

31:37.660 --> 31:39.660
外面本来就不需要调用这个东西

31:39.660 --> 31:42.660
所以说这反而是一件好事

31:42.660 --> 31:44.660
这也是为什么我们可能会在

31:44.660 --> 31:46.660
这也是为什么会支持

31:46.660 --> 31:48.660
在函数里边写函数

31:48.660 --> 31:49.660
那么我们可以认为

31:49.660 --> 31:50.660
这个函数是指函数

31:50.660 --> 31:52.660
是这个函数的指函数

31:52.660 --> 31:53.660
那么这个函数里边

31:53.660 --> 31:54.660
比方它的功能也比较复杂

31:54.660 --> 31:55.660
OK

31:55.660 --> 31:56.660
它可能还会写函数

31:56.660 --> 31:58.660
它可能还会写函数

31:58.660 --> 32:00.660
SubHelper

32:00.660 --> 32:02.660
非常非常正常

32:02.660 --> 32:03.660
那么这个函数

32:03.660 --> 32:05.660
只能在它里边使用

32:05.660 --> 32:06.660
外边是使用不了的

32:06.660 --> 32:08.660
我们认为它是它的指函数

32:08.660 --> 32:10.660
或者叫做内部函数

32:10.660 --> 32:11.660
看没

32:11.660 --> 32:12.660
OK

32:12.660 --> 32:13.660
这是关于这一块

32:13.660 --> 32:14.660
它的实际的意义

32:14.660 --> 32:15.660
在函数里边

32:15.660 --> 32:16.660
我们可以写函数

32:16.660 --> 32:17.660
那么避免的

32:17.660 --> 32:18.660
在外部可以调用这个函数

32:18.660 --> 32:19.660
那么现在外部

32:19.660 --> 32:20.660
能不能调用这个函数

32:20.660 --> 32:21.660
调用不了

32:21.660 --> 32:22.660
因为这个函数

32:22.660 --> 32:23.660
是在底一边的

32:23.660 --> 32:24.660
在三底一边的东西

32:24.660 --> 32:25.660
外部只能在调用

32:25.660 --> 32:26.660
只能使用什么

32:26.660 --> 32:28.660
在外部声明的东西

32:28.660 --> 32:29.660
你在哪一块声明的

32:29.660 --> 32:31.660
只能在哪一块使用

32:31.660 --> 32:33.660
加上一个外层环境

32:33.660 --> 32:34.660
由于这是全局环境

32:34.660 --> 32:35.660
全局环境没有外层环境

32:35.660 --> 32:36.660
所以说

32:36.660 --> 32:37.660
全局环境里边

32:37.660 --> 32:38.660
它只能使用在

32:38.660 --> 32:41.660
全局环境里边声明的东西

32:41.660 --> 32:43.660
好在函数里边的东西

32:43.660 --> 32:44.660
只能在函数里边

32:44.660 --> 32:46.660
不要在这个函数里边

32:46.660 --> 32:47.660
在这个函数里边

32:47.660 --> 32:48.660
它只能使用什么

32:48.660 --> 32:49.660
在这个函数里边

32:49.660 --> 32:50.660
声明的啥

32:50.660 --> 32:51.660
声明了HELP1

32:51.660 --> 32:52.660
声明了HELP2

32:52.660 --> 32:54.660
只能使用这两个东西

32:54.660 --> 32:56.660
明白这个意思

32:56.660 --> 32:57.660
这是关于

32:57.660 --> 32:58.660
这个作用欲

32:58.660 --> 33:01.660
外部只能使用外部的

33:01.660 --> 33:03.660
内部可以使用内部

33:04.660 --> 33:06.660
这里还有个问题

33:06.660 --> 33:09.660
就是名称冲突

33:09.660 --> 33:11.660
声明冲突

33:11.660 --> 33:13.660
声明冲突时

33:13.660 --> 33:15.660
内部和外部

33:15.660 --> 33:16.660
内部

33:16.660 --> 33:18.660
函数内部

33:18.660 --> 33:20.660
声明的

33:20.660 --> 33:22.660
变量

33:22.660 --> 33:24.660
和外部冲突时

33:24.660 --> 33:26.660
如果冲突的时候

33:26.660 --> 33:28.660
使用内部的

33:28.660 --> 33:29.660
使用内部的

33:29.660 --> 33:31.660
这就是什么意思呢

33:32.660 --> 33:34.660
比方说

33:34.660 --> 33:35.660
咱们这里有函数

33:35.660 --> 33:37.660
A

33:37.660 --> 33:39.660
函数A

33:39.660 --> 33:40.660
函数A

33:40.660 --> 33:41.660
然后

33:41.660 --> 33:43.660
外面有一个变量

33:43.660 --> 33:45.660
变量A

33:45.660 --> 33:46.660
变量A

33:46.660 --> 33:47.660
ABC

33:49.660 --> 33:50.660
然后有一个

33:50.660 --> 33:52.660
函数B

33:52.660 --> 33:54.660
函数B

33:54.660 --> 33:56.660
然后A里边

33:56.660 --> 33:58.660
也有一个变量A

33:58.660 --> 34:00.660
也有一个变量A

34:01.660 --> 34:03.660
BCD

34:03.660 --> 34:06.660
然后也有一个函数B

34:06.660 --> 34:08.660
也有一个函数B

34:08.660 --> 34:10.660
好 B里边

34:10.660 --> 34:12.660
我们也有一个

34:12.660 --> 34:13.660
不行了

34:13.660 --> 34:14.660
我们直接输出

34:14.660 --> 34:16.660
直接输出A

34:16.660 --> 34:18.660
和

34:18.660 --> 34:20.660
就输出A

34:20.660 --> 34:23.660
然后咱们

34:23.660 --> 34:26.660
A里边去调用B

34:26.660 --> 34:28.660
我们来理一下这个代码

34:28.660 --> 34:30.660
有练绕

34:30.660 --> 34:32.660
我们这里去调用A

34:32.660 --> 34:33.660
看着

34:33.660 --> 34:35.660
怎么来理解这个代码

34:36.660 --> 34:37.660
首先函数

34:37.660 --> 34:38.660
声明了

34:38.660 --> 34:39.660
然后把A

34:39.660 --> 34:40.660
全局

34:40.660 --> 34:42.660
我们看一下全局环境

34:43.660 --> 34:46.660
全局环境里边有哪些东西

34:46.660 --> 34:47.660
有哪些东西呢

34:47.660 --> 34:49.660
是不是有函数A

34:49.660 --> 34:51.660
函数A可以用

34:51.660 --> 34:52.660
还有什么

34:52.660 --> 34:54.660
还有变量A

34:54.660 --> 34:55.660
变量A是多少

34:55.660 --> 34:57.660
是不是ABC

34:58.660 --> 35:00.660
变量A是ABC

35:00.660 --> 35:01.660
这样子去

35:01.660 --> 35:02.660
换过来

35:05.660 --> 35:07.660
全局环境里边

35:07.660 --> 35:09.660
有一个A是函数

35:09.660 --> 35:10.660
函数

35:10.660 --> 35:12.660
然后有一个

35:12.660 --> 35:13.660
变量A

35:13.660 --> 35:14.660
是一个支付串

35:14.660 --> 35:16.660
ABC

35:17.660 --> 35:18.660
OK

35:18.660 --> 35:19.660
这是全局环境

35:19.660 --> 35:20.660
还有吗

35:20.660 --> 35:21.660
全局环境还有吗

35:21.660 --> 35:22.660
是没了

35:22.660 --> 35:23.660
全局环境没了

35:23.660 --> 35:24.660
好

35:24.660 --> 35:26.660
函数A的环境

35:26.660 --> 35:28.660
函数A的环境

35:28.660 --> 35:30.660
函数A的环境里边

35:30.660 --> 35:31.660
像这个东西

35:31.660 --> 35:32.660
我给大家说一下

35:32.660 --> 35:34.660
以后我会再详细的讲

35:34.660 --> 35:35.660
现在我们先简单了解一下

35:35.660 --> 35:37.660
这一块其实蛮复杂的

35:37.660 --> 35:38.660
函数A里边

35:38.660 --> 35:39.660
雕用函数A的时候

35:39.660 --> 35:41.660
函数A里边的环境

35:41.660 --> 35:42.660
它有哪些东西呢

35:42.660 --> 35:44.660
你是在雕用函数A的时候

35:44.660 --> 35:45.660
它有这个环境

35:45.660 --> 35:46.660
如果没有雕用

35:46.660 --> 35:48.660
这个环境是不存在的

35:48.660 --> 35:50.660
函数A的环境里边

35:50.660 --> 35:51.660
有哪些东西呢

35:51.660 --> 35:52.660
有啥呢

35:52.660 --> 35:53.660
有变量

35:53.660 --> 35:55.660
变量A

35:55.660 --> 35:57.660
这个只是BCD

35:57.660 --> 35:58.660
有啥呢

35:58.660 --> 36:00.660
有B是一个函数

36:00.660 --> 36:01.660
函数

36:01.660 --> 36:03.660
这是函数A的环境

36:03.660 --> 36:04.660
好

36:04.660 --> 36:06.660
函数B的环境里边

36:06.660 --> 36:08.660
函数B

36:08.660 --> 36:10.660
B的环境

36:10.660 --> 36:11.660
里边有啥东西呢

36:11.660 --> 36:12.660
啥都没有

36:12.660 --> 36:13.660
函数B里边

36:13.660 --> 36:14.660
没有声明任何东西

36:14.660 --> 36:15.660
没有声明任何东西

36:15.660 --> 36:16.660
所以啥都没有

36:16.660 --> 36:17.660
好

36:17.660 --> 36:18.660
那么现在

36:18.660 --> 36:19.660
看着

36:20.660 --> 36:22.660
雕用函数A

36:22.660 --> 36:24.660
开始执行函数A了

36:24.660 --> 36:25.660
开始执行函数A的时候

36:25.660 --> 36:26.660
第一句话

36:26.660 --> 36:27.660
你看

36:27.660 --> 36:28.660
是不是声明了一个变量A

36:28.660 --> 36:29.660
BCD

36:29.660 --> 36:30.660
BCD

36:30.660 --> 36:32.660
然后声明了一个函数B

36:32.660 --> 36:33.660
函数B

36:33.660 --> 36:34.660
好 接下来

36:34.660 --> 36:35.660
在函数A里边

36:35.660 --> 36:37.660
去雕用B函数

36:37.660 --> 36:38.660
那么现在问题是

36:40.660 --> 36:41.660
全球环境里面

36:41.660 --> 36:42.660
还有一个B

36:42.660 --> 36:43.660
全球环境里面还有一个B

36:43.660 --> 36:44.660
它也是个函数

36:47.030 --> 36:49.030
现在问大家一个问题

36:49.030 --> 36:50.030
在函数A里边

36:50.030 --> 36:52.030
去雕用函数B

36:52.030 --> 36:53.030
雕用函数B

36:53.030 --> 36:55.030
它雕用的是函数A里边的

36:55.030 --> 36:56.030
这个函数B

36:56.030 --> 36:57.030
还是这个函数B

36:58.030 --> 36:59.030
看一下

36:59.030 --> 37:00.030
雕用哪个函数B呢

37:01.030 --> 37:02.030
我们刚才说了

37:03.030 --> 37:05.030
在函数里面的环境

37:05.030 --> 37:07.030
冲突的时候使用那一步的

37:07.030 --> 37:08.030
也就是说

37:08.030 --> 37:09.030
它是怎么找的呢

37:09.030 --> 37:10.030
它先看一下

37:10.030 --> 37:11.030
自己的环境里面

37:11.030 --> 37:12.030
有没有这个东西

37:12.030 --> 37:13.030
有没有B这个函数

37:14.030 --> 37:15.030
如果自己环境里面

37:15.030 --> 37:16.030
没有B这个函数

37:16.030 --> 37:17.030
再去找外面的

37:18.030 --> 37:19.030
但是现在B

37:19.030 --> 37:20.030
这个A的环境里面

37:20.030 --> 37:21.030
是不是有这个函数

37:21.030 --> 37:22.030
有这个函数

37:22.030 --> 37:24.030
因此我雕用的函数B

37:24.030 --> 37:25.030
在A里边

37:25.030 --> 37:26.030
雕用的函数B呢

37:26.030 --> 37:27.030
雕用的是啥

37:27.030 --> 37:28.030
雕用的是这个函数B

37:29.030 --> 37:30.030
因此输出啥

37:30.030 --> 37:31.030
输出BCD

37:32.030 --> 37:33.030
输出BCD

37:34.030 --> 37:35.030
也就是说

37:35.030 --> 37:36.030
B里边

37:36.030 --> 37:37.030
我们再来看B里边

37:37.030 --> 37:38.030
B里边执行的时候

37:38.030 --> 37:39.030
它输出的是A

37:39.030 --> 37:40.030
来看一下

37:40.030 --> 37:41.030
B的环境里面有没有A

37:42.030 --> 37:43.030
是没有A

37:43.030 --> 37:44.030
B的环境里面没有A

37:44.030 --> 37:45.030
是不是往外成早

37:45.030 --> 37:47.030
找A的环境里面有没有A

37:47.030 --> 37:48.030
A的环境里面

37:48.030 --> 37:49.030
是不是有A了

37:49.030 --> 37:50.030
找到BCD

37:50.030 --> 37:52.030
如果A的环境里面

37:52.030 --> 37:53.030
没有A

37:53.030 --> 37:55.030
如果A的环境里面

37:55.030 --> 37:56.030
先看一下结果

37:56.030 --> 37:59.050
BCD

37:59.050 --> 38:00.050
BCD

38:01.050 --> 38:03.050
如果A的环境里面

38:03.050 --> 38:05.050
没有这个变量A

38:05.050 --> 38:06.050
那又会怎么样了

38:07.050 --> 38:08.050
这又会怎么样了

38:09.050 --> 38:10.050
没有这个A了

38:10.050 --> 38:11.050
那B里面找的时候

38:11.050 --> 38:12.050
你看找

38:12.050 --> 38:13.050
它找自己的环境里面

38:13.050 --> 38:14.050
没有A

38:14.050 --> 38:15.050
然后找A的环境

38:15.050 --> 38:16.050
A的环境里面

38:16.050 --> 38:17.050
也没有A

38:17.050 --> 38:19.050
于是找全局环境

38:19.050 --> 38:20.050
找到ABC了

38:20.050 --> 38:21.050
这个时候就输出ABC

38:22.050 --> 38:23.050
看没有

38:23.050 --> 38:25.050
虽然我现在在线阶段

38:25.050 --> 38:27.050
我没有进行详细的讲解

38:27.050 --> 38:29.050
因为这一会讲信仰仰的话

38:29.050 --> 38:30.050
会花很多时间

38:30.050 --> 38:32.050
我打算马上就到进阶课程

38:32.050 --> 38:34.050
但是基本原理

38:34.050 --> 38:35.050
就已经通了

38:35.050 --> 38:37.050
就基本上就是这个道理

38:38.050 --> 38:39.050
好吧

38:40.050 --> 38:42.050
这就是作用域之间的

38:43.050 --> 38:44.050
相互使用

38:45.050 --> 38:46.050
接下来就是作用域

38:46.050 --> 38:47.050
接下来我们看

38:47.050 --> 38:48.050
第二个问题就是B包

38:48.050 --> 38:50.050
那你把作用域了解清楚了

38:50.050 --> 38:52.050
B包就非常非常简单了

38:52.050 --> 38:53.050
B包

38:54.050 --> 38:55.050
B包

38:55.050 --> 38:56.050
它的单词叫做Cloyer

38:56.050 --> 38:57.050
Cloyer

38:58.050 --> 38:59.050
Cloyer

39:00.050 --> 39:01.050
Cloyer

39:01.050 --> 39:02.050
B包

39:02.050 --> 39:04.050
是一种现象

39:04.050 --> 39:05.050
一种现象

39:05.050 --> 39:06.050
什么现象呢

39:06.050 --> 39:08.050
它不是说我们写

39:08.050 --> 39:09.050
有些同学

39:09.050 --> 39:10.050
当然我是严格的说

39:10.050 --> 39:12.050
有的时候习惯上了

39:12.050 --> 39:14.050
我们也可以用另外的说法

39:14.050 --> 39:15.050
但是我是严格的说

39:15.050 --> 39:16.050
严格的说的话

39:16.050 --> 39:18.050
B包是一种现象

39:18.050 --> 39:20.050
就是有些同学老是

39:20.050 --> 39:22.050
老是在问

39:22.050 --> 39:25.050
你这个单码有没有写B包

39:25.050 --> 39:27.050
B包不是我写出来的

39:27.050 --> 39:29.050
它是一个现象自然而然发生的

39:29.050 --> 39:31.050
是发生的一个现象

39:31.050 --> 39:33.050
它表示什么意思呢

39:33.050 --> 39:35.050
我们以后还会详细讲B包

39:35.050 --> 39:36.050
还会详细讲

39:36.050 --> 39:38.050
可以利用B包来实现一些效果

39:38.050 --> 39:40.050
现在我们先简单认识一下

39:40.050 --> 39:42.050
它是什么现象呢

39:42.050 --> 39:44.050
它就是指的是

39:44.050 --> 39:46.050
内部函数

39:46.050 --> 39:48.050
可以使用

39:48.050 --> 39:50.050
外部函数的

39:50.050 --> 39:52.050
外部函数

39:52.050 --> 39:54.050
环境中的

39:56.050 --> 39:58.050
辨量

39:58.050 --> 40:00.050
当然也包括函数

40:00.050 --> 40:02.050
内部函数可以使用

40:02.050 --> 40:04.050
外部函数函数环境中的辨量

40:04.050 --> 40:07.050
我们以后会详细的讲这一块

40:07.050 --> 40:09.050
这就是B包现象

40:09.050 --> 40:10.050
你看这里

40:10.050 --> 40:12.050
内部函数可以使用

40:12.050 --> 40:13.050
外部环境

40:13.050 --> 40:14.050
这个环境没有

40:14.050 --> 40:15.050
继续往上找

40:15.050 --> 40:16.050
找到这个环境

40:16.050 --> 40:17.050
这个环境里面有这个东西

40:17.050 --> 40:19.050
内部函数可以使用

40:19.050 --> 40:20.050
外部的东西

40:20.050 --> 40:21.050
这就是B包

40:21.050 --> 40:22.050
这个现象就是B包

40:22.050 --> 40:24.050
当然B包会带来一系列的

40:24.050 --> 40:25.050
不是问题

40:25.050 --> 40:27.050
带来一系列的就是

40:27.050 --> 40:28.050
现象

40:28.050 --> 40:30.050
我们后边会详细讲念B包

40:30.050 --> 40:32.050
并且我们可以利用B包

40:32.050 --> 40:33.050
来做一些事

40:33.050 --> 40:34.050
我们平时说

40:34.050 --> 40:35.050
有没有用B包

40:35.050 --> 40:37.050
实际上指的是什么意思呢

40:37.050 --> 40:39.050
我们有没有利用B包

40:39.050 --> 40:41.050
来去做一些常见的操作

40:41.050 --> 40:42.050
是这个意思

40:42.050 --> 40:44.050
但是B包是无时无刻不在发生的

40:44.050 --> 40:45.050
你看你定一个函数

40:45.050 --> 40:46.050
它就有B包

40:46.050 --> 40:47.050
定一个函数

40:47.050 --> 40:48.050
这个函数里面

40:48.050 --> 40:50.050
只要使用了外面的东西

40:50.050 --> 40:51.050
它就有B包

40:51.050 --> 40:52.050
它就有B包

40:52.050 --> 40:53.050
比方说

40:53.050 --> 40:55.050
我这里随便定一个变量

40:55.050 --> 40:56.050
Test

40:56.050 --> 40:57.050
随便定一个变量

40:57.050 --> 40:59.050
那么这个A函数里面

40:59.050 --> 41:01.050
这个A函数里面

41:01.050 --> 41:02.050
输出了Test

41:02.050 --> 41:03.050
这就有B包

41:03.050 --> 41:05.050
这个B包就已经发生了

41:05.050 --> 41:06.050
你在A函数里面

41:06.050 --> 41:07.050
使用了这个变量

41:07.050 --> 41:08.050
使用了外部环境的东西

41:08.050 --> 41:10.050
它就已经发生了这件事了

41:10.050 --> 41:11.050
没关系的意思

41:11.050 --> 41:13.050
OK

41:13.050 --> 41:15.050
这是关于B包

41:16.050 --> 41:17.050
OK

41:17.050 --> 41:18.050
这一课我们学习了

41:18.050 --> 41:19.050
关于作用欲

41:19.050 --> 41:20.050
使用欲

41:20.050 --> 41:21.050
始终记住

41:21.050 --> 41:22.050
外面的不能用里边的

41:22.050 --> 41:24.050
里边的可以用外边的

41:24.050 --> 41:25.050
并且我们学习了

41:25.050 --> 41:26.050
函数表达式

41:26.050 --> 41:27.050
函数表达式

41:27.050 --> 41:30.050
就是这种邪法

41:30.050 --> 41:31.050
这种邪法

41:31.050 --> 41:32.050
就是函数表达式

41:32.050 --> 41:33.050
你用小货号把扩起来

41:33.050 --> 41:34.050
函数表达式

41:34.050 --> 41:35.050
以后我们下节课

41:35.050 --> 41:36.050
我们下节课叫

41:36.050 --> 41:37.050
详细的讲函数表达式

41:37.050 --> 41:39.050
还可以有更多的邪法

41:39.050 --> 41:40.050
还可以有更多的邪法

41:40.050 --> 41:42.050
好吧

41:42.050 --> 41:43.050
这是这一课的内容

41:43.050 --> 41:44.050
作用欲和B包

