WEBVTT

00:00.500 --> 00:06.300
之前我们把浏览器那一块的知识就已经学习完了

00:06.300 --> 00:10.300
现在我们又回到ES标准这一块的知识

00:10.300 --> 00:15.700
在这里边还有一些很深的知识我们还没有讲解

00:15.700 --> 00:17.700
所以说我们在进阶部分讲解了

00:17.700 --> 00:20.500
这一部分的知识它会影响到啥呢?

00:20.500 --> 00:22.500
它会影响到你写面试题

00:22.500 --> 00:25.500
或者说你做一些公共的组件

00:25.500 --> 00:27.500
或者是公共的插件

00:27.500 --> 00:29.500
做一些通用性的东西

00:29.500 --> 00:31.500
那么你可能需要这一部分的知识

00:31.500 --> 00:35.500
好 咱们这一块先来了解咱们的进阶部分的第一块知识

00:35.500 --> 00:38.500
就是关于圆形和圆形链

00:38.500 --> 00:42.500
应该说每一个学界式的同学

00:42.500 --> 00:46.500
这一块知识对你们来说都非常非常重要

00:46.500 --> 00:48.500
一是面试题非常容易考

00:48.500 --> 00:53.500
第二就是我们在写一些非常特别的功能的时候

00:53.500 --> 00:55.500
需要这一块的知识

00:55.500 --> 00:57.500
好 咱们现在了解圆形圆形链

00:57.500 --> 01:00.500
这部分我们首先来回顾一下

01:00.500 --> 01:03.500
之前咱们学习的一些核心的知识点

01:03.500 --> 01:06.500
第一个 不知道大家还记不记得

01:06.500 --> 01:12.500
当时说过所有的对象都是通过6创建的

01:12.500 --> 01:13.500
还记得吗?

01:13.500 --> 01:17.500
我们当时说过的所有的对象都是通过6来创建的

01:17.500 --> 01:20.500
6啥呢? 6一个函数

01:20.500 --> 01:23.500
通过这么一种格式来创建对象的

01:23.500 --> 01:27.500
无论什么对象 包括我们两个大国号写的对象

01:27.500 --> 01:29.500
都是通过6一个函数来创建的

01:29.500 --> 01:31.500
就比方说咱们平时写的什么代码

01:31.500 --> 01:36.500
就是6一个OB界等于一个大国号

01:36.500 --> 01:37.500
当时我们说了

01:37.500 --> 01:40.500
这个大国号是一个语法堂

01:40.500 --> 01:43.500
它的本质是6一个objects

01:43.500 --> 01:46.500
我们当时给大家看了一下一个MDN文档

01:46.500 --> 01:48.500
MDN文档上也是这么说的对吧

01:48.500 --> 01:51.500
本质上是6一个objects

01:51.500 --> 01:52.500
这是第一个知识点

01:52.500 --> 01:55.500
这里有张图

01:55.500 --> 01:57.500
你看这张图

01:57.500 --> 01:59.500
跑了去

01:59.500 --> 02:01.500
就这张图

02:01.500 --> 02:04.500
这张图里边我们可以看到

02:04.500 --> 02:06.500
这个函数这里

02:06.500 --> 02:09.500
这个普通对象 绿色的表示普通对象

02:09.500 --> 02:11.500
都是通过6一个函数产生的

02:11.500 --> 02:13.500
我们平时写的两个大国号

02:13.500 --> 02:15.500
是通过6一个objects

02:15.500 --> 02:17.500
6一个objects产生的

02:17.500 --> 02:19.500
我们的普通对象都是这样产生的

02:19.500 --> 02:21.500
包括我们可以6 比方数组

02:21.500 --> 02:22.500
数组两个中货号

02:22.500 --> 02:24.500
或者是6一个array

02:24.500 --> 02:27.500
相当于甭管理杂写

02:27.500 --> 02:30.500
最终相当于6一个array产生的

02:30.500 --> 02:32.500
我们自己也可不可以写函数

02:32.500 --> 02:33.500
自己也可以写函数

02:33.500 --> 02:35.500
我们也可以去6一个函数

02:35.500 --> 02:37.500
来产生对象

02:37.500 --> 02:38.500
原来这个意思

02:38.500 --> 02:40.500
这里我们再举个例子

02:40.500 --> 02:42.500
帮大家理解

02:42.500 --> 02:45.500
TES-1

02:45.500 --> 02:47.500
我们这里比方说

02:48.500 --> 02:50.500
有这么一个函数

02:51.500 --> 02:53.500
TEST

02:53.500 --> 02:55.500
啥都不写

02:55.500 --> 02:56.500
我们这里是反回一个东西

02:56.500 --> 02:58.500
反回一个

03:00.500 --> 03:01.500
这样子

03:01.500 --> 03:03.500
反回一个空的对象

03:05.500 --> 03:06.500
我们这里面试体

03:06.500 --> 03:08.500
它可能会问你这么一个东西

03:08.500 --> 03:09.500
就是说

03:09.500 --> 03:11.500
我到时候去6一个TEST

03:11.500 --> 03:13.500
它会问你

03:13.500 --> 03:15.500
我这个地方有没有产生对象

03:15.500 --> 03:17.500
那肯定有

03:17.500 --> 03:18.500
你只要6一个函数

03:18.500 --> 03:19.500
肯定产生对象

03:19.500 --> 03:21.500
那么这个对象

03:21.500 --> 03:24.500
是通过6一个函数产生的

03:24.500 --> 03:27.500
还是6一个array函数产生的

03:27.500 --> 03:29.500
这个对象的构造函数

03:29.500 --> 03:30.500
我们知道每一个对象

03:30.500 --> 03:33.500
它都通过一个6函数来产生的

03:33.500 --> 03:35.500
那么这个函数叫做构造函数

03:35.500 --> 03:38.500
再问你构造函数是谁

03:38.500 --> 03:40.500
构造函数是谁

03:40.500 --> 03:43.500
这里就很多同学交出问题了

03:43.500 --> 03:44.500
这里呢

03:44.500 --> 03:45.500
它的构造函数是谁呢

03:45.500 --> 03:46.500
可能你会认为

03:46.500 --> 03:48.500
它的构造函数是TEST

03:48.500 --> 03:49.500
但是不是的

03:49.500 --> 03:50.500
它的构造函数是什么

03:50.500 --> 03:52.500
它的构造函数是objects

03:52.500 --> 03:55.810
看一下吧

03:55.810 --> 03:56.810
这里

03:56.810 --> 03:58.810
好 刷新

03:58.810 --> 04:00.810
这里看不出来

04:00.810 --> 04:01.810
但是你可以看到展开过后

04:01.810 --> 04:02.810
它有个这个东西

04:02.810 --> 04:03.810
这个东西我们后面会解释

04:03.810 --> 04:05.810
它是一个objects

04:05.810 --> 04:07.810
它是6一个objects产生的

04:07.810 --> 04:08.810
为什么呢

04:08.810 --> 04:09.810
因为这个构造函数里边

04:09.810 --> 04:10.810
我们反回了一个对象

04:10.810 --> 04:11.810
我们之前说过

04:11.810 --> 04:13.810
如果你在函数里边

04:13.810 --> 04:14.810
或者是一个对象的话

04:14.810 --> 04:16.810
那么你6一个函数

04:16.810 --> 04:18.810
它得到的是这个反回结果

04:18.810 --> 04:20.810
而这个反回结果是两个大括号

04:20.810 --> 04:22.810
两个大括号是相当于啥

04:22.810 --> 04:23.810
是不是相当于6一个objects

04:23.810 --> 04:24.810
对吧

04:24.810 --> 04:26.810
相当于是这么个代码

04:26.810 --> 04:27.810
所以说呢

04:27.810 --> 04:28.810
这个函数呢

04:28.810 --> 04:30.810
你通过你虽然是6的函数

04:30.810 --> 04:31.810
但是呢它得到的是

04:31.810 --> 04:33.810
一个objects的对象

04:33.810 --> 04:34.810
好 如果你不写这个呢

04:34.810 --> 04:35.810
那就不一样了

04:35.810 --> 04:36.810
你不写这个就不一样了

04:36.810 --> 04:37.810
不写这个的话

04:37.810 --> 04:38.810
得到的是啥

04:38.810 --> 04:41.810
得到的是TEST这个对象

04:41.810 --> 04:42.810
我们来看一下

04:42.810 --> 04:43.810
你看 它会标注

04:43.810 --> 04:46.810
它是一个TEST这个构造函数的对象

04:46.810 --> 04:48.810
当然Proton的这个东西

04:48.810 --> 04:50.810
我们后边会解释

04:50.810 --> 04:53.810
但这个东西是一个TEST的对象

04:53.810 --> 04:55.810
如果你写了这个return的话

04:55.810 --> 04:57.810
它得到的是一个objects的对象

04:57.810 --> 04:58.810
明白这个意思吧

04:58.810 --> 05:00.810
我们把这个东西先搞清楚

05:00.810 --> 05:02.810
好 这是这一块

05:02.810 --> 05:04.810
所有对象都会通过6一个函数创结

05:04.810 --> 05:05.810
这是第一个知识点

05:05.810 --> 05:06.810
第二个知识点

05:06.810 --> 05:07.810
我们之前回一下

05:07.810 --> 05:08.810
都是说过的

05:08.810 --> 05:11.810
所有的函数也是对象

05:11.810 --> 05:13.810
我们当时还反复强调这个点

05:13.810 --> 05:14.810
还记得吧

05:14.810 --> 05:15.810
在第五章函数的时候

05:15.810 --> 05:17.810
我们讲函数的本质

05:17.810 --> 05:19.810
函数的本质就是一个对象

05:19.810 --> 05:20.810
所以说所有的函数

05:20.810 --> 05:21.810
它本质上也是个对象

05:21.810 --> 05:22.810
那么对象刚才说了

05:22.810 --> 05:24.810
都是通过6来创建的

05:24.810 --> 05:26.810
那么函数是怎么创建的呢

05:26.810 --> 05:28.810
函数是咋创建的呢

05:28.810 --> 05:29.810
函数我们当时说的是

05:29.810 --> 05:31.810
通过6一个方个型来创建的

05:31.810 --> 05:33.810
尽管我们写函数的时候

05:33.810 --> 05:34.810
不会这样子写

05:34.810 --> 05:35.810
也不建议大家这样子写

05:35.810 --> 05:37.810
但是它本质上

05:37.810 --> 05:39.810
都是通过6一个大写的F方个型

05:39.810 --> 05:40.810
来产生的

05:40.810 --> 05:42.810
也就是方个型它本身也是一个

05:42.810 --> 05:43.810
构造函数

05:43.810 --> 05:45.810
那么这里我当时还说

05:45.810 --> 05:46.810
这个地方就设立到

05:46.810 --> 05:48.810
鲜有机还是鲜有弹的问题

05:48.810 --> 05:50.810
那么这个方个型是哪来的呢

05:50.810 --> 05:51.810
方个型是函数

05:51.810 --> 05:52.810
它函数也是对象

05:52.810 --> 05:53.810
它也是对象

05:53.810 --> 05:54.810
它也是怎么产生的呢

05:54.810 --> 05:55.810
因为所有的函数

05:55.810 --> 05:56.810
都是通过6来创建的

05:56.810 --> 05:58.810
它比较特殊

05:58.810 --> 05:59.810
最特殊的就是它

05:59.810 --> 06:00.810
方个型函数

06:00.810 --> 06:02.810
是直接放到内存里边的

06:02.810 --> 06:03.810
就介石引擎启动的时候

06:03.810 --> 06:05.810
它直接把这东西放到内存里边

06:05.810 --> 06:07.810
它不通过任何东西来创建

06:07.810 --> 06:09.810
其他的所有的对象

06:09.810 --> 06:11.810
都是通过6来创建的

06:11.810 --> 06:12.810
函数是一个对象

06:12.810 --> 06:14.810
它通过6方个型来创建

06:14.810 --> 06:15.810
普通的对象是一个对象

06:15.810 --> 06:17.810
它通过6一个函数来创建

06:17.810 --> 06:18.810
看不

06:18.810 --> 06:19.810
是这么回事

06:19.810 --> 06:21.810
把这个图要彻底理解

06:21.810 --> 06:22.810
一定要理解清楚

06:22.810 --> 06:23.810
好吧

06:23.810 --> 06:24.810
这里

06:24.810 --> 06:25.810
这里还一张图

06:25.810 --> 06:26.810
还一张图

06:26.810 --> 06:27.810
也可以看得很清楚

06:27.810 --> 06:28.810
我把它简化一下

06:28.810 --> 06:29.810
就是所有的函数

06:29.810 --> 06:30.810
比方说OPGX4个函数

06:30.810 --> 06:31.810
对吧

06:31.810 --> 06:32.810
OPGX4是不是函数

06:32.810 --> 06:33.810
是不是函数

06:33.810 --> 06:34.810
咱们来看一下吧

06:34.810 --> 06:35.810
看一下OPGX

06:35.810 --> 06:36.810
Type

06:36.810 --> 06:38.810
OPGX

06:38.810 --> 06:39.810
是不是函数

06:39.810 --> 06:40.810
函数

06:40.810 --> 06:41.810
Array是不是函数

06:41.810 --> 06:42.810
函数

06:42.810 --> 06:43.810
为什么是函数

06:43.810 --> 06:44.810
因为你可以6它

06:44.810 --> 06:45.810
对吧

06:45.810 --> 06:46.810
你可以通过一个关键字6

06:46.810 --> 06:47.810
来创建它

06:47.810 --> 06:48.810
把它当成构造函数使用

06:48.810 --> 06:49.810
你看

06:49.810 --> 06:50.810
它的手这么大切的

06:50.810 --> 06:52.810
说明它是一个构造函数

06:52.810 --> 06:53.810
它是通过6来创建的

06:53.810 --> 06:54.810
你要这个意思

06:54.810 --> 06:56.810
所以说函数的本质上

06:56.810 --> 06:57.810
它也是对象

06:57.810 --> 06:59.810
它通过6一个方个型来创建

06:59.810 --> 07:01.810
这部分知识

07:02.810 --> 07:04.810
我们当时还说过啥

07:04.810 --> 07:06.810
由于函数是对象

07:06.810 --> 07:07.810
所以说函数里边

07:08.810 --> 07:10.810
函数中可以有属象

07:10.810 --> 07:11.810
对吧

07:11.810 --> 07:12.810
可以有属象

07:13.810 --> 07:14.810
比方说

07:14.810 --> 07:15.810
我们之前说什么

07:15.810 --> 07:16.810
Array对吧

07:16.810 --> 07:17.810
Array它是不是可以有属象

07:17.810 --> 07:19.810
Front是不是它的属象

07:19.810 --> 07:20.810
Array是不是函数

07:20.810 --> 07:22.810
函数里边是不是可以有属象

07:22.810 --> 07:23.810
因为函数就是个对象

07:23.810 --> 07:24.810
有啥区别呢

07:24.810 --> 07:25.810
或者是

07:25.810 --> 07:26.810
Array什么

07:26.810 --> 07:27.810
EaseArray 判断对吧

07:28.810 --> 07:29.810
对吧

07:29.810 --> 07:30.810
这些都是

07:30.810 --> 07:31.810
包括这个

07:31.810 --> 07:32.810
Number

07:32.810 --> 07:33.810
Number是不是函数

07:33.810 --> 07:34.810
来看一下Type

07:34.810 --> 07:35.810
Number

07:35.810 --> 07:36.810
Number里面会不会有属象

07:36.810 --> 07:37.810
对吧

07:37.810 --> 07:38.810
有属象

07:38.810 --> 07:39.810
EaseNan

07:39.810 --> 07:40.810
对吧

07:40.810 --> 07:41.810
这些都是属象

07:41.810 --> 07:42.810
方法也叫做方法

07:42.810 --> 07:44.810
如果属象是一个函数的话

07:44.810 --> 07:45.810
它也叫做方法

07:45.810 --> 07:47.810
那么这些东西都是属象

07:47.810 --> 07:48.810
看没

07:48.810 --> 07:49.810
所以说

07:49.810 --> 07:50.810
函数里边

07:50.810 --> 07:51.810
也可以有属象

07:51.810 --> 07:52.810
好

07:52.810 --> 07:54.810
先把之前的知识回过一下

07:54.810 --> 07:55.810
好

07:55.810 --> 07:56.810
接下来了

07:56.810 --> 07:57.810
当然还有一个知识

07:57.810 --> 07:58.810
还有一个知识就是

07:58.810 --> 07:59.810
所有对象

07:59.810 --> 08:01.810
都是引用类型

08:01.810 --> 08:02.810
什么叫引用类型

08:02.810 --> 08:03.810
它保存的是保存的是什么

08:03.810 --> 08:04.810
保存的是地址

08:04.810 --> 08:05.810
对吧

08:05.810 --> 08:06.810
复植

08:06.810 --> 08:07.810
复植的是什么

08:07.810 --> 08:08.810
复植的也是地址

08:08.810 --> 08:10.810
它们是引用传递

08:10.810 --> 08:11.810
好

08:11.810 --> 08:12.810
OK

08:12.810 --> 08:13.810
咱们把之前的东西

08:13.810 --> 08:14.810
先回顾一下

08:14.810 --> 08:15.810
接下来

08:15.810 --> 08:16.810
让我们来看一下

08:16.810 --> 08:17.810
第一个知识点

08:17.810 --> 08:18.810
圆熊

08:18.810 --> 08:19.810
圆熊的单子

08:19.810 --> 08:21.810
叫做Prototype

08:21.810 --> 08:23.810
光学这个知识点的话

08:23.810 --> 08:25.810
你会感觉很浪漫

08:25.810 --> 08:26.810
这东西到底有啥用

08:26.810 --> 08:28.810
这是有啥意义

08:28.810 --> 08:29.810
但是你要学过

08:29.810 --> 08:31.810
学完整个这节课之后

08:31.810 --> 08:32.810
你才知道它有什么意义

08:32.810 --> 08:33.810
好

08:34.810 --> 08:35.810
Prototype叫做圆形

08:35.810 --> 08:37.810
圆形是什么意思呢

08:37.810 --> 08:39.810
圆形就是Prototype

08:39.810 --> 08:41.810
Prototype

08:41.810 --> 08:43.810
是所有函数

08:43.810 --> 08:45.810
都具备的属性

08:45.810 --> 08:46.810
应该这样说

08:46.810 --> 08:47.810
所有函数都有个属性

08:47.810 --> 08:49.810
叫Prototype

08:49.810 --> 08:52.810
所有函数都有一个属性

08:52.810 --> 08:54.810
Prototype

08:54.810 --> 08:56.810
它称之为

08:56.810 --> 08:59.810
称之为函数圆形

08:59.810 --> 09:01.810
称之为函数圆形

09:01.810 --> 09:02.810
好

09:02.810 --> 09:03.810
咱们来看一下

09:03.810 --> 09:05.810
是不是真的所有函数都有这个东西

09:05.810 --> 09:07.810
看一下

09:07.810 --> 09:08.810
有没有这个东西

09:08.810 --> 09:10.810
所以你甭管它里面试试啥

09:10.810 --> 09:11.810
这个不重要

09:11.810 --> 09:13.810
它有这个东西

09:13.810 --> 09:14.810
然后再看

09:14.810 --> 09:15.810
number

09:15.810 --> 09:16.810
函数

09:16.810 --> 09:17.810
有没有这个东西

09:17.810 --> 09:18.810
有

09:18.810 --> 09:19.810
看没

09:19.810 --> 09:20.810
然后再来

09:20.810 --> 09:21.810
array

09:21.810 --> 09:22.810
有没有这个东西

09:22.810 --> 09:23.810
Prototype

09:23.810 --> 09:24.810
都有

09:24.810 --> 09:25.810
都有这个东西

09:25.810 --> 09:27.810
包括我们自己写个函数

09:27.810 --> 09:28.810
刚才我们写的函数

09:28.810 --> 09:30.810
刚才我们写的是Test

09:30.810 --> 09:31.810
我们自己写的函数

09:31.810 --> 09:32.810
只要你是一个函数

09:32.810 --> 09:34.810
那你一定有这个东西

09:34.810 --> 09:35.810
看没

09:35.810 --> 09:36.810
都有这个东西

09:36.810 --> 09:37.810
它会自动创建的

09:37.810 --> 09:38.810
当你创建一个函数的时候

09:38.810 --> 09:39.810
它会自动给你加上

09:39.810 --> 09:40.810
我们是通过

09:40.810 --> 09:41.810
什么来创建函数的

09:41.810 --> 09:42.810
通过六一个方式

09:42.810 --> 09:43.810
对吧

09:43.810 --> 09:44.810
你可以认为这样子

09:44.810 --> 09:45.810
比方说Test

09:45.810 --> 09:46.810
它是这个东西

09:46.810 --> 09:47.810
它是相当于是啥

09:47.810 --> 09:48.810
相当于是

09:48.810 --> 09:49.810
你定了个变量Test

09:49.810 --> 09:50.810
然后来六一个什么

09:50.810 --> 09:51.810
方式

09:51.810 --> 09:52.810
对吧

09:52.810 --> 09:53.810
六一个方式来创建的

09:53.810 --> 09:55.810
没有参数

09:55.810 --> 09:56.810
没有参数

09:56.810 --> 09:57.810
六一个方式

09:57.810 --> 09:58.810
那么你可以认为

09:58.810 --> 09:59.810
在这个方式里边

09:59.810 --> 10:00.810
它是不是产生一个对象

10:00.810 --> 10:01.810
对吧

10:01.810 --> 10:02.810
一个函数对象

10:02.810 --> 10:03.810
那么在这个构造函数里边

10:03.810 --> 10:05.810
它自动的为这个对象

10:05.810 --> 10:06.810
加了一个数项

10:06.810 --> 10:07.810
Prototype

10:07.810 --> 10:09.810
就是它的原型

10:09.810 --> 10:11.810
而原型是啥玩意儿呢

10:11.810 --> 10:12.810
原型

10:12.810 --> 10:13.810
它到底是啥玩意儿呢

10:13.810 --> 10:14.810
原型的本质上

10:14.810 --> 10:16.810
原型它就是一个

10:16.810 --> 10:20.120
默认情况下

10:20.120 --> 10:23.120
Prototype在默认情况下

10:23.120 --> 10:26.120
是一个普通的

10:26.120 --> 10:29.120
OP几个车对象

10:29.120 --> 10:30.120
它是一个普通的

10:30.120 --> 10:31.120
OP几个车对象

10:31.120 --> 10:32.120
默认情况下

10:32.120 --> 10:33.120
Prototype都是一个普通的

10:33.120 --> 10:34.120
OP几个车对象

10:34.120 --> 10:35.120
比方说

10:35.120 --> 10:36.120
咱们的

10:36.120 --> 10:37.120
它这个TES

10:37.120 --> 10:38.120
这个函数

10:38.120 --> 10:39.120
它的Prototype

10:39.120 --> 10:40.120
你看一下

10:40.120 --> 10:42.120
只要前面没有做任何标注的话

10:42.120 --> 10:44.120
前面只要没有做任何标注

10:44.120 --> 10:45.120
那么这个原型

10:45.120 --> 10:48.120
它都是一个OP几个车对象

10:48.120 --> 10:49.120
原来这个意思吧

10:49.120 --> 10:50.120
都是OP几个车对象

10:50.120 --> 10:52.120
是这么回事

10:52.120 --> 10:53.120
好

10:53.120 --> 10:54.120
那么这个对象里边

10:54.120 --> 10:55.120
也就是相当于是啥呢

10:55.120 --> 10:56.120
相当于是个原型

10:56.120 --> 10:58.120
它相当于是这样的负责

10:58.120 --> 10:59.120
它这个原型

10:59.120 --> 11:00.120
相当于是这样的负责

11:00.120 --> 11:02.120
就是一个普通的OP几个车对象

11:02.120 --> 11:03.120
对吧

11:03.120 --> 11:04.120
这就是它的原型

11:04.120 --> 11:06.120
你先别管原型有什么用

11:06.120 --> 11:08.120
先把它理解清楚

11:08.120 --> 11:10.120
它是一个OP几个车对象

11:10.120 --> 11:11.120
那么这个对象

11:11.120 --> 11:12.120
它肯定有数项对吧

11:12.120 --> 11:13.120
有哪些数项呢

11:13.120 --> 11:15.120
原型里边

11:15.120 --> 11:17.120
默认情况下

11:17.120 --> 11:21.120
都说是默认情况下

11:21.120 --> 11:22.120
也就是说可以改的

11:22.120 --> 11:23.120
我们后边再说怎么改

11:23.120 --> 11:25.120
默认情况下

11:25.120 --> 11:29.120
Prototype

11:29.120 --> 11:32.120
Type中有一个属性

11:32.120 --> 11:33.120
有一个属性叫什么呢

11:33.120 --> 11:35.120
叫做constructor

11:35.120 --> 11:37.120
有这么一个属性

11:37.120 --> 11:38.120
constructor

11:38.120 --> 11:39.120
这个属性是指向什么呢

11:39.120 --> 11:40.120
它是一个对象

11:40.120 --> 11:43.120
它也是一个对象

11:43.120 --> 11:44.120
一个对象

11:44.120 --> 11:45.120
当然对象它存的

11:45.120 --> 11:46.120
肯定是地址

11:46.120 --> 11:47.120
对吧

11:47.120 --> 11:48.120
它存的肯定是地址

11:48.120 --> 11:49.120
也就是它存的

11:49.120 --> 11:50.120
是一个引用

11:50.120 --> 11:51.120
它指向什么

11:51.120 --> 11:52.120
它地址肯定指向

11:52.120 --> 11:53.120
一块内存空间

11:53.120 --> 11:54.120
它指向谁呢

11:54.120 --> 11:58.120
指向构造函数本身

11:58.120 --> 12:02.120
能理解吗

12:02.120 --> 12:03.120
好

12:03.120 --> 12:04.120
咱们来看一下

12:04.120 --> 12:05.120
看一下这张图

12:05.120 --> 12:07.120
看一下这张图

12:07.120 --> 12:09.120
我们自己写的函数

12:09.120 --> 12:11.120
ADD是通过载字创建的

12:11.120 --> 12:12.120
通过这个方式创建的

12:12.120 --> 12:13.120
对吧

12:13.120 --> 12:14.120
那么它是一个函数

12:14.120 --> 12:15.120
它是不是有一个属性

12:15.120 --> 12:17.120
叫做Prototype

12:17.120 --> 12:18.120
它是一个对象

12:18.120 --> 12:19.120
Prototype是一个对象

12:19.120 --> 12:20.120
于是我们把它称之为

12:20.120 --> 12:22.120
ADD的圆形

12:22.120 --> 12:23.120
好

12:23.120 --> 12:24.120
圆形对象

12:24.120 --> 12:25.120
圆形对象里边

12:25.120 --> 12:26.120
是不是有个属性

12:26.120 --> 12:27.120
叫constructor

12:27.120 --> 12:28.120
constructor 什么意思

12:28.120 --> 12:29.120
就是构造函数的意思

12:29.120 --> 12:31.120
它又指向这个函数

12:31.120 --> 12:32.120
它又指回来了

12:32.120 --> 12:33.120
它里边有一个属性

12:33.120 --> 12:34.120
constructor

12:34.120 --> 12:36.120
跟这个函数本身是一样的

12:36.120 --> 12:38.120
其他函数都是这样子

12:38.120 --> 12:39.120
都是这样子

12:39.120 --> 12:40.120
包括这个函数

12:40.120 --> 12:42.120
这些函数都是这样子

12:42.120 --> 12:43.120
好

12:43.120 --> 12:44.120
咱们来看一下

12:44.120 --> 12:45.120
咱们来看一下

12:45.120 --> 12:47.120
比方Test

12:47.120 --> 12:49.120
Prototype

12:49.120 --> 12:51.120
那么它这个里边

12:51.120 --> 12:52.120
有一个constructor

12:52.120 --> 12:54.120
我现在问你

12:54.120 --> 12:55.120
它跟这个Test

12:55.120 --> 12:56.120
是不是一样的

12:56.120 --> 12:59.120
这个表达是是为真还是为假

12:59.120 --> 13:01.120
这个表达是

13:01.120 --> 13:03.120
这个表达是不是一定为真

13:03.120 --> 13:04.120
对不对

13:04.120 --> 13:05.120
你看这边

13:05.120 --> 13:06.120
看一下这边

13:06.120 --> 13:08.120
函数Prototype指向

13:08.120 --> 13:09.120
指过来

13:09.120 --> 13:10.120
然后它的constructor

13:10.120 --> 13:11.120
又指回去

13:11.120 --> 13:12.120
对吧

13:12.120 --> 13:13.120
它又指向自己了

13:13.120 --> 13:14.120
所以说

13:14.120 --> 13:15.120
是不是一定为真

13:15.120 --> 13:16.120
对不对

13:16.120 --> 13:17.120
一定为真

13:17.120 --> 13:18.120
那么再来

13:18.120 --> 13:19.120
那么Objects的Prototype

13:19.120 --> 13:20.120
它里边也有一个constructor

13:20.120 --> 13:23.120
那是不是一定等于Objects呢

13:23.120 --> 13:24.120
为真

13:24.120 --> 13:25.120
肯定为真

13:25.120 --> 13:26.120
怎么样了

13:26.120 --> 13:27.120
你看那个图吧

13:27.120 --> 13:28.120
还能怎么样了

13:28.120 --> 13:29.120
对吧

13:29.120 --> 13:30.120
只回去

13:30.120 --> 13:31.120
只过去就只回来

13:31.120 --> 13:32.120
对不对

13:32.120 --> 13:33.120
所以说它一定为真

13:33.120 --> 13:34.120
这个地方

13:34.120 --> 13:35.120
其实要告诉我们

13:35.120 --> 13:36.120
有的时候

13:36.120 --> 13:37.120
我没有得到函数

13:37.120 --> 13:39.120
但是我得到函数的原型

13:39.120 --> 13:41.120
有的是有可能

13:41.120 --> 13:42.120
我们自己可以讲完之后

13:42.120 --> 13:43.120
你就知道了

13:43.120 --> 13:45.120
有的时候我们得到的是函数原型

13:45.120 --> 13:46.120
我们可以通过原型

13:46.120 --> 13:47.120
来得到这个函数

13:47.120 --> 13:49.120
它到底是一个什么样的函数

13:49.120 --> 13:50.120
对吧

13:51.120 --> 13:52.120
好

13:52.120 --> 13:54.120
那么比方说

13:54.120 --> 13:55.120
现在还不好举例子

13:55.120 --> 13:56.120
我们一会再举例子

13:56.120 --> 13:58.120
现在知识还不够

13:58.120 --> 14:00.120
这是关于函数的原型

14:00.120 --> 14:02.120
这一块知识很简单

14:02.120 --> 14:03.120
就是每一个函数的

14:03.120 --> 14:04.120
它都有一个原型

14:04.120 --> 14:05.120
再看一下这个图

14:05.120 --> 14:06.120
每一个函数都有一个原型

14:06.120 --> 14:07.120
这个原型里面

14:07.120 --> 14:08.120
一个属性叫constructor

14:08.120 --> 14:10.120
然后只回这个函数

14:10.120 --> 14:11.120
好

14:11.120 --> 14:13.120
原型有啥用呢

14:13.120 --> 14:14.120
关键是

14:14.120 --> 14:15.120
原型有啥用呢

14:15.120 --> 14:16.120
接下来

14:16.120 --> 14:17.120
我们来看另外一个概念

14:17.120 --> 14:19.120
叫做隐释原型

14:19.120 --> 14:21.120
原型本身没有啥用

14:21.120 --> 14:22.120
但是配合隐释原型

14:22.120 --> 14:24.120
它就有大有的用处了

14:25.120 --> 14:27.120
它这个属性的解放

14:27.120 --> 14:28.120
是两个下滑线

14:28.120 --> 14:29.120
然后一个proto

14:29.120 --> 14:31.120
然后又是两个下滑线

14:31.120 --> 14:32.120
这是一个

14:32.120 --> 14:33.120
反而你看到这个东西

14:33.120 --> 14:35.120
两个下滑线开头的东西

14:35.120 --> 14:37.120
都表示的是一个系统变量

14:37.120 --> 14:39.120
不要去轻易使用的变量

14:39.120 --> 14:40.120
好

14:40.120 --> 14:41.120
那么这个东西

14:41.120 --> 14:43.120
看一下它是什么意思

14:44.120 --> 14:46.120
所有的对象

14:46.120 --> 14:48.120
都有一个属性

14:48.120 --> 14:53.100
proto

14:53.100 --> 14:55.100
称之为

14:55.100 --> 14:57.100
隐释原型

14:59.100 --> 15:00.100
马克当里面

15:00.100 --> 15:01.100
下滑线是个关键词

15:01.100 --> 15:03.100
我们这样子写

15:03.100 --> 15:05.100
它称之为隐释原型

15:05.100 --> 15:06.100
注意哦

15:06.100 --> 15:07.100
所有的对象

15:07.100 --> 15:08.100
都有一个属性

15:08.100 --> 15:10.100
称之为隐释原型

15:10.100 --> 15:11.100
好

15:11.100 --> 15:12.100
之前我们说的是

15:12.100 --> 15:14.100
所有的函数都有一个属性

15:14.100 --> 15:15.100
proto

15:15.100 --> 15:16.100
称之为函数原型

15:16.100 --> 15:17.100
好

15:17.100 --> 15:18.100
那么现在问你

15:18.100 --> 15:19.100
来 又来

15:19.100 --> 15:20.100
现在这个type

15:20.100 --> 15:21.100
是不是函数

15:21.100 --> 15:22.100
它是函数

15:22.100 --> 15:23.100
函数里面

15:23.100 --> 15:24.100
有没有proto

15:24.100 --> 15:26.100
先别管这个proto是啥

15:26.100 --> 15:27.100
有没有

15:27.100 --> 15:28.100
先说有没有

15:28.100 --> 15:30.100
有没有呢

15:30.100 --> 15:32.100
要理解这个中文

15:32.100 --> 15:34.100
要理解中文是什么意思

15:34.100 --> 15:35.100
所有的对象都有

15:35.100 --> 15:37.100
那函数是不是对象

15:37.100 --> 15:38.100
函数肯定是对象

15:38.100 --> 15:40.100
所以说函数里面一定有

15:40.100 --> 15:41.100
一定有

15:41.100 --> 15:42.100
先别管它是啥

15:42.100 --> 15:43.100
好

15:43.100 --> 15:44.100
然后再看

15:44.100 --> 15:45.100
然后呢

15:45.100 --> 15:46.100
我们的

15:48.100 --> 15:49.100
一个对象

15:49.100 --> 15:50.100
一个普通对象

15:50.100 --> 15:52.100
它里面有没有proto

15:52.100 --> 15:53.100
有没有

15:53.100 --> 15:54.100
有没有

15:54.100 --> 15:55.100
它肯定有

15:55.100 --> 15:57.100
我这个格式有问题

15:58.100 --> 15:59.100
这样子质面量的话

15:59.100 --> 16:00.100
你得这样子写

16:00.100 --> 16:01.100
把它扩起来

16:01.100 --> 16:02.100
不然的话它理解不了

16:02.100 --> 16:03.100
所以一定有

16:03.100 --> 16:04.100
对吧

16:04.100 --> 16:05.100
一定有

16:05.100 --> 16:06.100
它也有proto

16:06.100 --> 16:07.100
先别管这个东西是啥

16:07.100 --> 16:08.100
先别管这个东西是啥

16:08.100 --> 16:10.100
我们先把它理解清楚

16:10.100 --> 16:12.100
说每一个对象都有

16:12.100 --> 16:13.100
好

16:13.100 --> 16:14.100
那么现在再问你

16:14.100 --> 16:15.100
再问你

16:15.100 --> 16:16.100
一个普通对象

16:16.100 --> 16:17.100
我们这里写个普通

16:17.100 --> 16:18.100
就在这

16:18.100 --> 16:19.100
写个普通对象

16:20.100 --> 16:21.100
好

16:21.100 --> 16:22.100
那么这个ob界

16:22.100 --> 16:23.100
有没有这个

16:23.100 --> 16:24.100
proto type

16:24.100 --> 16:25.100
有没有

16:25.100 --> 16:27.410
有没有

16:27.410 --> 16:28.410
它就没有了

16:28.410 --> 16:29.410
没有了

16:29.410 --> 16:30.410
为什么

16:30.410 --> 16:31.410
它不是函数

16:31.410 --> 16:33.410
只有函数才有圆形

16:33.410 --> 16:34.410
圆形对象

16:34.410 --> 16:36.410
普通对象是没有这个proto type的

16:36.410 --> 16:38.410
但是普通对象它肯定有什么

16:38.410 --> 16:39.410
proto

16:39.410 --> 16:40.410
就是影视圆形

16:40.410 --> 16:41.410
先别管什么用

16:41.410 --> 16:42.410
好

16:42.410 --> 16:43.410
再来

16:43.410 --> 16:44.410
再来问你

16:44.410 --> 16:45.410
先把这个东西搞清楚

16:45.410 --> 16:46.410
好

16:46.410 --> 16:47.410
这是个函数

16:47.410 --> 16:48.410
函数里面是不是有proto type

16:48.410 --> 16:49.410
没问题吧

16:49.410 --> 16:50.410
没问题

16:50.410 --> 16:51.410
好

16:51.410 --> 16:52.410
那么这个proto type

16:52.410 --> 16:54.410
是不是个对象

16:54.410 --> 16:55.410
proto type

16:55.410 --> 16:58.410
是不是个对象

16:58.410 --> 16:59.410
是不是对象

16:59.410 --> 17:00.410
肯定是个对象

17:00.410 --> 17:01.410
对吧

17:01.410 --> 17:03.410
那么它有没有这个proto

17:03.410 --> 17:04.410
有没有

17:04.410 --> 17:05.410
有没有

17:05.410 --> 17:06.410
肯定有

17:06.410 --> 17:07.410
肯定有

17:07.410 --> 17:08.410
只要你是一个对象

17:08.410 --> 17:10.410
你不是圆形内形

17:10.410 --> 17:11.410
你只要不是圆形内形

17:11.410 --> 17:12.410
什么数字

17:12.410 --> 17:13.410
布尔

17:13.410 --> 17:14.410
你只要是对象

17:14.410 --> 17:15.410
那一定有proto

17:15.410 --> 17:16.410
这个毫无疑问

17:16.410 --> 17:17.410
它叫做影视圆形

17:17.410 --> 17:18.410
好

17:18.410 --> 17:19.410
那么这个影视圆形

17:19.410 --> 17:21.410
是啥东西呢

17:21.410 --> 17:23.410
影视圆形

17:23.410 --> 17:25.410
影视圆形

17:25.410 --> 17:27.410
指向谁呢

17:27.410 --> 17:28.410
指向

17:28.410 --> 17:29.410
创建

17:29.410 --> 17:30.410
该对象

17:30.410 --> 17:31.410
应该说默认情况下

17:31.410 --> 17:32.410
我们这几个

17:32.410 --> 17:34.410
只讨论默认情况

17:34.410 --> 17:36.410
默认情况下

17:36.410 --> 17:37.410
影视圆形

17:37.410 --> 17:38.410
指向

17:38.410 --> 17:39.410
创建

17:39.410 --> 17:40.410
该

17:40.410 --> 17:41.410
对象的

17:41.410 --> 17:42.410
函数的

17:42.410 --> 17:44.410
圆形

17:44.410 --> 17:45.410
它把两个字

17:45.410 --> 17:46.410
连起来了

17:47.410 --> 17:48.410
你也这句话

17:48.410 --> 17:49.410
这句话没几个字

17:49.410 --> 17:50.410
但是呢

17:50.410 --> 17:51.410
特别的糟

17:51.410 --> 17:52.410
对象

17:52.410 --> 17:53.410
是不是一定通过

17:53.410 --> 17:54.410
勾造函数产生的

17:54.410 --> 17:55.410
一个对象

17:55.410 --> 17:56.410
是不是一定通过

17:56.410 --> 17:57.410
勾造函数产生

17:57.410 --> 17:58.410
没问题吧

17:58.410 --> 18:00.410
我们刚才说了

18:00.410 --> 18:02.410
对象一定是溜出来的

18:02.410 --> 18:03.410
一定是溜出来的

18:03.410 --> 18:04.410
毫无疑问

18:04.410 --> 18:05.410
溜一个Object车

18:05.410 --> 18:06.410
或者是你写两个大伙号

18:06.410 --> 18:08.410
就相当于是溜一个Object车

18:08.410 --> 18:09.410
或者是溜一个

18:09.410 --> 18:10.410
自己写的函数Test

18:10.410 --> 18:12.410
对象一定是这样产生的

18:12.410 --> 18:13.410
包括函数

18:13.410 --> 18:14.410
函数它也是对象

18:14.410 --> 18:15.410
函数相当于是

18:15.410 --> 18:16.410
溜一个方式

18:16.410 --> 18:18.410
对象一定是溜出来的

18:19.410 --> 18:21.410
那么对象

18:21.410 --> 18:23.410
它有一个隐释圆形

18:23.410 --> 18:24.410
所有的对象都是溜出来的

18:24.410 --> 18:25.410
因此所有的对象

18:25.410 --> 18:26.410
都有一个隐释圆形

18:26.410 --> 18:27.410
隐释圆形

18:27.410 --> 18:28.410
它指向的是谁

18:28.410 --> 18:29.410
指向的是

18:29.410 --> 18:32.410
溜那个函数的圆形

18:32.410 --> 18:33.410
一定是通过一个函数

18:33.410 --> 18:34.410
来创立对象的

18:34.410 --> 18:35.410
因此

18:35.410 --> 18:36.410
它指向的是

18:36.410 --> 18:37.410
函数的圆形

18:37.410 --> 18:38.410
所以说

18:38.410 --> 18:40.410
这个Object

18:41.410 --> 18:43.410
它的隐释圆形

18:43.410 --> 18:46.410
它一定等于函数

18:46.410 --> 18:48.410
是这个函数在创建它

18:48.410 --> 18:49.410
对吧

18:49.410 --> 18:50.410
这个函数在创建它

18:50.410 --> 18:51.410
因此它一定等于

18:51.410 --> 18:52.410
这个函数的圆形

18:52.410 --> 18:54.410
这个函数是一定成立的

18:55.410 --> 18:56.410
好 咱们来看一下吧

18:56.410 --> 18:58.410
口说无凭

18:58.410 --> 19:00.410
Object点

19:00.410 --> 19:01.410
Prot

19:01.410 --> 19:03.410
是不是一定等于

19:03.410 --> 19:06.410
一定等于Test

19:06.410 --> 19:09.410
这个函数的Prot type

19:09.410 --> 19:10.410
你看

19:11.410 --> 19:13.410
我这里return了

19:13.410 --> 19:14.410
我这里return了这个

19:14.410 --> 19:15.410
我这里return了这个

19:15.410 --> 19:16.410
不要return这个

19:16.410 --> 19:17.410
return了这个就不一样了

19:17.410 --> 19:18.410
就不一样了

19:19.410 --> 19:20.410
是不是一定为出

19:20.410 --> 19:21.410
对吧 一定为出

19:21.410 --> 19:22.410
它一定指向

19:22.410 --> 19:23.410
创建它的

19:23.410 --> 19:25.410
构造函数的圆形

19:25.410 --> 19:26.410
那我刚才为什么不行

19:26.410 --> 19:27.410
刚才这样子不行

19:27.410 --> 19:28.410
为什么不行

19:28.410 --> 19:29.410
因为这个时候

19:29.410 --> 19:30.410
得到了对象

19:30.410 --> 19:31.410
是谁在创建的

19:31.410 --> 19:32.410
是哪个函数创建的

19:32.410 --> 19:33.410
不是Test

19:33.410 --> 19:34.410
是什么

19:34.410 --> 19:36.410
Object

19:36.410 --> 19:38.410
是这个东西创建的

19:38.410 --> 19:39.410
对吧

19:39.410 --> 19:40.410
所以说现在的Object

19:40.410 --> 19:41.410
如果现在这样子写的话

19:41.410 --> 19:43.410
那么Object的

19:43.410 --> 19:45.410
Object的引式元箱

19:45.410 --> 19:46.410
应该等于啥

19:46.410 --> 19:47.410
应该等于啥

19:47.410 --> 19:50.410
是不是等于Object的元箱

19:50.410 --> 19:51.410
应该等于这个

19:51.410 --> 19:53.410
应该的意思吧

19:53.410 --> 19:54.410
这个情况不太一样

19:54.410 --> 19:55.410
因为我之前说过了

19:55.410 --> 19:56.410
这个东西也是讲过的

19:56.410 --> 19:57.410
对不对

19:57.410 --> 19:58.410
如果你返回一个对象的话

19:58.410 --> 19:59.410
那么它得到的对象

19:59.410 --> 20:01.410
返回的结果

20:01.410 --> 20:02.410
那么这个对象

20:02.410 --> 20:03.410
就是6Object创建的

20:03.410 --> 20:04.410
因此

20:04.410 --> 20:05.410
我们这里得到的对象

20:05.410 --> 20:07.410
是6Object的

20:07.410 --> 20:08.410
它的引式元箱

20:08.410 --> 20:11.410
等于Object的元箱

20:11.410 --> 20:12.410
总之一个对象

20:12.410 --> 20:13.410
你甭管它怎么绕

20:13.410 --> 20:15.410
它只要创建的时候

20:15.410 --> 20:17.410
是用哪个对象创建的

20:17.410 --> 20:19.410
那么它就指向哪个对象的

20:19.410 --> 20:22.410
它就指向哪个对象的元箱

20:22.410 --> 20:23.410
好

20:23.410 --> 20:24.410
那么于是呢

20:24.410 --> 20:26.410
这里我们这里有道题

20:26.410 --> 20:28.410
有道面试题

20:28.410 --> 20:30.410
只要出道面试题的话

20:30.410 --> 20:32.410
我们这里首先要了解一个知识

20:32.410 --> 20:34.410
就是每一个函数有一个数项

20:34.410 --> 20:35.410
我们之前好像讲过的

20:35.410 --> 20:37.410
就是函数的名称

20:37.410 --> 20:39.410
有这么一个数项得到函数的名称

20:39.410 --> 20:42.410
那么现在有这么一道面试题

20:42.410 --> 20:43.410
来看一下

20:43.410 --> 20:47.170
TES2

20:47.170 --> 20:49.170
这面试题考的它有点偏了

20:49.170 --> 20:50.170
有点偏

20:50.170 --> 20:51.170
但是呢

20:51.170 --> 20:53.170
确实有这么个道理

20:53.170 --> 20:55.170
比方说一个函数

20:55.170 --> 20:57.170
Crate这个函数

20:57.170 --> 20:58.170
这个函数呢

20:58.170 --> 21:00.170
判断一下

21:00.170 --> 21:02.170
它是用一个随机数

21:02.170 --> 21:04.170
小于0.5的时候

21:04.170 --> 21:06.170
随机数小于0.5

21:06.170 --> 21:07.170
我返回一个啥呢

21:07.170 --> 21:09.170
返回一个空对象

21:09.170 --> 21:10.170
好

21:10.170 --> 21:11.170
Ls呢

21:11.170 --> 21:13.170
返回一个数组

21:13.170 --> 21:15.170
看着

21:15.170 --> 21:17.170
它要么返回一个空对象

21:17.170 --> 21:19.170
要么返回一个数组

21:19.170 --> 21:20.170
然后呢

21:20.170 --> 21:23.170
它得到这个函数得到的结果

21:23.170 --> 21:24.170
雕用函数

21:24.170 --> 21:25.170
雕用函数

21:25.170 --> 21:26.170
然后得到一个结果

21:26.170 --> 21:27.170
保存到变量OB界里边

21:27.170 --> 21:29.170
然后现在问你

21:29.170 --> 21:32.170
如何得到OB界的

21:32.170 --> 21:36.170
如何得到创建OB界的

21:36.170 --> 21:39.170
勾造函数名称

21:40.170 --> 21:41.170
来吧

21:41.170 --> 21:42.170
想一想啊

21:42.170 --> 21:44.170
你如何才能得到

21:44.170 --> 21:46.170
创建OB界

21:46.170 --> 21:47.170
OB界肯定是通过

21:47.170 --> 21:48.170
勾造函数创建的吧

21:48.170 --> 21:49.170
任何对象都是通过

21:49.170 --> 21:50.170
勾造函数创建的

21:50.170 --> 21:51.170
因此呢

21:51.170 --> 21:52.170
现在问你

21:52.170 --> 21:53.170
怎么得到OB界

21:53.170 --> 21:56.170
这个勾造函数的名字叫啥

21:56.170 --> 21:57.170
它是不是有两种情况

21:57.170 --> 21:58.170
对吧

21:58.170 --> 21:59.170
一定有两种情况嘛

21:59.170 --> 22:00.170
要么得到它

22:00.170 --> 22:01.170
要么得到一个Object车

22:01.170 --> 22:02.170
对吧

22:02.170 --> 22:03.170
Object车是勾造函数

22:03.170 --> 22:04.170
要么是

22:04.170 --> 22:05.170
Erase勾造函数

22:06.170 --> 22:07.170
有些同学呢

22:07.170 --> 22:08.170
很取巧

22:08.170 --> 22:09.170
他很取巧

22:09.170 --> 22:10.170
他怎么做呢

22:10.170 --> 22:11.170
他这样子

22:11.170 --> 22:12.170
Erase

22:12.170 --> 22:13.170
Ease Erase

22:13.170 --> 22:15.170
他是不是一个数组

22:15.170 --> 22:17.170
是不是一个数组

22:17.170 --> 22:18.170
如果是数组的话

22:18.170 --> 22:20.170
那么我们就输出什么

22:20.170 --> 22:22.170
输出Erase

22:22.170 --> 22:24.170
Else的话就输出Object车

22:24.170 --> 22:25.170
对吧

22:25.170 --> 22:26.170
用这种取巧的办法

22:26.170 --> 22:27.170
方式来做

22:27.170 --> 22:28.170
但是这样做并不好

22:28.170 --> 22:29.170
因为为什么呢

22:29.170 --> 22:30.170
那这里我反回的

22:30.170 --> 22:31.170
不是数组呢

22:31.170 --> 22:32.170
比方说

22:32.170 --> 22:34.170
比方说我反回的是一个什么呢

22:34.170 --> 22:35.170
反回的是一个

22:35.170 --> 22:37.170
比方说再一个函数

22:38.170 --> 22:40.170
A

22:40.170 --> 22:41.170
再一个函数

22:41.170 --> 22:42.170
B

22:42.170 --> 22:44.170
好我这里反回的是

22:44.170 --> 22:46.170
六一个A的对象

22:46.170 --> 22:47.170
这个六一个B的对象

22:47.170 --> 22:48.170
那又咋办了

22:48.170 --> 22:49.170
又咋办了

22:49.170 --> 22:50.170
对吧

22:50.170 --> 22:51.170
好

22:51.170 --> 22:52.170
那么我们现在

22:52.170 --> 22:53.170
如何来得到

22:53.170 --> 22:55.170
Object的勾造函数名称呢

22:55.170 --> 22:56.170
你看着

22:56.170 --> 22:58.170
我们可以这样子写

22:58.170 --> 23:00.170
Object是不是有隐私原型

23:00.170 --> 23:02.170
我甭管他是谁创建的

23:02.170 --> 23:04.170
他一定有个隐私原型对吧

23:04.170 --> 23:05.170
隐私原型指向谁

23:05.170 --> 23:06.170
是不是指向

23:06.170 --> 23:09.170
创建他的勾造函数的原型

23:09.170 --> 23:11.170
如果是A创建他

23:11.170 --> 23:13.170
那么他就会指向A的原型

23:13.170 --> 23:14.170
如果是B创建他

23:14.170 --> 23:16.170
他就指向了B的原型对吧

23:16.170 --> 23:17.170
好

23:17.170 --> 23:18.170
那么指向了一个原型

23:18.170 --> 23:21.170
原型里面是不是有个Constructor

23:21.170 --> 23:22.170
对吧

23:22.170 --> 23:23.170
Constructor是不是

23:23.170 --> 23:24.170
表示了

23:24.170 --> 23:26.170
这个原型是哪个勾造函数的

23:26.170 --> 23:27.170
是哪个函数的

23:27.170 --> 23:28.170
还有指向函数

23:28.170 --> 23:30.170
函数里面是不是有个Name属性

23:30.170 --> 23:31.170
对吧

23:31.170 --> 23:33.170
就得到勾造函数的名称了

23:33.170 --> 23:34.170
看一下吧

23:34.170 --> 23:36.610
好 这里

23:36.610 --> 23:37.610
看一下

23:37.610 --> 23:38.610
来 这里

23:38.610 --> 23:39.610
A 刷新

23:39.610 --> 23:40.610
A 再来

23:40.610 --> 23:41.610
刷新

23:41.610 --> 23:42.610
B 看没

23:43.610 --> 23:44.610
你只要拿到一个对象

23:44.610 --> 23:46.610
你一定能得到它的勾造函数

23:46.610 --> 23:47.610
这就是它的勾造函数

23:47.610 --> 23:49.610
你一定能得到它的什么

23:49.610 --> 23:51.610
得到它的勾造函数名称

23:51.610 --> 23:52.610
屌内

23:52.610 --> 23:53.610
对不对

23:53.610 --> 23:55.610
好 这里有张图

23:55.610 --> 23:57.610
大家可以看得更加清楚一点

23:58.610 --> 24:00.610
我看一下是哪张图

24:01.610 --> 24:02.610
不是这张

24:02.610 --> 24:03.610
不是这张

24:03.610 --> 24:04.610
不是这张

24:07.610 --> 24:08.610
不是这张

24:08.610 --> 24:09.610
不是这张

24:10.610 --> 24:11.610
好 这里

24:11.610 --> 24:12.610
好 看着

24:12.610 --> 24:14.610
比方说有个函数

24:14.610 --> 24:15.610
ADD

24:15.610 --> 24:17.610
ADD是不是可以通过它去留一个对象

24:17.610 --> 24:18.610
对吧

24:18.610 --> 24:19.610
可以留一个对象

24:19.610 --> 24:20.610
跟着我的鼠标走

24:20.610 --> 24:21.610
它可以通过它留一个对象

24:21.610 --> 24:23.610
也可以通过它去留一个对象

24:23.610 --> 24:24.610
看没

24:24.610 --> 24:26.610
一个函数是不是可以产生很多的对象

24:26.610 --> 24:27.610
你每一次留一个函数

24:27.610 --> 24:28.610
它就产生一个对象

24:28.610 --> 24:29.610
对不对

24:29.610 --> 24:30.610
函数本身有圆形

24:30.610 --> 24:31.610
看没

24:31.610 --> 24:32.610
Prototype

24:32.610 --> 24:33.610
它指向一个圆形

24:33.610 --> 24:34.610
而圆形

24:34.610 --> 24:35.610
它还有一个conflict

24:35.610 --> 24:36.610
它又指回来

24:36.610 --> 24:37.610
这是我们之前讲的

24:37.610 --> 24:39.610
好 所有的产生的对象

24:39.610 --> 24:40.610
是不是都有隐私圆形

24:40.610 --> 24:41.610
对吧

24:41.610 --> 24:42.610
所有的对象

24:42.610 --> 24:43.610
是不是都有隐私圆形

24:43.610 --> 24:44.610
而它的隐私圆形

24:44.610 --> 24:45.610
是不是有指向函数的圆形

24:45.610 --> 24:46.610
看没

24:46.610 --> 24:47.610
它形成这么一种结构

24:47.610 --> 24:48.610
看没

24:49.610 --> 24:50.610
好好看一下这个图

24:51.610 --> 24:52.610
那么从这个图中

24:52.610 --> 24:53.610
我们可以发现一个现象

24:53.610 --> 24:54.610
什么现象

24:55.610 --> 24:57.610
就是说

24:57.610 --> 24:58.610
我们从这个图里边

24:58.610 --> 24:59.610
我们可以看到一个结果

24:59.610 --> 25:01.610
就是所有的对象

25:02.610 --> 25:04.610
通过同一个构造函数产生的对象

25:05.610 --> 25:06.610
他们会有一块

25:06.610 --> 25:08.610
内存空间是共用的

25:08.610 --> 25:09.610
什么内存空间

25:09.610 --> 25:11.610
就他们的隐私圆形

25:11.610 --> 25:12.610
指向的内存空间

25:12.610 --> 25:13.610
是不是共用的

25:13.610 --> 25:14.610
跟这个函数

25:14.610 --> 25:15.610
它的圆形

25:15.610 --> 25:16.610
是不是一致的

25:16.610 --> 25:17.610
对吧

25:17.610 --> 25:18.610
一致的对不对

25:18.610 --> 25:19.610
你看这个空间

25:19.610 --> 25:20.610
ADD的圆形

25:20.610 --> 25:21.610
它这个空间

25:21.610 --> 25:22.610
是不是被所有的对象

25:22.610 --> 25:23.610
共享

25:23.610 --> 25:24.610
对吧

25:24.610 --> 25:25.610
共享一块空间

25:25.610 --> 25:27.610
那么就意味着啥

25:27.610 --> 25:28.610
比方说

25:28.610 --> 25:29.610
比方说

25:29.610 --> 25:31.610
咱们来玩这么一些烧操作

25:33.610 --> 25:34.610
再见一个

25:34.610 --> 25:35.610
TESLA3

25:36.610 --> 25:37.610
就一个

25:37.610 --> 25:38.610
构造函数A

25:38.610 --> 25:39.610
我通过A

25:39.610 --> 25:40.610
拿窗戒两个对象

25:40.610 --> 25:41.610
六一个A

25:42.610 --> 25:43.610
这里也容易出面词题

25:43.610 --> 25:44.610
不过这种面词题

25:45.610 --> 25:46.610
我一讲了之后

25:46.610 --> 25:47.610
对于你们来说

25:47.610 --> 25:48.610
就非常简单了

25:49.610 --> 25:50.610
这是两个对象

25:50.610 --> 25:51.610
对吧

25:51.610 --> 25:52.610
温妮这个面词

25:52.610 --> 25:53.610
它这样子写的

25:53.610 --> 25:55.610
ABC

25:55.610 --> 25:56.610
把它复制为123

25:57.610 --> 25:58.610
好

25:58.610 --> 25:59.610
然后

25:59.610 --> 26:01.610
obj2.

26:02.610 --> 26:03.610
proto

26:04.610 --> 26:05.610
2

26:05.610 --> 26:06.610
然后

26:06.610 --> 26:07.610
BCD

26:07.610 --> 26:09.610
复制为456

26:09.610 --> 26:10.610
现在

26:10.610 --> 26:11.610
输出

26:11.610 --> 26:13.610
输出obj1.abc

26:13.610 --> 26:15.610
obj2.abc

26:17.610 --> 26:18.610
这样子

26:18.610 --> 26:20.610
输出obj1.abc

26:20.610 --> 26:22.610
obj2.abc

26:22.610 --> 26:23.610
然后

26:23.610 --> 26:24.610
再输出

26:24.610 --> 26:26.610
obj1.

26:27.610 --> 26:28.610
proto

26:28.610 --> 26:29.610
proto

26:29.610 --> 26:30.610
abc

26:30.610 --> 26:31.610
bcd

26:31.610 --> 26:33.610
然后输出obj2.

26:33.610 --> 26:34.610
proto

26:36.610 --> 26:37.610
bcd

26:37.610 --> 26:38.610
好

26:38.610 --> 26:39.610
问你输出啥

26:39.610 --> 26:40.610
这题其实蛮简单的

26:40.610 --> 26:41.610
真的蛮简单的

26:42.610 --> 26:43.610
输出啥呢

26:44.610 --> 26:45.610
好

26:45.610 --> 26:46.610
你看着

26:46.610 --> 26:47.610
首先看abc

26:47.610 --> 26:48.610
对吧

26:48.610 --> 26:49.610
这是两个对象

26:49.610 --> 26:50.610
对不对

26:50.610 --> 26:51.610
两个不同的对象

26:51.610 --> 26:53.610
你改了obj1.abc

26:53.610 --> 26:54.610
你改的是它

26:54.610 --> 26:55.610
它这个俗象

26:55.610 --> 26:56.610
跟obj2有啥关系呢

26:56.610 --> 26:57.610
所以说

26:57.610 --> 26:58.610
第一个输出什么

26:58.610 --> 26:59.610
123

26:59.610 --> 27:00.610
然后undefend

27:00.610 --> 27:01.610
对吧

27:01.610 --> 27:02.610
第一个没啥好说的

27:02.610 --> 27:03.610
关键是第二个

27:04.610 --> 27:05.610
第二个

27:05.610 --> 27:07.610
为什么都输出456呢

27:07.610 --> 27:10.610
因为这个obj1的影视圆形

27:10.610 --> 27:12.610
跟obj2的影视圆形

27:12.610 --> 27:13.610
是不是一样的

27:13.610 --> 27:14.610
是同一块内存空间

27:14.610 --> 27:15.610
他们共同指向

27:15.610 --> 27:16.610
同一个内存空间

27:16.610 --> 27:17.610
对吧

27:17.610 --> 27:19.610
指向的是同一个圆形

27:19.610 --> 27:20.610
好

27:20.610 --> 27:21.610
那么我们来问一下大家

27:21.610 --> 27:22.610
这个东西无论怎么绕

27:22.610 --> 27:24.610
不要被绕住了

27:24.610 --> 27:25.610
proto

27:25.610 --> 27:28.610
东西是不是等于obj2的proto

27:28.610 --> 27:29.610
是不是等于

27:29.610 --> 27:30.610
对吧

27:30.610 --> 27:31.610
一定是相等的

27:31.610 --> 27:32.610
对吧

27:32.610 --> 27:33.610
一定是相等的

27:33.610 --> 27:34.610
那么再问大家一个问题

27:34.610 --> 27:36.610
obj1的proto

27:36.610 --> 27:37.610
影视圆形

27:37.610 --> 27:38.610
是不是等于

27:38.610 --> 27:40.610
函数a的圆形

27:40.610 --> 27:41.610
是不是也是相等的

27:41.610 --> 27:42.610
这几个是一个东西

27:42.610 --> 27:43.610
是一个东西

27:43.610 --> 27:44.610
看到没

27:44.610 --> 27:46.610
是一个东西

27:46.610 --> 27:48.610
那么就意味着啥呢

27:48.610 --> 27:49.610
就意味着

27:49.610 --> 27:52.610
我们改变obj1的影视圆形

27:52.610 --> 27:53.610
那不是obj2也改变了

27:53.610 --> 27:54.610
反之也是一样

27:54.610 --> 27:55.610
obj2的影视圆形一改

27:55.610 --> 27:57.610
那么obj1是不是也改了

27:57.610 --> 27:58.610
对吧

27:58.610 --> 27:59.610
他们共享这一块内存空间

27:59.610 --> 28:00.610
看到没

28:00.610 --> 28:01.610
好

28:01.610 --> 28:02.610
所以说呢这里

28:02.610 --> 28:03.610
我改动了啥

28:03.610 --> 28:05.610
改动了这个obj2的影视圆形中的

28:05.610 --> 28:06.610
bcd

28:06.610 --> 28:07.610
加了一个属性

28:07.610 --> 28:08.610
那么obj1的影视圆形

28:08.610 --> 28:09.610
是不是也加了一个属性

28:09.610 --> 28:10.610
他们是一块内存空间

28:10.610 --> 28:12.610
所以说这一块呢

28:12.610 --> 28:13.610
这一块呢

28:13.610 --> 28:14.610
我们刷新一下

28:14.610 --> 28:15.610
这一块

28:15.610 --> 28:16.610
不仅这两个改了

28:16.610 --> 28:17.610
还有什么

28:17.610 --> 28:18.610
a元素的proto type里边

28:18.610 --> 28:20.610
是不是也有一个bcd

28:20.610 --> 28:21.610
看到没

28:21.610 --> 28:22.610
是不是一样的

28:22.610 --> 28:23.610
这三个东西是一个东西

28:23.610 --> 28:24.610
对吧

28:24.610 --> 28:25.610
哎

28:25.610 --> 28:27.610
这就有意思了

28:27.610 --> 28:28.610
有意思了

28:28.610 --> 28:29.610
我们可以怎么玩了

28:29.610 --> 28:30.610
这个东西

28:30.610 --> 28:31.610
我们可以玩出这样的

28:31.610 --> 28:33.610
这样一个操作

28:33.610 --> 28:34.610
我们之前不是

28:34.610 --> 28:35.610
写构造函数吗

28:35.610 --> 28:36.610
对吧

28:36.610 --> 28:37.610
构造函数创建一个

28:37.610 --> 28:38.610
什么

28:38.610 --> 28:39.610
创建一个对象

28:39.610 --> 28:40.610
对吧

28:40.610 --> 28:41.610
有点吗

28:41.610 --> 28:42.610
构造函数

28:42.610 --> 28:43.610
你给我一个什么

28:43.610 --> 28:44.610
给我一个name

28:44.610 --> 28:45.610
给我一个年年

28:45.610 --> 28:46.610
对吧

28:46.610 --> 28:47.610
我创建一个对象

28:47.610 --> 28:48.610
对吧

28:48.610 --> 28:49.610
好

28:49.610 --> 28:50.610
看着

28:50.610 --> 28:51.610
name

28:51.610 --> 28:52.610
对象

28:52.610 --> 28:53.610
那么之前

28:53.610 --> 28:54.610
我要给对象加

28:54.610 --> 28:55.610
一些函数的时候

28:55.610 --> 28:56.610
我怎么加的呢

28:56.610 --> 28:57.610
我是怎么加的

28:57.610 --> 28:58.610
属性呢

28:58.610 --> 28:59.610
我是直接放了对象上面

28:59.610 --> 29:00.610
对吧

29:00.610 --> 29:01.610
属性呢

29:01.610 --> 29:02.610
我是分别把它

29:02.610 --> 29:03.610
放到不同的对象上面

29:03.610 --> 29:04.610
比方说

29:04.610 --> 29:05.610
我先看属性

29:05.610 --> 29:06.610
U1

29:06.610 --> 29:07.610
等于6一个U2

29:07.610 --> 29:08.610
ABC

29:08.610 --> 29:09.610
年年年年年年

29:09.610 --> 29:10.610
U2

29:10.610 --> 29:11.610
等于6一个U2

29:11.610 --> 29:12.610
BCD

29:12.610 --> 29:13.610
年年年年年

29:13.610 --> 29:14.610
12

29:14.610 --> 29:15.610
比方说

29:15.610 --> 29:16.610
这有两个对象

29:16.610 --> 29:17.610
那么这两个属性

29:17.610 --> 29:18.610
你看传进去过后

29:18.610 --> 29:19.610
这两个属性

29:19.610 --> 29:20.610
他们在哪

29:20.610 --> 29:21.610
对象1有自己的属性

29:21.610 --> 29:22.610
对象2有自己的属性

29:22.610 --> 29:23.610
他们在对象里面

29:23.610 --> 29:24.610
对吧

29:24.610 --> 29:25.610
因为你是通过

29:25.610 --> 29:26.610
通过Z10

29:26.610 --> 29:27.610
Z10就是对象

29:27.610 --> 29:28.610
对吧

29:28.610 --> 29:29.610
直接给对象的属性负责的

29:29.610 --> 29:30.610
他在对象里面

29:30.610 --> 29:32.610
他们是互不干扰的

29:32.610 --> 29:34.610
然后我们以前的写

29:34.610 --> 29:36.610
我想给对象加一个函数

29:36.610 --> 29:37.610
以前我咋写的

29:37.610 --> 29:38.610
我是这样写的

29:38.610 --> 29:39.610
Say hello

29:39.610 --> 29:40.610
打个招呼

29:40.610 --> 29:41.610
我怎么写的呢

29:41.610 --> 29:42.610
我们是这样写的

29:43.610 --> 29:44.610
我们这里输出

29:44.610 --> 29:45.610
Hello

29:45.610 --> 29:46.610
比方说Hello

29:47.610 --> 29:48.610
Hello

29:49.610 --> 29:51.610
那么如果我这样子写的话

29:51.610 --> 29:52.610
你看一下

29:52.610 --> 29:53.610
这个函数是不是

29:53.610 --> 29:54.610
我们来看一下

29:54.610 --> 29:55.610
看一下这样子

29:55.610 --> 29:57.610
如果我这样子写的话

29:57.610 --> 29:58.610
这个U1

29:58.610 --> 29:59.610
这里运行出来

30:00.610 --> 30:02.610
这样子写是会有些问题的

30:02.610 --> 30:03.610
这个问题虽然不是很严重

30:03.610 --> 30:05.610
但是有的时候也蛮严重的

30:05.610 --> 30:07.610
U1的 say hello

30:07.610 --> 30:08.610
跟这个U2的 say hello

30:08.610 --> 30:09.610
是不是一个东西

30:09.610 --> 30:13.110
是不是一个东西

30:13.110 --> 30:14.110
好好看一下

30:14.110 --> 30:16.110
凭什么是一个东西呢

30:16.110 --> 30:17.110
你这个东西都不是一个东西

30:17.110 --> 30:18.110
他凭什么这个东西

30:18.110 --> 30:19.110
就是一个东西呢

30:19.110 --> 30:20.110
他还是

30:20.110 --> 30:21.110
各有各的

30:21.110 --> 30:22.110
各是各的

30:22.110 --> 30:24.110
看一下等于是force

30:24.110 --> 30:25.110
他们函数是不一样的

30:25.110 --> 30:26.110
也就是说

30:26.110 --> 30:27.110
每一式创建对象的时候

30:27.110 --> 30:28.110
我都要去重复的

30:28.110 --> 30:29.110
创建这些函数

30:29.110 --> 30:30.110
对吧

30:30.110 --> 30:32.110
但是这些对象的函数有变化没

30:32.110 --> 30:33.110
所以没啥变化

30:33.110 --> 30:34.110
这些函数有啥变化呢

30:34.110 --> 30:35.110
对不对

30:35.110 --> 30:37.110
属性的值会有变化

30:37.110 --> 30:38.110
会有差异

30:38.110 --> 30:39.110
但是函数有啥差异呢

30:39.110 --> 30:40.110
对吧

30:40.110 --> 30:41.110
我又不让你去

30:41.110 --> 30:42.110
传一个函数进来

30:42.110 --> 30:44.110
当然如果你要传一个函数进来的话

30:44.110 --> 30:45.110
可以这样子写

30:45.110 --> 30:46.110
但这种情况很少很少

30:46.110 --> 30:47.110
几乎是看不见的

30:47.110 --> 30:49.110
我们函数一般都是加上去的

30:49.110 --> 30:50.110
那这个函数呢

30:50.110 --> 30:52.110
我们是不是可以让它共享

30:52.110 --> 30:53.110
所有的对象共享

30:53.110 --> 30:54.110
对吧

30:54.110 --> 30:55.110
看这张图

30:55.110 --> 30:57.110
我是不是可以把函数放这儿

30:57.110 --> 30:58.110
对吧

30:58.110 --> 31:00.110
可以把函数放这儿

31:00.110 --> 31:01.110
因此呢

31:01.110 --> 31:02.110
我们可以咋写呢

31:02.110 --> 31:03.110
可以咋写

31:03.110 --> 31:05.110
我们可以用user点什么

31:05.110 --> 31:06.110
prototype

31:06.110 --> 31:07.110
点什么

31:07.110 --> 31:08.110
点

31:08.110 --> 31:10.110
往这个圆形里边

31:10.110 --> 31:11.110
加一个函数

31:11.110 --> 31:12.110
say hello

31:13.110 --> 31:14.110
看一下

31:14.110 --> 31:15.110
我们说说 hello

31:16.110 --> 31:17.110
那么这样子呢

31:17.110 --> 31:18.110
我就把这个say hello

31:18.110 --> 31:19.110
放哪儿了

31:19.110 --> 31:20.110
放到哪儿了

31:20.110 --> 31:21.110
放到这个圆形里边了

31:21.110 --> 31:22.110
而这个圆形

31:22.110 --> 31:23.110
是不是被所有对象共享的

31:23.110 --> 31:24.110
只要通过它创建的

31:24.110 --> 31:25.110
是不是都有这个东西

31:25.110 --> 31:26.110
对吧

31:26.110 --> 31:27.110
都有这个东西

31:27.110 --> 31:29.110
这就体现出差异的

31:29.110 --> 31:30.110
通过不孔的

31:30.110 --> 31:31.110
构造函数创建的对象

31:31.110 --> 31:32.110
它就有差异的

31:32.110 --> 31:33.110
因为它们的圆形不一样

31:33.110 --> 31:34.110
好

31:34.110 --> 31:35.110
圆形里边是可以有东西的

31:35.110 --> 31:36.110
对吧

31:36.110 --> 31:37.110
可以有东西的

31:37.110 --> 31:38.110
因此呢

31:38.110 --> 31:39.110
我们这个user

31:39.110 --> 31:40.110
这个u1u2

31:40.110 --> 31:41.110
是不是可以使用的东西的

31:41.110 --> 31:42.110
看着

31:42.110 --> 31:43.110
u1的

31:43.110 --> 31:44.110
prototype

31:44.110 --> 31:45.110
它的什么

31:45.110 --> 31:46.110
say hello

31:46.110 --> 31:47.110
你看是不是可以使用的

31:47.110 --> 31:48.110
调用它

31:48.110 --> 31:50.110
是不是可以得到 hello 了

31:50.110 --> 31:52.110
并且u2是不是也一样的

31:52.110 --> 31:53.110
u2

31:53.110 --> 31:54.110
所以也可以这样做

31:54.110 --> 31:55.110
对吧

31:55.110 --> 31:57.110
那么现在这两个u1的

31:57.110 --> 31:58.110
prototype

32:03.110 --> 32:04.110
say hello

32:04.110 --> 32:05.110
跟这个u2的

32:05.110 --> 32:07.110
u2的prototype

32:07.110 --> 32:08.110
say hello

32:08.110 --> 32:09.110
是不是一样的

32:09.110 --> 32:10.110
他们是不是一样的

32:10.110 --> 32:11.110
他们肯定是一样的

32:11.110 --> 32:13.110
他们共用一块的一种空间

32:13.110 --> 32:14.110
他们都是对象里面的属性

32:14.110 --> 32:15.110
所以说他们是一样的

32:15.110 --> 32:17.110
看明白没

32:17.110 --> 32:18.110
好

32:18.110 --> 32:19.110
咱们再看

32:19.110 --> 32:20.110
还有一个特别

32:20.110 --> 32:21.110
特别牛的特点

32:21.110 --> 32:23.110
什么特点呢

32:23.110 --> 32:25.110
当访问

32:25.110 --> 32:27.110
无论是复职也好

32:27.110 --> 32:28.110
还是获取也好

32:28.110 --> 32:30.110
访问一个对象的成员时

32:30.110 --> 32:31.110
这个成员

32:31.110 --> 32:32.110
无论是方法也好

32:32.110 --> 32:33.110
还是属性也好

32:33.110 --> 32:36.490
它是按照这样的顺序来看的

32:36.490 --> 32:37.490
第一个

32:37.490 --> 32:38.490
第一步

32:38.490 --> 32:40.490
看该对象

32:40.490 --> 32:41.490
自身

32:41.490 --> 32:44.490
是否拥有该成员

32:46.490 --> 32:47.490
如果有

32:47.490 --> 32:48.490
如果有

32:48.490 --> 32:49.490
直接使用

32:49.490 --> 32:50.490
如果没有了

32:50.490 --> 32:51.490
如果没有

32:51.490 --> 32:52.490
进入第二步

32:52.490 --> 32:54.490
看该对象的

32:54.490 --> 32:56.490
影视员形中

32:58.490 --> 32:59.490
影视员形中

32:59.490 --> 33:01.490
是否拥有该成员

33:03.490 --> 33:04.490
如果有

33:04.490 --> 33:05.490
直接使用

33:05.490 --> 33:08.500
有意思吗

33:09.500 --> 33:10.500
u1

33:10.500 --> 33:11.500
say hello

33:12.500 --> 33:14.500
为什么可以访问

33:14.500 --> 33:16.500
为什么可以访问

33:16.500 --> 33:18.500
我不用什么点影视员形了

33:18.500 --> 33:19.500
直接访问

33:19.500 --> 33:21.500
为什么可以直接访问呢

33:21.500 --> 33:22.500
看图

33:23.500 --> 33:25.500
我访问对象1的say hello

33:25.500 --> 33:26.500
它有吗

33:26.500 --> 33:27.500
它是不是没有

33:27.500 --> 33:28.500
它哪有这个属性啊

33:28.500 --> 33:29.500
对象1里边哪有这个属性啊

33:29.500 --> 33:30.500
没有

33:30.500 --> 33:31.500
我们来看一下

33:31.500 --> 33:32.500
打印这个对象1

33:32.500 --> 33:33.500
U1

33:33.500 --> 33:34.500
看一下

33:34.500 --> 33:35.500
它里边有这个属性吗

33:35.500 --> 33:36.500
有say hello吗

33:36.500 --> 33:37.500
没有对吧

33:37.500 --> 33:38.500
没有

33:38.500 --> 33:39.500
好 这里边没有

33:39.500 --> 33:40.500
它找不到了

33:40.500 --> 33:41.500
第一步它找不到了

33:42.500 --> 33:43.500
第一步找不到了

33:43.500 --> 33:44.500
它就会从第二步去找

33:44.500 --> 33:45.500
直接找

33:45.500 --> 33:47.500
于是看对象的影视员形中

33:47.500 --> 33:48.500
你看下边

33:48.500 --> 33:49.500
是不是影视员形

33:49.500 --> 33:50.500
影视员形里边

33:50.500 --> 33:51.500
看一下有没有这个

33:51.500 --> 33:52.500
say hello

33:52.500 --> 33:53.500
有没有

33:53.500 --> 33:54.500
有没有say hello

33:54.500 --> 33:55.500
是不是有

33:55.500 --> 33:56.500
对不对

33:56.500 --> 33:57.500
那是不是找到了

33:57.500 --> 33:58.500
就可以使用了

33:59.500 --> 34:00.500
看到没

34:00.500 --> 34:02.500
这就是它的查找方式

34:02.500 --> 34:04.500
那么就解释了

34:04.500 --> 34:05.500
很多很多现象了

34:05.500 --> 34:06.500
首先解释了啥呢

34:06.500 --> 34:08.500
解释了MDN上

34:08.500 --> 34:09.500
我们看一下

34:09.500 --> 34:10.500
Array随便找一个

34:10.500 --> 34:12.500
随便找一个MDN

34:12.500 --> 34:15.500
MDN上呢

34:15.500 --> 34:16.500
它凭是我们解释

34:16.500 --> 34:17.500
之前说的是什么

34:17.500 --> 34:19.500
实力成员对吧

34:19.500 --> 34:20.500
实力成员的时候

34:20.500 --> 34:22.500
它是用什么名词来说的

34:22.500 --> 34:23.500
实力成员

34:23.500 --> 34:24.500
它说

34:24.500 --> 34:26.500
所有的数组实力

34:26.500 --> 34:27.500
实力成员就是它的对象

34:27.500 --> 34:28.500
都会从这里

34:28.500 --> 34:29.500
继承属性的方法

34:29.500 --> 34:30.500
就这里边有的它都有

34:30.500 --> 34:31.500
对吧

34:31.500 --> 34:32.500
为什么都有

34:32.500 --> 34:33.500
就是因为影视员形

34:33.500 --> 34:34.500
影视员形的存在

34:34.500 --> 34:35.500
影视员形

34:35.500 --> 34:37.500
是不是指向这个函数的员形

34:37.500 --> 34:38.500
因此呢啥呢

34:38.500 --> 34:39.500
我们之前写的那些

34:39.500 --> 34:41.500
数组的一些函数

34:41.500 --> 34:42.500
我们写的那些数组的函数

34:42.500 --> 34:43.500
在哪儿了

34:43.500 --> 34:45.500
我们比方说建立一个数组

34:45.500 --> 34:46.500
创建一个数组

34:46.500 --> 34:47.500
你看一下这个数组里边

34:47.500 --> 34:49.500
本来只有一个属性Lens的

34:49.500 --> 34:51.500
但是它的影视员形里边

34:51.500 --> 34:52.500
是不是有这些东西

34:52.500 --> 34:53.500
Concrete拼接数组

34:53.500 --> 34:54.500
对吧

34:54.500 --> 34:56.500
还有什么Avery, Feel

34:56.500 --> 34:57.500
看到没

34:57.500 --> 34:59.500
为什么所有的数组都有这个函数

34:59.500 --> 35:00.500
是因为他们指向的

35:00.500 --> 35:02.500
影视员形里边

35:02.500 --> 35:03.500
就是数组的员形里边

35:03.500 --> 35:04.500
是不是有这些东西

35:04.500 --> 35:05.500
对吧

35:05.500 --> 35:06.500
所以说这些函数

35:06.500 --> 35:08.500
是不是数组的员形里边了

35:08.500 --> 35:09.500
你看一下

35:09.500 --> 35:10.500
我们打印出Avery的

35:10.500 --> 35:11.500
员形

35:11.500 --> 35:13.500
看一下这个员形里边

35:13.500 --> 35:14.500
是不是有很多这些东西

35:14.500 --> 35:15.500
inclusive

35:15.500 --> 35:16.500
index of

35:16.500 --> 35:17.500
对不对

35:17.500 --> 35:18.500
我们这些函数

35:18.500 --> 35:19.500
全在数组的员形里边

35:19.500 --> 35:21.500
这就来提示我们啥呢

35:21.500 --> 35:23.500
我们将来写构造函数

35:23.500 --> 35:24.500
应该把这些函数

35:24.500 --> 35:25.500
就是共有的东西

35:25.500 --> 35:27.500
他们要共享的

35:27.500 --> 35:29.500
所有对象共享的东西

35:29.500 --> 35:30.500
应该写到哪

35:30.500 --> 35:32.500
是不是应该写到员形里边

35:32.500 --> 35:33.500
没问题吧

35:33.500 --> 35:35.500
没问题吧

35:35.500 --> 35:36.500
好好理一下

35:36.500 --> 35:38.500
我们后边就不再会去

35:38.500 --> 35:39.500
用这种方式写了

35:39.500 --> 35:40.500
特别是函数

35:40.500 --> 35:42.500
函数一般都是共享的

35:42.500 --> 35:44.500
不太会用这种方式写了

35:44.500 --> 35:46.500
直接在圆形里边写

35:46.500 --> 35:47.500
因为圆形有了过后

35:47.500 --> 35:48.500
它的对象

35:48.500 --> 35:49.500
影视员形就指向它

35:49.500 --> 35:50.500
对吧

35:50.500 --> 35:51.500
影视员形就一定指向它

35:51.500 --> 35:53.500
那么它就可以直接使用这个成员了

35:53.500 --> 35:56.500
而且并且这里还可以用Race

35:56.500 --> 35:58.500
可以用Race的

35:58.500 --> 35:59.500
可以用Race的

35:59.500 --> 36:00.500
为什么可以用Race呢

36:00.500 --> 36:01.500
因为你调用的时候

36:01.500 --> 36:02.500
是咋调用的

36:02.500 --> 36:03.500
是不是这样调用的

36:03.500 --> 36:04.500
我们说Race的指向

36:04.500 --> 36:05.500
取决于怎么调用

36:05.500 --> 36:07.500
你这样调用的肯定没问题

36:07.500 --> 36:09.500
Race就指向调用者

36:09.500 --> 36:10.500
哪个对象在调用函数

36:10.500 --> 36:12.500
那就是函数的Race就指向谁

36:12.500 --> 36:13.500
那是不是没问题

36:13.500 --> 36:14.500
对吧

36:14.500 --> 36:15.500
没问题吧

36:15.500 --> 36:16.500
所以说

36:16.500 --> 36:17.500
我们可以以后

36:17.500 --> 36:18.500
就可以把它的函数写到

36:18.500 --> 36:20.500
什么圆形里边

36:20.500 --> 36:22.500
同学们

36:22.500 --> 36:23.500
这个时候

36:23.500 --> 36:25.500
如果你的神经够敏锐的话

36:25.500 --> 36:28.500
你会发现你头皮发麻

36:28.500 --> 36:29.500
这个时候你会发现

36:29.500 --> 36:30.500
一个新世界的大门

36:30.500 --> 36:32.500
已经向你打开了

36:32.500 --> 36:34.500
什么大门呢

36:34.500 --> 36:35.500
看着啊

36:35.500 --> 36:37.500
数组

36:37.500 --> 36:40.500
不是有圆形吗

36:40.500 --> 36:42.500
圆形里面可不可以加东西

36:42.500 --> 36:44.500
可以加东西

36:44.500 --> 36:45.500
于是这样一加

36:45.500 --> 36:47.500
所有的数组都有了

36:47.500 --> 36:48.500
这个属性abc了

36:48.500 --> 36:49.500
看到没

36:49.500 --> 36:50.500
全部数组

36:50.500 --> 36:54.500
任何数组都有了这个abc了

36:54.500 --> 36:55.500
于是你可以玩

36:55.500 --> 36:56.500
什么东西出来了

36:56.500 --> 36:57.500
你看着

36:57.500 --> 36:58.500
我可以这么玩

36:58.500 --> 36:59.500
我觉得数组里面

36:59.500 --> 37:00.500
方法不够

37:00.500 --> 37:01.500
方法不够

37:01.500 --> 37:02.500
我觉得数组里面

37:02.500 --> 37:03.500
还应该多加一些方法

37:03.500 --> 37:04.500
好来吧

37:04.500 --> 37:06.500
二位proto type

37:06.500 --> 37:07.500
要加一个方法

37:07.500 --> 37:10.500
camel

37:10.500 --> 37:11.500
我都游望了这个名字

37:11.500 --> 37:12.500
叫啥了

37:12.500 --> 37:14.500
骆驼

37:14.500 --> 37:16.500
骆驼

37:16.500 --> 37:21.070
骆驼

37:21.070 --> 37:22.070
翻译

37:22.070 --> 37:24.450
翻译

37:24.450 --> 37:27.450
骆驼

37:27.450 --> 37:28.450
驼风明法

37:28.450 --> 37:30.450
知道我要玩什么的吧

37:30.450 --> 37:32.450
camel

37:32.450 --> 37:33.450
camel

37:33.450 --> 37:34.450
这个写都要的

37:34.450 --> 37:35.450
camel

37:35.450 --> 37:37.450
把它变成一个骆风明法

37:37.450 --> 37:38.450
就是把这个数组里面的

37:38.450 --> 37:40.450
所有字母创手字母大写

37:40.450 --> 37:42.450
不是数组

37:42.450 --> 37:43.450
应该说字母创吧

37:43.450 --> 37:45.450
把字母创中所有的

37:45.450 --> 37:46.450
手字母大写

37:46.450 --> 37:47.450
你看字母创是不是对象

37:47.450 --> 37:48.450
对象有圆形

37:48.450 --> 37:51.450
圆形里面加上这么一个东西

37:51.450 --> 37:54.450
然后给它等于一个函数

37:54.450 --> 37:57.450
把当前字母创的对象z

37:57.450 --> 37:58.450
z是啥

37:58.450 --> 37:59.450
是不是当前对象

37:59.450 --> 38:00.450
对吧

38:00.450 --> 38:01.450
看一下吧

38:01.450 --> 38:02.450
输出z

38:02.450 --> 38:04.450
我们回到这

38:04.450 --> 38:06.450
那么现在所有的字母创

38:06.450 --> 38:08.450
全部有了这个camel

38:08.450 --> 38:09.450
camel

38:09.450 --> 38:11.450
全部有了这个函数了

38:11.450 --> 38:13.450
并且输出当前字母

38:13.450 --> 38:14.450
干嘛呢

38:14.450 --> 38:15.450
我要把这个字母创里面

38:15.450 --> 38:17.450
所有的手字母大写

38:17.450 --> 38:18.450
单词手字母大写

38:18.450 --> 38:19.450
怎么玩

38:19.450 --> 38:22.450
怎么玩这个东西

38:22.450 --> 38:23.450
怎么玩呢

38:23.450 --> 38:25.450
我们这里就直接返回

38:25.450 --> 38:26.450
z是啥

38:26.450 --> 38:27.450
replace

38:27.450 --> 38:28.450
对吧

38:28.450 --> 38:29.450
我们之前学过正载表达式

38:29.450 --> 38:31.450
用正载表达式

38:32.450 --> 38:34.450
对了replace

38:34.450 --> 38:35.450
正载表达式替换当前

38:35.450 --> 38:36.450
什么替换

38:36.450 --> 38:37.450
单词边界

38:37.450 --> 38:38.450
单词边界

38:38.450 --> 38:39.450
然后这里是一个单词

38:39.450 --> 38:40.450
对不对

38:40.450 --> 38:41.450
一个单词

38:41.450 --> 38:42.450
这里单词

38:42.450 --> 38:44.450
匹配什么呢

38:44.450 --> 38:47.450
匹配任意的就是单词文字

38:47.450 --> 38:48.450
任意的单词文字

38:48.450 --> 38:49.450
一个或多个

38:49.450 --> 38:50.450
对吧

38:50.450 --> 38:51.450
匹配出来

38:51.450 --> 38:52.450
匹配出来过后

38:52.450 --> 38:53.450
我们把它的手字母大写

38:53.450 --> 38:54.450
手字母大写

38:54.450 --> 38:55.450
写个函数

38:55.450 --> 38:57.450
这个函数返回一个什么呢

38:57.450 --> 38:58.450
函数

38:58.450 --> 39:00.450
这里是用

39:01.450 --> 39:02.450
得到这个

39:02.450 --> 39:03.450
得到这个

39:03.450 --> 39:04.450
多的1

39:04.450 --> 39:05.450
我们来输出一个多的1

39:05.450 --> 39:06.450
看一下吧

39:06.450 --> 39:08.950
看一下

39:08.950 --> 39:09.950
输出一个多的1

39:09.950 --> 39:10.950
我们之前学过正载表达式的

39:10.950 --> 39:11.950
对不对

39:11.950 --> 39:12.950
一个

39:12.950 --> 39:13.950
致不順

39:13.950 --> 39:14.950
空格

39:15.950 --> 39:16.950
致不順

39:16.950 --> 39:17.950
空格

39:17.950 --> 39:18.950
致不順

39:18.950 --> 39:19.950
camel

39:19.950 --> 39:20.950
看一下

39:20.950 --> 39:21.950
是不是得到3个

39:21.950 --> 39:22.950
多了1

39:22.950 --> 39:23.950
多了2

39:23.950 --> 39:24.950
多了3

39:24.950 --> 39:25.950
多了1

39:25.950 --> 39:26.950
对吧

39:26.950 --> 39:27.950
它每一次运行函数

39:27.950 --> 39:28.950
它会把这个匹配的结果返回给你

39:28.950 --> 39:29.950
这是它匹配的结果

39:29.950 --> 39:31.950
但这个函数的名字随便你写

39:31.950 --> 39:32.950
随便你写

39:32.950 --> 39:33.950
我们这里就用多了

39:33.950 --> 39:35.950
多了表示那个是

39:35.950 --> 39:36.950
它的

39:36.950 --> 39:37.950
它的参数

39:37.950 --> 39:38.950
它的参数

39:38.950 --> 39:39.950
只要匹配的结果

39:39.950 --> 39:40.950
随便用个变量名字

39:40.950 --> 39:41.950
好

39:41.950 --> 39:42.950
然后干嘛呢

39:42.950 --> 39:43.950
把这个东西手字母大写

39:43.950 --> 39:44.950
对吧

39:44.950 --> 39:45.950
手字母大写

39:45.950 --> 39:46.950
没问题吧

39:46.950 --> 39:47.950
把它手字母大写

39:47.950 --> 39:48.950
好

39:48.950 --> 39:49.950
其实呢你也可以这样子来做

39:49.950 --> 39:51.950
你把你一开始匹配

39:51.950 --> 39:52.950
第一个单词字母

39:52.950 --> 39:54.950
匹配第一个单词字母

39:54.950 --> 39:55.950
第一个单词字母的

39:55.950 --> 39:56.950
后边再写上一个

39:56.950 --> 39:58.950
写杠W信号

39:58.950 --> 39:59.950
对吧

39:59.950 --> 40:00.950
也可以这样子写

40:00.950 --> 40:01.950
然后把这个地方扩起来

40:01.950 --> 40:02.950
扩起来表示什么呢

40:02.950 --> 40:03.950
表示一个分组

40:03.950 --> 40:04.950
正的表达是分组

40:04.950 --> 40:05.950
好

40:05.950 --> 40:06.950
那么这里呢我们可以得到

40:06.950 --> 40:07.950
多了一

40:07.950 --> 40:08.950
是不是得到

40:08.950 --> 40:09.950
主看一下

40:09.950 --> 40:10.950
多了一

40:10.950 --> 40:11.950
你看看一下吧

40:11.950 --> 40:13.950
这里我们再加个小货

40:13.950 --> 40:14.950
好吧

40:14.950 --> 40:15.950
这里再加一个

40:15.950 --> 40:16.950
这里呢就两个分组了

40:16.950 --> 40:17.950
对吧

40:17.950 --> 40:18.950
多了一

40:18.950 --> 40:19.950
多了二

40:19.950 --> 40:20.950
我们不仅可以得到

40:20.950 --> 40:21.950
它的匹配结果

40:21.950 --> 40:22.950
还可以得到它的分组

40:22.950 --> 40:23.950
对不对

40:23.950 --> 40:24.950
之前我们正的表达是说过的

40:24.950 --> 40:25.950
再看一下吧

40:25.950 --> 40:26.950
再看一下

40:26.950 --> 40:27.950
你看是不是得到分组了

40:27.950 --> 40:29.950
第一个匹配是ASDF

40:29.950 --> 40:30.950
它第一个分组是A

40:30.950 --> 40:31.950
看来是手字母

40:31.950 --> 40:33.950
手字母是不是得到了

40:33.950 --> 40:35.950
然后声语的字母是不是得到了

40:35.950 --> 40:36.950
对吧

40:36.950 --> 40:37.950
声语的字母是不是也得到了

40:37.950 --> 40:38.950
没问题吧

40:38.950 --> 40:40.950
好

40:40.950 --> 40:41.950
我们当时是不是这样做的

40:41.950 --> 40:42.950
当时好像不是这样做的

40:42.950 --> 40:43.950
无所谓

40:43.950 --> 40:44.950
无所谓

40:44.950 --> 40:45.950
然后我们返回啥呢

40:45.950 --> 40:46.950
返回什么

40:46.950 --> 40:47.950
多了1点

40:47.950 --> 40:48.950
2

40:48.950 --> 40:49.950
R per case

40:49.950 --> 40:50.950
对吧

40:50.950 --> 40:52.950
拼接上什么

40:52.950 --> 40:53.950
多了2

40:53.950 --> 40:54.950
对不对

40:54.950 --> 40:55.950
返回这个东西

40:55.950 --> 40:56.950
没问题吧

40:56.950 --> 40:58.950
我们把这个东西替换掉原式的东西

40:58.950 --> 40:59.950
原式的东西

40:59.950 --> 41:00.950
保存

41:00.950 --> 41:01.950
看着

41:01.950 --> 41:05.290
看一下

41:05.290 --> 41:06.290
没问题吧

41:06.290 --> 41:07.290
是不是没问题了

41:07.290 --> 41:08.290
对吧

41:08.290 --> 41:10.290
然后再把什么空格

41:10.290 --> 41:12.290
再把空格就是替换掉

41:12.290 --> 41:13.290
空格替换掉

41:13.290 --> 41:15.290
我们之前是不是这样做的

41:15.290 --> 41:16.290
好像有点

41:16.290 --> 41:18.290
印象中好像不是这样做的

41:18.290 --> 41:19.290
看一下吧

41:19.290 --> 41:20.290
看一下

41:20.290 --> 41:22.290
我们当时是不是这样做的

41:22.290 --> 41:24.290
制服串

41:24.290 --> 41:25.290
投封命迷法

41:25.290 --> 41:26.290
看一下

41:29.240 --> 41:31.240
多了1

41:31.240 --> 41:32.240
不是

41:32.240 --> 41:34.240
这里不是

41:36.240 --> 41:37.240
看一下

41:37.240 --> 41:38.240
随便吧

41:38.240 --> 41:39.240
无所谓

41:39.240 --> 41:40.240
把做出来就完事了

41:40.240 --> 41:42.240
我主要说的这个是

41:42.240 --> 41:44.240
要说的这么一个东西

41:44.240 --> 41:45.240
说的也不是真的表达是

41:45.240 --> 41:46.240
无所谓吧

41:46.240 --> 41:47.240
返回了之后呢

41:47.240 --> 41:48.240
返回了之后

41:48.240 --> 41:50.240
还是不是还要去掉空格

41:50.240 --> 41:51.240
还要去掉空格

41:51.240 --> 41:52.240
也就是说

41:52.240 --> 41:54.240
单词边界是不是得去掉

41:54.240 --> 41:56.240
单词边界得去掉

41:56.240 --> 41:59.240
我们这里再继续replace

41:59.240 --> 42:01.240
前面返回的是个制服串

42:01.240 --> 42:02.240
总之你想办法

42:02.240 --> 42:03.240
把它变成投封命迷法

42:03.240 --> 42:04.240
我们以前是做过的

42:04.240 --> 42:07.240
然后再替换掉空白制服

42:07.240 --> 42:09.240
空白制服

42:09.240 --> 42:10.240
替换掉空白制服

42:10.240 --> 42:12.240
空白制服替换成空制服串

42:12.240 --> 42:14.240
空白制服

42:14.240 --> 42:16.240
这里我们用什么来得到空白制服

42:16.240 --> 42:17.240
空白制服之前是

42:17.240 --> 42:18.240
真的表达是

42:18.240 --> 42:20.240
我也忘了差不多了

42:20.240 --> 42:21.240
这些东西

42:21.240 --> 42:22.240
我也背不住

42:22.240 --> 42:23.240
真背不住

42:23.240 --> 42:25.240
真的背不住

42:25.240 --> 42:26.240
转衣服

42:26.240 --> 42:28.240
好像是s

42:28.240 --> 42:30.240
鞋杠s再替换空白制服

42:30.240 --> 42:32.240
保存看一下

42:33.240 --> 42:34.240
没问题吧

42:34.240 --> 42:36.240
转变成投封命迷法了

42:36.240 --> 42:37.240
看没

42:37.240 --> 42:38.240
于是呢

42:38.240 --> 42:39.240
我主要说这个

42:39.240 --> 42:40.240
我们可以给

42:40.240 --> 42:41.240
制服串的元雄里面

42:41.240 --> 42:42.240
给它加这个东西

42:42.240 --> 42:44.240
于是所有的制服串

42:44.240 --> 42:45.240
全部都有了

42:45.240 --> 42:46.240
那么以后你遇到什么

42:46.240 --> 42:47.240
输足啊

42:47.240 --> 42:48.240
那段钱把他们的玩意儿

42:48.240 --> 42:49.240
是不是都可以这样做

42:49.240 --> 42:50.240
你给它增强一些功能

42:50.240 --> 42:52.240
那么这种现象呢

42:52.240 --> 42:54.240
叫做猴子补钉

42:54.240 --> 42:55.240
猴子

42:55.240 --> 42:57.240
它为什么叫做猴子补钉呢

42:57.240 --> 42:59.240
这个解释呢有很多种

42:59.240 --> 43:01.240
反正我觉得最符合

43:01.240 --> 43:03.240
可能比较符合国际的解释呢

43:03.240 --> 43:05.240
猴子衫云模仿对吧

43:05.240 --> 43:06.240
就是模仿

43:06.240 --> 43:08.240
就像官方给你提供了

43:08.240 --> 43:09.240
一个对象

43:09.240 --> 43:10.240
Array

43:10.240 --> 43:11.240
对吧

43:11.240 --> 43:12.240
或者是制服串

43:12.240 --> 43:13.240
这个构造函数

43:13.240 --> 43:15.240
你模仿官方的东西

43:15.240 --> 43:16.240
给它做一个东西出来

43:16.240 --> 43:18.240
就是猴子补钉

43:18.240 --> 43:20.240
就是在元形中

43:20.240 --> 43:22.240
在函数元形中

43:22.240 --> 43:24.240
加入属性

43:24.240 --> 43:25.240
加入成员

43:25.240 --> 43:26.240
或者是属性

43:26.240 --> 43:27.240
或者是方法

43:27.240 --> 43:28.240
加入成员

43:28.240 --> 43:30.240
以增强

43:30.240 --> 43:31.240
增强

43:31.240 --> 43:35.240
其对象的功能

43:35.240 --> 43:37.240
增强对象的功能

43:37.240 --> 43:38.240
那么这个函数以后

43:38.240 --> 43:39.240
创建的对象都具有这个成员了

43:39.240 --> 43:41.240
都具有这个函数

43:41.240 --> 43:42.240
或者是属性的

43:42.240 --> 43:43.240
就是猴子补钉

43:43.240 --> 43:44.240
猴子补钉呢

43:44.240 --> 43:46.240
它会把猴子补钉

43:46.240 --> 43:48.240
会导致

43:49.240 --> 43:51.240
会导致元形污染

43:51.240 --> 43:52.240
什么叫元形污染

43:52.240 --> 43:53.240
就是元形里边

43:53.240 --> 43:54.240
原来没有这个东西

43:54.240 --> 43:55.240
但是你给它加了这个东西

43:55.240 --> 43:57.240
它会导致元形的污染

43:57.240 --> 43:59.240
所以说使用时

43:59.240 --> 44:01.240
使用需要去谨慎

44:01.240 --> 44:03.240
去谨慎

44:04.240 --> 44:06.240
谨慎使用

44:06.240 --> 44:08.240
甚至有些公司里边

44:08.240 --> 44:10.240
它不允许你去这样做

44:10.240 --> 44:12.240
为什么要防治这样的污染呢

44:12.240 --> 44:14.240
因为其他的开发者

44:14.240 --> 44:16.240
后续的开发者

44:16.240 --> 44:17.240
它并不知道你污染的元形

44:17.240 --> 44:19.240
它有可能往元形里面

44:19.240 --> 44:20.240
又去加东西

44:20.240 --> 44:21.240
一个人加一点

44:21.240 --> 44:22.240
一个人加一点

44:22.240 --> 44:23.240
后面这个元形不得了

44:23.240 --> 44:24.240
一个对象里边

44:24.240 --> 44:26.240
它产生了太多的成员

44:26.240 --> 44:27.240
明白这个意思吧

44:27.240 --> 44:28.240
所以说尽量

44:28.240 --> 44:30.240
猴子补钉的谨慎使用

44:30.240 --> 44:31.240
但是它存在的

44:31.240 --> 44:32.240
有的时候

44:32.240 --> 44:33.240
确实可以

44:33.240 --> 44:35.240
可以变得很有效

44:35.240 --> 44:37.240
就是我们可以增强它的功能

44:37.240 --> 44:38.240
让它的所有对象

44:38.240 --> 44:40.240
它都具备这个功能

44:40.240 --> 44:42.240
好吧 这是关于这一块

44:42.240 --> 44:43.240
好 这是

44:43.240 --> 44:45.240
元形和云式元形

44:45.240 --> 44:47.240
好 最后一块的知识

44:47.240 --> 44:49.240
就是元形链

44:49.240 --> 44:50.240
元形这一块

44:50.240 --> 44:51.240
一节课肯定讲不完

44:51.240 --> 44:52.240
如果一节课可以讲完的话

44:52.240 --> 44:53.240
我早就讲了

44:53.240 --> 44:54.240
一节课肯定讲不完

44:54.240 --> 44:55.240
分几节课

44:55.240 --> 44:57.240
好 元形链

44:57.240 --> 44:59.240
我们先认识最基础的东西

44:59.240 --> 45:02.240
什么是元形链呢

45:02.240 --> 45:03.240
因为每一个对象

45:03.240 --> 45:05.240
它都有云式元形

45:05.240 --> 45:06.240
对吧

45:06.240 --> 45:08.240
云式元形的指向

45:08.240 --> 45:10.240
它就形成了一个链条

45:10.240 --> 45:12.240
比方说

45:12.240 --> 45:14.240
咱们之前看到的是什么呢

45:14.240 --> 45:15.240
看到的是

45:15.240 --> 45:16.240
比方TES这个函数

45:16.240 --> 45:18.240
没有这个函数了

45:19.240 --> 45:20.240
哪个

45:20.240 --> 45:21.240
就随便哪一个吧

45:21.240 --> 45:22.240
就随便哪个函数

45:22.240 --> 45:24.240
函数A嘛

45:24.240 --> 45:25.240
方个形

45:25.240 --> 45:26.240
A

45:26.240 --> 45:27.240
这个函数A

45:27.240 --> 45:28.240
我们自己写的函数

45:28.240 --> 45:29.240
对吧

45:29.240 --> 45:32.680
我们通过

45:32.680 --> 45:33.680
OB界

45:33.680 --> 45:34.680
6一个A

45:34.680 --> 45:35.680
是不是个对象

45:35.680 --> 45:36.680
OB界一个对象

45:36.680 --> 45:37.680
对吧

45:37.680 --> 45:38.680
通过函数A创建的

45:38.680 --> 45:39.680
那么OB界的

45:39.680 --> 45:40.680
什么 影式元形

45:40.680 --> 45:41.680
是不是指向A的元形

45:41.680 --> 45:42.680
对吧

45:42.680 --> 45:43.680
指向A的元形

45:43.680 --> 45:44.680
没问题吧

45:44.680 --> 45:45.680
那么这个影式元形

45:45.680 --> 45:46.680
是不是个对象

45:46.680 --> 45:47.680
它是不是个对象

45:47.680 --> 45:48.680
影式元形

45:48.680 --> 45:49.680
它凭什么不是对象呢

45:49.680 --> 45:50.680
它还是个对象

45:50.680 --> 45:51.680
那么这个对象

45:51.680 --> 45:52.680
都有元形

45:52.680 --> 45:53.680
它有没有元形

45:53.680 --> 45:54.680
它有没有影式元形

45:54.680 --> 45:55.680
是不是还是有

45:55.680 --> 45:56.680
对不对

45:56.680 --> 45:57.680
还是有

45:57.680 --> 45:58.680
那这个影式元形

45:58.680 --> 45:59.680
是不是还是对象

45:59.680 --> 46:00.680
它是不是还有影式元形

46:00.680 --> 46:01.680
对吧

46:01.680 --> 46:02.680
还是有 看到没

46:02.680 --> 46:03.680
还是有

46:03.680 --> 46:04.680
只不过它最后一个

46:04.680 --> 46:05.680
指向烙了

46:05.680 --> 46:06.680
那就这就去形成了

46:06.680 --> 46:07.680
一个链条

46:07.680 --> 46:08.680
看到没

46:08.680 --> 46:09.680
它就形成了一个链条

46:09.680 --> 46:10.680
那么这个链条

46:10.680 --> 46:11.680
是什么样子呢

46:11.680 --> 46:12.680
我给大家看一个图

46:12.680 --> 46:14.680
你只有看图才能理解

46:14.680 --> 46:15.680
好 我们看一下

46:15.680 --> 46:17.680
这就是�条

46:17.680 --> 46:18.680
链条

46:18.680 --> 46:21.680
我们I再来梳理一下

46:21.680 --> 46:22.680
先看

46:22.680 --> 46:23.680
先看这个

46:23.680 --> 46:25.680
白色的

46:25.680 --> 46:27.680
白色的是啥

46:27.680 --> 46:28.680
白色的是

46:28.680 --> 46:29.680
白色的表示

46:29.680 --> 46:30.680
函数的元形

46:30.680 --> 46:31.680
每一个函数都有元形

46:31.680 --> 46:32.680
对吧

46:32.680 --> 46:33.680
每一个函数都有元形

46:33.680 --> 46:35.680
Object有没有元形

46:35.680 --> 46:36.680
有元形

46:36.680 --> 46:37.680
它有元形

46:37.680 --> 46:38.680
元形是啥

46:38.680 --> 46:39.680
就是一个对象

46:39.680 --> 46:40.680
就是一个Object对象

46:40.680 --> 46:41.680
就是个元形

46:41.680 --> 46:42.680
对吧

46:42.680 --> 46:43.680
好

46:43.680 --> 46:44.680
然后我们自己的函数

46:44.680 --> 46:45.680
有没有元形

46:45.680 --> 46:46.680
有元形

46:46.680 --> 46:47.680
任何一个函数都有元形

46:47.680 --> 46:48.680
它有一个对象

46:48.680 --> 46:49.680
对吧

46:49.680 --> 46:50.680
它有一个对象

46:50.680 --> 46:51.680
那个地方

46:51.680 --> 46:52.680
先看白色

46:52.680 --> 46:53.680
先看白色

46:53.680 --> 46:54.680
好 这里有个特殊点

46:54.680 --> 46:55.680
什么特殊点呢

46:55.680 --> 46:56.680
就是方形

46:56.680 --> 46:57.680
这个方形

46:57.680 --> 46:58.680
我们之前说过

46:58.680 --> 46:59.680
是直接下到内存里面的

46:59.680 --> 47:00.680
直接扔

47:00.680 --> 47:01.680
扔到内存里面了

47:01.680 --> 47:03.680
因为所有的东西

47:03.680 --> 47:05.680
都是通过它来产生的

47:05.680 --> 47:06.680
所有的函数

47:06.680 --> 47:08.680
都是通过方形来产生的

47:08.680 --> 47:09.680
而所有的对象

47:09.680 --> 47:10.680
都是通过函数来产生的

47:10.680 --> 47:12.680
所以说一定要先有它

47:12.680 --> 47:14.680
它是直接扔对象里面的

47:14.680 --> 47:15.680
它的元形

47:15.680 --> 47:16.680
它的元形

47:16.680 --> 47:17.680
它也有一个元形

47:17.680 --> 47:18.680
方形

47:18.680 --> 47:19.680
这里还不是特殊

47:19.680 --> 47:20.680
这里还不是特殊点

47:20.680 --> 47:21.680
以后才说到

47:21.680 --> 47:22.680
方形的元形

47:22.680 --> 47:23.680
它也有一个元形

47:23.680 --> 47:24.680
好

47:24.680 --> 47:25.680
我们先看白色

47:25.680 --> 47:26.680
白色能看懂吗

47:26.680 --> 47:28.680
白色没问题吧

47:28.680 --> 47:29.680
好

47:29.680 --> 47:30.680
然后我们再看绿色

47:30.680 --> 47:31.680
绿色是什么

47:31.680 --> 47:32.680
六

47:32.680 --> 47:33.680
六一个方形

47:33.680 --> 47:35.680
是不是可以产生一个函数

47:35.680 --> 47:36.680
对吧

47:36.680 --> 47:37.680
六一个方形

47:37.680 --> 47:38.680
是可以产生一个函数吗

47:38.680 --> 47:39.680
比方说

47:39.680 --> 47:40.680
我们这里写的函数

47:40.680 --> 47:41.680
A

47:41.680 --> 47:42.680
函数A

47:42.680 --> 47:43.680
是不是通过六方形来产生的

47:43.680 --> 47:44.680
一定是

47:44.680 --> 47:45.680
六一个方形来产生

47:45.680 --> 47:46.680
一个函数

47:46.680 --> 47:47.680
那么 object 是不是一定通过

47:47.680 --> 47:48.680
方形来产生的

47:48.680 --> 47:49.680
对吧

47:49.680 --> 47:51.680
也是通过六方形来产生的函数

47:51.680 --> 47:52.680
对吧

47:52.680 --> 47:53.680
所有的函数

47:53.680 --> 47:55.680
都是通过六方形来产生的

47:55.680 --> 47:56.680
好

47:56.680 --> 47:58.680
然后所有的普通对象

47:58.680 --> 48:00.680
所有的普通对象

48:00.680 --> 48:02.680
都是通过

48:02.680 --> 48:03.680
所有的普通对象

48:03.680 --> 48:04.680
像这些普通对象

48:04.680 --> 48:06.680
都是通过什么

48:06.680 --> 48:07.680
六一个

48:07.680 --> 48:08.680
比方说这个函数

48:08.680 --> 48:09.680
至定义对象的函数

48:09.680 --> 48:10.680
它通过

48:10.680 --> 48:12.680
比方说我们刚才的A

48:12.680 --> 48:14.680
这里的OB界

48:14.680 --> 48:16.680
刚才这个OB界

48:16.680 --> 48:17.680
它通过六一个

48:17.680 --> 48:18.680
自己的函数产生的

48:18.680 --> 48:19.680
对吧

48:19.680 --> 48:20.680
所以说这一块

48:20.680 --> 48:21.680
这一块

48:21.680 --> 48:23.680
我们可以产生至定义的对象

48:23.680 --> 48:24.680
可以通过六一个

48:24.680 --> 48:25.680
自己定义的函数

48:25.680 --> 48:29.680
来产生一个至定义对象

48:29.680 --> 48:30.680
好

48:30.680 --> 48:31.680
这是绿色的线

48:31.680 --> 48:32.680
绿色的线

48:32.680 --> 48:33.680
没问题吧

48:33.680 --> 48:34.680
好

48:34.680 --> 48:35.680
接下来咱们来看

48:35.680 --> 48:36.680
蓝色的线

48:36.680 --> 48:37.680
蓝色的线表示隐释元雄

48:37.680 --> 48:38.680
我们之前说过

48:38.680 --> 48:40.680
隐释元雄指向谁

48:40.680 --> 48:41.680
它指向谁

48:41.680 --> 48:43.680
它是不是指向的是

48:43.680 --> 48:44.680
谁创建它

48:44.680 --> 48:46.680
它就指向谁的元雄

48:46.680 --> 48:47.680
好

48:47.680 --> 48:48.680
你看一下

48:48.680 --> 48:49.680
我们自己的函数

48:49.680 --> 48:50.680
至定义的函数

48:50.680 --> 48:51.680
是不是通过六一个

48:51.680 --> 48:52.680
方可形来创建的

48:52.680 --> 48:54.680
因此我们自己写的函数

48:54.680 --> 48:57.680
它的隐释元雄指向谁

48:57.680 --> 48:59.680
指向的是方可形的元雄

48:59.680 --> 49:00.680
看到没

49:00.680 --> 49:02.680
指向的是方可形的元雄

49:02.680 --> 49:03.680
先看这一步

49:03.680 --> 49:04.680
我们自己写的函数

49:04.680 --> 49:06.680
我们这里写的一个M

49:06.680 --> 49:07.680
对吧

49:07.680 --> 49:08.680
A相当于是啥

49:08.680 --> 49:10.680
A相当于是六一个方可形

49:10.680 --> 49:11.680
对吧

49:11.680 --> 49:12.680
六一个方可形

49:12.680 --> 49:13.680
它是通过这样的来产生的

49:13.680 --> 49:15.680
那么这个A它是不是对象

49:15.680 --> 49:17.680
那么对象是不是一定有隐释元雄

49:17.680 --> 49:19.680
那它的隐释元雄指向谁

49:19.680 --> 49:21.680
肯定指向的是方可形的元雄

49:21.680 --> 49:22.680
对吧

49:22.680 --> 49:23.680
它肯定是指向这个

49:23.680 --> 49:24.680
对不对

49:24.680 --> 49:25.680
所以说呢

49:25.680 --> 49:27.680
它就出现了这么一个

49:27.680 --> 49:29.680
很有意思的现象

49:29.680 --> 49:30.680
你看object也是一样

49:30.680 --> 49:31.680
它是个对象

49:31.680 --> 49:32.680
对吧

49:32.680 --> 49:33.680
它是一个函数

49:33.680 --> 49:35.680
那么它是通过六方可形来创建的

49:35.680 --> 49:36.680
因此它的隐释元雄

49:36.680 --> 49:39.680
也指向方可形的元雄

49:39.680 --> 49:40.680
没问题吧

49:40.680 --> 49:41.680
好

49:41.680 --> 49:43.680
那么基于这个特点

49:43.680 --> 49:44.680
那么现在呢

49:44.680 --> 49:46.680
大家就会发现这么一个现象

49:46.680 --> 49:48.680
所有的函数

49:48.680 --> 49:50.680
它都有些公有的成员

49:50.680 --> 49:54.680
所有的函数都有公有的成员

49:54.680 --> 49:56.680
A这个函数

49:56.680 --> 49:57.680
它有啥

49:57.680 --> 49:58.680
有call

49:58.680 --> 49:59.680
讲过了对吧

49:59.680 --> 50:00.680
有什么

50:00.680 --> 50:01.680
有apply

50:01.680 --> 50:03.680
讲过了对吧

50:03.680 --> 50:04.680
有啥

50:04.680 --> 50:05.680
有那个

50:05.680 --> 50:06.680
呃

50:06.680 --> 50:07.680
有啥

50:07.680 --> 50:09.680
有那个

50:09.680 --> 50:10.680
nance

50:10.680 --> 50:11.680
不是nance

50:11.680 --> 50:12.680
叫什么

50:12.680 --> 50:14.680
叫做band

50:14.680 --> 50:15.680
对吧

50:15.680 --> 50:17.680
这些成员哪来的

50:17.680 --> 50:18.680
哪来的

50:18.680 --> 50:19.680
我给它复制过吗

50:19.680 --> 50:20.680
没有复制过

50:20.680 --> 50:22.680
我没有给它复制过

50:22.680 --> 50:23.680
这些成员哪来的

50:23.680 --> 50:24.680
哪来的

50:24.680 --> 50:25.680
我们来看一下哪来的

50:25.680 --> 50:26.680
console

50:26.680 --> 50:27.680
dira

50:27.680 --> 50:29.680
把当成对象来输出

50:29.680 --> 50:30.680
看一下

50:30.680 --> 50:31.680
这个A是一个函数

50:31.680 --> 50:32.680
你看一下

50:32.680 --> 50:33.680
它里边有这个属性吗

50:33.680 --> 50:35.680
有什么apply call

50:35.680 --> 50:36.680
没有

50:36.680 --> 50:37.680
它里边只有什么nance

50:37.680 --> 50:38.680
对吧

50:38.680 --> 50:39.680
它对象里边只有这些属性

50:39.680 --> 50:40.680
它只有这些属性

50:40.680 --> 50:41.680
然后呢

50:41.680 --> 50:43.680
我们在这里看一下

50:43.680 --> 50:45.680
它的隐私员向里边数有

50:45.680 --> 50:47.680
隐私员向哪来的

50:47.680 --> 50:48.680
隐私员向哪来的

50:48.680 --> 50:50.680
隐私员向是不是函数的

50:50.680 --> 50:52.680
这个方式的员向提供的

50:52.680 --> 50:53.680
对吧

50:53.680 --> 50:55.680
我们这里打印出来

50:55.680 --> 50:56.680
console

50:56.680 --> 50:57.680
diR

50:57.680 --> 50:58.680
diR

50:58.680 --> 50:59.680
方式

50:59.680 --> 51:01.680
diR prototype

51:01.680 --> 51:02.680
你看一下

51:02.680 --> 51:03.680
是不是这里面提供的

51:03.680 --> 51:04.680
看到没

51:04.680 --> 51:06.680
这就是为什么所有的函数

51:06.680 --> 51:07.680
它都有这些东西

51:07.680 --> 51:08.680
就是因为

51:08.680 --> 51:09.680
我们之前讲所有的函数

51:09.680 --> 51:10.680
都有这个call

51:10.680 --> 51:11.680
都有这个什么apply

51:11.680 --> 51:12.680
都是改变这些指向对吧

51:12.680 --> 51:13.680
都有这些函方法

51:13.680 --> 51:14.680
它为什么有

51:14.680 --> 51:15.680
是因为

51:15.680 --> 51:17.680
它们的隐私员向里边有

51:17.680 --> 51:18.680
有说方式的员向里边有

51:18.680 --> 51:20.680
也就是我们说

51:20.680 --> 51:21.680
这个

51:21.680 --> 51:22.680
adr

51:22.680 --> 51:23.680
adr call

51:23.680 --> 51:24.680
是不是应该等于

51:24.680 --> 51:25.680
方式

51:25.680 --> 51:26.680
diR prototype

51:26.680 --> 51:27.680
diR call

51:27.680 --> 51:28.680
对不对

51:28.680 --> 51:29.680
是不是应该想懂的

51:29.680 --> 51:31.680
两个是一个东西

51:31.680 --> 51:32.680
应该都有意思吧

51:32.680 --> 51:33.680
所以说呢

51:33.680 --> 51:35.680
由于自定义函数的

51:35.680 --> 51:36.680
隐私员向在这

51:36.680 --> 51:37.680
在方式的员向里边

51:37.680 --> 51:38.680
而方式的员向里边

51:38.680 --> 51:40.680
给你提供了很多的东西

51:40.680 --> 51:41.680
那是不是这些

51:41.680 --> 51:42.680
函数都可以使用了

51:42.680 --> 51:43.680
这东西是不是

51:43.680 --> 51:44.680
函数都可以使用了

51:44.680 --> 51:45.680
对吧

51:45.680 --> 51:46.680
这就是一个继承的效果

51:46.680 --> 51:47.680
我们后边会专门

51:47.680 --> 51:48.680
拿一个课来讲继承

51:48.680 --> 51:49.680
这是个继承的效果

51:49.680 --> 51:50.680
就是它

51:50.680 --> 51:51.680
父亲有的东西

51:51.680 --> 51:52.680
我都有

51:52.680 --> 51:53.680
有相当于是我的东西

51:53.680 --> 51:54.680
我是通过它来创建的

51:54.680 --> 51:55.680
我是它生出来的

51:55.680 --> 51:56.680
所以说

51:56.680 --> 51:57.680
它有的东西

51:57.680 --> 51:58.680
我都有

51:58.680 --> 51:59.680
有的东西是吧

51:59.680 --> 52:00.680
那么你看一下

52:00.680 --> 52:01.680
objects

52:01.680 --> 52:02.680
objects是有

52:02.680 --> 52:03.680
也有call

52:03.680 --> 52:04.680
array

52:04.680 --> 52:05.680
是不是也有call

52:05.680 --> 52:06.680
对不对

52:06.680 --> 52:07.680
那么现在问你

52:07.680 --> 52:08.680
array的call跟objects的call

52:08.680 --> 52:09.680
是不是一样的

52:09.680 --> 52:10.680
是不是一样的

52:10.680 --> 52:11.680
怎么不一样的

52:11.680 --> 52:12.680
他们指向的是

52:12.680 --> 52:13.680
都是隐私员向里边的东西

52:13.680 --> 52:15.680
都指向的是同一块员形

52:15.680 --> 52:17.680
指向的是同一个员形

52:17.680 --> 52:19.680
这个自定义函数指向的是它

52:19.680 --> 52:20.680
objects指向的也是它

52:20.680 --> 52:21.680
对不对

52:21.680 --> 52:22.680
所以说这些函数里边的

52:22.680 --> 52:23.680
这些成员都是有的

52:23.680 --> 52:24.680
看没

52:24.680 --> 52:25.680
都是有的

52:25.680 --> 52:26.680
没问题吧

52:26.680 --> 52:27.680
好

52:27.680 --> 52:28.680
这是这个箭头

52:28.680 --> 52:29.680
这个箭头

52:29.680 --> 52:30.680
以及这个箭头

52:30.680 --> 52:32.680
好 继续我们再看

52:32.680 --> 52:33.680
再看

52:33.680 --> 52:34.680
那么这个方式

52:34.680 --> 52:35.680
它本身的

52:35.680 --> 52:36.680
函数也是

52:36.680 --> 52:37.680
函数也是对象吧

52:37.680 --> 52:38.680
对吧 它也是个对象

52:38.680 --> 52:40.680
那么它的隐私员向指向谁呢

52:40.680 --> 52:41.680
它比较特殊

52:41.680 --> 52:42.680
因为没有任何东西

52:42.680 --> 52:43.680
创建它

52:43.680 --> 52:44.680
没有任何东西创建它

52:44.680 --> 52:45.680
它是直接在内群里边的

52:45.680 --> 52:46.680
我们说隐私员向

52:46.680 --> 52:47.680
指向的是

52:47.680 --> 52:48.680
谁创建它

52:48.680 --> 52:49.680
它就指向谁

52:49.680 --> 52:50.680
那么它不是

52:50.680 --> 52:52.680
没有人创建它

52:52.680 --> 52:53.680
所以说

52:53.680 --> 52:54.680
它的隐私员向比较特殊

52:54.680 --> 52:56.680
它指向自己的员形

52:56.680 --> 52:57.680
所以说这一块

52:57.680 --> 52:58.680
我们要记一笔

52:58.680 --> 52:59.680
特殊点

52:59.680 --> 53:01.680
就是

53:01.680 --> 53:04.680
第一个是方式的

53:04.680 --> 53:07.680
隐私员向

53:07.680 --> 53:09.680
proto 隐私员向指向

53:09.680 --> 53:11.680
自身的员向

53:11.680 --> 53:12.680
它没办法了

53:12.680 --> 53:14.680
它不知道怎么指向了

53:14.680 --> 53:17.680
proto type 指向自己

53:17.680 --> 53:19.680
方式的隐私员向指向自己

53:19.680 --> 53:20.680
这是一块

53:20.680 --> 53:21.680
一个特殊点

53:21.680 --> 53:23.680
好 咱们继续看

53:23.680 --> 53:24.680
我们自定义函数

53:24.680 --> 53:25.680
可以创建对象

53:25.680 --> 53:26.680
对吧

53:26.680 --> 53:27.680
我们六一个A

53:27.680 --> 53:28.680
创建对象

53:28.680 --> 53:29.680
它的隐私员向

53:29.680 --> 53:30.680
是不是指向

53:30.680 --> 53:32.680
指向函数的员向

53:32.680 --> 53:33.680
这就是为什么

53:33.680 --> 53:35.680
我们之前可以用这种方式来玩

53:35.680 --> 53:37.680
为什么可以用这种方式来玩

53:37.680 --> 53:38.680
可以用这种方式

53:38.680 --> 53:40.680
我往构造函数里边

53:40.680 --> 53:41.680
加一个

53:41.680 --> 53:42.680
员向里边加东西

53:42.680 --> 53:43.680
往员向里边加东西

53:43.680 --> 53:45.680
是不是就相当于是

53:45.680 --> 53:47.680
往这里边加东西

53:47.680 --> 53:48.680
是不是相当于是

53:48.680 --> 53:49.680
往这里边加

53:49.680 --> 53:50.680
那么他们是

53:50.680 --> 53:51.680
共用这一块内存空间的

53:51.680 --> 53:52.680
所以说

53:52.680 --> 53:53.680
往这里边加东西

53:53.680 --> 53:54.680
是不是它也有了

53:54.680 --> 53:55.680
对不对

53:55.680 --> 53:57.680
因为它的隐私员向指向它

53:58.680 --> 53:59.680
对不对

53:59.680 --> 54:00.680
好那么这个东西

54:00.680 --> 54:01.680
它是函数的员向

54:01.680 --> 54:02.680
对吧

54:02.680 --> 54:03.680
函数的员向有指向谁呢

54:03.680 --> 54:04.680
函数的员向

54:04.680 --> 54:06.680
它本身也是对象

54:06.680 --> 54:07.680
你看这个

54:07.680 --> 54:08.680
A这个函数

54:08.680 --> 54:09.680
它有员向对吧

54:09.680 --> 54:10.680
员向本身可以看

54:10.680 --> 54:11.680
是不是对象

54:11.680 --> 54:12.680
它肯定是对象

54:12.680 --> 54:14.680
它是不是也得有隐私员向

54:14.680 --> 54:16.680
对象都得有隐私员向

54:16.680 --> 54:17.680
我们之前说过

54:17.680 --> 54:19.680
对这个员形

54:19.680 --> 54:21.680
默认情况下

54:21.680 --> 54:23.680
Prototype是一个普通的

54:23.680 --> 54:25.680
OB结构对象

54:25.680 --> 54:26.680
所以说你可以认为

54:26.680 --> 54:27.680
OB结构它是通过

54:27.680 --> 54:29.680
6一个OB结构创建的

54:29.680 --> 54:31.680
于是你看这个

54:31.680 --> 54:32.680
员形对象

54:32.680 --> 54:33.680
它的隐私员向

54:33.680 --> 54:35.680
都指向OB结构的员向

54:35.680 --> 54:36.680
看没

54:36.680 --> 54:37.680
都指向OB结构的员向

54:37.680 --> 54:39.680
都是通过OB结构产生的

54:39.680 --> 54:40.680
但这里有个特殊点

54:40.680 --> 54:42.680
就是OB结构的员向

54:42.680 --> 54:44.680
它指向NOW

54:44.680 --> 54:45.680
这个特殊点

54:45.680 --> 54:47.680
第二个特殊点

54:47.680 --> 54:49.680
OB结构的

54:50.680 --> 54:52.680
Prototype的

54:52.680 --> 54:54.680
隐私员向

54:54.680 --> 54:55.680
Prot

54:55.680 --> 54:57.680
指向NOW

54:57.680 --> 54:58.680
这是个特殊点

54:58.680 --> 55:00.680
其他都是正常的

55:01.680 --> 55:02.680
还记得吗

55:02.680 --> 55:03.680
咱们在

55:03.680 --> 55:05.680
讲标准库的时候

55:05.680 --> 55:07.680
说过这么一句话

55:07.680 --> 55:09.680
所有的对象

55:09.680 --> 55:11.680
都拥有一些东西

55:11.680 --> 55:13.680
都拥有一些东西对吧

55:14.680 --> 55:16.680
一个对象

55:17.680 --> 55:19.680
OB结

55:19.680 --> 55:20.680
6一个A

55:20.680 --> 55:22.680
OB结是个对象

55:22.680 --> 55:23.680
它有啥

55:23.680 --> 55:24.680
它有啥

55:25.680 --> 55:27.680
它有什么就是

55:28.680 --> 55:29.680
有这个成员吧

55:30.680 --> 55:31.680
它凭什么有

55:31.680 --> 55:32.680
凭什么有

55:33.680 --> 55:35.680
就是因为它指向这里

55:35.680 --> 55:36.680
OB结它的员向

55:36.680 --> 55:38.680
因为这里有一个逻辑

55:38.680 --> 55:40.680
这个逻辑

55:40.680 --> 55:41.680
什么逻辑呢

55:41.680 --> 55:42.680
就是

55:42.680 --> 55:43.680
刚才我们说的

55:43.680 --> 55:45.680
看自己是不是拥有这个成员

55:45.680 --> 55:46.680
如果没有的话

55:46.680 --> 55:47.680
去找它

55:47.680 --> 55:48.680
找它的隐私员向

55:48.680 --> 55:50.680
如果隐私员向也没有

55:50.680 --> 55:53.680
依次寻找

55:55.680 --> 55:57.680
隐私员向

55:57.680 --> 55:59.680
应该说这样说吧

55:59.680 --> 56:01.680
在圆形链中

56:01.680 --> 56:04.680
依次查找

56:04.680 --> 56:07.990
这里该这样说

56:07.990 --> 56:09.990
在圆形链中依次查找

56:09.990 --> 56:10.990
为什么叫圆形链

56:10.990 --> 56:11.990
你看是不是形成链式结构

56:11.990 --> 56:13.990
它有隐私员向指向它

56:13.990 --> 56:14.990
它有隐私员向指向它

56:14.990 --> 56:16.990
它有隐私员向指向它

56:16.990 --> 56:18.990
看是不是形成像链了

56:18.990 --> 56:19.990
包括这里也是一样

56:19.990 --> 56:21.990
函数的隐私员向指向它

56:21.990 --> 56:22.990
它的隐私员向的

56:22.990 --> 56:23.990
又指向它

56:23.990 --> 56:24.990
它又指向它

56:24.990 --> 56:25.990
它就形成像链了

56:25.990 --> 56:27.990
它自己没有这个成员

56:27.990 --> 56:29.990
于是从隐私员向那边去找

56:29.990 --> 56:30.990
有隐私员向那边去找

56:30.990 --> 56:31.990
隐私员向那边没找到

56:31.990 --> 56:32.990
继续往上找

56:32.990 --> 56:34.990
找它下一个隐私员向

56:34.990 --> 56:36.990
如果还找不到

56:36.990 --> 56:37.990
继续往上找

56:37.990 --> 56:38.990
如果没有了

56:38.990 --> 56:39.990
那么就是

56:39.990 --> 56:40.990
不存在

56:40.990 --> 56:41.990
就是不存在

56:41.990 --> 56:42.990
明白这个意思吧

56:42.990 --> 56:43.990
因此

56:43.990 --> 56:45.990
为什么我这里可以使用图示郡

56:45.990 --> 56:46.990
为什么可以用

56:48.990 --> 56:50.990
为什么这里可以用图示郡

56:50.990 --> 56:52.990
看一下它怎么找的

56:52.990 --> 56:54.990
OBG是我们自己的对象

56:54.990 --> 56:55.990
对吧

56:55.990 --> 56:56.990
它里面肯定没有

56:56.990 --> 56:57.990
于是它从哪里去找

56:57.990 --> 56:59.990
它的隐私员向里面去找

56:59.990 --> 57:00.990
隐私员向里面有吗

57:00.990 --> 57:01.990
是不是也没有

57:01.990 --> 57:02.990
对吧

57:02.990 --> 57:03.990
也没有往哪里找

57:03.990 --> 57:04.990
继续往上找

57:04.990 --> 57:05.990
是不是找到OBG的车了

57:05.990 --> 57:07.990
因此OBG车里面

57:07.990 --> 57:08.990
这些东西是不是

57:08.990 --> 57:09.990
所有对象全都有

57:10.990 --> 57:11.990
对不对

57:11.990 --> 57:13.990
是不是所有的对象全都有

57:14.990 --> 57:15.990
这就是为什么

57:15.990 --> 57:17.990
所有对象都有这个东西的原因

57:17.990 --> 57:19.990
因为它始终处于圆形链上

57:19.990 --> 57:21.990
它始终找来找去

57:21.990 --> 57:22.990
它最终会找到这个OBG车

57:22.990 --> 57:23.990
为什么

57:23.990 --> 57:24.990
因为圆形对象

57:24.990 --> 57:25.990
它本身就是OBG车

57:25.990 --> 57:26.990
创建的

57:26.990 --> 57:27.990
因为它会指向OBG车

57:28.990 --> 57:29.990
明白这个意思吧

57:29.990 --> 57:30.990
把这个图好好看懂

57:30.990 --> 57:31.990
看懂那个图

57:31.990 --> 57:32.990
什么面试题都不怕了

57:32.990 --> 57:33.990
无论它怎么绕理

57:33.990 --> 57:34.990
它的部分

57:34.990 --> 57:35.990
你都不用怕

57:36.990 --> 57:37.990
于是

57:37.990 --> 57:38.990
为什么我们这里面

57:38.990 --> 57:39.990
可以有这一顿

57:40.990 --> 57:41.990
OBG车里面的所有成员

57:41.990 --> 57:42.990
都可以用

57:42.990 --> 57:43.990
就是这个原因

57:44.990 --> 57:45.990
那么我们先讲的

57:45.990 --> 57:46.990
覆盖是什么意思

57:46.990 --> 57:47.990
什么叫覆盖

57:47.990 --> 57:48.990
就是因为我们

57:48.990 --> 57:50.990
如果你自己写了一个

57:50.990 --> 57:52.990
比方说我们在这里

57:53.990 --> 57:54.990
在这里

58:01.010 --> 58:02.010
在这里OBG

58:02.010 --> 58:03.010
6一个A

58:03.010 --> 58:06.010
然后我往OBG里面写了一个toolstream

58:06.010 --> 58:08.010
toolstream写个函数

58:09.010 --> 58:11.010
反而回到一个abc

58:11.010 --> 58:12.010
比方说

58:12.010 --> 58:13.010
那么你看一下

58:13.010 --> 58:14.010
现在的情况

58:14.010 --> 58:15.010
现在的情况是什么

58:15.010 --> 58:16.010
OBG的toolstream

58:16.010 --> 58:17.010
这叫覆盖

58:17.010 --> 58:18.010
对吧

58:18.010 --> 58:19.010
我当时说的这叫覆盖

58:19.010 --> 58:20.010
本质是什么意思呢

58:20.010 --> 58:21.010
你看一下

58:21.010 --> 58:22.010
你往对象里面

58:22.010 --> 58:23.010
加了一个东西

58:23.010 --> 58:24.010
对吧

58:24.010 --> 58:25.010
加了这个东西

58:25.010 --> 58:26.010
那么这个东西加到哪的

58:26.010 --> 58:27.010
加到这的

58:27.010 --> 58:28.010
看没有

58:28.010 --> 58:29.010
加到自定对象里面的

58:29.010 --> 58:31.010
那么这是不是找的时候

58:31.010 --> 58:32.010
是不是一下就找到了

58:32.010 --> 58:33.010
找到自己的东西了

58:33.010 --> 58:35.010
因此他就不会往上找了

58:35.010 --> 58:36.010
那么之前的toolstream

58:36.010 --> 58:37.010
在不在

58:37.010 --> 58:38.010
他在

58:38.010 --> 58:39.010
看没有

58:39.010 --> 58:40.010
在这

58:40.010 --> 58:41.010
他仍然在的

58:41.010 --> 58:42.010
他在这

58:42.010 --> 58:43.010
看没

58:43.010 --> 58:44.010
那么这里

58:44.010 --> 58:45.010
是不是已经找到

58:45.010 --> 58:46.010
他就不会继续往上找了

58:46.010 --> 58:48.010
明白这个意思吧

58:48.010 --> 58:50.010
搞清楚

58:50.010 --> 58:51.010
好

58:51.010 --> 58:52.010
那咱们再看

58:52.010 --> 58:53.010
再看

58:53.010 --> 58:54.010
那我能不能强行调用

58:54.010 --> 58:56.010
OBG车里面的toolstream

58:56.010 --> 58:57.010
能不能强行调用

58:57.010 --> 58:59.010
比方说咱们有个数组

58:59.010 --> 59:01.010
有个数组

59:01.010 --> 59:03.010
我们订个辨量

59:03.010 --> 59:05.010
放大一点

59:05.010 --> 59:06.010
AR

59:06.010 --> 59:07.010
一个数组随便写个

59:07.010 --> 59:09.010
我们知道数组里面的toolstream

59:09.010 --> 59:10.010
是被重写过的

59:10.010 --> 59:11.010
是被重写过的

59:11.010 --> 59:12.010
AR toolstream

59:12.010 --> 59:14.010
它是被重写过的

59:14.010 --> 59:15.010
你看没

59:15.010 --> 59:16.010
它是被重写过的

59:16.010 --> 59:17.010
那么怎么样

59:17.010 --> 59:18.010
我这里一定要想使用

59:18.010 --> 59:19.010
toolstream来调用它

59:19.010 --> 59:20.010
怎么办

59:20.010 --> 59:21.010
你看着

59:21.010 --> 59:22.010
就是OBG车的toolstream

59:22.010 --> 59:23.010
怎么来用

59:23.010 --> 59:24.010
我们可以这样再写

59:24.010 --> 59:26.010
OBG车

59:26.010 --> 59:27.010
原型

59:27.010 --> 59:28.010
找到哪了

59:28.010 --> 59:29.010
就找到这了

59:29.010 --> 59:30.010
对吧

59:30.010 --> 59:31.010
找到这了

59:31.010 --> 59:32.010
它里面不是一个toolstream吗

59:32.010 --> 59:33.010
对吧

59:33.010 --> 59:34.010
toolstream函数

59:34.010 --> 59:35.010
函数函数

59:35.010 --> 59:36.010
函数然后干嘛

59:36.010 --> 59:38.010
call

59:38.010 --> 59:39.010
call 是不是可以传ZS

59:39.010 --> 59:40.010
对吧

59:40.010 --> 59:41.010
可以传ZS

59:41.010 --> 59:42.010
不是

59:42.010 --> 59:43.010
可以传ZS

59:43.010 --> 59:45.010
AR 把AR当成ZS

59:45.010 --> 59:46.010
这样的样子

59:46.010 --> 59:47.010
就是可以强行调用

59:47.010 --> 59:48.010
OBG车的toolstream

59:48.010 --> 59:49.010
看没

59:49.010 --> 59:50.010
看没

59:50.010 --> 59:51.010
后边写的是

59:51.010 --> 59:52.010
勾罩函数的名称

59:52.010 --> 59:53.010
后边显示的是

59:53.010 --> 59:54.010
勾罩函数的名称

59:54.010 --> 59:56.010
没问题吧

59:56.010 --> 59:57.010
没问题吧

59:57.010 --> 59:58.010
这样子就可以使用

59:58.010 --> 01:00:00.010
toolstream的勾罩函数了

01:00:00.010 --> 01:00:02.010
看没

01:00:02.010 --> 01:00:03.010
好

01:00:03.010 --> 01:00:04.010
然后我们这里

01:00:04.010 --> 01:00:05.010
再来一个例子

01:00:05.010 --> 01:00:06.010
再来一个例子

01:00:06.010 --> 01:00:07.010
比方说我不是写到这了

01:00:07.010 --> 01:00:08.010
我写到哪了

01:00:08.010 --> 01:00:10.010
写到adder prototype里边

01:00:10.010 --> 01:00:11.010
是不是也可以覆盖

01:00:11.010 --> 01:00:12.010
对吧

01:00:12.010 --> 01:00:13.010
是不是也可以覆盖

01:00:13.010 --> 01:00:14.010
返回

01:00:14.010 --> 01:00:15.010
123

01:00:15.010 --> 01:00:16.010
看一下

01:00:16.010 --> 01:00:19.010
我写到adder的原型里边

01:00:19.010 --> 01:00:21.010
那么这个OBG的toolstream

01:00:21.010 --> 01:00:23.010
是不是还是可以覆盖

01:00:23.010 --> 01:00:24.010
那么你现在的情况

01:00:24.010 --> 01:00:25.010
跟刚才有什么不同呢

01:00:25.010 --> 01:00:27.010
刚才是把它加到这儿的

01:00:27.010 --> 01:00:28.010
现在把它加到这儿的

01:00:28.010 --> 01:00:30.010
被所有的对象共享

01:00:30.010 --> 01:00:31.010
它这个原型

01:00:31.010 --> 01:00:33.010
只要是通过这个函数

01:00:33.010 --> 01:00:34.010
创建的对象

01:00:34.010 --> 01:00:36.010
都会共享这个原型

01:00:36.010 --> 01:00:37.010
所以说通用了

01:00:37.010 --> 01:00:38.010
通用了

01:00:38.010 --> 01:00:39.010
那么它这里找到了

01:00:39.010 --> 01:00:41.010
它就不会继续往上找了

01:00:41.010 --> 01:00:43.010
是这么个意思

01:00:43.010 --> 01:00:44.010
你要这个意思吧

01:00:44.010 --> 01:00:45.010
好

01:00:46.010 --> 01:00:48.010
这些可能我们没有讲什么

01:00:48.010 --> 01:00:49.010
新的语法

01:00:49.010 --> 01:00:50.010
新的属性

01:00:50.010 --> 01:00:52.010
新的属性就两个

01:00:52.010 --> 01:00:53.010
一个是 prototype

01:00:53.010 --> 01:00:54.010
一个是 prototype

01:00:54.010 --> 01:00:55.010
两个一个是原型

01:00:55.010 --> 01:00:56.010
一个是影视原型

01:00:56.010 --> 01:00:57.010
主要是理解

01:00:57.010 --> 01:00:58.010
讲那么久

01:00:58.010 --> 01:00:59.010
主要是要让大家理解

01:00:59.010 --> 01:01:01.010
好 理解了之后

01:01:01.010 --> 01:01:03.010
咱们来做一些面试题

01:01:03.010 --> 01:01:04.010
有三道题

01:01:04.010 --> 01:01:05.010
都是面试题

01:01:05.010 --> 01:01:06.010
好 看一下

01:01:06.010 --> 01:01:08.010
看一下地体说出什么

01:01:08.010 --> 01:01:10.380
很简单

01:01:10.380 --> 01:01:11.380
非常非常简单

01:01:11.380 --> 01:01:12.380
说出啥呢

01:01:14.380 --> 01:01:15.380
你看着

01:01:15.380 --> 01:01:17.380
它往Object车原型里面

01:01:17.380 --> 01:01:18.380
加了一个a

01:01:18.380 --> 01:01:19.380
加了一个a

01:01:19.380 --> 01:01:20.380
是不是所有对象

01:01:20.380 --> 01:01:21.380
全部都有了

01:01:21.380 --> 01:01:23.380
你看原型链

01:01:23.380 --> 01:01:24.380
所有对象最终原型链

01:01:24.380 --> 01:01:25.380
是不是都要指向Object车

01:01:25.380 --> 01:01:26.380
对吧

01:01:26.380 --> 01:01:27.380
所以全都有了

01:01:27.380 --> 01:01:28.380
所有对象都有了

01:01:28.380 --> 01:01:29.380
一往方形里面

01:01:29.380 --> 01:01:30.380
加了一个b

01:01:30.380 --> 01:01:31.380
是不是所有的函数

01:01:31.380 --> 01:01:32.380
全部都有了

01:01:32.380 --> 01:01:33.380
所有的函数

01:01:33.380 --> 01:01:34.380
全部都有这个b了

01:01:34.380 --> 01:01:35.380
看没

01:01:35.380 --> 01:01:36.380
然后大写的f

01:01:36.380 --> 01:01:37.380
是一个函数

01:01:37.380 --> 01:01:38.380
小写的f

01:01:38.380 --> 01:01:40.380
是通过函数创建的对象

01:01:40.380 --> 01:01:41.380
小写f里面

01:01:41.380 --> 01:01:42.380
有没有a

01:01:42.380 --> 01:01:43.380
有没有a

01:01:43.380 --> 01:01:44.380
所以一定有a

01:01:44.380 --> 01:01:45.380
所有的对象都有a

01:01:45.380 --> 01:01:46.380
所以它一定有a

01:01:46.380 --> 01:01:48.380
小写的f里面有没有b

01:01:48.380 --> 01:01:50.380
那么这里输出

01:01:50.380 --> 01:01:51.380
我们看一下输出啥

01:01:51.380 --> 01:01:52.380
第一个输出a

01:01:52.380 --> 01:01:53.380
是不是一个函数

01:01:53.380 --> 01:01:54.380
第一个输出函数

01:01:54.380 --> 01:01:55.380
第二个

01:01:55.380 --> 01:01:57.380
f里面有没有b呢

01:01:57.380 --> 01:01:59.380
b只有函数才有b

01:01:59.380 --> 01:02:00.380
只有函数

01:02:00.380 --> 01:02:02.380
它加到函数的元凶里面了

01:02:02.380 --> 01:02:03.380
它加到这个元凶里面了

01:02:03.380 --> 01:02:04.380
对吧

01:02:04.380 --> 01:02:05.380
加到这个元凶里面了

01:02:05.380 --> 01:02:06.380
那么只有函数才有

01:02:06.380 --> 01:02:07.380
对不对

01:02:07.380 --> 01:02:08.380
函数才有

01:02:08.380 --> 01:02:09.380
所以说只有函数才有b

01:02:09.380 --> 01:02:10.380
那么小写的f

01:02:10.380 --> 01:02:11.380
它不是函数

01:02:12.380 --> 01:02:13.380
找不到这个b

01:02:13.380 --> 01:02:14.380
好

01:02:14.380 --> 01:02:15.380
大写的f有没有a

01:02:15.380 --> 01:02:16.380
肯定有

01:02:16.380 --> 01:02:17.380
它这两个还是一样的

01:02:17.380 --> 01:02:18.380
不仅有还是一样的

01:02:18.380 --> 01:02:20.380
它们共享一个空间

01:02:20.380 --> 01:02:21.380
加到这的

01:02:21.380 --> 01:02:22.380
因为a是加到这的

01:02:22.380 --> 01:02:23.380
好

01:02:23.380 --> 01:02:25.380
然后大写的f里面

01:02:25.380 --> 01:02:26.380
函数的f里面

01:02:26.380 --> 01:02:27.380
有没有b呢

01:02:27.380 --> 01:02:28.380
有

01:02:28.380 --> 01:02:29.380
它是函数

01:02:29.380 --> 01:02:30.380
它指向函数的元凶

01:02:30.380 --> 01:02:31.380
因此这里是有的

01:02:31.380 --> 01:02:33.380
于是输出这么一个结果

01:02:33.380 --> 01:02:34.380
好

01:02:34.380 --> 01:02:35.380
这是地道题

01:02:35.380 --> 01:02:36.380
地道题

01:02:36.380 --> 01:02:37.380
要不要看一下

01:02:37.380 --> 01:02:39.380
看一下你自己去建个页面

01:02:39.380 --> 01:02:40.380
运行出来

01:02:40.380 --> 01:02:41.380
我这里的话就难得

01:02:41.380 --> 01:02:42.380
难得去建页面了

01:02:42.380 --> 01:02:43.380
我就在漏的这些是运行

01:02:43.380 --> 01:02:44.380
是一样的

01:02:44.380 --> 01:02:45.380
是一样的

01:02:45.380 --> 01:02:46.380
漏的

01:02:46.380 --> 01:02:47.380
我们这里不用漏的运行了

01:02:47.380 --> 01:02:48.380
这些f

01:02:49.380 --> 01:02:50.380
f运行

01:02:54.380 --> 01:02:55.380
我这个配置的

01:02:55.380 --> 01:02:57.380
运行的不是漏的环节

01:02:57.380 --> 01:02:58.380
不是漏的环节

01:02:58.380 --> 01:02:59.380
那算了吧

01:03:00.380 --> 01:03:01.380
行吗

01:03:02.380 --> 01:03:03.380
复制

01:03:03.380 --> 01:03:04.380
暂停过来

01:03:05.380 --> 01:03:06.380
对吧

01:03:06.380 --> 01:03:08.380
fn

01:03:08.380 --> 01:03:10.380
fn

01:03:10.380 --> 01:03:11.380
对吧

01:03:12.380 --> 01:03:13.380
好 地道题

01:03:13.380 --> 01:03:14.380
地道题

01:03:14.380 --> 01:03:15.380
看一下

01:03:15.380 --> 01:03:18.660
这些都没什么难的

01:03:18.660 --> 01:03:19.660
没什么难的

01:03:19.660 --> 01:03:20.660
难的是第三题

01:03:21.660 --> 01:03:22.660
第三题还是恐怖

01:03:23.660 --> 01:03:24.660
第三题

01:03:24.660 --> 01:03:25.660
我觉得当时是

01:03:25.660 --> 01:03:26.660
先看地道题

01:03:26.660 --> 01:03:27.660
先看地道题

01:03:28.660 --> 01:03:34.550
来吧

01:03:34.550 --> 01:03:35.550
来

01:03:36.550 --> 01:03:37.550
好 第二题

01:03:39.550 --> 01:03:40.550
a 点什么

01:03:40.550 --> 01:03:41.550
prototype

01:03:41.550 --> 01:03:43.550
往a的元凶里边加一个a

01:03:43.550 --> 01:03:46.550
往b的元凶里边加一个a

01:03:46.550 --> 01:03:47.550
e

01:03:47.550 --> 01:03:49.550
往c的元凶里边加一个a

01:03:49.550 --> 01:03:50.550
e

01:03:50.550 --> 01:03:51.550
对吧

01:03:51.550 --> 01:03:52.550
那么这三个元凶里边

01:03:52.550 --> 01:03:53.550
是不是都加了一个a

01:03:53.550 --> 01:03:54.550
对吧 都加了个a数项

01:03:54.550 --> 01:03:55.550
对不对

01:03:55.550 --> 01:03:56.550
好 然后输出什么

01:03:56.550 --> 01:03:57.550
6a

01:03:57.550 --> 01:03:59.550
用a来创建一个

01:03:59.550 --> 01:04:00.550
对象

01:04:00.550 --> 01:04:01.550
对象里边有没有a

01:04:01.550 --> 01:04:02.550
有没有a

01:04:02.550 --> 01:04:03.550
它用的是哪

01:04:03.550 --> 01:04:05.550
用的是韩数a的元凶里边的a

01:04:05.550 --> 01:04:06.550
得到的是e

01:04:06.550 --> 01:04:07.550
对不对

01:04:07.550 --> 01:04:08.550
得到的是e

01:04:08.550 --> 01:04:09.550
好 6b

01:04:09.550 --> 01:04:10.550
6b

01:04:10.550 --> 01:04:11.550
6b的时候

01:04:12.550 --> 01:04:13.550
它要传一个参数

01:04:13.550 --> 01:04:14.550
但是它传没传参数

01:04:14.550 --> 01:04:15.550
它没有传参数

01:04:15.550 --> 01:04:16.550
于是参数是啥

01:04:16.550 --> 01:04:17.550
参数是ondi犯

01:04:17.550 --> 01:04:19.550
于是它把ondi犯复制给了谁

01:04:19.550 --> 01:04:21.550
复制给了它自己的一个属性

01:04:21.550 --> 01:04:22.550
于是它现在

01:04:22.550 --> 01:04:23.550
这个对象本身

01:04:23.550 --> 01:04:25.550
它是不是有个属性a了

01:04:25.550 --> 01:04:26.550
那自己有这个属性a了

01:04:26.550 --> 01:04:27.550
它是不是不会找元凶了

01:04:27.550 --> 01:04:28.550
就相当于是

01:04:28.550 --> 01:04:29.550
这里有这个属性a了

01:04:29.550 --> 01:04:31.550
它就不会从元凶里面去找了

01:04:31.550 --> 01:04:32.550
这么个意思

01:04:32.550 --> 01:04:34.550
所以b这里的a

01:04:34.550 --> 01:04:35.550
输出啥

01:04:35.550 --> 01:04:36.550
输出ondi犯

01:04:36.550 --> 01:04:37.550
于是这里是什么

01:04:37.550 --> 01:04:38.550
ondi犯

01:04:38.550 --> 01:04:39.550
第一个是e

01:04:40.550 --> 01:04:41.550
第三体

01:04:41.550 --> 01:04:43.550
第三体传了一个2进去

01:04:43.550 --> 01:04:44.550
2进去

01:04:44.550 --> 01:04:45.550
2肯定为真对吧

01:04:45.550 --> 01:04:46.550
那么就把2复制给了a

01:04:46.550 --> 01:04:48.550
那么是不是自己又有属性的

01:04:48.550 --> 01:04:49.550
又有这个a属性的

01:04:49.550 --> 01:04:50.550
那么到时候它就不会

01:04:50.550 --> 01:04:51.550
从元凶里面去找了

01:04:51.550 --> 01:04:52.550
那么得到2

01:04:53.550 --> 01:04:55.550
来吧看一下吧

01:04:55.550 --> 01:04:59.440
1ondi犯2

01:04:59.440 --> 01:05:01.440
下面这个是整个表拉式的反馈结果

01:05:01.440 --> 01:05:03.440
它把它当成一个整个表拉式的

01:05:03.440 --> 01:05:04.440
1ondi犯的

01:05:04.440 --> 01:05:05.440
2

01:05:05.440 --> 01:05:06.440
没问题吧

01:05:06.440 --> 01:05:07.440
好 第三体

01:05:07.440 --> 01:05:09.880
第三体

01:05:10.880 --> 01:05:11.880
第三体

01:05:12.880 --> 01:05:13.880
第三体

01:05:14.880 --> 01:05:16.880
它确实是一道面试体

01:05:16.880 --> 01:05:18.880
但是你们以后估计看不见

01:05:18.880 --> 01:05:19.880
看不到

01:05:19.880 --> 01:05:20.880
为什么看不到呢

01:05:20.880 --> 01:05:21.880
因为这是我之前的公司里面

01:05:21.880 --> 01:05:22.880
给别人出的面试体

01:05:23.880 --> 01:05:24.880
有点面态

01:05:25.880 --> 01:05:26.880
我说你把这个东西

01:05:26.880 --> 01:05:28.880
你如果这个体能做出来了的话

01:05:28.880 --> 01:05:30.880
原性这一块一定没什么问题了

01:05:30.880 --> 01:05:31.880
一定没什么问题了

01:05:31.880 --> 01:05:32.880
我都不用去考虑乱七八糟

01:05:32.880 --> 01:05:33.880
花里浮上的东西

01:05:33.880 --> 01:05:35.880
直接考虑这个

01:05:36.880 --> 01:05:37.880
一个对象

01:05:37.880 --> 01:05:38.880
只有一个函数

01:05:39.880 --> 01:05:41.880
它原性里面有一个方法

01:05:42.880 --> 01:05:43.880
创建两个对象

01:05:43.880 --> 01:05:44.880
来吧

01:05:44.880 --> 01:05:46.880
U1的 say hello等于U2的 say hello

01:05:46.880 --> 01:05:47.880
肯定为粗

01:05:49.880 --> 01:05:51.880
这个是原形上的东西

01:05:51.880 --> 01:05:52.880
它的影视原形

01:05:52.880 --> 01:05:54.880
找从影视原形里面找到的

01:05:54.880 --> 01:05:55.880
所以一定为粗

01:05:57.880 --> 01:05:58.880
好

01:05:58.880 --> 01:05:59.880
然后再来

01:05:59.880 --> 01:06:00.880
如果我这里换一下

01:06:01.880 --> 01:06:02.880
这里写错了

01:06:02.880 --> 01:06:03.880
应该是吧

01:06:04.880 --> 01:06:06.880
这里我如果换一下U1

01:06:07.880 --> 01:06:09.880
U1的 say hello

01:06:10.880 --> 01:06:11.880
我给它重新复制

01:06:11.880 --> 01:06:12.880
那现在还一样吗

01:06:12.880 --> 01:06:13.880
是不是不一样了

01:06:13.880 --> 01:06:14.880
因为U1找 say hello的时候

01:06:14.880 --> 01:06:16.880
是不是找到自己对象的 say hello

01:06:16.880 --> 01:06:18.880
U2它没有 say hello

01:06:18.880 --> 01:06:19.880
U2的话

01:06:19.880 --> 01:06:20.880
它就会从原形上去找

01:06:20.880 --> 01:06:21.880
现在就不一样了

01:06:22.880 --> 01:06:23.880
搞清楚

01:06:23.880 --> 01:06:24.880
好

01:06:24.880 --> 01:06:25.880
第二个

01:06:25.880 --> 01:06:29.880
User prototype constructor

01:06:29.880 --> 01:06:30.880
是不是就是User

01:06:30.880 --> 01:06:31.880
对吧

01:06:31.880 --> 01:06:32.880
就是User

01:06:32.880 --> 01:06:33.880
User

01:06:33.880 --> 01:06:34.880
方可信

01:06:35.880 --> 01:06:36.880
就是User的方可信

01:06:36.880 --> 01:06:37.880
对吧

01:06:37.880 --> 01:06:38.880
原形的

01:06:38.880 --> 01:06:39.880
构造函数

01:06:39.880 --> 01:06:40.880
对不对

01:06:40.880 --> 01:06:41.880
它就是User的方可信

01:06:42.880 --> 01:06:43.880
第九题

01:06:43.880 --> 01:06:44.880
User prototype

01:06:44.880 --> 01:06:46.880
是不是等于方形的 prototype

01:06:49.700 --> 01:06:50.700
相等吗

01:06:50.700 --> 01:06:51.700
相等吗

01:06:51.700 --> 01:06:52.700
肯定不相等

01:06:52.700 --> 01:06:53.700
方形的 prototype 是在这

01:06:53.700 --> 01:06:54.700
对吧

01:06:54.700 --> 01:06:55.700
我们自定义含书的 prototype

01:06:55.700 --> 01:06:56.700
是自己的

01:06:56.700 --> 01:06:57.700
两个肯定不相等

01:06:58.700 --> 01:06:59.700
看一下

01:06:59.700 --> 01:07:00.700
这个是 force

01:07:01.700 --> 01:07:02.700
下一个

01:07:03.700 --> 01:07:05.700
User的

01:07:05.700 --> 01:07:06.700
隐私原型

01:07:06.700 --> 01:07:08.700
就是含书的隐私原型

01:07:08.700 --> 01:07:09.700
是不是等于

01:07:09.700 --> 01:07:10.700
方形的原型

01:07:10.700 --> 01:07:11.700
它肯定是

01:07:11.700 --> 01:07:13.700
因为含书都是通过它创建的

01:07:13.700 --> 01:07:14.700
它的隐私原型

01:07:14.700 --> 01:07:15.700
一定是个等于它的原型

01:07:15.700 --> 01:07:16.700
下一个

01:07:17.700 --> 01:07:18.700
User prototype

01:07:18.700 --> 01:07:19.700
隐私原型

01:07:19.700 --> 01:07:20.700
是不是等于方形的隐私原型

01:07:21.700 --> 01:07:22.700
考虑的是特殊点

01:07:22.700 --> 01:07:23.700
看表特殊点

01:07:23.700 --> 01:07:24.700
方形的隐私原型

01:07:24.700 --> 01:07:25.700
它只能指向自己的

01:07:25.700 --> 01:07:26.700
因为没有任何东西

01:07:26.700 --> 01:07:27.700
可以创建它

01:07:27.700 --> 01:07:28.700
它只能指向自己的原型

01:07:28.700 --> 01:07:29.700
因此也是相等的

01:07:29.700 --> 01:07:30.700
这个东西跟这个东西

01:07:30.700 --> 01:07:31.700
是一样的

01:07:31.700 --> 01:07:32.700
就这两个代码

01:07:32.700 --> 01:07:33.700
这两个表达

01:07:33.700 --> 01:07:34.700
一定是一样的

01:07:34.700 --> 01:07:35.700
看一下吧

01:07:36.700 --> 01:07:37.700
方形的

01:07:37.700 --> 01:07:38.700
proto type

01:07:38.700 --> 01:07:39.700
一定是等于

01:07:39.700 --> 01:07:41.700
方形的proto的

01:07:41.700 --> 01:07:42.700
怎么样

01:07:42.700 --> 01:07:43.700
一定是一样的

01:07:43.700 --> 01:07:44.700
说到这个东西

01:07:44.700 --> 01:07:45.700
维修还是一样

01:07:45.700 --> 01:07:46.700
下一个

01:07:46.700 --> 01:07:47.700
User的隐私原型

01:07:47.700 --> 01:07:48.700
跟User的隐私原型

01:07:48.700 --> 01:07:49.700
那肯定没什么说的

01:07:49.700 --> 01:07:50.700
肯定是一样的

01:07:50.700 --> 01:07:51.700
它们都是同一个构造

01:07:51.700 --> 01:07:52.700
还是创建的

01:07:52.700 --> 01:07:53.700
下一题

01:07:53.700 --> 01:07:54.700
User的隐私原型

01:07:54.700 --> 01:07:55.700
跟User的隐私原型

01:07:55.700 --> 01:07:56.700
那肯定不一样

01:07:56.700 --> 01:07:57.700
User的隐私原型

01:07:57.700 --> 01:07:58.700
是啥

01:07:58.700 --> 01:07:59.700
是这个玩意

01:07:59.700 --> 01:08:01.700
我们对象的隐私原型

01:08:01.700 --> 01:08:02.700
是这个东西

01:08:02.700 --> 01:08:03.700
所以肯定不一样

01:08:04.700 --> 01:08:05.700
下一个

01:08:07.700 --> 01:08:08.700
方形的隐私原型

01:08:08.700 --> 01:08:10.700
跟Object的隐私原型

01:08:10.700 --> 01:08:13.210
看头

01:08:13.210 --> 01:08:15.210
方形的隐私原型在这

01:08:15.210 --> 01:08:16.210
Object的隐私原型

01:08:16.210 --> 01:08:17.210
是不是也在这

01:08:17.210 --> 01:08:18.210
为什么

01:08:18.210 --> 01:08:19.210
因为Object是方形

01:08:19.210 --> 01:08:20.210
创建的

01:08:20.210 --> 01:08:21.210
它只能指向这

01:08:21.210 --> 01:08:22.210
所以说一样的

01:08:23.210 --> 01:08:24.210
下一个

01:08:26.210 --> 01:08:27.210
方形的

01:08:27.210 --> 01:08:29.210
圆形的隐私原型

01:08:30.210 --> 01:08:32.210
和Object的圆形的隐私原型

01:08:33.210 --> 01:08:34.210
是不是一样的

01:08:34.210 --> 01:08:35.210
看一下吧

01:08:36.210 --> 01:08:39.210
方形的圆形的隐私原型

01:08:39.210 --> 01:08:40.210
这

01:08:40.210 --> 01:08:42.210
Object是圆形的隐私原型

01:08:42.210 --> 01:08:43.210
这

01:08:44.210 --> 01:08:45.210
不一样

01:08:45.210 --> 01:08:46.210
一个是NOW

01:08:46.210 --> 01:08:47.210
一个是Object的圆形

01:08:47.210 --> 01:08:48.210
好

01:08:48.210 --> 01:08:49.210
那这个就是一样的

01:08:49.210 --> 01:08:50.210
这个就是一样的

01:08:51.210 --> 01:08:52.210
看吧

01:08:53.210 --> 01:08:55.520
当天过来

01:08:55.520 --> 01:08:56.520
没问题吧

01:08:58.520 --> 01:08:59.520
User

01:08:59.520 --> 01:09:00.520
方形

01:09:00.520 --> 01:09:01.520
Force

01:09:02.520 --> 01:09:03.520
它叫一个

01:09:03.520 --> 01:09:04.520
Force

01:09:04.520 --> 01:09:05.520
Force2

01:09:05.520 --> 01:09:06.520
Force2

01:09:07.520 --> 01:09:10.150
理清楚

01:09:10.150 --> 01:09:11.150
理清楚

01:09:12.150 --> 01:09:13.150
这就是

01:09:13.150 --> 01:09:14.150
这些面试题

01:09:14.150 --> 01:09:15.150
做这一块

01:09:15.150 --> 01:09:16.150
非常容易出面试题

01:09:16.150 --> 01:09:17.150
就是圆形这一块

01:09:17.150 --> 01:09:18.150
它不一定用这种方式来考虑

01:09:18.150 --> 01:09:20.150
它可能就是变成花样来考

01:09:20.150 --> 01:09:21.150
就像这种

01:09:24.150 --> 01:09:25.150
这是关于

01:09:26.150 --> 01:09:27.150
圆形这一块

01:09:27.150 --> 01:09:29.150
刚才我还想说个啥呢

01:09:29.150 --> 01:09:30.150
还想说个啥呢

01:09:30.150 --> 01:09:31.150
暂时没有了吧

01:09:31.150 --> 01:09:32.150
暂时没了

01:09:33.150 --> 01:09:34.150
就这么多了

01:09:34.150 --> 01:09:35.150
好

01:09:35.150 --> 01:09:37.150
我们先把这个基础点认识清楚

01:09:37.150 --> 01:09:39.150
周杰克的作业的话

01:09:40.150 --> 01:09:41.150
没啥作业

01:09:41.150 --> 01:09:42.150
主要是理解

01:09:43.150 --> 01:09:44.150
那么下杰克开始

01:09:44.150 --> 01:09:45.150
我们来讲一讲圆形

01:09:45.150 --> 01:09:47.150
它的有一些哪些应用场景

