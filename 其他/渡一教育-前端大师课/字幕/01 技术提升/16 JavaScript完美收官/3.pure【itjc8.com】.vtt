WEBVTT

00:00.000 --> 00:03.000
欢迎继续收看我们独一课堂所提供这样的

00:03.000 --> 00:05.600
你不知道GS占据系列的一个视频

00:05.600 --> 00:10.000
我是咱们的主讲人 也是独一教育的一个CTO

00:10.000 --> 00:11.000
叫陈思东

00:11.000 --> 00:15.000
那这个 依旧是我 对吧

00:15.000 --> 00:18.000
那好了 我们今天呢 开始回给我们的正题啊

00:18.000 --> 00:21.000
因为之前很多节课呢 我都已经做了

00:21.000 --> 00:24.000
平凡这样的一个自我介绍 我都不想再介绍我自己了

00:24.000 --> 00:27.000
对吧 我们直接切入这样一个正题

00:27.000 --> 00:30.000
那今天呢 我们还是带来 函数是变成的

00:30.000 --> 00:33.000
一个另外一个精华 也是这样的一个基石

00:33.000 --> 00:35.000
就是存函数

00:35.000 --> 00:39.000
那首先 我们都知道函数这个概念是什么意思

00:39.000 --> 00:45.000
无非就是fx等于什么s 乘以什么什么上

00:45.000 --> 00:47.000
后来说s加什么什么

00:47.000 --> 00:50.000
反正就是这个函数fx最后的一个结果

00:50.000 --> 00:53.000
是由这个字幕量s来决定的

00:53.000 --> 00:55.000
那我们来看一下

00:55.000 --> 01:00.000
这里面有个函数 叫做y等于fx

01:00.000 --> 01:03.000
那当然fx 具体等于什么 咱们不用管

01:03.000 --> 01:05.000
那我们能看到出来一点

01:05.000 --> 01:07.000
这个y 最后它等于什么

01:07.000 --> 01:12.000
实际上是由这个字幕量x 它来去决定的

01:12.000 --> 01:14.000
ok 那其实呢

01:14.000 --> 01:16.000
我这一个简单的等式

01:16.000 --> 01:19.000
它就是一个最基本的一个存函数的一个概念

01:19.000 --> 01:21.000
那咱来看一下

01:22.000 --> 01:23.000
这样一个图

01:23.000 --> 01:25.000
比如说存函数的话

01:25.000 --> 01:28.000
需要你去往函数的这个规则之中

01:28.000 --> 01:30.000
去输入这样的一个字幕量

01:30.000 --> 01:33.000
或者说是输入这样的一个实际参数

01:33.000 --> 01:35.000
之后呢 这存函数呢

01:35.000 --> 01:40.000
会返回这个经过这个规则所处理后的这样的一个值

01:40.000 --> 01:42.000
那而且呢

01:42.000 --> 01:46.000
当这个存函数在进行这样的一个执行的时候

01:46.000 --> 01:50.000
它不会影响到外界的选举辩量的一些值

01:50.000 --> 01:53.000
同时呢 它所制定的这套规则

01:53.000 --> 01:57.000
也不会依靠外界的一些选举辩量来完成

01:57.000 --> 01:58.000
但那这么说

01:58.000 --> 02:00.000
很抽象 会很复杂

02:00.000 --> 02:02.000
我能给大家总结出了两句话

02:02.000 --> 02:05.000
一个是来看一下存函数这样的一个定义

02:05.000 --> 02:07.000
就是对于相同的实物

02:07.000 --> 02:09.000
永远就是存函数

02:09.000 --> 02:11.000
就是对于相同的实物来讲的话

02:11.000 --> 02:13.000
它永远都会得到相同的一个输出

02:13.000 --> 02:14.000
而且呢

02:14.000 --> 02:16.000
没有任何可观察的一个负责用

02:16.000 --> 02:18.000
也不依赖外部环境的状态

02:19.000 --> 02:22.000
咱们再换句能听懂的人话

02:22.000 --> 02:23.000
再说一遍

02:23.000 --> 02:25.000
存函数是

02:25.000 --> 02:31.000
它不依赖和不修改其宗育之外的辩量

02:31.000 --> 02:32.000
如果说

02:32.000 --> 02:35.000
一个函数具备了这两个特点的话

02:35.000 --> 02:39.000
不依赖和不修改外界的宗育的一些辩量的话

02:39.000 --> 02:42.000
我们就可以称为这个函数是个存函数

02:43.000 --> 02:46.000
我们在这边可以给你举个例子

02:46.000 --> 02:47.000
我在这呢

02:47.000 --> 02:48.000
把它

02:48.000 --> 02:50.000
看到这个

02:51.000 --> 02:53.000
打开一次

02:53.000 --> 02:59.090
OK

02:59.090 --> 03:00.090
那这个数据呢

03:00.090 --> 03:02.090
我们一会再来管它

03:03.090 --> 03:05.090
我们先来看一下

03:06.090 --> 03:08.090
假如

03:08.090 --> 03:10.090
我写了个辩量

03:10.090 --> 03:11.090
这个辩量呢

03:11.090 --> 03:12.090
叫做一个

03:12.090 --> 03:13.090
NUM

03:13.090 --> 03:15.090
比如说它等于一个18

03:15.090 --> 03:16.090
好

03:16.090 --> 03:18.090
那我再写个方式

03:18.090 --> 03:20.090
它叫做Compare

03:21.090 --> 03:22.090
好

03:22.090 --> 03:23.090
一个比较的函数

03:23.090 --> 03:25.090
那这个函数呢

03:25.090 --> 03:27.090
如果说它可以接受一个参数

03:27.090 --> 03:28.090
比如说叫做X

03:28.090 --> 03:29.090
好了

03:29.090 --> 03:30.090
那它这样的规则呢

03:30.090 --> 03:31.090
是比较

03:31.090 --> 03:34.090
你传进来的这样的一个参数

03:34.090 --> 03:37.090
和这个18之间的一个值

03:37.090 --> 03:39.090
然后反回数这样的一个结果

03:39.090 --> 03:41.090
那我们再使用这个函数的时候

03:41.090 --> 03:42.090
再来看一眼

03:42.090 --> 03:43.090
好

03:43.090 --> 03:45.090
我往里面去传一个20

03:45.090 --> 03:48.090
我可以去输出一下它的一个反回值

03:48.090 --> 03:49.090
那当然呢

03:49.090 --> 03:51.090
我们用一个函数的话

03:51.090 --> 03:53.090
如果说你用的这个函数

03:53.090 --> 03:55.090
并不是用它的反回值的话

03:55.090 --> 03:57.090
那其实基本上我们可以断定了

03:57.090 --> 03:59.090
它一定不是传函数了

03:59.090 --> 04:00.090
那为什么它会这样呢

04:00.090 --> 04:01.090
我们一会说

04:01.090 --> 04:03.090
我们现在还是来看这

04:03.090 --> 04:05.090
你看这我们确实是用了它的一个反回值

04:05.090 --> 04:06.090
对吧

04:06.090 --> 04:07.090
那用到它的反回值呢

04:07.090 --> 04:09.090
它也不一定是个传函数

04:09.090 --> 04:11.090
我们还是再根据我们刚才所说的两句话

04:11.090 --> 04:13.090
来判定一下它到底是不是

04:13.090 --> 04:14.090
好

04:14.090 --> 04:15.090
那咱来看一下

04:15.090 --> 04:16.090
现在我保存一次

04:16.090 --> 04:17.090
咱来输出一下这个结果

04:17.090 --> 04:18.090
打开一下

04:19.090 --> 04:21.090
当然这个结果是一定可以输出出来

04:21.090 --> 04:22.090
对不对

04:22.090 --> 04:23.090
因为我们传的是一个20

04:23.090 --> 04:25.090
它里面只有

04:25.090 --> 04:26.090
它里面这个值呢

04:26.090 --> 04:28.090
是使用的是NAM

04:28.090 --> 04:29.090
对吧

04:29.090 --> 04:30.090
NAM是18

04:30.090 --> 04:31.090
所以说最后输出一个是2

04:31.090 --> 04:32.090
对吧

04:32.090 --> 04:33.090
那它是传函数吗

04:33.090 --> 04:34.090
它显然不是传函数

04:34.090 --> 04:35.090
因为什么呢

04:35.090 --> 04:37.090
因为这个函数在执行它的功能的时候

04:37.090 --> 04:40.090
它需要依赖于外部的这样一个变量

04:40.090 --> 04:41.090
好了

04:41.090 --> 04:44.090
那我说依赖于外部这样的一个变量的话

04:44.090 --> 04:46.090
它才能完成这样的功能的话

04:46.090 --> 04:47.090
就不如是传函数

04:47.090 --> 04:48.090
那如果说话

04:48.090 --> 04:49.090
这个NAM

04:49.090 --> 04:50.090
我不使用它

04:50.090 --> 04:51.090
而我使用这个18

04:51.090 --> 04:53.090
那我在这的话咱们保存一次

04:53.090 --> 04:54.090
您看一眼

04:54.090 --> 04:55.090
上心一下

04:55.090 --> 04:56.090
好

04:56.090 --> 04:58.090
依旧是返回这样的数

04:58.090 --> 04:59.090
那现在这个函数呢

04:59.090 --> 05:01.090
我们可以管它叫做传函数了

05:01.090 --> 05:02.090
因为这个函数的功能

05:02.090 --> 05:04.090
一旦执行以后的话

05:04.090 --> 05:06.090
它并没有对外界产生任何影响

05:06.090 --> 05:07.090
也就是说

05:07.090 --> 05:11.090
它并没有去修改掉

05:11.090 --> 05:13.090
它遵御之外

05:13.090 --> 05:15.090
当然它遵御之外的话

05:15.090 --> 05:17.090
应该是权娱作用

05:17.090 --> 05:19.090
它没有去修改权娱作用

05:19.090 --> 05:21.090
任何一个变量的这样一个值

05:21.090 --> 05:23.090
也就是说它对外界没有这样的影响

05:23.090 --> 05:25.090
同时它所完成的功能

05:25.090 --> 05:27.090
也不依赖于外界

05:27.090 --> 05:28.090
OK

05:28.090 --> 05:29.090
那当然

05:29.090 --> 05:31.090
如果说我这么来对一个函数的话

05:31.090 --> 05:33.090
它这样的一个试用性

05:33.090 --> 05:34.090
就不会非常低

05:34.090 --> 05:35.090
它只能判断一个

05:35.090 --> 05:36.090
是18这样的一个

05:36.090 --> 05:38.090
比较的一个值

05:38.090 --> 05:40.090
那我们可以怎么办呢

05:40.090 --> 05:42.090
我可以让它接受两个传数

05:42.090 --> 05:43.090
对吧

05:43.090 --> 05:45.090
比如说叫做NAM

05:45.090 --> 05:46.090
好我这呢

05:46.090 --> 05:47.090
写一个NAM

05:47.090 --> 05:48.090
OK

05:48.090 --> 05:50.090
那我在进行比较的时候

05:50.090 --> 05:52.090
我可以传两个传数

05:52.090 --> 05:53.090
第一个传数呢

05:53.090 --> 05:55.090
就是我传个具体的一个值

05:55.090 --> 05:56.090
第二个传数呢

05:56.090 --> 05:57.090
我放进这样一个变量

05:57.090 --> 05:58.090
对吧

05:58.090 --> 05:59.090
好了那这样的话

05:59.090 --> 06:00.090
咱来看一下

06:00.090 --> 06:02.090
依旧是可以返回这样一个处的

06:02.090 --> 06:04.090
那它叫传数吗

06:04.090 --> 06:06.090
它当然叫传数了

06:06.090 --> 06:07.090
为什么呢

06:07.090 --> 06:08.090
咱们之前不说嘛

06:08.090 --> 06:09.090
说一个传数

06:09.090 --> 06:10.090
只有说在成功的时候

06:10.090 --> 06:12.090
不依赖于外界的变量

06:12.090 --> 06:13.090
要存传数吗

06:13.090 --> 06:14.090
OK

06:14.090 --> 06:16.090
这句话确实是没有错

06:16.090 --> 06:17.090
那你看好了

06:17.090 --> 06:18.090
我们这个传数

06:18.090 --> 06:20.090
在真正执行的时候

06:20.090 --> 06:22.090
它一定会创建这样一个AO

06:22.090 --> 06:25.090
叫做执行期

06:25.090 --> 06:26.090
上下门对象

06:26.090 --> 06:27.090
或者叫做活动对象

06:27.090 --> 06:29.090
它其实就是这个

06:29.090 --> 06:31.090
传数在执行的时候

06:31.090 --> 06:33.090
一个直接的一个环境

06:33.090 --> 06:35.090
那在这个AO里面

06:35.090 --> 06:37.090
必然会有这样一个NAM

06:37.090 --> 06:38.090
那这个

06:38.090 --> 06:40.090
如果说你了解一边一的话

06:40.090 --> 06:42.090
你就一定知道

06:42.090 --> 06:43.090
这个一个还数在真正之前

06:43.090 --> 06:45.090
到底发生了哪些过程

06:45.090 --> 06:46.090
如果你不知道的话

06:46.090 --> 06:47.090
你也可以去看我们

06:47.090 --> 06:49.090
独一教育的这样的一个

06:49.090 --> 06:50.090
Joss Cooper经营课堂

06:50.090 --> 06:51.090
这样的一个课程

06:51.090 --> 06:52.090
是完全公益的

06:52.090 --> 06:53.090
你可以

06:53.090 --> 06:54.090
在里面

06:54.090 --> 06:56.090
我们把整个GS

06:56.090 --> 06:58.090
所有覆盖的这样的知识点

06:58.090 --> 07:00.090
全部很适用进行这样的一个讲解

07:00.090 --> 07:01.090
你想去看的话

07:01.090 --> 07:03.090
可以去东京课堂上去搜一下

07:03.090 --> 07:05.090
去搜一下这个独一

07:05.090 --> 07:06.090
就可以去看我们这样的课程了

07:06.090 --> 07:07.090
完全是公益的

07:07.090 --> 07:08.090
OK

07:08.090 --> 07:09.090
那回到这里面来

07:09.090 --> 07:11.090
那这个AO里面有这个NAM

07:11.090 --> 07:12.090
那也就是说

07:12.090 --> 07:14.090
我在使用这个NAM的时候

07:14.090 --> 07:15.090
并不是使用外界的这个NAM

07:15.090 --> 07:17.090
而是使用它自己的一个NAM

07:17.090 --> 07:18.090
我把这个

07:18.090 --> 07:20.090
我在执行这个函数的时候

07:20.090 --> 07:22.090
我所传递的这个

07:22.090 --> 07:23.090
全聚必量的这个NAM

07:23.090 --> 07:24.090
只是把这个值

07:24.090 --> 07:26.090
复制一份去给了它

07:26.090 --> 07:28.090
那我在真正完成这个功能的时候呢

07:28.090 --> 07:30.090
依旧是使用我内部的这样一个NAM

07:30.090 --> 07:32.090
所以说它依旧是个全函数

07:32.090 --> 07:33.090
好了

07:33.090 --> 07:35.090
那这个地方

07:35.090 --> 07:36.090
咱大概了解以后的话

07:36.090 --> 07:37.090
我们藏了下来

07:37.090 --> 07:38.090
再回来

07:38.090 --> 07:40.090
我们再往下去深入的去看一下

07:40.090 --> 07:42.090
比如说在这

07:42.090 --> 07:44.090
过了一个AR

07:44.090 --> 07:45.090
一个数组

07:45.090 --> 07:46.090
好了

07:46.090 --> 07:48.090
那我写个function

07:48.090 --> 07:49.090
叫做test

07:49.090 --> 07:51.090
或者叫做add

07:51.090 --> 07:52.090
好了

07:52.090 --> 07:53.090
那它呢

07:53.090 --> 07:55.090
介绍一个参数叫做Gun

07:55.090 --> 07:57.090
那如果说

07:57.090 --> 07:59.090
我在执行这个函数的时候

07:59.090 --> 08:00.090
我们之前是不是说了

08:00.090 --> 08:02.090
当你在执行一个函数的时候

08:02.090 --> 08:03.090
如果这个函数完全没有法规指的时候

08:03.090 --> 08:05.090
它就一定不是传递的数

08:05.090 --> 08:06.090
那当然呢

08:06.090 --> 08:08.090
这个没有法规指

08:08.090 --> 08:09.090
没有

08:09.090 --> 08:11.090
这个没有法规指的前提是这个函数

08:11.090 --> 08:13.090
还要应该起到它下一个函数

08:13.090 --> 08:14.090
对不对

08:14.090 --> 08:15.090
那怎么办呢

08:15.090 --> 08:16.090
那你看好了

08:16.090 --> 08:17.090
当我在执行这个add的时候

08:17.090 --> 08:18.090
如果说我传一个数组

08:18.090 --> 08:20.090
那我的目的是要往这个数组之中呢

08:20.090 --> 08:22.090
去加上一个数据

08:22.090 --> 08:24.090
或者说去加上一个对象

08:24.090 --> 08:25.090
握一个

08:25.090 --> 08:26.090
叫做obj

08:26.090 --> 08:27.090
等于一个对象

08:27.090 --> 08:28.090
这个对象呢

08:28.090 --> 08:29.090
叫NAM等于3c

08:29.090 --> 08:30.090
好了

08:30.090 --> 08:32.090
那如果说是这样的话

08:32.090 --> 08:34.090
我让这个add执行完以后

08:34.090 --> 08:35.090
既没有法规指

08:35.090 --> 08:37.090
还能起到这个加

08:37.090 --> 08:39.090
还能起到这样一个加的一个作用的话

08:39.090 --> 08:41.090
我就只能去使用

08:41.090 --> 08:43.090
dea.push

08:43.090 --> 08:45.090
往里面去放一下这个对象

08:45.090 --> 08:46.090
ok

08:46.090 --> 08:48.090
那如果是这样的话

08:48.090 --> 08:49.090
咱可以看一下

08:49.090 --> 08:51.090
当这个函数执行完以后

08:51.090 --> 08:53.090
我确实没用到这个函数的一个法规指

08:53.090 --> 08:55.090
而我去输出这个arr的时候

08:55.090 --> 08:56.090
咱们来看一眼

08:56.090 --> 08:58.090
当arr里面一定是有了

08:58.090 --> 09:00.090
这样的一个对象这个指

09:00.090 --> 09:01.090
那也就是说

09:01.090 --> 09:03.090
现在这个函数在执行的时候

09:03.090 --> 09:05.090
虽然说

09:05.090 --> 09:07.090
它有这样的一个行参辩量

09:07.090 --> 09:08.090
但是呢

09:08.090 --> 09:11.090
它在拿到这个行参辩量去执行的时候呢

09:11.090 --> 09:15.090
它依旧对外界这个arr产生了影响

09:15.090 --> 09:16.090
那咱们说

09:16.090 --> 09:19.090
你看刚才这个函数

09:19.090 --> 09:20.090
我用这个NAM

09:20.090 --> 09:21.090
它是自己的对不对

09:21.090 --> 09:22.090
那如果说

09:22.090 --> 09:24.090
你在这改变这个NAM的话

09:24.090 --> 09:26.090
它也不会对外界产生

09:26.090 --> 09:27.090
产生这样的一个影响

09:27.090 --> 09:29.090
那为什么它就会呢

09:29.090 --> 09:30.090
那这一门

09:30.090 --> 09:31.090
涉及到一个引用值

09:31.090 --> 09:33.090
和原始值存储的一个区别

09:33.090 --> 09:35.090
如果说你技术不好的话

09:35.090 --> 09:36.090
对吧

09:36.090 --> 09:37.090
也可以去看看我们之前的课

09:37.090 --> 09:39.090
那在这门我就不再去追数了

09:39.090 --> 09:41.090
好

09:41.090 --> 09:43.090
那由于呢

09:43.090 --> 09:44.090
我确实在传

09:44.090 --> 09:46.090
我确实在形容这个函数的时候

09:46.090 --> 09:48.090
我传递是这个arr

09:48.090 --> 09:49.090
OK

09:49.090 --> 09:50.090
但你要知道

09:50.090 --> 09:51.090
我传递就是这个受阻的一个引用

09:51.090 --> 09:52.090
哇

09:52.090 --> 09:53.090
这个引用我复制给它

09:53.090 --> 09:54.090
那我在这个函数里面

09:54.090 --> 09:55.090
执行的时候

09:55.090 --> 09:57.090
其实我依旧操作的是外界这个受阻

09:57.090 --> 09:59.090
我在加这个对象的时候

09:59.090 --> 10:00.090
也是往这里面夹

10:00.090 --> 10:01.090
这个函数执行完以后的话

10:01.090 --> 10:02.090
好了

10:02.090 --> 10:04.090
它确实

10:04.090 --> 10:06.090
它确实是对

10:06.090 --> 10:08.090
这个外界这样的数

10:08.090 --> 10:10.090
产生了一个很深的一个影响

10:10.090 --> 10:13.090
有时候给它确实是加上这样的一个值

10:13.090 --> 10:14.090
那OK

10:14.090 --> 10:16.090
那它必然不是一个存函数

10:16.090 --> 10:17.090
那如果想把它变成个存函数

10:17.090 --> 10:18.090
怎么办呢

10:18.090 --> 10:19.090
当然

10:19.090 --> 10:20.090
你可以这么做

10:21.090 --> 10:23.090
我可以误了一个新的arr

10:24.090 --> 10:25.090
好

10:25.090 --> 10:26.090
它是个受阻

10:26.090 --> 10:27.090
那这个新的arr的话

10:27.090 --> 10:28.090
好了

10:28.090 --> 10:30.090
我再去

10:31.090 --> 10:33.090
往里面去加上一个值

10:33.090 --> 10:34.090
叫什么呢

10:34.090 --> 10:36.090
叫上一个

10:40.090 --> 10:42.090
叫上一个obj

10:42.090 --> 10:43.090
对吧

10:43.090 --> 10:44.090
好了

10:44.090 --> 10:45.090
那如果是这样的话

10:45.090 --> 10:46.090
怎么会发现

10:46.090 --> 10:48.090
当然我最后都反过这个arr对吧

10:48.090 --> 10:50.090
我在执行一个函数的时候

10:50.090 --> 10:54.090
我最后使用的也是这样的一个narr

10:55.090 --> 10:56.090
最后我使用的

10:56.090 --> 10:58.090
也确实是它所反馈的一个反馈值

10:58.090 --> 10:59.090
对不对

10:59.090 --> 11:00.090
好

11:00.090 --> 11:01.090
那这里面

11:01.090 --> 11:02.090
我这个garr

11:02.090 --> 11:04.090
它是没有什么起到任何作用对不对

11:04.090 --> 11:06.090
那如果是我把这个

11:06.090 --> 11:09.090
例子再进行一个强化的要求

11:09.090 --> 11:11.090
就是我这里面一开始

11:11.090 --> 11:12.090
有一个数据

11:12.090 --> 11:13.090
它叫name

11:13.090 --> 11:14.090
比如name叫做一个

11:14.090 --> 11:15.090
读意

11:15.090 --> 11:16.090
好了

11:16.090 --> 11:18.090
那我在执行这个add的时候

11:18.090 --> 11:19.090
我希望呢

11:19.090 --> 11:20.090
是把这个

11:20.090 --> 11:23.090
试图中原样的这个对象

11:23.090 --> 11:24.090
对吧

11:24.090 --> 11:26.090
我再去加上这样的一个新的对象

11:26.090 --> 11:27.090
最后反馈一个新的数据

11:27.090 --> 11:29.090
去给外界去使用

11:29.090 --> 11:30.090
那当然呢

11:30.090 --> 11:32.090
如果我不采取这种方式

11:32.090 --> 11:35.090
我直接去这么做arr点posed的话

11:35.090 --> 11:36.090
那当然呢

11:36.090 --> 11:37.090
确实是可以达到我们这样的需求

11:37.090 --> 11:38.090
但咱们说了对吧

11:38.090 --> 11:40.090
它不是一个纯函数

11:40.090 --> 11:42.090
因为你一旦

11:43.090 --> 11:44.090
这样

11:44.090 --> 11:45.090
因为你一旦这么做了以后的话

11:45.090 --> 11:46.090
最后你输出的时候

11:46.090 --> 11:47.090
你会发现

11:47.090 --> 11:48.090
外界这个arr

11:48.090 --> 11:51.090
它确实是多了一个这样的值

11:51.090 --> 11:54.040
等会等一下

11:57.040 --> 11:59.040
当然我不应该输出它

11:59.040 --> 12:03.540
应该是输出这个console

12:03.540 --> 12:05.540
the logarr

12:05.540 --> 12:06.540
把它算一下

12:06.540 --> 12:07.540
好 三看一眼

12:07.540 --> 12:10.540
OK 是确实是多一个值对吧

12:10.540 --> 12:11.540
但是呢

12:11.540 --> 12:12.540
我们现在是想

12:12.540 --> 12:13.540
想想它变成一个传喊数

12:13.540 --> 12:14.540
那传喊数的话

12:14.540 --> 12:15.540
就是需要

12:15.540 --> 12:16.540
像我们之前说的

12:16.540 --> 12:17.540
用它的一个返回值

12:17.540 --> 12:18.540
那这样的话

12:18.540 --> 12:20.540
我就不应该直接在这里面去加

12:20.540 --> 12:21.540
而是怎么做呢

12:21.540 --> 12:23.540
应该是应该把arr里面去个值

12:23.540 --> 12:24.540
克龙一份

12:24.540 --> 12:25.540
克龙给谁啊

12:25.540 --> 12:28.540
克龙给这个新的arr里面的

12:31.540 --> 12:33.540
数据中的第一个值

12:33.540 --> 12:34.540
那好了

12:34.540 --> 12:35.540
那怎么来克龙呢

12:35.540 --> 12:37.540
其实你当然可以这么做对吧

12:37.540 --> 12:39.540
比如说你有arr

12:39.540 --> 12:41.540
你可以直接让它的d0位

12:41.540 --> 12:43.540
等于arr0

12:43.540 --> 12:44.540
但呢

12:45.540 --> 12:46.540
如果说

12:46.540 --> 12:47.540
这个数据

12:47.540 --> 12:48.540
它的这个个数

12:48.540 --> 12:49.540
你不知道

12:49.540 --> 12:50.540
它有多少个的情况下的话

12:50.540 --> 12:52.540
你当然可以采用这样的一个

12:52.540 --> 12:53.540
对吧

12:53.540 --> 12:54.540
你放行换一下

12:54.540 --> 12:55.540
过一个i

12:55.540 --> 12:56.540
i等于一个点

12:56.540 --> 12:57.540
完了之后

12:57.540 --> 12:58.540
i小于一个

13:00.540 --> 13:01.540
完了之后呢

13:01.540 --> 13:02.540
再来一个i加加

13:02.540 --> 13:03.540
你可以把这个

13:03.540 --> 13:05.540
garr里面的所有的值

13:05.540 --> 13:06.540
你全部

13:06.540 --> 13:08.540
给到这个arr里面来

13:09.540 --> 13:10.540
好

13:10.540 --> 13:11.540
那最后呢

13:11.540 --> 13:13.540
最后我们再来添加那个功能

13:13.540 --> 13:14.540
再来添加那个功能

13:14.540 --> 13:15.540
好

13:15.540 --> 13:17.540
这让我来一个叫做

13:17.540 --> 13:18.540
o

13:18.540 --> 13:19.540
push

13:19.540 --> 13:20.540
一个obj

13:20.540 --> 13:21.540
最后呢

13:21.540 --> 13:22.540
返回的时候

13:22.540 --> 13:23.540
也是返回这样的一个

13:24.540 --> 13:26.540
那么咱来看一眼吧

13:26.540 --> 13:27.540
咱来看一眼

13:27.540 --> 13:29.540
那最后我在添加这个函数的时候

13:29.540 --> 13:31.540
我确实是要使用它的一个返回值

13:31.540 --> 13:32.540
好

13:32.540 --> 13:33.540
OK

13:33.540 --> 13:34.540
cancel

13:34.540 --> 13:36.540
点log一下

13:36.540 --> 13:37.540
好 看它返回值

13:37.540 --> 13:39.540
是不是我们所期待的这样的一个值

13:39.540 --> 13:40.540
稍微一次

13:40.540 --> 13:41.540
有两个值吧

13:41.540 --> 13:42.540
对吧

13:42.540 --> 13:44.540
确实是有两个

13:44.540 --> 13:45.540
那这样的话

13:45.540 --> 13:47.540
确实能达到这样一个

13:47.540 --> 13:49.540
就是仇函数的一个思想

13:49.540 --> 13:50.540
但是呢

13:50.540 --> 13:51.540
如果说

13:51.540 --> 13:52.540
我们针对于

13:52.540 --> 13:53.540
这种

13:53.540 --> 13:54.540
引用值中

13:54.540 --> 13:56.540
又嵌套了一个引用值

13:56.540 --> 13:57.540
但是一个数组中发了一个对象

13:57.540 --> 13:58.540
对不对

13:58.540 --> 13:59.540
我们进行这样的一个

14:00.540 --> 14:01.540
一个传承数

14:01.540 --> 14:02.540
一个操作的时候

14:02.540 --> 14:03.540
我不确实呢

14:03.540 --> 14:05.540
是想往这个一个新的数组中对不对

14:05.540 --> 14:07.540
去加上一个这个原有的一个值

14:07.540 --> 14:08.540
再反过这个新的数组

14:08.540 --> 14:09.540
我们使用的呢

14:09.540 --> 14:10.540
是这个新的数组

14:10.540 --> 14:11.540
那我们如果说

14:11.540 --> 14:12.540
在外界

14:12.540 --> 14:14.540
比如说我们在外界

14:14.540 --> 14:15.540
你握一个

14:15.540 --> 14:16.540
n

14:16.540 --> 14:17.540
对吧等于一个它

14:17.540 --> 14:19.540
那我拿到这个数组的话

14:20.540 --> 14:21.540
比如说

14:21.540 --> 14:22.540
我让它的最后一位

14:22.540 --> 14:23.540
n

14:24.540 --> 14:25.540
或者说

14:25.540 --> 14:27.540
我直接再调一个

14:27.540 --> 14:28.540
PUSH方法

14:28.540 --> 14:29.540
好

14:29.540 --> 14:31.540
去往里面放一个叫做NAM

14:31.540 --> 14:32.540
等于一个

14:33.540 --> 14:34.540
好

14:34.540 --> 14:36.540
那咱们再来看一下

14:36.540 --> 14:37.540
我现在

14:37.540 --> 14:38.540
拿到这个AR

14:38.540 --> 14:40.540
它是只有一个值

14:40.540 --> 14:41.540
但这个n

14:41.540 --> 14:42.540
它就变成了

14:42.540 --> 14:43.540
三个值对不对

14:43.540 --> 14:44.540
好

14:44.540 --> 14:45.540
那有时候我确实通过

14:45.540 --> 14:47.540
这个传说这样的那种方式

14:47.540 --> 14:49.540
打到你所需要的一个需求对不对

14:49.540 --> 14:51.540
而且它并没有影响到

14:51.540 --> 14:52.540
原先这样的一个值

14:52.540 --> 14:53.540
那如果说

14:53.540 --> 14:55.540
像我们刚才讲的

14:55.540 --> 14:56.540
一个数组中

14:56.540 --> 14:57.540
又签到了另外一个

14:57.540 --> 14:58.540
引用值的情况下的话

14:58.540 --> 15:00.540
我建议同学们

15:00.540 --> 15:01.540
以后大盘碰到这样的

15:01.540 --> 15:02.540
状况状况的时候

15:02.540 --> 15:04.540
你不要把这样的一个数据

15:04.540 --> 15:05.540
直接去付给它

15:05.540 --> 15:06.540
而是在这呢

15:06.540 --> 15:08.540
我希望你能通过

15:08.540 --> 15:10.540
你自己写的一个克隆方法

15:10.540 --> 15:11.540
DeepClo

15:11.540 --> 15:13.540
把这个对象

15:13.540 --> 15:14.540
也克隆克隆一份

15:14.540 --> 15:16.540
如果说你不这么做的话

15:16.540 --> 15:17.540
你就很有可能

15:17.540 --> 15:19.540
不说在外界的时候

15:19.540 --> 15:21.540
你去拿这个n

15:21.540 --> 15:22.540
去拿这个0

15:22.540 --> 15:23.540
你去操作这个值的时候

15:23.540 --> 15:25.540
你把它改成一个

15:25.540 --> 15:26.540
哈哈

15:26.540 --> 15:27.540
好了

15:27.540 --> 15:28.540
又说我不用它来做

15:28.540 --> 15:30.540
我不用它来做

15:30.540 --> 15:31.540
好

15:31.540 --> 15:32.540
给它改成一个

15:32.540 --> 15:33.540
哈哈

15:33.540 --> 15:34.540
那咱们再来看一下

15:34.540 --> 15:35.540
咱们再来看

15:35.540 --> 15:36.540
这个ARR的一个值

15:36.540 --> 15:37.540
是不是从不一变成了

15:37.540 --> 15:38.540
哈哈

15:38.540 --> 15:39.540
虽然说我只是改了

15:39.540 --> 15:41.540
这个n对不对

15:42.540 --> 15:43.540
我只是改了一个

15:43.540 --> 15:44.540
牛ARR

15:44.540 --> 15:45.540
但呢

15:45.540 --> 15:46.540
确实也让这个ARR的

15:46.540 --> 15:47.540
第一个值发生了

15:47.540 --> 15:48.540
这样的一个改变

15:48.540 --> 15:49.540
因为什么呢

15:49.540 --> 15:50.540
哎

15:50.540 --> 15:51.540
因为我在

15:51.540 --> 15:53.540
看这个n

15:53.540 --> 15:54.540
好

15:54.540 --> 15:55.540
因为什么呢

15:55.540 --> 15:56.540
因为我在这个复制的时候

15:56.540 --> 15:57.540
我是直接把

15:57.540 --> 15:58.540
这个对象里面

15:58.540 --> 15:59.540
去撇给了它

15:59.540 --> 16:00.540
对不对

16:00.540 --> 16:01.540
咱们在乘这个

16:01.540 --> 16:02.540
第一个值的时候

16:02.540 --> 16:03.540
都共同指向的是

16:03.540 --> 16:04.540
一个对象

16:04.540 --> 16:05.540
那我通过

16:05.540 --> 16:06.540
这种方式

16:06.540 --> 16:07.540
发文到你

16:07.540 --> 16:08.540
给你进行修改以后的话

16:08.540 --> 16:09.540
那我必然然我这个ARR

16:09.540 --> 16:10.540
对吧

16:10.540 --> 16:11.540
它所指向的值

16:11.540 --> 16:12.540
也会发生这样的

16:12.540 --> 16:13.540
那这样的话

16:13.540 --> 16:14.540
就没有办法

16:14.540 --> 16:15.540
真正去保证

16:15.540 --> 16:16.540
这个

16:16.540 --> 16:18.540
函数的一个纯度

16:18.540 --> 16:19.540
所以说呢

16:19.540 --> 16:20.540
你想真正去

16:20.540 --> 16:21.540
让它

16:21.540 --> 16:22.540
变成一个玩玩

16:22.540 --> 16:23.540
整种的一个纯函数的话

16:23.540 --> 16:24.540
好了

16:24.540 --> 16:25.540
我希望你

16:25.540 --> 16:26.540
能再写一个克龙

16:26.540 --> 16:27.540
那克龙呢

16:27.540 --> 16:28.540
我们之前也是讲过

16:28.540 --> 16:29.540
这里面呢

16:29.540 --> 16:30.540
我也不再去

16:30.540 --> 16:31.540
坠述了

16:31.540 --> 16:32.540
如果你想了解克龙的话

16:32.540 --> 16:33.540
你可以去看我们

16:33.540 --> 16:34.540
之前那个

16:34.540 --> 16:35.540
加特斯克北京

16:35.540 --> 16:36.540
看到那个课

16:36.540 --> 16:37.540
好

16:37.540 --> 16:38.540
那

16:38.540 --> 16:39.540
大体呢

16:39.540 --> 16:40.540
咱已经对这种

16:40.540 --> 16:41.540
传输的方式

16:41.540 --> 16:42.540
有所了解了

16:42.540 --> 16:43.540
也就是说

16:43.540 --> 16:45.540
当你订一个函数的时候

16:45.540 --> 16:46.540
好

16:46.540 --> 16:47.540
这个函数呢

16:48.540 --> 16:49.540
OK

16:49.540 --> 16:50.540
比如说SY

16:50.540 --> 16:51.540
我返回的是

16:51.540 --> 16:52.540
S加Y

16:52.540 --> 16:53.540
好

16:53.540 --> 16:54.540
那我握一个NAM

16:54.540 --> 16:55.540
E

16:55.540 --> 16:56.540
终于一个E

16:56.540 --> 16:57.540
我握一个NAM2

16:57.540 --> 16:58.540
等于2

16:58.540 --> 16:59.540
好了

16:59.540 --> 17:00.540
当你使用一个函数的时候

17:00.540 --> 17:01.540
首先你使用它的是

17:01.540 --> 17:02.540
法规值

17:02.540 --> 17:03.540
你传的值呢

17:03.540 --> 17:04.540
好了

17:04.540 --> 17:05.540
是它外界最后一个值

17:05.540 --> 17:06.540
或者说你自己

17:06.540 --> 17:07.540
是把写给值

17:07.540 --> 17:08.540
那

17:08.540 --> 17:09.540
这个函数

17:09.540 --> 17:10.540
在实行功能的时候呢

17:10.540 --> 17:11.540
OK

17:11.540 --> 17:13.540
它只是使用它内部的

17:13.540 --> 17:14.540
一些配量

17:14.540 --> 17:15.540
而并没有说是

17:15.540 --> 17:16.540
非得依靠

17:16.540 --> 17:17.540
使用外部的一些配量

17:17.540 --> 17:18.540
才能完成

17:18.540 --> 17:19.540
我这样的一个功能

17:20.540 --> 17:21.540
那

17:21.540 --> 17:22.540
这种情况下的话

17:22.540 --> 17:23.540
我们可以说

17:23.540 --> 17:24.540
它就是一个

17:24.540 --> 17:25.540
纯函数了

17:25.540 --> 17:26.540
而且呢

17:26.540 --> 17:27.540
它必须在完成

17:27.540 --> 17:28.540
功能的时候呢

17:28.540 --> 17:29.540
还不想到外界

17:29.540 --> 17:30.540
对吧

17:30.540 --> 17:31.540
就比如说

17:31.540 --> 17:32.540
像这样的一个函数

17:32.540 --> 17:33.540
爱的

17:33.540 --> 17:34.540
如果呢

17:34.540 --> 17:35.540
就是来个

17:35.540 --> 17:36.540
好了

17:36.540 --> 17:37.540
我再握一个叫做

17:37.540 --> 17:38.540
叫G

17:38.540 --> 17:39.540
G

17:39.540 --> 17:40.540
R

17:40.540 --> 17:41.540
算一个数字

17:41.540 --> 17:42.540
那我在

17:42.540 --> 17:43.540
实行这个功能的时候

17:43.540 --> 17:44.540
比如说我

17:44.540 --> 17:45.540
铺实一下

17:45.540 --> 17:46.540
一个E

17:46.540 --> 17:47.540
OK

17:47.540 --> 17:48.540
那虽然说

17:48.540 --> 17:49.540
其实我最后

17:49.540 --> 17:50.540
反过来是这个R

17:50.540 --> 17:51.540
那我在掉它的时候

17:51.540 --> 17:52.540
我传这个G

17:52.540 --> 17:53.540
R

17:53.540 --> 17:54.540
好

17:54.540 --> 17:55.540
一直使用的话

17:55.540 --> 17:56.540
它也依旧

17:56.540 --> 17:57.540
不是一个传暗数

17:57.540 --> 17:58.540
因为什么呢

17:58.540 --> 17:59.540
因为

17:59.540 --> 18:01.540
你确实在使用的时候

18:01.540 --> 18:02.540
这个函数在执行的时候

18:02.540 --> 18:03.540
你使用的是

18:03.540 --> 18:04.540
你自己的内部的一个配量

18:04.540 --> 18:05.540
没有说使用到

18:05.540 --> 18:07.540
外部的一个配量

18:07.540 --> 18:08.540
你确实在执行完以后

18:08.540 --> 18:09.540
对吧

18:09.540 --> 18:10.540
影响到了这样的一个

18:10.540 --> 18:11.540
外部的一个配量

18:11.540 --> 18:12.540
那这个

18:12.540 --> 18:14.540
它就没有办法保

18:14.540 --> 18:15.540
保证该函数的一个

18:15.540 --> 18:16.540
纯净度了

18:16.540 --> 18:17.540
这个纯度

18:17.540 --> 18:18.540
其实指的

18:18.540 --> 18:19.540
它就是

18:19.540 --> 18:20.540
我不依赖于外界

18:20.540 --> 18:21.540
也不影响外界

18:21.540 --> 18:22.540
OK

18:22.540 --> 18:23.540
那说了这么多

18:23.540 --> 18:24.540
绕口的词

18:24.540 --> 18:25.540
对吧

18:25.540 --> 18:26.540
好了

18:26.540 --> 18:27.540
咱也有这么多

18:27.540 --> 18:28.540
复杂的这样的功能

18:28.540 --> 18:29.540
那这个

18:29.540 --> 18:30.540
纯函数到底有什么用呢

18:30.540 --> 18:31.540
好

18:31.540 --> 18:32.540
那咱可以

18:32.540 --> 18:33.540
当然这个例子

18:33.540 --> 18:34.540
已经举完了

18:34.540 --> 18:35.540
对吧

18:35.540 --> 18:36.540
好

18:36.540 --> 18:37.540
这个

18:37.540 --> 18:38.540
我相信很多人都听过

18:38.540 --> 18:39.540
叫做bug

18:39.540 --> 18:40.540
首红定律

18:40.540 --> 18:41.540
也就是说

18:41.540 --> 18:43.540
当你在开发网站的时候

18:43.540 --> 18:44.540
其实你百分

18:44.540 --> 18:45.540
或者说

18:45.540 --> 18:47.540
当你做这个开发的时候吧

18:47.540 --> 18:48.540
你百分之五十的时间

18:48.540 --> 18:49.540
其实是在调bug

18:49.540 --> 18:50.540
对吧

18:50.540 --> 18:51.540
当你去

18:51.540 --> 18:53.540
发现了十个bug以后的话

18:53.540 --> 18:55.540
你可能又多出了十个bug

18:55.540 --> 18:57.540
当然这是一个开玩笑的一个事

18:57.540 --> 18:58.540
这个命名之中

18:58.540 --> 18:59.540
可能会有这些

18:59.540 --> 19:00.540
首红的一个定律

19:00.540 --> 19:01.540
但是呢

19:01.540 --> 19:02.540
你要知道一点

19:02.540 --> 19:04.540
或者你要知道两点吧

19:04.540 --> 19:05.540
第一点就是

19:05.540 --> 19:06.540
你在开发网站的时候

19:06.540 --> 19:07.540
当这个代码量

19:07.540 --> 19:08.540
达到一定程度以后的话

19:08.540 --> 19:09.540
你是不可避免的

19:09.540 --> 19:11.540
会产生各种bug

19:11.540 --> 19:13.540
当然这个不是just code

19:13.540 --> 19:15.540
不是这个gstl的一个问题

19:15.540 --> 19:16.540
你用任何一个语言

19:16.540 --> 19:17.540
做任何一种开发

19:17.540 --> 19:18.540
它都会这样

19:18.540 --> 19:19.540
它是语言的一个通病

19:19.540 --> 19:20.540
那好了

19:20.540 --> 19:21.540
虽然说我们不可能

19:21.540 --> 19:24.540
彻底的清除程序中的bug

19:24.540 --> 19:25.540
但是呢

19:25.540 --> 19:26.540
这并不意味着

19:26.540 --> 19:27.540
我们可以通过一些

19:27.540 --> 19:29.540
提前的一些规范

19:29.540 --> 19:32.540
来避免更多的bug的一个引入

19:32.540 --> 19:33.540
OK

19:33.540 --> 19:34.540
所以传达数呢

19:34.540 --> 19:35.540
它就是我们

19:35.540 --> 19:36.540
预防bug

19:36.540 --> 19:37.540
一个很好的一个利器

19:37.540 --> 19:38.540
OK

19:38.540 --> 19:39.540
因为什么呢

19:39.540 --> 19:41.540
因为在我们这个开发过程中

19:41.540 --> 19:42.540
尤其是在我们

19:42.540 --> 19:43.540
前面开发过程中

19:43.540 --> 19:44.540
我们使用gst

19:44.540 --> 19:45.540
其实是很容易

19:45.540 --> 19:46.540
创建一个权局变量的

19:46.540 --> 19:47.540
而且我们也会

19:47.540 --> 19:48.540
经常创建权局变量

19:48.540 --> 19:50.540
我相信很多人在没有

19:50.540 --> 19:51.540
学到这个传达数的

19:51.540 --> 19:52.540
一概念之之前

19:52.540 --> 19:55.540
你完全就是不在乎

19:55.540 --> 19:56.540
是一个还是之中

19:56.540 --> 19:57.540
对吧

19:57.540 --> 19:58.540
在实现这个功能

19:58.540 --> 19:59.540
它是否对外界产生的影响

19:59.540 --> 20:01.540
它是否一定要依赖于

20:01.540 --> 20:02.540
外界

20:02.540 --> 20:03.540
可能说你都没有去注意

20:03.540 --> 20:04.540
但是往往

20:04.540 --> 20:05.540
就是因为这些点

20:05.540 --> 20:08.540
它是经常导致bug的一些原因

20:08.540 --> 20:10.540
因为程序中呢

20:10.540 --> 20:12.540
如果任何一个权数

20:12.540 --> 20:14.540
都可能去修改权局变量的话

20:14.540 --> 20:15.540
那好了

20:15.540 --> 20:16.540
那彼此之间

20:16.540 --> 20:19.540
进行权局变量的一个影响

20:19.540 --> 20:20.540
比如说权数和权数之间

20:20.540 --> 20:22.540
对权局变量都有些影响

20:22.540 --> 20:23.540
而且他们在

20:23.540 --> 20:25.540
进行一些功能的时候

20:25.540 --> 20:26.540
都会依靠于

20:26.540 --> 20:27.540
这样的一个权局的一个变量

20:27.540 --> 20:28.540
或者说

20:28.540 --> 20:30.540
依赖于它外界这样的一个变量

20:30.540 --> 20:31.540
那就很有可能

20:31.540 --> 20:32.540
对吧

20:32.540 --> 20:33.540
当你改完以后的话

20:33.540 --> 20:34.540
另一个在使用的时候

20:34.540 --> 20:36.540
它就会出现这样的一个异常

20:36.540 --> 20:37.540
好了

20:37.540 --> 20:38.540
那存在说这个概念呢

20:38.540 --> 20:40.540
就是我

20:40.540 --> 20:41.540
我示好

20:41.540 --> 20:43.540
就是表面上是依赖你

20:43.540 --> 20:45.540
你这个外界变量的一个传入

20:45.540 --> 20:46.540
但实际上呢

20:46.540 --> 20:47.540
我使用的是

20:47.540 --> 20:49.540
我内部的这样的一个形参变量

20:49.540 --> 20:50.540
我在使用的时候

20:50.540 --> 20:51.540
我去完成我的功能

20:51.540 --> 20:53.540
而且并没有影响到你

20:53.540 --> 20:55.540
这个外界的这样的一个变量

20:55.540 --> 20:56.540
一个值

20:56.540 --> 20:57.540
那我使用的呢

20:57.540 --> 20:58.540
也只是这个权数

20:58.540 --> 21:00.540
它输出后的一个结果而已

21:00.540 --> 21:01.540
那具有情况下的话

21:01.540 --> 21:02.540
就可以很好的很大程度上

21:02.540 --> 21:04.540
避免这个Bug存在

21:04.540 --> 21:05.540
那OK

21:05.540 --> 21:07.540
那当然它的自动还有很多

21:07.540 --> 21:08.540
就比如说

21:08.540 --> 21:10.540
如果说我们再往后学

21:10.540 --> 21:11.540
当然是我们这个

21:11.540 --> 21:12.540
这个

21:12.540 --> 21:13.540
进阶班的时候

21:13.540 --> 21:14.540
我们这个独一的有一个

21:14.540 --> 21:16.540
就业班和进阶班

21:16.540 --> 21:18.540
如果说你是这个

21:18.540 --> 21:20.540
还没有在一个就业的一个

21:20.540 --> 21:22.540
你还没有处在一个就业的一个状况

21:22.540 --> 21:25.540
或者说你是处在一个求职的一个状态的话

21:25.540 --> 21:26.540
你可以看我们

21:26.540 --> 21:28.540
你可以去报名我这样的一个就业班

21:28.540 --> 21:30.540
就业班基本上覆盖了所有这样的一个

21:30.540 --> 21:32.540
课程那个内容

21:32.540 --> 21:34.540
如果说你想在二线线尝试

21:34.540 --> 21:36.540
找到一个比较好的工作的话

21:36.540 --> 21:38.540
你就可以去报这样的就业班

21:38.540 --> 21:39.540
那还有这样的进阶班

21:39.540 --> 21:40.540
在进阶班之中呢

21:40.540 --> 21:42.540
我们这个整个体系

21:42.540 --> 21:43.540
又升级又缝满

21:43.540 --> 21:44.540
而且加深了很多

21:44.540 --> 21:46.540
比如说有主流的框架

21:46.540 --> 21:47.540
像VOE

21:47.540 --> 21:48.540
比如说相当的GS这种存在开发

21:48.540 --> 21:50.540
包括一些单元测试

21:50.540 --> 21:51.540
包括设计模式

21:51.540 --> 21:53.540
包括这些原码那些阅读

21:53.540 --> 21:54.540
等等等等

21:54.540 --> 21:55.540
那那个时候呢

21:55.540 --> 21:57.540
你会往往会发发现

21:57.540 --> 21:58.540
这个存寒数这个概念

21:58.540 --> 22:00.540
会取到更大的一个作用

22:00.540 --> 22:01.540
嗯

22:01.540 --> 22:03.540
就比如说在单元测试这个块的话

22:03.540 --> 22:05.540
如果说你拿存寒数去写的话

22:05.540 --> 22:07.540
它必然会是很容易去测试出

22:07.540 --> 22:09.540
这样的一个问题的所在的

22:09.540 --> 22:11.540
好那再往下来的话

22:11.540 --> 22:13.540
就是存寒数

22:13.540 --> 22:14.540
它是有这样一个

22:14.540 --> 22:16.540
是有这样一个建状性的

22:16.540 --> 22:17.540
也就是说该寒数

22:17.540 --> 22:18.540
或者说

22:18.540 --> 22:19.540
很多个存寒数

22:19.540 --> 22:21.540
在支撑的时候

22:21.540 --> 22:23.540
在这叫改变支撑的次序

22:23.540 --> 22:25.540
不会对系统造成影响

22:25.540 --> 22:26.540
那也就是说

22:26.540 --> 22:27.540
很多存寒数的话

22:27.540 --> 22:29.540
它可以去并行去执行的

22:29.540 --> 22:30.540
嗯

22:30.540 --> 22:31.540
那当然你想具体去

22:31.540 --> 22:33.540
真正的理解这一块的话

22:33.540 --> 22:35.540
我们还能拿一个粒子来举一举啊

22:35.540 --> 22:36.540
主要就是

22:36.540 --> 22:37.540
其实我们主要是想

22:37.540 --> 22:39.540
回顾一下这块的这样一个作用

22:39.540 --> 22:40.540
嗯

22:40.540 --> 22:42.540
就是在招式客户中对吧

22:42.540 --> 22:44.540
经常会碰到这种情况

22:44.540 --> 22:45.540
你要去修改全体别量

22:45.540 --> 22:46.540
但你修改完以后的话

22:46.540 --> 22:48.540
就可能会出现一些点的错误对吧

22:48.540 --> 22:49.540
我们来看一下这

22:49.540 --> 22:51.540
那再举个粒子啊

22:51.540 --> 22:52.540
拿数组过滤来举一个粒子

22:52.540 --> 22:53.540
在这一块呢

22:53.540 --> 22:55.540
我可以给你大概看一眼

22:55.540 --> 22:56.540
嗯

22:56.540 --> 22:57.540
好对

22:57.540 --> 22:58.540
我们这样的一个

23:02.010 --> 23:03.010
粒子啊

23:03.010 --> 23:04.010
在这呢

23:04.010 --> 23:06.010
比如说它是一个过滤的一个组件

23:06.010 --> 23:08.010
那这里蠻有一条一条的这样的人名

23:08.010 --> 23:10.010
比如说当我输一个王字的话

23:10.010 --> 23:12.010
我这样去显示一些

23:12.010 --> 23:14.010
具有王字的这样的姓名的一个人

23:14.010 --> 23:15.010
那么写一个王

23:15.010 --> 23:16.010
好写个王

23:16.010 --> 23:17.010
ok

23:17.010 --> 23:18.010
那你要知道一点啊

23:18.010 --> 23:19.010
这一条一条数据啊

23:19.010 --> 23:21.010
其实都应该是用一个

23:21.010 --> 23:23.010
都应该是用一个对象来描述的

23:23.010 --> 23:25.010
比如说这个对象呢

23:25.010 --> 23:27.010
有该这条数据的一个头像

23:27.010 --> 23:28.010
有名字

23:28.010 --> 23:29.010
有还有这样的一个姓名

23:29.010 --> 23:30.010
对吧

23:30.010 --> 23:31.010
或者说包括这个

23:31.010 --> 23:33.010
他的一个姓别啊

23:33.010 --> 23:34.010
ok

23:34.010 --> 23:36.010
那我说这样的话

23:36.010 --> 23:38.010
当我写一个王以后的话

23:38.010 --> 23:40.010
那我是不是要根据对吧

23:40.010 --> 23:41.010
这个

23:41.010 --> 23:43.010
你这个对象之中

23:43.010 --> 23:44.010
你这个名字

23:44.010 --> 23:46.010
是否包含我这个字符对吧

23:46.010 --> 23:47.010
来决定是否

23:47.010 --> 23:48.010
我来显示你

23:48.010 --> 23:49.010
当然呢

23:49.010 --> 23:50.010
这一条一条数据

23:50.010 --> 23:51.010
或者说这一条一条

23:51.010 --> 23:54.010
这个用对象来描述的

23:54.010 --> 23:56.010
对象来描述的他们对吧

23:56.010 --> 23:57.010
那这些对象呢

23:57.010 --> 23:58.010
都要放到这个数据之中

23:58.010 --> 23:59.010
那好了

23:59.010 --> 24:00.010
那比如说

24:00.010 --> 24:01.010
我在说一个王以后的话

24:01.010 --> 24:02.010
ok

24:02.010 --> 24:03.010
我要把这个数据之中

24:03.010 --> 24:04.010
一条一条对象

24:04.010 --> 24:05.010
全拿出来来看一看

24:05.010 --> 24:06.010
看一看哪

24:06.010 --> 24:07.010
哪个对象之中呢

24:07.010 --> 24:09.010
那里面是包含这个王的

24:09.010 --> 24:10.010
如果是包含的话

24:10.010 --> 24:11.010
就让你显示

24:11.010 --> 24:12.010
否则就不显示

24:12.010 --> 24:14.010
那如果是这样的一个操作的话

24:14.010 --> 24:15.010
好

24:15.010 --> 24:16.010
比如说数据之中一开始啊

24:16.010 --> 24:17.010
是有

24:17.010 --> 24:18.010
一二三四五个值

24:18.010 --> 24:19.010
那这个五个值

24:19.010 --> 24:20.010
传给你以后的话

24:20.010 --> 24:21.010
当你写一个王好了

24:21.010 --> 24:22.010
去过滤一下

24:22.010 --> 24:25.010
如果说直接你只留下来

24:25.010 --> 24:26.010
就是

24:26.010 --> 24:27.010
啊姓王那个人

24:27.010 --> 24:28.010
而且

24:28.010 --> 24:30.010
而把这个之前

24:30.010 --> 24:32.010
那些其实的补姓王的人

24:32.010 --> 24:33.010
去给删掉的话

24:33.010 --> 24:35.010
那你在回退到之前的时候

24:35.010 --> 24:36.010
其实你就回退不了了

24:36.010 --> 24:37.010
因为这个数据已经丢了

24:37.010 --> 24:38.010
对吧

24:38.010 --> 24:39.010
那好

24:39.010 --> 24:40.010
我们来做一个简单的一个测试啊

24:40.010 --> 24:43.010
这一边就有我所写的一个数据

24:43.010 --> 24:44.010
里面有五个这样的一个对象

24:44.010 --> 24:45.010
每个对象呢

24:45.010 --> 24:46.010
有内幕值

24:46.010 --> 24:47.010
有这个图片的一个路径

24:47.010 --> 24:48.010
有这样一个描述

24:48.010 --> 24:50.010
包括这样一个姓别

24:50.010 --> 24:51.010
但当然姓别呢

24:51.010 --> 24:52.010
我们是用不上的现在

24:52.010 --> 24:53.010
那比如说

24:53.010 --> 24:55.010
把他给你剪接到这个前面

24:55.010 --> 24:57.010
我们来做一个简单的测验

24:57.010 --> 24:58.010
好

24:58.010 --> 25:00.010
请你们有一个书框

25:00.010 --> 25:01.010
你把书框

25:01.010 --> 25:02.010
那我在这呢

25:02.010 --> 25:04.010
给你握上一个叫OMP

25:04.010 --> 25:06.010
通过document.gatch

25:06.010 --> 25:08.010
I'm in the band

25:08.010 --> 25:10.010
我去来获取一下这样的一个

25:10.010 --> 25:11.010
DOM

25:11.010 --> 25:12.010
那在这呢

25:12.010 --> 25:14.010
我写一个uncleink

25:14.010 --> 25:16.010
来一个function

25:16.010 --> 25:17.010
一个function

25:17.010 --> 25:19.010
那我在这去执行

25:19.010 --> 25:20.010
比如说我在这去输

25:20.010 --> 25:21.010
不是应该是uncleink

25:21.010 --> 25:22.010
应该是uncleink

25:22.010 --> 25:23.010
就是我在这呢

25:23.010 --> 25:24.010
去输一个字符的时候

25:24.010 --> 25:26.010
就会输发这样的一个函数

25:26.010 --> 25:27.010
对吧

25:27.010 --> 25:28.010
那比如说我写个功能

25:28.010 --> 25:29.010
这个功能呢

25:29.010 --> 25:33.010
叫做filter by test

25:33.010 --> 25:34.010
它叫做

25:34.010 --> 25:37.010
要根据你输的文本

25:37.010 --> 25:39.010
来进行这个数组的一个过滤

25:39.010 --> 25:40.010
那它假如可以接受

25:40.010 --> 25:41.010
不是假而无

25:41.010 --> 25:43.010
咱假定它可以接受两个参数

25:43.010 --> 25:44.010
一个是过滤的文本

25:44.010 --> 25:45.010
一个叫做

25:45.010 --> 25:47.010
所传的一个数组

25:47.010 --> 25:49.010
希望这函数最后进行完以后的话

25:49.010 --> 25:50.010
它能把这个

25:50.010 --> 25:51.010
就是

25:51.010 --> 25:52.010
它能把这个过滤之后的数组

25:52.010 --> 25:53.010
给它返回出来

25:53.010 --> 25:54.010
那当然

25:54.010 --> 25:55.010
如果不是按照一个

25:55.010 --> 25:57.010
纯函数的方式来执行的话

25:57.010 --> 25:58.010
我们可以这么做

25:58.010 --> 26:01.010
filter by test

26:01.010 --> 26:02.010
好我往里面去传一下

26:02.010 --> 26:03.010
this is the value

26:03.010 --> 26:05.010
这个是你所输入的这样的一个字

26:05.010 --> 26:07.010
那我再传一个percent range

26:07.010 --> 26:08.010
好

26:08.010 --> 26:09.010
那如果是这样的情况下的话

26:09.010 --> 26:10.010
让它进行这样的一个

26:10.010 --> 26:12.010
根据文本来进行过滤

26:12.010 --> 26:13.010
好了比如说

26:13.010 --> 26:15.010
我把这个rr给它便利一遍

26:15.010 --> 26:16.010
便利完一遍呢

26:16.010 --> 26:17.010
如果说

26:17.010 --> 26:18.010
不满足这样的一个

26:18.010 --> 26:19.010
test需求的情况下的话

26:19.010 --> 26:20.010
我就把这个数组的

26:20.010 --> 26:22.010
元素通过splash

26:22.010 --> 26:23.010
给它清理掉

26:23.010 --> 26:24.010
给它删除掉

26:24.010 --> 26:26.010
那好了

26:26.010 --> 26:27.010
那删除掉的情况下的话

26:27.010 --> 26:29.010
那比如说我真正输入的一个网

26:29.010 --> 26:31.010
它把三个其余的性流的

26:31.010 --> 26:32.010
全部给的

26:32.010 --> 26:33.010
就是

26:33.010 --> 26:34.010
它把这个其余三个

26:34.010 --> 26:35.010
不性网的

26:35.010 --> 26:36.010
全给它清掉了

26:36.010 --> 26:37.010
清掉以后的话

26:37.010 --> 26:38.010
好了

26:38.010 --> 26:39.010
那你要知道

26:39.010 --> 26:40.010
它对外界的这个数组

26:40.010 --> 26:42.010
percent range

26:42.010 --> 26:43.010
是不是

26:43.010 --> 26:45.010
做了一个删除性的操作

26:45.010 --> 26:46.010
对吧

26:46.010 --> 26:47.010
它以前有五个值

26:47.010 --> 26:48.010
现在是只有两个值

26:48.010 --> 26:49.010
而且并且这两个值

26:49.010 --> 26:50.010
它只性网了

26:50.010 --> 26:51.010
那OK

26:51.010 --> 26:52.010
那我们再回对到以前的时候的话

26:52.010 --> 26:53.010
那

26:53.010 --> 26:54.010
由于这个值

26:54.010 --> 26:55.010
已经被你杀掉了

26:55.010 --> 26:56.010
那你回对到以前的话

26:56.010 --> 26:58.010
它也不能把这个五个值

26:58.010 --> 26:59.010
全部都显现出来了

26:59.010 --> 27:00.010
好

27:00.010 --> 27:01.010
那这个时候就会很麻烦

27:01.010 --> 27:02.010
由于你这个函数

27:02.010 --> 27:03.010
不是一个纯函数

27:03.010 --> 27:04.010
对吧

27:04.010 --> 27:05.010
对外界这个整体的数据

27:05.010 --> 27:06.010
造成了这种

27:06.010 --> 27:07.010
很不好的影

27:07.010 --> 27:08.010
很不好的影响

27:08.010 --> 27:10.010
保持整个长距

27:10.010 --> 27:12.010
没有像我们预料道的这样一个

27:12.010 --> 27:13.010
执行

27:13.010 --> 27:14.010
没有像我们这个

27:14.010 --> 27:16.010
没有让我们

27:16.010 --> 27:17.010
让它

27:17.010 --> 27:18.010
就是通过我们预料的

27:18.010 --> 27:20.010
这样的情况去执行

27:20.010 --> 27:21.010
那这样的话

27:21.010 --> 27:22.010
往往呢

27:22.010 --> 27:23.010
会出现很多很多这个错误

27:23.010 --> 27:25.010
那这是只是一个小的

27:25.010 --> 27:26.010
例子小的一个demo

27:26.010 --> 27:28.010
如果放到更大的英雄之中的话

27:28.010 --> 27:29.010
你会经常会发现

27:29.010 --> 27:30.010
这样的一种

27:30.010 --> 27:32.010
函数对权力变量有影响

27:32.010 --> 27:34.010
或者对权力的数据

27:34.010 --> 27:35.010
有影响

27:35.010 --> 27:36.010
一样完以后的话

27:36.010 --> 27:37.010
好了

27:37.010 --> 27:38.010
那整个这样的长距

27:38.010 --> 27:39.010
可能会导致各种各样的错误

27:39.010 --> 27:40.010
那怎么能保证

27:40.010 --> 27:41.010
或者怎么能预防

27:41.010 --> 27:43.010
这样的一个bug的出现呢

27:43.010 --> 27:44.010
那我就只需要让你

27:44.010 --> 27:45.010
砍售变成一个传寒数

27:45.010 --> 27:46.010
对不对

27:46.010 --> 27:47.010
那如果说它是个传寒数的话

27:47.010 --> 27:48.010
我怎么办呢

27:48.010 --> 27:49.010
首先我们要知道

27:49.010 --> 27:50.010
我用它的之后

27:50.010 --> 27:52.010
用的那个是一个反围值对不对

27:52.010 --> 27:53.010
那在这的话

27:53.010 --> 27:55.010
它反围的必须是一个数组

27:55.010 --> 27:56.010
那我首先我一个数组

27:56.010 --> 27:57.010
叫nullary

27:57.010 --> 27:58.010
接着你传的

27:58.010 --> 27:59.010
是一个权力数组的话

27:59.010 --> 28:00.010
好了

28:00.010 --> 28:01.010
那我可以怎么办呢

28:01.010 --> 28:02.010
我也可以这么做

28:02.010 --> 28:05.010
反围一个nullary

28:05.010 --> 28:07.010
我可以把你这个数组

28:07.010 --> 28:08.010
给你循环一下

28:08.010 --> 28:09.010
我只是循环查看你

28:09.010 --> 28:10.010
而不对你进行

28:10.010 --> 28:11.010
任何一个操作

28:11.010 --> 28:12.010
也不进行

28:12.010 --> 28:13.010
也就是我不对你进行

28:13.010 --> 28:15.010
这样一个山族性的一个操作

28:15.010 --> 28:16.010
那我问一个i等于0

28:16.010 --> 28:19.010
那i去小于这个ARR.lans

28:19.010 --> 28:20.010
好了

28:20.010 --> 28:21.010
那i加加

28:21.010 --> 28:22.010
那如果是i加加的话

28:22.010 --> 28:24.010
现在我用的nullary

28:24.010 --> 28:26.010
我让它等于什么呢

28:26.010 --> 28:29.010
等于ARR中符合条件的一些值

28:29.010 --> 28:31.010
那哪些值是符合条件呢

28:31.010 --> 28:32.010
我在这里面做个判断

28:32.010 --> 28:34.010
我把ARR里面的对象

28:34.010 --> 28:35.010
每个对象都拿出来

28:35.010 --> 28:37.010
去看一下你的内幕

28:37.010 --> 28:38.010
你的内幕中呢

28:38.010 --> 28:41.010
是否包含对吧

28:41.010 --> 28:44.010
如果它不包含的话

28:44.010 --> 28:45.010
这样

28:45.010 --> 28:47.010
就是如果它不包含的话

28:47.010 --> 28:48.010
我需要怎么样

28:48.010 --> 28:50.010
我需要把这个值

28:50.010 --> 28:52.010
它给的就是

28:52.010 --> 28:54.010
这个如果它包含的话

28:54.010 --> 28:55.010
对吧

28:55.010 --> 28:56.010
就是如果它包含

28:56.010 --> 28:57.010
那也就是它不等于负义

28:57.010 --> 28:58.010
对吧

28:58.010 --> 28:59.010
好

28:59.010 --> 29:00.010
如果说你包含的话

29:00.010 --> 29:01.010
你只能是能在这个

29:01.010 --> 29:02.010
主的这个字幕串里面

29:02.010 --> 29:03.010
这个内幕里面

29:03.010 --> 29:04.010
去找到

29:04.010 --> 29:05.010
而这中间是个

29:05.010 --> 29:06.010
字幕串太小

29:06.010 --> 29:07.010
应该是个变量

29:07.010 --> 29:09.010
但是通过这样的

29:09.010 --> 29:10.010
的话

29:10.010 --> 29:12.010
如果在内幕这个字幕串中

29:12.010 --> 29:13.010
去找到

29:13.010 --> 29:14.010
包含你这样的字幕串的话

29:14.010 --> 29:15.010
它必然能返回一个

29:15.010 --> 29:16.010
非0的一个值

29:16.010 --> 29:18.010
返回一个非负义的一个值

29:18.010 --> 29:20.010
至少是0以上的一个值

29:20.010 --> 29:21.010
那如果说

29:21.010 --> 29:22.010
你不等于负义的话

29:22.010 --> 29:23.010
我们就证明对吧

29:23.010 --> 29:24.010
确实是包含的

29:24.010 --> 29:25.010
你包含的话

29:25.010 --> 29:26.010
我就在这

29:26.010 --> 29:27.010
我就把这个值

29:27.010 --> 29:28.010
直接给你

29:28.010 --> 29:29.010
扣持一下

29:29.010 --> 29:31.010
给你往里面去放一下

29:31.010 --> 29:32.010
哎呀

29:32.010 --> 29:33.010
哎

29:33.010 --> 29:34.010
当然否则的话

29:34.010 --> 29:35.010
我就什么都不干

29:35.010 --> 29:36.010
对不对

29:36.010 --> 29:37.010
那最后咱可以来看一下

29:37.010 --> 29:40.010
我去输出一下它的反轨值

29:40.010 --> 29:41.010
好

29:41.010 --> 29:42.010
包含一次

29:42.010 --> 29:44.580
咱刷新一次

29:44.580 --> 29:45.580
看一眼

29:45.580 --> 29:46.580
在这

29:46.580 --> 29:47.580
好

29:47.580 --> 29:48.580
这里面报来个错

29:48.580 --> 29:49.580
第14行叫

29:49.580 --> 29:50.580
on input

29:50.580 --> 29:53.580
on input

29:53.580 --> 29:54.580
on input

29:54.580 --> 29:55.580
on input

29:55.580 --> 29:57.580
这应该是IP

29:57.580 --> 29:58.580
IP

29:58.580 --> 29:59.580
不是IP

29:59.580 --> 30:00.580
好

30:00.580 --> 30:01.580
刷新一次

30:01.580 --> 30:02.580
看一眼

30:02.580 --> 30:03.580
当我去写一个

30:03.580 --> 30:04.580
流的时候

30:04.580 --> 30:05.580
好

30:05.580 --> 30:06.580
现在是不是

30:06.580 --> 30:07.580
在这一行

30:07.580 --> 30:08.580
一个三个性流的

30:08.580 --> 30:10.580
是不是全都给他

30:10.580 --> 30:11.580
弄出来吧

30:11.580 --> 30:12.580
对不对

30:12.580 --> 30:13.580
ok

30:13.580 --> 30:14.580
那这样

30:14.580 --> 30:15.580
当我

30:15.580 --> 30:16.580
再回退

30:16.580 --> 30:18.580
我再写一个王的时候

30:18.580 --> 30:19.580
是不是

30:19.580 --> 30:21.580
又有两个值了

30:21.580 --> 30:22.580
对吧

30:22.580 --> 30:23.580
这两个都是新王的

30:23.580 --> 30:24.580
也就是说

30:24.580 --> 30:25.580
我现在保证了

30:25.580 --> 30:27.580
这个函数的纯度以后破的话

30:27.580 --> 30:28.580
我想回退到

30:28.580 --> 30:29.580
一开始的状态

30:29.580 --> 30:31.580
再重新过滤的话

30:31.580 --> 30:32.580
它依旧可以满足

30:32.580 --> 30:33.580
这样的一种情况

30:33.580 --> 30:35.580
否则你

30:35.580 --> 30:36.580
它如果不是出来说的话

30:36.580 --> 30:38.580
你就没有办法进行这种回退

30:38.580 --> 30:39.580
再重新来过滤了

30:39.580 --> 30:40.580
那

30:40.580 --> 30:41.580
我要回到这一点

30:41.580 --> 30:42.580
这个数据

30:42.580 --> 30:43.580
等你返回以后的话

30:43.580 --> 30:44.580
你在后面可能进行

30:44.580 --> 30:45.580
对这个数据的渲染

30:45.580 --> 30:46.580
会对这个数据

30:46.580 --> 30:47.580
额外的一些操作

30:47.580 --> 30:48.580
那操作的时候

30:48.580 --> 30:49.580
我也希望你

30:49.580 --> 30:50.580
其他的函数

30:50.580 --> 30:51.580
也尽量主持函数

30:51.580 --> 30:52.580
或者说

30:52.580 --> 30:53.580
你在操作这个对象的时候

30:53.580 --> 30:54.580
你对这个对象

30:54.580 --> 30:55.580
有修改的话

30:55.580 --> 30:56.580
好了

30:56.580 --> 30:57.580
我更希望你

30:57.580 --> 30:58.580
把这个

30:58.580 --> 30:59.580
这个纸

30:59.580 --> 31:00.580
再付给它的时候

31:00.580 --> 31:01.580
还是通过一个

31:01.580 --> 31:02.580
你得不可动

31:03.580 --> 31:05.580
我给你可动一个新版本

31:05.580 --> 31:06.580
对吧

31:06.580 --> 31:07.580
一模一样的新版本

31:07.580 --> 31:08.580
那之后的话

31:08.580 --> 31:09.580
你把这个纸

31:09.580 --> 31:10.580
有时候给了妞儿蕊以后

31:10.580 --> 31:11.580
好

31:11.580 --> 31:13.580
妞儿蕊再进行

31:13.580 --> 31:14.580
一个修改的话

31:14.580 --> 31:15.580
或者说是妞儿蕊

31:15.580 --> 31:16.580
再进行对里面

31:16.580 --> 31:18.580
对象的一个修改的话

31:18.580 --> 31:20.580
其实都是没问题的了

31:20.580 --> 31:21.580
它都不会影响到

31:21.580 --> 31:23.580
这个圆形的这样的一个纸

31:23.580 --> 31:25.580
OK

31:25.580 --> 31:26.580
也就是说

31:26.580 --> 31:27.580
现在我们大概能看得出来

31:27.580 --> 31:28.580
对吧

31:28.580 --> 31:29.580
这个存产数

31:29.580 --> 31:30.580
还是很有用的

31:30.580 --> 31:31.580
当然

31:31.580 --> 31:32.580
它一个更大的威力

31:32.580 --> 31:33.580
其实是用在

31:33.580 --> 31:35.580
我们这样的一个高级框架之中

31:35.580 --> 31:36.580
就比如说

31:36.580 --> 31:37.580
VoE也好

31:37.580 --> 31:38.580
或者说比如说

31:38.580 --> 31:39.580
Rat也好

31:39.580 --> 31:40.580
我们后续

31:40.580 --> 31:41.580
在接近班之中

31:41.580 --> 31:42.580
会学这样一个

31:42.580 --> 31:43.580
组织化开发

31:43.580 --> 31:44.580
但是其实组织化开发

31:44.580 --> 31:46.580
你光学怎么去用

31:46.580 --> 31:47.580
怎么用VoE

31:47.580 --> 31:48.580
怎么用那些

31:48.580 --> 31:49.580
怎么Router

31:49.580 --> 31:50.580
怎么用VoE X

31:50.580 --> 31:51.580
对吧

31:51.580 --> 31:52.580
光怎么去用的话

31:52.580 --> 31:53.580
这个还不是

31:53.580 --> 31:54.580
怎么说呢

31:54.580 --> 31:55.580
你不算是

31:55.580 --> 31:56.580
能变成你这样的

31:56.580 --> 31:57.580
高级工收师

31:57.580 --> 31:58.580
或者说

31:58.580 --> 31:59.580
你很难拿到这样一个

31:59.580 --> 32:00.580
很高的一个先知

32:00.580 --> 32:01.580
重在是你了解这种

32:01.580 --> 32:02.580
组织化的思想

32:02.580 --> 32:03.580
整个这样的框架的

32:03.580 --> 32:04.580
设计理念

32:04.580 --> 32:05.580
和管理数据的

32:05.580 --> 32:06.580
这样的理念

32:06.580 --> 32:07.580
那咱们看一下

32:07.580 --> 32:08.580
比如说

32:08.580 --> 32:10.580
我们按组织化的开发方式

32:10.580 --> 32:11.580
开发一个页面

32:11.580 --> 32:12.580
这个页面我可以给你看成

32:12.580 --> 32:13.580
是个大的几个组件

32:13.580 --> 32:14.580
一个容器

32:14.580 --> 32:16.580
我们真正在今天开发的时候

32:16.580 --> 32:18.580
无非是往一个大的容器

32:18.580 --> 32:20.580
去放各种各样的组件

32:20.580 --> 32:21.580
而且组建和组织之中

32:21.580 --> 32:22.580
是形成这种

32:22.580 --> 32:23.580
父子关系的

32:23.580 --> 32:24.580
比如说

32:24.580 --> 32:25.580
整个页面里面

32:25.580 --> 32:26.580
就有两个大的组件

32:26.580 --> 32:27.580
一个是它

32:27.580 --> 32:28.580
OK

32:28.580 --> 32:29.580
那它下面

32:29.580 --> 32:30.580
分别有这个组件

32:30.580 --> 32:31.580
还有这个组件

32:31.580 --> 32:32.580
那它们

32:32.580 --> 32:33.580
你会发现

32:33.580 --> 32:34.580
每个组件下面

32:34.580 --> 32:35.580
还有一些组件

32:35.580 --> 32:36.580
那这种情况下的话

32:36.580 --> 32:37.580
你会发现整个页面

32:37.580 --> 32:38.580
形成了一个很复杂的

32:38.580 --> 32:40.580
一个垂直性的一个关系

32:40.580 --> 32:41.580
那好了

32:41.580 --> 32:42.580
那你要知道一点

32:42.580 --> 32:43.580
每个组件

32:43.580 --> 32:44.580
其实它都可以

32:44.580 --> 32:46.580
接受一些行为

32:46.580 --> 32:47.580
当用户

32:47.580 --> 32:49.580
得到一些操作的时候

32:49.580 --> 32:50.580
行为发生到

32:50.580 --> 32:51.580
它身上以后的话

32:51.580 --> 32:52.580
它可能会改变

32:52.580 --> 32:54.580
它一些这样的一些状态

32:54.580 --> 32:55.580
那这个状态

32:55.580 --> 32:56.580
改变完以后的话

32:56.580 --> 32:57.580
一可能会影响到

32:57.580 --> 32:58.580
到自己

32:58.580 --> 32:59.580
二可能影响到

32:59.580 --> 33:00.580
它这个子组件

33:00.580 --> 33:01.580
那也就是说

33:01.580 --> 33:02.580
在我们这种

33:02.580 --> 33:03.580
组件化开发之中

33:03.580 --> 33:04.580
状态更小

33:04.580 --> 33:05.580
是一个很常见的

33:05.580 --> 33:07.580
一种常态

33:07.580 --> 33:08.580
那咱就比如说

33:08.580 --> 33:10.580
它身上有一些状态

33:10.580 --> 33:11.580
或者有一些数据

33:11.580 --> 33:13.580
是它和它

33:13.580 --> 33:15.580
所需要的

33:15.580 --> 33:16.580
OK

33:16.580 --> 33:17.580
那比如说

33:19.580 --> 33:20.580
它和它所需要的

33:20.580 --> 33:21.580
什么意思呢

33:21.580 --> 33:22.580
就一种是依赖

33:22.580 --> 33:23.580
一种的是

33:23.580 --> 33:24.580
我可以把它只拿过来

33:24.580 --> 33:25.580
给它进行这样的

33:25.580 --> 33:26.580
给它进行这样的一次修改

33:26.580 --> 33:27.580
那比如说

33:27.580 --> 33:28.580
这个组件

33:28.580 --> 33:29.580
和这个组件

33:29.580 --> 33:30.580
OK

33:30.580 --> 33:32.580
它下面还有两个子组件

33:32.580 --> 33:34.580
它有一个这样的一个子组件

33:34.580 --> 33:35.580
那比如说

33:35.580 --> 33:36.580
这个组件的

33:36.580 --> 33:37.580
下面这两个组件

33:37.580 --> 33:38.580
同时

33:38.580 --> 33:39.580
怎么样

33:39.580 --> 33:41.580
可以去修改它的一个状态

33:41.580 --> 33:43.580
也可以去修改它的一个状态

33:43.580 --> 33:44.580
那它呢

33:44.580 --> 33:45.580
它也可以修改它的一个状态

33:45.580 --> 33:47.580
那如果是这样的情况下的

33:47.580 --> 33:48.580
你会发现

33:48.580 --> 33:50.580
如果我一旦它出了错以后

33:50.580 --> 33:51.580
OK

33:51.580 --> 33:52.580
那它的

33:52.580 --> 33:53.580
这展示

33:53.580 --> 33:54.580
可能需要

33:54.580 --> 33:56.580
它的数据的一个传递

33:56.580 --> 33:57.580
那它和它呢

33:57.580 --> 33:58.580
都可能通过

33:58.580 --> 34:00.580
一种直接和渐渐的方式

34:00.580 --> 34:01.580
来改变它的这样的一个数据

34:01.580 --> 34:02.580
或改变它的这样的一个状态

34:02.580 --> 34:03.580
那它和它呢

34:03.580 --> 34:04.580
依旧可以改变

34:04.580 --> 34:05.580
它的这样的一个状态状态

34:05.580 --> 34:07.580
那如果当它出错的时候

34:07.580 --> 34:09.580
按照我们刚才所描述的

34:09.580 --> 34:11.580
谁都可以去影响到它对不对

34:11.580 --> 34:12.580
那好了

34:12.580 --> 34:13.580
那你调Bug的时候

34:13.580 --> 34:14.580
请问你找谁

34:14.580 --> 34:15.580
你调谁对吧

34:15.580 --> 34:16.580
你是看它

34:16.580 --> 34:17.580
还是看它

34:17.580 --> 34:18.580
还是看它

34:18.580 --> 34:19.580
还是来看它对吧

34:19.580 --> 34:20.580
很麻烦

34:20.580 --> 34:21.580
要说你很难去调

34:21.580 --> 34:22.580
所以说呢

34:22.580 --> 34:23.580
我们在进行这种

34:23.580 --> 34:24.580
这种组件化开发的时候

34:24.580 --> 34:25.580
就能让这种

34:25.580 --> 34:26.580
对状态的一种修改

34:26.580 --> 34:27.580
或者说

34:27.580 --> 34:29.580
在这种状态的一种

34:29.580 --> 34:30.580
互相的一个依赖

34:30.580 --> 34:31.580
或者这样的影响呢

34:31.580 --> 34:33.580
尽量变强是那种

34:33.580 --> 34:35.580
就是不可修改的

34:35.580 --> 34:36.580
或者说

34:36.580 --> 34:37.580
叫做

34:37.580 --> 34:39.580
让这种处理状态的一种函数呢

34:39.580 --> 34:40.580
让它是一个传函数

34:40.580 --> 34:41.580
也就是说

34:41.580 --> 34:42.580
我不去影响你的状态

34:42.580 --> 34:43.580
我只能拿来

34:43.580 --> 34:44.580
去给它加工

34:44.580 --> 34:46.580
将重来使用你

34:46.580 --> 34:47.580
而不进行对你这样的

34:47.580 --> 34:49.580
一个真正的一个修改

34:49.580 --> 34:50.580
我只要你一个克隆的一个版本

34:50.580 --> 34:51.580
对克隆的版本

34:51.580 --> 34:52.580
在它既有之上的

34:52.580 --> 34:53.580
进行加工修改

34:53.580 --> 34:54.580
我再去修改它

34:54.580 --> 34:55.580
那这样的话

34:55.580 --> 34:56.580
如果说

34:56.580 --> 34:58.580
它对它的一个数据修改的话

34:58.580 --> 34:59.580
其实呢

34:59.580 --> 35:01.580
是一个传函数据的一种方式

35:01.580 --> 35:02.580
我只是把那个状态

35:02.580 --> 35:03.580
拿过来对吧

35:03.580 --> 35:04.580
修改一下

35:04.580 --> 35:06.580
一个克隆版的一个状态

35:06.580 --> 35:07.580
那它也是这样的话

35:07.580 --> 35:08.580
那OK

35:08.580 --> 35:09.580
那也就是说

35:09.580 --> 35:10.580
它对它本质上

35:10.580 --> 35:11.580
不会对它有用的状态

35:11.580 --> 35:13.580
发生这样的一个影响

35:13.580 --> 35:14.580
那它呢

35:14.580 --> 35:16.580
在依赖它的状态的时候

35:16.580 --> 35:17.580
也只是去拿一个

35:17.580 --> 35:19.580
克隆的一个版本

35:19.580 --> 35:20.580
那它俩呢

35:20.580 --> 35:22.580
再去修改它的一个状态的时候呢

35:22.580 --> 35:24.580
也是克隆的一个版本出来之后呢

35:24.580 --> 35:26.580
再去修改这样的一个

35:26.580 --> 35:28.580
它自己克隆后的这样的一个状态

35:28.580 --> 35:30.580
那有时候当它出错的时候呢

35:30.580 --> 35:32.580
那有时候当它之中出错的时候

35:32.580 --> 35:34.580
其实我们可以直接定位到了

35:34.580 --> 35:35.580
对不对

35:35.580 --> 35:36.580
他们他们他们他们

35:36.580 --> 35:38.580
真不得不会对它产生一些影响

35:38.580 --> 35:40.580
那有时候它出错的话

35:40.580 --> 35:41.580
只有可能是

35:41.580 --> 35:42.580
它自己有问题

35:42.580 --> 35:43.580
或者说是它的上部分

35:43.580 --> 35:44.580
它有问题

35:44.580 --> 35:45.580
这样的话就

35:45.580 --> 35:47.580
让你整个的

35:47.580 --> 35:49.580
这样的一个组建化的一个开发

35:49.580 --> 35:51.580
它的一些错误的信息

35:51.580 --> 35:52.580
变成可预测了

35:52.580 --> 35:54.580
那我们再进行这样的一个

35:54.580 --> 35:56.580
开发或进行一个项目

35:56.580 --> 35:57.580
叠带的时候

35:57.580 --> 35:59.580
效率就会变得很高

35:59.580 --> 36:00.580
OK 那就说

36:00.580 --> 36:01.580
这种传说

36:01.580 --> 36:03.580
它的更高端的一个用处呢

36:03.580 --> 36:04.580
就是它可以更好的去管理

36:04.580 --> 36:05.580
状态

36:05.580 --> 36:07.580
使得可预测性变得增强

36:07.580 --> 36:08.580
降低了整个代码

36:08.580 --> 36:10.580
整个项目的一个管理

36:10.580 --> 36:11.580
和维护的一个难度

36:11.580 --> 36:12.580
所以说呢

36:12.580 --> 36:13.580
我们前端基本上

36:13.580 --> 36:15.580
都是在跟这个副作用

36:15.580 --> 36:16.580
去打交道

36:16.580 --> 36:17.580
我们也希望

36:17.580 --> 36:19.580
尽量的去使用这个传说

36:19.580 --> 36:20.580
但是

36:20.580 --> 36:21.580
并不是所有情况下

36:21.580 --> 36:23.580
都是能使用传说的

36:23.580 --> 36:24.580
因为传说的这样的使用

36:24.580 --> 36:26.580
往往有的时候是可预

36:26.580 --> 36:27.580
而不可求的

36:27.580 --> 36:28.580
OK

36:28.580 --> 36:29.580
那如果说

36:29.580 --> 36:30.580
你讲对传说

36:30.580 --> 36:31.580
有个真正的了解

36:31.580 --> 36:33.580
有个真正这样的应用的话

36:33.580 --> 36:34.580
你可以去关注

36:34.580 --> 36:35.580
我们一下

36:35.580 --> 36:36.580
今天办的一个课程

36:36.580 --> 36:37.580
在那里面呢

36:37.580 --> 36:39.580
我们会十大时的

36:39.580 --> 36:40.580
用一个大型的项目

36:40.580 --> 36:41.580
来教你传说

36:41.580 --> 36:43.580
一个真正的一个好处

36:43.580 --> 36:44.580
OK

36:44.580 --> 36:45.580
那这期课呢

36:45.580 --> 36:46.580
先讲到这里

36:46.580 --> 36:47.580
如果说你想

36:47.580 --> 36:48.580
对后期的问题

36:48.580 --> 36:49.580
有一些疑问

36:49.580 --> 36:50.580
或者对课程

36:50.580 --> 36:51.580
有一些疑问的话

36:51.580 --> 36:52.580
你可以去

36:52.580 --> 36:53.580
接下我们的小度

36:53.580 --> 36:54.580
让小度去带你进这个群

36:54.580 --> 36:55.580
那我们这个

36:55.580 --> 36:56.580
向上的工艺群呢

36:56.580 --> 36:58.580
已经有很多期了

36:58.580 --> 36:59.580
很多同学都在里面

36:59.580 --> 37:00.580
去讨论各种各样的

37:00.580 --> 37:01.580
一个支出问题

37:01.580 --> 37:02.580
如果说

37:02.580 --> 37:03.580
你有些工作的问题

37:03.580 --> 37:04.580
或学习中的一些问题的话

37:04.580 --> 37:05.580
都可以往里面

37:05.580 --> 37:06.580
进行提问

37:06.580 --> 37:07.580
我们的老师

37:07.580 --> 37:08.580
会24小时

37:08.580 --> 37:09.580
工艺性的

37:09.580 --> 37:10.580
跟你们去回答

37:10.580 --> 37:11.580
这样的一些

37:11.580 --> 37:12.580
难的一些问题

37:12.580 --> 37:13.580
OK

37:13.580 --> 37:14.580
那我们今天就到这吧

37:14.580 --> 37:15.580
拜拜

