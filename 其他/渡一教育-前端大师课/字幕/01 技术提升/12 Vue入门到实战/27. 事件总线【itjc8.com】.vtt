WEBVTT

00:00.300 --> 00:02.860
咱们来看一下这个文章详情页

00:03.380 --> 00:07.980
完成了吗 大体上完成了 但是呢还有一些细节需要我们处理

00:08.500 --> 00:09.260
比方说

00:09.780 --> 00:13.620
我左边这个区域啊 它的滚动条有个滚动 对吧

00:13.860 --> 00:16.940
这滚动条啊 它滚动的位置呢

00:18.220 --> 00:21.800
它可能会影响到右边这个区域的

00:22.060 --> 00:24.100
这个激活样式

00:24.620 --> 00:27.180
有可能滚动到这个位置 它这个地方应该激活

00:27.440 --> 00:28.200
有个样式

00:28.720 --> 00:29.220
对不对

00:29.900 --> 00:30.240
哎

00:30.500 --> 00:34.600
这个滚动条的位置呢 它还会影响到下边

00:34.860 --> 00:35.880
加载更多

00:36.140 --> 00:39.980
到滚到底的时候呢 这边要一个加载中的效果 要加载更多的

00:40.240 --> 00:41.760
评论数据

00:42.540 --> 00:44.840
那么这个问题怎么来处理

00:45.340 --> 00:47.400
首先咱们来分析一下这个

00:47.660 --> 00:49.700
滚动条是属于哪个组件的

00:49.960 --> 00:52.520
我们整个组件结构呢 就像我们之前

00:52.780 --> 00:53.540
安排的啊

00:54.300 --> 00:56.100
有这么一个detail组件

00:56.360 --> 00:57.900
就是文章详情页的组件

00:58.360 --> 00:59.640
这个组件呢 有一些纸组件

00:59.900 --> 01:00.920
有哪些纸组件呢

01:01.680 --> 01:05.020
由我们左边两个组件 左边呢是一个文章详情

01:05.280 --> 01:06.300
block detail

01:06.560 --> 01:08.360
它主要是显示文章标题

01:08.600 --> 01:10.140
以及文章的一些附加信息

01:10.400 --> 01:11.420
以及文章的证文

01:12.440 --> 01:16.020
然后左边呢 下边呢 还有一个组件啊 就是我们的评论组件

01:16.280 --> 01:17.820
我们把它叫做block comment

01:18.840 --> 01:20.640
就这个区域 评论组件

01:21.660 --> 01:25.760
然后还有什么组件呢 还有左边 还有右边这个组件

01:26.260 --> 01:31.080
右边这个组件呢 我们把它叫做block toc

01:31.340 --> 01:33.140
对不对 是不是有这么一个组件

01:34.160 --> 01:35.700
那么咱们来研究一下

01:36.460 --> 01:38.260
滚动条在哪个组件呢

01:38.760 --> 01:40.060
滚动条在这个组件

01:41.340 --> 01:43.120
好 那么这个滚动条的组件呢

01:43.380 --> 01:45.940
我们把记住一下啊 滚动条在这个组件

01:46.700 --> 01:48.500
然后block toc

01:49.520 --> 01:51.820
这个是我们的目录组件

01:52.080 --> 01:54.120
目录组件是不是要读取滚动条的位置

01:54.540 --> 01:55.980
就这边滚动的时候啊

01:56.740 --> 02:01.260
那么我们toc这个组件呢 要知道滚动条滚动到哪儿了

02:01.940 --> 02:06.260
对不对 那么这里呢 要获取滚动条

02:06.620 --> 02:07.780
就是要监听滚动

02:09.700 --> 02:13.260
滚动到一定位置的时候呢 它这里有个激活样式

02:13.500 --> 02:16.340
要调处理 所以说它这里本质上一定要能够监听滚动

02:16.460 --> 02:19.660
我们先不说监听的滚动过后要干嘛

02:19.980 --> 02:21.620
那肯定得监听 对不对

02:22.600 --> 02:25.120
好 然后这边这个block comment

02:25.360 --> 02:28.720
这个评论组件 是不是也得监听滚动啊

02:29.240 --> 02:30.280
监听滚动

02:31.040 --> 02:33.080
好 咱们还说一下这个问题了啊

02:33.800 --> 02:36.120
这个问题呢 在哪儿呢 其实

02:36.360 --> 02:37.680
看上去呢 也很简单

02:38.680 --> 02:40.000
副组件在滚动

02:41.280 --> 02:43.960
副组件里边哪个在滚动 你看一下啊 咱们

02:44.200 --> 02:45.080
把那个打开

02:49.390 --> 02:51.430
副组件是哪个在滚动啊

02:51.950 --> 02:52.910
detail里边

02:53.650 --> 02:54.450
是不是这个地方

02:54.710 --> 02:55.730
make container

02:55.970 --> 02:57.010
是不是它在滚动啊

02:57.250 --> 03:00.090
那么它滚动的时候 只有副组件才知道

03:00.850 --> 03:04.170
那么现在呢 就涉及到一个东西 就是复制组件通信

03:04.930 --> 03:06.490
复制组件怎么通信呢

03:06.730 --> 03:08.770
咱们之前学过那个组件通信啊

03:09.290 --> 03:10.330
回归一下啊

03:13.550 --> 03:16.110
慢慢来说一下 这些可能东西啊 到底要讲啥

03:16.870 --> 03:20.710
我们之前呢 说到那个组件通信 有很多种通信方式

03:21.230 --> 03:22.750
复制组件通信

03:23.030 --> 03:23.790
可以用什么呀

03:24.030 --> 03:24.810
是不是可以用prob

03:25.570 --> 03:31.470
属性传递 属性是从副组件传递到执著件的 所以说呢 这里其中一种方案

03:31.730 --> 03:34.030
什么方案呢 就是非常简单的 就我们之前学过的

03:34.550 --> 03:37.110
我们在detail这个组件里边呢 定一个数据

03:37.610 --> 03:39.910
我们这个组件里边是不是可以监听滚动条

03:40.430 --> 03:44.270
对吧 我们就简单的写一下这个格式啊 我也不把它写完

03:44.530 --> 03:47.590
就说我们这里呢 可以在副组件里边 给一个数据

03:48.870 --> 03:49.630
data

03:50.410 --> 03:51.190
给个数据

03:51.690 --> 03:55.270
数据呢 其中一个数据要是我scrawtop吧

03:55.830 --> 03:56.870
一开始是0吗

03:57.630 --> 04:02.510
然后呢 我们在这个组件里边是不是可以监听这个东西 监听这个DIV的滚动 怎么监听呢

04:02.750 --> 04:03.510
是不是可以用这个

04:03.770 --> 04:04.550
用个rips

04:04.790 --> 04:07.350
DIV container吧 我去个例子啊

04:07.610 --> 04:09.390
然后呢 我们在这里created

04:09.910 --> 04:11.950
一开始的时候呢 我们去监听一下啊

04:12.470 --> 04:13.510
this rips

04:14.790 --> 04:16.070
打开写下一个代码格式

04:16.310 --> 04:17.350
DIV

04:17.850 --> 04:18.630
container

04:19.630 --> 04:20.410
就这个玩意儿

04:20.670 --> 04:22.710
然后呢 是不是可以adv event listener

04:22.970 --> 04:24.250
监听了吗scrawl

04:24.710 --> 04:25.750
滚动事件

04:27.010 --> 04:30.350
当他滚动的时候 我干嘛呀 我是不是把那个

04:30.610 --> 04:31.370
呃

04:31.630 --> 04:32.910
滚动的位置

04:33.170 --> 04:34.950
就是this rips

04:35.470 --> 04:36.230
DIV

04:36.490 --> 04:38.030
scrawl top

04:38.790 --> 04:39.110
把它

04:39.370 --> 04:40.070
复制给谁呢

04:40.330 --> 04:40.830
this

04:41.610 --> 04:42.630
scrawl top

04:43.150 --> 04:44.670
对不对 是不是可以这样的复制

04:45.190 --> 04:49.290
这个没问题吧 然后在这个组件卸载的时候呢 再把这个监听器移除

04:49.550 --> 04:51.850
所以说我们还可以把这个东西做一个message

04:52.310 --> 04:53.050
然后在

04:53.290 --> 04:54.870
卸载组件的时候 把监听器移除

04:55.390 --> 04:58.470
接下来我们这个数据是不是就记录了我的滚动条位置了

04:58.710 --> 05:01.790
这种做法呢 我就把说一下啊 所以我们不会用这种做法做

05:02.050 --> 05:03.070
为什么以后我再说

05:03.830 --> 05:05.870
呃 那么这个数据呢 是不是可以

05:06.130 --> 05:07.150
通过属性

05:07.410 --> 05:08.710
传给这两个组件啊

05:08.950 --> 05:10.230
这两个组件我们增加一个属性

05:10.490 --> 05:12.270
诶 就是我目前的滚动位置

05:12.790 --> 05:15.610
那么他这个属性变化的时候 我们是不是可以用watch

05:16.890 --> 05:17.650
学过了啊

05:17.910 --> 05:20.470
watch进行监听 监听那个属性的变化

05:20.730 --> 05:21.510
属性一变化

05:21.710 --> 05:22.970
诶 我们可能会做一些事

05:23.230 --> 05:24.970
要说这边呢 可能要加载更多

05:25.230 --> 05:26.830
诶 这边呢 可能要

05:27.090 --> 05:28.110
重新设置

05:28.370 --> 05:29.390
激活样式

05:29.910 --> 05:30.410
对吧

05:30.670 --> 05:31.950
诶 这个逻辑上是怎么能能

05:32.210 --> 05:32.990
是不是可以走通的

05:33.250 --> 05:34.010
是可以走通的

05:35.550 --> 05:36.830
那为什么我

05:37.090 --> 05:39.130
不会选择用这种方式来做呢

05:39.390 --> 05:40.910
是因为我要考虑到将来

05:41.690 --> 05:43.990
将来我们看一个最终案例里边啊

05:44.750 --> 05:46.550
我们看最终案例里边还有什么东西

05:47.790 --> 05:48.850
跟滚动相关的

05:49.830 --> 05:52.710
就说有可能监听这个滚动调的

05:52.950 --> 05:54.550
还不一定是这种复制结构

05:54.810 --> 05:55.710
复制结构很简单

05:55.950 --> 05:57.750
我们用那个prob传过去就完事了

05:58.270 --> 06:00.590
复原数的数据呢 传递到指援数

06:01.550 --> 06:03.390
但是它有可能出现另外的情况

06:03.910 --> 06:04.590
你看啊

06:05.390 --> 06:06.990
我们就去看详情吧

06:08.150 --> 06:09.030
我们往下走

06:10.790 --> 06:11.390
往下走

06:14.260 --> 06:15.660
这里出现一个东西 看到没

06:16.540 --> 06:18.100
回到顶部

06:18.840 --> 06:21.120
看到没 一个东西回到顶部啊

06:21.880 --> 06:23.880
那么这个东西是不是也要监听滚动调

06:24.640 --> 06:26.640
它不仅要监听滚动调

06:26.920 --> 06:29.840
还要重新去设置这个滚动调的位置

06:32.240 --> 06:34.800
你看这个这个这个倒设肯定又是个组件

06:35.040 --> 06:36.080
那么这个组件呢

06:36.340 --> 06:37.960
它就不一定是复制关系的

06:38.720 --> 06:40.280
因为这个组件是一个通用性质的

06:40.520 --> 06:41.680
任何一个页面

06:42.120 --> 06:43.280
只要某个滚动调

06:43.520 --> 06:44.800
滚动到某一个位置的时候

06:45.040 --> 06:46.360
我们都会出现这个组件

06:47.020 --> 06:50.140
所以说这个组件它不一定监听的是这个detail的滚动调

06:51.180 --> 06:51.700
看到没

06:51.940 --> 06:53.140
遇到这么一个情况

06:53.980 --> 06:55.300
还有一个问题呢就是

06:55.540 --> 07:00.140
我现在呢我刚才的做法呢只是把副组件的滚动调位置往下传递

07:00.660 --> 07:03.220
那么执着键有能力修改的滚动调位置吗

07:03.720 --> 07:04.940
是没有能力修改啊

07:05.420 --> 07:08.580
你看执着键一个但是我们的实际开发中是有权力修改的

07:09.100 --> 07:09.860
你看点这

07:10.860 --> 07:12.420
所以可以修改这个滚动调的位置啊

07:13.400 --> 07:15.200
我们这里是那个

07:15.440 --> 07:17.480
我们用的是某链接码还好一点

07:17.740 --> 07:19.280
然后呢我们点这个东西的时候

07:20.040 --> 07:21.680
所以也可以修改到滚动调的位置

07:22.560 --> 07:23.120
对不对

07:23.380 --> 07:25.160
那么这个问题

07:25.940 --> 07:27.480
是一个什么样的问题呢

07:28.000 --> 07:29.000
这个问题呢

07:29.520 --> 07:30.560
根源在于这

07:31.560 --> 07:33.880
我们现在要多讲一种组件通信方式了

07:35.160 --> 07:37.440
就是有的时候呢咱们在项目里边

07:37.680 --> 07:39.360
有些组件之间的通信啊

07:39.620 --> 07:41.040
它是比较灵活的

07:41.200 --> 07:42.580
它不一定是负责关系

07:42.840 --> 07:44.100
负责关系通信很简单

07:44.380 --> 07:45.900
从上往下prop

07:46.160 --> 07:47.180
从下往上event

07:48.460 --> 07:49.500
但是有的时候

07:50.000 --> 07:52.560
组件之间的通信啊它极其的灵活

07:52.820 --> 07:54.860
它有可能会出现这两个组件之间通信

07:55.620 --> 07:56.920
你说他们是负责组件吗

07:57.180 --> 07:57.940
也不是

07:58.700 --> 07:59.460
那怎么办呢

07:59.980 --> 08:02.300
目前的如果说用目前学过的知识的话

08:02.540 --> 08:03.580
只有一种办法

08:04.340 --> 08:04.860
怎么办法

08:05.620 --> 08:07.420
他事件比方他们要通信

08:07.660 --> 08:09.200
他出发一个事件他要处理

08:09.700 --> 08:10.220
那怎么办

08:10.680 --> 08:11.180
他

08:11.440 --> 08:12.220
事件往上抛

08:12.480 --> 08:14.000
他处理不了事件继续往上抛

08:14.260 --> 08:15.040
让他来处理

08:15.560 --> 08:17.600
然后他处理过后把数据往下传遞

08:17.860 --> 08:18.360
传给他

08:18.880 --> 08:20.400
那个数据呢对他来说没用

08:20.660 --> 08:21.700
他就把数据直接传给他

08:21.960 --> 08:22.980
他就把数据传给他

08:23.740 --> 08:24.500
那么这样子

08:24.760 --> 08:26.040
通过间接的方式

08:26.300 --> 08:27.580
来完成这个组件通信

08:28.600 --> 08:29.120
明显的意思吧

08:30.140 --> 08:32.700
其实我们这里的这个例子呢还不是

08:32.960 --> 08:33.980
特别的明显

08:34.240 --> 08:35.260
但是呢

08:35.520 --> 08:37.820
我们这个例子里边其实也已经看到这个效果了

08:38.220 --> 08:40.340
就是我们的 detail 组件跟他之间至少

08:41.100 --> 08:42.380
也可能不会存在一个负责关系

08:42.640 --> 08:44.440
因为这个组件呢他可能会放到哪呢

08:45.200 --> 08:45.960
这个组件有可能放到这

08:47.500 --> 08:48.520
放到app里边

08:49.280 --> 08:50.840
因为这个是一个全局的组件

08:51.600 --> 08:55.180
他在任何时候在滚动条往下拉到一定位置的时候他都会出现

08:56.460 --> 08:56.980
懂得意思吧

08:57.740 --> 08:58.760
所以说呢

08:59.280 --> 09:00.300
我们这一块

09:00.800 --> 09:04.400
设计到这个组件通信的他可能就是跨越这个组件成绩的

09:05.380 --> 09:07.880
而且还有一种可能更加灵活

09:08.140 --> 09:09.940
就是一个组件发生了一件事

09:10.200 --> 09:11.520
发生了一件事情过后

09:11.780 --> 09:13.580
不是另一个组件来处理

09:14.340 --> 09:15.100
而是

09:15.360 --> 09:16.900
一个普通的GS模块

09:17.660 --> 09:21.500
还有将来还可能会有这么一种情况啊在我们的项目里边好像是没有

09:22.020 --> 09:25.340
但是呢如果说将来在公司里面遇到一些比较灵活的场景

09:25.600 --> 09:26.620
一个组件发生一件事

09:26.880 --> 09:27.900
一个GS模块

09:28.160 --> 09:28.940
要启动来处理

09:29.700 --> 09:31.220
那么这种又该怎么去通信

09:33.020 --> 09:34.300
好像这种问题

09:34.620 --> 09:36.660
就是处于我们这一节可能内容

09:36.920 --> 09:39.760
给他介绍一个新的通信方式叫做事件

09:40.240 --> 09:40.740
总线

09:41.520 --> 09:43.320
这个事件总线是什么意思呢

09:43.820 --> 09:47.400
他有了这个事件总线之后我们这个组件之间通信啊

09:47.660 --> 09:48.940
完全可以跨越成绩

09:49.200 --> 09:49.640
正是呢

09:49.900 --> 09:52.020
组件跟普通的GS模块都可以重新的

09:52.780 --> 09:55.860
好咱们来看一下这事件总线啊我这里做了一个

09:56.360 --> 09:57.140
BBT

09:59.590 --> 10:00.630
来看一下吧

10:02.410 --> 10:03.190
首先呢我们

10:03.430 --> 10:05.750
是这样我们回到一开始

10:06.290 --> 10:08.850
我这里有一个事件总线这是我们一会要做的

10:09.370 --> 10:11.410
他实际能够实现一个什么效果呢

10:11.670 --> 10:13.470
就是无论是一个组件

10:13.730 --> 10:15.770
还是一个普通的GS模块

10:16.790 --> 10:19.350
就是用一个GS写成的一个模块啊普通的GS模块

10:20.630 --> 10:26.010
他们都可以去监在事件总线上去监听一个东西啊监听某个事件

10:26.270 --> 10:29.070
监听的方式呢就跟那个伍佑一样差不多啊

10:29.330 --> 10:30.710
然后监听某一个东西比较兼

10:30.970 --> 10:34.210
这两这个组件和这个普通的GS模块监听一分成一

10:34.650 --> 10:35.490
来取个名字

10:35.750 --> 10:38.050
然后这个组件和这个普通模块监听一分成二

10:38.810 --> 10:41.630
监听在事件总线上去监听不同的事件

10:42.410 --> 10:43.430
当有一天

10:43.690 --> 10:48.550
某一个GS模块或者是某一个组件他发生了一件事

10:48.810 --> 10:51.870
他就可以往事件总线上去扔一个事件

10:52.130 --> 10:53.410
比方说我是那个组件

10:55.210 --> 10:58.270
他发生了一件事比方说事件的名字叫做一分成一

10:58.530 --> 11:01.350
他就把这个事件的在事件总线上去触发

11:01.810 --> 11:05.650
当然也不一定是组件啊也有可能是一个普通的GS模块

11:05.910 --> 11:10.010
他可能发生了一件事他总之他会往这个事件总线上去扔一个事件

11:10.770 --> 11:12.570
那个事件可能有一些相关的数据

11:13.070 --> 11:15.390
比方说刚刚是滚动条滚动到某一个位置

11:15.650 --> 11:18.970
那么这个他会把相关的数据呢传递给事件总线

11:19.470 --> 11:20.510
就发生这么一件事

11:21.790 --> 11:26.910
那么发生了过后呢事件总线因为他知道之前有一些东西是在监听这个事件的

11:27.170 --> 11:28.190
现在发生了事件一了

11:28.590 --> 11:31.670
那怎么办呢他会把这个数据啊传递给

11:32.230 --> 11:33.270
所有的监听者

11:34.030 --> 11:34.530
原来说

11:35.070 --> 11:37.350
这里两个监听者对吧他把这个数据传递给他们

11:37.610 --> 11:39.830
然后让他们去运行各自的方法

11:40.170 --> 11:41.190
各自的处理函数

11:41.710 --> 11:43.750
这就是整个事件总线要做的事情

11:44.790 --> 11:47.110
有人触发事件有人监听事件

11:47.470 --> 11:50.350
触发了事件过后呢他会自建总线会分派

11:50.630 --> 11:53.150
把数据分派到各个监听者让他们去

11:53.430 --> 11:55.550
进行运行其实这就是一个观察者模式

11:56.550 --> 12:00.390
好然后呢还有什么还有什么要处理的就是事件总线

12:01.150 --> 12:04.030
有一天这个某一个组建表现消失了

12:04.790 --> 12:07.790
表现回到最开始啊有一天这个组建消失了

12:08.550 --> 12:10.790
这个组建卸载了卸载过后是不是不要监听了

12:11.030 --> 12:15.270
也这个事件总件呢可以非常方便的把这个监听器呢给他移除掉

12:17.510 --> 12:18.790
他要处理这么一些东西

12:19.070 --> 12:21.470
所以说这就是我们今天要做的这个事件总线

12:21.870 --> 12:24.190
我们来回顾一下这个事件总线他要做什么事情

12:24.390 --> 12:26.910
他要提供监听某一个事件的接口

12:27.150 --> 12:30.870
就是我要通过事件总线去监听监听一分成一监听一分成二

12:31.630 --> 12:34.830
还要能够取消监听啊表某一个组建卸载了过后

12:34.830 --> 12:36.350
他就不要再监听这个事件了

12:37.470 --> 12:40.790
当有一天触发事件的时候呢我要做一些事儿

12:40.790 --> 12:42.990
所以说他要提供一个触发事件的接口

12:43.590 --> 12:45.310
还要可以传递数据过去

12:45.910 --> 12:49.230
触发事件过后要做什么呢事件总线要能够自动的把

12:49.830 --> 12:52.830
触发这个事件过后所有的监听者通知所谓的监听者

12:52.830 --> 12:54.430
让他们去处理

12:55.750 --> 12:58.950
好那么我们这就是事件总线要做的事情啊

12:59.190 --> 13:02.350
我认为这个PVT是用那个keynote这些

13:02.350 --> 13:04.230
里面那边不一定打得开没关系

13:04.230 --> 13:06.750
你就听这个意思看这个视频就ok了

13:07.950 --> 13:10.550
好那么这个事件总线怎么做呢

13:10.550 --> 13:13.950
其实我们在这里呢可以用自己熟悉代码的方式把它完成

13:14.310 --> 13:15.710
并不复杂并不复杂

13:16.990 --> 13:19.710
我这里把这个这个代码去掉啊

13:22.880 --> 13:23.680
这个代码去掉了

13:25.400 --> 13:26.160
好看着啊

13:26.600 --> 13:28.960
现在呢我们写上这么一个就是

13:29.680 --> 13:30.800
在根路路下建一个吧

13:30.800 --> 13:31.880
叫做event

13:32.720 --> 13:33.120
buzz

13:33.440 --> 13:34.040
叫js

13:34.640 --> 13:35.840
我们想写这么一个东西

13:36.560 --> 13:37.560
好写这么一个东西

13:37.560 --> 13:40.720
这里呢我希望事件总线是一个什么样呢

13:40.720 --> 13:42.040
我就希望它是一个对象

13:42.280 --> 13:43.240
对象就ok了

13:43.400 --> 13:45.200
所以我们这里导出直接导出一个对象

13:46.440 --> 13:48.440
这就是导出对象就是个事件总线

13:51.340 --> 13:54.540
这个事件总线它里面有什么方法呢

13:54.540 --> 13:55.220
因为我们要

13:55.700 --> 13:56.700
做一些事情对吧

13:57.300 --> 13:59.300
这就是这一事情呢就是我们提供了接口

13:59.460 --> 14:02.740
有什么方法呢首先要能够坚定某一个事件啊

14:02.740 --> 14:04.180
因此呢我们这里有个方法

14:04.700 --> 14:05.540
叫做

14:06.060 --> 14:08.140
我们给他取个名字就是on

14:08.140 --> 14:11.540
当什么什么发生的时候要做什么什么事情啊

14:11.900 --> 14:15.860
按照命名按照我们就模拟无诱的命名规范吧

14:16.220 --> 14:17.100
用多的开头

14:17.100 --> 14:18.980
当然你可以直接用一个on也可以啊

14:18.980 --> 14:19.580
没什么问题

14:19.780 --> 14:21.060
我这里用多的开头吧

14:21.980 --> 14:24.620
当什么什么的时候我要做什么什么的事情

14:24.860 --> 14:27.460
那么这个方法呢我怎么来怎么来写呢

14:27.780 --> 14:28.940
这个方法其实很简单啊

14:29.180 --> 14:30.260
我给他写上这么一个东西

14:31.260 --> 14:33.780
第一个是事件的名字event

14:35.020 --> 14:35.780
事件的名字

14:36.180 --> 14:37.620
后边呢可能要传递

14:38.020 --> 14:40.740
后边要传递什么传递一个处理函数对吧

14:40.860 --> 14:41.380
handle

14:42.460 --> 14:43.180
就这么简单

14:43.820 --> 14:45.260
监听某一个事件

14:46.220 --> 14:48.300
监听某一个事件

14:48.660 --> 14:49.780
第一个是事件的名字

14:49.900 --> 14:50.580
监听啥时候见

14:50.580 --> 14:54.620
比方说我将来用这个事就可以怎么用了event bus

14:54.780 --> 14:58.900
当某一个事件比方event一发生的时候

14:59.060 --> 15:00.260
我可能要做这些事情

15:00.380 --> 15:00.780
对吧

15:01.220 --> 15:02.220
这就是监听

15:02.420 --> 15:03.180
监听事件

15:04.260 --> 15:05.140
传一个handle过去

15:05.140 --> 15:06.140
处理函数过去

15:06.420 --> 15:07.300
传一个事件名字

15:08.220 --> 15:08.740
没问题吧

15:08.740 --> 15:10.140
我们先写到这儿

15:10.140 --> 15:11.460
先不倒去写在里边的代码

15:11.860 --> 15:13.340
然后呢我们还要做什么事情呢

15:13.340 --> 15:14.540
你看我们刚才记录的

15:15.020 --> 15:18.060
还要做的是提供取消监听的接口

15:18.940 --> 15:19.940
就是off

15:21.300 --> 15:24.180
给我一个事件的名字

15:24.940 --> 15:26.700
你要取消监听哪个事件

15:26.700 --> 15:29.020
那么这个事件的handle的处理函数

15:29.020 --> 15:31.140
你要取消哪个处理函数的监听

15:31.500 --> 15:33.420
因为针对某一个事件

15:33.420 --> 15:35.180
它可能有多个的监听

15:35.180 --> 15:38.620
比方说这个组建的监听一分之一

15:38.620 --> 15:41.140
这个组建也通过这个on来监听一分之一

15:41.140 --> 15:42.220
他们都雕容了这个on

15:42.220 --> 15:43.140
监听一分之一

15:43.140 --> 15:44.740
将来这个组建不要了

15:44.740 --> 15:46.740
我们要取消监听怎么办了

15:46.740 --> 15:47.700
取消监听的时候

15:47.700 --> 15:50.340
就是我这个组建里边去雕容off

15:51.300 --> 15:52.660
event

15:52.660 --> 15:53.780
雕容off

15:53.780 --> 15:55.420
把哪个事件取消监听

15:55.420 --> 15:57.020
event1取消监听

15:57.020 --> 15:57.780
哪个处理函数

15:57.780 --> 15:59.420
那就把之前的处理函数传过去

16:00.700 --> 16:02.340
那么就取消监听

16:02.340 --> 16:03.020
没问题吧

16:03.780 --> 16:03.980
好

16:03.980 --> 16:04.780
咱们继续看

16:05.500 --> 16:07.660
有这么一个方法取消监听

16:07.660 --> 16:08.660
还有什么方法呢

16:09.820 --> 16:10.380
刚才说了

16:10.380 --> 16:12.180
还有一个就是触发事件

16:13.180 --> 16:14.060
有些东西

16:14.060 --> 16:14.980
有一个模块

16:14.980 --> 16:17.140
一个介绍模块或者是一个组建

16:17.140 --> 16:18.980
他们在任何时候发生的一件事

16:18.980 --> 16:20.300
可以往事件总线里边

16:20.340 --> 16:21.580
触发一个事件

16:21.580 --> 16:22.580
那么触发事件

16:22.580 --> 16:23.740
我们可以用

16:23.740 --> 16:25.140
就是Mate

16:25.140 --> 16:25.940
这个5u差不多

16:25.940 --> 16:26.380
对吧

16:26.380 --> 16:28.060
用个Mate来触发一个事件

16:28.060 --> 16:29.380
那么你只需要告诉我

16:29.380 --> 16:30.620
事件的名字

16:30.620 --> 16:31.580
触发的事件的时候

16:31.580 --> 16:33.180
是不是要传递一些数据

16:33.180 --> 16:33.580
对吧

16:33.580 --> 16:34.660
那么那个数据

16:34.660 --> 16:36.580
你可以传递多个

16:36.580 --> 16:37.420
随便多号个都可以

16:37.420 --> 16:38.540
我用声语参数了

16:38.540 --> 16:39.660
把他接受一下

16:39.660 --> 16:40.540
这是触发事件

16:42.020 --> 16:42.660
这是什么

16:42.660 --> 16:44.540
取消监听

16:45.940 --> 16:47.660
取消监听

16:48.620 --> 16:49.820
这个是触发事件

16:51.300 --> 16:52.900
触发事件的时候

16:52.900 --> 16:53.660
我们刚才说了

16:53.660 --> 16:54.460
就要做什么了

16:54.460 --> 16:56.260
就要把他要能够自动的

16:56.260 --> 16:58.180
去通知监听者

16:58.180 --> 16:59.700
我们就要实现这么一个东西

16:59.700 --> 17:00.420
就这三个函数

17:00.420 --> 17:01.380
实现就完事了

17:02.220 --> 17:03.380
那怎么来实现了

17:04.580 --> 17:05.860
其实并不复杂

17:05.860 --> 17:08.420
我们在这个事件总线内部

17:08.420 --> 17:10.300
给他做上这么一个东西

17:10.300 --> 17:13.060
你不是要处理很多事件吗

17:13.060 --> 17:14.820
每个事件有很多的监听者

17:14.820 --> 17:16.660
那么我们就设计一个结构

17:16.660 --> 17:18.740
这个事件总线里边设计一个结构

17:18.780 --> 17:20.660
就监听者专门来记录哪些监听者

17:20.660 --> 17:23.020
比方说一分彻一的一个数组

17:23.020 --> 17:24.460
有哪些监听者

17:24.460 --> 17:26.020
每个监听者是不是一个处理函数

17:26.020 --> 17:27.500
我就把函到了一

17:27.500 --> 17:29.420
函到了二记录到这

17:29.420 --> 17:30.860
将来触发了一分彻一

17:30.860 --> 17:32.260
我就把这些处理函数拿到

17:32.260 --> 17:34.140
一个一个去运行就完事了

17:34.140 --> 17:36.140
然后如果说我有

17:36.140 --> 17:36.900
另外一个事件

17:36.900 --> 17:37.820
又有一个数组

17:37.820 --> 17:39.060
函到了一

17:39.060 --> 17:40.260
函到了二

17:40.260 --> 17:40.820
没了意思吧

17:40.820 --> 17:41.700
就是这么一种结构

17:41.700 --> 17:44.020
我的内部有这么一个结构

17:44.020 --> 17:45.780
对每一个事件

17:45.780 --> 17:47.500
我有这么一个数组

17:47.580 --> 17:50.100
记录每一个监听者

17:50.100 --> 17:51.340
他的处理函数

17:51.340 --> 17:52.660
将来触发这个事件的时候

17:52.660 --> 17:54.660
我只需要去把它的

17:54.660 --> 17:55.940
一个一个运行就行了

17:55.940 --> 17:57.020
那怎么来取消监听呢

17:57.020 --> 17:59.500
就从一个数组里面删除就完事了

17:59.500 --> 18:01.380
基本逻辑是很简单

18:01.380 --> 18:02.140
那么我们在内部

18:02.140 --> 18:04.780
这个模块内部就写上这么一个

18:04.780 --> 18:06.020
写上这么一个数组

18:06.020 --> 18:07.460
写上这么一个数据结构

18:07.460 --> 18:08.460
给他叫nesoners

18:12.580 --> 18:13.500
他是个空对象

18:13.500 --> 18:14.340
为什么是空对象呢

18:14.340 --> 18:14.860
因为一开始

18:14.860 --> 18:17.260
我也不知道有哪些事件要监听

18:17.420 --> 18:18.860
那么我们来一个个看

18:18.860 --> 18:20.220
首先这个按

18:20.220 --> 18:22.300
当我们监听某一个事件的时候

18:22.300 --> 18:24.180
是不是就是往对应的事件里边

18:24.180 --> 18:25.380
比方我们监听一分之一

18:25.380 --> 18:26.340
我就找了一分之一

18:26.340 --> 18:27.700
往这个数组里面加一个

18:27.700 --> 18:28.940
所以就完事了

18:28.940 --> 18:30.860
为了避免这个handle的重复

18:30.860 --> 18:32.700
你不要用一个按

18:32.700 --> 18:34.220
反正那附近传统一个handle的

18:34.220 --> 18:35.980
那没什么意义

18:35.980 --> 18:37.300
我就加一个就行了

18:37.300 --> 18:39.740
所以说这个地方我们可以用个set

18:39.740 --> 18:40.820
es6的set对吧

18:40.820 --> 18:41.740
避免重复

18:41.740 --> 18:43.100
那么我们来看

18:43.100 --> 18:44.180
首先我判断一下

18:44.180 --> 18:46.340
这个里边有没有1分成1呢

18:46.380 --> 18:48.060
就是有没有这个事件名字呢

18:48.060 --> 18:50.140
怎么判断nesoners

18:50.140 --> 18:52.540
里边有一个是不是event name传进去

18:52.540 --> 18:54.380
有没有这个属性啊

18:54.380 --> 18:55.780
对吧 我们把这个属性拿到

18:55.780 --> 18:56.780
有没有这个属性啊

18:56.780 --> 18:58.380
如果说有的话

18:58.380 --> 19:00.380
或者说如果他没有的话

19:00.380 --> 19:00.940
没有的话

19:00.940 --> 19:04.260
那么就给他初始化一个空的集合

19:04.260 --> 19:05.700
他一开始没有这个event name

19:05.700 --> 19:07.620
我就给他初始化一个空的集合

19:07.620 --> 19:08.660
那怎么来初始化

19:08.660 --> 19:10.700
nesoners event name

19:10.700 --> 19:11.220
等于什么

19:11.220 --> 19:12.980
new set

19:12.980 --> 19:13.700
对吧

19:13.700 --> 19:15.020
我们避免重复嘛

19:15.020 --> 19:16.500
给他初始化这么一个东西

19:16.500 --> 19:17.860
好然后呢

19:17.860 --> 19:18.940
如果

19:18.940 --> 19:20.620
那么经过这段代码

19:20.620 --> 19:23.100
无论是有还是之前有这个属性

19:23.100 --> 19:24.020
还是没有这个属性

19:24.020 --> 19:25.380
代码到了第十行

19:25.380 --> 19:26.900
是不是已经有这个属性了

19:26.900 --> 19:27.860
他要么是一个空输组

19:27.860 --> 19:29.740
要么是一个已经有内容的输组

19:29.740 --> 19:30.820
那么接下来我要做的事情

19:30.820 --> 19:33.260
就是往这个输组里边加一下

19:33.260 --> 19:34.820
nesoners event name

19:34.820 --> 19:36.500
那么这个一定是个set对不对

19:36.500 --> 19:38.260
给他add

19:38.260 --> 19:39.460
set里面不是一个方法吗

19:39.460 --> 19:41.700
叫做add加一下

19:41.700 --> 19:42.100
他避免

19:42.100 --> 19:42.980
他如果说有重复的话

19:42.980 --> 19:44.660
他就是会捕捉任何处理

19:44.660 --> 19:45.180
加什么呢

19:45.180 --> 19:46.260
加这个handle

19:46.260 --> 19:47.100
就这么简单

19:47.100 --> 19:48.500
就完了

19:48.500 --> 19:49.460
把这个加进去

19:49.460 --> 19:50.980
这就是监听某一个时间

19:50.980 --> 19:51.940
我现在要运行它吗

19:51.940 --> 19:52.820
不运行

19:52.820 --> 19:54.460
只有等到将来触发时间的时候

19:54.460 --> 19:55.740
才去循环这个输组运行

19:57.020 --> 19:59.340
好取消监听也很简单

19:59.340 --> 20:00.260
取消监听呢

20:00.260 --> 20:02.580
如果说我们还是为了

20:02.580 --> 20:04.380
避免那个出问题

20:04.380 --> 20:05.060
避免爆错

20:05.060 --> 20:05.700
我们还是判断一下

20:05.700 --> 20:07.180
有没有这个属性

20:07.180 --> 20:09.020
如果说这个属性都没有

20:09.020 --> 20:10.620
用这个属性都不存在

20:10.620 --> 20:12.660
你要取消一分之一的监听

20:12.660 --> 20:13.580
一分之一都没有

20:13.620 --> 20:14.580
没有任何人监听

20:14.580 --> 20:14.780
对吧

20:14.780 --> 20:15.660
都不存在

20:15.660 --> 20:16.860
那还取消了啥

20:16.860 --> 20:17.580
不用取消了

20:17.580 --> 20:18.020
对吧

20:18.020 --> 20:19.380
那么就直接结束了

20:19.380 --> 20:20.460
这里就直接结束了

20:22.340 --> 20:22.540
好

20:22.540 --> 20:23.860
如果说你有监听

20:23.860 --> 20:25.340
一分之一有监听

20:25.340 --> 20:26.620
有人在监听

20:26.620 --> 20:26.740
好

20:26.740 --> 20:28.660
那么我们取消哪个监听函数

20:28.660 --> 20:29.780
取消这个监听函数

20:29.780 --> 20:32.220
我们是不是要去找到这个监听函数

20:33.380 --> 20:34.380
其实也不用去找

20:34.380 --> 20:36.140
我们给这个一分层的

20:36.140 --> 20:37.700
他这个一分层的重新复职

20:39.260 --> 20:40.460
重新复职

20:40.460 --> 20:43.100
我看一下State里面有没有filter

20:43.140 --> 20:43.580
没有

20:43.580 --> 20:44.060
没有的话

20:44.060 --> 20:45.060
我这样吧

20:46.500 --> 20:46.940
这样吧

20:46.940 --> 20:49.660
我直接我就直接用remove了

20:49.660 --> 20:52.060
因为这里面不就有一个方法

20:52.060 --> 20:52.940
就remove对吧

20:56.100 --> 21:00.020
叫做remove

21:00.020 --> 21:01.180
denad

21:01.180 --> 21:02.260
删除某一个

21:02.260 --> 21:03.580
删除某一个指

21:03.580 --> 21:05.060
我们这里面直接

21:05.060 --> 21:05.940
denad

21:05.940 --> 21:07.620
删除某一个handle

21:07.620 --> 21:08.940
把删除掉就完事了

21:08.940 --> 21:10.220
上找不到这个handle的话

21:10.220 --> 21:11.260
就不会说任何处

21:11.260 --> 21:12.300
就取消监听

21:12.340 --> 21:14.180
其实就是控制这个数组

21:14.180 --> 21:15.580
那么最后就是触发事件的

21:15.580 --> 21:16.460
触发事件呢

21:16.460 --> 21:17.340
稍微单码多一点

21:17.340 --> 21:18.580
其实也很简单

21:18.580 --> 21:19.140
触发事件

21:19.140 --> 21:21.780
我们是不是要找到这个事件名字的那个set

21:21.780 --> 21:22.340
对吧

21:22.340 --> 21:22.500
好

21:22.500 --> 21:23.260
我们找到一下

21:23.260 --> 21:24.460
当然如果从前提条件

21:24.460 --> 21:25.420
如果说这个玩意里面

21:25.420 --> 21:27.380
根本就没有这个相应的监听函数

21:27.380 --> 21:29.020
那我就啥都不做

21:29.020 --> 21:30.140
有的话怎么办

21:30.140 --> 21:31.660
我是不是循环这个set

21:31.660 --> 21:33.180
我们用for25

21:33.180 --> 21:34.060
handle

21:34.060 --> 21:34.740
循环什么

21:34.740 --> 21:38.140
循环这个nationless event

21:38.140 --> 21:39.660
循环这个set

21:39.660 --> 21:41.580
每一循环一次是不是拿到一个handle

21:41.580 --> 21:43.700
然后去运行它就完事了

21:43.700 --> 21:46.380
就这么简单handle去运行它

21:46.380 --> 21:49.660
运行它的时候传递什么参数呢

21:49.660 --> 21:51.260
运行它的时候是不是传递这些

21:51.260 --> 21:53.580
触发事件的时候扔过来什么数据

21:53.580 --> 21:54.500
你看

21:54.500 --> 21:55.580
触发事件的时候

21:55.580 --> 21:57.460
它的数据扔过来什么数据

21:57.460 --> 21:58.620
我就把这个数据呢

21:58.620 --> 22:00.580
去找到这些监听者

22:00.580 --> 22:02.100
一个人去执行

22:02.100 --> 22:05.020
然后把这个数据传递过去

22:05.020 --> 22:06.820
你看

22:06.820 --> 22:07.820
再看一下这个颜色

22:07.820 --> 22:09.820
你看

22:09.820 --> 22:10.700
扔过来数据

22:10.700 --> 22:13.260
触发的时候扔过来数据

22:13.260 --> 22:15.300
然后数据传递过去执行

22:15.300 --> 22:16.780
那么一通过在执行函数的时候

22:16.780 --> 22:19.860
是不是要把这个数据一次传递过去

22:19.860 --> 22:20.940
没了

22:20.940 --> 22:22.620
这是我们的事件总线的单码

22:22.620 --> 22:24.580
一共有20多行单码

22:24.580 --> 22:26.620
不复杂吧

22:26.620 --> 22:28.620
接下来我们来试验一下事件总线

22:28.620 --> 22:30.100
这个事件总线是跨越组件

22:30.100 --> 22:31.900
跨越界是模块的

22:31.900 --> 22:32.700
那么来看一下

22:32.700 --> 22:34.340
是不是真的能够运行呢

22:34.340 --> 22:35.660
你看现在我都不用付诱了

22:35.660 --> 22:37.180
你付诱都不要了

22:37.180 --> 22:39.100
你看我能不能玩

22:39.180 --> 22:41.700
测试事件总线

22:43.860 --> 22:50.580
我们导入EventBusFromEventBus

22:50.580 --> 22:51.700
导进来

22:51.700 --> 22:53.340
接下来我们来玩一下

22:53.340 --> 22:56.900
等下我们再坚定一个

22:56.900 --> 23:00.860
当我们发生Event一的时候

23:00.860 --> 23:04.300
我给大家用个时间处理

23:04.300 --> 23:06.260
等下说一个data

23:06.260 --> 23:08.500
我们输出一下

23:08.540 --> 23:09.900
handle1

23:09.900 --> 23:11.980
我们这里写一个吧

23:11.980 --> 23:14.420
分析handle1

23:14.420 --> 23:19.180
data输出handle1data

23:19.180 --> 23:20.100
好 再来一个

23:20.100 --> 23:23.340
一会儿我们要有一个handle2data

23:23.340 --> 23:29.100
consolehandle2data

23:29.100 --> 23:31.100
好 接下来我们把这个Event1

23:31.100 --> 23:32.660
当我们遇到Event1的时候

23:32.660 --> 23:34.700
我们把handle1传进去

23:34.700 --> 23:36.900
然后当我们遇到Event2的时候

23:36.900 --> 23:38.900
我们把Event1的时候

23:38.900 --> 23:40.100
我们把handle2传进去

23:40.100 --> 23:42.300
就是Event1有两个处理函数

23:42.300 --> 23:45.100
然后当我们遇到Event2的时候

23:45.100 --> 23:48.500
我把再传一个handle1

23:48.500 --> 23:50.300
OK 我们就比方说

23:50.300 --> 23:51.660
有这么一个场景

23:51.660 --> 23:54.700
注册了坚定了两个Event1

23:54.700 --> 23:56.340
Event1有两个坚定函数

23:56.340 --> 23:58.980
Event2有一个坚定函数

23:58.980 --> 24:00.980
好了 接下来我要做的事情

24:00.980 --> 24:04.580
就是找到EventBus

24:04.580 --> 24:07.860
把它放到Windows里边变成测试

24:07.860 --> 24:12.190
好 接下来我们看

24:12.190 --> 24:13.670
现在没有爆错吧

24:13.670 --> 24:14.750
没有任何问题

24:14.750 --> 24:16.350
那么接下来我们来看一下EventBus

24:16.350 --> 24:17.470
我现在去触发时间

24:17.470 --> 24:20.590
怎么触发 我就用EventBus

24:20.590 --> 24:27.350
EventBus用Emet触发时间

24:27.350 --> 24:30.350
然后触发的是Event1

24:30.350 --> 24:31.350
这个时间

24:31.350 --> 24:33.190
给它传一些数据吧

24:33.190 --> 24:36.550
比方说传一个123

24:36.550 --> 24:37.790
好 咱们来试一下

24:37.790 --> 24:38.870
一回车你看

24:38.910 --> 24:39.630
是不是之前

24:39.630 --> 24:42.710
监听Event1的处理还是都运行了

24:42.710 --> 24:44.870
它循环那个数字就运行了

24:44.870 --> 24:46.230
那如果说我们再去触发

24:46.230 --> 24:47.230
看又运行了

24:47.230 --> 24:49.350
那么再去触发Event2

24:49.350 --> 24:51.630
你看 是不是运行了这个

24:51.630 --> 24:53.550
有一天我不想监听

24:53.550 --> 24:54.830
我不想我要取消监听

24:54.830 --> 24:57.670
在Event1下面取消监听Handle1

24:57.670 --> 24:58.710
那也很简单

24:58.710 --> 25:00.710
咬着我们这里把Handle

25:01.830 --> 25:03.430
放到Windows里边

25:03.430 --> 25:04.830
Handle1

25:04.830 --> 25:06.430
Handle1

25:06.430 --> 25:07.350
Windows

25:07.350 --> 25:08.630
Handle2

25:09.630 --> 25:11.470
再试一下

25:11.470 --> 25:13.830
比方说我现在触发没问题吧

25:13.830 --> 25:15.190
都没问题

25:15.190 --> 25:18.110
现在我们去取消监听EventBus

25:18.110 --> 25:19.470
off

25:19.470 --> 25:21.510
Event1

25:21.510 --> 25:23.230
把Handle1取消掉

25:23.230 --> 25:24.110
不监听了

25:24.110 --> 25:26.230
不监听过后我们再去触发Event1

25:26.230 --> 25:28.150
你看只有Handle2运行了

25:28.150 --> 25:29.950
咱们就要实现这样的效果

25:29.950 --> 25:31.390
这个效果实现了过后

25:31.390 --> 25:32.550
能不能完成我们最终的事情

25:32.550 --> 25:33.390
肯定是可以的

25:33.390 --> 25:34.990
不过那是下级课的事情

25:34.990 --> 25:35.950
具体的做业务

25:35.950 --> 25:36.870
我们下级课再做

25:36.950 --> 25:38.390
我们这一课先把这个

25:38.390 --> 25:39.270
问题解决

25:39.270 --> 25:40.430
这就事件总线

25:40.430 --> 25:41.510
所以说我们现在

25:41.510 --> 25:42.990
在组建通信这里一块

25:42.990 --> 25:43.870
又多了一个东西

25:43.870 --> 25:44.910
叫事件总线

25:44.910 --> 25:46.950
这个事件总线是极其灵活的

25:48.310 --> 25:50.150
在不同的组建之间都可以玩

25:50.990 --> 25:52.030
好 那么这个事件总线

25:52.030 --> 25:54.470
我这里是用自己的代码写的

25:54.470 --> 25:55.590
实际上那个事件总线

25:55.590 --> 25:56.590
你们以后

25:56.590 --> 25:58.230
面试的时候也好

25:58.230 --> 25:59.550
还是公司里面也好

25:59.550 --> 26:00.430
因为看到

26:01.630 --> 26:02.390
有一种方式

26:02.390 --> 26:03.790
就不用自己用代码写

26:03.790 --> 26:04.630
他们会怎么写的

26:04.630 --> 26:05.870
他们会这样子写

26:05.910 --> 26:06.510
你看着

26:07.670 --> 26:08.430
他们这样子写

26:09.070 --> 26:10.510
他们在这里的新件

26:10.510 --> 26:11.510
导入一个5U

26:15.180 --> 26:15.900
导入5U

26:16.540 --> 26:17.380
5U

26:17.980 --> 26:18.820
6一个5U

26:20.660 --> 26:22.420
空的 没有任何配置

26:22.420 --> 26:23.660
这个5U没有任何配置

26:24.500 --> 26:25.140
这个5U

26:25.140 --> 26:25.740
因为我们知道

26:25.740 --> 26:26.980
这个是一个5U实力

26:26.980 --> 26:28.140
5U实力的本质上

26:28.140 --> 26:29.420
跟组建实力差不多

26:29.900 --> 26:31.500
组建里边是不是有A面车

26:32.340 --> 26:33.860
组建实力里边是不是有A面车

26:34.980 --> 26:36.100
我现在告诉大家

26:36.100 --> 26:36.900
组建实力里面

26:36.900 --> 26:38.020
不仅有A面车

26:38.140 --> 26:39.940
不仅可以触发事件

26:39.940 --> 26:42.500
还可以监听事件

26:42.500 --> 26:43.940
监听这个组建的事件

26:43.940 --> 26:44.740
还可以

26:45.260 --> 26:47.060
off 取消这个监听

26:47.060 --> 26:48.060
还有这两个成员

26:48.060 --> 26:49.700
所以说我们组建实力里边

26:49.700 --> 26:51.940
实力成员里面有多了几个了

26:51.940 --> 26:52.860
除了A面车之外

26:52.860 --> 26:55.260
还有一个off

26:55.260 --> 26:56.300
其他一本身就有

26:56.300 --> 26:57.980
为什么刚才我这样的秘密

26:57.980 --> 26:58.980
变异大家

26:58.980 --> 27:00.140
更加好理解

27:00.660 --> 27:02.340
所以说我这里要做的是什么事情呢

27:02.340 --> 27:03.260
其实非常简单

27:03.260 --> 27:05.020
我这里导出这个玩意就完事了

27:05.980 --> 27:07.020
这就是个事件的东西

27:07.780 --> 27:09.420
因为六一个五六

27:09.420 --> 27:11.860
就是本质上就是一个组建实力

27:11.860 --> 27:13.220
就是一个五六的实力

27:13.220 --> 27:14.940
五六实力里边本身就有三个函数

27:14.940 --> 27:16.020
它给你提供好了的

27:16.020 --> 27:17.700
一本从我们以前接触过的

27:17.700 --> 27:18.020
对吧

27:18.020 --> 27:19.660
比如说我们都是用Z点的一面车

27:19.660 --> 27:20.260
就是组建

27:20.260 --> 27:21.460
Z就是组建实力

27:22.580 --> 27:23.540
所以说这里呢

27:23.540 --> 27:25.020
你看大马远方不动

27:25.540 --> 27:26.220
这里on

27:26.220 --> 27:27.020
这都远方不动

27:27.020 --> 27:27.580
我们来看一下

27:27.900 --> 27:28.620
可不可以呢

27:30.770 --> 27:31.410
A面车

27:31.410 --> 27:32.050
你看

27:32.050 --> 27:33.010
是不是可以

27:34.010 --> 27:36.050
这个A面车还会返回自己

27:36.050 --> 27:37.530
返回这个组建实力

27:37.730 --> 27:38.170
然后呢

27:38.170 --> 27:39.690
我们再触发A面车

27:39.690 --> 27:40.450
A面车2

27:40.450 --> 27:41.250
看一下行不行

27:41.610 --> 27:42.730
你看是不是也可以

27:42.730 --> 27:43.930
然后我们来取消

27:44.410 --> 27:45.370
取消事件

27:45.370 --> 27:46.850
然后再触发A面车1

27:46.850 --> 27:48.090
看是不是只有Handel本2了

27:48.690 --> 27:49.130
对不对

27:49.690 --> 27:50.610
也可以实现

27:51.210 --> 27:53.130
无论你是自己写单码实现

27:53.130 --> 27:54.730
还是能利用它那个玩意儿

27:54.730 --> 27:55.410
都可以

27:55.930 --> 27:56.490
都可以

27:56.490 --> 27:57.410
这就是主意

27:57.410 --> 27:58.810
这就是事件总线

27:58.810 --> 28:00.530
事件总线你会发现它极其的灵活

28:00.970 --> 28:02.250
它的介石里边都可以触发

28:02.650 --> 28:03.330
触发事件

28:04.410 --> 28:05.930
而且可以监听事件

28:06.010 --> 28:07.650
那么就是满足了

28:07.650 --> 28:09.450
我们之前要的这个效果

28:10.450 --> 28:11.210
好那么最后呢

28:11.210 --> 28:12.290
我们要把这个消

28:12.290 --> 28:12.890
把这个

28:13.450 --> 28:14.850
最终是要把这个业务

28:14.850 --> 28:16.650
就是把业务加进去

28:16.650 --> 28:18.250
就是真正用这个事件总线

28:18.250 --> 28:19.930
来去完成我们刚才那一块代码

28:19.930 --> 28:20.770
那么接下来下节课

28:20.770 --> 28:21.890
我们来给大家说

28:21.890 --> 28:22.930
怎么去完成

28:23.930 --> 28:24.610
这是这一课

28:24.610 --> 28:26.210
这是这一课的事件总线内容

