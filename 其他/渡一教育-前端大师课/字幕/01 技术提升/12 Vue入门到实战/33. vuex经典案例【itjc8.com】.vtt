WEBVTT

00:00.500 --> 00:06.500
哎呦哎 这节课可不好讲 这节课讲啥呀

00:06.500 --> 00:16.130
这节课讲登录 注销 然后注册就算了 注册其实很简单的

00:16.130 --> 00:21.130
然后健全 麻烦在这 健全

00:21.130 --> 00:26.130
咱们要实现一个什么效果呢 可能有同学觉得这个用户登录这一块还挺简单的

00:26.130 --> 00:29.130
那你们就看节目简单吗

00:29.130 --> 00:34.130
当然如果说你做一个非常简易的 就是能判断登录是不是成功

00:34.130 --> 00:40.130
那倒是挺简单的 但是呢我们要做登录 就要把那个用户的一套做出来

00:40.130 --> 00:45.130
那要做出来这一套的话就不简单 咱们那个项目里边没有登录

00:45.130 --> 00:50.130
后台有 后台呢我们现在还讲不到 将来会讲后台

00:50.130 --> 00:55.130
后台有 但是目前那个项目里边是没有登录的 把简化了

00:55.130 --> 00:59.130
如果说你学了这个块要去做登录也可以 没有什么问题

00:59.130 --> 01:03.130
就是我没做而已 那么我们这里单独开一个效果来讲

01:03.130 --> 01:08.130
那么这一块呢东西比较多 它要运用到很多的知识

01:08.130 --> 01:14.130
包括要用到views 登录有个登录状态 很多的主件它需要一个登录状态

01:14.130 --> 01:18.130
它知道要知道目前的用户有没有登录 它可能要显示不同的东西

01:18.130 --> 01:23.130
说要用到一个仓库 要配合viewrotor 为什么要配合viewrotor呢

01:23.130 --> 01:26.130
因为不同的页面呢 对登录的要求不一样

01:26.130 --> 01:31.130
比方说个人中心 个人中心的话它就不能是一个普通用

01:31.130 --> 01:35.130
就是不能说你没有登录跑进来 你必须要登录之后才能进来

01:35.130 --> 01:40.130
就是需要一个路由来控制 总之这一块东西蛮多的

01:40.130 --> 01:44.130
我们一块一块说 慢慢来 首先咱们看这个效果啊

01:44.130 --> 01:48.130
效果没有做成什么样子 我再把运行出来 慢慢来啊

01:48.130 --> 01:52.130
就不能着急的 如果说我自己写的话 他就写完了

01:52.130 --> 01:56.130
但是我要讲课的话 我就得慢慢来

01:56.130 --> 02:00.130
关掉啊 就这么一个样子啊

02:00.130 --> 02:04.130
样式做得很丑啊 大家直接忽略样式

02:04.130 --> 02:08.130
我们就关心功能 我们这里有好多页面 一个首页

02:08.130 --> 02:12.130
首页的四个人都能访问 你不用登录 我这里先退出登录

02:12.130 --> 02:16.130
你看这个逻辑 理性这个逻辑都还是没有那么容易啊

02:16.130 --> 02:20.130
首先这是一个首页 然后一开始你会发现这一块

02:20.130 --> 02:24.130
一个加载中的效果 为什么呢 为什么一个加载中呢

02:24.130 --> 02:28.130
加载啥呀 他加载看一下之前有没有登录过 如果说已经登录过了

02:28.130 --> 02:32.130
我就不用再登录了 那发现他现在没有登录

02:32.130 --> 02:35.130
没有登录的话他就显示一个登录 然后这里是一个新闻页

02:35.130 --> 02:39.130
新闻页的话是不能进的 他必须要登录之后才能进

02:39.130 --> 02:43.130
就是模拟我们网站中有一些页面 你没有登录是不能进的

02:44.130 --> 02:47.130
这是这个页面 你看我现在想尝试的

02:47.130 --> 02:51.130
从首页进入到新闻页 他给我提示

02:51.130 --> 02:54.130
然后这个提示的有点丑 大家直接忽略样式

02:54.130 --> 02:58.130
然后点击确定过后 他就给我跳转到登录页了 让我先登录

02:58.130 --> 03:01.130
有这么一个效果 这里也是一样

03:01.130 --> 03:05.130
进不去 然后我们这里 当然我们如果说直接刷新

03:05.130 --> 03:09.130
这个地方的地址是六四 我先不直接刷新吧

03:09.130 --> 03:12.130
我们先不直接刷新吧 直接刷新的一块还有个逻辑

03:12.130 --> 03:16.130
然后我们在登录 先登录吧 二字面 123 123

03:16.130 --> 03:20.130
登录成功 登录成功还会挑转到我们

03:20.130 --> 03:23.130
之前尝试进入那个新闻页 对吧 之前进不去

03:23.130 --> 03:26.130
现在登录成功过后还有自动进去了

03:26.130 --> 03:29.130
那如果说你之前没有尝试过任何页面 我们推出

03:29.130 --> 03:33.130
没有尝试过任何页面 我们直接刷新 直接进了登录页

03:33.130 --> 03:37.130
然后我们这里登录成功呢 他就会进入到首页

03:37.130 --> 03:40.130
你看这个逻辑 很多的

03:40.130 --> 03:43.130
接下来还有个人中心 这个个人中心也是一样的道理

03:43.130 --> 03:46.130
登录之后呢 这里有个超链接 点击可以进入个人中心

03:46.130 --> 03:48.130
但个人中心 我里边啥都没写

03:48.130 --> 03:51.130
这个人中心也是一样 它的地址是这个

03:51.130 --> 03:54.130
如果说你现在没有登录

03:54.130 --> 03:57.130
想尝试的进入那个个人中心 或者是进入新闻

03:57.130 --> 04:00.130
它会怎么样呢 我直接通过地址

04:00.130 --> 04:03.130
我们知道点是点不进去了 对吧 个人中心的链接都没了

04:03.130 --> 04:06.130
但是我们有可能会直接通过地址来进入

04:06.130 --> 04:09.130
60 它就会有一个状态 正在登录中

04:09.130 --> 04:12.130
它要恢复登录状态 它发现你没有登录

04:12.130 --> 04:14.130
然后呢 还算超链到登录页

04:14.130 --> 04:17.130
然后如果说我们进入个人中心 也是一样的

04:17.130 --> 04:19.130
它有个恢复登录状态的过程

04:19.130 --> 04:23.760
恢复完了过后 发现你没有登录 它会进入登录页

04:23.760 --> 04:25.760
就这么一个逻辑

04:25.760 --> 04:28.760
然后怎么样呢

04:28.760 --> 04:31.760
当然如果说我登录成功了 它又会挑回到

04:31.760 --> 04:34.760
你尝试进入那个页面

04:34.760 --> 04:37.760
登录成功 厉害 进入到个人中心了

04:37.760 --> 04:39.760
说到这一块逻辑呢 还蛮多的

04:39.760 --> 04:42.760
我们怎么来处理呢 我们一块一块处理

04:42.760 --> 04:45.760
首先搞定仓库 这里边肯定有一个仓库

04:45.760 --> 04:49.760
我们这里有个课件 课件给大家打开

04:49.760 --> 04:52.760
课件有些逻辑试译图 我们一会会用到

04:52.760 --> 04:55.760
还有一些参考资料 这一课是有一些新知识的

04:55.760 --> 04:58.760
我们一会会用到 因为像这些东西

04:58.760 --> 05:01.760
可能在讲课的过程中 我不可能说把这些

05:01.760 --> 05:04.760
API一个一个给拿出来给你们看 那疯了吧

05:04.760 --> 05:07.760
就是我们遇到一些细节问题的时候呢

05:07.760 --> 05:10.760
你大概都知道 有可能它给你提供了这样的功能

05:10.760 --> 05:13.760
让你去查一下文道 这些可能我会带大家

05:13.760 --> 05:16.760
去查一下文道

05:16.760 --> 05:19.760
好 我们这里边 现在我们看一下

05:19.760 --> 05:21.760
目前我们的代码 目前我把一些

05:21.760 --> 05:23.760
组件 央视都给你写好了

05:23.760 --> 05:26.760
安装的包呢 包括Viu和Rotor 其他都没了

05:26.760 --> 05:28.760
然后SRC里边 我们

05:28.760 --> 05:30.760
这个地方呢 我就用了一下Rotor

05:30.760 --> 05:32.760
我们来看一下Rotor吧

05:32.760 --> 05:34.760
Rotor里边也非常简单 我就两个组件

05:34.760 --> 05:36.760
一个是首页组件 一个是登陆组件

05:36.760 --> 05:39.760
分别有两个地址 首页和登陆

05:39.760 --> 05:42.760
非常简单啊 然后这边就导出就完了

05:42.760 --> 05:45.760
好 我们的跟组件里边呢

05:45.760 --> 05:47.760
有一个导航

05:47.760 --> 05:50.760
对导航 我们把运行出来吧 边运行边看吧

05:50.760 --> 05:52.760
我们再新开一个

05:52.760 --> 05:55.760
我们要搞定这个项目

05:55.760 --> 05:57.760
不能叫项目 就是这么一个demo

05:57.760 --> 06:04.620
运行出来啊

06:04.620 --> 06:06.620
运行啊

06:06.620 --> 06:08.620
目前是这个样子啊 一人丑啊

06:08.620 --> 06:11.620
看一下 目前是由一个导航啊 上面一个导航

06:11.620 --> 06:14.620
下边的是一个主区域 主区域就是这一块

06:14.620 --> 06:17.620
就是这一块 显示不同的页面的

06:17.620 --> 06:19.620
非常简单吧 上面的导航呢

06:19.620 --> 06:21.620
一个是到首页 很简单吧

06:21.620 --> 06:23.620
到首页

06:24.620 --> 06:27.620
然后呢 右边这一块呢 我用了一个组件

06:28.620 --> 06:31.620
它用来显示当前登录的用户名字

06:31.620 --> 06:33.620
在这个地方 有点恋

06:33.620 --> 06:35.620
目前呢 只有一些样式啊 样式不用看了

06:35.620 --> 06:38.620
然后呢 有这么一个 这个样式好像是多余的

06:38.620 --> 06:41.620
然后呢 有这么一个集中情况

06:41.620 --> 06:43.620
因为这个组件它要显示集中情况

06:43.620 --> 06:45.620
要么显示正在登录中

06:45.620 --> 06:47.620
恢复之前的登录状态

06:47.620 --> 06:49.620
要么显示当前登录的用户

06:49.620 --> 06:52.620
要 然后呢 加一个按钮退出

06:52.620 --> 06:54.620
要么就显示这个

06:54.620 --> 06:56.620
登录

06:56.620 --> 06:58.620
这样的情况 要么显示这个

06:58.620 --> 07:00.620
要么呢 显示这个

07:00.620 --> 07:02.620
要么呢 显示这个

07:04.620 --> 07:06.620
好 这是这一块啊

07:06.620 --> 07:08.620
那么上面的导航就完了啊 一个后面

07:08.620 --> 07:09.620
当然还有一个News 对吧

07:09.620 --> 07:11.620
News呢 我们加一个吧

07:11.620 --> 07:15.260
加一个News

07:15.260 --> 07:17.260
新闻列表

07:17.260 --> 07:20.260
好了 然后我们在Root里边加一个吧

07:20.260 --> 07:24.910
News

07:24.910 --> 07:26.910
这是哪一个

07:26.910 --> 07:31.570
News

07:31.570 --> 07:33.570
连接这里面呢 我加一个超连接啊

07:33.570 --> 07:37.070
那么这边就跳转了

07:37.070 --> 07:39.070
我这里就没有用那个命名录邮了啊

07:39.070 --> 07:41.070
直接来吧

07:41.070 --> 07:43.070
用命名录邮的话也不影响

07:43.070 --> 07:45.070
对吧 还有新闻列表

07:45.070 --> 07:47.070
目前都是可以访问的啊

07:47.070 --> 07:49.070
好 下面呢就是渲染那个仕途

07:49.070 --> 07:51.070
渲染我们的就是页面

07:51.070 --> 07:53.070
这三个页面 这三个页面啥都没有

07:53.070 --> 07:55.070
这个页面都是没有

07:55.070 --> 07:57.070
那么登录页面看一下 有个表单

07:57.070 --> 07:59.070
登录页呢 有个表单

07:59.070 --> 08:01.070
有什么账号 密码

08:01.070 --> 08:03.070
这个数据呢 我已经写好了

08:03.070 --> 08:05.070
然后注写了一个事件

08:05.070 --> 08:07.070
表单提交事件 表单提交的时候

08:07.070 --> 08:09.070
就运行这个函数 下面样式不用看了

08:09.070 --> 08:11.070
提交的时候呢

08:11.070 --> 08:13.070
我们就输出了一句话

08:13.070 --> 08:15.070
把当号密码打印出来

08:15.070 --> 08:17.070
好 咱们看一下吧 点击右键检查

08:17.070 --> 08:19.070
然后控制台

08:19.070 --> 08:21.070
这顺便说一下 控制台里边呢 这有两个

08:21.070 --> 08:23.070
两个提示啊 都不是警告

08:23.070 --> 08:25.070
它是一个提示

08:25.070 --> 08:27.070
这个提示里呢 它说我有Rotor啊

08:27.070 --> 08:29.070
因为你们看个课程的时候呢 可能又过了一段时间了

08:29.070 --> 08:31.070
这个Rotor里边呢 有一些东西呢

08:31.070 --> 08:33.070
建议你不要使用了啊

08:33.070 --> 08:35.070
已经过期了 一个是Type

08:35.070 --> 08:37.070
Type这个标签

08:37.070 --> 08:39.070
就是一个是Event

08:39.070 --> 08:41.070
啥意思呢 它这里个链接让你进去看一下

08:41.070 --> 08:43.070
就是说呢 它里边有这么一个属性

08:43.070 --> 08:45.070
和这么一个属性

08:45.070 --> 08:47.070
它已经过期了

08:47.070 --> 08:49.070
让你的建议你不要使用了啊

08:49.070 --> 08:51.070
这两个属性呢 我目前也没用到

08:51.070 --> 08:53.070
这些东西呢 我觉得

08:53.070 --> 08:55.070
有没有必要讲 我之后再说吧

08:55.070 --> 08:57.070
我觉得

08:57.070 --> 08:59.070
好讲的 要讲的话 我之后再说吧

08:59.070 --> 09:01.070
因为这个API太多了

09:01.070 --> 09:03.070
好

09:03.070 --> 09:05.070
现在就是这个东西啊 我们账号随便输入一个密码

09:05.070 --> 09:07.070
随便输入一个点击

09:07.070 --> 09:09.070
把账号密码输入出来了 就是我们目前的工程

09:09.070 --> 09:11.070
然后这边呢 有个文件夹是API

09:11.070 --> 09:13.070
我们目前没有用到 以后肯定要用的

09:13.070 --> 09:15.070
这里边就是远程通信

09:15.070 --> 09:17.070
阿迦克斯 因为登录肯定是

09:17.070 --> 09:19.070
涉及到跟服务器之间通信嘛

09:19.070 --> 09:21.070
那么在登录里边啊

09:21.070 --> 09:23.070
在用户登录啊 注册 这里没有注册

09:23.070 --> 09:25.070
注册就加个方法就完成了

09:25.070 --> 09:27.070
一般来说服务器

09:27.070 --> 09:29.070
会给你三个接口

09:29.070 --> 09:31.070
一般来说哈

09:31.070 --> 09:33.070
然后这个东西 你要说

09:33.070 --> 09:35.070
原来到了工程里面 为什么他给我五个

09:35.070 --> 09:37.070
六个 他为什么是给我两个

09:37.070 --> 09:39.070
那我怎么知道 你的工程自己

09:39.070 --> 09:41.070
但是基本上至少有两个接口 他要给你

09:41.070 --> 09:43.070
一个是登录接口

09:43.070 --> 09:45.070
我这里呢 就

09:45.070 --> 09:47.070
我这里就没有写的 因为我这里没有服务器

09:47.070 --> 09:49.070
虽然我这里有一个服务器

09:49.070 --> 09:51.070
就是我自己的服务器 但是呢

09:51.070 --> 09:53.070
我还是不愿意在课堂里面

09:53.070 --> 09:55.070
用我那个服务器

09:55.070 --> 09:57.070
不是说我认识 是因为我那个服务器

09:57.070 --> 09:59.070
万一改动过后里面就用不了了

09:59.070 --> 10:01.070
就是说你一个阿迦克斯请求去

10:01.070 --> 10:03.070
请求一个API POST的请求

10:03.070 --> 10:05.070
把登录账号和密码传过去

10:05.070 --> 10:07.070
他登录成功了 他会给你一个用户对象

10:07.070 --> 10:09.070
如果说登录失败了

10:09.070 --> 10:11.070
他会给你一个用户对象就是NOW

10:11.070 --> 10:13.070
或者是一些别的决定

10:13.070 --> 10:15.070
我这里呢 就魔力的一下

10:15.070 --> 10:17.070
就非常非常简单的魔力的一下

10:17.070 --> 10:19.070
假设你登录账号是ERDME

10:19.070 --> 10:21.070
密码是123123

10:21.070 --> 10:23.070
否则的话我就给你反馈拉

10:23.070 --> 10:25.070
表示没有登录成功

10:25.070 --> 10:27.070
魔力服务器的响应结果

10:27.070 --> 10:29.070
然后登录成功怎么办呢

10:29.070 --> 10:31.070
登录成功就魔力的一个用户对象

10:31.070 --> 10:33.070
账号和名字

10:33.070 --> 10:35.070
他一般不会给你密码的

10:35.070 --> 10:37.070
不会给你传一个密码过来

10:37.070 --> 10:39.070
然后我就把他保存到Local Storage里边

10:39.070 --> 10:41.070
为什么保存到Local Storage

10:41.070 --> 10:43.070
这是网络通信的知识

10:43.070 --> 10:45.070
一般来说服务器那边会给你一个Cookie

10:45.070 --> 10:47.070
那么你就把个Cookie保存下来就ok了

10:47.070 --> 10:49.070
或者是给你一个用户

10:49.070 --> 10:51.070
把用户保存到Local Storage里边

10:51.070 --> 10:53.070
或者是给你一个什么GWT

10:53.070 --> 10:55.070
不知道大家有没有学过这个玩意

10:57.070 --> 10:59.070
叫接生web token

10:59.070 --> 11:01.070
总之他会给你一个东西

11:01.070 --> 11:03.070
来表示你已经登录成功了

11:03.070 --> 11:05.070
会给你一个表示这个用户的东西

11:05.070 --> 11:07.070
那么这个用户的东西呢

11:07.070 --> 11:09.070
要么就自动存在Cookie里边

11:09.070 --> 11:11.070
要么就可以手动的存到Local Storage里边

11:11.070 --> 11:13.070
我这里存到Local Storage里的

11:13.070 --> 11:15.070
那么这里是魔力服务器的响应结果

11:15.070 --> 11:17.070
我这里当然没有服务器

11:18.070 --> 11:19.070
好

11:19.070 --> 11:20.070
这个什么东西的

11:20.070 --> 11:22.070
这个就我写了一个

11:22.070 --> 11:23.070
魔力的函数

11:23.070 --> 11:24.070
就是等待一段时间

11:24.070 --> 11:25.070
来魔力网络通信

11:25.070 --> 11:27.070
我这里等了一秒钟

11:27.070 --> 11:28.070
这登录结果

11:28.070 --> 11:29.070
服务器在多登录的时候

11:29.070 --> 11:30.070
服务器一般

11:30.070 --> 11:31.070
肯定会给你提供一个登录结果

11:31.070 --> 11:33.070
这是毫无疑问的

11:33.070 --> 11:34.070
那么具体的情况呢

11:34.070 --> 11:36.070
一看登录结果怎么弄

11:36.070 --> 11:38.070
看给力的事啥

11:38.070 --> 11:39.070
另外呢就是

11:39.070 --> 11:40.070
还会给你提供一个结果

11:40.070 --> 11:41.070
叫互外卖

11:41.070 --> 11:42.070
这个名字呢

11:42.070 --> 11:43.070
不一定是这个名字

11:43.070 --> 11:45.070
它是用来恢复登录状态的

11:45.070 --> 11:46.070
比方说我今天登录了

11:46.070 --> 11:48.070
我明天就不想登录了

11:48.070 --> 11:49.070
每一次的都

11:49.070 --> 11:51.070
每一次刷新流耐器都登录

11:51.070 --> 11:52.070
我要封掉了

11:52.070 --> 11:53.070
所以说呢

11:53.070 --> 11:54.070
因为我们Cookie里边也好

11:54.070 --> 11:56.070
local storage里边也好

11:56.070 --> 11:58.070
是保存了之前那个登录的

11:58.070 --> 11:59.070
那个状态的

11:59.070 --> 12:01.070
那个状态有可能是一个用户ID

12:01.070 --> 12:03.070
有可能是一个JWT

12:03.070 --> 12:04.070
说不准是啥

12:04.070 --> 12:05.070
看你服务器给力的是啥

12:05.070 --> 12:06.070
我现在呢都比较流行

12:06.070 --> 12:07.070
JWT的

12:07.070 --> 12:09.070
我这边就保存个用户对象

12:09.070 --> 12:10.070
然后呢

12:10.070 --> 12:12.070
他希望你下一次的时候

12:12.070 --> 12:14.070
你要看一下有没有登录

12:14.070 --> 12:15.070
你就把那个东西

12:15.070 --> 12:17.070
又重新传给服务器

12:17.070 --> 12:18.070
就是你之前保存那个东西

12:18.070 --> 12:19.070
重新传给服务器

12:19.070 --> 12:20.070
然后服务器就会

12:20.070 --> 12:21.070
根据这个东西

12:21.070 --> 12:22.070
比方说这个JWT

12:22.070 --> 12:24.070
JWT就是一个水智无串

12:24.070 --> 12:25.070
也不是水智无串

12:25.070 --> 12:27.070
就是一个很长的一个

12:27.070 --> 12:28.070
智无串

12:28.070 --> 12:30.070
我瞎写一下

12:30.070 --> 12:31.070
很长的东西

12:31.070 --> 12:33.070
你把这个东西给服务器

12:33.070 --> 12:34.070
服务器会告诉你

12:34.070 --> 12:36.070
你之前登录的用户是啥

12:36.070 --> 12:38.070
如果说这个东西过时了

12:38.070 --> 12:39.070
或者是无效的

12:39.070 --> 12:41.070
那么服务器会给你一个

12:41.070 --> 12:42.070
表示你没有登录

12:42.070 --> 12:43.070
他会给你说明

12:43.070 --> 12:44.070
会给你一个响应

12:44.070 --> 12:45.070
我这边就模拟的

12:45.070 --> 12:46.070
因为我没有服务器

12:46.070 --> 12:47.070
就模拟的

12:47.070 --> 12:49.070
就是我这等待一秒钟

12:49.070 --> 12:50.070
模拟网络通信

12:50.070 --> 12:51.070
我这边就直接

12:51.070 --> 12:52.070
从那个Story级别拿了

12:52.070 --> 12:53.070
里面以后不能这样拿

12:53.070 --> 12:55.070
要把这个东西

12:55.070 --> 12:56.070
扔给服务器

12:56.070 --> 12:57.070
让服务器去看一下

12:57.070 --> 12:58.070
如果说你是

12:58.070 --> 13:00.070
之前是放到Cookie里边的话

13:00.070 --> 13:01.070
那么浏览器

13:01.070 --> 13:02.070
他会自动把Cookie发动到服务器

13:02.070 --> 13:03.070
服务器会告诉你

13:03.070 --> 13:04.070
有没有登录成功

13:04.070 --> 13:05.070
他会给你一个用户

13:05.070 --> 13:07.070
如果说这个用户有值

13:07.070 --> 13:08.070
表示说这个登录已经成功了

13:08.070 --> 13:10.070
我就把一个用户返回

13:10.070 --> 13:11.070
如果说登录没有值

13:12.070 --> 13:13.070
就这么个逻辑

13:13.070 --> 13:14.070
这是服务器接口

13:16.070 --> 13:18.070
然后我又做了一个

13:18.070 --> 13:19.070
助销

13:19.070 --> 13:20.070
助销这个玩意

13:20.070 --> 13:22.070
有些服务器就不管了

13:22.070 --> 13:23.070
你自己去散出Cookie

13:23.070 --> 13:25.070
或者是散出的Cookie

13:25.070 --> 13:26.070
之前保存的东西

13:26.070 --> 13:27.070
那么就表示助销了

13:27.070 --> 13:29.070
有些服务器必须要让你

13:29.070 --> 13:30.070
发送到服务器一次

13:30.070 --> 13:31.070
怎么发送

13:31.070 --> 13:32.070
你不需要发送任何参数

13:32.070 --> 13:33.070
你就请求一个地址

13:33.070 --> 13:34.070
服务器就知道了

13:34.070 --> 13:35.070
你要做助销

13:35.070 --> 13:36.070
因为有些服务器

13:36.070 --> 13:37.070
他可能要记录一下

13:37.070 --> 13:39.070
你什么时候助销的

13:39.070 --> 13:40.070
所以说需要你发

13:40.070 --> 13:41.070
一个东西过去

13:41.070 --> 13:42.070
那么我这里呢

13:42.070 --> 13:43.070
就用魔力的一下

13:43.070 --> 13:44.070
等待一秒钟

13:44.070 --> 13:45.070
然后我側面

13:45.070 --> 13:47.070
就把德克斯多尔吉移除了

13:47.070 --> 13:48.070
来魔力网络通信

13:48.070 --> 13:49.070
这三个方法

13:49.070 --> 13:50.070
全都是魔力

13:50.070 --> 13:51.070
你不要代码了

13:51.070 --> 13:52.070
没有任何参考信

13:52.070 --> 13:53.070
我只是告诉你

13:53.070 --> 13:54.070
将来你们在公司里边

13:54.070 --> 13:55.070
做登录的时候

13:55.070 --> 13:57.070
那么这些东西是要齐全的

13:57.070 --> 13:58.070
如果说你现在

13:58.070 --> 13:59.070
实在听不懂我说啥的话

13:59.070 --> 14:00.070
那也没关系

14:00.070 --> 14:02.070
因为我们之后要做后台

14:02.070 --> 14:03.070
做后台的话

14:03.070 --> 14:04.070
那边是

14:04.070 --> 14:05.070
需要有服务器接口

14:05.070 --> 14:06.070
要做登录的接口的

14:06.070 --> 14:08.070
我们到时候会魔力输去

14:08.070 --> 14:10.070
那一块就比较真实一点的情况

14:10.070 --> 14:12.070
现在不用管

14:12.070 --> 14:13.070
好

14:13.070 --> 14:14.070
那么现在呢

14:14.070 --> 14:15.070
我们只需要知道

14:15.070 --> 14:16.070
这里有三个API

14:16.070 --> 14:17.070
这是跟服务器通信的

14:17.070 --> 14:18.070
跟不用有关系吗

14:18.070 --> 14:19.070
没关系

14:19.070 --> 14:20.070
跟什么仓库有关系吗

14:20.070 --> 14:21.070
没关系

14:21.070 --> 14:22.070
它就是来跟服务器通信的

14:22.070 --> 14:23.070
三个方法

14:23.070 --> 14:24.070
调用这个

14:24.070 --> 14:25.070
登录

14:25.070 --> 14:26.070
登录成功

14:26.070 --> 14:27.070
返回够用户对象

14:27.070 --> 14:28.070
登录失败

14:28.070 --> 14:29.070
返回一个loud

14:29.070 --> 14:30.070
logging out

14:30.070 --> 14:31.070
助销

14:31.070 --> 14:32.070
不会有任何返回

14:32.070 --> 14:33.070
一定助销成功

14:33.070 --> 14:34.070
然后固然卖

14:34.070 --> 14:35.070
恢复登录

14:35.070 --> 14:36.070
对吧

14:37.070 --> 14:38.070
发出一个请求

14:38.070 --> 14:39.070
它会

14:39.070 --> 14:40.070
这个方法运行完过后

14:40.070 --> 14:41.070
它会告诉我

14:41.070 --> 14:42.070
如果说恢复成功了

14:42.070 --> 14:43.070
返回一个用户对象

14:43.070 --> 14:44.070
恢复失败了

14:44.070 --> 14:45.070
返回loud

14:45.070 --> 14:46.070
恢复失败

14:46.070 --> 14:47.070
就表示登录过期了

14:47.070 --> 14:49.070
或者是之前就没有登录过

14:49.070 --> 14:51.070
就有这么三个方法

14:51.070 --> 14:52.070
这需要服务器配合的

14:52.070 --> 14:54.070
这是就是我们的工程

14:54.070 --> 14:56.070
你也可以拿到我们的代码过后

14:56.070 --> 14:57.070
好好去看一下

14:57.070 --> 14:58.070
首先

14:58.070 --> 14:59.070
之前的代码你一定要写

14:59.070 --> 15:00.070
就上节课

15:00.070 --> 15:01.070
之前的代码你一定要写过

15:01.070 --> 15:03.070
然后呢

15:03.070 --> 15:04.070
再充分的理解一下

15:04.070 --> 15:05.070
目前的工程情况

15:05.070 --> 15:07.070
接下来我们开始玩了

15:07.070 --> 15:08.070
怎么玩呢

15:08.070 --> 15:10.070
首先你肯定得有一个仓库

15:10.070 --> 15:11.070
为什么得有仓库

15:11.070 --> 15:12.070
你看这个组建

15:12.070 --> 15:14.070
这个组建是不是

15:14.070 --> 15:16.070
会改变当前登录的用户

15:16.070 --> 15:17.070
登录成功了

15:17.070 --> 15:19.070
是不是当前的登录用户就变了

15:19.070 --> 15:20.070
当前登录的用户变了

15:20.070 --> 15:22.070
会影响到这个组建

15:22.070 --> 15:23.070
这个组建是不是

15:23.070 --> 15:24.070
要根据当前有没有登录用户

15:24.070 --> 15:26.070
来显示不同的东西

15:26.070 --> 15:27.070
对吧

15:27.070 --> 15:28.070
而这个组建里边

15:28.070 --> 15:30.070
这个退出是不是又会影响到

15:30.070 --> 15:32.070
当前登录的用户

15:32.070 --> 15:33.070
对不对

15:33.070 --> 15:34.070
然后这个组建

15:34.070 --> 15:35.070
新闻组建

15:35.070 --> 15:37.070
它是不是没有登录用户的时候

15:37.070 --> 15:39.070
是不是需要那个不能进入

15:39.070 --> 15:40.070
对吧

15:40.070 --> 15:42.070
还要包括那个用户中个人中心

15:42.070 --> 15:43.070
个人中心

15:43.070 --> 15:44.070
这里还没有写

15:44.070 --> 15:45.070
没有写出来

15:45.070 --> 15:46.070
将来会有个个人中心

15:46.070 --> 15:48.070
那也是没有登录的时候

15:48.070 --> 15:49.070
是不能进入的

15:49.070 --> 15:50.070
所以说很多组建

15:50.070 --> 15:52.070
它都需要用到同一个状态

15:52.070 --> 15:54.070
就是当前登录的用户到底是谁

15:54.070 --> 15:56.070
有没有登录

15:56.070 --> 15:58.070
甚至是不是正在登录中

15:58.070 --> 16:00.070
这些状态的我们都需要用到

16:00.070 --> 16:01.070
那么我们自然而然

16:01.070 --> 16:03.070
要做一个数据仓库出来

16:04.070 --> 16:05.070
好吧

16:05.070 --> 16:06.070
那么怎么来做数据仓库呢

16:06.070 --> 16:08.070
我们先拋开什么5U的组建数

16:08.070 --> 16:10.070
我们直接这个文件夹

16:10.070 --> 16:14.830
这里写一个index.js文件

16:14.830 --> 16:16.830
那么这边就按不不就搬来写

16:16.830 --> 16:17.830
我上节课写过了

16:17.830 --> 16:19.830
这里还有一些仓库的一些小的

16:19.830 --> 16:20.830
开发细节

16:20.830 --> 16:22.830
from vx

16:22.830 --> 16:24.830
如果说你一次听不懂的话

16:24.830 --> 16:26.830
反复的听几次

16:26.830 --> 16:28.830
你把这个玩意儿做出来了

16:28.830 --> 16:29.830
过后你rotor的一块

16:29.830 --> 16:31.830
包括vx这一块

16:31.830 --> 16:33.830
就用得比较熟练了

16:34.830 --> 16:38.460
这里导入viu

16:38.460 --> 16:39.460
首先我们应用这个插件

16:39.460 --> 16:41.460
viu use vx

16:41.460 --> 16:42.460
是不是应用插件

16:42.460 --> 16:44.460
然后我们这里要导出一个什么玩意儿

16:44.460 --> 16:45.460
导出一个仓库

16:45.460 --> 16:46.460
为了方便测试

16:46.460 --> 16:48.460
我还是先把它保存到温度里面吧

16:48.460 --> 16:49.460
这里我们留一个viux

16:49.460 --> 16:50.460
叫store

16:53.460 --> 16:55.460
我这里好像没有安装了

16:55.460 --> 16:57.460
好像没安装viux

16:57.460 --> 16:59.460
安装一下了

16:59.460 --> 17:01.460
我说这没提示呢

17:01.460 --> 17:03.460
创建一个仓库

17:03.460 --> 17:04.460
这里配置先暂时不着急

17:04.460 --> 17:06.460
然后这里把window

17:06.460 --> 17:08.460
store保存到window里面

17:08.460 --> 17:10.460
方便测试

17:10.460 --> 17:12.460
然后export

17:12.460 --> 17:13.460
因为我个人习惯了

17:13.460 --> 17:14.460
写仓库的时候

17:14.460 --> 17:15.460
我就想脱离viu逐渐

17:15.460 --> 17:17.460
我不想看什么viu逐渐

17:17.460 --> 17:19.460
我直接通过对象来测试就行了

17:19.460 --> 17:20.460
因为仓库本身呢

17:20.460 --> 17:22.460
它就相对独立的

17:22.460 --> 17:23.460
导出仓库过后

17:23.460 --> 17:24.460
我们在MediaJS里面

17:24.460 --> 17:25.460
是不是要应用这个仓库

17:25.460 --> 17:27.460
store

17:29.460 --> 17:31.460
然后这边把store放进来

17:31.460 --> 17:32.460
我们就把仓库

17:32.460 --> 17:33.460
加到我们的viu

17:33.460 --> 17:35.460
整个系统里面去了

17:35.460 --> 17:37.460
NPM装设备再打开看一下

17:37.460 --> 17:43.020
打开啊

17:43.020 --> 17:44.020
现在我们点击右键检查

17:44.020 --> 17:45.020
我们现在就多了一个

17:45.020 --> 17:47.020
多了一个store对象了

17:47.020 --> 17:48.020
这就是我们的仓库

17:48.020 --> 17:50.020
不过那目前有状态吗

17:50.020 --> 17:51.020
有状态吗

17:51.020 --> 17:52.020
没有什么状态

17:52.020 --> 17:53.020
是空的对吧

17:53.020 --> 17:54.020
状态是空的

17:54.020 --> 17:56.020
啥都没有

17:56.020 --> 17:57.020
然后呢

17:57.020 --> 17:59.020
我们现在进入这个仓库

17:59.020 --> 18:00.020
我们这里有什么状态呢

18:00.020 --> 18:01.020
无非就是一个登陆用户

18:01.020 --> 18:02.020
对不对

18:02.020 --> 18:04.020
当前登陆的用户是啥

18:04.020 --> 18:05.020
那么登陆用户里边

18:05.020 --> 18:06.020
有很多很多的信息

18:06.020 --> 18:08.020
包括是不是正在登陆中啊

18:08.020 --> 18:10.020
登陆成功过后的那个

18:10.020 --> 18:11.020
那个状态又是啥呀

18:11.020 --> 18:12.020
登陆失败过后的那个状态又是啥

18:12.020 --> 18:13.020
对不对

18:13.020 --> 18:15.020
是不是我们要写个locking user

18:15.020 --> 18:17.020
有没有这个登陆用户的状态

18:17.020 --> 18:18.020
这里是个stat

18:18.020 --> 18:19.020
写个stat

18:19.020 --> 18:20.020
我们这里呢

18:20.020 --> 18:22.020
有没有locking user这个状态

18:22.020 --> 18:24.020
没了意思吧

18:25.020 --> 18:27.020
这里有可能有很多数据

18:27.020 --> 18:28.020
是不是正在登陆中啊

18:28.020 --> 18:30.020
一开始没有登陆

18:30.020 --> 18:32.020
登陆成功过后

18:33.020 --> 18:34.020
那个用户是啥呀

18:34.020 --> 18:35.020
对不对

18:35.020 --> 18:36.020
那默认是那

18:37.020 --> 18:39.020
这是登陆成功的用户对象

18:39.020 --> 18:40.020
这是

18:40.020 --> 18:42.020
当前登陆的用户对象

18:44.020 --> 18:46.020
用户对象

18:46.020 --> 18:47.020
这是

18:48.020 --> 18:51.020
是否正在登陆中

18:51.020 --> 18:52.020
那么写到这呢

18:52.020 --> 18:53.020
其实就已经有疑问了

18:53.020 --> 18:54.020
为什么有些人说

18:54.020 --> 18:55.020
为什么要放个封装到这呢

18:55.020 --> 18:57.020
你直接写到这不行吗

18:57.020 --> 18:58.020
其实直接写到这呢

18:58.020 --> 19:00.020
也没啥问题

19:00.020 --> 19:01.020
只剩下我考虑到

19:01.020 --> 19:03.020
考虑到这么一个情况

19:03.020 --> 19:04.020
这是我们的仓库

19:04.020 --> 19:06.020
一个系统里边

19:06.020 --> 19:08.020
大部分情况下只有一个仓库

19:08.020 --> 19:10.020
那这个仓库里面东西特别多啊

19:10.020 --> 19:12.020
因为我这里呢只是用了

19:12.020 --> 19:13.020
当然我们这个系统里面

19:13.020 --> 19:15.020
只关心那个登陆用户

19:15.020 --> 19:17.020
那如果说一个大真实的系统里面

19:17.020 --> 19:18.020
一个大的系统里面

19:18.020 --> 19:20.020
它可能不光有登陆用户

19:20.020 --> 19:21.020
是在仓库里面

19:21.020 --> 19:23.020
还有什么新闻列表啊

19:23.020 --> 19:25.020
还有网站的全局设置啊

19:25.020 --> 19:26.020
用户的隐私设置啊

19:26.020 --> 19:27.020
个人偏好设置啊

19:27.020 --> 19:28.020
等等等等

19:28.020 --> 19:29.020
可能有仓库里面

19:29.020 --> 19:31.020
有很多很多的数据

19:31.020 --> 19:32.020
那如果说你这样子

19:32.020 --> 19:33.020
这样子排列的话

19:33.020 --> 19:35.020
那是不是就特别容易

19:35.020 --> 19:36.020
导致那个

19:36.020 --> 19:37.020
秘密冲突对不对

19:37.020 --> 19:39.020
而且呢非常难以管理

19:39.020 --> 19:40.020
所以说我们这边

19:40.020 --> 19:41.020
把包含到这里面

19:41.020 --> 19:42.020
其实包含到这里面

19:42.020 --> 19:43.020
能够解决这个问题吗

19:43.020 --> 19:44.020
也解决不了

19:44.020 --> 19:45.020
比方说我们将来

19:45.020 --> 19:46.020
是写了个矛盾形式

19:46.020 --> 19:47.020
我们写一块的话

19:47.020 --> 19:49.020
就慢慢把这块解释清楚

19:49.020 --> 19:50.020
写矛盾形的时候

19:50.020 --> 19:51.020
我们是不是可能会

19:51.020 --> 19:52.020
针对这个状态

19:52.020 --> 19:53.020
有不同的状态变化

19:53.020 --> 19:54.020
对吧

19:54.020 --> 19:55.020
我们这里可能会设置

19:55.020 --> 19:56.020
这个楼顶

19:56.020 --> 19:57.020
楼顶状态

19:57.020 --> 19:58.020
有可能会改变这个

19:58.020 --> 19:59.020
由于优导的状态

19:59.020 --> 20:00.020
那将来还有一些

20:00.020 --> 20:01.020
别的共享出去

20:01.020 --> 20:02.020
是不是有写到一大堆模特形

20:02.020 --> 20:05.020
那么就特别容易导致

20:05.020 --> 20:06.020
一是名字冲突

20:06.020 --> 20:07.020
模特形的名字冲突

20:07.020 --> 20:08.020
因为这里的方法名字

20:08.020 --> 20:09.020
是唯一的嘛

20:09.020 --> 20:10.020
名字冲突

20:10.020 --> 20:11.020
还有X也是不是

20:11.020 --> 20:12.020
也是同样的问题

20:12.020 --> 20:14.020
一是容易导致名字冲突

20:14.020 --> 20:15.020
二是呢

20:15.020 --> 20:17.020
这些状态混杂在一起

20:17.020 --> 20:19.020
没有起到一个很好的隔离

20:19.020 --> 20:20.020
那怎么办呢

20:20.020 --> 20:21.020
其实有一种

20:21.020 --> 20:23.020
比较好的办法就是这个

20:23.020 --> 20:24.020
然后我们遇到

20:24.020 --> 20:25.020
一个问题就可以解决

20:25.020 --> 20:27.020
其实你写到这的时候

20:27.020 --> 20:29.020
按照有一点开发经验的话

20:29.020 --> 20:30.020
当然你们现在

20:30.020 --> 20:31.020
可能开发经验不足

20:31.020 --> 20:32.020
慢慢去感知

20:32.020 --> 20:33.020
像这些东西

20:33.020 --> 20:34.020
你相信

20:34.020 --> 20:36.020
相信这个框架

20:36.020 --> 20:37.020
或者叫插件

20:37.020 --> 20:39.020
它一定是帮你解决的

20:39.020 --> 20:40.020
你去看一下

20:40.020 --> 20:42.020
这个威尔格斯的官方文档

20:42.020 --> 20:43.020
你多多少少的

20:43.020 --> 20:44.020
都给人看得到

20:44.020 --> 20:45.020
有点影子的

20:45.020 --> 20:46.020
他们肯定想到这个问题了

20:46.020 --> 20:47.020
那怎么办呢

20:47.020 --> 20:48.020
这个问题解决的办法

20:48.020 --> 20:49.020
就是Modules

20:49.020 --> 20:52.020
这里有一个就是

20:52.020 --> 20:53.020
官方文档

20:53.020 --> 20:54.020
他告诉你

20:54.020 --> 20:55.020
我们来解决这个问题

20:55.020 --> 20:56.020
怎么解决呢

20:56.020 --> 20:57.020
他可以把

20:57.020 --> 20:58.020
他可以把不同的

20:58.020 --> 20:59.020
状态啊

20:59.020 --> 21:00.020
Motation啊

21:00.020 --> 21:01.020
Action啊

21:01.020 --> 21:02.020
这些东西

21:02.020 --> 21:03.020
接着是我们之后再说吧

21:03.020 --> 21:05.020
遇到的用了的时候再说

21:05.020 --> 21:06.020
把这些东西呢

21:06.020 --> 21:07.020
单独的去放到

21:07.020 --> 21:08.020
一个配置对象里面

21:08.020 --> 21:09.020
你看另外一个模块

21:09.020 --> 21:11.020
他就单独去放一个

21:11.020 --> 21:12.020
他的状态

21:12.020 --> 21:13.020
他的Motation

21:13.020 --> 21:14.020
他的Action

21:14.020 --> 21:15.020
然后最终的

21:15.020 --> 21:17.020
把它合并到跟状态里面

21:17.020 --> 21:18.020
通过这个配置

21:18.020 --> 21:19.020
Modules

21:19.020 --> 21:21.020
把它合并到跟状态里面

21:21.020 --> 21:22.020
就这么个意思

21:22.020 --> 21:23.020
那么之后的状态

21:23.020 --> 21:25.020
就是我们把

21:25.020 --> 21:26.020
按照这样子写

21:26.020 --> 21:27.020
写出来就知道了

21:27.020 --> 21:28.020
我们这里呢

21:28.020 --> 21:29.020
比方说我们写个Login user

21:29.020 --> 21:31.020
单独去写个模块

21:31.020 --> 21:33.020
那么这个模块呢

21:33.020 --> 21:35.020
Export

21:35.020 --> 21:37.020
现在跟5u都没什么关系啊

21:37.020 --> 21:38.020
注意啊

21:38.020 --> 21:39.020
我这里是可以配置

21:39.020 --> 21:40.020
他的State

21:40.020 --> 21:42.020
他的Motations

21:44.020 --> 21:46.020
Motations

21:46.020 --> 21:48.020
他的Action

21:50.020 --> 21:51.020
会去配置他的

21:51.020 --> 21:52.020
然后呢

21:52.020 --> 21:54.020
比方我还有一些别的模块

21:54.020 --> 21:55.020
比方是Counter

21:55.020 --> 21:57.020
随便写个吧

21:57.020 --> 21:59.020
那么他也导出一个配置对象

21:59.020 --> 22:00.020
仓库的配置对象

22:00.020 --> 22:01.020
他也有自己的State

22:01.020 --> 22:03.020
比方他就只有Count

22:03.020 --> 22:04.020
之前呢

22:04.020 --> 22:05.020
我们刚才写的

22:05.020 --> 22:07.020
有一个Login

22:07.020 --> 22:09.020
Force

22:09.020 --> 22:10.020
有一个User

22:10.020 --> 22:12.020
当前能用的用户

22:13.020 --> 22:14.020
就例子

22:15.020 --> 22:16.020
那么这个Counter

22:16.020 --> 22:17.020
只有一个Count

22:17.020 --> 22:19.020
他有可能有自己的Motations

22:19.020 --> 22:21.020
有可能有自己的Actions

22:21.020 --> 22:22.020
你要的意思吧

22:22.020 --> 22:24.020
他就写的不同的模块里边

22:24.020 --> 22:25.020
然后我们最终在

22:25.020 --> 22:26.020
这个Index里边吧

22:26.020 --> 22:27.020
把他导入进来

22:27.020 --> 22:29.020
一个Counter

22:33.020 --> 22:38.930
然后再导出一个Login user

22:38.930 --> 22:39.930
然后我们在这边

22:39.930 --> 22:41.930
就不需要这些东西了

22:41.930 --> 22:42.930
我们自己在这里

22:42.930 --> 22:43.930
直接写个Modules

22:43.930 --> 22:44.930
配置我们的模块

22:44.930 --> 22:45.930
一个Counter

22:45.930 --> 22:47.930
一个Login user

22:47.930 --> 22:48.930
好,咱们来看一下

22:48.930 --> 22:49.930
我们目前的仓库

22:49.930 --> 22:50.930
变成这个样子了

22:53.750 --> 22:55.750
好,我们再看Wheel

22:55.750 --> 22:56.750
这些Wheels

22:56.750 --> 22:57.750
看我们的仓库

22:57.750 --> 22:59.750
你看我们的状态里边

22:59.750 --> 23:00.750
所以有个模块

23:00.750 --> 23:01.750
Counter

23:01.750 --> 23:03.750
Counter里边有自己的状态

23:03.750 --> 23:05.750
看看一说一个Count

23:05.750 --> 23:06.750
然后Login user

23:06.750 --> 23:07.750
说这个模块

23:07.750 --> 23:09.750
那么这个模块里边有自己的状态

23:09.750 --> 23:10.750
Login user

23:10.750 --> 23:12.750
他就变成这种结构了

23:12.750 --> 23:14.750
所以这样的更加方便管理一点

23:14.750 --> 23:15.750
当然了

23:15.750 --> 23:16.750
这个模块的名字

23:16.750 --> 23:17.750
不是文件名

23:17.750 --> 23:18.750
是这个属性名

23:18.750 --> 23:19.750
比方说你这个属性

23:19.750 --> 23:20.750
我这个ABC

23:20.750 --> 23:21.750
那就是ABC

23:22.750 --> 23:25.510
你看

23:25.510 --> 23:26.510
这变成ABC了

23:26.510 --> 23:28.510
这个属性名

23:29.510 --> 23:31.510
好,我就把它分到不可能的模块里边

23:31.510 --> 23:32.510
那么我现在这个模块

23:32.510 --> 23:33.510
就不用去管它了

23:33.510 --> 23:34.510
我们就看这个模块

23:35.510 --> 23:36.510
好,那么这个模块

23:36.510 --> 23:37.510
有哪些事情要做呢

23:37.510 --> 23:38.510
这里有两个

23:38.510 --> 23:39.510
在当登入用户这一块

23:39.510 --> 23:41.510
它有两个状态

23:41.510 --> 23:42.510
一个是Login

23:42.510 --> 23:44.510
表示当前是不是正在登入中

23:44.510 --> 23:45.510
因为是远程

23:45.510 --> 23:47.510
传输嘛,需要一段时间

23:47.510 --> 23:49.510
一个是

23:49.510 --> 23:51.510
当前登入成功的用户

23:51.510 --> 23:52.510
是啥

23:52.510 --> 23:53.510
好,那么我们这里有两个状态

23:53.510 --> 23:54.510
我们当然

23:54.510 --> 23:55.510
在Multi-Action里边

23:55.510 --> 23:57.510
我们很有可能

23:57.510 --> 23:58.510
极大可能我们就要会设置

23:58.510 --> 23:59.510
两个Multi-Action

23:59.510 --> 24:00.510
因为我们有两个状态图变

24:00.510 --> 24:02.510
一个是setLogin

24:02.510 --> 24:04.510
它把原来的状态传过来

24:04.510 --> 24:06.510
然后给我一个

24:06.510 --> 24:07.510
你知道把它设置为True

24:07.510 --> 24:08.510
还是Force

24:08.510 --> 24:09.510
给我一个Payload的

24:09.510 --> 24:10.510
我就干嘛呀

24:10.510 --> 24:11.510
我就非常简单

24:11.510 --> 24:12.510
我就把Stats的Login

24:12.510 --> 24:13.510
设置为Payload

24:13.510 --> 24:14.510
就完了

24:14.510 --> 24:15.510
就这么简单

24:15.510 --> 24:16.510
然后呢,一个是

24:16.510 --> 24:17.510
setUser

24:17.510 --> 24:18.510
设置用户

24:18.510 --> 24:19.510
原来的状态给我

24:19.510 --> 24:20.510
那么新的用户是咋

24:20.510 --> 24:21.510
一个传一个Payload的进来

24:21.510 --> 24:23.510
那我就把Stats的User

24:23.510 --> 24:24.510
设置为Payload

24:24.510 --> 24:25.510
就这么简单

24:25.510 --> 24:26.510
设置两个Multi-Action

24:26.510 --> 24:27.510
Multi-Action是

24:27.510 --> 24:28.510
数据改变的唯一原因

24:28.510 --> 24:29.510
Multi-Action的写法

24:29.510 --> 24:31.510
往往是非常非常简单的

24:31.510 --> 24:32.510
好,咱们来看一下吧

24:32.510 --> 24:34.510
现在的一开始是

24:34.510 --> 24:36.510
没有用户的对吧

24:36.510 --> 24:37.510
没有用户的

24:37.510 --> 24:38.510
好,那么接下来

24:38.510 --> 24:39.510
那么这里

24:39.510 --> 24:41.510
用Store

24:41.510 --> 24:42.510
commit

24:42.510 --> 24:43.510
提交一个啊

24:43.510 --> 24:45.510
比方说Loading

24:45.510 --> 24:49.020
社为True

24:52.990 --> 24:53.990
unloadMulti-Action

24:53.990 --> 24:54.990
哦,setLoading

24:54.990 --> 24:55.990
写错了

24:55.990 --> 24:59.750
setLoading

25:00.750 --> 25:01.750
好,然后我们看一下

25:01.750 --> 25:02.750
无用里边

25:02.750 --> 25:03.750
是不是就设置了

25:03.750 --> 25:04.750
什么set出发了这个Multi-Action

25:04.750 --> 25:05.750
这个Multi-Action

25:05.750 --> 25:06.750
它的重用就是

25:06.750 --> 25:07.750
把Multi-Action

25:07.750 --> 25:08.750
User里面的Loading变为True

25:08.750 --> 25:09.750
你看这个Stats

25:09.750 --> 25:10.750
这个Stats呢

25:10.750 --> 25:11.750
现在他指的是

25:11.750 --> 25:13.750
当前这个模块的Stats

25:14.750 --> 25:15.750
你看啊

25:15.750 --> 25:16.750
这里指的是

25:16.750 --> 25:17.750
当前这个模块的Stats

25:17.750 --> 25:19.750
而不是全聚模块

25:19.750 --> 25:20.750
他指的只是

25:20.750 --> 25:21.750
当前这个模块

25:21.750 --> 25:22.750
你看我这里

25:22.750 --> 25:23.750
这点Loading指的是

25:23.750 --> 25:24.750
当前这个模块

25:24.750 --> 25:25.750
LoadingUser这个模块里边的

25:25.750 --> 25:26.750
Loading

25:26.750 --> 25:27.750
对吧

25:27.750 --> 25:28.750
它不是全聚的

25:28.750 --> 25:29.750
我们要

25:29.750 --> 25:30.750
除非你在

25:30.750 --> 25:31.750
这里用的时候

25:31.750 --> 25:32.750
通过这个Stone对象的时候

25:32.750 --> 25:33.750
得到Stats呢

25:33.750 --> 25:34.750
才是全聚的

25:34.750 --> 25:35.750
你看这里面有Counter

25:35.750 --> 25:36.750
有LoadingUser

25:36.750 --> 25:37.750
我们要得到

25:37.750 --> 25:38.750
它的Loading状态的话

25:38.750 --> 25:39.750
应该是这样子

25:39.750 --> 25:40.750
Stats

25:40.750 --> 25:41.750
LoadingUser

25:41.750 --> 25:42.750
Loading

25:43.750 --> 25:44.750
没人的意思吧

25:45.750 --> 25:46.750
好,那么我们刚才

25:46.750 --> 25:47.750
触发了一个Multi-Action

25:47.750 --> 25:48.750
让大家想一想

25:48.750 --> 25:49.750
跟Multi-Action触发

25:49.750 --> 25:50.750
到底有没有什么问题呢

25:50.750 --> 25:51.750
实际上是有一点问题的

25:51.750 --> 25:53.750
好像数据是没有什么问题

25:53.750 --> 25:54.750
问题在哪呢

25:54.750 --> 25:55.750
问题在于这个

25:55.750 --> 25:56.750
Multi-Action的名字

25:57.750 --> 25:58.750
那你看啊

25:58.750 --> 25:59.750
我们当前这个模块

25:59.750 --> 26:00.750
把这个名字占用了

26:01.750 --> 26:02.750
把这个Multi-Action名字占用了

26:03.750 --> 26:04.750
那如果说别的模块

26:04.750 --> 26:05.750
它也占用了这个名字呢

26:05.750 --> 26:06.750
因为这个名字

26:06.750 --> 26:07.750
也蛮常见的对吧

26:07.750 --> 26:08.750
设置当前

26:08.750 --> 26:09.750
夹仔冻的效果

26:09.750 --> 26:10.750
那比方说

26:10.750 --> 26:11.750
有个新闻列表的

26:11.750 --> 26:12.750
数据模块

26:12.750 --> 26:13.750
那么那个模块里边

26:14.750 --> 26:15.750
它也要登录

26:15.750 --> 26:16.750
Loading效果

26:16.750 --> 26:18.750
那它又用什么名字呢

26:18.750 --> 26:19.750
是不是特别容易导致

26:19.750 --> 26:20.750
冲突啊

26:20.750 --> 26:21.750
就这个模块的

26:21.750 --> 26:22.750
Multi-Action的名字

26:22.750 --> 26:23.750
跟另一个模块的

26:23.750 --> 26:25.750
Multi-Action的名字发生冲突

26:25.750 --> 26:26.750
那怎么办呢

26:26.750 --> 26:27.750
这里的一个非常简单的办法

26:27.750 --> 26:28.750
其实这个东西

26:28.750 --> 26:30.750
你查文档就基本上就解决了

26:30.750 --> 26:31.750
你看吧

26:31.750 --> 26:32.750
在哪里查呢

26:32.750 --> 26:33.750
你看

26:33.750 --> 26:35.750
慢慢的教大家去查这个文档

26:35.750 --> 26:36.750
比方我们刚才知道了

26:36.750 --> 26:37.750
Module

26:37.750 --> 26:38.750
这个东西呢

26:38.750 --> 26:39.750
是来解决这个问题的

26:39.750 --> 26:40.750
你往下找一找

26:40.750 --> 26:41.750
慢慢去约组一下

26:41.750 --> 26:42.750
这个文档

26:42.750 --> 26:43.750
多少少的都会看到这个东西

26:43.750 --> 26:44.750
明明空间

26:45.750 --> 26:46.750
它主要是为了

26:46.750 --> 26:47.750
来防止明明冲突的

26:47.750 --> 26:48.750
加上这个命名空间

26:49.750 --> 26:50.750
加上这个配置

26:50.750 --> 26:51.750
在模块里边加

26:51.750 --> 26:52.750
Name is best

26:53.750 --> 26:54.750
这为去

26:55.750 --> 26:56.750
好加上命名空间过后

26:56.750 --> 26:57.750
就不一样了

26:57.750 --> 26:58.750
加上命名空间过后

26:58.750 --> 26:59.750
现在让我们来看

26:59.750 --> 27:01.750
我们现在再去触发

27:02.750 --> 27:03.750
现在是初手状态

27:03.750 --> 27:05.750
我们把这个楼顶设为去

27:06.750 --> 27:07.750
再去触发

27:07.750 --> 27:09.750
设置一个楼顶为去

27:09.750 --> 27:10.750
因为发现

27:10.750 --> 27:11.750
它告诉你

27:11.750 --> 27:12.750
这个设置楼顶

27:12.750 --> 27:13.750
这个抹腿形不存在

27:13.750 --> 27:14.750
我们这里不是

27:14.750 --> 27:15.750
明明写的是设置楼顶吗

27:15.750 --> 27:16.750
它不允许你

27:16.750 --> 27:17.750
用这样的名字

27:17.750 --> 27:18.750
因为这个名字特别容易

27:18.750 --> 27:19.750
找是冲突

27:19.750 --> 27:20.750
加了命名空

27:20.750 --> 27:22.750
把命名空间开启过后

27:22.750 --> 27:24.750
开启命名空间

27:24.750 --> 27:26.750
开启了这个东西之后

27:26.750 --> 27:28.750
你之后再要去

27:28.750 --> 27:29.750
使用抹腿形的时候

27:29.750 --> 27:30.750
你必须要把模块名字

27:30.750 --> 27:31.750
作为前綴

27:31.750 --> 27:32.750
加上

27:32.750 --> 27:33.750
那怎么写呢

27:33.750 --> 27:34.750
它现在的抹腿形

27:34.750 --> 27:35.750
变成这个样子的

27:36.750 --> 27:37.750
它的抹腿形变成这个东西

27:37.750 --> 27:38.750
叫做

27:39.750 --> 27:40.750
模块名字

27:40.750 --> 27:41.750
脑底

27:41.750 --> 27:42.750
油热一个斜缸

27:43.750 --> 27:44.750
变这个了

27:44.750 --> 27:45.750
一回车

27:46.750 --> 27:47.750
你看我们的抹腿形的内形

27:47.750 --> 27:48.750
是这个

27:48.750 --> 27:49.750
陪斗的

27:49.750 --> 27:50.750
围举

27:50.750 --> 27:51.750
把它传来一个举进去

27:51.750 --> 27:53.750
那么它就把弄定式围举了

27:53.750 --> 27:54.750
它就出发了这个抹腿形

27:55.750 --> 27:56.750
看没

27:56.750 --> 27:57.750
加上命名空间主要是为了

27:57.750 --> 27:58.750
你看这样子

27:58.750 --> 27:59.750
是不是不会有命名冲突了

27:59.750 --> 28:01.750
因为模块的名字是唯一的

28:01.750 --> 28:02.750
对吧

28:02.750 --> 28:03.750
好

28:03.750 --> 28:04.750
就把这个命名空间加上

28:04.750 --> 28:05.750
其实还有一个东西

28:05.750 --> 28:06.750
它也可以

28:06.750 --> 28:07.750
把它开启

28:07.750 --> 28:08.750
叫Strict

28:08.750 --> 28:09.750
严格模式

28:09.750 --> 28:10.750
开启严格模式过后

28:11.750 --> 28:12.750
严格模式后

28:13.750 --> 28:14.750
只能

28:15.750 --> 28:16.750
只允许

28:18.750 --> 28:19.750
通过

28:19.750 --> 28:20.750
Motation

28:21.750 --> 28:22.750
改变状态

28:23.750 --> 28:25.750
也就是我们之前那种用法

28:25.750 --> 28:27.750
直接通过State来改变状态

28:27.750 --> 28:28.750
它不能让你用了

28:28.750 --> 28:29.750
它会给你

28:29.750 --> 28:30.750
包一个警告还是错误

28:30.750 --> 28:31.750
我看一下吧

28:32.750 --> 28:33.750
State

28:34.750 --> 28:35.750
比方说

28:35.750 --> 28:36.750
Counter吧

28:36.750 --> 28:37.750
Cost加加

28:38.750 --> 28:39.750
这是另外一个模块

28:39.750 --> 28:40.750
另外一个模块

28:40.750 --> 28:41.750
没有开启的状态

28:41.750 --> 28:43.750
我们如果说通过这个老顶

28:43.750 --> 28:44.750
楼顶

28:44.750 --> 28:45.750
把它设为Cue

28:45.750 --> 28:46.750
你看一下

28:46.750 --> 28:49.450
刷新一下

28:52.910 --> 28:53.910
设为Cue

28:54.910 --> 28:55.910
看一下这边

28:55.910 --> 28:59.220
这边是不是设置失销了

28:59.220 --> 29:00.220
设置失销了

29:00.220 --> 29:01.220
至少

29:01.220 --> 29:02.220
现在没给你提示错误了

29:03.220 --> 29:05.220
我把这个Strict去掉了

29:05.220 --> 29:06.220
去掉过后

29:06.220 --> 29:07.220
我们再看

29:07.220 --> 29:08.220
设置个楼顶

29:08.220 --> 29:09.220
为Cue

29:12.600 --> 29:14.600
那么我查一下文档了

29:14.600 --> 29:15.600
查一下文档

29:16.600 --> 29:17.600
是这样写的吗

29:21.600 --> 29:23.600
直接查API参考

29:23.600 --> 29:24.600
配置

29:24.600 --> 29:25.600
我们看一下配置

29:32.580 --> 29:34.580
是在构造器里面

29:34.580 --> 29:37.950
是在构造器里面

29:37.950 --> 29:39.950
我写到模块里面去了

29:39.950 --> 29:41.950
应该写到构造器里面

29:45.520 --> 29:47.520
把严格模式开启

29:47.520 --> 29:48.520
现在我们再来看

29:49.520 --> 29:50.520
现在我们再去

29:50.520 --> 29:52.520
刚才的样子去改动楼顶

29:53.520 --> 29:54.520
是不是

29:54.520 --> 29:56.520
给你爆了一个错误

29:56.520 --> 29:58.520
那么我还要

29:58.520 --> 29:59.520
尝试一下

29:59.520 --> 30:00.520
他改动成功了没有呢

30:00.520 --> 30:01.520
这些细节

30:01.520 --> 30:02.520
我平时都没有怎么去注意到

30:02.520 --> 30:04.520
这些细节也很好验证

30:04.520 --> 30:05.520
你去读一下就完事了

30:05.520 --> 30:06.520
改动到是成功了

30:06.520 --> 30:08.520
但是他给你爆了一个警告

30:09.520 --> 30:10.520
他说

30:14.520 --> 30:18.520
不能让窗户的状态突变

30:19.520 --> 30:21.520
应该这样的翻译

30:21.520 --> 30:23.520
除了使用Multi-sync之外

30:23.520 --> 30:25.520
不能让这个窗户的状态发生突变

30:25.520 --> 30:26.520
就这么个意思

30:26.520 --> 30:28.520
就起这么一个作用

30:28.520 --> 30:29.520
严格模式

30:29.520 --> 30:30.520
那我把它开启吧

30:30.520 --> 30:32.520
这也是应该开启的

30:32.520 --> 30:34.520
好多这些小的细节

30:34.520 --> 30:36.520
那么现在我们接着写这边

30:36.520 --> 30:37.520
我们这里个Multi-sync

30:37.520 --> 30:39.520
名字命名冲突搞定了

30:39.520 --> 30:40.520
不再有命名冲突了

30:40.520 --> 30:41.520
我们就大展的写

30:41.520 --> 30:42.520
那么Multi-sync就写完了

30:42.520 --> 30:44.520
因为我们这里只有这两个状态

30:44.520 --> 30:45.520
需要维护

30:45.520 --> 30:46.520
也没有什么更多的东西了

30:46.520 --> 30:48.520
我们现在来写Actions

30:48.520 --> 30:50.520
是不是我们一些处理副作用

30:50.520 --> 30:51.520
比方说你要登录

30:51.520 --> 30:53.520
登录是不是会导致这个状态变化

30:53.520 --> 30:55.520
而登录就是一个副作用的操作

30:55.520 --> 30:56.520
那么这里边

30:56.520 --> 30:59.520
就很有可能会用到User API

31:01.520 --> 31:03.520
导致这个APN里边的User

31:03.520 --> 31:04.520
这个User API里面

31:04.520 --> 31:05.520
不是有三个函数吗

31:05.520 --> 31:06.520
我们之前看过我的

31:06.520 --> 31:09.520
那么这里我们就写这么几个方法

31:09.520 --> 31:10.520
一个是登录

31:13.520 --> 31:14.520
登录方法

31:14.520 --> 31:15.520
登录方法

31:15.520 --> 31:17.520
你给我传递的是

31:17.520 --> 31:19.520
之前的一个Context给我传进来

31:19.520 --> 31:20.520
还记得吗

31:20.520 --> 31:21.520
Action是这样

31:21.520 --> 31:23.520
所以说上级课的东西一定要写

31:23.520 --> 31:24.520
不写的肯定就忘完了

31:24.520 --> 31:26.520
第二层是什么Payload

31:26.520 --> 31:28.520
Payload让我期望了你给我传一个对象

31:28.520 --> 31:29.520
对象里边有两个属性

31:29.520 --> 31:30.520
一个Nokin ID

31:30.520 --> 31:31.520
一个Nokin password

31:31.520 --> 31:32.520
这个东西你要自己约定

31:32.520 --> 31:34.520
它这里无法接受更多的参数

31:34.520 --> 31:35.520
它只能接受一个Payload

31:35.520 --> 31:36.520
一个Payload

31:36.520 --> 31:38.520
你把包装成一个对象传过来

31:38.520 --> 31:39.520
好,那么正确

31:39.520 --> 31:40.520
我就说一下这个Context

31:40.520 --> 31:41.520
上级课

31:41.520 --> 31:42.520
我们说这个Context

31:42.520 --> 31:43.520
就跟那个仓库差不多

31:43.520 --> 31:44.520
但是那就完全一样

31:44.520 --> 31:46.520
那么这个Context是什么意思呢

31:46.520 --> 31:47.520
实际上就相当于是

31:47.520 --> 31:49.520
这个仓库里边的这个模块

31:50.520 --> 31:53.520
因此我们在这个Context里边

31:53.520 --> 31:55.520
比方说我们这里commit

31:55.520 --> 31:56.520
提交的时候

31:56.520 --> 31:58.520
如果说写全的话

31:58.520 --> 31:59.520
应该是这样子

31:59.520 --> 32:01.520
LoginUserSetLoading

32:01.520 --> 32:02.520
我们先把那个Loading状态

32:02.520 --> 32:03.520
我们要登录

32:03.520 --> 32:05.520
先把Loading状态的设为True

32:05.520 --> 32:07.520
那么这里我们提交一个状态

32:07.520 --> 32:09.520
提交个设为True

32:09.520 --> 32:11.520
我们完整的显化应该是这个

32:11.520 --> 32:12.520
但是由于我们目前

32:12.520 --> 32:13.520
就在这个模块里边

32:13.520 --> 32:16.520
你可以省略掉前面的东西

32:16.520 --> 32:18.520
省略掉前面还会自动给你加上

32:18.520 --> 32:20.520
就这么个意思

32:20.520 --> 32:21.520
好,commit

32:21.520 --> 32:22.520
先把这个东西设为True

32:22.520 --> 32:23.520
然后我们再去登录

32:23.520 --> 32:24.520
怎么登录呢

32:24.520 --> 32:25.520
User API

32:25.520 --> 32:26.520
Login

32:26.520 --> 32:27.520
它就有一个Login方法

32:27.520 --> 32:28.520
它传入两个属性

32:28.520 --> 32:29.520
一个是Login ID

32:29.520 --> 32:30.520
Login ID得在Payload里面去找

32:30.520 --> 32:32.520
这是我们约定好的

32:32.520 --> 32:33.520
你希望你到时候

32:33.520 --> 32:34.520
给我传一个复合进来

32:34.520 --> 32:35.520
这是个对象

32:35.520 --> 32:36.520
要约定好

32:36.520 --> 32:38.520
不行的话你打成主事

32:38.520 --> 32:39.520
Login password的

32:39.520 --> 32:40.520
登录

32:40.520 --> 32:41.520
登录的话

32:41.520 --> 32:42.520
它是一个异步操作

32:42.520 --> 32:43.520
要等待

32:43.520 --> 32:44.520
等待完了过后

32:44.520 --> 32:46.520
是不是拿到服务器的返回结果

32:46.520 --> 32:47.520
这个服务器的返回结果

32:47.520 --> 32:48.520
有两种情况

32:48.520 --> 32:49.520
这要看你的接客文档

32:49.520 --> 32:50.520
如果说

32:50.520 --> 32:51.520
给我的结果

32:51.520 --> 32:52.520
那么就

32:52.520 --> 32:53.520
给我的是登录用户了

32:53.520 --> 32:55.520
表示登录成功了

32:55.520 --> 32:57.520
登录成功

32:57.520 --> 32:58.520
然后Ls

32:58.520 --> 33:00.520
那就登录失败

33:00.520 --> 33:02.520
不管你是登录成功

33:02.520 --> 33:03.520
还是失败

33:03.520 --> 33:04.520
成功的话

33:04.520 --> 33:05.520
它就是个用户对象

33:05.520 --> 33:06.520
失败的话就是那样

33:06.520 --> 33:07.520
那么我们要做的事情

33:07.520 --> 33:08.520
无非就是

33:08.520 --> 33:10.520
设置登录的用户

33:10.520 --> 33:11.520
设置这个

33:11.520 --> 33:13.520
先是由着

33:13.520 --> 33:14.520
注意啊

33:14.520 --> 33:15.520
只有在这个模型

33:15.520 --> 33:16.520
那一步啊

33:16.520 --> 33:18.520
才不用写全

33:18.520 --> 33:20.520
这就是它跟那个

33:20.520 --> 33:22.520
这个Stone的区别

33:22.520 --> 33:23.520
然后这边

33:23.520 --> 33:24.520
就是把用户对象传进去

33:24.520 --> 33:25.520
就是这个Resp

33:25.520 --> 33:26.520
传进去

33:26.520 --> 33:27.520
然后呢

33:27.520 --> 33:28.520
把当前正在登录的状态

33:28.520 --> 33:29.520
设为Force

33:29.520 --> 33:33.370
设为Force

33:33.370 --> 33:34.370
你看

33:34.370 --> 33:35.370
这就完成了一个

33:35.370 --> 33:37.370
X形式登录

33:37.370 --> 33:39.370
好 咱们来试一下吧

33:39.370 --> 33:40.370
X形式该怎么触发

33:40.370 --> 33:42.370
是不是用Stone

33:42.370 --> 33:43.370
Dispatch

33:43.370 --> 33:45.370
哪个Action呢

33:45.370 --> 33:46.370
叫做

33:46.370 --> 33:48.370
Login有点命名空间要写上啊

33:48.370 --> 33:50.370
然后呢Login

33:50.370 --> 33:52.370
接下来一个Payload的

33:52.370 --> 33:54.370
按要求是不是要写对象

33:54.370 --> 33:55.370
对象有两个属性

33:55.370 --> 33:56.370
Login ID

33:56.370 --> 33:58.370
Login Password有两个属性

33:58.370 --> 34:00.370
Login ID的属性呢

34:00.370 --> 34:02.370
我这里之前写的测试代码

34:02.370 --> 34:04.370
测试代码里边

34:04.370 --> 34:05.370
登录的时候

34:05.370 --> 34:06.370
账号为二的命

34:06.370 --> 34:07.370
密码为一二三一二三

34:07.370 --> 34:08.370
就能成功

34:08.370 --> 34:09.370
所以说这里写二的命

34:09.370 --> 34:10.370
这一刻

34:10.370 --> 34:11.370
听着

34:11.370 --> 34:13.370
听着有点懵的同学啊

34:13.370 --> 34:14.370
一定要反复

34:14.370 --> 34:16.370
这一刻一定要搞定的

34:16.370 --> 34:17.370
虽然有点难

34:17.370 --> 34:19.370
一二三一二三

34:19.370 --> 34:22.370
好 让我们Tispatch一下

34:22.370 --> 34:24.370
好 接下来我们看一下这边仓库

34:24.370 --> 34:26.370
你看是不是触发了多个码腿形

34:26.370 --> 34:27.370
先把它设为Cue

34:27.370 --> 34:28.370
先把这个Login设为Cue

34:28.370 --> 34:30.370
然后再设置个登录用户

34:30.370 --> 34:32.370
登录用户什么有了

34:32.370 --> 34:35.370
最后再设置一只Login

34:35.370 --> 34:37.370
WeForce

34:37.370 --> 34:39.370
就经过了这么几个操作

34:39.370 --> 34:40.370
几个护手的操作

34:40.370 --> 34:43.370
好 那么这是IbeX付出用操作

34:44.370 --> 34:47.370
好 接下来的是互玩慢

34:47.370 --> 34:48.370
就是我是谁

34:48.370 --> 34:49.370
我不用登录了

34:49.370 --> 34:50.370
我之前可能登录过

34:50.370 --> 34:51.370
我看一下我之前有没有登录过

34:51.370 --> 34:52.370
我是谁

34:52.370 --> 34:53.370
那么这个地方

34:53.370 --> 34:54.370
是不是需要给我任何参数的

34:54.370 --> 34:56.370
因为我这里呢

34:56.370 --> 34:57.370
最多是调用那个API

34:57.370 --> 34:59.370
我把个代码复制一下吧

34:59.370 --> 35:00.370
一开始是不是也得把它

35:00.370 --> 35:01.370
状态设为Cue

35:01.370 --> 35:02.370
Login状态设为Cue

35:02.370 --> 35:04.370
表示我正在处理中

35:04.370 --> 35:05.370
然后我们调用这个方法

35:05.370 --> 35:07.370
互玩慢

35:07.370 --> 35:09.370
我这边是没有人

35:10.370 --> 35:12.370
以后不要说原谅是这样子写

35:12.370 --> 35:14.370
就说明API里边有一个函数

35:14.370 --> 35:15.370
这边就有一个X型

35:15.370 --> 35:16.370
它不一定的

35:16.370 --> 35:18.370
只是这个例子那就臭巧了

35:18.370 --> 35:20.370
那个不一定的灵活处理的

35:20.370 --> 35:21.370
因为函数都不一样的

35:21.370 --> 35:23.370
X型是就处理一部的

35:23.370 --> 35:25.370
处理一些副作用操作的

35:25.370 --> 35:26.370
这API就是API

35:26.370 --> 35:27.370
有可能一个X型里边

35:27.370 --> 35:29.370
要调用多次API

35:29.370 --> 35:30.370
有可能一个X型里边

35:30.370 --> 35:31.370
一个API都不调用

35:31.370 --> 35:32.370
都不一定的

35:32.370 --> 35:34.370
具体情况具体分析

35:34.370 --> 35:36.370
主要把代码去备去

35:36.370 --> 35:37.370
即时 即时就完了

35:37.370 --> 35:38.370
我讲课也讲封了

35:38.370 --> 35:40.370
因为我要把每一种状况

35:40.370 --> 35:41.370
都一名讲一遍

35:41.370 --> 35:42.370
那就封掉了

35:42.370 --> 35:44.370
那你们就别像毕业了

35:45.370 --> 35:46.370
要灵活处理

35:46.370 --> 35:47.370
我们这边去调一个互玩慢

35:47.370 --> 35:48.370
它会返回一个

35:48.370 --> 35:50.370
服务器会返回给我一个享用

35:51.370 --> 35:52.370
按照捷克文档

35:52.370 --> 35:53.370
这里没有捷克文档

35:53.370 --> 35:54.370
就假设有

35:54.370 --> 35:57.370
它会给我一个对象

35:57.370 --> 35:59.370
如果说恢复成功了

35:59.370 --> 36:00.370
它就会给我一个用户对象

36:00.370 --> 36:01.370
恢复失败了

36:01.370 --> 36:02.370
就给我一个鸟

36:02.370 --> 36:03.370
所以我就把这个东西

36:03.370 --> 36:04.370
直接设置到用户这里

36:04.370 --> 36:05.370
要么我鸟

36:05.370 --> 36:06.370
要么我一个用户对象

36:06.370 --> 36:08.370
然后把一只loading

36:08.370 --> 36:09.370
force

36:11.370 --> 36:12.370
这是互玩慢

36:14.370 --> 36:16.370
然后这边我再来一个

36:16.370 --> 36:18.370
灯出

36:18.370 --> 36:20.370
就是助销

36:20.370 --> 36:21.370
助销的话

36:21.370 --> 36:22.370
也不需要给我

36:22.370 --> 36:23.370
任何其他的东西

36:23.370 --> 36:24.370
然后先把loading

36:24.370 --> 36:25.370
设为去

36:25.370 --> 36:26.370
然后这边调

36:26.370 --> 36:28.370
locking out

36:28.370 --> 36:29.370
助销

36:29.370 --> 36:31.370
它没有任何返回

36:31.370 --> 36:32.370
没有任何返回

36:32.370 --> 36:34.370
这边我们在

36:35.370 --> 36:36.370
设置用户

36:36.370 --> 36:37.370
这里直接设置为lock

36:37.370 --> 36:38.370
助销过后的用户

36:38.370 --> 36:39.370
肯定为lock

36:39.370 --> 36:40.370
然后把loading

36:40.370 --> 36:41.370
设为force

36:41.370 --> 36:42.370
就把3个action

36:42.370 --> 36:43.370
就写好了

36:43.370 --> 36:44.370
这3个action

36:44.370 --> 36:45.370
当然你可以在这里

36:45.370 --> 36:46.370
挨在这个控制台里面

36:46.370 --> 36:47.370
去测试一下

36:47.370 --> 36:48.370
测试一下它的action

36:48.370 --> 36:49.370
出发过后的这一只

36:49.370 --> 36:50.370
正不正确

36:50.370 --> 36:51.370
把它弄好

36:52.370 --> 36:54.370
那我们现在不测试了

36:54.370 --> 36:55.370
就OK了

36:55.370 --> 36:56.370
敞锅这边

36:56.370 --> 36:58.370
是不是就感觉别上问题了

36:58.370 --> 36:59.370
然后我们再仔细观察一下

36:59.370 --> 37:00.370
这个问题

37:00.370 --> 37:01.370
其实现在不做

37:01.370 --> 37:03.370
一会也会遇到这个问题

37:03.370 --> 37:04.370
就是这一块

37:04.370 --> 37:05.370
这一块是不是要根据

37:05.370 --> 37:07.370
是不是有三种状态

37:08.370 --> 37:09.370
什么三种状态

37:09.370 --> 37:11.370
一个是当前正在夹载中

37:11.370 --> 37:13.370
一个是

37:13.370 --> 37:15.370
当前已经登录成功了

37:15.370 --> 37:17.370
一个是

37:17.370 --> 37:19.370
目前还没有登录

37:19.370 --> 37:21.370
你看我们的网页中

37:21.370 --> 37:22.370
不就是三种状态吗

37:22.370 --> 37:23.370
正在处理中

37:23.370 --> 37:24.370
我也不知道登录没有

37:24.370 --> 37:25.370
我正在恢复

37:25.370 --> 37:26.370
恢复这个状态

37:26.370 --> 37:27.370
或者是我正在登录中

37:27.370 --> 37:28.370
我也不能确定

37:28.370 --> 37:30.370
有没有登录成功

37:30.370 --> 37:32.370
然后还就是

37:32.370 --> 37:33.370
成功了

37:33.370 --> 37:34.370
还就是失败

37:34.370 --> 37:35.370
三种状态

37:35.370 --> 37:36.370
那么这三种状态

37:36.370 --> 37:37.370
是不是可以根据

37:37.370 --> 37:38.370
这两个属性来得到

37:38.370 --> 37:39.370
如果说他为去

37:39.370 --> 37:41.370
那么就是正在处理中

37:41.370 --> 37:42.370
如果他不是去

37:42.370 --> 37:43.370
他为force

37:43.370 --> 37:44.370
那就看他

37:44.370 --> 37:46.370
他如果说是有值的

37:46.370 --> 37:47.370
那么说明登录成功了

37:47.370 --> 37:48.370
他如果说没有值

37:48.370 --> 37:49.370
就要登录失败

37:49.370 --> 37:50.370
根据他那两个来算出来的

37:50.370 --> 37:52.370
那是不是一个计算属性

37:52.370 --> 37:53.370
这个计算属性

37:53.370 --> 37:54.370
我们可以在

37:54.370 --> 37:55.370
组件里面去写个计算属性

37:55.370 --> 37:57.370
根据这两个状态来算

37:57.370 --> 37:58.370
如果说这个计算属性

37:58.370 --> 38:00.370
很多组件都要用到的话

38:00.370 --> 38:01.370
我们实际上

38:01.370 --> 38:02.370
就写到这儿了

38:02.370 --> 38:03.370
那怎么写呢

38:03.370 --> 38:04.370
这东西叫做getals

38:07.370 --> 38:08.370
这里文档

38:08.370 --> 38:10.370
getals非常非常简单

38:10.370 --> 38:12.370
这就是写个计算属性

38:12.370 --> 38:13.370
我们平时写到组件里面

38:13.370 --> 38:15.370
现在是可以写到getals里面

38:15.370 --> 38:16.370
那么getals里面

38:16.370 --> 38:18.370
还有getals有一个参数

38:18.370 --> 38:19.370
这个参数就乃至于

38:19.370 --> 38:20.370
当前的状态

38:20.370 --> 38:21.370
你根据当前的状态

38:21.370 --> 38:23.370
去计算一个东西

38:23.370 --> 38:24.370
我们这里写一个吧

38:24.370 --> 38:25.370
getals

38:26.370 --> 38:27.370
我们比较说这里

38:27.370 --> 38:28.370
我们就写个status

38:28.370 --> 38:29.370
表示状态

38:29.370 --> 38:30.370
他有一个参数

38:30.370 --> 38:32.370
status就是当前的状态

38:32.370 --> 38:34.370
他会自动给你传输

38:34.370 --> 38:37.370
然后我们这边就反

38:37.370 --> 38:38.370
反过来是什么呢

38:38.370 --> 38:39.370
判断一下吧

38:39.370 --> 38:40.370
如果说当前状态里面

38:40.370 --> 38:41.370
什么loading为q

38:41.370 --> 38:42.370
说明了

38:42.370 --> 38:43.370
我们就反回一个状态

38:43.370 --> 38:44.370
叫loading

38:45.370 --> 38:46.370
alsif

38:46.370 --> 38:48.370
如果说当前的状态是

38:51.370 --> 38:52.370
logging

38:53.370 --> 38:54.370
user有值

38:54.370 --> 38:56.370
那么就return

38:58.370 --> 38:59.370
logging

38:59.370 --> 39:01.370
alds就return

39:01.370 --> 39:02.370
unlogging

39:02.370 --> 39:03.370
没有登录

39:03.370 --> 39:05.370
一共都是三种状态

39:06.370 --> 39:07.370
没问题吧

39:07.370 --> 39:08.370
好了

39:08.370 --> 39:09.370
那么我们怎么来访问getals呢

39:09.370 --> 39:10.370
访问起来也很简单的

39:10.370 --> 39:12.370
你看我现在跟无忧有关系吗

39:12.370 --> 39:13.370
对于毛钱关系都没有

39:13.370 --> 39:15.370
我就是在这里

39:15.370 --> 39:16.370
控制在这里用普通的介绍

39:16.370 --> 39:17.370
来过去的

39:17.370 --> 39:18.370
getals

39:18.370 --> 39:19.370
通过这样的访问

39:20.370 --> 39:21.370
仓库对象里面getals

39:21.370 --> 39:22.370
然后我们打开看一下吧

39:22.370 --> 39:23.370
getals是啥

39:24.370 --> 39:25.370
他有这么一个属性

39:25.370 --> 39:27.370
属性名字是一个秘名空间

39:27.370 --> 39:29.370
加上他的getal的名称

39:29.370 --> 39:31.370
这样子是为了避免重名

39:32.370 --> 39:34.370
不是在State里面

39:34.370 --> 39:35.370
是getals

39:35.370 --> 39:36.370
怎么访问的

39:36.370 --> 39:37.370
通过命名空间

39:37.370 --> 39:38.370
这样的访问

39:38.370 --> 39:40.370
他目前状态是unlogging

39:40.370 --> 39:41.370
logging

39:41.370 --> 39:42.370
没有登录

39:42.370 --> 39:44.370
那我们登录一下吧

39:44.370 --> 39:45.370
store

39:46.370 --> 39:47.370
dispatch

39:48.370 --> 39:49.370
就这个玩意

39:49.370 --> 39:50.370
好登录一下

39:50.370 --> 39:51.370
好登录完了

39:51.370 --> 39:52.370
过后我们再看一下

39:52.370 --> 39:53.370
storegetals

39:54.370 --> 39:56.370
你看现在是不是登录了

39:57.370 --> 39:58.370
对吧

39:58.370 --> 39:59.370
就这么简单

40:00.370 --> 40:01.370
好

40:01.370 --> 40:03.370
这是我们的仓库

40:03.370 --> 40:04.370
其实就写完了

40:04.370 --> 40:05.370
就准备好了

40:05.370 --> 40:07.370
仓库里面提供了数据

40:07.370 --> 40:09.370
也提供了各种

40:09.370 --> 40:10.370
改变仓库的

40:11.370 --> 40:12.370
猴腿型

40:12.370 --> 40:13.370
也提供了各种

40:13.370 --> 40:15.370
异部处理的Action

40:15.370 --> 40:16.370
也提供了一个

40:16.370 --> 40:17.370
计算署项Status

40:17.370 --> 40:18.370
然后这些东西

40:18.370 --> 40:20.370
就留给界面也好

40:20.370 --> 40:21.370
其他的GS模块也好

40:21.370 --> 40:23.370
你随意的去使用

40:23.370 --> 40:24.370
就OK了

40:25.370 --> 40:26.370
那我们怎么使用呢

40:26.370 --> 40:27.370
首先我们找到

40:27.370 --> 40:28.370
找到我们的登录

40:28.370 --> 40:29.370
登录这个页面

40:30.370 --> 40:31.370
到这里边

40:31.370 --> 40:32.370
登录的时候

40:32.370 --> 40:33.370
我们不是有个楼顶

40:33.370 --> 40:34.370
表示是否正在登录中

40:34.370 --> 40:35.370
这个楼顶

40:35.370 --> 40:36.370
我们是不是可以不要了

40:36.370 --> 40:38.370
是不是可以不要了

40:38.370 --> 40:39.370
这个楼顶可以放哪呢

40:39.370 --> 40:40.370
这个楼顶

40:40.370 --> 40:41.370
我们可以是不是

40:41.370 --> 40:42.370
读仓库里面的一个楼顶

40:42.370 --> 40:43.370
仓库里面不是一个

40:43.370 --> 40:44.370
正在处理中吗

40:44.370 --> 40:45.370
对吧

40:45.370 --> 40:46.370
那我们把楼顶放这

40:46.370 --> 40:47.370
如果它的disable的状态

40:47.370 --> 40:48.370
也取决于楼顶

40:48.370 --> 40:49.370
我们这里

40:49.370 --> 40:50.370
就可以写什么

40:51.370 --> 40:52.370
state

40:52.370 --> 40:53.370
locking user

40:53.370 --> 40:54.370
这是我们的

40:54.370 --> 40:55.370
这个模块名

40:55.370 --> 40:56.370
对吧

40:56.370 --> 40:57.370
后边里边

40:57.370 --> 40:58.370
就谈你的数据了

40:58.370 --> 40:59.370
里边有个楼顶

40:59.370 --> 41:00.370
是不是可以写在这

41:00.370 --> 41:01.370
好 那么这边

41:01.370 --> 41:02.370
是不是也可以写在这

41:02.370 --> 41:03.370
对吧

41:03.370 --> 41:04.370
之后登录中

41:04.370 --> 41:05.370
这个状态

41:05.370 --> 41:06.370
是不是可以读这了

41:06.370 --> 41:07.370
对吧

41:08.370 --> 41:09.370
好 登录的时候

41:09.370 --> 41:10.370
我们干嘛呀

41:10.370 --> 41:11.370
登录的时候

41:11.370 --> 41:12.370
我们这里的处理函数里边

41:12.370 --> 41:13.370
我们是不是可以处发

41:14.370 --> 41:15.370
locking

41:16.370 --> 41:17.370
喂

41:17.370 --> 41:18.370
stone

41:19.370 --> 41:20.370
dispatch

41:22.370 --> 41:23.370
处发action

41:23.370 --> 41:24.370
locking user

41:28.370 --> 41:29.370
叫什么

41:29.370 --> 41:30.370
叫做locking

41:31.370 --> 41:32.370
好 配置了

41:32.370 --> 41:33.370
是不是一个对象

41:33.370 --> 41:34.370
之前有一定好的

41:34.370 --> 41:35.370
locking id等于

41:35.370 --> 41:36.370
this.locking id

41:39.700 --> 41:41.700
locking id

41:41.700 --> 41:42.700
然后this

41:42.700 --> 41:43.700
locking password

41:44.700 --> 41:46.700
this.locking password

41:46.700 --> 41:47.700
是不是处发过去

41:47.700 --> 41:48.700
让它去登录

41:48.700 --> 41:49.700
对吧

41:49.700 --> 41:50.700
它登录的过程中

41:50.700 --> 41:51.700
它就会设置

41:51.700 --> 41:52.700
仓库里边的状态一遍

41:52.700 --> 41:53.700
它这里的楼顶状态

41:53.700 --> 41:54.700
也会跟这边

41:55.700 --> 41:57.700
好 我们目前看一下吧

41:58.700 --> 41:59.700
接下来我们要

41:59.700 --> 42:00.700
到登录里边去看一下

42:00.700 --> 42:02.700
嗯 这里保错了

42:02.700 --> 42:03.700
怎么回事

42:03.700 --> 42:04.700
它说

42:05.700 --> 42:07.700
哦 这里写错了

42:07.700 --> 42:09.700
stone state

42:10.700 --> 42:13.270
这个

42:13.270 --> 42:14.270
好 再来啊

42:14.270 --> 42:15.270
好 这样好了

42:15.270 --> 42:16.270
我们就写个

42:16.270 --> 42:17.270
随便写吧

42:17.270 --> 42:18.270
密码就随便写

42:19.270 --> 42:20.270
是不是

42:20.270 --> 42:21.270
至少楼顶状态正常了

42:21.270 --> 42:22.270
然后我们看一下

42:22.270 --> 42:23.270
5u里边

42:23.270 --> 42:25.270
处发了locking那个action

42:25.270 --> 42:26.270
是不是设置了几次

42:26.270 --> 42:27.270
先把它设为处

42:27.270 --> 42:28.270
然后再去

42:28.270 --> 42:29.270
网络请求登录

42:29.270 --> 42:30.270
登录完了过后

42:30.270 --> 42:31.270
我发现那个user

42:31.270 --> 42:32.270
没有登录成功

42:32.270 --> 42:33.270
设置为now

42:33.270 --> 42:35.270
然后再把loading设为force

42:35.270 --> 42:36.270
对不对

42:36.270 --> 42:38.270
你可以通过一个回退

42:38.270 --> 42:39.270
回到之前的效果

42:39.270 --> 42:40.270
你可以看到每一步

42:40.270 --> 42:41.270
它的状态是从

42:41.270 --> 42:42.270
什么变到什么的

42:42.270 --> 42:43.270
对吧

42:43.270 --> 42:44.270
可以看得非常清楚

42:44.270 --> 42:47.290
好 OK

42:48.290 --> 42:49.290
但是我们这里

42:49.290 --> 42:50.290
还有一些问题要解决

42:50.290 --> 42:51.290
就是我这里

42:51.290 --> 42:52.290
需要知道它到底

42:52.290 --> 42:53.290
有没有登录成功

42:53.290 --> 42:54.290
因为登录成功

42:54.290 --> 42:56.290
按照我们最终的要求

42:56.290 --> 42:58.290
我们登录成功的时候

42:58.290 --> 43:02.180
8080

43:02.180 --> 43:04.180
退出

43:04.180 --> 43:06.180
登录成功的时候

43:06.180 --> 43:07.180
我们要跳转页面

43:07.180 --> 43:08.180
登录失败的时候

43:08.180 --> 43:09.180
我要提示

43:09.180 --> 43:11.180
帐号密码错误

43:11.180 --> 43:12.180
就是说我去触发

43:12.180 --> 43:13.180
这个action的时候

43:13.180 --> 43:14.180
我得知道这个action

43:14.180 --> 43:15.180
运行的结果

43:15.180 --> 43:16.180
它到底成功了

43:16.180 --> 43:17.180
还是没成功

43:17.180 --> 43:18.180
那我怎么让

43:18.180 --> 43:19.180
知道这个action

43:19.180 --> 43:20.180
的运行结果呢

43:20.180 --> 43:21.180
有两种方法

43:21.180 --> 43:22.180
第一种方法

43:22.180 --> 43:23.180
我就是知道

43:23.180 --> 43:24.180
我想通过这个

43:24.180 --> 43:25.180
函数的法源归指

43:25.180 --> 43:26.180
来确定它有没有登录成功

43:26.180 --> 43:27.180
第二种方法是

43:27.180 --> 43:29.180
我触发了之后

43:29.180 --> 43:30.180
它是一个异步的

43:30.180 --> 43:31.180
我等待它

43:31.180 --> 43:32.180
我触发了之后

43:32.180 --> 43:33.180
我去判断

43:33.180 --> 43:34.180
目前仓库里边的数据

43:34.180 --> 43:35.180
到底是怎么回事

43:35.180 --> 43:36.180
就没登录成功

43:36.180 --> 43:37.180
两种方法都可以

43:37.180 --> 43:38.180
那么这里能简单一点

43:38.180 --> 43:40.180
把它用它的返回值

43:40.180 --> 43:41.180
返回值呢

43:41.180 --> 43:42.180
它这里的返回什么呢

43:42.180 --> 43:43.180
返回就是我们这边

43:43.180 --> 43:44.180
action的返回值

43:44.180 --> 43:45.180
login

43:45.180 --> 43:46.180
我这里返回的是ondified

43:46.180 --> 43:47.180
对吧

43:47.180 --> 43:48.180
那我这里返回一个

43:48.180 --> 43:49.180
返回什么呢

43:49.180 --> 43:50.180
返回的是

43:51.180 --> 43:52.180
呼吸的响应结果

43:52.180 --> 43:53.180
我去把东西返回

43:53.180 --> 43:54.180
返回完了过后

43:54.180 --> 43:55.180
这边是不是可以

43:55.180 --> 43:56.180
接收一下

43:56.180 --> 43:58.680
呼吸的响应结果

43:58.680 --> 43:59.680
那么判断一下

43:59.680 --> 44:01.680
如果说登录成功了

44:01.680 --> 44:02.680
登录成功了

44:02.680 --> 44:03.680
我怎么样呢

44:03.680 --> 44:04.680
我就跳转一面

44:04.680 --> 44:05.680
跳转一面很简单

44:05.680 --> 44:06.680
Rotor

44:06.680 --> 44:07.680
Push

44:07.680 --> 44:08.680
跳转到首页

44:08.680 --> 44:09.680
非常简单

44:09.680 --> 44:10.680
好

44:10.680 --> 44:11.680
如果说登录失败了

44:11.680 --> 44:12.680
我就ornat

44:12.680 --> 44:13.680
账号密码错误

44:13.680 --> 44:14.680
密码错误了

44:14.680 --> 44:15.680
或者是

44:15.680 --> 44:16.680
然后是把这两个

44:16.680 --> 44:17.680
清空都可以

44:17.680 --> 44:18.680
随便你清不清空

44:18.680 --> 44:19.680
保存

44:19.680 --> 44:20.680
我们再来看

44:20.680 --> 44:21.680
现在呢

44:21.680 --> 44:22.680
我们如果说

44:22.680 --> 44:23.680
是一个失败的状态

44:23.680 --> 44:25.680
登录失败

44:25.680 --> 44:28.120
账号密码错误

44:29.120 --> 44:30.120
如果登录成功

44:33.010 --> 44:34.010
是不是跳到首页了

44:34.010 --> 44:35.010
这一块是不是就做完了

44:35.010 --> 44:36.010
这一块

44:36.010 --> 44:37.010
这一块就做完了

44:38.010 --> 44:39.010
好

44:39.010 --> 44:40.010
接下来我们看

44:40.010 --> 44:41.010
上面这一块

44:41.010 --> 44:42.010
上面这一块呢

44:42.010 --> 44:43.010
就是

44:43.010 --> 44:44.010
在这个组件里面

44:44.010 --> 44:45.010
又在那

44:46.010 --> 44:47.010
等一下

44:48.010 --> 44:49.010
我还有一个小的细节别说

44:49.010 --> 44:51.010
这边细节可多了

44:51.010 --> 44:52.010
这里

44:52.010 --> 44:54.010
这里其实没有什么问题

44:54.010 --> 44:55.010
就是说

44:55.010 --> 44:56.010
但是这里呢

44:56.010 --> 44:57.010
总感觉要写一长串

44:57.010 --> 44:58.010
是不是很不舒服

44:59.010 --> 45:00.010
比方说

45:00.010 --> 45:01.010
如果说像这个数据

45:01.010 --> 45:02.010
我们状态上

45:02.010 --> 45:03.010
我们的页面上

45:03.010 --> 45:04.010
就是模板里面

45:04.010 --> 45:06.010
到处都可以可能会用到的话

45:06.010 --> 45:07.010
那里每个地方都要写这么一长串

45:07.010 --> 45:09.010
是不是有点恶心啊

45:09.010 --> 45:10.010
那咋办了

45:10.010 --> 45:11.010
咋办了

45:11.010 --> 45:12.010
我们可以用一个

45:12.010 --> 45:14.010
非常简单的方式

45:14.010 --> 45:15.010
就该写一个

45:17.900 --> 45:18.900
楼顶

45:18.900 --> 45:21.270
楼顶

45:22.270 --> 45:23.270
楼顶来自于哪呢

45:23.270 --> 45:24.270
来自于这个

45:24.270 --> 45:26.270
我就把它封装一下

45:26.270 --> 45:27.270
没别的意思

45:27.270 --> 45:28.270
兄弟

45:28.270 --> 45:29.270
没别的意思

45:29.270 --> 45:30.270
我就把它封装一下

45:30.270 --> 45:31.270
这样子呢

45:31.270 --> 45:33.270
是不是要舒服一点

45:33.270 --> 45:34.270
对吧

45:34.270 --> 45:35.270
因为我们知道

45:35.270 --> 45:36.270
computing的呢是有

45:36.270 --> 45:38.270
他他他会自行计算

45:38.270 --> 45:39.270
那个依赖关系的

45:39.270 --> 45:40.270
如果他依赖变化了

45:40.270 --> 45:42.270
他也会重新计算的

45:42.270 --> 45:43.270
这样子要舒服一点

45:43.270 --> 45:44.270
其他没啥

45:48.270 --> 45:49.270
这里要用race

45:52.290 --> 45:53.290
小心

45:53.290 --> 45:54.290
来看啊

45:54.290 --> 45:55.290
水源写个

45:55.290 --> 45:56.290
你说是一样的

45:56.290 --> 45:57.290
对吧

45:57.290 --> 45:58.290
是一样的

45:58.290 --> 45:59.290
这样子呢就是

45:59.290 --> 46:00.290
界面上写

46:00.290 --> 46:01.290
因为界面上有可能多处用到

46:01.290 --> 46:02.290
写写简单一点

46:02.290 --> 46:04.290
像这种情况还蛮多的

46:05.290 --> 46:06.290
这还蛮多的

46:06.290 --> 46:07.290
因为毕竟在这里

46:07.290 --> 46:08.290
要写的通过

46:08.290 --> 46:09.290
动物球获取的话

46:09.290 --> 46:10.290
要写一长串

46:10.290 --> 46:11.290
那怎么办呢

46:11.290 --> 46:13.290
每一次要写个

46:13.290 --> 46:15.290
computing的呢也挺麻烦的

46:15.290 --> 46:16.290
那我怎么办呢

46:16.290 --> 46:18.290
其实这样写肯定是没问题的

46:18.290 --> 46:19.290
于是Wilkes呢

46:19.290 --> 46:21.290
他给你出了一些辅助函数

46:22.290 --> 46:24.290
比方说像这个辅助函数

46:25.290 --> 46:26.290
Wilkes

46:26.290 --> 46:27.290
你们给你出了一个

46:27.290 --> 46:28.290
辅助函数来帮你

46:28.290 --> 46:30.290
让你少写点带嘛

46:30.290 --> 46:31.290
叫MapState

46:32.290 --> 46:33.290
这个函数是干嘛用的呢

46:34.290 --> 46:35.290
这里有一个MapState

46:35.290 --> 46:36.290
你可以去看一下

46:36.290 --> 46:38.290
它有很超级多的用法

46:38.290 --> 46:39.290
一大堆的用法

46:40.290 --> 46:41.290
我不要说这里

46:41.290 --> 46:43.290
是随便举几个用法吧

46:43.290 --> 46:44.290
第一个用法

46:47.300 --> 46:48.300
我通过这个MapState

46:49.300 --> 46:50.300
调用MapState

46:50.300 --> 46:52.300
它里面可以传各种东西

46:53.300 --> 46:54.300
比方说我传一个

46:55.300 --> 46:56.300
传个啥呀

46:56.300 --> 46:57.300
我传个这个东西吧

46:58.300 --> 46:59.300
传个对象进去

47:00.300 --> 47:01.300
我不是有个loading吗

47:01.300 --> 47:02.300
对不对

47:02.300 --> 47:03.300
loading

47:03.300 --> 47:04.300
这个loading呢

47:04.300 --> 47:06.300
我这里边给他这样子传递

47:06.300 --> 47:07.300
他是一个函数

47:07.300 --> 47:08.300
他给我一个State

47:08.300 --> 47:10.300
然后我返回一个State的

47:10.300 --> 47:14.300
login user.loading

47:16.810 --> 47:17.810
这样子这个方法

47:17.810 --> 47:18.810
我跟你说他返回啥

47:18.810 --> 47:19.810
MapState返回啥

47:19.810 --> 47:21.810
他返回的是这么一个东西

47:22.810 --> 47:24.810
他返回的是一个对象

47:34.090 --> 47:35.090
这个MapState

47:35.090 --> 47:37.090
目前他会返回一个对象

47:37.090 --> 47:39.090
对象里边有一个loading方法

47:40.090 --> 47:41.090
loading

47:41.090 --> 47:42.090
这个loading呢

47:42.090 --> 47:43.090
他是这样子写的

47:44.090 --> 47:46.850
他会返回这么一个对象

47:47.850 --> 47:49.850
然后他这个loading return

47:50.850 --> 47:51.850
this

47:51.850 --> 47:52.850
Stone

47:53.850 --> 47:54.850
State

47:54.850 --> 47:55.850
login

47:56.850 --> 47:57.850
user

47:57.850 --> 47:58.850
loading

47:58.850 --> 47:59.850
他又会返回这个东西

47:59.850 --> 48:00.850
明白吧

48:00.850 --> 48:01.850
他就会

48:01.850 --> 48:02.850
MapState返回这么一个对象

48:02.850 --> 48:04.850
这个对象是不是就是我们需要的

48:04.850 --> 48:05.850
这个计算属性

48:05.850 --> 48:07.850
你看有好多种灵活的用法

48:07.850 --> 48:09.850
我是不是直接可以把个MapState放这

48:10.850 --> 48:11.850
对吧

48:11.850 --> 48:12.850
是不是直接放这

48:12.850 --> 48:13.850
我把这个返回的对象

48:13.850 --> 48:15.850
返回不就是这个对象吗

48:15.850 --> 48:16.850
我把这个返回的对象

48:16.850 --> 48:18.850
给你computer的复制

48:18.850 --> 48:19.850
这就完了

48:19.850 --> 48:20.850
然后我们再来看吧

48:20.850 --> 48:24.220
就这种非常灵活的

48:26.220 --> 48:27.220
你看

48:27.220 --> 48:28.220
什么没问题

48:29.220 --> 48:30.220
他给你返回这个东西

48:30.220 --> 48:31.220
你甚至可以把

48:31.220 --> 48:32.220
把这个对象

48:32.220 --> 48:34.220
上面拿出来输出看一下

48:34.220 --> 48:35.220
就这么个玩意

48:37.540 --> 48:38.540
那如果说

48:38.540 --> 48:40.540
那就说就想到了

48:40.540 --> 48:41.540
老师

48:41.540 --> 48:42.540
那这个玩意

48:43.540 --> 48:45.540
他把自己给computer的复制

48:45.540 --> 48:46.540
那万一我computer里面

48:46.540 --> 48:48.540
还有其他的计算属性了

48:49.540 --> 48:50.540
那你这样子我就没发起

48:50.540 --> 48:51.540
其他的计算属性了

48:54.490 --> 48:55.490
灵活处理

48:55.490 --> 48:56.490
灵活处理

48:56.490 --> 48:57.490
兄弟

48:57.490 --> 48:58.490
求求你们了

48:58.490 --> 48:59.490
这个玩意就是一个对象

48:59.490 --> 49:00.490
对吧

49:00.490 --> 49:01.490
我要的是什么

49:01.490 --> 49:02.490
要的是对象里面这个东西

49:02.490 --> 49:04.490
哪里看我这里有好多处理方式

49:04.490 --> 49:06.490
他超级多的处理方式

49:06.490 --> 49:08.490
怎么处理啊

49:08.490 --> 49:09.490
我各种处理方式都有

49:09.490 --> 49:11.490
我就这样子写个node

49:11.490 --> 49:12.490
然后把这个对象

49:12.490 --> 49:14.490
取取这个对象的node属性

49:14.490 --> 49:15.490
把node属性取出来

49:15.490 --> 49:16.490
可不可以啊

49:16.490 --> 49:17.490
当然可以啊

49:17.490 --> 49:18.490
那里边写学的计算属性

49:18.490 --> 49:19.490
是不是可以啊

49:19.490 --> 49:20.490
对吧

49:20.490 --> 49:25.400
超级多的处理方式

49:25.400 --> 49:26.400
或者是怎么样

49:26.400 --> 49:27.400
我这是个对象

49:27.400 --> 49:29.400
我把对象用展开用上去展开吗

49:29.400 --> 49:31.400
展开过后是不是就属性就展

49:31.400 --> 49:32.400
甭管他里面有多少属性

49:32.400 --> 49:33.400
就展开在这了

49:33.400 --> 49:34.400
对吧你后边要写啥

49:34.400 --> 49:35.400
你随便去写

49:35.400 --> 49:36.400
写别的计算属性

49:36.400 --> 49:37.400
对吧都可以

49:38.400 --> 49:39.400
灵活处理

49:39.400 --> 49:40.400
灵活处理

49:40.400 --> 49:41.400
不要去记着些语法

49:42.400 --> 49:44.400
维俑克斯他支持这种语法

49:44.400 --> 49:45.400
那我就封掉了

49:45.400 --> 49:46.400
那你这样的学技术

49:46.400 --> 49:47.400
我就不知道

49:47.400 --> 49:49.400
稍微变化一点怎么办呢你

49:50.400 --> 49:52.400
他就是个普通对象而已

49:52.400 --> 49:54.400
那你看这是bipestat的这种用法

49:54.400 --> 49:55.400
那还没有别的用法呢

49:55.400 --> 49:56.400
用法太多了

49:56.400 --> 49:57.400
这里边你可以看一下

49:57.400 --> 49:58.400
那个文档提供了

49:58.400 --> 49:59.400
很多种用法

49:59.400 --> 50:01.400
他可以在前面写个命名空间

50:01.400 --> 50:02.400
这个命名空间

50:02.400 --> 50:03.400
那就是你给他写在前面

50:03.400 --> 50:04.400
啊

50:04.400 --> 50:05.400
表示我们用的命名空间

50:05.400 --> 50:07.400
是node step user

50:07.400 --> 50:09.400
那么后边可以写数组的

50:09.400 --> 50:10.400
是可以写数组的

50:10.400 --> 50:12.400
那或者是写这个吗

50:13.400 --> 50:14.400
写对象也可以

50:15.400 --> 50:17.400
写对象我们用这种写法

50:18.400 --> 50:19.400
他里面不是我们要

50:19.400 --> 50:20.400
拿他拿他

50:20.400 --> 50:22.400
拿这个命名空间下的什么数据啊

50:22.400 --> 50:24.400
拿他的node的这个数据对吧

50:24.400 --> 50:25.400
那我直接就写个node

50:27.400 --> 50:28.400
然后你取什么数据呢

50:28.400 --> 50:29.400
取node

50:29.400 --> 50:31.400
也说我这个计算属性的名字

50:31.400 --> 50:32.400
叫做node

50:33.400 --> 50:34.400
然后呢

50:34.400 --> 50:36.400
他对应的那个状态的名字

50:36.400 --> 50:37.400
也叫做node

50:37.400 --> 50:38.400
这样的写也可以

50:38.400 --> 50:40.400
他反过来人家是个对象啊

50:40.400 --> 50:41.400
最终结果也是这个

50:41.400 --> 50:42.400
一样的

50:44.400 --> 50:45.400
他就给你封装了一下

50:45.400 --> 50:46.400
你看这样子也可以的

50:48.400 --> 50:49.400
他写法很多啊

50:49.400 --> 50:50.400
我都背不住

50:50.400 --> 50:51.400
我都背不住背不完

50:51.400 --> 50:52.400
然后呢

50:52.400 --> 50:53.400
还有什么写法呢

50:53.400 --> 50:54.400
他还可以这样子写啊

50:54.400 --> 50:56.400
你取这个地方

50:56.400 --> 50:57.400
比方说你可以取

50:57.400 --> 50:59.400
取这个命名空间下的哪些数据

50:59.400 --> 51:01.400
你需要的写个数组

51:01.400 --> 51:02.400
比如说我需要个node

51:02.400 --> 51:04.400
那么他就直接给你生成这个东西了

51:04.400 --> 51:06.400
那如果说你写了两个

51:06.400 --> 51:07.400
我不仅需要node

51:07.400 --> 51:08.400
我还需要那个u字

51:08.400 --> 51:09.400
他不是有两个属性吗

51:09.400 --> 51:10.400
一个node

51:10.400 --> 51:11.400
一个u字

51:11.400 --> 51:12.400
那么这边呢

51:12.400 --> 51:13.400
他就会生成两个属性

51:13.400 --> 51:14.400
一个node

51:15.400 --> 51:16.400
一个u字

51:17.400 --> 51:18.400
他这边是u字

51:18.400 --> 51:20.400
明白了意思吧

51:20.400 --> 51:21.400
他这种语言生成两个

51:21.400 --> 51:23.400
他只是为了方便你去写

51:23.400 --> 51:24.400
这个玩意计算属性的

51:24.400 --> 51:26.400
没有别的意思

51:26.400 --> 51:27.400
你如果说看他

51:27.400 --> 51:28.400
实在是看不爽利

51:28.400 --> 51:29.400
就自己写不计算属性

51:29.400 --> 51:30.400
你只要不怕麻烦

51:30.400 --> 51:31.400
那无所谓

51:31.400 --> 51:33.400
我们这里只需要用到node

51:33.400 --> 51:34.400
那就ok了

51:34.400 --> 51:35.400
这样子

51:35.400 --> 51:36.400
他又生成了个计算属性node

51:36.400 --> 51:38.400
我这里由于没有别的

51:38.400 --> 51:39.400
没有别的计算属性

51:39.400 --> 51:40.400
所以说我这里呢

51:40.400 --> 51:42.400
就直接扔过去就ok了

51:42.400 --> 51:44.710
没问题吧

51:44.710 --> 51:45.710
同学们

51:45.710 --> 51:51.480
没问题吧

51:51.480 --> 51:52.480
除了这个

51:52.480 --> 51:55.480
其实除了这个MapStats之外

51:55.480 --> 51:56.480
他还给你提供了一些别的辅助

51:56.480 --> 51:58.480
还说什么MapGatres

51:58.480 --> 52:00.480
MapGatres

52:00.480 --> 52:01.480
就是他会把一个Gatres

52:01.480 --> 52:03.480
给你映射过来

52:03.480 --> 52:04.480
也可以

52:04.480 --> 52:05.480
也可以

52:05.480 --> 52:06.480
你自己可以去看一下

52:06.480 --> 52:09.480
然后还有Map那个

52:09.480 --> 52:12.480
MapX

52:12.480 --> 52:13.480
MapX

52:13.480 --> 52:15.480
他把他生成一个对象

52:15.480 --> 52:16.480
对象里面提供各种方法

52:16.480 --> 52:17.480
给你弄过来

52:17.480 --> 52:18.480
不过MapX

52:18.480 --> 52:20.480
我个人不太习惯用

52:20.480 --> 52:22.480
其实就是一个习惯的问题

52:22.480 --> 52:23.480
根据自己的需要去用

52:23.480 --> 52:25.480
这些都是一些工具喊数

52:25.480 --> 52:28.480
不要把它想象得那么严重

52:28.480 --> 52:29.480
好

52:29.480 --> 52:30.480
那么现在呢

52:30.480 --> 52:31.480
我把这个地方搞定了

52:31.480 --> 52:32.480
现在我们回到那个

52:32.480 --> 52:33.480
component里面

52:33.480 --> 52:34.480
由着内

52:34.480 --> 52:35.480
那么这里也是一样

52:35.480 --> 52:36.480
你看这个组建里面

52:36.480 --> 52:37.480
需要哪些状态

52:37.480 --> 52:38.480
是不是需要

52:38.480 --> 52:40.480
Gatres

52:40.480 --> 52:41.480
我们需要什么呢

52:41.480 --> 52:42.480
我们需要这个东西

52:42.480 --> 52:44.480
我要知道他状态是啥

52:44.480 --> 52:45.480
是吧

52:45.480 --> 52:47.480
说我要知道他状态是啥

52:47.480 --> 52:48.480
然后呢

52:48.480 --> 52:50.480
我就可以这样来

52:50.480 --> 52:51.480
在这里边

52:51.480 --> 52:53.480
computed的时候

52:53.480 --> 52:55.480
倒入啊

52:55.480 --> 52:57.480
MapGatres

52:57.480 --> 53:00.300
Wix

53:00.300 --> 53:03.740
MapGatres

53:03.740 --> 53:05.740
如果说你不用他的话怎么写

53:05.740 --> 53:07.740
我们写个Status是吧

53:07.740 --> 53:08.740
这里就反而回

53:08.740 --> 53:09.740
Z

53:09.740 --> 53:10.740
Stats

53:10.740 --> 53:11.740
Stone

53:11.740 --> 53:13.740
Gatres

53:13.740 --> 53:14.740
之前过去过对吧

53:14.740 --> 53:15.740
然后呢

53:15.740 --> 53:16.740
LoginUser

53:16.740 --> 53:17.740
Status

53:17.740 --> 53:18.740
就反回就按下了

53:18.740 --> 53:20.740
也没什么大不了的

53:20.740 --> 53:21.740
当然有他的话

53:21.740 --> 53:24.740
你可以用MapGatres

53:24.740 --> 53:27.740
反回也是对象展开

53:27.740 --> 53:29.740
那么MapGatres怎么用呢

53:29.740 --> 53:31.740
不好意思我忘了

53:31.740 --> 53:33.740
查一下吧

53:33.740 --> 53:34.740
传一个数组

53:34.740 --> 53:35.740
就是把Gatres传进去

53:35.740 --> 53:36.740
是吧

53:36.740 --> 53:37.740
我看一下

53:37.740 --> 53:42.210
他应该是支持命名空间的

53:42.210 --> 53:43.210
应该是

53:43.210 --> 53:44.210
第一个参数命名空间

53:44.210 --> 53:45.210
LoginUser

53:45.210 --> 53:47.210
第二个参数呢是Gatres的名称

53:47.210 --> 53:49.210
你要反回哪些Gatres

53:49.210 --> 53:50.210
Status

53:50.210 --> 53:51.210
那么他就会反回

53:51.210 --> 53:52.210
刚才我们写的一个对象

53:52.210 --> 53:53.210
他自动给你反回

53:53.210 --> 53:54.210
然后你把展开就完事了

53:54.210 --> 53:55.210
当然

53:55.210 --> 53:56.210
如果说你没有别的东西的话

53:56.210 --> 53:57.210
你直接给他computed的复制

53:57.210 --> 53:58.210
也可以

53:58.210 --> 53:59.210
当然是这里呢

53:59.210 --> 54:00.210
我们可能显然

54:00.210 --> 54:01.210
还有些别的东西

54:01.210 --> 54:02.210
还有什么东西呢

54:02.210 --> 54:03.210
除了这个东西之外

54:03.210 --> 54:04.210
我们还要去

54:04.210 --> 54:06.210
拿他的这个楼顶状态

54:06.210 --> 54:07.210
对吧

54:07.210 --> 54:08.210
好像也不去

54:08.210 --> 54:09.210
这个用户

54:09.210 --> 54:10.210
当年登录的用户

54:10.210 --> 54:11.210
所以说呢

54:11.210 --> 54:15.610
我们这里还要去mabstat

54:15.610 --> 54:16.610
mabstat

54:16.610 --> 54:20.010
stat

54:20.010 --> 54:21.010
就一个东西啊

54:21.010 --> 54:22.010
你一定要看他的本质是啥

54:22.010 --> 54:24.010
你才能够灵活运用

54:24.010 --> 54:25.010
命名空间

54:25.010 --> 54:26.010
我要需要他哪个

54:26.010 --> 54:27.010
还需要他哪个数据呢

54:27.010 --> 54:28.010
数据呢

54:28.010 --> 54:29.010
我需要和优点的一个数据

54:29.010 --> 54:30.010
因为我要知道

54:30.010 --> 54:31.010
他用户名是啥

54:31.010 --> 54:32.010
我要显示到这

54:32.010 --> 54:33.010
其他的没啥

54:33.010 --> 54:34.010
如果说你这个

54:34.010 --> 54:35.010
组建里边还有别的计算

54:35.010 --> 54:36.010
首先你自己去写

54:36.010 --> 54:37.010
OK

54:37.010 --> 54:38.010
那么我们这个

54:38.010 --> 54:39.010
几个元数就要

54:39.010 --> 54:40.010
开始判断了

54:40.010 --> 54:41.010
什么情况下会显示他呢

54:41.010 --> 54:43.010
当然是Status等于

54:43.010 --> 54:44.010
loading的时候

54:45.010 --> 54:46.010
我要显示他

54:46.010 --> 54:47.010
Status

54:47.010 --> 54:48.010
不是有三种状态吗

54:48.010 --> 54:49.010
什么时候我显示

54:49.010 --> 54:50.010
这两个元数呢

54:51.010 --> 54:52.010
这就出了问题了

54:52.010 --> 54:53.010
这是个无忧的问题

54:53.010 --> 54:54.010
就是我

54:54.010 --> 54:55.010
有一种情况

54:55.010 --> 54:56.010
我要显示多个元数

54:56.010 --> 54:58.010
不是多个同级的元数

54:58.010 --> 54:59.010
那但是呢

54:59.010 --> 55:00.010
这个指令呢

55:00.010 --> 55:02.010
他只能加到一个元数上面

55:02.010 --> 55:03.010
那怎么办呢

55:03.010 --> 55:04.010
你可以用这个

55:04.010 --> 55:05.010
template

55:05.010 --> 55:06.010
这个特殊的元数

55:06.010 --> 55:07.010
给他包一下

55:07.010 --> 55:08.010
这个元数

55:08.010 --> 55:09.010
专门来做这种事情的

55:09.010 --> 55:11.010
像一些v4循环呀

55:11.010 --> 55:12.010
每一次循环

55:12.010 --> 55:13.010
你要生成几个同级元数

55:13.010 --> 55:15.010
或者是vif判断呀

55:15.010 --> 55:16.010
你每一次判断

55:16.010 --> 55:18.010
你要生成

55:18.010 --> 55:19.010
成功过后

55:19.010 --> 55:20.010
你要显示几个同级元数

55:20.010 --> 55:22.010
你可以用这个东西包一下

55:22.010 --> 55:23.010
因为他只能

55:23.010 --> 55:24.010
作用在一个元数上面

55:24.010 --> 55:26.010
他不会生存任何的元

55:26.010 --> 55:27.010
真实的动物

55:27.010 --> 55:28.010
只是用来就是

55:28.010 --> 55:29.010
提供一个

55:29.010 --> 55:31.010
语法支持的

55:31.010 --> 55:32.010
好这里呢

55:32.010 --> 55:33.010
Status

55:33.010 --> 55:34.010
如果说等于什么

55:34.010 --> 55:35.010
等于loading

55:35.010 --> 55:36.010
所以已经登录了

55:36.010 --> 55:37.010
loading

55:37.010 --> 55:38.010
我就显示这个

55:38.010 --> 55:39.010
vls呢

55:39.010 --> 55:40.010
我就显示这个

55:41.010 --> 55:42.010
对吧

55:42.010 --> 55:43.010
好

55:43.010 --> 55:44.010
那么现在看一下

55:44.010 --> 55:46.580
8080

55:46.580 --> 55:47.580
OK

55:47.580 --> 55:48.580
到左边来

55:49.580 --> 55:50.580
不是这

55:50.580 --> 55:51.580
这边

55:52.580 --> 55:53.580
好然后现在登录啊

55:53.580 --> 55:54.580
耳朵密

55:55.580 --> 55:56.580
123123

55:56.580 --> 55:57.580
回车

55:57.580 --> 55:58.580
好登录成功了

55:58.580 --> 55:59.580
一看是是不是显示他

56:00.580 --> 56:01.580
对吧

56:01.580 --> 56:02.580
好我们再刷新一次

56:02.580 --> 56:03.580
刷新一次又没有登录了

56:03.580 --> 56:04.580
然后到登录里边

56:04.580 --> 56:06.580
登录示范看一下吧

56:06.580 --> 56:07.580
loading状态

56:07.580 --> 56:08.580
是否统一的loading状态

56:08.580 --> 56:09.580
对吧

56:09.580 --> 56:10.580
这里又回到登录了

56:10.580 --> 56:11.580
没问题吧

56:12.580 --> 56:13.580
好那么这里呢

56:13.580 --> 56:14.580
我们一个个来啊

56:14.580 --> 56:15.580
首先登录成功过后

56:15.580 --> 56:16.580
这里我要显示什么呢

56:16.580 --> 56:18.580
显示是用户的名字

56:18.580 --> 56:19.580
是不是我要显示

56:19.580 --> 56:20.580
U字

56:20.580 --> 56:21.580
这个数据

56:21.580 --> 56:22.580
登录成功了他肯定有值嘛

56:22.580 --> 56:23.580
屌炼

56:24.580 --> 56:25.580
我们来看一下吧

56:25.580 --> 56:26.580
耳朵密

56:26.580 --> 56:27.580
123123

56:27.580 --> 56:28.580
回车

56:29.580 --> 56:30.580
管理员

56:30.580 --> 56:31.580
显示出来了

56:31.580 --> 56:33.580
这个玩意其实是一个超链接啊

56:33.580 --> 56:34.580
他要链接到个人中心

56:34.580 --> 56:36.580
我们就用rotlink吧

56:36.580 --> 56:39.580
rotlink2

56:39.580 --> 56:40.580
链接到哪呢

56:40.580 --> 56:41.580
链接到个人中心

56:41.580 --> 56:42.580
我们就用一个U字嘛

56:42.580 --> 56:43.580
链接到这个地址

56:43.580 --> 56:44.580
这个地址呢

56:44.580 --> 56:45.580
实际上路由里面是没有注册的

56:45.580 --> 56:46.580
我加一个组件吧

56:46.580 --> 56:47.580
U字

56:48.580 --> 56:49.580
这是个个人中心

56:51.580 --> 56:52.580
有这么一个组件

56:52.580 --> 56:54.580
在路由里面注册一下

56:54.580 --> 56:55.580
Rotz

56:58.340 --> 57:00.900
U字

57:00.900 --> 57:01.900
好 这边

57:02.900 --> 57:03.900
下面拿一个啊

57:06.410 --> 57:07.410
U字

57:07.410 --> 57:08.410
到哪呢 到个人中心

57:09.410 --> 57:10.410
好了

57:10.410 --> 57:11.410
那么这边呢

57:11.410 --> 57:12.410
我们在component

57:12.410 --> 57:14.410
这个组件里边

57:15.410 --> 57:16.410
路由导航

57:16.410 --> 57:17.410
他链接到这

57:17.410 --> 57:19.410
登入过后才看得见

57:19.410 --> 57:20.410
对吧

57:20.410 --> 57:21.410
咱们接下来

57:22.410 --> 57:23.410
Rotlink123

57:23.410 --> 57:24.410
回车

57:25.410 --> 57:26.410
管理员

57:27.410 --> 57:28.410
没问题吧

57:28.410 --> 57:29.410
到个人中心了

57:29.410 --> 57:30.410
新闻

57:30.410 --> 57:31.410
是不是没问题

57:31.410 --> 57:32.410
好 那么登出

57:32.410 --> 57:33.410
退出

57:33.410 --> 57:34.410
退出的话在这

57:34.410 --> 57:36.410
那么我给他写一个时间嘛

57:37.410 --> 57:38.410
click

57:38.410 --> 57:39.410
为了避免点击过后

57:39.410 --> 57:40.410
因为他是个超链接

57:40.410 --> 57:41.410
点到过去刷新页面了

57:41.410 --> 57:42.410
为了避免刷新页面

57:42.410 --> 57:43.410
再加上prevents

57:43.410 --> 57:44.410
这些姿势要活用

57:45.410 --> 57:46.410
然后handle

57:47.410 --> 57:48.410
login out

57:50.410 --> 57:51.410
处理退出

57:51.410 --> 57:52.410
message

57:53.410 --> 57:55.410
好 退出的时候怎么弄呢

57:55.410 --> 57:56.410
因为它是一步的

57:57.410 --> 57:58.410
首先它肯定要出发X型嘛

57:58.410 --> 57:59.410
因为X型里面有个退出

57:59.410 --> 58:01.410
它会管理倉库里比较状态

58:01.410 --> 58:02.410
this store

58:03.410 --> 58:04.410
dispatch

58:06.850 --> 58:07.850
命名空间

58:07.850 --> 58:08.850
login user

58:09.850 --> 58:10.850
login out

58:10.850 --> 58:11.850
出发这个X型

58:12.850 --> 58:13.850
没有payload

58:13.850 --> 58:14.850
没有payload

58:14.850 --> 58:15.850
然后等待它

58:16.850 --> 58:17.850
完了过后

58:17.850 --> 58:18.850
是不是就登出了

58:18.850 --> 58:19.850
登出过后干嘛

58:19.850 --> 58:20.850
我这里跳转一下页面嘛

58:20.850 --> 58:21.850
登出过后

58:21.850 --> 58:22.850
登出一定成功

58:22.850 --> 58:23.850
对吧

58:23.850 --> 58:24.850
跳转页面

58:24.850 --> 58:25.850
跳转到首页

58:25.850 --> 58:27.850
我这里使用this store

58:27.850 --> 58:28.850
一倍

58:28.850 --> 58:29.850
rotor

58:29.850 --> 58:30.850
就看你登出过后

58:30.850 --> 58:31.850
你希望跳转到哪

58:32.850 --> 58:33.850
或者跳转到登入页

58:33.850 --> 58:34.850
登入页好一点

58:34.850 --> 58:35.850
login

58:36.850 --> 58:37.850
好 咱们看一下

58:37.850 --> 58:38.850
退出

58:39.850 --> 58:41.850
就跳转到这了

58:41.850 --> 58:42.850
然后再登入

58:43.850 --> 58:46.860
再退出

58:50.780 --> 58:51.780
看呗 是不是没问题了

58:52.780 --> 58:53.780
好 还有什么问题呢

58:53.780 --> 58:55.780
就是页面最开始的时候

58:55.780 --> 58:56.780
刷新

58:56.780 --> 58:57.780
已经登入过了

58:58.780 --> 59:01.220
已经登入了嘛

59:01.220 --> 59:02.220
对吧

59:02.220 --> 59:03.220
这个状态其实已经保留下来了

59:03.220 --> 59:04.220
我们这里测试代码了

59:04.220 --> 59:06.220
是保证在dokal storage里边

59:06.220 --> 59:08.220
我们希望下一次刷新页面的时候

59:08.220 --> 59:09.220
你不要又告诉我你没有登入

59:10.220 --> 59:12.220
你希望我把这个登入状态恢复

59:12.220 --> 59:13.220
恢复出来

59:13.220 --> 59:14.220
其实就是干嘛呀

59:14.220 --> 59:15.220
其实我就要做的

59:15.220 --> 59:17.220
就是触发这个东西

59:17.220 --> 59:19.220
我要去触发这个

59:21.220 --> 59:22.220
who am i这个x

59:22.220 --> 59:24.220
它能够恢复登入状态

59:24.220 --> 59:26.220
这个x是能够恢复登入状态的

59:26.220 --> 59:28.220
它需要跟服务器之间通信

59:28.220 --> 59:29.220
那么这件事情

59:29.220 --> 59:30.220
什么时候做你觉得

59:33.420 --> 59:34.420
什么时候做

59:34.420 --> 59:35.420
恢复登入状态

59:36.420 --> 59:37.420
什么时候做

59:39.420 --> 59:40.420
你们又用了一些app

59:41.420 --> 59:42.420
用什么新浪微博那些东西

59:43.420 --> 59:44.420
点进去过后

59:44.420 --> 59:45.420
甭管你进了的是哪个页面

59:45.420 --> 59:46.420
是不是一开始

59:46.420 --> 59:48.420
又会有一个正在登入中

59:48.420 --> 59:49.420
对不对

59:49.420 --> 59:50.420
正在夹载中

59:50.420 --> 59:51.420
它在干嘛

59:51.420 --> 59:52.420
它就在恢复里的登入状态

59:52.420 --> 59:53.420
所以这件事情

59:53.420 --> 59:55.420
是最开始的时候叫做

59:55.420 --> 59:56.420
在什么时候做

59:56.420 --> 59:58.420
在这里就做

59:58.420 --> 59:59.420
在这里

59:59.420 --> 01:00:01.420
在创建5u实力之前就可以做

01:00:01.420 --> 01:00:02.420
怎么做呢

01:00:02.420 --> 01:00:03.420
这里不是个store吗

01:00:03.420 --> 01:00:04.420
disk purge

01:00:05.420 --> 01:00:06.420
老顶忧着

01:00:06.420 --> 01:00:07.420
因为我们的仓库里边是

01:00:07.420 --> 01:00:08.420
任何人

01:00:08.420 --> 01:00:09.420
任何模糊都可以改变的

01:00:09.420 --> 01:00:11.420
不是说直接有那个5u的

01:00:11.420 --> 01:00:12.420
主件可以做

01:00:12.420 --> 01:00:13.420
可以去改动它

01:00:14.420 --> 01:00:16.420
就触发一下

01:00:16.420 --> 01:00:17.420
当然它是异部的

01:00:17.420 --> 01:00:18.420
我们也就说

01:00:18.420 --> 01:00:20.420
这件事情跟那个创建5u

01:00:20.420 --> 01:00:21.420
是同时发生的

01:00:21.420 --> 01:00:22.420
比方这件事情有疫苗

01:00:22.420 --> 01:00:24.420
但是渲染组件可能只需要

01:00:24.420 --> 01:00:25.420
50毫秒

01:00:25.420 --> 01:00:26.420
那么也就是

01:00:26.420 --> 01:00:27.420
组件渲染完了过来

01:00:27.420 --> 01:00:28.420
这件事情都还没有结束

01:00:28.420 --> 01:00:29.420
没关系

01:00:29.420 --> 01:00:30.420
但是我最尽早的去触发它

01:00:30.420 --> 01:00:31.420
对吧

01:00:31.420 --> 01:00:32.420
它会改动

01:00:32.420 --> 01:00:33.420
窗户里边的状态

01:00:33.420 --> 01:00:34.420
那么这个组件的东西

01:00:34.420 --> 01:00:36.420
是根据窗户里边的状态渲染出来的

01:00:37.420 --> 01:00:38.420
保存咱们再看一下

01:00:39.420 --> 01:00:40.420
你看

01:00:40.420 --> 01:00:41.420
现在是不是可以恢复了

01:00:42.420 --> 01:00:44.420
一开始去触发这个action

01:00:44.420 --> 01:00:45.420
这个action来干嘛

01:00:45.420 --> 01:00:47.420
跟服务器之间通信的

01:00:47.420 --> 01:00:48.420
恢复了一个登录状态

01:00:48.420 --> 01:00:49.420
如果说恢复成功了

01:00:51.420 --> 01:00:52.420
如果说恢复成功了

01:00:52.420 --> 01:00:53.420
它就会把设置到

01:00:53.420 --> 01:00:54.420
窗户里边

01:00:54.420 --> 01:00:55.420
窗户一改变

01:00:55.420 --> 01:00:56.420
这些东西就跟着变了

01:00:57.420 --> 01:00:58.420
好了

01:00:58.420 --> 01:00:59.420
目前就做成这个样子了

01:01:00.420 --> 01:01:01.420
那么目前只能说

01:01:01.420 --> 01:01:03.420
你把登录

01:01:03.420 --> 01:01:05.420
这个流程这一块完成了一半

01:01:06.420 --> 01:01:08.420
只是把登录逻辑跑通了

01:01:09.420 --> 01:01:10.420
还有另外一个逻辑

01:01:10.420 --> 01:01:11.420
叫做健全

01:01:12.420 --> 01:01:15.380
什么叫健全

01:01:16.380 --> 01:01:19.380
就是我看一下有些页面

01:01:19.380 --> 01:01:21.380
这个东西就不光是

01:01:21.380 --> 01:01:22.380
窗户的问题了

01:01:22.380 --> 01:01:23.380
跟路由还有关系

01:01:23.380 --> 01:01:24.380
有些页面没有登录

01:01:24.380 --> 01:01:25.380
是不能访问的

01:01:26.380 --> 01:01:27.380
这叫健全

01:01:29.380 --> 01:01:30.380
那怎么弄呢

01:01:30.380 --> 01:01:31.380
我这里先退出

01:01:31.380 --> 01:01:32.380
给大家看一下

01:01:32.380 --> 01:01:33.380
现在有什么问题

01:01:34.380 --> 01:01:36.380
我现在进这个六十这个页面

01:01:36.380 --> 01:01:37.380
你会发现

01:01:37.380 --> 01:01:38.380
它实际上是能够进的

01:01:38.380 --> 01:01:39.380
而我希望这个页面

01:01:39.380 --> 01:01:41.380
必须要登录之后才能进

01:01:41.380 --> 01:01:42.380
还有是个人中心

01:01:42.380 --> 01:01:44.380
原来说现在个人进不去

01:01:44.380 --> 01:01:45.380
你看进不进来去

01:01:45.380 --> 01:01:46.380
我这里直接方便优着

01:01:46.380 --> 01:01:47.380
是不是进去了

01:01:49.380 --> 01:01:50.380
个人中心也能进

01:01:50.380 --> 01:01:51.380
我希望它不能进

01:01:52.380 --> 01:01:54.380
就是需要有一个东西叫健全

01:01:55.380 --> 01:01:57.380
那么健全又怎么做呢

01:01:57.380 --> 01:01:59.750
往上走

01:02:02.320 --> 01:02:03.320
这里有两张图片

01:02:04.320 --> 01:02:05.320
把这两张图研究清楚了过后

01:02:05.320 --> 01:02:07.320
你就知道这个代码开咋写

01:02:07.320 --> 01:02:08.320
第一张图

01:02:08.320 --> 01:02:09.320
一个总体的图

01:02:10.320 --> 01:02:11.320
第一张图呢

01:02:11.320 --> 01:02:13.320
就是我们刚刚进入页面的时候

01:02:13.320 --> 01:02:14.320
就最开始的刷新页面的时候

01:02:14.320 --> 01:02:15.320
甭管你是什么地址

01:02:16.320 --> 01:02:18.320
我这里就做了什么事情

01:02:18.320 --> 01:02:19.320
首先触发了一个忽安曼

01:02:20.320 --> 01:02:21.320
这几件事情是同时在做

01:02:22.320 --> 01:02:23.320
这是我们自己手续代码触发的

01:02:23.320 --> 01:02:24.320
对吧

01:02:24.320 --> 01:02:25.320
然后去改动仓库

01:02:25.320 --> 01:02:26.320
当然它是异步的

01:02:26.320 --> 01:02:27.320
可能要过一会才能

01:02:28.320 --> 01:02:29.320
让仓库的状态发生一些变化

01:02:30.320 --> 01:02:31.320
甭管我先去触发

01:02:31.320 --> 01:02:32.320
然后呢就是路由匹配

01:02:32.320 --> 01:02:34.320
这是我们的柔特组建自动完成的

01:02:34.320 --> 01:02:35.320
它会根据你的地址

01:02:35.320 --> 01:02:36.320
去匹配你的路由

01:02:36.320 --> 01:02:37.320
匹配到哪呢

01:02:37.320 --> 01:02:38.320
匹配到就是那个油热主线

01:02:39.320 --> 01:02:40.320
对吧

01:02:40.320 --> 01:02:41.320
或者是这里匹配到了

01:02:41.320 --> 01:02:42.320
一开始刷新的时候

01:02:42.320 --> 01:02:43.320
匹配到了新闻组建

01:02:44.320 --> 01:02:45.320
好

01:02:45.320 --> 01:02:46.320
然后就是我们自己写的代码

01:02:46.320 --> 01:02:47.320
根组建渲染

01:02:47.320 --> 01:02:48.320
就是这个代码

01:02:48.320 --> 01:02:50.320
这几件事情是同时在做的

01:02:51.320 --> 01:02:52.320
渲染根组建

01:02:52.320 --> 01:02:53.320
好

01:02:53.320 --> 01:02:55.320
我们再单看路由匹配

01:02:55.320 --> 01:02:56.320
路由匹配完了过后

01:02:56.320 --> 01:02:58.320
他就匹配到组建了

01:02:58.320 --> 01:03:00.320
那么他有个路由确认

01:03:00.320 --> 01:03:01.320
路由确认表示

01:03:01.320 --> 01:03:03.320
我这个路由是OK的

01:03:03.320 --> 01:03:04.320
这个路由是没问题的

01:03:04.320 --> 01:03:05.320
那么我就匹配到这个组建了

01:03:05.320 --> 01:03:07.320
匹配到这个组建过后呢

01:03:07.320 --> 01:03:11.210
那么他刚才在渲染根组建

01:03:11.210 --> 01:03:12.210
渲染根组建的时候

01:03:12.210 --> 01:03:14.210
是不是有根组建的渲染过程中

01:03:14.210 --> 01:03:15.210
有这么一个东西

01:03:15.210 --> 01:03:16.210
对吧

01:03:16.210 --> 01:03:18.210
如果说之前还没有匹配完成

01:03:18.210 --> 01:03:19.210
那么这个地方就是空白

01:03:19.210 --> 01:03:20.210
空白一片

01:03:20.210 --> 01:03:21.210
啥都看不到

01:03:21.210 --> 01:03:23.210
一旦路由匹配完成了

01:03:23.210 --> 01:03:24.210
路由确认完成了

01:03:24.210 --> 01:03:26.210
那么他就会把匹配的对应的组建

01:03:26.210 --> 01:03:27.210
渲染到这个位置

01:03:27.210 --> 01:03:28.210
就他的整个流程

01:03:29.210 --> 01:03:31.210
现在我们要看这个地方

01:03:31.210 --> 01:03:34.210
叫做一个路由前置守卫

01:03:34.210 --> 01:03:35.210
这什么意思

01:03:36.210 --> 01:03:39.650
就是说我们要看

01:03:39.650 --> 01:03:42.650
就是说我们目前有一些页面

01:03:42.650 --> 01:03:44.650
页面的本质就是组建

01:03:44.650 --> 01:03:47.650
就这个组建和这个组建

01:03:47.650 --> 01:03:48.650
他没有登录

01:03:48.650 --> 01:03:50.650
我是不希望他访问的

01:03:50.650 --> 01:03:52.650
有一种比较简单的办法

01:03:52.650 --> 01:03:53.650
是什么呢

01:03:53.650 --> 01:03:55.650
我把代码写到这个组建里一边去

01:03:55.650 --> 01:03:57.650
每个组建的creted的时候

01:03:57.650 --> 01:03:58.650
我就判断一下

01:03:58.650 --> 01:04:00.650
目前有没有登录

01:04:00.650 --> 01:04:02.650
有登录的话

01:04:02.650 --> 01:04:03.650
那就OK

01:04:03.650 --> 01:04:04.650
没有登录的话

01:04:04.650 --> 01:04:05.650
我就调转到登录也

01:04:05.650 --> 01:04:09.020
可不可以这样做呢

01:04:09.020 --> 01:04:11.020
你这样做倒是问题不大

01:04:11.020 --> 01:04:13.020
但是你这个代码

01:04:13.020 --> 01:04:15.020
是不是到处多少钱

01:04:15.020 --> 01:04:16.020
我们这个组建里边

01:04:16.020 --> 01:04:18.020
我就希望你这个组建

01:04:18.020 --> 01:04:19.020
你就专心写你这个组建的代码

01:04:19.020 --> 01:04:21.020
你不要去管什么权限的东西

01:04:21.020 --> 01:04:23.020
我统一的处理

01:04:23.020 --> 01:04:24.020
这样是不是最好的

01:04:24.020 --> 01:04:25.020
你新闻列表就好好去

01:04:25.020 --> 01:04:27.020
选择你的新闻列表

01:04:27.020 --> 01:04:28.020
你不要管什么

01:04:28.020 --> 01:04:29.020
你别人能不能进

01:04:29.020 --> 01:04:31.020
那些东西我统一处理

01:04:31.020 --> 01:04:32.020
是不是更好

01:04:32.020 --> 01:04:33.020
那么也就是说

01:04:33.020 --> 01:04:34.020
我希望把这个时间点

01:04:34.020 --> 01:04:35.020
尽量提前

01:04:35.020 --> 01:04:37.020
你不要进了组建过后

01:04:37.020 --> 01:04:38.020
再去搞这个事情

01:04:38.020 --> 01:04:41.020
最好在挑转页面的时候

01:04:41.020 --> 01:04:43.020
在很早的时候

01:04:43.020 --> 01:04:45.020
路由匹配的时候

01:04:45.020 --> 01:04:46.020
我给它加一个东西

01:04:46.020 --> 01:04:48.020
好像一个拦截器一样

01:04:48.020 --> 01:04:50.020
我们把它叫做导航守卫

01:04:50.020 --> 01:04:53.020
你进这个导航的时候

01:04:53.020 --> 01:04:55.020
比方你想进这个导航

01:04:55.020 --> 01:04:57.020
我首先就会出发一个函数

01:04:57.020 --> 01:04:59.020
看一下你能不能进

01:04:59.020 --> 01:05:00.020
然后能进了过后

01:05:00.020 --> 01:05:01.020
我给你确认

01:05:01.020 --> 01:05:02.020
我可能要等待很长一段时间

01:05:02.020 --> 01:05:03.020
因为是一步嘛

01:05:03.020 --> 01:05:05.020
我等待很长一段时间

01:05:05.020 --> 01:05:06.020
我才能确认能不能进

01:05:06.020 --> 01:05:07.020
能进过后呢

01:05:08.020 --> 01:05:09.020
我给你

01:05:09.020 --> 01:05:10.020
就给你进

01:05:10.020 --> 01:05:11.020
不能进的话

01:05:11.020 --> 01:05:13.020
我可以给你跳转到别的一面

01:05:13.020 --> 01:05:14.020
没什么意思吧

01:05:14.020 --> 01:05:16.020
我希望加上这么一个拦截的东西

01:05:16.020 --> 01:05:17.020
那么这个拦截的东西

01:05:17.020 --> 01:05:19.020
说啥呀就导航守卫

01:05:20.020 --> 01:05:21.020
在这

01:05:21.020 --> 01:05:23.020
在维若桃里面导航守卫有很多

01:05:23.020 --> 01:05:25.020
其实这些东西没有什么

01:05:25.020 --> 01:05:26.020
难的

01:05:26.020 --> 01:05:28.020
如果说你

01:05:28.020 --> 01:05:30.020
带码慢慢写多了

01:05:30.020 --> 01:05:31.020
你这些东西

01:05:31.020 --> 01:05:32.020
哪怕他没有告诉你

01:05:32.020 --> 01:05:33.020
有这个导航守卫

01:05:33.020 --> 01:05:34.020
你都大概都能猜得到

01:05:34.020 --> 01:05:36.020
他应该有这么一个东西

01:05:36.020 --> 01:05:38.020
你看AXLST他都有了

01:05:38.020 --> 01:05:40.020
一些拦截器的东西

01:05:40.020 --> 01:05:41.020
这里也应该有

01:05:41.020 --> 01:05:42.020
一个成熟的空架

01:05:42.020 --> 01:05:43.020
是应该有这些东西的

01:05:43.020 --> 01:05:45.020
能够进行一些统一的处理

01:05:45.020 --> 01:05:46.020
那么他这个拦截器呢

01:05:46.020 --> 01:05:47.020
其实有很多

01:05:49.020 --> 01:05:50.020
我也不清楚

01:05:50.020 --> 01:05:51.020
为什么现在

01:05:51.020 --> 01:05:53.020
有一些公司对这一块

01:05:53.020 --> 01:05:54.020
这么看重

01:05:54.020 --> 01:05:55.020
这个玩意

01:05:55.020 --> 01:05:56.020
在我眼中看来

01:05:56.020 --> 01:05:58.020
就是一个工具型的东西

01:05:58.020 --> 01:05:59.020
没有什么大不了的

01:05:59.020 --> 01:06:01.020
没有什么多高大上的东西

01:06:01.020 --> 01:06:02.020
只是呢

01:06:02.020 --> 01:06:03.020
它就是一个工具能够解决的

01:06:03.020 --> 01:06:04.020
一些问题

01:06:04.020 --> 01:06:05.020
有些公司他特别

01:06:05.020 --> 01:06:07.020
总是在面试里面考到

01:06:07.020 --> 01:06:08.020
所以说呢

01:06:08.020 --> 01:06:09.020
本来这个就是一些

01:06:09.020 --> 01:06:10.020
乱七八糟的API的

01:06:10.020 --> 01:06:11.020
有什么好讲的

01:06:11.020 --> 01:06:13.020
但是由于有些公司

01:06:13.020 --> 01:06:14.020
他特别还出面实体

01:06:14.020 --> 01:06:15.020
所以说将来呢

01:06:15.020 --> 01:06:16.020
我们在就业阶段

01:06:16.020 --> 01:06:17.020
还会详细的

01:06:17.020 --> 01:06:18.020
来说这个导航守卫

01:06:18.020 --> 01:06:19.020
目前呢

01:06:19.020 --> 01:06:20.020
我们就简单说

01:06:20.020 --> 01:06:21.020
其中一个东西

01:06:21.020 --> 01:06:22.020
叫做守卫

01:06:22.020 --> 01:06:23.020
叫做Before Rotor

01:06:23.020 --> 01:06:25.020
Before Each

01:06:26.020 --> 01:06:27.020
在这儿

01:06:27.020 --> 01:06:28.020
导航守卫有很多种

01:06:28.020 --> 01:06:29.020
我们就当初

01:06:29.020 --> 01:06:30.020
这一种

01:06:30.020 --> 01:06:31.020
我们到Rotor这里来

01:06:31.020 --> 01:06:32.020
这里不是一个Rotor吗

01:06:32.020 --> 01:06:36.700
找出

01:06:36.700 --> 01:06:39.210
Rotor里边

01:06:39.210 --> 01:06:40.210
其实我们可以

01:06:40.210 --> 01:06:41.210
统一的配置一些

01:06:41.210 --> 01:06:42.210
蓝阶器

01:06:42.210 --> 01:06:43.210
类似于蓝阶器

01:06:43.210 --> 01:06:44.210
这个东西

01:06:44.210 --> 01:06:45.210
Rotor

01:06:45.210 --> 01:06:46.210
它叫做Before Each

01:06:46.210 --> 01:06:47.210
你看它有Before Resolve

01:06:47.210 --> 01:06:48.210
还有After Each

01:06:48.210 --> 01:06:49.210
都有

01:06:49.210 --> 01:06:50.210
这里边传一个啥

01:06:50.210 --> 01:06:52.210
传一个回调函数

01:06:52.210 --> 01:06:53.210
这个回调函数

01:06:53.210 --> 01:06:54.210
有三个函数

01:06:54.210 --> 01:06:55.210
它都可以提示了

01:06:55.210 --> 01:06:56.210
to

01:06:56.210 --> 01:06:58.210
from

01:06:58.210 --> 01:06:59.210
next

01:07:00.210 --> 01:07:01.210
啥意思呢

01:07:01.210 --> 01:07:02.210
再说一下

01:07:02.210 --> 01:07:05.840
这是个函数

01:07:05.840 --> 01:07:06.840
首先这个函数

01:07:06.840 --> 01:07:07.840
什么时候运行

01:07:08.840 --> 01:07:09.840
每当

01:07:10.840 --> 01:07:11.840
导航

01:07:11.840 --> 01:07:12.840
切换时

01:07:13.840 --> 01:07:14.840
包含第一次

01:07:14.840 --> 01:07:16.840
包含刷新页面的第一次

01:07:19.790 --> 01:07:20.790
导航要进入

01:07:20.790 --> 01:07:22.790
进入某一个页面的时候

01:07:22.790 --> 01:07:25.680
该函数

01:07:26.680 --> 01:07:27.680
会运行

01:07:27.680 --> 01:07:29.680
就导航即将进入

01:07:29.680 --> 01:07:30.680
即将从

01:07:30.680 --> 01:07:31.680
从这个导航

01:07:31.680 --> 01:07:32.680
跳到这个导航

01:07:32.680 --> 01:07:33.680
如果说

01:07:33.680 --> 01:07:34.680
第一次刷新的话

01:07:34.680 --> 01:07:35.680
这个导航里边的信息就是

01:07:35.680 --> 01:07:37.680
很多东西都是空的

01:07:37.680 --> 01:07:38.680
它要从这个导航

01:07:38.680 --> 01:07:40.680
进入到这个导航的时候

01:07:40.680 --> 01:07:41.680
还没有进入到这个导航

01:07:41.680 --> 01:07:42.680
还没有进去

01:07:42.680 --> 01:07:43.680
这个函数就会运行

01:07:44.680 --> 01:07:45.680
那么这个运行的时候

01:07:45.680 --> 01:07:46.680
from

01:07:46.680 --> 01:07:47.680
from是什么呢

01:07:47.680 --> 01:07:48.680
from就是

01:07:49.680 --> 01:07:52.680
之前的导航

01:07:52.680 --> 01:07:53.680
就是路由对象

01:07:53.680 --> 01:07:54.680
这路由对象是啥

01:07:54.680 --> 01:07:55.680
就是我们平时用的

01:07:55.680 --> 01:07:58.680
平时用的那个z road

01:07:58.680 --> 01:07:59.680
明白了吧

01:07:59.680 --> 01:08:00.680
这里边有各种

01:08:00.680 --> 01:08:01.680
当前的路由信息

01:08:01.680 --> 01:08:03.680
然后to就是

01:08:03.680 --> 01:08:06.680
即将进入的路由对象

01:08:07.680 --> 01:08:08.680
这里就是

01:08:08.680 --> 01:08:09.680
跟我们平时做的

01:08:09.680 --> 01:08:10.680
是一样的

01:08:10.680 --> 01:08:12.680
然后那个时候是什么呢

01:08:12.680 --> 01:08:14.680
是做导航确认的

01:08:15.680 --> 01:08:18.680
确认导航的一个函数

01:08:18.680 --> 01:08:20.680
你调用这个函数

01:08:20.680 --> 01:08:24.680
调用该函数

01:08:24.680 --> 01:08:25.680
不传参数

01:08:25.680 --> 01:08:26.680
五参

01:08:26.680 --> 01:08:30.680
那么就会直接进入

01:08:30.680 --> 01:08:33.680
就会进入这个导航

01:08:33.680 --> 01:08:35.680
你不是想从它进入它吗

01:08:35.680 --> 01:08:36.680
这个函数

01:08:36.680 --> 01:08:38.680
如果说你不调用这个那个数

01:08:38.680 --> 01:08:39.680
它是不会进入的

01:08:39.680 --> 01:08:41.680
它不会进入这个tool

01:08:41.680 --> 01:08:43.680
调用过后才会进入

01:08:43.680 --> 01:08:45.680
那如果说

01:08:45.680 --> 01:08:46.680
你传参呢

01:08:46.680 --> 01:08:49.680
调用该函数

01:08:49.680 --> 01:08:50.680
传参

01:08:50.680 --> 01:08:51.680
它会根据你的参数

01:08:51.680 --> 01:08:53.680
进入到新的导航

01:08:54.680 --> 01:08:55.680
那么它会根据

01:08:55.680 --> 01:08:57.680
传入参数

01:08:57.680 --> 01:09:00.680
进入新的导航

01:09:00.680 --> 01:09:01.680
就这么个意思

01:09:02.680 --> 01:09:03.680
好,咱们来试一下

01:09:04.680 --> 01:09:05.680
Uter before each

01:09:05.680 --> 01:09:06.680
我们在这里

01:09:06.680 --> 01:09:07.680
就输出一个

01:09:08.680 --> 01:09:09.680
two

01:09:10.680 --> 01:09:11.680
保存

01:09:11.680 --> 01:09:12.680
接下来我们来看一下这边

01:09:12.680 --> 01:09:13.680
刷新

01:09:14.680 --> 01:09:15.680
看首页吧

01:09:15.680 --> 01:09:16.680
刷新

01:09:16.680 --> 01:09:17.680
你会发现

01:09:17.680 --> 01:09:19.680
这个区域没了

01:09:19.680 --> 01:09:21.680
为什么它导航确认不了

01:09:21.680 --> 01:09:23.680
它有这么一个函数

01:09:23.680 --> 01:09:24.680
你看

01:09:24.680 --> 01:09:25.680
从之前的地址

01:09:25.680 --> 01:09:26.680
之前的地址是空的

01:09:26.680 --> 01:09:27.680
因为地址刷新

01:09:28.680 --> 01:09:29.680
想到这个地址

01:09:31.680 --> 01:09:32.680
想到这个地址

01:09:33.680 --> 01:09:34.680
但是现在不行

01:09:34.680 --> 01:09:36.680
因为我没有调用这个next

01:09:36.680 --> 01:09:37.680
导航确认不了

01:09:38.680 --> 01:09:40.680
你看,现在目前的情况就这个

01:09:43.680 --> 01:09:45.680
导航路由不能确认

01:09:45.680 --> 01:09:46.680
不能确认的话

01:09:46.680 --> 01:09:47.680
它就不能匹配主线

01:09:47.680 --> 01:09:48.680
就不能渲染这个rotor view

01:09:48.680 --> 01:09:50.680
它这个地方是卡住了

01:09:50.680 --> 01:09:51.680
你没有调用next

01:09:51.680 --> 01:09:52.680
它就确认不了

01:09:53.680 --> 01:09:54.680
下面就是导航所谓的作用

01:09:54.680 --> 01:09:55.680
你可以拦解它

01:09:55.680 --> 01:09:57.680
比方说现在要去进入六四

01:09:57.680 --> 01:09:58.680
你看它又出发了这个函数

01:09:58.680 --> 01:10:00.680
要从之前的空的

01:10:00.680 --> 01:10:01.680
空的这个路由

01:10:01.680 --> 01:10:02.680
然后到了六四

01:10:03.680 --> 01:10:04.680
但是我没有确认

01:10:05.680 --> 01:10:06.680
没有确认

01:10:06.680 --> 01:10:07.680
你看地址难度不会变

01:10:07.680 --> 01:10:09.680
到老景都变不了

01:10:09.680 --> 01:10:10.680
地址难度不变

01:10:10.680 --> 01:10:12.680
那如果说我这样子显得

01:10:12.680 --> 01:10:16.440
我们是不是就可以用next了

01:10:16.440 --> 01:10:17.440
那个是

01:10:17.440 --> 01:10:18.440
无参,那不就表示说

01:10:18.440 --> 01:10:19.440
OK,我允许你通过

01:10:20.440 --> 01:10:21.440
好,那么现在我们来看一下

01:10:22.440 --> 01:10:23.440
一开始能显示的

01:10:23.440 --> 01:10:24.440
六四的时候

01:10:24.440 --> 01:10:25.440
你看这个函数是不是运行了

01:10:25.440 --> 01:10:27.440
并且我能允许它通过

01:10:27.440 --> 01:10:28.440
它就通过了

01:10:28.440 --> 01:10:30.440
老景是不是运行了这个函数

01:10:30.440 --> 01:10:31.440
我允许它通过

01:10:31.440 --> 01:10:32.440
它就通过了

01:10:33.440 --> 01:10:35.440
那如果说我刚传禅

01:10:35.440 --> 01:10:36.440
比方说我这样子显

01:10:37.440 --> 01:10:38.440
六四

01:10:40.440 --> 01:10:41.440
保存,刷新

01:10:42.440 --> 01:10:44.440
现在进入无限地规了

01:10:44.440 --> 01:10:46.440
你看,这是不是地规的错误

01:10:46.440 --> 01:10:47.440
怎么回事

01:10:47.440 --> 01:10:49.440
我本来是进了老景

01:10:49.440 --> 01:10:50.440
然后运行了这个

01:10:50.440 --> 01:10:51.440
我跳到六四

01:10:51.440 --> 01:10:53.440
跳到六四是不是又要重新运行这个

01:10:53.440 --> 01:10:54.440
对吧,又要重新运行这个

01:10:54.440 --> 01:10:55.440
它又跳到六四

01:10:55.440 --> 01:10:56.440
又要跳到六四

01:10:56.440 --> 01:10:57.440
又要重新运行这个

01:10:57.440 --> 01:10:58.440
就无限地规了

01:10:59.440 --> 01:11:00.440
就这么个意思

01:11:00.440 --> 01:11:01.440
明白吧

01:11:02.440 --> 01:11:03.440
也就是我们现在有了

01:11:03.440 --> 01:11:05.440
有了这个玩意之后

01:11:05.440 --> 01:11:06.440
我们是不是可以这里的判断

01:11:08.440 --> 01:11:10.440
我们怎么判断呢

01:11:10.440 --> 01:11:12.440
下面有张流程图

01:11:12.440 --> 01:11:13.440
有张逻辑图

01:11:13.440 --> 01:11:15.440
这逻辑图看上去就比较复杂了

01:11:15.440 --> 01:11:19.260
也就是这里和最复杂的地点

01:11:20.260 --> 01:11:21.260
看看吧

01:11:21.260 --> 01:11:24.960
这个黄色的东西

01:11:24.960 --> 01:11:26.960
就是我需要在导航

01:11:26.960 --> 01:11:28.960
路由导航一边写在

01:11:28.960 --> 01:11:29.960
需要来这写在

01:11:30.960 --> 01:11:32.960
你看我有哪些逻辑

01:11:33.960 --> 01:11:34.960
我进入到这个路由的

01:11:34.960 --> 01:11:35.960
就是

01:11:36.960 --> 01:11:37.960
路由守卫的时候

01:11:38.960 --> 01:11:39.960
导航守卫的时候

01:11:39.960 --> 01:11:40.960
我要判断一下

01:11:41.960 --> 01:11:42.960
我即将进入哪个页面

01:11:42.960 --> 01:11:43.960
即将进入它

01:11:43.960 --> 01:11:45.960
它需不需要建权

01:11:45.960 --> 01:11:46.960
怎么要建权

01:11:46.960 --> 01:11:47.960
就验证权先

01:11:47.960 --> 01:11:48.960
你能不能进

01:11:48.960 --> 01:11:49.960
需不需要

01:11:49.960 --> 01:11:50.960
我们来走一下这个流程

01:11:52.960 --> 01:11:53.960
现在我们

01:11:53.960 --> 01:11:54.960
第一件事情就卡住了

01:11:54.960 --> 01:11:56.960
我怎么知道它需不需要呢

01:11:57.960 --> 01:11:58.960
我怎么知道呢

01:11:59.960 --> 01:12:00.960
你当然可以这样的判断

01:12:03.530 --> 01:12:04.530
2里边不是pass吗

01:12:05.530 --> 01:12:06.530
你的访问路径

01:12:06.530 --> 01:12:07.530
你希望跳到哪个页面

01:12:08.530 --> 01:12:09.530
你希望跳到的是

01:12:09.530 --> 01:12:11.530
比方说跳到哪个页面

01:12:11.530 --> 01:12:12.530
是需要权限的

01:12:12.530 --> 01:12:13.530
news

01:12:13.530 --> 01:12:15.530
或者是pass

01:12:17.530 --> 01:12:18.530
等于什么呢

01:12:18.530 --> 01:12:19.530
等于那个

01:12:20.530 --> 01:12:21.530
user对吧

01:12:21.530 --> 01:12:22.530
一个用户业一个新闻业

01:12:22.530 --> 01:12:23.530
是需要建权的

01:12:23.530 --> 01:12:24.530
那么这里

01:12:24.530 --> 01:12:25.530
这可不可以通用它来判断

01:12:27.530 --> 01:12:28.530
对不对

01:12:28.530 --> 01:12:29.530
这样的判断呢

01:12:30.530 --> 01:12:31.530
有点不好

01:12:31.530 --> 01:12:32.530
为什么路径有写死了

01:12:32.530 --> 01:12:34.530
当然路径规则变了过

01:12:34.530 --> 01:12:35.530
有完蛋了

01:12:35.530 --> 01:12:36.530
我们最好怎么样呢

01:12:36.530 --> 01:12:37.530
我们最好是

01:12:38.530 --> 01:12:40.530
因为这个得到是路由对象

01:12:40.530 --> 01:12:41.530
路由对象里边

01:12:41.530 --> 01:12:42.530
它其实就是

01:12:42.530 --> 01:12:43.530
这一部分

01:12:43.530 --> 01:12:44.530
这个对象里边

01:12:44.530 --> 01:12:46.530
还给你加了一些别的属性

01:12:46.530 --> 01:12:48.530
我们现在要做的事情是

01:12:48.530 --> 01:12:50.530
可以把这个地方配置一些

01:12:50.530 --> 01:12:51.530
额外的信息

01:12:51.530 --> 01:12:52.530
配置什么信息呢

01:12:52.530 --> 01:12:53.530
其中一个信息叫元数据

01:12:53.530 --> 01:12:54.530
meta

01:12:57.530 --> 01:12:58.530
这里边是个对象

01:12:58.530 --> 01:13:00.530
对象里边是个自定的对象

01:13:00.530 --> 01:13:02.530
你不要可以写任何信息

01:13:02.530 --> 01:13:03.530
不要说写这个信息

01:13:03.530 --> 01:13:04.530
20

01:13:04.530 --> 01:13:05.530
去

01:13:05.530 --> 01:13:06.530
任何属性

01:13:06.530 --> 01:13:08.530
你写A等于B等于2都可以

01:13:09.530 --> 01:13:10.530
你写这个东西

01:13:11.530 --> 01:13:12.530
好写这个东西的意思呢

01:13:12.530 --> 01:13:13.530
就是说

01:13:13.530 --> 01:13:14.530
我给你

01:13:14.530 --> 01:13:15.530
告诉你啊

01:13:15.530 --> 01:13:16.530
这里是需要权限的

01:13:16.530 --> 01:13:17.530
当这个属性名

01:13:17.530 --> 01:13:19.530
属性者你自行规定

01:13:20.530 --> 01:13:21.530
这里有点也是一样

01:13:21.530 --> 01:13:23.530
我们可以干写个meta

01:13:23.530 --> 01:13:24.530
叫元数据

01:13:24.530 --> 01:13:25.530
20

01:13:25.530 --> 01:13:27.530
当然你可以写很多别的信息

01:13:28.530 --> 01:13:29.530
去

01:13:30.530 --> 01:13:31.530
你看

01:13:31.530 --> 01:13:32.530
现在这两个路由是不是

01:13:32.530 --> 01:13:33.530
多了一个额外的信息了

01:13:33.530 --> 01:13:35.530
于是我们在这边

01:13:35.530 --> 01:13:37.530
在这个路由导航里边

01:13:37.530 --> 01:13:39.530
导航守卫里边

01:13:39.530 --> 01:13:41.530
我们再调问那个是吧

01:13:41.530 --> 01:13:42.530
先调问他

01:13:42.530 --> 01:13:44.530
我们再输出一下一个tu

01:13:44.530 --> 01:13:48.100
我们访问login

01:13:48.100 --> 01:13:49.100
你看这里

01:13:49.100 --> 01:13:50.100
没有任何信息

01:13:50.100 --> 01:13:52.100
对吧,meta里边没有任何信息

01:13:52.100 --> 01:13:53.100
但是如果说我们访问duce

01:13:53.100 --> 01:13:55.100
它是不是运行导航守卫

01:13:55.100 --> 01:13:57.100
所以我们meta里边有个20等于2

01:13:57.100 --> 01:13:58.100
我们访问什么

01:13:58.100 --> 01:13:59.100
访问U字

01:14:00.100 --> 01:14:01.100
我们可以说不该

01:14:01.100 --> 01:14:02.100
可以在路由那个位置

01:14:02.100 --> 01:14:03.100
统一定义

01:14:04.100 --> 01:14:05.100
20等于2

01:14:05.100 --> 01:14:06.100
对吧

01:14:06.100 --> 01:14:07.100
20等于2

01:14:07.100 --> 01:14:08.100
所以说我们以后

01:14:08.100 --> 01:14:09.100
就可以在路由这个位置

01:14:09.100 --> 01:14:11.100
可以通过一个简单的meta

01:14:11.100 --> 01:14:13.100
往里边加一些自定义的消息

01:14:13.100 --> 01:14:14.100
来描述

01:14:14.100 --> 01:14:16.100
这个路由有什么特殊之处

01:14:17.100 --> 01:14:18.100
描述一下就完事了

01:14:18.100 --> 01:14:20.100
因为我们在路由导航守卫里边

01:14:20.100 --> 01:14:22.100
可以统一处理

01:14:22.100 --> 01:14:23.100
那么这边我们是不是可以判断

01:14:23.100 --> 01:14:26.100
判断什么2.meta

01:14:26.100 --> 01:14:28.100
20属性有没有指

01:14:28.100 --> 01:14:29.100
是不是维2

01:14:29.100 --> 01:14:31.100
如果说维2

01:14:31.100 --> 01:14:33.100
就需要建权

01:14:34.100 --> 01:14:36.100
那么进入建权流程

01:14:36.100 --> 01:14:40.240
建权流程

01:14:40.240 --> 01:14:43.240
好 else 就是不需要建权

01:14:43.240 --> 01:14:44.240
不需要建权

01:14:44.240 --> 01:14:46.240
我们就走那个next

01:14:46.240 --> 01:14:47.240
你还是不是形成这么一个逻辑了

01:14:47.240 --> 01:14:50.620
看一下我们的图

01:14:50.620 --> 01:14:51.620
这个页面需要建权吗

01:14:51.620 --> 01:14:53.620
需要建权就进入建权流程

01:14:53.620 --> 01:14:54.620
不需要建权

01:14:54.620 --> 01:14:55.620
直接进入目标页

01:14:55.620 --> 01:14:56.620
是不是直接调到next

01:14:56.620 --> 01:14:57.620
进入目标页

01:14:57.620 --> 01:14:58.620
是不是这个逻辑

01:14:58.620 --> 01:14:59.620
你不需要建权

01:14:59.620 --> 01:15:00.620
我还弄什么

01:15:00.620 --> 01:15:02.620
不需要弄

01:15:02.620 --> 01:15:03.620
那么需要建权

01:15:03.620 --> 01:15:05.620
又是怎么样的一个流程

01:15:05.620 --> 01:15:07.620
首先是看一下

01:15:07.620 --> 01:15:10.620
你目前的状态是啥

01:15:10.620 --> 01:15:12.620
目前你这个登陆

01:15:12.620 --> 01:15:13.620
因为我们建权

01:15:13.620 --> 01:15:14.620
就看一看登陆用户

01:15:14.620 --> 01:15:16.620
你到底是在登陆中

01:15:16.620 --> 01:15:18.620
是在夹载中

01:15:18.620 --> 01:15:19.620
到底不能确定

01:15:19.620 --> 01:15:20.620
有没有登陆成功

01:15:20.620 --> 01:15:21.620
恢复登陆状态

01:15:21.620 --> 01:15:23.620
忽而慢

01:15:23.620 --> 01:15:25.620
是在夹载中

01:15:25.620 --> 01:15:27.620
还是说你已经表示

01:15:27.620 --> 01:15:28.620
有登陆用户了

01:15:28.620 --> 01:15:29.620
还是没有登陆用户

01:15:29.620 --> 01:15:30.620
是不是这三种状态

01:15:30.620 --> 01:15:32.620
是不是对应到仓库里边

01:15:32.620 --> 01:15:34.620
这个东西

01:15:34.620 --> 01:15:36.620
这个status

01:15:36.620 --> 01:15:37.620
那么我们这里是否

01:15:37.620 --> 01:15:38.620
拿到一个status来判断

01:15:38.620 --> 01:15:40.620
肯定逻辑不一样吗

01:15:40.620 --> 01:15:41.620
来

01:15:41.620 --> 01:15:42.620
我们这里呢

01:15:42.620 --> 01:15:43.620
到这

01:15:46.620 --> 01:15:48.620
需要建权进入建权流程

01:15:48.620 --> 01:15:50.620
我们这里能拿到这个status

01:15:50.620 --> 01:15:51.620
怎么拿呢

01:15:51.620 --> 01:15:52.620
导入仓库

01:15:52.620 --> 01:15:53.620
因为仓库是

01:15:53.620 --> 01:15:54.620
任何某盒都可以使用的

01:15:54.620 --> 01:15:55.620
不要认为

01:15:55.620 --> 01:15:57.620
只有主间里面可以使用

01:15:58.620 --> 01:16:00.620
通过这个status

01:16:00.620 --> 01:16:01.620
getters

01:16:01.620 --> 01:16:02.620
什么getters

01:16:02.620 --> 01:16:04.620
loginUserStatus

01:16:04.620 --> 01:16:06.620
是不是拿到后来状态

01:16:06.620 --> 01:16:08.620
状态是不是有三种

01:16:08.620 --> 01:16:10.620
如果说状态

01:16:10.620 --> 01:16:11.620
等于

01:16:11.620 --> 01:16:12.620
login

01:16:12.620 --> 01:16:14.620
是不是夹载中的状态

01:16:14.620 --> 01:16:15.620
else

01:16:15.620 --> 01:16:16.620
if

01:16:16.620 --> 01:16:17.620
status

01:16:17.620 --> 01:16:18.620
等于什么

01:16:18.620 --> 01:16:19.620
等于那个

01:16:19.620 --> 01:16:21.620
login

01:16:21.620 --> 01:16:22.620
表示

01:16:22.620 --> 01:16:24.620
这个是表示夹载中

01:16:24.620 --> 01:16:26.620
夹载中

01:16:26.620 --> 01:16:28.620
无法确定

01:16:28.620 --> 01:16:30.620
是否已登录

01:16:30.620 --> 01:16:32.620
确定不了目前

01:16:32.620 --> 01:16:34.620
好

01:16:34.620 --> 01:16:35.620
status

01:16:35.620 --> 01:16:37.620
login表示的是

01:16:37.620 --> 01:16:39.620
登录成功了

01:16:39.620 --> 01:16:41.620
已经登录过了

01:16:41.620 --> 01:16:43.620
登录过了

01:16:43.620 --> 01:16:47.500
else就是为登录

01:16:47.500 --> 01:16:49.500
那么看流程

01:16:49.500 --> 01:16:50.500
如果说已经登录过了

01:16:50.500 --> 01:16:51.500
非常简单

01:16:51.500 --> 01:16:52.500
直接进入目标也就行了

01:16:52.500 --> 01:16:53.500
你虽然说需要建权

01:16:53.500 --> 01:16:54.500
需要权限

01:16:54.500 --> 01:16:56.500
但是我已经登录了

01:16:56.500 --> 01:16:57.500
当然有些系统可能

01:16:57.500 --> 01:16:58.500
更加复杂一点

01:16:58.500 --> 01:17:00.500
登录过后你不一定有权限

01:17:00.500 --> 01:17:01.500
你可能这个页面必须要

01:17:01.500 --> 01:17:02.500
VIP产能访问

01:17:02.500 --> 01:17:03.500
那么你又可以去加一个

01:17:03.500 --> 01:17:04.500
置地引属性

01:17:04.500 --> 01:17:06.500
VIP为出

01:17:06.500 --> 01:17:07.500
VIP为出的话

01:17:07.500 --> 01:17:08.500
哪有判断用户

01:17:08.500 --> 01:17:09.500
到底是不是VIP

01:17:09.500 --> 01:17:11.500
那么这里就统一处理了

01:17:11.500 --> 01:17:12.500
登录

01:17:12.500 --> 01:17:14.500
成功过后这就是有用户了

01:17:14.500 --> 01:17:15.500
那么就ok

01:17:15.500 --> 01:17:16.500
那就直接进

01:17:17.500 --> 01:17:18.500
直接进

01:17:19.500 --> 01:17:21.500
好 没有登录怎么办

01:17:21.500 --> 01:17:23.500
我们把这个逻辑走一路

01:17:23.500 --> 01:17:24.500
没有登录

01:17:24.500 --> 01:17:25.500
是不是要进入登录也

01:17:25.500 --> 01:17:26.500
好

01:17:26.500 --> 01:17:27.500
我们进入登录也

01:17:27.500 --> 01:17:28.500
进入登录页面就行了

01:17:28.500 --> 01:17:31.500
因此我不能给你通过了

01:17:31.500 --> 01:17:32.500
我要让你什么

01:17:32.500 --> 01:17:34.500
要进入登录也

01:17:34.500 --> 01:17:35.500
看没

01:17:35.500 --> 01:17:37.500
是不是这个逻辑还写好

01:17:37.500 --> 01:17:40.390
好了

01:17:40.390 --> 01:17:42.390
那么这样就是这个楼顶中的状态

01:17:42.390 --> 01:17:44.390
夹在中的状态

01:17:44.390 --> 01:17:45.390
你夹在中的时候

01:17:45.390 --> 01:17:47.390
这个时候怎么办

01:17:47.390 --> 01:17:49.390
这个时候怎么办

01:17:49.390 --> 01:17:51.390
我现在既不能确定他有登录

01:17:51.390 --> 01:17:53.390
也不能确定他没有登录

01:17:53.390 --> 01:17:54.390
你看啊

01:17:54.390 --> 01:17:55.390
最开始的时候

01:17:55.390 --> 01:17:56.390
我们是不是调了这个户外卖

01:17:56.390 --> 01:17:58.390
这户外卖哪怕我们把时间射长一点

01:17:58.390 --> 01:18:00.390
他要一年才能知道有没有登录

01:18:01.390 --> 01:18:03.390
那我一开始要进这个路

01:18:03.390 --> 01:18:04.390
有是不是要等一年啊

01:18:04.390 --> 01:18:05.390
我肯定得等一年啊

01:18:05.390 --> 01:18:07.390
因为我要一年之后才能知道

01:18:07.390 --> 01:18:08.390
还有没有登录

01:18:08.390 --> 01:18:09.390
那这一年干嘛这一年

01:18:10.390 --> 01:18:11.390
这一天我干嘛了

01:18:11.390 --> 01:18:12.390
现在我就啥都没有干

01:18:12.390 --> 01:18:14.390
现在是啥情况呢

01:18:15.390 --> 01:18:16.390
显示不出来了

01:18:17.390 --> 01:18:18.390
我们进这个页

01:18:18.390 --> 01:18:19.390
啥都显示不出来

01:18:19.390 --> 01:18:20.390
为什么呢

01:18:20.390 --> 01:18:21.390
他进入到这了

01:18:21.390 --> 01:18:23.390
一开始是楼顶状态

01:18:23.390 --> 01:18:25.390
他也不能确定有没有登录成功

01:18:26.390 --> 01:18:27.390
所以代码到这了

01:18:27.390 --> 01:18:29.390
他既没有挑战到楼顶

01:18:29.390 --> 01:18:30.390
也没有让他通过

01:18:30.390 --> 01:18:31.390
他就啥都没他做了

01:18:32.390 --> 01:18:34.390
那么这个时候我们一般来说会干嘛呀

01:18:34.390 --> 01:18:36.390
一般来说我们会进入到一个

01:18:37.390 --> 01:18:39.390
坚权等待页

01:18:39.390 --> 01:18:40.390
比如我们现在需要一个页面

01:18:41.390 --> 01:18:43.390
这个叫做坚权等待页

01:18:44.390 --> 01:18:45.390
这个页面主要重点就是

01:18:45.390 --> 01:18:46.390
显示一个东西

01:18:46.390 --> 01:18:47.390
给用户看

01:18:47.390 --> 01:18:48.390
你现在我现在也不能确定

01:18:48.390 --> 01:18:49.390
能不能让你过

01:18:49.390 --> 01:18:50.390
先让你看一个东西

01:18:50.390 --> 01:18:51.390
给他一个图片呀

01:18:51.390 --> 01:18:52.390
或者给他一个什么玩意

01:18:52.390 --> 01:18:54.390
让你知道我现在正在登录中

01:18:55.390 --> 01:18:56.390
说明里面平时用那个APP的时候

01:18:56.390 --> 01:18:58.390
就看到那个正在恢复登录中

01:18:58.390 --> 01:18:59.390
有一个发出终枝

01:18:59.390 --> 01:19:01.390
或者是一个小轮带来跑

01:19:01.390 --> 01:19:03.390
他在恢复里的登录状态

01:19:04.390 --> 01:19:05.390
给他看一个东西

01:19:05.390 --> 01:19:06.390
还不能用回来的瞎等

01:19:06.390 --> 01:19:08.390
所以说我们在VU里面

01:19:08.390 --> 01:19:09.390
需要新建一个页面

01:19:09.390 --> 01:19:11.390
就取个名字叫楼顶吧

01:19:11.390 --> 01:19:13.390
这页面我就显示一句话

01:19:13.390 --> 01:19:16.390
正在恢复登录中

01:19:17.390 --> 01:19:19.390
或者是正在登录中

01:19:20.390 --> 01:19:21.390
就显示这个页面

01:19:22.390 --> 01:19:23.390
这个页面呢

01:19:23.390 --> 01:19:24.390
我们就在路由里面加一个

01:19:28.180 --> 01:19:33.110
楼顶

01:19:33.110 --> 01:19:34.110
这里加一个

01:19:36.940 --> 01:19:37.940
楼顶

01:19:38.940 --> 01:19:39.940
这个页面不需要全线

01:19:39.940 --> 01:19:41.940
就这两个页面需要全线

01:19:41.940 --> 01:19:43.940
然后我们到路由里面

01:19:43.940 --> 01:19:45.940
加在楼我们到哪去

01:19:45.940 --> 01:19:47.940
到楼顶里面去

01:19:48.940 --> 01:19:50.940
好 这个逻辑就走通了

01:19:50.940 --> 01:19:51.940
你看

01:19:51.940 --> 01:19:52.940
一开始呢

01:19:52.940 --> 01:19:53.940
我们在哪呢

01:19:53.940 --> 01:19:55.940
一开始我去了个新闻

01:19:55.940 --> 01:19:56.940
刷新

01:19:56.940 --> 01:19:57.940
进新闻

01:20:01.820 --> 01:20:05.390
你看是不是进入到楼顶也了

01:20:05.390 --> 01:20:06.390
对吧

01:20:06.390 --> 01:20:07.390
他一开始不能去

01:20:07.390 --> 01:20:08.390
他的有一个登录成功

01:20:08.390 --> 01:20:09.390
然后呢

01:20:09.390 --> 01:20:10.390
如果说已经确定了

01:20:10.390 --> 01:20:11.390
有没有登录成功了

01:20:11.390 --> 01:20:12.390
比较现在没有登录

01:20:12.390 --> 01:20:13.390
对吧

01:20:13.390 --> 01:20:14.390
一开始没有登录

01:20:14.390 --> 01:20:15.390
那么这个时候呢

01:20:15.390 --> 01:20:16.390
我再去

01:20:16.390 --> 01:20:17.390
再跳转到60

01:20:17.390 --> 01:20:18.390
能跳转吗

01:20:18.390 --> 01:20:19.390
跳转不过去

01:20:19.390 --> 01:20:20.390
跳转不过去

01:20:20.390 --> 01:20:21.390
当然你可以提示一下

01:20:21.390 --> 01:20:22.390
为登录

01:20:22.390 --> 01:20:23.390
你可以提示一下

01:20:24.390 --> 01:20:25.390
该页面

01:20:26.390 --> 01:20:27.390
需要登录

01:20:27.390 --> 01:20:29.390
你还没有登录

01:20:30.390 --> 01:20:31.390
请先登

01:20:32.390 --> 01:20:34.390
好 接下来我们来看一下

01:20:34.390 --> 01:20:35.390
已经确定了

01:20:35.390 --> 01:20:36.390
目前没有登录

01:20:36.390 --> 01:20:38.390
然后我们现在进入这个60

01:20:38.390 --> 01:20:39.390
进去

01:20:39.390 --> 01:20:41.390
就出发这句话

01:20:41.390 --> 01:20:43.390
他又可以回到楼顶了

01:20:43.390 --> 01:20:45.390
就这个意思

01:20:45.390 --> 01:20:46.390
那如果说你已经登录了

01:20:46.390 --> 01:20:47.390
他就会直接让你过

01:20:47.390 --> 01:20:49.390
比方说我们现在登录成功

01:20:52.390 --> 01:20:53.390
好 现在我们

01:20:53.390 --> 01:20:54.390
从各种东西

01:20:54.390 --> 01:20:55.390
跳到各种东西

01:20:55.390 --> 01:20:56.390
没问题吧

01:20:56.390 --> 01:20:57.390
跳过去了

01:20:57.390 --> 01:20:58.390
然后进入60

01:20:58.390 --> 01:20:59.390
没问题吧

01:20:59.390 --> 01:21:00.390
跳过去了

01:21:00.390 --> 01:21:01.390
让你通过了

01:21:01.390 --> 01:21:02.390
没了意思吧

01:21:02.390 --> 01:21:03.390
现在我们又可以出

01:21:04.390 --> 01:21:05.390
没有登录了

01:21:05.390 --> 01:21:06.390
现在我们再去进那个60

01:21:06.390 --> 01:21:07.390
是不是到这

01:21:09.390 --> 01:21:10.390
对吧

01:21:10.390 --> 01:21:11.390
就这么个意思

01:21:12.390 --> 01:21:13.390
好 那如果说是

01:21:13.390 --> 01:21:14.390
一开始进入60的

01:21:14.390 --> 01:21:16.390
那么就会进入那个

01:21:16.390 --> 01:21:17.390
正在加载中

01:21:17.390 --> 01:21:18.390
因为一开始要一秒钟的时间

01:21:18.390 --> 01:21:19.390
我们这里就模拟远程

01:21:19.390 --> 01:21:20.390
就需要一秒

01:21:20.390 --> 01:21:21.390
一秒钟过后

01:21:21.390 --> 01:21:22.390
我才知道有没有登录成功

01:21:22.390 --> 01:21:23.390
那这一秒钟之内

01:21:24.390 --> 01:21:25.390
所以加载中的状态

01:21:26.390 --> 01:21:27.390
还去跳到这个页面

01:21:27.390 --> 01:21:28.390
但这个页面

01:21:28.390 --> 01:21:29.390
它没完没了

01:21:29.390 --> 01:21:30.390
就在这些显示

01:21:31.390 --> 01:21:32.390
它不能没了

01:21:32.390 --> 01:21:33.390
我的显示

01:21:33.390 --> 01:21:34.390
所以说我们这里还有一个逻辑

01:21:35.390 --> 01:21:36.390
坚权等待业

01:21:36.390 --> 01:21:38.390
它不能没完没了的等待

01:21:38.390 --> 01:21:40.390
它要去监控仓库

01:21:40.390 --> 01:21:41.390
里边状态的变化

01:21:41.390 --> 01:21:43.390
如果说你状态变了

01:21:43.390 --> 01:21:44.390
我怎么样呢

01:21:45.390 --> 01:21:48.390
我这里就重新跳

01:21:48.390 --> 01:21:49.390
跳到目标业

01:21:49.390 --> 01:21:51.390
重新来走一下这个流程

01:21:51.390 --> 01:21:52.390
你不能不可能

01:21:52.390 --> 01:21:53.390
永远在加载中

01:21:53.390 --> 01:21:54.390
哪怕你等一年

01:21:54.390 --> 01:21:55.390
一年的时间就总会到

01:21:56.390 --> 01:21:58.390
我就监控仓库

01:21:58.390 --> 01:21:59.390
里边的状态变化

01:21:59.390 --> 01:22:00.390
那么现在我们回到这

01:22:00.390 --> 01:22:01.390
我这边要铁带码

01:22:01.390 --> 01:22:03.390
去监控仓库的变化

01:22:03.390 --> 01:22:04.390
我怎么监控

01:22:05.390 --> 01:22:06.390
我咋监控仓库的变化

01:22:07.390 --> 01:22:08.390
是不是可以用watch

01:22:09.390 --> 01:22:10.390
对不对

01:22:10.390 --> 01:22:12.390
watch什么数据

01:22:12.390 --> 01:22:14.390
哪个数据

01:22:14.390 --> 01:22:16.390
是仓库里边

01:22:16.390 --> 01:22:17.390
Stone里边

01:22:17.390 --> 01:22:18.390
当然属性不能那样

01:22:18.390 --> 01:22:19.390
属性是一个字幕刷

01:22:19.390 --> 01:22:20.390
所以说你得用这种方式来写

01:22:21.390 --> 01:22:22.390
它比较长

01:22:22.390 --> 01:22:25.390
仓库里边哪个东西的变化

01:22:25.390 --> 01:22:26.390
getters

01:22:28.700 --> 01:22:29.700
哪个数据

01:22:29.700 --> 01:22:30.700
locking user

01:22:31.700 --> 01:22:32.700
Status

01:22:32.700 --> 01:22:34.700
所以就监控这个状态的变化

01:22:35.700 --> 01:22:36.700
对吧

01:22:36.700 --> 01:22:37.700
它目前是loading

01:22:37.700 --> 01:22:38.700
loading才会跑到这来

01:22:38.700 --> 01:22:39.700
要把监控它的变化

01:22:41.700 --> 01:22:42.700
但是

01:22:42.700 --> 01:22:44.700
watch它不允许你这样写的

01:22:45.700 --> 01:22:46.700
不允许你这样写的

01:22:46.700 --> 01:22:47.700
这样写要报错的

01:22:47.700 --> 01:22:48.700
不能使别

01:22:48.700 --> 01:22:49.700
它只能使别

01:22:49.700 --> 01:22:50.700
用底这个符号

01:22:50.700 --> 01:22:51.700
来导航属性

01:22:51.700 --> 01:22:52.700
你这样的属性

01:22:52.700 --> 01:22:53.700
它不能使别的

01:22:53.700 --> 01:22:54.700
那怎么办

01:22:55.700 --> 01:22:56.700
全是问题

01:22:57.700 --> 01:22:58.700
这个watch

01:22:58.700 --> 01:22:59.700
你可以通过查

01:22:59.700 --> 01:23:00.700
无诱的稳当

01:23:00.700 --> 01:23:01.700
现在要跑去查

01:23:01.700 --> 01:23:02.700
无诱的稳当了

01:23:02.700 --> 01:23:03.700
无诱里边

01:23:03.700 --> 01:23:05.700
除了使用watch配置之外

01:23:05.700 --> 01:23:06.700
还可以使用

01:23:06.700 --> 01:23:08.700
无诱里面一个实力的

01:23:08.700 --> 01:23:09.700
函数叫watch

01:23:09.700 --> 01:23:10.700
多的watch

01:23:10.700 --> 01:23:12.700
调用这个函数来监控

01:23:12.700 --> 01:23:13.700
其实这里的配置

01:23:13.700 --> 01:23:14.700
其实最终还是

01:23:14.700 --> 01:23:15.700
调用函数来监控

01:23:15.700 --> 01:23:16.700
那么也就是说

01:23:16.700 --> 01:23:17.700
我在这个组建

01:23:17.700 --> 01:23:18.700
一开始的时候

01:23:18.700 --> 01:23:19.700
我可以调用

01:23:20.700 --> 01:23:21.700
watch监控

01:23:22.700 --> 01:23:23.700
监控

01:23:23.700 --> 01:23:24.700
那么第一个参数

01:23:24.700 --> 01:23:25.700
你可以写成一个函数

01:23:25.700 --> 01:23:26.700
这个函数的返回值

01:23:26.700 --> 01:23:28.700
它监控这个函数的返回值

01:23:29.700 --> 01:23:30.700
它可以直接这样监控

01:23:30.700 --> 01:23:31.700
不要这个写

01:23:31.700 --> 01:23:32.700
我写一个函数

01:23:32.700 --> 01:23:33.700
这个函数的返回值是啥

01:23:33.700 --> 01:23:34.700
这个函数的返回值

01:23:34.700 --> 01:23:36.700
我要监控这个

01:23:36.700 --> 01:23:37.700
Stone

01:23:37.700 --> 01:23:38.700
第二

01:23:39.700 --> 01:23:40.700
Gatres

01:23:41.700 --> 01:23:42.700
LoginUser

01:23:43.700 --> 01:23:44.700
Stanters

01:23:44.700 --> 01:23:45.700
我要监控它

01:23:45.700 --> 01:23:46.700
就没有烟化

01:23:47.700 --> 01:23:48.700
好 第二个参数呢

01:23:48.700 --> 01:23:49.700
就是毁掉函数

01:23:49.700 --> 01:23:50.700
它变化了

01:23:50.700 --> 01:23:51.700
它就会运行这个毁掉函数

01:23:52.700 --> 01:23:53.700
当然这个函数有两个参数

01:23:53.700 --> 01:23:54.700
一个新的值

01:23:54.700 --> 01:23:55.700
一个旧的值

01:23:55.700 --> 01:23:56.700
就新的值

01:23:56.700 --> 01:23:57.700
得到新的值

01:23:59.700 --> 01:24:00.700
输出

01:24:00.700 --> 01:24:01.700
状态

01:24:01.700 --> 01:24:02.700
为

01:24:02.700 --> 01:24:04.700
现在变为了Stanters

01:24:04.700 --> 01:24:05.700
好 第三个参数

01:24:05.700 --> 01:24:06.700
就相当于是March里面的

01:24:06.700 --> 01:24:07.700
其他额外配置

01:24:07.700 --> 01:24:08.700
比较说Immediate

01:24:10.700 --> 01:24:12.700
Immediate

01:24:13.700 --> 01:24:14.700
回去

01:24:15.700 --> 01:24:16.700
好 老陈

01:24:16.700 --> 01:24:17.700
你看一下

01:24:18.700 --> 01:24:19.700
你看 状态一开始为Unlocking

01:24:21.700 --> 01:24:22.700
你看进入一个组建的过合

01:24:22.700 --> 01:24:23.700
它一开始状态

01:24:23.700 --> 01:24:24.700
目前状态变化了

01:24:24.700 --> 01:24:25.700
变化成Unlocking的

01:24:26.700 --> 01:24:27.700
再刷新一下

01:24:27.700 --> 01:24:28.700
状态一开始为Loading

01:24:28.700 --> 01:24:29.700
然后变化成Unlocking

01:24:29.700 --> 01:24:31.700
是不是都能运行到了

01:24:32.700 --> 01:24:34.700
好 那么就是这个监控

01:24:34.700 --> 01:24:36.700
怎么来取消监控呢

01:24:36.700 --> 01:24:38.700
因为这个组建最终会消失

01:24:38.700 --> 01:24:39.700
消失过后就不能监控了

01:24:39.700 --> 01:24:40.700
怎么来取消监控呢

01:24:40.700 --> 01:24:41.700
我们可以

01:24:41.700 --> 01:24:43.700
它会返回一个函数

01:24:43.700 --> 01:24:44.700
返回函数

01:24:44.700 --> 01:24:45.700
我们可以保持到

01:24:45.700 --> 01:24:46.700
Race里面 叫Unlock

01:24:46.700 --> 01:24:47.700
返回这个函数

01:24:47.700 --> 01:24:49.700
一调用 它就会取消监控

01:24:49.700 --> 01:24:50.700
就取消

01:24:50.700 --> 01:24:52.700
取消那个观察

01:24:52.700 --> 01:24:53.700
它会返回一个函数

01:24:53.700 --> 01:24:54.700
这个函数一调用

01:24:54.700 --> 01:24:55.700
它就会取消观察

01:24:55.700 --> 01:24:56.700
那么我们可以在

01:24:56.700 --> 01:24:57.700
迪斯多尔德的时候

01:25:00.780 --> 01:25:01.780
这些可能星期两大不大

01:25:02.780 --> 01:25:04.780
你还觉得

01:25:04.780 --> 01:25:05.780
登录简单吧

01:25:05.780 --> 01:25:06.780
是不是取消监控

01:25:09.780 --> 01:25:10.780
好 这就是这种做法

01:25:10.780 --> 01:25:11.780
其实呢 这个除了用

01:25:11.780 --> 01:25:13.780
Wheel组建里面的一个Warch

01:25:14.780 --> 01:25:15.780
还可以用

01:25:15.780 --> 01:25:16.780
仓库里面的一个Warch

01:25:16.780 --> 01:25:17.780
仓库里面给你提供的一个Warch

01:25:17.780 --> 01:25:18.780
都可以

01:25:19.780 --> 01:25:20.780
WheelX里面

01:25:20.780 --> 01:25:21.780
它也给你提供了一个Warch

01:25:21.780 --> 01:25:23.780
它也是在监听变化的

01:25:24.780 --> 01:25:25.780
用法是一模一样的

01:25:25.780 --> 01:25:26.780
它都会告诉你

01:25:26.780 --> 01:25:27.780
这个

01:25:27.780 --> 01:25:28.780
跟那个

01:25:28.780 --> 01:25:29.780
Wheel这个用法的

01:25:29.780 --> 01:25:30.780
参数都是一样的

01:25:31.780 --> 01:25:32.780
那么你用它也可以

01:25:32.780 --> 01:25:33.780
用什么

01:25:33.780 --> 01:25:35.780
用WheelX里面的东西也可以

01:25:35.780 --> 01:25:36.780
都可以

01:25:37.780 --> 01:25:38.780
它可以用什么

01:25:38.780 --> 01:25:40.780
ZS Store里面的这个Warch

01:25:41.780 --> 01:25:42.780
这个Warch的方法

01:25:42.780 --> 01:25:43.780
也可以

01:25:43.780 --> 01:25:44.780
一样的

01:25:45.780 --> 01:25:46.780
我说你看一下吧

01:25:46.780 --> 01:25:47.780
刷新

01:25:47.780 --> 01:25:48.780
一开始是loading

01:25:48.780 --> 01:25:49.780
对吧 因为我设置到

01:25:49.780 --> 01:25:50.780
一个immediate

01:25:50.780 --> 01:25:51.780
表示一开始要只寻一次

01:25:51.780 --> 01:25:52.780
这个回调

01:25:53.780 --> 01:25:55.780
好 以后变化不会变成unlocking

01:25:55.780 --> 01:25:56.780
那么我们这里

01:25:56.780 --> 01:25:57.780
要做的事情就是

01:25:58.780 --> 01:25:59.780
要做啥事情呢

01:25:59.780 --> 01:26:00.780
状态变化过后

01:26:00.780 --> 01:26:01.780
只要你的状态

01:26:01.780 --> 01:26:02.780
它不再是loading的

01:26:02.780 --> 01:26:03.780
因为我们这个页面就是

01:26:03.780 --> 01:26:05.780
它正在加在中的时候

01:26:05.780 --> 01:26:06.780
才显示

01:26:06.780 --> 01:26:07.780
加在完了过后

01:26:07.780 --> 01:26:08.780
我就不显示了

01:26:08.780 --> 01:26:09.780
只要你的状态

01:26:09.780 --> 01:26:10.780
不再是loading的

01:26:10.780 --> 01:26:11.780
我怎么样呢

01:26:11.780 --> 01:26:16.570
只要等待完毕

01:26:16.570 --> 01:26:17.570
不管你是成坏的失败

01:26:17.570 --> 01:26:18.570
我就再一次

01:26:18.570 --> 01:26:19.570
尝试进入目标页

01:26:20.570 --> 01:26:21.570
是不是我这要重新

01:26:21.570 --> 01:26:22.570
跳转路由

01:26:23.570 --> 01:26:24.570
rotor

01:26:24.570 --> 01:26:25.570
重新跳转路由

01:26:25.570 --> 01:26:26.570
跳转到哪 目标页

01:26:26.570 --> 01:26:27.570
就是你之前

01:26:27.570 --> 01:26:28.570
访问的是啥页面

01:26:28.570 --> 01:26:29.570
现在就访问啥页面

01:26:29.570 --> 01:26:30.570
那问题来了

01:26:30.570 --> 01:26:31.570
我之前访问的是啥页面

01:26:31.570 --> 01:26:34.010
你怎么知道

01:26:34.010 --> 01:26:35.010
我怎么知道

01:26:35.010 --> 01:26:36.010
之前访问的是啥页面

01:26:36.010 --> 01:26:37.010
我怎么知道是哪

01:26:37.010 --> 01:26:38.010
从哪个页面

01:26:38.010 --> 01:26:39.010
扔过来的

01:26:39.010 --> 01:26:40.010
我怎么知道

01:26:41.010 --> 01:26:42.010
那么这个逻辑是这样子

01:26:43.010 --> 01:26:45.010
刚才我们在路由导航

01:26:45.010 --> 01:26:46.010
就导航守卫这里

01:26:46.010 --> 01:26:47.010
不是发生了

01:26:47.010 --> 01:26:48.010
它在加在中吗

01:26:48.010 --> 01:26:49.010
我要跳转到建权业

01:26:49.010 --> 01:26:50.010
你看啊

01:26:50.010 --> 01:26:51.010
我之前在这

01:26:54.660 --> 01:26:55.660
我之前在这

01:26:55.660 --> 01:26:57.660
我要跳转到建权业

01:26:57.660 --> 01:26:58.660
是不是从这里跳过来的

01:26:58.660 --> 01:26:59.660
跳过来的时候

01:26:59.660 --> 01:27:02.660
我就顺便告诉这个建权业

01:27:02.660 --> 01:27:03.660
我是打

01:27:03.660 --> 01:27:05.660
本来打算是进哪个页面

01:27:05.660 --> 01:27:06.660
本来打算进他的

01:27:06.660 --> 01:27:07.660
但是我现在进不了

01:27:07.660 --> 01:27:09.660
我要跳转到你这

01:27:09.660 --> 01:27:10.660
让你等

01:27:10.660 --> 01:27:11.660
等待一会

01:27:11.660 --> 01:27:12.660
对吧

01:27:12.660 --> 01:27:13.660
我就传入目标页的路径

01:27:13.660 --> 01:27:14.660
我在这里就传入

01:27:14.660 --> 01:27:15.660
告诉他

01:27:15.660 --> 01:27:16.660
我怎么传入呢

01:27:16.660 --> 01:27:17.660
我可以通过query再传入

01:27:17.660 --> 01:27:19.660
你看我可以传个对象

01:27:19.660 --> 01:27:20.660
pass 它跳转的路径

01:27:20.660 --> 01:27:21.660
目前跳转到这

01:27:21.660 --> 01:27:23.660
我们之前用命名路由的时候

01:27:23.660 --> 01:27:24.660
是不是可以用这个name

01:27:24.660 --> 01:27:25.660
命名路由

01:27:25.660 --> 01:27:26.660
不过这里不是命名路由

01:27:26.660 --> 01:27:27.660
就直接用pass

01:27:31.320 --> 01:27:32.320
好

01:27:33.320 --> 01:27:34.320
我跳转到这

01:27:34.320 --> 01:27:35.320
同时我给你一个query

01:27:35.320 --> 01:27:36.320
query里面你自行规定

01:27:36.320 --> 01:27:38.320
比方说我一个return URL

01:27:38.320 --> 01:27:39.320
我告诉他

01:27:39.320 --> 01:27:40.320
我之前我本来打算的

01:27:40.320 --> 01:27:41.320
进到哪个页面呢

01:27:41.320 --> 01:27:44.320
我进的是tue导航的pass

01:27:45.320 --> 01:27:46.320
我给他一个附合pass吧

01:27:46.320 --> 01:27:47.320
都可以

01:27:47.320 --> 01:27:49.320
我本来打算进这的

01:27:50.320 --> 01:27:51.320
然后我现在进不了

01:27:51.320 --> 01:27:52.320
我到你这

01:27:52.320 --> 01:27:54.320
然后我给你给了一个return URL

01:27:57.530 --> 01:27:58.530
我们来看一下

01:27:58.530 --> 01:27:59.530
现在我们来看一下

01:27:59.530 --> 01:28:01.530
我们现在进入这个leus

01:28:03.530 --> 01:28:04.530
leus

01:28:05.530 --> 01:28:06.530
你看到了楼顶过后

01:28:06.530 --> 01:28:08.530
你看这里是不是一个return URL

01:28:09.530 --> 01:28:10.530
他编码过后的

01:28:10.530 --> 01:28:11.530
所以他告诉他了

01:28:11.530 --> 01:28:12.530
这个玩意就是

01:28:12.530 --> 01:28:13.530
相当于是个鞋杠

01:28:13.530 --> 01:28:14.530
相当于是个鞋杠

01:28:15.530 --> 01:28:16.530
编码过后变成这样子

01:28:17.530 --> 01:28:19.530
然后告诉他一个

01:28:19.530 --> 01:28:21.530
通过一个地转参数告诉他

01:28:21.530 --> 01:28:23.530
你到了时候等待完了过后

01:28:23.530 --> 01:28:24.530
你再重新尝试

01:28:24.530 --> 01:28:25.530
进入这个页面

01:28:26.530 --> 01:28:27.530
你要的意思吧

01:28:27.530 --> 01:28:28.530
那我这里该铺写啥呀

01:28:29.530 --> 01:28:30.530
铺写

01:28:31.530 --> 01:28:34.530
读取当前路由的return URL

01:28:37.530 --> 01:28:39.530
当然如果说读不到的话

01:28:39.530 --> 01:28:40.530
读不到的话

01:28:40.530 --> 01:28:41.530
那么我这里写两个问号

01:28:41.530 --> 01:28:42.530
两个问号

01:28:42.530 --> 01:28:43.530
我之前在es6的

01:28:44.530 --> 01:28:45.530
直播课的时候解释过

01:28:45.530 --> 01:28:46.530
如果说

01:28:46.530 --> 01:28:48.530
就说前面都这个东西没有值

01:28:48.530 --> 01:28:49.530
当然你这个玩意也行

01:28:49.530 --> 01:28:50.530
没有值

01:28:51.530 --> 01:28:52.530
没有值的话

01:28:52.530 --> 01:28:53.530
我就跳转到

01:28:55.530 --> 01:28:57.530
就是我要跳转的路径是这样

01:29:01.220 --> 01:29:02.220
在6时

01:29:02.220 --> 01:29:03.220
来 走一只

01:29:04.220 --> 01:29:05.220
等到中

01:29:06.220 --> 01:29:08.220
然后现在呢就是

01:29:08.220 --> 01:29:09.220
他告诉你

01:29:11.220 --> 01:29:12.220
没有登录

01:29:12.220 --> 01:29:13.220
又跳到6时

01:29:13.220 --> 01:29:14.220
跳6时过后

01:29:14.220 --> 01:29:16.220
是不是有重新走下这个流程

01:29:16.220 --> 01:29:17.220
你看啊

01:29:17.220 --> 01:29:18.220
我们刚才的

01:29:19.220 --> 01:29:21.220
坚权完毕了

01:29:21.220 --> 01:29:23.220
又重新又尝试去进入这个6时

01:29:23.220 --> 01:29:25.220
这一次就不是夹载东了

01:29:25.220 --> 01:29:26.220
这一次他没有登录

01:29:26.220 --> 01:29:27.220
没有登录就

01:29:27.220 --> 01:29:28.220
跳到登录也

01:29:28.220 --> 01:29:29.220
他刚才给了一个提示

01:29:29.220 --> 01:29:30.220
跳到登录也

01:29:31.220 --> 01:29:32.220
你看

01:29:32.220 --> 01:29:33.220
就跳到登录也

01:29:33.220 --> 01:29:34.220
好 我看一下这里

01:29:34.220 --> 01:29:35.220
什么问题

01:29:35.220 --> 01:29:36.220
所以第二个

01:29:36.220 --> 01:29:37.220
这文革运放

01:29:38.220 --> 01:29:39.220
6时

01:29:40.220 --> 01:29:41.220
通过一个什么

01:29:43.220 --> 01:29:46.220
重定向当从那个楼顶

01:29:46.220 --> 01:29:48.220
跳到6时的时候

01:29:50.790 --> 01:29:52.790
通过了一个导航守卫

01:29:53.790 --> 01:29:54.790
没问题啊

01:29:55.790 --> 01:29:56.790
没问题啊

01:29:57.790 --> 01:30:00.790
看看他到底这个错误是什么错误

01:30:00.790 --> 01:30:03.550
再来一次啊

01:30:03.550 --> 01:30:04.550
6时

01:30:05.550 --> 01:30:09.950
这里怎么会有一个错误

01:30:10.950 --> 01:30:13.580
这个错误呢

01:30:13.580 --> 01:30:14.580
我刚才去那个

01:30:14.580 --> 01:30:17.580
stack workflow 上面去查了一下

01:30:17.580 --> 01:30:18.580
他这样

01:30:19.580 --> 01:30:20.580
他是那个

01:30:20.580 --> 01:30:21.580
vue rotor

01:30:22.580 --> 01:30:24.580
给你做了一个提示

01:30:24.580 --> 01:30:26.580
他可能觉得你一个代码

01:30:26.580 --> 01:30:28.580
可能并不是你想要的

01:30:28.580 --> 01:30:30.580
他给你做了一个有好的提示

01:30:30.580 --> 01:30:31.580
但是结果呢

01:30:31.580 --> 01:30:32.580
他也没想到

01:30:32.580 --> 01:30:33.580
我们确实要这样去做

01:30:34.580 --> 01:30:35.580
他这样子啊

01:30:35.580 --> 01:30:36.580
当你去访问

01:30:36.580 --> 01:30:37.580
当你从

01:30:38.580 --> 01:30:40.580
当你去访问一个页面

01:30:40.580 --> 01:30:41.580
a的时候

01:30:41.580 --> 01:30:43.580
他被定向到到了页面b

01:30:43.580 --> 01:30:45.580
就像我们刚才放访问的那个6时

01:30:45.580 --> 01:30:46.580
他定向到了谁啊

01:30:46.580 --> 01:30:47.580
定向到了这个楼顶页面

01:30:47.580 --> 01:30:48.580
对吧

01:30:48.580 --> 01:30:49.580
我们本来是访问6时的

01:30:50.580 --> 01:30:53.020
他定向到了谁

01:30:53.020 --> 01:30:54.020
定向到了楼顶

01:30:54.020 --> 01:30:55.020
这是一次重定向了

01:30:56.020 --> 01:30:58.020
然后在楼顶页面呢

01:30:58.020 --> 01:31:00.020
他又去尝试的去定向到

01:31:01.020 --> 01:31:03.400
6时

01:31:04.400 --> 01:31:05.400
其实就是这一步

01:31:05.400 --> 01:31:06.400
这一步出了问题

01:31:07.400 --> 01:31:08.400
我们其实我们在这里

01:31:08.400 --> 01:31:09.400
回车刷新一下

01:31:09.400 --> 01:31:10.400
他本来也开始在这里地址

01:31:10.400 --> 01:31:11.400
对吧

01:31:11.400 --> 01:31:12.400
然后呢跳到了是吧

01:31:12.400 --> 01:31:14.400
像他尝试的去跳到6时

01:31:14.400 --> 01:31:16.400
结果6时呢又跳到login

01:31:16.400 --> 01:31:18.400
我们再来一次啊

01:31:18.400 --> 01:31:19.400
从6时

01:31:19.400 --> 01:31:20.400
这里直接进去

01:31:20.400 --> 01:31:21.400
跳到login

01:31:21.400 --> 01:31:22.400
他是在这里发生了问题

01:31:23.400 --> 01:31:24.400
从楼顶页面呢

01:31:24.400 --> 01:31:25.400
尝试去跳到6时

01:31:25.400 --> 01:31:27.400
结果呢由于导航

01:31:27.400 --> 01:31:28.400
所谓的影响

01:31:28.400 --> 01:31:30.400
又被重新定向到了login

01:31:30.400 --> 01:31:32.400
就是这一连串操作

01:31:32.400 --> 01:31:34.400
还导致了两次重定向

01:31:34.400 --> 01:31:36.400
本来我们从这里定向到这

01:31:36.400 --> 01:31:37.400
就应该过去了

01:31:37.400 --> 01:31:38.400
结果从他定向到了这

01:31:39.400 --> 01:31:41.400
就是唯有router的就party

01:31:41.400 --> 01:31:43.400
两次重定向的就可能

01:31:43.400 --> 01:31:45.400
并不是你想要的

01:31:45.400 --> 01:31:47.400
他认为只需要一次重定向就够了

01:31:47.400 --> 01:31:48.400
怎么会出现两次重定向

01:31:48.400 --> 01:31:50.400
他就给你做了个错误提示

01:31:50.400 --> 01:31:52.400
其实他并不影响我们的页面跳转

01:31:52.400 --> 01:31:54.400
给的一个错误提示

01:31:54.400 --> 01:31:56.400
那么这个问题怎么解决呢

01:31:56.400 --> 01:31:58.400
解决方案呢有两种

01:31:58.400 --> 01:31:59.400
一种呢是比较复杂的方案

01:31:59.400 --> 01:32:01.400
就是你这里健全等待业

01:32:01.400 --> 01:32:03.400
等待完成过后你就不要再重新

01:32:03.400 --> 01:32:04.400
跳到目标业了

01:32:04.400 --> 01:32:05.400
你直接跳到登录业

01:32:05.400 --> 01:32:07.400
如果说你没有用户

01:32:07.400 --> 01:32:08.400
直接跳到登录业

01:32:08.400 --> 01:32:10.400
有用户的话直接跳到目标业

01:32:11.400 --> 01:32:12.400
你不要直接跳到目标业

01:32:12.400 --> 01:32:13.400
因为有可能没有登录

01:32:13.400 --> 01:32:14.400
没有登录的话

01:32:14.400 --> 01:32:15.400
他又会重新定向到登录业

01:32:15.400 --> 01:32:16.400
他就会有两次

01:32:16.400 --> 01:32:18.400
这是一种比较复杂的方案

01:32:18.400 --> 01:32:20.400
这种方案呢我不打算用

01:32:20.400 --> 01:32:21.400
另外一种呢就是不希望他报个错而已

01:32:21.400 --> 01:32:23.400
因为他功能是正常的

01:32:23.400 --> 01:32:24.400
他不希望他报这个错

01:32:24.400 --> 01:32:25.400
那怎么弄呢

01:32:25.400 --> 01:32:27.400
就在login里边他这个跳转

01:32:27.400 --> 01:32:29.400
实际上呢他是个promise

01:32:29.400 --> 01:32:30.400
跳转呢他需要一段时间

01:32:30.400 --> 01:32:31.400
他是个promise

01:32:31.400 --> 01:32:32.400
那么我们这里呢可以用z

01:32:32.400 --> 01:32:33.400
也可以用kash

01:32:33.400 --> 01:32:35.400
来补货一下错误对吧

01:32:35.400 --> 01:32:36.400
他不是说uncaught吗

01:32:36.400 --> 01:32:38.400
没有补货的promise的错误

01:32:38.400 --> 01:32:39.400
那么我就补货一下

01:32:39.400 --> 01:32:40.400
一完事

01:32:40.400 --> 01:32:42.400
当然呢你也可以用arwait

01:32:42.400 --> 01:32:43.400
用checkkash也可以

01:32:43.400 --> 01:32:45.400
好咱们我们再看一下

01:32:45.400 --> 01:32:47.400
现在我们去再去进那个地址

01:32:47.400 --> 01:32:49.900
放心

01:32:49.900 --> 01:32:50.900
现在没有错误了

01:32:50.900 --> 01:32:51.900
对吧把这个问题稍微解决一下

01:32:51.900 --> 01:32:53.900
那么我们这个过程就完成了

01:32:53.900 --> 01:32:54.900
对吧

01:32:54.900 --> 01:32:55.900
其他在中的情况下呢

01:32:55.900 --> 01:32:57.900
我把跳转到等待业

01:32:57.900 --> 01:32:58.900
给他传入一个目标地址

01:32:58.900 --> 01:33:00.900
就像刚才我们的路径一样

01:33:00.900 --> 01:33:01.900
给他传入这么个目标地址

01:33:01.900 --> 01:33:02.900
本来我是想进这的

01:33:02.900 --> 01:33:04.900
结果呢我先到这里的

01:33:04.900 --> 01:33:05.900
然后你等待完成过后呢

01:33:05.900 --> 01:33:07.900
你把个目标地址读出来

01:33:07.900 --> 01:33:08.900
再重新进入目标

01:33:08.900 --> 01:33:11.900
然后重新进行进行一次健全

01:33:11.900 --> 01:33:12.900
就这么个意思

01:33:12.900 --> 01:33:13.900
如果说没有登陆就进去了

01:33:13.900 --> 01:33:15.900
登陆过后进入目标业了

01:33:15.900 --> 01:33:16.900
好接下来我们来看

01:33:16.900 --> 01:33:17.900
最后一个问题就是

01:33:17.900 --> 01:33:19.900
进了登陆业过后

01:33:19.900 --> 01:33:20.900
登陆成功过后

01:33:20.900 --> 01:33:22.900
目前呢是直接跳到那首业

01:33:22.900 --> 01:33:23.900
但是呢

01:33:23.900 --> 01:33:25.900
我们最好的做法就是

01:33:25.900 --> 01:33:26.900
登陆成功过后

01:33:26.900 --> 01:33:28.900
你之前本来像进新闻列表业

01:33:28.900 --> 01:33:30.900
登陆成功过后就直接进新闻列表

01:33:30.900 --> 01:33:32.900
所以说在进入登陆业的时候啊

01:33:32.900 --> 01:33:33.900
也要给他传入目标业的独进

01:33:33.900 --> 01:33:35.900
登陆成功过后直接跳转到目标业

01:33:35.900 --> 01:33:36.900
那怎么弄的

01:33:36.900 --> 01:33:37.900
我们在登陆

01:33:37.900 --> 01:33:39.900
在路由导航所谓这里

01:33:39.900 --> 01:33:41.900
登陆的时候其实也可以这样做

01:33:41.900 --> 01:33:42.900
给他传一个pass

01:33:42.900 --> 01:33:43.900
叫一样的

01:33:43.900 --> 01:33:44.900
然后来query

01:33:44.900 --> 01:33:45.900
给他传一个return

01:33:45.900 --> 01:33:48.900
UIL to the full pass

01:33:48.900 --> 01:33:50.900
我们本来打算进这的

01:33:50.900 --> 01:33:52.900
结果他进到了登陆业

01:33:52.900 --> 01:33:54.900
好然后在登陆业里边

01:33:54.900 --> 01:33:55.900
登陆业里边

01:33:55.900 --> 01:33:57.900
我们最后登陆成功过后要跳转

01:33:57.900 --> 01:33:58.900
对吧

01:33:58.900 --> 01:33:59.900
跳转的时候呢

01:33:59.900 --> 01:34:00.900
就不一定是首页了

01:34:00.900 --> 01:34:02.900
我们跳转的pass

01:34:02.900 --> 01:34:03.900
应该是什么呢

01:34:03.900 --> 01:34:05.900
应该是zsrows

01:34:05.900 --> 01:34:08.900
当前的query里边的returnUIL

01:34:08.900 --> 01:34:09.900
看一没有指

01:34:09.900 --> 01:34:10.900
没有指的话就是首页

01:34:10.900 --> 01:34:12.900
有指的话就用他的指

01:34:12.900 --> 01:34:14.900
我们跳转到这个地址

01:34:14.900 --> 01:34:15.900
整个过程就写完了

01:34:15.900 --> 01:34:17.900
就把这个逻辑补充全了

01:34:17.900 --> 01:34:18.900
这边的逻辑

01:34:18.900 --> 01:34:20.900
好咱们再来看啊

01:34:20.900 --> 01:34:22.900
现在我们进入首页的一些动作问题

01:34:22.900 --> 01:34:24.900
现在我们只想进入登陆

01:34:24.900 --> 01:34:25.900
60

01:34:25.900 --> 01:34:27.900
不行你看跳转到登陆业

01:34:27.900 --> 01:34:28.900
跳转登陆业的时候

01:34:28.900 --> 01:34:29.900
只会加到returnUIL

01:34:29.900 --> 01:34:31.900
然后我们登陆成功过后

01:34:31.900 --> 01:34:32.900
123

01:34:32.900 --> 01:34:33.900
登陆成功过后

01:34:33.900 --> 01:34:35.900
你看说跳转到新文点表页

01:34:35.900 --> 01:34:36.900
对吧

01:34:36.900 --> 01:34:38.900
如果说我们这里直接刷新新文点表页

01:34:38.900 --> 01:34:41.900
他要重新加在登陆状态

01:34:41.900 --> 01:34:42.900
你看说一个登陆中

01:34:42.900 --> 01:34:44.900
要恢复登陆状态恢复成功过后

01:34:44.900 --> 01:34:46.900
也又重新进入目标业

01:34:46.900 --> 01:34:47.900
没问题吧

01:34:47.900 --> 01:34:48.900
然后进入用户中

01:34:48.900 --> 01:34:50.900
个人中心也是一样

01:34:50.900 --> 01:34:51.900
如果说你没有登陆

01:34:51.900 --> 01:34:52.900
没有登陆的话

01:34:52.900 --> 01:34:54.900
想要进入用户中心

01:34:54.900 --> 01:34:56.900
他会先进入那个正在加载中

01:34:56.900 --> 01:34:57.900
然后呢

01:34:57.900 --> 01:34:58.900
又重新挑转

01:34:58.900 --> 01:35:00.900
重新尝试挑转到

01:35:00.900 --> 01:35:01.900
加载完成过后

01:35:01.900 --> 01:35:03.900
重新尝试挑转到UIL

01:35:03.900 --> 01:35:04.900
个人中心的页面

01:35:04.900 --> 01:35:05.900
发现你没有登陆

01:35:05.900 --> 01:35:06.900
没有登陆的话

01:35:06.900 --> 01:35:07.900
挑转到登陆业

01:35:07.900 --> 01:35:08.900
同时把这个地址带过去了

01:35:08.900 --> 01:35:09.900
然后登陆成功过后

01:35:09.900 --> 01:35:11.900
他就自动进入这个地址了

01:35:13.900 --> 01:35:14.900
看呗

01:35:14.900 --> 01:35:16.900
好最后一个非常非常小的问题

01:35:16.900 --> 01:35:17.900
什么问题呢

01:35:17.900 --> 01:35:18.900
这个问题

01:35:18.900 --> 01:35:20.900
我们尝试进入UIL

01:35:20.900 --> 01:35:22.900
你可以发现路由导航这里

01:35:22.900 --> 01:35:23.900
没有一个激活效果了

01:35:23.900 --> 01:35:24.900
这怎么回事呢

01:35:24.900 --> 01:35:26.900
因为我目前设置的样式

01:35:26.900 --> 01:35:28.900
是它的就是精确匹配的样式

01:35:28.900 --> 01:35:30.900
就是这个东西

01:35:30.900 --> 01:35:34.900
我们目前设置的样式在

01:35:34.900 --> 01:35:36.900
在这

01:35:36.900 --> 01:35:37.900
link

01:35:37.900 --> 01:35:38.900
exact active

01:35:38.900 --> 01:35:39.900
对吧

01:35:39.900 --> 01:35:40.900
还要完全匹配上台

01:35:40.900 --> 01:35:41.900
由于我这个路径里面

01:35:41.900 --> 01:35:42.900
多了这个东西

01:35:42.900 --> 01:35:43.900
他就匹配不上了

01:35:43.900 --> 01:35:44.900
那怎么办呢

01:35:44.900 --> 01:35:46.900
其实这个查约纹档

01:35:46.900 --> 01:35:47.900
这个问题肯定有解决的

01:35:47.900 --> 01:35:48.900
查约纹档他也

01:35:48.900 --> 01:35:49.900
告诉你的怎么解决

01:35:49.900 --> 01:35:51.900
就是通过这个解决

01:35:51.900 --> 01:35:52.900
exact pass

01:35:52.900 --> 01:35:53.900
他告诉你什么

01:35:53.900 --> 01:35:55.900
他告诉你允许你

01:35:56.900 --> 01:35:58.900
纸匹配pass这一部分

01:35:58.900 --> 01:35:59.900
在UIL中

01:35:59.900 --> 01:36:00.900
纸匹配pass这一部分

01:36:03.900 --> 01:36:05.900
就忽略掉query和哈希

01:36:05.900 --> 01:36:06.900
所以说呢

01:36:06.900 --> 01:36:07.900
我们把这个东西夹上

01:36:07.900 --> 01:36:08.900
导航这里

01:36:08.900 --> 01:36:09.900
夹上就完事了

01:36:10.900 --> 01:36:11.900
在这

01:36:12.900 --> 01:36:13.900
login

01:36:13.900 --> 01:36:14.900
看一下啊

01:36:14.900 --> 01:36:16.900
在这个u的name这里

01:36:16.900 --> 01:36:18.900
再加上一个exact

01:36:19.900 --> 01:36:20.900
pass

01:36:21.900 --> 01:36:22.900
纸匹配路径这一部分

01:36:22.900 --> 01:36:23.900
可以了

01:36:23.900 --> 01:36:24.900
我们再看

01:36:24.900 --> 01:36:25.900
现在就没问题了

01:36:25.900 --> 01:36:26.900
对吧

01:36:27.900 --> 01:36:28.900
OK啊

01:36:28.900 --> 01:36:29.900
那么目前呢

01:36:29.900 --> 01:36:30.900
就是这个

01:36:31.900 --> 01:36:33.900
整套登录和健全

01:36:33.900 --> 01:36:34.900
就做完了

01:36:35.900 --> 01:36:36.900
只实现登录

01:36:36.900 --> 01:36:37.900
这一部分呢

01:36:37.900 --> 01:36:38.900
实际上

01:36:38.900 --> 01:36:39.900
仓库

01:36:39.900 --> 01:36:40.900
就够了

01:36:41.900 --> 01:36:42.900
仓库里面

01:36:42.900 --> 01:36:43.900
提供数据

01:36:43.900 --> 01:36:44.900
提供各种仓库数据

01:36:44.900 --> 01:36:45.900
变化的

01:36:45.900 --> 01:36:46.900
猴头型和x型

01:36:47.900 --> 01:36:48.900
然后呢

01:36:48.900 --> 01:36:49.900
这个仓库的共享数据呢

01:36:49.900 --> 01:36:50.900
组建i用就用

01:36:51.900 --> 01:36:52.900
这是这一部分

01:36:52.900 --> 01:36:53.900
关键这个比较麻烦的地方

01:36:53.900 --> 01:36:54.900
在于健全

01:36:54.900 --> 01:36:56.900
健全我们需要用到的导航守卫

01:36:57.900 --> 01:36:58.900
导航守卫里的

01:36:58.900 --> 01:36:59.900
在进入这个页面的时候

01:36:59.900 --> 01:37:01.900
要有一套健全流程

01:37:01.900 --> 01:37:02.900
那么这个流程呢

01:37:02.900 --> 01:37:03.900
我有通过一个图

01:37:03.900 --> 01:37:04.900
给大家画出来了

01:37:04.900 --> 01:37:05.900
这一套写好过后

01:37:05.900 --> 01:37:06.900
后面就简单了

01:37:06.900 --> 01:37:07.900
将来我们比较

01:37:07.900 --> 01:37:08.900
某一个路由

01:37:08.900 --> 01:37:09.900
比方说守业

01:37:10.900 --> 01:37:11.900
我们在

01:37:11.900 --> 01:37:12.900
守业他也需要健全

01:37:12.900 --> 01:37:13.900
OK

01:37:13.900 --> 01:37:14.900
再加上一个meta

01:37:15.900 --> 01:37:16.900
这一套

01:37:16.900 --> 01:37:17.900
再加上一个meta

01:37:19.900 --> 01:37:20.900
20

01:37:20.900 --> 01:37:21.900
就OK

01:37:22.900 --> 01:37:24.900
守业现在守业也需要健全了

01:37:24.900 --> 01:37:25.900
那么现在我们看

01:37:27.900 --> 01:37:28.900
现在没有登录

01:37:28.900 --> 01:37:29.900
我们去守业

01:37:29.900 --> 01:37:30.900
去不了了

01:37:30.900 --> 01:37:31.900
就非常简单的后边

01:37:32.900 --> 01:37:33.900
明儿的意思吧

01:37:33.900 --> 01:37:36.340
我们直接去守业

01:37:37.340 --> 01:37:38.340
他会跳脑登录

01:37:40.340 --> 01:37:41.340
这就是咱们的

01:37:43.340 --> 01:37:44.340
这么一个小的demo

01:37:45.340 --> 01:37:46.340
每个同学都要学会

01:37:46.340 --> 01:37:47.340
这套东西做完了

01:37:47.340 --> 01:37:48.340
过后你才会

01:37:48.340 --> 01:37:50.340
才是真正算完整的

01:37:50.340 --> 01:37:51.340
完成了登录和健全流程

01:37:52.340 --> 01:37:54.340
这一刻的内容比较多

01:37:54.340 --> 01:37:55.340
时间也比较长

01:37:55.340 --> 01:37:56.340
大家可以下来

01:37:56.340 --> 01:37:57.340
多花点时间去消化

01:37:58.340 --> 01:37:59.340
可以花个一天两天

01:37:59.340 --> 01:38:00.340
三天都没个事

01:38:00.340 --> 01:38:01.340
一定要把它消化了

01:38:01.340 --> 01:38:02.340
之后呢

01:38:02.340 --> 01:38:03.340
再往接着往后看

01:38:03.340 --> 01:38:04.340
尽管了我们这个项目里面

01:38:04.340 --> 01:38:05.340
没有用到这个东西

01:38:05.340 --> 01:38:06.340
还是拿出来给大家讲

01:38:07.340 --> 01:38:08.340
好

01:38:08.340 --> 01:38:09.340
这就可以到这了

