WEBVTT

00:00.430 --> 00:05.030
从折截课开始 咱们来聊一聊在无忧的开发中

00:05.290 --> 00:08.110
如果说遇到数据共享 该怎么办

00:08.630 --> 00:11.430
这应该是在无忧的学习中

00:11.950 --> 00:15.530
咱们入门阶段 最后一个大的知识框

00:15.790 --> 00:17.570
好 咱们来看一下一个问题

00:17.830 --> 00:19.630
所以我们这里面有一个工程

00:20.150 --> 00:21.430
这两节课

00:21.930 --> 00:23.990
我们先把之前的项目先放一放

00:24.490 --> 00:28.330
因为用那个项目不是很好来解释这个事情

00:28.530 --> 00:31.610
咱们单独去开一些例子来给大家讲解

00:32.370 --> 00:35.190
我们这里有个工程 非常干净的无忧工程

00:35.450 --> 00:38.530
来看一下吧 有一个CSS 这个CSS是没什么好看的

00:38.790 --> 00:43.890
然后MediaJS里边倒一个CSS 倒入5U 倒入一个根组件 然后选择它

00:44.150 --> 00:44.650
OK吧

00:44.910 --> 00:49.010
然后根组件里边也没有做啥 倒入了两个组件 A和B

00:49.530 --> 00:52.610
这两个组件干嘛呀 这两个组件目前啥个功能都没有

00:52.870 --> 00:53.810
央视也没有

00:54.070 --> 00:55.410
那么就是一个

00:55.670 --> 00:56.690
显示出一个界面

00:56.910 --> 00:58.430
这里面也要显示一个界面

00:58.950 --> 01:02.270
就这么一个东西 然后我们来看一下我们最终的界面呈现效果

01:03.030 --> 01:04.310
这是两个组件

01:04.830 --> 01:06.270
他们是互为兄弟节点

01:06.630 --> 01:07.390
兄弟关系

01:07.910 --> 01:10.470
他们里边都有一个数字要显示出来

01:10.990 --> 01:12.510
但是我现在要求是

01:13.270 --> 01:15.590
这两个数字是共享的

01:16.350 --> 01:18.910
也就是这边这个组件的数字变化过后

01:19.170 --> 01:21.230
这个组件里边有两个按钮 一个是减少

01:21.990 --> 01:23.790
一个是增加 增加是一步增加

01:23.850 --> 01:27.090
就说要等一会 比方说模拟网络通信 要等一会才增加

01:27.570 --> 01:29.570
那么这边有一个异步减少和一个

01:30.130 --> 01:30.850
同步增加

01:31.410 --> 01:34.250
但不管怎么样吧 每一个组件 你看这个组件里边

01:34.490 --> 01:36.170
它是有可能会改变这个数据的

01:36.410 --> 01:40.890
我希望这个组件导致个数据变化后 不仅自己要重新宣传

01:41.530 --> 01:44.410
还会影响到他的兄弟节点 重新宣传

01:45.090 --> 01:47.130
对吧 这又涉及到组件之间通信了

01:47.370 --> 01:51.050
那咱们把这个组件之间的通信再拿出来看一下

01:51.470 --> 01:54.030
我们之前 哎 哪个地方 上一次

01:54.590 --> 01:55.870
上一次组件通信

01:58.670 --> 02:00.790
是在事件总线这一块儿

02:01.230 --> 02:03.790
我们当时呢 有一个是X-Mand

02:04.630 --> 02:05.470
再来看一下

02:08.900 --> 02:13.780
咱们之前的组件之间通信呢 你会去找一找 你会发现咋都不合适

02:14.540 --> 02:15.500
我们来找一找吧

02:16.260 --> 02:17.340
组件组件通信 你看

02:17.620 --> 02:18.620
属性

02:18.980 --> 02:23.620
事件能在兄弟节点之间发生吗 也不行啊

02:24.020 --> 02:26.620
你看我们这个A和B他们是护围兄弟员书的

02:28.660 --> 02:31.940
他发生的一件事必要知道 必发生一件事A要知道

02:32.540 --> 02:35.420
那我们往下找Reverse也不合适 Router呢

02:35.820 --> 02:40.380
你不能 Router倒是能做啊 但是不合适 为啥呢 有Router要怎么做呢

02:40.580 --> 02:42.860
我这里增加过后来要改变地址栏

02:43.660 --> 02:47.020
那么这边去监控地址栏的变化 对吧 来间接处理一下

02:47.220 --> 02:50.860
可不可以通了 当然可以做 但是有的时候我们也不希望地址栏变化

02:51.280 --> 02:54.880
像这种情况 我们不希望地址栏变化 Router呢也不是很合适啊

02:55.200 --> 02:59.160
尽管Router可以间接的来做那个组件通信

02:59.920 --> 03:03.880
但是呢 这个玩意儿呢 他毕竟是会影响到地址栏变化啊

03:05.240 --> 03:06.680
你什么都靠他 那也不合适

03:07.440 --> 03:10.360
然后这个玩意儿呢 这个玩意儿也是复制之间的 对吧

03:10.600 --> 03:13.880
在植入间里边可以得到复制建船外的所有事件

03:14.240 --> 03:16.480
维莫的呢 也是复制组件之间的

03:16.920 --> 03:20.840
事件总线可不可以呢 事件总线的感觉上好像也可以啊

03:21.240 --> 03:23.120
也可以 但是呢 也不是很合适

03:23.360 --> 03:27.080
因为事件总线呢 主要的作用呢 是来传递消息的

03:28.240 --> 03:29.440
就是我发生了一件事

03:30.480 --> 03:31.200
我要通知你

03:31.960 --> 03:33.480
你发生了一件事 你要通知我

03:33.960 --> 03:35.160
是来传递消息的

03:35.640 --> 03:39.720
像这种数据共享啊 就是我有一个数据 我要分发到不同的组件里边

03:39.720 --> 03:41.280
他们都用同一个数据

03:41.800 --> 03:45.800
用事件总线其实也可以通过一些技巧来做啊 他总归是不合适的

03:46.800 --> 03:50.480
就这么一个例子 那么我们这就可能要解决这个问题啊

03:51.080 --> 03:53.480
在这个问题呢 是易解课讲不完的 东西比较多

03:54.440 --> 03:57.400
他根源问题就是这个啊 我给他画了一个更加复杂的一个结构

03:57.840 --> 04:00.800
实际上在大型项目里边 这个结构呢 可能更加复杂

04:01.320 --> 04:06.920
就是我们的网站中呢 可能会有不少的这样的数据 我们这里只是一个数字而已

04:07.600 --> 04:11.680
在真实的开发中 可能是有不少的这样的数据 比方说当前登陆的用户

04:12.840 --> 04:15.600
然后我现在有没有登陆 我目前登陆的是谁

04:16.720 --> 04:20.200
还有什么网站的全局设置 什么叫全局设置呢

04:20.660 --> 04:26.660
就好必须说这个 我们那个博客啊 博客里面就有些全局设置 就博客的标题标题市场

04:27.140 --> 04:30.140
对吧 我们的头像市场可能很多组件都需要用到

04:31.060 --> 04:34.540
还包括了我们的用户偏号设置啊 在有些网站里边呢 比如说

04:35.700 --> 04:42.340
这个用户呢 他可能喜欢一个皮肤啊 我们给网站换一个皮肤 那么之后呢 他在访问的时候呢 就始终使用那个皮肤

04:42.580 --> 04:49.660
就是他的有一些偏号设置啊 像我们现在特别是手机应用上面 特别多的东西 对吧 用户了自己的设置

04:50.500 --> 04:57.780
那么一向有类似于这种啊 当然 当然 这个共享数据呢 不止这么一些 在真实的开发中 还有很多很多我们意想不到的共享数据

04:58.900 --> 05:06.700
像共享数据呢 我们可能整个网站有很多 我这里用不同的颜色来表示 而我们的网站用为有开发的话 他是一个组件数

05:07.220 --> 05:13.380
对吧 在这个组件数中呢 就说不好哪个组件要用到这个数据 比方说跟组件 他要用到这个当前的用户

05:13.860 --> 05:16.740
这个组件也要用到 这个组件也要用到 这个组件也要用到

05:17.520 --> 05:27.120
而像那个网站全局设置呢 他要用到 他要用到 他要用到 用户偏号设置呢 他要用到 他要用到 他都要用到 对吧 他这个组件数的分布是极其凝乱的

05:28.120 --> 05:31.520
有些组件的一个都不用 有些组件的要用好几个都说不好

05:32.560 --> 05:37.200
那么这里就产生了很多的问题 第一个问题就是我如何保证数据的唯一性

05:38.320 --> 05:39.600
这个唯一性是很重要的

05:40.540 --> 05:44.380
如果说你在每个组件里边 我们去设置一个什么data

05:45.260 --> 05:50.660
来设置这个数据啊 每个组件 这个组件里边一个data 那么得到的是他的当前登录的用户

05:51.620 --> 05:54.060
啊 我们这个return 然后一个locking user吧

05:55.780 --> 05:57.500
locking user啊 当前登录的用户

05:58.300 --> 06:02.220
我们这里有个数据 那他里边也有又有一个数据 他里边又有一个数据

06:02.580 --> 06:06.620
这就类似于我们这个地方了 这个组件里边有一个data 他有个数字

06:06.920 --> 06:10.320
第一个组件里边有一个data 一个数字 那么就导致这个问题数据是不是不唯一啊

06:10.960 --> 06:12.480
那么不唯一会找成什么问题了

06:13.400 --> 06:17.840
那我来看一下啊 首先就是很大量的内存资源浪费 他们本来是同一个意识

06:18.320 --> 06:22.320
含义上就是一个东西 但是呢你数据不同以每个地方维护一个

06:22.760 --> 06:24.520
数据是不是就产生了多份数据

06:25.240 --> 06:26.400
这是一个降低了

06:27.160 --> 06:30.160
浪费了大量的内存资源 降低运行效率 这是这么一个问题

06:30.640 --> 06:32.640
但这个问题呢不是最重要的 最重要的是

06:33.220 --> 06:34.900
不同意的数据就难以维护

06:35.460 --> 06:40.740
因为你一个变了 另外一个他不知道 不知道你变了 你是你各自是各自的数据

06:41.060 --> 06:43.820
所以数据的唯一性呢 我们第一个是需要保证的

06:44.460 --> 06:45.620
怎么去保证是一个问题

06:46.780 --> 06:52.300
第二个呢 就是如果说某个组件变动了这个数据之后 如何让其他要用到这个组件的

06:52.780 --> 06:54.620
数据的组件 制造数据变化了 比方说

06:55.980 --> 07:00.340
他是个登录组件 登录过后是不是之前没有登录用户 现在有了

07:00.800 --> 07:03.680
有了过后 他要变化 因为他用到了登录用户

07:04.360 --> 07:06.200
他也要变化 他也要变化

07:07.160 --> 07:09.040
对吧 那么这个东西又怎么来处理

07:09.880 --> 07:12.280
这两个问题啊 一个是我一性的问题怎么来解决

07:12.760 --> 07:17.360
一个是某一个组件 他们都有可能会导致这个数据变化 他也有可能会导致

07:17.600 --> 07:21.040
比方他是一个灯出 一个助销 一点了助销过后

07:21.800 --> 07:25.600
那么这个组件要收到通知 这个组件要收到通知 这个组件要收到通知又怎么办

07:26.580 --> 07:31.740
好 一种比较容易想到的方案怎么来解决呢 就是非常粗暴的

07:32.620 --> 07:34.620
因为我们组件之间通信的

07:35.500 --> 07:42.940
最常见的方式就是事件和属性对吧 就负责组件之间的 那我就把所有的共产数据全部扔到根组件里边去

07:43.940 --> 07:49.700
你看就这种方式 虽然说我根组件只用到了他 但是呢 我把所有的数据全部提到他里边去了

07:50.440 --> 07:52.000
然后通过属性往下发

07:52.680 --> 07:57.600
我把所有的所有的共产数据通过属性发到下个组件 这个组件又把所有的数据

07:58.480 --> 08:02.320
又把所有的共产数据发到下面的指数件 他们又继续往下发

08:03.040 --> 08:06.040
让每一个组件里边都可以通过属性来得到

08:06.880 --> 08:12.320
所有的共产数据 不过呢 有些有些组件呢 他根本用不到 比方说这个组件

08:12.800 --> 08:17.320
他根本用不到这个共产数据 但是他也要接收 为什么要接收 因为他要往下发

08:17.740 --> 08:18.860
他不接收怎么往下发的

08:19.360 --> 08:24.740
因为后面可能会用到 那么这个组件可能只用到这个数据 但是他仍然要把所有的数据往下发

08:25.260 --> 08:26.780
就变成这种这种模式了

08:27.820 --> 08:30.620
这种模式呢 虽然可以解决这个问题啊 但是

08:31.400 --> 08:32.420
那是相当恶心的

08:34.220 --> 08:39.600
为什么呢 你至少你看有两个非常明显的问题 第一个明显的问题就是我要编写大量的代码对吧

08:39.860 --> 08:41.900
我要声明吧 这个地方要声明我要拿

08:42.160 --> 08:46.500
我声明一些属性 我要拿共产数据 但是实际上我只用到这两个 但是我要声明三个

08:46.960 --> 08:51.820
你看这个组件我一个都不用 但是我还是要声明这个属性 我要拿到这个数据 为什么我要往下发

08:52.340 --> 08:56.180
所以会写他大量的代码 下发属性的代码就非常恶心

08:57.980 --> 09:02.840
然后还有什么问题呢 那如果说遇到一个要改变数据的事件 不要说他

09:03.100 --> 09:08.220
要不要他吧 他是一个登录组件 登录过后我要改变那个当前登录的用户

09:09.240 --> 09:11.540
是不是抛出事件往上跑 他能处理吗

09:12.220 --> 09:16.940
他不能处理 不能处理你还在注册事件 为什么呢 因为你要接着把这个事件往上跑

09:17.540 --> 09:24.860
所以说呢 他得注册事件 注册你登录成功之后 什么登录用户 我把这个事件有仍然往上跑 那么他也是一样

09:25.380 --> 09:30.460
他处理不了 他也要往上跑 直到抛到跟组件 跟组件过后就因为数据是跟组件的吗

09:30.940 --> 09:32.740
数据是跟组件 就在跟组件里面有data

09:33.780 --> 09:35.980
数据是他的 他可以改数据 改了过后

09:36.660 --> 09:40.740
数据变化又重新分发这个属性 然后这些组件选了

09:41.580 --> 09:43.580
这个东西想着就比较恐怖 对不对

09:44.300 --> 09:49.460
所以说 这种模式呢 基本上看看就好了 我也不敢写了这个代码 这个代码太恐怖了

09:51.340 --> 09:55.260
那么我们正确的做法应该是什么呢 应该去设置一个独立的数据仓库

09:55.620 --> 09:59.500
这个独立的数据仓库呢 实际上他跟组件数都没有什么关系了

10:00.260 --> 10:02.860
他就是一个用纯粹的介石代码写出了一个仓库

10:04.260 --> 10:09.860
然后呢 我们在这个组件书里也好 或者是其他的介石模块 跟组件没关系的介石模块

10:10.060 --> 10:15.140
都可以从仓库里面拿数据 都拿的是同一份数据 你要用哪个 你就拿哪个

10:15.460 --> 10:21.220
比方说这个组件 我需要用这个数据 这个数据 哪里从仓库里面拿 把这个数据拿过来 把这个数据拿过来 你用就行了

10:22.500 --> 10:26.420
而且呢 这个仓库的数据呢 还必须要求是享用式的 他变化过后

10:27.140 --> 10:30.380
反而是依赖他的数据的组件 都要能够自动炫的

10:30.740 --> 10:34.180
比方说这个组件 他依赖这个数据 那么其他两个数据变了 跟他没关系

10:34.420 --> 10:37.420
但这个数据变了 他必须要重新炫的 那这个组件也是一样

10:37.900 --> 10:42.860
他用到的当前登陆的用户 这个东西变了 他要变 他要变 他也要变

10:43.540 --> 10:46.740
明儿那是吧 我们希望有这么一个独立的数据仓库 就能解决这个问题了

10:48.940 --> 10:50.380
那么这个仓库要解决什么问题呢

10:51.100 --> 10:58.500
就是 组件需要什么共享数据 他可以自由的从仓库里面拿 需要什么拿什么 跟组件数 他跟这个组件在什么

10:58.940 --> 11:00.700
组件数的位置没有任何关系

11:01.660 --> 11:02.340
然后呢

11:03.220 --> 11:07.940
他拿了某些数据过后呢 他就对这个数据形成了一代关系 一旦那个数据变化了

11:08.420 --> 11:10.620
那么他会自动通知到这些组件来进行炫的

11:11.180 --> 11:16.100
那么要解决这个问题怎么解决了 我当然可以熟悉代码来解决啊 关于这个熟悉代码呢 我

11:17.100 --> 11:20.140
现在不讲了啊 现在入门阶段就不讲了啊 之后的就业阶段再帮忙说吧

11:21.020 --> 11:22.380
他放了放了放了后边的阶段去

11:23.660 --> 11:27.580
我们现在直接使用一个已经做好的现成的一个东西 叫做

11:28.340 --> 11:28.780
vx

11:29.540 --> 11:29.900
使用他

11:31.660 --> 11:36.300
这个东西呢 我们在讲之前呢 首先给大家证明一下 这个玩意儿呢 一般用于大型项目

11:37.580 --> 11:40.700
你在一些中小型项目里边用它你会觉得很恶心

11:41.660 --> 11:45.820
这也是为什么美当同学学到这个vx的时候

11:46.540 --> 11:51.180
总感觉真的搞出一个这么恶心的东西 我不就是想共享数据吗 你共享就玩事那边

11:51.580 --> 11:53.020
为什么搞出这么多玩意儿出来

11:53.740 --> 12:00.620
就是因为他是适配大型项目的 那如果说中小型项目怎么办呢 中小型项目呢 我们可以自己熟悉一个解

12:00.780 --> 12:04.380
简单的数据上过 两三句话就可以写完 我们之后再说啊

12:05.100 --> 12:07.740
但是呢 你们学习肯定是要学习的

12:08.460 --> 12:11.820
这个vx 因为有些公司啊

12:13.020 --> 12:18.060
因为现在市面上啊 很多那种前端公司的前端开发者的质量啊 非常的堪忧

12:18.300 --> 12:18.700
知道吧

12:19.180 --> 12:26.860
他什么东西都敢往里面用 像这个vx呢 实际上呢 在中小型项目里面我是不太推荐使用的

12:26.860 --> 12:33.660
但是实际上在开发的过程中呢 很多小型项目啊 他们也在用这个玩意儿啊 很多都在用

12:34.140 --> 12:37.420
所以说这个还是得学习啊 你拿不住啊 这个东西拿不住

12:39.260 --> 12:45.980
那我们就来学习吧 他其实也在南 也就是花个两三节课 也能去搞懂啊 花一点时间

12:46.060 --> 12:48.860
就说你们那边花个两三天啊 也能把它搞懂

12:49.260 --> 12:50.220
也没有太负责

12:51.580 --> 12:54.300
好 那么第一个问题 他是一个数据仓库嘛

12:54.780 --> 12:59.660
那我们肯定得安装他来创检查我 他必须要有这样的功能呗 那怎么来安装创

13:00.140 --> 13:03.740
安装他呢 首先我们到这个啊 把他停止 安装一个

13:06.060 --> 13:06.620
啊 安装

13:09.940 --> 13:15.140
那么现在呢 我们就学习了一个新的数据通信方案啊 我觉得这得把记录一下啊 就是vx

13:16.260 --> 13:20.100
你看这些我为什么要记录啊 因为面试体用易考到 组件之间通信有哪些方案

13:23.830 --> 13:26.710
好 接下来我们安装好了啊 安装好了 我们先再重新启动

13:26.870 --> 13:27.350
装设

13:28.550 --> 13:29.110
慢慢讲啊

13:30.390 --> 13:33.430
好 我们在我们的工程里边呢 去新建一个文件夹

13:34.470 --> 13:39.350
啊 为什么 当然我们代码呢 也可以直接写脑罩啊 我这里当着把分出去吧

13:39.350 --> 13:41.510
我们平时开发中呢 也往往是把分出去的

13:41.510 --> 13:48.390
Stone里边我们新建一个文件啊 叫做index的介绍 我们认为呢 这个模块就是一个数据仓库模块

13:49.110 --> 13:50.470
那么这个仓库里边怎么写呢

13:51.350 --> 13:53.910
首先我们要导入这个vx

13:55.030 --> 13:55.750
vx

13:56.950 --> 13:58.870
啊 这个vx里边呢 他有一个

13:59.830 --> 14:00.630
构造函数

14:01.190 --> 14:04.550
叫Stone啊 他提供了一个构造函数 哎 这个我第一个这个

14:05.270 --> 14:06.550
这里好像还写错了啊

14:09.190 --> 14:14.950
有一个构造函数 叫Stone 就是通过这个构造函数呢 我们就可以创建一个数据仓库

14:15.190 --> 14:15.990
6他就行了啊

14:16.630 --> 14:21.430
这个构造函数的参数里边呢 有一个对象 他是一个配置对象啊 有仓库

14:21.910 --> 14:22.550
配置对象

14:23.270 --> 14:24.950
呃 然后呢 我这里再顺便说一下

14:25.350 --> 14:31.270
vx呢 他这个东西呢 跟v6呢 他联系的比较紧密啊 他是作为一个v6的插线来应用的

14:31.510 --> 14:37.110
所以说呢 这个你在创建仓库之前 你必须要使用v6插件 怎么使用呢 我们之前

14:37.670 --> 14:41.030
用那个rotor的时候是不是用过啊 就是导入圈导入v6吧

14:43.130 --> 14:48.010
v6里边 我们有一个use方法 对吧 这个方法呢 里边把这个插件对象传入进去

14:48.970 --> 14:50.010
他要应用这个插线

14:51.130 --> 14:51.610
应用

14:52.570 --> 14:59.290
v6插件啊 这个方法好像我 我的这个地方也没有写啊 我这个地方也没有写 要吧 要

14:59.530 --> 15:00.330
要写上啊

15:02.390 --> 15:06.790
他跟v6联系的比较紧密啊 尽管呢 我们不一定在v6的组件里边用他 但是我们

15:07.430 --> 15:08.470
也必须要写着这句话

15:09.510 --> 15:14.870
好了 我们这里呢 再创建仓库 仓库里边有个配置对象 我们来配置这个仓库里边有什么东西

15:15.430 --> 15:16.950
那么其中一个配置呢 叫做stat

15:17.910 --> 15:21.510
啊 表示仓库的当前的状态 什么叫当前状态呢

15:21.750 --> 15:30.070
就说啊 你不是一个数据仓库吗 那里面的有数据啊 那这个数据一开始是什么样子啊 这个数据的初始值默认值是什么

15:30.470 --> 15:34.630
比方说这个 当然这个状态呢 你可以试其他东西啊 我这里通常情况下是一个对象

15:34.950 --> 15:38.950
因为毕竟一个仓库出现了 他里面一般有很多很多的数据 对吧

15:39.670 --> 15:44.630
好 我们这里呢 有一个数据scount 比方说我们一个数字零 它的默认值为零

15:45.670 --> 15:47.670
这个数据的默认值为零

15:48.310 --> 15:49.670
这就创建好的一个数据仓库

15:50.630 --> 15:55.910
简单的 简单吗 非常简单 对吧 那么我们这里呢 把它保存到一个变疆里边啊stone 这个变疆里边

15:56.470 --> 16:02.470
为了变于测试呢 我们把这个放到Windows里边啊 主要是为了方便测试 然后呢导出

16:03.430 --> 16:04.790
以后stone导出

16:05.750 --> 16:07.110
这就创建好了一个数据仓库

16:07.670 --> 16:13.030
当然这是一个普通的GSE模块 我们要用 要使用它的话 我们需要在Made.GSE一边导入它

16:13.750 --> 16:17.370
这个stone 是不是导入它

16:17.770 --> 16:22.250
ok 导入它过后呢 至少让它代码运行一遍吧 其他不说 先把代码运行一遍

16:23.130 --> 16:29.370
好了 导入了过后呢 现在这个数据仓库呢 我们把它放到Windows里边 方便来测试啊 接下来来看一下

16:30.330 --> 16:37.210
我们在这里呢 就可以使用这个stone 你看 数据的数据仓库呢 它是一个对象 这个对象哪来的 是不是通过它来创建的

16:37.770 --> 16:42.970
对吧 创建了一个对象 这个对象里边有很多很多的属性啊 很多很多的方法 我们其他的不看

16:43.690 --> 16:46.490
我们就看这个方 这个这个东西叫做State

16:48.170 --> 16:55.450
你看 这有三个点让你想起来啥呀 我指着这个三个点 下面就出现个提示叫做InvokePropertyGator

16:56.330 --> 17:01.850
啥意思呢 是不是它是一个想用式数据啊 它通过Object DefineProperty

17:02.570 --> 17:06.330
定义了一个数据 它里边数据是想用式的 是不是就满足我们之前的要求

17:07.050 --> 17:13.610
呃 仓库的数据要变化后 要能够自动通知 要能够实现自动通知 它数据必须是想用式的

17:14.170 --> 17:19.050
对吧 VX呢 还帮我们把数据变成想用式的 尽管跟目前跟组件还没有一毛钱关系

17:19.370 --> 17:22.970
那么也就是说我们可以通过这个Stone 点State 是不是可以拿到仓库数据啊

17:23.450 --> 17:28.010
哎 这个仓库数据里边呢 你看 是不是有我们的刚才的数据Count 它也变成个想用式数据

17:28.890 --> 17:34.250
0 那么也就我们要拿到这个Count怎么拿到StoneStateCount 拿到这个数据了

17:34.810 --> 17:36.250
对吧 就这么简单

17:37.050 --> 17:43.050
好 这就是仓库啊 创建一个数据仓库 然后呢 我们这个Vilx啊

17:43.850 --> 17:52.090
我们Vilx DevTools 这是我们的Vilx的一个开发者工具 那么这个东西呢 它本身也支持Vilx

17:52.650 --> 17:56.010
我们点击这个Vilx里边 它有一个Vilx 看到没 进去过后

17:56.410 --> 18:02.970
它这里呢 有个初始状态叫做BassState 就最开始的状态 那么点击过后呢 你可以看到 目前的仓库状态

18:03.530 --> 18:05.610
是不是就已经知道了 是Count为利用

18:06.810 --> 18:13.450
没什么意思吧 OK 那么我们仓库是不是创建好了 我们可以通过它来进行监控 我们也可以通过这个WindowsState

18:13.770 --> 18:16.250
等我这里是主要是测试啊 里面以后不要这样写啊

18:17.130 --> 18:23.850
通过一个Stone对象来操作 目前跟组建数有关系吗 都还没有关系 它还没有应用到我们的组建数里边去

18:25.370 --> 18:27.610
通常情况下呢 我们什么时候创建 创建

18:28.410 --> 18:30.890
创空呢 就是在最开始的时候我们可以创建一个仓库

18:31.770 --> 18:36.650
然后呢 整个工程里边 我们通常也只有一个数据仓库啊 大部分情况下都是这样子

18:37.770 --> 18:43.850
好 创建好的仓库 仓库创建好了之后呢 我们可以使用这个东西来访问仓库里边的数据

18:45.610 --> 18:51.130
如果说我们要在组建数里面使用了 在组建数里面使用这些共享数据呢 那怎么办呢

18:51.850 --> 18:56.090
我们除了要应用这个插件之外 我们还要把这个仓库配置到这

18:56.810 --> 19:00.330
创建没有实力的时候配置到这 这有是不是有点类似于

19:00.970 --> 19:06.330
维尤路特对吧 维尤路特是不是要配置到这 那么我们这里也一样啊 需要把它配置到这

19:07.450 --> 19:12.490
那么这样子呢 我们在整个维尤的组建数里边 都可以随意的使用仓库了

19:12.810 --> 19:18.410
怎么使用呢 其实非常简单 在组建里边使用这个仓库数据呢 你只要配置到过后

19:19.130 --> 19:24.170
它会往所有组建 就是往这个维尤圆形里边注入一个数项

19:24.730 --> 19:25.210
叫做

19:26.970 --> 19:33.130
store 所以跟那个维尤特非常相似啊 维尤特维尤才可以注册两个对吧 那么这里只可以注册的一个

19:33.370 --> 19:37.530
store 那么也就是在任何组建里边 你都可以通过这个实力属性 访问到

19:38.410 --> 19:41.530
仓库 那么比方说我们在A组建里边 几个生命都去含述

19:42.490 --> 19:44.650
我们输出一下 当前的仓库Store

19:46.490 --> 19:49.050
好 输出你看一下 这边控制台

19:49.770 --> 19:53.290
所以能够拿到这个仓库了 刚才我们看到的仓库对象是不是拿到了

19:54.010 --> 19:59.130
啊 那么同样的 那么既然可以拿到 在这里可以是不是可以用啊 在这个地方 怎么用

20:01.050 --> 20:02.250
是不是Store

20:02.970 --> 20:06.410
第二State 穿固的状态 拿个数据Count

20:06.970 --> 20:10.730
是不是拿到这个数据了 那么同样的道理在B组建里边 所以也可以拿这个数据

20:11.370 --> 20:13.290
B组建里边 所以也可以拿这个数据

20:16.010 --> 20:22.170
没问题吧 好 那么我们看一下 现在仍然是两个零 但是现在就不一样了 这两个零呢是来自于仓库的数据

20:23.370 --> 20:29.450
而且呢 我们仓库只要一遍 比方说我们这里Windows里边一个Store对象啊 都是同一个Store对象 我们改变这个仓库的数据Count

20:30.090 --> 20:32.250
加加 你看一下 是不是都加一了

20:33.050 --> 20:37.370
所以满足我们刚才说的要求 仓库的数据变化会导致他们本身发生变化

20:38.010 --> 20:39.210
啊 很简单吧

20:40.010 --> 20:46.490
对不对 好 然后呢 我们那如果说要减少怎么办 减少的话非常简单啊 我们这里住这个时间吧

20:46.890 --> 20:47.210
click

20:48.170 --> 20:56.890
点击的时候呢 我们把Store叫StateCount减减减少啊 一步我们以后再说啊 然后这里增加呢 我说click

20:59.050 --> 20:59.450
Store

21:00.970 --> 21:09.610
StateCount加加 都要改动仓库就完事了 任何图件都可以改动仓库 那我们来看一下减少 是不是跟着一起减了

21:10.330 --> 21:15.610
对增加是跟着一起争了 对吧 复杂吗 现在至少现在不复杂吗

21:16.570 --> 21:21.610
好 但是这样子好吗 这样子是可以的 但是不好

21:22.730 --> 21:32.890
你如果说你只需要这样子的话 那你其实没有必要用wix了啊 将来我们在后边给大家说 我们自己熟悉一个简单的仓库呢 几句话就写完了 你看你没有必要用wix了

21:33.930 --> 21:35.050
因为wix呢

21:35.770 --> 21:40.010
他用来在大主要是用于大型项目的 大型项目有个怎么特点

21:40.890 --> 21:45.850
组件特别多 组件的层次特别复杂 共享数据的共享了也

21:46.570 --> 21:49.530
就是共享数据呢 可能会应用到不同的组件里面去

21:50.170 --> 21:56.090
有可能任何组件都可能会改变数据 那么现在你在脑海里边想 我这个例子呢就不好给大家举了啊

21:56.730 --> 22:00.570
脑海里边想 现在我们的网页上有个极其复杂的网页

22:01.130 --> 22:03.930
这个网页呢 可能涉及到成百上千个组件

22:04.650 --> 22:12.570
这些成百上千个组件里边 可能有一两百个组件都要用到同一个共享数据 比方说最常见的就是当前登录用户

22:13.290 --> 22:16.810
很多组件都要兵去当前登录用户来显示的 比方说一个评论区

22:17.850 --> 22:22.090
如果说你当前没有登录 他就会去显示请登录 对吧 还比方说

22:23.210 --> 22:26.970
收藏按钮 你当前没有登录的话 点击收藏按钮 他就会去坦出请先登录

22:27.530 --> 22:32.410
就是很多组件都可能跟当前登录的状态有关系 可能有100多个组件都有关系

22:34.010 --> 22:39.130
而且呢 更夸张的是 有可能会有这100多个组件都有可能会改变登录状态

22:41.050 --> 22:45.530
比方说有一个组件你点了登录过后 他那边可以用了 这登录状态有已经变化了

22:46.250 --> 22:52.090
就是有很多组件都可能会改变这些共享数据 如果说有一天共享数据出了问题

22:52.890 --> 22:54.650
你知不知道是什么导致的问题

22:55.930 --> 22:57.610
有可能你页面刚刚一刷新

22:58.570 --> 23:02.810
这个共享数据已经出现了非常多次变化了 因为任何组件都会可以更改它

23:03.370 --> 23:08.970
更不要说这个网页运行了一会 用户点了一些东西 做了一些操作 突然页面爆错了

23:09.450 --> 23:13.770
有一个共享数据出了问题 他成为了一个不该应该有的状态

23:14.730 --> 23:17.130
爆错了 你是不是要调啊 是不是要去调个bug

23:18.010 --> 23:26.970
那如果说你的网页足够复杂 你怎么知道这个数据变化了哪些多少次 是从什么状态变成了这个错误状态的 你根本就不知道

23:27.370 --> 23:32.730
因为任何组件都有可能改变它 是不是说极难调试 你不要认为这是一个小问题

23:33.530 --> 23:36.890
过去呢 在Facebook

23:38.170 --> 23:40.010
Facebook上面也遇到一些bug

23:40.810 --> 23:44.090
他们呢 用的不是伍佑啊 用的是其他技术

23:44.730 --> 23:49.610
不然他用的就遇到类似的问题 有些共享数据 很多组件都有可能会改用它

23:50.650 --> 23:52.890
那我这个数据变了变成一个错误的状态

23:53.610 --> 23:58.730
整个部门调了一抽都没找到错误 到底是怎么导致的 因为他组件太多了

23:59.850 --> 24:05.850
那怎么办呢 就必须要以后这个问题解决的 倒是解决了 解决了过后我们得想办法 以后不要发生这种问题了

24:06.730 --> 24:10.730
于是呢 我们希望了这个数据的变化是能够被监控到的

24:11.370 --> 24:14.970
它在什么时间点 是从什么状态变成了这个状态

24:15.930 --> 24:19.610
那么当时是为什么从这个状态变成这个状态 我们都希望能够监控到

24:20.570 --> 24:24.490
那么如果说你现在直接改变状态 你就监控不到这个东西

24:25.610 --> 24:29.050
我给你解释这么多了 主要是要引出一个概念啊 这个概念就是

24:30.090 --> 24:32.090
猛蹄形 我们现在讲数据的变更

24:33.610 --> 24:39.450
vx建议你不要去这样子直接变变化数据 这样子你的数据是很难跟踪到的

24:39.930 --> 24:44.490
它建议什么呢 建议你使用一个东西 一个特殊东西来更改数据 叫做猛蹄形

24:44.890 --> 24:47.530
猛蹄形的意思呢 叫做突变

24:48.330 --> 24:52.330
变化 变异 就是这就是个变化 一个猛蹄形就是个变化

24:52.890 --> 24:56.090
它让一个数据从一种状态变成另一种状态

24:57.130 --> 25:02.490
通过使用它来更改数据 让这个数据变更是可控的 我们来看一下啊 怎么弄

25:04.250 --> 25:07.210
我们在这里写吧 编写代码 这个文档就可以

25:07.770 --> 25:14.010
那些有 如果说喜欢看文档的同学就可以直接去看文档啊 我这边呢就在代码里边给他写了

25:14.730 --> 25:22.330
我们这是一个仓库 对吧 这个仓库里边有一个状态 那么现在的状态呢 有可能会发生哪些变化 你先把它定义好

25:22.890 --> 25:24.890
你不要在那里 之后在那里随便变

25:25.530 --> 25:31.930
定义好 把每一种变化定义成一个方法 以发生我这里呢有可能会发生这么几种变化

25:32.890 --> 25:34.170
举个例子啊 举个下几个例子

25:34.650 --> 25:36.410
就配置一个代码

25:37.210 --> 25:38.410
表示数据的突变

25:39.370 --> 25:42.490
每一个突变就是一个方法 比方说这个数据有可能加一

25:42.970 --> 25:48.970
我们给他定义一个increase方法 表示这个数据有可能加一 每一个方法的第一个参数呢表示的是

25:49.610 --> 25:55.210
当前的状态 他会自动的把当前的状态传给你 到时候交用方法的时候 他会自动给你传

25:55.930 --> 25:59.850
当前的状态 传给你 然后呢就问你你怎么变化

26:00.650 --> 26:03.210
怎么变化呢 我就加一呗 就这么简单

26:04.170 --> 26:06.330
好 那么我们还有减少decrease

26:08.360 --> 26:11.800
他也会把当前的状态给你 状态怎么变呢 减一呗

26:12.200 --> 26:17.560
那么将来你想想这个方法一定要用 是不是状态就加一了 这个方法一定要用 将来就减一了

26:18.120 --> 26:23.160
但是跟之前的做法就完全不一样了 之前做法是我们在外面直接更改这个状态

26:23.720 --> 26:24.440
现在是变成了

26:25.800 --> 26:31.320
调用方法 调用方法的时候呢 他就能够记录你的状态变更

26:31.960 --> 26:33.480
你直接更改的话 他记录不了

26:34.440 --> 26:39.000
好 比方说呢 有的时候呢 我们更改一个状态 可能还会需要一些额外的信息

26:39.640 --> 26:42.200
比如说我这里有个power power表示

26:42.440 --> 26:45.000
求密 求他的多少次密

26:46.040 --> 26:49.880
他也会给你传一个当前状态 但是呢我要求多少次密 比方说

26:50.120 --> 26:53.960
当前数字的5次方 当前数字的6次方

26:54.200 --> 26:59.080
到底几次方呢 你要传给我 那么传递的额外信息呢 我们把它叫做payload

26:59.800 --> 27:01.640
payload啥意思呢 就表示的是

27:02.920 --> 27:05.240
复贺 复载的意思

27:05.480 --> 27:06.760
就好像一列卡车

27:07.000 --> 27:09.320
他要运送一些货物

27:09.560 --> 27:14.200
那么这个运送的货物呢 就是复贺 就表示一些额外的东西

27:14.440 --> 27:15.480
额外带的东西

27:15.720 --> 27:17.000
payload

27:18.280 --> 27:19.560
叫做复贺

27:19.560 --> 27:20.840
也叫做复载

27:21.080 --> 27:27.400
那么这个东西可以是任何数据 可以是数字可以是支付出来可以是一个对象可以是任何东西

27:28.120 --> 27:33.240
当然那个名字呢 我们平时得用的是payload的 你可以换个别人名字 因为他只是一个行参

27:34.520 --> 27:39.640
好 那么比方说我这里的就约定啊 这个方法呢 他这个参数呢 是一个数字

27:39.880 --> 27:43.480
表示当前数字的几次方 那我们这里的是不是可以写个StateCult

27:43.960 --> 27:46.280
等于StateCult的

27:47.320 --> 27:48.040
payload的释放

27:48.600 --> 27:51.160
对吧 也可以用这种方式写啊

27:51.160 --> 27:51.880
都可以

27:52.440 --> 27:57.270
好 我们现在就定义了三种数据变化

27:57.430 --> 28:02.470
看到呗 我们也就说 我们这里呢

28:02.950 --> 28:06.310
仓库里边有一个数据 针对这个数据呢 我们至少这里的

28:06.710 --> 28:09.670
定了三种变化 你只能通过这种Multi-sync

28:10.310 --> 28:12.390
来改变数据 你不能随便

28:13.830 --> 28:19.430
那么之后呢 有了这个Multi-sync之后 我们现在如何来更改数据呢 你就千万不能再这样子写了啊

28:19.910 --> 28:23.350
千万不能在这个StateCult里边直接去更改了啊 尽管它允许你这样做

28:23.830 --> 28:29.190
但不能这样子更改了 你看这样子更改的数据过后 我们在监控里边是完全不知道这个数据变了的

28:29.430 --> 28:30.070
它不知道的

28:30.710 --> 28:35.670
那我们怎么样才能去知道这个数据变化呢 我们必须要提交Multi-sync

28:36.310 --> 28:39.670
Multi-sync 我们触发Multi-sync的方式叫做提交Multi-sync

28:39.910 --> 28:42.070
提交突变 提交一次数据变化

28:42.550 --> 28:46.470
那我们怎么来提交呢 我们使用仓库里边给我们提供了一个函数叫comment

28:46.790 --> 28:47.510
提交的意思

28:49.350 --> 28:50.950
那么怎么写comment

28:51.670 --> 28:54.790
它的第一个参数是数据突变的类型

28:55.430 --> 28:59.910
数据突变 因为这个突变其实就是一个单词 对吧 一个方法就是一个单词

29:00.150 --> 29:05.670
它其实就是描述了一个数据突变的方向 增加 减少 还是穷逆

29:06.070 --> 29:09.670
所以间接了描述了这个数据突变的原因 到底是怎么突变的

29:09.910 --> 29:12.950
好 我们这里呢 就是increase 比方说增加一个

29:14.230 --> 29:16.550
好 第二个参数呢 写复合 payload

29:16.790 --> 29:20.390
那么我们这里没有怎么复合 增加的话它不需要有什么复杂

29:20.870 --> 29:23.670
那我就不写那边 那复杂就是 on defined

29:23.910 --> 29:25.670
我们来看一下啊 一回车

29:26.230 --> 29:31.750
说数据变了 这样子一运行是不是就相当于是运行了仓库里边的increase方法

29:31.830 --> 29:35.030
它会自动给你传这个当前的状态 状态就变化了

29:35.670 --> 29:39.430
哎 为什么这样子做了有好处呢 你看一下这边

29:41.770 --> 29:42.330
看到没

29:43.050 --> 29:44.970
是不是它这里记录了状态的变化

29:45.290 --> 29:46.650
它一开始的状态是0

29:47.290 --> 29:50.410
然后变到它状态变成1 为什么变成1呢

29:50.570 --> 29:53.690
因为提交了一个multation 什么multation的increase

29:53.690 --> 29:55.930
一看数据的变化是不是记录下来了

29:56.650 --> 29:58.650
好 比方我们再来啊 我们再来一个

29:59.210 --> 30:01.530
command increase变成了2 你看这边

30:02.090 --> 30:05.290
这边又多了一个又出发了一个multation increase

30:05.290 --> 30:08.330
这样子我们就可以监控到数据是怎么一步一步变化的

30:08.970 --> 30:09.450
看到没

30:10.010 --> 30:13.450
哎 如果说我这里还可以提交什么 还可以提交stone

30:14.650 --> 30:16.730
command power

30:17.690 --> 30:21.210
是不是可以传负贺了 这个需要一个负贺 比较说三次方

30:21.210 --> 30:23.850
二到三次方就是八 变成八了

30:23.850 --> 30:26.410
然后我们看一下这里是不是又多了一个突变

30:26.890 --> 30:28.890
我们可以看到每一步是怎么变化的

30:28.890 --> 30:31.210
它可以记录下来 它为什么能记录下来了

30:31.210 --> 30:33.530
因为你通过调用这个方法的时候

30:34.010 --> 30:36.330
实际上这个这个调制工具

30:36.970 --> 30:38.490
就在监控这个方法的调用

30:38.730 --> 30:42.490
它调用方法的时候呢 它会先记录当前的状态

30:43.450 --> 30:47.610
然后呢等那个方法调用完了过后再记录之后的状态

30:47.610 --> 30:51.450
它就能知道每一步的状态是怎么从一个状态变到另一个状态的

30:52.490 --> 30:55.290
而且呢这个调制工具还允许的进行时间旅行

30:55.290 --> 30:57.850
比方说这里呢 我这个始终看到没

30:59.130 --> 31:00.410
Time travel

31:00.410 --> 31:02.970
让你旅行到这个状态

31:02.970 --> 31:04.250
点击

31:04.250 --> 31:05.530
你看状态变回这个状态了

31:05.530 --> 31:08.330
我们可以可以回到之前的那个状态来一步一步检查

31:08.330 --> 31:10.650
页面上到底是哪个区域出的问题

31:11.610 --> 31:12.650
没了意思吧

31:12.650 --> 31:14.650
你看我又可以回到这个状态

31:14.650 --> 31:16.650
又可以回到这个状态

31:16.650 --> 31:18.650
没了意思吧就这么个意思

31:19.770 --> 31:24.170
这就是为什么我们要去使用那个突变来改变状态

31:24.170 --> 31:26.490
就可以主要的目的是为了方便调试

31:26.490 --> 31:28.490
那如果说你在中小型项目里边

31:29.290 --> 31:30.730
本来组建的物多对吧

31:30.730 --> 31:32.010
可能有几十个组建

31:32.010 --> 31:32.890
几十个组建的

31:33.770 --> 31:35.210
都还在可控范围之内

31:35.210 --> 31:38.010
不要择不太复杂的话都还在可控范围之内

31:38.170 --> 31:41.450
而且共享的东西本来也不多

31:41.450 --> 31:43.450
那可能就不需要用到这个东西了

31:43.450 --> 31:45.450
如果说大型项目就非常需要这个东西

31:46.810 --> 31:48.810
于是我们这里的减少和增加

31:48.810 --> 31:50.810
是不是不能这样子写呢

31:50.810 --> 31:52.810
减少和增加

31:55.610 --> 31:58.170
减少的时候我们是不是不能再这样子写了

31:58.170 --> 31:59.770
减少的时候该怎么减少

31:59.770 --> 32:01.770
是不是应该用Stone

32:02.730 --> 32:03.930
叫Comet

32:03.930 --> 32:05.930
提交什么突变

32:05.930 --> 32:07.930
Decrease

32:08.730 --> 32:10.730
当然也可以把写成方法

32:10.730 --> 32:12.730
Message

32:12.730 --> 32:14.730
Handle

32:14.730 --> 32:16.730
Decrease

32:16.730 --> 32:21.770
处理减少

32:21.770 --> 32:26.620
那么其实就是个代码

32:26.620 --> 32:28.620
就是个代码

32:28.620 --> 32:30.620
那么这里用方法

32:30.620 --> 32:32.620
Handle Decrease

32:32.620 --> 32:34.620
另外一边就是增加

32:34.620 --> 32:36.620
我们可以写一个方法

32:36.620 --> 32:38.620
Message

32:38.620 --> 32:40.620
Handle

32:40.620 --> 32:42.620
Increase

32:42.860 --> 32:44.860
提交一个突变

32:44.860 --> 32:50.150
Increase

32:50.150 --> 32:52.150
Handle Decrease

32:52.150 --> 32:54.150
保存啊,我们来看一下

32:54.150 --> 32:57.530
刷新

32:57.530 --> 32:59.530
现在我们这里一开始是一个基础状态

32:59.530 --> 33:01.530
零

33:01.530 --> 33:03.530
你看这里是不是记录了

33:03.530 --> 33:05.530
你看这里是不是都记录了

33:05.530 --> 33:07.530
然后增加

33:07.530 --> 33:09.530
增加

33:09.530 --> 33:11.530
你看这里是不是都记录了

33:11.530 --> 33:13.530
而且每一步它是怎么变化的

33:13.530 --> 33:15.530
提交的是什么呢

33:15.770 --> 33:17.770
那个负荷是什么

33:17.770 --> 33:19.770
还都一一记录下来

33:19.770 --> 33:21.770
OK啊

33:21.770 --> 33:23.770
这是关于那个

33:23.770 --> 33:25.770
状态的突变

33:25.770 --> 33:27.770
Mertekin

33:27.770 --> 33:29.770
那么这有两个点要特别注意啊

33:29.770 --> 33:31.770
一个是Mertekin中不得出现一步操作

33:31.770 --> 33:33.770
为什么它不允许你出现一步操作呢

33:33.770 --> 33:35.770
就说你在Mertekin里边啊

33:35.770 --> 33:37.770
这里是写的Mertekin

33:37.770 --> 33:39.770
你不能够写这些东西啊

33:39.770 --> 33:41.770
什么抬帽子啊

33:41.770 --> 33:43.770
一秒钟之后状态变化

33:44.010 --> 33:46.010
或者是你做一些什么阿迦克斯过后呢

33:46.010 --> 33:48.010
你才去做一些状态变化

33:48.010 --> 33:50.010
不允许的啊

33:50.010 --> 33:52.010
为什么不允许呢

33:52.010 --> 33:54.010
因为Mertekin出现的原因是啥呢

33:54.010 --> 33:56.010
你搞清楚

33:56.010 --> 33:58.010
出现的原因是不是为了方便调试啊

33:58.010 --> 34:00.010
那调试它是怎么调试的

34:00.010 --> 34:02.010
它是在触发这个Mertekin的时候

34:02.010 --> 34:04.010
就在commet的时候啊

34:04.010 --> 34:06.010
就在我们的commet的时候

34:06.010 --> 34:08.010
调用这个东西的时候

34:08.010 --> 34:10.010
它会先记录当前的状态

34:10.010 --> 34:12.010
而commet一运行完

34:12.010 --> 34:14.010
一秒钟之后再改变

34:14.010 --> 34:16.010
它又记录不到了

34:16.010 --> 34:18.010
commet之前它这个状态

34:18.010 --> 34:20.010
这个函数是不是瞬间运行完了

34:20.010 --> 34:22.010
这个东西一不处理是世界运行完嘛

34:22.010 --> 34:24.010
那么这个玩意是之后再运行

34:24.010 --> 34:26.010
它不管之后的

34:26.010 --> 34:28.010
运行完这个方法它马上又会记录新的状态

34:28.010 --> 34:30.010
它就记录不到

34:30.010 --> 34:32.010
明儿的意思吧

34:32.010 --> 34:34.010
是这么个意思

34:34.010 --> 34:36.010
所以它不允许你出现异步

34:36.010 --> 34:38.010
然后呢在有一些公司里边

34:38.010 --> 34:40.010
或者是一些其他的实际开发中

34:40.010 --> 34:42.010
它甚至不要求你

34:42.010 --> 34:44.010
不得有副作用操作

34:44.010 --> 34:46.010
这个玩意是借鉴那个react里面的redux

34:46.010 --> 34:48.010
那里面以后要学习的

34:48.010 --> 34:50.010
它甚至不允许你副作用

34:50.010 --> 34:52.010
其实在viewx里面

34:52.010 --> 34:54.010
它倒是美后说你不能有副作用

34:54.010 --> 34:56.010
它只是说不能有异步

34:56.010 --> 34:58.010
异步是副作用的一种

34:58.010 --> 35:00.010
什么叫副作用呢

35:00.010 --> 35:02.010
这些操作都叫做副作用

35:02.010 --> 35:04.010
异步

35:04.010 --> 35:06.010
另外呢就是

35:06.010 --> 35:08.010
更改和读取外部环境的信息

35:08.010 --> 35:10.010
例如我们地子栏

35:10.010 --> 35:12.010
读什么local storage

35:12.010 --> 35:14.010
读什么动物元素

35:14.010 --> 35:16.010
就读外面的东西

35:16.010 --> 35:18.010
跟这个函数本身的参数无关的东西

35:18.010 --> 35:20.010
那么你去读那些东西的话

35:20.010 --> 35:22.010
都叫做副作用

35:22.010 --> 35:24.010
读或者是更改都叫做副作用

35:24.010 --> 35:26.010
不过呢viewx再说一次

35:26.010 --> 35:28.010
viewx它没有这样的要求

35:28.010 --> 35:30.010
只是我们平时开发中的

35:30.010 --> 35:32.010
可能规范更加严格一点

35:32.010 --> 35:34.010
这是第一个

35:34.010 --> 35:36.010
要注意的

35:36.010 --> 35:38.010
改变数据只能有一个途径

35:38.010 --> 35:40.010
就是通过提交

35:40.010 --> 35:42.010
提交的时候有可能会有负荷

35:42.010 --> 35:44.010
没提交是改变数据的唯一原因

35:44.010 --> 35:46.010
不然的话你就不要用这个贵科词

35:46.010 --> 35:48.010
你自己去写个仓库

35:48.010 --> 35:50.010
你自己去简单几个代码

35:50.010 --> 35:52.010
去写个简单的仓库就ok了

35:52.010 --> 35:54.010
你不要用它

35:54.010 --> 35:56.010
它出现的目的就是为了监控数据变化

35:56.010 --> 35:58.010
能够非常方便的来

35:58.010 --> 36:00.010
监控共享数据的变化

36:00.010 --> 36:02.010
所以说你必须要通过提交没提行

36:02.010 --> 36:04.010
来改变仓库

36:04.010 --> 36:06.570
就描述了组建UI

36:07.090 --> 36:10.150
组建仓库和马铁型之间的关系

36:10.410 --> 36:11.690
我们仓库中有一些数据对吧

36:11.950 --> 36:13.730
组建里面是不是在用这些数据

36:14.250 --> 36:16.290
我们在组建里面是不是在用这些数据

36:18.610 --> 36:22.190
然后有一天组建发生了一件事件或者是做了什么事情

36:22.450 --> 36:24.750
总之他就有可能会提交马铁型

36:25.250 --> 36:27.050
提交马铁型是不是改变了仓库

36:27.810 --> 36:29.090
改变了仓库之后

36:30.130 --> 36:32.430
依赖这个对应数据的组建

36:32.690 --> 36:33.450
他就会

36:33.650 --> 36:34.450
重新宣传

36:34.970 --> 36:35.490
你看

36:35.750 --> 36:37.550
我这边点了这个增加

36:38.050 --> 36:39.590
点了过后是不是提交了一个马铁型

36:39.850 --> 36:40.610
改变了仓库

36:40.870 --> 36:41.650
仓库一变

36:41.890 --> 36:43.950
那么这两个图片都是依赖这个仓库的

36:44.210 --> 36:45.230
他都会重新宣传

36:45.990 --> 36:47.270
他整个流程是这样子的

36:48.290 --> 36:49.330
好这是数据的变革

36:52.130 --> 36:53.410
好接下来再说异部处理

36:54.190 --> 36:57.250
我们刚才做了一个仓库一个仓库不是不能异部处理吗

36:57.510 --> 36:57.770
不能处理

36:58.030 --> 37:00.070
这个马铁型是不能处理异部的

37:00.530 --> 37:03.850
那有的时候我确实需要异部怎么办了比方说我一个网络请求

37:04.630 --> 37:07.190
我说是当前登陆用户我得先请求

37:07.450 --> 37:10.770
我得先登陆啊登陆不是一个阿交克斯吗那不得是异部吗

37:11.290 --> 37:12.310
那这个东西怎么办了

37:12.830 --> 37:15.130
他单独一个东西来进行处理异部

37:15.390 --> 37:16.150
这东西叫做X

37:19.000 --> 37:21.560
他是专门这里边也是配置一个一个的方法

37:21.820 --> 37:22.580
他专门来

37:23.100 --> 37:23.860
处理异部的

37:24.380 --> 37:27.440
那比方说我这里的提供一个异部增和一个异部减

37:27.700 --> 37:28.220
而sync

37:28.480 --> 37:29.240
increase

37:30.000 --> 37:31.040
一个异部增加

37:32.020 --> 37:33.000
和一个异部减少

37:33.640 --> 37:35.180
再来一个异部power吧

37:35.680 --> 37:36.200
而sync

37:36.460 --> 37:37.220
decrease

37:39.020 --> 37:39.780
再来一个

37:40.300 --> 37:40.820
而sync

37:41.320 --> 37:41.820
power

37:42.600 --> 37:44.400
比方说都有相应的异部操作

37:45.160 --> 37:46.700
那么这个increase里边呢

37:47.220 --> 37:49.000
我们怎么来弄呢我们希望

37:49.760 --> 37:54.120
一段时间过后比方说一秒钟之后我在增加数字

37:54.640 --> 37:55.920
那问题是怎么增加的

37:57.200 --> 37:57.960
你在这里

37:58.840 --> 38:02.820
不能使用什么StandardState然后靠扯加加啊不能这样子做啊

38:03.080 --> 38:04.100
尽管这样子是可以

38:04.360 --> 38:05.900
但是就打破了vux的这种

38:06.160 --> 38:06.660
结构了

38:06.920 --> 38:07.940
不能去这样做啊

38:08.200 --> 38:09.220
应该怎么做

38:10.240 --> 38:11.280
刚才说的之前说了

38:11.540 --> 38:15.120
应该正确的做法是改动数据一定是提交门推行

38:15.880 --> 38:16.900
没有其他任何图形

38:17.160 --> 38:18.180
一定是提交门推行

38:18.700 --> 38:21.260
所以说呢我这里要去提交门推行怎么来提交呢

38:21.520 --> 38:23.300
实际上这个地方呢他会给你

38:24.080 --> 38:26.120
自动传入一个东西叫做context

38:26.840 --> 38:28.120
有的是我们减线为

38:28.880 --> 38:29.640
减线为他

38:30.940 --> 38:31.440
context

38:31.960 --> 38:35.540
context实际上是什么东西呢你现在暂时可以把他认为就是个仓库

38:35.800 --> 38:37.840
尽管他跟仓库的还是有点区别的啊

38:38.100 --> 38:40.400
我们这里的先暂时认为他就是这个仓库

38:41.440 --> 38:43.220
那么可以通过这个context呢

38:43.480 --> 38:45.280
干嘛是commet提交

38:45.540 --> 38:46.800
提交什么提交一个门推行

38:47.320 --> 38:49.360
门推行是什么门推行是increase

38:49.880 --> 38:50.640
增加

38:51.160 --> 38:52.440
是这么一个模具啊

38:52.700 --> 38:53.200
increase

38:56.180 --> 38:57.460
好然后呢有了这个

38:58.220 --> 38:59.900
一会这边也也写一下啊

39:01.420 --> 39:03.140
那么这边也是一样context

39:03.220 --> 39:04.500
那么这里提要的是decrease

39:08.180 --> 39:09.140
好那么这个呢

39:09.900 --> 39:10.620
也是一样啊

39:12.180 --> 39:12.580
power

39:13.100 --> 39:16.310
提交一个power

39:16.550 --> 39:17.870
power需要一个负荷

39:17.950 --> 39:19.390
那么这个负荷我也不知道是多少

39:19.390 --> 39:21.790
然后我这里也可以给我传一个负荷

39:21.950 --> 39:24.510
也就是这个x型的他也是可以接受负荷的

39:25.910 --> 39:26.270
传过来

39:26.870 --> 39:27.750
就像这样子

39:28.350 --> 39:30.590
x型是在专门来处理异部操作的

39:31.830 --> 39:33.470
但是他改变数据他不能直接改变

39:33.470 --> 39:35.190
他必须要通过提交门推行来改变

39:35.670 --> 39:37.350
他的整个逻辑是下面这样这张图

39:39.110 --> 39:39.950
你看啊

39:40.470 --> 39:41.310
之前我们画了

39:42.070 --> 39:43.230
这一部分对吧

39:43.790 --> 39:45.390
理解了吧从分区理解了啊

39:45.630 --> 39:47.030
然后呢现在多了一个x型

39:47.390 --> 39:48.990
就是有的时候那么可能要做一些副作

39:48.990 --> 39:51.270
就是异部操作或者是副作用的操作啊

39:51.790 --> 39:55.270
之前呢说门推行里面不能有副作用的这种规范里面呢

39:55.310 --> 39:57.270
他就把副作用就放到这个x型里面去了

39:58.470 --> 40:01.790
好总归的是有一些操作异部操作副作用操作

40:01.790 --> 40:03.670
那么通过我们要去通过

40:05.030 --> 40:06.230
触发x

40:06.990 --> 40:09.950
我们把叫做这个触发的过程的叫做分发啊

40:09.950 --> 40:13.630
就上面之前那个过程之前提交门推行的叫做commet

40:14.510 --> 40:16.390
触发这个x的叫做disparch

40:19.510 --> 40:21.470
好我们需要触发这个x

40:21.990 --> 40:25.030
x去做一些事比方说这里等待等待多少时间啊

40:25.030 --> 40:26.510
等待一秒钟啊怎么样

40:27.270 --> 40:32.470
然后最终他可能会去一次或多次改变门推行

40:32.870 --> 40:34.310
他可以提交门推行呢

40:34.310 --> 40:36.350
他可以提交一次可以提交多次啊都可以

40:38.390 --> 40:39.390
他可以提交门推行

40:39.390 --> 40:42.430
最终还是要通过我们准备成型去改变仓库

40:42.430 --> 40:44.190
仓库一变然后呢旋了UI

40:44.550 --> 40:45.870
对还变成这样的一个过程了

40:46.270 --> 40:48.910
啊UI当然也可以直接去提交门推行也可以

40:48.910 --> 40:51.630
也可以用异部操作提交x型啊

40:51.630 --> 40:53.590
让x型的间接着去提交门推行

40:54.590 --> 40:57.750
因为我们在调试工具呢最终会记录只记录的是

40:57.750 --> 40:59.390
马台型他不会记录x型的啊

40:59.390 --> 41:00.190
x型记录不了

41:01.150 --> 41:02.510
好那么就这么一个逻辑

41:03.510 --> 41:05.190
好现在我们把这个三个x型写好了

41:05.190 --> 41:06.190
我们又来试一下啊

41:07.510 --> 41:09.150
我们来刷新看一下这个状态啊

41:11.990 --> 41:13.030
然后我们在这边

41:13.710 --> 41:14.630
我们看一下这边能

41:15.910 --> 41:19.120
在停滞记录

41:19.920 --> 41:22.120
来吧自己指红铁

41:22.320 --> 41:23.120
Stone

41:24.560 --> 41:26.360
这里也是分发x型

41:26.880 --> 41:28.440
第一个参数x型的类型

41:29.040 --> 41:30.760
类型呢就是那个方法名字

41:31.560 --> 41:32.920
比较说一步增加

41:35.920 --> 41:37.400
一步增加一回车

41:38.480 --> 41:40.120
你看是不是一秒钟之后增加啊

41:40.400 --> 41:41.520
那么他这边记录的是啊

41:41.520 --> 41:44.000
记录的指示马台型他记录不了x型的啊

41:44.440 --> 41:45.800
只只能记录门推行

41:46.960 --> 41:47.760
好又来啊

41:49.200 --> 41:49.720
增加

41:50.720 --> 41:52.080
啊你看是不是搞定了

41:52.600 --> 41:53.640
啊又出发

41:54.760 --> 41:56.200
啊是不是一秒钟之后增加

41:57.640 --> 42:00.000
好然后呢我这边呢再来一个

42:00.720 --> 42:02.720
a sync decrease

42:07.160 --> 42:07.720
说二

42:09.240 --> 42:10.560
a sync decrease

42:11.760 --> 42:12.200
一

42:12.680 --> 42:16.000
然后呢我们再来如果说我们要有负荷的话

42:16.000 --> 42:17.560
就是a sync power

42:18.560 --> 42:19.640
比较传个参数啊

42:19.800 --> 42:20.400
三次方

42:21.120 --> 42:22.760
一的三次方好像没什么变化

42:24.800 --> 42:26.040
好像也没什么变化啊

42:26.360 --> 42:28.320
啊我们这里的先增加吧

42:28.560 --> 42:29.080
increase

42:29.760 --> 42:31.160
然后我们再来二的三次方

42:32.440 --> 42:33.240
看看到没

42:33.680 --> 42:35.680
这边记录的全是马台型的变化

42:36.640 --> 42:37.320
明儿的意思吧

42:37.880 --> 42:40.160
啊然后呢我们可以看到这个dispatch这个函数啊

42:40.160 --> 42:41.920
他有个返回返回的是个promise

42:42.760 --> 42:44.280
这个promise返回的是啥呀

42:44.880 --> 42:47.640
这个promise返回的就是这个函数的返回结果

42:48.040 --> 42:50.120
啊所以说有的时候呢我们可以把这个函数呢

42:50.400 --> 42:52.240
呃用一个返回个promise啊

42:52.480 --> 42:53.000
能够知

42:53.320 --> 42:55.320
那么在dispatch的时候呢我们就可以知道

42:55.800 --> 42:57.840
他什么时候一步操作结束了

42:58.520 --> 43:01.400
啊比方说我们这里呢可以这样子写啊写一个辅助函数

43:02.080 --> 43:04.080
方可行地内延迟多少秒

43:04.760 --> 43:05.360
点racing

43:05.960 --> 43:08.560
然后这里这个函数应该每个同学都会写吧

43:08.920 --> 43:09.400
result

43:11.080 --> 43:11.680
set them out

43:12.320 --> 43:14.560
点racing啊等待一会儿然后我们result

43:16.960 --> 43:19.920
好那么这边呢我们就可以用用成一个一步函数啊

43:19.920 --> 43:20.440
a sync

43:21.160 --> 43:21.640
a ways

43:21.880 --> 43:22.360
点内

43:23.080 --> 43:23.720
一秒钟

43:23.920 --> 43:24.960
然后呢我再去增加

43:27.960 --> 43:28.240
啊

43:29.000 --> 43:30.400
好然后这边也是一样啊

43:31.520 --> 43:32.280
this decrease

43:35.760 --> 43:36.720
然后这边也是一样

43:39.430 --> 43:40.190
这是power

43:42.610 --> 43:43.130
payload

43:44.810 --> 43:46.090
啊这都是一步函数

43:48.520 --> 43:50.920
好了这样子写也可以啊也可以

43:51.080 --> 43:54.320
那么他的返回值呢其实就是一个dispatch的返回值

43:54.840 --> 43:55.160
你看吧

43:55.320 --> 43:55.680
store

43:56.480 --> 43:57.040
dispatch

43:59.120 --> 43:59.680
increase

43:59.680 --> 44:01.120
那么他会返回一个promise对吧

44:01.120 --> 44:03.280
因为这边这边这边反复的是一个promise

44:03.280 --> 44:04.400
那么这里还可以认

44:04.400 --> 44:06.320
啊如果说你完成了过后了

44:06.320 --> 44:07.680
我这里就输出一个吧

44:10.760 --> 44:11.480
输出一个

44:14.480 --> 44:15.280
变化完成

44:16.720 --> 44:18.080
有的时候呢有点用啊

44:19.920 --> 44:22.000
要这里变化完成再来看一次啊

44:23.600 --> 44:24.160
变化完成

44:24.960 --> 44:28.960
OK啊这就是使用x来触发一些一步操作

44:29.200 --> 44:31.520
那么我们对应到界面上这里呢

44:32.440 --> 44:34.240
一步增加我们是可以注册时间

44:34.720 --> 44:35.280
handle

44:35.920 --> 44:36.560
啊

44:37.440 --> 44:38.080
a sink

44:38.880 --> 44:39.440
increase

44:43.200 --> 44:45.280
好这边我们是用store

44:46.800 --> 44:47.440
dispatch

44:49.880 --> 44:50.360
a sink

44:51.000 --> 44:51.480
increase

44:53.400 --> 44:54.760
好这边B

44:55.000 --> 44:55.480
组件

44:56.840 --> 44:57.640
一步减少

44:58.600 --> 44:59.160
handle

44:59.400 --> 44:59.960
a sink

45:00.920 --> 45:01.480
decrease

45:06.110 --> 45:07.230
this store

45:08.030 --> 45:08.670
dispatch

45:11.470 --> 45:13.230
a sink decrease

45:14.510 --> 45:15.310
好保证啊

45:15.870 --> 45:16.350
小心

45:17.150 --> 45:18.110
然后呢一步增加

45:19.870 --> 45:20.350
你看

45:22.110 --> 45:22.750
一步减少

45:25.680 --> 45:26.800
啊一步增加

45:27.680 --> 45:28.400
一步减少

45:29.040 --> 45:31.360
啊你看这里而且这边呢还是

45:31.600 --> 45:34.160
对每一次门推行都会记录啊它只记录门推行

45:35.120 --> 45:36.720
啊这边呢还有几个按钮我顺便说一下吧

45:36.720 --> 45:38.240
这个recording就正在记录中

45:38.480 --> 45:39.600
你可以停滞记录啊

45:39.920 --> 45:41.600
可以停滞记录停滞记录过后呢

45:41.680 --> 45:42.480
你可以把这个

45:43.600 --> 45:44.400
删除掉啊

45:44.960 --> 45:45.440
然后

45:46.400 --> 45:48.000
回归到最开始的状态

45:48.880 --> 45:52.880
然后这边呢我们再停滞记录过后呢我们再再减少再增加它就不会记录了啊

45:53.520 --> 45:54.160
不会记录了

45:54.400 --> 45:56.720
然后这里呢我们再点击它又可以开始记录

45:56.960 --> 45:57.360
减少

45:57.920 --> 45:58.480
增加

45:58.480 --> 45:59.280
它又开始记录了

45:59.520 --> 46:01.040
我们这里呢一个commit all

46:01.040 --> 46:02.080
commit all呢就是

46:04.000 --> 46:06.160
就是使用最后一次的状态数据

46:06.160 --> 46:08.480
那么之前呢就把那个记录就清空了

46:08.960 --> 46:10.480
那就看不见了那就这么个意思

46:12.080 --> 46:13.680
好了那么这就是这节课的内容啊

46:13.760 --> 46:14.880
当然我们这节课呢讲了

46:15.120 --> 46:17.040
呃仓库的最核心最核心的东西

46:17.520 --> 46:18.320
至少能够把

46:18.560 --> 46:19.840
一个程序跑起来了

46:20.080 --> 46:22.400
将来呢我们仓库的一边还有很多的一些

46:22.880 --> 46:25.200
呃小的一些使用技巧啊一些

46:25.440 --> 46:27.760
技巧型的可以给我们提供方便的一些函数

46:27.760 --> 46:29.280
我们之后来进行讲解吧

46:29.680 --> 46:31.360
OK啊咱们这节课就到这了

