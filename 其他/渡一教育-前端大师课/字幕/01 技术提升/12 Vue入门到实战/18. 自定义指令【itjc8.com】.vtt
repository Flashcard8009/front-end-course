WEBVTT

00:00.240 --> 00:02.240
下一个话题

00:02.240 --> 00:05.240
首页做的差不多了

00:05.240 --> 00:07.240
但是首页有个小的问题

00:07.240 --> 00:08.240
什么问题呢

00:08.240 --> 00:10.240
就是我们的数据

00:10.240 --> 00:12.240
我们首页有三张幻灯片

00:12.240 --> 00:15.240
那么这三张幻灯片呢

00:15.240 --> 00:18.240
是来自于远程数据

00:18.240 --> 00:20.240
而我们获取远程数据

00:20.240 --> 00:22.240
可能需要一段时间

00:22.240 --> 00:23.240
那我们来看一下吧

00:23.240 --> 00:24.240
我们来刷新

00:24.240 --> 00:26.240
你看是不是先空白

00:26.240 --> 00:28.240
空白了一段时间

00:28.240 --> 00:30.240
出现这个玩意儿

00:30.240 --> 00:32.240
如果说我们把这个魔力数据

00:32.240 --> 00:34.240
稍微的调整一下

00:34.240 --> 00:36.240
魔力

00:36.240 --> 00:38.240
也不要一千到两千

00:38.240 --> 00:40.240
我们来个10秒钟到20秒钟

00:40.240 --> 00:42.240
那么如果说这种情况的话

00:42.240 --> 00:44.240
就是魔力远程数据需要很长一段时间

00:44.240 --> 00:45.240
进行加载

00:45.240 --> 00:47.240
那么这个时候用户看到的是一个白板

00:47.240 --> 00:48.240
为什么是一个白板呢

00:48.240 --> 00:50.240
是因为我们的组建设计里边

00:50.240 --> 00:52.240
你看我们的组建设计

00:52.240 --> 00:55.240
这里不再循环渲染这个Li元素

00:55.240 --> 00:57.240
Li元素是根据什么渲染的

00:57.240 --> 00:59.240
根据Banners

00:59.240 --> 01:00.240
这个数组

01:00.240 --> 01:01.240
这个数组默认是空的

01:01.240 --> 01:03.240
那么也就是说一个Li都没有

01:03.240 --> 01:04.240
一开始

01:04.240 --> 01:06.240
那么这个时候去加载远程数据

01:06.240 --> 01:08.240
加载完了过后呢

01:08.240 --> 01:10.240
才给这个数组复职

01:10.240 --> 01:11.240
那么数组才有职

01:11.240 --> 01:12.240
有了职

01:12.240 --> 01:13.240
然后再重新渲染

01:13.240 --> 01:15.240
才能看到我们的界面

01:15.240 --> 01:17.240
于是呢就出现一个空白的

01:17.240 --> 01:19.240
一个真空期

01:19.240 --> 01:21.240
就是开始加载数据

01:21.240 --> 01:23.240
到加载数据完成之间

01:23.240 --> 01:24.240
那么这个时候界面

01:24.240 --> 01:25.240
显示啥的问题

01:25.240 --> 01:26.240
其实说白了我要干嘛呢

01:26.240 --> 01:28.240
我就是显示一个圈圈在那里

01:28.240 --> 01:29.240
转

01:29.240 --> 01:30.240
给一个用户

01:30.240 --> 01:32.240
看到一个加载中的效果

01:32.240 --> 01:34.240
就要做这么一件事

01:34.240 --> 01:36.240
那么这件事咋做呢

01:36.240 --> 01:37.240
用传统的方式呢

01:37.240 --> 01:38.240
其实也挺好做的

01:38.240 --> 01:39.240
怎么来做

01:39.240 --> 01:42.240
我们先用一个比较简单的方式来做

01:42.240 --> 01:43.240
就是我们在component里面

01:43.240 --> 01:44.240
新建一个组建

01:44.240 --> 01:47.620
叫做loading组建

01:47.620 --> 01:48.620
来吧

01:48.620 --> 01:49.620
来新建这么一个组建

01:49.620 --> 01:51.620
index的view

01:51.620 --> 01:55.310
这个组建要做的事情很简单

01:55.310 --> 01:57.310
就是加载一个

01:57.310 --> 01:59.310
转转的图片

01:59.310 --> 02:00.310
这个图片呢

02:00.310 --> 02:01.310
我在课件里面

02:01.310 --> 02:02.310
已经给大家提供了

02:02.310 --> 02:03.310
这个svg

02:03.310 --> 02:04.310
这个动图

02:04.310 --> 02:05.310
你把它复制

02:05.310 --> 02:06.310
复制到哪呢

02:06.310 --> 02:08.310
这是一些静态资源

02:08.310 --> 02:09.310
静态资源

02:09.310 --> 02:10.310
那么把它放到这

02:10.310 --> 02:11.310
新建在src里面

02:11.310 --> 02:12.310
新建一个文件夹

02:12.310 --> 02:14.310
比方说像一些图片啊

02:14.310 --> 02:15.310
像一些字体文件啊

02:15.310 --> 02:16.310
像一些比方说

02:16.310 --> 02:18.310
np3啊多媒体文件啊

02:18.310 --> 02:19.310
等等等等

02:19.310 --> 02:20.310
如果说有的话

02:20.310 --> 02:21.310
像这种静态资源

02:21.310 --> 02:23.310
它跟服务器没有什么关系

02:23.310 --> 02:24.310
那么你直接可以放到

02:25.310 --> 02:27.310
这是我们的习惯

02:27.310 --> 02:28.310
好我们给大家暂停到这

02:28.310 --> 02:30.310
这是一个svg图片

02:30.310 --> 02:31.310
那么现在呢

02:31.310 --> 02:32.310
我们在

02:32.310 --> 02:34.310
index的view里面呢

02:34.310 --> 02:36.310
我们就可以用一个mg元素

02:36.310 --> 02:38.310
用一个mg元素就ok了

02:38.310 --> 02:40.310
那么这个元素的链接地址呢

02:40.310 --> 02:41.310
就选择什么呢

02:41.310 --> 02:42.310
选择

02:48.310 --> 02:49.310
那么这个组建

02:49.310 --> 02:50.310
其实还有啥呀

02:50.310 --> 02:51.310
没啥了

02:51.310 --> 02:52.310
啥都没了

02:52.310 --> 02:53.310
脚本不要了

02:53.310 --> 02:54.310
都不用了

02:54.310 --> 02:55.310
那么我们要图片扔在这

02:55.310 --> 02:56.310
不就完了吗

02:56.310 --> 02:57.310
好那么接下来

02:57.310 --> 02:59.310
我们来测试一下这个组建啊

02:59.310 --> 03:00.310
还是老规矩

03:00.310 --> 03:02.310
先建一个task.vue

03:03.310 --> 03:04.310
然后导入进来

03:05.310 --> 03:06.310
impose

03:06.310 --> 03:07.310
这是一种最简单的

03:07.310 --> 03:09.310
制作这个楼顶效果的方式

03:09.310 --> 03:10.310
导入这个楼顶

03:12.310 --> 03:13.310
fro

03:13.310 --> 03:14.310
脚脊杠就ok了

03:15.310 --> 03:16.310
注册一下组建

03:16.310 --> 03:19.140
component

03:19.140 --> 03:20.140
楼顶

03:21.140 --> 03:22.140
注册进来

03:23.140 --> 03:24.140
那么我们在模板测试的时候

03:24.140 --> 03:26.140
在模板里面写上这么一个东西

03:26.140 --> 03:27.140
一个dave

03:27.140 --> 03:29.140
那么这里是一个楼顶组建

03:30.140 --> 03:31.140
楼顶

03:32.140 --> 03:33.140
ok

03:33.140 --> 03:35.140
然后下边一个按钮的显示

03:35.140 --> 03:36.140
切换显示隐藏

03:36.140 --> 03:38.140
显示隐藏

03:39.140 --> 03:40.140
好了

03:40.140 --> 03:41.140
写好这个测试组建过后

03:41.140 --> 03:42.140
老规矩

03:42.140 --> 03:44.140
我们在这边加上一个测试脚本

03:47.980 --> 03:48.980
test

03:48.980 --> 03:52.320
楼顶

03:52.320 --> 03:54.320
那么这里是楼顶

03:54.320 --> 03:55.320
test

03:55.320 --> 03:56.320
ok

03:56.320 --> 03:57.320
现在我们运行一下这个脚本

04:00.320 --> 04:01.320
先开一个吧

04:05.420 --> 04:07.420
npm run test

04:07.420 --> 04:09.800
楼顶

04:11.800 --> 04:12.800
呀

04:12.800 --> 04:13.800
啥意思

04:14.800 --> 04:15.800
他说啥呀

04:16.800 --> 04:17.800
他说找

04:19.800 --> 04:20.800
找不到

04:20.800 --> 04:21.800
没有进入一个目录

04:21.800 --> 04:22.800
我没有进入一个目录

04:23.800 --> 04:24.800
set

04:24.800 --> 04:25.800
课堂代码

04:26.800 --> 04:27.800
然后再set

04:28.800 --> 04:29.800
这个是my site

04:32.620 --> 04:34.620
然后来npm run

04:34.620 --> 04:35.620
test楼顶

04:35.620 --> 04:41.710
好打开啊

04:42.710 --> 04:43.710
看一下这个效果

04:43.710 --> 04:44.710
你看不这个图片就转出来了吗

04:45.710 --> 04:46.710
好那是这个图片呢

04:46.710 --> 04:48.710
他倒是没有居中

04:49.710 --> 04:50.710
那为啥没有居中呢

04:50.710 --> 04:51.710
是因为我

04:51.710 --> 04:52.710
没有设置央视

04:53.710 --> 04:54.710
央视的把它设置为居中

04:54.710 --> 04:56.710
在负义容器里边居中

04:56.710 --> 04:57.710
那这个很简单对吧

04:57.710 --> 04:58.710
我们可以呢

04:58.710 --> 04:59.710
用一个scout吧

05:00.710 --> 05:02.710
还是用ness

05:03.710 --> 05:05.710
我们就这里可以导入 import

05:09.300 --> 05:11.300
导入那个styles

05:12.300 --> 05:13.300
放个原弹

05:13.300 --> 05:15.300
我这些以前写的弹把都忘完了

05:16.300 --> 05:18.300
styles里边的一个mixin

05:18.300 --> 05:19.300
点ness

05:19.300 --> 05:20.300
是这个吧

05:21.300 --> 05:22.300
styles mixin.ness

05:22.300 --> 05:23.300
ok

05:23.300 --> 05:24.300
这里边有一个

05:25.300 --> 05:27.300
棍合的样式

05:27.300 --> 05:29.300
我们给这个imaging的设置一个样式

05:29.300 --> 05:30.300
you have a class

05:31.300 --> 05:32.300
img 就是楼顶

05:32.300 --> 05:33.300
楼顶

05:35.300 --> 05:36.300
用这个contain的作为那样式呢

05:36.300 --> 05:39.300
好像对img元素有点奇奇怪怪的

05:39.300 --> 05:40.300
它并不是一个容器

05:40.300 --> 05:41.300
但是命名规范

05:41.300 --> 05:42.300
然后我们这样做

05:42.300 --> 05:43.300
倒就这样做

05:43.300 --> 05:45.300
命名规范其实也是我们自己订的

05:46.300 --> 05:47.300
来吧也影响不了啥

05:47.300 --> 05:48.300
好我们这里呢

05:48.300 --> 05:49.300
就让他居中

05:49.300 --> 05:50.300
这个

05:50.300 --> 05:53.300
这个混合里面不是有一个abs

05:53.300 --> 05:54.300
sinter

05:54.300 --> 05:55.300
对不对

05:55.300 --> 05:56.300
居中

05:56.300 --> 05:57.300
好来看一下

05:57.300 --> 05:58.300
有没有居中呢

05:58.300 --> 05:59.300
这就把我戳了

05:59.300 --> 06:01.300
他说abs center is not defined

06:01.300 --> 06:04.300
咱们来看一下以前的mixin里面

06:04.300 --> 06:05.300
self center

06:09.300 --> 06:10.300
好

06:10.300 --> 06:11.300
不就居中了吗

06:12.300 --> 06:14.300
默认之呢是abs

06:14.300 --> 06:15.300
但是目前呢

06:15.300 --> 06:17.300
他不是针对那个附容器居中的

06:17.300 --> 06:18.300
对吧

06:18.300 --> 06:20.300
所以说呢他这里要求的附容器啊

06:20.300 --> 06:21.300
他得是一个placent

06:22.300 --> 06:23.300
placent relative

06:23.300 --> 06:25.300
那么这样子才能相对于附容器居中

06:25.300 --> 06:26.300
那么这个东西呢

06:26.300 --> 06:27.300
在使用的时候呢

06:27.300 --> 06:28.300
你注意一下

06:29.300 --> 06:31.300
是不是针对附容器居中了

06:31.300 --> 06:32.300
附容器只有这么高

06:32.300 --> 06:34.300
那么怎么来切换显示隐藏呢

06:34.300 --> 06:36.300
因为他不能永远显示这个玩意吧

06:36.300 --> 06:37.300
怎么来切换显示隐藏呢

06:37.300 --> 06:38.300
其实非常简单啊

06:38.300 --> 06:39.300
你在这边呢

06:39.300 --> 06:40.300
就可以用这种方式

06:40.300 --> 06:42.300
你给他订一个数据呗

06:42.300 --> 06:44.300
数据呢有一个

06:44.300 --> 06:48.580
node

06:48.580 --> 06:49.580
或者叫esnode

06:49.580 --> 06:51.580
是否正在夹载中

06:51.580 --> 06:52.580
默认的是tuma

06:52.580 --> 06:53.580
正在夹载中

06:53.580 --> 06:55.580
那么点击按钮过后呢

06:55.580 --> 06:56.580
就把切换呗

06:56.580 --> 06:57.580
切换这个值

06:57.580 --> 06:58.580
click

06:58.580 --> 06:59.580
esnode

06:59.580 --> 07:00.580
等于

07:00.580 --> 07:01.580
esnode

07:01.580 --> 07:02.580
不就完了吗

07:03.580 --> 07:04.580
然后呢

07:04.580 --> 07:05.580
这边呢

07:05.580 --> 07:06.580
这个node组件显示隐藏

07:06.580 --> 07:07.580
给他加一个vif

07:07.580 --> 07:08.580
或者是vshow都行

07:08.580 --> 07:09.580
我们这里呢

07:09.580 --> 07:10.580
因为vif

07:10.580 --> 07:11.580
因为node的效果呢

07:11.580 --> 07:12.580
他也不会频繁了

07:12.580 --> 07:13.580
切来切去

07:13.580 --> 07:14.580
这里呢

07:14.580 --> 07:16.580
是否正在夹载中

07:16.580 --> 07:17.580
如果说正在夹载中的话

07:17.580 --> 07:19.580
我们给他显示个组件

07:19.580 --> 07:20.580
那你开始来显示

07:20.580 --> 07:21.580
对吧

07:21.580 --> 07:22.580
点击过去显示隐藏

07:22.580 --> 07:23.580
显示

07:23.580 --> 07:24.580
这不特别简单啊

07:24.580 --> 07:26.580
这个组件就其实就做出来了

07:27.580 --> 07:28.580
那么这里呢

07:28.580 --> 07:30.580
有一个小的地方我说一下啊

07:30.580 --> 07:31.580
你看我在这个loading

07:31.580 --> 07:32.580
组件里边的

07:32.580 --> 07:33.580
这是一个新知识

07:33.580 --> 07:34.580
这loading

07:34.580 --> 07:35.580
组件里边呢

07:35.580 --> 07:36.580
我们用了这个路径

07:36.580 --> 07:37.580
这个路径呢

07:37.580 --> 07:38.580
是相对于我们的工程路径

07:38.580 --> 07:39.580
对吧

07:39.580 --> 07:41.580
相对于我们的元代码路径

07:41.580 --> 07:42.580
元代码路径

07:42.580 --> 07:43.580
相对于src目录

07:43.580 --> 07:44.580
下面的ss文件

07:44.580 --> 07:45.580
下面的这个

07:45.580 --> 07:46.580
呃

07:46.580 --> 07:47.580
支援

07:48.580 --> 07:49.580
那么像这种支援呢

07:49.580 --> 07:51.580
会有一个什么样的问题呢

07:51.580 --> 07:53.580
一旦打包完成过后

07:53.580 --> 07:54.580
还有这样的路径吗

07:55.580 --> 07:56.580
还有吗

07:56.580 --> 07:57.580
来试一下吧

07:57.580 --> 07:58.580
打包完成

07:58.580 --> 07:59.580
我们把停止啊

07:59.580 --> 08:00.580
npm装备

08:01.580 --> 08:02.580
打包

08:03.580 --> 08:04.580
就最终

08:04.580 --> 08:06.580
因为我们现在是在开发阶段吧

08:06.580 --> 08:07.580
打包呢

08:07.580 --> 08:08.580
是在内存里边打包的

08:08.580 --> 08:10.580
它并没有形成一个打包的结果

08:10.580 --> 08:11.580
那么如果说我们要部署的时候

08:11.580 --> 08:12.580
肯定要打包的

08:12.580 --> 08:13.580
那打包完成过后

08:13.580 --> 08:14.580
你看一下还有什么

08:14.580 --> 08:15.580
rc目录吗

08:15.580 --> 08:16.580
说都没了

08:16.580 --> 08:17.580
哪有rc目录啊

08:18.580 --> 08:19.580
说都没了

08:19.580 --> 08:20.580
那么

08:20.580 --> 08:21.580
那么现在问题就是

08:21.580 --> 08:23.580
那这个文件在哪去了呢

08:23.580 --> 08:24.580
那打包完成过

08:24.580 --> 08:25.580
还有还有这个文件吗

08:26.580 --> 08:27.580
实际上呢

08:27.580 --> 08:29.580
我们在开发阶段啊

08:29.580 --> 08:30.580
我们仔细观察一下

08:30.580 --> 08:31.580
它这个

08:31.580 --> 08:33.580
出来过后的图片路径是什么

08:34.580 --> 08:35.580
观察一下

08:35.580 --> 08:36.580
你看

08:36.580 --> 08:37.580
出来的图片路径

08:37.580 --> 08:38.580
它就不再是

08:39.580 --> 08:40.580
rc目录了

08:40.580 --> 08:41.580
它变成了这个路径

08:42.580 --> 08:44.580
就打包完成之后的路径

08:44.580 --> 08:45.580
明白了这个意思吗

08:45.580 --> 08:46.580
也就是说

08:46.580 --> 08:47.580
它这一个路径

08:47.580 --> 08:48.580
它会给你自动处理

08:48.580 --> 08:50.580
就你写的静态路径

08:50.580 --> 08:51.580
它会给你自动处理

08:51.580 --> 08:52.580
你写的是相对于

08:52.580 --> 08:54.580
原代码工程的路径

08:54.580 --> 08:55.580
但是呢

08:55.580 --> 08:56.580
实际上运行的时候

08:56.580 --> 08:58.580
它已经给你变成了

08:58.580 --> 08:59.580
最终的路径

09:00.580 --> 09:01.580
它会自动处理

09:01.580 --> 09:02.580
不用管

09:02.580 --> 09:03.580
但是大家要心里边

09:03.580 --> 09:04.580
要知道

09:04.580 --> 09:05.580
这个并不是最终的路径

09:05.580 --> 09:06.580
最终路径了

09:06.580 --> 09:07.580
它会给你按照打包结果

09:07.580 --> 09:08.580
给你变化

09:09.580 --> 09:10.580
那有同学可能想问的

09:10.580 --> 09:11.580
刚才打包结果里边

09:11.580 --> 09:12.580
为什么又看不到

09:12.580 --> 09:13.580
这个amg文件夹了

09:14.580 --> 09:16.580
是因为我们刚才的开发阶段

09:16.580 --> 09:17.580
开发阶段

09:17.580 --> 09:18.580
它给你做了这样的处理

09:18.580 --> 09:19.580
但是在部署的时候呢

09:19.580 --> 09:21.580
他发现这个图片的文件很小

09:22.580 --> 09:23.580
图片的文件很小

09:23.580 --> 09:24.580
它会怎么样呢

09:24.580 --> 09:26.580
它会把它做成一个data

09:26.580 --> 09:27.580
bass64

09:27.580 --> 09:29.580
它可以做成一个bass64

09:30.580 --> 09:31.580
数据

09:31.580 --> 09:32.580
只这么一个意思

09:33.580 --> 09:35.580
它会用内联的方式完成

09:35.580 --> 09:36.580
它并不给你形成一个文件

09:36.580 --> 09:37.580
这个其实你们在

09:37.580 --> 09:38.580
vipag的学习的过程中

09:38.580 --> 09:39.580
也知道

09:39.580 --> 09:40.580
有一个什么url

09:40.580 --> 09:41.580
loader

09:41.580 --> 09:42.580
有一个fileloader

09:42.580 --> 09:43.580
对吧

09:43.580 --> 09:44.580
根据情况

09:44.580 --> 09:45.580
它自行选择

09:45.580 --> 09:46.580
好

09:46.580 --> 09:47.580
那么就是这一块

09:48.580 --> 09:49.580
但是这一块

09:49.580 --> 09:50.580
再顺便多说两句吧

09:50.580 --> 09:52.580
那如果说你这个数据

09:52.580 --> 09:55.580
它不是静态的

09:55.580 --> 09:56.580
它是一个动态

09:57.580 --> 09:58.580
我们还是在test里边

09:58.580 --> 09:59.580
来写一个

10:00.580 --> 10:01.580
顺便说到这了

10:01.580 --> 10:02.580
就顺便说一下

10:03.580 --> 10:04.580
比方说这个数据

10:04.580 --> 10:05.580
哪有一个data

10:05.580 --> 10:06.580
data里面有一个

10:08.580 --> 10:09.580
图片路径

10:09.580 --> 10:10.580
loadingurl

10:10.580 --> 10:11.580
那么这个时候

10:11.580 --> 10:13.580
我们写上一个sys

10:13.580 --> 10:14.580
loading

10:14.580 --> 10:15.580
svg

10:16.580 --> 10:17.580
那么我们把loadingurl

10:17.580 --> 10:18.580
放到这

10:18.580 --> 10:19.580
那这样子行不行

10:20.580 --> 10:21.580
保存

10:22.580 --> 10:23.580
你看一样

10:23.580 --> 10:24.580
刷新

10:31.000 --> 10:32.000
这个

10:32.000 --> 10:33.000
重新运行

10:34.000 --> 10:35.000
错了

10:35.000 --> 10:36.000
重新运行一下

10:36.000 --> 10:41.060
好

10:41.060 --> 10:42.060
然后我们刷新

10:42.060 --> 10:44.060
一会发现图片不见了

10:44.060 --> 10:45.060
它的sys路径

10:45.060 --> 10:46.060
它并没有给你进行转移了

10:46.060 --> 10:47.060
对吧

10:47.060 --> 10:49.060
并没有给你转换成真实的路径了

10:49.060 --> 10:50.060
它还是用了

10:50.060 --> 10:51.060
缘分不动的用了之前的字

10:51.060 --> 10:52.060
那么这是为什么呢

10:52.060 --> 10:53.060
是因为你来自于

10:53.060 --> 10:54.060
动态那种的话

10:54.060 --> 10:55.060
不是静态的话

10:55.060 --> 10:56.060
它分析模办的时候

10:56.060 --> 10:57.060
它就分析不出来

10:57.060 --> 10:58.060
因为分析模办的时候

10:58.060 --> 10:59.060
打包的时候

10:59.060 --> 11:00.060
它还没有运行这个代码

11:00.060 --> 11:01.060
没有运行这个代码

11:01.060 --> 11:02.060
它只知道来自于

11:02.060 --> 11:03.060
这个辨量

11:03.060 --> 11:04.060
它并不知道这个辨量的直式上

11:04.060 --> 11:05.060
它就不知道

11:05.060 --> 11:07.060
它就没法进行分析

11:07.060 --> 11:08.060
就跟我们之前

11:08.060 --> 11:09.060
banner的一个图片

11:09.060 --> 11:10.060
是不是一样的

11:10.060 --> 11:11.060
就是我们首页不是有个band

11:11.060 --> 11:12.060
banner的图片

11:12.060 --> 11:13.060
什么来自于服务器

11:13.060 --> 11:14.060
来自于动态的数据

11:14.060 --> 11:15.060
那么这动态的数据

11:15.060 --> 11:17.060
它是无法进行分析的

11:17.060 --> 11:18.060
是这么一个意识

11:18.060 --> 11:19.060
那么像这种情况

11:19.060 --> 11:20.060
如果说

11:21.060 --> 11:22.060
遇到一些特殊情况

11:22.060 --> 11:24.060
明明是静态的资源

11:24.060 --> 11:26.060
我还是得把它写成一个数据

11:26.060 --> 11:27.060
那如果说遇到这种情况

11:27.060 --> 11:28.060
怎么办呢

11:28.060 --> 11:30.060
回忆一下webpack

11:30.060 --> 11:31.060
webpack里面怎么做的

11:31.060 --> 11:33.060
说是不是利用file load

11:33.060 --> 11:34.060
对不对

11:34.060 --> 11:36.060
那你直接导入静态资源

11:36.060 --> 11:37.060
loading url

11:37.060 --> 11:38.060
from

11:38.060 --> 11:40.060
来自于哪儿呢

11:40.060 --> 11:41.060
resets

11:41.060 --> 11:43.060
来自于loading

11:43.060 --> 11:45.060
svg

11:45.060 --> 11:47.060
那么把这个数据放在这

11:47.060 --> 11:48.060
那么这个数据

11:48.060 --> 11:49.060
实际上就是

11:49.060 --> 11:51.060
已经打包好的一个图片

11:51.060 --> 11:52.060
好保存啊

11:52.060 --> 11:54.060
你现在看一下是不是又出来了

11:54.060 --> 11:55.060
对不对

11:55.060 --> 11:57.060
这中间是哈西兹

11:57.060 --> 11:58.060
没问题吧

11:58.060 --> 11:59.060
好好的去梳理一下

11:59.060 --> 12:00.060
有的这里是静态的

12:00.060 --> 12:02.060
它在分析这个模板的时候

12:02.060 --> 12:03.060
它知道原来这里

12:03.060 --> 12:05.060
引用了一代的一个资源

12:05.060 --> 12:06.060
对吧

12:06.060 --> 12:07.060
对其他资源将webpack里面

12:07.060 --> 12:09.060
对其他的资源有依赖

12:09.060 --> 12:10.060
那么这个时候

12:10.060 --> 12:11.060
它会导入静态

12:11.060 --> 12:12.060
它会给你变成一个

12:12.060 --> 12:14.060
打包之后的动机

12:14.060 --> 12:16.060
那如果说你不是静态的

12:16.060 --> 12:17.060
是动态的

12:17.060 --> 12:18.060
动态的数据

12:18.060 --> 12:19.060
你要用这种方式

12:19.060 --> 12:20.060
其实这个玩意

12:20.060 --> 12:21.060
跟595没有什么关系

12:21.060 --> 12:22.060
跟595一毛钱关系没有

12:22.060 --> 12:24.060
这些都是webpack的功能

12:24.060 --> 12:26.060
是fireload的功能

12:26.060 --> 12:28.060
好了就这里说到这

12:28.060 --> 12:29.060
那么这个图片做好了

12:29.060 --> 12:31.060
它具体的在我们的

12:31.060 --> 12:32.060
页面上怎么用呢

12:32.060 --> 12:34.060
其实特别简单的

12:34.060 --> 12:35.060
页面上咋用啊

12:35.060 --> 12:36.060
这个DIV

12:36.060 --> 12:38.060
它一个内央是home content

12:38.060 --> 12:39.060
刚才他们说了

12:39.060 --> 12:41.060
这个DIV最好是一个

12:41.060 --> 12:42.060
相对定位

12:42.060 --> 12:43.060
因为它里面

12:43.060 --> 12:45.060
要放一个决定定位的楼顶

12:45.060 --> 12:46.060
pracing relative

12:46.060 --> 12:47.060
没问题

12:47.060 --> 12:48.060
相对定位的

12:48.060 --> 12:49.060
那么接下来

12:49.060 --> 12:50.060
无非就在这里呢

12:50.060 --> 12:51.060
放一个楼顶主件就完了

12:51.060 --> 12:52.060
你看啊

12:53.060 --> 12:54.060
楼顶主件

12:54.060 --> 12:55.060
放这

12:55.060 --> 12:56.060
component

12:58.820 --> 12:59.820
楼顶

13:00.820 --> 13:02.820
楼顶主件的注册进来

13:03.820 --> 13:04.820
同样的道理呢

13:04.820 --> 13:05.820
data里面

13:05.820 --> 13:06.820
我们需要提供一个数据

13:06.820 --> 13:07.820
叫做意思楼顶

13:07.820 --> 13:08.820
是否正在夹载中

13:08.820 --> 13:09.820
意思楼顶

13:09.820 --> 13:11.820
默认就一为初嘛

13:11.820 --> 13:12.820
因为一开始

13:12.820 --> 13:13.820
正在夹载中嘛

13:13.820 --> 13:14.820
对不对

13:14.820 --> 13:15.820
默认为q

13:15.820 --> 13:16.820
什么是vforce呢

13:16.820 --> 13:17.820
就是当我们数据拿到之后

13:17.820 --> 13:18.820
把它变成force

13:18.820 --> 13:19.820
意思楼顶

13:20.820 --> 13:21.820
这数据有了

13:21.820 --> 13:22.820
楼顶主件有了

13:22.820 --> 13:23.820
数据有了

13:23.820 --> 13:24.820
那我们根据数据来

13:24.820 --> 13:25.820
显示个楼顶主件就完了

13:25.820 --> 13:26.820
楼顶主件随便放一个地方

13:26.820 --> 13:27.820
它反正决定定位嘛

13:27.820 --> 13:29.820
楼顶主件放这

13:29.820 --> 13:30.820
vif

13:30.820 --> 13:32.820
什么情况要显示个楼顶主件呢

13:32.820 --> 13:33.820
是不是就是

13:34.820 --> 13:35.820
意思楼顶的时候

13:35.820 --> 13:36.820
对不对

13:36.820 --> 13:37.820
那什么时候不显示呢

13:37.820 --> 13:39.820
一楼顶为force的时候就不显示

13:39.820 --> 13:40.820
都去写完了

13:40.820 --> 13:41.820
好

13:41.820 --> 13:42.820
咱们再看一下啊

13:42.820 --> 13:43.820
有没有时间的效果

13:43.820 --> 13:44.820
刷新

13:44.820 --> 13:46.820
你看是不是一开始在夹载

13:46.820 --> 13:47.820
要十多二十秒的太长了

13:47.820 --> 13:50.820
我们把时间稍微有改回来啊

13:51.820 --> 13:52.820
index

13:52.820 --> 13:53.820
改成一到两秒

13:56.390 --> 13:57.390
刷新

13:57.390 --> 13:59.390
你看是不是好了

13:59.390 --> 14:00.390
刷新

14:01.390 --> 14:02.390
就好了对不对

14:02.390 --> 14:04.390
这是最简单

14:04.390 --> 14:06.390
来实现楼顶主件的效果

14:06.390 --> 14:08.390
而其实像我们这个

14:08.390 --> 14:11.390
简单的个人博客项目

14:11.390 --> 14:13.390
用这个东西就完全够了

14:13.390 --> 14:15.390
完全完全够了

14:15.390 --> 14:16.390
但是呢

14:16.390 --> 14:18.390
如果说以后遇到了一些复杂的项目

14:18.390 --> 14:20.390
像那种类似的东西

14:20.390 --> 14:22.390
主件做的非常简单

14:22.390 --> 14:25.390
关键是拥的地方特别特别多

14:25.390 --> 14:26.390
那你看如果说

14:26.390 --> 14:28.390
假设我们有

14:28.390 --> 14:29.390
30个页面

14:29.390 --> 14:31.390
不说30个页面吧

14:31.390 --> 14:32.390
有100个主件

14:32.390 --> 14:35.390
这100个主件都要依赖这个楼顶

14:35.390 --> 14:37.390
那么我们在写着100个主件的时候

14:37.390 --> 14:39.390
是不是每一次都要去做这么三件事

14:39.390 --> 14:41.390
第一件事我要去做

14:41.390 --> 14:42.390
你倒入这个

14:42.390 --> 14:45.390
第二件事我要注册主件

14:45.390 --> 14:47.390
第三件事我要加入这个一支楼顶

14:47.390 --> 14:49.390
第四件事我要

14:49.390 --> 14:51.390
引用这个楼顶主件

14:51.390 --> 14:54.390
就是在主件中使用这个楼顶

14:54.390 --> 14:56.390
是不是特别麻烦了

14:56.390 --> 14:58.390
那如果说我希望有一天

14:58.390 --> 15:00.390
我不用主件的形式

15:00.390 --> 15:02.390
我用什么形式呢

15:02.390 --> 15:03.390
因为这个玩意呢

15:03.390 --> 15:04.390
因为这个功能太常见了

15:04.390 --> 15:07.390
我们用的地方特别特别多

15:07.390 --> 15:09.390
那如果说我不希望用主件的形式

15:09.390 --> 15:11.390
我希望用这种形式

15:11.390 --> 15:12.390
把这个地方保存一下

15:12.390 --> 15:14.390
加上你们可以下来看下代吧

15:14.390 --> 15:15.390
现在我们要用新的方式了

15:15.390 --> 15:18.390
我希望用指令的形式

15:18.390 --> 15:20.390
很神奇哦

15:20.390 --> 15:21.390
我们怎么来做呢

15:21.390 --> 15:22.390
我希望假设假设

15:22.390 --> 15:23.390
没有这个东西了

15:23.390 --> 15:24.390
也没有这个东西了

15:24.390 --> 15:26.390
也没有这个东西了

15:26.390 --> 15:28.390
这个一支楼顶都要保留

15:28.390 --> 15:29.390
这个数据要保留

15:29.390 --> 15:31.390
好 接下来我们希望这是

15:31.390 --> 15:32.390
什么情况下这个DIV里面

15:32.390 --> 15:33.390
有个楼顶效果呢

15:33.390 --> 15:36.390
我这里加上一个V楼顶

15:36.390 --> 15:38.390
等于一支楼顶

15:38.390 --> 15:40.390
这个楼顶回去的时候

15:40.390 --> 15:42.390
那么这个DIV就显示一个楼顶效果

15:42.390 --> 15:44.390
这个DIV内部

15:44.390 --> 15:46.390
如果说这个楼顶为Force的时候

15:46.390 --> 15:48.390
它就不显示

15:48.390 --> 15:50.390
这样做是不是方便很多啊

15:50.390 --> 15:51.390
对不对

15:51.390 --> 15:53.390
其实有些人说那也方便不了多少

15:53.390 --> 15:55.390
如果说你只有那么一两个主件

15:55.390 --> 15:57.390
使用到这个楼顶的话

15:57.390 --> 15:58.390
确实方便不了多少

15:58.390 --> 15:59.390
如果说你主件多了

15:59.390 --> 16:02.390
那这个玩意就比较方便

16:02.390 --> 16:03.390
明儿的意思吧

16:03.390 --> 16:04.390
所以说我们希望

16:04.390 --> 16:06.390
如果假设有这么一种形式

16:06.390 --> 16:07.390
那我们用起来更加方便

16:07.390 --> 16:08.390
但是实际上

16:08.390 --> 16:10.390
现在能不能实现呢

16:10.390 --> 16:12.390
现在肯定不能实现的

16:13.390 --> 16:14.390
所以啥效果都没有

16:14.390 --> 16:15.390
对不对

16:15.390 --> 16:16.390
他这里直接给你报错了

16:16.390 --> 16:19.390
他说无法识别指令楼顶

16:19.390 --> 16:21.390
因为我们知道V指令都是V横档开头

16:21.390 --> 16:23.390
特别是指令的名称

16:23.390 --> 16:25.390
他这个指令实际上是VU里面

16:25.390 --> 16:26.390
并不存在的

16:26.390 --> 16:28.390
他无法识别

16:28.390 --> 16:29.390
那么无法识别

16:29.390 --> 16:31.390
我们无非就是让他能够识别就完事了

16:31.390 --> 16:33.390
那怎么样让他能够识别呢

16:33.390 --> 16:34.390
其实就是制定你指令

16:34.390 --> 16:37.390
这是我们这一刻的主要内容

16:37.390 --> 16:38.390
我再说一次啊

16:38.390 --> 16:40.390
并不说必须的

16:40.390 --> 16:42.390
这些都是给我们提供了一个

16:42.390 --> 16:44.390
额外的选择

16:44.390 --> 16:46.390
可以让我们更加舒服的

16:46.390 --> 16:48.390
去使用一些常见的功能

16:48.390 --> 16:50.390
一些比较简单并且常见的功能

16:50.390 --> 16:52.390
并不说以后你们开发项目

16:52.390 --> 16:53.390
就一定会用的

16:53.390 --> 16:54.390
那不一定的

16:54.390 --> 16:57.390
我这里把这个知识介绍给大家

16:58.390 --> 17:00.390
好我们来看一下这个文档啊

17:00.390 --> 17:01.390
它并不复杂其实

17:01.390 --> 17:02.390
定义

17:02.390 --> 17:04.390
首先我们要做一个自定义指令

17:04.390 --> 17:06.390
那么我们首先就需要

17:06.390 --> 17:07.390
定义一个指令

17:07.390 --> 17:09.390
这个定义组件是一样的

17:09.390 --> 17:10.390
以前没有这个组件

17:10.390 --> 17:11.390
那么我给它定义一个组件

17:11.390 --> 17:12.390
定义指令呢

17:12.390 --> 17:14.390
分为权具定义和局部定义

17:14.390 --> 17:15.390
跟组件是不是类似

17:15.390 --> 17:16.390
什么叫权具定义呢

17:16.390 --> 17:17.390
就权具定义了之后呢

17:17.390 --> 17:19.390
这个指令到处都可以用了

17:19.390 --> 17:20.390
每个组件都可以用

17:20.390 --> 17:22.390
你看下权具定义怎么定义的

17:22.390 --> 17:23.390
直接使用

17:23.390 --> 17:24.390
唯有这个构造函数里面

17:24.390 --> 17:25.390
一个静态方法叫Directive

17:25.390 --> 17:26.390
什么意思呢

17:26.390 --> 17:27.390
就是指令的意思

17:27.390 --> 17:28.390
好给指令取个名字

17:28.390 --> 17:29.390
随便取个名字

17:29.390 --> 17:31.390
好后边是指令的一些配置

17:31.390 --> 17:33.390
配置我们之后再讲

17:33.390 --> 17:35.390
你看我这里定义了两个指令

17:35.390 --> 17:36.390
这里写错了

17:37.390 --> 17:38.390
定义了两个指令

17:41.390 --> 17:42.390
好然后呢下面

17:42.390 --> 17:43.390
我们怎么来用这个指令呢

17:43.390 --> 17:44.390
定义了指令过后呢

17:44.390 --> 17:45.390
你就可以直接使用了

17:45.390 --> 17:46.390
你看这个组件里边

17:46.390 --> 17:48.390
有一个V横杠

17:48.390 --> 17:49.390
这个就指令名称

17:49.390 --> 17:50.390
后边写上什么

17:50.390 --> 17:51.390
解释表达式

17:51.390 --> 17:54.390
指令后面跟的都是解释表达式

17:54.390 --> 17:55.390
那么这里也是一样

17:55.390 --> 17:56.390
可以用到任何地方

17:56.390 --> 17:57.390
可以用到组件里边

17:57.390 --> 17:58.390
可以用到DIV里边

17:58.390 --> 17:59.390
可以用到其他里面的数里边

17:59.390 --> 18:00.390
都可以

18:00.390 --> 18:02.390
那些指令看都可以使用了

18:02.390 --> 18:03.390
这就是权具注册

18:03.390 --> 18:04.390
权具注册使用起来

18:04.390 --> 18:05.390
确实很方便

18:05.390 --> 18:06.390
但是权具注册呢

18:06.390 --> 18:08.390
跟那个组件权具注册是一样的

18:09.390 --> 18:10.390
它会导致呢

18:10.390 --> 18:11.390
我们打包结果里边

18:11.390 --> 18:13.390
默认就会有这个东西

18:13.390 --> 18:14.390
那如果说你一开始

18:14.390 --> 18:15.390
打包结果里边

18:15.390 --> 18:16.390
就希望它有这个东西

18:16.390 --> 18:17.390
因为它太常见了

18:17.390 --> 18:18.390
那OK

18:18.390 --> 18:19.390
那就把它作为权具指令

18:19.390 --> 18:20.390
没有什么打不了的

18:21.390 --> 18:22.390
那如果说有的时候呢

18:22.390 --> 18:23.390
我并不是每一个

18:23.390 --> 18:24.390
主点都会用

18:24.390 --> 18:25.390
我也不希望打包结果

18:25.390 --> 18:26.390
默认就有这个东西

18:26.390 --> 18:27.390
我希望了

18:27.390 --> 18:28.390
要用到某个组件

18:28.390 --> 18:29.390
那个组件要用到

18:29.390 --> 18:30.390
这个指令指令的时候呢

18:30.390 --> 18:32.390
打包结果才会有

18:32.390 --> 18:33.390
那么这个时候

18:33.390 --> 18:34.390
你可以用进行

18:34.390 --> 18:35.390
举一步定义

18:36.390 --> 18:37.390
举一步定义跟那个

18:37.390 --> 18:38.390
组件是类似的

18:38.390 --> 18:39.390
怎么来定义呢

18:39.390 --> 18:40.390
你看我在某个

18:40.390 --> 18:41.390
组件代码里边

18:41.390 --> 18:43.390
我使用了这两个指令

18:44.390 --> 18:45.390
那么这两个指令呢

18:45.390 --> 18:46.390
并不是权具注册的

18:47.390 --> 18:48.390
我只希望在这个

18:48.390 --> 18:49.390
组件里边使用

18:49.390 --> 18:50.390
别的组件就用不了了

18:50.390 --> 18:51.390
那怎么用呢

18:51.390 --> 18:52.390
弄了

18:52.390 --> 18:53.390
我们在这个组件里边

18:53.390 --> 18:54.390
就可以硬硬配置

18:54.390 --> 18:55.390
Directives

18:55.390 --> 18:57.390
一个复述形式

18:57.390 --> 18:59.390
跟那个组件是不一样的

18:59.390 --> 19:00.390
组件是不是也要配置

19:00.390 --> 19:01.390
Components

19:01.390 --> 19:02.390
对吧

19:02.390 --> 19:03.390
那么这里也是

19:03.390 --> 19:04.390
举一步注册指令

19:05.390 --> 19:06.390
那么这里的指令名称

19:06.390 --> 19:07.390
就是属性名

19:07.390 --> 19:08.390
跟那个组件是不是一样的

19:08.390 --> 19:10.390
然后指令的值呢

19:10.390 --> 19:11.390
就是一个配置对象

19:11.390 --> 19:12.390
那组件的值

19:12.390 --> 19:13.390
是不是一个配置对象

19:13.390 --> 19:14.390
我们之前在组件

19:14.390 --> 19:15.390
你看这个

19:15.390 --> 19:16.390
组件的属性名

19:16.390 --> 19:17.390
属性值

19:17.390 --> 19:18.390
这个是不是一个配置对象

19:18.390 --> 19:19.390
是一样的

19:19.390 --> 19:20.390
你看

19:20.390 --> 19:21.390
那么这样子

19:21.390 --> 19:22.390
只能在这个

19:22.390 --> 19:23.390
组件里边使用指令

19:23.390 --> 19:24.390
两种方式都可以

19:24.390 --> 19:25.390
那我们这里

19:25.390 --> 19:26.390
用啥

19:26.390 --> 19:27.390
权具定义还是

19:27.390 --> 19:28.390
绝不定义

19:28.390 --> 19:29.390
其实都行

19:29.390 --> 19:30.390
权具也行

19:30.390 --> 19:31.390
因为这个指令

19:32.390 --> 19:33.390
首先代码不多

19:33.390 --> 19:34.390
它进入到打包结果

19:34.390 --> 19:35.390
也无所谓

19:35.390 --> 19:36.390
另外本身

19:36.390 --> 19:37.390
一面一开始的时候

19:37.390 --> 19:38.390
就需要用到它

19:38.390 --> 19:39.390
所以说

19:39.390 --> 19:40.390
你可以把它弄成

19:40.390 --> 19:41.390
权具定义

19:41.390 --> 19:42.390
也可以用成

19:42.390 --> 19:43.390
绝不定义都行

19:44.390 --> 19:45.390
那么比方说

19:45.390 --> 19:46.390
我们这里的

19:46.390 --> 19:48.390
就做一个权具定义的组件

19:48.390 --> 19:49.390
权具定义的指令

19:49.390 --> 19:50.390
那怎么来写

19:50.390 --> 19:51.390
权具定义的指令呢

19:51.390 --> 19:52.390
首先

19:52.390 --> 19:53.390
用新建议文件夹

19:53.390 --> 19:54.390
把它分门别类的

19:54.390 --> 19:55.390
安放到

19:55.390 --> 19:56.390
我们的原代码的

19:56.390 --> 19:57.390
各种位置

19:57.390 --> 19:58.390
给它写上一个Directive

19:59.390 --> 20:00.390
这里边

20:00.390 --> 20:01.390
我们专门来放一些

20:01.390 --> 20:02.390
制定义指令

20:02.390 --> 20:03.390
好

20:03.390 --> 20:04.390
我们这里首先要做一个

20:04.390 --> 20:05.390
制定义指令叫做Vloading

20:05.390 --> 20:06.390
对吧

20:06.390 --> 20:07.390
名字叫做loading

20:07.390 --> 20:08.390
叫介石

20:09.390 --> 20:10.390
这是个制定义指令

20:10.390 --> 20:11.390
这个制定义指令

20:11.390 --> 20:12.390
实际上是什么呢

20:12.390 --> 20:13.390
实际上就是个配置对象

20:13.390 --> 20:15.390
跟那个组件是一样的

20:15.390 --> 20:17.390
它不是一个无语模办的

20:17.390 --> 20:18.390
它是个配置对象

20:18.390 --> 20:19.390
export

20:19.390 --> 20:20.390
default

20:20.390 --> 20:21.390
就是个配置对象

20:21.390 --> 20:23.390
就是导出指令的配置对象

20:23.390 --> 20:27.390
导出指令的配置对象

20:27.390 --> 20:28.390
配置对象里面写上

20:28.390 --> 20:29.390
我们之后再说

20:29.390 --> 20:30.390
好

20:30.390 --> 20:31.390
那么我们现在要

20:31.390 --> 20:32.390
全局注册它

20:32.390 --> 20:33.390
怎么来全局注册呢

20:33.390 --> 20:34.390
我们到媒体监视里面去

20:34.390 --> 20:35.390
那么这里我可以

20:35.390 --> 20:36.390
给它注册一些指令

20:36.390 --> 20:38.390
注册指令

20:38.390 --> 20:40.390
全局指令

20:40.390 --> 20:41.390
好

20:41.390 --> 20:42.390
怎么来注册呢

20:42.390 --> 20:43.390
就用vio

20:43.390 --> 20:45.390
Directive

20:45.390 --> 20:46.390
指令的名字

20:46.390 --> 20:48.390
名字的就该取个loading吧

20:48.390 --> 20:49.390
刚也可以取别的名字

20:49.390 --> 20:50.390
它并不是说

20:50.390 --> 20:51.390
这个文件名

20:51.390 --> 20:52.390
就是指令的名字

20:52.390 --> 20:53.390
不是的

20:53.390 --> 20:54.390
也是这里的名字

20:54.390 --> 20:55.390
好

20:55.390 --> 20:56.390
那么这个指令的

20:56.390 --> 20:57.390
配置对象呢

20:57.390 --> 20:59.390
就用这个loading

20:59.390 --> 21:00.390
导入进来吧

21:00.390 --> 21:03.390
import

21:03.390 --> 21:04.390
回家个v吧

21:04.390 --> 21:06.390
一个秘密规范

21:06.390 --> 21:07.390
下个v

21:07.390 --> 21:10.390
from directives

21:10.390 --> 21:12.390
loading

21:12.390 --> 21:13.390
下个v

21:13.390 --> 21:14.390
就是它的配置对象

21:14.390 --> 21:15.390
指令的名字

21:15.390 --> 21:16.390
好

21:16.390 --> 21:17.390
那么这样就注册了

21:17.390 --> 21:18.390
一个全局指令的

21:18.390 --> 21:19.390
那么这个全局指令

21:19.390 --> 21:20.390
我们是不是可以在

21:20.390 --> 21:21.390
这里可以使用了

21:21.390 --> 21:22.390
对吧

21:22.390 --> 21:23.390
再加上一个vloading

21:23.390 --> 21:24.390
你看现在还爆错吗

21:26.900 --> 21:27.900
这边刷新

21:27.900 --> 21:30.590
是不是没有爆错了

21:30.590 --> 21:31.590
它指令已经能识别了

21:31.590 --> 21:32.590
只不过这个指令

21:32.590 --> 21:33.590
没有什么功能

21:33.590 --> 21:34.590
啥效果都没有

21:34.590 --> 21:35.590
为啥没效果了

21:35.590 --> 21:36.590
因为你没有做效果

21:36.590 --> 21:37.590
对吧

21:37.590 --> 21:38.590
一个指令要实现啥功能

21:38.590 --> 21:39.590
它并不知道

21:39.590 --> 21:41.590
然后指令是已经能够识别了

21:41.590 --> 21:42.590
好了

21:42.590 --> 21:43.590
这是指令的定义

21:44.590 --> 21:45.590
接下来我们就要

21:45.590 --> 21:46.590
终点研究这个指令的

21:46.590 --> 21:47.590
配置对象了

21:47.590 --> 21:49.590
就指令里边到底配置啥

21:49.590 --> 21:50.590
就这里边

21:50.590 --> 21:51.590
loading.js里边

21:51.590 --> 21:52.590
它到底写哪些配置

21:52.590 --> 21:54.590
就这里边配置的是什么呢

21:54.590 --> 21:56.590
配置的是一些钩子函数

21:56.590 --> 21:57.590
所以钩子函数

21:57.590 --> 21:58.590
你看你学那个

21:58.590 --> 21:59.590
组建的生命周期

21:59.590 --> 22:00.590
不是一些钩子函数吗

22:00.590 --> 22:01.590
created

22:01.590 --> 22:02.590
amounted

22:02.590 --> 22:04.590
还什么updated

22:04.590 --> 22:05.590
都有一些钩子函数

22:05.590 --> 22:06.590
那么指令

22:06.590 --> 22:07.590
它也有一些钩子函数

22:07.590 --> 22:09.590
这钩子函数有5个

22:09.590 --> 22:10.590
我记得是有5个

22:10.590 --> 22:11.590
不过我们常用的

22:11.590 --> 22:13.590
没有那么一些

22:13.590 --> 22:15.590
只用了这么3个比较常用的

22:15.590 --> 22:16.590
一个是band

22:16.590 --> 22:17.590
这个钩子函数

22:17.590 --> 22:19.590
它只会调用一次

22:20.590 --> 22:21.590
什么时候调用呢

22:21.590 --> 22:22.590
我们指令不是

22:22.590 --> 22:24.590
绑定到元素上面的吧

22:24.590 --> 22:25.590
对不对

22:25.590 --> 22:27.590
指令是会放到元素上面的

22:27.590 --> 22:28.590
那么这个放到

22:28.590 --> 22:29.590
绑定到元素

22:29.590 --> 22:31.590
这个为了在分析

22:31.590 --> 22:33.590
我们的Vload

22:33.590 --> 22:34.590
发现一个其中一个Vload

22:34.590 --> 22:35.590
有一个指令

22:35.590 --> 22:36.590
那么它会把指令

22:36.590 --> 22:37.590
绑定到这个元素

22:37.590 --> 22:38.590
那么这个时候

22:38.590 --> 22:40.590
它就会调用这个band的方法

22:40.590 --> 22:41.590
好,什么叫inserted呢

22:41.590 --> 22:43.590
我们这里输出一下

22:43.590 --> 22:44.590
band

22:44.590 --> 22:46.590
还有一个inserted

22:46.590 --> 22:47.590
这个时候

22:47.590 --> 22:48.590
什么时候执行了

22:48.590 --> 22:49.590
这个钩子函数

22:49.590 --> 22:50.590
它是指令

22:50.590 --> 22:52.590
指令比方绑定到这个元素

22:52.590 --> 22:53.590
这个元素是不是

22:53.590 --> 22:54.590
还有复元素

22:55.590 --> 22:56.590
复元素是啥

22:56.590 --> 22:58.590
复元素是不是商业副组建

22:58.590 --> 22:59.590
这个home的副组建

22:59.590 --> 23:00.590
home的副组建是啥

23:00.590 --> 23:02.590
是不是Rotov-U

23:02.590 --> 23:04.590
所以它里面在渲染home的组建

23:04.590 --> 23:05.590
所以它的副组建

23:05.590 --> 23:06.590
它绑定到副组建的时候

23:06.590 --> 23:07.590
就是把它

23:07.590 --> 23:08.590
把这个元素

23:08.590 --> 23:10.590
插入到副元素里面的时候

23:10.590 --> 23:12.590
都是真实的动物操作

23:12.590 --> 23:13.590
全是真实的动物操作

23:13.590 --> 23:14.590
我们把这个元素

23:14.590 --> 23:17.590
放到副元素的指令里面去

23:17.590 --> 23:18.590
那么这个时候

23:18.590 --> 23:19.590
它会触发这个inserted

23:19.590 --> 23:20.590
所以它的运行过程

23:20.590 --> 23:21.590
应该是先运行band

23:21.590 --> 23:23.590
再运行inserted

23:24.590 --> 23:26.590
后边还有什么呢

23:26.590 --> 23:27.590
还有就是update

23:27.590 --> 23:29.590
update就是我们的

23:29.590 --> 23:31.590
蓄力节点更新了

23:31.590 --> 23:33.590
就我们这个玩意更新了

23:33.590 --> 23:34.590
你看数据变化和思路

23:34.590 --> 23:35.590
也导致它更新

23:35.590 --> 23:36.590
对不对

23:36.590 --> 23:37.590
它更新了过后

23:37.590 --> 23:39.590
那么它会运行update

23:39.590 --> 23:41.590
那么输出一下update

23:41.590 --> 23:43.590
好,咱们来看一下吧

23:43.590 --> 23:46.540
控制台里面

23:46.540 --> 23:48.540
所以已经输出了band

23:48.540 --> 23:49.540
inserted

23:49.540 --> 23:51.540
输出了两次update

23:51.540 --> 23:53.540
为什么会输出两次呢

23:53.540 --> 23:55.540
是因为最开始的时候

23:55.540 --> 23:56.540
最开始的时候

23:56.540 --> 23:58.540
那么输出了一次

23:58.540 --> 24:00.540
它数据有变化

24:00.540 --> 24:01.540
对吧,数据一开始

24:01.540 --> 24:02.540
该绑定的数据

24:02.540 --> 24:04.540
输出了一次update的

24:04.540 --> 24:05.540
好,然后后边数据是不是变了

24:05.540 --> 24:07.540
这个is loading变成force

24:07.540 --> 24:08.540
对不对,那么这个时候

24:08.540 --> 24:09.540
又会输出

24:09.540 --> 24:11.540
又会触发update的

24:11.540 --> 24:12.540
那么这是指令的

24:12.540 --> 24:14.540
这个三个勾字函数

24:14.540 --> 24:15.540
其实我们最常见的

24:15.540 --> 24:17.540
用了最多的一个是band

24:17.540 --> 24:19.540
一个是inserted

24:19.540 --> 24:22.540
这是这个指令

24:22.540 --> 24:24.540
配置对象

24:24.540 --> 24:26.540
还用更多的勾字函数

24:26.540 --> 24:27.540
大家可以看一下

24:27.540 --> 24:28.540
参与一下官方文档

24:28.540 --> 24:30.540
它其实还有这个

24:30.540 --> 24:31.540
你们可以参与一下

24:31.540 --> 24:33.540
都挺简单

24:33.540 --> 24:35.540
好,这是指令的配置

24:35.540 --> 24:36.540
配置为函数

24:36.540 --> 24:38.540
那么这个函数里边

24:38.540 --> 24:39.540
触发了函数

24:39.540 --> 24:40.540
它能做啥呢

24:40.540 --> 24:42.540
这里要说到另外一个问题

24:42.540 --> 24:43.540
就是它每一次

24:43.540 --> 24:45.540
调用函数的时候

24:45.540 --> 24:47.540
实际上给它传递的两个参数

24:47.540 --> 24:48.540
实际上不止两个参数

24:48.540 --> 24:50.540
实际上是四个参数

24:50.540 --> 24:51.540
只不过了后边两个参数

24:51.540 --> 24:52.540
我们不太用得到

24:52.540 --> 24:53.540
平时用的最多的

24:53.540 --> 24:54.540
就是前面两个参数

24:54.540 --> 24:56.540
第一个参数叫做eL

24:56.540 --> 24:57.540
也就是说这些里边

24:57.540 --> 24:59.540
都有两个参数

24:59.540 --> 25:01.540
eL,一个是band

25:01.540 --> 25:04.690
都有这两个参数

25:04.690 --> 25:05.690
都是一样的

25:05.690 --> 25:07.690
那么这个eL是啥呢

25:07.690 --> 25:08.690
这个eL就是

25:08.690 --> 25:10.690
绑定元素对应的

25:10.690 --> 25:12.690
真实的动物

25:12.690 --> 25:14.690
我们来输出一下这个eL

25:14.690 --> 25:16.690
可以看到很明白了

25:16.690 --> 25:22.590
输出一下

25:22.590 --> 25:24.590
以后我们再顺便输出一下band

25:24.590 --> 25:28.030
以后反正我们要看的

25:28.030 --> 25:29.030
好,保存啊

25:29.030 --> 25:30.030
看一下这边

25:30.030 --> 25:32.030
你看这个eL是不是就是DIV

25:32.030 --> 25:33.030
看到没

25:33.030 --> 25:35.030
这个eL就是DIV

25:35.030 --> 25:37.030
就是我们的真实的动物元素

25:37.030 --> 25:38.030
不是虚拟节点

25:38.030 --> 25:39.030
真实动物元素

25:39.030 --> 25:41.030
那么就可以用动物操作了

25:41.030 --> 25:43.030
你可以想象得到

25:43.030 --> 25:44.030
我们将来要做一个

25:44.030 --> 25:45.030
扭顶效果

25:45.030 --> 25:46.030
是不是在这里边加上一个

25:46.030 --> 25:47.030
图片

25:47.030 --> 25:48.030
这图片链接

25:48.030 --> 25:50.030
那个扭顶的那个图片文件

25:50.030 --> 25:52.030
可以夹到这个DIV里边去

25:52.030 --> 25:53.030
用原生的介石

25:53.030 --> 25:54.030
做一些扭顶效果

25:54.030 --> 25:55.030
当然也可以结合介块

25:55.030 --> 25:57.030
这里的操作很简单

25:57.030 --> 25:59.030
也用不到什么介块而已

25:59.030 --> 26:00.030
对不对,真实动物

26:00.030 --> 26:02.030
好,关键是另外一个对象

26:02.030 --> 26:03.030
叫band

26:03.030 --> 26:04.030
这个对象是

26:04.030 --> 26:05.030
这是一个对象

26:05.030 --> 26:09.030
这里边提供了一些指令的信息

26:09.030 --> 26:11.030
那么这个对象是什么样子呢

26:11.030 --> 26:12.030
往下看

26:12.030 --> 26:13.030
把这个图看弄了

26:13.030 --> 26:15.030
一下就明白了

26:15.030 --> 26:17.030
你看我们的指令是打写的

26:17.030 --> 26:19.030
微衡杠指令的名称

26:19.030 --> 26:21.030
然后完整写法

26:21.030 --> 26:22.030
帽号

26:22.030 --> 26:23.030
帽号后面跟指令的是什么

26:23.030 --> 26:24.030
跟的是什么

26:24.030 --> 26:26.030
跟的是指令参数

26:26.030 --> 26:28.030
这个见过没

26:28.030 --> 26:30.030
你什么情况下见过帽号的

26:30.030 --> 26:32.030
啥时候见过帽号的

26:32.030 --> 26:37.330
是不是注册时间啊

26:37.330 --> 26:39.330
指令名称叫on

26:39.330 --> 26:41.330
指令参数叫click

26:41.330 --> 26:43.330
看没

26:43.330 --> 26:44.330
是不是就见过这个东西

26:44.330 --> 26:45.330
见过帽号的

26:45.330 --> 26:46.330
没问题吧

26:46.330 --> 26:47.330
那么只不过呢

26:47.330 --> 26:48.330
平时写事件的时候

26:48.330 --> 26:49.330
我们用的是简写

26:49.330 --> 26:51.330
但是简写只是一个语法唐而已

26:51.330 --> 26:53.330
它完整的写法应该是这样子

26:53.330 --> 26:55.330
这叫指令参数

26:55.330 --> 26:57.330
指令参数只有一个

26:57.330 --> 26:58.330
那么像我们

26:58.330 --> 27:00.330
如果说你写个完整的指令的话

27:00.330 --> 27:01.330
那有可能是指令的名称

27:01.330 --> 27:02.330
加指令的参数

27:02.330 --> 27:03.330
当然有的人指令

27:03.330 --> 27:04.330
他没有参数

27:04.330 --> 27:05.330
那没有参数的话

27:05.330 --> 27:06.330
自然不用写了

27:06.330 --> 27:07.330
像我们刚才的V-loading指令

27:07.330 --> 27:08.330
有什么有参数吗

27:08.330 --> 27:09.330
没有参数

27:09.330 --> 27:11.330
没有参数就不用写了

27:11.330 --> 27:12.330
有没有参数呢

27:12.330 --> 27:13.330
是取决于你自己

27:13.330 --> 27:14.330
做了指令的时候

27:14.330 --> 27:15.330
要不要参数

27:15.330 --> 27:16.330
需要就写

27:16.330 --> 27:17.330
不需要就拿到

27:17.330 --> 27:18.330
这指令参数

27:18.330 --> 27:19.330
那么后边有可能还会写

27:19.330 --> 27:21.330
底耳啥底耳啥

27:21.330 --> 27:22.330
那么这个底耳啥底耳啥

27:22.330 --> 27:24.330
你们是没见过的

27:24.330 --> 27:25.330
那么这个底耳啥底耳啥

27:25.330 --> 27:29.330
叫做指令的修饰符

27:29.330 --> 27:30.330
指令修饰符

27:30.330 --> 27:31.330
只不过我们目前

27:31.330 --> 27:33.330
V-loading指令是没有写

27:33.330 --> 27:34.330
不需要

27:34.330 --> 27:35.330
如果说他写了

27:35.330 --> 27:37.330
那么比方说我现在写了

27:37.330 --> 27:38.330
这些信息

27:38.330 --> 27:39.330
就是都是指令信息

27:39.330 --> 27:40.330
比方说我们这里

27:40.330 --> 27:41.330
V-loading

27:41.330 --> 27:43.330
A B E C D

27:43.330 --> 27:44.330
多该写几个

27:44.330 --> 27:46.330
你看这个是参数

27:46.330 --> 27:48.330
后边三个是修饰符

27:48.330 --> 27:49.330
也可以没有参数

27:49.330 --> 27:50.330
没有参数的话

27:50.330 --> 27:51.330
就这样子写

27:51.330 --> 27:53.330
没有参数只有修饰符

27:53.330 --> 27:55.330
有三个B C D

27:55.330 --> 27:56.330
如果说有参数的话

27:56.330 --> 27:57.330
就这样子

27:57.330 --> 27:58.330
也可以有参数

27:58.330 --> 27:59.330
没有修饰符

27:59.330 --> 28:00.330
都可以

28:00.330 --> 28:01.330
就是完整的指令

28:01.330 --> 28:03.330
就是这样子写的

28:03.330 --> 28:04.330
那么这些

28:04.330 --> 28:05.330
都是指令的信息

28:05.330 --> 28:06.330
有啥用了没啥用

28:06.330 --> 28:07.330
但是这些信息

28:07.330 --> 28:09.330
它会传递到

28:09.330 --> 28:10.330
班顶对象里面

28:10.330 --> 28:13.330
看一下怎么传递的

28:13.330 --> 28:14.330
班顶是一个对象

28:14.330 --> 28:15.330
对对象里面

28:15.330 --> 28:16.330
提供了一些关键的信息

28:16.330 --> 28:17.330
首先

28:17.330 --> 28:18.330
这个指令的名字

28:18.330 --> 28:19.330
它会传递到

28:19.330 --> 28:21.330
班顶对象里的Name属性

28:21.330 --> 28:22.330
你看传的到这

28:22.330 --> 28:23.330
我们看一下

28:23.330 --> 28:24.330
班顶对象

28:24.330 --> 28:25.330
你看Name

28:25.330 --> 28:26.330
这个Name属性

28:32.360 --> 28:33.360
这个Name属性

28:33.360 --> 28:34.360
是不是指令的名称

28:34.360 --> 28:35.360
对不对

28:35.360 --> 28:36.360
楼顶

28:36.360 --> 28:37.360
其实还有一个Row Name

28:37.360 --> 28:40.360
就是包括V橫钢的名称

28:40.360 --> 28:42.360
这是Name属性

28:44.360 --> 28:47.360
然后修饰符

28:47.360 --> 28:49.360
它会传到这个Ark

28:49.360 --> 28:50.360
这个参数

28:50.360 --> 28:51.360
指令参数

28:51.360 --> 28:52.360
它会传到这个地方

28:52.360 --> 28:53.360
它会变成一个字符刷

28:53.360 --> 28:54.360
你看看这边

28:56.360 --> 28:57.360
对

28:58.360 --> 28:59.360
刷新意思

29:01.360 --> 29:02.360
你看

29:02.360 --> 29:03.360
现在有个参数Ark

29:03.360 --> 29:04.360
对吧

29:04.360 --> 29:05.360
A对吧

29:05.360 --> 29:06.360
参数我们就是A

29:07.360 --> 29:08.360
好

29:08.360 --> 29:09.360
后边的修饰符

29:09.360 --> 29:11.360
它会传递到这个Modify

29:11.360 --> 29:13.360
Modify是一个对象

29:13.360 --> 29:14.360
对象里面

29:14.360 --> 29:15.360
你看它什么格式

29:15.360 --> 29:16.360
BCD都委屈

29:16.360 --> 29:18.360
表示现在有三个修饰符

29:18.360 --> 29:19.360
用了BCD

29:19.360 --> 29:20.360
你看

29:20.360 --> 29:21.360
这里用了BC

29:21.360 --> 29:22.360
BC修饰符在这

29:22.360 --> 29:23.360
好

29:23.360 --> 29:24.360
后边这个指令的

29:24.360 --> 29:26.360
这后边不是个GIS表达式吗

29:26.360 --> 29:27.360
这个GIS表达式

29:27.360 --> 29:28.360
它会算出来一个值

29:28.360 --> 29:29.360
表达式不得一个值吗

29:29.360 --> 29:31.360
这个表达式的值

29:31.360 --> 29:33.360
就会放到Value属性里面

29:33.360 --> 29:35.360
你看Value值

29:35.360 --> 29:36.360
是不是True

29:36.360 --> 29:37.360
后边Update过后

29:37.360 --> 29:39.360
是不是Value值变成了Force

29:39.360 --> 29:40.360
对吧

29:40.360 --> 29:41.360
Value值是什么

29:41.360 --> 29:42.360
来自于数据一直漏定

29:42.360 --> 29:43.360
它把一直漏定算出来

29:43.360 --> 29:44.360
放到Value里面

29:44.360 --> 29:46.360
这些信息全部提供给你

29:46.360 --> 29:48.360
当然还有一些别的属性

29:48.360 --> 29:49.360
一般我们不太用得到

29:49.360 --> 29:51.360
你可以自己去看一下

29:51.360 --> 29:52.360
这是它的信息

29:53.360 --> 29:54.360
要不要用参数

29:54.360 --> 29:55.360
要不要用修饰符

29:55.360 --> 29:56.360
完全有你自己来决定

29:56.360 --> 29:58.360
如果说你希望

29:58.360 --> 29:59.360
这个指令光用的还不够

29:59.360 --> 30:01.360
还要额外给提供一些信息

30:01.360 --> 30:02.360
那么你可以利用参数

30:02.360 --> 30:03.360
而修饰符

30:03.360 --> 30:05.360
来进行额外提供信息

30:05.360 --> 30:07.360
那用不到的话就算了

30:08.360 --> 30:09.360
不要到这里

30:09.360 --> 30:10.360
我用不到

30:10.360 --> 30:11.360
OK

30:11.360 --> 30:12.360
那就算了过后

30:12.360 --> 30:13.360
我们来看一下

30:13.360 --> 30:14.360
现在的情况

30:16.740 --> 30:18.740
Modifier是空了对象

30:18.740 --> 30:20.740
那个和Augre是被没了

30:21.740 --> 30:22.740
这就是指令

30:22.740 --> 30:24.740
它如何来传递到斑定对象

30:24.740 --> 30:26.740
斑定对象里面包含了指令的

30:26.740 --> 30:27.740
全部信息

30:28.740 --> 30:30.740
好,那么现在其实就已经可以写了

30:30.740 --> 30:31.740
那怎么写呢?

30:31.740 --> 30:33.740
其实这个东西我们可以不用了

30:33.740 --> 30:35.740
Band是最开始的情况

30:35.740 --> 30:37.740
Update是数据更新过后的情况

30:37.740 --> 30:38.740
那么最开始的情况

30:38.740 --> 30:40.740
我们要做啥事呢

30:40.740 --> 30:41.740
我们打个注释

30:41.740 --> 30:42.740
我们要做啥事

30:42.740 --> 30:44.740
其实要做的事情就是

30:45.740 --> 30:48.740
创建一个Image元素

30:49.740 --> 30:50.740
楼定效果

30:50.740 --> 30:55.740
放到EL元素内部

30:55.740 --> 30:57.740
不知道要做这个效果吗

30:57.740 --> 31:00.740
那么Update要做什么效果呢

31:00.740 --> 31:01.740
Update我们

31:01.740 --> 31:03.740
是不是数据更新过后

31:03.740 --> 31:05.740
有可能为Q有可能为Force

31:05.740 --> 31:07.740
它到底要不要显示这个Image

31:07.740 --> 31:09.740
那么我们要干嘛呢

31:09.740 --> 31:15.180
根据Band的Value

31:15.180 --> 31:16.180
它这个Value属性值为Q

31:16.180 --> 31:18.180
我就显示这个Image

31:18.180 --> 31:20.180
为Force就不显示

31:20.180 --> 31:22.180
根据Value的值

31:22.180 --> 31:25.180
决定是否显示

31:25.180 --> 31:27.180
是否创建

31:29.180 --> 31:30.180
或者这样

31:30.180 --> 31:34.180
决定创建或删除Image元素

31:35.180 --> 31:36.180
你看是不是这个逻辑

31:36.180 --> 31:38.180
如果说它为Q

31:38.180 --> 31:41.180
表示要显示楼定效果

31:41.180 --> 31:43.180
那我就创建一个Image元素

31:43.180 --> 31:44.180
放到这个里面去

31:44.180 --> 31:46.180
如果说它为Force

31:46.180 --> 31:49.180
表示的是不显示楼定效果

31:49.180 --> 31:51.180
就显示了个Image元素删除掉

31:51.180 --> 31:52.180
简单吧

31:52.180 --> 31:54.180
特别简单吧

31:54.180 --> 31:56.180
对不对

31:56.180 --> 31:58.180
其实这两件事

31:58.180 --> 32:00.180
Band里面和Update里面

32:00.180 --> 32:03.180
这两件事实际上是差不多的

32:03.180 --> 32:05.180
那我们把个柱子打完整

32:05.180 --> 32:07.180
Band里面是不是也可以根据这个玩意儿来

32:07.180 --> 32:09.180
因为Band不一定

32:09.180 --> 32:11.180
它不一定一开始就是要显示的

32:11.180 --> 32:13.180
它一开始可能为Force

32:13.180 --> 32:14.180
不显示

32:14.180 --> 32:15.180
对不对

32:15.180 --> 32:18.180
所以说Band也是一个类似的效果

32:19.180 --> 32:20.180
没问题吧

32:20.180 --> 32:21.180
好 那么这两个

32:21.180 --> 32:23.180
其实它的处理方式是一样的

32:23.180 --> 32:25.180
你们在做自定义指令的时候

32:25.180 --> 32:27.180
有的时候像这种自定义指令

32:27.180 --> 32:30.180
Band里面和Update的效果是一样的

32:30.180 --> 32:31.180
那么怎么办呢

32:31.180 --> 32:32.180
只会来减少重复代码呢

32:32.180 --> 32:34.180
当然你可以把它写成一个单独的函数

32:34.180 --> 32:35.180
在这里雕用

32:35.180 --> 32:37.180
没有任何问题

32:37.180 --> 32:40.180
也可以进行配置减化

32:40.180 --> 32:42.180
如果说你的Band和Update

32:42.180 --> 32:43.180
这两个勾字函数

32:43.180 --> 32:45.180
处理的效果都是一样的

32:45.180 --> 32:46.180
OK

32:46.180 --> 32:47.180
那你甚至可以这样子

32:47.180 --> 32:49.180
它无由允许你这样做

32:49.180 --> 32:51.180
你直接这里写个函数

32:51.180 --> 32:53.180
你的配置不但是个对象

32:53.180 --> 32:54.180
你的配置就是一个函数

32:54.180 --> 32:55.180
这个函数什么时候雕用

32:55.180 --> 32:57.180
Band的时候雕用

32:57.180 --> 32:59.180
然后Update的时候雕用

32:59.180 --> 33:00.180
因为它发现了

33:00.180 --> 33:01.180
在实际开发中

33:01.180 --> 33:03.180
这两个用了最多

33:03.180 --> 33:05.180
就是它给你做成一个函数

33:05.180 --> 33:06.180
那么这种写法

33:06.180 --> 33:08.180
跟这种写法效果是完全一样的

33:08.180 --> 33:10.180
好 那么在这里

33:10.180 --> 33:12.180
来看一下

33:12.180 --> 33:17.000
我们在这里要做什么事情

33:17.000 --> 33:22.000
根据Band.value的值

33:22.000 --> 33:26.000
决定

33:26.000 --> 33:31.000
创建或删除MG元素

33:31.000 --> 33:33.000
好 慢慢来写呗

33:33.000 --> 33:36.000
这个地方就是纯粹的动物操作了

33:36.000 --> 33:37.000
深圳你可以不用听我讲了

33:37.000 --> 33:39.000
你自己把它完成也可以

33:39.000 --> 33:40.000
好 来吧

33:40.000 --> 33:41.000
我们来看一下

33:41.000 --> 33:42.000
其实这里面还是有些小的细节

33:42.000 --> 33:43.000
没有什么新的知识

33:43.000 --> 33:44.000
新的知识就是

33:44.000 --> 33:46.000
我们现在多了一个指令

33:47.000 --> 33:50.000
然后学训到指令里面的一些

33:50.000 --> 33:52.000
关键信息什么叫指令参数

33:52.000 --> 33:54.000
什么叫指令修制服啊这些东西

33:54.000 --> 33:57.000
好 然后我们这里判断

33:57.000 --> 33:58.000
判断什么呢

33:58.000 --> 34:00.000
Band.value

34:00.000 --> 34:02.000
看它是不是V2

34:02.000 --> 34:04.000
V2的时候要干嘛呢

34:04.000 --> 34:07.000
是不是要创建MG元素

34:07.000 --> 34:09.000
好 else

34:09.000 --> 34:12.000
输出是不是要删除MG元素

34:12.000 --> 34:14.000
好 保存啊

34:15.000 --> 34:17.000
那么这里说创建两次

34:17.000 --> 34:18.000
为什么Band.运行的一次

34:18.000 --> 34:19.000
Updates运行的一次

34:19.000 --> 34:21.000
为了避免重复创建了

34:21.000 --> 34:23.000
我们在这里是不是要先判断

34:23.000 --> 34:24.000
有没有MG元素

34:24.000 --> 34:25.000
对不对

34:25.000 --> 34:26.000
首先判断

34:28.000 --> 34:31.000
如果没有MG元素

34:31.000 --> 34:32.000
我们才创建

34:32.000 --> 34:33.000
有MG元素就刷了

34:33.000 --> 34:34.000
它本身就在那对吧

34:34.000 --> 34:36.000
已经正在显示了就刷了

34:36.000 --> 34:38.000
没有MG元素就创建MG元素

34:38.000 --> 34:39.000
那我怎么样知道

34:39.000 --> 34:41.000
有没有MG元素了

34:41.000 --> 34:42.000
我们关键你就看这个

34:42.000 --> 34:43.000
因为我们MG元素

34:43.000 --> 34:45.000
是不是夹到这里面了

34:45.000 --> 34:47.000
夹到这里面了

34:47.000 --> 34:48.000
对吧

34:49.000 --> 34:51.000
那如果说

34:51.000 --> 34:52.000
MG元素在这里面

34:52.000 --> 34:54.000
那么我们就在这个元素里面

34:54.000 --> 34:57.000
查找一下有没有MG元素

34:57.000 --> 34:59.000
那么我们可以保持

34:59.000 --> 35:01.000
写成一个单独函数

35:02.000 --> 35:05.630
Is Exist

35:05.630 --> 35:06.630
是否

35:06.630 --> 35:09.630
把一个EL过传进来判断

35:09.630 --> 35:12.630
判断EL中是否存在

35:12.630 --> 35:14.630
楼顶

35:14.630 --> 35:17.630
效果的MG元素

35:17.630 --> 35:18.630
看有没有

35:18.630 --> 35:19.630
有的话就返回去

35:19.630 --> 35:21.630
没有的话就返回Force

35:21.630 --> 35:23.630
那到底有没有呢

35:23.630 --> 35:24.630
你肯定不能用这种方式

35:24.630 --> 35:27.630
query

35:27.630 --> 35:29.630
看一下里面有没有MG

35:29.630 --> 35:31.630
因为这个EL里面是来自

35:31.630 --> 35:32.630
你鬼知道这里面

35:32.630 --> 35:33.630
DIV里面有啥

35:33.630 --> 35:34.630
可能有很多的MG

35:34.630 --> 35:35.630
我们只看一下

35:35.630 --> 35:36.630
有没有楼顶效果的MG

35:36.630 --> 35:37.630
对吧

35:37.630 --> 35:38.630
所以说我们到时候

35:38.630 --> 35:40.630
再创建MG元素的时候

35:40.630 --> 35:41.630
给它加上一个

35:41.630 --> 35:43.630
自定义的属性

35:43.630 --> 35:45.630
高速

35:45.630 --> 35:47.630
比方说一个Data Set

35:47.630 --> 35:48.630
到时候我们创建

35:48.630 --> 35:49.630
比方说这里写了

35:49.630 --> 35:51.630
创建MG元素

35:51.630 --> 35:52.630
Trace

35:52.630 --> 35:53.630
楼顶

35:53.630 --> 35:54.630
MG

35:54.630 --> 35:55.630
比方说9个例子

35:55.630 --> 35:57.630
我们这里

35:57.630 --> 35:59.630
创建MG元素的时候

35:59.630 --> 36:00.630
到时候我们调用

36:00.630 --> 36:02.630
创建MG元素

36:02.630 --> 36:04.630
我们就给这个元素

36:04.630 --> 36:07.630
添加一个自定义属性Data Set

36:07.630 --> 36:09.630
楼顶

36:10.630 --> 36:12.630
或者叫Data Set

36:12.630 --> 36:13.630
楼顶吧

36:14.630 --> 36:15.630
都可以

36:16.630 --> 36:17.630
给它加上一个自定义属性

36:17.630 --> 36:19.630
可以通过自定义属性

36:19.630 --> 36:21.630
来进行查找

36:21.630 --> 36:22.630
好

36:22.630 --> 36:23.630
到时候

36:23.630 --> 36:25.630
我们创建MG元素的时候

36:25.630 --> 36:26.630
由于自定义属性

36:26.630 --> 36:28.630
那么找这个MG的时候

36:28.630 --> 36:29.630
是不是可以这样找

36:30.630 --> 36:31.630
怎么找呢

36:31.630 --> 36:32.630
MG

36:33.630 --> 36:36.630
给它找它的楼顶

36:36.630 --> 36:37.630
Data

36:37.630 --> 36:38.630
Data

36:38.630 --> 36:39.630
肉

36:39.630 --> 36:40.630
等于什么

36:40.630 --> 36:41.630
等于楼顶

36:41.630 --> 36:43.630
找这样的MG

36:43.630 --> 36:45.630
看能不能找得到

36:45.630 --> 36:46.630
能找到就ok

36:46.630 --> 36:48.630
找不到就算了

36:48.630 --> 36:49.630
或者是我们

36:49.630 --> 36:51.630
这里不用一个ZS吧

36:51.630 --> 36:52.630
get

36:52.630 --> 36:53.630
楼顶

36:53.630 --> 36:54.630
MG

36:54.630 --> 36:56.630
得到EL中

36:56.630 --> 36:58.630
楼顶效果的MG元素

36:58.630 --> 37:00.630
得到EL中

37:00.630 --> 37:02.630
楼顶效果的MG元素

37:02.630 --> 37:04.630
好直接返回

37:04.630 --> 37:06.630
好有了这个函数帮忙过后

37:06.630 --> 37:08.630
如果说没有EMG元素怎么来判断

37:08.630 --> 37:09.630
是不是掉到这个函数

37:09.630 --> 37:11.630
把EL传进去

37:11.630 --> 37:12.630
看一下

37:12.630 --> 37:13.630
如果说没有

37:13.630 --> 37:15.630
没有这个EMG元素怎么办

37:15.630 --> 37:17.630
所以我们要创建EMG元素

37:17.630 --> 37:21.200
创建EMG元素

37:21.200 --> 37:22.200
CreateLoadingEMG

37:22.200 --> 37:23.200
创建它

37:26.200 --> 37:28.200
那么这个EMG还没有写SRC

37:28.200 --> 37:29.200
SRC属性

37:29.200 --> 37:30.200
SRC来自于哪了

37:30.200 --> 37:31.200
跟我们之前一样的

37:31.200 --> 37:32.200
就是

37:32.200 --> 37:34.200
导入这个楼顶

37:34.200 --> 37:35.200
UIL

37:35.200 --> 37:36.200
来自于

37:36.200 --> 37:37.200
来自于

37:40.200 --> 37:42.200
LoadingSVG

37:42.200 --> 37:45.600
好发挥

37:45.600 --> 37:46.600
发挥这个EMG

37:47.600 --> 37:49.600
好创建好一个EMG

37:50.600 --> 37:52.600
SRC自定义属性都设置好

37:52.600 --> 37:54.600
然后把这个EMG加到哪儿去

37:54.600 --> 37:56.600
加这个EL里边去

37:56.600 --> 37:58.600
AppendChannelEMG

37:59.600 --> 38:00.600
好保存RD看一下

38:03.680 --> 38:04.680
没出来是吧

38:04.680 --> 38:05.680
没出来我们来看一下吧

38:05.680 --> 38:06.680
到底是怎么情况没出来

38:06.680 --> 38:10.310
我把这个时间调长一点

38:10.310 --> 38:11.310
调4倍

38:11.310 --> 38:12.310
123

38:12.310 --> 38:16.030
加3个0

38:16.030 --> 38:17.030
放下来吧

38:17.030 --> 38:21.300
找到这个DIV

38:21.300 --> 38:23.300
Nayout往下找

38:23.300 --> 38:24.300
Made往下找

38:24.300 --> 38:25.300
HomeContent

38:25.300 --> 38:26.300
往下找

38:26.300 --> 38:28.300
这个楼顶已经出来了

38:28.300 --> 38:30.300
图片也有了

38:30.300 --> 38:31.300
放了

38:31.300 --> 38:32.300
我没有把它居中

38:32.300 --> 38:33.300
对不对

38:33.300 --> 38:34.300
它是一个普通定位

38:34.300 --> 38:36.300
我要把它绝对定位居中

38:36.300 --> 38:38.300
绝对定位居中怎么办

38:38.300 --> 38:40.300
我们是不是可以写上一个

38:40.300 --> 38:41.300
SRC

38:41.300 --> 38:42.300
对不对

38:42.300 --> 38:44.300
我们可以开启SRC module

38:44.300 --> 38:45.300
来吧

38:45.300 --> 38:47.300
我们可以写上一个

38:47.300 --> 38:49.300
loading module

38:49.300 --> 38:50.300
SRC

38:50.300 --> 38:52.680
或者NAS

38:53.680 --> 38:54.680
这里我们写上一个

38:54.680 --> 38:55.680
loading

38:55.680 --> 38:56.680
loading.content

38:58.680 --> 38:59.680
高度明明

38:59.680 --> 39:00.680
或者就是loading

39:00.680 --> 39:01.680
都可以

39:01.680 --> 39:03.680
反正是开启SRC module的

39:03.680 --> 39:04.680
这里导入之前的

39:04.680 --> 39:07.630
SRC

39:07.630 --> 39:08.630
之前的NAS

39:08.630 --> 39:09.630
Styles

39:09.630 --> 39:11.630
Mixing.nas

39:12.630 --> 39:13.630
这里边很简单

39:13.630 --> 39:14.630
SelfCenter

39:16.630 --> 39:17.630
好

39:17.630 --> 39:18.630
这个内样式

39:19.630 --> 39:20.630
Styles

39:21.630 --> 39:22.630
from

39:23.630 --> 39:25.630
loading module.ness

39:26.630 --> 39:27.630
给它设置一下

39:27.630 --> 39:28.630
它的class name

39:29.630 --> 39:31.630
withStyles.loading

39:31.630 --> 39:32.630
对吧

39:32.630 --> 39:33.630
把设置跟内样式

39:33.630 --> 39:34.630
保存

39:34.630 --> 39:35.630
你看不得出来了吗

39:35.630 --> 39:36.630
你看

39:36.630 --> 39:38.630
这个是开启SRC module的

39:38.630 --> 39:39.630
是不是出来了

39:40.630 --> 39:41.630
效果就出来了

39:42.630 --> 39:43.630
那么一开始

39:43.630 --> 39:44.630
是不是就创建了这么

39:44.630 --> 39:45.630
创建好了这么一个

39:46.630 --> 39:47.630
没有IMG元素的时候

39:47.630 --> 39:48.630
是不是就创建好IMG

39:48.630 --> 39:49.630
把它加到

39:50.630 --> 39:51.630
元素里边去了

39:51.630 --> 39:53.630
那如果说有IMG元素了

39:53.630 --> 39:55.630
它的Value为

39:55.630 --> 39:56.630
Force的时候

39:56.630 --> 39:58.630
是不是要删除IMG元素

39:58.630 --> 39:59.630
对不对

39:59.630 --> 40:00.630
删除的时候是不是也很简单

40:00.630 --> 40:02.630
首先拿到IMG

40:02.630 --> 40:03.630
拿到之前的IMG

40:03.630 --> 40:05.630
可以是loadingIMG

40:05.630 --> 40:07.630
或者既然都要拿到IMG

40:07.630 --> 40:08.630
我们就干脆

40:08.630 --> 40:14.270
用变量

40:15.270 --> 40:16.270
当前的IMG

40:16.270 --> 40:19.710
如果说没有当前的IMG

40:19.710 --> 40:20.710
我们就创建

40:20.710 --> 40:21.710
好

40:21.710 --> 40:22.710
那么这里也是

40:22.710 --> 40:24.710
如果说有当前的IMG

40:24.710 --> 40:25.710
那么我们就删除

40:29.710 --> 40:30.710
好

40:30.710 --> 40:31.710
试一下吧

40:31.710 --> 40:32.710
我们再

40:32.710 --> 40:33.710
又回到mode这里

40:33.710 --> 40:34.710
先调一下

40:34.710 --> 40:36.710
1000到2000秒

40:36.710 --> 40:37.710
好

40:37.710 --> 40:38.710
好

40:38.710 --> 40:39.710
刷新

40:39.710 --> 40:40.710
你看

40:40.710 --> 40:42.710
时间这样的效果了

40:42.710 --> 40:43.710
刷新

40:43.710 --> 40:45.710
是不是时间这样的效果了

40:45.710 --> 40:46.710
那么之后

40:46.710 --> 40:47.710
你看虽然写起来

40:47.710 --> 40:48.710
比之前要写

40:48.710 --> 40:49.710
主件要稍微麻烦一点

40:49.710 --> 40:50.710
但是也没有用多好时间

40:50.710 --> 40:51.710
但是之后用起来

40:51.710 --> 40:52.710
它可方便了

40:52.710 --> 40:54.710
我们要时间loading效果

40:54.710 --> 40:55.710
不用去导致什么主件了

40:55.710 --> 40:57.710
不用去注册什么主件了

40:57.710 --> 40:59.710
我们直接使用这个为loading

40:59.710 --> 41:00.710
把这个到底

41:00.710 --> 41:01.710
要不要写成loading效果

41:01.710 --> 41:02.710
给它设为q或者是force

41:02.710 --> 41:03.710
就完事了

41:03.710 --> 41:05.710
是不是用起来就非常方便

41:05.710 --> 41:06.710
实际上你们以后

41:06.710 --> 41:07.710
在做开发的时候

41:07.710 --> 41:08.710
就会发现

41:09.710 --> 41:10.710
如果说有一些东西

41:10.710 --> 41:12.710
它用的特别特别多

41:12.710 --> 41:14.710
我宁愿多花一点时间

41:14.710 --> 41:15.710
把它做好

41:15.710 --> 41:16.710
然后不要用起来方便

41:16.710 --> 41:17.710
因为

41:17.710 --> 41:19.710
我们写它的时候

41:19.710 --> 41:20.710
只写一次

41:21.710 --> 41:23.710
无非就是修修改改

41:23.710 --> 41:25.710
用的时候它就是无数次

41:25.710 --> 41:26.710
当初可能会用

41:26.710 --> 41:27.710
对吧

41:27.710 --> 41:29.710
它可以大量的节省使用的时间

41:29.710 --> 41:31.710
那么这loading效果就做出来了

41:31.710 --> 41:32.710
OK 那么这节课

41:32.710 --> 41:34.710
我就说一下这个自定义指令

41:34.710 --> 41:35.710
通过这节课

41:35.710 --> 41:36.710
它就对自定义指令

41:36.710 --> 41:37.710
就有一个认识了

41:37.710 --> 41:38.710
就自定义指令

41:38.710 --> 41:39.710
它本身并不复杂

41:39.710 --> 41:40.710
如果说你想了解

41:40.710 --> 41:42.710
更多的自定义指令的用法

41:42.710 --> 41:43.710
你可以去参见观望

41:43.710 --> 41:44.710
自定指令

41:44.710 --> 41:45.710
后边我就不再

41:45.710 --> 41:46.710
更多的去讲了

41:46.710 --> 41:47.710
因为这个玩意

41:47.710 --> 41:49.710
它也没有什么好复杂的

41:49.710 --> 41:51.710
好 这是这节课的内容

41:51.710 --> 41:53.710
跟着我 把这个效果做出来

