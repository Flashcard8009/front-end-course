WEBVTT

00:00.000 --> 00:02.000
好 来吧

00:02.000 --> 00:05.000
首先我们今天看一下今天我们实现的效果

00:05.000 --> 00:08.000
是一个音乐歌词滚动的效果

00:08.000 --> 00:20.590
看一下吧

00:20.590 --> 00:22.590
这就是咱们今天要实现的效果

00:22.590 --> 00:24.590
很好理解对吧

00:24.590 --> 00:26.590
平时你们听歌的时候也看到过这样的效果

00:26.590 --> 00:29.590
来吧 我们今天来练习一下

00:29.590 --> 00:31.590
整体课的内容比较简单

00:31.590 --> 00:34.590
相对来说 相对我们这几天的效果

00:34.590 --> 00:36.590
是相对来说比较简单的

00:36.590 --> 00:38.590
不过里面也会练习到

00:38.590 --> 00:40.590
很多的ES6啊ES5的一些API

00:40.590 --> 00:43.590
更重要的是会断连我们的

00:43.590 --> 00:45.590
程序思维逻辑

00:45.590 --> 00:47.590
好 我们把这个放一边

00:47.590 --> 00:49.590
接下来我们在

00:49.590 --> 00:51.590
这里有两个文念夹

00:51.590 --> 00:53.590
一个是效果 就是这个东西

00:53.590 --> 00:56.590
一个是素材 就是发给你们的东西

00:56.590 --> 00:58.590
里面要做的就是打开素材文念夹

00:58.590 --> 00:59.590
进行开发

00:59.590 --> 01:01.590
我这里为了避免污染

01:01.590 --> 01:03.590
我就复制一个吧

01:04.590 --> 01:05.590
过来啊

01:05.590 --> 01:09.420
好 给他重新取个名字

01:09.420 --> 01:11.420
叫做客堂代码

01:12.420 --> 01:13.420
好 我们打开它

01:13.420 --> 01:15.420
看它里面有什么东西

01:15.420 --> 01:17.420
它里面其实有

01:17.420 --> 01:18.420
这么两个东西啊

01:18.420 --> 01:20.420
一个是介石文件

01:20.420 --> 01:22.420
介石文件里面有一个寒树

01:22.420 --> 01:24.420
这个寒树咋写的你不用管

01:24.420 --> 01:26.420
它里边的代码你们现在还没有学习

01:26.420 --> 01:29.420
你们将来很快就会学习了

01:29.420 --> 01:31.420
这个寒树你只需要知道怎么用就行了

01:31.420 --> 01:33.420
我们以后会说这个寒树

01:33.420 --> 01:34.420
现在放在这

01:34.420 --> 01:36.420
然后我们页面都还没有

01:36.420 --> 01:38.420
然后有一个MP3的文件

01:38.420 --> 01:40.420
这个MP3你懂的对不对

01:40.420 --> 01:42.420
可以直接播放的这么一个MP3文件

01:42.420 --> 01:45.980
说放

01:45.980 --> 01:47.980
就这个东西

01:47.980 --> 01:50.980
好 接下来我们要做的就是

01:50.980 --> 01:51.980
建立页面

01:51.980 --> 01:53.980
完成介石 完成CSS

01:53.980 --> 01:55.980
然后实现我们整个的效果

01:55.980 --> 01:57.980
来 我们首先开始

01:57.980 --> 01:59.980
首先我们新建一个页面

01:59.980 --> 02:01.980
叫index.atm

02:02.980 --> 02:04.980
我们先把atm写好

02:04.980 --> 02:06.980
其实我们做整个效果

02:06.980 --> 02:08.980
无论是页面复杂也好

02:08.980 --> 02:09.980
还是简单也好

02:09.980 --> 02:11.980
基本的流程都差不多

02:11.980 --> 02:13.980
都是先写结构

02:13.980 --> 02:14.980
atm写好

02:14.980 --> 02:16.980
然后再写一些样式

02:16.980 --> 02:17.980
把它做出来

02:17.980 --> 02:19.980
然后接下来我们该加上一些功能

02:19.980 --> 02:20.980
解释

02:20.980 --> 02:21.980
首先我们写这个atm

02:21.980 --> 02:23.980
这个atm其实还是比较简单的

02:23.980 --> 02:25.980
我们来看一下我们的最终效果

02:25.980 --> 02:26.980
我们最终效果里面

02:26.980 --> 02:29.980
无非就是这里有这么一个

02:30.980 --> 02:31.980
Audio元素

02:31.980 --> 02:33.980
对吧 那我们就写一个

02:33.980 --> 02:35.980
Audio元素

02:35.980 --> 02:37.980
那么SRCD自然就是

02:37.980 --> 02:39.980
Music MP3

02:39.980 --> 02:41.980
这是一个Audio元素

02:41.980 --> 02:43.980
然后下边是一个歌词

02:43.980 --> 02:44.980
那么这个歌词

02:44.980 --> 02:45.980
你要好好考虑一下

02:45.980 --> 02:47.980
这歌词它是能滚动的

02:47.980 --> 02:48.980
啥意思呢

02:48.980 --> 02:50.980
也就是说我们这里

02:50.980 --> 02:52.980
里面实际上是有一个

02:52.980 --> 02:54.980
很长很长的东西

02:54.980 --> 02:55.980
就说这里

02:55.980 --> 02:56.980
这什么

02:57.980 --> 03:01.360
等一下

03:01.360 --> 03:03.360
就是这里实际上是有一个容器

03:03.360 --> 03:04.360
这个容器

03:04.360 --> 03:06.360
我们把高度给它固定

03:06.360 --> 03:07.360
固定一个高度

03:07.360 --> 03:08.360
然后它里面

03:08.360 --> 03:11.360
实际上是一个很长很长的东西

03:11.360 --> 03:12.360
比方说它里面

03:12.360 --> 03:14.360
是有一个UL

03:14.360 --> 03:16.360
外面这个容器我换个颜色

03:18.670 --> 03:20.670
外面这个蓝色的是

03:20.670 --> 03:22.670
一个DNA吧 定高

03:22.670 --> 03:24.670
然后溢出隐藏

03:24.670 --> 03:26.670
里面是一个很高很高的UL

03:26.670 --> 03:27.670
一个列表

03:27.670 --> 03:28.670
UL里面当然就是

03:28.670 --> 03:30.670
一行一行的LI

03:30.670 --> 03:31.670
明白了意思吧

03:31.670 --> 03:33.670
就这么一个逻辑

03:33.670 --> 03:34.670
所以说我们元素结构

03:34.670 --> 03:35.670
按照我们的分析

03:35.670 --> 03:36.670
接下来大家可以把

03:36.670 --> 03:38.670
元素结构尝试着

03:38.670 --> 03:40.670
自己看能不能把它写出来

03:40.670 --> 03:41.670
暂停视频

03:41.670 --> 03:43.670
尝试来写一下

03:44.670 --> 03:46.670
好 那我们来写一下

03:46.670 --> 03:48.670
无非就是这里有一个DIV

03:48.670 --> 03:49.670
这个DIV给它跟那样试吧

03:49.670 --> 03:50.670
停了

03:50.670 --> 03:52.670
然后里面有个UL

03:52.670 --> 03:53.670
UL里面显示歌词

03:53.670 --> 03:56.670
歌词的话我们用S-L-R-C

03:56.670 --> 03:58.670
然后里面就是很多的LI

03:58.670 --> 03:59.670
那么这个LI呢

03:59.670 --> 04:00.670
我们就先随便写一些吧

04:00.670 --> 04:01.670
写一些静态的

04:01.670 --> 04:02.670
我们先把样式给它做出来

04:02.670 --> 04:03.670
才说

04:03.670 --> 04:05.670
我们要给它写30个

04:05.670 --> 04:06.670
然后呢

04:06.670 --> 04:07.670
每一行是一个LORI

04:07.670 --> 04:09.670
随便写 生成一个文字

04:09.670 --> 04:11.670
样式 那就随便嘛

04:11.670 --> 04:12.670
然后呢

04:12.670 --> 04:14.670
OpenWidthDefServer

04:14.670 --> 04:16.670
目前就是这个样子

04:16.670 --> 04:18.670
好 接下来我们来调整

04:18.670 --> 04:19.670
看哪些地方

04:19.670 --> 04:20.670
我们还要去修饰一下

04:20.670 --> 04:21.670
比方说这个Audio元素

04:21.670 --> 04:22.670
Audio元素呢

04:22.670 --> 04:24.670
我这里显示不出来

04:24.670 --> 04:25.670
为什么显示不出来呢

04:26.670 --> 04:27.670
是因为Audio元素呢

04:27.670 --> 04:29.670
它本身它是没有界面的

04:29.670 --> 04:30.670
它的界面呢

04:30.670 --> 04:32.670
实际上是一些按钮啊

04:32.670 --> 04:34.670
一些播放进度条啊

04:34.670 --> 04:35.670
这些东西叫做空键

04:35.670 --> 04:36.670
播放空键

04:36.670 --> 04:37.670
那么我们这里呢

04:37.670 --> 04:39.670
需要把这个空键给它显示出来

04:39.670 --> 04:40.670
再加上一个布尔属性

04:40.670 --> 04:41.670
叫Controls

04:42.670 --> 04:43.670
Controls

04:43.670 --> 04:44.670
加上它

04:44.670 --> 04:45.670
那么是不是就显示出来了

04:45.670 --> 04:46.670
对不对

04:46.670 --> 04:47.670
其他就没啥了

04:47.670 --> 04:48.670
这边就写好了

04:49.670 --> 04:51.670
好 接下来我们来写CSS

04:51.670 --> 04:52.670
因为这个CSS呢

04:52.670 --> 04:53.670
其实非常简单

04:53.670 --> 04:54.670
你可以打开看一下

04:54.670 --> 04:56.670
你也知道它里面没有多少CSS

04:56.670 --> 04:57.670
所以说呢我们这里呢

04:57.670 --> 04:58.670
就可以

04:58.670 --> 05:00.670
不用去建立一个外部的CSS文件

05:00.670 --> 05:02.670
直接在这里用style写得了

05:03.670 --> 05:05.670
像这种CSS内容很少的地方

05:05.670 --> 05:08.670
其实没有必要去建立外部的CSS文件

05:08.670 --> 05:09.670
外部的CSS文件呢

05:09.670 --> 05:11.670
主要是内容角度

05:12.670 --> 05:13.670
这里呢我们就跟

05:13.670 --> 05:14.670
首先给它设置个背景颜色吧

05:14.670 --> 05:15.670
给body

05:15.670 --> 05:16.670
白光

05:17.670 --> 05:18.670
设置一个黑色

05:19.670 --> 05:20.670
然后呢把文字颜色呢

05:20.670 --> 05:22.670
稍微设置一下啊

05:22.670 --> 05:23.670
设置一个666吧

05:23.670 --> 05:24.670
一个

05:25.670 --> 05:26.670
浅黑色

05:26.670 --> 05:27.670
好 差不多了

05:27.670 --> 05:28.670
然后呢我们把整个

05:29.670 --> 05:30.670
take a second

05:31.670 --> 05:32.670
所有的航禾居中

05:33.670 --> 05:34.670
对吧 居中了

05:34.670 --> 05:35.670
这也可以看出

05:35.670 --> 05:36.670
像这个玩意呢

05:36.670 --> 05:37.670
它也是生成了一个航禾

05:38.670 --> 05:39.670
好 接下来这一块呢

05:39.670 --> 05:41.670
我们再慢慢去设置一下

05:41.670 --> 05:42.670
首先是这个Audio

05:42.670 --> 05:44.670
Audio的话我们

05:44.670 --> 05:46.670
给它设置个宽度吧

05:46.670 --> 05:48.670
宽度的话我带个相处

05:48.670 --> 05:49.670
可以

05:49.670 --> 05:51.670
好 然后让它离下边有一段距离

05:51.670 --> 05:54.670
margin bottom 50的像素

05:55.670 --> 05:56.670
嗯 差不多

05:56.670 --> 05:57.670
好 接下来

05:57.670 --> 05:58.670
那我们来设置一下这个容器

05:58.670 --> 06:00.670
因为这里呢有这么几个元素啊

06:00.670 --> 06:02.670
DIV就是一个定高的容器

06:02.670 --> 06:04.670
之前我们画过的对不对

06:05.670 --> 06:08.670
就是这么有一个定高的

06:08.670 --> 06:09.670
高度固定的容器

06:09.670 --> 06:11.670
然后呢艺术隐藏

06:11.670 --> 06:13.670
然后里边呢是一个

06:14.670 --> 06:15.670
很高的

06:15.670 --> 06:17.670
就是被内容撑开的这么一个UL

06:17.670 --> 06:19.670
UL里面就是每一行一行一行的li

06:20.670 --> 06:22.670
好 那我们来写一下啊

06:22.670 --> 06:25.670
首先是这里的DIV

06:25.670 --> 06:26.670
那么它要高度固定

06:26.670 --> 06:28.670
高度的我这里设置一个

06:28.670 --> 06:30.670
多少呢 先随便设置一个吧

06:30.670 --> 06:31.670
400个像素

06:32.670 --> 06:34.670
好 然后里边呢

06:34.670 --> 06:36.670
我们设置一个overflow item

06:37.670 --> 06:39.670
首先不着急overflow item吧

06:39.670 --> 06:41.670
我们首先给它一个背景颜色

06:41.670 --> 06:42.670
方便我们看清楚一点

06:43.670 --> 06:45.670
这里是300

06:46.670 --> 06:47.670
1008c8c8c8

06:47.670 --> 06:49.670
随便随便下写一个

06:49.670 --> 06:50.670
就这么一个东西

06:50.670 --> 06:51.670
然后接下来呢

06:51.670 --> 06:53.670
里边的LRC呢

06:53.670 --> 06:54.670
这个UL

06:54.670 --> 06:55.670
UL元素呢

06:55.670 --> 06:57.670
我们把它这个

06:57.670 --> 06:59.670
默认样式给取掉了

06:59.670 --> 07:00.670
pandy

07:00.670 --> 07:01.670
0

07:01.670 --> 07:03.670
margin

07:03.670 --> 07:05.670
0

07:05.670 --> 07:06.670
好

07:06.670 --> 07:08.670
然后是

07:08.670 --> 07:09.670
啥呀

07:09.670 --> 07:11.670
然后是它里边的li

07:12.670 --> 07:14.670
lrc下面的li

07:14.670 --> 07:16.670
这个li元素呢

07:16.670 --> 07:18.670
我们给它定一个高度

07:18.670 --> 07:20.670
让它稍微稀缩一点

07:20.670 --> 07:21.670
很高度呢

07:21.670 --> 07:23.670
给它定一个30个像素吧

07:24.670 --> 07:25.670
差不多

07:25.670 --> 07:26.670
然后呢

07:26.670 --> 07:28.670
那它每一行的居中

07:28.670 --> 07:29.670
30个像素

07:31.670 --> 07:33.670
好 那么li那就差不多设置好了

07:33.670 --> 07:34.670
接下来呢

07:34.670 --> 07:35.670
我们要做的事情呢

07:35.670 --> 07:37.670
就是设置这个container

07:37.670 --> 07:38.670
overflow item

07:38.670 --> 07:39.670
但是这里呢

07:39.670 --> 07:40.670
有一个小的细节

07:40.670 --> 07:41.670
大家注意一下啊

07:41.670 --> 07:42.670
什么小的细节呢

07:42.670 --> 07:44.670
就是我每一行的li

07:44.670 --> 07:45.670
那是30个高度

07:45.670 --> 07:46.670
而container呢

07:46.670 --> 07:48.670
是400的高度

07:48.670 --> 07:49.670
那么一会我滚动的时候呢

07:49.670 --> 07:50.670
就有可能会出现

07:50.670 --> 07:52.670
有一半文字在上面

07:52.670 --> 07:53.670
有一半文字显示出来了

07:53.670 --> 07:55.670
有一半文字没有显示

07:55.670 --> 07:56.670
对不对

07:56.670 --> 07:57.670
所以会出现这种情况

07:57.670 --> 07:58.670
所以说我们这里的高度呢

07:58.670 --> 08:00.670
最好是30的倍数

08:00.670 --> 08:01.670
那我们这里呢

08:01.670 --> 08:03.670
给它设置一个420吧

08:03.670 --> 08:05.670
给它设置一个420

08:05.670 --> 08:06.670
好 我们把这个地方呢

08:06.670 --> 08:08.670
稍微注意一下啊

08:09.670 --> 08:10.670
其他的

08:10.670 --> 08:12.670
然后我们把这个overflow item

08:12.670 --> 08:13.670
再加上

08:13.670 --> 08:15.670
这样子艺术就隐藏了

08:15.670 --> 08:16.670
好 到时候呢

08:16.670 --> 08:17.670
我们怎么来处理滚动呢

08:17.670 --> 08:18.670
你可以想象一下啊

08:18.670 --> 08:19.670
怎么来处理滚动

08:19.670 --> 08:20.670
其实非常简单

08:20.670 --> 08:21.670
我们到时候

08:21.670 --> 08:22.670
只要去设置这个

08:22.670 --> 08:25.670
UL元素的什么

08:25.670 --> 08:26.670
transform

08:26.670 --> 08:27.670
对吧 我们学过的

08:27.670 --> 08:29.670
transnate y

08:29.670 --> 08:30.670
让它进行移动

08:30.670 --> 08:32.670
比方说我要往上移动

08:32.670 --> 08:33.670
30个像素

08:33.670 --> 08:34.670
是不是移动到这儿了

08:34.670 --> 08:35.670
然后移动到

08:35.670 --> 08:36.670
60个像素

08:36.670 --> 08:37.670
是不是移动到这儿了

08:37.670 --> 08:38.670
对不对 到时候

08:38.670 --> 08:39.670
我们设置它就可以了

08:39.670 --> 08:40.670
但是这里呢

08:40.670 --> 08:41.670
有一个小的细节

08:41.670 --> 08:42.670
就是

08:42.670 --> 08:43.670
如果说这样设置的话

08:43.670 --> 08:44.670
它是没有动画效果的

08:44.670 --> 08:46.670
它是瞬间完成变化的

08:46.670 --> 08:47.670
所以说呢

08:47.670 --> 08:48.670
你们应该怎么办呢

08:48.670 --> 08:49.670
应该去设置一下

08:49.670 --> 08:52.670
这个UL元素的transition

08:52.670 --> 08:55.670
把设置为0.5秒吧

08:55.670 --> 08:56.670
这样子一来呢

08:56.670 --> 08:57.670
我们在这里

08:57.670 --> 08:59.670
再去设置它的transform

08:59.670 --> 09:06.670
transnate y

09:06.670 --> 09:07.670
附的30个像素

09:07.670 --> 09:08.670
你看

09:08.670 --> 09:09.670
现在是不是有一个

09:09.670 --> 09:10.670
滚动的效果

09:10.670 --> 09:11.670
对吧

09:11.670 --> 09:12.670
到时候我们

09:12.670 --> 09:13.670
只需要在解释里面

09:13.670 --> 09:15.670
去控制它的transnate

09:15.670 --> 09:16.670
这就可以了

09:16.670 --> 09:17.670
那么具体怎么控制

09:17.670 --> 09:19.670
我们一会写解释的时候再说

09:19.670 --> 09:20.670
然后就让我把

09:20.670 --> 09:22.670
这个overflow加上

09:22.670 --> 09:24.670
还能够加上

09:24.670 --> 09:25.670
背景也是要去掉

09:25.670 --> 09:27.670
大概就这样子

09:27.670 --> 09:28.670
还有什么没有设置呢

09:28.670 --> 09:29.670
我们这里

09:29.670 --> 09:30.670
还要考虑一下

09:30.670 --> 09:31.670
就是

09:31.670 --> 09:32.670
到时候呢

09:32.670 --> 09:33.670
某一行的li

09:33.670 --> 09:34.670
就是某一个歌词

09:34.670 --> 09:36.670
它要高亮显示

09:36.670 --> 09:37.670
比方说这里

09:37.670 --> 09:38.670
它要高亮显示

09:38.670 --> 09:39.670
那么这个高亮显示

09:39.670 --> 09:40.670
我们怎么来处理呢

09:40.670 --> 09:41.670
我们可以

09:41.670 --> 09:42.670
像这种啊

09:42.670 --> 09:43.670
非常常见的处理方式

09:43.670 --> 09:44.670
就是某一个li比较特殊

09:44.670 --> 09:45.670
那么到时候呢

09:45.670 --> 09:46.670
就给它加上

09:46.670 --> 09:47.670
你的内样式

09:47.670 --> 09:48.670
比方说active

09:48.670 --> 09:49.670
激活的

09:49.670 --> 09:50.670
被选中的

09:50.670 --> 09:52.670
都可以用类似的单词

09:52.670 --> 09:54.670
我们找到这个active

09:54.670 --> 09:55.670
当你处于

09:55.670 --> 09:56.670
一个active状态的时候

09:56.670 --> 09:57.670
也是我们找到

09:57.670 --> 09:59.670
lrc下面的li

09:59.670 --> 10:00.670
当你处于

10:00.670 --> 10:01.670
一个active状态的时候呢

10:01.670 --> 10:02.670
我给你稍微

10:02.670 --> 10:03.670
注意一下变形

10:03.670 --> 10:04.670
首先把颜色给你

10:04.670 --> 10:05.670
设置为白色

10:06.670 --> 10:07.670
比方说这里行

10:07.670 --> 10:08.670
这高亮显示了

10:08.670 --> 10:09.670
然后呢

10:09.670 --> 10:10.670
我再把它放大一点

10:10.670 --> 10:12.670
我们可以用transform

10:12.670 --> 10:13.670
scale

10:13.670 --> 10:14.670
放大一点

10:14.670 --> 10:16.670
放大到1.5倍

10:18.670 --> 10:19.670
这些不太夸张了

10:19.670 --> 10:21.670
1.3倍

10:21.670 --> 10:23.670
稍微给它放大一点

10:23.670 --> 10:24.670
这就可以了

10:24.670 --> 10:25.670
这个高亮的效果

10:25.670 --> 10:26.670
那么到时候呢

10:26.670 --> 10:27.670
切换的时候

10:27.670 --> 10:28.670
它加上这个内样式

10:28.670 --> 10:29.670
它就有这个效果

10:29.670 --> 10:30.670
没有这个内样式

10:30.670 --> 10:31.670
它就去掉这个效果

10:31.670 --> 10:32.670
但是呢

10:33.670 --> 10:34.670
也就是它没有动画

10:34.670 --> 10:35.670
比方说像这里呢

10:35.670 --> 10:37.670
我们把个class

10:37.670 --> 10:38.670
去掉

10:38.670 --> 10:39.670
你看是不是瞬间

10:39.670 --> 10:40.670
完成变化的

10:40.670 --> 10:41.670
它没有动画

10:41.670 --> 10:42.670
那怎么办呢

10:42.670 --> 10:43.670
其实也很简单

10:43.670 --> 10:44.670
我们只需要给这个li

10:44.670 --> 10:45.670
加上一个垂水形

10:47.670 --> 10:49.670
0.2秒

10:52.110 --> 10:53.110
好 这里我们看一下

10:55.110 --> 10:56.110
你看 是不是就有了

10:56.110 --> 10:57.110
那么这里呢

10:57.110 --> 10:59.110
有一个小的小的细节

10:59.110 --> 11:01.110
为什么不把垂水形加这呢

11:01.110 --> 11:02.110
为什么不加这呢

11:02.110 --> 11:03.110
那你看一下

11:03.110 --> 11:04.110
加这的话

11:04.110 --> 11:05.110
什么情况呢

11:05.110 --> 11:06.110
就是它只有带

11:06.110 --> 11:07.110
这个内样式的时候

11:07.110 --> 11:08.110
才有动画

11:08.110 --> 11:09.110
没有这个内样式的时候

11:09.110 --> 11:10.110
是没有动画的

11:10.110 --> 11:11.110
那什么意思呢

11:12.110 --> 11:13.110
我们看

11:13.110 --> 11:14.110
如果说加这的话

11:14.110 --> 11:15.110
你看

11:15.110 --> 11:16.110
回去的时候

11:16.110 --> 11:17.110
是不是瞬间回去了

11:17.110 --> 11:18.110
只有加上它的时候

11:18.110 --> 11:19.110
也有这个动画

11:19.110 --> 11:21.110
没有这个内样式的时候

11:21.110 --> 11:23.110
它就没有过渡效果了

11:23.110 --> 11:24.110
所以说我们

11:24.110 --> 11:25.110
如果说要用过渡效果的话

11:25.110 --> 11:26.110
我们通常是

11:26.110 --> 11:28.110
把它始终保持动画效果

11:28.110 --> 11:30.110
加到它的普通样式里边

11:31.110 --> 11:32.110
那么这一块

11:33.110 --> 11:35.110
没有什么东西了

11:35.110 --> 11:36.110
那么这一块呢

11:36.110 --> 11:37.110
这有静态内容呢

11:37.110 --> 11:39.110
我们是为了样式服务的

11:39.110 --> 11:40.110
所以说静态内容

11:40.110 --> 11:41.110
我们写完之后

11:41.110 --> 11:42.110
就可以把它删掉了

11:42.110 --> 11:43.110
以后我们用JS来填充

11:43.110 --> 11:44.110
接下来

11:44.110 --> 11:45.110
张琳视频

11:45.110 --> 11:47.110
大家把它开发到这个位置

11:47.110 --> 11:48.110
把样式给它写好

11:50.110 --> 11:51.110
好 那么接下来

11:51.110 --> 11:52.110
我们就开始写这个JS了

11:52.110 --> 11:53.110
我们首先在页面上

11:53.110 --> 11:54.110
去引用这个JS

11:58.700 --> 11:59.700
JS

11:59.700 --> 12:00.700
接下来进入这个JS

12:00.700 --> 12:02.700
来看一下我们的JS代码

12:02.700 --> 12:05.530
这个JS代码

12:05.530 --> 12:06.530
怎么写

12:06.530 --> 12:08.530
是很多同学学

12:08.530 --> 12:10.530
前段开发的一个难点

12:10.530 --> 12:11.530
就是很多时候

12:11.530 --> 12:12.530
听老师讲了

12:12.530 --> 12:13.530
确实能听懂

12:13.530 --> 12:15.530
但是你自己一写

12:15.530 --> 12:16.530
就去蒙了

12:16.530 --> 12:18.530
就完全不知道怎么去下手

12:18.530 --> 12:20.530
其实我们JS代码

12:20.530 --> 12:21.530
就是我们的程序功能

12:21.530 --> 12:22.530
总的来说

12:22.530 --> 12:24.530
无论是一个页面复杂

12:24.530 --> 12:26.530
还是一个页面它简单

12:26.530 --> 12:27.530
它的功能呢

12:27.530 --> 12:29.530
无非就是这么两个过程

12:29.530 --> 12:31.530
哪两个过程呢

12:31.530 --> 12:34.530
一个就是页面初始化

12:36.530 --> 12:37.530
什么叫页面初始化

12:37.530 --> 12:39.530
就是打开这个页面过后

12:39.530 --> 12:41.530
它自动的会去完成一些事情

12:42.530 --> 12:43.530
我们不用做任何操作

12:43.530 --> 12:44.530
啥都不用管

12:44.530 --> 12:45.530
你只要打开它

12:45.530 --> 12:46.530
它就会自动去做一些事

12:46.530 --> 12:48.530
就叫做初始化操作

12:48.530 --> 12:49.530
比方说像哪些呢

12:49.530 --> 12:52.530
像我们去生成一些元素

12:52.530 --> 12:54.530
给元素添加一些内容

12:54.530 --> 12:55.530
对不对

12:55.530 --> 12:57.530
那么这些都是属于初始化操作

12:58.530 --> 13:01.530
好 第二部分是交互事件

13:02.530 --> 13:04.530
就是页面初始化完成了

13:04.530 --> 13:05.530
用户现在没动

13:05.530 --> 13:06.530
它动都没动

13:06.530 --> 13:07.530
然后可以看到页面了

13:07.530 --> 13:08.530
那么初始化就完成了

13:08.530 --> 13:10.530
完成之后呢

13:10.530 --> 13:11.530
用户它不是永远不动的

13:11.530 --> 13:13.530
它可能会去跟页面做一些互动

13:13.530 --> 13:14.530
比方说点这呢

13:14.530 --> 13:16.530
以后又点一个那个地方

13:16.530 --> 13:17.530
又点了一个按钮

13:17.530 --> 13:19.530
又把鼠标移动到某一个位置

13:19.530 --> 13:21.530
或者是以滚动来滚动条等等等等

13:21.530 --> 13:23.530
它可能会做各种各样的操作

13:23.530 --> 13:24.530
有些操作呢

13:24.530 --> 13:25.530
我们是不care的

13:25.530 --> 13:26.530
我们没有这个功能

13:26.530 --> 13:27.530
你随便做

13:27.530 --> 13:28.530
反正我不管你

13:28.530 --> 13:29.530
有些操作呢

13:29.530 --> 13:30.530
我们是需要care的

13:30.530 --> 13:31.530
是需要关心的

13:31.530 --> 13:33.530
就是它点了某个东西

13:33.530 --> 13:34.530
的时候呢

13:34.530 --> 13:35.530
我们可能会做一些事

13:35.530 --> 13:37.530
那么这一部分的叫做交互事件

13:37.530 --> 13:38.530
你看我们页面上

13:38.530 --> 13:39.530
无非就是这么两个

13:39.530 --> 13:40.530
随便哪一个页面

13:40.530 --> 13:41.530
对吧

13:41.530 --> 13:42.530
一开始它做一些事

13:42.530 --> 13:43.530
做了一大堆的事情

13:43.530 --> 13:46.530
然后呢

13:46.530 --> 13:48.530
接下来就是用户交互

13:48.530 --> 13:49.530
那么复杂页面

13:49.530 --> 13:51.530
跟简单页面的区别就在哪呢

13:51.530 --> 13:53.530
就在于初始化的内容

13:53.530 --> 13:54.530
复杂的页面

13:54.530 --> 13:55.530
初始化的事情要做的多一些

13:55.530 --> 13:57.530
有很多事情要做

13:57.530 --> 13:59.530
然后交互事件要多一些

13:59.530 --> 14:02.530
有很多地方要监听用户的事件

14:02.530 --> 14:03.530
当然页面就是这些东西

14:03.530 --> 14:04.530
稍微少一点

14:04.530 --> 14:05.530
基本上都是这两个步骤

14:05.530 --> 14:06.530
所以说呢

14:06.530 --> 14:08.530
我们在写页面的GS的话

14:08.530 --> 14:10.530
也可以按照这样的一种

14:10.530 --> 14:11.530
思路具体

14:11.530 --> 14:12.530
就是一开始我要做啥

14:12.530 --> 14:14.530
就是用户不用操作

14:14.530 --> 14:15.530
一开始我要做啥

14:15.530 --> 14:17.530
然后就是用户操作之后

14:17.530 --> 14:21.530
或者是随着某一些时间的流逝

14:21.530 --> 14:22.530
比方说这里用户

14:22.530 --> 14:24.530
其实没有多少操作

14:24.530 --> 14:25.530
但是随着时间的流逝

14:25.530 --> 14:26.530
它播放的时间流逝

14:26.530 --> 14:28.530
我们可能会做一些事

14:28.530 --> 14:30.530
无非就是这么两个情况

14:30.530 --> 14:31.530
那么这里呢

14:31.530 --> 14:32.530
全局边上污染

14:32.530 --> 14:34.530
我可以把所有东西写到

14:34.530 --> 14:37.970
一个立即执行函数里面

14:37.970 --> 14:38.970
在这里吧

14:38.970 --> 14:40.970
然后把个弹码扔进来

14:40.970 --> 14:44.860
这个弹码我们一会再说

14:44.860 --> 14:47.860
首先我们进行第一步初始化

14:47.860 --> 14:48.860
好

14:48.860 --> 14:51.860
后边就是交互事件

14:51.860 --> 14:52.860
对吧 五分就两步

14:52.860 --> 14:54.860
好 第一步初始化

14:54.860 --> 14:56.860
初始化的时候呢

14:56.860 --> 14:57.860
我们也可以在这里

14:57.860 --> 14:58.860
一开始

14:58.860 --> 14:59.860
因为这个是立即执行函数

14:59.860 --> 15:01.860
所以它一开始会运行很多弹码

15:01.860 --> 15:02.860
也可以把它

15:02.860 --> 15:05.860
直接把弹码写到这儿

15:05.860 --> 15:07.860
也可以把它封装成一个函数

15:07.860 --> 15:09.860
叫做音列子

15:09.860 --> 15:11.860
以后我们去调用这个函数用来说

15:11.860 --> 15:13.860
就这么一回事

15:13.860 --> 15:15.860
好 那么接下来我们来思考一下

15:15.860 --> 15:17.860
在这个效果里边

15:17.860 --> 15:19.860
初始化一开始就用户不动

15:19.860 --> 15:22.860
它要做什么事

15:22.860 --> 15:23.860
你看要做什么事

15:23.860 --> 15:25.860
是不是最容易看到的就是

15:25.860 --> 15:29.860
我要去把歌词生成很多的Li

15:29.860 --> 15:32.860
加到一个容器UL里边

15:32.860 --> 15:33.860
对不对

15:33.860 --> 15:34.860
那么这里肯定是有很多问题

15:34.860 --> 15:35.860
第一个问题就是

15:35.860 --> 15:37.860
我首先得拿到这个UL

15:37.860 --> 15:39.860
以后我要把东西往里边加

15:39.860 --> 15:40.860
那么这个UL呢

15:40.860 --> 15:43.860
我们就可以把它放到一个

15:43.860 --> 15:44.860
元素里边

15:44.860 --> 15:47.860
放到一个动物室里边

15:47.860 --> 15:48.860
因为我们以后呢

15:48.860 --> 15:49.860
或许动物还不止一个

15:49.860 --> 15:51.860
所以把它封装到一个对象里边

15:51.860 --> 15:52.860
用Documents

15:52.860 --> 15:54.860
Claris and later

15:54.860 --> 15:56.860
这个函数非常非常好用

15:56.860 --> 15:57.860
大家用说

15:57.860 --> 15:59.860
LC

15:59.860 --> 16:01.860
是不是就可以拿到这个UL了

16:01.860 --> 16:02.860
对吧

16:02.860 --> 16:03.860
一会儿我就往这个UL

16:03.860 --> 16:04.860
不断的去放Li

16:04.860 --> 16:06.860
那么初始化的时候

16:06.860 --> 16:07.860
你看我现在有UL了

16:07.860 --> 16:08.860
接下来我们要干嘛呢

16:08.860 --> 16:11.860
就是拿到歌词

16:11.860 --> 16:15.860
生成Li

16:15.860 --> 16:17.860
放入到UL中

16:17.860 --> 16:19.860
是不是要做这么一件事

16:19.860 --> 16:21.860
好 第一个问题

16:21.860 --> 16:23.860
歌词哪来

16:23.860 --> 16:25.860
我这个工程里面肯定是没有的

16:25.860 --> 16:27.860
那么歌词哪来的

16:27.860 --> 16:28.860
这个函数要用上

16:28.860 --> 16:30.860
这个函数是我给你写好的函数

16:30.860 --> 16:32.860
里边代码还看不懂

16:32.860 --> 16:33.860
将来你们学到网络之后

16:33.860 --> 16:34.860
你们就看懂了

16:34.860 --> 16:37.860
从网络中去获取到歌词

16:37.860 --> 16:40.860
当然有些东西可能很好奇

16:40.860 --> 16:42.860
如果说要获取其他歌的歌词

16:42.860 --> 16:43.860
怎么办呢

16:43.860 --> 16:44.860
你自己去百度

16:44.860 --> 16:45.860
百度去找

16:45.860 --> 16:46.860
因为我这个歌词

16:46.860 --> 16:47.860
是百度去找了

16:47.860 --> 16:48.860
下载下来

16:48.860 --> 16:50.860
放到我独一的服务器上的

16:50.860 --> 16:51.860
所以说我们就请求

16:51.860 --> 16:52.860
独一的服务器拿到这个歌词

16:52.860 --> 16:54.860
我们就做这个效果就OK了

16:55.860 --> 16:57.860
将来你如果说学到漏的

16:57.860 --> 16:58.860
学到漏的这些时候

16:58.860 --> 16:59.860
说你要自己开发服务器

16:59.860 --> 17:00.860
那如果说你要歌词的话

17:00.860 --> 17:02.860
你把你的歌词下载下来

17:02.860 --> 17:04.860
放到你的服务器就OK

17:04.860 --> 17:05.860
现在我们

17:05.860 --> 17:07.860
冲过这个函数可以打歌词

17:07.860 --> 17:09.860
那么这个函数怎么用呢

17:09.860 --> 17:11.860
就你不会写这个函数没事

17:11.860 --> 17:12.860
但是你至少要知道

17:12.860 --> 17:14.860
这个函数怎么用

17:14.860 --> 17:15.860
通过看这个注释

17:15.860 --> 17:17.860
从网络中获取歌词

17:17.860 --> 17:18.860
就是它的含义

17:18.860 --> 17:19.860
关键点在哪

17:19.860 --> 17:21.860
关键点在这里

17:21.860 --> 17:23.860
它反过来是一个Promise

17:24.860 --> 17:25.860
这里标记了Essink

17:25.860 --> 17:27.860
其实通过这个Essink关键字也知道

17:27.860 --> 17:29.860
凡是标记了Essink

17:29.860 --> 17:30.860
比较关键字的函数

17:30.860 --> 17:32.860
它一定反回Promise

17:32.860 --> 17:34.860
对不对

17:34.860 --> 17:36.860
那么我们怎么用这个函数

17:36.860 --> 17:38.860
是不是我们D2用这个函数

17:39.860 --> 17:40.860
它反过来Promise

17:40.860 --> 17:41.860
那么我们是不是可以

17:41.860 --> 17:43.860
这样子有两种用法

17:43.860 --> 17:44.860
一种是使用Zing

17:44.860 --> 17:46.860
等它Promise完成

17:46.860 --> 17:47.860
完成之后

17:47.860 --> 17:49.860
它会把歌词给我

17:49.860 --> 17:50.860
那么我这里

17:50.860 --> 17:52.860
用函数来接受一下

17:52.860 --> 17:53.860
这样子我们是不是可以

17:53.860 --> 17:54.860
拿到这个歌词

17:54.860 --> 17:55.860
好看一下

17:55.860 --> 17:56.860
控制台

17:57.860 --> 17:59.860
你看是不是拿到这个歌词了

17:59.860 --> 18:00.860
是一个很长很长的

18:00.860 --> 18:01.860
一个字不错

18:01.860 --> 18:02.860
对不对

18:02.860 --> 18:03.860
拿到了

18:03.860 --> 18:05.860
好也可以就是

18:05.860 --> 18:07.860
利用Es7的

18:07.860 --> 18:08.860
而位置关键字

18:08.860 --> 18:09.860
我等待

18:09.860 --> 18:10.860
你不是一个Promise吗

18:10.860 --> 18:11.860
我等待你

18:11.860 --> 18:12.860
等待你完成

18:12.860 --> 18:14.860
等待完成过后

18:14.860 --> 18:15.860
它要等一会

18:15.860 --> 18:17.860
等一会完成过后

18:17.860 --> 18:19.860
你把你反回的歌词

18:19.860 --> 18:21.860
我保存到一个变量里面

18:21.860 --> 18:23.860
这样子不使用回调了

18:29.830 --> 18:30.830
爆错

18:30.830 --> 18:32.830
怎么会爆错呢

18:32.830 --> 18:34.830
这里是不是爆错了

18:34.830 --> 18:35.830
为什么爆错

18:35.830 --> 18:36.830
因为而位置关键字

18:36.830 --> 18:37.830
是不是必须要放到Ersync

18:37.830 --> 18:38.830
函数里面

18:38.830 --> 18:39.830
这里要标记Ersync

18:39.830 --> 18:40.830
那么这样子一标记了

18:40.830 --> 18:41.830
这个函数

18:41.830 --> 18:42.830
它反过来也是Promise

18:46.360 --> 18:48.360
你看还是拿到一个字幕串

18:48.360 --> 18:49.360
这个字幕串

18:49.360 --> 18:50.360
什么意思

18:50.360 --> 18:51.360
它每一行就表示

18:51.360 --> 18:53.360
有一个这么一个东西

18:53.360 --> 18:55.360
它表示几分

18:55.360 --> 18:56.360
几秒

18:56.360 --> 18:58.360
这个秒是包含小数点的

18:58.360 --> 19:01.360
几分几秒出现什么样的歌词

19:01.360 --> 19:03.360
几分几秒出现什么样的歌词

19:03.360 --> 19:04.360
变成这个样子

19:05.360 --> 19:07.360
那么这次我们就拿到这个字幕串了

19:08.360 --> 19:09.360
接下来大家

19:10.360 --> 19:12.360
理解我这一块的代码

19:12.360 --> 19:14.360
然后把它写到这个位置

19:14.360 --> 19:15.360
你可以不跟我一样

19:15.360 --> 19:17.360
代码可以不用跟我一样

19:17.360 --> 19:18.360
按照你自己的想法写

19:18.360 --> 19:19.360
但是一定要理解我的代码

19:19.360 --> 19:20.360
充分理解

19:21.360 --> 19:22.360
好了没

19:23.360 --> 19:24.360
那么我们继续来写

19:25.360 --> 19:26.360
我们现在目前手上

19:26.360 --> 19:27.360
有的是一个什么

19:27.360 --> 19:28.360
有的是一个字幕串

19:28.360 --> 19:30.360
一个很长的字幕串

19:30.360 --> 19:31.360
但是我们要用

19:31.360 --> 19:32.360
做的是什么

19:32.360 --> 19:33.360
做成一个一个的Li

19:34.360 --> 19:35.360
对不对

19:35.360 --> 19:37.360
而做Li的时候

19:37.360 --> 19:39.360
需不需要知道这个时间

19:40.360 --> 19:41.360
实际上是不需要知道的

19:41.360 --> 19:42.360
一开始是不需要知道的

19:42.360 --> 19:44.360
你看一开始需要知道时间

19:44.360 --> 19:45.360
不需要知道

19:45.360 --> 19:46.360
我就生成很多很多的Li

19:46.360 --> 19:47.360
该加进于心的

19:48.360 --> 19:49.360
那么这里的

19:49.360 --> 19:50.360
需要我们做一些提前

19:51.360 --> 19:52.360
考虑的提前量

19:52.360 --> 19:53.360
什么要考虑的提前量

19:53.360 --> 19:54.360
就是说

19:54.360 --> 19:55.360
如果说我现在只考虑

19:56.360 --> 19:57.360
把这个Li加进去

19:58.360 --> 19:59.360
其实不难

19:59.360 --> 20:00.360
我们可以很快的

20:00.360 --> 20:01.360
把这件事情完成

20:02.360 --> 20:03.360
但是如果说

20:03.360 --> 20:04.360
我们只考虑这一点的话

20:04.360 --> 20:05.360
我们后续可以麻烦了

20:06.360 --> 20:07.360
因为后续我们要

20:08.360 --> 20:09.360
更改这个时间

20:10.360 --> 20:11.360
更改这个时间过后了

20:12.360 --> 20:13.360
我现在手上

20:13.360 --> 20:14.360
比方时间改了

20:14.360 --> 20:15.360
改到55秒了

20:15.360 --> 20:16.360
但是我手上只有一堆的Li

20:17.360 --> 20:18.360
我没有其他东西了

20:18.360 --> 20:19.360
一堆Li

20:19.360 --> 20:20.360
那这个Li里面

20:20.360 --> 20:21.360
是不是我们看不到

20:21.360 --> 20:22.360
跟时间相关的东西

20:22.360 --> 20:24.360
那我到底要显示哪个Li

20:25.360 --> 20:26.360
要高量显示哪个Li

20:26.360 --> 20:27.360
是不是我们这个逻辑上

20:27.360 --> 20:28.360
就做不到

20:28.360 --> 20:29.360
我少了一些数据

20:29.360 --> 20:30.360
我把这个东西扔了

20:30.360 --> 20:31.360
我把前面这个东西扔了

20:31.360 --> 20:33.360
我只要后边那个值生成Li

20:33.360 --> 20:35.360
那后边我们只有Li

20:35.360 --> 20:36.360
有这个时间

20:36.360 --> 20:38.360
那我有个时间从哪里去比对呢

20:38.360 --> 20:40.360
先不说怎么去比对

20:40.360 --> 20:41.360
那是后话

20:41.360 --> 20:42.360
但是我至少得有时间

20:42.360 --> 20:43.360
进行比对吧

20:44.360 --> 20:45.360
懂这个意思吧

20:45.360 --> 20:46.360
所以说我们这里

20:46.360 --> 20:48.360
要考虑一些提前量

20:48.360 --> 20:50.360
我这里能打算这样做

20:50.360 --> 20:51.360
你听我的思路

20:53.360 --> 20:54.360
老师

20:54.360 --> 20:55.360
你这么能想到这些

20:55.360 --> 20:56.360
为什么我想不到了

20:56.360 --> 20:58.360
这是一个开发经验的问题

20:58.360 --> 20:59.360
慢慢来

20:59.360 --> 21:00.360
放得一口一口的湿

21:00.360 --> 21:02.360
路得一步一步的走

21:02.360 --> 21:03.360
不卖得还要大

21:03.360 --> 21:04.360
容易扯得大

21:04.360 --> 21:06.360
所以说你先跟着我的思路来做

21:06.360 --> 21:08.360
你只要能够把我的练习题

21:08.360 --> 21:09.360
听到我的思路

21:09.360 --> 21:10.360
并且能够

21:10.360 --> 21:11.360
按照我的思路

21:11.360 --> 21:12.360
把它写出来就非常OK了

21:13.360 --> 21:14.360
好 那么接下来

21:14.360 --> 21:15.360
我要做这么一件事

21:15.360 --> 21:16.360
挺好

21:16.360 --> 21:17.360
我手上拿到这个制服串

21:17.360 --> 21:19.360
我要把这个制服串

21:19.360 --> 21:20.360
转换成这个对象

21:22.670 --> 21:24.670
将LRC

21:24.670 --> 21:26.670
转换成一个数组

21:27.670 --> 21:28.670
数组有很多项

21:28.670 --> 21:30.670
每一项是一个对象

21:30.670 --> 21:32.670
后面有很多项

21:32.670 --> 21:33.670
每一项呢

21:33.670 --> 21:34.670
它是一个对象

21:34.670 --> 21:36.670
这个对象里面有两个属性

21:36.670 --> 21:37.670
一个是10

21:38.670 --> 21:39.670
时间

21:40.670 --> 21:41.670
你先别管为什么这样做

21:41.670 --> 21:43.670
我现在就是要求你这样做

21:43.670 --> 21:45.670
其实我们一个再复杂的东西

21:45.670 --> 21:46.670
它都可以把它分解成

21:46.670 --> 21:48.670
一个一个的小的功能

21:49.670 --> 21:50.670
就好像做题一样

21:50.670 --> 21:52.670
大题可以分建成很多小题

21:52.670 --> 21:54.670
无非整个过程就是先分解

21:54.670 --> 21:56.670
然后再实现没到小题

21:56.670 --> 21:57.670
就把整个功能做出来了

21:59.670 --> 22:00.670
有两个属性

22:00.670 --> 22:01.670
一个是时间

22:01.670 --> 22:03.670
比方说这个时间

22:03.670 --> 22:05.670
它就会变成1.06

22:08.110 --> 22:09.110
表示1.06秒

22:09.110 --> 22:10.110
像这个时间

22:10.110 --> 22:13.110
就是1分26秒09

22:13.110 --> 22:15.110
那就是1分就是60秒

22:15.110 --> 22:17.110
60秒的话就是86.09

22:19.550 --> 22:20.550
明白我的意思吗

22:20.550 --> 22:21.550
它有很多这样的一个对象

22:21.550 --> 22:22.550
每个对象里面有两个属性

22:22.550 --> 22:23.550
一个是10

22:23.550 --> 22:24.550
它对应的时间

22:24.550 --> 22:25.550
秒数

22:25.550 --> 22:26.550
另一个是Words

22:26.550 --> 22:28.550
它歌词的内容

22:28.550 --> 22:29.550
它是一个字幕刺

22:29.550 --> 22:30.550
比较要到这里的

22:30.550 --> 22:31.550
就这个字幕刺

22:32.550 --> 22:33.550
明白我的意思吗

22:33.550 --> 22:34.550
现在我要做的事情

22:34.550 --> 22:36.550
已经很明确了

22:36.550 --> 22:38.550
就是我要把这个东西

22:39.550 --> 22:40.550
LRC

22:41.550 --> 22:42.550
这个东西

22:42.550 --> 22:45.550
转变成这么一个数组

22:46.550 --> 22:47.550
我们怎么来转变

22:48.550 --> 22:49.550
同学们可以想一想

22:49.550 --> 22:50.550
甚至可以暂停视频

22:50.550 --> 22:51.550
尝试一下

22:51.550 --> 22:53.550
看自己能不能把它转换出来

22:53.550 --> 22:54.550
然后再来听我讲

22:55.550 --> 22:57.930
有没有想到办法

22:57.930 --> 22:58.930
其实我们可以这样子

22:59.930 --> 23:00.930
因为你看这是一个字幕刺刷

23:00.930 --> 23:01.930
那么这个字幕刺刷

23:01.930 --> 23:02.930
每一行

23:02.930 --> 23:03.930
是不是就相当于

23:03.930 --> 23:04.930
对应这个对象里面的

23:04.930 --> 23:05.930
每一个对象

23:05.930 --> 23:06.930
对对对应到这里的

23:06.930 --> 23:07.930
每一个对象

23:07.930 --> 23:08.930
所以说我们先把它

23:08.930 --> 23:09.930
按航来分割

23:10.930 --> 23:11.930
Split

23:11.930 --> 23:12.930
用什么来分割

23:12.930 --> 23:13.930
写个N

23:13.930 --> 23:14.930
对吧

23:14.930 --> 23:15.930
半航服来进行分割

23:15.930 --> 23:16.930
那么我们来看一下result

23:17.930 --> 23:18.930
输出一下result

23:20.930 --> 23:21.930
是不是就形成了一个数组了

23:22.930 --> 23:23.930
对不对

23:23.930 --> 23:25.930
按照每一行进行分割

23:25.930 --> 23:26.930
然后我们会发现

23:26.930 --> 23:28.930
数组里面可能有一些空航

23:28.930 --> 23:29.930
空航对我们来说

23:29.930 --> 23:30.930
是没有任何意义的

23:30.930 --> 23:31.930
像这种地方

23:31.930 --> 23:32.930
是不是空航

23:32.930 --> 23:33.930
纯粹的空航

23:33.930 --> 23:34.930
啥内容都没有

23:34.930 --> 23:35.930
那么像这种情况

23:35.930 --> 23:36.930
我都可以理解

23:36.930 --> 23:37.930
就这一句没有歌词

23:38.930 --> 23:39.930
可以理解

23:39.930 --> 23:40.930
那这个东西就是

23:40.930 --> 23:42.930
纯粹的是无销的东西了

23:42.930 --> 23:43.930
那么我们把

23:43.930 --> 23:45.930
我们是不是要把这个去

23:45.930 --> 23:46.930
那怎么去

23:46.930 --> 23:47.930
你看

23:47.930 --> 23:48.930
现在这是一个数组

23:48.930 --> 23:50.930
我们是不是可以利用filt

23:50.930 --> 23:51.930
仅筛选

23:51.930 --> 23:52.930
保留什么

23:53.930 --> 23:55.930
保留有值的那一行

23:55.930 --> 23:56.930
没有值的那一行

23:56.930 --> 23:57.930
我就扔掉了

23:58.930 --> 23:59.930
那这里怎么行

23:59.930 --> 24:03.010
就完了

24:03.010 --> 24:04.010
只要这个制服串

24:04.010 --> 24:05.010
布尔判定为真

24:05.010 --> 24:06.010
你看这个filt

24:06.010 --> 24:07.010
反回来不是

24:07.010 --> 24:09.010
又是一个布尔判定吗

24:09.010 --> 24:10.010
我每一个制服串拿到

24:10.010 --> 24:12.010
我看一下这个制服串

24:12.010 --> 24:13.010
直接把这个制服串返回

24:13.010 --> 24:14.010
如果这个制服串

24:14.010 --> 24:15.010
本身判定为真

24:15.010 --> 24:17.010
说明这个制服串有值

24:17.010 --> 24:18.010
有值我就保留

24:18.010 --> 24:19.010
没有值我就去掉

24:19.010 --> 24:20.010
那你看一下

24:20.010 --> 24:21.010
现在是不是空航就没了

24:21.010 --> 24:22.010
第一个空航没了

24:23.010 --> 24:24.010
对不对

24:24.010 --> 24:25.010
空航没了过后

24:25.010 --> 24:26.010
现在我们已经

24:26.010 --> 24:28.010
越来越接近了

24:28.010 --> 24:31.010
形成了一个制服串的数组

24:31.010 --> 24:33.010
那么现在我要做的是啥

24:33.010 --> 24:39.050
我要做的无非就是

24:39.050 --> 24:43.960
我要做的无非就是

24:44.960 --> 24:46.960
把制服串的每一项

24:46.960 --> 24:49.960
生成一个对象

24:49.960 --> 24:50.960
对不对

24:50.960 --> 24:51.960
把制服串的每一项

24:51.960 --> 24:52.960
生成一个对象

24:52.960 --> 24:53.960
是不是要做印射

24:53.960 --> 24:56.960
一个制服串变成一个对象

24:56.960 --> 24:57.960
对吧

24:57.960 --> 24:58.960
接下来来做这个印射

24:58.960 --> 24:59.960
印射用什么

24:59.960 --> 25:00.960
就是用MAP

25:00.960 --> 25:01.960
针对前面的这个数组

25:01.960 --> 25:03.960
我们继续用MAP

25:03.960 --> 25:04.960
进行链识变成

25:04.960 --> 25:05.960
你给我一个制服串

25:05.960 --> 25:07.960
我要给你返回一个什么的

25:07.960 --> 25:09.960
我要给你返回一个对象

25:09.960 --> 25:10.960
你看我现在

25:10.960 --> 25:11.960
就这样子写的话

25:11.960 --> 25:12.960
就已经出来了

25:12.960 --> 25:13.960
数组里面

25:13.960 --> 25:14.960
每个每项有一个对象

25:14.960 --> 25:16.960
不过这目前是个空对象

25:16.960 --> 25:17.960
那么接下来的问题就是

25:17.960 --> 25:20.960
我拿到这个制服串了

25:20.960 --> 25:22.960
我可能输出一下

25:22.960 --> 25:23.960
什么拿到这个每一行

25:23.960 --> 25:24.960
拿到这个制服串了

25:24.960 --> 25:25.960
拿到这个制服串过后

25:25.960 --> 25:26.960
制服串过后

25:26.960 --> 25:27.960
我怎么样把它变成

25:27.960 --> 25:29.960
这个一个对象呢

25:29.960 --> 25:31.960
来我们又来

25:31.960 --> 25:32.960
首先我们第一步

25:32.960 --> 25:34.960
是不是可以把这个制服串

25:34.960 --> 25:35.960
按照什么时候来分割

25:35.960 --> 25:37.960
按照这个U中扩号

25:37.960 --> 25:38.960
来进行分割

25:38.960 --> 25:39.960
分割成两个部分

25:39.960 --> 25:40.960
一个是时间

25:40.960 --> 25:42.960
一个是内容

25:42.960 --> 25:43.960
对吧

25:43.960 --> 25:45.960
所以说我们这里分割一下

25:45.960 --> 25:49.780
叫做S-part

25:49.780 --> 25:53.100
S-part嘛

25:55.100 --> 25:57.100
S-split

25:57.100 --> 25:58.100
U中扩号

25:58.100 --> 25:59.100
U中扩号

25:59.100 --> 26:00.100
来进行分割

26:00.100 --> 26:01.100
我们来输出一下

26:01.100 --> 26:04.100
part

26:04.100 --> 26:05.100
你看

26:05.100 --> 26:07.100
这样子是不是把分割成这个样子

26:07.100 --> 26:08.100
那么输出的第二项

26:08.100 --> 26:10.100
是不是就是

26:10.100 --> 26:11.100
我们的歌词

26:11.100 --> 26:12.100
所以对象里面

26:12.100 --> 26:14.100
这个属性就已经出来了

26:14.100 --> 26:18.100
part1

26:18.100 --> 26:20.100
你看

26:20.100 --> 26:21.100
保存

26:21.100 --> 26:22.100
你看下面的数组里面

26:22.100 --> 26:23.100
生成

26:23.100 --> 26:25.100
没保存

26:25.100 --> 26:26.100
生成下面的数组里面

26:26.100 --> 26:27.100
你看对象里面

26:28.100 --> 26:30.100
那么还有个属性叫Time

26:30.100 --> 26:31.100
Time的话

26:31.100 --> 26:32.100
我们这里分割出来过后

26:32.100 --> 26:34.100
它的第一项

26:34.100 --> 26:35.100
把这个去掉

26:35.100 --> 26:38.100
是不是就形成了一个制服串的时间

26:38.100 --> 26:39.100
对吧

26:39.100 --> 26:40.100
我们第一项是

26:40.100 --> 26:41.100
对我们来说没有意义

26:41.100 --> 26:42.100
对不对

26:42.100 --> 26:43.100
所以说我们这里

26:43.100 --> 26:44.100
针对第一项时间

26:44.100 --> 26:46.100
我们来看一下怎么来处理

26:46.100 --> 26:48.100
首先我们拿到

26:48.100 --> 26:50.100
Time Part

26:50.100 --> 26:52.100
Time的一块

26:52.100 --> 26:55.100
Time Stream

26:55.100 --> 26:57.100
Part 0

26:57.100 --> 26:58.100
Replace

26:58.100 --> 27:00.100
就把第一项

27:00.100 --> 27:01.100
它那个中货号

27:01.100 --> 27:03.100
左中货号给它去掉

27:03.100 --> 27:04.100
这样子一去的话

27:04.100 --> 27:06.100
我们看一下Time Stream

27:06.100 --> 27:08.100
那么这里是不是

27:08.100 --> 27:09.100
时间拿到了

27:09.100 --> 27:10.100
一个制服串

27:10.100 --> 27:11.100
是一个制服串的时间

27:11.100 --> 27:12.100
但是我们要的是

27:12.100 --> 27:13.100
制服串的时间吗

27:13.100 --> 27:14.100
不是吧

27:14.100 --> 27:15.100
我们要的是这个

27:15.100 --> 27:16.100
一个数字

27:16.100 --> 27:18.100
那又怎么拿呢

27:18.100 --> 27:19.100
你看啊

27:19.100 --> 27:20.100
又怎么拿呢

27:20.100 --> 27:22.100
我们是不是又可以把

27:22.100 --> 27:23.100
这个制服串

27:23.100 --> 27:24.100
按照冒号来分割

27:24.100 --> 27:25.100
分割成左右两个部分

27:25.100 --> 27:28.100
左边是秒数

27:28.100 --> 27:29.100
左边是分钟

27:29.100 --> 27:30.100
右边是秒数

27:30.100 --> 27:31.100
对吧

27:31.100 --> 27:32.100
好那么接下来呢

27:32.100 --> 27:34.100
我们把这个制服串

27:34.100 --> 27:35.100
拿到这个制服串

27:35.100 --> 27:36.100
再进行分割

27:36.100 --> 27:38.100
Split

27:38.100 --> 27:40.100
用什么分割冒号

27:40.100 --> 27:42.100
这样子拿到一个

27:42.100 --> 27:46.100
时间的数组

27:46.100 --> 27:48.100
你看

27:48.100 --> 27:49.100
这个数组里边

27:49.100 --> 27:50.100
第一项是分钟

27:50.100 --> 27:51.100
第二项呢

27:51.100 --> 27:52.100
是秒数

27:54.600 --> 27:55.600
出来了没

27:55.600 --> 27:57.600
那不就出来了吗

27:57.600 --> 28:00.600
时间是多少

28:00.600 --> 28:02.600
我先把第一项

28:02.600 --> 28:03.600
这个数组的第一项

28:03.600 --> 28:05.600
转换成数字

28:05.600 --> 28:07.600
把第一项转换成数字

28:07.600 --> 28:09.600
然后乘以60

28:09.600 --> 28:11.600
因为它第一项是分钟嘛

28:11.600 --> 28:13.600
乘以60就变成秒数了

28:13.600 --> 28:15.600
第一项得到了秒数

28:15.600 --> 28:17.600
加上第二项

28:17.600 --> 28:18.600
第二项直接转换成数字

28:18.600 --> 28:19.600
就完事了

28:20.600 --> 28:22.600
就完事了

28:22.600 --> 28:24.600
看一下

28:24.600 --> 28:27.300
你看

28:27.300 --> 28:28.300
TEM是不是出来了

28:28.300 --> 28:29.300
VIRT是不是有了

28:29.300 --> 28:30.300
有些地方呢

28:30.300 --> 28:31.300
因为我们知道

28:31.300 --> 28:32.300
小数运算计算计的

28:32.300 --> 28:33.300
里边是不精确的

28:33.300 --> 28:35.300
有一些不精确的结果

28:35.300 --> 28:36.300
无所谓

28:36.300 --> 28:38.300
这我们也没和必要去

28:38.300 --> 28:40.300
究竟那么小的物差

28:40.300 --> 28:42.300
那么这个数组就有了

28:42.300 --> 28:43.300
这个数组很重要啊

28:43.300 --> 28:45.300
这个数组我们后面还要用的

28:45.300 --> 28:46.300
不是说这一块

28:46.300 --> 28:47.300
我初始化的时候

28:47.300 --> 28:48.300
我用一下就没了

28:48.300 --> 28:50.300
我们后面还要接着用的

28:50.300 --> 28:52.300
比方说播放到一定时间的时候

28:52.300 --> 28:53.300
我要从这个数组里面去找

28:53.300 --> 28:55.300
对应到哪句歌词

28:55.300 --> 28:56.300
这很重要的啊

28:56.300 --> 28:57.300
所以这个数组呢

28:57.300 --> 28:59.300
我不仅仅是在这里边要用

28:59.300 --> 29:01.300
我要把它保存到外面

29:02.300 --> 29:05.300
叫做LRCData吧

29:05.300 --> 29:06.300
我要把它复制到外面

29:06.300 --> 29:08.300
一会儿其他函数

29:08.300 --> 29:09.300
不光是初始化的时候要用

29:09.300 --> 29:11.300
其他函数也要用

29:11.300 --> 29:13.300
所以说我们把它保存到这

29:14.300 --> 29:15.300
接下来我们输出它

29:15.300 --> 29:18.800
当然像我是完全一样的

29:18.800 --> 29:19.800
那么接下来的同学们

29:19.800 --> 29:21.800
暂停视频

29:21.800 --> 29:22.800
把它做到这一步

29:22.800 --> 29:24.800
就不管你用什么样的方式

29:24.800 --> 29:25.800
这种方式很多啊

29:25.800 --> 29:27.800
我用到了大量的ES5的

29:27.800 --> 29:29.800
一些函数来实现

29:29.800 --> 29:31.800
当然你也可以用非常传统的方式

29:31.800 --> 29:32.800
就一行一行循环

29:32.800 --> 29:33.800
一行一行处理

29:33.800 --> 29:34.800
也没事

29:34.800 --> 29:35.800
总之你还把它完成

29:36.800 --> 29:37.800
好那么

29:37.800 --> 29:39.800
同学们自己搞定啊

29:40.800 --> 29:41.800
搞定没

29:42.800 --> 29:44.800
好那么我们接下来啊

29:44.800 --> 29:45.800
现在我们有了

29:45.800 --> 29:47.800
这个数组其实很多事情

29:47.800 --> 29:48.800
那就好做了

29:48.800 --> 29:49.800
我们知道现在在做什么

29:49.800 --> 29:50.800
在做初始化

29:50.800 --> 29:52.800
就是一开始要做的事情

29:52.800 --> 29:54.800
一开始我们要做的事情

29:54.800 --> 29:55.800
一开始我现在在这里

29:55.800 --> 29:56.800
Li都没有

29:56.800 --> 29:57.800
那么现在我们回到一开始的任务

29:57.800 --> 29:58.800
我们要干嘛

29:58.800 --> 30:00.800
我们要生成Li

30:01.800 --> 30:02.800
生成Li是不是

30:02.800 --> 30:03.800
加到这个Ul里面去

30:03.800 --> 30:04.800
那怎么弄啊

30:05.800 --> 30:06.800
我来这里

30:07.800 --> 30:08.800
生成Li

30:08.800 --> 30:10.800
加入到Ul中

30:11.800 --> 30:12.800
怎么弄呢

30:13.800 --> 30:15.800
我们其实也可以循环这个数组

30:15.800 --> 30:16.800
你看我们之前不是生成了

30:16.800 --> 30:17.800
一个数组吗

30:17.800 --> 30:18.800
对不对

30:18.800 --> 30:19.800
这个数组是不是可以循环

30:19.800 --> 30:20.800
那么循环这个数组

30:20.800 --> 30:22.800
每循环一次生成一个Li

30:22.800 --> 30:24.800
然后给Li复制一个文本乌尔子

30:24.800 --> 30:26.800
然后把它加到这个Ul里面去

30:26.800 --> 30:27.800
这个不难吧

30:27.800 --> 30:29.800
很多人应该都做得出来啊

30:29.800 --> 30:31.800
都觉得太麻烦了

30:31.800 --> 30:34.800
我希望就直接给我生成一个字乌串

30:34.800 --> 30:35.800
然后给这个doms

30:35.800 --> 30:36.800
Ul

30:36.800 --> 30:37.800
Inner

30:37.800 --> 30:38.800
Atm复制就完事了

30:39.800 --> 30:40.800
给它复制就完事了

30:41.800 --> 30:42.800
那我怎么来生成

30:42.800 --> 30:43.800
快速生成这个字乌串呢

30:43.800 --> 30:45.800
接下来我们来看一下啊

30:45.800 --> 30:47.800
怎么来快速生成这个字乌串

30:47.800 --> 30:49.800
这也是一种开发技巧

30:49.800 --> 30:50.800
我们现在有的是什么呢

30:50.800 --> 30:52.800
所以有的是这个数组

30:53.800 --> 30:55.800
数组每一项是个对象

30:56.800 --> 30:58.800
我现在不希望数组每一项是个对象

30:58.800 --> 31:00.800
我要把它变成一个Li

31:01.800 --> 31:02.800
做什么

31:02.800 --> 31:03.800
是不是做印射

31:03.800 --> 31:04.800
一个对象

31:04.800 --> 31:06.800
印射到一个

31:06.800 --> 31:08.800
Atm字乌串

31:08.800 --> 31:10.800
所以做Map印射

31:11.800 --> 31:13.800
对每一句歌词

31:13.800 --> 31:14.800
我们生成什么

31:14.800 --> 31:16.800
生成一个字乌串

31:16.800 --> 31:17.800
这个字乌串是这个样子的

31:19.800 --> 31:20.800
Li

31:20.800 --> 31:22.800
Li里边让我们拼接一个什么

31:22.800 --> 31:23.800
Lrc的Words

31:25.800 --> 31:26.800
输出一下这个招式

31:26.800 --> 31:27.800
你看一下

31:27.800 --> 31:29.800
这就是我想象的东西

31:30.800 --> 31:32.800
你看数组的每一项

31:32.800 --> 31:34.800
用印射过后就变成了一个Li了

31:35.800 --> 31:37.800
然后有了这个数组之后

31:37.800 --> 31:39.800
我们再把这个数组呢用交影

31:40.800 --> 31:41.800
是不是连接起来

31:41.800 --> 31:43.800
比方说我用兜号连接

31:43.800 --> 31:44.800
那就变成这个样子了

31:44.800 --> 31:45.800
每个Lrc有个兜号

31:45.800 --> 31:47.800
如果说我用一个空字乌串连接的话

31:47.800 --> 31:48.800
那么就是

31:49.800 --> 31:51.800
一次把数组的每一项写出来

31:51.800 --> 31:53.800
那么这就是一个字乌串

31:53.800 --> 31:55.800
我要做的就是把这个字乌串复制给谁

31:55.800 --> 31:57.800
复制给动物

31:57.800 --> 31:59.800
6L

31:59.800 --> 32:02.800
就是像ES5的很多这种方法

32:02.800 --> 32:04.800
都可以极大的减化我们的初写

32:06.800 --> 32:10.560
你看是不是就出来了

32:11.560 --> 32:13.560
那么初始化的工作

32:13.560 --> 32:15.560
其实就已经完成了

32:15.560 --> 32:17.560
这是我们第一步

32:17.560 --> 32:19.560
初始化就是我们用户不做任何操作

32:19.560 --> 32:22.560
一开始已经给他做了一些事情

32:22.560 --> 32:23.560
好 同学们呢

32:23.560 --> 32:25.560
把淡满了开发到这一步

32:25.560 --> 32:27.560
把初始化完成

32:27.560 --> 32:30.000
好了呗

32:31.000 --> 32:34.000
完成了初始化之后呢

32:34.000 --> 32:36.000
我们现在要做交互时间了

32:37.000 --> 32:38.000
这里涉及到什么事情

32:38.000 --> 32:40.000
现在首先要搞清楚

32:40.000 --> 32:43.000
交互时间无非就是两个地方吧

32:43.000 --> 32:44.000
第一个

32:46.700 --> 32:48.700
就是什么事情

32:48.700 --> 32:50.700
到底有哪些事情我们要去监听

32:50.700 --> 32:53.700
第二个就是干什么

32:54.700 --> 32:56.700
就是如何处理

32:56.700 --> 32:58.700
什么事件如何处理

32:58.700 --> 32:59.700
就把这两个问题回答清楚

32:59.700 --> 33:01.700
那么交互时间就做好了

33:01.700 --> 33:03.700
什么事件呢

33:04.700 --> 33:07.700
要用户点击这里的时间

33:08.700 --> 33:10.700
当然也会

33:10.700 --> 33:13.700
用来说是播放和暂停的时间

33:13.700 --> 33:14.700
因为我们学过这个Audio啊

33:14.700 --> 33:16.700
里面有些事件的

33:16.700 --> 33:18.700
播放和暂停的时间

33:18.700 --> 33:20.700
其实本质上的它的事件

33:21.700 --> 33:25.700
就是它的播放进度发生变化的时间

33:25.700 --> 33:27.700
是不是你自己琢磨

33:27.700 --> 33:28.700
是不是这个道理

33:29.700 --> 33:31.700
只要你播放进度不变

33:31.700 --> 33:33.700
播放进度不变

33:33.700 --> 33:34.700
那我这里肯定不会变化

33:34.700 --> 33:36.700
只要你播放进度变了

33:36.700 --> 33:38.700
那么我这里就要做相应的变化

33:38.700 --> 33:39.700
你看一下吧

33:48.920 --> 33:49.920
是不是

33:49.920 --> 33:50.920
那么也就是说

33:50.920 --> 33:52.920
我们要找Audio元素的

33:53.920 --> 33:55.920
什么事件

33:55.920 --> 34:01.920
Audio元素的播放进度变化的时间

34:01.920 --> 34:03.920
那么这个事件名字叫啥

34:03.920 --> 34:05.920
这就是考验记忆力的时候了

34:05.920 --> 34:07.920
但是我们学开发需要记忆力吗

34:07.920 --> 34:08.920
不需要记忆力

34:08.920 --> 34:10.920
那忘了怎么办

34:10.920 --> 34:12.920
你可以查老师的文档

34:12.920 --> 34:13.920
也可以看老师的视频

34:13.920 --> 34:15.920
但是这些都没有这个方法

34:16.920 --> 34:18.920
AudioMDN

34:21.230 --> 34:22.230
第一个点进去

34:23.230 --> 34:24.230
事件

34:25.230 --> 34:26.230
你自己看吧

34:26.230 --> 34:28.230
你觉得哪个是播放进度改变的时间

34:28.230 --> 34:30.230
你找啊找啊找不就它吗

34:32.230 --> 34:33.230
Current Time

34:33.230 --> 34:34.230
Current Time还没说

34:34.230 --> 34:35.230
当前时间

34:35.230 --> 34:36.230
什么叫当前时间

34:36.230 --> 34:37.230
就是不当前的播放时间

34:38.230 --> 34:39.230
更新了变

34:39.230 --> 34:40.230
更新的时候

34:40.230 --> 34:41.230
就是变化的时候

34:41.230 --> 34:42.230
就这个时间

34:42.230 --> 34:43.230
所以说你要做的事

34:43.230 --> 34:44.230
那你不确定怎么办

34:44.230 --> 34:46.230
不确定你测试一下变

34:48.230 --> 34:49.230
那你就找

34:49.230 --> 34:50.230
首先找到Audio元素

34:50.230 --> 34:52.230
我们把Audio元素加住进来

34:52.230 --> 34:53.230
因为我们音乐上只有一个Audio

34:53.230 --> 34:54.230
所以说我们这里

34:54.230 --> 34:56.230
直接用Documents question

34:58.230 --> 35:00.230
好 接下来我们找到这个Audio

35:01.230 --> 35:02.230
给它添加事件

35:02.230 --> 35:03.230
一本成Nation 什么事件呢

35:03.230 --> 35:05.230
Time Update

35:05.230 --> 35:06.230
好 接下来我们写个

35:06.230 --> 35:07.230
事件处理函数

35:07.230 --> 35:09.230
看这个函数里边

35:11.230 --> 35:12.230
随便打一个吧

35:13.230 --> 35:15.230
看一下播放进度变化

35:15.230 --> 35:16.230
它会不会触发

35:17.230 --> 35:18.230
随便不断的触发

35:18.230 --> 35:19.230
暂停播后

35:20.230 --> 35:22.230
不动了 因为播放进度没变化了

35:22.230 --> 35:23.230
然后拖动

35:24.230 --> 35:25.230
你看是不是也在触发

35:25.230 --> 35:26.230
拖动

35:27.230 --> 35:28.230
拖动的时候也在触发

35:28.230 --> 35:30.230
因此这就是我们要找的事件

35:31.230 --> 35:32.230
那么在这个事件里边

35:32.230 --> 35:35.230
我们如何拿到当前的播放进度呢

35:35.230 --> 35:37.230
因为这个数据很重要

35:38.230 --> 35:39.230
我只有拿到了当前播放进度

35:39.230 --> 35:40.230
我才能根据进度

35:40.230 --> 35:42.230
我来设置这下面的效果

35:43.230 --> 35:44.230
所以说当前播放进度怎么拿到呢

35:45.230 --> 35:46.230
所以你又查文档

35:46.230 --> 35:48.230
那应该是一个属性吧

35:48.230 --> 35:49.230
对不对

35:49.230 --> 35:50.230
事件我们已经做到了

35:50.230 --> 35:51.230
我要去拿一些属性

35:51.230 --> 35:52.230
它什么属性呢

35:52.230 --> 35:53.230
就是Current Time

35:54.230 --> 35:55.230
对吧 它可以解释得很清楚

35:55.230 --> 35:57.230
它是一个伏电值

35:57.230 --> 36:00.230
用于表明引表为单位

36:00.230 --> 36:02.230
当前音频的播放位置

36:03.230 --> 36:04.230
对吧

36:04.230 --> 36:06.230
好 接下来我们来看一下

36:07.230 --> 36:09.230
是不是可以输出ZS

36:09.230 --> 36:11.230
当前的事件对象

36:12.230 --> 36:16.460
Current Time

36:16.460 --> 36:18.460
秒1.91 2.1

36:19.460 --> 36:27.220
明白吧

36:27.220 --> 36:29.220
是不是可以拿到播放的

36:29.220 --> 36:31.220
就当前的播放进度

36:31.220 --> 36:33.220
因此呢

36:33.220 --> 36:35.220
我们要做的事情就是

36:35.220 --> 36:38.220
根据目前的播放进度

36:38.220 --> 36:40.220
设置好这些东西

36:40.220 --> 36:41.220
是不是就完事了

36:42.220 --> 36:43.220
那么我们也就是

36:43.220 --> 36:45.220
我们这里交给一个函数来处理吧

36:45.220 --> 36:46.220
写上这么一个函数

36:48.220 --> 36:50.220
上面的引力程度最好等待一下

36:50.220 --> 36:52.220
等待它出手完成之后

36:52.220 --> 36:53.220
我们才能进行交互

36:53.220 --> 36:54.220
出手完成之前

36:54.220 --> 36:56.220
我们先不要着急进行交互

36:58.220 --> 37:00.220
然后这里我写个函数来进行处理

37:00.220 --> 37:03.220
就是Set Status

37:03.220 --> 37:05.220
你给我一个时间

37:06.220 --> 37:07.220
打个注释

37:07.220 --> 37:08.220
刚才我们分析过了

37:08.220 --> 37:10.220
我们要做的事情是什么呢

37:10.220 --> 37:14.220
就是根据当前的播放进度

37:16.220 --> 37:18.220
就是播放时间

37:18.220 --> 37:20.220
根据播放时间

37:20.220 --> 37:23.220
设置好页面的

37:23.220 --> 37:26.220
设置好歌词的状态

37:26.220 --> 37:27.220
什么叫状态

37:27.220 --> 37:29.220
就是哪个地方高亮

37:29.220 --> 37:31.220
哪个地方放大

37:31.220 --> 37:32.220
然后呢就是

37:32.220 --> 37:34.220
我们这个整个歌词要往上滚动

37:34.220 --> 37:35.220
滚动到哪个位置

37:35.220 --> 37:38.220
这些东西我们乱七八糟的一切事情

37:38.220 --> 37:40.220
都是根据一个时间来设置的

37:41.220 --> 37:42.220
那么我们这里呢

37:42.220 --> 37:44.220
当我们时间变化的时候

37:44.220 --> 37:45.220
播放进度变化的时候

37:45.220 --> 37:47.220
我们无非就是掉用这个函数

37:47.220 --> 37:49.220
把时间给它传进去

37:49.220 --> 37:50.220
对吧

37:50.220 --> 37:51.220
我传给的时间

37:51.220 --> 37:53.220
来你来圣圈的事情交给你了

37:53.220 --> 37:56.220
我就把代码来写成了这种结构

37:56.220 --> 37:57.220
原来说

37:57.220 --> 37:59.220
为什么我不把直接把这个函数的内容

37:59.220 --> 38:00.220
直接写到这儿呢

38:00.220 --> 38:02.220
为什么还要单独去提一个函数呢

38:02.220 --> 38:05.220
其实你直接写到这儿也可以

38:05.220 --> 38:07.220
但是呢我不是很推荐

38:07.220 --> 38:09.220
为什么不推推荐呢

38:09.220 --> 38:10.220
就不好测试

38:10.220 --> 38:11.220
如果说我要去对这个函数

38:11.220 --> 38:13.220
单独进行测试的话

38:13.220 --> 38:16.220
比方说我对他进行单独测试的话

38:16.220 --> 38:17.220
那么

38:18.220 --> 38:20.220
我必须要用事件去测试

38:20.220 --> 38:21.220
于是他在事件里面

38:21.220 --> 38:23.220
他所谓的代码全部在事件里面

38:23.220 --> 38:24.220
我提升函数过后呢

38:24.220 --> 38:25.220
我就可以在浏览器里面直接

38:25.220 --> 38:26.220
调过这个函数

38:26.220 --> 38:28.220
或者是以后呢将来有些功能

38:28.220 --> 38:29.220
比方说不点这儿

38:29.220 --> 38:30.220
跟这个播放器没关系

38:30.220 --> 38:32.220
我就要有一个功能就是

38:32.220 --> 38:33.220
我点一个按钮

38:33.220 --> 38:34.220
一个普通按钮

38:34.220 --> 38:35.220
我就要把歌词

38:35.220 --> 38:37.220
布定到某一个时间点的位置

38:38.220 --> 38:40.220
那如果说有这样的功能的话

38:40.220 --> 38:41.220
那一个代码到时候呢

38:41.220 --> 38:42.220
又不好维护了

38:42.220 --> 38:44.220
所以我就写成习惯了啊

38:44.220 --> 38:46.220
事件里面我不会写太多东西

38:46.220 --> 38:47.220
就是调用别的方法

38:48.220 --> 38:50.220
那么大家呢暂停视频

38:50.220 --> 38:52.220
把这个东西写成这样的结构

38:52.220 --> 38:53.220
体会一下这个事件

38:53.220 --> 38:54.220
他什么时候运行了

38:55.220 --> 38:56.220
这个东西到底是啥玩意

38:58.220 --> 38:59.220
好的

38:59.220 --> 39:00.220
那么接下来

39:00.220 --> 39:02.220
我们下面的所有的事情

39:04.220 --> 39:05.220
这里包错了

39:06.220 --> 39:07.220
这已经包错了

39:07.220 --> 39:08.220
什么错误了

39:08.220 --> 39:09.220
他说

39:10.220 --> 39:12.220
位置必须要放到

39:12.220 --> 39:13.220
Essink的函数里面

39:14.220 --> 39:15.220
加上Essink可以

39:16.220 --> 39:17.220
接下来我们所有的事情

39:17.220 --> 39:19.220
就是完成这个函数

39:21.220 --> 39:22.220
这个函数要做什么

39:22.220 --> 39:23.220
你看我们就是

39:23.220 --> 39:24.220
大问题套小问题

39:24.220 --> 39:25.220
小问题套小问题

39:25.220 --> 39:26.220
一个个一个套

39:26.220 --> 39:27.220
叫俄罗斯套娃一样

39:29.220 --> 39:30.220
这个函数就要做两件事

39:31.220 --> 39:32.220
第一件事

39:34.720 --> 39:36.720
找到对应的

39:36.720 --> 39:37.720
就根据时间

39:39.720 --> 39:41.720
找到对应的li

39:43.720 --> 39:44.720
高量

39:44.720 --> 39:45.720
什么叫高量

39:46.720 --> 39:47.720
是不是就加上了一个active

39:48.720 --> 39:49.720
对吧

39:49.720 --> 39:50.720
这是第一件事

39:51.720 --> 39:52.720
第二件事

39:53.720 --> 39:56.720
设置UL的滚动位置

39:56.720 --> 39:58.720
滚动到某一个位置

39:59.720 --> 40:01.720
好我们两件事分开来做

40:01.720 --> 40:02.720
一件一件做

40:03.720 --> 40:04.720
首先第一件事

40:05.720 --> 40:06.720
根据时间

40:06.720 --> 40:07.720
时间在哪儿

40:07.720 --> 40:13.040
在这儿

40:13.040 --> 40:14.040
是不是拿到时间

40:15.040 --> 40:16.040
每次都会调这个函数

40:16.040 --> 40:17.040
调函数以后

40:17.040 --> 40:18.040
就给他一个时间

40:18.040 --> 40:19.040
目前的播放时间

40:20.040 --> 40:23.420
时间我能拿到

40:23.420 --> 40:24.420
现在我要根据这个时间

40:24.420 --> 40:26.420
找到到底是第几个li

40:26.420 --> 40:27.420
我要高量显示

40:28.420 --> 40:30.420
我只要能够找到第几个

40:30.420 --> 40:31.420
比方说我找到的是

40:31.420 --> 40:32.420
举个例子

40:32.420 --> 40:34.420
我找到的是index

40:34.420 --> 40:36.420
假设是第13个

40:36.420 --> 40:37.420
假设

40:37.420 --> 40:38.420
那么我们是不是就非常方便了

40:38.420 --> 40:40.420
可以利用ULQ去

40:42.420 --> 40:44.420
就是第13句个时

40:44.420 --> 40:45.420
要高量

40:45.420 --> 40:46.420
那么我们就直接找到

40:46.420 --> 40:48.420
这个对应的li

40:48.420 --> 40:49.420
给他的什么

40:49.420 --> 40:51.420
classness

40:51.420 --> 40:52.420
index

40:54.420 --> 40:55.420
他说实际上好像有点多了

40:56.420 --> 40:58.730
还没播放呢

41:00.730 --> 41:01.730
你看

41:01.730 --> 41:02.730
是不是就非常方便了

41:02.730 --> 41:04.730
也就是我们要做的事情

41:04.730 --> 41:06.730
就是找到这个index

41:07.730 --> 41:08.730
对下标

41:08.730 --> 41:10.730
到底是第几个

41:10.730 --> 41:11.730
第几句个时

41:12.730 --> 41:13.730
那么我们怎么找呢

41:13.730 --> 41:15.730
我们先不说具体怎么找

41:15.730 --> 41:16.730
大家想一想

41:16.730 --> 41:17.730
我们可能要用到

41:17.730 --> 41:18.730
什么样的东西

41:18.730 --> 41:19.730
前面的

41:19.730 --> 41:20.730
我们接触的

41:22.730 --> 41:23.730
需要用到它呀

41:24.730 --> 41:26.730
它里边是不是有时间啊

41:26.730 --> 41:27.730
这里是不是要有时间啊

41:27.730 --> 41:29.730
也就是我们要用这个时间

41:29.730 --> 41:30.730
跟它里边的时间去对

41:30.730 --> 41:32.730
看哪一个格子能对上

41:32.730 --> 41:33.730
对不对

41:33.730 --> 41:34.730
那么我们这里输出一下

41:34.730 --> 41:35.730
两个东西

41:35.730 --> 41:37.730
temp和lrc

41:45.070 --> 41:46.070
你看

41:46.070 --> 41:48.070
每次我都能拿到一个时间

41:49.070 --> 41:50.070
往后方

41:50.070 --> 41:51.070
不放一下吧

41:51.070 --> 41:53.070
你看我每次能拿到一个时间

41:53.070 --> 41:55.070
同时能拿到一个数组

41:55.070 --> 41:56.070
我要用这个时间

41:56.070 --> 41:57.070
在数组里面对

41:57.070 --> 41:59.070
看哪个东西能对上

41:59.070 --> 42:00.070
我们先不着急用程序来对

42:00.070 --> 42:02.070
我们先人来对一下

42:03.070 --> 42:05.070
第一条能对上吗

42:06.070 --> 42:07.070
对不上 为什么

42:07.070 --> 42:08.070
第二条能对上吗

42:08.070 --> 42:09.070
对不上

42:09.070 --> 42:10.070
对上吗

42:10.070 --> 42:11.070
对不上

42:11.070 --> 42:12.070
对不上

42:12.070 --> 42:13.070
对不上

42:13.070 --> 42:14.070
对不上

42:14.070 --> 42:15.070
对不上

42:16.070 --> 42:18.070
这个能对上吗

42:19.070 --> 42:20.070
能对上吗

42:21.070 --> 42:22.070
是不是能对上

42:22.070 --> 42:23.070
为什么

42:23.070 --> 42:25.070
因为它下一条

42:25.070 --> 42:27.070
开始时间是99秒

42:27.070 --> 42:29.070
而我目前是98秒

42:30.070 --> 42:31.070
是不是

42:32.070 --> 42:33.070
这一条不合适

42:34.070 --> 42:36.070
然后我就找到了上一条

42:36.070 --> 42:37.070
对上了

42:38.070 --> 42:39.070
所以我们找的是啥

42:41.070 --> 42:43.070
是不是找这个数组中

42:44.070 --> 42:45.070
第一个

42:47.070 --> 42:49.070
比它大的值

42:51.070 --> 42:52.070
是不是

42:52.070 --> 42:53.070
你看

42:54.070 --> 42:56.070
比它小 不管

42:56.070 --> 42:58.070
不管 不管 不管 不管

42:58.070 --> 43:00.070
到这还是比它小 不管

43:00.070 --> 43:02.070
它是不是第一个比它大的

43:02.070 --> 43:04.070
第一个比它大的值

43:05.070 --> 43:06.070
是不是可以找到一个index

43:06.070 --> 43:08.070
然后减1

43:08.070 --> 43:10.070
不就是上一条吗

43:11.070 --> 43:13.070
好好输定一下我刚才说的话

43:13.070 --> 43:14.070
就是这个逻辑

43:15.070 --> 43:17.070
所以说相等

43:17.070 --> 43:18.070
相等

43:19.070 --> 43:20.070
不用管

43:20.070 --> 43:21.070
我们只管比它大的

43:21.070 --> 43:23.070
比方说目前就是96.5

43:23.070 --> 43:25.070
那么到它96.5

43:25.070 --> 43:26.070
96.5比它大吗

43:26.070 --> 43:27.070
不比它大

43:27.070 --> 43:28.070
然后我们就找下一条

43:28.070 --> 43:30.070
99.07比96.5大

43:30.070 --> 43:32.070
那么就找这一条

43:32.070 --> 43:34.070
它的下标25-1

43:34.070 --> 43:35.070
就是24

43:36.070 --> 43:37.070
所以说

43:37.070 --> 43:38.070
我们要找的是啥

43:40.070 --> 43:41.070
第一个比它大的

43:41.070 --> 43:42.070
比这个时间大的

43:43.070 --> 43:44.070
我们可以用什么API

43:45.070 --> 43:46.070
可以用啥

43:48.070 --> 43:49.070
可是不是可以用

43:49.070 --> 43:51.070
alrc

43:51.070 --> 43:52.070
data 这个数主

43:52.070 --> 43:53.070
fand

43:54.070 --> 43:55.070
index

43:55.070 --> 43:56.070
不知道大家学过没有

43:56.070 --> 43:57.070
没学过也没关系

43:57.070 --> 43:58.070
非常简单

43:58.070 --> 43:59.070
这个玩意

43:59.070 --> 44:00.070
跟4e

44:00.070 --> 44:01.070
跟mapr

44:01.070 --> 44:02.070
filter的本质是一样的

44:02.070 --> 44:03.070
它里边传一个回调函数

44:04.070 --> 44:05.070
非常类似于filter

44:06.070 --> 44:08.070
它传一个回调函数

44:08.070 --> 44:09.070
这个回调函数

44:09.070 --> 44:10.070
它返回一个布尔

44:11.070 --> 44:13.070
它会把每一项拿出来

44:13.070 --> 44:14.070
一次放到

44:14.070 --> 44:15.070
调问这个回调函数

44:15.070 --> 44:17.070
比方说这里的alrc

44:17.070 --> 44:19.070
它会一次掉用这个回调函数

44:20.070 --> 44:22.070
第一次得到的是true

44:22.070 --> 44:24.070
那么就把下标拿到了

44:24.070 --> 44:25.070
它就返回了

44:25.070 --> 44:26.070
是一个下标

44:26.070 --> 44:27.070
好看一下吧

44:27.070 --> 44:28.070
alrc

44:28.070 --> 44:30.070
我们可以通过这个alrc的

44:30.070 --> 44:31.070
什么

44:31.070 --> 44:32.070
cam

44:32.070 --> 44:33.070
要比它大

44:33.070 --> 44:34.070
对吧

44:34.070 --> 44:35.070
找第一个

44:35.070 --> 44:37.070
时间比它大的

44:37.070 --> 44:38.070
那个index

44:38.070 --> 44:39.070
那个下标

44:39.070 --> 44:40.070
好

44:40.070 --> 44:41.070
如果说我们这样

44:41.070 --> 44:42.070
找到过后

44:42.070 --> 44:43.070
我们输出一下index

44:43.070 --> 44:54.730
看一下

44:54.730 --> 45:04.270
看看

45:04.270 --> 45:05.270
是不是快了一点

45:05.270 --> 45:06.270
可是首先快了一点

45:06.270 --> 45:07.270
为什么

45:07.270 --> 45:08.270
因为还没有减1

45:08.270 --> 45:09.270
我们之前分析过了对不对

45:09.270 --> 45:10.270
它的上一条

45:10.270 --> 45:11.270
才是我们要的东西

45:11.270 --> 45:12.270
减1

45:12.270 --> 45:13.270
但是减1过后来

45:13.270 --> 45:15.270
index有可能是负数

45:15.270 --> 45:17.270
比方说最开始的时候

45:17.270 --> 45:18.270
最开始的时候

45:18.270 --> 45:19.270
确实什么都不需要显示

45:19.270 --> 45:20.270
所以我们这里

45:20.270 --> 45:21.270
判断一下

45:21.270 --> 45:23.270
如果说index小于0的话

45:23.270 --> 45:24.270
我就啥也别干了

45:25.270 --> 45:26.270
啥也别干了

45:26.270 --> 45:27.270
不动

45:27.270 --> 45:28.270
一切都不要动

45:28.270 --> 45:29.270
好

45:29.270 --> 45:31.270
如果说index大于等于0的话

45:31.270 --> 45:32.270
我们就设置它

45:32.270 --> 45:33.270
对应的那样是

45:34.270 --> 45:43.430
看一下

45:43.430 --> 45:44.430
说对上了

45:45.430 --> 45:46.430
好

45:46.430 --> 45:47.430
希望大家

45:47.430 --> 45:48.430
把它做到目前的效果

45:48.430 --> 45:49.430
不着急吧

45:49.430 --> 45:50.430
我们先把那个东西弄完了

45:50.430 --> 45:51.430
弄完

45:51.430 --> 45:52.430
对它之前的没有销

45:52.430 --> 45:53.430
对吧

45:53.430 --> 45:54.430
之前的Active没有销

45:54.430 --> 45:55.430
那这个东西太简单了

45:57.430 --> 45:59.430
我先消除之前的

45:59.430 --> 46:00.430
消除

46:00.430 --> 46:01.430
之前的Active

46:01.430 --> 46:02.430
那怎么弄

46:03.430 --> 46:04.430
Document是

46:08.830 --> 46:10.830
找到之前的Active

46:11.830 --> 46:12.830
对吧

46:13.830 --> 46:14.830
拿到一个

46:16.830 --> 46:17.830
Active

46:18.830 --> 46:19.830
Li

46:19.830 --> 46:21.830
然后之前的Active

46:21.830 --> 46:23.830
就是目前有那样是Active的Li

46:23.830 --> 46:24.830
如果它有值

46:24.830 --> 46:25.830
能拿到

46:25.830 --> 46:26.830
说明目前有一个I

46:26.830 --> 46:27.830
它已经是集合了

46:27.830 --> 46:29.830
我们就把它的class list

46:29.830 --> 46:30.830
remove

46:31.830 --> 46:32.830
去掉Active

46:32.830 --> 46:33.830
先把之前的去掉

46:33.830 --> 46:35.830
然后再找目前的index

46:35.830 --> 46:36.830
给目前的加上

46:37.830 --> 46:38.830
好

46:38.830 --> 46:47.740
你看

46:47.740 --> 46:48.740
好

46:48.740 --> 46:49.740
如果你觉得有点

46:49.740 --> 46:51.740
误差对不上

46:51.740 --> 46:53.740
那是因为这个歌词的本身有问题

46:53.740 --> 46:54.740
有些小问题

46:54.740 --> 46:55.740
它没有做得那么完美

46:55.740 --> 46:57.740
那你可以进行微调

46:57.740 --> 46:58.740
怎么微调

46:58.740 --> 46:59.740
你看

47:00.740 --> 47:01.740
可以在一开始进行微调

47:03.740 --> 47:04.740
怎么微调呢

47:04.740 --> 47:06.740
就是比方说目前看上去有点

47:10.300 --> 47:12.300
歌词出现在太慢了

47:12.300 --> 47:13.300
啥意思

47:14.300 --> 47:15.300
就是我们播放到

47:15.300 --> 47:16.300
某一个位置的时候

47:16.300 --> 47:18.300
这个时候已经唱到这一句了

47:19.300 --> 47:21.300
就时间上已经到了这一句

47:21.300 --> 47:22.300
就是我唱到这一句了

47:22.300 --> 47:24.300
但是根据目前这个时间

47:24.300 --> 47:25.300
还没有到这一句

47:25.300 --> 47:28.300
所以我们只要把目前的时间增加一点

47:28.300 --> 47:29.300
就把这个时间增加一点

47:29.300 --> 47:30.300
对吧

47:30.300 --> 47:31.300
我不是增加这里的时间

47:31.300 --> 47:34.300
我是把这里传坏的时间增加一点

47:34.300 --> 47:36.300
然后加一个0.5

47:36.300 --> 47:38.300
你自己可以调整一下

47:38.300 --> 47:39.300
那么

47:39.300 --> 47:40.300
它就会提

47:40.300 --> 47:41.300
那么这个

47:41.300 --> 47:43.300
这句话就可以早点出来

47:43.300 --> 47:47.600
对吧

47:47.600 --> 47:48.600
所以舒服多了

47:49.600 --> 47:51.600
大家把它做到这个位置

47:52.600 --> 47:53.600
那么第一步就完成了

47:53.600 --> 47:55.600
根据时间到了

47:58.940 --> 47:59.940
好

47:59.940 --> 48:00.940
接下来第二步

48:01.940 --> 48:04.940
设置ULO的滚动位置

48:05.940 --> 48:07.940
是不是在课堂一开始我就说了

48:07.940 --> 48:08.940
这个ULO咋滚动

48:09.940 --> 48:10.940
怎么滚动

48:10.940 --> 48:12.940
是不是直接找到这个ULO

48:12.940 --> 48:13.940
给它设置什么

48:13.940 --> 48:15.940
Transform

48:16.940 --> 48:17.940
Transnet

48:17.940 --> 48:18.940
Y

48:19.940 --> 48:22.940
复指比方说滚动到60

48:23.940 --> 48:25.940
滚动到120

48:25.940 --> 48:26.940
对吧

48:26.940 --> 48:28.940
所以就设置这个纸就完成了

48:28.940 --> 48:29.940
那么也就是说我们要找的

48:29.940 --> 48:31.940
是不是就是这个纸

48:31.940 --> 48:33.940
到底往上滚动多少

48:34.940 --> 48:35.940
这个时候

48:36.940 --> 48:40.440
意图胜千言

48:40.440 --> 48:41.440
这个图

48:41.440 --> 48:43.440
大家需要安装一个插件才能打开

48:43.440 --> 48:45.440
就是叫做

48:45.440 --> 48:46.440
你不用插件的话

48:46.440 --> 48:49.440
你只能看一张存的图片

48:49.440 --> 48:50.440
当然也没什么问题

48:50.440 --> 48:53.440
按照这个插件叫做IO integration

48:53.440 --> 48:56.440
这是专门来做一些

48:56.440 --> 48:57.440
做图的

48:57.440 --> 48:59.820
打开它

48:59.820 --> 49:01.820
也可以看到这么一个界面

49:01.820 --> 49:07.560
这个黑色的就是外面

49:07.560 --> 49:09.560
定高的DIV溢出隐藏

49:09.560 --> 49:13.000
然后

49:13.000 --> 49:15.000
这里面的黄色这一块

49:15.000 --> 49:17.000
就是我们的ULO

49:17.000 --> 49:18.000
绿色的一行一行的

49:18.000 --> 49:20.000
就是我们的LI

49:20.000 --> 49:23.000
假设我们目前的LI

49:23.000 --> 49:24.000
是这个红色

49:24.000 --> 49:26.000
那么红色应该保持在

49:26.000 --> 49:28.000
整个DIV的正中

49:28.000 --> 49:31.000
那怎么来才能保证它的正中呢

49:31.000 --> 49:34.000
我们得把这个ULO往上移动

49:34.000 --> 49:35.000
ULO

49:36.000 --> 49:38.000
我得从这往上移动

49:38.000 --> 49:41.000
它应该是跟L1连在一起的

49:42.000 --> 49:43.000
就这一块

49:43.000 --> 49:45.000
我应该从这个位置

49:45.000 --> 49:47.000
它默认是这个位置吗

49:47.000 --> 49:49.000
用transform

49:49.000 --> 49:51.000
把它往上移动

49:51.000 --> 49:52.000
移动到这个位置

49:53.000 --> 49:55.000
现在我们就要求的是这一段

49:55.000 --> 49:57.000
这一段到底移动多少

49:57.000 --> 49:59.000
这一段肯定是复述

49:59.000 --> 50:01.000
它要移动多少

50:01.000 --> 50:02.000
往上移动多少

50:03.000 --> 50:05.000
你看看这个图吧

50:05.000 --> 50:09.040
没什么好说的

50:09.040 --> 50:10.040
移动多少呢

50:10.040 --> 50:14.040
无非就是从上边

50:14.040 --> 50:18.610
从这儿到这儿的高度

50:18.610 --> 50:20.610
减去

50:20.610 --> 50:22.610
从这儿到这儿的高度

50:22.610 --> 50:23.610
对吧

50:23.610 --> 50:25.610
那么一部分一部分来吗

50:26.610 --> 50:28.610
这一部分的高度

50:29.610 --> 50:30.610
怎么求啊

50:30.610 --> 50:32.610
这里有两个值

50:32.610 --> 50:34.610
一个是每一个Li的高度

50:34.610 --> 50:36.610
乘以什么

50:36.610 --> 50:38.610
当前Li的index

50:38.610 --> 50:40.610
比方说index的时候是0

50:40.610 --> 50:42.610
我这个高度可能就是0了

50:42.610 --> 50:44.610
就压到底了

50:44.610 --> 50:45.610
那我们来数一数吧

50:45.610 --> 50:46.610
1

50:46.610 --> 50:47.610
都是0

50:47.610 --> 50:48.610
1

50:48.610 --> 50:49.610
2

50:49.610 --> 50:50.610
3

50:50.610 --> 50:51.610
4

50:51.610 --> 50:52.610
5

50:52.610 --> 50:53.610
6

50:53.610 --> 50:54.610
7

50:54.610 --> 50:55.610
index的时候是9

50:55.610 --> 50:57.610
那么也就是说Li clients

50:57.610 --> 50:59.610
就是每个Li的高度

50:59.610 --> 51:01.610
乘以9

51:01.610 --> 51:03.610
上面就有9个相当于

51:03.610 --> 51:04.610
1

51:04.610 --> 51:05.610
2

51:05.610 --> 51:06.610
3

51:06.610 --> 51:07.610
4

51:07.610 --> 51:08.610
5

51:08.610 --> 51:09.610
6

51:09.610 --> 51:10.610
7

51:10.610 --> 51:11.610
8

51:11.610 --> 51:12.610
9

51:12.610 --> 51:13.610
对不对

51:13.610 --> 51:15.610
是不是就求出了这一部分高度

51:15.610 --> 51:16.610
然后呢

51:16.610 --> 51:18.610
我要保证它在正中是不是还要

51:18.610 --> 51:20.610
加上它的高度的一半

51:20.610 --> 51:22.610
Li的高度的一半

51:22.610 --> 51:24.610
一看它就不用听我讲了

51:24.610 --> 51:26.610
然后这个高度是不是求出来了

51:26.610 --> 51:28.610
然后再减去左边那个

51:28.610 --> 51:29.610
这个高度

51:29.610 --> 51:30.610
这个高度是什么

51:30.610 --> 51:31.610
就是DIV高度的一半的

51:31.610 --> 51:32.610
对吧

51:32.610 --> 51:33.610
容器高度的一半

51:33.610 --> 51:35.610
一减不就是这个东西吗

51:35.610 --> 51:38.610
看着图里的都能把它写出来

51:40.610 --> 51:42.610
那么接下来我们来写

51:42.610 --> 51:43.610
接下来我需要两个尺寸

51:43.610 --> 51:44.610
一个是每个Li的高度

51:44.610 --> 51:46.610
以及容器的高度

51:46.610 --> 51:47.610
那么这两个尺寸

51:47.610 --> 51:49.610
我可以在一开始一把定义好

51:50.610 --> 51:51.610
当然你要去

51:51.610 --> 51:53.610
每一次去获取的话也可以

51:53.610 --> 51:55.610
我就可以直接定义吧

51:56.610 --> 51:57.610
一开始把定义好

51:57.610 --> 51:58.610
尺寸

51:58.610 --> 51:59.610
两个尺寸

51:59.610 --> 52:00.610
一个是Li的高度

52:00.610 --> 52:01.610
多少呢

52:01.610 --> 52:03.610
三十个像素

52:03.610 --> 52:05.610
容器的高度

52:05.610 --> 52:06.610
多少呢

52:06.610 --> 52:08.610
420个像素

52:08.610 --> 52:09.610
对吧

52:09.610 --> 52:11.610
我们就有两个尺寸

52:11.610 --> 52:12.610
我用的就是两个尺寸

52:12.610 --> 52:14.610
那么Li的滚动位置

52:14.610 --> 52:20.160
就是上面的一个距离

52:21.160 --> 52:22.160
你看

52:22.160 --> 52:23.160
就这一段距离

52:23.160 --> 52:24.160
应该等于什么了

52:24.160 --> 52:25.160
我们把它定个变量

52:27.160 --> 52:28.160
TOP

52:28.160 --> 52:29.160
Const

52:29.160 --> 52:31.160
平时定义变量的时候

52:31.160 --> 52:32.160
尽量用const

52:33.160 --> 52:35.160
然后如果说你实在要改它的时候

52:35.160 --> 52:37.160
再考虑把它修改成net

52:37.160 --> 52:38.160
这是我们的开发习惯

52:39.160 --> 52:40.160
首先是

52:40.160 --> 52:41.160
每个Li的高度

52:41.160 --> 52:42.160
乘以index

52:42.160 --> 52:44.160
index是不是我们一有了

52:44.160 --> 52:45.160
前面是不是一求出来了

52:46.160 --> 52:47.160
只是我们这里要拿到

52:47.160 --> 52:49.160
三十里面的Li height

52:50.160 --> 52:51.160
乘以什么index

52:54.240 --> 52:55.240
然后呢

52:56.240 --> 52:57.240
加上

52:57.240 --> 52:58.240
这里

52:58.240 --> 53:00.240
一个Li的高度处于2

53:02.240 --> 53:03.240
Li的高度处于2

53:05.240 --> 53:06.240
然后再减去

53:06.240 --> 53:07.240
减去这边

53:07.240 --> 53:09.240
容器高度处于2

53:10.240 --> 53:11.240
Const

53:13.240 --> 53:14.240
这就是我们

53:15.240 --> 53:16.240
做东西

53:17.240 --> 53:18.240
TOP

53:18.240 --> 53:20.550
但是个TOP

53:20.550 --> 53:21.550
在程序里面是复数

53:21.550 --> 53:23.550
它也是复数

53:23.550 --> 53:24.550
所以说我们这里

53:24.550 --> 53:26.550
这样的算法肯定是正书

53:26.550 --> 53:27.550
所以说我们这里

53:27.550 --> 53:28.550
得把它

53:29.550 --> 53:30.550
改成复数

53:30.550 --> 53:31.550
等于复的TOP

53:31.550 --> 53:34.310
那么这里要改

53:34.310 --> 53:36.310
是不是把它改成net

53:37.310 --> 53:39.310
改成复数过后

53:39.310 --> 53:40.310
有没有特殊情况呢

53:40.310 --> 53:41.310
实际上是有特殊情况的

53:42.310 --> 53:45.880
什么情况还是特殊情况

53:46.880 --> 53:47.880
比方说它目前

53:47.880 --> 53:49.880
它目前不是这个一个

53:49.880 --> 53:50.880
是第一个

53:50.880 --> 53:52.880
它index等于0

53:54.880 --> 53:55.880
对不对

53:55.880 --> 53:56.880
那么index等于0

53:56.880 --> 53:57.880
会导致一个什么样的结果呢

53:57.880 --> 53:58.880
就这一块算出来是0

53:59.880 --> 54:00.880
那么我只有这一块

54:00.880 --> 54:01.880
减去这一块

54:01.880 --> 54:02.880
那算出来就是复数

54:02.880 --> 54:03.880
复数在求反

54:03.880 --> 54:04.880
是不是就变成正书了

54:04.880 --> 54:05.880
也就是啥意思

54:05.880 --> 54:06.880
就是我这个TOP

54:06.880 --> 54:07.880
如果说是正书的话

54:07.880 --> 54:08.880
就变成这个样子了

54:09.880 --> 54:11.880
它为了保证第一条在中间

54:11.880 --> 54:13.880
它的全式模式变成这样子了

54:14.880 --> 54:15.880
对吧

54:15.880 --> 54:16.880
那如果说你觉得

54:16.880 --> 54:17.880
就这样子OK的话

54:17.880 --> 54:18.880
那就这样子了

54:18.880 --> 54:19.880
但是我们这个效果

54:19.880 --> 54:20.880
不是这样子的

54:20.880 --> 54:22.880
就是一开始的时候

54:23.880 --> 54:24.880
你看

54:25.880 --> 54:27.880
它并没有在中间

54:27.880 --> 54:28.880
我们并没有往下拉

54:28.880 --> 54:29.880
拉到中间去

54:30.880 --> 54:31.880
所以说如果说

54:31.880 --> 54:32.880
也就是说啥意思呢

54:32.880 --> 54:34.880
我这里不允许它是正书

54:34.880 --> 54:36.880
它注意一扫碎扫都是这个位置

54:37.880 --> 54:38.880
然后往上跑

54:38.880 --> 54:39.880
对吧

54:39.880 --> 54:40.880
你不能跑到这个位置来

54:40.880 --> 54:41.880
所以说我们这里

54:41.880 --> 54:42.880
判断一下一块事

54:42.880 --> 54:43.880
非常简单

54:43.880 --> 54:46.880
如果TOP值大于0

54:47.880 --> 54:48.880
那么我就把TOP值

54:48.880 --> 54:49.880
设置为0

54:49.880 --> 54:50.880
你不能是正书

54:50.880 --> 54:51.880
就是你通过取反过后

54:51.880 --> 54:52.880
就不能是正书

54:53.880 --> 54:54.880
好

54:54.880 --> 54:55.880
那么TOP值算出来过后

54:55.880 --> 54:56.880
就非常简单了

54:56.880 --> 54:57.880
就是TOP是UL

54:57.880 --> 54:58.880
STYLE

54:58.880 --> 54:59.880
TRANSFORM

55:01.880 --> 55:02.880
为什么呢

55:02.880 --> 55:07.150
TRANSNATE

55:08.150 --> 55:09.150
多少PX

55:09.150 --> 55:10.150
这里是不是要拼接

55:10.150 --> 55:11.150
拼接什么

55:11.150 --> 55:12.150
TOP

55:12.150 --> 55:13.150
拼接进去就完成了

55:14.150 --> 55:15.150
好

55:15.150 --> 55:16.150
最后我们来看一下

55:34.720 --> 55:35.720
少写个Y

55:35.720 --> 55:36.720
对吧

55:36.720 --> 55:37.720
少写个Y

55:55.980 --> 55:56.980
这就是咱们

55:56.980 --> 55:57.980
整个效果的事情

55:57.980 --> 55:58.980
就没了

55:58.980 --> 55:59.980
至于说

55:59.980 --> 56:01.980
我这里滚动歌词

56:01.980 --> 56:03.980
然后播放某一句歌词

56:03.980 --> 56:05.980
这个功能我们就不做了

56:05.980 --> 56:06.980
不然的话

56:06.980 --> 56:07.980
就会把整得很复杂

56:07.980 --> 56:08.980
很复杂

56:08.980 --> 56:09.980
因为你们以后开发

56:09.980 --> 56:11.980
不是说也会做这些东西

56:11.980 --> 56:12.980
我们是通过这些东西

56:12.980 --> 56:13.980
去锻炼咱们的

56:13.980 --> 56:14.980
成绩设备逻辑

56:14.980 --> 56:15.980
去整个过程

56:15.980 --> 56:16.980
我来总结一下

56:16.980 --> 56:18.980
总结介绍就行了

56:18.980 --> 56:19.980
整过程会有两个阶段

56:19.980 --> 56:20.980
一个是初始化

56:21.980 --> 56:23.980
一个是事件交互

56:23.980 --> 56:24.980
对吧

56:24.980 --> 56:25.980
初始化的时候

56:25.980 --> 56:26.980
你就考虑一点

56:26.980 --> 56:27.980
开始要做什么

56:27.980 --> 56:29.980
就考虑这点就行了

56:29.980 --> 56:31.980
然后你就去做

56:31.980 --> 56:32.980
初始化完成之后

56:32.980 --> 56:34.980
就要考虑交互了

56:34.980 --> 56:35.980
什么叫交互呢

56:35.980 --> 56:37.980
就是什么时候

56:37.980 --> 56:39.980
我要做什么样的处理

56:39.980 --> 56:41.980
往往是什么事件

56:41.980 --> 56:43.980
注册函数怎么处理

56:43.980 --> 56:45.980
那么这里我们只有一个时间

56:45.980 --> 56:47.980
就是播放时间变化的时间

56:47.980 --> 56:48.980
播放时间变化的时候

56:48.980 --> 56:49.980
我要根据时间

56:49.980 --> 56:51.980
来设置这些状态

56:51.980 --> 56:53.980
只要你这个东西也好

56:53.980 --> 56:55.980
那么整个逻辑跑通了

56:55.980 --> 56:56.980
因为我们整个开发的是

56:56.980 --> 56:58.980
大逻辑套小逻辑

56:58.980 --> 57:00.980
大的题套小的题

57:00.980 --> 57:01.980
不断地分解

57:01.980 --> 57:02.980
分解成一个一个的小任务

57:02.980 --> 57:03.980
最后把它完成

57:03.980 --> 57:05.980
那么大家我不仅希望

57:05.980 --> 57:07.980
大家能够把这个效果做出来

57:07.980 --> 57:09.980
当然你要暂停视频

57:09.980 --> 57:10.980
把个效果做完

57:10.980 --> 57:11.980
把个效果做出来

57:11.980 --> 57:12.980
还希望大家

57:12.980 --> 57:13.980
能够去体会这种

57:13.980 --> 57:14.980
开发的这种思路

57:14.980 --> 57:16.980
这不是一朝一夕的事情

57:16.980 --> 57:19.980
它需要一个长期的一个断终

57:19.980 --> 57:20.980
那么这就好了

57:20.980 --> 57:21.980
我就到这了

57:21.980 --> 57:22.980
拜拜

