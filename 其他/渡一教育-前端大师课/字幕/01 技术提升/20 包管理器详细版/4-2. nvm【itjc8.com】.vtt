WEBVTT

00:00.750 --> 00:03.750
这些课咱们来学习NVM

00:03.750 --> 00:07.750
NVM这个东西 它并非包管的一系

00:07.750 --> 00:09.750
我们这门课不是学包管的一系吗

00:09.750 --> 00:12.750
为什么还要学不是包管的一系的东西呢

00:12.750 --> 00:16.750
因为我实在不知道把这个东西夹到哪去了

00:16.750 --> 00:19.750
按理说的话 它应该是在Note教程里边

00:19.750 --> 00:24.750
但是个Note的教程 可能是作为你们的最后一门课了

00:24.750 --> 00:28.750
可能是在后边去了 很后边才会学习Note的

00:28.750 --> 00:32.750
因此如果说你在学习Note之前要切换Note的版本

00:32.750 --> 00:34.750
那就遇到问题了

00:34.750 --> 00:37.750
所以说我想来想去也不麻烦了

00:37.750 --> 00:40.750
因为这个东西也就一节课的事情 也很简单

00:40.750 --> 00:45.750
所以说我把它放到包管的一系里边讲了算了

00:45.750 --> 00:47.750
这个NVM 它什么东西呢

00:47.750 --> 00:49.750
它是用来管理多个Note的版本的

00:49.750 --> 00:52.750
我们知道Note它从发布至经

00:52.750 --> 00:56.750
经过了这么多年了 肯定会产生多个版本

00:56.750 --> 00:59.750
那么为什么会用到多个版本呢

00:59.750 --> 01:02.750
为什么我们不用最新版就完事了呢 是这样子

01:02.750 --> 01:04.750
你不能说永远开发项目了

01:04.750 --> 01:07.750
你永远不会回头去开发一些旧的项目

01:07.750 --> 01:09.750
永远是开发新的项目

01:09.750 --> 01:12.750
那么你们以后到公司里边去的时候

01:12.750 --> 01:14.750
会遇到这么一些情况

01:14.750 --> 01:18.750
比方说你在两年前 有个两年前的项目

01:18.750 --> 01:22.750
那么当时那个项目是用的Note的版本

01:22.750 --> 01:25.750
哪个版本呢 是比方说Note的8这个版本

01:25.750 --> 01:26.750
书写的

01:26.750 --> 01:30.750
然后呢 今年 今年要开发一个新的项目

01:30.750 --> 01:32.750
那么肯定用Note的最新版 对吧

01:32.750 --> 01:35.750
Note的最新版的是多少呢 是12

01:35.750 --> 01:39.750
然后呢 后年呢 又要开发一个新的项目

01:39.750 --> 01:42.750
Note的 那么可能就是 现在还没出来

01:42.750 --> 01:44.750
可能就是V14了 明儿的意思吗

01:44.750 --> 01:47.750
那么到了后 诶 不是后天

01:47.750 --> 01:49.750
今年 后年

01:49.750 --> 01:51.750
那么到了后年的时候 你懂得

01:51.750 --> 01:54.750
不可能说以前的项目呢 就说完全不动它了

01:54.750 --> 01:58.750
可能又要回 又会拿出来修改一下 更新一下

01:58.750 --> 02:00.750
可能会接着开发

02:00.750 --> 02:03.750
所以说呢 你可能会需要在你的计算机上

02:03.750 --> 02:05.750
不停的去切换这个Note的版本

02:05.750 --> 02:08.750
因为你要开发的 你要维护两年前的项目

02:08.750 --> 02:11.750
那么你肯定要用这个V8的版本

02:11.750 --> 02:13.750
那么你要去切换到V8这个版本

02:13.750 --> 02:15.750
你肯定用最新版本不太合适

02:15.750 --> 02:17.750
因为有些API可能会变懂

02:17.750 --> 02:20.750
你用最新版本的话 会导致项目可能会运行不起来

02:20.750 --> 02:22.750
然后呢 你如果说你

02:22.750 --> 02:24.750
你要维护经典开发的项目的话

02:24.750 --> 02:26.750
那么你要使用V12 你要维护

02:26.750 --> 02:29.750
后年的开发的项目的话 你要使用最新版V14

02:29.750 --> 02:30.750
明儿的意思吗

02:30.750 --> 02:33.750
但是你的计算机上只能安装一个Note的版本

02:33.750 --> 02:35.750
那么就会造成问题

02:35.750 --> 02:37.750
我每一次就特别特别麻烦

02:37.750 --> 02:39.750
我要维护两年前 怎么办呢

02:39.750 --> 02:41.750
我得把现在的Note的版本卸杂掉

02:41.750 --> 02:43.750
卸杂干净 卸杂完了过后呢

02:43.750 --> 02:46.750
我还要去切换到这个版本

02:46.750 --> 02:48.750
去下载这个对应的版本

02:48.750 --> 02:50.750
下载完了过后呢 进行安装

02:50.750 --> 02:52.750
好 不容易啊 可能维护的

02:52.750 --> 02:55.750
维护十来分钟就维护完了

02:55.750 --> 02:56.750
维护完了过后我要干嘛呢

02:56.750 --> 02:58.750
又要维护后年呢 就是我们

02:58.750 --> 02:59.750
最新的项目 最新的项目

02:59.750 --> 03:01.750
是不是又得把Note的卸杂掉

03:01.750 --> 03:05.750
卸杂安装的时间就有M1超过了我维护的时间

03:05.750 --> 03:07.750
很有可能会出现这么一种情况

03:07.750 --> 03:09.750
那么就可能会需要一个工具

03:09.750 --> 03:11.750
来帮我们管理各种版本

03:11.750 --> 03:15.750
那么这个NDM呢 就是用来切换版本的一个工具

03:15.750 --> 03:17.750
好 首先呢 我们来下载和安装

03:17.750 --> 03:19.750
怎么就下载呢 到这个地址

03:19.750 --> 03:22.750
因为它本身呢 没有什么官网

03:22.750 --> 03:24.750
它没有官网 就一个github地址

03:24.750 --> 03:26.750
那么github里面 我们都知道

03:26.750 --> 03:29.750
它里面有一个什么release 就是我们它的发布版

03:29.750 --> 03:31.750
它的发布版呢 进这个页面

03:31.750 --> 03:33.750
就可以看到它最新的发布版

03:33.750 --> 03:35.750
那么这个NDM就不要去管了

03:35.750 --> 03:37.750
它肯定是下载最新版本就完事了

03:37.750 --> 03:39.750
那么这个NDM的工具呢 你下载最新版本

03:39.750 --> 03:41.750
所以说你们打开这个地址呢

03:41.750 --> 03:44.750
可能看到的最新版呢 跟我这里面不一样

03:44.750 --> 03:46.750
可能里面那边可能还要更新一点

03:46.750 --> 03:48.750
那么里面就下载最新的版本就完事了

03:48.750 --> 03:50.750
好 点进去 点进去

03:50.750 --> 03:53.750
点进去过后呢 下面有很多动作下载方案

03:53.750 --> 03:55.750
方案 那咱们现在加载哪一个呢

03:55.750 --> 03:58.750
第一个呢 是不安装的 不用安装的

03:58.750 --> 04:00.750
相当于是绿色版

04:00.750 --> 04:02.750
那么这个呢 是要安装的

04:02.750 --> 04:04.750
咱们下载这个 NDM setup

04:04.750 --> 04:06.750
下载这个安装版就完事了

04:06.750 --> 04:08.750
好 下载下来过后呢 我这里已经安装了

04:08.750 --> 04:11.750
我给它看一下 下载下来是一个一家说包

04:11.750 --> 04:13.750
那么你解压

04:13.750 --> 04:15.750
解压

04:15.750 --> 04:17.750
解压完了过后呢 有个安装文件

04:17.750 --> 04:19.750
你双击它 安装

04:19.750 --> 04:21.750
安装的时候呢 我们选这个

04:21.750 --> 04:23.750
就是接受它的

04:23.750 --> 04:25.750
就是这个

04:25.750 --> 04:27.750
嗯 协议 接受它的协议

04:27.750 --> 04:29.750
那么这个协议呢 我们可以认识到

04:29.750 --> 04:31.750
以前讲过的 对吧 MIT协议

04:31.750 --> 04:33.750
好 那么下一步

04:33.750 --> 04:35.750
下一步呢 它问你

04:35.750 --> 04:37.750
NDM呢 安装到什么地址

04:37.750 --> 04:39.750
安装到什么位置 那么这个东西呢 你可以改

04:39.750 --> 04:41.750
但是我不是很推荐大家改它

04:41.750 --> 04:43.750
像我的习惯的话

04:43.750 --> 04:45.750
凡是开发软件 开发工具呢

04:45.750 --> 04:47.750
我都不太会去改动它的地址

04:47.750 --> 04:49.750
好 然后呢 我们下一步

04:49.750 --> 04:51.750
下一步呢 是

04:51.750 --> 04:53.750
NoteGS的安装目录

04:53.750 --> 04:55.750
NoteGS的安装目录

04:55.750 --> 04:57.750
NoteGS安装目录呢 你这里就保持

04:57.750 --> 04:59.750
你之前这个NoteGS安装到哪儿了

04:59.750 --> 05:01.750
那么这里呢 就选择哪个位置

05:01.750 --> 05:03.750
这也是我为什么

05:03.750 --> 05:05.750
不太愿意去改动这个位置的原因

05:05.750 --> 05:07.750
改动了过后呢

05:07.750 --> 05:09.750
可能一些别的软件要跟它配合的时候呢

05:09.750 --> 05:11.750
它无法知道它的地址是什么

05:11.750 --> 05:13.750
我这里呢 就直接

05:13.750 --> 05:15.750
保持默认了 因为我的NoteGS呢

05:15.750 --> 05:17.750
本身就安装到这了

05:17.750 --> 05:19.750
然后呢 点下一步

05:19.750 --> 05:21.750
然后呢 就直接安装就完了

05:21.750 --> 05:23.750
安装到过程中呢 它会弹出 有可能

05:23.750 --> 05:25.750
会弹出一个框 问你

05:25.750 --> 05:27.750
你之前NoteGS已经安装了

05:27.750 --> 05:29.750
如果说你NoteGS没有安装的话

05:29.750 --> 05:31.750
那么它会自动帮你安装 安装一个版本

05:31.750 --> 05:33.750
如果说你的NoteGS已经安装的话

05:33.750 --> 05:35.750
它会问你

05:35.750 --> 05:37.750
就是在刚才这个目录下面

05:37.750 --> 05:39.750
它发现了已经有NoteGS了

05:39.750 --> 05:41.750
你这个NoteGS要不要加入版本控制

05:41.750 --> 05:43.750
就是NVM的版本控制

05:43.750 --> 05:45.750
要不要 你选4就行了

05:45.750 --> 05:47.750
OK 那么最后呢 我就安装就完了

05:47.750 --> 05:49.750
否则就取消了

05:49.750 --> 05:51.750
因为我已经安装了

05:51.750 --> 05:53.750
安装完成之后呢

05:53.750 --> 05:55.750
接下来我们就可以在命令行里面

05:55.750 --> 05:57.750
对它进行操作

05:57.750 --> 05:59.750
要切换版本呀 要下载新的Note的版本呀

05:59.750 --> 06:01.750
要下载旧的Note的版本呀

06:01.750 --> 06:03.750
那些东西呢 都可以在命令行里面操作

06:03.750 --> 06:05.750
因为这个NVM呢

06:05.750 --> 06:07.750
它已经提供了一个CD工具

06:07.750 --> 06:09.750
来用来管理这个Note的版本

06:09.750 --> 06:11.750
好 那么

06:11.750 --> 06:13.750
如何来使用这个NVM的命令呢

06:13.750 --> 06:15.750
我们要首先打开命令行

06:15.750 --> 06:17.750
命令行的话

06:17.750 --> 06:19.750
我这里就不在VSCode里面了

06:19.750 --> 06:21.750
我们就直接打开一个PowerShell

06:21.750 --> 06:23.750
或者是CMD也行

06:23.750 --> 06:25.750
PowerShell 我们这里点击右键

06:25.750 --> 06:27.750
使用管理员身份运行

06:27.750 --> 06:29.750
因为它里面有可能要下载安装

06:29.750 --> 06:31.750
所以说它不用管理员的话

06:31.750 --> 06:33.750
它每次都要提示你

06:33.750 --> 06:35.750
不停的提示你很烦的

06:35.750 --> 06:37.750
用管理员安装

06:37.750 --> 06:39.750
打开管理员

06:39.750 --> 06:41.750
用管理员身份运行这个PowerShell

06:41.750 --> 06:43.750
然后呢 我们来输入这个NVM命令

06:43.750 --> 06:45.750
好 你看到

06:45.750 --> 06:47.750
它会提示你这个NVM

06:47.750 --> 06:49.750
现在是1.1.7这个版本

06:49.750 --> 06:51.750
那么怎么来用呢

06:51.750 --> 06:53.750
怎么来用呢 它可以提供了

06:53.750 --> 06:55.750
下面这些命令来使用

06:55.750 --> 06:57.750
其实这些命令非常非常简单

06:57.750 --> 06:59.750
咱们随便看几个吧

06:59.750 --> 07:01.750
看几个常见的

07:01.750 --> 07:03.750
其实第一个都不太常见

07:03.750 --> 07:05.750
打印出你目前系统的版本

07:05.750 --> 07:07.750
和它默认安装的漏的版本

07:07.750 --> 07:09.750
漏的的就是叫做架构

07:09.750 --> 07:11.750
架构类型

07:11.750 --> 07:13.750
什么意思呢 我们来看一下吧

07:13.750 --> 07:15.750
NVM Arch

07:15.750 --> 07:17.750
目前我的计算机上

07:17.750 --> 07:19.750
是64位的

07:19.750 --> 07:21.750
也就是说我的计算机

07:21.750 --> 07:23.750
是64位的计算机

07:23.750 --> 07:25.750
现在的笔记本 现在的台式机

07:25.750 --> 07:27.750
基本上都是64位的

07:27.750 --> 07:29.750
然后它默认配置的是

07:29.750 --> 07:31.750
默认安装漏的

07:31.750 --> 07:33.750
架构类型的

07:33.750 --> 07:35.750
是64位

07:35.750 --> 07:37.750
所以说就没事了 看一下就行了

07:37.750 --> 07:39.750
主要是它第二个

07:39.750 --> 07:41.750
第二个是什么呢 Insta

07:41.750 --> 07:43.750
表示的是使用NVM

07:43.750 --> 07:45.750
来安装一个指定的漏的版本

07:45.750 --> 07:47.750
比如说我这里写个

07:47.750 --> 07:49.750
8.5.4 随便写个吧

07:49.750 --> 07:51.750
那么它就会怎么样呢

07:51.750 --> 07:53.750
它就会安装8.5.4这个版本

07:53.750 --> 07:55.750
就这么简单

07:55.750 --> 07:57.750
那么有同学想问

07:57.750 --> 07:59.750
我怎么知道漏的有哪些版本呢

07:59.750 --> 08:01.750
我怎么知道呢

08:01.750 --> 08:03.750
那要看你之前的那个程序

08:03.750 --> 08:05.750
是使用了哪一个漏的版本写的

08:05.750 --> 08:07.750
那如果说你一定要

08:07.750 --> 08:09.750
列出来的有哪些版本的话

08:09.750 --> 08:11.750
你可以使用这个名字

08:11.750 --> 08:13.750
上面有一个提示 使用List这个名字

08:13.750 --> 08:15.750
NVM

08:15.750 --> 08:17.750
不是NPM

08:17.750 --> 08:19.750
NVM List

08:19.750 --> 08:21.750
那么这里它就会列出

08:21.750 --> 08:23.750
你目前的电脑上

08:23.750 --> 08:25.750
目前使用的

08:25.750 --> 08:27.750
已经安装过了哪些

08:27.750 --> 08:29.750
漏的版本

08:29.750 --> 08:31.750
目前我只安装了一个

08:31.750 --> 08:33.750
就是12.14.0

08:33.750 --> 08:35.750
就是最新版本

08:35.750 --> 08:37.750
如果说你还安装了别的版本的话

08:37.750 --> 08:39.750
那么它会这里提示你

08:39.750 --> 08:41.750
然后前面有个新号 新号什么意思呢

08:41.750 --> 08:43.750
表示目前正在使用的版本

08:43.750 --> 08:45.750
是12.14.0

08:45.750 --> 08:47.750
如果说你要查看

08:47.750 --> 08:49.750
漏的一共有哪些版本呢

08:49.750 --> 08:51.750
NVM List

08:51.750 --> 08:53.750
后面有提示 有这么一个单词叫available

08:53.750 --> 08:55.750
表示可用的

08:55.750 --> 08:57.750
available

08:57.750 --> 08:59.750
那么表示一共漏的

08:59.750 --> 09:01.750
除了哪些版本呢 咱们回测看一下

09:01.750 --> 09:03.750
后边两列

09:03.750 --> 09:05.750
它有一个表格 后边两列不用看

09:05.750 --> 09:07.750
那都是非常非常旧的版本了

09:07.750 --> 09:09.750
表示旧的稳定版

09:09.750 --> 09:11.750
旧的不稳定版 不用看

09:11.750 --> 09:13.750
我们只看什么呢 只看这个

09:13.750 --> 09:15.750
Netist

09:15.750 --> 09:17.750
Netist stable LTS

09:17.750 --> 09:19.750
LTS我以前好像在

09:19.750 --> 09:21.750
安装漏的时候解释过

09:21.750 --> 09:23.750
表示的是最新的稳定版

09:23.750 --> 09:25.750
所以说我们安装的话

09:25.750 --> 09:27.750
一般安装的是最新的稳定版

09:27.750 --> 09:29.750
最新的稳定版

09:29.750 --> 09:31.750
那么目前有这么一些版本 都是稳定版

09:31.750 --> 09:33.750
都是稳定版

09:33.750 --> 09:35.750
其实具体的要看

09:35.750 --> 09:37.750
你到底要安装哪个版本 具体的要看

09:37.750 --> 09:39.750
你现在的工程要用哪个版本

09:39.750 --> 09:41.750
用哪个版本就安装哪个版本

09:41.750 --> 09:43.750
然后这左边的还有Corrent

09:43.750 --> 09:45.750
Corrent一般表示的是

09:45.750 --> 09:47.750
目前的版本 目前的最新版

09:47.750 --> 09:49.750
但是最新版还不一定是稳定的

09:49.750 --> 09:51.750
那么目前有这么一些版本

09:51.750 --> 09:53.750
它都是可以安装的

09:53.750 --> 09:55.750
但是它不一定稳定

09:55.750 --> 09:57.750
所以说我们安装的一般的是这个

09:57.750 --> 09:59.750
比方说吧 我们刚才看到的

09:59.750 --> 10:01.750
我们本本的版本是12.14.0

10:01.750 --> 10:03.750
我们来再看一次

10:03.750 --> 10:05.750
NVM LTS可以通过这个东西来查看

10:05.750 --> 10:07.750
目前使用的版本是这个版本

10:07.750 --> 10:09.750
也可以通过load刚v来查看

10:09.750 --> 10:11.750
目前使用的版本是这个版本

10:11.750 --> 10:13.750
比方说我们要安装一个

10:13.750 --> 10:15.750
10.18.0

10:15.750 --> 10:17.750
来复制一下

10:17.750 --> 10:19.750
怎么安装 就NVM install

10:19.750 --> 10:21.750
那么这里的使用

10:21.750 --> 10:23.750
这个名字就行了

10:23.750 --> 10:25.750
但是我这里不着急回车

10:25.750 --> 10:27.750
为啥呢 因为这个安装过程

10:27.750 --> 10:29.750
很有可能会爆错

10:29.750 --> 10:31.750
为啥会爆错呢 因为它会连接到load

10:31.750 --> 10:33.750
它的github地址去安装

10:33.750 --> 10:35.750
它会安装load的时候

10:35.750 --> 10:37.750
会安装load的时候 会安装两个东西

10:37.750 --> 10:39.750
一个是load本身

10:39.750 --> 10:41.750
一个是load对应的

10:41.750 --> 10:43.750
NVM版本

10:43.750 --> 10:45.750
因为我们知道load安装load的时候

10:45.750 --> 10:47.750
它会对应安装NVM对吧

10:47.750 --> 10:49.750
所以它这里安装的时候

10:49.750 --> 10:50.750
它会分开安装

10:50.750 --> 10:51.750
一个是load

10:51.750 --> 10:52.750
一个是下载load

10:52.750 --> 10:53.750
一个是下载NVM

10:53.750 --> 10:55.750
那么这两个都是在

10:55.750 --> 10:57.750
Y网上面 都是在海外的网站上面

10:57.750 --> 10:59.750
github上面

10:59.750 --> 11:01.750
很有可能就会导致下载不成功

11:01.750 --> 11:03.750
因此怎么办呢

11:03.750 --> 11:05.750
因此我们通常在这里会使用代理

11:05.750 --> 11:07.750
会使用代理来进行加快下载速度

11:07.750 --> 11:09.750
我们这里有两个代理

11:09.750 --> 11:11.750
一个是load的淘宝镜像

11:11.750 --> 11:13.750
一个是NVM的淘宝镜像

11:13.750 --> 11:15.750
我希望它一会下载的时候

11:15.750 --> 11:17.750
下载load就从这个地址去下载

11:17.750 --> 11:19.750
从这个地址里面

11:19.750 --> 11:21.750
去下载相应的版本

11:21.750 --> 11:23.750
如果下载NVM的话

11:23.750 --> 11:25.750
就从这个地址去下载对应的

11:25.750 --> 11:27.750
NVM版本

11:27.750 --> 11:29.750
这个地址好像

11:29.750 --> 11:31.750
好像也是那个

11:31.750 --> 11:33.750
github我当时不是填错了

11:33.750 --> 11:35.750
当时不是填错了

11:35.750 --> 11:37.750
我这里

11:37.750 --> 11:39.750
我这里再找一下

11:39.750 --> 11:41.750
找一下看能不能

11:41.750 --> 11:43.750
改一下淘宝镜像

11:43.750 --> 11:45.750
NVM淘宝镜像

11:45.750 --> 11:47.750
NVM淘宝镜像

11:47.750 --> 11:49.750
它替换的是

11:49.750 --> 11:51.750
我试一下吧

11:51.750 --> 11:53.750
这样改了之后能不能下载成功

11:53.750 --> 11:55.750
或者是我马上查一下

11:55.750 --> 11:57.750
我把视频中断一下

11:57.750 --> 11:59.750
我去查一下NVM淘宝镜像在哪

11:59.750 --> 12:01.750
我找到了

12:01.750 --> 12:03.750
其实就是

12:03.750 --> 12:05.750
就这个地址

12:05.750 --> 12:07.750
这个地址

12:07.750 --> 12:09.750
保存一下

12:09.750 --> 12:11.750
这个地址

12:11.750 --> 12:13.750
我们把load的下载地址

12:13.750 --> 12:15.750
改成这个

12:15.750 --> 12:17.750
NVM的下载地址改成这个

12:17.750 --> 12:19.750
其实我们可以进去看一下

12:19.750 --> 12:21.750
load的地址

12:21.750 --> 12:23.750
它里面就有各种各样的版本

12:23.750 --> 12:25.750
包括NVM的地址

12:25.750 --> 12:27.750
有各种各样的NVM版本

12:27.750 --> 12:29.750
都是在淘宝的地址上

12:29.750 --> 12:31.750
这样下载起来就比较快一点

12:31.750 --> 12:33.750
现在问题是我们怎么来设置

12:33.750 --> 12:35.750
淘宝镜像呢

12:35.750 --> 12:37.750
高速NVM要从这个地址去下载呢

12:37.750 --> 12:39.750
那么我们肯定是不用

12:39.750 --> 12:41.750
NVM在打印出来

12:41.750 --> 12:43.750
那么使用这个load mirror

12:43.750 --> 12:45.750
来设置和NPM mirror来设置

12:45.750 --> 12:47.750
来吧

12:47.750 --> 12:49.750
NVM load mirror

12:49.750 --> 12:51.750
空格

12:51.750 --> 12:52.750
后边设置啥呢

12:52.750 --> 12:53.750
设置load的淘宝镜像

12:53.750 --> 12:55.750
复制一下

12:55.750 --> 12:57.750
粘贴过来

12:57.750 --> 12:59.750
回车

12:59.750 --> 13:01.750
然后再去NVM

13:01.750 --> 13:03.750
就是NPM mirror

13:03.750 --> 13:05.750
再来设置一下

13:05.750 --> 13:07.750
NPM的淘宝镜像地址

13:08.750 --> 13:09.750
回车

13:09.750 --> 13:10.750
那么这样子一来了

13:10.750 --> 13:11.750
它后边下载的时候呢

13:11.750 --> 13:13.750
就会按照这两个地址下载

13:13.750 --> 13:15.750
咱们可以查看一下load mirror

13:15.750 --> 13:17.750
load mirror

13:17.750 --> 13:19.750
20

13:19.750 --> 13:21.750
它没打印出来

13:21.750 --> 13:23.750
load mirror

13:23.750 --> 13:25.750
它没打印出来

13:25.750 --> 13:27.750
算了吧

13:27.750 --> 13:29.750
咱们直接下载

13:29.750 --> 13:31.750
NVM install

13:31.750 --> 13:33.750
后边呢

13:33.750 --> 13:35.750
跟上你的版本号

13:35.750 --> 13:37.750
我要下载哪个版本

13:37.750 --> 13:39.750
我要下载的是10.18.0

13:39.750 --> 13:41.750
复制一下

13:41.750 --> 13:43.750
下载这个版本

13:43.750 --> 13:45.750
好 又回车

13:45.750 --> 13:47.750
那么这个时候呢

13:47.750 --> 13:49.750
它就会去

13:49.750 --> 13:51.750
我们指定的淘宝镜像里边去下载load

13:51.750 --> 13:53.750
又从指定的淘宝镜像里边去下载

13:53.750 --> 13:55.750
10.18.0这个load的版本

13:55.750 --> 13:57.750
它对应的NPM的版本

13:57.750 --> 13:59.750
都会去下载

13:59.750 --> 14:01.750
稍等一下

14:01.750 --> 14:03.750
它默认下载的是64

14:03.750 --> 14:05.750
如果说你一定要下载32位的load的话

14:05.750 --> 14:07.750
那么后边空格

14:07.750 --> 14:09.750
跟上一个32的数字就行了

14:09.750 --> 14:11.750
空格32就行了

14:11.750 --> 14:13.750
一般来说我们都不用去动它

14:13.750 --> 14:14.750
因为现在电脑

14:14.750 --> 14:16.750
绝大部分情况下都使用的是64

14:16.750 --> 14:19.750
但是如果说保不起你以前的开发的项目

14:19.750 --> 14:20.750
是32位的

14:20.750 --> 14:22.750
那么你去下载对应的32位就完事了

14:23.750 --> 14:25.750
稍等一下

14:26.750 --> 14:31.020
这个等的时间有点长

14:31.020 --> 14:33.020
我这里剪一下呗

14:33.020 --> 14:35.020
我这里已经下载好了

14:35.020 --> 14:37.020
你会看到它说已经下载

14:37.020 --> 14:39.020
完成了10.18.0这个版本

14:39.020 --> 14:41.020
然后呢

14:41.020 --> 14:43.020
NPM的版本呢

14:43.020 --> 14:45.020
是6.13.4这个版本

14:45.020 --> 14:46.020
都下载好了

14:46.020 --> 14:47.020
那么现在呢

14:47.020 --> 14:49.020
我们再来使用这个mini

14:49.020 --> 14:50.020
清空一下啊

14:50.020 --> 14:52.020
使用NVM list来看一下

14:52.020 --> 14:54.020
现在有两个版本了

14:54.020 --> 14:56.020
我们目前的load的版本有两个

14:56.020 --> 14:58.020
一个是我们目前正在使用的版本

14:58.020 --> 14:59.020
12.14.0

14:59.020 --> 15:01.020
你看一下load的钢飞

15:01.020 --> 15:02.020
12.14.0

15:02.020 --> 15:04.020
然后呢已经有一个可以切换的版本

15:04.020 --> 15:06.020
10.18.0

15:06.020 --> 15:07.020
对吧

15:07.020 --> 15:09.020
那么如果说你还要下载更多的版本

15:09.020 --> 15:10.020
可以参与管理的话

15:10.020 --> 15:12.020
那么你继续下载

15:12.020 --> 15:13.020
好下载完了之后

15:13.020 --> 15:15.020
以后怎么来切换版本呢

15:15.020 --> 15:16.020
非常的简单

15:16.020 --> 15:18.020
我们使用这个mini

15:18.020 --> 15:20.020
NVM use

15:20.020 --> 15:22.020
比较多我们要切换到10.18.0

15:22.020 --> 15:24.020
好一回车

15:24.020 --> 15:25.020
你看

15:25.020 --> 15:26.020
是不是他告诉你啊

15:26.020 --> 15:27.020
现在已经切换了过来了

15:27.020 --> 15:29.020
那么我们来查看一下啊

15:29.020 --> 15:31.020
NVM list

15:31.020 --> 15:33.020
你看现在是不是使用了这个版本

15:33.020 --> 15:35.020
然后我们再使用load的mini

15:35.020 --> 15:36.020
load钢飞

15:36.020 --> 15:37.020
你看是不是变成这个版本了

15:37.020 --> 15:39.020
就非常容易切换

15:39.020 --> 15:41.020
就这么简单啊NVM

15:41.020 --> 15:42.020
可以通过这种

15:42.020 --> 15:43.020
那么到时候要用回去呢

15:43.020 --> 15:45.020
又用NVM use

15:45.020 --> 15:47.020
12.14.0

15:47.020 --> 15:48.020
你看是不是又切换回去了

15:48.020 --> 15:49.020
对不对

15:49.020 --> 15:51.020
其实它是怎么运作的呢

15:51.020 --> 15:52.020
它是这样运作的

15:52.020 --> 15:54.020
我们用NVM

15:54.020 --> 15:55.020
mini来看一下

15:55.020 --> 15:56.020
它其中有一个呢

15:56.020 --> 15:57.020
叫做root

15:57.020 --> 15:58.020
rootmini

15:58.020 --> 15:59.020
怎么看一下啊

15:59.020 --> 16:01.020
NVM root

16:01.020 --> 16:03.020
它其实呢就是把我们的load

16:03.020 --> 16:04.020
下来到哪呢

16:04.020 --> 16:05.020
下来到这个位置

16:05.020 --> 16:06.020
下来到这个位置

16:06.020 --> 16:08.020
那么复制一下

16:08.020 --> 16:09.020
打开

16:10.020 --> 16:11.020
粘贴过来

16:11.020 --> 16:12.020
好你看

16:12.020 --> 16:13.020
所以下来到这个位置

16:13.020 --> 16:14.020
这个位置是不是有两个版本

16:14.020 --> 16:15.020
对吧

16:15.020 --> 16:16.020
load了两个版本

16:16.020 --> 16:17.020
下来到这个位置

16:17.020 --> 16:18.020
然后呢

16:18.020 --> 16:19.020
如果说

16:19.020 --> 16:20.020
我们要切换到这个版本

16:20.020 --> 16:21.020
它怎么样呢

16:21.020 --> 16:23.020
它就把这个版本的内容呢

16:23.020 --> 16:24.020
相当于是

16:24.020 --> 16:26.020
我们可以这样理解吧

16:26.020 --> 16:28.020
相当于把这个文件下来的内容呢

16:28.020 --> 16:30.020
把它的内容复制粘贴到哪呢

16:30.020 --> 16:32.020
粘贴到load的安装目录

16:32.020 --> 16:34.020
然后如果要切换到这个文件

16:34.020 --> 16:35.020
切换到这个版本呢

16:35.020 --> 16:36.020
也把这个文件

16:36.020 --> 16:37.020
版本里边的内容呢

16:37.020 --> 16:39.020
安装到就是load的安装目录

16:39.020 --> 16:41.020
它就可以用这种方式来进行切换

16:41.020 --> 16:42.020
对吧

16:42.020 --> 16:43.020
它就可以非常高效的进行切换了

16:43.020 --> 16:44.020
就这么简单

16:45.020 --> 16:46.020
这里有个点呢

16:46.020 --> 16:48.020
大家需要注意一下

16:48.020 --> 16:50.020
就是我们切换版本之后呢

16:50.020 --> 16:52.020
它每一个版本呢

16:52.020 --> 16:54.020
它对应了一个

16:54.020 --> 16:58.020
全局包的内容

16:58.020 --> 17:00.020
啥意思呢

17:00.020 --> 17:01.020
比方说啊

17:01.020 --> 17:03.020
我们在load的

17:03.020 --> 17:05.020
load的这个V8这个版本里边

17:05.020 --> 17:06.020
比方说啊

17:06.020 --> 17:07.020
V10嘛

17:07.020 --> 17:08.020
V10的这个版本里边

17:08.020 --> 17:10.020
可能全局安装了一些包

17:10.020 --> 17:11.020
全局包

17:11.020 --> 17:12.020
我们知道有的时候呢

17:12.020 --> 17:14.020
我们特别是一些教授下

17:14.020 --> 17:15.020
我们需要全局安装对吧

17:15.020 --> 17:17.020
全局安装了一些包

17:17.020 --> 17:19.020
那么比方说包A

17:19.020 --> 17:20.020
包B

17:20.020 --> 17:21.020
包C

17:21.020 --> 17:22.020
我们安装了一些包

17:22.020 --> 17:23.020
那么可能呢

17:23.020 --> 17:25.020
在load的V12里边呢

17:25.020 --> 17:26.020
V12里边呢

17:26.020 --> 17:28.020
又全局安装了这些包

17:28.020 --> 17:29.020
啊

17:29.020 --> 17:30.020
全局包

17:30.020 --> 17:31.020
安装了一些包

17:31.020 --> 17:32.020
比方说啊

17:32.020 --> 17:33.020
C

17:33.020 --> 17:34.020
D

17:34.020 --> 17:36.020
比方说安装了这些包

17:36.020 --> 17:37.020
那么它会

17:37.020 --> 17:39.020
在切换版本的时候呢

17:39.020 --> 17:41.020
它也会自动的去切换

17:41.020 --> 17:42.020
这个全局安装包

17:42.020 --> 17:43.020
比方的意思吗

17:43.020 --> 17:45.020
它为什么要这样做呢

17:45.020 --> 17:46.020
因为不同的

17:46.020 --> 17:47.020
在load不同的版本下边

17:47.020 --> 17:49.020
它全局包的可能

17:49.020 --> 17:51.020
它支持的版本是不是也不一样

17:51.020 --> 17:52.020
对吧

17:52.020 --> 17:53.020
又比方说

17:53.020 --> 17:54.020
这个C这个包

17:54.020 --> 17:55.020
在12这个

17:55.020 --> 17:56.020
load为12这个版本里边

17:56.020 --> 17:57.020
它可能是最新版

17:57.020 --> 17:58.020
到10这个版本里边

17:58.020 --> 17:59.020
它最新版可能就不是

17:59.020 --> 18:00.020
这个最新版了

18:00.020 --> 18:01.020
没什么意思吗

18:01.020 --> 18:02.020
所以说它为了保证

18:02.020 --> 18:03.020
这些全局包在

18:03.020 --> 18:04.020
每一个load的版本下面

18:04.020 --> 18:05.020
都是可用的

18:05.020 --> 18:06.020
至少不会出问题

18:06.020 --> 18:07.020
所以说

18:07.020 --> 18:08.020
它要每一个全

18:08.020 --> 18:09.020
每一个load的版本呢

18:09.020 --> 18:10.020
要对应一个全局包

18:10.020 --> 18:11.020
因此呢

18:11.020 --> 18:12.020
我们在不同的load的

18:12.020 --> 18:13.020
版本里边

18:13.020 --> 18:14.020
看到的是不同的全局包

18:14.020 --> 18:15.020
有可能

18:15.020 --> 18:16.020
关键是看你怎么去安装的

18:16.020 --> 18:17.020
是在哪个版本里面

18:17.020 --> 18:18.020
去安装的

18:18.020 --> 18:19.020
比方说我们现在的load的版本

18:19.020 --> 18:22.020
Nest

18:22.020 --> 18:23.020
看一下目前的版本

18:23.020 --> 18:24.020
咱们把切换回去

18:24.020 --> 18:26.020
比方说我们使用那个

18:26.020 --> 18:28.020
又是12.14.0

18:28.020 --> 18:30.020
这是我们之前安装的最新版

18:30.020 --> 18:31.020
对吧

18:31.020 --> 18:32.020
然后呢之前呢

18:32.020 --> 18:33.020
我们还记得吗

18:33.020 --> 18:34.020
我们之前是安装了一个

18:34.020 --> 18:35.020
load的猛戒全局

18:35.020 --> 18:36.020
咱们来试一下

18:36.020 --> 18:38.020
NPM

18:38.020 --> 18:39.020
杠季

18:39.020 --> 18:40.020
看一下全局安装的包

18:40.020 --> 18:42.020
Debs

18:42.020 --> 18:44.780
你看呀

18:44.780 --> 18:46.780
之前安装了一个load的猛

18:46.780 --> 18:47.780
这个包

18:47.780 --> 18:48.780
这个是NPM更新的

18:48.780 --> 18:49.780
不用管它

18:49.780 --> 18:50.780
那么这个是不是load的猛

18:50.780 --> 18:51.780
最新的包

18:51.780 --> 18:52.780
对吧

18:52.780 --> 18:53.780
其实实际上

18:53.780 --> 18:54.780
我们加入load的版本

18:54.780 --> 18:55.780
管理过后了

18:55.780 --> 18:56.780
这个东西都可以不用了

18:56.780 --> 18:57.780
都可以不用去

18:57.780 --> 18:59.780
不用去用它了

18:59.780 --> 19:00.780
好咱们来看一下

19:00.780 --> 19:02.780
如果说现在我们切换版本

19:02.780 --> 19:03.780
Nest

19:03.780 --> 19:05.780
NVM use

19:05.780 --> 19:07.780
10.18.0

19:07.780 --> 19:08.780
切换到这个版本

19:08.780 --> 19:09.780
好切换过来之后呢

19:09.780 --> 19:10.780
我们再来看

19:10.780 --> 19:12.780
NPM杠季

19:14.780 --> 19:15.780
全局包

19:16.780 --> 19:17.780
你看那个load的猛

19:17.780 --> 19:18.780
是不是没了

19:18.780 --> 19:19.780
对吧

19:19.780 --> 19:20.780
是不是没了

19:20.780 --> 19:21.780
那么为什么都没了

19:21.780 --> 19:23.780
因为load猛之前是在

19:23.780 --> 19:24.780
另外一个版本里面

19:24.780 --> 19:25.780
是在12.14.0

19:25.780 --> 19:26.780
这个版本里面安装的

19:26.780 --> 19:28.780
那么现在切换到这个版本

19:28.780 --> 19:29.780
它肯定就没了

19:29.780 --> 19:30.780
所以说有些东西

19:30.780 --> 19:32.780
你可能切换过后

19:32.780 --> 19:34.780
你得重新进行全局安装

19:34.780 --> 19:35.780
其实这个东西是好事

19:35.780 --> 19:36.780
就是它就

19:36.780 --> 19:37.780
什么意思呢

19:37.780 --> 19:38.780
它就是建议你

19:38.780 --> 19:40.780
你以后开发项目的时候

19:40.780 --> 19:41.780
你一定要用NVM

19:41.780 --> 19:43.780
来对load的进行管理

19:43.780 --> 19:45.780
比如说我这个项目

19:45.780 --> 19:47.780
要用load的

19:47.780 --> 19:48.780
load的什么版本

19:48.780 --> 19:49.780
load的v10这个版本

19:49.780 --> 19:50.780
OK

19:50.780 --> 19:52.780
就用NVM去切换到这个版本

19:52.780 --> 19:53.780
切换过后

19:53.780 --> 19:54.780
在这个版本里面

19:54.780 --> 19:55.780
该安装什么全局包

19:55.780 --> 19:56.780
就安装什么全局包

19:56.780 --> 19:57.780
然后去开发你的项目

19:57.780 --> 19:59.780
开发完了过后

19:59.780 --> 20:00.780
以后又遇到新的项目了

20:00.780 --> 20:02.780
可能我们要换版本

20:02.780 --> 20:04.780
就换到这个v12里面

20:04.780 --> 20:07.780
v12它又有自己的全局包

20:07.780 --> 20:09.780
那么在这个版本环境下边

20:09.780 --> 20:10.780
你又去安装什么样的全局包

20:10.780 --> 20:11.780
你自己去安装

20:11.780 --> 20:12.780
那么这样子

20:12.780 --> 20:13.780
就非常容易切换

20:13.780 --> 20:14.780
还原现场

20:14.780 --> 20:15.780
比方说将来

20:15.780 --> 20:17.780
我要维护这个v10的环境

20:17.780 --> 20:18.780
那么我切换到v10

20:18.780 --> 20:20.780
同样的就把之前的全局包

20:20.780 --> 20:21.780
全部切换过来了

20:21.780 --> 20:23.780
这样子其实是好事

20:23.780 --> 20:24.780
这个意思

20:24.780 --> 20:26.780
OK 这是关于这个NVM的使用

20:26.780 --> 20:27.780
其他还有啥呢

20:27.780 --> 20:29.780
其他这个命令里面

20:29.780 --> 20:30.780
也就没啥了

20:30.780 --> 20:32.780
也就没啥了

20:32.780 --> 20:33.780
就没啥了

20:33.780 --> 20:34.780
其他都

20:34.780 --> 20:35.780
还有一个卸载

20:35.780 --> 20:36.780
一个卸载叫UlisDo

20:36.780 --> 20:37.780
UlisDo卸载

20:37.780 --> 20:38.780
卸载的话

20:38.780 --> 20:39.780
前例条件

20:39.780 --> 20:41.780
你这个窗口得用管理员打开

20:41.780 --> 20:42.780
不然的话不太容易卸载掉

20:42.780 --> 20:44.780
比方说我们现在要卸载

20:44.780 --> 20:45.780
哪个版本呢

20:45.780 --> 20:46.780
卸载

20:47.780 --> 20:49.780
目前用的是10.18.0

20:49.780 --> 20:50.780
对吧

20:50.780 --> 20:51.780
把卸载掉

20:51.780 --> 20:53.780
先把它切换去

20:53.780 --> 20:55.780
切换到12.14.0

20:55.780 --> 20:57.780
切换过去再看一下

20:59.780 --> 21:00.780
切换过去

21:00.780 --> 21:02.780
然后呢使用NVM

21:02.780 --> 21:03.780
UlisDo

21:03.780 --> 21:05.780
卸载10.18.0

21:05.780 --> 21:06.780
卸载

21:08.780 --> 21:09.780
好 卸载完了

21:09.780 --> 21:10.780
卸载完了其实很简单

21:10.780 --> 21:11.780
它做的一件很简单的事

21:11.780 --> 21:12.780
就是在这里

21:12.780 --> 21:14.780
把文件夹给你删掉了

21:15.780 --> 21:17.780
当然你可以自己手动去删掉

21:17.780 --> 21:18.780
好 就没了

21:18.780 --> 21:20.780
那么现在再看用列室来查看的话

21:20.780 --> 21:21.780
只有一个版本了

21:21.780 --> 21:22.780
就这么简单

21:23.780 --> 21:25.780
OK 这就是关于NVM的使用

21:25.780 --> 21:27.780
以后你们在公司里面肯定

21:27.780 --> 21:29.780
10.18.9是跑不掉这个东西的

21:30.780 --> 21:32.780
这是关于肉的版本的控制

