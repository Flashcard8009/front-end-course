WEBVTT

00:00.750 --> 00:05.150
这些可能我们讲一个有点比较有意思的事情

00:05.150 --> 00:06.350
叫做语异版本

00:06.350 --> 00:09.550
这个玩意儿大家听一听 听个热闹就行了

00:09.550 --> 00:12.750
因为平时我们开发也不太会用的到这个玩意儿

00:12.750 --> 00:16.550
是属于理解的范畴

00:16.550 --> 00:19.550
有的时候可能一些极个别的情况下会遇到

00:19.550 --> 00:20.550
什么情况下的

00:20.550 --> 00:22.550
就是如果说你自己要发布一个包

00:22.550 --> 00:25.550
那么这个时候你必须要了解语异版本了

00:25.550 --> 00:30.350
其他的时候你了解它是更好的帮助你理解

00:31.350 --> 00:33.350
听一听吧 肯定是要听的

00:33.350 --> 00:36.350
但是不用去使经营备

00:36.350 --> 00:37.350
那么什么是语异版本呢

00:37.350 --> 00:39.350
首先大家思考一个问题

00:39.350 --> 00:41.350
如果说你自己来编写一个包

00:41.350 --> 00:44.350
现在我们现在还没有想发布包

00:44.350 --> 00:46.350
但是编写包是不是一定会编写的

00:46.350 --> 00:48.350
就是在工程里面写单

00:48.350 --> 00:50.350
生成一个配置文件在里面写单

00:50.350 --> 00:52.350
把什么包的一些描述给它加进去

00:52.350 --> 00:54.350
就完事了就开发了一个包

00:54.350 --> 00:56.350
那么至于如何发布到NPM上

00:56.350 --> 00:57.350
我们后边再说

00:57.350 --> 00:59.350
那么你编写了一个包

00:59.350 --> 01:01.350
比方说你在包的名字叫做A

01:01.350 --> 01:02.350
这是个大写

01:02.350 --> 01:04.350
不过实际上NPM上面

01:04.350 --> 01:06.350
也是不允许有大写的字母的

01:06.350 --> 01:08.350
它的所有的包的名字都是小写

01:08.350 --> 01:11.350
因此你在NPM上搜包的名字的时候

01:11.350 --> 01:13.350
不要去搜大写

01:13.350 --> 01:15.350
直接写小写就行了

01:15.350 --> 01:17.350
你编写了个包A

01:17.350 --> 01:19.350
你编写了个包需要用到另外一个包

01:19.350 --> 01:21.350
也就是说你自己安装了另外一个包

01:21.350 --> 01:23.350
一个包B

01:23.350 --> 01:25.350
那么你在编写代码的时候

01:25.350 --> 01:26.350
你安装包B的时候

01:26.350 --> 01:28.350
可能十字八九都用的是最新版

01:28.350 --> 01:30.350
那么包B的版

01:30.350 --> 01:32.350
当前的版本是2.4.1

01:32.350 --> 01:34.350
比方说有这么一个场景

01:34.350 --> 01:36.350
那么现在有一个问题

01:36.350 --> 01:40.350
你是希望别人安装你的包的时候

01:40.350 --> 01:42.350
安装包B的时候

01:42.350 --> 01:44.350
一定是这个2.4.1的版本

01:44.350 --> 01:47.350
还是希望它可以是更高的版本

01:47.350 --> 01:49.350
那么有这么一个问题存在

01:49.350 --> 01:50.350
就是你写好了个包

01:50.350 --> 01:52.350
比方说你把它发布出去了

01:52.350 --> 01:55.350
你这个包的一代的版本是2.4.1

01:55.350 --> 01:56.350
我再说一次

01:56.350 --> 01:58.350
你一代的版本是2.4.1

01:58.350 --> 01:59.350
一代包B

01:59.350 --> 02:02.350
那么如果说别人安装你这个包

02:02.350 --> 02:03.350
安装的时候

02:03.350 --> 02:04.350
肯定要安装包B对不对

02:04.350 --> 02:06.350
因为你依赖包B嘛

02:06.350 --> 02:09.350
所以说你肯定要安装B包

02:09.350 --> 02:12.350
那么你安装包B的时候

02:12.350 --> 02:14.350
它到底安装哪个版本

02:14.350 --> 02:16.350
它是安装你编写代码的时候的版本

02:16.350 --> 02:17.350
2.4.1

02:17.350 --> 02:20.350
你还是希望它可以安装更高的版本

02:20.350 --> 02:23.350
如果说你希望它可以安装更高的版本

02:23.350 --> 02:25.350
它高到什么程度

02:25.350 --> 02:26.350
那么这个东西

02:26.350 --> 02:29.350
就是我们现在要解决的一个问题

02:29.350 --> 02:31.350
就是版本的问题

02:31.350 --> 02:32.350
为什么说

02:32.350 --> 02:33.350
有时候可能

02:33.350 --> 02:34.350
这个很简单

02:34.350 --> 02:37.350
我编代码的时候用的是2.4.1

02:37.350 --> 02:39.350
那么不管你是有什么时间

02:39.350 --> 02:41.350
用我的这个包

02:41.350 --> 02:42.350
那你肯定要安装2.4.1

02:42.350 --> 02:44.350
哪怕包B的版本已经很高了

02:44.350 --> 02:46.350
你也得使用2.4.1的版本

02:46.350 --> 02:49.350
那么如果说你这样子想问题的话

02:49.350 --> 02:51.350
你是基于什么目的来思考呢

02:52.350 --> 02:53.350
怕出事

02:53.350 --> 02:54.350
因为

02:54.350 --> 02:57.350
如果说它用了更新的包B的版本的话

02:57.350 --> 02:59.350
那么就有可能会造成一个问题

02:59.350 --> 03:01.350
会造成一个问题就是

03:01.350 --> 03:02.350
它可能API变了

03:02.350 --> 03:03.350
对不对

03:03.350 --> 03:04.350
怕出事

03:04.350 --> 03:06.350
但是实际上包B它的更新呢

03:06.350 --> 03:08.350
可能它是兼容的更新

03:08.350 --> 03:10.350
就是它兼容以前的版本

03:10.350 --> 03:12.350
它只是做了一些修复

03:12.350 --> 03:13.350
比方说以前有些bug

03:13.350 --> 03:15.350
它把它修复了

03:15.350 --> 03:18.350
或者说之前有些运行效率不高的一些函数

03:18.350 --> 03:20.350
它把它优化了

03:20.350 --> 03:22.350
使它运行效率更高了

03:22.350 --> 03:23.350
那么这种情况下

03:23.350 --> 03:24.350
你是不是

03:24.350 --> 03:26.350
如果是考虑到这种情况下的话

03:26.350 --> 03:28.350
是不是它升级就更好一些啊

03:28.350 --> 03:29.350
对不对

03:29.350 --> 03:30.350
是不是这个道理

03:30.350 --> 03:31.350
那么也就是说

03:31.350 --> 03:33.350
我在编写代码的时候

03:33.350 --> 03:34.350
依赖另外一个包

03:34.350 --> 03:35.350
那个包的版本呢

03:35.350 --> 03:37.350
它不一定是真正拥我这个包的时候

03:37.350 --> 03:39.350
那个一代包的版本

03:39.350 --> 03:40.350
这个有点绕

03:40.350 --> 03:42.350
能不能明白这个问题

03:42.350 --> 03:43.350
那么这个时候呢

03:43.350 --> 03:45.350
我们就要回顾这个版本号规则了

03:45.350 --> 03:46.350
我们之前说过

03:46.350 --> 03:48.350
我们每一个包的它都有个版本号

03:48.350 --> 03:50.350
主版本号 赤版本号

03:50.350 --> 03:51.350
补定版本号

03:51.350 --> 03:52.350
它在编写包的时候呢

03:52.350 --> 03:54.350
尽量按照这个要求

03:54.350 --> 03:56.350
按照这个规范来确定版本号

03:56.350 --> 03:57.350
主版本号是什么呢

03:57.350 --> 03:59.350
主版本号发生变化的话

03:59.350 --> 04:01.350
一般是有重大更新

04:01.350 --> 04:02.350
这个重大更新的

04:02.350 --> 04:04.350
可能会导致不兼容的情况出现

04:04.350 --> 04:06.350
比方说我们以后要学习的wippack

04:06.350 --> 04:08.350
wippack2和wippack3

04:08.350 --> 04:10.350
它就是不兼容的

04:10.350 --> 04:12.350
主版本更新的

04:12.350 --> 04:15.350
10至89的可能会带来不兼容的变化

04:15.350 --> 04:17.350
然后还有一个赤版本号

04:17.350 --> 04:19.350
赤版本号更新的一般是兼容的

04:19.350 --> 04:22.350
它是指的是一些新增的一些小功能

04:22.350 --> 04:24.350
新增的一些小功能

04:24.350 --> 04:26.350
或者是一些辅助型的API

04:26.350 --> 04:28.350
那么过去的API它并没有做出改动

04:28.350 --> 04:30.350
它是兼容的 兼容过去的版本的

04:30.350 --> 04:32.350
然后还有一个补定版本

04:32.350 --> 04:33.350
它是完全兼容的

04:33.350 --> 04:35.350
绝对不会出现不兼容的情况

04:35.350 --> 04:36.350
它只是修复了bug

04:36.350 --> 04:38.350
它连功能都没有新增

04:38.350 --> 04:39.350
只是修复了bug

04:39.350 --> 04:41.350
或者是做了一些优化

04:41.350 --> 04:43.350
那么按照这个版本号规则的话

04:43.350 --> 04:44.350
你想一想

04:44.350 --> 04:45.350
我们就很容易可以想出

04:45.350 --> 04:47.350
别人在安装我这个包的时候

04:47.350 --> 04:50.350
那么我的依赖包是可以更新的

04:50.350 --> 04:52.350
更新的你只要兼容就行了

04:52.350 --> 04:54.350
只要兼容就行了

04:54.350 --> 04:56.350
就可以想出

04:56.350 --> 04:58.350
我们通常会有这么一个规则

04:58.350 --> 05:00.350
所以说有的时候我们就希望

05:00.350 --> 05:02.350
安装我的包的时候

05:02.350 --> 05:03.350
我的包有依赖

05:03.350 --> 05:05.350
那么你安装那个依赖包的时候

05:05.350 --> 05:08.350
你的赤版本号和补定版本

05:08.350 --> 05:10.350
是可以有提升的

05:10.350 --> 05:11.350
是可以更新的

05:11.350 --> 05:13.350
但是那主版本号是不能变化的

05:13.350 --> 05:15.350
你赤版本和补定版本

05:15.350 --> 05:17.350
它都不会导致不兼容

05:17.350 --> 05:18.350
它都是兼容的

05:18.350 --> 05:19.350
那么这个可是可以更新

05:19.350 --> 05:21.350
但是有的时候有可能

05:21.350 --> 05:22.350
我们又希望

05:22.350 --> 05:23.350
安装我依赖包的时候

05:23.350 --> 05:25.350
可能要更加稳健一点

05:25.350 --> 05:27.350
只有补定版本可以更新

05:27.350 --> 05:28.350
其他都不能更新

05:28.350 --> 05:30.350
只有这个版本号能更新

05:30.350 --> 05:31.350
那甚至有的时候

05:31.350 --> 05:34.350
我们希望依赖包要保持完全固定

05:34.350 --> 05:35.350
完全固定

05:35.350 --> 05:37.350
就不能有更新

05:37.350 --> 05:38.350
那么这种情况

05:38.350 --> 05:39.350
虽然比较少见

05:39.350 --> 05:40.350
但是也有可能会出现

05:40.350 --> 05:42.350
就最稳健的做法

05:42.350 --> 05:44.350
那么这就会出现一个问题

05:44.350 --> 05:46.350
就是我们在配置文件里边

05:46.350 --> 05:48.350
我们之前写了个package.json

05:48.350 --> 05:50.350
就这个package.json

05:50.350 --> 05:52.350
这个文件

05:52.350 --> 05:53.350
这个文件配置里边

05:53.350 --> 05:54.350
不是要写依赖关系吗

05:54.350 --> 05:55.350
对吧

05:55.350 --> 05:56.350
那么这个依赖关系该怎么写呢

05:56.350 --> 05:58.350
我这个版本号该怎么来描述呢

05:58.350 --> 06:00.350
才能表达我们的

06:00.350 --> 06:01.350
依赖的东西

06:01.350 --> 06:03.350
就是它依赖的意愿了

06:03.350 --> 06:05.350
怎么来描述呢

06:05.350 --> 06:07.350
那么这样子一来了

06:07.350 --> 06:08.350
我们在配置文件中

06:08.350 --> 06:10.350
就需要具体的描述出

06:10.350 --> 06:12.350
到底是什么样的依赖规则

06:12.350 --> 06:14.350
而不是直接写上版本号

06:14.350 --> 06:16.350
因为你直接写上版本号的话

06:16.350 --> 06:17.350
比方说你这里直接写上版本号

06:17.350 --> 06:18.350
那就是固定的

06:18.350 --> 06:20.350
我一定要按照这个版本

06:20.350 --> 06:21.350
将来我这个包一发布出去

06:21.350 --> 06:23.350
那么别人按照我这个包的时候

06:23.350 --> 06:25.350
结果一定是3.4.1

06:25.350 --> 06:26.350
一点都不能变

06:26.350 --> 06:27.350
是这么个意思

06:27.350 --> 06:28.350
但是实际上

06:28.350 --> 06:29.350
它是有的时候

06:29.350 --> 06:32.350
是我们很多时候都会放宽规则

06:32.350 --> 06:34.350
让它允许有一点点升级

06:34.350 --> 06:36.350
那么这样的描述规则呢

06:36.350 --> 06:38.350
它就叫做语异版本

06:38.350 --> 06:40.350
其实大家之前看到的这个尖尖

06:40.350 --> 06:41.350
像它的尖尖

06:41.350 --> 06:43.350
其实它就是一个语异版本的描述

06:43.350 --> 06:45.350
那么语异版本的描述规则

06:45.350 --> 06:47.350
规则是非常非常多的

06:47.350 --> 06:49.350
不是说我下面表格列出来这么一点

06:49.350 --> 06:51.350
我们下面的表格

06:51.350 --> 06:53.350
只是列的一些常见的书写方式

06:53.350 --> 06:54.350
我们来看一下

06:54.350 --> 06:56.350
第一个就是大语

06:56.350 --> 06:57.350
大语符号

06:57.350 --> 06:59.350
比方说我写的大语1.2.1

06:59.350 --> 07:01.350
那么指的是什么意思呢

07:01.350 --> 07:03.350
比方说我这里写的大语

07:03.350 --> 07:04.350
那么以后

07:04.350 --> 07:06.350
你安装我这个包的时候

07:06.350 --> 07:07.350
你安装哪个

07:07.350 --> 07:08.350
应该安装结块位

07:08.350 --> 07:09.350
结块的版本是什么呢

07:09.350 --> 07:11.350
只要大语3.4.1就行

07:11.350 --> 07:13.350
管它什么版本无所谓

07:13.350 --> 07:15.350
只要按大语3.4.1就行

07:15.350 --> 07:17.350
那么具体性是哪个版本的NPM来自行决定

07:17.350 --> 07:19.350
反正我这里规则给你描述了

07:19.350 --> 07:21.350
我一代的只要能高语这个版本就行

07:21.350 --> 07:23.350
就这么个意思

07:23.350 --> 07:24.350
明白吧

07:24.350 --> 07:25.350
那么大语等于呢

07:25.350 --> 07:26.350
就大语等于

07:26.350 --> 07:27.350
小语等于

07:27.350 --> 07:28.350
不用说了吧

07:28.350 --> 07:31.350
一般不太会去写小语等于

07:31.350 --> 07:33.350
所以会让它越小越好了

07:34.350 --> 07:35.350
然后呢

07:35.350 --> 07:36.350
还有一个横杆

07:36.350 --> 07:39.350
横杆就是介于两个版本之间

07:39.350 --> 07:40.350
这里要说一下

07:40.350 --> 07:41.350
版本号是怎么比较的

07:41.350 --> 07:44.350
版本号先比较第一位

07:44.350 --> 07:46.350
然后第一位如果相同

07:46.350 --> 07:47.350
再比较第二位

07:47.350 --> 07:49.350
第二位如果相同再比较第三位

07:49.350 --> 07:51.350
就这么一个自然的比较规则

07:51.350 --> 07:52.350
这个横杆指的是

07:52.350 --> 07:53.350
在两个版本之间

07:53.350 --> 07:54.350
比方说这样子写

07:54.350 --> 07:56.350
那么就处于什么呢

07:56.350 --> 07:58.350
比方说我这里这样子写

07:58.350 --> 08:01.350
3.4.1到5.0.0

08:01.350 --> 08:05.350
主版本号可以在3和5之间浮动

08:05.350 --> 08:07.350
主版本号如果一致的话

08:07.350 --> 08:09.350
那么在4版本一定要大于4

08:09.350 --> 08:11.350
是这么个意思

08:11.350 --> 08:13.350
比方说这样子写的话

08:13.350 --> 08:15.350
那么像这个版本

08:15.350 --> 08:17.350
4.0.0

08:17.350 --> 08:18.350
它是符合要求的

08:18.350 --> 08:19.350
因为主版

08:19.350 --> 08:21.350
4.0.0是比它大

08:21.350 --> 08:22.350
比它小

08:22.350 --> 08:23.350
对不对

08:23.350 --> 08:24.350
那么这个是符合规则的

08:24.350 --> 08:26.350
就这么个意思

08:26.350 --> 08:28.350
了解就行了

08:28.350 --> 08:30.350
这个东西也不好试验

08:30.350 --> 08:31.350
是建有两个版本之间

08:31.350 --> 08:33.350
那么这个叉叉呢

08:33.350 --> 08:35.350
叉叉就是

08:35.350 --> 08:36.350
不是叉叉X

08:36.350 --> 08:38.350
X它是不固定的版本

08:38.350 --> 08:39.350
一个站位符

08:39.350 --> 08:41.350
比方说你写的是1.3.X

08:41.350 --> 08:43.350
那么表示什么意思呢

08:43.350 --> 08:44.350
前面的保持固定

08:44.350 --> 08:46.350
这个位置是可以变化的

08:46.350 --> 08:47.350
随便怎么变

08:47.350 --> 08:48.350
都无所谓

08:48.350 --> 08:50.350
这个地方我是放宽的

08:50.350 --> 08:51.350
放宽要求的

08:51.350 --> 08:52.350
那么NPM的安装包的时候

08:52.350 --> 08:54.350
它是尽量安装新的

08:54.350 --> 08:56.350
尽量的安装新的

08:56.350 --> 08:58.350
但是它也不一定是

08:58.350 --> 08:59.350
安装最新的

08:59.350 --> 09:00.350
我们以后会说这个

09:00.350 --> 09:02.350
特殊的场景

09:02.350 --> 09:04.350
那么就是加上这个X

09:04.350 --> 09:05.350
对吧

09:05.350 --> 09:07.350
然后呢

09:07.350 --> 09:09.350
这个玩意呢

09:09.350 --> 09:11.350
补进版本号是可以

09:11.350 --> 09:12.350
可争的

09:12.350 --> 09:13.350
什么意思

09:13.350 --> 09:14.350
如果说你这样子写

09:14.350 --> 09:15.350
那么什么意思呢

09:15.350 --> 09:16.350
就第1个

09:16.350 --> 09:17.350
就前2个

09:17.350 --> 09:19.350
前2个表示保持固定

09:19.350 --> 09:20.350
最后一个

09:20.350 --> 09:22.350
只要大于等于4就行了

09:22.350 --> 09:23.350
就这么个意思

09:23.350 --> 09:25.350
就这个符号

09:25.350 --> 09:26.350
那么这个符号

09:26.350 --> 09:27.350
就是我们最常见的

09:27.350 --> 09:28.350
符号

09:28.350 --> 09:29.350
这个符号

09:29.350 --> 09:30.350
你默认安装包的时候

09:30.350 --> 09:31.350
你如果不去改它

09:31.350 --> 09:32.350
当然你可不可以改

09:32.350 --> 09:33.350
肯定可以改

09:33.350 --> 09:34.350
它写

09:34.350 --> 09:35.350
它除了这个语异规则

09:35.350 --> 09:37.350
它就是可以让你改的

09:37.350 --> 09:38.350
它默认就是这个东西

09:38.350 --> 09:40.350
默认的东西是什么意思呢

09:40.350 --> 09:41.350
就是主版本保持不变

09:41.350 --> 09:43.350
后边两个版本可以增加

09:43.350 --> 09:44.350
可以增加

09:44.350 --> 09:46.350
比方我们这个包发布出去了

09:46.350 --> 09:47.350
那么到时候别人

09:47.350 --> 09:48.350
安装这个接宽锐的时候

09:48.350 --> 09:49.350
它只要保证

09:49.350 --> 09:50.350
接宽锐3

09:50.350 --> 09:51.350
那么后边的版本

09:51.350 --> 09:52.350
我无所谓

09:52.350 --> 09:53.350
生就生呗

09:53.350 --> 09:55.350
尽量用最新的

09:55.350 --> 09:56.350
就是这么个意思

09:56.350 --> 09:57.350
再写新号的话

09:57.350 --> 09:58.350
就相当于是我们写个

09:58.350 --> 09:59.350
Netist

09:59.350 --> 10:01.350
表示安装最新版本

10:01.350 --> 10:02.350
没啥意思

10:02.350 --> 10:03.350
OK 这就是语异版本的描述

10:03.350 --> 10:04.350
是不是很简单

10:04.350 --> 10:06.350
就通过一种特殊的

10:06.350 --> 10:08.350
语写方式

10:08.350 --> 10:10.350
来描述我依赖的版本

10:10.350 --> 10:12.350
其实我们NPM

10:12.350 --> 10:14.350
在安装包的时候

10:14.350 --> 10:15.350
因为每个包

10:15.350 --> 10:17.350
它都可能会担有依赖

10:17.350 --> 10:18.350
它去安装那些依赖的时候

10:18.350 --> 10:20.350
它就按照这样的规则来安装

10:20.350 --> 10:22.350
比方说我们这里

10:22.350 --> 10:24.350
之前安装了一个什么呢

10:24.350 --> 10:26.350
对吧 我们来看一下

10:26.350 --> 10:28.350
我们之前安装了个模型

10:28.350 --> 10:29.350
咱们来看一下

10:29.350 --> 10:30.350
我们安装这个包的时候

10:30.350 --> 10:31.350
这个包里边是不是

10:31.350 --> 10:32.350
有个配音点节省

10:32.350 --> 10:33.350
对吧 有个配置文件

10:33.350 --> 10:34.350
那么它里边有哪些依赖

10:34.350 --> 10:36.350
是不是在这里边可以读出来

10:36.350 --> 10:37.350
对吧 我们看一下

10:37.350 --> 10:38.350
它的dependency

10:38.350 --> 10:41.350
它这里边有很多的什么

10:41.350 --> 10:42.350
参与贡献者

10:42.350 --> 10:43.350
对吧 这些姓名

10:43.350 --> 10:49.350
我们看一下dependency

10:49.350 --> 10:51.350
好 你看一下

10:51.350 --> 10:53.350
它这里边就有很多依赖

10:53.350 --> 10:55.350
那么这里边它写的依赖

10:55.350 --> 10:57.350
它还全部把固定了的

10:57.350 --> 10:59.350
它这里把全部固定了的

10:59.350 --> 11:01.350
它要保持足够的稳定

11:01.350 --> 11:03.350
它把这些依赖全部固定了的

11:03.350 --> 11:05.350
没有使用那个语异版本

11:05.350 --> 11:07.350
那么我们看一下它的依赖里边

11:07.350 --> 11:09.350
我们随便看一个包

11:09.350 --> 11:11.350
看一下依赖的DIF这个包

11:11.350 --> 11:12.350
看一下吧

11:12.350 --> 11:14.350
DIF这个包

11:14.350 --> 11:15.350
这个包它也有

11:15.350 --> 11:16.350
那么按照它的时候

11:16.350 --> 11:17.350
要去读它的依赖

11:17.350 --> 11:18.350
对吧 它的依赖

11:18.350 --> 11:20.350
我看一下它的依赖怎么写的

11:20.350 --> 11:21.350
dependency

11:21.350 --> 11:22.350
它没有依赖

11:22.350 --> 11:24.350
那么我们随便找一个吧

11:24.350 --> 11:26.350
随便找一个

11:26.350 --> 11:28.350
你说这些包我能认识完吗

11:28.350 --> 11:29.350
我也不是神仙

11:29.350 --> 11:30.350
我怎么可能认识完

11:30.350 --> 11:31.350
那么你看一下

11:31.350 --> 11:32.350
拍一点节省

11:32.350 --> 11:33.350
它这个包叫做locate

11:33.350 --> 11:34.350
它依赖这个包

11:34.350 --> 11:35.350
locate pass

11:35.350 --> 11:37.350
对吧 它依赖这个包

11:37.350 --> 11:38.350
那么依赖这个包

11:38.350 --> 11:39.350
它的书写规则就是

11:39.350 --> 11:40.350
我只要保证

11:40.350 --> 11:42.350
保证是主版本是三就行了

11:42.350 --> 11:44.350
后面版本你尽量的更新吧

11:44.350 --> 11:45.350
尽量的更新

11:45.350 --> 11:46.350
那么我们来看一下这个

11:46.350 --> 11:47.350
于是NPM它就会

11:47.350 --> 11:48.350
看到这个依赖过去

11:48.350 --> 11:50.350
它就会去安装这个包

11:50.350 --> 11:51.350
那么locate pass

11:51.350 --> 11:52.350
我们来看一下

11:52.350 --> 11:53.350
locate pass

11:53.350 --> 11:56.350
locate pass

11:56.350 --> 11:58.350
locate pass

11:58.350 --> 11:59.350
我们来看一下

11:59.350 --> 12:00.350
这个包安装了一个版本

12:00.350 --> 12:01.350
是什么呢

12:01.350 --> 12:02.350
安装那个版本

12:02.350 --> 12:04.350
看一下它的Version

12:04.350 --> 12:06.350
它自己的版本

12:06.350 --> 12:07.350
查照一下Version

12:07.350 --> 12:08.350
它Version刚好

12:08.350 --> 12:09.350
巧了

12:09.350 --> 12:11.350
目前刚好就是3.0.0

12:11.350 --> 12:13.350
目前就是3.0.0.0

12:13.350 --> 12:14.350
然后它又依赖这个包

12:14.350 --> 12:16.350
pass exist

12:16.350 --> 12:18.350
咱们又来看一下

12:18.350 --> 12:19.350
pass exist

12:20.350 --> 12:22.350
看一下它的Version

12:22.350 --> 12:23.350
Version

12:23.350 --> 12:24.350
它也是3.0.0

12:24.350 --> 12:25.350
但是呢

12:25.350 --> 12:26.350
如果说它有更新的话

12:26.350 --> 12:27.350
如果说它有更新的话

12:27.350 --> 12:28.350
那么安装它的新的

12:28.350 --> 12:29.350
也不会成问题的

12:29.350 --> 12:30.350
它语异版本里边说了的

12:30.350 --> 12:32.350
是可以安装更新的

12:32.350 --> 12:33.350
那么NPM

12:33.350 --> 12:34.350
它就是按照这样的规则

12:34.350 --> 12:35.350
来进行安装的

12:35.350 --> 12:36.350
它安装

12:36.350 --> 12:37.350
比方说我安装

12:37.350 --> 12:38.350
一个包的时候

12:38.350 --> 12:39.350
那么它会去读到

12:39.350 --> 12:40.350
这个包的

12:40.350 --> 12:41.350
它都会读到

12:41.350 --> 12:42.350
这个包的配置文件

12:42.350 --> 12:43.350
那么它自然而然

12:43.350 --> 12:44.350
会读到这个包的依赖

12:44.350 --> 12:45.350
那么包的依赖一读出来

12:45.350 --> 12:46.350
那么它就会去安装

12:46.350 --> 12:47.350
语异版本

12:47.350 --> 12:48.350
描述的版本

12:48.350 --> 12:49.350
描述的版本

12:49.350 --> 12:50.350
描述它可以更新

12:50.350 --> 12:51.350
可以有更新的

12:51.350 --> 12:53.350
它就去安装更新的

12:53.350 --> 12:54.350
那么它具体的安装

12:54.350 --> 12:56.350
其实它的整个依赖的

12:56.350 --> 12:57.350
就是确定的话

12:57.350 --> 12:58.350
是非常复杂的

12:58.350 --> 12:59.350
我给大家举个例子吧

12:59.350 --> 13:00.350
比方说

13:00.350 --> 13:02.350
它安装一个包A

13:02.350 --> 13:04.350
A它依赖一个包B

13:04.350 --> 13:07.350
它依赖一个包B

13:07.350 --> 13:09.350
然后包B

13:09.350 --> 13:12.350
它依赖了一个包

13:12.350 --> 13:13.350
叫做包C

13:13.350 --> 13:14.350
它依赖包C什么版本

13:14.350 --> 13:15.350
它依赖包C的版本

13:15.350 --> 13:16.350
是这样子的

13:16.350 --> 13:20.350
只要能够主版本好保持不变

13:20.350 --> 13:23.350
C的版本是零念零念零

13:23.350 --> 13:25.350
比方说它依赖这样子依赖

13:25.350 --> 13:26.350
然后包A里边

13:26.350 --> 13:28.350
它还依赖一个包D

13:28.350 --> 13:30.350
A依赖B和D

13:30.350 --> 13:31.350
B依赖C

13:31.350 --> 13:33.350
那么肯定要去安装B和D

13:33.350 --> 13:34.350
对吧

13:34.350 --> 13:35.350
那么D呢

13:35.350 --> 13:37.350
它又要依赖C

13:37.350 --> 13:38.350
它也要依赖C

13:38.350 --> 13:40.350
那么它依赖的版本是什么呢

13:40.350 --> 13:41.350
它可能是这样子写的

13:41.350 --> 13:45.350
小于3.4.5

13:45.350 --> 13:47.350
小于3.4.5

13:47.350 --> 13:49.350
那么现在呢

13:49.350 --> 13:50.350
小于等于吗

13:50.350 --> 13:52.350
小于等于3.4.5

13:52.350 --> 13:53.350
那么现在呢

13:53.350 --> 13:56.350
C的最新版的最新版

13:56.350 --> 13:57.350
是多少呢

13:57.350 --> 14:01.350
是3.6.7

14:01.350 --> 14:04.350
比方说C的最新版是3.6.7

14:04.350 --> 14:06.350
那么这个时候怎么办呢

14:06.350 --> 14:08.350
这个时候它到底安装哪个版本呢

14:08.350 --> 14:09.350
它安装C的时候

14:09.350 --> 14:10.350
它叫综合考虑

14:10.350 --> 14:12.350
我既要比它大

14:12.350 --> 14:13.350
比这个版本

14:13.350 --> 14:14.350
主版本好保持不变

14:14.350 --> 14:16.350
又要同时小于等于这个

14:16.350 --> 14:17.350
那么它安装什么版本呢

14:17.350 --> 14:19.350
它是不是就安装了3.4.5

14:19.350 --> 14:20.350
对吧

14:20.350 --> 14:21.350
当然C得有这个版本

14:21.350 --> 14:22.350
有可能C没有这个版本

14:22.350 --> 14:24.350
那么它还要继续往下找

14:24.350 --> 14:25.350
又要大于它

14:25.350 --> 14:26.350
又要小于它对不对

14:26.350 --> 14:27.350
它要综合考虑

14:27.350 --> 14:28.350
所以它的整个考虑过程

14:28.350 --> 14:29.350
是比较复杂的

14:29.350 --> 14:30.350
没关系

14:30.350 --> 14:32.350
我们也不用去彻底去管

14:32.350 --> 14:33.350
它的怎么去考虑的

14:33.350 --> 14:34.350
到底安装哪个版本

14:34.350 --> 14:35.350
跟我们也没大关系

14:35.350 --> 14:37.350
这些东西交给NPM智能

14:37.350 --> 14:38.350
来进行处理就行了

14:38.350 --> 14:39.350
我们只需要知道

14:39.350 --> 14:40.350
怎么来描述这个东西

14:40.350 --> 14:42.350
能看得懂这个玩意就行了

14:43.350 --> 14:44.350
就是关于语异版本

14:44.350 --> 14:45.350
这就解释了我们

14:46.350 --> 14:47.350
这个配置文件里面

14:47.350 --> 14:48.350
这个东西是啥玩意

14:48.350 --> 14:50.350
给它解释一下

14:51.350 --> 14:52.350
那么下面我说一个问题

14:52.350 --> 14:54.350
这个东西了解就行了

14:55.350 --> 14:58.350
是关于避免还原的差异的

14:58.350 --> 14:59.350
就是说这个东西

14:59.350 --> 15:00.350
地方我是要解释啥呢

15:00.350 --> 15:01.350
我是要解释这个文件

15:01.350 --> 15:02.350
我们之前

15:02.350 --> 15:03.350
每次都看到这个文件

15:03.350 --> 15:04.350
不知道它干嘛的

15:04.350 --> 15:05.350
我来解释一下

15:05.350 --> 15:06.350
这个文件是怎么来出现的

15:06.350 --> 15:08.350
这里有点绕

15:08.350 --> 15:09.350
你要跟着我的思路走

15:09.350 --> 15:10.350
它是怎么来的

15:10.350 --> 15:11.350
它就是我们

15:11.350 --> 15:13.350
尽管有这样的语异描述

15:13.350 --> 15:15.350
还会有什么样的问题呢

15:15.350 --> 15:17.350
因为我们的版本控制

15:17.350 --> 15:18.350
始终是一个逻辑上

15:18.350 --> 15:19.350
就是一个复杂的问题

15:19.350 --> 15:20.350
它不是说

15:20.350 --> 15:22.350
我们给它提供一个智能的工具

15:22.350 --> 15:23.350
它就全部搞定了

15:23.350 --> 15:24.350
其实很多场景

15:24.350 --> 15:25.350
它也不知道

15:25.350 --> 15:26.350
我们到底该怎么办

15:26.350 --> 15:27.350
它不知道该怎么办

15:28.350 --> 15:29.350
就是说我们这里

15:29.350 --> 15:30.350
有两种情况

15:30.350 --> 15:32.350
一种就是我允许版本增加

15:32.350 --> 15:34.350
比如说我依赖了Jquery

15:34.350 --> 15:35.350
Jquery我允许你

15:35.350 --> 15:36.350
你到时候安装的时候

15:36.350 --> 15:38.350
你版本可以

15:39.350 --> 15:41.350
不用我书写代码的时候的一个版本

15:41.350 --> 15:43.350
你可以用更高的版本

15:43.350 --> 15:45.350
对我的代码也不会造成什么影响

15:45.350 --> 15:46.350
兼容的

15:46.350 --> 15:47.350
我允许版本增加

15:47.350 --> 15:49.350
那么这是一种比较开放的

15:49.350 --> 15:52.350
比较开放的

15:52.350 --> 15:54.350
一种版本控制

15:54.350 --> 15:55.350
它可以让

15:55.350 --> 15:56.350
它这个好处在什么呢

15:56.350 --> 15:58.350
好处就是让依赖包的bug

15:58.350 --> 15:59.350
得益修复

15:59.350 --> 16:00.350
比如说我现在

16:00.350 --> 16:01.350
写编写我的包的时候

16:01.350 --> 16:03.350
用的是3.4.1

16:03.350 --> 16:04.350
用的是这个版本

16:04.350 --> 16:05.350
那么这个版本

16:05.350 --> 16:06.350
可能有些bug

16:06.350 --> 16:08.350
没有发现

16:08.350 --> 16:09.350
可能用在用的过程中

16:09.350 --> 16:11.350
出现一个bug了

16:11.350 --> 16:12.350
那么bug

16:12.350 --> 16:14.350
就会影响到我这个功能了

16:14.350 --> 16:15.350
那么我是不是

16:15.350 --> 16:17.350
又要去处理一次呢

16:17.350 --> 16:18.350
那么如果说

16:18.350 --> 16:19.350
我在那个

16:19.350 --> 16:20.350
依赖写

16:20.350 --> 16:21.350
依赖的时候

16:21.350 --> 16:22.350
我就说

16:22.350 --> 16:24.350
反正主版本保持不变

16:24.350 --> 16:25.350
后边的版本更新

16:25.350 --> 16:26.350
因为别人安装的时候

16:26.350 --> 16:28.350
可能Jquery就更新了

16:28.350 --> 16:29.350
就更新了

16:29.350 --> 16:30.350
那么它一更新

16:30.350 --> 16:31.350
你想一个道理

16:31.350 --> 16:33.350
它一更新的话

16:33.350 --> 16:34.350
那么

16:34.350 --> 16:35.350
之前的bug是不是

16:35.350 --> 16:36.350
就有可能会修复

16:36.350 --> 16:37.350
对不对

16:37.350 --> 16:38.350
我就不用做任何事情的

16:38.350 --> 16:40.350
你去更新一次就完事了

16:40.350 --> 16:41.350
那么它版本

16:41.350 --> 16:42.350
它就可能是

16:42.350 --> 16:43.350
给它修复掉了

16:43.350 --> 16:44.350
所以说bug可以修复

16:44.350 --> 16:45.350
比方说

16:45.350 --> 16:46.350
补定版本

16:46.350 --> 16:47.350
就专门来修复bug的

16:47.350 --> 16:48.350
我们允许它增加

16:48.350 --> 16:49.350
那么就可以

16:49.350 --> 16:51.350
让它bug得益修复

16:51.350 --> 16:53.350
那么有可能

16:53.350 --> 16:54.350
还会带来一些

16:54.350 --> 16:55.350
额外的惊喜

16:55.350 --> 16:56.350
吃版本号

16:56.350 --> 16:57.350
吃版本号

16:57.350 --> 16:58.350
它可能会增加一些

16:58.350 --> 16:59.350
比较实用的一些小功能

16:59.350 --> 17:00.350
那么我们

17:00.350 --> 17:01.350
一来

17:01.350 --> 17:02.350
就是说

17:02.350 --> 17:03.350
我宽松一点

17:03.350 --> 17:04.350
让这个版本号

17:04.350 --> 17:05.350
也可以增加

17:05.350 --> 17:06.350
那么别人在用我的包的时候

17:06.350 --> 17:07.350
安装那个页带的时候

17:07.350 --> 17:08.350
这个版本号

17:08.350 --> 17:09.350
有可能会增加

17:09.350 --> 17:10.350
增加了之后

17:10.350 --> 17:11.350
它就会带来一些

17:11.350 --> 17:12.350
结块的一些

17:12.350 --> 17:14.350
新增的一些小功能

17:14.350 --> 17:15.350
非常实用

17:15.350 --> 17:16.350
它又兼容过去

17:16.350 --> 17:17.350
又新增了一些东西

17:17.350 --> 17:18.350
比过去更好了

17:18.350 --> 17:19.350
对不对

17:19.350 --> 17:20.350
但是

17:20.350 --> 17:21.350
它有一个问题就是

17:21.350 --> 17:22.350
它不是完美的

17:22.350 --> 17:23.350
这种方案

17:23.350 --> 17:24.350
它有可能会带来一些

17:24.350 --> 17:25.350
不确定的风险

17:25.350 --> 17:26.350
比方说

17:26.350 --> 17:27.350
它把之前的bug修复了

17:27.350 --> 17:28.350
它又会带来一个新的bug

17:28.350 --> 17:29.350
有没有可能

17:29.350 --> 17:30.350
完全有可能

17:30.350 --> 17:31.350
这个新的bug

17:31.350 --> 17:32.350
本来以前我的功能

17:32.350 --> 17:33.350
它在那个bug

17:33.350 --> 17:34.350
还原来那个bug

17:34.350 --> 17:35.350
都没有影响我的功能

17:35.350 --> 17:36.350
但是新的bug

17:36.350 --> 17:37.350
影响了我的功能

17:37.350 --> 17:38.350
有没有可能

17:38.350 --> 17:39.350
这种可能呢

17:39.350 --> 17:40.350
是完全有这种可能的

17:40.350 --> 17:41.350
它就是有风险

17:41.350 --> 17:42.350
这种做法是有风险的

17:42.350 --> 17:44.350
允许版本增加

17:44.350 --> 17:45.350
那如果说

17:45.350 --> 17:46.350
我不允许版本增加了

17:46.350 --> 17:47.350
我一定要固定

17:47.350 --> 17:48.350
就是我的版本

17:48.350 --> 17:49.350
不允许它增加

17:49.350 --> 17:51.350
我把固定下来

17:51.350 --> 17:52.350
那么别人安装

17:52.350 --> 17:53.350
我的包的时候

17:53.350 --> 17:54.350
它只能安装3.4.1

17:54.350 --> 17:55.350
对吧

17:55.350 --> 17:56.350
那好处显而一简

17:56.350 --> 17:57.350
就是稳定

17:57.350 --> 17:58.350
因为我自己在本地

17:58.350 --> 17:59.350
已经测试得很好了

17:59.350 --> 18:00.350
那么有些

18:00.350 --> 18:01.350
它功能性上面

18:01.350 --> 18:03.350
上面优化了这些东西

18:03.350 --> 18:04.350
我也不管了

18:04.350 --> 18:05.350
总之它能用

18:05.350 --> 18:07.350
它是非常非常稳定的

18:07.350 --> 18:08.350
但是它失去了

18:08.350 --> 18:10.350
依赖包自我优化的功能

18:10.350 --> 18:11.350
比方说

18:11.350 --> 18:12.350
它之后

18:12.350 --> 18:13.350
快为它升级的一些功能

18:13.350 --> 18:14.350
对吧

18:14.350 --> 18:15.350
它在赤版本号

18:15.350 --> 18:16.350
或者是那个

18:16.350 --> 18:17.350
补定版本号里边增加了

18:17.350 --> 18:18.350
但是别人用不了

18:18.350 --> 18:19.350
为什么用不了呢

18:19.350 --> 18:21.350
因为我指的一代这个东西

18:21.350 --> 18:22.350
它没有办法

18:22.350 --> 18:23.350
把这种优化

18:23.350 --> 18:25.350
自我修复的这种优势

18:25.350 --> 18:27.350
带到我们这个包里边来

18:27.350 --> 18:29.350
就是这个两难的问题

18:30.350 --> 18:31.350
而有的时候的情况

18:31.350 --> 18:33.350
可能更复杂

18:35.350 --> 18:37.350
如果说依赖包升级了过后

18:37.350 --> 18:39.350
它的依赖又发生了变化

18:39.350 --> 18:41.350
会有更多的不确定的情况出现

18:41.350 --> 18:42.350
比方说

18:42.350 --> 18:44.350
我自己写的包叫A

18:44.350 --> 18:46.350
我依赖的包叫B

18:46.350 --> 18:47.350
B的版本

18:47.350 --> 18:49.350
我写的是3.4.1

18:49.350 --> 18:50.350
比方说

18:50.350 --> 18:51.350
我们写的版本是3.4.1

18:51.350 --> 18:53.350
那么3.4.1这个B

18:53.350 --> 18:55.350
它的依赖版本是

18:55.350 --> 18:56.350
依赖的是C

18:56.350 --> 18:58.350
C是5.1.2

18:59.350 --> 19:01.350
比方说

19:01.350 --> 19:02.350
那么后来

19:02.350 --> 19:03.350
我允许这个B变化

19:03.350 --> 19:05.350
比方说我是这样子写的

19:08.350 --> 19:10.350
我允许B变化

19:10.350 --> 19:12.350
B在3.4.1这个版本

19:12.350 --> 19:15.350
它依赖了C是5.1.2

19:15.350 --> 19:17.350
我允许这个B变化

19:17.350 --> 19:19.350
那么可能别人安装的时候

19:19.350 --> 19:22.350
这是我开发的时候

19:22.350 --> 19:24.350
那么别人用我的时候

19:24.350 --> 19:27.350
别人用我的A

19:28.350 --> 19:29.350
那么A的时候

19:29.350 --> 19:30.350
安装啥

19:30.350 --> 19:31.350
安装A

19:31.350 --> 19:32.350
安装A完了过后

19:32.350 --> 19:33.350
是不是安装B

19:33.350 --> 19:34.350
是不是安装B

19:34.350 --> 19:36.350
因为A依赖B

19:36.350 --> 19:37.350
是不是安装B

19:37.350 --> 19:38.350
安装B

19:38.350 --> 19:39.350
它这个时候

19:39.350 --> 19:40.350
它可能安装的版本

19:40.350 --> 19:42.350
因为它可允许增加

19:42.350 --> 19:45.350
它可能安装的版本是3.6.7

19:45.350 --> 19:47.350
有没有这种可能

19:47.350 --> 19:48.350
有可能

19:48.350 --> 19:49.350
安装B的时候

19:49.350 --> 19:50.350
它可能会安装这个版本

19:50.350 --> 19:52.350
那么这个版本由于B升级的

19:52.350 --> 19:54.350
那么升级之后

19:54.350 --> 19:56.350
可能B的依赖发生了变化

19:56.350 --> 19:58.350
当B是3.4.1的时候

19:58.350 --> 19:59.350
它依赖的C是5.1.2

19:59.350 --> 20:01.350
它可能3.6.7的时候

20:01.350 --> 20:02.350
它依赖的C

20:02.350 --> 20:03.350
它变成了这个了

20:03.350 --> 20:04.350
你看着

20:04.350 --> 20:06.350
它变成了6.0.0的

20:06.350 --> 20:08.350
那这个变化是不是太大了

20:08.350 --> 20:10.350
对不对 是不是太大了

20:10.350 --> 20:12.350
是不是又有很多不确定的事情发生了

20:12.350 --> 20:13.350
对吧

20:13.350 --> 20:16.350
这些依赖关系是很复杂的

20:16.350 --> 20:17.350
那么为了解决这个问题

20:17.350 --> 20:18.350
就是有的时候

20:18.350 --> 20:20.350
我们希望这个依赖到

20:20.350 --> 20:22.350
尽量的保持稳定

20:22.350 --> 20:23.350
尽量的保持稳定

20:23.350 --> 20:24.350
不要影响太大

20:24.350 --> 20:25.350
太大

20:25.350 --> 20:27.350
但是这种情况就太恐怖了

20:27.350 --> 20:28.350
这个影响

20:28.350 --> 20:29.350
你说不准有什么影响

20:29.350 --> 20:31.350
那C变成了6.0.0过后了

20:31.350 --> 20:33.350
它的依赖是不是又可能

20:33.350 --> 20:34.350
要出问题

20:34.350 --> 20:35.350
对不对

20:35.350 --> 20:37.350
又可能这样子沉沉影响

20:37.350 --> 20:38.350
间接影响

20:38.350 --> 20:39.350
可能最终会影响到A

20:39.350 --> 20:41.350
所以说我们尽量的还是希望

20:41.350 --> 20:43.350
一方面要保持靡活

20:43.350 --> 20:44.350
一方面要保持稳定

20:44.350 --> 20:46.350
叫避免这种情况出现

20:46.350 --> 20:47.350
这种情况出现

20:47.350 --> 20:49.350
你之前3.4.1的时候

20:49.350 --> 20:50.350
用的是5.1.2

20:50.350 --> 20:52.350
那么现在3.6.7了

20:52.350 --> 20:53.350
你过去变成这个样子

20:53.350 --> 20:55.350
这个东西风险太大了

20:55.350 --> 20:57.350
我编线这个包是承受不了的

20:57.350 --> 20:59.350
这么大的风险

20:59.350 --> 21:00.350
所以说NPM

21:00.350 --> 21:02.350
他以前没有考虑这个问题

21:02.350 --> 21:03.350
所以说

21:03.350 --> 21:04.350
以前他有意没考虑这个问题

21:04.350 --> 21:06.350
这是个严重的缺陷

21:06.350 --> 21:08.350
后来被另外一个保管令器

21:08.350 --> 21:09.350
叫做压

21:09.350 --> 21:11.350
我们后面会介绍的东西

21:11.350 --> 21:13.350
这个东西是最早考虑到

21:13.350 --> 21:14.350
这个问题的

21:14.350 --> 21:16.350
而且他处理的方式非常好

21:16.350 --> 21:17.350
那么后来

21:17.350 --> 21:18.350
有压学压

21:18.350 --> 21:20.350
这些东西互相抄的

21:20.350 --> 21:22.350
NPM他就学习了压

21:22.350 --> 21:23.350
这个方式

21:23.350 --> 21:25.350
他怎么做的呢

21:25.350 --> 21:26.350
他在安装包的时候

21:26.350 --> 21:27.350
现在NPM都有这个功能了

21:27.350 --> 21:28.350
他在安装包的时候

21:28.350 --> 21:29.350
他就会生成一个文件

21:29.350 --> 21:31.350
叫做Package.lock

21:31.350 --> 21:32.350
lock什么

21:32.350 --> 21:34.350
锁住把版本号锁住

21:34.350 --> 21:36.350
他生成了这么一个文件

21:36.350 --> 21:38.350
这个文件里面就寄入了安装的时候

21:38.350 --> 21:41.350
他所有的确切的一代关系

21:41.350 --> 21:42.350
好 咱们看一下这个文件

21:42.350 --> 21:43.350
大概看一下就行了

21:43.350 --> 21:44.350
你看他这里边

21:44.350 --> 21:45.350
也有个Dependency

21:45.350 --> 21:47.350
你看他就把我们的

21:47.350 --> 21:48.350
一代包全部放这了

21:48.350 --> 21:50.350
每一个一代包的确切的

21:50.350 --> 21:51.350
他的紫一代

21:51.350 --> 21:52.350
你看

21:52.350 --> 21:54.350
这个一代包的里边的紫一代

21:54.350 --> 21:56.350
Dependency是

21:56.350 --> 21:57.350
是不是

21:57.350 --> 21:58.350
这些什么

21:58.350 --> 21:59.350
Version具体的版本

21:59.350 --> 22:00.350
对不对

22:00.350 --> 22:01.350
它具体的版本

22:01.350 --> 22:03.350
是不是全部给他写出来了

22:03.350 --> 22:04.350
这个文件很大

22:04.350 --> 22:06.350
他把所有的包里边的确切版本

22:06.350 --> 22:08.350
全部记录下来了

22:08.350 --> 22:10.350
那么有了这个文件之后

22:10.350 --> 22:11.350
它有什么好处呢

22:11.350 --> 22:12.350
如果说一字工程

22:12.350 --> 22:14.350
我们把工程拷贝过去

22:14.350 --> 22:16.350
我们不会拷贝

22:16.350 --> 22:17.350
一定是不会拷贝这个的

22:17.350 --> 22:18.350
如果说一字工程的时候

22:18.350 --> 22:20.350
移植到这个文件

22:20.350 --> 22:21.350
如果说你

22:21.350 --> 22:23.350
你把这个文件也参与了移植

22:23.350 --> 22:24.350
那么也就是什么呢

22:24.350 --> 22:25.350
你在还原包的时候

22:25.350 --> 22:27.350
比方说到时候用npm install

22:27.350 --> 22:28.350
来还原包的时候

22:28.350 --> 22:29.350
他如果发现了

22:29.350 --> 22:31.350
你工程里边有这个文件

22:31.350 --> 22:32.350
那么他会按照这个文件里边的

22:32.350 --> 22:35.350
确切版本进行安装

22:35.350 --> 22:36.350
那么就是

22:36.350 --> 22:38.350
还原了一个跟

22:38.350 --> 22:40.350
你之前安装一模一样的

22:40.350 --> 22:41.350
场景

22:41.350 --> 22:43.350
这个特别适合在开发阶段

22:43.350 --> 22:46.350
开发阶段保持包的稳定

22:46.350 --> 22:48.350
那么以后到服务器上

22:48.350 --> 22:50.350
还要不要这个文件呢

22:50.350 --> 22:52.350
看你自己考虑

22:52.350 --> 22:53.350
如果说你要还原跟

22:53.350 --> 22:55.350
我们开发环境一模一样的东西的话

22:55.350 --> 22:56.350
那么你可以要它

22:56.350 --> 22:57.350
如果说你不需要

22:57.350 --> 22:59.350
你可以让它增加的话

22:59.350 --> 23:00.350
那么你可以不要它

23:00.350 --> 23:02.350
总之自行决定

23:02.350 --> 23:04.350
这个东西没有人能帮你决定

23:04.350 --> 23:05.350
看你自己

23:05.350 --> 23:07.350
它自己是喜欢更加稳固一点

23:07.350 --> 23:08.350
稳件一点好了

23:08.350 --> 23:10.350
还是喜欢更加开放一点好

23:12.350 --> 23:13.350
这个东西

23:13.350 --> 23:14.350
其实也不是考虑自己

23:14.350 --> 23:17.350
是你们团队讨论的结果

23:17.350 --> 23:18.350
这就是这个文件的功能

23:18.350 --> 23:19.350
原来的意思

23:19.350 --> 23:22.350
如果说你不想安装确切的依赖

23:22.350 --> 23:24.350
那么你把这个文件一删就就行了

23:24.350 --> 23:25.350
把删就行了

23:25.350 --> 23:26.350
就这么个意思

23:26.350 --> 23:27.350
OK

23:27.350 --> 23:29.350
这是关于这个避免还原的差异

23:29.350 --> 23:31.350
什么叫还原我们之前安装的依赖

23:31.350 --> 23:32.350
把还原

23:32.350 --> 23:33.350
还原的时候可能跟过去的安装

23:33.350 --> 23:34.350
就会有差异

23:34.350 --> 23:35.350
如果要避免这个差异

23:35.350 --> 23:37.350
就保持这个文件不动

23:37.350 --> 23:39.350
这个文件里边有确切的版本

23:40.350 --> 23:43.350
下面我们介绍个扩展姿势

23:43.350 --> 23:45.350
这个姿势就纯粹是听得到了

23:46.350 --> 23:47.350
就说什么意思

23:48.350 --> 23:50.350
我们平时安装一代的时候

23:50.350 --> 23:52.350
他都是把依赖的包

23:52.350 --> 23:54.350
也放到loaded margins目录下面

23:54.350 --> 23:56.350
就是他的目录结构

23:56.350 --> 23:57.350
跟我们比方说

23:57.350 --> 23:59.350
比方说我们安装一个包A

23:59.350 --> 24:00.350
他一代包B

24:01.350 --> 24:03.350
那么安装到loaded margins目录下面

24:04.350 --> 24:05.350
那么他是怎么安装

24:05.350 --> 24:06.350
他的目录结构是这样子

24:06.350 --> 24:07.350
有A也有B

24:07.350 --> 24:09.350
他们是同一个目录

24:09.350 --> 24:11.350
还没有形成成绩关系

24:11.350 --> 24:13.350
我这里也先说几句

24:13.350 --> 24:14.350
就最早的时候

24:14.350 --> 24:16.350
他是会形成成绩关系的

24:16.350 --> 24:17.350
就怎么回事

24:17.350 --> 24:18.350
你安装A的时候

24:18.350 --> 24:19.350
A依赖B

24:19.350 --> 24:21.350
他会形成这么一种结构

24:21.350 --> 24:24.350
A下面这样子来写

24:24.350 --> 24:26.350
A的紫目录下面有个包B

24:26.350 --> 24:27.350
他会这样来处理

24:27.350 --> 24:29.350
最早的时候是这样处理的

24:29.350 --> 24:31.350
后来为什么不这样处理的

24:31.350 --> 24:33.350
因为在Windows系统上面

24:33.350 --> 24:34.350
有一个问题就是

24:36.350 --> 24:39.350
路径不能太深

24:39.350 --> 24:40.350
文件不能埋得太深

24:40.350 --> 24:42.350
因为你这样子一写的话

24:42.350 --> 24:43.350
就可能导致这种情况

24:43.350 --> 24:44.350
A依赖B

24:44.350 --> 24:46.350
B有依赖C

24:46.350 --> 24:47.350
C有依赖D

24:47.350 --> 24:49.350
所以可以套了很深很深的一个文件结构

24:49.350 --> 24:50.350
对吧

24:50.350 --> 24:51.350
Windows系统

24:51.350 --> 24:52.350
原来是不能允许

24:52.350 --> 24:53.350
太过于深的文件结构的

24:53.350 --> 24:55.350
所以说他有可能

24:55.350 --> 24:57.350
安装的交出问题

24:57.350 --> 24:58.350
就会出问题

24:58.350 --> 24:59.350
因此他后来

24:59.350 --> 25:00.350
把他拍扁了

25:00.350 --> 25:01.350
没有形成这种成绩结构了

25:01.350 --> 25:03.350
把他都放到同一个目录了

25:03.350 --> 25:04.350
放到同一个目录

25:04.350 --> 25:05.350
还有一个好处就是

25:05.350 --> 25:06.350
比方说A依赖B

25:06.350 --> 25:08.350
那么C有依赖B

25:08.350 --> 25:10.350
那以前是不是安装两次

25:10.350 --> 25:11.350
对吧

25:11.350 --> 25:12.350
那么现在拍扁了过后了

25:12.350 --> 25:13.350
他只需要安装一次就行了

25:13.350 --> 25:14.350
对不对

25:14.350 --> 25:15.350
他综合考虑

25:15.350 --> 25:17.350
那么到底B应该是个什么版本

25:17.350 --> 25:18.350
他把考虑清楚过后了

25:18.350 --> 25:19.350
他把安装到

25:19.350 --> 25:21.350
同一个目录下面就行了

25:21.350 --> 25:23.350
这种做法叫做Flight

25:23.350 --> 25:25.350
这多说两句

25:26.350 --> 25:27.350
听到这就行了

25:27.350 --> 25:28.350
Dependency

25:32.350 --> 25:33.350
平面的依赖

25:33.350 --> 25:34.350
Flight是平面的

25:34.350 --> 25:35.350
拍扁了

25:36.350 --> 25:37.350
但是这里面

25:37.350 --> 25:38.350
可能还遇到一种

25:38.350 --> 25:39.350
比较特殊的情况

25:39.350 --> 25:41.350
就是下面那个图里边的情况

25:41.350 --> 25:43.350
A依赖C

25:43.350 --> 25:45.350
依赖的版本是1.4.0

25:45.350 --> 25:46.350
B依赖C

25:46.350 --> 25:49.350
依赖的版本是1.2.3

25:49.350 --> 25:50.350
这个要命了

25:50.350 --> 25:53.350
而且他们依赖的是确切版本

25:53.350 --> 25:54.350
这个就要命了

25:54.350 --> 25:55.350
对吧

25:55.350 --> 25:56.350
这个我怎么挖的

25:56.350 --> 25:57.350
我到底安装哪一个了

25:57.350 --> 25:59.350
如果说我还用这样的目录

25:59.350 --> 26:01.350
A B C

26:01.350 --> 26:03.350
那么C的版本到底是啥了

26:04.350 --> 26:06.350
到底是1.4.0还是1.2.3

26:06.350 --> 26:07.350
对吧

26:07.350 --> 26:08.350
用哪一个都不合适

26:08.350 --> 26:10.350
那么面对这种情况

26:10.350 --> 26:11.350
N片把他逼疯了

26:11.350 --> 26:12.350
实在没办法了

26:12.350 --> 26:13.350
他怎么办

26:13.350 --> 26:14.350
他就用这种最原始的方式

26:14.350 --> 26:15.350
看下面的结构

26:15.350 --> 26:16.350
他就混形了

26:16.350 --> 26:17.350
下面那个结构

26:17.350 --> 26:18.350
Low the Marjus

26:18.350 --> 26:19.350
里边有什么

26:19.350 --> 26:20.350
有A和B两个包

26:20.350 --> 26:21.350
对吧

26:21.350 --> 26:22.350
A里边呢

26:22.350 --> 26:23.350
他又给你建了一个目录

26:23.350 --> 26:24.350
Low the Marjus

26:24.350 --> 26:25.350
里边包含C这个包

26:25.350 --> 26:26.350
那么这个包呢

26:26.350 --> 26:28.350
就是1.4.0

26:28.350 --> 26:29.350
那B里边呢

26:29.350 --> 26:30.350
他有一个Low the Marjus

26:30.350 --> 26:31.350
他里边也有个C

26:31.350 --> 26:32.350
C就是1.2.3

26:32.350 --> 26:33.350
你想这个道理

26:33.350 --> 26:35.350
那么A包里边的文件

26:35.350 --> 26:38.350
A里边的文件用Require C的时候

26:38.350 --> 26:39.350
那么是不是首先

26:39.350 --> 26:40.350
找当前目录

26:40.350 --> 26:41.350
下面的Low the Marjus

26:41.350 --> 26:42.350
是不是找到这个

26:42.350 --> 26:43.350
找到这个C了

26:43.350 --> 26:44.350
对不对

26:44.350 --> 26:46.350
那么B里边用Require C的时候

26:46.350 --> 26:47.350
是不是找到这个目录

26:47.350 --> 26:48.350
找到C了

26:48.350 --> 26:49.350
对不对

26:49.350 --> 26:50.350
没问题吧

26:50.350 --> 26:52.350
他就用这种方案来解决的

26:52.350 --> 26:53.350
OK

26:53.350 --> 26:54.350
这就是关于

26:54.350 --> 26:56.350
他的差异版本的处理方式

26:56.350 --> 26:57.350
这些东西都做了解

26:57.350 --> 26:58.350
这些可能我们主要是

26:58.350 --> 26:59.350
讲解了一下

26:59.350 --> 27:01.350
语异版本的这么一些规则

27:01.350 --> 27:02.350
不知道这个啥意思

27:02.350 --> 27:06.350
另外就是关于Lock文件

27:06.350 --> 27:07.350
他到底什么意思

27:07.350 --> 27:08.350
给大家说一下

27:09.350 --> 27:10.350
平时我们也不太会

27:10.350 --> 27:11.350
关注这些东西

27:11.350 --> 27:12.350
平时我们最多的就是

27:12.350 --> 27:13.350
就我们之前讲的

27:13.350 --> 27:14.350
安装包

27:14.350 --> 27:15.350
安装就往上

27:15.350 --> 27:16.350
OK

27:16.350 --> 27:18.350
这是关于语异版本这一块

