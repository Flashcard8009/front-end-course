WEBVTT

00:00.750 --> 00:05.550
这个章节呢 我们来介绍另外一个保管力器 叫做一亚

00:06.350 --> 00:10.950
其实呢 除了NPM这个核心的保管力器之外呢

00:10.950 --> 00:14.350
其实在前端的发展过程中

00:14.350 --> 00:17.750
还陆陆续续出现了一些其他的保管力器

00:17.750 --> 00:20.150
那么有些其他的保管力器呢

00:20.150 --> 00:23.350
已经逐渐的被历史所淘汰了啊

00:23.350 --> 00:25.350
也没有怎么用了

00:25.350 --> 00:28.550
但是呢 一亚这个东西呢 还是需要大家学习的

00:28.750 --> 00:31.950
因为压这个东西呢 目前呢 仍然很火爆啊

00:31.950 --> 00:34.750
那么至于他为什么会活这么火爆呢

00:34.750 --> 00:37.550
我们这些可能先对他做一个简介 你就明白了

00:38.550 --> 00:40.150
嗯 这里呢 有个官网啊

00:40.150 --> 00:42.150
我们先把这个压了 下载下来啊

00:42.150 --> 00:44.150
这个有个官网 我们这里进去

00:44.750 --> 00:47.750
压这个东西呢 它是基于NPM做的

00:47.950 --> 00:49.350
嗯 它基于什么呢

00:49.350 --> 00:52.350
它基于就是NPM在NPM基础上啊

00:52.350 --> 00:55.150
来做了一些改进和优化

00:55.150 --> 00:58.350
所以说呢 它的很多东西呢 是跟NPM相同的

00:58.350 --> 01:02.950
比方说到目前为止啊 压着压了这个保管力器呢

01:02.950 --> 01:06.350
它仍然使用的是NPM的registry

01:06.350 --> 01:09.150
就是NPM的入口 对吧

01:09.150 --> 01:11.950
这个数据库 它仍然是使用的是那个保护数据库

01:11.950 --> 01:14.950
它没有自己的保护数据库

01:14.950 --> 01:16.950
它使用的是NPM的保护数据库

01:16.950 --> 01:20.550
所以说呢 我们使用压的时候呢

01:20.550 --> 01:22.550
后边我们会介绍啊 压怎么去使用

01:22.550 --> 01:24.750
这一张很简单啊 没用不了解结课

01:24.750 --> 01:27.550
因为很多东西呢 都是跟NPM相同的

01:27.750 --> 01:30.150
我们在使用这个压的时候呢

01:30.150 --> 01:32.750
你会发现跟NPM就非常非常的相似啊

01:32.750 --> 01:34.150
已经非常相似了

01:34.150 --> 01:37.950
其实呢 压啊 它其实有这么一个野心

01:37.950 --> 01:40.950
就是说它要做一个跟NPM齐平的

01:40.950 --> 01:44.550
它要独立出来啊 独立出来自己去建一个库

01:44.550 --> 01:45.750
但是呢 这个东西呢

01:45.750 --> 01:47.550
一直没有实施 中间有很多的困难

01:47.550 --> 01:49.150
倒不是技术上的困难啊

01:49.150 --> 01:53.150
只是实施起来的 在推广上啊 市场上的困难啊

01:53.150 --> 01:54.550
那么现在呢 目前还没有啊

01:54.550 --> 01:57.550
目前仍然是使用的是NPM的那个数据库

01:57.550 --> 01:59.550
呃 然后我们这里安装啊

02:00.550 --> 02:03.550
首先呢 我们这里呢 这里看安装压啊 点击这个

02:03.550 --> 02:05.550
我这里是选择的中文啊

02:05.550 --> 02:09.550
大家可以如果说看原版和最新的第一手资料的话

02:09.550 --> 02:12.150
最好用英文啊 这里安装安装的话

02:12.150 --> 02:13.550
这里根据你的系统啊

02:13.550 --> 02:15.550
根据你的系统自己去选择一个安装啊

02:15.550 --> 02:16.550
安装就行了

02:16.550 --> 02:18.550
呃 中文这里好像少了一些东西

02:18.550 --> 02:20.550
我们还是用英文得了

02:20.550 --> 02:23.550
啊 这里根据你的系统啊

02:23.550 --> 02:25.550
你是苹果的话就Mac

02:25.550 --> 02:27.550
啊 你是那个Windows的话就选Windows

02:27.550 --> 02:30.550
好 我们安装的时候呢 版本呢一定要选Stable

02:30.550 --> 02:33.550
就表示什么 稳定版啊 稳定版

02:33.550 --> 02:36.550
啊 那么安装 这里也需要下载啊

02:36.550 --> 02:38.550
呃 这里我的顺便说一下

02:38.550 --> 02:41.550
最早的时候呢 压的压了

02:41.550 --> 02:43.550
它是通过NPM的安装的

02:43.550 --> 02:46.550
啊 也就是它是作为一个第三方库存在的

02:46.550 --> 02:48.550
它保存在NPM的仓库里边

02:48.550 --> 02:50.550
啊 它提供了一个命令行

02:50.550 --> 02:53.550
啊 让你去使用它的新的命令行工具

02:53.550 --> 02:56.550
来进行操作 来进行包的管理

02:56.550 --> 02:59.550
但是呢 现在呢 压是比较有野心的啊

02:59.550 --> 03:02.550
因此呢 它现在呢 出来了一个就是独立的安装包

03:02.550 --> 03:05.550
啊 希望你用独立的安装包的方式来安装

03:05.550 --> 03:08.550
它不再提供用NPM的方式来安装了啊

03:08.550 --> 03:10.550
好 那么我们就直接下载啊

03:10.550 --> 03:12.550
当load installer 下载这个安装包

03:12.550 --> 03:13.550
啊 点击下载就行了

03:13.550 --> 03:15.550
而我这里其实已经下载好了啊

03:15.550 --> 03:16.550
已经下载在桌面上了

03:16.550 --> 03:18.550
那我们直接进入安装

03:18.550 --> 03:19.550
好 双击安装

03:19.550 --> 03:21.550
啊 其实很简单啊 下一步

03:21.550 --> 03:23.550
然后呢 同意啊 下一步

03:23.550 --> 03:25.550
目楼都难得改了啊 下一步 下一步

03:25.550 --> 03:26.550
安装 安装

03:26.550 --> 03:28.550
啊 完成安装了

03:28.550 --> 03:30.550
就我们就没了啊 就安装完成了

03:30.550 --> 03:31.550
安装完成了 过后呢

03:31.550 --> 03:32.550
我们可以进入一个命令行

03:32.550 --> 03:35.550
啊 去看一下啊 这个压有没有安装成功

03:35.550 --> 03:37.550
啊 压 干杯

03:37.550 --> 03:41.550
啊 它告诉你 今天的版本是1.2.121.1这个版本

03:41.550 --> 03:43.550
啊 那么就安装好了

03:43.550 --> 03:45.550
就这么简单啊 那么之后呢 我们

03:45.550 --> 03:47.550
这一张呢 我们就学习用压这个命令

03:47.550 --> 03:49.550
啊 用压这个命令来管理包

03:49.550 --> 03:51.550
就不再是NPM的命令了啊

03:51.550 --> 03:53.550
好 那么接下来 我的开载对它进行介绍了

03:53.550 --> 03:55.550
它怎么回事

03:55.550 --> 03:58.550
首先呢 压这个呢 它的出生就比较高贵

03:58.550 --> 04:01.550
它是有几家大公司联合推出的一个

04:01.550 --> 04:03.550
包管理器啊 其中有两个

04:03.550 --> 04:05.550
鼎鼎大名的Facebook和谷歌 对吧

04:05.550 --> 04:08.550
然后呢 它仍然使用的是NPM的Recistry

04:08.550 --> 04:10.550
它仍然使用的是NPM的那个数据户

04:10.550 --> 04:12.550
只不过呢 它封装了全新的

04:12.550 --> 04:15.550
这些CD 就是命令行工具

04:15.550 --> 04:17.550
它对包固进行管理就不再使用NPM了

04:17.550 --> 04:19.550
那么至于它为什么这么火爆啊

04:19.550 --> 04:21.550
刚出来的时候 为什么这么火爆

04:21.550 --> 04:24.550
呃 压的出现了 它当时出现的时候

04:24.550 --> 04:26.550
就非常强烈 首先它的背景就很强大

04:26.550 --> 04:28.550
对吧 它出品的公司很强大

04:28.550 --> 04:30.550
另外呢 它做出来的东西呢

04:30.550 --> 04:32.550
确实比NPM好得多

04:32.550 --> 04:34.550
因此呢 压出现了过了很多的大公司

04:34.550 --> 04:37.550
单凡呢 学前端的啊 前端的技术

04:37.550 --> 04:40.550
开发者 它只要看到了压啊

04:40.550 --> 04:43.550
它只要有机会 它一定使用压

04:43.550 --> 04:44.550
而不再使用NPM

04:44.550 --> 04:45.550
甚至有人说呢

04:45.550 --> 04:48.550
NPM当时呢 只剩下一个人 给失去了

04:48.550 --> 04:50.550
它的命令行已经全部被压起去代了

04:50.550 --> 04:52.550
为什么会出现这种情况呢

04:52.550 --> 04:54.550
是因为当时呢 过去啊

04:54.550 --> 04:56.550
NPM存在着很多的问题

04:56.550 --> 04:58.550
而这些问题呢 都被压解决了

04:58.550 --> 05:00.550
那我们来看一下NPM存在什么问题啊

05:00.550 --> 05:02.550
这是过去啊 现在很多问题都解决了

05:02.550 --> 05:03.550
过去是什么呢

05:03.550 --> 05:04.550
最早的时候啊

05:04.550 --> 05:07.550
NPM的它的一代目录了千套层次

05:07.550 --> 05:08.550
非常深

05:08.550 --> 05:09.550
过去的时候呢

05:09.550 --> 05:11.550
NPM的一代是千套的啊

05:11.550 --> 05:13.550
就像我们之前好像有一些客户说过

05:13.550 --> 05:15.550
比方说我们用NPM安装了两个包

05:15.550 --> 05:17.550
一个A包 一个B包

05:17.550 --> 05:19.550
那么这个A包呢

05:19.550 --> 05:20.550
它里面一代C

05:20.550 --> 05:21.550
C安装到哪儿呢

05:21.550 --> 05:23.550
它不像现在 它是平行安装的

05:23.550 --> 05:25.550
对吧 它是这样子安装的

05:25.550 --> 05:26.550
之前它是这样子

05:26.550 --> 05:27.550
在A包里面呢

05:27.550 --> 05:30.550
建立一个loaded modules目录

05:30.550 --> 05:31.550
然后呢

05:31.550 --> 05:33.550
loaded modules目录里面有C

05:33.550 --> 05:35.550
那么B里面也一代C

05:35.550 --> 05:37.550
那么也是建立loaded modules目录

05:37.550 --> 05:39.550
那么现在呢 还会这样做

05:39.550 --> 05:41.550
有一种情况还会这样做

05:41.550 --> 05:42.550
什么情况呢

05:42.550 --> 05:43.550
就是版本不一致的情况

05:43.550 --> 05:44.550
对吧

05:44.550 --> 05:45.550
以前没有

05:45.550 --> 05:46.550
以前不管版本一不一致

05:46.550 --> 05:47.550
它全是这样做的

05:47.550 --> 05:49.550
是不是全是这样做的

05:49.550 --> 05:50.550
那么这样一来的话

05:50.550 --> 05:52.550
如果说C包还一代别的包

05:52.550 --> 05:53.550
比方说一代D

05:53.550 --> 05:55.550
那么它又会出现这种情况

05:55.550 --> 05:57.550
loaded modules

05:57.550 --> 05:58.550
那么这里是不是D

05:58.550 --> 06:00.550
那么这个千套的目录层次

06:00.550 --> 06:02.550
就非常非常的深

06:02.550 --> 06:04.550
那么这里也是一样

06:04.550 --> 06:05.550
我这里画一下吧

06:05.550 --> 06:06.550
它又会千套一个

06:06.550 --> 06:08.550
非常非常深的目录结构

06:08.550 --> 06:09.550
那么这样子呢

06:09.550 --> 06:10.550
在Windows系统上

06:10.550 --> 06:11.550
它就会出很大的问题

06:11.550 --> 06:12.550
因为Windows系统呢

06:12.550 --> 06:14.550
它的目录层次不能过深

06:14.550 --> 06:16.550
它是有这么一个规则

06:16.550 --> 06:17.550
中所周知的原因

06:17.550 --> 06:18.550
什么原因呢

06:18.550 --> 06:19.550
就是Windows系统里边

06:19.550 --> 06:20.550
它这个目录结构啊

06:20.550 --> 06:22.550
比方说我们从某一个盘

06:22.550 --> 06:23.550
某一个盘

06:23.550 --> 06:24.550
然后一个目录

06:24.550 --> 06:25.550
一个目录

06:25.550 --> 06:26.550
那么这个目录的路径呢

06:26.550 --> 06:28.550
它最多只能支持256个制服

06:28.550 --> 06:30.550
它不能再多了

06:30.550 --> 06:31.550
再多的话

06:31.550 --> 06:32.550
它就支持不了了

06:32.550 --> 06:33.550
这是Windows的

06:33.550 --> 06:34.550
它特有的这么一种机制

06:34.550 --> 06:35.550
所以说呢

06:35.550 --> 06:37.550
当你目录层次很深的时候

06:37.550 --> 06:39.550
结构就会非常非常长

06:39.550 --> 06:41.550
它要去寻找文件的时候呢

06:41.550 --> 06:43.550
它可能会超过256个制服

06:43.550 --> 06:44.550
那么就出问题

06:44.550 --> 06:46.550
以前呢有很多很麻

06:46.550 --> 06:47.550
有很多的解决办法

06:47.550 --> 06:48.550
来解决这个问题

06:48.550 --> 06:50.550
但是极其的麻烦

06:50.550 --> 06:51.550
所以说呢

06:51.550 --> 06:52.550
这是它第一个问题

06:52.550 --> 06:54.550
这以前啊

06:54.550 --> 06:55.550
然后呢由于这个问题

06:55.550 --> 06:57.550
它又出现了新的问题

06:57.550 --> 06:58.550
就是下载速度很慢

06:58.550 --> 06:59.550
为什么呢

06:59.550 --> 07:00.550
因为千套层次的原因

07:00.550 --> 07:01.550
你看这个目录

07:01.550 --> 07:03.550
你是不是得先下载A这个包

07:03.550 --> 07:04.550
对吧

07:04.550 --> 07:06.550
然后才能去下载C

07:06.550 --> 07:07.550
对不对

07:07.550 --> 07:08.550
是不是得这样做

07:08.550 --> 07:10.550
先下载A再下载C再下载D

07:10.550 --> 07:12.550
因为它的目录层次是千套的

07:12.550 --> 07:13.550
所以说呢

07:13.550 --> 07:14.550
它要一个一个下载

07:14.550 --> 07:15.550
因此呢

07:15.550 --> 07:16.550
NP们对包的下载呢

07:16.550 --> 07:17.550
它只能是串形的

07:17.550 --> 07:18.550
怎么

07:18.550 --> 07:19.550
就是前一个要下载完了过后呢

07:19.550 --> 07:20.550
才会下载下一个

07:20.550 --> 07:22.550
它是这样子下载的

07:22.550 --> 07:23.550
那么如果说

07:23.550 --> 07:24.550
比方说我们这个

07:24.550 --> 07:25.550
本来安装一个包

07:25.550 --> 07:26.550
那个包呢有几十个一代

07:26.550 --> 07:28.550
那个几十个一代包里面

07:28.550 --> 07:29.550
又有几十个一代

07:29.550 --> 07:30.550
可能要下载100多个包

07:30.550 --> 07:31.550
那么它只能一个一个下

07:31.550 --> 07:33.550
那么你懂得啊

07:33.550 --> 07:35.550
哪怕你的贷款很多

07:35.550 --> 07:36.550
你得也得一个一个下

07:36.550 --> 07:37.550
所以贷款资源呢

07:37.550 --> 07:38.550
没有完全利用

07:38.550 --> 07:39.550
这样子呢

07:39.550 --> 07:41.550
导致了下载速度慢

07:41.550 --> 07:42.550
然后呢

07:42.550 --> 07:43.550
还有一个很严重的问题就是

07:43.550 --> 07:44.550
它会导致多个

07:44.550 --> 07:45.550
相同的版本的包

07:45.550 --> 07:46.550
被重复下载

07:46.550 --> 07:47.550
比方说A

07:47.550 --> 07:48.550
它一代的包

07:48.550 --> 07:49.550
C的包

07:49.550 --> 07:50.550
那么B也一代C的包

07:50.550 --> 07:51.550
那么这两个包呢

07:51.550 --> 07:53.550
版本是完全一样的

07:53.550 --> 07:54.550
又可能版本是完全一样的

07:54.550 --> 07:56.550
都是它的最新版本

07:56.550 --> 07:57.550
那么导致呢

07:57.550 --> 07:58.550
这两个包是不是下载两次

07:58.550 --> 07:59.550
而更恐怖的是

07:59.550 --> 08:00.550
这两个包呢

08:00.550 --> 08:01.550
它还要一代别的包

08:01.550 --> 08:02.550
是不是又要下载

08:02.550 --> 08:03.550
对吧

08:03.550 --> 08:04.550
它会重复的下载

08:04.550 --> 08:06.550
已经被下载过了

08:06.550 --> 08:07.550
就导致了下载

08:07.550 --> 08:09.550
就是相同的版本的包呢

08:09.550 --> 08:10.550
被重复的下载

08:10.550 --> 08:11.550
导致下载速度慢

08:11.550 --> 08:13.550
这下载速度慢这个缺陷

08:13.550 --> 08:14.550
然后呢

08:14.550 --> 08:15.550
在过去呢

08:15.550 --> 08:16.550
现在已经看不到了

08:16.550 --> 08:17.550
过去呢

08:17.550 --> 08:18.550
NPM安装包的时候呢

08:18.550 --> 08:20.550
它会在控制台里面输出

08:20.550 --> 08:21.550
现在呢

08:21.550 --> 08:22.550
我们看到NPM也会输出

08:22.550 --> 08:23.550
只不过输出的东西比较少

08:23.550 --> 08:24.550
就是我们用NPM

08:24.550 --> 08:25.550
Install的时候呢

08:25.550 --> 08:26.550
它控制台有些输出

08:26.550 --> 08:27.550
对吧

08:27.550 --> 08:28.550
有些信息

08:28.550 --> 08:29.550
该爆出的爆出

08:29.550 --> 08:30.550
那么以前呢

08:30.550 --> 08:31.550
它输出的东西呢

08:31.550 --> 08:33.550
非常的繁杂

08:33.550 --> 08:34.550
我说了

08:34.550 --> 08:35.550
它每下载一个包呢

08:35.550 --> 08:36.550
它都给告诉你这个包

08:36.550 --> 08:37.550
下载时间用了多少

08:37.550 --> 08:39.550
包下载包的名字叫什么

08:39.550 --> 08:40.550
包的一些哪些

08:40.550 --> 08:42.550
减要的信息给打印在控制台

08:42.550 --> 08:44.550
如果说你安装一个包的时候

08:44.550 --> 08:45.550
包的依赖很多

08:45.550 --> 08:46.550
那么就会导致

08:46.550 --> 08:48.550
控制台里面有大量的信息

08:48.550 --> 08:49.550
如果说其中一个包

08:49.550 --> 08:50.550
下载出问题了

08:50.550 --> 08:52.550
你要从这种大量的信息里面

08:52.550 --> 08:54.550
去找到这个问题

08:54.550 --> 08:56.550
是极其难以查到的

08:56.550 --> 08:57.550
所以说以前呢

08:57.550 --> 08:58.550
如果说下载出问题了

08:58.550 --> 08:59.550
你可能都感觉不到

08:59.550 --> 09:00.550
你可能去喝茶去了

09:00.550 --> 09:01.550
到水去了

09:01.550 --> 09:02.550
一回来

09:02.550 --> 09:03.550
好像下载完了

09:03.550 --> 09:05.550
但是它其中有一个地方出错了

09:05.550 --> 09:06.550
但是控制台的信息很多

09:06.550 --> 09:08.550
你都不知道哪里出错了

09:08.550 --> 09:10.550
你都认为它是正确的

09:10.550 --> 09:11.550
那么导致了一些隐患

09:11.550 --> 09:13.550
这是以前的问题

09:13.550 --> 09:14.550
然后就是还有一个

09:14.550 --> 09:16.550
工程一致的问题

09:16.550 --> 09:18.550
以前呢

09:18.550 --> 09:20.550
NPM是没有那个LOCK文件的

09:20.550 --> 09:22.550
就是没有那个Package

09:22.550 --> 09:24.550
Hunganglock那个文件

09:24.550 --> 09:26.550
所以说它的版本依赖

09:26.550 --> 09:27.550
本身就是比较模糊的

09:27.550 --> 09:28.550
因为我们知道

09:28.550 --> 09:29.550
它的版本是用的是什么

09:29.550 --> 09:31.550
语异化版本号

09:31.550 --> 09:32.550
对吧

09:32.550 --> 09:34.550
因此它可能会导致

09:34.550 --> 09:35.550
我这个地方开发的

09:35.550 --> 09:36.550
是用了一个版本

09:36.550 --> 09:37.550
然后一致过去的过后

09:37.550 --> 09:39.550
你再也安装又是另外一个版本了

09:39.550 --> 09:41.550
或者是到服务器那边

09:41.550 --> 09:42.550
也安装又是另外一个版本了

09:42.550 --> 09:44.550
就可能会导致一些隐患

09:44.550 --> 09:47.550
所以说呢

09:47.550 --> 09:49.550
我们在以前的时候

09:49.550 --> 09:50.550
没有办法

09:50.550 --> 09:52.550
完全的还原开发环境

09:52.550 --> 09:53.550
开发环境里面安装的东西

09:53.550 --> 09:55.550
没法再服务器完全还原

09:55.550 --> 09:56.550
因为可能会出现

09:56.550 --> 09:57.550
版本不一致的情况

09:57.550 --> 09:59.550
以前倒是有一些命令的

09:59.550 --> 10:00.550
可以NPM倒是

10:00.550 --> 10:02.550
后来发现这个问题了

10:02.550 --> 10:03.550
它出了一些命令

10:03.550 --> 10:04.550
但是也极其的麻烦

10:04.550 --> 10:06.550
这是工程一致的问题

10:06.550 --> 10:08.550
那么针对上述的主要问题

10:08.550 --> 10:10.550
压它从单身的那一天

10:10.550 --> 10:12.550
它就立志要解决这些问题

10:12.550 --> 10:13.550
所以说为什么压

10:13.550 --> 10:14.550
后来那么火爆了

10:14.550 --> 10:15.550
就是因为它把

10:15.550 --> 10:17.550
这些非常重要的问题

10:17.550 --> 10:18.550
把它解决了

10:18.550 --> 10:19.550
它怎么来解决呢

10:19.550 --> 10:20.550
第一个

10:20.550 --> 10:22.550
它是用扁平的目录结构

10:22.550 --> 10:23.550
它就不再使用这种模式了

10:23.550 --> 10:25.550
它使用的是扁平目录

10:25.550 --> 10:27.550
就这种目录结构

10:28.550 --> 10:29.550
那么C2依赖D

10:29.550 --> 10:30.550
那么D就在这

10:30.550 --> 10:32.550
它使用扁平的目录结构

10:32.550 --> 10:33.550
避免了重复下载

10:33.550 --> 10:35.550
避免了目录层次过生

10:35.550 --> 10:37.550
然后下载的时候

10:37.550 --> 10:39.550
由于它目录变得扁平了

10:39.550 --> 10:40.550
因此它下载的时候

10:40.550 --> 10:41.550
可以进行并行下载

10:41.550 --> 10:42.550
就是我把依赖关系

10:42.550 --> 10:43.550
确定过后

10:43.550 --> 10:44.550
我依旧要安装这么一些薄

10:44.550 --> 10:45.550
OK

10:45.550 --> 10:46.550
那我就一起下载

10:46.550 --> 10:48.550
开多个线程进行并行下载

10:48.550 --> 10:49.550
同时下载

10:49.550 --> 10:50.550
这样子安装的下载

10:50.550 --> 10:52.550
安装的速度就非常非常的快

10:52.550 --> 10:54.550
然后它使用了本地缓存

10:54.550 --> 10:56.550
就是它有个缓存文件

10:56.550 --> 10:59.550
在它的全军目录里面有个缓存文件

10:59.550 --> 11:00.550
缓存文件夹

11:00.550 --> 11:01.550
它把下载过的包

11:01.550 --> 11:03.550
全部放到本地目录里面去

11:03.550 --> 11:05.550
以后如果说你安装的时候

11:05.550 --> 11:07.550
安装的是同一个版本的包

11:07.550 --> 11:09.550
那么它不会从网络上直接下载

11:09.550 --> 11:10.550
它直接拷贝

11:10.550 --> 11:13.550
直接把那个包直接拷贝过来

11:13.550 --> 11:16.550
然后接下来

11:16.550 --> 11:18.550
控制台它仅输出关键信息

11:18.550 --> 11:20.550
它为了解决控制台里面

11:20.550 --> 11:21.550
很多的繁杂信息

11:21.550 --> 11:22.550
它就进行了简化

11:22.550 --> 11:24.550
它就最后一个总提示

11:24.550 --> 11:26.550
告诉你一共安装了多少个包

11:26.550 --> 11:27.550
它就不会把每一个包的信息

11:27.550 --> 11:28.550
全部给你输出

11:28.550 --> 11:30.550
然后重点放到什么

11:30.550 --> 11:32.550
重点放到错误和警告上面

11:32.550 --> 11:33.550
这是它的重点

11:33.550 --> 11:35.550
让你知道发生了一些事情

11:35.550 --> 11:37.550
这些事情可能会带来一些隐患

11:37.550 --> 11:39.550
那么它主要把这些重要的信息

11:39.550 --> 11:41.550
给你用醒目的方式来显示

11:41.550 --> 11:43.550
后面我们安装的时候就看到了

11:43.550 --> 11:46.550
然后它为了解决那个就是

11:46.550 --> 11:48.550
工程遗址的问题

11:48.550 --> 11:50.550
要完整的还原每一个版本

11:50.550 --> 11:51.550
那么它使用了一个lock文件

11:51.550 --> 11:53.550
来记录确切依赖

11:53.550 --> 11:55.550
其实我说这些东西

11:55.550 --> 11:57.550
说这些东西的时候你会感觉到

11:57.550 --> 11:59.550
NPM现在的东西是学的谁

11:59.550 --> 12:01.550
学的就是亚

12:01.550 --> 12:02.550
而不仅如此

12:02.550 --> 12:04.550
亚还优化了一些东西

12:04.550 --> 12:06.550
还做了一些小优化

12:06.550 --> 12:07.550
比方说它增加了一些

12:07.550 --> 12:09.550
功能比较强大的命令

12:09.550 --> 12:10.550
我们后边会学习

12:10.550 --> 12:12.550
然后它让我们NPM里面

12:12.550 --> 12:14.550
以前用的那些命令

12:14.550 --> 12:15.550
更加的语异化

12:15.550 --> 12:17.550
看上去更加舒服

12:17.550 --> 12:19.550
然后

12:19.550 --> 12:21.550
当时我们安装

12:21.550 --> 12:23.550
以前安装NPM本地

12:23.550 --> 12:24.550
用本地安装

12:24.550 --> 12:25.550
就是安装到我们的工程里边的时候

12:25.550 --> 12:27.550
有些包含它是带有了一个

12:27.550 --> 12:28.550
CD工具的

12:28.550 --> 12:29.550
我们之前学过什么Mochia

12:29.550 --> 12:30.550
对吧

12:30.550 --> 12:32.550
它只带了一些CD工具

12:32.550 --> 12:34.550
比方说我们学过了什么Mochia

12:34.550 --> 12:36.550
什么

12:36.550 --> 12:38.550
我们之前还学过Nodomo

12:38.550 --> 12:39.550
这些它本身就带了

12:39.550 --> 12:41.550
一些命令行工具

12:41.550 --> 12:42.550
那么我们在NPM里面

12:42.550 --> 12:44.550
要用的这个命令行工具

12:44.550 --> 12:45.550
以前是怎么用的呢

12:45.550 --> 12:47.550
以前是没有这个NPX的

12:47.550 --> 12:49.550
以前没有

12:49.550 --> 12:50.550
那么以前要怎么用

12:50.550 --> 12:51.550
这样子写 瞎人的狠

12:51.550 --> 12:53.550
以前的Nodomo

12:53.550 --> 12:55.550
我们要进到那个目录

12:55.550 --> 12:57.550
然后找到这个并母念甲

12:57.550 --> 12:58.550
然后找到这个命令行

12:58.550 --> 12:59.550
Mochia

12:59.550 --> 13:00.550
然后开始写命令

13:00.550 --> 13:02.550
Mochia 撒撒撒 测试撒撒撒

13:02.550 --> 13:03.550
对不对

13:03.550 --> 13:04.550
我们以前的这样子写

13:04.550 --> 13:05.550
就特别特别麻烦

13:05.550 --> 13:06.550
那么压了

13:06.550 --> 13:08.550
它就简化了一个操作

13:08.550 --> 13:09.550
它可以直接通过压这个命令

13:09.550 --> 13:10.550
直接启动

13:10.550 --> 13:11.550
我们后面会学习

13:11.550 --> 13:12.550
好

13:12.550 --> 13:14.550
然后它做了一个改变

13:14.550 --> 13:16.550
这个改变我觉得挺好的

13:16.550 --> 13:18.550
就是它对全局安装目录

13:18.550 --> 13:19.550
做了一个处理

13:19.550 --> 13:21.550
就是我们之前的用NPM

13:21.550 --> 13:23.550
我们之前用NPM的时候

13:23.550 --> 13:25.550
NPM Roots

13:25.550 --> 13:27.550
我们看一下全局目录

13:27.550 --> 13:29.550
我们的全局目录在这

13:29.550 --> 13:30.550
对吧

13:30.550 --> 13:31.550
我们全局目录

13:31.550 --> 13:33.550
再打开

13:38.440 --> 13:39.440
访问

13:39.440 --> 13:41.440
这是我们的全局目录

13:41.440 --> 13:42.440
对不对

13:42.440 --> 13:43.440
我们这个全局目录

13:43.440 --> 13:45.440
如果说我把我的

13:45.440 --> 13:47.440
我上到另一台计划机上

13:47.440 --> 13:49.440
还原我这个全局安装的东西

13:49.440 --> 13:50.440
其实我们后边还会

13:50.440 --> 13:51.440
陆陆续续

13:51.440 --> 13:53.440
设计到一些全局安装

13:53.440 --> 13:55.440
我们可能想在

13:55.440 --> 13:57.440
另外一台计算机上

13:57.440 --> 13:59.440
去全局安装一些东西

13:59.440 --> 14:00.440
想还原

14:00.440 --> 14:01.440
那么怎么还原的

14:01.440 --> 14:02.440
我不知道怎么还原

14:02.440 --> 14:04.440
你说怎么还原吗

14:04.440 --> 14:06.440
我是不是得用一个本本

14:06.440 --> 14:07.440
用一个计设本

14:07.440 --> 14:08.440
记录一下

14:08.440 --> 14:09.440
我这台计算机

14:09.440 --> 14:11.440
全局安装了哪些东西

14:11.440 --> 14:12.440
是不是得记录一下

14:12.440 --> 14:13.440
或者说我们通过命令

14:13.440 --> 14:14.440
通过什么命令

14:14.440 --> 14:17.440
就是通过NPM

14:17.440 --> 14:18.440
什么呢

14:18.440 --> 14:19.440
List

14:19.440 --> 14:20.440
对吧

14:20.440 --> 14:21.440
HungerG

14:21.440 --> 14:22.440
对吧

14:22.440 --> 14:23.440
可以看一下全局

14:23.440 --> 14:24.440
我们安装了什么东西

14:24.440 --> 14:25.440
是不是

14:25.440 --> 14:26.440
我们可以通过这样的命令

14:26.440 --> 14:27.440
看一下全局安装了

14:27.440 --> 14:28.440
什么东西

14:28.440 --> 14:29.440
当然他这里打印出了

14:29.440 --> 14:30.440
一代太多了

14:30.440 --> 14:31.440
我们这样吧

14:31.440 --> 14:32.440
NPM

14:32.440 --> 14:33.440
List

14:33.440 --> 14:35.440
Ls

14:35.440 --> 14:36.440
这里HungerG

14:36.440 --> 14:37.440
Ls

14:37.440 --> 14:39.440
Jesse

14:39.440 --> 14:41.440
不是

14:41.440 --> 14:43.440
Debs

14:43.440 --> 14:46.520
你

14:46.520 --> 14:47.520
我们只打印一个

14:47.520 --> 14:48.520
是不是安装一个NPM

14:48.520 --> 14:49.520
对吧

14:49.520 --> 14:50.520
我们总的总规

14:50.520 --> 14:51.520
我们要用一个命令

14:51.520 --> 14:52.520
去查看一下

14:52.520 --> 14:53.520
那么查看过后

14:53.520 --> 14:54.520
比如说我们这里安装了

14:54.520 --> 14:55.520
全局安装了10个包

14:55.520 --> 14:56.520
那么另一台计算机

14:56.520 --> 14:58.520
是不是得用NPM

14:58.520 --> 14:59.520
Install全局

14:59.520 --> 15:00.520
一个个去安装

15:00.520 --> 15:01.520
安装10个包

15:01.520 --> 15:02.520
是不是得这样做

15:02.520 --> 15:03.520
而且要保证

15:03.520 --> 15:04.520
版本号一致

15:04.520 --> 15:05.520
要还原吧

15:05.520 --> 15:06.520
版本号得一致

15:06.520 --> 15:08.520
那么对针对这个点

15:08.520 --> 15:10.520
其实压这里

15:10.520 --> 15:11.520
它就进行了处理

15:11.520 --> 15:12.520
它怎么办的

15:12.520 --> 15:13.520
它就做的事情很简单

15:13.520 --> 15:15.520
它就在全局安装的目录里边

15:15.520 --> 15:16.520
就比方说

15:16.520 --> 15:18.520
比方说这是压的全局安装目录

15:18.520 --> 15:19.520
它这不是

15:19.520 --> 15:20.520
那么比方说吧

15:20.520 --> 15:22.520
这是压全局安装的目录

15:22.520 --> 15:24.520
那么它就在全局安装目录里边

15:24.520 --> 15:25.520
做了一件什么事呢

15:25.520 --> 15:26.520
它就在这里建立了

15:26.520 --> 15:28.520
一个Package.json文件

15:28.520 --> 15:29.520
它就在这里建立了

15:29.520 --> 15:31.520
一个Package.json

15:31.520 --> 15:33.520
这么一个文件

15:33.520 --> 15:34.520
那么

15:34.520 --> 15:35.520
当时候你

15:35.520 --> 15:36.520
一直到别的计算机的时候

15:36.520 --> 15:38.520
你只需要把这个文件考过去

15:38.520 --> 15:39.520
那么这个文件里边

15:39.520 --> 15:41.520
就记录了全局目录下面

15:41.520 --> 15:42.520
你安装了哪些东西

15:42.520 --> 15:43.520
那么

15:43.520 --> 15:44.520
你是不是在那边

15:44.520 --> 15:45.520
直接用一个Install

15:45.520 --> 15:46.520
就可以全部安装起来了

15:46.520 --> 15:47.520
对不对

15:47.520 --> 15:48.520
它就把全局的安装目录

15:48.520 --> 15:50.520
当成一个普通的目录来进行处理

15:50.520 --> 15:53.520
它就做了这么一个箭强暴的事

15:53.520 --> 15:54.520
OK

15:54.520 --> 15:55.520
这是关于压

15:55.520 --> 15:57.520
它做的一些额外的优化

15:57.520 --> 15:58.520
然后压的出现了

15:58.520 --> 16:00.520
它给NPM就带来了巨大的压力

16:00.520 --> 16:01.520
你想

16:01.520 --> 16:02.520
它这么多好处

16:02.520 --> 16:03.520
所以说

16:03.520 --> 16:05.520
就是看到过压的威力的

16:05.520 --> 16:06.520
开发者

16:06.520 --> 16:08.520
他一定是转去使用压了

16:08.520 --> 16:10.520
不再使用NPM了

16:10.520 --> 16:11.520
因此NPM

16:11.520 --> 16:14.520
他就市场就不断的萎缩

16:14.520 --> 16:16.520
所以说他要挽回这个市场了

16:16.520 --> 16:18.520
他就必须要更新

16:18.520 --> 16:19.520
接下来压出现过后了

16:19.520 --> 16:22.520
NPM就开始迅速的学习压里边的先进理念

16:22.520 --> 16:24.520
不断的对支撑进行优化

16:24.520 --> 16:25.520
那么目前

16:25.520 --> 16:27.520
我们到了NPM6这个版本

16:27.520 --> 16:29.520
它就几乎解决了

16:29.520 --> 16:30.520
上面的全部问题了

16:30.520 --> 16:31.520
它怎么解决的

16:31.520 --> 16:32.520
我们现在都能看到了

16:32.520 --> 16:33.520
对吧

16:33.520 --> 16:34.520
我们现在就用的就是

16:34.520 --> 16:35.520
版本就是6.9

16:35.520 --> 16:37.520
NPM8.0

16:37.520 --> 16:38.520
还有版本

16:38.520 --> 16:41.520
我们版本用的就是6.13.4

16:41.520 --> 16:42.520
对吧

16:42.520 --> 16:43.520
那么在这个版本里面

16:43.520 --> 16:45.520
就是第一个目录扁平化

16:45.520 --> 16:46.520
我们的所有的就是

16:46.520 --> 16:47.520
漏的Marchus目录下面

16:47.520 --> 16:48.520
全部扁平化

16:48.520 --> 16:49.520
不管你的依赖是什么

16:49.520 --> 16:51.520
我们之前安装的漏的Marchus

16:51.520 --> 16:52.520
全部把扁平化

16:52.520 --> 16:54.520
那依赖也把它放到

16:54.520 --> 16:56.520
漏的Marchus跟目录下面去

16:56.520 --> 16:57.520
除非出现版本的冲突

16:57.520 --> 16:59.520
否则的话都是扁平化管理

16:59.520 --> 17:00.520
然后下载的时候

17:00.520 --> 17:02.520
自然而然就可以进行并行下载了

17:02.520 --> 17:05.520
所以现在的NPM下载速度已经很快了

17:05.520 --> 17:08.520
然后使用本地的缓存

17:08.520 --> 17:10.520
因为NPM它是有本地缓存的

17:10.520 --> 17:12.520
我们之前看这

17:12.520 --> 17:14.520
在哪呢

17:14.520 --> 17:17.520
我们看一下在哪

17:17.520 --> 17:19.520
就在这NPM开启

17:19.520 --> 17:20.520
就在这个目录

17:20.520 --> 17:22.520
这个目录就是它的缓存目录

17:22.520 --> 17:23.520
缓存目录

17:23.520 --> 17:24.520
它里边记录了

17:24.520 --> 17:25.520
就是已经下载过的

17:25.520 --> 17:27.520
包的里边的数据都在这里边

17:27.520 --> 17:29.520
如果有一天比方说缓存出问题了

17:29.520 --> 17:31.520
你要清空缓存

17:31.520 --> 17:33.520
清空缓存你使用这个命令

17:33.520 --> 17:35.520
开启

17:35.520 --> 17:36.520
开启

17:36.520 --> 17:37.520
Clean

17:37.520 --> 17:39.520
使用这个命令和清空缓存

17:39.520 --> 17:41.520
如果说你下载包的时候

17:41.520 --> 17:42.520
已经下载过了

17:42.520 --> 17:44.520
OK 它就会从缓存里边去找

17:44.520 --> 17:45.520
明白的意思吗

17:45.520 --> 17:47.520
OK 它使用了本地缓存了

17:47.520 --> 17:49.520
这都是从压里边学习过来的

17:49.520 --> 17:51.520
然后它又学习了压里边的

17:51.520 --> 17:52.520
压LOCK

17:52.520 --> 17:54.520
进行锁加锁

17:54.520 --> 17:56.520
就是把已经安装过的包

17:56.520 --> 17:59.520
它的确切版本给它锁住

17:59.520 --> 18:00.520
然后还原的时候

18:00.520 --> 18:02.520
就可以还原到确切版本了

18:02.520 --> 18:04.520
它就使用Package的LOCK

18:04.520 --> 18:06.520
很刚LOCK进行加锁

18:06.520 --> 18:08.520
记录确切的依赖

18:08.520 --> 18:11.520
然后针对它的有些命令

18:11.520 --> 18:12.520
不是那么

18:12.520 --> 18:14.520
名字不是取得那么好

18:14.520 --> 18:16.520
比方说像什么

18:16.520 --> 18:18.520
Install命令

18:18.520 --> 18:19.520
像什么就是删除命令

18:19.520 --> 18:21.520
Delete命令等等

18:21.520 --> 18:23.520
它就针对了大量的命令别名

18:23.520 --> 18:24.520
你可以用这个名字

18:24.520 --> 18:25.520
也可以用另外一个名字

18:25.520 --> 18:26.520
就解决了这个

18:26.520 --> 18:28.520
命令本身不友好的问题

18:28.520 --> 18:30.520
然后它又内置了

18:30.520 --> 18:31.520
现在安装了压之后

18:31.520 --> 18:33.520
还有内置的NPX

18:33.520 --> 18:34.520
我们这些都介绍过

18:34.520 --> 18:35.520
那么通过它

18:35.520 --> 18:37.520
就可以非常方便的来启动

18:37.520 --> 18:40.520
本地安装的命令行工具

18:40.520 --> 18:42.520
然后现在它极大了

18:42.520 --> 18:43.520
减化了控制台的输出

18:43.520 --> 18:45.520
大家应该能感受到

18:45.520 --> 18:46.520
它没有输出多少

18:46.520 --> 18:47.520
就给你告诉一个种数

18:47.520 --> 18:48.520
一个汇总的信息

18:48.520 --> 18:50.520
它没有给你像以前那样子

18:50.520 --> 18:51.520
把一个包一个包的信息

18:51.520 --> 18:52.520
全部给你输出了

18:52.520 --> 18:53.520
所以说

18:53.520 --> 18:55.520
当NPM6之后

18:55.520 --> 18:56.520
我们最后做总结

18:56.520 --> 18:57.520
NPM6之后

18:57.520 --> 18:59.520
可以说NPM和压已经非常接近了

18:59.520 --> 19:00.520
甚至都没有什么差距了

19:00.520 --> 19:01.520
这差不多了

19:01.520 --> 19:03.520
你用NPM可以

19:03.520 --> 19:04.520
用AR也可以

19:04.520 --> 19:06.520
而且说很多新的项目

19:06.520 --> 19:08.520
它又重新回归到NPM了

19:08.520 --> 19:10.520
又不再使用压了

19:10.520 --> 19:12.520
毕竟压是

19:12.520 --> 19:14.520
官方的东西

19:14.520 --> 19:16.520
毕竟它也不算是官方吧

19:16.520 --> 19:18.520
毕竟是鼻祖

19:18.520 --> 19:20.520
毕竟压它也是利用的是

19:20.520 --> 19:22.520
NPM的库

19:22.520 --> 19:24.520
就是瑞基斯锤

19:24.520 --> 19:25.520
所以说

19:25.520 --> 19:26.520
很多又回到了压了

19:26.520 --> 19:28.520
又回到了NPM

19:28.520 --> 19:30.520
但是压现在学不学呢

19:30.520 --> 19:31.520
还是得学

19:31.520 --> 19:33.520
因为可能有些公司

19:33.520 --> 19:35.520
现在这个情况就说不好了

19:35.520 --> 19:37.520
录使谁手

19:37.520 --> 19:39.520
到时候过了几年

19:39.520 --> 19:41.520
到底是压又出了一些新东西

19:41.520 --> 19:42.520
又战成了NPM

19:42.520 --> 19:43.520
还是NPM

19:43.520 --> 19:45.520
就逐渐回归了主流市场

19:45.520 --> 19:47.520
然后压了就逐渐退出了

19:47.520 --> 19:49.520
还是后面就两个了

19:49.520 --> 19:50.520
就合而为一

19:50.520 --> 19:51.520
干脆怎么合而算了

19:51.520 --> 19:53.520
然后或者是两个

19:53.520 --> 19:55.520
就平分天下说不好

19:55.520 --> 19:57.520
所以现在形势

19:57.520 --> 19:58.520
还不是很明确

19:58.520 --> 20:00.520
因此我们还是得学习压

20:00.520 --> 20:02.520
而且学习的过程也非常轻松

20:02.520 --> 20:04.520
要不了多少时间

20:04.520 --> 20:05.520
你花几个小时时间

20:05.520 --> 20:06.520
把这几个节课一看

20:06.520 --> 20:07.520
就没了

20:07.520 --> 20:08.520
压的东西很简单

20:08.520 --> 20:09.520
甚至还花不了几个小时

20:09.520 --> 20:10.520
所以说呢

20:10.520 --> 20:11.520
大家还是得学习压

20:11.520 --> 20:12.520
保不清你们

20:12.520 --> 20:13.520
以后到了一些公司里边

20:13.520 --> 20:15.520
他还是可能习惯上使用的是压

20:15.520 --> 20:17.520
或者是几年前的项目

20:17.520 --> 20:19.520
他1898都用的是压

20:19.520 --> 20:20.520
由于这两个包管理型的

20:20.520 --> 20:21.520
都是目前的主流

20:21.520 --> 20:22.520
所以必须要学习

20:22.520 --> 20:23.520
因此我们这门客

20:23.520 --> 20:25.520
终点就是学习一个NPM

20:25.520 --> 20:26.520
最重要的NPM

20:26.520 --> 20:27.520
然后再学习压

20:27.520 --> 20:29.520
因为压很多东西

20:29.520 --> 20:31.520
都是参考了NPM

20:31.520 --> 20:32.520
只不过对它进行了

20:32.520 --> 20:33.520
很多优化而已

20:33.520 --> 20:34.520
所以说NPM

20:34.520 --> 20:35.520
很多知识在压里面

20:35.520 --> 20:36.520
都可以使用

20:36.520 --> 20:37.520
主要就是学习这两个

20:37.520 --> 20:38.520
其他的保管理型

20:38.520 --> 20:39.520
我们下一张

20:39.520 --> 20:41.520
稍微介绍一下就行了

20:41.520 --> 20:42.520
好吧

20:42.520 --> 20:44.520
OK 这就是关于压

20:44.520 --> 20:45.520
是什么东西

20:45.520 --> 20:46.520
它为什么来的

20:46.520 --> 20:47.520
它怎么来的

20:47.520 --> 20:48.520
以及它解决什么问题

20:48.520 --> 20:51.520
以及它的安装和下载

20:51.520 --> 20:52.520
那么下一个开始

20:52.520 --> 20:53.520
我们就开始具体的介绍

20:53.520 --> 20:55.520
压里边的命令

