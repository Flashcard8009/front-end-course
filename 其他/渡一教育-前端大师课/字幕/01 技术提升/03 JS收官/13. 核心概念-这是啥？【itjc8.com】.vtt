WEBVTT

00:00.430 --> 00:04.430
我们这一课来聊一个非常有趣的话题

00:04.430 --> 00:08.430
叫 这是啥 注意它的俄话音

00:08.430 --> 00:10.430
它叫做 这

00:11.430 --> 00:14.430
咱们生活中经常说这个词 这

00:14.430 --> 00:16.430
但是这个词呢

00:16.430 --> 00:18.430
它在不同的语境下边

00:18.430 --> 00:20.430
它表达的意识不一样

00:20.430 --> 00:23.430
表达下边有一些图 指人现场

00:23.430 --> 00:26.430
这就指在这个框框

00:26.430 --> 00:28.430
这就指在这个自行车

00:28.430 --> 00:30.430
这呢 指在这个台间

00:30.430 --> 00:32.430
这呢 指在这个

00:32.430 --> 00:34.430
这是什么 糖粉

00:34.430 --> 00:38.430
我们这个词啊 是同一个词

00:38.430 --> 00:40.430
但是呢 在不同的环境里边呢

00:40.430 --> 00:42.430
它的含义是不一样的

00:42.430 --> 00:45.430
生活中其实有很多这种现象啊

00:45.430 --> 00:47.430
我们的程序里边呢 其实也有这个现象

00:47.430 --> 00:51.430
我们在程序里边呢

00:51.430 --> 00:54.430
这就指的是this

00:54.430 --> 00:56.430
那么this的含义就是这

00:57.430 --> 01:01.430
这个东西 比方说我们之前写那个

01:01.430 --> 01:03.430
写勾到含书

01:03.430 --> 01:05.430
对吧 比方说一个u字 勾到含书

01:05.430 --> 01:08.430
我们在u里边呢 有一个什么name

01:08.430 --> 01:11.430
啊 我们这 比方说这怎么写呢

01:11.430 --> 01:15.430
这个东西的名字等于这个

01:15.430 --> 01:18.430
这个东西的 age 等于这个

01:18.430 --> 01:21.430
对吧 那么这就是this

01:21.430 --> 01:22.430
我们程序里边

01:22.430 --> 01:24.430
this 它到底指向谁

01:24.430 --> 01:26.430
到底是什么东西

01:26.430 --> 01:28.430
这是我们这节课要研究的话题

01:28.430 --> 01:30.430
其实呢 它并不复杂

01:30.430 --> 01:32.430
技术关键点就行了

01:32.430 --> 01:34.430
只有两种情况 在GS里边

01:34.430 --> 01:37.430
this 关键字 它只有两种情况

01:37.430 --> 01:39.430
第一种情况是

01:39.430 --> 01:43.430
如果说你在全局代码中使用this

01:43.430 --> 01:45.430
它只带的是全局对象

01:45.430 --> 01:47.430
这一块呢 漏的环境有点不同

01:47.430 --> 01:50.430
所以我们直接在浏览器环境里边来看

01:50.430 --> 01:53.430
到浏览器环境里边

01:54.430 --> 01:58.450
我弄下来啊

01:58.450 --> 02:00.450
我们在这里 这是不是全局代码

02:00.450 --> 02:02.450
当然是全局代码对吧

02:02.450 --> 02:04.450
全局代码里边我们使用this

02:04.450 --> 02:07.450
你会发现它指向的是window

02:07.450 --> 02:09.450
这个没什么好说的 非常简单

02:09.450 --> 02:12.450
就在全局代码里边使用this

02:12.450 --> 02:15.450
它只带的就是全局对象window

02:15.450 --> 02:16.450
只不过呢 这一点呢

02:16.450 --> 02:17.450
我们知道就行了

02:17.450 --> 02:19.450
因为我们在真实的开发里边

02:19.450 --> 02:22.450
基本上不会在全局代码里边

02:22.450 --> 02:24.450
去使用this 不会去这样做

02:24.450 --> 02:27.450
因为我们要访问window的话

02:27.450 --> 02:29.450
直接使用window就行了

02:29.450 --> 02:30.450
没有必要使用this

02:30.450 --> 02:33.450
所以说我们这一点呢 知道就行了

02:33.450 --> 02:35.450
终点是第二点

02:35.450 --> 02:37.450
第二点指的是在函数里边

02:37.450 --> 02:39.450
因为我们只有两种作用预

02:39.450 --> 02:40.450
一个是全局 一个是函数

02:40.450 --> 02:41.450
全局里边this呢

02:41.450 --> 02:43.450
就只带的是全局对象

02:43.450 --> 02:45.450
那么在函数里边this

02:45.450 --> 02:49.450
它的指向 它取决于不同的情况

02:49.450 --> 02:50.450
它取决于什么呢

02:50.450 --> 02:53.450
是如何被调用的这个函数

02:54.450 --> 02:57.450
记住了啊 这个要牢牢的记住

02:57.450 --> 02:59.450
函数里边的this

02:59.450 --> 03:01.450
它到底只带的是谁

03:01.450 --> 03:04.450
取决于如何被调用

03:04.450 --> 03:07.450
因此呢 你在写这个函数的时候

03:07.450 --> 03:11.450
那我请问你这个this指向谁

03:11.450 --> 03:12.450
这个this指向谁啊

03:12.450 --> 03:13.450
有些同学说

03:13.450 --> 03:15.450
它指向的是一个新的对象

03:15.450 --> 03:16.450
对吧 我们之前原浪师说了

03:16.450 --> 03:18.450
这里的this呢 相当于是

03:18.450 --> 03:19.450
this不能复职啊

03:19.450 --> 03:21.450
这个是伟代嘛

03:21.450 --> 03:22.450
只是让你们好理解

03:22.450 --> 03:24.450
它只带的是一个新的对象

03:24.450 --> 03:27.450
实际上真实的情况下

03:27.450 --> 03:29.450
你在写这个函数的时候

03:29.450 --> 03:32.450
它this指向谁 我不知道

03:32.450 --> 03:33.450
我不知道了

03:33.450 --> 03:35.450
它有可能指向任何东西

03:35.450 --> 03:37.450
我并不知道这个this指向谁

03:37.450 --> 03:39.450
那什么时候我才知道

03:39.450 --> 03:40.450
这个this指向谁呢

03:40.450 --> 03:43.450
只有这个函数在调用的时候

03:43.450 --> 03:45.450
对吧 只有这个人

03:45.450 --> 03:47.450
只有这个人来到这个地方

03:47.450 --> 03:50.450
用手指了一下 就是函数调用

03:50.450 --> 03:52.450
他才知道指向谁

03:52.450 --> 03:53.450
只不过呢

03:53.450 --> 03:55.450
我们有的很多时候写函数啊

03:55.450 --> 03:56.450
我写了这个函数

03:56.450 --> 04:00.450
我就希望 我希望你不要乱来

04:00.450 --> 04:01.450
你应该怎么来调用呢

04:01.450 --> 04:02.450
比方这是个构造函数

04:02.450 --> 04:04.450
我希望你这样调用

04:04.450 --> 04:05.450
对吧 所以说

04:05.450 --> 04:06.450
绝大部分时候

04:06.450 --> 04:09.450
这个this的指向是不出问题的

04:09.450 --> 04:11.450
就是因为我写这个函数

04:11.450 --> 04:13.450
我就希望你这样来调用

04:13.450 --> 04:15.450
但是万一别人不听话怎么办

04:15.450 --> 04:16.450
他要万调用怎么办

04:16.450 --> 04:17.450
那这个this指向

04:17.450 --> 04:19.450
那要出问题了

04:19.450 --> 04:20.450
this就要出问题了

04:20.450 --> 04:21.450
比方这里呢

04:21.450 --> 04:23.450
我们就直接打应this

04:23.450 --> 04:25.450
他就要出问题

04:25.450 --> 04:26.450
比方这里指向了谁呢

04:26.450 --> 04:27.450
指向了

04:27.450 --> 04:28.450
我们不应该在这

04:28.450 --> 04:33.870
应该在浏览器里面

04:34.870 --> 04:36.870
你用这个1.js

04:36.870 --> 04:43.420
运行出来

04:43.420 --> 04:45.420
你看 是不是只在了Windows了

04:45.420 --> 04:46.420
他指向就变了

04:46.420 --> 04:47.420
他就不再是一个新的对象了

04:47.420 --> 04:48.420
然后来换一下

04:48.420 --> 04:51.420
我又暂时用6的方式来调用

04:51.420 --> 04:53.420
它又变成一个空对象了

04:53.420 --> 04:54.420
所以说

04:54.420 --> 04:55.420
这个this指向谁啊

04:55.420 --> 04:57.420
他完全取决于

04:57.420 --> 04:59.420
如何调用函数

04:59.420 --> 05:00.420
这个观念啊

05:00.420 --> 05:02.420
一定要纠正过来

05:02.420 --> 05:03.420
在介石里面

05:03.420 --> 05:06.420
他不是说你写函数的时候

05:06.420 --> 05:08.420
这个this他就知道指向谁了

05:08.420 --> 05:09.420
不知道的

05:09.420 --> 05:10.420
他只有在运行的时候

05:10.420 --> 05:12.420
才知道这个this指向谁

05:12.420 --> 05:13.420
那么运行就是调用

05:13.420 --> 05:14.420
对吧

05:14.420 --> 05:16.420
我们来看一下有哪些情况

05:16.420 --> 05:18.420
他会导致this的指向不一样

05:18.420 --> 05:20.420
第一种方式

05:20.420 --> 05:21.420
一个函数

05:21.420 --> 05:23.420
如果说通过6来调用的话

05:23.420 --> 05:25.420
比方说6的一个函数

05:25.420 --> 05:26.420
这种方式来调用的话

05:26.420 --> 05:27.420
那么this is

05:27.420 --> 05:29.420
他就是只带着新对象

05:29.420 --> 05:30.420
他就相当于是

05:30.420 --> 05:32.420
第一句话给你写了这么一个东西

05:32.420 --> 05:34.420
this的一个空对象

05:34.420 --> 05:35.420
懂了意思吧

05:35.420 --> 05:36.420
所以说任何一个函数

05:36.420 --> 05:38.420
不管你这个手这么有没有大型

05:38.420 --> 05:39.420
任何一个函数

05:39.420 --> 05:41.420
你只要通过6的方式来调用

05:41.420 --> 05:43.420
他的this就指向新对象

05:43.420 --> 05:44.420
你看着

05:44.420 --> 05:45.420
就指向新对象

05:45.420 --> 05:46.420
对吧

05:46.420 --> 05:47.420
这第一种情况

05:47.420 --> 05:49.420
这是我们之前讲的构造函数

05:49.420 --> 05:50.420
说过的

05:50.420 --> 05:52.420
非常简单

05:52.420 --> 05:54.420
第二种情况

05:54.420 --> 05:56.420
如果说的是直接调用

05:56.420 --> 05:57.420
就写个函数名

05:57.420 --> 05:58.420
然后两个小过号

05:58.420 --> 05:59.420
里边传参数

05:59.420 --> 06:00.420
对吧

06:00.420 --> 06:01.420
直接调用的话

06:01.420 --> 06:02.420
那么里边的this

06:02.420 --> 06:03.420
函数里边

06:03.420 --> 06:04.420
如果说用了this

06:04.420 --> 06:08.420
他就只带的是全举对象

06:08.420 --> 06:11.420
比方说我这里直接调用

06:11.420 --> 06:13.420
你看他这边的this

06:13.420 --> 06:15.420
他只带的就是全举对象

06:15.420 --> 06:16.420
window

06:16.420 --> 06:17.420
看没

06:17.420 --> 06:18.420
只不过这种情况

06:18.420 --> 06:19.420
我们平时写代

06:19.420 --> 06:20.420
如果说

06:20.420 --> 06:21.420
这个函数是被指

06:21.420 --> 06:23.420
将来我希望他是被直接调用的

06:23.420 --> 06:25.420
那我里边基本上是不会使用this的

06:25.420 --> 06:27.420
不会使用的

06:27.420 --> 06:29.420
但是我们要知道

06:29.420 --> 06:31.420
他里边指向的是全举对象

06:31.420 --> 06:33.420
第三种情况

06:33.420 --> 06:36.420
就是通过一个对象去调用

06:36.420 --> 06:37.420
就前面有一个对象

06:37.420 --> 06:39.420
对象里面有一个属性

06:39.420 --> 06:41.420
是一个函数

06:41.420 --> 06:42.420
通过这种方式来调用

06:42.420 --> 06:44.420
这种方式我们是不是写过很多了

06:44.420 --> 06:46.420
像cancel.log

06:46.420 --> 06:47.420
什么意思

06:47.420 --> 06:48.420
前面是一个对象

06:48.420 --> 06:50.420
通过这个对象来调用这个函数

06:50.420 --> 06:51.420
那如果说

06:51.420 --> 06:54.420
这个函数里面使用了this

06:54.420 --> 06:56.420
他指向的谁呢

06:56.420 --> 06:58.420
他指向的就是前边这个对象

06:58.420 --> 07:00.420
懂了意思吧

07:00.420 --> 07:01.420
比方说

07:01.420 --> 07:03.420
我这里有个函数

07:03.420 --> 07:05.420
那我这个函数不是这样写的

07:05.420 --> 07:06.420
我是这样写的

07:06.420 --> 07:07.420
有个ob界

07:07.420 --> 07:08.420
这里边

07:08.420 --> 07:09.420
adv1

07:09.420 --> 07:10.420
b等于2

07:10.420 --> 07:12.420
然后一个method

07:12.420 --> 07:14.420
是一个函数

07:14.420 --> 07:17.420
我们这里输出this

07:17.420 --> 07:19.420
怎么调用这个函数呢

07:19.420 --> 07:22.420
是不是叫ob界的method

07:22.420 --> 07:23.420
来调用

07:23.420 --> 07:25.420
那么这样子一来呢

07:25.420 --> 07:27.420
这个函数里面的this

07:27.420 --> 07:28.420
他就指向的是谁

07:28.420 --> 07:31.420
指向的你前边这个对象

07:31.420 --> 07:32.420
懂了意思吧

07:32.420 --> 07:33.420
你看

07:33.420 --> 07:34.420
是不是指向了这个method

07:34.420 --> 07:36.420
是不是指向那个ob界

07:36.420 --> 07:37.420
指向这个对象

07:37.420 --> 07:39.420
好 那我们再来玩一个

07:39.420 --> 07:41.420
比方说我们这里有个c

07:41.420 --> 07:43.420
c里面又是一个对象

07:43.420 --> 07:45.420
这个对象里面再来一个

07:45.420 --> 07:49.180
m

07:49.180 --> 07:51.180
在这里输出this

07:51.180 --> 07:53.180
好 我要调用这个函数

07:53.180 --> 07:54.180
该怎么调用的

07:54.180 --> 07:55.180
是不是应该这样子写

07:55.180 --> 07:57.180
ob界点c

07:57.180 --> 07:58.180
找到这个对象

07:58.180 --> 08:00.180
这个对象里面有个属性

08:00.180 --> 08:01.180
点m

08:01.180 --> 08:03.180
那么这个m里面的z

08:03.180 --> 08:05.180
这个函数里面的z是指向谁呢

08:05.180 --> 08:06.180
那就看你怎么调用的

08:06.180 --> 08:07.180
你这样调用的

08:07.180 --> 08:09.180
那就指向前边这一坨

08:09.180 --> 08:10.180
前边这一坨是啥

08:10.180 --> 08:12.180
前面这一坨就是这个对象

08:12.180 --> 08:13.180
是吧

08:13.180 --> 08:15.180
因此我这里打印

08:15.180 --> 08:16.180
你看

08:17.180 --> 08:19.180
调用am

08:20.180 --> 08:21.180
保存 刚才没保存

08:21.180 --> 08:23.180
是不是指向这个对象了

08:23.180 --> 08:25.180
是不是指向这个对象了

08:25.180 --> 08:26.180
你看一下

08:27.180 --> 08:28.180
对吧

08:28.180 --> 08:30.180
因此再重生一次

08:31.180 --> 08:33.180
函数里面的z是指向谁

08:33.180 --> 08:36.180
完全取决于他如何调用

08:36.180 --> 08:38.180
那比方说我这里还可以这样子玩

08:38.180 --> 08:39.180
比方说这不是一个函数

08:39.180 --> 08:40.180
对吧

08:40.180 --> 08:41.180
那我能不能把这个函数

08:41.180 --> 08:43.180
保存到另外一个辩量里面的

08:44.180 --> 08:46.180
比方说保存到一个辩量里面

08:46.180 --> 08:49.180
objc.am

08:49.180 --> 08:51.180
所以我这里没有调用函数

08:51.180 --> 08:52.180
没有执行函数

08:52.180 --> 08:53.180
我只是把这个函数

08:53.180 --> 08:56.180
它的值保存到一个辩量里面

08:56.180 --> 08:59.180
那么这句话其实也非常简单

08:59.180 --> 09:01.180
就这里面保存那个函数的地址

09:01.180 --> 09:02.180
把这个地址拿出来

09:02.180 --> 09:04.180
复制粘贴到这个辩量里面

09:04.180 --> 09:06.180
这个辩量也指向这个函数了

09:06.180 --> 09:08.180
那么我们再通过这个test去调用

09:08.180 --> 09:09.180
可不可以

09:09.180 --> 09:10.180
当然可以

09:10.180 --> 09:13.180
那请问这样子它的z是指向谁呢

09:13.180 --> 09:16.180
一定要始终不要去看函数

09:16.180 --> 09:18.180
要看怎么去调用的

09:18.180 --> 09:19.180
这里怎么调用的

09:19.180 --> 09:20.180
就直接调用了

09:20.180 --> 09:21.180
对吧

09:21.180 --> 09:22.180
直接调用它的z是指向谁

09:22.180 --> 09:24.180
是不是指向温度

09:24.180 --> 09:27.180
因此你在写一个函数的时候

09:27.180 --> 09:30.180
你是不知道它的z是会指向谁的

09:30.180 --> 09:31.180
你根本就不知道

09:31.180 --> 09:36.180
它完全取决于如何调用这个函数

09:36.180 --> 09:37.180
这也造成了

09:37.180 --> 09:39.180
在介石里边

09:39.180 --> 09:41.180
在函数里边写z是

09:41.180 --> 09:43.180
心里边总会有些担心

09:43.180 --> 09:44.180
为什么会担心呢

09:44.180 --> 09:45.180
比方说吧

09:45.180 --> 09:46.180
我就这个函数

09:46.180 --> 09:48.180
就这个master的函数

09:48.180 --> 09:49.180
这个函数呢

09:49.180 --> 09:51.180
我肯定希望它怎么调用了

09:51.180 --> 09:55.180
它用obj.master来调用

09:55.180 --> 09:57.180
我肯定希望它这样调用

09:57.180 --> 09:58.180
所以说呢

09:58.180 --> 09:59.180
我希望了这里的z

09:59.180 --> 10:01.180
就只代表是这个顿箱

10:01.180 --> 10:03.180
比方说我对叔叔z.a

10:03.180 --> 10:04.180
z.b

10:04.180 --> 10:05.180
对吧

10:05.180 --> 10:07.180
我希望这样子做

10:07.180 --> 10:09.180
但是呢

10:09.180 --> 10:11.180
如果说那些开发者呢

10:11.180 --> 10:13.180
玩那个骚操作

10:13.180 --> 10:15.180
它可能不这样调用

10:15.180 --> 10:16.180
它要这样来

10:16.180 --> 10:18.180
本来应该是这样调用的对吧

10:18.180 --> 10:19.180
但是它一定要这样子来

10:19.180 --> 10:21.180
给你保存到一个新的函数里边

10:21.180 --> 10:22.180
调用这个新的函数

10:22.180 --> 10:24.180
拉这个z是完蛋了

10:24.180 --> 10:25.180
两个都是undefined的

10:25.180 --> 10:26.180
为什么呢

10:26.180 --> 10:27.180
因为这个z

10:27.180 --> 10:29.180
已经指向的是window了

10:29.180 --> 10:30.180
懂的意思吧

10:30.180 --> 10:31.180
我再重申一次

10:31.180 --> 10:32.180
我把这句话

10:32.180 --> 10:33.180
要反复给你强调

10:33.180 --> 10:35.180
写一个函数的时候

10:35.180 --> 10:37.180
它里边的z指向啥

10:37.180 --> 10:38.180
你是不知道的

10:38.180 --> 10:39.180
你只能说

10:39.180 --> 10:41.180
希望它怎么调用

10:41.180 --> 10:42.180
因此呢

10:42.180 --> 10:44.180
在我们GS开发的过程中啊

10:44.180 --> 10:45.180
我们程序员呢

10:45.180 --> 10:46.180
要自觉

10:46.180 --> 10:48.180
只能靠程序员自觉

10:48.180 --> 10:50.180
你不要乱来

10:50.180 --> 10:51.180
像这个函数

10:51.180 --> 10:52.180
按理说

10:52.180 --> 10:54.180
就应该是ob界点

10:54.180 --> 10:55.180
对吧

10:55.180 --> 10:56.180
你就不要把它拿出来

10:56.180 --> 10:57.180
保存一下再去调用

10:57.180 --> 10:59.180
你不要乱来

10:59.180 --> 11:01.180
但是有的时候呢

11:01.180 --> 11:03.180
我们可能会玩一些稍操作

11:03.180 --> 11:04.180
可能会改变

11:04.180 --> 11:06.180
但是绝大部分时候

11:06.180 --> 11:08.180
我们都不要去乱来

11:08.180 --> 11:11.180
不要去随意的去乱调用函数

11:11.180 --> 11:12.180
这样子的

11:12.180 --> 11:15.180
会导致它的z指向发生变化

11:15.180 --> 11:16.180
确实没办法

11:16.180 --> 11:18.180
它就是争为一个特点

11:18.180 --> 11:20.180
这是前三种情况

11:20.180 --> 11:21.180
是我们开发当中

11:21.180 --> 11:23.180
绝大部分的情况

11:23.180 --> 11:25.180
就是前三种new

11:25.180 --> 11:26.180
直接调用

11:26.180 --> 11:29.180
然后通过一个对象调用

11:29.180 --> 11:32.180
其实后面还有两种情况

11:32.180 --> 11:34.180
它可以手动的

11:34.180 --> 11:35.180
在调用的时候

11:35.180 --> 11:37.180
手动的指定z

11:37.180 --> 11:38.180
一个叫core

11:38.180 --> 11:39.180
一个叫erplein

11:39.180 --> 11:41.180
这两种情况我给大家说一下

11:41.180 --> 11:45.180
比方说我这里有一个函数

11:45.180 --> 11:48.180
这个函数我们这里输出z

11:48.180 --> 11:53.810
请问z指向谁

11:53.810 --> 11:54.810
指向谁

11:54.810 --> 11:55.810
又来了

11:55.810 --> 11:56.810
指向window

11:56.810 --> 11:58.810
我再重生一次

11:58.810 --> 12:00.810
函数里面你写函数的时候

12:00.810 --> 12:02.810
声明的时候

12:02.810 --> 12:03.810
它里面的z指向谁

12:03.810 --> 12:05.810
根本就不知道

12:05.810 --> 12:06.810
你只能说

12:06.810 --> 12:07.810
你这样子写函数

12:07.810 --> 12:09.810
我希望你

12:09.810 --> 12:11.810
怀着一个美好的愿望

12:11.810 --> 12:13.810
我希望你这样去调用它

12:13.810 --> 12:15.810
那肯定就是指向window了

12:15.810 --> 12:16.810
但是有的时候

12:16.810 --> 12:17.810
你不是这样弄的

12:17.810 --> 12:19.810
比方说我们这里有个ob界

12:19.810 --> 12:21.810
我这里要写个abc

12:21.810 --> 12:22.810
我把amon

12:22.810 --> 12:23.810
保存到abc里面

12:23.810 --> 12:24.810
可不可以

12:24.810 --> 12:26.810
把函数保存到abc里面

12:26.810 --> 12:27.810
然后我ob界abc

12:27.810 --> 12:28.810
那这里的z

12:28.810 --> 12:30.810
它又指向ob界了

12:30.810 --> 12:33.810
这怎么弄

12:33.810 --> 12:35.810
因此你没有办法说

12:35.810 --> 12:36.810
你写函数的时候

12:36.810 --> 12:38.810
你又知道z是指向谁

12:38.810 --> 12:39.810
你不知道的

12:39.810 --> 12:40.810
你只能说你调用的时候

12:40.810 --> 12:41.810
才能知道

12:41.810 --> 12:42.810
好

12:42.810 --> 12:44.810
那这里反复的说

12:44.810 --> 12:45.810
说清楚了

12:45.810 --> 12:46.810
那比方说

12:46.810 --> 12:47.810
我这里有个函数

12:47.810 --> 12:48.810
a和b

12:48.810 --> 12:50.810
那我这里输出z

12:50.810 --> 12:51.810
输出a

12:51.810 --> 12:54.810
输出b

12:54.810 --> 12:55.810
好

12:55.810 --> 12:56.810
我们刚才的三种情况

12:56.810 --> 12:57.810
清楚了

12:57.810 --> 12:58.810
就是这三种情况

12:58.810 --> 13:00.810
通过6的方式

13:00.810 --> 13:01.810
通过直接调用

13:01.810 --> 13:02.810
通过对向的方式来调用

13:02.810 --> 13:03.810
接下来我们来说

13:03.810 --> 13:04.810
下面两种情况

13:04.810 --> 13:05.810
下面两种情况

13:05.810 --> 13:06.810
是这样子的

13:06.810 --> 13:08.810
就是所有的函数

13:08.810 --> 13:09.810
它里面

13:09.810 --> 13:12.810
会有一个方法

13:12.810 --> 13:14.810
函数本身也是对象

13:14.810 --> 13:15.810
我给你函数

13:15.810 --> 13:18.810
加上一个abc等于1

13:18.810 --> 13:20.810
bcd等于2

13:20.810 --> 13:22.810
我们输出一下am

13:22.810 --> 13:24.810
用dir的方式

13:24.810 --> 13:25.810
输出一下am

13:25.810 --> 13:27.810
你会发现它是一个函数

13:27.810 --> 13:28.810
它里面

13:28.810 --> 13:29.810
它除了自己是函数之外

13:29.810 --> 13:30.810
它里面还有两个属性

13:30.810 --> 13:32.810
abc和bcd

13:32.810 --> 13:34.810
函数里面是可以加东西的

13:34.810 --> 13:35.810
可以随便加东西

13:35.810 --> 13:37.810
函数里面怎么能加函数

13:37.810 --> 13:38.810
也可以

13:38.810 --> 13:39.810
比方amdir

13:39.810 --> 13:40.810
abc

13:40.810 --> 13:42.810
它又是一个函数

13:42.810 --> 13:43.810
是可以的

13:43.810 --> 13:44.810
没问题的

13:44.810 --> 13:45.810
函数本质上就是对象

13:45.810 --> 13:46.810
amdirabc

13:46.810 --> 13:48.810
没问题的

13:49.810 --> 13:50.810
是可以的

13:50.810 --> 13:52.810
我们打印一下这个

13:52.810 --> 13:54.810
打印一下这个am

13:54.810 --> 13:56.810
你会发现它本身是一个函数

13:56.810 --> 13:57.810
它可以调用的

13:57.810 --> 13:59.810
它里面还有一个属性

13:59.810 --> 14:00.810
abc

14:00.810 --> 14:01.810
它又是一个函数

14:01.810 --> 14:02.810
所以说

14:02.810 --> 14:03.810
当然你说的是什么意义

14:03.810 --> 14:04.810
没什么意义

14:04.810 --> 14:05.810
我只跟你说这个道理

14:05.810 --> 14:07.810
是不是可以这样调用

14:07.810 --> 14:08.810
那如果说

14:08.810 --> 14:09.810
这样调用abc

14:09.810 --> 14:11.810
里面写这个类似的话

14:11.810 --> 14:12.810
abc里面

14:12.810 --> 14:13.810
就顺便说一下

14:13.810 --> 14:14.810
写这个类似

14:14.810 --> 14:15.810
我们再来复习一下

14:15.810 --> 14:16.810
那这样子调用的话

14:16.810 --> 14:18.810
它类似指向谁

14:18.810 --> 14:20.810
它这一次类似指向谁

14:20.810 --> 14:22.810
是不是指向前面这个am

14:22.810 --> 14:24.810
管它am是啥

14:24.810 --> 14:26.810
就指向这个am

14:26.810 --> 14:29.810
因此再重申一次

14:29.810 --> 14:32.810
就是取决于函数

14:32.810 --> 14:33.810
如何调用的

14:33.810 --> 14:34.810
这一次指向

14:34.810 --> 14:35.810
好

14:35.810 --> 14:36.810
我们现在知道了

14:36.810 --> 14:37.810
函数里面其实也可以

14:37.810 --> 14:38.810
加一些乱七八糟的东西

14:38.810 --> 14:40.810
那么其实

14:40.810 --> 14:41.810
我们每一个函数

14:41.810 --> 14:43.810
它其实给你加了一些东西

14:43.810 --> 14:45.810
加了什么东西呢

14:45.810 --> 14:47.810
里面加了两个函数

14:47.810 --> 14:48.810
一个叫core

14:48.810 --> 14:50.810
一个叫erplay

14:50.810 --> 14:51.810
就是函数

14:51.810 --> 14:53.810
任何函数里只要写了过后

14:53.810 --> 14:54.810
不管你是什么构造函数

14:54.810 --> 14:55.810
因为你写函数的时候

14:55.810 --> 14:56.810
你都不知道

14:56.810 --> 14:57.810
它是不是构造函数

14:57.810 --> 14:58.810
对吧

14:58.810 --> 14:59.810
只用你调用的时候

14:59.810 --> 15:00.810
我才知道

15:00.810 --> 15:01.810
你通过六调用

15:01.810 --> 15:02.810
那我就是个构造函数

15:02.810 --> 15:03.810
你没有通过六调用

15:03.810 --> 15:05.810
我就不是构造函数

15:05.810 --> 15:08.810
完全取决于调用

15:08.810 --> 15:09.810
好

15:09.810 --> 15:10.810
那么现在呢就是

15:10.810 --> 15:11.810
每一个函数

15:11.810 --> 15:13.810
给你加了两个方法

15:13.810 --> 15:15.810
一个叫core

15:15.810 --> 15:16.810
这个玩意有什么用呢

15:16.810 --> 15:17.810
这个玩意就是

15:17.810 --> 15:19.810
调用函数的意思

15:19.810 --> 15:20.810
就是调用函数

15:20.810 --> 15:22.810
只不过这个core

15:22.810 --> 15:23.810
这个玩意

15:23.810 --> 15:25.810
其实它的本质上

15:25.810 --> 15:27.810
就是n

15:27.810 --> 15:28.810
就是这样调用

15:28.810 --> 15:32.810
表示运行实行这个函数core

15:32.810 --> 15:33.810
好

15:33.810 --> 15:35.810
现在我要讨论的是

15:35.810 --> 15:37.810
core这个函数有什么用

15:37.810 --> 15:38.810
它有什么用呢

15:38.810 --> 15:40.810
它可以在调用函数的时候

15:40.810 --> 15:43.810
更改ZS的指向

15:43.810 --> 15:44.810
怎么更改呢

15:44.810 --> 15:46.810
就是第一个函数

15:46.810 --> 15:47.810
好 第一个函数

15:47.810 --> 15:48.810
比方说

15:48.810 --> 15:50.810
它传入一个

15:50.810 --> 15:51.810
比方说

15:51.810 --> 15:52.810
这里传入一个数组

15:52.810 --> 15:55.810
123

15:55.810 --> 15:56.810
这个玩意

15:56.810 --> 15:57.810
现在看上去

15:57.810 --> 15:58.810
好像就没啥用

15:58.810 --> 16:00.810
后边我们会有一些用处

16:00.810 --> 16:02.810
core

16:02.810 --> 16:03.810
好 现在我们把

16:03.810 --> 16:04.810
函数传进去

16:04.810 --> 16:05.810
于是呢干嘛呀

16:05.810 --> 16:08.810
就执行了这个函数

16:08.810 --> 16:09.810
把这个ZS

16:09.810 --> 16:10.810
函数里面的ZS

16:10.810 --> 16:12.810
指向这里传入的

16:12.810 --> 16:13.810
第一个函数

16:13.810 --> 16:14.810
现在我们来

16:14.810 --> 16:15.810
这一句话

16:15.810 --> 16:17.810
我们就在调用函数

16:17.810 --> 16:21.810
让你它里面的ZS

16:21.810 --> 16:23.810
指向AR

16:23.810 --> 16:24.810
那么接下来

16:24.810 --> 16:25.810
我们来看一下

16:25.810 --> 16:26.810
函数的ZS

16:26.810 --> 16:27.810
我们来看

16:27.810 --> 16:28.810
输出的ZS是什么

16:28.810 --> 16:30.810
是不是就是个数组

16:30.810 --> 16:31.810
后边两个OND范

16:31.810 --> 16:32.810
为什么呢

16:32.810 --> 16:33.810
是OND范呢

16:33.810 --> 16:34.810
是因为两个参数没传递

16:34.810 --> 16:35.810
那如果说要传递参数

16:35.810 --> 16:36.810
怎么办啊

16:36.810 --> 16:37.810
我们就这里一是写呗

16:37.810 --> 16:38.810
第一个参数为1

16:38.810 --> 16:40.810
第二个参数为2

16:40.810 --> 16:42.810
好 于是呢就得到了

16:42.810 --> 16:44.810
A等于1 B等于2

16:44.810 --> 16:45.810
说这也是一种

16:45.810 --> 16:47.810
调用函数的方式

16:47.810 --> 16:49.810
通过扩的方式来调用函数

16:49.810 --> 16:51.810
通过这种方式来调用函数

16:51.810 --> 16:52.810
我们可以随意的更改

16:52.810 --> 16:54.810
它ZS的指向

16:54.810 --> 16:56.810
我这里写的是一个数组

16:56.810 --> 16:58.810
那我能不能写个空对象呢

16:58.810 --> 16:59.810
也可以

16:59.810 --> 17:01.810
ZS指向变成空对象

17:01.810 --> 17:03.810
就这么个意思叫做扩

17:03.810 --> 17:05.810
它可以更改ZS的指向

17:05.810 --> 17:07.810
后边我们会有一些用处

17:07.810 --> 17:09.810
那么除了这个之外呢

17:09.810 --> 17:11.810
还有一个东西叫做

17:11.810 --> 17:12.810
除了扩之外

17:12.810 --> 17:13.810
还有一个叫做ERPLAY

17:13.810 --> 17:15.810
它的道理是一样的

17:15.810 --> 17:17.810
也是更改ZS的指向

17:17.810 --> 17:19.810
只不过呢

17:19.810 --> 17:21.810
它的后边的参数的传递方式不一样

17:21.810 --> 17:23.810
扩的话是一次传递

17:23.810 --> 17:24.810
后边的参数对吧

17:24.810 --> 17:25.810
传递给函数

17:25.810 --> 17:27.810
那么ERPLAY呢

17:27.810 --> 17:30.810
它是要用数组的方式来传递参数

17:30.810 --> 17:32.810
对吧 这是第一个参数

17:32.810 --> 17:33.810
这是第二个参数

17:33.810 --> 17:35.810
就是参数的传递方式不一样

17:35.810 --> 17:38.810
效果是完全一样的

17:38.810 --> 17:39.810
你看

17:39.810 --> 17:41.810
得到结果是完全一样的

17:41.810 --> 17:42.810
ZS指向

17:42.810 --> 17:44.810
这个空对象

17:44.810 --> 17:45.810
A是1

17:45.810 --> 17:47.810
B是2

17:47.810 --> 17:49.810
那没

17:49.810 --> 17:50.810
就这么个意思

17:50.810 --> 17:51.810
这是扩和ERPLAY

17:51.810 --> 17:52.810
所以扩和ERPLAY呢

17:52.810 --> 17:54.810
只需要知道一个就行了

17:54.810 --> 17:55.810
你I用哪个就用哪个

17:55.810 --> 17:56.810
一个是

17:56.810 --> 17:58.810
以参数列表的方式

17:58.810 --> 17:59.810
一个一个传递

17:59.810 --> 18:00.810
一个是参数

18:00.810 --> 18:02.810
把它组装成一个对象

18:02.810 --> 18:03.810
组装成一个数组

18:03.810 --> 18:06.810
其他的效果完全一样

18:06.810 --> 18:07.810
好了

18:07.810 --> 18:08.810
这就是我们这几颗讲的东西

18:08.810 --> 18:10.810
ZS指向

18:10.810 --> 18:11.810
ZS指向

18:11.810 --> 18:13.810
完全取决于如何被调用的

18:13.810 --> 18:14.810
因此

18:14.810 --> 18:15.810
你在写函数的时候

18:15.810 --> 18:17.810
你是不知道ZS指向的

18:17.810 --> 18:18.810
你只能说

18:18.810 --> 18:19.810
希望开发到自决

18:19.810 --> 18:20.810
不要乱来

18:20.810 --> 18:21.810
乱来来

18:21.810 --> 18:22.810
我也没办法

18:22.810 --> 18:23.810
因此

18:23.810 --> 18:24.810
如果说

18:24.810 --> 18:26.810
我们函数里面要用到ZS

18:26.810 --> 18:27.810
那你就

18:27.810 --> 18:28.810
老老实实的

18:28.810 --> 18:29.810
该怎么调用就怎么调用

18:29.810 --> 18:30.810
你不要玩超操作

18:30.810 --> 18:31.810
但有的时候

18:31.810 --> 18:33.810
我们需要玩一些超操作

18:33.810 --> 18:35.810
来达到一些特殊的效果

18:35.810 --> 18:36.810
这个效果

18:36.810 --> 18:37.810
我们下节课

18:37.810 --> 18:38.810
就会遇到了

18:38.810 --> 18:39.810
好

18:39.810 --> 18:40.810
我们这节课

18:40.810 --> 18:42.810
讲完了ZS指向之后

18:42.810 --> 18:43.810
我们就把练习题做完

18:43.810 --> 18:44.810
每一节课

18:44.810 --> 18:45.810
我们最终的目标

18:45.810 --> 18:46.810
就是完成练习题

18:46.810 --> 18:47.810
你能够完成练习题

18:47.810 --> 18:48.810
那就OK

18:48.810 --> 18:50.810
地道题

18:50.810 --> 18:51.810
这些练习题

18:51.810 --> 18:53.810
都是袁老师精心设计的

18:53.810 --> 18:54.810
就是我们平时开发里面

18:54.810 --> 18:57.810
经常用到的一些场景

18:57.810 --> 18:58.810
地道题

18:58.810 --> 19:00.810
完成这个C害方法

19:00.810 --> 19:01.810
打印姓名和年龄

19:01.810 --> 19:05.810
就是我这里要输出姓名和年龄

19:05.810 --> 19:06.810
我这里就

19:06.810 --> 19:07.810
不废话了

19:07.810 --> 19:08.810
我就不写一些什么

19:08.810 --> 19:09.810
意思了

19:09.810 --> 19:11.810
我就直接把个名和年龄输出

19:11.810 --> 19:13.810
那能不能这样子写

19:13.810 --> 19:14.810
那肯定不行

19:14.810 --> 19:16.810
那为什么不能这样子写呢

19:16.810 --> 19:17.810
是因为这里

19:17.810 --> 19:18.810
利用的是变量

19:18.810 --> 19:19.810
哪有这个变量

19:19.810 --> 19:21.810
这两个玩意不属性吗

19:21.810 --> 19:22.810
谁的属性

19:22.810 --> 19:24.810
是不是Person的属性

19:24.810 --> 19:25.810
调用函数的时候

19:25.810 --> 19:27.810
我找到变量Person

19:27.810 --> 19:28.810
然后把打印出来

19:28.810 --> 19:29.810
这样子行不行

19:29.810 --> 19:31.810
这样子是可以的

19:31.810 --> 19:33.810
C害

19:33.810 --> 19:34.810
这里有没有用到ZS

19:34.810 --> 19:35.810
没有

19:35.810 --> 19:37.810
没有

19:37.810 --> 19:38.810
可以

19:38.810 --> 19:41.810
但是这样子做的是有隐患的

19:41.810 --> 19:43.810
我们不太会用这种方式来写

19:43.810 --> 19:44.810
为什么呢

19:44.810 --> 19:46.810
为什么会有隐患呢

19:46.810 --> 19:47.810
看着

19:47.810 --> 19:48.810
它隐患在哪

19:48.810 --> 19:51.810
比方说这是一个Person

19:51.810 --> 19:52.810
那有第一个问题

19:52.810 --> 19:54.810
有一天我想改这个变量的名字

19:54.810 --> 19:57.810
我改成了变量Person1

19:57.810 --> 19:59.810
那是不是这里要更改

19:59.810 --> 20:00.810
改的地方太多了

20:00.810 --> 20:01.810
当然这个不是主要问题

20:01.810 --> 20:03.810
我们可以完全点击右键

20:03.810 --> 20:05.810
这里从命名符号

20:05.810 --> 20:06.810
把它改成Person1

20:06.810 --> 20:08.810
它下面的会自动更改

20:08.810 --> 20:10.810
这个玩意不是一个问题

20:10.810 --> 20:12.810
那主要的问题在哪呢

20:12.810 --> 20:14.810
在于这是一个变量

20:14.810 --> 20:17.810
变量的质疑是有可能会变化的

20:17.810 --> 20:18.810
比方说

20:18.810 --> 20:20.810
后面我要做一些事

20:20.810 --> 20:23.810
我想把它变保存到Person2里面

20:23.810 --> 20:25.810
Person1

20:25.810 --> 20:27.810
保存到Person2里面

20:27.810 --> 20:30.810
然后把Person1更改一下

20:30.810 --> 20:31.810
更改成了一个数字

20:31.810 --> 20:33.810
比方说这种情况

20:33.810 --> 20:35.810
因为我知道Person2

20:35.810 --> 20:36.810
是一个对象

20:36.810 --> 20:38.810
因为之前把对象地址取出来

20:38.810 --> 20:39.810
放到Person2里面

20:39.810 --> 20:42.810
现在Person2是不是指向对象了

20:42.810 --> 20:44.810
Person2指向对象了

20:44.810 --> 20:48.810
因此我完全可以使用Person2.sh

20:48.810 --> 20:50.810
那结果就出问题了

20:50.810 --> 20:51.810
是不是爆错了

20:51.810 --> 20:52.810
不是爆错

20:52.810 --> 20:53.810
是undefined的

20:53.810 --> 20:54.810
因为这个数字里面

20:54.810 --> 20:56.810
是没有这两个属性的

20:56.810 --> 20:58.810
是没有name和ag的

20:59.810 --> 21:00.810
所以就出问题了

21:00.810 --> 21:03.810
因此我希望的是什么

21:03.810 --> 21:06.810
我希望的是我是哪一个调用sh

21:06.810 --> 21:08.810
我就打印哪一个

21:08.810 --> 21:10.810
我不管你之前是保存哪个变量

21:10.810 --> 21:11.810
无所谓

21:11.810 --> 21:13.810
我什么时候调用sh

21:13.810 --> 21:15.810
是哪个调用的是Person2调用的

21:15.810 --> 21:17.810
那我就打印Person2的

21:17.810 --> 21:18.810
是Person3调用的

21:18.810 --> 21:19.810
我就打印Person3的

21:19.810 --> 21:21.810
懂了意思吗

21:21.810 --> 21:22.810
那这个应该用什么

21:22.810 --> 21:24.810
最好的就应该用z

21:24.810 --> 21:25.810
所以说以后

21:25.810 --> 21:27.810
我们常见的第1个场景

21:27.810 --> 21:29.810
使用z的第1个场景

21:29.810 --> 21:31.810
就是在一个普通对象里面

21:31.810 --> 21:32.810
我有一个方法

21:32.810 --> 21:33.810
这个方法里面

21:33.810 --> 21:35.810
我要访问对象里面的一些属性

21:35.810 --> 21:37.810
一些其他成员

21:37.810 --> 21:39.810
我们就应该使用z

21:39.810 --> 21:41.810
应该使用z去访问

21:41.810 --> 21:43.810
这样子我们在

21:43.810 --> 21:44.810
到时候用这个方法的时候

21:44.810 --> 21:45.810
一定是通过对象调用的

21:45.810 --> 21:46.810
对吧

21:46.810 --> 21:48.810
当你要说你要说你要这

21:48.810 --> 21:49.810
我要稍操作

21:49.810 --> 21:50.810
我就没办法了

21:50.810 --> 21:51.810
我当然我希望的是

21:51.810 --> 21:52.810
你不要玩这个稍操作

21:52.810 --> 21:53.810
那正常的情况下

21:53.810 --> 21:55.810
是不是z就应该指向的是

21:55.810 --> 21:57.810
当前调用者

21:57.810 --> 21:58.810
谁在调用我

21:58.810 --> 21:59.810
我就指向谁

21:59.810 --> 22:00.810
那Person2在调用他

22:00.810 --> 22:02.810
那我就指向Person2

22:02.810 --> 22:03.810
这样子就避免了

22:03.810 --> 22:04.810
这个问题了

22:04.810 --> 22:05.810
你看现在

22:05.810 --> 22:07.810
我们仍然能打印出Molica17

22:07.810 --> 22:08.810
那如果说没有

22:08.810 --> 22:09.810
变化正常情况下

22:09.810 --> 22:10.810
Person1一点是害

22:10.810 --> 22:11.810
但也没问题

22:11.810 --> 22:13.810
Person1就是对象

22:13.810 --> 22:14.810
Person1是不是对象

22:14.810 --> 22:15.810
那通过对象

22:15.810 --> 22:16.810
再调用这个谁害

22:16.810 --> 22:17.810
那么这个谁害里面的z

22:17.810 --> 22:19.810
是不是就指向对象

22:19.810 --> 22:20.810
这是我们z使用的

22:20.810 --> 22:21.810
第1个场景

22:21.810 --> 22:22.810
当然我这里

22:22.810 --> 22:24.810
不应该去改动这个

22:24.810 --> 22:25.810
年纪题

22:25.810 --> 22:26.810
应该

22:26.810 --> 22:28.810
粘贴出来

22:29.810 --> 22:34.170
讲解

22:34.170 --> 22:35.170
这里应该怎么说说

22:35.170 --> 22:37.170
z点年

22:37.170 --> 22:38.170
z点 age

22:38.170 --> 22:40.170
有时候我问这个Douhouse

22:40.170 --> 22:41.170
这两个参数

22:41.170 --> 22:42.170
第1个参数

22:42.170 --> 22:43.170
第2个参数

22:44.170 --> 22:45.170
就是

22:45.170 --> 22:47.170
Consolog是可以传多个参数的

22:47.170 --> 22:48.170
它是一个函数

22:48.170 --> 22:50.170
它可以传多个参数的

22:50.170 --> 22:51.170
它会一次

22:51.170 --> 22:52.170
在统一行里边

22:52.170 --> 22:53.170
把这些参数

22:53.170 --> 22:54.170
一次打印出来

22:54.170 --> 22:55.170
好

22:55.170 --> 22:56.170
第2个问题

22:56.170 --> 22:58.170
为所有对象

22:58.170 --> 23:00.170
添加方法Print

23:00.170 --> 23:02.170
打印对象的建值队

23:02.170 --> 23:04.170
这是一个综合考察

23:04.170 --> 23:05.170
包括上一节课

23:05.170 --> 23:07.170
上上节课的知识都有

23:07.170 --> 23:08.170
为所有对象

23:08.170 --> 23:10.170
添加方法Print

23:10.170 --> 23:11.170
什么意思呢

23:11.170 --> 23:14.170
就是我任何一个对象

23:14.170 --> 23:16.170
不管对象是啥

23:16.170 --> 23:18.170
B等于2

23:19.170 --> 23:22.170
然后OB接2

23:22.170 --> 23:25.170
A等于A

23:25.170 --> 23:27.170
E等于B

23:27.170 --> 23:29.170
C等于C

23:29.170 --> 23:31.170
这是一个对象

23:31.170 --> 23:32.170
那么这两个对象

23:32.170 --> 23:34.170
它都应该自动拥有一个方法

23:34.170 --> 23:35.170
叫Print

23:35.170 --> 23:37.170
它应该有这么一个方法

23:37.170 --> 23:39.170
OB接2也应该用Print

23:39.170 --> 23:40.170
那么这个怎么做呢

23:40.170 --> 23:41.170
这叫利用我到

23:41.170 --> 23:44.170
我们上一节课的知识

23:44.170 --> 23:45.170
上一节课

23:45.170 --> 23:47.170
我们是不是讲过这么一个

23:47.170 --> 23:49.170
三角形 三角关系

23:49.170 --> 23:50.170
我们说过

23:50.170 --> 23:52.170
这种方式来创建对象

23:52.170 --> 23:54.170
是不是就相当于

23:54.170 --> 23:55.170
是一个什么呀

23:55.170 --> 23:58.170
相当于是一个new object

23:58.170 --> 23:59.170
对吧

23:59.170 --> 24:00.170
是不是这样子

24:00.170 --> 24:02.170
我们上一节课之前说过的

24:02.170 --> 24:03.170
反正反正是说过的

24:03.170 --> 24:04.170
我忘了哪一节课了

24:04.170 --> 24:05.170
反正是说过的

24:05.170 --> 24:07.170
那么既然如此

24:07.170 --> 24:08.170
那我们对象

24:08.170 --> 24:10.170
是不是相当于是在这里的实力

24:10.170 --> 24:11.170
那个Object

24:11.170 --> 24:14.170
是不是相当于是个构造函数

24:14.170 --> 24:16.170
我们要为每一个对象

24:16.170 --> 24:17.170
实力都添加一个方法

24:17.170 --> 24:19.170
是不是把它放到圆形上

24:19.170 --> 24:20.170
就可以了

24:20.170 --> 24:21.170
因此我把Print

24:21.170 --> 24:22.170
方法放到哪呢

24:22.170 --> 24:25.170
是不是放到Object

24:26.170 --> 24:28.170
Prototype

24:28.170 --> 24:29.170
放到这里边去

24:29.170 --> 24:31.170
加一个Print方法

24:31.170 --> 24:33.170
那么加了Print方法之后

24:33.170 --> 24:34.170
它后面在找

24:34.170 --> 24:36.170
通过实力去找Print的时候

24:36.170 --> 24:37.170
它自己没有

24:37.170 --> 24:38.170
自己没有就会从

24:38.170 --> 24:40.170
影视圆形上去找

24:40.170 --> 24:41.170
影视圆形上

24:41.170 --> 24:43.170
是不是就有这个方法了

24:43.170 --> 24:44.170
Print

24:44.170 --> 24:45.170
我们再输出一下

24:45.170 --> 24:46.170
打印

24:47.170 --> 24:48.170
既然它们在运行

24:48.170 --> 24:49.170
看一下这两个方法

24:49.170 --> 24:50.170
是不是真的有

24:50.170 --> 24:52.170
所以运行了两次打印

24:52.170 --> 24:53.170
雕用一次

24:53.170 --> 24:55.170
它输出了一个打印

24:55.170 --> 24:57.170
第二个打印

24:57.170 --> 24:58.170
好

24:58.170 --> 24:59.170
那么现在问题

24:59.170 --> 25:00.170
就在于在这

25:00.170 --> 25:02.170
我要打印出

25:02.170 --> 25:04.170
当前这个对象的兼职队

25:06.170 --> 25:08.170
打印兼职队是很简单的

25:08.170 --> 25:09.170
我们之前学过

25:09.170 --> 25:11.170
用Folding循环

25:11.170 --> 25:12.170
是不是可以

25:12.170 --> 25:14.170
循环某一个对象

25:14.170 --> 25:15.170
然后一次取出

25:15.170 --> 25:17.170
这个对象的每一个键

25:17.170 --> 25:18.170
然后每一个纸

25:18.170 --> 25:19.170
就可以取出来了

25:19.170 --> 25:20.170
一个打印了

25:20.170 --> 25:22.170
关键是这里填啥呢

25:22.170 --> 25:23.170
我要循环哪个对象呢

25:23.170 --> 25:25.170
我要循环OB界1

25:25.170 --> 25:26.170
OB界2呢

25:26.170 --> 25:28.170
到底循环哪一个呢

25:28.170 --> 25:30.170
你循环哪一个都不好使

25:30.170 --> 25:32.170
那将来出来OB界3呢

25:32.170 --> 25:34.170
又可能有无穷无尽的对象

25:34.170 --> 25:35.170
你这么知道对象的名字

25:35.170 --> 25:36.170
是咋了

25:36.170 --> 25:37.170
对象的辩量是咋了

25:37.170 --> 25:38.170
根本就不知道

25:38.170 --> 25:40.170
所以这一块呢

25:40.170 --> 25:42.170
你要灵活处理的看这

25:42.170 --> 25:43.170
我们知道这个函数

25:43.170 --> 25:44.170
应该怎么调用

25:44.170 --> 25:46.170
应该是一个对象

25:46.170 --> 25:47.170
第二Print

25:47.170 --> 25:48.170
对吧

25:48.170 --> 25:49.170
所以说呢

25:49.170 --> 25:51.170
我们希望的是咱

25:51.170 --> 25:54.170
什么对象在调用他

25:54.170 --> 25:56.170
我就打印哪一个对象的

25:56.170 --> 25:59.610
那如果说通过他来

25:59.610 --> 26:00.610
调用Print

26:00.610 --> 26:02.610
是不是这里面的Z

26:02.610 --> 26:03.610
他就会指向他

26:03.610 --> 26:05.610
通过他来调用Print

26:05.610 --> 26:06.610
这里的Z就会指向他

26:06.610 --> 26:08.610
所以说我循环的是咋呀

26:08.610 --> 26:10.610
循环的就是Z

26:10.610 --> 26:12.610
循环的就是Z

26:12.610 --> 26:14.610
我再输出一下key

26:14.610 --> 26:18.940
你看

26:18.940 --> 26:20.940
是不是就出来了

26:20.940 --> 26:22.940
便利这个对象

26:22.940 --> 26:24.940
当然他里边还有一个Print方法

26:24.940 --> 26:26.940
因为它在元性上边

26:26.940 --> 26:27.940
那这个玩意

26:27.940 --> 26:29.940
目前把它想象消除

26:29.940 --> 26:31.940
它还办不到

26:31.940 --> 26:32.940
但是我们现在呢

26:32.940 --> 26:34.940
可以通过这种方式来看到

26:34.940 --> 26:36.940
A B Print

26:36.940 --> 26:38.940
对吧 这是第一个OB接1的

26:38.940 --> 26:40.940
OB接2的ABC Print

26:41.940 --> 26:42.940
对吧

26:42.940 --> 26:44.940
是不是可以看得到了

26:44.940 --> 26:45.940
其实这里呢

26:45.940 --> 26:46.940
我们要不包含Print

26:46.940 --> 26:47.940
也可以

26:47.940 --> 26:48.940
我们要通过一个判断

26:48.940 --> 26:50.940
通过一个判断

26:50.940 --> 26:51.940
通过什么判断呢

26:51.940 --> 26:53.940
就是有OB接个词的一个方法

26:53.940 --> 26:55.940
叫做

26:55.940 --> 26:57.940
Heist

26:57.940 --> 26:59.940
OM

26:59.940 --> 27:01.940
不在这

27:01.940 --> 27:02.940
就是这个

27:02.940 --> 27:03.940
OB接个词

27:03.940 --> 27:04.940
Heist

27:04.940 --> 27:05.940
OM

27:05.940 --> 27:09.900
Property

27:09.900 --> 27:14.100
顺便说一下这个方法吧

27:14.100 --> 27:15.100
我看一下

27:15.100 --> 27:16.100
是不是在这里边

27:16.100 --> 27:17.100
我一点忘了

27:17.100 --> 27:18.100
因为这个方法用的比较少

27:18.100 --> 27:19.100
Heist

27:19.100 --> 27:20.100
OM

27:20.100 --> 27:24.850
Property

27:24.850 --> 27:26.850
不应该是这

27:26.850 --> 27:28.850
那应该是哪呢

27:28.850 --> 27:29.850
是一个对象的上面的

27:29.850 --> 27:30.850
我看一下

27:32.850 --> 27:33.850
好 那就是这

27:33.850 --> 27:34.850
是这样子

27:34.850 --> 27:35.850
我这里就顺便说一下吧

27:35.850 --> 27:37.850
如果说我要去除这个Print

27:38.850 --> 27:39.850
我们先不去除吧

27:39.850 --> 27:40.850
先不去除 打印完了再说

27:40.850 --> 27:42.850
打印完了我们再做个判断就完事了

27:42.850 --> 27:44.850
好 那么现在我打印出来了A和B

27:44.850 --> 27:45.850
对吧 第一个对象的

27:45.850 --> 27:46.850
第二个对象的

27:46.850 --> 27:47.850
对吧 雕了两次

27:47.850 --> 27:48.850
那么就说明第一次

27:48.850 --> 27:50.850
R是指向谁

27:50.850 --> 27:51.850
R是指向的是这个对象

27:51.850 --> 27:52.850
有三个属性

27:52.850 --> 27:53.850
ABC

27:53.850 --> 27:54.850
AB Print

27:54.850 --> 27:56.850
好 第二次

27:56.850 --> 27:57.850
第二次的话

27:57.850 --> 27:59.850
R是指向的是下边这个

28:00.850 --> 28:01.850
对吧

28:01.850 --> 28:03.850
有ABC Print

28:03.850 --> 28:05.850
不管你是谁来调用这个Print

28:05.850 --> 28:07.850
谁来调用我就指向谁

28:07.850 --> 28:08.850
好 那接下来

28:08.850 --> 28:09.850
R是一个对象

28:09.850 --> 28:11.850
你其实你可以打印一下这个R

28:16.340 --> 28:17.340
你看 打印这个R

28:17.340 --> 28:18.340
它是一个对象

28:18.340 --> 28:19.340
看到没

28:19.340 --> 28:20.340
好 那么接下来

28:20.340 --> 28:21.340
我就要是还要输发的值

28:21.340 --> 28:24.340
对吧 除了输出它的属性名之外

28:24.340 --> 28:26.340
还要输出它的值

28:27.340 --> 28:28.340
它的值怎么输出呢

28:28.340 --> 28:29.340
我们之前也学过

28:30.340 --> 28:31.340
这是它的属性名

28:31.340 --> 28:33.340
属性值是否通过这种方式来达到

28:33.340 --> 28:35.340
对象 前面是对象

28:35.340 --> 28:36.340
不管前面对象是啥

28:36.340 --> 28:37.340
反正是个对象

28:37.340 --> 28:39.340
对象里面一个属性

28:39.340 --> 28:41.340
属性的名字来自于这个变量

28:41.340 --> 28:43.340
把这个变量的值作为属性的名字

28:43.340 --> 28:44.340
就可以取出它的值

28:44.340 --> 28:47.340
这样我们来打印一下RT Value

28:50.610 --> 28:51.610
你看 第一个对象

28:51.610 --> 28:52.610
是不是打印出来了

28:52.610 --> 28:53.610
属性名 属性值

28:53.610 --> 28:54.610
属性名 属性值

28:54.610 --> 28:56.610
属性名 属性值

28:56.610 --> 28:57.610
第二个对象

28:57.610 --> 28:58.610
属性名 属性值

28:58.610 --> 28:59.610
属性名 属性值

28:59.610 --> 29:00.610
属性名 属性值

29:01.610 --> 29:03.610
好 我们最后来说一下

29:03.610 --> 29:04.610
这个小问题

29:07.610 --> 29:09.610
这个问题就是我要去除掉

29:09.610 --> 29:11.610
就是我在变异这个对象的时候

29:12.610 --> 29:13.610
因为我们知道A和B

29:13.610 --> 29:15.610
是属于对象本身的

29:15.610 --> 29:16.610
看这张图

29:17.610 --> 29:18.610
就是有些属性比较让A和B

29:18.610 --> 29:19.610
是属于对象本身的

29:20.610 --> 29:21.610
当然还有一些东西

29:21.610 --> 29:23.610
是在它的影视员性上边

29:24.610 --> 29:26.610
我不希望变异出影视员性的东西

29:26.610 --> 29:28.610
我不希望变异这个上面的东西

29:29.610 --> 29:31.610
我只希望变异这上面的东西

29:32.610 --> 29:34.610
那么这个该怎么来做呢

29:35.610 --> 29:37.610
这是一个小的新知识

29:38.610 --> 29:39.610
顺便给大家说了

29:39.610 --> 29:40.610
反正咱们都要说的

29:43.560 --> 29:45.560
比方说我这里有一个

29:45.560 --> 29:47.560
arbitra 给大家加一个圆形

29:48.560 --> 29:50.560
abc 等于1

29:51.560 --> 29:53.560
这里有一个对象

29:54.560 --> 29:55.560
A等于1 B等于2

29:56.560 --> 29:58.560
当我在变异这个对象的时候

30:02.020 --> 30:03.020
abc

30:04.020 --> 30:05.020
输出这个t

30:06.020 --> 30:07.020
当我在变异这个对象的时候

30:07.020 --> 30:09.020
你会发现它除了自己的A和B

30:10.020 --> 30:12.020
它还会变异到它的影视员性

30:12.020 --> 30:13.020
变异到这上面去了

30:14.020 --> 30:16.020
那我希望不要在这上面拿出来

30:16.020 --> 30:18.020
我们这里就需要做个判断

30:18.020 --> 30:19.020
就是我要判断什么呢

30:20.020 --> 30:23.020
判断这个属性

30:25.020 --> 30:29.020
是不是属于对象本身

30:30.020 --> 30:33.020
而不是在影视员性上

30:34.020 --> 30:35.020
就是我要做这个判断

30:35.020 --> 30:38.020
如果说你只是属于对象本身

30:38.020 --> 30:40.020
那我就需要就把答应出来

30:40.020 --> 30:42.020
如果说你在影视员性上

30:42.020 --> 30:43.020
我就不答应

30:44.020 --> 30:45.020
那怎么来判断呢

30:45.020 --> 30:46.020
怎么来判断呢

30:46.020 --> 30:48.020
有一个判断方式

30:49.020 --> 30:51.020
就是通过对象

30:51.020 --> 30:52.020
有一个

30:52.020 --> 30:54.020
自动会有一个函数

30:54.020 --> 30:56.020
叫做 heise

30:56.020 --> 30:58.020
oen property

30:59.020 --> 31:03.020
这里面传的是一个属性的名字

31:03.020 --> 31:04.020
传的是属性名

31:04.020 --> 31:06.020
比方说我传一个A

31:06.020 --> 31:08.020
它判断的是

31:08.020 --> 31:11.020
A这个属性再不在obj

31:11.020 --> 31:13.020
对象本身上表

31:15.020 --> 31:16.020
懂了意思吧

31:16.020 --> 31:17.020
看A这个属性

31:17.020 --> 31:19.020
再不在对象本身上表

31:19.020 --> 31:21.020
它会返回一个 true or false

31:23.400 --> 31:24.400
我们来看一下

31:24.400 --> 31:25.400
是true

31:25.400 --> 31:27.400
A是在对象本身上表的

31:27.400 --> 31:28.400
heise的意思

31:28.400 --> 31:30.400
有没有oen

31:30.400 --> 31:33.400
自己的 property

31:33.400 --> 31:36.400
这个对象有没有一个自己的属性

31:36.400 --> 31:37.400
A

31:37.400 --> 31:38.400
是不是很好读

31:39.400 --> 31:41.400
那么如果说我传的是abc

31:41.400 --> 31:42.400
我们来看一下

31:43.400 --> 31:44.400
就是 false

31:45.400 --> 31:46.400
因为abc

31:46.400 --> 31:47.400
虽然说这个对象能不能用

31:47.400 --> 31:48.400
能用

31:48.400 --> 31:49.400
它在影视员上面

31:49.400 --> 31:52.400
但它不是属于对象自身的

31:53.400 --> 31:55.400
因此我们这一块

31:55.400 --> 31:56.400
我就可以通过这种判断

31:58.400 --> 31:59.400
obj

31:59.400 --> 32:01.400
heise oen property

32:01.400 --> 32:02.400
这里把什么传进去

32:02.400 --> 32:03.400
把t传进去

32:03.400 --> 32:04.400
对吧

32:05.400 --> 32:07.400
这个属性再不在

32:07.400 --> 32:08.400
这个对象本身上表

32:08.400 --> 32:09.400
如果再的话

32:09.400 --> 32:10.400
我才答应

32:10.400 --> 32:11.400
不再的话

32:11.400 --> 32:12.400
我就不答应

32:12.400 --> 32:13.400
这样答应出来的话

32:13.400 --> 32:14.400
那么只有A和B了

32:15.400 --> 32:17.400
这也是一种常见的

32:17.400 --> 32:19.400
属性变地的方式

32:19.400 --> 32:20.400
在变地属性的时候

32:20.400 --> 32:22.400
我们可能要去除掉

32:22.400 --> 32:24.400
在原性上面的东西

32:24.400 --> 32:26.400
这个点给大家说一下

32:28.400 --> 32:29.400
既然说到这

32:29.400 --> 32:30.400
其实我还可以再说

32:30.400 --> 32:32.400
一个小的知识

32:32.400 --> 32:33.400
再拖展一个小的知识

32:33.400 --> 32:34.400
尽管这个知识

32:34.400 --> 32:36.400
也不是怎么会遇到

32:36.400 --> 32:37.400
但是有的时候

32:37.400 --> 32:38.400
也可能会有用

32:38.400 --> 32:39.400
除了这个方法

32:39.400 --> 32:42.400
可以判断一个属性再不在

32:42.400 --> 32:44.400
对象自身上面

32:44.400 --> 32:45.400
其实我们还有一个

32:46.400 --> 32:47.400
叫做运算符

32:47.400 --> 32:49.400
或者叫做一个新语法

32:49.400 --> 32:51.400
可以判断一个属性

32:51.400 --> 32:53.400
再不在对象上面

32:53.400 --> 32:54.400
什么语法呢

32:55.400 --> 32:56.400
是这样子写的

32:56.400 --> 32:58.400
前边写一个字符串

32:59.400 --> 33:01.400
就属性名

33:02.400 --> 33:03.400
硬

33:03.400 --> 33:05.400
后边是对象

33:05.400 --> 33:06.400
它判断的是什么呢

33:06.400 --> 33:07.400
这个判断的是

33:10.480 --> 33:11.480
这个判断

33:11.480 --> 33:13.980
判断

33:14.980 --> 33:16.980
属性名

33:16.980 --> 33:18.980
是否在对象

33:18.980 --> 33:19.980
自身

33:19.980 --> 33:21.980
极其

33:21.980 --> 33:23.980
连

33:23.980 --> 33:24.980
连形上

33:25.980 --> 33:27.980
影视连形上

33:28.980 --> 33:31.980
除了判断自身之外

33:31.980 --> 33:32.980
还会判断

33:32.980 --> 33:33.980
它再不在影视远形上

33:33.980 --> 33:34.980
举个例子

33:34.980 --> 33:36.980
比方说我判断A

33:36.980 --> 33:37.980
是不是

33:37.980 --> 33:38.980
这属性名吧

33:38.980 --> 33:39.980
前边是属性名

33:39.980 --> 33:40.980
后边是跟对象

33:40.980 --> 33:41.980
我这个判断的是什么呢

33:41.980 --> 33:43.980
判断了A在OBG里面存不存在

33:44.980 --> 33:45.980
存不存在

33:46.980 --> 33:47.980
存在对吧

33:47.980 --> 33:48.980
那时候说判断ABC

33:48.980 --> 33:50.980
是不是在OBG里面存不存在

33:50.980 --> 33:51.980
它也是存在的

33:51.980 --> 33:52.980
为什么呢

33:52.980 --> 33:54.980
因为它虽然在自身里面不存在

33:54.980 --> 33:56.980
但是它的影视远形上是不是有

33:56.980 --> 33:57.980
也就是说

33:57.980 --> 33:58.980
印判断的是什么

33:59.980 --> 34:01.980
判断OBG里面有没有这个东西

34:01.980 --> 34:02.980
有没有这个属性

34:02.980 --> 34:03.980
它是判断这个的

34:05.980 --> 34:06.980
了解一下就行了

34:06.980 --> 34:07.980
这两个是不一样的

34:07.980 --> 34:09.980
一个是判断自身有没有

34:09.980 --> 34:11.980
一个判断它自己有没有

34:11.980 --> 34:13.980
管它是不是自身的

34:13.980 --> 34:15.980
我从爸爸那里继承的也可以

34:18.620 --> 34:20.620
有了这么一点扩展知识之后

34:20.620 --> 34:21.620
我这里要输出

34:22.620 --> 34:23.620
所谓的属性

34:23.620 --> 34:25.620
我要驱除掉远形上边的

34:25.620 --> 34:26.620
那怎么来驱除呢

34:27.620 --> 34:29.990
特别是通过判断

34:30.990 --> 34:32.990
哪个对象Z

34:32.990 --> 34:34.990
这个对象是不是highest own property

34:34.990 --> 34:35.990
是不是有一个属

34:35.990 --> 34:37.990
自己的属性T

34:37.990 --> 34:39.990
如果说是自己的属性T的话

34:39.990 --> 34:40.990
我输出

34:42.990 --> 34:43.990
当然了

34:43.990 --> 34:44.990
这个表达是

34:44.990 --> 34:45.990
你是不是也可以直接放过来

34:45.990 --> 34:49.260
看一下

34:50.260 --> 34:51.260
这样子就清爽一些了

34:52.260 --> 34:53.260
这是第二题

34:54.260 --> 34:55.260
第二题

34:55.260 --> 34:57.260
这也是我们Z使常用的一个地方

34:57.260 --> 34:59.260
就是在远形方法里边

35:00.260 --> 35:02.260
换句话说叫实力方法

35:02.260 --> 35:04.260
通过对象去交融方法叫实力方法

35:04.260 --> 35:06.260
在远形方法或者叫做实力方法里边

35:06.260 --> 35:08.260
我们常常会使用Z使

35:09.260 --> 35:11.260
因为到时候调用这个方法的时候

35:11.260 --> 35:13.260
是通过对象来调用的

35:13.260 --> 35:15.260
它就会指向这个调用的对象

35:17.260 --> 35:18.260
就是现在说两个了

35:18.260 --> 35:20.260
一个是在一个普通对象里边

35:20.260 --> 35:22.260
方法里边我们使用Z使

35:22.260 --> 35:23.260
只带着这个调用者

35:24.260 --> 35:26.260
第二个是在远形方法里边

35:26.260 --> 35:27.260
我们也会使用Z使

35:27.260 --> 35:28.260
你看回忆一下

35:28.260 --> 35:29.260
我们之前写构造函数

35:29.260 --> 35:30.260
是不是在远形体里边

35:30.260 --> 35:32.260
也在远形上面使用了Z使

35:33.260 --> 35:34.260
第三个

35:34.260 --> 35:37.260
第三个就来练一个稍操作

35:37.260 --> 35:38.260
这个操作是有用的

35:38.260 --> 35:39.260
不是说没用的

35:39.260 --> 35:41.260
只是现在还发现不了它的威力

35:41.260 --> 35:43.260
我们下几颗之后

35:44.260 --> 35:46.260
你就会知道它的威力了

35:46.260 --> 35:48.260
就是有这么一个构造函数

35:48.260 --> 35:50.260
现在正常情况下

35:50.260 --> 35:51.260
不应该这样

35:51.260 --> 35:52.260
是不是应该这样调用

35:53.260 --> 35:54.260
传一个

35:55.260 --> 35:56.260
轻

35:56.260 --> 35:57.260
再传一个

35:57.260 --> 35:58.260
鸣

35:58.260 --> 35:59.260
是不是得到一个U字

36:02.260 --> 36:03.260
对吧

36:03.260 --> 36:05.260
说出一个U

36:08.150 --> 36:09.150
是不是得到一个U字

36:09.150 --> 36:10.150
没问题吧

36:10.150 --> 36:13.150
现在我希望的是

36:13.150 --> 36:18.360
不要使用六关键字

36:19.360 --> 36:21.360
能不能利用函数

36:21.360 --> 36:22.360
来创建一个用户

36:22.360 --> 36:24.360
它有三个属性

36:24.360 --> 36:25.360
能不能

36:26.360 --> 36:27.360
可不可以

36:30.440 --> 36:31.440
可以的

36:31.440 --> 36:32.440
怎么弄

36:32.440 --> 36:33.440
不使用

36:33.440 --> 36:34.440
你肯定不能这样子做

36:34.440 --> 36:35.440
你这样子做的话

36:35.440 --> 36:36.440
就会导致什么了

36:36.440 --> 36:38.440
导致Z指向谁

36:38.440 --> 36:39.440
指向了Windows

36:40.440 --> 36:41.440
它把Windows里面

36:41.440 --> 36:42.440
加了三个属性去了

36:42.440 --> 36:43.440
肯定不行

36:43.440 --> 36:44.440
你不要这个带

36:44.440 --> 36:46.440
我在浏览器里面运行

36:51.630 --> 36:53.630
我们来看一下U

36:54.630 --> 36:55.630
U里面啥都没有

36:55.630 --> 36:56.630
因为这个函数没有返回

36:56.630 --> 36:58.630
Return没有返回

36:58.630 --> 37:00.630
U就是undefined

37:00.630 --> 37:01.630
然后我们来看一下

37:01.630 --> 37:02.630
Windows里面

37:03.630 --> 37:05.630
Windows里面多个

37:05.630 --> 37:06.630
肯定不是我们想要的

37:08.630 --> 37:09.630
那怎么办

37:10.630 --> 37:11.630
这个时候

37:11.630 --> 37:13.630
你可以使用这种方式

37:14.630 --> 37:15.630
我给这个U

37:15.630 --> 37:16.630
一个空对象

37:18.630 --> 37:21.630
然后我这样子来调用

37:21.630 --> 37:22.630
User

37:22.630 --> 37:23.630
它不是一个函数吗

37:23.630 --> 37:25.630
函数里面不就一个扩吗

37:25.630 --> 37:27.630
耳拍也可以

37:28.630 --> 37:29.630
我第一个参数

37:29.630 --> 37:30.630
就给它传一个U

37:31.630 --> 37:32.630
就表示让里面的Z

37:32.630 --> 37:33.630
指向这个对象

37:35.630 --> 37:36.630
对吧

37:36.630 --> 37:37.630
是不是指向这个对象

37:37.630 --> 37:38.630
然后运行一遍

37:38.630 --> 37:39.630
当然

37:39.630 --> 37:40.630
后面的参数

37:40.630 --> 37:41.630
有意思传递的

37:44.630 --> 37:45.630
序名

37:49.030 --> 37:50.030
然后我们来看一下

37:50.030 --> 37:51.030
这样子行不行

37:52.030 --> 37:53.030
这样子也可以

37:54.030 --> 37:55.030
这个玩意是有用的

37:56.030 --> 37:57.030
后面还会知道有什么用

37:57.030 --> 37:58.030
当然这种做法

37:58.030 --> 37:59.030
跟刚才的那种做法

37:59.030 --> 38:01.030
是有一些差异的

38:02.030 --> 38:04.030
那么差异具体在哪

38:05.030 --> 38:06.030
这玩意有什么用

38:06.030 --> 38:07.030
我们后面就知道了

38:07.030 --> 38:08.030
但是我们现在的

38:08.030 --> 38:11.030
至少只能够理解

38:11.030 --> 38:12.030
它是有这个属性的

38:12.030 --> 38:13.030
对吧

38:13.030 --> 38:14.030
这是可以理解的

38:14.030 --> 38:15.030
为什么

38:15.030 --> 38:16.030
因为它这个Z

38:16.030 --> 38:17.030
就指向这个东西了

38:17.030 --> 38:18.030
所以说它里面就是Z

38:19.030 --> 38:20.030
这里面玩的Z

38:20.030 --> 38:22.030
就相当于是U了

38:22.030 --> 38:23.030
往U里面加属性

38:23.030 --> 38:24.030
还不简单

38:24.030 --> 38:25.030
对吧

38:25.030 --> 38:26.030
意思夹就完事了

38:27.030 --> 38:28.030
这种方式

38:28.030 --> 38:29.030
也可以帮助我们

38:29.030 --> 38:30.030
创建一个对象

38:31.030 --> 38:32.030
OK 就是三道题

38:32.030 --> 38:34.030
把三道题完成

38:34.030 --> 38:35.030
那么这些课的目标

38:35.030 --> 38:36.030
就达到了

38:37.030 --> 38:38.030
关于Z的指向

