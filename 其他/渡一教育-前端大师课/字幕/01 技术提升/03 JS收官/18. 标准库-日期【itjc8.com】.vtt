WEBVTT

00:00.000 --> 00:04.360
好 我们早些课来聊一聊日期这个话题

00:04.860 --> 00:06.660
日期这一块是这样

00:07.420 --> 00:11.520
标准库里边还给你提供了一些API

00:11.780 --> 00:17.400
不过这些API基本上属于这怎么说呢 属于这种比较粗患

00:17.660 --> 00:19.460
比较搞笑的比较幽默的

00:19.720 --> 00:23.300
因此我们以后在实际的开发中

00:23.800 --> 00:26.880
往往不会去使用真正的日期API

00:27.000 --> 00:31.240
除非我们要用的日期特别简单我们可能就用它的

00:31.740 --> 00:33.020
稍微有一点

00:33.280 --> 00:38.920
复杂的我们都不会去用它的日期API 因为它实在是提供的太少太少了

00:39.180 --> 00:39.940
不实用

00:40.440 --> 00:45.820
有没有用出来肯定是有用准的 也说它能不能解决日期里面的所有问题呢 肯定是能解决

00:46.080 --> 00:46.580
只是

00:46.840 --> 00:47.860
没有那么方便

00:48.120 --> 00:49.160
因此我们将来

00:49.660 --> 00:51.200
对于日期的处理

00:51.720 --> 00:56.580
更加专业的做法是使用一些别人已经写好的API 写好的一些对象

00:56.780 --> 01:00.380
写好的一些函数直接可以用的 将来我会给大家介绍

01:00.880 --> 01:04.460
现在我们肯定要学习一下官方的 毕竟是官方的嘛

01:04.720 --> 01:07.040
就算你们以后学习别人写的

01:07.280 --> 01:09.840
那别人写的还是依托于官方写的给他做出来的

01:10.360 --> 01:11.900
因此我们还是得学习官方的

01:12.660 --> 01:15.980
日期这一块的重点是什么的 重点不是API

01:16.500 --> 01:19.560
所以我这几颗重点不是API所预说的同学们

01:20.600 --> 01:21.360
API

01:21.620 --> 01:23.160
我之前说了它不重要

01:23.680 --> 01:25.200
忘记了就可以查

01:25.660 --> 01:26.740
但是什么东西重要啊

01:27.000 --> 01:28.480
概念是特别重要的

01:28.740 --> 01:30.260
因为概念你查不到啊

01:31.040 --> 01:33.860
你看官方文章里边谁给你说去说概念

01:34.120 --> 01:36.420
他不会给你讲概念 因为他默认你概念都知道

01:36.940 --> 01:39.220
因此呢概念一定要认真听

01:40.260 --> 01:45.120
你先把你的手上的咖啡 茶放下 专注来听这个概念

01:45.640 --> 01:47.420
日期这一块有什么概念呢

01:47.940 --> 01:51.020
我们先来说日期的一些基础知识

01:51.260 --> 01:52.300
首先是单位

01:53.060 --> 01:54.340
就咱们的

01:55.160 --> 01:58.120
时间是有单位的啊 有哪些单位呢

01:59.160 --> 02:01.920
单词hour表示小时

02:02.280 --> 02:05.040
这个不用说了吧 一天等于24小时

02:05.560 --> 02:07.600
minus分钟

02:08.120 --> 02:10.160
这个不用说了吧 second秒

02:10.680 --> 02:13.240
好 后边这两个minus second

02:14.000 --> 02:15.800
我们简写为ms

02:16.320 --> 02:17.600
叫做毫秒

02:17.840 --> 02:21.680
这个毫秒什么意思呢 是一秒钟等于一千毫秒

02:21.960 --> 02:23.480
有这么一个换算关系

02:24.440 --> 02:26.080
还有这个nanosecond

02:26.340 --> 02:27.800
那么这个玩意叫纳秒

02:27.800 --> 02:31.200
纳秒的话在我们程序里边基本上很少很少会使用

02:31.200 --> 02:33.000
一般都是使用到毫秒就可以了

02:33.520 --> 02:37.480
纳秒是一毫秒等于一千纳秒

02:37.800 --> 02:38.840
是这么一个关系

02:39.000 --> 02:41.000
这是关于单位 大家知道了

02:41.680 --> 02:45.280
下面这两个概念 一个是gmt 一个是utc

02:45.480 --> 02:46.560
这个玩意是咋呢

02:46.720 --> 02:51.040
因为我们的世界啊 地球在自转 又在公转

02:51.180 --> 02:56.220
所谓说导致每个地方它的时间是不一样的

02:56.220 --> 02:59.820
因此我们对世界作为时趋来进行划分

02:59.940 --> 03:01.740
这个我不多说了

03:02.260 --> 03:05.460
这是你们初中还是小学 弟弟上就应该学过的

03:05.900 --> 03:07.060
就是一个时趋的划分

03:07.060 --> 03:08.900
你不要去背这些时趋 没有意义

03:08.900 --> 03:10.780
但是你要知道有时趋存在

03:11.340 --> 03:13.180
整个地球有24个时趋

03:13.180 --> 03:17.340
我们的中国 北京 在东巴区

03:18.320 --> 03:20.320
其中有一个时趋比较特殊

03:20.320 --> 03:21.640
就是零时趋

03:21.640 --> 03:23.320
这个时趋比较特殊

03:23.320 --> 03:25.320
这个时趋就是欧洲这一块

03:25.320 --> 03:29.320
这个时趋它会穿过一个东西叫做本处植物线

03:29.320 --> 03:31.320
这个玩意就是本处植物线

03:31.320 --> 03:33.320
那么这个本处植物线呢

03:33.320 --> 03:35.320
它会穿过一个地方

03:35.320 --> 03:37.320
那个地方叫做格林威治

03:38.320 --> 03:40.320
gmt是什么意思

03:40.320 --> 03:44.320
就是指的是格林威治的时间

03:44.320 --> 03:45.320
就是gmt

03:46.300 --> 03:47.800
格林威治就在零时趋

03:47.800 --> 03:49.300
我们把格林威治时间呢

03:49.300 --> 03:51.300
就叫做世界

03:51.300 --> 03:53.300
叫什么 原子时

03:53.300 --> 03:55.300
就是在零时趋的那个时间

03:57.300 --> 03:58.300
好 那么我们来看一下这两个概念

03:58.300 --> 03:59.300
一个是gmt

03:59.300 --> 04:01.300
就是Greenway-Mintime

04:01.300 --> 04:03.300
格林威治时间 世界时

04:03.300 --> 04:05.300
它是在零时趋

04:05.300 --> 04:06.300
这个时间呢

04:06.300 --> 04:08.300
它是精确到好妙的

04:08.300 --> 04:10.300
它是以太阳的公传

04:10.300 --> 04:12.300
以及地球的自传

04:12.300 --> 04:14.300
具体的情况 袁老师也早就忘了

04:15.280 --> 04:18.280
它能够精确地计算到好妙

04:18.280 --> 04:20.280
它精确度到好妙

04:20.280 --> 04:22.280
但是在我们计算机里边

04:22.280 --> 04:23.280
到好妙是不够的

04:23.280 --> 04:24.280
因此呢

04:24.280 --> 04:27.280
我们需要更加精确的计算机时间

04:27.280 --> 04:30.280
我们计算机里边是精确到辣妙的

04:30.280 --> 04:32.280
那么如何来精确到辣妙呢

04:32.280 --> 04:34.280
就需要另外一个时间

04:34.280 --> 04:35.280
叫utc

04:35.280 --> 04:38.280
它叫做世界协调时

04:38.280 --> 04:41.280
它是以一个原子的半衰期

04:41.280 --> 04:43.280
为时间单位的

04:43.280 --> 04:45.280
这个晚上也不要问袁老师

04:45.280 --> 04:47.280
我也不是学物理的 学化学的

04:47.280 --> 04:49.280
反正我就知道有这么一个常识

04:49.280 --> 04:51.280
是以哪个原子我忘了

04:51.280 --> 04:54.280
反正就是一个变化的一个时间点

04:54.280 --> 04:56.280
以它来作为计时标准

04:56.280 --> 04:58.280
它精确到辣妙

04:58.280 --> 05:03.280
注意 这个utc时间也指的是零时趋

05:03.280 --> 05:05.280
都是以零时趋为单位的

05:05.280 --> 05:08.280
那其他时趋呢 自己去换出来

05:08.280 --> 05:10.280
比方说你这个东巴趋

05:10.280 --> 05:12.280
是不是零时趋 加上八个小时

05:13.280 --> 05:15.280
那西巴区

05:15.280 --> 05:17.280
西巴区的话就是零时趋 减去八个小时

05:17.280 --> 05:19.280
自行换算

05:19.280 --> 05:22.280
因此它都计算的是零时趋的时间

05:22.280 --> 05:24.280
这个大家一定要记住

05:24.280 --> 05:26.280
在国际标准里边

05:26.280 --> 05:28.280
现在整个世界上使用的时间

05:28.280 --> 05:30.280
包括你的电脑 手机

05:30.280 --> 05:34.280
这些时间都全面的使用的是utc时间

05:34.280 --> 05:36.280
不再使用gmt时间了

05:36.280 --> 05:38.280
不过这gmt呢

05:38.280 --> 05:40.280
作为过去几百年

05:40.280 --> 05:42.280
几百年一直使用的时间

05:42.280 --> 05:45.280
它的习惯上

05:45.280 --> 05:49.280
我们还是把utc时间写作gmt

05:49.280 --> 05:51.280
只是习惯上写作

05:51.280 --> 05:53.280
但是实际使用的

05:53.280 --> 05:55.280
已经是原子这个计时标准了

05:55.280 --> 05:57.280
懂的意思吧

05:57.280 --> 05:59.280
我们写的时候还说

05:59.280 --> 06:01.280
这个gmt时间多少多少

06:01.280 --> 06:03.280
零时趋时间多少多少

06:03.280 --> 06:06.280
其实说的还是就是utc

06:06.280 --> 06:09.280
因此utc也用过去的那种书写方式

06:10.280 --> 06:12.280
这两种时间呢

06:12.280 --> 06:13.280
他们在格式上

06:13.280 --> 06:15.280
在计算机里边

06:15.280 --> 06:17.280
文笨格式上是一致的

06:17.280 --> 06:19.280
它基本上都是这样子写的

06:19.280 --> 06:21.280
前面写个星期的说写

06:21.280 --> 06:23.280
比方说你这里tuesday

06:23.280 --> 06:25.280
tuesday是星期几

06:25.280 --> 06:27.280
星期二是吧

06:27.280 --> 06:28.280
Monday

06:28.280 --> 06:29.280
Tuesday

06:29.280 --> 06:30.280
Wednesday

06:30.280 --> 06:31.280
Thursday

06:31.280 --> 06:32.280
Friday

06:32.280 --> 06:33.280
Saturday

06:33.280 --> 06:34.280
Sunday

06:34.280 --> 06:36.280
Tuesday是星期二

06:36.280 --> 06:38.280
那么前面就是星期的说写

06:38.280 --> 06:40.280
然后是日期

06:40.280 --> 06:41.280
比方说27号

06:41.280 --> 06:43.280
月份是一个单词

06:43.280 --> 06:44.280
月份不像我们

06:44.280 --> 06:46.280
就是世界上用月份的时候

06:46.280 --> 06:47.280
它不像我们

06:47.280 --> 06:48.280
有1月2月3月

06:48.280 --> 06:49.280
它不是这样计的

06:49.280 --> 06:51.280
世界上月份的记录的方式

06:51.280 --> 06:54.280
是用单词来作为说写

06:54.280 --> 06:58.740
比方说1月

06:58.740 --> 06:59.740
完了完了完了

06:59.740 --> 07:01.740
1月是啥呢

07:01.740 --> 07:03.740
1月是啥

07:05.740 --> 07:07.740
2月是feverly

07:07.740 --> 07:08.740
就这个意思

07:08.740 --> 07:10.740
这个 August 应该是8月

07:10.740 --> 07:12.740
8月就是后面是月份

07:12.740 --> 07:14.740
然后年份

07:14.740 --> 07:16.740
然后那个时间

07:16.740 --> 07:17.740
小时分钟秒

07:17.740 --> 07:18.740
后面都一样了

07:18.740 --> 07:20.740
后面加上一个固定的单词 GMT

07:20.740 --> 07:21.740
但是我再重生一次

07:21.740 --> 07:22.740
用的都是 UTC

07:22.740 --> 07:24.740
这是一个常识

07:24.740 --> 07:26.740
虽然我们写的时候

07:26.740 --> 07:27.740
还写个 GMT

07:27.740 --> 07:28.740
但是用的是

07:28.740 --> 07:30.740
实际上是 UTC 来计时

07:30.740 --> 07:32.740
这就是标准的日期格式

07:32.740 --> 07:33.740
表示方式

07:33.740 --> 07:35.740
也就是说习惯上

07:35.740 --> 07:36.740
过去习惯上

07:36.740 --> 07:38.740
像欧美那些国家

07:38.740 --> 07:39.740
他们习惯上用这种方式

07:39.740 --> 07:41.740
格式来表示日期

07:41.740 --> 07:44.740
后来一个国际标准组织

07:44.740 --> 07:46.740
叫 ASO

07:46.740 --> 07:47.740
ASO 就是一个国际标准组织

07:47.740 --> 07:49.740
它出了好多好多标准

07:49.740 --> 07:50.740
那么它其中一个标准

07:50.740 --> 07:51.740
8061

07:51.740 --> 07:52.740
编号8061

07:52.740 --> 07:53.740
这个标准

07:53.740 --> 07:55.740
它就建议全世界

07:55.740 --> 07:57.740
使用下边这种方式

07:57.740 --> 07:59.740
来表示时间

07:59.740 --> 08:01.740
所以说我们后边看到

08:01.740 --> 08:03.740
什么月份用数字来表示

08:03.740 --> 08:06.740
实际上是这个标准提出的

08:06.740 --> 08:07.740
它用什么表示呢

08:07.740 --> 08:08.740
就是 YYY

08:08.740 --> 08:10.740
表示连四位数的连分

08:10.740 --> 08:11.740
横杠

08:11.740 --> 08:13.740
然后两个 M 表示

08:13.740 --> 08:15.740
两位数的月份

08:15.740 --> 08:17.740
用数字来表示

08:17.740 --> 08:18.740
滴滴

08:18.740 --> 08:20.740
表示两位数的天数

08:20.740 --> 08:21.740
日期

08:21.740 --> 08:23.740
中间跟一个 T 表示

08:23.740 --> 08:24.740
后边是时间了

08:24.740 --> 08:26.740
用 T 来分割一下

08:26.740 --> 08:28.740
小时 24 小时至

08:28.740 --> 08:30.740
小时分钟秒

08:30.740 --> 08:31.740
一个底

08:31.740 --> 08:32.740
后边跟上豪妙

08:32.740 --> 08:33.740
后边一个 Z

08:33.740 --> 08:35.740
大体的 Z 表示结束

08:35.740 --> 08:37.740
所以说在世界

08:37.740 --> 08:39.740
ISO 这个标准下边

08:39.740 --> 08:40.740
它建议时间

08:40.740 --> 08:42.740
用这种方式来表示

08:42.740 --> 08:46.250
同时大家一定要注意

08:46.250 --> 08:49.250
无论是 GMT 还是 UTC

08:49.250 --> 08:51.250
还是 ISO 8061

08:51.250 --> 08:55.250
它们都使用的是零时趋的时间

08:55.250 --> 08:56.250
所以说其他时间怎么办

08:56.250 --> 08:57.250
你自己换一双

08:57.250 --> 08:58.250
自己自行换一双

08:58.250 --> 09:00.250
所以说以后你看到这个时间

09:00.250 --> 09:02.250
你不要问我是哪个时趋的

09:02.250 --> 09:03.250
它就是零时趋的

09:04.250 --> 09:06.250
你看到这种时间

09:06.250 --> 09:07.250
不要问我哪个时趋的

09:07.250 --> 09:09.250
它就是零时趋的

09:09.250 --> 09:10.250
懂了意思吧

09:10.250 --> 09:13.250
这三种时间都表示零时趋的时间

09:14.250 --> 09:16.250
这是有这个点给他说清楚

09:16.250 --> 09:17.250
接下来下一个概念

09:17.250 --> 09:19.250
叫 UNICS 时间戳

09:19.250 --> 09:20.250
这个玩意是什么呢

09:20.250 --> 09:22.250
是前边

09:22.250 --> 09:23.250
其实都跟计算机

09:23.250 --> 09:25.250
没有直接的关系

09:25.250 --> 09:26.250
你没有计算机

09:26.250 --> 09:28.250
它也是一种表示方式

09:28.250 --> 09:29.250
那么这个玩意

09:29.250 --> 09:32.250
才是跟计算机有关系

09:32.250 --> 09:34.250
这个玩意是什么东西呢

09:34.250 --> 09:36.250
它指的是在计算机那边

09:36.250 --> 09:38.250
我该怎么来表示一个时间呢

09:40.250 --> 09:41.250
怎么来表示时间呢

09:41.250 --> 09:42.250
在计算机里边

09:42.250 --> 09:44.250
它是用这种方式来表示时间的

09:44.250 --> 09:45.250
它是用一个数字

09:45.250 --> 09:47.250
因为计算机里边只能存数字

09:47.250 --> 09:49.250
它存不了别的玩意

09:49.250 --> 09:50.250
然后我们数字

09:50.250 --> 09:51.250
它就数字的方式存处

09:51.250 --> 09:52.250
对吧

09:52.250 --> 09:53.250
那如果说字不错的话

09:53.250 --> 09:55.250
它用编码的方式来进行存处

09:56.250 --> 09:57.250
那时间也是一样

09:57.250 --> 09:58.250
它存不了别的玩意

09:58.250 --> 09:59.250
包括我们的颜色

09:59.250 --> 10:01.250
颜色是不是也是用数字来存处的

10:01.250 --> 10:02.250
RGB嘛

10:02.250 --> 10:05.250
加上一个R法通道也是数字

10:05.250 --> 10:07.250
因此它计算机存不了别的玩意

10:07.250 --> 10:09.250
所以说关于日期怎么办呢

10:09.250 --> 10:11.250
它就想了一个办法

10:11.250 --> 10:14.250
它用了一个歧视时间

10:14.250 --> 10:18.250
为1970年1月1号凌晨

10:18.250 --> 10:20.250
主要是UT这时间

10:20.250 --> 10:21.250
就是说凌时区

10:21.250 --> 10:23.250
一定要想到都是凌时区

10:23.250 --> 10:28.250
以凌时区的1970年1月1号凌晨

10:28.250 --> 10:30.250
作为歧视时间

10:30.250 --> 10:32.250
到一个指定时间

10:32.250 --> 10:35.250
经过的秒数或者毫秒数

10:35.250 --> 10:37.250
有些用的是秒数

10:37.250 --> 10:39.250
有的用毫秒数都无所谓

10:39.250 --> 10:41.250
然后把这个秒数或者是毫秒数

10:41.250 --> 10:43.250
当成时间戳

10:43.250 --> 10:45.250
就这么个意思

10:45.250 --> 10:46.250
那比方说我告诉你

10:46.250 --> 10:49.250
时间戳有一个单词叫做TimeStand

10:49.250 --> 10:51.250
就时间戳的意思

10:51.250 --> 10:53.250
我告诉你这个时间戳是0

10:53.250 --> 10:54.250
啥意思

10:54.250 --> 10:55.250
表示哪个日期

10:55.250 --> 10:59.250
表示就是凌时区的1970年1月1号凌晨

10:59.250 --> 11:03.250
那如果说我时间戳写的是1

11:03.250 --> 11:04.250
表示什么日期

11:04.250 --> 11:10.250
表示是凌时区1970年1月1号凌晨0分1秒

11:10.250 --> 11:12.250
那如果说我写的是-1

11:12.250 --> 11:15.250
那就表示1969年12月31号

11:15.250 --> 11:20.250
59分59秒

11:20.250 --> 11:21.250
懂的意思吗

11:21.250 --> 11:23.250
这就是时间戳的意思

11:23.250 --> 11:26.250
它是以这个日期作为分界点

11:27.250 --> 11:28.250
好

11:28.250 --> 11:30.250
那么接下来我们来说

11:30.250 --> 11:31.250
我们在程序里边

11:31.250 --> 11:35.250
跟我们平时开发有什么样的关系

11:35.250 --> 11:40.250
将来你们在写代码的时候

11:40.250 --> 11:42.250
或者跟后端或者在公司里边

11:42.250 --> 11:45.250
跟别人的同事协作的时候

11:45.250 --> 11:46.250
经常会发现

11:46.250 --> 11:50.250
别人给力的时间就是一串数字

11:50.250 --> 11:53.250
程序里面对日期的计算

11:53.250 --> 11:57.250
存储它都用的是UTC时间

11:57.250 --> 11:58.250
或者是时间戳

11:58.250 --> 12:00.250
绝大部分用的都是时间戳

12:00.250 --> 12:02.250
比方说有篇文章

12:02.250 --> 12:05.250
它告诉你发布日期是一串数字

12:05.250 --> 12:07.250
你要看懂那个数字是它的意思

12:07.250 --> 12:09.250
那个数字就是时间戳

12:09.250 --> 12:10.250
不然的话你搞不清楚

12:10.250 --> 12:12.250
日期怎么变成一个时间戳

12:12.250 --> 12:13.250
怎么变成一串数字呢

12:13.250 --> 12:16.250
因此别人给力数据的时候

12:16.250 --> 12:17.250
比方说我要有篇文章

12:17.250 --> 12:19.250
你作为前端就要把它显示出来

12:19.250 --> 12:21.250
它可能会给力一个对象

12:21.250 --> 12:24.250
对象里边有文章的标题

12:24.250 --> 12:26.250
是一个字书创

12:26.250 --> 12:29.250
登革结婚了

12:29.250 --> 12:31.250
然后有一个文章的描述

12:31.250 --> 12:33.250
其他的属性不写了

12:33.250 --> 12:35.250
然后日期

12:35.250 --> 12:39.250
还会给你写一个文章的发布日期

12:39.250 --> 12:42.250
发布日期它不会给你这样子写

12:42.250 --> 12:45.250
2021年12月15号

12:45.250 --> 12:47.250
它不会这样写

12:47.250 --> 12:48.250
它会给你怎么给你的

12:48.250 --> 12:50.250
它会给你一串算数字

12:50.250 --> 12:52.250
你要通过这个数字

12:52.250 --> 12:54.250
把这个日期换算出来

12:54.250 --> 12:56.250
是这么一个意识

12:56.250 --> 12:58.250
所以我们在计算机里边

12:58.250 --> 13:00.250
玩那个时间也好

13:00.250 --> 13:01.250
玩日期也好

13:01.250 --> 13:03.250
都玩的是时间戳

13:03.250 --> 13:05.250
玩的是这个东西

13:05.250 --> 13:07.250
别人给力的数据

13:07.250 --> 13:09.250
给的也是时间戳

13:09.250 --> 13:10.250
当然了不排除

13:10.250 --> 13:11.250
就正规的程序里边

13:11.250 --> 13:13.250
正经程序里边

13:13.250 --> 13:14.250
它一般都给力时间戳

13:14.250 --> 13:15.250
那一不正经的程序里边

13:15.250 --> 13:16.250
那就可能会乱七八糟

13:16.250 --> 13:17.250
都给力了

13:17.250 --> 13:19.250
它就很真的给力一个字书创

13:19.250 --> 13:21.250
你都说不好

13:21.250 --> 13:23.250
但是我们不能把这个数字

13:23.250 --> 13:25.250
这个时间戳

13:25.250 --> 13:27.250
直接给用户显示出来

13:27.250 --> 13:28.250
对吧

13:28.250 --> 13:29.250
你把这个玩意给用户显示出来

13:29.250 --> 13:30.250
用户就蒙了

13:30.250 --> 13:31.250
多少玩意啊

13:31.250 --> 13:34.250
因此我们在给用户显示的时候

13:34.250 --> 13:37.250
我们需要把这个UTC时间

13:37.250 --> 13:38.250
或者是时间戳

13:38.250 --> 13:40.250
大部分时候都是时间戳

13:40.250 --> 13:43.250
转换成更加友好的文本

13:43.250 --> 13:45.250
好 这里下面一张图

13:45.250 --> 13:46.250
可以看得非常清楚

13:46.250 --> 13:48.250
比方说咱们写了一个网站

13:48.250 --> 13:51.250
这个网站是全世界都有很多用户

13:51.250 --> 13:53.250
各个地方都有

13:53.250 --> 13:56.250
那么英国有一个人在注册的时候

13:56.250 --> 13:58.250
填了一个生日

13:58.250 --> 14:00.250
比如2001年1月1号

14:00.250 --> 14:02.250
是他的生日

14:02.250 --> 14:04.250
那么这个生日

14:04.250 --> 14:08.250
你要想办法把它转成时间戳来存出

14:08.250 --> 14:10.250
要把它转换成时间戳

14:10.250 --> 14:12.250
这是要做的事情

14:12.250 --> 14:14.250
因为我们存程序里边

14:14.250 --> 14:17.250
我的时期全是时间戳

14:17.250 --> 14:18.250
它写的是什么

14:18.250 --> 14:21.250
它写的是本地时间

14:21.250 --> 14:24.250
比方说中国有个用户

14:24.250 --> 14:26.250
他也写的是这个日期

14:26.250 --> 14:30.250
那么请问大家一个问题

14:30.250 --> 14:32.250
他们写的都是同一天的生日

14:32.250 --> 14:35.250
但他们的生日真的是同一天吗

14:35.250 --> 14:36.250
这不是的

14:36.250 --> 14:37.250
为什么

14:37.250 --> 14:39.250
因为他们时区不一样

14:39.250 --> 14:40.250
对吧 时区

14:40.250 --> 14:42.250
其实也是同一天

14:42.250 --> 14:44.250
严格来说的话

14:44.250 --> 14:47.250
这个生日指的是2000年1月1号凌晨

14:47.250 --> 14:50.250
这个生日指的是换成凌时

14:50.250 --> 14:52.250
不是同一天

14:52.250 --> 14:53.250
这个玩意换成凌时区的话

14:53.250 --> 14:56.250
就是1999年12月31号

14:56.250 --> 14:58.250
晚上下午4点

14:58.250 --> 15:00.250
应该是这样换算

15:00.250 --> 15:01.250
换成凌时区

15:01.250 --> 15:03.250
这个生日换成凌时区的要减8

15:03.250 --> 15:04.250
所以他们不是同一天

15:04.250 --> 15:06.250
因为它时间不一样

15:06.250 --> 15:08.250
至少不是同一个时刻

15:08.250 --> 15:10.250
它时间不一样

15:10.250 --> 15:13.250
因此用户在写这个日期的时候

15:13.250 --> 15:15.250
他们用的都是本地时间

15:15.250 --> 15:17.250
如果说注册的时候

15:17.250 --> 15:19.250
让你去填时间户

15:19.250 --> 15:21.250
让你去填那个

15:21.250 --> 15:23.250
时间户一定是凌时区

15:23.250 --> 15:25.250
记住 时间户一定是凌时区

15:25.250 --> 15:29.250
让你去填那个凌时区的时间

15:29.250 --> 15:30.250
你也要封掉

15:30.250 --> 15:32.250
所以你填的都是本地时间

15:32.250 --> 15:33.250
但是在计算机里边

15:33.250 --> 15:36.250
它给你换算成时间户

15:36.250 --> 15:38.250
你看 换算成时间户之后

15:38.250 --> 15:40.250
你会发现他们两个是不一样的

15:40.250 --> 15:41.250
是不一样的

15:41.250 --> 15:42.250
都虽然写的都是一样的

15:42.250 --> 15:44.250
换算出来是不一样的

15:44.250 --> 15:45.250
实需不一样的

15:45.250 --> 15:47.250
那么如何换算

15:47.250 --> 15:49.250
将来有更好的

15:49.250 --> 15:50.250
不是标准户

15:50.250 --> 15:51.250
是更好的第三方户

15:51.250 --> 15:53.250
是别人写的一些户

15:53.250 --> 15:54.250
会帮你解决

15:54.250 --> 15:55.250
现在你不用管

15:55.250 --> 15:57.250
然后我们在显示的时候

15:57.250 --> 15:58.250
比方说将来我看一下

15:58.250 --> 16:00.250
这个用户的生日是这一天

16:00.250 --> 16:01.250
这个用户的生日是这一天

16:01.250 --> 16:02.250
在显示的时候

16:02.250 --> 16:05.250
我要根据用户的电脑

16:05.250 --> 16:07.250
显示成一个合适的本地时间

16:07.250 --> 16:08.250
给它显示

16:08.250 --> 16:09.250
懂了意思吗

16:09.250 --> 16:10.250
说了半天什么意思

16:10.250 --> 16:12.250
就是说我们在计算机表

16:12.250 --> 16:13.250
玩的时候

16:13.250 --> 16:14.250
玩的是时间户

16:14.250 --> 16:16.250
但是在显示的时候

16:16.250 --> 16:18.250
或者让用户填写的时候

16:18.250 --> 16:21.250
显示和填写的是本地时间

16:21.250 --> 16:23.250
就这么个意思

16:23.250 --> 16:25.250
那有东西可能想问的

16:25.250 --> 16:26.250
我在程序里边

16:26.250 --> 16:28.250
我怎么知道它是哪个死虚的呢

16:28.250 --> 16:30.250
我怎么知道它是本地的呢

16:30.250 --> 16:32.250
这个玩意你不用管

16:32.250 --> 16:33.250
为什么不用管呢

16:33.250 --> 16:35.250
因为操作系统帮你做了

16:35.250 --> 16:36.250
你看操作系统

16:36.250 --> 16:38.250
比方说我这个操作系统

16:38.250 --> 16:40.250
Windows是一样的也有的

16:40.250 --> 16:42.250
反正找到时间日期

16:42.250 --> 16:43.250
这里是不是有一个时趋

16:43.250 --> 16:44.250
会自动给你设置

16:44.250 --> 16:46.250
比方说我在这

16:46.250 --> 16:47.250
就是这个意思

16:47.250 --> 16:48.250
这个事情你不用管

16:48.250 --> 16:49.250
但是显示的时候

16:49.250 --> 16:51.250
要换算成本地时间

16:51.250 --> 16:53.250
好 接下来有几个思考题

16:53.250 --> 16:54.250
看一下

16:54.250 --> 16:56.250
用户的生日

16:56.250 --> 16:58.250
是本地时间还是UTC时间

16:58.250 --> 17:00.250
用户填的生日

17:00.250 --> 17:02.250
那肯定是本地的嘛

17:02.250 --> 17:03.250
你们填生日的时候

17:03.250 --> 17:04.250
没有说

17:04.250 --> 17:06.250
填个时间说吧

17:06.250 --> 17:07.250
没有说填个UTC时间吧

17:07.250 --> 17:08.250
都没有吧

17:08.250 --> 17:09.250
都填的是北京时间

17:09.250 --> 17:10.250
对吧

17:10.250 --> 17:11.250
第二个

17:11.250 --> 17:13.250
如果要比较两个日期的大小

17:13.250 --> 17:15.250
哪个日期先到

17:15.250 --> 17:17.250
哪个日期后到

17:17.250 --> 17:18.250
我们有这么一个

17:18.250 --> 17:20.250
约定俗成的这么一个规范

17:20.250 --> 17:23.250
就是说这是一条时间走

17:23.250 --> 17:27.560
时间向右流动

17:27.560 --> 17:28.560
这有两个时间

17:28.560 --> 17:29.560
那么我们认为

17:29.560 --> 17:33.560
这个时间比它大

17:33.560 --> 17:35.560
这个时间比它小

17:35.560 --> 17:37.560
就左边的小于右边的

17:37.560 --> 17:38.560
我们有这个约定

17:38.560 --> 17:40.560
就是比较两个日期的大小

17:40.560 --> 17:41.560
如果说要比较大小的话

17:41.560 --> 17:43.560
你觉得应该比较的是

17:43.560 --> 17:46.560
本地时间还是比较UTC时间

17:46.560 --> 17:50.510
是不是肯定是比较UTC

17:50.510 --> 17:51.510
为啥

17:51.510 --> 17:52.510
你看这两个生日

17:52.510 --> 17:53.510
如果说比较大小的话

17:53.510 --> 17:55.510
是不是一样的

17:55.510 --> 17:56.510
对吧

17:56.510 --> 17:57.510
那肯定是不能用

17:57.510 --> 17:59.510
不同时区的来进行比较

17:59.510 --> 18:00.510
一定要换算成同一个时区

18:00.510 --> 18:01.510
哪个时区呢

18:01.510 --> 18:02.510
就是零时区

18:02.510 --> 18:04.510
比较的是UTC时间

18:04.510 --> 18:06.510
如果说要显示

18:06.510 --> 18:07.510
稳张的发布日期

18:07.510 --> 18:09.510
是显示本地时间

18:09.510 --> 18:12.510
还是显示UTC时间

18:12.510 --> 18:14.510
所有的显示跟拥护

18:14.510 --> 18:16.510
要给拥护看的

18:16.510 --> 18:18.510
一定要换算成本地时间

18:18.510 --> 18:20.510
好 第四个点

18:20.510 --> 18:21.510
北京时间

18:21.510 --> 18:23.510
2020年8月28号

18:23.510 --> 18:25.510
上午10点

18:25.510 --> 18:27.510
和格林威治2020年

18:27.510 --> 18:28.510
8月28号

18:28.510 --> 18:29.510
上午2点

18:29.510 --> 18:30.510
凌晨2点

18:30.510 --> 18:31.510
哪个时间大

18:31.510 --> 18:33.510
哪个时间小

18:33.510 --> 18:35.510
是不是都要换算成

18:35.510 --> 18:37.510
零时区才能比较大小

18:37.510 --> 18:39.510
格林威治本来就是零时区

18:39.510 --> 18:41.510
本来就是UTC时间

18:41.510 --> 18:42.510
不用换算了

18:42.510 --> 18:43.510
那就是北京时间

18:43.510 --> 18:45.510
换算成格林威治

18:45.510 --> 18:47.510
是不是要减8个小时

18:47.510 --> 18:49.510
减8个小时

18:49.510 --> 18:51.510
减8个小时是不是凌晨2点

18:51.510 --> 18:53.510
凌晨2点是不是跟这个日期是一样的

18:53.510 --> 18:55.510
所以他们两个日期一样的

18:55.510 --> 18:56.510
大小强等

18:56.510 --> 18:57.510
好 第五题

18:57.510 --> 18:59.510
北京的时间戳为零

18:59.510 --> 19:01.510
格林威治的时间戳为零

19:01.510 --> 19:02.510
他们的日期

19:02.510 --> 19:04.510
他们的时间一样

19:04.510 --> 19:06.510
这是一道非常具有迷惑性的题

19:06.510 --> 19:07.510
我倒别说

19:12.510 --> 19:15.510
他们的日期和时间是一样的

19:17.510 --> 19:18.510
有的人说

19:18.510 --> 19:19.510
不对

19:20.510 --> 19:21.510
他们时区都不一样

19:22.510 --> 19:24.510
但是你看这个词

19:24.510 --> 19:26.510
用的是时间戳

19:26.510 --> 19:28.510
时间戳跟你在哪没关系

19:28.510 --> 19:30.510
它一定是零时区

19:31.510 --> 19:33.510
时间戳一定是零时区

19:33.510 --> 19:34.510
知道吧

19:34.510 --> 19:36.510
所以说跟前面全是干扰的

19:36.510 --> 19:38.510
跟这个没用的前面全是

19:38.510 --> 19:40.510
而且这个说法都是有多多少少有练

19:40.510 --> 19:42.510
问题的什么叫北京的时间戳

19:42.510 --> 19:44.510
没有什么北京的时间戳

19:44.510 --> 19:46.510
没有什么格林威治的时间戳

19:46.510 --> 19:47.510
没有这个东西

19:47.510 --> 19:48.510
时间戳就是时间戳

19:48.510 --> 19:50.510
它一定是零时区的

19:50.510 --> 19:51.510
好 第六题

19:51.510 --> 19:53.510
就他们时间是一样的

19:53.510 --> 19:54.510
第六题

19:54.510 --> 19:56.510
中国的用户注册的时候

19:56.510 --> 19:58.510
填写了生日是1970年1月1号

19:58.510 --> 20:01.510
它出生的UTC时间是多少

20:02.510 --> 20:04.510
需要减8个小时

20:04.510 --> 20:06.510
它填写生日是本地时间

20:06.510 --> 20:10.510
1969年12月31号下午4点

20:10.510 --> 20:12.510
减8个小时

20:12.510 --> 20:14.510
时间戳是多少呢

20:14.510 --> 20:17.510
那就先把它换成UTC时间

20:17.510 --> 20:18.510
UTC时间是多少

20:18.510 --> 20:25.510
1969年12月31号下午16点

20:26.510 --> 20:30.510
那么这个日期就是UTC时间

20:30.510 --> 20:33.510
那它的时间戳是多少

20:33.510 --> 20:34.510
肯定是附属

20:34.510 --> 20:35.510
对吧

20:35.510 --> 20:37.510
因为时间戳是1970年1月1号开始的

20:37.510 --> 20:38.510
附多少呢

20:38.510 --> 20:39.510
附8个小时

20:39.510 --> 20:40.510
附8个小时多少呢

20:40.510 --> 20:44.510
就是8成亿

20:44.510 --> 20:46.510
你就算吧

20:46.510 --> 20:48.510
8成亿

20:48.510 --> 20:50.510
一个小时3600秒

20:50.510 --> 20:52.510
如果说用秒来算的话

20:52.510 --> 20:55.510
就是附的2880

20:55.510 --> 20:56.510
如果说用好秒来算的话

20:56.510 --> 20:58.510
还要成1000好秒

20:59.510 --> 21:01.510
就是2880万

21:01.510 --> 21:02.510
好秒

21:02.510 --> 21:03.510
附的

21:05.510 --> 21:06.510
好了

21:06.510 --> 21:08.510
这就是日期时间的基础知识

21:08.510 --> 21:10.510
基本知识就够了

21:10.510 --> 21:11.510
知道这些就够了

21:11.510 --> 21:13.510
好 先让我们来看日期API

21:13.510 --> 21:14.510
你把前面搞清楚了之后

21:14.510 --> 21:16.510
日期API就很简单

21:16.510 --> 21:18.510
API就是很简单的

21:18.510 --> 21:20.510
这个API用来干什么用呢

21:20.510 --> 21:21.510
我们在程序里面

21:21.510 --> 21:23.510
都是有玩的是时间戳

21:23.510 --> 21:24.510
那么这个API

21:24.510 --> 21:26.510
它主要是帮你做一些

21:26.510 --> 21:28.510
简单的运算

21:28.510 --> 21:30.510
做一些简单的换算

21:30.510 --> 21:31.510
做这么一件事

21:31.510 --> 21:33.510
它的东西确实太过于简单了

21:33.510 --> 21:35.510
所以它并不是很好用

21:35.510 --> 21:36.510
因此很多

21:36.510 --> 21:38.510
将来我们在真正处理日期的时候

21:38.510 --> 21:40.510
往往会使用

21:40.510 --> 21:42.510
更加成熟 更加专业的

21:42.510 --> 21:43.510
第三方库

21:43.510 --> 21:45.510
就别人写好的一个库

21:45.510 --> 21:46.510
别人会把这个API拿出来

21:46.510 --> 21:47.510
给你封装一下

21:47.510 --> 21:48.510
继续封装

21:48.510 --> 21:50.510
加入很多功能

21:50.510 --> 21:51.510
好

21:51.510 --> 21:52.510
所以我们来看一下

21:52.510 --> 21:53.510
它是一个构造函数

21:53.510 --> 21:54.510
名字叫Dat

21:54.510 --> 21:55.510
叫一个New

21:55.510 --> 21:57.510
来创建这么一个

21:57.510 --> 21:59.510
构造函数

21:59.510 --> 22:00.510
好

22:00.510 --> 22:01.510
我们来创建一下

22:01.510 --> 22:02.510
试一下

22:02.510 --> 22:09.020
把这个

22:09.020 --> 22:10.020
稍微折叠一下

22:10.020 --> 22:14.300
这里我们用一个辨量

22:14.300 --> 22:16.300
D等于NewDat

22:16.300 --> 22:18.300
好 这就创建了一个日期对象

22:18.300 --> 22:19.300
这个日期对象

22:19.300 --> 22:22.300
由于你里边没有传参数

22:22.300 --> 22:23.300
没有传参数

22:23.300 --> 22:25.300
它就默认保存的是

22:25.300 --> 22:27.300
当前时间

22:27.300 --> 22:29.300
就此时此刻

22:29.300 --> 22:31.300
里面就保存了这么个东西

22:31.300 --> 22:32.300
对象就完成了

22:32.300 --> 22:34.300
你可以打印对象看一下

22:34.300 --> 22:36.300
打印对象

22:36.300 --> 22:38.300
里面就告诉你

22:38.300 --> 22:41.300
GNT的标准格式

22:41.300 --> 22:43.300
这是12月星期三

22:43.300 --> 22:44.300
Wednesday

22:44.300 --> 22:46.300
12月December

22:46.300 --> 22:49.300
15号2021年

22:49.300 --> 22:55.300
下午1点43分09秒

22:55.300 --> 22:56.300
但是

22:56.300 --> 22:58.300
它是不是GNT时间

22:58.300 --> 23:00.300
它后面给你加了一个这个东西

23:00.300 --> 23:02.300
加00800

23:02.300 --> 23:03.300
什么意思

23:03.300 --> 23:05.300
就是在GNT的基础上

23:05.300 --> 23:08.300
它已经给你加上了8个小时

23:08.300 --> 23:09.300
所以说这个时间

23:09.300 --> 23:10.300
它是给你显示了什么

23:10.300 --> 23:12.300
显示的是本地时间

23:12.300 --> 23:13.300
中国的标准时间

23:13.300 --> 23:15.300
如果说你要把它换换成GNT

23:15.300 --> 23:17.300
是不是要减去8个小时

23:17.300 --> 23:19.300
就这么个意思

23:19.300 --> 23:21.300
都是得到了一个日期对象

23:21.300 --> 23:22.300
对象里边有很多的方法

23:22.300 --> 23:23.300
有些实地的方法

23:23.300 --> 23:25.300
我们一会来讲

23:25.300 --> 23:26.300
好 我们看一下

23:26.300 --> 23:27.300
别的创建对象的方式

23:27.300 --> 23:29.300
下面这个

23:29.300 --> 23:31.300
还是第6一个Dance

23:31.300 --> 23:33.300
这里给它一个Value值

23:33.300 --> 23:35.300
这个Value值是什么呢

23:35.300 --> 23:37.300
就是时间戳

23:37.300 --> 23:38.300
你给它一个时间戳

23:38.300 --> 23:40.300
比方给它一个0

23:40.300 --> 23:41.300
表示什么意思

23:41.300 --> 23:42.300
表示的是UTC

23:42.300 --> 23:45.300
1970年1月1号

23:45.300 --> 23:46.300
你看

23:46.300 --> 23:48.300
现在得到的日期是什么

23:48.300 --> 23:53.300
1970年1月1号

23:53.300 --> 23:55.300
那天是星期二

23:55.300 --> 23:56.300
三五八点

23:56.300 --> 23:57.300
不是零层零电吗

23:57.300 --> 23:58.300
为什么是三五八点呢

23:58.300 --> 24:00.300
因为这是本地时间

24:00.300 --> 24:01.300
UTC的时间

24:01.300 --> 24:02.300
是不是减去8个小时

24:02.300 --> 24:04.300
刚好是零层

24:04.300 --> 24:06.300
好 第三个

24:06.300 --> 24:09.300
6一个Dance

24:09.300 --> 24:10.300
里边可以传一个

24:10.300 --> 24:12.300
标准的日期制服串

24:12.300 --> 24:14.300
比方说你可以这么传

24:16.300 --> 24:17.300
传到一个

24:17.300 --> 24:18.300
比方说就传这个吧

24:18.300 --> 24:20.300
就传这个

24:20.300 --> 24:24.380
复制一下

24:24.380 --> 24:25.380
加800吧

24:25.380 --> 24:27.380
这就是一个标准的日期制服串

24:27.380 --> 24:28.380
就得到这个日期了

24:28.380 --> 24:30.380
你传的是啥就是啥

24:30.380 --> 24:33.380
比方说我们来传这个

24:33.380 --> 24:34.380
不是很好用

24:34.380 --> 24:36.380
就是这个原因

24:36.380 --> 24:39.380
2021年1月1号

24:39.380 --> 24:41.380
是不是也可以

24:41.380 --> 24:43.380
2021年1月1号

24:43.380 --> 24:45.380
之前是星期五

24:45.380 --> 24:46.380
然后零层

24:46.380 --> 24:48.380
注意是北京时间的零层

24:48.380 --> 24:51.380
那UTC时间是不是会变化

24:51.380 --> 24:53.380
对吧

24:53.380 --> 24:55.380
好 再下一个

24:55.380 --> 24:57.380
NewDance

24:57.380 --> 24:59.380
分别跟上年月日

24:59.380 --> 25:02.690
Dance

25:02.690 --> 25:04.690
年比方说20

25:04.690 --> 25:06.690
2020年

25:06.690 --> 25:08.690
注意这个月

25:08.690 --> 25:10.690
同学们 注意

25:10.690 --> 25:14.690
当用一个数字来表示月的时候

25:14.690 --> 25:17.690
它的曲直是从零开始的

25:17.690 --> 25:19.690
它不是从一开始的

25:19.690 --> 25:20.690
零表示一月

25:20.690 --> 25:21.690
一表示二月

25:21.690 --> 25:23.690
是这样子的

25:24.690 --> 25:26.690
这种鬼做法

25:26.690 --> 25:28.690
是怎么来的呢

25:28.690 --> 25:30.690
我只能猜测

25:30.690 --> 25:31.690
其实不知道

25:31.690 --> 25:33.690
我只能猜测

25:33.690 --> 25:35.690
我猜测是这样子的

25:35.690 --> 25:37.690
因为在欧美那些国家的

25:37.690 --> 25:38.690
语言习惯里边

25:38.690 --> 25:41.690
他们不习惯用数字来表示月

25:41.690 --> 25:44.690
他们习惯用某一个单词来表示月

25:44.690 --> 25:46.690
它不是说我们1月2月

25:46.690 --> 25:47.690
按照数字来递征

25:47.690 --> 25:48.690
它不是这样子的

25:48.690 --> 25:50.690
它是用单词来表示的

25:50.690 --> 25:53.690
因此在数字那一块

25:53.690 --> 25:55.690
它就不是

25:55.690 --> 25:56.690
它就不是像我们那样

25:56.690 --> 25:58.690
从一开始的技术

25:58.690 --> 26:00.690
它就按照从零开始来技术

26:00.690 --> 26:03.690
我觉得如果说像欧美他们

26:03.690 --> 26:05.690
使用的是从一开始技术来边

26:05.690 --> 26:07.690
来进行月份的处理的话

26:07.690 --> 26:09.690
那么这一块也会跟着从一开始

26:09.690 --> 26:10.690
但是由于他们不是

26:10.690 --> 26:12.690
所以说这一块处理得起来

26:12.690 --> 26:13.690
它就按照程序喜欢的

26:13.690 --> 26:15.690
程序肯定喜欢从零开始

26:15.690 --> 26:18.690
从零开始来计算这个月份

26:18.690 --> 26:20.690
这是我个人觉得的

26:20.690 --> 26:21.690
可能是这个原因

26:21.690 --> 26:22.690
具体的原因我不知道

26:22.690 --> 26:23.690
反正就是这个数字

26:23.690 --> 26:24.690
它在从零开始

26:24.690 --> 26:26.690
也说这里写理由表示一月

26:26.690 --> 26:28.690
后面是一样的

26:28.690 --> 26:30.690
天一

26:30.690 --> 26:32.690
后面是小时分钟秒

26:32.690 --> 26:34.690
大家看这个文档里面

26:34.690 --> 26:36.690
有些时候还给你写个中括号

26:36.690 --> 26:37.690
是啥意思

26:37.690 --> 26:39.690
中括号表示可选参数

26:39.690 --> 26:41.690
就是这个参数可以不写

26:41.690 --> 26:42.690
表示这个D

26:43.690 --> 26:45.690
连月是必须要写的

26:45.690 --> 26:47.690
然后D是可以不写的

26:48.690 --> 26:49.690
然后小时呢

26:49.690 --> 26:50.690
有写到D过后

26:50.690 --> 26:52.690
小时也可以不写

26:52.690 --> 26:53.690
分钟也可以不写

26:53.690 --> 26:55.690
都可以省略的

26:55.690 --> 26:56.690
省略过后

26:56.690 --> 26:59.690
它都是默认为0

27:00.690 --> 27:02.690
默认值为1

27:02.690 --> 27:03.690
这个默认值为0

27:03.690 --> 27:05.690
就那么个意思

27:05.690 --> 27:08.690
后面容设不写的就是零成

27:08.690 --> 27:11.690
但是它指的是本地时间的零成

27:11.690 --> 27:13.690
指的是本地时间的零成

27:13.690 --> 27:14.690
Utc这时间

27:14.690 --> 27:16.690
可能要剪8个小时

27:16.690 --> 27:19.690
好了这就是创建对象就创建完了

27:19.690 --> 27:21.690
你看现在就这么一个东西

27:21.690 --> 27:23.690
好接下来我们来看一下

27:23.690 --> 27:24.690
它里面的API

27:24.690 --> 27:26.690
首先有一个静态方法

27:26.690 --> 27:28.690
静态方法是不通过一个构造

27:28.690 --> 27:29.690
还是来调用的

27:29.690 --> 27:31.690
这个玩意返回的是一个数字

27:31.690 --> 27:35.690
它表示此时此刻的时间戳

27:35.690 --> 27:37.690
我们经常用它来得到

27:37.690 --> 27:39.690
一个当前的时间戳

27:39.690 --> 27:41.690
这是这个

27:41.690 --> 27:42.690
注意在GS里面

27:42.690 --> 27:44.690
时间戳指的是好妙伟单位

27:44.690 --> 27:45.690
是好妙伟单位

27:45.690 --> 27:46.690
不是妙

27:46.690 --> 27:48.690
这是地团道

27:48.690 --> 27:50.690
好接下来全是圆形方法了

27:50.690 --> 27:52.690
我们来看一下圆形方法

27:52.690 --> 27:55.690
首先有一个这个方法

27:55.690 --> 27:59.190
Gateful Year

27:59.190 --> 28:00.190
这个方法是得到

28:00.190 --> 28:02.190
得到这个日期的年

28:02.190 --> 28:04.190
刚才我们创建的日期

28:04.190 --> 28:05.190
这个日期是2020年

28:05.190 --> 28:07.190
那么Gateful Year

28:07.190 --> 28:09.190
它得到了是当前的

28:09.190 --> 28:11.190
年这一部分的数字

28:11.190 --> 28:14.190
后面就简单的GateMounts

28:14.190 --> 28:16.190
得到当前日期

28:16.190 --> 28:17.190
不是当前日期

28:17.190 --> 28:18.190
是这个日期

28:18.190 --> 28:21.190
日期对箱里面的月份

28:21.190 --> 28:22.190
是一个数字

28:22.190 --> 28:24.190
这个数字是从零开始的

28:24.190 --> 28:26.190
好这个要注意一下

28:26.190 --> 28:27.190
然后是GateDates

28:27.190 --> 28:29.190
得到它的日期部分

28:29.190 --> 28:30.190
就是天内部分

28:30.190 --> 28:32.190
一号

28:32.190 --> 28:34.190
还有就是GateHours

28:34.190 --> 28:36.190
就不说了吧

28:36.190 --> 28:38.190
后面就是小时分钟秒

28:38.190 --> 28:40.190
好后面那个是

28:40.190 --> 28:42.190
转换成制服串

28:42.190 --> 28:45.190
Local

28:45.190 --> 28:46.190
表示

28:46.190 --> 28:48.190
转换成

28:48.190 --> 28:52.190
本地的日期制服串

28:52.190 --> 28:54.190
它的这种格式

28:54.190 --> 28:56.190
如果说你不想要时间

28:56.190 --> 28:57.190
只想要日期呢

28:57.190 --> 29:00.190
就是LocalDates

29:00.190 --> 29:01.190
它只有日期

29:01.190 --> 29:02.190
没有时间

29:02.190 --> 29:06.400
如果说你只想要时间

29:06.400 --> 29:08.400
就是to

29:08.400 --> 29:10.400
low

29:10.400 --> 29:12.400
Local

29:12.400 --> 29:13.400
它是写的

29:13.400 --> 29:14.400
呵呵碰碰的

29:14.400 --> 29:16.400
这些API不是经常用的

29:16.400 --> 29:18.400
因为不是很好用

29:18.400 --> 29:20.400
得到这个

29:20.400 --> 29:21.400
懂了意思吧

29:21.400 --> 29:22.400
就是得到制服串的

29:22.400 --> 29:25.400
它还可以得到UTC的制服串

29:25.400 --> 29:26.400
to

29:26.400 --> 29:28.400
UTC

29:28.400 --> 29:30.400
就得到这么个制服串

29:30.400 --> 29:32.400
然后to

29:32.400 --> 29:34.400
GMT

29:34.400 --> 29:35.400
一看是不是一样的

29:35.400 --> 29:37.400
说了UTC和GMT这种写法

29:37.400 --> 29:38.400
都是一样的

29:38.400 --> 29:40.400
还有to

29:41.400 --> 29:44.400
就是这种格式表示方式

29:44.400 --> 29:46.400
就这么一些意思

29:46.400 --> 29:48.400
其实同学们可以看一下

29:48.400 --> 29:50.400
我们刚才不是说了

29:50.400 --> 29:51.400
有很多创建方式吗

29:51.400 --> 29:52.400
那么比方说我们现在

29:52.400 --> 29:54.400
创建一个日期

29:54.400 --> 29:56.400
就0吧

29:56.400 --> 29:58.400
时间出为0

29:58.400 --> 29:59.400
来创建一个日期

29:59.400 --> 30:01.400
我们来看一下这个日期

30:01.400 --> 30:02.400
to

30:02.400 --> 30:04.400
LocalStream

30:04.400 --> 30:08.290
本地时间就是

30:08.290 --> 30:09.290
1970年1月1号

30:09.290 --> 30:11.290
上午8点

30:11.290 --> 30:13.290
时间出为0

30:13.290 --> 30:14.290
是不是本地日期

30:14.290 --> 30:15.290
北京时间是上午8点

30:15.290 --> 30:16.290
对吧

30:16.290 --> 30:17.290
加8个小时

30:17.290 --> 30:19.290
然后我们再看一下to

30:19.290 --> 30:21.290
UTC死菌

30:21.290 --> 30:22.290
这个看的不是很清楚

30:22.290 --> 30:24.290
ISO吗

30:24.290 --> 30:27.290
是不是就1970年1月1号凌晨

30:27.290 --> 30:29.290
它不同死菌

30:29.290 --> 30:30.290
表示方式不一样的

30:30.290 --> 30:33.290
时间出是最准确的

30:33.290 --> 30:35.290
好了说完了

30:35.290 --> 30:37.290
那最后我们来到练习题

30:37.290 --> 30:39.290
就一到练习题就行了

30:39.290 --> 30:42.290
这到练习题是非常具有实用性质的

30:42.290 --> 30:45.290
将来你们如果说开发一个网页

30:45.290 --> 30:47.290
它要做一些简单的日期处理

30:47.290 --> 30:49.290
非常简单的日期处理

30:49.290 --> 30:51.290
这个函数就够了

30:51.290 --> 30:54.290
其实我们这一套APN里边

30:54.290 --> 30:56.290
为什么说它不行呢

30:56.290 --> 30:58.290
其中一个很重要的原因就是

30:58.290 --> 31:01.290
它没有办法格式化日期

31:01.290 --> 31:02.290
比方说我要显示日期为

31:02.290 --> 31:05.290
1970年和日

31:05.290 --> 31:09.290
日多少十多少分多少秒

31:09.290 --> 31:11.290
它就不好格式化了

31:11.290 --> 31:13.290
那么我们可以写一个简单的函数

31:13.290 --> 31:15.290
来帮助它格式化

31:15.290 --> 31:17.290
这个函数我先讲一下

31:17.290 --> 31:18.290
什么意思

31:18.290 --> 31:20.290
你先要看懂这个道题是什么意思

31:20.290 --> 31:24.050
这个函数是很有用的

31:24.050 --> 31:25.050
什么意思呢

31:25.050 --> 31:27.050
它告诉你传入两个参数

31:27.050 --> 31:28.050
第一个参数传入一个日期

31:28.050 --> 31:30.050
比方说

31:30.050 --> 31:33.050
我就调用一个format date

31:33.050 --> 31:35.050
我传一个日期对象

31:35.050 --> 31:37.050
比方说就当前日期

31:37.050 --> 31:38.050
我是不是可以留一个电子

31:38.050 --> 31:40.050
没见过这种邪法

31:40.050 --> 31:42.050
这也是一个表达式

31:42.050 --> 31:43.050
这个表达式反回什么

31:43.050 --> 31:45.050
就是反回一个对象

31:45.050 --> 31:46.050
日期对象

31:46.050 --> 31:48.050
而且是当前时间的日期对象

31:48.050 --> 31:49.050
把对象给它

31:49.050 --> 31:51.050
当然你也可以把它保存一个变量

31:51.050 --> 31:53.050
里边然后再把变量传过去

31:53.050 --> 31:55.050
是一样的

31:55.050 --> 31:57.050
第一个参数

31:57.050 --> 31:58.050
第二个参数呢

31:58.050 --> 32:01.050
第二个参数是一个制服串

32:01.050 --> 32:02.050
它告诉你

32:02.050 --> 32:03.050
你要告诉它

32:03.050 --> 32:05.050
你想把这个日期

32:05.050 --> 32:07.050
显示成什么样子

32:07.050 --> 32:09.050
那么这是一个模板制服串

32:09.050 --> 32:11.050
这个制服串怎么写呢

32:11.050 --> 32:12.050
它告诉你

32:12.050 --> 32:14.050
这里边有一些站位符

32:14.050 --> 32:15.050
比方说歪歪歪

32:15.050 --> 32:16.050
是个书的歪歪

32:16.050 --> 32:17.050
那么就表示

32:17.050 --> 32:19.050
四位书的年

32:19.050 --> 32:20.050
比方说我可以这样子写

32:20.050 --> 32:22.050
歪歪歪

32:22.050 --> 32:24.050
好MMM表示

32:24.050 --> 32:26.050
弟弟表示日

32:26.050 --> 32:28.050
小时24小时

32:28.050 --> 32:31.050
小时两个大写的H

32:31.050 --> 32:33.050
MM表示分钟

32:33.050 --> 32:34.050
SS表示秒

32:34.050 --> 32:35.050
毫秒的话你按写就写

32:35.050 --> 32:37.050
不写就拉倒

32:37.050 --> 32:39.050
于是你把这个玩意传进去

32:39.050 --> 32:41.050
它就会给你返回一个制服串

32:41.050 --> 32:43.050
返回什么呢

32:43.050 --> 32:44.050
返回比方

32:44.050 --> 32:47.050
现在是2021年

32:47.050 --> 32:50.050
12月15号

32:52.050 --> 32:53.050
多少小时

32:53.050 --> 32:55.050
13点53分

32:55.050 --> 32:57.050
46秒

32:57.050 --> 32:59.050
它就会给你返回这么一个制服串

32:59.050 --> 33:00.050
什么意思

33:00.050 --> 33:02.050
它就把日期里面的年的这一部分

33:02.050 --> 33:03.050
替换掉这个

33:03.050 --> 33:05.050
月的部分替换掉这个

33:05.050 --> 33:06.050
日的部分替换掉这个

33:06.050 --> 33:07.050
一是替换

33:07.050 --> 33:08.050
懂了意思吗

33:08.050 --> 33:10.050
那如果说你的制服串

33:10.050 --> 33:11.050
这样写的

33:11.050 --> 33:12.050
年

33:12.050 --> 33:14.050
月

33:14.050 --> 33:15.050
日

33:15.050 --> 33:17.050
时

33:17.050 --> 33:19.050
分

33:19.050 --> 33:20.050
秒

33:20.050 --> 33:21.050
如果说你是这样子写的话

33:21.050 --> 33:23.050
那么它就会这样子显示

33:23.050 --> 33:25.050
年

33:25.050 --> 33:26.050
月

33:26.050 --> 33:27.050
日

33:27.050 --> 33:28.050
懂了意思吗

33:28.050 --> 33:30.050
时

33:30.050 --> 33:31.050
分

33:31.050 --> 33:32.050
秒

33:32.050 --> 33:34.050
那有的时候我不想显示时间

33:34.050 --> 33:35.050
那你把这个去掉

33:35.050 --> 33:37.050
那么它这边就会直接给你

33:37.050 --> 33:39.050
返回这么一个制服串

33:39.050 --> 33:40.050
懂了意思吗

33:40.050 --> 33:41.050
这是第二个参数的作用

33:41.050 --> 33:43.050
表示格式化制服串

33:43.050 --> 33:46.050
你到底要显示成什么格式

33:46.050 --> 33:47.050
那么这些地方

33:47.050 --> 33:49.050
它会给你进行替换

33:49.050 --> 33:50.050
然后还返回一个新制服串

33:50.050 --> 33:51.050
有了这个函数之后

33:51.050 --> 33:52.050
那么我们的日期

33:52.050 --> 33:53.050
是不是可以显示成

33:53.050 --> 33:54.050
各种各样的制服串

33:54.050 --> 33:55.050
都可以了

33:55.050 --> 33:56.050
对不对

33:56.050 --> 33:58.050
好,我们来实现这个函数

33:59.050 --> 34:00.050
怎么实现呢

34:00.050 --> 34:01.050
其实非常简单

34:01.050 --> 34:02.050
我要做的事情

34:02.050 --> 34:04.050
其实就是

34:04.050 --> 34:05.050
我把这个写完

34:05.050 --> 34:06.050
还有毫秒

34:06.050 --> 34:07.050
MS

34:07.050 --> 34:11.130
毫秒

34:11.130 --> 34:12.130
多少毫秒

34:12.130 --> 34:14.130
比方说526

34:14.130 --> 34:16.130
毫秒

34:17.130 --> 34:19.130
我要做的实际上

34:19.130 --> 34:21.130
就是不断的替换这个制服串

34:21.130 --> 34:23.130
把它替换成什么

34:23.130 --> 34:25.130
替换成年

34:25.130 --> 34:26.130
把它替换成月

34:26.130 --> 34:28.130
把它替换成日

34:28.130 --> 34:29.130
那我是不是要拿到

34:29.130 --> 34:30.130
年月日十分秒

34:30.130 --> 34:31.130
毫秒

34:31.130 --> 34:32.130
对不对

34:32.130 --> 34:33.130
是不是全都拿到

34:33.130 --> 34:34.130
来吧

34:34.130 --> 34:35.130
年

34:35.130 --> 34:36.130
一二

34:36.130 --> 34:37.130
怎么拿到

34:37.130 --> 34:38.130
这一层里边

34:38.130 --> 34:39.130
用一个方法

34:39.130 --> 34:40.130
要get for year

34:40.130 --> 34:42.130
得到完整的年

34:42.130 --> 34:43.130
它其实有两个方法

34:43.130 --> 34:44.130
一个是get for year

34:44.130 --> 34:45.130
这个get for year

34:45.130 --> 34:46.130
它只得到两位数的

34:46.130 --> 34:47.130
比方说

34:47.130 --> 34:48.130
现在是2021年

34:48.130 --> 34:50.130
它只会得到21

34:52.130 --> 34:53.130
get for year

34:53.130 --> 34:55.130
它得到4位数的年份

34:55.130 --> 34:56.130
好

34:56.130 --> 34:57.130
年月

34:57.130 --> 34:58.130
月是什么呢

34:58.130 --> 34:59.130
get months

34:59.130 --> 35:00.130
注意

35:00.130 --> 35:02.130
它这个月是从年文开始的

35:02.130 --> 35:03.130
所以说你要加一

35:03.130 --> 35:04.130
一定要加一

35:04.130 --> 35:05.130
好

35:05.130 --> 35:07.130
日 date

35:07.130 --> 35:09.130
重明了

35:09.130 --> 35:11.130
get date

35:11.130 --> 35:14.130
这是得到年月日

35:14.130 --> 35:16.130
然后十分秒

35:16.130 --> 35:17.130
hour

35:17.130 --> 35:23.130
get hours

35:23.130 --> 35:24.130
小时

35:24.130 --> 35:26.130
分钟 minutes

35:26.130 --> 35:27.130
get minutes

35:27.130 --> 35:29.130
秒 second

35:29.130 --> 35:31.130
然后得到get

35:31.130 --> 35:33.130
second

35:33.130 --> 35:34.130
second

35:34.130 --> 35:36.130
还有就是毫秒

35:38.130 --> 35:42.460
media second

35:42.460 --> 35:43.460
就写完了

35:43.460 --> 35:44.460
那么我要拿到

35:44.460 --> 35:45.460
这个日期的年月日

35:45.460 --> 35:46.460
十分秒

35:46.460 --> 35:47.460
我们输出一下

35:47.460 --> 35:49.460
年月日

35:49.460 --> 35:53.460
十分秒

35:53.460 --> 35:57.950
好

35:57.950 --> 35:58.950
我来看一下

35:58.950 --> 35:59.950
是不是拿到

35:59.950 --> 36:00.950
所有东西了

36:00.950 --> 36:01.950
我再运行

36:01.950 --> 36:03.950
每一次时间都不一样

36:03.950 --> 36:04.950
传入的是当前时间

36:04.950 --> 36:06.950
当然也可以传入一个固定的时间

36:06.950 --> 36:07.950
都可以

36:08.950 --> 36:09.950
好

36:09.950 --> 36:10.950
拿到这些时间过后

36:10.950 --> 36:11.950
我们现在要就是

36:11.950 --> 36:12.950
把这些数字

36:12.950 --> 36:14.950
替换掉这些位置

36:14.950 --> 36:16.950
所以玩笑了

36:16.950 --> 36:17.950
不就完了吗

36:17.950 --> 36:18.950
替换掉这些位置不就完了吗

36:18.950 --> 36:19.950
好

36:19.950 --> 36:20.950
我们来替换

36:20.950 --> 36:22.950
那怎么来替换呢

36:22.950 --> 36:23.950
不就是这个

36:23.950 --> 36:24.950
这是一个制服圈

36:24.950 --> 36:25.950
这个玩意就是个制服圈

36:25.950 --> 36:26.950
这个制服圈

36:26.950 --> 36:27.950
我们只有使用

36:27.950 --> 36:28.950
它制服圈里面的

36:29.950 --> 36:30.950
就是替换

36:30.950 --> 36:31.950
替换歪歪歪歪

36:31.950 --> 36:32.950
为什么呢

36:32.950 --> 36:33.950
为易儿

36:34.950 --> 36:36.950
把连替换了

36:36.950 --> 36:37.950
把这一会替换了

36:37.950 --> 36:38.950
替换了之后

36:38.950 --> 36:39.950
我们再来

36:40.950 --> 36:41.950
再把

36:42.950 --> 36:43.950
替换成

36:44.950 --> 36:45.950
后边再把

36:46.950 --> 36:47.950
替换成

36:47.950 --> 36:48.950
然后再把

36:50.950 --> 36:52.950
HH替换成

36:53.950 --> 36:54.950
好

36:54.950 --> 36:55.950
然后再把

36:56.950 --> 36:57.950
消息的M

36:57.950 --> 36:58.950
替换成

36:58.950 --> 36:59.950
Milits

37:01.950 --> 37:02.950
然后再把

37:03.950 --> 37:05.950
SS替换成Second

37:06.950 --> 37:07.950
然后再把

37:08.950 --> 37:09.950
MS

37:10.950 --> 37:11.950
替换成MilitsSecond

37:12.950 --> 37:15.390
就玩笑了

37:15.390 --> 37:16.390
对吧

37:16.390 --> 37:17.390
哪一常穿的替换

37:17.390 --> 37:18.390
把这个替换完

37:18.390 --> 37:20.390
完成之后的制服圈

37:20.390 --> 37:21.390
直接返回

37:23.390 --> 37:24.390
好

37:24.390 --> 37:25.390
咱们来看一下

37:26.390 --> 37:27.390
我们输出

37:28.390 --> 37:35.310
好运行

37:35.310 --> 37:37.310
你看是不是这样一个结果了

37:37.310 --> 37:38.310
对不对

37:39.310 --> 37:40.310
没问题吧

37:40.310 --> 37:41.310
好

37:41.310 --> 37:42.310
但是这个程序

37:42.310 --> 37:44.310
其实还有一些小的问题

37:44.310 --> 37:45.310
什么小的问题呢

37:45.310 --> 37:46.310
比方说

37:46.310 --> 37:47.310
我这里把好秒去掉

37:49.310 --> 37:50.310
以方说吧

37:50.310 --> 37:51.310
我这个日期是这样子的

37:51.310 --> 37:54.310
2021年1月1号

37:54.310 --> 37:58.840
这是2月

37:58.840 --> 38:01.840
2021年1月1号

38:02.840 --> 38:05.840
3.5分

38:05.840 --> 38:07.840
6秒

38:07.840 --> 38:08.840
好

38:08.840 --> 38:09.840
我创建这么一个日期

38:09.840 --> 38:10.840
然后把它传进去

38:10.840 --> 38:12.840
因为发现它是这样子的

38:12.840 --> 38:14.840
这样子好像也没有什么问题

38:14.840 --> 38:15.840
对吧

38:15.840 --> 38:16.840
但是实际上

38:16.840 --> 38:17.840
我们希望

38:17.840 --> 38:18.840
它不足两位的时候

38:18.840 --> 38:19.840
前边补充零

38:21.840 --> 38:22.840
是不是让你想起了什么

38:22.840 --> 38:24.840
想起了制服圈处理

38:24.840 --> 38:25.840
对吧

38:25.840 --> 38:26.840
我们之前说

38:26.840 --> 38:27.840
有学过制服圈处理

38:27.840 --> 38:29.840
制服圈里面有一个方法

38:29.840 --> 38:30.840
叫做PendLeft

38:31.840 --> 38:33.840
PendStart

38:33.840 --> 38:35.840
在开始位置填充

38:35.840 --> 38:38.840
不足多少位就填充啥

38:38.840 --> 38:40.840
比方说填充零

38:40.840 --> 38:41.840
前面不足三位

38:41.840 --> 38:43.840
它就填充了两个零

38:43.840 --> 38:44.840
它满足三位

38:44.840 --> 38:46.840
它就不填充

38:46.840 --> 38:47.840
是不是说

38:47.840 --> 38:48.840
现在我只需要把

38:48.840 --> 38:49.840
每一块

38:49.840 --> 38:51.840
转换成制服圈就可以了

38:51.840 --> 38:52.840
对不对

38:52.840 --> 38:53.840
ToStream

38:53.840 --> 38:55.840
转换成制服圈

38:55.840 --> 38:57.840
然后填充PendStart

38:58.840 --> 39:00.840
连份不足四位

39:00.840 --> 39:02.840
就填充零

39:04.840 --> 39:05.840
一次来起了

39:06.840 --> 39:07.840
这一块

39:08.840 --> 39:09.840
家里的

39:09.840 --> 39:10.840
加完了之后

39:10.840 --> 39:11.840
我们再来ToStream

39:12.840 --> 39:13.840
这是一个表达式

39:13.840 --> 39:14.840
表达式是一个数字

39:14.840 --> 39:15.840
数字变成制服圈

39:15.840 --> 39:16.840
制服圈里面

39:16.840 --> 39:17.840
调用这个函数

39:17.840 --> 39:18.840
不足两位

39:18.840 --> 39:20.840
约份前面填充零

39:21.840 --> 39:22.840
同样的道理

39:23.840 --> 39:24.840
那我这里

39:24.840 --> 39:25.840
是不是也是一样

39:26.840 --> 39:27.840
这里是不是也是一样

39:27.840 --> 39:28.840
这里是不是也是一样

39:28.840 --> 39:29.840
这里是不是也是一样

39:29.840 --> 39:30.840
毫秒就不管它了

39:32.840 --> 39:33.840
现在是不是可以了

39:34.840 --> 39:35.840
不足两位就填充零

39:35.840 --> 39:36.840
那如果说你失两位了

39:36.840 --> 39:37.840
它就不动

39:41.410 --> 39:42.410
OK

39:42.410 --> 39:44.410
好 这就是这一块

39:44.410 --> 39:45.410
这个函数大家一定要会写

39:45.410 --> 39:46.410
因为有的时候

39:46.410 --> 39:47.410
我们虽然将来

39:47.410 --> 39:49.410
有一些现成的日期处理

39:49.410 --> 39:51.410
功能很强大的API

39:51.410 --> 39:52.410
可以让你用

39:52.410 --> 39:53.410
你可以不用写这个函数

39:53.410 --> 39:54.410
但是有的时候

39:54.410 --> 39:55.410
一些系统里边

39:55.410 --> 39:57.410
有些系统对日期的处理很简单

39:57.410 --> 39:59.410
我们没有必要去使用第三方库

39:59.410 --> 40:00.410
因为使用第三方库

40:00.410 --> 40:02.410
是要带来一些代价的

40:02.410 --> 40:04.410
因此我们可能会自己写一些

40:04.410 --> 40:06.410
简单的方法来处理一下就可以了

40:07.410 --> 40:08.410
好 OK

40:08.410 --> 40:10.410
这就是关于日期这一块

40:10.410 --> 40:11.410
我要讲讲东西

