WEBVTT

00:00.560 --> 00:04.160
好 大家看了我就把标准库给它结束了

00:04.160 --> 00:08.160
这里有对象 对象里面就讲完了

00:08.160 --> 00:10.560
像什么get the prototype

00:10.560 --> 00:11.760
get the prototype

00:11.760 --> 00:13.560
crazed 说的都讲了

00:13.560 --> 00:15.560
有一个叫ersam

00:15.560 --> 00:17.560
这个玩意大家了解一下就行了

00:17.560 --> 00:21.560
它是可以把多个对象的属性混合在一起

00:21.560 --> 00:27.160
这个玩意将来你们学到了很后期很后期的时候

00:27.160 --> 00:30.360
有些用 现在目前这个阶段没有啥用

00:30.360 --> 00:33.760
了解就行了 我来说一下这个ersam

00:33.760 --> 00:36.560
这是什么东西呢 比方说

00:36.560 --> 00:39.960
这里有一个对象obj1

00:39.960 --> 00:41.960
a等于eb等于2

00:41.960 --> 00:44.560
然后还有一个obj2

00:44.560 --> 00:45.760
a等于3

00:45.760 --> 00:46.960
c等于4

00:46.960 --> 00:48.560
d等于5

00:48.560 --> 00:52.360
还有一个obj3

00:52.360 --> 00:54.960
b等于4

00:54.960 --> 00:57.760
c等于

00:57.760 --> 00:59.160
1等于7

00:59.160 --> 01:00.960
然后就这么一些对象

01:00.960 --> 01:02.560
现在我要做这么一件事

01:02.560 --> 01:06.160
我要把这三个对象混合在一起

01:06.160 --> 01:08.160
怎么要混合在一起呢

01:08.160 --> 01:12.160
比方说我要把这个和这个换个颜色

01:12.160 --> 01:14.560
这个和这个混合在一起

01:14.560 --> 01:17.760
它里边没有的属性的权

01:17.760 --> 01:20.560
就相当于是求一个病疾

01:20.560 --> 01:22.360
知道意思吧 求病疾

01:22.360 --> 01:23.560
属性的权

01:23.560 --> 01:28.360
那么它混合之后它里边就会有a有b有c有d

01:28.560 --> 01:30.760
然后如果说出现重明的怎么办呢

01:30.760 --> 01:32.960
后边的覆盖前边的

01:32.960 --> 01:35.560
比方说这个3就会覆盖这个1

01:35.560 --> 01:36.360
懂的意思吧

01:36.360 --> 01:37.160
就这么个意思

01:37.160 --> 01:38.360
这叫混合

01:38.360 --> 01:39.360
混合怎么做呢

01:39.360 --> 01:41.360
就可以使用obj的词

01:41.360 --> 01:44.960
ersam来进行混合

01:44.960 --> 01:49.960
里边的传任意数量的参数都可以

01:49.960 --> 01:53.160
但是至少传两个obj1obj2

01:53.160 --> 01:54.560
那么这样子一来的话

01:54.560 --> 01:56.360
它就会把obj2的属性

01:56.360 --> 01:59.160
把读出来覆盖obj1

01:59.160 --> 02:01.360
然后没有的了给它加上

02:01.360 --> 02:03.760
好 这样子一混合完成之后

02:03.760 --> 02:05.560
再输出obj1

02:05.560 --> 02:07.760
你会发现是不是都有了

02:07.760 --> 02:08.360
对吧

02:08.360 --> 02:11.160
而且这个函数它还会给你返回

02:11.160 --> 02:12.160
返回什么的

02:12.160 --> 02:13.160
返回一个对象

02:13.160 --> 02:15.360
这个对象就是obj1

02:15.360 --> 02:16.560
就是obj1

02:16.560 --> 02:18.360
其实我们这里输出这个O

02:18.360 --> 02:19.960
和输出这个obj1

02:19.960 --> 02:21.560
得到的结果是一样的

02:21.560 --> 02:24.760
实际上这个O还等于obj1

02:24.760 --> 02:26.760
说明它的地址是一样的

02:26.760 --> 02:27.760
就这么个意思

02:27.760 --> 02:28.760
就要混合

02:28.760 --> 02:30.760
混合不只是两个

02:30.760 --> 02:31.760
还可以有多个

02:31.760 --> 02:33.760
比方说把obj3也可以传进去

02:33.760 --> 02:34.760
那么就是一直覆盖

02:34.760 --> 02:35.160
对吧

02:35.160 --> 02:37.760
它覆盖到它

02:37.760 --> 02:39.760
然后它也覆盖到它

02:39.760 --> 02:40.760
就这么个意思

02:40.760 --> 02:43.760
好 我们再输出O

02:43.760 --> 02:44.760
看一下

02:44.760 --> 02:45.760
说都有了

02:45.760 --> 02:46.260
对吧

02:46.260 --> 02:47.760
后边覆盖前面了

02:47.760 --> 02:50.760
然后obj2是没有变化的

02:50.760 --> 02:52.760
它是不会有变化的

02:52.760 --> 02:54.760
那这个我们一般在做的时候

02:54.760 --> 02:55.760
很后期的时候才有用

02:55.760 --> 02:57.760
在做的时候是这样

02:57.760 --> 02:59.760
因为如果说我们这样子写的话

02:59.760 --> 03:03.760
会导致obj1也发生变化

03:03.760 --> 03:05.760
那如果说我们在写这个单码的时候

03:05.760 --> 03:08.760
不希望有任何对象得到更改

03:08.760 --> 03:09.760
就他们的这些以前的对象

03:09.760 --> 03:11.760
就的对象不变

03:11.760 --> 03:13.760
我们只是返回一个新对象

03:13.760 --> 03:14.760
那怎么做呢

03:14.760 --> 03:15.760
就非常简单

03:15.760 --> 03:16.760
你只需要在第1个参数

03:16.760 --> 03:18.760
给它加上一个新对象就可以了

03:18.760 --> 03:19.760
那么就相当于是

03:19.760 --> 03:20.760
把它覆盖到它

03:20.760 --> 03:21.760
对吧

03:21.760 --> 03:22.760
把它也覆盖到它

03:22.760 --> 03:24.760
然后它也覆盖到它

03:24.760 --> 03:26.760
那么产生那个新对象

03:26.760 --> 03:27.760
对吧

03:27.760 --> 03:28.760
然后把这个新对象返回

03:28.760 --> 03:29.760
用一个变量保存一下

03:29.760 --> 03:30.760
那这样子呢

03:30.760 --> 03:33.760
我们就没有去改变原有的对象

03:33.760 --> 03:34.760
这个了解一下就行了

03:34.760 --> 03:36.760
这叫对象混合

03:36.760 --> 03:37.760
将来会有用

03:37.760 --> 03:38.760
现在没啥用

03:38.760 --> 03:39.760
对象

03:39.760 --> 03:40.760
其他的我们都学过

03:40.760 --> 03:42.760
包括函数这里边

03:42.760 --> 03:43.760
有一个apply

03:43.760 --> 03:44.760
有一个call

03:44.760 --> 03:45.760
是不是我们都学过了

03:45.760 --> 03:47.760
这一块就没什么好说的了

03:47.760 --> 03:48.760
主要是数组

03:48.760 --> 03:50.760
数组里边有很多很多的方法

03:50.760 --> 03:52.760
我们这里先学这么一些

03:52.760 --> 03:53.760
将来让你们再学

03:53.760 --> 03:55.760
到解释语言提升这一块

03:55.760 --> 03:56.760
还会学习更多的方法

03:56.760 --> 03:58.760
不过都是写app

03:58.760 --> 03:59.760
忘记了就查就行了

03:59.760 --> 04:01.760
没什么复杂的

04:01.760 --> 04:02.760
一个个说吧

04:02.760 --> 04:04.760
首先说concat

04:04.760 --> 04:05.760
这个玩意是什么呢

04:05.760 --> 04:07.760
我们还是在浏览器里边给它演示

04:07.760 --> 04:12.160
把它打开

04:13.160 --> 04:14.160
下面

04:14.160 --> 04:15.160
数组

04:15.160 --> 04:16.160
第一个concat

04:16.160 --> 04:18.160
它用于拼接数组

04:18.160 --> 04:19.160
这啥意思

04:19.160 --> 04:21.160
比方说我有一个数组

04:21.160 --> 04:23.160
arr1等于123

04:23.160 --> 04:25.160
然后还有一个arr2

04:25.160 --> 04:27.160
等于234

04:27.160 --> 04:29.160
我想把两个数组拼接在一起

04:29.160 --> 04:30.160
那怎么做呢

04:30.160 --> 04:32.160
arr1concat

04:32.160 --> 04:34.160
arr2传进去就完事了

04:34.160 --> 04:35.160
就这么简单

04:35.160 --> 04:36.160
它反回一个数组

04:36.160 --> 04:37.160
是不是拼接的结果

04:37.160 --> 04:38.160
那么我们来看一下

04:38.160 --> 04:39.160
arr1有没有变动

04:39.160 --> 04:40.160
没有变动

04:40.160 --> 04:42.160
arr2有没有变动

04:42.160 --> 04:43.160
没有变动

04:43.160 --> 04:45.160
它是反回一个新数组

04:45.160 --> 04:47.160
新数组是拼接的结果

04:47.160 --> 04:48.160
是这么个意思

04:48.160 --> 04:50.160
就把这个数组的东西展开

04:50.160 --> 04:52.160
然后依次拼到

04:52.160 --> 04:54.160
第一个数组的后面

04:54.160 --> 04:56.160
arr1拼上arr2

04:56.160 --> 04:57.160
就这么个意思

04:57.160 --> 04:59.160
它其实还可以传入更多的纸

04:59.160 --> 05:01.160
比方说还有一个arr3

05:01.160 --> 05:04.160
等于678

05:04.160 --> 05:05.160
那么如果说我们可以

05:05.160 --> 05:06.160
把三个数组拼在一起

05:06.160 --> 05:08.160
那就是arr1concat

05:08.160 --> 05:10.160
arr2

05:10.160 --> 05:12.160
arr2

05:12.160 --> 05:13.160
那么这样子

05:13.160 --> 05:15.160
就三个数组拼在一起了

05:15.160 --> 05:16.160
concat

05:16.160 --> 05:17.160
就连接的意思

05:17.160 --> 05:19.160
然后这一块

05:19.160 --> 05:20.160
它其实还有很多的用法

05:20.160 --> 05:22.160
比方说arr1里面concat

05:22.160 --> 05:24.160
我们其实可以写一些固定的数值

05:24.160 --> 05:25.160
arr2

05:25.160 --> 05:26.160
arr3

05:26.160 --> 05:27.160
arr2

05:27.160 --> 05:28.160
arr1

05:28.160 --> 05:29.160
arr2

05:29.160 --> 05:30.160
arr3

05:30.160 --> 05:31.160
arr1

05:31.160 --> 05:32.160
arr2

05:32.160 --> 05:33.160
arr1

05:33.160 --> 05:34.160
arr2

05:34.160 --> 05:35.160
arr2

05:35.160 --> 05:36.160
arr2

05:36.160 --> 05:37.160
arr2

05:37.160 --> 05:38.160
arr2

05:38.160 --> 05:39.160
arr2

05:39.160 --> 05:40.160
arr2

05:40.160 --> 05:41.160
arr2

05:41.160 --> 05:42.160
arr2

05:42.160 --> 05:43.160
arr2

05:43.160 --> 05:44.160
arr2

05:44.160 --> 05:45.160
arr2

05:45.160 --> 05:46.160
arr1

05:46.160 --> 05:47.160
arr2

05:47.160 --> 05:48.160
arr2

05:48.160 --> 05:49.160
arr2

05:49.160 --> 05:50.160
arr2

05:50.160 --> 05:51.160
arr2

05:51.160 --> 05:52.160
arr2

05:52.160 --> 05:53.160
arr2

05:53.160 --> 05:54.160
arr2

05:54.160 --> 05:55.160
arr2

05:55.160 --> 05:56.160
arr2

05:56.160 --> 05:57.160
arr2

05:57.160 --> 05:58.160
arr2

05:58.160 --> 05:59.160
arr2

05:59.160 --> 06:00.160
arr2

06:00.160 --> 06:01.160
arr2

06:01.160 --> 06:02.160
arr2

06:02.160 --> 06:03.160
arr2

06:03.160 --> 06:04.160
arr2

06:04.160 --> 06:05.160
arr2

06:05.160 --> 06:06.160
arr2

06:06.160 --> 06:07.160
arr2

06:07.160 --> 06:08.160
arr2

06:08.160 --> 06:09.160
arr2

06:09.160 --> 06:10.160
arr2

06:10.160 --> 06:11.160
arr2

06:11.160 --> 06:12.160
arr2

06:12.160 --> 06:13.160
arr2

06:13.160 --> 06:14.160
arr2

06:14.160 --> 06:15.160
arr2

06:15.160 --> 06:16.160
arr2

06:16.160 --> 06:17.160
arr2

06:17.160 --> 06:18.160
arr2

06:18.160 --> 06:19.160
arr2

06:19.160 --> 06:20.160
arr2

06:20.160 --> 06:21.160
arr2

06:21.160 --> 06:22.160
arr2

06:22.160 --> 06:23.160
arr2

06:23.160 --> 06:24.160
arr2

06:24.160 --> 06:25.160
arr2

06:25.160 --> 06:26.160
arr2

06:26.160 --> 06:27.160
arr2

06:27.160 --> 06:28.160
arr2

06:28.160 --> 06:29.160
arr2

06:29.160 --> 06:30.160
arr2

06:30.160 --> 06:31.160
arr2

06:31.160 --> 06:32.160
arr2

06:32.160 --> 06:33.160
arr2

06:33.160 --> 06:34.160
arr2

06:34.160 --> 06:35.160
arr2

06:35.160 --> 06:36.160
arr2

06:36.160 --> 06:37.160
arr2

06:37.160 --> 06:38.160
arr2

06:38.160 --> 06:39.160
arr2

06:39.160 --> 06:40.160
arr2

06:40.160 --> 06:41.160
arr2

06:41.160 --> 06:42.160
arr2

06:42.160 --> 06:43.160
arr2

06:43.160 --> 06:44.160
arr2

06:44.160 --> 06:45.160
arr2

06:45.160 --> 06:46.160
arr2

06:46.160 --> 06:47.160
arr2

06:47.160 --> 06:48.160
arr2

06:48.160 --> 06:49.160
arr2

06:49.160 --> 06:50.160
arr2

06:50.160 --> 06:51.160
arr2

06:51.160 --> 06:52.160
arr2

06:52.160 --> 06:53.160
arr2

06:53.160 --> 06:54.160
arr2

06:54.160 --> 06:55.160
arr2

06:55.160 --> 06:56.160
arr2

06:56.160 --> 06:57.160
arr2

06:57.160 --> 06:58.160
arr2

06:58.160 --> 06:59.160
arr2

06:59.160 --> 07:00.160
arr2

07:00.160 --> 07:01.160
arr2

07:01.160 --> 07:02.160
arr2

07:02.160 --> 07:03.160
arr2

07:03.160 --> 07:04.160
arr2

07:04.160 --> 07:05.160
arr2

07:05.160 --> 07:06.160
arr2

07:06.160 --> 07:07.160
arr2

07:07.160 --> 07:08.160
arr2

07:08.160 --> 07:09.160
arr2

07:09.160 --> 07:10.160
arr2

07:10.160 --> 07:11.160
arr2

07:11.160 --> 07:12.160
arr2

07:12.160 --> 07:13.160
arr2

07:13.160 --> 07:14.160
arr2

07:14.160 --> 07:15.160
arr2

07:15.160 --> 07:16.160
arr2

07:16.160 --> 07:17.160
arr2

07:17.160 --> 07:18.160
arr2

07:18.160 --> 07:19.160
arr2

07:19.160 --> 07:20.160
arr2

07:20.160 --> 07:21.160
arr2

07:21.160 --> 07:22.160
arr2

07:22.160 --> 07:23.160
arr2

07:23.160 --> 07:24.160
arr2

07:24.160 --> 07:25.160
arr2

07:25.160 --> 07:26.160
arr2

07:26.160 --> 07:27.160
arr2

07:27.160 --> 07:28.160
arr2

07:28.160 --> 07:29.160
arr2

07:29.160 --> 07:30.160
arr2

07:30.160 --> 07:31.160
arr2

07:31.160 --> 07:32.160
arr2

07:32.160 --> 07:33.160
arr2

07:33.160 --> 07:34.160
arr2

07:34.160 --> 07:35.160
arr2

07:35.160 --> 07:36.160
arr2

07:36.160 --> 07:37.160
arr2

07:37.160 --> 07:38.160
arr2

07:38.160 --> 07:39.160
arr2

07:39.160 --> 07:40.160
arr2

07:40.160 --> 07:41.160
arr2

07:41.160 --> 07:42.160
arr2

07:42.160 --> 07:43.160
arr2

07:43.160 --> 07:44.160
arr2

07:44.160 --> 07:45.160
arr2

07:45.160 --> 07:46.160
arr2

07:46.160 --> 07:47.160
arr2

07:47.160 --> 07:48.160
arr2

07:48.160 --> 07:49.160
arr2

07:49.160 --> 07:50.160
arr2

07:50.160 --> 07:51.160
arr2

07:51.160 --> 07:52.160
arr2

07:52.160 --> 07:53.160
arr2

07:53.160 --> 07:54.160
arr2

07:54.160 --> 07:55.160
arr2

07:55.160 --> 07:56.160
arr2

07:56.160 --> 07:57.160
arr2

07:57.160 --> 07:58.160
arr2

07:58.160 --> 07:59.160
arr2

07:59.160 --> 08:00.160
arr2

08:00.160 --> 08:01.160
arr2

08:01.160 --> 08:02.160
arr2

08:02.160 --> 08:03.160
arr2

08:03.160 --> 08:04.160
arr2

08:04.160 --> 08:05.160
arr2

08:05.160 --> 08:06.160
arr2

08:06.160 --> 08:07.160
arr2

08:07.160 --> 08:08.160
arr2

08:08.160 --> 08:09.160
arr2

08:09.160 --> 08:10.160
arr2

08:10.160 --> 08:12.460
给他加一个A再加一个B

08:12.720 --> 08:14.760
可以加多个也可以加一个都行

08:15.020 --> 08:16.820
那于是呢我们看一下AR1

08:17.080 --> 08:18.860
是不是开吹多了一个AB

08:19.640 --> 08:20.660
就这么简单啊

08:20.920 --> 08:21.680
有什么复杂的呢

08:21.940 --> 08:22.960
还有这个Shift

08:23.220 --> 08:25.260
Shift是上面这个POP

08:25.520 --> 08:27.560
POP是删除数的最后一项

08:27.820 --> 08:28.600
AR1

08:29.100 --> 08:29.620
POP

08:29.880 --> 08:31.400
你看它最后一项是不是

08:31.660 --> 08:32.180
4

08:32.680 --> 08:33.960
对吧 我们给它删除了

08:34.740 --> 08:37.800
那么它会返回你删除的那一项

08:38.320 --> 08:39.860
那么现在我们再看AR1

08:40.060 --> 08:41.140
所以4就没了

08:41.660 --> 08:42.420
POP

08:42.680 --> 08:44.980
就弹出去 把尾巴给它弹出去

08:45.240 --> 08:46.520
POP就弹出去的意思

08:47.020 --> 08:48.320
还有一个就是Shift

08:48.580 --> 08:49.340
Shift就是

08:50.100 --> 08:51.120
把第1个

08:51.380 --> 08:51.900
弹出去

08:52.160 --> 08:53.420
把头弹出去

08:55.980 --> 08:58.540
那么这样子呢A就被弹出去了 我们看一下

08:59.320 --> 09:00.080
所以A就没了

09:00.340 --> 09:01.360
就这么简单啊

09:01.880 --> 09:03.920
好 下面这个有意思 下面这个Splice

09:04.440 --> 09:06.480
这个函数它可以做很多很多的事

09:06.740 --> 09:07.760
它可以做删除

09:08.020 --> 09:09.040
也可以做修改

09:09.240 --> 09:10.280
也可以做插入

09:10.540 --> 09:12.060
我们来看一下这个函数

09:12.320 --> 09:13.340
这个函数呢

09:13.600 --> 09:17.180
其实我们往往用它的时候 我们先说基本使用

09:17.440 --> 09:18.200
基本用它

09:18.460 --> 09:20.520
基本上我们用它的时候了 大部分时候

09:21.280 --> 09:22.300
都是在做

09:23.840 --> 09:25.380
都是在做那个删除

09:25.640 --> 09:26.660
比方说一个AR1

09:27.420 --> 09:28.700
重新刷新了

09:29.740 --> 09:30.240
AR2

09:31.260 --> 09:32.280
AR2 3 4 5 6

09:33.820 --> 09:35.880
比方说我们要删除这个4

09:36.380 --> 09:37.400
那我怎么来删呢

09:37.600 --> 09:38.200
我可以用

09:38.460 --> 09:43.240
因为它不在头也不在尾对吧 在头的话在尾的话我们就可以使用Pop和Shift

09:44.260 --> 09:45.800
但是它不在头也不在尾

09:46.060 --> 09:48.620
那怎么删呢 我们就可以使用Splice

09:49.900 --> 09:52.200
第1个参数写上下标

09:52.460 --> 09:54.000
第1个参数写上下标

09:54.260 --> 09:55.020
下标呢

09:55.280 --> 09:57.580
4的下标是多少 0 1 2

09:57.840 --> 09:59.120
对吧 下标为2

09:59.620 --> 10:03.460
第2个参数呢 表示删除几项 从下标为2的开始

10:03.720 --> 10:04.740
删除几项

10:04.860 --> 10:07.780
那我就删除一项 这样子的就把4给删掉了

10:08.280 --> 10:11.100
还会告诉你 删除了哪些呢 删除了一个4

10:11.360 --> 10:12.880
它会返回被删除的

10:13.140 --> 10:14.420
东西组成的数组

10:15.180 --> 10:16.340
好 我们再看AR

10:16.600 --> 10:17.240
说实在只有

10:17.500 --> 10:19.800
2 3 5 6了 4就没了对吧

10:20.060 --> 10:21.340
那如果说我们

10:21.840 --> 10:22.860
我们再来一次

10:25.590 --> 10:28.770
如果说我们现在要删除两项呢 怎么办呢

10:29.030 --> 10:30.710
我们就这样子写Splice

10:31.470 --> 10:32.750
下标为2开始

10:33.270 --> 10:35.830
删除两项 从这里开始 删除两项

10:35.850 --> 10:37.110
那么第2个参数就写2

10:37.370 --> 10:39.170
这样就删除了两项了 你看

10:39.670 --> 10:43.770
是不是只有2 3 6了 对吧 删除了4和5 它返回了删除的结果

10:44.270 --> 10:45.810
然后只剩下2 3 6了

10:46.330 --> 10:47.350
就这么个意思

10:47.610 --> 10:48.370
好 我们再来一次

10:48.890 --> 10:51.710
那它其实里边还可以做很多其他的事情 比方说

10:52.990 --> 10:54.010
看这AR

10:54.270 --> 10:56.310
我现在不仅要删除两项

10:56.830 --> 10:59.630
还要在删除的位置一次添加

10:59.890 --> 11:01.170
添加点1 2 3

11:01.690 --> 11:03.230
添加三项 那怎么做呢

11:03.490 --> 11:04.510
ARSplice

11:04.970 --> 11:05.730
下标为2

11:06.250 --> 11:08.810
删除两项 对吧 把4和5删除掉

11:09.330 --> 11:12.150
然后再添加1 2 3

11:13.670 --> 11:15.470
你看 它告诉你删除了4和5

11:15.730 --> 11:18.290
然后再看ARSplice 说这里变成了1 2 3

11:19.050 --> 11:20.070
就这么简单

11:20.330 --> 11:23.150
那如果说我不删除要插入呢 也可以

11:23.670 --> 11:24.430
就像这里边

11:25.190 --> 11:27.750
用法很灵活的 实际上是非常灵活的用法

11:28.270 --> 11:29.290
下标为2的位置

11:29.550 --> 11:30.830
就是说我从这个位置开始

11:31.090 --> 11:32.370
这个位置插入1 2 3

11:32.810 --> 11:35.010
我就删除零项

11:35.390 --> 11:36.410
插入1 2 3

11:37.690 --> 11:39.750
那么它告诉你 删除的东西没有

11:40.510 --> 11:41.550
我们看一下结果

11:42.310 --> 11:44.350
所以1 2 3被插入到这个位置了

11:44.870 --> 11:47.170
就这么简单 这就是Splice函数

11:47.430 --> 11:49.230
直播我们平时用的时候

11:49.470 --> 11:52.030
往往是做删除 其他都没有去操作

11:53.310 --> 11:55.350
接下来下一个Reverse

11:55.610 --> 11:58.950
将树中的元素顺序颠倒

11:59.630 --> 12:02.030
它不排序的 它不排序 它只是顺序颠倒

12:02.030 --> 12:04.810
比较说6 3 1 2 7 8

12:05.490 --> 12:07.610
那么我们只需要调用Reverse

12:09.650 --> 12:11.170
那么你看它返回的结果就是

12:11.610 --> 12:14.050
返过来都8 7 2 3 6

12:14.810 --> 12:17.010
就这么意思 我们来看AR也没有变化

12:17.130 --> 12:19.490
它也有变化 它会改动元素主

12:20.610 --> 12:23.090
Reverse 素主顺序颠倒

12:23.490 --> 12:26.810
还有下面这个 我先把下面这两个比较重要

12:27.090 --> 12:28.970
一个是Sort 表示排序

12:29.710 --> 12:33.270
这个排序它里面就有点神奇了

12:33.270 --> 12:34.550
我们给它看一下

12:35.150 --> 12:36.590
这个排序它是怎么排的呢

12:36.950 --> 12:39.470
比方说我们这里有一个AR

12:42.260 --> 12:43.660
1 2 3 4 5

12:44.460 --> 12:45.180
随便写吧

12:46.220 --> 12:49.300
2 7 1 6

12:50.300 --> 12:51.300
有这么一个数主

12:51.460 --> 12:53.940
现在我想把它排列成一个生序排序

12:53.940 --> 12:55.780
就是1 2 5 6 7

12:56.260 --> 12:58.220
我这里再加一个数字吧

12:58.640 --> 13:00.840
不然的话 同样再加一个数字

13:01.240 --> 13:02.840
加个11 好 我们来排一下

13:03.240 --> 13:04.920
它里面提供了一个Sort方法

13:05.600 --> 13:08.120
这个方法是确实是用来做排序的

13:08.840 --> 13:10.600
那如果说你不传参数的话

13:10.600 --> 13:13.120
我们来看一下 排序出来的数主是什么呢

13:13.880 --> 13:16.360
它变成这样子 1 1 2

13:16.360 --> 13:17.440
反正肯定是不对的

13:17.440 --> 13:19.240
1 1不应该出现在这个位置

13:19.880 --> 13:21.000
那它怎么回事呢

13:21.720 --> 13:24.600
默认情况下 如果说你不传参数

13:25.280 --> 13:27.720
它是不知道如何来比较大小的

13:27.780 --> 13:30.180
因为我们知道排序的最核心的东西是什么

13:30.580 --> 13:32.180
是要能够比较大小

13:33.060 --> 13:33.940
它才能排序

13:34.460 --> 13:36.340
它不比较大小就排不了序的

13:37.260 --> 13:38.940
你都不知道谁大谁小 你怎么排序

13:39.660 --> 13:41.180
因此它不知道比较大小

13:41.380 --> 13:42.500
为什么它不知道

13:42.500 --> 13:43.820
它怎么为什么这么傻呢

13:44.740 --> 13:45.340
它不是傻

13:45.820 --> 13:48.660
因为在介石里边数主的每一项

13:48.860 --> 13:50.300
它不一定是数字

13:51.620 --> 13:52.780
它又可能是字幅串

13:53.500 --> 13:55.500
它又可能是对箱

13:56.340 --> 13:57.380
它又可能是布尔

13:58.380 --> 14:00.980
这里我只不过这里臭巧了

14:00.980 --> 14:02.020
我全是数字

14:02.020 --> 14:03.580
那如果说是对箱怎么办

14:03.860 --> 14:04.860
它怎么来比较大小

14:05.100 --> 14:06.140
它没法比较大小了

14:06.700 --> 14:09.100
所以说它默认的排序方式是这样子的

14:09.740 --> 14:12.700
它会把这些玩意儿全部转成字幅串

14:13.020 --> 14:15.780
然后比较字幅串的编码来进行排序

14:16.100 --> 14:18.780
这默认方式我们就完全不用去考虑它了

14:18.780 --> 14:19.860
根本就不用去考虑它

14:20.260 --> 14:21.620
不能使用它的默认方式

14:22.540 --> 14:23.900
那比方说我们这里

14:24.140 --> 14:27.140
要用数字的方式来进行排序

14:27.280 --> 14:30.760
你就必须要告诉它哪个大哪个小

14:32.160 --> 14:34.480
你怎么告诉它哪个大哪个小呢

14:35.200 --> 14:37.880
你这里要传递一个非常奇怪的东西

14:37.880 --> 14:40.080
其实以后见多了也就不奇怪了

14:40.360 --> 14:42.360
要传一个函数进去

14:43.360 --> 14:44.720
就是我们这里要写个函数

14:44.720 --> 14:46.560
compair比较大小

14:47.880 --> 14:49.880
你要把这个函数给它传进去

14:50.800 --> 14:52.080
它得这么传

14:52.440 --> 14:53.200
知道了

14:53.800 --> 14:56.400
那么这个函数还得有两个参数

14:57.020 --> 14:59.740
这两个参数它到时候会调用这个函数

14:59.740 --> 15:01.260
它会在这个函数里边

15:02.020 --> 15:03.300
调用这个函数

15:03.820 --> 15:04.540
它不断的调用

15:04.540 --> 15:05.420
不是调用一次

15:05.420 --> 15:06.700
它会调用很多次

15:07.020 --> 15:09.900
它每一次调用的时候会给你传两个东西进来

15:10.140 --> 15:12.060
这两个东西你不用管它是啥

15:12.620 --> 15:14.780
你只需要知道它是数组的某一项就行了

15:14.780 --> 15:18.060
比方说它有可能把这个2传给A

15:18.580 --> 15:20.540
把这个11传给B

15:20.700 --> 15:22.140
它有可能这样传递

15:22.500 --> 15:24.500
也有可能它要把这个

15:24.980 --> 15:26.300
7传给A

15:26.860 --> 15:29.220
把这个1传给B都有可能

15:29.620 --> 15:32.100
反正这个A和B它就是数组里边

15:32.100 --> 15:33.180
某两项

15:33.180 --> 15:35.020
这个A和B就是数组里边

15:36.860 --> 15:37.380
A

15:38.580 --> 15:42.420
B是数组的其中两项

15:44.180 --> 15:46.740
好 那么这个时候你要怎么办呢

15:46.740 --> 15:49.620
你要怎么处理它才知道大小呢

15:50.180 --> 15:54.700
如果说A大于B你就传

15:54.800 --> 15:56.920
比方说我这里该打一个柱是吧

15:56.920 --> 15:57.720
生序排序

15:59.680 --> 16:03.920
A大于B就传正数

16:06.920 --> 16:10.760
然后反之传复数

16:11.280 --> 16:14.080
反之返回复数

16:16.080 --> 16:16.960
返回正数

16:17.880 --> 16:21.920
相等返回0你就这样来动

16:22.660 --> 16:25.220
生序排序A大于B就返回正数

16:25.620 --> 16:26.980
反之就返回复数

16:26.980 --> 16:28.220
相等就返回0

16:28.820 --> 16:29.540
就这么个意思

16:30.340 --> 16:33.500
好 那么你解就行了

16:33.500 --> 16:35.180
如果说A大于B

16:35.660 --> 16:37.540
那么就返回正数

16:37.540 --> 16:38.340
正数随便

16:38.340 --> 16:39.140
返回1也行

16:39.140 --> 16:39.740
2也行

16:39.740 --> 16:40.220
3也行

16:40.220 --> 16:40.860
都数随便

16:40.860 --> 16:41.580
我们就返回1嘛

16:42.100 --> 16:46.180
A小于B就返回复数

16:46.180 --> 16:47.020
复1

16:47.740 --> 16:49.820
A就返回0

16:50.520 --> 16:52.280
要告诉他比较的结果

16:52.840 --> 16:54.120
这就是他告诉他比较的结果

16:54.120 --> 16:55.240
通过返回值来比较

16:55.240 --> 16:56.200
告诉他比较的结果

16:56.760 --> 16:58.800
这里是有点神奇的

16:59.200 --> 17:00.640
把函数作为参数

17:00.640 --> 17:03.320
其实函数在GS里面没有什么特别的

17:03.320 --> 17:06.080
我们之前也说函数本身上就是一个对象

17:06.560 --> 17:07.840
其实你就是传了个对象进去

17:08.480 --> 17:10.480
它只不过传函数没有任何问题

17:11.200 --> 17:13.040
传递的时候也是引用传递

17:13.040 --> 17:13.960
传递指

17:14.400 --> 17:15.320
函数递指传过去

17:15.320 --> 17:16.000
没关系的

17:16.000 --> 17:17.000
函数是可以传递的

17:17.000 --> 17:18.400
以后见多了你就习惯了

17:18.400 --> 17:19.440
突破突破就习惯了

17:20.280 --> 17:21.680
那么把函数参传进去

17:21.680 --> 17:23.840
那么通过这个函数来告诉他

17:24.240 --> 17:26.360
他会问你这两个东西怎么来比较大小

17:26.840 --> 17:28.760
他在排序的时候一定会收集到比较大小

17:28.760 --> 17:29.280
他不知道

17:29.960 --> 17:32.120
那你就告诉他A和B怎么来比较大小

17:32.120 --> 17:34.600
如果说他A大于B你就返回1

17:34.920 --> 17:36.400
小于B就返回复一

17:37.000 --> 17:37.720
否则返回0

17:39.240 --> 17:40.760
那如果说是要将续排序

17:40.760 --> 17:41.560
就返过来呗

17:41.800 --> 17:43.040
A大于B返回复一

17:43.440 --> 17:45.480
A小于B返回1相等返回1

17:46.000 --> 17:47.480
好 这样子一完事之后

17:47.480 --> 17:48.400
我们来运行看一下

17:48.860 --> 17:49.940
是不是可以生虚排序了

17:50.500 --> 17:52.500
排序这里要传一个函数进去

17:53.140 --> 17:54.620
当然你会发现函数

17:55.620 --> 17:57.020
就是临时用一下

17:57.500 --> 17:58.860
是不是就这个函数没有别的用法

17:58.860 --> 17:59.140
对吧

17:59.140 --> 18:00.580
其他地方你不会调用这个函数吧

18:01.020 --> 18:01.580
不会吧

18:01.580 --> 18:03.060
你只有在这里会用一下

18:03.060 --> 18:04.180
那么这个时候

18:04.180 --> 18:06.300
我们知道函数上任何东西

18:06.300 --> 18:07.340
你可以传辨量

18:07.820 --> 18:08.540
也可以传什么

18:08.540 --> 18:09.540
也可以传表达诗

18:10.060 --> 18:11.700
你是不是可以直接把表达诗写到这

18:12.500 --> 18:13.700
这是我们常见的写法

18:14.620 --> 18:16.220
直接在这里写个函数表达诗

18:16.280 --> 18:17.080
对吧 我不需要给

18:17.080 --> 18:18.840
因为表达诗就不需要有名字的

18:18.840 --> 18:19.960
你写名字也无所谓

18:19.960 --> 18:20.920
但是没什么意义

18:20.920 --> 18:21.920
就不需要有名字

18:22.360 --> 18:23.800
那效果是完全一样的

18:24.240 --> 18:25.520
好 同学们听好了

18:26.000 --> 18:28.040
这里有一个重要的词出现了

18:30.400 --> 18:33.840
当函数作为参数传递

18:36.240 --> 18:40.080
该函数称之为毁掉函数

18:41.920 --> 18:44.920
如果说一个函数被作为参数传递

18:44.920 --> 18:46.720
这个函数称之为毁掉函数

18:46.860 --> 18:48.460
你只需要知道这个名字就行了

18:48.460 --> 18:51.020
你不用去知道这个毁什么叫毁掉

18:51.020 --> 18:53.180
毁掉函数的因为它是callback

18:54.380 --> 18:55.740
后边慢慢就秦出了

18:55.740 --> 18:57.740
后边我们还会说到毁掉函数的

18:58.580 --> 19:00.580
你只需要知道这个函数作为参数传递

19:00.580 --> 19:03.060
那么这个函数它的名字叫做毁掉函数

19:03.580 --> 19:04.580
它就这么一个说法

19:04.580 --> 19:05.420
其实没有什么特别的

19:05.420 --> 19:06.380
就是传了一个函数进去

19:07.380 --> 19:08.780
把函数作为参数传递进去了

19:09.180 --> 19:10.620
OK 那么这是生讯

19:10.620 --> 19:11.940
那如果说是将讯

19:11.940 --> 19:13.060
将讯就反过来

19:13.060 --> 19:15.300
这里反回1 这里反回

19:16.280 --> 19:17.360
就反过来不就将讯了吗

19:18.720 --> 19:20.400
其实这个单码还可以减化

19:22.240 --> 19:23.560
怎么可以怎么减化呢

19:24.440 --> 19:25.880
你看A大于B

19:25.880 --> 19:27.360
因为我们这里面全是数字

19:27.800 --> 19:28.720
所以全是数字

19:29.960 --> 19:32.320
那A大于B是不是就返回正数

19:32.320 --> 19:34.520
A小于B是不是返回负数

19:34.520 --> 19:35.960
A等于B是不是返回0

19:37.040 --> 19:39.520
那这个正数负数0

19:39.520 --> 19:42.640
是不是刚好跟A减B的结果是一样的

19:43.620 --> 19:45.620
是不是一样的对吧

19:45.620 --> 19:48.540
A大于B是不是就A减B是正数

19:48.540 --> 19:51.540
A小于B是不是A减B就是负数

19:51.540 --> 19:54.540
A等于B是不是A减B就是0

19:54.540 --> 19:57.540
那你直接返回A减B就是完事了

19:58.540 --> 20:00.540
所以就完事了

20:01.540 --> 20:03.540
A大于B就是正数

20:03.540 --> 20:04.540
那就返回1

20:04.540 --> 20:06.540
A小于B那就返回正数

20:06.540 --> 20:07.540
不一定是1

20:07.540 --> 20:10.540
A小于B那就是一减就是负数

20:10.540 --> 20:11.540
那就返回负数

20:12.440 --> 20:13.440
相等于返回0

20:13.440 --> 20:15.440
所以这样子写也可以

20:15.440 --> 20:17.440
那如果说倒去排序就是B减A

20:18.440 --> 20:20.440
所以就完事了

20:20.440 --> 20:22.440
就这么个意思

20:22.440 --> 20:23.440
A减B

20:23.440 --> 20:25.440
那如果说

20:26.440 --> 20:28.440
我要随机排序

20:28.440 --> 20:30.440
就是我的排序不是说

20:30.440 --> 20:32.440
我生序和倒去

20:32.440 --> 20:34.440
我要把数字打乱

20:34.440 --> 20:35.440
随机

20:35.440 --> 20:36.440
那这个怎么排呢

20:36.440 --> 20:37.440
什么叫随机

20:37.440 --> 20:39.440
随机的意思

20:40.340 --> 20:42.340
随机排序

20:42.340 --> 20:44.340
sort

20:44.340 --> 20:46.340
A减B

20:46.340 --> 20:48.340
那我应该返回啥呢

20:48.340 --> 20:50.340
也就是我有可能是正数

20:50.340 --> 20:51.340
也有可能是负数

20:51.340 --> 20:52.340
也有可能是0

20:52.340 --> 20:54.340
跟A减B没关系

20:54.340 --> 20:56.340
像这种跟A减B没关系的话

20:56.340 --> 20:57.340
就用不到

20:57.340 --> 20:59.340
你在这个函数里面用不到A减B的话

20:59.340 --> 21:01.340
其实可以省略这个参数

21:01.340 --> 21:03.340
是可以不写的

21:03.340 --> 21:05.340
用不到嘛对吧

21:05.340 --> 21:07.340
其实编辑写有在提示

21:07.340 --> 21:09.340
你看这个明显的文字是不是变暗了

21:10.240 --> 21:12.240
所以你现在还没有用到A和B

21:12.240 --> 21:14.240
你用到它就不会变暗了

21:14.240 --> 21:16.240
比方说你这里用到了一个A

21:16.240 --> 21:18.240
你看A是不是变亮了

21:18.240 --> 21:20.240
其实有在提示你

21:20.240 --> 21:22.240
变暗的东西其实可以删除掉的

21:22.240 --> 21:24.240
你用不到嘛对吧

21:24.240 --> 21:26.240
那么你说跟A和B没关系

21:26.240 --> 21:27.240
管A和B是啥

21:27.240 --> 21:28.240
我有可能返回正数

21:28.240 --> 21:29.240
有可能返回负数

21:29.240 --> 21:31.240
有可能返回0

21:31.240 --> 21:33.240
那我这个代码怎么写

21:33.240 --> 21:35.240
你可以这样子写

21:35.240 --> 21:37.240
这个玩意是不是产生0到1

21:38.140 --> 21:40.140
所以50%的几率是负数

21:40.140 --> 21:42.140
50%的几率是正数

21:42.140 --> 21:44.140
还有一个极小的几率是0

21:44.140 --> 21:46.140
是不是就去玩了

21:46.140 --> 21:48.140
我来看一下

21:48.140 --> 21:50.140
这就随机排序了

21:50.140 --> 21:52.140
每一次都可能不一样

21:52.140 --> 21:54.140
对数组的顺序打乱

21:54.140 --> 21:56.140
这就是说

21:56.140 --> 21:58.140
这一会关于排序

21:58.140 --> 22:00.140
它传的是一个好的数

22:00.140 --> 22:02.140
好,那么接下来

22:02.140 --> 22:04.140
下边这个Slice

22:04.140 --> 22:06.140
对数组进行切割

22:06.160 --> 22:08.160
其实它函数很简单

22:08.160 --> 22:10.160
它有一个很特别的用处

22:10.160 --> 22:12.160
比方说我们这有个数组

22:12.160 --> 22:14.160
我想只取数组的这一部分

22:14.160 --> 22:16.160
那么怎么来写呢

22:16.160 --> 22:18.160
就ARSlice

22:18.160 --> 22:20.160
好,里边呢

22:20.160 --> 22:22.160
只取这一部分

22:22.160 --> 22:24.160
给它传第一个参数就是

22:24.160 --> 22:26.160
起始下标

22:26.160 --> 22:28.160
起始下标是一个1

22:28.160 --> 22:30.160
下标为1开始

22:30.160 --> 22:32.160
好,第二个参数呢

22:32.160 --> 22:34.160
是传结束下标

22:34.180 --> 22:36.180
是不是1,2,3

22:36.180 --> 22:38.180
下标为3

22:38.180 --> 22:40.180
它取不到结束下标

22:40.180 --> 22:42.180
因此你要传4

22:42.180 --> 22:44.180
这样子它会返回一个新数组

22:44.180 --> 22:46.180
它不会改变原数组

22:46.180 --> 22:48.180
返回一个新数组

22:48.180 --> 22:50.180
那么这个新数组就是切割之后的结果

22:50.180 --> 22:52.180
它原数组不变

22:52.180 --> 22:54.180
是不是2,7,11

22:54.180 --> 22:56.180
它取不到最后一个位置

22:56.180 --> 22:58.180
那如果说你不传第二个参数呢

22:58.180 --> 23:00.180
它就是从1开始

23:00.180 --> 23:02.180
从这里开始取到末尾

23:02.200 --> 23:04.200
是不是取到末尾

23:04.200 --> 23:05.200
对吧

23:05.200 --> 23:07.200
那如果说你第一个参数传的是

23:07.200 --> 23:09.200
不传

23:09.200 --> 23:10.200
我看一下,试一下

23:10.200 --> 23:11.200
不传

23:11.200 --> 23:13.200
或者是第一个参数传的是你

23:13.200 --> 23:15.200
那么就是从这个数组一开始

23:15.200 --> 23:17.200
取到末尾

23:17.200 --> 23:19.200
哎,它说这有啥意义啊

23:19.200 --> 23:21.200
那不是就是原数组吗

23:21.200 --> 23:23.200
不一样的

23:23.200 --> 23:25.200
这叫做数组拷贝克隆

23:25.200 --> 23:27.200
数组拷贝克隆

23:27.200 --> 23:29.200
虽然说这个新数组

23:29.200 --> 23:31.200
跟原数组长得一模一样

23:31.200 --> 23:33.200
但是它们两个是不相等的

23:33.200 --> 23:35.200
知道吧

23:35.200 --> 23:37.200
它们两个

23:37.200 --> 23:39.200
它们两个是force

23:39.200 --> 23:41.200
不相等的

23:41.200 --> 23:44.710
为什么不相等啊

23:44.710 --> 23:46.710
就跟这里道理是一样的

23:46.710 --> 23:48.710
比方说obj1

23:48.710 --> 23:50.710
是个空对象

23:50.710 --> 23:52.710
obj2也是个空对象

23:52.710 --> 23:54.710
这两个对象相等嘛

23:54.710 --> 23:56.710
它们肯定是不相等的

23:56.710 --> 23:58.710
为什么

23:58.710 --> 24:00.710
你学到现在了

24:00.710 --> 24:02.710
不断的强调过

24:02.710 --> 24:04.710
你看到这个大货号

24:04.710 --> 24:06.710
就相当于是new了一个obj

24:06.710 --> 24:08.710
是不是新创建了一个对象

24:08.710 --> 24:10.710
这里也是新创建了一个对象

24:10.710 --> 24:12.710
对吧

24:12.710 --> 24:14.710
它们里面存的地址是不一样的

24:14.710 --> 24:16.710
只不过这两个对象长得一模一样

24:16.710 --> 24:18.710
就好比说

24:18.710 --> 24:20.710
现在邓格整容

24:20.710 --> 24:22.710
整成迪地热巴

24:22.710 --> 24:24.710
跟迪地热巴长成一模一样

24:24.710 --> 24:26.710
但是它说是两个人啊

24:26.710 --> 24:28.710
就这么个意思

24:28.710 --> 24:30.710
即是nice

24:30.710 --> 24:32.710
虽然说我从零开始取出

24:32.710 --> 24:34.710
取出来的结果一模一样

24:34.710 --> 24:36.710
但是它是两个不同的数组

24:36.710 --> 24:38.710
这就是数组克龙

24:38.710 --> 24:40.710
因此snice这个函数

24:40.710 --> 24:42.710
切割数组的时候

24:42.710 --> 24:44.710
用的反而比较少

24:44.710 --> 24:46.710
有的时候也会用

24:46.710 --> 24:48.710
反而我们用数组克龙

24:48.710 --> 24:50.710
这种做法去完成一个数组克龙

24:50.710 --> 24:52.710
用的比较多

24:52.710 --> 24:54.710
这样我就产生了两个一模一样的数组

24:54.710 --> 24:56.710
之后我去改动它

24:56.710 --> 24:58.710
不过不是现在

24:58.710 --> 25:00.710
是将来

25:00.710 --> 25:02.710
懂了意思吧

25:02.710 --> 25:04.710
这是这个数组克龙

25:04.710 --> 25:06.710
那有的时候snice还有一些特别的用处

25:06.710 --> 25:08.710
比方说我现在有这么一个

25:08.710 --> 25:10.710
尾数组

25:10.710 --> 25:12.710
将来我们会看到有很多的尾数组

25:12.710 --> 25:14.710
它长得跟数组一模一样

25:14.710 --> 25:16.710
它不是数组

25:16.710 --> 25:18.710
它不是六儿瑞出现产生的

25:18.710 --> 25:20.710
因为我们知道写中货号

25:20.710 --> 25:22.710
它相当于是六儿瑞

25:22.710 --> 25:24.710
它不是六儿瑞产生的

25:24.710 --> 25:26.710
这就是一个尾数组

25:26.710 --> 25:28.710
它长得跟数组

25:28.710 --> 25:30.710
看上去差不多

25:30.710 --> 25:32.710
那么我如何把它变成一个

25:32.710 --> 25:34.710
那我如何来判断它是不是真数组

25:34.710 --> 25:36.710
是不是我们说过通过什么判断

25:36.710 --> 25:38.710
Instantial

25:38.710 --> 25:40.710
它的原型链上

25:40.710 --> 25:42.710
有没有儿瑞

25:42.710 --> 25:44.710
那肯定是没有的

25:44.710 --> 25:46.710
它是一个普通对象

25:46.710 --> 25:48.710
那我们如何把它变成一个真数组

25:48.710 --> 25:50.710
所以说这个里面它是不可能存在

25:50.710 --> 25:52.710
数组里面的方法的

25:52.710 --> 25:54.710
根本就没有这个方法

25:54.710 --> 25:56.710
有什么措施吗?没有

25:56.710 --> 25:58.710
有的时候为了方便对它进行操作

25:58.710 --> 26:00.710
我们需要把它转成真数组

26:00.710 --> 26:02.710
因为只有真数组里面才有各种各样的函数

26:02.710 --> 26:04.710
它这些方法才能用

26:04.710 --> 26:06.710
所以说我们要转成真数组

26:06.710 --> 26:08.710
那怎么来转呢?

26:08.710 --> 26:10.710
我们就可以使用Sness

26:10.710 --> 26:12.710
我们通过这个

26:12.710 --> 26:14.710
这个函数在哪儿?

26:14.710 --> 26:16.710
那现在没有数组了

26:16.710 --> 26:18.710
你不能用OBG的Sness

26:18.710 --> 26:20.710
它没有这个函数了

26:20.710 --> 26:22.710
原型上边

26:22.710 --> 26:24.710
那么我们平时调的时候

26:24.710 --> 26:26.710
是不是通过一个数组来调用的

26:26.710 --> 26:28.710
为什么要通过数组调用

26:28.710 --> 26:30.710
不然的话它怎么知道要对哪个数组来进行切割呢

26:30.710 --> 26:32.710
所以说它里面一定用到了Z

26:32.710 --> 26:34.710
它不用Z的话

26:34.710 --> 26:36.710
它怎么知道就给它传了一个0

26:36.710 --> 26:38.710
它怎么知道要对哪个数组

26:38.710 --> 26:40.710
进行切割

26:40.710 --> 26:42.710
它肯定是对Z是对它来进行切割

26:42.710 --> 26:44.710
所以说我们现在

26:44.710 --> 26:46.710
调用Sness的时候要用Core

26:46.710 --> 26:48.710
告诉它Z是啥

26:48.710 --> 26:50.710
告诉它Z是这个

26:50.710 --> 26:52.710
你现在给我切割这个东西

26:52.710 --> 26:54.710
它是不是数组?不是

26:54.710 --> 26:56.710
不过没关系,它是一个伪数组

26:56.710 --> 26:58.710
也可以切割的

26:58.710 --> 27:00.710
切割这个数组

27:00.710 --> 27:02.710
从哪里开始切割呢?从0开始切割

27:02.710 --> 27:04.710
当然也可以不传这个参数

27:04.710 --> 27:06.710
因为不传的话

27:06.710 --> 27:08.710
默认就是从0开始切割

27:08.710 --> 27:10.710
就调用这个

27:10.710 --> 27:12.710
它就会返回一个新数组

27:12.710 --> 27:14.710
那么这个新数组就是真正的数组

27:14.710 --> 27:19.110
我们来打印一下这个

27:19.110 --> 27:21.110
运行

27:21.110 --> 27:23.110
所以变成真数组了

27:23.110 --> 27:25.110
我们来看一下Instance

27:25.110 --> 27:27.110
这就是我们以后

27:27.110 --> 27:29.110
一种常见的

27:29.110 --> 27:31.110
把伪数组变成真数组的方式

27:31.110 --> 27:33.110
就用Sness

27:33.110 --> 27:35.110
然后绑定Z

27:35.110 --> 27:37.110
把它当成Z

27:37.110 --> 27:39.110
那么就相当于是OBG.Sness

27:39.110 --> 27:41.110
对吧?你这里不率也是这样

27:41.110 --> 27:43.110
AR.Sness

27:43.110 --> 27:45.110
那么它里面的Z就指向它了

27:45.110 --> 27:47.110
那我这里直接绑定Z

27:47.110 --> 27:49.110
对吧?这是一种邪法

27:49.110 --> 27:51.110
这种邪法是最好的邪法

27:51.110 --> 27:52.110
是政府的邪法

27:52.110 --> 27:53.110
那么有的时候

27:53.110 --> 27:55.110
你们以后在公司里面还会看到这种邪法

27:55.110 --> 27:58.740
还会看到这种邪法

27:58.740 --> 28:00.740
效果是一样的

28:00.740 --> 28:02.740
就是我产生一个数组实力

28:02.740 --> 28:03.740
对吧?

28:03.740 --> 28:05.740
这个玩意不就是一个6的AR.Sness吗?

28:05.740 --> 28:07.740
产生一个数组实力

28:07.740 --> 28:09.740
我不是要用这个数组

28:09.740 --> 28:11.740
而我是想用它里面的一个方法

28:11.740 --> 28:12.740
叫Sness

28:12.740 --> 28:13.740
然后调用它的货

28:13.740 --> 28:15.740
绑定Z为OBG

28:15.740 --> 28:17.740
也是一样的效果

28:17.740 --> 28:18.740
只不过这种邪法呢

28:18.740 --> 28:19.740
没有上边的好

28:19.740 --> 28:20.740
为什么?

28:20.740 --> 28:22.740
因为上边不会产生额外的东西

28:22.740 --> 28:24.740
是不是不会产生额外的东西

28:24.740 --> 28:25.740
而下面这个代码呢

28:25.740 --> 28:27.740
会产生一个新数组

28:27.740 --> 28:29.740
尽管那个新数组很快就消失了

28:29.740 --> 28:31.740
那两种邪法都是可以的

28:31.740 --> 28:33.740
都是可以的

28:33.740 --> 28:35.740
好,这是关于这个Sness

28:35.740 --> 28:38.740
OK,那我们数组的API就讲完了

28:38.740 --> 28:39.740
目前就这么一些

28:39.740 --> 28:41.740
好,接下来我们来做题

28:41.740 --> 28:42.740
几道题呢?

28:42.740 --> 28:43.740
七道题

28:43.740 --> 28:44.740
来吧

28:44.740 --> 28:46.740
都很简单

28:46.740 --> 28:49.740
第一道题就是要熟练一下数据的

28:49.740 --> 28:50.740
这些常见的API

28:50.740 --> 28:53.740
把下面多个数组拼接成一个数组

28:54.740 --> 28:56.740
那还不简单吗?

28:56.740 --> 28:57.740
拼呗

28:57.740 --> 28:59.740
Concrete

28:59.740 --> 29:01.740
然后NumS

29:01.740 --> 29:02.740
二

29:02.740 --> 29:03.740
NumS

29:03.740 --> 29:04.740
三

29:04.740 --> 29:05.740
NumS

29:05.740 --> 29:07.740
没了

29:07.740 --> 29:09.740
把二和三拼接进去

29:09.740 --> 29:11.740
不就完了吗?

29:11.740 --> 29:12.740
那就全都有了

29:12.740 --> 29:13.740
对吧

29:13.740 --> 29:14.740
这是第一题

29:14.740 --> 29:15.740
非常简单

29:15.740 --> 29:19.740
三除数组中所有的制服串

29:19.740 --> 29:21.740
要做三除了

29:21.740 --> 29:22.740
但三除哪一个呢?

29:22.740 --> 29:23.740
三除所有的制服串

29:23.740 --> 29:24.740
那么这个数组

29:24.740 --> 29:26.740
你不要在这里给我删了

29:26.740 --> 29:28.740
我不相信学到现在

29:28.740 --> 29:30.740
还有同学敢去做这种事情

29:30.740 --> 29:32.740
因为这个数组将来会变化的

29:32.740 --> 29:33.740
而且你有可能不知道

29:33.740 --> 29:35.740
这个数组里面包含了哪些东西

29:35.740 --> 29:37.740
所以说你只能便利

29:37.740 --> 29:39.740
便利数组每一下

29:39.740 --> 29:40.740
对吧

29:40.740 --> 29:41.740
然后干嘛呀?

29:41.740 --> 29:43.740
判断数组

29:43.740 --> 29:45.740
判断这一项

29:45.740 --> 29:46.740
什么叫这一项?

29:46.740 --> 29:48.740
就是我们的保存一下吧

29:48.740 --> 29:49.740
就是Item

29:49.740 --> 29:50.740
NumS

29:50.740 --> 29:51.740
就这一项

29:51.740 --> 29:53.740
判断Item

29:53.740 --> 29:55.740
是否是制服串

29:55.740 --> 29:57.740
如果是

29:57.740 --> 29:59.740
则将其

29:59.740 --> 30:01.740
删除

30:01.740 --> 30:03.740
或者是判断它

30:03.740 --> 30:04.740
是不是制服串

30:04.740 --> 30:05.740
都一样的

30:05.740 --> 30:06.740
你把保存到变量里面

30:06.740 --> 30:08.740
或者直接使用那个表达式来判断

30:08.740 --> 30:09.740
都一样

30:09.740 --> 30:11.740
好了怎么来判断它是不是制服串呢?

30:11.740 --> 30:12.740
是不是通过Type

30:13.740 --> 30:14.740
Type

30:14.740 --> 30:16.740
这个玩意可以当函数使用

30:16.740 --> 30:18.740
也可以当成一个关键字使用

30:18.740 --> 30:21.740
TypeNumS i

30:21.740 --> 30:23.740
是不是等于Stune

30:23.740 --> 30:25.740
它是不是制服串

30:25.740 --> 30:27.740
那么如果是制服串怎么办呀?

30:27.740 --> 30:28.740
是不是要把它删除?

30:28.740 --> 30:30.740
那怎么来删除呢?

30:30.740 --> 30:31.740
怎么删除?

30:31.740 --> 30:33.740
是不是数组里面一个方法叫Splice

30:34.740 --> 30:36.740
删除从哪个位置开始删

30:36.740 --> 30:37.740
从哪个位置呢?

30:37.740 --> 30:38.740
从i这个位置

30:38.740 --> 30:39.740
因为di这个位置

30:39.740 --> 30:41.740
它是不是制服串吗?

30:41.740 --> 30:43.740
它是制服串就从这个位置开始删

30:43.740 --> 30:44.740
删几个呢?

30:44.740 --> 30:45.740
删一个

30:45.740 --> 30:46.740
删完了

30:46.740 --> 30:48.740
我们来看一下这个数组的结果

30:48.740 --> 30:52.080
你会看到

30:52.080 --> 30:53.080
有没有删了

30:53.080 --> 30:54.080
它确实有删

30:54.080 --> 30:55.080
它把这个东西删了

30:55.080 --> 30:57.080
它把这个东西删了

30:57.080 --> 30:58.080
但是这个玩意没删

30:58.080 --> 30:59.080
这个玩意没删

30:59.080 --> 31:01.080
是不是A比较特殊啊

31:01.080 --> 31:03.080
那你把这里写成C

31:03.080 --> 31:05.080
你会发现C也没有删

31:06.080 --> 31:08.080
那是怎么回事呢?

31:08.080 --> 31:10.080
这里给同学们讲一讲

31:10.080 --> 31:13.080
关于在循环中删除数组元素

31:13.080 --> 31:14.080
会带来一个问题

31:14.080 --> 31:15.080
这个问题呢

31:15.080 --> 31:17.080
其实你通过逻辑分析

31:17.080 --> 31:18.080
不是什么新知识

31:18.080 --> 31:21.080
它通过逻辑分析都能够分析得出来

31:21.080 --> 31:23.080
我把这个数组给它复制一下

31:23.080 --> 31:24.080
看一下这个问题是怎么回

31:24.080 --> 31:28.540
怎么产生的

31:28.540 --> 31:29.540
那么循环的时候

31:29.540 --> 31:30.540
我们怎么循环的

31:30.540 --> 31:31.540
是不是有个i

31:31.540 --> 31:33.540
对吧?i从0开始

31:33.540 --> 31:35.540
看0这一项要不要删啊

31:35.540 --> 31:36.540
不删不动

31:36.540 --> 31:37.540
进不了判断吧

31:37.540 --> 31:38.540
不动

31:38.540 --> 31:39.540
然后i++

31:39.540 --> 31:40.540
是不是i++

31:40.540 --> 31:41.540
加加过后

31:41.540 --> 31:42.540
是不是i等于1

31:42.540 --> 31:43.540
看这一项

31:43.540 --> 31:44.540
这一项能不能删啊

31:44.540 --> 31:45.540
也不能

31:45.540 --> 31:46.540
说不动

31:46.540 --> 31:47.540
i等于2

31:47.540 --> 31:49.540
这一项能不能删

31:49.540 --> 31:50.540
是不是可以删

31:50.540 --> 31:52.540
于是我就把它删除掉了

31:52.540 --> 31:54.540
这一删除掉之后

31:54.540 --> 31:55.540
你看

31:55.540 --> 31:57.540
整个数组后边的下标

31:57.540 --> 31:59.540
全部潜移了

31:59.540 --> 32:00.540
懂了意思吗

32:00.540 --> 32:03.540
是这样子下标就全部潜移了

32:03.540 --> 32:04.540
好,那么现在呢

32:04.540 --> 32:06.540
接下来又是i++对吧

32:06.540 --> 32:08.540
刚才把下标为2的3了

32:08.540 --> 32:09.540
现在下一次循环

32:09.540 --> 32:10.540
下一次循环i++

32:10.540 --> 32:11.540
还有等于3了

32:11.540 --> 32:12.540
i等于3是哪一位

32:12.540 --> 32:13.540
是不是这一位

32:13.540 --> 32:15.540
就相当于是挑过了这一位

32:15.540 --> 32:16.540
懂了意思吧

32:16.540 --> 32:18.540
就好好去梳理一下

32:18.540 --> 32:19.540
问题在哪呢

32:19.540 --> 32:21.540
问题就是在我3了之后

32:21.540 --> 32:22.540
如果说3了之后

32:22.540 --> 32:23.540
这里没动

32:23.540 --> 32:24.540
那就没问题

32:24.540 --> 32:25.540
但是3了之后

32:25.540 --> 32:27.540
后面的下标全部变了

32:27.540 --> 32:28.540
变得潜移了

32:28.540 --> 32:29.540
潜移过后

32:29.540 --> 32:30.540
我啥也没管

32:30.540 --> 32:32.540
我就继续i++

32:32.540 --> 32:33.540
于是呢

32:33.540 --> 32:34.540
就挑过了这一项

32:34.540 --> 32:35.540
因此

32:35.540 --> 32:36.540
我们正确的做法是什么

32:36.540 --> 32:38.540
是把这一项3了之后

32:38.540 --> 32:39.540
只要出现了3处

32:39.540 --> 32:40.540
3了之后

32:41.540 --> 32:43.540
我这一项要重新看一下

32:43.540 --> 32:45.540
要重新看一下这一项

32:45.540 --> 32:46.540
因为这一项

32:46.540 --> 32:47.540
后面的下标

32:47.540 --> 32:48.540
后面的就补过来了

32:48.540 --> 32:49.540
就补过来了

32:49.540 --> 32:50.540
那么这一项

32:50.540 --> 32:51.540
我要重新看一下

32:51.540 --> 32:52.540
因为这一项

32:52.540 --> 32:53.540
有可能还要被3

32:53.540 --> 32:54.540
懂了意思吧

32:54.540 --> 32:55.540
那我怎么来重新看一下

32:55.540 --> 32:56.540
这一项呢

32:56.540 --> 32:57.540
其实非常简单

32:57.540 --> 32:59.540
你只需要把i-1

32:59.540 --> 33:00.540
就行了

33:00.540 --> 33:01.540
只要i-1过后

33:01.540 --> 33:02.540
i是不是在这了

33:02.540 --> 33:04.540
然后再来进行i++

33:04.540 --> 33:05.540
是不是又挑了这了

33:06.540 --> 33:07.540
所以说

33:07.540 --> 33:08.540
你每一次3了

33:08.540 --> 33:09.540
在循环里边

33:09.540 --> 33:10.540
3了之后

33:10.540 --> 33:12.540
i-1

33:12.540 --> 33:14.540
它就没问题了

33:14.540 --> 33:16.540
就这一个小的细节

33:16.540 --> 33:17.540
在循环里边3处

33:17.540 --> 33:18.540
要注意一下

33:18.540 --> 33:19.540
好

33:19.540 --> 33:20.540
第三题

33:20.540 --> 33:22.540
数组去从

33:22.540 --> 33:23.540
还是一项一样的数组

33:23.540 --> 33:24.540
我要把这个数组里边

33:24.540 --> 33:26.540
重复的向全部去掉

33:26.540 --> 33:27.540
重复的向

33:27.540 --> 33:28.540
我们肯定要用

33:28.540 --> 33:29.540
严格相等

33:29.540 --> 33:30.540
像这个东西

33:30.540 --> 33:31.540
以这个伺服串的仪

33:31.540 --> 33:32.540
和这个数字仪

33:32.540 --> 33:33.540
它们虽然都是仪

33:33.540 --> 33:35.540
但是它类型不一样

33:35.540 --> 33:36.540
那么也是不同的

33:36.540 --> 33:38.540
我们说完全相同

33:39.540 --> 33:40.540
那么这个数组去从

33:40.540 --> 33:41.540
怎么去呢

33:41.540 --> 33:42.540
之前

33:42.540 --> 33:43.540
如果说

33:43.540 --> 33:45.540
诚哥在GSE课程里看的话

33:45.540 --> 33:46.540
里边讲到了数组去从

33:46.540 --> 33:48.540
有一些比较取巧的办法

33:48.540 --> 33:49.540
有些比较巧妙的办法

33:49.540 --> 33:50.540
不过我这里

33:50.540 --> 33:51.540
故意给你做出来

33:51.540 --> 33:52.540
这么一个数组

33:52.540 --> 33:54.540
让你没有取巧的办法

33:54.540 --> 33:56.540
那就是严格按照

33:56.540 --> 33:58.540
数组去从的

33:58.540 --> 34:00.540
最笨也是最实用的办法

34:00.540 --> 34:01.540
来进行去从

34:01.540 --> 34:03.540
那如何去从呢

34:05.540 --> 34:06.540
怎么去从

34:06.540 --> 34:08.540
其实就是

34:08.540 --> 34:10.540
找到数组的每一项

34:10.540 --> 34:11.540
找到第一项

34:11.540 --> 34:14.540
看一下第一项里边

34:15.540 --> 34:17.540
除了就是从这一项开始

34:17.540 --> 34:18.540
后边有没有等于

34:18.540 --> 34:19.540
这一项的值

34:19.540 --> 34:21.540
如果说有的话

34:21.540 --> 34:22.540
那么就把它一次

34:22.540 --> 34:24.540
给它删掉

34:24.540 --> 34:25.540
就看后边就行了

34:25.540 --> 34:26.540
那么这里怎么写的

34:26.540 --> 34:28.540
是不是要循环

34:29.540 --> 34:30.540
i的于0

34:30.540 --> 34:31.540
i小于

34:32.540 --> 34:36.110
nomus.nance

34:36.110 --> 34:37.110
i加加

34:38.110 --> 34:40.110
那么这里我要判断啥呢

34:40.110 --> 34:41.110
得到item

34:41.110 --> 34:42.110
那么是i

34:43.110 --> 34:44.110
我要判断啥呢

34:44.110 --> 34:46.110
我要判断

34:46.110 --> 34:48.110
item在

34:49.110 --> 34:52.110
下标i之后

34:52.110 --> 34:55.740
有没有

34:55.740 --> 34:56.740
重复

34:56.740 --> 34:57.740
对吧

34:57.740 --> 34:58.740
比如说这一项标

34:58.740 --> 34:59.740
这一项是e

34:59.740 --> 35:00.740
我要看这个e

35:00.740 --> 35:01.740
在这个下标

35:01.740 --> 35:02.740
这个下标是0

35:02.740 --> 35:03.740
对吧

35:03.740 --> 35:04.740
0之后就在这里边

35:04.740 --> 35:05.740
有没有e

35:05.740 --> 35:06.740
有的话全部删除

35:06.740 --> 35:07.740
有没有重复

35:08.740 --> 35:11.740
有的话全部删除

35:12.740 --> 35:13.740
或者换言之

35:13.740 --> 35:15.740
在下标i之后

35:15.740 --> 35:18.740
有没有等于item的象

35:20.740 --> 35:22.740
有的话全部删除

35:22.740 --> 35:23.740
那么如果说

35:23.740 --> 35:24.740
你不看外边的循环

35:24.740 --> 35:26.740
这道题其实很简单的

35:26.740 --> 35:27.740
对吧

35:27.740 --> 35:28.740
其实跟上面的题有什么

35:28.740 --> 35:29.740
跟第二题有什么本质区别

35:29.740 --> 35:31.740
就是看一下

35:31.740 --> 35:32.740
i之后

35:32.740 --> 35:34.740
输出了下标i之后

35:34.740 --> 35:35.740
有没有跟它相等的

35:35.740 --> 35:36.740
有的话就删除

35:36.740 --> 35:37.740
上面是不是也一样了

35:37.740 --> 35:38.740
因此你这里只需要

35:38.740 --> 35:39.740
写个循环

35:39.740 --> 35:40.740
对吧

35:40.740 --> 35:41.740
那么这里由于

35:41.740 --> 35:42.740
已经有了变量i

35:42.740 --> 35:43.740
所以说不能再写i了

35:43.740 --> 35:44.740
我们要写个借

35:44.740 --> 35:45.740
借等于

35:45.740 --> 35:46.740
借从几开始

35:46.740 --> 35:48.740
从i加1开始

35:48.740 --> 35:49.740
i之后

35:49.740 --> 35:51.740
i加1开始看

35:51.740 --> 35:52.740
看到哪儿了

35:52.740 --> 35:54.740
看到输出了末尾

35:55.740 --> 35:57.740
看什么呢

35:57.740 --> 35:59.740
看有没有跟item一样的

35:59.740 --> 36:00.740
跟这个不是item

36:00.740 --> 36:03.740
是输出的末尾

36:03.740 --> 36:05.740
看有没有等于item的东西

36:05.740 --> 36:06.740
我们就判断吧

36:06.740 --> 36:07.740
那么是借

36:07.740 --> 36:09.740
是不是等于item

36:09.740 --> 36:11.740
是不是等于它

36:11.740 --> 36:12.740
那如果说是相等的话

36:12.740 --> 36:13.740
是不是要删除

36:13.740 --> 36:14.740
怎么删

36:14.740 --> 36:15.740
那么是splice

36:15.740 --> 36:16.740
借

36:16.740 --> 36:17.740
借

36:17.740 --> 36:18.740
借

36:18.740 --> 36:19.740
出去删吧

36:19.740 --> 36:20.740
你看这个代码

36:20.740 --> 36:21.740
跟这边的代码

36:21.740 --> 36:23.740
我们把隔一下

36:24.740 --> 36:26.740
你看这段代码

36:26.740 --> 36:28.740
跟这段代码有什么区别呢

36:28.740 --> 36:29.740
那还要注意一下

36:29.740 --> 36:31.740
借减减

36:32.740 --> 36:33.740
因为它后边有很多

36:33.740 --> 36:34.740
重复的相

36:34.740 --> 36:35.740
重复相都要删除

36:36.740 --> 36:37.740
对不对

36:37.740 --> 36:38.740
那就删完了

36:38.740 --> 36:40.740
就删完了

36:40.740 --> 36:41.740
删完了之后

36:41.740 --> 36:42.740
然后再看下一项

36:42.740 --> 36:43.740
对吧

36:43.740 --> 36:44.740
就完事了

36:44.740 --> 36:45.740
比方就这个

36:45.740 --> 36:46.740
就这个输出吧

36:46.740 --> 36:47.740
就这个输出

36:47.740 --> 36:48.740
我们来看一下吧

36:49.740 --> 36:50.740
它到底是怎么删的

36:50.740 --> 36:51.740
先看这一项

36:51.740 --> 36:52.740
看这一项的时候

36:52.740 --> 36:54.740
我要把后边的e全部删掉

36:54.740 --> 36:55.740
后边的e全部删掉

36:55.740 --> 36:57.740
是不是就成这样子

36:57.740 --> 36:58.740
那这一项就完了

36:58.740 --> 37:00.740
然后再看这一项

37:00.740 --> 37:01.740
我要把这一项

37:01.740 --> 37:02.740
后边的全部制服串e

37:02.740 --> 37:03.740
全部删掉

37:03.740 --> 37:04.740
那是不是说e没有

37:04.740 --> 37:05.740
那就完事了

37:05.740 --> 37:06.740
然后再看这一项

37:06.740 --> 37:08.740
这一项我要把后边的

37:08.740 --> 37:10.740
所有的制服串e全部删掉

37:10.740 --> 37:11.740
那是不是把这一项删了

37:12.740 --> 37:13.740
好

37:13.740 --> 37:14.740
然后再看这一项

37:14.740 --> 37:15.740
这一项我要把后边的b全部删掉

37:15.740 --> 37:16.740
所以全部删掉

37:16.740 --> 37:17.740
好

37:17.740 --> 37:18.740
再看这一项

37:18.740 --> 37:19.740
要把后边的3全部删掉

37:19.740 --> 37:20.740
是不是就这里

37:20.740 --> 37:21.740
对吧

37:21.740 --> 37:22.740
然后再看5

37:22.740 --> 37:23.740
再看7

37:23.740 --> 37:24.740
所以没了

37:24.740 --> 37:25.740
没有重复了

37:25.740 --> 37:26.740
整个过程完了就结束了

37:26.740 --> 37:27.740
就写完了代码

37:27.740 --> 37:28.740
所以一看着

37:28.740 --> 37:29.740
好像是一个嵌套循环

37:29.740 --> 37:30.740
对吧

37:30.740 --> 37:31.740
我说我嵌套循环怎么处理

37:31.740 --> 37:33.740
以后还多隔几行

37:33.740 --> 37:34.740
忘记外边的循环

37:34.740 --> 37:35.740
把注释打好

37:35.740 --> 37:36.740
就变成一道小偶题了

37:36.740 --> 37:38.740
所以变得比较简单了

37:38.740 --> 37:40.740
最后我们输出一项

37:42.740 --> 37:43.740
是不是就没有重复了

37:45.740 --> 37:46.740
这就是这一块

37:48.740 --> 37:49.740
第三题

37:49.740 --> 37:50.740
第四题

37:50.740 --> 37:52.740
判断下边的文件

37:52.740 --> 37:54.740
是否符合后居民的要求

37:54.740 --> 37:55.740
这是一道非常实用的题

37:56.740 --> 37:57.740
将来我们在实际开发中

37:57.740 --> 37:58.740
以后会用到的

37:58.740 --> 37:59.740
就是有的时候

37:59.740 --> 38:00.740
我会拿到一个制服串

38:00.740 --> 38:02.740
这个制服串是一个文件路径

38:02.740 --> 38:04.740
是一个文件路径

38:04.740 --> 38:05.740
这个文件路径

38:05.740 --> 38:07.740
这里我顺便说一下

38:07.740 --> 38:09.740
顺便说一下文件路径

38:10.740 --> 38:11.740
这个文件路径

38:11.740 --> 38:12.740
它有一个就是

38:12.740 --> 38:13.740
这是盘嘛

38:13.740 --> 38:14.740
拿一个盘

38:14.740 --> 38:16.740
然后这里是盘的分割符

38:16.740 --> 38:19.740
这个分割符有可能是左鞋线

38:19.740 --> 38:22.740
也有可能是右鞋线

38:22.740 --> 38:23.740
Windows

38:23.740 --> 38:25.740
其实它的Windows的标准是右鞋线

38:25.740 --> 38:27.740
其他的标准都是左鞋线

38:27.740 --> 38:29.740
我这里是用的左鞋线

38:29.740 --> 38:31.740
现在Windows的左鞋线

38:31.740 --> 38:32.740
它也认识

38:32.740 --> 38:34.740
但它的标准鞋法是右鞋线

38:34.740 --> 38:35.740
有的时候你得到一个路径

38:35.740 --> 38:37.740
它可能就是右鞋杠

38:37.740 --> 38:38.740
好 那注意一下

38:38.740 --> 38:40.740
这个右鞋杠这一块

38:40.740 --> 38:42.740
要出问题的同学们

38:42.740 --> 38:43.740
为什么呢

38:43.740 --> 38:44.740
你看

38:45.740 --> 38:47.740
这么存这样子的答应出来

38:47.740 --> 38:48.740
因为我们知道

38:48.740 --> 38:50.740
在制服串里面是不是有转衣服

38:50.740 --> 38:52.740
转衣服是不是就是右鞋杠

38:52.740 --> 38:53.740
对吧

38:53.740 --> 38:55.740
那你说

38:55.740 --> 38:58.740
我现在不希望你是转衣服

38:58.740 --> 39:00.740
我不希望你是转衣服

39:00.740 --> 39:02.740
我希望你就是一个普通的鞋杠而已

39:02.740 --> 39:04.740
你看它想把山来进行转衣

39:04.740 --> 39:06.740
你看那怎么转衣呢

39:06.740 --> 39:08.740
所以有的时候

39:08.740 --> 39:09.740
我不希望它是转衣服

39:09.740 --> 39:11.740
希望它是一个普通的右鞋杠

39:11.740 --> 39:13.740
那怎么办呢

39:13.740 --> 39:14.740
可以这样子

39:14.740 --> 39:17.740
你可以再写两个鞋杠

39:17.740 --> 39:19.740
来表示一个鞋杠

39:19.740 --> 39:22.740
就是对这个鞋杠再进行转衣

39:22.740 --> 39:24.740
就是你本来是一个

39:24.740 --> 39:25.740
本来有特殊含义的对吧

39:25.740 --> 39:27.740
然后我在前面再加一个鞋杠

39:27.740 --> 39:29.740
就表示说

39:29.740 --> 39:31.740
告诉我程序

39:31.740 --> 39:33.740
我是个转衣服

39:33.740 --> 39:36.740
我后边那个鞋杠是一个普通鞋杠

39:36.740 --> 39:38.740
所以要用两个鞋杠来表示

39:38.740 --> 39:40.740
一个鞋杠 右鞋杠

39:40.740 --> 39:41.740
那这里

39:41.740 --> 39:42.740
这里有两个右鞋杠

39:42.740 --> 39:43.740
需要写四个

39:43.740 --> 39:44.740
这里有一个右鞋杠

39:44.740 --> 39:46.740
需要写两个

39:46.740 --> 39:47.740
那这样就没问题了

39:47.740 --> 39:48.740
顺便给大家说一下

39:48.740 --> 39:50.740
但我这里不是这道题的重点

39:50.740 --> 39:51.740
这道题呢

39:51.740 --> 39:54.740
重点是这个路径里边

39:54.740 --> 39:55.740
它是一个文件的路径

39:55.740 --> 39:57.740
这个文件一定有个后罪名对吧

39:57.740 --> 39:59.740
我要判断这个文件的后罪名

39:59.740 --> 40:01.740
是不是合法的

40:01.740 --> 40:03.740
因为有的时候我们要上传文件

40:03.740 --> 40:05.740
我只允许上传图片

40:05.740 --> 40:06.740
因此我只能

40:06.740 --> 40:08.740
我只认这些后罪名

40:08.740 --> 40:10.740
其他的后罪名我不认了

40:10.740 --> 40:12.740
其他后罪名我不认

40:12.740 --> 40:15.740
那么像这种程序该怎么来做

40:15.740 --> 40:17.740
那第一步要分成两步

40:17.740 --> 40:22.740
第一步要得到文件的后罪名

40:23.740 --> 40:24.740
就是这个文件给力了

40:24.740 --> 40:25.740
对吧

40:25.740 --> 40:26.740
我随便写的

40:26.740 --> 40:28.740
你不能直接给我写个底儿界匹

40:28.740 --> 40:29.740
文件的后罪名是啥

40:29.740 --> 40:31.740
文件的后罪名EST

40:31.740 --> 40:33.740
Extension

40:33.740 --> 40:34.740
文件的后罪名是底儿界匹

40:34.740 --> 40:35.740
不能这样玩

40:35.740 --> 40:36.740
玩是我

40:37.740 --> 40:40.740
你要动态的去读

40:40.740 --> 40:43.740
因为这个玩意里边有可能会变化的

40:43.740 --> 40:45.740
你都不知道它里边放的是啥

40:45.740 --> 40:46.740
所以说你不能写常量

40:46.740 --> 40:47.740
你不能写字面量

40:47.740 --> 40:48.740
你要去读

40:48.740 --> 40:49.740
怎么读呢

40:49.740 --> 40:51.740
你要取最后一个底

40:52.740 --> 40:55.740
你要首先要取到最后一个底

40:55.740 --> 40:56.740
Final name

40:56.740 --> 40:58.740
Last index of 底儿

40:58.740 --> 41:00.740
底儿的位置

41:00.740 --> 41:01.740
那位置是不是出来了

41:01.740 --> 41:02.740
它会告诉你

41:02.740 --> 41:03.740
最后一个

41:03.740 --> 41:04.740
为什么要取最后一个底儿呢

41:04.740 --> 41:06.740
因为它有可能中间会出现底儿

41:06.740 --> 41:07.740
知道吧

41:07.740 --> 41:08.740
所以你要取最后一个底儿

41:08.740 --> 41:09.740
位置是17

41:09.740 --> 41:10.740
好

41:10.740 --> 41:11.740
然后根据这个位置

41:11.740 --> 41:14.740
使用制服出来解决

41:14.740 --> 41:16.740
Substitute

41:16.740 --> 41:18.740
从这个位置开始取

41:18.740 --> 41:19.740
取到结束

41:19.740 --> 41:21.740
不就是后罪名吗

41:22.740 --> 41:23.740
对吧

41:23.740 --> 41:24.740
我们来输出一下

41:25.740 --> 41:27.740
是不是掉GIPG就出来了

41:27.740 --> 41:28.740
这后罪名

41:28.740 --> 41:29.740
好 这是第一步

41:29.740 --> 41:30.740
然后第二步

41:30.740 --> 41:34.740
再判断后罪名是否合法

41:34.740 --> 41:35.740
那么如何来判断

41:35.740 --> 41:37.740
后罪名是否合法呢

41:37.740 --> 41:38.740
有可能会这样子去

41:38.740 --> 41:40.740
那么这个EST name

41:41.740 --> 41:43.740
是不是等于

41:43.740 --> 41:45.740
点GIPG

41:45.740 --> 41:47.740
或者

41:47.740 --> 41:49.740
等于点PNG

41:49.740 --> 41:50.740
叫GIF

41:50.740 --> 41:51.740
就是一式写

41:51.740 --> 41:52.740
对吧

41:52.740 --> 41:53.740
还有很多那种情况

41:53.740 --> 41:54.740
这样的写代码是

41:54.740 --> 41:55.740
可不可以的

41:55.740 --> 41:56.740
当然是可以的

41:56.740 --> 41:57.740
注意是或者

41:57.740 --> 41:59.740
因为它等于任何一个都可以

42:00.740 --> 42:01.740
可不可以这样写

42:01.740 --> 42:02.740
可以

42:02.740 --> 42:05.740
但是略显幼稚

42:05.740 --> 42:07.740
略显智能

42:07.740 --> 42:08.740
高手是怎么写

42:08.740 --> 42:09.740
这一块程序等等

42:09.740 --> 42:11.740
高手会把合法的

42:11.740 --> 42:13.740
后罪名

42:13.740 --> 42:15.740
保存到一个数族里面

42:15.740 --> 42:17.740
叫Erloss

42:17.740 --> 42:18.740
表示过允许哪些后罪名

42:18.740 --> 42:19.740
叫GIPG

42:19.740 --> 42:21.740
叫GIF

42:21.740 --> 42:23.740
叫BMP

42:23.740 --> 42:25.740
叫WIP

42:25.740 --> 42:27.740
叫PNG

42:27.740 --> 42:29.740
这是我允许的合法后罪名

42:29.740 --> 42:30.740
将来如果说

42:30.740 --> 42:31.740
我合法的后罪名

42:31.740 --> 42:32.740
要求有变动

42:32.740 --> 42:34.740
我在这个数族里面去变动就行了

42:34.740 --> 42:36.740
只需要改数族就行了

42:36.740 --> 42:37.740
那么我如何来判断

42:37.740 --> 42:38.740
是否合法呢

42:38.740 --> 42:39.740
它用这种方式来判断

42:39.740 --> 42:41.740
Erloss includes

42:41.740 --> 42:43.740
就是包含

42:43.740 --> 42:44.740
这个数族里面

42:44.740 --> 42:46.740
是不是包含你这个后罪名

42:46.740 --> 42:47.740
就是你这个后罪名

42:47.740 --> 42:49.740
是不是在这个数族中存在

42:49.740 --> 42:51.740
include不就是个算吗

42:51.740 --> 42:54.740
include

42:54.740 --> 42:56.740
判断数族中是否包含某一个字

42:56.740 --> 42:59.740
包含就是合法

42:59.740 --> 43:04.330
否则的话就不合法

43:04.330 --> 43:06.330
目前这个后罪名是合法的

43:06.330 --> 43:08.330
有天给你传一个可执行文件

43:08.330 --> 43:10.330
它就不合法了

43:10.330 --> 43:11.330
有这么个意思

43:11.330 --> 43:12.330
第四题

43:12.330 --> 43:13.330
第五题

43:13.330 --> 43:14.330
将下面的伪数组

43:14.330 --> 43:21.800
转换成真数组

43:21.800 --> 43:22.800
不说了

43:26.590 --> 43:27.590
真数数

43:27.590 --> 43:29.590
好 第六题

43:29.590 --> 43:33.590
这是我们之前写的那个铺客牌程序

43:33.590 --> 43:35.590
这个铺客牌程序里边呢

43:35.590 --> 43:37.590
之前还不知道同学们自己写的

43:37.590 --> 43:38.590
就一定有印象

43:38.590 --> 43:40.590
这铺客牌

43:40.590 --> 43:42.590
还有一叠铺客牌

43:42.590 --> 43:44.590
应该是这个叠

43:45.590 --> 43:46.590
当然你可以把之前的

43:46.590 --> 43:48.590
你写的那个铺客牌程序

43:48.590 --> 43:49.590
暂停过来

43:49.590 --> 43:50.590
因为我这里写的是我的

43:50.590 --> 43:51.590
现在要求是什么呢

43:51.590 --> 43:52.590
要给排堆

43:52.590 --> 43:54.590
就是这个一叠铺客牌

43:54.590 --> 43:56.590
加一个方法叫Swaffle

43:56.590 --> 43:58.590
这叫洗牌方法

43:58.590 --> 44:00.590
这个方法可以打乱排堆中的

44:00.590 --> 44:01.590
铺客牌顺序

44:01.590 --> 44:03.590
你看目前

44:03.590 --> 44:05.590
排堆里边铺客牌顺序是非常规矩的

44:05.590 --> 44:07.590
因为我是一次加的

44:07.590 --> 44:09.590
先加1 再加2 再加3

44:09.590 --> 44:11.590
然后再加小王大王

44:11.590 --> 44:12.590
一次加的

44:12.590 --> 44:15.590
因此我现在去创建一个排堆

44:15.590 --> 44:17.590
留一个Dec

44:17.590 --> 44:20.590
然后去打印它Print

44:20.590 --> 44:23.590
得到的牌是非常规矩的

44:23.590 --> 44:24.590
一次有顺序的

44:24.590 --> 44:25.590
我想把它洗牌

44:25.590 --> 44:27.590
把它打乱顺序

44:27.590 --> 44:29.590
那我希望是什么效果呢

44:29.590 --> 44:31.590
希望是我一定要用这个方法

44:31.590 --> 44:33.590
就是有这么一个方法

44:33.590 --> 44:34.590
一定要用一个方法

44:34.590 --> 44:35.590
它的顺序就变了

44:35.590 --> 44:37.590
那都是随机的顺序

44:37.590 --> 44:38.590
我都不知道它变成什么样子

44:38.590 --> 44:40.590
那这个函数怎么写呢

44:40.590 --> 44:41.590
这个函数

44:41.590 --> 44:43.590
其实这个函数无非就是对它里边

44:43.590 --> 44:45.590
这个数组来进行重新排序

44:45.590 --> 44:46.590
对吧

44:46.590 --> 44:48.590
对这个数组来进行重新排序

44:48.590 --> 44:50.590
排什么顺序

44:50.590 --> 44:52.590
随机排序

44:52.590 --> 44:53.590
那来呗

44:53.590 --> 44:54.590
那就说的特别

44:54.590 --> 44:55.590
对吧

44:55.590 --> 44:57.590
方向型A和B

44:57.590 --> 44:58.590
我们说过随机排序

44:58.590 --> 45:00.590
是不需要这个A和B的

45:00.590 --> 45:02.590
那我返回什么呢

45:02.590 --> 45:04.590
返回NiceRandom

45:04.590 --> 45:05.590
减去0.5

45:05.590 --> 45:06.590
有可能是函数

45:06.590 --> 45:07.590
有可能是复数

45:07.590 --> 45:08.590
那里看得来吧

45:08.590 --> 45:09.590
随机的嘛

45:09.590 --> 45:11.590
这样子就打乱了

45:11.590 --> 45:14.590
就打到了洗牌的效果了

45:14.590 --> 45:15.590
就这样子

45:15.590 --> 45:17.590
每次都不一样的

45:17.590 --> 45:20.590
这是那个

45:20.590 --> 45:22.590
那至于那些什么

45:22.590 --> 45:24.590
洗牌游戏里边

45:24.590 --> 45:26.590
是不是用这种方式洗牌的

45:26.590 --> 45:27.590
拉我不知道

45:27.590 --> 45:28.590
我不知道

45:28.590 --> 45:30.590
那有可能有些

45:30.590 --> 45:31.590
什么稍稍做在里边

45:31.590 --> 45:33.590
就不知道了

45:33.590 --> 45:34.590
好

45:34.590 --> 45:35.590
看得到题

45:35.590 --> 45:36.590
这道题是一个以前

45:36.590 --> 45:38.590
我们玩过的一个水生数组

45:38.590 --> 45:39.590
有很多的学生

45:39.590 --> 45:40.590
好

45:40.590 --> 45:41.590
第一道题

45:41.590 --> 45:43.590
得到学生的姓名

45:43.590 --> 45:45.590
形成的制服串

45:45.590 --> 45:47.590
得到制服串

45:47.590 --> 45:48.590
得到这么一个东西

45:48.590 --> 45:49.590
好

45:49.590 --> 45:51.590
这道题呢

45:51.590 --> 45:52.590
你开发久了

45:52.590 --> 45:53.590
你瞬间就反应过来了

45:53.590 --> 45:55.590
我只要能够得到一个姓名数组

45:55.590 --> 45:56.590
是不是就可以了

45:56.590 --> 45:58.590
张三

45:58.590 --> 46:01.590
你是

46:01.590 --> 46:02.590
王五

46:02.590 --> 46:03.590
对吧

46:03.590 --> 46:05.590
那比方就这么几项

46:05.590 --> 46:06.590
然后数组里边

46:06.590 --> 46:08.590
不有一个交引方法吗

46:08.590 --> 46:10.590
把数组的每一项连接

46:10.590 --> 46:11.590
成为一个制服串

46:11.590 --> 46:12.590
中间用逗号来分割

46:12.590 --> 46:13.590
对吧

46:13.590 --> 46:15.590
那我就用逗号来连接

46:15.590 --> 46:20.820
那不就得到结果了吗

46:20.820 --> 46:22.820
就是出了的话就是个制服串

46:22.820 --> 46:24.820
因此我这里要做的事情

46:24.820 --> 46:25.820
其实非常简单

46:25.820 --> 46:26.820
我要做什么事呢

46:26.820 --> 46:28.820
我就是要把这个玩意儿

46:28.820 --> 46:30.820
转换成姓名的数组就可以了

46:30.820 --> 46:32.820
那我怎么能转换成姓名的数组呢

46:32.820 --> 46:33.820
之前说的写过

46:33.820 --> 46:35.820
我隐约约记得写过

46:35.820 --> 46:37.820
哪一个新数组

46:37.820 --> 46:39.820
然后循环原来的数组

46:39.820 --> 46:42.820
小于students

46:44.820 --> 46:45.820
被循环一次

46:45.820 --> 46:48.820
我往这个新数组里边

46:49.820 --> 46:51.820
加一个什么元数组的这一项的名字

46:51.820 --> 46:53.820
我把名字加到新数组里边去

46:53.820 --> 46:55.820
然后把名字放这

46:55.820 --> 46:57.820
把名字用逗号连接

46:57.820 --> 46:59.820
这样子我就形成了一个

46:59.820 --> 47:01.820
只有姓名的制服串

47:01.820 --> 47:03.820
只用交引

47:03.820 --> 47:05.820
这道题

47:05.820 --> 47:06.820
下道题

47:06.820 --> 47:09.820
将学生数组按照年龄的生序排序

47:09.820 --> 47:11.820
这是个学生数组

47:11.820 --> 47:12.820
那么我们现在

47:12.820 --> 47:13.820
是不是要排序要用数组

47:13.820 --> 47:14.820
对吧

47:14.820 --> 47:15.820
注意

47:15.820 --> 47:18.820
这里的你就不能哪个A减B了

47:18.820 --> 47:20.820
为什么不能A减B的

47:20.820 --> 47:21.820
因为这个A和B

47:21.820 --> 47:22.820
我们之前说过是啥

47:22.820 --> 47:25.820
是数组里边任意两项

47:25.820 --> 47:28.820
这里任意两项是数字吗

47:28.820 --> 47:29.820
不是吧

47:29.820 --> 47:30.820
是两个对象

47:30.820 --> 47:31.820
对不对

47:31.820 --> 47:32.820
是不是两个对象

47:32.820 --> 47:34.820
两个对象怎么能相减呢

47:34.820 --> 47:35.820
你不能这样做

47:35.820 --> 47:37.820
那应该怎么做呢

47:37.820 --> 47:40.820
你现在不是要按年龄排序吗

47:40.820 --> 47:42.820
所以我要比较的是谁

47:42.820 --> 47:44.820
比较的是年龄的大小

47:44.820 --> 47:45.820
对不对

47:45.820 --> 47:46.820
A和B

47:46.820 --> 47:48.820
现在A和B是啥就要搞清楚

47:48.820 --> 47:56.320
A和B是数组中的两项

47:56.320 --> 47:57.320
对吧

47:57.320 --> 47:59.320
其中两项

47:59.320 --> 48:01.320
那每一项是什么呢

48:01.320 --> 48:03.320
每一项就是一个学生

48:03.320 --> 48:05.320
所以A是一个学生

48:05.320 --> 48:06.320
B也是个学生

48:06.320 --> 48:07.320
我要比较的是什么

48:07.320 --> 48:09.320
年龄

48:09.320 --> 48:11.320
年龄相减

48:11.320 --> 48:12.320
这样子

48:12.320 --> 48:13.320
我们来看一下

48:13.320 --> 48:15.320
Students

48:15.320 --> 48:17.320
按照年龄排序

48:17.320 --> 48:18.320
最小的12岁

48:18.320 --> 48:19.320
后面就越来越大了

48:19.320 --> 48:21.320
看最后一个29岁

48:21.320 --> 48:22.320
对吧

48:22.320 --> 48:24.320
那如果说要导去排序

48:24.320 --> 48:25.320
是不是反过来

48:25.320 --> 48:26.320
B点的年龄

48:26.320 --> 48:28.320
减去A点的年龄

48:28.320 --> 48:32.210
是不是导去排序

48:32.210 --> 48:33.210
对吧

48:33.210 --> 48:35.210
这就是排序

48:35.210 --> 48:36.210
OK

48:36.210 --> 48:37.210
你把这些停电的

48:37.210 --> 48:38.210
我们平时开发中

48:38.210 --> 48:40.210
跟数组相关的

48:40.210 --> 48:42.210
绝大部分都联系到了

48:42.210 --> 48:44.210
标准库也就到这了

48:44.210 --> 48:45.210
没啥了

48:45.210 --> 48:47.210
标准库学习起来是很轻松的

48:47.210 --> 48:48.210
OK

48:48.210 --> 48:50.210
那么就完事了

48:50.210 --> 48:51.210
我们很快

48:51.210 --> 48:53.210
就会进入到界面的学习了

