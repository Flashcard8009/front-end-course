WEBVTT

00:00.620 --> 00:04.220
好 我们这里可能讲这个数据的作用预

00:04.220 --> 00:05.620
其实讲的是什么呢

00:05.620 --> 00:08.620
因为我们知道的一些程序就是玩数据 对吧

00:08.620 --> 00:11.420
我们程序里边有很多很多的数据

00:11.420 --> 00:13.620
那么这么多数据

00:13.620 --> 00:16.620
如果说不给它加以范围来约束的话

00:16.620 --> 00:18.620
那就乱了它了

00:18.620 --> 00:21.620
你这个函数里边的数据跑到外边来了

00:21.620 --> 00:24.620
这个函数的数据跑到另外一个函数里边去了

00:24.620 --> 00:26.620
因为我们知道函数里边数可以定义变量

00:26.620 --> 00:29.620
对吧 定义变量 声明一些指函数都有可能

00:29.620 --> 00:32.620
所以这个数据如果说到处乱穿的话

00:32.620 --> 00:33.620
这个世界就乱了套了

00:33.620 --> 00:37.620
所以我们这个世界其实数据是非常规矩的

00:37.620 --> 00:40.620
银河系有银河系的数据

00:40.620 --> 00:42.620
宇宙有宇宙的数据

00:42.620 --> 00:45.620
银河系里边每个星球有每个星球的数据

00:45.620 --> 00:48.620
每个星球里边每个国家有每个国家的数据

00:48.620 --> 00:53.620
国家里边每一个省份 市 县 人 是不是

00:53.620 --> 00:54.620
都有自己的数据

00:54.620 --> 00:57.620
对吧 数据是分门别类的

00:57.620 --> 00:59.620
数据不要到处乱跑

00:59.620 --> 01:00.620
就好比说邓哥

01:00.620 --> 01:03.620
邓哥喜欢吃秋葵和香菜这件事

01:03.620 --> 01:05.620
是不是众所周知的

01:05.620 --> 01:08.620
但众所周知也只是咱们独一的学员

01:08.620 --> 01:11.620
独一的老师众所周知

01:11.620 --> 01:14.620
当你出了这个范围 是不是就不知道了

01:14.620 --> 01:17.620
比方说你问一些建筑工人 邓哥是谁

01:17.620 --> 01:20.620
然后你问美国总统 邓哥是谁

01:20.620 --> 01:21.620
他不知道了

01:21.620 --> 01:24.620
所以说我们的数据它是有个范围的

01:24.620 --> 01:26.620
那么这就是数据的作用域

01:26.620 --> 01:27.620
什么叫作用域

01:27.620 --> 01:30.620
就是数据在哪一个范围内是可以用的

01:30.620 --> 01:31.620
是有效的

01:31.620 --> 01:33.620
除了这个范围就不能用了

01:33.620 --> 01:34.620
就是讲这件事

01:34.620 --> 01:37.620
我们这些可能东西写的很简单

01:37.620 --> 01:38.620
就这么几句话

01:38.620 --> 01:40.620
你把这几句话搞清楚就可以了

01:40.620 --> 01:42.620
这里来给大家说一下

01:42.620 --> 01:45.620
数据作用域这一块其实知识是蛮多的

01:45.620 --> 01:48.620
只不过我们目前现阶段

01:48.620 --> 01:51.620
没有必要去搞清楚那么多的知识

01:51.620 --> 01:54.620
这些知识我们将来留到笔面式

01:54.620 --> 01:55.620
再一个一个去搞定

01:55.620 --> 01:57.620
我们这一块先简单的

01:57.620 --> 02:01.620
把它里边的脉络给它梳理清楚

02:01.620 --> 02:04.620
不影响我们后边写代码就可以了

02:04.620 --> 02:06.620
好 我们来看第一点

02:06.620 --> 02:08.620
说介石有两种作用域

02:08.620 --> 02:10.620
一种叫全局作用域

02:10.620 --> 02:12.620
一种叫寒树作用域

02:12.620 --> 02:13.620
这啥意思

02:13.620 --> 02:15.620
就指的是介石里边

02:15.620 --> 02:17.620
我们随便写个介石

02:17.620 --> 02:19.620
有介石代码里边

02:19.620 --> 02:21.620
如果说你直接输写的代码

02:21.620 --> 02:23.620
比方说你直接在这里定一个变量

02:23.620 --> 02:26.620
那么这个变量的作用域就是全局的

02:26.620 --> 02:29.620
在整个环境中都有效的

02:29.620 --> 02:32.620
比方说在这里在定义一个

02:32.620 --> 02:34.620
在声明一个寒树

02:34.620 --> 02:37.620
寒树声明 变量定义

02:37.620 --> 02:39.620
这也叫变量声明

02:39.620 --> 02:42.620
那么它都是属于全局作用域

02:42.620 --> 02:43.620
你看是不是在全局定义的

02:43.620 --> 02:45.620
全局声明的寒树

02:45.620 --> 02:47.620
全局定义的变量

02:47.620 --> 02:49.620
那有人说这样子写

02:49.620 --> 02:51.620
这样子写又算啥

02:51.620 --> 02:52.620
寒树是可以这样子写的

02:52.620 --> 02:55.620
用法是一样的

02:55.620 --> 02:56.620
用法是一样的

02:56.620 --> 02:57.620
表示把这个寒树

02:57.620 --> 02:59.620
这是表达式的

02:59.620 --> 03:01.620
把这个寒树的表达式

03:01.620 --> 03:03.620
复制给这个变量C

03:03.620 --> 03:04.620
那么C里边保存了一个寒树

03:04.620 --> 03:05.620
当然你要用这个C的话

03:05.620 --> 03:06.620
也是直接调用

03:06.620 --> 03:08.620
比方说我们这里输出一个

03:08.620 --> 03:10.620
C

03:10.620 --> 03:11.620
我们来看一下印象

03:11.620 --> 03:12.620
是不是C

03:12.620 --> 03:14.620
没问题的

03:14.620 --> 03:15.620
那这又算啥呢

03:15.620 --> 03:16.620
你觉得这个算啥呢

03:16.620 --> 03:17.620
这到底算寒树呢

03:17.620 --> 03:19.620
还是算变量呢

03:19.620 --> 03:20.620
当然算变量

03:20.620 --> 03:21.620
你看这个是不是变量

03:21.620 --> 03:23.620
定义一个变量

03:23.620 --> 03:25.620
把寒树复制给它

03:25.620 --> 03:27.620
所以它里边保存了一个寒树

03:27.620 --> 03:29.620
你要这么去理解

03:29.620 --> 03:32.620
那么这也是要做变量

03:32.620 --> 03:33.620
无论是变量

03:33.620 --> 03:35.620
变量还是寒树声明

03:35.620 --> 03:38.620
那么这里都是在定义在哪呢

03:38.620 --> 03:39.620
定义在全局的

03:39.620 --> 03:42.620
所以他们是全局作用域

03:42.620 --> 03:44.620
那比方说在寒树里边

03:44.620 --> 03:46.620
我们就通过一个VAR

03:46.620 --> 03:47.620
来定义一个变量

03:47.620 --> 03:51.380
比方说D

03:51.380 --> 03:52.380
那这个变量

03:52.380 --> 03:54.380
你看所以说这个作用域在哪

03:54.380 --> 03:57.380
关键是在它在哪定义的

03:57.380 --> 03:58.380
你这个变量在哪定义的

03:58.380 --> 04:00.380
是不是在寒树里边定义的

04:00.380 --> 04:01.380
因此它的作用域呢

04:01.380 --> 04:03.380
就在寒树里边

04:03.380 --> 04:04.380
懂的意思吧

04:04.380 --> 04:07.380
那比方说这里边有个变量E

04:07.380 --> 04:09.380
那么这个变量在哪定义的

04:09.380 --> 04:10.380
是在寒树里边定义的

04:10.380 --> 04:12.380
所以关键看什么

04:12.380 --> 04:13.380
不要去看它什么复制

04:13.380 --> 04:14.380
不复制

04:14.380 --> 04:16.380
一定要看这个关键制在哪里定义的

04:16.380 --> 04:19.380
在哪里定义就是哪个作用域

04:19.380 --> 04:20.380
懂了意思吧

04:20.380 --> 04:21.380
那么E是哪个作用域

04:21.380 --> 04:23.380
是这个寒树的作用域

04:23.380 --> 04:24.380
D是哪个作用域

04:24.380 --> 04:26.380
是这个寒树的作用域

04:26.380 --> 04:28.380
S是谁的哪个作用域是全局的

04:28.380 --> 04:30.380
B是哪个作用域全局的

04:30.380 --> 04:32.380
C是哪个作用域全局的

04:32.380 --> 04:35.380
一定要看它定义的位置

04:35.380 --> 04:36.380
懂了意思吧

04:36.380 --> 04:38.380
根据定义的位置来确定

04:38.380 --> 04:39.380
它是哪一个作用域

04:39.380 --> 04:40.380
其实我们写代码的时候

04:40.380 --> 04:43.380
很多时候并不是关键这个

04:43.380 --> 04:46.380
只是有的时候有些小的地方

04:46.380 --> 04:48.380
比方就跟我们上一课说的

04:48.380 --> 04:50.380
当它的物理护甲很足的时候

04:50.380 --> 04:52.380
我们要用一些魔法的时候

04:52.380 --> 04:53.380
我们可能要关心这个

04:53.380 --> 04:55.380
但是平时我们写代码其实很少去

04:55.380 --> 04:56.380
我写个辩量

04:56.380 --> 04:58.380
我要去看它的作用域在哪

04:58.380 --> 05:01.380
很少去这样去想

05:01.380 --> 05:02.380
那么这就是作用域

05:02.380 --> 05:03.380
非常简单

05:03.380 --> 05:04.380
你就看它在哪里定义的

05:04.380 --> 05:06.380
在哪里定义就是哪个作用域

05:06.380 --> 05:07.380
我们先分清楚

05:07.380 --> 05:08.380
有两种作用域

05:08.380 --> 05:09.380
一种是辩量

05:09.380 --> 05:10.380
一种是寒树

05:10.380 --> 05:13.380
那比方在这里我再写个寒树

05:13.380 --> 05:14.380
这里边怎么能写寒树

05:14.380 --> 05:16.380
当然可以写寒树

05:16.380 --> 05:18.380
比方说这里是

05:18.380 --> 05:23.720
那我们又来看这个

05:23.720 --> 05:28.720
又说什么时候我才会在寒树里面写寒树呢

05:28.720 --> 05:30.720
有这种情况肯定是有的

05:30.720 --> 05:33.720
比方说我这个寒树功能很复杂

05:33.720 --> 05:36.720
它要写几十行上百行代码

05:36.720 --> 05:39.720
那么这寒树里面又产生了一些重复代码

05:39.720 --> 05:41.720
在实现寒树的过程中

05:41.720 --> 05:43.720
又产生了一些重复代码

05:43.720 --> 05:45.720
那么我想把它提一下

05:45.720 --> 05:46.720
提一下的话

05:46.720 --> 05:49.720
我只是在这个寒树里面有效

05:49.720 --> 05:51.720
所以说我在这里写个指寒树

05:51.720 --> 05:53.720
在寒树里面去调用它用一下

05:53.720 --> 05:54.720
好

05:54.720 --> 05:55.720
我们来看一下

05:55.720 --> 05:56.720
这个寒树

05:56.720 --> 05:57.720
M这个寒树

05:57.720 --> 05:58.720
现在我们先不管这个

05:58.720 --> 06:00.720
我们只看它的作用域在哪

06:00.720 --> 06:02.720
M的作用域在哪

06:02.720 --> 06:04.720
你就看它在哪里定义的

06:04.720 --> 06:05.720
在哪里定义的

06:05.720 --> 06:06.720
是不是在这里边定义的

06:06.720 --> 06:07.720
这个大括号里边定义的

06:07.720 --> 06:08.720
所以寒树的作用域

06:08.720 --> 06:10.720
M是那个作用域

06:10.720 --> 06:12.720
这个寒树B的作用域

06:12.720 --> 06:13.720
对吧

06:13.720 --> 06:15.720
那么K这个变量是哪个作用域呢

06:15.720 --> 06:17.720
是哪里定义的

06:17.720 --> 06:18.720
是不是M里边定义的

06:18.720 --> 06:19.720
对吧

06:19.720 --> 06:21.720
所以在这个寒树里边定义的

06:21.720 --> 06:23.720
那么它的作用域是谁

06:23.720 --> 06:24.720
它的作用域就是M

06:24.720 --> 06:26.720
这个寒树的作用域

06:26.720 --> 06:27.720
我们先把

06:27.720 --> 06:28.720
你先不要管别的

06:28.720 --> 06:30.720
先把作用域搞清楚

06:30.720 --> 06:32.720
我们再说其他的

06:32.720 --> 06:33.720
一步一步来

06:33.720 --> 06:34.720
你要先搞了清楚

06:34.720 --> 06:36.720
那个东西到底是哪个作用域

06:36.720 --> 06:38.720
你就看它在哪里定义的

06:38.720 --> 06:39.720
哪里定义就是哪个作用域

06:39.720 --> 06:40.720
那么再比如

06:40.720 --> 06:43.720
我这里写了一个变量判断

06:43.720 --> 06:45.720
XXX

06:45.720 --> 06:48.720
那么我这里定一个变量A等于1

06:48.720 --> 06:49.720
那么请问

06:49.720 --> 06:51.720
这个A这个变量是哪个作用域

06:51.720 --> 06:52.720
是全局作用域

06:52.720 --> 06:54.720
还是这个E副判断的作用域

06:54.720 --> 06:56.720
是哪个

06:56.720 --> 06:59.100
记住

06:59.100 --> 07:00.100
GS里边

07:00.100 --> 07:02.100
只有两种作用域

07:02.100 --> 07:03.100
一种是全局

07:03.100 --> 07:04.100
一种是寒树

07:04.100 --> 07:05.100
那这里有寒树吗

07:05.100 --> 07:07.100
没有寒树

07:07.100 --> 07:08.100
A在哪个寒树里边

07:08.100 --> 07:09.100
你说有寒树

07:09.100 --> 07:11.100
那A在哪个寒树里边

07:11.100 --> 07:12.100
没有寒树

07:12.100 --> 07:13.100
那没有寒树

07:13.100 --> 07:14.100
它只能是全局作用域

07:14.100 --> 07:16.100
说A它是全局作用域

07:16.100 --> 07:18.100
跟你写不写在衣服里边

07:18.100 --> 07:19.100
一点关系都没有

07:19.100 --> 07:21.100
因为它这个玩意不是寒树

07:21.100 --> 07:23.100
包括佛循环也都是一样的

07:23.100 --> 07:25.100
不要看到一个大括号

07:25.100 --> 07:26.100
就表示一个作用域

07:26.100 --> 07:27.100
不是的

07:27.100 --> 07:28.100
关键是看

07:28.100 --> 07:29.100
它在哪里定义的

07:29.100 --> 07:31.100
是在寒树里边

07:31.100 --> 07:32.100
还是在全局

07:32.100 --> 07:34.100
如果说是寒树里边

07:34.100 --> 07:35.100
是哪一个寒树

07:35.100 --> 07:36.100
你它最近

07:36.100 --> 07:37.100
那就是它的作用域

07:38.100 --> 07:40.100
这时候要先分清楚作用域

07:41.100 --> 07:43.100
在哪我们再说其他的

07:43.100 --> 07:44.100
好 那么看一下

07:44.100 --> 07:46.100
这个作用域哪些规则

07:46.100 --> 07:47.100
里边的作用域

07:47.100 --> 07:48.100
可以访问外边的

07:48.100 --> 07:50.100
反之不行

07:51.100 --> 07:52.100
好 啥意思呀

07:53.100 --> 07:55.100
比方说我们这里有一个

07:55.100 --> 07:56.100
电量A

07:56.100 --> 07:58.100
然后这里有一个寒树

07:59.100 --> 08:00.100
这个寒树里边

08:00.100 --> 08:01.100
是可以直接使用A的

08:02.100 --> 08:03.100
为什么呢

08:03.100 --> 08:05.100
这个寒树的作用域里边

08:05.100 --> 08:07.100
是不是可以访问外边的

08:07.100 --> 08:08.100
这是不是外边的

08:08.100 --> 08:10.100
里边是可以访问外边的

08:10.100 --> 08:11.100
没问题的

08:11.100 --> 08:12.100
我们来运行一下这个寒树

08:12.100 --> 08:13.100
调用一次

08:13.100 --> 08:15.100
你看是不是输出1

08:15.100 --> 08:17.100
而且我还可以把它A加加

08:17.100 --> 08:19.100
给它增加1

08:19.100 --> 08:20.100
增加1过后

08:20.100 --> 08:21.100
我们在这里

08:21.100 --> 08:22.100
调用完寒树之后

08:22.100 --> 08:24.100
我们再输出在全局输出A

08:24.100 --> 08:25.100
是变成了2了

08:25.100 --> 08:26.100
说明啥

08:26.100 --> 08:27.100
说明这个寒树的运行过程中

08:27.100 --> 08:29.100
把这个碗样变成了2了

08:29.100 --> 08:32.100
所以里边可以访问外边的

08:32.100 --> 08:34.100
你可以这样去理解

08:35.100 --> 08:36.100
比方说这样

08:36.100 --> 08:38.100
像你家庭是一个单位

08:38.100 --> 08:39.100
对吧

08:39.100 --> 08:41.100
国家也是一个单位

08:41.100 --> 08:44.100
那家庭是在国家里边的

08:44.100 --> 08:45.100
对不对

08:45.100 --> 08:47.100
我们平时在生活中

08:47.100 --> 08:48.100
是不是还是可以使用

08:48.100 --> 08:50.100
国家提供的公共资源

08:50.100 --> 08:51.100
对吧

08:51.100 --> 08:52.100
那就是个意思

08:52.100 --> 08:54.100
里边可以访问外边的

08:54.100 --> 08:57.100
但是外边是不能访问里边的

08:57.100 --> 08:59.100
国家不能跑到你家里边

08:59.100 --> 09:00.100
来拿东西

09:00.100 --> 09:01.100
那是不行的

09:01.100 --> 09:03.100
那么这就是

09:03.100 --> 09:04.100
这个是不一样的情况

09:04.100 --> 09:06.100
外边不能访问里边

09:06.100 --> 09:07.100
里边可以访问外边

09:07.100 --> 09:09.100
比方说我这个M寒树里边

09:09.100 --> 09:11.100
定义了一个变量N

09:11.100 --> 09:12.100
那我在外边

09:12.100 --> 09:14.100
能不能去输出这个N呢

09:14.100 --> 09:15.100
那肯定是不行的

09:15.100 --> 09:16.100
他报错了

09:16.100 --> 09:18.100
他说N is not defined

09:18.100 --> 09:20.100
说N不存在

09:20.100 --> 09:21.100
未定义

09:21.100 --> 09:22.100
这样子

09:22.100 --> 09:23.100
为什么要这样子去设计

09:23.100 --> 09:25.100
这样子设计

09:25.100 --> 09:26.100
是有好处的

09:26.100 --> 09:27.100
为什么有好处的

09:27.100 --> 09:28.100
这样子

09:28.100 --> 09:30.100
我在调用这个寒树的时候

09:30.100 --> 09:32.100
我就不用关心

09:32.100 --> 09:33.100
说你这个寒树啊

09:33.100 --> 09:35.100
里边是咋实现的呀

09:35.100 --> 09:37.100
你定义了哪些变量啊

09:37.100 --> 09:38.100
那我这里定义变量的时候

09:38.100 --> 09:39.100
会不会给你这个

09:39.100 --> 09:41.100
里边的东西当成冲突啊

09:41.100 --> 09:43.100
我们之前讲寒树的时候说过

09:43.100 --> 09:45.100
你在调用寒树的时候

09:45.100 --> 09:47.100
你就不要去想寒树

09:47.100 --> 09:48.100
里边是咋写的

09:48.100 --> 09:50.100
跟你有啥关系呢

09:50.100 --> 09:51.100
比方说我们这里写个

09:51.100 --> 09:52.100
寒树漏个

09:52.100 --> 09:54.100
这是不是调用寒树啊

09:54.100 --> 09:55.100
这是不是调用寒树

09:55.100 --> 09:56.100
那肯定是嘛

09:56.100 --> 09:58.100
你知不知道他里边咋写的

09:58.100 --> 10:00.100
你不需要知道吧

10:00.100 --> 10:02.100
你知不知道这个寒树里边

10:02.100 --> 10:03.100
他定义了哪些变量

10:03.100 --> 10:05.100
你不需要知道吧

10:05.100 --> 10:08.100
如果说外边能访问里边

10:08.100 --> 10:10.100
那就这个事情就太吓人了

10:10.100 --> 10:12.100
有多吓人呢

10:12.100 --> 10:15.100
我现在连一个变量都不敢定义了

10:15.100 --> 10:16.100
因为我定一个变量的时候

10:16.100 --> 10:17.100
我还要想

10:17.100 --> 10:18.100
那万一这个寒树里边

10:18.100 --> 10:19.100
也有一个变量

10:19.100 --> 10:21.100
哎怎么办

10:21.100 --> 10:23.100
所以这个事情就太恐怖了

10:23.100 --> 10:24.100
所以外边他肯定是

10:24.100 --> 10:25.100
不能访问里边的

10:25.100 --> 10:26.100
这样子可以让我们

10:26.100 --> 10:27.100
调用寒树的时候

10:27.100 --> 10:28.100
非常的轻松

10:28.100 --> 10:31.100
我不用想你里边哪些变量

10:31.100 --> 10:32.100
反正跟我没关系

10:32.100 --> 10:33.100
里边I定有哪些定有哪些

10:33.100 --> 10:35.100
跟我没关系

10:35.100 --> 10:36.100
懂了意思吧

10:36.100 --> 10:38.100
这是这个调

10:38.100 --> 10:39.100
访问的时候呢

10:39.100 --> 10:41.100
就是里边访问外边的时候

10:41.100 --> 10:46.100
是从内向外一次查找

10:46.100 --> 10:48.100
比方说我这个M里边

10:48.100 --> 10:51.100
也有一个变量A

10:51.100 --> 10:53.100
那这就有意思了

10:53.100 --> 10:54.100
那么这个时候

10:54.100 --> 10:55.100
我调用完寒树之后

10:55.100 --> 10:58.100
我再再输出A

10:58.100 --> 10:59.100
你会发现了

10:59.100 --> 11:00.100
它没有变化这个A

11:00.100 --> 11:02.100
这个A没有变化

11:02.100 --> 11:03.100
我这里用的是哪个A

11:03.100 --> 11:04.100
用的是肯定不是它

11:04.100 --> 11:05.100
对吧

11:05.100 --> 11:06.100
外边不能访问里边

11:06.100 --> 11:08.100
用的肯定跟它里边没关系

11:08.100 --> 11:09.100
是隔绝的

11:09.100 --> 11:10.100
那我用的是肯定是它

11:10.100 --> 11:12.100
对不对

11:12.100 --> 11:13.100
那我用它的时候

11:13.100 --> 11:15.100
发现它没有变化

11:15.100 --> 11:16.100
但是这里边

11:16.100 --> 11:17.100
确实有把A夹夹了

11:17.100 --> 11:18.100
那这是怎么回事呢

11:18.100 --> 11:20.100
是因为这个里边

11:20.100 --> 11:22.100
它也有一个A

11:23.100 --> 11:25.100
是不是也有一个A

11:25.100 --> 11:26.100
那么这个A

11:26.100 --> 11:29.100
由于它定义在寒树M里边

11:29.100 --> 11:30.100
因此

11:30.100 --> 11:33.100
这个A的作用域是这个寒树

11:33.100 --> 11:34.100
那一说M里边

11:34.100 --> 11:36.100
它就可以访问这些东西了

11:36.100 --> 11:38.100
可以访问里边的A

11:38.100 --> 11:40.100
也可以访问外边的A

11:40.100 --> 11:41.100
那用的时候

11:41.100 --> 11:42.100
我到底用的是哪一个呢

11:42.100 --> 11:43.100
我这里比较A加加

11:43.100 --> 11:44.100
用的是哪一个呢

11:44.100 --> 11:48.100
由内而外进行查找

11:48.100 --> 11:50.100
由你向外进行查找

11:50.100 --> 11:51.100
所以说

11:51.100 --> 11:52.100
它先发现了自己有A

11:52.100 --> 11:54.100
于是用的就是自己的

11:54.100 --> 11:56.100
懂了意思吧

11:56.100 --> 11:57.100
你也清楚没

11:57.100 --> 11:58.100
就是第一条

11:58.100 --> 12:00.100
里边能访问外边

12:00.100 --> 12:01.100
反过来就不行

12:01.100 --> 12:02.100
访问的时候

12:02.100 --> 12:03.100
从内向外查找

12:03.100 --> 12:04.100
其实这个玩意

12:04.100 --> 12:05.100
你开始接触了

12:05.100 --> 12:06.100
可能觉得

12:06.100 --> 12:08.100
是不是还要记一下

12:08.100 --> 12:09.100
久而久之

12:09.100 --> 12:11.100
这个东西跟呼吸一样

12:11.100 --> 12:12.100
都形成本能了

12:12.100 --> 12:13.100
对吧

12:13.100 --> 12:14.100
一位同学不知道怎么呼吸的

12:14.100 --> 12:16.100
一位同学不知道怎么走路的

12:16.100 --> 12:17.100
当你小时候

12:17.100 --> 12:19.100
刚刚开始学走路的时候

12:19.100 --> 12:20.100
很困难

12:20.100 --> 12:22.100
当然可能忘了

12:22.100 --> 12:23.100
一看别的小孩了

12:23.100 --> 12:24.100
那走路是不是

12:24.100 --> 12:25.100
还经过很长时间

12:25.100 --> 12:26.100
但是一旦形成习惯

12:26.100 --> 12:27.100
我们不需要

12:27.100 --> 12:28.100
经过那么长时间

12:28.100 --> 12:29.100
对吧

12:29.100 --> 12:30.100
一两天就够了

12:30.100 --> 12:31.100
那就形成习惯之后

12:31.100 --> 12:32.100
你就觉得

12:32.100 --> 12:33.100
这个玩意理所当然的

12:33.100 --> 12:34.100
如果从哪一天语言

12:34.100 --> 12:36.100
它有某一门语言

12:36.100 --> 12:38.100
它不是这样子的

12:38.100 --> 12:39.100
比方说有门语言

12:39.100 --> 12:40.100
很奇怪

12:40.100 --> 12:41.100
我外边能访问里边

12:41.100 --> 12:42.100
里边不能访问外边

12:42.100 --> 12:44.100
那觉得天都塌下来了

12:44.100 --> 12:45.100
实际上

12:45.100 --> 12:46.100
有没有这样的语言呢

12:46.100 --> 12:47.100
我目前没有看到

12:47.100 --> 12:48.100
有这样的语言

12:48.100 --> 12:49.100
里边能访问外边

12:49.100 --> 12:51.100
外边不能访问里边

12:51.100 --> 12:53.100
都是这样子的

12:53.100 --> 12:56.100
说这也不是什么界是特有的

12:56.100 --> 12:58.100
这是第一条

12:58.100 --> 12:59.100
然后这一条

12:59.100 --> 13:02.100
如果在里边访问了外边

13:02.100 --> 13:04.100
这会产生必包

13:04.100 --> 13:05.100
这跟着词呢

13:05.100 --> 13:07.100
有很多同学就特别害怕

13:07.100 --> 13:09.100
这个必包是啥意思

13:09.100 --> 13:11.100
这个玩意

13:11.100 --> 13:12.100
怎么说呢

13:12.100 --> 13:13.100
翻译过来也指

13:13.100 --> 13:17.100
它的英文叫clawier

13:17.100 --> 13:20.100
这个玩意是跟那个

13:20.100 --> 13:22.100
编译原理有些关系的

13:22.100 --> 13:23.100
但是呢

13:23.100 --> 13:26.100
我们也不可能去讲那么深

13:26.100 --> 13:28.100
也没有哪个去编译前端

13:28.100 --> 13:29.100
讲那么深

13:29.100 --> 13:30.100
包括编译关下自己

13:30.100 --> 13:32.100
可能也编译原理那一块

13:32.100 --> 13:33.100
也不是很清楚

13:33.100 --> 13:34.100
因此呢

13:34.100 --> 13:35.100
这个词

13:35.100 --> 13:37.100
你就当它就是一个词

13:37.100 --> 13:38.100
就是如果说

13:38.100 --> 13:39.100
在里边访问外边

13:39.100 --> 13:41.100
它就会产生一个叉叉叉

13:41.100 --> 13:42.100
这个叉叉叉就叫做必包

13:42.100 --> 13:43.100
这个必包跟你有啥关系呢

13:43.100 --> 13:44.100
没啥关系

13:44.100 --> 13:46.100
它就是这么一种现象

13:46.100 --> 13:47.100
比如说

13:47.100 --> 13:49.100
我这里的这个变叠里边

13:49.100 --> 13:51.100
我这里输出了一个

13:51.100 --> 13:52.100
就用了一个A加加

13:52.100 --> 13:53.100
那么这个函数

13:53.100 --> 13:55.100
是不是用的外边东西

13:55.100 --> 13:56.100
它自己没有A吗

13:56.100 --> 13:57.100
没有A的话

13:57.100 --> 13:59.100
它就会用外边了

13:59.100 --> 14:01.100
是不是可以用外边的

14:01.100 --> 14:03.100
当然它有A的情况下

14:03.100 --> 14:04.100
它用的就是里边了

14:04.100 --> 14:06.100
包括你是变叠定义

14:06.100 --> 14:07.100
或者是你是参数

14:07.100 --> 14:08.100
这个参数也是

14:08.100 --> 14:10.100
相当于是在这个中容语里边

14:10.100 --> 14:11.100
这个参数

14:11.100 --> 14:13.100
那么它也是里边的东西

14:13.100 --> 14:14.100
因此这个A呢

14:14.100 --> 14:15.100
指的是这个参数

14:16.100 --> 14:17.100
给它说一下

14:17.100 --> 14:18.100
它有自己的

14:18.100 --> 14:19.100
它就用自己的

14:19.100 --> 14:20.100
没有自己的

14:20.100 --> 14:21.100
它就会用外边的

14:21.100 --> 14:22.100
现在是不是也用外边的

14:22.100 --> 14:23.100
那么现在在用外边的

14:23.100 --> 14:24.100
它就产生了必包

14:24.100 --> 14:25.100
就这么简单

14:25.100 --> 14:27.100
那必包有啥用没啥用

14:27.100 --> 14:29.100
它就是这么一个现象

14:29.100 --> 14:30.100
你可以随意的用外边

14:30.100 --> 14:31.100
就行了

14:31.100 --> 14:33.100
你可以随意的用

14:33.100 --> 14:34.100
那用了就产生必包了

14:34.100 --> 14:36.100
你不用去刻意的

14:36.100 --> 14:37.100
这个必包出来了

14:37.100 --> 14:38.100
又会怎么样怎么样

14:38.100 --> 14:39.100
不怎么样

14:39.100 --> 14:40.100
不怎么样

14:40.100 --> 14:41.100
它有没有先影响了

14:41.100 --> 14:42.100
有一些影响

14:42.100 --> 14:43.100
我们以后留着面

14:43.100 --> 14:44.100
比面试再说

14:44.100 --> 14:45.100
我们现在就需要知道

14:45.100 --> 14:46.100
你可以访问外边

14:46.100 --> 14:47.100
访问的外边

14:47.100 --> 14:48.100
你就是必包

14:48.100 --> 14:49.100
又产生了必包

14:51.100 --> 14:52.100
你只需要知道这么个概念

14:52.100 --> 14:53.100
就行了

14:53.100 --> 14:54.100
跟你开发没有什么关系

14:55.100 --> 14:56.100
所以呢

14:57.100 --> 14:58.100
在这里

14:58.100 --> 14:59.100
我们调用这个函数

14:59.100 --> 15:00.100
那么它就用了外边

15:00.100 --> 15:01.100
然后用了外面产生必包

15:01.100 --> 15:02.100
就没啥了

15:02.100 --> 15:03.100
就这么简单

15:03.100 --> 15:04.100
好 OK

15:04.100 --> 15:05.100
那么这是这个

15:05.100 --> 15:06.100
你只需要知道

15:06.100 --> 15:07.100
这么一个现象就行了

15:09.100 --> 15:10.100
然后下一个

15:10.100 --> 15:12.100
内部作用欲

15:12.100 --> 15:13.100
能访问外部

15:13.100 --> 15:14.100
这个地方

15:14.100 --> 15:15.100
是非常容易出面

15:15.100 --> 15:16.100
是提的

15:16.100 --> 15:18.100
取决于函数定义的位置

15:18.100 --> 15:20.100
和调用无关

15:20.100 --> 15:22.100
那么这又是啥意思

15:22.100 --> 15:23.100
那比方说

15:23.100 --> 15:24.100
我这个M函数

15:24.100 --> 15:25.100
就把A加加

15:25.100 --> 15:26.100
接下来

15:26.100 --> 15:27.100
让我再来一个函数

15:28.100 --> 15:29.100
M2

15:30.100 --> 15:31.100
这个函数

15:31.100 --> 15:32.100
我又定义了一个A

15:32.100 --> 15:33.100
3

15:33.100 --> 15:36.730
然后调用M

15:36.730 --> 15:38.730
我在这里输出A

15:38.730 --> 15:39.730
然后我在外边

15:39.730 --> 15:40.730
调用M2

15:40.730 --> 15:42.730
我在这里再输出A

15:42.730 --> 15:43.730
那就看一下这个逻辑

15:44.730 --> 15:45.730
我们前面都是函数定义

15:45.730 --> 15:46.730
函数定义

15:46.730 --> 15:47.730
变量定义

15:47.730 --> 15:48.730
那我们看一下

15:48.730 --> 15:49.730
因为函数定义

15:49.730 --> 15:50.730
它并不会运行

15:50.730 --> 15:52.730
我们要看函数调用

15:52.730 --> 15:53.730
调用了M2

15:53.730 --> 15:54.730
让它运行一遍

15:54.730 --> 15:55.730
走一遍

15:55.730 --> 15:56.730
走一遍的时候

15:56.730 --> 15:57.730
是不是这里定义了

15:57.730 --> 15:58.730
一个A等于3

15:58.730 --> 15:59.730
那这个A是谁的

15:59.730 --> 16:00.730
A是M2的

16:00.730 --> 16:01.730
对吧

16:01.730 --> 16:02.730
A是属于M2的

16:02.730 --> 16:03.730
然后调用M

16:03.730 --> 16:05.730
那么这里的A加加

16:05.730 --> 16:06.730
现在其实就是在考虑

16:06.730 --> 16:07.730
什么呢

16:07.730 --> 16:08.730
考虑

16:08.730 --> 16:09.730
这个调用M

16:09.730 --> 16:10.730
把这里走一遍的时候

16:10.730 --> 16:11.730
它用到了A

16:11.730 --> 16:12.730
有没有A吗

16:12.730 --> 16:13.730
有没有A

16:13.730 --> 16:14.730
它只能用外边的

16:14.730 --> 16:15.730
那么外边到底

16:15.730 --> 16:16.730
用的是谁

16:16.730 --> 16:17.730
用的是这个A

16:17.730 --> 16:18.730
还是这个A

16:18.730 --> 16:19.730
是不一样的对吧

16:19.730 --> 16:20.730
这个A在M2里边

16:20.730 --> 16:21.730
这个A是全局的

16:21.730 --> 16:23.730
用的是到底是哪一个A

16:23.730 --> 16:25.730
用的是到底是哪一个A呢

16:25.730 --> 16:26.730
看这

16:27.730 --> 16:29.730
它访问外部的时候

16:29.730 --> 16:32.730
取决于函数定义的位置

16:32.730 --> 16:34.730
和调用无关

16:34.730 --> 16:35.730
跟这里

16:35.730 --> 16:36.730
跟你在哪里

16:36.730 --> 16:38.730
调用是没有关系的

16:38.730 --> 16:39.730
用的是哪里呢

16:39.730 --> 16:40.730
用的是这个函数

16:40.730 --> 16:41.730
定义的时候

16:41.730 --> 16:42.730
在哪里定义的

16:42.730 --> 16:43.730
在全局定义的

16:43.730 --> 16:44.730
定的时候

16:44.730 --> 16:45.730
外边的A是哪个A

16:45.730 --> 16:46.730
是不是这个A

16:46.730 --> 16:47.730
是不是这个A

16:47.730 --> 16:48.730
所以说A加加加的是谁

16:48.730 --> 16:49.730
加的是这个A

16:49.730 --> 16:51.730
因此它加的是这个A的话

16:51.730 --> 16:53.730
那你这里

16:53.730 --> 16:54.730
你这里输出

16:54.730 --> 16:55.730
这里输出A

16:55.730 --> 16:56.730
输出它

16:56.730 --> 16:57.730
输出它里边的A

16:57.730 --> 16:58.730
对吧

16:58.730 --> 17:00.730
是不是输出它里边的A

17:00.730 --> 17:01.730
输出这个A

17:01.730 --> 17:02.730
输出这个A的时候

17:02.730 --> 17:03.730
那个A是不是没变

17:03.730 --> 17:04.730
还是它

17:04.730 --> 17:05.730
对不对

17:05.730 --> 17:06.730
所以这里

17:06.730 --> 17:07.730
输出的多少

17:07.730 --> 17:08.730
输出3

17:09.730 --> 17:12.730
数字怎么没变了

17:12.730 --> 17:13.730
好

17:13.730 --> 17:14.730
这里输出3

17:14.730 --> 17:15.730
然后接下来

17:15.730 --> 17:17.730
我就能出空本吧

17:17.730 --> 17:18.730
没变

17:19.730 --> 17:21.730
下边这个输出A呢

17:21.730 --> 17:22.730
就这里呢

17:22.730 --> 17:23.730
那这里输出啥呢

17:23.730 --> 17:24.730
这里就

17:24.730 --> 17:26.730
输出的是全局的A

17:26.730 --> 17:27.730
那它加的是谁

17:27.730 --> 17:28.730
加的就全局的A

17:28.730 --> 17:29.730
所以这里输出2

17:29.730 --> 17:31.730
因此最终得到的结果呢

17:31.730 --> 17:33.730
是3 2

17:33.730 --> 17:35.730
3 2

17:35.730 --> 17:39.490
运行一下

17:40.490 --> 17:42.490
把这道题看清楚

17:42.490 --> 17:44.490
这一个地方容易出面试题

17:44.490 --> 17:46.490
其实我们平时开发的话

17:46.490 --> 17:47.490
都没有关注

17:47.490 --> 17:48.490
反正我没有关注过

17:48.490 --> 17:49.490
没去关注过

17:49.490 --> 17:51.490
但是如果说出到面试题

17:51.490 --> 17:52.490
你要关注

17:52.490 --> 17:53.490
要把关注起来

17:53.490 --> 17:54.490
好吧

17:54.490 --> 17:55.490
这是这一块

17:55.490 --> 17:57.490
我先把个鼠标电池

17:57.490 --> 17:58.490
还是弄一下吧

17:58.490 --> 18:00.490
弄一下鼠标电池

18:00.490 --> 18:03.180
好

18:03.180 --> 18:04.180
那么这一点就说完了

18:04.180 --> 18:05.180
这三点

18:05.180 --> 18:06.180
里边能访问外边

18:06.180 --> 18:07.180
这些都是非常自然的

18:07.180 --> 18:09.180
后边我说都不用说了

18:09.180 --> 18:11.180
你就应该能感觉到了

18:11.180 --> 18:12.180
访问的时候

18:12.180 --> 18:14.180
从内向外一色查照

18:14.180 --> 18:15.180
都是非常自然的

18:15.180 --> 18:16.180
不需要去背

18:16.180 --> 18:18.180
如果说里边访问外边

18:18.180 --> 18:19.180
就会产生必包

18:19.180 --> 18:21.180
知道这么个概念就行了

18:21.180 --> 18:22.180
现在对你们用处

18:22.180 --> 18:23.180
没有什么用处

18:23.180 --> 18:24.180
就知道这么个概念就行了

18:24.180 --> 18:25.180
你随便访问外边

18:25.180 --> 18:27.180
访问了就产生必包了

18:27.180 --> 18:29.180
然后里边访问外边的时候

18:29.180 --> 18:31.180
取决于函数定义的位置

18:31.180 --> 18:33.180
就这个地方

18:33.180 --> 18:34.180
就影响做面试题

18:34.180 --> 18:37.180
主要是影响做面试题

18:37.180 --> 18:39.180
然后第二个点

18:39.180 --> 18:41.180
作用率里边定义的变量

18:41.180 --> 18:43.180
函数声明会提升到

18:43.180 --> 18:45.180
作用率顶部

18:45.180 --> 18:48.180
这一块跟我们开发是有关系的

18:48.180 --> 18:50.180
比方说什么意思呢

18:50.180 --> 18:52.750
比方说这里有个变量

18:52.750 --> 18:53.750
对吧

18:53.750 --> 18:54.750
那我可以在变量之前

18:54.750 --> 18:56.750
去访问一个变量吗

18:56.750 --> 18:58.750
在很多语言里边是不允许的

18:58.750 --> 18:59.750
但是介石

18:59.750 --> 19:00.750
它是一个神奇的语言

19:00.750 --> 19:01.750
它可以

19:01.750 --> 19:02.750
而且它不爆错

19:02.750 --> 19:04.750
很多语言是要爆错了

19:04.750 --> 19:05.750
是要爆错了

19:05.750 --> 19:06.750
在这里不爆错

19:06.750 --> 19:08.750
它输出undefined

19:08.750 --> 19:10.750
不是一吗

19:10.750 --> 19:12.750
为什么会输出undefined的呢

19:12.750 --> 19:13.750
那你要说它不存在的话

19:13.750 --> 19:14.750
应该爆错

19:14.750 --> 19:15.750
是怎么回事呢

19:15.750 --> 19:17.750
就是这句话的原因

19:17.750 --> 19:19.750
作用率里边的定义的变量

19:19.750 --> 19:20.750
函数声明的时候

19:20.750 --> 19:22.750
会提升到作用率顶部

19:22.750 --> 19:25.750
也就是说什么呢

19:25.750 --> 19:27.750
这里是两个

19:27.750 --> 19:28.750
作用率里边定义的变量

19:28.750 --> 19:29.750
函数声明

19:29.750 --> 19:30.750
就这两个东西

19:30.750 --> 19:32.750
会提升到作用率的顶部

19:32.750 --> 19:33.750
我首先问大家

19:33.750 --> 19:35.750
A是哪个作用率

19:35.750 --> 19:37.750
是不是全局作用率

19:37.750 --> 19:38.750
对吧

19:38.750 --> 19:39.750
因此你这句话

19:39.750 --> 19:40.750
是不是定义变量A

19:40.750 --> 19:42.750
那么定义这个变量A的动作

19:42.750 --> 19:45.750
它会提升到作用率的顶部

19:45.750 --> 19:47.750
就是最终形成的代码是这样子的

19:47.750 --> 19:51.320
所以为什么输出undefined的

19:51.320 --> 19:52.320
就这个原因

19:52.320 --> 19:53.320
对吧

19:53.320 --> 19:55.320
就是你刚才那个代码

19:55.320 --> 19:57.320
最终会变成这个玩意

19:57.320 --> 19:59.320
我们用这种简单的方式

19:59.320 --> 20:01.320
给大家说清楚了

20:01.320 --> 20:02.320
好

20:02.320 --> 20:03.320
那么除了变量之外

20:03.320 --> 20:05.320
还有一种其实也是一样的

20:05.320 --> 20:07.320
比方说这里有个函数M

20:08.320 --> 20:10.320
我在哪里定义的声明的函数

20:10.320 --> 20:12.320
我在这里声明的函数对吧

20:12.320 --> 20:13.320
在这里声明的函数

20:13.320 --> 20:15.320
然后我在这里输出M

20:15.320 --> 20:16.320
你看这个M是啥

20:17.320 --> 20:18.320
它就是一个函数

20:18.320 --> 20:19.320
对吧

20:19.320 --> 20:20.320
它是个方形

20:20.320 --> 20:21.320
它是一个函数

20:21.320 --> 20:23.320
也就是为什么在这里

20:23.320 --> 20:25.320
它也会得到函数

20:25.320 --> 20:26.320
不是在下边定义的吗

20:26.320 --> 20:27.320
是这样子

20:27.320 --> 20:29.320
所有在一个作用率里边

20:29.320 --> 20:31.320
所有的变量定义

20:31.320 --> 20:33.320
或者是函数声明

20:33.320 --> 20:36.320
全部都会跑到作用率的顶部

20:36.320 --> 20:37.320
都会跑到这来

20:37.320 --> 20:39.320
就你写到下边

20:39.320 --> 20:41.320
它也会跑到上面来

20:41.320 --> 20:42.320
懂了意思吧

20:42.320 --> 20:44.320
所以说你这里M得到的是函数

20:44.320 --> 20:46.320
A得到的是undefined

20:46.320 --> 20:47.320
那又对了

20:47.320 --> 20:49.320
那这样子写呢

20:49.320 --> 20:51.320
那这样子写又怎么来解释呢

20:51.320 --> 20:53.320
这样子就不叫函数声明了

20:53.320 --> 20:55.320
函数声明只有这种写法

20:55.320 --> 20:57.320
这种叫函数声明

20:57.320 --> 20:58.320
你直接写个方形

20:58.320 --> 20:59.320
然后函数明

20:59.320 --> 21:01.320
然后函数函数体

21:01.320 --> 21:03.320
这叫函数声明

21:03.320 --> 21:04.320
这个不是函数声明

21:04.320 --> 21:06.320
这叫函数表达式

21:06.320 --> 21:08.320
这叫函数表达式

21:08.320 --> 21:11.320
就是把这个函数作为一个值

21:11.320 --> 21:12.320
作为一个数据

21:12.320 --> 21:14.320
保存到变量B里边

21:14.320 --> 21:16.320
所以说这里叫变量声明

21:16.320 --> 21:17.320
它不叫函数声明

21:17.320 --> 21:18.320
之前还是说过

21:18.320 --> 21:20.320
那么这个单码就相当于是

21:20.320 --> 21:23.320
把这个变量声明又提到了顶部

21:23.320 --> 21:25.320
然后这里给B负值

21:25.320 --> 21:27.320
所以说你看这里输出啥呀

21:27.320 --> 21:29.320
输出B的话

21:29.320 --> 21:30.320
输出啥

21:30.320 --> 21:32.320
输出undefined

21:32.320 --> 21:34.320
然后一个函数

21:34.320 --> 21:37.320
那这个玩意跟我们开发有什么影响呢

21:37.320 --> 21:38.320
主要的影响在这

21:38.320 --> 21:40.320
就是我们在写单码的时候

21:40.320 --> 21:42.320
经常会写一些函数对吧

21:42.320 --> 21:44.320
我们不要在这里写个函数

21:44.320 --> 21:45.320
那你只需要知道一点

21:45.320 --> 21:47.320
这个函数无论写到哪个位置

21:47.320 --> 21:49.320
你在同一个作用域里边

21:49.320 --> 21:52.320
是可以在属于来访问这个函数的

21:52.320 --> 21:53.320
哪怕这个函数写下边

21:53.320 --> 21:54.320
你也可以函用它

21:54.320 --> 21:55.320
为什么

21:55.320 --> 21:56.320
就是因为它会提升

21:56.320 --> 21:57.320
提升到顶部去

21:57.320 --> 21:58.320
函数声明

21:58.320 --> 22:00.320
函数声明会提升到顶部去

22:00.320 --> 22:01.320
就这个原因

22:01.320 --> 22:03.320
所以说你用这种方式写的函数

22:03.320 --> 22:05.320
你可以在任何地方

22:05.320 --> 22:06.320
雕用

22:06.320 --> 22:07.320
在这个同一个作用域

22:07.320 --> 22:08.320
当然要同一个作用域里面

22:08.320 --> 22:11.320
任何地方都可以雕用

22:11.320 --> 22:12.320
懂得意思吧

22:12.320 --> 22:16.320
但是如果说你写的函数是这样子的

22:16.320 --> 22:19.320
你写的函数是这样子的

22:19.320 --> 22:21.320
那比方说你这个M吧

22:21.320 --> 22:23.320
那么这样子就不能雕用了

22:23.320 --> 22:24.320
为什么它不是一个函数声明

22:24.320 --> 22:26.320
它是一个函数表达式

22:26.320 --> 22:27.320
你看现在爆错了

22:27.320 --> 22:28.320
它说M is not function

22:28.320 --> 22:29.320
为什么

22:29.320 --> 22:30.320
因为这里的时候

22:30.320 --> 22:32.320
M还是一个undefined

22:32.320 --> 22:33.320
为什么

22:33.320 --> 22:34.320
刚才说了

22:34.320 --> 22:35.320
它这个玩意会提升到顶部

22:35.320 --> 22:36.320
边量定义

22:36.320 --> 22:38.320
然后在这里重新给边量复制

22:38.320 --> 22:40.320
这里是不是undefined

22:40.320 --> 22:41.320
是不是undefined

22:41.320 --> 22:43.320
那肯定是不能雕用的

22:43.320 --> 22:44.320
因此如果说

22:44.320 --> 22:45.320
你要用这种写法来

22:45.320 --> 22:46.320
输写函数的话

22:46.320 --> 22:48.320
你应该在下边雕用

22:48.320 --> 22:49.320
你只能在下边雕用

22:49.320 --> 22:50.320
对我们平时开发的话

22:50.320 --> 22:52.320
就是这个影响

22:52.320 --> 22:54.320
其他的也没啥

22:54.320 --> 22:56.320
懂得意思吧

22:57.320 --> 22:59.320
中语里边定义的边量

22:59.320 --> 23:00.320
函数声明会提到中语里面

23:00.320 --> 23:01.320
当然我这是全句中语

23:01.320 --> 23:02.320
其他中语也是一样

23:02.320 --> 23:04.320
比方说我这里一个函数

23:04.320 --> 23:06.320
我再调整它吧

23:06.320 --> 23:08.320
在这个函数里边

23:08.320 --> 23:09.320
我又定义了一个边量

23:09.320 --> 23:11.320
A等于1

23:11.320 --> 23:14.320
然后有一个方个型B

23:14.320 --> 23:17.320
然后有一个C等于方个型

23:17.320 --> 23:20.320
那么我在前边输出

23:20.320 --> 23:23.320
输出A B C

23:23.320 --> 23:24.320
那么分别输出啥

23:25.320 --> 23:26.320
其实是一样的对不对

23:26.320 --> 23:27.320
是一样的

23:27.320 --> 23:29.320
这里的这个边量

23:29.320 --> 23:32.320
它会提到这个作用剧的顶部

23:32.320 --> 23:34.320
然后呢

23:34.320 --> 23:37.320
这个函数也会提到顶部

23:37.320 --> 23:40.320
然后这个玩意儿也会提到顶部

23:40.320 --> 23:43.400
对吧

23:43.400 --> 23:45.400
你到底说它输出啥吗

23:45.400 --> 23:47.400
只能是undefined

23:47.400 --> 23:50.400
函数 undefined

23:50.400 --> 23:51.400
对吧

23:51.400 --> 23:52.400
得到结果

23:52.400 --> 23:54.400
undefined 函数 undefined

23:54.400 --> 23:56.400
并不复杂

23:56.400 --> 23:57.400
这一块并不复杂

23:57.400 --> 23:58.400
说了那么多

23:58.400 --> 24:00.400
其实你过了几个小时

24:00.400 --> 24:02.400
你把你眼清楚过后

24:02.400 --> 24:03.400
以后就跟那个呼吸一样

24:03.400 --> 24:05.400
是一个非常自然的现象

24:05.400 --> 24:08.400
你脑袋里边都不需要专门去过它

24:08.400 --> 24:09.400
它非常自然

24:09.400 --> 24:10.400
这就是我们的现象

24:10.400 --> 24:11.400
然后呢

24:11.400 --> 24:12.400
现在我们看一下面试题

24:12.400 --> 24:14.400
长刀面试题

24:14.400 --> 24:17.710
地刀面试题比较简单

24:17.710 --> 24:18.710
问你这个玩意儿是啥

24:18.710 --> 24:19.710
这个玩意儿是不是刚才说了

24:19.710 --> 24:20.710
是啥

24:20.710 --> 24:21.710
你说是啥吧

24:21.710 --> 24:22.710
你说是啥吧

24:22.710 --> 24:24.710
这个玩意儿 undefined

24:24.710 --> 24:25.710
这个玩意儿

24:25.710 --> 24:27.710
这个玩意儿 undefined

24:27.710 --> 24:28.710
这个玩意儿函数

24:28.710 --> 24:29.710
对吧

24:29.710 --> 24:30.710
前面两个undefined

24:30.710 --> 24:32.710
后面一个函数

24:32.710 --> 24:34.710
就这样

24:34.710 --> 24:35.710
好

24:35.710 --> 24:36.710
然后下面第二题

24:36.710 --> 24:38.710
第二题下面在那边输出啥

24:38.710 --> 24:42.090
就是啥

24:42.090 --> 24:43.090
你看吧

24:43.090 --> 24:44.090
前面有两个变量

24:44.090 --> 24:45.090
然后那调用ME这个函数

24:45.090 --> 24:46.090
对吧

24:46.090 --> 24:47.090
调用它

24:47.090 --> 24:48.090
好 开始执行边

24:48.090 --> 24:49.090
好 这里输出A

24:49.090 --> 24:50.090
那这里要想了

24:50.090 --> 24:52.090
我自己有A吗

24:52.090 --> 24:54.090
我自己没有A

24:54.090 --> 24:55.090
那这个是啥

24:56.090 --> 24:58.090
而且它还有提升

24:58.090 --> 24:59.090
对吧

24:59.090 --> 25:00.090
这个玩意儿是不是会提升到这

25:01.090 --> 25:02.090
变量提升

25:02.090 --> 25:03.090
它会提升到这

25:03.090 --> 25:04.090
说它自己有没有A

25:04.090 --> 25:05.090
自己肯定有A

25:06.090 --> 25:07.090
是不是

25:07.090 --> 25:08.090
那这里输出啥

25:08.090 --> 25:09.090
输出自己的

25:09.090 --> 25:10.090
自己的A是啥

25:10.090 --> 25:11.090
那就是undefined

25:11.090 --> 25:12.090
对吧

25:12.090 --> 25:14.090
所以这一块

25:15.090 --> 25:17.090
第一个输出undefined

25:18.090 --> 25:19.090
好

25:19.090 --> 25:20.090
然后把这个A

25:20.090 --> 25:22.090
给自己的F只为3

25:22.090 --> 25:23.090
对吧

25:23.090 --> 25:24.090
不是外边的

25:24.090 --> 25:25.090
自己的F只为3

25:25.090 --> 25:26.090
然后这里有个函数M2

25:26.090 --> 25:27.090
然后调用M2

25:27.090 --> 25:28.090
好

25:28.090 --> 25:29.090
M2开始运行

25:29.090 --> 25:30.090
运行的时候

25:30.090 --> 25:31.090
M2还要输出A何必

25:31.090 --> 25:33.090
那它输出的A是哪个A

25:33.090 --> 25:34.090
看自己有没有A

25:34.090 --> 25:35.090
看M2自己有没有A

25:35.090 --> 25:36.090
没有A吗

25:36.090 --> 25:37.090
于是它就输出

25:37.090 --> 25:38.090
找到谁

25:38.090 --> 25:40.090
从那项外一次寻找

25:40.090 --> 25:41.090
是不是先找外边的

25:41.090 --> 25:42.090
找外边的

25:42.090 --> 25:43.090
哪里

25:43.090 --> 25:44.090
是不是找M1

25:44.090 --> 25:45.090
找M1

25:45.090 --> 25:46.090
是不是找到一个A

25:46.090 --> 25:47.090
自己

25:47.090 --> 25:48.090
是不是3

25:48.090 --> 25:49.090
因此这里会输出

25:51.090 --> 25:53.090
会输出3

25:53.090 --> 25:55.090
然后第二个B

25:55.090 --> 25:57.460
第二个B

25:57.460 --> 25:58.460
它自己有没有B

25:58.460 --> 25:59.460
没有B

25:59.460 --> 26:00.460
好

26:00.460 --> 26:01.460
找M1的

26:01.460 --> 26:02.460
M1有没有B

26:02.460 --> 26:03.460
也没有B

26:03.460 --> 26:04.460
是不是找外边的

26:04.460 --> 26:05.460
找到谁

26:05.460 --> 26:06.460
找到2

26:07.460 --> 26:08.460
是不是说是undefined

26:08.460 --> 26:09.460
32

26:11.460 --> 26:12.460
然后第三题

26:12.460 --> 26:14.460
这是百度的一段面试题

26:15.460 --> 26:16.460
看一下

26:16.460 --> 26:17.460
这个大面试其实

26:17.460 --> 26:18.460
我刚才都讲了

26:18.460 --> 26:19.460
其实

26:19.460 --> 26:20.460
它做的是什么呢

26:20.460 --> 26:21.460
它考验的就是

26:21.460 --> 26:22.460
这个A加加

26:22.460 --> 26:23.460
到底加的是谁

26:23.460 --> 26:24.460
加的是这个A

26:24.460 --> 26:26.460
还是这个A

26:26.460 --> 26:27.460
是讲过的

26:27.460 --> 26:28.460
你们自己去看吧

26:28.460 --> 26:29.460
加的是谁

26:29.460 --> 26:30.460
家里肯定是他

26:30.460 --> 26:31.460
对不对

26:31.460 --> 26:32.460
说这个A有没有变动

26:32.460 --> 26:33.460
它自己M2的A

26:33.460 --> 26:34.460
有没有变动

26:34.460 --> 26:35.460
没有变动

26:35.460 --> 26:36.460
还是2

26:36.460 --> 26:37.460
那么这个A

26:37.460 --> 26:38.460
全具的A有变动

26:38.460 --> 26:39.460
它被加一了

26:39.460 --> 26:42.030
说22

26:42.030 --> 26:43.030
就完了

26:43.030 --> 26:45.030
这节课的东西

26:45.030 --> 26:47.030
存概念性质

26:47.030 --> 26:49.030
讲这个概念性质的目的

26:49.030 --> 26:50.030
一方面

26:50.030 --> 26:52.030
是要消除大家的疑惑

26:52.030 --> 26:53.030
大家之前

26:53.030 --> 26:55.030
可能有些同学有些疑惑

26:55.030 --> 26:56.030
就是我韩束里边定义了变量

26:56.030 --> 26:57.030
外边又变量了

26:57.030 --> 26:58.030
冲突了怎么办

26:58.030 --> 26:59.030
对吧

26:59.030 --> 27:01.030
完全不用考虑冲突

27:01.030 --> 27:02.030
韩束里边对韩束里边而言

27:02.030 --> 27:03.030
它又有自己的

27:03.030 --> 27:04.030
它又用自己的

27:04.030 --> 27:06.030
它就不会用外边的

27:06.030 --> 27:07.030
对外边而言

27:07.030 --> 27:08.030
压根就不能用

27:08.030 --> 27:09.030
我韩束里边的东西

27:09.030 --> 27:10.030
你就可以认为

27:10.030 --> 27:11.030
他们之间是

27:11.030 --> 27:12.030
隔绝的

27:12.030 --> 27:13.030
不会产生冲突

27:13.030 --> 27:14.030
不然的话

27:14.030 --> 27:15.030
就乱了套了

27:15.030 --> 27:16.030
你脑袋里边就负担太重了

27:16.030 --> 27:17.030
我掉入韩束的时候

27:17.030 --> 27:18.030
我还要想

27:18.030 --> 27:19.030
它里边咋写的

27:19.030 --> 27:20.030
有哪些变量

27:20.030 --> 27:21.030
然后我就封掉了

27:21.030 --> 27:22.030
这完全不用考虑它里边

27:22.030 --> 27:23.030
它里边的东西

27:23.030 --> 27:24.030
只有在它里边存在

27:24.030 --> 27:27.030
除了它里边就不存在了

27:27.030 --> 27:30.030
一个是这方面的疑惑

27:30.030 --> 27:32.030
另外一方面就是

27:32.030 --> 27:34.030
能够知道一些

27:34.030 --> 27:35.030
核心的概念

27:35.030 --> 27:36.030
不然的话

27:36.030 --> 27:37.030
后面说到一些术语

27:37.030 --> 27:38.030
你都不知道

27:38.030 --> 27:39.030
说什么变量提升

27:39.030 --> 27:40.030
你都不知道我能说啥

27:40.030 --> 27:41.030
说什么必保

27:41.030 --> 27:42.030
你都不知道我能说啥

27:42.030 --> 27:43.030
必保是什么

27:43.030 --> 27:44.030
就是韩束里边

27:44.030 --> 27:45.030
用到的外边就是必保

27:47.030 --> 27:48.030
好了

27:48.030 --> 27:49.030
那就没啥了

27:49.030 --> 27:51.030
这就是这节课的内容

