WEBVTT

00:00.000 --> 00:02.000
好 下一个第三方库

00:02.000 --> 00:04.000
moment 你看那个库的名字

00:04.000 --> 00:05.000
是做什么的

00:05.000 --> 00:08.000
就做时间处理的 日期时间处理

00:08.000 --> 00:09.000
因为讲门介石里面

00:09.000 --> 00:11.000
实际上是有这么一个对象的dead

00:11.000 --> 00:13.000
对吧 它可以创建一个日期

00:13.000 --> 00:15.000
但是它里面的API比较少

00:15.000 --> 00:16.000
功能比较弱

00:16.000 --> 00:18.000
所以说有这么一个第三方库

00:18.000 --> 00:20.000
它增强了dead的功能

00:20.000 --> 00:22.000
就这么一回事

00:23.000 --> 00:26.000
那么平时我们在做开发的时候

00:26.000 --> 00:29.000
这个moments库到底什么情况下去使用呢

00:30.000 --> 00:31.000
是这样子

00:31.000 --> 00:35.000
如果说你的页面上显示时间那些

00:35.000 --> 00:38.000
不需要太多的时间处理的话

00:38.000 --> 00:40.000
那么这个dead的对象实际上是够用的

00:40.000 --> 00:42.000
比方说你就显示一个

00:42.000 --> 00:44.000
比方说平时我们经常用的显示

00:44.000 --> 00:48.000
显示一篇文章的年 月 日 时分秒

00:48.000 --> 00:49.000
对吧

00:50.000 --> 00:51.000
那么像这种情况下

00:51.000 --> 00:52.000
这个dead实际上是够用的

00:52.000 --> 00:54.000
你自己封装一个函数也能搞定

00:54.000 --> 00:56.000
但是有的时候我们页面上

00:56.000 --> 00:58.000
可能会需要一些日期处理

00:58.000 --> 01:00.000
比方说我在显示一篇新文的时候

01:00.000 --> 01:02.000
我不是用这种方式来显示的

01:02.000 --> 01:04.000
比方说我显示10年前

01:04.000 --> 01:06.000
显示这么几个字

01:06.000 --> 01:08.000
你不要简单的看这么几个字

01:08.000 --> 01:10.000
那么有可能它会显示10年前

01:10.000 --> 01:12.000
有可能会显示刚刚

01:12.000 --> 01:14.000
有可能会显示今天

01:14.000 --> 01:16.000
多少点 多少分 多少秒

01:16.000 --> 01:18.000
或者是显示昨天

01:18.000 --> 01:20.000
那么要显示这些文字其实还是蛮复杂的

01:20.000 --> 01:21.000
比方说有的时候

01:21.000 --> 01:23.000
我们可能需要用户注册的时候

01:23.000 --> 01:25.000
填写了一个生日

01:25.000 --> 01:26.000
我们要根据它的生日

01:26.000 --> 01:27.000
计算出年龄

01:27.000 --> 01:29.000
对吧 那个计算还是

01:29.000 --> 01:31.000
虽然说你可以做

01:31.000 --> 01:33.000
但是还是需要一段时间

01:33.000 --> 01:34.000
需要一些年代吧

01:34.000 --> 01:37.000
像这些如果说我们项目里边

01:37.000 --> 01:40.000
有一些跟日期时间处理相关的操作

01:40.000 --> 01:43.000
就可以考虑使用Moment这个库

01:43.000 --> 01:44.000
但是我给大家说一下

01:44.000 --> 01:46.000
Moment这个库有点大

01:46.000 --> 01:48.000
这个体积有点大

01:48.000 --> 01:50.000
如果说你需要获得一个

01:50.000 --> 01:52.000
轻量级的日期处理的话

01:52.000 --> 01:55.000
建议大家使用这个库 叫DEX FNS

01:55.000 --> 01:58.000
这个库的作用跟Moment差不多

01:58.000 --> 01:59.000
几乎是一样的

01:59.000 --> 02:01.000
只不过它的比较小一点

02:01.000 --> 02:02.000
它是支持垂斜性的

02:02.000 --> 02:03.000
什么叫垂斜性呢

02:03.000 --> 02:05.000
我们后边学到工程化之后

02:05.000 --> 02:09.000
就可以有效的减少库的体积

02:09.000 --> 02:11.000
但是我们这里讲的话

02:11.000 --> 02:12.000
还是讲这个Moment

02:12.000 --> 02:15.000
因为毕竟它知名度是最高的

02:15.000 --> 02:16.000
好 这个Moment这个库

02:16.000 --> 02:17.000
其实它并不复杂

02:17.000 --> 02:19.000
它本身并不复杂

02:19.000 --> 02:21.000
关键是我们在学习它之前

02:21.000 --> 02:24.000
你得知道一些关于程序里边的

02:24.000 --> 02:26.000
时间的基本概念

02:26.000 --> 02:27.000
我们再看一下吧

02:27.000 --> 02:28.000
有哪些基本概念

02:28.000 --> 02:29.000
实际上是时间的单位

02:29.000 --> 02:30.000
单位的话 这个

02:30.000 --> 02:31.000
你们就自己看一下吧

02:31.000 --> 02:33.000
这个没什么好说的

02:33.000 --> 02:34.000
然后是这么两个单词

02:34.000 --> 02:35.000
叫GMT UTC

02:35.000 --> 02:37.000
这个东西跟时趋相关

02:37.000 --> 02:38.000
因为你们知道

02:38.000 --> 02:40.000
在地球上是不是有不同的时趋

02:40.000 --> 02:42.000
有24的时趋 对吧

02:42.000 --> 02:43.000
每个时趋呢

02:43.000 --> 02:45.000
他们的时间 记度

02:45.000 --> 02:47.000
记度时间是有差异的

02:47.000 --> 02:49.000
那么我们在开发的时候

02:49.000 --> 02:51.000
比较说我们要做一个网站

02:51.000 --> 02:52.000
这个网站可能面向的用户

02:52.000 --> 02:53.000
是全球的

02:53.000 --> 02:55.000
就会造成一些问题

02:55.000 --> 02:56.000
所以说那就会

02:56.000 --> 02:57.000
就出现了一些东西

02:57.000 --> 02:58.000
来解决这个问题

02:58.000 --> 02:59.000
一个个说

02:59.000 --> 03:01.000
首先是GMT和UTC

03:01.000 --> 03:02.000
这两个啥意思呢

03:02.000 --> 03:05.000
这两GMT表示隔离微质时间

03:05.000 --> 03:06.000
什么叫隔离微质啊

03:06.000 --> 03:08.000
隔离微质就是一个地方

03:08.000 --> 03:09.000
它在英国

03:09.000 --> 03:11.000
这具体在哪我也不知道

03:11.000 --> 03:13.000
它的时趋呢 是零时趋

03:13.000 --> 03:15.000
它是一个本出值物线

03:15.000 --> 03:17.000
划过那个这个地方

03:17.000 --> 03:18.000
它有个大笨中

03:18.000 --> 03:19.000
你们可以往上去搜一下

03:19.000 --> 03:21.000
非常有名的一个景点

03:22.000 --> 03:23.000
这是隔离微质事件时

03:23.000 --> 03:25.000
我们也把它叫做太阳时

03:25.000 --> 03:26.000
就是它根据地球的自转

03:26.000 --> 03:28.000
太阳的公转来记住时间的

03:28.000 --> 03:30.000
那么它的精确度呢比较低

03:30.000 --> 03:32.000
它只能精确到毫秒

03:32.000 --> 03:33.000
因此呢

03:33.000 --> 03:34.000
现代记度时间啊

03:34.000 --> 03:36.000
像你们手机上的那些

03:36.000 --> 03:37.000
标准时间

03:37.000 --> 03:39.000
都不再会使用隔离微质时间了

03:39.000 --> 03:41.000
因为这个时间呢

03:41.000 --> 03:42.000
已经不太准了

03:42.000 --> 03:43.000
我们现在使用的是什么时间呢

03:43.000 --> 03:44.000
叫做UTC时间

03:44.000 --> 03:46.000
世界协调时

03:46.000 --> 03:47.000
它呢也是

03:47.000 --> 03:49.000
它是以原子

03:49.000 --> 03:51.000
时间为计时标准

03:51.000 --> 03:53.000
哪个原子呢是这个设原子

03:53.000 --> 03:55.000
了解一下就行了

03:55.000 --> 03:57.000
设原子它的一个什么能量越迁

03:57.000 --> 03:58.000
我也搞不懂啊

03:58.000 --> 03:59.000
我也不敢问

03:59.000 --> 04:00.000
咱也不懂

04:00.000 --> 04:01.000
反正就是那个

04:01.000 --> 04:03.000
以原子的能量越迁

04:03.000 --> 04:04.000
为一个计时标准

04:04.000 --> 04:05.000
那么这个精确度是非常高的

04:05.000 --> 04:06.000
精确到那秒

04:06.000 --> 04:07.000
像你们现在

04:07.000 --> 04:09.000
手机上的一些移动端

04:09.000 --> 04:10.000
标准时间

04:10.000 --> 04:12.000
都是以UTC时间

04:12.000 --> 04:13.000
为标准

04:13.000 --> 04:15.000
来制定的

04:15.000 --> 04:17.000
好那么大家一定要搞清楚啊

04:17.000 --> 04:19.000
无论是GMT

04:19.000 --> 04:20.000
还是UTC

04:20.000 --> 04:22.000
他们都表示的是

04:22.000 --> 04:24.000
零时区的时间

04:24.000 --> 04:26.000
都表示是零时区

04:26.000 --> 04:27.000
比方说

04:27.000 --> 04:29.000
我们说GMT时间

04:29.000 --> 04:31.000
2020年1月1号

04:31.000 --> 04:33.000
表示的是伦敦

04:33.000 --> 04:35.000
就是革定微质

04:35.000 --> 04:36.000
所谓的零时区

04:36.000 --> 04:38.000
它的时间是2020年1月1号

04:38.000 --> 04:40.000
那如果说你要换换成

04:40.000 --> 04:41.000
我们北京时间的话

04:41.000 --> 04:42.000
你要加8个小时

04:42.000 --> 04:44.000
那么就是2021年1月1号

04:44.000 --> 04:46.000
2020年1月1号

04:46.000 --> 04:47.000
早上8点

04:47.000 --> 04:48.000
原来意思

04:48.000 --> 04:49.000
所以说无论是GMT

04:49.000 --> 04:50.000
还是UTC

04:50.000 --> 04:52.000
都表示零时区的时间

04:52.000 --> 04:53.000
不存在说

04:53.000 --> 04:55.000
我们北京UTC时间

04:55.000 --> 04:56.000
没有这个说法

04:56.000 --> 04:58.000
UTC就是零时区

04:58.000 --> 05:00.000
GMT也自以零时区为标准

05:00.000 --> 05:02.000
他们出的时间

05:02.000 --> 05:04.000
都是以零时区为标准的

05:04.000 --> 05:05.000
现在呢

05:05.000 --> 05:06.000
我们基本上不太会使用

05:06.000 --> 05:07.000
GMT时间了

05:07.000 --> 05:08.000
都是使用的是UTC时间

05:08.000 --> 05:09.000
但是有的时候呢

05:09.000 --> 05:10.000
我们写

05:10.000 --> 05:11.000
我们在制服串里边呢

05:11.000 --> 05:12.000
有的时候会看到啊

05:12.000 --> 05:14.000
还有GMT这个单词

05:14.000 --> 05:15.000
比方说啊

05:15.000 --> 05:16.000
我给大家看一下

05:17.000 --> 05:19.000
我们平时在用这个日期对象的时候

05:19.000 --> 05:21.000
第6个代词

05:21.000 --> 05:22.000
当前时间

05:22.000 --> 05:23.000
对吧

05:23.000 --> 05:24.000
然后呢

05:24.000 --> 05:25.000
我们这里输出2-stream

05:25.000 --> 05:26.000
那你看

05:26.000 --> 05:27.000
这里是不是一个GMT

05:27.000 --> 05:28.000
对不对

05:28.000 --> 05:29.000
这个GMT呢

05:29.000 --> 05:30.000
实际上呢

05:30.000 --> 05:32.000
只是沿用了以前的协法而已

05:32.000 --> 05:33.000
基本的时间

05:33.000 --> 05:35.000
基本上已经被抛弃掉了

05:35.000 --> 05:36.000
只是沿用了过去的协法

05:36.000 --> 05:38.000
这里的GMT就是UTC

05:38.000 --> 05:40.000
就是指的是UTC时间

05:40.000 --> 05:42.000
只是沿用了过去的协法而已

05:42.000 --> 05:43.000
你看这个制服串呢

05:43.000 --> 05:44.000
就是怎么表达的

05:44.000 --> 05:47.000
2021年1月

05:47.000 --> 05:49.000
这January

05:49.000 --> 05:50.000
1月

05:50.000 --> 05:52.000
6月

05:52.000 --> 05:54.000
怎么说的

05:54.000 --> 05:55.000
对对对

05:55.000 --> 05:58.000
6月1号

05:58.000 --> 06:00.000
Tuesday星期二

06:01.000 --> 06:02.000
然后这是分秒

06:02.000 --> 06:04.000
然后GMT就是

06:04.000 --> 06:05.000
隔离位置时间

06:05.000 --> 06:07.000
然后这里加0800

06:07.000 --> 06:08.000
啥意思呢

06:08.000 --> 06:09.000
表示

06:09.000 --> 06:10.000
我们目前呢

06:10.000 --> 06:12.000
是东巴区

06:12.000 --> 06:13.000
北京时间是东巴区

06:13.000 --> 06:14.000
所以说呢

06:14.000 --> 06:15.000
它要加8个小时

06:15.000 --> 06:16.000
也就UTC时间

06:16.000 --> 06:18.000
实际上是早上的8点

06:18.000 --> 06:19.000
28分12秒

06:19.000 --> 06:20.000
但是呢

06:20.000 --> 06:21.000
换成中国标准时间

06:21.000 --> 06:22.000
加了8个小时

06:22.000 --> 06:23.000
过后呢

06:23.000 --> 06:24.000
就变成16个小

06:24.000 --> 06:25.000
16点

06:25.000 --> 06:26.000
是这么一个意思

06:27.000 --> 06:29.000
这是这两个概念

06:29.000 --> 06:30.000
GMTUTC

06:30.000 --> 06:31.000
现在GMT没用了

06:31.000 --> 06:32.000
就是UTC

06:33.000 --> 06:34.000
那么它的协法呢

06:34.000 --> 06:35.000
就下面这个协法

06:35.000 --> 06:36.000
前面是星期

06:36.000 --> 06:37.000
然后呢

06:37.000 --> 06:38.000
月

06:38.000 --> 06:39.000
就是

06:39.000 --> 06:40.000
日期

06:40.000 --> 06:41.000
年

06:41.000 --> 06:42.000
时分秒

06:42.000 --> 06:43.000
GMT

06:43.000 --> 06:44.000
然后还有的时候呢

06:44.000 --> 06:45.000
你还会看到

06:45.000 --> 06:47.000
另外一种时间的协法

06:47.000 --> 06:48.000
这种时间的协法呢

06:48.000 --> 06:50.000
就是iOS 8601的

06:50.000 --> 06:51.000
标准的协法

06:51.000 --> 06:52.000
那么它的协法是这样子的

06:52.000 --> 06:53.000
年

06:53.000 --> 06:54.000
月

06:54.000 --> 06:55.000
日

06:55.000 --> 06:56.000
一个T

06:56.000 --> 06:57.000
T也在做分割

06:57.000 --> 06:58.000
分割过后呢

06:58.000 --> 06:59.000
后面就是时

06:59.000 --> 07:00.000
分

07:00.000 --> 07:01.000
秒

07:01.000 --> 07:02.000
后面是好秒

07:02.000 --> 07:03.000
后面是个Z

07:03.000 --> 07:04.000
Z表示UTC时间

07:04.000 --> 07:05.000
也就是我们现在说了半天啊

07:05.000 --> 07:06.000
这样子这个时间

07:06.000 --> 07:07.000
那个时间

07:07.000 --> 07:08.000
这三个东西

07:08.000 --> 07:09.000
协法不一样啊

07:09.000 --> 07:10.000
协法的格式不一样

07:10.000 --> 07:11.000
其实他们本质都是一样的

07:11.000 --> 07:14.000
都指的是零时区的时间

07:14.000 --> 07:16.000
零时区的时间

07:16.000 --> 07:17.000
我们其他地方的时间

07:17.000 --> 07:18.000
都是以零时区

07:18.000 --> 07:19.000
作为标准

07:19.000 --> 07:20.000
来换算出来的

07:20.000 --> 07:21.000
比较零时区

07:21.000 --> 07:22.000
2020年1月1号

07:22.000 --> 07:23.000
凌晨

07:23.000 --> 07:24.000
东巴区

07:24.000 --> 07:25.000
我们就换算成加8个小时

07:25.000 --> 07:27.000
西巴区减8个小时

07:27.000 --> 07:28.000
就这么一个回事

07:28.000 --> 07:29.000
所以我们表示时间

07:29.000 --> 07:30.000
都是零时区

07:30.000 --> 07:31.000
为标准

07:31.000 --> 07:32.000
其他的地方换算出来

07:32.000 --> 07:33.000
好

07:33.000 --> 07:34.000
然后还有一个

07:34.000 --> 07:35.000
跟零时区相关的

07:35.000 --> 07:36.000
叫做时间戳

07:36.000 --> 07:37.000
它指的是呢

07:37.000 --> 07:39.000
它是这个时间戳的概念

07:39.000 --> 07:40.000
是零时区的操作系统

07:40.000 --> 07:41.000
最早提出来的

07:41.000 --> 07:42.000
所以我们有的时候

07:42.000 --> 07:43.000
把它叫做

07:43.000 --> 07:45.000
零时时间戳

07:45.000 --> 07:46.000
它啥意思呢

07:46.000 --> 07:47.000
指的是

07:47.000 --> 07:48.000
UTC时间

07:48.000 --> 07:50.000
一定是UTC时间

07:50.000 --> 07:52.000
1970年1月1号凌晨

07:52.000 --> 07:53.000
作为歧视时间

07:53.000 --> 07:54.000
到指定的时间

07:54.000 --> 07:56.000
经过了描述

07:56.000 --> 07:57.000
那么有的时候

07:57.000 --> 07:59.000
也可以用好妙数来记录

07:59.000 --> 08:00.000
比方说我们

08:00.000 --> 08:01.000
JS里面就是好妙数

08:01.000 --> 08:02.000
对吧

08:02.000 --> 08:03.000
JS里面

08:03.000 --> 08:05.000
比方说我们用一个DAT

08:05.000 --> 08:06.000
用一个DAT

08:06.000 --> 08:07.000
给它写个零

08:07.000 --> 08:08.000
那么什么意思

08:08.000 --> 08:10.000
这个零就是时间戳

08:10.000 --> 08:12.000
那么这样的创举的时间

08:12.000 --> 08:13.000
是什么时间

08:13.000 --> 08:15.000
是格林威治时间

08:15.000 --> 08:16.000
就是UTC时间

08:16.000 --> 08:21.000
1970年1月1号

08:21.000 --> 08:22.000
不是北

08:22.000 --> 08:23.000
然后凌晨

08:23.000 --> 08:24.000
不是北京时间

08:24.000 --> 08:25.000
搞清楚

08:25.000 --> 08:26.000
不是北京时间的

08:26.000 --> 08:28.000
1月1号凌晨

08:28.000 --> 08:29.000
一切都以

08:29.000 --> 08:30.000
零时区委标准

08:30.000 --> 08:32.000
我说清楚了吗

08:32.000 --> 08:34.000
就这么个意思

08:34.000 --> 08:35.000
那么这个DAT就出来了

08:35.000 --> 08:36.000
又说不对

08:36.000 --> 08:37.000
那这里不是显然是

08:37.000 --> 08:38.000
宝藏8点吗

08:38.000 --> 08:39.000
为什么是你说是凌晨了

08:39.000 --> 08:40.000
因为它换算成

08:40.000 --> 08:41.000
中国的时间过后

08:41.000 --> 08:42.000
要加8个小时

08:42.000 --> 08:44.000
但是它里面

08:44.000 --> 08:45.000
内部记录的时间

08:45.000 --> 08:46.000
是凌晨

08:46.000 --> 08:48.000
然后显示出来的时候

08:48.000 --> 08:49.000
它要显示本地时间

08:49.000 --> 08:51.000
那么还会给你加8个小时

08:51.000 --> 08:52.000
是这么一个意思

08:52.000 --> 08:54.000
好 这是时间戳

08:54.000 --> 08:55.000
接下来

08:55.000 --> 08:56.000
说终点了

08:56.000 --> 08:57.000
就是这个我还要

08:57.000 --> 08:58.000
跟我们开发有什么关系

08:58.000 --> 08:59.000
有啥关系

08:59.000 --> 09:00.000
是这样

09:00.000 --> 09:02.000
就咱们

09:02.000 --> 09:03.000
我们的系统里面

09:03.000 --> 09:05.000
凡是针对时间的计算

09:05.000 --> 09:06.000
比较这个时间大

09:06.000 --> 09:07.000
还是另外一个时间大

09:07.000 --> 09:08.000
哪个在前

09:08.000 --> 09:09.000
哪个在后

09:09.000 --> 09:11.000
两个时间差是多少

09:11.000 --> 09:12.000
还有有的时候

09:12.000 --> 09:14.000
要把时间存起来

09:14.000 --> 09:15.000
比方说服务系

09:15.000 --> 09:16.000
这个东西

09:16.000 --> 09:17.000
跟你们到时候没有多少关系

09:17.000 --> 09:19.000
比如说你用户一个注册

09:19.000 --> 09:20.000
注册过后

09:20.000 --> 09:21.000
进入用户的注册时间

09:21.000 --> 09:22.000
那么这个时间

09:22.000 --> 09:25.000
都是使用UTC时间

09:25.000 --> 09:26.000
绝大部分情况下

09:26.000 --> 09:28.000
都会使用时间戳

09:28.000 --> 09:31.000
一定不会使用本地时间

09:32.000 --> 09:33.000
一定不会使用本地时间

09:33.000 --> 09:34.000
如果说你以后

09:34.000 --> 09:35.000
到了公司里面

09:35.000 --> 09:36.000
看到别人

09:36.000 --> 09:37.000
特别是后端

09:37.000 --> 09:38.000
用本地时间

09:38.000 --> 09:39.000
你可以善意的提醒一下

09:39.000 --> 09:41.000
千万不能用本地时间

09:41.000 --> 09:42.000
为什么不能用本地时间

09:42.000 --> 09:44.000
如果说你的网站是国际化的

09:44.000 --> 09:47.000
那么你中国的小货车

09:47.000 --> 09:48.000
他记住他的生日

09:48.000 --> 09:50.000
2020年

09:50.000 --> 09:52.000
2020年1月1号

09:52.000 --> 09:53.000
然后一个英国的小货车

09:53.000 --> 09:54.000
也记住他的生日

09:54.000 --> 09:56.000
2020年1月1号

09:56.000 --> 09:58.000
你能说他们是同一先生的吗

09:58.000 --> 10:00.000
他们时趋都不一样

10:00.000 --> 10:01.000
对吧

10:01.000 --> 10:02.000
那么记住的时间是不一样的

10:02.000 --> 10:03.000
生日的话

10:03.000 --> 10:04.000
我们一般都是用凌晨

10:04.000 --> 10:05.000
作为生日

10:05.000 --> 10:06.000
那么这个玩意

10:06.000 --> 10:07.000
是不是时间都不一样

10:07.000 --> 10:08.000
那但是你

10:08.000 --> 10:09.000
如果说你记住的

10:09.000 --> 10:11.000
不是UTC时间

10:11.000 --> 10:12.000
你用的是本地时间

10:12.000 --> 10:13.000
那么本地时间

10:13.000 --> 10:14.000
他们是这个

10:14.000 --> 10:15.000
中国的是这个

10:15.000 --> 10:16.000
英国的也是这个

10:16.000 --> 10:17.000
结果他们时间相同了

10:17.000 --> 10:19.000
说一定不能用本地时间

10:19.000 --> 10:20.000
这个玩意

10:20.000 --> 10:21.000
跟你们倒是没多少关系

10:21.000 --> 10:23.000
是后端开发人员要注意的

10:23.000 --> 10:25.000
但是跟你们有关系的时候

10:25.000 --> 10:26.000
什么呢

10:26.000 --> 10:28.000
就是你们以后用什么API

10:28.000 --> 10:29.000
接口

10:29.000 --> 10:31.000
从后端去请求一些数据的时候

10:31.000 --> 10:33.000
如果要给你时间的话

10:33.000 --> 10:35.000
它会给你一个时间戳

10:35.000 --> 10:36.000
就是一串数字

10:36.000 --> 10:38.000
它不会给你一个时间的制服串

10:38.000 --> 10:40.000
前面我们好像有一个例子

10:40.000 --> 10:42.000
得到的是时间的制服串

10:42.000 --> 10:43.000
哪个无所谓

10:43.000 --> 10:44.000
哪个我们是做的玩的

10:44.000 --> 10:45.000
真正实质的情况下

10:45.000 --> 10:47.000
后边我们有一个项目

10:47.000 --> 10:48.000
就是个人博客的一个项目

10:48.000 --> 10:49.000
给力的时间

10:49.000 --> 10:51.000
都是时间戳

10:53.000 --> 10:55.000
那么当时我们前段

10:55.000 --> 10:56.000
在程序里边

10:56.000 --> 10:57.000
比方说我再说一下

10:57.000 --> 10:59.000
在程序里边有定个变量

10:59.000 --> 11:00.000
这个变量里边接收的时间

11:00.000 --> 11:02.000
那么一定是时间戳

11:03.000 --> 11:04.000
一定是时间戳

11:04.000 --> 11:05.000
你不要用本地时间去

11:05.000 --> 11:06.000
进入到变量里边

11:06.000 --> 11:07.000
没有任何意义

11:08.000 --> 11:10.000
就这么个情况

11:10.000 --> 11:11.000
就是在程序里边

11:11.000 --> 11:13.000
我们都是使用时间戳

11:13.000 --> 11:15.000
或者是UTC时间

11:15.000 --> 11:17.000
一般它说时间戳

11:18.000 --> 11:20.000
但是跟用户交互的时候

11:20.000 --> 11:22.000
你不能显示个时间戳给它吧

11:22.000 --> 11:23.000
比如说这篇文章

11:23.000 --> 11:24.000
什么时候发布的

11:24.000 --> 11:25.000
一个显示一串数字

11:25.000 --> 11:26.000
它就封掉了

11:26.000 --> 11:27.000
让它自己去换算

11:27.000 --> 11:28.000
我们一般来说

11:28.000 --> 11:30.000
在显示的时候

11:30.000 --> 11:32.000
我们会帮它换算一下

11:32.000 --> 11:34.000
换算成它的本地时间

11:34.000 --> 11:35.000
就这么个意义

11:36.000 --> 11:37.000
我们会把UTC时间

11:37.000 --> 11:38.000
或者是时间戳

11:38.000 --> 11:40.000
转换成更久好的文本

11:40.000 --> 11:42.000
也就是我们程序里边

11:42.000 --> 11:43.000
只考虑时间戳

11:43.000 --> 11:45.000
但是我们在显示的时候

11:45.000 --> 11:46.000
跟用户交互的时候

11:46.000 --> 11:48.000
我们用本地时间

11:48.000 --> 11:49.000
我们帮它转换一下

11:49.000 --> 11:51.000
比方说我举个例子

11:52.000 --> 11:54.000
这里有个文本框

11:54.000 --> 11:55.000
填写生日

11:55.000 --> 11:56.000
那英国的用户

11:56.000 --> 11:58.000
填写2020年1月1号

11:58.000 --> 11:59.000
那么请问它

11:59.000 --> 12:02.000
填写的是本地时间

12:02.000 --> 12:03.000
还是时间戳

12:04.000 --> 12:05.000
所以填写的是本地时间

12:05.000 --> 12:07.000
时间戳是一个数字

12:07.000 --> 12:08.000
所以它填写的是本地时间

12:08.000 --> 12:09.000
当然不过

12:09.000 --> 12:10.000
它比较特殊

12:10.000 --> 12:11.000
它就是临时区

12:11.000 --> 12:12.000
那就只有提成时间了

12:12.000 --> 12:13.000
但是我们也要

12:13.000 --> 12:15.000
把它当成一个统一的处理

12:15.000 --> 12:16.000
根据你的时区

12:16.000 --> 12:18.000
把它变成一个时间戳

12:18.000 --> 12:19.000
就是我在程序里边

12:19.000 --> 12:20.000
是用时间戳来处理的

12:21.000 --> 12:22.000
另外的意思

12:22.000 --> 12:23.000
然后中国的用户

12:23.000 --> 12:25.000
填了一个2020年1月1号的生日

12:25.000 --> 12:27.000
我也要把它变成时间戳

12:27.000 --> 12:28.000
那么这样子一变出来

12:28.000 --> 12:29.000
过后你会发现

12:29.000 --> 12:31.000
这两个时间戳实际上是不一样的

12:31.000 --> 12:32.000
所以它们填的是一样的

12:32.000 --> 12:34.000
它时间戳是不一样的

12:34.000 --> 12:35.000
为什么?

12:35.000 --> 12:36.000
因为它填的是本地时间

12:36.000 --> 12:37.000
转换的时间戳过后

12:37.000 --> 12:39.000
就变成了统一的临时区的时间

12:40.000 --> 12:41.000
好好去处理一下

12:41.000 --> 12:42.000
这个没问题吧

12:42.000 --> 12:43.000
然后有一天

12:43.000 --> 12:44.000
它要显示

12:44.000 --> 12:45.000
比方说到个人信息页面

12:45.000 --> 12:46.000
我要显示出

12:46.000 --> 12:48.000
我之前填的生日是多少

12:48.000 --> 12:49.000
显示的时候

12:49.000 --> 12:50.000
我们又把这个时间戳

12:50.000 --> 12:52.000
又换算成它的本地时间

12:52.000 --> 12:53.000
一个换算成本地时间

12:53.000 --> 12:55.000
那么这里填写的时候

12:55.000 --> 12:56.000
显示的时候

12:56.000 --> 12:57.000
就给它换算成本地时间

12:57.000 --> 12:58.000
就是我们在程序内部

12:58.000 --> 13:00.000
都是使用时间戳来处理

13:00.000 --> 13:02.000
然后就是在显示的

13:02.000 --> 13:03.000
最后一个环节

13:03.000 --> 13:05.000
给它变成本地时间显示

13:05.000 --> 13:07.000
然后它填的时候

13:07.000 --> 13:09.000
我们把它转换成时间戳

13:09.000 --> 13:10.000
就这么个意思

13:10.000 --> 13:12.000
这是最基本的时间的概念

13:12.000 --> 13:14.000
那么接下来有几道思考题

13:14.000 --> 13:15.000
大家想一想

13:16.000 --> 13:18.000
我们说用户的生日

13:18.000 --> 13:19.000
是本地时间

13:19.000 --> 13:20.000
比方说我们说这句话

13:20.000 --> 13:21.000
用户的生日

13:21.000 --> 13:22.000
说这句话

13:23.000 --> 13:24.000
那么它指的是本地时间

13:24.000 --> 13:26.000
还是指的是UTC时间

13:29.140 --> 13:30.140
是啥呢

13:30.140 --> 13:31.140
是不是本地时间

13:32.140 --> 13:33.140
你不可能说你的生日

13:33.140 --> 13:34.140
你还要去

13:34.140 --> 13:35.140
减个八个小时区

13:35.140 --> 13:37.140
到零时区来换算成UTC时间

13:37.140 --> 13:38.140
不会吧

13:39.140 --> 13:41.140
你们的生日都是说的本地时间

13:41.140 --> 13:42.140
但是我们程序处理的时候

13:42.140 --> 13:44.140
要把它换算成UTC时间

13:44.140 --> 13:45.140
什么回事

13:45.140 --> 13:46.140
下面一个问题

13:46.140 --> 13:49.140
如果说比较两个日期的大小

13:49.140 --> 13:51.140
是比较本地时间

13:51.140 --> 13:52.140
还是比较UTC时间

13:54.140 --> 13:55.140
就哪个日期

13:55.140 --> 13:57.140
在前边大概就是在后边

13:57.140 --> 13:58.140
大小

13:58.140 --> 13:59.140
我们一般来说

13:59.140 --> 14:01.140
认为这是一个时间线

14:02.140 --> 14:03.140
这个时间

14:04.140 --> 14:05.140
这个时间B

14:05.140 --> 14:07.140
那么B就比A大

14:07.140 --> 14:09.140
就这么个说法

14:09.140 --> 14:11.140
要比较两个日期的大小

14:11.140 --> 14:13.140
应该比本地还是比较UTC呢

14:14.140 --> 14:16.140
应该比较UTC

14:16.140 --> 14:18.140
像这种日期的计算

14:18.140 --> 14:20.140
比较存储都是UTC时间

14:21.140 --> 14:22.140
那么我们一般来说

14:22.140 --> 14:24.140
就把两个日期换算成UTC时间

14:24.140 --> 14:25.140
或者是换算成时间戳

14:25.140 --> 14:27.140
两个数字直接比较大小

14:27.140 --> 14:28.140
第三个

14:28.140 --> 14:31.140
如果说要显示文章的发布日期

14:31.140 --> 14:33.140
是要显示本地时间呢

14:33.140 --> 14:35.140
还是显示UTC时间

14:35.140 --> 14:36.140
叫显示本地的

14:36.140 --> 14:37.140
对吧

14:37.140 --> 14:39.140
凡是设得要跟用户交互的位置

14:39.140 --> 14:40.140
都是本地时间

14:40.140 --> 14:41.140
好 下一个

14:41.140 --> 14:43.140
北京时间这个点

14:43.140 --> 14:44.140
和格林位置这个点

14:44.140 --> 14:45.140
哪个时间大

14:45.140 --> 14:46.140
哪个时间小

14:46.140 --> 14:49.220
看一下

14:50.220 --> 14:51.220
首先你要搞清楚

14:51.220 --> 14:53.220
这两个时间说的是什么时间

14:53.220 --> 14:54.220
都是本地时间

14:54.220 --> 14:55.220
对吧

14:55.220 --> 14:56.220
本地时间

14:56.220 --> 14:57.220
那么换算成UTC时间

14:57.220 --> 14:58.220
那么这个玩意

14:58.220 --> 15:00.220
换算成UTC时间是多少呢

15:00.220 --> 15:03.220
就是2020年8月28号

15:03.220 --> 15:04.220
UTC时间是多少

15:04.220 --> 15:05.220
减8个小时

15:05.220 --> 15:06.220
对吧 东巴区嘛

15:06.220 --> 15:08.220
然后减8个小时

15:08.220 --> 15:11.220
就是凌晨2点

15:12.220 --> 15:15.220
这第一个UTC时间

15:16.220 --> 15:18.220
换算成UTC过去就统一了

15:18.220 --> 15:19.220
使续统一了

15:19.220 --> 15:20.220
那么第二个格林位置

15:20.220 --> 15:21.220
它本身就是UTC

15:21.220 --> 15:23.220
那么就是2020年

15:23.220 --> 15:25.220
8月28号凌晨2点

15:25.220 --> 15:27.220
两个时间是不是一样大的

15:27.220 --> 15:28.220
对不对

15:28.220 --> 15:29.220
一样大的

15:30.220 --> 15:31.220
第二个问题

15:31.220 --> 15:33.220
北京的时间戳为0

15:33.220 --> 15:34.220
格林位置的时间戳为0

15:34.220 --> 15:35.220
他们的时间一样吗

15:35.220 --> 15:39.300
你觉得一样吗

15:39.300 --> 15:42.740
这个说法都是有问题的

15:42.740 --> 15:44.740
对吧 每些有什么北京的时间戳

15:44.740 --> 15:46.740
时间戳一定是UTC时间

15:47.740 --> 15:49.740
没有什么格林位置的时间戳

15:49.740 --> 15:50.740
时间戳一定是UTC

15:50.740 --> 15:53.740
一定是在格林位置那个地方

15:57.760 --> 15:59.760
格林位置

16:00.760 --> 16:02.760
他们的时间是一样的

16:02.760 --> 16:04.760
UTC就是一个统一的

16:04.760 --> 16:06.760
时间戳就是个统一的标准

16:06.760 --> 16:09.760
就是UTC1970年1月1号

16:09.760 --> 16:11.760
到目前经过的时间

16:11.760 --> 16:12.760
到某一个时间

16:12.760 --> 16:13.760
经过的时间

16:13.760 --> 16:14.760
那么0就表示

16:14.760 --> 16:16.760
UTC时间1970年1月1号

16:16.760 --> 16:17.760
这里的0也表示

16:17.760 --> 16:19.760
UTC时间1970年1月1号

16:19.760 --> 16:20.760
那就一样

16:20.760 --> 16:22.760
一个中国用户注册的时候

16:22.760 --> 16:24.760
填写生日1970年1月1号

16:24.760 --> 16:27.760
它的出生的UTC时间是多少

16:29.760 --> 16:30.760
是多少呢

16:30.760 --> 16:32.760
那么这个你可以去换算一下

16:32.760 --> 16:33.760
对吧

16:33.760 --> 16:34.760
1970年

16:34.760 --> 16:35.760
它填的时候

16:35.760 --> 16:37.760
填的是1970年1月1号

16:38.760 --> 16:41.760
那么我们一般认为生日的就是凌晨

16:41.760 --> 16:43.760
因为它不会让它去填十分秒的

16:43.760 --> 16:45.760
它也记不住

16:45.760 --> 16:47.760
这是本地时间

16:47.760 --> 16:49.760
北京本地时间

16:50.760 --> 16:51.760
北京

16:51.760 --> 16:52.760
本地时间

16:52.760 --> 16:54.760
1970年1月1号

16:54.760 --> 16:56.760
那么换算成UTC时间

16:56.760 --> 16:58.760
因为我们要存处

16:58.760 --> 17:00.760
存处的时候要换成UTC时间

17:00.760 --> 17:02.760
UTC时间是什么呢

17:02.760 --> 17:03.760
减8个小时

17:03.760 --> 17:05.760
那就是1969年

17:07.760 --> 17:09.760
12月31号

17:10.760 --> 17:12.760
24点

17:12.760 --> 17:13.760
8

17:13.760 --> 17:15.760
16点

17:15.760 --> 17:16.760
对吧

17:16.760 --> 17:18.760
下午4点

17:18.760 --> 17:20.760
这是UTC时间

17:20.760 --> 17:22.760
那么它的时间戳是什么

17:22.760 --> 17:24.760
时间戳1970年1月1号凌晨

17:24.760 --> 17:28.760
UTC时间1970年1月1号凌晨是0

17:28.760 --> 17:30.760
那么它比时间戳早

17:30.760 --> 17:32.760
比它早的就是负数

17:32.760 --> 17:34.760
也就是减8个小时的负数

17:34.760 --> 17:36.760
那就是8

17:36.760 --> 17:37.760
来看一下吧

17:37.760 --> 17:39.760
得到结果就是

17:39.760 --> 17:41.760
8乘以

17:41.760 --> 17:43.760
一个小时

17:43.760 --> 17:44.760
60分钟

17:44.760 --> 17:46.760
每分钟60秒

17:46.760 --> 17:48.760
然后加上个好秒数吧

17:48.760 --> 17:50.760
1000

17:50.760 --> 17:52.760
那么时间戳就是负的

17:52.760 --> 17:54.760
负了这么多

17:54.760 --> 17:56.760
这是它的时间戳

17:56.760 --> 17:57.760
好 那咱们来验证一下

17:57.760 --> 17:58.760
看是不是这样子的

17:58.760 --> 18:00.760
那么我们用6一个DAT

18:00.760 --> 18:01.760
我们用本地时间

18:01.760 --> 18:02.760
1970年

18:02.760 --> 18:03.760
因为6DAT的时候

18:03.760 --> 18:06.760
你传入了这些年月日都是本地时间

18:06.760 --> 18:08.760
年月

18:08.760 --> 18:09.760
月的话我们用0

18:09.760 --> 18:10.760
0开始了

18:10.760 --> 18:11.760
1月1号

18:11.760 --> 18:12.760
1号

18:12.760 --> 18:13.760
10分秒不甜了

18:13.760 --> 18:14.760
不甜的话你默认是

18:14.760 --> 18:16.760
0成0分0秒

18:16.760 --> 18:20.330
好 来得到这么一个日期

18:20.330 --> 18:22.330
我们来看一下这个D

18:22.330 --> 18:24.330
得到它的时间戳

18:24.330 --> 18:26.330
你看是不是这个

18:26.330 --> 18:28.330
这个地方我们使用的是本地时间

18:28.330 --> 18:29.330
传进去的

18:29.330 --> 18:30.330
那么得到的时间戳就是这个

18:30.330 --> 18:32.330
明儿的意思吧

18:32.330 --> 18:34.330
咱们这就是

18:34.330 --> 18:36.330
给大家介绍一下日期的

18:36.330 --> 18:37.330
一些基本的概念

18:37.330 --> 18:38.330
反正的基础

18:38.330 --> 18:40.330
纯时间

18:40.330 --> 18:42.330
对时间进行运算

18:42.330 --> 18:44.330
比较全是使用UTC

18:44.330 --> 18:46.330
什么时候用本地时间

18:46.330 --> 18:48.330
会打交道的最后一个环

18:48.330 --> 18:49.330
把它变成本地时间

18:49.330 --> 18:50.330
友好一点

18:50.330 --> 18:52.330
好 最后来我们来看一下这个MOMENT

18:52.330 --> 18:54.330
你要理解这个玩意过后

18:54.330 --> 18:56.330
MOMENT就简单了

18:56.330 --> 18:58.330
MOMENT也好还是

18:58.330 --> 19:00.330
DATFMS也好

19:00.330 --> 19:01.330
本质都是差不多的

19:01.330 --> 19:02.330
MOMENT的用法

19:02.330 --> 19:04.330
其实就分为两个部分

19:04.330 --> 19:05.330
获取MOMENT对象

19:05.330 --> 19:06.330
它有个对象

19:06.330 --> 19:07.330
我们平时用的是DAT对象

19:07.330 --> 19:08.330
对吧

19:08.330 --> 19:09.330
DAT是根本提供的

19:09.330 --> 19:10.330
不用了

19:10.330 --> 19:12.330
直接使用它的MOMENT对象

19:12.330 --> 19:14.330
表示一个时间点

19:14.330 --> 19:16.330
它的内部就是使用的是

19:16.330 --> 19:18.330
时间出来处理的

19:18.330 --> 19:20.330
所以说里边都用的是UTC

19:20.330 --> 19:22.330
同意用的是UTC时间

19:22.330 --> 19:23.330
然后得到这个对象之后

19:23.330 --> 19:25.330
对这个对象做各种操作

19:25.330 --> 19:27.330
就分成这么两个部分

19:27.330 --> 19:29.330
好 咱们来看一下它的文档

19:29.330 --> 19:31.330
来体验一下

19:31.330 --> 19:32.330
这里有个中文网

19:32.330 --> 19:37.750
它原官网是英文的

19:37.750 --> 19:40.750
你看 这里有一个解析

19:40.750 --> 19:41.750
解析是什么意思呢

19:41.750 --> 19:43.750
就是你怎么来获得

19:43.750 --> 19:44.750
MOMENT对象

19:44.750 --> 19:46.750
也好多种方式

19:46.750 --> 19:48.750
把引用现在试一下吧

19:48.750 --> 19:50.750
TEST

19:50.750 --> 19:56.470
我们用那个CDN

19:56.470 --> 19:57.470
这个CDN我给大家说一下

19:57.470 --> 19:59.470
MOMENT这个库

20:00.470 --> 20:01.470
CDN在这儿

20:01.470 --> 20:02.470
不要复制粘贴过来

20:02.470 --> 20:03.470
这个都没啥

20:03.470 --> 20:05.470
然后除了引用这个解析之外

20:05.470 --> 20:07.470
你要去

20:07.470 --> 20:08.470
还要去引用一个解析

20:08.470 --> 20:10.470
因为它里边有个语言包

20:10.470 --> 20:11.470
啥意思

20:11.470 --> 20:13.470
就是不同的地方

20:13.470 --> 20:15.470
比方说中国它显示的时间的文本

20:15.470 --> 20:17.470
和别的地方显示的时间的文本

20:17.470 --> 20:19.470
每个国家还有一些区别

20:19.470 --> 20:21.470
所以它又提供了大量的语言包

20:21.470 --> 20:23.470
比方说你要用中文的情况是来显示

20:23.470 --> 20:24.470
日期

20:24.470 --> 20:26.470
那么你要用使用中文的语言包

20:26.470 --> 20:28.470
这里需要把个中文的语言包倒进来

20:28.470 --> 20:30.470
各种语言包在这儿

20:30.470 --> 20:31.470
那你就找一下吧

20:31.470 --> 20:33.470
你看这个LOCARE表示

20:33.470 --> 20:34.470
地区 对吧

20:34.470 --> 20:36.470
你就搜索一下

20:36.470 --> 20:37.470
CDN

20:37.470 --> 20:39.470
就找这个解析

20:40.470 --> 20:41.470
把引用进来

20:41.470 --> 20:42.470
引用进来就OK了

20:42.470 --> 20:43.470
好了

20:43.470 --> 20:45.470
一个MOMENT的核心库

20:45.470 --> 20:46.470
一个语言包

20:46.470 --> 20:47.470
就完事了

20:47.470 --> 20:48.470
那么接下来呢

20:48.470 --> 20:49.470
我们来使用一下

20:49.470 --> 20:58.540
就在你任天里面使用吧

20:58.540 --> 20:59.540
好 咱们来看一下

20:59.540 --> 21:01.540
我们可以使用这个

21:01.540 --> 21:02.540
在这边

21:02.540 --> 21:04.540
如何来创建一个MOMENT对象呢

21:04.540 --> 21:05.540
还有好多的方式

21:05.540 --> 21:06.540
MOMENT这样子

21:06.540 --> 21:07.540
就得到一个当前时间

21:07.540 --> 21:09.540
但它内部用的是UTC

21:09.540 --> 21:11.540
反正就是当前时间

21:11.540 --> 21:12.540
因为此时此刻

21:12.540 --> 21:14.540
跟伦敦的此时此刻都是一样的

21:15.540 --> 21:17.540
得到一个MOMENT对象的

21:17.540 --> 21:19.540
那么后续就可以根据这个对象来做各种操作

21:19.540 --> 21:21.540
你可以把它保存在一个边疆里面

21:21.540 --> 21:22.540
MOMENT

21:23.540 --> 21:24.540
就得到MOMENT对象了

21:24.540 --> 21:25.540
后边就可以根据它

21:25.540 --> 21:26.540
做各种各样的操作

21:26.540 --> 21:28.540
这个M对象

21:28.540 --> 21:29.540
那么它还有很多的方式

21:29.540 --> 21:30.540
得到MOMENT对象

21:30.540 --> 21:32.540
你可以给它传入一个字幕串

21:32.540 --> 21:34.540
比方说传入的是这个字幕串

21:34.540 --> 21:36.540
那么注意这是本地时间

21:36.540 --> 21:38.540
传入的字幕串是本地时间

21:38.540 --> 21:39.540
没了意思吧

21:39.540 --> 21:40.540
字幕串这种格式呢

21:40.540 --> 21:42.540
一般都是用本地时间表示的

21:43.540 --> 21:44.540
好 我们这里它比方说

21:44.540 --> 21:45.540
可以用

21:45.540 --> 21:48.540
M也可以等于MOMENT

21:49.540 --> 21:51.540
它支持各种各样的格式

21:51.540 --> 21:52.540
比方说20

21:53.540 --> 21:56.540
或者就1970年1月1号

21:59.560 --> 22:01.560
这样子也可以得到一个MOMENT

22:02.560 --> 22:03.560
我们来看一下这个MOMENT

22:04.560 --> 22:05.560
那么这个MOMENT

22:05.560 --> 22:06.560
其实我们可以把它转换的数字

22:06.560 --> 22:07.560
非常简单

22:07.560 --> 22:08.560
强转

22:08.560 --> 22:09.560
转换的数字就完成了

22:09.560 --> 22:10.560
你看是不是负的

22:10.560 --> 22:11.560
28000

22:11.560 --> 22:13.560
说明我们刚才传的是

22:13.560 --> 22:14.560
这个东西是本地时间

22:14.560 --> 22:15.560
对吧

22:15.560 --> 22:16.560
它内部记录的UTC

22:16.560 --> 22:17.560
是时间戳

22:17.560 --> 22:18.560
是一个负数

22:18.560 --> 22:19.560
之前演示过的

22:20.560 --> 22:22.560
那么它给你介绍了

22:22.560 --> 22:23.560
各种各样

22:23.560 --> 22:25.560
如何来创建一个MOMENT

22:25.560 --> 22:26.560
你可以去看一下

22:26.560 --> 22:27.560
总之你要得到MOMENT对象

22:27.560 --> 22:28.560
你才有后续操作

22:29.560 --> 22:30.560
就这么一个回事

22:30.560 --> 22:32.560
给你传各种各样的格式

22:32.560 --> 22:34.560
让你去创建一个MOMENT对象

22:34.560 --> 22:36.560
好 拿到MOMENT对象之后

22:36.560 --> 22:37.560
可以做什么呢

22:37.560 --> 22:39.560
你看后边就各种各样的处理了

22:39.560 --> 22:41.560
取值复值

22:41.560 --> 22:42.560
比方说你要取哪一部分

22:42.560 --> 22:44.560
比方说我这个MOMENT对象

22:44.560 --> 22:46.560
我要给它取值Second

22:46.560 --> 22:47.560
我要看它的秒数

22:48.560 --> 22:50.560
就是秒类部分的值

22:50.560 --> 22:51.560
Second

22:52.560 --> 22:54.560
我要取年那部分的值一二

22:55.560 --> 22:56.560
就这么简单

22:56.560 --> 22:57.560
而且这个还说还可以更改

22:57.560 --> 22:59.560
要说一二我给它改成

22:59.560 --> 23:00.560
2000年

23:00.560 --> 23:02.560
那么这个年份就改了

23:02.560 --> 23:03.560
我们来看一下

23:03.560 --> 23:04.560
再取它的年份

23:04.560 --> 23:05.560
改了

23:05.560 --> 23:07.560
改成2000年了

23:07.560 --> 23:09.560
就是取值复值

23:09.560 --> 23:11.560
把这个日期各个部分都可以更改的

23:12.560 --> 23:13.560
更改年

23:13.560 --> 23:14.560
更改月

23:14.560 --> 23:16.560
更改日期

23:16.560 --> 23:17.560
都可以

23:17.560 --> 23:19.560
然后我们再看操作

23:19.560 --> 23:21.560
操作的话可以在这个

23:21.560 --> 23:22.560
在这个时间基础上

23:22.560 --> 23:23.560
再去改

23:23.560 --> 23:24.560
再去增加一些

23:24.560 --> 23:26.560
比方说我不是改

23:26.560 --> 23:28.560
我是在原用的时间基础上

23:28.560 --> 23:29.560
增加

23:29.560 --> 23:30.560
比方说这个ADD

23:30.560 --> 23:31.560
你看

23:31.560 --> 23:33.560
这个ADD方法非常非常简单

23:33.560 --> 23:34.560
我们找到这个MOMENT对象

23:34.560 --> 23:35.560
然后ADD

23:35.560 --> 23:37.560
然后添加一个

23:38.560 --> 23:39.560
添加什么呢

23:39.560 --> 23:40.560
那么这个E表示什么意思呢

23:40.560 --> 23:42.560
表示的是年一二十

23:42.560 --> 23:43.560
你看下面

23:44.560 --> 23:45.560
有这些

23:45.560 --> 23:46.560
第二个参数有这些邪法

23:46.560 --> 23:47.560
还有快捷键

23:47.560 --> 23:48.560
的话直接传

23:48.560 --> 23:49.560
只需要传一个Y就行了

23:49.560 --> 23:50.560
那么这样子

23:50.560 --> 23:51.560
它就增加了一年了

23:51.560 --> 23:52.560
什么意思

23:52.560 --> 23:54.560
它就增加了一年

23:54.560 --> 23:55.560
如果注意一下

23:55.560 --> 23:56.560
它这个玩意

23:56.560 --> 23:58.560
返回的

23:59.560 --> 24:00.560
增加了一年

24:00.560 --> 24:01.560
我们来看一下

24:01.560 --> 24:02.560
一二

24:02.560 --> 24:03.560
是吧

24:03.560 --> 24:04.560
2021年

24:04.560 --> 24:05.560
对吧

24:05.560 --> 24:06.560
你这里边

24:06.560 --> 24:07.560
这个下滑键

24:07.560 --> 24:10.510
你不用去管它

24:10.510 --> 24:11.510
就这么一些

24:11.510 --> 24:12.510
这个CORTOS

24:12.510 --> 24:13.510
季度

24:13.510 --> 24:14.510
月

24:14.510 --> 24:15.510
周

24:15.510 --> 24:16.510
天

24:16.510 --> 24:17.510
小时分钟秒

24:17.510 --> 24:18.510
你可以增加不同的部分

24:19.510 --> 24:20.510
当然你要减的话

24:20.510 --> 24:21.510
就用复数

24:21.510 --> 24:22.510
或者是掉这个方法也可以

24:22.510 --> 24:23.510
掉这个方法就是减

24:23.510 --> 24:24.510
那么就传正数

24:24.510 --> 24:26.510
掉这个方法传复数也是减

24:26.510 --> 24:28.510
就这么个意思

24:29.510 --> 24:30.510
然后这边

24:30.510 --> 24:31.510
还有一个就是STARTLE

24:31.510 --> 24:32.510
这啥意思呢

24:32.510 --> 24:33.510
这表示的是

24:33.510 --> 24:35.510
设置这个日期

24:35.510 --> 24:39.020
以某一个

24:39.020 --> 24:40.020
部分开头

24:40.020 --> 24:41.020
这啥意思

24:41.020 --> 24:43.020
我们又来一个MOMENT

24:44.020 --> 24:45.020
MOMENT

24:47.020 --> 24:48.020
2021年

24:50.020 --> 24:52.020
6月1号

24:52.020 --> 24:54.390
现在是

24:55.390 --> 24:56.390
凌晨8点

24:58.390 --> 24:59.390
这是本地时间

24:59.390 --> 25:00.390
所以我拿到一个MOMENT

25:00.390 --> 25:01.390
好

25:01.390 --> 25:02.390
然后我们看一下

25:02.390 --> 25:03.390
MOMENT的就是

25:05.390 --> 25:06.390
小时部分

25:08.390 --> 25:09.390
所以这是

25:09.390 --> 25:10.390
打到本地时间的吧

25:10.390 --> 25:12.390
打到本地时间的吧

25:13.390 --> 25:14.390
然后

25:14.390 --> 25:15.390
如果说你要

25:15.390 --> 25:17.390
把它设为凌晨

25:17.390 --> 25:18.390
那我怎么来设置呢

25:18.390 --> 25:19.390
我们可以用

25:20.390 --> 25:21.390
STARTLE

25:24.390 --> 25:25.390
设为今天上午12点

25:25.390 --> 25:27.390
就是凌晨

25:27.390 --> 25:28.390
STARTLE

25:29.390 --> 25:30.390
好

25:30.390 --> 25:31.390
这样你设置完了过后

25:31.390 --> 25:32.390
我们再来去拿小时

25:32.390 --> 25:33.390
就变成0了

25:33.390 --> 25:35.390
就是凌晨0.0分0秒

25:37.390 --> 25:38.390
对吧

25:38.390 --> 25:39.390
就是这么一回事

25:39.390 --> 25:41.390
总之它就做各种各样的操作

25:41.390 --> 25:42.390
然后呢

25:42.390 --> 25:43.390
还包括就是

25:43.390 --> 25:44.390
我看一下

25:45.390 --> 25:46.390
这个时长

25:46.390 --> 25:48.390
后边我们来看时长

25:48.390 --> 25:49.390
再来看显示

25:49.390 --> 25:50.390
显示的话

25:50.390 --> 25:52.390
就会把一个日期格式化

25:52.390 --> 25:53.390
格式化成本地的

25:53.390 --> 25:54.390
本地的时间来显示

25:54.390 --> 25:56.390
比方说用M FORMAT

25:56.390 --> 25:58.390
我们稍微的浏览一下

25:58.390 --> 25:59.390
它的这些各种操作

25:59.390 --> 26:00.390
我们一会儿来做项目的时候

26:00.390 --> 26:01.390
就做练习的时候

26:01.390 --> 26:02.390
来在具体的来说

26:02.390 --> 26:03.390
具体来查语文章

26:03.390 --> 26:04.390
解决问题就完事了

26:04.390 --> 26:05.390
5个就是拿

26:05.390 --> 26:06.390
MOMENT的对象

26:06.390 --> 26:07.390
然后做各种各样的东西

26:07.390 --> 26:09.390
做各种各样的行为

26:09.390 --> 26:10.390
给它进行格式化

26:10.390 --> 26:11.390
格式化了

26:11.390 --> 26:12.390
你给它写一个

26:12.390 --> 26:13.390
格式化的支部串

26:13.390 --> 26:14.390
比方它格式化的支部串

26:14.390 --> 26:15.390
怎么写呢

26:16.390 --> 26:18.390
我给它举个例子吧

26:18.390 --> 26:19.390
比方说我要写

26:19.390 --> 26:21.390
我要把它日期格式化成

26:21.390 --> 26:22.390
这种格式

26:22.390 --> 26:23.390
如果说你不传

26:23.390 --> 26:24.390
不传就是

26:24.390 --> 26:26.390
默认就是这种格式给你显示

26:26.390 --> 26:28.390
默认给你这种格式给你显示

26:28.390 --> 26:30.390
那么我们传递

26:30.390 --> 26:31.390
我们需要的格式

26:31.390 --> 26:32.390
比方说我们传

26:33.390 --> 26:34.390
Y Y Y Y

26:34.390 --> 26:36.390
就是世位数的年

26:36.390 --> 26:37.390
可不可以给它一个年

26:37.390 --> 26:39.390
MM

26:39.390 --> 26:41.390
约滴滴

26:41.390 --> 26:44.410
年分

26:44.410 --> 26:46.410
下面又有

26:52.110 --> 26:53.110
我看一下

26:54.110 --> 26:56.110
滴滴滴滴

26:56.110 --> 26:59.680
月份的日期

26:59.680 --> 27:00.680
滴滴

27:00.680 --> 27:01.680
没问题

27:01.680 --> 27:02.680
大小的滴滴

27:02.680 --> 27:03.680
然后小时

27:03.680 --> 27:04.680
24小时

27:04.680 --> 27:05.680
是HH

27:05.680 --> 27:06.680
分钟

27:06.680 --> 27:07.680
秒

27:07.680 --> 27:08.680
好

27:08.680 --> 27:09.680
我们来看一下

27:09.680 --> 27:10.680
它就有这么格式的显示了

27:10.680 --> 27:11.680
2021年

27:11.680 --> 27:12.680
6月1号

27:12.680 --> 27:13.680
小时分钟秒

27:13.680 --> 27:14.680
就返回一个支部串

27:14.680 --> 27:15.680
它其实本质上

27:15.680 --> 27:16.680
啥意思呢

27:16.680 --> 27:17.680
这些都是站位符

27:17.680 --> 27:18.680
4个Y表示

27:18.680 --> 27:19.680
它会有T

27:19.680 --> 27:21.680
它会用世位数的年分

27:21.680 --> 27:22.680
T换掉这个位置

27:22.680 --> 27:23.680
两个M

27:23.680 --> 27:24.680
它会用两位数的

27:24.680 --> 27:25.680
月份T换掉这个位置

27:25.680 --> 27:26.680
两个大D

27:26.680 --> 27:27.680
它会用两位数的

27:27.680 --> 27:28.680
日期T换掉这个位置

27:28.680 --> 27:30.680
那么每一个站位符

27:30.680 --> 27:31.680
什么意思

27:31.680 --> 27:32.680
它这里有个文档

27:32.680 --> 27:33.680
你可以至于去查阅

27:34.680 --> 27:35.680
原理上

27:35.680 --> 27:36.680
这就是

27:36.680 --> 27:38.680
咱们的Momance

27:38.680 --> 27:39.680
然后其实还有一些

27:39.680 --> 27:40.680
很多好玩的

27:40.680 --> 27:41.680
比方说像FromNow

27:41.680 --> 27:42.680
那么这个可以得到

27:42.680 --> 27:43.680
相对日期

27:43.680 --> 27:44.680
比方说我们用

27:44.680 --> 27:46.680
M.FromNow

27:48.680 --> 27:49.680
它就会告诉你

27:49.680 --> 27:50.680
17个小时前

27:50.680 --> 27:51.680
就这个日期到现在

27:51.680 --> 27:52.680
跟现在之间

27:52.680 --> 27:54.680
现在的时刻进行对比

27:54.680 --> 27:56.680
那么得到一个相对的时间

27:56.680 --> 27:57.680
而且这个文字

27:57.680 --> 27:58.680
还可以配置的

27:58.680 --> 27:59.680
这里有一个文档

27:59.680 --> 28:01.680
如果说你需要配置的话

28:01.680 --> 28:02.680
那么可以配置

28:03.680 --> 28:04.680
这样的意思

28:05.680 --> 28:06.680
还有什么呢

28:06.680 --> 28:08.680
还有一些

28:09.680 --> 28:11.680
这个我们来看一下

28:11.680 --> 28:12.680
Client

28:12.680 --> 28:13.680
这个还是挺有意思的

28:13.680 --> 28:15.680
都是以这个日期

28:15.680 --> 28:16.680
刚才这个玩意是跟

28:16.680 --> 28:17.680
当前的

28:17.680 --> 28:18.680
就是现在这个时刻

28:18.680 --> 28:20.680
时刻来进行对比

28:20.680 --> 28:21.680
得到一个相对的时间

28:21.680 --> 28:22.680
那么还有一种

28:22.680 --> 28:23.680
协访就是Client

28:23.680 --> 28:25.680
就以日历的协访

28:25.680 --> 28:26.680
Client

28:27.680 --> 28:29.680
那么这里传入一个相对时间

28:29.680 --> 28:30.680
一个传入传到的话

28:30.680 --> 28:32.680
就表示跟当前的时间

28:32.680 --> 28:33.680
来对比

28:33.680 --> 28:34.680
然后得到一个日历

28:34.680 --> 28:35.680
之上的时间

28:35.680 --> 28:36.680
那么这个玩意

28:36.680 --> 28:37.680
是什么东西呢

28:37.680 --> 28:38.680
我们就先直接

28:38.680 --> 28:39.680
长得不传吧

28:39.680 --> 28:40.680
给大家看一下

28:41.680 --> 28:42.680
它就显示这么格式

28:42.680 --> 28:44.680
今天的凌晨

28:44.680 --> 28:45.680
也可以看到

28:45.680 --> 28:46.680
这有些例子

28:46.680 --> 28:47.680
上星期一

28:47.680 --> 28:48.680
昨天今天

28:48.680 --> 28:50.680
它就用这种形式给你显示

28:50.680 --> 28:51.680
对吧

28:51.680 --> 28:52.680
显示一个日历的这种格式

28:52.680 --> 28:54.680
那么这玩意是可以配置的

28:54.680 --> 28:55.680
是可以配的

28:55.680 --> 28:56.680
在这里可以配置

28:56.680 --> 28:58.680
它说大概了解一下就行了

28:58.680 --> 28:59.680
总之呢

28:59.680 --> 29:00.680
它整个这个库

29:00.680 --> 29:01.680
它就是

29:01.680 --> 29:02.680
基本作用

29:02.680 --> 29:03.680
核心就是

29:03.680 --> 29:04.680
拿到Mobius对象

29:04.680 --> 29:05.680
然后通过这个对象

29:05.680 --> 29:06.680
通过各种这样的操作

29:07.680 --> 29:08.680
好

29:08.680 --> 29:09.680
了解这个库的基本用法之后

29:09.680 --> 29:11.680
大概能做什么事呢

29:11.680 --> 29:13.680
我们直接来上效果

29:13.680 --> 29:15.680
来看一下效果

29:15.680 --> 29:17.680
这是我们要做的事

29:17.680 --> 29:18.680
首先这个页面上

29:18.680 --> 29:19.680
显示中国

29:19.680 --> 29:20.680
英国

29:20.680 --> 29:21.680
纽约

29:21.680 --> 29:22.680
西尼

29:22.680 --> 29:23.680
这四个市区

29:23.680 --> 29:26.120
他们当时的时间

29:27.120 --> 29:28.120
然后呢

29:28.120 --> 29:30.120
这里可以填写你自己的生日

29:30.120 --> 29:32.120
表络我填写5月31号

29:32.120 --> 29:33.120
那么它就下面就会显示出

29:33.120 --> 29:35.120
你的出生日期是什么

29:35.120 --> 29:36.120
用一个格式显示出来

29:36.120 --> 29:38.120
然后你目前的年龄是多少

29:38.120 --> 29:39.120
不要说我们这些

29:39.120 --> 29:41.430
换一个吧

29:41.430 --> 29:42.430
1999年

29:43.430 --> 29:45.430
那么你的年龄是多少

29:45.430 --> 29:47.430
然后你在这个世界上存活了

29:47.430 --> 29:48.430
多少秒

29:48.430 --> 29:49.430
然后还有多少天

29:49.430 --> 29:52.430
会迎来你下一岁的生日

29:52.430 --> 29:54.430
那么在今年你

29:54.430 --> 29:56.430
在什么时候过了生日

29:56.430 --> 29:57.430
或者说你在

29:57.430 --> 29:59.430
你将在什么时间点过生日

29:59.430 --> 30:00.430
比方说我这个生日的

30:00.430 --> 30:02.430
之前的6月5号

30:02.430 --> 30:04.430
那么你将来本周星期六

30:04.430 --> 30:06.430
迎来下一个生日

30:06.430 --> 30:08.430
就这么个意思

30:08.430 --> 30:09.430
我们要做这么个效果

30:09.430 --> 30:10.430
那么这里面

30:10.430 --> 30:12.430
涉及到大量的时间的处理

30:12.430 --> 30:13.430
你要用原生的代程

30:13.430 --> 30:15.430
可以就写得很麻烦

30:15.430 --> 30:16.430
好我们来看一下

30:16.430 --> 30:17.430
怎么来做这个事

30:18.430 --> 30:19.430
这边有个练习素材

30:19.430 --> 30:20.430
我们直接把练习素材

30:20.430 --> 30:21.430
复制在这里

30:21.430 --> 30:22.430
这里是我们的贺常代

30:26.920 --> 30:27.920
印出了

30:27.920 --> 30:28.920
目前只有一些

30:28.920 --> 30:29.920
纯粹的静态样式

30:29.920 --> 30:30.920
没有写介式

30:30.920 --> 30:31.920
那么首先

30:31.920 --> 30:32.920
我们要做第一件事

30:32.920 --> 30:34.920
这里面肯定涉及到日期处理

30:34.920 --> 30:36.920
顺便我们再把

30:36.920 --> 30:38.920
杰克瑞引用进来吧

30:38.920 --> 30:39.920
杰克瑞

30:42.680 --> 30:43.680
然后这边

30:43.680 --> 30:44.680
script

30:44.680 --> 30:45.680
src

30:45.680 --> 30:47.680
杰克瑞引用进来

30:47.680 --> 30:49.680
然后这两个时间

30:49.680 --> 30:50.680
时间也引用进来

30:51.680 --> 30:52.680
这个两个

30:52.680 --> 30:53.680
介式引用进来

30:54.680 --> 30:55.680
是什么需要用的

30:55.680 --> 30:56.680
好这样

30:56.680 --> 30:57.680
我们到index.js

30:57.680 --> 30:58.680
里面去完成它

30:59.680 --> 31:00.680
index.js

31:00.680 --> 31:01.680
去完成它

31:01.680 --> 31:02.680
sys就不用写了

31:02.680 --> 31:03.680
不用你写了

31:03.680 --> 31:04.680
来吧

31:05.680 --> 31:06.680
我们要不成这个样子

31:07.680 --> 31:08.680
首先我们的整个程序

31:08.680 --> 31:09.680
思路还是一样

31:09.680 --> 31:10.680
像这一第三方货

31:10.680 --> 31:12.680
它不会改变

31:12.680 --> 31:13.680
我们开发的思路

31:13.680 --> 31:14.680
以后框架

31:14.680 --> 31:16.680
主要以后框架就会

31:16.680 --> 31:18.680
框架会让我们的开发思路

31:18.680 --> 31:20.680
会做出很大的变化

31:20.680 --> 31:22.680
但是这些第三方货不会的

31:22.680 --> 31:23.680
我们该用什么样的思路

31:23.680 --> 31:24.680
还是用什么样的思路

31:24.680 --> 31:26.680
首先就是一面初始化

31:26.680 --> 31:27.680
一开始我不动

31:27.680 --> 31:28.680
它要做啥

31:29.680 --> 31:31.680
是不是要设置

31:31.680 --> 31:33.680
这些各个

31:33.680 --> 31:34.680
时趋对不对

31:34.680 --> 31:35.680
是不是要设置这个东西

31:37.990 --> 31:38.990
就是这些元素

31:39.990 --> 31:40.990
是不是要去设置这些元素

31:40.990 --> 31:41.990
这个div

31:41.990 --> 31:43.990
中国的当前时间是多少

31:43.990 --> 31:45.990
英国的当前时间是多少

31:45.990 --> 31:46.990
然后纽约的当前时间

31:46.990 --> 31:47.990
系列的当前时间

31:47.990 --> 31:49.990
是不是要去设置这个东西

31:49.990 --> 31:51.990
那么这些元素是静态的

31:51.990 --> 31:52.990
我把它去掉

31:52.990 --> 31:54.990
静态的这些内容全部去掉

31:54.990 --> 31:56.990
因为我要用

31:57.990 --> 31:59.990
介石给它加进去

31:59.990 --> 32:01.990
于是我就写这么一个函数

32:02.990 --> 32:03.990
叫做set

32:08.990 --> 32:09.990
我就这样写

32:09.990 --> 32:10.990
写这么一个函数

32:10.990 --> 32:11.990
就是设置

32:12.990 --> 32:15.990
各个时趋的时间

32:15.990 --> 32:16.990
文本

32:17.990 --> 32:18.990
就把当前的时间

32:18.990 --> 32:19.990
设置

32:19.990 --> 32:20.990
转换成各种时趋的

32:20.990 --> 32:21.990
当地时间

32:21.990 --> 32:22.990
显示出来

32:23.990 --> 32:24.990
那么这里边

32:24.990 --> 32:25.990
我们怎么来操作呢

32:25.990 --> 32:26.990
大家想一想

32:28.990 --> 32:29.990
我们要去操作一个

32:29.990 --> 32:30.990
当前时间

32:30.990 --> 32:31.990
其实特别简单

32:31.990 --> 32:32.990
就是显示了

32:32.990 --> 32:33.990
某一个时趋的时间

32:33.990 --> 32:34.990
特别简单

32:34.990 --> 32:35.990
我们直接是用moment

32:35.990 --> 32:36.990
moment的时间

32:36.990 --> 32:37.990
拿到了是不是utc

32:37.990 --> 32:38.990
时间

32:38.990 --> 32:39.990
当前的utc时间

32:39.990 --> 32:40.990
那你看这几个时间

32:40.990 --> 32:41.990
utc时间是不是一样的

32:42.990 --> 32:43.990
不一样就快了

32:43.990 --> 32:44.990
你只要把它换

32:44.990 --> 32:46.990
都是此时此刻

32:46.990 --> 32:47.990
又不会穿越

32:48.990 --> 32:50.990
你现在你的此时此刻

32:50.990 --> 32:52.990
跟utc的此时此刻

32:52.990 --> 32:53.990
是一个时刻

32:53.990 --> 32:55.990
只是他们显示出来的东西

32:55.990 --> 32:56.990
不一样而已

32:56.990 --> 32:57.990
都指的是一个时刻

32:57.990 --> 32:58.990
那么换成utc时间

32:58.990 --> 32:59.990
都是一样的

32:59.990 --> 33:00.990
那么比方说

33:00.990 --> 33:01.990
我们用这个

33:01.990 --> 33:02.990
是不是达到utc时间

33:02.990 --> 33:03.990
还内部记录了

33:03.990 --> 33:04.990
接下来我只要

33:04.990 --> 33:05.990
给它设置一个时趋

33:05.990 --> 33:06.990
让它用指定的时趋

33:06.990 --> 33:07.990
给我显示出来

33:07.990 --> 33:08.990
就完事了

33:08.990 --> 33:10.990
那怎么来设置时趋呢

33:10.990 --> 33:11.990
查文档

33:12.990 --> 33:13.990
文档里边怎么来设置时趋呢

33:13.990 --> 33:14.990
这里有个国际化

33:14.990 --> 33:19.990
应该是操作

33:19.990 --> 33:21.990
utc offsets

33:22.990 --> 33:24.990
这是设置utc的偏移量

33:24.990 --> 33:25.990
就是时趋

33:25.990 --> 33:26.990
比方说你这个地方

33:26.990 --> 33:27.990
设置的是8

33:27.990 --> 33:28.990
那么就是

33:28.990 --> 33:30.990
在utc时间基础上加8

33:30.990 --> 33:31.990
那么就相当于

33:31.990 --> 33:32.990
是东巴区

33:32.990 --> 33:33.990
就是北京时间

33:33.990 --> 33:34.990
一说设置个-8

33:34.990 --> 33:37.990
那就是-7-8区

33:37.990 --> 33:39.990
应该是纽约时间

33:39.990 --> 33:40.990
看一下是不是纽约时间

33:41.990 --> 33:42.990
我尝试还不

33:42.990 --> 33:43.990
我还真忘了

33:45.990 --> 33:46.990
纽约

33:46.990 --> 33:47.990
西武区

33:47.990 --> 33:48.990
纽约在

33:48.990 --> 33:49.990
七八区是哪

33:49.990 --> 33:50.990
洛杉矶

33:53.990 --> 33:54.990
那么现在呢

33:54.990 --> 33:55.990
我们就到这来

33:55.990 --> 33:56.990
比方说我要显示

33:56.990 --> 33:57.990
一个东巴区的时间

33:57.990 --> 33:59.990
或者是西市区

33:59.990 --> 34:00.990
西市区

34:00.990 --> 34:01.990
西武区

34:01.990 --> 34:02.990
纽约时间

34:02.990 --> 34:03.990
那我们该怎么来

34:03.990 --> 34:04.990
怎么来操作呢

34:04.990 --> 34:05.990
这是当前utc的时间

34:05.990 --> 34:06.990
对吧

34:06.990 --> 34:07.990
接下来

34:07.990 --> 34:08.990
我就该怎么去显示

34:08.990 --> 34:10.990
使用utc offsets

34:11.990 --> 34:12.990
偏移

34:12.990 --> 34:14.990
西武区就是-5

34:14.990 --> 34:15.990
然后呢

34:15.990 --> 34:16.990
这就是

34:16.990 --> 34:18.990
后续的显示

34:18.990 --> 34:20.990
我们就可以利用这个

34:20.990 --> 34:21.990
对象来进行显示了

34:21.990 --> 34:23.990
因为它设置完了过后

34:23.990 --> 34:24.990
它偏移量过后

34:24.990 --> 34:25.990
我们再来进行format

34:25.990 --> 34:26.990
对吧

34:26.990 --> 34:27.990
格式化成一个日期

34:29.990 --> 34:30.990
再把它进行格式化

34:30.990 --> 34:32.990
显示format

34:32.990 --> 34:33.990
对吧

34:33.990 --> 34:34.990
再雕一个字幕刷

34:34.990 --> 34:36.990
格式字幕刷就是

34:36.990 --> 34:37.990
显示一个

34:38.990 --> 34:39.990
月

34:39.990 --> 34:40.990
日

34:40.990 --> 34:41.990
小时

34:41.990 --> 34:42.990
分钟

34:45.560 --> 34:46.560
这是什么

34:46.560 --> 34:47.560
这是西武区

34:47.560 --> 34:48.560
西武区

34:48.560 --> 34:49.560
我就这样写吧

34:49.560 --> 34:50.560
输出

34:50.560 --> 34:51.560
西武区

34:52.560 --> 34:53.560
把你看一下

34:53.560 --> 34:57.700
我没调用是吧

35:01.910 --> 35:02.910
出现了算了

35:02.910 --> 35:03.910
对吧

35:03.910 --> 35:04.910
这是西武区

35:04.910 --> 35:05.910
现在美国的时间

35:05.910 --> 35:06.910
纽约的时间

35:06.910 --> 35:07.910
纽约的时间

35:09.910 --> 35:10.910
现在呢

35:10.910 --> 35:11.910
但是我们不仅仅去

35:11.910 --> 35:12.910
设置一个

35:12.910 --> 35:13.910
对吧

35:13.910 --> 35:14.910
我们有这么多DIV

35:14.910 --> 35:15.910
都需要设置

35:15.910 --> 35:16.910
那么哪个DIV设置

35:16.910 --> 35:17.910
更呢

35:17.910 --> 35:18.910
我们是要做很多的判断

35:18.910 --> 35:19.910
第一个

35:19.910 --> 35:20.910
拿这个DIV

35:20.910 --> 35:21.910
我要去设置中国的

35:21.910 --> 35:22.910
第二个呢

35:22.910 --> 35:23.910
英国的

35:23.910 --> 35:24.910
英国是哪个市区

35:24.910 --> 35:25.910
我要去一个个的判断

35:25.910 --> 35:26.910
那么这里的最好做法

35:26.910 --> 35:28.910
是利用自定义属性

35:28.910 --> 35:32.610
使用

35:32.610 --> 35:33.610
中国的市区

35:33.610 --> 35:37.330
让这个

35:37.330 --> 35:38.330
让这个市区的

35:38.330 --> 35:39.330
这个信息

35:39.330 --> 35:40.330
跟我们的DIV

35:40.330 --> 35:41.330
自行观念

35:41.330 --> 35:42.330
英国的市区

35:42.330 --> 35:44.330
英国的市区就零

35:44.330 --> 35:45.330
纽约的市区

35:45.330 --> 35:46.330
纽约的市区

35:46.330 --> 35:47.330
就是富武

35:47.330 --> 35:48.330
西里

35:48.330 --> 35:49.330
西里是多少

35:49.330 --> 35:51.330
好像是富石

35:51.330 --> 35:54.660
我还真不知道

35:54.660 --> 35:55.660
西里是多少

35:55.660 --> 35:56.660
那就富石

35:56.660 --> 35:57.660
那就富石吧

35:57.660 --> 35:58.660
哦

35:58.660 --> 35:59.660
哦

35:59.660 --> 36:00.660
证实

36:00.660 --> 36:01.660
西里

36:01.660 --> 36:02.660
证实

36:02.660 --> 36:03.660
东吗

36:03.660 --> 36:04.660
东就是证

36:04.660 --> 36:05.660
证实

36:05.660 --> 36:06.660
在西里

36:07.660 --> 36:08.660
好吧

36:08.660 --> 36:09.660
如果说我有误的话

36:09.660 --> 36:10.660
你们自己更改

36:10.660 --> 36:11.660
好

36:11.660 --> 36:12.660
那么这样子

36:12.660 --> 36:13.660
我就把这个

36:13.660 --> 36:14.660
实区的这个信息

36:14.660 --> 36:15.660
跟这个DIV一关联了

36:15.660 --> 36:16.660
那么现在我要做啥

36:16.660 --> 36:17.660
所有带这个自定义

36:17.660 --> 36:18.660
属性的DIV

36:18.660 --> 36:20.660
是不是

36:20.660 --> 36:21.660
我要干嘛

36:21.660 --> 36:22.660
我要拿到所有带

36:22.660 --> 36:23.660
这个自定义

36:23.660 --> 36:24.660
属性的DIV

36:24.660 --> 36:26.660
是不是用Decore

36:27.660 --> 36:29.660
Decore用属性选择器

36:29.660 --> 36:30.660
跟C色选择器一样

36:30.660 --> 36:32.660
还有这么一个属性

36:32.660 --> 36:33.660
对它做

36:34.660 --> 36:35.660
只要有这个属性的DIV

36:35.660 --> 36:36.660
我全部拿到

36:38.660 --> 36:39.660
好

36:39.660 --> 36:40.660
拿到这个DIV过后

36:40.660 --> 36:41.660
我们可以利用

36:41.660 --> 36:42.660
Decore里面的函数

36:42.660 --> 36:43.660
一起来进行循环

36:43.660 --> 36:44.660
第一个参数是

36:44.660 --> 36:45.660
下标

36:45.660 --> 36:46.660
然后第二参数是

36:46.660 --> 36:47.660
元数

36:48.660 --> 36:49.660
我们来输出一下

36:49.660 --> 36:50.660
这个元数

36:52.660 --> 36:53.660
看一下吧

36:53.660 --> 36:54.660
Sets呢

36:54.660 --> 36:55.660
所以拿到了

36:55.660 --> 36:56.660
四个DIV

36:56.660 --> 36:57.660
对吧

36:57.660 --> 36:58.660
每个DIV里面

36:58.660 --> 36:59.660
是有一个自定义属性

36:59.660 --> 37:00.660
好

37:00.660 --> 37:01.660
那么接下来

37:01.660 --> 37:02.660
我是不是可以注意

37:02.660 --> 37:03.660
这里是动物

37:03.660 --> 37:04.660
拿到的是动物元数

37:04.660 --> 37:05.660
那么我们是不是

37:05.660 --> 37:06.660
可以利用这个

37:06.660 --> 37:07.660
这个玩意

37:07.660 --> 37:08.660
Data Set

37:08.660 --> 37:09.660
什么

37:09.660 --> 37:10.660
Zone

37:11.660 --> 37:12.660
是不是拿到这个

37:12.660 --> 37:13.660
实区的值

37:13.660 --> 37:14.660
把它转换成数字吧

37:16.980 --> 37:17.980
输出

37:19.980 --> 37:20.980
好

37:20.980 --> 37:21.980
现在我们来看一下

37:22.980 --> 37:23.980
是不是拿到

37:23.980 --> 37:24.980
各个实区的数字了

37:24.980 --> 37:25.980
拿到实区的数字过后

37:25.980 --> 37:26.980
我们是不是就可以

37:26.980 --> 37:27.980
用这个代码了

37:27.980 --> 37:28.980
来吧

37:28.980 --> 37:29.980
用一个代码来

37:29.980 --> 37:30.980
再走一次

37:34.060 --> 37:35.060
我们要拿到的

37:35.060 --> 37:36.060
偏意量多少

37:36.060 --> 37:37.060
我就是个Zone

37:37.060 --> 37:38.060
实区

37:38.060 --> 37:39.060
然后format

37:39.060 --> 37:40.060
把它变成这种格式

37:40.060 --> 37:41.060
对吧

37:41.060 --> 37:42.060
这就是日期的制服串

37:43.060 --> 37:44.060
然后把这个制服串

37:44.060 --> 37:45.060
给谁复职

37:45.060 --> 37:47.060
给这个变量的

37:47.060 --> 37:49.060
Inner Atm

37:49.060 --> 37:50.060
当然你也可以把它

37:50.060 --> 37:51.060
转换成界块

37:51.060 --> 37:52.060
用Atm 函数复职

37:52.060 --> 37:53.060
都一样

37:53.060 --> 37:54.060
好

37:54.060 --> 37:55.060
现在我们去调一下

37:55.060 --> 37:56.060
这个函数

37:56.060 --> 37:57.060
这是什么

37:57.060 --> 37:58.060
你看是不是设置好了

37:58.060 --> 37:59.060
不同实区

37:59.060 --> 38:00.060
是好

38:00.060 --> 38:01.060
我看是对的

38:01.060 --> 38:02.060
应该是对的

38:03.060 --> 38:04.060
那么现在有如何的

38:04.060 --> 38:05.060
那个时间

38:05.060 --> 38:06.060
不停的变化呢

38:06.060 --> 38:07.060
你用一个TCT

38:07.060 --> 38:08.060
不玩了吗

38:08.060 --> 38:09.060
Sesino

38:10.060 --> 38:12.060
每个一秒钟

38:12.060 --> 38:13.060
你重新调一下

38:13.060 --> 38:14.060
这个函数

38:14.060 --> 38:15.060
这是什么

38:15.060 --> 38:16.060
不玩了吗

38:17.060 --> 38:19.060
一开始调用一次

38:19.060 --> 38:20.060
然后后边

38:20.060 --> 38:21.060
每个一秒钟

38:21.060 --> 38:22.060
重新调用一次

38:22.060 --> 38:23.060
它时间就不停的走

38:23.060 --> 38:24.060
这就是初始化掉

38:24.060 --> 38:25.060
做了算

38:25.060 --> 38:26.060
对不对

38:26.060 --> 38:27.060
输了一下

38:27.060 --> 38:28.060
本期们暂停视频

38:28.060 --> 38:29.060
把这个

38:29.060 --> 38:30.060
Sesino 函数

38:30.060 --> 38:31.060
把这一块功能完成

38:31.060 --> 38:32.060
然后呢

38:32.060 --> 38:33.060
我们再说下面的

38:33.060 --> 38:34.060
好

38:34.060 --> 38:35.060
下面这一块

38:36.060 --> 38:37.060
像这个粒子

38:38.060 --> 38:39.060
基本上

38:39.060 --> 38:40.060
常见的日期操作

38:40.060 --> 38:41.060
都在里面了

38:42.060 --> 38:43.060
这个地方

38:43.060 --> 38:44.060
是一个交互效果

38:44.060 --> 38:45.060
对吧

38:45.060 --> 38:46.060
只要这个文笨框

38:46.060 --> 38:47.060
这是一个

38:47.060 --> 38:48.060
TypeWareData的文笨框

38:48.060 --> 38:49.060
那么这个文笨框

38:49.060 --> 38:50.060
内容改变之后

38:50.060 --> 38:51.060
我们就需要

38:51.060 --> 38:52.060
重新

38:52.060 --> 38:54.060
设置下面的文笨

38:54.060 --> 38:55.060
所以我们这个

38:55.060 --> 38:56.060
刚刚就写了函数

38:58.060 --> 38:59.060
SetsInfo

38:59.060 --> 39:01.060
SetsInfo

39:01.060 --> 39:04.060
设置跟生日相关的信息

39:05.060 --> 39:09.060
设置和生日相关的信息

39:10.060 --> 39:12.060
那么生日数据

39:12.060 --> 39:15.060
来源于文笨框的值

39:15.060 --> 39:17.940
好

39:17.940 --> 39:18.940
那么这里我们是不是

39:18.940 --> 39:19.940
首先要拿到这个文笨框

39:19.940 --> 39:20.940
文笨框在哪

39:20.940 --> 39:21.940
是不是在这

39:21.940 --> 39:22.940
BurstInfo

39:22.940 --> 39:23.940
我都给你

39:23.940 --> 39:24.940
在这

39:24.940 --> 39:25.940
BurstInfo

39:25.940 --> 39:26.940
我都给你写好一个ID了

39:26.940 --> 39:27.940
你直接拿

39:28.940 --> 39:32.790
对吧

39:32.790 --> 39:33.790
拿到这个文笨框

39:34.790 --> 39:35.790
文笨框是什么

39:35.790 --> 39:36.790
我们要拿它的Value值

39:36.790 --> 39:37.790
Value值用8

39:37.790 --> 39:38.790
你可以去查一下

39:38.790 --> 39:39.790
结块位的文档

39:39.790 --> 39:40.790
拿到它的Value值

39:40.790 --> 39:41.790
好

39:41.790 --> 39:42.790
我们来看一下吧

39:42.790 --> 39:43.790
那么这个Value值

39:43.790 --> 39:44.790
是一个文笨

39:44.790 --> 39:46.790
就是Burst

39:46.790 --> 39:48.790
这是一个生日的文笨

39:49.790 --> 39:50.790
保存

39:50.790 --> 39:51.790
我们来看一下

39:51.790 --> 39:52.790
我们调用这个函数

39:52.790 --> 39:54.790
就是SetsBurstInfo

39:54.790 --> 39:55.790
拿到的是什么

39:55.790 --> 39:56.790
拿到的是个空置五串

39:57.790 --> 39:58.790
对不对

39:58.790 --> 39:59.790
因为它现在没有写东西

39:59.790 --> 40:00.790
然后不要那么多

40:00.790 --> 40:01.790
这里写一个吧

40:01.790 --> 40:03.790
1999年1月1号

40:03.790 --> 40:04.790
那么这里现在

40:04.790 --> 40:05.790
我们拿一个BurstInfo

40:05.790 --> 40:06.790
拿到这个

40:07.790 --> 40:08.790
也就是说我们这里

40:08.790 --> 40:09.790
拿到的文笨

40:09.790 --> 40:10.790
可能是一个无销的值

40:10.790 --> 40:11.790
比方说它这里

40:11.790 --> 40:12.790
只写了一部分

40:12.790 --> 40:13.790
然后就可能拿到

40:13.790 --> 40:14.790
没有填完

40:14.790 --> 40:15.790
没有填完的话

40:15.790 --> 40:16.790
那么它的Value值

40:16.790 --> 40:17.790
还是唯空

40:17.790 --> 40:18.790
所以说我们这里

40:18.790 --> 40:19.790
那就判断一下吧

40:19.790 --> 40:20.790
比方说我们这里写个

40:20.790 --> 40:21.790
你

40:21.790 --> 40:22.790
延续了

40:22.790 --> 40:23.790
你再看

40:24.790 --> 40:25.790
没填完

40:25.790 --> 40:26.790
没填完就是空

40:26.790 --> 40:27.790
所以说我们这里

40:27.790 --> 40:28.790
如果说

40:28.790 --> 40:30.790
如果说BurstInfo

40:30.790 --> 40:31.790
BurstTSD

40:31.790 --> 40:33.790
这个是无销的

40:33.790 --> 40:35.790
没写完

40:35.790 --> 40:36.790
那么这种情况下

40:36.790 --> 40:37.790
是不是没有办法

40:37.790 --> 40:38.790
去设置下面的

40:38.790 --> 40:39.790
都没有写完

40:39.790 --> 40:40.790
我怎么去设置呢

40:40.790 --> 40:41.790
这个地方

40:41.790 --> 40:42.790
我就把下面的清空

40:42.790 --> 40:43.790
那怎么来清空呢

40:43.790 --> 40:45.790
我们下面不是个DV吗

40:45.790 --> 40:46.790
DV里边

40:46.790 --> 40:47.790
什么样的信息

40:47.790 --> 40:48.790
BurstInfoID

40:48.790 --> 40:50.790
我就把BurstInfo

40:50.790 --> 40:52.790
给它去AT秒

40:52.790 --> 40:54.790
或者叫MT

40:54.790 --> 40:55.790
清空

40:55.790 --> 40:56.790
然后方法结束了

40:56.790 --> 40:58.790
不用再进去往后走了

40:58.790 --> 40:59.790
好

40:59.790 --> 41:00.790
我们来看一下

41:00.790 --> 41:02.790
一开始我去调用它

41:02.790 --> 41:03.790
是不是就清空了

41:03.790 --> 41:04.790
对不对

41:05.790 --> 41:06.790
那么如果说

41:06.790 --> 41:08.790
我这边写了的话

41:08.790 --> 41:12.870
那就不会清空

41:12.870 --> 41:14.870
得到打印出这个日期了

41:14.870 --> 41:15.870
打印出这个文本了

41:15.870 --> 41:16.870
好那么如果说

41:16.870 --> 41:17.870
你写了一个正确的

41:17.870 --> 41:19.870
就是这里是不正确的

41:19.870 --> 41:22.870
不正确的日期文本

41:22.870 --> 41:23.870
就没有填完

41:23.870 --> 41:25.870
如果说你填完了

41:25.870 --> 41:26.870
那么就可以

41:26.870 --> 41:28.870
就可以来处理日期了

41:28.870 --> 41:29.870
我们手上有什么

41:29.870 --> 41:30.870
有这个文本

41:30.870 --> 41:31.870
我要把它转换成什么

41:31.870 --> 41:32.870
转换成MOMENT对象

41:32.870 --> 41:33.870
怎么转

41:33.870 --> 41:35.870
那就是刚才我们看到解析

41:35.870 --> 41:36.870
解析文章里面

41:36.870 --> 41:37.870
直接把文本传进去

41:37.870 --> 41:39.870
是不是拿到BurstInfoID了

41:39.870 --> 41:41.870
那么这里边就寄入一个UTC时间

41:41.870 --> 41:42.870
内部寄入的

41:42.870 --> 41:45.500
你都不用管

41:45.500 --> 41:46.500
BurstInfoID

41:46.500 --> 41:51.220
那么这里就是一个MOMENT对象

41:51.220 --> 41:52.220
我这里干脆就这样

41:52.220 --> 41:53.220
这个函数什么时候运行呢

41:53.220 --> 41:55.220
我们就注册一个时间

41:55.220 --> 41:56.220
什么时候运行呢

41:56.220 --> 41:58.220
就在那个

41:58.220 --> 42:00.220
这个文本框内容变化的时候运行

42:00.220 --> 42:01.220
对吧

42:01.220 --> 42:04.220
所以说我们这里BurstInfoID

42:04.220 --> 42:06.220
这个文本框内容变化

42:06.220 --> 42:07.220
迁起

42:07.220 --> 42:10.220
或者是InfoID的时间

42:10.220 --> 42:12.220
InfoID的时间就是实施变化

42:12.220 --> 42:15.220
迁起了要失去焦点之后

42:15.220 --> 42:17.220
我就把这个函数直接放在这了

42:17.220 --> 42:20.790
当InfoID的时间发生的时候

42:20.790 --> 42:21.790
我就运行这个函数

42:21.790 --> 42:22.790
咱们来看一下吧

42:22.790 --> 42:24.790
一开始我们这里

42:24.790 --> 42:29.300
一开始为什么没有运行这个函数

42:29.300 --> 42:38.180
一开始为什么没有运行这个函数

42:38.180 --> 42:40.180
我看一下

42:40.180 --> 42:46.450
输出一下123

42:46.450 --> 42:48.450
这个函数没运行

42:48.450 --> 42:50.450
它还必须要把它写完才运行

42:50.450 --> 42:55.850
那我们用一下券几的时间

42:55.850 --> 42:58.850
这个input时间不是应该是

42:58.850 --> 42:59.850
我想想

42:59.850 --> 43:02.850
这个input时间应该是立即运行

43:02.850 --> 43:03.850
应该是立即运行

43:03.850 --> 43:04.850
我用这种方式

43:04.850 --> 43:06.850
我们用多么来试一下

43:06.850 --> 43:11.850
input等于setBurstInfoID

43:11.850 --> 43:13.850
这个input时间只要变了一点

43:13.850 --> 43:15.850
还都会运行的

43:15.850 --> 43:16.850
这个Date

43:16.850 --> 43:17.850
这个Date框好像是

43:17.850 --> 43:20.850
有什么特殊的规定吗

43:20.850 --> 43:23.850
把换成Texa试一下

43:23.850 --> 43:28.700
Texa就可以

43:28.700 --> 43:29.700
就可以立即运行

43:29.700 --> 43:30.700
但是呢

43:30.700 --> 43:31.700
换成Date的话

43:31.700 --> 43:33.700
那么就是它的它的一个特点

43:33.700 --> 43:34.700
那就没办法了

43:34.700 --> 43:35.700
它的一个特点

43:35.700 --> 43:36.700
换成几个

43:36.700 --> 43:38.700
它都一样的

43:38.700 --> 43:40.700
都一样的

43:40.700 --> 43:41.700
它必须要写完

43:41.700 --> 43:43.700
写完过它才会触发

43:43.700 --> 43:44.700
没写完还不触发

43:44.700 --> 43:46.700
不要说我们这里写完吧

43:46.700 --> 43:48.700
今天5月5号

43:48.700 --> 43:50.700
5号你看是不是输出了123

43:50.700 --> 43:51.700
然后这里

43:51.700 --> 43:52.700
可以看到我们输出

43:52.700 --> 43:54.700
我们得到的摩摩执对象

43:54.700 --> 43:56.700
拿到摩摩执对象过后

43:56.700 --> 43:57.700
我要一个一个来了

43:57.700 --> 43:59.700
这里面有很多的

43:59.700 --> 44:00.700
这是第一个字母串

44:00.700 --> 44:01.700
这是第二个字母串

44:01.700 --> 44:02.700
第三个字母串

44:02.700 --> 44:03.700
第四个字母串

44:03.700 --> 44:04.700
我们要一个个来

44:04.700 --> 44:05.700
首先是P

44:05.700 --> 44:06.700
第一个字母串

44:06.700 --> 44:08.700
就是出生日期

44:08.700 --> 44:10.700
出生日期这个字母串

44:10.700 --> 44:11.700
特别简单

44:11.700 --> 44:12.700
用P1吧

44:12.700 --> 44:13.700
第一个段落

44:13.700 --> 44:15.700
那么它的字母串非常简单

44:15.700 --> 44:17.700
就是这么一个东西

44:17.700 --> 44:21.140
出生日期

44:21.140 --> 44:22.140
这里拼接啥呢

44:22.140 --> 44:25.140
拼接就是生日的一个

44:25.140 --> 44:26.140
比较合适的一个

44:26.140 --> 44:27.140
字母串显示方式

44:27.140 --> 44:29.140
那么这里拼接什么Burstay

44:29.140 --> 44:30.140
这是一个什么

44:30.140 --> 44:32.140
这是一个摩摩执对象

44:32.140 --> 44:33.140
对吧

44:33.140 --> 44:35.140
然后把它格式化一下

44:35.140 --> 44:36.140
format

44:36.140 --> 44:38.140
比较有年月字

44:38.140 --> 44:39.140
哪一年呢

44:39.140 --> 44:41.140
歪歪歪歪

44:41.140 --> 44:43.140
年MMM

44:43.140 --> 44:45.140
月滴滴

44:45.140 --> 44:48.220
好

44:48.220 --> 44:49.220
接下来我们最后

44:49.220 --> 44:53.220
就把这个Burst info

44:53.220 --> 44:56.220
Burst info

44:56.220 --> 44:57.220
受到它的AT秒

44:57.220 --> 44:58.220
然后P1

44:58.220 --> 44:59.220
是吧

44:59.220 --> 45:01.220
好 咱们来试一下

45:01.220 --> 45:04.220
1999年5月

45:04.220 --> 45:06.220
5月5号

45:06.220 --> 45:08.220
这就说显示出来了

45:08.220 --> 45:09.220
5月5号

45:09.220 --> 45:11.220
就设置到这么一个东西

45:11.220 --> 45:12.220
P1就设置进去了

45:12.220 --> 45:14.220
设置到DIVD

45:14.220 --> 45:16.220
好 咱们暂停视频

45:16.220 --> 45:17.220
先把这个简单的先搞定

45:17.220 --> 45:19.220
出生日期

45:19.220 --> 45:20.220
好了

45:20.220 --> 45:21.220
除了出生日期之外

45:21.220 --> 45:22.220
还有个年铃

45:22.220 --> 45:24.220
这个年铃计算

45:24.220 --> 45:26.220
年铃

45:26.220 --> 45:27.220
年铃怎么算呢

45:27.220 --> 45:28.220
A级

45:28.220 --> 45:29.220
年铃

45:29.220 --> 45:31.220
我们知道它的生日

45:31.220 --> 45:32.220
年铃是什么

45:32.220 --> 45:34.220
是不是生日到我

45:34.220 --> 45:35.220
当前这个时间段

45:35.220 --> 45:37.220
当前这一刻

45:37.220 --> 45:39.220
经过的年

45:39.220 --> 45:40.220
对不对

45:40.220 --> 45:41.220
那么怎么算呢

45:41.220 --> 45:42.220
要查文档

45:42.220 --> 45:43.220
这个文档里边有没有

45:43.220 --> 45:46.220
算以两个日期之间的差值呢

45:46.220 --> 45:48.220
这里有个时长

45:48.220 --> 45:49.220
看这里

45:49.220 --> 45:52.220
有没有一个差值

45:52.220 --> 45:54.220
来找一找

45:54.220 --> 45:56.220
操作

45:56.220 --> 45:57.220
显示

45:57.220 --> 46:00.530
查询

46:00.530 --> 46:02.530
制定义

46:02.530 --> 46:03.530
等一下

46:03.530 --> 46:04.530
我要找一找

46:04.530 --> 46:08.530
取值复值

46:08.530 --> 46:11.530
应该是在哪呢

46:11.530 --> 46:13.530
显示肯定不是

46:13.530 --> 46:15.530
它只是把它显示出来

46:15.530 --> 46:19.350
查询

46:19.350 --> 46:20.350
国际化肯定不是

46:20.350 --> 46:22.350
制定义

46:22.350 --> 46:27.010
时长

46:27.010 --> 46:28.010
DIV

46:28.010 --> 46:30.010
应该是这个DIV函数

46:30.010 --> 46:32.010
这个DIV函数在哪呢

46:32.010 --> 46:34.010
使用函数

46:34.010 --> 46:35.010
查询

46:35.010 --> 46:37.010
这个DIV函数在哪呢

46:37.010 --> 46:42.300
时长

46:42.300 --> 46:46.870
一二四

46:46.870 --> 46:48.870
不是

46:48.870 --> 46:50.870
不是不是

46:50.870 --> 46:52.870
这个DIV函数

46:52.870 --> 46:53.870
就是这个DIV函数啊

46:53.870 --> 46:56.870
这个DIV函数在哪呢

46:56.870 --> 46:58.870
制定义不上

46:58.870 --> 47:00.870
查询

47:00.870 --> 47:02.870
操作

47:02.870 --> 47:05.870
取值复值

47:05.870 --> 47:06.870
解析嘛

47:06.870 --> 47:07.870
难道是

47:07.870 --> 47:09.870
也不是

47:09.870 --> 47:12.570
哎呀

47:12.570 --> 47:14.570
这个地方我还忘了

47:14.570 --> 47:16.570
那我直接搜吧

47:16.570 --> 47:17.570
在哪呢

47:17.570 --> 47:19.570
显示这一块

47:19.570 --> 47:21.570
现在显示这一块

47:21.570 --> 47:23.570
怎么这样子分类

47:23.570 --> 47:24.570
什么意思呢

47:24.570 --> 47:25.570
这个函数是

47:25.570 --> 47:26.570
它指的是

47:26.570 --> 47:27.570
你当前

47:27.570 --> 47:28.570
前面是一个moment对象

47:28.570 --> 47:29.570
你这个的

47:29.570 --> 47:30.570
这个时间

47:30.570 --> 47:33.570
跟我另外一个时间

47:33.570 --> 47:35.570
他们的差值

47:35.570 --> 47:36.570
哪一部分的差值呢

47:36.570 --> 47:37.570
作为第二个参数

47:37.570 --> 47:39.570
再传进去

47:39.570 --> 47:40.570
举个例子

47:40.570 --> 47:41.570
A和B

47:41.570 --> 47:43.570
它之间相差了多少天

47:43.570 --> 47:44.570
返回1

47:44.570 --> 47:46.570
就这么个意思

47:46.570 --> 47:47.570
明白吧

47:47.570 --> 47:48.570
所以说我们这一块

47:48.570 --> 47:49.570
要做的话就这样做

47:49.570 --> 47:53.100
A级

47:53.100 --> 47:54.100
我们

47:54.100 --> 47:55.100
这个BIRSTED

47:55.100 --> 47:57.100
BIRSTED就是它的生日

47:57.100 --> 47:59.100
DIV

47:59.100 --> 48:00.100
和我们那个

48:00.100 --> 48:03.100
当前时间moment

48:03.100 --> 48:04.100
它的差值

48:04.100 --> 48:05.100
哪一部分的差值呢

48:05.100 --> 48:06.100
连内部分

48:06.100 --> 48:08.100
一二四

48:08.100 --> 48:09.100
我们看一下

48:09.100 --> 48:10.100
连内部分的字母刷

48:10.100 --> 48:11.100
什么写的

48:11.100 --> 48:13.100
一二四

48:13.100 --> 48:15.100
那么就写一二四

48:15.100 --> 48:16.100
连这部分的差值

48:16.100 --> 48:19.100
那么就是连你

48:19.100 --> 48:20.100
对不对

48:20.100 --> 48:21.100
我们来输出一下

48:21.100 --> 48:27.100
你看1999年5月

48:27.100 --> 48:28.100
5号

48:28.100 --> 48:30.100
它是-22

48:30.100 --> 48:31.100
对不对

48:31.100 --> 48:32.100
因为它是

48:32.100 --> 48:33.100
前边剪后边

48:33.100 --> 48:34.100
我们反过来吧

48:34.100 --> 48:37.920
moment

48:37.920 --> 48:38.920
BIRSTED

48:38.920 --> 48:39.920
这样子争取的

48:39.920 --> 48:40.920
好再来

48:40.920 --> 48:44.920
1999年5月5号

48:44.920 --> 48:45.920
是不是22岁

48:45.920 --> 48:46.920
对吧

48:46.920 --> 48:47.920
你刷一下吧

48:47.920 --> 48:48.920
现在是2021年

48:48.920 --> 48:49.920
2021年剪去1999

48:49.920 --> 48:51.920
是不是22岁

48:51.920 --> 48:52.920
那如果说

48:52.920 --> 48:53.920
它的生日还没到呢

48:53.920 --> 48:54.920
比方说

48:54.920 --> 48:56.920
那么这里是10月5号

48:56.920 --> 48:57.920
它就是21

48:57.920 --> 48:58.920
为什么可以是21呢

48:58.920 --> 49:00.920
因为2021年这个时间

49:00.920 --> 49:03.920
剪去1999年10月5号的时间

49:03.920 --> 49:05.920
是不是还不足22年

49:05.920 --> 49:06.920
对吧

49:06.920 --> 49:07.920
是21点几

49:07.920 --> 49:08.920
对吧

49:08.920 --> 49:09.920
是有

49:09.920 --> 49:11.920
那么它这里就直接去掉小数了

49:11.920 --> 49:12.920
那么就说21点

49:12.920 --> 49:14.920
所以说直接可以刷出连你

49:14.920 --> 49:16.920
那么就连你就刷出来了

49:16.920 --> 49:17.920
那么连你刷出过后

49:17.920 --> 49:18.920
我们第二个部分的制服刷

49:18.920 --> 49:19.920
就可以拼接出来

49:19.920 --> 49:20.920
p2

49:20.920 --> 49:23.940
好

49:23.940 --> 49:24.940
这里p2

49:24.940 --> 49:25.940
连你是这个

49:25.940 --> 49:27.940
拼接一下

49:27.940 --> 49:28.940
连你

49:28.940 --> 49:29.940
这里边

49:29.940 --> 49:30.940
我们直接寫

49:30.940 --> 49:32.940
p2拿到过后

49:32.940 --> 49:33.940
我就这里

49:33.940 --> 49:34.940
直接加一下

49:34.940 --> 49:35.940
拼接一下

49:35.940 --> 49:36.940
p2

49:36.940 --> 49:37.940
好咱们再来看

49:37.940 --> 49:39.940
1999年5月

49:41.940 --> 49:42.940
6号

49:42.940 --> 49:43.940
说连你就出来了

49:43.940 --> 49:44.940
这里

49:44.940 --> 49:45.940
10月

49:45.940 --> 49:46.940
6号

49:46.940 --> 49:47.940
21

49:47.940 --> 49:48.940
好

49:48.940 --> 49:49.940
连你就出来了

49:49.940 --> 49:50.940
那么只要这样

49:50.940 --> 49:51.940
其实有同学就有疑问了

49:51.940 --> 49:53.940
那是万一他够填到一个错误的生日

49:53.940 --> 49:55.940
比方说他把生日填到哪去了

49:55.940 --> 49:58.940
给我填到大雨当前日期了

49:58.940 --> 49:59.940
对吧

49:59.940 --> 50:01.940
还不是说今天出生的

50:01.940 --> 50:02.940
明天出生的

50:02.940 --> 50:04.940
那你怎么知道是明天出生的

50:04.940 --> 50:06.940
所以说这里生日是有一个情况

50:06.940 --> 50:08.940
就是如果说你的生日

50:08.940 --> 50:10.940
你填下的生日有问题

50:10.940 --> 50:11.940
什么问题呢

50:11.940 --> 50:13.940
猛闷的对象可以直接比较大小的

50:13.940 --> 50:15.940
可以直接比较大小

50:15.940 --> 50:16.940
小雨

50:16.940 --> 50:17.940
那么这个其实有当前时间

50:17.940 --> 50:18.940
我就把

50:18.940 --> 50:20.940
先用一个闹

50:20.940 --> 50:21.940
表示当前时间

50:21.940 --> 50:23.940
这里可以重复使用了

50:23.940 --> 50:25.940
没有必要去反后的窗戒对象

50:25.940 --> 50:28.940
如果说生日是大雨当前时间

50:29.940 --> 50:31.940
那怎么样

50:31.940 --> 50:33.940
我就要

50:33.940 --> 50:35.940
说明生日是有问题的

50:35.940 --> 50:38.940
生日有问题

50:38.940 --> 50:40.940
生日有问题会怎么样

50:40.940 --> 50:42.940
那么就还是一样

50:42.940 --> 50:44.940
不正确的日期

50:44.940 --> 50:46.940
或者是我给他设置一个ATM

50:46.940 --> 50:48.940
表示

50:48.940 --> 50:51.940
生日不正确

50:51.940 --> 50:52.940
再设置这么一个文本

50:52.940 --> 50:53.940
一个错误消息

50:53.940 --> 50:55.940
把比方说我这里填一个

50:55.940 --> 51:00.940
2022年1月1号生日不正确

51:00.940 --> 51:01.940
对吧

51:01.940 --> 51:03.940
把这个问题再归庇掉

51:03.940 --> 51:04.940
如果说我会填今天

51:04.940 --> 51:06.940
2021年6月1号

51:06.940 --> 51:07.940
今天没问题

51:07.940 --> 51:09.940
连定为0

51:09.940 --> 51:10.940
有没有意思

51:10.940 --> 51:12.940
就这么个意思

51:12.940 --> 51:13.940
好

51:13.940 --> 51:15.940
出生日期有了

51:15.940 --> 51:16.940
连定有了

51:16.940 --> 51:17.940
同学们暂停视频

51:17.940 --> 51:19.940
把连定这一块的功能完成

51:19.940 --> 51:20.940
好了

51:20.940 --> 51:22.940
那么接下来下一步

51:22.940 --> 51:23.940
你在这个世界上

51:23.940 --> 51:24.940
已经存在了多少天

51:24.940 --> 51:29.140
多少秒

51:29.140 --> 51:30.140
生存

51:30.140 --> 51:32.140
时长

51:32.140 --> 51:34.140
那么就是P3

51:35.140 --> 51:36.140
你在这个世界上

51:36.140 --> 51:37.140
存在了多少秒钟

51:37.140 --> 51:38.140
那么这里

51:38.140 --> 51:39.140
要填一个东西

51:39.140 --> 51:40.140
先随便填一个

51:40.140 --> 51:42.140
P3加进来

51:43.140 --> 51:44.140
再试一下

51:44.140 --> 51:47.140
2010年1月1号

51:47.140 --> 51:48.140
存在了多少秒钟

51:48.140 --> 51:49.140
这个是不是要算

51:49.140 --> 51:50.140
算什么

51:50.140 --> 51:52.140
算你生日

51:52.140 --> 51:53.140
到现在

51:53.140 --> 51:55.140
经过的秒数

51:55.140 --> 51:56.140
对吧

51:56.140 --> 51:57.140
所以也可以用DEF

51:57.140 --> 51:58.140
那么这里

51:58.140 --> 52:00.140
我们可以得到一个Second

52:00.140 --> 52:02.140
当前时间DEF

52:02.140 --> 52:03.140
Birthday

52:03.140 --> 52:05.140
生日

52:05.140 --> 52:06.140
生日那一天的

52:06.140 --> 52:08.140
秒数Second

52:08.140 --> 52:09.140
好

52:09.140 --> 52:10.140
那么把Second放下

52:10.140 --> 52:18.580
2021年6月1号

52:18.580 --> 52:20.580
存在了多少秒

52:20.580 --> 52:22.580
然后

52:22.580 --> 52:25.580
2020年

52:25.580 --> 52:27.580
看是不是没问题

52:27.580 --> 52:28.580
没问题

52:28.580 --> 52:29.580
好了

52:29.580 --> 52:31.580
那么都是存在了秒数

52:31.580 --> 52:33.580
然后接下来下一个

52:33.580 --> 52:34.580
你还有多少天

52:34.580 --> 52:36.580
就会迎来你的生日

52:36.580 --> 52:41.500
这里的情况有两种

52:41.500 --> 52:44.500
生日相对时间

52:44.500 --> 52:46.500
这里的情况有两种

52:46.500 --> 52:48.500
我们来看一下这边

52:48.500 --> 52:52.500
比方说我写一个1999年5月1号

52:52.500 --> 52:54.500
他的说法是

52:54.500 --> 52:55.500
你还有多少天

52:55.500 --> 52:56.500
会迎来你的生日

52:56.500 --> 52:59.500
就今年的生日已经过了

52:59.500 --> 53:00.500
明白吗

53:00.500 --> 53:01.500
你今年的生日

53:01.500 --> 53:02.500
已经过了

53:02.500 --> 53:03.500
你还有多少天

53:03.500 --> 53:05.500
会迎来你的生日

53:05.500 --> 53:06.500
如果说

53:06.500 --> 53:07.500
这里

53:07.500 --> 53:08.500
不对

53:08.500 --> 53:09.500
这里的写

53:09.500 --> 53:10.500
7月1号

53:10.500 --> 53:11.500
对了

53:11.500 --> 53:12.500
没问题的

53:12.500 --> 53:13.500
那么这里的写法

53:13.500 --> 53:14.500
其实只有一种

53:14.500 --> 53:15.500
你还有多少天

53:15.500 --> 53:16.500
就会迎来你多少

53:16.500 --> 53:18.500
睡的生日

53:18.500 --> 53:20.500
就这句话

53:20.500 --> 53:21.500
复制一下

53:21.500 --> 53:22.500
这是P3

53:22.500 --> 53:23.500
P4

53:23.500 --> 53:27.260
你还有多少天

53:27.260 --> 53:28.260
这个地方

53:28.260 --> 53:29.260
不知道

53:29.260 --> 53:30.260
多少睡的生日

53:30.260 --> 53:31.260
是不是知道

53:31.260 --> 53:33.260
就是当

53:33.260 --> 53:34.260
不对

53:34.260 --> 53:36.700
这个地方也不一定知道

53:36.700 --> 53:38.700
我们把个P4加进去

53:38.700 --> 53:40.700
同学想一想

53:40.700 --> 53:41.700
这两个温耗位置

53:41.700 --> 53:42.700
该怎么来算

53:42.700 --> 53:43.700
这个地方

53:43.700 --> 53:44.700
这个效果里边

53:44.700 --> 53:45.700
唯一复杂的

53:45.700 --> 53:46.700
就这个地方

53:46.700 --> 53:48.700
稍微点复杂

53:48.700 --> 53:50.700
东西该怎么来算

53:50.700 --> 53:53.700
因为他分为这么两种情况

53:53.700 --> 53:54.700
比方说

53:54.700 --> 53:58.700
5月1号

53:58.700 --> 54:01.700
你的年龄是22

54:01.700 --> 54:02.700
那么说明今年的生日

54:02.700 --> 54:03.700
而且5月1号的生日

54:03.700 --> 54:04.700
今年的生日就已经过了

54:04.700 --> 54:05.700
对吧

54:05.700 --> 54:06.700
已经过了生日了

54:06.700 --> 54:07.700
那么就是下一个生日了

54:07.700 --> 54:08.700
下一个生日就是

54:08.700 --> 54:09.700
还要过一年

54:09.700 --> 54:11.700
基本上要到明年去了

54:11.700 --> 54:12.700
还会这样的显示

54:12.700 --> 54:14.700
迎来你23岁的生日

54:14.700 --> 54:15.700
那如果说你目前的生日

54:15.700 --> 54:18.700
还没有到07

54:18.700 --> 54:20.700
那始终是年龄加一

54:20.700 --> 54:22.700
这个没问题

54:22.700 --> 54:24.700
始终是年龄加一

54:24.700 --> 54:26.700
就是你下一个生日的时间

54:26.700 --> 54:27.700
那么这里

54:27.700 --> 54:29.700
这个温耗位置是确定的

54:29.700 --> 54:30.700
不好意思

54:30.700 --> 54:32.700
温耗位置

54:32.700 --> 54:33.700
你这么知道

54:33.700 --> 54:35.700
到下一个生日还有多好

54:35.700 --> 54:37.700
还有多好天

54:38.700 --> 54:39.700
对不对

54:39.700 --> 54:41.700
到下一个生日还有多好天

54:41.700 --> 54:42.700
关键是

54:42.700 --> 54:43.700
我们是不是可以

54:43.700 --> 54:45.700
好像是可以利用这个

54:45.700 --> 54:46.700
用DEV

54:46.700 --> 54:48.700
但是你想一想

54:48.700 --> 54:50.700
DEV的话我们就算天嘛

54:52.700 --> 54:54.700
这个位置天啥

54:54.700 --> 54:55.700
这个位置天啥

54:55.700 --> 54:56.700
你把这两个位置点

54:56.700 --> 54:57.700
找出来

54:57.700 --> 54:58.700
那么就把这个纸

54:58.700 --> 55:00.700
放这就完事了

55:00.700 --> 55:01.700
就是两个日期之间

55:01.700 --> 55:03.700
还想它的天

55:04.700 --> 55:05.700
这个位置天啥

55:05.700 --> 55:10.480
想一想

55:11.480 --> 55:13.480
是不是

55:13.480 --> 55:15.480
你现在这个

55:15.480 --> 55:17.480
就是你要看你今年的生日

55:17.480 --> 55:19.480
有没有过

55:19.480 --> 55:21.480
如果说你今年的生日

55:21.480 --> 55:22.480
已经过了

55:22.480 --> 55:26.370
所以这种生日已经过了

55:26.370 --> 55:27.370
那么这个位置

55:27.370 --> 55:30.370
就是你今年的生日

55:30.370 --> 55:33.370
到你明年生日

55:33.370 --> 55:35.370
这个位置是

55:35.370 --> 55:37.370
当前时间

55:37.370 --> 55:39.370
这个位置是

55:39.370 --> 55:41.370
那么这个位置就是

55:41.370 --> 55:43.370
你明年生日的时间

55:43.370 --> 55:45.370
对不对

55:45.370 --> 55:46.370
就从今天开始到

55:46.370 --> 55:47.370
你下一个生日

55:47.370 --> 55:49.370
是不是明年生日的时间

55:49.370 --> 55:51.370
好

55:51.370 --> 55:53.370
那如果说你这个

55:53.370 --> 55:55.370
你这个地方

55:55.370 --> 55:57.370
今年的生日过了

55:57.370 --> 55:58.370
还没有过

55:58.370 --> 55:59.370
那么这个地方就是

55:59.370 --> 56:01.370
今年的生日的时间

56:01.370 --> 56:03.370
这有两种情况

56:03.370 --> 56:05.370
你好好梳理一下

56:05.370 --> 56:06.370
目前这个时间点

56:06.370 --> 56:08.370
到底下一个生日

56:08.370 --> 56:09.370
那下一个生日

56:09.370 --> 56:10.370
是不是今年的生日

56:10.370 --> 56:11.370
不一定

56:11.370 --> 56:12.370
今年的生日过了

56:12.370 --> 56:14.370
那就是下一个生日

56:14.370 --> 56:15.370
下一个生日

56:15.370 --> 56:16.370
今年的生日

56:16.370 --> 56:17.370
没有过

56:17.370 --> 56:19.370
那就是今年的生日

56:19.370 --> 56:20.370
那么是不是要判断

56:20.370 --> 56:21.370
今年的生日

56:21.370 --> 56:23.370
有没有过

56:23.370 --> 56:24.370
所以说

56:24.370 --> 56:25.370
这里是不是要得到

56:25.370 --> 56:26.370
今年的生日

56:26.370 --> 56:27.370
Z1

56:27.370 --> 56:29.370
Z2

56:29.370 --> 56:31.370
这是今年的生日

56:31.370 --> 56:33.370
今年的生日怎么来算呢

56:33.370 --> 56:34.370
我们就可以利用

56:34.370 --> 56:35.370
我们不是有个生日吗

56:35.370 --> 56:37.370
First day

56:37.370 --> 56:38.370
这是个模式对象

56:38.370 --> 56:40.370
我们只要把它的点

56:40.370 --> 56:41.370
是不是可以设置的

56:41.370 --> 56:42.370
我们之前看到文档里面

56:42.370 --> 56:43.370
可以设置它点

56:43.370 --> 56:44.370
设置为什么

56:44.370 --> 56:46.370
设置为今年的

56:46.370 --> 56:48.370
那今年又是哪一年呢

56:48.370 --> 56:50.370
我们不是有个老吗

56:50.370 --> 56:51.370
当前时间

56:51.370 --> 56:52.370
当前时间

56:52.370 --> 56:54.370
是不是可以拿到一个年份

56:54.370 --> 56:55.370
当前时间的年份

56:55.370 --> 56:56.370
不就是今年的

56:56.370 --> 56:57.370
那么这样子

56:57.370 --> 56:58.370
就能拿到一个今年的生日

56:58.370 --> 56:59.370
好

56:59.370 --> 57:00.370
咱们来看一下

57:00.370 --> 57:02.370
这个年份

57:02.370 --> 57:04.370
这个年份

57:04.370 --> 57:06.370
这个年份

57:06.370 --> 57:08.370
然后来给它稍微

57:08.370 --> 57:12.470
format一下

57:12.470 --> 57:13.470
年

57:13.470 --> 57:14.470
月

57:14.470 --> 57:15.470
日

57:15.470 --> 57:17.470
好看一下

57:17.470 --> 57:21.300
1999年5月1号

57:21.300 --> 57:23.300
那么拿到了今年的生日

57:23.300 --> 57:25.300
是不是2021年5月1号

57:25.300 --> 57:26.300
那如果说

57:26.300 --> 57:27.300
这里是7月1号

57:27.300 --> 57:28.300
拿到今年的生日

57:28.300 --> 57:30.300
是不是2021年7月1号

57:30.300 --> 57:31.300
对不对

57:31.300 --> 57:32.300
总之

57:32.300 --> 57:33.300
我们要拿到今年的生日

57:33.300 --> 57:34.300
今天我们来看一下

57:34.300 --> 57:36.300
今年的生日有没有过

57:36.300 --> 57:37.300
怎么来判断呢

57:37.300 --> 57:39.300
就看一这一二二二十

57:39.300 --> 57:41.300
是不是小于闹

57:41.300 --> 57:43.300
那么这个是什么情况

57:43.300 --> 57:46.300
今年的生日

57:46.300 --> 57:48.300
就是已经过了

57:48.300 --> 57:49.300
对吧

57:49.300 --> 57:50.300
你把个

57:50.300 --> 57:51.300
脑袋里面想象成

57:51.300 --> 57:52.300
这么一个日期的时间

57:52.300 --> 57:53.300
走

57:53.300 --> 57:54.300
这里是闹

57:54.300 --> 57:56.300
当前时间

57:56.300 --> 57:57.300
它比它小

57:57.300 --> 57:58.300
说明在之前

57:58.300 --> 58:00.300
自己已经发生过了

58:00.300 --> 58:01.300
今年的生日已经过了

58:01.300 --> 58:02.300
今年的生日

58:02.300 --> 58:03.300
已经过了的话

58:03.300 --> 58:04.300
那么我们是不是说

58:04.300 --> 58:06.300
要求的是明年的生日

58:06.300 --> 58:07.300
对吧

58:07.300 --> 58:09.300
那么我们就

58:09.300 --> 58:11.300
这里定一个

58:11.300 --> 58:13.300
Target

58:13.300 --> 58:15.300
我们这个地方

58:15.300 --> 58:17.300
我们要填到这儿来

58:17.300 --> 58:19.300
就说填到这儿

58:19.300 --> 58:20.300
那么这个地方

58:20.300 --> 58:21.300
如果说今年的生日过了

58:21.300 --> 58:22.300
我就要给它设置

58:22.300 --> 58:23.300
为什么明年的生日

58:23.300 --> 58:24.300
那就说

58:24.300 --> 58:25.300
还要把在今年的生日

58:25.300 --> 58:26.300
基础上

58:26.300 --> 58:27.300
我还要加一

58:27.300 --> 58:29.300
把那个

58:29.300 --> 58:30.300
ADD

58:30.300 --> 58:31.300
加一

58:31.300 --> 58:33.300
把连这一部分加一

58:33.300 --> 58:34.300
对吧

58:34.300 --> 58:35.300
那么就得到明年的生日

58:35.300 --> 58:36.300
我们要算

58:36.300 --> 58:37.300
现在到明年的生日

58:37.300 --> 58:38.300
还有多少天

58:38.300 --> 58:39.300
我们把这个东西

58:39.300 --> 58:41.300
就复制到这儿了

58:41.300 --> 58:46.780
是这个意思吧

58:46.780 --> 58:47.780
好

58:47.780 --> 58:48.780
我们来看一下

58:48.780 --> 58:49.780
这种情况

58:49.780 --> 58:50.780
现在呢

58:50.780 --> 58:51.780
我们得到

58:51.780 --> 58:52.780
得到一个

58:52.780 --> 58:53.780
1999年

58:53.780 --> 58:54.780
今年的生日

58:54.780 --> 58:55.780
已经过了的情况

58:55.780 --> 58:56.780
5月1号

58:56.780 --> 59:02.590
这里好像有点问题

59:02.590 --> 59:03.590
我们把Target

59:03.590 --> 59:04.590
Date

59:04.590 --> 59:07.540
输出

59:07.540 --> 59:08.540
Target

59:08.540 --> 59:09.540
Date

59:13.390 --> 59:14.390
输出一下

59:14.390 --> 59:16.390
1999年

59:16.390 --> 59:17.390
5月

59:17.390 --> 59:18.390
1号

59:19.390 --> 59:21.390
2022年5月1号

59:21.390 --> 59:22.390
没问题

59:22.390 --> 59:23.390
TargetDate

59:23.390 --> 59:24.390
没问题

59:25.390 --> 59:26.390
这里

59:26.390 --> 59:27.390
这里求的有问题吗

59:29.390 --> 59:30.390
当前

59:30.390 --> 59:32.390
当前时间

59:35.540 --> 59:36.540
这里写反了

59:39.550 --> 59:40.550
写反了

59:42.550 --> 59:43.550
这样子

59:43.550 --> 59:44.550
好

59:44.550 --> 59:45.550
咱们看

59:45.550 --> 59:46.550
5月1号

59:46.550 --> 59:47.550
那么你还有333天

59:47.550 --> 59:48.550
就引来你下一孔

59:48.550 --> 59:49.550
下一岁的生日

59:49.550 --> 59:50.550
对吧

59:50.550 --> 59:51.550
这个没问题

59:51.550 --> 59:52.550
好

59:52.550 --> 59:53.550
如果说

59:53.550 --> 59:54.550
当前的生日

59:54.550 --> 59:55.550
已经过了的情况

59:55.550 --> 59:56.550
如果说没有过呢

59:56.550 --> 59:57.550
现在生日没有过

59:57.550 --> 59:58.550
那就就算今年的生日

59:58.550 --> 59:59.550
那么这个都

59:59.550 --> 01:00:00.550
目标的日期

01:00:00.550 --> 01:00:01.550
就是我们今年的生日

01:00:01.550 --> 01:00:03.550
那也是一二二四

01:00:03.550 --> 01:00:05.550
就是我们当前的生日

01:00:05.550 --> 01:00:06.550
好

01:00:06.550 --> 01:00:07.550
咱们来看一下

01:00:07.550 --> 01:00:08.550
1999年

01:00:08.550 --> 01:00:09.550
7

01:00:10.550 --> 01:00:11.550
1999年

01:00:11.550 --> 01:00:13.550
7月1号

01:00:13.550 --> 01:00:14.550
就这么一回事

01:00:15.550 --> 01:00:18.440
好

01:00:18.440 --> 01:00:20.440
这是这么一个生日的

01:00:20.440 --> 01:00:21.440
相对时间

01:00:21.440 --> 01:00:22.440
然后最后一部分

01:00:23.440 --> 01:00:26.840
你已在

01:00:31.150 --> 01:00:32.150
最后一部分

01:00:35.680 --> 01:00:37.680
什么时候过的生日

01:00:38.680 --> 01:00:39.680
那么这里的写法

01:00:39.680 --> 01:00:40.680
有两种

01:00:40.680 --> 01:00:41.680
两种写法

01:00:41.680 --> 01:00:42.680
找到P5

01:00:47.810 --> 01:00:48.810
这是一种写法

01:00:48.810 --> 01:00:49.810
我们来看一下

01:00:49.810 --> 01:00:50.810
有没有别的写法

01:00:50.810 --> 01:00:53.810
1999年5月1号

01:00:56.310 --> 01:00:58.310
你已在什么什么过了生日

01:00:58.310 --> 01:00:59.310
就生日已经过了

01:00:59.310 --> 01:01:00.310
那如果说7月1号

01:01:00.310 --> 01:01:02.310
你将在什么什么迎来

01:01:02.310 --> 01:01:03.310
你下一个生日

01:01:03.310 --> 01:01:04.310
是不是有两种情况

01:01:04.310 --> 01:01:05.310
那这里只能用判断

01:01:06.310 --> 01:01:08.310
那还是一样的问题

01:01:08.310 --> 01:01:09.310
今年的生日有没有过

01:01:09.310 --> 01:01:11.310
你今年的生日有没有过

01:01:11.310 --> 01:01:12.310
那么今年的

01:01:12.310 --> 01:01:13.310
就是我们的

01:01:13.310 --> 01:01:14.310
这是我们的今年的生日

01:01:14.310 --> 01:01:15.310
对吧

01:01:15.310 --> 01:01:16.310
已经拿到了

01:01:16.310 --> 01:01:17.310
所以还是要判断一下

01:01:18.310 --> 01:01:19.310
是不是小鱼了

01:01:19.310 --> 01:01:20.310
说明啥

01:01:21.310 --> 01:01:23.310
今年的生日

01:01:23.310 --> 01:01:24.310
过了

01:01:25.310 --> 01:01:26.310
Els

01:01:27.310 --> 01:01:30.690
今年的生日

01:01:30.690 --> 01:01:32.690
还没有过

01:01:33.690 --> 01:01:34.690
然后这个制服串

01:01:34.690 --> 01:01:35.690
有两种情况

01:01:36.690 --> 01:01:37.690
我直接定一个

01:01:38.690 --> 01:01:39.690
Net

01:01:40.690 --> 01:01:41.690
把一个看

01:01:41.690 --> 01:01:42.690
如果说今年的生日

01:01:42.690 --> 01:01:43.690
过了的话

01:01:43.690 --> 01:01:44.690
它的显示格式是什么

01:01:44.690 --> 01:01:45.690
我们来看一下

01:01:45.690 --> 01:01:47.690
1999年5月1号

01:01:48.690 --> 01:01:49.690
你已在什么什么过了生日

01:01:49.690 --> 01:01:50.690
那么就相当于是

01:01:50.690 --> 01:01:51.690
在这里

01:01:51.690 --> 01:01:52.690
写个P元数

01:01:52.690 --> 01:01:54.690
还是P5

01:01:54.690 --> 01:01:55.690
P5

01:01:55.690 --> 01:01:57.690
等于

01:01:57.690 --> 01:01:58.690
P元数

01:01:58.690 --> 01:01:59.690
在这里边

01:01:59.690 --> 01:02:00.690
你已在

01:02:00.690 --> 01:02:01.690
什么时候过了生日

01:02:01.690 --> 01:02:02.690
那么这里边填上

01:02:03.690 --> 01:02:04.690
这里边

01:02:05.690 --> 01:02:06.690
昨天前天

01:02:06.690 --> 01:02:07.690
还是什么情况

01:02:07.690 --> 01:02:08.690
那么这里边

01:02:08.690 --> 01:02:09.690
我们要去使用一个

01:02:09.690 --> 01:02:10.690
相对的

01:02:10.690 --> 01:02:11.690
就是一个日丽文本

01:02:11.690 --> 01:02:12.690
在这

01:02:12.690 --> 01:02:14.690
显示的时候有Plant

01:02:14.690 --> 01:02:15.690
一个日丽文本

01:02:16.690 --> 01:02:17.690
那么就是

01:02:18.690 --> 01:02:19.690
一个时间

01:02:20.690 --> 01:02:21.690
相对于

01:02:21.690 --> 01:02:22.690
当前时间

01:02:22.690 --> 01:02:23.690
相对于这个时间

01:02:23.690 --> 01:02:24.690
如果说你不填的话

01:02:24.690 --> 01:02:25.690
就当前时间

01:02:25.690 --> 01:02:26.690
相对于当前时间

01:02:26.690 --> 01:02:27.690
那么它的一个

01:02:27.690 --> 01:02:29.690
相对日期是多少

01:02:29.690 --> 01:02:30.690
在日丽上

01:02:30.690 --> 01:02:31.690
应该怎么来描述

01:02:31.690 --> 01:02:33.690
就这么一个意思

01:02:34.690 --> 01:02:35.690
我们就是

01:02:35.690 --> 01:02:37.690
This year birth

01:02:38.690 --> 01:02:39.690
calendar

01:02:39.690 --> 01:02:41.690
这是今年的生日

01:02:41.690 --> 01:02:42.690
我们用 calendar 喊数

01:02:43.690 --> 01:02:44.690
就可以拿到

01:02:45.690 --> 01:02:46.690
它的这个

01:02:46.690 --> 01:02:48.690
相对的就是日丽文本

01:02:48.690 --> 01:02:49.690
我们就用call

01:02:49.690 --> 01:02:53.190
把日丽文本添找

01:02:54.190 --> 01:02:55.190
这是今年的生日

01:02:55.190 --> 01:02:56.190
已经过了

01:02:56.190 --> 01:02:57.190
我们来看一下

01:02:58.190 --> 01:03:01.190
1999年5月1号

01:03:01.190 --> 01:03:02.190
生日已经过了

01:03:02.190 --> 01:03:03.190
屁股还没加进去

01:03:05.950 --> 01:03:06.950
1999年

01:03:07.950 --> 01:03:09.950
1999年5月1号

01:03:10.950 --> 01:03:11.950
这是undefend

01:03:13.950 --> 01:03:14.950
怎么会是undefend的呢

01:03:15.950 --> 01:03:19.030
看一下

01:03:20.030 --> 01:03:24.780
calendar

01:03:26.780 --> 01:03:27.780
就这个喊数

01:03:28.780 --> 01:03:30.780
它对我反悔的是undefend

01:03:32.780 --> 01:03:33.780
This birth

01:03:33.780 --> 01:03:34.780
year birth

01:03:38.110 --> 01:03:40.110
怎么早也不能是undefend的呢

01:03:41.110 --> 01:03:42.110
我看一下吧

01:03:42.110 --> 01:03:43.110
看一下这边

01:03:43.110 --> 01:03:44.110
来测试一下

01:03:44.110 --> 01:03:45.110
moments 我啥都不传

01:03:45.110 --> 01:03:46.110
calendar

01:03:48.110 --> 01:03:50.110
怎么早也不能是undefend的呀

01:03:50.110 --> 01:03:52.110
它不反悔的是undefend

01:03:53.110 --> 01:03:54.110
这个call

01:03:59.600 --> 01:04:01.600
今年的生日过了

01:04:01.600 --> 01:04:07.180
没问题啊

01:04:08.180 --> 01:04:10.180
难道它进了aos

01:04:12.180 --> 01:04:13.180
不应该进aos

01:04:15.180 --> 01:04:16.180
可能是它进了aos

01:04:17.180 --> 01:04:25.160
7月1号 2号

01:04:26.160 --> 01:04:27.160
好像这边

01:04:27.160 --> 01:04:28.160
这个单码都没有运行

01:04:28.160 --> 01:04:29.160
看没

01:04:29.160 --> 01:04:31.160
它都没有运行的热耐嘛

01:04:33.160 --> 01:04:34.160
我这里输出一下cow

01:04:35.160 --> 01:04:36.160
看到底是哪一块输的问题

01:04:37.160 --> 01:04:38.160
1999年

01:04:38.160 --> 01:04:39.160
不行的话

01:04:39.160 --> 01:04:40.160
我要断脸调试了

01:04:44.690 --> 01:04:45.690
这是哪一行输出的

01:04:46.690 --> 01:04:52.070
calender

01:04:53.070 --> 01:04:54.070
这一行输出的

01:04:54.070 --> 01:04:55.070
倒是没有什么问题

01:04:55.070 --> 01:04:56.070
它都是输出的

01:04:57.070 --> 01:04:58.070
好 断脸调试

01:04:59.070 --> 01:05:01.070
这是这种一时半回的调不出来的话

01:05:01.070 --> 01:05:02.070
就断脸调试

01:05:02.070 --> 01:05:04.070
这就是杀手剪的

01:05:04.070 --> 01:05:05.070
好 接下来我们来看

01:05:06.070 --> 01:05:07.070
天天4月

01:05:07.070 --> 01:05:08.070
到这来

01:05:08.070 --> 01:05:09.070
我们一步一步看

01:05:09.070 --> 01:05:10.070
到底是什么运行的

01:05:10.070 --> 01:05:11.070
cow得到了这个东西

01:05:11.070 --> 01:05:12.070
倒是没问题

01:05:12.070 --> 01:05:13.070
然后我们看一下

01:05:13.070 --> 01:05:14.070
这个东西是不是小于它

01:05:14.070 --> 01:05:15.070
是不是小于它呢

01:05:15.070 --> 01:05:16.070
我们往下走

01:05:20.450 --> 01:05:21.450
它没有进这个衣服

01:05:21.450 --> 01:05:22.450
看到没

01:05:23.450 --> 01:05:24.450
今年的生日

01:05:24.450 --> 01:05:25.450
它没有进这个衣服

01:05:30.060 --> 01:05:31.060
明白了

01:05:31.060 --> 01:05:32.060
明白了

01:05:32.060 --> 01:05:33.060
我知道问题在哪

01:05:33.060 --> 01:05:34.060
问题在这

01:05:38.060 --> 01:05:39.060
这个问题是什么问题呢

01:05:40.060 --> 01:05:41.060
当你调动这个add

01:05:41.060 --> 01:05:42.060
方法的时候

01:05:42.060 --> 01:05:43.060
它会改动这个日期

01:05:44.060 --> 01:05:46.060
因为它之前运行到这的时候

01:05:46.060 --> 01:05:48.060
它把今年的生日又加了一年

01:05:49.060 --> 01:05:50.060
它出了这么一个问题

01:05:50.060 --> 01:05:51.060
因为调这个方法

01:05:51.060 --> 01:05:52.060
会改动这个日期

01:05:52.060 --> 01:05:53.060
所以说我这里

01:05:53.060 --> 01:05:54.060
可以用这种方式来操作

01:05:55.060 --> 01:05:56.060
movement

01:05:56.060 --> 01:05:57.060
把这个包一下

01:05:57.060 --> 01:05:59.060
那么这种做法是什么

01:05:59.060 --> 01:06:00.060
这里边传一个movement对象

01:06:00.060 --> 01:06:01.060
再用movement把它包一下

01:06:01.060 --> 01:06:02.060
那么就不相当于是

01:06:02.060 --> 01:06:04.060
复制了一个一模一样的movement出来

01:06:04.060 --> 01:06:06.060
就不会对它进行改动

01:06:06.060 --> 01:06:08.060
那么是对这个新的movement进行改动

01:06:08.060 --> 01:06:09.060
是这么一个情况

01:06:09.060 --> 01:06:10.060
不然的话

01:06:10.060 --> 01:06:12.060
它就加了一年变成明年的生日去了

01:06:12.060 --> 01:06:14.060
它把这个边上改了

01:06:14.060 --> 01:06:15.060
好 接下来我们再来看

01:06:15.060 --> 01:06:16.060
应该就没问题了

01:06:17.060 --> 01:06:18.060
5月1号

01:06:18.060 --> 01:06:20.500
然后呢

01:06:20.500 --> 01:06:22.500
如果说你传的是6月1号

01:06:22.500 --> 01:06:23.500
你看一下

01:06:23.500 --> 01:06:24.500
是不是今天

01:06:24.500 --> 01:06:25.500
但是这个文本啊

01:06:25.500 --> 01:06:26.500
这种格式的文本

01:06:26.500 --> 01:06:28.500
好像不是我们想要的

01:06:28.500 --> 01:06:29.500
我们想要一些别的文本

01:06:29.500 --> 01:06:30.500
不要过显示时间

01:06:30.500 --> 01:06:31.500
那怎么办呢

01:06:31.500 --> 01:06:32.500
怎么来格式化这个文本呢

01:06:32.500 --> 01:06:34.500
这里有文档

01:06:34.500 --> 01:06:35.500
它告诉你呢

01:06:35.500 --> 01:06:36.500
这里可以写配置

01:06:39.330 --> 01:06:40.330
第一个是相对日期

01:06:40.330 --> 01:06:41.330
写闹的话就表示

01:06:41.330 --> 01:06:43.330
这个日期相对于当前

01:06:44.330 --> 01:06:46.330
就是它一共有这么几种情况

01:06:46.330 --> 01:06:47.330
如果说跟今天是同一天

01:06:47.330 --> 01:06:49.330
那里显示什么

01:06:49.330 --> 01:06:51.330
那我就显示今天

01:06:52.330 --> 01:06:53.330
如果说是

01:06:53.330 --> 01:06:55.330
下一天我就显示明天

01:06:56.330 --> 01:06:57.330
如果说是上一天

01:06:57.330 --> 01:06:59.330
我就显示昨天

01:06:59.330 --> 01:07:01.330
如果说是下一周

01:07:01.330 --> 01:07:03.330
那么我就写个下个

01:07:03.330 --> 01:07:04.330
下个什么滴滴滴滴

01:07:04.330 --> 01:07:06.330
滴滴滴滴滴表示星期

01:07:06.330 --> 01:07:07.330
下个星期几

01:07:07.330 --> 01:07:08.330
如果说是上一周

01:07:08.330 --> 01:07:10.330
我就显示上一个星期几

01:07:10.330 --> 01:07:11.330
其他情况呢

01:07:11.330 --> 01:07:17.020
我就显示连月

01:07:17.020 --> 01:07:19.530
对吧

01:07:19.530 --> 01:07:20.530
可以配置了

01:07:20.530 --> 01:07:21.530
好 配置好了

01:07:21.530 --> 01:07:22.530
过后我们再来看

01:07:22.530 --> 01:07:24.530
就6年5月1号

01:07:24.530 --> 01:07:25.530
对吧

01:07:25.530 --> 01:07:26.530
这是其他情况

01:07:26.530 --> 01:07:27.530
那么6月1号

01:07:27.530 --> 01:07:31.530
就今天5月31号

01:07:31.530 --> 01:07:34.530
昨天30号上个星期日

01:07:34.530 --> 01:07:35.530
对吧

01:07:35.530 --> 01:07:36.530
没问题吧

01:07:37.530 --> 01:07:38.530
像我这边写的话

01:07:38.530 --> 01:07:40.530
就把那个上个下个都取掉了

01:07:41.530 --> 01:07:42.530
这是这个

01:07:42.530 --> 01:07:44.530
当前今天的生日已经过了

01:07:44.530 --> 01:07:45.530
今天的生日还没有过呢

01:07:45.530 --> 01:07:46.530
没有过的话

01:07:46.530 --> 01:07:48.530
就另外一套文本

01:07:48.530 --> 01:07:56.320
7月1号

01:07:56.320 --> 01:07:57.320
你将在什么什么

01:07:57.320 --> 01:07:59.320
迎来下一个生日

01:07:59.320 --> 01:08:02.890
那么屁股应该等于这个

01:08:02.890 --> 01:08:03.890
其他都一样

01:08:03.890 --> 01:08:05.890
你将在

01:08:05.890 --> 01:08:08.580
什么时候

01:08:08.580 --> 01:08:09.580
迎来下一个生日

01:08:09.580 --> 01:08:12.580
迎来下一个生日

01:08:12.580 --> 01:08:13.580
好了

01:08:13.580 --> 01:08:14.580
就写完了

01:08:14.580 --> 01:08:16.580
日系处理基本上就这么一些

01:08:16.580 --> 01:08:19.580
其实绕来绕去

01:08:19.580 --> 01:08:20.580
好多都是逻辑问题

01:08:20.580 --> 01:08:22.580
跟那个库道是没有什么关系

01:08:22.580 --> 01:08:23.580
你把逻辑想通的话

01:08:23.580 --> 01:08:24.580
就在库里边去找

01:08:24.580 --> 01:08:25.580
相应的操作

01:08:25.580 --> 01:08:27.580
看有没有相应的操作

01:08:27.580 --> 01:08:28.580
7月1号

01:08:28.580 --> 01:08:31.580
6月2号

01:08:31.580 --> 01:08:33.580
5号

01:08:33.580 --> 01:08:34.580
3号

01:08:34.580 --> 01:08:35.580
6

01:08:35.580 --> 01:08:36.580
3

01:08:36.580 --> 01:08:37.580
零

01:08:37.580 --> 01:08:38.580
3

01:08:38.580 --> 01:08:39.580
零4

01:08:39.580 --> 01:08:40.580
3

01:08:40.580 --> 01:08:41.580
3

01:08:42.580 --> 01:08:43.580
好

01:08:43.580 --> 01:08:44.580
就这么一个小练习

01:08:44.580 --> 01:08:46.580
它完成

01:08:46.580 --> 01:08:48.580
最好是能够一边查文档一边做

01:08:48.580 --> 01:08:49.580
这个摩门车里边

01:08:49.580 --> 01:08:51.580
反正也就这么一些函数

01:08:51.580 --> 01:08:53.580
反正就是这么一些函数

01:08:53.580 --> 01:08:54.580
你可以自己看一看

01:08:54.580 --> 01:08:56.580
大概每个函数大概什么意思

01:08:56.580 --> 01:08:58.580
了解一下就ok了

01:08:58.580 --> 01:08:59.580
大概了解一下就行了

01:08:59.580 --> 01:09:01.580
这是摩门车的库

