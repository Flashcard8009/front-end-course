WEBVTT

00:00.560 --> 00:04.560
咱们这节课能了解两个非常有意识的集合

00:04.560 --> 00:09.560
实际上在ES6里面它不仅出现了这个set集合和map集合

00:09.560 --> 00:14.560
并且它同时为set集合和map集合分别做了两个

00:14.560 --> 00:19.560
应该叫做复苏的集合 又做了两个新的玩意儿出来

00:19.560 --> 00:22.560
这两个玩意儿平时开发的时候没有什么用

00:22.560 --> 00:24.560
不过我觉得它非常有趣

00:24.560 --> 00:27.560
所以说我给大家介绍一下 做一个扩展课程

00:27.560 --> 00:30.560
那么首先让我们来看一下这个weak

00:30.560 --> 00:34.560
weak什么意思 弱的 弱的意思

00:34.560 --> 00:37.560
weakset 我都不知道怎么翻译它了

00:37.560 --> 00:39.560
它在解决一个什么样的问题呢

00:39.560 --> 00:41.560
其实这个东西都不叫问题

00:41.560 --> 00:44.560
就是有的时候我们可能有这样的一个需要

00:44.560 --> 00:47.560
啥意思呢 就是说我们在开发的时候

00:47.560 --> 00:49.560
可能有这么一个代码 大家看一下

00:49.560 --> 00:53.560
obj 是一个对象

00:53.560 --> 00:56.560
表面对象里边还有一些其他信息吧

00:56.560 --> 00:59.560
无所谓 我们随便写个信息 比方说

00:59.560 --> 01:02.560
A型18

01:02.560 --> 01:03.560
然后有这么一个对象

01:03.560 --> 01:05.560
我现在把这个对象放到哪儿了

01:05.560 --> 01:07.560
我把它放到set里边去 你看着

01:07.560 --> 01:11.560
我们这里创建一个set 又一个set

01:11.560 --> 01:14.560
然后我把对象放进去add 对吧obj

01:14.560 --> 01:16.560
放进去吧 没问题吧

01:16.560 --> 01:18.560
接下来我做这么一件事

01:18.560 --> 01:21.560
你看着 我把obj设置为now

01:21.560 --> 01:25.560
设置为now 请问这个set里边的对象还在吗

01:26.560 --> 01:29.560
还在吗 肯定是在的

01:29.560 --> 01:31.560
肯定是在的 为什么呢

01:31.560 --> 01:34.560
这次设置到gs的垃圾回收

01:34.560 --> 01:39.560
画个图 这个是gs的垃圾回收

01:39.560 --> 01:40.560
因为是这样子

01:40.560 --> 01:42.560
gs首先这句代码

01:42.560 --> 01:43.560
它是不是创建一个对象

01:43.560 --> 01:45.560
对吧 一个对象 我们画个图

01:45.560 --> 01:46.560
这里是一个对象

01:46.560 --> 01:47.560
对象里边有两个属性

01:47.560 --> 01:50.560
一个是name 是什么 原进

01:50.560 --> 01:53.560
A型是18 有这么两个属性

01:53.560 --> 01:56.560
然后它把对象的地址负责给谁

01:56.560 --> 01:58.560
负责给辨量obj

01:58.560 --> 02:00.560
它负责给辨量obj

02:00.560 --> 02:05.560
obj这个辨量它就指向

02:05.560 --> 02:08.560
它里边一个地址 它就指向谁

02:08.560 --> 02:13.190
指向这个对象 还有指向这

02:14.190 --> 02:15.190
指向这个对象

02:15.190 --> 02:19.190
然后我又把obj又放到set里边去

02:19.190 --> 02:21.190
现在咱们有个set

02:21.190 --> 02:24.190
看着咱们有一个set

02:24.190 --> 02:27.190
有个set辨量 它是一个集合

02:27.190 --> 02:29.190
这个集合 当然set也是个对象

02:29.190 --> 02:31.190
如果说严格画图的话

02:31.190 --> 02:33.190
那么应该是这样子画

02:33.190 --> 02:35.190
set也是个对象

02:35.190 --> 02:38.190
这个对象里边 它有地一项

02:38.190 --> 02:41.190
地一项是咋的 地一项是

02:41.190 --> 02:42.190
地一项是咋 加了一个obj

02:42.190 --> 02:43.190
它是不是个地址

02:43.190 --> 02:45.190
地一项也是个地址

02:45.190 --> 02:46.190
那么这个地址指向谁呢

02:46.190 --> 02:48.190
是不是也指向它

02:48.190 --> 02:50.190
地址是不是也指向它

02:50.190 --> 02:52.190
咱们换个颜色

02:54.760 --> 02:57.760
它这个地址也指向着它

02:57.760 --> 02:58.760
为什么呢

02:58.760 --> 03:00.760
因为我们这个set指向它

03:00.760 --> 03:02.760
这个set指向它

03:02.760 --> 03:03.760
对吧

03:03.760 --> 03:04.760
这是咱们辨量

03:04.760 --> 03:05.760
辨量是指向一个set

03:05.760 --> 03:07.760
set它只有一项

03:07.760 --> 03:09.760
地一项它里边有存了一个地址

03:09.760 --> 03:11.760
这个地址也指向它

03:11.760 --> 03:12.760
对不对

03:12.760 --> 03:14.760
如果说不严格来画的话

03:14.760 --> 03:15.760
因为下面这一块的话

03:15.760 --> 03:16.760
其实无所谓

03:16.760 --> 03:17.760
我们这样子画也行

03:17.760 --> 03:19.760
我们这样子能说明这个道理就行了

03:19.760 --> 03:21.760
set

03:21.760 --> 03:23.760
那么现在你看一下这个辨量

03:23.760 --> 03:25.760
它是不是有两个东西

03:25.760 --> 03:27.760
记录了它的地址

03:27.760 --> 03:29.760
当我有一天把obj

03:29.760 --> 03:31.760
设为null之后

03:31.760 --> 03:33.760
obj现在变成null了

03:33.760 --> 03:35.760
那么obj是不是不再指向它了

03:35.760 --> 03:37.760
obj变成指向一个null

03:37.760 --> 03:38.760
指向一个null

03:38.760 --> 03:40.760
它指向这个

03:40.760 --> 03:41.760
那么现在呢

03:41.760 --> 03:42.760
关键问题是

03:42.760 --> 03:45.760
它要不要被垃圾回收

03:45.760 --> 03:47.760
它就是垃圾回收器

03:47.760 --> 03:48.760
它会不会认为

03:48.760 --> 03:49.760
这一块的一群是垃圾

03:49.760 --> 03:50.760
要把它扔掉

03:50.760 --> 03:52.760
回收掉

03:52.760 --> 03:53.760
那么目前是不会的

03:53.760 --> 03:54.760
为什么不会

03:54.760 --> 03:56.760
它跟数组的道理是一样的

03:56.760 --> 03:58.760
介式引擎它认为

03:58.760 --> 04:00.760
虽然说你这个辨量已经找不到

04:00.760 --> 04:01.760
没法通过这个辨量

04:01.760 --> 04:02.760
找到这个对象了

04:02.760 --> 04:05.760
但是你还能通过set里边的这个东西

04:05.760 --> 04:07.760
因为你能找到这个set

04:07.760 --> 04:08.760
因为你有这个辨量

04:08.760 --> 04:10.760
你能够找到这个set

04:10.760 --> 04:11.760
那么你既然可以找到set

04:11.760 --> 04:13.760
那么你可以通过set里边的

04:13.760 --> 04:14.760
第一项你在辨历的时候

04:14.760 --> 04:16.760
是不是可以找到这个东西

04:16.760 --> 04:18.760
所以它不会进行垃圾回收

04:18.760 --> 04:21.760
以前的这个东西是完全没法控制的

04:21.760 --> 04:22.760
完全没法改的

04:22.760 --> 04:24.760
但是现在它为了

04:24.760 --> 04:27.760
你能够做一些特别烧的操作

04:27.760 --> 04:29.760
所以说它现在给你出了这么一个玩意

04:29.760 --> 04:31.760
叫做weekset

04:31.760 --> 04:33.760
weekset做什么事情呢

04:33.760 --> 04:35.760
它叫做弱没法翻译

04:35.760 --> 04:37.760
真的没法翻译叫弱set

04:37.760 --> 04:39.760
算了不翻译了

04:39.760 --> 04:41.760
它的特点是什么呢

04:41.760 --> 04:44.760
使用该集合

04:44.760 --> 04:46.760
使用该集合

04:46.760 --> 04:50.760
可以实现和set一样的功能

04:50.760 --> 04:52.760
set有的功能它也有

04:52.760 --> 04:55.760
不同的是

04:55.760 --> 04:56.760
哪些地方不同呢

04:56.760 --> 04:57.760
第一个点

04:57.760 --> 04:59.760
最重要的一个不同的点

04:59.760 --> 05:03.760
就是它内部的地址

05:03.760 --> 05:07.760
内部存储的对象地址

05:07.760 --> 05:11.760
不会影响垃圾回收

05:11.760 --> 05:13.760
不会影响垃圾回收

05:13.760 --> 05:15.760
这是啥意思呢

05:15.760 --> 05:17.760
这是啥意思 你看着

05:17.760 --> 05:20.760
我们之前用set我们来演示一下

05:20.760 --> 05:23.760
我们在这里添加了obj之后

05:23.760 --> 05:26.760
我们输出set

05:26.760 --> 05:29.760
是不是有这个值obj

05:29.760 --> 05:32.760
是不是有这个

05:32.760 --> 05:33.760
有这个啥呢

05:33.760 --> 05:35.760
有这个就是

05:35.760 --> 05:37.760
这个还真没法测试

05:37.760 --> 05:38.760
还没法测试

05:38.760 --> 05:39.760
我们只能说

05:39.760 --> 05:41.760
没法测试只能说

05:41.760 --> 05:42.760
我们放之后

05:42.760 --> 05:44.760
它其实这个对象是在的

05:44.760 --> 05:46.760
我们把这个设为拉我之后

05:46.760 --> 05:47.760
这个对象是在的

05:47.760 --> 05:48.760
这是set的情况

05:48.760 --> 05:50.760
如果说你一旦使用wigset

05:50.760 --> 05:52.760
一旦使用wigset

05:52.760 --> 05:54.760
那就不一样了

05:54.760 --> 05:56.760
wigset虽然它里边的地址

05:56.760 --> 05:58.760
现在是wigset

05:58.760 --> 06:00.760
虽然说它里边的地址

06:00.760 --> 06:02.760
仍然是指向它

06:02.760 --> 06:04.760
但是它不会影响垃圾回收

06:04.760 --> 06:07.760
你把外边的obj设为拉我之后

06:07.760 --> 06:10.760
你把外边的obj设为拉我之后

06:10.760 --> 06:13.760
它发现没有任何一个变量

06:13.760 --> 06:16.760
它就直接把对象给你回收掉了

06:16.760 --> 06:18.760
直接把对象给你回收掉了

06:18.760 --> 06:21.760
然后这里边有啥都看不到了

06:21.760 --> 06:22.760
没啥意思吗

06:22.760 --> 06:25.760
这就是它的这么一种情况

06:25.760 --> 06:26.760
wigset

06:26.760 --> 06:30.760
比方说我们还是来看一下

06:30.760 --> 06:33.760
看一下能不能测试一下

06:33.760 --> 06:35.760
比方说我们用set

06:35.760 --> 06:36.760
我们把obj设为拉我

06:36.760 --> 06:38.760
我们输出这个set

06:38.760 --> 06:39.760
输出这个set

06:39.760 --> 06:42.710
看一下

06:42.710 --> 06:44.710
怎么点新键

06:44.710 --> 06:45.710
运行

06:45.710 --> 06:51.070
看一下

06:51.070 --> 06:53.070
我这里怎么用

06:53.070 --> 06:54.070
这里要用net

06:54.070 --> 06:56.070
不然它变成长量了

06:56.070 --> 06:57.070
不是这

06:57.070 --> 06:58.070
不是这

06:58.070 --> 07:00.070
是这

07:00.070 --> 07:01.070
这里要用net

07:01.070 --> 07:03.070
看一下

07:03.070 --> 07:05.070
那你看set里边是不是还有这个数据

07:05.070 --> 07:06.070
数据还在

07:06.070 --> 07:07.070
看没 数据还在

07:07.070 --> 07:09.070
尽管没有外面的变量

07:09.070 --> 07:10.070
已经没有指向它了

07:10.070 --> 07:11.070
数据还在

07:11.070 --> 07:13.070
但是我们现在把它换成wigset

07:13.070 --> 07:14.070
你看一下

07:14.070 --> 07:16.070
本来换成wigset过后

07:16.070 --> 07:17.070
你看一下

07:17.070 --> 07:18.070
这里边是不是没数据了

07:18.070 --> 07:19.070
没数据了

07:19.070 --> 07:20.070
如果说我不删

07:20.070 --> 07:22.070
不删那个变量的指向

07:22.070 --> 07:24.070
obj的指向不删

07:24.070 --> 07:25.070
你看一下

07:25.070 --> 07:27.070
这里边有个数据

07:27.070 --> 07:30.070
但是我把外面obj的指向变成拉

07:30.070 --> 07:32.070
那么外表除了wigset之外

07:32.070 --> 07:33.070
其他都没有任何一个东西

07:33.070 --> 07:35.070
可以找到这个对象了

07:35.070 --> 07:36.070
那么wigset

07:36.070 --> 07:37.070
因为它不影响垃圾回收

07:37.070 --> 07:39.070
垃圾回收就当它不存在一样

07:39.070 --> 07:40.070
完全不考虑它

07:40.070 --> 07:42.070
所以说它就垃圾回收器

07:42.070 --> 07:45.070
我现在完全不考虑这个set

07:45.070 --> 07:47.070
我完全不考虑这个wigset

07:47.070 --> 07:48.070
我就看外面其他东西

07:48.070 --> 07:49.070
有没有东西能找到它

07:49.070 --> 07:50.070
发现没有

07:50.070 --> 07:51.070
OK 它就把它回收掉了

07:51.070 --> 07:53.070
那么wigset里边自然

07:53.070 --> 07:54.070
既然被回收掉了

07:54.070 --> 07:57.070
那么wigset里边自然啥都没有了

07:57.070 --> 07:59.070
这是wigset的特点

07:59.070 --> 08:01.070
它有这么一个特点

08:01.070 --> 08:03.070
好 那么它有这么一个

08:03.070 --> 08:04.070
基于它这么一个特点

08:04.070 --> 08:06.070
我们可以用它来干嘛呢

08:06.070 --> 08:08.070
我们也可以用它来记录一些东西

08:08.070 --> 08:10.070
就是我们要记录一些关键对象

08:11.070 --> 08:13.070
比如说我们在做一个程序的时候

08:13.070 --> 08:15.070
发现有一些对象的内容特别多

08:15.070 --> 08:16.070
占用内存特别多

08:16.070 --> 08:18.070
可能会影响效率

08:18.070 --> 08:20.070
那么为了防止它该回收的时候

08:20.070 --> 08:21.070
没有回收掉

08:21.070 --> 08:23.070
我们可以用wigset来记录它

08:23.070 --> 08:25.070
来通过观察这个wigset

08:25.070 --> 08:27.070
那么就可以看到

08:27.070 --> 08:29.070
那么有哪些对象已经被回收掉了

08:29.070 --> 08:30.070
哪些对象没有被回收掉

08:30.070 --> 08:32.070
就看这个wigset的内容

08:32.070 --> 08:33.070
那么有的时候

08:33.070 --> 08:34.070
我们创建一个对象

08:34.070 --> 08:37.070
就把它往wigset里边扔

08:37.070 --> 08:38.070
那么将来有一天

08:38.070 --> 08:39.070
我们再不要这个对象了

08:39.070 --> 08:41.070
OK 我们把外面的对象受为烙

08:41.070 --> 08:43.070
我们就可以通过观察

08:43.070 --> 08:44.070
观察这个wigset

08:44.070 --> 08:45.070
看里边有没有东西

08:45.070 --> 08:47.070
看里边还有没有这个对象

08:47.070 --> 08:48.070
如果说有的话

08:48.070 --> 08:49.070
说明还有东西在指向它

08:49.070 --> 08:50.070
比方说

08:50.070 --> 08:52.070
我们这里再写个obj2

08:52.070 --> 08:55.070
等于obj

08:55.070 --> 08:57.070
那么这样一来

08:57.070 --> 08:58.070
你看

08:58.070 --> 09:00.070
除了这个wigset之外

09:00.070 --> 09:01.070
那么是不是用

09:01.070 --> 09:03.070
两个东西指向这个对象

09:03.070 --> 09:05.070
那么我现在把这个对象的

09:05.070 --> 09:07.070
引用给它删除掉了

09:07.070 --> 09:08.070
那么看一下

09:08.070 --> 09:10.070
我们只需要通过wigset来观察一下

09:10.070 --> 09:11.070
看它对象在不在

09:11.070 --> 09:12.070
你发现对象还在

09:12.070 --> 09:13.070
对象还在说明了什么

09:13.070 --> 09:16.070
说明了是不是还有东西指向这个对象

09:16.070 --> 09:17.070
wigset有的时候

09:17.070 --> 09:18.070
它就起这么一个作用

09:18.070 --> 09:20.070
可以帮帮助我们

09:20.070 --> 09:22.070
就是调试这个代码中的

09:22.070 --> 09:24.070
就是有些该回收的对象

09:24.070 --> 09:26.070
没有回收掉的问题

09:26.070 --> 09:28.070
那么可以帮我们

09:28.070 --> 09:29.070
确定到底有没有东西

09:29.070 --> 09:32.070
还指向该回收的对象

09:32.070 --> 09:33.070
那么这个时候一看

09:33.070 --> 09:34.070
wigset里边还有

09:34.070 --> 09:36.070
说明还有东西指向它

09:36.070 --> 09:37.070
但是你想

09:37.070 --> 09:38.070
这个时候确实该回收掉了

09:38.070 --> 09:39.070
那就有检查的代码

09:39.070 --> 09:40.070
是

09:40.070 --> 09:42.070
还有什么东西会指向这个对象

09:42.070 --> 09:43.070
那你发现还有个obj2

09:43.070 --> 09:44.070
所以说你还得去删除

09:44.070 --> 09:46.070
这个obj2的引用

09:46.070 --> 09:47.070
没有那意思吗

09:47.070 --> 09:49.070
就是wigset

09:49.070 --> 09:50.070
那么现在

09:50.070 --> 09:51.070
表示完成的

09:51.070 --> 09:52.070
现在没问题了

09:52.070 --> 09:53.070
OK 那么说明这段代码

09:53.070 --> 09:55.070
它的回收现在正常了

09:55.070 --> 09:57.070
以前用输主肯定是观察不到的

09:57.070 --> 09:58.070
对吧

09:58.070 --> 09:59.070
因为输主里边的引用

09:59.070 --> 10:01.070
它是会影响垃圾回收的

10:01.070 --> 10:02.070
所以它观察不到的

10:02.070 --> 10:04.070
那么用wigset就能观察到

10:04.070 --> 10:05.070
是关于这一点

10:05.070 --> 10:07.070
尤其是你怎么用的

10:07.070 --> 10:08.070
另外就是

10:08.070 --> 10:09.070
它有机会

10:09.070 --> 10:10.070
它这么一种特点

10:10.070 --> 10:13.070
wigset跟set还是有一些区别的

10:13.070 --> 10:14.070
还有什么区别

10:14.070 --> 10:19.070
首先wigset它只能添加对象

10:19.070 --> 10:22.070
因为它就是用来监测对象引用的

10:22.070 --> 10:25.070
用来监测对象引用还在不在

10:25.070 --> 10:27.070
那么它说它只能添加对象

10:27.070 --> 10:28.070
第二是不能便利

10:28.070 --> 10:30.070
它不是一个可谍带的对象

10:30.070 --> 10:31.070
所以它不能便利

10:31.070 --> 10:32.070
不能用服O5便利

10:32.070 --> 10:33.070
不能便利

10:33.070 --> 10:35.070
没有size属性

10:35.070 --> 10:37.070
没有size属性

10:37.070 --> 10:39.070
没有什么

10:39.070 --> 10:41.070
没有dnet

10:41.070 --> 10:43.070
有dnet

10:43.070 --> 10:44.070
没有size

10:44.070 --> 10:45.070
我们之前说的set还有一些

10:45.070 --> 10:46.070
还有它的API

10:46.070 --> 10:47.070
我们看一下

10:49.070 --> 10:50.070
没有size

10:50.070 --> 10:51.070
对

10:51.070 --> 10:52.070
没有size

10:52.070 --> 10:53.070
没有就是不能便利

10:53.070 --> 10:54.070
它有这么一个特点

10:54.070 --> 10:56.070
没有size和不能便利

10:56.070 --> 10:59.070
因此你要想去便利这个set

10:59.070 --> 11:00.070
是不可能的

11:00.070 --> 11:02.070
同时还有没有for一起方法

11:02.070 --> 11:04.070
for一起方法

11:04.070 --> 11:05.070
不能便利

11:05.070 --> 11:08.070
是因为它不是谍带对象

11:08.070 --> 11:10.070
不是可谍带的对象

11:10.070 --> 11:12.070
为什么它不允许你便利呢

11:12.070 --> 11:14.070
它是这样子想的

11:14.070 --> 11:17.070
你不能去随意使用wigset里面的东西

11:17.070 --> 11:18.070
为什么呢

11:18.070 --> 11:19.070
因为wigset里面

11:19.070 --> 11:21.070
它是不会影响垃圾回收的

11:21.070 --> 11:23.070
你便利它没有什么意义

11:23.070 --> 11:26.070
你使用wigset的目的就是来观察

11:26.070 --> 11:28.070
哪些对象是被垃圾回收去回收的

11:28.070 --> 11:31.070
哪些对象还没有被垃圾回收

11:31.070 --> 11:32.070
对吧

11:32.070 --> 11:33.070
你是用来观察这个东西的

11:33.070 --> 11:34.070
它不是用

11:34.070 --> 11:35.070
因为你便利的话

11:35.070 --> 11:37.070
它就会把它保存到另外的便量了

11:37.070 --> 11:40.070
所以它觉得不应该去对它进行便利

11:40.070 --> 11:42.070
这是关于这个wigset

11:42.070 --> 11:44.070
另外一个就是

11:44.070 --> 11:46.070
叫做weekmap

11:46.070 --> 11:48.070
这个东西有的时候还

11:48.070 --> 11:50.070
会在我们的代码中出现

11:50.070 --> 11:51.070
这个玩意是怎么了

11:51.070 --> 11:52.070
它跟wigset差不多

11:52.070 --> 11:55.070
它是类似于

11:55.070 --> 11:58.070
类似于map的集合

11:58.070 --> 11:59.070
不同的是

11:59.070 --> 12:01.070
它用法来跟map差不多

12:01.070 --> 12:02.070
不同的是什么呢

12:02.070 --> 12:07.070
不同的是它的键

12:07.070 --> 12:14.070
必须它的键存储的地址

12:14.070 --> 12:18.070
不会影响垃圾回收

12:18.070 --> 12:19.070
这是啥意思呢

12:19.070 --> 12:20.070
第二点

12:20.070 --> 12:25.070
它的键只能是对象

12:25.070 --> 12:27.070
那么就相当于是set里边

12:27.070 --> 12:28.070
它不会影响垃圾回收

12:28.070 --> 12:30.070
那么map里边它的键

12:30.070 --> 12:31.070
不会影响垃圾回收

12:31.070 --> 12:32.070
就这么个意思

12:32.070 --> 12:33.070
看一下吧

12:33.070 --> 12:35.070
举个例子

12:35.070 --> 12:37.070
比方说还是个对象吧

12:37.070 --> 12:39.070
然后我们这里

12:39.070 --> 12:41.070
创建一个weekmap

12:41.070 --> 12:44.070
weekmap

12:44.070 --> 12:46.070
我们往weekmap里边

12:46.070 --> 12:50.070
往weekmap里边加一个数据

12:50.070 --> 12:51.070
set一个数据

12:51.070 --> 12:52.070
那么它的键是不能写

12:52.070 --> 12:53.070
什么是数字

12:53.070 --> 12:54.070
字幕出来是不能写的

12:54.070 --> 12:56.070
必须要写对象

12:56.070 --> 12:59.070
它的字随便写

12:59.070 --> 13:00.070
随便啥的字都可以

13:00.070 --> 13:02.070
但是键必须是对象

13:02.070 --> 13:03.070
那么这样你来

13:03.070 --> 13:05.070
只要一个对象没有被垃圾回收

13:05.070 --> 13:07.070
那么它的键就在

13:07.070 --> 13:08.070
我们来看一下

13:08.070 --> 13:09.070
只要一个对象没有被垃圾回收

13:09.070 --> 13:10.070
它的键就在

13:10.070 --> 13:13.380
你看这个weekmap

13:13.380 --> 13:14.380
是不是有个键

13:14.380 --> 13:15.380
键是一个对象

13:15.380 --> 13:16.380
如果说这个对象

13:16.380 --> 13:17.380
一旦被垃圾回收了

13:17.380 --> 13:19.380
比方说我们把ob界

13:19.380 --> 13:20.380
复制为nau

13:20.380 --> 13:21.380
一旦被垃圾回收了

13:21.380 --> 13:23.380
我们再看这个weekmap

13:23.380 --> 13:26.380
ob界

13:27.380 --> 13:28.380
我们在这里写吧

13:28.380 --> 13:29.380
我们在这里写

13:29.380 --> 13:31.380
我们把这个ob界

13:31.380 --> 13:34.380
复制为nau

13:34.380 --> 13:36.380
然后看一下

13:36.380 --> 13:37.380
因为它当时输出的时候

13:37.380 --> 13:39.380
当时输出的时候还在

13:39.380 --> 13:40.380
实际上你展开的时候

13:40.380 --> 13:41.380
它已经不在了

13:41.380 --> 13:42.380
因为展开的时候

13:42.380 --> 13:44.380
才会是实时读取

13:44.380 --> 13:45.380
实时读取的内容

13:45.380 --> 13:46.380
因为垃圾回收

13:46.380 --> 13:47.380
它不是立即回收的

13:47.380 --> 13:48.380
它有个过程

13:48.380 --> 13:49.380
它需要一段时间

13:49.380 --> 13:50.380
那么你展开的时候

13:50.380 --> 13:51.380
这个时候

13:51.380 --> 13:52.380
垃圾回收才会

13:52.380 --> 13:53.380
真正的把它回收掉

13:53.380 --> 13:55.380
不是说你一把色

13:55.380 --> 13:56.380
垃圾回收 马上就把它回收掉

13:56.380 --> 13:58.380
没有那么快

13:58.380 --> 13:59.380
所以说你看

13:59.380 --> 14:00.380
它里边是不是没东西了

14:00.380 --> 14:01.380
没东西了

14:01.380 --> 14:02.380
如果说你不把它

14:02.380 --> 14:03.380
设为nau

14:03.380 --> 14:04.380
你看一下

14:04.380 --> 14:05.380
它里边是不是有东西

14:05.380 --> 14:06.380
有东西

14:06.380 --> 14:08.380
是这么回事

14:08.380 --> 14:09.380
那么这样的意义

14:09.380 --> 14:10.380
它有什么样的意义呢

14:10.380 --> 14:11.380
它有的时候

14:11.380 --> 14:13.380
它会这么一个好处

14:13.380 --> 14:14.380
就是我们写代码的时候

14:14.380 --> 14:15.380
就比方说

14:15.380 --> 14:16.380
我们代码里边

14:16.380 --> 14:19.380
有一些Ul

14:19.380 --> 14:21.380
里边有些li

14:21.380 --> 14:22.380
比方说有10个

14:22.380 --> 14:23.380
每个li里边

14:23.380 --> 14:25.380
有一些内容吧

14:25.380 --> 14:26.380
有些内容

14:26.380 --> 14:29.380
比方说就一个

14:29.380 --> 14:30.380
就一个啥

14:30.380 --> 14:32.380
就一个多了吧

14:32.380 --> 14:33.380
就一些li

14:33.380 --> 14:34.380
有的时候

14:34.380 --> 14:35.380
我们页面上的

14:35.380 --> 14:36.380
有一些元素

14:36.380 --> 14:37.380
它可能会关联到

14:37.380 --> 14:40.380
一个普通的GSE对象

14:40.380 --> 14:42.380
有可能会有这种情况

14:42.380 --> 14:43.380
页面上的每一个元素

14:43.380 --> 14:46.380
它会关联一个普通的GSE对象

14:46.380 --> 14:49.380
比方说我举个例子

14:49.380 --> 14:50.380
这个li

14:50.380 --> 14:52.380
它关联一个对象

14:53.380 --> 14:54.380
关联什么对象呢

14:54.380 --> 14:55.380
它关联对象

14:55.380 --> 14:56.380
这个对象

14:56.380 --> 14:58.380
我们就随便写一个吧

14:58.380 --> 15:01.700
NAM

15:01.700 --> 15:04.700
就是id为1

15:04.700 --> 15:06.700
id为1

15:06.700 --> 15:08.700
NAM为

15:08.700 --> 15:11.700
NAM为姓名1

15:11.700 --> 15:12.700
然后呢

15:12.700 --> 15:13.700
后面就不写了

15:13.700 --> 15:15.700
它会关联这个对象

15:15.700 --> 15:17.700
然后它会关联这个对象

15:17.700 --> 15:18.700
姓名2

15:18.700 --> 15:19.700
它会关联这个对象

15:19.700 --> 15:20.700
姓名3

15:20.700 --> 15:22.700
不用我说了

15:22.700 --> 15:23.700
它每一个li

15:23.700 --> 15:25.700
它会关联一个对象

15:25.700 --> 15:27.700
页面上显示是一回事

15:27.700 --> 15:28.700
我们内部的程序处理

15:28.700 --> 15:30.700
可能会有一个对象跟它相关联

15:30.700 --> 15:31.700
对吧

15:31.700 --> 15:32.700
而且我们有这么一个现象

15:32.700 --> 15:33.700
有可能

15:33.700 --> 15:34.700
就是说这个li

15:34.700 --> 15:35.700
如果存在的话

15:35.700 --> 15:37.700
那么这个对象就应该存在

15:37.700 --> 15:38.700
如果说这个li不存在的话

15:38.700 --> 15:40.700
那么这个对象就应该消失

15:40.700 --> 15:41.700
有这个li

15:41.700 --> 15:42.700
如果说这个li

15:42.700 --> 15:44.700
被垃圾回收器回收掉了

15:44.700 --> 15:45.700
那么我们一个对象存在

15:45.700 --> 15:46.700
也没有意义了

15:46.700 --> 15:48.700
我也应该被垃圾回收器回收掉

15:48.700 --> 15:50.700
那如果说你把这些对象存到

15:50.700 --> 15:51.700
输主里边

15:51.700 --> 15:52.700
那就出问题

15:52.700 --> 15:53.700
输主里边的东西

15:53.700 --> 15:54.700
它一直记录的

15:54.700 --> 15:56.700
哪怕这个li不在了

15:56.700 --> 15:57.700
那么输主里边还在

15:57.700 --> 15:58.700
这个时候

15:58.700 --> 15:59.700
就可以用weekmap

15:59.700 --> 16:00.700
来实现这个功能

16:00.700 --> 16:01.700
你看weekmap

16:01.700 --> 16:02.700
map怎么实现

16:02.700 --> 16:03.700
我们来比方说

16:03.700 --> 16:04.700
举个例子

16:04.700 --> 16:07.700
我们这里得到所有的li

16:07.700 --> 16:09.700
li

16:09.700 --> 16:10.700
拿到所有的li

16:10.700 --> 16:12.700
然后我们用document

16:12.700 --> 16:14.700
curry-select

16:14.700 --> 16:19.070
拿到所有的li

16:19.070 --> 16:21.070
那么我们是不是可以便利这个li

16:21.070 --> 16:22.070
对吧

16:22.070 --> 16:23.070
用for-off循环

16:23.070 --> 16:24.070
每一次循环

16:24.070 --> 16:25.070
就循环出一个li

16:25.070 --> 16:27.070
然后我们把它加到哪去了

16:27.070 --> 16:29.070
加到一个weekmap里边去

16:29.070 --> 16:31.070
weekmap

16:31.070 --> 16:33.070
又一个weekmap

16:33.070 --> 16:34.070
好

16:34.070 --> 16:35.070
每一次循环

16:35.070 --> 16:37.070
我们往weekmap里边加一下

16:37.070 --> 16:38.070
jn是什么呢

16:38.070 --> 16:40.070
我就用li作为键

16:40.070 --> 16:42.070
为什么把li作为键

16:42.070 --> 16:43.070
而不是用把一个

16:43.070 --> 16:44.070
自给你对象作为键呢

16:44.070 --> 16:46.070
因为这个li作为键的话

16:46.070 --> 16:47.070
有个好处

16:47.070 --> 16:48.070
如果说li不在了

16:48.070 --> 16:49.070
它也跟着不在了

16:49.070 --> 16:50.070
它也跟着不在了

16:50.070 --> 16:52.070
所以说我们把li作为键

16:52.070 --> 16:54.070
那么对象就关联到这个后边

16:54.070 --> 16:55.070
它的值就是一个对象

16:55.070 --> 16:57.070
id等于什么

16:57.070 --> 17:00.070
li的inner atml

17:00.070 --> 17:01.070
然后呢

17:01.070 --> 17:02.070
name等于什么呢

17:02.070 --> 17:04.070
姓名

17:04.070 --> 17:05.070
然后呢

17:05.070 --> 17:08.070
拼接上li的inner atml

17:08.070 --> 17:09.070
对吧

17:09.070 --> 17:10.070
好

17:10.070 --> 17:11.070
我们就把它加进去

17:11.070 --> 17:12.070
好

17:12.070 --> 17:13.070
咱们输出看一下

17:13.070 --> 17:16.540
输出看一下这个weekmap

17:16.540 --> 17:17.540
好

17:17.540 --> 17:18.540
你看一下

17:18.540 --> 17:19.540
是不是有三项

17:19.540 --> 17:20.540
对吧

17:20.540 --> 17:21.540
每个li对应一个对象

17:21.540 --> 17:22.540
你看

17:22.540 --> 17:23.540
每个li对应一个对象

17:23.540 --> 17:25.540
你看它里面存的格式

17:25.540 --> 17:26.540
是不是就是我们之前用

17:26.540 --> 17:28.540
手动写书写的那个map的那种格式

17:28.540 --> 17:29.540
对吧

17:29.540 --> 17:31.540
每个li存一个对象

17:31.540 --> 17:32.540
没问题吧

17:32.540 --> 17:33.540
好

17:33.540 --> 17:34.540
那么现在呢

17:34.540 --> 17:36.540
我们首先把这个引用卡去掉

17:36.540 --> 17:39.100
看着啊

17:39.100 --> 17:41.100
我们首先把这个li s

17:41.100 --> 17:42.100
给它去掉

17:42.100 --> 17:43.100
就有天我不用了

17:43.100 --> 17:45.100
把这个引用卡去掉

17:46.100 --> 17:47.100
好

17:47.100 --> 17:48.100
L就是const

17:49.100 --> 17:50.100
好

17:50.100 --> 17:51.100
这个引用去掉

17:51.100 --> 17:52.100
然后你看

17:52.100 --> 17:53.100
它还在

17:53.100 --> 17:54.100
为什么还在呢

17:54.100 --> 17:55.100
那一步还在用它

17:55.100 --> 17:56.100
还用这些对象

17:56.100 --> 17:57.100
因为这个li在页面上

17:57.100 --> 17:58.100
实际上是存在的

17:58.100 --> 17:59.100
那如果有一天

17:59.100 --> 18:00.100
我们把这个li3

18:01.100 --> 18:02.100
delete element

18:02.100 --> 18:03.100
第一个li3

18:03.100 --> 18:04.100
你看着

18:04.100 --> 18:08.100
这个weekmap里边展开

18:10.100 --> 18:11.100
我们在这里吧

18:11.100 --> 18:12.100
代码里边3

18:12.100 --> 18:13.100
因为在调控台的话

18:13.100 --> 18:14.100
有些有些呢

18:14.100 --> 18:15.100
它保留现场

18:16.100 --> 18:17.100
我们在调

18:17.100 --> 18:18.100
在这里面3

18:18.100 --> 18:19.100
这里面3

18:19.100 --> 18:20.100
我们先删除这个li

18:22.100 --> 18:23.100
li s0

18:23.100 --> 18:24.100
remove

18:24.100 --> 18:25.100
在这里3

18:25.100 --> 18:26.100
好

18:26.100 --> 18:27.100
删了过后

18:27.100 --> 18:28.100
我再把这个变量

18:28.100 --> 18:29.100
把这个东西设为NOW

18:29.100 --> 18:30.100
好

18:30.100 --> 18:31.100
那么现在呢

18:31.100 --> 18:32.100
是不是没有任何一个代码

18:32.100 --> 18:33.100
能够找到第一个li

18:33.100 --> 18:34.100
好

18:34.100 --> 18:35.100
咱们看一下

18:35.100 --> 18:36.100
你看到

18:36.100 --> 18:37.100
是不是这里也跟着3了

18:37.100 --> 18:38.100
weekmap里边

18:38.100 --> 18:39.100
是不是跟着3了

18:39.100 --> 18:40.100
它只有两项了

18:40.100 --> 18:41.100
刚才为什么

18:41.100 --> 18:42.100
这里还显示3个

18:42.100 --> 18:43.100
我刚才说了

18:43.100 --> 18:44.100
垃圾回收器

18:44.100 --> 18:45.100
它不是立即回收的

18:45.100 --> 18:46.100
刚才为什么在

18:46.100 --> 18:47.100
控制台里边不行呢

18:47.100 --> 18:48.100
因为控制台

18:48.100 --> 18:49.100
它为了让你调试方便

18:49.100 --> 18:50.100
它要保留很多现场

18:51.100 --> 18:53.100
在代码里面写的话

18:53.100 --> 18:54.100
就会正常的

18:54.100 --> 18:55.100
正常的现象

18:55.100 --> 18:56.100
那么这里呢

18:57.100 --> 18:58.100
你看我把第一个li3了

18:58.100 --> 18:59.100
那么你现在一看

18:59.100 --> 19:01.100
我把这个东西一删

19:01.100 --> 19:02.100
是不是我不可能

19:02.100 --> 19:03.100
从页面上

19:03.100 --> 19:04.100
得到这个动物对象了

19:04.100 --> 19:05.100
我们用document

19:05.100 --> 19:06.100
是不是一定得不到

19:06.100 --> 19:07.100
这个动物对象了

19:07.100 --> 19:08.100
然后我把这个东西

19:08.100 --> 19:09.100
设为NOW

19:09.100 --> 19:10.100
那么设为NOW之后

19:10.100 --> 19:11.100
你看后面有没有

19:11.100 --> 19:12.100
任何一种办法

19:12.100 --> 19:13.100
能够得到之前的li

19:13.100 --> 19:14.100
所以任何一个办法

19:14.100 --> 19:15.100
都得不到

19:15.100 --> 19:16.100
那么得不到过后

19:16.100 --> 19:17.100
它就会发现

19:17.100 --> 19:18.100
大家回收器

19:18.100 --> 19:19.100
发现这个东西

19:19.100 --> 19:20.100
应该回收掉了

19:20.100 --> 19:22.100
于是它把li也回收了

19:22.100 --> 19:23.100
li回收是不是对象

19:23.100 --> 19:24.100
也跟着回收了

19:24.100 --> 19:25.100
因为没有任何东西

19:25.100 --> 19:26.100
可以找到对象了

19:26.100 --> 19:27.100
它也会跟着回收

19:27.100 --> 19:28.100
就这么一回事

19:28.100 --> 19:29.100
你看这是什么

19:29.100 --> 19:31.100
这就是weekmap

19:31.100 --> 19:32.100
weekmap

19:32.100 --> 19:33.100
它如果说

19:33.100 --> 19:34.100
在这么一种场景下面

19:34.100 --> 19:36.100
它可以发挥它的作用

19:36.100 --> 19:38.100
这是关于这一块

19:38.100 --> 19:39.100
同样的

19:39.100 --> 19:41.100
它也是不能便利

19:42.100 --> 19:43.100
它也是一个

19:43.100 --> 19:44.100
不可迭代的

19:44.100 --> 19:46.100
不是一个可迭代的对象

19:46.100 --> 19:47.100
没有三字属性

19:47.100 --> 19:49.100
没有佛一起方法

19:49.100 --> 19:51.100
这就是这两个东西

19:51.100 --> 19:52.100
给大家介绍一下

19:52.100 --> 19:53.100
特别有意思

19:53.100 --> 19:54.100
那么至此

19:54.100 --> 19:56.100
我们本章就学习完了

19:56.100 --> 19:57.100
特别特别的简单

19:57.100 --> 19:58.100
一个set 一个map

19:58.100 --> 19:59.100
至少

19:59.100 --> 20:00.100
我们以后

20:00.100 --> 20:02.100
就多了两种集合类型了

20:02.100 --> 20:03.100
可以使用了

20:03.100 --> 20:04.100
甭管我们平时

20:04.100 --> 20:05.100
多用了少

20:05.100 --> 20:06.100
至少多了一种选择了

20:06.100 --> 20:07.100
对吧

20:07.100 --> 20:08.100
OK

