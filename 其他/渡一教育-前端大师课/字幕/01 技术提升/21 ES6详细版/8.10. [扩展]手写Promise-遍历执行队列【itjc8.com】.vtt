WEBVTT

00:00.180 --> 00:03.460
好 前面的工作呢 我们已经实现了这么一个对立

00:03.460 --> 00:08.180
这些对立里面就包含了我们所有有可能会执行到的函数

00:08.180 --> 00:11.180
对吧 当然也有可能不执行 要根据状态来确定

00:11.180 --> 00:14.780
还有包括了有些函数它本身是undefined 对吧 没法执行

00:14.780 --> 00:17.780
那么这些工作呢 都要去遍地这个对立

00:17.780 --> 00:21.380
然后呢 一个一个拿出来看一下到底该怎么来处理

00:21.380 --> 00:26.180
于是我们在这呢 去抽象这么一个函数 啊 去写这么一个函数

00:26.180 --> 00:29.480
刚才我们之前写过这么一个加到对立的函数 对吧

00:29.480 --> 00:35.480
现在呢 我们去执行对立的函数 叫做rawhandlers

00:35.480 --> 00:42.040
执行对立 不需要产数 根据实际情况

00:42.040 --> 00:46.040
然后执行对立 写出来这么一个函数

00:46.040 --> 00:49.040
当然这个函数呢 比较容易想到的是什么呢

00:49.040 --> 00:52.040
比较容易想到的就是 如果说目前的状态

00:52.040 --> 00:56.040
state 等于什么 等于pending

00:56.040 --> 01:05.040
说明啥 说明目前任务仍在挂起

01:05.040 --> 01:08.040
目前任务还没有结束 对吧 没有成功也没有失败

01:08.040 --> 01:11.040
我都不知道它什么状态 那么这种情况下是无论如何

01:11.040 --> 01:15.040
不可能去执行对立的 看都不会去看它 对不对

01:15.040 --> 01:17.040
那么这种状态 那么直接return

01:17.040 --> 01:20.040
好 那么现在我们想个这么一个问题

01:20.040 --> 01:24.040
这个函数什么时候只调用它 当然函算没写完

01:25.040 --> 01:31.040
这函数什么时候调用它 什么时候 改状态变了要不要调用

01:31.040 --> 01:34.040
比方说你刚才一开始挂起 后来变成功了

01:34.040 --> 01:37.040
那是不是要得来来来看一遍 对不对

01:37.040 --> 01:39.040
要不要调用 肯定要调用

01:39.040 --> 01:42.040
好 于是我们知道这一点之后

01:42.040 --> 01:46.040
我们至少可以在这里 在result里面

01:46.040 --> 01:49.040
在change state里面 是不是状态变了之后

01:49.040 --> 01:52.040
如果说你状态目前已经改变了

01:52.040 --> 01:55.040
那就是啥子不干了 对吧 如果说状态没有改变

01:55.040 --> 01:58.040
这之前是挂起 现在把状态改了

01:58.040 --> 02:01.040
那么改了状态之后 无论你改成成功

02:01.040 --> 02:04.040
还是改成失败 是不是得运行这个对立

02:04.040 --> 02:07.040
对吧 run handlers得运行吧

02:07.040 --> 02:11.040
对吧 状态变化 执行对立

02:11.040 --> 02:14.040
把对立从头到尾看一遍

02:14.040 --> 02:17.040
这没问题吧 那么就描述了什么了

02:17.040 --> 02:21.040
描述了你一秒钟之后变成成功

02:21.040 --> 02:24.040
但是我在一秒钟之前就给他驻车了这些函数了

02:24.040 --> 02:27.040
对立已经形成了 那里成功的时候

02:27.040 --> 02:30.040
改变了状态 改变状态是否要从头到尾看一遍

02:30.040 --> 02:34.040
这是一个时候 那么现在思讨另外一个问题

02:34.040 --> 02:38.040
如果说是智商人代码的 那么没有等待一秒钟

02:38.040 --> 02:42.040
那么我们当我们调用 zin的时候 是不是状态已经确定了

02:42.040 --> 02:45.040
是不是状态已经确定了 这个时候是不是已经成了

02:45.040 --> 02:49.040
状态已经是成功了 那么这个函数加到对立了

02:49.040 --> 02:54.930
比方说我们现在看这种情况 运行

02:54.930 --> 02:57.930
你看状态现在已经成功了 有没有加到对立

02:57.930 --> 03:01.930
加了一个函数 加了一个 undefined 对吧 第二个函数 undefined

03:01.930 --> 03:04.930
那么这个时候 调用 zin的时候 这个时候要不要看

03:04.930 --> 03:07.930
是不是也得看 因此调任方法的时候

03:07.930 --> 03:10.930
有两件事要做 第一件事加到对立里面去

03:10.930 --> 03:14.930
第二件事还是要看一下 那万一现在状态已经确定了呢

03:14.930 --> 03:17.930
所以说 调任方法的时候 在这儿

03:18.930 --> 03:22.930
我们把加到对立里面去 然后同样的也要去调用

03:22.930 --> 03:26.930
你看为什么我要把抽离出去 避免重复弹

03:26.930 --> 03:29.930
而且让每一个函数 结构保持减击

03:29.930 --> 03:32.930
你看我们每一个函数其实代表并不多 就这么几号

03:32.930 --> 03:36.930
这样子的每个单元 其实模细是非常清晰的

03:36.930 --> 03:42.930
然后调用 这个时候就执行对立吧

03:42.930 --> 03:45.930
懂得意思就讲了 好 现在我们所有的

03:45.930 --> 03:48.930
调用时机我们已经确定了 就在这儿

03:48.930 --> 03:52.930
如果说你目前的状态是挂起的 拿我啥的也不看

03:52.930 --> 03:54.930
对立也看都不看

03:54.930 --> 03:57.930
那么现在我们来考虑一下 67 行

03:57.930 --> 04:01.930
如果说现在的状态不是挂起 要么成功 要么失败

04:01.930 --> 04:04.930
那么这个时候是不是要把对立一个一个拿出来看

04:04.930 --> 04:08.930
对吧 那怎么一个一个拿出来看呢

04:08.930 --> 04:11.930
一个循环就搞定了 都要用 4-2 循环

04:12.930 --> 04:14.930
拿到每一个 Handler

04:15.930 --> 04:17.930
注意每个 Handler 是个对象

04:17.930 --> 04:19.930
拿到每一个 Handler 继续循环什么呢

04:19.930 --> 04:21.930
循环 Z 叫 Handlers

04:21.930 --> 04:22.930
所以循环这个数字

04:22.930 --> 04:24.930
当然这个数字有没有可能是空的

04:24.930 --> 04:26.930
当然有可能 那无所谓吧

04:26.930 --> 04:28.930
比方说现在都没有注册进

04:28.930 --> 04:30.930
对吧 那调用一个律作物 要不要执行

04:30.930 --> 04:32.930
要执行 所以要执行

04:32.930 --> 04:35.930
但是现在的数字是空的

04:36.930 --> 04:38.930
你看 Handler 是空的

04:38.930 --> 04:40.930
那空的的话就经不了循环

04:40.930 --> 04:42.930
就经不了循环 那将来又是啥也没做吗

04:42.930 --> 04:45.930
没问题的 这个逻辑都是没问题的

04:45.930 --> 04:50.240
那么现在的对立肯定不是空的了

04:50.240 --> 04:52.240
那么现在我们去循环这个对立

04:52.240 --> 04:55.240
然后一个一个一个对象一个对象拿出来

04:55.240 --> 04:56.240
处理就完事了

04:56.240 --> 04:58.240
那么具体处理每一个对象呢

04:58.240 --> 05:00.240
那又是一个负账的过程

05:00.240 --> 05:02.240
因此我这里再开一个 Handler

05:02.240 --> 05:03.240
别看我 Handler 起来多

05:03.240 --> 05:05.240
其实你可以保持每一个 Handler 的简洁

05:05.240 --> 05:07.240
把注册打好 没有任何问题

05:07.240 --> 05:12.240
就是 Run One Handler

05:12.240 --> 05:14.240
你给我传一个 Handler

05:15.240 --> 05:17.240
这个 Handler 是

05:17.240 --> 05:20.240
这是一个 Object 的对象

05:20.240 --> 05:24.240
处理每一个 Handler

05:24.240 --> 05:26.240
我们循环不就是一个一个拿出来处理吗

05:26.240 --> 05:28.240
处理一个我单独开成一个 Handler

05:28.240 --> 05:30.240
这是我们下几颗要实现的

05:30.240 --> 05:33.240
这不大出事

05:33.240 --> 05:36.240
这边就是调用这个什么

05:36.240 --> 05:40.240
Run Handler

05:40.240 --> 05:44.000
把什么 Handler 传进去

05:44.000 --> 05:45.000
让它去处理

05:45.000 --> 05:46.000
对 我不处理

05:46.000 --> 05:47.000
我只是循环

05:47.000 --> 05:48.000
帮你循环

05:48.000 --> 05:49.000
一个个拿出来

05:49.000 --> 05:51.000
先拿出来第一个交给他来处理

05:51.000 --> 05:52.000
先拿出来第二个交给他来处理

05:52.000 --> 05:53.000
这种思路啊

05:53.000 --> 05:54.000
大家一定要学会

05:54.000 --> 05:56.000
来降低复杂度

05:56.000 --> 05:57.000
不然的话

05:57.000 --> 05:58.000
全部弄在一堆它写出来

05:58.000 --> 05:59.000
大概没法看了个代码

05:59.000 --> 06:00.000
你自己都受不了

06:00.000 --> 06:02.000
这种代码其实非常非常清晰

06:02.000 --> 06:04.000
每一个还是极其简洁

06:04.000 --> 06:06.000
把功能拆分很细

06:06.000 --> 06:07.000
而且由于功能拆分很细的

06:07.000 --> 06:10.000
特别容易复用

06:10.000 --> 06:11.000
好 那么现在

06:11.000 --> 06:12.000
我们还要考虑一个问题

06:12.000 --> 06:13.000
就是个对列

06:13.000 --> 06:14.000
你处理的一个

06:14.000 --> 06:16.000
是不是就应该把删掉

06:16.000 --> 06:18.000
是不是应该删掉

06:18.000 --> 06:19.000
你不删掉的话

06:19.000 --> 06:20.000
会出现什么样的后果

06:20.000 --> 06:21.000
你看现在这个

06:21.000 --> 06:24.000
我改变状态的过后

06:24.000 --> 06:25.000
比方说吧

06:25.000 --> 06:27.000
我这里

06:27.000 --> 06:30.380
set to mode

06:30.380 --> 06:31.380
这样子来处理

06:31.380 --> 06:33.380
resort

06:33.380 --> 06:34.380
一

06:34.380 --> 06:35.380
好 那么现在呢

06:35.380 --> 06:37.380
我再来一个set to mode

06:37.380 --> 06:41.760
再来一个

06:41.760 --> 06:42.760
再来一个什么呢

06:42.760 --> 06:43.760
pro.z

06:43.760 --> 06:45.760
分析

06:45.760 --> 06:47.760
一看一下

06:47.760 --> 06:49.760
我们这里

06:49.760 --> 06:50.760
每一次处理的时候

06:50.760 --> 06:51.760
要打印一下

06:51.760 --> 06:55.710
处理

06:55.710 --> 06:56.710
多好个呢

06:56.710 --> 06:57.710
处理res

06:57.710 --> 07:03.280
handlers.z

07:03.280 --> 07:04.280
然后呢

07:04.280 --> 07:05.280
我们这里

07:05.280 --> 07:06.280
甚至可以把res

07:06.280 --> 07:07.280
handlers

07:07.280 --> 07:08.280
打印出来

07:08.280 --> 07:09.280
好吧

07:09.280 --> 07:10.280
我们在这里呢

07:10.280 --> 07:11.280
用这种方式来处理

07:11.280 --> 07:12.280
所以这样子

07:12.280 --> 07:13.280
会有一个什么样的问题

07:13.280 --> 07:15.280
我这里不输出了

07:15.280 --> 07:17.280
运行

07:17.280 --> 07:18.280
你看

07:18.280 --> 07:19.280
是不是处理到两次

07:19.280 --> 07:20.280
为什么会处理两次

07:20.280 --> 07:21.280
咱们来分析一下

07:21.280 --> 07:22.280
第一次

07:22.280 --> 07:23.280
什么时候处理的

07:23.280 --> 07:24.280
是不是调用任的时候

07:24.280 --> 07:25.280
因为这里要等一会儿才调用

07:25.280 --> 07:26.280
对吧

07:26.280 --> 07:27.280
调用任的时候

07:27.280 --> 07:29.280
是不是要我们要循环便利一次

07:29.280 --> 07:30.280
对吧

07:30.280 --> 07:31.280
他先把这个a1加进去

07:31.280 --> 07:32.280
a1

07:32.280 --> 07:33.280
然后把第二个参数

07:33.280 --> 07:34.280
昂定犯的加进去

07:34.280 --> 07:35.280
是不是有两个函数

07:35.280 --> 07:36.280
在对列里边

07:36.280 --> 07:37.280
好 我就处理到两个函数

07:37.280 --> 07:38.280
调用任的时候

07:38.280 --> 07:39.280
是不是要运行一遍

07:39.280 --> 07:40.280
把这个对列

07:41.280 --> 07:43.280
这个同学们

07:43.280 --> 07:45.280
还不是调用任的时候

07:45.280 --> 07:47.280
调用resolve的时候

07:47.280 --> 07:48.280
因为调用任的时候

07:48.280 --> 07:49.280
现在还是平定

07:49.280 --> 07:50.280
还是平定状态

07:50.280 --> 07:51.280
他不会处理的

07:51.280 --> 07:52.280
那么调用resolve的时候

07:52.280 --> 07:53.280
是不是要处理一次

07:53.280 --> 07:55.280
他看到对列里面有两个东西

07:55.280 --> 07:56.280
那么我们这里的

07:56.280 --> 07:58.280
循环两次处理

07:58.280 --> 08:00.280
接下来

08:00.280 --> 08:01.280
下一个碳冒着的时间

08:01.280 --> 08:02.280
到了之后

08:02.280 --> 08:03.280
我又调用了任

08:03.280 --> 08:04.280
那么这个时候

08:04.280 --> 08:05.280
状态是不是已经完成了

08:05.280 --> 08:06.280
那么调用任的时候

08:06.280 --> 08:07.280
他也要处理

08:07.280 --> 08:08.280
调用任的时候

08:08.280 --> 08:09.280
又处理

08:09.280 --> 08:10.280
是不是要处理四个

08:10.280 --> 08:11.280
之前的A1

08:11.280 --> 08:12.280
还有Andy Fand

08:12.280 --> 08:14.280
还有现在的新的A2

08:14.280 --> 08:15.280
和Andy Fand

08:15.280 --> 08:16.280
说明啥

08:16.280 --> 08:17.280
我一绕了半天说明啥

08:17.280 --> 08:18.280
说明我每处理一个

08:18.280 --> 08:20.280
要把之前的杆删掉

08:21.280 --> 08:22.280
处理一个就删一个

08:22.280 --> 08:23.280
说这件事

08:23.280 --> 08:25.280
你理解清楚了就好做了

08:25.280 --> 08:26.280
那怎么来删呢

08:26.280 --> 08:28.280
是不是可以通过

08:28.280 --> 08:32.280
thisHandlersShift

08:32.280 --> 08:34.280
删除第一个

08:34.280 --> 08:36.280
你看我这里处理完

08:36.280 --> 08:37.280
第一个就走了

08:37.280 --> 08:38.280
不要了

08:38.280 --> 08:40.280
那这样子行吗

08:40.280 --> 08:42.280
这样子肯定不行

08:42.280 --> 08:43.280
都是一个小细节

08:43.280 --> 08:44.280
这个刀不是什么

08:44.280 --> 08:46.280
多复杂的事情

08:46.280 --> 08:47.280
你看吧

08:47.280 --> 08:49.280
比方说我这里写个数字

08:49.280 --> 08:50.280
L2

08:50.280 --> 08:53.280
这里写个1,2,3,4,5

08:53.280 --> 08:54.280
来吧

08:54.280 --> 08:55.280
比方说我这里

08:55.280 --> 08:56.280
用for2的循环

08:56.280 --> 08:57.280
去循环它

08:57.280 --> 08:58.280
循环的时候

08:58.280 --> 08:59.280
每循环一次

08:59.280 --> 09:00.280
我输出一下它

09:00.280 --> 09:02.280
然后再删一个

09:02.280 --> 09:03.280
最后

09:03.280 --> 09:05.280
应该是把这个数字删完

09:05.280 --> 09:06.280
对不对

09:06.280 --> 09:07.280
第一个拿到

09:07.280 --> 09:08.280
第二个拿到

09:08.280 --> 09:09.280
用完就删了

09:09.280 --> 09:10.280
所以应该把个数字删完

09:10.280 --> 09:11.280
那么最后

09:11.280 --> 09:12.280
我们输出一下的数字

09:12.280 --> 09:14.280
看一下有没有删完

09:14.280 --> 09:15.280
因为发现没有删完

09:15.280 --> 09:17.280
那么到底是怎么回事的

09:17.280 --> 09:20.280
这其实是一个非常基础的问题

09:20.280 --> 09:22.280
比方说

09:22.280 --> 09:31.480
现在呢

09:31.480 --> 09:32.480
好

09:32.480 --> 09:33.480
那么比方说

09:33.480 --> 09:34.480
我们循环要第一个

09:34.480 --> 09:35.480
第一个

09:35.480 --> 09:37.480
它目前是这样子的

09:37.480 --> 09:38.480
它那个for2的循环

09:38.480 --> 09:40.480
是一个一个便利的

09:40.480 --> 09:45.130
它便利到第一个

09:45.130 --> 09:48.440
然后我把第一个赶删了

09:48.440 --> 09:49.440
接下来

09:49.440 --> 09:50.440
由于现在

09:50.440 --> 09:51.440
第一个删了过后

09:51.440 --> 09:52.440
它就导致

09:52.440 --> 09:54.440
它目前就指向这个了

09:54.440 --> 09:55.440
懂了意思吧

09:55.440 --> 09:57.440
它目前就指向这个了

09:57.440 --> 09:58.440
你把第一个删了

09:58.440 --> 09:59.440
删了过后

09:59.440 --> 10:00.440
你现在去

10:00.440 --> 10:01.440
你现在

10:01.440 --> 10:02.440
刚才本来是指向1的

10:02.440 --> 10:04.440
你现在指向这个了

10:04.440 --> 10:06.440
那么在下一个的时候

10:06.440 --> 10:07.440
下一个的时候

10:07.440 --> 10:08.440
下一次循环

10:08.440 --> 10:09.440
它就挑过2了

10:09.440 --> 10:10.440
于是

10:10.440 --> 10:11.440
它现在就指向3了

10:11.440 --> 10:13.440
所以你会发现

10:13.440 --> 10:14.440
一输出完了过

10:14.440 --> 10:15.440
就输出几

10:15.440 --> 10:16.440
一输出完了过后

10:16.440 --> 10:17.440
就输出3

10:17.440 --> 10:18.440
因为它2就略过了

10:18.440 --> 10:19.440
知道吧

10:19.440 --> 10:21.440
它有这么一个问题存在

10:21.440 --> 10:23.440
那么输出3过后

10:23.440 --> 10:24.440
它又删出第一个

10:24.440 --> 10:25.440
然后它就删出一删

10:25.440 --> 10:26.440
又把这个2删了

10:26.440 --> 10:28.440
懂了意思吧

10:28.440 --> 10:29.440
然后2删了过后

10:29.440 --> 10:30.440
3又跑前面去了

10:30.440 --> 10:32.440
那么它本来是指向3的

10:32.440 --> 10:34.440
结果它现在指向4了

10:34.440 --> 10:36.440
然后再下一次循环

10:36.440 --> 10:37.440
下一次循环

10:37.440 --> 10:39.440
又输出了5

10:39.440 --> 10:40.440
这里又输出了5

10:40.440 --> 10:41.440
然后又删出第一个

10:41.440 --> 10:42.440
它又把3删了

10:42.440 --> 10:43.440
所以最后删出5

10:43.440 --> 10:44.440
但是输出的是1删5

10:44.440 --> 10:45.440
我记得它这个玩意

10:45.440 --> 10:47.440
还可以出面是提的

10:47.440 --> 10:49.440
它就变成这么一个样子了

10:49.440 --> 10:51.440
因此怎么来处理这个问题呢

10:51.440 --> 10:52.440
就是我一个一个看

10:52.440 --> 10:54.440
看完了过后就3

10:54.440 --> 10:55.440
其实非常简单

10:55.440 --> 10:57.440
你写这样子写

10:57.440 --> 11:00.440
你写这么一个英德克诗

11:00.440 --> 11:02.440
就不用写英德克诗

11:02.440 --> 11:05.440
我就直接看你第1个

11:05.440 --> 11:06.440
AR0

11:06.440 --> 11:08.440
就看你第1项

11:08.440 --> 11:09.440
我一个一个拿

11:09.440 --> 11:10.440
什么一个拿

11:10.440 --> 11:11.440
就拿第1项

11:11.440 --> 11:12.440
永远只拿第1项

11:12.440 --> 11:14.440
第1项有东西吗

11:14.440 --> 11:16.440
有东西说明了

11:16.440 --> 11:18.440
我现在还没有循环

11:18.440 --> 11:19.440
你这个输出还有东西

11:19.440 --> 11:21.440
有东西我就拿第1项

11:21.440 --> 11:22.440
拿第1项的时候

11:22.440 --> 11:23.440
我干嘛呢

11:23.440 --> 11:26.440
我输出第1项

11:26.440 --> 11:28.440
然后怎么样

11:28.440 --> 11:30.440
Shift3掉

11:30.440 --> 11:32.440
那现在就没问题了

11:32.440 --> 11:33.440
你看

11:33.440 --> 11:34.440
进行了

11:34.440 --> 11:35.440
是吧

11:35.440 --> 11:36.440
每一项都变得到了

11:36.440 --> 11:37.440
同时把全都删完了

11:37.440 --> 11:38.440
你看

11:38.440 --> 11:40.440
拿输出的第1项

11:40.440 --> 11:41.440
拿出来输出

11:41.440 --> 11:43.440
输出完了过去删掉

11:43.440 --> 11:44.440
删掉了

11:44.440 --> 11:45.440
那下一次循环

11:45.440 --> 11:46.440
是不是还是取得第1项

11:46.440 --> 11:47.440
这就是一个

11:47.440 --> 11:49.440
遍地同时删除了

11:49.440 --> 11:50.440
这么一个做法

11:50.440 --> 11:51.440
好

11:51.440 --> 11:52.440
那么我们知道

11:52.440 --> 11:53.440
这个做法之后

11:53.440 --> 11:54.440
到这边

11:54.440 --> 11:55.440
那就非常简单了

11:55.440 --> 11:56.440
我就不用放二个循环

11:56.440 --> 11:57.440
用Wild

11:57.440 --> 11:58.440
循环循环

11:58.440 --> 11:59.440
Handlers

11:59.440 --> 12:00.440
第1项

12:00.440 --> 12:01.440
但是第1项

12:01.440 --> 12:02.440
如果一开始就没有的话

12:02.440 --> 12:03.440
一开始就进不了循环

12:03.440 --> 12:04.440
就结束了

12:04.440 --> 12:05.440
好

12:05.440 --> 12:06.440
那么我们这里呢

12:06.440 --> 12:07.440
首先第1步

12:07.440 --> 12:08.440
运行这个

12:08.440 --> 12:10.440
然后再运行

12:11.440 --> 12:12.440
续步完成了

12:12.440 --> 12:13.440
现在我们看一下

12:13.440 --> 12:14.440
我们用一项

12:14.440 --> 12:15.440
删一项

12:15.440 --> 12:17.440
那么得到一个结果是什么呢

12:17.440 --> 12:18.440
运行

12:20.440 --> 12:21.440
这里

12:21.440 --> 12:22.440
应该是

12:22.440 --> 12:23.440
得到一下吧

12:23.440 --> 12:24.440
Handlers

12:28.440 --> 12:29.440
运行

12:30.440 --> 12:32.440
一开始我们处理的是A1

12:32.440 --> 12:33.440
处理一项就删一项

12:33.440 --> 12:35.440
处理一项就删一项

12:35.440 --> 12:36.440
所以说

12:36.440 --> 12:37.440
在加对立的时候

12:37.440 --> 12:39.440
是不是就加到A2

12:39.440 --> 12:40.440
第二个Handlers

12:40.440 --> 12:41.440
之前就没了

12:41.440 --> 12:43.440
所以我们保证每一个函数

12:43.440 --> 12:45.440
它只会运行一次

12:45.440 --> 12:47.440
不会重复的运行

12:47.440 --> 12:49.440
就这么一个处理

12:49.440 --> 12:50.440
那么就完事了

12:50.440 --> 12:52.440
我们这一刻就实现这么一个东西

12:52.440 --> 12:53.440
就是

12:54.440 --> 12:55.440
在运行的时候

12:55.440 --> 12:57.440
就是一个一个便利

12:57.440 --> 12:58.440
那么但是要注意

12:58.440 --> 12:59.440
用一个就删一个

12:59.440 --> 13:00.440
用一个就删一个

13:00.440 --> 13:02.440
那么具体每一个

13:02.440 --> 13:04.440
现在最后一个点了

13:04.440 --> 13:05.440
每一个怎么办

13:05.440 --> 13:07.440
你这一个玩要搞定的就没事了

13:07.440 --> 13:08.440
就完事了

13:08.440 --> 13:09.440
所以我们一点点分解

13:09.440 --> 13:11.440
一点点分解就可以做到这个样子了

13:11.440 --> 13:13.440
好 这是我们下期可能内容

