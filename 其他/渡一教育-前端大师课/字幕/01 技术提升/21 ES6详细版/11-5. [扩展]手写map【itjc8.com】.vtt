WEBVTT

00:00.690 --> 00:03.490
还是老国籍 咱们这一块熟悉一个Map

00:03.490 --> 00:06.990
当然前面跟大家说的是

00:06.990 --> 00:10.190
我们熟悉的Map跟它底层的实现

00:10.190 --> 00:12.190
肯定是不一样的

00:12.190 --> 00:14.690
因为我们不能雕用它的底层代码

00:14.690 --> 00:17.390
但是我们通过熟悉Map

00:17.390 --> 00:19.190
可以多点大家的程序思维

00:19.190 --> 00:21.990
首先还是建立这么一个文件

00:21.990 --> 00:24.490
叫Map.js

00:24.490 --> 00:28.190
同样我们在这里建立一个测试的文件

00:28.390 --> 00:31.490
来测试我们的写的.js 有没有问题

00:31.490 --> 00:33.990
这是Map

00:33.990 --> 00:35.590
我们下面测试

00:35.590 --> 00:37.390
我们之前说过 咱们Map

00:37.390 --> 00:39.690
要创建Map是要通过构造函数

00:39.690 --> 00:42.190
OK 我们这里可以写这么一个内

00:42.190 --> 00:43.590
Map

00:43.590 --> 00:44.990
写这么一个内

00:44.990 --> 00:46.390
这就是个构造函数

00:46.390 --> 00:48.690
我们这里创建一个Map

00:48.690 --> 00:51.090
留一个Map

00:51.090 --> 00:53.190
好 这里边可以传参数

00:53.190 --> 00:54.490
是不是也可以不传

00:54.490 --> 00:56.790
这里边可以传可以不传

00:56.890 --> 01:00.190
那么如果说你要传的话

01:00.190 --> 01:01.690
我写了个构造函数

01:01.690 --> 01:02.890
如果说你不传的话

01:02.890 --> 01:04.090
那么我们这里的参数

01:04.090 --> 01:06.690
可以给它一个默认值aturable

01:06.690 --> 01:08.690
默认值就为一个空数组

01:08.690 --> 01:09.890
如果说你要传的话

01:09.890 --> 01:12.290
自然而然你要传一个数组进来

01:12.290 --> 01:13.190
对不对

01:13.190 --> 01:14.190
OK

01:14.190 --> 01:15.390
好 那么这里

01:15.390 --> 01:17.890
跟之前的set就不太一样了

01:17.890 --> 01:19.690
当然我们也可以先去

01:19.690 --> 01:21.490
干嘛先去跟之前一样

01:21.490 --> 01:23.190
先去做这么一个验证

01:23.190 --> 01:25.890
验证了是否是可以迭代的对象

01:25.990 --> 01:27.990
先来做这么一个验证

01:27.990 --> 01:29.990
如果说你给我的這個ator

01:29.990 --> 01:31.290
它不是一个可迭代对象的话

01:31.290 --> 01:33.590
那么我们就给你报一个错误

01:33.590 --> 01:34.590
好 那么现在呢

01:34.590 --> 01:35.990
单码到了第八行

01:35.990 --> 01:37.190
是不是这个ator

01:37.190 --> 01:39.190
它已经是一个可

01:39.190 --> 01:40.790
就这里写错了

01:40.790 --> 01:42.890
aturable

01:42.890 --> 01:43.990
aturable

01:43.990 --> 01:45.090
那么你这个东西

01:45.090 --> 01:46.790
它已经是一个可迭代对象了

01:46.790 --> 01:47.990
那么我们要怎么办

01:47.990 --> 01:49.290
是不是循环它

01:49.290 --> 01:50.990
用forO5循环它

01:50.990 --> 01:53.090
循环这个aturable

01:53.090 --> 01:55.490
循环这个东西

01:55.490 --> 01:58.790
然后每一次循环的结果

01:58.790 --> 02:00.490
是不是每一次循环的结果

02:00.490 --> 02:02.690
仍然得是一个可迭代对象

02:02.690 --> 02:03.390
对吧

02:03.390 --> 02:07.990
item也得是一个可迭代对象

02:07.990 --> 02:09.290
所以必须要这么做

02:09.290 --> 02:09.690
对吧

02:09.690 --> 02:11.590
它也必须要是一个可迭代对象

02:11.590 --> 02:13.390
如果说它不是一个可迭代对象的话

02:13.390 --> 02:14.690
是不是也要出问题

02:14.690 --> 02:14.890
对吧

02:14.890 --> 02:15.890
也要出问题

02:15.890 --> 02:17.890
那么这里咱们验证一下

02:17.890 --> 02:18.390
验证一下

02:18.390 --> 02:19.790
它是不是一个可迭代对象

02:19.790 --> 02:20.490
好 来吧

02:20.490 --> 02:20.990
来验证

02:20.990 --> 02:21.690
怎么验证呢

02:21.690 --> 02:22.990
还是不一样的

02:22.990 --> 02:24.990
如果说type of

02:24.990 --> 02:27.990
这个item

02:27.990 --> 02:28.390
什么呢

02:28.390 --> 02:29.290
symbol

02:29.290 --> 02:30.890
iterator

02:30.890 --> 02:31.790
不等于

02:31.790 --> 02:33.490
当然你这个东西还可以抽象成

02:33.490 --> 02:35.090
一个函数来帮你验证

02:35.090 --> 02:35.390
对吧

02:35.390 --> 02:36.890
验证它是不是可迭代的

02:36.890 --> 02:38.490
那么如果说它不是可迭代的

02:38.490 --> 02:41.090
那么又一个type error

02:41.090 --> 02:41.790
说它呢

02:41.790 --> 02:44.690
就说你提供的

02:44.690 --> 02:45.290
提供了什么呢

02:45.290 --> 02:48.490
提供的这个item

02:48.490 --> 02:52.690
不是一个可迭代的对象

02:52.690 --> 02:54.490
我们之前遇到的错误是不是也是这个错误

02:54.490 --> 02:54.790
对吧

02:54.790 --> 02:56.590
它也得是一个可迭代的

02:56.590 --> 02:56.790
好

02:56.790 --> 02:59.290
那么如果说它是能迭代的的话

02:59.290 --> 03:00.990
我们是不是要把它第一项

03:00.990 --> 03:02.590
第一个迭代值取出来

03:02.590 --> 03:04.590
和第二个迭代值取出来

03:04.590 --> 03:04.890
对吧

03:04.890 --> 03:06.790
那怎么来取第一个和第二个呢

03:06.790 --> 03:08.190
怎么来取第一个和第二个呢

03:08.190 --> 03:08.390
好

03:08.390 --> 03:09.290
我们就这样去

03:09.290 --> 03:11.090
你不是一个可迭代对象吗

03:11.090 --> 03:11.990
那我调用这个函数

03:11.990 --> 03:13.990
是不是可以得到一个迭代器

03:13.990 --> 03:14.390
对吧

03:14.390 --> 03:15.890
可以得到一个迭代器

03:15.890 --> 03:17.190
const

03:17.190 --> 03:17.890
iter

03:17.890 --> 03:18.790
rater

03:18.790 --> 03:20.390
是不是可以得到一个迭代器

03:20.390 --> 03:21.490
那么这个迭代器呢

03:21.490 --> 03:24.190
我们第一次调用它的next

03:24.190 --> 03:26.790
调用它的next

03:26.790 --> 03:27.590
然后第二什么

03:27.590 --> 03:28.190
value

03:28.190 --> 03:28.990
是不是可能拿到它

03:28.990 --> 03:30.990
它第一个值就是j

03:30.990 --> 03:32.290
这是不是可以拿到j

03:32.290 --> 03:33.090
然后呢

03:33.090 --> 03:36.090
可以通过这个iterator

03:36.090 --> 03:38.490
顺便就把之前的知识复习一下

03:38.490 --> 03:39.390
调用next

03:39.390 --> 03:40.190
是不是在点value

03:40.190 --> 03:40.990
可以拿到它的值

03:40.990 --> 03:41.290
对吧

03:41.290 --> 03:43.690
这样子是不是把j和值拿到了

03:43.690 --> 03:45.390
如果说它是一个数组

03:45.390 --> 03:47.990
第一次迭代是不是得到数组的第一下

03:47.990 --> 03:48.790
它有两个属性

03:48.790 --> 03:49.490
一个value

03:49.490 --> 03:50.390
一个stun

03:50.390 --> 03:51.190
那么第二次迭代

03:51.190 --> 03:52.290
是不是得到数组的第二下

03:52.290 --> 03:53.490
总之得到前两下

03:53.490 --> 03:54.990
后边我不要了

03:54.990 --> 03:56.190
你不能假设它是数组

03:56.190 --> 03:57.590
你鬼照它是什么东西

03:57.590 --> 04:00.190
所以说你不能用什么护循环

04:00.190 --> 04:01.390
那么现在搞定了

04:01.390 --> 04:02.590
k和value得到了

04:02.590 --> 04:03.690
得到了之后

04:03.690 --> 04:05.390
就是你千万不能这样去做

04:05.390 --> 04:07.090
你千万不能什么item0

04:07.090 --> 04:07.890
这种解放来了

04:07.890 --> 04:09.290
这种情况只针对数组的

04:09.290 --> 04:09.890
对吧

04:09.890 --> 04:11.490
那这里不一定是数组

04:11.490 --> 04:12.990
只要是可迭代的就行

04:12.990 --> 04:14.690
那么这里把kvalue拿到了

04:14.690 --> 04:15.690
拿到之后

04:15.690 --> 04:18.290
我们是不是要调用它自己的一个方法

04:18.290 --> 04:19.390
它自己一个什么方法

04:19.390 --> 04:20.790
是不是set方法

04:20.790 --> 04:21.990
set方法把key传进去

04:21.990 --> 04:22.690
把value传进去

04:22.690 --> 04:23.590
不就完了吗

04:23.590 --> 04:24.890
因此我们这里的问题

04:24.890 --> 04:26.490
是不是又转换成了

04:26.490 --> 04:27.790
使用set方法了

04:27.790 --> 04:28.090
对吧

04:28.090 --> 04:29.390
要输写set方法

04:29.390 --> 04:31.790
你要写个key value

04:31.790 --> 04:32.890
这么一个方法

04:32.890 --> 04:33.090
好

04:33.090 --> 04:34.490
这个方法干嘛呢

04:34.490 --> 04:38.490
这个方法其实就是往这个集合里面加一项

04:38.490 --> 04:38.890
对不对

04:38.890 --> 04:39.490
加一项

04:39.490 --> 04:40.290
它的t是啥

04:40.290 --> 04:40.990
它的value是啥

04:40.990 --> 04:42.190
是不是加一项

04:42.190 --> 04:42.390
好

04:42.390 --> 04:43.990
那么我们首先要在这里边

04:43.990 --> 04:45.790
用一个东西来保存一下

04:45.790 --> 04:46.990
来保存一下

04:46.990 --> 04:47.890
比方说我们这里的

04:47.890 --> 04:49.090
用data是

04:49.090 --> 04:50.690
还是个数组

04:50.690 --> 04:53.590
这个数组里边可以用来进行保存

04:53.590 --> 04:55.390
那么这里怎么去加一项呢

04:55.390 --> 04:56.090
其实很简单

04:56.090 --> 04:58.290
就是往这个数组里边铺写一个

04:58.290 --> 04:58.990
铺写一个什么

04:58.990 --> 05:00.290
铺写一个对象

05:00.290 --> 05:02.690
这个对象的属性key

05:02.690 --> 05:03.990
就得用这个key的值

05:03.990 --> 05:05.290
这个属性的value

05:05.290 --> 05:06.590
就得用这个value的值

05:06.590 --> 05:08.290
就加这么一个对象

05:08.290 --> 05:09.790
属性名为key

05:09.790 --> 05:10.690
它的值是什么

05:10.690 --> 05:11.790
是key的值

05:11.790 --> 05:12.690
属性名为什么

05:12.690 --> 05:14.690
value它的值是value的值

05:14.690 --> 05:15.590
是不是加一下

05:15.590 --> 05:17.290
但是不是一定要加的对吧

05:17.290 --> 05:19.290
不是说不是一定要加

05:19.390 --> 05:22.990
如果说

05:22.990 --> 05:26.890
我这里边已经有了key了

05:26.890 --> 05:28.490
是不是已经有这个值了

05:28.490 --> 05:29.590
已经有这个键了

05:29.590 --> 05:30.990
我干吗呢

05:30.990 --> 05:32.590
我干吗呢

05:32.590 --> 05:34.790
如果说它已经有这个键了

05:34.790 --> 05:38.490
我是不是要去从数组里边去找到

05:38.490 --> 05:40.990
它对应的值

05:40.990 --> 05:42.590
然后还要修改

05:42.590 --> 05:44.590
这是不是要进行修改

05:44.590 --> 05:45.490
如果它已经有这个键

05:45.490 --> 05:46.490
要进行修改

05:46.490 --> 05:48.590
如果说没有的情况下

05:48.690 --> 05:50.690
我们是不是才进行添加

05:50.690 --> 05:52.890
对吧

05:52.890 --> 05:54.890
那么现在问题又转换了

05:54.890 --> 05:56.090
存这里的问题了

05:56.090 --> 05:58.290
就是我要判断它到底有没有这个键

05:58.290 --> 05:58.690
ok

05:58.690 --> 06:00.890
我们现在又去写这个方法key

06:00.890 --> 06:02.290
你看都是一串一串来的这个

06:02.290 --> 06:03.990
就是问题都是一串来发生的

06:03.990 --> 06:06.490
那么我们就一次去写就完成了

06:06.490 --> 06:09.190
那么到底有没有这个键呢

06:09.190 --> 06:11.890
有没有这个键呢跟我传进来的

06:11.890 --> 06:12.890
那么这种怎么办呢

06:12.890 --> 06:16.490
是不是循环 for of obj

06:16.490 --> 06:17.990
或者是用这个item

06:18.090 --> 06:20.090
那么我习惯上有item

06:20.090 --> 06:22.890
这里用这个就是z

06:22.890 --> 06:25.490
data 是不是变例这个数组

06:25.490 --> 06:27.490
从数组里面一向一向拿出来看

06:27.490 --> 06:28.490
看一下啥呢

06:28.490 --> 06:30.490
看一下这个item的key

06:30.490 --> 06:33.090
和这个key是不是一样的

06:33.090 --> 06:34.090
那么怎么来看呢

06:34.090 --> 06:37.790
是不是又要用到之前的我们写的这个函数

06:37.790 --> 06:40.990
就是判断两个数据是不是相等

06:40.990 --> 06:42.290
对吧 要用到这个函数

06:42.290 --> 06:43.390
复制过来

06:43.390 --> 06:45.590
那么如果说两个字的原因就是

06:45.590 --> 06:46.590
如果说其他情况

06:46.590 --> 06:48.290
那就用obj一直来判断

06:48.290 --> 06:49.490
那么我们这里就判断

06:49.490 --> 06:50.190
判断什么呢

06:50.190 --> 06:51.790
item

06:51.790 --> 06:52.590
这是个对象对吧

06:52.590 --> 06:54.090
存在数组里面是一个一个的对象

06:54.090 --> 06:56.190
你看我们每次往数组里面加的时候

06:56.190 --> 06:58.890
是一个对象 有key属性 有value属性

06:58.890 --> 07:01.890
看这个对象的key属性

07:01.890 --> 07:02.990
我们要用这个z

07:02.990 --> 07:04.690
e is equal

07:04.690 --> 07:06.790
看是不是相等的

07:06.790 --> 07:08.790
看一下这个对象的key属性

07:08.790 --> 07:10.790
和一个传进的key属性

07:10.790 --> 07:11.990
是不是一样的

07:11.990 --> 07:13.590
如果说是一样的话

07:13.590 --> 07:14.290
是不是找到了

07:14.990 --> 07:17.190
否则的话就没有找到 返回force

07:17.190 --> 07:19.590
那么这样子我就把height写完了

07:19.590 --> 07:21.690
你看 你看到吗

07:21.690 --> 07:24.390
好 那么现在我们再回到这里来做修改

07:24.390 --> 07:25.890
因为是扩展课程

07:25.890 --> 07:27.790
是面向的是基础比较好的同学

07:27.790 --> 07:30.590
所以说我这里就讲的比较快一点

07:30.590 --> 07:33.890
我不可能回过头去讲什么循环这些东西

07:33.890 --> 07:36.990
那么这里如果说有得到了这个件

07:36.990 --> 07:38.990
那么我们这里要做修改

07:38.990 --> 07:41.290
那么修改怎么修改

07:41.290 --> 07:42.890
怎么修改呢

07:42.990 --> 07:45.890
是不是就是找到这个对象

07:45.890 --> 07:47.690
是不是找到那个相应的对象

07:47.690 --> 07:50.190
然后把它的value 只给它改一下

07:50.190 --> 07:51.090
是不是就完了

07:51.090 --> 07:52.690
这就是在做修改

07:52.690 --> 07:53.890
对吧 找到这个对象

07:53.890 --> 07:56.190
把它的value 只改一下

07:56.190 --> 07:58.190
好 来吧 我们来找这个对象

07:58.190 --> 08:00.590
找这个对象我们怎么找呢

08:00.590 --> 08:02.390
我们也可以专门来写个函数

08:02.390 --> 08:03.890
来辅助我们查找

08:03.890 --> 08:04.590
我们这里

08:04.590 --> 08:06.590
因为我是怎么想的呢

08:06.590 --> 08:08.990
如果说我在这里再去写个forl5循环

08:08.990 --> 08:09.790
去循环它

08:09.790 --> 08:12.290
那么这个代码跟这里就差不多重复了

08:12.290 --> 08:14.590
所以说我想到了

08:14.590 --> 08:17.990
得到这么一个就是

08:17.990 --> 08:19.790
写这么一个内部的函数

08:19.790 --> 08:23.390
get obj

08:23.390 --> 08:25.190
根据一个key值

08:25.190 --> 08:27.190
根据一个key值来从数组里面

08:27.190 --> 08:29.990
找到数组里的意象

08:29.990 --> 08:32.190
根据key值

08:32.190 --> 08:39.590
从内部数组中找到对应的数主项

08:39.590 --> 08:41.390
那么这个代码就是很简单

08:41.490 --> 08:43.190
写法就跟这个写法差不多

08:43.190 --> 08:44.890
那么这里返回了就不再sq了

08:44.890 --> 08:45.690
返回的是什么

08:45.690 --> 08:47.390
item 把这个item返回

08:47.390 --> 08:48.390
那么这里的返回什么

08:48.390 --> 08:50.090
undefend 当然也可以不写

08:50.090 --> 08:50.990
不写的话

08:50.990 --> 08:53.390
没找到 下去返回undefend

08:53.390 --> 08:55.390
看 是不是这样子写了

08:55.390 --> 08:56.190
get obj

08:56.190 --> 08:57.890
那么有了这个函数辅助之后

08:57.890 --> 08:59.990
这个height函数是不是可以改了

08:59.990 --> 09:01.290
对吧 是不是可以改了

09:01.290 --> 09:02.090
好 来吧

09:02.090 --> 09:02.790
我们看一下

09:02.790 --> 09:03.890
item

09:03.890 --> 09:05.790
get obj

09:05.790 --> 09:06.990
把key值传进去

09:06.990 --> 09:08.090
是不是得到这个对象

09:08.090 --> 09:09.690
如果说

09:09.690 --> 09:10.790
我这里就返回了

09:10.790 --> 09:15.690
返回这个item是不是不等于undefend

09:15.690 --> 09:16.290
对吧

09:16.290 --> 09:17.190
返回的是这个东西

09:17.190 --> 09:18.790
返回的是不是不等于undefend

09:18.790 --> 09:19.590
就返回它就完事了

09:19.590 --> 09:21.990
或者说我们就直接把表达是返回

09:21.990 --> 09:22.890
不等于undefend

09:22.890 --> 09:23.890
如果不等于undefend

09:23.890 --> 09:24.990
相当于是找到了

09:24.990 --> 09:25.690
等于undefend

09:25.690 --> 09:27.590
就相当于是没有找到

09:27.590 --> 09:30.090
这个height就不用避免重复代

09:30.090 --> 09:32.490
一切都是为了避免重复代

09:32.490 --> 09:34.190
就写出来这么一个内部函数

09:34.190 --> 09:35.290
因为这个内部函数过后

09:35.290 --> 09:36.690
要做修改就特别容易了

09:36.690 --> 09:38.290
要做修改怎么做修改

09:38.290 --> 09:39.990
首先我得到这个件

09:39.990 --> 09:42.590
得到这个就是得到这个就是值

09:42.590 --> 09:43.190
this height

09:43.190 --> 09:45.290
当然这里也可以这样判断

09:45.290 --> 09:49.990
这样判断比方说obj

09:49.990 --> 09:54.290
this getobj key

09:54.290 --> 09:54.890
key传进去

09:54.890 --> 09:55.590
得到这个对象

09:55.590 --> 09:57.190
得到输出里面相应的对象

09:57.190 --> 09:58.090
来判断一下

09:58.090 --> 10:02.790
这个对象如果说不等于undefend

10:02.790 --> 10:05.390
或者说这个对象没有值

10:05.390 --> 10:06.590
这个对象没有值

10:06.590 --> 10:09.190
没有值的话是不是做修改

10:09.690 --> 10:10.990
这个对象有值

10:10.990 --> 10:12.590
有值的话是不是做修改

10:12.590 --> 10:14.190
有值就做修改

10:14.190 --> 10:14.990
修改做什么呢

10:14.990 --> 10:17.190
修改就是把这个obj的value

10:17.190 --> 10:18.290
改一下改成什么

10:18.290 --> 10:19.490
改成这个value

10:19.490 --> 10:20.790
不就修改了吗

10:20.790 --> 10:21.590
对吧

10:21.590 --> 10:22.990
输主里面存的是什么

10:22.990 --> 10:24.690
输主里面存的就是这么一个东西

10:24.690 --> 10:26.590
这是个输主

10:26.590 --> 10:28.190
就是我们内部的实现里边

10:28.190 --> 10:29.890
有个输主key

10:29.890 --> 10:31.390
就是保存什么件

10:31.390 --> 10:33.490
这个件可以是任何类型

10:33.490 --> 10:34.290
value

10:34.290 --> 10:35.090
保他的值

10:35.090 --> 10:36.990
值可以是任何类型

10:36.990 --> 10:38.590
那么就全是这种东西

10:38.590 --> 10:41.890
这输主里面全部保存这种东西

10:41.890 --> 10:44.390
全部保存这种东西

10:44.390 --> 10:45.290
看啊

10:45.290 --> 10:46.490
全部保存它

10:46.490 --> 10:48.790
那么如果说我要在set的时候

10:48.790 --> 10:49.990
如果说我先去查到的

10:49.990 --> 10:50.890
查到这个对象

10:50.890 --> 10:51.890
通过键去查到

10:51.890 --> 10:53.490
有没有相应的对象存在

10:53.490 --> 10:54.790
如果说这个对象存在的话

10:54.790 --> 10:55.090
ok

10:55.090 --> 10:57.490
我就把他的value值改一下就完事了

10:57.490 --> 10:57.690
对吧

10:57.690 --> 10:58.790
改一下就完事了

10:58.790 --> 10:59.690
如果它不存在的话

10:59.690 --> 11:01.190
再往里面加一下

11:01.190 --> 11:03.290
这就完成了set方法

11:03.290 --> 11:03.490
好

11:03.490 --> 11:04.490
咱们来看一下吧

11:04.490 --> 11:05.190
看一下

11:05.190 --> 11:10.190
我们在这里写上一些初始的

11:10.190 --> 11:15.260
我们把之前的直接复制过来吧

11:15.260 --> 11:16.160
好

11:16.160 --> 11:16.660
来吧

11:16.660 --> 11:19.880
来看一下

11:19.880 --> 11:20.080
好

11:20.080 --> 11:22.580
这里写好了

11:22.580 --> 11:24.480
咱们来看一下

11:24.480 --> 11:27.480
我们这里就把一个代码拿出来

11:27.480 --> 11:28.780
运行

11:28.780 --> 11:29.780
看一下我们输出的

11:29.780 --> 11:30.980
当然我们这里使用的是map

11:30.980 --> 11:32.780
要用map

11:32.780 --> 11:33.780
再看一下吧

11:33.780 --> 11:35.380
点击右键检查

11:35.380 --> 11:36.380
好

11:36.380 --> 11:37.580
你看map

11:37.580 --> 11:40.080
那么这里边的数据有四项

11:40.080 --> 11:43.280
是不是key value key value key

11:43.280 --> 11:45.680
是对象value value

11:45.680 --> 11:46.980
那么我们这里加两个对象

11:46.980 --> 11:47.880
还有怎么判断相等的

11:47.880 --> 11:50.080
因为两个对象的地址是一样的

11:50.080 --> 11:52.080
它用objects一直来判断的

11:52.080 --> 11:53.180
objects一直来判断的

11:53.180 --> 11:54.480
两个对象的地址是一样的

11:54.480 --> 11:54.780
ok

11:54.780 --> 11:55.680
它就相等

11:55.680 --> 11:56.480
相等的话

11:56.480 --> 11:58.880
它就是去改它的value值就行了

11:58.880 --> 12:00.780
你看就是我们形成内部的数据结构

12:00.780 --> 12:02.880
当然这个是对内使用的

12:02.880 --> 12:05.680
外面是不希望它使用的

12:05.680 --> 12:06.780
还是set

12:06.880 --> 12:07.780
那么同样的

12:07.780 --> 12:09.580
后边我们还有什么

12:09.580 --> 12:10.480
hass已经写了

12:10.480 --> 12:10.980
对吧

12:10.980 --> 12:11.780
hass已经写了

12:11.780 --> 12:13.580
还有get

12:13.580 --> 12:14.980
get

12:14.980 --> 12:15.980
有get的方法

12:15.980 --> 12:17.180
那么这个get的方法

12:17.180 --> 12:19.180
是根据一个key得到它的值

12:19.180 --> 12:19.380
对吧

12:19.380 --> 12:20.380
如果它找不到的话

12:20.380 --> 12:21.180
就是undefined

12:21.180 --> 12:21.780
那么同样的

12:21.780 --> 12:24.580
到底是不是又可以再一次利用这个函数

12:24.580 --> 12:25.980
item等于

12:25.980 --> 12:27.180
z

12:27.180 --> 12:29.180
get obj

12:29.180 --> 12:30.080
key传进去

12:30.080 --> 12:32.180
那么这样子得到那个数据里面的对象

12:32.180 --> 12:33.980
那么如果说

12:33.980 --> 12:35.080
item有值

12:35.180 --> 12:36.080
有值的方法为啥

12:36.080 --> 12:37.380
item的value

12:37.380 --> 12:38.480
如果它没有值

12:38.480 --> 12:40.080
没有值就放回undefined

12:40.080 --> 12:41.080
没有值放回undefined

12:41.080 --> 12:42.880
当然这句话可以不写

12:42.880 --> 12:43.780
这是get

12:43.780 --> 12:44.880
也特别简单

12:44.880 --> 12:45.180
来吧

12:45.180 --> 12:47.080
我们来看一下吧

12:47.080 --> 12:48.080
比方说

12:48.080 --> 12:51.380
这里我们使用mp1get

12:51.380 --> 12:52.580
写个a

12:52.580 --> 12:54.080
你看是不得了abc

12:54.080 --> 12:54.880
对吧

12:54.880 --> 12:56.380
get就实现了

12:56.380 --> 12:56.580
好

12:56.580 --> 12:57.880
再来

12:57.880 --> 12:59.480
它里边还有啥呢

12:59.480 --> 12:59.880
还有啥

12:59.880 --> 13:00.580
大概上几块钱了

13:00.580 --> 13:00.920
啥

13:00.920 --> 13:03.080
size属性

13:03.080 --> 13:03.880
size属性

13:03.880 --> 13:04.380
size属性

13:04.380 --> 13:06.280
我们把它写成一个getter

13:06.280 --> 13:07.880
getter类型的属性

13:07.880 --> 13:09.180
size

13:09.180 --> 13:09.380
好

13:09.380 --> 13:10.180
返回的是什么呢

13:10.180 --> 13:12.180
返回的就是z

13:12.180 --> 13:13.580
data.nance

13:13.580 --> 13:13.780
对吧

13:13.780 --> 13:14.980
所以返回就是数组长度

13:14.980 --> 13:16.480
这个很简单

13:16.480 --> 13:17.680
还有啥呢

13:17.680 --> 13:18.780
dnet

13:18.780 --> 13:20.780
dnet

13:20.780 --> 13:21.780
dnet的方法

13:21.780 --> 13:22.780
你给我一个建值

13:22.780 --> 13:24.380
我来帮你删除

13:24.380 --> 13:25.080
帮你删除

13:25.080 --> 13:25.880
那这个怎么办

13:25.880 --> 13:26.880
是不是循环

13:26.880 --> 13:27.780
复循环

13:27.780 --> 13:28.480
循环啥

13:28.480 --> 13:29.380
z

13:29.380 --> 13:30.880
data是这个数组

13:30.880 --> 13:32.180
如果说发现了

13:32.180 --> 13:35.180
其中有一个数据

13:35.180 --> 13:35.980
element

13:35.980 --> 13:36.580
第二key

13:36.580 --> 13:37.080
它里边

13:37.080 --> 13:37.980
就数组里边

13:37.980 --> 13:38.780
你只要知道

13:38.780 --> 13:40.180
数组里面存在是这个东西

13:40.180 --> 13:41.980
它的key这个属性

13:41.980 --> 13:42.780
跟什么

13:42.780 --> 13:44.880
跟我们传这个key的属性是一样的

13:44.880 --> 13:45.680
怎么来判断

13:45.680 --> 13:46.180
z

13:46.180 --> 13:47.180
e是equal

13:47.180 --> 13:47.580
对吧

13:47.580 --> 13:48.680
通过这种方式来判断

13:48.680 --> 13:49.280
你这个key

13:49.280 --> 13:51.080
跟我们传入的key是一样的

13:51.080 --> 13:52.580
是一样的怎么办

13:52.580 --> 13:53.380
是不是删除

13:53.380 --> 13:53.880
对吧

13:53.880 --> 13:54.580
z

13:54.580 --> 13:55.380
data

13:55.380 --> 13:56.680
splice

13:56.680 --> 13:57.980
i

13:57.980 --> 13:59.780
e

13:59.780 --> 14:00.880
删除一下

14:00.880 --> 14:01.280
对不对

14:01.280 --> 14:03.680
删除完了过后就return true

14:03.680 --> 14:04.580
因为它不可能又重复了

14:04.580 --> 14:06.180
你不用继续看了

14:06.180 --> 14:07.280
表示删除成功

14:07.280 --> 14:07.880
否则的话

14:07.880 --> 14:09.080
return force

14:09.080 --> 14:09.380
对吧

14:09.380 --> 14:10.080
删除

14:10.080 --> 14:11.180
很简单

14:11.180 --> 14:12.780
再试一下吧

14:12.780 --> 14:13.780
这里不是有四项吗

14:13.780 --> 14:14.680
我们三印象

14:14.680 --> 14:15.780
dnet

14:15.780 --> 14:17.180
a

14:17.180 --> 14:17.980
删除

14:17.980 --> 14:18.580
咱们再看

14:18.580 --> 14:19.480
mp1

14:19.480 --> 14:20.680
是不是只有三项了

14:20.680 --> 14:22.180
对吧

14:22.180 --> 14:22.580
好

14:22.580 --> 14:24.380
这是关于这一块

14:24.380 --> 14:25.180
然后继续

14:25.180 --> 14:25.880
那么clear

14:25.880 --> 14:26.580
清空

14:26.580 --> 14:27.880
清空就特别简单了

14:27.880 --> 14:28.380
clear

14:28.380 --> 14:29.580
清空特别简单

14:29.580 --> 14:30.080
z

14:30.080 --> 14:30.880
data

14:30.880 --> 14:32.080
nance等于0

14:32.080 --> 14:32.380
对吧

14:32.380 --> 14:34.380
而里边的数组清空就清空了

14:34.380 --> 14:34.680
对吧

14:34.680 --> 14:35.780
清空看一下吧

14:35.780 --> 14:38.380
mp1 clear

14:38.380 --> 14:39.180
好

14:39.180 --> 14:41.380
然后mp1

14:41.380 --> 14:42.280
是不是清空了

14:42.280 --> 14:43.380
对吧

14:43.380 --> 14:43.880
好

14:43.880 --> 14:44.780
那么size

14:44.780 --> 14:46.280
因为size是动态读取的

14:46.280 --> 14:48.780
读取的始终是数组的长度

14:48.780 --> 14:48.880
好

14:48.880 --> 14:50.680
这清空搞定了

14:50.680 --> 14:51.880
然后呢

14:51.880 --> 14:53.780
然后它本身它是一个可谍带的

14:53.780 --> 14:54.380
对吧

14:54.380 --> 14:54.980
这个map

14:54.980 --> 14:56.480
它本身要可谍带

14:56.480 --> 14:58.680
你要它能够应用展开运输案符

14:58.680 --> 15:01.580
要能够使用佛二五进行对它进行循环

15:01.580 --> 15:03.080
所以它本身要能谍带

15:03.080 --> 15:03.480
所以说呢

15:03.480 --> 15:05.380
我们是不是要把它变成一个

15:05.380 --> 15:07.280
让它去满足可谍带协议

15:07.280 --> 15:07.680
对吧

15:07.680 --> 15:09.480
symbol attrator

15:09.480 --> 15:11.280
啊满足可谍带协议

15:11.280 --> 15:12.780
那么这里返回个迭代器

15:12.780 --> 15:13.580
那么自然而然

15:13.580 --> 15:14.780
这个玩意应该是个啥

15:14.780 --> 15:15.980
应该是个可谍

15:15.980 --> 15:17.380
迭代器创建函数

15:17.380 --> 15:18.380
迭代器创建函数

15:18.380 --> 15:20.480
实际上就是生成器函数

15:20.480 --> 15:21.280
啊

15:21.280 --> 15:21.780
然后呢

15:21.780 --> 15:22.280
生成器函数

15:22.280 --> 15:23.580
本身就是

15:23.580 --> 15:26.380
一个一个就是不断的去给它迭代的数据的

15:26.380 --> 15:26.580
好

15:26.580 --> 15:27.380
那怎么迭代的

15:27.480 --> 15:29.480
每一次迭代不就是返回一个

15:29.480 --> 15:30.980
返回一个数组吗

15:30.980 --> 15:31.180
好

15:31.180 --> 15:33.080
那么425循环循环啥

15:33.080 --> 15:34.080
循环Zs

15:34.080 --> 15:34.980
data s

15:34.980 --> 15:35.180
对吧

15:35.180 --> 15:35.580
循环Zs

15:35.580 --> 15:36.580
data s

15:36.580 --> 15:38.080
每一次迭代

15:38.080 --> 15:39.280
一有的

15:39.280 --> 15:40.280
给它个什么数据

15:40.280 --> 15:41.280
给它一个数组

15:41.280 --> 15:43.680
数组的第一项是item.key

15:43.680 --> 15:45.580
数组的第二项是item.value

15:45.580 --> 15:46.380
就完了

15:46.380 --> 15:47.380
啊

15:47.380 --> 15:49.180
这就写出来了嘛

15:49.180 --> 15:49.380
好

15:49.380 --> 15:49.980
咱们试一下啊

15:49.980 --> 15:51.180
它能不能迭代

15:51.180 --> 15:53.580
我们这里先用425循环

15:53.580 --> 15:54.180
啊

15:54.180 --> 15:55.180
先用425循环

15:55.180 --> 15:56.180
npe

15:56.280 --> 15:57.780
这里输出item

15:57.780 --> 15:59.180
保存

15:59.180 --> 15:59.780
你看

15:59.780 --> 16:01.380
是不是输出了这么一些东西

16:01.380 --> 16:01.780
对吧

16:01.780 --> 16:03.080
输出了这么一些东西

16:03.080 --> 16:04.580
没问题吧

16:04.580 --> 16:05.180
另外呢

16:05.180 --> 16:08.180
我们也可以用那个展开运算幅

16:08.180 --> 16:10.280
把它转换成数组

16:10.280 --> 16:12.480
用展开运算幅npe

16:12.480 --> 16:13.980
输出result

16:13.980 --> 16:14.880
你看一下

16:14.880 --> 16:17.080
那么result里边是不是就展开了

16:17.080 --> 16:17.480
对吧

16:17.480 --> 16:19.480
因为它满足可迭代的协议

16:19.480 --> 16:19.580
好

16:19.580 --> 16:20.080
同时呢

16:20.080 --> 16:21.380
它里边有一个for2

16:21.380 --> 16:22.780
for一起循环

16:22.780 --> 16:23.880
它里边提供的一个方法

16:23.880 --> 16:25.780
就是for一起方法

16:26.780 --> 16:28.580
那么这里边要传个callback

16:28.580 --> 16:29.680
那么这个方法怎么实现的

16:29.680 --> 16:30.880
这个方法也很简单

16:30.880 --> 16:31.280
对吧

16:31.280 --> 16:32.080
怎么实现的

16:32.080 --> 16:33.680
就是循环

16:33.680 --> 16:35.180
循环里边的一个数组

16:37.080 --> 16:38.280
每一次循环干嘛

16:38.280 --> 16:40.280
是不是调用这个callback

16:40.280 --> 16:41.480
它里边不有三个贪数吗

16:41.480 --> 16:42.380
你要给它三个东西

16:42.380 --> 16:43.380
这个东西是咋

16:43.380 --> 16:44.780
是它的指

16:44.780 --> 16:45.780
每一项的指

16:45.780 --> 16:47.380
这个东西是它的鍵

16:47.380 --> 16:47.980
t

16:47.980 --> 16:49.280
第三个东西呢

16:49.280 --> 16:50.780
是它本身

16:50.780 --> 16:52.180
这个map对象本身

16:52.180 --> 16:52.480
对吧

16:52.480 --> 16:53.580
就完了

16:53.580 --> 16:53.680
好

16:53.680 --> 16:54.780
咱们来看一下for一起方法

16:55.780 --> 16:58.780
npe for each

16:58.780 --> 16:59.880
这里三个贪数

16:59.880 --> 17:01.580
a1,a2,a3

17:01.580 --> 17:03.380
当然你具体的用的时候

17:03.380 --> 17:04.980
也要用几个就写几个

17:04.980 --> 17:06.780
a1,a2,a3

17:06.780 --> 17:07.780
便利塔

17:07.780 --> 17:08.780
保存

17:08.780 --> 17:09.780
你看一下这边

17:09.780 --> 17:10.580
所以就得到

17:10.580 --> 17:13.780
直键,直键,直键,直键,map

17:13.780 --> 17:14.780
对吧

17:14.780 --> 17:15.780
OK就写完了

17:15.780 --> 17:16.580
好

17:16.580 --> 17:18.280
就是map的手动实现

17:18.280 --> 17:19.580
但是再强调一次

17:19.580 --> 17:20.780
这个手动实现的

17:20.780 --> 17:22.180
跟它内部的实现的

17:22.180 --> 17:22.980
肯定是不一样的

17:22.980 --> 17:24.180
我们这里的内部呢

17:24.180 --> 17:25.380
是用一个数组来保存的

17:25.380 --> 17:25.980
对吧

17:25.980 --> 17:26.680
我们无论是在

17:26.680 --> 17:27.980
set手动实现的时候

17:27.980 --> 17:29.580
还是在map手动实现的时候

17:29.580 --> 17:30.380
内部都是用一个

17:30.380 --> 17:31.480
数组来保存的

17:31.480 --> 17:32.480
实际上它的内部呢

17:32.480 --> 17:33.680
它不是用的不是数组

17:33.680 --> 17:34.480
用的不是数组

17:34.480 --> 17:35.580
它是直接操作内存

17:35.580 --> 17:36.780
并且它用的数据结构呢

17:36.780 --> 17:37.880
是链标

17:37.880 --> 17:38.780
所以不一样的

17:38.780 --> 17:39.580
不一样的

17:39.580 --> 17:40.480
因为链标呢

17:40.480 --> 17:41.680
它涉及到就是

17:41.680 --> 17:42.980
那个算法的知识

17:42.980 --> 17:43.680
那么算法呢

17:43.680 --> 17:45.580
不在本课程的讨论范围之列

17:45.580 --> 17:47.080
我们有专门的算法课程

17:47.080 --> 17:47.680
到时候呢

17:47.680 --> 17:50.180
你可以一定会学习到链标的

17:50.180 --> 17:50.480
OK

17:50.480 --> 17:53.480
这是关于这个map的手动实现

