WEBVTT

00:00.620 --> 00:04.460
这里当然咱们来学习代理与反射

00:04.460 --> 00:08.980
代理与反射它往往是作为一个整体出现的

00:08.980 --> 00:13.020
我们用反射的时候往往有代理

00:13.020 --> 00:15.420
对吧 用代理的时候往往会出现反射

00:15.420 --> 00:20.300
这一个章节我发现了有些同学不是觉得它不是那么好理解

00:20.300 --> 00:23.020
就感觉它怪怪的 总感觉怪怪的

00:23.020 --> 00:26.740
后来我分析了一下为什么同学们会觉得怪呢

00:26.740 --> 00:30.580
是因为你们缺失这个概念

00:30.580 --> 00:31.940
reflect

00:31.940 --> 00:35.100
因为很多的课程里边去讲代理与反射

00:35.100 --> 00:37.620
他们重点一定是在代理那一块

00:37.620 --> 00:40.500
因为代理那一块确实能够做出一些功夫的效果

00:40.500 --> 00:44.260
而reflect反射这一块啥都做不出来

00:44.260 --> 00:46.140
所以说这一节课学习要过后

00:46.140 --> 00:48.220
你能做出啥呀 啥都做不出来

00:48.220 --> 00:49.900
都一样的 跟之前是一样的

00:49.900 --> 00:52.740
感觉没有任何提升 没有任何新知识

00:52.740 --> 00:57.380
但是恰恰这一节课才是这一个章节最重要的

00:57.380 --> 00:59.980
你把这一节课的概念理解清楚了

01:00.020 --> 01:02.780
你就彻底理解了 就非常容易去理解

01:02.780 --> 01:04.380
代理到到底是怎么回事

01:04.380 --> 01:05.980
就很容易理解了

01:05.980 --> 01:08.620
如果说你这一节课缺失了的话

01:08.620 --> 01:11.220
这一节课或者是理解不清楚的话

01:11.220 --> 01:13.780
那么后边讲代理 你总感觉很怪

01:13.780 --> 01:15.580
总感觉怪怪的 怪怪的

01:15.580 --> 01:16.900
你说不出清楚哪里怪

01:16.900 --> 01:19.340
就是因为缺少了这一课的知识

01:19.340 --> 01:22.700
所以说我们本章的重点在反射

01:22.700 --> 01:23.780
代理都是其次

01:23.780 --> 01:26.420
你理解的反射一定很容易理解代理

01:26.420 --> 01:29.180
好 咱们来首先看一下反射到底是什么

01:29.180 --> 01:31.300
它单纯的叫做Reflect

01:31.300 --> 01:32.940
我们现在认识它

01:32.940 --> 01:34.540
Reflect是啥玩意儿呢

01:34.540 --> 01:36.740
它是一个内置的解释对象

01:36.740 --> 01:39.300
以前没有 是ES6里边才出来的

01:39.300 --> 01:40.980
它是个内置的解释对象

01:40.980 --> 01:43.740
也不要去想怎么去改 改不了的

01:43.740 --> 01:46.740
它里边的东西全是用底层代码写的 写死了的

01:46.740 --> 01:48.060
也因为如此

01:48.060 --> 01:51.060
所以说这一个章节里边

01:51.060 --> 01:53.580
涉及到一些底层的实现

01:53.580 --> 01:56.820
这个章节接动性会有一些接动性问题

01:56.860 --> 01:59.820
因为这个章节里边的这些API

01:59.820 --> 02:01.540
你说你要用一些工具

02:01.540 --> 02:03.740
把它兼容到9版本的浏览器

02:03.740 --> 02:05.980
但是9版本浏览器里边

02:05.980 --> 02:08.940
就是ES5里边根本就没有提供这些实现

02:08.940 --> 02:11.660
你只能去模拟 模拟出来还有一些不一样

02:11.660 --> 02:13.820
所以说这个章节学习的API

02:13.820 --> 02:15.940
它是有兼容性问题的

02:15.940 --> 02:18.820
必须要去支持ES6的浏览器才行

02:18.820 --> 02:21.820
不过现在ES6的浏览器越来越多了

02:21.820 --> 02:25.500
后续慢慢的它会发挥重要的作用

02:25.540 --> 02:27.100
它是一个内置的介绍对象

02:27.100 --> 02:28.500
它提供了一系列的方法

02:28.500 --> 02:31.220
后面我们会认识它有很多很多的方法

02:31.220 --> 02:33.460
那么这些方法有什么意义呢

02:33.460 --> 02:36.020
我们可以调用这些方法

02:36.020 --> 02:38.140
然后可以通过这些方法访问

02:38.140 --> 02:40.060
既也是底层功能

02:40.060 --> 02:42.220
哇一会就开始很兴奋了对吧

02:42.220 --> 02:44.700
哇可我们可以访问到底层功能了

02:44.700 --> 02:46.380
那么到底底层是啥呢

02:46.380 --> 02:48.660
你会看了过后你会大失所望

02:48.660 --> 02:52.340
但是你仔细认识过后你又很兴奋了

02:52.340 --> 02:54.940
不着急 咱们认识一个东西的时候

02:54.980 --> 02:56.740
就跟你们谈恋爱一样

02:56.740 --> 02:58.300
先要认识这个人

02:58.300 --> 03:00.820
然后慢慢去了解他

03:00.820 --> 03:02.780
一开始他觉得他好讨厌

03:02.780 --> 03:06.460
没有任何的优势

03:06.460 --> 03:07.700
没有任何的常处

03:07.700 --> 03:09.020
但是你慢慢认识他过后

03:09.020 --> 03:10.780
发现他有一些闪光点

03:10.780 --> 03:11.500
对吧

03:11.500 --> 03:13.580
怎么说这么远

03:13.580 --> 03:15.140
就这么个意思

03:15.140 --> 03:17.060
你先不要歧视他

03:17.060 --> 03:19.020
我们慢慢的来认识他

03:19.020 --> 03:20.540
由于他为什么取这个名字呢

03:20.540 --> 03:22.020
因为他这种功能

03:22.020 --> 03:24.140
就是应用他底层的这种现象

03:24.140 --> 03:26.980
就有一点类似于其他语言里边的反射

03:26.980 --> 03:29.100
其他语言里边有反射这么一个功能

03:29.100 --> 03:31.020
单词也是reflect

03:31.020 --> 03:33.300
指的是我这解不解释呢

03:33.300 --> 03:34.300
算了不解释了吧

03:34.300 --> 03:35.380
那不解释了

03:35.380 --> 03:37.140
那其他语言的事情跟我们没啥关系

03:37.140 --> 03:38.300
总之他就取名为反射了

03:38.300 --> 03:38.980
怎么样

03:38.980 --> 03:40.620
他就取名为反射了

03:40.620 --> 03:42.300
他的名字叫反射

03:42.300 --> 03:43.460
他作用是什么

03:43.460 --> 03:45.060
作用是他里面提供了一些API

03:45.060 --> 03:48.340
我们通过这些API能够访问底层功能

03:48.340 --> 03:49.780
接下来我们来看一下

03:49.780 --> 03:51.340
他能够做什么底层功能

03:51.340 --> 03:53.220
他到底能够访问什么底层功能

03:53.260 --> 03:55.220
我们他可以做什么呢

03:56.380 --> 03:58.300
大师所忘了

03:58.300 --> 04:01.020
属性的复职他可以做

04:01.020 --> 04:02.140
一个对象里面有属性

04:02.140 --> 04:03.820
给属性复职他可以做

04:03.820 --> 04:05.220
属性的取职

04:05.220 --> 04:07.620
读取属性的职他可以做

04:07.620 --> 04:10.100
调用一个普通函数他可以做

04:10.100 --> 04:11.100
调用一个构造函数

04:11.100 --> 04:13.620
就是用粒带调用一个构造函数他可以做

04:13.620 --> 04:15.580
判断属性的是不是存在对象中

04:15.580 --> 04:17.060
他可以做等等

04:17.060 --> 04:19.100
诸如这些的功能

04:19.100 --> 04:20.100
是不是大师所忘了

04:20.100 --> 04:21.420
这不疯了吗

04:21.420 --> 04:22.620
属性的复职和取职

04:22.620 --> 04:23.460
我早就学过了

04:23.460 --> 04:24.580
在基础建设就学过了

04:24.580 --> 04:27.420
你还给我来个新的AP来做这件事

04:27.420 --> 04:30.460
就感觉他好像啥都做不了

04:30.460 --> 04:32.460
那么这些功能已经存在了

04:32.460 --> 04:35.860
为什么还要用Reflex重新来一次呢

04:35.860 --> 04:39.700
这里就是要说来话长了

04:39.700 --> 04:40.700
是这样子的

04:40.700 --> 04:42.620
我讲长话软说吧

04:42.620 --> 04:44.580
就在ES5之后

04:44.580 --> 04:48.060
他就出现在制定这个语言标准的时候

04:48.060 --> 04:50.420
就出现这么一种理念

04:50.460 --> 04:51.460
这个什么理念呢

04:51.460 --> 04:55.060
就是尽量减少一个语言的魔法

04:55.060 --> 04:58.100
让语言的代码更加纯粹

04:58.100 --> 04:59.380
就是语言里面的功能

04:59.380 --> 05:01.420
他都以API的形式出现

05:01.420 --> 05:03.300
就是以方法

05:03.300 --> 05:05.780
函数这种用这种对象

05:05.780 --> 05:07.700
以这些API的形式出现

05:07.700 --> 05:11.300
而不再使用什么什么特殊的语法

05:11.300 --> 05:12.620
用这种方式来出现

05:12.620 --> 05:15.060
像什么特殊的语法

05:15.060 --> 05:16.660
像这种东西就是魔法

05:16.660 --> 05:18.340
面对于什么

05:18.420 --> 05:21.020
减少魔法让代码更加纯粹

05:21.020 --> 05:22.020
什么叫更加纯粹

05:22.020 --> 05:23.420
就是都是用API

05:23.420 --> 05:25.020
啥功能都是用API来出现

05:25.020 --> 05:26.140
那么就被提出来了

05:26.140 --> 05:28.660
他为什么会有这样的一个理念提出来了

05:28.660 --> 05:29.780
因为很大程度上

05:29.780 --> 05:33.060
这样的理念是受到函数式编程的影响

05:33.060 --> 05:36.820
在一个纯粹的函数式编程的语言里边

05:36.820 --> 05:39.460
像GS还不是一个纯粹的函数式编程语言

05:39.460 --> 05:42.980
在一个纯粹的函数式编程语言里边

05:42.980 --> 05:45.300
他有很少很少的语法

05:45.300 --> 05:46.780
几乎是没有什么语法

05:46.820 --> 05:49.300
当然基本语法还是得有

05:49.300 --> 05:51.140
那么函数的编程里面他实际上想什么呢

05:51.140 --> 05:51.860
你可以发现

05:51.860 --> 05:53.340
你可以发现他全都是函数

05:53.340 --> 05:57.280
比方说举个例子吧

05:57.280 --> 05:59.760
在某某函数式编程语言里边

05:59.760 --> 06:01.280
名字也不给大家说了

06:01.280 --> 06:02.360
那么他的加法

06:02.360 --> 06:03.960
他没有这个符号

06:03.960 --> 06:05.280
在符号都没有

06:05.280 --> 06:07.480
你要做加法对不起我没有加号

06:07.480 --> 06:09.600
你要做减法对不起我减号都没有

06:09.600 --> 06:11.520
你要做加法怎么做呢

06:11.520 --> 06:13.320
ADD表3加2

06:13.320 --> 06:14.920
3加2

06:14.920 --> 06:16.560
你是这样做的

06:16.600 --> 06:17.480
再加个1

06:17.480 --> 06:18.680
再加个1呗

06:20.200 --> 06:23.480
然后整个加起来的结果再乘以6

06:23.480 --> 06:24.280
加起来的结果

06:27.600 --> 06:28.800
乘是怎么说的

06:28.800 --> 06:31.280
乘以6

06:33.480 --> 06:36.200
这是函数式编程的思想

06:37.200 --> 06:37.760
有加号

06:37.760 --> 06:39.040
连符号都没有

06:39.040 --> 06:40.760
他就尽量少的语法

06:40.760 --> 06:42.320
就是我这里面一切都是透明的

06:42.320 --> 06:43.520
一切都是API

06:43.520 --> 06:47.120
他不存在说有什么特别的魔法

06:47.120 --> 06:49.240
这个魔法你自己实现不了

06:49.240 --> 06:50.800
只有我底层才能实现

06:50.800 --> 06:51.840
他不存在这个东西

06:51.840 --> 06:53.400
或者说很少有这个东西

06:53.400 --> 06:55.800
这就是一个纯粹的函数式编程语言

06:55.800 --> 06:58.880
当然你能适应这种方式吗

06:58.880 --> 07:00.600
而且他没有编辆

07:00.600 --> 07:01.880
他连编辆都没有

07:01.880 --> 07:03.040
你能适应这种方式吗

07:05.440 --> 07:06.440
你不能适应

07:06.440 --> 07:07.560
我都适应不了

07:07.560 --> 07:08.360
我说实话

07:08.360 --> 07:10.000
我现在都适应不了

07:10.000 --> 07:11.920
这个东西需要一个过程

07:11.920 --> 07:13.080
但是函数式编程里边

07:13.120 --> 07:14.360
确实有一些理念

07:14.360 --> 07:16.040
包括你们以后学到了什么

07:16.040 --> 07:17.240
reacts的时候

07:17.240 --> 07:18.520
你会发现他里边有很多的

07:18.520 --> 07:20.080
函数式编程理念在里边

07:20.080 --> 07:22.280
他一些理念确实比较先进

07:22.280 --> 07:26.160
总之现在我们前端的整个环境

07:27.440 --> 07:29.760
有一部分受到面向对象的影响

07:29.760 --> 07:32.400
有一部分受到函数式编程的影响

07:32.400 --> 07:34.840
两种识想的都在借识代码里边

07:34.840 --> 07:36.160
杂揍起来了

07:36.160 --> 07:38.800
那么其中有一部分框架

07:38.800 --> 07:39.560
比方说reacts

07:39.560 --> 07:41.560
他就深深的受到函数式编程的影响

07:43.080 --> 07:45.960
因此GS这个语言

07:45.960 --> 07:47.640
他也受到这种影响

07:47.640 --> 07:49.520
因此他提出来这么一种理念

07:49.520 --> 07:51.200
总之他有这么一种识想存在

07:52.560 --> 07:55.440
那么es6他就进一步观测这种理念

07:55.440 --> 07:58.640
他认为相对属性的内存的控制

07:58.640 --> 08:00.600
比方说我内存里边放一个纸

08:00.600 --> 08:01.840
这是你底层实现

08:01.840 --> 08:02.600
对不对

08:02.600 --> 08:03.920
这属于魔法

08:03.920 --> 08:05.880
像什么圆形链的修改

08:05.880 --> 08:06.160
对吧

08:06.160 --> 08:08.240
像什么隐私圆形这些修改

08:08.240 --> 08:09.560
像什么函数调用

08:09.560 --> 08:11.520
这是他特别的语法这些东西

08:11.520 --> 08:14.200
那么他这些都属于底层实现

08:14.200 --> 08:15.600
他属于一种魔法

08:15.600 --> 08:18.920
而es6他觉得我们应该减少魔法

08:18.920 --> 08:19.760
那怎么办呢

08:19.760 --> 08:21.960
就把他把这些东西就全部变成了

08:21.960 --> 08:23.600
一个正常的API

08:23.600 --> 08:25.120
这些API放到哪

08:25.120 --> 08:26.920
就放到reflect里边

08:26.920 --> 08:29.880
也就是说我们可以用以前的那种语法

08:29.880 --> 08:33.120
就算是对象的属性复制

08:33.120 --> 08:34.160
用复制符号对吧

08:34.160 --> 08:37.120
用一个符号来给对象的属性复制

08:37.120 --> 08:38.200
这是一种语法

08:38.200 --> 08:40.960
那么也可以用我们今天这节课学习的

08:41.040 --> 08:43.000
用API的形式来实现

08:43.000 --> 08:44.240
现在多了一种方式了

08:44.240 --> 08:44.640
对吧

08:44.640 --> 08:47.160
他并没有现在并没有强制要求你说

08:47.160 --> 08:49.320
我们一定要贯彻韩数字编程的理念

08:49.320 --> 08:51.200
一定要用API的形式来做

08:51.200 --> 08:52.480
他没有这样子说

08:52.480 --> 08:54.600
你可以大胆的使用过去的语法

08:54.600 --> 08:57.400
但是他至少了提供了这么一种方式

08:57.400 --> 08:59.960
因为js他既要支持面向对象

08:59.960 --> 09:01.880
又要支持韩数字编程

09:01.880 --> 09:05.280
所以说他要为韩数字编程考虑一些

09:05.280 --> 09:08.040
因此他把它做成了API的形式

09:08.040 --> 09:10.560
并且把这些API的高度的聚合到

09:10.560 --> 09:11.240
一个对象里面

09:11.240 --> 09:11.840
就是什么对象

09:11.840 --> 09:13.280
就是reflect对象

09:13.280 --> 09:14.880
因此我们这节课学习的知识

09:14.880 --> 09:18.400
就像这些API全部在reflect对象里面调用

09:18.400 --> 09:20.480
于是他就遭救了reflect对象

09:21.720 --> 09:24.160
那么一会我们可以看到他里面的一些API

09:24.160 --> 09:25.240
你会发现了

09:25.240 --> 09:28.760
其实我们前边无论是你在介石基础阶段

09:28.760 --> 09:32.880
还是在我们这门课里面学习了很多API

09:32.880 --> 09:34.000
之前都学过的

09:34.000 --> 09:36.120
就是reflect里面API之前都能用

09:36.120 --> 09:38.160
他并没有增加什么新的功能

09:38.160 --> 09:40.160
但是他把它聚合到reflect里面

09:40.160 --> 09:40.960
说明了啥

09:40.960 --> 09:42.760
说明了他有这么一种想法

09:42.760 --> 09:46.920
就是以后我凡是设计到介石底层的东西

09:46.920 --> 09:50.360
那么你都可以在reflect里面找到相应的API

09:50.360 --> 09:52.120
他都有对应的API

09:52.120 --> 09:54.160
至少介石是往这个方向再努力

09:55.880 --> 09:56.960
那么讲了这么一些

09:56.960 --> 09:59.040
我相信大家对reflect的东西

09:59.040 --> 09:59.840
它的意义

09:59.840 --> 10:02.640
它的出现的原因又说了解了

10:02.640 --> 10:03.920
它并不是必须要出现

10:03.920 --> 10:08.320
它是希望介石更加能够适应韩数字编程

10:08.320 --> 10:10.240
那么接下来我们就看一下reflect里面

10:10.240 --> 10:12.120
它到底提供了哪些API

10:12.120 --> 10:13.880
我这里挪劣了一些

10:13.880 --> 10:15.360
这一些我们以后拥不拥

10:15.360 --> 10:17.560
几乎是很少用

10:17.560 --> 10:19.880
但是通过去看这些API

10:19.880 --> 10:21.760
可以帮助你理解reflect

10:21.760 --> 10:22.520
他想干吗

10:22.520 --> 10:24.080
他到底他想干吗

10:24.080 --> 10:25.920
好 咱们来看一下

10:25.920 --> 10:27.160
第一个

10:27.160 --> 10:29.200
它里面提供的全是静态韩数

10:29.200 --> 10:30.800
全是静态韩数

10:30.800 --> 10:31.560
静态方法

10:31.560 --> 10:33.280
当然reflect它本身是对象

10:33.280 --> 10:34.800
它只是R大写的而已

10:34.800 --> 10:35.760
它不是一个构造韩数

10:35.760 --> 10:38.280
你不要去创建一个reflect对象

10:38.440 --> 10:41.040
它里面提供了一个方法叫set

10:41.040 --> 10:42.360
干吗呢

10:42.360 --> 10:47.560
设置一个对象的某个属性的值

10:47.560 --> 10:49.040
就这么简单

10:49.040 --> 10:50.600
来吧 我们看一下吧

10:50.600 --> 10:53.770
tess1

10:53.770 --> 10:55.650
就是这些可以学完了过的感觉

10:55.650 --> 10:57.010
我在干吗

10:57.010 --> 10:59.330
怎么这个API这么白痴

10:59.330 --> 11:00.730
你看一下吧

11:00.730 --> 11:03.370
一个objA等于B等于2

11:03.370 --> 11:05.090
我现在要把A变成2

11:05.090 --> 11:08.050
我们以前咋做的obj.a

11:08.050 --> 11:09.210
变成10

11:09.210 --> 11:09.930
等于10 对吧

11:09.970 --> 11:11.690
一句话就写完了 对不对

11:11.690 --> 11:12.970
那么这个东西是啥呢

11:12.970 --> 11:13.850
这个东西呢

11:13.850 --> 11:15.690
ES6人为它属于魔法

11:15.690 --> 11:16.210
因为为什么

11:16.210 --> 11:17.250
这是一种特殊的语法

11:17.250 --> 11:18.450
用负质运算符 对吧

11:18.450 --> 11:20.410
你能自己给我造一个符号出来吗

11:20.410 --> 11:22.290
你能够造一个就是运算符出来吗

11:22.290 --> 11:23.410
你造不了

11:23.410 --> 11:25.090
它是底层实现的东西

11:25.090 --> 11:27.530
那么它用到了底层的负质运算符

11:27.530 --> 11:29.970
它认为这属于魔法

11:29.970 --> 11:31.210
那么只要是有魔法

11:31.210 --> 11:34.250
OK 我就能够在reflect里面找到

11:34.250 --> 11:35.810
当然它现在还不一定

11:35.810 --> 11:39.650
以后它肯定是会往这个方向努力

11:39.690 --> 11:40.810
那么这属于魔法 对吧

11:40.810 --> 11:42.050
那么reflect里面

11:42.050 --> 11:44.650
它会提供一个对应的API

11:44.650 --> 11:47.970
来帮你没有魔法的来实现这个效果

11:47.970 --> 11:50.690
那么这里用setobj

11:50.690 --> 11:51.330
第一个参数

11:51.330 --> 11:53.770
第二个参数是属性a

11:53.770 --> 11:58.290
第三个参数是属性的值10

11:58.290 --> 11:59.610
当然平时

11:59.610 --> 12:01.690
你不太会用这种代码去写

12:01.690 --> 12:02.410
但是呢

12:02.410 --> 12:03.970
这个代码就在说

12:03.970 --> 12:05.290
告诉你是什么意思呢

12:05.290 --> 12:06.210
你看到这个代码

12:06.210 --> 12:07.650
它越读起来就是

12:07.690 --> 12:09.890
我再使用一个底层的实现

12:09.890 --> 12:12.850
给这个obj的a负质为10

12:12.850 --> 12:14.210
当然上面这个也是

12:14.210 --> 12:16.690
但是下面的代码是不是从越读上

12:16.690 --> 12:18.970
就更加容易理解成为底层实现

12:18.970 --> 12:19.250
对吧

12:19.250 --> 12:21.610
因为为什么它用到了reflect

12:21.610 --> 12:23.970
reflect就是跟底层实现相关的

12:23.970 --> 12:26.970
它里面风光了很多的API都是底层实现

12:26.970 --> 12:27.690
但是你从

12:27.690 --> 12:28.690
通过这个语法

12:28.690 --> 12:30.650
你没法一眼看出它就是在底层实现

12:30.650 --> 12:32.450
你只是觉得一切都很正常

12:32.450 --> 12:34.130
就是负责一个10

12:34.130 --> 12:35.770
能体会到那种细微的差别吗

12:35.810 --> 12:36.690
好好体会

12:36.690 --> 12:38.250
你细品

12:38.250 --> 12:39.770
是有点细微的差别的

12:39.770 --> 12:40.210
但是呢

12:40.210 --> 12:41.770
功能是没有任何差别的

12:41.770 --> 12:43.210
只是在感觉上

12:43.210 --> 12:45.890
在越读上是有细微的差别的

12:45.890 --> 12:47.290
使用底层实现

12:47.290 --> 12:50.090
给一个对象的属性a负质为10

12:50.090 --> 12:51.050
这里是什么意思

12:51.050 --> 12:52.330
给属性a负质为10

12:52.330 --> 12:52.850
对吧

12:52.850 --> 12:54.210
它忽略掉了一个强调

12:54.210 --> 12:56.010
少了一个强调底层实现

12:56.010 --> 12:56.890
当然这不是重点

12:56.890 --> 12:57.890
重点是

12:57.890 --> 12:59.050
它是要减少魔法

12:59.050 --> 13:00.370
你看这个是个API调用

13:00.370 --> 13:01.370
就很纯粹了

13:01.370 --> 13:04.010
咱们来输出这个obj

13:04.010 --> 13:05.090
效果当然是一样的

13:05.090 --> 13:06.250
没有任何区别

13:08.890 --> 13:10.010
你看

13:10.010 --> 13:10.930
说这个obj

13:10.930 --> 13:11.810
a等于10了

13:11.810 --> 13:13.530
就这么简单

13:13.530 --> 13:14.250
这就

13:14.250 --> 13:15.210
又是什么意思呢

13:15.210 --> 13:18.410
要说有用的话没啥用

13:18.410 --> 13:20.250
reflect get

13:20.250 --> 13:23.970
获取某一个对象的某一个属性值

13:23.970 --> 13:24.890
来吧

13:24.890 --> 13:26.130
我们要输出属性a

13:26.130 --> 13:27.410
是不是这样子输出

13:27.410 --> 13:28.210
这属于啥

13:28.210 --> 13:29.450
底耳运算符

13:29.450 --> 13:29.810
对吧

13:29.810 --> 13:31.730
底耳运算符魔法

13:31.730 --> 13:33.530
尽量的消除魔法

13:33.570 --> 13:35.210
怎么来呢

13:35.210 --> 13:36.530
reflect

13:36.530 --> 13:37.410
点什么

13:37.410 --> 13:38.650
get

13:38.650 --> 13:40.090
当然这个地方也用到了点

13:40.090 --> 13:41.490
它要完全消除这些东西

13:41.490 --> 13:42.810
还不太可能

13:42.810 --> 13:43.850
obj

13:43.850 --> 13:45.690
a

13:45.690 --> 13:46.530
那么告诉我什么呢

13:46.530 --> 13:48.410
这个代码就是什么意思

13:48.410 --> 13:50.610
使用底层实现

13:50.610 --> 13:52.210
从obj的属性a中

13:52.210 --> 13:53.050
把一个数据

13:53.050 --> 13:54.690
内存里边的数据取出来

13:54.690 --> 13:56.690
就这么个意思

13:56.690 --> 13:57.850
它含义上读起来

13:57.850 --> 13:59.690
是有点点感觉上的差别的

13:59.690 --> 14:01.530
是不是

14:01.530 --> 14:02.210
一样的

14:02.210 --> 14:05.290
跟obj.a是一样的

14:05.290 --> 14:10.380
下面这个reflect.apply

14:10.380 --> 14:13.300
雕用一个指定的函数

14:13.300 --> 14:14.260
传递z

14:14.260 --> 14:16.260
绑定z关键字

14:16.260 --> 14:17.860
绑定参数列表

14:17.860 --> 14:18.980
不就是函数雕用吗

14:18.980 --> 14:19.980
说的那么高达上

14:19.980 --> 14:21.460
但是通过这个代码

14:21.460 --> 14:23.580
你一眼就看出它在使用什么

14:23.580 --> 14:25.100
使用底层实现

14:25.100 --> 14:27.100
比方说

14:27.100 --> 14:28.580
我们这里

14:28.580 --> 14:30.140
你先不要着急排斥它

14:30.140 --> 14:31.020
先不要着急排斥它

14:31.020 --> 14:31.940
我们要接纳它

14:31.940 --> 14:33.660
接纳去接纳新的东西

14:33.700 --> 14:36.100
说不定它会给你造成一些惊喜

14:36.100 --> 14:39.580
比方说我们这里有个函数

14:39.580 --> 14:40.900
method

14:40.900 --> 14:42.020
这里输出

14:42.020 --> 14:43.740
method

14:43.740 --> 14:44.660
好 来吧

14:44.660 --> 14:46.020
我们这里

14:46.020 --> 14:47.220
雕用函数怎么调用的

14:47.220 --> 14:48.260
不就是method

14:48.260 --> 14:49.540
就这样调用的

14:49.540 --> 14:50.500
还能是啥

14:50.500 --> 14:51.340
比如说a和b

14:51.340 --> 14:52.460
有两个参数

14:52.460 --> 14:55.620
有两个参数a和b

14:55.620 --> 14:56.820
还能咋调用

14:56.820 --> 14:58.140
就这样调用

14:58.140 --> 14:59.580
但是它认为

14:59.580 --> 15:01.900
这个调用它也属于模仿

15:01.940 --> 15:03.700
函数调用的应该是一个底层实现

15:03.700 --> 15:04.860
为什么要找到那一块

15:04.860 --> 15:06.700
函数的指令的那团空间

15:06.700 --> 15:08.260
找那团空间

15:08.260 --> 15:09.540
然后做什么

15:09.540 --> 15:11.260
就是建立上下文

15:11.260 --> 15:12.540
我们指讯站里面加

15:12.540 --> 15:12.980
对不对

15:12.980 --> 15:14.420
等等一些底层实现

15:14.420 --> 15:15.220
那么函数调用的

15:15.220 --> 15:16.500
它认为是一个底层实现

15:16.500 --> 15:17.020
OK

15:17.020 --> 15:21.180
那么它就又把它放到了reflect里面

15:21.180 --> 15:22.180
相信了以后

15:22.180 --> 15:23.180
在不久的江南

15:23.180 --> 15:25.980
reflect里面要对应所有的底层实现

15:25.980 --> 15:29.140
那么reflect里面它有个apply

15:29.140 --> 15:31.500
这里面第一个参数传函数

15:31.540 --> 15:32.900
第一个参数绑定了Z

15:32.900 --> 15:34.580
Z如果说你没有什么需要绑定的话

15:34.580 --> 15:36.660
就是第三个参数

15:36.660 --> 15:37.860
就是参数列表

15:37.860 --> 15:39.260
参数列表表有两个参数

15:39.260 --> 15:41.740
三和五放到数组里面

15:41.740 --> 15:44.150
保存

15:44.150 --> 15:45.110
不还是调用吗

15:45.110 --> 15:46.350
这上面有啥区别呢

15:46.350 --> 15:47.150
没啥区别

15:47.150 --> 15:49.350
没啥区别

15:49.350 --> 15:51.550
这是reflectsapply

15:51.550 --> 15:53.470
下面再来

15:53.470 --> 15:54.550
delete property

15:54.550 --> 15:56.670
删除一个对象的某一个属性

15:56.670 --> 15:58.470
删除一个对象的某一个属性

15:58.470 --> 15:59.230
都很简单

15:59.230 --> 16:01.350
这April没有任何一个是难的

16:01.350 --> 16:02.590
只剩的大家不太好理解

16:02.630 --> 16:04.790
为什么要够去做这些东西出来

16:04.790 --> 16:05.670
有什么意义

16:05.670 --> 16:07.070
所以我这一刻就不断的关注你

16:07.070 --> 16:08.390
他为什么要这样做

16:08.390 --> 16:10.110
因为他要消除魔法

16:10.110 --> 16:11.670
消除那些特殊语法

16:11.670 --> 16:13.550
全部以API的形式出现

16:13.550 --> 16:14.790
他不是说消除吧

16:14.790 --> 16:18.710
至少他得提供这种API的对应的实现

16:18.710 --> 16:20.830
因为API还是一个普通的东西

16:20.830 --> 16:23.430
他就没有任何魔法了

16:23.430 --> 16:25.830
至少他表面上看起来没有任何魔法了

16:25.830 --> 16:28.230
那么这里我们比较说一个obg

16:28.230 --> 16:29.270
一个对象

16:29.270 --> 16:30.870
A等于B等于2

16:30.910 --> 16:32.150
那么我们要删除属性A

16:32.150 --> 16:33.110
怎么删除的

16:33.110 --> 16:35.390
是不是delete关键制obg也A

16:35.390 --> 16:36.710
这是不是典型的魔法

16:36.710 --> 16:37.710
对吧

16:37.710 --> 16:40.190
你给我能够做一个关键制出来

16:40.190 --> 16:41.070
实现同样的功能

16:41.070 --> 16:42.070
你做不出来吧

16:42.070 --> 16:44.350
这是一个典型的余法层面的东西

16:44.350 --> 16:45.070
对吧

16:45.070 --> 16:46.350
好消除魔法

16:46.350 --> 16:48.870
我们使用reflect

16:49.910 --> 16:51.430
delete property

16:51.430 --> 16:52.950
obg传进去

16:52.950 --> 16:53.990
A传进去

16:53.990 --> 16:55.710
那是不是一个正常的API

16:57.230 --> 16:58.110
A传进去

16:58.110 --> 16:59.790
是不是一个正常的API

16:59.830 --> 17:00.510
保存你看

17:00.510 --> 17:01.550
效果是一样的

17:01.550 --> 17:02.870
没有任何区别

17:02.870 --> 17:04.630
是不是就消除魔法了

17:04.630 --> 17:06.030
再来看

17:06.030 --> 17:07.110
define property

17:07.110 --> 17:09.670
这个东西就是我们上罗杰克刚刚回过的

17:09.670 --> 17:12.070
当然如果说你没有搞清楚这个东西的话

17:12.070 --> 17:13.550
建议回顾一下上杰克

17:13.550 --> 17:16.310
那么上杰克我们是不是讲了define property

17:16.310 --> 17:17.070
它是在哪里呢

17:17.070 --> 17:19.430
它是在obg彻define property里面

17:19.430 --> 17:21.430
就定一个属性

17:21.430 --> 17:23.590
给它加一些描述服务

17:23.590 --> 17:25.510
那么reflect Define property

17:25.510 --> 17:27.630
跟obg彻define property是一样的

17:28.590 --> 17:29.790
几乎是一样的

17:29.790 --> 17:30.870
类似于

17:30.870 --> 17:32.430
只有一点不同就是

17:32.430 --> 17:33.790
如果说你这里出了问题

17:33.790 --> 17:34.830
配置出了问题

17:34.830 --> 17:36.910
上杰克我好像还少讲个东西

17:36.910 --> 17:37.830
就是说

17:37.830 --> 17:40.830
这个就是纯去弃属性

17:40.830 --> 17:44.790
就配置get和set的时候

17:44.790 --> 17:46.270
你是不能跟那个

17:46.270 --> 17:48.390
value和writeable共存的

17:48.390 --> 17:49.310
为什么不能共存

17:49.310 --> 17:50.470
就是你配置了value

17:50.470 --> 17:51.830
配置了writeable

17:51.830 --> 17:53.670
你就不能再配置get和set

17:53.670 --> 17:54.790
你配置的get和set

17:54.790 --> 17:56.350
你不能配置value和writeable

17:56.790 --> 17:57.230
为什么呢

17:57.230 --> 17:58.070
你想的那个道理

17:58.070 --> 17:59.630
因为你配置了get和set之后

17:59.630 --> 18:01.190
它变成一个纯去弃属性

18:01.190 --> 18:03.150
它本身就没有类传空间了

18:03.150 --> 18:05.270
没有类传空间来放这个数据了

18:05.270 --> 18:07.110
那么这个value是什么意思

18:07.110 --> 18:08.710
表示类传空间里面的数据

18:08.710 --> 18:09.990
是不是矛盾的

18:09.990 --> 18:11.150
对吧

18:11.150 --> 18:11.830
对不对

18:11.830 --> 18:12.870
因为你配置get和set

18:12.870 --> 18:14.750
变成运行函数了

18:14.750 --> 18:16.870
所以说它不能共存的

18:16.870 --> 18:17.870
writeable指的是

18:17.870 --> 18:19.990
这个类传空间的东西能不能修改

18:19.990 --> 18:20.750
就没什么意义了

18:20.750 --> 18:21.590
是矛盾的

18:21.590 --> 18:23.030
如果说你配置的get和set

18:23.030 --> 18:24.430
再去配置value和writeable的话

18:24.430 --> 18:26.270
它会爆错

18:26.310 --> 18:29.110
那么这边Reflect Define Property

18:30.350 --> 18:32.590
它跟Object Define Property

18:32.590 --> 18:34.430
类似只不过它不会爆错

18:34.430 --> 18:35.350
如果配置出了问题

18:35.350 --> 18:37.230
它反回整个函数反回Force

18:37.230 --> 18:38.030
而不是爆错

18:38.030 --> 18:38.870
就这么个区别

18:39.870 --> 18:42.390
实际上的Define Property

18:42.390 --> 18:43.350
就是内部

18:43.350 --> 18:45.190
你可以认为它内部就在调整这个

18:46.070 --> 18:47.470
调整这个底层实现

18:47.470 --> 18:48.590
只不过它做了一些验证

18:48.590 --> 18:49.310
验证不通过

18:49.310 --> 18:49.830
还要爆错

18:49.830 --> 18:50.150
对吧

18:51.270 --> 18:51.390
好

18:51.390 --> 18:53.630
那么下面这个Reflect Construct

18:54.270 --> 18:54.990
这是干嘛呢

18:54.990 --> 18:57.230
这是用勾造函数的方式创建一个对象

18:58.230 --> 18:58.510
好了

18:58.510 --> 18:59.030
咱们来看一下

18:59.030 --> 19:00.110
这个也挺有意思的

19:01.950 --> 19:03.830
因为它认为使用关键字6

19:03.830 --> 19:04.670
它也是模仿

19:06.230 --> 19:06.550
你看

19:06.550 --> 19:08.910
慢慢就体会到它的干嘛了

19:08.910 --> 19:09.870
对吧

19:09.870 --> 19:10.790
它要消除模仿

19:12.390 --> 19:13.430
我们这里比方说

19:14.270 --> 19:15.630
Z是点A等于A

19:15.630 --> 19:16.790
Z是点B等于A

19:16.790 --> 19:17.950
B 是不是勾造函数

19:17.950 --> 19:19.510
那么我们要创建一个勾造函数的对象

19:19.510 --> 19:20.310
是怎么创建的

19:21.150 --> 19:22.230
New一个Test

19:22.230 --> 19:22.710
对吧

19:22.710 --> 19:23.670
是不是New一个Test

19:23.710 --> 19:24.470
它要输出

19:26.830 --> 19:27.510
输出个T

19:28.190 --> 19:28.510
保存

19:29.150 --> 19:29.830
大家看

19:29.830 --> 19:30.190
Test吧

19:30.190 --> 19:30.630
对吧

19:30.630 --> 19:31.110
没问题吧

19:31.870 --> 19:32.070
好

19:32.070 --> 19:33.030
那么这个玩意呢

19:34.470 --> 19:35.030
它是模仿

19:35.030 --> 19:36.390
因为它用了关键字6

19:36.390 --> 19:38.390
你能够做出一个关键字6出来吗

19:38.390 --> 19:38.910
不能吧

19:38.910 --> 19:41.950
于是它变成了没有模仿的API

19:41.950 --> 19:43.430
叫Construct

19:43.550 --> 19:45.670
这个创传韩数

19:45.670 --> 19:46.510
这个创传

19:46.510 --> 19:48.430
传那个就是参数列表

19:48.430 --> 19:49.870
参数列表

19:49.870 --> 19:51.030
一和三

19:52.070 --> 19:52.470
没了

19:53.310 --> 19:54.190
反回一个T

19:54.190 --> 19:56.030
反回一个对象T接手

19:56.030 --> 19:56.430
保存

19:57.790 --> 19:58.350
一样的效果

19:58.350 --> 19:58.910
还没

19:58.910 --> 19:59.910
是不是一样的效果

19:59.910 --> 20:00.230
对吧

20:00.230 --> 20:01.870
你看这个API是没有模仿

20:01.870 --> 20:05.070
雕用底层的勾造韩数实现

20:05.070 --> 20:06.830
去创建一个勾造韩数的对象

20:06.830 --> 20:07.790
参数传进去

20:08.390 --> 20:09.830
是这么个意思

20:11.310 --> 20:12.030
Hes

20:12.030 --> 20:14.550
判断一个对象是否拥有一个属性

20:14.550 --> 20:15.550
这个东西类似于啥呢

20:15.550 --> 20:19.020
类似于硬关键制

20:19.020 --> 20:21.020
比方说咱们有个对象

20:21.020 --> 20:23.540
有个属性A等于1B等于2

20:23.540 --> 20:24.940
然后我们判断一下

20:24.940 --> 20:27.980
这个A属性A是在不在OB界里面的

20:27.980 --> 20:29.140
是不是魔法

20:29.140 --> 20:29.780
对吧

20:29.780 --> 20:31.180
又有一个新的语法出现了

20:31.180 --> 20:31.580
对吧

20:31.580 --> 20:32.580
魔法

20:32.580 --> 20:33.940
消除魔法

20:33.940 --> 20:37.650
使用Reflect

20:37.650 --> 20:40.210
看着

20:40.210 --> 20:41.930
使用Reflect是消除魔法

20:41.930 --> 20:44.570
那么它对应的格式是Reflect

20:45.170 --> 20:45.730
什么

20:45.730 --> 20:46.530
Haz

20:46.530 --> 20:47.970
有没有一个属性

20:47.970 --> 20:49.130
Target

20:49.130 --> 20:50.090
对象

20:50.090 --> 20:52.050
属性名

20:52.050 --> 20:53.410
一样的效果

20:53.410 --> 20:54.890
对象里面是否有属性

20:54.890 --> 20:57.810
效果跟那个硬关键制是一样的

20:57.810 --> 21:00.090
是一样的

21:00.090 --> 21:01.930
其实我们这些课的重点

21:01.930 --> 21:06.570
并不在于我们要去了解它多少的API

21:06.570 --> 21:08.130
而去理解它

21:08.130 --> 21:10.250
它为什么要去这样做

21:10.250 --> 21:11.370
它不是封了

21:11.370 --> 21:12.050
它不是吃饱了

21:12.050 --> 21:13.090
没事干

21:13.090 --> 21:14.530
它是希望

21:14.930 --> 21:16.250
我这个语言

21:16.250 --> 21:19.290
应用的范围更加广一点

21:19.290 --> 21:20.570
不仅能够

21:20.570 --> 21:22.010
它不仅是一个普通的语言

21:22.010 --> 21:24.770
而且能够支持一个函数式编程

21:24.770 --> 21:26.970
因为函数式编程就最讨厌那种魔法了

21:26.970 --> 21:28.890
它认为一切功能都是应该

21:28.890 --> 21:30.090
都是计算

21:30.090 --> 21:30.970
一切功能都是计算

21:30.970 --> 21:31.650
都是运营算

21:31.650 --> 21:32.330
你给我一个东西

21:32.330 --> 21:33.450
我给你输出一个东西

21:33.450 --> 21:35.690
都应该是一个函数调用

21:35.690 --> 21:38.530
那么它就出现了相应的API

21:38.530 --> 21:42.130
来代替代以前的那种魔法

21:42.130 --> 21:43.410
当然不是说这一章

21:43.410 --> 21:45.410
这一节课学习完了过后

21:45.410 --> 21:47.650
以及以后就走获入魔了

21:47.650 --> 21:50.370
全部用Furifleg这也不对

21:50.370 --> 21:53.770
我们还是要以线状还是要看一下线状

21:53.770 --> 21:57.250
毕竟线状函数式编程的风声大

21:57.250 --> 21:58.530
雨点小

21:58.530 --> 22:01.090
因为那一块确实难以掌握

22:01.090 --> 22:03.090
不要说小公司的

22:03.090 --> 22:06.450
就大公司能掌握的函数式编程的人都不多

22:06.450 --> 22:09.690
因为确实太颠覆普通的编程

22:09.690 --> 22:11.210
编程模式了

22:11.250 --> 22:14.250
所以说目前以前的语法

22:14.250 --> 22:15.530
还是经常会使用

22:15.530 --> 22:17.570
而且反而是这个东西用的特别少

22:17.570 --> 22:19.290
但是有了这个东西之后

22:19.290 --> 22:27.130
至少介绍它具有了函数式编程的应用的能力

22:27.130 --> 22:28.770
是这么个意思

22:28.770 --> 22:31.050
那么Refleg车里面还有一些其他的API

22:31.050 --> 22:32.170
如果有兴趣的同学

22:32.170 --> 22:33.690
可以去看一下这个地址

22:33.690 --> 22:36.690
这个地址是MDN

22:36.690 --> 22:37.690
我之前给大家说过

22:37.690 --> 22:39.450
你看稳当的话

22:39.450 --> 22:40.770
特别是前端

22:40.770 --> 22:44.210
MDN上有的一定是以MDN为准

22:44.210 --> 22:45.330
那么在这里边还告诉你

22:45.330 --> 22:46.690
还有很多很多的方法

22:46.690 --> 22:47.970
你会发现了这些方法

22:47.970 --> 22:51.210
其实不用它都能实现

22:51.210 --> 22:54.010
只不过它给你提供了这些API

22:54.010 --> 22:56.330
来尽量的减少模法

22:56.330 --> 22:57.490
是这么个意思

22:57.490 --> 22:59.610
这就是这一节课Refleg的东西

22:59.610 --> 23:01.210
这也是很多教程里面

23:01.210 --> 23:02.850
往往把它忽略掉了一点

23:02.850 --> 23:04.290
但是你忽略掉了它

23:04.290 --> 23:06.370
你就不是那么好理解代理了

23:06.370 --> 23:06.890
好吧

23:06.890 --> 23:09.850
好 这一课就是Refleg车

23:09.850 --> 23:10.650
大家有兴趣的话

23:10.690 --> 23:12.770
我建议大家去用它几个API

23:12.770 --> 23:16.370
比方说你去用一下SetsAPI和GatsAPI

23:16.370 --> 23:17.530
去用一下这两个吧

23:17.530 --> 23:19.090
别的不说用下这两个

23:19.090 --> 23:20.010
也挺有意思的

23:20.010 --> 23:21.130
也很简单

23:21.130 --> 23:21.610
好吧

23:21.610 --> 23:22.490
这就是这一课的知识

