WEBVTT

00:00.000 --> 00:02.800
我们把姿势学完之后

00:02.800 --> 00:05.200
咱们这些可能单独来聊一聊

00:05.200 --> 00:08.000
关于这个Promise的面相关面试题

00:08.000 --> 00:10.200
Promise这个面试题呢

00:10.200 --> 00:12.200
也是ES6里边

00:12.200 --> 00:14.200
面试题非常密集的地方

00:14.200 --> 00:16.400
它玩的花样也可能比较多

00:16.400 --> 00:18.000
我不可能说把每一套

00:18.000 --> 00:19.400
你们将来可能会遇到的

00:19.400 --> 00:20.600
每一道面试拿出来讲

00:20.600 --> 00:21.800
那个太多了

00:21.800 --> 00:22.800
没有必要

00:22.800 --> 00:24.800
我们只要抓住它的核心

00:24.800 --> 00:26.000
抓住它的核心原理

00:26.000 --> 00:28.600
我们就可以解开所有的面试题

00:28.600 --> 00:31.400
像我们这里给大家介绍出来一些面试题的

00:31.400 --> 00:32.400
基本考点

00:32.400 --> 00:33.600
一个就是概念

00:33.600 --> 00:35.000
这都是我们讲过的

00:35.000 --> 00:36.000
我们回顾一下

00:36.000 --> 00:37.600
一个就是Promise的概念

00:37.600 --> 00:40.400
概念的话它主要可能会出现一些

00:40.400 --> 00:43.600
天空题 选择题 或者是问答题

00:43.600 --> 00:45.400
它可能会问你Promise的一些

00:45.400 --> 00:48.800
核心的一些阶段 哪些阶段

00:48.800 --> 00:51.000
或者是状态的变化

00:51.000 --> 00:52.400
就问这些东西

00:52.400 --> 00:53.600
就基本概念

00:55.600 --> 00:57.800
如果说出现代码题的话

00:57.800 --> 01:00.800
它可能会问你给你一段代码

01:00.800 --> 01:03.800
让你说出它的输出结果

01:03.800 --> 01:04.800
那么代码里面可能

01:04.800 --> 01:06.800
针对这个基本概念的考察的话

01:06.800 --> 01:08.800
它会可能会问你

01:08.800 --> 01:10.800
像某一些状态之间

01:10.800 --> 01:12.800
能不能进行转换

01:12.800 --> 01:14.800
我们之前其实做过一种类似的题

01:14.800 --> 01:15.800
你看我们面试题的地

01:15.800 --> 01:17.800
这道题就是

01:17.800 --> 01:19.800
诶呗

01:19.800 --> 01:22.800
哪道题呢

01:22.800 --> 01:24.800
之前我这里好像没有列出来

01:24.800 --> 01:27.800
就之前我们在做过一个题

01:27.800 --> 01:29.800
就是它在Promise

01:29.800 --> 01:31.800
扭一个Promise的时候

01:31.800 --> 01:35.180
让我写到代码里面吧

01:35.180 --> 01:40.410
在扭一个Promise的时候

01:40.410 --> 01:42.410
这里边它可能会出现

01:42.410 --> 01:44.410
这种形式

01:46.410 --> 01:48.410
它可能先Result1

01:48.410 --> 01:51.410
然后再Result2

01:51.410 --> 01:54.410
再Result1一个东西

01:54.410 --> 01:56.410
它可能会用这种题来考察

01:56.410 --> 01:58.410
就是针对Promise的状态

01:58.410 --> 02:01.410
它会不会因为改变了数据

02:01.410 --> 02:03.410
数据会不会导致变化

02:03.410 --> 02:04.410
改变了一个状态

02:04.410 --> 02:05.410
状态会不会变化

02:05.410 --> 02:07.410
可能会针对这个东西来进行考察

02:07.410 --> 02:09.410
之前那么大家牢记

02:09.410 --> 02:12.410
Promise的状态一旦确定了之后

02:12.410 --> 02:14.410
是不可能会变化的

02:14.410 --> 02:15.410
它的数据也好

02:15.410 --> 02:16.410
状态也好

02:16.410 --> 02:17.410
是不可能会变化

02:17.410 --> 02:18.410
那么就

02:18.410 --> 02:19.410
这种题就没有任何问题了

02:19.410 --> 02:21.410
还是比较简单啊这种题

02:21.410 --> 02:22.410
然后呢

02:22.410 --> 02:23.410
第二个考点

02:23.410 --> 02:24.410
是关于它的念试跟用规则

02:24.410 --> 02:26.410
这一块可能有比较复杂一点

02:26.410 --> 02:28.410
就是咱们单独的有一些课

02:28.410 --> 02:29.410
对吧

02:29.410 --> 02:31.410
专门来讲它的念试跟用规则

02:31.410 --> 02:33.410
那么记住这么几个条

02:33.410 --> 02:34.410
这几条

02:34.410 --> 02:36.410
你把这几条搞清楚了过后

02:36.410 --> 02:39.410
那么这种题就OK了

02:39.410 --> 02:40.410
到这里就不再出于数了

02:40.410 --> 02:42.410
因为我之前专门来讲的一些课

02:42.410 --> 02:44.410
在讲这个东西

02:44.410 --> 02:45.410
然后呢

02:45.410 --> 02:46.410
还有就是真正它的一些静态方法

02:46.410 --> 02:48.410
这个也算是比较简单的

02:48.410 --> 02:50.410
最复杂的可能就是在这一块了

02:50.410 --> 02:53.410
真正它的静态方法呢

02:53.410 --> 02:54.410
我们就这么一些

02:54.410 --> 02:55.410
对吧

02:55.410 --> 02:56.410
这两个完事了

02:56.410 --> 02:57.410
它可能会针对什么

02:57.410 --> 02:58.410
or any

02:58.410 --> 03:00.410
这些东西来进行考察

03:00.410 --> 03:02.410
然后就是针对而Sinc和而为者

03:02.410 --> 03:05.410
这两个玩意是一个是愚法堂

03:05.410 --> 03:08.410
它其实本质上考的还是Promise

03:08.410 --> 03:09.410
这个地方

03:09.410 --> 03:10.410
我们一会儿看一下题吧

03:10.410 --> 03:11.410
看一下题

03:11.410 --> 03:13.410
我们就可以明白了

03:13.410 --> 03:14.410
然后最后一个考点呢

03:14.410 --> 03:17.410
是针对把Promise跟视线循环

03:17.410 --> 03:18.410
结合起来考

03:18.410 --> 03:19.410
这种题是

03:19.410 --> 03:21.410
考题的量是非常大的

03:21.410 --> 03:23.410
就我们之前学过视线循环

03:23.410 --> 03:24.410
大家还记得吗

03:24.410 --> 03:26.410
我们这个执行上下文

03:26.410 --> 03:27.410
我们的异部的函数呢

03:27.410 --> 03:29.410
会放到这个

03:29.410 --> 03:31.410
就是微对列或者是红对列

03:31.410 --> 03:32.410
对吧

03:32.410 --> 03:33.410
那么针对这一块呢

03:33.410 --> 03:35.410
有一个知识给大家说一下

03:35.410 --> 03:37.410
我们目前学的

03:37.410 --> 03:40.410
所有的关于介事的知识

03:40.410 --> 03:42.410
有这么极重情况

03:42.410 --> 03:45.410
函数会进入视线对列

03:45.410 --> 03:46.410
加总结一下

03:46.410 --> 03:49.410
一个是set timeout和一个是set interval

03:49.410 --> 03:50.410
就计时器

03:50.410 --> 03:52.410
计时器本管是哪一个

03:52.410 --> 03:54.410
它的回调啊

03:54.410 --> 03:55.410
时间到达之后

03:55.410 --> 03:56.410
它的回调

03:56.410 --> 03:58.410
它一定是进入视线对列的

03:58.410 --> 03:59.410
进入哪一个对列呢

03:59.410 --> 04:02.410
进入这个红对列

04:02.410 --> 04:04.410
就是普通用户

04:04.410 --> 04:05.410
这是VIP吧

04:05.410 --> 04:07.410
普通用户

04:07.410 --> 04:09.410
然后Promise的函函数

04:09.410 --> 04:11.410
它也有一个回调

04:11.410 --> 04:12.410
对吧

04:12.410 --> 04:14.410
这个函函数是不是有个回调

04:14.410 --> 04:17.410
函函数里边的回调啊

04:17.410 --> 04:18.410
它是进入的是

04:18.410 --> 04:20.410
它是唯一任务

04:20.410 --> 04:21.410
它进入到哪呢

04:21.410 --> 04:24.410
这是这个V对列

04:24.410 --> 04:26.410
这个大家记住啊

04:26.410 --> 04:27.410
然后剩下的就是

04:27.410 --> 04:29.410
我们之前还学过request animation frame

04:29.410 --> 04:31.410
以及就它的回调呢

04:31.410 --> 04:33.410
是进入那个红对列

04:33.410 --> 04:34.410
以及我们的视线处理函数

04:34.410 --> 04:35.410
比方说点击世界啊

04:35.410 --> 04:37.410
鼠标移入世界啊等等

04:37.410 --> 04:38.410
事件发生的时候

04:38.410 --> 04:39.410
那个函数

04:39.410 --> 04:41.410
它也是先会进入红对列

04:41.410 --> 04:43.410
就我们目前学的东西呢

04:43.410 --> 04:45.410
就是这个Promise任函数它的回调

04:45.410 --> 04:47.410
进入的是V对列

04:47.410 --> 04:48.410
当然它开启函数也是一样啊

04:48.410 --> 04:49.410
开启函数

04:49.410 --> 04:51.410
本身就是任的翻版

04:51.410 --> 04:53.410
说这个之前给它补充一下

04:53.410 --> 04:55.410
好 接下来我们再做一些面试题

04:55.410 --> 04:57.410
不断的去巩固我们前面学的知识

04:57.410 --> 05:02.410
一共给它出了这么9道面试题

05:02.410 --> 05:03.410
这9道面试题的话

05:03.410 --> 05:05.410
是非常有代表性的

05:05.410 --> 05:06.410
我们来看一看

05:06.410 --> 05:07.410
第一个题

05:07.410 --> 05:10.410
基本上都是为你给了一段代码

05:10.410 --> 05:12.410
让你说出它的输出结果

05:12.410 --> 05:13.410
我们来分析一下啊

05:13.410 --> 05:15.410
当然你可以先不听我讲

05:15.410 --> 05:18.410
你自己根据我们之前学的知识

05:18.410 --> 05:21.410
包括这些可补充的这个世界对立的知识

05:21.410 --> 05:23.410
自己想一下它会输出什么

05:23.410 --> 05:25.410
然后运行一下

05:25.410 --> 05:26.410
看它的输出结果

05:26.410 --> 05:28.410
跟你想的一样嘛

05:28.410 --> 05:31.410
好 来 我们来看一下第一道题

05:31.410 --> 05:32.410
第一道题呢

05:32.410 --> 05:34.410
我们这里呢

05:34.410 --> 05:35.410
它问你输出什么

05:35.410 --> 05:39.550
这个我们就打开

05:39.550 --> 05:40.550
打开一个计识本

05:40.550 --> 05:41.550
你们之后做题的时候

05:41.550 --> 05:43.550
千万不要在脑袋里面想想

05:43.550 --> 05:45.550
特别容易错

05:45.550 --> 05:48.550
像这种题你本身就有这样的知识

05:48.550 --> 05:49.550
有这样的能力

05:49.550 --> 05:50.550
想了这么多解课之后

05:50.550 --> 05:52.550
本来是能做出来的

05:52.550 --> 05:54.550
结果呢你自己想可能意

05:54.550 --> 05:55.550
一不留神就做错了

05:55.550 --> 05:57.550
应该拿出一个计识本

05:57.550 --> 05:59.550
或者是拿出一个超高纸笔盒子

05:59.550 --> 06:01.550
都可以画一画那个世界对立

06:01.550 --> 06:03.550
红对立微对立

06:03.550 --> 06:04.550
那我们平时

06:04.550 --> 06:06.550
我们可以用这种方式来记录一下

06:06.550 --> 06:08.550
然后一开始是全局上下稳

06:08.550 --> 06:09.550
对吧

06:09.550 --> 06:11.550
或者是我们用一个直行站

06:11.550 --> 06:13.550
然后一个红对立

06:13.550 --> 06:15.550
一个微对立

06:15.550 --> 06:16.550
用这种方式

06:16.550 --> 06:17.550
看一下这里边有什么东西

06:17.550 --> 06:18.550
然后再打开一个计识本

06:18.550 --> 06:20.550
然后这里写上输出结果

06:20.550 --> 06:22.550
来把我们一开始

06:22.550 --> 06:23.550
一开始的时候

06:23.550 --> 06:26.550
我们是一个全局上下稳

06:26.550 --> 06:27.550
也就是这里

06:27.550 --> 06:28.550
我们在直行全局站

06:28.550 --> 06:30.550
对不对

06:30.550 --> 06:31.550
开始执行

06:31.550 --> 06:32.550
开始执行的时候

06:32.550 --> 06:34.550
创建了一个Promise

06:34.550 --> 06:35.550
然后给它传了一个回调

06:35.550 --> 06:36.550
注意啊

06:36.550 --> 06:38.550
这个回调它是不进入世界对立的

06:38.550 --> 06:39.550
它是直接执行的

06:39.550 --> 06:40.550
所以直接执行

06:40.550 --> 06:42.550
这里是不是输出了1

06:42.550 --> 06:44.550
输出结果你是不是1

06:44.550 --> 06:46.550
接下来我们这里

06:46.550 --> 06:47.550
再开一个

06:47.550 --> 06:49.550
记录一下Promise的状态

06:51.550 --> 06:52.550
一开始是平顶嘛

06:52.550 --> 06:53.550
这个Promise

06:53.550 --> 06:55.550
刑建Promise是平顶嘛

06:55.550 --> 06:56.550
对吧

06:56.550 --> 06:57.550
状态永远是平顶

06:57.550 --> 06:58.550
一开始

06:58.550 --> 06:59.550
然后输出了一个1

06:59.550 --> 07:00.550
接下来一个2

07:00.550 --> 07:01.550
我是不是把它状态变成了

07:01.550 --> 07:04.550
变成了Fullfield

07:04.550 --> 07:05.550
数据是什么

07:05.550 --> 07:06.550
数据是ND判的

07:06.550 --> 07:07.550
就这样的

07:07.550 --> 07:10.550
用这样的方式来记录一下

07:10.550 --> 07:12.550
然后我们接着输出2

07:12.550 --> 07:13.550
因为它说

07:13.550 --> 07:14.550
那这个状态变

07:14.550 --> 07:15.550
是不是要运行这个

07:15.550 --> 07:17.550
既然代码都还没有执行到这来

07:17.550 --> 07:18.550
不着急

07:18.550 --> 07:19.550
我们这里

07:19.550 --> 07:21.550
这句话只是改变它的状态

07:21.550 --> 07:24.550
还没法执行执行这个回调

07:24.550 --> 07:26.550
如果把变成状态变了过后

07:26.550 --> 07:28.550
我们再输出2

07:28.550 --> 07:29.550
没问题吧

07:29.550 --> 07:30.550
它为什么在这里

07:30.550 --> 07:31.550
给你加个输出

07:31.550 --> 07:32.550
其实就是考察的

07:32.550 --> 07:33.550
可能有些同学有误解

07:33.550 --> 07:35.550
是不是状态一旦确定之后

07:35.550 --> 07:36.550
后边代码就不执行的

07:36.550 --> 07:37.550
不是的

07:37.550 --> 07:38.550
还是要执行完的

07:38.550 --> 07:40.550
只是后边更改状态代码

07:40.550 --> 07:41.550
无销了

07:41.550 --> 07:42.550
只是如此

07:42.550 --> 07:44.550
其实代码要执行完的

07:44.550 --> 07:45.550
好

07:45.550 --> 07:46.550
那么我接下来

07:46.550 --> 07:47.550
把这个Promise

07:47.550 --> 07:48.550
就复辞给了变量Promise

07:48.550 --> 07:49.550
好

07:49.550 --> 07:52.550
接下来我代码继续往后走

07:52.550 --> 07:53.550
然后在这里

07:53.550 --> 07:55.550
给它注册了一个回调函数

07:55.550 --> 07:58.550
说你的状态一旦完成之后

07:58.550 --> 08:00.550
请你运行这个回调函数

08:00.550 --> 08:01.550
完成了吗

08:01.550 --> 08:02.550
就完成了

08:02.550 --> 08:04.550
现在状态就是完成的

08:04.550 --> 08:05.550
成功的

08:05.550 --> 08:06.550
成功的时候

08:06.550 --> 08:08.550
请你执行这个回调函数

08:08.550 --> 08:09.550
那么按理说的话

08:09.550 --> 08:11.550
现在应该执行这个回调

08:11.550 --> 08:13.550
但是你要记住

08:13.550 --> 08:15.550
这个函函数的回调

08:15.550 --> 08:16.550
是要进入V队列的

08:16.550 --> 08:17.550
所以说呢

08:17.550 --> 08:18.550
这里呢

08:18.550 --> 08:19.550
虽然说

08:19.550 --> 08:20.550
我们实际已经成熟了

08:20.550 --> 08:21.550
但是它的做法呢

08:21.550 --> 08:22.550
是把这个函数

08:22.550 --> 08:24.550
我们把它叫做fn1嘛

08:24.550 --> 08:25.550
把这个函数加到哪呢

08:25.550 --> 08:27.550
是实际上是加到V队列的

08:27.550 --> 08:32.570
我们就把它叫做fn1嘛

08:32.570 --> 08:33.570
这个函数

08:34.570 --> 08:36.570
实际上放到这儿的

08:36.570 --> 08:37.570
等待执行

08:37.570 --> 08:38.570
因为我们目前的

08:38.570 --> 08:39.570
全聚上下关还没有执行结束

08:39.570 --> 08:40.570
对吧

08:40.570 --> 08:41.570
事件

08:41.570 --> 08:42.570
执行站还没有清空

08:42.570 --> 08:43.570
所以说呢

08:43.570 --> 08:44.570
执行站

08:44.570 --> 08:46.570
我们还要继续执行

08:46.570 --> 08:47.570
执行站里面

08:47.570 --> 08:49.570
目前是执行的全聚上下关

08:49.570 --> 08:50.570
我们就执行结束就好

08:50.570 --> 08:51.570
放过来吧

08:51.570 --> 08:52.570
我们心里边知道就行了

08:52.570 --> 08:53.570
主要是把个队列

08:53.570 --> 08:55.570
和promet状态要记住一下

08:55.570 --> 08:56.570
好

08:56.570 --> 08:57.570
那么接下来

08:57.570 --> 08:58.570
我们这V队列里面

08:58.570 --> 08:59.570
是不是有一个函数啊

08:59.570 --> 09:00.570
我们就把它叫做fn嘛

09:00.570 --> 09:01.570
就这个函数

09:01.570 --> 09:02.570
我们自己可以标记一下

09:02.570 --> 09:03.570
fn3

09:03.570 --> 09:05.570
这个函数是要输出3的

09:06.570 --> 09:08.570
以后你们

09:08.570 --> 09:09.570
我再跟你们讲

09:09.570 --> 09:10.570
你们以后在做彼式的时候

09:10.570 --> 09:12.570
一定要用这种方式

09:12.570 --> 09:13.570
去出错

09:13.570 --> 09:15.570
虽然这个题简单

09:15.570 --> 09:16.570
但是你可以要

09:16.570 --> 09:18.570
养成这个习惯

09:18.570 --> 09:19.570
不然的话

09:19.570 --> 09:20.570
你这个本身

09:20.570 --> 09:22.570
灰的题都做好了

09:22.570 --> 09:23.570
那就很划不来

09:23.570 --> 09:25.570
你不会的题错了

09:25.570 --> 09:26.570
你做不出来

09:26.570 --> 09:27.570
那是无所谓嘛

09:27.570 --> 09:28.570
拆嘛拆错了

09:28.570 --> 09:29.570
无所谓

09:29.570 --> 09:30.570
本来就不会

09:30.570 --> 09:31.570
那你灰的题都要做错

09:31.570 --> 09:32.570
那就太划不来了

09:32.570 --> 09:33.570
好

09:33.570 --> 09:34.570
我们这里呢

09:34.570 --> 09:35.570
这个函数进入了

09:35.570 --> 09:36.570
v队列等待执行

09:36.570 --> 09:38.570
然后我们继续执行全聚上下关

09:38.570 --> 09:40.570
是不是输出了4

09:40.570 --> 09:41.570
然后全聚上下关执行结束了

09:41.570 --> 09:42.570
没有什么东西可以执行的

09:42.570 --> 09:43.570
这个时候呢

09:43.570 --> 09:44.570
从v队列里面

09:44.570 --> 09:45.570
拿出这个函数来执行

09:45.570 --> 09:47.570
是不是输出了3

09:47.570 --> 09:48.570
对吧

09:48.570 --> 09:49.570
就1243

09:50.570 --> 09:51.570
什么意思

09:51.570 --> 09:52.570
好

09:52.570 --> 09:53.570
我们再运行

09:53.570 --> 09:54.570
1243

09:54.570 --> 09:55.570
好

09:55.570 --> 09:56.570
这是第1道题

09:57.570 --> 09:58.570
好

09:58.570 --> 10:01.330
第2道题

10:01.330 --> 10:03.330
再把Copy过来

10:04.330 --> 10:05.330
扔过来

10:06.330 --> 10:07.330
一样的做法

10:07.330 --> 10:08.330
你们呢

10:08.330 --> 10:09.330
自己试一下

10:10.330 --> 10:11.330
自己试一下

10:11.330 --> 10:12.330
这道题就纯粹端的

10:12.330 --> 10:13.330
就是其实跟刚才的题

10:13.330 --> 10:15.330
没有什么本质的区别

10:15.330 --> 10:16.330
你们试一下

10:16.330 --> 10:18.330
用刚才的分析方式来做一下

10:18.330 --> 10:19.330
好了没

10:19.330 --> 10:20.330
我不知道你们做的答案

10:20.330 --> 10:21.330
是不是正确的

10:21.330 --> 10:22.330
相信如果说

10:22.330 --> 10:23.330
你听懂了我之前的

10:23.330 --> 10:24.330
解释的话

10:24.330 --> 10:25.330
应该能够做出来

10:25.330 --> 10:26.330
好 又来吧

10:26.330 --> 10:27.330
这里创建了一个Promise

10:27.330 --> 10:28.330
那么我们这里

10:28.330 --> 10:29.330
它有一个Promise

10:29.330 --> 10:31.330
它的状态是什么呢

10:31.330 --> 10:32.330
Pending

10:32.330 --> 10:33.330
写好

10:33.330 --> 10:34.330
接下来

10:34.330 --> 10:36.330
运行这个任务

10:36.330 --> 10:37.330
任务开始进行

10:37.330 --> 10:38.330
输出1

10:40.330 --> 10:41.330
接下来

10:41.330 --> 10:42.330
CTime Out

10:42.330 --> 10:43.330
这里有一个函数

10:43.330 --> 10:44.330
那么我没有传

10:44.330 --> 10:45.330
第二个函数

10:45.330 --> 10:46.330
就是没有传

10:46.330 --> 10:47.330
等待时间

10:47.330 --> 10:48.330
没有传等待时间

10:48.330 --> 10:49.330
就相当于是传了个0

10:50.330 --> 10:51.330
说明这个函数

10:51.330 --> 10:53.330
马上要被执行

10:53.330 --> 10:54.330
这个

10:54.330 --> 10:56.330
时间循环的知识

10:56.330 --> 10:57.330
不需要重新的演示了吧

10:57.330 --> 10:59.330
调用CTime Out函数

11:01.330 --> 11:02.330
CTime Out函数

11:03.330 --> 11:05.330
通知计时现成

11:05.330 --> 11:06.330
你过计时

11:06.330 --> 11:07.330
计时结束过后

11:07.330 --> 11:08.330
运行一个函数Fn

11:08.330 --> 11:10.330
计时马上就结束了

11:10.330 --> 11:11.330
所以放到V队的

11:11.330 --> 11:12.330
而红队的

11:13.330 --> 11:14.330
对吧

11:14.330 --> 11:15.330
进入这儿了

11:15.330 --> 11:16.330
所以说呢

11:16.330 --> 11:18.330
我们这一步执行完了之后

11:18.330 --> 11:19.330
实际上我们的红队的里面

11:19.330 --> 11:20.330
有一个函数

11:20.330 --> 11:21.330
就是Fn

11:21.330 --> 11:22.330
你心里面清楚

11:22.330 --> 11:23.330
就是这个函数

11:23.330 --> 11:24.330
就行了

11:24.330 --> 11:25.330
进入了红队的

11:25.330 --> 11:26.330
等待被执行

11:26.330 --> 11:27.330
现在执行完没

11:27.330 --> 11:28.330
没有执行

11:28.330 --> 11:29.330
然后把这个Promise

11:29.330 --> 11:30.330
复制给谁

11:30.330 --> 11:31.330
复制给这个辩量

11:33.330 --> 11:34.330
复制给他

11:35.330 --> 11:36.330
对吧

11:36.330 --> 11:37.330
所以他的状态是Pending

11:37.330 --> 11:38.330
因此

11:38.330 --> 11:39.330
如果说你在这里

11:39.330 --> 11:40.330
Promise

11:40.330 --> 11:42.330
之前是不是可以解释了

11:42.330 --> 11:43.330
为什么在这里

11:43.330 --> 11:44.330
输出Promise

11:44.330 --> 11:45.330
得到的状态呢

11:45.330 --> 11:46.330
是什么

11:46.330 --> 11:47.330
得到的状态

11:47.330 --> 11:48.330
是Pending

11:48.330 --> 11:49.330
就这个原因

11:53.110 --> 11:55.110
得到的状态是不是Pending

11:55.110 --> 11:56.110
对吧

11:56.110 --> 11:57.110
好

11:57.110 --> 11:58.110
继续来分析

12:04.260 --> 12:05.260
现在这些东西

12:05.260 --> 12:06.260
大家都还不执行

12:06.260 --> 12:07.260
一个函数的

12:07.260 --> 12:08.260
在红队的里面

12:08.260 --> 12:09.260
等待执行

12:09.260 --> 12:10.260
接下来

12:10.260 --> 12:11.260
告诉Promise

12:11.260 --> 12:13.260
如果说

12:13.260 --> 12:14.260
你运行

12:14.260 --> 12:15.260
你成功之后

12:15.260 --> 12:16.260
请运行这个回掉

12:16.260 --> 12:17.260
那么这里

12:17.260 --> 12:18.260
现在有个问题了

12:18.260 --> 12:19.260
这个回掉函数

12:19.260 --> 12:21.260
现在进不进围队

12:22.260 --> 12:23.260
进不进

12:24.260 --> 12:25.260
不进的

12:25.260 --> 12:27.260
为什么不进呢

12:27.260 --> 12:28.260
他要等他完成之后

12:28.260 --> 12:29.260
才能进围队列

12:29.260 --> 12:30.260
现在是完成

12:30.260 --> 12:32.260
现在是挂起的状态

12:32.260 --> 12:33.260
对吧

12:33.260 --> 12:34.260
所以这个函数

12:34.260 --> 12:35.260
是不会进入围队列的

12:35.260 --> 12:36.260
你只要等这个函数

12:36.260 --> 12:37.260
什么时候进围队列

12:37.260 --> 12:38.260
我都

12:38.260 --> 12:39.260
我一些不清楚

12:39.260 --> 12:40.260
他什么时候完成

12:40.260 --> 12:41.260
什么时候进围队列

12:41.260 --> 12:42.260
所以这个函数

12:42.260 --> 12:43.260
现在还不着急

12:43.260 --> 12:44.260
我只是告诉Promise

12:44.260 --> 12:45.260
以后

12:45.260 --> 12:46.260
将来有一天

12:46.260 --> 12:48.260
比方说你一年之后完成了

12:48.260 --> 12:49.260
一年之后

12:49.260 --> 12:50.260
这个函数进围队的

12:50.260 --> 12:51.260
是这么个意思

12:52.260 --> 12:53.260
然后就输出五

12:53.260 --> 12:54.260
所以说这里可能看到的输出

12:54.260 --> 12:56.260
最开始就是一和五

12:57.260 --> 12:58.260
好 接下来

12:58.260 --> 12:59.260
时间

12:59.260 --> 13:00.260
接下来干嘛呢

13:00.260 --> 13:01.260
全局常常问

13:01.260 --> 13:02.260
执行结束了

13:02.260 --> 13:03.260
没事情做了

13:03.260 --> 13:05.260
就把红队列的东西

13:05.260 --> 13:06.260
拿出来执行

13:06.260 --> 13:07.260
执行哪

13:07.260 --> 13:08.260
执行这个函数

13:08.260 --> 13:09.260
执行这个函数的过程中

13:09.260 --> 13:11.260
红队列拿出来执行

13:11.260 --> 13:12.260
执行这个函数的过程中

13:12.260 --> 13:13.260
输出了什么

13:13.260 --> 13:14.260
输出了二

13:15.260 --> 13:16.260
然后呢

13:16.260 --> 13:17.260
把这个Promise的状态

13:17.260 --> 13:18.260
改为了

13:19.260 --> 13:20.260
Fullfield

13:21.260 --> 13:22.260
数据上离范

13:23.260 --> 13:24.260
然后再输出三

13:25.260 --> 13:27.770
好 应该是

13:27.770 --> 13:28.770
应该是这样的过程

13:28.770 --> 13:29.770
不好意思

13:29.770 --> 13:30.770
先输出二

13:30.770 --> 13:31.770
然后呢

13:31.770 --> 13:32.770
更改状态

13:32.770 --> 13:33.770
改状态的时候

13:34.770 --> 13:35.770
之前是不是说好的

13:35.770 --> 13:36.770
你一旦完成之后

13:36.770 --> 13:38.770
执行这个函数

13:38.770 --> 13:39.770
对吧

13:39.770 --> 13:40.770
所以说这里状态一变

13:40.770 --> 13:41.770
这个时候

13:41.770 --> 13:42.770
它会把这个函数

13:42.770 --> 13:44.770
加入到围队里

13:44.770 --> 13:45.770
这个函数

13:45.770 --> 13:47.770
估计把它命名为FN4

13:47.770 --> 13:48.770
数数4

13:49.770 --> 13:50.770
但是那些

13:50.770 --> 13:51.770
不执行围队列

13:51.770 --> 13:52.770
不执行

13:52.770 --> 13:53.770
为什么

13:53.770 --> 13:54.770
因为我们现在执行站

13:54.770 --> 13:55.770
还有东西没执行完

13:55.770 --> 13:56.770
你不能说

13:56.770 --> 13:57.770
把这个函数执行到

13:57.770 --> 13:58.770
一半跑去执行围队列的

13:58.770 --> 14:00.770
虽然说你是VIP

14:00.770 --> 14:02.770
但是前面那个客户

14:02.770 --> 14:03.770
你

14:03.770 --> 14:04.770
VIP可以插队

14:04.770 --> 14:05.770
但是前面那个客户

14:05.770 --> 14:06.770
你不能说

14:06.770 --> 14:07.770
搬业务搬了一半

14:08.770 --> 14:09.770
然后你不要

14:09.770 --> 14:10.770
你让它走

14:10.770 --> 14:11.770
然后把后边的客户

14:11.770 --> 14:12.770
然后再过来

14:12.770 --> 14:13.770
不能这样子

14:13.770 --> 14:14.770
这样子太霸道了

14:14.770 --> 14:16.770
所以这个函数执行完

14:16.770 --> 14:18.770
执行站必须要清空之后

14:18.770 --> 14:19.770
再看围队的

14:19.770 --> 14:21.770
再看这个队列

14:21.770 --> 14:22.770
然后先找围队的

14:22.770 --> 14:23.770
再找空队的

14:23.770 --> 14:24.770
但是变成正在执行

14:24.770 --> 14:25.770
你不能打断

14:26.770 --> 14:27.770
然后再输出3

14:28.770 --> 14:29.770
对吧

14:29.770 --> 14:30.770
然后这个函数是不是执行完了

14:31.770 --> 14:32.770
执行完了执行站清空了

14:32.770 --> 14:33.770
没有什么东西

14:33.770 --> 14:34.770
可以执行的

14:34.770 --> 14:35.770
这个时候

14:35.770 --> 14:36.770
把围队里边的东西

14:36.770 --> 14:37.770
FN4拿出来执行

14:37.770 --> 14:38.770
于是输出4

14:39.770 --> 14:40.770
1,2,3,4

14:41.770 --> 14:42.770
好

14:43.770 --> 14:44.770
执行

14:44.770 --> 14:45.770
1,2,3,4

14:46.770 --> 14:47.770
这些题呢

14:47.770 --> 14:49.770
其实无论它怎么考虑

14:49.770 --> 14:51.770
它可以用各种各样的变形

14:51.770 --> 14:52.770
变种

14:52.770 --> 14:53.770
都无所谓

14:53.770 --> 14:54.770
比方说我们这里

14:54.770 --> 14:55.770
还可以把这个题

14:55.770 --> 14:56.770
变成这样的形式

14:57.770 --> 14:58.770
然后再在上边去

14:58.770 --> 15:00.770
设置一个set time out

15:01.770 --> 15:05.780
这里输出一个

15:05.780 --> 15:10.780
1,2,3,4

15:11.780 --> 15:12.780
看这个题吧

15:13.780 --> 15:14.780
那到底是一样的

15:14.780 --> 15:15.780
你们自己先做一下

15:16.780 --> 15:17.780
我来讲一讲

15:18.780 --> 15:19.780
首先第一步

15:19.780 --> 15:21.780
0秒后运行这个函数

15:21.780 --> 15:22.780
所以说一开始

15:22.780 --> 15:23.780
有个红队列

15:25.780 --> 15:26.780
红队列里边

15:26.780 --> 15:27.780
是一个函数

15:27.780 --> 15:28.780
FN

15:28.780 --> 15:29.780
就这个函数

15:29.780 --> 15:30.780
把FN1输出1

15:31.780 --> 15:32.780
到红队列

15:32.780 --> 15:33.780
然后接着执行

15:34.780 --> 15:35.780
执行的时候

15:35.780 --> 15:36.780
得到一个promise

15:36.780 --> 15:37.780
这个promise的状态

15:37.780 --> 15:38.780
一开始是平顶

15:38.780 --> 15:39.780
然后输出一个2

15:40.780 --> 15:41.780
对吧

15:41.780 --> 15:42.780
然后把这个promise的状态

15:42.780 --> 15:43.780
改成ful fill的

15:45.780 --> 15:46.780
数据商计犯的

15:47.780 --> 15:48.780
把这个promise的复制给它

15:48.780 --> 15:49.780
那么它的状态

15:49.780 --> 15:50.780
就是这个东西

15:51.780 --> 15:53.780
接下来告诉promise

15:53.780 --> 15:54.780
如果说你完成了

15:54.780 --> 15:55.780
运行这个毁掉函数

15:56.780 --> 15:57.780
完成了吗

15:57.780 --> 15:58.780
所以说完成了

15:58.780 --> 15:59.780
所以说

15:59.780 --> 16:00.780
红队列里边

16:00.780 --> 16:01.780
就会加入一个毁掉函数

16:01.780 --> 16:02.780
FN3

16:02.780 --> 16:03.780
输出3的毁掉函数

16:04.780 --> 16:05.780
然后再输出4

16:05.780 --> 16:06.780
接下来执行站轻空了

16:06.780 --> 16:07.780
没有什么东西

16:07.780 --> 16:08.780
可以执行了

16:08.780 --> 16:09.780
然后我们就看什么

16:09.780 --> 16:10.780
看时间对列

16:10.780 --> 16:11.780
VIP先来

16:12.780 --> 16:13.780
FN3

16:13.780 --> 16:14.780
是不是先运行它

16:14.780 --> 16:15.780
输出3

16:16.780 --> 16:17.780
为对列轻空

16:18.780 --> 16:19.780
然后再看红队列

16:19.780 --> 16:20.780
FN1

16:22.780 --> 16:23.780
输出1

16:23.780 --> 16:24.780
那么就是231

16:28.500 --> 16:29.500
对吧

16:29.500 --> 16:30.500
用这种方式去解体

16:31.500 --> 16:32.500
好 下道题

16:32.500 --> 16:33.500
第三题

16:34.500 --> 16:38.390
这道题我们好像是说过的

16:38.390 --> 16:40.770
来吧

16:40.770 --> 16:41.770
我们再来一次

16:42.770 --> 16:47.300
首先你们先做

16:47.300 --> 16:48.300
北道题都是你们先做

16:48.300 --> 16:49.300
自己先做

16:49.300 --> 16:50.300
要做来听我讲

16:50.300 --> 16:51.300
好

16:51.300 --> 16:54.300
首先是拿到Promise

16:54.300 --> 16:55.300
状态是什么

16:55.300 --> 16:56.300
Pending

16:56.300 --> 16:57.300
想都没有想先写出来

16:58.300 --> 16:59.300
然后是一摊帽子

16:59.300 --> 17:00.300
一秒钟过后

17:02.300 --> 17:04.300
一秒钟过后运行这个函数

17:04.300 --> 17:05.300
所以说我们这里

17:05.300 --> 17:07.300
可以简单记录一下

17:07.300 --> 17:13.060
一秒后运行某一个函数

17:13.060 --> 17:14.060
就是有个计时

17:14.060 --> 17:15.060
现成的计时

17:15.060 --> 17:16.060
一秒后运行谁

17:16.060 --> 17:18.060
运行这个FN吗

17:18.060 --> 17:19.060
把这个函数叫做FN

17:20.060 --> 17:21.060
好 现在一秒钟的话

17:21.060 --> 17:23.060
还早 继续往后执行

17:23.060 --> 17:25.060
然后Promise1

17:28.060 --> 17:29.060
是不是Promise1

17:29.060 --> 17:31.060
如果失败的时候运行这个回教

17:31.060 --> 17:32.060
现在失败了吗

17:32.060 --> 17:33.060
没有吧

17:33.060 --> 17:35.060
现在是Pending还是挂起阶段

17:35.060 --> 17:36.060
我都不知道他要不要失败

17:36.060 --> 17:37.060
对吧

17:37.060 --> 17:39.060
任务都还没有结果

17:39.060 --> 17:40.060
所以我也不知道他要不要失败

17:40.060 --> 17:41.060
让大家说一声

17:41.060 --> 17:43.060
失败之后

17:43.060 --> 17:45.060
失败后运行了

17:45.060 --> 17:47.060
这个是FN2

17:47.060 --> 17:49.060
那么得到一个新的Promise

17:49.060 --> 17:51.060
刚才的是Promise1

17:51.060 --> 17:55.780
那么Promise1

17:55.780 --> 17:56.780
调用开启方法

17:56.780 --> 17:58.780
是返回一个新的Promise

17:58.780 --> 18:01.780
那么Promise2的状态是什么

18:01.780 --> 18:03.780
这个地方考察的是啥

18:03.780 --> 18:05.780
考察的是这一块的知识

18:05.780 --> 18:09.470
链式调用

18:09.470 --> 18:10.470
链式调用为止

18:10.470 --> 18:11.470
你自己去看一下

18:11.470 --> 18:13.470
我们之前也是反复了讲过的

18:13.470 --> 18:15.470
它的状态取决于

18:15.470 --> 18:17.470
前边这个任务的状态

18:17.470 --> 18:18.470
前面是挂起

18:18.470 --> 18:19.470
无论是什么情况

18:19.470 --> 18:20.470
前面是挂起

18:20.470 --> 18:21.470
他一定挂起

18:21.470 --> 18:22.470
100%挂起

18:22.470 --> 18:25.470
他的状态一定是挂起

18:25.470 --> 18:26.470
他的状态

18:26.470 --> 18:28.470
他也没有结果

18:28.470 --> 18:29.470
好

18:29.470 --> 18:31.470
接下来输出Promise1和Promise2

18:31.470 --> 18:33.470
那么Promise1的状态

18:33.470 --> 18:34.470
是不是

18:34.470 --> 18:35.470
Pending

18:35.470 --> 18:37.470
Promise2的状态

18:37.470 --> 18:39.470
是不是Pending

18:39.470 --> 18:40.470
对吧

18:40.470 --> 18:42.470
然后在那两秒后

18:42.470 --> 18:43.470
又来

18:43.470 --> 18:45.470
两秒后

18:45.470 --> 18:46.470
运行什么呢

18:46.470 --> 18:47.470
运行

18:47.470 --> 18:48.470
这个回合

18:48.470 --> 18:50.470
Fm3

18:50.470 --> 18:51.470
好

18:51.470 --> 18:52.470
接下来

18:52.470 --> 18:53.470
我们现在事情是不是说完了

18:53.470 --> 18:54.470
没有什么代表可以执行

18:54.470 --> 18:55.470
接下来我们等什么

18:55.470 --> 18:56.470
就等时间

18:56.470 --> 18:57.470
一秒后

18:57.470 --> 18:59.470
这个东西到了

18:59.470 --> 19:00.470
一秒后就到了

19:00.470 --> 19:02.470
是不是运行这个喊说

19:02.470 --> 19:03.470
这个喊出来干嘛

19:03.470 --> 19:05.470
是把Promise1的状态

19:05.470 --> 19:08.470
改为FullFilled

19:08.470 --> 19:10.470
数据上笔带

19:10.470 --> 19:12.470
对吧

19:13.470 --> 19:15.470
好那么Promise1的状态

19:15.470 --> 19:17.470
那么一秒后就完成了这个事

19:17.470 --> 19:19.470
他就做了这么一件事

19:19.470 --> 19:21.470
好那么Promise1的状态

19:21.470 --> 19:22.470
变成FullFilled之后呢

19:22.470 --> 19:24.470
有这么连续

19:24.470 --> 19:26.470
两件事就可以确定了

19:26.470 --> 19:28.470
第一件事

19:28.470 --> 19:30.470
Promise1

19:30.470 --> 19:31.470
有没有成

19:31.470 --> 19:32.470
它是成功了对吧

19:32.470 --> 19:34.470
有没有成功的毁掉

19:34.470 --> 19:35.470
没有

19:35.470 --> 19:36.470
它只有失败的毁掉

19:36.470 --> 19:37.470
说成功的毁掉

19:37.470 --> 19:39.470
没法执行上

19:39.470 --> 19:41.470
第二

19:41.470 --> 19:43.470
后边这个任务的状态

19:43.470 --> 19:45.470
要发生相应的变化

19:45.470 --> 19:46.470
怎么变化呢

19:46.470 --> 19:48.470
看那个123

19:48.470 --> 19:50.470
看这123

19:50.470 --> 19:54.870
三条 规则

19:54.870 --> 19:55.870
什么情况

19:55.870 --> 19:58.870
前边这个任务完成了

19:58.870 --> 20:00.870
但是呢

20:00.870 --> 20:01.870
后边

20:01.870 --> 20:02.870
它没有针对完成

20:02.870 --> 20:03.870
做相应的处理

20:03.870 --> 20:05.870
没有相应的后续处理

20:05.870 --> 20:06.870
这就导致了

20:06.870 --> 20:08.870
后边那个任务的状态

20:08.870 --> 20:09.870
和数据

20:09.870 --> 20:14.570
跟前边那个任务保持一致

20:14.570 --> 20:17.570
Promise2的状态变成这样子了

20:17.570 --> 20:18.570
就变成这样子了

20:18.570 --> 20:19.570
这个函数执行吗

20:19.570 --> 20:20.570
它不执行

20:20.570 --> 20:22.570
因为它是失败的毁掉

20:22.570 --> 20:24.570
并不是成功的毁掉

20:24.570 --> 20:25.570
没啥意思吧

20:25.570 --> 20:27.570
所以这个函数是不执行的

20:27.570 --> 20:28.570
然后呢

20:28.570 --> 20:29.570
两秒后

20:29.570 --> 20:30.570
我们再输出

20:30.570 --> 20:31.570
输出两个Promise

20:31.570 --> 20:32.570
得到的结果就是

20:32.570 --> 20:35.570
就这样的结果

20:35.570 --> 20:37.570
好 这道题就这样子出来了

20:37.570 --> 20:39.570
另一条

20:39.570 --> 20:41.570
两秒后

20:41.570 --> 20:42.570
你看 回去出来了

20:42.570 --> 20:43.570
两个都完成

20:43.570 --> 20:47.140
数据都是 Undefined

20:47.140 --> 20:48.140
好 再来看

20:48.140 --> 20:49.140
如果说我这里写的是

20:49.140 --> 20:50.140
Rege 1的成本

20:50.140 --> 20:54.280
又来分析一下

20:54.280 --> 20:56.280
又来呗

20:56.280 --> 20:59.280
好 那么刚才的唯一的变化就是什么呢

20:59.280 --> 21:01.280
变化就是在这

21:01.280 --> 21:03.280
一开始都没有问题的

21:03.280 --> 21:04.280
都是陪你

21:04.280 --> 21:06.280
这个里面自己去分析

21:06.280 --> 21:07.280
就在这

21:07.280 --> 21:08.280
我这个一秒后

21:08.280 --> 21:09.280
把这个Rege借个成的时候呢

21:09.280 --> 21:11.280
它的状态不是Fulfilled的了

21:11.280 --> 21:12.280
它的状态是什么

21:12.280 --> 21:14.280
Rege借个题的

21:14.280 --> 21:15.280
原因是什么

21:15.280 --> 21:16.280
没有给

21:16.280 --> 21:18.280
没有给的话就是 Undefined

21:18.280 --> 21:20.280
变这样子

21:20.280 --> 21:23.280
然后Promise 2的状态是什么呢

21:23.280 --> 21:25.280
它被拒绝了

21:25.280 --> 21:26.280
有没有后续处理

21:26.280 --> 21:28.280
你看 是不是有后续处理

21:28.280 --> 21:30.280
F2要做什么

21:30.280 --> 21:32.280
进入围队的

21:32.280 --> 21:33.280
对吧

21:33.280 --> 21:36.280
F2是要进入围队的执行

21:36.280 --> 21:37.280
Promise 2的状态

21:37.280 --> 21:39.280
就取决于

21:39.280 --> 21:41.280
这个函数的执行结果

21:41.280 --> 21:42.280
所以说

21:42.280 --> 21:44.280
这个时候要去执行这个函数

21:44.280 --> 21:45.280
执行的过程中

21:45.280 --> 21:46.280
有没有错误

21:46.280 --> 21:47.280
没有错误

21:47.280 --> 21:48.280
没有错误

21:48.280 --> 21:49.280
Promise 2

21:49.280 --> 21:52.280
得到了状态就是Fulfilled

21:52.280 --> 21:53.280
数据是什么

21:53.280 --> 21:54.280
数据12

21:54.280 --> 21:57.280
返回的结果就是它的数据

21:57.280 --> 21:58.280
因此两秒后

21:58.280 --> 22:00.280
把这两个Promise输出

22:00.280 --> 22:04.740
得到的结果就是这样子

22:04.740 --> 22:10.320
看一下

22:10.320 --> 22:14.320
你看 是不是这样子

22:14.320 --> 22:15.320
好 这是这种题

22:15.320 --> 22:17.320
联系调用这一块呢

22:17.320 --> 22:19.320
会有点糟

22:19.320 --> 22:21.320
但是你按照我这个分析的话

22:21.320 --> 22:22.320
是没有任何问题的

22:22.320 --> 22:26.020
好 接下来下一道题

22:26.020 --> 22:30.950
三 四

22:30.950 --> 22:32.950
好 这道题

22:32.950 --> 22:37.160
看一下吧

22:37.160 --> 22:40.160
这道题是不是

22:40.160 --> 22:42.160
其实这道题的本质上

22:42.160 --> 22:44.160
也就是考的是Promise

22:44.160 --> 22:45.160
只是它用了

22:45.160 --> 22:46.160
余法堂

22:46.160 --> 22:48.160
而Think和Await

22:48.160 --> 22:49.160
干扰你

22:49.160 --> 22:51.160
其实本质上就是Promise

22:51.160 --> 22:53.160
来吧

22:53.160 --> 22:55.160
这里是函数生命

22:55.160 --> 22:56.160
生命函数

22:56.160 --> 22:57.160
只是任何结果

22:57.160 --> 22:59.160
我们关键是关注的是函数调用

22:59.160 --> 23:02.160
这里调用了M函数

23:02.160 --> 23:04.160
是不是调用了M函数

23:04.160 --> 23:06.160
M函数里边

23:06.160 --> 23:08.160
我们等待了一个E

23:08.160 --> 23:09.160
等待E是什么呢

23:09.160 --> 23:13.160
是不是等待了Promise Resolve E

23:13.160 --> 23:14.160
相当于是这样子写的

23:14.160 --> 23:15.160
对吧

23:15.160 --> 23:16.160
我之前说过的

23:16.160 --> 23:17.160
这里如果说直接写个数据的话

23:17.160 --> 23:19.160
就相当于是用这种方式来写

23:19.160 --> 23:21.160
等待一个E

23:21.160 --> 23:23.160
是不是等待了一个Promise完成

23:23.160 --> 23:25.160
那么后边注意

23:25.160 --> 23:27.160
看我鼠标框住了一部分

23:27.160 --> 23:28.160
这一部分

23:28.160 --> 23:29.160
这一部分的代码

23:29.160 --> 23:34.160
实际上是在一个世界对列里

23:34.160 --> 23:37.160
你怎么理解呢

23:37.160 --> 23:39.160
你把这个函数

23:39.160 --> 23:41.160
想象成这种格式

23:41.160 --> 23:43.160
你就明白了

23:43.160 --> 23:51.310
而Think他只是个余法堂

23:51.310 --> 23:53.310
等待E

23:53.310 --> 23:55.310
应该是这样子写的

23:55.310 --> 23:59.310
Returned是Promise Resolve E

23:59.310 --> 24:02.310
等待E返回的Z

24:02.310 --> 24:04.310
然后Z

24:04.310 --> 24:09.350
所以说看到没

24:09.350 --> 24:11.350
它实际上是这么写的

24:11.350 --> 24:14.350
把这个给N复指

24:14.350 --> 24:16.350
放到这参数里边

24:16.350 --> 24:18.350
然后再输出N放到这

24:18.350 --> 24:23.050
明儿里说它本质上是这个样子

24:23.050 --> 24:24.050
所以说我们再回来

24:24.050 --> 24:28.190
看这个函数

24:28.190 --> 24:30.190
我们在这边再加一个

24:30.190 --> 24:32.190
加一个输出0

24:32.190 --> 24:33.190
来吧

24:33.190 --> 24:35.190
运行这个函数

24:35.190 --> 24:36.190
什么马上就会输出0

24:36.190 --> 24:38.190
这个没问题吧

24:38.190 --> 24:39.190
这个函数马上得到运行

24:39.190 --> 24:40.190
输出0

24:40.190 --> 24:43.190
好 接下来等待E

24:43.190 --> 24:45.190
那么后边是不是全在N里边

24:45.190 --> 24:48.190
相当于是给N复指

24:48.190 --> 24:49.190
给N复指的代码

24:49.190 --> 24:51.190
和给输出N

24:51.190 --> 24:53.190
是不是都在N里边

24:53.190 --> 24:55.190
它等待完成之后

24:55.190 --> 24:56.190
我才给它复指

24:56.190 --> 24:59.190
N是完成之后的数据

24:59.190 --> 25:01.190
完成的数据是不是就是E

25:01.190 --> 25:04.190
E的本质就是这个

25:04.190 --> 25:05.190
在这里而为什么后边写E

25:05.190 --> 25:06.190
就相当于是写了这个

25:06.190 --> 25:08.190
我们之前说过的

25:08.190 --> 25:10.190
那么相当于是Promise完成之后

25:10.190 --> 25:11.190
我才去运行这个代码

25:11.190 --> 25:13.190
所以给N复指的代码

25:13.190 --> 25:15.190
和给输出N

25:15.190 --> 25:20.190
实际上它本质是在V对列里边

25:20.190 --> 25:22.190
输出

25:22.190 --> 25:23.190
相当于输出E

25:23.190 --> 25:25.190
是在V对列里边

25:25.190 --> 25:26.190
这个代码

25:26.190 --> 25:28.190
你要这么去看

25:28.190 --> 25:30.190
因为它用余法藏在干擾里

25:30.190 --> 25:31.190
比方说

25:31.190 --> 25:33.190
这里Promise等待一年

25:33.190 --> 25:36.190
难道我就在这里卡住等它一年吗

25:36.190 --> 25:37.190
那不可能

25:37.190 --> 25:40.190
我们说过GSE是一个异部的语言

25:40.190 --> 25:42.190
它不可能有主色的

25:42.190 --> 25:43.190
它不会真正的去等它

25:43.190 --> 25:44.190
我就干别的事去了

25:44.190 --> 25:45.190
什么时候玩

25:45.190 --> 25:48.190
我就在接着把后边的代码执行了

25:48.190 --> 25:50.190
因此我调用M函数

25:50.190 --> 25:51.190
它输出了N之后

25:51.190 --> 25:53.190
它不会让这里

25:53.190 --> 25:55.190
不会让M函数卡住

25:55.190 --> 25:56.190
所以这里一定要清楚

25:56.190 --> 25:58.190
它不会让M函数卡住

25:58.190 --> 26:00.190
M函数就直接结束了

26:00.190 --> 26:02.190
在这里就结束了

26:02.190 --> 26:03.190
就像这里一样

26:03.190 --> 26:06.190
调用M函数返回Promise结束了

26:06.190 --> 26:07.190
它不是说

26:07.190 --> 26:09.190
我一定要等到这个毁掉之行过

26:09.190 --> 26:10.190
我才会结束

26:10.190 --> 26:11.190
那你这样想吧

26:11.190 --> 26:12.190
我这个任务

26:12.190 --> 26:13.190
异部任务

26:13.190 --> 26:15.190
我这个任务不是立即完成的

26:15.190 --> 26:17.190
我是要等10年才完成

26:17.190 --> 26:18.190
那里说你这个函数

26:18.190 --> 26:20.190
要在卡10年

26:20.190 --> 26:22.190
后边代码就不运行了

26:22.190 --> 26:23.190
一直在等它卡10年

26:23.190 --> 26:24.190
那可能吗

26:24.190 --> 26:25.190
不可能

26:25.190 --> 26:26.190
所以说

26:26.190 --> 26:28.190
函数马上就去

26:28.190 --> 26:30.190
瞬间就结束了

26:30.190 --> 26:32.190
运行返回Promise结束了

26:32.190 --> 26:34.190
这些代码等Promise完成之后

26:34.190 --> 26:36.190
它自然回去运行

26:36.190 --> 26:37.190
所以这里

26:37.190 --> 26:38.190
把它换成这种格式

26:38.190 --> 26:39.190
实际上是一样的

26:39.190 --> 26:41.190
我输出了0

26:41.190 --> 26:42.190
遇到这个代码

26:42.190 --> 26:43.190
这个函数结束了

26:43.190 --> 26:45.190
接下来输出2

26:45.190 --> 26:47.190
你要这样子去看

26:47.190 --> 26:52.080
输出2完了之后

26:52.080 --> 26:54.080
再看V对列

26:54.080 --> 26:57.080
V对列是不是在运行这段代码

26:57.080 --> 26:59.080
给N负责再输出N

26:59.080 --> 27:01.080
是不是输出1

27:01.080 --> 27:02.080
所以这个代码

27:02.080 --> 27:07.030
这道题的答案是021

27:07.030 --> 27:08.030
是吧

27:08.030 --> 27:11.030
好好去理一下

27:11.030 --> 27:12.030
这道题

27:12.030 --> 27:14.030
下面第五题

27:14.030 --> 27:21.840
也是考堂类似的东西

27:21.840 --> 27:23.840
稍微做了一下变化

27:23.840 --> 27:24.840
也就是刚才的题

27:24.840 --> 27:25.840
稍微做了一下变化

27:25.840 --> 27:26.840
那么我说

27:26.840 --> 27:28.840
这里还是从0开始输出

27:28.840 --> 27:39.190
来看一下这个题

27:39.190 --> 27:41.190
本质上是一样的

27:41.190 --> 27:42.190
来吧

27:42.190 --> 27:43.190
这里是一个函数声明

27:43.190 --> 27:44.190
不用管它

27:44.190 --> 27:45.190
这里是一个立即执行函数

27:45.190 --> 27:47.190
那么执行的是谁

27:47.190 --> 27:48.190
执行的是这个函数

27:48.190 --> 27:49.190
对吧

27:49.190 --> 27:50.190
执行这个函数

27:50.190 --> 27:51.190
然后执行这个函数

27:51.190 --> 27:53.190
调用M函数

27:53.190 --> 27:55.630
调用M函数

27:55.630 --> 27:56.630
是不是在调用这个

27:56.630 --> 27:58.630
那么先执行M函数

27:58.630 --> 27:59.630
M函数

27:59.630 --> 28:00.630
好

28:00.630 --> 28:02.630
执行M函数是不是先出出0

28:02.630 --> 28:04.630
对吧

28:04.630 --> 28:07.630
然后等待1

28:07.630 --> 28:09.630
等待1

28:09.630 --> 28:12.630
我这里是不是会卡住

28:12.630 --> 28:13.630
不会卡住

28:13.630 --> 28:15.630
是立即就执行结束了

28:15.630 --> 28:16.630
所以说我们这

28:16.630 --> 28:17.630
后边给N复制

28:17.630 --> 28:18.630
输出N在哪

28:18.630 --> 28:21.630
在V队里

28:21.630 --> 28:23.630
给N复制输出N

28:23.630 --> 28:25.630
那就相当于是输出1嘛

28:25.630 --> 28:26.630
输出1是在哪

28:26.630 --> 28:29.630
是在V队里边等着

28:29.630 --> 28:30.630
好

28:30.630 --> 28:31.630
那么就回过头来

28:31.630 --> 28:32.630
这个M函数是不是

28:32.630 --> 28:34.630
返回了一个Promise

28:34.630 --> 28:37.630
M函数是不是返回了一个Promise

28:37.630 --> 28:38.630
那么请问

28:38.630 --> 28:40.630
我现在问大家一个问题

28:40.630 --> 28:42.630
这个Promise的状态是啥

28:42.630 --> 28:44.630
状态是啥

28:44.630 --> 28:45.630
那也就是说

28:45.630 --> 28:47.630
我现在把个代码全部去掉

28:47.630 --> 28:48.630
我输出一下

28:48.630 --> 28:49.630
M函数

28:49.630 --> 28:50.630
交融M函数的返回结果

28:50.630 --> 28:51.630
这个一定是输出Promise

28:51.630 --> 28:52.630
对吧

28:52.630 --> 28:53.630
这毫无疑问

28:53.630 --> 28:54.630
因为它是而胜可标记的

28:54.630 --> 28:56.630
那么这个函数的状态是啥

28:56.630 --> 28:58.630
这个时候输出的状态

28:58.630 --> 29:00.630
我们先把这个东西看懂

29:00.630 --> 29:03.630
状态是啥

29:03.630 --> 29:05.630
状态是平顶挂机

29:05.630 --> 29:06.630
为什么是平顶呢

29:06.630 --> 29:07.630
因为这个函数还

29:07.630 --> 29:08.630
还没完啊

29:08.630 --> 29:09.630
虽然我们知道

29:09.630 --> 29:10.630
它已经运行完了

29:10.630 --> 29:11.630
但是呢

29:11.630 --> 29:12.630
这个Promise

29:12.630 --> 29:13.630
它返回了一个Promise

29:13.630 --> 29:14.630
这个Promise

29:14.630 --> 29:15.630
是什么时候结束

29:15.630 --> 29:16.630
它要把这里面代码运行完了

29:16.630 --> 29:17.630
过后才结束

29:17.630 --> 29:18.630
才完成

29:18.630 --> 29:19.630
对吧

29:19.630 --> 29:20.630
因为这个代码运行完了之后

29:20.630 --> 29:21.630
才能确定返回之

29:21.630 --> 29:24.630
我这里相当于是返回了

29:24.630 --> 29:26.630
这还说没有运行完

29:26.630 --> 29:27.630
这个代码都还没有运行完

29:27.630 --> 29:29.630
所以说这个Promise

29:29.630 --> 29:32.630
还没有结束

29:32.630 --> 29:33.630
因此呢

29:33.630 --> 29:34.630
我们如果说这个时候

29:34.630 --> 29:36.630
这个时间减去输出

29:36.630 --> 29:38.630
得到的就是平顶

29:38.630 --> 29:39.630
没了意思

29:39.630 --> 29:45.840
因为这个函数还没运行完

29:45.840 --> 29:47.840
如果说把这段代码运行完了之后

29:47.840 --> 29:48.840
就输出1

29:48.840 --> 29:50.840
从微队那边取出完了过后

29:50.840 --> 29:51.840
那么这个函数的

29:51.840 --> 29:52.840
返回了Promise

29:52.840 --> 29:53.840
状态就可以确定了

29:53.840 --> 29:54.840
所以说我们再回到

29:54.840 --> 29:55.840
刚才的问题

29:55.840 --> 29:58.840
有点绕啊

29:58.840 --> 30:00.840
先输出0

30:00.840 --> 30:01.840
然后呢

30:01.840 --> 30:02.840
M函数就运行完了

30:02.840 --> 30:03.840
等待1

30:03.840 --> 30:05.840
还不会真正的在等待啊

30:05.840 --> 30:06.840
那么后边代码是

30:06.840 --> 30:07.840
放到微队那边了

30:07.840 --> 30:10.840
输出1

30:10.840 --> 30:11.840
对吧

30:11.840 --> 30:12.840
放到微队那边

30:12.840 --> 30:14.840
输出1

30:14.840 --> 30:16.840
那么这个函数返回了Promise

30:16.840 --> 30:17.840
刚才看过的

30:17.840 --> 30:19.840
是不是目前是挂起的

30:19.840 --> 30:21.840
因此

30:21.840 --> 30:23.840
这里要等待它完成

30:23.840 --> 30:24.840
换句话说

30:24.840 --> 30:26.840
什么时候Promise完成

30:26.840 --> 30:29.840
它必须要把这个1输出了之后

30:29.840 --> 30:31.840
才会完成

30:31.840 --> 30:33.840
所以说

30:33.840 --> 30:34.840
现在能输出2吗

30:34.840 --> 30:36.840
输出不了

30:36.840 --> 30:37.840
对不对

30:37.840 --> 30:38.840
是不是不能输出2

30:38.840 --> 30:41.840
没有办法输出2

30:41.840 --> 30:42.840
我要等现在

30:42.840 --> 30:43.840
等它完成

30:43.840 --> 30:44.840
它现在完成吗

30:44.840 --> 30:45.840
没有完成

30:45.840 --> 30:46.840
那我这边是不是

30:46.840 --> 30:47.840
也是要卡住呢

30:47.840 --> 30:48.840
我说

30:48.840 --> 30:49.840
这个函数

30:49.840 --> 30:50.840
是不是也会导致卡住呢

30:50.840 --> 30:51.840
不会

30:51.840 --> 30:52.840
因为这个函数

30:52.840 --> 30:53.840
而这个函数也是一样的

30:53.840 --> 30:54.840
你始终记住

30:54.840 --> 30:57.840
介石代码是永远不可能卡住的

30:57.840 --> 30:58.840
就是我

30:58.840 --> 30:59.840
因为我们知道

30:59.840 --> 31:01.840
浏览器的执行介石的线程

31:01.840 --> 31:03.840
跟那个渲染页面的线程是互斥的

31:03.840 --> 31:04.840
你执行介石的时候

31:04.840 --> 31:05.840
如果卡住了

31:05.840 --> 31:06.840
那就导致了页面上

31:06.840 --> 31:07.840
啥都不能动了

31:07.840 --> 31:09.840
连滚动条都不能滚动了

31:09.840 --> 31:11.840
介石原是一定不能卡住的

31:11.840 --> 31:13.840
它都是用异布的处理

31:13.840 --> 31:14.840
这个就是

31:14.840 --> 31:15.840
关键是你容易绕云的

31:15.840 --> 31:17.840
就是因为这个地方是愚法堂

31:17.840 --> 31:19.840
你看不到那个原式的

31:19.840 --> 31:20.840
Promise格式

31:20.840 --> 31:22.840
但是你始终记住

31:22.840 --> 31:23.840
而威者

31:23.840 --> 31:24.840
一旦出现了

31:24.840 --> 31:25.840
而威者关键制

31:25.840 --> 31:27.840
后边的代码

31:27.840 --> 31:29.840
它不是立即执行的

31:29.840 --> 31:31.840
它是要放到唯一队列里边的

31:31.840 --> 31:33.840
它会等待前面的Promise完成

31:33.840 --> 31:34.840
完成过后

31:34.840 --> 31:35.840
这个代码是会放到

31:35.840 --> 31:36.840
唯一队列里边的

31:36.840 --> 31:37.840
那么这里也是一样

31:37.840 --> 31:38.840
等待这个Promise完成

31:38.840 --> 31:39.840
完成之后

31:39.840 --> 31:40.840
我把输出二

31:40.840 --> 31:41.840
要放到唯一队列

31:41.840 --> 31:42.840
那现在有没有到唯一队列

31:42.840 --> 31:43.840
现在都没有

31:43.840 --> 31:45.840
因为这个Promise都没完成

31:45.840 --> 31:46.840
Promise什么时候完成

31:46.840 --> 31:48.840
我要把一输出了过后

31:48.840 --> 31:50.840
我要把这个代码运行过后

31:50.840 --> 31:51.840
我这个Promise才完成

31:51.840 --> 31:52.840
这个Promise完成过后

31:52.840 --> 31:53.840
这个代码才会

31:53.840 --> 31:54.840
到唯一队列

31:54.840 --> 31:55.840
对吧

31:55.840 --> 31:56.840
那现在还找得很

31:56.840 --> 31:58.840
所以说

31:58.840 --> 32:00.840
这个函数就执行完了

32:00.840 --> 32:01.840
它不会再傻了八句

32:01.840 --> 32:02.840
在这里等一年

32:02.840 --> 32:03.840
等它完成

32:03.840 --> 32:04.840
比方说

32:04.840 --> 32:05.840
我这里虽然说是立即完成

32:05.840 --> 32:06.840
但是

32:06.840 --> 32:08.840
那万一Promise完成

32:08.840 --> 32:09.840
时间也输不准

32:09.840 --> 32:10.840
那如果说

32:10.840 --> 32:11.840
这里用了一个

32:11.840 --> 32:12.840
定内函数

32:12.840 --> 32:13.840
对吧

32:13.840 --> 32:14.840
我们之前写过的定内函数

32:14.840 --> 32:15.840
那等了一年呢

32:15.840 --> 32:16.840
它等一年

32:16.840 --> 32:17.840
我要在这边等一年

32:17.840 --> 32:18.840
不会等了

32:18.840 --> 32:20.840
继续马上运行

32:20.840 --> 32:21.840
输出三

32:21.840 --> 32:24.840
这个时候执行站清空

32:24.840 --> 32:25.840
反复的看一下

32:25.840 --> 32:26.840
这一段

32:26.840 --> 32:27.840
好好去梳理一下

32:27.840 --> 32:28.840
执行站清空

32:28.840 --> 32:30.840
清空了之后

32:30.840 --> 32:31.840
等呗

32:31.840 --> 32:32.840
那这里

32:32.840 --> 32:33.840
唯一队列里

32:33.840 --> 32:35.840
是不是拿出来输出一了

32:35.840 --> 32:36.840
唯一队列里边

32:36.840 --> 32:39.840
是把这段代码拿出来运行的

32:39.840 --> 32:40.840
输出一

32:40.840 --> 32:42.840
因为这个有余法堂的存在

32:42.840 --> 32:43.840
其实这个东西是

32:43.840 --> 32:44.840
实际上是认里面

32:44.840 --> 32:47.840
认那个毁掉里面

32:47.840 --> 32:48.840
输出一

32:48.840 --> 32:50.840
输出一完了过后

32:50.840 --> 32:51.840
这个函数

32:51.840 --> 32:52.840
函数的代码

32:52.840 --> 32:54.840
是不是全部运行完了

32:54.840 --> 32:56.840
运行完了之后

32:56.840 --> 32:58.840
这个返回的Promise就完成了

32:58.840 --> 33:01.840
这个Promise完成了之后

33:01.840 --> 33:02.840
输出二代码

33:03.840 --> 33:05.840
进入到归队列

33:05.840 --> 33:07.840
由于现在没有什么别的事情可以执行

33:07.840 --> 33:09.840
所以说这个拿出来输出了

33:09.840 --> 33:10.840
输出二

33:10.840 --> 33:12.840
说零三一二

33:12.840 --> 33:16.790
结果是

33:16.790 --> 33:18.790
这样的意思吧

33:18.790 --> 33:19.790
下面的倒题

33:19.790 --> 33:22.790
又是有类似的跑点

33:22.790 --> 33:24.790
反正复去绕理

33:24.790 --> 33:29.940
我给你们说

33:29.940 --> 33:31.940
我给你们讲的那些面试题

33:31.940 --> 33:33.940
都是讲的Promise相关的面试题

33:33.940 --> 33:36.940
都是给你们出的相对比较深一点

33:36.940 --> 33:38.940
因为我还是希望大家能够去冲击

33:38.940 --> 33:40.940
还高兴

33:40.940 --> 33:41.940
最基本的面试题的话

33:41.940 --> 33:43.940
都没有什么好说的了

33:43.940 --> 33:46.940
因为我把姿势已经讲得非常细了

33:46.940 --> 33:48.940
要看下这道题

33:48.940 --> 33:56.660
甭管它咋绕

33:56.660 --> 33:59.660
把屋里都是一样的

33:59.660 --> 34:05.860
来吧

34:05.860 --> 34:07.860
好 首先这些都是函数

34:07.860 --> 34:09.860
声明看都不用看

34:09.860 --> 34:13.420
调用M3

34:13.420 --> 34:15.420
调用M3是调用它

34:15.420 --> 34:17.420
所以现在是在调用M3

34:17.420 --> 34:19.420
M3一定会返回一个Promise

34:19.420 --> 34:20.420
因为还标记了而Sync

34:20.420 --> 34:22.420
它一定返回Promise

34:22.420 --> 34:24.420
调用M3

34:24.420 --> 34:25.420
然后这里边

34:25.420 --> 34:27.420
M3里边又在调用啥

34:27.420 --> 34:28.420
调用M2

34:28.420 --> 34:30.420
那么会去运行M2

34:30.420 --> 34:32.420
M2里边在调用M1

34:32.420 --> 34:34.420
现在我们去运行M1

34:34.420 --> 34:36.420
M1返回的是啥

34:36.420 --> 34:38.420
不要告诉我返回的E

34:38.420 --> 34:40.420
返回的是一个Promise

34:40.420 --> 34:43.420
M1就这一块返回的是一个Promise

34:43.420 --> 34:46.420
得到了完成数据的就是E

34:46.420 --> 34:48.420
所以说我们之前演示过

34:48.420 --> 34:49.420
M1返回的Promise

34:49.420 --> 34:52.420
那么这句话就相当于是写了一个Promise

34:52.420 --> 34:54.420
就相当于是写了这个

34:54.420 --> 34:56.420
换句话说就相当于是写了一个这个

34:56.420 --> 34:58.420
道理很简单

34:58.420 --> 35:02.800
这里去调用M1就是这样的结果

35:02.800 --> 35:04.800
那么我们这个M1

35:04.800 --> 35:06.800
这个地方得到了Promise

35:06.800 --> 35:08.800
是不是就已经是完成了

35:08.800 --> 35:09.800
数据是多少 数据是E

35:09.800 --> 35:10.800
以后这个表达是

35:10.800 --> 35:12.800
它就想把E复制给N

35:12.800 --> 35:13.800
但是不好意思

35:13.800 --> 35:15.800
由于我使用了而Wate

35:15.800 --> 35:17.800
而Wate后边代码全是在

35:17.800 --> 35:18.800
扔的回雕里边

35:18.800 --> 35:20.800
你可以这样想想

35:20.800 --> 35:22.800
要等待Promise完成之后

35:22.800 --> 35:23.800
做后续处理

35:23.800 --> 35:25.800
所以代码都是后续处理

35:25.800 --> 35:28.800
因此我们输出N这个函数

35:28.800 --> 35:29.800
输出2这个动作

35:29.800 --> 35:31.800
输出E这个动作在哪里

35:31.800 --> 35:33.800
在违对列里面

35:33.800 --> 35:34.800
输出E

35:34.800 --> 35:36.800
所以这个地方

35:36.800 --> 35:38.800
输出E这个动作

35:38.800 --> 35:41.800
在违对列里面

35:41.800 --> 35:44.800
好 那么我们回到M3这里

35:44.800 --> 35:46.800
我们第二个用M2

35:46.800 --> 35:48.800
我在会在这里等待它

35:48.800 --> 35:50.800
我这里都没有用而Wate

35:50.800 --> 35:52.800
都没有用而Wate

35:52.800 --> 35:53.800
没有用而Wate的话

35:53.800 --> 35:57.300
我这里N是什么

35:57.300 --> 35:59.300
如果说我用了而Wate

35:59.300 --> 36:01.300
如果说我用了而Wate

36:01.300 --> 36:02.300
那么我要等待

36:02.300 --> 36:04.300
而Wate的Promise完成

36:04.300 --> 36:05.300
什么时候完成

36:05.300 --> 36:07.300
它必须要输出E之后才完成

36:07.300 --> 36:09.300
然后才会运行后边代码

36:09.300 --> 36:12.300
但是我没有用而Wate

36:12.300 --> 36:14.300
没有用而Wate的话

36:14.300 --> 36:17.300
达到的是什么Promise

36:17.300 --> 36:19.300
M2本身就返回的是Promise对吧

36:19.300 --> 36:20.300
而标记了而生给

36:20.300 --> 36:21.300
它一定返回Promise

36:21.300 --> 36:22.300
所以这个N是什么

36:22.300 --> 36:23.300
输出了N

36:23.300 --> 36:24.300
所以我们第一个输出

36:24.300 --> 36:27.300
得到的就是一个Promise

36:27.300 --> 36:30.300
状态是啥

36:30.300 --> 36:31.300
就是M2返回那个Promise

36:31.300 --> 36:33.300
目前的状态是啥

36:33.300 --> 36:34.300
是个Pending

36:34.300 --> 36:35.300
为什么是Pending

36:35.300 --> 36:37.300
它把代码运行完

36:37.300 --> 36:40.300
它代码运行完

36:40.300 --> 36:42.300
是不是只能是Pending

36:43.300 --> 36:44.300
对不对

36:46.300 --> 36:49.300
得到输出了是Pending

36:49.300 --> 36:51.300
然后它返回3

36:51.300 --> 36:53.300
那么这个Promise完成吗

36:53.300 --> 36:55.300
就完成了

36:55.300 --> 36:56.300
它不会去等上面

36:56.300 --> 36:57.300
前面这个Promise

36:57.300 --> 36:59.300
因为我这里没有用而Wate

36:59.300 --> 37:01.300
那就是Promise对象

37:01.300 --> 37:02.300
如果说你用了而Wate

37:02.300 --> 37:03.300
那就不一样了

37:03.300 --> 37:05.300
你用了而Wate的话

37:05.300 --> 37:07.300
那么M3函数

37:07.300 --> 37:09.300
它会把这一段代码

37:09.300 --> 37:11.300
进行等待

37:11.300 --> 37:13.300
等待前面Promise完成

37:13.300 --> 37:15.300
前面Promise目前是Pending

37:15.300 --> 37:17.300
所以说目前M3返回的结果

37:17.300 --> 37:18.300
也是Pending

37:18.300 --> 37:20.300
但是你由于没有用而Wate

37:20.300 --> 37:21.300
没有等待

37:21.300 --> 37:22.300
我没有什么好等待的

37:22.300 --> 37:24.300
我就是把之前Promise

37:24.300 --> 37:25.300
拿到输出

37:25.300 --> 37:26.300
然后我返回一个3

37:26.300 --> 37:27.300
那我这个Promise

37:27.300 --> 37:28.300
就直接结束了

37:28.300 --> 37:30.300
所以说M3

37:30.300 --> 37:33.300
这个M3函数

37:33.300 --> 37:35.300
M2返回的Promise

37:35.300 --> 37:37.300
M1我就不说了

37:37.300 --> 37:39.300
M1刚才调用M1的时候

37:39.300 --> 37:41.300
返回了Promise

37:41.300 --> 37:43.300
那就是已经付费我的了

37:43.300 --> 37:45.300
数据是1

37:45.300 --> 37:46.300
M2那个函数呢

37:46.300 --> 37:47.300
目前还是Pending

37:47.300 --> 37:48.300
还在挂起

37:48.300 --> 37:49.300
因为它没有输出

37:49.300 --> 37:50.300
没有输出1

37:50.300 --> 37:51.300
所以它目前还是挂起

37:51.300 --> 37:53.300
调用M3那个函数返回的呢

37:53.300 --> 37:55.300
由于它没有等待

37:55.300 --> 37:56.300
中间没有任何等待

37:56.300 --> 37:58.300
所以说它直接就是完成了

37:58.300 --> 38:00.300
你看它有没有完成

38:00.300 --> 38:02.300
你看它代码有没有全部运行

38:02.300 --> 38:03.300
全部运行出来了

38:03.300 --> 38:04.300
有返回结果了

38:04.300 --> 38:06.300
那是不是就一定完成了

38:06.300 --> 38:07.300
数据是什么

38:07.300 --> 38:09.300
M3

38:09.300 --> 38:10.300
对吧

38:10.300 --> 38:11.300
好

38:11.300 --> 38:12.300
接下来运行到这

38:12.300 --> 38:14.300
因为函函数调用完成

38:14.300 --> 38:15.300
调用完了

38:15.300 --> 38:16.300
调用任函数

38:16.300 --> 38:18.300
高速杀

38:18.300 --> 38:20.300
如果说你前面这个Promise

38:20.300 --> 38:21.300
就这个Promise

38:21.300 --> 38:23.300
前面这个Promise完成过后

38:23.300 --> 38:24.300
你给我运行这个

38:24.300 --> 38:26.300
那这个完成了吗

38:26.300 --> 38:27.300
就完成了

38:27.300 --> 38:28.300
完成了这个代码

38:28.300 --> 38:29.300
这个函数会到了

38:29.300 --> 38:30.300
是不是到维对列

38:30.300 --> 38:31.300
它不会立即执行的

38:31.300 --> 38:33.300
这是输出几呢

38:33.300 --> 38:35.300
是不是输出那个完成的数据3

38:35.300 --> 38:37.300
是到维对列里面

38:37.300 --> 38:40.060
对吧

38:40.060 --> 38:41.060
没问题吧

38:41.060 --> 38:42.060
好

38:42.060 --> 38:43.060
接下来

38:43.060 --> 38:45.060
我这个地方又掉了一次M3

38:45.060 --> 38:47.060
又掉了一次

38:47.060 --> 38:49.060
那结果不是一样的吗

38:49.060 --> 38:50.060
有什么区别的

38:50.060 --> 38:51.060
那就重新来到一遍

38:51.060 --> 38:52.060
对吧

38:52.060 --> 38:53.060
来吧

38:53.060 --> 38:55.060
又掉M3

38:55.060 --> 38:57.060
那这里是不是运行M2

38:57.060 --> 38:58.060
M2是不是运行M1

38:58.060 --> 38:59.060
M1

38:59.060 --> 39:01.060
那这里要重新开一个了

39:03.060 --> 39:05.060
这一次跟之前的调用已经不一样了

39:05.060 --> 39:07.060
M1

39:07.060 --> 39:09.060
用一个符号标准一下吧

39:09.060 --> 39:11.060
就这一次新的这一次调用

39:11.060 --> 39:13.060
M1得到的是结果是for fair的

39:13.060 --> 39:15.060
一

39:15.060 --> 39:17.060
然后呢这一次M2

39:17.060 --> 39:19.060
因为它是可以调用很多次吧

39:19.060 --> 39:21.060
每一次调用都是新开一块的一存

39:21.060 --> 39:23.060
好掉了M2

39:23.060 --> 39:25.060
M2返回了什么了

39:25.060 --> 39:26.060
要等待

39:26.060 --> 39:27.060
M2这里是不是

39:27.060 --> 39:29.060
要等待那个

39:29.060 --> 39:31.060
M1完成了

39:31.060 --> 39:32.060
完成了

39:32.060 --> 39:34.060
所以说后边的代码归放了

39:34.060 --> 39:35.060
输出1的代码

39:35.060 --> 39:36.060
又会放入微队里

39:36.060 --> 39:37.060
输出1

39:37.060 --> 39:38.060
就这段代码

39:38.060 --> 39:40.060
又会放入微队里

39:40.060 --> 39:41.060
对吧

39:41.060 --> 39:42.060
所以M2目前也是挂起

39:42.060 --> 39:44.060
这个M2也是挂起

39:44.060 --> 39:46.060
因为它要把这个

39:46.060 --> 39:47.060
后边代码执行完了过

39:47.060 --> 39:48.060
跟刚才一样的

39:48.060 --> 39:49.060
要把这个代码执行完了过后

39:49.060 --> 39:50.060
才继续运行

39:50.060 --> 39:53.820
然后接下来是M3

39:53.820 --> 39:54.820
调用这个M3

39:54.820 --> 39:55.820
M3呢

39:55.820 --> 39:56.820
我没有等待M2

39:56.820 --> 39:57.820
对吧

39:57.820 --> 39:58.820
所以说我这里输出的是promise

39:58.820 --> 40:00.820
那还是跟刚才一样的

40:00.820 --> 40:02.820
就重新调了一次

40:02.820 --> 40:04.820
那么M3就直接完成了

40:05.820 --> 40:06.820
3

40:06.820 --> 40:07.820
这是这一次调了M3

40:07.820 --> 40:08.820
刚才是不是一样的

40:08.820 --> 40:10.820
就重新来的一遍

40:10.820 --> 40:12.820
然后输出4

40:12.820 --> 40:14.820
接下来代码执行完了

40:14.820 --> 40:16.820
没有啥东西可以执行的

40:16.820 --> 40:17.820
然后微队的一边

40:17.820 --> 40:18.820
一个一个拿出来

40:18.820 --> 40:19.820
先输出1再输出3

40:19.820 --> 40:20.820
再输出1

40:20.820 --> 40:21.820
对吧

40:21.820 --> 40:22.820
我们一个个来吧

40:22.820 --> 40:24.820
第一次先输出1

40:24.820 --> 40:26.820
这里是不是输出1

40:26.820 --> 40:28.820
那么这个执行完了过后

40:28.820 --> 40:30.820
是不是导致M2就执行结束了

40:30.820 --> 40:32.820
M2执行结束了

40:32.820 --> 40:34.820
那么这之前那个M2调用

40:34.820 --> 40:35.820
是不是导致输出了

40:35.820 --> 40:38.820
就fuel的数据12

40:38.820 --> 40:39.820
M2执行结束了

40:39.820 --> 40:40.820
跟M3有关系吗

40:40.820 --> 40:41.820
没有关系

40:41.820 --> 40:43.820
因为M3没有去等待它

40:43.820 --> 40:44.820
对吧

40:44.820 --> 40:45.820
好

40:45.820 --> 40:46.820
那么这也输出1

40:46.820 --> 40:47.820
然后再输出3

40:47.820 --> 40:48.820
这输出3是哪来的

40:48.820 --> 40:49.820
是这个函数

40:49.820 --> 40:53.840
输出3

40:53.840 --> 40:54.840
这个执行完了

40:54.840 --> 40:55.840
然后再输出1

40:55.840 --> 40:56.840
是不是刚才

40:56.840 --> 40:58.840
第二次调用这个M2的时候

40:58.840 --> 40:59.840
一样的当里

40:59.840 --> 41:04.280
那么这里变成了fuel的

41:04.280 --> 41:06.280
这个是2

41:06.280 --> 41:07.280
输出1

41:07.280 --> 41:10.280
所以这个题的最终输出结果

41:10.280 --> 41:11.280
就这个

41:11.280 --> 41:12.280
准备是平底

41:12.280 --> 41:13.280
两个平底

41:13.280 --> 41:15.280
是1131

41:16.280 --> 41:17.280
是吧

41:18.280 --> 41:19.280
我不跟你们吹牛话

41:19.280 --> 41:21.280
我不知道这个问题的答案是啥

41:21.280 --> 41:22.280
我没有去背过

41:22.280 --> 41:23.280
这个玩意不需要背

41:23.280 --> 41:25.280
你只要抓住我这种分析方法

41:25.280 --> 41:28.280
你这个题随便怎么来绕理

41:28.280 --> 41:31.280
你都可以把它做出来

41:31.280 --> 41:32.280
要慢慢去分析

41:32.280 --> 41:34.280
因为地方看不看得不是很懂

41:34.280 --> 41:35.280
有点晕的话

41:35.280 --> 41:36.280
你反复多看几遍

41:36.280 --> 41:40.100
第七题

41:40.100 --> 41:41.100
如果说觉得累了

41:41.100 --> 41:42.100
可以休息一会再看看

41:42.100 --> 41:43.100
没关系

41:43.100 --> 41:46.930
这个题其实蛮简单的

41:46.930 --> 41:48.930
就是一个小的知识

41:48.930 --> 41:49.930
有些朋友不知道

41:49.930 --> 41:51.930
给你说一下

41:51.930 --> 41:53.930
是这样子

41:53.930 --> 41:56.930
如果说任方法里边传了一个

41:56.930 --> 41:57.930
因为任方法里边都传的

41:57.930 --> 41:58.930
是一个回掉函数

41:58.930 --> 41:59.930
对不对

41:59.930 --> 42:00.930
传的是一个函数

42:00.930 --> 42:01.930
如果说你传的不是函数

42:01.930 --> 42:03.930
就传一个乱七八糟的别的东西

42:03.930 --> 42:04.930
传一个数字

42:04.930 --> 42:05.930
对象

42:05.930 --> 42:07.930
你只要传的不是函数

42:07.930 --> 42:08.930
你就这样子

42:08.930 --> 42:09.930
一个最简单的方式

42:09.930 --> 42:12.930
你就把这个代码过三了

42:12.930 --> 42:14.930
你就这样子就行了

42:14.930 --> 42:16.930
实际上说的严格一点的话

42:16.930 --> 42:17.930
那么如果说任方法

42:17.930 --> 42:19.930
调用任方法的时候

42:19.930 --> 42:22.930
他发现你传的函数不是函数

42:22.930 --> 42:23.930
那么他反

42:23.930 --> 42:25.930
这个任方法反回的Promise

42:25.930 --> 42:27.930
就是原来的Promise

42:27.930 --> 42:28.930
就相当于是

42:28.930 --> 42:29.930
你没有注册

42:29.930 --> 42:30.930
相当于是传一个NOW

42:30.930 --> 42:31.930
你这样想吧

42:31.930 --> 42:32.930
传一个NOW

42:32.930 --> 42:33.930
我们之前说过了

42:33.930 --> 42:34.930
相当于是

42:34.930 --> 42:35.930
你没有注册回掉函数

42:35.930 --> 42:37.930
没有注册回掉函数的话

42:37.930 --> 42:38.930
那么这个Promise

42:38.930 --> 42:40.930
跟前面那个Promise的状态

42:40.930 --> 42:42.930
数据都是一致的

42:42.930 --> 42:43.930
所以说

42:43.930 --> 42:45.930
你将冲的就是可以把任三了

42:45.930 --> 42:46.930
他少的没写

42:46.930 --> 42:47.930
你看

42:47.930 --> 42:49.930
我这里传了一个2

42:49.930 --> 42:50.930
2是不是函数

42:50.930 --> 42:51.930
不是吧

42:51.930 --> 42:53.930
那就8个3了

42:53.930 --> 42:54.930
这里Result

42:54.930 --> 42:55.930
这些传的是什么

42:55.930 --> 42:57.930
传的是一个Promise对象

42:57.930 --> 42:58.930
不是函数吧

42:58.930 --> 42:59.930
那不是函数

42:59.930 --> 43:01.930
它就是无效的传递

43:02.930 --> 43:04.930
这个Consult6个是不是函数

43:06.930 --> 43:07.930
同学们

43:07.930 --> 43:09.930
Consult6个是不是函数

43:09.930 --> 43:10.930
不是函数是啥

43:10.930 --> 43:12.930
那么提示我用的是啥东西

43:12.930 --> 43:13.930
不就是个函数吗

43:13.930 --> 43:14.930
它接受一个参数

43:14.930 --> 43:15.930
对吧

43:15.930 --> 43:17.930
你把它写成一个函数格式

43:17.930 --> 43:18.930
就是这样子的格式

43:18.930 --> 43:20.930
6个有一个参数

43:20.930 --> 43:22.930
然后它就负责把那个参数

43:22.930 --> 43:24.930
把那个参数来输出

43:24.930 --> 43:25.930
不就是一个函数吗

43:25.930 --> 43:26.930
所以说这个是不是函数

43:26.930 --> 43:27.930
是函数

43:27.930 --> 43:28.930
那么你可以

43:28.930 --> 43:29.930
也没问题

43:29.930 --> 43:31.930
那么这个Promise完成之后

43:31.930 --> 43:33.930
它会把这个数据

43:33.930 --> 43:35.930
传递给这个函数

43:35.930 --> 43:37.930
那么相当于是把1传给这个漏的函数

43:37.930 --> 43:38.930
那就输出了1

43:38.930 --> 43:39.930
所以这个结构就是输出1

43:39.930 --> 43:43.300
那你把刚才那个东西加上

43:43.300 --> 43:44.300
乱七八糟的代码加上

43:44.300 --> 43:45.300
其实也是输出1

43:45.300 --> 43:47.300
因为传的都是无效的参数

43:47.300 --> 43:48.300
是一样

43:48.300 --> 43:50.300
这个小的信简

43:50.300 --> 43:51.300
再说一下

43:51.300 --> 43:53.300
第八题就九题

43:53.300 --> 43:55.300
是一个中俄形成大题

43:55.300 --> 43:57.300
也是非常经典的Promise的

43:57.300 --> 43:59.300
两道面试题

43:59.300 --> 44:00.300
网上有很多的文章

44:00.300 --> 44:02.300
去解释这两道面试题

44:02.300 --> 44:04.300
就是你听我讲就行了

44:04.300 --> 44:06.870
来了

44:06.870 --> 44:08.870
你们自己可以尝试着先

44:08.870 --> 44:09.870
做一下

44:15.330 --> 44:17.330
到底有点复杂

44:17.330 --> 44:26.140
来 走一遍

44:26.140 --> 44:27.140
上面是分析

44:27.140 --> 44:34.300
下边是输出

44:34.300 --> 44:36.300
好 来了

44:36.300 --> 44:39.300
这里是定义了一个变量A

44:39.300 --> 44:41.300
目前肯定是扬迪凡的

44:41.300 --> 44:43.300
那还能输啥呢

44:43.300 --> 44:45.300
然后定义了一个变量B

44:46.300 --> 44:49.300
这里有个小的细节给你们说一下

44:49.300 --> 44:51.300
变量的定义

44:51.300 --> 44:53.300
变量的定义和复值

44:53.300 --> 44:56.300
实际上是分两步完成的

44:56.300 --> 44:57.300
知道吧

44:57.300 --> 44:58.300
它会先运算

44:58.300 --> 44:59.300
后边表达式

44:59.300 --> 45:01.300
然后再把表达式的结果

45:01.300 --> 45:03.300
复制给变量

45:03.300 --> 45:05.300
这是一个非常朴素的整理

45:05.300 --> 45:07.300
但是很容易忘记着一点

45:07.300 --> 45:09.300
所以这个B的变量的值

45:09.300 --> 45:11.300
目前是扬迪凡的

45:11.300 --> 45:13.300
它先是扬迪凡的

45:13.300 --> 45:14.300
是这样子的

45:14.300 --> 45:15.300
它先是扬迪凡的

45:15.300 --> 45:17.300
然后把这个表达式算出来过后

45:17.300 --> 45:19.300
再复制给B

45:19.300 --> 45:21.300
好 那么接下来是不开始算这个表达式了

45:21.300 --> 45:23.300
这个表达式在干嘛

45:23.300 --> 45:24.300
创建一个Promise的一个

45:24.300 --> 45:26.300
这是个很长的表达式

45:26.300 --> 45:27.300
一把简化之后

45:27.300 --> 45:29.300
它代码应该是这样子的

45:29.300 --> 45:30.300
NewPromise

45:30.300 --> 45:32.300
然后传了一个啥啥

45:32.300 --> 45:34.300
然后它调了它的Zen

45:34.300 --> 45:35.300
传了一个啥啥啥

45:35.300 --> 45:36.300
再调了它的Zen

45:36.300 --> 45:37.300
传了一个啥啥啥

45:37.300 --> 45:38.300
再调用Zen

45:38.300 --> 45:39.300
传了一个啥啥啥

45:39.300 --> 45:41.300
就是这么一个表达式

45:41.300 --> 45:43.300
那么这个表达式

45:43.300 --> 45:44.300
它复制给了B

45:44.300 --> 45:46.300
请问

45:46.300 --> 45:47.300
这个表达

45:47.300 --> 45:49.300
这个B这个表达

45:49.300 --> 45:51.300
就是这个表达式复制给B

45:51.300 --> 45:53.300
复制的是哪一个Promise

45:53.300 --> 45:54.300
是这个吗

45:54.300 --> 45:56.300
还是这个Zen函数返回的

45:56.300 --> 45:58.300
还是这个Zen函数返回的

45:58.300 --> 45:59.300
还是这个Zen函数返回的

45:59.300 --> 46:02.300
我记得有一些可我说过的

46:02.300 --> 46:04.300
这是最基础的概念了 对吧

46:04.300 --> 46:05.300
一个对象

46:05.300 --> 46:07.300
再调一个方法

46:07.300 --> 46:08.300
再调一个方法

46:08.300 --> 46:09.300
再调一个方法

46:09.300 --> 46:11.300
整个表达式返回的是啥

46:11.300 --> 46:13.300
返回的是最后一个

46:13.300 --> 46:15.300
所以说这里返回的是

46:15.300 --> 46:19.300
返回的是这个Zen函数的Promise

46:19.300 --> 46:21.300
有些同学可能有误音了

46:21.300 --> 46:22.300
也不对啊

46:22.300 --> 46:23.300
你看

46:23.300 --> 46:25.300
这个Promise要等一秒后才完成

46:25.300 --> 46:26.300
所以说这个Zen

46:26.300 --> 46:27.300
是不是要等一秒后才完成

46:27.300 --> 46:29.300
这个Zen是不是要等一秒后才完成

46:29.300 --> 46:31.300
你错了 同学

46:31.300 --> 46:32.300
一秒

46:32.300 --> 46:34.300
这些回调函数是这样子的

46:34.300 --> 46:35.300
一秒后才会运行

46:35.300 --> 46:36.300
一秒后才会运行

46:36.300 --> 46:38.300
这也是没问题的

46:38.300 --> 46:39.300
但是这个Zen函数方法

46:39.300 --> 46:41.300
是马上就得调用对吧

46:41.300 --> 46:44.300
再调用Zen方法

46:44.300 --> 46:45.300
你看吧

46:45.300 --> 46:46.300
你是不是要调用方法

46:46.300 --> 46:48.300
创建一个对象 调用它的方法Zen

46:48.300 --> 46:49.300
这个Zen会返回一个新的对象

46:49.300 --> 46:50.300
又会调用这个方法

46:50.300 --> 46:51.300
新的对象的Zen方法

46:51.300 --> 46:53.300
再返回了新的对象

46:53.300 --> 46:54.300
调用它的方法

46:54.300 --> 46:56.300
方法是瞬间就调用完了

46:56.300 --> 46:57.300
只是这个Promise

46:57.300 --> 47:00.300
这个方法返回的Promise的状态

47:00.300 --> 47:01.300
还不能确定

47:01.300 --> 47:02.300
所以说B是一个什么

47:02.300 --> 47:04.300
是一个Promise

47:04.300 --> 47:06.300
它的状态是啥

47:06.300 --> 47:09.300
是平底

47:10.300 --> 47:13.930
挂起的

47:13.930 --> 47:14.930
对不对

47:14.930 --> 47:15.930
好 那我们来再来

47:15.930 --> 47:19.240
详细分析一下

47:19.240 --> 47:20.240
这个代码到底是怎么执行的

47:20.240 --> 47:22.240
它是这样执行的

47:22.240 --> 47:24.240
先运行那个表达式

47:24.240 --> 47:25.240
运行的表达式

47:25.240 --> 47:26.240
不要从左到右运行

47:26.240 --> 47:28.240
好 首先运行左边

47:28.240 --> 47:30.240
先运行这个指表达式

47:30.240 --> 47:31.240
指表达式干嘛

47:31.240 --> 47:33.240
创建一个Promise

47:33.240 --> 47:35.240
把它叫做P1

47:35.240 --> 47:36.240
这是第一个Promise

47:36.240 --> 47:38.240
创建一个Promise

47:38.240 --> 47:39.240
然后输出的时候

47:39.240 --> 47:40.240
马上输出

47:40.240 --> 47:46.410
马上运行的输出Promise

47:46.410 --> 47:49.410
然后一秒后运行这个函数

47:49.410 --> 47:51.410
我们记录一下

47:51.410 --> 47:56.980
一秒后完成

47:56.980 --> 47:58.980
这个函数其实就是完成Promise

47:58.980 --> 47:59.980
所以这个Promise

47:59.980 --> 48:00.980
一开始状态是什么

48:00.980 --> 48:02.980
平底

48:02.980 --> 48:04.980
那么这个Promise创建好了

48:04.980 --> 48:06.980
创建好了之后

48:06.980 --> 48:08.980
调它的任方法

48:08.980 --> 48:09.980
这个任方法是不是

48:09.980 --> 48:11.980
产分了第二个Promise

48:11.980 --> 48:12.980
第二个Promise

48:12.980 --> 48:13.980
取决于前面Promise

48:14.980 --> 48:15.980
Promise的状态

48:15.980 --> 48:16.980
前面是平底

48:16.980 --> 48:17.980
那它就是平底

48:17.980 --> 48:18.980
这个回调现在运行

48:18.980 --> 48:19.980
现在不运行

48:19.980 --> 48:20.980
它连对立也都不会到

48:20.980 --> 48:22.980
因为目前是平底状态

48:22.980 --> 48:23.980
前面是平底状态

48:23.980 --> 48:25.980
前边完成

48:25.980 --> 48:26.980
才会运行这个回调

48:26.980 --> 48:27.980
对吧

48:27.980 --> 48:29.980
然后P3

48:29.980 --> 48:31.980
这里再调用任方法

48:31.980 --> 48:32.980
反回第三个Promise

48:32.980 --> 48:33.980
它的状态是什么

48:33.980 --> 48:35.980
它的状态就是也是平底

48:35.980 --> 48:36.980
因为它前一个Promise

48:36.980 --> 48:38.980
状态是平底

48:38.980 --> 48:39.980
对吧

48:39.980 --> 48:41.980
然后P4

48:41.980 --> 48:42.980
也是平底

48:42.980 --> 48:44.980
那么这个B

48:44.980 --> 48:46.980
B实际上是提示

48:46.980 --> 48:48.980
实际上是最后一个

48:50.980 --> 48:51.980
那么这个表达是就运行完了

48:51.980 --> 48:52.980
创建Promise

48:52.980 --> 48:54.980
付这个B都是平底

48:54.980 --> 48:55.980
一秒后P1完成

48:55.980 --> 48:57.980
它造成了连锁反应

48:57.980 --> 49:00.980
这是这个代码

49:00.980 --> 49:02.980
现在目前输出只有Promise1

49:02.980 --> 49:04.980
接下来我们看下面

49:04.980 --> 49:07.980
又创建一个Promise

49:07.980 --> 49:09.980
给A付值

49:09.980 --> 49:10.980
好好来分析一下

49:10.980 --> 49:15.670
A目前的值得是undefined

49:15.670 --> 49:16.670
来吧

49:16.670 --> 49:17.670
给A付值

49:17.670 --> 49:23.260
创建一个Promise

49:23.260 --> 49:25.260
这个代码是不是立即执行

49:25.260 --> 49:27.260
注意这个Promise是标准而sync

49:27.260 --> 49:28.260
这个回调函数

49:28.260 --> 49:30.260
这个函数也标准而sync

49:30.260 --> 49:31.260
就说这个函数反回来

49:31.260 --> 49:32.260
也是Promise

49:32.260 --> 49:33.260
崩溫它

49:33.260 --> 49:34.260
无所谓

49:34.260 --> 49:36.260
先输出A这个代码

49:36.260 --> 49:37.260
立即执行

49:37.260 --> 49:38.260
请问A目前的值市场

49:38.260 --> 49:39.260
是不是undefined

49:39.260 --> 49:40.260
为什么

49:40.260 --> 49:41.260
现在还没有完成复制

49:41.260 --> 49:42.260
我要把这个表达

49:42.260 --> 49:43.260
运算完了过后

49:43.260 --> 49:44.260
才能复制

49:45.260 --> 49:46.260
先右再左

49:47.260 --> 49:48.260
复制表达式

49:48.260 --> 49:49.260
运行右边的

49:49.260 --> 49:50.260
运行完了之后

49:50.260 --> 49:51.260
再给A付值

49:51.260 --> 49:52.260
现在目前

49:52.260 --> 49:54.260
A这边代码还在运行

49:54.260 --> 49:56.260
这是比较传到一个函数

49:56.260 --> 49:57.260
函数还在运行

49:57.260 --> 49:58.260
所以目前的A

49:58.260 --> 49:59.260
还上的地方

50:01.260 --> 50:02.260
好 等待B

50:02.260 --> 50:04.260
等待B是不是等待P4

50:06.260 --> 50:07.260
对不对

50:07.260 --> 50:09.260
是不是等待P4

50:09.260 --> 50:11.260
P4现在是不是平底

50:12.260 --> 50:13.260
对吧

50:13.260 --> 50:15.260
因此这后边代码现在执行

50:15.260 --> 50:16.260
不执行

50:17.260 --> 50:19.260
后边一长串代码

50:19.260 --> 50:20.260
都不会执行到目前

50:20.260 --> 50:21.260
为什么

50:21.260 --> 50:22.260
因为P4还是

50:22.260 --> 50:23.260
挂起的

50:23.260 --> 50:24.260
我现在P4完成之后

50:24.260 --> 50:26.260
我才能继续往后执行

50:26.260 --> 50:27.260
对吧

50:27.260 --> 50:29.260
但是程序可不会卡住

50:29.260 --> 50:31.260
程序可不会卡

50:32.260 --> 50:34.260
这个函数就结束了

50:35.260 --> 50:36.260
等到B完成过后

50:36.260 --> 50:38.260
它再回过头来执行这个

50:39.260 --> 50:40.260
没什么 没什么意思吧

50:40.260 --> 50:42.260
这个函数就执行结束了

50:42.260 --> 50:43.260
这个函数就执行结束了

50:43.260 --> 50:45.260
过后这个表达是就执行结束了

50:45.260 --> 50:47.260
好 就反 产生那个Promise

50:47.260 --> 50:48.260
Fox给了A

50:48.260 --> 50:49.260
那么A就是一个什么

50:49.260 --> 50:50.260
Promise

50:50.260 --> 50:52.260
我们姑且把它叫做P5

50:52.260 --> 50:54.260
这个Promise

50:54.260 --> 50:55.260
也就是P5

50:55.260 --> 50:57.260
那么请问P5的状态是啥

50:59.260 --> 51:00.260
这个状态是啥

51:00.260 --> 51:01.260
这个还不简单吗

51:01.260 --> 51:03.260
你是通过6来创建的Promise

51:03.260 --> 51:04.260
那么状态

51:04.260 --> 51:06.260
你看你有没有调容为ZO

51:06.260 --> 51:07.260
有没有调容为ZO

51:08.260 --> 51:10.260
目前只运行到这就结束了

51:10.260 --> 51:12.260
所以说目前啥都没调容

51:12.260 --> 51:13.260
状态肯定是很低

51:14.260 --> 51:15.260
这还有什么好疑问的

51:17.260 --> 51:18.260
好 然后输出了

51:18.260 --> 51:19.260
然后再输出N

51:21.260 --> 51:22.260
123 输出完了

51:24.260 --> 51:25.260
接下来等吧

51:25.260 --> 51:26.260
等发生连锁反应

51:26.260 --> 51:28.260
1秒后完成P1

51:29.260 --> 51:31.260
1秒后完成了谁

51:31.260 --> 51:32.260
这个Promise

51:32.260 --> 51:33.260
好 来吧

51:33.260 --> 51:35.260
P1完成之后

51:35.260 --> 51:36.260
就导致了谁

51:36.260 --> 51:39.260
导致了这个的函数进入V队列

51:39.260 --> 51:40.260
因为没有别的事

51:40.260 --> 51:41.260
直接拿出来执行

51:43.260 --> 51:44.260
输出啥

51:44.260 --> 51:46.260
P1就完成了

51:50.260 --> 51:51.260
然后就运行这个函数

51:51.260 --> 51:52.260
输出了Promise2

51:54.260 --> 51:55.260
后面就没什么好说的了

51:55.260 --> 51:57.260
因为它执行的过程中

51:57.260 --> 51:58.260
没有产生错误

51:58.260 --> 51:59.260
成功完成了

51:59.260 --> 52:03.260
所以说P2也跟着完成了

52:03.260 --> 52:04.260
P2一完成

52:04.260 --> 52:05.260
这个玩意又到V队列

52:05.260 --> 52:06.260
又拿出来执行

52:06.260 --> 52:08.260
所以说输出Promise3

52:11.260 --> 52:12.260
同样的道理

52:12.260 --> 52:14.260
这个玩意P3也完成了

52:14.260 --> 52:16.260
然后跟着P4也完成了

52:16.260 --> 52:17.260
然后就输出Promise4

52:17.260 --> 52:19.260
P4也完成了

52:19.260 --> 52:20.260
那么就一是输出

52:20.260 --> 52:22.260
二 三 四

52:23.260 --> 52:25.260
好 P4完成了之后

52:25.260 --> 52:27.700
是不是会导致了

52:27.700 --> 52:29.700
这里就等待就结束了

52:29.700 --> 52:31.700
它等待B吧 B就是P4

52:31.700 --> 52:33.700
所以说它B是不是完成了

52:33.700 --> 52:34.700
完成了过后

52:35.700 --> 52:37.700
那么这里边代码可以继续了

52:37.700 --> 52:38.700
但是P5还是盆顶

52:38.700 --> 52:40.700
因为它没有调用result

52:41.700 --> 52:43.700
然后接下来输出什么

52:43.700 --> 52:44.700
输出A

52:44.700 --> 52:46.700
那么A不好意思

52:46.700 --> 52:48.700
现在A有值了

52:48.700 --> 52:49.700
不是

52:49.700 --> 52:50.700
现在A有值了

52:50.700 --> 52:51.700
现在A是不是P5

52:51.700 --> 52:53.700
所以说现在输出A是什么了

52:53.700 --> 52:55.700
输出的是一个Promise

52:55.700 --> 52:57.700
状态是什么

52:57.700 --> 52:58.700
还是盆顶

52:59.700 --> 53:00.700
目前A得值

53:02.700 --> 53:03.700
再输出一个after

53:07.140 --> 53:08.140
然后接下来有意思的就是

53:08.140 --> 53:10.140
等待A完成

53:10.140 --> 53:12.140
A现在目前是Pending

53:12.140 --> 53:13.140
你看P5是Pending

53:13.140 --> 53:15.140
等待A完成

53:15.140 --> 53:18.460
这个事有尽头吗

53:18.460 --> 53:19.460
是不是没有尽头

53:20.460 --> 53:21.460
现在代码又结束了

53:21.460 --> 53:23.460
这个还说执行了一段

53:23.460 --> 53:25.460
然后遇到这儿等待又结束了

53:25.460 --> 53:27.460
又不止啥都没啥事情可以做了

53:27.460 --> 53:28.460
因为它只有A完成之后

53:28.460 --> 53:30.460
才会接着做后面的事情

53:30.460 --> 53:32.460
但是A现在是不是Pending

53:32.460 --> 53:33.460
没有完成

53:33.460 --> 53:35.460
那现在就相当于是等待自己

53:35.460 --> 53:36.460
自己等待自己

53:36.460 --> 53:39.460
说我等待我完成之后

53:39.460 --> 53:41.460
我就完成我

53:41.460 --> 53:43.460
那是不是永远等不到

53:43.460 --> 53:45.460
就有点像前段时间疫情

53:45.460 --> 53:46.460
你家里面没口罩了

53:46.460 --> 53:48.460
但是又不能出小区

53:48.460 --> 53:50.460
出小区的时候有一个大妈

53:50.460 --> 53:52.460
带着红袖哭

53:52.460 --> 53:53.460
不能出小区

53:53.460 --> 53:55.460
出小区要带口罩

53:55.460 --> 53:56.460
你说你没有口罩

53:56.460 --> 53:58.460
所以说出门去买口罩

53:59.460 --> 54:00.460
那不行

54:00.460 --> 54:02.460
你没有口罩不能出小区

54:03.460 --> 54:04.460
有人口罩才能出小区

54:04.460 --> 54:05.460
但是我不出门

54:05.460 --> 54:06.460
又怎么去买口罩

54:06.460 --> 54:08.460
就是这么一个问题

54:09.460 --> 54:11.460
它要等待自己完成

54:11.460 --> 54:12.460
完成之后才能完成自己

54:12.460 --> 54:13.460
那你永远等不到

54:13.460 --> 54:15.460
自己本来就是挂起的

54:15.460 --> 54:16.460
所以这个代码就不执行了

54:16.460 --> 54:17.460
后面就不执行了

54:17.460 --> 54:18.460
永远没法执行了

54:18.460 --> 54:20.460
你永远等不到它完成

54:20.460 --> 54:21.460
它永远挂起挂起

54:21.460 --> 54:22.460
无所谓

54:22.460 --> 54:23.460
但是你要记住

54:23.460 --> 54:25.460
挂起不代表程序卡

54:25.460 --> 54:26.460
做程序永远不会卡的

54:26.460 --> 54:28.460
介绍程序是永远不会卡的

54:29.460 --> 54:30.460
相当于是后面的代码

54:30.460 --> 54:31.460
是在一个函数里面

54:31.460 --> 54:33.460
这个函数永远不执行

54:34.460 --> 54:36.460
就相当于是定义了一个函数

54:36.460 --> 54:37.460
这个函数你没有去调用它

54:37.460 --> 54:38.460
它就永远不执行

54:40.460 --> 54:41.460
而为止只是一个愚法堂

54:41.460 --> 54:43.460
所以说这两个代码无效

54:44.460 --> 54:45.460
最终结果就是这样子

54:45.460 --> 54:46.460
运行看一看

54:49.280 --> 54:50.280
自己对一下

54:50.280 --> 54:51.280
肯定是这样子

54:51.280 --> 54:53.280
你学会了这样的分析方法之后

54:53.280 --> 54:54.280
这些题都非常不好

54:56.280 --> 54:57.280
这些面试题

54:57.280 --> 54:59.280
我觉得你现在了解个

55:00.280 --> 55:01.280
六七十可以了

55:02.280 --> 55:04.280
后边你在准备面试的时候

55:04.280 --> 55:05.280
你肯定要回过头来看的

55:05.280 --> 55:06.280
到时候肯定又忘完了

55:06.280 --> 55:07.280
这是正常的

55:08.280 --> 55:10.280
有多少影响算多少影响

55:11.280 --> 55:12.280
多少题

55:12.280 --> 55:13.280
这也是一道经典的面试题

55:16.720 --> 55:17.720
来吧

55:17.720 --> 55:18.720
这有定了两个函数

55:19.720 --> 55:20.720
这两个函数没有调用

55:20.720 --> 55:21.720
它没调用

55:21.720 --> 55:22.720
它滑倒

55:23.720 --> 55:24.720
我们只关心函数的调用

55:24.720 --> 55:25.720
然后输出

55:26.720 --> 55:27.720
输出这个

55:28.720 --> 55:34.040
输出这个

55:35.040 --> 55:36.040
然后在

55:37.040 --> 55:38.040
零秒后

55:38.040 --> 55:39.040
输出这个

55:39.040 --> 55:40.040
所以说

55:40.040 --> 55:41.040
红队你

55:42.040 --> 55:44.040
零秒后输出这个

55:44.040 --> 55:45.040
输出

55:45.040 --> 55:46.040
set

55:46.040 --> 55:47.040
timeout

55:47.040 --> 55:48.040
零秒马上就到了嘛

55:48.040 --> 55:49.040
排队

55:50.040 --> 55:51.040
调用而sync1

55:52.040 --> 55:53.040
来吧

55:53.040 --> 55:54.040
调用呗

55:54.040 --> 55:55.040
而sync1

55:55.040 --> 55:56.040
运行

55:56.040 --> 55:57.040
它是不是输出这个

55:58.040 --> 55:59.040
sync1

55:59.040 --> 56:00.040
start

56:01.040 --> 56:02.040
然后调用啥

56:02.040 --> 56:03.040
调用而sync2

56:04.040 --> 56:06.040
输出而sync2

56:07.040 --> 56:10.310
好

56:10.310 --> 56:11.310
而sync2运行完了

56:11.310 --> 56:12.310
而sync2会返回啥

56:12.310 --> 56:13.310
返回一个promise

56:13.310 --> 56:14.310
这个promise是不是完成了

56:14.310 --> 56:15.310
它中间没爆错嘛

56:16.310 --> 56:17.310
它虽然没返回

56:17.310 --> 56:18.310
返回的就相当于是undefined

56:18.310 --> 56:19.310
说这个

56:19.310 --> 56:20.310
而sync2返回的是一个promise

56:21.310 --> 56:22.310
它的相关数据呢

56:22.310 --> 56:23.310
是undefined

56:24.310 --> 56:25.310
那我这里要等待这个promise完成

56:25.310 --> 56:26.310
现在是不是已经完成了

56:27.310 --> 56:29.310
那么后边的单码进入围队里

56:31.310 --> 56:32.310
我再重复解释了

56:33.310 --> 56:34.310
这个相当于是在Zen里边

56:35.310 --> 56:36.310
不是马上运行

56:36.310 --> 56:37.310
所以想说

56:37.310 --> 56:38.310
它目前已经完成了

56:38.310 --> 56:39.310
但是呢

56:39.310 --> 56:40.310
它不是马上运行

56:40.310 --> 56:41.310
它进入围队里

56:41.310 --> 56:43.310
围队里边是输出

56:44.310 --> 56:46.310
而sync1

56:46.310 --> 56:47.310
end

56:48.310 --> 56:51.820
那么而sync1调用完

56:51.820 --> 56:52.820
调用结束

56:53.820 --> 56:54.820
接下来

56:54.820 --> 56:56.820
创建一个新的promise

56:57.820 --> 56:58.820
这个新的promise

56:58.820 --> 56:59.820
马上运行

56:59.820 --> 57:01.820
输出promise1

57:06.050 --> 57:07.050
然后呢

57:07.050 --> 57:08.050
把这个promise完成

57:08.050 --> 57:09.050
我们把这个promise进入一下

57:10.050 --> 57:11.050
P就是fulfill

57:12.050 --> 57:13.050
不用记得

57:13.050 --> 57:14.050
其实这个地方很简单的

57:14.050 --> 57:15.050
完成这个promise

57:15.050 --> 57:16.050
完成这个promise

57:16.050 --> 57:17.050
然后呢

57:17.050 --> 57:18.050
这里一个Zen

57:18.050 --> 57:19.050
目前这个promise

57:19.050 --> 57:20.050
是不是已经完成了

57:20.050 --> 57:21.050
已经完成了过后

57:21.050 --> 57:22.050
这个函数

57:22.050 --> 57:23.050
不好意思

57:23.050 --> 57:24.050
你进入围队里

57:24.050 --> 57:25.050
你不能马上执行

57:26.050 --> 57:27.050
你进入围队里

57:27.050 --> 57:28.050
说围队里边有加了一个

57:29.050 --> 57:31.050
输出promise2

57:33.050 --> 57:34.050
接下来继续运行

57:34.050 --> 57:35.050
script end

57:38.510 --> 57:39.510
运行完了之后

57:42.340 --> 57:43.340
从队里边排队了

57:44.340 --> 57:46.340
队里边有普通用户

57:46.340 --> 57:47.340
有vip

57:47.340 --> 57:48.340
小天后vip

57:48.340 --> 57:49.340
输出这个script end

57:51.340 --> 57:52.340
输出这个

57:52.340 --> 57:53.340
好 这句话输出过后

57:53.340 --> 57:54.340
这个函数反复的promise

57:54.340 --> 57:55.340
就OK了

57:55.340 --> 57:56.340
就完成了

57:56.340 --> 57:57.340
之前一直在挂起

57:57.340 --> 57:58.340
输出它

57:59.340 --> 58:00.340
然后再输出promise2

58:01.340 --> 58:02.340
就是这

58:03.340 --> 58:04.340
输出promise2

58:05.340 --> 58:07.650
好 围队的清空了

58:07.650 --> 58:08.650
再来红队里

58:08.650 --> 58:09.650
输出这个

58:10.650 --> 58:11.650
输出这个

58:12.650 --> 58:13.650
输出这个

58:15.650 --> 58:16.650
这些题你要背影

58:16.650 --> 58:17.650
怎么背得出

58:18.650 --> 58:19.650
对比一下

58:19.650 --> 58:20.650
肯定是没有问题的

58:21.650 --> 58:22.650
好 这就是咱们

58:22.650 --> 58:23.650
promise里边

58:23.650 --> 58:24.650
长期大家面试题

58:24.650 --> 58:26.650
还是比较复杂对吧

58:26.650 --> 58:27.650
有可能都听晕了

58:28.650 --> 58:29.650
这些题我跟你们说

58:30.650 --> 58:31.650
现阶段

58:32.650 --> 58:33.650
不对你们做过多的要求

58:33.650 --> 58:34.650
你们能听懂多少

58:34.650 --> 58:35.650
听懂多少

58:35.650 --> 58:36.650
尽量听懂一些

58:37.650 --> 58:38.650
平时我跟我们开发

58:38.650 --> 58:40.650
其实关系到

58:40.650 --> 58:41.650
不是特别大

58:41.650 --> 58:43.650
但是你这一点要知道

58:43.650 --> 58:44.650
它是

58:44.650 --> 58:45.650
你只剩下技术一点

58:45.650 --> 58:47.650
就GS代码它永远不会卡住

58:48.650 --> 58:49.650
不算在那里啥等

58:49.650 --> 58:50.650
等一个东西完成了

58:50.650 --> 58:51.650
完了过后

58:51.650 --> 58:52.650
我才继续往后运行

58:52.650 --> 58:53.650
它有事就去做

58:54.650 --> 58:56.650
这是GS的异部处理机制

58:56.650 --> 58:58.650
我不会等

58:58.650 --> 58:59.650
不会很干等

58:59.650 --> 59:00.650
我后边有事我就忙

59:00.650 --> 59:01.650
后边的时候就去了

59:02.650 --> 59:03.650
你那边完事过

59:03.650 --> 59:04.650
说为什么

59:04.650 --> 59:05.650
我们跑过来重新运行

59:05.650 --> 59:06.650
你就想好

59:07.650 --> 59:08.650
所以说

59:08.650 --> 59:09.650
这一部分

59:09.650 --> 59:10.650
前面几道题

59:10.650 --> 59:11.650
还比较关键一点

59:12.650 --> 59:13.650
前面几道题

59:13.650 --> 59:14.650
就在告诉你

59:14.650 --> 59:15.650
它不会卡住代码

59:15.650 --> 59:16.650
你看这里

59:17.650 --> 59:18.650
没有

59:18.650 --> 59:19.650
我这里

59:19.650 --> 59:20.650
然后说向这

59:23.650 --> 59:24.650
向这

59:26.650 --> 59:27.650
然后我这里

59:27.650 --> 59:28.650
等待了一秒钟过后

59:28.650 --> 59:29.650
它不会说

59:29.650 --> 59:31.650
我这边必须要等你一秒

59:31.650 --> 59:32.650
然后再运行这个

59:32.650 --> 59:34.650
然后再运行这个

59:34.650 --> 59:35.650
它不会卡住的

59:35.650 --> 59:36.650
它说等没有等

59:36.650 --> 59:37.650
你去等呗

59:37.650 --> 59:38.650
把技术现在去等呗

59:38.650 --> 59:39.650
等完了过后

59:39.650 --> 59:41.650
我回过头来再运行就完事了

59:42.650 --> 59:43.650
这一点大家要理解清楚

59:43.650 --> 59:44.650
这个而未成的

59:44.650 --> 59:46.650
它只是一个愚法堂

59:46.650 --> 59:48.650
感觉上的好像这个代码

59:48.650 --> 59:49.650
这个函数在卡住了

59:49.650 --> 59:51.650
别人感觉上是卡住的

59:51.650 --> 59:53.650
等待它过后再继续运行

59:53.650 --> 59:55.650
实际上是一个愚法堂

59:55.650 --> 59:56.650
后边单纯中心的实际上

59:56.650 --> 59:57.650
是在任你里面

59:57.650 --> 59:58.650
你可以这样理解

01:00:00.650 --> 01:00:01.650
好 这说到这结合的那种

01:00:01.650 --> 01:00:02.650
尽量理解吧

01:00:02.650 --> 01:00:04.650
因为你现在要说

01:00:04.650 --> 01:00:06.650
你一定要要求你

01:00:06.650 --> 01:00:08.650
把这些没道题理解得非常透彻

01:00:08.650 --> 01:00:10.650
可能不是很现实

01:00:11.650 --> 01:00:13.650
慢慢学到大家代码量的提升

01:00:13.650 --> 01:00:15.650
逻辑思维的能力的提升

01:00:16.650 --> 01:00:17.650
你能够真正到了

01:00:17.650 --> 01:00:19.650
面试的那个阶段的时候

01:00:19.650 --> 01:00:20.650
再回过头来看的话

01:00:20.650 --> 01:00:22.650
感触就会有不一样

01:00:22.650 --> 01:00:23.650
但是这些东西

01:00:23.650 --> 01:00:25.650
我必须要提前给你们说

01:00:25.650 --> 01:00:26.650
不说的话会不会讲起来

01:00:26.650 --> 01:00:28.650
讲某些知识的时候

01:00:28.650 --> 01:00:30.650
会有很多的隐患

01:00:31.650 --> 01:00:33.650
好 我希望了这一段时间

01:00:33.650 --> 01:00:34.650
大家学习这个ProMesh

01:00:34.650 --> 01:00:35.650
能够把我们课程里面

01:00:35.650 --> 01:00:37.650
理解个60%

01:00:37.650 --> 01:00:40.650
50%就不错了

01:00:40.650 --> 01:00:41.650
咱们面试的时候

01:00:41.650 --> 01:00:43.650
再回过头来复习

01:00:43.650 --> 01:00:44.650
如果说我现在这段

01:00:44.650 --> 01:00:45.650
见到人我啥都不讲

01:00:45.650 --> 01:00:46.650
直接等到你面试的时候

01:00:46.650 --> 01:00:47.650
来说的话

01:00:47.650 --> 01:00:48.650
你们就直接更加懵了

01:00:48.650 --> 01:00:50.650
而且还会对面试之前

01:00:50.650 --> 01:00:51.650
你们学习

01:00:51.650 --> 01:00:52.650
其他知识造成很多困执

01:00:53.650 --> 01:00:54.650
好 那么这一会就

01:00:54.650 --> 01:00:55.650
到此结束了

01:00:56.650 --> 01:00:57.650
拜拜

