WEBVTT

00:01.010 --> 00:04.410
咱们上一节课说到了支普串里边

00:04.410 --> 00:07.810
在ES6里边有更好的UdCode支持

00:07.810 --> 00:12.410
实际上在支普串里边除了支持UdCode之外

00:12.410 --> 00:17.010
还增加了一些API可以让我们在某些时候

00:17.010 --> 00:19.810
更加方便的来操作这个支普串

00:19.810 --> 00:22.610
我们这里后来介绍一下ES6里边

00:22.610 --> 00:25.210
给支普串新增的API

00:25.210 --> 00:26.410
就这么试个

00:26.410 --> 00:27.610
我们来看一下

00:27.610 --> 00:29.210
这里建个文件

00:30.210 --> 00:36.000
建个介绍引用

00:36.000 --> 00:40.540
实际上像这些测试代码

00:40.540 --> 00:42.940
我们其实都可以直接写到流量器

00:42.940 --> 00:44.140
控制台里边

00:44.140 --> 00:46.540
只不过这样子我写到这边

00:46.540 --> 00:47.740
给大家查阅

00:47.740 --> 00:48.940
好来吧

00:48.940 --> 00:51.140
第一个叫Rincludes

00:51.140 --> 00:51.940
这什么东西呢

00:51.940 --> 00:53.540
就是一个支普串里边

00:53.540 --> 00:55.940
它可以判断一个支普串里边

00:55.940 --> 00:59.740
是否包含一个传递的支普串

01:00.740 --> 01:01.740
判断

01:02.740 --> 01:05.140
这些都是支普串的实力方法

01:05.140 --> 01:10.140
以下均为支普串的实力方法

01:10.140 --> 01:11.540
什么叫实力方法

01:11.540 --> 01:13.540
就是在圆形上面的方法

01:13.540 --> 01:14.940
也叫做圆形方法

01:15.740 --> 01:16.740
圆形方法

01:16.740 --> 01:19.140
那么这个includes是判断

01:19.140 --> 01:24.740
支普串中是否包含指定的

01:24.740 --> 01:26.140
指支普串

01:26.740 --> 01:27.940
是这么个意思

01:27.940 --> 01:29.740
有的时候我们这其实是一个

01:29.740 --> 01:31.340
非常常见的功能

01:31.540 --> 01:33.540
在很多语言的支普串APN里边

01:33.540 --> 01:34.740
它都包含这个功能

01:34.740 --> 01:36.140
但是GS呢一直没有

01:36.140 --> 01:38.540
GS以前要判断支普串里边

01:38.540 --> 01:40.340
释放包含一个支普的话

01:40.340 --> 01:41.740
那么我们要用什么

01:41.740 --> 01:42.540
index-ov

01:42.540 --> 01:42.940
对吧

01:42.940 --> 01:44.940
或者是index-ov

01:44.940 --> 01:46.540
但是现在我们有的时候

01:46.540 --> 01:47.740
不需要知道它的下标

01:47.740 --> 01:49.340
我们只需要知道它存不存在

01:49.340 --> 01:51.340
我们就可以用includes

01:51.340 --> 01:53.140
那么看一下吧

01:53.140 --> 01:55.140
我们这里比方说有这么一个支普串

01:57.540 --> 01:58.340
test

01:58.340 --> 01:59.340
有这么一个支普串

01:59.340 --> 02:00.940
这个支普串我们随便写一下吧

02:01.340 --> 02:02.340
随便写一下

02:03.540 --> 02:04.340
诚哥很帅

02:07.340 --> 02:09.340
那么我们要判断这个支普串中

02:09.340 --> 02:12.340
是否包含很这个字

02:12.340 --> 02:14.340
是否包含很这个字

02:14.340 --> 02:18.340
诚哥是个很人

02:18.340 --> 02:20.340
那么是否包含很这个字

02:20.340 --> 02:22.340
那么我们怎么来判断呢

02:22.340 --> 02:24.340
我们以前是不是要用index-ov

02:24.340 --> 02:27.340
那么现在就可以使用includes

02:27.340 --> 02:28.340
那么这里

02:29.340 --> 02:31.340
表示在这个支普串中去查找

02:31.340 --> 02:33.340
你指定的支普串

02:33.340 --> 02:34.340
比方说我们这里查到它了

02:34.340 --> 02:35.340
查到很

02:37.340 --> 02:39.340
那么这里得到结果

02:39.340 --> 02:40.340
result

02:40.340 --> 02:43.340
那么这个反昏的结果自然而然是一个布尔

02:43.340 --> 02:45.340
要么为q 要么为force

02:45.340 --> 02:48.990
看一下吧

02:48.990 --> 02:50.990
我们这里打开控制台

02:51.990 --> 02:52.990
看一下这边

02:52.990 --> 02:53.990
你看是q对吧

02:53.990 --> 02:56.990
那如果说你这里查到一个

02:56.990 --> 02:57.990
不存在的字呢

02:57.990 --> 02:59.990
比方说我们这里写个囊

03:01.990 --> 03:03.990
就这么简单

03:03.990 --> 03:04.990
非常简单

03:04.990 --> 03:06.990
实际上这个查找

03:06.990 --> 03:08.990
它还可以指定查找位置

03:08.990 --> 03:10.990
如果说你

03:10.990 --> 03:13.990
如果说你没有给定第二个参数的话

03:13.990 --> 03:15.990
那么它查到的位置是整个支普串

03:15.990 --> 03:16.990
从0开始查找

03:16.990 --> 03:19.990
如果说你给定第二个参数的话

03:19.990 --> 03:21.990
那么它会从指定位置开始查找

03:21.990 --> 03:23.990
比方说我给

03:23.990 --> 03:26.990
我查找的位置是0 1 2 3

03:26.990 --> 03:29.990
从这个支普串中下标为3的位置

03:29.990 --> 03:30.990
开始查找

03:30.990 --> 03:31.990
看能不能找到

03:31.990 --> 03:32.990
你看是不是还是可以找到

03:32.990 --> 03:34.990
那么我如果我从下标为4的位置

03:34.990 --> 03:35.990
开始找

03:35.990 --> 03:36.990
你看是不是找不到了

03:36.990 --> 03:37.990
就这么简单

03:37.990 --> 03:38.990
非常简单

03:38.990 --> 03:41.990
这是关于includes

03:41.990 --> 03:42.990
那么下面这个两个

03:42.990 --> 03:45.990
也是用于查找支普串的

03:45.990 --> 03:47.990
那么这个start place

03:47.990 --> 03:48.990
表示的是判断

03:48.990 --> 03:52.990
支普串中是否包含

03:52.990 --> 03:59.990
是否以指定的支普串开始

03:59.990 --> 04:02.990
那么下面这个是判断

04:02.990 --> 04:06.990
支普串中是否以

04:06.990 --> 04:09.990
指定的支普串结位

04:09.990 --> 04:11.990
它主要是用于这么两个判断

04:11.990 --> 04:12.990
好来吧

04:12.990 --> 04:13.990
咱们来试一下

04:13.990 --> 04:15.990
还是以这个为例

04:15.990 --> 04:16.990
还是以这个为例

04:16.990 --> 04:17.990
我们这里呢

04:17.990 --> 04:18.990
这样子写吧

04:18.990 --> 04:20.990
这样子写

04:20.990 --> 04:23.990
是否包含

04:28.990 --> 04:29.990
是否包含

04:29.990 --> 04:31.990
很这个字

04:31.990 --> 04:34.990
我们这里使用这个表达式

04:34.990 --> 04:36.990
使用这个表达式

04:36.990 --> 04:38.990
那么下面我们再来

04:38.990 --> 04:42.990
是否以

04:42.990 --> 04:48.990
乘哥开头

04:48.990 --> 04:49.990
那么这里要怎么判断呢

04:49.990 --> 04:50.990
我们就不能用includes

04:50.990 --> 04:51.990
因为includes的话

04:51.990 --> 04:52.990
它判断的是

04:52.990 --> 04:53.990
只要支普串包含就行

04:53.990 --> 04:54.990
它不一定是开头

04:54.990 --> 04:55.990
所以我们用这里

04:55.990 --> 04:56.990
start place

04:56.990 --> 04:57.990
其实这个东西

04:57.990 --> 04:58.990
就相当于是

04:58.990 --> 04:59.990
in这个时候

04:59.990 --> 05:00.990
是不是等于0

05:00.990 --> 05:01.990
对吧

05:01.990 --> 05:02.990
相当于是这个

05:02.990 --> 05:04.990
乘哥

05:04.990 --> 05:06.990
那么下面这个

05:06.990 --> 05:08.990
是否以

05:08.990 --> 05:10.990
是否以乘哥结尾

05:10.990 --> 05:13.990
是否以狠人结尾吧

05:13.990 --> 05:16.990
狠人结尾

05:16.990 --> 05:19.620
这里呢

05:19.620 --> 05:21.620
我们就使用end ways

05:21.620 --> 05:23.620
就非常的简单

05:23.620 --> 05:27.620
这是狠人

05:27.620 --> 05:29.620
好保存

05:29.620 --> 05:30.620
那厉害

05:30.620 --> 05:31.620
是不是判断出来了

05:31.620 --> 05:32.620
以后呢

05:32.620 --> 05:33.620
我们判断一包含之不错的话

05:33.620 --> 05:36.620
如果你不是很在乎它的位置

05:36.620 --> 05:38.620
只是要在乎它是否包含的话

05:38.620 --> 05:39.620
那么又includes

05:39.620 --> 05:41.620
或者是start ways

05:41.620 --> 05:42.620
end ways

05:42.620 --> 05:43.620
都是非常合适的

05:43.620 --> 05:44.620
好

05:44.620 --> 05:45.620
最后一个

05:45.620 --> 05:46.620
repeat

05:46.620 --> 05:47.620
repeat

05:47.620 --> 05:48.620
这个函数

05:48.620 --> 05:49.620
它是

05:49.620 --> 05:51.620
以

05:51.620 --> 05:53.620
将

05:53.620 --> 05:54.620
制服串

05:54.620 --> 05:56.620
重复

05:56.620 --> 05:58.620
指定的次数

05:58.620 --> 05:59.620
然后

05:59.620 --> 06:02.620
返回一个新制服串

06:02.620 --> 06:03.620
新制服串

06:03.620 --> 06:05.620
就非常有意思

06:05.620 --> 06:06.620
比方说

06:06.620 --> 06:09.620
咱们以这个制服串为例吧

06:09.620 --> 06:10.620
重复

06:10.620 --> 06:12.620
重复4次

06:12.620 --> 06:13.620
重复4次

06:13.620 --> 06:14.620
那么怎么写呢

06:14.620 --> 06:16.620
我们这里就可以这样写

06:16.620 --> 06:17.620
text

06:17.620 --> 06:18.620
repeat

06:18.620 --> 06:19.620
这里写个次数

06:19.620 --> 06:20.620
比方说4

06:20.620 --> 06:21.620
那么这样子一来

06:21.620 --> 06:22.620
这个表达是

06:22.620 --> 06:23.620
这个函数

06:23.620 --> 06:25.620
它会返回一个新的制服串

06:25.620 --> 06:26.620
这个新的制服串

06:26.620 --> 06:27.620
就是把当前这个制服串

06:27.620 --> 06:28.620
重复4次

06:28.620 --> 06:30.620
你看一下

06:30.620 --> 06:31.620
是不是出来了

06:31.620 --> 06:33.620
特别简单

06:33.620 --> 06:35.620
其他就没了

06:35.620 --> 06:36.620
其他就没了

06:36.620 --> 06:37.620
当然这个

06:37.620 --> 06:38.620
start with

06:38.620 --> 06:39.620
和end with

06:39.620 --> 06:41.620
它也可以给第二个参数

06:41.620 --> 06:44.620
以什么位置开头

06:44.620 --> 06:46.620
以什么位置开始查找

06:46.620 --> 06:47.620
比方说

06:47.620 --> 06:48.620
它这里

06:48.620 --> 06:49.620
第二个参数的意思就是说

06:49.620 --> 06:50.620
比方说我写个3

06:50.620 --> 06:52.620
那么指的是什么意思呢

06:52.620 --> 06:53.620
第三个位置

06:53.620 --> 06:55.620
就下标为3的那个位置

06:55.620 --> 06:56.620
0123

06:56.620 --> 06:57.620
这个位置

06:57.620 --> 06:59.620
必须要是乘隔开头

06:59.620 --> 07:00.620
从这个位置开始找

07:00.620 --> 07:01.620
必须要是乘隔

07:01.620 --> 07:02.620
什么个意思

07:02.620 --> 07:04.620
这个东西没什么好说的

07:04.620 --> 07:05.620
好就没了

07:05.620 --> 07:06.620
这就是新增的

07:06.620 --> 07:07.620
这个制服串API

07:07.620 --> 07:08.620
大家下来

07:08.620 --> 07:09.620
去用一遍

07:09.620 --> 07:10.620
用一遍就够了

07:10.620 --> 07:11.620
有点这么一个点印象

07:11.620 --> 07:12.620
知道这里这么个功能

07:12.620 --> 07:13.620
就行了

