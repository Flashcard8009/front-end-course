WEBVTT

00:00.750 --> 00:05.510
在面向对象里边呢有一种内之间的关系啊

00:05.510 --> 00:06.750
它叫做继承

00:06.750 --> 00:09.510
就是我们内是什么东西呢

00:09.510 --> 00:10.990
内其实就是一个内形

00:10.990 --> 00:11.350
对吧

00:11.350 --> 00:13.270
我们的那个他

00:13.270 --> 00:15.790
GS里边他本身提供了一些内形

00:15.790 --> 00:16.870
比方说字不错啊

00:16.870 --> 00:17.990
数字啊

00:17.990 --> 00:20.590
还有什么啊

00:20.590 --> 00:21.710
布尔啊

00:21.710 --> 00:23.470
还有什么对象对吧

00:23.470 --> 00:25.510
而实际上呢

00:25.510 --> 00:27.270
内形这些内形呢是不够的

00:27.270 --> 00:30.510
比方说我们要做一个文章管理系统

00:30.510 --> 00:32.110
那还得有文章内形吧

00:32.110 --> 00:32.790
对吧

00:32.790 --> 00:33.790
比方说我们这里呢

00:33.790 --> 00:35.830
还有一个动物内形对不对

00:35.830 --> 00:38.230
而内形与内形之间呢

00:38.230 --> 00:40.110
它是有一点关系的

00:40.110 --> 00:42.270
我们把这有一种关系呢

00:42.270 --> 00:44.110
他就叫做继承

00:44.110 --> 00:45.790
那么继承是什么样的关系呢

00:45.790 --> 00:47.670
就是我们这几个要讨论的啊

00:47.670 --> 00:48.390
内的继承

00:49.470 --> 00:50.910
继承他描述一种什么关系呢

00:50.910 --> 00:57.110
就是如果两个内可以使用啊

00:57.150 --> 00:58.710
什么什么啊

00:58.710 --> 01:01.150
是什么什么啊

01:01.150 --> 01:02.310
我们会说啊

01:02.310 --> 01:06.030
两个内AA和B

01:08.150 --> 01:08.270
啊

01:08.270 --> 01:10.030
我给大家讲的是

01:10.030 --> 01:13.150
如何在实际的应用中去判断两个内

01:13.150 --> 01:15.110
是否有继承关系

01:15.110 --> 01:17.350
如果是可以使用啊

01:17.350 --> 01:21.830
如果可以描述为什么呢

01:21.830 --> 01:24.470
就是A4B啊

01:24.470 --> 01:27.070
或者是B4A啊

01:27.150 --> 01:28.270
B是一个A

01:28.270 --> 01:33.870
则A和B形成继承关系

01:33.870 --> 01:34.390
啊

01:34.390 --> 01:34.870
以后呢

01:34.870 --> 01:37.390
你要描述两个内到底是不是继承关系呢

01:37.390 --> 01:37.990
啊

01:37.990 --> 01:39.990
那么你就用这样的方式来描述

01:39.990 --> 01:43.550
比方说猫是动物

01:43.550 --> 01:46.030
那猫和动物之间是不是继承关系

01:46.030 --> 01:46.710
对吧

01:46.710 --> 01:47.990
狗是一个动物

01:47.990 --> 01:51.190
狗和动物之间是一个继承关系

01:51.190 --> 01:54.230
比方说男人是人

01:54.230 --> 01:55.630
女人是人

01:55.670 --> 01:58.550
那么男人和人之间形成继承关系

01:58.550 --> 02:01.070
女人和人之间形成继承关系

02:01.070 --> 02:02.270
这样的意思吧

02:02.270 --> 02:03.550
啊啊

02:03.550 --> 02:05.110
男同学是男人

02:05.110 --> 02:05.470
ok

02:05.470 --> 02:09.550
那么男同学和男人之间形成继承关系

02:09.550 --> 02:10.870
对吧

02:10.870 --> 02:12.230
啊啊

02:12.230 --> 02:14.350
那比方说啊

02:14.350 --> 02:16.150
成哥是帅哥

02:16.150 --> 02:16.390
诶

02:16.390 --> 02:17.630
成哥和帅哥啊

02:17.630 --> 02:19.230
如果说有两个内的话啊

02:19.230 --> 02:20.510
形成继承关系

02:20.510 --> 02:20.630
啊

02:20.630 --> 02:21.310
当然这个说法呢

02:21.310 --> 02:23.510
不是很严格的啊

02:23.510 --> 02:23.670
好

02:23.670 --> 02:24.750
那么这里呢

02:24.750 --> 02:26.710
你看我们这里有了一个动物的类

02:26.710 --> 02:26.870
对吧

02:26.870 --> 02:29.030
我们以前的写法是写这么一个构造函数

02:29.030 --> 02:29.470
实际上呢

02:29.470 --> 02:30.430
整个加起来了

02:30.430 --> 02:32.190
整个把它看成一个整体的话

02:32.190 --> 02:33.870
实际上它就是一个类

02:33.870 --> 02:35.390
那么动物

02:35.390 --> 02:37.190
是不是有很多具体的动物啊

02:37.190 --> 02:37.870
对吧

02:37.870 --> 02:38.510
那么

02:38.510 --> 02:39.990
比方猫是一个动物啊

02:39.990 --> 02:40.790
狗是一个动物

02:40.790 --> 02:41.590
那么它会

02:41.590 --> 02:44.150
如果说猫和狗还有这么两个类的话

02:44.150 --> 02:46.910
它和动物之间就会形成继承关系

02:46.910 --> 02:49.270
那么这个继承关系有什么意义呢

02:49.270 --> 02:51.150
你想这个道理啊

02:51.150 --> 02:52.470
如果说

02:52.470 --> 02:54.270
b啊

02:54.270 --> 02:55.750
4a

02:55.750 --> 02:57.270
比方说猫是动物

02:57.270 --> 03:01.030
那么猫里边是不是有动物的所有的特征啊

03:01.030 --> 03:01.270
哎

03:01.270 --> 03:02.430
动物该有的东西

03:02.430 --> 03:03.190
它都应该有

03:03.190 --> 03:04.390
因为它是一个动物

03:04.390 --> 03:05.670
是吧

03:05.670 --> 03:06.950
男人是人

03:06.950 --> 03:10.270
那男人是不是应该有人的所有的特征

03:10.270 --> 03:12.750
那么也就是说具体到我们的

03:12.750 --> 03:14.310
代码层面的话

03:14.310 --> 03:17.350
就是说如果形成了继承关系的话

03:17.350 --> 03:19.550
那么谁谁是谁

03:19.550 --> 03:21.510
那么谁就拥有啊

03:21.510 --> 03:22.470
比方b4a

03:22.470 --> 03:25.830
那么b就会拥有a里边的所有东西啊

03:25.830 --> 03:27.070
这就是继承关系

03:27.070 --> 03:27.830
其实这个关系呢

03:27.830 --> 03:31.630
我也不用去过多的去过细的去讲解了

03:31.630 --> 03:33.950
因为这个里面肯定之前是学过的啊

03:33.950 --> 03:35.990
就是你们不是学过胜碑模式吗

03:35.990 --> 03:38.110
在诚哥的公开直播课里边啊

03:38.110 --> 03:39.030
公益课程里边

03:39.030 --> 03:41.030
他就已经提到了啊

03:41.030 --> 03:41.150
好

03:41.150 --> 03:42.230
那么这个继承关系呢

03:42.230 --> 03:43.110
我们还有很多

03:43.110 --> 03:44.550
在人变相对象的领域里边呢

03:44.550 --> 03:45.390
还有很多说法

03:45.390 --> 03:47.790
我给大家说一下啊

03:47.790 --> 03:49.470
如果b4a

03:49.510 --> 03:51.790
如果b4a

03:51.790 --> 03:55.270
那么则有下面的一系列说法

03:55.270 --> 03:57.270
b继承制

03:57.270 --> 03:58.710
继承制

03:58.710 --> 03:59.630
a

03:59.630 --> 04:00.550
还有什么

04:00.550 --> 04:02.550
a派生b

04:02.550 --> 04:03.710
全是一样的意思啊

04:03.710 --> 04:04.750
全是一样的意思

04:04.750 --> 04:07.630
就是各种说法不一样啊

04:07.630 --> 04:09.430
然后呢说什么呢

04:09.430 --> 04:12.830
b4a的纸类

04:12.830 --> 04:15.070
a4b的附类

04:15.070 --> 04:18.830
这都是面向对象领域里边的一种说法

04:18.830 --> 04:20.430
比方说猫是动物

04:20.430 --> 04:22.630
那么猫就继承制动物

04:22.630 --> 04:24.350
动物派生猫

04:24.350 --> 04:27.350
猫是动物的纸类啊

04:27.350 --> 04:30.150
动物是猫的附类

04:30.150 --> 04:30.310
好

04:30.310 --> 04:33.950
那么把这个关系形成之后呢啊

04:33.950 --> 04:37.430
如果a4b的附类

04:37.430 --> 04:41.710
则啊b会自动拥有

04:41.710 --> 04:46.830
a中的所有实力成员啊

04:46.830 --> 04:47.630
包括方法啊

04:47.630 --> 04:48.310
包括属性

04:48.310 --> 04:49.270
会自动拥有

04:49.270 --> 04:53.270
这就是继承需要在代码层面表达出来的含义

04:53.270 --> 04:54.830
因为这个逻辑上也是这样子嘛

04:54.830 --> 04:55.510
猫是一个动物

04:55.510 --> 04:56.310
狗是一个动物

04:56.310 --> 04:57.390
那么狗既然是动物

04:57.390 --> 04:59.070
它动物有的东西它一定有

04:59.070 --> 05:00.390
比方动物有内想

05:00.390 --> 05:01.030
那狗也有

05:01.030 --> 05:01.950
得有内想

05:01.950 --> 05:02.830
动物里有名字

05:02.830 --> 05:04.030
狗也得有名字

05:04.030 --> 05:04.990
动物有年龄

05:04.990 --> 05:05.910
狗也得有年龄

05:05.910 --> 05:06.430
对吧

05:06.430 --> 05:08.990
动物里边有的东西它都得有

05:08.990 --> 05:09.630
对不对

05:09.630 --> 05:11.430
那么它自己特有的东西呢

05:11.430 --> 05:13.110
那动物就不一定有了啊

05:13.110 --> 05:14.630
就形成这么一种关系

05:14.630 --> 05:15.310
这种关系呢

05:15.310 --> 05:16.950
在面向对象里边开发的时候呢

05:17.910 --> 05:20.230
因为有了这么一种关系之后呢

05:20.230 --> 05:22.070
我们把一些啊

05:22.070 --> 05:25.470
有就是有很多的类的话

05:25.470 --> 05:28.590
我们可以把它抽象一些公共的成员出来

05:28.590 --> 05:30.630
比方说特别是在玩游戏里边啊

05:30.630 --> 05:31.790
就特别明显

05:31.790 --> 05:34.550
呃比方说说一个什么飞机大战啊

05:34.550 --> 05:35.710
有各种各样的飞机对吧

05:35.710 --> 05:36.390
不同的飞机呢

05:36.390 --> 05:38.030
是一个类啊

05:38.030 --> 05:39.070
不同的飞机是一个类

05:39.070 --> 05:40.630
那么这些飞机的共同的特征

05:40.630 --> 05:42.790
那我们可以把提取提取成一个附类

05:42.790 --> 05:43.510
对吧啊

05:43.510 --> 05:45.590
可以形成这么一种关系啊

05:45.590 --> 05:46.430
那么在以前

05:46.870 --> 05:47.590
因为这些东西呢

05:47.590 --> 05:48.950
你们以前都是学习过了

05:48.950 --> 05:50.870
所以说我我这里提一下

05:50.870 --> 05:51.270
呃

05:51.270 --> 05:55.070
那以前在构造函数里边如何来做一个

05:55.070 --> 05:56.590
纸类出来了啊

05:56.590 --> 05:57.430
这是附类吧

05:57.430 --> 05:59.710
我现在比方说要写一个狗的类

05:59.710 --> 06:00.430
那怎么写呢

06:00.430 --> 06:01.190
是不是方形

06:02.590 --> 06:04.230
方形啊

06:04.230 --> 06:05.630
到狗嘛

06:05.630 --> 06:06.270
对吧

06:06.270 --> 06:07.430
那狗又什么呢

06:07.430 --> 06:08.790
狗需不需要给它类型呢

06:08.790 --> 06:09.590
它有类型

06:09.590 --> 06:11.190
但是你不需要给它类型

06:11.190 --> 06:12.390
因为狗的类型呢

06:12.390 --> 06:14.190
动物的种类不就是狗吗

06:14.190 --> 06:14.510
对吧

06:14.510 --> 06:15.550
全类对吧

06:15.590 --> 06:16.830
全类啊

06:16.830 --> 06:19.390
那么你只需要给这个狗的宠物名字啊

06:19.390 --> 06:20.550
狗的年龄

06:20.550 --> 06:21.870
狗的性别就行了

06:21.870 --> 06:22.590
对不对啊

06:22.590 --> 06:23.990
是不是这样子写的

06:23.990 --> 06:24.390
哎

06:24.390 --> 06:25.070
那这里边呢

06:25.070 --> 06:27.430
我们需不需要把这个单码重新写一遍呢

06:27.430 --> 06:28.430
需不需要写一遍呢

06:28.430 --> 06:29.110
那不需要了

06:29.110 --> 06:30.150
写的话就重复了

06:30.150 --> 06:31.110
对不对啊

06:31.110 --> 06:33.350
那么既然它是它的纸类

06:33.350 --> 06:37.110
我我们希望了这个纸类里边拥有附类里边的成员

06:37.110 --> 06:38.470
那么我们是怎么做的呢

06:38.470 --> 06:40.070
以前打做的回忆一下啊

06:40.070 --> 06:42.830
以前我们是不是去借用啊

06:42.830 --> 06:44.350
animal的构造函数对吧

06:44.390 --> 06:45.110
我们使用啊

06:45.110 --> 06:47.030
比方说使用core啊

06:47.030 --> 06:48.630
借用animal的构造函数

06:48.630 --> 06:50.550
那么绑定Z是关键字啊

06:50.550 --> 06:51.910
把当前创建狗

06:51.910 --> 06:54.190
创建一只狗的Z是绑定进去

06:54.190 --> 06:54.510
然后呢

06:54.510 --> 06:56.430
把它的额外参数给它放进去

06:56.430 --> 06:57.790
它不是要有4个参数吗

06:57.790 --> 06:57.990
好

06:57.990 --> 06:59.390
第一个参数是type

06:59.390 --> 07:01.510
type我这里也不需要给我传递

07:01.510 --> 07:03.830
因为狗的类型是不是确定的

07:03.830 --> 07:04.910
狗的种类是确定的

07:04.910 --> 07:06.190
我直接给你传就行了啊

07:06.190 --> 07:07.550
全类啊

07:07.550 --> 07:08.990
全类对不对

07:08.990 --> 07:09.230
好

07:09.230 --> 07:10.150
然后呢

07:10.150 --> 07:11.390
呃

07:11.390 --> 07:12.550
狗的名字啊

07:12.550 --> 07:13.910
名字就是来自于参数

07:13.950 --> 07:15.190
狗的年龄来自于参数

07:15.190 --> 07:16.470
狗的性别来自于参数

07:16.470 --> 07:18.910
是不是我们借用负类的构造函数

07:18.910 --> 07:19.150
对吧

07:19.150 --> 07:23.510
这里是借用负类的构造函数

07:23.510 --> 07:25.430
也就是把负类的构造函数运行一次

07:25.430 --> 07:27.630
我们就不用去写这个重复代码了

07:27.630 --> 07:28.750
是这么个意思

07:28.750 --> 07:29.910
那么呃

07:29.910 --> 07:31.510
通过运行负类的构造函数

07:31.510 --> 07:33.670
又把Z当前的这只狗啊

07:33.670 --> 07:34.670
Z是绑定进去

07:34.670 --> 07:35.430
于是呢

07:35.430 --> 07:37.110
它狗里边就加这些成员了

07:37.110 --> 07:37.310
好

07:37.310 --> 07:39.150
咱们来试一下啊

07:39.150 --> 07:39.750
咱们来试一下

07:40.990 --> 07:41.310
呃

07:41.310 --> 07:41.910
const

07:41.910 --> 07:42.430
D

07:42.430 --> 07:43.790
nu一个dog

07:43.830 --> 07:45.190
新建一只狗啊

07:45.190 --> 07:48.700
狗的话妄裁

07:48.700 --> 07:49.140
然后呢

07:49.140 --> 07:50.260
狗的年龄啊

07:50.260 --> 07:52.020
狗的年龄三岁吧

07:52.020 --> 07:53.100
狗的性别啊

07:54.180 --> 07:55.100
公啊

07:55.100 --> 07:55.300
公

07:57.780 --> 07:57.940
好

07:57.940 --> 07:58.740
我们这里输出啊

07:58.740 --> 08:00.180
输出一只狗

08:00.180 --> 08:00.780
保存

08:00.780 --> 08:01.220
这里呢

08:01.220 --> 08:01.900
我们运行出来

08:03.540 --> 08:07.780
看一下吧

08:07.780 --> 08:08.220
好

08:08.220 --> 08:10.780
那么我们借用了负类的构造函数

08:10.780 --> 08:11.300
呃

08:11.300 --> 08:13.220
那么在狗里边是不是加了这些属性了

08:13.220 --> 08:13.780
对吧

08:13.780 --> 08:14.180
你看一下

08:14.180 --> 08:15.180
直接对照一下啊

08:15.180 --> 08:16.140
是不是加了这些属性了

08:16.140 --> 08:17.100
这个大家应该理解啊

08:17.540 --> 08:18.980
这些都是技术的事

08:18.980 --> 08:19.300
但是呢

08:19.300 --> 08:21.620
现在有一个问题就是狗里边呢

08:21.620 --> 08:22.900
它在圆形上面

08:22.900 --> 08:23.820
它圆形直接是

08:24.380 --> 08:25.580
objects

08:25.580 --> 08:26.380
objects

08:26.380 --> 08:28.780
因此它的圆形上面呢

08:28.780 --> 08:29.140
呃

08:29.140 --> 08:31.660
是没有这个printer还出的

08:31.660 --> 08:32.900
有圆形上的东西呢

08:32.900 --> 08:34.460
我没有继承过来

08:34.460 --> 08:35.340
那么怎么办呢

08:35.340 --> 08:36.620
圆形上的继承

08:36.620 --> 08:39.100
那么我给大家画个图呗啊

08:39.100 --> 08:40.260
给大家画个图呗

08:40.260 --> 08:41.460
圆形上的继承呢

08:41.460 --> 08:43.220
我们一定要形成这么一种结构

08:43.220 --> 08:45.100
而就不管你用什么方式

08:45.100 --> 08:46.700
你一定要形成这么一种结构

08:46.740 --> 08:47.620
比方说这里呢

08:47.620 --> 08:49.940
是animal的构造函数啊

08:49.940 --> 08:51.540
这是animal

08:51.540 --> 08:52.900
animal的构造函数

08:53.740 --> 08:54.460
构造器

08:56.340 --> 08:58.140
那么这个animal函数啊

08:58.140 --> 09:00.500
我们就写animal

09:00.500 --> 09:00.780
行吧

09:00.780 --> 09:01.980
就写animal

09:01.980 --> 09:03.180
表示animal的构造函数

09:05.100 --> 09:07.220
那么它是不是有个圆形啊

09:07.220 --> 09:08.260
它是不是有个圆形啊

09:08.260 --> 09:09.060
这个好我以为啊

09:09.060 --> 09:10.580
它肯定是有一个圆形的

09:12.460 --> 09:13.060
那么这里呢

09:13.060 --> 09:14.620
叫做animal

09:15.620 --> 09:18.060
Prototype

09:18.060 --> 09:19.620
这是animal的圆形

09:19.620 --> 09:21.300
那么现在我们有了一只狗

09:21.300 --> 09:21.900
对吧

09:21.900 --> 09:23.420
狗的这个构造函数

09:23.420 --> 09:24.860
那么我们现在让通过

09:24.860 --> 09:26.140
在狗的构造函数里面

09:26.140 --> 09:27.300
去雕用animal

09:27.300 --> 09:28.260
那么我们就可以

09:28.260 --> 09:29.980
往创建狗的对象上面

09:29.980 --> 09:30.860
是不是去加东西

09:30.860 --> 09:31.260
对吧

09:31.260 --> 09:31.740
到时候呢

09:31.740 --> 09:32.540
我们会

09:32.540 --> 09:34.380
创建狗的对象

09:34.380 --> 09:36.220
通过六关键字

09:36.220 --> 09:37.940
是不是来创建一只狗的对象

09:37.940 --> 09:39.100
多个对象

09:39.100 --> 09:42.660
怎么来创建的

09:42.660 --> 09:43.900
是不是通过六一个

09:43.900 --> 09:44.580
创建的

09:44.580 --> 09:45.180
对吧

09:45.860 --> 09:47.500
通过六一个道个来创建的

09:49.420 --> 09:50.660
这是通过六

09:50.660 --> 09:51.300
通过六

09:52.620 --> 09:53.500
六关键字

09:53.500 --> 09:55.180
那么来创建一个狗的对象

09:55.180 --> 09:57.740
那狗的对象是不是有个隐私圆形啊

09:57.740 --> 09:58.380
对不对

09:58.380 --> 10:00.740
是不是就得有个隐私圆形

10:00.740 --> 10:03.180
那么它得有一个隐私圆形

10:03.180 --> 10:04.380
这个是圆形的

10:04.380 --> 10:05.100
这个是圆形

10:05.100 --> 10:09.060
我们把它拿过来啊

10:09.060 --> 10:09.540
画个图

10:09.540 --> 10:11.060
大家理解得更加清楚一点

10:11.060 --> 10:11.900
因为这个知识呢

10:11.900 --> 10:12.900
可能对你们来说

10:12.900 --> 10:14.700
可能比较久远了

10:14.700 --> 10:16.740
Prototype

10:16.780 --> 10:18.460
这是animal的Prototype

10:18.460 --> 10:20.700
那么它通过Prototype

10:20.700 --> 10:21.860
是不是可以找到它的圆形

10:21.860 --> 10:22.940
那么这个多个的

10:22.940 --> 10:24.820
多个的隐私圆形

10:24.820 --> 10:26.700
隐私圆形

10:26.700 --> 10:28.380
是不是多个

10:28.380 --> 10:29.380
是不是来自于

10:29.380 --> 10:30.100
来自于啥呢

10:30.100 --> 10:30.900
它的隐私圆形

10:30.900 --> 10:33.060
是不是来自于多个的Prototype

10:33.060 --> 10:33.820
对吧

10:33.820 --> 10:36.460
是不是来自于多个的Prototype

10:36.460 --> 10:38.340
Prototype

10:38.340 --> 10:39.580
那么应该在这

10:39.580 --> 10:40.580
应该在这

10:42.260 --> 10:45.740
这是狗这个对象的隐私圆形

10:45.740 --> 10:46.700
对不对

10:46.900 --> 10:48.820
我们如果说

10:48.820 --> 10:50.860
现在文的Print方法在哪

10:50.860 --> 10:52.100
Print方法是不是在这

10:52.100 --> 10:52.500
对不对

10:52.500 --> 10:53.580
Print方法在这

10:53.580 --> 10:55.340
但是狗的隐私圆形里面

10:55.340 --> 10:56.420
有没有Print方法

10:56.420 --> 10:57.020
没有

10:57.020 --> 10:58.860
因为它的隐私圆形

10:58.860 --> 11:00.260
是不是指向狗的圆形

11:00.260 --> 11:00.700
对吧

11:00.700 --> 11:01.940
它是指向狗的圆形

11:01.940 --> 11:03.380
好好理解下一个图

11:03.380 --> 11:04.860
它指向的是狗的圆形

11:04.860 --> 11:05.940
那么狗的圆形里面

11:05.940 --> 11:06.940
有一个隐私圆形

11:06.940 --> 11:07.700
它指向谁

11:07.700 --> 11:09.620
它指向OBG车的圆形

11:09.620 --> 11:11.780
OBG车的Prototype

11:11.780 --> 11:14.460
它目前是这么一种关系

11:15.460 --> 11:16.660
看一下吧

11:16.660 --> 11:18.260
它目前是这么一种关系

11:19.500 --> 11:20.780
那么OBG车的Prototype

11:20.780 --> 11:22.060
隐私圆形来指向狗

11:22.060 --> 11:22.860
对吧

11:22.860 --> 11:25.260
这个就是那个圆形链

11:25.260 --> 11:25.980
看到没

11:25.980 --> 11:27.340
它的隐私圆形指向它

11:27.340 --> 11:28.580
它的隐私圆形指向它

11:28.580 --> 11:30.180
它的隐私圆形指向狗

11:30.180 --> 11:31.300
我就变化了

11:31.300 --> 11:32.540
那么这就是圆形链

11:32.540 --> 11:34.780
那么当我们找它的成员的时候

11:34.780 --> 11:35.580
首先看这个对象

11:35.580 --> 11:36.740
本身上有没有了

11:36.740 --> 11:37.740
它本身有什么了

11:37.740 --> 11:39.180
本身有什么Type

11:39.180 --> 11:40.100
本身有Name

11:40.100 --> 11:40.860
本身有Age

11:40.860 --> 11:41.740
本身有Sex

11:41.740 --> 11:42.220
对吧

11:42.220 --> 11:44.220
它本身有这么一些属性

11:44.260 --> 11:45.260
但是这一属性

11:45.260 --> 11:46.020
还有一些方法

11:46.020 --> 11:47.780
我们是在圆形上面

11:47.780 --> 11:48.860
首先对象里边没有

11:48.860 --> 11:50.340
它就从圆形链上去找

11:50.340 --> 11:51.020
一找一找

11:51.020 --> 11:51.620
找不到

11:51.620 --> 11:52.620
找不到的话就没有

11:52.620 --> 11:54.260
所以说现在狗里边

11:54.260 --> 11:56.340
是没有Print盘书的

11:56.340 --> 11:59.860
你看它的Prototype

11:59.860 --> 12:00.460
指向材的

12:00.460 --> 12:03.140
指向DogPrototype

12:03.140 --> 12:04.580
DogPrototype

12:04.580 --> 12:06.900
就是隐私圆形来指向OBG车

12:06.900 --> 12:08.900
OBG车Prototype就没有了

12:08.900 --> 12:10.100
就没有了

12:10.100 --> 12:11.580
这么个意思

12:11.580 --> 12:14.780
如果说我们要形成继承关系

12:14.780 --> 12:16.900
我们一定要把这个东西

12:16.900 --> 12:18.460
就是狗的圆形

12:18.460 --> 12:20.060
它的隐私圆形

12:20.060 --> 12:21.100
要指向材

12:21.100 --> 12:22.620
要指向它

12:22.620 --> 12:24.540
这是我们一定要办到的

12:24.540 --> 12:25.700
如果你办到了这一点

12:25.700 --> 12:27.700
你就可以形成继承关系

12:27.700 --> 12:28.460
如果你办不到

12:28.460 --> 12:29.940
那就形成继承关系

12:29.940 --> 12:31.260
就是不管你用什么方式

12:31.260 --> 12:32.740
你一定要够组成这个样子

12:32.740 --> 12:34.540
它的圆形链一定要是这样子

12:34.540 --> 12:35.460
这样子的话

12:35.460 --> 12:36.740
那么狗的话

12:36.740 --> 12:41.500
它才能够叫做继承制Animal

12:41.500 --> 12:42.380
狗是一个动物

12:42.380 --> 12:43.940
那么狗是继承Animal的

12:43.940 --> 12:45.740
你就在代码层面

12:45.740 --> 12:47.980
你就必须要形成这么一种圆形链

12:47.980 --> 12:49.060
那么这样子一来的话

12:49.060 --> 12:49.980
你看Printer在这

12:49.980 --> 12:50.260
对吧

12:50.260 --> 12:51.300
Printer在这

12:51.300 --> 12:53.220
那么狗的话

12:53.220 --> 12:54.900
狗去使用Printer方法

12:54.900 --> 12:55.700
它自己没有

12:55.700 --> 12:57.340
它从狗的圆形里边没有

12:57.340 --> 12:57.980
狗的圆形没有

12:57.980 --> 12:59.100
但是它上面还有

12:59.100 --> 13:00.300
上面它是Animal

13:00.300 --> 13:01.300
Animal的圆形

13:01.300 --> 13:02.620
Animal的圆形是不是找到了

13:02.620 --> 13:04.340
就可以使用Printer了

13:04.340 --> 13:05.020
这样子一来

13:05.020 --> 13:06.060
我既不会

13:06.060 --> 13:07.020
不要说到时候

13:07.020 --> 13:08.620
我会给狗的圆形上

13:08.620 --> 13:10.380
加一些特别的函数

13:10.380 --> 13:12.180
可以它不会影响负累

13:12.180 --> 13:13.460
不会影响Animal

13:13.460 --> 13:15.260
对Animal不会产生影响

13:15.260 --> 13:16.940
因为这是狗特有的东西

13:16.940 --> 13:17.700
动物里边

13:17.700 --> 13:19.020
它只提供动物里边

13:19.020 --> 13:21.020
所有公共的东西

13:21.020 --> 13:22.700
狗里边的具体的纸内里边

13:22.700 --> 13:23.500
只提供

13:23.500 --> 13:25.100
纸内里边特有的东西

13:25.100 --> 13:27.260
就形成了这么一种继承关系

13:27.260 --> 13:29.180
所以说这个继承关系该怎么来设置呢

13:29.180 --> 13:30.620
我们要做的事情就是

13:30.620 --> 13:32.900
把狗的圆形的

13:32.900 --> 13:35.420
影视圆形

13:35.420 --> 13:37.980
设置为Animal的圆形

13:37.980 --> 13:39.100
以前我们要用

13:39.140 --> 13:40.900
生备模式写大队代码

13:40.900 --> 13:42.460
那么现在都不用了

13:42.460 --> 13:43.700
现在我们怎么做呢

13:43.700 --> 13:45.580
现在我们可以用这种方式来做

13:45.580 --> 13:46.940
我们之前不是学过吗

13:46.940 --> 13:49.500
Objects里边也不是一个Set Prototype

13:49.500 --> 13:50.020
对吧

13:50.020 --> 13:52.060
所以学过这么个东西

13:52.060 --> 13:54.940
它就是来专门来设置影视圆形的

13:54.940 --> 13:56.580
它可以把第一个参数

13:56.580 --> 13:57.900
对象的影视圆形

13:57.900 --> 13:59.340
设置为第二个参数

13:59.340 --> 14:01.180
所以这个东西怎么写

14:01.180 --> 14:03.500
我要把它的影视圆形拿来设置

14:03.500 --> 14:06.580
是不是这里写Dog的Prototype

14:06.580 --> 14:07.940
然后第二个参数写啥

14:07.940 --> 14:08.740
把它设置为什么

14:08.780 --> 14:11.300
把它的影视圆形

14:11.300 --> 14:13.740
把它的影视圆形设置为它的圆形

14:13.740 --> 14:13.940
对吧

14:13.940 --> 14:15.740
就是Animal

14:15.740 --> 14:18.580
Animal.Prototype

14:18.580 --> 14:19.380
就完了

14:19.380 --> 14:21.700
这样子就形成继承关系了

14:21.700 --> 14:22.940
保存

14:22.940 --> 14:24.100
那么现在再看一下

14:24.100 --> 14:26.380
狗你看这四个属性这个没问题

14:26.380 --> 14:28.620
然后你看它的Prototype是不是Animal

14:28.620 --> 14:29.580
对吧

14:29.580 --> 14:32.140
你看一下

14:32.140 --> 14:33.300
你看一下

14:33.300 --> 14:36.020
在它的圆形上面不是一个Print方法吗

14:36.020 --> 14:36.860
你看

14:36.860 --> 14:37.780
你看

14:37.820 --> 14:39.060
这个地方的圆形

14:39.060 --> 14:40.500
这个地方的圆形

14:40.500 --> 14:42.540
这个地方的圆形是哪个

14:42.540 --> 14:43.500
是不是这个玩意儿

14:43.500 --> 14:43.980
对吧

14:43.980 --> 14:46.260
然后这个玩意儿的影视圆形

14:46.260 --> 14:46.900
是不是它

14:46.900 --> 14:48.220
它里面不是个Print

14:48.220 --> 14:48.980
对不对

14:48.980 --> 14:50.340
它里面就个Print

14:50.340 --> 14:52.460
所以现在我们就可以雕用这个

14:52.460 --> 14:53.580
地点Print

14:53.580 --> 14:54.580
就没问题了

14:54.580 --> 14:56.260
保存

14:56.260 --> 14:56.420
好

14:56.420 --> 14:57.620
这是我们说了半天

14:57.620 --> 14:59.420
就讲的是过去的做法

14:59.420 --> 15:00.580
过去的做法

15:00.580 --> 15:02.540
当然就这个函数是新函数

15:03.740 --> 15:04.940
没问题吧

15:04.940 --> 15:05.140
好

15:05.140 --> 15:08.580
那么现在我们有了ES6之后

15:08.580 --> 15:11.620
它提供了内的语法格式

15:11.620 --> 15:13.700
它可以高度聚合某一个内

15:13.700 --> 15:15.740
把内的代码组织到一起

15:15.740 --> 15:16.740
那么同样的

15:16.740 --> 15:18.460
它也考虑到了继承

15:18.460 --> 15:20.500
你在使用继承的时候

15:20.500 --> 15:23.300
你会发现ES6特别方便

15:23.300 --> 15:25.300
我们这里复制一下

15:25.300 --> 15:28.260
我们把它改写成ES6的写法

15:28.260 --> 15:30.740
我们这里把这个放过来

15:32.220 --> 15:32.460
好

15:32.500 --> 15:33.300
这边放过来

15:35.300 --> 15:37.460
那么这是我们以前ES6的animal

15:37.460 --> 15:37.940
对吧

15:37.940 --> 15:40.220
那么现在我们要写它一个纸内

15:40.220 --> 15:41.540
要写一个纸内出来

15:41.540 --> 15:42.740
一看着我们这样子写

15:44.540 --> 15:45.540
这是一个内

15:45.540 --> 15:46.740
那么现在我们又要写个内

15:46.740 --> 15:47.820
是不是还是写class

15:47.820 --> 15:48.260
对吧

15:48.260 --> 15:49.820
dog

15:49.820 --> 15:50.900
class

15:50.900 --> 15:53.820
那么怎么来表达出这个类似这个类的

15:53.820 --> 15:54.500
纸内呢

15:54.500 --> 15:55.940
以前的表达方式

15:55.940 --> 15:58.380
是我们要去用什么原型链的东西来模拟

15:58.380 --> 15:58.980
对不对

15:58.980 --> 16:01.460
但是它没有办法从语法上

16:01.500 --> 16:04.340
以前它没办法从语法上一眼就看出

16:04.340 --> 16:05.740
它是它的纸内

16:05.740 --> 16:07.940
没办法从语法上就看出来

16:07.940 --> 16:08.540
那么现在呢

16:08.540 --> 16:09.660
有了那种语法过后

16:09.660 --> 16:10.580
你看我们这样子写

16:12.620 --> 16:13.460
dog

16:13.460 --> 16:14.300
extend

16:14.300 --> 16:15.540
关键字extend

16:15.540 --> 16:16.540
比较extend什么意思

16:16.540 --> 16:17.980
就是继承的意思

16:17.980 --> 16:20.060
狗继承制哪呢

16:20.060 --> 16:21.900
继承制animal

16:21.900 --> 16:23.140
就这么简单

16:23.140 --> 16:25.020
狗继承制animal

16:25.020 --> 16:25.180
好

16:25.180 --> 16:27.220
那么现在我们就写狗的

16:27.220 --> 16:27.940
constructor

16:27.940 --> 16:28.940
狗的寒树

16:28.940 --> 16:29.980
狗的构造寒树

16:29.980 --> 16:30.420
构造寒树

16:30.420 --> 16:31.820
我们刚才对比了那边写吧

16:31.820 --> 16:32.660
我们对比起来写

16:37.230 --> 16:39.750
你看现在的语法是变得非常简洁了

16:39.750 --> 16:41.510
我们就不需要用这种

16:41.510 --> 16:43.870
很模糊的语句来表达继承关系了

16:43.870 --> 16:46.550
我们直接语法上就可以表达继承关系

16:46.550 --> 16:48.710
狗继承制animal

16:48.710 --> 16:48.950
好

16:48.950 --> 16:49.630
那么这里呢

16:49.630 --> 16:50.590
构造寒树这里

16:50.590 --> 16:51.750
你看跟狗一样呗

16:51.750 --> 16:53.510
狗的构造寒树不就有三个参数吗

16:53.510 --> 16:54.310
name

16:54.310 --> 16:54.910
Age

16:54.910 --> 16:55.710
6

16:55.710 --> 16:56.750
对吧

16:56.750 --> 16:57.870
好

16:57.870 --> 16:59.070
那么这三个参数呢

16:59.070 --> 17:00.550
我们在构造寒树里边

17:00.590 --> 17:02.350
是不是要调用副类的构造寒树

17:02.350 --> 17:02.830
对吧

17:02.830 --> 17:04.030
要调用副类的构造寒树

17:04.030 --> 17:05.070
那我们怎么调用呢

17:05.070 --> 17:07.110
以前我们是不是得这样调用animal core

17:07.110 --> 17:07.870
对吧

17:07.870 --> 17:09.270
现在仍然可以这样调用

17:09.270 --> 17:10.190
吃不过

17:10.190 --> 17:11.590
噁心

17:11.590 --> 17:12.790
不好

17:12.790 --> 17:13.710
我们现在呢

17:13.710 --> 17:14.590
它规定了

17:14.590 --> 17:17.310
如果你使用class这种类的语法的话

17:17.310 --> 17:18.710
你可以使用这种方式

17:18.710 --> 17:20.230
有个关键字叫做super

17:20.230 --> 17:21.630
你看出了两个关键字

17:21.630 --> 17:23.430
ext

17:23.430 --> 17:25.430
表示的是

17:25.430 --> 17:26.550
表示的是那个

17:28.670 --> 17:30.030
继承

17:30.070 --> 17:31.430
super

17:31.430 --> 17:32.510
这个关键字什么意思呢

17:32.510 --> 17:33.710
我们这里记一笔

17:34.870 --> 17:35.870
新的关键字

17:37.350 --> 17:39.110
新的关键字

17:39.110 --> 17:43.590
第一个是ext

17:43.590 --> 17:45.750
它表示继承

17:45.750 --> 17:47.670
用于类的定义

17:47.670 --> 17:48.910
你定义一个类的时候

17:48.910 --> 17:49.990
可以用ext

17:49.990 --> 17:51.470
表示它的副类是谁

17:51.470 --> 17:51.670
好

17:51.670 --> 17:53.710
那么super

17:53.710 --> 17:55.230
super这个关键字呢

17:55.230 --> 17:56.230
它有两种用法

17:56.230 --> 17:57.990
首先我们说它第一种用法

17:57.990 --> 17:59.310
第一种用法就是

17:59.310 --> 18:01.470
直接调用

18:01.470 --> 18:03.150
直接当作函数调用

18:04.310 --> 18:07.830
当作函数调用

18:09.190 --> 18:12.670
表示副类构造函数

18:12.670 --> 18:13.990
表示副类构造函数

18:13.990 --> 18:14.430
所以说呢

18:14.430 --> 18:15.910
我们这个直接把它当作函数调用

18:15.910 --> 18:17.070
它就是副类构造函数

18:17.070 --> 18:17.710
它是什么

18:17.710 --> 18:18.670
它就是animal

18:18.670 --> 18:19.870
你看它继承它

18:19.870 --> 18:21.070
那么在多个里面的super

18:21.070 --> 18:23.470
就指的是animal的构造函数

18:23.470 --> 18:25.110
所以说这里直接调用就完事了

18:25.110 --> 18:25.750
来吧

18:25.750 --> 18:27.550
你看这里怎么也不用去绑定类似的

18:28.710 --> 18:30.270
把这个复制过来

18:30.270 --> 18:31.230
不就完了吗

18:31.230 --> 18:32.870
对不对

18:32.870 --> 18:34.030
就完了

18:34.030 --> 18:35.950
你看是不是非常简单

18:35.950 --> 18:37.070
非常简单吧

18:37.070 --> 18:37.470
对不对

18:39.310 --> 18:40.030
那么现在呢

18:40.030 --> 18:43.830
我们就写出了两个类animal和多个

18:43.830 --> 18:44.470
对不对

18:44.470 --> 18:45.390
就写出了这么两个类

18:46.590 --> 18:47.350
那么super

18:47.350 --> 18:48.750
我们这里还有一个细节要注意

18:48.750 --> 18:49.790
注意

18:52.030 --> 18:53.350
es6要求

18:55.390 --> 18:58.110
如果定义了constructor

18:58.590 --> 19:03.430
并且该内是指内

19:03.430 --> 19:09.550
则必须在constructor的第一行

19:10.870 --> 19:14.350
手动调用副类的构造函数

19:15.430 --> 19:16.470
必须要调用一次

19:16.470 --> 19:18.430
因为这张纸才会形成继承关系

19:18.430 --> 19:19.230
不然的话

19:19.230 --> 19:19.990
副类里边的

19:19.990 --> 19:21.350
你不调用副类的构造函数的话

19:21.350 --> 19:22.870
那么这些成员是不是加不进去

19:22.870 --> 19:24.190
加不到指类里边来

19:24.190 --> 19:26.590
你没有去运行一下这句话的话

19:26.590 --> 19:27.430
这些代码的话

19:27.510 --> 19:29.910
那么指内里边是不是不具有这些成员

19:29.910 --> 19:31.110
所以说他要求你

19:31.110 --> 19:33.710
如果说你自己手动写了constructor

19:33.710 --> 19:35.830
那么你就必须要手动调

19:35.830 --> 19:38.510
在第一行必须要先去调用一次

19:38.510 --> 19:39.790
super

19:39.790 --> 19:41.550
如果说你不调用

19:41.550 --> 19:42.830
如果说你不调用会怎么样呢

19:44.750 --> 19:45.070
放心

19:47.590 --> 19:48.950
我们这里没有创建多个

19:48.950 --> 19:50.230
我们创建一个吧

19:50.230 --> 19:51.950
第6一个道

19:51.950 --> 19:55.270
我们这里把副字过来

19:55.270 --> 19:55.630
好

19:55.630 --> 19:56.190
保存

19:56.190 --> 19:57.430
你看是爆错了

19:57.430 --> 19:57.670
对吧

19:57.670 --> 19:58.670
他说

19:58.670 --> 20:01.710
must call super constructor

20:01.710 --> 20:04.470
他必须要调用super

20:04.470 --> 20:06.870
就是副类的构造函数

20:06.870 --> 20:07.710
这什么呢

20:07.710 --> 20:09.830
在这个

20:09.830 --> 20:11.710
他这后面这一句话的意思就是

20:11.710 --> 20:14.230
在这个构造函数的最开始的位置

20:14.230 --> 20:14.990
调用super

20:14.990 --> 20:16.070
用super去调用

20:16.070 --> 20:17.990
这个就是副类的构造函数

20:17.990 --> 20:19.510
所以说你必须要调用

20:19.510 --> 20:21.390
这是跑不了的

20:21.390 --> 20:22.350
再写一次

20:22.350 --> 20:23.430
super

20:23.430 --> 20:24.190
还有四个参数

20:24.190 --> 20:25.270
你看它在提示里的

20:25.270 --> 20:26.150
副类有四个参数

20:26.150 --> 20:27.150
第一个参数type

20:27.150 --> 20:28.430
type我竟然是狗

20:28.430 --> 20:29.430
那么我的类型

20:29.430 --> 20:31.630
种类是固定的权类

20:31.630 --> 20:33.270
然后其他的参数

20:33.270 --> 20:34.310
我们来自于我的参数

20:34.310 --> 20:35.310
我也不知道是啥

20:35.310 --> 20:36.830
别人传给我

20:36.830 --> 20:37.310
你看

20:37.310 --> 20:38.830
是不是对手中将有意思

20:38.830 --> 20:39.830
对不对

20:39.830 --> 20:42.510
那么如果说你不写构造函数的话

20:42.510 --> 20:43.230
可不可以呢

20:43.230 --> 20:45.270
不写构造函数就可以

20:45.270 --> 20:47.430
它就不会爆错

20:47.430 --> 20:48.430
不写构造函数

20:48.430 --> 20:49.470
它就不会爆错

20:49.470 --> 20:53.790
它就没有什么问题

20:53.790 --> 20:55.070
那么不写构造函数

20:55.070 --> 20:56.750
它为什么没有什么问题呢

20:56.750 --> 20:58.110
它是这样子的

20:58.110 --> 21:00.670
如果说你不写构造函数的话

21:00.670 --> 21:02.870
那么它就相当于是给你写了

21:02.870 --> 21:04.150
一个一模一样的

21:04.150 --> 21:07.310
它会自动完成

21:07.310 --> 21:10.390
如果不写

21:10.390 --> 21:16.670
如果指内不写constructor

21:16.670 --> 21:23.270
则会有默认的构造器

21:23.310 --> 21:30.950
该构造器的需要的参数和负类一致

21:30.950 --> 21:35.110
并且自动调用负类构造器

21:35.110 --> 21:36.110
那么它怎么回事呢

21:36.110 --> 21:37.270
就是说如果你不写的话

21:37.270 --> 21:38.670
它就相当于写了一个

21:38.670 --> 21:41.110
跟负类一模一样的构造器

21:41.110 --> 21:43.190
然后在构造器里面只做了一件事

21:43.190 --> 21:44.070
就是调用修盘

21:44.070 --> 21:46.830
把这参数传进去

21:46.830 --> 21:47.990
相当于是做了这么一件事

21:47.990 --> 21:49.910
所以说现在看到的有点不对

21:49.910 --> 21:50.110
对吧

21:50.110 --> 21:50.950
数据有点不对

21:50.950 --> 21:52.750
你把忘彩传给了Type

21:52.750 --> 21:54.070
把3传给了Nate

21:54.070 --> 21:55.990
把这个功传给了A级

21:55.990 --> 21:57.550
six为undefend

21:57.550 --> 21:57.750
对吧

21:57.750 --> 21:58.670
里面传递

21:58.670 --> 22:00.230
它变成这个样子了

22:00.230 --> 22:01.310
所以说你可以不写

22:01.310 --> 22:02.190
但是你知道不写

22:02.190 --> 22:05.510
它的默认情况是什么情况就行了

22:05.510 --> 22:07.270
这是关于这一块

22:07.270 --> 22:08.670
那么这一块是不是搞定了

22:08.670 --> 22:10.750
那么圆形有没有搞定了

22:10.750 --> 22:12.030
我们来看一下圆形

22:12.030 --> 22:13.470
你看我们这里printer打印出来

22:13.470 --> 22:14.110
肯定没问题

22:14.110 --> 22:14.590
对不对

22:14.590 --> 22:15.790
我们再输出一下

22:15.790 --> 22:17.710
它会自动帮你搞定这个圆形�

22:17.710 --> 22:19.550
最终会形成这样的格式

22:19.550 --> 22:20.910
最终还是这样的格式

22:20.910 --> 22:22.030
没有什么区别

22:22.070 --> 22:24.150
你看多个圆形

22:24.150 --> 22:25.030
你看是不是一样的

22:25.030 --> 22:25.550
print

22:25.550 --> 22:25.830
对吧

22:25.830 --> 22:26.630
是一样的

22:26.630 --> 22:28.910
它最终会帮你形成这个圆形链

22:28.910 --> 22:30.710
所以说现在我们要表达

22:30.710 --> 22:33.150
在代码里面表达一个继承关系

22:33.150 --> 22:35.510
从语言的角度来说

22:35.510 --> 22:36.910
就非常舒服了

22:36.910 --> 22:37.790
你看

22:37.790 --> 22:40.070
我们通过extend关键字

22:40.070 --> 22:41.390
一看这个关键字就知道了

22:41.390 --> 22:42.310
它继承它

22:42.310 --> 22:43.030
对吧

22:43.030 --> 22:44.270
有些人来说

22:44.270 --> 22:45.790
那我要继承多个负累了

22:45.790 --> 22:46.670
不可能的

22:46.670 --> 22:48.030
在面向对向的世界里边

22:48.030 --> 22:49.550
继承一定是单根的

22:49.550 --> 22:51.310
就是一定只有一个负累

22:51.390 --> 22:52.910
尤其只有一个负累

22:52.910 --> 22:54.670
那么它能不能再有负累了

22:54.670 --> 22:55.230
可以

22:55.230 --> 22:56.630
它可以形成一条链

22:56.630 --> 22:58.510
但是你一个类不能继承多个

23:00.270 --> 23:01.230
那么这里

23:01.230 --> 23:03.110
在勾招器里面

23:03.110 --> 23:04.470
我们手动调整一次

23:04.470 --> 23:06.830
其实这个东西跟加码代码就差不多了

23:06.830 --> 23:08.670
那你说如果说我在狗里边

23:08.670 --> 23:11.550
还要增加一些自己的属性怎么办

23:11.550 --> 23:12.830
那就是记得写呗

23:12.830 --> 23:14.790
你记得写不完了吗

23:14.790 --> 23:16.790
你要加些自己的属性随便写吧

23:18.790 --> 23:20.070
你看呀

23:20.270 --> 23:21.550
当然Print还说的

23:21.550 --> 23:22.950
还没有打印这个属性

23:22.950 --> 23:23.710
没有打印那个属性

23:23.710 --> 23:24.670
我们打印一下地

23:25.550 --> 23:26.270
打印一下地

23:27.070 --> 23:27.670
你看

23:28.150 --> 23:30.670
是不是可以得到这个abc了

23:30.670 --> 23:31.230
对吧

23:31.230 --> 23:32.630
你可以要写什么属性

23:32.630 --> 23:33.710
你自己写

23:33.710 --> 23:35.190
就是纸类特有的属性

23:35.190 --> 23:37.670
纸类特有的属性

23:37.670 --> 23:38.710
我们随便写了一个

23:38.710 --> 23:39.430
对吧

23:39.430 --> 23:41.590
那如果说你要写一些纸类特有的方法

23:41.590 --> 23:42.350
也没问题

23:42.350 --> 23:43.430
你随便写呗

23:43.430 --> 23:44.350
比方说

23:46.150 --> 23:47.350
狗里边有一个方法

23:47.350 --> 23:48.670
一个原先上一个方法

23:48.670 --> 23:49.390
那么有什么方法

23:49.430 --> 23:50.590
比方说一个叫做

23:51.150 --> 23:51.950
shout

23:52.670 --> 23:53.550
叫吗

23:53.550 --> 23:53.910
叫

23:53.910 --> 23:54.590
我们就叫

23:57.900 --> 23:59.580
输出一下

24:00.540 --> 24:02.100
旺旺

24:03.740 --> 24:05.380
输出一下这么一个方法

24:05.380 --> 24:05.860
好

24:05.860 --> 24:07.060
那么我们来看一下

24:07.060 --> 24:09.820
狗里边有没有这个旺旺的方法

24:10.340 --> 24:10.900
叫

24:12.020 --> 24:12.700
看一下

24:12.700 --> 24:13.460
有没有这个方法

24:13.460 --> 24:14.340
是不是有这个方法

24:14.340 --> 24:14.780
对吧

24:14.780 --> 24:15.740
没问题的

24:15.740 --> 24:16.980
那么现在的继承关系

24:16.980 --> 24:18.220
你看原型链上

24:18.220 --> 24:19.220
它就相当于这个了

24:19.220 --> 24:20.260
狗的原型上面

24:20.260 --> 24:21.660
有一个这么叫

24:23.260 --> 24:24.020
那么

24:24.020 --> 24:25.260
当我们去调用这个方法的时候

24:25.260 --> 24:26.140
是不是找到这个方法了

24:26.140 --> 24:26.940
就调用这里

24:27.460 --> 24:28.580
那么现在还有一个问题

24:28.580 --> 24:29.060
就是说

24:29.060 --> 24:30.420
如果说

24:30.420 --> 24:32.740
在负类里边有一个同名方法

24:32.740 --> 24:34.620
比方说也有一个方法要叫

24:34.620 --> 24:36.620
到时候我们调用狗的叫做方法

24:36.620 --> 24:37.380
调用的是哪一个

24:38.860 --> 24:39.780
你看原型链

24:39.780 --> 24:40.180
呗

24:40.180 --> 24:41.260
一次往上找

24:41.260 --> 24:42.340
找到了就行

24:42.340 --> 24:43.740
那么是不是找先找到这个

24:43.740 --> 24:44.020
对吧

24:44.020 --> 24:45.420
那肯定是调用狗的

24:45.420 --> 24:46.060
那么这个东西

24:46.060 --> 24:47.780
其实就叫做方法覆盖

24:47.780 --> 24:49.220
也说我们在负类里边

24:49.540 --> 24:51.460
如果说的有同样一个叫的方法

24:52.220 --> 24:52.660
叫的方法

24:52.660 --> 24:53.700
我写什么了

24:53.700 --> 24:54.500
我是一个动物

24:54.500 --> 24:56.260
我也不知道动物是怎么叫的

24:56.260 --> 24:56.780
我也不知道

24:56.780 --> 24:58.100
那我就抛出错误

24:58.100 --> 24:59.820
抛出的错误

24:59.820 --> 25:01.900
我不知道动物怎么叫的

25:01.900 --> 25:03.900
动物怎么叫的

25:04.900 --> 25:06.340
你告诉我动物是怎么叫的

25:06.340 --> 25:06.940
我也不知道

25:06.940 --> 25:07.980
我知道狗是怎么叫的

25:07.980 --> 25:09.340
但是我不知道动物是怎么叫的

25:09.340 --> 25:12.020
因为它是个高度抽象的一个负类

25:12.020 --> 25:13.740
所以说我不知道动物怎么叫的

25:13.740 --> 25:16.140
因此我们在这里就抛出一个错误

25:16.740 --> 25:18.540
那么指内也有一个叫方法

25:18.580 --> 25:20.660
但是我们由于圆形链的存在

25:20.660 --> 25:21.780
我们现在调用的是谁

25:21.780 --> 25:23.140
调用的是狗的叫

25:23.140 --> 25:23.540
对吧

25:23.540 --> 25:24.340
狗的叫

25:24.340 --> 25:26.340
那么现在是不是调用了这个叫方法

25:26.340 --> 25:26.700
对吧

25:26.700 --> 25:28.140
因此它能正常输出

25:28.140 --> 25:28.940
看没有

25:28.940 --> 25:30.100
这叫覆盖

25:30.100 --> 25:31.500
覆盖了负类的方法

25:32.380 --> 25:33.660
同名方法

25:34.260 --> 25:35.420
同名方法

25:35.420 --> 25:36.700
会覆盖负类

25:36.700 --> 25:37.420
但是你要注意

25:37.420 --> 25:38.540
这个覆盖是什么意思

25:39.460 --> 25:41.100
不是说我写了这个指内

25:41.100 --> 25:42.260
负类的就不存在了

25:42.260 --> 25:44.060
是我要通过一只狗

25:44.060 --> 25:45.300
去调用这个方法的时候

25:45.300 --> 25:46.500
才会达到负类的效果

25:46.500 --> 25:47.660
覆盖负类的效果

25:48.620 --> 25:50.140
你要搞清楚这么一个原因

25:50.140 --> 25:52.220
如果说我们把这个图简化一下

25:52.220 --> 25:53.340
简化一下这个图

25:53.340 --> 25:55.580
就是我们在面向对向的画法里面

25:55.580 --> 25:56.740
我们可能会这样子画

25:57.740 --> 25:59.420
就不用画什么圆形链了

25:59.420 --> 26:01.540
但知道这么一个意思就行了

26:01.540 --> 26:02.540
这是动物

26:02.540 --> 26:03.540
动物

26:05.540 --> 26:06.540
这是animal

26:06.540 --> 26:07.540
动物

26:07.540 --> 26:08.540
动物里边有两个方法

26:08.540 --> 26:09.540
Print叫

26:09.540 --> 26:10.540
然后了指内

26:11.540 --> 26:13.540
它有一个方法叫

26:13.540 --> 26:14.540
那么

26:14.540 --> 26:16.540
我们把这个圆形链

26:16.540 --> 26:17.540
一个方法叫

26:17.540 --> 26:18.540
那么

26:18.540 --> 26:20.540
我们一个动物的对象

26:20.540 --> 26:21.540
它是不是有三个方法

26:21.540 --> 26:23.540
一个是自己的叫方法

26:23.540 --> 26:26.540
另外一个是自己的叫方法

26:26.540 --> 26:27.540
有两个方法

26:27.540 --> 26:28.540
一个是负类的Print方法

26:28.540 --> 26:30.540
负类的叫方法

26:30.540 --> 26:31.540
外面能访问到吗

26:31.540 --> 26:32.540
访问不到

26:32.540 --> 26:34.540
因为我们狗的对象

26:34.540 --> 26:37.540
它继承了负类

26:37.540 --> 26:38.540
继承的话

26:38.540 --> 26:40.540
一般会用这么一个箭头

26:40.540 --> 26:42.540
一般都是用空心箭头

26:42.540 --> 26:44.540
我这里难得去找了

26:44.540 --> 26:46.540
它继承自负类animal

26:46.540 --> 26:47.540
那么到时候

26:47.540 --> 26:49.540
我用狗去调用叫的时候

26:49.540 --> 26:51.540
调用的是狗的叫的方法

26:51.540 --> 26:52.540
就这么个意思

26:52.540 --> 26:54.540
就特殊的覆盖普遍的

26:56.540 --> 26:57.540
那么接下来

26:57.540 --> 26:58.540
我们再看一个问题

26:58.540 --> 26:59.540
有的时候

26:59.540 --> 27:01.540
我们可能会遇到这样的问题

27:01.540 --> 27:03.540
看什么问题呢

27:03.540 --> 27:04.540
就说

27:05.540 --> 27:06.540
比方说

27:06.540 --> 27:07.540
Print

27:07.540 --> 27:09.540
Print是打印自己的信息

27:09.540 --> 27:10.540
打印自己的信息

27:10.540 --> 27:11.540
狗里边不是一个

27:11.540 --> 27:13.540
特别的信息吗

27:13.540 --> 27:14.540
狗里边是不是有个

27:14.540 --> 27:15.540
特别的信息

27:15.540 --> 27:16.540
狗里边有一个

27:16.540 --> 27:17.540
特别的信息

27:17.540 --> 27:18.540
但是我换一个

27:18.540 --> 27:19.540
有异议的名字吧

27:19.540 --> 27:20.540
狗里边跟动物

27:20.540 --> 27:22.540
有什么样的特点呢

27:24.540 --> 27:26.540
我们先加个Labs

27:26.540 --> 27:27.540
喜欢

27:27.540 --> 27:28.540
喜欢是什么

27:28.540 --> 27:30.540
吃骨头

27:32.540 --> 27:33.540
比方说

27:34.540 --> 27:37.540
狗现在都不吃骨头了

27:37.540 --> 27:38.540
比方说现在

27:38.540 --> 27:39.540
狗喜欢吃骨头

27:39.540 --> 27:41.540
多了这么一个鼠箱了

27:41.540 --> 27:42.540
但是那我们先

27:42.540 --> 27:43.540
调用Print方法的时候

27:43.540 --> 27:44.540
你会看到

27:44.540 --> 27:45.540
是没有这个东西

27:45.540 --> 27:46.540
因为负类

27:46.540 --> 27:47.540
它不知道自己的

27:47.540 --> 27:48.540
有哪些籽类

27:48.540 --> 27:49.540
你写负类的时候

27:49.540 --> 27:51.540
是不知道有哪些籽类的

27:51.540 --> 27:52.540
我这么知道

27:52.540 --> 27:54.540
动物里边有哪些

27:54.540 --> 27:55.540
我的籽类有哪些

27:55.540 --> 27:56.540
每个籽类里边

27:56.540 --> 27:57.540
哪些特有属性的

27:57.540 --> 27:58.540
我不知道

27:58.540 --> 27:59.540
我只能管我公共的属性

27:59.540 --> 28:00.540
就是

28:00.540 --> 28:02.540
所有动物都有的东西

28:02.540 --> 28:03.540
我只能管这些东西

28:03.540 --> 28:04.540
他不知道

28:04.540 --> 28:06.540
不知道有这么一个属性

28:06.540 --> 28:07.540
因此

28:07.540 --> 28:08.540
我们在动物这里

28:08.540 --> 28:09.540
肯定是解决不了了

28:09.540 --> 28:10.540
那怎么办

28:10.540 --> 28:11.540
用刚才所说的

28:11.540 --> 28:13.540
是不是覆盖覆类的方法

28:13.540 --> 28:14.540
Print

28:14.540 --> 28:15.540
我们把覆类的方法

28:15.540 --> 28:16.540
里边的东西

28:16.540 --> 28:17.540
给它复制过来

28:17.540 --> 28:18.540
你除了

28:18.540 --> 28:20.540
打印这些东西之外

28:20.540 --> 28:21.540
你再打印一个

28:21.540 --> 28:22.540
再打印一个

28:22.540 --> 28:24.540
就是

28:24.540 --> 28:26.540
爱好

28:26.540 --> 28:28.540
这个宠物的爱好

28:28.540 --> 28:29.540
是什么呢

28:29.540 --> 28:31.540
this loves

28:31.540 --> 28:33.540
我们打印一个特有属性

28:33.540 --> 28:34.540
这句话是

28:34.540 --> 28:35.540
打印

28:35.540 --> 28:36.540
自己的

28:36.540 --> 28:39.540
特有的东西

28:39.540 --> 28:43.110
自己特有的代码

28:43.110 --> 28:45.110
自己特有的代码

28:45.110 --> 28:46.110
那么现在形成的结构

28:46.110 --> 28:47.110
是什么呢

28:47.110 --> 28:48.110
就是狗里边有个叫

28:48.110 --> 28:49.110
狗里边

28:49.110 --> 28:50.110
还有一个什么呢

28:50.110 --> 28:51.110
Print

28:51.110 --> 28:52.110
还有一个Print

28:52.110 --> 28:53.110
那么到时候

28:53.110 --> 28:54.110
我们调用的时候

28:54.110 --> 28:55.110
是不是调用了狗的Print

28:55.110 --> 28:56.110
对不对

28:56.110 --> 28:57.110
那么这样子一看

28:57.110 --> 28:58.110
Print的时候

28:58.110 --> 28:59.110
是不是多了一个爱好

28:59.110 --> 29:00.110
但是

29:00.110 --> 29:01.110
这样的代码

29:01.110 --> 29:02.110
不是很好

29:02.110 --> 29:03.110
因为一看就知道了

29:03.110 --> 29:04.110
是不是有重复代码

29:04.110 --> 29:05.110
当然我这里

29:05.110 --> 29:06.110
只是一个输出语句

29:06.110 --> 29:07.110
你可以

29:07.110 --> 29:08.110
就是依持内推

29:08.110 --> 29:10.110
你要有这种内比的

29:10.110 --> 29:11.110
理解能力

29:11.110 --> 29:12.110
就是说

29:12.110 --> 29:13.110
以后我们如果说

29:13.110 --> 29:15.110
出现了这种继承关系

29:15.110 --> 29:16.110
这种继承结构

29:16.110 --> 29:17.110
那么负累里边

29:17.110 --> 29:18.110
可能代码很多很复杂

29:18.110 --> 29:20.110
我是不是又得把它写一次呢

29:20.110 --> 29:21.110
那到时候

29:21.110 --> 29:22.110
如果还有别的指导

29:22.110 --> 29:23.110
别的指导

29:23.110 --> 29:24.110
还又要做这种事情

29:24.110 --> 29:25.110
是不是又得写一次呢

29:25.110 --> 29:26.110
是不是很麻烦

29:26.110 --> 29:28.110
你看一下前面的这一段

29:28.110 --> 29:30.110
看一下前面的这一段

29:30.110 --> 29:31.110
这一段代码

29:31.110 --> 29:32.110
是不是就是

29:32.110 --> 29:34.110
调用负累的Print

29:34.110 --> 29:36.110
是不是调用负累的Print

29:36.110 --> 29:37.110
那么如果说

29:37.110 --> 29:38.110
我们在这里

29:38.110 --> 29:39.110
如果能够

29:39.110 --> 29:42.110
调用负累的Print

29:42.110 --> 29:44.110
是不是就很好了

29:44.110 --> 29:45.110
把负累的Print

29:45.110 --> 29:46.110
调用一遍

29:46.110 --> 29:47.110
然后再调用自己的Print

29:47.110 --> 29:49.110
自己的特有的代码

29:49.110 --> 29:50.110
但是我们现在

29:50.110 --> 29:51.110
怎么来调用呢

29:51.110 --> 29:53.110
你肯定不能用ZS

29:53.110 --> 29:54.110
因为ZS表示什么

29:54.110 --> 29:56.110
当前狗的对象

29:56.110 --> 29:57.110
它是在狗里边的

29:57.110 --> 29:58.110
在狗

29:58.110 --> 29:59.110
当前狗的对象

29:59.110 --> 30:00.110
这个ZS

30:00.110 --> 30:01.110
调用Print

30:01.110 --> 30:02.110
是不是调用的是狗里边的Print

30:02.110 --> 30:03.110
就形成无限地规了

30:03.110 --> 30:05.110
你肯定不能在这里调用

30:05.110 --> 30:06.110
这样调用

30:06.110 --> 30:07.110
那怎么调用呢

30:07.110 --> 30:09.110
Super的第二个用处

30:09.110 --> 30:11.110
如果当作

30:11.110 --> 30:13.110
对象使用

30:13.110 --> 30:15.110
这表示

30:15.110 --> 30:19.110
负累的

30:19.110 --> 30:20.110
就是

30:20.110 --> 30:22.110
原型

30:22.110 --> 30:24.110
表示负累的原型

30:24.110 --> 30:25.110
也就是说

30:25.110 --> 30:26.110
我们这里调用Print的话

30:26.110 --> 30:27.110
怎么调用呢

30:27.110 --> 30:29.110
用Super的调用

30:29.110 --> 30:30.110
Super的调用

30:30.110 --> 30:31.110
Super表示什么

30:31.110 --> 30:33.110
Super的表示的就是

30:33.110 --> 30:34.110
负累的原型

30:34.110 --> 30:35.110
就这张图

30:35.110 --> 30:36.110
负累的原型

30:36.110 --> 30:37.110
你可以这样理解

30:37.110 --> 30:39.110
你把当前对象使用的话

30:39.110 --> 30:40.110
它表示的是

30:40.110 --> 30:41.110
调用负累的原型方法

30:41.110 --> 30:42.110
那么是不是可以调用

30:42.110 --> 30:43.110
Super的Print

30:43.110 --> 30:44.110
那么这样子

30:44.110 --> 30:45.110
既没有重复代码

30:45.110 --> 30:47.110
又可以解决这样的问题

30:47.110 --> 30:49.110
原来的意思吗

30:49.110 --> 30:51.110
这是关于

30:51.110 --> 30:52.110
这个

30:52.110 --> 30:53.110
继承这一块

30:53.110 --> 30:54.110
这东西

30:54.110 --> 30:55.110
多不多呢

30:55.110 --> 30:56.110
也没有那么多

30:56.110 --> 30:57.110
如果说你学过加法的话

30:57.110 --> 30:58.110
那肯定很轻松的理解

30:58.110 --> 30:59.110
如果说你没有学过

30:59.110 --> 31:00.110
都没关系

31:00.110 --> 31:01.110
你看就只有两个观念词

31:01.110 --> 31:02.110
一个是添子

31:02.110 --> 31:03.110
来表示继承关系

31:03.110 --> 31:04.110
一个是Super

31:04.110 --> 31:05.110
注意在勾造函数里面

31:05.110 --> 31:06.110
第一行

31:06.110 --> 31:07.110
如果你写的勾造函数

31:07.110 --> 31:08.110
一定要写上Super

31:08.110 --> 31:09.110
如果是你是指的

31:09.110 --> 31:10.110
当然你没有继承关系的

31:10.110 --> 31:11.110
就无所谓的

31:11.110 --> 31:13.110
如果说你在其他方法里边

31:13.110 --> 31:14.110
想调用负累的方法

31:14.110 --> 31:15.110
OK

31:15.110 --> 31:16.110
有Super

31:16.110 --> 31:17.110
有Super

31:17.110 --> 31:18.110
D2

31:18.110 --> 31:19.110
什么什么

31:19.110 --> 31:20.110
来调用负累的方法

31:20.110 --> 31:21.110
这样的意思吗

31:21.110 --> 31:22.110
当然

31:22.110 --> 31:24.110
我们有了这种继承

31:24.110 --> 31:26.110
有了这种内

31:26.110 --> 31:27.110
之后

31:27.110 --> 31:29.110
可以玩出各种各样的花样

31:29.110 --> 31:30.110
那么那一块东西

31:30.110 --> 31:32.110
涉及到设计模式了

31:32.110 --> 31:34.110
涉及到设计模式了

31:34.110 --> 31:35.110
这里就不展开说了

31:35.110 --> 31:37.110
那是单独的一门课程

31:37.110 --> 31:38.110
也单独的一门课程

31:38.110 --> 31:40.110
这就不展开说了

31:40.110 --> 31:42.110
最后我给大家

31:42.110 --> 31:44.110
说一些冷知识吧

31:44.110 --> 31:48.900
冷知识

31:50.900 --> 31:51.900
第一个冷知识

31:51.900 --> 31:52.900
这一块你爱听又听

31:52.900 --> 31:54.900
听一下对你没坏处

31:54.900 --> 31:55.900
不听的话

31:55.900 --> 31:57.900
对你没有多大影响

31:57.900 --> 31:58.900
听一下吧

31:58.900 --> 32:00.900
有兴趣的话就听一下

32:00.900 --> 32:02.900
第一个就是

32:02.900 --> 32:04.900
用戒也是

32:04.900 --> 32:06.900
做抽象内

32:06.900 --> 32:07.900
这个抽象内是

32:07.900 --> 32:09.900
铭行对象里面的概念

32:09.900 --> 32:11.900
什么叫抽象内呢

32:11.900 --> 32:12.900
什么叫抽象内呢

32:12.900 --> 32:14.900
就是

32:14.900 --> 32:17.900
一般是负累

32:17.900 --> 32:18.900
一般是负累

32:18.900 --> 32:19.900
如果说你

32:19.900 --> 32:21.900
这个内没有纸内

32:21.900 --> 32:22.900
没有纸内的内

32:22.900 --> 32:23.900
不是负累对吧

32:23.900 --> 32:24.900
它一定不是负累

32:24.900 --> 32:25.900
如果没有纸内的话

32:25.900 --> 32:26.900
一般不会是抽象内

32:26.900 --> 32:28.900
一般都是负累

32:28.900 --> 32:30.900
该内

32:30.900 --> 32:32.900
就是不可以

32:32.900 --> 32:34.900
不能

32:34.900 --> 32:36.900
通过该内

32:36.900 --> 32:38.900
创建对象

32:38.900 --> 32:39.900
这就是抽象内

32:39.900 --> 32:40.900
为什么

32:40.900 --> 32:41.900
不能创建对象

32:41.900 --> 32:42.900
那有什么意义呢

32:42.900 --> 32:43.900
你看着

32:43.900 --> 32:46.900
想一个道理

32:46.900 --> 32:47.900
我记得有一次

32:47.900 --> 32:48.900
我刷抖音的时候

32:48.900 --> 32:52.900
就刷了这么一段话

32:52.900 --> 32:53.900
就是说

32:53.900 --> 32:55.900
搞哲学的人

32:55.900 --> 32:56.900
他说

32:56.900 --> 32:58.900
有一段话是这么说的

32:58.900 --> 33:01.900
这个世界上没有人

33:01.900 --> 33:02.900
能理解吗

33:02.900 --> 33:04.900
这个世界上没有人

33:04.900 --> 33:05.900
有什么呢

33:05.900 --> 33:06.900
我不是什么

33:06.900 --> 33:07.900
你是人有你

33:07.900 --> 33:09.900
但是没有人

33:09.900 --> 33:10.900
这个东西

33:10.900 --> 33:11.900
你给我告诉我

33:11.900 --> 33:12.900
人是谁

33:12.900 --> 33:14.900
他是一个抽象的概念

33:14.900 --> 33:15.900
对吧

33:15.900 --> 33:17.900
他不是一个具体的东西

33:17.900 --> 33:19.900
这个世界上没有男人

33:19.900 --> 33:20.900
那你告诉我

33:20.900 --> 33:21.900
男人是谁

33:21.900 --> 33:22.900
你把男人给我拿出来看一下

33:22.900 --> 33:23.900
你给我拿出个男人出来

33:23.900 --> 33:24.900
那是一个具体的

33:24.900 --> 33:25.900
那是张三

33:25.900 --> 33:26.900
那是李氏

33:26.900 --> 33:27.900
那是王五

33:27.900 --> 33:29.900
他不是男人这个概念

33:30.900 --> 33:31.900
你看一下

33:31.900 --> 33:32.900
animal

33:32.900 --> 33:33.900
它只是一个动物

33:33.900 --> 33:35.900
是一个高度抽象的一个概念

33:35.900 --> 33:37.900
它是一个统称

33:37.900 --> 33:39.900
它具体存不存在动物呢

33:39.900 --> 33:40.900
它存在一只狗

33:40.900 --> 33:41.900
存在一只猫

33:41.900 --> 33:43.900
它不存在动物这个东西

33:43.900 --> 33:44.900
明白我的意思吗

33:44.900 --> 33:45.900
所以说你不应该去

33:45.900 --> 33:47.900
创建一个动物对象

33:47.900 --> 33:48.900
你要么创建一只狗

33:48.900 --> 33:49.900
要么创建一只猫

33:49.900 --> 33:51.900
要么创建一只老虎

33:51.900 --> 33:53.900
那么你不能创建一个

33:53.900 --> 33:54.900
动物的对象

33:54.900 --> 33:55.900
所以说呢

33:55.900 --> 33:57.900
我不希望你

33:58.900 --> 34:00.900
能够调用腐略狗招寒术

34:00.900 --> 34:02.900
你不应该去使用这样的代码

34:03.900 --> 34:04.900
说些冷知识

34:04.900 --> 34:08.210
听听就完了

34:08.210 --> 34:09.210
在很多语言里面

34:09.210 --> 34:11.210
它在语法上都支持这样子

34:11.210 --> 34:12.210
支持

34:12.210 --> 34:13.210
让一个内不能充电对象

34:13.210 --> 34:14.210
但是戒指目前

34:14.210 --> 34:15.210
还没有这样的语法

34:15.210 --> 34:17.210
我觉得将来可能会有

34:17.210 --> 34:18.210
将来可能会有

34:20.210 --> 34:21.210
我们不希望它创建animal

34:21.210 --> 34:22.210
也就是说

34:22.210 --> 34:23.210
下面的代码是

34:23.210 --> 34:24.210
我们觉得是

34:24.210 --> 34:26.210
逻辑是有问题的

34:26.210 --> 34:27.210
下面的代码

34:27.210 --> 34:28.210
逻辑有物

34:32.030 --> 34:33.030
什么呢

34:33.030 --> 34:34.030
就是说

34:34.030 --> 34:35.030
我们

34:35.030 --> 34:37.030
如果说去创建了一个animal

34:37.030 --> 34:39.030
创建了一个animal

34:39.030 --> 34:40.030
比方说拳类

34:40.030 --> 34:42.030
比方说

34:42.030 --> 34:44.030
Name

34:44.030 --> 34:45.030
Name

34:45.030 --> 34:46.030
汪柴

34:46.030 --> 34:48.030
AZ3

34:48.030 --> 34:49.030
工的

34:50.030 --> 34:51.030
比方说我们这里的

34:51.030 --> 34:52.030
创建了这么一个动物

34:54.030 --> 34:55.030
Age of Prints

34:55.030 --> 34:56.030
它是能够运行的对吧

34:56.030 --> 34:57.030
是不是能够运行的

34:57.030 --> 34:58.030
对不对

34:58.030 --> 35:00.030
那么这样子一来

35:00.030 --> 35:01.030
是不符合逻辑的

35:01.030 --> 35:03.030
逻辑是有问题的

35:03.030 --> 35:04.030
因为不存在动物

35:04.030 --> 35:05.030
你应该创建一只狗

35:05.030 --> 35:06.030
不应该创建一个animal

35:06.030 --> 35:07.030
没有意思吗

35:07.030 --> 35:09.030
animal它只是用来抽象

35:09.030 --> 35:11.030
公有的成员

35:11.030 --> 35:12.030
公有的代码的

35:12.030 --> 35:14.030
它只是用来做这么一个事的

35:14.030 --> 35:15.030
你不应该直接去使用它

35:15.030 --> 35:16.030
所以说

35:16.030 --> 35:18.030
我们要怎么来防止这一点呢

35:18.030 --> 35:19.030
你看现在肯定能直接使用

35:19.030 --> 35:21.030
如果为了避免

35:21.030 --> 35:22.030
错误的代码发生

35:22.030 --> 35:23.030
我们应该给它报一个错误

35:23.030 --> 35:24.030
因此我们可以在

35:24.030 --> 35:26.030
构造函数里边

35:26.030 --> 35:28.030
是抛出一个错误

35:28.030 --> 35:29.030
你不能给我

35:29.030 --> 35:34.030
不能创建这个动物

35:34.030 --> 35:39.030
你不能直接创建animal的对象

35:39.030 --> 35:41.030
你不能直接创建animal的对象

35:41.030 --> 35:44.030
应该通过纸类创建

35:44.030 --> 35:46.030
应该通过纸类创建

35:46.030 --> 35:47.030
但是这样子一来的话

35:47.030 --> 35:48.030
一个会出问题

35:48.030 --> 35:49.030
当你吊

35:49.030 --> 35:50.030
你看现在肯定是出问题的

35:50.030 --> 35:51.030
你不能创建animal的对象

35:51.030 --> 35:53.030
你去运行构造函数的时候

35:53.030 --> 35:54.030
它这句话爆错了

35:54.030 --> 35:55.030
但是如果说

35:55.030 --> 35:56.030
我们现在通过

35:56.030 --> 35:57.030
创建一只狗的话

35:57.030 --> 35:58.030
也出了问题

35:58.030 --> 35:59.030
你为什么呢

35:59.030 --> 36:00.030
因为狗里边是不是

36:00.030 --> 36:01.030
也在调用负累的构造函数

36:01.030 --> 36:02.030
狗里边说

36:02.030 --> 36:03.030
也在调用负累的构造函数

36:03.030 --> 36:04.030
是不是也出了问题

36:04.030 --> 36:05.030
对吧

36:05.030 --> 36:06.030
它也要爆错

36:06.030 --> 36:08.030
我得把这个东西解决

36:08.030 --> 36:09.030
你不能全部爆错

36:09.030 --> 36:10.030
你看下面的代码

36:10.030 --> 36:11.030
变成灰色了

36:11.030 --> 36:12.030
表示个代码永远不会执行

36:12.030 --> 36:13.030
所以说

36:13.030 --> 36:15.030
我们这里是不是判断

36:15.030 --> 36:16.030
判断什么

36:16.030 --> 36:22.030
创建的是哪个类的对象

36:22.030 --> 36:24.030
你溜的是哪一个类

36:24.030 --> 36:27.030
那这个东西怎么判断呢

36:27.030 --> 36:28.030
还记得吗

36:28.030 --> 36:30.030
是不是使用了

36:30.030 --> 36:33.030
new.target

36:33.030 --> 36:34.030
是不是使用这个

36:34.030 --> 36:35.030
这个就表示的是

36:35.030 --> 36:37.030
我代码运行到这的时候

36:37.030 --> 36:39.030
是基于什么运行的

36:39.030 --> 36:40.030
是不是基于一个

36:40.030 --> 36:41.030
new关键之运行的

36:41.030 --> 36:42.030
那么new的

36:42.030 --> 36:44.030
后边到底是啥

36:44.030 --> 36:45.030
到底是啥

36:45.030 --> 36:46.030
那么这个target

36:46.030 --> 36:48.030
指向的就是类的本身

36:48.030 --> 36:50.030
如果等于anymore的时候

36:50.030 --> 36:51.030
那么我才

36:51.030 --> 36:52.030
抛出这样的错误

36:52.030 --> 36:53.030
保存

36:53.030 --> 36:54.030
你看狗就是正常的

36:54.030 --> 36:55.030
你创建负累就是正常的

36:55.030 --> 36:57.030
如果说你创建一个负累

36:57.030 --> 36:58.030
anymore

36:58.030 --> 36:59.030
我懒得改参出了

36:59.030 --> 37:00.030
是不能创建的

37:00.030 --> 37:01.030
对吧

37:01.030 --> 37:02.030
这就是用js

37:02.030 --> 37:05.030
来模拟这么一个抽象类的概念

37:05.030 --> 37:07.030
模拟这么一个东西出来

37:07.030 --> 37:09.030
没有人认识吗

37:09.030 --> 37:11.030
这是关于这一点

37:11.030 --> 37:12.030
另外一个冷知识

37:12.030 --> 37:13.030
我告诉大家就是关于Z

37:13.030 --> 37:15.030
Z的指向

37:15.030 --> 37:18.030
Z的指向

37:18.030 --> 37:22.030
Z始终指向

37:22.030 --> 37:23.030
指向谁呢

37:23.030 --> 37:25.030
指向的是

37:25.030 --> 37:27.030
就正常情况下

37:27.030 --> 37:30.030
正常情况下

37:30.030 --> 37:33.030
Z始终指向具体

37:33.030 --> 37:36.030
就是具体的类的对象

37:36.030 --> 37:37.030
什么意思呢

37:37.030 --> 37:39.030
就是说你创建的是dog

37:39.030 --> 37:42.030
那么在整个运行代码的运行过程中

37:42.030 --> 37:44.030
你甭管你运行的是负累代码

37:44.030 --> 37:46.030
还是运行的是纸类代码

37:46.030 --> 37:48.030
Z一定指向新的

37:48.030 --> 37:50.030
就是个dog对象

37:50.030 --> 37:51.030
一定是指向那个dog对象

37:51.030 --> 37:53.030
比方说我们这里

37:53.030 --> 37:55.030
admprint

37:55.030 --> 37:57.030
那么admprint的时候

37:57.030 --> 37:59.030
你看这个print函数里边

37:59.030 --> 38:01.030
看一下多个函数里边

38:01.030 --> 38:02.030
是不是掉了负累的方法

38:02.030 --> 38:03.030
在执行负累代码

38:03.030 --> 38:05.030
但是依然Z是不会变的

38:05.030 --> 38:07.030
仍然是指向了这个

38:07.030 --> 38:09.030
因为它怎么变的

38:09.030 --> 38:10.030
它没法变

38:10.030 --> 38:12.030
它又不存在另外一个对象

38:12.030 --> 38:13.030
它只有一个对象

38:13.030 --> 38:14.030
只有这个多个对象

38:14.030 --> 38:15.030
它要注意点

38:15.030 --> 38:17.030
不是说你代码运行到负累代码过后

38:17.030 --> 38:19.030
Z就变了

38:19.030 --> 38:20.030
Z是指的运行时的状态

38:20.030 --> 38:21.030
运行时的状态

38:21.030 --> 38:25.030
一定是指向的是当前对象

38:25.030 --> 38:27.030
搞清楚这一点

38:28.030 --> 38:30.030
其他就没啥了

38:30.030 --> 38:33.030
这是关于内的继承

38:33.030 --> 38:35.030
那么对象这一张

38:35.030 --> 38:36.030
讲了这么一些知识过后

38:36.030 --> 38:38.030
我们下一节课

38:38.030 --> 38:39.030
来做这么一个练习

38:39.030 --> 38:40.030
把这些

38:40.030 --> 38:41.030
特别是关于面向对象的东西

38:41.030 --> 38:42.030
给大家串一下

38:42.030 --> 38:43.030
做这么一个练习

38:43.030 --> 38:44.030
大家体会一下

38:44.030 --> 38:46.030
面向对象开发的

38:46.030 --> 38:47.030
这种好处也好

38:47.030 --> 38:48.030
它的特点也好

38:48.030 --> 38:49.030
可以让大家体会一下

38:49.030 --> 38:50.030
好吧

