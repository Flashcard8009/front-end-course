WEBVTT

00:00.880 --> 00:03.680
好 本章的最后一个部分 知名符号

00:03.680 --> 00:05.680
符号其实这个当地都蛮简单的

00:05.680 --> 00:10.080
有些知识都属于扩展知识了

00:10.080 --> 00:11.080
像这一张解特

00:11.080 --> 00:13.880
如果说你要展开讲的话 知识还蛮多的

00:13.880 --> 00:15.680
知识真的没有什么用

00:15.680 --> 00:17.880
真的是没有什么用对我们

00:17.880 --> 00:20.280
所以说我们这一块了解一下

00:20.280 --> 00:21.680
了解一下知名符号

00:21.680 --> 00:24.080
但是知名符号的概念还是蛮有用的

00:24.080 --> 00:25.680
知名符号的概念是很重要的

00:25.680 --> 00:28.080
因为我们后面会学习一个非常非常重要的

00:28.080 --> 00:28.880
知名符号

00:28.880 --> 00:30.280
我们后面会学习

00:30.280 --> 00:31.280
只不过不在这个张解

00:31.280 --> 00:33.280
它要配合其他东西来用

00:33.280 --> 00:35.280
知名符号什么意思呢

00:35.280 --> 00:40.280
它指的是一些具有特殊含义的共享符号

00:40.280 --> 00:41.580
首先它是一个共享符号

00:41.580 --> 00:43.480
有一个符号是全局唯一的

00:43.480 --> 00:44.480
都可以用

00:44.480 --> 00:46.480
你可以用我也可以用

00:46.480 --> 00:47.880
你不用去重新创建

00:47.880 --> 00:50.680
它已经有了 天生就有这些符号

00:50.680 --> 00:51.480
那么这些符号

00:51.480 --> 00:53.080
它具备一些特殊含义

00:53.080 --> 00:54.480
不同的知名符号

00:54.480 --> 00:56.280
它的含义不一样

00:56.280 --> 00:58.080
那我们怎么来得到一个知名符号

00:58.080 --> 01:00.280
知名符号一定不是你创建的

01:00.280 --> 01:02.680
因为早就给你创建好了

01:02.680 --> 01:03.980
你啥都没做

01:03.980 --> 01:06.280
那么JS内部都要用这些知名符号

01:06.280 --> 01:10.080
只不过你要了解知名符号的作用

01:10.080 --> 01:11.880
我们怎么来得到这个知名符号呢

01:11.880 --> 01:12.780
通过symbol

01:12.780 --> 01:13.880
symbol是不是个含书

01:13.880 --> 01:14.480
对吧

01:14.480 --> 01:16.480
含书里边有一些静态属性

01:16.480 --> 01:18.080
就通过含书得到了属性

01:18.080 --> 01:19.680
你看下面这些知名符号

01:19.680 --> 01:22.480
就symbol 底耳啥 得到一个知名符号

01:22.480 --> 01:24.580
symbol 底耳啥 得到一个知名符号

01:24.580 --> 01:25.480
就这么个意思

01:25.480 --> 01:27.480
它通过它的静态属性得到

01:27.480 --> 01:28.780
当属性名不一样的话

01:28.780 --> 01:30.380
它的符号就不一样

01:30.380 --> 01:34.080
不同的符号也不同的含义

01:34.080 --> 01:36.880
它为什么要去包露一些知名符号呢

01:36.880 --> 01:38.380
这知名符号也叫做公共符号

01:38.380 --> 01:40.680
或者叫居民符号都是一个意思

01:40.680 --> 01:44.680
因为ES6里边它延续了ES5的思想

01:44.680 --> 01:49.780
就是尽量的为这个语言减少魔法

01:49.780 --> 01:50.580
什么叫魔法

01:50.580 --> 01:52.080
就得搞不清楚它是怎么回事

01:52.080 --> 01:53.080
它就实现了

01:53.080 --> 01:54.080
这就叫魔法

01:54.080 --> 01:55.480
以后我们可以看到

01:55.480 --> 01:57.180
我后边看的话可以看到

01:57.180 --> 01:58.180
其实我们不知不觉

01:58.180 --> 02:00.180
街市里面有很多很多的魔法

02:00.180 --> 02:03.480
其实一个语言魔法越多

02:03.480 --> 02:05.780
对这个语言本身并不是什么好事

02:05.780 --> 02:08.480
说明这个语言它越不规范

02:08.480 --> 02:11.380
它需要通过一些魔法来解决一些特殊问题

02:11.380 --> 02:12.880
还并不没有那么规范

02:12.880 --> 02:14.680
所以说减少魔法是一个语言

02:14.680 --> 02:16.580
发生到成熟的阶段的时候

02:16.580 --> 02:18.880
是必须要做点一件事情

02:18.880 --> 02:20.080
减少魔法过后

02:20.080 --> 02:23.080
它就把一些以前看起来莫名其妙的事情

02:23.080 --> 02:25.380
或者是我们不能插手的事情

02:25.380 --> 02:26.980
现在可以插手了

02:26.980 --> 02:28.980
它的内部实现我们可以参与了

02:28.980 --> 02:31.780
我们一会就可以具体看到东西了

02:31.780 --> 02:35.380
因此ES6它就是通过殖民符号

02:35.380 --> 02:39.680
能够暴露它里边语言内部的一些实现

02:39.680 --> 02:40.780
我们这里具体看吧

02:40.780 --> 02:42.980
不然说起来太抽象了

02:42.980 --> 02:47.980
第一个殖民符号叫做HasInstance

02:47.980 --> 02:48.680
这什么意思

02:48.680 --> 02:50.480
这个殖民符号用的干嘛呢

02:50.480 --> 02:52.980
这个殖民符号它会影响到

02:52.980 --> 02:55.180
Instance of the Pending

02:55.280 --> 02:58.280
因为我们之前都学过这个关键字

02:58.280 --> 02:59.680
我们也不知道关键字

02:59.680 --> 03:01.080
我们知道它是怎么工作的

03:01.080 --> 03:02.980
判断的是什么圆形链

03:02.980 --> 03:04.480
那我们能不能去改它呢

03:04.480 --> 03:05.180
你改不了

03:05.180 --> 03:06.780
它一定是判断的是圆形链

03:06.780 --> 03:09.180
你想去改一下别的判断行为

03:09.180 --> 03:09.780
你改不了

03:09.780 --> 03:11.680
你参与不了它的内部实现

03:11.680 --> 03:12.780
这就叫做魔法

03:14.480 --> 03:16.280
你们学习以后学习Viu

03:16.280 --> 03:17.280
学习Reacts

03:17.280 --> 03:18.580
他们最大的区别就在于

03:18.580 --> 03:20.480
Viu里边有很多的魔法

03:20.480 --> 03:22.280
看上去很神奇

03:22.280 --> 03:23.280
很简单就实现了

03:23.280 --> 03:25.880
但是你要想去参与它的改动

03:25.880 --> 03:27.880
那抱歉了很麻烦

03:27.880 --> 03:28.880
而Reacts呢

03:28.880 --> 03:30.980
它就是沿用了另外一套哲学思想

03:30.980 --> 03:32.180
我没有魔法

03:32.180 --> 03:33.680
我就是纯粹的GS

03:33.680 --> 03:36.480
我里边的实现你都可以实现

03:36.480 --> 03:37.580
说你可以参与它

03:37.580 --> 03:40.280
你就可以去改造它的里边一些东西

03:40.280 --> 03:42.480
那么GS现在在减少魔法

03:42.480 --> 03:45.180
那么其中有一个叫做HasInstance

03:45.180 --> 03:46.580
以前有这么一个关键字

03:46.580 --> 03:48.880
这个关键字它判断的一定是圆形链

03:48.880 --> 03:51.180
判断这个对象

03:51.180 --> 03:54.180
它的隐释圆形上有没有

03:54.180 --> 03:56.280
有没有一个圆形是属于A的

03:56.280 --> 03:58.980
就判断这个东西

03:58.980 --> 04:00.680
但是现在呢

04:00.680 --> 04:01.680
现在呢

04:01.680 --> 04:04.180
现在呢我们可以参与到它的判定了

04:04.180 --> 04:04.680
它不一定

04:04.680 --> 04:07.180
我说不一定要按这个圆形链来判定

04:07.180 --> 04:08.680
我可能用别的判定方式

04:08.680 --> 04:10.180
OK我们现在可以参与了

04:10.180 --> 04:10.780
怎么参与

04:10.780 --> 04:13.180
就通过一个知名符号参与

04:13.180 --> 04:16.180
也就这句话的意思就相当于是

04:16.180 --> 04:18.980
你看下面这句话的意思

04:18.980 --> 04:20.580
实际上就是一个函数的调用

04:21.080 --> 04:22.080
就是个函数的调用

04:22.080 --> 04:23.980
把ob就作为参数的进去

04:23.980 --> 04:25.080
调用这个函数

04:25.080 --> 04:26.580
就这么个意思

04:26.580 --> 04:28.780
那么这个函数是什么属性的调用呢

04:28.780 --> 04:31.380
通过这个函数的

04:31.380 --> 04:33.780
通过这个一定是个构造函数

04:33.780 --> 04:34.380
对吧

04:34.380 --> 04:35.280
这个一定毫无疑问

04:35.280 --> 04:36.380
它一定是个构造函数

04:36.380 --> 04:37.180
这是一个对象

04:37.180 --> 04:39.280
看这个对象的隐释圆形链上面

04:39.280 --> 04:42.380
有没有这个函数的圆形

04:42.380 --> 04:43.580
那么这里呢

04:43.580 --> 04:46.880
它其实通过这个函数的什么这个东西

04:46.880 --> 04:48.180
这个知名符号

04:48.180 --> 04:49.080
它是一个方法

04:49.180 --> 04:50.980
通过调用这个方法来形容判定的

04:50.980 --> 04:52.180
那么这个方法在哪呢

04:52.180 --> 04:52.780
这个方法呢

04:52.780 --> 04:53.680
实际上它在这

04:55.080 --> 04:56.280
方形

04:56.280 --> 04:56.880
第二

04:56.880 --> 04:58.480
proto

04:58.480 --> 04:59.380
type

04:59.380 --> 05:00.580
第二

05:00.580 --> 05:01.980
不是第二了

05:01.980 --> 05:03.480
它的方法实际上在这

05:03.480 --> 05:04.380
在这

05:04.380 --> 05:07.080
但是那你在控制台上可能看不太看得到

05:07.080 --> 05:07.980
实际上在这

05:07.980 --> 05:09.480
实际上在这

05:09.480 --> 05:10.480
是它的方法

05:10.480 --> 05:11.780
因为我们所有的函数

05:11.780 --> 05:13.980
是不是都是通过它来创建的

05:13.980 --> 05:14.880
因此我们所有的函数

05:14.880 --> 05:16.280
都有这么一个东西

05:16.280 --> 05:17.380
都有这么一个东西

05:17.380 --> 05:18.380
好比举个例子啊

05:18.380 --> 05:19.880
举个例子说起来才说像

05:19.880 --> 05:20.580
比方说呢

05:20.580 --> 05:21.380
我们呢

05:21.380 --> 05:23.380
有一个函数

05:23.380 --> 05:24.780
a

05:24.780 --> 05:25.780
一个构造函数

05:25.780 --> 05:26.480
啥都没有

05:26.480 --> 05:26.980
啥都没有

05:26.980 --> 05:27.880
啥都没有

05:27.880 --> 05:28.280
然后呢

05:28.280 --> 05:28.780
我们这里呢

05:28.780 --> 05:30.480
创建一个obj

05:30.480 --> 05:31.480
创建一个a

05:31.480 --> 05:32.480
a的对象

05:32.480 --> 05:32.780
来吧

05:32.780 --> 05:34.280
我们输出一下obj

05:34.280 --> 05:36.180
instance

05:36.180 --> 05:37.080
啊

05:37.080 --> 05:37.880
什么

05:37.880 --> 05:39.080
a

05:39.080 --> 05:39.980
看一下

05:39.980 --> 05:40.880
是不是微粗了

05:40.880 --> 05:41.880
它一定是微粗啊

05:41.880 --> 05:43.480
因为圆形在一条链上

05:43.480 --> 05:45.280
它肯定是微粗啊

05:45.280 --> 05:45.980
这个肯定是微粗

05:45.980 --> 05:46.680
对吧

05:46.680 --> 05:49.080
以前我们是没法参与改动的

05:49.080 --> 05:50.280
比方说我们希望了

05:50.280 --> 05:51.380
这个判定永远为假

05:51.380 --> 05:52.180
那假设嘛

05:52.180 --> 05:53.380
就这么一个假设

05:53.380 --> 05:54.080
我们希望控制这个

05:54.080 --> 05:55.280
判定永远为假

05:55.280 --> 05:56.080
那怎么办呢

05:56.080 --> 05:57.280
没法没有

05:57.280 --> 05:58.980
以前没有办法

05:58.980 --> 06:00.180
那么现在有办法了

06:00.180 --> 06:02.180
现在ges6高数里

06:02.180 --> 06:03.280
这个东西判定的

06:03.280 --> 06:04.780
实际上是在做什么呢

06:04.780 --> 06:06.280
实际上是在调用

06:06.280 --> 06:08.380
adb的一个知名函数

06:08.380 --> 06:10.980
叫做symbol

06:10.980 --> 06:12.280
hasinstance

06:12.280 --> 06:12.680
调用

06:12.680 --> 06:13.680
实际上调用这个函数

06:13.680 --> 06:15.480
把obj传进去

06:15.480 --> 06:16.080
你看

06:16.080 --> 06:16.880
是不是true

06:16.880 --> 06:17.680
对吧

06:17.680 --> 06:19.080
为什么这个instance

06:19.080 --> 06:20.180
它能判定为粗呢

06:20.180 --> 06:21.080
是因为这个地方

06:21.080 --> 06:23.380
它判定的为粗

06:23.380 --> 06:25.680
因此我们能不能改了

06:25.680 --> 06:27.080
是不是就可以改了

06:27.080 --> 06:27.880
你看一下

06:27.880 --> 06:30.080
这里边是不是就是ad成员

06:30.080 --> 06:31.380
来吧

06:31.380 --> 06:32.080
ad里边

06:32.080 --> 06:33.380
del什么了

06:33.380 --> 06:34.180
del啥

06:34.180 --> 06:35.280
不是del啊

06:35.280 --> 06:38.180
直接给它这个复制symbol

06:38.180 --> 06:39.980
del hasinstance

06:39.980 --> 06:41.580
给它复制为一个函数

06:41.580 --> 06:42.180
对吧

06:42.180 --> 06:42.880
给它复一个函数

06:42.880 --> 06:43.880
你给我一个obj

06:43.880 --> 06:45.380
你给我一个对象

06:45.480 --> 06:47.280
我来判断这个对象是不是

06:47.280 --> 06:48.780
它的原形链上是不是有误

06:48.780 --> 06:50.180
就是判断这个东西

06:50.180 --> 06:51.980
到底为真还是为假

06:51.980 --> 06:53.380
那么你这里随便怎么判断

06:53.380 --> 06:55.280
想咋判断咋判断

06:55.280 --> 06:58.180
那么这里比方说我们直接返回一个force

06:58.180 --> 06:59.380
那里看一下

06:59.380 --> 07:00.480
包出来

07:00.480 --> 07:03.580
哎呀

07:03.580 --> 07:06.680
我看哪里写错了吗

07:06.680 --> 07:07.280
instance

07:12.280 --> 07:13.980
没问题啊

07:13.980 --> 07:14.980
刷新

07:15.080 --> 07:16.680
等一下

07:16.680 --> 07:17.380
哦

07:17.380 --> 07:20.080
这里有这个问题

07:20.080 --> 07:21.780
就这个属性是不能改写的

07:21.780 --> 07:23.080
是不能改写的

07:23.080 --> 07:24.780
这种属性是不能改写的

07:24.780 --> 07:25.580
你要改写的话

07:25.580 --> 07:27.780
你必须要通过这种方式

07:27.780 --> 07:31.080
用这个obj的define property

07:31.080 --> 07:32.580
用这种方式来改写

07:32.580 --> 07:32.980
对象

07:32.980 --> 07:34.780
第一个对象传啥传A

07:34.780 --> 07:36.380
给这个A上加一个属

07:36.380 --> 07:37.780
就是改一个属性

07:37.780 --> 07:38.680
属性是啥呢

07:38.680 --> 07:41.880
属性就是symbol hasinstance

07:41.880 --> 07:43.480
要通过这种方式来改

07:43.480 --> 07:44.580
这个属性

07:44.680 --> 07:46.080
这个属性你是不能改的

07:46.080 --> 07:47.080
在它的内部实现

07:47.080 --> 07:47.680
你要改的话

07:47.680 --> 07:48.180
可以改

07:48.180 --> 07:49.380
你通过这种方式

07:49.380 --> 07:49.580
好

07:49.580 --> 07:51.280
那么这后边是discrepanter

07:51.280 --> 07:51.480
对吧

07:51.480 --> 07:53.080
配置为它的value

07:53.080 --> 07:54.380
这个属性的值是什么呢

07:54.380 --> 07:56.080
属性的值是一个函数

07:56.080 --> 07:57.480
我这里直接返回force

07:59.280 --> 07:59.780
好

07:59.780 --> 08:00.880
那么咱们看一下

08:00.880 --> 08:01.980
保存啊

08:01.980 --> 08:03.980
这边你看是不是变成force了

08:03.980 --> 08:05.080
那么也就是现在呢

08:05.080 --> 08:06.780
我们instance of A变成force

08:06.780 --> 08:07.980
是不是被我们改了

08:07.980 --> 08:09.380
我们在这里还可以做任何事情

08:09.380 --> 08:11.280
比方输出

08:11.280 --> 08:13.280
然后判定

08:13.280 --> 08:15.080
判定obj

08:15.080 --> 08:16.980
你看每次判定obj

08:16.980 --> 08:18.180
是不是在输出啊

08:18.180 --> 08:18.580
对不对

08:18.580 --> 08:19.580
你想做什么做什么

08:19.580 --> 08:21.980
是不是可以参与它的内部实现了

08:21.980 --> 08:22.880
现在是不是可以参与了

08:22.880 --> 08:24.280
以前参与不了

08:24.280 --> 08:25.680
现在可以参与了

08:25.680 --> 08:26.280
原来的意思

08:26.280 --> 08:28.080
所以你要现在知道

08:28.080 --> 08:30.180
现在实际上instance of判定

08:30.180 --> 08:31.380
实际上你刁了这个

08:31.380 --> 08:31.780
其实呢

08:31.780 --> 08:33.880
我要讲的也不是这么一个玩意

08:33.880 --> 08:35.380
我要讲的就是告诉你

08:35.380 --> 08:36.880
通过这个例子能告诉你

08:36.880 --> 08:38.280
你现在呢

08:38.280 --> 08:39.580
在某些场景下边

08:39.580 --> 08:42.480
是可以参与GS的内部实现的

08:42.480 --> 08:43.880
以前是不行的

08:43.880 --> 08:45.380
以前不行

08:45.380 --> 08:47.780
好 接下来我们随便再介绍一些吧

08:47.780 --> 08:49.380
你爱听又听这些东西呢

08:49.380 --> 08:50.880
你不听对你完全没影响

08:50.880 --> 08:53.180
听了过后呢增加一些眼界也可以

08:53.180 --> 08:54.680
也不错

08:54.680 --> 08:55.680
都是扩展啊

08:55.680 --> 08:57.180
二三次都是扩展

08:57.180 --> 08:58.280
其实二三次都还没有讲完

08:58.280 --> 08:59.680
还有一些其他的知名符号

08:59.680 --> 09:00.780
其他知名符号呢

09:00.780 --> 09:01.580
有一个蛮重要的

09:01.580 --> 09:02.880
但是现在讲不了

09:02.880 --> 09:03.880
他要解释一些知识

09:03.880 --> 09:05.580
我们后边才会讲

09:05.580 --> 09:07.380
好 首先让我们看一下这个这个地方

09:07.380 --> 09:10.680
叫symbol is concat spreadable

09:10.680 --> 09:11.580
什么意思呢

09:11.580 --> 09:12.680
好 这个知名符号呢

09:12.680 --> 09:14.980
会影响宿主的concat方法

09:14.980 --> 09:17.790
好 给大家看一下吧

09:17.790 --> 09:20.590
哎呀 这个块我也没忘了

09:20.590 --> 09:22.790
因为我平时开发哪会用到这些东西吗

09:22.790 --> 09:24.090
根本不会用到这些东西

09:24.090 --> 09:26.190
所以就把它做成扩展

09:26.190 --> 09:27.190
什么意思呢

09:27.190 --> 09:29.990
比方说宿主里边有一些数字

09:29.990 --> 09:31.790
AR concat不是一个函数吗

09:31.790 --> 09:32.690
对不对

09:32.690 --> 09:33.490
这个函数呢

09:33.490 --> 09:35.390
它有它很神奇

09:35.390 --> 09:37.490
你可以给它传

09:37.590 --> 09:38.790
一个蚕数

09:38.790 --> 09:40.490
它返回一个新的宿主

09:40.490 --> 09:41.890
对吧

09:41.890 --> 09:42.790
返回一个新的宿主

09:42.790 --> 09:45.190
我们这里先输出一下AR

09:45.190 --> 09:45.990
保存

09:45.990 --> 09:47.390
你看一下

09:47.390 --> 09:48.990
是不是这个数字没变

09:48.990 --> 09:50.190
这个数字是不是只有一个3

09:50.190 --> 09:50.690
对吧

09:50.690 --> 09:52.990
我们这里添加一个56

09:52.990 --> 09:53.790
原数字不变

09:53.790 --> 09:56.590
它会返回一个新的宿主

09:56.590 --> 09:57.990
result

09:57.990 --> 09:59.090
那么新的宿主呢

09:59.090 --> 10:00.390
它就是原来这个宿主

10:00.390 --> 10:01.590
拼接上这个数字

10:01.590 --> 10:03.590
是不是宿主形成了两项

10:03.590 --> 10:03.890
对吧

10:03.890 --> 10:04.490
3和56

10:04.490 --> 10:06.190
这个很简单对吧

10:06.690 --> 10:07.490
很神奇

10:07.490 --> 10:10.390
接下来我们再给它传一个宿主

10:10.390 --> 10:12.990
5678

10:12.990 --> 10:14.490
那么这会怎么处理呢

10:14.490 --> 10:16.990
那么这里是不是有逻辑上的起义

10:16.990 --> 10:18.490
它有可能会这样处理

10:18.490 --> 10:20.090
3 56

10:20.090 --> 10:21.290
第三项是一个宿主

10:21.290 --> 10:22.390
5678

10:22.390 --> 10:22.590
对吧

10:22.590 --> 10:24.090
这个也是符合逻辑的

10:24.090 --> 10:26.390
它也可以这样处理

10:26.390 --> 10:28.090
3 56

10:28.090 --> 10:30.090
567

10:30.090 --> 10:30.990
是不是不一样的

10:30.990 --> 10:31.390
对吧

10:31.390 --> 10:33.390
它是不是有两种处理方式

10:33.390 --> 10:34.090
对不对

10:34.090 --> 10:34.290
好

10:34.290 --> 10:35.090
保存

10:35.090 --> 10:35.690
你看一下

10:35.690 --> 10:36.390
它是怎么处理的

10:36.390 --> 10:37.790
它是按照第二种方式处理的

10:37.790 --> 10:40.690
这种处理方式叫做分割

10:40.690 --> 10:42.890
它只要发现你给它的参数

10:42.890 --> 10:44.790
你给它的某一个参数

10:44.790 --> 10:46.690
它有数字锁印

10:46.690 --> 10:48.090
并且有类似属性

10:48.090 --> 10:50.790
它就会把这个当成宿主来分割

10:50.790 --> 10:52.590
分割完了之后

10:52.590 --> 10:54.290
然后加到新宿主里面去

10:54.290 --> 10:55.690
它有这么一个行为

10:55.690 --> 10:58.890
以前我们是绝对不可能控制这个行为了

10:58.890 --> 10:59.190
对吧

10:59.190 --> 11:01.290
我们没有办法控制这个行为

11:01.290 --> 11:02.290
所以说它要分割

11:02.290 --> 11:03.790
我们只能让它分割

11:03.790 --> 11:05.090
那如果说你要控制这个行为

11:05.090 --> 11:05.890
以前没办法

11:05.890 --> 11:07.190
到现在可以了

11:07.190 --> 11:08.290
那怎么做呢

11:08.290 --> 11:10.090
你看我这样做

11:10.090 --> 11:13.090
我把这个玩意先保存在变量里面

11:13.090 --> 11:14.390
AR2

11:14.390 --> 11:15.690
先保存在变量里面

11:15.690 --> 11:16.690
那么这个把宿主放进去

11:16.690 --> 11:17.290
是不是一样的

11:17.290 --> 11:18.290
这个没有什么区别

11:18.290 --> 11:18.790
对吧

11:18.790 --> 11:19.990
这个没什么区别

11:19.990 --> 11:22.490
你看一下吧

11:22.490 --> 11:23.190
这边

11:23.190 --> 11:24.090
是不是一样的

11:24.090 --> 11:25.190
对吧

11:25.190 --> 11:25.890
一样的

11:25.890 --> 11:26.890
没有什么区别

11:26.890 --> 11:27.090
好

11:27.090 --> 11:29.690
那么现在它之所以会变成分割

11:29.690 --> 11:31.590
它会把这个宿主分割

11:31.590 --> 11:33.990
是因为这个宿主里面

11:33.990 --> 11:35.590
它受到这个属性的影响

11:35.590 --> 11:36.290
什么属性呢

11:36.290 --> 11:38.290
是一个知名符号属性

11:38.290 --> 11:40.090
叫做symbol

11:40.090 --> 11:41.190
symbol

11:41.190 --> 11:42.790
叫做属性名义长串

11:42.790 --> 11:46.190
就是 isConcrete separatable

11:46.190 --> 11:48.290
isConcrete separatable

11:48.290 --> 11:49.290
什么意思

11:49.290 --> 11:51.290
是否在Concrete的时候

11:51.290 --> 11:53.390
是不是在Concrete连接宿主的时候

11:53.390 --> 11:56.190
要把当前的宿主进行分割

11:56.190 --> 11:57.390
就这么个意思

11:57.390 --> 11:58.190
你把它视为true

11:58.190 --> 11:59.390
它就要分割

11:59.390 --> 12:00.090
保存

12:00.090 --> 12:01.390
你看是不是分割了

12:01.390 --> 12:03.890
如果说你把它视为force

12:03.890 --> 12:05.290
它就不会进行分割

12:05.290 --> 12:06.090
你看

12:06.090 --> 12:06.790
第二项是不是

12:06.790 --> 12:08.390
第三项是不是变成一个宿主了

12:08.390 --> 12:08.690
对吧

12:08.690 --> 12:10.390
它会影响这么一个东西

12:10.390 --> 12:12.490
你说这有啥多大用呢

12:12.490 --> 12:13.690
也不是没有多大用

12:13.690 --> 12:14.590
而且神奇的是

12:14.590 --> 12:15.490
这个玩意

12:15.490 --> 12:17.390
它还可以用于对象

12:17.390 --> 12:18.390
它还可以用于对象

12:18.390 --> 12:18.990
你看着

12:20.490 --> 12:21.290
const

12:21.290 --> 12:21.690
obg

12:23.590 --> 12:25.690
如果说你给它直接传一个对象进去的话

12:25.690 --> 12:26.490
它是不会分割的

12:26.490 --> 12:27.290
比方说哪怕

12:27.290 --> 12:28.390
哪怕这个对象是

12:28.390 --> 12:30.590
有点像是一个宿主

12:30.590 --> 12:31.890
有点像一个宿主

12:31.890 --> 12:33.590
我换个例子吧

12:33.590 --> 12:34.590
换个例子

12:34.590 --> 12:35.890
copy一下

12:35.890 --> 12:37.690
这里写1

12:37.690 --> 12:39.990
这个地方不要了

12:39.990 --> 12:41.190
这个地方不要了

12:41.190 --> 12:43.390
那么这里有一个obj

12:43.390 --> 12:45.090
obj

12:45.090 --> 12:48.690
这里我们0为2

12:48.690 --> 12:50.090
1为3

12:50.090 --> 12:54.190
nance为2

12:54.190 --> 12:55.590
是不是很像一个宿主

12:55.590 --> 12:55.990
对吧

12:55.990 --> 12:56.790
很像一个宿主

12:56.790 --> 12:57.890
咱们把obj传进去

12:57.890 --> 12:58.890
看一下它要不要分割

12:58.890 --> 13:00.590
把obj分割成2和3

13:00.590 --> 13:01.990
加到这个宿主里面去

13:01.990 --> 13:03.190
它不会分割

13:03.190 --> 13:04.390
它不会分割的

13:04.390 --> 13:04.790
你看

13:09.790 --> 13:11.290
我这里为什么写个56

13:11.290 --> 13:11.590
对了

13:11.590 --> 13:12.490
56

13:12.490 --> 13:13.190
12

13:13.190 --> 13:14.090
这里写3

13:14.090 --> 13:14.790
这里写4

13:14.790 --> 13:15.390
OK

13:15.390 --> 13:16.190
那么你看一下

13:16.190 --> 13:17.390
它把2加进去

13:17.390 --> 13:18.790
然后再把对象加进去

13:18.790 --> 13:20.990
它会不会把对象展开分割

13:20.990 --> 13:21.590
它不会

13:21.590 --> 13:22.990
它就直接把对象加进去了

13:22.990 --> 13:24.190
看到没

13:24.190 --> 13:26.190
如果说我希望它把对象加进去的时候

13:26.190 --> 13:26.990
分割怎么办

13:26.990 --> 13:27.190
好

13:27.190 --> 13:28.790
我看我可以这样做

13:28.790 --> 13:30.690
我可以在对象里面写个知名属性

13:30.690 --> 13:31.190
symbol

13:32.190 --> 13:35.390
叫做 is concatenate separatable

13:35.390 --> 13:37.590
把它变成要分割

13:37.590 --> 13:38.390
那么你看

13:38.390 --> 13:39.890
所以把对象也分割了

13:39.890 --> 13:40.590
对吧

13:41.990 --> 13:42.690
有点意思

13:42.690 --> 13:43.390
有点意思

13:45.190 --> 13:46.390
既然我们看这个

13:46.390 --> 13:47.790
这个也是扩展

13:47.790 --> 13:49.190
都是一些扩展知识

13:49.190 --> 13:52.390
这个知名符号会影响内形转换的结果

13:52.390 --> 13:53.790
这又是啥意思呢

13:53.790 --> 13:54.590
就有的时候

13:54.590 --> 13:56.590
我们有一些对象

13:56.590 --> 13:58.490
对象可能会参与一些运算

13:58.490 --> 13:59.590
参与一些运算的时候

13:59.590 --> 14:00.790
它会进行转换

14:00.990 --> 14:02.090
会进行转换

14:02.090 --> 14:03.790
比方说我们这里对象

14:03.790 --> 14:04.790
A等于1

14:04.790 --> 14:05.890
B等于2

14:05.890 --> 14:07.290
比方说我们这里输出一个啥呢

14:09.390 --> 14:10.390
输出一个

14:13.090 --> 14:14.490
ob借

14:14.490 --> 14:15.890
拼接上

14:15.890 --> 14:16.590
123

14:16.590 --> 14:17.790
加上123

14:17.790 --> 14:19.390
这是不是一个数学运算

14:19.390 --> 14:19.790
对吧

14:19.790 --> 14:21.690
是不是一个数学运算

14:21.690 --> 14:23.490
那么这么一个数学运算的话

14:23.490 --> 14:24.190
保存

14:24.190 --> 14:25.190
那么你看一下

14:25.190 --> 14:26.590
得到结果是啥呢

14:26.590 --> 14:27.690
得到结果

14:27.690 --> 14:29.390
它把它变成制服数的拼接了

14:29.390 --> 14:31.290
它为什么会把它变成制服数的拼接

14:31.290 --> 14:32.790
因为它在运算的时候

14:32.790 --> 14:34.390
它在进行数学运算的时候

14:34.390 --> 14:36.590
它会做这么一个默认行为处理

14:36.590 --> 14:39.490
它首先调用ob借的value

14:39.490 --> 14:40.790
它首先调用这个

14:40.790 --> 14:43.790
首先调用这个ob借的value

14:43.790 --> 14:45.290
调用这个函数

14:45.290 --> 14:46.790
你看出来的结果

14:46.790 --> 14:47.390
是不是这个

14:47.390 --> 14:48.890
还是它本身对吧

14:48.890 --> 14:51.590
通过这个东西拿不到一个基本类型

14:51.590 --> 14:53.190
它一定要去拿一个基本类型

14:53.190 --> 14:54.890
因为你要去进行这种运算

14:54.890 --> 14:56.090
还一定要拿基本类型

14:56.090 --> 14:57.190
它拿不到基本类型

14:57.190 --> 14:58.490
ok 拿不到基本类型

14:58.490 --> 15:01.090
它又去调用这个toolstream

15:01.090 --> 15:02.090
调用toolstream过后

15:02.090 --> 15:03.390
它就拿到基本类型了

15:03.390 --> 15:04.890
它一定要先调用value

15:04.890 --> 15:05.890
再调用toolstream

15:05.890 --> 15:07.090
拿到这个基本类型了

15:07.090 --> 15:08.590
拿到这个基本类型过后

15:08.590 --> 15:09.590
它发现是一个字幕券

15:09.590 --> 15:10.890
字幕券跟123

15:10.890 --> 15:12.290
是不是进行字幕券拼接

15:13.690 --> 15:14.290
对不对

15:14.290 --> 15:15.890
它是用这种模式来做的

15:15.890 --> 15:16.690
对吧

15:16.690 --> 15:17.990
它是用这种模式来做的

15:17.990 --> 15:20.290
那么我们以前是肯定是没法改动这种东西的

15:20.290 --> 15:20.690
对吧

15:20.690 --> 15:22.290
肯定是没法改动这种东西的

15:22.290 --> 15:23.790
但是我们现在可以了

15:23.790 --> 15:26.090
比方我要相承这么办

15:26.090 --> 15:27.390
相承

15:27.390 --> 15:28.390
那它又是这种

15:28.390 --> 15:29.690
先把它变成value

15:29.690 --> 15:30.990
没有得到数字

15:30.990 --> 15:32.390
再变成toolstream

15:32.390 --> 15:32.990
然后字幕券

15:32.990 --> 15:34.990
字幕券转成数字转不了

15:34.990 --> 15:36.190
转变了就是NAN

15:36.190 --> 15:38.190
NAN成123就是NAN

15:38.190 --> 15:38.990
对吧

15:38.990 --> 15:40.390
以前我们控制不了这个行为

15:40.390 --> 15:42.190
那么现在可以控制了

15:42.190 --> 15:43.390
现在怎么控制呢

15:43.390 --> 15:44.390
怎么控制呢

15:44.390 --> 15:46.190
这样控制

15:46.190 --> 15:49.990
我们要在这个对象的影视圆形上面

15:49.990 --> 15:51.890
我看直接加属性好像是不行的

15:51.890 --> 15:52.590
直接加属性

15:52.590 --> 15:53.690
我们比方说simple

15:53.690 --> 15:54.590
它一个属性叫做

15:55.590 --> 15:59.590
to primitive

15:59.590 --> 16:02.590
把它写成一个函数

16:02.590 --> 16:04.590
这个函数呢

16:04.590 --> 16:06.190
直接给它返回一个2

16:06.190 --> 16:07.590
比方说

16:07.590 --> 16:08.590
我们这样子写

16:08.590 --> 16:09.590
那你看

16:09.590 --> 16:10.590
是不是影响到了

16:10.590 --> 16:11.590
它变成了

16:11.590 --> 16:13.590
也就是现在在进行转换的时候

16:13.590 --> 16:15.590
它会调用这个函数来进行转换

16:15.590 --> 16:17.590
这个函数返回的是2

16:17.590 --> 16:19.590
那么2x123就是26

16:19.590 --> 16:20.590
对吧

16:20.590 --> 16:21.590
是不是可以这样做了

16:21.590 --> 16:23.590
当然我们还可以把这个玩意买到什么

16:23.590 --> 16:24.590
然后有一个构造

16:24.590 --> 16:26.590
这个对象是由于构造函数产生的

16:26.590 --> 16:27.590
那么我们可以把它写到

16:27.590 --> 16:28.590
构造函数的圆形里边

16:28.590 --> 16:30.590
是不是所有对象都有了

16:30.590 --> 16:31.590
对不对

16:31.590 --> 16:34.590
它就会影响所有对象的那种转换方式

16:34.590 --> 16:35.590
去个例子吧

16:35.590 --> 16:36.590
去个例子

16:36.590 --> 16:37.590
比方说我们这里有一个

16:37.590 --> 16:38.590
温度

16:38.590 --> 16:41.590
温度temperature

16:41.590 --> 16:44.590
temperature

16:44.590 --> 16:45.590
写对没有

16:45.590 --> 16:49.590
temperature

16:49.590 --> 16:50.590
对了

16:51.590 --> 16:53.590
有这么一个温度

16:53.590 --> 16:54.590
degree

16:54.590 --> 16:56.590
你给我一个度数

16:56.590 --> 16:57.590
给我一个度数

16:57.590 --> 16:58.590
那么我这里就是一个

16:58.590 --> 16:59.590
我们写成内嘛

16:59.590 --> 17:00.590
写成内

17:00.590 --> 17:01.590
class

17:01.590 --> 17:03.590
temperature

17:03.590 --> 17:04.590
都一样

17:04.590 --> 17:05.590
那么你constructor

17:05.590 --> 17:06.590
你给我一个degree

17:06.590 --> 17:07.590
一个温度

17:07.590 --> 17:08.590
那么我们把它

17:08.590 --> 17:09.590
保存那个属性里边

17:09.590 --> 17:10.590
degree

17:10.590 --> 17:11.590
假设我们一个温

17:11.590 --> 17:12.590
温度这么一个构造函数

17:12.590 --> 17:13.590
好

17:13.590 --> 17:15.590
那么我们现在去创建一个温度

17:15.590 --> 17:17.590
t等于new temperature

17:17.590 --> 17:19.590
比方说30度

17:19.590 --> 17:20.590
当然这里边还可以进行什么

17:20.590 --> 17:21.590
华式

17:21.590 --> 17:23.590
华式和设施的转换

17:23.590 --> 17:24.590
我就不写了

17:24.590 --> 17:25.590
那么现在呢

17:25.590 --> 17:26.590
我们比方说

17:26.590 --> 17:28.590
我们要输出t

17:28.590 --> 17:30.590
拼接上一个感叹号

17:30.590 --> 17:32.590
又要输出t

17:32.590 --> 17:34.590
除一二

17:34.590 --> 17:37.590
除一二

17:37.590 --> 17:38.590
又要输出把t

17:38.590 --> 17:39.590
转换成一个字部串

17:39.590 --> 17:40.590
比方说

17:40.590 --> 17:41.590
我们要做这么三件事情

17:41.590 --> 17:42.590
那么这些

17:42.590 --> 17:43.590
是不是都涉及到内形转换

17:43.590 --> 17:44.590
对吧

17:44.590 --> 17:45.590
这些以前都是

17:45.590 --> 17:46.590
介石的内部行为

17:46.590 --> 17:47.590
看没有

17:47.590 --> 17:48.590
都是介石的内部行为

17:48.590 --> 17:49.590
一控制不了的

17:49.590 --> 17:50.590
那么现在呢

17:50.590 --> 17:51.590
是可以控制的

17:51.590 --> 17:52.590
你怎么控制呢

17:52.590 --> 17:53.590
你是不是在

17:53.590 --> 17:54.590
往这个temperature的圆形上面

17:54.590 --> 17:56.590
加一个知名属性

17:56.590 --> 17:57.590
符号属性

17:57.590 --> 17:58.590
simple

17:58.590 --> 17:59.590
ease

17:59.590 --> 18:01.590
对吧

18:01.590 --> 18:02.590
你自己记不住

18:02.590 --> 18:04.590
to primer

18:04.590 --> 18:05.590
那么他这个

18:05.590 --> 18:06.590
他这里是个函数

18:06.590 --> 18:07.590
这个函数呢

18:07.590 --> 18:09.590
会给你传一个参数

18:09.590 --> 18:10.590
参数什么意思呢

18:10.590 --> 18:11.590
我们来输出一下这个参数

18:11.590 --> 18:12.590
tap

18:12.590 --> 18:13.590
输出下一个参数

18:13.590 --> 18:14.590
这个参数呢

18:14.590 --> 18:16.590
你看有default

18:16.590 --> 18:17.590
有number

18:17.590 --> 18:18.590
有stune

18:18.590 --> 18:20.590
你说第一次运行的时候

18:20.590 --> 18:22.590
他这个参数的值是default

18:22.590 --> 18:24.590
就是他默认的转换行为

18:24.590 --> 18:26.590
默认的转换行为

18:26.590 --> 18:27.590
第二次呢

18:27.590 --> 18:28.590
他是一个数字

18:28.590 --> 18:29.590
他是想把他转换成数字

18:29.590 --> 18:30.590
第三个呢

18:30.590 --> 18:31.590
是想把他转换成字无窜

18:31.590 --> 18:32.590
对吧

18:32.590 --> 18:34.590
默认的转换行为是什么意思的

18:34.590 --> 18:35.590
就是说先调用value

18:35.590 --> 18:37.590
先再调用什么

18:37.590 --> 18:38.590
再调用那个就是

18:38.590 --> 18:39.590
先调用value

18:39.590 --> 18:40.590
然后再调用什么toestune

18:40.590 --> 18:41.590
对吧

18:41.590 --> 18:42.590
先调用这么东西的进行状态

18:42.590 --> 18:43.590
这是默认的转换行为

18:43.590 --> 18:45.590
那么有了这个东西过后呢

18:45.590 --> 18:47.590
会按照这个喊出的规则来转换

18:47.590 --> 18:48.590
那么我们这里就可以判断

18:48.590 --> 18:50.590
如果你的转换行为是默认的

18:50.590 --> 18:52.590
就是第一种情况

18:52.590 --> 18:53.590
第一种情况是不是先调用value

18:53.590 --> 18:54.590
我再调用什么toestune

18:54.590 --> 18:55.590
对吧

18:55.590 --> 18:56.590
调用这些东西来进行转换

18:56.590 --> 18:57.590
好

18:57.590 --> 18:58.590
如果是这种情况的话

18:58.590 --> 18:59.590
那么我怎么办呢

18:59.590 --> 19:02.590
我就给你返回一个制幅串

19:02.590 --> 19:04.590
不要返回这么一个制幅串嘛

19:04.590 --> 19:06.590
就是this.degree

19:06.590 --> 19:08.590
拼接上

19:08.590 --> 19:11.590
degree

19:11.590 --> 19:12.590
多少度

19:12.590 --> 19:14.900
多少度

19:14.900 --> 19:16.900
设施度

19:16.900 --> 19:19.900
设施度

19:19.900 --> 19:22.900
如果说else if type

19:22.900 --> 19:24.900
如果说你type等于什么

19:24.900 --> 19:25.900
等于number

19:25.900 --> 19:27.900
你想把它转换成数字

19:27.900 --> 19:29.900
我就给你返回this.degree

19:29.900 --> 19:30.900
这就是个数字

19:30.900 --> 19:32.900
然后else if

19:32.900 --> 19:34.900
如果说你的type等于制幅串

19:34.900 --> 19:35.900
你想把它转换成制幅串

19:35.900 --> 19:37.900
我就给你返回

19:37.900 --> 19:39.900
return this.degree

19:39.900 --> 19:40.900
拼接上

19:40.900 --> 19:42.900
设施度

19:42.900 --> 19:43.900
拼上这个

19:43.900 --> 19:44.900
来吧

19:44.900 --> 19:45.900
看一下吧

19:45.900 --> 19:46.900
接下来我们看到这三个

19:46.900 --> 19:48.900
它有不同的转换方式

19:48.900 --> 19:50.900
第一个是转换成这样子

19:50.900 --> 19:51.900
第二个是转换成34的数字

19:51.900 --> 19:52.900
除一二变成15

19:52.900 --> 19:54.900
第三个是得到这个

19:54.900 --> 19:55.900
看没有

19:55.900 --> 19:58.280
就是这个

19:58.280 --> 19:59.280
如果我们通过这些例子

19:59.280 --> 20:00.280
都可以知道

20:00.280 --> 20:02.280
现在有了一些知名符号过后

20:02.280 --> 20:03.280
我们是可以影响

20:03.280 --> 20:05.280
解释的内部的一些行为的

20:05.280 --> 20:08.280
是有机会去产生影响的

20:08.280 --> 20:09.280
下面这个

20:09.280 --> 20:10.280
随便举一些例子吧

20:10.280 --> 20:12.280
下面这个是toestune tag

20:12.280 --> 20:14.280
这个知名符号会影响

20:14.280 --> 20:16.280
这个的返回值

20:16.280 --> 20:17.280
什么意思呢

20:17.280 --> 20:18.280
给大家打开看一下

20:18.280 --> 20:19.280
这个东西只要讲的话

20:19.280 --> 20:20.280
还是蛮多的

20:20.280 --> 20:22.280
打开看一下就行了

20:22.280 --> 20:24.280
就这个玩意

20:24.280 --> 20:25.280
这个玩意toestune tag

20:25.280 --> 20:26.280
什么意思呢

20:26.280 --> 20:28.280
比方说我们这里有个obj

20:28.280 --> 20:30.280
或者说我们这样子

20:30.280 --> 20:31.280
写个够多函数

20:31.280 --> 20:32.280
写个内

20:32.280 --> 20:34.280
parsing

20:34.280 --> 20:35.280
就一个内就行了

20:35.280 --> 20:36.280
一个内就行了

20:36.280 --> 20:37.280
行了

20:37.280 --> 20:38.280
我们建一个parsing内

20:38.280 --> 20:39.280
对象

20:39.280 --> 20:40.280
六一个parsing

20:40.280 --> 20:41.280
穿一个对象

20:41.280 --> 20:42.280
然后让我们输出

20:42.280 --> 20:44.280
p.toestune

20:44.280 --> 20:45.280
你看一下

20:45.280 --> 20:46.280
这包的是什么东西

20:46.280 --> 20:47.280
保存

20:47.280 --> 20:48.280
是不是

20:48.280 --> 20:49.280
obj 几个字

20:49.280 --> 20:52.280
我们再看一下这个

20:52.280 --> 20:55.280
cons array

20:55.280 --> 20:56.280
随便写一下

20:56.280 --> 20:57.280
对东西都无所谓

20:57.280 --> 20:58.280
随便写

20:58.280 --> 20:59.280
然后让我们输出

20:59.280 --> 21:02.280
arr toestune

21:07.280 --> 21:08.280
我们用这种方式

21:08.280 --> 21:09.280
这个arr

21:09.280 --> 21:10.280
这个输出里面

21:10.280 --> 21:11.280
它把toestune给它重写了

21:11.280 --> 21:12.280
重写了

21:12.280 --> 21:13.280
我们这个toestune

21:13.280 --> 21:14.280
我们希望的是

21:14.280 --> 21:16.280
用obj 里面的toestune

21:16.280 --> 21:17.280
toestune

21:17.280 --> 21:18.280
我们希望的是

21:18.280 --> 21:19.280
obj 的toestune

21:19.280 --> 21:20.280
我们用apply

21:20.280 --> 21:22.280
apply

21:22.280 --> 21:23.280
p

21:23.280 --> 21:24.280
apply p

21:24.280 --> 21:25.280
那么

21:25.280 --> 21:26.280
用obj 里面的toestune

21:26.280 --> 21:27.280
去调用一下

21:27.280 --> 21:29.280
这里也是

21:29.280 --> 21:30.280
其实

21:30.280 --> 21:31.280
这也是乘个的课程里面

21:31.280 --> 21:32.280
就讲的

21:32.280 --> 21:33.280
怎么来判定数组

21:33.280 --> 21:34.280
对吧

21:34.280 --> 21:35.280
因为数组的判定

21:35.280 --> 21:36.280
用instance of

21:36.280 --> 21:37.280
如果说一面

21:37.280 --> 21:38.280
出现了fraying的时候

21:38.280 --> 21:40.280
可能会出现一些问题

21:40.280 --> 21:41.280
toestune

21:41.280 --> 21:42.280
来看一下

21:44.280 --> 21:45.280
这什么了

21:46.280 --> 21:47.280
怎么了

21:48.280 --> 21:50.280
obj 这点

21:50.280 --> 21:51.280
prototype

21:51.280 --> 21:53.280
这个东西写掉了

21:54.280 --> 21:55.280
好 你看一下

21:55.280 --> 21:57.280
我们写的构造函数

21:57.280 --> 21:58.280
是这个样子

21:58.280 --> 21:59.280
数组写的构造函数

21:59.280 --> 22:01.280
凭什么是这个样子呢

22:01.280 --> 22:02.280
凭什么

22:02.280 --> 22:03.280
凭什么

22:03.280 --> 22:04.280
我们这个地方

22:04.280 --> 22:05.280
构造函数

22:05.280 --> 22:06.280
这个地方

22:06.280 --> 22:07.280
应该写个构造函数名字

22:07.280 --> 22:08.280
那么我们的构造函数

22:08.280 --> 22:09.280
为什么不是person

22:09.280 --> 22:11.280
他凭什么是obj

22:11.280 --> 22:12.280
为什么数组是这个

22:12.280 --> 22:13.280
以前是改动不了的

22:13.280 --> 22:14.280
你没办法

22:15.280 --> 22:17.280
现在是可以改了

22:17.280 --> 22:18.280
现在怎么改

22:18.280 --> 22:19.280
怎么改

22:19.280 --> 22:22.280
你只需要在person 这里

22:22.280 --> 22:24.280
加上一个知名符号

22:24.280 --> 22:26.280
加上一个知名符号

22:26.280 --> 22:27.280
叫symbol

22:31.280 --> 22:32.280
叫做什么

22:32.280 --> 22:33.280
叫做那个符号

22:33.280 --> 22:35.280
叫toestune tag

22:36.280 --> 22:37.280
给它复制

22:37.280 --> 22:38.280
复制为什么

22:38.280 --> 22:39.280
你看一下

22:40.280 --> 22:41.280
就变成person了

22:41.280 --> 22:42.280
对吧

22:42.280 --> 22:43.280
这变成person了

22:43.280 --> 22:44.280
它加上这么一个玩意

22:44.280 --> 22:45.280
原先当加上这么一个玩意

22:45.280 --> 22:46.280
就变成person了

22:46.280 --> 22:47.280
就加上

22:47.280 --> 22:48.280
这个东西就会影响

22:48.280 --> 22:51.280
obj的原生的toestune函数

22:51.280 --> 22:53.280
它的第二个位置写啥

22:53.280 --> 22:54.280
写啥

22:54.280 --> 22:55.280
以前是不是控制不了

22:55.280 --> 22:56.280
现在可以控制了

22:56.280 --> 22:57.280
也就是通过这么一些例子

22:57.280 --> 22:58.280
我都是在告诉你

22:58.280 --> 23:00.280
s6和s5的理念是一样的

23:00.280 --> 23:01.280
减少魔法

23:01.280 --> 23:03.280
让一切都变得那么透明

23:03.280 --> 23:05.280
那么简单和单纯

23:05.280 --> 23:06.280
你们都可以影响

23:06.280 --> 23:08.280
不是我在里边玩的什么东西

23:08.280 --> 23:10.280
你都不知道我什么玩的

23:10.280 --> 23:12.280
你们也可以参与

23:12.280 --> 23:14.280
这就是知名符号

23:14.280 --> 23:15.280
其实这节课讲了

23:15.280 --> 23:17.280
具体的知名符号并不重要

23:17.280 --> 23:18.280
我只是通过这些例子

23:18.280 --> 23:19.280
告诉大家

23:19.280 --> 23:22.280
知名符号这么一个理念和概念

23:22.280 --> 23:24.280
以后我们会学习

23:24.280 --> 23:25.280
其中有一个非常重要的

23:25.280 --> 23:26.280
知名符号

23:26.280 --> 23:27.280
那个东西才是重点

23:27.280 --> 23:28.280
这个东西

23:28.280 --> 23:29.280
现在我们具体的学习

23:29.280 --> 23:30.280
这些知名符号并不重要

23:30.280 --> 23:31.280
但是通过这个例子

23:31.280 --> 23:32.280
可以了解

23:32.280 --> 23:33.280
知名符号

23:33.280 --> 23:34.280
公共符号

23:34.280 --> 23:37.280
那么符号这一章就到此结束了

