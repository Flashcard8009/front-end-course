WEBVTT

00:00.620 --> 00:04.940
好 来 这张截咱们学习更多的集合类型

00:04.940 --> 00:06.380
什么叫集合

00:06.380 --> 00:10.220
集合就是用来保存多个数据的一种数据结构

00:10.220 --> 00:11.980
它用来保存多个数据的

00:11.980 --> 00:14.340
实际上戒是里边的

00:14.340 --> 00:15.340
能不能保存多个数据呢

00:15.340 --> 00:16.380
当然是没问题的

00:16.380 --> 00:18.460
一直以来我们都使用的是数组

00:18.460 --> 00:21.100
或者是对象来保存多个数据

00:21.100 --> 00:22.220
有一个同学说

00:22.220 --> 00:24.620
对象怎么来保存多个数据呢

00:24.620 --> 00:26.860
你看对象里面不有属性吗

00:26.860 --> 00:28.180
不有很多属性吗

00:28.180 --> 00:29.980
对吧 每一个属性可以保存一个数据

00:29.980 --> 00:32.940
对象也是可以保存多个数据的

00:32.940 --> 00:35.740
它就缺乏像其他语言那样子

00:35.740 --> 00:38.220
拥有丰富的类型 集合类型

00:38.220 --> 00:39.740
像加把语言

00:39.740 --> 00:40.500
csharp语言

00:40.500 --> 00:42.700
它们除了数组和对象之外呢

00:42.700 --> 00:43.940
它还有很多的东西

00:43.940 --> 00:46.020
都可以保存多个数据

00:46.020 --> 00:49.340
因此为了适应更多的需求的话

00:49.340 --> 00:50.180
ES6呢

00:50.180 --> 00:51.580
它在这个版本里面

00:51.580 --> 00:53.420
就新增了两个集合类型

00:53.420 --> 00:54.500
一个是set

00:54.500 --> 00:55.780
就是我们这几个要讲的

00:55.780 --> 00:57.740
一个是map

00:57.740 --> 00:59.580
它这两种集合类型的话

00:59.620 --> 01:01.180
配合数组 配合对象

01:01.180 --> 01:04.140
它们可以在不同的场景里面发挥作用

01:04.140 --> 01:04.740
好 这节课呢

01:04.740 --> 01:07.020
咱们来学习set集合

01:07.020 --> 01:10.500
set集合它用来实现一个什么样的场景的

01:10.500 --> 01:12.940
set集合它用来做这么一件事

01:12.940 --> 01:19.900
set用于存放不重复的数据

01:21.540 --> 01:25.220
你可以把它理解为类似于一个数组

01:25.220 --> 01:28.260
只不过这个数组里面存的东西呢

01:28.260 --> 01:29.860
是不能重复的

01:29.860 --> 01:32.140
它用来存放这么一些数据

01:32.140 --> 01:33.940
如果说你以后遇到一些场景

01:33.940 --> 01:35.060
你要存一些数据

01:35.060 --> 01:37.980
你要放一些数据到一个集合里边去

01:37.980 --> 01:41.260
那么它又要求这些数据是不能重复的

01:41.260 --> 01:42.460
当然你可以自己

01:42.460 --> 01:44.580
每次加数据的时候可以自己判断一下

01:44.580 --> 01:45.500
对吧

01:45.500 --> 01:48.300
最简单的就是可以使用set集合

01:48.300 --> 01:50.460
set集合就专门用来做这个事了

01:50.460 --> 01:52.780
好 咱们来看一下set集合怎么要用

01:52.780 --> 01:55.140
首先那么一个个看

01:55.140 --> 01:57.700
如何来创建一个set集合

01:57.780 --> 02:01.260
如何创建set集合

02:01.260 --> 02:03.020
怎么来创建呢

02:03.020 --> 02:04.500
set集合的创建方式

02:04.500 --> 02:08.060
直接使用它的构造函数就是set

02:08.060 --> 02:10.100
就这种方式

02:10.100 --> 02:11.460
view一个set

02:11.460 --> 02:12.740
就靠它构造函数

02:12.740 --> 02:14.060
这就创建了一个

02:14.060 --> 02:20.660
创建了一个没有任何内容的set集合

02:20.660 --> 02:22.700
这创建一个没有任何内容的set集合

02:22.700 --> 02:25.380
咱们来写一下吧

02:25.380 --> 02:29.930
test1

02:30.010 --> 02:32.730
这里我们就写这么一袋

02:35.050 --> 02:36.770
set

02:36.770 --> 02:37.970
或者就s

02:37.970 --> 02:39.570
view一个set

02:39.570 --> 02:41.050
这样就创建了一个空的

02:41.050 --> 02:42.970
没有任何内容的set集合

02:42.970 --> 02:43.650
咱们来看一下

02:43.650 --> 02:45.050
打印出来

02:45.050 --> 02:48.850
你看一下

02:48.850 --> 02:50.170
检查

02:50.170 --> 02:51.450
空台

02:51.450 --> 02:52.490
你看 是不是

02:52.490 --> 02:53.330
没有任何东西

02:53.330 --> 02:53.650
对吧

02:53.650 --> 02:55.730
没有任何东西

02:55.730 --> 02:57.690
这就是一个set集合

02:57.690 --> 03:01.050
然后我们如果说你在创建集合的时候

03:01.090 --> 03:03.410
你希望给它加一些数据进去了

03:03.410 --> 03:04.170
那怎么办呢

03:04.170 --> 03:05.610
你可以使用第二种方式

03:05.610 --> 03:06.850
它的构造函数里面

03:06.850 --> 03:08.610
是可以传递参数的

03:08.610 --> 03:10.490
这个参数它是这么一回事

03:10.490 --> 03:13.170
这参数传的是Aterable

03:13.170 --> 03:14.290
是不是学过了

03:14.290 --> 03:15.530
Aterable啥意思

03:15.530 --> 03:17.490
是不是可叠带的对象

03:17.490 --> 03:19.690
你只要把可叠带的对象传进去

03:19.690 --> 03:22.130
那么它会利用你这个可叠带的对象

03:22.130 --> 03:24.130
来给你创建这么一个set集合

03:24.130 --> 03:24.970
那么这种方式

03:24.970 --> 03:33.930
它创建一个具有初始内容的set集合

03:33.930 --> 03:34.970
内容是什么呢

03:34.970 --> 03:40.530
内容来自于可叠带对象

03:40.530 --> 03:43.050
每一次叠带的结果

03:43.050 --> 03:44.650
这我们上一档学习了

03:44.650 --> 03:45.210
对吧

03:45.210 --> 03:46.090
每一次叠带的结果

03:46.090 --> 03:47.370
它就放进去了

03:47.370 --> 03:47.610
好

03:47.610 --> 03:48.210
来吧

03:48.210 --> 03:49.170
我们来试一下

03:49.170 --> 03:50.170
再来一个S1

03:51.690 --> 03:54.860
再来一个S2

03:54.860 --> 03:56.380
然后另外一个set

03:56.420 --> 03:58.980
这里边可以传递一个可叠带对象

03:58.980 --> 04:02.100
任何可叠带对象都可以

04:02.100 --> 04:04.100
那么这些可叠带对象

04:04.100 --> 04:05.340
我们怎么写呢

04:05.340 --> 04:06.860
是不是就比方数组

04:06.860 --> 04:08.300
数组是不是可叠带对象

04:08.300 --> 04:08.780
对吧

04:08.780 --> 04:09.500
数组是不是

04:09.500 --> 04:10.220
当然是

04:10.220 --> 04:12.860
比方说我们这里传递一个12345

04:12.860 --> 04:14.300
那么把数组传进去

04:14.300 --> 04:15.180
它会怎么样呢

04:15.180 --> 04:16.980
它会把你这个可叠带对象

04:19.180 --> 04:20.700
它每一次叠带的结果

04:20.700 --> 04:21.500
那么每一次叠带的结果

04:21.500 --> 04:22.340
是不是123456

04:22.340 --> 04:22.580
对吧

04:22.580 --> 04:23.540
分别是

04:23.540 --> 04:25.820
那么把它作为set的初始相

04:25.860 --> 04:26.100
好

04:26.100 --> 04:28.820
这里我们输出S2

04:28.820 --> 04:30.300
保存

04:30.300 --> 04:31.220
你看一下

04:31.220 --> 04:32.140
第二个set集合

04:32.140 --> 04:34.180
是不是就有一些数据了12345

04:34.180 --> 04:35.100
所以放进来了

04:35.100 --> 04:35.660
对吧

04:35.660 --> 04:37.260
放进来了

04:37.260 --> 04:37.420
好

04:37.420 --> 04:40.300
这是关于set集合的初始化

04:40.300 --> 04:41.420
我们刚才说

04:41.420 --> 04:44.620
set集合它是不允许重复的

04:44.620 --> 04:46.260
存放不重复的数据

04:46.260 --> 04:49.660
那么如果说我这里写重复了怎么办

04:49.660 --> 04:51.540
如果说我写重复了怎么办

04:51.540 --> 04:52.700
比方说这里写

04:52.700 --> 04:53.580
写这样子

04:53.580 --> 04:55.460
这样子

04:55.500 --> 04:57.220
我写一些重复的数据会怎么办

04:57.220 --> 04:59.740
它会自动帮我们去掉重复的

04:59.740 --> 05:00.180
保存

05:00.180 --> 05:00.980
你看一下

05:00.980 --> 05:02.060
最终形成的结果

05:02.060 --> 05:03.940
set里边还是12345

05:03.940 --> 05:06.580
这就是一种非常简单的

05:06.580 --> 05:08.300
数组驱虫的方式

05:08.300 --> 05:09.500
可以通过这种方式

05:09.500 --> 05:11.580
直接对数组进行驱虫

05:11.580 --> 05:15.060
这是这种set创建的方式

05:15.060 --> 05:16.460
给它传递个可叠带对象

05:16.460 --> 05:18.460
当然它一不一定是数组

05:18.460 --> 05:20.060
能不能是别的对象

05:20.060 --> 05:20.660
可以

05:20.660 --> 05:21.980
只要你是可叠带对象

05:21.980 --> 05:22.740
都可以

05:23.060 --> 05:24.860
甚至你可以是一个制服串

05:26.540 --> 05:27.740
甚至你可以是个制服串

05:27.740 --> 05:28.940
制服串的话

05:28.940 --> 05:30.380
其实它是这样子

05:30.380 --> 05:31.580
制服串的话

05:31.580 --> 05:33.420
它会把它转换成

05:33.420 --> 05:35.820
会把它转换成驱对象

05:35.820 --> 05:38.300
驱对象它实际上是一个可叠带对象

05:38.300 --> 05:39.140
不信我们看一下

05:40.140 --> 05:41.660
我们这里六一个

05:45.420 --> 05:46.140
用一个变量

05:46.140 --> 05:46.940
STR

05:46.940 --> 05:50.500
六一个str

05:51.220 --> 05:52.620
咱们看一下STR

05:52.620 --> 05:53.380
STR

05:53.380 --> 05:53.940
它是个对象

05:54.340 --> 05:55.940
我们看一下它是不是可叠带的

05:57.540 --> 05:58.100
你看

05:58.100 --> 05:59.740
symbol attrator

05:59.740 --> 06:01.740
它也是个可叠带对象

06:01.740 --> 06:04.380
虽然说我给它传的是制服串的字面量

06:04.380 --> 06:05.460
那么它会进行转换

06:05.460 --> 06:07.140
转换成驱对象

06:07.140 --> 06:08.780
那么它是个可叠带对象

06:08.780 --> 06:10.460
因此它也是可以叠带的

06:10.460 --> 06:11.660
它每一次叠带是什么

06:11.660 --> 06:13.980
每一次叠带就是它的自己的

06:13.980 --> 06:14.980
每一个字母

06:14.980 --> 06:15.220
对吧

06:15.220 --> 06:16.380
每一个制服

06:16.380 --> 06:17.860
那么最终叠带的结果

06:17.860 --> 06:19.500
你看一下set输出

06:19.500 --> 06:20.540
输出结果是不是

06:20.540 --> 06:22.300
就已经对制服串去从了

06:22.340 --> 06:24.500
这也是一种非常简单的

06:24.500 --> 06:25.900
去从方式

06:25.900 --> 06:28.100
针对制服串的去从方式

06:28.100 --> 06:29.100
没人意思吗

06:29.100 --> 06:29.540
OK

06:29.540 --> 06:32.940
这是关于set的这两种创建方式

06:32.940 --> 06:34.140
接着来

06:34.140 --> 06:36.460
我们创建好了set集合之后

06:36.460 --> 06:38.820
我们还需要对这个集合进行后续操作

06:38.820 --> 06:40.060
什么叫后续操作呢

06:40.060 --> 06:41.700
往这个集合里边加东西

06:41.700 --> 06:43.700
比方说以前我们用数组

06:43.700 --> 06:45.140
所以有这个需求

06:45.140 --> 06:46.340
往数组里边加一箱

06:46.340 --> 06:47.100
删除一箱

06:47.100 --> 06:48.100
查找一箱

06:48.100 --> 06:48.940
等等

06:48.940 --> 06:51.420
我们需要往这个集合里边去加东西

06:51.460 --> 06:52.620
那么怎么加呢

06:52.620 --> 06:53.780
我们就设计到

06:53.780 --> 07:00.380
如何对set集合进行后续操作

07:00.380 --> 07:01.460
那么它这里边

07:01.460 --> 07:02.380
在set集合里边

07:02.380 --> 07:04.220
根本提供了一些实力方法

07:04.220 --> 07:06.100
就通过对象去调用的实力方法

07:06.100 --> 07:07.020
那么通过这些方法

07:07.020 --> 07:08.820
你可以完成对set集合的操作

07:08.820 --> 07:10.420
第一个方法

07:10.420 --> 07:11.580
ad

07:11.580 --> 07:14.220
这里边填数据

07:14.220 --> 07:16.740
那么这个方法做什么事情呢

07:16.740 --> 07:19.940
这个方法就是添加一个数据

07:19.980 --> 07:23.460
到set集合后续

07:23.460 --> 07:26.060
添加一个数据到set集合后续

07:26.060 --> 07:27.620
set它是有顺序的

07:27.620 --> 07:29.180
它是有一个顺序的

07:29.180 --> 07:32.580
就是按照你添加的顺序来排序的

07:32.580 --> 07:34.860
它添加一个数据到set集合后续

07:34.860 --> 07:35.940
那么添加之

07:35.940 --> 07:38.740
如果说数据已存在

07:38.740 --> 07:39.860
如果数据

07:39.860 --> 07:41.580
因为set集合是不允许重复的

07:41.580 --> 07:42.140
对吧

07:42.140 --> 07:44.980
如果数据已存在

07:44.980 --> 07:49.460
则不进行任何操作

07:49.580 --> 07:50.340
这是add

07:50.340 --> 07:51.500
咱们来试一下吧

07:51.500 --> 07:52.500
比方说我们这里

07:55.020 --> 07:56.060
就第一个集合吧

07:57.660 --> 07:58.900
我们看一下

07:58.900 --> 08:00.020
s1

08:00.020 --> 08:02.020
我们把这里还是保留一下

08:02.020 --> 08:03.060
我们重新开一个得了

08:06.360 --> 08:07.240
第一个集合

08:07.240 --> 08:09.240
我们之前创建了一个空的集合

08:09.240 --> 08:11.400
我们这里s1给它调用add

08:11.400 --> 08:12.280
加一个数据

08:12.280 --> 08:14.920
比方说这个数据是可以是任何类型

08:14.920 --> 08:16.080
你可以是对象

08:16.080 --> 08:17.920
就像我数组里面加一个对象一样

08:17.920 --> 08:18.920
你可以是数字

08:18.920 --> 08:19.720
你可以是支不出来

08:19.720 --> 08:21.000
可以是任何东西

08:21.040 --> 08:21.560
甚至可以

08:21.560 --> 08:23.240
还可以是另外一个set都可以

08:23.240 --> 08:24.160
随便啥都可以

08:25.160 --> 08:26.720
那么这里我们比方说加一个数字

08:26.720 --> 08:28.280
加一个3

08:28.280 --> 08:29.720
不要说再加一个1

08:29.720 --> 08:32.760
然后再加一个2

08:32.760 --> 08:34.000
s1add

08:34.000 --> 08:36.840
再加一个3

08:36.840 --> 08:37.200
好

08:37.200 --> 08:41.440
接下来我们再加一个s1add1

08:41.440 --> 08:44.480
这里我们输出s1

08:44.480 --> 08:45.200
保存

08:45.200 --> 08:46.480
这里我们打开看一下

08:48.000 --> 08:49.800
我们看一下这个集合

08:49.800 --> 08:50.160
刷新

08:51.200 --> 08:52.280
你看是不是123

08:52.280 --> 08:53.520
对吧123

08:53.520 --> 08:55.640
那么它后边我们在这一句代码

08:55.640 --> 08:56.560
是不是无效的

08:56.560 --> 08:57.000
对不对

08:57.000 --> 08:58.080
无效代码

08:58.080 --> 08:59.200
为什么无效呢

08:59.200 --> 09:02.000
因为它觉得这个东西跟这个东西是一样的

09:02.000 --> 09:03.480
那么既然一样set集合

09:03.480 --> 09:05.280
它不允许重复的数据

09:05.280 --> 09:07.160
因此它这句代码是无效的

09:07.160 --> 09:08.440
因为数据相同

09:09.440 --> 09:10.240
那意思

09:10.240 --> 09:12.720
那么它里面的数据就是123

09:12.720 --> 09:14.400
这里面有一个细节

09:14.400 --> 09:15.960
一个细节大家注意一下

09:15.960 --> 09:17.880
就是它怎么来判断两个数据

09:17.880 --> 09:19.200
是不是一样的

09:19.200 --> 09:20.760
是不是一样的

09:20.800 --> 09:27.640
它使用的是set使用objects.ease的方式

09:27.640 --> 09:33.400
判断两个数据是否相同

09:33.400 --> 09:35.200
它用这个方式来判断

09:35.200 --> 09:36.360
因为我们之前讲过的

09:36.360 --> 09:37.760
objects.ease

09:37.760 --> 09:39.760
它用的不是三个等号

09:39.760 --> 09:40.600
不是严格相的

09:40.600 --> 09:42.200
是用objects.ease来方式

09:42.200 --> 09:43.360
来判断两个数据

09:43.360 --> 09:44.120
是什么样的

09:44.160 --> 09:56.600
但是针对正临和负临set认为是同一个数据

09:56.600 --> 09:57.720
是相等的

09:57.720 --> 09:59.000
认为是相等的

10:00.320 --> 10:01.240
啥意思呢

10:01.240 --> 10:02.920
就说我们之前不是说过

10:02.920 --> 10:03.880
有这么一个方法

10:03.880 --> 10:04.960
叫objects.ease

10:05.960 --> 10:08.720
如果是正临和负临的话

10:08.720 --> 10:11.520
那么objects.ease认为是不相等的

10:11.520 --> 10:13.240
而严格相等里边

10:14.320 --> 10:16.520
正临和负临它认为是相等的

10:16.520 --> 10:18.280
那么针对这一块的话

10:18.280 --> 10:20.280
set它把正临和负临这一块

10:20.280 --> 10:21.800
就单独针对这一块

10:21.800 --> 10:23.680
它本来是用objects.ease来判断的

10:23.680 --> 10:25.600
但是它单独针对这一块

10:25.600 --> 10:27.680
它又把它看成是相等的

10:27.680 --> 10:28.840
也就是说啥呢

10:28.840 --> 10:30.840
也就是说我们这里如果说

10:30.840 --> 10:35.360
这里加了SE,ADD加了一个正临

10:36.680 --> 10:39.080
然后SE,ADD加一个负临

10:39.080 --> 10:40.360
它认为是同一个数据

10:40.360 --> 10:43.000
因此这一句代码是无效的

10:43.000 --> 10:43.960
你看一下吧

10:44.000 --> 10:44.960
是不是只有一个零

10:44.960 --> 10:45.640
对吧

10:45.640 --> 10:47.240
它认为这句代码是无效的

10:47.240 --> 10:48.720
你看这意思吗

10:48.720 --> 10:50.320
像这个东西

10:50.320 --> 10:52.440
我怎么说呢

10:52.440 --> 10:53.600
这个东西没法开拓

10:53.600 --> 10:54.200
我告诉你

10:54.200 --> 10:56.200
这个东西肯定是没法开拓的

10:56.200 --> 10:58.520
你再怎么去狡辩都没用

10:58.520 --> 11:00.320
这纯粹是设计的问题

11:00.320 --> 11:02.680
这是设计的问题

11:02.680 --> 11:05.440
它不应该去这样去设计

11:05.440 --> 11:07.640
一个语言它设计一定要统一

11:07.640 --> 11:08.440
你是怎么想的

11:08.440 --> 11:10.000
你认为它们是不是一个东西

11:10.000 --> 11:11.640
就全程认为它是一个东西

11:11.640 --> 11:12.760
你认为它们不是一个东西

11:12.800 --> 11:14.880
全程认为它不是一个东西

11:14.880 --> 11:16.200
设计要统一

11:16.200 --> 11:17.960
这个东西没法开拓

11:17.960 --> 11:21.000
因为EX它整个设计的话

11:21.000 --> 11:23.040
它不是一个人完成的

11:23.040 --> 11:26.440
而且好多人都还是坚持

11:26.440 --> 11:27.120
坚持状态

11:27.120 --> 11:29.000
所以大部分人来做这个事情

11:29.000 --> 11:30.800
难免会造成一些

11:30.800 --> 11:33.600
这种设计上不同意的情况

11:33.600 --> 11:34.760
给大家说一下

11:34.760 --> 11:37.600
这是ADD

11:37.600 --> 11:39.080
接下来我们来看一下

11:39.080 --> 11:40.000
加数据我们搞定了

11:40.000 --> 11:40.280
对吧

11:40.280 --> 11:41.800
可以往那边加数据

11:41.840 --> 11:44.760
然后我们看一下它里边怎么来判断

11:44.760 --> 11:46.600
有没有数据了

11:46.600 --> 11:49.040
它是用这个叛数数据

11:50.920 --> 11:51.920
当然我们刚才说

11:51.920 --> 11:53.400
判断两个数据是不是相等

11:53.400 --> 11:54.360
如果是对象

11:54.360 --> 11:55.960
对象里你得用什么

11:55.960 --> 11:56.760
判断地址

11:56.760 --> 11:57.000
对吧

11:57.000 --> 11:58.520
因为B对象判断两个相等

11:58.520 --> 11:59.080
是不是相等

11:59.080 --> 12:00.360
OBG是意识判断的是

12:00.360 --> 12:03.680
对象的引用地址是不是一样的

12:03.680 --> 12:06.600
还是它这个数据是判断

12:06.600 --> 12:08.440
判断设计中

12:08.480 --> 12:12.400
是否存在对应的数据

12:12.400 --> 12:13.800
判断的方式

12:13.800 --> 12:14.720
判断的对应

12:14.720 --> 12:16.360
是不是有对应数据的方式

12:16.360 --> 12:18.880
跟这个地方方式一样

12:18.880 --> 12:20.800
也是用OBG的意识来判断

12:20.800 --> 12:22.000
判断两个数据是不是相等

12:22.000 --> 12:22.600
如果相等的话

12:22.600 --> 12:23.840
就表示有这个数据

12:25.080 --> 12:25.880
既然我们来输出

12:25.880 --> 12:26.840
我们就要看这里看一下

12:28.360 --> 12:29.640
SE-HAS

12:29.640 --> 12:31.120
比方说我们这里写一个什么

12:31.120 --> 12:32.360
写一个3

12:32.360 --> 12:33.440
说返回去

12:33.440 --> 12:34.600
写一个5

12:34.600 --> 12:35.600
是返回force

12:35.600 --> 12:35.960
对吧

12:35.960 --> 12:36.880
就这么简单

12:36.880 --> 12:37.960
HAS

12:38.000 --> 12:38.640
有没有

12:39.480 --> 12:40.640
就是这个函数

12:40.640 --> 12:41.880
再来下一个

12:41.880 --> 12:43.680
下一个叫做DINNET

12:44.560 --> 12:45.440
这里面填什么

12:45.440 --> 12:46.000
填数据

12:46.000 --> 12:46.840
不是下标

12:46.840 --> 12:47.760
不是下标

12:47.760 --> 12:50.040
我们以后再说一个下标的问题

12:50.040 --> 12:51.640
DINNET这里填数据

12:51.640 --> 12:55.240
它是删除匹配的数据

12:55.240 --> 12:56.440
那么它怎么来匹配的

12:56.440 --> 12:57.840
还是用这种方式

12:57.840 --> 12:59.600
还是用这种方式

12:59.600 --> 13:00.320
这个方式

13:00.320 --> 13:01.240
反正我们后边

13:01.240 --> 13:02.120
判断两个数据

13:02.120 --> 13:02.680
是不是相等

13:02.680 --> 13:04.240
都是用的这种方式来判断的

13:04.240 --> 13:04.720
在SE-HAS里面

13:04.720 --> 13:06.200
都是用这种方式来判断的

13:06.200 --> 13:06.800
来吧

13:06.800 --> 13:07.840
我们来看一下

13:08.520 --> 13:11.560
如果说我们来调用DINNET

13:11.560 --> 13:14.080
比方说我们这里传入一个3

13:14.080 --> 13:15.280
那么它返回一个2

13:15.280 --> 13:16.040
返回的是什么呢

13:16.040 --> 13:17.720
它返回的结果

13:17.720 --> 13:21.360
返回是否删除成功

13:21.360 --> 13:23.160
返回是否删除成功

13:23.160 --> 13:24.760
比方说我们这里删除一个3

13:24.760 --> 13:25.960
2表示删除成功了

13:25.960 --> 13:27.520
我们再看一下SE

13:27.520 --> 13:28.720
是不是删就没了

13:28.720 --> 13:28.960
对吧

13:28.960 --> 13:29.400
删就没了

13:29.400 --> 13:30.400
就那么简单

13:30.400 --> 13:33.200
如果说你这DINNET

13:33.200 --> 13:34.360
随便写个数字

13:34.360 --> 13:35.360
它返回的就是force

13:35.360 --> 13:37.120
表示没有删除成功

13:37.120 --> 13:39.160
就DINNET的方法

13:39.160 --> 13:39.520
没问题吧

13:39.520 --> 13:40.800
都很简单

13:40.800 --> 13:43.360
然后下面这个clear

13:43.360 --> 13:45.640
clear没有参数

13:45.640 --> 13:49.280
它是清空整个set集合

13:49.280 --> 13:51.000
清空整个set集合

13:51.000 --> 13:51.760
看一下吧

13:51.760 --> 13:53.280
如果说我们在这里调用clear

13:53.280 --> 13:54.800
这方法都非常简单

13:54.800 --> 13:56.400
那么看一下SE

13:56.400 --> 13:57.160
是不是就没了

13:57.160 --> 13:59.040
所有的数据都没了

13:59.040 --> 14:00.040
这就是set集合

14:01.360 --> 14:02.200
没问题吧

14:02.200 --> 14:06.200
这是如何对set集合进行后续操作

14:07.680 --> 14:10.800
那么这是对set集合的后续操作

14:12.040 --> 14:13.320
好 今天我们再来看

14:13.320 --> 14:14.600
因为有的时候

14:14.600 --> 14:17.160
我们可能数据来自于数组

14:17.160 --> 14:20.040
我们希望通过set集合来处理一下

14:20.040 --> 14:22.720
然后又把它还原成数组

14:22.720 --> 14:24.920
那么这种情况下该怎么来操作呢

14:24.920 --> 14:25.640
咱们来看

14:27.080 --> 14:30.040
如何和与数组之间

14:30.040 --> 14:33.640
数组进行相互转换

14:33.640 --> 14:34.680
这个东西其实很简单

14:34.680 --> 14:35.880
我们之前说过了

14:35.880 --> 14:37.960
数组要转换成set

14:37.960 --> 14:38.920
其实非常简单的

14:38.920 --> 14:40.600
比方说我们这里有个数组

14:40.600 --> 14:42.880
你要把它转换成set

14:44.720 --> 14:46.320
另外一个set

14:46.320 --> 14:48.440
那么这里是不是把数组传进来就完事了

14:48.440 --> 14:48.840
对吧

14:48.840 --> 14:52.080
把数组传进来就完事了

14:52.080 --> 14:52.400
对吧

14:52.400 --> 14:53.520
这就特别简单

14:53.520 --> 14:55.120
因为数组是个可谍在对象

14:55.120 --> 14:56.920
所以说可以把它传到构造函数里面

14:56.920 --> 14:57.920
因为由于

14:57.920 --> 14:58.600
这样子已经来了

14:58.600 --> 15:00.600
数组里面每一项是把把它谍代出来

15:00.600 --> 15:01.520
帮到set里面

15:01.520 --> 15:02.400
对吧

15:02.400 --> 15:03.720
那么这就完事了

15:03.760 --> 15:05.000
非常简单

15:05.000 --> 15:07.880
那么set如何来转换成数组呢

15:07.880 --> 15:09.000
你要把set

15:09.000 --> 15:10.000
这是个set对象

15:10.000 --> 15:11.920
你要把它转换成数组怎么来转换呢

15:11.920 --> 15:13.400
其实也非常简单

15:13.400 --> 15:17.160
因为set它本身是一个可谍在对象

15:17.160 --> 15:22.480
set本身也是一个可谍在对象

15:22.480 --> 15:24.200
谍在对象

15:24.200 --> 15:26.440
所以每一次谍代

15:26.440 --> 15:29.120
每次谍代的结果

15:29.120 --> 15:32.560
就是每一项的值

15:32.560 --> 15:36.800
因此我们可以用这种方式来转换成数组

15:36.800 --> 15:38.200
是不是可以用这种方式

15:38.200 --> 15:38.920
对吧

15:38.920 --> 15:41.880
用这种方式可以转换成数组了

15:41.880 --> 15:43.240
因此在这个地方

15:43.240 --> 15:45.440
有一道有一个不是面试题

15:45.440 --> 15:47.160
有一个非常巧妙的方式

15:47.160 --> 15:50.040
就是说数组去从得到一个新的

15:50.040 --> 15:52.800
去除重复之后的数组

15:52.800 --> 15:53.680
那么这种方式

15:53.680 --> 15:54.440
你来怎么来做

15:54.440 --> 15:57.100
我们来看一下吧

15:57.100 --> 16:01.100
比方说咱们这里有个数组

16:01.100 --> 16:03.500
这里有个数组ARR

16:03.500 --> 16:04.860
这个数组里边有一些数据

16:05.700 --> 16:06.980
它有一些重复的数据

16:06.980 --> 16:09.300
可能数据量比较大

16:09.300 --> 16:11.180
数据量非常非常大

16:11.180 --> 16:14.140
但是可能会重复这里边的数据

16:14.140 --> 16:15.820
总之有这么一个数据

16:15.820 --> 16:18.540
那么我们希望对这个数据进行去从

16:18.540 --> 16:20.980
去从之后得到一个新的数据

16:20.980 --> 16:22.180
那么这个东西怎么来做呢

16:22.180 --> 16:23.220
你看我们可以这样做

16:23.220 --> 16:24.300
这样子写

16:24.300 --> 16:26.100
首先留一个set

16:26.100 --> 16:28.140
因为set里边是不允许有重复的

16:28.140 --> 16:29.540
把数据一放进去

16:29.540 --> 16:31.500
那么这样子得到的这个set集合里边

16:31.500 --> 16:32.540
是一定没有重复的

16:33.220 --> 16:35.140
set集合里面不可能有重复的

16:35.140 --> 16:37.060
那么这是得到一个set集合

16:37.060 --> 16:38.620
那么我可以用个变量保存起来

16:38.620 --> 16:39.820
比方说s

16:39.820 --> 16:42.220
然后我们得到一个新的数据

16:42.220 --> 16:43.340
新的数据是什么呢

16:43.340 --> 16:46.660
就是把这个set集合又转换成数据

16:46.660 --> 16:48.540
数据

16:48.540 --> 16:49.220
保存

16:49.220 --> 16:50.660
因为我们知道展开运算幅

16:50.660 --> 16:53.380
是可以展开那些可谍在对象的

16:53.380 --> 16:54.980
那么

16:56.300 --> 16:57.380
我输出s干嘛

16:57.380 --> 16:59.220
去输 result

16:59.220 --> 17:00.420
你看是不是变成数据了

17:00.420 --> 17:01.820
而且个数据里边是没有重复的

17:03.180 --> 17:04.140
而且这个单码呢

17:04.140 --> 17:05.460
你还可以进一步减化

17:05.460 --> 17:06.620
比如把这句话

17:06.620 --> 17:07.700
这是个表达式吗

17:07.700 --> 17:08.380
直接放这

17:08.380 --> 17:09.020
可不可以

17:09.020 --> 17:10.260
当然也可以

17:10.260 --> 17:11.540
直接放了就可以了

17:11.540 --> 17:12.820
为什么直接放了就可以了

17:12.820 --> 17:14.020
因为把这个表达式

17:14.020 --> 17:15.740
这个表达式不是得到一个set对象吗

17:15.740 --> 17:16.260
对吧

17:16.260 --> 17:17.780
没有必要用变量保存了

17:17.780 --> 17:19.380
直接把这个对象直接展开

17:19.380 --> 17:20.620
因为它是个可谍在对象

17:20.620 --> 17:22.100
那么就变成一个数据了

17:22.100 --> 17:22.940
就这么简单

17:22.940 --> 17:24.660
这是个非常非常简洁的

17:24.660 --> 17:26.700
数据去从的办法

17:26.700 --> 17:27.620
对吧

17:27.620 --> 17:28.900
以前的咱们数据去从

17:28.900 --> 17:31.020
是不是还在诚哥讲的

17:31.020 --> 17:33.620
我们诚哥在基础课程里面讲了数据去从

17:33.620 --> 17:35.340
因为以前没有学习set什么

17:35.340 --> 17:37.180
所以他还在用什么辅助对象

17:37.180 --> 17:38.180
对不对

17:38.180 --> 17:39.340
那么特别麻烦

17:39.340 --> 17:41.460
而且对象的属性明了

17:41.460 --> 17:43.340
因为他只能存放字不错

17:43.340 --> 17:44.260
他不能空

17:44.260 --> 17:45.380
他不能存放对象

17:45.380 --> 17:47.660
所以说也会导致一些缺陷

17:47.660 --> 17:49.180
但是set就没有这样的各种

17:49.180 --> 17:50.340
没有这些问题了

17:50.340 --> 17:51.540
就没有这些问题了

17:51.540 --> 17:53.180
这是数据去从

17:54.780 --> 17:56.260
这是关于这个问题

17:57.260 --> 17:58.380
那有时候来说

17:58.380 --> 17:59.780
那如果字不错的去从

17:59.780 --> 18:00.700
我们就顺便说一下

18:00.700 --> 18:01.380
字不错的去从

18:02.380 --> 18:02.980
字不错

18:02.980 --> 18:03.900
STR

18:03.900 --> 18:05.460
我们这里边有个字不错

18:05.460 --> 18:06.820
这里边有乱七八糟的字符

18:06.820 --> 18:07.860
有很多重复的

18:07.860 --> 18:10.380
我们希望对一个字不错里面的字符去从

18:10.380 --> 18:11.500
那怎么办呢

18:11.500 --> 18:13.380
你看还是可以用set

18:13.380 --> 18:15.180
首先我们得到一个set

18:15.180 --> 18:16.740
6一个set

18:16.740 --> 18:17.700
把字不错传进去

18:17.700 --> 18:19.140
因为字不错是不可以迭代的

18:19.140 --> 18:19.540
对吧

18:19.540 --> 18:20.540
那么它迭代之后

18:20.540 --> 18:22.900
那么这个形成的set集合里边

18:22.900 --> 18:25.060
是不是就没有重复向了

18:25.060 --> 18:25.460
对吧

18:25.540 --> 18:27.420
来输出一下s

18:27.420 --> 18:28.700
你看一下吧

18:28.700 --> 18:29.220
输出了s

18:29.220 --> 18:31.380
你看是不是没有重复向了

18:31.380 --> 18:32.060
有这么一些

18:32.060 --> 18:32.260
对吧

18:32.260 --> 18:34.300
没有重复向了

18:34.300 --> 18:36.220
那么没有重复向了之后

18:36.220 --> 18:37.500
我们再把这个玩意

18:37.500 --> 18:39.180
是不是又可以转换成数组

18:39.180 --> 18:40.180
我们刚才说了

18:40.180 --> 18:41.860
把这个玩意是不是可以转换成数组

18:44.100 --> 18:45.940
咱们这样子写

18:45.940 --> 18:48.060
把这个set里边的东西是不是转换成数组

18:48.060 --> 18:48.700
你看

18:48.700 --> 18:50.380
这样几转化跟上面一样

18:50.380 --> 18:52.060
这样转换是不是形成了个数组了

18:52.060 --> 18:52.820
对吧

18:52.820 --> 18:53.940
然后再干嘛

18:53.940 --> 18:55.820
再把这个数组去调用什么

18:55.820 --> 18:56.660
交引

18:56.660 --> 18:57.260
对不对

18:57.260 --> 18:58.020
是不是调用交引

18:59.740 --> 19:01.500
调用这个交引里边拼接服

19:01.500 --> 19:03.140
用空字不错的拼接

19:03.140 --> 19:03.940
你看一下

19:03.940 --> 19:06.380
所以变成字不错去从了

19:06.380 --> 19:07.420
特别简单

19:07.420 --> 19:08.860
好好看一下这个代码

19:08.860 --> 19:09.620
先把它变成数组

19:09.620 --> 19:10.900
然后来就交引一下

19:10.900 --> 19:12.740
把它变成字不错

19:12.740 --> 19:14.180
这也是字不错去从

19:14.180 --> 19:16.100
现在一句话就写完了

19:16.100 --> 19:17.740
这是关于这个

19:17.740 --> 19:20.060
如何与数组之间进行相互转换

19:22.860 --> 19:23.900
下一个问题

19:23.980 --> 19:25.180
就是如何变利

19:25.700 --> 19:27.220
如何变利

19:27.220 --> 19:28.060
那么这个变利

19:28.060 --> 19:29.220
我们刚才其实说了

19:29.220 --> 19:31.260
set它本身是一个可叠带对象

19:31.260 --> 19:33.900
因此你是不是可以用for2无循环来进行变利

19:33.900 --> 19:34.660
对吧

19:34.660 --> 19:36.380
第一种方式

19:36.380 --> 19:39.380
使用for2无循环

19:39.380 --> 19:42.460
使用for2无循环

19:42.460 --> 19:43.820
因为它本身是可叠带对象

19:43.820 --> 19:45.380
因此它变利起来非常简单

19:45.380 --> 19:45.580
好

19:45.580 --> 19:46.260
咱们来看一下

19:46.260 --> 19:47.580
比方这里吧

19:47.580 --> 19:48.860
这里

19:48.860 --> 19:50.020
我们这里要变利它的话

19:50.020 --> 19:50.980
变利这个set的话

19:50.980 --> 19:51.260
OK

19:51.260 --> 19:53.300
我们可以使用for2无循环

19:53.380 --> 19:55.060
那么这里每循环一次

19:55.060 --> 19:55.900
s1

19:55.900 --> 19:57.180
那么输出item

19:57.180 --> 19:57.780
你看一下吧

19:59.100 --> 19:59.900
这边

19:59.900 --> 20:01.340
你是不是变利出来了

20:01.340 --> 20:02.260
1230

20:02.260 --> 20:02.620
对吧

20:02.620 --> 20:03.780
1230

20:03.780 --> 20:04.060
好

20:04.060 --> 20:05.140
这是第一种方式

20:05.140 --> 20:06.380
第二种变利方式

20:06.380 --> 20:10.460
我们可以使用它里面提供了一个方法

20:10.460 --> 20:15.900
使用set中的实力方法for1

20:15.900 --> 20:17.220
for1

20:17.220 --> 20:19.300
那么这个方法跟数组差不多

20:19.300 --> 20:20.260
跟数组差不多

20:20.260 --> 20:20.980
我们来看一下吧

20:22.180 --> 20:23.060
s1

20:23.100 --> 20:24.700
s1 for each

20:24.700 --> 20:26.820
那么这里是不是要切个毁掉函数

20:26.820 --> 20:28.620
它会把每一项拿出来给力

20:28.620 --> 20:28.860
OK

20:28.860 --> 20:30.740
我们这里输出每一项就完手了

20:30.740 --> 20:32.460
这也是一种变利方式

20:32.460 --> 20:32.660
好

20:32.660 --> 20:33.180
保存

20:33.180 --> 20:34.020
咱们看一下

20:34.020 --> 20:35.900
是不是还是可以输出1230

20:35.900 --> 20:37.060
对不对

20:37.060 --> 20:37.900
但是for each

20:37.900 --> 20:38.580
大家要注意

20:38.580 --> 20:40.060
因为我们数组里边for each

20:40.060 --> 20:41.460
是不是有三个参数

20:41.460 --> 20:42.660
第一个参数是啥

20:42.660 --> 20:44.220
是每一项的值

20:44.220 --> 20:45.420
第二个参数是啥

20:45.420 --> 20:46.780
是不是下标

20:46.780 --> 20:48.180
第三个参数是啥

20:48.180 --> 20:49.940
是不是整个数组对象

20:49.940 --> 20:52.220
那么这里就相当于是set对象

20:52.260 --> 20:53.380
相当于是set对象

20:53.380 --> 20:54.900
那么这里我们把三个输出

20:54.900 --> 20:55.620
大家看一下

20:55.620 --> 20:58.020
这个地方是有差别的

20:58.020 --> 20:58.500
保存

20:58.500 --> 21:00.100
你看一下

21:00.100 --> 21:01.380
第三个参数没问题

21:01.380 --> 21:03.420
第三个参数是不是都是set对象

21:03.420 --> 21:03.980
对吧

21:03.980 --> 21:06.940
输出里边的第三个参数就是输出对象

21:06.940 --> 21:08.140
第三个参数是set对象

21:08.140 --> 21:09.060
这个没问题

21:09.060 --> 21:10.460
第一个参数是每一项的值

21:10.460 --> 21:11.100
没问题

21:11.100 --> 21:12.700
关键是在第二个参数

21:12.700 --> 21:13.580
第二个参数

21:13.580 --> 21:15.420
你看一下是不是下标

21:15.420 --> 21:16.700
它不是下标

21:16.700 --> 21:17.900
它不是下标

21:17.900 --> 21:19.740
为什么不是下标呢

21:19.740 --> 21:25.340
是因为注意

21:25.340 --> 21:29.180
set集合中不存在下标

21:29.180 --> 21:31.860
因为下标是输组特有的东西

21:31.860 --> 21:33.980
不要认为是集合特有的东西

21:33.980 --> 21:36.340
没有任何人说集合必须要有下标

21:36.340 --> 21:38.540
那不是没有这种说法

21:38.540 --> 21:41.380
下标是输组里边搞出来的东西

21:41.380 --> 21:43.020
那你看对象也是集合

21:43.020 --> 21:43.660
对不对

21:43.660 --> 21:45.060
对象它里边可以存多个数据

21:45.060 --> 21:46.660
对象有下标吗

21:46.660 --> 21:47.300
没有吧

21:47.300 --> 21:47.780
对不对

21:47.780 --> 21:48.860
输组它有下标

21:48.860 --> 21:49.940
是因为输组里边

21:49.940 --> 21:51.340
它的特殊处理方式

21:51.380 --> 21:52.420
它可以用那个下标

21:52.420 --> 21:55.460
用一个数字来作为属性铭

21:55.460 --> 21:55.980
对吧

21:55.980 --> 21:56.820
它是用这种方式

21:56.820 --> 21:59.300
但set它已经不是数据的那种方式了

21:59.300 --> 22:01.100
所以它没有不存在下标的

22:01.100 --> 22:03.060
因此在set集合中

22:03.060 --> 22:05.100
你是不可能去获取下标的

22:05.100 --> 22:05.940
自然而难

22:05.940 --> 22:07.620
你也不可能用 for 循环

22:07.620 --> 22:08.700
普通的for 循环

22:08.700 --> 22:09.900
去循环它的下标

22:09.900 --> 22:11.380
这也不现实的

22:11.380 --> 22:12.980
如果说你一定要用下标的话

22:12.980 --> 22:14.180
你把它转换成数据

22:14.180 --> 22:15.140
都可以再去用

22:15.140 --> 22:16.500
转换数据很简单

22:16.500 --> 22:17.180
对吧

22:17.180 --> 22:18.820
大家注意一下这一点

22:18.820 --> 22:19.780
所以说第二个参数

22:19.860 --> 22:21.300
由于它不存在下标

22:21.300 --> 22:24.420
它又为了保持这个for一起的格式统一

22:25.060 --> 22:26.500
为什么它要保持格式统一呢

22:26.500 --> 22:28.020
因为有可能你会写一些

22:28.020 --> 22:29.700
通用的for一起回调函数

22:29.700 --> 22:31.420
比方说把这个东西抽离成一个函数

22:31.420 --> 22:33.220
它可以适应数组

22:33.220 --> 22:34.220
也可以适用set

22:34.220 --> 22:35.860
适应任何其他集合

22:35.860 --> 22:38.020
所以它为了保持通用性

22:38.020 --> 22:39.820
因此在这个地方

22:39.820 --> 22:41.260
仍然给你提供了三个参数

22:41.260 --> 22:42.380
只不过第二个参数

22:42.380 --> 22:44.300
跟第一个参数是一样的

22:44.300 --> 22:45.860
都表示数组相的值

22:45.860 --> 22:47.580
都表示集合的每一项

22:48.580 --> 22:51.500
因此for一起

22:51.500 --> 22:55.500
终的回调的第二个参数

22:55.500 --> 22:59.940
和第一个参数是一致的

22:59.940 --> 23:05.100
均表示set终的每一项

23:05.100 --> 23:05.740
所以这个地方

23:05.740 --> 23:07.700
小地方大家注意一下就行了

23:07.700 --> 23:08.220
好吧

23:08.220 --> 23:08.780
OK

23:08.780 --> 23:10.380
这就是set集合

23:10.380 --> 23:11.900
还有什么没啥了

23:11.900 --> 23:13.100
特别简单

23:13.100 --> 23:13.860
这是set集合

