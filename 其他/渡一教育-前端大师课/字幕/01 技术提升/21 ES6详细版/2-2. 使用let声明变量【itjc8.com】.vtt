WEBVTT

00:00.820 --> 00:04.940
咱们上一期课呢 讲了就是用传统的方式

00:04.940 --> 00:07.220
也就是用var的那种方式 声明辨量呢

00:07.220 --> 00:08.940
它会导致三个问题对吧

00:08.940 --> 00:12.980
那么这三个问题呢 在ES6里边都已经非常非常好的

00:12.980 --> 00:14.140
把它解决了

00:14.140 --> 00:16.580
那么ES6里边怎么来解决这个问题呢

00:16.580 --> 00:17.980
这是我们这一颗要说的

00:17.980 --> 00:21.820
在ES6里边呢 它引入了一个关键字叫做net

00:21.820 --> 00:25.180
它并且呢建议你呢 声明辨量

00:25.180 --> 00:27.660
不再使用var来进行声明

00:27.660 --> 00:31.300
而转而去使用net来声明辨量

00:31.300 --> 00:34.300
就以前呢 咱们要写这个var 然后一个辨量名对吧

00:34.300 --> 00:37.540
那么现在只需要把这个var 变成net

00:37.540 --> 00:41.220
就可以非常好的来解决这三个问题了

00:41.220 --> 00:42.820
好 咱们一个一个看

00:42.820 --> 00:44.780
首先 咱们看第一个问题

00:44.780 --> 00:47.140
就是我们之前说了个var 它

00:47.140 --> 00:49.740
它容易挂载到权局对象上面

00:49.740 --> 00:52.940
造成了权局对象上面的成员的污染

00:52.940 --> 00:54.060
那么我们现在看一下

00:54.060 --> 00:57.060
我们页面中引入了一个介石 介石里面的东西

00:57.100 --> 00:58.740
那么接下来 我们来看一下

00:58.740 --> 01:02.940
如果说我们使用net的关键字来声明辨量

01:02.940 --> 01:04.660
并且复制的话 我们来看一下

01:06.540 --> 01:08.660
a等于123 随便写一个

01:08.660 --> 01:13.060
然后我们这里输出一下window.a

01:13.060 --> 01:16.260
看一下有没有污染权局辨量呢

01:16.260 --> 01:21.100
运行出来 看一下在空谈

01:21.100 --> 01:23.180
你看一下 是不是输出undefend

01:23.180 --> 01:24.220
也就是说啥呢

01:24.220 --> 01:27.900
也就是说window里边有没有这个a这个辨量呢

01:27.940 --> 01:30.860
这个成员是不是没有 就这么简单

01:30.860 --> 01:32.700
就是关于这一块的话

01:32.700 --> 01:34.420
仅仅是这么一个改动

01:34.420 --> 01:37.980
也都没有任何理由不去使用net

01:37.980 --> 01:39.740
因为它不会污染权局辨量

01:39.740 --> 01:41.060
你看以前我们咋写

01:41.060 --> 01:43.060
以前要避免污染权局辨量

01:43.060 --> 01:44.740
是不是得写个立即执行函数

01:44.740 --> 01:46.180
把这一辩量放到函数里边

01:46.180 --> 01:47.940
现在不用了 你直接来就行了

01:47.940 --> 01:49.660
它不会污染权局辨量的

01:49.660 --> 01:50.660
这是关于这一个点

01:52.220 --> 01:54.300
好 另外一个 下一个问题

01:54.300 --> 01:56.260
就是之前说那个var的声明

01:56.260 --> 01:59.140
它是允许重复的辨量声明

01:59.140 --> 02:01.340
就导致了很怪异的问题

02:01.340 --> 02:03.260
导致了数据被覆盖

02:03.260 --> 02:05.220
导致了数据被覆盖

02:05.220 --> 02:07.500
那么使用net的话就不会了

02:07.500 --> 02:08.700
我们来看一下

02:09.780 --> 02:11.380
这么还是记彼吧

02:11.380 --> 02:15.020
net声明的辨量

02:15.020 --> 02:19.140
不会挂载到权局对象

02:19.140 --> 02:20.340
这是关于这个

02:20.340 --> 02:22.540
另外一个 下一个就是

02:22.580 --> 02:28.180
net声明的辨量

02:28.180 --> 02:38.900
不允许在当前作用预范围内重复声明

02:40.500 --> 02:41.300
不允许

02:41.300 --> 02:42.780
应该这样说

02:42.780 --> 02:43.780
不允许当前作用

02:43.780 --> 02:44.780
对了 没问题

02:44.780 --> 02:48.420
不允许当前作用预范围内重复声明

02:48.420 --> 02:49.100
啥意思呢

02:49.100 --> 02:50.900
好 我们先看一个简单的例子

02:51.900 --> 02:52.700
看这

02:53.700 --> 02:57.300
比方说我们这里设置一个neta等于123

02:57.300 --> 03:00.100
然后再设置一个neta等于456

03:01.500 --> 03:02.420
它一定会爆错

03:02.420 --> 03:03.460
我们来看一下爆错了

03:03.460 --> 03:04.620
对吧 爆错了

03:04.620 --> 03:06.580
那么它爆出来哪一句话呢

03:06.580 --> 03:08.140
它爆出在第二句话

03:08.140 --> 03:09.300
第八行这一句

03:09.300 --> 03:10.580
你看 它这里告诉你

03:10.580 --> 03:11.940
第八行出了问题

03:11.940 --> 03:13.620
你看 是不是这句话出了问题

03:13.620 --> 03:16.900
因为当它用net来声明一个辨量的时候

03:16.900 --> 03:18.580
它一定会检查

03:18.580 --> 03:20.300
在当前这个作用预

03:20.300 --> 03:21.620
当前是不是全局作用预

03:21.620 --> 03:22.140
对吧

03:22.140 --> 03:24.020
在当前这个作用预范围内

03:24.020 --> 03:27.300
有没有声明过这个辨量

03:27.300 --> 03:28.620
如果说已经声明过了

03:28.620 --> 03:29.420
它一定会爆错

03:29.420 --> 03:30.380
不允许重新声明

03:30.380 --> 03:32.460
有这句话会爆错

03:32.460 --> 03:34.060
检查到

03:34.060 --> 03:35.580
当前作用预

03:35.580 --> 03:37.500
也是全局作用预

03:37.500 --> 03:40.580
全局作用预

03:40.580 --> 03:45.100
以声明了辨量

03:45.100 --> 03:47.500
所以说这个时候它会爆错

03:47.500 --> 03:50.620
它不允许这里重复声明

03:50.620 --> 03:53.580
那如果说不是同一个作用预

03:53.580 --> 03:54.220
可不可以呢

03:54.220 --> 03:56.380
不是同一个作用预就可以

03:56.380 --> 03:57.740
你看

03:57.740 --> 03:59.900
它不允许当前作用预的重复声明

03:59.900 --> 04:01.220
但它没有说

04:01.220 --> 04:03.460
不同的作用预里面能不能重复声明

04:03.460 --> 04:05.260
比方说举个例子

04:05.260 --> 04:08.240
我们把这个注释掉

04:08.240 --> 04:10.240
这里有个全局作用预

04:10.240 --> 04:11.240
全局作用预里面

04:11.240 --> 04:12.200
一二三

04:12.200 --> 04:14.080
然后下面有个函数

04:14.080 --> 04:16.120
这个函数test

04:16.120 --> 04:18.800
它里面又有定一个辨量

04:18.920 --> 04:19.640
这里是什么

04:19.640 --> 04:21.000
456吧

04:21.000 --> 04:22.160
输出

04:22.160 --> 04:24.280
我们这里运行函数

04:24.280 --> 04:25.480
保存

04:25.480 --> 04:26.200
你看一下

04:26.200 --> 04:27.960
那现在就没问题

04:27.960 --> 04:28.920
为它现在没问题

04:28.920 --> 04:31.240
这个道理其实很容易理解

04:31.240 --> 04:33.240
因为你在函数里面定义的辨量

04:33.240 --> 04:34.160
你要用的时候

04:34.160 --> 04:36.400
是不是用在函数里面的

04:36.400 --> 04:37.480
你看这里用的

04:37.480 --> 04:39.320
是不是用在函数里面的作用预

04:39.320 --> 04:42.000
我们之前讲作用预粘

04:42.000 --> 04:44.000
它一定是从究竟原则

04:44.000 --> 04:46.320
从究竟的作用预出发

04:46.320 --> 04:48.440
然后一次往外层去找

04:48.480 --> 04:50.080
那么这个作用预翻蚊不一样

04:50.080 --> 04:52.240
那么自然可以有重复

04:52.240 --> 04:53.400
没有任何问题

04:53.400 --> 04:54.760
没有任何问题

04:54.760 --> 04:55.720
但是我说的是

04:55.720 --> 04:57.400
同一个作用预里边

04:57.400 --> 04:58.880
是不允许重复生命的

04:58.880 --> 05:00.120
那以前在VAR

05:00.120 --> 05:01.560
用VAR关键字生命辨量

05:01.560 --> 05:02.680
是不是同一个作用预

05:02.680 --> 05:03.880
它也可以重复

05:03.880 --> 05:05.000
这样子不好

05:05.000 --> 05:06.880
所以说它这里用net之后

05:06.880 --> 05:08.440
你在同一个作用预勒里边

05:08.440 --> 05:10.800
是不能重复生命的

05:10.800 --> 05:11.920
而且呢

05:11.920 --> 05:13.640
EAS6它不仅

05:13.640 --> 05:14.880
仅为了解决这个问题

05:14.880 --> 05:16.880
它不仅仅引入了net

05:16.920 --> 05:18.600
并且还做了这么一件事

05:19.960 --> 05:27.880
EAS6不仅引入net关键字

05:27.880 --> 05:34.640
用于解决辨量生命的问题

05:34.640 --> 05:44.560
同时引入了quarty作用预概念

05:44.560 --> 05:44.960
好

05:44.960 --> 05:48.080
什么就是以前我们的作用预

05:48.080 --> 05:49.400
是不是只有两种

05:49.400 --> 05:51.520
一种就是全局作用预

05:51.520 --> 05:53.600
一种是函数作用预

05:53.600 --> 05:54.280
对吧

05:54.280 --> 05:56.560
那么现在多了一种作用预

05:56.560 --> 05:58.440
叫做quarty作用预

05:58.440 --> 06:00.240
quarty作用预是什么东西呢

06:00.240 --> 06:01.800
我们这里再说一下

06:01.800 --> 06:03.720
什么叫quarty作用预

06:03.720 --> 06:05.000
作用预

06:05.000 --> 06:08.840
就是代码执行时

06:08.840 --> 06:10.760
遇到大扩号

06:11.760 --> 06:21.710
quarty会创建一个quarty作用预

06:21.710 --> 06:22.870
quarty结束

06:24.630 --> 06:26.310
结束

06:26.310 --> 06:28.550
quarty销毁

06:28.550 --> 06:31.590
quarty作用预

06:31.590 --> 06:33.550
也他多了一种作用预了

06:33.550 --> 06:35.870
那么就是quarty来创建的是

06:35.870 --> 06:36.670
quarty作用预

06:36.670 --> 06:37.590
那么quarty结束

06:37.590 --> 06:38.830
quarty作用预销毁

06:38.830 --> 06:40.990
比方说举个例子

06:41.030 --> 06:42.150
又来

06:42.150 --> 06:43.430
这个就是杜斯尼

06:44.630 --> 06:45.550
你看一下

06:45.550 --> 06:46.470
我们如果说他还嘛

06:46.470 --> 06:47.950
这样子写

06:47.950 --> 06:48.630
net

06:48.630 --> 06:50.150
A等于1 2他

06:50.150 --> 06:51.950
下面我直接写个划货号

06:51.950 --> 06:53.830
以前我这种东西表示对象

06:53.830 --> 06:55.390
那么现在的划货号

06:55.390 --> 06:56.470
还有别的意思

06:56.470 --> 06:58.430
他表示的是一块作用预

06:58.430 --> 06:59.590
如果说你直接这样写

06:59.590 --> 07:00.590
输写划货号的话

07:00.590 --> 07:01.310
他表示的是

07:01.310 --> 07:03.950
就是一个你创建了一个快级作用预

07:03.950 --> 07:05.070
比方我们这里写个net

07:05.070 --> 07:05.750
A456

07:05.750 --> 07:07.350
你看一下会不会爆错

07:07.350 --> 07:08.430
输出A

07:08.630 --> 07:11.150
这里边也输出A

07:11.150 --> 07:11.510
好

07:11.510 --> 07:12.350
咱们来看一下

07:13.190 --> 07:14.350
首先他没有爆错

07:14.350 --> 07:16.110
并且正确的输出了结果

07:16.110 --> 07:16.830
那他怎么回事

07:16.830 --> 07:18.110
这个地方

07:18.110 --> 07:21.990
它是全局作用预中定义了A

07:21.990 --> 07:22.790
对吧

07:22.790 --> 07:24.430
那么这里为什么没有爆错

07:24.430 --> 07:26.110
是因为这里的作用预

07:26.110 --> 07:27.390
是不是全局作用预

07:27.390 --> 07:28.030
不是

07:28.030 --> 07:32.870
这是一个quarty作用预定义A

07:32.870 --> 07:34.590
所以说两个不冲突

07:34.590 --> 07:35.710
两个不冲突

07:35.710 --> 07:36.510
你要的意思

07:36.510 --> 07:38.190
两个是不冲突的

07:38.350 --> 07:40.910
那么这个是quarty作用预定的A

07:40.910 --> 07:41.710
那么这里

07:41.710 --> 07:43.710
由于他作用预是全局作用预

07:43.710 --> 07:44.990
下边的quarty作用预

07:44.990 --> 07:45.750
里边代码

07:45.750 --> 07:46.830
所以说他用的是什么

07:46.830 --> 07:48.630
用的自然是究竟原则

07:48.630 --> 07:49.190
对吧

07:49.190 --> 07:50.950
作用预念究竟原则

07:50.950 --> 07:56.790
使用的是quarty作用预中的A

07:56.790 --> 07:58.550
并且quarty作用预

07:58.550 --> 07:59.870
它执行完了之后

07:59.870 --> 08:01.430
它会立即销毁

08:01.430 --> 08:02.990
因此在quarty作用预中

08:02.990 --> 08:04.870
用net来定义的辩量

08:04.870 --> 08:08.990
在quarty作用预中

08:08.990 --> 08:13.070
quarty作用预中

08:13.070 --> 08:16.950
用net定义的辩量

08:16.950 --> 08:20.350
在作用预外

08:20.350 --> 08:21.710
不能访问

08:21.710 --> 08:23.110
是不能访问的

08:23.110 --> 08:24.750
这个东西是很自然的

08:24.750 --> 08:25.150
对吧

08:25.150 --> 08:25.790
你看

08:25.790 --> 08:27.790
就跟我们平时用的什么

08:27.790 --> 08:28.470
加把语言

08:28.470 --> 08:31.870
拍的就是PGP语言

08:31.870 --> 08:33.110
还有什么cshop语言

08:33.110 --> 08:34.350
是不是就像类似的

08:34.830 --> 08:36.230
那么在这里边定义的东西

08:36.230 --> 08:37.390
只能在这里边使用

08:37.390 --> 08:38.510
外边用不了

08:38.510 --> 08:39.910
用不了

08:39.910 --> 08:41.430
全居中域的东西

08:41.430 --> 08:42.230
在里边

08:42.230 --> 08:43.430
它的内部都可以使用

08:43.430 --> 08:44.310
那么里边的东西

08:44.310 --> 08:45.270
外部也不能用

08:45.270 --> 08:45.950
对吧

08:45.950 --> 08:46.830
就好比说

08:46.830 --> 08:48.230
你家里边的东西

08:48.230 --> 08:49.790
你就是你在住在家里边

08:49.790 --> 08:51.870
是不是可以利用外面的公共资源

08:51.870 --> 08:52.590
对不对

08:52.590 --> 08:53.830
叫个外卖

08:53.830 --> 08:54.070
对吧

08:54.070 --> 08:55.670
这是外面的公共服务资源

08:55.670 --> 08:56.550
是可以用的

08:56.550 --> 08:58.230
外面能不能跑到你家里面

08:58.230 --> 08:59.310
去用你的东西

08:59.310 --> 09:00.030
是不是不能

09:00.030 --> 09:00.550
对吧

09:00.550 --> 09:02.230
外边不能用里边的东西

09:02.230 --> 09:03.870
里边可以用外边的东西

09:04.350 --> 09:06.270
但是由于这里的名字是重复的

09:06.270 --> 09:08.350
它究竟原则用的是里边东西

09:08.350 --> 09:10.590
那如果说这里边的名字是b

09:10.590 --> 09:12.190
那这个a是不是用了外面a

09:12.190 --> 09:12.510
对吧

09:12.510 --> 09:13.150
那输出啥

09:13.150 --> 09:14.630
是不是输出123这里

09:14.630 --> 09:15.950
那这里输出啥

09:15.950 --> 09:16.710
这里呢

09:16.710 --> 09:18.150
输出还是123

09:18.150 --> 09:19.950
两个都是123

09:19.950 --> 09:20.750
你看这个意思

09:20.750 --> 09:21.910
里边不能用外边的

09:21.910 --> 09:22.670
外边的

09:22.670 --> 09:24.310
里边能用外边的

09:24.310 --> 09:25.510
外边不能用里边的

09:25.510 --> 09:26.550
跟那个函数差不多

09:26.550 --> 09:28.110
就多了一个快捷中用域而已

09:29.110 --> 09:30.670
那么同样的

09:30.670 --> 09:32.110
如果说这样子写的话

09:32.110 --> 09:33.670
那么除了这个作用域之外

09:33.710 --> 09:35.350
里边的a是不是不见了

09:35.350 --> 09:35.590
对吧

09:35.590 --> 09:37.110
里边的a是不是不见了

09:37.110 --> 09:37.990
里边的a看不见了

09:37.990 --> 09:38.950
所以说这里的a呢

09:38.950 --> 09:40.150
用的是这里的a

09:40.150 --> 09:41.470
因此里边输出啥

09:41.470 --> 09:42.350
输出456

09:42.350 --> 09:43.430
外边的输出123

09:43.430 --> 09:45.390
这是非常非常自然的一件事

09:45.390 --> 09:48.030
实际上我都没有必要去讲那么细

09:48.030 --> 09:49.510
大家说一下

09:49.510 --> 09:52.350
大家一感觉跟函数差不多

09:52.350 --> 09:53.790
就明白这个意思了

09:53.790 --> 09:54.110
当然了

09:54.110 --> 09:55.230
平时我们写单码

09:55.230 --> 09:58.430
不太会去直接加这个大货号

09:58.430 --> 09:59.990
不太会去直接加这个大货号

09:59.990 --> 10:00.950
但是这个大货号

10:00.950 --> 10:03.150
我们平时写判断的时候

10:03.190 --> 10:04.190
或者是switch

10:04.190 --> 10:05.710
选择的分支的时候

10:05.710 --> 10:06.590
一般会出现

10:06.590 --> 10:07.750
比方说这个道理

10:08.710 --> 10:09.270
看一下

10:09.270 --> 10:10.630
我们看一下这个代码

10:10.630 --> 10:12.030
小于0.5

10:12.470 --> 10:13.550
然后我们这里定

10:13.550 --> 10:15.790
这里用net定一个变量a123

10:16.670 --> 10:18.510
然后我们这里输出a

10:19.030 --> 10:19.830
AOS

10:19.830 --> 10:20.910
这里输出a

10:20.910 --> 10:22.350
这里输出a

10:22.350 --> 10:24.030
我们来问看一下

10:24.030 --> 10:25.710
会有什么样的情况发生

10:26.590 --> 10:27.710
保存

10:28.230 --> 10:28.870
你看

10:29.150 --> 10:31.750
现在输出了123没问题

10:31.830 --> 10:34.310
现在进入了这个判断

10:34.310 --> 10:36.670
然后定义了一个变量123

10:36.670 --> 10:38.790
那么这个变量是哪个作用语定义的

10:38.790 --> 10:40.830
是在这个快捷作用语里边定义的

10:41.590 --> 10:46.510
定义在当前快捷作用语

10:47.310 --> 10:49.270
那么现在这里输出a

10:49.270 --> 10:50.350
是哪里的a

10:50.350 --> 10:54.270
是不是当前快捷作用语中的a

10:54.270 --> 10:54.510
对吧

10:54.510 --> 10:55.430
输出了是这个a

10:55.430 --> 10:56.710
如果说竞争这个判断

10:56.710 --> 10:58.150
它就会有一个变量产生

10:58.550 --> 11:00.070
那么这里会不会有提升

11:00.550 --> 11:01.790
这里就不会有提升了

11:01.790 --> 11:02.430
不会有提升

11:02.430 --> 11:03.990
因为它是在快捷作用语里边的

11:04.870 --> 11:05.030
好

11:05.030 --> 11:05.870
那么你看

11:05.870 --> 11:07.430
如果说你进入了aOS

11:09.590 --> 11:11.310
你看现在就是进入了aOS的情况

11:11.910 --> 11:12.950
这个地方没有输出

11:12.950 --> 11:13.470
对吧

11:13.470 --> 11:15.070
那么如果说你进入了aOS

11:15.070 --> 11:16.750
那是不是另外一个快捷作用语了

11:17.350 --> 11:25.350
这是另外一个快捷作用语

11:25.350 --> 11:25.790
是吧

11:25.790 --> 11:27.710
那么当该作用语中

11:28.190 --> 11:31.150
作用语中找不到a

11:31.150 --> 11:32.230
所以说它这里报错了

11:32.230 --> 11:33.710
它说a is not defined

11:33.710 --> 11:34.990
a是没有定义的

11:35.430 --> 11:36.310
原来这意思吗

11:37.190 --> 11:37.750
能看懂吗

11:37.750 --> 11:38.150
这个

11:38.390 --> 11:39.270
应该很好理解

11:39.870 --> 11:41.830
那么现在有了net关键之后

11:42.270 --> 11:47.190
首先它能够解决覆盖全局边量的问题

11:47.710 --> 11:48.990
它能够解决第一个问题

11:49.270 --> 11:49.870
覆盖全局

11:49.870 --> 11:50.710
挂得到全局对象

11:50.710 --> 11:51.470
它不会挂载

11:51.990 --> 11:53.990
另外它不允许

11:53.990 --> 11:55.350
在同一个作用语里面

11:55.350 --> 11:56.390
不允许重复生命

11:56.430 --> 11:57.430
你说在这里如果说

11:57.430 --> 11:59.030
再去生命一个a是不允许的

12:00.190 --> 12:02.110
再去生命一个a看是不允许的

12:02.590 --> 12:05.590
它不能在同一个作用语里面反复生命

12:05.790 --> 12:08.150
但是允许在不同的作用语里面生命

12:08.310 --> 12:10.350
并且有了快捷作用语之后

12:10.710 --> 12:12.750
它的边量的使用范围

12:12.750 --> 12:14.510
被限制在这个作用语里面

12:14.510 --> 12:16.230
跑不出去就跟寒树一样

12:16.430 --> 12:17.230
也不能在寒树里

12:17.230 --> 12:18.710
外边使用寒树里边的边量

12:19.110 --> 12:19.790
是不是用不了

12:20.310 --> 12:21.350
那么这里是一样的

12:21.630 --> 12:25.790
那么这样子就更加符合一个常规语言的逻辑了

12:26.270 --> 12:28.430
几乎是所谓的语言都是这样子玩的

12:28.430 --> 12:30.790
但是那节词由于以前有变强提升

12:31.070 --> 12:32.390
就是搞得很混乱

12:32.550 --> 12:33.590
那么现在有内车之后

12:33.990 --> 12:34.990
它就解决这个问题了

12:34.990 --> 12:36.590
这个问题早就跟应该解决了

12:37.830 --> 12:38.230
没啥意思

12:38.230 --> 12:39.270
所以说这里要爆错

12:39.270 --> 12:39.990
是不是要爆错

12:39.990 --> 12:41.150
那这里要不要爆错

12:42.230 --> 12:42.750
要不要爆错

12:42.750 --> 12:43.510
是不是也在爆错

12:44.030 --> 12:44.830
如果运行到这

12:44.830 --> 12:45.630
它也在爆错

12:45.630 --> 12:46.230
为什么呢

12:46.350 --> 12:48.430
因为你看一下这个作用语里面有没有a

12:49.110 --> 12:50.110
这个作用语里边

12:50.670 --> 12:52.670
就这是全聚作用语里边有没有定义

12:52.750 --> 12:53.270
没有

12:53.270 --> 12:54.670
你不能说在这里边定义了

12:54.790 --> 12:55.950
这里边是矿季作用语

12:55.950 --> 12:57.310
它出了作用语就消失了

12:57.950 --> 12:58.670
没啥意思吗

12:59.790 --> 13:01.790
是不是这两个问题就解决了

13:02.870 --> 13:03.830
这两个问题就解决了

13:04.110 --> 13:05.710
那么也就是说在内车

13:05.990 --> 13:06.910
使用内车的时候

13:07.550 --> 13:08.350
使用内车

13:09.830 --> 13:10.790
不会有

13:11.590 --> 13:14.270
就是不会有变量提升

13:16.030 --> 13:17.430
不仅不会有变量提升

13:17.430 --> 13:19.430
因为它不会有变量提升

13:19.430 --> 13:22.430
所以你不能在定义之前

13:23.430 --> 13:24.470
因此

13:24.950 --> 13:28.150
不能在定义

13:29.750 --> 13:30.630
定义

13:31.830 --> 13:35.550
内车变量之前使用它

13:35.950 --> 13:37.070
因为它不会有提升

13:37.270 --> 13:38.230
以前的没问题

13:38.230 --> 13:39.030
但现在不行了

13:39.030 --> 13:40.310
比方说就例子

13:41.510 --> 13:44.030
以前我们不要在这里输出一个a

13:44.030 --> 13:46.670
然后在下边定一个变量a等于23

13:46.870 --> 13:47.990
那这里会不会爆错了

13:47.990 --> 13:48.510
不会

13:48.510 --> 13:49.670
为什么它会有提升

13:49.670 --> 13:51.230
它会把这句话提升到上面来

13:51.790 --> 13:52.950
所以上面有定义变量

13:52.950 --> 13:54.590
它会变成这个样子

13:54.590 --> 13:55.510
所以它不会爆错

13:55.510 --> 13:56.910
这里它会输出什么

13:56.910 --> 13:57.910
会输出independ

13:58.470 --> 14:00.230
但是如果说你用了net

14:01.390 --> 14:02.950
你如果说你用了net

14:03.390 --> 14:04.910
用了net之后

14:05.270 --> 14:05.910
那就不行了

14:05.910 --> 14:07.710
因为它没有变量提升

14:08.070 --> 14:08.550
是不是

14:08.550 --> 14:09.390
它没有变量提升

14:09.390 --> 14:11.270
它是在这里才是与声明一个变量

14:11.270 --> 14:13.190
那么之前是没有这个变量的

14:13.190 --> 14:14.910
因此你之前使用它的话

14:14.910 --> 14:15.630
它会爆错

14:16.190 --> 14:18.830
它说在a初始化之前

14:18.830 --> 14:20.030
你是不能使用它的

14:20.150 --> 14:22.190
但是它这里有一个细节

14:22.190 --> 14:23.070
有一个细节

14:23.070 --> 14:25.830
它并没有爆一个错说

14:25.830 --> 14:27.150
a is not defined

14:27.150 --> 14:28.630
它并没有说a没有定义

14:28.630 --> 14:30.070
而是爆了另外一个错误

14:30.070 --> 14:31.550
叫做a before

14:31.550 --> 14:33.190
就是cannot exist a

14:33.190 --> 14:35.630
不能访问a在它初始化之前

14:36.070 --> 14:36.750
那什么意思呢

14:36.750 --> 14:37.630
其实这里有个细节

14:37.630 --> 14:38.630
我给大家说一下

14:39.430 --> 14:41.430
有的时候万一练习的时候问到了

14:41.430 --> 14:42.430
可以给它吹吹牛

14:42.750 --> 14:43.470
是这样子的

14:44.070 --> 14:44.830
底层

14:45.430 --> 14:46.830
底层实现上

14:47.830 --> 14:51.110
领测声明的变量

14:51.670 --> 14:54.590
实际上也会有提升

14:54.990 --> 14:56.110
也会有提升

14:57.750 --> 14:59.390
但是你可以当成它没有提升

14:59.390 --> 14:59.990
为什么呢

15:00.430 --> 15:02.550
但是提升后

15:03.190 --> 15:07.110
会将其会将其放入到

15:07.790 --> 15:12.310
一个东西叫做暂时性死区

15:12.670 --> 15:14.110
你可以认为是一块内存空间

15:14.110 --> 15:16.110
它把放到一个暂时性死区里边去

15:16.910 --> 15:17.710
如果

15:18.470 --> 15:20.910
如果访问的变量

15:21.470 --> 15:24.910
位于暂时性死区

15:25.510 --> 15:27.070
则会爆错

15:27.190 --> 15:27.830
爆什么错呢

15:27.830 --> 15:28.590
就爆这个错

15:29.310 --> 15:30.030
爆这个错

15:32.710 --> 15:33.710
它就会爆这个错误

15:34.070 --> 15:34.750
原来这意思

15:35.270 --> 15:35.990
如果说

15:35.990 --> 15:38.030
因为你看这里的代码

15:38.030 --> 15:39.150
实际上它有没有提升

15:39.150 --> 15:39.870
它有提升

15:39.870 --> 15:40.910
它是这样提升的

15:40.910 --> 15:42.310
它先把这个放在这

15:42.310 --> 15:43.510
但是同时

15:44.150 --> 15:45.630
同时将其

15:45.750 --> 15:47.150
因为这个代码我就没发写了

15:47.150 --> 15:48.270
这是底层代码

15:48.270 --> 15:51.590
放入暂时性死区

15:52.110 --> 15:52.750
那么这个时候

15:52.750 --> 15:54.710
你是不是来访问暂时性死区里边的东西

15:54.710 --> 15:55.750
是不是要爆错

15:56.630 --> 15:57.950
就这么个意思

15:58.230 --> 15:58.950
它也会提升

15:59.430 --> 16:00.910
那至于它为什么会提升了

16:00.910 --> 16:02.070
那是要编译原理的

16:02.670 --> 16:04.590
但是我们可以认为它就没有提升

16:04.590 --> 16:04.950
对吧

16:04.950 --> 16:07.150
因为你在它复职

16:07.150 --> 16:07.990
在它声明之前

16:07.990 --> 16:08.990
你是不能访问的

16:09.350 --> 16:10.070
是不能访问的

16:10.070 --> 16:10.510
所以说

16:10.510 --> 16:11.510
可以认为

16:13.630 --> 16:15.190
你可以认为它是没有暂时

16:15.310 --> 16:16.270
没有就是提升的

16:17.070 --> 16:18.830
当然你这样的写肯定不行

16:18.830 --> 16:20.550
它会把它放入暂时性死区

16:20.550 --> 16:22.470
你这里访问的是暂时性死区的东西

16:23.270 --> 16:24.150
是这么个意思

16:24.790 --> 16:26.950
那么什么时候从暂时性死区移出

16:26.950 --> 16:28.430
你不能一直在暂时性死区

16:28.710 --> 16:30.070
那不然永远访问不了

16:30.350 --> 16:36.710
当代码运行到该变量的声明语句时

16:37.950 --> 16:43.950
会将其从暂时性死区中移出

16:44.510 --> 16:45.310
是这么回事

16:46.190 --> 16:46.870
也就是说

16:47.070 --> 16:48.270
你看这个代码

16:48.830 --> 16:50.510
在这里为什么不能访问的

16:50.510 --> 16:51.950
因为这个A它有没有提升

16:51.950 --> 16:52.670
实际上有提升

16:52.670 --> 16:54.550
它无非就是在暂时性死区

16:54.550 --> 16:55.750
所以说你用不了

16:55.750 --> 16:56.550
它不准你用

16:56.870 --> 16:58.990
所以说你可以当成它没有提升

16:59.310 --> 17:00.510
那么当运行到这句话

17:00.510 --> 17:01.390
是不是在声明变量

17:01.390 --> 17:01.830
这个时候

17:02.350 --> 17:04.190
它从暂时性死区里面移除掉

17:04.190 --> 17:05.470
那么后边是不是可以用了

17:05.750 --> 17:06.070
对吧

17:06.070 --> 17:07.390
它是用这种方式来处理的

17:08.030 --> 17:08.910
了解一下就行了

17:08.910 --> 17:11.150
你可以认为它没有提升

17:11.150 --> 17:12.150
是完全没问题的

17:12.150 --> 17:13.550
一点都不影响后边的学习

17:14.430 --> 17:14.750
好了

17:14.750 --> 17:15.630
这是关于这一块

17:16.030 --> 17:16.990
关于就是

17:18.670 --> 17:19.630
变量提升

17:19.630 --> 17:20.950
就是这几个问题

17:20.950 --> 17:23.630
它是怎么去解决的

17:24.110 --> 17:25.150
那么从此以后

17:25.430 --> 17:26.470
我们定义变降

17:26.470 --> 17:28.190
都不再使用VAR了

17:28.190 --> 17:28.990
而使用什么呢

17:28.990 --> 17:30.190
使用Net

17:30.550 --> 17:31.230
没人的意思吧

17:31.950 --> 17:32.950
全是使用Net

17:32.950 --> 17:34.270
没有不再使用VAR了

17:34.270 --> 17:35.070
不再使用VAR了

17:35.790 --> 17:37.990
那么再回归一下

17:37.990 --> 17:39.350
它首先解决了

17:39.710 --> 17:41.070
它不会挂得到全球对象

17:41.070 --> 17:42.750
不会解决到污染问题

17:42.990 --> 17:43.750
另外一个

17:43.750 --> 17:45.390
在同一个作用域中

17:45.390 --> 17:46.710
是不能重复生命的

17:47.070 --> 17:47.910
同一个作用域中

17:47.910 --> 17:48.750
是不能重复生命的

17:48.750 --> 17:49.910
比方说只要遇到

17:49.910 --> 17:51.070
只要运行到一个大国号

17:51.070 --> 17:52.310
它就会创建一个作用域

17:53.030 --> 17:54.190
大国号已经结束

17:54.190 --> 17:55.750
那么这个作用域就会销毁

17:55.750 --> 17:56.910
当然变量里边的所谓

17:56.910 --> 17:58.110
这个作用域里边的所谓的东西

17:58.110 --> 17:58.870
都会销毁掉

17:59.710 --> 18:01.110
有时候就不能用了

18:01.910 --> 18:03.350
那么在外边的

18:03.350 --> 18:04.230
是不能用里边的

18:04.230 --> 18:05.430
里边的可以用外边的

18:06.030 --> 18:06.670
没人的意思吧

18:07.230 --> 18:09.790
这就是在同一个作用域里边

18:09.790 --> 18:10.910
是不能有重复生命的

18:11.150 --> 18:12.110
另外提升了

18:12.150 --> 18:13.390
再用内存生命的变量了

18:13.390 --> 18:14.510
它就不会有提升了

18:14.510 --> 18:15.390
不会有提升了

18:16.350 --> 18:18.270
那么这里边还有一个小的问题

18:18.270 --> 18:20.590
就是关于循环

18:21.310 --> 18:22.590
关于循环我这里说一下

18:23.870 --> 18:25.070
还是有以这个例子

18:26.070 --> 18:28.790
DIV buttons

18:30.190 --> 18:30.910
还是以这个例子

18:30.910 --> 18:32.230
我在这里边加10个按钮

18:32.790 --> 18:34.150
看一下现在能不能解决这个问题

18:37.630 --> 18:38.910
我们这里加10个按钮

18:39.510 --> 18:42.390
我们这里得到这个DIV documents

18:42.390 --> 18:43.630
DatsElementID

18:44.190 --> 18:45.590
DIV.es

18:46.510 --> 18:47.870
然后这里循环10次

18:48.430 --> 18:49.230
i等于0

18:49.230 --> 18:50.630
i小于10

18:50.630 --> 18:51.270
i等于1

18:52.270 --> 18:53.630
i小于10

18:53.630 --> 18:54.470
i加加

18:56.270 --> 18:58.470
然后我们给我们每一循环

18:58.470 --> 18:59.630
一次创建一个按钮

19:00.070 --> 19:00.750
Documents

19:00.750 --> 19:01.790
CreateElements

19:02.270 --> 19:02.710
Dotem

19:03.110 --> 19:03.790
创建一个按钮

19:05.550 --> 19:05.910
Dotem

19:07.350 --> 19:09.190
然后给这个按钮了

19:09.190 --> 19:10.990
加个文本InnerItem

19:11.990 --> 19:17.750
好这里我们写上

19:20.430 --> 19:21.030
按钮

19:21.670 --> 19:22.310
拼接上

19:24.110 --> 19:26.270
然后把这个按钮加到DIV里面去

19:26.270 --> 19:27.030
AppendChannel

19:28.350 --> 19:28.830
Bottom

19:28.830 --> 19:29.510
加进去

19:29.510 --> 19:30.750
保存看一下

19:33.550 --> 19:34.390
我这里得不到

19:36.030 --> 19:37.070
DIV buttons

19:37.070 --> 19:37.750
我写错了吗

19:38.510 --> 19:38.990
没错

19:41.630 --> 19:42.190
他说什么

19:42.550 --> 19:44.030
他说这个DIV is now

19:44.030 --> 19:44.590
没得到

19:44.590 --> 19:45.310
没得到

19:46.070 --> 19:47.950
我这里写的那样是ID

19:49.230 --> 19:49.990
好按钮出来了

19:50.990 --> 19:51.870
这个没问题

19:51.870 --> 19:53.030
那么接下来我们注册事件

19:53.030 --> 19:54.790
看一下会不会遇到同样的问题呢

19:55.350 --> 19:55.790
Button

19:56.070 --> 19:56.670
onClick

19:57.470 --> 19:57.870
方形

19:58.390 --> 20:00.390
点击按钮过后我们输出

20:01.430 --> 20:02.070
好保存

20:02.710 --> 20:03.630
现在是不是遇到问题

20:03.630 --> 20:04.910
这个问题我们之前是解释过的

20:05.430 --> 20:07.590
根本的原因是因为这个i提升了

20:07.590 --> 20:08.070
提升到哪了

20:08.070 --> 20:08.870
提升到上面去了

20:09.230 --> 20:10.190
用的是同一个i

20:10.630 --> 20:12.390
我们现在只需要做一件事

20:13.750 --> 20:14.550
把它改为net

20:15.110 --> 20:15.590
就完了

20:17.190 --> 20:17.590
你看

20:18.390 --> 20:20.550
所以没有什么历史之音函数

20:20.550 --> 20:21.550
没有去用什么b

20:21.550 --> 20:22.150
背包

20:22.150 --> 20:23.070
直接搞定了

20:23.070 --> 20:23.390
对吧

20:23.390 --> 20:24.750
直接就搞定了

20:26.270 --> 20:26.790
为什么

20:27.030 --> 20:27.990
这个循环这里

20:28.110 --> 20:29.110
我要单独说一下

20:29.150 --> 20:30.230
首先我一个个说

20:30.750 --> 20:31.390
首先第一个点

20:31.830 --> 20:32.630
就是我刚才说的

20:32.950 --> 20:33.550
net

20:33.630 --> 20:34.350
尽量用net

20:34.350 --> 20:35.230
就不再使用VAR了

20:35.470 --> 20:36.230
不再使用VAR了

20:36.230 --> 20:38.230
所以说避免在一个项目里面

20:38.230 --> 20:38.990
一会用VAR

20:38.990 --> 20:39.590
一会用net

20:39.630 --> 20:40.550
这样子很不好的

20:40.550 --> 20:41.510
你要么全部用VAR

20:41.510 --> 20:42.350
要么全部用net

20:42.350 --> 20:43.430
建议大家全部用net

20:44.710 --> 20:45.230
接着问题

20:45.230 --> 20:46.190
我们以后会解决

20:46.190 --> 20:46.910
现在不用管

20:47.070 --> 20:47.910
全部变成net

20:48.070 --> 20:49.790
那为什么现在能解决这样的问题呢

20:50.230 --> 20:51.550
在循环这一块

20:51.550 --> 20:52.790
它会有个特殊处理

20:52.950 --> 20:53.350
你看

20:54.150 --> 20:55.590
你看这个声明变量

20:55.590 --> 20:57.030
是不是不在大户号里边

20:57.710 --> 20:58.950
他没有在大户号里边声明

20:59.550 --> 21:00.030
对吧

21:00.310 --> 21:01.710
是没有在大户号里边声明

21:02.070 --> 21:03.310
因此好像说

21:03.310 --> 21:05.510
你这个声明变量是在全局重用余

21:05.510 --> 21:06.750
它不是快局重用余

21:07.070 --> 21:07.950
实际上是这样子

21:07.950 --> 21:08.950
循环这一块

21:08.990 --> 21:10.430
它会有一个特殊处理

21:11.710 --> 21:14.030
在循环中使用

21:14.270 --> 21:19.070
循环中net会特殊处理

21:21.110 --> 21:22.350
就是循环变量

21:22.590 --> 21:23.590
循环变量

21:24.110 --> 21:31.660
就是用net声明的循环变量

21:32.420 --> 21:33.420
会特殊处理

21:33.420 --> 21:34.340
怎么处理呢

21:34.340 --> 21:39.340
它每一次进入循环体

21:40.060 --> 21:41.340
循环体是个大户号

21:41.740 --> 21:48.260
都会开启一个新的作用余

21:48.620 --> 21:56.460
并且将循环变量绑定到该作用余

21:57.660 --> 22:00.340
也就是说换句话说

22:00.340 --> 22:08.140
就是每次循环使用的是一个全新的循环变量

22:10.340 --> 22:11.940
它会作为做这么一个特殊处理

22:11.940 --> 22:12.740
要看这边

22:13.060 --> 22:15.060
那么这里是不是循环变量是i

22:15.060 --> 22:15.580
对不对

22:15.580 --> 22:17.660
那么首先问大家第一个问题

22:18.100 --> 22:20.620
这里整个循环开启了多少个作用余

22:22.140 --> 22:23.620
你不要告诉我只有一个

22:24.140 --> 22:26.300
作用余不是说你看到一个大户号

22:26.300 --> 22:27.100
就是一个作用余

22:27.100 --> 22:28.740
是它运行到一个大户号

22:28.740 --> 22:29.540
是一个作用余

22:29.540 --> 22:30.980
那么这里你会运行的尺

22:30.980 --> 22:32.980
这个代码是不是会运行十次

22:32.980 --> 22:33.260
对吧

22:33.260 --> 22:33.980
十次

22:34.780 --> 22:37.300
因此这里会开启十个作用余

22:37.980 --> 22:40.380
第一次循环开启一个新的作用余

22:40.380 --> 22:42.420
那么这个作用余它会绑定

22:42.420 --> 22:44.860
它会把这个i绑定到这个作用余里面

22:44.860 --> 22:46.220
它会做一个这么一个特殊处理

22:46.740 --> 22:48.020
绑定到这个作用余里面

22:48.020 --> 22:50.740
因此这个作用余里面相当于就是一个新的i

22:50.740 --> 22:52.540
相当于是一个新的i

22:52.820 --> 22:53.740
相当于是这样子

22:54.540 --> 22:58.940
列设 i 等于 i2

22:59.380 --> 23:00.900
相当于是给了一个i2

23:00.900 --> 23:02.780
把这个i放到这个i2里面

23:02.780 --> 23:05.060
由于它是在这个作用余里面定义的

23:05.420 --> 23:07.500
那么它只在这个作用余里面有效

23:07.500 --> 23:09.940
那么下一次循环还能不能用它

23:09.940 --> 23:12.460
下一次循环还能不能用之前那个循环的i2

23:12.460 --> 23:13.380
是不是不能用了

23:13.380 --> 23:13.660
对吧

23:13.660 --> 23:14.820
除了这个作用余了

23:14.820 --> 23:16.620
这里要有一点抽象思维

23:16.620 --> 23:18.820
第一次循环它定义了一个i2

23:18.820 --> 23:20.980
第二次循环又定义了一个i2

23:20.980 --> 23:23.420
那么两次循环的i2是不是同一个

23:23.420 --> 23:24.220
不是同一个

23:24.220 --> 23:25.860
他们不在同一个作用余里面

23:25.860 --> 23:27.140
因为用net定义的

23:27.140 --> 23:28.620
他不在同一个作用余里面

23:29.260 --> 23:30.980
实际上这件事他帮你做了

23:30.980 --> 23:32.300
他帮你做了这么一件事

23:32.700 --> 23:34.940
他这里有个i实际上在外面定义的i

23:34.940 --> 23:37.780
但是他会绑定到每一次的作用余

23:37.780 --> 23:38.780
每一次的作用余

23:38.780 --> 23:41.420
因此每一次的循环他用的是自己的i

23:41.860 --> 23:42.340
对吧

23:42.340 --> 23:43.100
没问题吧

23:43.100 --> 23:44.900
所以说每一次循环里面

23:44.900 --> 23:49.220
这里的b包用的i是当前这个作用余里面的i

23:50.700 --> 23:52.420
每一次循环他运行个i

23:52.420 --> 23:55.220
他的b包里面的i是当前的作用余里面的i

23:55.220 --> 23:57.660
那么下一次循环又是下一个循环的i了

23:57.660 --> 23:59.260
虽然说我们都用的是i

23:59.260 --> 24:00.700
但是i是不一样的

24:01.580 --> 24:02.740
用了i是不一样的

24:03.260 --> 24:07.380
这里使用的是当前作用余中的i

24:07.380 --> 24:08.540
你看这意思吗

24:09.780 --> 24:10.980
好 并且呢

24:10.980 --> 24:12.060
不仅如此

24:12.060 --> 24:13.540
他为了避免你犯错

24:13.540 --> 24:15.500
在外面去使用循环辨量

24:15.500 --> 24:16.580
他还做了一件事

24:16.580 --> 24:19.020
就是循环辨量

24:19.020 --> 24:20.780
在循环结束后会被销毁

24:22.020 --> 24:22.860
循环辨量

24:26.340 --> 24:27.460
应该这样说

24:27.460 --> 24:29.500
在循环中

24:29.540 --> 24:33.700
使用net声明的循环辨量

24:34.700 --> 24:38.140
在循环结束后会销毁

24:38.660 --> 24:39.420
会销毁

24:39.420 --> 24:41.580
也就是说我们在这个循环结束后

24:41.580 --> 24:42.580
你还能获得i吗

24:42.580 --> 24:43.260
我们来看一下

24:43.940 --> 24:44.620
还能获得i吗

24:44.620 --> 24:45.620
i是not defend

24:45.620 --> 24:46.180
看没有

24:47.220 --> 24:48.860
也就是说他这里i不见了

24:48.860 --> 24:49.780
所以说循环这里呢

24:49.780 --> 24:50.860
你要特殊看待

24:50.860 --> 24:51.900
你要特殊看待

24:51.900 --> 24:52.620
就是你可以

24:52.620 --> 24:56.220
你就是把当成每一次循环用的是这个i

24:57.020 --> 24:57.940
那不是同一个i

24:57.940 --> 24:59.100
每一次循环是一个新的i

24:59.140 --> 25:00.260
你可以这样去认为

25:00.260 --> 25:01.940
每一次循环是一个新的i

25:01.940 --> 25:03.860
他内部做了特殊处理的

25:03.860 --> 25:05.260
然后并且i

25:05.260 --> 25:07.020
他不是在拳击中用于

25:07.020 --> 25:08.540
而是跟循环绑立在一起的

25:08.540 --> 25:09.540
循环一旦结束

25:09.540 --> 25:11.580
那么这个i就消失

25:11.580 --> 25:13.660
所以现在这个问题就不会存在了

25:13.660 --> 25:15.020
就大冷用就行了

25:15.020 --> 25:15.420
你看

25:15.420 --> 25:17.500
是不是解决了痛苦很久的问题

25:17.500 --> 25:19.700
是不是就很轻松的解决了

25:19.700 --> 25:20.740
对不对

25:20.740 --> 25:23.860
这是关于net

25:25.100 --> 25:27.060
是不是就说完了

25:27.060 --> 25:27.860
说完了还有啥呢

25:29.140 --> 25:29.860
就没了

25:29.860 --> 25:31.180
就这么一点知识

25:31.180 --> 25:32.460
那么大家下来了

25:32.460 --> 25:33.860
我建议你呢

25:33.860 --> 25:35.700
自己手不要去光看

25:35.700 --> 25:36.980
看是没有什么印象的

25:36.980 --> 25:38.340
自己手中写下这个带吧

25:38.340 --> 25:39.500
你用定义一下边量

25:39.500 --> 25:41.700
看一下用内手定义什么感觉

25:41.700 --> 25:43.660
看一下温斗里面有没有

25:43.660 --> 25:45.380
去看一下他能不能重复定义

25:45.380 --> 25:47.020
多去多去写几个例子

25:47.020 --> 25:48.260
慢慢去体会

25:48.260 --> 25:49.700
多去写几个

25:49.700 --> 25:50.860
甚至我可能上也不可能

25:50.860 --> 25:52.820
把所有的历史全部讲完

25:52.820 --> 25:54.500
你自己多去写几个

25:54.500 --> 25:55.540
也非常非常简单

25:55.540 --> 25:57.260
特别是你要去写下这个循环

25:57.260 --> 25:58.540
找一找这种感觉

25:58.580 --> 25:59.500
一定要去写一声

25:59.500 --> 26:00.860
不要觉得他简单

26:00.860 --> 26:01.500
好

26:01.500 --> 26:03.620
这是关于net的边量证明

