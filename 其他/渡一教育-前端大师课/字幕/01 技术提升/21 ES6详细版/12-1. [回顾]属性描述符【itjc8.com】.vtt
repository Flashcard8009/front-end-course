WEBVTT

00:01.010 --> 00:06.010
在开始学习这张铁铁之前呢 我们先来回顾一个知识点啊

00:06.010 --> 00:11.010
因为我们这一张铁呢 要用到这个知识点 叫做属性描述服务

00:11.010 --> 00:16.010
当然了 如果说你对这个知识点影掌握的没有问题了啊 觉得很牢靠了

00:16.010 --> 00:20.010
你知道这 这是什么回事 那么你就可以略过这个张铁了啊

00:20.010 --> 00:24.010
这是一个回顾的内容 那么什么叫做属性描述服务呢

00:24.010 --> 00:28.010
因为这不是ES6的东西啊 这是之前慢慢的东西

00:28.010 --> 00:34.010
它叫做Property Descriptor 那么这是属性描述服务

00:34.010 --> 00:42.010
它用来干嘛呢 它用于描述一个属性的相关信息

00:42.010 --> 00:47.010
那么我们属性是不是在对象里边的 对吧 是在对象里边的东西

00:47.010 --> 00:51.010
那么属性呢 我们目前只知道它有两个关键信息

00:51.010 --> 00:56.010
什么呢 一个是属性的名字 一个是属性的值 对吧 就这么两个信息

00:57.010 --> 01:01.010
那还有什么样的关键相关信息呢 好 咱们来看一下

01:01.010 --> 01:04.010
其实一个属性呢 它还有一些相关信息

01:04.010 --> 01:09.010
比方说这个属性呢 能不能被在FoIn循环中被循环出来 对吧

01:09.010 --> 01:13.010
那么我们把它叫做可媒举性 如果说它可媒举的话

01:13.010 --> 01:17.010
那么它就能够能够在FoIn循环中把它循环出来

01:17.010 --> 01:20.010
如果说它不可媒举的话 那么它就不能循环出来

01:20.010 --> 01:25.010
就是其实也就是说 一个属性呢 除了属性名和属性值之外呢

01:25.010 --> 01:30.010
它还有一些信息 那么这些信息呢 我们把它称之为属性描述符

01:30.010 --> 01:34.010
这个名字呢 这是发音的原因啊

01:34.010 --> 01:37.010
其实它英文人很好理解 property什么意思 属性

01:37.010 --> 01:41.010
descript descriptor 就是一个描述者 用来描述属性的东西

01:41.010 --> 01:45.010
那么发音管理变成属性描述符了 就这东西不是那么好理解

01:45.010 --> 01:48.010
那么其实呢 你看英文的话 就非常好理解这个东西

01:48.010 --> 01:51.010
就是来描述一个属性的相关信息

01:51.010 --> 01:55.010
好 每一个属性啊 它除了属性名和属性值之外

01:55.010 --> 01:59.010
它都有一些相关信息 那么这些信息我们如何来得到呢

01:59.010 --> 02:02.010
我们来看一下吧 看一下随便找一个属性来看一下

02:02.010 --> 02:04.010
它的相关信息有哪些 怎么来得到呢

02:04.010 --> 02:08.010
你可以通过这么一个代码 怎么代码呢

02:08.010 --> 02:17.010
object get own property descriptor

02:19.010 --> 02:23.010
通过这个方法来得到一个属性的描述符

02:23.010 --> 02:33.010
通过它可以得到一个对象的某个属性的属性描述符

02:33.010 --> 02:37.010
好 比方说啊 咱们的这里呢 来写这么一个代码

02:37.010 --> 02:41.010
我们来看一下 随便写个对象 随便写一个对象

02:41.010 --> 02:45.010
这里呢 我们写上这么一个对象 obj

02:46.010 --> 02:49.010
那么它有两个属性 add 1 b 等于2

02:49.010 --> 02:51.010
那么这两个属性呢 我们现在要得到

02:51.010 --> 02:56.010
这两个属性的属性描述符

02:56.010 --> 03:03.010
怎么来得到呢 就可以使用 object get own property descriptor

03:03.010 --> 03:04.010
你看 是不是这个还是说

03:04.010 --> 03:06.010
它有两个参数需要传递啊

03:06.010 --> 03:11.010
好 第一个参数呢 就是一个对象

03:11.010 --> 03:14.010
因为你要得到某个对象的某个属性 对吧

03:14.010 --> 03:16.010
对象告诉它 哪个对象的属性

03:16.010 --> 03:18.010
哪个属性 第一个参数的对象

03:18.010 --> 03:21.010
那么第二个参数呢 就很简单了 就是属性名

03:21.010 --> 03:24.010
属性的名字自然而然是字不错 对吧

03:24.010 --> 03:26.010
那么你就可以得到一个对象的属性

03:26.010 --> 03:28.010
某个属性的描述符

03:28.010 --> 03:30.010
好 这里呢 我们怎么传递呢 obj

03:30.010 --> 03:32.010
对象属性名呢

03:32.010 --> 03:34.010
我们看它返回的结果

03:34.010 --> 03:36.010
看它返回的结果

03:36.010 --> 03:37.010
就是一个属性描述符

03:37.010 --> 03:39.010
咱们把输出 你看一下

03:39.010 --> 03:44.150
好 这里我们运行

03:44.150 --> 03:45.150
好 稍等片刻

03:45.150 --> 03:47.150
那么我们就看得到 这个控制台里面呢

03:47.150 --> 03:49.150
它输出了这么一个对象

03:49.150 --> 03:51.150
也就是属性描述符那里看上去

03:51.150 --> 03:53.150
其实就是一个对象 对吧

03:53.150 --> 03:55.150
通过这个函数呢 我们就知道了

03:55.150 --> 03:57.150
原来属性描述符呢 就特别简单

03:57.150 --> 03:59.150
它就是一个普通对象

03:59.150 --> 04:02.150
属性描述符是一个普通对象

04:02.150 --> 04:05.150
它用来描述一个属性的相关信息

04:05.150 --> 04:07.150
那么我们从这里也可以看到

04:07.150 --> 04:09.150
这个对象里面呢 有一些属性 对吧

04:09.150 --> 04:12.150
那么这些属性呢 就是

04:12.150 --> 04:14.150
这个东西的相关信息

04:14.150 --> 04:16.150
好 那么这里边有哪些属性呢

04:16.150 --> 04:18.150
我们一个个看 一个是Value值

04:18.150 --> 04:19.150
Value是什么呢

04:19.150 --> 04:21.150
Value呢 就表示的是属性值

04:21.150 --> 04:23.150
这个很简单 属性值

04:23.150 --> 04:25.150
你看一下这边

04:25.150 --> 04:28.150
Value 是不是得到对象的

04:28.150 --> 04:29.150
这个属性 它的属性值

04:29.150 --> 04:31.150
是不是就在Value里面 对吧

04:31.150 --> 04:34.150
通过是整个对象来描述出来

04:34.150 --> 04:36.150
好 那么这里呢 还有一些属性

04:36.150 --> 04:37.150
什么Configurable

04:37.150 --> 04:38.150
怎么来看一下吧

04:38.150 --> 04:40.150
Configurable

04:40.150 --> 04:42.150
那么这个东西呢 是表示的是

04:42.150 --> 04:46.150
属性描述服的描述服

04:46.150 --> 04:50.150
是否可以重新配置

04:50.150 --> 04:52.150
重新修改

04:52.150 --> 04:54.150
或者是否可以修改吧

04:54.150 --> 04:55.150
啥意思呢

04:55.150 --> 04:57.150
就是说你看这个描述信息里边

04:57.150 --> 04:59.150
不是有这么一些信息吗 对不对

04:59.150 --> 05:01.150
那么这些信息能不能被修改

05:01.150 --> 05:03.150
就是通过这个属性来规定的

05:03.150 --> 05:04.150
如果说这个属性呢

05:04.150 --> 05:05.150
Value 就表示了

05:05.150 --> 05:07.150
这些信息是能够修改的

05:07.150 --> 05:08.150
尽管呢 你现在呢

05:08.150 --> 05:09.150
还不知道怎么修改 对吧

05:09.150 --> 05:10.150
但是呢 你

05:10.150 --> 05:12.150
这个配置呢 就告诉你

05:12.150 --> 05:13.150
这个东西是能修改的

05:13.150 --> 05:14.150
就这么个意思

05:14.150 --> 05:15.150
那么一会儿呢

05:15.150 --> 05:17.150
我就会讲怎么去修改它

05:17.150 --> 05:18.150
这是这个Configurable

05:18.150 --> 05:20.150
那么如果它为Force的话

05:20.150 --> 05:22.150
那么这个属性描述服就定下来了

05:22.150 --> 05:23.150
这个属性的相关信息

05:23.150 --> 05:24.150
是不能被修改的

05:24.150 --> 05:26.150
就这么个意思

05:26.150 --> 05:27.150
这是一个Configurable

05:27.150 --> 05:29.150
好 接下来我们再看

05:29.150 --> 05:30.150
再看

05:30.150 --> 05:31.150
这里呢 还有一个属性

05:31.150 --> 05:33.150
叫Enumerable

05:33.150 --> 05:34.150
Enumerable 什么意思呢

05:34.150 --> 05:36.150
就是是否可媒举的

05:36.150 --> 05:39.150
该属性是否可以被媒举

05:39.150 --> 05:41.150
什么叫媒举呢

05:41.150 --> 05:43.150
媒举呢 又是被拿出来看

05:43.150 --> 05:45.150
被罗列出来 就是这个意思

05:45.150 --> 05:46.150
什么意思呢

05:46.150 --> 05:48.150
也就是说 如果说这个属性呢

05:48.150 --> 05:50.150
如果说这个描述服它为True

05:50.150 --> 05:52.150
那么在for-in循环里边

05:52.150 --> 05:54.150
包括在什么Objects

05:54.150 --> 05:56.150
什么Kids 啊

05:56.150 --> 05:57.150
这些方法里边

05:57.150 --> 05:59.150
都可以得到这个属性

05:59.150 --> 06:01.150
是因为这个描述服为True

06:01.150 --> 06:03.150
一会儿我们把修改之后呢

06:03.150 --> 06:04.150
我们可以把它修改为Force

06:04.150 --> 06:05.150
大家可以看一下

06:05.150 --> 06:07.150
好 下面这个Retable

06:07.150 --> 06:08.150
Retable很简单

06:09.150 --> 06:12.150
该属性是否可以被

06:12.150 --> 06:15.150
重新复职

06:15.150 --> 06:16.150
就这么个意思

06:16.150 --> 06:19.150
是不是可写的Retable

06:19.150 --> 06:21.150
那么它这个描述服

06:21.150 --> 06:23.150
跟这个Configurable有什么区别呢

06:23.150 --> 06:24.150
Configurable 指的是

06:24.150 --> 06:26.150
这个描述服本身

06:26.150 --> 06:28.150
就是这个描述服本身

06:28.150 --> 06:29.150
能不能被修改

06:29.150 --> 06:30.150
那么Retable呢

06:30.150 --> 06:32.150
指的是这个属性的值

06:32.150 --> 06:33.150
能不能被修改

06:33.150 --> 06:34.150
是这么个意思

06:34.150 --> 06:36.150
这么个意思

06:36.150 --> 06:37.150
Retable

06:37.150 --> 06:38.150
那么我们也可以看到

06:38.150 --> 06:39.150
一个属性里边

06:39.150 --> 06:41.150
除了属性名和属性值之外

06:41.150 --> 06:42.150
其实还有一些相关信息

06:42.150 --> 06:43.150
这些信息就放到

06:43.150 --> 06:46.150
属性描述服里边去了

06:46.150 --> 06:47.150
好 那么我们现在可以看到

06:47.150 --> 06:48.150
属性描述服

06:48.150 --> 06:49.150
可以通过这个方法

06:49.150 --> 06:50.150
其实还有一个方法

06:50.150 --> 06:51.150
给大家看一下吧

06:51.150 --> 06:53.150
另外还有一个方法

06:53.150 --> 06:54.150
还有一个方法叫做

06:54.150 --> 06:56.150
我们在这里写吧

06:56.150 --> 06:57.150
大家看一下就行了

06:57.150 --> 06:59.150
就是Objects

06:59.150 --> 07:00.150
Gate

07:00.150 --> 07:01.150
Own

07:01.150 --> 07:03.150
Probities

07:03.150 --> 07:05.150
我们在这里写

07:05.150 --> 07:08.150
的话有提示一点

07:08.150 --> 07:09.150
Objects

07:09.150 --> 07:10.150
太长了

07:10.150 --> 07:11.150
我也记不住

07:11.150 --> 07:12.150
Gate

07:12.150 --> 07:13.150
Own

07:13.150 --> 07:14.150
Probities

07:14.150 --> 07:15.150
也说后面加个s

07:15.150 --> 07:17.150
就加个s

07:17.150 --> 07:18.150
加个s

07:18.150 --> 07:19.150
那么这个方法

07:19.150 --> 07:20.150
它就会得到

07:20.150 --> 07:21.150
某一个对象的

07:21.150 --> 07:23.150
所有的属性描述服

07:23.150 --> 07:24.150
你看

07:24.150 --> 07:25.150
是不是得到一个对象

07:25.150 --> 07:26.150
这个对象

07:26.150 --> 07:27.150
属性a它的描述服是啥

07:27.150 --> 07:29.150
属性b它的描述服是啥

07:29.150 --> 07:30.150
它就得到这么一个对象了

07:30.150 --> 07:31.150
它就可以得到一个

07:31.150 --> 07:32.150
某一个对象的

07:32.150 --> 07:34.150
所有的属性描述服

07:35.150 --> 07:36.150
了解一下就行了

07:36.150 --> 07:37.150
也就是说这里

07:37.150 --> 07:39.150
记一笔吧

07:39.150 --> 07:40.150
也不怎么用

07:40.150 --> 07:41.150
Probities

07:41.150 --> 07:42.150
那么这个

07:42.150 --> 07:43.150
传一个对象进去就行了

07:43.150 --> 07:44.150
那么这个东西

07:44.150 --> 07:45.150
是可以得到

07:45.150 --> 07:46.150
某一个对象的

07:46.150 --> 07:48.150
所有属性描述服

07:48.150 --> 07:49.150
可以得到

07:49.150 --> 07:50.150
某个对象的

07:50.150 --> 07:54.150
所有属性描述服

07:54.150 --> 07:55.150
好吧

07:55.150 --> 07:56.150
那么现在我们知道了

07:56.150 --> 07:57.150
怎么来得到

07:57.150 --> 07:59.150
一个对象的属性描述服

07:59.150 --> 08:00.150
那怎么去改它呢

08:00.150 --> 08:01.150
能不能改呢

08:01.150 --> 08:02.150
可以改

08:02.150 --> 08:03.150
它是这样子

08:04.150 --> 08:06.150
如果需要

08:06.150 --> 08:08.150
为某个对象

08:08.150 --> 08:11.150
添加属性10

08:11.150 --> 08:13.150
或

08:13.150 --> 08:16.150
修改属性10

08:17.150 --> 08:19.150
配置其

08:20.150 --> 08:22.150
属性描述服

08:22.150 --> 08:24.150
可以使用

08:24.150 --> 08:25.150
下面的代表

08:25.150 --> 08:26.150
就说如果说

08:26.150 --> 08:27.150
你想为一个对象

08:27.150 --> 08:28.150
添加一个属性

08:28.150 --> 08:29.150
像我们之前添加属性

08:29.150 --> 08:30.150
都是直接在这里写

08:30.150 --> 08:31.150
对吧

08:31.150 --> 08:32.150
或者说我们在这里

08:32.150 --> 08:33.150
这样子写

08:33.150 --> 08:34.150
添加一个属性

08:34.150 --> 08:35.150
对吧

08:35.150 --> 08:36.150
我们现在

08:36.150 --> 08:37.150
其实还可以用

08:37.150 --> 08:38.150
另外一种方式

08:38.150 --> 08:39.150
添加属性

08:39.150 --> 08:40.150
那么那种方式

08:40.150 --> 08:41.150
它不仅可以

08:41.150 --> 08:42.150
把一个属性添加到对象里边

08:42.150 --> 08:43.150
同时

08:43.150 --> 08:44.150
还可以给这个属性

08:44.150 --> 08:46.150
指定属性描述服

08:46.150 --> 08:47.150
就这么个意思

08:47.150 --> 08:48.150
为某个对象

08:48.150 --> 08:49.150
添加属性的时候

08:49.150 --> 08:50.150
或者说

08:50.150 --> 08:51.150
这个属性已经存在了

08:51.150 --> 08:52.150
我们需要

08:52.150 --> 08:54.150
修改它的属性描述服

08:54.150 --> 08:55.150
OK

08:55.150 --> 08:56.150
都可以使用

08:56.150 --> 08:57.150
下面的代码

08:57.150 --> 08:58.150
下面的代码是什么呢

08:58.150 --> 09:02.510
就这个

09:02.510 --> 09:03.510
就是Object

09:03.510 --> 09:04.510
Defend

09:05.510 --> 09:06.510
这个代码

09:06.510 --> 09:07.510
那么这里

09:07.510 --> 09:08.510
第一个参数

09:08.510 --> 09:09.510
是对象

09:09.510 --> 09:10.510
第二个参数

09:10.510 --> 09:11.510
是属性名

09:11.510 --> 09:12.510
第三个参数

09:12.510 --> 09:14.510
就是描述服

09:14.510 --> 09:16.510
就这么个意思

09:16.510 --> 09:17.510
好

09:17.510 --> 09:18.510
咱们来看一下吧

09:18.510 --> 09:19.510
比方我们刚才

09:19.510 --> 09:20.510
不是写了这么一个

09:20.510 --> 09:21.510
A吗

09:21.510 --> 09:22.510
对不对

09:22.510 --> 09:23.510
有这么一个A

09:23.510 --> 09:24.510
这个属性

09:24.510 --> 09:25.510
OK

09:25.510 --> 09:26.510
我现在把属性

09:26.510 --> 09:27.510
描述服改一下

09:27.510 --> 09:28.510
来看一下

09:28.510 --> 09:29.510
我们用Object

09:29.510 --> 09:30.510
Defend

09:31.510 --> 09:32.510
那么这里

09:32.510 --> 09:34.510
可以写上对象

09:34.510 --> 09:35.510
第二个参数

09:35.510 --> 09:36.510
谁上属性名

09:36.510 --> 09:38.510
改这个属性名A

09:38.510 --> 09:39.510
第三个参数

09:39.510 --> 09:41.510
就是属性描述服了

09:41.510 --> 09:42.510
那么第三个参数

09:42.510 --> 09:43.510
属性描述服

09:43.510 --> 09:44.510
就是我们刚才讲的

09:44.510 --> 09:45.510
这个对象

09:45.510 --> 09:46.510
是可以改的

09:46.510 --> 09:47.510
那么我们怎么改呢

09:47.510 --> 09:48.510
比方说

09:48.510 --> 09:49.510
举个例子

09:49.510 --> 09:51.510
我们把它Y6

09:51.510 --> 09:53.510
设置为3

09:53.510 --> 09:54.510
好

09:54.510 --> 09:55.510
来吧

09:55.510 --> 09:56.510
我们来看一下吧

09:56.510 --> 09:57.510
如果这样子

09:57.510 --> 09:58.510
一设置了过后

09:58.510 --> 09:59.510
那么这个属性描述服

09:59.510 --> 10:00.510
是不是Y6

10:00.510 --> 10:01.510
它的属性值

10:01.510 --> 10:02.510
参了

10:02.510 --> 10:03.510
被变成3了

10:03.510 --> 10:04.510
当然了

10:04.510 --> 10:05.510
这个太满了

10:05.510 --> 10:06.510
也没什么意义

10:06.510 --> 10:07.510
因为

10:07.510 --> 10:08.510
要把它属性名变

10:08.510 --> 10:09.510
属性值变成3

10:09.510 --> 10:10.510
自己这样子写就完事了

10:10.510 --> 10:11.510
对吧

10:11.510 --> 10:12.510
没有必要去用这种方式

10:12.510 --> 10:13.510
这种方式反而麻烦一点

10:13.510 --> 10:14.510
但是

10:14.510 --> 10:15.510
它可以修改别的东西

10:15.510 --> 10:16.510
你看现在的

10:16.510 --> 10:17.510
属性描述服是3的

10:17.510 --> 10:18.510
这个Y6是3

10:19.510 --> 10:21.510
它还可以修改别的东西

10:21.510 --> 10:22.510
比方说

10:22.510 --> 10:23.510
我们还可以修改是吗

10:24.510 --> 10:26.510
修改这个Configurable

10:26.510 --> 10:27.510
把它设为Force

10:28.510 --> 10:29.510
这个我们刚才讲了

10:29.510 --> 10:30.510
什么意思呢

10:30.510 --> 10:31.510
它可以修改

10:31.510 --> 10:33.510
如果说你把它设为Force了之后

10:33.510 --> 10:34.510
你看一下

10:34.510 --> 10:35.510
我们得到了属性描述服

10:35.510 --> 10:37.510
是不是Configurable Force

10:37.510 --> 10:38.510
对吧

10:38.510 --> 10:39.510
那么这又有什么用呢

10:39.510 --> 10:40.510
你看着

10:40.510 --> 10:42.510
如果说我把它设为Force了之后

10:42.510 --> 10:43.510
我们后边再对它进行

10:43.510 --> 10:45.510
属性描述服进行修改

10:45.510 --> 10:46.510
不是修改值

10:46.510 --> 10:47.510
修改值没问题

10:47.510 --> 10:49.510
只是对它属性描述服进行修改

10:50.510 --> 10:51.510
比方说我们这里

10:51.510 --> 10:52.510
重新变成2

10:52.510 --> 10:53.510
看一下

10:54.510 --> 10:55.510
我们在这里

10:55.510 --> 10:56.510
是不是看到一个错误

10:56.510 --> 10:57.510
它说

10:57.510 --> 11:00.510
不能Redefine重新定义属性A

11:00.510 --> 11:01.510
就这么个意思

11:03.510 --> 11:04.510
就这么个意思

11:04.510 --> 11:05.510
所以说

11:05.510 --> 11:06.510
那一把Configurable

11:06.510 --> 11:07.510
设为Force了之后

11:07.510 --> 11:08.510
它就不能再一次

11:08.510 --> 11:09.510
针对这个属性

11:09.510 --> 11:11.510
使用这个Define property的

11:11.510 --> 11:12.510
不能再一次修改

11:12.510 --> 11:14.510
它则是个属性描述服的修改

11:15.510 --> 11:16.510
那么这个Enumerable

11:16.510 --> 11:17.510
什么意思呢

11:17.510 --> 11:18.510
它是否是可美举的

11:18.510 --> 11:19.510
比方说

11:19.510 --> 11:20.510
它默论

11:20.510 --> 11:21.510
它一开始是

11:21.510 --> 11:22.510
普通属性的话

11:22.510 --> 11:23.510
它是一个true

11:23.510 --> 11:24.510
对吧

11:24.510 --> 11:25.510
那么把它设为Force

11:25.510 --> 11:26.510
设为Force了之后

11:26.510 --> 11:27.510
我们来看一下

11:27.510 --> 11:28.510
这个属性有什么变化

11:29.510 --> 11:30.510
设为Force了之后

11:30.510 --> 11:31.510
我们现在

11:31.510 --> 11:32.510
用Foring循环

11:32.510 --> 11:34.510
去循环这个对象

11:35.510 --> 11:36.510
循环这个对象

11:36.510 --> 11:37.510
咱们来看一下

11:37.510 --> 11:38.510
这个对象里边

11:38.510 --> 11:39.510
是不是能够

11:39.510 --> 11:41.510
循环出这个属性A呢

11:41.510 --> 11:42.510
保存

11:42.510 --> 11:43.510
咱们来看一下

11:43.510 --> 11:44.510
你看它只输出了

11:44.510 --> 11:45.510
一个属性B

11:45.510 --> 11:46.510
是不是属性A没了

11:46.510 --> 11:47.510
对吧

11:47.510 --> 11:48.510
属性A在不在

11:48.510 --> 11:49.510
它在

11:49.510 --> 11:50.510
比方说

11:50.510 --> 11:51.510
我们输出这个对象

11:51.510 --> 11:52.510
属性A肯定是在的

11:52.510 --> 11:53.510
保存

11:53.510 --> 11:54.510
你看属性A是不是在

11:54.510 --> 11:55.510
但是那你循环循环

11:55.510 --> 11:56.510
不出来

11:56.510 --> 11:57.510
为什么

11:57.510 --> 11:58.510
因为它不能被美矩

11:58.510 --> 11:59.510
美矩就是裸裂

11:59.510 --> 12:00.510
不能把它裸裂出来

12:00.510 --> 12:01.510
就这么个意思

12:01.510 --> 12:02.510
除了会影响

12:02.510 --> 12:04.510
这个Foring循环之外呢

12:04.510 --> 12:05.510
它还会影响

12:05.510 --> 12:06.510
这个什么

12:06.510 --> 12:07.510
Object车

12:07.510 --> 12:08.510
Tis

12:08.510 --> 12:09.510
OB界

12:09.510 --> 12:10.510
你看

12:10.510 --> 12:11.510
是不是得到一个

12:11.510 --> 12:12.510
对象的所有属性

12:12.510 --> 12:13.510
对吧

12:13.510 --> 12:14.510
它可以得到一个

12:14.510 --> 12:15.510
对象的所有属性

12:15.510 --> 12:16.510
得到一个数组

12:16.510 --> 12:17.510
那咱们看一下

12:17.510 --> 12:18.510
这个数组里边

12:18.510 --> 12:19.510
是不是没有A

12:19.510 --> 12:20.510
对吧

12:20.510 --> 12:21.510
没有A

12:21.510 --> 12:22.510
同样的

12:22.510 --> 12:23.510
也会影响

12:23.510 --> 12:24.510
Object

12:24.510 --> 12:25.510
对吧

12:25.510 --> 12:26.510
Values

12:26.510 --> 12:27.510
把对象传进去

12:27.510 --> 12:28.510
那么我们输出Values

12:28.510 --> 12:29.510
就是得到一个

12:29.510 --> 12:30.510
对象的所有的

12:30.510 --> 12:32.510
属性值形成的数组

12:32.510 --> 12:33.510
那么Value里边

12:33.510 --> 12:34.510
你是不是也没有A

12:34.510 --> 12:35.510
对吧

12:35.510 --> 12:36.510
这就是

12:36.510 --> 12:37.510
Enumerable

12:37.510 --> 12:38.510
好

12:38.510 --> 12:39.510
那么Retable

12:39.510 --> 12:40.510
就表示这个属性

12:40.510 --> 12:41.510
是否可写

12:41.510 --> 12:42.510
Retable

12:42.510 --> 12:43.510
如果说

12:43.510 --> 12:44.510
你把它设为Force

12:44.510 --> 12:45.510
那么从此以后

12:45.510 --> 12:46.510
这个属性

12:46.510 --> 12:47.510
是不能被重新复制的

12:47.510 --> 12:49.510
比方说咱们看一下

12:49.510 --> 12:50.510
我们现在

12:50.510 --> 12:51.510
这个属性是A

12:51.510 --> 12:52.510
对吧

12:52.510 --> 12:53.510
这个属性是A

12:53.510 --> 12:54.510
好

12:54.510 --> 12:55.510
现在我们再把它

12:55.510 --> 12:56.510
再把它变成

12:56.510 --> 12:57.510
变成多少呢

12:57.510 --> 12:58.510
变成10

12:58.510 --> 13:00.510
输出一下Object

13:00.510 --> 13:01.510
好

13:01.510 --> 13:02.510
看一下

13:02.510 --> 13:03.510
那么你会看到

13:03.510 --> 13:04.510
这个属性A是3

13:04.510 --> 13:05.510
为什么呢

13:05.510 --> 13:06.510
你在这里把它改成3

13:06.510 --> 13:07.510
对吧

13:07.510 --> 13:08.510
那么从此以后

13:08.510 --> 13:09.510
由于它Retable

13:09.510 --> 13:10.510
为Force

13:10.510 --> 13:11.510
从此以后

13:11.510 --> 13:12.510
这个属性

13:12.510 --> 13:13.510
是不能被重新修改

13:13.510 --> 13:14.510
它的值不能被重新修改

13:14.510 --> 13:15.510
你看

13:15.510 --> 13:16.510
再把它复制为10

13:16.510 --> 13:17.510
没用了

13:17.510 --> 13:18.510
这个属性

13:18.510 --> 13:19.510
变成了止独的属性

13:19.510 --> 13:21.510
这是属性描述服

13:21.510 --> 13:24.510
属性更加丰富的一些信息

13:24.510 --> 13:25.510
就是这一块

13:25.510 --> 13:26.510
Define property

13:26.510 --> 13:27.510
那么同样的

13:27.510 --> 13:29.510
它有一个对应的函数

13:29.510 --> 13:31.510
可以同时对应

13:31.510 --> 13:32.510
可以同时

13:32.510 --> 13:34.510
定义多个属性

13:36.510 --> 13:37.510
每个属性

13:37.510 --> 13:38.510
就是多个属性的

13:38.510 --> 13:40.510
多个属性的

13:40.510 --> 13:42.510
描述服

13:42.510 --> 13:43.510
它就只有两个参数了

13:43.510 --> 13:44.510
可以同时定义多个属性

13:44.510 --> 13:45.510
那么它怎么写

13:45.510 --> 13:46.510
给它看一下就行了

13:46.510 --> 13:48.510
这个很简单

13:48.510 --> 13:49.510
那么我们把

13:49.510 --> 13:50.510
上面的代码

13:51.510 --> 13:52.510
Define property

13:52.510 --> 13:53.510
是

13:53.510 --> 13:54.510
那么第一个参数

13:54.510 --> 13:55.510
对象

13:55.510 --> 13:56.510
第二个参数

13:56.510 --> 13:57.510
直接传属性描述服

13:57.510 --> 13:58.510
但是那个属性描述服

13:58.510 --> 13:59.510
里面你要指定

13:59.510 --> 14:01.510
针对的是哪个属性

14:01.510 --> 14:02.510
比方说我们这样子写

14:02.510 --> 14:03.510
针对A这个属性

14:03.510 --> 14:04.510
属性描述服

14:04.510 --> 14:05.510
是这一块

14:05.510 --> 14:07.510
就这么写就完事了

14:07.510 --> 14:08.510
那么如果说

14:08.510 --> 14:09.510
你要针对B这个属性

14:09.510 --> 14:10.510
你就这样子写

14:11.510 --> 14:12.510
就很简单

14:12.510 --> 14:14.510
它就是另外一种愚法而已

14:14.510 --> 14:16.510
另外一种格式

14:16.510 --> 14:18.510
你看是一样的

14:18.510 --> 14:19.510
好

14:19.510 --> 14:21.510
属性描述服的基本使用

14:22.510 --> 14:23.510
而我们平时

14:23.510 --> 14:26.510
使用属性描述服的话

14:26.510 --> 14:27.510
往往的不是

14:27.510 --> 14:28.510
去针对

14:28.510 --> 14:30.510
这些东西来做配置

14:30.510 --> 14:31.510
属性描述服里边

14:31.510 --> 14:33.510
还有两个特殊的配置

14:33.510 --> 14:35.510
这两个特殊的配置

14:35.510 --> 14:37.510
会极大的影响

14:37.510 --> 14:38.510
这个属性

14:38.510 --> 14:40.510
本身的运作原理

14:40.510 --> 14:41.510
这两个配置

14:42.510 --> 14:43.510
我们把它称之为

14:43.510 --> 14:46.510
就是存取器

14:46.510 --> 14:47.510
属性

14:47.510 --> 14:48.510
什么意思

14:48.510 --> 14:49.510
就是说

14:49.510 --> 14:52.510
属性描述服中

14:52.510 --> 14:54.510
描述服就是这个对象

14:54.510 --> 14:55.510
对象里面不是有很多配置吗

14:55.510 --> 14:57.510
属性描述服中

14:57.510 --> 14:59.510
如果配置了

14:59.510 --> 15:02.510
get和set

15:02.510 --> 15:04.510
我们之前吃不看过一配置

15:04.510 --> 15:05.510
value这些东西的配置

15:05.510 --> 15:07.510
它其实还有两个配置

15:07.510 --> 15:08.510
一个是get

15:08.510 --> 15:09.510
一个是set

15:09.510 --> 15:10.510
如果说配置了

15:10.510 --> 15:11.510
这两个中的任何一个

15:11.510 --> 15:14.510
和set中的任何一个

15:14.510 --> 15:16.510
则该属性

15:16.510 --> 15:19.510
不再是一个普通属性

15:19.510 --> 15:20.510
像我们之前遇到的

15:20.510 --> 15:22.510
都是一些普通属性

15:22.510 --> 15:23.510
那么它变成一个什么属性呢

15:23.510 --> 15:24.510
这个属性呢

15:24.510 --> 15:25.510
是大家从来没有见过的

15:25.510 --> 15:28.510
叫做而变成了

15:28.510 --> 15:31.510
存取器属性

15:31.510 --> 15:33.510
存取器属性

15:33.510 --> 15:35.510
跟我们的普通属性

15:35.510 --> 15:37.510
有很大的区别

15:37.510 --> 15:38.510
有什么样的区别

15:38.510 --> 15:39.510
它是这样子

15:39.510 --> 15:43.510
get和set配置

15:43.510 --> 15:45.510
都均为函数

15:45.510 --> 15:47.510
均为函数

15:47.510 --> 15:52.510
如果一个属性是存取器属性

15:52.510 --> 15:53.510
则

15:53.510 --> 15:56.510
读取该属性时

15:56.510 --> 16:01.510
会运行相应的

16:01.510 --> 16:04.510
就是会运行get方法

16:04.510 --> 16:10.510
将get方法得到的返回值

16:10.510 --> 16:12.510
返回值

16:12.510 --> 16:14.510
作为属性值

16:14.510 --> 16:15.510
有点抽象

16:15.510 --> 16:16.510
我们以后举例子

16:16.510 --> 16:20.510
如果给该属性负值

16:20.510 --> 16:23.510
则会运行set方法

16:23.510 --> 16:25.510
set就是负值的意思

16:25.510 --> 16:26.510
set方法

16:26.510 --> 16:28.510
那么就完了

16:28.510 --> 16:30.510
你看这个属性就很有意思

16:30.510 --> 16:31.510
咱们来看一下吧

16:31.510 --> 16:34.980
我们再举个例子

16:34.980 --> 16:36.980
tess2

16:36.980 --> 16:41.800
比方说吧

16:41.800 --> 16:42.800
我们这里

16:42.800 --> 16:43.800
给它加一个属性

16:43.800 --> 16:45.800
它没有这个属性

16:45.800 --> 16:47.800
给它加一个属性

16:47.800 --> 16:49.800
object

16:49.800 --> 16:51.800
define property

16:51.800 --> 16:52.800
对象名

16:52.800 --> 16:53.800
obj

16:53.800 --> 16:55.800
属性名

16:55.800 --> 16:58.800
给它一个属性描述符

16:58.800 --> 16:59.800
但是这个描述符里边

16:59.800 --> 17:00.800
我给它配置了一个

17:00.800 --> 17:01.800
非常特殊的东西

17:01.800 --> 17:03.800
叫做get

17:03.800 --> 17:04.800
get是一个函数

17:04.800 --> 17:05.800
一个函数

17:05.800 --> 17:06.800
我们可以用

17:06.800 --> 17:08.800
es6的数写方式

17:08.800 --> 17:10.800
用这种方式来数写

17:10.800 --> 17:12.800
我们这里返回

17:12.800 --> 17:13.800
这里输出一个

17:13.800 --> 17:15.800
运行了

17:15.800 --> 17:17.800
属性a的get

17:17.800 --> 17:19.800
每个属性都可以这样配置

17:19.800 --> 17:21.800
属性a的get函数

17:21.800 --> 17:24.800
然后还有一个set

17:24.800 --> 17:25.800
我们这里输出

17:25.800 --> 17:26.800
运行了

17:26.800 --> 17:29.800
属性a的set函数

17:29.800 --> 17:30.800
接下来

17:30.800 --> 17:32.800
我们来看一个神奇的现象

17:32.800 --> 17:33.800
首先obj里边

17:33.800 --> 17:36.800
存不存在这个属性a

17:36.800 --> 17:38.800
obj里边存在

17:38.800 --> 17:39.800
为什么

17:39.800 --> 17:40.800
因为这里定义了一个属性a

17:40.800 --> 17:41.800
加了一个属性a

17:41.800 --> 17:43.800
所以属性a一定是存在的

17:43.800 --> 17:44.800
你看一下

17:44.800 --> 17:46.800
这个对象里边

17:46.800 --> 17:47.800
是不是有一个属性a

17:47.800 --> 17:48.800
在这里看不见

17:48.800 --> 17:49.800
在这里看不见

17:49.800 --> 17:50.800
在这里下边

17:50.800 --> 17:51.800
变成了属性a

17:51.800 --> 17:52.800
为什么在这里看不见呢

17:52.800 --> 17:53.800
因为这个属性a

17:53.800 --> 17:55.800
不再是一个普通属性了

17:55.800 --> 17:56.800
它没有那么简单了

17:56.800 --> 17:58.800
它变成了一个存去器属性

17:58.800 --> 17:59.800
存去器属性

17:59.800 --> 18:01.800
特别有意思的一点

18:01.800 --> 18:02.800
就在那

18:02.800 --> 18:04.800
它的属性值

18:04.800 --> 18:06.800
它不是像我们普通的属性

18:06.800 --> 18:07.800
是放到内存里边的

18:07.800 --> 18:08.800
我们这样想

18:08.800 --> 18:09.800
内存空间

18:09.800 --> 18:10.800
边量属性

18:10.800 --> 18:12.800
都是放到一个内存空间里边的

18:12.800 --> 18:14.800
它变成存去器属性过后

18:14.800 --> 18:16.800
它没有专门的一块

18:16.800 --> 18:17.800
内存空间来放数据了

18:17.800 --> 18:19.800
它变成了什么呢

18:19.800 --> 18:20.800
当我们去使用

18:20.800 --> 18:22.800
这个属性a的时候

18:22.800 --> 18:24.800
它变成了去运行

18:24.800 --> 18:25.800
这个界册函数

18:25.800 --> 18:27.800
变成了这个

18:27.800 --> 18:29.800
当我们去给属性a

18:29.800 --> 18:30.800
复制的时候

18:30.800 --> 18:32.800
它变成了去运行

18:32.800 --> 18:33.800
这个界册函数

18:33.800 --> 18:35.800
相当于这句话

18:35.800 --> 18:36.800
是什么意思呢

18:36.800 --> 18:38.800
这句话我写个伟代

18:38.800 --> 18:40.800
就相当于是运行了

18:40.800 --> 18:42.800
上边那个界册方法

18:42.800 --> 18:43.800
明白的意思吧

18:43.800 --> 18:44.800
相当于运行了

18:44.800 --> 18:46.800
属性a里边的界册方法

18:46.800 --> 18:49.800
把界册方法的反回结果放这

18:49.800 --> 18:50.800
相当于是这么个意思

18:50.800 --> 18:52.800
也说我们这里写的代码

18:52.800 --> 18:53.800
是ob界点a

18:53.800 --> 18:55.800
但是实际上它运行的是

18:55.800 --> 18:56.800
属性a里边的

18:56.800 --> 18:58.800
界册方法的配置

18:58.800 --> 19:00.800
因此这里会输出啥

19:00.800 --> 19:03.240
会输出啥

19:03.240 --> 19:05.240
是不是输出undefend

19:05.240 --> 19:06.240
为什么

19:06.240 --> 19:07.240
因为这个界册方法

19:07.240 --> 19:08.240
是不是没有反回结果

19:08.240 --> 19:09.240
没有反回结果

19:09.240 --> 19:11.240
因此它会输出undefend

19:11.240 --> 19:12.240
并且上面这句话

19:12.240 --> 19:13.240
也在提醒我们

19:13.240 --> 19:14.240
是不是运行了这个方法

19:14.240 --> 19:15.240
对吧

19:15.240 --> 19:16.240
当我们去读

19:16.240 --> 19:17.240
只要你遇到读这个属性

19:17.240 --> 19:20.240
它就一定会运行这个方法

19:20.240 --> 19:22.240
另外一个set

19:22.240 --> 19:24.240
我们这里来看一下

19:24.240 --> 19:26.240
如果说我们给这个属性复制

19:26.240 --> 19:28.240
比方说复制为20

19:28.240 --> 19:30.240
那么这个时候

19:30.240 --> 19:31.240
它就会运行set的方法

19:31.240 --> 19:32.240
因为它是复制

19:32.240 --> 19:33.240
把等号

19:33.240 --> 19:35.240
就是复制符号u边的内容

19:35.240 --> 19:37.240
就结果把它的值

19:37.240 --> 19:38.240
复制给这个属性a

19:38.240 --> 19:39.240
那么这个时候

19:39.240 --> 19:41.240
它就会运行set的方法

19:41.240 --> 19:42.240
就这么简单

19:42.240 --> 19:44.240
保存 这么看一下

19:44.240 --> 19:45.240
是不是先运行set的方法

19:45.240 --> 19:46.240
对吧 为什么

19:46.240 --> 19:47.240
因为这句话

19:47.240 --> 19:48.240
实际上在做什么

19:48.240 --> 19:49.240
这句话实际上在

19:49.240 --> 19:50.240
调用set的方法

19:50.240 --> 19:52.240
并把20传给它

19:52.240 --> 19:53.240
就在做这么一件事

19:53.240 --> 19:54.240
所以说set的方法

19:54.240 --> 19:56.240
它是有一个参数的

19:56.240 --> 19:57.240
有一个参数的

19:57.240 --> 19:58.240
我们比方说

19:58.240 --> 20:00.240
我们输出这个参数

20:00.240 --> 20:01.240
它是有一个参数的

20:01.240 --> 20:02.240
刚才这句话

20:02.240 --> 20:05.240
就相当于是调了一次set

20:05.240 --> 20:07.240
那么这里就是

20:08.240 --> 20:09.240
就这么个意思

20:09.240 --> 20:10.240
那么下面这句话

20:10.240 --> 20:11.240
就相当于是

20:11.240 --> 20:12.240
console.log

20:12.240 --> 20:14.240
调用了get

20:14.240 --> 20:15.240
然后也可以看出

20:15.240 --> 20:16.240
get的方法是没有参数的

20:16.240 --> 20:18.240
因为你读取属性

20:18.240 --> 20:19.240
要什么参数呢

20:19.240 --> 20:20.240
读就行了

20:20.240 --> 20:22.240
get的方法是没有参数的

20:22.240 --> 20:23.240
那么set的方法

20:23.240 --> 20:25.240
是有一个参数

20:25.240 --> 20:26.240
而且只有一个参数

20:26.240 --> 20:27.240
对吧 只有一个参数

20:27.240 --> 20:28.240
那有一个人要说

20:28.240 --> 20:29.240
那不对啊

20:29.240 --> 20:31.240
那如果说我给它多个数据呢

20:31.240 --> 20:33.240
那就相当于这个

20:33.240 --> 20:34.240
就相当于这个

20:34.240 --> 20:35.240
就上区别了

20:35.240 --> 20:37.240
算出来 然后再调用

20:38.240 --> 20:39.240
好 咱们看一下吧

20:39.240 --> 20:41.240
你看 运行了set的方法

20:41.240 --> 20:43.240
30 把30传进去了

20:44.240 --> 20:45.240
然后这里要读

20:45.240 --> 20:47.240
是不是运行了get的方法

20:47.240 --> 20:49.240
好 读出来的结果是啥呢

20:49.240 --> 20:50.240
你想get的方法返回的结果

20:50.240 --> 20:51.240
是不是undefend

20:51.240 --> 20:52.240
那么这里是不是

20:52.240 --> 20:53.240
还是输出undefend

20:53.240 --> 20:54.240
也就是说啥呢

20:54.240 --> 20:55.240
你这句话

20:55.240 --> 20:56.240
是不是写到这句白写

20:56.240 --> 20:58.240
对吧 写到这句白写

20:58.240 --> 20:59.240
为什么呢

20:59.240 --> 21:00.240
它只是运行了set的方法

21:00.240 --> 21:01.240
set的方法里边

21:01.240 --> 21:02.240
你啥都没做

21:02.240 --> 21:03.240
那它就

21:03.240 --> 21:04.240
在读属性A的时候

21:04.240 --> 21:05.240
还是运行get的方法

21:05.240 --> 21:06.240
对吧 你不要认为

21:06.240 --> 21:07.240
跟以前就不一样了 对吧

21:07.240 --> 21:08.240
以前那是

21:08.240 --> 21:10.240
它有一块内存空间

21:10.240 --> 21:11.240
我给它30

21:11.240 --> 21:13.240
它就把30放到内存空间里边去

21:13.240 --> 21:14.240
现在不是了

21:15.240 --> 21:17.240
现在这是一个存取器属性

21:17.240 --> 21:18.240
存取器属性

21:18.240 --> 21:19.240
根本就没有那块内存空间

21:19.240 --> 21:20.240
来放数据

21:20.240 --> 21:21.240
它变成了两个方法

21:21.240 --> 21:22.240
以这样子写

21:22.240 --> 21:23.240
就相当于运行set

21:23.240 --> 21:24.240
这样子写呢

21:24.240 --> 21:26.240
就相当于运行get

21:26.240 --> 21:27.240
就这么个意思

21:28.240 --> 21:29.240
好 我们再来一些

21:29.240 --> 21:30.240
再来一些例子

21:30.240 --> 21:32.240
比方说我们这里呢

21:33.240 --> 21:34.240
再写这么一个例子

21:34.240 --> 21:37.240
objA等于objA加1

21:38.240 --> 21:39.240
然后呢

21:39.240 --> 21:41.240
我们这里输出objA

21:42.240 --> 21:43.240
来吧

21:44.240 --> 21:46.240
这个我先不管别的

21:46.240 --> 21:48.240
我先问你这个最后输出啥

21:48.240 --> 21:54.140
最后输出啥

21:54.140 --> 21:55.140
最后输出啥

21:55.140 --> 21:58.140
你根本就不应该去看前辈的代码

21:58.140 --> 22:00.140
你就看最后一步

22:00.140 --> 22:02.140
最后一步是不是在读取属性A

22:02.140 --> 22:05.140
读取属性A是不是要运行get

22:05.140 --> 22:06.140
get的返回结果是不是undefine

22:06.140 --> 22:08.140
那这里就输出undefine

22:08.140 --> 22:09.140
就是输出undefine

22:09.140 --> 22:10.140
保存你看吧

22:10.140 --> 22:11.140
最后一定是undefine

22:11.140 --> 22:13.140
因为你读取属性

22:13.140 --> 22:15.140
你别管前边是啥

22:15.140 --> 22:17.140
读取属性它一定运行get

22:17.140 --> 22:20.140
给属性复制一定运行set

22:20.140 --> 22:23.140
那么它整个过程是怎么样子呢

22:23.140 --> 22:24.140
整个过程是这样子

22:25.140 --> 22:26.140
看这里

22:26.140 --> 22:27.140
这里在做啥呀

22:27.140 --> 22:31.140
这是不是在运行set

22:31.140 --> 22:32.140
什么呢

22:32.140 --> 22:34.140
objA加1

22:34.140 --> 22:35.140
对吧

22:35.140 --> 22:36.140
是不是要运行这个

22:36.140 --> 22:38.140
那么运行这个是不是在相当

22:38.140 --> 22:39.140
因为它复制嘛

22:39.140 --> 22:41.140
复制就相当于运行set

22:41.140 --> 22:43.140
那么这个相当于是在干嘛呢

22:43.140 --> 22:44.140
是在

22:44.140 --> 22:46.140
因为我们里边是不是在读取A的字

22:46.140 --> 22:47.140
把A的字读出来

22:47.140 --> 22:48.140
给E相加

22:48.140 --> 22:49.140
那相当于是什么呢

22:49.140 --> 22:51.140
get加1

22:51.140 --> 22:52.140
你懂的

22:52.140 --> 22:53.140
那怎么运行的

22:53.140 --> 22:54.140
怎么运行的

22:54.140 --> 22:56.140
先把这个A读出来

22:56.140 --> 22:57.140
读出来是不是要运行get

22:57.140 --> 22:58.140
对吧

22:58.140 --> 22:59.140
运行get

22:59.140 --> 23:00.140
输出了这么一句话

23:00.140 --> 23:02.140
运行get

23:02.140 --> 23:03.140
那么这个get是运行的结果

23:03.140 --> 23:04.140
是不是undefined

23:04.140 --> 23:06.140
那么这个一块是不是undefined

23:06.140 --> 23:08.140
undefined加1等于多少

23:08.140 --> 23:10.140
undefined加1等于多少

23:10.140 --> 23:11.140
是不是NAN

23:11.140 --> 23:12.140
对吧

23:12.140 --> 23:13.140
是不是NAN

23:13.140 --> 23:14.140
那么这里呢

23:14.140 --> 23:16.140
那么这里是不是给它的是NAN

23:16.140 --> 23:17.140
那么现在运行set

23:17.140 --> 23:18.140
对吧

23:18.140 --> 23:19.140
复制嘛运行set

23:19.140 --> 23:20.140
那么这里是NAN

23:20.140 --> 23:21.140
对吧

23:21.140 --> 23:23.140
那么这里就输出了这么一个东西

23:23.140 --> 23:24.140
然后呢

23:24.140 --> 23:27.140
NAN

23:27.140 --> 23:28.140
好

23:28.140 --> 23:29.140
那么这句话运行完了

23:29.140 --> 23:30.140
好

23:30.140 --> 23:31.140
我们

23:31.140 --> 23:32.140
又来输出这个

23:32.140 --> 23:33.140
输出OB借点

23:33.140 --> 23:34.140
OB借点

23:34.140 --> 23:35.140
是不是要读去

23:35.140 --> 23:36.140
是不是又要运行get的方法

23:36.140 --> 23:38.140
只要一读就要运行get的方法

23:38.140 --> 23:39.140
然后呢

23:39.140 --> 23:40.140
得到的结果是undefined

23:40.140 --> 23:41.140
于是呢

23:41.140 --> 23:44.140
这里输出了这么undefined

23:44.140 --> 23:46.140
这是它整个过程

23:46.140 --> 23:47.140
看没

23:47.140 --> 23:48.140
是不是整个过程

23:48.140 --> 23:49.140
好

23:49.140 --> 23:50.140
那么我们来看一下

23:50.140 --> 23:51.140
是不是这样子的

23:51.140 --> 23:52.140
对比一下

23:52.140 --> 23:53.140
是不是这样子

23:53.140 --> 23:54.140
好

23:54.140 --> 23:55.140
这就是

23:55.140 --> 23:56.140
这一块

23:56.140 --> 23:57.140
搞清楚

23:57.140 --> 23:58.140
好

23:58.140 --> 23:59.140
咱们再来一个例子

23:59.140 --> 24:01.140
我能不能把get成

24:01.140 --> 24:02.140
做成一个

24:02.140 --> 24:04.140
比较正常的

24:04.140 --> 24:06.140
用模拟出一个正常的属性呢

24:06.140 --> 24:08.140
又看是这样子

24:08.140 --> 24:09.140
set

24:09.140 --> 24:10.140
我们给它复制的时候

24:10.140 --> 24:12.140
你不是把值传给我了吗

24:12.140 --> 24:13.140
OK

24:13.140 --> 24:14.140
那么我运行这个函数

24:14.140 --> 24:15.140
运行了之后

24:15.140 --> 24:16.140
我干嘛呢

24:16.140 --> 24:17.140
我就给OB借里面

24:17.140 --> 24:19.140
一个属性A复制

24:19.140 --> 24:20.140
复制微发

24:20.140 --> 24:21.140
读去的时候

24:21.140 --> 24:22.140
我就把这个复

24:22.140 --> 24:23.140
读取出来

24:23.140 --> 24:24.140
你看一下这代码

24:24.140 --> 24:25.140
好好看一下

24:25.140 --> 24:26.140
行不行呢

24:26.140 --> 24:28.140
这代码行不行呢

24:29.140 --> 24:30.140
这代码是不行的

24:30.140 --> 24:31.140
我知道你的想法

24:31.140 --> 24:32.140
但是你想法很好

24:32.140 --> 24:33.140
但是呢

24:33.140 --> 24:35.140
这个代码实际上是行不通的

24:35.140 --> 24:36.140
为什么行不通呢

24:36.140 --> 24:37.140
我都不敢保存

24:37.140 --> 24:39.140
因为保存的瀏覽器就卡死了

24:41.140 --> 24:42.140
它还没卡死

24:42.140 --> 24:43.140
因为我这里没对它进行操作

24:43.140 --> 24:44.140
对吧

24:44.140 --> 24:46.140
我们这里输出OB借了A吧

24:46.140 --> 24:48.140
我们输出OB借了A

24:48.140 --> 24:49.140
你看

24:50.140 --> 24:52.140
是不是卡死了

24:52.140 --> 24:53.140
一直在运行

24:53.140 --> 24:54.140
一直在运行

24:54.140 --> 24:55.140
无限帝规了

24:55.140 --> 24:56.140
这怎么回事呢

24:56.140 --> 24:57.140
我这里把关掉了

24:58.140 --> 24:59.140
关掉

25:04.140 --> 25:05.140
怎么回事呢

25:05.140 --> 25:06.140
你来想一想

25:06.140 --> 25:08.140
我们现在是不是在读OB借了A

25:08.140 --> 25:10.140
OB借了A是不是要运行Gate

25:10.140 --> 25:12.140
出来运行Gate

25:12.140 --> 25:13.140
好Gate里面干嘛

25:13.140 --> 25:14.140
是不是又在读OB借了A

25:14.140 --> 25:16.140
把OB借了A的读出来

25:16.140 --> 25:17.140
然后返回对吧

25:17.140 --> 25:18.140
把它的值返回

25:18.140 --> 25:19.140
是不是又要读OB借了A

25:19.140 --> 25:21.140
那么要算这个表拉斯的值

25:21.140 --> 25:22.140
算这个表拉斯的值

25:22.140 --> 25:23.140
是不是又要运行Gate

25:23.140 --> 25:24.140
好

25:24.140 --> 25:25.140
下一次运行Gate了

25:25.140 --> 25:26.140
上一次都还没算出来

25:26.140 --> 25:27.140
下一次

25:27.140 --> 25:29.140
因为他要把Gate运行之后才能算出来

25:29.140 --> 25:30.140
那么又运行Gate的时候

25:30.140 --> 25:31.140
是不是又到这

25:31.140 --> 25:32.140
又要读OB借了A

25:32.140 --> 25:33.140
是不是又要运行

25:33.140 --> 25:35.140
是不是无限这样下去了

25:35.140 --> 25:36.140
那么同样的道理

25:36.140 --> 25:38.140
set里边是不是一样的道理

25:38.140 --> 25:39.140
如果说我们给它复制的话

25:39.140 --> 25:40.140
同样会卡死

25:40.140 --> 25:41.140
为什么呢

25:41.140 --> 25:43.140
这里会导致无限帝规

25:43.140 --> 25:44.140
同样会卡死

25:44.140 --> 25:45.140
为什么呢

25:45.140 --> 25:47.140
因为我们在给它复制的时候

25:47.140 --> 25:48.140
是不是要运行set

25:48.140 --> 25:49.140
运行set的时候

25:49.140 --> 25:50.140
是不是又要重新复制

25:50.140 --> 25:51.140
是不是又要运行set

25:51.140 --> 25:52.140
对吧

25:52.140 --> 25:54.140
那么就无限帝规下去了

25:55.140 --> 25:56.140
所以说一定要注意

25:56.140 --> 25:59.140
如果说你使用一个存取器属性的话

25:59.140 --> 26:02.140
千万不要在Gate里边去读取

26:02.140 --> 26:04.140
这样的方式在读取属性本身

26:04.140 --> 26:06.140
同样的你在set里边

26:06.140 --> 26:08.140
也同样不要去设置属性本身

26:09.140 --> 26:10.140
我们应该怎么做呢

26:10.140 --> 26:12.140
才能做成一个正常的属性

26:12.140 --> 26:13.140
其实很简单

26:13.140 --> 26:14.140
怎么做呢

26:14.140 --> 26:16.140
你复制的时候怎么复制呢

26:16.140 --> 26:17.140
你这样复制

26:17.140 --> 26:20.140
你可以一个别的属性复制不完的

26:20.140 --> 26:21.140
比如一个下滑线A

26:21.140 --> 26:23.140
下滑线A给我没关系吧

26:23.140 --> 26:25.140
它是一个普通的属性

26:25.140 --> 26:27.140
它只是一块内存空间

26:27.140 --> 26:29.140
我们把这个纸放到内存空间里边

26:29.140 --> 26:32.140
我在读取属性A的时候

26:32.140 --> 26:34.140
我把内存空间的纸拿出来

26:34.140 --> 26:36.140
随便夹个属性

26:36.140 --> 26:37.140
这就完了

26:37.140 --> 26:39.140
这样就做出一个正常属性了

26:39.140 --> 26:40.140
看一下吧

26:41.140 --> 26:42.140
我们现在OB借掉A

26:42.140 --> 26:43.140
给它复制为10

26:43.140 --> 26:45.140
然后输出OB借掉A

26:46.140 --> 26:47.140
保存

26:48.140 --> 26:49.140
就做出一个正常属性了

26:51.140 --> 26:52.140
这里捡它

26:54.140 --> 26:55.140
你看

26:55.140 --> 26:57.140
是不是在复制的时候

26:57.140 --> 26:59.140
相当于是运行了这次函数

26:59.140 --> 27:00.140
这次函数它就把纸放到哪儿呢

27:00.140 --> 27:02.140
放到另外一个属性里边去了

27:02.140 --> 27:04.140
放到另外一个属性里边去了

27:04.140 --> 27:05.140
占存 帮我们存一下

27:05.140 --> 27:07.140
因为我们没有内存空间

27:07.140 --> 27:08.140
那么你有

27:08.140 --> 27:09.140
你是个普通属性

27:09.140 --> 27:10.140
OK 你帮我存一下

27:11.140 --> 27:12.140
那么我们读取属性的时候

27:12.140 --> 27:14.140
是不是遇到的这次函数

27:14.140 --> 27:15.140
运行的这次函数

27:15.140 --> 27:17.140
是不是把内存空间的纸取出来

27:17.140 --> 27:19.140
所以说就变成一个正常属性了

27:19.140 --> 27:22.140
那么把它变成正常属性不仅如此

27:22.140 --> 27:24.140
而且你看我们的属性

27:24.140 --> 27:26.140
现在由于无论是读取

27:26.140 --> 27:28.140
还是复制

27:28.140 --> 27:30.140
是不是都会经过一个函数

27:30.140 --> 27:32.140
于是从此以后

27:32.140 --> 27:35.140
你针对这个属性的复制和读取

27:35.140 --> 27:38.140
会受到某函数的控制

27:38.140 --> 27:42.140
这就是存取器属性最大的意义

27:43.140 --> 27:49.140
存取器属性最大的意义

27:49.140 --> 27:54.140
在于可以控制属性的读取和复制

27:54.140 --> 27:56.140
因为你无论是怎么复制的

27:56.140 --> 27:59.140
只要你一复制一定运行设计方法

27:59.140 --> 28:00.140
那么在方法里面

28:00.140 --> 28:02.140
我们就可以做一些别的事情来控制

28:02.140 --> 28:04.140
你要读这个属性的时候

28:04.140 --> 28:06.140
一定运行的是设计方法

28:06.140 --> 28:08.140
那么我们就可以在设计方法里面

28:08.140 --> 28:09.140
来控制

28:09.140 --> 28:11.140
比方说我举个例子

28:13.140 --> 28:17.100
好 接下来我们看一下

28:17.100 --> 28:19.100
我们这里有个对象

28:20.100 --> 28:21.100
这个对象里面

28:22.100 --> 28:24.100
有一个Name属性

28:25.100 --> 28:27.100
还有一个年龄属性

28:27.100 --> 28:28.100
年龄属性

28:28.100 --> 28:30.100
因为年龄它是有一定取之判为的

28:30.100 --> 28:32.100
如果说你不控制的话

28:32.100 --> 28:34.100
那么我给年龄复制复的复一千

28:34.100 --> 28:35.100
可不可以复制

28:35.100 --> 28:36.100
有啥问题呢

28:36.100 --> 28:38.100
随便复制 没有任何问题

28:38.100 --> 28:40.100
你没法控制它

28:40.100 --> 28:42.100
但是我们有了define property之后

28:42.100 --> 28:43.100
我们就可以控制它了

28:43.100 --> 28:44.100
它就相当于是咋了

28:44.100 --> 28:46.100
就相当于我们购造函数里面

28:46.100 --> 28:49.100
我之前学过内里面的getter和setter

28:49.100 --> 28:50.100
就是那个玩意

28:50.100 --> 28:51.100
其实就是那个玩意

28:52.100 --> 28:53.100
它是个语法堂

28:53.100 --> 28:56.100
它其实本质上就是用define property

28:56.100 --> 28:57.100
那么我们现在可以控制它

28:57.100 --> 28:58.100
怎么来控制它呢

28:58.100 --> 29:01.100
我们用objects Define property

29:01.100 --> 29:03.100
对象传进去属性A级

29:03.100 --> 29:04.100
加个属性A级

29:04.100 --> 29:07.100
然后属性A级是一个存取器属性

29:07.100 --> 29:09.100
get的时候我怎么样呢

29:10.100 --> 29:13.100
我返回一个OB界点

29:13.100 --> 29:15.100
下滑线A级

29:15.100 --> 29:17.100
set的时候你给我传一个纸进来

29:17.100 --> 29:18.100
我干嘛呢

29:18.100 --> 29:20.100
我把OB界点A级

29:20.100 --> 29:22.100
给它复为这个纸

29:22.100 --> 29:24.100
就做这么一个简单的处理

29:24.100 --> 29:25.100
现在我们看一下

29:25.100 --> 29:27.100
如果说我们给OB界

29:27.100 --> 29:29.100
复制一个属性A级为10

29:29.100 --> 29:31.100
然后再输出OB界点A级

29:31.100 --> 29:33.100
那么现在你看一下

29:33.100 --> 29:37.140
现在做成那个

29:37.140 --> 29:39.140
看上去是比较正常的一个属性

29:39.140 --> 29:40.140
复制为10

29:40.140 --> 29:43.140
那我们现在复制为負的1000

29:45.140 --> 29:46.140
能复制吗

29:46.140 --> 29:47.140
也可以

29:47.140 --> 29:48.140
为什么呢

29:48.140 --> 29:49.140
因为复制的时候

29:49.140 --> 29:50.140
运行set对吧

29:50.140 --> 29:51.140
我就把负的1000

29:51.140 --> 29:52.140
保存到这个地方了

29:52.140 --> 29:53.140
当你要读的时候

29:53.140 --> 29:54.140
我就把这个地方取出来

29:54.140 --> 29:55.140
给你返回给你

29:55.140 --> 29:57.140
那我们怎么控制呢

29:57.140 --> 29:59.140
因为我们现在写成了函数了

29:59.140 --> 30:00.140
以前的某一个对象

30:00.140 --> 30:01.140
你给属性复制

30:01.140 --> 30:02.140
我们知不知道

30:02.140 --> 30:03.140
我鬼知道你给属性复制了

30:03.140 --> 30:05.140
我不可能有一个函

30:05.140 --> 30:06.140
不可能有一个函数

30:06.140 --> 30:08.140
我知道A你给这个对象复制了

30:08.140 --> 30:09.140
我可以监控它对吧

30:09.140 --> 30:10.140
不可能有一个函数

30:10.140 --> 30:11.140
可以监控它的

30:11.140 --> 30:12.140
但是现在可以监控了

30:12.140 --> 30:14.140
因为我们有get和set的方法

30:14.140 --> 30:16.140
你一复制一定运行这个方法

30:16.140 --> 30:18.140
那我们就在这里进行验证

30:18.140 --> 30:19.140
你给我的值

30:19.140 --> 30:21.140
如果说小于了0

30:21.140 --> 30:22.140
我就干嘛呢

30:22.140 --> 30:23.140
把它复制为0

30:23.140 --> 30:24.140
可以做任何事情

30:24.140 --> 30:25.140
甚至你可以在这里报错

30:25.140 --> 30:26.140
都可以

30:26.140 --> 30:27.140
LC

30:27.140 --> 30:28.140
如果你给我的值

30:28.140 --> 30:29.140
大于了2半

30:29.140 --> 30:31.140
那么我就复制为2半

30:31.140 --> 30:32.140
最大2半

30:32.140 --> 30:33.140
好

30:33.140 --> 30:34.140
那么这样子

30:34.140 --> 30:35.140
是不是保证了

30:35.140 --> 30:36.140
你的复制是正确了

30:36.140 --> 30:37.140
你的值是正确了

30:37.140 --> 30:38.140
那么我们最后

30:38.140 --> 30:39.140
就把正确的值

30:39.140 --> 30:40.140
给这个A级

30:40.140 --> 30:41.140
这么个意思

30:41.140 --> 30:42.140
还有你还可以

30:42.140 --> 30:43.140
在这里判断内形

30:43.140 --> 30:44.140
你给我的是什么内形

30:44.140 --> 30:45.140
比方说你给我的

30:45.140 --> 30:46.140
内形的话

30:46.140 --> 30:47.140
我还可以报错

30:47.140 --> 30:48.140
比方说

30:48.140 --> 30:49.140
如果说你type

30:49.140 --> 30:50.140
不等于

30:50.140 --> 30:51.140
不等于什么

30:51.140 --> 30:52.140
number

30:52.140 --> 30:53.140
你不是一个数字

30:53.140 --> 30:54.140
那么报错

30:54.140 --> 30:55.140
sru

30:55.140 --> 30:56.140
u

30:56.140 --> 30:58.140
type error

30:58.140 --> 30:59.140
就是

30:59.140 --> 31:03.140
年龄必须是一个数字

31:03.140 --> 31:04.140
那么这样子

31:04.140 --> 31:05.140
你看一下

31:05.140 --> 31:07.140
后边的对象

31:07.140 --> 31:09.140
就是金刚不坏自身了

31:09.140 --> 31:10.140
至少这个属性

31:10.140 --> 31:11.140
是金刚不坏的

31:11.140 --> 31:12.140
为什么

31:12.140 --> 31:13.140
你不可能乱来

31:13.140 --> 31:14.140
你不可能乱来

31:14.140 --> 31:15.140
这个属性

31:15.140 --> 31:16.140
你看我给他

31:16.140 --> 31:17.140
复制为复以前

31:17.140 --> 31:18.140
结果输出什么

31:18.140 --> 31:19.140
输出零

31:19.140 --> 31:20.140
为什么

31:20.140 --> 31:22.140
因为我这里控制了的

31:22.140 --> 31:23.140
控制了的

31:23.140 --> 31:24.140
再比方说

31:24.140 --> 31:25.140
我们这里

31:25.140 --> 31:26.140
给他复为1000

31:26.140 --> 31:27.140
你看

31:27.140 --> 31:28.140
是不是得到是200

31:28.140 --> 31:29.140
因为不可能超过200

31:29.140 --> 31:31.140
如果给他一个字乎串

31:31.140 --> 31:32.140
给他一个挖起发刀的东西

31:32.140 --> 31:33.140
年龄能是一个字乎串吗

31:33.140 --> 31:34.140
不能

31:34.140 --> 31:35.140
于是他报错了

31:35.140 --> 31:37.140
年龄必须是一个数字

31:37.140 --> 31:38.140
以前能做到吗

31:38.140 --> 31:39.140
以前是

31:39.140 --> 31:40.140
想想以前能做到吗

31:40.140 --> 31:41.140
这绝对做不到的

31:41.140 --> 31:42.140
绝对做不到的

31:42.140 --> 31:44.140
那么现在可以做到了

31:44.140 --> 31:45.140
面对什么

31:45.140 --> 31:46.140
好

31:46.140 --> 31:47.140
这是属性描述服

31:47.140 --> 31:48.140
好

31:48.140 --> 31:49.140
咱们再来看一下

31:49.140 --> 31:52.920
再来看一个例子

31:52.920 --> 31:53.920
举个例子

31:53.920 --> 31:54.920
比方说

31:54.920 --> 31:55.920
我们页面上

31:55.920 --> 31:56.920
有这么一些元素

31:59.920 --> 32:01.920
有个P元素吧

32:01.920 --> 32:02.920
P元素

32:02.920 --> 32:03.920
好

32:03.920 --> 32:04.920
接下来

32:04.920 --> 32:05.920
我们给P元素里面

32:05.920 --> 32:06.920
有些值

32:06.920 --> 32:08.920
一个是

32:08.920 --> 32:10.920
年龄

32:10.920 --> 32:11.920
姓名

32:12.920 --> 32:13.920
好

32:13.920 --> 32:14.920
后边

32:14.920 --> 32:15.920
IT

32:15.920 --> 32:17.920
Name

32:17.920 --> 32:18.920
来吧

32:18.920 --> 32:20.920
就一个姓名和年龄得了

32:20.920 --> 32:24.870
姓名和年龄

32:24.870 --> 32:26.870
这个人是AG

32:27.870 --> 32:28.870
有这么两个元素

32:28.870 --> 32:29.870
对吧

32:29.870 --> 32:31.870
我们这里分别可以得到span

32:31.870 --> 32:32.870
可以得到span

32:32.870 --> 32:33.870
Name

32:33.870 --> 32:34.870
Document

32:34.870 --> 32:35.870
getElement

32:35.870 --> 32:36.870
ID

32:36.870 --> 32:37.870
好

32:37.870 --> 32:38.870
同样的

32:38.870 --> 32:39.870
可以得到span

32:39.870 --> 32:40.870
AG

32:40.870 --> 32:41.870
好

32:41.870 --> 32:42.870
接下来我们做啥

32:42.870 --> 32:43.870
我们这里有个对象

32:43.870 --> 32:44.870
U字

32:44.870 --> 32:45.870
它有两个属性

32:45.870 --> 32:47.870
一个是Name属性

32:47.870 --> 32:48.870
一个是

32:51.870 --> 32:52.870
外接

32:52.870 --> 32:53.870
AG属性

32:53.870 --> 32:54.870
比如说100

32:55.870 --> 32:56.870
有这么个对象

32:56.870 --> 32:57.870
那么现在这个对象

32:57.870 --> 32:58.870
跟页面上之间

32:58.870 --> 33:00.870
是不是脱离的

33:00.870 --> 33:01.870
是不是脱离掉的

33:01.870 --> 33:02.870
对不对

33:02.870 --> 33:03.870
这个对象的属性

33:03.870 --> 33:04.870
跟这个

33:04.870 --> 33:05.870
页面上的这些元素里面

33:05.870 --> 33:06.870
你看这里

33:06.870 --> 33:07.870
肯定要显示个对象的

33:07.870 --> 33:08.870
什么Name属性

33:08.870 --> 33:10.870
这里要显示个对象的AG属性

33:10.870 --> 33:11.870
是不是脱离的

33:11.870 --> 33:12.870
那么我们

33:12.870 --> 33:13.870
如果说

33:13.870 --> 33:14.870
如果说不做处理的话

33:14.870 --> 33:15.870
能不能操作了

33:15.870 --> 33:16.870
可以操作

33:16.870 --> 33:17.870
当我们改这个对象的时候

33:17.870 --> 33:19.870
我们要手动的去找到

33:19.870 --> 33:20.870
这个Span元素

33:20.870 --> 33:22.870
那么把它的相应位置

33:22.870 --> 33:23.870
紧修改

33:23.870 --> 33:24.870
那么我们修改

33:24.870 --> 33:25.870
页面的时候

33:25.870 --> 33:26.870
我们要同时的

33:26.870 --> 33:27.870
把这个对象修改

33:27.870 --> 33:28.870
因为这两个是一个东西

33:28.870 --> 33:29.870
一个是用于显示的

33:29.870 --> 33:30.870
一个是内部的数据

33:30.870 --> 33:31.870
对吧

33:31.870 --> 33:32.870
两个的逻辑是一样的

33:32.870 --> 33:33.870
是对应的

33:34.870 --> 33:35.870
那么这样的

33:35.870 --> 33:36.870
就会有些麻烦

33:36.870 --> 33:37.870
为什么麻烦了

33:37.870 --> 33:38.870
比方说现在

33:38.870 --> 33:39.870
你现在看这个页面

33:39.870 --> 33:40.870
页面上的显示

33:40.870 --> 33:41.870
跟我们的对象的

33:41.870 --> 33:42.870
里面的数据

33:42.870 --> 33:43.870
是一样的吗

33:43.870 --> 33:44.870
肯定不一样

33:44.870 --> 33:45.870
这里啥都没显示

33:45.870 --> 33:46.870
这里是外接

33:46.870 --> 33:47.870
这里啥都没显示

33:47.870 --> 33:48.870
这里是一版

33:48.870 --> 33:49.870
对吧

33:49.870 --> 33:50.870
现在你是没有把这两个

33:50.870 --> 33:51.870
关联起来的

33:51.870 --> 33:53.870
那我们就可以利用

33:53.870 --> 33:54.870
我们刚才学过的

33:54.870 --> 33:55.870
define property

33:55.870 --> 33:57.870
来搞定这件事情

33:57.870 --> 33:58.870
怎么搞定的

33:58.870 --> 33:59.870
你看我把对象留空

33:59.870 --> 34:01.870
我们应该定义两个属性

34:01.870 --> 34:02.870
用define property

34:02.870 --> 34:03.870
定义两个属性

34:03.870 --> 34:04.870
一个是对象

34:04.870 --> 34:05.870
一个是属性名

34:06.870 --> 34:07.870
好

34:07.870 --> 34:08.870
这个属性很有意思

34:08.870 --> 34:09.870
或者说

34:10.870 --> 34:11.870
properties

34:11.870 --> 34:12.870
一起来定义

34:14.870 --> 34:15.870
同时对应多个属性的

34:15.870 --> 34:16.870
描述服

34:16.870 --> 34:18.870
一个是name属性

34:18.870 --> 34:20.870
一个是a级属性

34:20.870 --> 34:21.870
首先是name属性

34:21.870 --> 34:22.870
name属性

34:22.870 --> 34:23.870
我给它写一个get

34:24.870 --> 34:26.870
当我们读这个name属性的时候

34:26.870 --> 34:27.870
我读的是啥

34:27.870 --> 34:28.870
读的是界面上的

34:28.870 --> 34:30.870
span元素里边的东西

34:30.870 --> 34:31.870
返回的是什么

34:31.870 --> 34:33.870
返回的是span name

34:33.870 --> 34:35.870
inner text

34:35.870 --> 34:36.870
读的是什么

34:36.870 --> 34:37.870
读的是界面上的

34:37.870 --> 34:38.870
span元素里边的东西

34:39.870 --> 34:40.870
然后我们如果说

34:40.870 --> 34:42.870
给这个属性负值的时候

34:42.870 --> 34:43.870
如果说我们要

34:43.870 --> 34:45.870
给这个name属性负值的时候

34:45.870 --> 34:46.870
我实际上是给谁负值

34:46.870 --> 34:47.870
实际上是给他负值

34:48.870 --> 34:49.870
实际上是给他负值

34:49.870 --> 34:50.870
你看没

34:50.870 --> 34:51.870
是不是搞定了

34:52.870 --> 34:53.870
同样的道理

34:53.870 --> 34:54.870
a级这里是不是一样的

34:54.870 --> 34:55.870
a级这里

34:55.870 --> 34:56.870
a级这里

34:57.870 --> 34:58.870
我们把它得到的是什么

34:58.870 --> 35:00.870
span a级的

35:01.870 --> 35:02.870
a级的什么

35:03.870 --> 35:04.870
inner text

35:05.870 --> 35:06.870
把负值为

35:07.870 --> 35:08.870
得到的是这个

35:08.870 --> 35:09.870
然后负值的时候

35:09.870 --> 35:10.870
是负值这个

35:11.870 --> 35:12.870
看没

35:12.870 --> 35:13.870
是不是我们现在就把

35:13.870 --> 35:14.870
堆箱里面的属性

35:14.870 --> 35:15.870
跟这个元素关联起来了

35:15.870 --> 35:17.870
那么从此以后

35:17.870 --> 35:19.870
你想不让他们统一都不行

35:19.870 --> 35:20.870
都不可能

35:20.870 --> 35:21.870
绝对不可能的

35:21.870 --> 35:22.870
那么咱们看一下

35:25.180 --> 35:26.180
现在页面上没有

35:26.180 --> 35:27.180
没有

35:27.180 --> 35:28.180
那么我们得到这个有的

35:28.180 --> 35:29.180
看一下吧

35:29.180 --> 35:30.180
有的是不是里面

35:30.180 --> 35:31.180
啥都没有

35:31.180 --> 35:32.180
有两个属性a级和name

35:32.180 --> 35:33.180
但是啥都没有

35:33.180 --> 35:34.180
对不对

35:34.180 --> 35:35.180
啥都看不见

35:35.180 --> 35:36.180
然后比方说

35:36.180 --> 35:37.180
我们给有的

35:37.180 --> 35:38.180
属性a级负值

35:38.180 --> 35:39.180
负值为10

35:39.180 --> 35:40.180
给对象的属性负值的

35:40.180 --> 35:42.180
它是不是也变了

35:42.180 --> 35:43.180
页面上也变了

35:43.180 --> 35:44.180
这永远是统一的

35:44.180 --> 35:45.180
为什么变了呢

35:45.180 --> 35:47.180
因为我给a级属性负值的时候

35:47.180 --> 35:48.180
是不是运行了这个set

35:48.180 --> 35:49.180
这个set里面

35:49.180 --> 35:50.180
是把它的内容改过了

35:50.180 --> 35:51.180
因为这是个函数

35:51.180 --> 35:53.180
我们可以做任何事情

35:53.180 --> 35:54.180
再比方说

35:54.180 --> 35:57.180
我们要读给这个n属性负值

35:57.180 --> 35:58.180
n属性负值

35:58.180 --> 35:59.180
你看

35:59.180 --> 36:00.180
这里是不是也跟着变了

36:00.180 --> 36:01.180
对吧

36:01.180 --> 36:02.180
而且不仅如此

36:02.180 --> 36:03.180
那我这里是不是还可以验证

36:03.180 --> 36:04.180
对吧

36:04.180 --> 36:05.180
我们把之前的验证规则

36:05.180 --> 36:06.180
是不是可以放过来

36:06.180 --> 36:07.180
对吧

36:07.180 --> 36:08.180
还有这里get的时候

36:08.180 --> 36:09.180
由于它的页面内容

36:09.180 --> 36:10.180
是一个字不错

36:10.180 --> 36:12.180
我们这里可以把它转换成数字

36:12.180 --> 36:13.180
对不对

36:13.180 --> 36:14.180
加个加号

36:14.180 --> 36:15.180
把它转换成数字

36:15.180 --> 36:16.180
你看

36:16.180 --> 36:17.180
现在U字

36:17.180 --> 36:18.180
A级

36:18.180 --> 36:19.180
你看是0

36:19.180 --> 36:20.180
对不对

36:20.180 --> 36:21.180
U要点A级10

36:21.180 --> 36:22.180
U

36:22.180 --> 36:23.180
那么

36:23.180 --> 36:24.180
这里U要点A级10

36:24.180 --> 36:25.180
对不对

36:25.180 --> 36:26.180
没问题吧

36:26.180 --> 36:27.180
OK

36:27.180 --> 36:28.180
这就是

36:28.180 --> 36:29.180
这一块

36:29.180 --> 36:31.180
属性描述服的汉译

36:31.180 --> 36:32.180
实际上

36:32.180 --> 36:35.180
我们之前用的很多地方

36:35.180 --> 36:37.180
只是你自己不知道而已

36:37.180 --> 36:39.180
它都内部都用到了这个东西

36:39.180 --> 36:41.180
都用到纯去器属性

36:41.180 --> 36:42.180
比方说我们之前的

36:42.180 --> 36:43.180
就比方说我们这个

36:43.180 --> 36:44.180
一个10变元素吧

36:44.180 --> 36:45.180
10变

36:45.180 --> 36:46.180
10变LIM

36:46.180 --> 36:47.180
咱们看一下10变LIM

36:47.180 --> 36:48.180
我们用这个console

36:48.180 --> 36:49.180
点DR

36:49.180 --> 36:51.180
把对象结构打印出来

36:51.180 --> 36:52.180
对象结构里面

36:52.180 --> 36:53.180
我们往下找

36:53.180 --> 36:54.180
往下找

36:54.180 --> 36:56.180
它的原型里边

36:56.180 --> 36:58.180
不是有一个属性描述服的汉译

36:58.180 --> 36:59.180
实际上

36:59.180 --> 37:01.180
它的原型里边

37:01.180 --> 37:03.180
不是有一个Inner

37:03.180 --> 37:05.180
看一下

37:05.180 --> 37:06.180
Inner

37:06.180 --> 37:07.180
看

37:07.180 --> 37:08.180
这些属性

37:08.180 --> 37:09.180
你会看到这些属性

37:09.180 --> 37:10.180
有点奇怪没

37:10.180 --> 37:11.180
这些属性后面

37:11.180 --> 37:12.180
都有三个底

37:12.180 --> 37:13.180
对吧

37:13.180 --> 37:14.180
对三个底

37:14.180 --> 37:15.180
你指着它会告诉你

37:15.180 --> 37:16.180
invoke

37:16.180 --> 37:17.180
invoke什么意思

37:17.180 --> 37:18.180
调用property

37:18.180 --> 37:19.180
getter

37:19.180 --> 37:20.180
什么意思

37:20.180 --> 37:22.180
调用属性的get

37:22.180 --> 37:23.180
getter方法

37:23.180 --> 37:24.180
啥意思

37:24.180 --> 37:25.180
就是这个属性

37:25.180 --> 37:27.180
就是一个纯去器属性

37:27.180 --> 37:29.180
你看我们刚才写的那个

37:29.180 --> 37:30.180
User

37:30.180 --> 37:31.180
展开过后

37:31.180 --> 37:32.180
你看是不是

37:32.180 --> 37:33.180
A級Name

37:33.180 --> 37:34.180
对吧

37:34.180 --> 37:35.180
都是纯去器属性

37:35.180 --> 37:36.180
为什么呢

37:36.180 --> 37:37.180
因为它这里没法跟它显示出来

37:37.180 --> 37:39.180
因为一显示就要调用方法

37:39.180 --> 37:41.180
调用方法是

37:41.180 --> 37:42.180
是一个实时的内容

37:42.180 --> 37:43.180
对吧

37:43.180 --> 37:44.180
我还不知道一开始要不要调用

37:44.180 --> 37:46.180
那么你需要用这个属性的时候

37:46.180 --> 37:47.180
你点一下

37:47.180 --> 37:49.180
还调用一次方法得到结果

37:49.180 --> 37:50.180
点一下调用方法得到结果

37:50.180 --> 37:52.180
就这么个意思

37:52.180 --> 37:53.180
你看我们的

37:53.180 --> 37:56.180
这些元素里边

37:56.180 --> 37:58.180
其实就是

37:58.180 --> 38:01.180
有很多属性

38:01.180 --> 38:03.180
它都是纯去器属性

38:03.180 --> 38:04.180
为什么它把

38:04.180 --> 38:06.180
综成纯去器属性呢

38:06.180 --> 38:07.180
你想想这个道理

38:07.180 --> 38:08.180
我们给这个

38:08.180 --> 38:09.180
in the attainment

38:09.180 --> 38:10.180
复制的时候

38:10.180 --> 38:11.180
你认为

38:11.180 --> 38:12.180
页面它就跟着变了

38:12.180 --> 38:13.180
但是别人要写

38:13.180 --> 38:14.180
浏览器代码

38:14.180 --> 38:15.180
浏览器底层

38:15.180 --> 38:16.180
它不这样认为

38:16.180 --> 38:17.180
你只是给一个

38:17.180 --> 38:18.180
普通对象的属性复制而已

38:18.180 --> 38:19.180
我要干嘛

38:19.180 --> 38:21.180
我要重新去渲染页面

38:21.180 --> 38:23.180
是不是有个渲染的动作

38:23.180 --> 38:24.180
那么就设计到一个问题

38:24.180 --> 38:26.180
它什么时候知道

38:26.180 --> 38:28.180
你给这个属性复制了呢

38:28.180 --> 38:29.180
它不知道

38:29.180 --> 38:31.180
它只是个对象而已

38:31.180 --> 38:32.180
还有什么区别呢

38:32.180 --> 38:33.180
就是一个普通对象而已

38:33.180 --> 38:34.180
它里面有个属性

38:34.180 --> 38:35.180
叫in the attainment

38:35.180 --> 38:37.180
那我怎么知道

38:37.180 --> 38:38.180
你什么时候给它复制呢

38:38.180 --> 38:41.180
比方说你在写浏览器

38:41.180 --> 38:42.180
你在写浏览器代码

38:42.180 --> 38:44.180
你写了这么一个对象

38:44.180 --> 38:46.180
写了这么一个就是

38:46.180 --> 38:47.180
SPAN元素

38:47.180 --> 38:48.180
dom attainment

38:48.180 --> 38:49.180
就叫它

38:49.180 --> 38:50.180
咋对象呢

38:50.180 --> 38:51.180
对象名字

38:51.180 --> 38:52.180
叫atm span element

38:52.180 --> 38:53.180
对吧

38:53.180 --> 38:55.180
直接写这么一个span对象

38:55.180 --> 38:57.180
构造函数

38:57.180 --> 38:58.180
span

38:58.180 --> 39:00.180
atm element

39:00.180 --> 39:01.180
就随便写个吧

39:01.180 --> 39:03.180
比方说你在写构造函数

39:03.180 --> 39:04.180
那么通过构造函数

39:04.180 --> 39:06.180
是不是可以创建一个

39:06.180 --> 39:07.180
可以创建一个就是什么

39:07.180 --> 39:08.180
span元素

39:08.180 --> 39:09.180
对吧

39:09.180 --> 39:10.180
可以创建一个span元素

39:10.180 --> 39:12.180
atm span element

39:12.180 --> 39:17.880
atm span element

39:17.880 --> 39:18.880
那么通过构造函数

39:18.880 --> 39:20.880
它可以得到一个span对象

39:20.880 --> 39:21.880
一个动物对象

39:21.880 --> 39:22.880
那么动物对象里面

39:22.880 --> 39:23.880
如果说

39:23.880 --> 39:24.880
一个普通属性的话

39:24.880 --> 39:26.880
inner attainment

39:26.880 --> 39:27.880
对吧

39:27.880 --> 39:28.880
会给它设置一个inner attainment

39:28.880 --> 39:29.880
对不对

39:29.880 --> 39:30.880
好

39:30.880 --> 39:31.880
那么将来有一天

39:31.880 --> 39:32.880
有人去创

39:32.880 --> 39:33.880
去给它复制

39:33.880 --> 39:34.880
重新复制的时候

39:34.880 --> 39:35.880
你鬼知道

39:35.880 --> 39:36.880
它给它重新复制的

39:36.880 --> 39:37.880
你根本就不知道

39:37.880 --> 39:38.880
所以说

39:38.880 --> 39:39.880
它要把它做成一个

39:39.880 --> 39:40.880
存取器属性

39:40.880 --> 39:41.880
它怎么做的呢

39:41.880 --> 39:42.880
它这样做的

39:42.880 --> 39:43.880
几个车什么

39:43.880 --> 39:44.880
迪凡

39:44.880 --> 39:45.880
就写个伪代码

39:45.880 --> 39:46.880
就类似的代码

39:46.880 --> 39:47.880
就是把当前对象的

39:47.880 --> 39:48.880
什么属性呢

39:48.880 --> 39:49.880
inner attainment属性

39:49.880 --> 39:50.880
给它变成一个

39:50.880 --> 39:51.880
存取器属性

39:51.880 --> 39:52.880
对吧

39:52.880 --> 39:53.880
变成一个存取器属性

39:53.880 --> 39:55.880
那么存取器属性里面

39:55.880 --> 39:56.880
里边有什么

39:56.880 --> 39:57.880
有get

39:57.880 --> 39:58.880
对吧

39:58.880 --> 39:59.880
那么这个时候

39:59.880 --> 40:00.880
它要做什么呢

40:00.880 --> 40:01.880
它要从页面中

40:01.880 --> 40:05.880
获取页面窗口中

40:05.880 --> 40:08.880
对应的元素的内容

40:08.880 --> 40:09.880
对吧

40:09.880 --> 40:10.880
然后set的时候

40:10.880 --> 40:11.880
干嘛呢

40:11.880 --> 40:12.880
它就干

40:12.880 --> 40:13.880
要做什么

40:13.880 --> 40:16.880
重新渲染页面窗口

40:16.880 --> 40:17.880
对吧

40:17.880 --> 40:18.880
它要做这么一些事

40:18.880 --> 40:19.880
这样子

40:19.880 --> 40:20.880
它才知道你什么时候

40:20.880 --> 40:21.880
给它复制

40:21.880 --> 40:22.880
那读取的时候

40:22.880 --> 40:23.880
我就获取现在的内容

40:23.880 --> 40:24.880
对吧

40:24.880 --> 40:25.880
它就是它底层

40:25.880 --> 40:26.880
就是这么实现的

40:31.190 --> 40:32.190
好

40:32.190 --> 40:33.190
这是关于存取器属性

40:33.190 --> 40:35.190
都是以前的知识

40:35.190 --> 40:37.190
我们主要是这一张

40:37.190 --> 40:38.190
可能会用到

40:38.190 --> 40:39.190
所以给大家回顾一下

