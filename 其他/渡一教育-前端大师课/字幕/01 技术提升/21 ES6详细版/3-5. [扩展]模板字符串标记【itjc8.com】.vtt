WEBVTT

00:01.010 --> 00:04.010
这节课的东西给大家扩展一个知识

00:04.010 --> 00:08.010
这个知识应该说是90%以上的开发者都不太清楚的一个知识

00:08.010 --> 00:10.010
就是模板制不出的标记

00:10.010 --> 00:13.010
由于他平时开发的时候没有那么常见

00:13.010 --> 00:15.010
所以我把它作为扩展课程

00:15.010 --> 00:18.010
凡是扩展课程就是说你可以学 你可以不学

00:18.010 --> 00:21.010
你学了过后你可以在面试的时候吹血流

00:21.010 --> 00:23.010
你能学的话尽量学吧

00:23.010 --> 00:25.010
你不学的话也完全不影响后边的学习

00:25.010 --> 00:28.010
后边我们也不太会用到这个东西

00:28.010 --> 00:29.010
就是模板制不出标记

00:29.010 --> 00:32.010
它什么意思呢 它就是这个意思

00:32.010 --> 00:37.010
就是说有的时候我们可能面临了这么一个需求

00:37.010 --> 00:41.010
表扬我们这里有一个模板制不串

00:41.010 --> 00:43.010
就把上级课拿过来呗

00:43.010 --> 00:47.090
就把上级课拿过来啊

00:47.090 --> 00:49.090
把上级课拿过来得了

00:49.090 --> 00:54.090
我们这里把这东西去掉

00:54.090 --> 00:58.090
好 我们这里把习成一行吧

00:58.090 --> 01:00.090
我们有这么一个模板制不串

01:00.090 --> 01:03.090
我们希望可能希望

01:03.090 --> 01:08.090
把模板制不串进行一些简单的处理

01:08.090 --> 01:10.090
然后再形成一个新的制不串

01:10.090 --> 01:13.090
也就是现在它是用一种默认的处理方式

01:13.090 --> 01:14.090
就是拼接 对吧

01:14.090 --> 01:17.090
它把这个东西拼接这个东西

01:17.090 --> 01:20.090
然后这个东西又去拼接这个东西

01:20.090 --> 01:23.090
对吧 我们希望对这个制不串

01:23.090 --> 01:25.090
做一些简单的处理

01:25.090 --> 01:28.090
不光是拼接那么的简单

01:28.090 --> 01:31.090
我们可能会做一些简单的处理

01:31.090 --> 01:33.090
过后再进行拼接

01:33.090 --> 01:34.090
原来这意思吗

01:34.090 --> 01:38.090
我们可能希望达成了这么一个效果

01:38.090 --> 01:40.090
我这里先讲语法

01:40.090 --> 01:41.090
讲完语法了

01:41.090 --> 01:44.090
我们再说一些比较实用的例子

01:44.090 --> 01:47.090
那么如果我们要处理这个制不串

01:47.090 --> 01:48.090
怎么来处理呢

01:48.090 --> 01:50.090
你只需要在这个制不串前边

01:50.090 --> 01:51.090
加上一个标记

01:51.090 --> 01:55.090
这个标记的名称是一个函数的名称

01:55.090 --> 01:57.090
比方说我们这里

01:57.090 --> 02:00.090
加上一个就是MyTag

02:00.090 --> 02:03.090
直接在制不串前面加上一个标记就行了

02:03.090 --> 02:05.090
那么这个标记是啥意思呢

02:05.090 --> 02:06.090
这个标记呢

02:06.090 --> 02:08.090
当你加这个标记过后

02:08.090 --> 02:09.090
它会这样子来处理

02:09.090 --> 02:11.090
这个制不串它会这样处理

02:11.090 --> 02:13.090
它会把这个制不串进行分割

02:13.090 --> 02:15.090
按照你这里的Border大火号

02:15.090 --> 02:17.090
这个表达是来进行分割

02:17.090 --> 02:19.090
是不是把这个制不串分割成什么了

02:19.090 --> 02:22.090
是不是分割成三个部分

02:22.090 --> 02:24.090
第一个部分 第二个部分

02:24.090 --> 02:26.090
还有最后一个部分

02:26.090 --> 02:27.090
是空制不串

02:27.090 --> 02:29.090
于是它会传入这么一个东西

02:29.090 --> 02:31.090
它会调用这个函数

02:31.090 --> 02:33.090
相当于是什么呢

02:33.090 --> 02:36.090
相当于是Tag

02:36.090 --> 02:37.090
等于什么呢

02:37.090 --> 02:39.090
等于MyTag函数

02:39.090 --> 02:40.090
它是一个函数

02:40.090 --> 02:43.090
然后第一个参数给你传了一个数组进去

02:43.090 --> 02:46.090
第一个参数给你传了一个数组

02:46.090 --> 02:49.090
第一个参数传一个数组的话

02:49.090 --> 02:52.090
那么这里我们可以使用

02:52.090 --> 02:53.090
什么呢

02:53.090 --> 02:55.090
第一个就是

02:55.090 --> 02:58.090
数组的第一项是登革喜欢

02:58.090 --> 03:02.090
数组的第二项是这一部分

03:02.090 --> 03:03.090
明白这个意思吗

03:03.090 --> 03:05.090
数组的第三项是一个空制不串

03:05.090 --> 03:07.090
那如果说最后一个句号

03:07.090 --> 03:09.090
那么它会传入一个句号

03:09.090 --> 03:11.090
明白这个意思吗

03:11.090 --> 03:12.090
看一下

03:12.090 --> 03:14.090
第一个参数 它调用这个函数

03:14.090 --> 03:18.090
第一个参数它会传这个进去

03:18.090 --> 03:20.090
我们把它写到下面吧

03:20.090 --> 03:21.090
它相当于是这个

03:21.090 --> 03:22.090
看到没

03:22.090 --> 03:24.090
然后呢 第二个

03:24.090 --> 03:25.090
后边的参数传啥呢

03:25.090 --> 03:27.090
后边的参数它就传这个值

03:27.090 --> 03:28.090
你这里传出来的值

03:28.090 --> 03:29.090
那么这里呢

03:29.090 --> 03:31.090
得到的是Nav1

03:31.090 --> 03:32.090
对吧

03:32.090 --> 03:34.090
它会把表达式的结果传进去

03:34.090 --> 03:35.090
表达式的结果传进去

03:35.090 --> 03:37.090
就是它相当于是传了一个什么呢

03:37.090 --> 03:39.090
传了一个就是丘葵

03:39.090 --> 03:41.090
传了一个香菜

03:41.090 --> 03:43.090
它是把表达式的结果传进去

03:43.090 --> 03:45.090
后边的参数全是这个

03:45.090 --> 03:47.090
能看懂吗

03:47.090 --> 03:49.090
能不能看懂

03:49.090 --> 03:51.090
那么它就相当于是来调用这个函数

03:51.090 --> 03:53.090
把这个函数的反回结果

03:53.090 --> 03:55.090
复制给这个支付串

03:55.090 --> 03:57.090
你如果这样子写的话

03:57.090 --> 03:59.090
就相当于是下面这种写法

03:59.090 --> 04:01.090
相当于是下面这种写法

04:01.090 --> 04:02.090
好 那么也就是说

04:02.090 --> 04:04.090
我们得有这么一个函数

04:04.090 --> 04:06.090
得有这么一个函数做支撑

04:06.090 --> 04:07.090
那么我们这里要写这个函数

04:07.090 --> 04:08.090
如果说你不写这个函数的话

04:08.090 --> 04:09.090
你看一下

04:09.090 --> 04:11.090
我们这里运行出来吧

04:11.090 --> 04:15.300
关闭一下标题

04:15.300 --> 04:17.300
看控制台

04:17.300 --> 04:18.300
什么

04:18.300 --> 04:19.300
Matec is not defined

04:19.300 --> 04:21.300
它就是说你这个标记

04:21.300 --> 04:23.300
这个函数是没有定义的

04:23.300 --> 04:25.300
那么我们现在就定义一下这个函数

04:25.300 --> 04:27.300
Matec

04:27.300 --> 04:29.300
那么第一个参数是这个数主

04:29.300 --> 04:31.300
是不是个数主

04:31.300 --> 04:33.300
parts

04:33.300 --> 04:35.300
表示这个支付串有哪些部分

04:35.300 --> 04:37.300
被分割成了哪些部分

04:37.300 --> 04:39.300
我们这里就直接输出这个数主

04:39.300 --> 04:41.300
直接输出 你看一下parts是啥

04:41.300 --> 04:43.300
你看一下这个函数有没有调用

04:43.300 --> 04:45.300
保存

04:45.300 --> 04:47.300
第一个参数是不是

04:47.300 --> 04:49.300
分割成这么几个部分了

04:49.300 --> 04:51.300
第三个部分

04:51.300 --> 04:53.300
分割成这么一个玩意了

04:53.300 --> 04:55.300
没问题吧

04:55.300 --> 04:57.300
没问题

04:57.300 --> 04:59.300
分割成这么一些部分了

04:59.300 --> 05:01.300
而且它这里输出了Tex

05:01.300 --> 05:03.300
你看一下

05:03.300 --> 05:05.300
为什么是undefend

05:05.300 --> 05:07.300
因为你这里返回的是undefend

05:07.300 --> 05:09.300
你这里没返回

05:09.300 --> 05:11.300
它返回的就是undefend

05:11.300 --> 05:13.300
它会把函数调用了返回结果

05:13.300 --> 05:15.300
付出这个支付串

05:15.300 --> 05:17.300
那么你这里想返回什么了

05:17.300 --> 05:19.300
你得到的就是个对象

05:19.300 --> 05:21.300
你想返回什么就返回什么

05:21.300 --> 05:23.300
就是你完全可以自定义这些模板

05:23.300 --> 05:25.300
完全控制这个模板的目的

05:25.300 --> 05:27.300
那么后续参数是啥呢

05:27.300 --> 05:29.300
比方说

05:29.300 --> 05:31.300
后续参数

05:31.300 --> 05:33.300
二

05:33.300 --> 05:35.300
你看一下

05:35.300 --> 05:37.300
我们这里输出parts

05:37.300 --> 05:39.300
再输出

05:39.300 --> 05:41.300
二

05:41.300 --> 05:43.300
你看一下

05:43.300 --> 05:45.300
是不是得到了秋葵和香菜了

05:45.300 --> 05:47.300
是不是相当于是这样调用了

05:47.300 --> 05:49.300
对比一下上面的

05:49.300 --> 05:51.300
得到这个Tex的结果

05:51.300 --> 05:53.300
上面的代码就相当于是下面的代码

05:53.300 --> 05:55.300
而我们在写这个标记的时候

05:55.300 --> 05:57.300
往往是希望达到一个通用的目的

05:57.300 --> 05:59.300
我也不太清楚

05:59.300 --> 06:01.300
这个支付串里边分割的那些部分

06:01.300 --> 06:03.300
有多少个差值

06:03.300 --> 06:05.300
因为我这里就好像知道了

06:05.300 --> 06:07.300
它有两个差值

06:07.300 --> 06:09.300
差入了一 差入了二

06:09.300 --> 06:11.300
但是我其实很多时候是不知道差入了多少个值的

06:11.300 --> 06:13.300
那么这个时候怎么办呢

06:13.300 --> 06:15.300
我们来输出一下argument

06:15.300 --> 06:17.300
就是输出一下

06:17.300 --> 06:19.300
所有的参数

06:19.300 --> 06:21.300
你看argument 第一个参数是不是个数组

06:21.300 --> 06:23.300
第二个参数是不是

06:23.300 --> 06:25.300
后边的参数是秋葵香菜

06:25.300 --> 06:27.300
那么我们只需要把第一个参数去掉

06:27.300 --> 06:29.300
我们把它snice

06:29.300 --> 06:31.300
把它转换成数组

06:31.300 --> 06:33.300
把argument转换成数组

06:33.300 --> 06:35.300
array

06:35.300 --> 06:37.300
prototype

06:37.300 --> 06:41.250
snice

06:41.250 --> 06:43.250
把argument转换成数组

06:43.250 --> 06:45.250
snice

06:45.250 --> 06:47.250
这里写1

06:47.250 --> 06:49.250
从下标为1的位置开始

06:49.250 --> 06:51.250
我们这里得到

06:51.250 --> 06:53.250
得到rest

06:53.250 --> 06:55.250
剩余的参数

06:55.250 --> 06:57.250
我们是不是可以这样子

06:57.250 --> 06:59.250
就可以得到剩余的参数的数组了

07:01.250 --> 07:03.250
第一个参数是now

07:03.250 --> 07:05.250
第一个参数是this

07:05.250 --> 07:07.250
我看一下

07:07.250 --> 07:09.250
snice

07:09.250 --> 07:11.250
prototype

07:11.250 --> 07:14.750
等下

07:14.750 --> 07:16.750
snice

07:16.750 --> 07:18.750
我们这里

07:18.750 --> 07:20.750
调用的是

07:20.750 --> 07:22.750
第一个参数是argument

07:22.750 --> 07:24.750
第二个参数是

07:24.750 --> 07:26.750
0 是吧

07:26.750 --> 07:28.750
哦 这是这样子

07:28.750 --> 07:30.750
apply

07:30.750 --> 07:34.130
this

07:34.130 --> 07:36.130
第二个参数是argument

07:36.130 --> 07:38.130
this就是argument

07:38.130 --> 07:40.130
应该是这样子写

07:40.130 --> 07:42.130
我们现在是不是拿到第一个参数part

07:42.130 --> 07:44.130
又拿到了后边的参数

07:44.130 --> 07:46.130
形成一个数组丘而相差

07:46.130 --> 07:48.130
把后边的参数全部放到数组里边

07:48.130 --> 07:50.130
我们就知道了后边的参数有哪些了

07:50.130 --> 07:52.130
有哪些了

07:52.130 --> 07:54.130
这意思吧

07:54.130 --> 07:56.130
第一个参数是所有的字幕刷分割的结果

07:56.130 --> 07:58.130
分割的结果

07:58.130 --> 08:00.130
后边的这个数组

08:00.130 --> 08:02.130
这个数组表示的是

08:02.130 --> 08:04.130
它里面有哪些差值

08:04.130 --> 08:06.130
差入了哪些值

08:06.130 --> 08:08.130
通过这个例子

08:08.130 --> 08:10.130
大家可以看到有这么一个关系

08:10.130 --> 08:12.130
就是这个part

08:14.130 --> 08:16.130
part.nance

08:16.130 --> 08:18.130
它一定等于res.nance

08:20.130 --> 08:22.130
加1

08:22.130 --> 08:24.130
是不是这样子 一个关系

08:24.130 --> 08:26.130
好好想一想

08:26.130 --> 08:28.130
它里面有哪些差值

08:28.130 --> 08:30.130
是不是就把字幕刷分割成了多少个部分

08:30.130 --> 08:32.130
然后加1

08:32.130 --> 08:34.130
这里有两个差值

08:34.130 --> 08:36.130
是不是把字幕刷分割成了三个部分

08:36.130 --> 08:38.130
哪怕你最后没有这个句号

08:38.130 --> 08:40.130
我们来输出看一下吧

08:40.130 --> 08:42.130
part

08:42.130 --> 08:44.130
它是不是还是有三个部分

08:44.130 --> 08:46.130
最后一个部分是空字幕刷

08:46.130 --> 08:48.130
哪怕你第一个没有东西

08:48.130 --> 08:50.130
第一个没东西

08:50.130 --> 08:52.130
它也是三个部分

08:52.130 --> 08:54.130
第一个也是空字幕刷

08:54.130 --> 08:56.130
也就是有两个差值

08:56.130 --> 08:58.130
它就会把字幕刷分成三个部分

08:58.130 --> 09:00.130
有三个差值是不是分成四个部分

09:00.130 --> 09:02.130
那么我们这里表示的是差值

09:02.130 --> 09:04.130
用values

09:04.130 --> 09:06.130
这里表示的是差值

09:06.130 --> 09:08.130
就是这个argument

09:08.130 --> 09:10.130
生语参数除开第一个参数之外的

09:10.130 --> 09:12.130
生语参数的数数

09:12.130 --> 09:14.130
就把这个东西形成一个数数

09:14.130 --> 09:16.130
把它转换成一个真数数

09:16.130 --> 09:18.130
把它转换成个真数数

09:18.130 --> 09:20.130
我们也可以

09:20.130 --> 09:22.130
就用这种方式把它转换成一个真数数

09:22.130 --> 09:24.130
然后再用snice取出它下标唯一的

09:24.130 --> 09:26.130
之后的数数的部分

09:26.130 --> 09:28.130
那么是不是后语的生语参数

09:28.130 --> 09:30.130
把它做成个数数values

09:30.130 --> 09:32.130
它就形成这么一种关系

09:32.130 --> 09:34.130
那么如果说我要实现这个模办

09:34.130 --> 09:36.130
我们怎么办呢

09:36.130 --> 09:38.130
你想想怎么办

09:38.130 --> 09:40.130
我们是不是循环它呀

09:40.130 --> 09:42.130
对不对

09:42.130 --> 09:44.130
循环谁

09:44.130 --> 09:46.130
应该循环它

09:46.130 --> 09:48.130
是不是循环它

09:48.130 --> 09:50.130
循环它比方说

09:50.130 --> 09:52.130
循环values

09:52.130 --> 09:54.130
然后呢

09:54.130 --> 09:56.130
我们要把它形成一个真正的字幕刷

09:56.130 --> 09:58.130
是不是应该是这样子

09:58.130 --> 10:00.130
pars0

10:00.130 --> 10:02.130
它的第一个部分

10:02.130 --> 10:04.130
是不是values0

10:04.130 --> 10:06.130
对吧 是这个意思吧

10:06.130 --> 10:08.130
我们这里

10:08.130 --> 10:10.130
先订一个辨量

10:10.130 --> 10:12.130
str

10:12.130 --> 10:14.130
先是个控制不错

10:14.130 --> 10:16.130
然后这个辨量拼接上

10:16.130 --> 10:18.130
这一部分对不对

10:18.130 --> 10:20.130
然后这个辨量在拼接上parts

10:20.130 --> 10:22.130
1

10:22.130 --> 10:24.130
再加上values1

10:24.130 --> 10:26.130
是这个意思吧

10:26.130 --> 10:28.130
然后在拼接上parts

10:28.130 --> 10:30.130
还有吗

10:30.130 --> 10:32.130
最后呢在拼接上parts

10:32.130 --> 10:34.130
2

10:34.130 --> 10:36.130
是这个意思吧

10:36.130 --> 10:38.130
没问题吧

10:38.130 --> 10:40.130
是不是用这种方式就可以搞定了

10:40.130 --> 10:42.130
对不对

10:42.130 --> 10:44.130
那么这样子呢

10:44.130 --> 10:46.130
我们可以写成一个循环

10:46.130 --> 10:48.130
来吧

10:48.130 --> 10:50.130
复循环

10:50.130 --> 10:52.130
循环哪一个

10:52.130 --> 10:54.130
你不能循环parts

10:54.130 --> 10:56.130
因为parts的下标为2的时候

10:56.130 --> 10:58.130
它是不是没有下标2

10:58.130 --> 11:00.130
循环values

11:00.130 --> 11:02.130
好 循环values的时候

11:02.130 --> 11:04.130
每一次循环

11:04.130 --> 11:06.130
是不是我们把str

11:06.130 --> 11:08.130
拼接上parts

11:08.130 --> 11:10.130
i

11:10.130 --> 11:12.130
再拼接上values

11:12.130 --> 11:14.130
对不对

11:14.130 --> 11:16.130
好 那么是不是把这两步就搞定了

11:16.130 --> 11:18.130
这两步搞定了之后呢

11:18.130 --> 11:20.130
最后一步就是当下标

11:20.130 --> 11:22.130
为最大下标的时候

11:22.130 --> 11:24.130
当下标为最大下标的时候

11:24.130 --> 11:26.130
如果说

11:26.130 --> 11:28.130
这个下标为最大下标

11:28.130 --> 11:30.130
i等于到什么

11:30.130 --> 11:32.130
values-1

11:32.130 --> 11:34.130
是不是最大下标

11:34.130 --> 11:36.130
等于到最大下标的时候呢

11:36.130 --> 11:38.130
我们再拼接上这一部分

11:38.130 --> 11:40.130
再拼接上这个i-1

11:40.130 --> 11:42.130
对吧 拼上最后一个字

11:42.130 --> 11:44.130
最后呢我们把这个str返回

11:44.130 --> 11:46.130
是不是就可以模拟出这个

11:46.130 --> 11:48.130
模办之不错

11:48.130 --> 11:50.130
它本身的功能了

11:50.130 --> 11:52.130
你看一下

11:52.130 --> 11:54.130
是不是模拟出来了

11:54.130 --> 11:56.130
我们可以这样的模拟

11:56.130 --> 11:58.130
也可以用别的方式

11:58.130 --> 12:00.130
完全可以进行控制

12:00.130 --> 12:02.130
比方说我们要希望在

12:02.130 --> 12:04.130
希望在这一块

12:04.130 --> 12:06.130
每一个就是

12:06.130 --> 12:08.130
差值前面加个冒号

12:08.130 --> 12:10.130
我们希望在每一个差值前边

12:10.130 --> 12:12.130
加上一个冒号怎么办呢

12:12.130 --> 12:14.130
你看一下我们在这里是不是可以写拼接

12:14.130 --> 12:16.130
是不是在这样子可以写拼接

12:16.130 --> 12:18.130
每一个差值前面加个冒号

12:18.130 --> 12:20.130
对吧 这是差值吗

12:20.130 --> 12:22.130
你看

12:22.130 --> 12:24.130
完全自行控制了

12:24.130 --> 12:26.130
我这里面没有写冒号

12:26.130 --> 12:28.130
但是我们可以在这里可以控制

12:28.130 --> 12:30.130
当然这里也可以用模办之不错

12:30.130 --> 12:32.130
这里也可以写模办之不错

12:32.130 --> 12:34.130
当然这个模办之不错

12:34.130 --> 12:36.130
没有写这个标签

12:36.130 --> 12:38.130
所以它不会运行函数

12:38.130 --> 12:40.130
它只是做简单的拼接

12:40.130 --> 12:42.130
那么我们这里可以这样子写

12:42.130 --> 12:44.130
以后我们拼接之不错的话

12:44.130 --> 12:46.130
尽量多写模办之不错

12:46.130 --> 12:48.130
练习一下冒号

12:48.130 --> 12:50.130
你看我们是不是可以这样子写

12:50.130 --> 12:52.130
是一样的

12:52.130 --> 12:54.130
看懂了吗

12:54.130 --> 12:56.130
好好看一下啊 这是扩展课程

12:56.130 --> 12:58.130
所以说多多少少人会有些难度

12:58.130 --> 13:00.130
并不要求大家每个同学都能理解

13:00.130 --> 13:02.130
好吧 是不是看懂了

13:02.130 --> 13:04.130
那么这一块我们看懂了

13:04.130 --> 13:06.130
这个现象之后呢

13:06.130 --> 13:08.130
我们再来看

13:08.130 --> 13:10.130
实际上在那个

13:10.130 --> 13:12.130
在这个制无创的APP里边

13:12.130 --> 13:14.130
它给你提供了这么一个

13:14.130 --> 13:16.130
就是标记

13:16.130 --> 13:18.130
它本身给你提供了这么一个标记

13:18.130 --> 13:21.570
一个接触文件

13:21.570 --> 13:23.570
这里我们就

13:23.570 --> 13:25.570
就把这个复制一下

13:25.570 --> 13:27.570
就把这个取消掉了

13:27.570 --> 13:29.570
我们来看一下这个

13:29.570 --> 13:31.570
Test

13:31.570 --> 13:33.570
Test

13:33.570 --> 13:35.570
我们在模办之不错里面写上这么一个

13:35.570 --> 13:37.570
比如说

13:37.570 --> 13:39.570
ABC 写钢N

13:39.570 --> 13:41.570
BCD

13:41.570 --> 13:43.570
我们在模办之不错

13:43.570 --> 13:45.570
我们这里没有进行任何踏实

13:45.570 --> 13:47.570
也没有进行任何踏实

13:47.570 --> 13:49.570
有的时候呢

13:49.570 --> 13:51.570
我们可能希望

13:51.570 --> 13:53.570
这个花园行标记呢

13:53.570 --> 13:55.570
它就远风不动的输出就得了

13:55.570 --> 13:57.570
也就是说我们希望它输出什么呢

13:57.570 --> 13:59.570
输出这么一个结果

13:59.570 --> 14:01.570
ABC 写钢N

14:01.570 --> 14:03.570
ABCD

14:03.570 --> 14:05.570
那么以前的输写方式是

14:05.570 --> 14:07.570
用两个写钢

14:07.570 --> 14:09.570
用两个写钢表示一个写钢

14:09.570 --> 14:11.570
这个写多了容易晕

14:11.570 --> 14:13.570
容易投晕

14:13.570 --> 14:15.570
那么这个东西有没有好的办法

14:15.570 --> 14:17.570
就是普通制服

14:17.570 --> 14:19.570
没有任何的特殊制服

14:19.570 --> 14:21.570
没有任何的转移服

14:21.570 --> 14:23.570
能不能告诉这个解释是这么一种情况了

14:23.570 --> 14:25.570
可以的

14:25.570 --> 14:27.570
那这个东西怎么做

14:27.570 --> 14:29.570
你只要在前面加一个标记

14:29.570 --> 14:31.570
只需要在前面加一个标记

14:31.570 --> 14:33.570
SJR

14:33.570 --> 14:35.570
SJR 这个标记

14:35.570 --> 14:37.570
这个标记是别人一定做好的标记

14:37.570 --> 14:39.570
它的实现方式呢

14:39.570 --> 14:41.570
就跟我们刚才的方式是一样的

14:41.570 --> 14:43.570
它本身是一个函数

14:43.570 --> 14:45.570
那么这样子一写了过后

14:45.570 --> 14:47.570
是不是就已经变成这个样子了

14:47.570 --> 14:49.570
那里边随便写一些转移服

14:49.570 --> 14:51.570
它都变成普通制服了

14:51.570 --> 14:53.570
加上这么一个标记

14:53.570 --> 14:55.570
这是这个

14:55.570 --> 14:57.570
另外

14:57.570 --> 14:59.570
我们也可以利用标记这个特点

14:59.570 --> 15:01.570
我们来实现一个功能

15:01.570 --> 15:03.570
比方说我们在Body里面

15:03.570 --> 15:05.570
有这么一个DIV

15:05.570 --> 15:07.570
ID为Container

15:07.570 --> 15:09.570
然后我们在GS里边

15:09.570 --> 15:13.070
写上这么一段代码

15:13.070 --> 15:15.070
就是我们首先获取Container

15:15.070 --> 15:17.070
Container

15:17.070 --> 15:19.070
Document

15:19.070 --> 15:21.070
GetElement版ID

15:21.070 --> 15:23.070
Container

15:23.070 --> 15:25.070
获取到

15:25.070 --> 15:27.070
获取到Container之后

15:27.070 --> 15:29.070
我们希望在里边加入一些内容

15:29.070 --> 15:31.070
应该我们在做一个完整的例子吧

15:31.070 --> 15:33.070
我们在这上面加上一个P元数

15:33.070 --> 15:35.070
这里有一个Input

15:35.070 --> 15:37.070
给它的ID

15:37.070 --> 15:39.070
TST

15:39.070 --> 15:41.070
这里有一个按钮

15:41.070 --> 15:43.070
设置DIV的内容

15:43.070 --> 15:45.070
有这个DIV的内容

15:45.070 --> 15:47.070
可能是用户设置的

15:47.070 --> 15:49.070
有可能是用户设置的

15:49.070 --> 15:51.070
Btn

15:51.070 --> 15:53.070
我们把这些东西全部得到

15:53.070 --> 15:55.070
Const

15:55.070 --> 15:57.070
TST

15:57.070 --> 15:59.070
Document

15:59.070 --> 16:01.070
Btn

16:01.070 --> 16:03.070
Document

16:03.070 --> 16:05.070
Btn

16:05.070 --> 16:07.070
就是说

16:07.070 --> 16:09.070
我们就是这个按钮里边

16:09.070 --> 16:11.070
点击按钮的时候

16:11.070 --> 16:13.070
我们把文本框

16:13.070 --> 16:15.070
用TexArea

16:15.070 --> 16:17.070
给它的ID

16:17.070 --> 16:19.070
TexArea

16:19.070 --> 16:21.070
给它的ID

16:21.070 --> 16:23.070
那么这些东西不要了

16:23.070 --> 16:25.070
就是这个一个多选框

16:25.070 --> 16:27.070
不是多选框

16:27.070 --> 16:29.070
是多航文本框

16:29.070 --> 16:31.070
我们希望用户点击按钮之后

16:31.070 --> 16:33.070
我们把多航文本框的内容

16:33.070 --> 16:35.070
设置到DIV里边去

16:35.070 --> 16:37.070
如果说我们以前写咱们怎么写

16:37.070 --> 16:39.070
点击的时候

16:39.070 --> 16:41.070
我们是不是运行一个函数

16:41.070 --> 16:43.070
对吧

16:43.070 --> 16:45.070
然后把TST的Value值拿到

16:45.070 --> 16:47.070
我们输出一下

16:47.070 --> 16:49.070
TST的Value值

16:49.070 --> 16:51.070
它没有Value

16:51.070 --> 16:53.070
是Inner

16:53.070 --> 16:55.070
TST的4Value值

16:55.070 --> 16:57.070
4Value值

16:57.070 --> 16:59.070
4Value值拿到

16:59.070 --> 17:01.070
把Value值放到哪呢

17:01.070 --> 17:03.070
放到Container里边

17:03.070 --> 17:05.070
我们这里设置

17:05.070 --> 17:07.070
ContainerInnerAT秒

17:07.070 --> 17:09.070
我们把它放到哪

17:09.070 --> 17:11.070
把它放到一个P元数里边吧

17:11.070 --> 17:13.070
我们这里呢

17:13.070 --> 17:15.070
用模板支付出来吧

17:15.070 --> 17:17.070
放到一个P元数里边

17:19.070 --> 17:21.070
那么这里放出什么呢

17:21.070 --> 17:23.070
放置的是TST的Value

17:23.070 --> 17:25.070
没问题吧

17:25.070 --> 17:27.070
你看一下

17:27.070 --> 17:29.070
我们设置它InnerAT秒

17:29.070 --> 17:31.070
把它放到一个P元数里边

17:31.070 --> 17:33.070
P元数里边放的是TST的Value

17:33.070 --> 17:35.070
写上

17:35.070 --> 17:37.070
这个非常简单

17:37.070 --> 17:39.070
但是有的社会出现这么一个问题

17:39.070 --> 17:41.070
看着

17:41.070 --> 17:44.580
如果说拥护它

17:44.580 --> 17:46.580
二作剧

17:46.580 --> 17:48.580
我在这里边还写了一些标签

17:48.580 --> 17:50.580
写了一些元数

17:50.580 --> 17:52.580
那么这样子一来

17:52.580 --> 17:54.580
我们是不是把这个元数内容都拼接进去了

17:54.580 --> 17:56.580
也就是拥护的操作

17:56.580 --> 17:58.580
它改变了我们的ATM结构

17:58.580 --> 18:00.580
你看一下

18:00.580 --> 18:02.580
而且这个结构还是错的

18:02.580 --> 18:04.580
可以改成这样子的

18:04.580 --> 18:06.580
是不是拥护它有可能写一些恶意的内容

18:06.580 --> 18:08.580
对吧

18:08.580 --> 18:10.580
那么我们是不是要把拥护写的内容

18:10.580 --> 18:12.580
它有一些危险的内容

18:12.580 --> 18:14.580
我们是不是要对它进行编码呀

18:14.580 --> 18:15.580
对不对

18:15.580 --> 18:17.580
要对它进行编码

18:17.580 --> 18:19.580
那么我们当然可以写个函数

18:19.580 --> 18:21.580
在这里进行编码

18:21.580 --> 18:23.580
调用函数把Bi6传进去

18:23.580 --> 18:25.580
然后把这些乱七八糟的什么

18:25.580 --> 18:27.580
主要是把这个左横杠

18:27.580 --> 18:29.580
左那个

18:29.580 --> 18:31.580
左间扩号和右间扩号

18:31.580 --> 18:33.580
这样子做了每一次这样子去写

18:33.580 --> 18:35.580
如果说我们这种场景很多

18:35.580 --> 18:37.580
是不是显得会比较麻烦

18:37.580 --> 18:38.580
对吧

18:38.580 --> 18:39.580
我们会显得比较麻烦

18:39.580 --> 18:41.580
每一次都要去做这样的操作

18:41.580 --> 18:42.580
OK

18:42.580 --> 18:44.580
我们现在就做这么一件事

18:44.580 --> 18:45.580
做什么事呢

18:45.580 --> 18:47.580
而且我们对这个东西是不要编码的

18:47.580 --> 18:48.580
对吧

18:48.580 --> 18:49.580
对这个东西是不能编码的

18:49.580 --> 18:50.580
这个东西是我们

18:50.580 --> 18:52.580
就是这个东西是开发者写的

18:52.580 --> 18:54.580
开发者写的肯定是安全的

18:54.580 --> 18:56.580
十字八九都是安全的

18:56.580 --> 18:57.580
不安全的是拥护写的

18:57.580 --> 18:59.580
因为你不知道拥护到底会写啥

18:59.580 --> 19:01.580
开发者是我们自己写的

19:01.580 --> 19:02.580
我们会注意这个问题

19:02.580 --> 19:04.580
但是拥护写的你是不能信任的

19:04.580 --> 19:07.580
所以说我们要对拥护这一部分进行编码

19:07.580 --> 19:08.580
那么怎么办呢

19:08.580 --> 19:09.580
我们就可以加上一个标记

19:09.580 --> 19:11.580
比方说safe

19:11.580 --> 19:14.580
安全的模板字五串

19:14.580 --> 19:16.580
这里我们就写个函数safe

19:16.580 --> 19:18.580
那么我们来吧

19:18.580 --> 19:19.580
我们之前导写的

19:19.580 --> 19:20.580
第一个是不是part

19:20.580 --> 19:23.580
part是不是我们被这个差值分割的部分

19:23.580 --> 19:26.580
分割的部分是不是我们开发者自己写的

19:26.580 --> 19:27.580
自己写的我们不动

19:27.580 --> 19:28.580
不管它

19:28.580 --> 19:31.580
我们只考虑拥护写的

19:31.580 --> 19:33.580
拥护写的是哪一部分

19:33.580 --> 19:36.580
拥护写的Values是哪一部分

19:36.580 --> 19:37.580
来吧

19:37.580 --> 19:39.580
array

19:39.580 --> 19:40.580
part type

19:40.580 --> 19:42.580
然后snice

19:42.580 --> 19:45.580
apply

19:45.580 --> 19:48.580
然后argument

19:48.580 --> 19:51.580
然后就完了

19:51.580 --> 19:53.580
然后snice

19:53.580 --> 19:54.580
b

19:54.580 --> 19:55.580
是不是得到生育的部分

19:55.580 --> 19:57.580
我们来输出一下Values

19:57.580 --> 20:03.340
再输出一下part

20:03.340 --> 20:05.340
好来吧

20:05.340 --> 20:08.340
我们这里写上一个he

20:08.340 --> 20:12.100
看空台点击

20:12.100 --> 20:14.100
你看我们

20:14.100 --> 20:16.100
这是我们part的一部分

20:16.100 --> 20:17.100
就是开发者自己写的

20:17.100 --> 20:18.100
就是他把它分割成这么一部分

20:18.100 --> 20:19.100
这么一部分

20:19.100 --> 20:20.100
分成两部分

20:20.100 --> 20:21.100
传到这个数组里边

20:21.100 --> 20:22.100
你看这个

20:22.100 --> 20:23.100
第一个数组part

20:23.100 --> 20:24.100
是不是两个

20:24.100 --> 20:25.100
数组有两项

20:25.100 --> 20:26.100
第一项第二项

20:26.100 --> 20:27.100
对吧

20:27.100 --> 20:28.100
好

20:28.100 --> 20:30.100
然后下边的一个数组

20:30.100 --> 20:31.100
我们得到的数组

20:31.100 --> 20:32.100
是拥护传递的

20:32.100 --> 20:34.100
就是这里边的差值

20:34.100 --> 20:36.100
我们要解决的是这个差值

20:36.100 --> 20:38.100
我们要解决的是不是这个差值

20:38.100 --> 20:39.100
要把这个差值

20:39.100 --> 20:41.100
变成一个安全的支付串

20:41.100 --> 20:42.100
来吧

20:42.100 --> 20:44.100
我们按照刚之前的写法

20:44.100 --> 20:46.100
把这个复制过来

20:46.100 --> 20:48.100
我们按照之前的写法

20:48.100 --> 20:50.100
是不是这样的写的

20:50.100 --> 20:52.100
循环什么Values的链子

20:52.100 --> 20:54.100
你看是不是一样的

20:54.100 --> 20:55.100
对不对

20:55.100 --> 20:56.100
当然不加冒号了

20:56.100 --> 20:58.100
不加冒号了

20:58.100 --> 20:59.100
我们用这种方式

20:59.100 --> 21:01.100
评界

21:01.100 --> 21:03.100
这里就是part

21:03.100 --> 21:04.100
i

21:04.100 --> 21:05.100
如果说我们不处理的话

21:05.100 --> 21:06.100
评界

21:06.100 --> 21:07.100
评界

21:07.100 --> 21:08.100
是不是这样的评界

21:08.100 --> 21:09.100
但是我们现在是不是可以处理一下

21:09.100 --> 21:10.100
把这个Values i

21:10.100 --> 21:12.100
就是用户的内容

21:12.100 --> 21:14.100
是不是把它转变一下

21:14.100 --> 21:15.100
对不对

21:15.100 --> 21:17.100
Values i

21:17.100 --> 21:20.100
把这个内容是不是要转变一下

21:20.100 --> 21:21.100
怎么转变呢

21:21.100 --> 21:22.100
怎么转变呢

21:22.100 --> 21:24.100
我们是不是可以利用Replace

21:24.100 --> 21:25.100
对不对

21:25.100 --> 21:26.100
替换

21:26.100 --> 21:27.100
替换掉什么呢

21:27.100 --> 21:28.100
我们这里用个正则吧

21:28.100 --> 21:29.100
用个正则

21:29.100 --> 21:32.100
替换掉左肩扩号

21:32.100 --> 21:35.100
把左肩扩号来进行替换

21:35.100 --> 21:37.100
全局搜索

21:37.100 --> 21:38.100
替换成什么呢

21:38.100 --> 21:40.100
替换成这个

21:40.100 --> 21:42.100
左肩扩号替换成

21:42.100 --> 21:44.100
Nest

21:44.100 --> 21:45.100
对吧

21:45.100 --> 21:46.100
LT

21:46.100 --> 21:47.100
然后呢

21:47.100 --> 21:48.100
我们又继续替换

21:48.100 --> 21:49.100
对得到了新的支付串

21:49.100 --> 21:51.100
我们又对右肩扩号

21:51.100 --> 21:52.100
来进行替换

21:52.100 --> 21:53.100
替换成什么呢

21:53.100 --> 21:57.100
就是GreaseZ

21:57.100 --> 21:58.100
大语

21:58.100 --> 21:59.100
对吧

21:59.100 --> 22:00.100
替换这样的替换

22:00.100 --> 22:01.100
这样替换了过后

22:01.100 --> 22:04.100
我们把这个V拼接进去

22:04.100 --> 22:05.100
你看一下

22:05.100 --> 22:06.100
那么这样

22:06.100 --> 22:08.100
我们就写出了一个非常通用的

22:08.100 --> 22:09.100
这么一个标记

22:09.100 --> 22:10.100
知不知道标记

22:10.100 --> 22:11.100
那么有了这个标记之后

22:11.100 --> 22:12.100
我们反而是以后

22:12.100 --> 22:14.100
遇到了用户的差值

22:14.100 --> 22:15.100
怕有危险内容的

22:15.100 --> 22:18.100
那么他就会对他进行转移

22:18.100 --> 22:20.100
会对他进行就是编码

22:20.100 --> 22:21.100
来看一下

22:21.100 --> 22:22.100
我们这里再写一个

22:22.100 --> 22:24.100
H1

22:24.100 --> 22:25.100
H1

22:25.100 --> 22:26.100
点设置

22:26.100 --> 22:28.100
你看是不是变成这样子的

22:28.100 --> 22:30.100
你看这边

22:30.100 --> 22:31.100
DIVP里面

22:31.100 --> 22:32.100
是不是变成这个样子的

22:32.100 --> 22:33.100
对不对

22:33.100 --> 22:34.100
看一下一些什么代码

22:34.100 --> 22:35.100
是不是变

22:35.100 --> 22:36.100
转变了

22:36.100 --> 22:37.100
把转移了

22:37.100 --> 22:38.100
对吧

22:38.100 --> 22:40.100
我们就可以实现这么一个效果

22:40.100 --> 22:41.100
那么以后呢

22:41.100 --> 22:43.100
我们不管他要差多少个值

22:43.100 --> 22:44.100
无论你要差多少个值

22:44.100 --> 22:45.100
都无所谓

22:45.100 --> 22:46.100
比方我们这里差

22:46.100 --> 22:47.100
差入两次

22:47.100 --> 22:48.100
差入两次

22:48.100 --> 22:49.100
再来一个

22:49.100 --> 22:50.100
再来一个P元数

22:50.100 --> 22:52.100
或者再来一个H1元数

22:52.100 --> 22:53.100
H1元数

22:53.100 --> 22:54.100
那么这里边再插入一次

22:54.100 --> 22:56.100
无论你插入多少次

22:56.100 --> 22:57.100
都无所谓

22:57.100 --> 22:58.100
它都不影响

22:58.100 --> 22:59.100
你看一下

23:01.100 --> 23:03.100
我们这里写一个

23:03.100 --> 23:04.100
1米级元数

23:04.100 --> 23:05.100
1米级元数

23:05.100 --> 23:06.100
点击

23:06.100 --> 23:07.100
你看

23:07.100 --> 23:08.100
是不是不影响

23:08.100 --> 23:09.100
对不对

23:09.100 --> 23:10.100
只要加了这个标记过后

23:10.100 --> 23:12.100
这个标记通用的了

23:12.100 --> 23:13.100
就可以在各种制服圈里面

23:13.100 --> 23:15.100
来处理这个危险内容

23:15.100 --> 23:18.100
这就是磨办制服圈的标记

23:18.100 --> 23:19.100
没有记什么笔记

23:19.100 --> 23:20.100
对吧

23:20.100 --> 23:21.100
我们总结一下吧

23:21.100 --> 23:24.100
就是在磨办制服圈

23:24.100 --> 23:26.100
输

23:26.100 --> 23:27.100
制服圈

23:27.100 --> 23:29.100
输写之前

23:29.100 --> 23:32.100
可以加上标记

23:32.100 --> 23:33.100
格式

23:33.100 --> 23:35.410
是下面的格式

23:35.410 --> 23:37.410
磨办制服圈

23:37.410 --> 23:39.410
磨办制服圈

23:39.410 --> 23:42.410
然后这里是标记名

23:42.410 --> 23:43.410
标记名

23:43.410 --> 23:46.410
标记是一个函数

23:46.410 --> 23:48.410
标记是一个函数

23:48.410 --> 23:49.410
那么

23:49.410 --> 23:51.410
函数的第一个参数

23:51.410 --> 23:56.410
函数参数如下

23:56.410 --> 24:00.410
第一个参数一

24:00.410 --> 24:02.410
参数一是

24:02.410 --> 24:06.410
被差值分割的制服圈

24:06.410 --> 24:07.410
输住

24:07.410 --> 24:08.410
就是

24:08.410 --> 24:10.410
元风不动的在这里边写的

24:10.410 --> 24:12.410
就是静态的制服圈

24:12.410 --> 24:13.410
被差值分割的

24:13.410 --> 24:14.410
好

24:14.410 --> 24:15.410
那么第二个

24:15.410 --> 24:17.410
参数2

24:17.410 --> 24:19.410
是差值

24:19.410 --> 24:21.410
所以

24:21.410 --> 24:22.410
后续参数

24:22.410 --> 24:23.410
不一定是参数2

24:23.410 --> 24:25.410
后续参数是

24:25.410 --> 24:27.410
所有的差值

24:27.410 --> 24:28.410
它的关系是

24:28.410 --> 24:31.410
后续参数形成的数组

24:31.410 --> 24:33.410
它的长度

24:33.410 --> 24:34.410
加1过后

24:34.410 --> 24:36.410
就等于参数1的数组

24:36.410 --> 24:37.410
好吧

24:37.410 --> 24:38.410
这是关于磨办制服圈

24:38.410 --> 24:40.410
大家好好去底一下

24:40.410 --> 24:41.410
这东西也不是很重要

24:41.410 --> 24:42.410
主要是有这么一个印象

24:42.410 --> 24:44.410
知道JS6里面

24:44.410 --> 24:46.410
是有这么一个功能的

