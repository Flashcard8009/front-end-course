WEBVTT

00:00.110 --> 00:04.110
好 这就可能咱们来实现 promise 的两个静态方法

00:04.110 --> 00:07.110
一个叫做 result

00:07.110 --> 00:09.110
一个叫做 reject

00:09.110 --> 00:11.110
为什么说静态方法呢

00:11.110 --> 00:12.110
因为它不需要创建对象

00:12.110 --> 00:14.110
直接通过各个函数里面一个属性就可以

00:14.110 --> 00:17.110
一个成员就可以使用 叫静态方法

00:17.110 --> 00:18.110
比如说面试的时候

00:18.110 --> 00:20.110
我让你面试机就这样描述了

00:20.110 --> 00:22.110
说你在实现一个 result 方法

00:22.110 --> 00:24.110
那你这个代码怎么写 这样写

00:24.110 --> 00:26.110
promise result 等于一个函数

00:26.110 --> 00:29.110
重新够复制 是吧 这是 data

00:29.110 --> 00:31.110
然后让你实现一个 reject 是吧

00:31.110 --> 00:32.110
那一样的

00:32.110 --> 00:34.110
那么这里是 reason

00:34.110 --> 00:37.110
对吧 那就这样子写就完事了

00:37.110 --> 00:38.110
由于我们这里的是

00:38.110 --> 00:40.110
接着我自己写的一个 promise 继续编写

00:40.110 --> 00:42.110
所以说我这里要把那个换成什么

00:42.110 --> 00:45.110
换成 my promise

00:45.110 --> 00:47.110
要把它换成 my promise

00:47.110 --> 00:49.110
要换成这么一个彩

00:49.110 --> 00:50.110
换成这个东西

00:50.110 --> 00:51.110
懂了意思吗

00:51.110 --> 00:55.110
当然呢 一个也完全可以使用 yes6 的新语法

00:55.110 --> 00:57.110
就这种写法

00:57.110 --> 00:59.110
我完全可以把它变成这种写法

00:59.110 --> 01:02.620
static result

01:02.620 --> 01:03.620
那么这种写法呢

01:03.620 --> 01:06.620
跟下边这种写法效果是完全一样的

01:06.620 --> 01:08.620
有一点非常细微的差别

01:08.620 --> 01:10.620
但是我们认为它效果是完全一样的

01:10.620 --> 01:12.620
也这里写上一个 static

01:12.620 --> 01:13.620
那么拿这种写法好了

01:13.620 --> 01:15.620
肯定是上边的这种写法好

01:15.620 --> 01:18.620
因为上边那个写法是高聚合的

01:18.620 --> 01:21.620
它的逻辑仍然是 promise 里边的逻辑

01:21.620 --> 01:23.620
他们是代码是扎堆的

01:23.620 --> 01:24.620
他没有把他分离

01:24.620 --> 01:26.620
所以说这个逻辑更加集中

01:26.620 --> 01:28.620
因此在这种写法的肯定更好一点

01:28.620 --> 01:30.620
但是效果都是一样的

01:30.620 --> 01:33.620
然而呢 你们将来在诸面实体的时候

01:33.620 --> 01:34.620
由于呢 你没有

01:34.620 --> 01:35.620
比方说他个面实体没有

01:35.620 --> 01:36.620
让你自己写一个 promise

01:36.620 --> 01:38.620
他就让你实现一个 result

01:38.620 --> 01:41.620
你不可能把自己 promise 重新到位实现一面

01:41.620 --> 01:42.620
那个太浪费时间了

01:42.620 --> 01:44.620
而且他给的时间肯定不够

01:44.620 --> 01:46.620
因为 result 实现不了多少时间

01:46.620 --> 01:47.620
要比方说就十分钟

01:47.620 --> 01:49.620
那你这个 promise 肯定写不完

01:49.620 --> 01:50.620
那怎么办呢

01:50.620 --> 01:52.620
那你就用这种写法

01:52.620 --> 01:54.620
针对官方的 result 重新付一个值

01:54.620 --> 01:55.620
就行了

01:55.620 --> 01:56.620
懂了意思吧

01:56.620 --> 01:57.620
给大家说清楚

01:58.620 --> 01:59.620
我们这几个要实现两个

01:59.620 --> 02:00.620
一个是呢

02:04.180 --> 02:05.180
一个是 result

02:05.180 --> 02:07.180
好 我们来先来说这个 result

02:07.180 --> 02:09.180
这个玩意要根据官方文档来看

02:09.180 --> 02:10.180
要去看官方文档

02:10.180 --> 02:12.180
就是MDN 上的文档

02:12.180 --> 02:13.180
那么这个是什么意思呢

02:13.180 --> 02:17.180
就是返回一个 promise

02:17.180 --> 02:19.180
他核心中也就是返回一个

02:19.180 --> 02:22.180
已完成的 promise

02:22.180 --> 02:24.180
那他有这么几个逻辑

02:24.180 --> 02:26.180
有两种特殊情况

02:26.180 --> 02:28.180
特殊情况我说一下

02:28.180 --> 02:30.180
第一种特殊情况呢

02:30.180 --> 02:32.180
就是传递的

02:32.180 --> 02:34.180
传递的

02:34.180 --> 02:36.180
data

02:36.180 --> 02:38.180
本身就是

02:38.180 --> 02:40.180
本身

02:40.180 --> 02:43.180
就是 es6 的 promise 对象

02:44.180 --> 02:45.180
如果说是这种情况

02:45.180 --> 02:46.180
比方说我怎么来判断呢

02:46.180 --> 02:48.180
就是 data is tensile

02:48.180 --> 02:49.180
对吧

02:49.180 --> 02:50.180
是不是 es6 的 promise 对象

02:50.180 --> 02:51.180
但是呢

02:51.180 --> 02:52.180
因为我这里全是熟写的

02:52.180 --> 02:54.180
如果你们那边

02:54.180 --> 02:56.180
只实现 reserve 的话

02:56.180 --> 02:57.180
那这里直接写

02:57.180 --> 02:58.180
这样写就可以了

02:58.180 --> 02:59.180
但是由于我这边

02:59.180 --> 03:00.180
是自己熟写的

03:00.180 --> 03:02.180
所以我这里把它改成 my promise

03:02.180 --> 03:03.180
你们那边

03:03.180 --> 03:04.180
将来就做面试题的时候

03:04.180 --> 03:06.180
只要没让你去熟写

03:06.180 --> 03:08.180
这个完整的版的 promise

03:08.180 --> 03:10.180
只是让你熟写 reserve

03:10.180 --> 03:11.180
那你这里换成

03:11.180 --> 03:12.180
这个官方的 promise

03:12.180 --> 03:13.180
懂这个意思吗

03:13.180 --> 03:14.180
因为我这里

03:14.180 --> 03:15.180
既然自己熟写了

03:15.180 --> 03:16.180
我肯定要换成自己的

03:16.180 --> 03:18.180
如果说就是

03:18.180 --> 03:19.180
我们那个 promise 对象

03:19.180 --> 03:21.180
就通过个构造系创建的

03:21.180 --> 03:22.180
那我直接反悔对他

03:22.180 --> 03:23.180
啥也不管

03:24.180 --> 03:25.180
他是有这么一个逻辑存在

03:25.180 --> 03:27.180
那么第二种特殊情况

03:27.180 --> 03:31.180
就是他不是 es6 的 promise

03:31.180 --> 03:32.180
但是呢

03:32.180 --> 03:37.180
传递的 data 是 promise like

03:37.180 --> 03:39.180
这是什么东西啊

03:39.180 --> 03:42.180
这就是实现了 promise 而加规范的

03:43.180 --> 03:45.180
他像一个 promise

03:45.180 --> 03:47.180
他实现了 promise 而加规范

03:47.180 --> 03:49.180
如果说是这种情况的话

03:49.180 --> 03:50.180
那我怎么会做呢

03:50.180 --> 03:53.500
反悔一个新的 promise

03:53.500 --> 03:54.500
反悔一个新的 promise

03:54.500 --> 03:55.500
当然这个 promise 呢

03:55.500 --> 03:56.500
要用 my promise

03:56.500 --> 03:57.500
我都要用 my

03:57.500 --> 03:58.500
你们以后要用官方的

03:58.500 --> 04:00.500
如果说当你单独写的 reserve

04:00.500 --> 04:01.500
我不知道大家听懂

04:01.500 --> 04:02.500
我的意思没有

04:02.500 --> 04:03.500
因为我这边呢

04:03.500 --> 04:05.500
是自己熟写的一个 my promise

04:05.500 --> 04:07.500
所以说我啥地方都要用我自己的

04:07.500 --> 04:08.500
但是如果说

04:08.500 --> 04:09.500
你们将在做面试的时候

04:09.500 --> 04:10.500
没有让你去自己

04:10.500 --> 04:11.500
完整的版的

04:11.500 --> 04:12.500
去熟写一个 promise

04:12.500 --> 04:13.500
只是让你实现

04:13.500 --> 04:14.500
他的一个局部方法

04:14.500 --> 04:15.500
让你肯定这里

04:15.500 --> 04:16.500
要写官方的

04:16.500 --> 04:17.500
对不对

04:17.500 --> 04:18.500
没有自己熟写

04:18.500 --> 04:19.500
不要很傻的去

04:19.500 --> 04:20.500
把自己熟写一遍

04:20.500 --> 04:21.500
有时间不够的

04:21.500 --> 04:22.500
除非他明确

04:22.500 --> 04:23.500
自己熟写

04:23.500 --> 04:24.500
一般来说

04:24.500 --> 04:25.500
自己熟写的话

04:25.500 --> 04:26.500
需要花费多少时间

04:26.500 --> 04:27.500
半个小时到一个小时

04:27.500 --> 04:29.500
就这么长

04:29.500 --> 04:30.500
所以呢

04:30.500 --> 04:31.500
这里呢

04:31.500 --> 04:32.500
我们这里就返回

04:32.500 --> 04:34.500
一个新的 promise

04:34.500 --> 04:35.500
难道这种情况就是

04:35.500 --> 04:38.500
返回新的 promise

04:38.500 --> 04:43.500
状态和其保持一致即可

04:43.500 --> 04:44.500
这个新的 promise

04:44.500 --> 04:45.500
状态是什么的

04:45.500 --> 04:46.500
什么时候会入伍

04:46.500 --> 04:47.500
什么时候会接个程

04:47.500 --> 04:48.500
那就看你吧

04:48.500 --> 04:49.500
你判断一下

04:49.500 --> 04:50.500
如果说 data

04:50.500 --> 04:51.500
我们之前是不是写过

04:51.500 --> 04:52.500
一个函数吗

04:52.500 --> 04:53.500
这个函数你得实现

04:53.500 --> 04:54.500
到时候你写的时候

04:54.500 --> 04:55.500
你得实现

04:55.500 --> 04:56.500
如果说他里边

04:56.500 --> 04:57.500
是一个有任何方法的

04:57.500 --> 04:58.500
一个对象

04:58.500 --> 04:59.500
那么我们就认为

04:59.500 --> 05:00.500
他是一个 promise like

05:00.500 --> 05:01.500
是一个实现的 promise

05:01.500 --> 05:02.500
a 加规范的

05:02.500 --> 05:03.500
这么一个对象

05:03.500 --> 05:04.500
那么我就认为

05:04.500 --> 05:05.500
你那个

05:05.500 --> 05:06.500
你成功了

05:06.500 --> 05:07.500
我就成功了

05:07.500 --> 05:08.500
你失败了

05:08.500 --> 05:09.500
我就失败了

05:09.500 --> 05:11.500
就这么一个逻辑

05:11.500 --> 05:13.500
就这个逻辑

05:13.500 --> 05:14.500
那么剩下的

05:14.500 --> 05:15.500
就不是特殊情况了

05:15.500 --> 05:16.500
那我就直接返回

05:16.500 --> 05:17.500
一个以完成的 promise

05:17.500 --> 05:18.500
然后这个 promise

05:18.500 --> 05:19.500
我返回

05:19.500 --> 05:21.500
怎么让他完成了

05:21.500 --> 05:22.500
就其他情况

05:22.500 --> 05:23.500
其他情况

05:23.500 --> 05:24.500
完成的时候

05:24.500 --> 05:25.500
就直接resolve

05:25.500 --> 05:26.500
就完成了

05:26.500 --> 05:27.500
那么就是整个resolve

05:27.500 --> 05:28.500
的实现

05:28.500 --> 05:29.500
就这么三种情况

05:29.500 --> 05:30.500
其实我们平时

05:30.500 --> 05:31.500
用了最多的就是这种情况

05:31.500 --> 05:32.500
对吧

05:32.500 --> 05:33.500
他既不是一个

05:33.500 --> 05:34.500
就是平常我们

05:34.500 --> 05:35.500
平时怎么写的 promise

05:35.500 --> 05:36.500
resolve

05:36.500 --> 05:37.500
一个e

05:37.500 --> 05:38.500
对不对

05:38.500 --> 05:39.500
那么这里

05:39.500 --> 05:40.500
我们输出一下pro

05:40.500 --> 05:44.260
他自然得到一个

05:44.260 --> 05:45.260
就是以完成的 promise

05:45.260 --> 05:46.260
对吧

05:46.260 --> 05:47.260
就这么一个情况

05:47.260 --> 05:50.260
这就是resolve的逻辑

05:51.260 --> 05:52.260
然后呢

05:52.260 --> 05:53.260
resolve的逻辑

05:53.260 --> 05:54.260
是非常粗暴的

05:54.260 --> 05:55.260
非常非常粗暴的

05:55.260 --> 05:56.260
他跟resolve

05:56.260 --> 05:57.260
就不太一样

05:57.260 --> 06:00.260
这是一个

06:00.260 --> 06:04.820
得到一个

06:04.820 --> 06:07.820
被拒绝的 promise

06:07.820 --> 06:08.820
所以说

06:08.820 --> 06:09.820
我们这里的resolve

06:09.820 --> 06:10.820
他直接

06:10.820 --> 06:12.820
new一个my promise

06:12.820 --> 06:13.820
resolve

06:13.820 --> 06:14.820
resolve

06:14.820 --> 06:16.820
然后resolve

06:16.820 --> 06:17.820
resolve

06:17.820 --> 06:19.820
就完成了

06:19.820 --> 06:20.820
他就没有

06:20.820 --> 06:21.820
这些乱七八糟的逻辑了

06:21.820 --> 06:23.820
这就是官方的

06:23.820 --> 06:24.820
要求

06:24.820 --> 06:25.820
官方的MDN上

06:25.820 --> 06:26.820
就这样子描述了

06:26.820 --> 06:27.820
我就按照描述来写

06:27.820 --> 06:28.820
ok

06:28.820 --> 06:29.820
那么我们这里得到一个

06:29.820 --> 06:34.250
resolve

06:34.250 --> 06:35.250
你看

06:35.250 --> 06:36.250
是不是没问题的

06:36.250 --> 06:38.250
ok

06:38.250 --> 06:39.250
那么这就是

06:39.250 --> 06:40.250
这一块的逻辑

