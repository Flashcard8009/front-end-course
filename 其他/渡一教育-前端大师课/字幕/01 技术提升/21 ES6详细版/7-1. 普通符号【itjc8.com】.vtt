WEBVTT

00:01.260 --> 00:05.800
好 这一张呢 我们来学习一个非常有意思的东西啊 叫做符号

00:05.800 --> 00:11.160
符号呢 其实它分为好多种 有普通符号 共享符号 知名符号

00:11.160 --> 00:14.280
其实它们都差不多 都统称为符号

00:14.280 --> 00:16.800
咱们周杰克呢 先来学习普通符号

00:16.800 --> 00:19.760
我们后边再来学习什么共享符号啊

00:19.760 --> 00:22.600
再学习什么知名符号啊 就简单很多了啊

00:22.600 --> 00:24.400
都是符号啊 都是符号

00:24.400 --> 00:26.320
那符号到底是一个什么玩意儿呢

00:26.320 --> 00:28.080
它的英文单词呢 叫Symbol

00:28.480 --> 00:33.040
symbol 它是ES6新增的一个数据内行

00:33.040 --> 00:35.160
你看这句话就一下就把说清楚了

00:35.160 --> 00:38.560
我们以前的介石代码里边 不是有这么一些数据内行吗

00:38.560 --> 00:42.800
什么数字 什么制服串 什么布尔对不对

00:42.800 --> 00:45.680
还有什么对象 还有什么now对不对

00:45.680 --> 00:47.840
undefend 有这么一些数据内行

00:49.280 --> 00:51.400
现在用了这么多年的数据内行

00:51.400 --> 00:53.320
现在突然发现不够用了

00:53.320 --> 00:56.920
于是呢ES6呢给你增加了一个新的数据内行

00:56.960 --> 01:00.200
这个数据内行呢 它要怎么来创建数据呢

01:00.200 --> 01:02.040
我们说 如果说一个数字的话

01:02.040 --> 01:05.480
你可以直接输写 对吧 直接输一个数字

01:05.480 --> 01:06.560
如果说一个字幕串的话

01:06.560 --> 01:08.680
你用双引号输写一个字幕串

01:08.680 --> 01:09.600
如果说一个对象的话

01:09.600 --> 01:10.920
你用达国号来表示一个对象

01:12.440 --> 01:15.040
那这个新的数据内行

01:15.040 --> 01:16.440
它使用什么来输写呢

01:16.440 --> 01:19.240
它是使用一个函数调用得到的

01:20.000 --> 01:21.600
这是非常诚细哦

01:21.600 --> 01:25.240
以前我们有哪个数据内行是通过函数调用来得到的

01:25.240 --> 01:26.840
没有吧 对不对

01:26.840 --> 01:28.240
这个数据内行它就是

01:28.240 --> 01:30.480
它要通过一个函数的调用

01:30.480 --> 01:31.600
来得到一个数据

01:31.600 --> 01:33.200
比方说举个例子

01:33.200 --> 01:37.680
这里呢 我们得到一个创建

01:37.680 --> 01:39.840
比方说创建一个符号

01:39.840 --> 01:41.760
先不要着急 这个符号有什么用

01:41.760 --> 01:44.120
不要着急 我们把这些课学完了之后

01:44.120 --> 01:45.840
你自然知道符号有什么用了

01:45.840 --> 01:47.160
这里我们创建一个符号

01:47.160 --> 01:49.040
我们先来学一下它的语法

01:49.040 --> 01:50.760
比方说啊

01:50.760 --> 01:52.680
我们这里的第一个辩量

01:52.680 --> 01:56.360
叫做symbol1

01:56.360 --> 01:57.800
来吧 怎么来调用

01:57.800 --> 01:59.880
调用这个函数得到一个符号

01:59.880 --> 02:01.000
就这么简单

02:01.000 --> 02:04.360
来吧 再一个symbol2

02:04.360 --> 02:05.480
再调用一个函数

02:05.480 --> 02:07.320
这个函数里面还可以传参数

02:07.320 --> 02:08.120
参数什么意思呢

02:08.120 --> 02:10.520
就是描述 关于这个符号的描述

02:10.520 --> 02:11.920
一些描述信息

02:11.920 --> 02:13.440
就可以符号取个名字

02:13.440 --> 02:16.760
随便取个名字 想取啥取啥

02:16.760 --> 02:19.160
就abc吧 取个名字

02:19.160 --> 02:20.400
也可以得到一个符号

02:20.400 --> 02:21.960
我们来输出一下symbol

02:22.000 --> 02:23.680
看一下输出是什么样子

02:23.680 --> 02:24.920
这是一个非常有意思的

02:24.920 --> 02:26.200
以前我们一直用的

02:26.200 --> 02:28.120
这么久的数据类型现在多了一个了

02:28.120 --> 02:29.320
我们欢迎新同学

02:29.320 --> 02:31.360
欢迎新的数据类型

02:31.360 --> 02:32.120
来吧

02:32.120 --> 02:32.680
你看呀

02:32.680 --> 02:33.920
就得到这么一个东西

02:33.920 --> 02:35.400
输出这么一个东西

02:35.400 --> 02:36.880
它是啥 是对象吗

02:36.880 --> 02:37.400
不像啊

02:37.400 --> 02:38.680
它看上去不像一个对象

02:38.680 --> 02:39.240
对象了

02:39.240 --> 02:40.680
输出出来一定是两个大括号

02:40.680 --> 02:41.640
可以展开的 对吧

02:41.640 --> 02:42.640
还有圆形链

02:42.640 --> 02:43.240
它有吗

02:43.240 --> 02:44.440
啥都没有

02:44.440 --> 02:45.320
是一个制符串吗

02:45.320 --> 02:47.040
我们知道在控制台里边输出了

02:47.040 --> 02:49.320
如果说你输出一个制符串的话

02:49.320 --> 02:51.320
输出的是一个制符串的话

02:51.360 --> 02:52.960
比方说我们这里输出一个

02:54.160 --> 02:56.280
我们比方说在这里输出一个制符串

02:57.160 --> 02:58.320
你看看制符串在控制台里边

02:58.320 --> 02:59.240
是一个黑色的字体

02:59.240 --> 02:59.880
对吧

02:59.880 --> 03:01.480
是一个黑色的字体输出的

03:01.480 --> 03:02.960
也不是个制符串

03:02.960 --> 03:03.960
它是数字吗

03:03.960 --> 03:04.920
数字是蓝色字体

03:04.920 --> 03:06.200
也不是 啥都不是

03:06.200 --> 03:08.400
它跟之前的数据类型没有任何关系

03:08.400 --> 03:10.520
它是一个全新的数据类型

03:10.520 --> 03:11.800
这个数据类型怎么来的

03:11.800 --> 03:13.480
通过调用symbol

03:13.480 --> 03:15.040
或者是在symbol里面传参数

03:15.040 --> 03:16.880
都可以传进这样的数据类型

03:16.880 --> 03:17.720
没什么意思吗

03:17.720 --> 03:19.600
先别管它有什么用

03:19.640 --> 03:20.360
我们意识

03:20.360 --> 03:21.840
你会把这一节课学完的话

03:21.840 --> 03:23.200
你不知道它有什么用

03:23.200 --> 03:24.720
我们现在认识它

03:24.720 --> 03:26.080
一点点来认识

03:28.120 --> 03:28.600
好

03:28.600 --> 03:30.400
我们这里知道它怎么创建的了

03:30.400 --> 03:31.560
它通过这个函数来创建

03:31.560 --> 03:32.480
有没有别的方式创建的

03:32.480 --> 03:33.480
没有

03:33.480 --> 03:35.920
一定要通过这个函数symbol来创建

03:35.920 --> 03:36.840
没有别的方式

03:37.880 --> 03:41.280
那么为什么要设计这个符号的类型出来了

03:41.280 --> 03:42.360
以前的类型不够用吗

03:42.360 --> 03:44.520
它觉得不够用了

03:44.520 --> 03:47.840
它设计符号的最初的原因

03:47.880 --> 03:50.920
是为了给对象设置私有属性

03:50.920 --> 03:52.000
什么叫私有属性

03:52.000 --> 03:53.360
就是这个有一些属性

03:53.360 --> 03:56.520
我只能在对象内部的方法里边可以用

03:56.520 --> 03:57.880
别的对象用不了

03:57.880 --> 03:59.400
这叫私有属性

03:59.400 --> 04:02.200
很多的面向对象程序里边

04:02.200 --> 04:03.200
语言里边

04:03.200 --> 04:06.120
它们都有各自的私有属性的表达方式

04:06.120 --> 04:07.440
比方说访问修饰服

04:07.440 --> 04:07.720
对吧

04:07.720 --> 04:08.440
有些同学听过

04:08.440 --> 04:09.200
有些同学没听过

04:09.200 --> 04:10.120
没听过没关系

04:10.120 --> 04:11.760
这是别的语言的东西

04:11.760 --> 04:13.200
但是加把里面没有

04:13.200 --> 04:15.160
在介石里面是没有的

04:15.160 --> 04:16.680
介石里面没有这个东西

04:16.680 --> 04:18.480
那如果说我要表达一些

04:18.480 --> 04:21.000
只能在对象内部使用

04:21.000 --> 04:22.360
外面不能用的东西

04:22.360 --> 04:23.240
那怎么办的

04:23.240 --> 04:24.760
比方说我们有个例子

04:24.760 --> 04:25.480
就例子

04:28.160 --> 04:29.160
还是有这个

04:29.160 --> 04:30.200
写个对象

04:32.910 --> 04:34.870
比方说有一个英雄对象

04:34.870 --> 04:36.190
英雄对象

04:36.190 --> 04:39.510
英雄对象里边有什么

04:39.510 --> 04:40.470
有攻击力

04:40.470 --> 04:41.430
攻击力

04:42.830 --> 04:43.270
30

04:43.270 --> 04:44.190
谁写的

04:44.190 --> 04:45.990
HB 血量 300

04:45.990 --> 04:47.430
一个防御力

04:47.430 --> 04:49.390
Defense

04:50.470 --> 04:54.500
Defense 10

04:55.780 --> 04:57.500
有一个就是

04:57.500 --> 04:58.580
就是攻击

04:58.580 --> 04:59.940
有个攻击方法

04:59.940 --> 05:01.660
它有一个方法要进行攻击

05:01.660 --> 05:03.300
比方说的攻击方法

05:03.300 --> 05:05.500
我还叫一个Urtec

05:05.500 --> 05:06.420
这名字重复了

05:06.420 --> 05:07.740
我换一个名字吧

05:07.740 --> 05:08.540
攻击

05:08.540 --> 05:09.260
我们就用攻击

05:10.260 --> 05:11.420
有这么一个方法

05:11.420 --> 05:12.420
表示攻击

05:13.940 --> 05:14.420
攻击

05:15.500 --> 05:16.700
攻击的时候

05:16.700 --> 05:18.780
我们希望

05:18.780 --> 05:20.060
它的攻击力

05:20.100 --> 05:21.780
要随机去

05:21.780 --> 05:23.060
就是浮动

05:23.060 --> 05:24.500
浮动一个攻击力

05:24.500 --> 05:25.660
才产生一个伤害

05:25.660 --> 05:26.220
这个伤害

05:26.220 --> 05:28.380
是根据攻击力随机产生的

05:28.380 --> 05:29.700
我们就随便下去一个例子

05:29.700 --> 05:30.860
你听一听得了

05:30.860 --> 05:32.300
我也不打算把它写完

05:32.300 --> 05:32.980
我就说

05:32.980 --> 05:34.260
我这里的攻击

05:34.260 --> 05:35.420
产生了伤害

05:37.140 --> 05:38.060
伤害

05:38.060 --> 05:40.500
是攻击力

05:40.940 --> 05:41.780
攻击力

05:41.780 --> 05:44.180
乘以一个随机数

05:44.180 --> 05:45.540
乘以一个随机数

05:45.540 --> 05:47.460
这个随机数的取之范围是

05:47.460 --> 05:49.740
0.8

05:49.820 --> 05:53.020
到1.1

05:53.020 --> 05:54.980
当然其实真实要做的话

05:54.980 --> 05:56.700
攻击力还要看对方的防御值

05:56.700 --> 05:57.180
对吧

05:57.180 --> 05:57.820
等等

05:57.820 --> 05:58.980
还要看很多信息

05:59.540 --> 06:00.860
那么现在攻击力我能得到

06:00.860 --> 06:01.140
对吧

06:01.140 --> 06:03.260
攻击力我们可以通过ZsRTAC得到

06:03.260 --> 06:04.100
那么随机数

06:04.220 --> 06:05.220
我怎么来产生个随机数

06:05.220 --> 06:07.300
0.8到1.1

06:07.300 --> 06:08.500
我怎么来产生这个随机数

06:08.500 --> 06:12.260
我是不是要得写这么一个函数

06:12.260 --> 06:14.140
能够帮我们来生成一个随机数

06:15.420 --> 06:16.820
这是一个辅助函数

06:16.820 --> 06:18.180
来帮我们生成随机数

06:18.220 --> 06:19.340
那我们怎么写

06:19.340 --> 06:19.740
你看一下

06:19.740 --> 06:20.740
我们可以这样子写

06:20.740 --> 06:24.260
在这里我们写上一个Gate of Redom

06:24.260 --> 06:25.260
你给我一个最小值

06:25.260 --> 06:25.900
给我一个最大值

06:25.900 --> 06:26.980
我来帮你产生个随机数

06:26.980 --> 06:28.380
当然我产生的是一个小数

06:28.380 --> 06:28.940
不是准数

06:28.940 --> 06:29.860
所以我们直接来

06:29.860 --> 06:31.460
max.redom

06:31.460 --> 06:32.700
乘以什么呢

06:32.700 --> 06:35.380
max解密加上密

06:35.380 --> 06:36.580
来产生这么一个随机数

06:36.580 --> 06:37.460
对吧

06:37.460 --> 06:38.780
根据最小值

06:38.780 --> 06:41.820
根据最小值和最大值

06:41.820 --> 06:43.500
产生一个随机数

06:43.500 --> 06:44.180
当然这个东西

06:44.180 --> 06:46.460
大家应该非常熟悉了

06:46.500 --> 06:48.260
随机数

06:48.260 --> 06:49.460
只不过我没怕转换准数

06:49.460 --> 06:50.620
因为它这里不需要准数

06:50.620 --> 06:52.100
它有保留小数的

06:52.100 --> 06:53.700
那么这里伤害是什么

06:53.700 --> 06:54.260
来的

06:54.260 --> 06:55.900
damage

06:55.900 --> 06:59.020
伤害就是攻击力乘以一个随机数

06:59.020 --> 07:03.740
this gets rid of 0.8

07:03.740 --> 07:04.420
到多少呢

07:04.420 --> 07:05.180
1.1

07:05.180 --> 07:06.020
对吧

07:06.020 --> 07:07.220
是不是这样子写的

07:07.220 --> 07:07.900
产生伤害

07:07.900 --> 07:10.140
我们这里可以输出伤害

07:10.140 --> 07:11.740
我不是说要运行这个代码

07:11.740 --> 07:12.620
这个代码运不运行

07:12.620 --> 07:13.020
无所谓

07:13.020 --> 07:15.300
我主要说明一个问题

07:15.340 --> 07:16.740
你看一下英雄里边

07:16.740 --> 07:19.820
有一些东西是不是不应该公开的

07:19.820 --> 07:21.900
不应该给别人访问的

07:21.900 --> 07:24.060
不是说什么安全性问题

07:24.060 --> 07:25.540
你可以别人访问干嘛

07:25.540 --> 07:26.580
你说这个东西

07:26.580 --> 07:27.220
什么东西

07:27.220 --> 07:28.860
就这个玩意儿

07:28.860 --> 07:30.340
这个玩意儿

07:30.340 --> 07:33.460
需不需要在外面通过英雄对象来调用这个玩意儿

07:33.460 --> 07:35.420
需不需要通他的调用

07:35.420 --> 07:36.860
有意义吗

07:36.860 --> 07:38.260
没有任何意义

07:38.260 --> 07:42.380
因为这个函数是为了内部实现而出现的

07:42.380 --> 07:44.740
就是为了实现攻击方法

07:44.740 --> 07:45.900
我觉得

07:45.900 --> 07:47.660
我觉得这里少一个功能

07:47.660 --> 07:48.980
我下码的功能

07:48.980 --> 07:50.620
我就是少一个工具

07:50.620 --> 07:51.780
我下码用一下这个工具

07:51.780 --> 07:53.020
来帮我产生的函数

07:53.020 --> 07:55.860
它是为了实现这个方法而产生的

07:55.860 --> 07:57.580
它不是为了给外面用的

07:57.580 --> 07:59.820
外面可以用它的攻击力血量

07:59.820 --> 08:00.620
可以用防御值

08:00.620 --> 08:01.340
可以用攻击

08:01.340 --> 08:03.060
但是不希望它用这个方法

08:03.060 --> 08:04.460
用这个方法没意义

08:04.460 --> 08:06.500
不是说什么安全不安全的问题

08:06.500 --> 08:08.220
一个别人看到这个方法干嘛呢

08:08.220 --> 08:10.900
就比方说我们在网上去买一些东西的时候

08:10.900 --> 08:13.100
比方买一些家电的时候

08:13.140 --> 08:14.580
是不是用者越简单

08:14.580 --> 08:15.540
别人用者越舒服

08:15.540 --> 08:16.820
对不对

08:16.820 --> 08:18.620
你的可以超数的东西

08:18.620 --> 08:20.140
越简单用者越舒服

08:20.140 --> 08:21.460
比如说现在的电视

08:21.460 --> 08:22.820
不就是只有遥控器

08:22.820 --> 08:24.140
不就几个按钮吗

08:24.140 --> 08:25.380
四五个按钮可以搞定了

08:25.380 --> 08:26.100
对吧

08:26.100 --> 08:27.380
以前的遥控器一大堆

08:27.380 --> 08:28.500
你想看到这些东西吗

08:28.500 --> 08:30.220
没必要

08:30.220 --> 08:31.900
比方说你买一个微波炉

08:31.900 --> 08:33.580
你肯定希望它用的越简单越好

08:33.580 --> 08:34.580
比方说上面两三个按钮

08:34.580 --> 08:36.500
一个是开始一个是结束

08:36.500 --> 08:37.540
对吧

08:37.540 --> 08:38.940
就完了

08:38.940 --> 08:40.300
最多我现在就两个选令

08:40.300 --> 08:41.500
可以调时间

08:43.100 --> 08:45.340
因为我暴露那么多的按钮干嘛呢

08:45.340 --> 08:46.540
比如说你去买一个微波炉

08:46.540 --> 08:48.180
他给你1000个按钮上面

08:48.180 --> 08:49.700
最后个按钮写的自暴

08:49.700 --> 08:51.260
下面现在还写的一行字

08:51.260 --> 08:53.060
就说千万不要去按

08:53.060 --> 08:54.260
那有什么意义呢

08:54.260 --> 08:56.140
你都不希望别人用

08:56.140 --> 08:57.940
那你去暴露这个东西干嘛呢

08:57.940 --> 09:00.540
但是以前既也是做不到

09:00.540 --> 09:01.660
他做不到

09:01.660 --> 09:03.420
他写的所有成员都要暴露

09:03.420 --> 09:04.380
暴露出去

09:04.380 --> 09:06.220
那别人就可以看到这个对象里面

09:06.220 --> 09:07.620
一大堆断起八道东西

09:07.620 --> 09:08.180
所以说呢

09:08.180 --> 09:09.380
大家应该有这么一个

09:09.380 --> 09:10.540
应该有点印象啊

09:10.540 --> 09:13.660
就里面以前学学的我支持体系里边

09:13.660 --> 09:16.820
就是你但用一些第三方的介石库的时候

09:16.820 --> 09:17.860
他给了一些对象

09:17.860 --> 09:19.660
给了一些函数之类的东西

09:19.660 --> 09:20.980
你在控制台里面一打印

09:20.980 --> 09:22.700
他你会发现他里面一大堆东西

09:22.700 --> 09:23.700
一大堆属性

09:23.700 --> 09:25.460
但是绝大部分属性我们根本就用不到

09:25.460 --> 09:26.060
于是呢

09:26.060 --> 09:29.100
他为了不希望你去用这些属性

09:29.100 --> 09:30.060
不是为了安全啊

09:30.060 --> 09:31.180
不是为了安全

09:31.180 --> 09:33.260
他就是为了避免干扰你

09:33.260 --> 09:34.940
为了不希望你去用这些属性

09:34.940 --> 09:36.300
他一般会这个属性

09:36.300 --> 09:38.380
成员前面是不是加两个下滑线

09:38.380 --> 09:39.660
或者是加一些特殊字

09:39.700 --> 09:41.020
字符比较多了

09:41.020 --> 09:41.300
对吧

09:41.300 --> 09:42.340
加一些特殊字符

09:42.340 --> 09:44.940
都是为了不希望你去用这个东西

09:44.940 --> 09:45.660
啊

09:45.660 --> 09:46.700
不管他加啥吧

09:46.700 --> 09:47.860
不同的第三方库

09:47.860 --> 09:49.940
他加的一些特殊属性不一样

09:49.940 --> 09:51.180
一般就是下滑线

09:51.180 --> 09:52.580
或者是一些特殊字符

09:52.580 --> 09:54.580
都是为了不希望你去用这个

09:54.580 --> 09:56.620
给你造成一些麻烦

09:56.620 --> 09:57.140
啊

09:57.140 --> 09:58.940
所以我们有这么一个需求啊

09:58.940 --> 10:00.820
就是我们不想暴露给外面的东西

10:00.820 --> 10:03.500
我不希望那么轻松的被外面访问到

10:03.500 --> 10:05.100
我们有这么一个需求

10:05.100 --> 10:06.540
以前面对这个需求呢

10:06.540 --> 10:08.620
要么就是写一些特殊的成员名

10:08.660 --> 10:09.780
要么呢就这样子写

10:11.220 --> 10:12.300
把这个玩意儿写里面

10:13.500 --> 10:14.580
把这个玩意儿写里面

10:14.580 --> 10:16.220
但是写里面好不好呢

10:16.220 --> 10:17.100
其实也不好

10:18.420 --> 10:19.540
也不好

10:19.540 --> 10:20.300
把这个玩意儿写里面

10:20.300 --> 10:21.420
外面是不是不能访问的

10:21.420 --> 10:21.620
对吧

10:21.620 --> 10:23.060
这是他内部的成

10:23.060 --> 10:24.220
内部的东西啊

10:24.220 --> 10:25.020
他外面不能访问的

10:25.020 --> 10:25.860
这是函数作用于

10:27.180 --> 10:28.220
但是这个东西也不好

10:28.220 --> 10:28.780
为什么不好呢

10:28.780 --> 10:29.700
第一个问题

10:29.700 --> 10:31.140
每一次调用攻击方法

10:31.140 --> 10:32.500
是不是都要创建一个新的函数

10:32.500 --> 10:33.580
有这个必要吗

10:33.580 --> 10:35.300
这个函数只创建一次又够了呀

10:35.300 --> 10:35.980
那有这个必要

10:36.060 --> 10:37.700
重新创建一个新的函数吗

10:37.700 --> 10:38.780
浪费内存空间

10:38.780 --> 10:39.820
对吧

10:39.820 --> 10:40.940
还有一个问题

10:40.940 --> 10:42.180
如果别的方法

10:42.180 --> 10:43.620
就是英雄里边别的方法

10:43.620 --> 10:44.860
也要用这个东西怎么办

10:44.860 --> 10:46.180
也没法共享

10:46.180 --> 10:47.820
就造成各种各样的麻烦

10:47.820 --> 10:48.700
啊

10:48.700 --> 10:49.580
明白我的意思吗

10:50.780 --> 10:53.100
练这种意思就是缺失了什么

10:53.100 --> 10:55.340
缺失了私有属性

10:55.340 --> 10:57.100
私有属性是什么意思

10:57.100 --> 10:58.380
私有属性就是

10:58.380 --> 10:59.340
只有

10:59.340 --> 11:00.060
啊

11:00.060 --> 11:03.320
私有属性

11:03.320 --> 11:04.400
就私有成员

11:04.400 --> 11:05.480
不管是属性还是方法

11:05.480 --> 11:07.360
因为方法本质也是属性嘛

11:07.440 --> 11:09.400
私有成员的含义就是

11:09.400 --> 11:12.200
只能在对象中

11:12.200 --> 11:13.720
内部使用

11:13.720 --> 11:15.120
内部使用

11:15.120 --> 11:17.520
外面

11:17.520 --> 11:18.240
无法使用

11:18.240 --> 11:18.920
那么现在呢

11:18.920 --> 11:20.000
其实我们学了

11:20.000 --> 11:22.000
学了就是耶稣牛里边的内

11:22.000 --> 11:23.840
内同样有这样的需求啊

11:23.840 --> 11:24.680
同样的

11:24.680 --> 11:27.080
比方说我们写这么一个英雄类

11:27.080 --> 11:28.680
我们写这么一个英雄类

11:28.680 --> 11:29.800
class

11:29.800 --> 11:30.840
here的

11:30.840 --> 11:31.800
一个英雄类

11:31.800 --> 11:32.560
它里边呢

11:32.560 --> 11:33.520
一个constructor

11:33.520 --> 11:34.440
你给我传递什么

11:34.440 --> 11:35.120
攻击力

11:35.120 --> 11:35.640
攻击力

11:35.640 --> 11:37.200
我就帮你创建一个英雄

11:37.840 --> 11:38.880
生命值

11:38.880 --> 11:39.640
还有什么呢

11:39.640 --> 11:41.360
还有就是一个防御力

11:41.360 --> 11:41.920
啊

11:41.920 --> 11:42.560
防御力

11:42.560 --> 11:43.920
我来帮你创建这么一个英雄

11:43.920 --> 11:44.520
啊

11:44.520 --> 11:45.760
attack

11:45.760 --> 11:46.760
啊

11:46.760 --> 11:48.000
this.hp

11:48.000 --> 11:49.040
对于hp

11:49.040 --> 11:50.280
this.defense

11:50.280 --> 11:51.240
对于defense

11:52.160 --> 11:52.560
然后呢

11:52.560 --> 11:54.120
英雄里边有个方法叫做

11:54.120 --> 11:54.720
攻击

11:54.720 --> 11:55.640
攻击方法

11:55.640 --> 11:56.680
那是一样的问题

11:56.680 --> 11:57.160
对吧

11:57.160 --> 11:58.160
一样的问题

11:58.160 --> 11:58.880
那么

11:58.880 --> 11:59.440
攻击方法

11:59.440 --> 12:00.720
我们把这个放过来

12:01.600 --> 12:01.880
好

12:01.880 --> 12:03.520
那么他同样要产生一个随技术

12:03.520 --> 12:03.720
好

12:03.720 --> 12:04.200
随技术呢

12:04.200 --> 12:05.240
我又迫不得已

12:05.240 --> 12:05.520
对吧

12:05.520 --> 12:06.400
又是刚才那个问题

12:06.400 --> 12:08.040
我要写个随技术含书

12:08.680 --> 12:09.320
所以要写个

12:10.560 --> 12:12.120
我们又要写个随技术含书

12:12.120 --> 12:12.400
对不对

12:14.400 --> 12:14.920
有人说

12:14.920 --> 12:15.920
那这个随技术含书

12:15.920 --> 12:17.120
我能不能专门来放了

12:17.120 --> 12:18.000
放到外面去了

12:18.000 --> 12:19.400
放到别的地方了

12:19.400 --> 12:19.960
可以

12:19.960 --> 12:20.680
那放了别的地方

12:20.680 --> 12:23.720
确实确实没有污染这个英雄

12:23.720 --> 12:24.560
外面也访问不到

12:24.560 --> 12:26.880
通过英雄也访问不到这个方法

12:26.880 --> 12:27.400
但是呢

12:27.400 --> 12:28.320
如果说这个方法里边

12:28.320 --> 12:30.840
还要用到英雄的属性怎么办呢

12:30.840 --> 12:31.720
那又怎么办呢

12:31.720 --> 12:32.120
他要

12:32.120 --> 12:33.000
这个方法要跟Z

12:33.000 --> 12:34.480
跟英雄的Z是绑在一起

12:34.480 --> 12:35.640
要用到Z是怎么办

12:35.680 --> 12:36.720
又麻烦了

12:37.360 --> 12:39.560
就是有的是你跑不了的

12:39.560 --> 12:40.800
你的内里边也好

12:40.800 --> 12:42.040
你的对象里边也好

12:42.040 --> 12:43.200
有这么一些方法

12:43.200 --> 12:43.800
这些方法

12:43.800 --> 12:45.520
我只想自己用

12:45.520 --> 12:46.560
别人不要用

12:46.560 --> 12:48.080
或者说一些属性

12:48.080 --> 12:49.080
只想自己用

12:49.080 --> 12:49.840
别人不要用

12:49.840 --> 12:51.480
以前就办不到

12:51.480 --> 12:52.680
办不到

12:52.680 --> 12:54.680
那么也是设计这个符号的初衷

12:54.680 --> 12:56.000
就是为了解决这个问题

12:56.600 --> 12:57.920
那他到底怎么解决的呢

12:57.920 --> 12:59.560
我们以后看一下符号的特点

12:59.560 --> 13:00.680
就知道怎么解决了

13:00.680 --> 13:01.480
好吧

13:01.480 --> 13:01.720
好

13:01.720 --> 13:03.320
我们先来看符号的特点

13:03.320 --> 13:03.880
慢慢来

13:03.880 --> 13:04.600
不着急

13:05.480 --> 13:06.720
第一个特点

13:06.720 --> 13:08.840
符号它没有字面量

13:10.520 --> 13:13.040
这是所有的GS内形中

13:13.040 --> 13:14.040
都不具备的特点

13:15.200 --> 13:16.240
拿着你看一下

13:16.240 --> 13:17.720
GS里面这些内形

13:17.720 --> 13:19.400
哪个没有字面量

13:19.400 --> 13:19.920
数字

13:21.200 --> 13:23.320
这不就是数字的字面量吗

13:23.320 --> 13:24.120
字不错

13:24.120 --> 13:25.120
这是字不错的字面量

13:25.120 --> 13:25.480
对吧

13:25.480 --> 13:26.360
直接书写个字不错

13:27.400 --> 13:27.880
来

13:27.880 --> 13:30.640
NOW字面量

13:30.640 --> 13:31.640
字面量

13:31.640 --> 13:33.600
UND字面量

13:33.640 --> 13:34.600
BOR2

13:34.600 --> 13:35.840
或者是FORCE字面量

13:37.160 --> 13:37.920
还有什么呢

13:37.920 --> 13:38.920
还有对象

13:38.920 --> 13:39.600
对象的字面量

13:39.600 --> 13:40.640
那更加常见了

13:40.640 --> 13:41.840
两个大过号字面量

13:41.840 --> 13:42.400
对吧

13:42.400 --> 13:44.000
每一个内形都有字面量

13:44.000 --> 13:45.000
就直接书写

13:45.000 --> 13:46.560
直接书写它的数据

13:46.560 --> 13:47.920
可是符号没有

13:48.920 --> 13:50.040
也没有任何一种语法

13:50.040 --> 13:51.720
可以书写一个符号的字面量

13:51.720 --> 13:53.600
符号要得到一个符号数据

13:53.600 --> 13:56.000
只能通过symbol函数

13:56.000 --> 13:56.960
只能通过这样的写法

13:58.160 --> 13:58.960
通过这样的方式

13:58.960 --> 13:59.920
来写这么一个symbol

14:00.960 --> 14:01.960
这是关于它第一个特点

14:02.960 --> 14:04.000
第二个

14:04.000 --> 14:05.720
由于符号是一个新的内形

14:05.720 --> 14:07.000
那么我们以前有个运算符

14:07.000 --> 14:08.200
叫Typle

14:08.200 --> 14:09.640
那么通过它来得到的内形

14:10.960 --> 14:12.040
就是symbol

14:12.040 --> 14:13.560
你不要期望它得到的内形

14:13.560 --> 14:14.240
是什么object

14:14.240 --> 14:14.600
不是

14:14.600 --> 14:15.400
它就是一个symbol

14:15.400 --> 14:15.880
我们来看一下

14:19.040 --> 14:19.960
我们把它都复制过来

14:23.320 --> 14:25.120
我们来输出一下

14:25.120 --> 14:25.800
他们的内形

14:25.800 --> 14:27.000
Typle

14:27.000 --> 14:28.000
symbol1

14:28.000 --> 14:29.040
Typle

14:29.040 --> 14:30.400
symbol2

14:30.400 --> 14:30.960
你看一下吧

14:32.480 --> 14:33.280
symbol

14:33.360 --> 14:34.040
symbol

14:34.040 --> 14:34.480
对吧

14:34.480 --> 14:35.600
它得到的就是symbol

14:35.600 --> 14:37.720
所以说以后你要看一个东西

14:37.720 --> 14:38.360
是不是符号

14:38.360 --> 14:39.760
是不是可以用Typle来判断

14:39.760 --> 14:41.880
判断它是不是等于什么symbol

14:42.840 --> 14:45.400
看一下它是不是等于symbol

14:45.400 --> 14:46.520
要用这种方式来判断

14:47.520 --> 14:48.600
不管你有没有名字

14:48.600 --> 14:49.320
不管你这个符号

14:49.320 --> 14:51.080
有没有给它写一些描述

14:51.080 --> 14:52.160
有没有写描述都无所谓

14:52.160 --> 14:54.280
它内形一定是symbol

14:54.280 --> 14:55.240
它多了一种内形

14:56.800 --> 14:57.800
第三个特点

14:57.800 --> 14:58.880
特别特别重要

15:00.440 --> 15:01.200
第三个特点

15:01.200 --> 15:02.600
就决定了它

15:02.600 --> 15:04.600
为什么可以把它作为私有属相

15:04.600 --> 15:05.360
第三个特点什么

15:06.360 --> 15:09.000
每一次调用symbol函数

15:09.000 --> 15:11.640
得到的符号永远不相等

15:11.640 --> 15:14.040
无论符号名释放相同

15:14.040 --> 15:15.280
什么意思呢

15:15.280 --> 15:16.800
就说我们来看一下

15:16.800 --> 15:18.000
看一下这么个例子

15:18.000 --> 15:18.760
又来复制一下

15:21.600 --> 15:22.680
symbol1

15:22.680 --> 15:23.280
symbol2

15:23.280 --> 15:24.400
我们用这种方式

15:25.480 --> 15:27.120
输出symbol1

15:27.120 --> 15:28.360
是不是等于symbol2的

15:29.760 --> 15:31.480
输出 force

15:31.480 --> 15:33.160
你通过这个东西

15:33.160 --> 15:36.560
得到了符号永远不相等

15:36.560 --> 15:37.600
永远不相等

15:37.600 --> 15:38.600
只要你相当于是

15:38.600 --> 15:40.160
你可以这样理解

15:40.160 --> 15:41.480
每一次调用这个东西

15:41.480 --> 15:42.440
去产生一个新的对象

15:42.440 --> 15:42.760
算了

15:42.760 --> 15:43.720
你不要这样理解

15:43.720 --> 15:44.360
你又不让的话

15:44.360 --> 15:46.960
你又跟对象搞混在一起了

15:46.960 --> 15:48.520
你可以这样子感觉

15:48.520 --> 15:49.960
对象是不是每一次创建

15:49.960 --> 15:50.600
都是一个新的

15:50.600 --> 15:51.880
哪怕里边的属性全部一样

15:51.880 --> 15:53.320
它都是一个不同的地址

15:53.320 --> 15:53.800
对吧

15:53.800 --> 15:54.520
那么这个符号

15:54.520 --> 15:55.320
以类似

15:55.320 --> 15:56.520
类似

15:56.520 --> 15:57.720
每一个符号通过这个函数

15:57.720 --> 15:59.240
含在的都是一个新的符号

15:59.240 --> 16:01.160
哪怕你这里边给它用描述信息

16:01.160 --> 16:03.960
完全一样的描述信息

16:03.960 --> 16:04.760
这个描述信息

16:04.760 --> 16:06.360
只是起个调试的作用

16:06.360 --> 16:07.320
有的时候我想看一下

16:07.320 --> 16:08.280
这个符号

16:08.280 --> 16:10.240
我当时为什么要创建这个符号

16:10.240 --> 16:11.680
它的描述信息是啥

16:11.680 --> 16:13.600
我主要是起这么一个目的

16:13.600 --> 16:16.320
因为我到时候输出这个符号的时候

16:16.320 --> 16:18.040
输出这个符号的时候

16:18.040 --> 16:19.640
它会把它转换成制服串来输出

16:19.640 --> 16:19.960
你看

16:19.960 --> 16:21.440
它这里边有个描述信息

16:21.440 --> 16:22.800
它会把一个描述信息带上

16:22.800 --> 16:23.800
就起这么一个作用

16:23.800 --> 16:24.560
描述信息

16:24.560 --> 16:25.560
没有别的作用了

16:25.560 --> 16:26.320
也就是说你这里

16:26.320 --> 16:27.800
如果说你能够确切的

16:27.800 --> 16:29.480
清楚你这个符号要干嘛

16:29.480 --> 16:31.000
通过这个符号的名称

16:31.000 --> 16:32.800
你能非常清楚能干嘛

16:32.800 --> 16:33.360
那么OK

16:33.360 --> 16:36.080
你可以不写描述信息都可以

16:36.080 --> 16:37.680
描述信息只是为了我们方便

16:37.680 --> 16:38.360
我们调试

16:38.360 --> 16:39.600
方便我们开发者

16:39.600 --> 16:41.720
能够知道这个符号到底有什么用

16:41.720 --> 16:43.840
比如说我们这里还可以写传中文

16:43.840 --> 16:47.120
这是随便写的一个符号

16:47.120 --> 16:47.640
都可以

16:47.640 --> 16:49.640
而一个描述信息而已

16:49.640 --> 16:52.400
那么这里也是一样

16:52.400 --> 16:53.200
描述信息

16:53.200 --> 16:54.240
哪怕你给它一样

16:54.240 --> 16:56.520
你会发现它的还是Force

16:56.520 --> 16:58.080
符号永远是唯一的

16:58.080 --> 16:59.440
通过symbol创建的符号

16:59.440 --> 17:01.080
永远不相同

17:01.080 --> 17:03.240
开始慢慢接近答案了

17:03.240 --> 17:05.880
再看下面一个特点

17:05.880 --> 17:09.280
符号可以作为对翼象的属性名存在

17:09.280 --> 17:12.120
这种属性称为符号属性

17:12.120 --> 17:13.840
特别有意思

17:13.840 --> 17:15.240
以前我们咋说的

17:15.240 --> 17:19.520
我们说一个对翼象的属性名

17:19.520 --> 17:22.440
它一定是一个支付串

17:22.440 --> 17:25.240
有没有听说过这句话

17:25.240 --> 17:26.200
一定听说过这句话

17:26.200 --> 17:27.160
对吧

17:27.160 --> 17:28.960
对翼象的属性名

17:29.000 --> 17:31.080
它一定是一个支付串

17:31.080 --> 17:32.360
哎呦 它不对啊

17:32.360 --> 17:35.520
我这个是个输主啊

17:35.520 --> 17:36.600
我这里不是

17:36.600 --> 17:38.640
以前我们写过输主对吧

17:38.640 --> 17:39.800
输主是不对象

17:39.800 --> 17:40.640
是对象

17:40.640 --> 17:41.800
也输主的属性名

17:41.800 --> 17:42.800
它为什么不是支付串

17:42.800 --> 17:44.800
是一个数字呢

17:44.800 --> 17:47.120
它是不是支付串

17:47.120 --> 17:49.440
它是不是支付串

17:49.440 --> 17:51.360
它仍然是支付串

17:51.360 --> 17:52.840
只不过你写数字的时候

17:52.840 --> 17:54.760
它会自动把它转换成支付串

17:54.760 --> 17:58.040
所有的属性名一定是支付串

17:58.080 --> 17:59.960
但是现在的不一样了

17:59.960 --> 18:02.120
由于多了一个符号

18:02.120 --> 18:04.240
那么es6规定

18:04.240 --> 18:06.280
现在对象的属性名

18:06.280 --> 18:08.200
除了是支付串之外

18:08.200 --> 18:10.520
还可以是一个符号类型

18:10.520 --> 18:11.280
那么这样的是

18:11.280 --> 18:13.040
如果说一个属性名字

18:13.040 --> 18:14.640
它是一个符号类型

18:14.640 --> 18:17.920
那么它叫做符号属性

18:17.920 --> 18:19.800
符号属性

18:19.800 --> 18:21.720
那么这个符号属性怎么写呢

18:21.720 --> 18:24.870
给它写一个

18:24.870 --> 18:25.870
复制一个

18:25.870 --> 18:27.430
给它写一个符号属性

18:27.430 --> 18:28.790
不要说这个

18:28.870 --> 18:30.590
就是随便写个描述

18:30.590 --> 18:33.150
让这个描述写不写无所谓

18:33.150 --> 18:39.710
这是用于对象的一个属性

18:39.710 --> 18:40.470
就这个符号

18:40.470 --> 18:42.910
我要把它变成一个对象的属性名

18:42.910 --> 18:46.040
你看一下我怎么写

18:46.040 --> 18:46.960
有的

18:46.960 --> 18:48.800
就随便写OBG

18:48.800 --> 18:49.840
有一些普通属性名

18:49.840 --> 18:50.560
A

18:50.560 --> 18:51.560
你看A就是一个普通的

18:51.560 --> 18:52.440
支付串属性名

18:52.440 --> 18:52.840
对吧

18:52.840 --> 18:54.560
你这样的写跟这样子写

18:54.560 --> 18:55.480
效果是一样的

18:55.480 --> 18:56.200
对吧

18:56.200 --> 18:57.280
A等于1

18:57.280 --> 18:57.840
B等于2

18:57.840 --> 18:58.680
好

18:58.680 --> 18:59.640
第三个属性

18:59.680 --> 19:01.440
我打算使用符号

19:01.440 --> 19:02.160
那么你怎么写

19:02.160 --> 19:03.880
你不能这样子写

19:03.880 --> 19:05.160
这样写的话

19:05.160 --> 19:06.880
它的属性名仍然是一个支付串

19:06.880 --> 19:09.000
它的属性名叫做SYB1

19:10.000 --> 19:11.400
它用的不是这个变量

19:11.400 --> 19:12.000
那怎么写

19:12.000 --> 19:15.200
我们使用可计算的属性名

19:15.200 --> 19:16.200
加两个中复号

19:16.200 --> 19:17.640
我们以前是不是讲过

19:17.640 --> 19:19.720
这里面是不是可以写JS表达式

19:19.720 --> 19:20.720
对吧

19:20.720 --> 19:22.880
把表达式的结果作为属性名

19:22.880 --> 19:24.560
那么我们把表达式写成吗

19:24.560 --> 19:26.760
就写符号

19:26.760 --> 19:29.520
那么就把符号的值作为属性名

19:30.520 --> 19:31.880
三

19:31.880 --> 19:33.400
你看这个对象

19:33.400 --> 19:34.240
它就

19:34.240 --> 19:37.200
第三个这个属性就是一个符号属性

19:37.200 --> 19:38.400
因为你写的一个符号

19:38.400 --> 19:42.080
它现在的属性名就不再是支付串了

19:42.080 --> 19:43.240
不是支付串了

19:43.240 --> 19:44.760
是一个符号

19:44.760 --> 19:46.240
你看

19:46.240 --> 19:46.880
A

19:46.880 --> 19:47.280
B

19:47.280 --> 19:48.400
第三个属性

19:48.400 --> 19:49.120
是不是个符号

19:49.120 --> 19:49.640
你看这个玩意

19:49.640 --> 19:50.640
是不是个符号

19:50.640 --> 19:50.960
对吧

19:50.960 --> 19:52.320
它是个符号

19:52.320 --> 19:53.880
三

19:53.880 --> 19:58.160
也就是现在我们对象里边可以用符号作为属性名

19:58.200 --> 20:00.040
这个属性叫做符号属性

20:00.040 --> 20:01.520
符号属性它的值随便

20:01.520 --> 20:03.160
值可以是任何东西

20:03.160 --> 20:05.480
值是名字把它变成符号

20:05.480 --> 20:06.960
慢慢的不着急

20:06.960 --> 20:09.080
越来越接近答案了

20:09.080 --> 20:11.920
于是基于这么个特点

20:11.920 --> 20:13.000
你看着

20:13.000 --> 20:16.560
开发者可以通过精心的设计

20:16.560 --> 20:18.680
让这些符号属性

20:18.680 --> 20:21.720
无法通过常规方式被外界访问

20:21.720 --> 20:24.520
怎么去精心设计呢

20:24.520 --> 20:26.880
怎么去精心设计呢

20:26.920 --> 20:30.000
回到刚才的一个例子

20:30.000 --> 20:31.160
这里

20:31.160 --> 20:32.160
这里有个对象

20:34.160 --> 20:35.280
看着

20:35.280 --> 20:36.120
这里复制一个吧

20:36.120 --> 20:37.120
重新拿一个

20:38.440 --> 20:40.040
把这个先复制过来

20:41.480 --> 20:41.840
好

20:41.840 --> 20:42.960
你看着

20:42.960 --> 20:43.800
这里有个对象

20:43.800 --> 20:47.320
我不希望把这个东西变成一个私有的属性

20:47.320 --> 20:48.200
私有成员

20:48.200 --> 20:48.640
对吧

20:48.640 --> 20:49.680
不管是属性也好

20:49.680 --> 20:50.840
还是方法也好

20:50.840 --> 20:51.800
都是成员

20:51.800 --> 20:53.440
都其实本质上都是属性

20:53.440 --> 20:55.920
我希望把它变成一个私有属性

20:55.920 --> 20:57.200
那如果我用普通的属性

20:57.240 --> 20:58.480
外面一定能访问

20:58.480 --> 21:01.280
但是由于符号的东西存在

21:01.280 --> 21:02.520
于是它有这么一个特点

21:02.520 --> 21:03.640
符号有这么一个特点

21:03.640 --> 21:04.760
什么特点呢

21:04.760 --> 21:06.440
符号的特点是

21:06.440 --> 21:07.920
它是唯一的

21:07.920 --> 21:10.080
你永远无法

21:10.080 --> 21:14.000
就是你永远无法产生一个完全一样的符号

21:14.000 --> 21:16.160
哪怕你的名字是一样的

21:16.160 --> 21:18.480
因此我们可以这样去看着

21:18.480 --> 21:23.190
我们这里能把它写成一个立即执行函数

21:23.190 --> 21:28.420
写成一个立即执行函数

21:28.420 --> 21:29.100
对了

21:29.140 --> 21:31.220
这个函数返回一个对象

21:31.220 --> 21:33.260
返回的是一个对象

21:33.260 --> 21:34.460
这个对象里边

21:34.460 --> 21:35.980
这个地方是不是一个普通属性

21:35.980 --> 21:37.900
那么现在还是同样的问题

21:37.900 --> 21:39.900
一看一下我们输出还是同样的问题

21:39.900 --> 21:40.780
它把它暴露出来了

21:40.780 --> 21:41.700
外面是可以访问的

21:41.700 --> 21:42.340
get random

21:42.340 --> 21:42.580
对吧

21:42.580 --> 21:43.740
是可以访问的

21:43.740 --> 21:43.900
好

21:43.900 --> 21:44.500
那么接下来

21:44.500 --> 21:47.140
我把属性变成一个符号属性

21:47.140 --> 21:48.700
我们在这里这个函数里边

21:48.700 --> 21:49.940
因为这是立即执行函数

21:49.940 --> 21:51.980
它是用了就它就消失到里边的东西

21:51.980 --> 21:53.700
我们这里写上那么一个符号

21:53.700 --> 21:56.980
叫做get random

21:56.980 --> 21:58.140
这个符号我们变

21:58.180 --> 21:59.340
这是个变量名

21:59.340 --> 22:00.940
这只是一个变量名而已

22:00.940 --> 22:02.260
不要那么认真

22:02.260 --> 22:03.340
我完全可以写ABC

22:03.340 --> 22:04.820
随便啥都可以

22:04.820 --> 22:06.500
那么我们这里创建一个符号

22:06.500 --> 22:07.860
symbol

22:07.860 --> 22:09.540
创建一个符号

22:09.540 --> 22:15.580
这是用于产生随机数的符号

22:15.580 --> 22:18.300
产生随机数的成员的符号

22:18.300 --> 22:20.020
当然你可以不写描述都可以

22:20.020 --> 22:20.380
无所谓

22:20.380 --> 22:22.100
写不写描述都无所谓

22:22.100 --> 22:22.340
好

22:22.340 --> 22:23.060
接下来

22:23.060 --> 22:24.300
这是一个符号

22:24.300 --> 22:26.460
然后我们这里是不是用

22:26.460 --> 22:27.660
这种方式

22:27.700 --> 22:29.540
可计算的属性名

22:29.540 --> 22:30.380
有些人可能看不懂了

22:30.380 --> 22:31.540
看不懂我这样写吧

22:31.540 --> 22:32.900
这样写是不是能看懂

22:32.900 --> 22:33.420
能看懂吧

22:33.420 --> 22:34.500
这是属性名

22:34.500 --> 22:34.980
对吧

22:34.980 --> 22:36.700
通过一个表达式来得到属性名

22:36.700 --> 22:38.220
当然可以用数写方式

22:40.020 --> 22:41.940
那么到时候我要调用怎么办

22:41.940 --> 22:42.740
你看着

22:42.740 --> 22:44.340
我们在攻击里边要调用一个方法

22:44.340 --> 22:45.820
怎么调用的Z

22:47.180 --> 22:48.060
因为它的属性名

22:48.060 --> 22:49.020
你不能这样子写了

22:49.020 --> 22:50.020
这样子写是不是访问的是

22:50.020 --> 22:51.300
字不错的属性

22:51.300 --> 22:52.900
你这样写能能有效吗

22:52.900 --> 22:53.940
我们Hero

22:54.060 --> 22:57.580
叫HeroDirty

22:57.580 --> 22:58.780
那就是攻击

22:58.780 --> 22:59.580
调用一下攻击

22:59.580 --> 23:01.020
你看一下能有效吗

23:01.020 --> 23:02.020
它说什么

23:02.020 --> 23:03.980
GetThreader一直拿出方形

23:03.980 --> 23:05.180
GetThreader根本就不存在

23:05.180 --> 23:07.100
它说没有这个东西

23:07.100 --> 23:07.540
为什么呢

23:07.540 --> 23:08.220
它找不到

23:08.220 --> 23:08.780
它找它

23:08.780 --> 23:09.860
它找字不错的属性

23:09.860 --> 23:10.780
GetThreader它没有

23:10.780 --> 23:11.500
哪有字不错的属性

23:11.500 --> 23:12.420
GetThreader

23:12.420 --> 23:13.780
但它有个符号属性

23:13.780 --> 23:15.700
是不是我们也是一样的

23:15.700 --> 23:18.260
用类似于数组的方式

23:18.260 --> 23:18.620
对吧

23:18.620 --> 23:20.180
类似于数组的方式

23:20.180 --> 23:21.180
是不是可以得到

23:21.180 --> 23:21.980
把这个东西的

23:22.020 --> 23:23.220
把这个辨量的字

23:23.220 --> 23:24.220
作为属性

23:24.220 --> 23:25.340
去找这个属性

23:25.340 --> 23:26.860
找到是这个符号属性

23:26.860 --> 23:27.540
看到没

23:27.540 --> 23:29.220
调用的是这个符号属性

23:29.220 --> 23:30.500
那么现在就没问题了

23:30.500 --> 23:31.540
看到没有

23:31.540 --> 23:33.260
这是伤害

23:33.260 --> 23:34.860
就没问题了

23:34.860 --> 23:35.820
然后我们再看

23:35.820 --> 23:37.340
这样子写了过后

23:37.340 --> 23:38.220
外边我们得到了

23:38.220 --> 23:40.140
英雄对象是啥呢

23:40.140 --> 23:42.300
是不是就有一个符号属性了

23:42.300 --> 23:43.420
看到见呀

23:43.420 --> 23:44.820
有时候还说看得见呀

23:44.820 --> 23:47.060
那我外边可能还是会去难用啊

23:47.060 --> 23:47.460
来吧

23:47.460 --> 23:48.380
你外面给我用一下

23:48.380 --> 23:49.180
试一下

23:49.180 --> 23:50.980
你怎么去用这个GetThreader

23:51.020 --> 23:52.260
外面怎么去用

23:52.260 --> 23:54.900
你怎么用都用不了

23:54.900 --> 23:56.580
GetThreader is not a function

23:56.580 --> 23:57.980
它没有这个属性

23:57.980 --> 23:59.300
为什么没有这个属性

23:59.300 --> 24:01.020
因为它读的是字不串属性

24:01.020 --> 24:02.660
你这样写它的读的是字不串

24:02.660 --> 24:03.340
那有些人说

24:03.340 --> 24:04.620
这大不简单吗

24:04.620 --> 24:06.540
我这里GetThreader

24:06.540 --> 24:08.420
我还不是用符号玩笑呢

24:08.420 --> 24:08.740
保存

24:08.740 --> 24:09.260
你看一下

24:09.260 --> 24:11.100
他说getThreader is not a defend

24:11.100 --> 24:11.780
为什么

24:11.780 --> 24:13.740
因为我们在这里是一个局部辨量

24:13.740 --> 24:14.980
函数里边的局部辨量

24:14.980 --> 24:15.860
那么除了这个函数

24:15.860 --> 24:17.420
是不是访问不到这个玩笑了

24:17.420 --> 24:18.020
对不对

24:18.020 --> 24:18.820
因此这个符号

24:18.820 --> 24:20.220
是不是只能在内部使用

24:20.220 --> 24:21.020
对对象内部使用

24:21.020 --> 24:22.380
外面是不是用不到了

24:22.380 --> 24:23.900
就完全用不到这个符号了

24:25.220 --> 24:26.020
没问题吧

24:26.020 --> 24:27.260
就完全用不到这个符号了

24:28.380 --> 24:30.620
这就是通过精心设计

24:30.620 --> 24:33.260
可以让一个对象的成员

24:33.260 --> 24:35.140
只能在内里边使用

24:35.140 --> 24:36.580
外面绝对用不了

24:36.580 --> 24:37.860
绝对用不了

24:37.860 --> 24:39.180
不能说绝对吧

24:39.180 --> 24:42.780
至少通过常规方式是不能用的

24:42.780 --> 24:44.380
当然你要去想一些外面写到

24:44.380 --> 24:45.100
当然还是可以用

24:45.100 --> 24:46.100
以后我会说

24:46.100 --> 24:47.580
还是可以找到它

24:47.580 --> 24:48.940
只不过没意义了

24:48.980 --> 24:51.500
因为我就是为了避免你误操作

24:51.500 --> 24:53.020
你要去故意误操作

24:53.020 --> 24:54.380
那我有什么办法了

24:54.380 --> 24:55.940
那我也没办法

24:55.940 --> 24:58.140
解释也不考虑这样的问题

24:58.140 --> 24:58.900
所以说现在呢

24:58.900 --> 25:00.340
是不是没法正常的

25:00.340 --> 25:02.100
通过常规方式来访问这个属性的

25:02.100 --> 25:03.220
对不对

25:03.220 --> 25:05.140
这就是为什么符号

25:05.140 --> 25:06.700
它能够实现私有属性

25:06.700 --> 25:07.780
就是因为它这个特点

25:07.780 --> 25:09.940
有的人说我们能不能在这里

25:09.940 --> 25:11.580
写这么一个get write

25:11.580 --> 25:12.980
然后symbol

25:12.980 --> 25:14.860
能不能在这样写

25:14.860 --> 25:16.500
你看这个symbol里面是一样的

25:16.500 --> 25:18.340
看一下能不能访问的

25:18.340 --> 25:19.820
它说意思拿成方形

25:19.820 --> 25:20.580
为什么呢

25:20.580 --> 25:22.620
因为这两个符号不一样

25:22.620 --> 25:23.780
不是同一个符号

25:23.780 --> 25:25.060
所以它访问不到

25:25.060 --> 25:26.100
那符号是唯一的

25:26.100 --> 25:27.020
我们刚才说了

25:27.020 --> 25:28.460
你通过这个东西的符号

25:28.460 --> 25:29.580
永远不相等

25:29.580 --> 25:31.220
所以它找不到这样的属性

25:31.220 --> 25:32.860
没了意思吗

25:32.860 --> 25:34.620
所以说你访问不到这个方法了

25:34.620 --> 25:36.340
这就是ES6里面

25:36.340 --> 25:38.340
如何来实现一个私有的属性

25:38.340 --> 25:41.540
通过符号来实现的

25:41.540 --> 25:43.700
那么如果说一个内怎么办呢

25:43.700 --> 25:45.940
如果说一个内怎么去实现呢

25:45.940 --> 25:48.300
我们来看一下内的在吗

25:48.300 --> 25:49.700
是不是一样的道理

25:49.700 --> 25:50.900
道理都是一样的

25:50.900 --> 25:52.140
看着我们这样子写

25:52.140 --> 25:53.260
一本

25:53.820 --> 25:55.260
here

25:55.260 --> 25:57.100
我们写上一个什么呢

25:57.100 --> 25:59.860
还是一个立即执行函数

25:59.860 --> 26:01.340
或者说我们用那个

26:01.340 --> 26:02.580
箭头函数都行

26:02.580 --> 26:04.860
箭头函数

26:04.860 --> 26:06.060
立即执行函数

26:06.060 --> 26:06.580
对吧

26:06.580 --> 26:06.980
你看

26:06.980 --> 26:08.660
这是箭头函数

26:08.660 --> 26:09.460
这是箭头函数

26:09.460 --> 26:10.500
立即执行它

26:10.500 --> 26:12.260
那么同样的道理

26:12.260 --> 26:12.740
here

26:12.740 --> 26:14.780
我返回一个什么呢

26:14.780 --> 26:15.580
return

26:15.580 --> 26:16.980
返回一个类表

26:17.140 --> 26:18.420
我们现在讲过类表

26:18.420 --> 26:19.620
这是个类表

26:19.620 --> 26:21.380
就是相当于返回一个匿名函数

26:21.380 --> 26:22.340
一样返回一个类表

26:22.340 --> 26:24.700
把他复制到here

26:24.700 --> 26:25.340
里面

26:25.340 --> 26:26.380
here就是个内的

26:26.380 --> 26:27.500
那么同样道理

26:27.500 --> 26:29.620
这里面是不是仍然可以用符号

26:29.620 --> 26:31.260
仍然可以用符号

26:31.260 --> 26:33.580
是不是仍然可以用符号

26:33.580 --> 26:35.460
是不是讲过了

26:35.460 --> 26:36.900
这里是不是也可以用属性

26:36.900 --> 26:37.460
符号表

26:37.460 --> 26:39.780
是不一样的

26:39.780 --> 26:41.060
有啥区别的

26:41.060 --> 26:42.500
有啥区别的

26:42.500 --> 26:43.300
你看

26:43.300 --> 26:44.380
那是一样的

26:44.380 --> 26:46.260
看返回这么一个内

26:46.300 --> 26:47.220
有了这个内过后

26:47.220 --> 26:48.140
我们来看一下

26:48.140 --> 26:50.020
我通过这个内在创建一个英雄

26:50.020 --> 26:50.980
here的

26:50.980 --> 26:52.420
攻击力随便写吧

26:52.420 --> 26:53.060
随便写

26:53.060 --> 26:53.540
随便写

26:53.540 --> 26:53.740
随便写

26:53.740 --> 26:54.620
这个是无所谓

26:54.620 --> 26:55.540
输出H

26:55.540 --> 26:56.580
输出H

26:56.580 --> 26:57.380
保存

26:57.380 --> 26:58.540
那你看一下H里面

26:58.540 --> 26:59.420
有这么一些属相

26:59.420 --> 27:00.420
符号

27:00.420 --> 27:01.340
它是一个方法

27:01.340 --> 27:02.180
因为它是方法

27:02.180 --> 27:02.940
它在这

27:02.940 --> 27:03.540
对吧

27:03.540 --> 27:04.940
是不是符号的方法在这

27:04.940 --> 27:05.900
你能调用这个方法吗

27:05.900 --> 27:06.340
调用不到

27:06.340 --> 27:07.740
因为你拿不到这个符号

27:07.740 --> 27:08.380
你符号拿不到

27:08.380 --> 27:09.460
你就调用不了这个方法

27:09.460 --> 27:11.420
你必须要通过这个符号才能调用

27:11.420 --> 27:12.700
所以说它内部是可以用的

27:12.700 --> 27:14.940
因为内部能拿到这个符号

27:14.940 --> 27:16.260
没了意思吗

27:16.260 --> 27:18.860
以后学了模块化之后

27:18.860 --> 27:20.740
你们有更简单的方式来处理这个问题

27:20.740 --> 27:22.540
还不用去写什么立即执行函数了

27:22.540 --> 27:23.500
但目前没办法

27:23.500 --> 27:25.300
目前在写立即执行函数

27:25.300 --> 27:26.420
把符号包在里边

27:26.420 --> 27:28.780
外面就访问不到

27:28.780 --> 27:31.140
这就是ES6里面实现

27:31.140 --> 27:33.140
私有属性的这种方式

27:33.140 --> 27:34.300
因为它符号的特点

27:34.300 --> 27:34.900
它就决定了

27:34.900 --> 27:37.500
可以这样子实现

27:37.500 --> 27:37.700
好

27:37.700 --> 27:39.540
然后我们接下来再看

27:39.540 --> 27:41.380
符号还有什么样的

27:41.420 --> 27:42.780
作为符号属性

27:42.780 --> 27:44.260
还有什么样的特点

27:44.260 --> 27:47.220
符号属性是不能每一句的

27:47.220 --> 27:48.100
什么叫每一句

27:48.100 --> 27:48.860
我们之前说过

27:48.860 --> 27:49.940
我们通过Fo硬循环

27:49.940 --> 27:52.300
是不是可以把对象的属性

27:52.300 --> 27:52.940
一个个拿到

27:52.940 --> 27:54.180
对不对

27:54.180 --> 27:56.260
那么符号属性是不能每一句的

27:56.260 --> 27:57.620
因此在Fo硬循环中

27:57.620 --> 27:59.820
是无法读取到符号属性的

27:59.820 --> 28:00.180
好

28:00.180 --> 28:00.940
比方说

28:00.940 --> 28:03.570
举个例子

28:03.570 --> 28:03.930
来吧

28:03.930 --> 28:05.410
一个对象

28:05.410 --> 28:06.690
写个符号

28:06.690 --> 28:08.290
symbol

28:10.290 --> 28:11.570
这里一个对象

28:12.570 --> 28:14.970
它里面有些属象是符号属象

28:14.970 --> 28:16.370
有些属象是符号属象

28:16.370 --> 28:16.770
一

28:16.770 --> 28:17.010
哎

28:17.010 --> 28:18.490
有的人说

28:18.490 --> 28:19.890
那我如果生两个呢

28:20.890 --> 28:21.770
两个会怎么样

28:21.770 --> 28:22.890
你说怎么会怎么样

28:23.650 --> 28:24.970
是不是只能有一个生象

28:24.970 --> 28:26.130
有些两个是一个属象

28:26.130 --> 28:27.970
除非你创建两个不同的符号

28:27.970 --> 28:29.970
除非创建两个不同的符号

28:31.050 --> 28:32.210
那么这里呢

28:32.210 --> 28:33.650
是不是写了一个属象

28:33.650 --> 28:34.330
一个属象

28:34.330 --> 28:36.170
那么写一些别的属象

28:36.170 --> 28:37.250
写一些别的属象

28:37.890 --> 28:38.130
好

28:38.130 --> 28:39.850
接下来我们通过Fo硬循环

28:39.850 --> 28:41.450
来输出它的所有属象

28:41.490 --> 28:42.770
Fo硬循环

28:42.770 --> 28:43.730
prob

28:43.730 --> 28:44.530
obg

28:46.330 --> 28:48.330
输出它的所有的属象

28:48.330 --> 28:49.730
输出prob

28:49.730 --> 28:50.890
看一下

28:50.890 --> 28:53.610
Fo硬循环里面能不能得到这个符号属象名

28:53.610 --> 28:54.130
能得到吗

28:54.130 --> 28:55.290
得不到

28:55.290 --> 28:55.570
得不到

28:55.570 --> 28:57.450
它只能得到a和b

28:57.450 --> 28:59.690
也就是符号属象是不能每一句的

28:59.690 --> 29:01.930
你是无法通过Fo硬循环

29:01.930 --> 29:04.250
取出这个符号属象的

29:04.250 --> 29:06.130
由于它不能每一句呢

29:06.130 --> 29:07.850
s5里边这个方法

29:07.850 --> 29:09.450
object是t

29:09.450 --> 29:12.290
得到一个对象的所有的属性名

29:12.290 --> 29:14.250
得到它所有可每一句的属性名

29:14.250 --> 29:14.970
这个方法的意思

29:14.970 --> 29:17.850
得到一个对象所有可每一句的属性名

29:17.850 --> 29:19.090
是不是也得不到符号属性

29:19.090 --> 29:20.770
因为符号属性是不能每一句的

29:20.770 --> 29:21.970
是不能每一句的

29:21.970 --> 29:24.690
因此我这里如果说输出objects

29:24.690 --> 29:25.970
the keys

29:25.970 --> 29:28.050
得到obg的所有的属性名

29:28.050 --> 29:29.210
你看一下输出一个输出

29:29.210 --> 29:30.770
输出里面只有a和b

29:30.770 --> 29:32.970
因为它得到了可每一句的属性

29:32.970 --> 29:33.690
只有这两个

29:33.690 --> 29:34.530
没有这个

29:34.530 --> 29:35.330
是不是得不到

29:35.330 --> 29:35.770
对吧

29:35.770 --> 29:36.450
得不到

29:37.450 --> 29:38.450
下面这个课点

29:38.650 --> 29:40.530
其实这些特征

29:40.530 --> 29:43.770
就是为了让其他的用这个对象的人

29:43.770 --> 29:45.130
用这个类的人

29:45.130 --> 29:47.690
尽量的忽略掉符号属象

29:47.690 --> 29:48.690
就是起这么个作用

29:48.690 --> 29:49.810
让他尽量忽略掉

29:49.810 --> 29:51.450
就当看不见一样

29:51.450 --> 29:52.610
尽管你要打印出来

29:52.610 --> 29:53.690
你可以看得见

29:53.690 --> 29:56.050
只不过就当他看不见一样

29:56.050 --> 29:59.090
他一切都是为了隐藏这个东西

29:59.090 --> 29:59.370
好

29:59.370 --> 29:59.890
下面这个

30:01.650 --> 30:04.370
objects gets om property names

30:04.370 --> 30:05.090
就这个函数

30:05.090 --> 30:06.370
也是es5的一个函数

30:06.370 --> 30:08.330
就你们之前都学过了

30:08.370 --> 30:09.370
这个函数

30:09.370 --> 30:12.170
它是能够得到可每句的属性的

30:12.170 --> 30:13.130
就是无法每句的属性

30:13.130 --> 30:14.810
它是能得到的

30:14.810 --> 30:15.690
没有办法每句的属性

30:15.690 --> 30:17.010
它也能得到

30:17.010 --> 30:21.130
但是它仍然无法读取到符号属性

30:21.130 --> 30:22.050
什么意思呢

30:22.050 --> 30:25.410
就是说如果说你要用这种方式来调用

30:25.410 --> 30:27.770
get om property names

30:27.770 --> 30:29.890
得到obj的所谓的属性名

30:29.890 --> 30:30.890
虽然说这种方式

30:30.890 --> 30:32.250
跟这种方式区别在它

30:32.250 --> 30:33.450
这个这种方式

30:33.450 --> 30:35.330
它是能得到

30:35.330 --> 30:37.570
能得到无法每句的属性名

30:37.570 --> 30:38.610
属性值

30:38.610 --> 30:40.370
但是仍然得不到符号属性

30:40.370 --> 30:41.450
仍然得不到

30:41.450 --> 30:41.930
你看

30:41.930 --> 30:43.170
仍然得不到

30:43.170 --> 30:45.250
所以说你几乎是没有什么办法

30:45.250 --> 30:46.730
能够得到这个属性名的

30:46.730 --> 30:48.130
几乎是没办法了

30:48.130 --> 30:49.810
但是呢es6呢

30:49.810 --> 30:51.370
怕你万一

30:51.370 --> 30:53.250
万一开发者要得到这个符号属性

30:53.250 --> 30:54.050
怎么办呢

30:54.050 --> 30:54.610
对吧

30:54.610 --> 30:56.770
一生的可以做了一个方法出来

30:56.770 --> 30:57.290
因为它

30:57.290 --> 30:58.650
我刚才反复强调了

30:58.650 --> 31:01.130
符号属性它不是为了什么安全性

31:01.130 --> 31:03.930
它就是为了让你避免你乱用一些

31:03.930 --> 31:05.450
不应该用的方法

31:05.490 --> 31:08.010
造成了自己的麻烦

31:08.010 --> 31:10.930
就像我们设计一些产品一样

31:10.930 --> 31:12.410
尽量设计的简洁

31:12.410 --> 31:14.330
让用户少犯错

31:14.330 --> 31:16.610
但是如果说用户确实有这样的需求的话

31:16.610 --> 31:18.570
那么es6它给你提供了这么一个方法

31:18.570 --> 31:19.890
你可以读取到符号

31:19.890 --> 31:21.090
读取到符号

31:21.090 --> 31:22.610
通过什么objects

31:22.610 --> 31:25.130
getoenproperty symbols

31:25.130 --> 31:27.410
把names变成 symbols

31:27.410 --> 31:29.690
通过这个方法就可以得到符号属性了

31:29.690 --> 31:30.610
是同样道理

31:30.610 --> 31:33.130
它得到的是一个属性的数组

31:33.130 --> 31:35.410
getoenproperty symbols

31:35.570 --> 31:36.850
你看一下

31:36.850 --> 31:41.050
得到的就是一个符号属性的数组

31:41.050 --> 31:45.850
得到的是一个符号属性的数组

31:45.850 --> 31:47.490
那么比方说我们放了个变量

31:47.490 --> 31:51.650
symbols

31:51.650 --> 31:52.610
这么一个数组

31:52.610 --> 31:55.410
就这个对象中有哪些属性是符号属性

31:55.410 --> 31:58.010
把个符号的属性的符号全部读出来

31:58.010 --> 31:58.890
你看是不是这个数组

31:58.890 --> 32:00.890
数组里面第一项是不是这个符号

32:00.890 --> 32:01.730
那么这个符号

32:01.730 --> 32:04.050
你就可以看到这个符号就是这个符号

32:04.050 --> 32:04.370
对吧

32:04.370 --> 32:04.850
就是这个符号

32:04.850 --> 32:06.530
因为就这个符号属性

32:06.570 --> 32:08.010
那么如果说我要判断

32:08.010 --> 32:09.730
如果说我要判断什么

32:09.730 --> 32:11.810
这个symbols的第一项

32:11.810 --> 32:14.290
是不是等于symbol

32:14.290 --> 32:16.290
是不是等于一看是q

32:16.290 --> 32:18.770
两个是相等的

32:18.770 --> 32:20.050
说符号不是唯一吗

32:20.050 --> 32:20.810
是唯一

32:20.810 --> 32:21.490
只是放了

32:21.490 --> 32:25.050
只是有两个变量都指向的是这个符号

32:25.050 --> 32:26.170
它是唯一的

32:26.170 --> 32:27.690
我并没有重新去创建符号

32:27.690 --> 32:30.170
并没有调用这个函数重新创建符号

32:30.170 --> 32:32.570
你看是不是q

32:32.570 --> 32:36.800
就这么个意思

32:36.840 --> 32:40.240
这就是符号这里的这一块特点

32:40.240 --> 32:41.720
也就是说我们刚才说

32:41.720 --> 32:44.000
说常规方式是无法得到的

32:44.000 --> 32:44.240
对吧

32:44.240 --> 32:45.520
常规方式是无法得到的

32:45.520 --> 32:47.040
它的符号属性的

32:47.040 --> 32:48.640
用非常规方式就可以

32:48.640 --> 32:52.160
比方说我们把刚才代码再copy过来

32:52.160 --> 32:54.880
我们用非常规的方式是可以得到的

32:54.880 --> 32:59.460
看着我们这样子写

32:59.460 --> 33:00.460
这里不是创建一个英雄吗

33:00.460 --> 33:01.820
我就要用它的符号

33:01.820 --> 33:03.100
符号成员 get rid of

33:03.100 --> 33:04.180
我就要用它

33:04.180 --> 33:05.500
那就要用它怎么办呢

33:05.500 --> 33:08.060
看着我们这样做

33:08.100 --> 33:11.420
得到symbols

33:11.420 --> 33:15.300
objects get ompropertysymbols

33:15.300 --> 33:17.220
把这个H传进去

33:17.220 --> 33:18.780
输出symbols

33:18.780 --> 33:20.260
你看一下

33:20.260 --> 33:22.700
这里它是放到圆形上面的

33:22.700 --> 33:23.620
它是放到圆形上面的

33:23.620 --> 33:24.100
没关系

33:24.100 --> 33:25.260
放到圆形上面也行

33:25.260 --> 33:26.260
我们读取什么

33:26.260 --> 33:29.300
Hero的 prototype

33:29.300 --> 33:31.380
到圆形上面的所有的符号

33:31.380 --> 33:32.820
就得到一个symbol了

33:32.820 --> 33:33.340
对吧

33:33.340 --> 33:34.660
拿到这个symbol了

33:34.660 --> 33:36.060
拿到symbol过后

33:36.060 --> 33:38.100
我们就可以得到这个

33:38.100 --> 33:39.100
通过什么

33:39.100 --> 33:40.700
调用H

33:40.700 --> 33:41.740
你不要传一个符号

33:41.740 --> 33:42.740
什么符号呢

33:42.740 --> 33:43.820
这是一个符号数组

33:43.820 --> 33:45.980
这个符号数组的第一项

33:45.980 --> 33:47.260
这个符号的数组的第一项

33:47.260 --> 33:48.500
是不是就这个符号

33:48.500 --> 33:49.740
因为就只有这个符号

33:49.740 --> 33:50.620
当然你可以

33:50.620 --> 33:52.060
如果说一个代码看着牢火的话

33:52.060 --> 33:54.140
你可以先把它放到一个变量里边来

33:54.140 --> 33:56.900
这个变量名字随便去

33:56.900 --> 33:58.940
把它放到一个const

33:58.940 --> 33:59.980
把它放到一个变量里边来

33:59.980 --> 34:01.900
再用这个变量去读它

34:01.900 --> 34:03.220
你可以换个名字

34:03.220 --> 34:04.780
property

34:04.780 --> 34:05.060
读它

34:05.060 --> 34:06.340
然后来调用

34:06.340 --> 34:08.140
35

34:08.140 --> 34:09.540
说得得到一个水积数

34:09.540 --> 34:12.560
输出看一下吧

34:12.560 --> 34:16.420
输出

34:16.420 --> 34:17.900
看一下

34:17.900 --> 34:19.020
说可以得到一个水积数

34:19.020 --> 34:20.540
仍然可以调用它

34:20.540 --> 34:21.940
你用一些外面写到的办法

34:21.940 --> 34:22.660
仍然可以

34:22.660 --> 34:24.020
但是呢

34:24.020 --> 34:25.220
你想这个道理

34:25.220 --> 34:25.820
你细想

34:25.820 --> 34:27.340
你细琢磨

34:27.340 --> 34:29.060
你都这样子写代码了

34:29.060 --> 34:30.100
是不是你已经清楚

34:30.100 --> 34:32.260
你自己要干嘛了

34:32.260 --> 34:33.700
你都肯去

34:33.700 --> 34:35.900
这么麻烦的去读一个属性

34:35.940 --> 34:39.620
那说明你是真的需要这个东西

34:39.620 --> 34:40.820
是真的需要这个东西

34:40.820 --> 34:42.980
那你就去作为

34:42.980 --> 34:43.980
那如果说你

34:43.980 --> 34:45.180
没有人

34:45.180 --> 34:47.100
不需要这个东西去写这个代码吧

34:47.100 --> 34:48.740
这代码这么恶心

34:48.740 --> 34:49.420
对不对

34:49.420 --> 34:50.740
没必要吧

34:50.740 --> 34:51.980
所以说呢

34:51.980 --> 34:52.660
这是符号属性

34:52.660 --> 34:54.060
它不能通过常规方式访问

34:54.060 --> 34:54.500
但是呢

34:54.500 --> 34:57.620
还是会通过这种方式来访问

34:57.620 --> 34:58.780
最后一个说明一下

34:58.780 --> 35:00.100
符号的特点就是

35:00.100 --> 35:02.620
符号是不能被隐释转换的

35:02.620 --> 35:03.460
什么叫隐释转换呢

35:03.460 --> 35:04.740
就是我们有的时候

35:04.740 --> 35:06.940
把一个字符串跟一个数字相乘

35:06.940 --> 35:07.580
对不对

35:07.580 --> 35:10.180
把这个字符串它会隐释转换成数字

35:10.180 --> 35:12.100
就是这种隐释转换

35:12.100 --> 35:14.020
符号是不能隐释转换的

35:14.020 --> 35:14.540
因此呢

35:14.540 --> 35:17.620
符号你不能去用于什么字符串拼接

35:17.620 --> 35:19.220
字符串拼接是不是有隐释转换

35:19.220 --> 35:20.900
要把拼接的东西转换成字符串

35:20.900 --> 35:21.580
对吧

35:21.580 --> 35:22.780
或者说什么数学运刷

35:22.780 --> 35:24.980
数学运刷是不是要把它转换成数字

35:24.980 --> 35:27.260
这些常你都不能用符号

35:27.260 --> 35:28.340
都不能用符号

35:28.340 --> 35:30.660
也要说

35:30.660 --> 35:32.500
你这里呢有个符号

35:33.340 --> 35:35.060
当然谁会去这样做呢

35:35.060 --> 35:36.340
这个没有什么意义

35:36.340 --> 35:36.660
对吧

35:36.660 --> 35:37.780
你做这个事情干嘛呢

35:37.780 --> 35:38.860
因为符号的出现

35:38.860 --> 35:40.860
往往都是为了设置一个

35:40.860 --> 35:42.220
不可能变的东西

35:42.220 --> 35:43.140
不会

35:43.140 --> 35:44.260
就是唯一的东西

35:44.260 --> 35:46.340
或者一般就是用来做一些私有属性

35:46.340 --> 35:48.940
或者是一些做一些其他唯一的东西

35:48.940 --> 35:50.380
不希望别人访问的

35:50.380 --> 35:52.220
那你去做什么数学运刷呢

35:52.220 --> 35:52.780
你去

35:52.780 --> 35:53.660
谁会去这样做呢

35:53.660 --> 35:54.340
所以说这里点了

35:54.340 --> 35:55.180
我给它提一下

35:55.180 --> 35:56.780
也没有人

35:56.780 --> 35:57.740
没有人就去这样做

35:57.740 --> 35:58.420
他说什么

35:58.420 --> 36:00.940
他说这个符号是不能转换成数字的

36:01.020 --> 36:04.860
convert a simple value to a number

36:04.860 --> 36:07.180
那能不能做字符刷拼接呢

36:07.180 --> 36:09.340
拼接个字符刷

36:09.340 --> 36:09.980
不能

36:09.980 --> 36:12.140
他都不能把它转换成一个字符刷

36:12.140 --> 36:12.900
转换不了

36:12.900 --> 36:13.460
转换不了

36:15.220 --> 36:18.100
但是符号是可以显示转换的

36:18.100 --> 36:19.940
它可以转换成字符刷

36:19.940 --> 36:21.020
为什么它可以转换字符刷

36:21.020 --> 36:22.140
有的是我们要把它输出

36:22.140 --> 36:22.740
对吧

36:22.740 --> 36:24.340
我们要做一些信息记录

36:24.340 --> 36:25.220
做一些日子记录

36:25.220 --> 36:27.580
看一下是哪个可能有些符号出了问题

36:27.580 --> 36:28.740
一些符号属性出的问题

36:28.740 --> 36:30.860
我们看一下哪个属符号属性出了问题

36:30.860 --> 36:32.660
我们可能要把它转换成字符刷

36:32.660 --> 36:34.540
那么转换成字符刷是可以的

36:34.540 --> 36:36.060
但是你要手动转换

36:36.060 --> 36:37.020
你不能显示转换

36:37.020 --> 36:37.820
怎么手动转换呢

36:39.220 --> 36:40.380
这样转换

36:40.380 --> 36:40.900
用stream

36:42.820 --> 36:43.300
进步

36:43.300 --> 36:44.140
用这么方式来转换

36:47.380 --> 36:48.140
你看

36:48.140 --> 36:48.900
转换字符刷了

36:48.900 --> 36:49.500
你看黑色的

36:49.500 --> 36:49.860
对吧

36:49.860 --> 36:50.620
是不是黑色的

36:50.620 --> 36:51.300
转换字符刷了

36:52.900 --> 36:53.420
没人的意思吗

36:54.820 --> 36:55.900
转换字符刷了

36:55.900 --> 36:58.060
实际上在console log

36:58.060 --> 36:59.100
console log里边

36:59.100 --> 37:00.420
如果你直接传一个符号

37:00.420 --> 37:02.380
它的内部就是先把它转换成字符刷

37:02.380 --> 37:04.580
再用一种特别的颜色把它输出

37:04.580 --> 37:06.180
用那种红色把它输出

37:06.180 --> 37:07.380
表示一个符号

37:07.380 --> 37:08.940
它就是帮你做了这么一件事

37:10.580 --> 37:12.100
其他的就没啥了

37:12.100 --> 37:14.020
符号属性其实是其他这些东西

37:14.020 --> 37:14.820
你都不会遇到

37:14.820 --> 37:15.020
对吧

37:15.020 --> 37:16.620
都不会遇到这些问题

37:16.620 --> 37:18.100
像这些东西都很少需要用

37:18.100 --> 37:19.020
我们只是

37:19.020 --> 37:20.340
最重要的就是你要学会

37:20.340 --> 37:23.500
使用符号属性来做一个私有成员出来

37:23.500 --> 37:25.260
这是你一定要学会的

37:25.260 --> 37:27.980
并且你要深刻的理解符号属性

37:27.980 --> 37:29.860
每一次通过symbol创兰的符号

37:29.940 --> 37:31.540
一定是不一样的

37:31.540 --> 37:32.940
每次都用的都不一样

37:32.940 --> 37:34.300
只要你调用一次symbol

37:34.300 --> 37:35.980
它就得到一个全新符号

37:35.980 --> 37:37.780
给你一个写的什么符号描述

37:37.780 --> 37:38.620
没有任何关系

37:38.620 --> 37:40.100
算了我这里不要用符号名了

37:40.100 --> 37:41.540
用符号描述的了

37:41.540 --> 37:42.620
用符号描述的了

37:42.620 --> 37:43.580
这样子好一点

37:43.580 --> 37:45.980
这个描述只是用来调试用的

37:45.980 --> 37:47.940
只是用来调试用的

37:47.940 --> 37:50.340
ok 这就是一个普通符号怎么去做

37:50.340 --> 37:52.300
并且我讲了符号里边的一些特点

37:52.300 --> 37:54.060
其实你把普通符号学会了

37:54.060 --> 37:55.220
那么后面什么

37:55.220 --> 37:56.260
共享符号啊

37:56.260 --> 37:57.820
什么知名符号啊

37:57.860 --> 38:00.420
这些东西就特别特别简单了

38:00.420 --> 38:02.660
大家下来去用一下

38:02.660 --> 38:04.700
做一个私有属性出来

