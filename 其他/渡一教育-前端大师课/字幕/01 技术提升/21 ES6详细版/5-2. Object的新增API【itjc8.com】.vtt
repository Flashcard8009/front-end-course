WEBVTT

00:01.010 --> 00:05.210
然后呢 我们这一块来聊一聊 就是在Yes6里边的

00:05.210 --> 00:08.610
他为了简化一些问题的处理

00:08.610 --> 00:12.310
他给我们在OpenJ格车里边呢 新增了一些API

00:12.310 --> 00:16.010
那么这些API呢 都是属于OpenJ格车 这个

00:16.010 --> 00:17.610
诶 OpenJ格车是啥

00:18.410 --> 00:20.210
诶 我顺便问一下啊

00:20.210 --> 00:23.010
我 我有点害怕 我OpenJ格车是啥

00:23.610 --> 00:25.410
它是对象还是寒树

00:26.010 --> 00:27.810
对象还是寒树

00:29.580 --> 00:31.980
啊 是不是寒树啊

00:32.380 --> 00:33.580
是它是个构造寒树啊

00:33.580 --> 00:35.580
我顺便问一下啊

00:36.180 --> 00:37.580
OpenJ格它是一个寒树啊

00:37.580 --> 00:39.380
寒树里边它给你加了一些API

00:39.380 --> 00:41.980
所以说这些东西呢 都是一些静态方法

00:41.980 --> 00:43.980
全是静态方法 什么叫静态方法

00:43.980 --> 00:47.180
就是直接附着在寒树上面的方法

00:47.380 --> 00:51.180
好吧 嗯 好 那么接下来我们来说一下这些API啊

00:51.180 --> 00:52.980
第一个呢 就是Object的意识

00:52.980 --> 00:54.180
这个是用来干嘛呢

00:54.180 --> 00:56.180
用来判断两个对象是否相等

00:56.980 --> 01:02.180
用于判断两个对象是否相等

01:02.980 --> 01:04.380
好 咱们来举个例子啊

01:04.980 --> 01:07.780
它为什么要用 要有出来这么一个API来判断呢

01:07.780 --> 01:08.980
是因为以前呢

01:08.980 --> 01:10.580
我们判断相等的时候

01:10.580 --> 01:12.980
最常用的是严格相等

01:12.980 --> 01:14.380
对吧 三个等号

01:14.380 --> 01:16.180
但是在用三个等号的时候呢

01:16.180 --> 01:18.380
会发生一些怪异的现象

01:18.580 --> 01:19.780
比方说我们

01:20.180 --> 01:22.980
这些怪异的现象是一些历史疑的问题

01:22.980 --> 01:24.780
你说它现在去解决吧

01:25.380 --> 01:27.180
那又会导致旧系统不兼容

01:27.180 --> 01:28.780
对吧 它要兼容旧系统

01:28.780 --> 01:31.780
它所以说没办法只能给你新增一个API出来

01:31.780 --> 01:32.780
再解决这个问题

01:33.180 --> 01:35.380
两个NAN是不是相等的

01:35.380 --> 01:36.380
严格相等

01:38.380 --> 01:39.580
就是整个的课程里面

01:39.580 --> 01:41.180
最初的课程里面就说了

01:41.180 --> 01:44.180
NAN跟任何东西比较都是Force

01:44.180 --> 01:45.580
包括跟它自身

01:45.580 --> 01:46.980
是不是很怪异啊

01:46.980 --> 01:49.180
都是NAN 凭什么为Force呢

01:49.180 --> 01:49.780
对不对

01:49.780 --> 01:50.980
还有什么呢

01:51.380 --> 01:52.980
还有就是

01:52.980 --> 01:56.380
正宁和父宁是不是相等的呢

01:56.980 --> 01:58.180
在介事里边

01:58.180 --> 01:59.980
他认为这两个是相等的

01:59.980 --> 02:02.180
实际上他们内部的存处

02:02.180 --> 02:03.980
存处里边是不一样的

02:03.980 --> 02:05.380
他们的符号位不一样

02:05.380 --> 02:05.780
对吧

02:05.780 --> 02:06.780
虽然都是宁

02:06.780 --> 02:08.180
但是二进之的存处的时候

02:08.180 --> 02:09.980
他们符号位是不一样的

02:09.980 --> 02:10.980
说这个东西

02:10.980 --> 02:12.580
在严格相等里边

02:12.980 --> 02:14.780
他认为是不相等的

02:15.380 --> 02:16.580
他认为是Force

02:16.580 --> 02:18.180
那么这个他认为是Q

02:18.180 --> 02:20.780
这都是比较违反常理的

02:20.780 --> 02:22.580
尽管我们平时也不太会用到什么

02:22.580 --> 02:23.580
父灵正灵

02:23.580 --> 02:24.780
但是如果说出现了

02:24.780 --> 02:26.580
这是比较违反常理的

02:27.380 --> 02:28.580
因此我们希望了

02:28.580 --> 02:30.980
有一个更加合乎常理的

02:30.980 --> 02:32.380
你看一下是不是会出吗

02:33.180 --> 02:35.180
希望了有一个更加符合常理的

02:35.180 --> 02:36.180
这么一种比较

02:36.180 --> 02:37.380
那么他又不能去

02:37.380 --> 02:38.980
改动原来的严格相等

02:38.980 --> 02:40.480
因为这是一些历史一个问题

02:40.480 --> 02:41.380
他改了过后就系统

02:41.380 --> 02:42.780
可能会导致不兼容

02:42.780 --> 02:44.580
因此然后给你出了一个新的API

02:44.580 --> 02:45.980
叫Objects的意识

02:45.980 --> 02:47.180
那么这个东西呢

02:47.180 --> 02:48.780
来判断两个数据

02:48.780 --> 02:50.380
两个数据不一定是对象

02:50.780 --> 02:52.780
两个数据是否相等

02:52.780 --> 02:56.380
他基本上跟严格相等

02:57.180 --> 02:57.980
相等

02:58.780 --> 02:59.780
也就是三个等号

03:00.580 --> 03:03.180
基本上跟三个等号是一致的

03:04.380 --> 03:06.980
除了以下两点

03:06.980 --> 03:08.580
下面两点是不一样的

03:08.580 --> 03:09.780
第一个点就是

03:10.580 --> 03:18.580
第一个点是NAN和NAN相等

03:18.580 --> 03:19.980
这是比较符合常理的

03:19.980 --> 03:20.980
第二个点是

03:20.980 --> 03:25.380
正宁和负宁不相的

03:25.380 --> 03:27.180
就这两个点不一样

03:27.180 --> 03:27.680
他比较

03:27.680 --> 03:29.980
他把它做成一个更加符合常理的

03:29.980 --> 03:31.680
这么一种解释

03:31.680 --> 03:32.680
那么我们来试一下

03:32.680 --> 03:33.780
Objects的意识

03:33.780 --> 03:35.080
NAN

03:35.080 --> 03:37.280
两个NAN传进去

03:37.280 --> 03:42.480
下面再来一个正宁和负宁传进去

03:42.480 --> 03:43.380
判断一下

03:43.380 --> 03:43.880
你看一下

03:43.880 --> 03:45.580
所以正常的Q Force

03:45.580 --> 03:46.880
前面是Force Q

03:46.880 --> 03:47.680
对吧

03:47.680 --> 03:48.580
其他都一样

03:48.580 --> 03:49.580
其他都一样

03:49.680 --> 03:51.280
如果说你以后

03:51.280 --> 03:52.180
不是说以后了

03:52.180 --> 03:53.680
你就全部用Objects的意识

03:53.680 --> 03:55.480
写下来也挺麻烦的

03:55.480 --> 03:56.580
只是说你如果说

03:56.580 --> 03:58.780
你遇到了这样的一种情况

03:58.780 --> 04:00.380
一种特殊情况的话

04:00.380 --> 04:02.780
那么你可以是用Objects的意识

04:02.780 --> 04:04.480
来进行判定

04:04.480 --> 04:04.680
好吧

04:04.680 --> 04:06.280
这是关于这个

04:06.280 --> 04:06.780
下面这个

04:08.180 --> 04:09.180
Objects而三

04:09.180 --> 04:10.080
这是做什么呢

04:10.080 --> 04:11.680
是做对象混合的

04:11.680 --> 04:13.180
用于混合对象

04:13.180 --> 04:14.780
因为在JS里面混合对象

04:14.780 --> 04:16.780
是一种非常常见的场景

04:16.780 --> 04:17.380
混合对象

04:17.880 --> 04:18.980
好

04:18.980 --> 04:19.880
什么意思呢

04:19.880 --> 04:21.680
我们来这里再有几个例子

04:22.280 --> 04:23.080
看第二个例子

04:23.880 --> 04:24.580
Objects

04:24.580 --> 04:26.180
比如说我们这里有两个对象

04:26.180 --> 04:27.180
obj1

04:28.480 --> 04:31.480
a的属性等于123b的属性等于156

04:31.480 --> 04:33.880
然后c的属性等于abc

04:34.780 --> 04:34.980
好

04:34.980 --> 04:35.380
然后呢

04:35.380 --> 04:36.480
一个obj2

04:39.080 --> 04:41.180
也有一个a的属性

04:41.180 --> 04:43.380
等于789

04:44.480 --> 04:44.880
然后呢

04:44.880 --> 04:45.880
一个d的属性

04:45.980 --> 04:46.780
等于

04:47.580 --> 04:48.780
随便写个

04:48.780 --> 04:51.180
现在我们想把这两个对象混合

04:51.180 --> 04:52.580
混合成为一个对象

04:53.680 --> 04:55.480
我们想得到一个新的对象是什么呢

04:55.480 --> 04:56.580
得到新的对象是这个

04:58.580 --> 05:00.580
a的纸取obj2的纸

05:00.580 --> 05:01.780
就是obj2的纸

05:01.780 --> 05:03.480
它会覆盖叫obj1的纸

05:04.180 --> 05:04.780
好

05:04.780 --> 05:05.980
然后b的纸

05:05.980 --> 05:07.380
由于obj2没有

05:07.380 --> 05:09.980
就是把obj2去覆盖obj1

05:09.980 --> 05:11.580
如果有相同的属性

05:11.580 --> 05:12.280
就覆盖

05:12.280 --> 05:13.380
如果没有相同的属性

05:13.380 --> 05:14.680
就保留

05:14.680 --> 05:15.280
那么b呢

05:15.280 --> 05:17.080
就是保留456

05:17.080 --> 05:17.780
c呢

05:17.780 --> 05:19.680
就保留abc

05:19.680 --> 05:20.280
然后呢

05:20.280 --> 05:21.580
d呢

05:21.580 --> 05:22.680
就kkk

05:22.680 --> 05:23.380
明白的意思吗

05:23.380 --> 05:24.480
我们想得到这么一个对象

05:24.480 --> 05:26.580
就把两个对象混合

05:26.580 --> 05:28.980
其实混合对象最简单的方式是什么

05:30.080 --> 05:31.080
除了对象最简单的方式

05:31.080 --> 05:33.480
就是我们之前在哪个地方学的

05:33.480 --> 05:35.080
在展开运算符类学的

05:35.080 --> 05:36.780
展开对象obj1

05:36.780 --> 05:39.080
这是最简单的方式obj2

05:39.080 --> 05:39.480
对吧

05:39.480 --> 05:41.080
后边的覆盖前面的

05:41.080 --> 05:41.680
对吧

05:41.680 --> 05:44.480
这是es7的东西

05:44.580 --> 05:45.680
这是es7的东西

05:45.680 --> 05:46.880
看一下吧

05:46.880 --> 05:47.580
这就出来了

05:47.580 --> 05:47.880
对吧

05:47.880 --> 05:49.580
这是最简单的混合对象

05:49.580 --> 05:50.480
啊

05:50.480 --> 05:52.280
协下又方便又好阅读

05:52.280 --> 05:52.780
而且呢

05:52.780 --> 05:53.980
又不容易出问题

05:53.980 --> 05:54.380
但是呢

05:54.380 --> 05:55.680
es6出来的时候呢

05:55.680 --> 05:56.980
es7还没有出来

05:56.980 --> 05:58.080
所以说当时呢

05:58.080 --> 05:59.180
提供了这种解决方案

05:59.180 --> 06:01.480
叫做obj3

06:01.480 --> 06:02.180
后来呢

06:02.180 --> 06:02.880
他拧击一动

06:02.880 --> 06:03.980
那不对呀

06:03.980 --> 06:05.980
那个展开运算符类不是挺好的吗

06:05.980 --> 06:07.180
就直接用那个不管了吗

06:07.180 --> 06:07.580
对吧

06:07.580 --> 06:08.180
所以说现在呢

06:08.180 --> 06:10.280
我们基本上可以不用它了啊

06:10.280 --> 06:10.880
那么我说

06:10.880 --> 06:11.880
还是说一下啊

06:11.880 --> 06:13.080
用obj3呢

06:13.080 --> 06:14.080
怎么来做

06:14.080 --> 06:15.180
他这样来做

06:15.180 --> 06:17.080
obj3

06:17.080 --> 06:18.480
这里边传多少个参数呢

06:18.480 --> 06:19.380
随便的传多少个

06:19.380 --> 06:21.480
他一定是后边的覆盖前边的

06:21.480 --> 06:23.380
比方说我们这里传obj1

06:23.380 --> 06:25.280
obj2

06:25.280 --> 06:26.480
那么他就会怎么样呢

06:26.480 --> 06:27.680
他会做这么一个处理

06:28.580 --> 06:32.880
将obj2的数据

06:32.880 --> 06:35.580
覆盖到obj1

06:37.280 --> 06:41.580
并且会对obj1产生改动

06:42.580 --> 06:45.980
然后返回obj1

06:45.980 --> 06:46.980
他会做这么一件事

06:47.980 --> 06:49.180
咱们来看一下结果

06:49.180 --> 06:50.480
结果肯定是正确的

06:50.480 --> 06:51.180
但是这样子呢

06:51.180 --> 06:52.180
有一个不好的地方

06:52.180 --> 06:53.980
他会把obj1给给我改了

06:53.980 --> 06:55.280
像刚才那个展开运算符

06:55.280 --> 06:57.480
是不会改动这两个对象的

06:57.480 --> 06:57.880
以后呢

06:57.880 --> 06:58.880
你们遇到很多框架

06:58.880 --> 07:01.180
他都是不允许你改动对象的

07:01.180 --> 07:01.980
所以说这里呢

07:01.980 --> 07:02.580
一个不好的点

07:02.580 --> 07:03.980
他会把obj1改了

07:03.980 --> 07:04.880
怎么来验证呢

07:04.880 --> 07:05.580
我们来看一下

07:05.580 --> 07:06.780
我们再输出一下obj

07:06.780 --> 07:07.880
是不是等于obj1

07:09.380 --> 07:10.380
你看一下两个是q

07:10.380 --> 07:11.180
相当的

07:11.180 --> 07:12.280
所以他返回的是咋了

07:12.280 --> 07:13.680
返回的就是第一个参数

07:13.680 --> 07:14.880
把obj1给你返回了

07:14.880 --> 07:16.880
他会把obj1给改了

07:16.880 --> 07:18.480
就把obj2是没动的

07:18.480 --> 07:19.380
obj2是没动的

07:19.380 --> 07:20.880
但是obj1被改了

07:20.880 --> 07:22.580
比方说我们再输出一下obj1

07:22.580 --> 07:23.680
看一下吧

07:23.680 --> 07:24.680
再输出一下obj2

07:31.730 --> 07:33.030
obj2

07:33.030 --> 07:35.630
好 你看一下obj1是不是被改动了

07:35.630 --> 07:36.730
obj2是没变的

07:36.730 --> 07:37.630
对吧

07:37.630 --> 07:40.030
就第一个参数他会被改动过

07:40.030 --> 07:40.830
大家注意一下

07:40.830 --> 07:42.430
这个会产生影响的

07:42.430 --> 07:43.430
如果你稍不留神

07:43.430 --> 07:44.430
后边有些框架

07:44.430 --> 07:45.830
用框架的时候

07:45.830 --> 07:47.730
他不允许你对象进行改动

07:47.730 --> 07:49.030
你这里不小心把他改动了

07:49.030 --> 07:50.510
所以最安全的就是使用

07:50.510 --> 07:52.430
s7的那种方式

07:52.430 --> 07:53.630
但是我们这里可以用一种

07:53.630 --> 07:55.230
巧妙的方式来处理

07:55.230 --> 07:56.030
就是用什么方式呢

07:56.030 --> 07:57.630
用这种方式

07:57.630 --> 07:59.630
obj2

07:59.630 --> 08:02.430
第一个参数写个空对象obj1

08:02.430 --> 08:03.030
obj2

08:03.030 --> 08:04.730
因为他可以写无线多个参数

08:04.730 --> 08:06.430
他用的是圣语参数

08:06.430 --> 08:07.730
他用的是圣语参数

08:07.730 --> 08:09.030
所以说他的参数的数量

08:09.030 --> 08:10.730
你是可以无线写的

08:10.730 --> 08:11.830
可以无线写的

08:11.830 --> 08:13.330
因此你后边写两个

08:13.330 --> 08:15.230
一是后边覆盖前面的

08:15.230 --> 08:16.430
这样子一来了

08:16.430 --> 08:17.330
他改动的是谁呢

08:17.330 --> 08:18.930
改动的是这个对象

08:18.930 --> 08:19.930
后边obj1

08:19.930 --> 08:21.030
obj2他都没有改动

08:21.030 --> 08:21.930
改动的是这个对象

08:21.930 --> 08:24.130
并且把这个东西对象给你返回

08:24.130 --> 08:25.430
这个对象是空对象

08:25.430 --> 08:26.330
然后一混合之后

08:26.330 --> 08:28.330
是不是他里面就有东西了

08:28.330 --> 08:30.030
这样子就不会对obj1

08:30.030 --> 08:31.830
和obj2产生影响

08:31.830 --> 08:33.030
你看一下

08:33.030 --> 08:34.230
现在我们输出

08:34.230 --> 08:35.430
结果是正确的

08:35.430 --> 08:37.930
并且结果跟obj1

08:37.930 --> 08:38.730
是不相等的

08:38.730 --> 08:40.030
因为他这两个没动

08:40.030 --> 08:41.430
而且obj1和obj2

08:41.530 --> 08:44.730
你看后边这两个是没有产生变化的

08:44.730 --> 08:45.830
这是关于这个混合

08:48.030 --> 08:49.630
第三个呢

08:49.630 --> 08:50.830
就顺便提一提吧

08:50.830 --> 08:51.430
顺便提一提

08:51.430 --> 08:52.230
这个东西

08:52.230 --> 08:54.530
为什么要提这个呢

08:54.530 --> 08:55.830
我记得是哪家公司

08:55.830 --> 08:57.430
反正是一个同学

08:57.430 --> 09:00.030
他辨识的时候居然问到这个问题了

09:00.030 --> 09:00.630
我都想说

09:00.630 --> 09:01.230
天啊

09:01.230 --> 09:03.230
这个也太刁转了吧

09:03.230 --> 09:05.330
估计是那个辨识官

09:05.330 --> 09:06.230
一不留神

09:06.230 --> 09:08.230
在那个什么观望文档里面看到了

09:08.230 --> 09:09.730
这个就是改动

09:09.730 --> 09:10.830
他说考一考你吧

09:10.930 --> 09:11.830
看一下你对官网

09:11.830 --> 09:13.430
那个es6那一块

09:13.430 --> 09:14.530
理解到戏不戏

09:14.530 --> 09:15.930
这东西没有什么暖字用

09:15.930 --> 09:17.630
没什么暖用

09:17.630 --> 09:18.630
这个什么东西呢

09:18.630 --> 09:19.330
他就说

09:19.330 --> 09:20.930
这个函数是以前就有的

09:20.930 --> 09:22.330
并不是es6新增的

09:22.330 --> 09:23.830
getoenpropertynames

09:23.830 --> 09:25.330
得到一个对象

09:25.330 --> 09:26.930
他自己的所有属性

09:26.930 --> 09:28.030
就不在原型链上

09:28.030 --> 09:29.730
就是他自己拥有的所有属性

09:29.730 --> 09:31.430
这是以前就有的

09:31.430 --> 09:32.230
我们来看一下吧

09:34.130 --> 09:35.730
只不过以前

09:35.730 --> 09:37.130
他没有对他进行排序

09:37.130 --> 09:38.230
我就这里说一下吧

09:41.830 --> 09:43.930
这个函数

09:43.930 --> 09:47.030
这个方法之前就存在

09:47.030 --> 09:48.430
只不过

09:48.430 --> 09:53.230
官方没有明确要求

09:53.230 --> 09:57.230
对属性的顺序

09:57.230 --> 09:58.930
如何排序

09:58.930 --> 10:00.430
他不是得到一个数组吗

10:00.430 --> 10:01.530
你看一下

10:01.530 --> 10:03.130
我们这里写上这么一个对象

10:03.130 --> 10:05.030
obj

10:05.030 --> 10:06.430
a等于1

10:06.430 --> 10:07.830
b等于2

10:07.830 --> 10:08.730
c等于3

10:08.730 --> 10:10.430
随便写一个吧

10:10.430 --> 10:12.530
这里我们会换一个写法

10:12.530 --> 10:14.030
cba

10:14.030 --> 10:15.030
换个写法

10:15.030 --> 10:20.630
objgetoenpropertynames

10:20.630 --> 10:21.930
把对象传进去

10:21.930 --> 10:23.330
是不是会返回一个数组

10:23.330 --> 10:25.130
返回一个制不错的数组

10:25.130 --> 10:26.230
props

10:26.230 --> 10:27.830
那么我们把这个数组输出

10:27.830 --> 10:29.230
你看一下吧

10:29.230 --> 10:30.330
输出了是不是

10:30.330 --> 10:31.230
dba

10:31.230 --> 10:33.930
输出了是这么一个顺序

10:33.930 --> 10:35.630
那么这个时候

10:35.630 --> 10:37.330
官方他没有明确要求

10:37.330 --> 10:39.030
就是你这个顺序

10:39.030 --> 10:39.930
该如何进行排序

10:40.030 --> 10:41.930
他们并没有明确要求

10:41.930 --> 10:43.930
那么这具体怎么排序

10:43.930 --> 10:46.730
完全是由浏览器

10:46.730 --> 10:49.330
厂商自行决定

10:49.330 --> 10:51.230
如何排序

10:51.230 --> 10:56.330
完全由浏览器厂商决定

10:56.330 --> 10:59.740
厂商决定

10:59.740 --> 11:00.940
那么现在呢

11:00.940 --> 11:03.340
只不过官方的给你明确规定了

11:03.340 --> 11:05.440
你应该去怎么排序

11:05.440 --> 11:06.540
跟这些浏览器厂商说

11:06.540 --> 11:06.940
哎

11:06.940 --> 11:09.140
那么我们要不然把这一块统一一下吧

11:09.140 --> 11:09.540
不然的话

11:10.140 --> 11:11.240
你一种排序方式

11:11.240 --> 11:12.340
我一种排序方式

11:12.340 --> 11:15.440
那万一开发者觉得这个顺序有必要

11:15.440 --> 11:16.740
他有他的写的代码

11:16.740 --> 11:18.240
可能依赖这个顺序呢

11:18.240 --> 11:18.940
对不对

11:18.940 --> 11:20.140
所以说我们统一一下呗

11:20.140 --> 11:21.340
他就给你统一了一下

11:21.340 --> 11:22.340
就这么个意思啊

11:22.340 --> 11:23.340
出了一个标准

11:23.340 --> 11:24.440
那么现在的排序呢

11:25.440 --> 11:29.240
es6规定了该方法

11:29.240 --> 11:32.240
返回的数组的排序

11:32.240 --> 11:33.640
方式如下

11:35.040 --> 11:36.340
d先排

11:38.440 --> 11:39.240
先排

11:40.540 --> 11:41.840
数字

11:41.840 --> 11:43.540
然后呢再排字母

11:44.440 --> 11:46.240
再排其他

11:47.340 --> 11:48.340
也就是什么意思呢

11:48.340 --> 11:49.340
我给他举个例子

11:49.340 --> 11:50.340
就在这里呢

11:50.340 --> 11:52.040
如果说你在这里写了一些数字

11:52.040 --> 11:52.640
数字属性

11:52.640 --> 11:53.840
数字能不能做属性

11:54.540 --> 11:55.640
能不能作为属性名

11:55.640 --> 11:56.340
当然可以啊

11:56.340 --> 11:57.940
数数不就是数字属性名吗

11:57.940 --> 11:58.340
啊

11:59.340 --> 11:59.840
5

12:01.340 --> 12:01.940
4

12:02.840 --> 12:03.240
好

12:03.240 --> 12:03.940
来看一下吧

12:03.940 --> 12:06.140
他最后输出的属性顺序

12:09.740 --> 12:10.240
你看一下

12:10.240 --> 12:11.340
这个属性顺序

12:11.340 --> 12:13.840
是不是先按照数字排序

12:13.840 --> 12:14.340
对吧

12:14.340 --> 12:16.140
然后再按照其他排序

12:16.140 --> 12:17.140
但是你会发现呢

12:17.140 --> 12:19.540
数字他是给你按照生序排序的

12:19.540 --> 12:20.040
对不对

12:20.040 --> 12:20.840
数字你看

12:20.840 --> 12:22.140
数字是按照生序排序的

12:22.140 --> 12:22.940
045

12:22.940 --> 12:23.140
对吧

12:23.140 --> 12:24.240
虽然说我们0

12:24.240 --> 12:25.740
这个数字是不是都写到后边了

12:25.740 --> 12:27.040
他爬到前面去了

12:27.040 --> 12:28.240
后边的属性

12:28.240 --> 12:30.140
他又没有按照生序排序啊

12:30.140 --> 12:30.740
没有

12:30.740 --> 12:31.540
你怎么写的

12:31.540 --> 12:32.540
他就怎么排

12:32.540 --> 12:33.540
就这么个意思

12:33.540 --> 12:34.940
这个了解一下就行了

12:34.940 --> 12:36.740
他会把数字放前边

12:36.740 --> 12:37.540
就这么个意思

12:37.540 --> 12:38.040
其他都没动

12:39.540 --> 12:40.340
先排数字

12:40.340 --> 12:42.040
这里并按照生序排序

12:42.040 --> 12:44.740
并按照生序排序

12:44.740 --> 12:46.040
再排其他

12:46.040 --> 12:49.540
按照书写顺序排序

12:49.540 --> 12:49.940
这这个

12:51.540 --> 12:52.240
最后一个

12:52.240 --> 12:54.840
最后一个是关于圆形的

12:54.840 --> 12:55.740
而不就这里边了

12:55.740 --> 12:57.140
他出来这么一个函数呢

12:57.140 --> 13:00.440
他是用于设置某个对象的圆形

13:00.440 --> 13:02.540
设置某个对象的影视圆形

13:02.540 --> 13:04.840
就是该函数

13:04.840 --> 13:05.640
该函数

13:06.640 --> 13:13.040
用于设置某个对象的影视圆形

13:13.040 --> 13:15.040
那么影视圆形

13:15.040 --> 13:16.040
他有两个参数

13:16.040 --> 13:17.840
他的参数一

13:17.840 --> 13:19.840
比方说

13:19.840 --> 13:21.340
比如

13:21.340 --> 13:21.940
比如

13:21.940 --> 13:23.840
Objects

13:23.840 --> 13:25.840
set property

13:25.840 --> 13:32.240
Prototype of Obj1 Obj2

13:32.240 --> 13:33.840
相当于

13:34.440 --> 13:36.040
相当于是什么了

13:36.040 --> 13:40.240
把Obj1的影视圆形Prototype

13:40.240 --> 13:42.240
设置为了Obj2

13:42.240 --> 13:42.840
就这么个意思

13:44.840 --> 13:45.740
这能看懂了吗

13:45.740 --> 13:46.740
当然的潜力条件

13:46.740 --> 13:47.840
你得理解圆形

13:47.840 --> 13:48.540
你不要告诉我

13:48.540 --> 13:50.540
你现在圆形没搞清楚

13:50.540 --> 13:51.340
回过头去看一下

13:51.340 --> 13:52.340
诚哥的课程

13:52.340 --> 13:53.440
把圆形先搞清楚

13:53.440 --> 13:55.240
相当于是这么一个意思

13:55.240 --> 13:55.840
好吧

13:55.840 --> 13:56.840
咱们再看一下吧

13:56.840 --> 13:57.640
随便举个例子

13:57.640 --> 13:58.040
看一下

13:59.540 --> 14:02.740
他就提供了一种修改圆形的手段

14:02.740 --> 14:03.140
对吧

14:03.240 --> 14:04.140
提供了这么一种手段

14:04.140 --> 14:05.740
以前我们要修改圆形的话

14:05.740 --> 14:06.440
不是那么好办

14:06.440 --> 14:07.940
得用什么Objects create

14:07.940 --> 14:08.540
对吧

14:08.540 --> 14:09.640
创建一个新的对象

14:09.640 --> 14:12.040
那么现在在不创建新的对象的情况下

14:12.040 --> 14:13.640
我们仍然可以修改圆形

14:13.640 --> 14:14.640
比方说

14:14.640 --> 14:15.640
Obj1

14:15.640 --> 14:16.640
随便写个

14:16.640 --> 14:17.440
随便写一个

14:17.440 --> 14:18.440
A等于1

14:19.640 --> 14:21.340
Counts Obj2

14:21.340 --> 14:22.240
B等于2

14:22.240 --> 14:24.740
我们把Obj1的影视圆形修改成

14:24.740 --> 14:25.840
我们要做出这么一件事

14:25.840 --> 14:27.640
Obj1的影视圆形

14:28.840 --> 14:29.740
修改为Obj2

14:29.740 --> 14:30.340
怎么做呢

14:30.340 --> 14:31.540
以前是很难做的

14:31.540 --> 14:33.340
那么现在可以用Objects

14:33.340 --> 14:34.640
Set property

14:35.640 --> 14:37.040
那么这里怎么设置呢

14:37.040 --> 14:38.440
OBj1

14:38.440 --> 14:39.940
OBj2

14:39.940 --> 14:40.740
就完了

14:40.740 --> 14:41.540
这样一设置

14:41.540 --> 14:43.540
那么OBj1的影视圆形变成OBj2了

14:43.540 --> 14:44.540
我们输出OBj1

14:44.540 --> 14:45.040
看一下吧

14:46.440 --> 14:46.540
好

14:46.540 --> 14:48.940
那么现在OBj1的Prototype

14:48.940 --> 14:49.640
Prot你看

14:49.640 --> 14:50.840
是不是OBj2了

14:50.840 --> 14:51.240
对吧

14:51.240 --> 14:51.940
OBj2

14:51.940 --> 14:52.440
你看没有

14:53.540 --> 14:56.040
OBj1的影视圆形变成OBj2了

14:56.040 --> 14:57.540
那这个东西有啥用呢

14:57.540 --> 14:59.040
大部分情况下没啥用

14:59.040 --> 14:59.540
你要说

14:59.540 --> 15:01.740
如果说你要做那种深碑模式

15:01.740 --> 15:02.040
对吧

15:02.040 --> 15:03.040
完成继承

15:03.040 --> 15:05.040
那么在继承那一块是不是要修改圆形

15:05.040 --> 15:06.740
那怎么这个东西可以用

15:06.740 --> 15:08.040
那为什么我不去讲

15:08.040 --> 15:09.940
刚才就讲一讲深碑模式里边

15:09.940 --> 15:11.140
把它用这种方式改写

15:11.140 --> 15:12.840
为什么不去讲呢

15:12.840 --> 15:14.140
因为没必要了

15:14.140 --> 15:16.840
ES6后边对于继承

15:16.840 --> 15:17.840
对于构造函数

15:17.840 --> 15:20.340
出来一个非常非常舒服的东西

15:20.340 --> 15:21.540
完全就可以抛弃掉

15:21.540 --> 15:23.140
以前的什么深碑模式

15:23.140 --> 15:24.440
自己手中去写了

15:24.440 --> 15:25.540
那么这个玩意呢

15:25.540 --> 15:27.540
就仅在于就是

15:27.640 --> 15:29.840
不用构造函数的时候

15:29.840 --> 15:30.840
不用构造函数的时候

15:30.840 --> 15:33.240
我们可能要去修改一些圆形

15:33.240 --> 15:35.740
那么只是起这么一个小的作用

15:35.740 --> 15:36.240
这种作用呢

15:36.240 --> 15:37.840
我们几乎是遇不到的

15:37.840 --> 15:38.740
所以说我们了解

15:38.740 --> 15:40.540
有这么一个函数可以修改圆形

15:40.540 --> 15:41.440
就够了

15:41.440 --> 15:42.640
就够了

15:42.640 --> 15:43.640
现在ES6呢

15:43.640 --> 15:46.040
它提供了这种修改圆形的能力

15:46.040 --> 15:46.440
但是呢

15:46.440 --> 15:47.640
以后我们要做

15:47.640 --> 15:48.640
要做一个构造函数

15:48.640 --> 15:50.840
构造函数之间要形成一个圆形链

15:50.840 --> 15:51.940
这种情况下

15:51.940 --> 15:53.640
我们要应该使用ES6里边

15:53.640 --> 15:56.240
后边新出来的一个一种API来写

15:56.340 --> 15:57.640
写起来非常非常舒服

15:57.640 --> 16:00.140
到时候大家就知道知道了啊

16:00.140 --> 16:02.140
这是关于这一块

16:02.140 --> 16:02.940
其他就没啥了啊

16:02.940 --> 16:04.340
就新增了这么一些API

16:04.340 --> 16:05.340
大家下来呢

16:05.340 --> 16:06.840
就是主要是把这个看

16:06.840 --> 16:07.740
这个去练一下

16:07.740 --> 16:09.740
这个去写一些啊

16:09.740 --> 16:11.040
其他的都

16:11.040 --> 16:13.140
这个东西写一些吧

16:13.140 --> 16:13.940
这个东西写一些啊

16:13.940 --> 16:15.440
这个都挺无所谓

16:15.440 --> 16:15.740
好

16:15.740 --> 16:16.440
下面啥了啊

