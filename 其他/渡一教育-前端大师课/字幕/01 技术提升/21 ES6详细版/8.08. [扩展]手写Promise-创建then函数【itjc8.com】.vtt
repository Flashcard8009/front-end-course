WEBVTT

00:00.050 --> 00:02.370
这些可能我们来实现这个认函数

00:02.370 --> 00:05.050
当然我们一节课实现不了这个认函数

00:05.050 --> 00:07.050
因为这个认函数还是比较复杂的

00:07.050 --> 00:10.050
我们先把这个认函数的大块的价值给它打起来

00:10.050 --> 00:12.550
我们在这里去写这么一个认函数

00:12.550 --> 00:14.550
当我们去写任何一个函数的时候

00:14.550 --> 00:16.050
一定要去思考这么几个东西

00:16.050 --> 00:18.550
第一个它有什么样的参数传入

00:18.550 --> 00:20.550
第二个有什么样的返回值

00:20.550 --> 00:23.050
那我们要完全思考这个问题的话

00:23.050 --> 00:25.050
我们就可以写一个Promise

00:25.050 --> 00:27.050
我们来看一下Promise的认函数

00:27.050 --> 00:28.050
它应该干回什么

00:28.050 --> 00:31.050
应该传入什么

00:31.050 --> 00:34.050
然后我们这里随便写Promise

00:34.050 --> 00:36.050
Promise我们不是一个认函数吗

00:36.050 --> 00:38.050
这个认函数实际上有几个参数

00:38.050 --> 00:40.050
我们讲过的有两个参数

00:40.050 --> 00:42.050
比方说这里Data

00:42.050 --> 00:44.050
这是一个参数

00:44.050 --> 00:46.050
然后Reason

00:46.050 --> 00:47.050
这是一个参数

00:47.050 --> 00:49.050
那么我们可以看到这里

00:49.050 --> 00:50.050
非常明显的有两个参数

00:50.050 --> 00:52.050
第一个参数传入什么呢

00:52.050 --> 00:53.050
传入的是一个函数

00:53.050 --> 00:56.050
表示成功之后要做的事

00:56.050 --> 00:58.050
第二个参数也是一个函数

00:58.050 --> 00:59.050
表示失败之后要做的事

00:59.050 --> 01:00.050
所以有两个参数

01:00.050 --> 01:02.050
因为它说闹有的时候

01:02.050 --> 01:03.050
我们只可以只传一个

01:03.050 --> 01:04.050
其实传一个的时候

01:04.050 --> 01:05.050
你可以想象成为

01:05.050 --> 01:06.050
表示的是第二个参数

01:06.050 --> 01:08.050
传的是OnDefend

01:08.050 --> 01:09.050
对不对

01:09.050 --> 01:10.050
因此它会有两个参数传入

01:10.050 --> 01:11.050
这是第一个

01:11.050 --> 01:12.050
所以说我们这里

01:12.050 --> 01:13.050
来去写几个参数

01:13.050 --> 01:14.050
请两个

01:14.050 --> 01:15.050
一个是叫OnFulfilled

01:15.050 --> 01:17.050
一个是OnRegetT

01:17.050 --> 01:18.050
表示这个表示什么意思

01:18.050 --> 01:20.050
成功之后的掉落的函数

01:20.050 --> 01:21.050
我们来记录一下

01:21.050 --> 01:22.050
这个是方个性

01:22.050 --> 01:25.050
这边也是方个性

01:26.050 --> 01:32.050
这是PromiseA加规范的认函数

01:32.050 --> 01:33.050
PromiseA加规范

01:33.050 --> 01:34.050
它对认函数

01:34.050 --> 01:35.050
有非常非常详细的规定

01:35.050 --> 01:37.050
它有什么样的参数传入

01:37.050 --> 01:38.050
然后又反悔什么

01:38.050 --> 01:40.050
它就非常非常详细的规定

01:40.050 --> 01:41.050
这里我们把参数写出来了

01:41.050 --> 01:42.050
稍等一下

01:42.050 --> 01:43.050
我关一下门

01:47.740 --> 01:49.740
这里我们把参数传出来了

01:49.740 --> 01:50.740
这里有两个参数

01:50.740 --> 01:52.740
它反悔什么呢

01:52.740 --> 01:53.740
它反悔啥

01:53.740 --> 01:54.740
我们看到这个认函数

01:54.740 --> 01:55.740
反悔了什么

01:55.740 --> 01:56.740
新的Promise

01:56.740 --> 01:58.740
而且它本有特殊情况

01:58.740 --> 01:59.740
它一定反悔新的Promise

01:59.740 --> 02:01.740
所以说我们这里想都不用想

02:01.740 --> 02:03.740
直接给它反悔一个New

02:03.740 --> 02:04.740
New一个新的Promise

02:04.740 --> 02:05.740
注意一个Promise

02:05.740 --> 02:06.740
用我们自己这个

02:06.740 --> 02:08.740
因为我们是自己手写

02:08.740 --> 02:09.740
NewPromise

02:09.740 --> 02:11.740
一个新的Promise

02:11.740 --> 02:12.740
新的Promise里面

02:12.740 --> 02:14.740
是不是要传入一个参数

02:14.740 --> 02:15.740
是不是要传入一个函数

02:15.740 --> 02:18.740
ResultRegetT

02:18.740 --> 02:19.740
这个我们实现

02:19.740 --> 02:20.740
实现了

02:20.740 --> 02:21.740
我们的构造函数

02:21.740 --> 02:22.740
不就是一个Excutor吗

02:22.740 --> 02:24.740
这个玩意不就是一个Excutor

02:24.740 --> 02:25.740
对不对

02:25.740 --> 02:27.740
有连向地归

02:27.740 --> 02:28.740
好 那么我们把个价值

02:28.740 --> 02:30.740
就基本上写出来了

02:30.740 --> 02:31.740
OK

02:31.740 --> 02:33.740
那接下来我们要想的是

02:33.740 --> 02:35.740
一个比较生存式的问题

02:35.740 --> 02:36.740
就是这个认函数

02:36.740 --> 02:38.740
它到底要做啥

02:38.740 --> 02:40.740
认函数要做什么呢

02:40.740 --> 02:42.740
认函数我们再详细的

02:42.740 --> 02:43.740
描述一下

02:43.740 --> 02:45.740
当你成功之后

02:45.740 --> 02:47.740
我做这件事

02:47.740 --> 02:49.740
当你失败之后

02:49.740 --> 02:51.740
我做这件事

02:51.740 --> 02:52.740
是马上做吗

02:52.740 --> 02:53.740
那不一定

02:53.740 --> 02:54.740
对吧

02:54.740 --> 02:55.740
但是我们知道

02:55.740 --> 02:57.740
这是表示的是

02:57.740 --> 02:59.740
註册一个成功的比较函数

02:59.740 --> 03:01.740
註册一个失败的比较函数

03:01.740 --> 03:02.740
因此它这些事情

03:02.740 --> 03:03.740
并不是马上做的

03:03.740 --> 03:05.740
这是第一个点

03:05.740 --> 03:06.740
这个点我们这里

03:06.740 --> 03:07.740
可能先不着急去处理它

03:07.740 --> 03:09.740
因为这个点确实比较复杂

03:09.740 --> 03:11.740
第二个点

03:11.740 --> 03:12.740
是我们知道

03:12.740 --> 03:13.740
任函数就算

03:13.740 --> 03:15.740
它马上要去执行这个函数

03:15.740 --> 03:16.740
是不是一定要

03:16.740 --> 03:17.740
不会把它放到

03:17.740 --> 03:18.740
微对列里面

03:18.740 --> 03:19.740
对吧

03:19.740 --> 03:20.740
它会把那个函数

03:20.740 --> 03:21.740
不会立即执行

03:21.740 --> 03:23.740
微对列里面执行

03:23.740 --> 03:24.740
那么这件事

03:24.740 --> 03:25.740
我们这里刻

03:25.740 --> 03:26.740
要把它完成

03:26.740 --> 03:27.740
那如何来产生

03:27.740 --> 03:28.740
一个微对列呢

03:28.740 --> 03:29.740
我们知道

03:29.740 --> 03:30.740
Promise这一块

03:30.740 --> 03:31.740
Promise

03:31.740 --> 03:34.740
我们知道Promise的函

03:34.740 --> 03:35.740
有一个Promise

03:35.740 --> 03:36.740
后面那个函方法

03:36.740 --> 03:37.740
它会产

03:37.740 --> 03:38.740
这里面的函数

03:38.740 --> 03:40.740
会放到微对列里面

03:40.740 --> 03:41.740
那么还

03:41.740 --> 03:42.740
那我现在不能用这个Promise

03:42.740 --> 03:43.740
因为我们要

03:43.740 --> 03:44.740
现在要熟悉

03:44.740 --> 03:45.740
那如何来产生

03:45.740 --> 03:47.740
一个微对列的问题是

03:47.740 --> 03:49.740
这里呢

03:49.740 --> 03:50.740
已经超过了

03:50.740 --> 03:52.740
同学们的支持范围了

03:52.740 --> 03:53.740
我这里呢

03:53.740 --> 03:54.740
给大家写一个

03:54.740 --> 03:55.740
写一个

03:55.740 --> 03:56.740
然后慢慢给你们讲

03:56.740 --> 03:57.740
我现在需要写一个

03:57.740 --> 03:59.740
辅助函数的方式

03:59.740 --> 04:01.740
叫Micro

04:01.740 --> 04:02.740
Rom

04:02.740 --> 04:04.740
MicroTask

04:04.740 --> 04:07.740
运行一个微对列任务

04:07.740 --> 04:09.740
你给我传一个函数进来

04:09.740 --> 04:10.740
这是一个辅助

04:10.740 --> 04:11.740
这是一个工具函数

04:11.740 --> 04:14.740
打个注射

04:14.740 --> 04:15.740
好 扔的东西呢

04:15.740 --> 04:16.740
我们先放这

04:16.740 --> 04:17.740
先放这

04:17.740 --> 04:18.740
我们之后呢

04:18.740 --> 04:19.740
还要进行详细的处理

04:19.740 --> 04:21.740
这里是一个函数

04:21.740 --> 04:24.500
表面上呢

04:24.500 --> 04:28.500
运行一个微对列任务

04:28.500 --> 04:29.500
或者说呢

04:29.500 --> 04:32.500
把传递的函数

04:32.500 --> 04:35.500
放到微对列中

04:35.500 --> 04:36.500
就做这么一件事

04:36.500 --> 04:38.500
你给我传一个函数进来

04:38.500 --> 04:39.500
然后呢

04:39.500 --> 04:40.500
我把这个函数放到

04:40.500 --> 04:41.500
微对列里面

04:41.500 --> 04:42.500
我们先把这个功能实现

04:42.500 --> 04:43.500
因为这个功能

04:43.500 --> 04:44.500
我们肯定是要用到的

04:44.500 --> 04:45.500
对吧

04:45.500 --> 04:46.500
虽然我们这节

04:46.500 --> 04:47.500
可能暂时用不到

04:47.500 --> 04:48.500
因为我还要

04:48.500 --> 04:49.500
详细的去分析这个Z

04:49.500 --> 04:50.500
但是呢

04:50.500 --> 04:51.500
详细的处理文

04:51.500 --> 04:52.500
先把它写出来

04:52.500 --> 04:53.500
先把这些细致

04:53.500 --> 04:54.500
默契的东西写出来

04:54.500 --> 04:55.500
那么这里的写法呢

04:55.500 --> 04:56.500
其实啊

04:56.500 --> 04:58.500
你在面试零的时候

04:58.500 --> 05:00.500
你可以把它写的

05:00.500 --> 05:01.500
特别的粗糙

05:01.500 --> 05:02.500
也没问题

05:02.500 --> 05:03.500
因为这不是Promise的核心

05:03.500 --> 05:04.500
你可以怎么写呢

05:04.500 --> 05:05.500
非常简单

05:05.500 --> 05:07.500
你又写个Z time out

05:07.500 --> 05:09.500
然后把这个callback

05:09.500 --> 05:10.500
放进去

05:10.500 --> 05:12.500
领庙后执行这个

05:12.500 --> 05:13.500
那这个是不是微对列

05:13.500 --> 05:14.500
那不是

05:14.500 --> 05:15.500
不是微对列

05:15.500 --> 05:16.500
对吧

05:16.500 --> 05:17.500
但是我们用这个东西

05:17.500 --> 05:18.500
在模拟啊

05:18.500 --> 05:19.500
模拟一个异步制修

05:19.500 --> 05:20.500
这可不可以呢

05:20.500 --> 05:21.500
当然是可以的啊

05:21.500 --> 05:23.500
其实也不会扣分

05:23.500 --> 05:25.500
但是这一块要加分

05:25.500 --> 05:26.500
那是不可能的

05:26.500 --> 05:27.500
它不会扣分

05:27.500 --> 05:28.500
因为它知道这一块

05:28.500 --> 05:29.500
并不是Promise的核心

05:29.500 --> 05:30.500
好吧

05:30.500 --> 05:31.500
这是这个点

05:31.500 --> 05:32.500
给它说一下

05:32.500 --> 05:33.500
你可以简单的写

05:33.500 --> 05:34.500
但是呢

05:34.500 --> 05:35.500
作为我们教程的话

05:35.500 --> 05:36.500
我肯定还是要

05:36.500 --> 05:37.500
尽量把它实现得完善一点

05:37.500 --> 05:39.500
那我这一块怎么去

05:39.500 --> 05:40.500
实现呢

05:40.500 --> 05:41.500
我这里呢

05:41.500 --> 05:43.500
需要区分两个环境

05:43.500 --> 05:44.500
一个是漏的环境

05:44.500 --> 05:46.500
因为我们Promise这个东西啊

05:46.500 --> 05:48.500
它是ES6的

05:48.500 --> 05:49.500
官方标准

05:49.500 --> 05:51.500
所以说它在各种环境里边

05:51.500 --> 05:52.500
都论支持

05:52.500 --> 05:53.500
漏的环境里边支持

05:53.500 --> 05:55.500
流烂器环境里边也支持

05:55.500 --> 05:56.500
好我们首先来搞定

05:56.500 --> 05:57.500
漏的环境

05:57.500 --> 06:01.390
判断漏的环境

06:01.390 --> 06:03.390
漏的环境里边有一个

06:03.390 --> 06:04.390
对象

06:04.390 --> 06:06.390
叫做Process

06:06.390 --> 06:08.390
流烂器里边没有的啊

06:08.390 --> 06:10.390
漏的环境里面有这个对象

06:10.390 --> 06:11.390
并且呢

06:11.390 --> 06:12.390
这个对象呢

06:12.390 --> 06:13.390
还有一个属性

06:13.390 --> 06:15.390
叫做Next Take

06:15.390 --> 06:19.470
有这么一个东西

06:19.470 --> 06:20.470
这个东西呢

06:20.470 --> 06:22.470
就是漏的环境里边的

06:22.470 --> 06:23.470
V对列

06:23.470 --> 06:24.470
好咱们来马上试一下啊

06:24.470 --> 06:25.470
比方说我们在这里呢

06:25.470 --> 06:26.470
去新看一个

06:26.470 --> 06:27.470
1.js

06:27.470 --> 06:28.470
我们去

06:28.470 --> 06:29.470
比方说现在就漏的环境对吧

06:29.470 --> 06:31.470
Process

06:31.470 --> 06:32.470
Next

06:33.470 --> 06:34.470
Next Take

06:34.470 --> 06:38.740
这边传一个函数进来

06:38.740 --> 06:39.740
我们这里输出一个1

06:39.740 --> 06:40.740
123

06:40.740 --> 06:41.740
然后上边呢

06:41.740 --> 06:43.740
我们再输出一个Set Timeout

06:43.740 --> 06:45.740
传一个函数

06:45.740 --> 06:46.740
输出一个1

06:46.740 --> 06:47.740
这里输出一个2

06:47.740 --> 06:48.740
然后呢

06:48.740 --> 06:51.740
Set Timeout是0

06:52.740 --> 06:53.740
以后里面学习那个

06:53.740 --> 06:54.740
里面就非常清楚了

06:54.740 --> 06:55.740
这里输出一个3

06:55.740 --> 06:57.740
那么这个输出顺序呢

06:57.740 --> 06:59.740
肯定是安先输出对吧

06:59.740 --> 07:00.740
这个毫无疑问的

07:00.740 --> 07:01.740
那么1到底先输出

07:01.740 --> 07:02.740
还是2先输出呢

07:02.740 --> 07:04.740
因为它是放到V对列里边

07:04.740 --> 07:05.740
这个东西

07:05.740 --> 07:06.740
所以说它先输出

07:06.740 --> 07:07.740
再输出1

07:07.740 --> 07:08.740
咱们来运行看一下

07:08.740 --> 07:09.740
对吧

07:09.740 --> 07:10.740
3

07:10.740 --> 07:11.740
2

07:11.740 --> 07:12.740
1

07:12.740 --> 07:13.740
所以在漏的环境里边

07:13.740 --> 07:14.740
特别简单

07:14.740 --> 07:15.740
我用它就可以

07:15.740 --> 07:16.740
实现一个V对列

07:16.740 --> 07:17.740
反正我不能用Process

07:17.740 --> 07:18.740
好OK

07:18.740 --> 07:19.740
那么在漏的环境里边

07:19.740 --> 07:20.740
我发现它有Process

07:21.740 --> 07:22.740
OK

07:22.740 --> 07:23.740
那我就可以怎么样了

07:23.740 --> 07:25.740
我就可以Process

07:25.740 --> 07:26.740
我把这个函数

07:26.740 --> 07:27.740
就放到

07:27.740 --> 07:28.740
是不是可以放到V对列里边了

07:28.740 --> 07:29.740
对吧

07:29.740 --> 07:30.740
你看这个Pro

07:30.740 --> 07:31.740
Negative

07:31.740 --> 07:32.740
它就是做这个事的

07:32.740 --> 07:33.740
它把这个函数

07:33.740 --> 07:34.740
放到V对列里边

07:34.740 --> 07:35.740
马上执行

07:35.740 --> 07:36.740
这是漏的环境

07:36.740 --> 07:37.740
那么浏览器环境

07:37.740 --> 07:39.740
如何来实现V对列呢

07:39.740 --> 07:40.740
浏览器环境

07:40.740 --> 07:41.740
我给大家说一下

07:41.740 --> 07:42.740
写个页面

07:44.740 --> 07:45.740
浏览器环境里边

07:45.740 --> 07:46.740
有一个对象

07:46.740 --> 07:50.890
叫做Tation of Zerfer

07:50.890 --> 07:51.890
这个对象我也很少用

07:51.890 --> 07:52.890
它的API我经常都爱忘

07:52.890 --> 07:54.890
所以说我经常都会查那个

07:54.890 --> 07:56.890
MDN

07:56.890 --> 07:59.890
叫做Metation of Zerfer

07:59.890 --> 08:01.890
它是一个构造函数

08:01.890 --> 08:07.630
6一个Metation of Zerfer

08:07.630 --> 08:09.630
那么这里边会传递一个函数进去

08:09.630 --> 08:10.630
这个函数就是放到

08:10.630 --> 08:12.630
V对列里边执行的

08:12.630 --> 08:15.630
我们这里输出一个变化

08:16.630 --> 08:18.630
那么这个Metation of Zerfer

08:18.630 --> 08:19.630
是什么意思呢

08:19.630 --> 08:20.630
它表示的是一个观察器

08:20.630 --> 08:23.630
它可以观察一些元素的变化

08:23.630 --> 08:24.630
只要元素一变化

08:24.630 --> 08:26.630
它就会执行这个函数

08:26.630 --> 08:27.630
但是执行的时候

08:27.630 --> 08:28.630
它是先把这个函数

08:28.630 --> 08:30.630
放到V对列里边执行

08:30.630 --> 08:31.630
它就处这么个重点

08:31.630 --> 08:32.630
平时我们开发没有什么用

08:32.630 --> 08:33.630
这个玩意儿

08:33.630 --> 08:35.630
而且有些流量器它都不支持

08:35.630 --> 08:36.630
那么这个东西

08:36.630 --> 08:37.630
它就可以实现这个

08:37.630 --> 08:38.630
那如何来观察

08:38.630 --> 08:39.630
一个元素的变化呢

08:39.630 --> 08:42.630
比方说我这里去创建一个元素

08:42.630 --> 08:43.630
当然也可以从页面上

08:43.630 --> 08:44.630
获取一个元素

08:44.630 --> 08:45.630
都无所谓

08:45.630 --> 08:46.630
创建一个元素

08:46.630 --> 08:48.630
然后我们用这个Observer

08:48.630 --> 08:49.630
去观察它

08:49.630 --> 08:52.630
它有一个方法叫Observer

08:52.630 --> 08:53.630
观察这个元素

08:54.630 --> 08:55.630
然后第二个参数

08:55.630 --> 08:57.630
你要告诉它观察什么

08:57.630 --> 08:58.630
因为元素里边有属性

08:58.630 --> 09:00.630
有什么里边的节点

09:00.630 --> 09:01.630
对吧

09:01.630 --> 09:02.630
那我这里观察什么呢

09:02.630 --> 09:04.630
观察它的Chill List

09:04.630 --> 09:05.630
表示什么

09:05.630 --> 09:11.630
表示观察该元素内部的变化

09:11.630 --> 09:12.630
只要内部有东西变了

09:12.630 --> 09:14.630
那么它就会

09:14.630 --> 09:15.630
观察器就会知道

09:15.630 --> 09:16.630
它知道了之后

09:16.630 --> 09:17.630
它就会运行这个函数

09:17.630 --> 09:18.630
但是运行的时候

09:18.630 --> 09:19.630
一定要注意

09:19.630 --> 09:20.630
它是放到V对列里边执行的

09:20.630 --> 09:21.630
好,比方说

09:21.630 --> 09:22.630
我们现在去

09:22.630 --> 09:23.630
说什么说

09:23.630 --> 09:24.630
把这个P点

09:24.630 --> 09:25.630
Inner Atmel该改了

09:25.630 --> 09:26.630
随便改吧

09:26.630 --> 09:27.630
改成一个E

09:27.630 --> 09:28.630
它一开始啥都没有

09:28.630 --> 09:29.630
改一个东西

09:29.630 --> 09:30.630
加一个东西

09:30.630 --> 09:31.630
那么这个元素

09:31.630 --> 09:32.630
里边变了

09:32.630 --> 09:33.630
Chill List变了

09:33.630 --> 09:34.630
Chill List变了之后

09:34.630 --> 09:36.630
它就会执行这个函数

09:36.630 --> 09:37.630
那么这个函数

09:37.630 --> 09:38.630
它就放到V对列里边执行的

09:38.630 --> 09:39.630
比方说我们这里

09:39.630 --> 09:40.630
输出一个E

09:40.630 --> 09:41.630
然后呢

09:41.630 --> 09:43.630
在上面再输出一个Set Time Out

09:43.630 --> 09:45.630
然后在这里输出

09:47.630 --> 09:48.630
这里输出一个

09:48.630 --> 09:50.630
这里输出E吧

09:50.630 --> 09:51.630
这里输出2

09:52.630 --> 09:53.630
然后呢

09:53.630 --> 09:54.630
我们在这里

09:54.630 --> 09:55.630
就这样吧

09:55.630 --> 09:56.630
好,OK

09:56.630 --> 09:59.580
我们在浏览器里边看一下

09:59.580 --> 10:00.580
浏览器

10:00.580 --> 10:01.580
你看

10:01.580 --> 10:02.580
输出的结果是什么

10:02.580 --> 10:03.580
2变化了

10:03.580 --> 10:04.580
1

10:04.580 --> 10:05.580
什么意思

10:05.580 --> 10:06.580
2是不同步代吗

10:06.580 --> 10:07.580
马上执行的

10:07.580 --> 10:08.580
执行到过后

10:08.580 --> 10:09.580
本来它先到红对列里

10:09.580 --> 10:10.580
对吧

10:10.580 --> 10:11.580
但是呢

10:11.580 --> 10:12.580
后来

10:12.580 --> 10:13.580
它又到V对列了

10:13.580 --> 10:14.580
那么就是

10:14.580 --> 10:15.580
红对列里边

10:15.580 --> 10:16.580
和V对列里边

10:16.580 --> 10:17.580
什么都有

10:17.580 --> 10:18.580
对吧

10:18.580 --> 10:19.580
它在红对列

10:19.580 --> 10:20.580
它在V对列

10:20.580 --> 10:21.580
那么肯定是V对列

10:21.580 --> 10:22.580
先执行

10:22.580 --> 10:23.580
哪怕它先到红对列

10:23.580 --> 10:24.580
一看执行这个的时候

10:24.580 --> 10:25.580
是不是马上就到红对列了

10:25.580 --> 10:26.580
对吧

10:26.580 --> 10:27.580
它没有等待时间吗

10:27.580 --> 10:28.580
对不对

10:28.580 --> 10:29.580
好,然后呢

10:29.580 --> 10:30.580
执行完2

10:30.580 --> 10:31.580
执行完1

10:31.580 --> 10:32.580
把这个设置了之后

10:32.580 --> 10:34.580
这个是不是马上就到V对列了

10:34.580 --> 10:35.580
然后再输出2

10:35.580 --> 10:36.580
输出2之后

10:36.580 --> 10:37.580
先执行V对列

10:37.580 --> 10:38.580
所以执行它

10:38.580 --> 10:39.580
然后再执行它

10:39.580 --> 10:40.580
因此就看到了

10:40.580 --> 10:41.580
2变化了

10:41.580 --> 10:42.580
1

10:42.580 --> 10:44.580
我们就可以利用它来磨粒V对列

10:44.580 --> 10:46.580
我们把这个地方删掉

10:46.580 --> 10:47.580
OK

10:47.580 --> 10:48.580
我们就用这段代码

10:48.580 --> 10:49.580
给它copy过去

10:49.580 --> 10:51.580
到这边来

10:51.580 --> 10:52.580
我们判断什么的

10:52.580 --> 10:53.580
判断浏览器

10:53.580 --> 10:54.580
首先支不支撑

10:54.580 --> 10:55.580
Metallin of Zover

10:55.580 --> 10:56.580
有没有这个东西

10:56.580 --> 10:57.580
如果说有的话

10:57.580 --> 10:58.580
我就用这种方式

10:58.580 --> 10:59.580
创建一个元素

10:59.580 --> 11:01.580
然后去观察这个元素

11:01.580 --> 11:02.580
当观察到变化的时候

11:02.580 --> 11:03.580
我执行什么呢

11:03.580 --> 11:05.580
执行的就是copy

11:06.580 --> 11:08.580
执行的就是copy

11:08.580 --> 11:09.580
对不对

11:09.580 --> 11:11.580
然后我故意把元素改一下

11:11.580 --> 11:12.580
然后是不是

11:12.580 --> 11:13.580
这个东西就到V对列了

11:13.580 --> 11:14.580
OK

11:14.580 --> 11:15.580
那么这是浏览环境

11:15.580 --> 11:16.580
这是浏览器环境

11:16.580 --> 11:17.580
那还有种环境呢

11:17.580 --> 11:19.580
我都不知道它是啥环境呢

11:19.580 --> 11:20.580
反正就是

11:20.580 --> 11:21.580
有可能是一些

11:21.580 --> 11:22.580
浏览器

11:22.580 --> 11:23.580
Metallin of Zover

11:23.580 --> 11:24.580
有可能是一些

11:24.580 --> 11:25.580
莫名其妙的环境

11:25.580 --> 11:26.580
那么我们

11:26.580 --> 11:27.580
这种情况呢

11:27.580 --> 11:28.580
我就确实搞不定了

11:28.580 --> 11:29.580
我就不知道该怎么去

11:29.580 --> 11:30.580
弄规对列了

11:30.580 --> 11:31.580
那我就直接用谁的带帽子

11:31.580 --> 11:32.580
这是一种非常非常

11:32.580 --> 11:33.580
完整的做法

11:33.580 --> 11:34.580
其实这种做法

11:34.580 --> 11:35.580
就是参照了那个

11:35.580 --> 11:37.580
VU的写法

11:37.580 --> 11:38.580
那我讲到这儿了

11:38.580 --> 11:39.580
说明给大家说一下

11:39.580 --> 11:40.580
这个做法其实

11:40.580 --> 11:41.580
并不是很完善

11:41.580 --> 11:42.580
它里边还是有些

11:42.580 --> 11:43.580
效率的问题

11:43.580 --> 11:44.580
你看我每一次

11:44.580 --> 11:45.580
运行这个函数

11:45.580 --> 11:46.580
它都要去新建一个

11:46.580 --> 11:47.580
Metallin of Zover

11:47.580 --> 11:50.580
是不是有点浪费效率

11:50.580 --> 11:51.580
完全可以

11:51.580 --> 11:52.580
做一个单粒

11:52.580 --> 11:54.580
就是只有一个Ozover

11:54.580 --> 11:55.580
然后我让元素

11:55.580 --> 11:56.580
不断的变化

11:56.580 --> 11:57.580
但是这样子的话

11:57.580 --> 11:58.580
会导致我们程序

11:58.580 --> 11:59.580
比较复杂

11:59.580 --> 12:00.580
因为它还要去

12:00.580 --> 12:01.580
维护对列

12:01.580 --> 12:02.580
有点麻烦

12:02.580 --> 12:03.580
所以我们这里

12:03.580 --> 12:04.580
就不用去考虑那么深了

12:04.580 --> 12:05.580
因为这毕竟也不是

12:05.580 --> 12:06.580
Promise的核心内容

12:06.580 --> 12:07.580
如果说你这一块

12:07.580 --> 12:08.580
觉得太麻烦了

12:08.580 --> 12:09.580
你就直接写个这个

12:09.580 --> 12:10.580
没有问题

12:10.580 --> 12:11.580
等等我们

12:11.580 --> 12:12.580
把它封装一下

12:12.580 --> 12:13.580
将来要改的话

12:13.580 --> 12:14.580
就改这一块就行了

12:14.580 --> 12:15.580
好 封装这个函数

12:15.580 --> 12:16.580
我们来试一下

12:16.580 --> 12:17.580
现在其实跟MyPromise

12:17.580 --> 12:18.580
已经暂势

12:18.580 --> 12:19.580
没有什么关系了

12:20.580 --> 12:21.580
OK 我们这里

12:21.580 --> 12:24.580
找到Roc Microtask

12:24.580 --> 12:25.580
好 我给它传

12:25.580 --> 12:26.580
第一个函数进去

12:26.580 --> 12:27.580
我们这里输出一个2

12:27.580 --> 12:29.580
上面一个SetTimeout

12:30.580 --> 12:31.580
Timeout

12:31.580 --> 12:32.580
那么这里

12:33.580 --> 12:34.580
输出一个1

12:34.580 --> 12:35.580
然后我们下面

12:35.580 --> 12:36.580
输出3

12:36.580 --> 12:37.580
我们来看一下

12:37.580 --> 12:38.580
如果它打印的是数据

12:38.580 --> 12:40.580
打印的顺序是3 2 1

12:40.580 --> 12:41.580
那就是正确的

12:41.580 --> 12:42.580
运行

12:43.580 --> 12:44.580
说3 2 1

12:44.580 --> 12:45.580
对吧 那就正确的

12:45.580 --> 12:46.580
OK 那么这几课呢

12:46.580 --> 12:47.580
我们就实现了

12:47.580 --> 12:48.580
这么一个函数

12:48.580 --> 12:49.580
第一个

12:49.580 --> 12:50.580
我们把这函数的结构

12:50.580 --> 12:51.580
写出来了

12:51.580 --> 12:52.580
有两个参数

12:52.580 --> 12:53.580
然后它返回一个

12:53.580 --> 12:54.580
新的Promise

12:54.580 --> 12:55.580
这个结构出来了

12:55.580 --> 12:56.580
然后我们还实现了

12:56.580 --> 12:58.580
这么一个辅助函数

12:58.580 --> 12:59.580
将来我们要用的

12:59.580 --> 13:00.580
我们把它写好之后

13:00.580 --> 13:01.580
将来就非常方便了

13:01.580 --> 13:02.580
我要产生微对的

13:02.580 --> 13:03.580
调用这个函数

13:03.580 --> 13:04.580
把函数传进去

13:04.580 --> 13:05.580
对吧

13:05.580 --> 13:06.580
那么它就会把这个函数

13:06.580 --> 13:07.580
放在微对的一边

13:07.580 --> 13:08.580
马上执行

13:08.580 --> 13:09.580
马上把它放在

13:09.580 --> 13:10.580
微对的一边

13:10.580 --> 13:11.580
将来执行

13:11.580 --> 13:12.580
OK 这几课

13:12.580 --> 13:13.580
咱们的内容

