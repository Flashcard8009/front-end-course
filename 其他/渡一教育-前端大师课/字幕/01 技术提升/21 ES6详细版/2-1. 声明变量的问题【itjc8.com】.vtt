WEBVTT

00:00.500 --> 00:04.300
这一张节呢咱们来学习快极绑定

00:04.300 --> 00:06.620
是一块非常非常简单

00:06.620 --> 00:10.020
而且非常非常实用的一块知识

00:10.020 --> 00:12.660
在学习快极绑定之前呢

00:12.660 --> 00:13.980
咱们先认识一下

00:13.980 --> 00:17.940
我们以前呢在使用界是这么语言

00:17.940 --> 00:20.420
也就是一也是这么语言的时候呢

00:20.420 --> 00:22.860
有哪些问题啊

00:22.860 --> 00:25.860
主要的问题呢发我们这里关注的是

00:25.860 --> 00:28.700
变量声明的时候发生的问题

00:28.780 --> 00:31.420
我们以前的声明变量适用了什么声明啊

00:31.420 --> 00:33.420
是不是用了var来声明对吧

00:33.420 --> 00:34.620
声明变量啊

00:34.620 --> 00:39.420
我们啊就使用var声明变量啊

00:39.420 --> 00:41.340
我们以前是这样子也用的

00:41.340 --> 00:43.460
这里呢我准备准备了一个页面

00:43.460 --> 00:44.580
他引用了那个界式

00:44.580 --> 00:46.300
这个界式呢我们还没有写

00:46.300 --> 00:48.140
那么以前用那个var来声明变量

00:48.140 --> 00:49.740
还会有什么样的问题呢

00:49.740 --> 00:52.620
我们之前在在在讲那个javascript的时候啊

00:52.620 --> 00:54.700
也说过啊他有这么几个特点

00:54.700 --> 00:57.340
第一个呢是允许重复的变量声明

00:57.340 --> 00:58.580
那么他有这么一个特点

00:58.620 --> 01:00.180
这个特点还有导致的一个问题

01:00.180 --> 01:02.980
叫做导致数据被覆盖

01:02.980 --> 01:05.300
其实呢这个允许重复变量声明呢

01:05.300 --> 01:07.420
不是一个好的现象啊

01:07.420 --> 01:08.900
他会容易导致数据被覆盖

01:08.900 --> 01:09.380
什么意思呢

01:09.380 --> 01:11.740
我给大家举个例子啊

01:11.740 --> 01:16.700
呃重复把这个主持打过来吧

01:16.700 --> 01:21.000
啊放过来啊

01:21.000 --> 01:22.440
我给大家看一下啊

01:22.440 --> 01:24.000
就这种情况下呢

01:24.000 --> 01:26.480
他容易导致什么样的问题

01:26.480 --> 01:27.280
比方说吧

01:27.280 --> 01:29.760
我们这里呢有这么一个变量

01:29.800 --> 01:31.120
啊一个A

01:31.120 --> 01:33.440
A那等于1

01:33.440 --> 01:35.600
然后呢我们写了这么一个函数啊

01:35.600 --> 01:36.920
写了这么一个函数

01:36.920 --> 01:39.680
叫做print啊打印啊

01:39.680 --> 01:40.880
打印这么一个函数

01:40.880 --> 01:41.960
我们这里输出什么呢

01:41.960 --> 01:43.480
输出A啊

01:43.480 --> 01:45.320
接下来呢我们又定义了一个变量

01:45.320 --> 01:46.320
A等于2

01:46.320 --> 01:49.120
好接下来呢我们调用这个函数print

01:49.120 --> 01:49.920
你看一下啊

01:49.920 --> 01:52.560
咱们运行出来看一下

01:52.560 --> 01:53.600
那么你看一下这个函数

01:53.600 --> 01:55.400
他输出的是多少

01:55.400 --> 01:57.200
我相信了这个

01:57.200 --> 01:59.080
应该所有同学都应该知道吧

01:59.120 --> 02:00.240
这个没什么好说了啊

02:00.240 --> 02:01.400
他输出了一定是2

02:01.400 --> 02:01.800
对吧

02:01.800 --> 02:02.520
输出了一定是2

02:02.520 --> 02:03.880
因为他有个B包嘛

02:03.880 --> 02:04.840
你因为你这里呢

02:04.840 --> 02:05.960
定了两个变量啊

02:05.960 --> 02:06.520
一个是A

02:06.520 --> 02:07.640
还一个还是A

02:07.640 --> 02:08.840
所以说他们实际上呢

02:08.840 --> 02:10.120
是同一个变量啊

02:10.120 --> 02:11.760
实际上是同一个变量

02:11.760 --> 02:12.840
那么这里用了B包

02:12.840 --> 02:14.760
当调用这个函数的时候呢

02:14.760 --> 02:16.520
他打印的是外面

02:16.520 --> 02:18.560
外面这个作用域里边的变量A

02:18.560 --> 02:19.640
所以说他输出的是

02:19.640 --> 02:21.800
一定是最新的值2

02:21.800 --> 02:22.800
因为这两个A呢

02:22.800 --> 02:24.160
实际上是同一个东西

02:24.160 --> 02:26.040
原来说这个不是挺自然的吗

02:26.040 --> 02:27.440
那是因为你可能呢

02:27.480 --> 02:29.200
还没有接触过其他语言

02:29.200 --> 02:30.440
在其他语言里边

02:30.440 --> 02:32.640
这个东西是非常非常怪异的

02:32.640 --> 02:33.200
为什么呢

02:33.200 --> 02:34.520
你想想这个道理啊

02:34.520 --> 02:37.040
假设这里还有一千行代码

02:37.040 --> 02:37.560
假设

02:38.880 --> 02:43.260
这里也有一千行代码

02:43.260 --> 02:45.700
那么你写了一千行代码之后

02:45.700 --> 02:47.060
你再去定一个变量

02:47.060 --> 02:49.700
是不是有可能跟之前的变量重复了

02:49.700 --> 02:51.140
你写了一千行啊

02:51.140 --> 02:52.500
你这个时候再定一个变量

02:52.500 --> 02:53.740
你还能准确的知道

02:53.740 --> 02:55.380
之前定过哪些变量吗

02:55.380 --> 02:57.220
是不是有可能会重复啊

02:57.260 --> 02:58.300
那么这样一来

02:58.300 --> 03:00.060
一旦重复了之后

03:00.060 --> 03:01.500
那么你的想法了

03:01.500 --> 03:02.540
可能跟之前

03:02.540 --> 03:04.340
就是你写的代码的意图

03:04.340 --> 03:06.460
可能跟实际的效果就不太一致了

03:06.460 --> 03:08.740
因为你在写一千行代码之前

03:08.740 --> 03:09.860
你写了这么一个函数

03:09.860 --> 03:12.300
你是希望这个函数打印的时候呢

03:12.300 --> 03:13.700
打印的是这个A

03:13.700 --> 03:15.220
因为当时你还没有写这个代码

03:15.220 --> 03:15.940
对吧

03:15.940 --> 03:17.340
后来你写了一千行

03:17.340 --> 03:18.460
你再去写这个代码的时候

03:18.460 --> 03:20.620
你忘了之前已经有个A了

03:20.620 --> 03:21.420
你忘了

03:21.420 --> 03:22.300
当然不一定是A

03:22.300 --> 03:23.460
可能是别的名字

03:23.460 --> 03:24.900
可能是别的变量名

03:24.900 --> 03:27.180
你可能忘了之前有这么一个A了

03:27.220 --> 03:28.460
然后呢你不知道

03:28.460 --> 03:30.580
你自己的这一行代码之后呢

03:30.580 --> 03:32.980
会影响到之前的很多函数

03:32.980 --> 03:35.060
是不是很多函数受到影响了

03:35.060 --> 03:37.100
那么这个学者代码量的增加

03:37.100 --> 03:38.060
是不是这个情况

03:38.060 --> 03:39.260
会越来越多越来越多

03:39.260 --> 03:40.260
越来越麻烦

03:40.260 --> 03:42.100
越来越难以处理

03:42.100 --> 03:43.260
你就会发现

03:43.260 --> 03:44.620
他没有包任何的错误

03:44.620 --> 03:45.660
结果呢

03:45.660 --> 03:48.100
我的一调整函数跟我想的不一样

03:48.100 --> 03:49.140
因为为什么

03:49.140 --> 03:51.220
因为这个变量被改了

03:51.220 --> 03:53.140
到时候你要去调是这样的错误

03:53.140 --> 03:53.660
你要封

03:53.660 --> 03:54.060
我告诉你

03:54.060 --> 03:55.460
你真的要封掉

03:55.500 --> 03:57.700
因为你不知道到底是哪个地方

03:57.700 --> 03:58.580
改了这个数据

03:58.580 --> 04:00.060
你不知道到底是哪个地方

04:00.060 --> 04:01.020
你可能找了一天

04:01.020 --> 04:02.140
找了几一周才发现

04:03.140 --> 04:05.340
就是个变量名字重复的问题

04:05.340 --> 04:06.260
这就是为什么

04:06.260 --> 04:08.500
既也是他的一些原罪

04:08.500 --> 04:10.940
他不太适合开发大型应用

04:10.940 --> 04:11.700
对吧

04:11.700 --> 04:14.100
挖这个变量声明这一块

04:14.100 --> 04:15.260
都有严重的问题

04:15.260 --> 04:17.700
怎么能允许重复的变量名字出现呢

04:17.700 --> 04:17.980
对吧

04:17.980 --> 04:19.340
变量只能声明一次

04:19.340 --> 04:21.180
你要么就重新给他复制而已

04:21.180 --> 04:23.780
你不能去重复去声明变量

04:23.780 --> 04:25.260
但是以前是可以的

04:25.260 --> 04:27.860
因此的导致数据被覆盖掉了

04:27.860 --> 04:30.020
就之前的数据被覆盖掉了

04:30.020 --> 04:31.660
我们最理想的状况是什么

04:31.660 --> 04:33.340
最理想的状况你给我爆错

04:33.340 --> 04:34.540
这是最理想的状况

04:34.540 --> 04:34.940
爆错了

04:34.940 --> 04:36.300
我就马上知道这一块一个问题

04:36.300 --> 04:36.980
马上改

04:36.980 --> 04:39.100
不要等到我以后拥折拥折出了问题的

04:39.100 --> 04:40.140
我到处去找错误

04:40.140 --> 04:41.060
不知道在哪

04:41.060 --> 04:42.300
你还在意什么

04:42.300 --> 04:43.580
这是第一个问题

04:43.580 --> 04:45.780
他以为他允许变量重复声明

04:45.780 --> 04:47.060
导致的数据被覆盖

04:47.060 --> 04:49.860
从而产生了一些连错反应

04:49.860 --> 04:51.900
这是第一个问题

04:51.900 --> 04:53.460
我们再看第二个问题

04:53.500 --> 04:55.580
第二个问题叫做变量提升

04:55.580 --> 04:57.740
这个玩意大家应该都知道

04:57.740 --> 04:59.020
在函数里边的变量

04:59.020 --> 05:00.180
它会提升到最顶部

05:00.180 --> 05:00.700
对吧

05:00.700 --> 05:02.500
然后在全局重要率的变量

05:02.500 --> 05:04.980
它也会提升到最顶部

05:04.980 --> 05:05.940
那么这样你来了

05:05.940 --> 05:08.100
变量提升了又会导致一些问题

05:08.100 --> 05:08.980
第一个

05:08.980 --> 05:11.340
怪异的数据访问

05:11.340 --> 05:12.460
我们先说这个

05:12.460 --> 05:13.340
怪异的数据访问

05:13.340 --> 05:14.420
什么叫怪异的数据访问

05:14.420 --> 05:16.460
我给大家看个例子

05:16.460 --> 05:18.220
比方说我们这样子写吧

05:18.220 --> 05:18.980
Mass

05:18.980 --> 05:20.980
就 right on

05:20.980 --> 05:22.420
小语宁电

05:22.460 --> 05:23.820
就是有可能进这个判断

05:23.820 --> 05:24.700
有可能不进

05:24.700 --> 05:25.940
如果说进了这个判断

05:25.940 --> 05:27.980
我定一个变量

05:27.980 --> 05:29.380
定一个变量A

05:29.380 --> 05:31.540
等于ABC

05:31.540 --> 05:32.860
随便下写一个

05:32.860 --> 05:34.900
然后我们输出A

05:34.900 --> 05:38.020
Els输出A

05:38.020 --> 05:39.540
你看一下这个代码

05:39.540 --> 05:41.740
多噁心就知道了

05:41.740 --> 05:44.980
这里输出A

05:44.980 --> 05:46.980
这个代码它怎么都不爆出

05:46.980 --> 05:47.700
你看

05:47.700 --> 05:50.100
它输出undefine undefine

05:50.100 --> 05:51.580
undefine undefine

05:51.740 --> 05:52.260
再刷新

05:52.260 --> 05:53.580
还进不去寻划

05:53.580 --> 05:55.380
判断了我不信

05:55.380 --> 05:58.660
还进不去判断了

05:58.660 --> 06:01.180
再来

06:01.180 --> 06:02.700
再刷新

06:02.700 --> 06:04.380
这个运气这么差吗

06:04.380 --> 06:07.180
ABC ABC

06:07.180 --> 06:09.420
这有什么怪异的呢

06:09.420 --> 06:10.060
你看着

06:10.060 --> 06:11.180
我们来读一下这个代码

06:11.180 --> 06:13.420
读一下就觉得很怪异了

06:13.420 --> 06:15.500
当如果踩踩的一个随机数

06:15.500 --> 06:17.700
如果随机数小于0.5

06:17.700 --> 06:20.620
我们就声明一个变量ABC

06:20.660 --> 06:21.740
然后输出A

06:21.740 --> 06:23.100
是这个逻辑吧

06:23.100 --> 06:23.740
这样读代吧

06:23.740 --> 06:24.740
是这个逻辑吧

06:24.740 --> 06:25.820
没问题吧

06:25.820 --> 06:26.500
如果说

06:26.500 --> 06:27.900
随机数小于0.5

06:27.900 --> 06:29.140
我们就声明变量

06:29.140 --> 06:30.060
我们来读一下

06:30.060 --> 06:32.700
我们用个技术给大家写一下

06:32.700 --> 06:37.980
如果随机数小于0.5

06:37.980 --> 06:40.820
则声明变量

06:40.820 --> 06:43.420
你看我这里是不是在声明变量A

06:43.420 --> 06:45.860
复制为ABC

06:45.860 --> 06:48.940
然后输出A

06:48.940 --> 06:54.380
如果随机数不小于0.5

06:54.380 --> 06:55.980
则输出A

06:55.980 --> 06:59.180
你看一下这个逻辑是不是有问题的

06:59.180 --> 07:00.140
好好读一下这个话

07:00.140 --> 07:01.700
是不是逻辑上有问题

07:01.700 --> 07:03.540
如果随机数小于0.5

07:03.540 --> 07:04.700
才声明这个变量

07:04.700 --> 07:06.300
如果随机数不小于0.5

07:06.300 --> 07:07.900
有没有声明变量

07:07.900 --> 07:09.020
变量都没有

07:09.020 --> 07:09.860
哪有变量

07:09.860 --> 07:11.060
没有变量

07:11.060 --> 07:12.660
那为什么会输出A呢

07:12.660 --> 07:13.820
那A哪来的呢

07:13.820 --> 07:15.340
你都没有声明

07:15.340 --> 07:17.660
那为什么这个代码不爆错了

07:17.700 --> 07:19.900
是不是这个逻辑是有问题的

07:19.900 --> 07:21.420
读起来是有问题的

07:21.420 --> 07:22.780
但是这个代码没有爆错

07:22.780 --> 07:25.100
为什么是因为有变量提升

07:25.100 --> 07:25.860
你这个变了

07:25.860 --> 07:28.140
它会被提升到最顶部

07:28.140 --> 07:30.500
它会变成这样的语法

07:30.500 --> 07:30.900
对吧

07:30.900 --> 07:32.300
是不是这样的逻辑

07:32.300 --> 07:32.460
好

07:32.460 --> 07:34.100
那么它这个语法是不是变了

07:34.100 --> 07:35.540
本来它的逻辑上

07:35.540 --> 07:36.580
刚才的书写的逻辑

07:36.580 --> 07:38.140
应该是这样的逻辑的

07:38.140 --> 07:40.580
但是结果它变成了什么样的逻辑呢

07:40.580 --> 07:41.820
它变成这样的逻辑

07:41.820 --> 07:46.060
先声明一个变量A

07:46.060 --> 07:49.500
然后如果水积数小于0.5

07:49.500 --> 07:50.940
如果水积数小于0.5

07:50.940 --> 07:52.900
负责为ABC输出A

07:52.900 --> 07:56.300
如果水否则输出A

07:56.300 --> 07:57.740
变成这样的逻辑了

07:57.740 --> 08:00.860
那跟我们的代码格式上的表达逻辑

08:00.860 --> 08:02.700
是不是有差异的

08:02.700 --> 08:03.340
对吧

08:03.340 --> 08:05.060
这就是GSE里边变量提升

08:05.060 --> 08:06.700
很怪异的地方

08:06.700 --> 08:08.620
我明明在这个区域中

08:08.620 --> 08:09.980
没有声明变量A

08:09.980 --> 08:11.780
结果我也能访问

08:11.780 --> 08:13.020
它也不爆错

08:13.020 --> 08:13.620
这样子呢

08:13.660 --> 08:16.740
是不是在鼓励你去写一些错误的代码

08:16.740 --> 08:17.940
你应不应该这样子写

08:17.940 --> 08:19.500
是不是不应该这样子写

08:19.500 --> 08:21.180
你都没有去声明变量A

08:21.180 --> 08:23.180
哪能去输出A呢

08:23.180 --> 08:23.620
对吧

08:23.620 --> 08:24.940
是不是不能这样子写

08:24.940 --> 08:26.660
但是由于它这样的一个特点

08:26.660 --> 08:27.940
有个变量提升的特点

08:27.940 --> 08:31.340
导致了它允许你书写这样的怪异的

08:31.340 --> 08:32.300
数据访问代码

08:32.300 --> 08:33.540
在这里去访问了数据A

08:33.540 --> 08:36.860
这个数据A本来是应该从语法角度

08:36.860 --> 08:37.940
是应该不存在的

08:37.940 --> 08:39.580
你把这个代码拿给任何语言

08:39.580 --> 08:41.820
就书写任何的内设的代码

08:41.820 --> 08:42.780
它都会爆错

08:42.780 --> 08:44.780
它会告诉你这里出了问题

08:44.780 --> 08:46.020
这里也出了问题

08:46.020 --> 08:48.620
你只能在这里边访问这个A

08:48.620 --> 08:50.620
如果你接触过其他语言

08:50.620 --> 08:52.380
很多计划机专业的同学应该接触过

08:52.380 --> 08:53.060
假坝啊

08:53.060 --> 08:54.140
谁语言对吧

08:54.140 --> 08:56.140
都不应该出现这种情况

08:56.140 --> 08:57.060
对不对

08:57.060 --> 08:58.100
是这种逻辑吧

08:58.100 --> 08:59.980
你看这个代码读起来了

08:59.980 --> 09:01.140
应该是在这里边声明的

09:01.140 --> 09:02.540
结果它提升跑到外边去了

09:02.540 --> 09:03.980
就怪异的数据访问

09:03.980 --> 09:06.140
从语法的角度来说

09:06.140 --> 09:08.700
它读起来是比较怪的

09:08.700 --> 09:11.380
那么另外一个问题就更加严重了

09:11.820 --> 09:13.820
边上其中当然的另外一个问题就是

09:15.420 --> 09:16.580
这里

09:16.580 --> 09:17.940
必爆问题

09:17.940 --> 09:19.100
什么必爆问题呢

09:19.100 --> 09:20.820
我给大家举个例子

09:20.820 --> 09:22.820
我这样举什么例子呢

09:23.900 --> 09:25.060
我们举这个例子

09:25.060 --> 09:27.060
还是用一个数组

09:27.060 --> 09:29.060
方形式

09:30.060 --> 09:32.060
或者我们举一个比较现实的例子

09:33.540 --> 09:35.540
举一个比较现实的例子

09:37.100 --> 09:37.900
这样吧

09:37.900 --> 09:40.580
我们这里在这个DEAV里面生成

09:41.060 --> 09:43.060
这里边生成一些按钮

09:43.060 --> 09:45.060
加入一些按钮

09:45.060 --> 09:47.060
加入10个按钮吧

09:47.060 --> 09:47.860
好吧

09:47.860 --> 09:49.860
这个DEAV里面加入10个按钮

09:49.860 --> 09:50.860
DEAV

09:50.860 --> 09:52.860
buttons

09:52.860 --> 09:56.170
这也是一个常见的场景

09:56.170 --> 09:59.170
我们使用GS里面提供的web API

09:59.170 --> 10:00.170
来得到

10:00.170 --> 10:01.170
这不是ES的知识

10:01.170 --> 10:03.170
这是GS的web API

10:03.170 --> 10:06.170
通过得到DEAV buttons

10:06.170 --> 10:07.170
BTS

10:07.170 --> 10:10.170
得到这个DEAV

10:10.650 --> 10:14.650
往这个DEAV里面打算加上10个按钮

10:14.650 --> 10:15.650
怎么写

10:15.650 --> 10:16.650
是不是循环

10:16.650 --> 10:17.650
循环多少次

10:17.650 --> 10:18.770
循环

10:18.770 --> 10:19.770
i等于10次

10:19.770 --> 10:20.770
对不对

10:20.770 --> 10:21.770
i等于1

10:21.770 --> 10:22.770
i小于10

10:22.770 --> 10:23.770
i加加

10:23.770 --> 10:24.770
是不是循环10次

10:24.770 --> 10:25.770
每一个循环一次

10:25.770 --> 10:26.770
我加一个按钮进去

10:26.770 --> 10:28.770
document

10:28.770 --> 10:29.770
create element

10:29.770 --> 10:30.770
加一个按钮

10:30.770 --> 10:31.770
button

10:31.770 --> 10:33.770
创建这么一个按钮

10:33.770 --> 10:34.770
button

10:36.770 --> 10:38.770
然后

10:38.770 --> 10:39.770
看着

10:40.370 --> 10:42.370
然后我们给这个按钮

10:42.370 --> 10:43.370
加一个文本

10:43.370 --> 10:45.370
inner element

10:45.370 --> 10:46.370
文本是什么

10:46.370 --> 10:47.370
按钮

10:47.370 --> 10:49.370
加上一拼接上一个i

10:49.370 --> 10:51.370
然后把这个按钮加到DEAV里面去

10:51.370 --> 10:52.370
Apply the child

10:52.370 --> 10:54.370
一个非常非常简单的例子

10:54.370 --> 10:55.370
保存

10:55.370 --> 10:56.370
咱们看一下

10:56.370 --> 10:58.370
因为它说的就10个按钮

10:58.370 --> 10:59.370
那么接下来

10:59.370 --> 11:00.370
我们要做一件事

11:00.370 --> 11:02.370
就是点这个按钮

11:02.370 --> 11:03.370
它输出

11:04.370 --> 11:06.370
它对应的数字

11:06.370 --> 11:08.370
点这个按钮输出对应的数字

11:08.970 --> 11:09.970
onclick

11:09.970 --> 11:11.970
点击

11:11.970 --> 11:12.970
做出一个事件

11:12.970 --> 11:13.970
点击的时候

11:13.970 --> 11:14.970
我们输出它

11:14.970 --> 11:15.970
输出i

11:15.970 --> 11:16.970
对吧

11:16.970 --> 11:17.970
输出i

11:17.970 --> 11:18.970
是不是它对应的数字

11:18.970 --> 11:19.970
来我们来看一下

11:19.970 --> 11:20.970
会有什么样的问题

11:20.970 --> 11:22.970
这是一个典型的必包问题

11:22.970 --> 11:23.970
这个必包问题的根源

11:23.970 --> 11:25.970
就是有变量提升导致的

11:25.970 --> 11:27.970
咱们来看一下

11:27.970 --> 11:29.970
点击过后

11:29.970 --> 11:30.970
点击按钮7

11:30.970 --> 11:31.970
它输出11

11:31.970 --> 11:32.970
点击按钮1

11:32.970 --> 11:33.970
输出11

11:33.970 --> 11:34.970
点击按钮9

11:34.970 --> 11:35.970
输出11

11:35.970 --> 11:36.970
怎么回事

11:36.970 --> 11:37.970
怎么回事呢

11:38.970 --> 11:39.970
怎么回事

11:39.970 --> 11:41.970
我这样子一写你就明白了

11:42.970 --> 11:44.970
它有一个变量提升

11:44.970 --> 11:46.970
我这样子写是不是你就看懂了

11:48.970 --> 11:50.970
每一个按钮点击过后

11:50.970 --> 11:52.970
是不是使用了同一个变量i

11:52.970 --> 11:54.970
是不是用了同一个变量

11:54.970 --> 11:55.970
对吧

11:55.970 --> 11:56.970
不是每一次循环

11:56.970 --> 11:57.970
一个新的变量

11:57.970 --> 11:58.970
不是每一次循环

11:58.970 --> 11:59.970
一个新的变量

11:59.970 --> 12:00.970
是所有的按钮

12:00.970 --> 12:02.970
都用的是同一个变量i

12:02.970 --> 12:04.970
那等到点这个按钮的时候

12:04.970 --> 12:06.970
是不是循环早结束了

12:06.970 --> 12:08.970
循环结束过后

12:08.970 --> 12:09.970
这个i是多少

12:09.970 --> 12:10.970
是不是就11

12:10.970 --> 12:11.970
11就是循环条件不满足

12:11.970 --> 12:12.970
又到了这里

12:12.970 --> 12:14.970
循环结束后

12:14.970 --> 12:16.970
循环结束后

12:16.970 --> 12:17.970
i等于多少

12:17.970 --> 12:18.970
是不是等于11

12:18.970 --> 12:19.970
对吧

12:20.970 --> 12:21.970
当你点按钮的时候

12:21.970 --> 12:22.970
是不是循环早结束了

12:22.970 --> 12:24.970
我们后面才点的按钮

12:24.970 --> 12:25.970
循环运起来都快

12:25.970 --> 12:26.970
这个不到1毫秒

12:26.970 --> 12:27.970
好

12:27.970 --> 12:28.970
当你点这个按钮的时候

12:28.970 --> 12:29.970
i的指是不是11

12:29.970 --> 12:30.970
对吧

12:30.970 --> 12:31.970
那你看一下

12:31.970 --> 12:32.970
这里是不是有个B包

12:32.970 --> 12:33.970
这个函数里面输出了

12:33.970 --> 12:34.970
i不变量i

12:34.970 --> 12:35.970
那么这个i

12:35.970 --> 12:36.970
所谓的都是用了

12:36.970 --> 12:37.970
同一个i

12:37.970 --> 12:38.970
那i等于11

12:38.970 --> 12:39.970
那所谓的按钮点击过后

12:39.970 --> 12:40.970
输出的都是11

12:40.970 --> 12:42.970
这也是一个变量提升的问题

12:42.970 --> 12:44.970
也是个变量提升的问题

12:45.970 --> 12:47.970
如果说

12:47.970 --> 12:48.970
如果说

12:48.970 --> 12:49.970
你

12:49.970 --> 12:50.970
有没有想办法

12:50.970 --> 12:51.970
想办法

12:51.970 --> 12:53.970
你不是说有这个i出了问题吗

12:53.970 --> 12:54.970
对吧

12:54.970 --> 12:55.970
这个i出了问题

12:55.970 --> 12:56.970
好

12:56.970 --> 12:58.970
那我在这里面再订一个g

12:58.970 --> 12:59.970
你看看这样行不行

12:59.970 --> 13:00.970
再订一个g

13:00.970 --> 13:01.970
把这个i的指

13:01.970 --> 13:02.970
给g

13:02.970 --> 13:03.970
然后这里输出g

13:03.970 --> 13:04.970
那这样子一来不就是

13:04.970 --> 13:05.970
每一次点击有一个

13:05.970 --> 13:06.970
他有自己的变量g了吗

13:06.970 --> 13:08.970
在循环里边定义的g

13:08.970 --> 13:09.970
有用吗

13:10.970 --> 13:11.970
你看呀

13:11.970 --> 13:12.970
有用吗

13:12.970 --> 13:13.970
他变成输出

13:13.970 --> 13:14.970
全部输出10了

13:14.970 --> 13:15.970
为什么

13:15.970 --> 13:16.970
为什么没用了

13:17.970 --> 13:19.970
为什么没用了

13:19.970 --> 13:21.970
因为他也会提升

13:21.970 --> 13:23.970
他也会提升

13:23.970 --> 13:25.970
又导致了所有的点击过后

13:25.970 --> 13:27.970
又使用了同一个变量g

13:27.970 --> 13:28.970
这个g是不是同一个

13:28.970 --> 13:29.970
改来改去

13:29.970 --> 13:30.970
改来改去都是同一个

13:30.970 --> 13:31.970
对吧

13:31.970 --> 13:32.970
每一次循环改了

13:32.970 --> 13:33.970
每一次循环改了

13:33.970 --> 13:34.970
最后点击按钮的时候

13:34.970 --> 13:35.970
输出了都是同一个g

13:35.970 --> 13:36.970
对不对

13:36.970 --> 13:37.970
为什么是10

13:37.970 --> 13:38.970
因为最后一次循环

13:38.970 --> 13:40.970
给g负的值就是10

13:40.970 --> 13:42.970
出了循环就不会再复制了

13:42.970 --> 13:43.970
对吧

13:43.970 --> 13:44.970
他就变成这么一种情况

13:44.970 --> 13:46.970
所以说这两个情况都没有

13:46.970 --> 13:48.970
导致我们没有办法

13:48.970 --> 13:49.970
解决这样的问题

13:49.970 --> 13:51.970
这就是必包带来的问题

13:51.970 --> 13:52.970
对吧

13:53.970 --> 13:54.970
这些问题的根源

13:54.970 --> 13:55.970
大家知道吗

13:55.970 --> 13:56.970
就是因为变量提升

13:56.970 --> 13:57.970
如果说没有变量提升

13:57.970 --> 13:59.970
因为这个变量

13:59.970 --> 14:01.970
每一次循环绑立在一起

14:01.970 --> 14:03.970
是不是就不会出现这样的问题了

14:03.970 --> 14:04.970
每一次点击

14:04.970 --> 14:05.970
它用了不是不同的变量

14:05.970 --> 14:06.970
虽然名字一样

14:06.970 --> 14:07.970
但是不同的变量

14:07.970 --> 14:09.970
那是不是就不会导致这样的问题了

14:09.970 --> 14:10.970
对不对

14:10.970 --> 14:12.970
这就是一个点雄的必包问题

14:12.970 --> 14:13.970
所以说我们以前为了解决

14:13.970 --> 14:14.970
这个问题是不是要写一个

14:14.970 --> 14:16.970
非常非常恶心和丑陋的带吗

14:16.970 --> 14:17.970
怎么写的

14:17.970 --> 14:19.970
当时的带吗怎么写的

14:19.970 --> 14:20.970
当时的带吗

14:20.970 --> 14:22.970
是不是这样子写的

14:22.970 --> 14:24.970
要写一个匿名函数

14:24.970 --> 14:25.970
对吧

14:25.970 --> 14:26.970
匿名函数

14:26.970 --> 14:28.970
然后呢

14:28.970 --> 14:30.970
在这里立即

14:30.970 --> 14:32.970
立即执行函数

14:32.970 --> 14:34.970
然后这里有个i

14:34.970 --> 14:36.970
是不是要这样子写

14:36.970 --> 14:37.970
这带吗就多丑陋

14:37.970 --> 14:38.970
你知道吗

14:38.970 --> 14:39.970
我们本来就只是要注册这个时间的

14:39.970 --> 14:41.970
为了解决这样的必包问题

14:41.970 --> 14:43.970
是不是我们也得这样去处理

14:43.970 --> 14:44.970
对吧

14:44.970 --> 14:45.970
这样去处理

14:45.970 --> 14:46.970
才能解决这样的问题

14:46.970 --> 14:47.970
又不好理解

14:47.970 --> 14:48.970
又丑陋的带吗

14:48.970 --> 14:49.970
那么今后

14:49.970 --> 14:50.970
我希望了

14:50.970 --> 14:52.970
就没有这样的带吗了

14:52.970 --> 14:53.970
基本上是没有了

14:53.970 --> 14:55.970
这一张学习玩的结果

14:55.970 --> 14:57.970
就不会有这样的带吗了

14:57.970 --> 14:58.970
那么这是这个问题

14:58.970 --> 14:59.970
全部输出

14:59.970 --> 15:01.970
输出11

15:01.970 --> 15:02.970
对吧

15:02.970 --> 15:04.970
这是第二个问题

15:04.970 --> 15:05.970
好

15:05.970 --> 15:06.970
这些问题都是由于

15:06.970 --> 15:07.970
变量

15:07.970 --> 15:08.970
挖变量声明

15:08.970 --> 15:10.970
它本身的特点导致的问题

15:10.970 --> 15:11.970
第三个问题

15:11.970 --> 15:13.970
就更加就是容易理解了

15:13.970 --> 15:15.970
就是会导致

15:15.970 --> 15:19.730
全局变量污染的问题

15:19.730 --> 15:21.730
因为我们知道

15:21.730 --> 15:23.730
这个挖声明的变量

15:23.730 --> 15:25.730
它是会挂载到哪呢

15:25.730 --> 15:26.730
就在全局变量

15:26.730 --> 15:28.730
全局声明的挖变量

15:28.730 --> 15:29.730
它会挂得到全局对象

15:29.730 --> 15:31.730
那么这个全局对象

15:31.730 --> 15:34.730
在这个浏览器环境里边

15:34.730 --> 15:36.730
就是Window对象

15:36.730 --> 15:37.730
那么这个Window对象

15:37.730 --> 15:38.730
你不是说声明了

15:38.730 --> 15:39.730
很多变量过后

15:39.730 --> 15:41.730
会导致Window对象里边的成员

15:41.730 --> 15:42.730
被污染掉了

15:42.730 --> 15:43.730
对吧

15:43.730 --> 15:45.730
比方说你声明一个ABC123

15:45.730 --> 15:48.730
那么你输出

15:48.730 --> 15:51.730
输出Window.ABC

15:51.730 --> 15:52.730
你看一下

15:52.730 --> 15:53.730
有没有值呢

15:53.730 --> 15:54.730
不有值吗

15:54.730 --> 15:55.730
ABC123

15:55.730 --> 15:57.730
这不是很怪异吗

15:57.730 --> 15:58.730
它会导致一个什么样的问题呢

15:58.730 --> 16:00.730
它会导致Window里边挂载成员

16:00.730 --> 16:02.730
属性是不是越来越多

16:02.730 --> 16:05.730
那么容易导致全局变量污染

16:05.730 --> 16:07.730
比方说你写了很多的JS

16:07.730 --> 16:08.730
这个JS里边

16:08.730 --> 16:09.730
你要用的一变量

16:09.730 --> 16:10.730
可能污染了

16:10.730 --> 16:12.730
另外一个JS里边

16:12.730 --> 16:14.730
设置了全局变量

16:14.730 --> 16:15.730
因为它挂得到

16:15.730 --> 16:17.730
同一个Window对象里边

16:17.730 --> 16:18.730
那么这里

16:18.730 --> 16:19.730
还有可能会导致一个问题

16:19.730 --> 16:20.730
就是说

16:20.730 --> 16:21.730
有的时候

16:21.730 --> 16:24.730
你可能会写一些东西

16:24.730 --> 16:26.730
会导致Window对象里边

16:27.730 --> 16:29.730
它已有我的成员被覆盖掉了

16:29.730 --> 16:31.730
比方说你写这么一个东西

16:31.730 --> 16:33.730
Console等于ABC

16:33.730 --> 16:35.730
那么现在你在输出

16:36.730 --> 16:38.730
输出Console

16:38.730 --> 16:40.730
你看一下

16:40.730 --> 16:42.730
Console

16:42.730 --> 16:43.730
保存

16:43.730 --> 16:44.730
它告诉你

16:44.730 --> 16:46.730
console.log一次输出

16:46.730 --> 16:47.730
你这个代表用不了了

16:47.730 --> 16:48.730
为什么那么不老

16:48.730 --> 16:49.730
因为你这个玩意儿

16:49.730 --> 16:51.730
本来这个Console

16:51.730 --> 16:52.730
本来这个Console

16:52.730 --> 16:55.730
是Window对象里边已有的成员

16:55.730 --> 16:56.730
结果你把它改了

16:56.730 --> 16:57.730
改成ABC了

16:57.730 --> 16:58.730
你看没

16:58.730 --> 16:59.730
如果你不写这句话

16:59.730 --> 17:00.730
你看一下

17:00.730 --> 17:01.730
不写这句话

17:01.730 --> 17:03.730
Window Console是不是一个对象

17:03.730 --> 17:04.730
它里面有提供了各种各样的方法

17:04.730 --> 17:05.730
对吧

17:05.730 --> 17:06.730
有Log的方法

17:06.730 --> 17:07.730
所以我们之所以可以使用

17:07.730 --> 17:08.730
Console.log

17:08.730 --> 17:09.730
是因为Window对象里边可以使用

17:09.730 --> 17:11.730
是Window对象里面的成员

17:11.730 --> 17:12.730
那你这样子一写

17:12.730 --> 17:13.730
是不是复改掉了

17:13.730 --> 17:14.730
对不对

17:14.730 --> 17:16.730
它导致了Console.log没法用了

17:16.730 --> 17:17.730
你可以随意复改

17:17.730 --> 17:18.730
Window对象的成员

17:18.730 --> 17:19.730
它的坏区就在这

17:19.730 --> 17:20.730
当然还有

17:20.730 --> 17:21.730
还有就是说

17:21.730 --> 17:22.730
有的时候

17:22.730 --> 17:23.730
常见的一个常计

17:23.730 --> 17:24.730
就是你设置Name

17:24.730 --> 17:25.730
Name是一个常计

17:25.730 --> 17:27.730
非常非常常见的辩量迷

17:27.730 --> 17:29.730
是一个非常非常常见的辩量迷

17:29.730 --> 17:31.730
结果你把Window对象里边的Name

17:31.730 --> 17:32.730
给它复改掉了

17:32.730 --> 17:33.730
Window对象里边

17:33.730 --> 17:34.730
它原本

17:35.730 --> 17:36.730
Window对象里边

17:36.730 --> 17:38.730
原本就有一个Name属性

17:38.730 --> 17:39.730
原本就有一个Name属性

17:39.730 --> 17:41.730
你给它复改掉了

17:41.730 --> 17:43.730
因为我们不写这个Name

17:43.730 --> 17:44.730
不写这个Name

17:44.730 --> 17:45.730
你看一下

17:45.730 --> 17:47.730
Window.Name

17:48.730 --> 17:49.730
刷新词

17:49.730 --> 17:51.730
Window.Name

17:52.730 --> 17:53.730
ABC

17:55.730 --> 17:56.730
ABC

17:56.730 --> 17:57.730
Window.Name

18:01.100 --> 18:03.100
应该复制过了

18:03.100 --> 18:04.100
因为复制过了

18:04.100 --> 18:05.100
我们重新打开一次

18:05.100 --> 18:07.100
重新打开一次浏览器

18:10.250 --> 18:11.250
刷新

18:11.250 --> 18:13.250
Window.Name

18:14.250 --> 18:15.250
是不是一个空置不串

18:15.250 --> 18:16.250
对吧

18:16.250 --> 18:17.250
一个空置不串

18:17.250 --> 18:19.250
它表示我们的窗口的名称

18:19.250 --> 18:20.250
这个东西有什么用

18:20.250 --> 18:22.250
这个东西平时也没啥用

18:22.250 --> 18:24.250
它可能跟iFrame结合起来

18:24.250 --> 18:25.250
有点用处

18:25.250 --> 18:26.250
可以设置窗口的名称

18:26.250 --> 18:27.250
平时也没啥用

18:27.250 --> 18:28.250
总之我们通过这个例子

18:28.250 --> 18:29.250
就告诉大家

18:29.250 --> 18:31.250
容易覆盖掉Window里边

18:31.250 --> 18:32.250
已有的成员

18:33.250 --> 18:34.250
还有可能会导致

18:34.250 --> 18:35.250
全局成员的无断问题

18:35.250 --> 18:37.250
其实都是全局成员的无断问题

18:37.250 --> 18:39.250
这就是我们之前

18:39.250 --> 18:41.250
使用Var生命变量

18:41.250 --> 18:43.250
它的三个特点

18:43.250 --> 18:45.250
以及由于这三个特点的存在

18:45.250 --> 18:47.250
导致了三个非常恶心的问题

18:47.250 --> 18:49.250
这个我如果说你用习惯了

18:49.250 --> 18:50.250
你还不觉得恶心

18:50.250 --> 18:51.250
当你开发大型项目的时候

18:51.250 --> 18:52.250
恶心死

18:52.250 --> 18:53.250
把你恶心死

18:53.250 --> 18:54.250
真的是恶心死

18:55.250 --> 18:56.250
所以说

18:56.250 --> 18:58.250
为了让介石语言

18:58.250 --> 19:00.250
能够适应大型应用的开发

19:00.250 --> 19:03.250
因此必须要解决

19:03.250 --> 19:04.250
这个变量生命的问题

19:04.250 --> 19:06.250
你变量生命都要出这么多问题

19:06.250 --> 19:07.250
那还谈什么

19:07.250 --> 19:09.250
后续的处理呢

19:09.250 --> 19:10.250
那么下节课

19:10.250 --> 19:11.250
我们来说

19:11.250 --> 19:13.250
在ES6里边如何来解决

19:13.250 --> 19:14.250
这样的问题的

