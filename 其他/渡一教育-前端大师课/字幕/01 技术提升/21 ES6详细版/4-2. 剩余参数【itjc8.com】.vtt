WEBVTT

00:00.560 --> 00:03.880
这节课咱们来学习圣语参数

00:03.880 --> 00:10.880
圣语参数也是在ES6里边增加的一个非常非常优秀的功能

00:10.880 --> 00:19.000
利用这个功能我们可以几乎是说可以抛弃掉以前使用argument来处理这个问题的

00:19.000 --> 00:24.280
比方说我们以前没有圣语参数的时候会遇到一个什么样的问题呢

00:24.280 --> 00:27.280
比方说咱们有这么一个函数上

00:27.880 --> 00:35.080
求和一个非常非常简单的函数就求和反回一个求和就所谓的数字之和就行了

00:35.080 --> 00:40.520
那么我们希望这个函数到时候我这样调用一个数可以没问题

00:40.520 --> 00:44.440
两个数可以没问题三个数也可以没问题

00:44.440 --> 00:47.440
四个数五个数一千个参数都没问题

00:47.440 --> 00:53.120
也就是它的参数的数量是不固定的不固定的参数的数量

00:53.120 --> 00:56.840
那如果说你要去写这么一个函数的话你该怎么去输先了

00:56.880 --> 01:00.000
就遇到这么一个问题了啊你怎么去输写这个函数的问题了

01:00.920 --> 01:05.840
那么这个函数的你这里参数到你写多少个了你告诉我你写一个吧

01:05.840 --> 01:09.360
不合适两个怎么办呢你写两个呢也不合适三个怎么办呢

01:09.360 --> 01:11.120
你写多少个都不合适

01:11.120 --> 01:16.040
所以说呢这里呢以前呢有两种处理办法第一种处理办法呢

01:16.040 --> 01:19.680
就是你给我传一个数组啊你给我传一个数组进来

01:19.680 --> 01:23.840
那么这样子一来呢我就可以循环这个数组求和了对吧

01:23.840 --> 01:27.800
我这里循环这个数组啊上来于0啊4循环

01:27.800 --> 01:30.800
i等于什么argued students

01:30.800 --> 01:36.120
然后呢每一次循环了求和啊拼接上这个啊叫求和啊

01:37.240 --> 01:40.280
加上啊哪家然后呢最后反悔这个上对吧

01:40.280 --> 01:42.280
我们以前呢可以用这种方式来处理

01:42.280 --> 01:44.160
你给我传一个数组进来

01:44.160 --> 01:49.000
但是呢这样子处理的话你就必须要要求雕用这个函数的人呢

01:49.000 --> 01:51.640
你要给我传一个数组你是不是得这样子写

01:52.640 --> 01:56.520
略显麻烦啊也不是特也不说特别麻烦吧

01:56.520 --> 02:00.680
略显麻烦对吧是不是略显麻烦啊

02:00.680 --> 02:05.000
那么这样子呢一来呢雕用的人呢不是很方便啊

02:05.000 --> 02:08.280
雕用他就喜欢这样雕用这样这样挺舒服的他很爽

02:08.280 --> 02:11.800
所以说呢我们其实也有一个原则啊

02:11.800 --> 02:15.880
就是写函数的时候呢一定要让雕用的人爽

02:15.880 --> 02:19.200
我函数写的那一点没关系雕用的一定要爽

02:19.200 --> 02:22.440
为什么呢因为函数写的就是为了雕用的啊

02:22.440 --> 02:29.480
是为了雕用服务的雕用的场景呢要远远大于函数定议的场景

02:29.480 --> 02:32.040
定议函数你只需要定议一次就够了

02:32.040 --> 02:34.680
那么雕用呢可能也无数次呢要来雕用

02:34.680 --> 02:36.840
所以说呢为了避免后续的麻烦

02:36.840 --> 02:40.080
尽量让雕用的人呢雕用的舒服一点啊

02:40.080 --> 02:44.280
所以说呢我们这种这种办法呢我们把past掉不合适

02:44.280 --> 02:46.640
那么如果说这样子的办法不合适的话

02:46.680 --> 02:49.840
我们会就会转而去寻求别的办法

02:49.840 --> 02:52.480
怎么写呢是不是可以利用这种方式

02:52.480 --> 02:54.440
我们利用argument

02:54.440 --> 02:56.320
啊利用argument

02:56.320 --> 02:58.080
你不是说里面有有什么呢

02:58.080 --> 03:01.280
有那个就是snaps对吧

03:01.280 --> 03:02.240
我们把这个啊

03:02.240 --> 03:03.440
哎

03:03.440 --> 03:07.560
我们把这个argument转换成数组啊

03:07.560 --> 03:09.120
argument本来就是为数组的吧

03:09.120 --> 03:11.120
我们可以这样子写啊

03:11.120 --> 03:13.080
所以我们可以这样子来书写啊

03:13.080 --> 03:15.080
也可以达到同样的效果的看一下吧

03:16.080 --> 03:17.080
啊

03:17.080 --> 03:19.840
啊

03:19.840 --> 03:20.840
看

03:20.840 --> 03:22.840
是不是也可以达到同样的效果对吧

03:22.840 --> 03:24.840
求和也没问题对不对啊

03:24.840 --> 03:28.840
因为argument里边记录了你真实的传递的所有的参数啊

03:28.840 --> 03:31.840
它形成了一个尾数组啊一个内数组

03:31.840 --> 03:34.840
但是呢这种方式呢有点点不好

03:34.840 --> 03:35.840
为什么呢

03:35.840 --> 03:38.840
第一个原因啊就是argument的缺陷

03:38.840 --> 03:42.840
argument的缺陷啊

03:42.840 --> 03:43.840
第一个问题呢

03:43.840 --> 03:48.840
就是如果和形参配合使用啊

03:48.840 --> 03:51.840
容易导致混乱

03:51.840 --> 03:53.840
就是我们之前说过

03:53.840 --> 03:55.840
如果说这里有形参的话

03:55.840 --> 03:58.840
那么argument里边东西是不跟形参对应的啊

03:58.840 --> 04:00.840
那么这样子一对应的话

04:00.840 --> 04:03.840
你不小心改变了形参argument里边东西也改了

04:03.840 --> 04:05.840
那你在严格模式下呢

04:05.840 --> 04:06.840
由于两个是分开的

04:06.840 --> 04:08.840
有的时候呢你又希望对应啊

04:08.840 --> 04:10.840
总之麻烦啊

04:10.840 --> 04:11.840
容易造成混乱

04:11.840 --> 04:14.840
因为只要有同一个数据出现在两个地方

04:14.840 --> 04:15.840
就容易造成混乱

04:15.840 --> 04:17.840
这是第一个原因

04:17.840 --> 04:18.840
第二个原因呢

04:18.840 --> 04:20.840
从语意上来说啊

04:20.840 --> 04:22.840
从语意上

04:22.840 --> 04:24.840
语意上啊

04:24.840 --> 04:29.840
使用argument获取参数

04:29.840 --> 04:33.840
由于形参缺失

04:33.840 --> 04:35.840
就是你既然要用argument来获取参数

04:35.840 --> 04:37.840
一定是因为形参

04:37.840 --> 04:38.840
它少了一些形参

04:38.840 --> 04:40.840
你看这里是不是没有形参

04:40.840 --> 04:42.840
由于形参缺失

04:42.840 --> 04:50.840
无法从含数定义上理解含数的真实意图

04:50.840 --> 04:51.840
这是从语意上

04:51.840 --> 04:53.840
其实这个问题是最严重的

04:53.840 --> 04:55.840
就是说我们要雕用含数

04:55.840 --> 04:58.840
需不需要去看含数怎么实现的

04:58.840 --> 05:01.840
你们以前去雕用的数组里边给你提供的含数

05:01.840 --> 05:02.840
你知道它是怎么实现的吗

05:02.840 --> 05:04.840
你管它是怎么实现的呀

05:04.840 --> 05:06.840
我只要知道这个含数名字是啥

05:06.840 --> 05:07.840
是什么含义

05:07.840 --> 05:09.840
要传哪些参数就行了

05:09.840 --> 05:12.840
但是由于你不使用形参

05:12.840 --> 05:15.840
利用argument在内部实现

05:15.840 --> 05:17.840
那么从这个含数的定义语法上

05:17.840 --> 05:19.840
你看这个含数的定义语法上

05:19.840 --> 05:21.840
有个含数名称没有形参

05:21.840 --> 05:22.840
从这个定义语法上

05:22.840 --> 05:23.840
从语意上来讲

05:23.840 --> 05:26.840
是不是按理说是不应该传递参数的

05:26.840 --> 05:27.840
但是你鬼知道

05:27.840 --> 05:28.840
它里边给你实现的

05:28.840 --> 05:30.840
用argument来做了这件事情

05:30.840 --> 05:32.840
所以说从语意上读起来

05:32.840 --> 05:34.840
不是那么容易阅读

05:34.840 --> 05:37.840
因此为了解决这个问题

05:37.840 --> 05:39.840
ES6出来了剩余参数

05:39.840 --> 05:40.840
来解决这个问题

05:40.840 --> 05:42.840
剩余参数来做什么呢

05:42.840 --> 05:44.840
剩余参数

05:44.840 --> 05:47.840
就是ES6的剩余参数

05:47.840 --> 05:52.840
专门用于收集

05:52.840 --> 05:56.840
末尾的所有参数

05:56.840 --> 06:02.840
将其放置到一个形参数主中

06:02.840 --> 06:04.840
它是来做这么一件事情的

06:04.840 --> 06:06.840
也就是说我们

06:06.840 --> 06:08.840
以这里传递的参数

06:08.840 --> 06:10.840
它会把它进行收集

06:10.840 --> 06:12.840
收集自动把它放到一个数主里边去

06:12.840 --> 06:14.840
那么这个东西怎么来收集呢

06:14.840 --> 06:17.840
剩余参数是要写到形参里边的

06:17.840 --> 06:18.840
你看着我怎么写

06:18.840 --> 06:20.840
在这里直接写上一个形参

06:20.840 --> 06:22.840
随便名字随便取

06:22.840 --> 06:24.840
形参的名字随便取

06:24.840 --> 06:26.840
只不过做一件事

06:26.840 --> 06:29.840
形参前边加上三个点

06:29.840 --> 06:31.840
这就是一个剩余参数

06:31.840 --> 06:32.840
它来做什么呢

06:32.840 --> 06:33.840
它来收集的

06:33.840 --> 06:35.840
三个点的名字是省略号

06:35.840 --> 06:36.840
省略号就是

06:36.840 --> 06:37.840
我不知道后面有多少东西

06:37.840 --> 06:38.840
不管你有多少东西

06:38.840 --> 06:39.840
你给我传的东西

06:39.840 --> 06:41.840
我们全把它收集到这个数主里边

06:41.840 --> 06:43.840
因此ARCUS

06:43.840 --> 06:48.840
收集了所有的参数

06:48.840 --> 06:50.840
它是不是把参数所有的参数

06:50.840 --> 06:52.840
收集到这个形参里面的

06:52.840 --> 06:54.840
形成的一个数主

06:54.840 --> 06:56.840
它就形成了一个数主

06:56.840 --> 06:58.840
因此我们这里直接使用ARCUS就行了

06:58.840 --> 07:01.840
比方说我这里不去使用这个东西

07:01.840 --> 07:02.840
我们直接输出ARCUS

07:02.840 --> 07:04.840
你看一下吧

07:04.840 --> 07:05.840
保存

07:05.840 --> 07:06.840
你看一下

07:06.840 --> 07:07.840
第一个是不是收集了个数主

07:07.840 --> 07:09.840
1,1,2,1,2,3,1,2,3,4

07:09.840 --> 07:11.840
所以把这些参数就收集到这个数主里边去了

07:11.840 --> 07:13.840
不管你传递的是几个

07:13.840 --> 07:14.840
全部收集到数主里边去了

07:14.840 --> 07:16.840
哪怕你不传递

07:16.840 --> 07:17.840
哪怕你不传递

07:17.840 --> 07:18.840
不传递的话

07:18.840 --> 07:20.840
它数主是空的

07:20.840 --> 07:21.840
你看这意思吧

07:21.840 --> 07:22.840
就这么简单

07:22.840 --> 07:25.840
它起一个收集参数的目的

07:25.840 --> 07:27.840
那么它既然已经把参数

07:27.840 --> 07:28.840
收集到一个数主里边了

07:28.840 --> 07:29.840
那还不简单吗

07:29.840 --> 07:31.840
我们需不需要使用ARCUS

07:31.840 --> 07:32.840
不需要

07:32.840 --> 07:34.840
直接用这个数主就完事了

07:34.840 --> 07:35.840
你看

07:35.840 --> 07:37.840
是不是直接使用个数主就完事了

07:37.840 --> 07:38.840
对不对

07:38.840 --> 07:39.840
没问题吧

07:39.840 --> 07:40.840
是不是很简单

07:40.840 --> 07:42.840
这就是圣语参数

07:42.840 --> 07:44.840
它定义在行参位置

07:44.840 --> 07:46.840
它的语法

07:46.840 --> 07:49.600
语法

07:49.600 --> 07:51.600
方式

07:52.600 --> 07:53.600
这里边

07:53.600 --> 07:54.600
三个点

07:54.600 --> 07:56.600
行参名

07:56.600 --> 07:58.600
那么它会收集参数

07:58.600 --> 08:00.600
把这个参数放到这个数主里边

08:00.600 --> 08:02.600
这个参数是一个数主

08:02.600 --> 08:03.600
就这么简单

08:03.600 --> 08:05.600
这就是圣语参数

08:05.600 --> 08:06.600
是不是很简单

08:06.600 --> 08:08.600
明白这个意思吗

08:08.600 --> 08:09.600
好

08:09.600 --> 08:11.600
那么现在我们了解了

08:11.600 --> 08:14.600
圣语参数的使用方式

08:14.600 --> 08:15.600
我们再来说一下

08:15.600 --> 08:19.600
圣语参数在使用上的一些细节

08:19.600 --> 08:21.600
比方说一下细节

08:21.600 --> 08:25.300
细节

08:25.300 --> 08:27.300
第一个细节

08:27.300 --> 08:29.300
一个函数

08:29.300 --> 08:31.300
仅能出现

08:31.300 --> 08:33.300
一个圣语参数

08:33.300 --> 08:34.300
它不能出现多个

08:34.300 --> 08:36.300
你不能说也写多个圣语参数

08:36.300 --> 08:37.300
来我们来复制一个

08:37.300 --> 08:39.300
来写一个圣语

08:39.300 --> 08:42.300
如果说它能够收集多个圣语参数的话

08:42.300 --> 08:43.300
会怎么样

08:43.300 --> 08:45.300
你看这个就会造成逻辑混乱

08:45.300 --> 08:47.300
比方说ARCHUS 1

08:47.300 --> 08:49.300
再来一个ARCHUS 2

08:49.300 --> 08:51.300
它肯定给你爆出了

08:51.300 --> 08:52.300
肯定爆出了毫无疑问

08:52.300 --> 08:54.300
我们输出ARCHUS 1

08:55.300 --> 08:57.300
然后再来输出

08:58.300 --> 09:00.300
再来输出ARCHUS 2

09:00.300 --> 09:01.300
Test

09:01.300 --> 09:02.300
比方说

09:02.300 --> 09:03.300
你想吧

09:03.300 --> 09:04.300
你想这个道理吗

09:04.300 --> 09:06.300
它怎么能不混乱

09:06.300 --> 09:07.300
它说什么

09:07.300 --> 09:08.300
Rest

09:08.300 --> 09:09.300
Rest就是圣语的

09:09.300 --> 09:10.300
Rest parameter

09:10.300 --> 09:15.300
圣语参数必须是最后一个行参

09:15.300 --> 09:16.300
最后一个行参

09:16.300 --> 09:18.300
formal parameter就是行参的意思

09:18.300 --> 09:20.300
圣语参数必须是最后一个行参

09:20.300 --> 09:22.300
那么现在

09:23.300 --> 09:24.300
它的错误就是

09:24.300 --> 09:25.300
前边写了行参的

09:25.300 --> 09:27.300
我们现在是不是只能出现

09:27.300 --> 09:28.300
两个前边写了行参的

09:28.300 --> 09:29.300
这就爆出了

09:29.300 --> 09:30.300
我一会再说

09:30.300 --> 09:32.300
为什么只能是最后一个行参

09:32.300 --> 09:33.300
那么我们看一下

09:33.300 --> 09:34.300
出现了多个圣语参数

09:34.300 --> 09:36.300
它理解它就混乱了

09:36.300 --> 09:37.300
它就无法理解了

09:37.300 --> 09:38.300
因为你传的参数

09:38.300 --> 09:40.300
它到底该怎么收集呢

09:40.300 --> 09:41.300
它就不知道了

09:41.300 --> 09:42.300
你看它可以这样收集

09:42.300 --> 09:44.300
把1和32收集到这

09:44.300 --> 09:46.300
这后边3个收集到这

09:46.300 --> 09:47.300
它可以这样收集

09:47.300 --> 09:49.300
也可以把前面3个收集到这

09:49.300 --> 09:50.300
后边2个收集到这

09:50.300 --> 09:51.300
它到底该怎么收集呢

09:51.300 --> 09:52.300
它不知道了

09:52.300 --> 09:54.300
所以它只能出现一个圣语参数

09:54.300 --> 09:55.300
这是第1个点

09:55.300 --> 09:56.300
第2个点

09:56.300 --> 09:58.300
一个函数

09:58.300 --> 10:01.300
如果有圣语参数

10:01.300 --> 10:03.300
圣语参数

10:03.300 --> 10:08.300
圣语参数必须是最后一个参数

10:08.300 --> 10:11.300
圣语参数必须是最后一个参数

10:11.300 --> 10:13.300
然后再来一个例子

10:13.300 --> 10:15.300
比方说我们这里前边

10:15.300 --> 10:16.300
还有一个

10:16.300 --> 10:18.300
两个参数A和B

10:18.300 --> 10:21.300
如果说我把圣语参数

10:21.300 --> 10:24.300
后边还有参数C和D

10:24.300 --> 10:26.300
比方说有这么一些参数

10:26.300 --> 10:27.300
来吧

10:27.300 --> 10:29.300
我们来看一下这个函数的逻辑

10:29.300 --> 10:32.300
是不是混乱的逻辑

10:32.300 --> 10:35.300
那么我们现在调用这个函数

10:35.300 --> 10:36.300
你看一下

10:36.300 --> 10:37.300
现在肯定抱错了

10:37.300 --> 10:38.300
它又是刚才的错误

10:38.300 --> 10:41.300
圣语参数B必须是最后一个形参

10:41.300 --> 10:43.300
那么现在的逻辑混乱在哪呢

10:43.300 --> 10:44.300
你看一下它蒙了

10:44.300 --> 10:46.300
那么现在有几种情况

10:46.300 --> 10:47.300
你看一下吧

10:47.300 --> 10:49.300
第1种情况

10:49.300 --> 10:51.300
A传给A

10:51.300 --> 10:52.300
这个没问题

10:52.300 --> 10:55.300
32传给B这个没问题

10:55.300 --> 10:57.300
圣语参数

10:57.300 --> 10:59.300
这个圣语参数

10:59.300 --> 11:00.300
哪些是圣语参数呢

11:00.300 --> 11:01.300
有几种情况

11:01.300 --> 11:03.300
圣语参数可以是什么呢

11:03.300 --> 11:06.300
46734

11:06.300 --> 11:08.300
后边的C没有传D

11:08.300 --> 11:10.300
D没有传D

11:10.300 --> 11:12.300
D也这个意思吗

11:12.300 --> 11:13.300
你可以不传C or D

11:13.300 --> 11:14.300
我们调用函数

11:14.300 --> 11:16.300
是不是可以不传OB的参数

11:16.300 --> 11:18.300
它没有传D

11:18.300 --> 11:19.300
这是D种情况

11:19.300 --> 11:20.300
情况2

11:20.300 --> 11:22.300
懂我这个意思了吗

11:22.300 --> 11:24.300
我的鼠腰怎么又不行了

11:25.300 --> 11:26.300
等一下

11:26.300 --> 11:28.300
我的鼠腿又不见了

11:28.300 --> 11:29.300
好

11:29.300 --> 11:30.300
第二种情况是

11:30.300 --> 11:32.300
我只把这两个收集了

11:32.300 --> 11:33.300
C那是34

11:33.300 --> 11:34.300
D没有传D

11:34.300 --> 11:36.300
懂我这个意思吗

11:36.300 --> 11:38.300
不好意思

11:38.300 --> 11:39.300
不好意思

11:39.300 --> 11:41.300
把我讲课的诗度都打完了

11:41.300 --> 11:42.300
好 的确

11:42.300 --> 11:44.300
那么你理解我的意思吧

11:44.300 --> 11:45.300
就是说

11:45.300 --> 11:46.300
你这样子去调用的话

11:46.300 --> 11:47.300
还搞不清楚了

11:47.300 --> 11:49.300
这个C和D怎么办呢

11:49.300 --> 11:50.300
它到底传还是不传呢

11:50.300 --> 11:52.300
哪些是收集的圣语参数呢

11:52.300 --> 11:53.300
是不是搞不清楚了

11:53.300 --> 11:54.300
因此它认为

11:54.300 --> 11:56.300
圣语参数必须是最后一个

11:56.300 --> 11:58.300
最后一个的话就没有问题了

11:58.300 --> 12:00.300
最后一个的话你看一下

12:00.300 --> 12:02.300
那A是1B是32

12:02.300 --> 12:04.300
剩下的全部是圣语参数

12:04.300 --> 12:05.300
收集到圣语参数里面

12:05.300 --> 12:06.300
圣语参数嘛

12:06.300 --> 12:07.300
就剩下的东西

12:07.300 --> 12:09.300
所以说圣语参数

12:09.300 --> 12:11.300
它必须是最后一个参数

12:11.300 --> 12:13.300
其他就没啥了

12:13.300 --> 12:17.300
这是关于圣语参数的使用

12:17.300 --> 12:19.300
那么有了圣语参数之后

12:19.300 --> 12:20.300
我们以后呢

12:20.300 --> 12:23.300
就不太会需要ARCUMENT了

12:23.300 --> 12:26.300
这个东西其实在一部分作用上

12:26.300 --> 12:28.300
就是来替换ARCUMENT了

12:28.300 --> 12:29.300
我们后边的ARCUMENT

12:29.300 --> 12:31.300
其实很多时候你想ARCUMENT

12:31.300 --> 12:34.300
就不就是搞定那个参数不确定的问题吗

12:34.300 --> 12:35.300
对不对

12:35.300 --> 12:36.300
那么这个圣语参数

12:36.300 --> 12:38.300
就可以搞定这个问题了

12:38.300 --> 12:39.300
这是关于圣语参数

12:39.300 --> 12:40.300
练习一下

12:40.300 --> 12:41.300
这个东西很重要的

12:41.300 --> 12:42.300
练习一下

12:42.300 --> 12:43.300
随便找一个例子

12:43.300 --> 12:44.300
比方说就是球合

12:44.300 --> 12:46.300
你练习一下

12:46.300 --> 12:47.300
好 这是关于圣语参数

