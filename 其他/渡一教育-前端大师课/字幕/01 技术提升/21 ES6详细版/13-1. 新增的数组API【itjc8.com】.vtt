WEBVTT

00:00.690 --> 00:04.290
来吧 增强的宿主功能

00:04.290 --> 00:08.090
说的是啥呢 这个章节其实特别简单啊 东西也不多

00:08.090 --> 00:12.890
就是呢 ES6里面呢 他给宿主里面新增了一些API

00:12.890 --> 00:16.690
使我们之后呢 操作宿主呢 或者是面对一些特殊场景的

00:16.690 --> 00:20.090
有更多的可以选择了啊 就其实就是讲这么一些东西

00:20.090 --> 00:24.090
我们这一课呢 其实API学习是最简单的 你大家发现没

00:24.090 --> 00:28.090
就是如果说没有什么新的思想 新的理念出来的话

00:28.290 --> 00:33.090
纯粹是新增API的话 学习起来是非常简单的 那么就告诉你怎么拥挤完事了

00:33.090 --> 00:37.690
好来吧 呃 首先呢 他在宿主里面加了一个静态方法啊 两个静态方法

00:37.690 --> 00:42.490
一个是二五 一个是from 这两个方法呢 都是用来创建宿主的

00:42.490 --> 00:45.690
啊 我们首先看这个二五方法 这个二五方法呢 他是用来

00:46.410 --> 00:51.490
根据你指定的宿主项来创建一个宿主 来帮我们看一下吧 特别特别简单

00:54.760 --> 00:55.720
好 我们来看一下啊

00:56.720 --> 01:04.120
呃 比方说啊 尔瑞 他里边一个静态方法 二五 那么这个里边传啥呢 这里边传任何类型啊

01:04.120 --> 01:10.720
任何类型的参数和任何类型的数量都可以啊 比方说12345

01:12.320 --> 01:15.720
那么这样子呢 他就会得到一个新的宿主啊 你可以接受一下

01:16.920 --> 01:22.520
输出 那么输出这个输出呢 就是里面包含12345 对吧 看一下啊

01:25.920 --> 01:26.520
哎 看一下

01:30.550 --> 01:35.350
好 刷新啊 你看什么12345 哎 有些同学说那这个没必要啊

01:35.750 --> 01:41.550
因为我们以前学宿主的时候 不是个宿主的勾造函数就能够实现这样的功能吗 对吧

01:41.950 --> 01:46.350
哎 宿主的勾造函数是不是能够实现这样的功能 对不对啊 保存啊 你看一下

01:46.830 --> 01:52.870
那么是不是得到一样的东西 那为什么他还给你搞出一个二五呢 他主要是目的呢 是因为

01:53.190 --> 01:58.870
在宿主勾造函数里边容易出现这么一种场景 当你只有一个参数的时候

01:59.910 --> 02:06.590
那么这个参数如果是数字的话 他表达的是什么意思呢 表达的是这个数组的长度为一

02:06.790 --> 02:10.750
而不是数组的里边的有哪些像有哪些数据 对吧 你看一下

02:11.470 --> 02:14.990
那么现在这个数组呢 就是长度为一啊 这是空数组 对吧

02:15.750 --> 02:16.310
明白的意思吗

02:17.030 --> 02:26.670
所以说呢 因为以前的数组勾造函数呢 他觉得之前设计得不好 但是他又不能把它推翻重来 因为他考虑接动性问题 因为有些工程呢 是根据以前的

02:27.510 --> 02:32.790
这种理念做出来的 所以说他考虑接动性问题 那没办法 他又给你新做了一个API

02:33.230 --> 02:39.310
那么这个API呢 无论你传递的是多少个参数 无论人参数是什么类型 他反回了一定是数组

02:39.590 --> 02:44.470
并且呢 参数的含义呢 是固定的 就是数组里边的像 有哪些数据

02:44.950 --> 02:50.230
那么这样子比较说 我们这样得到的结果是什么 一个长度为一的数组里边第一项是一

02:50.710 --> 02:56.270
如果我们这里写的 写的是五 那么就是得到一个长度为一的数组 里边第一项是五

02:57.070 --> 02:58.510
他的一含义的比较固定

02:59.830 --> 03:04.950
他就为了消除以前的勾造函数里边的起义 如果说你以后呢

03:05.870 --> 03:09.150
有了这两种方式的之后呢 我个人建议啊

03:09.790 --> 03:17.990
就是你以后创建数组 除非呢 就是说你要创建一个指定长度的数组 你可以用这种方式

03:18.230 --> 03:20.030
那这里面就写一个数字 长度

03:20.990 --> 03:30.790
否则的话 其他情况就是你要初始化数组里边每一项的话 要么就用那个余法堂啊 两个大 两个中过号啊 里边是也写 要么就使用

03:31.110 --> 03:33.150
用这种方式来创建

03:33.870 --> 03:35.510
没有问题吧 这是关于第一个函数

03:36.950 --> 03:37.990
好 第二个呢

03:39.990 --> 03:47.070
他指什么意思呢 这个函数呢 他是通过改定的内数组 或者是可谍在对象创建一个新数组

03:47.390 --> 03:55.670
就咱们以前呢 经常会遇到 特别是在动物操作里边 得到一个内数组 对吧 比方说我们这里写的这么一个document

03:56.510 --> 04:02.350
query select all 我们把一面上所谓的div打到 那么这个东西是不是一个

04:03.550 --> 04:11.870
内数组 对吧 他有点 他是相一个数组 他不是一个数组啊 怎么叫不是一个数组 就是不是通过而为的构造函数来的东西 就是

04:12.550 --> 04:15.190
内数组 但他又相一个数组 看一下吧

04:16.670 --> 04:25.630
这就是一个典型的内数组 老存看一下吧 这里看是不是得到所有的div 但是呢 看上去像是一个数组 实际上他不是数组 因为有什么

04:25.870 --> 04:32.310
他原型并不是array 对吧 并不是数组 那么既然他并不是array的话 他就不能使用array里面的方法

04:32.750 --> 04:37.590
啊 比方说我要在这里面使用什么4e 呃 这是这个方法是他给你提供的啊

04:38.190 --> 04:40.350
这个方法是他那个loadless 就是

04:41.150 --> 04:45.750
这个对象给你提供的啊 我们看一下啊 数组里面不比方说

04:46.630 --> 04:51.910
filter 来 我要使用这个方法能使用吗啊 我们试一下啊

04:52.910 --> 05:00.270
就随便写个吧 force 啊 咱们来写写一下啊 能使用吗 filter is not function 对吧 是不能使用

05:00.710 --> 05:04.590
对不对 不能使用 因为他是内数组 内数组里边 他没有一个数组的方法 filter

05:04.990 --> 05:11.030
就有的时候呢 我们需要把它转换成真正的数组 那怎么转换了啊 我们以前要这样子写对吧 呃

05:11.030 --> 05:14.630
array prototype 里边不是个stice吗

05:15.230 --> 05:15.510
哎

05:16.990 --> 05:19.230
呃 然后呢 调用什么 调用这个

05:19.830 --> 05:21.590
扣啊

05:22.190 --> 05:28.910
然后呢 把那个内数组传进去啊 就绑进Z 然后呢 后边的参数呢 传零对吧 我们传算零

05:29.430 --> 05:34.510
用这种方式呢 把它变成变成那个就是真正的数组啊 他反悔的就是个真正的数组

05:34.910 --> 05:37.670
那以前的那种方式呢 发现啊 es6 发现呢

05:38.390 --> 05:43.790
这种这种做法呢 太常见了 我还不如干脆给你搞一个API出来 于是呢 他做了这么一个API啊

05:43.830 --> 05:48.830
array from 你把内数组呢 放进去 他就可以直接给你返回一个真正的数组 那就非常方便了

05:49.350 --> 05:51.750
array from 啊 内数组放进去

05:54.430 --> 06:03.060
好 他就会给你一个新 给你一个真正的数组 好看一下吧 好 输出啊 result

06:04.260 --> 06:09.540
保存啊 你看一下这边 是不是得到一个真正的数组了 你看 他的元项因是array了 对吧

06:10.380 --> 06:17.340
这就是把内数组呢 转换成真正的数组 当然不仅是内数组啊 只要是可以叠在的对象 他都可以转换成

06:17.740 --> 06:23.500
一个新的数组 他说你给他内数组也可以 给他可叠带的对象也可以啊 他都会把它转换成数组

06:23.900 --> 06:29.300
如果你给他可叠带对象的话 就是一个一个叠带呗 把每一次叠带的结果放到数组里边

06:30.860 --> 06:31.540
好 下面呢

06:32.500 --> 06:37.940
这是两个静态方法啊 都是用来创建数组的 好 下面有些实力方法 咱们看一下啊 都非常简单

06:38.500 --> 06:44.500
第一个呢 就是fan的 用来查找满足条件的第一个元素 这个玩意儿蛮有用的 我觉得

06:45.540 --> 06:54.460
他们说以后我们在做一些功能的时候呢 这个方法蛮有用的 以前的我们得自己写啊 挺麻烦的 比方说啊 比方说

06:56.800 --> 07:04.160
我们这里呢 有一个数组啊 有一个数组 最常见的一个场景 给大家举个例子 这个数组里边呢 有一些对象

07:05.160 --> 07:13.840
啊 念维 a i d 为 i d 为一啊 就这样吧

07:15.200 --> 07:23.640
id 为都好 大家见 好 差不多了啊

07:25.240 --> 07:29.280
二三四五六七

07:30.280 --> 07:34.600
b c d e fg 好了啊

07:35.640 --> 07:41.840
我们这里有个对象的数组 里面每一个对象呢 有一个内容属性 有个id属性 我们很有可能会遇到这么一个需求

07:42.640 --> 07:49.800
什么需求呢 就是我要找到啊 我要找到id 为5的那个对象啊

07:50.480 --> 07:55.480
找到id 为5的对象 这是一个非常非常常见的一个查到功能

07:56.080 --> 08:03.000
以前我们得咋做呢 以前呢 我们怎么做 你只能去循环 对吧 循环 挨在这判断啊 挨在这判断

08:03.480 --> 08:07.880
但是现在呢 我们就可以使用他提供的fan的方法 专门来查找

08:08.600 --> 08:14.400
查找数组里边的元素的 使用这个方法 可以非常轻松的找到 那么这个方法怎么用呢

08:15.640 --> 08:17.640
就是数组里边一个实力方法啊fan的

08:18.560 --> 08:21.760
那这里边传上了 传的是一个回调函数

08:22.360 --> 08:26.680
这个回调函数你要告诉他 他会把数组的每一项拿出来 问你

08:27.080 --> 08:31.840
哎 我把数组的第一项拿出来 问你 这项满不满足要求 满足要求 ok 你就返回去

08:32.360 --> 08:37.560
那么不满足要求的 你就返回force 就是你这个这个回调函数呢 跟那个filter

08:38.040 --> 08:44.360
是非常类似的 就是说他会把每一项传给你 你只需要告诉他 这一项是不是满足要求就行了

08:44.800 --> 08:50.600
如果说这一项满足要求 比方说啊 他的id等于5 是不是满足要求 我就返回去

08:51.520 --> 08:57.080
啊 else呢 我就返回force 是吧 是不是跟那个filter是一样的道理

08:57.800 --> 09:01.840
filter他只是要把全部找出来 对吧 满足要求的全部找出来

09:02.160 --> 09:04.400
fan的呢 他只找满足要求的第一个

09:04.960 --> 09:07.520
明白了意思吗 他就这其实他跟filter没有什么区别

09:08.000 --> 09:13.520
filter是把满足要求的东西全部找出来 形成一个新的数组 而fan的只找一个

09:14.240 --> 09:19.880
以后呢 我们说如果说要找一堆东西的话 就用filter 要找其中一个的话 就用fan的

09:20.320 --> 09:24.920
就这么简单 所以他就会返回找到了那个东西 返回找到了东西

09:26.000 --> 09:26.480
readout

09:27.800 --> 09:34.000
好 那么当然这个单码呢 我们可以简写啊 比方说这个it数等于5 那么就直接把这个表达式返回就完事了 对吧

09:35.360 --> 09:38.000
啊 既然这样的话 只有一条语句 那么在

09:39.200 --> 09:47.560
箭头函数里面 一条语句是不是可以这样子写 对吧 找找什么呢 找某一项的id等于5的东西啊 那么咱看一下输出readout

09:50.060 --> 09:54.220
啊 这里运行啊 可控材

09:55.140 --> 10:00.180
啊 你看是不是找到了 他就把个对象找到了 对吧 这是用fan的方法啊fan的方法

10:00.780 --> 10:05.220
那如果说没有找到了 比方说这里写个实物 没有找到了 他找到了就是undefend

10:05.700 --> 10:06.500
啊 得到是undefend

10:07.300 --> 10:13.500
啊 他提供了这么一个方法 这个方法我觉得蛮好用的啊 以前的我得自己去封装一个函数 去找啊 简称 因为

10:13.860 --> 10:18.660
因为我们平时从服务器拿到数据过后呢 经常要对这个数据里面去找一些关键点

10:18.980 --> 10:23.780
关键的对象 我们要对他进行操作啊 所以说我们用fan的方法可以非常方便的找出来

10:24.500 --> 10:34.180
好 关于第一个啊fan的 第二个呢 很简单fan的index他也跟fan的作用是完全一样的 只不过他找的是啥呢 他找的是下标

10:35.300 --> 10:38.340
啊 他找的是下标 就找了他的 他在数据里边下标

10:40.020 --> 10:43.220
readout index啊 保证啊 看一下

10:45.060 --> 10:46.340
我这里用fan的index啊

10:47.060 --> 10:56.820
你看 他找的是数据下标 如果说没有找到的话 没有找到的话那个下标呢 就跟我们之前学的那个index不一样是负一 对吧

10:57.380 --> 11:06.580
他为什么要搞出一个fan的index呢 他我们之前不是有个index还有什么那是index对吧 他为什么还要搞出一个fan的index呢

11:07.700 --> 11:12.180
因为我们之前的那个index以及那是index

11:12.900 --> 11:18.500
他只是针对普通数据的 因为他这里边传的不是后不是那个回调函数

11:19.700 --> 11:22.740
你看吧 以前的index里边是不是要传一个

11:23.540 --> 11:29.460
传一个元数 对吧 他把这个元数呢拿去匹配 匹配数 跟数组里边进行匹配

11:29.940 --> 11:37.460
对吧 但是如果说这个数组里边每一个是个堆箱的话 就不好匹配了 因为对象的地址不一样 你不能说在这里购建一个堆箱出来

11:38.020 --> 11:41.380
id等于5 nem等于abcd1

11:41.940 --> 11:47.060
这样是查不到的 因为这是一个新的对象 他对象的地址跟这里边是完全不一样的 对吧

11:47.620 --> 11:54.980
所以说我们他缺少一个传入回调的这种灵活的查照方式 因此他可以做出一个fan的index

11:56.580 --> 11:57.780
好 下面这个feel

11:58.580 --> 12:03.300
这个挺有意思的 他做什么呢 他是用指定的数据把数组填充满

12:04.180 --> 12:04.580
啥意思

12:06.580 --> 12:15.750
今天我这个赏资不是很好啊 有点感冒 好看一下啊 这啥意思

12:17.350 --> 12:18.950
比方说啊 我们这里呢

12:20.230 --> 12:23.030
要购建一个啊 要创建一个

12:23.670 --> 12:29.990
创建一个长度为100的数组 数组的每一项

12:30.870 --> 12:31.190
是

12:32.150 --> 12:34.230
是什么abc

12:34.230 --> 12:36.230
比方说有这么一个需求

12:37.030 --> 12:39.830
创建一个长度为100的数组 数组的每一项是abc

12:39.830 --> 12:46.150
那么创建长度为100 我们是不是就进行循环 或者是我们一开始来创建一个数组啊 六一个array

12:46.470 --> 12:47.990
对吧 指定长度为100

12:48.790 --> 12:54.470
啊 我们以后呢 用构造函数的时候呢 就尽量只传一个数据啊 表示我这是一个长度

12:54.710 --> 12:58.230
如果说你要直接传数组箱的话 你应该用array

12:59.110 --> 13:04.710
好 那么这里呢 我们创建好一个数组 那么这是数组里面有东西吗 没有东西 我要跟他每一项填充abc

13:04.790 --> 13:07.110
是不是要在循环 然后每一项去复制

13:07.510 --> 13:12.630
但是现在不用了 现在呢 多了这么一个方法叫feal啊 可以直接填充

13:13.430 --> 13:15.830
feal abc 完了

13:16.790 --> 13:22.310
这句话的意思就是 将数组的每一项填充为指定的值啊 就没了 我看一下了

13:24.920 --> 13:25.480
啊 看一下啊

13:26.440 --> 13:27.640
这里呢arr

13:29.400 --> 13:36.440
啊 你看 这边得到一个长度为100的数组 没像是abc 就这么简单啊 没有什么别的了啊 就这么简单啊 这是feal

13:38.360 --> 13:42.040
好 下面呢 这个呢 叫做copyweasin copyweasin

13:42.680 --> 13:47.400
嗯 这个函数呢 是用于在数组内部完成复制的

13:48.040 --> 13:54.680
嗯 用文字的话 不是很好说清楚啊 它有三个参数 后边两个参数呢 是可传递可不传递的啊

13:54.840 --> 13:59.880
还有默认值 然后大家说一下这个这个函数干嘛用的啊 还用的比较奇葩

14:00.680 --> 14:09.590
平时呢 我们可能用了用这个函数的用的不是那么多啊 我们看一下吧 我们比方说我这里有个数组

14:11.190 --> 14:14.230
嗯 比方说啊123456

14:15.350 --> 14:19.430
有这么数 呃 这些数据 现在呢 我打算做这么一件事

14:20.070 --> 14:24.550
仔细看啊 我打算呢 把数组的从

14:25.190 --> 14:30.790
开始复制啊 从这个位置 从4这个位置 改从这个位置开始来改动后边的数据

14:31.430 --> 14:35.110
啊 从这个位置开始 这个位置是啥 下标尾3啊

14:36.630 --> 14:40.710
从下标3开始啊 改变

14:41.670 --> 14:44.310
数组数组的数据

14:45.270 --> 14:49.750
数据来自于哪呢 数据来自于

14:51.430 --> 14:55.190
下标0位置开始 这啥意思

14:56.710 --> 15:00.710
这啥意思呢 这个地方我们是下标3对吧 下标尾3

15:01.110 --> 15:07.270
那么这个数据要改数据 怎么改呢 我就把这个数据改成从0开始的数据 从0开始复制

15:07.590 --> 15:09.430
把0的位置呢放到这

15:10.390 --> 15:13.110
然后呢 把1的位置呢放到这 就开始复制了

15:13.750 --> 15:19.350
把2的位置呢放到这 然后边到那数捉为了 又不多了 不做了 明白的意思吗

15:20.070 --> 15:25.270
然后是这么一回事啊 我再看 再来一遍啊 再比方说从下标2开始来复制数据

15:25.750 --> 15:30.070
就内部复制 就是从这个位置开始来复制数据 怎么复制呢

15:30.630 --> 15:37.990
我们就从0开始复制啊 就那么就是把这里改成1 这里改成2 这里改成3 这里改成4

15:38.470 --> 15:41.830
对吧 所以完成完成这么一种非常奇葩的需求

15:42.310 --> 15:48.870
那么如果说有这么一种奇葩的需求的话 你就非常合适的可以使用cop in cop within

15:50.390 --> 15:56.310
这个方法就专门来做这个事了 就完成内部复制 那么它第一个参数传什么呢 传的就是从下标几开始复制

15:56.870 --> 16:00.790
从下标几开始改变数据 那么比方说我们传一个2 大家看一下吧

16:01.750 --> 16:09.190
然后我们再输出lr啊 注意这个方法返回的就是还是lr本身啊 返回的还是lr本身啊 看一下吧

16:13.110 --> 16:19.110
抓心 你看它变 它一开始是什么123456 对吧 最终变成了什么121234

16:20.070 --> 16:23.590
它最终变成了这个 对比一下吧

16:24.710 --> 16:26.790
能看懂什么意思吗 从这个位置开始

16:27.750 --> 16:32.710
复制 就是就是改变数据 一直改变到莫为 对吧 一直改变到莫为

16:33.910 --> 16:40.230
好 就这个 那么它还有两个参数 那两个参数干嘛的呢 再看下一个

16:42.070 --> 16:46.070
copy within 第一个参数呢 我们还是从2开始

16:46.710 --> 16:54.470
但是第二个参数呢 我给它传递一个值 第二个参数表示什么意思呢 表示我复制的时候从第几位开始复制

16:54.790 --> 17:01.110
那么默认情况下呢 没有传递的话 它是从零位置开始复制的 那比方说我这里传了一个

17:02.070 --> 17:02.310
一

17:03.510 --> 17:06.870
那么这个东西是什么意思呢 这个东西就很糟啊

17:07.590 --> 17:11.990
什么意思呢 它就是说从下标为二的位置开始复制 从这里开始改变数据

17:12.630 --> 17:17.910
从哪里从哪里把数据从来自于哪呢 数据来自于下标一的数据开始

17:18.390 --> 17:24.390
那么下标一是不是从这里的 对吧 那么这里改成啥 就是二三四五

17:25.270 --> 17:31.670
没有意思吧 它有这么一个意思啊 那么我们看一下 得到结果就是12235

17:32.630 --> 17:38.790
12235 是这么个意思啊 第二个参数的指的是 你要从哪个位置开始复制数据

17:40.870 --> 17:45.350
好 再来啊 还有第三个参数 第三个参数呢

17:45.910 --> 17:51.910
表示的是在哪个位置复制停止 停止 比方说我们这里写个三

17:52.870 --> 17:54.070
这又是啥意思呢

17:54.950 --> 18:00.310
你看着啊 这个意思就是我从下标为二的地方 从这里开始改数据了

18:00.710 --> 18:03.990
那数据来自于哪呢 来自于下标一

18:05.430 --> 18:06.790
到下标三

18:07.670 --> 18:09.350
也就是数据我们只取这一段

18:09.750 --> 18:11.430
二三四啊 只取这一段

18:11.910 --> 18:15.110
把这一段数据从从下标为二的位置开始复制

18:15.750 --> 18:19.190
下标为二是在这 那么这里变成二三四

18:20.150 --> 18:22.550
那么后维不动了 复制完了

18:23.270 --> 18:26.070
是这么个意思啊 得到结果是122 36

18:28.550 --> 18:29.430
122

18:30.790 --> 18:35.830
哦 他三是取不到的啊 三是取不到的 他那么就是从一到二的

18:35.830 --> 18:39.270
下标为一开始取不到三啊 取不到三 最大下标取不到

18:39.830 --> 18:41.910
那么是从一到二

18:44.390 --> 18:48.710
我要从哪里改数据呢 从这里改数据 对吧 下标为二的地方开始改数据

18:48.870 --> 18:54.070
改数据呢 我的数据来自于哪呢 来自于下标为一到下标为二

18:54.070 --> 18:57.030
因为三取不到 那么下标为二对吧 来自于这一部分

18:57.270 --> 19:00.790
那么我们把二和三放到哪呢 放到从这个位置开始改

19:01.110 --> 19:04.710
二和三变成这个样子 123 56

19:05.350 --> 19:07.190
就这么个意思啊 copy ways

19:08.230 --> 19:10.790
默认情况下呢 最后一个参数呢 就是整个数组长度

19:10.790 --> 19:12.070
他就把整个数组复制过来

19:12.950 --> 19:14.470
就是关于这个 copy ways

19:15.590 --> 19:17.590
非常怪怪的方法

19:18.310 --> 19:21.830
这就是这个 es6 里面给数组里面新增了一些 API

19:22.150 --> 19:23.830
那么最后还有一个就是 includes

19:23.830 --> 19:27.590
includes 呢 这个函数呢 这个方法呢 它不是 es6 的

19:27.910 --> 19:31.110
它是 es7 里面那种啊 如果呢 我觉得也挺好用的

19:31.110 --> 19:32.470
所以我拿出来说一说

19:33.990 --> 19:37.670
那么以前呢 我们要判断一个东西在数组里面存不存在

19:37.670 --> 19:38.870
我们是用什么来判断的

19:40.150 --> 19:41.510
诶 我们用怎么来判断的

19:41.910 --> 19:44.310
是不是我们要用那个 int 的时候 对吧

19:44.630 --> 19:47.750
int 这个时候什么意思呢 指的是满足条件啊

19:47.750 --> 19:50.870
就是跟这个数组相匹配的下标 对吧

19:51.110 --> 19:52.310
找不到的话就是负一

19:52.790 --> 19:55.110
那么这个从语异上来说的话

19:55.350 --> 19:57.670
它不像是一个 呃

19:58.550 --> 20:00.710
存不存在 从于语异上不好阅读

20:00.710 --> 20:02.630
比方说举个例子啊 举个例子

20:03.350 --> 20:05.990
嗯 我们看一下 这里一个数组

20:07.670 --> 20:09.190
随便写写吧 随便写写

20:11.290 --> 20:13.290
好 我要判断的就是

20:13.530 --> 20:15.530
66

20:15.930 --> 20:17.450
在这个数组里面存不存在

20:18.010 --> 20:20.010
我就输出 to 和 force 就行了

20:20.410 --> 20:21.450
存在就为 to

20:22.010 --> 20:23.290
不存在呢 就为 force

20:23.690 --> 20:26.330
以前呢 我们怎么写呢 以前是不是要这样子写

20:26.730 --> 20:28.890
ar int 这个时候

20:29.530 --> 20:30.650
啊 然后呢 什么

20:31.210 --> 20:32.730
66 对吧 传进去

20:33.130 --> 20:34.570
好 传进去之后呢

20:34.810 --> 20:36.890
判断一下 它存不存在怎么判断呢

20:36.890 --> 20:38.330
是不是还要跟一个东西比较

20:38.890 --> 20:41.690
如果说大于等于0 是不是存在的

20:42.410 --> 20:43.770
小于0 是不是不存在的

20:45.370 --> 20:46.810
没问题吧 这是以前的方式

20:47.050 --> 20:49.050
这个以前的方式呢 就不是很好阅读

20:49.210 --> 20:51.290
因为我们要判断它是不是存在

20:51.290 --> 20:52.650
我拿到它下标干嘛呢

20:53.050 --> 20:55.770
对吧 是两个意思 对吧 拿到下标跟它存不存在

20:55.770 --> 20:56.650
是两个意识

20:56.970 --> 20:58.810
结果这两个意识呢 还有些观念

20:59.050 --> 21:01.530
但是呢 从代码的阅读上来说 不是那么好阅读

21:01.850 --> 21:04.410
于是呢 耶税期呢 稍微的感进了一下啊

21:04.570 --> 21:06.570
给你做出来这么一个函数 叫做 Includes

21:07.050 --> 21:09.450
比较 Includes 这么意思 适逢包含的意思

21:09.930 --> 21:12.730
你把数据传进去 它就会帮你判断适逢包含

21:13.050 --> 21:15.130
因此呢 以这里现在我们会怎么做呢

21:15.130 --> 21:17.050
现在我们会这样子写 Includes

21:18.090 --> 21:19.130
66 完了

21:19.770 --> 21:21.850
这样子写的话 是不是更加好阅读一点

21:21.850 --> 21:24.810
输出什么 输出输出 输出里面适逢包含66

21:25.370 --> 21:26.330
你看上面这个阅读

21:26.650 --> 21:29.450
输出里面66的下标 是不是大于等于0

21:30.090 --> 21:32.490
是不是要绕一圈啊 那下面这个是不是更加好阅读

21:33.050 --> 21:33.770
就这么个意思

21:35.450 --> 21:37.450
好看一下啊 结果的话都是一样的

21:37.770 --> 21:38.730
结果都是一样的

21:40.330 --> 21:42.490
而且大家注意一下 Includes 它的比较

21:42.490 --> 21:44.890
它内部的比较是用 object 是意思来比较的

21:45.770 --> 21:48.570
也就是说这个数据里面 如果说存在 NAN

21:49.130 --> 21:52.090
那么你这里呢 判断NAN 再不在数据里面

21:52.250 --> 21:54.490
保存啊 你发现是 true 对吧

21:54.490 --> 21:55.770
在的 对吧 是不是在的

21:56.490 --> 21:57.770
NAN 是在数据里面

21:58.250 --> 22:00.090
因为它是用 object 是意思来比较的

22:00.890 --> 22:02.250
好 这是关于这一块

22:02.890 --> 22:04.970
这是新增的数据 APN 其他也没啥了

22:05.370 --> 22:06.250
好吧 这就说

