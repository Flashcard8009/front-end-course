WEBVTT

00:00.050 --> 00:02.450
这些可能我们来实现这个认函数

00:02.450 --> 00:05.050
当然我们一节课实现不了这个认函数

00:05.050 --> 00:07.050
因为这个认函数还是比较复杂的

00:07.050 --> 00:10.050
我们先把这个认函数的大概的价值给它打起来

00:10.050 --> 00:12.550
我们在这里去写这么一个认函数

00:12.550 --> 00:14.550
当我们去写任何一个函数的时候

00:14.550 --> 00:16.050
一定要去思考这么几个东西

00:16.050 --> 00:18.550
第一个它有什么样的参数传入

00:18.550 --> 00:20.550
第二个有什么样的返回值

00:20.550 --> 00:23.050
那我们要完全思考这个问题的话

00:23.050 --> 00:25.050
我们就可以写一个Promise

00:25.050 --> 00:27.050
我们来看一下Promise的认函数

00:27.050 --> 00:28.050
它应该返回什么

00:28.050 --> 00:31.050
应该传入什么

00:31.050 --> 00:33.050
然后我们这里随便写Promise

00:33.050 --> 00:35.050
Promise我们不是一个认函函数

00:35.050 --> 00:38.050
这个认函数实际上有几个函数

00:38.050 --> 00:40.050
我们讲过了有两个函数

00:40.050 --> 00:42.050
比方说这里

00:42.050 --> 00:44.050
这是一个函数

00:44.050 --> 00:45.050
然后Ridder

00:45.050 --> 00:47.050
这是一个函数

00:47.050 --> 00:50.050
那么我们可以看到这里非常明显的有两个函数

00:50.050 --> 00:53.050
第一个函数传入是一个函数

00:53.050 --> 00:55.050
表示成功之后要做的事

00:55.050 --> 00:57.050
第二个函数也是一个函数

00:57.050 --> 00:59.050
表示失败之后要做的事

00:59.050 --> 01:00.050
所以有两个函数

01:00.050 --> 01:01.050
因为它说闹有的时候

01:01.050 --> 01:03.050
我们只可以只传一个

01:03.050 --> 01:04.050
其实传一个的时候

01:04.050 --> 01:05.050
你可以想象成为

01:05.050 --> 01:06.050
表示的是

01:06.050 --> 01:08.050
第二个函数传的是OnDefend

01:08.050 --> 01:09.050
对不对

01:09.050 --> 01:10.050
因此它会有两个函数传入

01:10.050 --> 01:11.050
这是第一个

01:11.050 --> 01:12.050
所以说我们这里

01:12.050 --> 01:13.050
去写几个函数

01:13.050 --> 01:14.050
请两个

01:14.050 --> 01:15.050
一个是叫OnFulfilled

01:15.050 --> 01:17.050
一个是OnRidgetT

01:17.050 --> 01:18.050
这个表示什么意思

01:18.050 --> 01:20.050
成功之后的掉落的函数

01:20.050 --> 01:21.050
我们来记录一下

01:21.050 --> 01:23.050
这个是方个性

01:23.050 --> 01:25.050
这边也是方个性

01:26.050 --> 01:32.050
这是PromiseA加规范的认函数

01:32.050 --> 01:33.050
PromiseA加规范

01:33.050 --> 01:35.050
它对认函数有非常非常详细的规定

01:35.050 --> 01:37.050
它有什么样的参数传入

01:37.050 --> 01:38.050
然后有反回什么

01:38.050 --> 01:40.050
它就非常非常详细的规定

01:40.050 --> 01:41.050
这里我们把参数写出来了

01:41.050 --> 01:42.050
稍等一下

01:42.050 --> 01:43.050
我关一下门

01:48.060 --> 01:50.060
这里我们把参数传出来了

01:50.060 --> 01:51.060
这里有两个参数

01:51.060 --> 01:52.060
它反回什么呢

01:52.060 --> 01:53.060
它反回啥呀

01:53.060 --> 01:55.060
我们看到这个认函数反回的是什么

01:55.060 --> 01:56.060
这是一个新的Promise

01:57.060 --> 01:58.060
而且它不用特殊情况

01:58.060 --> 02:00.060
它一定反回新的Promise

02:00.060 --> 02:01.060
所以说我们这里想都不用想

02:01.060 --> 02:03.060
直接刚刚反回一个New

02:04.060 --> 02:05.060
New一个新的Promise

02:05.060 --> 02:07.060
所以Promise用我们自己这个

02:07.060 --> 02:08.060
因为我们是自己手写

02:08.060 --> 02:10.060
NewPromise

02:10.060 --> 02:11.060
一个新的Promise

02:11.060 --> 02:13.060
那么新的Promise里面

02:13.060 --> 02:15.060
是不是要传入一个参数

02:15.060 --> 02:16.060
是不是要传入一个函数

02:16.060 --> 02:18.060
ResultRidgetT

02:19.060 --> 02:20.060
这个我们实现吗

02:20.060 --> 02:21.060
实现了

02:21.060 --> 02:22.060
我们的构造函数

02:22.060 --> 02:23.060
也不就是一个Excutor吗

02:23.060 --> 02:25.060
这个玩意不就是一个Excutor吗

02:25.060 --> 02:27.060
对 这有链项地归

02:27.060 --> 02:29.060
好 那么我们把个价值

02:29.060 --> 02:31.060
就基本上写出来了

02:31.060 --> 02:33.060
OK 那接下来我们要想的是

02:33.060 --> 02:35.060
一个比较深层次的问题

02:35.060 --> 02:37.060
就是这个认函数

02:37.060 --> 02:39.060
它到底要做啥

02:39.060 --> 02:41.060
认函数要做什么呢

02:41.060 --> 02:43.060
认函数我们再详细的描述一下

02:43.060 --> 02:46.060
当你成功之后

02:46.060 --> 02:48.060
我做这件事

02:48.060 --> 02:50.060
当你失败之后

02:50.060 --> 02:51.060
我做这件事

02:51.060 --> 02:52.060
是马上做吗

02:52.060 --> 02:54.060
那不一定

02:54.060 --> 02:55.060
但是我们知道

02:55.060 --> 02:57.060
这是表示的是

02:57.060 --> 02:59.060
註册一个成功的归掉函数

02:59.060 --> 03:01.060
註册一个失败的归掉函数

03:01.060 --> 03:03.060
因此它这些事情

03:03.060 --> 03:04.060
并不是马上做的

03:04.060 --> 03:05.060
这是第一个点

03:05.060 --> 03:06.060
这个点

03:06.060 --> 03:08.060
我们这里可能先不着急去处理它

03:08.060 --> 03:10.060
因为这个点确实比较复杂

03:10.060 --> 03:11.060
第二个点

03:11.060 --> 03:12.060
是我们知道

03:12.060 --> 03:13.060
任函数

03:13.060 --> 03:16.060
就算它马上要去执行这个函数

03:16.060 --> 03:17.060
是不是一定要

03:17.060 --> 03:19.060
不会把它放到微对列里面

03:19.060 --> 03:20.060
它会把函数

03:20.060 --> 03:21.060
不会立即执行

03:21.060 --> 03:23.060
把它放到微对列里面执行

03:24.060 --> 03:25.060
那么这件事

03:25.060 --> 03:27.060
我们这里可要把它完成

03:27.060 --> 03:29.060
那如何来产生一个微对列呢

03:29.060 --> 03:31.060
我们知道Promise这一块

03:31.060 --> 03:32.060
Promise

03:32.060 --> 03:34.060
我们知道Promise的任

03:35.060 --> 03:36.060
有一个Promise

03:36.060 --> 03:37.060
后面那个任方法

03:37.060 --> 03:38.060
它会产

03:38.060 --> 03:41.060
这里边的函数会放到微对列里面

03:41.060 --> 03:43.060
那么我现在不能用Promise

03:43.060 --> 03:45.060
因为我们现在要熟悉

03:45.060 --> 03:47.060
那如何来产生一个微对列呢

03:47.060 --> 03:48.060
问题是

03:48.060 --> 03:49.060
这里呢

03:49.060 --> 03:52.060
已经超过了同学们的支持范围了

03:53.060 --> 03:54.060
我这里呢

03:54.060 --> 03:55.060
给大家写一个

03:55.060 --> 03:57.060
然后慢慢给你们讲

03:57.060 --> 04:00.060
我现在需要写一个辅助函数的方式

04:00.060 --> 04:05.060
叫MicroRawMicroTask

04:05.060 --> 04:08.060
运行一个微对列任务

04:08.060 --> 04:10.060
你给我传一个函数进来

04:10.060 --> 04:11.060
这是一个辅助

04:11.060 --> 04:13.060
这是一个工具函数

04:15.060 --> 04:16.060
好 扔的东西呢

04:16.060 --> 04:18.060
我们先放这儿

04:18.060 --> 04:20.060
我们之后还要进行详细的处理

04:20.060 --> 04:22.060
这里是一个函数

04:22.060 --> 04:28.820
比方说运行一个微对列任务

04:28.820 --> 04:29.820
或者说呢

04:29.820 --> 04:34.820
把传递的函数放到微对列中

04:34.820 --> 04:36.820
就做这么一件事

04:36.820 --> 04:38.820
你给我传一个函数进来

04:38.820 --> 04:40.820
然后我把这个函数放到微对列里面

04:40.820 --> 04:41.820
我们先把这个功能实现

04:41.820 --> 04:43.820
因为这个功能我们肯定是要用到的

04:43.820 --> 04:44.820
对吧

04:44.820 --> 04:46.820
虽然我们这节可能暂时用不到

04:46.820 --> 04:48.820
因为我还要详细的去分析这个Z

04:48.820 --> 04:50.820
但是这个功能肯定是有的

04:50.820 --> 04:51.820
我们先把它写出来

04:51.820 --> 04:53.820
先把这些细致默契的东西写出来

04:53.820 --> 04:55.820
那么这里的写法呢

04:55.820 --> 04:57.820
其实你在面试零的时候

04:57.820 --> 05:00.820
你可以把它写得特别的粗糙

05:00.820 --> 05:01.820
也没问题

05:01.820 --> 05:03.820
因为这不是Promise的核心

05:03.820 --> 05:04.820
你可以怎么写呢

05:04.820 --> 05:05.820
非常简单

05:05.820 --> 05:07.820
你又写个Z time out

05:07.820 --> 05:10.820
然后把个callback放进去

05:10.820 --> 05:11.820
0秒后执行这个

05:11.820 --> 05:13.820
那这个是不是微对列

05:13.820 --> 05:14.820
那不是

05:14.820 --> 05:15.820
不是微对列

05:15.820 --> 05:16.820
但是我们用这个东西

05:16.820 --> 05:18.820
在模拟一个异部制修

05:18.820 --> 05:19.820
这可不可以呢

05:19.820 --> 05:21.820
当然是可以的

05:21.820 --> 05:23.820
其实也不会扣分

05:23.820 --> 05:24.820
但是这一块要加分

05:24.820 --> 05:25.820
那是不可能的

05:25.820 --> 05:26.820
它不会扣分

05:26.820 --> 05:27.820
因为它知道这一块

05:27.820 --> 05:29.820
并不是Promise的核心

05:29.820 --> 05:30.820
好吧

05:30.820 --> 05:31.820
这是这个点给他说一下

05:31.820 --> 05:32.820
你可以简单地写

05:32.820 --> 05:34.820
但是那作为我们教程的话

05:34.820 --> 05:35.820
我肯定还是要尽量

05:35.820 --> 05:37.820
把它实现得完善一点

05:37.820 --> 05:40.820
那我这一块怎么去实现呢

05:40.820 --> 05:43.820
我这里呢需要区分两个环境

05:43.820 --> 05:44.820
一个是漏的环境

05:44.820 --> 05:46.820
因为我们Promise这个东西

05:46.820 --> 05:48.820
它是ES6的官方标准

05:48.820 --> 05:50.820
所以说它在各种环境里面

05:50.820 --> 05:51.820
都论支持

05:51.820 --> 05:52.820
漏的环境里面支持

05:52.820 --> 05:54.820
浏览器环境里面也支持

05:54.820 --> 05:56.820
好我们首先来搞定漏的环境

05:56.820 --> 05:58.820
判断漏的环境

05:58.820 --> 06:03.710
漏的环境里面有一个对象

06:03.710 --> 06:05.710
叫做Process

06:05.710 --> 06:07.710
浏览器里面没有的

06:07.710 --> 06:09.710
漏的环境里面有这个对象

06:09.710 --> 06:10.710
并且呢这个对象呢

06:10.710 --> 06:12.710
还有一个属性

06:12.710 --> 06:15.710
叫做Next Take

06:15.710 --> 06:18.730
有这么一个东西

06:18.730 --> 06:19.730
这个东西呢

06:19.730 --> 06:21.730
就是漏的环境里面

06:22.730 --> 06:24.730
好咱们来马上试一下

06:24.730 --> 06:25.730
比方说我们在这里呢

06:25.730 --> 06:26.730
去新开一个

06:26.730 --> 06:27.730
1.ES

06:27.730 --> 06:28.730
我们去比方现在就

06:28.730 --> 06:29.730
都等环境对吧

06:29.730 --> 06:30.730
Process

06:30.730 --> 06:31.730
Next

06:33.730 --> 06:34.730
Next Take

06:34.730 --> 06:35.730
这边传一个函数进来

06:35.730 --> 06:40.000
我们这里输出一个1

06:40.000 --> 06:41.000
123

06:41.000 --> 06:42.000
然后上边呢

06:42.000 --> 06:44.000
我们再输出一个Set Timeout

06:44.000 --> 06:46.000
传一个函数

06:46.000 --> 06:47.000
输出一个1

06:47.000 --> 06:48.000
这里输出一个2

06:48.000 --> 06:52.000
然后Set Timeout是0

06:52.000 --> 06:53.000
以后里面

06:53.000 --> 06:54.000
学习漏的里面就非常清楚了

06:54.000 --> 06:56.000
这里输出一个3

06:56.000 --> 06:58.000
那么这个输出顺序呢

06:58.000 --> 06:59.000
肯定是安全输出对吧

06:59.000 --> 07:00.000
这个毫无疑问的

07:00.000 --> 07:01.000
那么1到底先输出

07:01.000 --> 07:02.000
还是二先输出呢

07:02.000 --> 07:03.000
因为它是放到

07:03.000 --> 07:04.000
微对地里面这个东西

07:04.000 --> 07:05.000
所以说它先输出

07:05.000 --> 07:06.000
再输出1

07:06.000 --> 07:08.000
好咱们来运行看一下

07:08.000 --> 07:09.000
3

07:09.000 --> 07:10.000
2

07:10.000 --> 07:11.000
1

07:11.000 --> 07:12.000
所以在漏的环境里面

07:12.000 --> 07:13.000
特别简单

07:13.000 --> 07:14.000
我用它就可以

07:14.000 --> 07:15.000
实现一个微对地

07:15.000 --> 07:16.000
反正我不能用Process

07:16.000 --> 07:17.000
好 OK

07:17.000 --> 07:18.000
那么在漏的环境里面

07:18.000 --> 07:19.000
我发现它有Process

07:19.000 --> 07:20.000
一个对象

07:20.000 --> 07:21.000
而且一个对象里面

07:21.000 --> 07:22.000
有个Next Take

07:23.000 --> 07:24.000
OK

07:24.000 --> 07:25.000
那我就可以怎么样了

07:25.000 --> 07:26.000
我就可以Process

07:26.000 --> 07:27.000
Next Take

07:27.000 --> 07:28.000
我把这个函数就放到

07:28.000 --> 07:29.000
是不是可以放到

07:29.000 --> 07:30.000
微对地里面了

07:30.000 --> 07:31.000
对吧

07:31.000 --> 07:32.000
你看这个Pro

07:32.000 --> 07:33.000
Next Take

07:33.000 --> 07:34.000
他就是做这个事的

07:34.000 --> 07:35.000
他把这个函数

07:35.000 --> 07:36.000
放到微对地里面

07:36.000 --> 07:37.000
马上执行

07:37.000 --> 07:38.000
这是漏的环境

07:38.000 --> 07:39.000
那么浏览器环境

07:39.000 --> 07:40.000
如何来实现微对地呢

07:40.000 --> 07:41.000
浏览器环境呢

07:41.000 --> 07:42.000
我要给他说一下

07:42.000 --> 07:43.000
写个页面

07:45.000 --> 07:46.000
浏览器环境里面

07:46.000 --> 07:47.000
有一个对象

07:47.000 --> 07:51.140
叫做Taking Observer

07:51.140 --> 07:52.140
这个对象我也很少用

07:52.140 --> 07:53.140
它的API我经常都要忘

07:53.140 --> 07:55.140
所以说我经常都会查那个

07:55.140 --> 07:56.140
查那个MDN

07:56.140 --> 07:59.140
叫做Motation Observer

07:59.140 --> 08:01.140
它是一个构造函数

08:01.140 --> 08:06.890
有一个Motation Observer

08:06.890 --> 08:07.890
那么这里边

08:07.890 --> 08:08.890
会传递一个函数进去

08:08.890 --> 08:09.890
这个函数呢

08:09.890 --> 08:11.890
就是放到微对地里面执行的

08:11.890 --> 08:14.890
我们这里输出一个变化

08:15.890 --> 08:17.890
那么这个Motation Observer

08:17.890 --> 08:18.890
是什么意思呢

08:18.890 --> 08:20.890
它表示的是一个观察器

08:20.890 --> 08:21.890
它可以观察

08:21.890 --> 08:22.890
一些元素的变化

08:22.890 --> 08:24.890
只要元素一变化

08:24.890 --> 08:25.890
它就会执行这个函数

08:25.890 --> 08:27.890
但是执行的时候

08:27.890 --> 08:28.890
它是先把这个函数

08:28.890 --> 08:29.890
放到微对地里面执行

08:29.890 --> 08:30.890
它就处这么个重点

08:30.890 --> 08:31.890
平时我们开发

08:31.890 --> 08:32.890
没有什么用啊

08:32.890 --> 08:33.890
这个玩意儿

08:33.890 --> 08:34.890
而且有些流量器

08:34.890 --> 08:35.890
它都不支持

08:35.890 --> 08:36.890
那么这个东西

08:36.890 --> 08:37.890
它就可以实现这个

08:37.890 --> 08:38.890
那如何来观察

08:38.890 --> 08:39.890
一个元素的变化呢

08:39.890 --> 08:40.890
比方说我这里

08:40.890 --> 08:41.890
去创建一个元素

08:41.890 --> 08:42.890
当然也可以

08:42.890 --> 08:43.890
从页面上获取一个元素

08:43.890 --> 08:44.890
都无所谓

08:44.890 --> 08:45.890
创建一个元素

08:45.890 --> 08:46.890
然后呢

08:46.890 --> 08:48.890
我们用这个Observer

08:48.890 --> 08:49.890
去观察它

08:49.890 --> 08:51.890
它有一个方法叫Observer

08:51.890 --> 08:52.890
观察这个元素

08:52.890 --> 08:53.890
你看

08:53.890 --> 08:54.890
这个参数传于元素

08:54.890 --> 08:55.890
然后第二个参数呢

08:55.890 --> 08:56.890
你要告诉它

08:56.890 --> 08:57.890
观察什么

08:57.890 --> 08:58.890
因为元素里面有属性

08:58.890 --> 09:00.890
有什么里面的节点

09:00.890 --> 09:01.890
对吧

09:01.890 --> 09:02.890
那我这里观察什么呢

09:02.890 --> 09:04.890
观察它的Channel List

09:04.890 --> 09:05.890
表示什么

09:05.890 --> 09:07.890
表示观察

09:07.890 --> 09:09.890
该元素

09:09.890 --> 09:11.890
内部的变化

09:11.890 --> 09:12.890
只要内部有东西变了

09:12.890 --> 09:14.890
那么它就会

09:14.890 --> 09:15.890
观察器就会知道

09:15.890 --> 09:16.890
它知道之后

09:16.890 --> 09:17.890
它就会运行这个函数

09:17.890 --> 09:18.890
但是运行的时候

09:18.890 --> 09:19.890
一定要注意

09:19.890 --> 09:20.890
它是放到微对地里面执行的

09:20.890 --> 09:21.890
好比方说

09:21.890 --> 09:22.890
我们现在那去

09:22.890 --> 09:23.890
把这个P点

09:23.890 --> 09:24.890
Inner Atmel

09:24.890 --> 09:25.890
改了

09:25.890 --> 09:26.890
随便改吧

09:26.890 --> 09:27.890
改成一个E

09:27.890 --> 09:28.890
它一开始啥都没有

09:28.890 --> 09:29.890
改一个东西

09:29.890 --> 09:30.890
加一个东西

09:30.890 --> 09:31.890
那么这个元素

09:31.890 --> 09:32.890
是不是里边变了

09:32.890 --> 09:33.890
Channel List

09:33.890 --> 09:34.890
是不是变了

09:34.890 --> 09:35.890
Channel List变了之后

09:35.890 --> 09:36.890
它就会执行这个函数

09:36.890 --> 09:37.890
那么这个函数

09:37.890 --> 09:38.890
它是放到微对地里面执行的

09:38.890 --> 09:39.890
比方说我们这里

09:39.890 --> 09:40.890
输出一个E

09:40.890 --> 09:41.890
然后呢

09:41.890 --> 09:42.890
在上面

09:42.890 --> 09:43.890
再输出一个Set Time Out

09:43.890 --> 09:45.890
然后在这里输出

09:45.890 --> 09:48.890
这里输出一个

09:48.890 --> 09:49.890
这里输出E吧

09:49.890 --> 09:51.890
这里输出2

09:52.890 --> 09:53.890
然后呢

09:53.890 --> 09:54.890
我们在这里

09:54.890 --> 09:55.890
就这样吧

09:55.890 --> 09:56.890
好

09:56.890 --> 09:59.840
我们在浏览器里面看一下

09:59.840 --> 10:00.840
浏览器

10:00.840 --> 10:01.840
你看

10:01.840 --> 10:02.840
输出的结果是什么

10:02.840 --> 10:03.840
2变化了

10:03.840 --> 10:04.840
1

10:04.840 --> 10:05.840
什么意思

10:05.840 --> 10:06.840
2是不同步代吗

10:06.840 --> 10:07.840
马上执行的

10:07.840 --> 10:08.840
执行到过后

10:08.840 --> 10:10.840
本来它先到红对地

10:10.840 --> 10:11.840
对吧

10:11.840 --> 10:12.840
但是呢

10:12.840 --> 10:13.840
后来它又到微对地了

10:13.840 --> 10:14.840
那么就是

10:14.840 --> 10:15.840
红对地里面

10:15.840 --> 10:16.840
和微对地里面

10:16.840 --> 10:17.840
什么都有

10:17.840 --> 10:18.840
它在红对地

10:18.840 --> 10:19.840
它在微对地

10:19.840 --> 10:20.840
那么肯定是微对地先执行

10:20.840 --> 10:21.840
哪怕它先到红对地

10:21.840 --> 10:22.840
它后到微对地

10:22.840 --> 10:24.840
一看执行这个的时候

10:24.840 --> 10:25.840
是不是马上就到红对地了

10:25.840 --> 10:26.840
对吧

10:26.840 --> 10:27.840
它没有等待时间嘛

10:27.840 --> 10:28.840
对不对

10:28.840 --> 10:29.840
好然后呢执行完2

10:29.840 --> 10:30.840
执行完4

10:30.840 --> 10:31.840
硬到AT表

10:31.840 --> 10:32.840
把这个设置了之后

10:32.840 --> 10:34.840
这个是不是马上就到微对地了

10:34.840 --> 10:35.840
然后再输出2

10:35.840 --> 10:36.840
输出2之后

10:36.840 --> 10:37.840
先执行微对地

10:37.840 --> 10:38.840
所以执行它

10:38.840 --> 10:39.840
然后再执行它

10:39.840 --> 10:40.840
因此就看到了2变化了

10:40.840 --> 10:41.840
1

10:41.840 --> 10:42.840
我们就可以利用

10:42.840 --> 10:44.840
它来模拟微对地

10:44.840 --> 10:45.840
我们把这个地方删掉

10:45.840 --> 10:46.840
OK

10:46.840 --> 10:47.840
我就用这个代码

10:47.840 --> 10:48.840
给它copy过去

10:49.840 --> 10:50.840
到这边来

10:50.840 --> 10:51.840
我们判断什么的

10:51.840 --> 10:52.840
判断

10:52.840 --> 10:54.840
浏览器首先支不支出

10:54.840 --> 10:55.840
Motation of Zover

10:55.840 --> 10:56.840
有没有这个东西

10:56.840 --> 10:57.840
如果说有的话

10:57.840 --> 10:58.840
我就用这种方式

10:58.840 --> 10:59.840
创建一个元素

10:59.840 --> 11:01.840
然后去观察这个元素

11:01.840 --> 11:02.840
当观察到变化的时候

11:02.840 --> 11:03.840
我执行什么呢

11:03.840 --> 11:04.840
执行的就是拷败

11:06.840 --> 11:07.840
执行的就是拷败

11:07.840 --> 11:08.840
对不对

11:08.840 --> 11:09.840
好

11:09.840 --> 11:10.840
然后我故意把元素

11:10.840 --> 11:11.840
改一下

11:11.840 --> 11:12.840
然后是不是这个东西

11:12.840 --> 11:13.840
到微对地了

11:13.840 --> 11:14.840
OK

11:14.840 --> 11:15.840
那么这是漏的环境

11:15.840 --> 11:16.840
这是浏览器环境

11:16.840 --> 11:17.840
那还有种环境呢

11:17.840 --> 11:18.840
我都不知道

11:18.840 --> 11:19.840
它是啥环境呢

11:19.840 --> 11:20.840
反正呢就是

11:20.840 --> 11:21.840
一些低版本的浏览器

11:21.840 --> 11:22.840
Motation of Zover

11:22.840 --> 11:23.840
有可能是一些

11:23.840 --> 11:24.840
莫名其妙的环境

11:24.840 --> 11:26.840
那么我们这种情况呢

11:26.840 --> 11:27.840
我就确实搞不定的

11:27.840 --> 11:28.840
我就不知道该怎么去

11:28.840 --> 11:29.840
浏览对地了

11:29.840 --> 11:30.840
那我就直接用这些拆帽子

11:30.840 --> 11:32.840
这是一种非常非常完善的做法

11:32.840 --> 11:33.840
其实这种做法

11:33.840 --> 11:34.840
就是参照了那个

11:34.840 --> 11:35.840
无忧的写法

11:35.840 --> 11:36.840
那我讲到这儿了

11:36.840 --> 11:37.840
顺便给大家说一下

11:37.840 --> 11:39.840
这个做法其实并不是

11:39.840 --> 11:40.840
很完善

11:40.840 --> 11:41.840
它里边还是有一些

11:41.840 --> 11:42.840
效率的问题

11:42.840 --> 11:43.840
你看我每一次运行

11:43.840 --> 11:44.840
这个函数

11:44.840 --> 11:45.840
它都要去新建一个

11:45.840 --> 11:46.840
Motation of Zover

11:47.840 --> 11:49.840
是不是有点浪费效率

11:49.840 --> 11:50.840
其实我们完全可以

11:50.840 --> 11:51.840
做一个单粒

11:51.840 --> 11:53.840
就是只有一个Ozover

11:53.840 --> 11:55.840
然后我让元素不断的变化

11:55.840 --> 11:56.840
但是这样子的话

11:56.840 --> 11:58.840
会导致我们程序比较复杂

11:58.840 --> 11:59.840
因为它还去围护对立

11:59.840 --> 12:00.840
有点麻烦

12:00.840 --> 12:01.840
所以我们这里呢

12:01.840 --> 12:02.840
就不用去考虑那么深了

12:02.840 --> 12:04.840
因为这里毕竟也不是

12:04.840 --> 12:05.840
Promise的核心内容

12:05.840 --> 12:06.840
如果说你这一块

12:06.840 --> 12:08.840
觉得太麻烦了

12:08.840 --> 12:09.840
你就直接写个这个

12:09.840 --> 12:10.840
没有问题

12:10.840 --> 12:11.840
我们把它封装一下

12:11.840 --> 12:12.840
将来要改的话

12:12.840 --> 12:13.840
就改这一块就行了

12:13.840 --> 12:14.840
好 封装这个函数

12:14.840 --> 12:15.840
我们来试一下

12:15.840 --> 12:16.840
现在其实跟Promise

12:16.840 --> 12:18.840
已经暂势没有什么关系了

12:18.840 --> 12:19.840
我们先把它实现

12:20.840 --> 12:21.840
OK 我们这里呢

12:21.840 --> 12:24.840
找到Roc Microtask

12:24.840 --> 12:26.840
好 我给它传递一个函数进去

12:26.840 --> 12:27.840
我们这里输出一个2

12:27.840 --> 12:29.840
上面一个SetTimeout

12:30.840 --> 12:31.840
Timeout

12:31.840 --> 12:32.840
那么这里呢

12:33.840 --> 12:34.840
输出一个1

12:34.840 --> 12:36.840
然后我们下边输出3

12:36.840 --> 12:37.840
我们来看一下

12:37.840 --> 12:38.840
如果它打印的是数据

12:38.840 --> 12:40.840
打印的顺序是3 2 1

12:40.840 --> 12:41.840
那就正确的

12:41.840 --> 12:42.840
运行

12:43.840 --> 12:44.840
说3 2 1

12:44.840 --> 12:45.840
对吧 那就正确的

12:45.840 --> 12:46.840
OK 那么这几课呢

12:46.840 --> 12:47.840
我们就实现了

12:47.840 --> 12:48.840
这么一个函数

12:48.840 --> 12:49.840
第一个

12:49.840 --> 12:50.840
我们把任函数的结构写出来了

12:50.840 --> 12:51.840
有两个参数

12:51.840 --> 12:53.840
然后呢 返回一个新的Promise

12:53.840 --> 12:54.840
这个结构出来了

12:55.840 --> 12:56.840
然后我们还实现了

12:56.840 --> 12:57.840
这么一个辅助函数

12:57.840 --> 12:58.840
将来我们要用的

12:58.840 --> 13:00.840
到了我们把它写好之后呢

13:00.840 --> 13:01.840
将来就非常方便了

13:01.840 --> 13:02.840
我要产生微对力

13:02.840 --> 13:03.840
调用这个函数

13:03.840 --> 13:04.840
把函数传进去 对吧

13:04.840 --> 13:05.840
那么它就会把这个函数

13:05.840 --> 13:06.840
放到微对的一边

13:06.840 --> 13:07.840
马上执行

13:08.840 --> 13:09.840
马上把它放到微对的一边

13:09.840 --> 13:10.840
将来执行

13:10.840 --> 13:11.840
OK 那是这几课

13:11.840 --> 13:12.840
咱们的内容

