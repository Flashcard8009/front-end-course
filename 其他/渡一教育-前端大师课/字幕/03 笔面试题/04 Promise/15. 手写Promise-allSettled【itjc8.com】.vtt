WEBVTT

00:00.180 --> 00:04.780
这些课呢 我们来实现另外一个Promise的静态方法叫做All Settled

00:05.560 --> 00:07.600
这个方法呢 跟All的区别在哪呢

00:07.860 --> 00:08.880
就这个方法啊

00:09.140 --> 00:12.720
它返回的Promise一定成功 它不可能失败的

00:13.500 --> 00:15.280
比方说啊 我们现在有个Promise1

00:15.540 --> 00:17.340
它10毫秒之后它失败

00:17.840 --> 00:20.660
然后呢 还有个234和5都是成功的

00:20.920 --> 00:25.780
对吧 那么我这个Promise呢 如果说是All的话呢 它一定失败了 因为它失败了

00:26.040 --> 00:27.320
任何一个失败它都会失败

00:27.820 --> 00:29.620
但是这个PromiseAll Settled 什么意思呢

00:30.020 --> 00:32.180
表示只要所有的

00:32.700 --> 00:33.460
已决

00:33.720 --> 00:36.280
Settled就是已决的意思 对吧 只要你

00:36.780 --> 00:38.580
OK了就行 有结果就行

00:39.340 --> 00:40.380
Settled就是

00:40.640 --> 00:44.460
反正一切沉安落定了 对吧 一个成功也可以 失败也可以

00:44.720 --> 00:46.520
只要你有结果就行

00:47.020 --> 00:49.340
那么它会把所有的结果来进行汇总

00:49.840 --> 00:50.860
我们来运行看一下

00:52.140 --> 00:52.660
一会发现

00:52.920 --> 00:55.480
你看 每一个得到结果呢 是一个对象

00:55.980 --> 00:57.780
失败的时候呢 它的状态是为解体的

00:58.500 --> 00:59.780
然后它的原因

01:00.040 --> 01:00.800
对吧 然后

01:01.060 --> 01:03.100
成功的时候呢 状态是否废了的

01:03.360 --> 01:04.140
它的数据

01:04.640 --> 01:05.660
它一定会总起来

01:05.920 --> 01:08.740
因为这个Promise是永远不可能失败的 它可能挂起

01:09.000 --> 01:12.320
对吧 只要有一个Promise没有已决 那这里

01:12.580 --> 01:15.660
一秒钟 那这三 这四个是不是很快就结束了

01:15.900 --> 01:17.440
但它没有结束 那么它就是挂起

01:17.700 --> 01:19.740
那等到一秒钟之后 那么成功

01:20.520 --> 01:21.280
看一下

01:22.060 --> 01:23.840
一秒钟之后 你看 才会成功

01:24.360 --> 01:25.120
就这么一个逻辑

01:25.380 --> 01:26.920
好 我们来实现这个静态方法

01:28.080 --> 01:29.020
其实这个静态方法呀

01:29.780 --> 01:30.720
很好实现

01:31.060 --> 01:32.340
需要一点想象力

01:32.860 --> 01:33.940
它代码并不复杂

01:35.160 --> 01:37.980
我这里写出是 你们想象一下

01:38.240 --> 01:39.260
该怎么去实现

01:41.580 --> 01:42.860
这是个自信器

01:43.120 --> 01:44.140
这个迭代器

01:44.400 --> 01:45.420
好 这是

01:46.180 --> 01:47.720
所有等待

01:47.980 --> 01:49.020
所有的

01:50.800 --> 01:51.560
Promise

01:52.460 --> 01:54.120
有结果之后

01:55.120 --> 01:57.440
该方法

01:57.700 --> 02:00.000
返回的Promise

02:00.780 --> 02:01.540
完成

02:02.320 --> 02:05.900
并且按照顺序 还是一样 按照顺序

02:06.400 --> 02:08.980
将所有结果贵重

02:09.480 --> 02:10.760
贵重出来就是这么一个玩意儿

02:12.040 --> 02:13.320
这个函数怎么实现呢

02:13.580 --> 02:15.360
其他的代码跟O是不是差不多

02:15.620 --> 02:18.440
如果发现你跟O差不多的话 你可以想一想

02:18.700 --> 02:20.220
能不能就利用这个O

02:20.480 --> 02:21.260
来去完成

02:22.540 --> 02:23.560
实际上是可以的

02:23.760 --> 02:27.600
我给大家写一遍 写了过后 因为好多人应该恍然大悟了

02:28.120 --> 02:29.920
我这边去准备好一个数组

02:30.420 --> 02:32.220
就是PS

02:32.480 --> 02:34.260
这个数组里边装什么呢

02:34.520 --> 02:37.340
我把这里边的Promise给它改一下

02:37.600 --> 02:38.360
稍微改一下

02:38.620 --> 02:39.900
然后装到这个数组里边去

02:41.720 --> 02:42.500
Promise

02:43.000 --> 02:44.800
怎么改呢 你看 我就这样改

02:47.100 --> 02:49.400
添加一个Promise 往里边装一个Promise

02:49.660 --> 02:50.940
但是装的不是直接装P

02:51.200 --> 02:53.260
而是通过P的另一方法

02:56.370 --> 02:59.190
然后这是那个成功的数据

02:59.710 --> 03:01.230
这是失败的原因

03:01.490 --> 03:05.810
一想一想

03:06.070 --> 03:07.870
我这个Promise调用Z

03:08.370 --> 03:10.690
不管它是成功还是失败

03:11.450 --> 03:14.010
要么运行这个函数 要么运行这个函数

03:14.270 --> 03:16.830
我只要保证这两个函数不要爆错

03:17.090 --> 03:19.130
是不是只要保证这两个函数不要爆错

03:19.390 --> 03:20.910
那么这个Promise返回了

03:21.170 --> 03:22.410
它一定是成功的

03:22.670 --> 03:23.490
是不是这个逻辑

03:26.520 --> 03:28.060
这个Promise是不是一定成功的

03:28.680 --> 03:31.740
所以说我这里往这个数据里边加的所有的Promise

03:31.980 --> 03:33.660
按照这种模组的话 它一定成功的

03:34.920 --> 03:38.000
那么成功之后就是无非就是成功之后的数据是什么

03:38.520 --> 03:39.540
数据是咋呢

03:40.300 --> 03:42.540
我这里直接我都拿着写Return语去拿

03:42.800 --> 03:43.640
返回了就是一个对象

03:44.140 --> 03:45.540
用小货号扩一下

03:45.800 --> 03:47.220
扩一下的好处

03:47.460 --> 03:49.000
就是让它不要有奇异

03:49.260 --> 03:50.280
表示这是一个对象

03:50.540 --> 03:51.560
一个表达是一个对象

03:51.820 --> 03:53.620
这对象里边有两 如果说你成功了

03:53.860 --> 03:54.880
对象里边有两个属性

03:55.140 --> 03:56.420
一个属性叫Status

03:57.260 --> 03:57.900
Rejected

03:58.160 --> 04:00.100
当我这里可以直接使用上面的长量

04:00.340 --> 04:00.900
Rejected

04:02.660 --> 04:03.060
好

04:03.300 --> 04:04.740
如果拿到

04:05.340 --> 04:06.740
不 它的Fulfill的

04:07.020 --> 04:08.260
成功的是有Fulfill的

04:09.420 --> 04:11.060
然后它的数据是什么呢

04:11.300 --> 04:11.740
就是Value

04:12.500 --> 04:13.260
这成功的

04:13.780 --> 04:15.580
好失败的是不是也一样的道理

04:16.540 --> 04:18.140
失败的时候它的Status

04:19.780 --> 04:20.340
是什么

04:20.580 --> 04:21.460
是那个Rejected

04:22.500 --> 04:23.180
Rejected

04:24.300 --> 04:24.660
好

04:25.300 --> 04:26.260
数据是Value

04:27.340 --> 04:29.260
原因是Rejected

04:30.700 --> 04:31.740
为什么保证什么呢

04:31.980 --> 04:34.500
我要往这个数据一项一项加一个新的ProMess

04:34.500 --> 04:36.540
这个新的ProMess是通过它来产生的

04:36.900 --> 04:37.700
它有可能失败

04:37.700 --> 04:39.780
但是这个新的ProMess是绝不可能失败的

04:41.580 --> 04:41.900
对不对

04:41.900 --> 04:44.300
那么这样子是不是就形成了一个ProMess的数据了

04:45.020 --> 04:46.180
那么这个ProMess的数据里面

04:46.180 --> 04:49.140
每一个ProMess只可能成功不可能失败

04:49.420 --> 04:50.700
而成功了

04:50.940 --> 04:52.220
成功之后返回这么一个对象

04:52.380 --> 04:53.500
它的数据是这么一个对象

04:53.500 --> 04:54.420
失败的时候

04:55.260 --> 04:56.540
它也是成功的

04:56.540 --> 04:57.820
成功的数据是这么一个对象

04:58.300 --> 05:00.540
那么我只需要把这个数据

05:01.380 --> 05:02.740
调用Z

05:03.300 --> 05:05.940
对调用那个MyProMess

05:05.940 --> 05:06.420
O

05:06.980 --> 05:08.300
然后把这个数据传进去

05:08.300 --> 05:09.020
是否完成了

05:09.900 --> 05:10.940
因为O的话

05:11.420 --> 05:12.780
O这个东西它是不是

05:13.500 --> 05:14.620
它本来可能会失败

05:14.620 --> 05:17.100
但是由于这里边的ProMess不可能失败的

05:17.100 --> 05:18.060
所有都必须要成功

05:18.060 --> 05:19.100
所以说O的方法

05:19.380 --> 05:20.740
返回的ProMess一定成功

05:21.020 --> 05:23.100
而且数据就是我这里给它返回的数据

05:23.140 --> 05:24.700
就算让这种节奏返回的

05:24.700 --> 05:25.660
就小痕了

05:26.020 --> 05:27.340
你们好好去理一下

05:27.340 --> 05:29.060
没有必要去写一大堆战吧

05:29.260 --> 05:30.780
因此我把这里的换成Buy

05:31.420 --> 05:33.460
得到的效果是完全一样的

05:36.020 --> 05:37.460
OK 我们再运行一下

05:38.220 --> 05:39.260
一秒钟之后

05:39.620 --> 05:40.580
是不是得到这个东西

05:41.580 --> 05:42.660
不对

05:42.660 --> 05:43.860
我这里还没改

05:43.860 --> 05:45.340
把这里改成BrandProMess

05:46.660 --> 05:47.740
这里有个错误

05:48.300 --> 05:48.860
对

05:48.860 --> 05:52.260
这个P它有可能它不是一个ProMess

05:52.260 --> 05:52.540
对吧

05:52.540 --> 05:54.140
所以说我们这里应该用什么

05:54.220 --> 05:57.420
用ProMess Result把它刀一下

05:58.420 --> 05:58.780
对不对

05:59.420 --> 06:00.140
好 再运行

06:01.740 --> 06:03.420
你看是完全一样的结果

06:03.740 --> 06:07.180
OK 这就是这个Ostotr如何去实现

