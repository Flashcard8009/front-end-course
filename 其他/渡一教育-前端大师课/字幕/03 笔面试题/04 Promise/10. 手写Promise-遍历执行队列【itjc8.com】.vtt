WEBVTT

00:00.180 --> 00:03.380
好 前面的工作呢 我们已经实现了这么一个对立

00:03.380 --> 00:08.180
这些对立里面就包含了我们所有有可能会执行到的函数

00:08.180 --> 00:11.180
对吧 当然也有可能不执行 要根据状态来确定

00:11.180 --> 00:14.680
还有包括了有些函数它本身是undefined 对吧 没法执行

00:14.680 --> 00:17.680
那么这些工作呢 都要去遍地这个对立

00:17.680 --> 00:21.180
然后呢 一个一个拿出来看 看一下到底该怎么来 怎么来处理

00:21.180 --> 00:26.180
于是我们在这呢 去抽象这么一个函数啊 去写这么一个函数

00:26.180 --> 00:29.180
刚才我们之前写过这么一个加到对立的函数 对吧

00:29.180 --> 00:36.180
现在呢 我们去执行对立的函数 叫做raw handlers 执行对立

00:36.180 --> 00:45.740
不需要函数 根据实际情况 然后执行对立 写出来这么一个函数

00:45.740 --> 00:48.740
当然这个函数呢 比较容易想到的是什么呢

00:48.740 --> 00:55.740
比较容易想到的就是 如果说目前的状态 state 等于什么 等于pending

00:55.740 --> 01:04.740
说明啥 说明目前 目前任务仍在挂起 挂起

01:04.740 --> 01:07.740
所以目前任务还没有结束 对吧 没有成功也没有失败

01:07.740 --> 01:11.740
我都不知道它什么状态 那么这种情况下是无论如何

01:11.740 --> 01:14.740
不可能去执行对立的 看都不会去看它 对不对

01:14.740 --> 01:16.740
那么这种状态 那么直接return

01:16.740 --> 01:19.740
好 那么现在我们想个这么一个问题

01:19.740 --> 01:23.740
这个函数什么时候只调用它 当然这个函数还没写完

01:24.740 --> 01:30.740
这函数什么时候调用它 什么时候 改状态变了要不要调用

01:30.740 --> 01:33.740
比方说你刚才一开始挂起 后来变成功了

01:33.740 --> 01:36.740
那是不是要得来来来看一遍 对不对

01:36.740 --> 01:38.740
要不要调用 肯定要调用

01:38.740 --> 01:42.740
好 于是呢 我们知道这一点之后 我们至少可以在这里

01:42.740 --> 01:47.740
在result里面 在change state里面

01:47.740 --> 01:51.740
是不是状态变了之后 如果说你状态目前已经改变了

01:51.740 --> 01:54.740
那就啥都不干了 对吧 如果说状态没有改变

01:54.740 --> 01:57.740
就之前是挂起 现在把状态改了

01:57.740 --> 02:01.740
那么改了状态之后 无论你改成成功还是改成失败

02:01.740 --> 02:03.740
是不是得运行这个对立 对吧

02:03.740 --> 02:06.740
run handles得运行吧

02:06.740 --> 02:10.740
状态变化 执行对立

02:10.740 --> 02:13.740
把对立从头到尾看一遍

02:13.740 --> 02:16.740
这没问题吧 那么就描述了什么了

02:16.740 --> 02:20.740
描述了你一秒钟之后变成成功

02:20.740 --> 02:23.740
但是我在一秒钟之前就给他驻车了这些喊数了

02:23.740 --> 02:26.740
对立已经形成了 那里成功的时候

02:26.740 --> 02:29.740
是不是改变了状态 改变状态是不是要从头到尾看一遍

02:29.740 --> 02:33.740
好 这是一个时候 那么现在失讨另外一个问题

02:33.740 --> 02:37.740
如果说是智商人代码的 那么没有等待一秒钟

02:37.740 --> 02:42.740
那么我们当我们调用Zing的时候 是不是状态已经确定了

02:42.740 --> 02:44.740
是不是状态已经确定了 这个时候是不是已经成了

02:44.740 --> 02:47.740
他状态已经是成功了 那么这个喊数加到对立没

02:47.740 --> 02:50.740
抓加到对立了 比方说我们现在看这种情况

02:50.740 --> 02:56.630
好 运行 你看状态现在已经成功了

02:56.630 --> 02:59.630
有没有加到对立 有啊 加了一个喊数

02:59.630 --> 03:01.630
加了一个undefined 对吧 第二个喊数undefined

03:01.630 --> 03:04.630
那么这个时候 调用Zing的时候 这个时候要不要看

03:04.630 --> 03:07.630
是不是也得看 因此调任方法的时候

03:07.630 --> 03:10.630
有两件事要做 第一件事加到对立里面去

03:10.630 --> 03:14.630
第二件事还是要看一下 那万一现在状态已经确定了呢

03:14.630 --> 03:17.630
所以说调任方法的时候 在这

03:18.630 --> 03:22.630
我们把加到对立里面去 然后同样的也要去调用这个

03:23.630 --> 03:26.630
你看为什么我要把抽离出去 避免重复它

03:26.630 --> 03:29.630
而且让每一个喊数的结构保持减减

03:29.630 --> 03:32.630
你看我们每一个喊数其实代表并不多 就那么极好

03:32.630 --> 03:35.630
这样子的每个单元 其实模细是非常清晰的

03:37.630 --> 03:42.630
然后调用 这个时候就执行对立吧

03:42.630 --> 03:45.630
懂的意思就讲了 好 现在我们所有的

03:45.630 --> 03:48.630
调用时机我们已经确定了 就在这

03:49.630 --> 03:52.630
如果说你目前的状态是挂起的 拿我啥的也不看

03:52.630 --> 03:54.630
对立也看得不看

03:55.630 --> 03:57.630
那么现在我们来考虑一下67行

03:57.630 --> 04:01.630
如果说现在的状态不是挂起 要么成功 要么失败

04:01.630 --> 04:04.630
那么这个时候是不是要把对立一个一个拿出来看

04:05.630 --> 04:07.630
对吧 那怎么一个一个拿出来看呢

04:08.630 --> 04:11.630
一个循环就搞定了 都要用for all循环

04:12.630 --> 04:14.630
拿到每一个handle

04:15.630 --> 04:17.630
注意 每个handle是个对象

04:17.630 --> 04:20.630
拿到每一个handle去循环什么的 循环z

04:20.630 --> 04:22.630
叫handleers 所以循环这个数组

04:23.630 --> 04:25.630
当这个数组有没有可能是空的 当然有可能

04:25.630 --> 04:28.630
那无所谓吧 比较说现在都没有注册z

04:28.630 --> 04:31.630
对吧 那调用一个Razor5要不要执行 要执行

04:31.630 --> 04:35.630
所以要执行 但是这个数 但是现在的数组是空的

04:36.630 --> 04:40.630
你看handleers是空的 那空的的话就进不了循环嘛

04:40.630 --> 04:42.630
进不了循环 那就相当于是啥也没做吗

04:42.630 --> 04:44.630
没问题的 这个逻辑都是没问题的

04:45.630 --> 04:48.940
好 那么现在的对立肯定不是空的了

04:49.940 --> 04:51.940
那么现在我们去循环这个对立

04:51.940 --> 04:55.940
然后一个一个一个对象一个对象拿出来 处理就完事了

04:55.940 --> 04:58.940
那么具体处理每一个对象呢 那又是一个副长的过程

04:59.940 --> 05:01.940
因此我这里再开一个函数 别看我函数起来多

05:01.940 --> 05:04.940
其实你可以保持每一个函数的简洁 把注册打好

05:04.940 --> 05:05.940
没有任何问题

05:06.940 --> 05:10.940
就是run onehandle

05:11.940 --> 05:13.940
你给我传一个handle

05:14.940 --> 05:18.940
这个函数是 这是一个object对象

05:19.940 --> 05:22.940
处理每一个handle

05:23.940 --> 05:25.940
我们循环不就是一个一个拿出来处理吗

05:25.940 --> 05:27.940
处理一个我单独开成一个函数

05:27.940 --> 05:28.940
这是我们下几颗要实现的

05:29.940 --> 05:31.940
这是不大出事

05:32.940 --> 05:34.940
好 这边就是调用这个什么

05:35.940 --> 05:36.940
run handle

05:38.940 --> 05:39.940
run onehandle

05:40.940 --> 05:44.700
把什么handle传进去 让它去处理

05:44.700 --> 05:45.700
就我不处理

05:45.700 --> 05:48.700
我只是循环 帮你循环一个个拿出来

05:48.700 --> 05:50.700
先拿出来第一个交给他来处理

05:50.700 --> 05:52.700
先拿出来第二个交给他来处理

05:52.700 --> 05:53.700
这种思路大家一定要学会

05:53.700 --> 05:55.700
来降低复杂度

05:55.700 --> 05:57.700
不然的话 全部弄在一堆

05:57.700 --> 05:58.700
它写出来大概没法看了个代码

05:58.700 --> 05:59.700
你自己都受不了

05:59.700 --> 06:01.700
这种代码其实非常非常清晰的

06:01.700 --> 06:03.700
每一个还是极其简洁

06:03.700 --> 06:05.700
把功能拆分很细

06:05.700 --> 06:08.700
而且由于功能拆分很细的 特别容易复用

06:09.700 --> 06:11.700
好 那么现在我们还要考虑一个问题

06:11.700 --> 06:14.700
就是一个对立 你处理的一个

06:14.700 --> 06:16.700
是不是就应该把删掉

06:16.700 --> 06:17.700
是不是应该删掉

06:17.700 --> 06:20.700
你不删掉的话 会出现什么样的后果

06:20.700 --> 06:21.700
你看现在这个

06:21.700 --> 06:23.700
我改变状态的过后

06:23.700 --> 06:25.700
比方说吧

06:25.700 --> 06:30.020
我这里set timeout

06:30.020 --> 06:32.020
这样子来处理

06:32.020 --> 06:34.020
resort

06:34.020 --> 06:37.020
好 那么现在我再来一个set timeout

06:37.020 --> 06:41.390
再来一个

06:41.390 --> 06:45.390
再来一个什么呢

06:45.390 --> 06:47.390
一看一下

06:47.390 --> 06:49.390
我们这里

06:49.390 --> 06:51.390
每次处理的时候 要打印一下

06:51.390 --> 06:55.340
处理

06:55.340 --> 06:56.340
多少个呢

06:56.340 --> 07:01.340
处理res handlers-dres

07:01.340 --> 07:03.980
然后我们这里

07:03.980 --> 07:06.980
甚至可以把res handlers

07:06.980 --> 07:07.980
打印出来

07:07.980 --> 07:09.980
好吧 我们在这里用这种方式来处理

07:09.980 --> 07:11.980
来看一下这样子

07:11.980 --> 07:12.980
会有一个什么样的问题

07:12.980 --> 07:15.980
我这里不输出了

07:15.980 --> 07:17.980
运行

07:17.980 --> 07:18.980
你看 是不是处理到两次啊

07:18.980 --> 07:19.980
为什么会处理两次

07:19.980 --> 07:20.980
咱们来分析一下

07:20.980 --> 07:22.980
第一次 什么时候处理的

07:22.980 --> 07:23.980
是不是调用任的时候

07:23.980 --> 07:24.980
因为这里要等一会儿才调用

07:24.980 --> 07:26.980
对吧 调用任的时候

07:26.980 --> 07:28.980
是不是我们要循环便利一次

07:28.980 --> 07:30.980
对吧 它先把这个a1加进去

07:30.980 --> 07:31.980
a1 然后把第二个参数

07:31.980 --> 07:32.980
Angle犯了加进去

07:32.980 --> 07:34.980
是不是有两个函数在对立里边

07:34.980 --> 07:35.980
好 我就处理到两个函数

07:35.980 --> 07:36.980
调用任的时候

07:36.980 --> 07:37.980
是不是要运行一遍

07:37.980 --> 07:39.980
把这个对立

07:39.980 --> 07:41.980
对吧

07:41.980 --> 07:43.980
这个同学们

07:43.980 --> 07:45.980
还不是调用任的时候

07:45.980 --> 07:47.980
是调用resolve的时候

07:47.980 --> 07:48.980
因为调用任的时候

07:48.980 --> 07:49.980
现在还是pending嘛

07:49.980 --> 07:50.980
对不对 还是pending状态

07:50.980 --> 07:51.980
它不会处理的

07:51.980 --> 07:52.980
那么调用resolve的时候

07:52.980 --> 07:53.980
是不是要处理一次

07:53.980 --> 07:55.980
它看到对立里面有两个东西

07:55.980 --> 07:57.980
那么我们这里的循环

07:57.980 --> 07:59.980
两次处理到

07:59.980 --> 08:00.980
接下来

08:00.980 --> 08:01.980
下一个摊帽子的时间

08:01.980 --> 08:02.980
到达了之后

08:02.980 --> 08:03.980
我又调用了任

08:03.980 --> 08:04.980
那么这个时候

08:04.980 --> 08:05.980
状态是不是已经完成了

08:05.980 --> 08:06.980
那么调用任的时候

08:06.980 --> 08:07.980
它也要处理

08:07.980 --> 08:08.980
调用任的时候

08:08.980 --> 08:09.980
又处理是不是又处理

08:09.980 --> 08:10.980
这个之前的A1

08:10.980 --> 08:11.980
还有Andy Fand

08:11.980 --> 08:13.980
还有现在的新的A2

08:13.980 --> 08:14.980
和Andy Fand

08:14.980 --> 08:15.980
说明啥

08:15.980 --> 08:16.980
我一直绕了半天说明啥

08:16.980 --> 08:17.980
说明我每处理一个

08:17.980 --> 08:19.980
要把之前的干删掉

08:19.980 --> 08:21.980
处理一个叫删一个

08:21.980 --> 08:22.980
说这件事

08:22.980 --> 08:24.980
你理解清楚了就好做了

08:24.980 --> 08:25.980
那怎么来删呢

08:25.980 --> 08:27.980
是不是可以通过

08:27.980 --> 08:30.980
this handlers

08:30.980 --> 08:31.980
shift

08:31.980 --> 08:33.980
删除第1个

08:33.980 --> 08:35.980
你看我这里处理完第1个

08:35.980 --> 08:36.980
第1个就走了

08:36.980 --> 08:38.980
不要了

08:38.980 --> 08:40.980
那这样子行吗

08:40.980 --> 08:41.980
这样子肯定不行

08:41.980 --> 08:43.980
都是一个小细节

08:43.980 --> 08:44.980
这个倒不是什么

08:44.980 --> 08:45.980
多复杂的事情

08:45.980 --> 08:46.980
你看吧

08:46.980 --> 08:48.980
比方说我这里写个数字

08:48.980 --> 08:49.980
L2

08:49.980 --> 08:52.980
这里写个1,2,3,4,5

08:52.980 --> 08:53.980
来吧

08:53.980 --> 08:54.980
比方说我这里

08:54.980 --> 08:55.980
用for 2的循环

08:55.980 --> 08:56.980
去循环它

08:56.980 --> 08:57.980
循环的时候

08:57.980 --> 08:58.980
每循环一次

08:58.980 --> 08:59.980
我输出一下它

08:59.980 --> 09:00.980
然后我再删一个

09:00.980 --> 09:02.980
shift

09:02.980 --> 09:03.980
最后应该是

09:03.980 --> 09:04.980
把这个数字删完

09:04.980 --> 09:05.980
对不对

09:05.980 --> 09:06.980
第1个拿到

09:06.980 --> 09:07.980
用完就删了

09:07.980 --> 09:09.980
所以应该把这个数字删完

09:09.980 --> 09:10.980
那么最后来

09:10.980 --> 09:11.980
我们输出一下这个数字

09:11.980 --> 09:13.980
看一下有没有删完

09:13.980 --> 09:14.980
因为发现没有删完

09:14.980 --> 09:16.980
那么到底是怎么回事的

09:16.980 --> 09:17.980
这其实是一个

09:17.980 --> 09:19.980
非常基础的问题

09:19.980 --> 09:21.980
比方说

09:21.980 --> 09:23.980
现在呢

09:23.980 --> 09:32.240
好

09:32.240 --> 09:33.240
那么比方说

09:33.240 --> 09:34.240
我们循环到第1个

09:34.240 --> 09:35.240
第1个

09:35.240 --> 09:37.240
它目前是这样子的

09:37.240 --> 09:38.240
它那个for 2的循环

09:38.240 --> 09:40.240
是一个一个便利的

09:40.240 --> 09:44.900
它便利到第1个

09:44.900 --> 09:48.210
然后我把第1个赶删了

09:48.210 --> 09:49.210
接下来

09:49.210 --> 09:51.210
由于现在第1个3

09:51.210 --> 09:52.210
那过后

09:52.210 --> 09:53.210
它就导致

09:53.210 --> 09:55.210
它目前就指向这个了

09:55.210 --> 09:56.210
懂了意思吧

09:56.210 --> 09:57.210
它目前就指向这个了

09:57.210 --> 09:59.210
你把第1个3了

09:59.210 --> 10:00.210
3那过后

10:00.210 --> 10:01.210
你现在去

10:01.210 --> 10:02.210
你现在

10:02.210 --> 10:03.210
刚才本来是指向1的

10:03.210 --> 10:04.210
现在就指向这个了

10:04.210 --> 10:06.210
那么在下一个的时候

10:06.210 --> 10:07.210
它指向

10:07.210 --> 10:08.210
下一个的时候

10:08.210 --> 10:09.210
下一次循环它就挑过2了

10:09.210 --> 10:10.210
知道吧

10:10.210 --> 10:11.210
于是

10:11.210 --> 10:12.210
它就现在就指向3了

10:12.210 --> 10:13.210
所以你会发现

10:13.210 --> 10:14.210
一输出完了过

10:14.210 --> 10:15.210
就输出几

10:15.210 --> 10:16.210
一输出完了过

10:16.210 --> 10:17.210
就输出3

10:17.210 --> 10:18.210
因为它2就略过了

10:18.210 --> 10:19.210
知道吧

10:19.210 --> 10:21.210
它有这么一个问题存在

10:21.210 --> 10:23.210
那么输出3过后

10:23.210 --> 10:24.210
它又散出第1个

10:24.210 --> 10:26.210
然后它现在就把2的3了

10:26.210 --> 10:28.210
懂了意思吧

10:28.210 --> 10:29.210
然后2的3那过后

10:29.210 --> 10:30.210
3又跑前面去了

10:30.210 --> 10:32.210
那么它本来是指向3的

10:32.210 --> 10:34.210
结果它现在指向4了

10:34.210 --> 10:35.210
指向4了

10:35.210 --> 10:36.210
然后再下一次循环

10:36.210 --> 10:37.210
下一次循环

10:37.210 --> 10:39.210
又输出了5

10:39.210 --> 10:40.210
这里输出了5

10:40.210 --> 10:41.210
然后又散出第1个

10:41.210 --> 10:42.210
它又把3散了

10:42.210 --> 10:43.210
所以最后剩15

10:43.210 --> 10:44.210
但是输出的是135

10:44.210 --> 10:45.210
我记得

10:45.210 --> 10:47.210
它这个玩意还可以出面是提的

10:47.210 --> 10:49.210
它就变成这么一个样子的

10:49.210 --> 10:51.210
因此怎么来处理这个问题呢

10:51.210 --> 10:52.210
就是我一个一个看

10:52.210 --> 10:54.210
看完了过后就3

10:54.210 --> 10:55.210
其实非常简单

10:55.210 --> 10:57.210
你这样子写

10:57.210 --> 10:58.210
你这样子写

10:58.210 --> 11:00.210
你写这么一个index

11:00.210 --> 11:02.210
就不用写index

11:02.210 --> 11:05.210
我就直接看你第1个

11:05.210 --> 11:07.210
AR0

11:07.210 --> 11:08.210
就看你第1项

11:08.210 --> 11:09.210
我一个一个拿

11:09.210 --> 11:10.210
什么一个拿

11:10.210 --> 11:11.210
就拿第1项

11:11.210 --> 11:12.210
永远只拿第1项

11:12.210 --> 11:14.210
第1项有东西吗

11:14.210 --> 11:16.210
有东西说明了

11:16.210 --> 11:18.210
我现在还没有循环

11:18.210 --> 11:19.210
你这个输出还有东西

11:19.210 --> 11:21.210
有东西我就拿第1项

11:21.210 --> 11:22.210
拿第1项的时候

11:22.210 --> 11:23.210
我干嘛呢

11:23.210 --> 11:26.210
我输出第1项

11:26.210 --> 11:28.210
然后怎么样

11:28.210 --> 11:30.210
Shift3掉

11:30.210 --> 11:32.210
那现在就没问题了

11:32.210 --> 11:33.210
你看

11:33.210 --> 11:34.210
进行了

11:34.210 --> 11:36.210
每一项都变得到了

11:36.210 --> 11:37.210
同时把全都删完了

11:37.210 --> 11:38.210
你看

11:38.210 --> 11:40.210
拿输出的第1项

11:40.210 --> 11:41.210
拿了出来输出

11:41.210 --> 11:43.210
输出完了过去3掉

11:43.210 --> 11:44.210
3掉了

11:44.210 --> 11:45.210
那下一次循环

11:45.210 --> 11:47.210
是不是还是取得第1项

11:47.210 --> 11:48.210
这就是一个

11:48.210 --> 11:49.210
遍地同时删除的一个

11:49.210 --> 11:50.210
这么一个做法

11:50.210 --> 11:51.210
好

11:51.210 --> 11:52.210
那么我们知道

11:52.210 --> 11:53.210
这个做法之后

11:53.210 --> 11:54.210
到了这边

11:54.210 --> 11:55.210
那就非常简单了

11:55.210 --> 11:56.210
我就不用服2个循环

11:56.210 --> 11:57.210
用Wild

11:57.210 --> 11:59.210
循环循环this

11:59.210 --> 12:00.210
handlers

12:00.210 --> 12:01.210
第1项

12:01.210 --> 12:02.210
当然第1项

12:02.210 --> 12:03.210
如果一开始就没有的话

12:03.210 --> 12:04.210
一开始就进不了循环

12:04.210 --> 12:05.210
就结束了

12:05.210 --> 12:06.210
好

12:06.210 --> 12:07.210
那么我们这里

12:07.210 --> 12:08.210
首先第1步

12:08.210 --> 12:09.210
运行这个

12:09.210 --> 12:12.210
然后再运行这个

12:12.210 --> 12:13.210
现在我们看一下

12:13.210 --> 12:14.210
我们用一项

12:14.210 --> 12:15.210
删一项

12:15.210 --> 12:16.210
用一项

12:16.210 --> 12:17.210
删一项

12:17.210 --> 12:18.210
那么得到一个结果是什么呢

12:18.210 --> 12:20.210
运行

12:20.210 --> 12:22.210
这里

12:22.210 --> 12:23.210
应该是

12:23.210 --> 12:24.210
得到一下吧

12:24.210 --> 12:26.210
handlers

12:26.210 --> 12:28.210
0

12:28.210 --> 12:30.210
运行

12:30.210 --> 12:31.210
好

12:31.210 --> 12:32.210
一开始我们处理的是A1

12:32.210 --> 12:33.210
对吧

12:33.210 --> 12:34.210
处理一项就删一项

12:34.210 --> 12:35.210
处理一项就删一项

12:35.210 --> 12:36.210
所以说

12:36.210 --> 12:37.210
后边再加对立的时候

12:37.210 --> 12:39.210
是不是就加到A2

12:39.210 --> 12:40.210
第2个A1

12:40.210 --> 12:41.210
那之前就没了

12:41.210 --> 12:42.210
对不对

12:42.210 --> 12:43.210
所以我们保证

12:43.210 --> 12:44.210
每一个函数

12:44.210 --> 12:45.210
它只能

12:45.210 --> 12:46.210
它只会运行一次

12:46.210 --> 12:48.210
不会重复的运行

12:48.210 --> 12:50.210
就这么一个处理

12:50.210 --> 12:51.210
那么就完事了

12:51.210 --> 12:52.210
我们这一刻就

12:52.210 --> 12:53.210
实现这么一个东西

12:53.210 --> 12:54.210
就是

12:54.210 --> 12:56.210
在运行的时候

12:56.210 --> 12:58.210
就是一个一个便利

12:58.210 --> 12:59.210
那么但是要注意

12:59.210 --> 13:00.210
用一个就删一个

13:00.210 --> 13:01.210
用一个就删一个

13:01.210 --> 13:02.210
那么具体

13:02.210 --> 13:03.210
每一个

13:03.210 --> 13:04.210
那么现在

13:04.210 --> 13:05.210
就现在最后一个点了

13:05.210 --> 13:06.210
每一个怎么办

13:06.210 --> 13:07.210
你这一个玩要搞定的

13:07.210 --> 13:08.210
就没事了

13:08.210 --> 13:09.210
就完事了

13:09.210 --> 13:10.210
所以我们一点点

13:10.210 --> 13:11.210
就可以做到这个样子了

13:11.210 --> 13:12.210
好

13:12.210 --> 13:13.210
这是我们下期可能内容

