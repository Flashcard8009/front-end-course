WEBVTT

00:00.000 --> 00:02.880
我们把知识学完之后

00:02.880 --> 00:05.200
咱们这节可能单独来聊一聊

00:05.200 --> 00:08.000
关于这个Promise的面相关面试题

00:08.000 --> 00:12.240
Promise这个面试题也是ES6里边

00:12.240 --> 00:14.240
面试题非常密集的地方

00:14.240 --> 00:16.480
它玩的花样也可能比较多

00:16.480 --> 00:18.000
我不可能说把每一套

00:18.000 --> 00:20.720
你们将来可能会遇到的每一道面试拿出来讲

00:20.720 --> 00:21.920
那个太多了

00:21.920 --> 00:22.800
没有必要

00:22.800 --> 00:24.960
我们只要抓住它的核心

00:24.960 --> 00:26.080
抓住它的核心原理

00:26.080 --> 00:28.560
我们就可以解开所有的面试题

00:28.640 --> 00:32.400
像我们这里给大家解决了一些面试题的基本考点

00:32.400 --> 00:33.680
一个就是概念

00:33.680 --> 00:35.040
这都是我们讲过的

00:35.040 --> 00:36.080
我们回顾一下

00:36.080 --> 00:37.680
一个就是Promise的概念

00:37.680 --> 00:40.240
概念的话它主要可能会出现一些

00:40.240 --> 00:43.680
天空题 选择题 或者是问答题

00:43.680 --> 00:46.560
它可能会问你Promise的一些核心的一些

00:46.560 --> 00:48.960
阶段 哪些阶段

00:48.960 --> 00:50.960
或者是状态的变化

00:50.960 --> 00:52.400
对吧 就问这些东西

00:52.400 --> 00:53.440
就基本概念

00:55.840 --> 00:57.840
如果说出现代码题的话

00:57.920 --> 01:00.960
它可能会问你给你一段代码

01:00.960 --> 01:03.760
让你说出它的输出结果

01:03.760 --> 01:04.960
那么这个代码里面可能

01:04.960 --> 01:07.040
针对这个基本概念的考察的话

01:07.040 --> 01:08.960
它会可能会问你

01:08.960 --> 01:12.400
像某一些状态之间能不能进行转换

01:12.400 --> 01:14.560
就我们之前其实做过一种类似的题

01:14.560 --> 01:16.160
你看我们面试题的地

01:16.160 --> 01:16.960
这道题就是

01:18.080 --> 01:18.480
哎呗

01:20.560 --> 01:21.120
哪道题呢

01:23.120 --> 01:25.040
之前我这里好像没有列出来

01:25.200 --> 01:27.440
就之前我们在做那个

01:27.440 --> 01:29.040
做过一个题就是

01:29.040 --> 01:30.160
它在Promise

01:30.160 --> 01:31.440
留一个Promise的时候

01:39.010 --> 01:41.010
我们再留一个Promise的时候

01:41.010 --> 01:43.970
这里边它可能会出现这种形式

01:47.170 --> 01:49.410
它可能先Result5一个1

01:49.410 --> 01:52.130
然后再Result5一个2

01:52.130 --> 01:53.170
再Result5一个2

01:53.170 --> 01:53.810
一个东西

01:54.610 --> 01:56.610
它可能会用这种题来考察的

01:56.610 --> 01:58.530
就是针对这个Promise的状态

01:58.610 --> 02:01.410
它会不会因为改变了数据

02:01.410 --> 02:03.010
数据会不会导致变化

02:03.010 --> 02:04.050
改变了一个状态

02:04.050 --> 02:05.410
状态会不会变化

02:05.410 --> 02:07.570
可能会针对这个东西来进行考察

02:07.570 --> 02:09.730
之前那么大家牢记

02:09.730 --> 02:12.130
Promise的状态一旦确定了之后

02:12.130 --> 02:13.650
是不可能会变化的

02:13.650 --> 02:15.010
它的数据也好

02:15.010 --> 02:15.810
状态也好

02:15.810 --> 02:16.850
它不可能会变化

02:16.850 --> 02:17.890
那么就

02:17.890 --> 02:19.250
这种题就没有任何问题了

02:19.250 --> 02:20.610
还是比较简单的

02:20.610 --> 02:21.010
这种题

02:21.730 --> 02:23.010
然后第二个考点

02:23.010 --> 02:24.610
是关于它的劣势标用规则

02:24.610 --> 02:26.370
这一块可能就比较复杂一点

02:26.450 --> 02:28.770
就是咱们单独的有一节课

02:28.770 --> 02:29.090
对吧

02:29.090 --> 02:31.330
专门来讲它的劣势标用规则

02:31.330 --> 02:32.930
那么记住这么几个条

02:32.930 --> 02:33.810
这几条

02:34.370 --> 02:36.050
你把这几条搞清楚了过后

02:37.330 --> 02:39.330
这种题就OK了

02:39.330 --> 02:40.610
到这里就不再出于数了

02:40.610 --> 02:41.730
因为我之前专门来

02:41.730 --> 02:43.650
一些课来时间来讲这个东西

02:44.370 --> 02:45.730
然后还有就是

02:45.730 --> 02:46.850
真正它的一些静态方法

02:46.850 --> 02:48.130
这个也算是比较简单的

02:48.130 --> 02:49.730
就最复杂的可能就是在这一块了

02:50.530 --> 02:51.730
真正它的静态方法

02:53.570 --> 02:54.450
我们就这么一些

02:54.450 --> 02:54.690
对吧

02:54.690 --> 02:55.810
你看一下就完事了

02:56.610 --> 02:57.650
它可能会针对什么

02:57.650 --> 02:59.650
OA、ND这些东西来进行考察

03:00.610 --> 03:02.690
然后就是针对Orsync和Awaiter

03:02.690 --> 03:04.530
这两个玩意是余法堂

03:05.170 --> 03:07.890
它其实本质上考的还是Promise

03:08.610 --> 03:09.170
这个地方

03:09.650 --> 03:10.850
我们一会儿看一下题吧

03:10.850 --> 03:12.370
看一下题我们就可以明白了

03:13.170 --> 03:14.530
然后最后一个考点

03:14.530 --> 03:17.250
是针对把Promise跟事件循环

03:17.250 --> 03:18.210
结合起来考

03:18.210 --> 03:21.250
这种题是考题的量是非常大的

03:21.810 --> 03:23.330
就我们之前学过事件循环

03:23.330 --> 03:23.970
大家还记得吗

03:24.530 --> 03:25.890
就我们这个执行上下文

03:26.610 --> 03:27.890
我们的异步的函数呢

03:27.890 --> 03:30.210
会放到这个维对列

03:30.210 --> 03:31.730
或者是红队列

03:32.050 --> 03:32.530
对吧

03:32.530 --> 03:33.570
那么针对这一块呢

03:34.050 --> 03:35.650
有一个知识给大家说一下

03:36.050 --> 03:39.970
我们目前学的所有的关于介石的知识

03:40.930 --> 03:42.210
有这么极重情况

03:43.330 --> 03:45.570
函数会进入事件对列

03:45.570 --> 03:46.610
加总结一下

03:46.610 --> 03:49.410
一个是set timeout和一个是setting turbo

03:49.410 --> 03:50.130
就计时器

03:50.770 --> 03:52.610
计时器本管是哪一个

03:52.610 --> 03:53.890
它的回调啊

03:54.450 --> 03:55.410
时间到达之后

03:55.410 --> 03:56.130
它的回调

03:56.450 --> 03:58.370
它一定是进入事件对列的

03:58.370 --> 03:59.570
进入哪一个对列呢

03:59.570 --> 04:01.810
进入这个红队的

04:03.250 --> 04:04.290
就是普通用户

04:04.290 --> 04:05.330
这是VIP吧

04:05.330 --> 04:06.130
普通用户

04:07.090 --> 04:10.050
然后Promise的Zen函数

04:10.050 --> 04:11.330
它也有一个回调

04:11.330 --> 04:11.970
对吧

04:12.610 --> 04:14.370
Zen函数是不是有个回调

04:15.010 --> 04:16.850
Zen函数里面的回调啊

04:17.410 --> 04:18.530
它是进入的是

04:18.530 --> 04:19.730
它是维对的任务

04:20.050 --> 04:20.930
它进入到哪呢

04:20.930 --> 04:23.250
进入的是这个维对的

04:24.530 --> 04:24.850
知道吧

04:24.850 --> 04:26.050
这个大家记住啊

04:26.210 --> 04:27.170
然后剩下的就是

04:27.170 --> 04:29.650
我们之前还学过这个request animation frame

04:29.650 --> 04:31.490
以及就它的回调呢

04:31.490 --> 04:32.930
是进入那个红队的

04:32.930 --> 04:34.370
以及我们的事件处理函数

04:34.370 --> 04:35.970
比方说点击事件啊

04:35.970 --> 04:37.410
鼠标移入事件啊等等

04:37.410 --> 04:38.290
事件发生的时候

04:38.290 --> 04:39.090
那个函数

04:39.090 --> 04:41.730
它也是先会进入红队的

04:41.730 --> 04:43.170
就我们目前觉得的东西呢

04:43.170 --> 04:44.850
就就是这个Promise任函数

04:44.850 --> 04:46.930
它的回调进入的是维对的

04:46.930 --> 04:48.530
当然它开启函数也是一样啊

04:48.530 --> 04:50.610
开启函数本身就是任的翻版

04:51.490 --> 04:53.410
说这个之前给它补充一下

04:53.410 --> 04:54.930
好接下来我们再做一些面试体

04:55.170 --> 04:57.010
不断的去巩固我们前面学的知识

04:58.290 --> 05:01.810
一共给它出了这么9道面试体

05:02.210 --> 05:03.490
这9道面试体的话

05:03.490 --> 05:04.850
是非常有代表性的

05:04.850 --> 05:05.810
我们来看一看

05:05.810 --> 05:06.290
第一个题

05:07.250 --> 05:09.250
基本上都是为你给的一段代码

05:10.210 --> 05:11.890
让你说出它的输出结果

05:11.890 --> 05:12.690
我们来分析一下

05:13.650 --> 05:15.650
当然你可以先不听我讲

05:15.650 --> 05:18.050
你自己根据我们之前学的知识

05:18.050 --> 05:19.170
包括这些可补充的

05:19.170 --> 05:20.290
这个事件对立的知识

05:21.810 --> 05:23.570
自己想一下它会输入是吧

05:23.730 --> 05:25.170
然后运行一下

05:25.170 --> 05:27.090
看它的输出结果跟你讲的一样吗

05:28.610 --> 05:30.130
好来我们来看一下第一道题

05:31.410 --> 05:32.930
第一道题呢我们这里呢

05:33.890 --> 05:34.850
它问你输出什么

05:34.850 --> 05:35.970
这个我们就打开

05:39.230 --> 05:40.110
打开一个计识本

05:40.110 --> 05:41.470
你们之后做题的时候

05:41.470 --> 05:43.310
千万不要在脑袋里边瞎想

05:43.310 --> 05:44.190
特别容易错

05:45.310 --> 05:48.030
像这种题你本身就有这样的知识

05:48.030 --> 05:48.910
有这样的能力

05:48.910 --> 05:50.750
听我讲了这么多节课之后

05:50.750 --> 05:52.430
本来是能做出来的

05:52.430 --> 05:55.550
结果呢你自己想可能一不留神就做错了

05:56.030 --> 05:57.310
应该拿出一个计识本

05:57.310 --> 05:58.990
或者是拿出一个潮高纸笔盒

05:58.990 --> 06:01.870
只都可以画一画那个事件对立

06:01.870 --> 06:02.830
红对立微对立

06:03.550 --> 06:05.950
那我们平时我们可以用这种方式来记录一下

06:06.590 --> 06:08.830
然后一开始是全举上下稳

06:08.830 --> 06:10.350
对吧或者是我们用一个直升站

06:11.310 --> 06:12.430
然后一个红对立

06:13.550 --> 06:14.270
一个微对立

06:15.150 --> 06:17.310
用这种方式看一下这里边有什么东西

06:17.310 --> 06:18.910
然后再打开一个计识本

06:18.910 --> 06:20.590
然后这里写上输出结果

06:21.150 --> 06:22.430
来把我们一开始

06:22.430 --> 06:23.470
一开始的时候呢

06:23.470 --> 06:25.230
我们是一个全举上下稳

06:26.590 --> 06:28.670
也说这里我们在执行全聚带嘛

06:28.670 --> 06:29.150
对不对

06:30.910 --> 06:31.710
开始执行

06:31.710 --> 06:34.350
开始执行的时候创建了一个Promise

06:34.350 --> 06:35.870
然后给它传了一个回调

06:35.870 --> 06:37.070
注意啊这个回调

06:37.070 --> 06:38.510
它是不进入事件对立的

06:38.510 --> 06:40.110
它是直接执行的

06:40.110 --> 06:41.870
所以直接执行这里是不是输出了1

06:42.430 --> 06:43.470
输出结果你是不是1

06:45.470 --> 06:47.630
接下来我们这里还要开一个

06:47.630 --> 06:49.230
记录一下这个Promise的状态

06:51.630 --> 06:53.390
一开始是平顶嘛这个Promise

06:54.030 --> 06:55.470
新建那个Promise是平顶嘛

06:55.870 --> 06:56.270
对吧

06:56.270 --> 06:57.630
状态永远是平顶

06:57.630 --> 06:58.510
一开始

06:58.510 --> 06:59.790
然后呢输出了一个1

06:59.790 --> 07:00.670
接下来于Row

07:00.670 --> 07:02.190
我是不是把它状态变成了什么

07:02.190 --> 07:03.390
变成了Full Field

07:04.830 --> 07:05.550
数据是什么

07:05.550 --> 07:06.750
数据是ND判的

07:06.750 --> 07:06.910
对吧

07:06.910 --> 07:07.390
就这样的

07:07.390 --> 07:08.750
用这样的方式来记录一下

07:10.430 --> 07:12.190
但是然后我们接着输出2

07:12.190 --> 07:13.470
哎呦我刚才说

07:13.470 --> 07:14.590
那这个状态变了

07:14.590 --> 07:15.550
是不是要运行这个

07:15.550 --> 07:17.630
既然代码都还没有执行到这来

07:17.630 --> 07:18.670
不着急啊

07:18.670 --> 07:20.030
我们这里这个这句话呢

07:20.030 --> 07:21.070
只是改变它的状态

07:21.870 --> 07:23.470
还没法执行执行这个回调

07:24.190 --> 07:26.190
好Row把变状态变了过后了

07:26.190 --> 07:26.990
我们再输出2

07:28.430 --> 07:28.990
没问题吧

07:29.710 --> 07:31.230
它为什么在这里给你加个输出呢

07:31.230 --> 07:32.510
其实就是考察的

07:32.510 --> 07:33.710
可能有些同学有误解

07:33.710 --> 07:34.990
是不是状态一旦确定之后

07:34.990 --> 07:36.590
后边代码就不执行的呢

07:36.590 --> 07:37.230
不是的啊

07:37.230 --> 07:38.430
还是要执行完的

07:38.430 --> 07:40.750
只是后边更改状态代码无销了

07:41.550 --> 07:42.510
只是如此

07:42.510 --> 07:43.870
它其实代码要执行完的啊

07:45.150 --> 07:46.190
好那么我先接下来

07:46.190 --> 07:48.350
把这个Promise就复制给了变量Promise

07:48.910 --> 07:49.230
是吧

07:50.190 --> 07:51.790
接下来我继续代码继续往后走

07:52.670 --> 07:55.230
然后呢这里给他注册了一个回调函数

07:55.230 --> 07:58.350
说你的状态一旦完成之后

07:58.350 --> 07:59.950
请你运行这个回调函数

08:00.830 --> 08:01.390
完成了吗

08:01.950 --> 08:02.590
就完成了

08:02.590 --> 08:04.670
现在状态就是完成的

08:04.670 --> 08:05.790
成功的对吧

08:05.790 --> 08:06.670
成功的时候呢

08:06.670 --> 08:08.030
请你执行这个回调函数

08:08.590 --> 08:10.110
那么按理说的话

08:10.110 --> 08:12.030
现在应该执行这个回调

08:12.030 --> 08:13.150
但是呢你要记住啊

08:13.870 --> 08:15.310
这个Zing函数的回调

08:15.310 --> 08:17.070
是要进入唯一对列的

08:17.070 --> 08:17.950
所以说呢这里呢

08:17.950 --> 08:20.270
虽然说我们实际已经成熟了

08:20.270 --> 08:21.710
但是他的做法呢

08:21.710 --> 08:22.590
是把这个函数

08:22.590 --> 08:23.790
我们把它叫做FN1嘛

08:24.270 --> 08:25.630
把这个函数加到哪呢

08:25.630 --> 08:27.070
是实际上是加到唯一对列的

08:30.530 --> 08:32.850
我们就把它叫做FN1嘛这个函数

08:34.930 --> 08:36.130
实际上放到这的啊

08:36.130 --> 08:37.010
等待执行

08:37.010 --> 08:38.530
因为我们目前的拳击上下门

08:38.530 --> 08:39.730
还没有执行结束对吧

08:40.450 --> 08:42.850
事件那个执行站还没有清空

08:42.850 --> 08:44.050
所以说呢执行站

08:44.050 --> 08:45.410
我们还要继续执行

08:46.770 --> 08:47.570
执行站里面

08:47.570 --> 08:48.850
目前是执行的拳击上下门

08:49.250 --> 08:50.290
我们就再解释就好

08:51.010 --> 08:51.570
放过来吧

08:51.650 --> 08:52.850
我们心里边说到就行了

08:52.850 --> 08:55.490
主要是把个对列和评论状态要记住一下

08:56.290 --> 08:57.810
好那么接下来我们这唯一对列里面

08:57.810 --> 08:58.610
是不是有一个函数啊

08:58.610 --> 08:59.810
我们就把它叫做FN嘛

08:59.810 --> 09:00.530
就这个函数

09:01.170 --> 09:02.770
我们自己可以标记一下

09:02.770 --> 09:04.530
FN3这个函数是要输出3的

09:06.290 --> 09:06.850
对

09:06.850 --> 09:07.890
以后你们

09:07.890 --> 09:09.010
我再跟你们讲啊

09:09.010 --> 09:10.610
你们以后在做比试的时候

09:10.610 --> 09:11.810
一定要用这种方式

09:12.130 --> 09:13.170
不容易出错

09:13.810 --> 09:15.410
虽然这个这个题简单

09:15.410 --> 09:15.890
但是里面要

09:16.770 --> 09:18.130
养成这个习惯

09:18.770 --> 09:19.410
不然的话

09:19.410 --> 09:21.330
你这个本身灰的题

09:21.730 --> 09:22.370
都错后了

09:22.370 --> 09:23.330
那就很划不来

09:24.130 --> 09:25.170
你不会的提错了

09:25.170 --> 09:25.810
你做不出来

09:25.810 --> 09:26.530
那是无所谓嘛

09:26.530 --> 09:26.930
猜嘛

09:26.930 --> 09:27.410
猜错了

09:27.410 --> 09:28.050
无所谓

09:28.050 --> 09:28.930
本来就不会

09:28.930 --> 09:30.530
那你灰的题子都要做错

09:30.530 --> 09:31.650
那就太划不来了

09:32.850 --> 09:33.010
好

09:33.010 --> 09:33.970
我们这里呢

09:33.970 --> 09:34.850
这个函数进入了

09:34.850 --> 09:36.130
v对列等待执行

09:36.130 --> 09:37.650
然后我们继续执行全局上下门

09:37.650 --> 09:38.450
是不是输出了4

09:39.810 --> 09:40.130
好

09:40.130 --> 09:41.650
然后全局上下门执行结束了

09:41.650 --> 09:42.850
没有什么东西可以执行的

09:42.850 --> 09:43.410
这个时候呢

09:43.410 --> 09:46.210
从v对列里边拿出这个函数来执行

09:46.210 --> 09:47.090
是不是输出了3

09:47.730 --> 09:48.050
对吧

09:48.050 --> 09:49.490
就1243

09:50.450 --> 09:51.330
啥的意思

09:51.810 --> 09:52.050
好

09:52.050 --> 09:52.690
我们再运行

09:53.650 --> 09:54.370
就是1243

09:55.090 --> 09:55.250
好

09:55.250 --> 09:55.970
这是第1道题

09:57.890 --> 09:58.210
好

09:58.210 --> 09:58.690
第2道题

10:01.650 --> 10:02.050
来嘛

10:02.050 --> 10:02.530
扛屁过来

10:04.780 --> 10:05.180
扔过来

10:07.180 --> 10:07.900
一样的做法

10:07.900 --> 10:08.300
你们呢

10:08.860 --> 10:09.500
自己试一下

10:11.020 --> 10:11.580
自己试一下

10:11.580 --> 10:12.700
这道题就纯粹端的

10:12.700 --> 10:13.820
就是其实跟刚才的题

10:13.820 --> 10:14.940
没有什么本质的区别

10:16.060 --> 10:16.540
你们试一下

10:16.540 --> 10:18.060
用刚才的分析方式来做一下

10:18.860 --> 10:19.660
好了呗

10:19.660 --> 10:20.860
我不知道你们做的答案

10:20.860 --> 10:21.740
是不是正确的

10:21.820 --> 10:23.100
相信如果说你听懂了

10:23.100 --> 10:24.460
我之前的解释的话

10:24.460 --> 10:25.500
应该能够做出来

10:25.500 --> 10:25.740
好

10:25.740 --> 10:26.060
又来吧

10:26.620 --> 10:28.060
这里创建了一个promise

10:28.060 --> 10:29.500
那么我们这里的有一个promise

10:30.060 --> 10:31.420
它的状态是什么呢

10:31.420 --> 10:31.820
Pending

10:32.460 --> 10:32.780
写好

10:33.980 --> 10:36.060
接下来运行这个任务

10:36.060 --> 10:36.860
开始进行

10:36.860 --> 10:38.140
任务开始进行

10:38.140 --> 10:38.780
输出1

10:40.540 --> 10:41.180
接下来

10:41.180 --> 10:42.060
see time out

10:42.060 --> 10:42.940
这里有个函数

10:43.660 --> 10:45.180
那么我没有传第二个参数

10:45.180 --> 10:46.060
就是没有传这个

10:46.780 --> 10:47.660
等待时间

10:47.660 --> 10:48.380
没有传等待时间

10:48.380 --> 10:49.340
就相当于是传了个0

10:50.620 --> 10:51.580
说明这个函数

10:51.900 --> 10:53.020
马上要被执行

10:53.580 --> 10:53.820
对吧

10:53.820 --> 10:56.380
这个时间循环的知识

10:56.380 --> 10:57.900
不需要重新的演示了吧

10:57.900 --> 10:59.420
调用这个see time out函数

11:01.260 --> 11:02.380
see time out函数

11:03.500 --> 11:05.100
通知计时现成

11:05.100 --> 11:05.740
理过计时

11:06.460 --> 11:07.500
计时结束过后来

11:07.500 --> 11:08.940
运行一个函数fn

11:08.940 --> 11:10.060
计时马上就结束了

11:10.540 --> 11:11.980
所以放到v队的

11:11.980 --> 11:12.620
要红队的

11:13.740 --> 11:14.380
对吧

11:14.380 --> 11:15.340
进入这了

11:15.340 --> 11:15.980
所以说呢

11:15.980 --> 11:17.500
我们这一步执行完了之后

11:18.060 --> 11:19.740
实际上我们的红队的里面

11:19.740 --> 11:20.540
有一个函数

11:20.540 --> 11:21.100
就是fn

11:21.900 --> 11:22.700
你行里面的行数

11:22.700 --> 11:24.060
就是这个函数就行了

11:24.060 --> 11:25.340
要进入到红队的

11:25.340 --> 11:26.140
等待被执行

11:26.140 --> 11:27.100
现在执行完了没

11:27.100 --> 11:28.060
没有执行

11:28.060 --> 11:29.820
然后把这个promise负责给谁

11:29.820 --> 11:31.260
负责给这个变量

11:33.180 --> 11:33.740
负责给他

11:35.340 --> 11:35.740
对吧

11:35.740 --> 11:37.340
所以他的状态是喷顶

11:37.340 --> 11:38.540
因此如果说你在这里

11:38.540 --> 11:40.220
去输出这个promise

11:40.220 --> 11:41.500
之前是不是可以解释了

11:42.300 --> 11:43.820
为什么在这里输出promise

11:44.380 --> 11:45.580
得到的状态呢是什么

11:46.300 --> 11:48.300
得到的状态是喷顶

11:48.300 --> 11:48.940
就这个原因

11:52.910 --> 11:54.190
得到的状态是不是喷顶

11:55.550 --> 11:56.190
对吧

11:56.190 --> 11:56.670
好

11:56.670 --> 11:58.110
就继续来分析

12:04.380 --> 12:04.700
好

12:04.700 --> 12:05.500
现在这些东西

12:05.500 --> 12:06.620
大家都还不执行

12:06.620 --> 12:08.140
一个函数在红队的里面

12:08.140 --> 12:08.860
本代执行

12:09.500 --> 12:09.740
好

12:09.740 --> 12:10.380
接下来

12:10.380 --> 12:11.420
告诉这个promise

12:12.060 --> 12:15.420
如果说你成功之后

12:15.420 --> 12:16.620
请运行这个回调

12:16.620 --> 12:18.220
那么这里现在有个问题了

12:18.220 --> 12:19.340
这个回调函数

12:19.340 --> 12:20.940
现在进不进围队

12:22.700 --> 12:23.180
进不进

12:24.460 --> 12:25.180
不进的

12:25.900 --> 12:27.100
为什么不进呢

12:27.100 --> 12:28.780
他要等他完成之后

12:28.860 --> 12:29.740
才能进围队里

12:29.740 --> 12:30.620
现在是完成吧

12:31.100 --> 12:32.300
现在是挂起的状态

12:32.300 --> 12:32.620
对吧

12:32.620 --> 12:33.420
所以说这个函数

12:33.980 --> 12:35.100
是不会进入围队里的

12:35.580 --> 12:36.700
你只要等这个函数

12:36.700 --> 12:37.580
什么时候进围队里

12:37.580 --> 12:38.060
我都

12:38.060 --> 12:39.020
我一些不清楚

12:39.020 --> 12:39.820
他什么时候完成

12:39.820 --> 12:40.700
什么时候进围队里

12:41.260 --> 12:42.060
所以这个函数

12:42.060 --> 12:42.860
现在还不着急

12:43.260 --> 12:44.540
我只是告诉promise

12:44.540 --> 12:45.020
以后

12:45.500 --> 12:46.540
将来有一天

12:46.540 --> 12:47.820
比方说你一年之后

12:47.820 --> 12:48.300
完成了

12:48.300 --> 12:49.340
那一年之后

12:49.340 --> 12:50.540
这个函数进围队里

12:50.540 --> 12:51.340
是这么个意思

12:52.140 --> 12:52.380
好

12:52.380 --> 12:53.260
然后就输出5

12:53.260 --> 12:54.700
所以说这里可能看到的输出

12:54.700 --> 12:55.900
最开始就是一和五

12:57.260 --> 12:57.500
好

12:58.220 --> 12:58.700
时间

12:59.340 --> 13:00.540
接着干嘛呢

13:00.540 --> 13:01.740
全局上下文执行结束了

13:01.740 --> 13:02.460
没事情做了

13:02.460 --> 13:03.020
对吧

13:03.020 --> 13:04.780
就把红队列的东西

13:04.780 --> 13:05.500
是不是拿出来执行

13:06.060 --> 13:06.700
执行哪

13:06.700 --> 13:07.660
是不是执行这个函数

13:08.140 --> 13:09.500
执行这个函数的过程中

13:09.500 --> 13:10.620
红队列拿出来执行了

13:11.260 --> 13:12.380
执行这个函数的过程中

13:12.380 --> 13:13.020
输出了什么

13:13.020 --> 13:13.580
输出了2

13:15.900 --> 13:17.500
然后把这个promise的状态

13:17.500 --> 13:17.980
改为了

13:19.020 --> 13:19.580
forfield

13:21.500 --> 13:22.300
数据上离贩

13:23.420 --> 13:24.380
然后再输出3

13:27.010 --> 13:27.570
好

13:27.570 --> 13:28.850
应该是这样的过程

13:29.170 --> 13:29.570
不好意思

13:30.370 --> 13:31.330
先输出2

13:31.330 --> 13:33.010
然后更改状态

13:33.010 --> 13:34.050
改状态的时候

13:34.770 --> 13:36.130
之前是不是说好的

13:36.130 --> 13:38.450
你一旦完成之后执行这个函数

13:39.170 --> 13:39.730
对吧

13:39.730 --> 13:41.170
所以说这里状态一变

13:41.170 --> 13:42.210
这个时候

13:42.210 --> 13:45.010
它会把这个函数加入到围队里

13:45.010 --> 13:47.330
这个函数我们鼓起把它命名为FN4

13:47.330 --> 13:47.810
输出4

13:49.650 --> 13:49.810
好

13:49.810 --> 13:50.690
但是那些不执行

13:50.690 --> 13:51.890
执行执行围队列

13:51.890 --> 13:52.930
不执行

13:52.930 --> 13:53.250
为什么

13:53.250 --> 13:54.770
因为我们现在执行站还有东西

13:54.770 --> 13:55.410
没执行完

13:55.890 --> 13:57.330
你不能说把这个函数执行到

13:57.330 --> 13:58.930
一半跑去执行围队列的

13:58.930 --> 14:00.530
虽然说你是VIP

14:00.530 --> 14:01.810
但是前面那个客户

14:03.090 --> 14:04.610
VIP可以插队

14:04.610 --> 14:05.730
但是前面那个客户

14:05.730 --> 14:07.410
你不能说办业务办了一半

14:09.170 --> 14:10.770
然后你把它走

14:10.770 --> 14:12.770
然后把后边的客户再过来

14:12.770 --> 14:13.650
不能这样子

14:13.650 --> 14:14.850
这样子太霸道了

14:14.850 --> 14:16.370
所以这个还说要执行完

14:16.370 --> 14:18.850
执行站必须要清空之后

14:18.850 --> 14:20.050
再看围队列

14:20.050 --> 14:21.010
再看这个队列

14:21.730 --> 14:23.410
然后先找围队列再找空队列

14:23.410 --> 14:24.530
但是平时正在执行

14:24.530 --> 14:25.250
你不能打断

14:26.130 --> 14:27.570
然后再输出杀

14:29.250 --> 14:29.490
对吧

14:29.490 --> 14:30.770
然后这个函数是不是执行完了

14:31.570 --> 14:32.210
好执行完了

14:32.210 --> 14:33.170
执行站清空了

14:33.170 --> 14:34.290
没有什么东西可以执行的

14:34.290 --> 14:36.130
这个时候把围队列里面的东西

14:36.130 --> 14:37.730
FN4拿出来执行

14:37.730 --> 14:38.610
也就是输出4

14:39.330 --> 14:40.530
15234

14:42.210 --> 14:42.530
好

14:43.490 --> 14:43.890
进行

14:45.090 --> 14:45.890
15234

14:46.690 --> 14:47.490
这些题呢

14:47.490 --> 14:49.810
其实无论它怎么考虑

14:49.810 --> 14:52.450
它可以用各种各样的变形变种

14:52.450 --> 14:53.570
都无所谓

14:53.570 --> 14:54.610
比方说我们这里呢

14:54.690 --> 14:55.490
还可以把这个题呢

14:55.490 --> 14:56.690
又变成这样的形式

14:56.690 --> 14:57.010
维热

14:58.210 --> 14:59.810
然后再在上边去设置一个

15:00.530 --> 15:01.250
set timeout

15:04.540 --> 15:05.420
这里输出一个

15:06.620 --> 15:10.540
1 2 3 4

15:11.340 --> 15:11.580
好

15:11.580 --> 15:12.380
那看这个题吧

15:14.140 --> 15:15.180
那到底是一样的

15:15.180 --> 15:16.060
里面自己先做一下

15:17.260 --> 15:18.060
好 我来讲一讲

15:18.860 --> 15:19.900
首先到第一步

15:20.540 --> 15:22.380
0秒后运行这个函数

15:22.380 --> 15:23.100
所以说一开始呢

15:23.100 --> 15:23.820
有个红队列

15:25.580 --> 15:26.380
红队列里边

15:26.860 --> 15:28.060
是一个函数 FN

15:28.620 --> 15:29.420
就这个函数

15:29.420 --> 15:30.780
把FN1输出1

15:31.660 --> 15:32.620
到红队列

15:32.620 --> 15:33.500
然后接着执行

15:34.940 --> 15:35.660
执行的时候呢

15:35.660 --> 15:36.700
就得到一个promise

15:36.700 --> 15:37.660
这个promise的状态呢

15:37.660 --> 15:38.780
一开始是平顶

15:38.780 --> 15:40.060
然后呢输出一个2

15:40.860 --> 15:41.260
对吧

15:41.740 --> 15:42.860
然后把一个promise的状态

15:42.860 --> 15:43.740
改成fulfilled的

15:46.060 --> 15:46.940
数据商计犯的

15:48.140 --> 15:49.340
把这个promise的负责给它

15:49.340 --> 15:50.700
那么它的状态就是这个东西

15:51.660 --> 15:53.660
接下来告诉promise

15:53.660 --> 15:54.860
如果说你完成了

15:54.860 --> 15:55.900
运行这个毁掉函数

15:57.420 --> 15:58.140
完成了吗

15:58.140 --> 15:58.860
就完成了

15:59.260 --> 15:59.580
所以说

15:59.580 --> 16:01.340
维队列里边就会加入一个毁掉函数

16:01.900 --> 16:02.540
FN3

16:02.860 --> 16:03.900
输出3的毁掉函数

16:04.700 --> 16:05.580
然后再输出4

16:06.300 --> 16:07.500
接下来执行站轻空了

16:07.500 --> 16:08.620
没有什么东西可以执行的

16:09.420 --> 16:10.140
然后我们就看什么

16:10.140 --> 16:10.860
看时间对列

16:11.420 --> 16:12.300
VIP先来

16:12.860 --> 16:13.580
FN3

16:13.580 --> 16:14.300
是不是先运行它

16:15.100 --> 16:15.580
输出3

16:16.620 --> 16:17.580
好 维队列轻空

16:18.700 --> 16:19.900
然后再看红队列

16:20.460 --> 16:21.020
FN1

16:22.540 --> 16:23.740
是不是领达输出1

16:23.740 --> 16:24.860
那么这是2 131

16:28.620 --> 16:29.100
对吧

16:29.260 --> 16:30.540
用这种方式去解题

16:31.980 --> 16:32.940
好 下道题

16:33.100 --> 16:33.740
第三题

16:36.750 --> 16:37.950
这道题我们好像是说谱的

16:40.370 --> 16:40.690
来吧

16:40.690 --> 16:41.330
我们再来一次

16:46.750 --> 16:47.950
首先你们先做

16:47.950 --> 16:49.070
北道题都是你们先做

16:49.070 --> 16:49.790
自己先做

16:49.790 --> 16:50.670
那做来听我讲

16:51.310 --> 16:54.190
好 首先是拿到这个promise

16:55.310 --> 16:55.950
状态是什么

16:55.950 --> 16:56.590
平底

16:56.590 --> 16:57.710
想都没有想先写出来

16:58.670 --> 17:00.750
然后说它冒着1秒钟过后

17:02.670 --> 17:03.790
1秒钟过后

17:03.870 --> 17:04.750
运行这个函数

17:05.310 --> 17:06.510
所以说我们这里可以

17:06.510 --> 17:07.390
简单记录一下

17:08.110 --> 17:13.070
1秒后运行某一个函数

17:13.070 --> 17:14.910
就是有个计时现成的那一计时

17:14.910 --> 17:16.030
1秒后运行谁

17:16.030 --> 17:17.230
运行这个FN吗

17:18.030 --> 17:19.070
把这个函数叫做FN

17:20.110 --> 17:21.310
好 现在1秒钟的话

17:21.310 --> 17:22.910
还早 继续往后执行

17:23.470 --> 17:25.950
然后高promise1 catch

17:28.270 --> 17:29.470
是不是promise1

17:29.470 --> 17:30.590
如果失败的时候

17:30.590 --> 17:31.310
运行这个回掉

17:31.310 --> 17:31.950
现在失败了吗

17:32.750 --> 17:33.230
没有吧

17:33.230 --> 17:35.230
现在是平底还是挂起阶段

17:35.310 --> 17:36.430
我都不知道要不要失败

17:36.430 --> 17:37.070
对吧

17:37.070 --> 17:38.990
任务都还没有结果

17:38.990 --> 17:40.350
所以我也不知道要不要失败

17:40.350 --> 17:41.070
给他说一声

17:41.870 --> 17:42.510
失败之后

17:43.710 --> 17:45.470
失败后运行了

17:45.470 --> 17:46.430
这个是FN2

17:47.950 --> 17:49.710
那么得到一个新的promise

17:49.710 --> 17:50.910
刚才的是promise1

17:54.880 --> 17:57.680
那么这个promise1调用开启方法

17:57.680 --> 17:59.520
是返回一个新的promise

17:59.520 --> 18:01.120
那么promise2的状态是什么

18:02.560 --> 18:04.160
好 这个地方考察的是啥

18:04.160 --> 18:05.360
考察是这一块的指示

18:06.320 --> 18:07.120
练习调用

18:09.700 --> 18:10.500
练习调用为止

18:10.500 --> 18:11.460
你自己去看一下

18:11.460 --> 18:13.220
我们之前也是反复地讲过的

18:14.420 --> 18:17.460
他的状态取决于前面这个任务的状态

18:17.460 --> 18:18.660
前面是挂起

18:18.660 --> 18:19.620
无论是什么情况

18:19.620 --> 18:20.180
前面是挂起

18:20.180 --> 18:20.980
他一定挂起

18:20.980 --> 18:22.100
百分之百挂起

18:22.100 --> 18:23.620
所以他的状态一定是挂起

18:25.620 --> 18:25.860
是吧

18:25.860 --> 18:28.740
他的状态他也没有结果

18:28.740 --> 18:31.380
好 接下来输出promise1和promise2

18:31.380 --> 18:32.900
那么promise1的状态

18:33.700 --> 18:34.580
是不是

18:34.580 --> 18:35.060
平底

18:36.020 --> 18:38.180
promise2的状态是不是平底

18:39.300 --> 18:39.700
对吧

18:40.740 --> 18:42.180
然后这种两秒后

18:42.740 --> 18:43.220
又来

18:44.100 --> 18:46.180
两秒后运行什么呢

18:46.180 --> 18:48.100
运行这个回交

18:48.100 --> 18:49.140
我们把它叫FN3

18:50.740 --> 18:52.660
好 接下来我们现在事情是不是说完了

18:52.660 --> 18:53.620
没有什么办法可以执行

18:54.580 --> 18:55.540
接下来我们等什么

18:55.540 --> 18:56.180
就等时间

18:57.060 --> 18:58.340
1秒后这个东西到了

18:59.700 --> 19:00.500
1秒后就到了

19:00.500 --> 19:01.460
是不是运行这个函数

19:02.180 --> 19:02.900
这个函数要干嘛

19:03.620 --> 19:07.780
是不是把promise1的状态改为fulfilled

19:08.660 --> 19:09.780
数据上述

19:11.300 --> 19:11.620
对吧

19:13.460 --> 19:15.620
好 那么promise1的状态

19:15.620 --> 19:17.380
那么1秒后就完成这个事

19:17.940 --> 19:19.140
他就做了这么一件事

19:20.100 --> 19:22.660
好 那么promise1的状态变成fulfilled之后

19:23.060 --> 19:26.420
有这么连续几两件事就可以确定了

19:27.060 --> 19:27.780
第一件事

19:29.620 --> 19:31.940
promise1有没有成

19:32.020 --> 19:32.980
它是成功了 对吧

19:32.980 --> 19:34.260
有没有成功的回掉

19:34.900 --> 19:36.420
没有 它只有失败的回掉

19:37.060 --> 19:38.660
说成功的回掉没法执行上

19:39.700 --> 19:40.260
第二

19:41.700 --> 19:42.980
后边这个任务的状态

19:43.540 --> 19:44.820
要发生相应的变化

19:45.380 --> 19:46.420
怎么变化呢

19:46.420 --> 19:47.300
看那个123

19:49.140 --> 19:50.100
看这123

19:50.100 --> 19:51.220
三条规则

19:54.720 --> 19:55.280
什么情况

19:56.320 --> 19:59.120
前边这个任务完成了

19:59.120 --> 20:01.200
但是后边

20:01.200 --> 20:04.160
它没有针对完成做相应的处理

20:04.240 --> 20:05.600
没有相应的后续处理

20:06.160 --> 20:08.640
这就导致了后边那个任务的状态

20:08.640 --> 20:11.440
和数据跟前边那个任务保持一致

20:14.180 --> 20:16.020
所以promise2的状态变成这样子了

20:17.380 --> 20:18.340
那就变成这样子了

20:18.740 --> 20:19.700
这个函数执行吗

20:19.700 --> 20:20.580
它不执行

20:20.580 --> 20:22.100
因为它是失败的回掉

20:22.100 --> 20:23.300
并不是成功的回掉

20:24.180 --> 20:25.140
没什么意思吧

20:25.140 --> 20:26.420
所以这个函数是不执行的

20:27.460 --> 20:29.380
然后呢 两秒后我们再输出

20:30.180 --> 20:32.100
输出两个promise得到的结果就是

20:32.100 --> 20:32.900
就这样的结果

20:33.220 --> 20:36.740
好 这道题就这样子出来了

20:37.620 --> 20:38.020
应行

20:39.700 --> 20:40.260
两秒后

20:41.300 --> 20:42.260
你看 回去出来了

20:42.820 --> 20:43.540
两个都完成

20:43.540 --> 20:44.260
数据都是二级

20:46.860 --> 20:47.580
好 再来看啊

20:47.580 --> 20:49.580
如果说我这里写的是瑞金的成本

20:49.580 --> 20:50.380
又来分析一下

20:54.350 --> 20:54.910
又来呗

20:56.590 --> 20:59.310
好 那么刚才的唯一的变化就是什么呢

20:59.310 --> 21:00.670
变化就是在这

21:01.230 --> 21:02.830
一开始都没有问题的

21:02.830 --> 21:03.470
都是陪你啊

21:03.470 --> 21:04.590
这个里面自己去分析

21:05.630 --> 21:06.110
就在这

21:06.830 --> 21:09.550
我这个一秒后把这个瑞借个车的时候呢

21:09.550 --> 21:11.150
它的状态不是fulfilled的了

21:11.150 --> 21:12.510
它的状态是什么瑞借个车

21:14.190 --> 21:14.910
原因是什么

21:14.910 --> 21:15.630
原因没有给

21:15.630 --> 21:16.830
没有给的话就是undefined

21:18.670 --> 21:19.470
会变这样子

21:20.030 --> 21:21.870
然后promise二的状态是什么呢

21:23.310 --> 21:24.750
它被拒绝了

21:24.750 --> 21:26.110
有没有后续处理

21:26.110 --> 21:27.310
你看是不是有后续处理

21:28.110 --> 21:29.710
FN2要做什么

21:29.710 --> 21:30.830
进入围队力

21:32.350 --> 21:33.150
对吧

21:33.150 --> 21:34.750
FN2是要进入围队力执行

21:35.710 --> 21:38.830
那么promise二的状态就取决于

21:38.830 --> 21:40.350
这个函数的执行结果

21:41.070 --> 21:42.750
所以说这个时候要去执行这个函数

21:43.470 --> 21:45.310
而这个函数执行的过程中

21:45.310 --> 21:46.430
有没有错误啊

21:46.430 --> 21:47.470
没有错误

21:47.470 --> 21:48.190
没有错误

21:48.190 --> 21:49.150
那么promise二

21:49.710 --> 21:51.310
得到的状态就是fulfilled

21:52.510 --> 21:53.230
数据是什么

21:53.230 --> 21:54.190
数据是二

21:54.190 --> 21:55.390
返回的结果就是它的数据

21:56.910 --> 21:57.790
好 因此呢

21:57.790 --> 21:59.790
两秒后把这两个promise输出

21:59.790 --> 22:00.830
得到的结果就是这样子

22:04.260 --> 22:04.820
好 看一下

22:10.420 --> 22:11.060
那里看

22:11.060 --> 22:11.700
是不是这样子

22:14.100 --> 22:15.460
好 这是这种题啊

22:15.460 --> 22:16.980
得练书雕用这一块呢会

22:18.020 --> 22:18.580
有点糟

22:19.540 --> 22:21.060
但是你按照我这个分析的话

22:21.060 --> 22:21.940
是没有任何问题的

22:24.290 --> 22:25.410
好 接下来下一道题

22:26.290 --> 22:30.860
三四

22:31.660 --> 22:32.220
好 这道题

22:35.470 --> 22:35.870
看一下吧

22:37.870 --> 22:38.830
这道题是不是

22:40.990 --> 22:42.270
其实这道题呢本质上呢

22:42.270 --> 22:43.630
也就是考的是promise

22:43.630 --> 22:44.190
只剩的

22:44.190 --> 22:45.470
它确定用了语法堂

22:45.550 --> 22:47.630
就是I think和await

22:48.670 --> 22:49.390
那干扰你

22:49.390 --> 22:50.830
其实本质上就是promise

22:51.710 --> 22:52.190
来吧

22:53.630 --> 22:54.910
这里是函数声明

22:54.910 --> 22:55.150
对吧

22:55.150 --> 22:57.070
声明函数它不会导致之之任何结果

22:57.070 --> 22:58.990
我们关键是关注的是函数雕用

22:59.550 --> 23:00.830
这里雕用了m函数

23:02.910 --> 23:03.950
是不是雕用了m函数

23:04.910 --> 23:06.030
m函数里边

23:06.750 --> 23:08.590
我们等待了一个e

23:08.590 --> 23:09.870
等待e是什么呢

23:09.870 --> 23:11.950
是不是等待了promise

23:12.590 --> 23:13.550
resulte

23:13.550 --> 23:15.230
相当于是这样子写的对吧

23:15.310 --> 23:16.190
我之前说过的

23:16.190 --> 23:17.550
这里如果说直接写个数据的话

23:17.550 --> 23:18.910
就相当于是用这种方式来写

23:19.950 --> 23:20.750
等待一个e

23:21.390 --> 23:22.910
是不是等待了一个promise完成

23:23.710 --> 23:24.990
那么后边注意

23:24.990 --> 23:26.830
注意看我鼠标框住的一部分

23:26.830 --> 23:27.550
这一部分

23:28.110 --> 23:29.550
这一部分的代码

23:29.550 --> 23:33.070
实际上是在一个事件对列里

23:34.990 --> 23:35.950
你怎么理解呢

23:37.390 --> 23:38.430
你把这个函数

23:39.390 --> 23:40.590
想象成这种格式

23:41.150 --> 23:41.790
你就明白了

23:42.670 --> 23:44.190
因为而圣诞只是个语法堂

23:50.460 --> 23:52.940
等待e

23:53.500 --> 23:54.620
应该是这样子写的

23:55.740 --> 23:57.580
return的是promise

23:57.580 --> 23:58.540
resulte

23:59.820 --> 24:00.540
等待e

24:00.540 --> 24:01.100
返回的是

24:02.620 --> 24:04.140
然后z

24:08.300 --> 24:09.420
所以说看到没

24:09.420 --> 24:10.540
它实际上是这么写的

24:11.580 --> 24:13.980
把这个给n负值

24:15.020 --> 24:16.540
放到这参数里边

24:16.540 --> 24:18.140
然后再输出n放到这

24:18.860 --> 24:20.620
明儿里说它本质上是这个样子

24:23.040 --> 24:23.920
所以说我们再回来

24:23.920 --> 24:24.640
看这个参数

24:27.740 --> 24:29.980
我们在这边再给它加一个

24:29.980 --> 24:30.620
加一个输出

24:31.420 --> 24:31.900
输出0

24:32.460 --> 24:33.020
好来吧

24:33.660 --> 24:34.860
运行这个函数

24:34.860 --> 24:36.700
运行这个函数是不是马上就会输出0

24:36.700 --> 24:37.420
这个没问题吧

24:38.060 --> 24:39.260
这个函数马上得到运行

24:39.260 --> 24:39.740
输出0

24:40.380 --> 24:41.900
好接下来等待e

24:43.340 --> 24:45.020
那么后边是不是全在 n 里边

24:45.740 --> 24:47.500
那么相当于是这个给n负值

24:48.060 --> 24:49.660
给n负值的这个代码

24:49.660 --> 24:50.860
和给这个输出n

24:51.660 --> 24:52.780
是不是都在 n 里边

24:53.900 --> 24:54.300
对吧

24:54.300 --> 24:55.500
它等待完成之后

24:55.500 --> 24:56.460
我才给它负值嘛

24:56.460 --> 24:57.020
n 是什么

24:57.100 --> 24:58.620
n 是这个完成之后的数据

24:59.180 --> 25:00.620
这个完成的数据是不是就是e

25:01.180 --> 25:01.500
对吧

25:01.500 --> 25:03.020
e 的本质就是这个

25:04.060 --> 25:04.460
在这里

25:04.460 --> 25:05.340
而为此后边写e

25:05.340 --> 25:06.380
就相当于是写了这个

25:06.380 --> 25:07.180
我们之前说过的

25:08.300 --> 25:09.260
那么相当于是这个

25:09.260 --> 25:10.300
Promise 完成之后

25:10.300 --> 25:11.580
我才去运行这个代码

25:11.580 --> 25:13.260
所以给n负值的代码

25:13.260 --> 25:14.300
和给输出n

25:15.260 --> 25:16.140
实际上它本质

25:16.940 --> 25:19.100
是在w1对列里边

25:20.940 --> 25:21.740
我们就输出

25:22.700 --> 25:23.740
相当于输出1

25:23.740 --> 25:25.660
是在w1对列里边这个代码

25:26.380 --> 25:27.260
原来的意思吧

25:27.260 --> 25:28.220
你要这么去看

25:28.220 --> 25:29.740
因为它用语法藏在干扰里

25:30.860 --> 25:32.060
比方说那这个

25:32.060 --> 25:33.340
这里Promise等待一年

25:33.340 --> 25:35.980
那我就在这里卡住等待一年嘛

25:35.980 --> 25:37.180
那不可能啊

25:37.180 --> 25:39.660
我们说过GS是一个异部的语言

25:40.220 --> 25:42.060
它不可能有组色的

25:42.060 --> 25:43.180
它不会真正的去等待

25:43.180 --> 25:44.620
我就干别的事去了

25:44.620 --> 25:45.180
什么时候玩

25:45.180 --> 25:47.180
我就在接着把后边的代码执行了

25:48.060 --> 25:50.300
因此我调用m函数

25:50.300 --> 25:51.740
它输出了0之后

25:51.740 --> 25:52.860
它不会让这

25:52.860 --> 25:54.460
这里不会让m函数卡住

25:55.180 --> 25:56.780
所以这里一定要清楚

25:56.780 --> 25:58.460
它不会让m函数卡住

25:58.460 --> 26:00.060
m函数就直接结束了

26:00.060 --> 26:01.020
在这里就结束了

26:01.980 --> 26:03.180
就像这里一样

26:03.180 --> 26:05.020
调用m函数返回一个Promise

26:05.020 --> 26:05.420
结束了

26:06.380 --> 26:07.980
它不是说我一定要等到

26:07.980 --> 26:09.980
这个回调执行过后才结束

26:09.980 --> 26:10.940
那你这样想吧

26:10.940 --> 26:11.820
我这个任务

26:11.820 --> 26:12.940
异部任务嘛

26:12.940 --> 26:14.860
我这个任务不是立即完成的

26:14.860 --> 26:16.780
我是要等10年才完成

26:17.500 --> 26:19.500
那你说你这个函数要再卡10年

26:20.460 --> 26:21.820
后边代码就不运行了

26:21.820 --> 26:23.260
一直在等它卡10年

26:23.420 --> 26:23.980
那可能吗

26:23.980 --> 26:24.540
不可能了

26:25.340 --> 26:25.980
所以说

26:25.980 --> 26:27.740
函数马上就去

26:27.740 --> 26:28.620
瞬间就结束了

26:29.900 --> 26:31.500
一运行返回一个Promise结束了

26:32.780 --> 26:34.940
这些代码等Promise完成之后

26:34.940 --> 26:35.820
它自然会去运行

26:36.380 --> 26:37.900
所以这里把它换成这种格式

26:37.900 --> 26:38.860
实际上是一样的

26:38.860 --> 26:39.580
我输出了0

26:41.020 --> 26:42.140
遇到这个代码

26:42.140 --> 26:42.860
这个函数结束了

26:43.500 --> 26:44.220
接下来输出2

26:45.420 --> 26:46.380
你要这样子去看

26:47.740 --> 26:48.940
输出2完了之后

26:51.820 --> 26:53.180
再看V队列

26:53.900 --> 26:55.740
V队列是不是在运行这个代码

26:56.700 --> 26:58.140
给N负质再输出N

26:58.620 --> 26:59.340
是不是输出1

27:00.860 --> 27:01.660
所以这个代码

27:01.660 --> 27:03.740
这道题的答案是021

27:06.820 --> 27:07.220
是吧

27:08.260 --> 27:09.700
好好去理一下

27:11.220 --> 27:11.780
这道题

27:12.420 --> 27:13.300
下面第五题

27:18.380 --> 27:20.460
也是考堂类似的东西

27:21.660 --> 27:23.020
稍微做了一下变化

27:23.580 --> 27:24.860
也就是刚才的题做了一下

27:24.860 --> 27:25.900
稍微做了一下变化

27:25.900 --> 27:27.580
那么我这里还是从0开始输出

27:28.460 --> 27:29.500
来看一下这个题

27:39.020 --> 27:40.140
本质上是一样的

27:41.740 --> 27:42.220
来吧

27:42.220 --> 27:43.020
这里是一个函数

27:43.020 --> 27:43.980
说明不用管它

27:43.980 --> 27:45.340
这里是一个立即执行函数

27:45.340 --> 27:46.780
那么执行的是谁

27:46.780 --> 27:47.660
执行的是这个函数

27:48.460 --> 27:48.700
对吧

27:48.700 --> 27:49.420
执行这个函数

27:49.420 --> 27:50.460
然后执行这个函数

27:51.420 --> 27:52.540
调用M函数

27:54.880 --> 27:55.840
调用M函数

27:55.840 --> 27:56.560
是不是在调用这个

27:57.040 --> 27:58.240
那么先执行M函数

27:58.560 --> 27:59.120
M函数

27:59.920 --> 28:00.240
好

28:00.240 --> 28:01.680
执行M函数是不是先输出0

28:03.200 --> 28:03.520
对吧

28:04.720 --> 28:05.920
然后等待1

28:08.000 --> 28:08.880
等待1

28:10.240 --> 28:12.000
我这里是不是不会卡住

28:12.560 --> 28:13.200
不会卡住

28:13.200 --> 28:14.720
这个函数立即有执行结束了

28:15.600 --> 28:17.840
所以说我们这后边给N负质

28:17.840 --> 28:18.880
输出N在哪

28:18.880 --> 28:20.000
在V队里

28:22.160 --> 28:23.680
给N负质输出N

28:23.680 --> 28:25.120
那就相当于是输出1嘛

28:25.120 --> 28:26.960
所以说输出1是在哪

28:26.960 --> 28:28.480
是在V队里边等着

28:29.920 --> 28:30.160
好

28:30.160 --> 28:31.360
那么就回过头来

28:31.360 --> 28:33.120
这个M函数是不是返回了一个Promise

28:34.960 --> 28:36.400
M函数是不是返回了一个Promise

28:37.760 --> 28:38.640
那么请问

28:39.040 --> 28:40.320
我现在问大家一个问题

28:41.440 --> 28:43.200
这个Promise的状态是啥

28:45.360 --> 28:47.280
也就是说我现在把这个代碼全部去掉

28:47.280 --> 28:48.000
全部去掉

28:48.000 --> 28:49.680
我输出一下M函数

28:49.680 --> 28:51.120
调用M函数的返回结果

28:51.120 --> 28:52.720
这个就一定是输出Promise对吧

28:52.720 --> 28:53.520
就毫无疑问

28:53.520 --> 28:54.800
因为它是耳声可标记的

28:55.200 --> 28:56.720
那么这个函数的状态是啥

28:57.040 --> 28:58.160
这个时候输出的状态

28:58.560 --> 28:59.600
我们先把这个东西看懂

29:01.520 --> 29:02.080
状态是啥

29:03.760 --> 29:05.760
状态是平顶挂机

29:05.760 --> 29:07.040
为什么是平顶呢

29:07.200 --> 29:09.120
因为这个函数还没完

29:09.120 --> 29:11.040
虽然说我们知道它已经运行完了

29:11.040 --> 29:14.080
但是这个Promise返回了一个Promise

29:14.080 --> 29:15.440
这个Promise是什么时候结束

29:15.440 --> 29:16.880
它要把这里边的代码运行完了

29:16.880 --> 29:17.840
过后才结束

29:18.080 --> 29:18.640
才完成

29:19.040 --> 29:19.440
对吧

29:19.440 --> 29:20.720
因为这个代码运行完了之后

29:20.720 --> 29:22.160
才能确定返回之

29:22.160 --> 29:23.840
我这里相当于是返回了Angie Fan的

29:25.200 --> 29:26.480
这个函数没有运行完

29:26.480 --> 29:28.240
这个代码都还没有运行完

29:28.240 --> 29:31.600
所以说这个Promise还没有结束

29:33.200 --> 29:35.040
因此我们如果说这个时候

29:35.040 --> 29:36.560
这个是时间减去输出

29:36.720 --> 29:37.520
得到的就是平顶

29:39.200 --> 29:39.760
没什么意思

29:44.860 --> 29:46.300
因为这个函数还没运行完

29:46.300 --> 29:48.700
如果说把这段代码运行完了之后

29:48.700 --> 29:49.660
就输出1

29:49.660 --> 29:51.260
从微队那边取出完了过后

29:51.260 --> 29:52.460
那么这个函数的

29:52.460 --> 29:54.460
返回了Promise状态就可以确定了

29:54.460 --> 29:55.980
所以说我们再回到刚才的问题

29:57.900 --> 29:58.540
有点绕

29:59.740 --> 30:00.460
先输出0

30:01.420 --> 30:03.260
然后M函数就运行完了

30:03.820 --> 30:04.380
等待1

30:04.380 --> 30:05.900
还不会真正的在等待

30:05.900 --> 30:07.900
那么后边代码是放到微队的一边的

30:09.660 --> 30:10.300
输出1

30:11.260 --> 30:11.980
对吧

30:11.980 --> 30:13.260
放到微队的一边

30:13.260 --> 30:13.740
输出1

30:15.020 --> 30:17.180
那么这个函数返回了Promise

30:17.180 --> 30:18.140
刚才看过的

30:18.140 --> 30:19.420
是不是目前是挂起的

30:20.780 --> 30:23.660
因此这里要等待它完成

30:24.700 --> 30:27.100
换句话说什么时候这个Promise完成

30:27.100 --> 30:28.940
它必须要把这个1输出了之后

30:30.380 --> 30:31.100
才会完成

30:32.700 --> 30:34.940
所以说现在能输出2吗

30:35.500 --> 30:36.140
输出不了

30:37.260 --> 30:37.740
对不对

30:37.820 --> 30:38.860
是不是不能输出2

30:39.420 --> 30:40.460
没有办法输出2

30:42.460 --> 30:43.420
我要等它完成

30:43.420 --> 30:44.060
它现在完成了吗

30:44.060 --> 30:44.620
没有完成

30:45.500 --> 30:47.900
那我这边是不是也是要卡住呢

30:47.900 --> 30:51.100
我说这个函数是不是也会导致卡住了

30:51.100 --> 30:51.580
不会

30:51.580 --> 30:53.500
因为这个函数而这个函数也是一样的

30:53.500 --> 30:54.460
你始终记住

30:54.460 --> 30:56.860
介石代码是永远不可能卡住的

30:57.500 --> 30:58.860
就是我因为我们知道

30:58.860 --> 31:01.660
浏览器的执行介石的线程

31:01.660 --> 31:03.980
跟那个渲染页面的线程是互斥的

31:03.980 --> 31:06.140
你执行介石的时候如果卡住了

31:06.140 --> 31:07.420
那就导致了页面上啥

31:07.500 --> 31:08.140
都不能动了

31:08.620 --> 31:09.980
连滚动条都不能滚动了

31:09.980 --> 31:11.900
所以介石原是一定不能卡住的

31:12.700 --> 31:14.220
它都是用异布的处理

31:14.220 --> 31:16.460
这个就是关键势力容易绕云的

31:16.460 --> 31:18.060
就是因为这个地方是余法堂

31:18.620 --> 31:20.780
你看不到那个原式的Promise格式

31:21.900 --> 31:23.340
但是你始终记住

31:23.340 --> 31:25.180
而威者一旦出现了

31:25.180 --> 31:27.020
而威者关键制后边的代码

31:28.380 --> 31:29.740
它不是立即执行的

31:30.940 --> 31:32.780
它是要放到唯一队列里边的

31:32.780 --> 31:34.300
它会等待前面的Promise完成

31:34.300 --> 31:36.620
完成过后这个代码是会放到唯一队列里边的

31:36.780 --> 31:37.820
那么这里也是一样

31:37.820 --> 31:39.260
等待这个Promise完成

31:39.260 --> 31:41.980
完成之后我把输出二要放到唯一队列

31:41.980 --> 31:43.340
那现在有没有到唯一队列

31:43.340 --> 31:44.060
现在都没有

31:44.060 --> 31:45.340
因为这个Promise都没完成

31:46.380 --> 31:47.420
Promise什么时候完成

31:47.420 --> 31:48.620
我要把一输出了过后

31:49.260 --> 31:50.620
我要把这个代码运行过后

31:50.620 --> 31:52.060
我这个Promise才完成

31:52.060 --> 31:53.180
这个Promise完成过后

31:53.180 --> 31:54.940
这个代码才会到唯一队列

31:54.940 --> 31:55.340
对吧

31:55.340 --> 31:56.300
那现在还找得很

31:57.500 --> 31:57.980
所以说

31:59.180 --> 32:00.380
这个函数就执行完了

32:01.420 --> 32:03.420
它不会在傻的巴基在那里等一年

32:03.420 --> 32:04.300
等它完成

32:04.300 --> 32:06.300
比方说我这里虽然说是立即完成

32:06.380 --> 32:07.180
但是

32:07.180 --> 32:10.140
那万一这个Promise完成时间也输不准

32:10.140 --> 32:11.820
那如果说我这里用了一个

32:11.820 --> 32:12.940
定内函数

32:12.940 --> 32:13.180
对吧

32:13.180 --> 32:14.220
我们之前写过的定内函数

32:14.220 --> 32:15.100
那等了一年了

32:16.060 --> 32:16.620
它等一年

32:16.620 --> 32:17.980
我要在这边等一年

32:18.620 --> 32:19.340
不会等了

32:19.340 --> 32:21.020
继续到就马上运行驱出山

32:22.700 --> 32:24.620
这个时候执行站清空

32:25.500 --> 32:26.700
反复的看一下这一段

32:26.700 --> 32:27.740
好好去梳理一下

32:28.220 --> 32:29.020
执行站清空

32:29.820 --> 32:30.860
清空了之后

32:31.740 --> 32:32.220
等呗

32:32.220 --> 32:32.940
那这就是

32:32.940 --> 32:34.780
唯一队列就拿出来输出一了

32:35.500 --> 32:36.460
唯一队的一边

32:36.460 --> 32:37.900
是把这段代码拿出来运行的

32:39.580 --> 32:40.220
输出一

32:40.860 --> 32:42.460
因为这个有余法堂的存在

32:42.460 --> 32:43.740
其实这个东西是实际上是

32:43.740 --> 32:44.620
认里边

32:44.620 --> 32:45.740
认那个毁掉里边

32:47.660 --> 32:48.540
输出一

32:48.540 --> 32:49.900
输出一完了过后

32:50.620 --> 32:51.420
这个函数是

32:51.420 --> 32:53.900
这个函数代码是不是全部运行完了

32:54.700 --> 32:55.740
运行完了之后

32:56.300 --> 32:58.220
这个返回的Promise就完成了

32:58.780 --> 33:00.460
这个Promise完成了之后

33:01.340 --> 33:02.780
这个输出二代码

33:03.500 --> 33:05.020
进入到回队列

33:05.820 --> 33:07.820
由于现在没有什么别的事情可以执行

33:07.820 --> 33:09.340
所以说这个拿出来输出了

33:09.340 --> 33:09.980
输出二

33:11.020 --> 33:12.220
说零三一二

33:12.220 --> 33:13.900
这个结果是

33:16.820 --> 33:17.460
这样的意思吧

33:18.660 --> 33:18.980
好

33:18.980 --> 33:19.540
下面的倒题

33:20.500 --> 33:21.780
优势类似的考定

33:23.300 --> 33:24.420
反正复去绕顶

33:27.600 --> 33:28.160
我跟你们说

33:30.000 --> 33:31.520
我跟你们讲的那面试题

33:32.240 --> 33:33.120
都是讲的

33:33.120 --> 33:34.320
这个Promise相关的面试题

33:34.320 --> 33:36.480
都是给你们出的相对比较深一点的

33:37.440 --> 33:39.520
因为我还是希望大家能够去冲击

33:39.520 --> 33:40.000
还高兴

33:41.120 --> 33:42.400
最基本的面试题的话

33:42.400 --> 33:43.600
都没有什么好说的了

33:43.600 --> 33:46.640
因为我把姿势已经讲得非常细了

33:47.280 --> 33:48.160
要看下这道题

33:54.930 --> 33:55.970
不管它咋绕

33:56.770 --> 33:58.130
到底都是一样的

34:00.210 --> 34:00.690
来吧

34:06.000 --> 34:06.400
好

34:06.400 --> 34:08.000
首先这些都是函数

34:08.000 --> 34:08.960
声明看都不用看

34:09.520 --> 34:10.480
调用M3

34:13.090 --> 34:14.290
调用M3是调用它

34:15.170 --> 34:16.370
所以现在是在调用M3

34:17.330 --> 34:19.250
对M3一定会反回一个Promise

34:19.250 --> 34:20.370
因为还标记了Essink

34:20.370 --> 34:21.650
它一定反回Promise

34:22.770 --> 34:23.490
调用M3

34:23.970 --> 34:25.010
然后这里边

34:25.010 --> 34:26.850
M3里边又在调用啥

34:27.170 --> 34:27.970
调用M2

34:28.690 --> 34:28.850
好

34:28.850 --> 34:30.130
那么会去运行M2

34:30.530 --> 34:31.970
M2里边就要调用M1

34:32.530 --> 34:33.810
现在我们去运行M1

34:34.450 --> 34:35.650
M1反回的是啥

34:36.450 --> 34:37.490
不要告诉我反回的1

34:37.970 --> 34:39.330
反回的是一个Promise

34:40.050 --> 34:41.250
M1就这一块

34:41.410 --> 34:42.610
反回的是一个Promise

34:43.250 --> 34:44.610
得到了数据

34:45.170 --> 34:45.890
完成数据

34:46.610 --> 34:48.210
所以说我们之前演示过

34:48.210 --> 34:49.650
M1反回的Promise

34:49.970 --> 34:51.650
那么这句话就相当于是写了一个Promise

34:51.650 --> 34:52.290
学者无依

34:53.330 --> 34:54.530
就相当于是写的这个

34:54.530 --> 34:56.130
换句话说就相当于是写了一个这个

34:56.770 --> 34:58.210
道理很简单对不对

34:58.530 --> 34:59.730
所以这里去调用M1

34:59.730 --> 35:00.610
就是这样的结果

35:02.940 --> 35:03.260
好

35:03.260 --> 35:04.540
那么我们这个M1

35:04.540 --> 35:06.060
这个地方得到了Promise

35:06.860 --> 35:08.300
是不是就已经是完成了

35:08.300 --> 35:09.260
数据是多少

35:09.260 --> 35:09.980
数据是1

35:09.980 --> 35:10.860
以后这个表达是

35:10.860 --> 35:12.300
他就想把1复制给N

35:13.020 --> 35:14.060
但是不好意思

35:14.300 --> 35:15.660
由于我使用了而位置

35:16.380 --> 35:17.660
而位置后边代码全是在

35:17.660 --> 35:19.340
任的一个回调里边

35:19.340 --> 35:20.300
你可以这样的想想

35:21.020 --> 35:22.860
要等待这个Promise完成之后

35:22.860 --> 35:23.820
做后续处理

35:23.820 --> 35:25.260
所以这个代码都是后续处理

35:25.900 --> 35:28.780
因此我们输出N这个函数

35:28.780 --> 35:29.740
输出2这个动作

35:29.740 --> 35:31.820
而输出1这个动作在哪里

35:32.140 --> 35:33.740
在围队列里面

35:33.740 --> 35:34.380
输出1

35:35.580 --> 35:36.620
所以这个地方

35:37.420 --> 35:38.460
输出1这个动作

35:39.660 --> 35:40.540
在围队列里边

35:42.540 --> 35:44.140
好那么我们回到M3这里

35:44.860 --> 35:46.300
我们第二个用M2

35:47.660 --> 35:48.860
我在会在这里等待它

35:48.860 --> 35:50.220
我这里都没有用而位置

35:50.220 --> 35:50.700
对吧

35:50.700 --> 35:51.580
都没有用而位置

35:52.620 --> 35:53.580
没有用而位置的话

35:53.580 --> 35:54.540
我这里N是什么

35:57.090 --> 35:58.770
如果说我用了而位置

35:58.770 --> 35:59.570
看看

35:59.570 --> 36:00.930
如果说我用了而位置

36:01.330 --> 36:02.690
那么我要等待而面

36:02.690 --> 36:04.050
而面2那个Promise完成

36:04.050 --> 36:04.690
什么时候完成

36:04.690 --> 36:06.210
它必须要输出1之后才完成

36:06.770 --> 36:08.290
然后才会运行后边代码

36:09.170 --> 36:09.570
对吧

36:09.570 --> 36:11.090
但是我没有用而位置

36:11.970 --> 36:13.090
没有用而位置的话

36:14.130 --> 36:15.010
拿到的是什么

36:15.170 --> 36:15.970
Promise

36:16.850 --> 36:19.090
M2本身就返回的是Promise对吧

36:19.090 --> 36:20.290
而标记了而生给

36:20.290 --> 36:21.570
它一定返回Promise

36:21.570 --> 36:22.370
所以这个N是什么

36:22.370 --> 36:23.330
输出了N

36:23.330 --> 36:24.370
所以我们第一个输出

36:24.370 --> 36:25.490
得到的就是一个Promise

36:27.970 --> 36:28.770
状态是啥

36:30.130 --> 36:31.570
就是M2返回那个Promise

36:31.570 --> 36:32.530
目前的状态是啥

36:33.090 --> 36:33.730
这是Pending

36:34.530 --> 36:35.330
为什么是Pending

36:35.970 --> 36:37.250
它把代码运行完

36:37.650 --> 36:38.850
它代码运行完

36:40.050 --> 36:41.090
是不是只能是Pending

36:42.690 --> 36:43.090
对不对

36:44.210 --> 36:44.530
好

36:45.970 --> 36:47.570
得到输出的是Pending

36:48.850 --> 36:49.970
然后它返回3

36:50.930 --> 36:52.450
那么这个Promise完成吗

36:52.450 --> 36:53.330
就完成了

36:53.970 --> 36:56.290
它不会去等上面前面这个Promise

36:56.290 --> 36:57.810
因为我这里没有用而位置

36:58.450 --> 37:00.130
那老老的就是Promise对象

37:00.610 --> 37:01.650
如果说你用了而位置

37:01.650 --> 37:02.370
那就不一样了

37:02.690 --> 37:03.970
你用了而位置的话

37:04.530 --> 37:05.970
那么M3函数

37:06.450 --> 37:07.810
它会把这一段代码

37:08.690 --> 37:09.730
进行等待

37:09.730 --> 37:10.690
等待什么了

37:10.690 --> 37:12.210
等待前面那个Promise完成

37:12.210 --> 37:12.930
前面的Promise

37:12.930 --> 37:14.290
目前是Pending对吧

37:14.370 --> 37:16.610
所以说目前这个M3返回的结果

37:16.610 --> 37:17.570
也是Pending

37:17.570 --> 37:19.410
但是你由于没有用而位置

37:19.410 --> 37:20.210
没有等待

37:20.210 --> 37:21.570
我没有什么好等待的

37:22.210 --> 37:24.290
我就是把之前那个Promise拿到输出

37:24.530 --> 37:25.570
然后我返回一个3

37:25.570 --> 37:27.090
那我这个Promise就直接结束了

37:27.090 --> 37:28.370
所以说M3

37:29.650 --> 37:30.930
这个M3函数

37:32.210 --> 37:33.490
M2返回的Promise

37:34.770 --> 37:36.050
M1我就不说了

37:36.050 --> 37:38.610
M1刚才调用M1的时候

37:38.610 --> 37:39.890
返回的Promise

37:39.890 --> 37:41.170
那就是已经Fulfilled的了

37:44.370 --> 37:45.330
数据是1

37:45.330 --> 37:46.690
M2那个函数呢

37:46.690 --> 37:47.650
目前还是Pending

37:47.650 --> 37:48.210
还在挂起

37:48.210 --> 37:49.250
因为它没有输出

37:49.250 --> 37:49.970
没有输出1

37:49.970 --> 37:51.410
所以它目前还是挂起

37:51.410 --> 37:53.250
调用M3那个函数返回的呢

37:54.290 --> 37:55.250
由于它没有等待

37:55.250 --> 37:56.210
中间没有任何等待

37:56.210 --> 37:57.570
所以说它直接就是完成了

37:57.970 --> 38:00.290
但你看它有没有完成

38:00.290 --> 38:01.890
你看它代码有没有全部运行

38:02.450 --> 38:03.330
全部运行出来

38:03.330 --> 38:04.610
也有返回结果了

38:04.610 --> 38:05.730
那是不是就一定完成了

38:06.210 --> 38:06.850
数据是什么

38:06.850 --> 38:07.490
数据是3

38:09.410 --> 38:09.810
对吧

38:10.770 --> 38:11.250
好

38:11.250 --> 38:12.130
接下来运行到这

38:12.850 --> 38:14.050
M3函数调用完成

38:14.450 --> 38:15.330
调用完了

38:15.330 --> 38:16.290
调用任函数

38:16.850 --> 38:18.130
高速杀

38:18.130 --> 38:19.890
如果说你前面这个Promise

38:19.890 --> 38:20.930
就这个Promise

38:20.930 --> 38:22.770
前面这个Promise完成过后

38:22.770 --> 38:24.050
你给我运行这个

38:24.050 --> 38:25.010
那这个完成了吗

38:26.050 --> 38:27.010
就完成了

38:27.010 --> 38:27.970
完成了这个代码

38:27.970 --> 38:28.930
这个函数会到了

38:28.930 --> 38:30.130
是不是把围队列

38:30.130 --> 38:31.650
它不会立即执行的

38:31.650 --> 38:32.930
这是输出几呢

38:32.930 --> 38:34.610
是不是输出那个完成的数据3

38:34.610 --> 38:35.730
那么一个输出3

38:35.730 --> 38:36.690
是到围队列里面

38:39.570 --> 38:39.970
对吧

38:39.970 --> 38:40.450
没问题吧

38:42.050 --> 38:42.370
好

38:42.370 --> 38:43.090
接下来

38:43.090 --> 38:44.930
我这个地方又掉了一次M3

38:46.210 --> 38:46.930
又掉了一次

38:47.890 --> 38:48.930
结果不是一样的吗

38:48.930 --> 38:49.970
有什么区别呢

38:49.970 --> 38:51.250
那就重新拿到一遍对吧

38:51.970 --> 38:52.290
来吧

38:54.210 --> 38:55.170
又掉M3

38:55.170 --> 38:56.610
那这里是不是运行M2

38:56.610 --> 38:58.370
M2是不是运行M1

38:58.370 --> 39:00.690
M1那这里要重新开一个了

39:02.930 --> 39:04.690
这一次调用跟之前的调用已经不一样了

39:05.650 --> 39:06.210
M1

39:06.210 --> 39:08.930
用一个符号标准一下

39:08.930 --> 39:09.730
就这一次新的

39:09.730 --> 39:10.690
这一次调用

39:10.690 --> 39:12.690
M1得到的是结果是FullFill的

39:14.370 --> 39:15.090
1

39:15.170 --> 39:15.570
然后呢

39:15.570 --> 39:16.370
这一次M2

39:17.330 --> 39:18.690
因为还是可以调用很多次

39:18.690 --> 39:20.850
每一次调用都是新开一块的一寸

39:21.570 --> 39:21.810
好

39:21.810 --> 39:22.530
掉了M2

39:24.050 --> 39:25.010
M2返回了是什么呢

39:25.010 --> 39:26.050
要等待

39:26.050 --> 39:27.010
M2这里是不是

39:27.890 --> 39:31.250
要等待M1完成了吗

39:31.250 --> 39:31.570
完成了

39:31.570 --> 39:32.930
所以说后边的单码会放入了

39:34.050 --> 39:34.930
输出1这个单码

39:34.930 --> 39:35.890
又会放入围队里

39:36.530 --> 39:37.250
输出1

39:37.250 --> 39:38.210
就这段单码

39:38.210 --> 39:39.490
又会放入围队里

39:40.370 --> 39:40.690
对吧

39:40.690 --> 39:42.130
所以M2目前也是挂

39:42.130 --> 39:43.410
这个M2也是挂起

39:44.370 --> 39:46.770
因为它要把这个后边单码执行完了过

39:46.770 --> 39:47.570
跟刚才一样的

39:47.570 --> 39:48.850
要把这个单码执行完了过后

39:48.850 --> 39:49.970
才继续运行

39:49.970 --> 39:51.090
然后接下来是M3

39:53.890 --> 39:54.770
交往这个M3

39:54.770 --> 39:55.490
M3呢

39:55.490 --> 39:56.610
我没有等待M2

39:56.610 --> 39:57.010
对吧

39:57.010 --> 39:59.010
所以说我这里输出的是Promise

39:59.010 --> 40:00.690
那还是跟刚才一样的

40:00.690 --> 40:01.730
就重新调了一次

40:02.610 --> 40:04.290
那么M3就直接完成了

40:04.290 --> 40:05.010
FullFill

40:05.890 --> 40:06.130
3

40:06.690 --> 40:06.930
对吧

40:06.930 --> 40:08.130
这是这一次交往M3

40:08.130 --> 40:09.090
刚才是不是一样的

40:09.090 --> 40:10.290
就重新来的一遍对吧

40:11.250 --> 40:12.050
然后输出4

40:12.850 --> 40:13.730
就输出4

40:13.730 --> 40:15.010
接下来单码执行完了

40:15.250 --> 40:16.290
没有啥东西可以执行了

40:16.770 --> 40:17.570
然后围队的一边

40:17.570 --> 40:18.290
一个一个拿出来

40:18.290 --> 40:19.410
先输出1再输出3

40:19.410 --> 40:19.890
再输出1

40:20.850 --> 40:21.490
对吧

40:21.490 --> 40:22.210
我们一个个来吧

40:22.930 --> 40:24.050
第一次先输出1

40:25.010 --> 40:25.970
这里是不是输出1

40:26.930 --> 40:28.370
那么这个执行完了过后

40:29.330 --> 40:31.650
是不是导致了M2就执行结束了

40:31.650 --> 40:32.610
M2执行结束了

40:32.610 --> 40:34.450
那么之前那个M2交用

40:35.010 --> 40:37.410
是不是导致了FullFill的

40:37.410 --> 40:38.130
数据是2

40:38.770 --> 40:40.210
M2执行结束了

40:40.210 --> 40:41.250
跟M3有关系吗

40:41.250 --> 40:41.730
没有关系

40:41.730 --> 40:43.010
因为M3没有去等待它

40:44.290 --> 40:44.610
对吧

40:45.410 --> 40:46.610
那么这也输出1

40:46.610 --> 40:47.570
然后再输出3

40:48.130 --> 40:49.170
这输出3是哪来的

40:49.170 --> 40:49.730
是这个函数

40:52.690 --> 40:53.170
输出3

40:53.890 --> 40:54.690
这个执行完了

40:55.250 --> 40:56.290
然后再输出1

40:56.290 --> 40:58.450
是不是刚才第二次交用这个M2的时候

40:58.930 --> 40:59.490
一样的当里

40:59.490 --> 41:01.410
那么这里又变成了FullFill的

41:02.130 --> 41:05.340
这把结构是2

41:05.980 --> 41:06.860
这个也输出1

41:07.340 --> 41:09.420
所以是这个题的最终输出结果

41:10.140 --> 41:10.700
就这个

41:10.700 --> 41:11.500
FullFill是平底

41:12.220 --> 41:12.780
两个平底

41:13.980 --> 41:14.700
4131

41:16.460 --> 41:16.780
对吧

41:17.500 --> 41:19.180
我们不给你们吹牛

41:19.180 --> 41:19.820
我没有

41:19.820 --> 41:21.420
我不知道这个问题的答案是啥

41:21.420 --> 41:22.140
我没有去背过

41:22.540 --> 41:23.420
这个玩意儿不需要背

41:23.420 --> 41:25.420
你只要抓住我这种分析方法

41:25.420 --> 41:27.420
你这个题随便怎么它怎么来招立

41:29.260 --> 41:30.540
你都可以把它做出来

41:31.180 --> 41:32.140
要慢慢去分析

41:32.540 --> 41:34.380
因为地方看不看到不是很懂

41:34.380 --> 41:35.180
有点晕的话

41:35.180 --> 41:36.140
你反复多看几遍

41:38.850 --> 41:39.490
第七题

41:40.130 --> 41:41.250
如果说觉得累了

41:41.250 --> 41:42.210
可以休息会再看

41:42.210 --> 41:42.850
这没关系

41:45.420 --> 41:47.100
这个题其实蛮简单的

41:47.420 --> 41:48.460
就是一个小的周识

41:49.180 --> 41:50.060
有些朋友不知道

41:50.060 --> 41:50.940
给你说一下

41:52.780 --> 41:53.420
是这样子

41:54.540 --> 41:56.940
如果说任方法里边传了一个

41:56.940 --> 41:59.180
因为任方法里边都传的是一个回调函数

41:59.180 --> 41:59.740
对不对

41:59.740 --> 42:00.620
传的是一个函数

42:01.180 --> 42:02.620
如果说你传的不是函数

42:02.620 --> 42:03.980
就传一个乱七八糟的别的东西

42:03.980 --> 42:04.620
传一个数字

42:04.620 --> 42:05.660
字幕圈对象

42:05.660 --> 42:06.940
你只要传的不是函数

42:08.460 --> 42:09.260
你就这样子

42:09.260 --> 42:10.220
一个最简单的方式

42:10.220 --> 42:11.420
你把这个代码给我删了

42:13.260 --> 42:14.860
你就这样子就行了

42:15.580 --> 42:17.180
实际上说的严格一点的话

42:17.260 --> 42:18.460
那么如果说任方法

42:18.460 --> 42:19.820
调用任方法的时候

42:20.220 --> 42:21.900
他发现你传的函数不是函数

42:23.500 --> 42:24.220
那么他反

42:24.220 --> 42:25.740
这个任方法反回的Promise

42:26.220 --> 42:27.500
就是原来那个Promise

42:28.220 --> 42:29.740
就相当于是你没有注册

42:29.740 --> 42:30.860
相当于是传那个纳红

42:30.860 --> 42:31.580
你这样想吧

42:32.380 --> 42:33.020
传那个纳红

42:33.020 --> 42:34.060
我们之前说过了对吧

42:34.060 --> 42:36.140
你们相当于是你没有注册回调函数

42:36.140 --> 42:37.660
没有注册回调函数的话

42:37.660 --> 42:39.340
那么这个Promise

42:39.340 --> 42:40.700
跟前面那个Promise的状态

42:40.700 --> 42:41.660
数据都是一致的

42:43.340 --> 42:44.700
所以说你将它认识

42:44.700 --> 42:45.580
可以把任三了

42:45.580 --> 42:46.300
它啥都没写

42:47.260 --> 42:49.980
你看我这里传了一个二

42:49.980 --> 42:51.340
二是不是函数

42:51.340 --> 42:51.820
不是吧

42:51.820 --> 42:52.540
那就办个三了

42:53.900 --> 42:54.780
这里Result

42:54.780 --> 42:55.580
这些传的是什么

42:55.580 --> 42:56.860
传的是一个Promise对象

42:57.980 --> 42:58.780
不是函数吧

42:59.500 --> 43:00.220
那不是函数

43:00.220 --> 43:01.740
它就是无效的传递

43:01.740 --> 43:02.140
三了

43:03.180 --> 43:04.620
这个Consol Nougat是不是函数

43:07.180 --> 43:07.740
同学们

43:07.740 --> 43:09.020
Consol Nougat是不是函数

43:09.980 --> 43:10.940
那不是函数是啥

43:10.940 --> 43:12.380
那么平手用的是啥东西

43:13.340 --> 43:14.220
不就是个函数

43:14.220 --> 43:15.260
它接收一个函数

43:15.260 --> 43:15.500
对吧

43:16.460 --> 43:17.660
你把它写成一个函数格式

43:17.660 --> 43:18.700
就是这样的格式

43:18.700 --> 43:19.340
Nougat

43:19.340 --> 43:20.060
有一个参数

43:21.260 --> 43:23.100
然后它就负责把那个参数

43:23.100 --> 43:24.860
把那个参数来输出

43:24.860 --> 43:26.140
不就是一个函数吗

43:26.140 --> 43:27.180
所以说这个是不是函数

43:27.180 --> 43:27.660
是函数

43:28.540 --> 43:29.260
那么你可以

43:29.260 --> 43:29.740
也没问题

43:30.380 --> 43:32.140
那么这个Promise完成之后

43:32.140 --> 43:33.100
它会把这个数据

43:34.140 --> 43:35.500
传递给这个函数

43:35.500 --> 43:37.580
那么相当于是把1传给这个Nougat函数

43:37.580 --> 43:38.460
那就输出了1

43:38.460 --> 43:39.660
所以这个结构就是输出1

43:41.920 --> 43:43.280
那你把刚才那个东西加上

43:43.280 --> 43:44.240
乱七八糟的代码加上

43:44.240 --> 43:45.600
其实也是输出

43:45.680 --> 43:46.880
你传的都是无效参数

43:48.160 --> 43:48.800
是一样

43:48.800 --> 43:49.920
这个小的信简

43:49.920 --> 43:50.480
再来说一下

43:51.680 --> 43:54.800
Nougat 9题是一个综合形容大题

43:56.000 --> 43:57.440
也是非常经典的

43:57.440 --> 43:59.120
Promise的两道面试题

43:59.120 --> 44:00.320
网上有很多的文章

44:00.320 --> 44:01.520
去解释这两道面试题

44:02.400 --> 44:03.760
就是你听我讲就行了

44:06.450 --> 44:07.170
来了

44:07.170 --> 44:08.450
你们自己可以尝试着

44:08.450 --> 44:09.330
先做一下

44:15.420 --> 44:16.220
到底有点复杂

44:17.180 --> 44:18.140
来 走一遍

44:25.920 --> 44:27.200
上面是分析

44:27.200 --> 44:28.080
下边是输出

44:34.350 --> 44:34.990
好 来了

44:36.670 --> 44:38.430
这里定义了一个变量A

44:39.630 --> 44:40.990
目前肯定是王敌凡的

44:40.990 --> 44:42.430
那还能说啥呢

44:43.550 --> 44:44.990
然后定义了一个变量B

44:46.350 --> 44:48.190
这里有个小的细节给你们说一下

44:49.310 --> 44:50.430
变量的定义

44:50.990 --> 44:52.990
变量的定义和复值

44:52.990 --> 44:54.830
实际上是分两步完成的

44:56.030 --> 44:56.430
知道吧

44:56.910 --> 44:58.910
它会先运算后边的表达是

44:59.630 --> 45:01.470
然后再把这个表达是的结果

45:01.470 --> 45:02.190
复制给变量

45:03.150 --> 45:04.830
这是一个非常朴素的一个整理

45:04.830 --> 45:07.070
但是很容易忘记着一点

45:07.070 --> 45:08.590
所以这个B的变量的值

45:10.110 --> 45:11.470
目前是王敌凡的

45:11.470 --> 45:12.670
它先是王敌凡的

45:13.870 --> 45:14.670
是这样子的

45:14.670 --> 45:15.870
它先是王敌凡的

45:15.870 --> 45:17.390
然后把这个表达是算出来

45:17.390 --> 45:18.590
过后再复制给B

45:19.470 --> 45:20.110
好 那么接下来

45:20.110 --> 45:21.550
是不是开始算这个表达式了

45:21.550 --> 45:22.430
这个表达是在干嘛

45:23.230 --> 45:24.430
创建一个Promise的一个

45:24.430 --> 45:25.790
这是个很长的表达式

45:26.190 --> 45:27.230
一把简化之后

45:27.230 --> 45:28.350
它代码应该是这样子的

45:29.310 --> 45:30.270
NewPromise

45:30.830 --> 45:32.030
然后传一个SATA查

45:32.990 --> 45:34.110
然后它调了它的Zen

45:34.110 --> 45:34.910
传了一个SATA查

45:35.550 --> 45:36.430
再调了它的Zen

45:36.430 --> 45:37.150
传了一个SATA查

45:37.550 --> 45:38.350
再调用Zen

45:38.350 --> 45:39.070
传了一个SATA查

45:40.110 --> 45:41.150
就是这个表达式

45:41.470 --> 45:42.510
那么这个表达式

45:43.390 --> 45:44.270
它复制给了B

45:44.910 --> 45:45.630
请问

45:46.990 --> 45:47.710
这个表达

45:48.270 --> 45:49.310
这个B这个表达

45:49.310 --> 45:51.390
就是这个表达式复制给B

45:51.390 --> 45:52.750
复制的是哪一个Promise

45:53.390 --> 45:53.950
是这个吗

45:55.070 --> 45:56.510
还是这个人含述返回的

45:57.230 --> 45:58.430
还是这个人含述返回的

45:58.990 --> 46:00.030
还是这个人含述返回的

46:00.030 --> 46:01.950
我记得有一些课我说过的

46:02.670 --> 46:04.030
这是最基础的概念了对吧

46:04.670 --> 46:06.510
一个对象调一个方法

46:06.510 --> 46:07.390
再调一个方法

46:07.390 --> 46:08.190
再调一个方法

46:08.510 --> 46:09.310
再调一个方法

46:10.190 --> 46:11.390
整个表达式返回的是啥

46:11.390 --> 46:12.590
返回的是注意后一个

46:13.390 --> 46:14.030
所以说这里

46:14.590 --> 46:15.070
返回的是啥

46:15.070 --> 46:17.790
返回的是这个人含述的Promise

46:19.710 --> 46:21.150
有些人可能有误音了

46:21.150 --> 46:21.790
也不对啊

46:22.590 --> 46:23.230
你看啊

46:23.230 --> 46:25.230
这个Promise要等一秒后才完成

46:25.230 --> 46:26.030
所以说这个人

46:26.030 --> 46:27.390
是不是要等一秒后才完成

46:27.390 --> 46:29.310
这个人是不是在等一秒后才完成

46:29.310 --> 46:30.110
你错了同学

46:31.150 --> 46:31.710
一秒

46:32.190 --> 46:34.350
这些回调函数是这样子的

46:34.350 --> 46:35.390
一秒后才会运行

46:35.710 --> 46:36.670
一秒后才会运行

46:36.670 --> 46:37.470
这个是没问题的

46:38.350 --> 46:40.830
但是这个人含述方法是马上就得雕用

46:40.830 --> 46:41.150
对吧

46:41.790 --> 46:43.230
在雕用Ring方法

46:44.110 --> 46:44.830
你看吧

46:44.830 --> 46:46.270
你是不是要雕用方法

46:46.270 --> 46:46.990
创建一个对象

46:46.990 --> 46:48.030
雕用它的方法Ring

46:48.030 --> 46:49.470
这个Ring会返回一个新的对象

46:49.470 --> 46:50.510
又会雕用这个方法

46:50.510 --> 46:51.710
新的对象的Ring方法

46:51.710 --> 46:53.070
再返回了新对象

46:53.070 --> 46:54.030
雕用它的方法

46:54.030 --> 46:55.550
方法是瞬间就雕用完了

46:56.510 --> 46:57.710
只是这个Promise

46:57.710 --> 46:59.870
这个方法反复的Promise的状态

46:59.870 --> 47:00.750
还不能确定

47:00.750 --> 47:02.190
所以说B是一个什么

47:02.190 --> 47:03.150
是一个Promise

47:04.830 --> 47:05.790
它的状态是啥

47:06.430 --> 47:07.150
是平底

47:10.350 --> 47:10.990
挂起的

47:13.500 --> 47:13.900
对不对

47:14.460 --> 47:14.700
好

47:14.700 --> 47:16.140
那我们来再来详细分析一下

47:18.740 --> 47:20.100
这个代码者到底是怎么执行的

47:20.100 --> 47:20.820
它是这样子执行的

47:22.100 --> 47:23.540
计算先运行这个表达式

47:24.100 --> 47:24.740
运行的表达式

47:24.740 --> 47:26.180
不知道从左到右运行

47:26.180 --> 47:26.580
好

47:26.580 --> 47:27.540
首先运行左边

47:27.700 --> 47:29.540
先运行这个指表达式

47:30.340 --> 47:31.380
指表达式干嘛

47:31.380 --> 47:32.660
创建了一个Promise

47:33.940 --> 47:35.220
把它叫做P1嘛

47:35.220 --> 47:36.500
这是第一个Promise

47:36.500 --> 47:37.380
创建一个Promise

47:38.020 --> 47:38.980
然后输出的时候

47:38.980 --> 47:39.700
马上输出

47:39.700 --> 47:41.140
这个代码是马上运行的

47:41.140 --> 47:41.940
输出Promise

47:46.510 --> 47:49.550
然后一秒后运行这个函数

47:49.550 --> 47:50.430
我们记录一下

47:51.710 --> 47:52.350
一秒后

47:55.920 --> 47:57.280
完成P1

47:57.280 --> 47:59.360
这个函数其实就是完成这个Promise

47:59.360 --> 48:00.080
所以这个Promise

48:00.080 --> 48:01.360
一开始状态是什么

48:01.440 --> 48:01.920
平定

48:03.040 --> 48:04.560
好那么这个Promise创建好了

48:05.680 --> 48:06.960
创建好了之后

48:06.960 --> 48:08.000
调它的任访法

48:09.040 --> 48:10.800
这个任访法是不是产生了第二个Promise

48:11.920 --> 48:13.920
第二个Promise是否取决于前面那个Promise

48:14.480 --> 48:16.080
是否取决于前面那个Promise的状态

48:16.080 --> 48:16.720
前面是平定

48:16.720 --> 48:17.440
而且它就是平定

48:18.000 --> 48:19.040
这个回调现在运行嘛

48:19.040 --> 48:20.080
现在不运行

48:20.080 --> 48:21.360
它连队列都不会到

48:21.360 --> 48:22.560
因为目前都是平定状态

48:22.960 --> 48:24.000
前面是平定状态

48:24.640 --> 48:26.960
前边完成才会运行这个回调

48:27.680 --> 48:28.080
对吧

48:28.080 --> 48:28.800
然后呢

48:28.800 --> 48:29.200
P3

48:29.920 --> 48:31.520
这里再调用任访法

48:31.520 --> 48:33.520
是不是它反回第三个Promise

48:33.520 --> 48:34.640
它的状态是什么

48:34.640 --> 48:36.320
它的状态就是也是平定

48:36.320 --> 48:38.000
因为它前一个Promise的状态是平定

48:39.360 --> 48:39.760
对吧

48:40.560 --> 48:41.200
然后P4

48:41.920 --> 48:42.560
也是平定

48:43.520 --> 48:44.960
那么这个B1

48:44.960 --> 48:46.480
B实际上是就是提示

48:47.440 --> 48:48.400
实际上是最后一个

48:50.560 --> 48:52.240
那么这个表达是就运行完了

48:52.240 --> 48:54.160
创建Promise负责给B都是平定

48:54.960 --> 48:56.080
一秒后P1完成

48:56.080 --> 48:57.360
它造成了连锁反应

48:58.320 --> 48:58.640
好

48:58.640 --> 49:00.720
这是这个代码

49:00.720 --> 49:02.560
现在目前输出只有Promise1

49:02.560 --> 49:03.760
接下来我们看下面

49:05.520 --> 49:07.280
又创建一个Promise

49:08.080 --> 49:09.120
给F值

49:10.000 --> 49:11.200
好好来分析一下

49:11.200 --> 49:12.880
目前的值得是undefined

49:15.490 --> 49:15.810
来吧

49:16.530 --> 49:17.170
给F值

49:20.880 --> 49:22.080
创建一个Promise

49:23.760 --> 49:25.200
这个代码是不是立即执行

49:25.200 --> 49:27.200
注意这个Promise是标记为Essink

49:27.200 --> 49:28.080
这个回调函数

49:28.080 --> 49:30.160
这个函数标记的Essink

49:30.320 --> 49:31.920
这个函数返回也是Promise

49:31.920 --> 49:32.480
崩溫它

49:32.480 --> 49:33.200
那个无所谓

49:34.800 --> 49:35.920
先输出Essink

49:35.920 --> 49:36.960
这个代码立即执行

49:36.960 --> 49:38.400
请问Essink目前的指示是什么

49:38.400 --> 49:39.120
是undefined

49:39.920 --> 49:40.320
为什么

49:40.320 --> 49:41.520
现在还没有完成复制

49:41.520 --> 49:43.360
我要把这个表达是运算完了过后

49:43.360 --> 49:44.000
才来复制

49:44.000 --> 49:44.240
对吧

49:45.280 --> 49:47.920
先又再组复制表达是吗

49:48.480 --> 49:49.440
运行右边的

49:49.440 --> 49:50.880
运行完了之后再给Essink复制

49:51.440 --> 49:52.080
现在目前

49:52.960 --> 49:54.080
这边代码还在运行

49:54.080 --> 49:55.760
这是给它传到一个函数

49:55.760 --> 49:56.160
函数

49:56.160 --> 49:57.280
那个函数还在运行

49:57.280 --> 49:59.120
所以目前的Essink还是undefined

50:01.120 --> 50:01.520
好

50:01.520 --> 50:02.800
等待B

50:02.800 --> 50:04.320
等待B是不是等待P4

50:06.480 --> 50:06.880
对不对

50:08.000 --> 50:08.800
是不是等待P4

50:09.840 --> 50:10.880
P4现在是不是偏紧

50:12.960 --> 50:13.680
对吧

50:13.680 --> 50:15.280
因此这后边代码现在执行

50:16.080 --> 50:16.720
不执行了

50:17.680 --> 50:19.280
后边可以长串代码

50:19.280 --> 50:20.320
都不会执行到目前

50:21.200 --> 50:21.520
为什么

50:21.520 --> 50:23.040
因为P4还是挂起的

50:23.040 --> 50:24.320
我现在P4完成之后

50:24.320 --> 50:25.760
我才能继续往后执行

50:26.160 --> 50:26.720
对吧

50:26.720 --> 50:28.480
但是程序可不会卡住

50:29.440 --> 50:30.720
程序可不会卡

50:32.560 --> 50:33.600
这个函数就结束了

50:35.120 --> 50:36.240
等到B完成过后

50:36.240 --> 50:37.680
它在回过头来执行这个

50:39.200 --> 50:39.760
你明白吧

50:39.760 --> 50:40.480
明白这个意思吧

50:40.480 --> 50:42.320
这个函数就执行结束了

50:42.320 --> 50:43.280
这个函数就执行结束了

50:43.280 --> 50:44.720
过后这个表达是就执行结束了

50:45.680 --> 50:46.240
好就反

50:46.240 --> 50:47.040
产生那个Promise

50:47.040 --> 50:47.600
复制给了A

50:48.160 --> 50:49.200
那么A就是一个什么

50:49.200 --> 50:49.920
Promise

50:49.920 --> 50:51.200
我姑且把它叫做P5

50:52.720 --> 50:53.920
这个Promise

50:53.920 --> 50:54.640
也就是P5

50:55.200 --> 50:56.880
那么请问P5的状态是什么

50:59.200 --> 50:59.920
这个状态是啥

50:59.920 --> 51:01.040
这个还不简单吗

51:01.040 --> 51:03.040
你是通过6来创建的Promise

51:03.600 --> 51:04.640
那么状态

51:04.640 --> 51:06.240
你看你有没有调容为这一种

51:06.240 --> 51:07.440
有没有调容为这个什么

51:08.160 --> 51:10.000
目前只预行到这就结束了

51:10.720 --> 51:12.000
所以说目前啥都没调用

51:12.000 --> 51:13.040
它状态肯定是偏低

51:14.080 --> 51:15.520
所以还有什么好疑问的呢

51:17.440 --> 51:18.560
好然后输出了

51:18.560 --> 51:19.520
然后再输出N

51:21.600 --> 51:22.640
123输出完了

51:24.080 --> 51:25.280
接下来等呗

51:25.280 --> 51:26.960
等发生连锁反应

51:27.040 --> 51:28.720
1秒后完成P1

51:29.680 --> 51:31.200
1秒后完成了是谁

51:31.200 --> 51:31.920
这个Promise

51:32.400 --> 51:32.880
好来吧

51:33.440 --> 51:35.120
P1完成之后

51:35.120 --> 51:36.000
就导致了谁

51:36.560 --> 51:38.960
导致了这个的函数进入维对列

51:38.960 --> 51:40.240
那因为没有别的事了

51:40.240 --> 51:41.280
直接拿出来执行

51:43.360 --> 51:43.840
输出啥

51:44.880 --> 51:45.760
P1就完成了

51:46.960 --> 51:47.920
说是有的

51:50.160 --> 51:51.440
然后就运行这个函数

51:51.440 --> 51:52.480
输出了Promise2

51:54.080 --> 51:55.840
后边就没什么好说的了

51:55.840 --> 51:58.000
因为它执行的过程中没有产生错误

51:58.560 --> 51:59.760
成功完成了

51:59.760 --> 52:03.280
所以说P2也跟着完成了

52:03.280 --> 52:04.160
P2也完成了

52:04.160 --> 52:05.200
这个玩意又到维对列

52:05.200 --> 52:06.080
又拿出来执行

52:06.080 --> 52:07.840
所以说输出Promise3

52:11.840 --> 52:12.560
同样的道理

52:12.560 --> 52:14.480
这个玩意P3也完成了

52:14.480 --> 52:16.000
然后跟着P4也完成了

52:16.000 --> 52:17.680
然后就输出Promise4

52:17.680 --> 52:18.560
P4也完成了

52:19.360 --> 52:20.240
那么就一是输出

52:20.240 --> 52:21.920
二 三 四

52:22.960 --> 52:24.720
好P4完成了之后

52:27.040 --> 52:28.160
是不是会有导致的

52:28.160 --> 52:29.600
这里就等待就结束了

52:29.600 --> 52:30.320
它等待B吧

52:30.320 --> 52:30.960
B就是P4

52:32.160 --> 52:33.920
所以说它B是不是完成了

52:33.920 --> 52:34.720
完成了过后

52:35.440 --> 52:37.440
那么这里边代码可以继续了

52:37.440 --> 52:38.720
但是P5还是盆顶

52:38.720 --> 52:39.840
因为它没有调用result

52:42.080 --> 52:43.520
然后接下来输出什么

52:43.520 --> 52:43.920
输出A

52:44.800 --> 52:45.760
那么A不好意思

52:46.960 --> 52:48.080
现在A有值了

52:49.760 --> 52:50.640
现在A有值了

52:50.640 --> 52:51.760
现在A是不是P5

52:51.760 --> 52:54.240
所以说现在输出A是什么了

52:54.240 --> 52:55.360
输出的是一个Promise

52:56.400 --> 52:57.440
状态是什么

52:57.440 --> 52:58.080
还是Pending

52:59.840 --> 53:00.560
目前A的值

53:02.400 --> 53:03.680
好 再输出一个after

53:06.220 --> 53:07.260
after1

53:07.260 --> 53:08.380
然后接下来又有意思的

53:08.380 --> 53:09.820
就是等待A完成

53:10.620 --> 53:11.740
A现在目前是Pending

53:12.140 --> 53:13.500
你看P5是Pending

53:13.500 --> 53:14.460
等待A完成

53:16.700 --> 53:18.060
这个事有尽头吗

53:18.060 --> 53:18.860
是不是没有尽头

53:20.380 --> 53:20.700
对不对

53:20.700 --> 53:21.500
现在代码又结束了

53:21.500 --> 53:23.420
这个还说执行了一段

53:23.420 --> 53:24.060
然后遇到这

53:24.060 --> 53:25.020
等待又结束了

53:25.020 --> 53:25.500
又不止

53:25.500 --> 53:27.500
少得没啥事情可以做了

53:27.580 --> 53:29.020
因为它只有A完成之后

53:29.020 --> 53:30.220
才会接着做后面的事情

53:30.700 --> 53:32.220
但是A现在是不是Pending

53:32.780 --> 53:33.340
没有完成

53:33.900 --> 53:35.660
那现在就相当于是等待自己

53:35.660 --> 53:36.540
自己等待自己

53:36.540 --> 53:39.980
说我等待我完成之后

53:39.980 --> 53:41.100
我就完成我

53:41.900 --> 53:43.340
那是不是永远等不到啊

53:43.340 --> 53:44.940
这有点像前段时间疫情

53:45.500 --> 53:46.700
你家里边没口罩了

53:46.700 --> 53:48.220
但是又不能出小区

53:48.220 --> 53:49.500
出小区的时候有一个

53:50.060 --> 53:51.580
大妈带着红袖哭

53:52.460 --> 53:53.180
不能出小区

53:53.740 --> 53:54.700
出小区要带口罩

53:55.260 --> 53:56.620
你说你没有口罩

53:56.780 --> 53:57.980
所以说出门要去买口罩

53:59.740 --> 54:00.620
那不行啊

54:01.100 --> 54:02.460
你没有口罩不能出小区啊

54:03.420 --> 54:04.700
有人口罩才能出小区

54:04.700 --> 54:06.380
但是我不出门要怎么去买口罩呢

54:06.380 --> 54:08.300
就是这么一个问题

54:10.220 --> 54:11.500
它要等待自己完成

54:11.500 --> 54:12.860
完成之后才能完成自己

54:12.860 --> 54:13.740
那你永远等不到

54:13.740 --> 54:13.980
对吧

54:13.980 --> 54:15.420
自己本来就是挂起的

54:15.420 --> 54:16.620
所以这个代码就不止行了

54:16.620 --> 54:17.580
后面就不止行了

54:18.060 --> 54:18.940
永远没法止行了

54:18.940 --> 54:19.260
对吧

54:19.260 --> 54:20.460
你永远等不到它完成

54:20.460 --> 54:21.820
它永远挂起挂起

54:22.140 --> 54:22.860
无所谓

54:22.860 --> 54:23.820
但是你要记住啊

54:23.820 --> 54:25.420
挂起不代表程序卡

54:25.420 --> 54:27.020
座程序永远不会卡的

54:27.020 --> 54:28.460
介绍程序是永远不会卡的

54:29.340 --> 54:30.780
就这个相当于是后面的代码

54:30.780 --> 54:31.740
是在一个函数里边

54:31.740 --> 54:33.580
这个函数永远不止行了而已

54:34.220 --> 54:35.980
就相当于是定义了一个函数

54:35.980 --> 54:37.340
这个函数你没有去调用它

54:37.340 --> 54:38.300
它就永远不止行呗

54:39.020 --> 54:39.420
没有什么

54:40.220 --> 54:41.900
这个而为止只是一个愚法堂而已

54:41.900 --> 54:43.100
所以说这两个代码无销

54:44.060 --> 54:44.940
最终结果就这样子

54:45.420 --> 54:45.980
运行看一样

54:49.360 --> 54:50.080
自己对一下

54:50.080 --> 54:51.280
肯定是这样子的

54:51.280 --> 54:52.880
你学会了这样的分析方法之后

54:52.880 --> 54:53.840
这些题都特别不好

54:55.680 --> 54:56.720
这些面试题啊

54:56.800 --> 54:58.720
我觉得你现在了解个

54:59.920 --> 55:01.360
六七十可以了

55:02.240 --> 55:04.160
后边你在准备面试的时候

55:04.160 --> 55:05.760
你肯定要回过头来看的

55:05.760 --> 55:06.880
到时候肯定又忘完了

55:06.880 --> 55:07.600
这是正常的

55:08.640 --> 55:10.560
有多少影响有算多少影响

55:11.360 --> 55:11.760
多少题

55:11.760 --> 55:13.040
这也是一道经典的面试题

55:17.280 --> 55:18.080
来吧

55:18.080 --> 55:19.120
这也定了两个函数

55:19.840 --> 55:20.640
这两个函数呢

55:20.640 --> 55:21.360
没有调用它

55:21.360 --> 55:22.480
没调用它拉到

55:22.480 --> 55:23.680
看得比较好看

55:23.680 --> 55:25.440
我们只关心函数的调用

55:25.440 --> 55:27.200
然后输出script start

55:27.920 --> 55:28.400
输出这个

55:33.710 --> 55:34.270
输出这个

55:35.150 --> 55:35.470
好

55:35.470 --> 55:36.030
然后呢

55:36.030 --> 55:38.190
在领秒后

55:39.150 --> 55:40.030
输出这个

55:40.030 --> 55:41.230
所以说红队领

55:42.990 --> 55:44.350
领秒后输出这个

55:44.910 --> 55:46.670
输出set

55:46.670 --> 55:47.550
Timeout

55:47.550 --> 55:49.070
领秒马上就到了嘛

55:49.070 --> 55:49.390
排队

55:50.670 --> 55:51.870
调用而sync1

55:52.910 --> 55:53.310
来吧

55:53.310 --> 55:53.790
调用呗

55:55.070 --> 55:56.670
而sync1运行

55:56.670 --> 55:57.630
它是不是输出这个

55:58.510 --> 56:00.030
sync1 start

56:00.990 --> 56:02.030
然后调用啥

56:02.030 --> 56:03.070
调用而sync2

56:04.830 --> 56:06.430
输出而sync2

56:09.820 --> 56:09.980
好

56:09.980 --> 56:11.420
而sync2运行完了

56:11.420 --> 56:12.700
而sync2会返回啥

56:12.700 --> 56:13.740
返回一个promise

56:13.740 --> 56:14.860
这个promise是不是完成了

56:14.860 --> 56:15.820
它中间没爆错嘛

56:16.860 --> 56:17.660
它说了没返回

56:17.660 --> 56:19.180
它返回的就相当于sync2返回的

56:19.180 --> 56:20.940
所以这个sync2返回的是一个promise

56:21.900 --> 56:23.020
它的相关数据呢

56:23.020 --> 56:23.580
sync2返回的

56:24.300 --> 56:26.060
那我这里要等待这个promise完成

56:26.060 --> 56:27.580
现在是不是已经完成了

56:27.580 --> 56:29.580
那么后边单码进入围队里

56:30.300 --> 56:32.860
不再重复解释了

56:32.860 --> 56:34.700
这个相当于是在任里边

56:35.980 --> 56:36.860
不是马上运行

56:36.860 --> 56:38.540
虽然说它目前已经完成了

56:38.540 --> 56:39.260
但是呢

56:39.260 --> 56:40.140
它不是马上运行

56:40.140 --> 56:41.260
它进入围队里

56:41.260 --> 56:43.500
所以围队里边是输出

56:44.380 --> 56:47.020
而sync1n

56:47.900 --> 56:48.220
对吧

56:50.290 --> 56:51.570
那么而sync1调用完

56:51.570 --> 56:52.290
调用结束

56:54.050 --> 56:54.770
接下来

56:54.770 --> 56:56.210
创建一个新的promise

56:57.490 --> 56:58.450
这个新的promise呢

56:58.450 --> 56:59.730
马上运行这段代表

57:00.290 --> 57:01.010
输出promise

57:01.970 --> 57:06.240
然后呢

57:06.240 --> 57:07.520
把这个promise完成

57:07.520 --> 57:08.800
我们把这个promise进入一下

57:09.600 --> 57:10.880
p就是fulfill的

57:10.880 --> 57:12.320
不用记得

57:12.320 --> 57:13.520
其实这个地方很简单的

57:13.520 --> 57:14.800
完成这个promise

57:14.800 --> 57:16.000
完成这个promise

57:16.000 --> 57:17.040
然后这里一个rin

57:17.040 --> 57:19.520
目前这个promise是不是已经完成了

57:19.520 --> 57:20.240
已经完成了

57:20.240 --> 57:21.200
过后这个函数

57:21.200 --> 57:22.240
不好意思

57:22.240 --> 57:23.440
你进入围队里

57:23.440 --> 57:24.480
你不能马上执行了

57:25.440 --> 57:26.320
你进入围队里

57:26.320 --> 57:27.840
所以围队里边又加了一个

57:29.120 --> 57:30.800
输出promise

57:32.800 --> 57:34.000
接下来继续运行

57:34.000 --> 57:34.640
scripts end

57:38.270 --> 57:39.310
好运行完了之后

57:42.180 --> 57:43.220
从队里边排队了呗

57:44.500 --> 57:46.500
队里边有普通用户

57:46.500 --> 57:47.220
有vip

57:47.220 --> 57:48.660
那首先vip输出这个

57:48.660 --> 57:49.380
而sync1n

57:50.980 --> 57:51.620
输出这个

57:52.260 --> 57:53.380
好这个句话输出过后

57:53.380 --> 57:55.060
这个函数反复的promise就ok了

57:55.060 --> 57:55.780
就完成了

57:55.780 --> 57:56.660
之前一直在挂起

57:57.620 --> 57:58.420
好输出它

57:59.140 --> 58:00.500
然后呢再输出promise2

58:02.020 --> 58:02.420
就是这

58:03.620 --> 58:04.500
输出promise2

58:05.220 --> 58:06.820
好围队的情况了

58:06.820 --> 58:08.340
然后再来红队的

58:08.340 --> 58:09.300
输出这个

58:10.580 --> 58:11.540
输出这个

58:11.540 --> 58:12.580
输出这个

58:12.580 --> 58:13.300
输出这个

58:13.300 --> 58:13.780
输出这个

58:13.780 --> 58:14.580
输出这个

58:14.580 --> 58:15.220
输出这个

58:15.220 --> 58:16.420
这些挺比较背影

58:16.420 --> 58:17.300
怎么背得出

58:17.300 --> 58:19.380
这就对比一下

58:19.380 --> 58:20.580
肯定是没有问题的

58:20.580 --> 58:23.860
好这就是咱们promise里边

58:23.860 --> 58:25.060
常见的那些面试题

58:25.060 --> 58:26.260
还是比较复杂对吧

58:26.260 --> 58:28.260
可能都挺晕的

58:28.260 --> 58:30.260
这些题呢我跟你们说

58:30.260 --> 58:32.260
现阶段呢

58:32.260 --> 58:34.020
不对你们做过多的要求

58:34.100 --> 58:35.300
你们能听懂多少

58:35.300 --> 58:36.020
听懂多少

58:36.020 --> 58:37.060
尽量听懂一些

58:37.940 --> 58:39.380
平时我跟我们开发呢

58:39.380 --> 58:41.940
其实关系到不是特别大

58:41.940 --> 58:43.380
但是你这一点要知道

58:43.780 --> 58:44.500
它是

58:44.500 --> 58:45.620
你只剩下记住一点

58:45.620 --> 58:47.620
就是GS代码它永远不会卡住

58:48.980 --> 58:50.180
不过在那里啥等

58:50.180 --> 58:51.220
等一个东西完成了

58:51.220 --> 58:52.740
完了过后我才继续往后运行

58:52.740 --> 58:53.700
它有事就去做

58:54.900 --> 58:57.380
这就是GS的异部处理机制

58:57.380 --> 58:58.660
我不会等

58:58.660 --> 58:59.380
不会很干等

58:59.380 --> 59:00.580
我后边有事我就马上

59:00.580 --> 59:02.100
往后边的事就去了

59:03.060 --> 59:04.260
你那边完成过

59:04.260 --> 59:05.540
说为什么我们跑过来重新运行

59:05.540 --> 59:06.740
你就想吧

59:06.740 --> 59:08.980
所以说这道题

59:08.980 --> 59:10.100
就这一部分呢

59:10.100 --> 59:11.860
前面几道题还比较关键一点

59:11.860 --> 59:14.100
前面几道题就去再告诉你

59:14.100 --> 59:15.460
它不会卡住代码

59:15.460 --> 59:16.820
你看这里

59:16.820 --> 59:18.420
没有

59:18.420 --> 59:19.700
我这里

59:19.700 --> 59:20.500
然后说向这

59:23.540 --> 59:24.180
向这

59:24.180 --> 59:27.300
然后我这里

59:27.300 --> 59:29.140
等待了一秒钟过后

59:29.140 --> 59:31.540
它不会说我这边必须要等你一秒

59:31.540 --> 59:33.140
然后再运行这个

59:33.140 --> 59:34.580
然后再运行这个

59:34.580 --> 59:35.940
它不会卡住的

59:35.940 --> 59:37.140
它是等没有等

59:37.140 --> 59:37.780
你去等呗

59:37.780 --> 59:39.220
把技师线进去等呗

59:39.220 --> 59:39.940
等完了过后

59:39.940 --> 59:42.580
我回过头来再运行就完成了

59:42.580 --> 59:44.340
所以这一点大家要理解清楚

59:44.340 --> 59:47.220
这个而未成的它只是一个愚法堂

59:47.220 --> 59:48.740
感觉上的好像这个代码

59:48.740 --> 59:50.020
这个函数在卡住了

59:50.020 --> 59:51.540
别人感觉上是卡住的

59:51.540 --> 59:52.180
对吧

59:52.180 --> 59:54.260
等待它过后再继续运行

59:54.260 --> 59:55.620
实际上是一个愚法堂

59:55.620 --> 59:57.620
后边当中心的实际上是在认里边

59:57.620 --> 59:58.500
就可以这样理解

59:58.500 --> 01:00:01.060
好

01:00:01.060 --> 01:00:02.180
这是这结果的那种

01:00:02.180 --> 01:00:03.220
尽量理解吧

01:00:03.220 --> 01:00:04.660
因为你现在当然要说

01:00:04.660 --> 01:00:07.540
我一定要要求你把这些

01:00:07.540 --> 01:00:09.220
没道理解的非常透彻了

01:00:09.220 --> 01:00:10.660
可能不是很现实

01:00:10.660 --> 01:00:14.420
慢慢随着大家代码量的提升

01:00:14.420 --> 01:00:15.860
逻辑思维能力的提升

01:00:15.860 --> 01:00:19.940
你能力到真正到了面试的阶段的时候

01:00:19.940 --> 01:00:21.300
再回过头来看的话

01:00:21.300 --> 01:00:22.900
感触就会有不一样

01:00:22.900 --> 01:00:23.700
但是这些东西

01:00:23.700 --> 01:00:25.620
我必须要提前给你们说

01:00:25.620 --> 01:00:26.180
不说的话

01:00:26.260 --> 01:00:27.220
后边讲起来

01:00:27.220 --> 01:00:28.980
想有某些知识的时候

01:00:28.980 --> 01:00:30.100
会有很多的隐患

01:00:30.100 --> 01:00:31.860
好

01:00:31.860 --> 01:00:33.860
我希望了这一段时间

01:00:33.860 --> 01:00:34.900
要学习这个ProMesh

01:00:34.900 --> 01:00:36.180
能够把我们课程里边

01:00:36.180 --> 01:00:37.700
理解个百分之六十

01:00:37.700 --> 01:00:40.900
百分之五十就不错了

01:00:40.900 --> 01:00:42.340
咱们面试的时候

01:00:42.340 --> 01:00:43.700
咱们再回过头来复习

01:00:43.700 --> 01:00:45.140
如果说我现在这点

01:00:45.140 --> 01:00:46.020
见到人我啥都不讲

01:00:46.020 --> 01:00:47.780
直接等到你面试的时候来说的话

01:00:47.780 --> 01:00:49.060
你们就直接更加懵了

01:00:49.060 --> 01:00:51.220
而且还会对面试之前

01:00:51.220 --> 01:00:51.780
你们学习它

01:00:51.780 --> 01:00:52.740
这次造成很多困扰的

01:00:52.740 --> 01:00:54.100
好

01:00:54.100 --> 01:00:55.860
那么这一刻就到此结束了

01:00:55.860 --> 01:00:57.140
好

01:00:57.140 --> 01:00:58.180
拜拜

