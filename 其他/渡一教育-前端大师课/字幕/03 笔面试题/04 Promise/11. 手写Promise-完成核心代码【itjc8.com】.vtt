WEBVTT

00:00.940 --> 00:04.740
好的同学们 我们到现在呢 我们一切都准备好了

00:04.740 --> 00:09.540
我们可以通过result和reject来改变promise的状态

00:09.540 --> 00:15.540
也可以通过这种方法来给promise增加一些执行函数

00:15.540 --> 00:18.340
那么这些函数呢会放到一个队列里边

00:18.340 --> 00:20.540
这个队列里边你看就是一个数组

00:20.540 --> 00:24.940
将来实际成熟之后 我们会循环遍地这个队列

00:24.940 --> 00:29.940
然后呢一次拿出来每一个执行器 我们一次去处理它

00:29.940 --> 00:32.940
一切都准备好了 就差最后一步了

00:32.940 --> 00:36.940
所以我们这些可能就来实现这个方法

00:36.940 --> 00:41.940
处理一个运行一个执行器 运行一个处理器

00:41.940 --> 00:44.940
那么这个方法里边我们一旦实现好了

00:44.940 --> 00:48.940
我们整个promiseA加规范就全部实现了

00:48.940 --> 00:50.940
好 我们来实现这个方法

00:50.940 --> 00:52.940
这个方法里边有个参数叫Handler

00:52.940 --> 00:55.940
这个Handler是什么呢 其实就是这里的对象

00:55.940 --> 00:57.940
对不对 每一个对象

00:57.940 --> 01:02.940
通过循环遍地的方式一试给它传过来

01:02.940 --> 01:05.940
那么这个对象拿到之后 我们要做什么事情呢

01:05.940 --> 01:08.940
首先我们回忆一下 任方法

01:08.940 --> 01:12.940
这个对象里边是不是包含了任方法传递的函数啊

01:12.940 --> 01:15.940
我们这个函数是不是就传过来的

01:15.940 --> 01:18.940
那么这个函数我们知道是要放到一个V队列里边执行

01:18.940 --> 01:20.940
所以说整个的处理过程

01:20.940 --> 01:23.940
我们是否会把它放到V队列里边进行处理

01:23.940 --> 01:26.940
而V队列我们之前是不是写过这么一个函数

01:26.940 --> 01:28.940
叫做Rom Microtask

01:28.940 --> 01:30.940
那么我们现在就利用这个函数

01:30.940 --> 01:33.940
找到Rom Microtask

01:33.940 --> 01:35.940
然后我们这里边给它传一个函数进去

01:35.940 --> 01:37.940
也就是我们现在把这个函数呢

01:37.940 --> 01:42.940
就把整个处理过程放到一个V队列里边

01:42.940 --> 01:44.940
然后这个函数里边做什么事情呢

01:44.940 --> 01:46.940
我们现在来分析它的逻辑

01:46.940 --> 01:49.940
那么比方说 我目前的状态

01:49.940 --> 01:54.940
我现在把这个地方 把这个地方打印放这儿吧

01:55.940 --> 01:56.940
放这儿

01:58.940 --> 02:00.940
我们输出一下

02:00.940 --> 02:04.830
输出一下这个Handle

02:04.830 --> 02:05.830
好 运行啊

02:05.830 --> 02:08.830
那么现在我们输出了四次对吧

02:08.830 --> 02:15.700
我们再来输出一下我们当前的状态

02:15.700 --> 02:19.700
当前的状态是Z state

02:19.700 --> 02:20.700
好 我们运行一下

02:20.700 --> 02:23.700
你看一下我们目前的状态是Fulfilled

02:23.700 --> 02:24.700
为什么是Fulfilled呢

02:24.700 --> 02:26.700
是因为我这里用了Raisal

02:26.700 --> 02:28.700
当然如果说我这里改成了Ragent

02:28.700 --> 02:30.700
它自然就变了 变成Ragent

02:30.700 --> 02:32.700
那么这是我们目前的状态

02:32.700 --> 02:34.700
然后这里有一个Handle

02:34.700 --> 02:35.700
Handle是一个对象

02:35.700 --> 02:37.700
对象里面也有一个状态

02:37.700 --> 02:39.700
那么这个状态是什么意思呢

02:39.700 --> 02:41.700
表示的是当什么什么的时候

02:41.700 --> 02:43.700
我要执行这个函数

02:43.700 --> 02:44.700
对不对

02:44.700 --> 02:45.700
那么这里会有一个逻辑

02:45.700 --> 02:46.700
就是如果说我这个状态

02:46.700 --> 02:48.700
跟这个状态不一致

02:48.700 --> 02:50.700
那这个函数值不执行

02:50.700 --> 02:51.700
是不执行

02:51.700 --> 02:53.700
因为它需要的是这个状态

02:53.700 --> 02:55.700
但是我们目前是这个状态

02:55.700 --> 02:56.700
状态不一致

02:56.700 --> 02:58.700
不一致的话就什么也不做

02:58.700 --> 03:00.700
对吧 这个好理解 对不对

03:00.700 --> 03:01.700
好 咱们来看一下

03:01.700 --> 03:04.700
所以说这里可以首先解决这么一个判断

03:04.700 --> 03:07.700
如果说我们目前的状态

03:07.700 --> 03:10.700
不等于Handle里面的状态

03:10.700 --> 03:12.700
那么这个时候我们就啥也不做

03:12.700 --> 03:14.700
对吧 状态不匹配

03:14.700 --> 03:16.700
就你传了 传没传函数传了

03:16.700 --> 03:18.700
但是由于我们状态不匹配

03:18.700 --> 03:21.700
你说的是要失败之后运行

03:21.700 --> 03:22.700
你要成功之后运行

03:22.700 --> 03:24.700
但是我们目前是失败的

03:24.700 --> 03:26.700
所以你这种传来跟没传一样

03:26.700 --> 03:28.700
那么这里表示的是

03:28.700 --> 03:30.700
状态不一致

03:32.700 --> 03:34.700
这个函数达不到执行的条件

03:34.700 --> 03:36.700
所以说不处理

03:36.700 --> 03:38.700
不做任何处理

03:38.700 --> 03:39.700
这是这种情况

03:39.700 --> 03:40.700
那么这种情况

03:40.700 --> 03:41.700
我们把筛选出气之后

03:41.700 --> 03:42.700
我们再来看

03:42.700 --> 03:44.700
还剩下哪些Handle了

03:44.700 --> 03:45.700
是不是就筛选掉了一些了

03:45.700 --> 03:46.700
我们只剩下什么了

03:46.700 --> 03:48.700
状态保持一致的

03:48.700 --> 03:49.700
看没

03:49.700 --> 03:51.700
好 状态保持一致的情况下

03:51.700 --> 03:53.700
一看是不是还有一种情况

03:53.700 --> 03:55.700
就是他传的不是函数

03:55.700 --> 03:57.700
他传的可能是Nd半的

03:57.700 --> 03:58.700
比较像这

03:58.700 --> 03:59.700
他第二参数没传

03:59.700 --> 04:00.700
对吧 第二参数没传

04:00.700 --> 04:02.700
相当于是传了一个Nd半的

04:02.700 --> 04:04.700
那么也有可能的第二参数传了

04:04.700 --> 04:05.700
传的是Mao

04:05.700 --> 04:06.700
或者是传的是123

04:06.700 --> 04:07.700
传的是一个字无创

04:07.700 --> 04:08.700
传的是一个对象

04:08.700 --> 04:10.700
总之不是一个正常的函数

04:10.700 --> 04:11.700
懂了意思吧

04:11.700 --> 04:13.700
那么这些都是无效的传递

04:13.700 --> 04:14.700
所以说我们这里

04:14.700 --> 04:16.700
还要判断这种情况

04:16.700 --> 04:18.700
好 这里我们判断一下

04:18.700 --> 04:21.700
如果说你给我传的函数

04:21.700 --> 04:23.700
状态一致了 没问题了

04:23.700 --> 04:24.700
那状态一致

04:24.700 --> 04:26.700
但是你给我传的这个excutor

04:26.700 --> 04:27.700
他不是一个函数

04:27.700 --> 04:29.700
怎么来看他是不是函数呢

04:29.700 --> 04:30.700
太可恶了

04:30.700 --> 04:33.700
对吧 是不是等于方形

04:33.700 --> 04:37.020
如果说你不是一个函数

04:37.020 --> 04:41.020
这里是传递的处理

04:41.020 --> 04:44.020
后续处理

04:44.020 --> 04:46.020
并非一个函数

04:46.020 --> 04:47.020
那么他不是函数

04:47.020 --> 04:48.020
大家回顾一下

04:48.020 --> 04:50.020
这要好好回顾一下

04:50.020 --> 04:51.020
他是怎么处理的

04:51.020 --> 04:53.020
他是不处理吗

04:53.020 --> 04:55.020
还是会做一些处理

04:55.020 --> 04:58.020
他如果传的不是函数

04:58.020 --> 05:00.020
如果说前边的知识

05:00.020 --> 05:02.020
学的比较细的同学

05:02.020 --> 05:04.020
应该能够回忆得起来

05:04.020 --> 05:06.020
当你有一些参数

05:06.020 --> 05:07.020
是无效的参数

05:07.020 --> 05:08.020
或者是你没有传递

05:08.020 --> 05:10.020
就是我们之前说的什么

05:10.020 --> 05:13.020
之前说的状态穿透

05:13.020 --> 05:14.020
比方说这里

05:14.020 --> 05:15.020
反回一个promise2

05:15.020 --> 05:17.020
任方法会反回一个新的promise

05:17.020 --> 05:19.020
我们说这个promise的状态

05:19.020 --> 05:20.020
是什么呢

05:20.020 --> 05:23.020
如果说他失败了

05:23.020 --> 05:27.020
但是我没有失败的处理

05:27.020 --> 05:29.020
那么他的状态

05:29.020 --> 05:32.020
跟他保持完全一致

05:32.020 --> 05:34.020
他这个状态已经确定了

05:34.020 --> 05:36.020
无论是成功还是失败

05:36.020 --> 05:39.020
但是他找不到相关的处理

05:39.020 --> 05:40.020
这种找不到什么情况

05:40.020 --> 05:41.020
你没有传

05:41.020 --> 05:43.020
或者是你传的不是一个函数

05:43.020 --> 05:45.020
都是没有相关处理

05:45.020 --> 05:46.020
那么这种情况下

05:46.020 --> 05:47.020
我们要把穿透

05:47.020 --> 05:48.020
他的状态是什么

05:48.020 --> 05:49.020
他就是什么

05:49.020 --> 05:51.020
他成功他就成功

05:51.020 --> 05:52.020
他的数据是什么

05:52.020 --> 05:53.020
他就说是什么

05:53.020 --> 05:54.020
他失败他就失败

05:54.020 --> 05:55.020
他的失败原因是什么

05:55.020 --> 05:56.020
他就是什么

05:56.020 --> 05:57.020
懂了意思吧

05:57.020 --> 05:59.020
那我们这里解释一样的逻辑

05:59.020 --> 06:01.020
如果说你够传的处理函数

06:01.020 --> 06:02.020
处理器他不是一个函数

06:02.020 --> 06:04.020
不是函数的话

06:04.020 --> 06:07.020
那么我这个promise是什么状态

06:07.020 --> 06:09.020
你也跟着是什么状态

06:09.020 --> 06:10.020
如果说我成功了

06:10.020 --> 06:12.020
你要调用这个result

06:12.020 --> 06:14.020
如果说我失败了

06:14.020 --> 06:15.020
你要调用这个result

06:15.020 --> 06:16.020
所以说这里呢

06:16.020 --> 06:18.020
我们就直接用个三目运算服务

06:18.020 --> 06:21.020
如果说我的状态是什么

06:21.020 --> 06:23.020
是fulfilled

06:23.020 --> 06:27.030
如果说我这个状态是这个

06:27.030 --> 06:28.030
我成功了

06:28.030 --> 06:30.030
如果说我成功了的话

06:30.030 --> 06:33.030
我要调用这个handled的result

06:33.030 --> 06:34.030
调用这个

06:34.030 --> 06:36.030
那么数据是什么呢

06:36.030 --> 06:37.030
就是我的数据

06:37.030 --> 06:39.030
叫做状态穿透

06:39.030 --> 06:41.030
如果说我失败了

06:41.030 --> 06:43.030
那么我就要调用handled

06:43.030 --> 06:44.030
的result

06:47.030 --> 06:49.030
然后我给他数据是什么呢

06:50.030 --> 06:51.030
对吧

06:51.030 --> 06:53.030
这就处理这么一种情况

06:53.030 --> 06:54.030
好

06:54.030 --> 06:55.030
那咱们来试一下

06:55.030 --> 06:57.030
试一下看是不是真的是这样

06:57.030 --> 06:58.030
好

06:58.030 --> 06:59.030
比方说我们这里呢

06:59.030 --> 07:01.030
把这个组织掉

07:01.030 --> 07:02.030
现在呢

07:02.030 --> 07:03.030
我们一秒

07:03.030 --> 07:05.030
也就是一段时间之后

07:05.030 --> 07:07.030
一秒钟之后

07:07.030 --> 07:08.030
一秒钟之后

07:08.030 --> 07:10.030
这个promise失败了

07:10.030 --> 07:11.030
那么失败

07:11.030 --> 07:12.030
他又没有失败的处理函数

07:12.030 --> 07:13.030
没有

07:13.030 --> 07:15.030
那么他正反回的promise

07:15.030 --> 07:16.030
也会跟着失败

07:16.030 --> 07:17.030
失败的原因

07:17.030 --> 07:18.030
跟这里的原因是一样的

07:18.030 --> 07:19.030
那我们来试一下

07:19.030 --> 07:21.030
我通过一段时间

07:21.030 --> 07:22.030
比方说我们这里

07:22.030 --> 07:24.030
在他冒着之后

07:24.030 --> 07:26.030
两秒钟吧

07:26.030 --> 07:27.030
或者一千五万秒

07:27.030 --> 07:28.030
一千五万毫秒

07:28.030 --> 07:29.030
然后我们输出promise二

07:29.030 --> 07:30.030
一

07:30.030 --> 07:33.030
promise一和promise二

07:33.030 --> 07:34.030
看一下两个状态

07:34.030 --> 07:36.030
是不是一致的

07:36.030 --> 07:38.030
一点五秒之后

07:38.030 --> 07:39.030
你看

07:39.030 --> 07:40.030
两个promise的状态

07:40.030 --> 07:42.030
是不是都是维权体的

07:42.030 --> 07:43.030
对吧

07:43.030 --> 07:44.030
只都是一

07:44.030 --> 07:45.030
都没问题吧

07:45.030 --> 07:47.030
就这要状态的穿透

07:47.030 --> 07:48.030
那么同样的道理

07:48.030 --> 07:49.030
如果说我没有

07:49.030 --> 07:51.030
连成功都没有团体

07:51.030 --> 07:52.030
这里如果说成功了

07:52.030 --> 07:53.030
余祚

07:53.030 --> 07:54.030
我这里成功了

07:54.030 --> 07:55.030
但是我这里

07:55.030 --> 07:57.030
没有处理成功的函数

07:57.030 --> 07:58.030
对吧

07:58.030 --> 07:59.030
然后我们来再试一下

07:59.030 --> 08:01.860
你看

08:01.860 --> 08:02.860
是不是两个状态都是成功的

08:02.860 --> 08:03.860
对吧

08:03.860 --> 08:05.860
这就是我们想要的一个结果

08:05.860 --> 08:06.860
懂了意思吗

08:06.860 --> 08:07.860
好

08:07.860 --> 08:12.220
把这个注射了

08:12.220 --> 08:13.220
把这个再取消注射

08:13.220 --> 08:17.510
好

08:17.510 --> 08:18.510
现在我们回到这

08:18.510 --> 08:19.510
继续来编写

08:19.510 --> 08:20.510
这里的逻辑

08:20.510 --> 08:21.510
现在我们什么情况呢

08:21.510 --> 08:23.510
现在我们的情况就是

08:23.510 --> 08:24.510
一秒钟之后

08:24.510 --> 08:26.510
现在的状态要处理了

08:26.510 --> 08:27.510
要进行处理的

08:27.510 --> 08:29.510
然后我们这里搞定了什么呢

08:29.510 --> 08:31.510
搞定了就是

08:32.510 --> 08:33.510
处理

08:33.510 --> 08:35.510
它处理器不是一个函数的情况

08:35.510 --> 08:36.510
对吧

08:36.510 --> 08:38.510
这种情况我们搞定了

08:38.510 --> 08:40.510
传令到后续处理并非一个函数

08:40.510 --> 08:41.510
那么我们看一下

08:41.510 --> 08:43.510
剩下还有什么情况

08:43.510 --> 08:45.950
进行

08:46.950 --> 08:47.950
好

08:47.950 --> 08:48.950
剩下的就是一个正常的函数了

08:48.950 --> 08:49.950
对吧

08:49.950 --> 08:50.950
状态也一致

08:50.950 --> 08:51.950
也是一个正常的函数

08:51.950 --> 08:52.950
那么这个时候怎么处理呢

08:52.950 --> 08:54.950
是不是要执行这个函数

08:55.950 --> 08:56.950
对不对

08:56.950 --> 08:57.950
而且我们知道之前

08:57.950 --> 08:58.950
怎么说的

08:58.950 --> 09:00.950
我们这个Promise的状态

09:00.950 --> 09:01.950
应该取决于什么呢

09:01.950 --> 09:03.950
取决于这边的执行的函数

09:03.950 --> 09:05.950
比方说我们这里有个Data

09:05.950 --> 09:08.650
输出Data

09:08.650 --> 09:10.650
返回一个1

09:10.650 --> 09:11.650
返回一个123

09:11.650 --> 09:12.650
比方说

09:12.650 --> 09:14.650
我们这里有Riddle

09:15.650 --> 09:16.650
运行看一下

09:17.650 --> 09:18.650
好

09:18.650 --> 09:19.650
那么这里我们传递了两个

09:19.650 --> 09:20.650
对不对

09:20.650 --> 09:21.650
下边还有

09:21.650 --> 09:22.650
下边还有一个A2

09:22.650 --> 09:23.650
这是

09:23.650 --> 09:24.650
这是第一个

09:25.650 --> 09:26.650
好

09:26.650 --> 09:27.650
那么我们来看一下

09:27.650 --> 09:28.650
比方说我们现在不考虑这个吧

09:28.650 --> 09:32.220
我们就考虑上面这个

09:32.220 --> 09:33.220
状态一致

09:33.220 --> 09:34.220
传的也是函数

09:34.220 --> 09:35.220
那么现在我们干嘛

09:35.220 --> 09:37.220
是不是要执行这个函数

09:37.220 --> 09:39.220
这个函数的返回结果

09:39.220 --> 09:40.220
这个函数如果说

09:40.220 --> 09:41.220
执行过程中没有爆错

09:41.220 --> 09:43.220
那么它就是成功的

09:43.220 --> 09:44.220
它的数据是什么呢

09:44.220 --> 09:46.220
数据就是这个返回结果

09:46.220 --> 09:47.220
如果说执行的过程中

09:47.220 --> 09:48.220
爆了错

09:48.220 --> 09:49.220
那么它就是失败的

09:49.220 --> 09:50.220
那么它的数据

09:50.220 --> 09:51.220
失败的原因

09:51.220 --> 09:52.220
就是爆了错误

09:52.220 --> 09:53.220
因此

09:53.220 --> 09:54.220
我们这边

09:54.220 --> 09:55.220
回到这

09:55.220 --> 09:57.220
逻辑是应该是什么呢

09:58.220 --> 10:01.220
通过揣开起来执行

10:01.220 --> 10:03.220
这个handle

10:03.220 --> 10:05.220
excutor

10:05.220 --> 10:06.220
那么这里有个小细节

10:06.220 --> 10:07.220
如果说你这样调用的话

10:07.220 --> 10:10.220
那么会导致这个函数的内部

10:10.220 --> 10:11.220
就是这个函数的内部

10:11.220 --> 10:12.220
Z是会指向它

10:12.220 --> 10:14.220
这个是不太合适的

10:14.220 --> 10:16.220
我希望就是

10:16.220 --> 10:17.220
怎么处理呢这个地方

10:17.220 --> 10:18.220
其实你可以这样子

10:18.220 --> 10:19.220
其实你可以非常简单的

10:19.220 --> 10:21.220
在这里做一个结构

10:21.220 --> 10:22.220
excutor

10:22.220 --> 10:23.220
它一共就这么一些嘛

10:23.220 --> 10:24.220
excutor state

10:24.220 --> 10:25.220
result

10:25.220 --> 10:26.220
reject

10:26.220 --> 10:27.220
对吧

10:27.220 --> 10:28.220
一共就这么四个属性

10:28.220 --> 10:29.220
然后我们这里

10:29.220 --> 10:30.220
后边我们就直接

10:30.220 --> 10:31.220
通过这个

10:31.220 --> 10:32.220
不需要那个点了

10:32.220 --> 10:34.220
把这个点去掉

10:34.220 --> 10:35.220
这是没问题吧

10:35.220 --> 10:36.220
很简单

10:36.220 --> 10:37.220
那我们这里是不是

10:37.220 --> 10:39.220
可以直接调用excutor

10:39.220 --> 10:40.220
直接调用

10:40.220 --> 10:42.220
这个Z是指向里没问题的

10:42.220 --> 10:43.220
好 调用它

10:43.220 --> 10:44.220
调用它的时候

10:44.220 --> 10:46.220
我们需要传什么参数呢

10:46.220 --> 10:47.220
那你看

10:47.220 --> 10:48.220
我们这个函数

10:48.220 --> 10:49.220
是不是有个参数啊

10:49.220 --> 10:50.220
无论是失败的

10:50.220 --> 10:51.220
处理函数

10:51.220 --> 10:52.220
还是成功的处理函数

10:52.220 --> 10:53.220
是不是有个参数

10:53.220 --> 10:55.220
这个参数是不是要传递进来

10:55.220 --> 10:56.220
这是它的参数是什么

10:56.220 --> 10:58.220
是不是有当前的Promise的Value

10:58.220 --> 10:59.220
它的值

10:59.220 --> 11:01.220
所以传参数是固定的

11:01.220 --> 11:02.220
传递什么呢

11:02.220 --> 11:04.220
传递的是Z

11:04.220 --> 11:05.220
Value

11:05.220 --> 11:07.220
传递的是Z

11:07.220 --> 11:08.220
对吧

11:08.220 --> 11:09.220
好 参数传进去

11:09.220 --> 11:11.220
然后去执行它

11:11.220 --> 11:13.220
如果说执行的期间有错

11:13.220 --> 11:15.220
有错怎么样呢

11:15.220 --> 11:17.220
是不是我就要拒绝

11:17.220 --> 11:19.220
调用这个reject

11:19.220 --> 11:21.220
调用这个reject

11:21.220 --> 11:23.220
这个Promise

11:23.220 --> 11:25.220
绝对错误的对象

11:25.220 --> 11:27.220
就是我们的原因

11:27.220 --> 11:29.220
这个逻辑就通了

11:29.220 --> 11:31.220
好 咱们来试一下

11:31.220 --> 11:33.220
现在我们到这边来

11:33.220 --> 11:34.220
比方说

11:34.220 --> 11:35.220
我这里result成功了

11:35.220 --> 11:36.220
成功了是不是要执行它

11:36.220 --> 11:37.220
那它执行的过程中

11:37.220 --> 11:38.220
如果说产生了错误

11:38.220 --> 11:41.220
我们就跑出一个ABC

11:41.220 --> 11:44.220
那我们来看一下Promise2的状态

11:44.220 --> 11:45.220
我们等一会

11:45.220 --> 11:48.220
因为我等Promise1完成之后

11:48.220 --> 11:50.220
然后这个玩意到E不对列

11:50.220 --> 11:51.220
到V对列

11:51.220 --> 11:53.220
然后再去执行这个函数

11:53.220 --> 11:54.220
所以说Promise2

11:54.220 --> 11:56.220
我要等一会再打印

11:56.220 --> 11:58.220
然后等个50毫秒吧

11:58.220 --> 11:59.220
然后再打印

11:59.220 --> 12:00.220
打印什么呢

12:00.220 --> 12:02.220
Promise2

12:02.220 --> 12:03.220
那么我们预计的状态

12:03.220 --> 12:05.220
应该是失败的

12:05.220 --> 12:07.220
Promise1成功了

12:07.220 --> 12:08.220
但是Promise2的

12:08.220 --> 12:09.220
后续处理过程中

12:09.220 --> 12:10.220
出现了问题

12:10.220 --> 12:11.220
Promise2失败

12:11.220 --> 12:12.220
失败的原因

12:12.220 --> 12:13.220
应该就是这个ABC

12:13.220 --> 12:15.220
看看这个逻辑是不是搞定的

12:15.220 --> 12:17.220
这是这一块

12:17.220 --> 12:18.220
这是失败的逻辑

12:18.220 --> 12:20.220
那么失败的逻辑搞定了之后

12:20.220 --> 12:21.220
我把这些折一折

12:21.220 --> 12:22.220
避免我们干的

12:22.220 --> 12:24.220
失败干的

12:24.220 --> 12:26.220
把这些折一折折起来

12:26.220 --> 12:27.220
好 我回到这

12:27.220 --> 12:29.220
那么如果说没有失败

12:29.220 --> 12:30.220
正常执行

12:30.220 --> 12:31.220
成功了怎么办

12:31.220 --> 12:32.220
那成功的情况

12:32.220 --> 12:33.220
我们这里跑错了

12:33.220 --> 12:35.220
那就正常执行 没有问题

12:35.220 --> 12:36.220
那我是不是说

12:36.220 --> 12:37.220
互相的反回结果呀

12:37.220 --> 12:38.220
对不对

12:38.220 --> 12:39.220
好 那我们这里

12:39.220 --> 12:41.220
是不是要拿到它的反回结果

12:41.220 --> 12:44.220
Results

12:44.220 --> 12:45.220
这个反回结果

12:45.220 --> 12:46.220
我们怎么样呢

12:46.220 --> 12:47.220
我们首先

12:47.220 --> 12:49.220
因为它执行过程中没有爆错

12:49.220 --> 12:50.220
所以说我们要做什么

12:50.220 --> 12:51.220
要Result

12:51.220 --> 12:52.220
对不对

12:52.220 --> 12:54.220
是不是我们要让Promise完成

12:54.220 --> 12:55.220
完成之后

12:55.220 --> 12:56.220
它的数据是什么呢

12:56.220 --> 12:57.220
就是这个函数的反回结果

12:57.220 --> 12:59.220
我们把函数的反回结果

12:59.220 --> 13:00.220
作为这个的数据

13:00.220 --> 13:01.220
让它Result

13:01.220 --> 13:02.220
就使用这个数据

13:02.220 --> 13:04.220
好 咱们再来看一下

13:04.220 --> 13:05.220
那么现在呢

13:05.220 --> 13:06.220
我们没有爆错

13:06.220 --> 13:08.220
是不是FulfilledValue的E23

13:08.220 --> 13:09.220
这里都没有问题了

13:09.220 --> 13:10.220
对不对

13:10.220 --> 13:12.220
Promise2是一个Promise

13:12.220 --> 13:14.220
它的状态是FulfilledValue的E23

13:14.220 --> 13:15.220
都没有问题了

13:15.220 --> 13:17.220
其实现在还有个小细节

13:17.220 --> 13:18.220
什么小细节呢

13:18.220 --> 13:19.220
就是如果说我这里

13:19.220 --> 13:20.220
反回的是什么

13:20.220 --> 13:22.220
反回的不是数字

13:22.220 --> 13:24.220
反回的是一个Promise

13:24.220 --> 13:26.220
我又反回的是一个Promise

13:27.220 --> 13:29.220
好 那么这个Promise的状态

13:29.220 --> 13:31.220
比方说Result

13:33.220 --> 13:35.220
比方说像这种情况

13:35.220 --> 13:37.220
那么这种情况呢

13:37.220 --> 13:38.220
如果说你反回的是Promise

13:38.220 --> 13:41.220
那么它的状态和数据

13:41.220 --> 13:44.220
跟它保持完全一致

13:44.220 --> 13:45.220
就是我们说过的

13:45.220 --> 13:46.220
如果说你反回的是

13:46.220 --> 13:47.220
一个特殊情况

13:47.220 --> 13:48.220
是Promise

13:48.220 --> 13:49.220
那么这个Promise

13:49.220 --> 13:50.220
是什么情况

13:50.220 --> 13:51.220
它就是什么情况

13:51.220 --> 13:52.220
保持完全一致

13:52.220 --> 13:53.220
好 因此呢

13:53.220 --> 13:54.220
我们在这里呢

13:54.220 --> 13:55.220
又会有一个逻辑

13:55.220 --> 13:56.220
就是你如果说你

13:56.220 --> 13:57.220
这个反回的结果

13:57.220 --> 13:58.220
是Promise

13:58.220 --> 13:59.220
那么这里问题来了

13:59.220 --> 14:00.220
我如何来判断

14:00.220 --> 14:02.220
它是不是一个Promise

14:02.220 --> 14:03.220
好 这里呢

14:03.220 --> 14:04.220
有个

14:04.220 --> 14:06.220
也不算姿势点吧

14:06.220 --> 14:08.220
就是这么一个情况

14:08.220 --> 14:09.220
给大家说明一下

14:09.220 --> 14:10.220
我们有的时候呢

14:10.220 --> 14:11.220
会在函数里边

14:11.220 --> 14:12.220
特别是你写一些

14:13.220 --> 14:15.220
或者是写一些框架

14:15.220 --> 14:16.220
当然这些一些

14:16.220 --> 14:17.220
高阶的编程

14:17.220 --> 14:19.220
如果说写这些东西的时候

14:19.220 --> 14:20.220
很有可能

14:20.220 --> 14:21.220
会遇到

14:21.220 --> 14:22.220
要判断一个东西

14:22.220 --> 14:23.220
是不是Promise

14:23.220 --> 14:24.220
我给大家写一下

14:24.220 --> 14:26.220
其实非常简单

14:26.220 --> 14:28.220
如何来判断一个东西

14:28.220 --> 14:29.220
是不是Promise呢

14:29.220 --> 14:30.220
我们做一个简单的

14:30.220 --> 14:31.220
判断就行了

14:31.220 --> 14:32.220
不用去判断

14:32.220 --> 14:33.220
它是什么构造函数

14:33.220 --> 14:34.220
有一种人说

14:34.220 --> 14:35.220
那我们能不能

14:35.220 --> 14:36.220
判断这个Instance

14:36.220 --> 14:37.220
不要这样去做

14:37.220 --> 14:38.220
首先为什么

14:38.220 --> 14:39.220
不要去这样做

14:39.220 --> 14:40.220
因为Promise

14:40.220 --> 14:41.220
这个东西

14:41.220 --> 14:42.220
认为只要满足Promise

14:42.220 --> 14:44.220
A加规范就可以了

14:44.220 --> 14:45.220
你不一定

14:45.220 --> 14:46.220
一定得是

14:46.220 --> 14:47.220
ES6的Promise

14:47.220 --> 14:48.220
你更加不要说

14:48.220 --> 14:49.220
我们可以自己

14:49.220 --> 14:50.220
去写个Promise

14:50.220 --> 14:51.220
最好不要用

14:51.220 --> 14:52.220
这种方式来判断

14:52.220 --> 14:53.220
那么怎么来判断呢

14:53.220 --> 14:55.220
Promise A加规范规定

14:55.220 --> 14:57.220
Promise一定得是一个对象

14:57.220 --> 14:59.220
所以说OB界必须要有指

14:59.220 --> 15:00.220
同时呢

15:00.220 --> 15:02.220
OB界必须要是一个

15:02.220 --> 15:03.220
Object

15:03.220 --> 15:04.220
必须是个对象

15:04.220 --> 15:05.220
A加规范规定的

15:05.220 --> 15:06.220
然后呢

15:06.220 --> 15:08.220
它不仅要是一个对象

15:08.220 --> 15:09.220
而且它必须要

15:09.220 --> 15:10.220
含一个任方法

15:10.220 --> 15:12.220
OB界

15:12.220 --> 15:13.220
Type

15:13.220 --> 15:14.220
OB界叫任

15:14.220 --> 15:16.220
它必须要得是一个什么

15:16.220 --> 15:18.220
得是一个函数

15:18.220 --> 15:20.220
它必须要有个任方法

15:20.220 --> 15:21.220
那么剩下的事情

15:21.220 --> 15:22.220
我们就不做判定了

15:22.220 --> 15:24.220
说只要满足这个要求

15:24.220 --> 15:26.220
那么它就是一个Promise

15:26.220 --> 15:28.220
我们认为就这样

15:28.220 --> 15:29.220
好

15:29.220 --> 15:30.220
那么这里有可能

15:30.220 --> 15:32.220
会返回

15:32.220 --> 15:34.220
就是返回处的情况

15:34.220 --> 15:35.220
它肯定是一致的

15:35.220 --> 15:36.220
就是有可能

15:36.220 --> 15:37.220
如果说是Promise的情况

15:37.220 --> 15:38.220
它不是Promise的话

15:38.220 --> 15:40.220
它有可能会返回一些

15:40.220 --> 15:41.220
什么

15:41.220 --> 15:42.220
比方说这里是Undefine

15:42.220 --> 15:43.220
它就直接返回Undefine了

15:43.220 --> 15:44.220
那么这里呢

15:44.220 --> 15:45.220
这里倒是会返

15:45.220 --> 15:47.220
这里如果说为Q

15:47.220 --> 15:49.220
但是

15:49.220 --> 15:50.220
这里为Force

15:50.220 --> 15:52.220
这里如果说是Undefine的话

15:52.220 --> 15:53.220
它就可能返回Undefine

15:53.220 --> 15:55.220
那么这里如果说是0的话

15:55.220 --> 15:56.220
它就会返回0

15:56.220 --> 15:57.220
这不是我们想要的

15:57.220 --> 15:58.220
我们希望它返回的

15:58.220 --> 15:59.220
永远是True和Force

15:59.220 --> 16:00.220
那么这里有个小技巧

16:00.220 --> 16:02.220
加两个感叹号

16:02.220 --> 16:03.220
是吧

16:03.220 --> 16:04.220
先取反再取反

16:04.220 --> 16:05.220
是反反得正

16:05.220 --> 16:07.220
那么通过这种方式

16:07.220 --> 16:09.220
来转换成布尔类小

16:09.220 --> 16:10.220
那么这个方法

16:10.220 --> 16:11.220
做什么事情

16:15.220 --> 16:17.220
判断一个数据

16:17.220 --> 16:19.220
是否是Promise

16:19.220 --> 16:21.220
对象

16:21.220 --> 16:23.220
那么有了这个函数之后

16:23.220 --> 16:24.220
我们再回到这

16:24.220 --> 16:28.230
我们现在是否判断

16:28.230 --> 16:30.230
Promise Results

16:30.230 --> 16:32.230
如果说它是一个Promise

16:32.230 --> 16:33.230
我们之前分析过

16:33.230 --> 16:35.230
就你返回的东西

16:35.230 --> 16:36.230
它是Promise

16:36.230 --> 16:37.230
那我这个Promise的状态

16:37.230 --> 16:38.230
要给你保持一致

16:38.230 --> 16:39.230
那怎么弄呢

16:39.230 --> 16:40.230
是不是

16:40.230 --> 16:41.230
我就Results

16:41.230 --> 16:42.230
Zim

16:42.230 --> 16:43.230
你是Promise

16:43.230 --> 16:44.230
那肯定有函函数

16:44.230 --> 16:46.230
那么你如果说成功了

16:46.230 --> 16:48.230
你就帮我运行一下我的Results

16:48.230 --> 16:49.230
你如果说失败了

16:49.230 --> 16:50.230
就帮我运行一下

16:50.230 --> 16:51.230
我的Results

16:51.230 --> 16:52.230
是不是可以了

16:52.230 --> 16:53.230
你成功了

16:53.230 --> 16:54.230
我自然就掉入Results

16:54.230 --> 16:55.230
我就成功了

16:55.230 --> 16:56.230
你失败了

16:56.230 --> 16:57.230
我就掉入Results

16:57.230 --> 16:58.230
这个时候我就失败了

16:58.230 --> 16:59.230
这个邏輯就通了

16:59.230 --> 17:00.230
那当然

17:00.230 --> 17:02.230
如果说你不是Promise的话

17:02.230 --> 17:04.230
那么我就正常的Results

17:04.230 --> 17:05.230
执行因为爆错

17:05.230 --> 17:06.230
对吧

17:07.230 --> 17:09.230
现在我们来看一下

17:09.230 --> 17:11.230
现在我们返回的是一个Promise

17:11.230 --> 17:12.230
运行

17:12.230 --> 17:14.230
我这里它成功了

17:14.230 --> 17:15.230
我也成功了

17:15.230 --> 17:18.610
那如果它失败了呢

17:18.610 --> 17:20.610
我也失败了

17:20.610 --> 17:21.610
好了同学们

17:21.610 --> 17:22.610
至此呢

17:22.610 --> 17:23.610
我们就完成了

17:23.610 --> 17:25.610
整个PromiseA下规范

17:25.610 --> 17:28.610
通过这么一百多行代码

17:28.610 --> 17:29.610
就完成这个规范了

17:29.610 --> 17:32.610
你可以尽情的去返付的去测试

17:32.610 --> 17:33.610
是没问题的

17:33.610 --> 17:34.610
然后呢

17:34.610 --> 17:35.610
当然你如果说

17:35.610 --> 17:36.610
我这里面也测试到

17:36.610 --> 17:37.610
如果说我没测试到

17:37.610 --> 17:38.610
有一些问题的话

17:38.610 --> 17:39.610
欢迎同学们

17:39.610 --> 17:42.610
在咱们的仓库里面给老师指出

17:42.610 --> 17:43.610
好那么现在呢

17:43.610 --> 17:44.610
我们来测试一下

17:44.610 --> 17:47.610
我们因为我们满足了PromiseA下规范

17:47.610 --> 17:49.610
PromiseA下规范有个什么样的特点

17:49.610 --> 17:52.610
就是可以互操作

17:52.610 --> 17:53.610
所以要互操作

17:53.610 --> 17:55.610
就是我可以使用官方的Promise

17:55.610 --> 17:56.610
和我自己写的Promise

17:56.610 --> 17:58.610
可以相互操作都没问题

17:58.610 --> 18:00.610
好咱们来试一下

18:00.610 --> 18:04.610
比方说我这里有一个Promise

18:04.610 --> 18:07.610
它是来自于我的Promise

18:11.610 --> 18:15.610
好然后我们使用Result1

18:15.610 --> 18:16.610
比方完成

18:16.610 --> 18:17.610
接下来呢

18:17.610 --> 18:19.610
我们用Promise1

18:19.610 --> 18:21.610
调用任方法

18:21.610 --> 18:23.610
然后我们都要data

18:23.610 --> 18:24.610
data呢

18:24.610 --> 18:25.610
我们输出一下data

18:25.610 --> 18:26.610
那么你就应该输出1

18:26.610 --> 18:27.610
对不对

18:27.610 --> 18:28.610
这个肯定是没问题的

18:28.610 --> 18:29.610
对吧

18:29.610 --> 18:31.610
其他测试到你们自己去做了

18:31.610 --> 18:32.610
好这个没问题

18:32.610 --> 18:33.610
然后呢我在这边呢

18:33.610 --> 18:35.610
去返回一个

18:35.610 --> 18:38.610
官方的Promise

18:39.610 --> 18:40.610
去做

18:40.610 --> 18:43.920
好我们输出一下

18:43.920 --> 18:46.920
我们Result一下那个2

18:46.920 --> 18:49.920
好接下来Z

18:49.920 --> 18:50.920
我们再来输出一下data

18:50.920 --> 18:51.920
你看啊

18:51.920 --> 18:53.920
如果说能够互相操作的话

18:53.920 --> 18:54.920
那么就应该有这么一个现象

18:54.920 --> 18:56.920
我这个Promise完成了

18:56.920 --> 18:57.920
完成的数据是什么

18:57.920 --> 18:58.920
1那么这里应该输出1

18:58.920 --> 18:59.920
这个没问题对吧

18:59.920 --> 19:02.920
然后让我返回了一个官方的Promise

19:02.920 --> 19:05.920
这官方的Promise呢

19:05.920 --> 19:07.920
因为它返回的是Promise

19:07.920 --> 19:09.920
所以说我这个任方法返回的是什么

19:09.920 --> 19:11.920
返回的是我们自己的够多函数对吧

19:11.920 --> 19:14.920
我们任方法返回的是我的Promise

19:14.920 --> 19:18.920
我自己写了个Promise函数的对象

19:18.920 --> 19:19.920
那么我这个对象的状态

19:19.920 --> 19:21.920
应该跟个官方的Promise的状态

19:21.920 --> 19:22.920
要保持一致对吧

19:22.920 --> 19:23.920
因为这里Result了2

19:23.920 --> 19:25.920
那么我这个任反回的Promise

19:25.920 --> 19:26.920
也该是Result5

19:26.920 --> 19:28.920
所以说这里应该输出2

19:28.920 --> 19:29.920
那如果说能够互操作的话

19:29.920 --> 19:31.920
那么这里肯定是没问题的

19:31.920 --> 19:32.920
因为发现没问题

19:32.920 --> 19:33.920
那么来改一下

19:33.920 --> 19:37.920
我先用官方的再用我自己的

19:37.920 --> 19:39.920
看一下也没问题

19:39.920 --> 19:40.920
因为发现也没问题

19:40.920 --> 19:41.920
就是我们的写的东西

19:41.920 --> 19:43.920
可以跟官方的互相操作

19:43.920 --> 19:45.920
因为他们都符合Promise

19:45.920 --> 19:46.920
A加规范都没问题

19:46.920 --> 19:48.920
好我们再来看一下

19:48.920 --> 19:49.920
既然我们符合A加规范

19:49.920 --> 19:51.920
那么我们在使用

19:51.920 --> 19:52.920
而Sync关键制的时候

19:52.920 --> 19:53.920
应该也没问题

19:53.920 --> 19:55.920
好咱们来试一下

19:55.920 --> 20:01.300
现在我们再写一个Delay函数吧

20:01.300 --> 20:03.860
我写过很多次了

20:03.860 --> 20:04.860
对吧这种函数

20:04.860 --> 20:05.860
Delay函数

20:05.860 --> 20:06.860
Delation

20:06.860 --> 20:07.860
然后我这里反回

20:07.860 --> 20:11.860
NewMyPromiseResult

20:11.860 --> 20:12.860
Result

20:12.860 --> 20:14.860
好我说Timeout

20:14.860 --> 20:17.300
多少时间了

20:17.300 --> 20:18.300
Delation

20:18.300 --> 20:20.300
这个时间完成之后

20:20.300 --> 20:21.300
我Result

20:21.300 --> 20:23.300
这是我自己的写的MyPromise

20:23.300 --> 20:24.300
我们看一下

20:24.300 --> 20:25.300
而Sync

20:25.300 --> 20:26.300
而Wate关键制

20:26.300 --> 20:27.300
能不能等待这样的一个东西呢

20:27.300 --> 20:28.300
Wate

20:28.300 --> 20:29.300
Delay

20:30.300 --> 20:31.300
2000

20:32.300 --> 20:33.300
好我们输出一下

20:35.300 --> 20:36.300
我现在输出一下

20:36.300 --> 20:37.300
Start

20:38.300 --> 20:39.300
运行

20:39.300 --> 20:40.300
Start

20:41.300 --> 20:42.300
杨庙东之后

20:42.300 --> 20:43.300
OK

20:43.300 --> 20:44.300
所以我们而Wate关键制

20:44.300 --> 20:45.300
也能识别

20:45.300 --> 20:46.300
我们自己写的Promise

20:46.300 --> 20:47.300
为什么能识别

20:47.300 --> 20:48.300
只要你能符合A加规范

20:48.300 --> 20:50.300
那么它就没问题

20:50.300 --> 20:51.300
所以我们

20:51.300 --> 20:52.300
也可以下来

20:52.300 --> 20:54.300
同学们可以多去做一些测试

20:54.300 --> 20:55.300
是没问题的

20:55.300 --> 20:56.300
那有些人说

20:56.300 --> 20:57.300
那我这个Promise里边

20:57.300 --> 20:58.300
还没有写

20:58.300 --> 20:59.300
什么看起方法还没有

20:59.300 --> 21:00.300
对吧

21:00.300 --> 21:01.300
还有什么finally

21:01.300 --> 21:02.300
方法还没有

21:02.300 --> 21:03.300
还有一些静态方法

21:03.300 --> 21:04.300
什么OrRest

21:04.300 --> 21:05.300
这些方法都没有

21:05.300 --> 21:06.300
注意

21:06.300 --> 21:07.300
这些方法

21:07.300 --> 21:09.300
不是PromiseA加规范的

21:09.300 --> 21:10.300
A加规范就规定了

21:10.300 --> 21:11.300
你必须要有个任方法

21:11.300 --> 21:12.300
它详细的说了

21:12.300 --> 21:13.300
这个任方法

21:13.300 --> 21:14.300
应该怎么来处理

21:14.300 --> 21:15.300
有几个参数

21:15.300 --> 21:16.300
每个参数

21:16.300 --> 21:17.300
应该长什么样子

21:17.300 --> 21:18.300
你具体处理

21:18.300 --> 21:19.300
该怎么去处理

21:19.300 --> 21:20.300
所以你把任方法

21:20.300 --> 21:21.300
实现了PromiseA加规范

21:21.300 --> 21:22.300
那么剩下的

21:22.300 --> 21:23.300
什么OrR

21:23.300 --> 21:24.300
那些东西

21:24.300 --> 21:25.300
小事

21:25.300 --> 21:26.300
真是小事

21:26.300 --> 21:27.300
最复杂的我们已经搞定了

21:27.300 --> 21:28.300
其他都不是小事

21:28.300 --> 21:29.300
我们后续的

21:29.300 --> 21:30.300
后续的课程

21:30.300 --> 21:31.300
我们慢慢把

21:31.300 --> 21:32.300
其他东西一点点实现

21:32.300 --> 21:33.300
你会发现其他东西实现

21:33.300 --> 21:34.300
就非常简单了

21:34.300 --> 21:35.300
OK

21:35.300 --> 21:36.300
那么我们这几课

21:36.300 --> 21:38.300
就算高于段落了

