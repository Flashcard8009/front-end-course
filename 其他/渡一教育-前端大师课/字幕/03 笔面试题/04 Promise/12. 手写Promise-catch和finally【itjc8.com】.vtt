WEBVTT

00:00.110 --> 00:04.610
好了 同学们 至此呢 我们已经完成了整个Promise 额价规范

00:05.110 --> 00:10.110
如果说将来面试的时候 让你熟写一个Promise 比方他提

00:10.110 --> 00:13.110
就是让你熟写一个Promise 写到这儿就够了

00:13.110 --> 00:16.110
只写一个Promise 额价规范就可以了

00:16.110 --> 00:20.110
那么剩下的还有什么Catch啊Family啊 还有一些静态方法

00:20.110 --> 00:23.110
我们可以不写 除非它有特别的要求

00:24.110 --> 00:28.110
一般来说面试题的时候 要么就考察力熟写Promise

00:28.110 --> 00:32.110
但是如果说考察力熟写Promise的话 这个要求是比较高的

00:32.110 --> 00:35.110
但是如果说同学们能够把我这样的一个代码写出来

00:35.110 --> 00:38.110
我告诉同学们 好不夸张的说 如果说满分是100分

00:38.110 --> 00:40.110
你们可以达到120

00:40.110 --> 00:43.110
整个面试的所有的人员中 你就是最亮的仔

00:43.110 --> 00:46.110
这个代码的质量是非常高的

00:46.110 --> 00:50.110
但是有可能面试的时候 不让你熟写Promise

00:50.110 --> 00:52.110
这不需要你写的太复杂了

00:52.110 --> 00:55.110
可能会让你去写一些什么Catch啊Family啊

00:55.110 --> 00:59.110
还有一些静态方法 那我们一次来给大家讲解一下

00:59.110 --> 01:02.110
那么这些方法呢 它不是A加规范的

01:02.110 --> 01:05.110
所以说让你单独的去写这些方法的时候

01:05.110 --> 01:10.110
你可以直接针对这个官方的Promise来进行书写

01:10.110 --> 01:13.110
那比方说你要写这个Catch方法

01:13.110 --> 01:16.110
你怎么写呢Promise PrototypeCatch

01:16.110 --> 01:19.110
就把重新改成另外一个函数 就实现就完事了

01:19.110 --> 01:22.110
OK 这就是你具体的写的位置

01:22.110 --> 01:24.110
当然 因为我们这边使用的是

01:24.110 --> 01:26.110
已经写好了我们自己的Promise

01:26.110 --> 01:28.110
所以说我们这边可以怎么写呢

01:28.110 --> 01:32.110
可以写MyPromise Prototype

01:32.110 --> 01:35.110
然后给它加上一个Catch方法

01:35.110 --> 01:36.110
当然可以在这里写

01:36.110 --> 01:39.110
也可以利用ES6的语法

01:39.110 --> 01:40.110
我再重生一次

01:40.110 --> 01:43.110
如果说面试的时候 让你单独的去写Catch

01:43.110 --> 01:46.110
你直接把这里换成官方的Promise就可以了

01:46.110 --> 01:49.110
因为我这里就要完整的实现一个我自己的Promise

01:49.110 --> 01:51.110
所以说我这里接着我的写 懂得意思吗

01:51.110 --> 01:54.110
以后在面试的时候 你直接使用官方的

01:54.110 --> 01:58.110
潜力条件 事实上它要让你单独的去写Catch

01:58.110 --> 02:00.110
好 那因为我们这里呢

02:00.110 --> 02:03.110
使用的是在我们自己的Promise上进行扩展

02:03.110 --> 02:06.110
因此我可以充分的利用ES6的语法

02:06.110 --> 02:08.110
ES6的语法是不是可以在这里写

02:08.110 --> 02:10.110
原型方法 对吧

02:10.110 --> 02:11.110
来写个Catch

02:11.110 --> 02:12.110
哇 开启方法

02:12.110 --> 02:14.110
那简单的建设是令人发指

02:14.110 --> 02:16.110
有多令人发指呢

02:16.110 --> 02:18.110
因为我们之前是不是讲过

02:18.110 --> 02:20.110
Catch实际上本质就是这

02:20.110 --> 02:23.110
它只是扫传了一个Unfulfilled的

02:23.110 --> 02:25.110
它只处理那个失败

02:25.110 --> 02:31.110
所以说 仅处理失败的场景

02:31.110 --> 02:33.110
这里呢 怎么写呢

02:33.110 --> 02:34.110
就一句话就写完了

02:34.110 --> 02:35.110
当然官方的也是一样

02:35.110 --> 02:38.110
你直接调用它的任意方法就完事了

02:38.110 --> 02:40.110
第一个参数传大了

02:40.110 --> 02:41.110
第二个参数呢

02:41.110 --> 02:43.110
Unrejected就完了

02:43.110 --> 02:44.110
就这么简单

02:44.110 --> 02:46.110
是不是非常非常简单

02:46.110 --> 02:48.110
就重复使用这个Ring就完事了

02:48.110 --> 02:50.110
开启就写完了

02:50.110 --> 02:51.110
是不是很简单

02:51.110 --> 02:52.110
好 然后接下来是一个方法

02:52.110 --> 02:53.110
是finally

02:53.110 --> 02:54.110
可能有一种人不太清楚

02:54.110 --> 02:55.110
一个finally的方法

02:55.110 --> 02:56.110
我来说一下

02:56.110 --> 02:58.110
finally的方法是这样

02:58.110 --> 03:01.110
它表示了是任何

03:01.110 --> 03:08.110
就是无论是什么结果都会运行

03:08.110 --> 03:09.110
啥意思

03:09.110 --> 03:11.110
比方说我这里写一个Promise

03:12.110 --> 03:14.110
这里的比方 我们就result吧

03:14.110 --> 03:15.110
result1

03:15.110 --> 03:16.110
OK 然后呢

03:16.110 --> 03:18.110
我们去调用finally

03:18.110 --> 03:20.110
它里边只传一个回调函数

03:20.110 --> 03:21.110
而且这个回调函数呢

03:21.110 --> 03:22.110
它没有参数

03:22.110 --> 03:23.110
也没有返回结果

03:23.110 --> 03:25.110
返回结果它反正也不认的

03:25.110 --> 03:27.110
这里传一个函数

03:27.110 --> 03:29.110
这个函数是无论如何都会运行的

03:29.110 --> 03:31.110
就finally

03:31.110 --> 03:33.110
finally

03:33.110 --> 03:34.110
好 我们输出一下

03:34.110 --> 03:35.110
那等一会儿呢

03:35.110 --> 03:37.110
我们再去打印一下

03:37.110 --> 03:39.110
打印一下 打印一下

03:39.110 --> 03:42.110
这个pro

03:42.110 --> 03:44.110
输出一下pro

03:44.110 --> 03:45.110
看它的状态

03:45.110 --> 03:46.110
我们运行啊

03:46.110 --> 03:47.110
因为发现了

03:47.110 --> 03:48.110
首先有这么一个特点

03:48.110 --> 03:49.110
反正你成功之后

03:49.110 --> 03:50.110
有没有运行

03:50.110 --> 03:51.110
有运行

03:51.110 --> 03:53.110
然后如果说失败呢

03:53.110 --> 03:55.110
失败之后有没有运行呢

03:55.110 --> 03:56.110
也有运行

03:56.110 --> 03:57.110
对吧

03:57.110 --> 03:58.110
它无论如何都会运行的

03:58.110 --> 03:59.110
那么这种情况呢

03:59.110 --> 04:00.110
我们虽然用的比较少

04:00.110 --> 04:01.110
但是我们要制造一点

04:01.110 --> 04:02.110
了解点

04:02.110 --> 04:03.110
首先它不是Promise

04:03.110 --> 04:04.110
A加规范

04:04.110 --> 04:05.110
A加规范已经讲完了

04:05.110 --> 04:06.110
后边都是ES6

04:06.110 --> 04:08.110
给我们新增的一切东西

04:08.110 --> 04:09.110
我们把它实现

04:09.110 --> 04:10.110
好 反正这个方法

04:10.110 --> 04:11.110
它无论如何都会运行

04:11.110 --> 04:12.110
还有这么一个特点

04:12.110 --> 04:13.110
就是我们讲的时候

04:13.110 --> 04:16.110
讲它的这个作用的时候

04:16.110 --> 04:17.110
大家可以想一想

04:17.110 --> 04:18.110
怎么去写

04:18.110 --> 04:21.110
充分的利用我们现有的东西

04:21.110 --> 04:23.110
然后还有个什么情况呢

04:23.110 --> 04:24.110
你会发现啊

04:24.110 --> 04:26.110
比方说我们result

04:26.110 --> 04:29.320
你会发现这个fand里呢

04:29.320 --> 04:30.320
它也会

04:30.320 --> 04:32.320
我这里写错了

04:32.320 --> 04:34.320
应该写pro2

04:34.320 --> 04:38.020
我们看pro2到底是什么

04:38.020 --> 04:39.020
因为发现pro2呢

04:39.020 --> 04:41.020
它也会跟任方法一样

04:41.020 --> 04:44.020
也会返回一个新的promise

04:44.020 --> 04:47.020
只不过呢不太一样的地方就是

04:47.020 --> 04:49.020
这个新的promise的状态跟旧的

04:49.020 --> 04:51.020
是完全一致的

04:51.020 --> 04:53.020
看来是完全一致的

04:53.020 --> 04:55.020
也就是说什么意思呢

04:55.020 --> 04:56.020
就是说你这个

04:56.020 --> 04:57.020
上面的promise完成了

04:57.020 --> 04:58.020
成功的数据是1

04:58.020 --> 05:00.020
那么它的也是成功的

05:00.020 --> 05:01.020
也是数据是1

05:01.020 --> 05:03.020
跟你这里的直系没有任何关系

05:03.020 --> 05:04.020
你这里如果说

05:04.020 --> 05:06.020
我这里返回一个123

05:06.020 --> 05:07.020
那你看

05:07.020 --> 05:08.020
它还是没变化

05:08.020 --> 05:10.020
因为它不需要你这个返回结果

05:10.020 --> 05:11.020
懂了意思吧

05:11.020 --> 05:13.020
它变成这样的一个模式

05:13.020 --> 05:15.020
那如果说失败呢

05:15.020 --> 05:16.020
就借个证

05:17.020 --> 05:18.020
那么这里呢

05:18.020 --> 05:19.020
promise2

05:19.020 --> 05:20.020
它也是失败的

05:20.020 --> 05:21.020
因为我这里呢

05:21.020 --> 05:22.020
没有针对一个promise

05:22.020 --> 05:23.020
进行失败的处理

05:23.020 --> 05:24.020
它有一个警告没关系

05:24.020 --> 05:25.020
那么我看到promise2

05:25.020 --> 05:26.020
它也有一个失败

05:26.020 --> 05:27.020
它也是失败的

05:27.020 --> 05:29.020
原因也是1

05:29.020 --> 05:30.020
懂了意思吧

05:30.020 --> 05:31.020
那我这边虽然

05:31.020 --> 05:32.020
这边虽然执行的过程中

05:32.020 --> 05:33.020
没有问题

05:33.020 --> 05:34.020
但是你还是失败的

05:34.020 --> 05:35.020
是不是有点像川普啊

05:35.020 --> 05:37.020
就是他本身呢

05:37.020 --> 05:38.020
不改变状态

05:38.020 --> 05:39.020
但是有一种情况之外

05:39.020 --> 05:40.020
就是他如果说

05:40.020 --> 05:41.020
抛出了一个错误

05:43.020 --> 05:45.020
那么数据变成他的错误了

05:45.020 --> 05:46.020
你可以想一想

05:46.020 --> 05:47.020
它是一个什么样的逻辑

05:47.020 --> 05:48.020
其实这个逻辑

05:48.020 --> 05:49.020
你想通了

05:49.020 --> 05:51.020
发现了一个太简单的逻辑

05:52.020 --> 05:53.020
如果说你看

05:53.020 --> 05:55.020
如果说它是成功的

05:55.020 --> 05:56.020
那么如果说

05:56.020 --> 05:57.020
里边抛了一个错误的话

05:57.020 --> 05:58.020
那么它

05:58.020 --> 06:00.020
你觉得它仍然会失败

06:00.020 --> 06:01.020
仍然是123

06:02.020 --> 06:03.020
好像不太容易想得到

06:03.020 --> 06:04.020
对吧

06:04.020 --> 06:05.020
它到底是一个什么的逻辑

06:05.020 --> 06:06.020
好像挺复杂的样子

06:06.020 --> 06:07.020
其实它这里贼简单

06:08.020 --> 06:09.020
好 翻了你

06:12.970 --> 06:13.970
它传一个什么

06:13.970 --> 06:14.970
传一个毁掉函数

06:14.970 --> 06:15.970
那么我们就该取个名叫

06:15.970 --> 06:16.970
un-settled

06:16.970 --> 06:17.970
就是你只要以决

06:17.970 --> 06:19.970
不管你是成功还是失败

06:19.970 --> 06:20.970
我都会处理

06:20.970 --> 06:21.970
就都会运行这个函数

06:22.970 --> 06:23.970
这是

06:24.970 --> 06:26.970
这也是传的一个函数

06:26.970 --> 06:27.970
这个函数它不需要

06:27.970 --> 06:28.970
这个反回结果

06:28.970 --> 06:29.970
你反复反回都无所谓

06:29.970 --> 06:30.970
反正我也不用的

06:31.970 --> 06:32.970
这就是什么呢

06:32.970 --> 06:34.970
无论成功

06:34.970 --> 06:36.970
还是失败

06:36.970 --> 06:38.970
都会执行毁掉

06:39.970 --> 06:40.970
它是这么一个逻辑

06:41.970 --> 06:42.970
那你想一想

06:43.970 --> 06:44.970
其实我把个代码

06:44.970 --> 06:45.970
写出来一本以下就明白了

06:45.970 --> 06:46.970
你想一想

06:47.970 --> 06:48.970
无论成 这个函数

06:48.970 --> 06:50.970
它无论成功还是失败

06:50.970 --> 06:51.970
它都会执行

06:51.970 --> 06:52.970
而且它也会

06:52.970 --> 06:53.970
这个函数本身也会

06:53.970 --> 06:54.970
反回promise

06:55.970 --> 06:57.970
是不是就是这么一个逻辑

06:58.970 --> 07:02.750
是不是就是这么一个逻辑

07:03.750 --> 07:04.750
我调入另一方法

07:04.750 --> 07:05.750
同时注册成功和失败

07:05.750 --> 07:06.750
都是它

07:06.750 --> 07:07.750
你成功之后运行它

07:07.750 --> 07:08.750
失败之后也运行它

07:08.750 --> 07:09.750
是不是就这么逻辑

07:10.750 --> 07:11.750
那么这个逻辑写出来

07:11.750 --> 07:13.750
首先它反回promise没问题

07:14.750 --> 07:15.750
然后无论成功还是失败

07:15.750 --> 07:16.750
都会执行没问题

07:17.750 --> 07:18.750
这个没问题

07:18.750 --> 07:20.750
但是有一些小的问题

07:20.750 --> 07:21.750
什么问题

07:21.750 --> 07:23.750
如果说你这样子写的话

07:23.750 --> 07:24.750
那么会导致什么

07:24.750 --> 07:26.750
会导致这边成功之后

07:26.750 --> 07:27.750
它的数据会传过来

07:27.750 --> 07:28.750
对不对

07:28.750 --> 07:29.750
这个数据是会传过来的

07:29.750 --> 07:30.750
但是你看这边的数据

07:30.750 --> 07:31.750
是没有传过来的

07:34.750 --> 07:35.750
它会把数据传过来

07:35.750 --> 07:36.750
失败的时候也是

07:36.750 --> 07:37.750
它会把原因传过来

07:38.750 --> 07:39.750
对吧

07:39.750 --> 07:40.750
它会有这么一个逻辑

07:40.750 --> 07:41.750
那么这里发现

07:41.750 --> 07:42.750
我这个函数好像

07:42.750 --> 07:43.750
接受不到这个函数

07:43.750 --> 07:44.750
而且这个函数

07:44.750 --> 07:46.750
它反回结果是无效的

07:47.750 --> 07:49.750
反回结果是无效的

07:50.750 --> 07:51.750
它不会改变

07:51.750 --> 07:52.750
这里的成功

07:52.750 --> 07:53.750
那么如果说

07:53.750 --> 07:54.750
我直接这样子写的话

07:54.750 --> 07:55.750
肯定不行

07:55.750 --> 07:56.750
那怎么写

07:59.190 --> 08:00.190
有点想象力

08:01.190 --> 08:02.190
我这样子写

08:03.190 --> 08:05.190
我跟你套一个函数

08:06.190 --> 08:08.190
我这个函数反回啥呢

08:08.190 --> 08:10.190
就反回这个data

08:10.190 --> 08:11.190
对吧

08:11.190 --> 08:12.190
你给我传的是怎么

08:12.190 --> 08:13.190
你成功了

08:13.190 --> 08:14.190
然后我就运行这个函数

08:14.190 --> 08:15.190
这个函数执行期间

08:15.190 --> 08:16.190
没有问题

08:16.190 --> 08:17.190
我同志给你反回这个data

08:17.190 --> 08:18.190
然后在

08:18.190 --> 08:19.190
反回data之前

08:19.190 --> 08:20.190
我运行一下

08:20.190 --> 08:21.190
你这个ancetor的

08:22.190 --> 08:23.190
所以就完了

08:23.190 --> 08:24.190
把包一下

08:24.190 --> 08:25.190
是不是这个逻辑

08:26.190 --> 08:28.190
好 如果说你失败了呢

08:29.190 --> 08:30.190
如果说你失败了

08:30.190 --> 08:31.190
这个Ryzen

08:32.190 --> 08:33.190
Ryzen

08:33.190 --> 08:34.190
Ryzen咋写

08:34.190 --> 08:35.190
Ryzen

08:35.190 --> 08:36.190
失败的原因

08:36.190 --> 08:37.190
你失败了

08:37.190 --> 08:39.190
我还是要运行这个

08:39.190 --> 08:40.190
我不会给你传任何参数

08:40.190 --> 08:41.190
所以说那边就收不到参数了

08:41.190 --> 08:42.190
对吧

08:42.190 --> 08:43.190
然后呢

08:43.190 --> 08:44.190
我抛出一个

08:45.190 --> 08:46.190
错误

08:46.190 --> 08:47.190
Ryzen

08:48.190 --> 08:49.190
没了

08:49.190 --> 08:51.190
他就是给你包了一下

08:51.190 --> 08:52.190
有点想象力

08:53.190 --> 08:54.190
就完了

08:54.190 --> 08:55.190
因此呢你会发现

08:55.190 --> 08:57.190
我这里能把它换成by promise

08:57.190 --> 08:58.190
一样没有任何问题

09:00.890 --> 09:01.890
你看

09:02.890 --> 09:03.890
Values1

09:04.890 --> 09:05.890
Vanity on Defend

09:05.890 --> 09:06.890
都得收不到这个参数

09:06.890 --> 09:07.890
而且这里反回的是

09:07.890 --> 09:08.890
无效的

09:08.890 --> 09:09.890
但是如果说这里爆错

09:09.890 --> 09:10.890
那就没法了

09:11.890 --> 09:12.890
123

09:12.890 --> 09:13.890
是不是跟刚才就一样了

09:14.890 --> 09:15.890
有些个体的by6123

09:15.890 --> 09:16.890
为什么爆错就不行呢

09:17.890 --> 09:18.890
你看这个逻辑吗

09:18.890 --> 09:19.890
他如果说本来是成功的

09:19.890 --> 09:20.890
但是你这里

09:20.890 --> 09:22.890
这个运行期间爆错了

09:22.890 --> 09:23.890
那么就会导致

09:23.890 --> 09:24.890
我这个函数爆错

09:24.890 --> 09:25.890
我这个函数爆错了

09:25.890 --> 09:26.890
那么这个反回的promise

09:27.890 --> 09:28.890
肯定是

09:28.890 --> 09:29.890
也是被拒绝的

09:29.890 --> 09:30.890
对吧

09:30.890 --> 09:31.890
那同样道理

09:31.890 --> 09:32.890
这里也是一样

09:32.890 --> 09:33.890
这里像

09:33.890 --> 09:34.890
如果说我这里爆错了

09:34.890 --> 09:35.890
那么同样的

09:35.890 --> 09:36.890
它会改变那个错误的数据

09:36.890 --> 09:37.890
如果说这里没有爆错

09:37.890 --> 09:38.890
那么它会跟着

09:38.890 --> 09:40.890
把之前那个错误爆出来

09:40.890 --> 09:41.890
这就是个逻辑

09:41.890 --> 09:42.890
你可以去跟那个

09:42.890 --> 09:44.890
官方的promise比较一下

09:44.890 --> 09:45.890
就非常简单

09:45.890 --> 09:47.890
这两个函数据就写完了

09:47.890 --> 09:48.890
搬到你

09:48.890 --> 09:49.890
就会发现了

09:50.890 --> 09:51.890
A加规范也实现

09:51.890 --> 09:53.890
剩下的东西都比较简单了

09:53.890 --> 09:54.890
无论是直接跟着

09:54.890 --> 09:55.890
官方的写

09:55.890 --> 09:56.890
还是我实现我们自己的

09:56.890 --> 09:57.890
都是这个写法

09:57.890 --> 09:58.890
官方的写法

09:58.890 --> 09:59.890
也是这样的写法

10:00.890 --> 10:01.890
无非你写到位置

10:01.890 --> 10:02.890
那就不是在这个位置

10:02.890 --> 10:03.890
你又写到位置

10:03.890 --> 10:04.890
Promise

10:04.890 --> 10:05.890
Prototype

10:05.890 --> 10:06.890
Catch

10:06.890 --> 10:08.890
Catch怎么写呢

10:08.890 --> 10:09.890
Return

10:09.890 --> 10:10.890
然后在这里

10:10.890 --> 10:11.890
Return

10:11.890 --> 10:12.890
This is the

10:12.890 --> 10:13.890
是一样的对吧

10:13.890 --> 10:14.890
一点区别都没有

10:14.890 --> 10:15.890
Return

10:15.890 --> 10:16.890
是一样的

10:16.890 --> 10:17.890
都是一样的

10:17.890 --> 10:18.890
利用之前的认方法

10:18.890 --> 10:20.890
反倒你写法也是一样的

10:20.890 --> 10:21.890
这就是

10:21.890 --> 10:23.890
这两个函数的实现

