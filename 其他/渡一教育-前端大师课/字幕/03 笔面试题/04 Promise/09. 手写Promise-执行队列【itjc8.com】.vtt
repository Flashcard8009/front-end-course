WEBVTT

00:00.000 --> 00:03.440
这些可能我们开始来真正的实现这个认函数

00:03.440 --> 00:05.720
当然我们一节课肯定是搞不定的

00:05.720 --> 00:07.240
这个认函数是最复杂的

00:07.240 --> 00:09.520
其实我们PromiseA加规范里边

00:10.080 --> 00:11.640
最复杂的就是认函数了

00:11.640 --> 00:14.440
因为它就是规定认函数如何去执行

00:14.760 --> 00:16.120
好 我们来看一下这个认函数

00:16.120 --> 00:17.960
我们知道它要传两个参数

00:17.960 --> 00:19.080
当然你传一个的话

00:19.080 --> 00:21.000
第二个参数相当于是UndieBand

00:21.000 --> 00:23.280
然后这个认函数还可以多次调用

00:23.280 --> 00:24.480
你看我这里调了两次

00:24.480 --> 00:26.200
实际上可以调了很多次的

00:26.640 --> 00:29.040
那么每一次调用是传了一个函数进去

00:29.080 --> 00:31.040
那么我现在问大家第一个问题

00:31.040 --> 00:32.840
这个函数是不是立即执行

00:34.360 --> 00:36.560
不是 它应该放到V队的也就执行

00:36.560 --> 00:38.760
那是不是立即把它放到V队的

00:39.760 --> 00:40.760
其实也不是

00:41.200 --> 00:41.840
为什么呢

00:41.840 --> 00:44.120
如果说这些函数立即放到V队的

00:44.120 --> 00:45.080
那里想一想

00:45.080 --> 00:47.160
那一定是这些函数先执行

00:48.160 --> 00:49.280
那凭什么要执行呢

00:49.280 --> 00:51.040
它必须要成功之后才执行

00:51.040 --> 00:51.920
你看我这儿

00:51.920 --> 00:56.440
是不是一秒钟之后才成功

00:56.920 --> 00:57.920
那你先想一想

00:57.920 --> 00:59.760
这些函数是马上执行吗

00:59.760 --> 01:00.920
那肯定不是马上执行

01:01.400 --> 01:02.960
甚至都不会马上放到V队的

01:02.960 --> 01:04.560
你看是不是等了一秒钟才出来的

01:05.480 --> 01:07.200
因此我们认为

01:07.200 --> 01:10.840
函数它并不是马上执行

01:10.840 --> 01:13.120
也不是马上把它放到V队的

01:13.560 --> 01:14.480
我们可以认为

01:14.480 --> 01:16.320
我们可以认为放到V队的

01:16.320 --> 01:17.280
就是马上执行了

01:17.280 --> 01:17.640
对吧

01:18.080 --> 01:19.840
它并不是马上要去做这件事

01:19.840 --> 01:21.240
而是什么时候做了

01:21.240 --> 01:24.200
是要等状态确定了之后再去做

01:24.720 --> 01:25.640
那我们想一想

01:25.680 --> 01:27.640
认函数它到底要做什么事

01:28.640 --> 01:30.000
其实我们仔细书里的话

01:30.000 --> 01:30.640
我们知道

01:30.640 --> 01:32.200
认函数它做什么事呢

01:32.200 --> 01:33.760
它做的事情其实就是

01:34.680 --> 01:37.320
把我们的函数放到一个对立

01:37.720 --> 01:39.200
第一个函数调用RAM

01:39.200 --> 01:40.680
放进去一个执行吗

01:40.680 --> 01:41.240
不执行

01:42.040 --> 01:43.240
就是相当于是一个数组

01:43.440 --> 01:44.360
然后第二个

01:44.360 --> 01:45.800
我们又调用于是RAM

01:45.800 --> 01:47.040
又放一个函数进去

01:47.320 --> 01:48.240
再调一次RAM

01:48.240 --> 01:49.400
又放一个函数进去

01:49.400 --> 01:50.800
再调一次又放一个

01:51.240 --> 01:51.480
对吧

01:51.480 --> 01:53.720
放了很多的函数

01:53.720 --> 01:54.920
到这个对立里面去了

01:55.720 --> 01:58.160
等到将来状态确定了之后

01:58.160 --> 02:00.440
我们再一次去执行这个对立

02:00.440 --> 02:01.840
从后到尾把执行了一遍

02:01.840 --> 02:02.760
把这个函数

02:03.240 --> 02:04.040
是不是这个意思

02:04.440 --> 02:05.240
所以说

02:05.240 --> 02:06.840
我们理清楚这个之后

02:06.840 --> 02:07.520
我们

02:07.960 --> 02:09.720
Promise里面就需要一个对立

02:09.720 --> 02:11.840
来存放这个函数

02:11.840 --> 02:14.640
因此我们认函数的作用就特别简单了

02:14.640 --> 02:15.640
就变成了什么了

02:15.640 --> 02:16.360
你给我一个函数

02:16.360 --> 02:17.320
我把放对立里面去

02:17.320 --> 02:17.840
给我一个函数

02:17.840 --> 02:19.040
我把放对立里面去

02:19.400 --> 02:19.720
好

02:19.720 --> 02:21.040
那于是我在这里呢

02:21.040 --> 02:22.240
去写上这么一个对立

02:22.920 --> 02:24.920
这个对立其实也可以非常非常简单

02:24.920 --> 02:26.720
我们就该取个名字叫做Handlers

02:27.240 --> 02:28.200
叫处理函数

02:29.080 --> 02:30.120
就是一个函数数

02:30.720 --> 02:33.640
处理函数形成的对立

02:33.640 --> 02:34.680
当然对立里面了

02:35.600 --> 02:37.320
我们可以想象每一项是什么

02:37.320 --> 02:38.680
每一项不就是一个函数吗

02:39.200 --> 02:39.560
对不对

02:39.560 --> 02:41.520
我就把UnfulFill的放进来

02:41.520 --> 02:42.160
调用认的时候

02:42.160 --> 02:43.920
把Unfill的解决体的也放进来

02:45.200 --> 02:45.520
好

02:45.520 --> 02:46.920
那么这个时候就产生问题了

02:47.240 --> 02:48.600
那我能这样做吗

02:48.800 --> 02:51.680
如果说我这里直接写个HandlersPush

02:52.400 --> 02:54.160
把这个UnfulFill的放进去

02:55.640 --> 02:56.040
然后呢

02:56.040 --> 02:56.960
我们再来一个Push

02:57.360 --> 02:58.960
或者是直接在这里用个Douhaut

02:58.960 --> 02:59.760
可以加多个了

03:00.200 --> 03:01.600
Unrejected的也放进去

03:02.080 --> 03:03.000
我能这样做吗

03:03.560 --> 03:04.320
好像不行

03:04.520 --> 03:04.960
为什么呢

03:04.960 --> 03:06.200
如果说你这样做了

03:07.800 --> 03:09.400
那么会导致一个什么样的问题呢

03:09.760 --> 03:12.920
你并不当将来当到时候要执行的时候

03:12.920 --> 03:13.840
看到第一个函数

03:14.200 --> 03:15.480
比方说将来成功了

03:16.120 --> 03:16.800
将来成功了

03:16.800 --> 03:18.960
我们现在对立里面的有两个函数

03:19.520 --> 03:20.440
一个是F1

03:20.440 --> 03:21.280
一个是F2

03:21.960 --> 03:24.040
如果说我们再多次调用认的话

03:24.320 --> 03:25.480
比方说多次调用认

03:26.080 --> 03:28.280
那么他就可能会放很多的函数进去

03:28.760 --> 03:29.600
将来成功了

03:29.600 --> 03:30.080
要执行

03:30.080 --> 03:31.160
你拿出第一个函数

03:31.160 --> 03:33.520
你并不知道这个函数是成功之后执行

03:33.520 --> 03:34.840
还是失败之后执行

03:34.840 --> 03:35.640
你并不知道

03:36.200 --> 03:37.040
你拿到第二个函数

03:37.040 --> 03:39.120
也不知道这个函数是成功之后执行

03:39.120 --> 03:40.760
还是失败之后执行

03:40.760 --> 03:41.640
他也不知道

03:42.480 --> 03:42.800
对不对

03:42.800 --> 03:43.960
是不是遇到这么一个问题

03:44.600 --> 03:45.080
因此呢

03:45.080 --> 03:45.840
我们就觉得

03:45.840 --> 03:46.960
那么这一块呢

03:46.960 --> 03:48.120
我们还要标记

03:48.120 --> 03:49.920
每个函数是成功之后执行

03:49.920 --> 03:51.400
还是失败之后执行

03:51.640 --> 03:53.320
所以说这个Handlers数主啊

03:53.360 --> 03:54.560
还不是单单的

03:55.200 --> 03:57.000
不停的往里边放函数那么简单

03:57.000 --> 03:58.040
他应该放的是什么呢

03:58.040 --> 03:59.600
应该放的是一个一个的对象

04:00.920 --> 04:01.800
第一个对象里边

04:01.800 --> 04:02.040
哎

04:02.040 --> 04:03.240
我们把它取得属性啊

04:03.240 --> 04:04.120
叫sqt

04:04.720 --> 04:05.480
执行器

04:05.880 --> 04:06.080
哎

04:06.080 --> 04:07.040
是个函数

04:07.040 --> 04:08.040
然后呢就是

04:09.360 --> 04:10.920
要求的状态是什么呢

04:10.920 --> 04:11.720
State

04:11.720 --> 04:13.040
状态的是fulfiled

04:16.110 --> 04:16.630
对吧

04:16.630 --> 04:18.230
这是第一个对象

04:18.230 --> 04:19.110
第二个对象呢

04:19.110 --> 04:20.150
是sqt

04:21.630 --> 04:22.550
f2

04:22.550 --> 04:23.630
函数2

04:23.670 --> 04:25.950
然后呢他要要求的状态是什么状态呢

04:25.950 --> 04:27.070
叫rejected

04:27.070 --> 04:27.990
是不是要这样子

04:29.030 --> 04:30.070
对吧

04:30.070 --> 04:31.670
因此他要放一个一个的对象

04:31.670 --> 04:32.630
那么我们把这件事呢

04:32.630 --> 04:35.150
单独去抽离一个函数来做这件事

04:35.150 --> 04:35.910
叫做push

04:36.950 --> 04:37.630
handlers

04:38.470 --> 04:38.990
啊

04:38.990 --> 04:39.790
我们给他去

04:39.790 --> 04:40.710
给他一些参数

04:41.830 --> 04:42.510
第一个参数呢

04:42.510 --> 04:43.470
你要给我传个函数

04:43.470 --> 04:44.150
sqt

04:45.630 --> 04:47.470
第二个参数呢是State

04:47.470 --> 04:47.670
好

04:47.670 --> 04:48.270
打个注射

04:50.190 --> 04:51.670
这个函数做什么事情呢

04:51.670 --> 04:52.190
像

04:53.710 --> 04:54.910
处理对列中

04:56.310 --> 04:59.150
添加一个函数

04:59.150 --> 04:59.790
那么这就是

04:59.790 --> 05:01.310
这个第一个参数就是函数本身

05:02.550 --> 05:02.910
分析

05:04.390 --> 05:04.750
这是

05:05.510 --> 05:07.470
添加的函数

05:07.470 --> 05:08.390
第二个参数是什么呢

05:08.390 --> 05:09.230
是状态

05:09.230 --> 05:09.550
对吧

05:10.870 --> 05:12.190
是个支付创

05:12.190 --> 05:13.390
表示的是

05:13.390 --> 05:16.190
该函数什么状态

05:16.190 --> 05:17.030
下执行

05:17.870 --> 05:20.550
以成功之后执行还是失败之后执行

05:20.550 --> 05:21.830
那么我们要在这里写

05:21.830 --> 05:23.350
那这里写法其实很简单

05:23.390 --> 05:24.110
我怎么写呢

05:24.110 --> 05:24.510
我就

05:24.510 --> 05:27.110
this handlers push

05:27.110 --> 05:28.310
添加一个对象

05:28.310 --> 05:29.750
这对象里面有这么一些属性

05:29.750 --> 05:30.550
一个是sqt

05:31.990 --> 05:32.950
一个是State

05:34.310 --> 05:36.230
是把它加到这个handlers里面

05:36.230 --> 05:37.390
是不是加进去

05:38.150 --> 05:38.470
对不对

05:38.470 --> 05:39.150
那我们这边呢

05:39.150 --> 05:41.270
是不是要怎么来处理这个双呢

05:41.270 --> 05:42.470
是不是要调用

05:42.470 --> 05:43.670
调用两次

05:43.670 --> 05:44.310
一个呢是

05:45.230 --> 05:47.430
this push handlers

05:49.110 --> 05:49.790
push handlers

05:49.790 --> 05:50.950
不加s

05:50.950 --> 05:51.270
为什么

05:51.270 --> 05:52.870
因为每次加一个嘛

05:52.870 --> 05:53.870
第一个参数传什么了

05:53.870 --> 05:55.030
复复有的

05:55.030 --> 05:55.950
第二参数传什么了

05:55.950 --> 05:56.550
状态

05:56.550 --> 05:58.310
状态就是复复有的

05:58.310 --> 05:58.550
对吧

05:58.550 --> 06:00.110
我们的那个长量

06:00.110 --> 06:01.270
是不是支付创

06:01.270 --> 06:02.830
特别复复有的

06:02.830 --> 06:04.470
那么这加上第一个函数

06:04.470 --> 06:05.670
然后加上第二个函数

06:05.670 --> 06:06.470
二维结个体的

06:09.550 --> 06:10.150
维结个体的

06:13.110 --> 06:13.990
表示说

06:13.990 --> 06:16.030
这个函数只有成功之后才执行

06:16.030 --> 06:16.630
这个函数呢

06:16.630 --> 06:17.910
只有失败之后执行

06:17.910 --> 06:18.870
那么具体怎么执行

06:18.870 --> 06:20.150
我们现在先不考虑

06:20.150 --> 06:20.950
我们先来加进去

06:20.950 --> 06:21.950
早晚肯定能执行

06:21.950 --> 06:22.590
那么对吧

06:22.630 --> 06:23.390
一循环变捷

06:23.390 --> 06:24.590
他是不是能够拿到这些函数

06:24.590 --> 06:25.750
一个个执行

06:25.750 --> 06:25.990
对吧

06:25.990 --> 06:27.470
这个没问题

06:27.470 --> 06:27.710
好

06:27.710 --> 06:29.230
接着来

06:29.230 --> 06:30.270
那么如果说

06:30.270 --> 06:31.030
这种方法里边

06:31.030 --> 06:33.070
因为他这种方法传递的是比较随意的

06:33.070 --> 06:33.390
比较多

06:33.390 --> 06:35.230
他可能可以给你这样传递

06:35.230 --> 06:35.910
你

06:35.910 --> 06:37.630
比方说你刚刚才的这种情况

06:37.630 --> 06:38.390
所以加了

06:38.390 --> 06:39.910
加了很多的函数到对立里面去了

06:39.910 --> 06:40.710
每次调用这种数

06:40.710 --> 06:43.150
都会加函数到对立里面去

06:43.150 --> 06:45.070
那万一是他这样传递

06:45.070 --> 06:46.270
你传递这个东西呢

06:46.270 --> 06:48.270
或者他啥都不给你传递

06:48.270 --> 06:49.470
那这种情况也怎么处理呢

06:49.470 --> 06:50.710
也就是你传递的函数

06:52.590 --> 06:54.510
发招的东西

06:54.510 --> 06:55.470
那么这个玩意到时候

06:55.470 --> 06:58.870
肯定是叫出问题的对吧

06:58.870 --> 06:59.790
那么我们到时候

06:59.790 --> 07:00.550
执行的时候

07:00.550 --> 07:02.270
可以执行的时候判断

07:02.270 --> 07:02.870
诶判断

07:02.870 --> 07:04.230
比方说你这里给我传的是安迪范

07:04.230 --> 07:05.550
那我家里也叫安迪范

07:05.550 --> 07:06.430
那到时候执行的时候

07:06.430 --> 07:08.110
一看那我咋执行啊

07:08.110 --> 07:08.950
你给我传的是安迪范

07:08.950 --> 07:10.190
我没法执行

07:10.190 --> 07:11.510
没法执行怎么办呢

07:11.510 --> 07:14.310
那我们就后续执行的时候再说

07:14.310 --> 07:15.390
再说这个问题

07:15.390 --> 07:15.870
对吧

07:15.870 --> 07:16.870
那么这个地方

07:16.870 --> 07:18.310
当时我们要先想到

07:18.310 --> 07:19.030
先想到

07:19.030 --> 07:19.710
那第二个函数

07:19.710 --> 07:21.550
比方说这里都传的是这个东西

07:21.550 --> 07:22.310
那到时候咋执行呢

07:22.310 --> 07:22.750
没法执行

07:22.750 --> 07:23.830
它都不是一个函数

07:23.830 --> 07:24.310
对吧

07:24.310 --> 07:24.710
但是呢

07:24.710 --> 07:26.150
我们到时候就可以把掠锅啊

07:26.150 --> 07:26.830
或者是怎么样

07:26.830 --> 07:27.790
我们到时候再处理

07:27.790 --> 07:28.750
是执行的时候

07:28.750 --> 07:29.590
我们再处理

07:29.590 --> 07:30.990
我们先现在只管放

07:30.990 --> 07:31.710
你给我传啥

07:31.710 --> 07:33.630
我就往里边放

07:33.630 --> 07:34.630
懂了意思吧

07:34.630 --> 07:34.790
好

07:34.790 --> 07:36.390
那么这个这个往里边放

07:36.390 --> 07:37.830
我多计能理解吧

07:37.830 --> 07:37.950
好

07:37.950 --> 07:38.630
这是第一个啊

07:38.630 --> 07:40.190
往里边放

07:40.190 --> 07:40.550
然后呢

07:40.550 --> 07:42.150
我们还要想到一件事

07:42.150 --> 07:42.590
什么事呢

07:42.590 --> 07:43.990
就是

07:43.990 --> 07:45.790
那如果说到时候

07:45.790 --> 07:46.430
你看我们这个

07:46.430 --> 07:48.670
任方法返回的时候啥

07:48.710 --> 07:49.430
任方法返回的时候

07:49.430 --> 07:52.030
是不是一个Promise

07:52.030 --> 07:52.590
那么这一块

07:52.590 --> 07:53.710
当时我们讲面试题的时候

07:53.710 --> 07:54.510
各种面试题啊

07:54.510 --> 07:55.670
各种Promise的原理的时候

07:55.670 --> 07:57.830
是不是特别重点强调这一块

07:57.830 --> 07:58.790
它返回的是Promise

07:58.790 --> 08:00.350
我们才能够进行电视调用

08:00.350 --> 08:01.430
关键就是个Promise

08:01.430 --> 08:02.710
什么时候完成

08:02.710 --> 08:04.830
什么时候失败

08:04.830 --> 08:05.630
比方说你这里的

08:05.630 --> 08:06.830
我什么时候完成它呢

08:06.830 --> 08:07.630
Riddle

08:07.630 --> 08:08.350
什么时候调

08:08.350 --> 08:08.950
现在问题是

08:08.950 --> 08:09.750
不是调用的问题

08:09.750 --> 08:10.710
是什么时候调用

08:10.710 --> 08:13.150
我都不知道

08:13.150 --> 08:14.310
什么时候调用

08:14.310 --> 08:15.710
是不是要一定要等将来

08:15.710 --> 08:17.310
去执行这些东西的时候

08:17.310 --> 08:19.270
才能调用

08:19.270 --> 08:22.270
不要用第一个函数

08:22.270 --> 08:23.190
现在完成了

08:23.190 --> 08:24.870
那我要执行这个函数

08:24.870 --> 08:25.950
那么执行这个函数

08:25.950 --> 08:27.630
执行过程中没问题

08:27.630 --> 08:29.790
就是你传递到这个函数啊

08:29.790 --> 08:31.150
执行这个函数没问题

08:31.150 --> 08:32.030
这个函数是啥呢

08:32.030 --> 08:34.390
也就是你传递到这个函数

08:34.390 --> 08:34.910
对吧

08:34.910 --> 08:36.750
这个函数其实就是个F1

08:36.750 --> 08:37.950
你可以这样想想

08:37.950 --> 08:39.910
那么要执行这个函数没问题

08:39.910 --> 08:41.110
那么说明

08:41.110 --> 08:41.910
说明啥呀

08:41.910 --> 08:44.070
说明Riddle返回的Promise

08:44.070 --> 08:45.550
就是成功的

08:45.550 --> 08:46.830
那执行这个函数失败了

08:46.830 --> 08:48.950
那个Promise是不是就该执行这个函数

08:48.950 --> 08:49.790
说明了啥呀

08:49.790 --> 08:52.670
说明了我们只有等到将来执行的时候

08:52.670 --> 08:53.750
我才能确定

08:53.750 --> 08:56.510
这个Promise是成功还是失败

08:56.510 --> 08:57.070
对吧

08:57.070 --> 08:58.750
那么等我将来执行的时候

08:58.750 --> 09:02.030
我在哪里去获得这个Riddle函数呢

09:02.030 --> 09:03.910
在哪里去获得这个Riddle函数呢

09:03.910 --> 09:05.390
是不拿不到

09:05.390 --> 09:06.790
那怎么办呢

09:06.790 --> 09:08.270
就是也很简单

09:08.270 --> 09:09.390
我加这个对列的时候

09:09.390 --> 09:12.110
我是不是可以把Riddle函数放进来

09:12.110 --> 09:12.670
对吧

09:12.670 --> 09:14.390
那么将来我执行的时候就特别简单的

09:14.390 --> 09:15.150
我执行这个函数

09:15.150 --> 09:15.870
我发现它成功了

09:15.870 --> 09:17.390
我就调用Riddle

09:17.390 --> 09:18.110
它执行失败了

09:18.110 --> 09:18.990
我就调用Riddle函数

09:18.990 --> 09:21.870
所以我可以把这两个函数给它放进来

09:21.870 --> 09:23.390
那于是我们在加的时候

09:23.390 --> 09:24.510
还要传两个参数

09:24.510 --> 09:25.790
一个是Riddle

09:25.790 --> 09:27.790
一个是Riddle函数

09:27.790 --> 09:30.790
那么这里我们打算一个参数

09:30.790 --> 09:34.570
这个Riddle函数是什么呢

09:34.570 --> 09:35.610
对吧

09:35.610 --> 09:37.570
这个是方形

09:37.570 --> 09:39.170
Riddle

09:39.170 --> 09:40.290
这个Riddle函数是什么呢

09:40.290 --> 09:47.930
就是Riddle函数返回的Promise

09:47.930 --> 09:49.050
调这个函数啊

09:49.050 --> 09:52.650
使让Riddle函数返回的Promise成功

09:52.650 --> 09:55.650
那么自然而然下面有一个Riddle函数

09:55.650 --> 09:56.530
调这个函数呢

09:56.530 --> 09:59.650
使让Riddle函数返回的Promise失败

09:59.650 --> 10:00.930
我现在去处理这件事吗

10:00.930 --> 10:01.730
现在不处理

10:01.730 --> 10:03.650
我只是把它放到对列里面去

10:03.650 --> 10:05.610
将来执行这个对列的时候

10:05.610 --> 10:07.490
那我就可以根据各种情况

10:07.490 --> 10:08.730
到底它应该成功啊

10:08.730 --> 10:09.850
还是应该失败

10:09.890 --> 10:11.450
是不是就可以处理的

10:11.450 --> 10:12.290
对不对

10:12.290 --> 10:14.450
因此我这里先不处理

10:14.450 --> 10:16.610
但是我将来再进行处理

10:16.610 --> 10:16.970
OK

10:16.970 --> 10:18.730
那么我们这里是不是要多两个参数

10:18.730 --> 10:20.810
然后同样的把放到对象里面来

10:20.810 --> 10:21.890
这个函数写出来很简单

10:21.890 --> 10:24.450
就是把它放到对列里面去

10:24.450 --> 10:26.610
就PoseHandle

10:26.610 --> 10:27.210
OK

10:27.210 --> 10:29.650
那么现在我们也要求了多两个参数了

10:29.650 --> 10:31.450
然后这里是不是要传一个Riddle

10:31.450 --> 10:31.690
诶

10:31.690 --> 10:33.170
那是不是代码就不能写字了

10:33.170 --> 10:33.890
应该写哪

10:33.890 --> 10:36.410
是不是应该写字了

10:36.410 --> 10:38.090
然后要传一个什么Riddle

10:38.090 --> 10:39.490
要传一个Riddle

10:39.530 --> 10:40.170
然后同样的道理

10:40.170 --> 10:41.930
下面这个下面也是一样

10:43.570 --> 10:43.770
对吧

10:43.770 --> 10:45.050
是不是把放到对列里面去

10:46.090 --> 10:46.930
OK

10:46.930 --> 10:47.970
那现在我们完成了吗

10:47.970 --> 10:49.770
其实我们最核心的就完成了

10:49.770 --> 10:51.410
就已经完成了

10:51.410 --> 10:51.570
好

10:51.570 --> 10:53.210
咱们来试一下

10:53.210 --> 10:55.490
现在我们把它不说别的

10:55.490 --> 10:58.250
我们先随便来一些

10:58.250 --> 10:58.930
来两个吧

11:00.490 --> 11:01.850
我们这里的函数A

11:03.130 --> 11:04.810
都拦着去输出啥子

11:04.810 --> 11:05.970
因为现在我们没有执行

11:05.970 --> 11:08.850
所以说现在输出肯定是没有效果的

11:08.850 --> 11:10.130
然后了A1

11:10.130 --> 11:10.850
这是A1

11:12.050 --> 11:14.570
然后下面现在是再写个方式

11:15.850 --> 11:19.270
A2

11:19.270 --> 11:20.070
为什么要命名呢

11:20.070 --> 11:22.510
主要是为了辩认我们看得清楚

11:22.510 --> 11:25.110
然后再调勇于实际

11:25.110 --> 11:25.190
好

11:25.190 --> 11:28.230
那么这是B1 B2

11:28.230 --> 11:28.710
OK

11:28.710 --> 11:30.430
那么现在我们换成BuyPromise

11:32.150 --> 11:32.590
先来问

11:33.830 --> 11:34.430
你若无之后

11:34.430 --> 11:41.100
我们打印一下这个Prom

11:41.100 --> 11:41.260
好

11:41.260 --> 11:42.220
你看到

11:42.220 --> 11:44.580
那么Handelers里面是不是有四个函数

11:44.580 --> 11:44.940
对吧

11:44.980 --> 11:47.380
第一个函数A1

11:47.380 --> 11:48.340
他什么时候执行

11:48.340 --> 11:49.500
他Fulfill的时候

11:49.500 --> 11:50.420
他要执行这个函数

11:51.540 --> 11:53.620
result是不是有一个方法

11:53.620 --> 11:54.740
result是不是有一个方法

11:54.740 --> 11:55.980
传明来了

11:55.980 --> 11:58.700
那么result和regult是不是这个的result

11:58.700 --> 12:00.100
那么将来我执行这个函数的时候

12:00.100 --> 12:01.660
如果说没什么问题

12:01.660 --> 12:02.860
我就调入result

12:02.860 --> 12:04.380
把这个Promise完成

12:04.380 --> 12:05.620
然后调入regult的时候

12:05.620 --> 12:05.980
没问题

12:05.980 --> 12:08.500
我就把调入result与regult

12:08.500 --> 12:09.420
就是他如果出了问题

12:09.420 --> 12:10.380
我就调入regult

12:10.380 --> 12:11.460
把这个Promise拒绝

12:11.460 --> 12:12.300
就这么个意思

12:12.300 --> 12:12.900
传了四个函数

12:12.900 --> 12:14.220
这个对列是不是出来了

12:14.260 --> 12:16.060
A1,A2,B1,B2

12:16.060 --> 12:18.220
那时候说我这里只传了一个

12:21.020 --> 12:22.220
或者说我不在这里输出

12:22.220 --> 12:23.180
在这里输出都可以

12:23.180 --> 12:24.660
反正我调入任的方式

12:24.660 --> 12:25.780
它不是执行

12:25.780 --> 12:26.620
再重申一次

12:26.620 --> 12:27.540
不是执行

12:27.540 --> 12:29.460
我只是放到对列里面去

12:29.460 --> 12:31.140
将来执行的时候再输

12:32.340 --> 12:34.100
你看是不是对列也出来了

12:34.100 --> 12:35.740
虽然目前的状态

12:35.740 --> 12:38.060
目前状态跟对列有关系吗

12:38.060 --> 12:39.300
没有什么关系

12:39.300 --> 12:39.500
对吧

12:39.500 --> 12:40.860
只有将来执行的时候

12:40.860 --> 12:41.420
这里的关系

12:41.420 --> 12:42.740
比较将来执行的时候

12:42.740 --> 12:43.820
发现状态是偏低

12:43.860 --> 12:44.820
那我就不能执行

12:44.820 --> 12:46.300
一个都不能执行

12:46.300 --> 12:47.500
是不是这个意思

12:47.500 --> 12:48.260
就这么个意思

12:48.260 --> 12:49.780
我现在把对列给它放好

12:49.780 --> 12:51.780
那一代将来再执行

12:51.780 --> 12:52.540
这就是浙姐课

12:52.540 --> 12:53.820
咱们实现的内容

12:53.820 --> 12:54.740
就是往对列里边放

