WEBVTT

00:00.180 --> 00:04.180
好了 同学们 这些课呢 咱们来聊一聊关于这个端点序传

00:04.180 --> 00:10.180
当前提条件当你前辈要学习过咱们课程里边的文件下载和文件上传

00:10.180 --> 00:15.180
关于这个端点序传的话 我们在学习这部分知识的时候啊 因为

00:15.180 --> 00:22.180
它可能会有点复杂 那么学习这块知识的时候 我们重点是要知道它的原理

00:22.180 --> 00:27.180
它到底是怎么回事 为什么这样就可以完成端点下载和端点上传

00:28.180 --> 00:33.180
这是第一个 我们的重心在哪 我们不用去太过于在意代码怎么写

00:33.180 --> 00:42.180
这是第一个给大家说的 第二个的话就是端点序传啊 它分为下载和上传

00:42.180 --> 00:48.180
那么首先为什么要端点序传呢 是因为我们有些文件在下载 有些文件比较大

00:48.180 --> 00:55.180
无论是下载也好 还是上传也好 它们的过程需要经过一段时间

00:56.180 --> 01:01.180
那么在这段时间中就可能会发生一些未知的事情 比方说你的电脑突然使机了

01:01.180 --> 01:06.180
或者是家里边网突然断了 对吧 好多容易传到99% 突然网断了

01:06.180 --> 01:12.180
如果说没有端点序传的话 那么下一次你重启的电脑或者是把网修复之后

01:12.180 --> 01:17.180
再序传的时候 是不是要重新开始 对吧 所以说是为了解决这样的一个问题

01:17.180 --> 01:23.180
那么在实际开发中呢 像比方说你像B站 你作为一个up主

01:24.180 --> 01:30.180
你需要去上传一些你的视频 对吧 原创视频 那么视频可能那种比较大 文件比较大

01:30.180 --> 01:35.180
那么就需要一个端点序传 哪怕传失败了 下次可以接着传 这是第一个

01:35.180 --> 01:41.180
然后呢 就是我们在说这个端点序传的时候呢 我们会分为两个部分来讲

01:41.180 --> 01:46.180
一个是下载 一个是上传 他们是不一样的 但它基本的逻辑是一样的

01:46.180 --> 01:51.180
还是那句话 咱们在学习这部分的时候一定要去关注它的原理

01:51.180 --> 01:56.180
不用去在意它的代码 去到底怎么写 好 我们首先说下载

01:56.180 --> 02:03.180
下载这一课呢 实际上对于我们前端开发者而言 了解它的原理就够了

02:03.180 --> 02:10.180
因为平时开发的话 也不需要理虚写代码 为什么呢 我们看看它的原理就知道了

02:10.180 --> 02:15.180
为什么这个代码呢 你基本上是写不了的 我们来看一下它的原理就行了

02:16.180 --> 02:23.180
首先呢 我们之前学过文件下载 你们知道 在下载文件的时候是不是有个特殊的响应头啊

02:23.180 --> 02:29.180
对不对 那个响应头呢 就会告诉你这个文件的 比如说我们科普端去请求服务器的时候呢

02:29.180 --> 02:34.180
你看下面有一些实力服务器 实力服务器里面有一些下载链接 就是我们之前弄的

02:34.180 --> 02:38.180
好 我们这边了 把这个实力服务器通过npm start 启动起来

02:39.180 --> 02:45.180
然后就可以去请求这个例子了 然后一请求 这就可以触发下载 对吧

02:45.180 --> 02:51.180
那么我们来看一下它得到下载的响应头到底是啥 我们用postman去请求一下

02:51.180 --> 02:57.180
这个玩意其实大家都之前都看了过 因为postman的话它不会触发下载行为

02:57.180 --> 03:03.180
它只是把那个响应这个文件给你显示出来 那浏览器它可以触发下载行为

03:03.180 --> 03:08.180
你看这个header 服务器的响应头里面是不是有这么一个东西 对吧 这是我们之前学过的

03:08.180 --> 03:15.180
都告诉你啊 当你去触发下载 那么这些一向一些下载工具 比方说像浏览器

03:15.180 --> 03:21.180
像那个一些训雷 这些下载工具 它看到这样的一个响应头

03:21.180 --> 03:29.180
它就会把它当成一个文件来进行保存 除此之外呢 如果说你服务器要支持断点蓄传

03:29.180 --> 03:36.180
就断点下载 你还要需要给我一个额外的消息头 叫做arcsaves ranges batch

03:36.180 --> 03:40.180
那么这个消息头有什么用呢 我们先来简单的认识一下

03:40.180 --> 03:47.180
这个消息头就是高速的工具 你的客户端 我是支持断点蓄传的

03:47.180 --> 03:54.180
那么客户端拿到这个消息头之后 它怎么来完成断点蓄传呢 我们来看一下 这边

03:54.180 --> 03:59.180
具体的做法是这样做的 首先客户端像一些下载工具

03:59.180 --> 04:05.180
它首先会发生一个head请求来询问文件信息 这是最开始做的

04:05.180 --> 04:10.180
那么这个head请求又到底又是啥呢 其实这个head请求非常简单

04:10.180 --> 04:17.180
它就是 我相当于是我先来问你 问你一声 对吧 我比方说你是开超市的

04:17.180 --> 04:21.180
你要去进货 你不可能一开始就跑去进货了 你要去多询问一下

04:21.180 --> 04:27.180
询问一下 你的价格如何啊 你每天什么时候送货啊

04:27.180 --> 04:32.180
每次送货都送多少啊 先询问一下 先进行真正的进货

04:32.180 --> 04:36.180
那么这里是差不多的意思 我先用head请求来询问一下

04:36.180 --> 04:41.180
你这边到底是一个文件下载吗 加这个文件名叫啥呀

04:41.180 --> 04:45.180
这个文件多大呀 我先询问一下 你不用真正给我文件

04:45.180 --> 04:49.180
所以说这个head请求啊 它拿到的结果是没有请求体的

04:49.180 --> 04:55.180
没有享用体 咱们来看一下 发生这个head请求 你看服务器

04:55.180 --> 04:58.180
它没有给我任何东西 保底里边没有任何东西

04:58.180 --> 05:01.180
它享用头里边会给我一些东西 它告诉我

05:01.180 --> 05:04.180
这个享用头就跟我们之前的get请求是一样的

05:04.180 --> 05:08.180
它告诉一个文件是 我是个文件 对吧 一个附件 文件名是这个

05:08.180 --> 05:14.180
然后我支持断典续传 然后我的文件的长度 文件的尺寸是这个

05:14.180 --> 05:19.180
那么这是字节 相当于是1.4兆左右

05:19.180 --> 05:23.180
那么就把这些信息拿到了 拿到这些信息过后呢

05:23.180 --> 05:27.180
像这些下载工具啊 这个工具是可以是任何工具

05:27.180 --> 05:31.180
比如像训雷啊 像浏览器啊 对吧 浏览器也是支持断典续传的

05:31.180 --> 05:37.180
那么你看第一次 先通过head请求拿到这个文件的这些享用头

05:37.180 --> 05:40.180
那么这个文件的基本信息 我就明白了 了解了

05:40.180 --> 05:46.180
了解之后呢 我就如果说 这个客户端决定使用断典续传

05:46.180 --> 05:48.180
这个东西要看客户端自己决定啊

05:48.180 --> 05:51.180
有些客户他觉得这个文件就这么实际KB

05:51.180 --> 05:55.180
100多KB 断典啥啊 断这个冒险啊 我直接拿不拿完了吗

05:55.180 --> 05:58.180
对吧 所以说他就一次性拿完了

05:58.180 --> 06:00.180
但是如果说他觉得这个文件比较大

06:00.180 --> 06:03.180
一次性拿完了可能不是很现实

06:03.180 --> 06:06.180
那万一中途出现了问题 那我又得从头开始

06:06.180 --> 06:08.180
所以他可能会一段一段的拿

06:08.180 --> 06:11.180
那么这一段一段的拿的话 那么就需要

06:11.180 --> 06:14.180
有一个特殊的请求头 叫做range

06:14.180 --> 06:18.180
他就告诉浏览器 我这一次请求来了啊

06:18.180 --> 06:21.180
但是呢 你不要给我全部的文件 没有必要

06:21.180 --> 06:24.180
你只给我其中一段 哪一段呢

06:24.180 --> 06:28.180
batch 什么 叫字节单位 单位为字节

06:28.180 --> 06:31.180
我们知道一字节等于八位 对吧

06:31.180 --> 06:35.180
8个1010101010101020 就是二计字

06:35.180 --> 06:38.180
就是等于一字节 1020个字节等于一KB

06:38.180 --> 06:42.180
1020KB 等于一兆 对吧 这个单位你们都是知道的

06:42.180 --> 06:46.180
那么我的字节范围是零到五百个字节

06:46.180 --> 06:48.180
也就是说 你告诉浏览器

06:48.180 --> 06:51.180
我只需要这么一段文件的内容就可以了

06:51.180 --> 06:54.180
其他不用全部给我 就这么个意识

06:54.180 --> 06:57.180
那么浏览器他就会给他这么一段数据

06:57.180 --> 06:58.180
给他这么一段数据

06:58.180 --> 07:00.180
它上面端的数据肯定不是完整的文件

07:00.180 --> 07:05.400
所以科普端这边向那些下载工具往往还会生成一个临时的文件

07:05.400 --> 07:06.240
你看讯内

07:06.240 --> 07:08.160
有些人如果说细心的话会知道

07:08.160 --> 07:11.080
讯内在下载的过程中会不会生成一个临时的文件

07:11.080 --> 07:12.840
那么这个临时的文件的话

07:12.840 --> 07:17.040
它就是用来保存这个数据段的

07:17.040 --> 07:18.080
它不是一个完整的文件

07:18.080 --> 07:19.240
但是它是一个数据段

07:19.240 --> 07:20.840
它还保存这个

07:20.840 --> 07:22.040
然后这个传完之后

07:22.040 --> 07:26.600
还会告诉福奇我要501到1000这一部分的数据

07:26.600 --> 07:27.800
福奇给我吧

07:27.800 --> 07:29.920
那么福奇他福奇传过来了过后

07:29.920 --> 07:32.360
他又会保存到临时文件里面

07:32.360 --> 07:35.600
直到把整个文件的数据全部传完

07:35.600 --> 07:36.400
传完之后

07:36.400 --> 07:41.080
他再把这些碎片信息组装成完整的文件的科普端完成

07:41.080 --> 07:41.720
懂得意思吗

07:41.720 --> 07:44.520
所以说我们要完成的端点下载

07:44.520 --> 07:47.480
是需要科普端和福奇同时支持的

07:47.480 --> 07:51.480
只要福奇他要能够认识这个字端

07:51.480 --> 07:53.160
然后给他一部分数据

07:53.160 --> 07:54.960
都是需要福奇完成的

07:54.960 --> 07:55.960
然后科普端这边

07:55.960 --> 07:57.240
他要能够去做一些处理

07:57.720 --> 07:59.720
拿到一个并不完整的文件

07:59.720 --> 08:01.800
我要怎么来处理放到哪

08:01.800 --> 08:03.880
然后将来我怎么来合并

08:03.880 --> 08:04.720
对不对

08:04.720 --> 08:06.920
甚至有些科普端为了加坏下载速度的话

08:06.920 --> 08:08.000
他可能同时请求

08:08.000 --> 08:08.200
对吧

08:08.200 --> 08:10.520
先不是一次的

08:10.520 --> 08:12.040
我同时请求0到500

08:12.040 --> 08:13.800
5000到1000

08:13.800 --> 08:15.960
然后10000到1500

08:15.960 --> 08:18.560
当然实际在科普端的时候

08:18.560 --> 08:19.840
实际科普端请求的时候

08:19.840 --> 08:20.640
没有这么短

08:20.640 --> 08:21.640
他可能比较多

08:21.640 --> 08:23.560
一般来说一照一照的请求

08:23.560 --> 08:25.680
现在往都比较快了

08:25.680 --> 08:27.880
总之科普端的行为

08:27.880 --> 08:30.680
他也会影响到他这个请求的逻辑

08:30.680 --> 08:31.960
是这么一回事

08:31.960 --> 08:32.880
像训雷的话

08:32.880 --> 08:34.640
他一般会开启多个请求

08:34.640 --> 08:36.200
同时开启多个请求

08:36.200 --> 08:37.760
几个请求一起发出去

08:37.760 --> 08:39.240
然后几个请求一起回来

08:39.240 --> 08:40.920
拿到很多的片段

08:40.920 --> 08:42.960
然后再几个请求一起发出去

08:42.960 --> 08:45.400
为了充分地利用贷宽

08:45.400 --> 08:46.680
总之他需要福奇

08:46.680 --> 08:48.440
要科普端共同来完成

08:48.440 --> 08:48.720
好

08:48.720 --> 08:50.000
现在我们回到之前的问题

08:50.000 --> 08:52.240
第一个问题

08:52.240 --> 08:55.120
福奇这边这个东西到底是啥意思

08:55.160 --> 08:56.240
这东西我们之前说

08:56.240 --> 08:58.040
是高速科普端

08:58.040 --> 09:00.000
我支持端点序传

09:00.000 --> 09:01.120
那么除此之外

09:01.120 --> 09:02.240
他会告诉科普端

09:02.240 --> 09:04.640
我支持端点序传的基本单位

09:04.640 --> 09:07.000
是字节败指

09:07.000 --> 09:09.920
就是福奇高速科普端这个单位是字节

09:09.920 --> 09:14.040
于是科普端才能用字节的方式来划分

09:14.040 --> 09:15.520
懂得意思吧

09:15.520 --> 09:16.520
这是通常的做法

09:16.520 --> 09:18.320
通常都是字节单位

09:18.320 --> 09:19.840
那么科普端就会告诉福奇

09:19.840 --> 09:21.840
我这个字节的范围是哪里

09:21.880 --> 09:25.760
说这里是对应到上边的这里

09:26.760 --> 09:28.360
这是第一个我要解释的

09:28.360 --> 09:30.160
第二个我要解释的就是

09:30.160 --> 09:32.360
在咱们在讲那个下载的时候

09:32.360 --> 09:33.400
端点下载的时候

09:33.400 --> 09:34.080
我说过

09:34.080 --> 09:35.320
对于我们前端开发者

09:35.320 --> 09:36.880
你不需要去做什么事情

09:36.880 --> 09:38.360
跟你没有什么关系

09:38.360 --> 09:39.320
为什么呢

09:39.320 --> 09:40.720
你想一想

09:40.720 --> 09:43.120
前端开发者需要管这边吧

09:43.120 --> 09:44.400
不太需要吧

09:44.400 --> 09:45.760
这些人是服务器

09:45.760 --> 09:47.280
是后端做的事情

09:47.280 --> 09:48.720
当然你要弄个节奏

09:48.720 --> 09:50.160
能不能写能写

09:50.200 --> 09:52.200
如果说遇到一些特殊情况

09:52.200 --> 09:53.120
我们公司要用

09:53.120 --> 09:54.440
当里面前端用这个写

09:55.960 --> 09:56.760
其实也很简单

09:56.760 --> 09:57.360
你就几句话

09:57.360 --> 09:58.800
你学到的节奏就知道了

09:58.800 --> 10:00.960
都在节奏里面其实我有讲的

10:00.960 --> 10:01.520
那么这一块的

10:01.520 --> 10:04.680
前端开发者一般的事来说是不用管的

10:04.680 --> 10:06.880
另外一个客户端这边

10:06.880 --> 10:08.640
前端开发者能写吗

10:08.640 --> 10:09.800
也写不了

10:09.800 --> 10:10.280
为什么呢

10:10.280 --> 10:11.440
因为我们写的是什么

10:11.440 --> 10:14.520
前端写的是一页面中的节词

10:14.520 --> 10:15.880
那一页面中的节词

10:15.880 --> 10:17.360
能保存临时文件吗

10:17.360 --> 10:19.200
你给我保存试一下

10:19.280 --> 10:20.400
你学了这么久的节词

10:20.400 --> 10:24.120
哪一个APN能够让你保存文件到用户电脑上

10:24.120 --> 10:25.120
是不可能的

10:25.120 --> 10:26.400
说这里一块你写不了的

10:27.560 --> 10:30.000
除非你写浏览器插件

10:30.000 --> 10:33.160
那那个东西就超出了咱们的翻筹了

10:33.160 --> 10:38.520
所以你要在页面上实现端点下载

10:38.520 --> 10:40.480
原理上是不可能的

10:40.480 --> 10:42.200
因为你保存不了临时文件

10:42.200 --> 10:43.520
你保存不了临时文件

10:43.520 --> 10:45.360
你就不能把碎片信息拼凑

10:46.520 --> 10:47.480
对吧

10:48.200 --> 10:49.480
所以说客户端这边

10:49.480 --> 10:51.040
一般来说是一些桌面应用

10:51.040 --> 10:53.480
比方说像迅雷

10:53.480 --> 10:54.640
比方说像什么

10:54.640 --> 10:57.440
一些百度网盘等等

10:57.440 --> 10:58.760
也下载工具

10:58.760 --> 11:01.040
那么他们是可以保存临时文件的

11:01.040 --> 11:02.920
这是第二点我要说明的

11:02.920 --> 11:04.200
第三件我要说明的是

11:04.200 --> 11:05.480
就是这里的原理部分

11:05.480 --> 11:08.480
它怎么能够完成端点序传呢

11:08.480 --> 11:10.800
比方说我传完了0到500

11:10.800 --> 11:11.520
突然这个时候

11:11.520 --> 11:13.000
网络断了

11:13.000 --> 11:14.520
电脑同洗了

11:14.520 --> 11:15.360
没关系

11:15.360 --> 11:17.400
因为客户端这边有个临时文件

11:17.400 --> 11:19.840
那下一次再传同样的文件的时候

11:19.840 --> 11:21.880
他发现这个文件我已经有一部分了

11:21.880 --> 11:23.320
我就不用再发生这个请求了

11:23.320 --> 11:23.680
对吧

11:23.680 --> 11:25.640
我直接从50001开始请求

11:25.640 --> 11:27.080
就这么个意思

11:27.080 --> 11:29.320
所以说这就可以完成端点下载了

11:29.320 --> 11:30.160
对于我们这一块

11:30.160 --> 11:32.520
我们只需要知道它的基本原理就可以了

11:32.520 --> 11:33.440
那么我们这里

11:33.440 --> 11:34.640
由于通过讯雷的话

11:34.640 --> 11:36.040
不是很好测试

11:36.040 --> 11:38.520
这本地的服务器下载速度非常快

11:38.520 --> 11:39.440
讯件就完了

11:39.440 --> 11:42.560
所以说我这里能用PoseMat给大家看一下

11:42.560 --> 11:44.000
首先发动个Header请求

11:44.000 --> 11:45.600
然后得到这么一个文件信息

11:45.600 --> 11:46.080
对吧

11:46.120 --> 11:48.280
那我们现在有模拟下载工具

11:48.280 --> 11:49.280
那么下载工具接下来

11:49.280 --> 11:50.480
还会发动Header请求

11:51.720 --> 11:52.680
发动Header请求的时候

11:52.680 --> 11:55.240
他拿的不是完整的文件

11:55.240 --> 11:58.720
他会在请求头里边加上一个Range之段

11:58.720 --> 12:01.000
然后通过这样的一个格式

12:01.000 --> 12:06.040
告诉服务器我给我0到5000

12:06.040 --> 12:08.320
相当于是5kb左右

12:08.320 --> 12:09.400
没有那么小

12:09.400 --> 12:10.160
一般来说

12:10.160 --> 12:13.600
传一段的话就基本上就是一兆左右了

12:13.640 --> 12:16.240
给我这么一个片段的数据就行了

12:16.240 --> 12:17.520
好 这里发送

12:19.120 --> 12:21.440
接下来我们来看服务器的响应

12:21.440 --> 12:25.240
服务器有没有响应的body呢

12:25.240 --> 12:26.800
实际上是有的

12:26.800 --> 12:28.000
你怎么看出有的呢

12:28.000 --> 12:29.920
首先我们通过这几点来看

12:29.920 --> 12:32.200
你看这明明body里边啥都没有

12:32.200 --> 12:32.840
对吧

12:32.840 --> 12:34.880
是因为它不是一个完整的图片

12:34.880 --> 12:36.080
它这里看不出来

12:36.080 --> 12:37.320
对吧 图片就显示不出来

12:37.320 --> 12:38.960
但实际上它是有数据的

12:38.960 --> 12:40.200
哪里看出来的

12:40.200 --> 12:42.280
首先我们看这里服务器的响应的消息

12:43.200 --> 12:44.480
2006

12:44.480 --> 12:45.360
这个2006消息

12:45.360 --> 12:47.200
大家可以了解一下

12:47.200 --> 12:49.000
叫做服务器高速科普端

12:49.000 --> 12:53.400
我这个数据是我完整数据的一部分

12:53.400 --> 12:54.600
就这么个意思

12:54.600 --> 12:55.800
它也是一个成功的消息

12:55.800 --> 12:56.880
它不是错误

12:56.880 --> 12:58.880
2006 partial

12:58.880 --> 13:00.760
什么部分的康天诊

13:00.760 --> 13:01.640
内容

13:01.640 --> 13:02.760
部分内容

13:02.760 --> 13:04.680
那么我们看它的headers

13:04.680 --> 13:05.800
服务器高速科普端

13:05.800 --> 13:07.000
我这里完成响应了

13:07.000 --> 13:08.440
我已经把数据给力了

13:08.440 --> 13:11.360
那么这个数据的长度是5001

13:11.400 --> 13:13.200
你看0到5000不就是5001吗

13:13.200 --> 13:13.800
加上一个0

13:13.800 --> 13:14.800
对吧

13:14.800 --> 13:16.720
那么我数据的长度是5001

13:16.720 --> 13:17.400
这说明什么

13:17.400 --> 13:20.520
数据服务器已经把部分数据给力了

13:20.520 --> 13:22.600
那拿到这个部分数据过后

13:22.600 --> 13:23.600
那么科普端这边

13:23.600 --> 13:25.760
因为我这里不是下载工具

13:25.760 --> 13:27.200
如果说是下载工具的话

13:27.200 --> 13:28.360
它就会把这一部分数据

13:28.360 --> 13:30.480
保存到一个零十文件一个

13:30.480 --> 13:31.440
好 那么接下来

13:31.440 --> 13:34.720
还有传从5001

13:34.720 --> 13:37.920
你给我传到一万

13:37.920 --> 13:39.840
好 保留你油

13:39.840 --> 13:41.280
是不是又拿到另外一部分数据

13:41.280 --> 13:43.080
你看这个显示不出来

13:43.080 --> 13:44.160
一个图片

13:44.160 --> 13:46.360
然后就拿到另外一部分数据

13:46.360 --> 13:47.360
拿到这部分数据过后

13:47.360 --> 13:49.280
它又保存到零十文件里边

13:49.280 --> 13:52.080
直到用这种方式把所有的数据全部传完

13:52.080 --> 13:54.720
再把它合并成一个完成的文件

13:54.720 --> 13:56.320
好 这是关于下载

13:56.320 --> 13:58.840
下载对我们前轮开发者而言

13:58.840 --> 14:00.720
不需要你做什么事

14:00.720 --> 14:02.080
服务器有后端来做

14:02.080 --> 14:04.400
科普端有现成的

14:04.400 --> 14:04.680
对吧

14:04.680 --> 14:08.480
一般用户那边用训能的就可以下载

14:08.480 --> 14:10.000
好 那么我们来终点说一下

14:10.000 --> 14:11.440
这个上传

14:11.440 --> 14:15.440
上传的话就跟我们如果说真的要在

14:15.440 --> 14:18.320
页面中做那些断点上传

14:18.320 --> 14:21.280
那跟你开发就有关系了

14:21.280 --> 14:24.360
虽然这种情况比较少

14:24.360 --> 14:26.560
但是有可能会出现

14:26.560 --> 14:28.080
几率小而已

14:28.080 --> 14:29.720
如果到时候出现的话

14:29.720 --> 14:32.560
因为我们这一块是比面试课程

14:32.560 --> 14:35.320
所以我们主要是应对面试题

14:35.320 --> 14:36.560
面试题的问题

14:36.560 --> 14:37.960
断点上传和断点下载

14:38.000 --> 14:40.720
那么你要通过下载和上传两个部分来讲

14:40.720 --> 14:42.200
给它描述

14:42.200 --> 14:44.680
主要说所以说我们要关注原理

14:44.680 --> 14:47.960
但是如果说以后开发真的遇到了这种情况

14:47.960 --> 14:53.000
那么你可以按照课程里面的施路来去完成

14:53.000 --> 14:55.400
这里会比较复杂

14:55.400 --> 14:59.440
上传的话其实它的核心思想跟下载差不多

14:59.440 --> 15:01.920
下载的是不是一端一端把数据拿下来

15:01.920 --> 15:03.720
然后在客户端这边组装

15:03.720 --> 15:04.320
对吧

15:04.320 --> 15:05.840
也就是下载的时候

15:05.840 --> 15:08.920
实际上是服务器有一个完整的文件

15:08.920 --> 15:10.720
然后我们把切割切割切割

15:10.720 --> 15:12.800
一部分一部分传过来

15:12.800 --> 15:14.720
然后在这边把这一小的部分

15:14.720 --> 15:17.400
再组装成一个完整的文件

15:17.400 --> 15:20.280
服务器切割客户端组装

15:20.280 --> 15:21.920
那么如果说是上传的话

15:21.920 --> 15:22.960
那就反过来

15:22.960 --> 15:28.320
在客户端这边把文件切割成一个一个的数据块

15:28.320 --> 15:30.960
然后再上传到服务器

15:30.960 --> 15:31.360
对吧

15:31.360 --> 15:34.840
在服务器那边组装成一个完整的文件

15:34.880 --> 15:37.160
这是上传要做的事

15:37.160 --> 15:39.400
那为什么说上传要商枪内复杂一点呢

15:39.400 --> 15:42.560
实际上他们两个基本的逻辑都是一样的

15:42.560 --> 15:45.040
只是我们在做下载的时候

15:45.040 --> 15:46.640
因为很多东西给你先

15:46.640 --> 15:48.440
首先你服务器不用做那是后端的事

15:48.440 --> 15:49.240
对吧

15:49.240 --> 15:52.280
而现在下载后端有很多线层的裤

15:52.280 --> 15:53.560
可以非常轻松的完成

15:53.560 --> 15:55.680
比方说你们将来选了露着街市之后

15:55.680 --> 15:56.560
你们就知道了

15:56.560 --> 15:57.440
下载这一块

15:57.440 --> 16:00.840
咱们这个势力服务器你看我们的下载

16:00.840 --> 16:03.240
就这么两行待马就可以实现了

16:03.240 --> 16:05.840
因为那些线层的东西的劲力做好了

16:07.480 --> 16:09.640
而且刻骨端这边本身别人下载的时候

16:09.640 --> 16:10.720
都是用一些下载工具

16:10.720 --> 16:10.920
对吧

16:10.920 --> 16:11.880
百度网盘也好

16:11.880 --> 16:15.120
还是训磊也好

16:15.120 --> 16:16.800
或者是浏览器自带的下载

16:16.800 --> 16:18.240
他们都是支持端的下载的

16:18.240 --> 16:19.840
所以说你不需要做什么事

16:19.840 --> 16:22.000
服务器一搭就完事了

16:22.000 --> 16:24.240
但是上传这一部分就有一个问题

16:24.240 --> 16:25.480
因为上传的话

16:25.480 --> 16:27.920
它没有一个统一的具体的标准

16:27.920 --> 16:30.400
你看下载有通过那个写一头

16:31.360 --> 16:34.960
想用头和一个请求头就可以约定好

16:35.800 --> 16:38.320
但是这个下载它没有统一的标准

16:38.320 --> 16:40.760
就会导致要做端点下

16:40.760 --> 16:42.080
上传没有统一的标准

16:42.080 --> 16:45.280
就会导致那些要做上传的功能的这种公司

16:45.280 --> 16:47.200
他们要自己制定标准

16:47.200 --> 16:50.120
就是我怎么来告诉你这个数据块是什么情况

16:50.120 --> 16:52.080
服务器那边怎么来进组装

16:52.080 --> 16:53.640
我刻骨端这边怎么来分辨

16:53.640 --> 16:54.800
全都没有标准

16:54.800 --> 16:56.280
全要你自己搞

16:56.280 --> 16:59.160
服务器的代码全都要自己写

16:59.240 --> 17:00.160
没有线程的

17:01.160 --> 17:03.640
或者有些线程的话都不是很好用

17:03.640 --> 17:06.200
然后刻骨端这边分辨也要自己写

17:06.200 --> 17:07.560
因此会显得比较复杂

17:07.560 --> 17:09.600
其实它跟下载本质上是一样的

17:10.920 --> 17:12.280
由于标准的不同

17:12.280 --> 17:14.000
这就意味着分辨上传

17:14.000 --> 17:15.960
需要自行编写代码实现

17:15.960 --> 17:17.400
那么这一边呢

17:17.400 --> 17:18.920
你问我怎么实现

17:18.920 --> 17:21.760
那这里我有一个小的例子

17:21.760 --> 17:23.440
以后给大家看一下

17:24.920 --> 17:26.680
当然我这边做的例子

17:26.720 --> 17:29.240
这个下面我用一种比较简单的流程

17:29.240 --> 17:30.360
来实现分辨上传

17:31.320 --> 17:32.680
一是我时间有限

17:32.680 --> 17:34.520
常出的写了一个出来

17:34.520 --> 17:36.000
第二我再怎么写

17:36.000 --> 17:36.920
我不可能说

17:36.920 --> 17:39.960
覆盖市面上所有的上传情况

17:39.960 --> 17:42.760
所以我把基本原理讲清楚之后

17:42.760 --> 17:44.760
希望同学们如果说真的

17:44.760 --> 17:46.360
在公司里面遇到这种情况

17:46.360 --> 17:47.720
需要你来做

17:47.720 --> 17:50.280
你能够通过这些原理来灵活处理

17:51.960 --> 17:53.840
咱们来看一下基本的逻辑

17:54.840 --> 17:56.040
我们现在的目标

17:56.040 --> 17:57.720
就是在客户端分文件

17:57.720 --> 18:00.720
然后把文件分成数据块分片

18:00.720 --> 18:01.920
然后再把它上传

18:01.920 --> 18:04.080
那么整体逻辑就是

18:04.080 --> 18:05.080
客户端这边

18:05.080 --> 18:07.440
首先是有一个文件选择框

18:07.440 --> 18:09.400
用户选择文件

18:09.400 --> 18:11.040
选择文件之后呢

18:11.040 --> 18:12.400
我们这边就写代了

18:12.400 --> 18:14.640
把用户的选择的文件的数据

18:14.640 --> 18:18.000
那个二进制数据切分为多个分片

18:18.680 --> 18:19.760
做这么一件事

18:20.800 --> 18:22.440
然后接下来有一个逻辑

18:22.440 --> 18:23.800
大家要理解

18:23.960 --> 18:27.000
我们需要得到这个文件的MD5

18:27.000 --> 18:29.600
和每个分片的MD5

18:29.600 --> 18:30.840
首先我要聊一下

18:30.840 --> 18:33.240
这个MD5它到底是一个什么东西

18:34.160 --> 18:36.840
MD5你们在学习WebPack的时候

18:36.840 --> 18:38.320
是接触过的

18:38.320 --> 18:41.880
叫做文件指纹

18:41.880 --> 18:42.320
对吧

18:42.320 --> 18:44.240
我们每一个生成的打包之后的文件

18:44.240 --> 18:44.760
是不是这样子

18:44.760 --> 18:47.360
比方说有一个文件名

18:47.360 --> 18:48.760
APP 第二版

18:48.760 --> 18:50.600
这里有一些数字

18:50.600 --> 18:51.800
对吧

18:51.800 --> 18:52.920
有一些数字

18:53.920 --> 18:56.720
然后第二TS

18:56.720 --> 18:58.280
那么这一部分我们打来叫什么

18:58.280 --> 18:59.320
叫哈希

19:00.400 --> 19:03.280
我们说过哈希是一种编码方式

19:03.280 --> 19:04.120
那么这种编码方式

19:04.120 --> 19:05.680
有个什么样的特点呢

19:05.680 --> 19:07.720
它可以把一个很长很长

19:07.720 --> 19:09.480
就无论多长的内容

19:09.480 --> 19:12.280
编码成一个定长的制服串

19:13.360 --> 19:15.640
比方说你给我一个制服串1

19:15.640 --> 19:16.840
我给你编码成的结果呢

19:17.840 --> 19:20.000
比方说是16位的

19:21.160 --> 19:22.000
就这样子

19:22.040 --> 19:23.200
一个16位的

19:24.200 --> 19:25.560
这样的一个编码结果

19:27.200 --> 19:28.000
假设啊

19:28.000 --> 19:28.960
这16位

19:28.960 --> 19:30.320
好像不止16位

19:31.200 --> 19:32.280
然后呢

19:32.280 --> 19:34.320
你给我一个一篇文章

19:34.320 --> 19:35.720
这里很长很长的制服串

19:35.720 --> 19:36.560
它编码的结果呢

19:36.560 --> 19:38.360
也是这么一个16位的

19:38.360 --> 19:40.000
它可以把也是任何长度的编码

19:40.000 --> 19:41.520
成一个定长的制服串

19:42.840 --> 19:44.680
那么这个定长的制服串呢

19:44.680 --> 19:45.840
它有这么一个特点

19:45.840 --> 19:47.640
就是你同一个内容

19:47.640 --> 19:49.760
编码串的制服串是一模一样的

19:49.760 --> 19:51.680
只要你内容不变

19:51.720 --> 19:53.120
通过同样的编码方式

19:53.920 --> 19:56.000
编码出来的内容是一定

19:56.000 --> 19:57.240
一定是相同的

19:58.440 --> 20:00.240
只要你的内容变一点

20:00.960 --> 20:02.120
稍微变一点

20:02.120 --> 20:04.160
那么我们这边的制服串呢

20:04.160 --> 20:05.000
就会发生

20:05.000 --> 20:06.920
可能会发生翻天覆辑的变化

20:08.600 --> 20:09.760
那么我们把这些位置

20:09.760 --> 20:11.920
对修改特别敏感

20:12.600 --> 20:13.560
改动了一点

20:13.560 --> 20:15.280
就一点的内容不一样

20:15.280 --> 20:16.840
那么这边的变化就特别大

20:17.560 --> 20:19.160
哈奇编码就这么一回事

20:19.160 --> 20:20.000
其实哈奇编码呢

20:20.000 --> 20:22.640
有很多种具体算法

20:22.640 --> 20:24.640
就哈奇它只是一个整体的思路

20:24.640 --> 20:27.120
就是把一个不定长的制服串

20:27.120 --> 20:29.080
编码成一个定长的制服串

20:29.080 --> 20:30.560
那么这个算法呢

20:30.560 --> 20:31.680
具体实现了有多种

20:31.680 --> 20:33.800
我们比较常见的一种的叫MD5

20:34.640 --> 20:36.360
MD5就是这么一个东西

20:37.360 --> 20:38.640
那么我们这里说的是

20:38.640 --> 20:40.640
得到用户选择的一个文件

20:40.640 --> 20:42.320
我们要得到这个文件的MD5

20:42.320 --> 20:43.280
和每一个分片

20:43.280 --> 20:45.000
我们不是要把切分成多个分片吗

20:45.000 --> 20:45.880
那么具体怎么切分

20:45.880 --> 20:46.880
我们一会再说

20:47.680 --> 20:48.800
把它分成多个分片

20:48.800 --> 20:50.920
那么每一个分片有自己的MD5

20:50.920 --> 20:52.080
这个MD5啥意思

20:52.080 --> 20:54.680
就是把文件的内容做一个MD5编码

20:54.680 --> 20:55.920
编码成一个定长的

20:55.920 --> 20:56.840
和每一个分片

20:56.840 --> 20:57.960
每个分片不是一个

20:57.960 --> 20:59.080
每个数据块

20:59.520 --> 21:00.560
把它做个MD5

21:01.240 --> 21:03.280
那么这个东西有什么好处呢

21:03.280 --> 21:05.000
我们就可以用这个MD5

21:05.000 --> 21:06.480
来表示这个分片

21:06.480 --> 21:08.000
或者是文件的内容

21:08.000 --> 21:09.280
就是你同一个文件

21:09.280 --> 21:11.280
得到的是一定是一个相同的MD5

21:11.640 --> 21:13.000
不同的分片

21:13.000 --> 21:14.680
得到了一定是不同的MD5

21:14.680 --> 21:16.200
同一个分片一定是

21:16.720 --> 21:17.920
一样的MD5

21:18.000 --> 21:20.560
对吧 用这个MD5来代表每个分片

21:20.560 --> 21:21.760
就好比较好比说

21:21.760 --> 21:23.280
它的编号一样

21:24.280 --> 21:25.800
来代表这个分片的内容

21:26.240 --> 21:28.800
只不过这个MD5它可以代表一个分片的内容

21:28.800 --> 21:30.000
就这么意思

21:31.280 --> 21:32.520
那么我们这里用了

21:32.520 --> 21:34.480
但是这只是我的一种做法

21:34.480 --> 21:35.160
这个MD5

21:35.160 --> 21:37.920
但是无论你是用哪一种方式将来

21:38.480 --> 21:40.480
这个MD5一般都是要做的

21:40.480 --> 21:41.840
这件事一般都是要做的

21:42.400 --> 21:43.400
好 那么接下来

21:43.760 --> 21:45.680
我把这个文件的MD5

21:45.680 --> 21:47.600
你选择的文件的后维

21:47.640 --> 21:49.200
你选择的这些分片顺序

21:49.200 --> 21:51.080
对吧 分片哪是哪个是第一个分片

21:51.080 --> 21:52.200
哪个是第二个分片

21:52.200 --> 21:53.720
然后每个分片的MD5

21:53.720 --> 21:55.880
把这些信息全部抵较给服务器

21:57.080 --> 21:58.480
那么服务器那边就会看

21:58.840 --> 22:00.440
你这个文件

22:00.640 --> 22:01.480
我之前上

22:01.480 --> 22:03.640
你之前上传过吗

22:04.280 --> 22:05.600
如果说你之前已经传完了

22:05.600 --> 22:07.280
那你就没有必要上传了

22:07.600 --> 22:10.080
我就直接给你一个文件的访问地址就完了

22:10.880 --> 22:13.400
那如果说你之前没有上传过

22:13.400 --> 22:15.120
那行吧 你就上传呗

22:15.240 --> 22:17.280
那如果说你之前上传过一部分

22:17.640 --> 22:19.440
它怎么来判断上传过一部分

22:19.440 --> 22:20.960
它就通过这个MD5来判断

22:22.880 --> 22:24.880
你之前上传过哪些部分

22:24.880 --> 22:26.640
对吧 每个部分的MD5

22:26.640 --> 22:28.200
服务器那边会有记录

22:28.320 --> 22:30.480
你把整个文件的所有的MD5

22:30.760 --> 22:32.320
分片的MD5都给我了

22:32.320 --> 22:33.920
就分片编号全部给我了

22:34.200 --> 22:36.680
那么服务器就会通过这个MD5来对绕

22:36.680 --> 22:40.040
之前你这个文件上传过哪些分片

22:40.040 --> 22:41.920
它就通过MD5来对绕

22:42.680 --> 22:45.880
那它就会把还剩下哪些分片没有上传

22:46.360 --> 22:47.560
它会给你一个东西

22:47.640 --> 22:51.080
告诉你 你现在不需要把所有的分片上传

22:51.080 --> 22:53.160
你给我部分的就可以了

22:53.880 --> 22:54.680
它就会告诉你

22:54.680 --> 22:57.320
你还需要上传哪些分片的编号

22:57.800 --> 22:59.400
那么客户端就拿到这个消息过后

22:59.400 --> 23:01.360
它就会再点上传的时候

23:01.360 --> 23:03.720
那么它就会从服务器

23:03.720 --> 23:06.080
给我这个消息中去上传分片

23:06.320 --> 23:10.400
比如说客户端这边分片的MD5

23:10.400 --> 23:15.090
假设客户端那边告诉服务器

23:18.590 --> 23:19.390
告诉服务器

23:19.950 --> 23:23.670
说我这个文件划分出5个分片

23:23.670 --> 23:25.190
当然不可能那么少

23:25.710 --> 23:27.070
看文件的大小其实

23:27.070 --> 23:28.830
分片的方式有很多种

23:29.390 --> 23:30.670
总之你分片就行了

23:30.670 --> 23:32.510
我们现在又通过一个数组告诉服务器

23:32.510 --> 23:34.870
我现在有5个分片要上传

23:35.070 --> 23:36.670
我就划分出来是5个分片

23:36.670 --> 23:37.870
那么他们MD5

23:37.870 --> 23:39.110
我这里就简单写

23:39.110 --> 23:41.390
是1 2

23:41.390 --> 23:43.950
MD5我们之前说过是一个定长的

23:43.950 --> 23:44.470
知不出来

23:44.470 --> 23:45.470
它不是这个样子的

23:45.470 --> 23:46.910
我这里就是简单举个例子

23:51.340 --> 23:51.940
告诉服务器

23:51.940 --> 23:53.860
我有这么一个这么一些编号的分片

23:53.860 --> 23:54.700
需要上传

23:56.020 --> 23:57.820
当然还要告诉他文件的编码

23:57.820 --> 23:59.820
文件的文件的编码

24:00.300 --> 24:02.780
文件编码就是ABC假设

24:03.660 --> 24:05.140
文件的编这是MD5

24:07.620 --> 24:08.540
告诉服务器

24:08.540 --> 24:10.780
然后服务器那边自己他就会查看

24:10.780 --> 24:12.540
查看服务器上有没有这个

24:12.540 --> 24:15.740
你这个文件ABC带服务器上有没有

24:16.740 --> 24:17.620
有的话

24:17.620 --> 24:19.460
那么说明这个文件内容一定是一样的

24:19.500 --> 24:21.340
因为这个MD5他就代表了文件内容

24:22.580 --> 24:24.540
那么服务器看这个ABC有

24:24.540 --> 24:25.940
有的就不需要上传了

24:26.820 --> 24:28.620
我们现在是说没有的情况

24:28.620 --> 24:30.900
没有的情况可能你传了一部分了

24:30.900 --> 24:31.340
已经

24:31.340 --> 24:33.300
那么服务器看原来MD

24:33.300 --> 24:34.740
这个ABC这个文件

24:34.740 --> 24:36.900
之前在服务器上已经上传了

24:37.620 --> 24:38.620
1和2了

24:39.820 --> 24:40.660
已经上传了

24:40.660 --> 24:42.340
我已经把它保存到临时文件里面了

24:42.340 --> 24:43.580
只是我现在还没有组装

24:43.580 --> 24:44.700
因为我还还差一部分

24:44.700 --> 24:45.220
对吧

24:45.220 --> 24:46.940
所以服务器他就会告诉科普端

24:50.440 --> 24:51.600
科普端

24:51.640 --> 24:53.080
那么你接下来给我上传

24:53.080 --> 24:54.240
这么一些部分就行了

24:54.240 --> 24:56.800
三四五

24:57.440 --> 24:58.400
懂了意思了

24:58.400 --> 25:00.320
那么科普端那边是不是知道了

25:00.320 --> 25:01.800
那么接下来科普端上传的时候

25:01.800 --> 25:03.440
那么就从三开始上传

25:03.440 --> 25:03.920
那你看

25:05.760 --> 25:07.040
我就上传其中一个分片

25:07.040 --> 25:08.880
比方说再上传一个三

25:08.880 --> 25:10.160
也上传三的话服务器是吧

25:10.160 --> 25:11.680
把三记录一下

25:11.680 --> 25:12.000
好了吗

25:12.000 --> 25:14.480
服务器又响应一个结果

25:14.480 --> 25:16.040
你现在我还差四和五

25:17.040 --> 25:19.480
他又响应一个还需要上传的分片

25:19.480 --> 25:20.440
MD5

25:20.440 --> 25:21.280
还差一个四和五

25:21.720 --> 25:23.800
那么这样子的科普端要继续

25:23.800 --> 25:25.840
我又上传一个四

25:25.840 --> 25:27.720
而服务器就把四保存一下

25:27.720 --> 25:29.080
好接下来我还差一个五

25:29.840 --> 25:31.000
是吧

25:31.000 --> 25:31.640
还差一个五

25:32.480 --> 25:32.680
好

25:32.680 --> 25:34.400
那么科普端那边再上传一个分片

25:34.400 --> 25:35.680
就上传五

25:35.680 --> 25:36.640
好上传五完了过后

25:36.640 --> 25:38.760
是不是所有分片都已经上传了

25:38.760 --> 25:40.280
所有分片都已经上传过后

25:40.280 --> 25:42.520
服务器那边就会把这些分片全部合并

25:42.520 --> 25:43.960
合并成一个完整的文件

25:43.960 --> 25:47.000
然后给科普端想一个文件的访问地址

25:47.000 --> 25:47.480
就完事了

25:48.920 --> 25:49.120
好

25:49.120 --> 25:50.200
那么这个服务器呢

25:50.240 --> 25:51.680
我这边已经给大家写好了

25:52.680 --> 25:53.800
我再重申一次

25:53.800 --> 25:58.640
这里边只是一个非常非常简单的分片上传的流程

25:58.640 --> 26:00.120
在真正的实际开发中

26:00.120 --> 26:02.000
还要考虑很多很多的情况

26:02.000 --> 26:03.080
比方说这个分片

26:03.080 --> 26:04.760
是不是一定按照数据去到达

26:04.760 --> 26:05.760
它有可能不是的

26:06.480 --> 26:08.080
它可能是乱去到达的

26:09.280 --> 26:10.200
还有一些问题

26:10.200 --> 26:11.680
比方说并发的时候

26:11.680 --> 26:13.000
同时上传很多分片的时候

26:13.000 --> 26:15.240
多个用户同时上传不同的分片的时候

26:15.240 --> 26:16.240
那么又该怎么处理

26:16.240 --> 26:18.120
服务器考虑的问题还要很多

26:18.120 --> 26:20.480
那么科普端那边可能也要考虑一些问题

26:20.480 --> 26:20.680
对吧

26:20.680 --> 26:24.200
我是如果说我一个分片一个分片接着上传的话

26:24.200 --> 26:26.360
那个这样子穿行的话会很难

26:26.360 --> 26:26.800
对吧

26:26.800 --> 26:28.240
我们刚才刚才做法是

26:28.240 --> 26:29.680
先来第一个分片

26:29.680 --> 26:30.400
再来第二个分片

26:30.400 --> 26:31.200
再来第三个分片

26:31.200 --> 26:32.000
这样子很乱

26:32.000 --> 26:32.760
那么我有可能呢

26:32.760 --> 26:35.640
我们会把几个分片同时上传

26:35.640 --> 26:37.440
开启多线程同时上传

26:37.440 --> 26:40.120
然后到达一个不会马上又上传另一个

26:41.480 --> 26:42.480
有可能用这种方式

26:42.480 --> 26:43.760
说实际开发中呢

26:43.760 --> 26:45.960
可能情况还要复杂一些

26:45.960 --> 26:46.720
但是不管怎么样

26:46.720 --> 26:48.320
它基本逻辑就这么个逻辑

26:49.600 --> 26:49.800
好

26:49.800 --> 26:50.560
接下来我们来看一下

26:50.560 --> 26:53.200
咱们的服务器目前知识的情况

26:53.200 --> 26:54.120
在上传这一块呢

26:54.120 --> 26:56.480
我写了两个接口

26:56.480 --> 26:58.720
一个接口叫做文件信息协商

26:58.720 --> 27:01.000
一个接口叫分片上传

27:01.000 --> 27:02.640
我们之间看第一个接口

27:02.640 --> 27:04.320
第一个就是做什么用的呢

27:04.320 --> 27:06.040
它是就是这一步

27:08.120 --> 27:09.400
在这一步

27:09.400 --> 27:12.840
你把这些信息提交给服务器的时候

27:12.840 --> 27:14.400
服务器那边先看一下

27:14.400 --> 27:15.600
你这个文件有没有

27:15.680 --> 27:17.480
有的话就说那边

27:17.480 --> 27:18.960
你没必要搞了

27:18.960 --> 27:21.520
没有的话咱们再说

27:21.520 --> 27:21.680
好

27:21.680 --> 27:23.480
咱们来看一下这个接口

27:23.480 --> 27:25.400
我用Pose麦给大家测试一下

27:25.400 --> 27:27.080
让大家比较对这个原理的

27:27.080 --> 27:27.920
跑得清楚一点

27:29.480 --> 27:31.160
我们把这个前边的

27:31.920 --> 27:32.640
复制一下

27:34.950 --> 27:35.430
这个地址

27:37.030 --> 27:37.190
好

27:37.190 --> 27:38.430
那么这是个Pose请求

27:39.190 --> 27:39.950
请求的字段

27:39.950 --> 27:41.830
你要给它提交三个字段

27:41.830 --> 27:44.910
Fill ID, EST, Trunks ID

27:44.910 --> 27:45.990
那么一个个说

27:46.030 --> 27:47.270
那么这边我们就模拟

27:47.270 --> 27:48.230
Body, Root

27:48.230 --> 27:49.270
这里选择接胜

27:50.310 --> 27:51.030
我用这种格式

27:51.030 --> 27:52.270
这里没有上传任何文件

27:52.950 --> 27:55.150
比方说客户端那边选择了一个文件

27:56.150 --> 27:58.190
那么这边我们就需要通过

27:58.590 --> 28:00.110
一个消息告诉服务器

28:00.110 --> 28:03.030
我接下来要给你上传文件的Fill ID

28:03.870 --> 28:05.230
这个Fill ID是什么呢

28:05.670 --> 28:07.030
就是它的MD5边

28:07.710 --> 28:09.270
对整个文件的MD5边

28:09.270 --> 28:11.710
那么比方说我这里就随便弄一个

28:12.550 --> 28:17.800
来一首唐诗

28:20.370 --> 28:22.450
假设我要分片上传一首唐诗

28:26.020 --> 28:26.580
就这个吧

28:27.580 --> 28:28.380
就这么识据话

28:28.900 --> 28:29.940
我有这么一个文件

28:29.940 --> 28:31.620
这个文件内容就是这么识据话

28:31.620 --> 28:33.060
那么我们现在客户端这边

28:33.060 --> 28:34.340
就要对这识据话

28:34.340 --> 28:34.980
这就是文件内容

28:34.980 --> 28:35.900
进行MD5边

28:36.660 --> 28:38.620
咱们找一个再线MD5边

28:42.800 --> 28:43.840
接下来

28:44.360 --> 28:45.520
在这

28:46.280 --> 28:46.800
在这

28:57.120 --> 28:58.640
你就要能够对多环闻

28:58.640 --> 28:59.400
好在这吧

28:59.400 --> 29:00.280
MD5加密

29:00.680 --> 29:03.880
那么接下来我们使用32位小写

29:03.880 --> 29:05.400
大写小写都是无所谓

29:05.400 --> 29:07.200
注意这件事是在哪完成的

29:07.200 --> 29:08.400
是在客户端完成的

29:08.800 --> 29:10.160
用户选择的文件

29:10.160 --> 29:12.960
我就要把文件的MD5给它算出来

29:13.720 --> 29:14.480
我们这里加密

29:15.720 --> 29:16.400
好找到

29:16.400 --> 29:18.240
那么它的MD5是这么一个制服串

29:18.240 --> 29:19.240
我就告诉服务器

29:19.240 --> 29:21.160
我接下来文件的MD5是这个

29:22.000 --> 29:23.080
然后会告诉服务器

29:23.080 --> 29:25.320
我这个文件的后续名 EST

29:25.440 --> 29:26.560
表示后续名

29:26.560 --> 29:27.440
那么这是一个

29:27.440 --> 29:28.720
比方说这是个TST文件

29:29.360 --> 29:30.880
那么就点TST

29:31.520 --> 29:33.160
然后再告诉服务器

29:33.160 --> 29:34.280
它的trunks

29:35.040 --> 29:35.720
IDs

29:36.920 --> 29:37.640
关键是这个

29:38.000 --> 29:38.760
这个是什么

29:38.760 --> 29:41.520
就是文件分片的编号数组

29:41.520 --> 29:42.800
每个编号就是MD5

29:43.320 --> 29:44.120
就是这个东西

29:45.880 --> 29:46.520
就这个东西

29:47.680 --> 29:49.680
我们要得到每个分片的MD5

29:49.680 --> 29:50.840
那么假设

29:50.840 --> 29:52.440
我这边对这个唐诗

29:52.440 --> 29:53.040
这个文件

29:53.040 --> 29:53.720
完整的文件

29:53.840 --> 29:56.040
文件数据分成两片来上传

29:56.040 --> 29:57.920
第一片上传前量据

29:58.760 --> 30:01.000
那么我们就先对前量据来进行

30:02.800 --> 30:03.400
MD5

30:04.120 --> 30:05.360
我们得到这么一个MD5

30:07.510 --> 30:07.830
算个是

30:07.830 --> 30:08.870
我就给它一个数据

30:08.870 --> 30:10.070
第一个MD5是这个

30:10.550 --> 30:11.270
第二个

30:13.440 --> 30:14.760
第二个是后两句

30:20.410 --> 30:21.970
另一个分片是后两句

30:23.090 --> 30:24.250
后两句写过来

30:25.250 --> 30:27.210
好我就告诉服务器这么一些消息

30:27.210 --> 30:28.370
我用一个文件

30:28.770 --> 30:29.330
要上传

30:29.370 --> 30:30.890
这个文件的MD5编号是这个

30:31.290 --> 30:32.610
文件的后维是这个

30:32.810 --> 30:33.250
这个文件

30:33.250 --> 30:34.610
我打算把它分成两片

30:35.570 --> 30:37.290
每一票的MD5都告诉你

30:37.290 --> 30:38.610
来你服务器给我看一下

30:38.610 --> 30:40.210
这个文件我还需要传哪些

30:41.010 --> 30:42.610
好我们现在就发送到服务器

30:43.690 --> 30:45.250
接下来你看服务器告诉我们什么

30:45.570 --> 30:46.610
告诉我们说

30:47.090 --> 30:48.010
现在这个文件

30:49.210 --> 30:50.010
我一个都没有

30:50.610 --> 30:52.410
那么这两个分片你都是要上传的

30:52.810 --> 30:55.010
你看这个分片是不是刚好等于第一个分片

30:55.530 --> 30:57.570
这个分片是不是刚好等于第二个分片

30:57.570 --> 30:59.170
那么服务器通过这种方式告诉你

30:59.530 --> 31:00.890
这两个分片都要上传

31:01.210 --> 31:02.730
那如果说服务器那边只有

31:02.730 --> 31:03.850
已经上传了一个分片了

31:03.850 --> 31:05.530
他就会他就想一句不一样了

31:05.850 --> 31:06.570
表达他上传了

31:06.570 --> 31:07.690
已经上传了这个分片了

31:07.690 --> 31:09.170
那么他那边服务器想用的时候

31:09.170 --> 31:10.450
他就会没有这个

31:11.130 --> 31:11.890
他就没有这个

31:12.650 --> 31:14.090
他只有一个懂得意思吧

31:14.450 --> 31:15.410
通过这种方式

31:15.410 --> 31:16.610
来边服务器已经决定

31:17.250 --> 31:18.730
好这是第一个接口明白了吗

31:19.730 --> 31:20.770
好第二个接口

31:21.770 --> 31:22.370
分片上传

31:22.370 --> 31:25.050
这个时候才是真正的上传分片信息

31:26.290 --> 31:27.410
来我们来看一下这个接口

31:28.290 --> 31:29.010
这个接口

31:29.010 --> 31:30.610
我们也是用PoseMain来测试

31:33.040 --> 31:33.960
还是Pose星球

31:35.560 --> 31:37.840
那么我们这里API的话是

31:37.840 --> 31:39.200
uploaduploadu

31:42.490 --> 31:43.090
就这个点

31:43.850 --> 31:46.290
接下来他要上传三个字段名

31:46.290 --> 31:46.930
第一个

31:48.970 --> 31:49.810
第一个是File

31:49.810 --> 31:51.610
就是分片的二进制数据

31:52.250 --> 31:53.050
比较重的现在

31:53.050 --> 31:53.770
比较重的现在

31:53.770 --> 31:55.770
知道了服务器让我上传两个分片

31:55.770 --> 31:57.290
那我先上传第一个分片吧

31:58.250 --> 32:00.410
那么这个分片的二进制数据

32:00.650 --> 32:01.530
那么也就是说

32:01.690 --> 32:03.570
跟我们之前学到的文件是一样的

32:07.340 --> 32:10.460
我们这里先把保底设成PoseData

32:12.420 --> 32:14.580
文件T值是File

32:14.900 --> 32:15.860
那么文件

32:15.860 --> 32:17.420
我这里文件我们就假设

32:17.420 --> 32:19.460
我在这里桌面上建一个TST文件

32:19.460 --> 32:19.980
假设

32:21.340 --> 32:24.420
这边是叫做SE

32:24.420 --> 32:25.140
第一个分片

32:25.140 --> 32:26.020
Segment1

32:26.460 --> 32:29.460
然后我把个数据的二进制数据

32:33.500 --> 32:34.180
就这个数据

32:34.900 --> 32:36.580
这是我们第一个分片

32:36.580 --> 32:37.580
然后第二个分片的

32:37.580 --> 32:39.140
我又真的进动了两个文件

32:39.140 --> 32:39.980
实际上这些东西

32:39.980 --> 32:41.300
就在内存里边划分完了过

32:41.300 --> 32:42.500
就直接上传上去了

32:44.180 --> 32:45.020
我这边的

32:45.020 --> 32:45.980
我来测试

32:46.500 --> 32:47.340
测试这个

32:47.340 --> 32:48.220
所以呢

32:49.060 --> 32:50.180
发现了两个文件

32:50.180 --> 32:51.180
来模拟

32:51.940 --> 32:53.500
看到底是怎么分片的

32:53.500 --> 32:54.660
这边再来一次

32:54.660 --> 32:55.620
这边我们是不是

32:55.620 --> 32:56.820
找到达到服务器的响应了

32:56.820 --> 32:58.540
他告诉我这两个分片都要上传

32:58.540 --> 33:00.100
那么这边我们就开始上传了

33:00.100 --> 33:02.060
第一次我上传第一个分片

33:02.220 --> 33:03.300
那么就是一个File

33:03.300 --> 33:04.780
T字为File

33:05.420 --> 33:07.220
这是分片的二进制数据

33:07.220 --> 33:08.420
文件数据

33:08.420 --> 33:09.500
这是第一个字段

33:09.500 --> 33:10.100
第一个字段

33:10.100 --> 33:11.220
TrunkID

33:11.220 --> 33:11.900
告诉服务器

33:11.900 --> 33:14.260
我这一次上传的是哪一个分片ID

33:14.860 --> 33:16.500
分片的MD5

33:16.500 --> 33:17.700
那么刚才上传了

33:17.700 --> 33:19.140
这个分片的MD5

33:19.140 --> 33:20.500
我把这个MD5写进去

33:21.740 --> 33:22.500
你不写这个的话

33:22.500 --> 33:23.420
服务器鬼知道的

33:23.420 --> 33:25.300
这个二进制到底是哪一个分片的

33:25.300 --> 33:26.140
是吧

33:26.140 --> 33:27.740
好把这个给他

33:27.740 --> 33:30.260
然后第三个FileID

33:30.260 --> 33:31.460
这个是告诉他服务器

33:31.500 --> 33:33.300
我这个分片是属于哪一个文件的

33:35.300 --> 33:35.620
在这

33:38.700 --> 33:40.700
就把这个三个消息告诉服务器

33:42.340 --> 33:43.980
好接下来我们再发送

33:46.370 --> 33:47.730
服务器那边跟我响应个什么呢

33:47.730 --> 33:49.090
响应的说

33:49.090 --> 33:51.490
好这个分片我已经收到了

33:51.490 --> 33:53.330
我已经正确处理了

33:53.330 --> 33:55.570
然后我现在还差一个分片

33:55.570 --> 33:56.930
还差这个分片

33:56.930 --> 33:58.650
你把这个分片给我

33:58.650 --> 33:59.090
懂了意思吗

33:59.090 --> 33:59.810
是不是这个

33:59.810 --> 34:01.450
我就上传了一个分片了

34:01.490 --> 34:02.970
对吧就这么简单

34:02.970 --> 34:04.290
就这个逻辑就是这么一个逻辑

34:04.290 --> 34:04.490
对吧

34:04.490 --> 34:06.330
客户端那边把分片分好过后

34:06.330 --> 34:07.570
一片一片给服务器

34:07.570 --> 34:08.530
服务器那边会告诉你

34:08.530 --> 34:09.610
还需要哪些分片

34:10.730 --> 34:12.050
好那么假设

34:12.050 --> 34:13.210
假设我现在断电了

34:13.210 --> 34:14.410
电脑重启了

34:14.410 --> 34:15.570
一切都没了

34:15.570 --> 34:16.930
接下来我重启了电脑之后

34:16.930 --> 34:19.090
我还想接着传

34:19.090 --> 34:20.690
那么用户又选择的一个文件

34:20.690 --> 34:21.770
还是之前的一个文件

34:21.770 --> 34:22.770
还是这个文件

34:22.770 --> 34:23.490
那么这一次呢

34:23.490 --> 34:24.530
我分片得让分片

34:24.530 --> 34:25.130
文件一样

34:25.130 --> 34:27.010
分片出来的结果是不是一样的

34:27.010 --> 34:28.890
只要分片规则不变

34:28.890 --> 34:30.690
分片规则是不能变的

34:30.730 --> 34:32.290
那么得到的分片一定是一样的

34:32.290 --> 34:33.050
这个时候呢

34:33.050 --> 34:34.530
我再去问服务器

34:34.530 --> 34:36.050
重复来一次

34:36.050 --> 34:36.890
我再去服务器

34:36.890 --> 34:38.770
你看这次服务器给我的东西不一样

34:38.770 --> 34:39.770
他告诉我

34:39.770 --> 34:40.570
你这个文件

34:40.570 --> 34:42.610
我那边已经有一部分了

34:42.610 --> 34:43.330
你再给我

34:43.330 --> 34:44.810
这个部分就行了

34:44.810 --> 34:45.770
那么客户端一看

34:45.770 --> 34:46.650
那我知道了

34:46.650 --> 34:47.970
那我现在再给你一个

34:47.970 --> 34:49.930
第二个分片S2

34:49.930 --> 34:51.010
那么第二个分片呢

34:51.010 --> 34:53.090
就是这个

34:53.090 --> 34:55.290
这个创改文件ID不变

34:55.290 --> 34:57.450
分片的ID就是这个ID了

34:57.450 --> 34:59.970
好那么现在我们再上传

35:00.090 --> 35:00.850
这边啥意思

35:00.850 --> 35:02.210
服务器高处理

35:02.210 --> 35:03.570
不需要了

35:03.570 --> 35:04.290
这个文件

35:04.290 --> 35:05.650
这个文件所有的信息

35:05.650 --> 35:07.450
我已经上传完成了

35:07.450 --> 35:10.730
不需要给我上传任何新的分片了

35:10.730 --> 35:14.450
那么这个时候就已经上传完成

35:14.450 --> 35:16.570
好那么这边的服务器就会高

35:16.570 --> 35:18.890
那如果说下一世你再选的这个文件

35:18.890 --> 35:20.090
又来了

35:20.090 --> 35:20.770
表演又锻炼了

35:20.770 --> 35:22.210
又重启了

35:22.210 --> 35:23.770
我之前那个文件传完没有

35:23.770 --> 35:25.050
我再上传一次

35:25.050 --> 35:27.610
那我再上传的时候服务器高处理

35:27.610 --> 35:28.690
没必要上传了

35:28.730 --> 35:30.290
这个文件已经有了

35:30.290 --> 35:31.850
它通过MD5就可以知道

35:31.850 --> 35:33.130
这个文件已经上传了

35:33.130 --> 35:34.290
那么还告诉你这个文件

35:34.290 --> 35:35.530
通过这个地址访问

35:35.530 --> 35:37.970
一般来说这个访问地址都是有一定规则的

35:37.970 --> 35:39.490
你客户端自己都可以生存出来

35:39.490 --> 35:41.410
比方说我这边的规则是

35:41.410 --> 35:42.210
uploader

35:42.210 --> 35:44.050
然后后面就是文件的MD5

35:44.050 --> 35:45.530
然后后面是后追名

35:45.530 --> 35:47.450
那么现在我们打开这个文件

35:47.450 --> 35:51.170
你可以看到服务器那边拿到一个完整的文件

35:51.170 --> 35:52.850
如果说通过这边

35:52.850 --> 35:53.850
我们的视力服务器里边

35:53.850 --> 35:55.730
你可以看到这个目录下面

35:55.730 --> 35:56.370
就可以拿

35:56.410 --> 35:58.010
它就是合并成一个完整的文件

35:59.370 --> 36:02.090
这就是整个分片上传的过程

36:02.090 --> 36:04.250
那么有了这个服务器接口之后

36:04.250 --> 36:06.530
接下来就是客户端可以输血代码

36:06.530 --> 36:07.570
那么客户端输血代码

36:07.570 --> 36:08.850
我这里做了一个简单的实力

36:08.850 --> 36:10.730
有一个央视有点丑陋

36:10.730 --> 36:13.370
不过勉强能看

36:13.370 --> 36:15.010
比方说这里得有选择文件

36:15.010 --> 36:15.930
选择文件的时候

36:15.930 --> 36:19.170
假设我们就上传一个大文件

36:19.170 --> 36:21.680
比方说这个

36:23.160 --> 36:24.520
1.42G

36:25.480 --> 36:27.640
那可能也要等太久了

36:28.480 --> 36:29.440
到这边接成品

36:29.440 --> 36:30.680
就是100多张

36:30.680 --> 36:31.560
好 打开

36:32.560 --> 36:34.280
那么这个时候正在处理中

36:34.280 --> 36:35.440
它处理的是什么呢

36:35.440 --> 36:37.840
处理到就是把这个文件进行分辨

36:37.840 --> 36:41.240
然后对每一个分辨进行MD5编号

36:41.240 --> 36:43.000
来说这个是不是效率太低了

36:43.000 --> 36:44.760
那可能别的上传工具

36:44.760 --> 36:45.800
你拿到就上传了

36:47.760 --> 36:50.160
那是它没有给你显示那个

36:50.160 --> 36:51.560
显示那个框框

36:51.560 --> 36:53.360
它可以通过WebWorker

36:53.400 --> 36:54.640
可以开一些新线程上

36:54.640 --> 36:55.920
它们去计算MD5

36:55.920 --> 36:57.640
然后让你的页面不要卡住

36:57.640 --> 36:58.480
它通过一些技术

36:58.480 --> 37:00.720
这个过程是肯定省不了的

37:00.720 --> 37:02.400
没办法省的

37:02.400 --> 37:04.000
然后我们这里点击开始上传

37:05.440 --> 37:06.320
那么暂停

37:07.800 --> 37:09.400
那么现在就上传了73%

37:09.400 --> 37:10.440
接下来我关掉页面

37:11.440 --> 37:12.600
关掉页面了

37:12.600 --> 37:14.080
然后我们再重新打开

37:14.080 --> 37:15.480
就模拟我们现在重启了

37:16.560 --> 37:18.240
然后我们再选择同样一个文件

37:18.240 --> 37:18.640
接成品

37:22.660 --> 37:24.060
你看它就是告诉你

37:24.060 --> 37:26.140
我已经上传了73%了

37:26.140 --> 37:27.300
你不需要重新上传了

37:27.300 --> 37:28.380
接下来继续上传

37:29.380 --> 37:30.100
好上传完了过后

37:30.100 --> 37:31.740
就得到一个文件的访问地址

37:31.740 --> 37:32.500
那么通过的地址

37:32.500 --> 37:34.460
你就可以看到这个完整的文件了

37:35.460 --> 37:35.780
OK

37:35.780 --> 37:37.900
那么到底是怎么做的呢

37:37.900 --> 37:40.500
这一块我就不带着大家写代码了

37:40.500 --> 37:41.900
如果说从您开始写代码的话

37:41.900 --> 37:44.540
那这一块有点太费事了

37:44.540 --> 37:46.060
而且我这个代码

37:46.060 --> 37:48.060
只是起个抛砖隐喻的作用

37:48.060 --> 37:48.940
供大家参考

37:50.740 --> 37:51.700
简单看一下吧

37:51.700 --> 37:53.620
首先那些ATMLCSS

37:53.620 --> 37:55.100
我就完全不说了

37:55.140 --> 37:56.580
我主要说GS这一块

37:57.340 --> 38:02.180
GS这一块我这里有一个DOM CONTROLS

38:02.180 --> 38:02.900
我做了一个对象

38:02.900 --> 38:04.940
当然你们那边如果说将来开发的时候

38:04.940 --> 38:06.060
是不是一定要按照我的设计

38:06.060 --> 38:06.580
那不一定

38:07.220 --> 38:09.580
我跟你说每块代码我在做什么就行了

38:09.580 --> 38:13.020
这一块我是主要是设置动物元素的

38:14.140 --> 38:15.500
我有一些动物元素的状态

38:15.500 --> 38:17.260
那些东西需要去设置

38:17.260 --> 38:21.640
比如说你看这个页面上

38:21.640 --> 38:23.040
我这里别成忘了

38:23.040 --> 38:24.280
这样给云测试

38:25.800 --> 38:26.840
我一个DOM CONTROL

38:26.840 --> 38:28.000
它起什么作用呢

38:28.000 --> 38:29.840
比如说我们这里可以set link

38:30.640 --> 38:31.880
设置超链接

38:31.880 --> 38:32.680
调用这个方法

38:32.680 --> 38:33.320
调用这个方法

38:35.320 --> 38:36.080
不要让它摆住吧

38:37.960 --> 38:40.840
它就给你把这个元素给你显示出来

38:40.840 --> 38:42.720
然后给你生成一个A元素显示这个

38:43.800 --> 38:45.320
这个里面都能做吧

38:45.320 --> 38:46.040
这个不用说了吧

38:47.480 --> 38:51.240
然后如果说我去调用set progress

38:52.760 --> 38:53.880
这里传一个百分比

38:54.720 --> 38:56.240
百分比的话传一个50

38:57.840 --> 38:58.960
那么它就会生成

38:58.960 --> 39:01.800
它就会把这个区域的元素显示出来

39:02.400 --> 39:05.000
然后给你设置这个区域的DOM对象

39:05.000 --> 39:06.120
这是蠢动

39:07.000 --> 39:08.560
DOM对象里面的蚊子

39:09.080 --> 39:10.160
还有这个精度条

39:10.160 --> 39:12.680
那么这些东西你们都能做吧

39:13.120 --> 39:14.160
这精度条会不会做

39:15.080 --> 39:17.080
就是一个DIV里面

39:17.760 --> 39:20.040
套了一个长的DIV

39:20.440 --> 39:22.080
DIV里面套了一个

39:23.080 --> 39:25.160
百分之

39:25.160 --> 39:27.920
宽度为百分比的这么一个DIV

39:28.360 --> 39:29.280
它有个背景颜色

39:29.280 --> 39:30.360
这个东西太简单了

39:31.560 --> 39:34.120
这个微象是用来设置DOM元素的

39:35.800 --> 39:36.400
还有什么呢

39:37.320 --> 39:38.920
还有设置这个按钮状态的

39:40.240 --> 39:43.280
DOM control set status

39:43.280 --> 39:44.520
按钮有这么一些状态

39:44.840 --> 39:45.440
一个是

39:47.120 --> 39:48.800
一个是

39:49.240 --> 39:49.800
choose

39:50.080 --> 39:51.800
表示用户已经选择了文件

39:52.360 --> 39:53.040
那么这个时候

39:58.200 --> 39:59.560
你把这些状态都忘了

40:01.920 --> 40:02.400
明白了

40:02.920 --> 40:04.240
我当时是这样做的

40:04.480 --> 40:06.080
我是给这里一个按钮

40:09.010 --> 40:10.490
这里它有个自定义属性

40:10.650 --> 40:12.690
它就是表示按钮目前的状态

40:13.690 --> 40:14.930
目前的状态有好几种

40:14.930 --> 40:17.090
有没有选择文件

40:17.330 --> 40:18.610
刚刚选择的文件

40:18.690 --> 40:19.850
正在商船中

40:20.410 --> 40:21.290
暂停中

40:22.010 --> 40:23.090
和已完成

40:23.090 --> 40:24.170
有这么一些状态

40:25.290 --> 40:26.850
比方说我这里把它设成choose

40:27.490 --> 40:28.490
表示按钮

40:28.810 --> 40:30.650
就是目前已选择的文件

40:30.650 --> 40:32.370
那么这个按钮应该是什么状态呢

40:32.370 --> 40:36.410
我就调用DOM control set status

40:39.180 --> 40:40.780
按钮应该长这个样子

40:41.580 --> 40:42.860
也就是说这个函数

40:43.100 --> 40:45.140
它就是根据你这里的自定义属性

40:45.140 --> 40:46.900
来设置这个button的状态

40:47.140 --> 40:49.300
比方说目前正在商船中uploading

40:50.740 --> 40:52.540
那么现在我们再调这个set status

40:53.180 --> 40:54.980
它的文字就变成了暂停

40:55.500 --> 40:56.540
你目前正在商船

40:56.540 --> 40:57.660
你点一下就暂停了

40:58.500 --> 41:00.540
如果说你目前正式暂停

41:00.820 --> 41:01.500
pose

41:02.260 --> 41:03.340
这些都是DOM操作

41:03.340 --> 41:04.340
没有什么好说的

41:06.020 --> 41:06.860
变成继续

41:07.620 --> 41:09.060
总之我就封装了一些方法

41:09.060 --> 41:10.780
主要是来控制一下

41:10.780 --> 41:11.940
DOM元素的操作

41:12.540 --> 41:13.740
这个不是重点

41:13.940 --> 41:16.060
重点是文件分辨就在这一块

41:16.460 --> 41:17.660
怎么来分辨的

41:18.140 --> 41:20.340
这个函数它反回一个promise

41:21.340 --> 41:22.900
这个函数

41:23.340 --> 41:25.140
你给它一个文件

41:25.260 --> 41:27.300
它要能够对这个文件进行分辨

41:27.300 --> 41:29.140
不仅要得到这个文件的后维

41:29.780 --> 41:32.980
还要得到这个文件的各种分辨信息

41:33.780 --> 41:34.420
懂吗

41:34.940 --> 41:36.100
比方说举个例子

41:38.540 --> 41:40.900
我这边有这么一个函数split file

41:40.900 --> 41:43.140
我比方说选择一个文件

41:44.660 --> 41:46.340
我就选择这个文件

41:50.560 --> 41:51.160
选择文件

41:51.160 --> 41:52.040
它已经上船完成了

41:52.040 --> 41:53.240
这个文件不用再上船了

41:53.760 --> 41:57.440
然后我这边的文件id為file

41:57.440 --> 41:59.120
这个input id为file

42:00.080 --> 42:02.040
因为我这个页面上是引用了接query的

42:03.160 --> 42:06.560
所以说我这里直接得到id为file的这个元素

42:08.160 --> 42:11.800
那么是不是得到拿到一个file元素

42:11.800 --> 42:12.440
F吧

42:14.080 --> 42:15.320
对吧 是不是这个元素

42:15.520 --> 42:16.520
它只是隐藏的

42:17.920 --> 42:20.040
这个元素目前选中了一个文件

42:20.040 --> 42:21.640
我们是不是特别通过files

42:21.680 --> 42:23.520
你拿到你这个文件

42:24.040 --> 42:25.040
这就是个file对象

42:25.640 --> 42:28.920
我把file对象传给这个函数split file

42:30.760 --> 42:32.160
把file对象传进去

42:32.760 --> 42:33.200
你看一下

42:34.600 --> 42:35.440
它是个promise

42:35.440 --> 42:37.960
它需要一个一段时间的运算

42:37.960 --> 42:40.040
这个MD5的运算还是比较花时间的

42:43.510 --> 42:44.670
我们可以拿到这个info

42:45.470 --> 42:46.670
然后打印一下这个info

42:51.860 --> 42:52.500
稍等片刻

42:54.020 --> 42:55.300
接下来是不是拿到这个info了

42:55.580 --> 42:58.860
这个函数的作用就是拿到文件的所有信息

42:58.860 --> 43:00.260
你看这里边它给我们返回

43:00.260 --> 43:01.420
得到一个是一个对象

43:01.420 --> 43:03.220
对对象里边就拿到我们需要的信息

43:03.700 --> 43:05.500
这个文件的MD5编号

43:05.940 --> 43:07.260
这个文件的后维

43:07.660 --> 43:10.420
然后这个文件的分片分成了137个片

43:11.260 --> 43:14.620
每一个分片的MD5编号

43:15.860 --> 43:17.620
然后每个分片的二净值数据

43:18.420 --> 43:19.700
那么这个二净值数据相当于

43:19.700 --> 43:21.260
我们刚才在这里分的东西

43:21.260 --> 43:22.380
都还要只是在内存里面

43:22.980 --> 43:23.980
分到了二净值数据

43:25.500 --> 43:26.580
你看这里很多

43:27.700 --> 43:30.460
那这个函数是整个实现整

43:30.460 --> 43:33.620
柯伯端这边实现分片上传的整个重点

43:34.540 --> 43:35.660
到底咋实现了呢

43:36.540 --> 43:37.340
就这么一段代吧

43:38.540 --> 43:40.300
我们简单的看一下

43:40.300 --> 43:42.500
一个逻辑可能会稍有一点复杂

43:43.100 --> 43:43.940
不需要大家学会

43:43.940 --> 43:45.500
我们再重申一次分片

43:46.500 --> 43:47.740
端点序传这一块

43:48.220 --> 43:50.220
了解原理比啥的重要

43:50.220 --> 43:52.340
因为到时候你们公司

43:52.780 --> 43:54.660
如果说有自己的商传下载

43:55.100 --> 43:55.700
标准的话

43:55.700 --> 43:57.180
他们一般会封装一些东西

43:57.420 --> 43:57.780
写好

43:59.700 --> 44:00.300
了解一下

44:00.420 --> 44:01.260
开会一下视野

44:02.660 --> 44:03.020
为什么

44:03.020 --> 44:04.380
首先为什么要返回Promise

44:04.900 --> 44:06.380
因为这个分片需要时间

44:06.380 --> 44:08.100
这个时间还挺满长的

44:08.740 --> 44:10.500
所以说它肯定是一个异步的行为

44:10.740 --> 44:11.620
得到一个Promise

44:12.820 --> 44:13.140
来吧

44:15.020 --> 44:15.220
好

44:15.220 --> 44:17.820
首先我这里定的一个编辖叫分片尺寸

44:18.620 --> 44:20.460
就是一个分片它到底多大

44:21.580 --> 44:23.980
我是用这种定长的分片方式

44:24.060 --> 44:25.420
分片方式有很多

44:25.580 --> 44:26.220
比方说

44:26.620 --> 44:28.140
也可以有动态的

44:28.620 --> 44:29.860
你根据网络的

44:29.860 --> 44:31.260
就是服务器的享用时间

44:31.260 --> 44:31.460
对吧

44:31.460 --> 44:33.020
看这个网络好不好好的话

44:33.020 --> 44:34.460
我就分片就大一点

44:34.940 --> 44:36.180
差的话分片就小一点

44:36.500 --> 44:38.100
分片方式千奇百怪

44:38.700 --> 44:40.860
我这里是用一种比较简单的定长

44:41.260 --> 44:42.860
一招单位是字节

44:42.860 --> 44:44.380
1024个字节等于1KB

44:44.380 --> 44:45.620
1024KB等于一招

44:45.820 --> 44:46.420
我就一招

44:47.620 --> 44:49.620
分片数量是不是很容易算出来

44:49.820 --> 44:51.220
我们通过File Size

44:51.220 --> 44:52.660
是不是这个文件的

44:54.020 --> 44:57.060
传过来的参数文件的字节数

44:57.060 --> 44:59.300
除异每一片的字节数

44:59.580 --> 45:00.780
然后向上取个准

45:01.300 --> 45:02.700
是不是因为它可能有小数

45:03.140 --> 45:04.020
得到分片的数量

45:04.020 --> 45:05.220
我一共有这么多分片

45:06.660 --> 45:08.860
然后接下来我得到一个Trunk Index

45:08.860 --> 45:09.660
这个什么意思

45:09.860 --> 45:12.300
我要一片一片拿出来计算

45:13.220 --> 45:15.660
我先拿到第一片数据算一下它的MD5

45:15.780 --> 45:18.060
然后再拿到第二片数据

45:18.060 --> 45:19.580
算一下第二片数据的MD5

45:19.580 --> 45:19.980
对吧

45:19.980 --> 45:21.580
这就是我们这个下标

45:21.580 --> 45:22.580
先从0开始

45:22.580 --> 45:23.380
一片一片拿

45:24.020 --> 45:26.260
好 接下来我用了这么一个第三方库

45:26.260 --> 45:28.260
这个第三方库叫Spot MD5

45:29.700 --> 45:31.380
这个玩意起什么作用了

45:31.700 --> 45:33.540
这个玩意是来做MD5编码的

45:33.540 --> 45:35.500
我这边也去引用了这个GS

45:37.300 --> 45:38.620
MD5就这个东西

45:38.620 --> 45:39.700
就引用了两个GS

45:39.700 --> 45:41.260
一个MD5 一个Gquery

45:42.260 --> 45:44.100
这个主要是用来做MD5编码

45:44.340 --> 45:46.420
因为文件的数据它不是一个字符串

45:46.940 --> 45:48.380
你看我刚才在页面上

45:48.660 --> 45:49.460
这里刚才

45:50.260 --> 45:52.580
对吧 唐诗是字符串

45:53.060 --> 45:54.900
但它文件的数据它是二进字的

45:55.420 --> 45:56.780
所以说我们要用一个buffer

45:56.780 --> 45:57.820
叫Array Buffer

45:57.820 --> 46:00.060
这个内容专门用来存二进字的

46:01.060 --> 46:02.340
我通过一个Array Buffer

46:02.340 --> 46:04.940
就是一部分一部分给它加二进字数据

46:05.100 --> 46:08.420
最后我先加第一片二进字数据给它

46:08.580 --> 46:10.940
然后再加第二片二进字数据给它

46:11.100 --> 46:13.300
最后把整个文件的每一个分片的

46:13.540 --> 46:15.020
二进字数据就全部加进来了

46:15.340 --> 46:16.100
那么我们来算

46:16.300 --> 46:17.300
这个东西主要是

46:17.300 --> 46:22.020
这一块主要是为了计算整个文件的MD5

46:23.540 --> 46:24.940
我们一片一片拿

46:25.980 --> 46:27.660
我再给大家划个头吧

46:28.060 --> 46:29.260
整个我继续这个

46:29.820 --> 46:31.380
我有一个完整的文件

46:32.700 --> 46:35.540
我先拿出第一片

46:36.620 --> 46:37.820
对吧 上面有个第一片

46:38.500 --> 46:39.900
拿出第一片的时候

46:39.900 --> 46:41.500
是不是可以拿到第一片的MD5

46:42.860 --> 46:45.380
然后再把第一片的二进字数据

46:46.140 --> 46:47.620
加到这个里面去

46:48.900 --> 46:50.900
好 接下来我们拿第二片

46:51.620 --> 46:53.340
第二片的MD5是不是可以出来了

46:54.340 --> 46:57.500
好 我们一把第二片的二进字数据加到这里面去

46:57.700 --> 46:59.420
我们一直拿

46:59.700 --> 47:00.820
拿到最后一片

47:01.340 --> 47:03.140
那么最后一片的MD5也出来了

47:03.300 --> 47:06.420
对吧 同时我们一把最后一片的MD5

47:06.420 --> 47:08.540
最后一片的二进字数据加到这里面去

47:08.540 --> 47:10.180
那么现在二进字数据加完了

47:10.420 --> 47:13.100
加完过后我们再对整个的二进字数据

47:15.060 --> 47:17.220
整个的二进字数据做一个MD5编码

47:18.100 --> 47:19.020
所以说这样子

47:19.020 --> 47:20.620
我就有了每一片的MD5

47:20.740 --> 47:22.340
同时有了整个文件的MD5

47:22.580 --> 47:23.700
一试性就搞定了

47:24.060 --> 47:25.140
是这么一个意思

47:27.500 --> 47:31.620
然后它就是起计算整个文件的MD5的

47:32.460 --> 47:34.020
好 接下来我们用一个File Radar

47:34.020 --> 47:35.900
这个东西是一个文件读取器

47:35.900 --> 47:38.500
是H5过后才有的

47:38.860 --> 47:40.900
它是可以一段

47:40.900 --> 47:42.300
可以读一个文件内容

47:42.300 --> 47:43.820
读一个二进字内容

47:43.820 --> 47:44.940
把二进字读出来

47:45.500 --> 47:46.540
好 那么这个创口时

47:46.540 --> 47:47.900
就是分片信息数组

47:47.900 --> 47:48.820
这个玩意就是这个

47:49.740 --> 47:50.540
创口时就是这个

47:51.140 --> 47:53.020
最终拿到每一个分片的信息

47:53.500 --> 47:55.100
我们一会儿要往这里边加的

47:55.100 --> 47:56.100
好 接下来我们看

47:57.500 --> 47:58.940
这里我准备好了一个函数叫

47:58.940 --> 47:59.820
load next

48:00.860 --> 48:02.180
读取下一个分片

48:02.700 --> 48:04.140
一个分片一个分片读

48:04.340 --> 48:06.900
那我怎么来计算下一个分片的起始的

48:07.300 --> 48:08.980
字结束位置呢

48:09.180 --> 48:12.060
首先下个分片的二进字开始的位置

48:12.060 --> 48:14.060
就是个字结束开始的位置

48:14.340 --> 48:16.740
等于下标成为每一个分片大小

48:16.740 --> 48:17.980
比方说你分片是一兆

48:18.700 --> 48:20.660
那第一个分片的起始和结束

48:20.660 --> 48:22.900
就应该是零到一兆

48:22.900 --> 48:23.540
对吧

48:23.860 --> 48:24.780
所以零到一兆

48:25.220 --> 48:28.500
第二个分片是不是一兆到两兆

48:28.500 --> 48:30.620
第三个分片是不是两兆到三兆

48:30.620 --> 48:31.340
就这个意思

48:31.860 --> 48:35.980
起始是不是下标成为分片的尺寸

48:35.980 --> 48:37.060
下标从零开始

48:37.860 --> 48:38.660
下标从零开始

48:38.660 --> 48:40.020
一开始起始就是零

48:40.020 --> 48:41.260
第二次下标变成一大

48:41.260 --> 48:42.580
那么这些起始变成一

48:43.580 --> 48:45.460
好 然后结束你至于算

48:46.460 --> 48:49.460
首先从起始加上一个尺寸

48:49.460 --> 48:50.060
这样一兆

48:50.060 --> 48:51.300
起始是零加一兆

48:51.300 --> 48:51.980
那就是一兆

48:51.980 --> 48:52.420
对吧

48:52.420 --> 48:53.980
开始大于文件尺寸

48:53.980 --> 48:54.980
如果说超过了文件尺寸

48:54.980 --> 48:55.940
我就得取文件尺寸

48:55.940 --> 48:57.180
没有超过的话就取这个

48:57.180 --> 48:58.140
这不可以算出

48:58.140 --> 48:59.460
我要取哪一段

48:59.460 --> 49:00.980
起始和结束就算出来了

49:00.980 --> 49:01.820
算出来之后

49:01.820 --> 49:03.180
我们通过File Snides

49:03.180 --> 49:05.940
这是File里面一个方法

49:05.940 --> 49:07.660
可以把这个文件的

49:08.140 --> 49:10.500
结取其中一部分二进字数据

49:10.500 --> 49:13.100
那么这里会反过一个二进字数据

49:13.700 --> 49:14.780
结取其中一段

49:14.900 --> 49:16.900
snides跟数据里面差不多的意思

49:17.340 --> 49:18.300
取这么一段

49:18.300 --> 49:21.220
然后把这一段数据交给File Raider

49:22.140 --> 49:23.780
让它把这一段数据读出来

49:24.300 --> 49:26.300
读出来是一个Array Buffer

49:26.300 --> 49:28.340
就是一个相当于是二进字的数据

49:29.660 --> 49:31.660
每一个数据的每一项就是一个数字

49:31.660 --> 49:32.860
二进字数字

49:33.780 --> 49:35.260
就是读出来这么一个东西

49:35.780 --> 49:36.940
那么也就是说这个函数据

49:36.940 --> 49:37.540
最后是什么

49:37.540 --> 49:39.660
读取下一个分片的二进字

49:40.660 --> 49:42.140
好 这一读的话

49:42.380 --> 49:44.420
它就会触发File Raider的一个事件

49:44.420 --> 49:45.260
叫Unload

49:45.940 --> 49:47.420
只要你读取成功一次

49:47.820 --> 49:49.660
它就会触发这么一个事件一次

49:49.900 --> 49:50.780
你读一个分片

49:50.780 --> 49:51.900
它就会触发这个事件

49:52.220 --> 49:53.020
那么这个事件里面

49:53.020 --> 49:55.100
你就可以拿到它读出来的结果

49:55.300 --> 49:56.300
它是用这种方式处理的

49:56.300 --> 49:57.300
因为读这个文件

49:57.300 --> 49:58.380
它是一个异步行为

49:58.900 --> 50:00.500
IO是一个异步行为

50:01.100 --> 50:02.580
这一块碳法有点复杂

50:02.980 --> 50:05.260
那么这个事件里面

50:05.260 --> 50:07.860
就其实我就拿到每一个分片的数据

50:08.460 --> 50:09.940
拿到每一个分片的二进字

50:10.900 --> 50:11.940
那么这个Result

50:11.940 --> 50:13.660
其实就是每一个分片的二进字

50:14.380 --> 50:15.260
就这么个意思

50:16.380 --> 50:17.420
好 那这个Result

50:17.420 --> 50:18.620
我就把它夹到这里边去

50:18.620 --> 50:19.620
我们刚才是不是说了

50:20.540 --> 50:21.740
有一个文件

50:21.740 --> 50:23.300
有一个完整的文件

50:23.940 --> 50:25.620
然后我先一片一片读

50:25.620 --> 50:26.420
对吧 读一片

50:26.420 --> 50:28.620
我就把二进字夹到这个Spark里面去

50:28.620 --> 50:29.420
就这么个意思

50:29.660 --> 50:30.060
你看

50:30.380 --> 50:31.660
所以我用Spark and Append

50:31.820 --> 50:33.300
夹这个二进字出去夹进去

50:33.900 --> 50:36.100
然后我在单独的计算

50:36.100 --> 50:40.060
这个分片的MD5

50:40.300 --> 50:42.100
你看我这句话就在单独的计算

50:42.420 --> 50:44.100
Rebuffer-Hash

50:44.100 --> 50:46.820
就在计算单独的这一块分片的MD5

50:48.020 --> 50:49.980
那这里我夹了这么一个东西

50:49.980 --> 50:50.700
夹了一个下标

50:51.140 --> 50:53.060
把整个编码出来的MD5支付出来

50:53.060 --> 50:54.020
再加上一个下标

50:54.300 --> 50:55.940
我这里为什么要加上一个下标呢

50:55.940 --> 50:57.700
我是为了防止这种情况

51:00.400 --> 51:01.000
因为这种情况

51:01.000 --> 51:02.400
我没有做特殊处理

51:02.960 --> 51:05.480
就是有的时候分片画出来了

51:05.480 --> 51:07.480
可能会遇到相同的

51:07.480 --> 51:08.200
比方说

51:08.680 --> 51:09.720
有一个

51:10.200 --> 51:11.080
我举个例子

51:11.760 --> 51:14.920
有一个文件写的是abc

51:17.690 --> 51:18.530
abcd

51:18.850 --> 51:19.530
abc

51:20.490 --> 51:22.210
那么假设这个文件

51:22.850 --> 51:23.770
这样子分片

51:23.770 --> 51:25.090
第一个分片是ab

51:25.090 --> 51:26.210
第二个分片是cd

51:26.210 --> 51:27.490
第三个分片是ab

51:27.490 --> 51:29.090
第四个分片只有c的

51:29.330 --> 51:30.610
假设是这样子分片

51:31.090 --> 51:32.810
那是不是第一个分片和第三个分片

51:32.810 --> 51:33.850
结果是一样的

51:34.450 --> 51:35.250
那第一个分片

51:35.250 --> 51:36.250
第三个分片的MD5

51:36.250 --> 51:36.970
是不是就一样

51:36.970 --> 51:37.810
一定一样的

51:38.690 --> 51:39.210
对吧

51:39.530 --> 51:41.210
那么到时候会遇到一些问题

51:41.210 --> 51:41.770
其实这个问题

51:41.810 --> 51:42.810
我们可以通过

51:42.810 --> 51:44.570
再去详细的制定一些标准

51:44.570 --> 51:46.170
比方说分片重用

51:46.690 --> 51:47.650
我第三个分片

51:47.650 --> 51:49.010
我就重用第一个分片

51:49.730 --> 51:51.490
这样子可以更高效

51:51.490 --> 51:52.970
但我这边没有人这样处理

51:52.970 --> 51:54.850
这样处理的话更加复杂

51:55.210 --> 51:56.850
因此这一块我就做法

51:56.850 --> 51:58.570
就是让每一个分片的MD5

51:58.570 --> 51:59.370
保持唯一

51:59.370 --> 52:00.730
就是我这里的做法

52:00.730 --> 52:01.610
不是说标准

52:02.130 --> 52:03.330
我加了一个index

52:04.890 --> 52:05.570
就是这一块

52:06.330 --> 52:07.410
不然我再写复杂

52:07.410 --> 52:09.010
你们是真的啥也看不懂了

52:10.010 --> 52:11.450
然后这个

52:12.290 --> 52:14.050
现在我们是不是把分片的二进字

52:14.050 --> 52:14.930
加到这里边去了

52:14.930 --> 52:17.170
这是用来算整个文件的MD5的

52:17.170 --> 52:18.690
一个加完了之后才能算

52:19.210 --> 52:20.210
然后我们又可以拿到

52:20.210 --> 52:21.690
当前那个分片的MD5

52:22.690 --> 52:24.730
准备好读习下一个分片

52:25.010 --> 52:25.690
它加加

52:25.930 --> 52:28.010
接下来我把目前分片

52:28.010 --> 52:29.330
就是分片数组

52:29.330 --> 52:30.090
有信息数组

52:30.090 --> 52:30.770
就这个数组

52:31.890 --> 52:32.570
它每个数组里边

52:32.570 --> 52:33.690
是不是有两个属性

52:33.690 --> 52:34.610
一个是ID

52:34.610 --> 52:35.650
一个是content

52:35.810 --> 52:37.610
那么ID是不是就是这个MD5

52:38.610 --> 52:39.410
内容

52:39.410 --> 52:40.250
content

52:40.250 --> 52:41.810
它是一个二进字数据

52:41.810 --> 52:42.610
blob

52:43.610 --> 52:44.490
blob

52:44.490 --> 52:45.090
这个东西

52:45.090 --> 52:46.250
我们回来这里去详细

52:46.250 --> 52:46.770
产数了

52:46.770 --> 52:48.410
你可以把就里面一个二进字

52:48.410 --> 52:49.250
这个二进字数

52:49.250 --> 52:50.290
它是个构造器

52:50.290 --> 52:52.650
因为你到时候要用文件上传的话

52:52.650 --> 52:53.850
你要上传这个东西

52:54.210 --> 52:55.610
一个分片一个分片上传

52:55.610 --> 52:56.810
你要上传这个东西

52:56.810 --> 52:57.570
这个东西

52:57.570 --> 52:59.130
要么就必须是File对象

52:59.130 --> 53:01.170
要么就必须是blob对象

53:01.690 --> 53:02.250
那么这里

53:02.250 --> 53:04.050
我就必须要去构建一个blob对象

53:04.050 --> 53:05.650
然后这里边让你去

53:06.650 --> 53:08.410
传到是一个数组进去

53:08.410 --> 53:09.410
这个数组里边

53:10.210 --> 53:12.330
每一项是一个array buffer

53:13.530 --> 53:14.730
是一个二进字数据

53:15.130 --> 53:15.730
那么

53:16.290 --> 53:18.130
这个玩意儿就是一个二进字数据

53:19.490 --> 53:21.290
你看我们刚才不就在读这个

53:21.890 --> 53:22.810
array buffer嘛

53:23.010 --> 53:24.970
那么这里的result

53:26.410 --> 53:27.090
在这

53:27.450 --> 53:28.370
这里的result

53:30.250 --> 53:30.930
在这

53:30.930 --> 53:31.850
这里的result

53:32.010 --> 53:33.930
result就是一个array buffer

53:34.250 --> 53:35.130
array buffer

53:35.930 --> 53:37.730
那么它可以有多个二进字数据

53:37.730 --> 53:38.570
把它拼在一起

53:38.570 --> 53:39.650
那我这里只有一个

53:39.890 --> 53:40.370
就这样

53:41.330 --> 53:42.610
创作生里边就加了一下

53:43.970 --> 53:46.170
如果说目前index小于

53:46.490 --> 53:47.210
创作cult

53:47.530 --> 53:48.570
表示我们的分片

53:48.570 --> 53:49.810
到后边都还有分片

53:49.970 --> 53:51.530
所以我调用load next

53:51.730 --> 53:52.530
调用这个函数

53:52.690 --> 53:53.770
继续读习下一个

53:54.090 --> 53:55.290
这个团形一读下一个

53:55.290 --> 53:56.610
是不是又读到一个array buffer

53:56.730 --> 53:57.490
又读了一个array buffer

53:57.490 --> 53:58.890
是不是又运行这个unload

53:59.010 --> 53:59.930
然后又读下一个

53:59.930 --> 54:00.170
对吧

54:00.170 --> 54:01.410
就一直读一直读

54:02.530 --> 54:03.410
那么直到

54:03.770 --> 54:04.730
到达这个cult

54:04.770 --> 54:06.010
表示分片已经读完了

54:06.290 --> 54:06.970
读完了过后

54:06.970 --> 54:08.330
我们调用这个end函数

54:08.690 --> 54:09.610
就是这个

54:09.890 --> 54:10.650
这个end函数

54:10.650 --> 54:11.450
那么就可以计算

54:11.450 --> 54:13.650
它里边不是加了很多的二进字数据吗

54:13.650 --> 54:14.450
到时候这个时候

54:14.450 --> 54:17.050
就已经是完整的文件的二进字数据了

54:17.250 --> 54:18.170
那么通过end

54:19.570 --> 54:21.810
就可以得到整个文件的md5

54:22.210 --> 54:23.130
最后我们result

54:23.130 --> 54:24.090
完成整个

54:24.490 --> 54:25.090
一步处理

54:25.090 --> 54:26.050
就完成整个任务

54:26.250 --> 54:27.570
任务里边我就告诉他

54:27.570 --> 54:28.330
我的文件

54:28.330 --> 54:28.850
id

54:29.010 --> 54:29.570
md5

54:30.490 --> 54:30.930
后续名

54:30.930 --> 54:32.130
后续名的话很简单

54:32.130 --> 54:32.810
通过一个

54:33.090 --> 54:34.130
辅助函数实现的

54:34.410 --> 54:35.010
非常简单

54:35.010 --> 54:36.250
得到一个文件名的

54:36.490 --> 54:37.410
把文件名传进去

54:37.410 --> 54:38.690
得到文件名的最后一个点

54:38.690 --> 54:39.290
对吧

54:39.290 --> 54:40.770
然后这个东西里面都懂

54:40.770 --> 54:41.450
很简单

54:41.610 --> 54:42.730
然后就是一个创始

54:42.730 --> 54:43.530
每个分片

54:44.050 --> 54:45.810
就完成这么一个核心函数

54:45.810 --> 54:46.610
十分之一之二

54:47.330 --> 54:48.530
只要一选择文件

54:49.170 --> 54:49.810
所以后续的

54:49.810 --> 54:50.730
后续就比较简单了

54:50.730 --> 54:51.210
对吧

54:51.850 --> 54:53.890
首先这里是一个普通按钮

54:53.890 --> 54:54.930
点击这个按钮的时候

54:54.930 --> 54:56.450
实际上是点击的

54:57.930 --> 54:59.090
文件那个按钮

54:59.450 --> 55:00.650
实际上是点击着它

55:01.010 --> 55:02.210
它虽然是隐藏的

55:02.410 --> 55:03.170
我点它的时候

55:03.170 --> 55:04.050
实际上是点它

55:04.370 --> 55:05.130
这个很简单

55:06.090 --> 55:07.290
然后的话

55:07.290 --> 55:10.290
当文件选择变化的时候

55:10.570 --> 55:11.290
关键这个函数

55:11.730 --> 55:13.450
就是我选择文件了过后

55:16.980 --> 55:18.260
选择了文件过后

55:18.500 --> 55:19.300
那么这个时候

55:19.540 --> 55:20.940
它会做一些界面上的处理

55:20.940 --> 55:22.580
比方要显示这个模

55:22.580 --> 55:23.500
就是请

55:23.740 --> 55:25.780
请稍后那个整个模特

55:26.420 --> 55:27.340
整个模特

55:28.460 --> 55:30.980
蒙层处理中显示这个

55:31.460 --> 55:32.700
然后后面都是一些

55:32.980 --> 55:34.780
有些界面处理我们不多说了

55:34.900 --> 55:35.620
关键是这

55:35.740 --> 55:36.940
我们调用刚才那个函数

55:36.940 --> 55:37.860
叫split file

55:38.060 --> 55:39.860
把文件的信息传进去

55:40.340 --> 55:41.140
等它完成

55:41.140 --> 55:42.020
等它完成之后

55:42.020 --> 55:43.940
是不是就拿到所有的文件信息了

55:44.100 --> 55:45.100
然后我们就可以通过

55:45.100 --> 55:46.620
请求服务器那个地址

55:46.620 --> 55:47.380
handle-shake

55:47.380 --> 55:48.540
就最开始那个地址

55:48.780 --> 55:50.380
把这些信息全部告诉服务器

55:50.380 --> 55:52.180
用接受的格式上传

55:52.180 --> 55:53.100
告诉服务器

55:53.100 --> 55:54.580
我的文件ID是啥

55:54.580 --> 55:55.700
我的后绝名是啥

55:55.700 --> 55:56.900
每一个分片信息

55:56.900 --> 55:58.420
因为服务器那边不要二进制

55:58.420 --> 55:59.420
它只要那个什么

55:59.420 --> 56:00.900
它只要那个每个分片的

56:01.540 --> 56:02.180
ID

56:02.180 --> 56:02.740
编号

56:02.740 --> 56:03.940
是不是我这里有个map

56:03.940 --> 56:04.860
把每个创渴

56:05.140 --> 56:06.340
都到它的编号就可以了

56:06.580 --> 56:08.300
把这个信息上传给服务器

56:08.540 --> 56:08.780
好

56:08.780 --> 56:09.580
咱们来看一下吧

56:10.500 --> 56:11.180
我这里就

56:11.740 --> 56:12.860
刚才应该有了

56:13.180 --> 56:14.140
你看handle-shake

56:14.540 --> 56:15.660
刚才我们选了文件过后

56:15.660 --> 56:16.940
你看上传的信息

56:17.060 --> 56:18.220
requiescent payload

56:20.090 --> 56:21.290
这样看的舒服一点

56:21.490 --> 56:22.890
所以上传文件的

56:22.890 --> 56:24.490
后绝文件的ID

56:24.490 --> 56:25.530
已经每一个创渴

56:26.330 --> 56:27.850
每个创渴的信息全部给它了

56:28.810 --> 56:29.050
好

56:29.050 --> 56:30.090
服务器那边就会验证了

56:30.090 --> 56:31.690
这些创渴是不是都完了

56:31.850 --> 56:32.930
还有哪些没有上传

56:32.930 --> 56:34.250
服务器是不是会有响应

56:34.810 --> 56:36.490
服务器我们看一下服务器的响应

56:37.290 --> 56:38.090
服务器告诉我

56:38.090 --> 56:39.130
这个文件已经上传过了

56:39.130 --> 56:40.010
你不需要再上传了

56:40.010 --> 56:42.090
它就会给我一个文件的访问地址

56:42.570 --> 56:43.530
就这么一个意思

56:44.490 --> 56:45.370
所以说

56:45.530 --> 56:47.690
如果说服务器给我的不是输出

56:48.250 --> 56:49.530
它给我的是一个制服圈

56:49.530 --> 56:50.410
那么就说明啥

56:50.810 --> 56:52.330
说明这个文件不需要上传了

56:52.330 --> 56:53.850
因此的我设置一下link

56:54.330 --> 56:55.610
得到服务器的响应结果

56:55.610 --> 56:55.930
对吧

56:55.930 --> 56:57.370
直接就上传完成了

56:57.370 --> 56:58.810
然后我把设置为

56:59.770 --> 57:01.130
这里我sets progress

57:01.130 --> 57:02.890
这个是封装了一个界面上的函数

57:02.890 --> 57:03.690
处理函数

57:04.490 --> 57:08.250
这里是保存的是文件信息

57:08.250 --> 57:08.810
这里是

57:08.810 --> 57:10.170
我还需要上传哪些分片

57:10.170 --> 57:11.130
这是服务器响应的

57:11.690 --> 57:13.050
还需要上传哪些分片

57:13.050 --> 57:13.930
那么这个函数

57:13.930 --> 57:15.290
就是你看一下

57:15.290 --> 57:17.050
文件信息里边不是有所有分片吗

57:17.050 --> 57:18.330
你目前还需要哪些分片

57:18.330 --> 57:19.450
是不是可以算出一个百分比

57:20.330 --> 57:20.650
对吧

57:20.650 --> 57:21.210
所以可以算出

57:21.210 --> 57:22.650
目前上传的多少百分比

57:22.650 --> 57:25.290
然后通过我们刚才这个东西

57:25.290 --> 57:28.090
是不可以设置界面上的百分几度条

57:28.090 --> 57:29.290
就这么一个作用

57:29.290 --> 57:33.290
通过这两个辩量来设置函度条

57:33.770 --> 57:35.130
你看都是这样做的

57:35.130 --> 57:36.730
如果说服务器那边给我的

57:36.730 --> 57:37.610
已经没有东西了

57:37.610 --> 57:37.930
对吧

57:37.930 --> 57:39.770
已经没有分片需要上传了

57:39.770 --> 57:40.730
那我就把这个

57:40.730 --> 57:42.490
还需要上传的分片清空

57:42.490 --> 57:43.290
设置空数组

57:43.290 --> 57:44.810
然后设置百分比

57:44.810 --> 57:47.050
那百分比肯定是100%了

57:47.050 --> 57:48.090
他没有东西需要上传了

57:49.530 --> 57:51.290
然后把安留的状态设置一下

57:51.290 --> 57:52.410
设置一下安留的状态

57:52.410 --> 57:54.330
然后设置一下这个访问链接就完事了

57:54.970 --> 57:56.570
那如果说还有东西要上传了

57:56.570 --> 57:57.850
比方说上传另外一个文件

57:58.570 --> 57:59.050
这个文件

58:04.560 --> 58:05.680
这个文件我没有上传过

58:06.400 --> 58:07.040
你看这边

58:08.320 --> 58:09.040
服务器告诉我

58:09.040 --> 58:10.560
哇 你还需要这么多

58:10.560 --> 58:13.680
你看还有268个分线都需要上传

58:13.680 --> 58:14.800
那么他就进入这个判断

58:15.760 --> 58:16.880
把这个例子得到

58:16.880 --> 58:20.160
得到就是服务器的响应结果

58:20.160 --> 58:20.640
这个数组

58:21.840 --> 58:24.160
整个的数组给这个变量

58:24.160 --> 58:27.280
表示还有这么多东西都需要上传

58:27.280 --> 58:28.560
那么设置一下函度条

58:29.520 --> 58:30.240
设置一下安留

58:31.600 --> 58:33.600
好 接下来真正上传是在这里

58:33.600 --> 58:34.720
点击安留的时候

58:35.440 --> 58:36.160
什么时候上传

58:37.520 --> 58:37.920
在这

58:41.120 --> 58:42.800
如果说目前正在上传的话

58:42.800 --> 58:45.200
就啥也别就点击就是暂停

58:45.200 --> 58:46.720
对 就暂停就完事了

58:48.400 --> 58:50.480
如果说他目前

58:53.290 --> 58:54.090
目前是暂停

58:54.090 --> 58:55.690
或者是目前刚刚选择的文件

58:55.690 --> 58:56.730
那么再点的时候

58:56.730 --> 58:57.850
这个安留不同的状态

58:57.850 --> 58:58.730
他点的时候

58:58.730 --> 58:59.850
那个效果是不一样的

59:00.570 --> 59:01.930
这些都是小事

59:01.930 --> 59:02.490
关键是这个

59:03.050 --> 59:04.970
整个上传是通过这个函数完成的

59:05.530 --> 59:06.890
它是上传一个分辨

59:07.930 --> 59:09.130
上传一个分辨

59:09.130 --> 59:10.090
上传一个分辨

59:10.090 --> 59:11.130
然后再上传下一个

59:11.690 --> 59:12.650
首先看一下

59:12.650 --> 59:14.410
还有没有分辨需要上传

59:14.410 --> 59:15.370
我们刚才的例子

59:15.370 --> 59:15.690
对吧

59:15.690 --> 59:16.890
还需要哪些分辨

59:16.890 --> 59:18.250
如果说没有分辨需要上传了

59:18.250 --> 59:19.050
它就结束

59:19.050 --> 59:20.330
或者说如果分

59:20.330 --> 59:21.370
这个变量有值

59:21.370 --> 59:22.330
但是它长度有点

59:22.330 --> 59:24.090
是不是也是没有分辨上传了

59:24.090 --> 59:25.290
没有分辨上传了

59:25.290 --> 59:26.570
表示什么上传完成了

59:26.570 --> 59:27.610
我设置一下

59:27.610 --> 59:29.130
这些访问链接就完事了

59:30.010 --> 59:31.530
好 关键是有分辨上传

59:31.530 --> 59:32.330
我看关键代吧

59:33.530 --> 59:34.410
有分辨上传的话

59:35.130 --> 59:36.810
你不是需要很多的分辨吗

59:36.810 --> 59:37.850
哪些分辨需要上传

59:37.850 --> 59:38.650
我就取第一个

59:39.770 --> 59:40.410
取第一个

59:40.410 --> 59:43.450
得到下一个需要上传的分辨的ID

59:43.450 --> 59:46.170
然后从我们之前这个数组里边

59:48.410 --> 59:49.370
看不到了

59:49.370 --> 59:50.250
就是这个FileInfo

59:51.450 --> 59:52.490
得到那个数组

59:52.490 --> 59:54.890
文件分辨信息这个数组里边

59:54.890 --> 59:59.050
是不是拿到对应的分辨的内容

59:59.050 --> 59:59.850
二镜子内容

59:59.850 --> 01:00:00.810
然后通过FileData

01:00:02.090 --> 01:00:03.130
添加三个属性

01:00:03.130 --> 01:00:03.690
一个是File

01:00:03.690 --> 01:00:04.170
二镜子

01:00:05.130 --> 01:00:05.770
创可ID

01:00:06.330 --> 01:00:06.890
就这个ID

01:00:06.890 --> 01:00:07.130
对吧

01:00:07.130 --> 01:00:08.250
下个分辨的ID

01:00:08.250 --> 01:00:09.290
然后文件的ID

01:00:09.850 --> 01:00:11.290
那么在这里边记录了

01:00:11.290 --> 01:00:12.650
然后请求就完事了

01:00:13.370 --> 01:00:13.770
好了吧

01:00:13.770 --> 01:00:14.570
服务机会高处里

01:00:14.570 --> 01:00:16.010
剩下还需要哪些分辨

01:00:16.010 --> 01:00:17.610
所以说把这个变量更新

01:00:18.490 --> 01:00:19.050
然后呢

01:00:19.050 --> 01:00:20.410
更新我们的更精度调

01:00:21.690 --> 01:00:22.170
接下来

01:00:22.970 --> 01:00:24.570
继续第一规调用

01:00:25.850 --> 01:00:26.970
上传下一个分辨

01:00:29.370 --> 01:00:30.250
当然潜力条件的

01:00:30.250 --> 01:00:31.610
有一个条件就限制就是

01:00:31.610 --> 01:00:33.130
如果说现在正在上传

01:00:33.210 --> 01:00:34.330
不是正在上传的话

01:00:34.330 --> 01:00:35.370
比方说目前暂停了

01:00:35.370 --> 01:00:36.090
那就算了

01:00:36.090 --> 01:00:37.370
就不上传了

01:00:37.370 --> 01:00:38.090
于是呢

01:00:38.090 --> 01:00:40.730
就会看到一个分辨接着一个分辨

01:00:40.730 --> 01:00:41.130
上传

01:00:42.650 --> 01:00:43.210
可以暂停

01:00:44.330 --> 01:00:45.370
也可以继续

01:00:45.370 --> 01:00:46.410
关掉了之后呢

01:00:46.410 --> 01:00:47.610
服务机那边你看服务机的

01:00:47.610 --> 01:00:49.370
我这边服务机做的非常非常粗暴

01:00:50.170 --> 01:00:51.770
你看服务机有很多的零食文件

01:00:53.610 --> 01:00:55.770
当这些上传完成之后

01:00:55.770 --> 01:00:58.170
服务机会把这些零食文件全部给它干掉

01:00:58.170 --> 01:00:59.770
把它合并成一个完整的文件

01:01:04.700 --> 01:01:05.420
上传完成

01:01:05.420 --> 01:01:06.460
你看这些都没了

01:01:06.540 --> 01:01:06.860
对吧

01:01:06.860 --> 01:01:07.260
就没了

01:01:08.700 --> 01:01:09.020
在这

01:01:11.020 --> 01:01:12.620
这就是整个过程

01:01:12.620 --> 01:01:13.580
是不是感觉有点

01:01:14.460 --> 01:01:14.940
复杂

01:01:14.940 --> 01:01:16.700
所以说这一块那种本身也

01:01:17.180 --> 01:01:17.980
就是个扩展那种

01:01:18.700 --> 01:01:19.740
最后我说一点

01:01:20.460 --> 01:01:21.500
这一块面

01:01:21.740 --> 01:01:23.580
最重要的是面试的时候

01:01:24.300 --> 01:01:25.500
它会如果说问你

01:01:25.820 --> 01:01:26.700
端点去传

01:01:26.700 --> 01:01:27.500
你该怎么回答

01:01:28.140 --> 01:01:29.500
你不要去该回答这些代码

01:01:29.500 --> 01:01:30.380
没这么意义的

01:01:30.380 --> 01:01:31.180
原理

01:01:31.180 --> 01:01:32.300
回答原理就可以了

01:01:33.180 --> 01:01:34.940
第一个端点下传

01:01:36.540 --> 01:01:37.420
怎么实现的

01:01:38.780 --> 01:01:40.780
服务机的客户端小英的是什么消息头

01:01:41.580 --> 01:01:43.340
客户端给服务机请求的时候

01:01:43.340 --> 01:01:44.380
有添加什么消息头

01:01:44.380 --> 01:01:45.420
它整个流程是什么

01:01:45.820 --> 01:01:46.700
黑的请求

01:01:46.700 --> 01:01:48.460
然后一段一段请求数据

01:01:48.460 --> 01:01:49.740
然后在客户端组装

01:01:50.380 --> 01:01:50.940
这下展

01:01:51.820 --> 01:01:54.620
上传需要在客户端把这个数据分辨

01:01:54.620 --> 01:01:57.100
但分辨也可以用各种各样的规则来进行分辨

01:01:58.060 --> 01:01:58.940
分辨完了过后

01:01:59.980 --> 01:02:01.900
生成每一个分辨的MD5

01:02:02.620 --> 01:02:03.980
和文件的MD5

01:02:03.980 --> 01:02:05.900
把这些信息全部告诉服务机

01:02:06.540 --> 01:02:08.460
服务机它要回馈给我

01:02:09.020 --> 01:02:10.780
你还需要上传哪些分辨

01:02:11.340 --> 01:02:12.860
那么我根据服务机的想用

01:02:13.100 --> 01:02:15.420
来决定剩下分辨的上传

01:02:15.980 --> 01:02:17.340
直到服务机有天告诉我

01:02:17.340 --> 01:02:18.620
你没有分辨需要上传了

01:02:18.620 --> 01:02:20.940
那么表示这个文件上传完成

01:02:20.940 --> 01:02:22.300
就是它基本的逻辑

01:02:22.300 --> 01:02:24.540
把这个逻辑回答到那就OK了

01:02:25.020 --> 01:02:27.740
要相信很多同学都回答不出来这个问题了

01:02:28.300 --> 01:02:28.940
而且这个问题

01:02:28.940 --> 01:02:30.700
其实问到的机论也不是很大

01:02:31.500 --> 01:02:35.500
因此这个客作为一个选修客

01:02:35.660 --> 01:02:37.340
你们自己决定要不要看

01:02:38.060 --> 01:02:39.820
OK这是关于这个端点叙传

