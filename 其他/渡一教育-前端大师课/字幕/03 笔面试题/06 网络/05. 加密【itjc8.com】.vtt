WEBVTT

00:00.000 --> 00:02.560
好 来聊一聊这个加密

00:02.560 --> 00:08.000
加密它本身并不是网络这一块的知识

00:08.000 --> 00:11.000
它是计算机密码学的知识

00:11.000 --> 00:14.000
这一块我们不会聊得很深

00:14.000 --> 00:17.000
就聊一下密码学那边一些常识性的东西

00:17.000 --> 00:20.000
聊生了过后又是一枚学科了

00:20.000 --> 00:24.000
它都不是一本课程的事情了

00:24.000 --> 00:28.000
加密 为什么要加密呢

00:28.000 --> 00:31.000
它首先跟网络本身没有什么个联系

00:31.000 --> 00:35.000
只是在网络的应用过程中可能会用到一些加密的东西

00:35.000 --> 00:38.000
所以我们把这个加密单独来讲一讲

00:38.000 --> 00:39.000
几分钟的时间

00:39.000 --> 00:42.000
我们这里讲一讲加密的分类

00:42.000 --> 00:45.000
首先加密的它本身面试体可能会考虑

00:45.000 --> 00:47.000
它就会问你一些分类的

00:47.000 --> 00:48.000
它问的也不会太深

00:48.000 --> 00:50.000
它就问你加密的分类

00:50.000 --> 00:52.000
你回答出这么三个东西就行了

00:52.000 --> 00:55.000
一个是对称加密 一个是非对称 一个是摘要

00:55.000 --> 00:57.000
我们的一个来说 首先是对称加密

00:57.000 --> 00:59.000
对称加密它是这么一种想象

00:59.000 --> 01:02.000
我们把没有加密的那种叫做明文

01:02.000 --> 01:05.000
当然这个明文可以是一个文本

01:05.000 --> 01:07.000
也可以是一个数字

01:07.000 --> 01:08.000
也可以是一个视频

01:08.000 --> 01:10.000
也可以是一个音品无所谓

01:10.000 --> 01:12.000
反正就是明文 原文

01:12.000 --> 01:16.000
然后我们把加密之后的东西叫做密文

01:16.000 --> 01:17.000
密文它就看不懂了

01:17.000 --> 01:19.000
它不知道那啥意思

01:19.000 --> 01:20.000
对称加密是什么意思呢

01:20.000 --> 01:21.000
它要准备一个密钥

01:21.000 --> 01:23.000
这个密钥是什么东西呢

01:23.000 --> 01:25.000
其实就是一个制服串

01:25.000 --> 01:27.000
其实本质上就是一个二进字

01:27.000 --> 01:30.000
那么这个密钥有什么用呢

01:30.000 --> 01:32.000
它就是用来加密和解密的

01:32.000 --> 01:37.000
你把原识内容变成密文需要一个密钥

01:37.000 --> 01:39.000
然后配合一定的算法

01:39.000 --> 01:41.000
就把它原文变成密文了

01:41.000 --> 01:43.000
然后解密的时候

01:43.000 --> 01:46.000
你要使用同一个钥匙 同一个密钥

01:46.000 --> 01:49.000
然后通过相同的解密算法

01:49.000 --> 01:52.000
每个算法它都有加密算法和解密算法

01:52.000 --> 01:54.000
那么它是对应的

01:54.000 --> 01:57.000
通过对应的解密算法加上密钥变成密文

01:57.000 --> 01:59.000
就这么简单

01:59.000 --> 02:01.000
那么常见的这种对称加密的算法

02:01.000 --> 02:03.000
有这么一些

02:03.000 --> 02:05.000
不用去计 一个都不用去计

02:05.000 --> 02:07.000
对这个东西有点影响就可以了

02:07.000 --> 02:09.000
其他都不用去计

02:09.000 --> 02:11.000
然后它的优点在什么呢

02:11.000 --> 02:13.000
它优点是它的效率特别高

02:13.000 --> 02:15.000
特别快

02:15.000 --> 02:17.000
所以它比较适合对一些大的数据量

02:17.000 --> 02:18.000
进行加密解密

02:18.000 --> 02:20.000
现在效率是比较高的

02:20.000 --> 02:22.000
其实任何的加密算法

02:22.000 --> 02:23.000
这里边任何加密算法

02:23.000 --> 02:25.000
对效率都是有损失的

02:25.000 --> 02:27.000
不要认为加密安全

02:27.000 --> 02:29.000
我到处都要去加密

02:29.000 --> 02:30.000
没意义的

02:30.000 --> 02:32.000
有些地方加密以后我再说吧

02:32.000 --> 02:34.000
前端加密是没有什么意义的

02:36.000 --> 02:38.000
加密它会带来效率的损失

02:38.000 --> 02:40.000
它是相当于是CPU密集型

02:42.000 --> 02:44.000
CPU密集型

02:44.000 --> 02:46.000
就计算密集型

02:46.000 --> 02:48.000
它特别消耗CPU

02:49.000 --> 02:51.000
它的缺陷也比较明显

02:51.000 --> 02:52.000
它的缺陷就是

02:52.000 --> 02:54.000
因为我加密和解密使用的是

02:54.000 --> 02:55.000
同一个密钥

02:55.000 --> 02:57.000
那么这个时候就遇到一个问题

02:57.000 --> 02:59.000
在实际应用中就遇到一个问题

02:59.000 --> 03:01.000
比方说我们

03:01.000 --> 03:03.000
有一个服务器

03:03.000 --> 03:05.000
有一个客户端

03:05.000 --> 03:07.000
服务器有一个内容想传给客户端

03:08.000 --> 03:09.000
假设

03:09.000 --> 03:11.000
服务器有一个内容想传给客户端

03:11.000 --> 03:13.000
但是它觉得传输的过程中

03:13.000 --> 03:15.000
容易被第三方获取

03:15.000 --> 03:17.000
有些重要的消息

03:17.000 --> 03:18.000
比如说

03:18.000 --> 03:20.000
或者说

03:20.000 --> 03:21.000
就服务器

03:21.000 --> 03:23.000
像传输的客户端有些重要的消息

03:23.000 --> 03:24.000
可能会被第三方获取

03:24.000 --> 03:25.000
在传输的中途

03:25.000 --> 03:27.000
可能会被别人拿到

03:27.000 --> 03:28.000
所以说

03:28.000 --> 03:29.000
它就不想用名文传输

03:29.000 --> 03:31.000
它可能想用密文来传输

03:31.000 --> 03:32.000
那密文传输

03:32.000 --> 03:33.000
它就要选一个加密算法

03:33.000 --> 03:35.000
比方说它选择对成加密

03:35.000 --> 03:36.000
于是

03:36.000 --> 03:38.000
它就服务器生成了一个密钥

03:41.000 --> 03:43.000
然后它选了一个加密算法

03:43.000 --> 03:45.000
比如说DES吧

03:45.000 --> 03:46.000
于是这个名文

03:46.000 --> 03:47.000
加上这个密钥

03:47.000 --> 03:48.000
加上这个算法

03:48.000 --> 03:49.000
就生成一个密文

03:51.000 --> 03:53.000
好那么它把密文传给客户端

03:53.000 --> 03:54.000
那么客户端是不是拿到密文了

03:54.000 --> 03:56.000
这个时候客户端是一脸梦逼

03:57.000 --> 03:58.000
我干嘛呀

03:58.000 --> 03:59.000
我在哪

03:59.000 --> 04:01.000
拿这个密文干嘛呀

04:01.000 --> 04:02.000
它要解密呀

04:02.000 --> 04:03.000
它解不了密

04:03.000 --> 04:04.000
为什么呢

04:04.000 --> 04:05.000
就算它知道

04:05.000 --> 04:06.000
服务器商量好了

04:06.000 --> 04:08.000
他们就用DES来

04:09.000 --> 04:10.000
加密解密

04:10.000 --> 04:12.000
那么它算法知道DES

04:12.000 --> 04:13.000
但是它没有密钥

04:13.000 --> 04:14.000
它没有密钥

04:14.000 --> 04:15.000
它就解不了这个密

04:15.000 --> 04:17.000
所以说服务器没办法

04:17.000 --> 04:18.000
它生成密钥过

04:18.000 --> 04:20.000
它是不是得把密钥也发给客户端

04:20.000 --> 04:22.000
那问题就解决

04:22.000 --> 04:23.000
这个没法解决了

04:23.000 --> 04:25.000
因为服务器

04:25.000 --> 04:28.000
就是因为担心中途被别人祸取掉

04:28.000 --> 04:29.000
到数据

04:29.000 --> 04:31.000
所以说它才要加密

04:31.000 --> 04:33.000
但是你把密钥也传给客户端

04:33.000 --> 04:34.000
但是传的时候

04:34.000 --> 04:35.000
是不是传的

04:35.000 --> 04:36.000
要传两个东西

04:36.000 --> 04:40.000
一个是密文本身

04:40.000 --> 04:41.000
一个是密钥

04:41.000 --> 04:42.000
都要传过去

04:43.000 --> 04:44.000
都要传过去

04:44.000 --> 04:45.000
那这个玩意

04:45.000 --> 04:47.000
还是容易被第三方祸取

04:47.000 --> 04:48.000
对不对

04:48.000 --> 04:50.000
所以说这个地方就搞不定了

04:50.000 --> 04:51.000
它就搞不定了

04:51.000 --> 04:53.000
那么如果说传了密钥

04:53.000 --> 04:54.000
当然它这边可以解密

04:54.000 --> 04:56.000
它可以通过这个密钥

04:56.000 --> 04:59.000
然后就可以得到这个密文了

04:59.000 --> 05:00.000
知道吧

05:00.000 --> 05:01.000
会得到这个AA了

05:01.000 --> 05:03.000
但是它这个密钥传说的

05:03.000 --> 05:04.000
就容易被第三方祸取

05:04.000 --> 05:06.000
所以它安全性是一个问题

05:06.000 --> 05:07.000
它有没有用

05:07.000 --> 05:08.000
它有用

05:08.000 --> 05:09.000
它配合一些别的方式

05:09.000 --> 05:11.000
来解决这个问题

05:11.000 --> 05:12.000
但是它本身

05:12.000 --> 05:13.000
是有这个安全性问题的

05:13.000 --> 05:14.000
再说一下

05:14.000 --> 05:15.000
对称加密

05:15.000 --> 05:17.000
非准称加密

05:17.000 --> 05:18.000
它就是主要是

05:18.000 --> 05:20.000
就为了解决这个问题

05:20.000 --> 05:21.000
它是做什么事呢

05:21.000 --> 05:23.000
它是有两个密钥

05:23.000 --> 05:24.000
一个是公钥

05:24.000 --> 05:26.000
一个是私钥

05:26.000 --> 05:28.000
加密的时候

05:28.000 --> 05:30.000
它是用公钥进行加密

05:30.000 --> 05:31.000
解密的时候

05:31.000 --> 05:32.000
用私钥进行解密

05:32.000 --> 05:33.000
这两个是一段

05:33.000 --> 05:34.000
天生一段

05:34.000 --> 05:35.000
就像配锁的时候

05:35.000 --> 05:36.000
一把锁一个钥匙

05:36.000 --> 05:38.000
天生一段

05:38.000 --> 05:39.000
所以说

05:39.000 --> 05:41.000
如果说你实质更改一个公钥

05:41.000 --> 05:42.000
和实质更改一个私钥

05:42.000 --> 05:43.000
那么他们对不上

05:43.000 --> 05:44.000
就出问题了

05:44.000 --> 05:45.000
就简单说一下

05:45.000 --> 05:46.000
然后

05:46.000 --> 05:48.000
那么它用这种加密方式

05:48.000 --> 05:50.000
它常常的方法有这么一些

05:50.000 --> 05:51.000
不用具体

05:51.000 --> 05:53.000
你对这个问题有点影响就行了

05:54.000 --> 05:56.000
总之它用这种加密方式

05:56.000 --> 05:57.000
它的特点就变成安全了

05:57.000 --> 05:58.000
为什么变得安全呢

05:58.000 --> 05:59.000
我们来再来

05:59.000 --> 06:00.000
回顾一下这个场景

06:01.000 --> 06:02.000
比方说服务器

06:02.000 --> 06:03.000
它怎么做呢

06:03.000 --> 06:05.000
它可以用

06:05.000 --> 06:06.000
它这个地方

06:06.000 --> 06:07.000
它就不用对称加密的

06:07.000 --> 06:08.000
它用非准称加密

06:08.000 --> 06:10.000
比方说RSA算法

06:10.000 --> 06:11.000
那么加密的时候

06:11.000 --> 06:13.000
它生成一个公钥和私钥

06:13.000 --> 06:14.000
服务器那边

06:14.000 --> 06:17.000
一个公钥和私钥

06:17.000 --> 06:19.000
私钥只有服务器有

06:19.000 --> 06:21.000
永远不会把私钥

06:21.000 --> 06:22.000
在网络上传输

06:22.000 --> 06:23.000
永远不会

06:23.000 --> 06:24.000
所以说它私钥

06:24.000 --> 06:25.000
永远在服务器上

06:25.000 --> 06:27.000
它就不容易被第三方获取

06:27.000 --> 06:28.000
因为它说

06:28.000 --> 06:29.000
它贡献了服务器怎么办

06:29.000 --> 06:30.000
那就没招了

06:30.000 --> 06:31.000
那就没招了

06:31.000 --> 06:32.000
服务器都被贡献了

06:32.000 --> 06:34.000
那里就完蛋了

06:34.000 --> 06:35.000
所以说

06:35.000 --> 06:37.000
不用去考虑这个时候

06:37.000 --> 06:38.000
你可以报警了

06:38.000 --> 06:40.000
私钥它不会用于网络发送

06:40.000 --> 06:41.000
那么它用什么加密呢

06:41.000 --> 06:42.000
用公钥加密

06:42.000 --> 06:45.000
这公钥是可以发到其他地方的

06:45.000 --> 06:47.000
那么得到一个密闻

06:47.000 --> 06:48.000
然后呢

06:48.000 --> 06:51.000
它把这个公钥和密闻的

06:51.000 --> 06:53.000
都会发给这个客户端

06:53.000 --> 06:55.000
客户端能拿到这个公钥和密闻过

06:55.000 --> 06:56.000
它能解密吗

06:56.000 --> 06:57.000
不好意思

06:57.000 --> 06:58.000
它不能解密

06:58.000 --> 06:59.000
为什么呢

06:59.000 --> 07:00.000
因为解密需要私钥

07:00.000 --> 07:02.000
它知道算法

07:02.000 --> 07:03.000
知道密闻

07:03.000 --> 07:04.000
它知道公钥

07:04.000 --> 07:06.000
但是它不能用来解密

07:06.000 --> 07:07.000
它只能用来加密

07:07.000 --> 07:08.000
它又可以

07:08.000 --> 07:10.000
比方说客户端以后再发消息给服务器

07:10.000 --> 07:12.000
它可以用公钥加密

07:12.000 --> 07:13.000
懂了意思吗

07:13.000 --> 07:15.000
它可以用公钥加密给服务器发

07:15.000 --> 07:17.000
那么它只能说单向的

07:17.000 --> 07:18.000
就是服务器给它发的密闻力

07:18.000 --> 07:19.000
解不了密

07:19.000 --> 07:20.000
但是呢

07:20.000 --> 07:21.000
服务器呢给你发的

07:21.000 --> 07:23.000
它会把公钥给

07:23.000 --> 07:25.000
那么就这个消息就反过来了

07:25.000 --> 07:27.000
服务器的公钥给客户端

07:27.000 --> 07:28.000
那么客户端比方说

07:28.000 --> 07:29.000
发个消息

07:29.000 --> 07:30.000
发到服务器

07:30.000 --> 07:31.000
那么它就可以用这种方式

07:31.000 --> 07:34.000
加上一个公钥来加密

07:35.000 --> 07:36.000
公钥加密

07:36.000 --> 07:38.000
得到一个密闻

07:38.000 --> 07:40.000
然后服务器那边

07:40.000 --> 07:42.000
收到密闻

07:42.000 --> 07:43.000
它知道算法

07:43.000 --> 07:44.000
ISA

07:44.000 --> 07:46.000
然后使用什么解密的

07:46.000 --> 07:48.000
使用施药来解密

07:50.000 --> 07:51.000
就是密闻

07:51.000 --> 07:52.000
它可以用这种

07:52.000 --> 07:54.000
它是用这种方式的

07:55.000 --> 07:56.000
客户端这边加密

07:56.000 --> 07:58.000
服务器那边解密

07:58.000 --> 07:59.000
用这种方式

07:59.000 --> 08:00.000
比方说你要

08:00.000 --> 08:01.000
什么账号密码

08:01.000 --> 08:02.000
发到服务器

08:02.000 --> 08:03.000
那么账号密码

08:03.000 --> 08:04.000
那么账号密码

08:04.000 --> 08:06.000
可能害怕被中间人获取

08:06.000 --> 08:08.000
我们把称之为中间人攻击

08:08.000 --> 08:10.000
在网络中可能被别人获取

08:10.000 --> 08:12.000
那么你可以使用这种方式

08:12.000 --> 08:14.000
用服务器给的公钥来进行加密

08:14.000 --> 08:16.000
服务器那边解密

08:16.000 --> 08:17.000
中间能不能

08:17.000 --> 08:18.000
你看这个密闻

08:18.000 --> 08:19.000
发到网络上了

08:19.000 --> 08:21.000
网络上能不能获取

08:21.000 --> 08:22.000
到这个密闻的能

08:22.000 --> 08:23.000
能不能获取到公钥

08:23.000 --> 08:25.000
能不能知道算法

08:25.000 --> 08:26.000
猜一猜一

08:26.000 --> 08:27.000
可能会猜得到

08:27.000 --> 08:28.000
多试几个算法

08:28.000 --> 08:29.000
也可以试得出来

08:29.000 --> 08:30.000
但是

08:30.000 --> 08:31.000
它拿到公钥没用

08:31.000 --> 08:32.000
拿到密闻没用

08:32.000 --> 08:33.000
拿到算法没用

08:33.000 --> 08:34.000
因为它没有试药

08:34.000 --> 08:36.000
试药只有服务器有

08:36.000 --> 08:38.000
所以只有服务器能解密

08:38.000 --> 08:39.000
因此它的特点是安全

08:39.000 --> 08:41.000
但是缺点也很明显

08:41.000 --> 08:43.000
就是它只能一方进行解密

08:43.000 --> 08:45.000
永远只有服务器能解密

08:45.000 --> 08:47.000
那个客户端解不了密的

08:47.000 --> 08:49.000
所以就这么一个情况

08:49.000 --> 08:50.000
当然这些东西

08:50.000 --> 08:52.000
我们一般在应用场景里面

08:52.000 --> 08:53.000
可能会都会应用

08:53.000 --> 08:54.000
对 而对成加密

08:54.000 --> 08:56.000
和非证判都会同时应用

08:56.000 --> 08:57.000
来解决这些问题

08:57.000 --> 08:58.000
我们之后再说

08:58.000 --> 08:59.000
我们现在就把

08:59.000 --> 09:00.000
每一个加密算法

09:00.000 --> 09:01.000
认识一下就行了

09:01.000 --> 09:03.000
这是非对成加密

09:03.000 --> 09:04.000
然后接下来

09:04.000 --> 09:06.000
一个比较重要的加密算法

09:06.000 --> 09:08.000
叫做摘药 哈希 闪烈

09:08.000 --> 09:10.000
都是它 都有一个意思

09:10.000 --> 09:11.000
那么这个玩意是什么呢

09:11.000 --> 09:13.000
这个玩意大家接触过

09:13.000 --> 09:14.000
我们来看一下吧

09:14.000 --> 09:15.000
这个算法

09:15.000 --> 09:16.000
它是什么意思呢

09:16.000 --> 09:17.000
它都没有密药了

09:17.000 --> 09:18.000
密药都没有了

09:18.000 --> 09:19.000
公钥也没有 试药也没有

09:19.000 --> 09:21.000
跟没有什么对成加密的密药

09:21.000 --> 09:22.000
这都没有

09:22.000 --> 09:23.000
它就是一个算法

09:23.000 --> 09:24.000
这个算法全世界都知道

09:24.000 --> 09:25.000
我就是知道

09:25.000 --> 09:26.000
利用什么样的算法

09:26.000 --> 09:27.000
生存了密闻

09:27.000 --> 09:28.000
也没有什么密药

09:28.000 --> 09:30.000
但是我就是解不开

09:30.000 --> 09:31.000
就是这么一个回事

09:31.000 --> 09:32.000
它就是把明文

09:32.000 --> 09:34.000
通过一个算法生存密闻

09:34.000 --> 09:35.000
那么常见的算法

09:35.000 --> 09:39.000
就MD4、MD5、SHA1、SHA1

09:39.000 --> 09:40.000
那么这种算法

09:40.000 --> 09:41.000
它有一个特点

09:41.000 --> 09:43.000
有点是密闻占用空间

09:43.000 --> 09:44.000
特别小

09:44.000 --> 09:45.000
这啥意思呢

09:45.000 --> 09:46.000
就是你这一块

09:46.000 --> 09:48.000
无论是一个50G的

09:48.000 --> 09:50.000
高清电影

09:50.000 --> 09:52.000
还是一个只有

09:52.000 --> 09:55.000
一个制服的0

09:55.000 --> 09:56.000
它生存的密闻

09:56.000 --> 09:58.000
长度是一定的

09:58.000 --> 10:00.000
那么要看不同的算法了

10:00.000 --> 10:04.000
比方说它生存32位的6G

10:04.000 --> 10:06.000
16G

10:06.000 --> 10:08.000
一般都是用16G在表示的

10:08.000 --> 10:12.000
然后你就写个32位的16G

10:12.000 --> 10:13.000
然后它就

10:13.000 --> 10:14.000
不知道是不是32位

10:14.000 --> 10:16.000
就这么个意思

10:16.000 --> 10:19.000
你50G出来是这么一个长度

10:19.000 --> 10:20.000
你一个制服

10:20.000 --> 10:22.000
出来也是这么一个长度

10:22.000 --> 10:23.000
它是定长的

10:23.000 --> 10:25.000
它有这么一个特点

10:25.000 --> 10:26.000
然后它定的特点

10:26.000 --> 10:27.000
就是难以被破解

10:27.000 --> 10:29.000
你拿到这个密闻之后

10:29.000 --> 10:30.000
你要还原

10:30.000 --> 10:31.000
不好意思

10:31.000 --> 10:32.000
你永远还不了原

10:32.000 --> 10:34.000
理论上是可以的

10:34.000 --> 10:35.000
但是理论上了

10:35.000 --> 10:36.000
那是理论上

10:36.000 --> 10:38.000
实际上也不太可能的

10:38.000 --> 10:40.000
将来量子计算机出来之后

10:40.000 --> 10:42.000
这个事可以被还原

10:42.000 --> 10:45.000
它是能够解决

10:45.000 --> 10:48.000
能够做运算还原的

10:48.000 --> 10:49.000
但是如果说

10:49.000 --> 10:51.000
我们上普通计算机

10:51.000 --> 10:52.000
当时以后

10:52.000 --> 10:53.000
可能也算法叫升级了

10:53.000 --> 10:55.000
像我们普通计算机的话

10:55.000 --> 10:56.000
要还原这个东西

10:57.000 --> 10:59.000
少说几百万年吧

10:59.000 --> 11:00.000
可以还原

11:00.000 --> 11:02.000
理论上数学上是可以还原的

11:02.000 --> 11:04.000
但是基本上是不太可能的

11:04.000 --> 11:05.000
所以说我们认为

11:05.000 --> 11:06.000
它难以被破解

11:06.000 --> 11:07.000
像我们网络上

11:07.000 --> 11:09.000
有一些什么在线哈希解密

11:09.000 --> 11:11.000
它是怎么破解的呢

11:11.000 --> 11:13.000
它是用暴力破解法

11:13.000 --> 11:14.000
什么意思呢

11:14.000 --> 11:15.000
比方说

11:15.000 --> 11:19.000
在哈希这种解密算法里边

11:19.000 --> 11:20.000
它有这么一个特点

11:20.000 --> 11:22.000
只要你的明文内容不变

11:22.000 --> 11:24.000
立文内容是一定的

11:24.000 --> 11:25.000
比方说

11:25.000 --> 11:27.000
一个字符E

11:27.000 --> 11:28.000
它加密出来是这个样子

11:28.000 --> 11:30.000
那下一次你再加密这个字符E

11:30.000 --> 11:31.000
它还是这个样子

11:31.000 --> 11:32.000
懂的意思吧

11:32.000 --> 11:33.000
那么它怎么破解呢

11:33.000 --> 11:34.000
暴力破解

11:34.000 --> 11:36.000
先看一下A的加密出来是啥

11:36.000 --> 11:38.000
然后再看B加密出来是啥

11:38.000 --> 11:39.000
C加密出来是啥

11:39.000 --> 11:40.000
对吧

11:40.000 --> 11:42.000
然后呢去对给你的个密

11:42.000 --> 11:43.000
传入的密文去对

11:43.000 --> 11:44.000
对啥对得上

11:44.000 --> 11:45.000
那我就知道

11:45.000 --> 11:46.000
这个玩意儿是E

11:46.000 --> 11:47.000
因为我知道E加密出来

11:47.000 --> 11:48.000
就是这个样子

11:48.000 --> 11:49.000
它是不变的

11:49.000 --> 11:50.000
只要算法一定

11:50.000 --> 11:51.000
那么这个东西

11:51.000 --> 11:52.000
得到的结果是不变的

11:52.000 --> 11:53.000
永远不会变化的

11:53.000 --> 11:54.000
这个意思

11:54.000 --> 11:55.000
它是用暴力破解解密的

11:55.000 --> 11:57.000
但这种解密方式

11:57.000 --> 11:58.000
它有个很大的数据库

11:58.000 --> 12:00.000
存了各种常见的

12:00.000 --> 12:01.000
这些字符加密

12:01.000 --> 12:03.000
通过哈西加密出来的

12:03.000 --> 12:04.000
这个结果

12:04.000 --> 12:06.000
然后从数据库里面去比对

12:06.000 --> 12:07.000
如果说比对不上

12:07.000 --> 12:08.000
那不好意思

12:08.000 --> 12:09.000
那可能需要

12:09.000 --> 12:10.000
那可能要继续暴力破解

12:10.000 --> 12:11.000
那可能

12:11.000 --> 12:12.000
需要几天

12:12.000 --> 12:13.000
几年

12:13.000 --> 12:14.000
甚至几百万年的时间

12:14.000 --> 12:15.000
那就说不准了

12:15.000 --> 12:16.000
看它运气了

12:17.000 --> 12:19.000
这就是这么一个东西

12:19.000 --> 12:20.000
难以被破解

12:20.000 --> 12:21.000
我们几乎认为

12:21.000 --> 12:23.000
它认为它没发对破解

12:23.000 --> 12:24.000
它缺点是什么呢

12:24.000 --> 12:25.000
缺点就是

12:25.000 --> 12:26.000
难以被破解

12:26.000 --> 12:27.000
因为它解不了密

12:27.000 --> 12:29.000
你只知道密文是啥

12:29.000 --> 12:30.000
它是还原不了名文

12:30.000 --> 12:32.000
那这个玩意儿有什么用的

12:32.000 --> 12:33.000
这个玩意儿

12:33.000 --> 12:34.000
这个用处太多了

12:34.000 --> 12:35.000
第一个对密码

12:35.000 --> 12:37.000
对用户密码

12:37.000 --> 12:39.000
使用哈西加密

12:40.000 --> 12:41.000
比方说你用户的密码

12:41.000 --> 12:42.000
是123123

12:42.000 --> 12:43.000
那哈西加密出来

12:43.000 --> 12:45.000
就是一个很长的东西

12:45.000 --> 12:46.000
那么这个

12:46.000 --> 12:48.000
为什么要对这个密码加密呢

12:49.000 --> 12:50.000
这个玩意儿

12:50.000 --> 12:51.000
能到后端的数据库

12:51.000 --> 12:52.000
这一般是后端来做

12:52.000 --> 12:53.000
你们倒是

12:53.000 --> 12:54.000
不用太去关心这个事

12:55.000 --> 12:56.000
有些公司呢

12:56.000 --> 12:57.000
他要求你前端用

12:57.000 --> 12:58.000
MD5加密过后

12:59.000 --> 13:01.000
来把加密成这个样子

13:01.000 --> 13:02.000
其实要前端加密的话

13:02.000 --> 13:03.000
也很简单

13:03.000 --> 13:04.000
我给他写一个吧

13:05.000 --> 13:06.000
像加密也很简单

13:07.000 --> 13:08.000
比方说我们这里呢

13:10.000 --> 13:11.000
就来一个吧

13:11.000 --> 13:17.020
毛90

13:18.020 --> 13:19.020
去掉

13:19.020 --> 13:20.020
然后我们这边

13:26.410 --> 13:33.370
然后我们安装一个

13:33.370 --> 13:34.370
安装一个包号

13:41.160 --> 13:42.160
npmimd5

13:43.160 --> 13:49.380
有这么卡吗

13:50.380 --> 13:53.390
好了

13:53.390 --> 13:54.390
我们这里写一个文件啊

13:55.390 --> 13:59.280
md5require

14:00.280 --> 14:01.280
好就这么简单啊

14:01.280 --> 14:03.280
比方说我用一个字符串啊

14:03.280 --> 14:04.280
名文

14:05.280 --> 14:06.280
arranging

14:06.280 --> 14:07.280
比方说abc

14:07.280 --> 14:08.280
我要把它进行

14:08.280 --> 14:09.280
md5加密

14:09.280 --> 14:10.280
md5arranging

14:11.280 --> 14:16.150
然后加密过后呢

14:16.150 --> 14:18.150
我得到一个result

14:18.150 --> 14:20.150
输出的result

14:20.150 --> 14:21.150
你看就是加密过后的

14:21.150 --> 14:22.150
你看就是加密过后的

14:24.150 --> 14:25.150
这里写错了

14:27.720 --> 14:29.720
就是这么一个定长的字符串

14:29.720 --> 14:30.720
就这么个意思

14:30.720 --> 14:32.720
然后这个无论这个数字

14:32.720 --> 14:33.720
比方说md5

14:33.720 --> 14:34.720
我这个abc没变

14:34.720 --> 14:35.720
你看加密的结果

14:35.720 --> 14:36.720
还是不会有变化的

14:36.720 --> 14:38.720
但是我只要改变一点

14:38.720 --> 14:40.720
那么整个就天翻地覆的变化

14:41.720 --> 14:42.720
对吧

14:42.720 --> 14:43.720
所以说你没有办法

14:43.720 --> 14:44.720
通过这种密文来看出

14:44.720 --> 14:46.720
将那个内容改变了多少

14:46.720 --> 14:47.720
你看不出来的

14:47.720 --> 14:49.720
它有可能改变的特别多

14:49.720 --> 14:51.720
但是呢密文没有多少变化

14:51.720 --> 14:52.720
可能改变了特别小

14:52.720 --> 14:54.720
密文发生了天翻腐敌的变化

14:54.720 --> 14:55.720
所以说你猜不出来的

14:55.720 --> 14:56.720
原文猜不出来的

14:56.720 --> 14:59.720
而且这个无论这个字符串有多长

14:59.720 --> 15:01.720
有可能有50个g

15:01.720 --> 15:02.720
有一个文件那么大

15:02.720 --> 15:03.720
那就没关系

15:03.720 --> 15:05.720
它出来还是这么多

15:05.720 --> 15:06.720
对吧

15:06.720 --> 15:09.720
这就是哈希这么一个算法的特点

15:10.720 --> 15:11.720
那么这个有什么用呢

15:11.720 --> 15:13.720
第一个就是用户密码

15:13.720 --> 15:14.720
你把用户的密码

15:14.720 --> 15:15.720
比方说用户前的密码

15:15.720 --> 15:17.720
你把它进行md5加密之后

15:17.720 --> 15:18.720
也传到服务器

15:18.720 --> 15:19.720
或者是你把密码传过去

15:19.720 --> 15:20.720
服务器那边

15:20.720 --> 15:21.720
把它变成md5

15:21.720 --> 15:22.720
然后存到数据库

15:22.720 --> 15:24.720
就最终数据库里面存这个

15:24.720 --> 15:25.720
这样子有什么好处呢

15:25.720 --> 15:28.720
这样子好处在于就是

15:28.720 --> 15:31.720
哪怕有一天用那个服务器被攻陷了

15:31.720 --> 15:34.720
别人拿到你的数据库了

15:34.720 --> 15:35.720
他仍然看到这个密码

15:35.720 --> 15:36.720
仍然不知道是啥意思

15:36.720 --> 15:37.720
解不了密

15:37.720 --> 15:38.720
对吧

15:38.720 --> 15:40.720
永远拿不到用户的密码

15:40.720 --> 15:42.720
所以说你们看现在网站

15:42.720 --> 15:44.720
网站上你忘记密码

15:44.720 --> 15:46.720
忘记密码他怎么做的

15:46.720 --> 15:48.720
他一般会给你一个权限

15:48.720 --> 15:49.720
验证一下你是不是本人

15:49.720 --> 15:50.720
是本人的话

15:50.720 --> 15:52.720
他网站里去设置新密码

15:52.720 --> 15:53.720
对不对

15:53.720 --> 15:55.720
他绝对不会通过一封邮件

15:55.720 --> 15:57.720
告诉你救密码是啥

15:57.720 --> 15:59.720
如果说他通过一封邮件

15:59.720 --> 16:00.720
告诉你救密码是啥

16:00.720 --> 16:01.720
那这个网站

16:01.720 --> 16:03.720
建议你不要用早点走吧

16:03.720 --> 16:04.720
为什么

16:04.720 --> 16:07.720
因为他是用名文存到数据库的

16:07.720 --> 16:10.720
如果说他知道密码是啥

16:10.720 --> 16:11.720
他知道告诉你

16:11.720 --> 16:12.720
原来的密码是这个

16:12.720 --> 16:14.720
那么他数据库里面存的就是

16:14.720 --> 16:15.720
用密码的名文

16:15.720 --> 16:17.720
一旦有一天他的服务器被攻陷

16:17.720 --> 16:19.720
你那么密码就丢失了

16:19.720 --> 16:20.720
密码丢失

16:20.720 --> 16:21.720
你知道这个问题很严重的

16:21.720 --> 16:22.720
不光是这个网站

16:22.720 --> 16:24.720
因为现在很多用户

16:24.720 --> 16:26.720
别的网站也使用相同的密码

16:26.720 --> 16:28.720
这个问题还是比较严重的

16:28.720 --> 16:30.720
一定要用密文来存存

16:30.720 --> 16:32.720
如果说有些密码忘了

16:32.720 --> 16:33.720
你去打电话找他的客服

16:33.720 --> 16:35.720
那他告诉你密码是啥

16:35.720 --> 16:36.720
他告诉不了你

16:36.720 --> 16:37.720
如果说他能告诉你

16:37.720 --> 16:38.720
你早点走吧

16:38.720 --> 16:40.720
这个地方太危险了

16:40.720 --> 16:42.720
以前发生过一件事

16:42.720 --> 16:44.720
好像就是CSDN

16:44.720 --> 16:46.720
还要拿几个网站

16:46.720 --> 16:49.720
他们的数据库泄漏了

16:49.720 --> 16:51.720
然后导致很多的用户密码被泄漏

16:51.720 --> 16:53.720
就很多人持进这么大的一个公司

16:53.720 --> 16:55.720
居然用名文来保存用户密码

16:55.720 --> 16:56.720
所以说一个用户密码

16:56.720 --> 16:58.720
其实只有用户自己知道

16:58.720 --> 17:00.720
全世界没有第二个人知道

17:00.720 --> 17:01.720
因为保存的时候

17:01.720 --> 17:02.720
是用它来保存的

17:02.720 --> 17:03.720
没有人知道它密码是啥

17:03.720 --> 17:04.720
那又说到这样子

17:04.720 --> 17:06.720
怎么来一验证登陆成功呢

17:06.720 --> 17:07.720
特别简单

17:07.720 --> 17:08.720
你下一次登陆的时候

17:08.720 --> 17:09.720
你输入一个密码

17:09.720 --> 17:11.720
然后我只需要对这个密码

17:11.720 --> 17:13.720
再一进行一次MD5加密

17:13.720 --> 17:14.720
来对比一下这个加密的结果

17:14.720 --> 17:15.720
跟上一个加密

17:15.720 --> 17:16.720
之前保存的加密结果

17:16.720 --> 17:17.720
一模一样就可以了

17:17.720 --> 17:19.720
一样的话那肯定密码是一样的

17:19.720 --> 17:20.720
但是我永远不知道

17:20.720 --> 17:21.720
你原来写的是啥

17:21.720 --> 17:22.720
是这个意思

17:22.720 --> 17:24.720
这是第一个用途

17:24.720 --> 17:26.720
第二个用途其实你们见过

17:26.720 --> 17:27.720
你们学伍佑啊

17:27.720 --> 17:28.720
学卫PAC的时候

17:28.720 --> 17:30.720
是不是见过这么一种文件

17:30.720 --> 17:31.720
就打包出来的文件

17:31.720 --> 17:32.720
打包出来的文件是不是

17:32.720 --> 17:34.720
这么一种

17:38.720 --> 17:39.720
有是不是有这种

17:39.720 --> 17:40.720
中间有这个东西

17:40.720 --> 17:41.720
这东西叫啥

17:41.720 --> 17:43.720
这个东西就是哈希

17:43.720 --> 17:45.720
把这个内容加密过后

17:45.720 --> 17:47.720
使用的哈希

17:47.720 --> 17:49.720
只的一部分

17:49.720 --> 17:50.720
它不是全部

17:50.720 --> 17:51.720
全部太长了

17:51.720 --> 17:52.720
使用它一部分

17:52.720 --> 17:53.720
对吧

17:53.720 --> 17:54.720
当时我说过

17:54.720 --> 17:55.720
为什么要这样做

17:55.720 --> 17:56.720
是为了

17:56.720 --> 17:59.720
能够反映文件内容的变化

17:59.720 --> 18:00.720
只要文件内容一变

18:00.720 --> 18:01.720
那么这个只一定会变

18:01.720 --> 18:02.720
那么就会解决缓存的问题

18:02.720 --> 18:03.720
对吧

18:03.720 --> 18:04.720
我们之前提过

18:04.720 --> 18:05.720
那么这个玩意

18:05.720 --> 18:07.720
我们把称之为文件指纹

18:07.720 --> 18:08.720
好像就是

18:08.720 --> 18:10.720
来识别的文件身份的

18:10.720 --> 18:11.720
只要文件内容不变

18:11.720 --> 18:13.720
那这个就是固定的

18:13.720 --> 18:14.720
流量器可以大胆使用

18:14.720 --> 18:15.720
之前的缓存结果

18:15.720 --> 18:17.720
那只要这个只一变

18:17.720 --> 18:18.720
只要内容一变

18:18.720 --> 18:19.720
那么这个只一会发生

18:19.720 --> 18:20.720
天翻覆地的变化

18:20.720 --> 18:22.720
那么流量器那边缓存就失效了

18:22.720 --> 18:23.720
对吧

18:23.720 --> 18:24.720
就会读去新的文件

18:24.720 --> 18:25.720
就出于这么一个目的

18:25.720 --> 18:27.720
那么这就也是

18:27.720 --> 18:29.720
哈希的一个用途

18:29.720 --> 18:31.720
这是咱们加密这一块

18:31.720 --> 18:32.720
就讲这么三个算法

18:32.720 --> 18:33.720
那面试题的话

18:33.720 --> 18:34.720
就问你这三种

18:34.720 --> 18:36.720
解释一下就完事了

18:36.720 --> 18:37.720
对称加密是一个

18:37.720 --> 18:38.720
怎么样的特点

18:38.720 --> 18:39.720
贼要算法

18:39.720 --> 18:40.720
哈希算法

18:40.720 --> 18:41.720
三天算法

18:41.720 --> 18:42.720
就是什么样的一个特点

18:42.720 --> 18:43.720
好

18:43.720 --> 18:44.720
这就是咱们做的内容

