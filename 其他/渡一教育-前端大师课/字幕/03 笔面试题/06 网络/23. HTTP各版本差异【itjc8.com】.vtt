WEBVTT

00:00.500 --> 00:06.500
OK 咱们聊一聊这个ATV协议的三个版本

00:06.500 --> 00:08.500
1.0 1.1和2.0

00:08.500 --> 00:12.500
这玩意对你们开发没有什么影响

00:12.500 --> 00:14.500
你之前带吧 该咋写咋写

00:14.500 --> 00:17.500
呃 只主要是面试题要问

00:17.500 --> 00:21.500
你看这些面试题里边还有很多大厂还喜欢问你这些东西

00:21.500 --> 00:24.500
咱们把他聊一聊吧

00:24.500 --> 00:26.500
这一块说实话 他很深的

00:26.500 --> 00:29.500
等你要把它彻底搞明白的话

00:29.500 --> 00:33.500
那计算机网络这个课程至少传输成了一块

00:33.500 --> 00:35.500
你得非常透彻的了解

00:35.500 --> 00:37.500
那就用TCP协议啊

00:37.500 --> 00:40.500
这种你要透彻的了解他得花一点时间

00:40.500 --> 00:43.500
那这个时间还真不是一两天能够搞得定的

00:43.500 --> 00:46.500
所以说我们这一块不会讲那么深

00:46.500 --> 00:49.500
我们大概的聊一下 聊一下最核心的东西

00:49.500 --> 00:51.500
然后主要是为了解决面试题

00:51.500 --> 00:53.500
实际上我们ATV的演化呢

00:53.500 --> 00:56.500
它是经历了五个版本

00:57.500 --> 00:59.500
第一个版本是0.29

00:59.500 --> 01:03.500
然后呢0.9基本上出来过后就被PASS掉了

01:03.500 --> 01:05.500
0.9我们就不考虑了

01:05.500 --> 01:09.500
一般来说面试题的话也还也不会去问你0.9的一个版本

01:09.500 --> 01:11.500
然后我们从1.0这个版本开始

01:11.500 --> 01:13.500
其实1.0呢他用的时间也比较短

01:13.500 --> 01:16.500
一年左右马上就替换成1.1了

01:16.500 --> 01:19.500
1.0我记得好像是96年出来的

01:19.500 --> 01:21.500
1.1呢是97年

01:21.500 --> 01:24.500
然后呢1.1用的时间就是最长的

01:24.500 --> 01:27.500
他用到了多久呢 用到了2015年

01:27.500 --> 01:29.500
其实不止2015年

01:29.500 --> 01:32.500
因为2015年的时候ATV2.0出来

01:32.500 --> 01:33.500
其实也没有出来

01:33.500 --> 01:36.500
当时呢正在那个开始要进行修订

01:36.500 --> 01:40.500
我们其实1.1包括到现在都还是在用

01:40.500 --> 01:43.500
像这些知识呢其实

01:43.500 --> 01:45.500
主要是运为人员

01:45.500 --> 01:48.500
后端人员他们需要了解

01:48.500 --> 01:51.500
前端开发者呢对他们影响不大

01:51.500 --> 01:53.500
我简单说一说吧

01:53.500 --> 01:55.500
1.0呢你记住这么两个特点

01:55.500 --> 01:57.500
第一个呢是无法复用连接

01:57.500 --> 01:59.500
第二个是对头主色

01:59.500 --> 02:00.500
就你回答面书题的时候

02:00.500 --> 02:02.500
你把这个两点轨达到就行了

02:02.500 --> 02:05.500
那么什么叫做无法复用连接呢

02:05.500 --> 02:08.500
是因为我们在制定这个1.0这个标准的时候

02:08.500 --> 02:11.500
他做了一个非常简单粗暴的决定

02:11.500 --> 02:13.500
这个决定呢其实我们就是

02:13.500 --> 02:15.500
给同学们平时这样子说的对吧

02:15.500 --> 02:18.500
什么决定呢就是每一次的请求响应

02:18.500 --> 02:21.500
他都是要经历一个新建连接

02:21.500 --> 02:23.500
以及销毁连接的过程

02:23.500 --> 02:25.500
可是我第一次请求页面

02:25.500 --> 02:27.500
那这个页面有个请求响应

02:27.500 --> 02:29.500
那我首先得有个TCP连接通道

02:29.500 --> 02:32.500
我首先得把电话拨通嘛对不对

02:32.500 --> 02:35.500
然后呢就经过三次握手建立连接

02:35.500 --> 02:37.500
然后接下来请求响应

02:37.500 --> 02:39.500
响应完成之后呢就把电话给挂了

02:39.500 --> 02:41.500
这是请求页面

02:41.500 --> 02:42.500
拿到页面一看

02:42.500 --> 02:44.500
里面上还有很多的文件

02:44.500 --> 02:46.500
还有什么CSS文件

02:46.500 --> 02:48.500
GSS文件还有图片文件

02:48.500 --> 02:51.500
好那又来又把电话拨通拨过去

02:51.500 --> 02:53.500
我讲的都想笑了

02:53.500 --> 02:54.500
是不是很傻

02:54.500 --> 02:57.500
然后呢去要他的GSS

02:57.500 --> 02:59.500
GSS给立的又把连接关闭

02:59.500 --> 03:02.500
一看还要CSS又把连接拨过去

03:02.500 --> 03:04.500
就是用这种模式来处理的

03:04.500 --> 03:05.500
这叫无法附用连接

03:05.500 --> 03:06.500
因为每一个连接呢

03:06.500 --> 03:09.500
他只完成一次请求响应

03:09.500 --> 03:11.500
这就说为什么在很早的时候

03:11.500 --> 03:12.500
我们经常说

03:12.500 --> 03:13.500
一个图片啊

03:13.500 --> 03:15.500
你不要搞那么多文件出来

03:15.500 --> 03:16.500
为什么呢

03:16.500 --> 03:17.500
因为他每一个文件

03:17.500 --> 03:18.500
他去拨号

03:18.500 --> 03:20.500
然后去拿文件然后挂电话

03:20.500 --> 03:21.500
每一次都要做这个事

03:21.500 --> 03:23.500
所以说我们会用了什么血币图

03:23.500 --> 03:25.500
来减少文件的数量

03:25.500 --> 03:26.500
其实这个三次握手啊

03:26.500 --> 03:27.500
四次挥手

03:27.500 --> 03:29.500
虽然说看上去呢还是挺快的

03:29.500 --> 03:30.500
对吧

03:30.500 --> 03:33.500
他基本上就是发一个空消息过去

03:33.500 --> 03:34.500
但是实际上

03:34.500 --> 03:35.500
如果说我们页面上文件多了

03:35.500 --> 03:36.500
资源多了

03:36.500 --> 03:38.500
那这个东西还是挺影响效率的

03:38.500 --> 03:39.500
说AGB 1.0呢

03:39.500 --> 03:41.500
这是一个严重的问题

03:41.500 --> 03:43.500
他用主要的问题在哪呢

03:43.500 --> 03:44.500
一个是

03:44.500 --> 03:46.500
连接的建立和消贵

03:46.500 --> 03:48.500
这种服务器和客户端的资源

03:48.500 --> 03:50.500
这是咱们在讲TCP的时候

03:50.500 --> 03:52.500
TCP内协客

03:52.500 --> 03:53.500
给大家说过的

03:53.500 --> 03:55.500
将TCP这个协议呢

03:55.500 --> 03:56.500
建立连接

03:56.500 --> 03:57.500
什么叫连接

03:57.500 --> 03:59.500
连接无非就是一块内存空间

03:59.500 --> 04:00.500
客户端开一块

04:00.500 --> 04:01.500
服务器开一块

04:01.500 --> 04:02.500
对吧

04:02.500 --> 04:05.500
那么连接的建立和消贵时候

04:05.500 --> 04:07.500
会不断的去开内存空间

04:07.500 --> 04:08.500
不断的去开

04:08.500 --> 04:09.500
然后不断的去消贵

04:09.500 --> 04:11.500
一会又开一会又消贵

04:11.500 --> 04:13.500
造成内存资源的浪费

04:13.500 --> 04:14.500
第二个问题呢

04:14.500 --> 04:15.500
就是连接的建立和消贵

04:15.500 --> 04:16.500
消耗时间

04:16.500 --> 04:17.500
对吧

04:17.500 --> 04:18.500
造成响应时间的浪费

04:18.500 --> 04:19.500
然后连接不

04:19.500 --> 04:20.500
首先要创建内存空间

04:20.500 --> 04:21.500
是一块时间

04:21.500 --> 04:22.500
然后三次握手

04:22.500 --> 04:23.500
对吧

04:23.500 --> 04:24.500
三次一二三

04:24.500 --> 04:25.500
四次挥手

04:25.500 --> 04:27.500
一二三四

04:27.500 --> 04:29.500
是不是都需要时间的

04:29.500 --> 04:31.500
那么这些时间浪费了很多

04:31.500 --> 04:33.500
第三个是无法充分的

04:33.500 --> 04:35.500
利用贷款资源

04:35.500 --> 04:37.500
像为什么这样子说呢

04:37.500 --> 04:39.500
是因为我们

04:39.500 --> 04:40.500
就是这个我没讲

04:40.500 --> 04:41.500
因为这个玩意

04:41.500 --> 04:42.500
是比较深的知识的

04:42.500 --> 04:44.500
这个是TCP协议

04:44.500 --> 04:46.500
TCP协议是这么一个情况

04:46.500 --> 04:48.500
它有一个雍色控制

04:48.500 --> 04:53.580
雍色控制

04:53.580 --> 04:55.580
它是怎么回事的

04:55.580 --> 04:57.580
就是你刚刚建立好连接之后

04:57.580 --> 04:58.580
你们在传输数据

04:58.580 --> 05:00.580
它的速度是很慢的

05:00.580 --> 05:01.580
然后逐渐增快

05:01.580 --> 05:03.580
逐渐升高

05:03.580 --> 05:04.580
那么是怎么回事

05:04.580 --> 05:05.580
大概就是这样子

05:05.580 --> 05:08.580
它一开始的速度很慢

05:08.580 --> 05:10.580
然后一个指数型的增长

05:10.580 --> 05:13.580
增长到一个点的之后

05:13.580 --> 05:15.580
一个线性的增长

05:15.580 --> 05:16.580
好 到了一个点

05:16.580 --> 05:17.580
突然发现网络雍色了

05:17.580 --> 05:19.580
然后回忆点

05:19.580 --> 05:21.580
然后再线性的增长

05:21.580 --> 05:23.580
当然这个具体的控制手段

05:23.580 --> 05:24.580
有很多种

05:24.580 --> 05:25.580
有一些模特的句话

05:25.580 --> 05:27.580
是启动一种

05:27.580 --> 05:28.580
那如果说

05:28.580 --> 05:30.580
你是每一次请求响应

05:30.580 --> 05:32.580
都是新建连接的话

05:32.580 --> 05:33.580
一看新建连接

05:33.580 --> 05:35.580
都是从这个网速开始的

05:35.580 --> 05:36.580
你刚刚开始要启动

05:36.580 --> 05:38.580
对吧 刚刚要发车了

05:38.580 --> 05:40.580
结果呢

05:40.580 --> 05:41.580
响应完成了

05:41.580 --> 05:42.580
对吧 请求响应完成了

05:42.580 --> 05:44.580
完成之后是不是断开了

05:44.580 --> 05:45.580
断开之后下一次

05:45.580 --> 05:47.580
它又得重新来

05:47.580 --> 05:50.580
所以它的网速是很难达到峰值的

05:50.580 --> 05:52.580
很难充分利用带宽

05:52.580 --> 05:54.580
一带宽哪怕是一千兆

05:54.580 --> 05:56.580
结果发现还是很慢

05:56.580 --> 05:58.580
这就是这一块造成的问题

05:58.580 --> 06:00.580
这是无法附用连接造成的问题

06:00.580 --> 06:02.580
另外一个是对头组设

06:02.580 --> 06:05.580
AKP1.0

06:05.580 --> 06:07.580
因为什么原因

06:07.580 --> 06:10.580
它要求上一个请求结束之后

06:10.580 --> 06:12.580
我才能发出下一个请求

06:12.580 --> 06:14.580
你看变成这么一个过程

06:14.580 --> 06:15.580
连接创建

06:15.580 --> 06:17.580
请求过去等待响应

06:17.580 --> 06:18.580
好销毁

06:18.580 --> 06:19.580
下一次建立连接

06:19.580 --> 06:20.580
又请求响应

06:20.580 --> 06:22.580
后面又销毁

06:22.580 --> 06:24.580
如果说我现在的页面上

06:24.580 --> 06:25.580
有一千个图片

06:25.580 --> 06:26.580
那没办法

06:26.580 --> 06:27.580
一个个来

06:27.580 --> 06:28.580
那有啥办法呢

06:28.580 --> 06:30.580
连接过去回来

06:30.580 --> 06:31.580
第一档图片完成

06:31.580 --> 06:33.580
第二档图片过去回来

06:33.580 --> 06:34.580
它就不能一起过去一起回来吗

06:34.580 --> 06:35.580
不行

06:35.580 --> 06:36.580
它不行

06:36.580 --> 06:37.580
这是AKP1.0

06:37.580 --> 06:39.580
造成了一个非常效率

06:39.580 --> 06:41.580
低下的一个问题

06:41.580 --> 06:44.580
接下来到了1.1

06:44.580 --> 06:46.580
1.1记住这么两个特点

06:46.580 --> 06:47.580
一个是长连接

06:47.580 --> 06:50.580
一个是管道化和对头组设

06:50.580 --> 06:51.580
长连接

06:51.580 --> 06:52.580
它是解决什么问题呢

06:52.580 --> 06:55.580
它主要是解决连接附用的问题

06:55.580 --> 06:58.580
就是我建立一次TCP连接

06:58.580 --> 07:00.580
我又可以完成多次请求响应

07:00.580 --> 07:02.580
它主要是解决这个问题

07:02.580 --> 07:03.580
那么我们来对比一下

07:03.580 --> 07:04.580
那个1.0的图

07:04.580 --> 07:05.580
是不是好多了

07:05.580 --> 07:06.580
对吧

07:06.580 --> 07:07.580
后边的图

07:07.580 --> 07:10.270
靠屁过来

07:10.270 --> 07:11.270
这样子

07:11.270 --> 07:12.270
对比一下

07:12.270 --> 07:13.270
都是两次请求响应

07:13.270 --> 07:15.270
那么这边肯定是好多了

07:15.270 --> 07:18.270
它少了中间的销毁和再创建

07:18.270 --> 07:19.270
这对于相当于什么呢

07:19.270 --> 07:21.270
相当于打电话

07:21.270 --> 07:22.270
打电话的时候

07:22.270 --> 07:24.270
我一开始拿到有门

07:24.270 --> 07:25.270
你别挂

07:25.270 --> 07:26.270
我现在看

07:26.270 --> 07:28.270
我还要一个CSS给我

07:28.270 --> 07:29.270
你别挂

07:29.270 --> 07:30.270
我现在还要一个GSS给我

07:30.270 --> 07:31.270
懂了意思吧

07:31.270 --> 07:33.270
是不是变得正常一点了

07:33.270 --> 07:35.270
请求响应 请求响应

07:35.270 --> 07:36.270
那么这是这种模式

07:36.270 --> 07:37.270
长连接

07:37.270 --> 07:40.270
长连接可能可以有效的

07:40.270 --> 07:42.270
利用同一个TCP连接

07:42.270 --> 07:44.270
那么这里边可以来回传输

07:44.270 --> 07:46.270
很多的消息

07:46.270 --> 07:48.270
那么这些消息呢

07:48.270 --> 07:50.270
他们由于使用同一个TCP连接

07:50.270 --> 07:52.270
是不是解决的带宽资源

07:52.270 --> 07:53.270
对吧

07:53.270 --> 07:54.270
充分的利用了网络带宽

07:54.270 --> 07:56.270
像TCP的慢启动

07:56.270 --> 07:57.270
慢启动

07:57.270 --> 07:58.270
那么

07:58.270 --> 07:59.270
它用这种模式

07:59.270 --> 08:01.270
它是很容易达到峰值的

08:01.270 --> 08:03.270
一开始传输一个atme文档

08:03.270 --> 08:05.270
然后传输了一个CSS

08:05.270 --> 08:07.270
到GS越来越快了

08:07.270 --> 08:09.270
到后边的图片越来越快了

08:09.270 --> 08:10.270
对吧

08:10.270 --> 08:13.270
我们只占用到网络的峰值

08:13.270 --> 08:15.270
可以充分的利用带宽资源

08:15.270 --> 08:17.270
所以atme 1.0在这一方面的感性

08:17.270 --> 08:19.270
是很大的

08:19.270 --> 08:20.270
好

08:20.270 --> 08:22.270
这里我顺便给大家说一下

08:22.270 --> 08:24.270
这种长连接

08:24.270 --> 08:25.270
这种长连接

08:25.270 --> 08:28.270
其实在atme 1.1出来之前

08:28.270 --> 08:30.270
1.0出来之后

08:30.270 --> 08:31.270
马上发现这个问题了

08:31.270 --> 08:34.270
简直无法容认这种方式

08:34.270 --> 08:36.270
所以atme 1.1出来之前

08:36.270 --> 08:37.270
有没有解决呢

08:37.270 --> 08:38.270
官方没有解决

08:38.270 --> 08:39.270
官方没有解决

08:39.270 --> 08:40.270
就是标准上没有解决

08:40.270 --> 08:42.270
但是开发者慢慢达成了一个共识

08:42.270 --> 08:44.270
什么共识呢

08:44.270 --> 08:46.270
我在请求的时候

08:46.270 --> 08:47.270
加一个请求头

08:47.270 --> 08:49.270
叫connection

08:49.270 --> 08:51.270
keeper line

08:51.270 --> 08:54.650
加上这么一个请求头

08:54.650 --> 08:56.650
加上这么一个请求头的话

08:56.650 --> 08:57.650
服务器只要一看到这个请求头

08:57.650 --> 08:59.650
当然都要达成共识

08:59.650 --> 09:00.650
服务器一看

09:00.650 --> 09:02.650
原来你是不希望我关闭这个连接

09:02.650 --> 09:03.650
那我就不关闭了

09:03.650 --> 09:04.650
暂时性不关闭

09:04.650 --> 09:05.650
先让你用一会

09:05.650 --> 09:07.650
用完了之后我们再关闭

09:07.650 --> 09:08.650
那肯定是要关闭的

09:08.650 --> 09:09.650
不会一直开启的

09:09.650 --> 09:11.650
是这么个意思

09:11.650 --> 09:13.650
也就是我们1.1之前

09:13.650 --> 09:14.650
能不能解决这个问题

09:14.650 --> 09:15.650
可以解决

09:15.650 --> 09:17.650
但是不是一个标准

09:17.650 --> 09:18.650
到了1.1之后

09:18.650 --> 09:20.650
你传不传这个都无所谓了

09:20.650 --> 09:22.650
默认使用常连接

09:22.650 --> 09:23.650
是这么一回事

09:23.650 --> 09:24.650
同学们有可能看到过

09:24.650 --> 09:25.650
这个东西

09:25.650 --> 09:26.650
其实你现在访问网站

09:26.650 --> 09:29.650
比方说就访问我那个博客

09:29.650 --> 09:31.650
我们来看一下他们的sword

09:31.650 --> 09:32.650
刷新

09:32.650 --> 09:36.150
我们来找一下

09:36.150 --> 09:38.150
你看到这里有一个显ID

09:38.150 --> 09:39.150
看到没

09:39.150 --> 09:41.150
是不是扛了一个显ID

09:41.150 --> 09:42.150
那么这个扛了一个显ID

09:42.150 --> 09:43.150
我们把它分类一下

09:43.150 --> 09:45.150
因为发现有一些ID是一样的

09:45.150 --> 09:46.150
这里一个ID

09:46.150 --> 09:47.150
一个扛了一个显ID

09:47.150 --> 09:49.150
它就是一个TCP连接

09:49.150 --> 09:50.150
懂了意思吧

09:50.150 --> 09:51.150
一个扛了一个显ID

09:51.150 --> 09:52.150
就是一个TCP连接

09:52.150 --> 09:54.150
如果说使用的是1.0版本的话

09:54.150 --> 09:56.150
那每个都是不一样的

09:56.150 --> 09:57.150
每个都是一个

09:57.150 --> 09:58.150
不同的TCP连接

09:58.150 --> 10:00.150
但是这里有些你发现是一样的

10:00.150 --> 10:01.150
你看

10:01.150 --> 10:02.150
这个868

10:02.150 --> 10:03.150
868

10:03.150 --> 10:04.150
这几个

10:04.150 --> 10:05.150
你看这几个

10:05.150 --> 10:06.150
是不是一样的

10:06.150 --> 10:09.150
证明他们在使用同一个TCP连接

10:09.150 --> 10:10.150
懂了意思吧

10:10.150 --> 10:11.150
是这么一回事

10:11.150 --> 10:15.150
然后你看这个TCP连接里边

10:15.150 --> 10:17.150
每一次请求

10:17.150 --> 10:18.150
你看Request

10:18.150 --> 10:20.150
一个扛了一个显ID

10:20.150 --> 10:22.150
是浏览器自动给你加上的

10:22.150 --> 10:23.150
当然不加这个

10:23.150 --> 10:24.150
能不能实现常连接

10:24.150 --> 10:25.150
可以

10:25.150 --> 10:26.150
它默认就开启了

10:26.150 --> 10:27.150
加这个的目的

10:27.150 --> 10:29.150
主要是兼容1.0这个版本

10:29.150 --> 10:31.150
万一一些非常老的服务器

10:31.150 --> 10:32.150
老的服务器

10:32.150 --> 10:34.150
它需要这个东西

10:34.150 --> 10:35.150
总之该加上

10:35.150 --> 10:37.150
就这么一个意思

10:37.150 --> 10:38.150
这是关于这个

10:38.150 --> 10:40.150
常连接是什么意思

10:40.150 --> 10:42.150
以及那个Connection

10:42.150 --> 10:43.150
Tapel Live是什么意思

10:45.150 --> 10:47.150
那么这里就是要一个问题

10:47.150 --> 10:49.150
就是什么时候关闭呢

10:49.150 --> 10:50.150
对吧你这里传来传去

10:50.150 --> 10:51.150
传一会儿一会儿传GS

10:51.150 --> 10:52.150
一会儿传CSS

10:52.150 --> 10:53.150
一会儿传图片

10:53.150 --> 10:55.150
那什么时候关闭这个连接呢

10:55.150 --> 10:56.150
这一块呢

10:56.150 --> 10:57.150
大家

10:57.150 --> 10:58.150
我觉得啊

10:58.150 --> 10:59.150
面试体一般不会问你这个

10:59.150 --> 11:00.150
这个玩意儿识一识

11:00.150 --> 11:02.150
有一点生了这个东西

11:02.150 --> 11:04.150
怎么关闭呢

11:04.150 --> 11:06.150
其实主要

11:06.150 --> 11:08.150
可以是客户端那边主动关闭

11:08.150 --> 11:09.150
就是我不要了

11:09.150 --> 11:10.150
我挂电话了

11:10.150 --> 11:12.150
也可以服务器那边挂电话

11:12.150 --> 11:13.150
但是大部分情况下

11:13.150 --> 11:14.150
是服务器那边挂

11:14.150 --> 11:15.150
那么它根据什么情况

11:15.150 --> 11:16.150
了解一下就行了

11:16.150 --> 11:17.150
这个东西

11:17.150 --> 11:18.150
面试体一般不会问的

11:18.150 --> 11:19.150
第一种情况就是

11:19.150 --> 11:20.150
客户端那边

11:20.150 --> 11:21.150
他想挂了

11:21.150 --> 11:22.150
他让服务器把它挂掉

11:22.150 --> 11:24.150
我没东西了

11:24.150 --> 11:25.150
那么他给最后一事

11:25.150 --> 11:26.150
请求加上这么一个东西

11:26.150 --> 11:27.150
Connection Close

11:27.150 --> 11:28.150
那么服务器

11:28.150 --> 11:29.150
如果说

11:29.150 --> 11:30.150
收到这么一个东西的话

11:30.150 --> 11:31.150
就觉得客户端那边

11:31.150 --> 11:33.150
确实是没有东西需要了

11:33.150 --> 11:34.150
那我就把它关了

11:34.150 --> 11:35.150
对吧

11:35.150 --> 11:36.150
一会你需要的话

11:36.150 --> 11:37.150
再重新来打电话

11:37.150 --> 11:39.150
因为一直站线的话

11:39.150 --> 11:41.150
其实也挺浪费资源的

11:41.150 --> 11:43.150
还有一种情况就是

11:43.150 --> 11:45.150
他其实两次请求之间

11:45.150 --> 11:47.150
他会不断地使用TCP协议

11:47.150 --> 11:49.150
他就不是ATP协议了

11:49.150 --> 11:51.150
比如说这是一事请求响应

11:51.150 --> 11:52.150
这是一事请求响应

11:52.150 --> 11:53.150
在两次请求响应之间

11:53.150 --> 11:55.150
可能会间隔一段时间

11:55.150 --> 11:56.150
可能会间隔几秒钟

11:56.150 --> 11:57.150
都有可能

11:57.150 --> 11:58.150
那么在中间

11:58.150 --> 11:59.150
它不能断的

11:59.150 --> 12:00.150
这个电话先不是不能断的

12:00.150 --> 12:02.150
那么中间的话

12:02.150 --> 12:03.150
他会客户端

12:03.150 --> 12:04.150
他就是浏览器

12:04.150 --> 12:05.150
他会自动帮你完成

12:05.150 --> 12:06.150
他会跟服务器之间

12:06.150 --> 12:09.150
保持一个联系

12:09.150 --> 12:11.150
怎么联系呢

12:11.150 --> 12:13.150
我们把它叫做心跳检测

12:13.150 --> 12:15.150
就在TCP城还有一个

12:15.150 --> 12:16.150
专业数语

12:16.150 --> 12:17.150
我们这里不去扯那么远

12:17.150 --> 12:18.150
就相当于说

12:18.150 --> 12:20.150
我在电话里边说

12:20.150 --> 12:21.150
等一下

12:21.150 --> 12:22.150
稍等一下

12:22.150 --> 12:23.150
别停

12:23.150 --> 12:24.150
别挂

12:24.150 --> 12:25.150
不停的这样子说

12:25.150 --> 12:26.150
简单跟他说一下

12:26.150 --> 12:27.150
让他别挂电话

12:27.150 --> 12:28.150
这叫心跳检测

12:28.150 --> 12:29.150
服务器能够一直

12:29.150 --> 12:30.150
收到这个消息

12:30.150 --> 12:31.150
他就不会挂

12:31.150 --> 12:33.150
服务器收不到这个消息了

12:33.150 --> 12:34.150
他等了一会

12:34.150 --> 12:35.150
怎么还没有一个消息

12:35.150 --> 12:36.150
怎么还没有

12:36.150 --> 12:37.150
让我不要挂电话

12:37.150 --> 12:39.150
那我怕就快挂了

12:39.150 --> 12:40.150
都是这么一回事

12:40.150 --> 12:41.150
还有一种情况

12:41.150 --> 12:42.150
就是说

12:42.150 --> 12:43.150
他虽然说一直

12:43.150 --> 12:44.150
一直在让服务器

12:44.150 --> 12:45.150
不要挂电话

12:45.150 --> 12:46.150
一直在让服务器

12:46.150 --> 12:47.150
不要挂电话

12:47.150 --> 12:48.150
但他长时间

12:48.150 --> 12:49.150
又没有什么东西需要了

12:49.150 --> 12:50.150
他又不说

12:50.150 --> 12:51.150
他要什么东西

12:51.150 --> 12:52.150
服务器一生气

12:52.150 --> 12:53.150
就要挂了

12:53.150 --> 12:54.150
这种情况

12:54.150 --> 12:55.150
一般运为人员

12:55.150 --> 12:57.150
是可以在服务器设置的

12:57.150 --> 12:59.150
叫做Keeper Live Time Out

12:59.150 --> 13:01.150
就是长连接的过期时间

13:01.150 --> 13:02.150
可以设置的

13:02.150 --> 13:03.150
长时间你不要东西

13:03.150 --> 13:04.150
我就可以挂了

13:04.150 --> 13:06.150
他不能一直保持的

13:06.150 --> 13:07.150
这是这个长连接

13:07.150 --> 13:08.150
给大家说一下

13:08.150 --> 13:11.150
好 接下来是管道化和对头组设

13:11.150 --> 13:13.150
对头组设ATP1.0有

13:13.150 --> 13:15.150
ATP1.1有没有呢

13:15.150 --> 13:16.150
他也有

13:16.150 --> 13:17.150
首先他还是没有解决

13:17.150 --> 13:18.150
这个问题

13:18.150 --> 13:20.150
就是那个

13:20.150 --> 13:21.150
请求响应必须要

13:21.150 --> 13:23.150
依次这种串形的方式

13:23.150 --> 13:24.150
上一个完了

13:24.150 --> 13:25.150
不会下一个

13:25.150 --> 13:26.150
再来

13:26.150 --> 13:27.150
他没有解决这个问题

13:27.150 --> 13:28.150
那么这个问题

13:28.150 --> 13:30.150
他想了一种办法

13:30.150 --> 13:31.150
叫管道化

13:31.150 --> 13:32.150
他希望了这个管道化

13:32.150 --> 13:34.150
能够缓解这个问题

13:34.150 --> 13:35.150
那么这个管道化

13:35.150 --> 13:36.150
是怎么回事的

13:36.150 --> 13:37.150
他就是说

13:37.150 --> 13:39.150
虽然说我

13:39.150 --> 13:40.150
我没法彻底解决

13:40.150 --> 13:41.150
这个问题

13:41.150 --> 13:42.150
但是我可以这样

13:42.150 --> 13:44.150
我可以两次请求

13:44.150 --> 13:45.150
一起发出

13:45.150 --> 13:46.150
就是我先

13:46.150 --> 13:47.150
这样

13:47.150 --> 13:49.150
我先发出一个请求

13:49.150 --> 13:51.150
先发出一个请求过去

13:51.150 --> 13:53.150
发出就发完了之后

13:53.150 --> 13:54.150
比方说有十张图片

13:54.150 --> 13:56.150
我不用等服务器的响应

13:56.150 --> 13:58.150
我马上把下一个图片的请求

13:58.150 --> 13:59.150
也发过去

14:00.150 --> 14:02.150
两个请求发过去

14:02.150 --> 14:03.150
那这样子

14:03.150 --> 14:04.150
可以节省时间

14:04.150 --> 14:05.150
一看图就应该可以知道

14:05.150 --> 14:06.150
如果说

14:06.150 --> 14:07.150
上面的那种模式

14:08.150 --> 14:10.150
就是上面的那种模式

14:10.150 --> 14:11.150
来对比一下

14:11.150 --> 14:13.150
对比下面这个模式

14:13.150 --> 14:14.150
看上去

14:14.150 --> 14:15.150
下面的模式就效率高得多

14:15.150 --> 14:16.150
对不对

14:16.150 --> 14:17.150
但是这样一来

14:17.150 --> 14:18.150
他还是会导致问题

14:18.150 --> 14:19.150
什么问题呢

14:19.150 --> 14:20.150
你看吧

14:20.150 --> 14:21.150
如果说

14:21.150 --> 14:22.150
第一个资源

14:22.150 --> 14:23.150
服务器比方

14:23.150 --> 14:24.150
第一个图片比较大

14:24.150 --> 14:25.150
或者是

14:25.150 --> 14:26.150
这个服务器那边

14:26.150 --> 14:27.150
要做一些什么

14:27.150 --> 14:28.150
加水 银压 各种

14:28.150 --> 14:29.150
复杂的处理

14:29.150 --> 14:30.150
它可能

14:30.150 --> 14:31.150
服务器那边要处理

14:31.150 --> 14:32.150
需要一段时间

14:32.150 --> 14:33.150
它时间比较长一点

14:33.150 --> 14:34.150
而第二个资源呢

14:34.150 --> 14:35.150
它比较小

14:35.150 --> 14:36.150
可能只是一个

14:36.150 --> 14:38.150
非常小的图标

14:38.150 --> 14:39.150
那么它的时间也比较小

14:39.150 --> 14:41.150
它的处理时间比较短

14:41.150 --> 14:42.150
那么就相反的

14:42.150 --> 14:44.150
跟那个请求顺序不一样了

14:44.150 --> 14:46.150
从服务器对服务器而言

14:46.150 --> 14:47.150
第二个资源

14:47.150 --> 14:49.150
是不是先完成

14:49.150 --> 14:50.150
对吧

14:50.150 --> 14:51.150
是应该先享用

14:51.150 --> 14:52.150
那么

14:52.150 --> 14:53.150
第一个资源呢

14:53.150 --> 14:54.150
后完成 后享用

14:54.150 --> 14:55.150
服务器不能这样做

14:55.150 --> 14:57.150
服务器必须要按照顺序来

14:57.150 --> 14:58.150
进行享用

14:58.150 --> 15:00.150
先享用第一个资源

15:00.150 --> 15:01.150
第二个资源

15:01.150 --> 15:02.150
虽然处理完了

15:02.150 --> 15:03.150
必须要等

15:03.150 --> 15:04.150
然后等到

15:04.150 --> 15:05.150
第一个资源享用过后

15:05.150 --> 15:06.150
然后第二个资源

15:06.150 --> 15:07.150
再进行享用

15:07.150 --> 15:09.150
你看 在这段时间内

15:09.150 --> 15:10.150
这段时间内

15:10.150 --> 15:11.150
是不是相对

15:11.150 --> 15:12.150
第二个资源

15:12.150 --> 15:13.150
被第一个资源阻涉了

15:13.150 --> 15:14.150
对吧

15:14.150 --> 15:15.150
阻涉什么意思

15:15.150 --> 15:16.150
就等待 无意义的等待

15:16.150 --> 15:17.150
等待别人完成

15:17.150 --> 15:18.150
这就是阻涉

15:18.150 --> 15:19.150
在这段时间内

15:19.150 --> 15:20.150
它就被阻涉掉了

15:20.150 --> 15:21.150
这也会有

15:21.150 --> 15:23.150
这也是一种对头阻涉

15:24.150 --> 15:25.150
那么大家可以想一想

15:25.150 --> 15:27.150
为什么

15:27.150 --> 15:29.150
为什么服务器必须要按照

15:29.150 --> 15:32.150
请求到达的顺序来进行享用

15:32.150 --> 15:33.150
为什么

15:33.150 --> 15:35.150
就好比较委屈个例子

15:35.150 --> 15:38.150
两个人聊天

15:38.150 --> 15:39.150
你做一种

15:39.150 --> 15:41.150
你比方说是客户端

15:41.150 --> 15:43.150
你去问对方一些问题

15:43.150 --> 15:44.150
对方就是服务器

15:44.150 --> 15:45.150
你们在微信里边聊天

15:45.150 --> 15:47.150
你刷刷刷刷刷

15:47.150 --> 15:48.150
给他问了好几个问题

15:48.150 --> 15:50.150
对吧 你有钱吗

15:50.150 --> 15:51.150
你有女朋友吗

15:51.150 --> 15:52.150
你有房吗

15:52.150 --> 15:53.150
你有车吗

15:53.150 --> 15:54.150
你有地吗

15:54.150 --> 15:55.150
你有矿吗

15:55.150 --> 15:56.150
然后我连续问了

15:56.150 --> 15:57.150
五六个问题

15:57.150 --> 15:58.150
是不是相当于是发出了

15:58.150 --> 15:59.150
五六次请求

15:59.150 --> 16:01.150
好 服务器在那边给你回

16:01.150 --> 16:04.150
有 没有 没有 没有

16:04.150 --> 16:06.150
好 那服务器这样子回了之后

16:06.150 --> 16:08.150
如果说双方没有约定顺序

16:08.150 --> 16:09.150
大家都可以随便

16:09.150 --> 16:11.150
不按照顺序来

16:11.150 --> 16:12.150
你怎么知道

16:12.150 --> 16:13.150
哪个答案是哪个答案的

16:13.150 --> 16:14.150
你怎么知道

16:14.150 --> 16:15.150
是不是不知道

16:15.150 --> 16:17.150
那么就会造成问题

16:17.150 --> 16:19.150
所以他必须要一次回复

16:19.150 --> 16:20.150
这就是

16:20.150 --> 16:22.150
他解决不了的问题

16:23.150 --> 16:24.150
于是

16:24.150 --> 16:26.150
正是因为这个问题

16:26.150 --> 16:29.150
虽然说我们可以使用管道化

16:29.150 --> 16:30.150
就是使用这种方式

16:30.150 --> 16:32.150
可以连续发请求

16:32.150 --> 16:34.150
但是仍然会有对头组设

16:34.150 --> 16:36.150
而且管道化

16:36.150 --> 16:38.150
开启过后的对头组设

16:38.150 --> 16:39.150
你别看它解决时间

16:39.150 --> 16:40.150
比上面那个好多了

16:40.150 --> 16:41.150
对吧

16:41.150 --> 16:42.150
比上面这个好多了

16:42.150 --> 16:43.150
你别看它好一些

16:43.150 --> 16:44.150
其实它造成的问题

16:44.150 --> 16:46.150
有可能更严重

16:46.150 --> 16:48.150
那么为什么会更严重

16:48.150 --> 16:50.150
我们这里就不扯得那么深了

16:50.150 --> 16:51.150
总之管道化的

16:51.150 --> 16:52.150
实际上这个东西

16:52.150 --> 16:54.150
也就是一个理想的

16:54.150 --> 16:55.150
一个状态而已

16:55.150 --> 16:57.150
实际上我们平时

16:57.150 --> 16:59.150
像谷歌浏览器

16:59.150 --> 17:01.150
它不会默认开启管道化的

17:01.150 --> 17:02.150
它还是一个请求

17:02.150 --> 17:03.150
接一个请求的

17:03.150 --> 17:05.150
咱们看一下这里的

17:05.150 --> 17:07.150
网络通信图吧

17:07.150 --> 17:08.150
我们看一下

17:08.150 --> 17:10.150
同一个TCP链接里面

17:10.150 --> 17:12.150
我们分类一下

17:12.150 --> 17:14.150
比方说就这个245

17:14.150 --> 17:15.150
好吧

17:15.150 --> 17:16.150
这个ID

17:16.150 --> 17:17.150
你看看这里有一个

17:17.150 --> 17:18.150
时序图

17:18.150 --> 17:19.150
245

17:19.150 --> 17:20.150
243

17:20.150 --> 17:21.150
144

17:21.150 --> 17:22.150
你看它的顺序

17:22.150 --> 17:24.150
你自己看它的顺序

17:24.150 --> 17:26.150
是不是一个接一个的

17:26.150 --> 17:27.150
是不是一个接一个

17:27.150 --> 17:28.150
上一个完成之后

17:28.150 --> 17:30.150
上一个完成之后

17:30.150 --> 17:31.150
下一个再来

17:31.150 --> 17:32.150
下一个完成之后

17:32.150 --> 17:33.150
下一个再来

17:33.150 --> 17:35.150
然后后边再来一个

17:35.150 --> 17:36.150
懂得意思吧

17:36.150 --> 17:37.150
它是用这种模式的

17:37.150 --> 17:39.150
它还不是

17:39.150 --> 17:41.150
把请求同时发出的

17:41.150 --> 17:43.150
它没有用管道化

17:43.150 --> 17:44.150
用管道化

17:44.150 --> 17:45.150
可能会带来更多的问题

17:45.150 --> 17:47.150
它仍然会有对头出色

17:47.150 --> 17:51.270
所以说为了解决这个对头组色的问题

17:51.270 --> 17:52.710
其实我们想了很多的手段

17:52.710 --> 17:54.830
减少文件的数量

17:54.830 --> 17:58.790
数量减少了 对吧 请求就少了

17:58.790 --> 18:02.190
请求少了过后 是不是这种组色的几率就降低了

18:02.190 --> 18:05.150
所以我们一般使用什么血币图

18:05.150 --> 18:07.630
对吧 一些比较少量的GS代码

18:07.630 --> 18:09.630
CS代码 我可以通过一些工具

18:09.630 --> 18:11.310
在工程化的时候

18:11.310 --> 18:13.430
把它压出到style里边

18:13.430 --> 18:15.350
或者是script元素里边

18:15.350 --> 18:16.790
不用形成外部文件

18:16.790 --> 18:18.630
都是为了去做这些处理

18:18.630 --> 18:20.150
还有一种办法是

18:20.150 --> 18:22.110
浏览器它是有这样的想

18:22.110 --> 18:23.830
那我能不能这样

18:23.830 --> 18:26.790
你页面上比方说有60个文件

18:26.790 --> 18:28.270
60个资源这个页面

18:28.270 --> 18:30.830
有些图片 有些CSS 还有GS

18:30.830 --> 18:33.870
我不用一个TCP连接

18:33.870 --> 18:37.670
我不用一个 我同时给你开启六个

18:37.670 --> 18:40.390
可不可以呢 这是可以的

18:40.390 --> 18:42.950
因为它如果说处在不同的连接通道里边

18:42.950 --> 18:44.070
它就没有这个问题了

18:44.070 --> 18:45.790
那比方说你还是刚才的例子

18:45.830 --> 18:47.910
你跟你朋友之间发消息

18:47.910 --> 18:49.350
你连续问他六个问题

18:49.350 --> 18:50.950
如果说都用微信来问

18:50.950 --> 18:52.990
他是不是必须按照顺序来回答

18:52.990 --> 18:55.950
但是如果说你表上两个问题吧

18:55.950 --> 18:57.390
你有房吗 你有车吗

18:57.390 --> 18:59.510
对吧 两个问题 两个请求

18:59.510 --> 19:01.350
这个时候你开两个通道

19:01.350 --> 19:03.350
就是一个QQ 一个微信

19:03.350 --> 19:05.070
你在QQ里边问一个问题

19:05.070 --> 19:07.110
在微信里边问一个问题

19:07.110 --> 19:09.030
它无论是先回复QQ

19:09.030 --> 19:10.430
还是先回复微信

19:10.430 --> 19:11.630
你是不是都知道

19:11.630 --> 19:13.510
哪个问题是哪个问题的 是不是都知道

19:13.670 --> 19:16.110
它就开两个通道来处理这个问题

19:16.110 --> 19:17.670
那么刘烂七会开几个呢

19:17.670 --> 19:19.390
他针对同一个域名

19:19.390 --> 19:21.750
他会开六个 你看这里

19:21.750 --> 19:24.310
你看有些请求他是同时的 来的

19:24.310 --> 19:25.190
你看这个请求

19:25.190 --> 19:26.230
跟这个请求同时来的

19:26.230 --> 19:28.590
为什么 因为他们的连接ID不一样

19:29.670 --> 19:32.590
你看这个请求跟这些请求

19:32.590 --> 19:33.590
是不是都有同时

19:33.590 --> 19:35.710
因为他的连接ID不一样

19:35.710 --> 19:37.430
看到没有 也就是我们刘烂七

19:37.430 --> 19:39.310
他会自动的进行优化

19:39.310 --> 19:42.070
最多开六个 不会更多了

19:43.070 --> 19:44.230
那么如果说你要更多

19:44.230 --> 19:45.070
有些他们大网站

19:45.070 --> 19:46.910
像淘宝那些那么多图片 对吧

19:46.910 --> 19:47.990
一大堆图片

19:47.990 --> 19:49.790
各种各样的外部资源一大堆

19:49.790 --> 19:50.670
那么如果说你

19:50.670 --> 19:52.670
像我这个网站资源都太多少了

19:52.670 --> 19:54.510
那如果说你有更多的图片

19:54.510 --> 19:56.510
六个可能觉得不够用

19:56.510 --> 19:59.750
因为你还是会重用很多的TCP连接

19:59.750 --> 20:01.430
导致了一对头组设的问题

20:01.430 --> 20:03.190
那怎么办呢

20:03.190 --> 20:05.270
那你就换域名

20:05.270 --> 20:06.430
你会发现有些网站的

20:06.430 --> 20:08.070
他给你加了很多的域名

20:08.070 --> 20:09.590
我们比方说直接看淘宝吧

20:12.540 --> 20:14.180
你看淘宝里边

20:14.180 --> 20:15.340
我们这里一个杜妹

20:15.340 --> 20:17.540
你看他域名不仅仅是淘宝网站下来

20:17.540 --> 20:18.540
你看各种各样的域名

20:18.540 --> 20:20.340
他为什么会换这么多域名

20:20.340 --> 20:23.740
他就是为了开启不同的TCP连接通道

20:23.740 --> 20:25.340
来处理这个问题

20:25.340 --> 20:28.540
这就是我这里在刷新意识

20:28.540 --> 20:30.140
文件是很多的

20:30.140 --> 20:33.140
你看这个域名

20:33.140 --> 20:34.140
是不是有很多

20:34.140 --> 20:35.140
对吧 有很多的域名

20:35.140 --> 20:36.740
他就是为了解决这个问题

20:36.740 --> 20:38.340
他不是想去搞那么多域名

20:38.340 --> 20:39.340
他没办法

20:40.340 --> 20:42.740
所以说这个管道化

20:42.740 --> 20:44.740
它不是一个成功的模型

20:44.740 --> 20:47.940
刘兰棋他默认都是关闭这种模式的

20:47.940 --> 20:50.140
他在对头组设还是没有解决

20:50.140 --> 20:51.540
有管道化还是没有解决

20:51.540 --> 20:52.940
而且可能更严重

20:52.940 --> 20:54.740
没有管道化还是有对头组设

20:54.740 --> 20:57.140
反正就是对头组设解决不了

20:57.140 --> 20:58.740
解决不了的原因是什么

20:58.740 --> 21:01.540
我们要探员他的根源

21:01.540 --> 21:02.540
原因是什么呢

21:02.540 --> 21:03.340
就有面试起来

21:03.340 --> 21:05.540
专门就问你为什么解决不了

21:05.540 --> 21:07.140
本质的问题

21:07.140 --> 21:09.540
就是因为ATTP协议

21:09.540 --> 21:11.740
它的传输单位是

21:13.740 --> 21:16.540
就是ATTP文档

21:16.540 --> 21:18.140
ATTP不是ATTP文档

21:18.140 --> 21:19.140
ATTP文档

21:19.140 --> 21:21.140
文档里面就是不包含什么行

21:24.140 --> 21:26.740
行 头 体

21:26.740 --> 21:27.540
对不对 是吧

21:27.540 --> 21:29.540
请求体 请求行 请求头

21:29.540 --> 21:31.340
想应行 想应头 想应体

21:31.340 --> 21:32.340
对吧 所以如果我们有的时候

21:32.340 --> 21:33.740
把行业归到头里边

21:33.740 --> 21:35.140
那就是头和体

21:35.140 --> 21:37.140
整个家企就是个ATTP文档

21:37.140 --> 21:40.140
这是ATTP传输的基本单元

21:40.140 --> 21:42.140
它不能分割

21:42.140 --> 21:43.140
什么叫不能分割

21:43.140 --> 21:46.140
我不能说我先把头传一半

21:46.140 --> 21:48.140
然后我再一会再传另一半头

21:48.140 --> 21:50.140
我再把体传一半

21:50.140 --> 21:52.140
它不行 它要传就一起传

21:52.140 --> 21:54.140
是这么一回事

21:54.140 --> 21:56.140
根本原因在这

21:56.140 --> 21:57.140
它不能分割

21:57.140 --> 21:59.140
一分割 我就搞不清楚了

21:59.140 --> 22:00.140
比方说吧

22:00.140 --> 22:02.140
我现在柯无端请求了

22:02.140 --> 22:03.140
两个文件

22:03.140 --> 22:05.140
一个介石 一个CSS

22:05.140 --> 22:07.140
你不能给柯无端先传一段介石

22:07.140 --> 22:09.140
再传一段CSS

22:09.140 --> 22:11.140
柯无端那边是懵的呀

22:11.140 --> 22:12.140
是懵的呀

22:12.140 --> 22:14.140
就好必说你在这个聊天的时候

22:14.140 --> 22:17.140
你今年就是

22:17.140 --> 22:18.140
你问了两个问题

22:18.140 --> 22:19.140
第一个问题

22:19.140 --> 22:22.140
你家乡在哪呢

22:22.140 --> 22:24.140
比方说家乡在成都

22:24.140 --> 22:26.140
第二个问题是

22:26.140 --> 22:28.140
你今年多大了呀

22:28.140 --> 22:30.140
那么他如果说打断来毁立的话

22:30.140 --> 22:32.140
他可能就会这样子毁立

22:32.140 --> 22:34.140
正常回是这样子毁的吧

22:34.140 --> 22:36.140
成都 今年多大了

22:36.140 --> 22:38.140
他如果说打断了毁立

22:38.140 --> 22:40.140
他就可能是这样毁的了

22:40.140 --> 22:44.930
成一 都八

22:44.930 --> 22:45.930
这些东西

22:45.930 --> 22:47.930
柯无端就完全看不懂是啥意思了

22:47.930 --> 22:49.930
他不能拆分的

22:49.930 --> 22:51.930
这是他根源的问题

22:51.930 --> 22:53.930
遭解决不了对头组设

22:53.930 --> 22:55.930
那么至于这个问题

22:55.930 --> 22:56.930
该怎么解决

22:56.930 --> 22:57.930
如何来解决对头组设

22:57.930 --> 22:59.930
只能靠ATP2

22:59.930 --> 23:01.930
所以说有了ATP2的时候

23:01.930 --> 23:03.930
像以前过去的一些旧办法

23:03.930 --> 23:05.930
就没有什么意义了

23:05.930 --> 23:07.930
像什么血币图没有啥意义了

23:07.930 --> 23:09.930
每个图片就有一个图标

23:09.930 --> 23:10.930
没有问题了

23:10.930 --> 23:11.930
包括那个是

23:11.930 --> 23:13.930
像什么你要去用不同的域名

23:13.930 --> 23:14.930
去开很多的琴球

23:14.930 --> 23:15.930
也没有多少意义了

23:15.930 --> 23:17.930
只不过有些网站为了监聋

23:17.930 --> 23:19.930
还得这么去做

23:19.930 --> 23:21.930
ATP2.0

23:21.930 --> 23:23.930
首先第一个大家要了解的是

23:23.930 --> 23:25.930
这里使用的是网络试诚协议

23:25.930 --> 23:27.930
我们之前讲网络误程协议的时候

23:27.930 --> 23:29.930
最早的时候是试诚协议

23:29.930 --> 23:30.930
他用试诚协议来画的

23:30.930 --> 23:32.930
我是网上找了一张图

23:32.930 --> 23:34.930
首先这是传输程的TCP协议

23:36.930 --> 23:39.930
然后上面的TCP上

23:39.930 --> 23:40.930
给它加了一个绘画程

23:40.930 --> 23:42.930
绘画程就是那个

23:42.930 --> 23:44.930
做安全的

23:44.930 --> 23:45.930
做安全用的

23:45.930 --> 23:47.930
就是我们讲过的TLS

23:47.930 --> 23:49.930
有一些课我们专门讲这个

23:49.930 --> 23:52.930
当时是跟那个SSL

23:52.930 --> 23:55.930
TLS和ATPS一起讲的

23:55.930 --> 23:57.930
也就是我们ATP2这个协议

23:57.930 --> 24:00.930
它必须要运行在安全模式之上

24:00.930 --> 24:02.930
就是你普通的ATP连接大就不行了

24:02.930 --> 24:04.930
它必须是ATPS

24:04.930 --> 24:06.930
这是第一个我们看到的特点

24:06.930 --> 24:08.930
第二个它会加了一个协议

24:08.930 --> 24:10.930
叫做Banner-FreeMe

24:10.930 --> 24:12.930
叫做二进制Zen

24:12.930 --> 24:13.930
那么这是一个什么东西

24:13.930 --> 24:14.930
我们马上来讲

24:14.930 --> 24:17.930
ATP2.0它解决的最大的问题就是

24:17.930 --> 24:18.930
对头组设的问题

24:18.930 --> 24:19.930
这个问题一定要解决

24:19.930 --> 24:20.930
不解决要死人

24:20.930 --> 24:21.930
那真的是

24:21.930 --> 24:23.930
现在网站上这么多丰富的资源

24:23.930 --> 24:24.930
传输量这么大

24:24.930 --> 24:25.930
你再不解决对头组设

24:25.930 --> 24:27.930
真的要崩溃了

24:27.930 --> 24:29.930
那么怎么解决的呢

24:29.930 --> 24:31.930
它就是二进制Zen

24:31.930 --> 24:33.930
简单的说就是什么

24:33.930 --> 24:36.930
以前传输单元就是一个ATP稳当

24:36.930 --> 24:39.930
头合体是一个整体你不能分割

24:39.930 --> 24:40.930
有了这个东西之后

24:40.930 --> 24:43.930
你可以把它拆分成很小很小的单元

24:43.930 --> 24:44.930
我先给你传一点

24:44.930 --> 24:46.930
然后再给你传一点

24:46.930 --> 24:47.930
再给你传一点

24:47.930 --> 24:49.930
就是我只要按照顺序

24:49.930 --> 24:50.930
一次给你传就行了

24:50.930 --> 24:52.930
我可以把它切分

24:52.930 --> 24:55.930
每一个切分的单元就是二进制Zen

24:55.930 --> 24:57.930
我们来了解一下它的基本概念

24:57.930 --> 24:59.930
ATP2.0允许

24:59.930 --> 25:01.930
以更小的单元来进行传输数据

25:01.930 --> 25:03.930
每一个传输单元

25:03.930 --> 25:04.930
称之为Zen

25:04.930 --> 25:06.930
就Zen就不能再拆分了

25:06.930 --> 25:08.930
最小就是Zen了

25:08.930 --> 25:10.930
那么那每一个Zen多少数据呢

25:10.930 --> 25:11.930
它的名字要有Zen

25:11.930 --> 25:13.930
它每个Zen是多少数据量呢

25:13.930 --> 25:14.930
那就不一定了

25:14.930 --> 25:16.930
那个东西我们也不用去考虑

25:16.930 --> 25:18.930
每一个请求或响应

25:18.930 --> 25:20.930
请求是不是一段数据发过去

25:20.930 --> 25:23.930
照号密码请求头一起发过去

25:23.930 --> 25:25.930
响应是不是一段数据

25:25.930 --> 25:27.930
响应头还有什么状态吗

25:27.930 --> 25:30.930
还有什么那个整个响应体的内容

25:30.930 --> 25:32.930
总之呢这些都是数据

25:32.930 --> 25:34.930
我们把一个请求

25:34.930 --> 25:36.930
或者是一个响应

25:36.930 --> 25:38.930
它整个的数据称之为牛

25:38.930 --> 25:42.940
就相当于是

25:42.940 --> 25:44.940
牛据相当于是一个ATP文档

25:44.940 --> 25:45.940
头合体

25:45.940 --> 25:47.940
整个就叫做牛

25:47.940 --> 25:49.940
牛可以分成很多的小的Zen

25:49.940 --> 25:51.940
原来的意思吧

25:51.940 --> 25:52.940
牛是可以分成很像的

25:52.940 --> 25:53.940
这有点像什么呢

25:53.940 --> 25:55.940
现实生活中不是那么好举例的

25:55.940 --> 25:58.940
就有点像什么你跟别人在微信聊天

25:58.940 --> 26:00.940
但是呢你们都用了一些插件

26:00.940 --> 26:02.940
或者是网上去买了一些工具

26:02.940 --> 26:04.940
跟同一个人聊天

26:04.940 --> 26:06.940
我可以开多个微信窗口

26:06.940 --> 26:08.940
聊的都是同一件事

26:08.940 --> 26:10.940
但是我用多个窗口给你聊

26:10.940 --> 26:13.940
就相当于是这么一个情况

26:13.940 --> 26:16.940
整个聊天的过程就是牛

26:16.940 --> 26:18.940
然后呢其中一个人就是Zen

26:18.940 --> 26:20.940
每一个窗口就是一个Zen

26:21.940 --> 26:23.940
算了我还是不距离的

26:23.940 --> 26:24.940
还是容易产生起义

26:24.940 --> 26:26.940
总之整个请求

26:26.940 --> 26:27.940
整个响应就是牛

26:27.940 --> 26:29.940
它的牛里边有很多数据

26:29.940 --> 26:31.940
那么把每一个数据拆分出来

26:31.940 --> 26:33.940
就形成Zen

26:33.940 --> 26:35.940
所以每一个牛还有自己的编号

26:35.940 --> 26:37.940
比方我这一次请求

26:37.940 --> 26:39.940
我这个请求编号是100

26:39.940 --> 26:41.940
那么这个请求编号

26:41.940 --> 26:43.940
我们请求里面的所有内容

26:43.940 --> 26:44.940
请求头请求体

26:44.940 --> 26:45.940
我可以把分段分段分段

26:45.940 --> 26:47.940
拆分成很多的小段

26:47.940 --> 26:48.940
每一个小段就是Zen

26:48.940 --> 26:50.940
每一个Zen会记录

26:50.940 --> 26:52.940
它自己属于哪一个牛

26:52.940 --> 26:53.940
我这一个小段

26:53.940 --> 26:54.940
里面有个ABC

26:54.940 --> 26:56.940
那这个ABC是哪来的呢

26:56.940 --> 26:57.940
是GS代吗

26:57.940 --> 26:59.940
GS是要请求GS

26:59.940 --> 27:01.940
还是请求CSS

27:01.940 --> 27:03.940
那么我可以标记一下

27:03.940 --> 27:06.940
标记这个ABC是属于编号100的牛

27:06.940 --> 27:07.940
它就知道了

27:07.940 --> 27:09.940
是属于哪一次请求

27:09.940 --> 27:10.940
哪一次响应用的

27:10.940 --> 27:12.940
懂了意思吧

27:12.940 --> 27:13.940
比方说就举个例子

27:13.940 --> 27:14.940
福奇连续收到了

27:14.940 --> 27:15.940
科普端两个请求

27:15.940 --> 27:16.940
一个请求GS

27:16.940 --> 27:17.940
一个请求CSS

27:17.940 --> 27:20.940
福奇那边要响应的东西

27:20.940 --> 27:21.940
GS要响应这个

27:21.940 --> 27:23.940
CSS要响应这个

27:23.940 --> 27:25.940
那么这个时候福奇那边

27:25.940 --> 27:27.940
使用ATP2协议的话

27:27.940 --> 27:29.940
那么它就会把它进行拆分

27:29.940 --> 27:30.940
拆分成不同的Zen

27:30.940 --> 27:32.940
当然像这么小的内容

27:32.940 --> 27:34.940
可能就不会拆分了

27:34.940 --> 27:35.940
就一个Zen就完了

27:35.940 --> 27:36.940
但是如果说内容大的话

27:36.940 --> 27:37.940
就会进行拆分

27:37.940 --> 27:38.940
它怎么拆分呢

27:38.940 --> 27:39.940
你看

27:39.940 --> 27:41.940
有可能形成的Zen格式乳下

27:41.940 --> 27:43.940
我这里只是让大家好理解

27:44.940 --> 27:46.940
你看GS它会拆分为

27:46.940 --> 27:48.940
比方说拆成3Zen

27:48.940 --> 27:50.940
第一Zen传的是

27:50.940 --> 27:51.940
我不是响应吗

27:51.940 --> 27:53.940
响应是不是有个响应头

27:53.940 --> 27:54.940
对吧

27:54.940 --> 27:56.940
响应剂也是这个header

27:56.940 --> 27:58.940
包括里边什么

27:58.940 --> 27:59.940
响应状态码

27:59.940 --> 28:01.940
还有什么那个缓存指令

28:01.940 --> 28:02.940
等等等等

28:02.940 --> 28:04.940
就是响应头

28:04.940 --> 28:05.940
那么每一个

28:05.940 --> 28:07.940
这就是这个Zen的数据

28:07.940 --> 28:09.940
我们把它叫做Payload

28:09.940 --> 28:11.940
复贺有效再贺

28:11.940 --> 28:13.940
总之就是每一Zen的数据

28:13.940 --> 28:15.940
每一Zen数据前面

28:15.940 --> 28:16.940
它会加一个头

28:16.940 --> 28:17.940
是不是有点像那个

28:17.940 --> 28:18.940
五成网络协议里边

28:18.940 --> 28:19.940
把每一层给它加个头

28:19.940 --> 28:21.940
就是这个东西

28:21.940 --> 28:22.940
就是这个东西

28:22.940 --> 28:24.940
它会给它加一个头

28:24.940 --> 28:26.940
那么这个东西就是

28:26.940 --> 28:27.940
头里边记录什么

28:27.940 --> 28:29.940
记录Zen是属于哪一个流的

28:29.940 --> 28:30.940
然后Zen是响应

28:30.940 --> 28:31.940
我给它编个号

28:31.940 --> 28:32.940
流是1

28:32.940 --> 28:34.940
响应剂也是个流是1

28:34.940 --> 28:36.940
我就说出了流是1

28:36.940 --> 28:37.940
那么Zen

28:37.940 --> 28:38.940
它的内形是什么呢

28:38.940 --> 28:40.940
内形是我们的响应头

28:42.940 --> 28:43.940
这里是不是有状态码

28:43.940 --> 28:44.940
这种也是响应头

28:44.940 --> 28:45.940
好

28:45.940 --> 28:46.940
第二Zen

28:46.940 --> 28:48.940
可能是响应体的一部分

28:49.940 --> 28:50.940
同样的变

28:50.940 --> 28:51.940
同样的记录

28:51.940 --> 28:52.940
这一Zen是属于哪个流的

28:52.940 --> 28:53.940
然后呢

28:53.940 --> 28:55.940
这个内形是响应体

28:55.940 --> 28:56.940
好

28:56.940 --> 28:57.940
这一Zen属于哪个流的

28:57.940 --> 28:58.940
内形是响应体

28:58.940 --> 28:59.940
对吧

28:59.940 --> 29:00.940
它就把差分成3Zen

29:00.940 --> 29:01.940
那么CSS也是一样

29:01.940 --> 29:03.940
先有一个响应头

29:03.940 --> 29:04.940
然后呢

29:04.940 --> 29:05.940
所属的流

29:05.940 --> 29:06.940
变后又变了

29:06.940 --> 29:07.940
变成2了

29:07.940 --> 29:08.940
响应头

29:08.940 --> 29:09.940
你看这样做的好处是什么呢

29:09.940 --> 29:11.940
好处它的顺序啊

29:11.940 --> 29:13.940
它就可以乱来了

29:13.940 --> 29:15.940
你可以先响应它

29:16.940 --> 29:18.940
然后再响应它

29:18.940 --> 29:20.940
然后再响应它

29:20.940 --> 29:22.940
再响应它

29:22.940 --> 29:23.940
再响应它

29:23.940 --> 29:24.940
再响应它

29:24.940 --> 29:25.940
是不是没问题

29:25.940 --> 29:26.940
客户端那边能不能分清楚

29:26.940 --> 29:27.940
能

29:27.940 --> 29:28.940
它能分清楚

29:28.940 --> 29:29.940
为什么

29:29.940 --> 29:30.940
因为这里七一度了

29:30.940 --> 29:31.940
这个东西

29:31.940 --> 29:32.940
就好必聊天的时候

29:32.940 --> 29:34.940
你连续问了五个问题

29:34.940 --> 29:35.940
对方不按顺序回答

29:35.940 --> 29:36.940
但他每次回答的时候

29:36.940 --> 29:37.940
前面加个编号

29:37.940 --> 29:38.940
对吧

29:38.940 --> 29:39.940
你问

29:39.940 --> 29:40.940
有房吗

29:40.940 --> 29:41.940
三个问题吧

29:41.940 --> 29:42.940
有房吗

29:42.940 --> 29:43.940
有车吗

29:43.940 --> 29:44.940
有钱吗

29:44.940 --> 29:45.940
好

29:45.940 --> 29:46.940
它可以回答

29:46.940 --> 29:47.940
二

29:47.940 --> 29:48.940
这样回答

29:50.940 --> 29:52.940
你问问的是什么

29:52.940 --> 29:53.940
一编号嘛

29:53.940 --> 29:54.940
对每一个请求

29:54.940 --> 29:55.940
想一道编号

29:56.940 --> 29:57.940
有房吗

29:58.940 --> 29:59.940
第二个问题

29:59.940 --> 30:00.940
有车吗

30:00.940 --> 30:01.940
第三个问题

30:01.940 --> 30:02.940
有钱吗

30:02.940 --> 30:03.940
好

30:03.940 --> 30:04.940
它回答的时候

30:04.940 --> 30:05.940
可以不按顺序回答

30:06.940 --> 30:07.940
二

30:07.940 --> 30:08.940
没有

30:08.940 --> 30:09.940
一

30:09.940 --> 30:10.940
有

30:10.940 --> 30:11.940
二

30:11.940 --> 30:12.940
三

30:12.940 --> 30:13.940
对吧

30:13.940 --> 30:14.940
它可以用这种方式来回答

30:14.940 --> 30:15.940
就这么个意思

30:16.940 --> 30:18.940
那么就是对编号的

30:18.940 --> 30:19.940
就是把裁分的更小的争

30:19.940 --> 30:21.940
然后对编号的这么一个好处

30:22.940 --> 30:23.940
好

30:23.940 --> 30:24.940
这里下面一张图

30:24.940 --> 30:25.940
可以看得很清楚

30:25.940 --> 30:26.940
那么现在我们就能不能解决

30:26.940 --> 30:28.940
对头主色的问题了

30:28.940 --> 30:29.940
就解决了

30:29.940 --> 30:30.940
你看

30:30.940 --> 30:31.940
请求

30:31.940 --> 30:32.940
可以

30:32.940 --> 30:34.940
这样子直接到哪

30:34.940 --> 30:35.940
对吧

30:35.940 --> 30:36.940
它没有对头主色

30:36.940 --> 30:37.940
所以说就可以这样的来了

30:37.940 --> 30:39.940
同时发出这些请求

30:39.940 --> 30:40.940
然后呢

30:40.940 --> 30:41.940
它先处理完

30:41.940 --> 30:42.940
你就想一遍

30:42.940 --> 30:43.940
因为我这里就告诉它

30:43.940 --> 30:44.940
我属于哪个流的

30:44.940 --> 30:45.940
对吧

30:45.940 --> 30:46.940
但是这里面会拆成很多的针

30:46.940 --> 30:47.940
给它一个一个发过去

30:47.940 --> 30:48.940
一个个发过去

30:48.940 --> 30:50.940
也可能把多个针呢

30:50.940 --> 30:51.940
组合到一块

30:51.940 --> 30:52.940
交给TCP

30:52.940 --> 30:53.940
让它一起发过去

30:53.940 --> 30:54.940
都有可能

30:54.940 --> 30:55.940
总之裁分人针发过去

30:55.940 --> 30:56.940
那么每一个针

30:56.940 --> 30:58.940
它是都有标记

30:58.940 --> 30:59.940
我一个针是属于哪个流的

30:59.940 --> 31:00.940
说客不当一收到

31:00.940 --> 31:01.940
你是

31:01.940 --> 31:02.940
这一次想意是针对

31:02.940 --> 31:03.940
这个东西

31:03.940 --> 31:04.940
我就知道了

31:04.940 --> 31:05.940
对吧

31:05.940 --> 31:06.940
这里是编号1

31:06.940 --> 31:07.940
这里是编号1

31:07.940 --> 31:08.940
这里是编号2

31:09.940 --> 31:10.940
然后想意的时候

31:10.940 --> 31:11.940
这里就是要带一个

31:11.940 --> 31:12.940
流的ID2

31:12.940 --> 31:13.940
说这边就知道了

31:13.940 --> 31:14.940
那这里想意的时候

31:14.940 --> 31:15.940
带一个流的ID1

31:15.940 --> 31:16.940
这边就知道了

31:16.940 --> 31:17.940
它可以不按顺序想意

31:17.940 --> 31:19.940
对头主色就没问题了

31:19.940 --> 31:20.940
对不对

31:20.940 --> 31:21.940
那么这种技术呢

31:21.940 --> 31:23.940
我们把它叫做多录附用

31:23.940 --> 31:24.940
什么叫多录附用

31:24.940 --> 31:26.940
就是使用同一套连接

31:26.940 --> 31:27.940
我们互补干扰的

31:27.940 --> 31:29.940
来完成数据的传递

31:30.940 --> 31:31.940
那就多录附用

31:31.940 --> 31:32.940
你看之前ATP1

31:32.940 --> 31:34.940
好像用管道化能实现

31:34.940 --> 31:35.940
这一套

31:35.940 --> 31:36.940
这一套

31:36.940 --> 31:37.940
之前ATP1

31:37.940 --> 31:38.940
好像用管道化能

31:38.940 --> 31:39.940
实现多录附用吧

31:39.940 --> 31:40.940
实现一个

31:40.940 --> 31:42.940
有严重缺陷的多录附用

31:42.940 --> 31:43.940
对吧

31:43.940 --> 31:44.940
所以我们可以认为

31:44.940 --> 31:45.940
它实现不了

31:45.940 --> 31:46.940
因为它有干扰

31:46.940 --> 31:47.940
是不是有干扰

31:47.940 --> 31:48.940
第二次请求

31:48.940 --> 31:49.940
是不是受到

31:49.940 --> 31:50.940
第一次请求的干扰

31:50.940 --> 31:51.940
但是这样子

31:51.940 --> 31:52.940
这种情况就不会

31:52.940 --> 31:53.940
它不会受到干扰

31:53.940 --> 31:54.940
所以说我们这里

31:54.940 --> 31:56.940
实现了真正的多录附用

31:56.940 --> 31:57.940
一个ATP2.0的

31:57.940 --> 31:58.940
一个重要特点

31:58.940 --> 31:59.940
二镜子纷争

31:59.940 --> 32:01.940
实现了多录附用

32:02.940 --> 32:03.940
不仅如此

32:03.940 --> 32:04.940
传输的时候

32:04.940 --> 32:05.940
是以真为单元传输的

32:05.940 --> 32:06.940
所以说无论是请求

32:06.940 --> 32:07.940
还是想用

32:07.940 --> 32:08.940
可以实现并发处理

32:08.940 --> 32:09.940
没事

32:09.940 --> 32:10.940
就是我们刚才说的

32:10.940 --> 32:11.940
可以交替想用

32:12.940 --> 32:13.940
比方说

32:13.940 --> 32:14.940
假设

32:14.940 --> 32:16.940
假设到这个时间点

32:16.940 --> 32:17.940
一也处理完了

32:17.940 --> 32:19.940
二也处理完了

32:19.940 --> 32:21.940
那我可以发一段一

32:21.940 --> 32:22.940
再发一段二

32:22.940 --> 32:23.940
再发一段一

32:23.940 --> 32:24.940
再发一段二

32:24.940 --> 32:25.940
可以这样子

32:25.940 --> 32:26.940
对吧

32:27.940 --> 32:29.940
这样子可以做什么事呢

32:29.940 --> 32:30.940
甚至可以做一些

32:30.940 --> 32:31.940
渐进式图片

32:32.940 --> 32:33.940
就是我们图片

32:33.940 --> 32:35.940
有的是用渐进式图片吧

32:35.940 --> 32:36.940
就是一个小图

32:36.940 --> 32:37.940
对吧

32:37.940 --> 32:38.940
然后了一个

32:38.940 --> 32:39.940
高清图

32:39.940 --> 32:40.940
对吧

32:40.940 --> 32:41.940
我先给他响应小图

32:41.940 --> 32:42.940
让他先能够看到一点

32:42.940 --> 32:43.940
然后再慢慢去

32:43.940 --> 32:44.940
给他响应高清图

32:45.940 --> 32:46.940
有了ATP2的技术

32:46.940 --> 32:47.940
可以做到什么程度

32:47.940 --> 32:49.940
我小图先给他

32:49.940 --> 32:51.940
响应前边

32:51.940 --> 32:53.940
比方说小图用一

32:53.940 --> 32:54.940
高清图用二

32:54.940 --> 32:55.940
对吧

32:55.940 --> 32:57.940
我先给他响应一部分小图

32:57.940 --> 32:58.940
响应一部分

32:58.940 --> 32:59.940
再给他响应一部分高清图

32:59.940 --> 33:01.940
再给他响应一部分小图

33:01.940 --> 33:02.940
再给他响应一部分高清图

33:02.940 --> 33:03.940
可以交替军机

33:04.940 --> 33:05.940
交替军机好处是什么

33:05.940 --> 33:06.940
如果说浏览器支持

33:06.940 --> 33:08.940
以前的好浏览器都支持

33:08.940 --> 33:10.940
就是这个图片你会看上去

33:10.940 --> 33:11.940
是这样子的

33:11.940 --> 33:13.940
它是一点一点往下

33:13.940 --> 33:14.940
刷的

33:14.940 --> 33:16.940
就是它不是整张图片

33:16.940 --> 33:17.940
一下子出来

33:17.940 --> 33:18.940
它是先出来这个图片的

33:18.940 --> 33:20.940
小图的一部分

33:20.940 --> 33:21.940
然后一个小图慢慢变高清了

33:21.940 --> 33:22.940
然后接下来

33:22.940 --> 33:24.940
出现那个小图的第二部分

33:24.940 --> 33:25.940
小图慢慢变高清了

33:25.940 --> 33:27.940
它可以实现这样的技术都可以

33:28.940 --> 33:29.940
所以说

33:29.940 --> 33:30.940
这边可以玩的事情

33:30.940 --> 33:31.940
其实很多的

33:31.940 --> 33:32.940
跟我们没什么关系

33:32.940 --> 33:34.940
我们只需要点几个图片的玩意

33:35.940 --> 33:36.940
然后这是这个

33:36.940 --> 33:37.940
其实这一块

33:37.940 --> 33:39.940
它由于可以交替进行

33:39.940 --> 33:41.940
还可以设置传输优先级

33:41.940 --> 33:43.940
就是每一帧的优先级

33:43.940 --> 33:45.940
像一些头部的帧

33:45.940 --> 33:46.940
我可以优先发送

33:46.940 --> 33:48.940
比较像这种情况

33:48.940 --> 33:51.940
我这里先把头部给他发过去

33:52.940 --> 33:54.940
因为头部里边有些很关键的信息

33:54.940 --> 33:55.940
包括我这里边

33:55.940 --> 33:56.940
我这里是一个什么东西

33:56.940 --> 33:57.940
什么那一种

33:57.940 --> 33:58.940
是一个图片

33:58.940 --> 33:59.940
还是GS

33:59.940 --> 34:00.940
有content的type

34:00.940 --> 34:01.940
还有就是我们的

34:01.940 --> 34:03.940
整个响应的数据长度

34:03.940 --> 34:05.940
头部里边有很多关键信息

34:05.940 --> 34:06.940
我可以先把这两个头部发出去

34:06.940 --> 34:08.940
等下是这个高优先级

34:08.940 --> 34:09.940
然后后边的话

34:09.940 --> 34:10.940
我们慢慢发

34:11.940 --> 34:13.940
甚至有的时候

34:13.940 --> 34:14.940
我在传输着传输着

34:14.940 --> 34:15.940
比方说像这

34:16.940 --> 34:18.940
我先完了

34:18.940 --> 34:19.940
我先传输

34:19.940 --> 34:20.940
然后传输的过程中

34:20.940 --> 34:22.940
突然他也完了

34:22.940 --> 34:23.940
还被传完了

34:23.940 --> 34:24.940
他也完了

34:24.940 --> 34:25.940
那么他一完了

34:25.940 --> 34:27.940
发现他的优先级比较高

34:27.940 --> 34:28.940
我先暂停

34:28.940 --> 34:29.940
你前面的传输

34:29.940 --> 34:31.940
比方这里是一个CSS文件

34:31.940 --> 34:32.940
前面是什么

34:32.940 --> 34:33.940
一个广告图片

34:33.940 --> 34:35.940
然后我觉得广告图片可以慢一点

34:35.940 --> 34:37.940
CSS代表了整个网易的样式

34:37.940 --> 34:38.940
这个很重要了

34:38.940 --> 34:40.940
所以我先把这个文件完了

34:40.940 --> 34:42.940
我先可以暂停之前的发送

34:42.940 --> 34:43.940
他还有一些真没有传完

34:43.940 --> 34:45.940
那么我先传这里

34:45.940 --> 34:46.940
都可以

34:46.940 --> 34:47.940
只有ATP2

34:47.940 --> 34:48.940
他有更小的传输单元

34:48.940 --> 34:49.940
才能实现

34:49.940 --> 34:50.940
我讲了这么多

34:50.940 --> 34:52.940
其实你面试的时候

34:52.940 --> 34:54.940
你不用去回答

34:54.940 --> 34:55.940
回答讲那么细

34:55.940 --> 34:56.940
就是

34:56.940 --> 34:58.940
事实上你们好理解

34:58.940 --> 35:00.940
要和点了就头不压缩

35:00.940 --> 35:02.940
这个点也挺有意思的

35:02.940 --> 35:03.940
他说了什么意思

35:03.940 --> 35:04.940
他就说

35:04.940 --> 35:06.940
你会发现ATP1

35:06.940 --> 35:08.940
1.1

35:08.940 --> 35:09.940
他很多要过

35:09.940 --> 35:10.940
这里边用的是1.1这个版本

35:10.940 --> 35:11.940
你看

35:11.940 --> 35:12.940
里面如果找不到这个的话

35:12.940 --> 35:13.940
你点右键

35:13.940 --> 35:14.940
这里有个Port口

35:14.940 --> 35:15.940
协议

35:15.940 --> 35:17.940
这个1.1这个版本

35:17.940 --> 35:18.940
你去看一下

35:18.940 --> 35:19.940
其实不光是1.1

35:19.940 --> 35:20.940
我们ATP请求里面

35:20.940 --> 35:21.940
不是有头吗

35:21.940 --> 35:22.940
你看那个头

35:22.940 --> 35:23.940
反正付出的都是这个样子

35:23.940 --> 35:24.940
XM

35:24.940 --> 35:25.940
是XM的一头

35:25.940 --> 35:26.940
一边

35:26.940 --> 35:27.940
一大堆

35:27.940 --> 35:28.940
有啥区别

35:28.940 --> 35:29.940
有多少区别

35:29.940 --> 35:30.940
有一点区别说

35:30.940 --> 35:31.940
大概

35:31.940 --> 35:33.940
大体上都是一样的对吧

35:33.940 --> 35:34.940
但是

35:34.940 --> 35:36.940
由于ATP协议的无状态

35:36.940 --> 35:37.940
导致他每一次请求

35:37.940 --> 35:38.940
都要把那个缘分

35:38.940 --> 35:40.940
不动的发一词

35:40.940 --> 35:41.940
是不是疯了

35:41.940 --> 35:42.940
是不是有点疯了

35:42.940 --> 35:43.940
每一次请求

35:43.940 --> 35:44.940
每一次打电话过去

35:44.940 --> 35:45.940
都要来一个

35:45.940 --> 35:46.940
一大段的自我介绍

35:46.940 --> 35:47.940
然后才说正确

35:47.940 --> 35:48.940
正确可能没说几句话

35:48.940 --> 35:50.940
全是自我介绍

35:50.940 --> 35:51.940
这就是头部

35:51.940 --> 35:52.940
给我们网络

35:52.940 --> 35:53.940
带来的负担

35:53.940 --> 35:54.940
好那么

35:54.940 --> 35:55.940
这个问题怎么解决了

35:55.940 --> 35:57.940
ATP2.0是使用

35:57.940 --> 35:58.940
头压缩的

35:58.940 --> 35:59.940
这某一个技术

35:59.940 --> 36:00.940
来解决这个问题

36:00.940 --> 36:01.940
他想的办法其实

36:01.940 --> 36:02.940
很好

36:02.940 --> 36:03.940
都很好的办法

36:03.940 --> 36:04.940
就是双方

36:04.940 --> 36:05.940
有两张表

36:05.940 --> 36:07.940
一张叫做静态表

36:07.940 --> 36:09.940
这张图可能有点小

36:09.940 --> 36:10.940
我把这个复制

36:10.940 --> 36:11.940
到底那一切

36:11.940 --> 36:13.940
给你们放大一点

36:13.940 --> 36:14.940
有两张表

36:14.940 --> 36:15.940
后果端那边

36:15.940 --> 36:16.940
有一张静态表

36:16.940 --> 36:17.940
这个静态表

36:17.940 --> 36:19.940
是协议里边的规定好的

36:19.940 --> 36:21.940
静态表

36:21.940 --> 36:22.940
静态表里边

36:22.940 --> 36:23.940
就描述了

36:23.940 --> 36:24.940
有哪些头部

36:24.940 --> 36:25.940
主要ATP2.0的头部

36:25.940 --> 36:27.940
跟ATP1.0之前的头部

36:27.940 --> 36:29.940
有一些头部有点不一样

36:29.940 --> 36:31.940
凡是带帽号的那种头部

36:31.940 --> 36:33.940
就是静态表里边的那种

36:33.940 --> 36:34.940
你看

36:34.940 --> 36:36.940
淘宝网他使用了很多的

36:36.940 --> 36:37.940
请求就是ATP2

36:37.940 --> 36:38.940
H2你看

36:38.940 --> 36:39.940
H2

36:39.940 --> 36:40.940
那么你看一下

36:40.940 --> 36:41.940
他的头部里边

36:41.940 --> 36:42.940
是不是有这么一些头部

36:42.940 --> 36:43.940
对不对

36:43.940 --> 36:44.940
Skeema表示的协议

36:46.940 --> 36:48.940
那么这个头部

36:48.940 --> 36:50.940
带帽号的头部

36:50.940 --> 36:51.940
就说明这个头部

36:51.940 --> 36:52.940
来自于哪呢

36:52.940 --> 36:53.940
来自于这个

36:54.940 --> 36:55.940
静态表

36:55.940 --> 36:56.940
好像也不能这么说

36:56.940 --> 36:57.940
也不能这么说

36:57.940 --> 36:58.940
这样子也不能这样

36:58.940 --> 36:59.940
离开论

36:59.940 --> 37:00.940
带帽号的头部

37:00.940 --> 37:02.940
其实就是他新增的

37:02.940 --> 37:03.940
就是比方说像这个

37:03.940 --> 37:04.940
像这个Master的

37:04.940 --> 37:05.940
以前在哪

37:05.940 --> 37:07.940
在请求航对不对

37:07.940 --> 37:08.940
是不是在请求航

37:08.940 --> 37:09.940
就第一航

37:09.940 --> 37:10.940
那现在ATP2里边

37:10.940 --> 37:12.940
是没有请求航了

37:12.940 --> 37:13.940
他把他放到头里边去

37:13.940 --> 37:14.940
所以他可以搞了

37:14.940 --> 37:15.940
搞了一个新的头部

37:15.940 --> 37:17.940
出来帽号Master的

37:17.940 --> 37:18.940
加帽号的原因

37:18.940 --> 37:20.940
其实就是防止那个聪明

37:20.940 --> 37:21.940
给你一些自定义的

37:21.940 --> 37:22.940
头部聪明

37:22.940 --> 37:23.940
主要说起这么一个目的

37:23.940 --> 37:24.940
我个人觉得

37:24.940 --> 37:26.940
是起这么一个目的

37:26.940 --> 37:27.940
好那么这里边

37:27.940 --> 37:28.940
他首先两方

37:28.940 --> 37:29.940
客户端也好

37:29.940 --> 37:30.940
服务器也好

37:30.940 --> 37:31.940
准备一张静态表

37:31.940 --> 37:32.940
这个表呢

37:32.940 --> 37:33.940
我这里画了三行

37:33.940 --> 37:34.940
其实我远远不止三行

37:34.940 --> 37:35.940
大家可以去那个

37:35.940 --> 37:38.940
ATP2的那个

37:40.940 --> 37:41.940
文档里边去看

37:41.940 --> 37:42.940
官方标准文档里面

37:42.940 --> 37:44.940
这有个index

37:44.940 --> 37:45.940
indexing table

37:45.940 --> 37:46.940
这里个static table

37:46.940 --> 37:47.940
静态表

37:47.940 --> 37:48.940
你点进去

37:48.940 --> 37:49.940
是不是很多

37:49.940 --> 37:50.940
这个表格里边

37:50.940 --> 37:52.940
有60多个

37:52.940 --> 37:53.940
它啥意思呢

37:53.940 --> 37:54.940
就是说

37:54.940 --> 37:55.940
我把这个

37:55.940 --> 37:56.940
就是我们常见的

37:56.940 --> 37:57.940
一些头部的信息

37:57.940 --> 37:58.940
我都把记录下来

37:58.940 --> 38:00.940
比方说请求方法get

38:00.940 --> 38:01.940
我就改编个号

38:01.940 --> 38:02.940
编号为2

38:02.940 --> 38:03.940
Master的post

38:03.940 --> 38:04.940
编号为3

38:04.940 --> 38:05.940
比方说你PASS

38:05.940 --> 38:06.940
请求的是首页

38:06.940 --> 38:08.940
那我编号为4

38:08.940 --> 38:09.940
为什么又PASS

38:09.940 --> 38:10.940
因为请求行销

38:10.940 --> 38:12.940
是全跑到头里边去了

38:12.940 --> 38:13.940
就做这么一个编号

38:13.940 --> 38:14.940
那么这个编号

38:14.940 --> 38:15.940
客户端和服务器

38:15.940 --> 38:16.940
都是完全一样的

38:16.940 --> 38:18.940
就跟这个表示一模一样的

38:18.940 --> 38:20.940
它不会变化的

38:20.940 --> 38:21.940
客户端一份

38:21.940 --> 38:22.940
服务器一份

38:22.940 --> 38:23.940
有什么好处呢

38:23.940 --> 38:24.940
比方说将来

38:24.940 --> 38:25.940
我要发送一个请求

38:25.940 --> 38:26.940
发送这个Master的

38:26.940 --> 38:27.940
为get的请求

38:27.940 --> 38:28.940
PASS为邪纲的请求

38:28.940 --> 38:29.940
这种请求

38:29.940 --> 38:30.940
我就不用去把这个东西

38:30.940 --> 38:31.940
远风不动

38:31.940 --> 38:32.940
传过来

38:32.940 --> 38:33.940
我传一个二合四

38:33.940 --> 38:34.940
二合四

38:34.940 --> 38:36.940
传两个数字就完事了

38:36.940 --> 38:37.940
你说这个是不是

38:37.940 --> 38:38.940
要解决很多的空间

38:38.940 --> 38:40.940
这样你传过去服务器看

38:40.940 --> 38:41.940
二合四啥意思

38:41.940 --> 38:42.940
查静态表

38:42.940 --> 38:43.940
二合四

38:43.940 --> 38:45.940
你是不是就查出来了

38:45.940 --> 38:47.940
它就用这种模式

38:47.940 --> 38:48.940
这是静态表

38:48.940 --> 38:50.940
静态表的内容很多

38:50.940 --> 38:51.940
还有一张表是动态表

38:51.940 --> 38:54.940
动态表一开始是空的

38:54.940 --> 38:57.940
动态表两方也是都有的

38:57.940 --> 38:58.940
两方一开始

38:58.940 --> 39:00.940
在同一个TCP链接里边

39:00.940 --> 39:02.940
两方一开始都是空的

39:02.940 --> 39:04.940
然后根据后面的请求

39:04.940 --> 39:06.940
不断的去新增内容

39:06.940 --> 39:07.940
那它怎么做的呢

39:07.940 --> 39:09.940
比方说最开始的时候

39:09.940 --> 39:11.940
动态表是空的

39:11.940 --> 39:13.940
这个客户端想发一个

39:13.940 --> 39:15.940
自定义的请求投

39:15.940 --> 39:16.940
想发这个请求投过去

39:16.940 --> 39:17.940
发现什么

39:17.940 --> 39:18.940
发现动态表里边

39:18.940 --> 39:19.940
静态表里边没有

39:19.940 --> 39:21.940
它不能替换人数字

39:21.940 --> 39:22.940
那这个时候怎么办

39:22.940 --> 39:24.940
它只能远风不动地发过去

39:24.940 --> 39:26.940
把这个东西远风不动地发过去

39:26.940 --> 39:28.940
就像跟以前一样

39:28.940 --> 39:31.940
然后同时自己记录一个动态表

39:31.940 --> 39:32.940
记录一下

39:32.940 --> 39:33.940
我之前用了

39:33.940 --> 39:34.940
用到一个头部

39:34.940 --> 39:36.940
二十Token等于这个

39:36.940 --> 39:38.940
那么因为它觉得

39:38.940 --> 39:39.940
你只要发过一次

39:39.940 --> 39:41.940
就很有可能会发第二次

39:41.940 --> 39:42.940
像什么哭泣这些东西

39:42.940 --> 39:43.940
你发了第一次

39:43.940 --> 39:44.940
就会发第二次

39:44.940 --> 39:45.940
后续就一直发

39:45.940 --> 39:46.940
而且内容都一样的

39:46.940 --> 39:47.940
它就会这样认为

39:47.940 --> 39:48.940
它就会加自己

39:48.940 --> 39:50.940
在自己这一方加个动态表

39:50.940 --> 39:51.940
加进去

39:51.940 --> 39:53.940
然后同时把这个发过去

39:53.940 --> 39:54.940
扶起一看这个东西

39:54.940 --> 39:55.940
说明什么

39:55.940 --> 39:57.940
说明客户端那边是没有的

39:57.940 --> 39:58.940
对吧

39:58.940 --> 39:59.940
那它也会在动态表里边

39:59.940 --> 40:00.940
记录一个

40:00.940 --> 40:01.940
记录一个一模一样的

40:01.940 --> 40:03.940
同时这样子

40:03.940 --> 40:04.940
动态表

40:04.940 --> 40:05.940
两个动态表是不是一样了

40:05.940 --> 40:06.940
好 下一次

40:06.940 --> 40:07.940
再发这个请求的时候

40:07.940 --> 40:09.940
如果说遇到一样的请求投

40:09.940 --> 40:10.940
它这个时候

40:10.940 --> 40:11.940
它就不会重新发一次

40:11.940 --> 40:12.940
它只要一个数字

40:12.940 --> 40:13.940
六十一

40:13.940 --> 40:15.940
六十一看静态表没有

40:15.940 --> 40:16.940
那动态表六十一

40:16.940 --> 40:18.940
我就找到了

40:18.940 --> 40:19.940
懂的意思吧

40:19.940 --> 40:20.940
那么通过这种方式

40:20.940 --> 40:22.940
来减缓减少头部

40:22.940 --> 40:23.940
大概能减少多少呢

40:23.940 --> 40:27.940
发开减少20%到30%的体积

40:27.940 --> 40:29.940
还是挺不错的

40:29.940 --> 40:31.940
然后除此之外呢

40:31.940 --> 40:32.940
就是有一个

40:32.940 --> 40:33.940
还有一个

40:33.940 --> 40:35.940
头部压缩的技术叫做

40:35.940 --> 40:36.940
Huffman

40:36.940 --> 40:37.940
翻译过来就是

40:37.940 --> 40:38.940
Huffman或者是

40:38.940 --> 40:39.940
Huffman

40:39.940 --> 40:40.940
Huffman编码

40:40.940 --> 40:41.940
它具体怎么编码的

40:41.940 --> 40:42.940
我们就不用管了

40:42.940 --> 40:43.940
它最近

40:43.940 --> 40:44.940
你知道它是

40:44.940 --> 40:45.940
做压缩算法的就行了

40:45.940 --> 40:46.940
它是做压缩的

40:46.940 --> 40:48.940
进一步压缩头部

40:48.940 --> 40:51.940
就是那个

40:51.940 --> 40:52.940
做这么一个件事

40:52.940 --> 40:53.940
比方说像什么

40:53.940 --> 40:55.940
像我们刚才说的那个情况

40:55.940 --> 40:56.940
就是这边

40:56.940 --> 40:57.940
你第一试的时候

40:57.940 --> 40:58.940
没有这个内容

40:58.940 --> 40:59.940
然后是不是要

40:59.940 --> 41:00.940
发给原文过去

41:00.940 --> 41:01.940
那么这个原文呢

41:01.940 --> 41:02.940
就这一块

41:02.940 --> 41:04.940
它会被进行Huffman编码

41:04.940 --> 41:05.940
像一些哭泣内容

41:05.940 --> 41:07.940
其实很多的你看

41:07.940 --> 41:09.940
有些哭泣

41:09.940 --> 41:11.940
这里没有哭泣

41:12.940 --> 41:13.940
你看哭泣内容

41:13.940 --> 41:14.940
是不是还是挺多的

41:14.940 --> 41:15.940
对吧

41:15.940 --> 41:17.940
那么它会进行Huffman编码

41:17.940 --> 41:18.940
好 OK

41:18.940 --> 41:19.940
你看这个PASS

41:19.940 --> 41:20.940
这个PASS

41:20.940 --> 41:21.940
我们进它表里面没有

41:21.940 --> 41:22.940
这个PASS没有

41:22.940 --> 41:23.940
对吧

41:23.940 --> 41:24.940
这个值得没有

41:24.940 --> 41:25.940
那么这么常常的内容

41:25.940 --> 41:30.150
它就会进行Huffman编码

41:30.150 --> 41:31.150
这是头部压缩

41:31.150 --> 41:32.150
然后还有一个技术

41:32.150 --> 41:33.150
就是服务器推

41:33.150 --> 41:34.150
这是什么意思呢

41:34.150 --> 41:35.150
指责事

41:35.150 --> 41:36.150
ATP2.0

41:36.150 --> 41:37.150
还允许没有

41:37.150 --> 41:38.150
请求的情况下

41:38.150 --> 41:39.150
服务器主动

41:39.150 --> 41:41.150
把职员推送到客户端

41:41.150 --> 41:42.150
对吧

41:42.150 --> 41:43.150
就好必说

41:43.150 --> 41:45.150
给我一个网页

41:45.150 --> 41:46.150
现在还指

41:46.150 --> 41:48.150
网页都还没拿到

41:48.150 --> 41:50.150
服务器那边

41:50.150 --> 41:51.150
正常情况下

41:51.150 --> 41:52.150
你是拿到了网页

41:52.150 --> 41:53.150
一看

41:53.150 --> 41:54.150
原来网页里面需要图片

41:54.150 --> 41:55.150
需要介事

41:55.150 --> 41:56.150
再去请求

41:56.150 --> 41:57.150
服务器推是什么意思呢

41:57.150 --> 41:58.150
就是我打电话过去

41:58.150 --> 41:59.150
我要一个网页

41:59.150 --> 42:00.150
服务器那边

42:00.150 --> 42:01.150
非常暴力的

42:01.150 --> 42:02.150
把网页给了

42:02.150 --> 42:03.150
把图片给了

42:03.150 --> 42:04.150
CSS给了

42:04.150 --> 42:06.150
介事全部一下推给你

42:06.150 --> 42:07.150
甚至把这个网页

42:07.150 --> 42:09.150
觉得你将来有可能

42:09.150 --> 42:10.150
会点别的网页

42:10.150 --> 42:11.150
另外一个网页

42:11.150 --> 42:12.150
另外一个网页东西

42:12.150 --> 42:13.150
我也推给你

42:14.150 --> 42:17.150
所以有点像PrefH

42:17.150 --> 42:18.150
对吧

42:18.150 --> 42:21.150
有点像H5的属性

42:21.150 --> 42:22.150
PrefH

42:22.150 --> 42:23.150
但是这个概念完全不一样

42:23.150 --> 42:25.150
我这个概念是服务器

42:25.150 --> 42:26.150
主动给的

42:26.150 --> 42:27.150
你不用去做任何事情

42:27.150 --> 42:28.150
服务器主动给你

42:28.150 --> 42:30.150
将来你在看页面的时候

42:30.150 --> 42:32.150
你现在手上是不是一堆东西

42:32.150 --> 42:33.150
你现在看页面

42:33.150 --> 42:34.150
一看页面

42:34.150 --> 42:35.150
我需要个CSS

42:35.150 --> 42:36.150
一看

42:36.150 --> 42:37.150
我手上刚好有

42:37.150 --> 42:38.150
我就不用去请求服务器了

42:38.150 --> 42:40.150
是这么一个意思

42:40.150 --> 42:41.150
这是服务器推

42:41.150 --> 42:43.150
它跟我们另外一几颗

42:43.150 --> 42:44.150
叫WebSockets

42:44.150 --> 42:45.150
是完全两罢事

42:46.150 --> 42:47.150
好

42:47.150 --> 42:48.150
那么就讲完了

42:48.150 --> 42:49.150
这就是我们三个协议

42:49.150 --> 42:50.150
其实还有一个协议

42:50.150 --> 42:51.150
就是ATP3.0

42:51.150 --> 42:52.150
3.0的话

42:52.150 --> 42:53.150
我们就不扯了

42:53.150 --> 42:54.150
这不扯了

42:54.150 --> 42:55.150
目前还在草案阶段

42:55.150 --> 42:56.150
好

42:56.150 --> 42:57.150
看一下面试题

42:57.150 --> 42:59.150
介绍一下他们之间的区别

42:59.150 --> 43:00.150
首先以各个说法

43:00.150 --> 43:02.150
1.0无法附用连接

43:02.150 --> 43:03.150
和对头组设

43:03.150 --> 43:04.150
是不是说过的

43:04.150 --> 43:05.150
然后1.1

43:05.150 --> 43:07.150
场链接管道化

43:07.150 --> 43:08.150
是不是说过的

43:08.150 --> 43:09.150
管道化还是解决不了

43:10.150 --> 43:12.150
对头组设的问题

43:12.150 --> 43:13.150
说一下

43:13.150 --> 43:14.150
然后这两个

43:14.150 --> 43:15.150
你了解一下就行了

43:15.150 --> 43:17.150
缓存处理是1.1加的

43:17.150 --> 43:18.150
要开始控制这个

43:18.150 --> 43:19.150
所以我们有捷克

43:19.150 --> 43:20.150
是不是讲缓存的

43:20.150 --> 43:22.150
锻炼传输

43:22.150 --> 43:24.150
也是ATP1.1加的

43:24.150 --> 43:25.150
我们讲了锻炼传输

43:25.150 --> 43:27.150
然后2.0

43:27.150 --> 43:28.150
就把这四个回答一下

43:28.150 --> 43:30.150
一个是二镜子分帧

43:30.150 --> 43:31.150
把它分成了

43:31.150 --> 43:32.150
更小的单位来进行传输

43:32.150 --> 43:35.150
每个帧有一个标识序号

43:35.150 --> 43:37.150
就是标识的

43:37.150 --> 43:38.150
应该就是流的编号

43:38.150 --> 43:39.150
应该正确说

43:39.150 --> 43:41.150
应该是流的编号

43:41.150 --> 43:43.150
多录复用

43:43.150 --> 43:45.150
这里我给它说一下

43:45.150 --> 43:48.150
这个随意打乱是什么意思

43:48.150 --> 43:49.150
随意打乱

43:49.150 --> 43:51.150
就是它跟不同的流之间

43:51.150 --> 43:52.150
可以被打乱

43:52.150 --> 43:53.150
就是它完了过后

43:53.150 --> 43:54.150
可以传输它

43:54.150 --> 43:55.150
可以传输它

43:55.150 --> 43:56.150
然后再传输它

43:56.150 --> 43:57.150
这个没问题

43:57.150 --> 43:58.150
但是同一个流里边

43:58.150 --> 43:59.150
是不能乱的

43:59.150 --> 44:00.150
你不能先传它

44:00.150 --> 44:01.150
再传它

44:01.150 --> 44:02.150
是不行的

44:02.150 --> 44:04.150
同一个流是不能乱的

44:04.150 --> 44:06.150
再给它说一下

44:07.150 --> 44:09.150
然后就是

44:10.150 --> 44:11.150
头部压缩 服务器推

44:11.150 --> 44:12.150
都讲过了

44:12.150 --> 44:13.150
然后为什么ATB 1.1

44:13.150 --> 44:15.150
不能实现多录复用

44:15.150 --> 44:16.150
根本原因就在

44:16.150 --> 44:17.150
因为它传输的是

44:17.150 --> 44:18.150
整个响应文本

44:18.150 --> 44:20.150
就整个ATP文档

44:20.150 --> 44:23.150
所以接触方案必须要按续接收

44:23.150 --> 44:24.150
中间不能穿插

44:24.150 --> 44:25.150
任何别的东西

44:25.150 --> 44:26.150
它必须要收完

44:26.150 --> 44:27.150
所有内容过后

44:27.150 --> 44:29.150
才能接收下一个传输单元

44:29.150 --> 44:30.150
它就必须要按照那种

44:30.150 --> 44:31.150
一次接收

44:31.150 --> 44:32.150
真是因为一次接收

44:32.150 --> 44:34.150
就造成了对头组设

44:34.150 --> 44:35.150
真是因为对头组设

44:35.150 --> 44:36.150
就造成了多录复用

44:36.150 --> 44:38.150
造成了不能使用多录复用

44:38.150 --> 44:40.150
就这个原因

44:40.150 --> 44:42.150
为什么会对头组设

44:42.150 --> 44:43.150
因为它前一个没收完

44:43.150 --> 44:45.150
后一个只能等着

44:45.150 --> 44:47.150
就是这个问题

44:47.150 --> 44:49.150
而ATB 2.0传输单元更小

44:49.150 --> 44:50.150
是一个二斤子针

44:50.150 --> 44:52.150
每个针它有个流变号

44:52.150 --> 44:53.150
所以说

44:53.150 --> 44:55.150
即便是不同的流交替传输

44:55.150 --> 44:56.150
也可以很容易区分

44:56.150 --> 44:58.150
是属于哪个流的

44:58.150 --> 45:00.150
好 简单闪述一下

45:00.150 --> 45:03.150
ATB 2的多录复用

45:03.150 --> 45:04.150
你自己看一下

45:04.150 --> 45:06.150
应该能看懂

45:06.150 --> 45:08.150
1.1是如何复用TCP连接的

45:08.150 --> 45:11.150
有讲过的

45:11.150 --> 45:13.150
在请求头里面附带这个东西

45:13.150 --> 45:15.150
其实1.1是可以不用附带的

45:15.150 --> 45:17.150
附带的东西是为了保持兼容

45:17.150 --> 45:19.150
高手伏计是个常连接

45:19.150 --> 45:21.150
让它不要去关闭TCP连接

45:21.150 --> 45:22.150
可以减少三次握手

45:22.150 --> 45:23.150
和四次回手的数量

45:23.150 --> 45:24.150
一定程度提升了

45:24.150 --> 45:25.150
网络利用率

45:25.150 --> 45:27.150
但是不能实现多录复用

45:27.150 --> 45:28.150
这里三个的区别

45:28.150 --> 45:31.150
那我就整样说一下3.0吧

45:31.150 --> 45:33.150
ATP 2仍然有问题

45:33.150 --> 45:34.150
出来过后

45:34.150 --> 45:36.150
这个问题就已经被发现了

45:36.150 --> 45:37.150
出来过正式发布之后

45:37.150 --> 45:39.150
就已经被发现了

45:39.150 --> 45:40.150
什么问题呢

45:40.150 --> 45:43.150
它解决不了TCP的对头注射

45:43.150 --> 45:46.150
TCP还有对头注射

45:46.150 --> 45:47.150
这个问题

45:47.150 --> 45:49.150
那ATP是一点招都没了

45:49.150 --> 45:50.150
为什么呢

45:50.150 --> 45:54.170
因为它用的就是TCP

45:54.170 --> 45:57.860
我只要简单说一下

45:57.860 --> 45:59.860
什么意思呢

45:59.860 --> 46:01.860
比方说

46:01.860 --> 46:02.860
简单说一下

46:02.860 --> 46:03.860
很能力也就得

46:03.860 --> 46:04.860
算了

46:04.860 --> 46:05.860
一遍3.0就像你面试的时候

46:05.860 --> 46:06.860
回答不出来也没事

46:06.860 --> 46:07.860
目前毕竟还在吵

46:07.860 --> 46:09.860
比方说服务器响应的顺序

46:09.860 --> 46:11.860
是这样子的

46:11.860 --> 46:12.860
一

46:12.860 --> 46:13.860
二

46:13.860 --> 46:20.580
三

46:20.580 --> 46:22.580
比方说

46:22.580 --> 46:24.580
假设

46:24.580 --> 46:26.580
它把第一帧交给TCP去传输

46:26.580 --> 46:27.580
然后传输没问题

46:27.580 --> 46:28.580
传过去了

46:28.580 --> 46:29.580
然后再把第二帧

46:29.580 --> 46:32.580
交给TCP去传输

46:32.580 --> 46:34.580
第三个在等着

46:34.580 --> 46:35.580
等着传

46:35.580 --> 46:37.580
然后第二帧

46:37.580 --> 46:38.580
丢失了

46:38.580 --> 46:40.580
中间网络原因丢失了

46:40.580 --> 46:42.580
TCP的特点是要解决可靠性

46:42.580 --> 46:45.580
它而且要按顺序来传输内容

46:45.580 --> 46:47.580
由于第二帧丢失

46:47.580 --> 46:49.580
所以说TCP呢

46:49.580 --> 46:51.580
它不敢传第三帧

46:51.580 --> 46:53.580
它只能重传第二帧

46:53.580 --> 46:55.580
懂的意思吧

46:55.580 --> 46:57.580
但是实际上呢

46:57.580 --> 46:59.580
第三帧可不可以传

46:59.580 --> 47:00.580
可以传

47:00.580 --> 47:01.580
因为第三帧是属于不同的流的

47:01.580 --> 47:03.580
传过去不影响

47:03.580 --> 47:05.580
但是TCP它不知道

47:05.580 --> 47:07.580
TCP它必须要按照顺序来传输

47:07.580 --> 47:09.580
所以说第三帧就被注射了

47:09.580 --> 47:11.580
这叫做TCP的注射

47:11.580 --> 47:13.580
这个问题就有点深了

47:13.580 --> 47:16.580
为了解决这个问题呢

47:16.580 --> 47:17.580
它实在是没招了

47:17.580 --> 47:19.580
因为它不可能去改TCP

47:19.580 --> 47:22.580
因为TCP不是专门为ATP服务的

47:22.580 --> 47:25.580
它还要为很多其他的上层的协议服务

47:25.580 --> 47:26.580
它不可能去改TCP

47:26.580 --> 47:28.580
怎么办 它就抛弃TCP了

47:28.580 --> 47:29.580
它没招了

47:29.580 --> 47:30.580
它就使用了UDP

47:30.580 --> 47:32.580
UDP就是非常简洁

47:32.580 --> 47:34.580
也没有任何可靠性的协议

47:34.580 --> 47:35.580
那可靠性怎么解决呢

47:35.580 --> 47:37.580
它自己搞了一个协议叫quick协议

47:37.580 --> 47:40.580
这个quick协议跟那个TCP

47:40.580 --> 47:41.580
基本上一样

47:41.580 --> 47:43.580
它就是把这个问题解决了

47:43.580 --> 47:44.580
把这个问题解决了

47:44.580 --> 47:46.580
把那个流编号

47:46.580 --> 47:47.580
那些流的编号

47:47.580 --> 47:49.580
直接放到这个协议里面去了

47:49.580 --> 47:50.580
懂了意思吧

47:50.580 --> 47:52.580
它把流编号放到这个协议里面去了

47:52.580 --> 47:54.580
所以它为什么搞

47:54.580 --> 47:55.580
为什么不基于ATP2呢

47:55.580 --> 47:57.580
因为流编号跑到这个协议里面去了

47:57.580 --> 47:59.580
上面就没有必要使用流编号了

47:59.580 --> 48:01.580
它必须要搞一个新的协议出来

48:02.580 --> 48:04.580
8个了解一下就行了

48:04.580 --> 48:07.580
这个ATP3的优化是非常非常彻底的

48:07.580 --> 48:09.580
现在目前还在吵

48:09.580 --> 48:10.580
大家拭目以待吧

48:10.580 --> 48:12.580
OK 这就是关于这个

48:12.580 --> 48:13.580
这一刻的内容

