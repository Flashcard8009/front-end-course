WEBVTT

00:00.500 --> 00:05.300
好 我们这一课呢来总结一下网络性能优化的一些方案

00:05.300 --> 00:09.300
总结这些方案呢 我们不去讲具体的每一个知识点

00:09.300 --> 00:13.300
因为它是分散在我们的整个比面式课程里面

00:13.300 --> 00:14.900
分成很多的课的

00:14.900 --> 00:18.100
所以我们这里来对它做一个汇总来总结

00:18.100 --> 00:24.700
有哪些方法呢 网络传输我们无非就是想提高网络传输的速度

00:24.700 --> 00:26.300
对吧 让它传的更快

00:26.300 --> 00:30.300
或者是利用一些手段让它尽量有些东西可以不传输

00:31.300 --> 00:36.300
那么我们一个来说 首先最重要的就是要优化打包体积

00:36.300 --> 00:43.300
就是我们无论是用维尤写的 还是我们一些原生的介石 原生的工程写的

00:43.300 --> 00:47.300
我们最后都需要打包 打包呢就会通过一些构建工具

00:47.300 --> 00:50.300
像什么WePike这种构建工具来进行打包

00:50.300 --> 00:54.300
那么打包之后呢 我们希望这些工具对我们进行压缩 代码压缩

00:54.300 --> 00:57.300
去掉换行啊 去掉一些不必要的空格

00:58.300 --> 01:01.300
然后呢 婚姻小最终代码打包代码

01:01.300 --> 01:05.300
比方说像有一些便量名字很长 那么打包之后呢 它会变得很短

01:05.300 --> 01:09.300
那么这些都是一些工具可以帮我们自动完成的

01:09.300 --> 01:12.300
我们只需要输入一个命令 比方说像我们的伍佑里面

01:12.300 --> 01:15.300
我们是不是输入一个命令啊 叫npmronbuild

01:15.300 --> 01:19.300
对吧 那么它就完成打包 这件事情它会自动的去完成

01:19.300 --> 01:22.300
那么这些做法呢 都是为了减少打包体积

01:22.300 --> 01:25.300
减少打包体积 比方说一开始你的介石

01:25.300 --> 01:28.300
介石是一招

01:28.300 --> 01:33.300
那么打包之后呢 可能只有那个500kb

01:33.300 --> 01:36.300
然后呢 我们还可以对 还可以进行一些压缩

01:36.300 --> 01:42.300
比方说用GZIP压缩 压缩之后呢 我们可能会只有得到100多kb

01:42.300 --> 01:46.300
这就是首先要优化这个体积 体积是要了

01:46.300 --> 01:51.300
我们整个传输的速度的自然 传输的时间的自然就减少了

01:51.300 --> 01:53.300
这是第一步啊

01:53.300 --> 01:57.300
然后呢 我们还可以使用多目标打包 什么意思呢

01:57.300 --> 02:00.300
就是我们打包体积 它为什么会大

02:00.300 --> 02:05.300
是因为里边呢 可能会加了很多的一些兼容性代码

02:05.300 --> 02:09.300
比方说大家学过那个 将构建工具里边 像WePike里边

02:09.300 --> 02:12.300
打包的时候 我们一般都会给它加上一个东西

02:12.300 --> 02:15.300
叫做bable 那么这个是用来处理兼容性问题的

02:15.300 --> 02:17.300
因为一些旧版本人的浏览器呢

02:17.300 --> 02:21.300
它不太兼容一些新的语法啊 一些新的APM兼容

02:21.300 --> 02:24.300
所以说我们会对它进行用兼容处理

02:24.300 --> 02:27.300
那兼容处理呢 你自然而然这个体积变大了

02:27.300 --> 02:30.300
以前没有这个APM的 那我们肯定要给它写一个

02:30.300 --> 02:35.300
这些工具还会给你自动写一些APM进去

02:35.300 --> 02:37.300
比方说像Promise

02:38.300 --> 02:40.300
这个玩意儿 旧版本浏览器就没有

02:40.300 --> 02:43.300
没有的话 它就会需要写一个APM进去

02:43.300 --> 02:45.300
那么自然而然会增加打包体积

02:45.300 --> 02:47.300
其实呢 我们分析打包结果里边

02:47.300 --> 02:51.300
很多东西 增加的打包体积都是由于兼容性代码带来的

02:51.300 --> 02:54.300
那么这个兼容性代码到怎么来解决呢

02:54.300 --> 02:58.300
你像 如果说我这个浏览器本身就是一个高版本浏览器

02:58.300 --> 03:01.300
我去访问网站的时候 我需要这些兼容性代码吗

03:01.300 --> 03:04.300
其实并不需要 对吧 只有低版本浏览器才需要

03:04.300 --> 03:07.300
所以说呢 我们可以针对不同的浏览器

03:07.300 --> 03:10.300
形成不同的打包结果 这就是多目标打包

03:10.300 --> 03:12.300
其实我们在做学习无诱的时候

03:12.300 --> 03:15.300
我们也做过 对吧 加上一个特殊的命令

03:16.300 --> 03:17.300
叫做Modem

03:19.300 --> 03:22.300
Modem咋写的 是这样写的吗

03:23.300 --> 03:26.300
就是针对现代浏览器来进行打包

03:26.300 --> 03:28.300
那么它会打包成两个版本

03:28.300 --> 03:30.300
一个版本是针对旧浏览器的

03:30.300 --> 03:32.300
一个版本是针对现代浏览器的

03:32.300 --> 03:34.300
现代浏览器的代码量就会很少

03:34.300 --> 03:36.300
因为它少了很多兼容性的处理代码

03:36.300 --> 03:40.300
这是这种方案 它也是减少打包体积

03:40.300 --> 03:43.300
还就是压缩 其实我们刚才已经说了

03:43.300 --> 03:47.300
我单独拿出来说了一下 就是GZIP压缩

03:49.300 --> 03:52.300
压缩这一块 我们就不单独去开课讲了

03:52.300 --> 03:54.300
大概了解一下就行了

03:54.300 --> 03:57.300
无论是我们现实 就是在操作系统上面

03:57.300 --> 04:02.300
我们进行的 怎么把一些文件打成一个压缩包

04:02.300 --> 04:06.300
那么这个压缩包 它是怎么来压缩体积的呢

04:06.300 --> 04:09.300
其实它用的一种 大家用的思维

04:09.300 --> 04:12.300
整体的思维、原理都差不多

04:12.300 --> 04:15.300
比方说 我们有这么一个制服串

04:16.300 --> 04:18.300
它可能很长 对不对

04:18.300 --> 04:20.300
那么我怎么来对它进行压缩呢

04:20.300 --> 04:21.300
我们可以这样做

04:21.300 --> 04:25.300
我们不用原文 原文的话它体积只能这么大

04:25.300 --> 04:27.300
那怎么来压缩呢 我可以这样子在记录

04:27.300 --> 04:29.300
我这个里边有一个制服A

04:29.300 --> 04:33.300
这个制服A出现的位置是第1个位置

04:33.300 --> 04:36.300
还有多少个位置

04:37.300 --> 04:43.300
就是比方说第8个位置 第10个位置

04:43.300 --> 04:45.300
A出现了3次 出现在这些位置

04:45.300 --> 04:47.300
因为A是一个ASK制服

04:47.300 --> 04:49.300
它是会占用多少体积啊

04:49.300 --> 04:51.300
它会占用一个字节的体积

04:51.300 --> 04:53.300
但是如果说我们把它变成了这种模式的话

04:53.300 --> 04:55.300
变成了一些数字的话

04:55.300 --> 04:57.300
那么占用中的体积会小很多

04:57.300 --> 04:59.300
我们只记录一个ASK制服

04:59.300 --> 05:01.300
那么它会出现哪些位置

05:01.300 --> 05:04.300
然后呢 第1又出现了哪些位置

05:04.300 --> 05:06.300
它用这种方式来记录

05:06.300 --> 05:09.300
那么解压缩的话就是把它缓缘成这么一个制服串

05:09.300 --> 05:11.300
这就是压缩的基本方案

05:11.300 --> 05:13.300
当然我们不去讲具体的它是怎么做的

05:13.300 --> 05:15.300
压缩的里边的算法有很多

05:15.300 --> 05:18.300
其中一种算法叫做ZAP这种算法

05:18.300 --> 05:20.300
那么这种算法是浏览器

05:20.300 --> 05:22.300
基本上都比较支持的算法

05:22.300 --> 05:25.300
所以说呢 网络传输的时候

05:25.300 --> 05:28.300
我可以只给它一浏览器传输一个压缩包GZAP

05:28.300 --> 05:32.300
这些都是工作都不是前端来做的

05:32.300 --> 05:34.300
都是靠谁呢 都是靠运萎来做的

05:34.300 --> 05:37.300
它在部署的时候 它就会去做这些事情

05:37.300 --> 05:40.300
那么传这个压缩包到浏览器

05:40.300 --> 05:41.300
浏览器会自动的解压缩

05:41.300 --> 05:43.300
然后呢 得到原始内容

05:43.300 --> 05:44.300
所以说这个压缩呢

05:44.300 --> 05:46.300
也是一个非常普遍的

05:46.300 --> 05:48.300
来减少我们的最终传输体积

05:48.300 --> 05:50.300
它不是大宝打包体积

05:50.300 --> 05:52.300
减少的是我们传输的体积

05:52.300 --> 05:55.300
比方打包出来呢 可能有100KB

05:55.300 --> 05:57.300
然后呢 传输的时候呢

05:57.300 --> 05:58.300
我们进行GZAP压缩

05:58.300 --> 06:00.300
压缩之后呢 可能传输的时候

06:00.300 --> 06:02.300
只传输50KB就差不多了

06:02.300 --> 06:03.300
那么我们得到浏览器

06:03.300 --> 06:05.300
这边再进行解压

06:05.300 --> 06:07.300
这是这种方案

06:07.300 --> 06:09.300
还有一种方案呢 是使用一个CDN

06:09.300 --> 06:12.300
这个CDN呢 给打包体积就没关系了

06:12.300 --> 06:15.300
它主要是为了缩短 访问时间

06:15.300 --> 06:16.300
这是什么意思呢

06:16.300 --> 06:19.300
这个CDN我之前在课程里面

06:19.300 --> 06:20.300
也给大家介绍过 对吧

06:20.300 --> 06:23.300
比方说像我们这个完成之后

06:23.300 --> 06:25.300
完成功能之后部署的话

06:25.300 --> 06:27.300
那比方说我们现在只有一个服务器

06:27.300 --> 06:29.300
只有有这么一个服务器

06:29.300 --> 06:32.300
那么全世界都通过这个服务器来访问

06:32.300 --> 06:34.300
那会有什么样的结果呢

06:34.300 --> 06:36.300
这个服务器的处理压力太大了

06:36.300 --> 06:37.300
比方就访问一些静态资源

06:37.300 --> 06:39.300
一些静态的解释

06:39.300 --> 06:40.300
那么这个服务器呢

06:40.300 --> 06:42.300
占用这个服务器的带宽就太多了

06:42.300 --> 06:43.300
比方说这里一个

06:43.300 --> 06:45.300
这里有各个地方

06:45.300 --> 06:47.300
它都有一些浏览器

06:47.300 --> 06:49.300
来去请求我们的服务器

06:49.300 --> 06:50.300
这个服务器压力就有点大

06:50.300 --> 06:53.300
就会导致了想用资源的不及时

06:53.300 --> 06:54.300
因为它带宽占用的比较高

06:54.300 --> 06:57.300
所以说它传输的速率就自然下降了

06:57.300 --> 06:58.300
那么CDN是什么意思呢

06:58.300 --> 07:00.300
CDN的意思就是说

07:00.300 --> 07:02.300
我在全世界各个地方

07:02.300 --> 07:05.300
然后夺去部署一些服务器

07:05.300 --> 07:06.300
换个颜色吧

07:06.300 --> 07:10.120
夺去部署有很多的服务器

07:10.120 --> 07:12.120
在世界各地都有

07:12.120 --> 07:15.120
为什么要部署在世界各地呢

07:15.120 --> 07:17.120
好处又在于用户去请求

07:17.120 --> 07:18.120
我们的资源的时候

07:18.120 --> 07:20.120
不用去请求我们的源服务器了

07:20.120 --> 07:23.120
源式就是这个源

07:23.120 --> 07:26.120
就源代码的源

07:26.120 --> 07:28.120
它不用去请求源服务器了

07:28.120 --> 07:29.120
那么去请求什么呢

07:29.120 --> 07:31.120
请求这些CDN服务器

07:31.120 --> 07:33.120
这些就是CDN

07:33.120 --> 07:34.120
请求这些服务器

07:34.120 --> 07:36.120
来得到我们的内容

07:36.120 --> 07:37.120
这样子它就会根据

07:37.120 --> 07:40.120
这些CDN服务器它具体的地点

07:40.120 --> 07:41.120
它比方了这台计算机

07:41.120 --> 07:42.120
它在成都

07:42.120 --> 07:43.120
那么它就会比方成都

07:43.120 --> 07:45.120
有一台CDN服务器

07:45.120 --> 07:46.120
它就会直接访问这台服务器了

07:46.120 --> 07:48.120
一是路径更短

07:48.120 --> 07:50.120
二是分担了源服务器的压力

07:50.120 --> 07:51.120
对吧

07:51.120 --> 07:53.120
有了CDN服务器之后

07:53.120 --> 07:55.120
我们再去拿网络资源的时候

07:55.120 --> 07:57.120
他们就是一个究竟原则

07:57.120 --> 07:59.120
从究竟的地方去拿

07:59.120 --> 08:02.120
从究竟的地方去拿个东西

08:02.120 --> 08:04.120
那么这些CDN服务器

08:04.120 --> 08:06.120
它会定期的从源服务器

08:06.120 --> 08:08.120
去获取内容

08:08.120 --> 08:09.120
那么这样子的

08:09.120 --> 08:11.120
就分担了源服务器的很多压力

08:11.120 --> 08:14.120
就是我们的最终的用户的一端

08:14.120 --> 08:16.120
它访问的不是我们的源服务器

08:16.120 --> 08:18.120
是通过CDN服务器来得到结果的

08:18.120 --> 08:19.120
当然这样子

08:19.120 --> 08:20.120
也会产生一些现象

08:20.120 --> 08:22.120
比方说我们代码更新了

08:22.120 --> 08:23.120
放到源服务器

08:23.120 --> 08:25.120
它需要有一段时间

08:25.120 --> 08:27.120
有一段时间才能更新到CDN

08:27.120 --> 08:30.120
因为CDN它是有一些规则

08:30.120 --> 08:32.120
从源服务器去拿东西

08:32.120 --> 08:33.120
有一些规则的

08:33.120 --> 08:35.120
那么这是用使用CDN

08:35.120 --> 08:37.120
来减少我们的网络传输时间

08:37.120 --> 08:39.120
其实CDN还有一个好处

08:39.120 --> 08:41.120
什么好处就是

08:41.120 --> 08:43.120
它不仅让我们的

08:43.120 --> 08:45.120
经过了路程更短

08:45.120 --> 08:47.120
网络传输的路程更短

08:47.120 --> 08:49.120
还有一个好处在于

08:49.120 --> 08:51.120
它一般都会加缓存

08:51.120 --> 08:53.120
缓存一般都是可以存很久

08:53.120 --> 08:54.120
比方说存十年

08:54.120 --> 08:55.120
但是缓存的我们源服务器

08:55.120 --> 08:56.120
也可以加

08:56.120 --> 08:59.120
CDN服务器一般会加上缓存

08:59.120 --> 09:00.120
缓存它会缓存很久

09:00.120 --> 09:01.120
因此这些用户

09:01.120 --> 09:03.120
只要第一次请求了资源之后

09:03.120 --> 09:05.120
我们可以等很久

09:05.120 --> 09:07.120
都不用再去重新请求了

09:07.120 --> 09:08.120
后边要用资源

09:08.120 --> 09:10.120
直接使用浏览器里边缓存

09:10.120 --> 09:11.120
就行了

09:11.120 --> 09:14.120
因为CDN一般来拖管什么呢

09:14.120 --> 09:15.120
拖管静态资源

09:15.120 --> 09:17.120
像什么一个静态网页

09:17.120 --> 09:18.120
一个静态的CSS

09:18.120 --> 09:20.120
这些都是比较稳定的

09:20.120 --> 09:22.120
不会变化的

09:22.120 --> 09:24.120
像JS 打包出来的JS

09:24.120 --> 09:25.120
它都不会变化的

09:25.120 --> 09:28.120
所以说我们一般就进行缓存

09:28.120 --> 09:31.120
这是这一扩的它的处理方案

09:31.120 --> 09:35.120
其实CDN它还有一个好处

09:35.120 --> 09:37.120
特别是针对那种

09:39.120 --> 09:41.120
比较通用的第三方库

09:41.120 --> 09:42.120
比方说像View

09:42.120 --> 09:44.120
比方说像Jquery

09:44.120 --> 09:46.120
比方说像AxS

09:46.120 --> 09:48.120
这些都是比较通用的

09:48.120 --> 09:49.120
第三方库

09:49.120 --> 09:50.120
比方说像很多

09:51.120 --> 09:53.120
还有Jquery

09:53.120 --> 09:54.120
这些东西

09:57.120 --> 09:58.120
针对这些

09:58.120 --> 10:00.120
大家都可能会使用的第三方库

10:00.120 --> 10:02.120
我们使用CDN的时候

10:02.120 --> 10:05.120
我们都没有必要自己去购买CDN服务器了

10:05.120 --> 10:06.120
都没必要了

10:06.120 --> 10:07.120
我们只需要做什么呢

10:07.120 --> 10:09.120
只需要使用一些公共的CDN

10:09.120 --> 10:10.120
比方说像国内人

10:10.120 --> 10:14.430
还用了比较多的布置CDN

10:14.430 --> 10:16.430
那么像这个CDN比方

10:16.430 --> 10:17.430
我们就要查View

10:17.430 --> 10:18.430
我们当时View

10:18.430 --> 10:20.430
好像就用了这一块的CDN

10:20.430 --> 10:22.430
那么是不是直接可以用这的解释

10:22.430 --> 10:24.430
那么用这些公共网站的CDN

10:24.430 --> 10:25.430
有什么好处了

10:25.430 --> 10:26.430
好处是在于

10:26.430 --> 10:29.430
它可以跨网站的缓存

10:29.430 --> 10:30.430
比方说我用这个CDN

10:30.430 --> 10:31.430
我用这个

10:31.430 --> 10:33.430
这里边去找一个不用的解释

10:33.430 --> 10:34.430
我们在页面上

10:34.430 --> 10:36.430
用这个script元素去引用它

10:36.430 --> 10:37.430
那么你想一想

10:37.430 --> 10:39.430
比方说用户一开始

10:39.430 --> 10:40.430
没有访问我们的网站

10:40.430 --> 10:42.430
一开始是访问的另外一个网站

10:42.430 --> 10:43.430
访问的是ABC

10:43.430 --> 10:44.430
A调稿

10:44.430 --> 10:47.430
比方说我们的网站是MIDALCOP

10:47.430 --> 10:49.430
用户一开始去访问这个网站

10:49.430 --> 10:51.430
那假设这个网站就使用了

10:51.430 --> 10:53.430
这个公共的CDN

10:53.430 --> 10:55.430
使用了这个解释

10:55.430 --> 10:57.430
那么这个解释是不是会缓存下来了

10:57.430 --> 10:59.430
将来它在访问我们的网站的时候

10:59.430 --> 11:01.430
这个文件是不是不用再重新下载了

11:01.430 --> 11:02.430
它有这么一个好处

11:02.430 --> 11:05.430
它可以跨网站的贡想

11:05.430 --> 11:07.430
这是关于这个CDN

11:07.430 --> 11:11.430
可以大幅度减少我们的传输时间

11:11.430 --> 11:12.430
然后就是缓存

11:12.430 --> 11:14.430
一般CDN都会开缓存

11:14.430 --> 11:16.430
就是我们自己的服务性

11:16.430 --> 11:18.430
也可以开缓存

11:18.430 --> 11:19.430
就是使用ATTP缓存

11:19.430 --> 11:21.430
我们有单独的一节课来讲这个东西

11:21.430 --> 11:22.430
那么缓存

11:22.430 --> 11:23.430
有了缓存之后

11:23.430 --> 11:25.430
浏览器对这些静态资源

11:25.430 --> 11:26.430
请求一次

11:26.430 --> 11:27.430
就第一次

11:27.430 --> 11:29.430
有些许多人发现

11:29.430 --> 11:31.430
访问网站的时候就第一次

11:31.430 --> 11:32.430
后面就非常快了

11:32.430 --> 11:33.430
那什么回事呢

11:33.430 --> 11:34.430
第一次呢

11:34.430 --> 11:35.430
由于还必须要从服务器下载

11:35.430 --> 11:37.430
那后续有了缓存之后

11:37.430 --> 11:39.430
浏览器很多资源

11:39.430 --> 11:40.430
当然不是所有的资源

11:40.430 --> 11:41.430
有些资源变动比较平凡的话

11:41.430 --> 11:43.430
就不能缓存

11:43.430 --> 11:45.430
我们对很多的静态资源

11:45.430 --> 11:46.430
我们在浏览器里面

11:46.430 --> 11:48.430
直接使用缓存就可以拿到结果

11:48.430 --> 11:49.430
对吧

11:49.430 --> 11:51.430
这就是使用缓存的功效

11:51.430 --> 11:53.430
可以减少很多的请求

11:53.430 --> 11:55.430
然后接下来就针对协议的

11:55.430 --> 11:56.430
就是比方说

11:56.430 --> 11:58.430
我们使用ATP2这个协议

11:58.430 --> 12:00.430
有一节课讲那个ATP版本

12:00.430 --> 12:02.430
我们会详细的去讲ATP2

12:02.430 --> 12:04.430
那么ATP2开启了之后

12:04.430 --> 12:06.430
这也是要运维来开启

12:06.430 --> 12:08.430
跟我们前段开发没有多少关系

12:08.430 --> 12:10.430
运维开启了ATP2之后

12:10.430 --> 12:12.430
因为ATP2有些什么特点

12:12.430 --> 12:14.430
多路附用和头部压缩等特点

12:14.430 --> 12:17.430
可以大幅度减少我们的传输时间

12:17.430 --> 12:19.430
特别是针对我们网页里边

12:19.430 --> 12:21.430
外部资源比较多的情况

12:21.430 --> 12:23.430
有些网页里面图片可能就几百个

12:23.430 --> 12:25.430
GES可能有

12:25.430 --> 12:27.430
SNIKE

12:27.430 --> 12:28.430
CSS有可能有好多个

12:28.430 --> 12:29.430
对吧 还有些其他的什么

12:29.430 --> 12:31.430
字体资源 图标资源等等等等

12:31.430 --> 12:33.430
那么这些资源

12:33.430 --> 12:35.430
我们开启ATP2之后

12:35.430 --> 12:38.430
由于受到ATP2这种特点

12:38.430 --> 12:40.430
那么详细的情况去看

12:40.430 --> 12:41.430
相关的课程

12:41.430 --> 12:43.430
由于ATP2的特点

12:43.430 --> 12:45.430
大幅度缩减

12:45.430 --> 12:48.430
就是网络的响应时间

12:48.430 --> 12:50.430
就开启ATP2

12:50.430 --> 12:52.430
当然这个需要浏览器支持

12:52.430 --> 12:54.430
接下来是血币图

12:54.430 --> 12:55.430
有些人就是

12:55.430 --> 12:57.430
如果说你不开启ATP2

12:57.430 --> 12:59.430
那么

12:59.430 --> 13:01.430
像我们的图片资源

13:01.430 --> 13:02.430
这个大家都知道对吧

13:02.430 --> 13:03.430
图片资源

13:03.430 --> 13:04.430
如果说像

13:04.430 --> 13:05.430
不管是图片还是其他资源

13:05.430 --> 13:07.430
如果说资源太多的话

13:07.430 --> 13:09.430
哪怕总的

13:09.430 --> 13:11.430
传输数量是一定的

13:11.430 --> 13:13.430
一个资源是1kb

13:13.430 --> 13:15.430
1000个资源

13:15.430 --> 13:17.430
那就是1000kb

13:17.430 --> 13:19.430
1000乘1kb

13:19.430 --> 13:21.430
如果说把每一个资源

13:21.430 --> 13:23.430
都用一个文件来保存

13:23.430 --> 13:24.430
那么传输的时候

13:24.430 --> 13:28.640
是不是要传1000个文件

13:28.640 --> 13:30.640
要传1000个文件过来

13:30.640 --> 13:32.640
那么另外一种处理方式就是

13:32.640 --> 13:34.640
把这1000个文件

13:34.640 --> 13:35.640
表示都是图片

13:35.640 --> 13:36.640
做成一张血币图

13:36.640 --> 13:38.640
那么一个图片就是1kb

13:38.640 --> 13:39.640
1000kb

13:39.640 --> 13:41.640
然后有几个文件

13:42.640 --> 13:43.640
传输了多少呢

13:43.640 --> 13:44.640
一个文件

13:44.640 --> 13:46.640
其实他们传输的数据

13:46.640 --> 13:47.640
总量是一样的

13:47.640 --> 13:48.640
并没有什么区别

13:48.640 --> 13:49.640
甚至呢血币图

13:49.640 --> 13:50.640
可能还要大一点

13:50.640 --> 13:51.640
因为它里面

13:51.640 --> 13:53.640
会加了一些透明通道在里面

13:53.640 --> 13:55.640
它可能会图片还会大一点

13:55.640 --> 13:56.640
但是这样做

13:56.640 --> 13:59.640
仍然比传1000个文件要快

13:59.640 --> 14:00.640
那么至于是为什么

14:00.640 --> 14:03.640
因为大家学过TCP协议

14:03.640 --> 14:04.640
就是因为

14:04.640 --> 14:05.640
如果说你直接

14:05.640 --> 14:06.640
传1000个文件的话

14:06.640 --> 14:07.640
那么很多的文件

14:07.640 --> 14:09.640
它都会导致TCP的

14:09.640 --> 14:10.640
握手和挥手

14:10.640 --> 14:12.640
那么这一块是需要时间的

14:12.640 --> 14:14.640
还包括一些其他的原因

14:14.640 --> 14:15.640
那么具体的情况

14:15.640 --> 14:17.640
我们去在那个

14:17.640 --> 14:19.640
TCP的各种协议版本里面

14:19.640 --> 14:21.640
那些课专门去讲解

14:21.640 --> 14:22.640
这是使用血币图

14:22.640 --> 14:23.640
但是如果说你使用了

14:23.640 --> 14:24.640
ATP2时候

14:25.640 --> 14:27.640
原则上是可以不用血币图的

14:27.640 --> 14:28.640
可以不用了

14:28.640 --> 14:29.640
就用这个原式的

14:29.640 --> 14:30.640
1000个文件去丢1000个文件

14:30.640 --> 14:31.640
仍然是很快的

14:31.640 --> 14:33.640
跟一个文件是一样快的

14:34.640 --> 14:36.640
但是前提条件得用ATP2

14:36.640 --> 14:37.640
所以有的时候

14:37.640 --> 14:39.640
我们网站为了兼容

14:39.640 --> 14:40.640
我们都要有些

14:40.640 --> 14:41.640
针对现在浏览器

14:41.640 --> 14:43.640
使用ATP2去传输

14:43.640 --> 14:44.640
针对旧浏览器

14:44.640 --> 14:46.640
我们还得用ATP1.1

14:46.640 --> 14:48.640
那么像这种情况

14:48.640 --> 14:49.640
怎么处理呢

14:49.640 --> 14:50.640
那这种情况

14:50.640 --> 14:51.640
那只能没办法

14:51.640 --> 14:52.640
还得使用血币图

14:52.640 --> 14:54.640
所以血币图还会存在

14:54.640 --> 14:55.640
很长一段时间

14:55.640 --> 14:57.640
然后就是Default and Async

14:57.640 --> 15:00.640
这是在浏览器的一个章节

15:00.640 --> 15:01.640
浏览器的一个章节

15:01.640 --> 15:03.640
咱们讲的内容

15:03.640 --> 15:05.640
我这里不去多说了

15:05.640 --> 15:06.640
那么使用这两个

15:06.640 --> 15:07.640
就是可以让浏览器

15:07.640 --> 15:09.640
尽快地夹载我们的节式

15:09.640 --> 15:11.640
尽快地夹载

15:11.640 --> 15:12.640
这样子的

15:12.640 --> 15:14.640
可以不影响浏览器

15:14.640 --> 15:16.640
解析动物的情况下

15:16.640 --> 15:18.640
尽快地夹载节式

15:18.640 --> 15:20.640
可以让我们夹载时间提前

15:20.640 --> 15:22.640
其实夹载速度并没有变化

15:22.640 --> 15:24.640
只是让我们夹载时间提前而已

15:24.640 --> 15:25.640
给用户感知

15:25.640 --> 15:27.640
我们网页响应的速度快一些

15:27.640 --> 15:28.640
然后使用PayFace

15:28.640 --> 15:29.640
PayNode

15:29.640 --> 15:30.640
这两个属性

15:30.640 --> 15:32.640
这两个属性是让浏览器

15:32.640 --> 15:34.640
能够早一点的去

15:34.640 --> 15:35.640
夹载一些必要的资源

15:35.640 --> 15:36.640
不光是节式

15:36.640 --> 15:37.640
包括一些图片

15:37.640 --> 15:39.640
包括一些CSS

15:39.640 --> 15:41.640
甚至一些别的网页要用到的

15:41.640 --> 15:43.640
当然这两个也是有区别的

15:43.640 --> 15:44.640
面试的时候也比较容易问

15:44.640 --> 15:46.640
那是另外一块浏览器

15:46.640 --> 15:47.640
那一块的支持

15:47.640 --> 15:48.640
PayFace

15:48.640 --> 15:49.640
我们大概回过一下吧

15:49.640 --> 15:50.640
PayFace

15:50.640 --> 15:52.640
实际上在空前的时候

15:52.640 --> 15:54.640
预先下载其他页面

15:54.640 --> 15:55.640
可能要用到的资源

15:55.640 --> 15:56.640
比方说我现在浏览手页

15:56.640 --> 15:57.640
但是很有可能

15:57.640 --> 15:59.640
我将来会浏览新闻页

15:59.640 --> 16:01.640
那么可以预先的在手页

16:01.640 --> 16:02.640
先把新闻页的东西

16:02.640 --> 16:03.640
空前的时候把下载下来

16:03.640 --> 16:05.640
将来我们去找新闻页的时候

16:05.640 --> 16:07.640
直接使用缓存结果就可以了

16:07.640 --> 16:09.640
然后那是一个PayNode

16:09.640 --> 16:11.640
这是预先下载本页

16:11.640 --> 16:12.640
可能要用到的资源

16:12.640 --> 16:14.640
那么这个就比方说

16:14.640 --> 16:16.640
像我们预先下载一些图片

16:16.640 --> 16:20.640
预先下载一些CSS

16:20.640 --> 16:22.640
以及预先下载一些介石

16:22.640 --> 16:24.640
都可以使用这个属性

16:24.640 --> 16:25.640
好

16:25.640 --> 16:26.640
然后下面这个是

16:26.640 --> 16:28.640
多个静态资源域

16:28.640 --> 16:30.640
这个还是一个潜力条件

16:30.640 --> 16:33.640
对于不支持ATV2的场景

16:34.640 --> 16:36.640
那么我们可以

16:36.640 --> 16:38.640
把静态资源分散在

16:38.640 --> 16:39.640
不同的域名下边

16:39.640 --> 16:41.640
可以让浏览器同时开启

16:41.640 --> 16:43.640
多个TCP链接并行下载

16:43.640 --> 16:45.640
那么这一块也是在

16:45.640 --> 16:47.640
另外一些课叫ATVP

16:47.640 --> 16:50.640
各个协议版本的那些课

16:50.640 --> 16:51.640
来进行详细的讲解

16:51.640 --> 16:53.640
那么这一块我简单的说一下

16:53.640 --> 16:54.640
是什么意思呢

16:54.640 --> 16:55.640
就是说

16:55.640 --> 16:57.640
如果说你

16:57.640 --> 16:59.640
一般来情况下

16:59.640 --> 17:02.640
如果说我们不去加干涉的话

17:02.640 --> 17:04.640
那么浏览器和服务器之间

17:04.640 --> 17:06.640
只会开启一个TCP链接

17:06.640 --> 17:09.640
那么一个TCP链接有一个

17:09.640 --> 17:11.640
当然潜力条件不是ATV2

17:11.640 --> 17:13.640
ATV2没有任何问题

17:13.640 --> 17:16.640
HB1.1以及ATV更低的版本

17:16.640 --> 17:17.640
都会有这个问题

17:17.640 --> 17:18.640
就是如果说你

17:18.640 --> 17:20.640
只有一个TCP链接的话

17:20.640 --> 17:22.640
那么它的资源的加载顺序

17:22.640 --> 17:23.640
是受限的

17:23.640 --> 17:24.640
比方说你在页面上

17:24.640 --> 17:26.640
先写了一个另可元素

17:26.640 --> 17:28.640
再写了一个script元素

17:28.640 --> 17:29.640
去加载资源

17:29.640 --> 17:30.640
还有一个EmG

17:30.640 --> 17:31.640
还有一个EmG

17:31.640 --> 17:32.640
这是第1个

17:32.640 --> 17:33.640
第2个

17:33.640 --> 17:34.640
那么页面的加载顺序

17:34.640 --> 17:36.640
它一定是利用这个链接

17:36.640 --> 17:37.640
先去加载这个

17:37.640 --> 17:39.640
等这个加载完了之后

17:39.640 --> 17:40.640
再去加载这个

17:40.640 --> 17:41.640
然后再去加载这个

17:41.640 --> 17:42.640
再去加载这个

17:42.640 --> 17:44.640
它是用这种模式来做的

17:44.640 --> 17:46.640
那这种模式就会导致很慢

17:46.640 --> 17:47.640
对吧

17:47.640 --> 17:48.640
它没法一起去加载

17:48.640 --> 17:49.640
这是它的限制

17:49.640 --> 17:50.640
因此浏览器

17:50.640 --> 17:52.640
它为了解决这个问题

17:52.640 --> 17:53.640
在过去

17:53.640 --> 17:56.640
它开启了6个TCP�接

17:56.640 --> 17:58.640
就是为一个网站

17:58.640 --> 18:00.640
最多开启6个TCP链接

18:00.640 --> 18:01.640
开多了又会浪费资源

18:01.640 --> 18:02.640
所以说它

18:02.640 --> 18:03.640
找了一个比较浙东的方案

18:03.640 --> 18:04.640
就开启6个

18:04.640 --> 18:06.640
那么如果说我们页面上

18:06.640 --> 18:07.640
有一些资源

18:07.640 --> 18:09.640
比方说有100个图片

18:09.640 --> 18:11.640
1到100个图片

18:11.640 --> 18:12.640
那么它在加载的时候

18:12.640 --> 18:14.640
浏览器会自动处理

18:14.640 --> 18:15.640
它会

18:15.640 --> 18:18.640
比方说把1到33个图片

18:18.640 --> 18:20.640
使用一个TCP链接

18:20.640 --> 18:21.640
去加载

18:21.640 --> 18:22.640
那么你会看到

18:22.640 --> 18:23.640
这些图片都是按数据去来的

18:23.640 --> 18:25.640
先1再2再3再4

18:25.640 --> 18:26.640
对吧

18:26.640 --> 18:28.640
然后对34到

18:28.640 --> 18:30.640
比方说66

18:30.640 --> 18:32.640
它就用一个TCP链接

18:32.640 --> 18:33.640
下去一个例子

18:33.640 --> 18:35.640
后边我就不写了

18:35.640 --> 18:37.640
它一共最多开6个

18:37.640 --> 18:38.640
那么这样子一来的话

18:38.640 --> 18:39.640
你看看

18:39.640 --> 18:41.640
我们在这一段

18:41.640 --> 18:43.640
就是1和31

18:43.640 --> 18:45.640
和第34张图片

18:45.640 --> 18:47.640
它可能一起加载出来

18:47.640 --> 18:48.640
懂了意思吧

18:48.640 --> 18:50.640
因为他们是一个链接

18:50.640 --> 18:51.640
他们是一个链接

18:51.640 --> 18:52.640
他们两个互不干擾

18:52.640 --> 18:53.640
所以说

18:53.640 --> 18:54.640
这个链接它不会等待它

18:54.640 --> 18:56.640
前边的也不会等待后边的

18:56.640 --> 18:57.640
后边也不会等待全边的

18:57.640 --> 18:58.640
他们可以一起去加载

18:58.640 --> 19:00.640
但是在同一个链接里边

19:00.640 --> 19:01.640
必须要按顺序

19:01.640 --> 19:02.640
懂了意思吧

19:02.640 --> 19:04.640
所以说它为什么要去开多个

19:04.640 --> 19:06.640
就是为了完成并行加载

19:06.640 --> 19:07.640
这么一个效果

19:07.640 --> 19:08.640
当然ATP2不存在这个问题

19:08.640 --> 19:10.640
ATP2是可以不按顺序的

19:10.640 --> 19:11.640
这个没问题

19:11.640 --> 19:13.640
但是ATP2之前

19:13.640 --> 19:15.640
是必须要按顺序的

19:15.640 --> 19:16.640
那么如果说

19:16.640 --> 19:18.640
我们的网页支援很多

19:18.640 --> 19:20.640
像我们有100个

19:20.640 --> 19:21.640
这种图片支援

19:21.640 --> 19:22.640
很多

19:22.640 --> 19:23.640
甚至有些网上

19:23.640 --> 19:25.640
网项可能会超过100个

19:25.640 --> 19:26.640
那么像这种情况下

19:26.640 --> 19:27.640
6个你会发现

19:27.640 --> 19:29.640
6个TCP链接还是慢

19:29.640 --> 19:30.640
还是不够用

19:30.640 --> 19:32.640
你还要开更多的TCP链接

19:32.640 --> 19:33.640
你甚至想开230个

19:33.640 --> 19:34.640
你有钱

19:34.640 --> 19:36.640
你服务系那边承受得住

19:36.640 --> 19:37.640
没问题

19:37.640 --> 19:38.640
你想开230个

19:38.640 --> 19:40.640
那这个时候怎么办呢

19:40.640 --> 19:42.640
这个时候你就搞不定了

19:42.640 --> 19:45.640
约浏览器最多给你开6个

19:45.640 --> 19:47.640
那能不能改一下浏览器

19:47.640 --> 19:48.640
这个数量限制

19:48.640 --> 19:49.640
没法改

19:49.640 --> 19:50.640
你改了你自己的

19:50.640 --> 19:51.640
也没用

19:51.640 --> 19:53.640
你没法改客户那边的浏览器限制

19:53.640 --> 19:55.640
随着没办法

19:55.640 --> 19:56.640
那怎么办呢

19:56.640 --> 19:57.640
后来发现一个浏览器

19:57.640 --> 19:59.640
对这个限制是针对寓民的

19:59.640 --> 20:00.640
就是你访问什么寓民

20:00.640 --> 20:02.640
比方你访问3W-100度

20:02.640 --> 20:03.640
这个寓民

20:03.640 --> 20:04.640
那么他给你

20:04.640 --> 20:05.640
为这个寓民给你开6个

20:05.640 --> 20:07.640
凡是请求这个寓民相关的资源

20:07.640 --> 20:08.640
在这个页面中

20:08.640 --> 20:09.640
比方请求图片

20:09.640 --> 20:13.640
3W-100度.com.image1.jpg

20:13.640 --> 20:14.640
那么他会

20:14.640 --> 20:17.640
这个链接开一个TCP

20:17.640 --> 20:18.640
然后

20:18.640 --> 20:19.640
后边有可能

20:19.640 --> 20:21.640
请求到了第55了

20:21.640 --> 20:23.640
他为他又开一个TCP链接

20:23.640 --> 20:25.640
为这种同一个寓民

20:25.640 --> 20:26.640
想开6个

20:26.640 --> 20:27.640
那不同寓民

20:27.640 --> 20:28.640
他就没有限制了

20:28.640 --> 20:29.640
那么所以说

20:29.640 --> 20:30.640
很多网站他这么做的

20:30.640 --> 20:31.640
你访问100度的寓民

20:31.640 --> 20:32.640
但是他图片

20:32.640 --> 20:33.640
放到另外的寓民里面

20:33.640 --> 20:36.640
比如说BD static

20:36.640 --> 20:37.640
放到这个寓民里面

20:37.640 --> 20:38.640
他寓民不一样

20:38.640 --> 20:39.640
对吧

20:39.640 --> 20:40.640
所以说他就会突破

20:40.640 --> 20:41.640
6个的限制

20:41.640 --> 20:42.640
他会把静态资源

20:42.640 --> 20:43.640
放到不同的寓民下边

20:43.640 --> 20:45.640
那么甚至有可能

20:45.640 --> 20:46.640
1

20:46.640 --> 20:47.640
2都有可能

20:47.640 --> 20:48.640
他只为了突破不同的限制

20:48.640 --> 20:49.640
其实这个最点

20:49.640 --> 20:50.640
大家可以通过

20:50.640 --> 20:52.640
去访问一些别的网站

20:52.640 --> 20:53.640
可以看得到

20:53.640 --> 20:54.640
比方我们看的

20:54.640 --> 20:55.640
他网络传说

20:56.640 --> 20:58.640
你看这里的ConnectionID

20:58.640 --> 20:59.640
他一个相同的ID

20:59.640 --> 21:01.640
就是一个TCP链接

21:01.640 --> 21:02.640
相同的ID就是一个

21:02.640 --> 21:03.640
你看这里是不是

21:03.640 --> 21:04.640
开了很多个

21:04.640 --> 21:05.640
对吧

21:05.640 --> 21:06.640
那他怎么做的呢

21:06.640 --> 21:07.640
你看

21:07.640 --> 21:08.640
他这里用了H2

21:08.640 --> 21:09.640
他为了兼容

21:09.640 --> 21:10.640
ATP1.1

21:10.640 --> 21:12.640
他也是做了这么一个处理

21:12.640 --> 21:13.640
你会看到对面

21:13.640 --> 21:15.640
是不是不一样的

21:15.640 --> 21:16.640
对不对

21:16.640 --> 21:17.640
是不是都不一样的

21:17.640 --> 21:19.640
他的资源地址

21:19.640 --> 21:20.640
都不一样

21:20.640 --> 21:22.640
他就是为了突破

21:22.640 --> 21:23.640
这个6个限制

21:23.640 --> 21:24.640
这些都是运萎

21:24.640 --> 21:25.640
要做的事情

21:25.640 --> 21:26.640
跟你们开放

21:26.640 --> 21:27.640
没有什么关系

21:27.640 --> 21:28.640
你了解就可以了

21:28.640 --> 21:29.640
好

21:29.640 --> 21:30.640
这是关于这个

21:30.640 --> 21:31.640
网络性能优化

21:31.640 --> 21:32.640
我们可以

21:32.640 --> 21:33.640
找到的一些方案

21:33.640 --> 21:34.640
好

21:34.640 --> 21:35.640
那么这些里边

21:35.640 --> 21:36.640
关于更多的制度

21:36.640 --> 21:37.640
像特别像一些

21:37.640 --> 21:38.640
协议版本

21:38.640 --> 21:39.640
包括缓除

21:39.640 --> 21:40.640
都是在单独的课里边

21:40.640 --> 21:42.640
需要大家去看课上

