WEBVTT

00:00.240 --> 00:04.080
好 同学们 这节课呢 我们来聊一聊跨域的另外一种

00:04.340 --> 00:07.160
比较特别的解决办法 叫做接生坯

00:07.920 --> 00:09.460
这个玩意儿呢是

00:09.720 --> 00:11.500
很早以前的技术了

00:11.760 --> 00:13.800
因为以前是没有这个

00:14.060 --> 00:14.580
cost

00:14.840 --> 00:16.360
没有这个东西 所以说

00:16.620 --> 00:19.960
只能想办法 那就想出来这么一个接生坯这种怪招

00:20.720 --> 00:25.580
虽然说现在没有人用了 新的网站肯定不会用这种方式来做跨域了

00:26.100 --> 00:28.660
如果说你们以后遇到了

00:29.120 --> 00:34.800
只有一种情况 就是你们公司里边还有一些老的系统需要维护 他可能使用的是接生坯这种

00:35.060 --> 00:35.820
方式来跨域

00:36.080 --> 00:41.200
因此呢 面试的时候也有可能会问到 对于你们而言也需要知道 毕竟

00:41.720 --> 00:42.740
你们以后到公司

00:43.000 --> 00:43.760
不一定

00:44.020 --> 00:45.040
不一定

00:45.560 --> 00:47.600
是新系统 有可能是老系统

00:49.140 --> 00:51.700
那这个玩意儿是怎么回事了 他需要

00:51.960 --> 00:55.020
用这种方案的话 他需要浏览器和服务器来一个

00:55.280 --> 00:57.080
天一无缝的配合

00:58.060 --> 00:58.820
对大家都要动

00:59.340 --> 01:00.860
不像那个course 对吧 course的话

01:01.380 --> 01:03.180
服务器动就行了 你客服装不用管了

01:03.700 --> 01:04.460
他需要都要动

01:05.220 --> 01:09.580
他怎么做呢 下面有一段话 这段话读起来非常的抽象啊 不是很好理解

01:09.840 --> 01:12.900
我写刀算了是为了同学们以后在做面试的时候

01:13.420 --> 01:18.020
别人问到接生坯的原理是啥呀 那么你可以用这段话去给他描述 当然不用背

01:18.540 --> 01:21.360
我们把原理解释清楚过后再回过头来看这段话

01:21.620 --> 01:24.420
然后用你自己的语言把它总结一下就可以了

01:25.400 --> 01:29.080
他到底是咋做的呢 他是这样的啊 我把这个一块儿给他放大一点

01:31.040 --> 01:31.800
他这么一个原理

01:32.560 --> 01:33.320
首先呢

01:33.840 --> 01:36.160
在浏览器里边准备好一个函数

01:36.660 --> 01:39.480
这个函数是啥意思啊 这个函数表示的意思就是说

01:40.000 --> 01:42.040
相当于是阿迦克斯的回调函数

01:42.800 --> 01:44.840
实际上啊 接生坯他这种方式

01:45.360 --> 01:48.180
他根本就不是阿迦克斯了 他是照顾阿迦克斯的

01:48.440 --> 01:50.360
因为你以前没办法

01:50.620 --> 01:53.800
你不照顾阿迦克斯的话 你始终要有话一问题

01:54.180 --> 01:58.460
所以他照顾他怎么照顾的呢 先准备好一个全举函数啊 这是个全举函数

01:59.660 --> 02:05.100
相当于呢 作用了就相当于是阿迦克斯的回调 就拿到浮觍器过后执行的函数

02:05.860 --> 02:08.100
函数有个参数对吧 就跟我们的回调函数一样

02:08.780 --> 02:10.620
参数是不是就浮觍器的响应结果

02:11.180 --> 02:16.300
就准备好这么一个函数 这个函数里边可以做任何事情 你把一个浮觍结果拿到过后可以做任何事情

02:16.900 --> 02:17.860
好 接下来咋做呢

02:18.500 --> 02:19.340
他接下来这么玩的

02:19.860 --> 02:21.500
他生成的是一个

02:22.380 --> 02:23.420
script元素

02:24.300 --> 02:27.060
他生成这么一个元素在这 他用的根本就不是阿迦克斯

02:27.660 --> 02:32.380
然后呢 把这个元素的src地址呢 设置为你请求的地址

02:32.980 --> 02:37.180
相当于呢 他是用元素的方式来代替阿迦克斯请求

02:37.940 --> 02:40.580
因为元素的请求啊 是允许跨域的

02:40.980 --> 02:48.220
虽然说他也会受到同源策略的一些限制啊 但是呢 至少他没有阿迦克斯现在那么严格 对吧 他可以发出去也可以收到结果

02:49.200 --> 02:55.040
那么请求这个地址 比方说我要拿用户 咱们网站上有很多用户 那么我们拿一拿

02:55.800 --> 02:57.320
花域请求这么一个地址

02:57.880 --> 02:59.880
于是请求到哪呢 是不是请求到服务器了

03:00.560 --> 03:02.280
好 服务器给你想应什么呢

03:02.880 --> 03:06.040
他给你配合一下啊 想应这么一个东西

03:07.280 --> 03:09.240
他想应的是一段介石代码

03:09.960 --> 03:13.720
这段介石代码在干嘛呢 在调用我们那个权剧函数

03:13.720 --> 03:17.000
说说这个玩意啊 需要客户端那边跟服务器商量好

03:17.980 --> 03:24.460
你用什么函数 我给你调用什么函数 其实这种商量也有一些别的办法 比方说也随机的函数名字

03:25.340 --> 03:30.980
通过请求地址附带过去 这个东西我就不讨论了啊 我们就讨论一个最简单的场景

03:31.420 --> 03:36.820
双方商量好 用什么函数 客户端这边先准备着 然后服务器那边就调用这个函数

03:37.980 --> 03:42.340
然后把需要的数据呢 作为函数的参数给你传进来

03:42.960 --> 03:47.920
服务器想应这么一个东西 你看一下 这个东西想应到这儿是不是

03:48.560 --> 03:53.160
想应给这个谁 想应这个scripts元数的 对吧 那么这个元数呢

03:53.640 --> 03:58.480
这是一段介石 他是不是会调执行这个介石 一执行是不是执行了这个函数

03:59.040 --> 04:02.240
一执行的话 是不是这个数据就可以放到这个函数里面来了

04:02.640 --> 04:05.440
对吧 这个函数就得到执行了 基本原理就是这个

04:05.960 --> 04:09.800
所以他需要服务器和客户端这边 双方都要进行配合

04:10.660 --> 04:16.660
当然这样做的话 会有一个什么问题的 但问题很非常非常的明显 他只能发送介石星球

04:17.700 --> 04:20.660
为什么 因为这个元数他只能发出介石星球

04:21.340 --> 04:26.220
所以他只能发出介石星球 他的缺陷是非常明显的 以前确实没办法

04:26.580 --> 04:30.580
只能这样做 好 让咱们来看一下 来实际的演示一下吧

04:31.860 --> 04:33.660
我这个服务器呢 已经准备好了

04:34.640 --> 04:38.120
客户端那边 我们自己写 服务器那边 我们把它启动起来

04:38.640 --> 04:41.200
你们进入这个目录过后了 可以使用那个npm

04:42.080 --> 04:44.240
npmstarts这个命令 把它启动起来

04:46.760 --> 04:49.920
好像之前已经启动过了 重新来一次 点击右键

04:52.200 --> 04:55.800
启动一下 但只能启动一次 再启动的话 端口就被占用了

04:56.400 --> 05:00.600
好 那么服务器让你说 你访问这个地址呢 你就可以拿到用户的数据

05:01.120 --> 05:03.600
我们用浏览器去访问一下这个地址 看他给我们的是啥

05:06.150 --> 05:06.750
你看一下这个

05:08.030 --> 05:10.670
是不是给我们的是啥 给我们的是一个GS代码

05:11.470 --> 05:16.590
是一个函数调用 这个函数的名字呢 是服务器跟客户端商量好的 比方说我们这里就用callback

05:17.510 --> 05:21.750
然后呢 把服务器 把他有的数据呢 通过参数给我们传过来了

05:22.870 --> 05:26.510
于是客户端这边该咋写代码呢 比方说我们这里写个客户端代码

05:29.940 --> 05:32.580
就写个按钮吧 按钮的话就是那个

05:33.120 --> 05:35.920
点击 获取用户

05:36.800 --> 05:39.960
怎么办 用户获取到 这里边我们写个script

05:41.080 --> 05:44.640
怎么来写这个代码 首先客户端这边是不是要准备好一个函数callback

05:45.840 --> 05:52.680
然后函数一个参数就是服务器的响应结果 拿到这个响应结果之后干嘛呀 你随便做 比方说你循环这个用户生成一些

05:53.120 --> 05:56.960
元数 每个元数里面有用户的名字 随便你啊 我这里就直接在空讯台打印了

05:57.940 --> 06:02.740
那都是一会给服务器就相当于是服务器拿到结果之后毁掉函数

06:03.660 --> 06:05.980
接下来我们来再写一个函数叫request请求

06:06.820 --> 06:11.100
比方说请求一个地址 请求哪个地址呢 请求这个uil地址 我怎么请求呢

06:12.020 --> 06:18.060
看一下我们文档的这个原理是什么 请求现在请求的方式就不是直接用article是请求了 是生成一个

06:18.620 --> 06:22.180
script元数来把我们服务器地址 所以说我们这里要用document

06:23.160 --> 06:27.040
然后create element 创建一个script元数

06:28.160 --> 06:34.800
然后拿到这个元数啊 给这个元数呢 设置一个什么src地址

06:36.440 --> 06:42.280
为什么呢 为这个uil地址 对吧 然后你请求这个地址 那么就把src给设置为这个地址

06:43.080 --> 06:44.960
然后再把个元数加到header里面去

06:45.720 --> 06:50.480
那加到任何地方都可以啊 我就加了body也行啊 高配名字 body header也行

06:50.860 --> 06:55.660
paint child 元数加进去 这一加进去的话 是不是他就会请求这个地址

06:56.340 --> 07:01.060
而请求这个地址的话 是不是会拿到这个东西 拿这个东西是不是就会执行 因为他是

07:01.700 --> 07:05.620
script元数嘛 对吧 所以他拿到这个东西会执行 一执行的话 是不是执行了这个函数

07:05.980 --> 07:11.620
他就用这种方式来做的 好 咱们来试一下啊 给按钮做一个点击事件啊 document

07:11.860 --> 07:12.980
快点上来一个特儿啊 保证

07:14.180 --> 07:18.180
点击时点击的时候干嘛呢 我调用这个锐子函数 然后去请求这个地址

07:18.760 --> 07:24.720
请求这个地址 扶持一下 好 咱们来看一下 是不是能够拿到这个结果呢

07:28.030 --> 07:29.470
铺材啊 刷新

07:30.470 --> 07:36.070
点击 你看是不是拿到这个结果了 特别神奇啊 跨域请求的能拿到 因为为什么跨域的

07:36.390 --> 07:41.870
你这是我们的原地址 页面原地址 这是我们请求的地址 你看肯定跨域了 对吧 那么拿到这个结果

07:43.150 --> 07:48.070
然后我们可以监控一下网络啊 网络这一块呢 我们再重新点击一次 刷新

07:49.050 --> 07:54.850
点击一次 我们发生一个新的请求 这个请求注意 它的分类 它并不是阿迦克斯 根本就不是阿迦克斯请求

07:55.210 --> 07:58.570
用阿迦克斯根本没有 它是通过原数 生成元数来得到的

07:59.770 --> 08:04.290
那么我们看福西的响应结果 福西的响应结果还都还告诉你这是一个GS

08:05.330 --> 08:06.130
加把script代码

08:06.970 --> 08:08.530
然后它的响应结果是这么一个东西

08:09.090 --> 08:16.090
然后呢 也面上直行 一直行 哎 正好我这边有一个全剧函数 那么就可以让这个函数得到执行

08:16.550 --> 08:20.910
它是这么一个逻辑啊 当我们可以看到一个页面上的也会生成一个响应的元数啊

08:21.310 --> 08:24.630
那同学们就可能先会想到 这样子一来的话 那这个元数是不是

08:25.590 --> 08:30.710
越来越多 对不对 会越来越多 所以说呢 一般来说 我们还会把这个元数删除掉

08:31.030 --> 08:35.590
就拿 拿到之后啊 用完之后就会删除 那么于是我会给他做这个实践啊

08:37.590 --> 08:38.390
当他元数

08:39.270 --> 08:43.470
从福西拿到结果之后 运行了这个GS之后 然后呢 我们把这个元数给他删除掉

08:44.450 --> 08:48.330
这样子呢 就不会生成那些很多元数了啊 我们看一下

08:50.090 --> 08:55.410
你看这边 能拿到结果对吧 结果可以拿到 但是呢 这边元数呢 就被删除掉了

08:55.690 --> 09:02.810
就这么一个逻辑在里边啊 这就是接审批的这种方式 它的缺陷非常的明显 只能支持垫子琴球

09:03.970 --> 09:05.970
好 这是过去的做法 让大家了解一下

