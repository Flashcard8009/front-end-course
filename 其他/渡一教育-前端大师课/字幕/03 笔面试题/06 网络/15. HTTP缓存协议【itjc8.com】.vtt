WEBVTT

00:00.300 --> 00:02.900
好的同学们 这些课咱们来说一说

00:02.900 --> 00:05.900
在网络通信中的缓存

00:05.900 --> 00:07.900
那么这些课我们说的缓存呢

00:07.900 --> 00:12.100
跟我们在浏览器章节里面的缓存还不太一样

00:12.100 --> 00:15.900
浏览器章节里面的缓存是浏览器自发的 对吧

00:15.900 --> 00:17.900
跟服务器没有什么关系

00:17.900 --> 00:22.900
是浏览器自发的 自愿的把一些东西缓存起来

00:22.900 --> 00:24.900
而我们这里说的缓存呢

00:24.900 --> 00:26.900
是跟服务器有关系

00:27.500 --> 00:30.500
浏览器跟服务器两方

00:30.500 --> 00:34.500
他们自己协商 然后得到这么一个缓存

00:34.500 --> 00:38.500
所以说如果说在做面试题的时候

00:38.500 --> 00:41.500
面试题问题关于协商缓存的东西呢

00:41.500 --> 00:44.500
就是我们这节课的内容

00:44.500 --> 00:47.500
如果说面试题问题 浏览器有哪些缓存呢

00:47.500 --> 00:49.500
那么你要把浏览器的缓存说出来

00:49.500 --> 00:52.500
同时也要把这些课的内容说出来

00:52.500 --> 00:55.500
所以这两个给大家说清楚

00:55.500 --> 00:57.500
那么这一个节课呢

00:57.500 --> 01:00.500
我们说的缓存是跟ATB协议相关的

01:00.500 --> 01:04.500
但是它不是ATB协议规定的内容

01:04.500 --> 01:07.500
就是是我们在实践开发中

01:07.500 --> 01:10.500
双方形成了这么一种共识

01:10.500 --> 01:12.500
那么这是到底是怎么一个回事呢

01:12.500 --> 01:14.500
首先为什么要缓存

01:14.500 --> 01:17.500
那又缓存的主要目的就是减轻压力

01:17.500 --> 01:20.500
对吧 我服务器可以给你扫传一些东西

01:20.500 --> 01:22.500
不要经常来烦我

01:22.500 --> 01:25.500
你有的话你就用你缓存那边东西

01:25.500 --> 01:27.500
是这么一个出发点

01:27.500 --> 01:30.500
基本原理的其实特别简单

01:30.500 --> 01:33.500
我给他画一个图大概就基本就明白了

01:33.500 --> 01:36.500
比方说这是一个浏览器

01:36.500 --> 01:38.500
这是一个服务器

01:38.500 --> 01:41.500
他们都有各自的一条时间线

01:41.500 --> 01:45.500
其实整个缓存过程还是比较简单的

01:45.500 --> 01:48.500
首先服务器如果说他没有缓存的话

01:48.500 --> 01:50.500
浏览器他没有缓存的话他会问服务器

01:51.500 --> 01:53.500
服务器给他一个东西

01:53.500 --> 01:54.500
这个给他东西的时候

01:54.500 --> 01:56.500
服务器觉得这个东西以后你没有必要来缓我

01:56.500 --> 01:58.500
你自己缓存吧

01:58.500 --> 02:00.500
余生会给他加一个特殊的消息

02:00.500 --> 02:03.500
告诉浏览器你就把这个玩意缓存下来吧

02:03.500 --> 02:06.500
余生的浏览器他就会把这个东西缓存下来

02:06.500 --> 02:09.500
那之后浏览器他就不会去问服务器了

02:09.500 --> 02:10.500
如果说遇到同样的东西

02:10.500 --> 02:12.500
他就会直接使用缓存里边的结果

02:12.500 --> 02:13.500
直接用就行了

02:13.500 --> 02:15.500
但是缓存它不是一直有效的

02:15.500 --> 02:17.500
它有一天会失效

02:20.500 --> 02:22.500
还能用吗

02:22.500 --> 02:23.500
过了一年了

02:23.500 --> 02:24.500
这个东西还能用吗

02:24.500 --> 02:26.500
一年前的东西了

02:26.500 --> 02:28.500
于是这个时候浏览器会问一下服务器

02:28.500 --> 02:30.500
问他啥

02:30.500 --> 02:32.500
问他这个东西还能不能用

02:32.500 --> 02:34.500
服务器说这个东西你继续用吧

02:34.500 --> 02:35.500
继续用

02:35.500 --> 02:39.500
那你浏览器以后还是寻求缓存里边的

02:39.500 --> 02:40.500
直接用就完成了

02:40.500 --> 02:42.500
那又过了一段时间

02:42.500 --> 02:43.500
他觉得还能不能用

02:43.500 --> 02:44.500
又去寻求服务器

02:44.500 --> 02:46.500
大概就是这么一个过程

02:46.500 --> 02:48.500
如果说你在面试体的时候回答的话

02:48.500 --> 02:51.500
你可以先把这个过程的大事干描说一下

02:51.500 --> 02:54.500
然后再去说一些细节

02:54.500 --> 02:56.500
好 让咱们来看这张图

02:56.500 --> 02:58.500
其实这一块就已经是

02:58.500 --> 03:00.500
我们刚才画的一张图了

03:00.500 --> 03:01.500
第一次寻求的时候

03:01.500 --> 03:02.500
服务器给他处理寻求

03:02.500 --> 03:03.500
然后给他一个响应

03:03.500 --> 03:06.500
然后客户端他就会把这个响应结果

03:06.500 --> 03:07.500
按照服务器的要求

03:07.500 --> 03:08.500
服务器是有要求的

03:08.500 --> 03:09.500
加入缓存

03:09.500 --> 03:10.500
然后后续寻求的话

03:10.500 --> 03:12.500
直接从缓存里边读

03:12.500 --> 03:15.500
就不需要再从服务器读了

03:15.500 --> 03:17.500
那么我们一块块说

03:17.500 --> 03:19.500
首先就是服务器

03:19.500 --> 03:21.500
到底要给他响应什么东西

03:21.500 --> 03:24.500
浏览器才会去做这件事

03:24.500 --> 03:26.500
比方说我们这里的

03:26.500 --> 03:27.500
客户端发出了一个

03:27.500 --> 03:28.500
该是寻求到服务器

03:28.500 --> 03:30.500
服务器可能是这么想的

03:30.500 --> 03:31.500
你寻求这个资源

03:31.500 --> 03:33.500
我将来很少去改动它

03:33.500 --> 03:35.500
什么资源我很少改动

03:35.500 --> 03:36.500
你们想一想

03:36.500 --> 03:38.500
是不是就是那些静态文件

03:38.500 --> 03:40.500
GSS

03:40.500 --> 03:42.500
还包括一些什么图片

03:42.500 --> 03:44.500
字体文件等等

03:44.500 --> 03:45.500
像这些玩意

03:45.500 --> 03:46.500
其实服务器很少人要改动

03:46.500 --> 03:47.500
基本上是可以

03:47.500 --> 03:49.500
认为它永远不变的

03:49.500 --> 03:51.500
那么这种资源

03:51.500 --> 03:52.500
服务器会告诉客户端

03:52.500 --> 03:54.500
你这个东西自己缓存下来吧

03:54.500 --> 03:55.500
以后不要来反握了

03:55.500 --> 03:57.500
那它怎么告诉客户端的呢

03:57.500 --> 03:59.500
其实又是利用我们的

03:59.500 --> 04:00.500
头部信息

04:00.500 --> 04:01.500
头部信息里边

04:01.500 --> 04:02.500
可以玩说很多话

04:02.500 --> 04:04.500
那么它会通过头部信息

04:04.500 --> 04:05.500
在响应头里边

04:05.500 --> 04:06.500
加上这么端内容

04:06.500 --> 04:08.500
好像看上去有四个字段

04:08.500 --> 04:09.500
那么我们来伊斯兰

04:09.500 --> 04:10.500
描述一下这四个字段

04:10.500 --> 04:11.500
第一个字段叫

04:11.500 --> 04:12.500
catch control

04:12.500 --> 04:13.500
就是缓存控制

04:13.500 --> 04:15.500
是浏览器告诉服务器的

04:15.500 --> 04:17.500
服务器告诉浏览器的

04:17.500 --> 04:19.500
说你这个就在这一步

04:19.500 --> 04:21.500
就在这一步告诉服务器的

04:21.500 --> 04:23.500
告诉浏览器的

04:23.500 --> 04:24.500
这一步

04:24.500 --> 04:25.500
那么服务器说

04:25.500 --> 04:28.500
你这个玩意我现在

04:28.500 --> 04:30.500
打算让你把它缓存起来

04:30.500 --> 04:31.500
那你缓缓存的

04:31.500 --> 04:32.500
那就看你自己了

04:32.500 --> 04:33.500
所以说

04:33.500 --> 04:35.500
这个需要双方共同努力的

04:35.500 --> 04:36.500
服务器说你这个东西

04:36.500 --> 04:37.500
可以缓存多久呢

04:37.500 --> 04:39.500
特别跟上一个秒数

04:39.500 --> 04:40.500
要3600

04:40.500 --> 04:42.500
然后你告诉你

04:42.500 --> 04:43.500
浏览器

04:43.500 --> 04:44.500
你这个玩意

04:44.500 --> 04:46.500
那就缓存一个小时

04:46.500 --> 04:47.500
3600秒

04:47.500 --> 04:49.500
但实际开发中的这个值

04:49.500 --> 04:51.500
可能会非常非常的大

04:51.500 --> 04:53.500
有可能会一年

04:53.500 --> 04:54.500
十年

04:54.500 --> 04:55.500
一百年都有可能

04:55.500 --> 04:56.500
因为有些东西

04:56.500 --> 04:57.500
它确实永远不变

04:57.500 --> 04:59.500
它就没有必要

04:59.500 --> 05:00.500
就是

05:00.500 --> 05:02.500
写字设置的很短

05:02.500 --> 05:03.500
可以让它缓存久一点

05:03.500 --> 05:04.500
就这种东西

05:04.500 --> 05:06.500
我们在网站开发过程中

05:06.500 --> 05:07.500
随处可见

05:07.500 --> 05:08.500
我们随便打开一个网易

05:08.500 --> 05:10.500
比较就百度

05:10.500 --> 05:11.500
打开一个网易

05:11.500 --> 05:12.500
监控它的network

05:12.500 --> 05:14.500
然后我们这边

05:14.500 --> 05:16.500
把这个禁用缓存搜上

05:16.500 --> 05:17.500
这个调试的时候

05:17.500 --> 05:19.500
是可以禁用缓存的

05:19.500 --> 05:20.500
然后我们刷新

05:20.500 --> 05:21.500
看一下

05:21.500 --> 05:22.500
这里边有很多的

05:22.500 --> 05:23.500
介石文件

05:23.500 --> 05:24.500
PNG图片文件

05:24.500 --> 05:25.500
我打开一个PNG图片

05:25.500 --> 05:26.500
你看

05:26.500 --> 05:28.500
这边百度告诉我

05:28.500 --> 05:29.500
你请求这个图片

05:29.500 --> 05:30.500
你就把它缓存一下

05:30.500 --> 05:32.500
把开机控售

05:32.500 --> 05:34.500
这个是多少时间

05:34.500 --> 05:35.500
你自己可以刷一刷

05:35.500 --> 05:36.500
反正时间还是比较长的

05:36.500 --> 05:37.500
我一般去

05:37.500 --> 05:39.500
如果说我去搞服务器的话

05:39.500 --> 05:40.500
像这些精彩资源文件

05:40.500 --> 05:41.500
我能看看

05:41.500 --> 05:42.500
弄个一年 十年

05:42.500 --> 05:43.500
瞧了其他

05:43.500 --> 05:45.500
我很一点用一个100年

05:45.500 --> 05:46.500
电脑坏了

05:46.500 --> 05:49.500
它都不一定缓存失效

05:49.500 --> 05:51.500
那么这就是

05:51.500 --> 05:52.500
告诉他这么一个信息

05:52.500 --> 05:53.500
然后后边

05:53.500 --> 05:55.500
这个东西是一个编号

05:55.500 --> 05:56.500
是个编号

05:56.500 --> 05:57.500
它会对那些

05:57.500 --> 05:58.500
你请求的资源

05:58.500 --> 05:59.500
做一个编号

05:59.500 --> 06:00.500
每个资源是

06:00.500 --> 06:01.500
比较唯一的

06:01.500 --> 06:03.500
那么一个编号

06:03.500 --> 06:04.500
这个E-Tag

06:04.500 --> 06:05.500
其实对我们开发来说

06:05.500 --> 06:07.500
没有什么特别大的意义

06:07.500 --> 06:08.500
我们开发有

06:08.500 --> 06:09.500
更好的解决办法

06:09.500 --> 06:10.500
这个东西就表示一个编号

06:10.500 --> 06:12.500
就是相当于是说

06:12.500 --> 06:13.500
你请求这个资源

06:13.500 --> 06:14.500
我给你编个号

06:14.500 --> 06:15.500
你那边我告诉你

06:15.500 --> 06:17.500
至于你那边拿这个编号去做

06:17.500 --> 06:18.500
那我不管了

06:18.500 --> 06:19.500
反正我把编号告诉你

06:19.500 --> 06:21.500
后边的日期表示说

06:21.500 --> 06:24.500
这个日期能按照服务器来

06:24.500 --> 06:25.500
因为你刻骨端那边

06:25.500 --> 06:26.500
是可以改时间的

06:26.500 --> 06:29.500
时间是可以随便改的

06:29.500 --> 06:30.500
但服务器的时间

06:30.500 --> 06:31.500
你是改不了的

06:31.500 --> 06:33.500
随着时间的我告诉你

06:33.500 --> 06:34.500
那么此时此刻

06:34.500 --> 06:35.500
是哪一年

06:35.500 --> 06:36.500
哪一月

06:36.500 --> 06:37.500
哪一日

06:37.500 --> 06:38.500
多少时间

06:38.500 --> 06:39.500
多少分钟多少秒

06:39.500 --> 06:40.500
当然是一个GNT时间

06:40.500 --> 06:41.500
隔离位置时间

06:41.500 --> 06:44.500
那么把服务器的时间告诉你

06:44.500 --> 06:45.500
那么到时候你缓存的时候

06:45.500 --> 06:46.500
你以这个时间为卷

06:46.500 --> 06:48.500
比方说你缓存一个小时

06:48.500 --> 06:49.500
那么是在这个时间上

06:49.500 --> 06:51.500
加上一个小时

06:51.500 --> 06:53.500
然后是NAS Modified

06:53.500 --> 06:54.500
表示这个文件

06:54.500 --> 06:56.500
上一次修改的时间是多久

06:56.500 --> 06:58.500
这是一个文件修改时间

06:58.500 --> 06:59.500
一个资源上一次

06:59.500 --> 07:00.500
改动是什么时候

07:00.500 --> 07:01.500
他会把这些信息

07:01.500 --> 07:03.500
都告诉浏览器

07:03.500 --> 07:04.500
那么浏览器

07:04.500 --> 07:05.500
如果说

07:05.500 --> 07:07.500
不是浏览器请求的

07:07.500 --> 07:09.500
他可能看到这个信息过后

07:09.500 --> 07:10.500
直接把

07:10.500 --> 07:11.500
什么玩意

07:11.500 --> 07:12.500
你都不理你

07:12.500 --> 07:13.500
我下一次

07:13.500 --> 07:14.500
你当我缓存我偏不缓存

07:14.500 --> 07:15.500
可不可以

07:15.500 --> 07:16.500
当然可以

07:16.500 --> 07:17.500
只不过浏览器

07:17.500 --> 07:18.500
它是跟服务器

07:18.500 --> 07:20.500
一直就是一个非常好的大档

07:20.500 --> 07:22.500
相亲相爱的小伙伴

07:22.500 --> 07:23.500
所以他当浏览器

07:23.500 --> 07:25.500
看到这个东西的时候

07:25.500 --> 07:26.500
他就会行动起来

07:26.500 --> 07:28.500
那么他会做哪些事呢

07:28.500 --> 07:29.500
他会把你这一次

07:29.500 --> 07:30.500
资源的请求

07:30.500 --> 07:31.500
就得到了想应体

07:31.500 --> 07:33.500
缓存到本地文件中

07:33.500 --> 07:34.500
你看我们这里

07:34.500 --> 07:36.500
比方说请求这个图片

07:36.500 --> 07:38.500
这个图片的内容不就是个想应体吗

07:38.500 --> 07:39.500
那么这个想应体

07:39.500 --> 07:40.500
会被浏览器缓存下来

07:40.500 --> 07:42.500
其实我们在浏览器的

07:42.500 --> 07:43.500
工具里边可以看到

07:43.500 --> 07:45.500
有一些可以清除浏览

07:45.500 --> 07:46.500
清除浏览器数据

07:46.500 --> 07:47.500
那么这个清除的时候

07:47.500 --> 07:49.500
就可以清除掉这些缓存文件

07:49.500 --> 07:51.500
他会把这些东西存起来

07:51.500 --> 07:52.500
有的时候我们用一些

07:52.500 --> 07:54.500
什么电脑的

07:54.500 --> 07:55.500
特别手机

07:55.500 --> 07:58.500
什么电脑的一些

07:58.500 --> 08:00.500
那个叫什么

08:00.500 --> 08:01.500
电脑医生

08:01.500 --> 08:02.500
我是从来不用的东西

08:02.500 --> 08:04.500
那有些什么家书

08:04.500 --> 08:05.500
这些东西小工具

08:05.500 --> 08:07.500
他都可以帮你清除掉

08:07.500 --> 08:08.500
这些缓存的

08:08.500 --> 08:10.500
有的时候缓存久了之后

08:10.500 --> 08:11.500
浏览器缓缓存

08:11.500 --> 08:13.500
可能好几个季

08:14.500 --> 08:15.500
这是第一件事

08:15.500 --> 08:16.500
第二件事

08:16.500 --> 08:17.500
他会标记这一次

08:17.500 --> 08:19.500
请求的请求方法和请求路径

08:19.500 --> 08:21.500
就是说我这个缓存是哪来的

08:21.500 --> 08:23.500
我是用了什么样的请求方法

08:23.500 --> 08:25.500
请求了什么样的路径

08:25.500 --> 08:26.500
来得到的

08:26.500 --> 08:28.500
也就是他会标记一下

08:28.500 --> 08:30.500
这个文件他是跟这个相关的

08:30.500 --> 08:31.500
有个盖着请求

08:31.500 --> 08:33.500
请求的是这个地址

08:33.500 --> 08:35.500
他请求的是

08:35.500 --> 08:36.500
他会把这个东西标记一下

08:36.500 --> 08:38.500
这是ATP2的

08:38.500 --> 08:41.500
我看一下ATP1的

08:42.500 --> 08:43.500
好了

08:43.500 --> 08:46.500
我看一下找一个介绍

08:47.500 --> 08:49.500
介绍

08:49.500 --> 08:50.500
ATP2的

08:50.500 --> 08:52.500
反正他就会把路径

08:52.500 --> 08:55.500
路径和请求方法标记一下

08:55.500 --> 08:56.500
标记的作用是什么呢

08:56.500 --> 08:57.500
就是将来

08:57.500 --> 08:59.500
不能说我缓存了这个文件

08:59.500 --> 09:00.500
比如我缓存了一张图片

09:00.500 --> 09:02.500
以后你请求CSS

09:02.500 --> 09:03.500
我可以用这张图片

09:03.500 --> 09:04.500
那肯定不行了

09:04.500 --> 09:05.500
所以说

09:05.500 --> 09:07.500
请求CSS可能路径不一样

09:07.500 --> 09:09.500
有可能请求方法也不一样

09:09.500 --> 09:10.500
他会标记一下

09:10.500 --> 09:12.500
就将来如果说遇到了同样的请求方法

09:12.500 --> 09:13.500
同样的路径的时候

09:13.500 --> 09:14.500
我就直接使用缓存了

09:14.500 --> 09:15.500
还是这么个意思

09:15.500 --> 09:17.500
然后会标记一下这个缓存的时间

09:17.500 --> 09:19.500
这是服务器告诉他的

09:19.500 --> 09:20.500
3600秒

09:20.500 --> 09:22.500
然后会标记一下

09:22.500 --> 09:25.500
当时的服务器的想用的时间

09:25.500 --> 09:26.500
就这个时间

09:26.500 --> 09:27.500
这些东西都会把标记下来

09:27.500 --> 09:28.500
都会把记录下来

09:28.500 --> 09:29.500
人为可以

09:29.500 --> 09:30.500
就是一个表格

09:30.500 --> 09:31.500
有请求方法

09:31.500 --> 09:32.500
有请求路径

09:32.500 --> 09:33.500
有缓存时间

09:33.500 --> 09:34.500
有当时的服务器时间

09:34.500 --> 09:35.500
有支援编号

09:35.500 --> 09:37.500
有上一次修改时间

09:37.500 --> 09:38.500
这些信息都有

09:38.500 --> 09:41.500
还有就是缓存的内容

09:41.500 --> 09:42.500
这些都有

09:42.500 --> 09:44.500
那么把他记录下来之后

09:44.500 --> 09:46.500
后续有简单了

09:46.500 --> 09:47.500
如果说后续的请求

09:47.500 --> 09:49.500
只要请求方法和请求的路径

09:49.500 --> 09:50.500
匹配上

09:50.500 --> 09:51.500
那么他就直接使用

09:51.500 --> 09:52.500
刚才的缓存内容

09:52.500 --> 09:55.500
那么他就不会再重新询问服务器了

09:55.500 --> 09:56.500
那么这一点

09:56.500 --> 09:57.500
其实我们在开发过程中

09:57.500 --> 09:59.500
在特别是网络者以后监控

09:59.500 --> 10:00.500
我们可以看得非常非常清楚

10:00.500 --> 10:02.500
你看我们这里刷新

10:02.500 --> 10:04.500
你看这里

10:04.500 --> 10:06.500
很多的那个就是

10:06.500 --> 10:07.500
看了

10:07.500 --> 10:10.500
很多的这个就是

10:10.500 --> 10:12.500
请求我们再刷新一次

10:12.500 --> 10:14.500
他有这么一个东西

10:14.500 --> 10:16.500
叫Disk Catch

10:16.500 --> 10:19.500
就是石盘缓存

10:19.500 --> 10:20.500
那么这个缓存的

10:20.500 --> 10:21.500
就是表示

10:21.500 --> 10:22.500
浏览器这个资源

10:22.500 --> 10:23.500
根本不用请求服务器

10:23.500 --> 10:25.500
你断网了都可以

10:25.500 --> 10:26.500
这个资源

10:26.500 --> 10:27.500
我就直接可以拿得到

10:27.500 --> 10:29.500
从缓存里面直接拿

10:29.500 --> 10:30.500
这样子的时间

10:30.500 --> 10:31.500
就会非常非常短

10:31.500 --> 10:32.500
你看只有2毫秒

10:32.500 --> 10:33.500
4毫秒

10:33.500 --> 10:35.500
甚至还有1毫秒

10:35.500 --> 10:37.500
那么对于像这种文件的话

10:37.500 --> 10:38.500
特别像GSI

10:38.500 --> 10:39.500
就是除了页面之外

10:39.500 --> 10:41.500
页面我们一般不缓存的

10:41.500 --> 10:43.500
就除了页面之外的GSI

10:43.500 --> 10:44.500
CSS什么图片

10:44.500 --> 10:45.500
什么视频

10:45.500 --> 10:46.500
音频

10:46.500 --> 10:47.500
字体文件

10:47.500 --> 10:48.500
全部可以使用这种方式

10:48.500 --> 10:51.500
让浏览器长期把它缓存下来

10:51.500 --> 10:52.500
我这个3600秒

10:52.500 --> 10:53.500
就是举个例子

10:53.500 --> 10:56.500
实际开发中的时间要长得多

10:56.500 --> 10:57.500
不然的话

10:57.500 --> 10:58.500
有个流量控制不足

10:58.500 --> 11:00.500
像你看我们的马克当文件里边

11:00.500 --> 11:01.500
我这些图片都是上传到

11:01.500 --> 11:05.500
我自己的空间的

11:05.500 --> 11:06.500
那么像这些图片

11:06.500 --> 11:07.500
它都是有缓存的

11:07.500 --> 11:08.500
我都是做了缓存的

11:08.500 --> 11:09.500
你看

11:09.500 --> 11:10.500
那时候我可能刷新一下

11:10.500 --> 11:12.500
你看这个图片

11:13.500 --> 11:14.500
Response

11:19.500 --> 11:20.500
Catch Control

11:20.500 --> 11:21.500
你看

11:21.500 --> 11:23.500
我这里设置的是一年的

11:23.500 --> 11:24.500
好像是一年

11:24.500 --> 11:25.500
我记得

11:25.500 --> 11:27.500
设置一年的缓存期限

11:27.500 --> 11:29.500
都是用了很长时间缓存的

11:29.500 --> 11:30.500
所以说

11:30.500 --> 11:31.500
不然的话

11:31.500 --> 11:32.500
我这个费用我肯定是吃不消的

11:32.500 --> 11:33.500
你看我这个

11:33.500 --> 11:34.500
那么多文档

11:34.500 --> 11:36.500
文档里边这么多图片

11:36.500 --> 11:37.500
我的课件里面

11:37.500 --> 11:38.500
到处都是图片

11:38.500 --> 11:39.500
那我的空间是要收费的

11:39.500 --> 11:40.500
它是按流量收费的

11:40.500 --> 11:41.500
它每一次都从服务器拿

11:41.500 --> 11:42.500
拿这个文件的话

11:42.500 --> 11:44.500
那我肯定是吃不消的

11:44.500 --> 11:45.500
这个费用还是蛮庞大

11:45.500 --> 11:47.500
那你有了缓存之后

11:47.500 --> 11:48.500
你只要

11:48.500 --> 11:49.500
只有第一次请求的时候

11:49.500 --> 11:50.500
从服务器拿

11:50.500 --> 11:51.500
拿过去

11:51.500 --> 11:52.500
就在你流量器的缓存下来

11:52.500 --> 11:53.500
缓存下来之后

11:53.500 --> 11:55.500
你就不需要再重新请求服务器了

11:55.500 --> 11:57.500
就会好很多

11:57.500 --> 11:59.500
好那么这是从服务器拿的

11:59.500 --> 12:00.500
这么一个情况

12:00.500 --> 12:01.500
接下来我们来看一下

12:01.500 --> 12:03.500
客户端的

12:03.500 --> 12:05.500
来自客户端的缓存指令

12:05.500 --> 12:06.500
这是什么意思呢

12:06.500 --> 12:07.500
这个地方其实说的就是

12:07.500 --> 12:09.500
协商缓存

12:09.500 --> 12:13.140
就是协商

12:13.140 --> 12:14.140
那么这个地方

12:14.140 --> 12:15.140
说的是什么意思呢

12:15.140 --> 12:17.140
我们来再看

12:17.140 --> 12:19.140
客户端有了缓存之后

12:19.140 --> 12:21.140
如果说遇到了一些

12:21.140 --> 12:22.140
请求的时候

12:22.140 --> 12:23.140
它会先检查缓存

12:23.140 --> 12:24.140
比方说你可以去请求

12:24.140 --> 12:25.140
去请求一个介事的时候

12:25.140 --> 12:26.140
它想

12:26.140 --> 12:28.140
我这个缓存那边有没有呢

12:28.140 --> 12:29.140
它要判断一下

12:29.140 --> 12:31.140
那么它到底是如何判断的呢

12:31.140 --> 12:34.140
它是有这么一个过程

12:34.140 --> 12:36.140
第一步

12:36.140 --> 12:38.140
判断缓存中

12:38.140 --> 12:40.140
是否有匹配的请求方法和路径

12:40.140 --> 12:41.140
因为我们知道之前

12:41.140 --> 12:42.140
在记录这些缓存的时候

12:42.140 --> 12:43.140
都会标记一下

12:43.140 --> 12:46.140
它是用哪个请求方法请求的

12:46.140 --> 12:50.140
用哪一个路径来请求的

12:50.140 --> 12:52.140
这种情况其实

12:52.140 --> 12:54.140
以前在过去很早的时候

12:54.140 --> 12:56.140
我们也经常为了绕开缓存

12:56.140 --> 12:57.140
去做什么一些事

12:57.140 --> 12:58.140
比方说我们有的时候

12:58.140 --> 13:01.140
去请求一个图片吧

13:01.140 --> 13:05.140
比方说去请求图片吧

13:05.140 --> 13:06.140
那有的时候

13:06.140 --> 13:07.140
我们可能希望

13:07.140 --> 13:10.140
这一次请求就不要用缓存了

13:10.140 --> 13:11.140
那怎么办呢

13:11.140 --> 13:12.140
我会给它加上一个

13:12.140 --> 13:13.140
随机的参数

13:13.140 --> 13:14.140
随机的参数

13:14.140 --> 13:15.140
比方说我给它加一个

13:15.140 --> 13:16.140
第二个

13:16.140 --> 13:18.140
那么之前缓存的时候

13:18.140 --> 13:19.140
是没有路径的

13:19.140 --> 13:21.140
路径里面是不缓和这个的

13:21.140 --> 13:22.140
那么路径就匹配不上

13:22.140 --> 13:23.140
跟着缓存就匹配不上

13:23.140 --> 13:24.140
那么这一次

13:24.140 --> 13:25.140
它就必须要重新发动请求

13:25.140 --> 13:26.140
那下一次

13:26.140 --> 13:28.140
我给它加上124

13:28.140 --> 13:31.140
用这种方式来绕开缓存

13:31.140 --> 13:32.140
这是过去的一种做法

13:32.140 --> 13:33.140
现在的做法

13:33.140 --> 13:35.140
肯定比过去的做法正好

13:35.140 --> 13:36.140
那么先

13:36.140 --> 13:38.140
这里就是看一下这个缓存

13:38.140 --> 13:39.140
如果我找到了缓存

13:39.140 --> 13:40.140
还要看一下这个缓存

13:40.140 --> 13:42.140
是不是在有效期内

13:42.140 --> 13:44.140
因为每个缓存都有一个有效期

13:44.140 --> 13:45.140
它整个逻辑的就是

13:45.140 --> 13:47.140
下面这个流程图

13:47.140 --> 13:48.140
就这一部分的流程图

13:48.140 --> 13:49.140
好,咱们来看一下

13:49.140 --> 13:50.140
这部分的流程图

13:50.140 --> 13:51.140
首先我们来准备一个请求

13:51.140 --> 13:52.140
比方说请求的是

13:52.140 --> 13:54.140
英德克斯德尔

13:54.140 --> 13:56.140
戒指请求

13:56.140 --> 13:58.140
请求这个路径

13:58.140 --> 13:59.140
那么在请求的时候

13:59.140 --> 14:00.140
我们首先看一下

14:00.140 --> 14:01.140
这个缓存里面

14:01.140 --> 14:03.140
有没有匹配的缓存

14:03.140 --> 14:05.140
那么如果说有缓存的

14:05.140 --> 14:06.140
如果说没有缓存的话

14:06.140 --> 14:07.140
那就是一个普通请求

14:07.140 --> 14:09.140
重新发一个请求就行了

14:09.140 --> 14:11.140
跟第一次是一样的

14:11.140 --> 14:14.140
跟第一次请求是缓存一样的

14:14.140 --> 14:16.140
那么如果说

14:16.140 --> 14:17.140
有缓存

14:17.140 --> 14:18.140
就是我这边浏览器

14:18.140 --> 14:19.140
已经记录了

14:19.140 --> 14:20.140
以前请求过了

14:20.140 --> 14:21.140
已经缓存下来了

14:21.140 --> 14:22.140
那么这个时候

14:22.140 --> 14:23.140
判断一下

14:23.140 --> 14:24.140
这个缓存还有没有效

14:24.140 --> 14:26.140
如果说这个缓存有效

14:26.140 --> 14:28.140
那就不去请求了

14:28.140 --> 14:31.140
那么就是你们看到这种情况

14:31.140 --> 14:33.140
就是这种情况

14:33.140 --> 14:38.050
在

14:38.050 --> 14:40.050
在

14:40.050 --> 14:42.680
在这边

14:42.680 --> 14:43.680
看这个

14:43.680 --> 14:44.680
第一次开启

14:44.680 --> 14:45.680
对吧

14:45.680 --> 14:47.680
就这种情况

14:47.680 --> 14:49.680
好,那如果说缓存已经失效了

14:49.680 --> 14:51.680
已经到了过期时间了

14:51.680 --> 14:53.680
到了过期时间的时候

14:53.680 --> 14:54.680
这个时候

14:55.680 --> 14:57.680
它是有一种情况

14:57.680 --> 14:58.680
不一定的

14:58.680 --> 15:00.680
就是它能不能抛弃这个缓存

15:00.680 --> 15:01.680
还不能抛弃

15:01.680 --> 15:02.680
为啥呢

15:02.680 --> 15:03.680
我好不容易把缓存下来

15:03.680 --> 15:05.680
比方说有一个图片很大

15:05.680 --> 15:06.680
三照的左右

15:06.680 --> 15:07.680
我好不容易把它缓存下来

15:07.680 --> 15:08.680
那我现在就删了

15:08.680 --> 15:10.680
那服务器又要给我重新传三照

15:10.680 --> 15:13.680
其实我还有包着一点点希望

15:13.680 --> 15:14.680
虽然说过了一年了

15:14.680 --> 15:16.680
那万一这个图片还没有编呢

15:16.680 --> 15:18.680
所以说他会去问一下

15:18.680 --> 15:20.680
这个服务器

15:20.680 --> 15:22.680
到底这个文件

15:22.680 --> 15:23.680
这么久了

15:23.680 --> 15:24.680
随便的话我还能继续用

15:24.680 --> 15:25.680
对吧

15:25.680 --> 15:26.680
所以他会

15:26.680 --> 15:28.680
他会做这么一个请求

15:28.680 --> 15:29.680
一个特殊的请求

15:29.680 --> 15:31.680
就是带缓存的请求

15:31.680 --> 15:32.680
那么这个请求

15:32.680 --> 15:33.680
其实我们很多时候

15:33.680 --> 15:35.680
把它称之为协商请求

15:35.680 --> 15:37.680
比如说狭义一点的话

15:37.680 --> 15:39.680
那么协商请求指的是这一个

15:39.680 --> 15:41.680
如果广义一点的话

15:41.680 --> 15:42.680
就整个逻辑

15:42.680 --> 15:44.680
就整个我们这一个结合讲的逻辑

15:44.680 --> 15:46.680
是这里给他说清楚

15:46.680 --> 15:49.680
好,那么我们来用一张图来看

15:49.680 --> 15:50.680
就是

15:50.680 --> 15:52.680
如果说第一次请求

15:52.680 --> 15:53.680
这个缓存的话

15:53.680 --> 15:54.680
那就来个同场请求

15:54.680 --> 15:55.680
比方说服务器觉得

15:55.680 --> 15:56.680
这个资源可以缓存

15:56.680 --> 15:58.680
他就会给他这个消息头

15:58.680 --> 15:59.680
如果他觉得这个资源

15:59.680 --> 16:00.680
不能缓存

16:00.680 --> 16:01.680
那就不会给这个消息头

16:01.680 --> 16:02.680
然后之后呢

16:02.680 --> 16:03.680
我永远就会把缓存起来

16:03.680 --> 16:05.680
那么后续就从缓存里面拿了

16:05.680 --> 16:07.680
既然有一天缓存失销了

16:07.680 --> 16:08.680
失销了怎么办呢

16:08.680 --> 16:11.680
那么他就会带一个协商请求

16:11.680 --> 16:12.680
我们就把它称

16:12.680 --> 16:13.680
也可以说

16:13.680 --> 16:15.680
他是带缓存的请求

16:15.680 --> 16:16.680
缓存确证请求

16:16.680 --> 16:18.680
都是指的是这么一种请求

16:18.680 --> 16:20.680
这是一种特殊的请求

16:20.680 --> 16:21.680
好,那么聚起来

16:21.680 --> 16:22.680
我们来看一下

16:22.680 --> 16:23.680
如果说缓存有效

16:23.680 --> 16:24.680
那这毫无疑问

16:24.680 --> 16:25.680
没有什么好说的

16:25.680 --> 16:26.680
就这一部分

16:26.680 --> 16:28.680
直接从缓存里面读

16:28.680 --> 16:30.680
如果说缓存无效

16:30.680 --> 16:31.680
那么这个时候呢

16:31.680 --> 16:33.680
他不会简单的把缓存删除

16:33.680 --> 16:35.680
而是称之为

16:35.680 --> 16:36.680
协商请求

16:36.680 --> 16:38.680
就是协商缓存的请求

16:38.680 --> 16:39.680
他会怎么来请求呢

16:39.680 --> 16:41.680
他会请求服务器的时候

16:41.680 --> 16:44.680
带上这么两个消息制断

16:45.680 --> 16:46.680
那么这两个消息制断呢

16:46.680 --> 16:48.680
第一个消息制断

16:48.680 --> 16:49.680
告诉服务器

16:49.680 --> 16:50.680
你这个资源

16:50.680 --> 16:52.680
你之前服务器不是

16:52.680 --> 16:53.680
之前当他缓存的时候

16:53.680 --> 16:54.680
服务器不是告诉他

16:54.680 --> 16:55.680
那个文件的修改时间吗

16:55.680 --> 16:56.680
对吧

16:56.680 --> 16:57.680
那么这个就是

16:57.680 --> 16:58.680
他当时的文件修改时间

16:58.680 --> 16:59.680
就当时服务器

16:59.680 --> 17:00.680
告诉他的文件修改时间

17:00.680 --> 17:02.680
他就问服务器

17:02.680 --> 17:03.680
自从这个时间

17:03.680 --> 17:05.680
文件被修改了之后

17:05.680 --> 17:08.680
后续文件还有没有修改呀

17:08.680 --> 17:09.680
那么服务器那边

17:09.680 --> 17:10.680
是不是可以拿到这个东西

17:10.680 --> 17:11.680
可以判断

17:11.680 --> 17:13.680
我当时给你的时候

17:13.680 --> 17:14.680
是这个时间点

17:14.680 --> 17:16.680
那如果说服务器

17:16.680 --> 17:17.680
文件后来又动了

17:17.680 --> 17:18.680
比方说

17:18.680 --> 17:20.680
动到2021年4月30号了

17:20.680 --> 17:22.680
那现在这个文件

17:22.680 --> 17:23.680
修改的时间

17:23.680 --> 17:24.680
已经大于这个时间了

17:24.680 --> 17:25.680
说明说

17:25.680 --> 17:26.680
你缓存那个文件

17:26.680 --> 17:27.680
版本有颠倒了

17:27.680 --> 17:28.680
是吧

17:28.680 --> 17:29.680
所以说那个文件

17:29.680 --> 17:30.680
可能不能用的

17:30.680 --> 17:31.680
那如果说服务器那边

17:31.680 --> 17:32.680
看那个时间

17:32.680 --> 17:33.680
还是没变化

17:33.680 --> 17:34.680
那服务器会觉得

17:34.680 --> 17:37.680
这个文件还是没有变化

17:37.680 --> 17:38.680
他就会告诉客户

17:38.680 --> 17:39.680
你可以继续用

17:39.680 --> 17:40.680
所以这个东西

17:40.680 --> 17:41.680
就是告诉服务器

17:41.680 --> 17:42.680
我自从

17:42.680 --> 17:45.680
收到这个时间的文件之后

17:45.680 --> 17:46.680
后来有没有更改

17:46.680 --> 17:47.680
就这么个意思

17:47.680 --> 17:49.680
后边就是把那个文件编号

17:49.680 --> 17:50.680
带过去

17:50.680 --> 17:52.680
有助于服务器的判定

17:52.680 --> 17:53.680
就把这两个信息

17:53.680 --> 17:55.680
告诉服务器

17:55.680 --> 17:57.680
那么告诉服务器过后

17:57.680 --> 17:58.680
那服务器那边

17:58.680 --> 18:00.680
其实就是会呈成

18:00.680 --> 18:01.680
一句话就是问服务器

18:01.680 --> 18:02.680
你快说

18:02.680 --> 18:03.680
这个资源到底变了没有

18:03.680 --> 18:05.680
没变我就继续用

18:05.680 --> 18:06.680
变了

18:06.680 --> 18:07.680
你叫重新给我传

18:07.680 --> 18:08.680
就这么个意思

18:08.680 --> 18:10.680
那么为什么要传这两个呢

18:10.680 --> 18:13.680
其实这两个传一个就可以了

18:13.680 --> 18:14.680
说实话传一个就可以了

18:14.680 --> 18:15.680
主要是为了兼容

18:15.680 --> 18:16.680
因为有些服务器

18:16.680 --> 18:17.680
他只认第一个

18:17.680 --> 18:18.680
有些服务器认第二个

18:18.680 --> 18:19.680
所谓浏览器

18:19.680 --> 18:20.680
他会自动的给他

18:20.680 --> 18:21.680
加上这两个

18:21.680 --> 18:23.680
其实整个缓存过程都是自动的

18:23.680 --> 18:24.680
要动的话

18:24.680 --> 18:26.680
只能说去动物一下服务器

18:26.680 --> 18:28.680
服务器给他带上一个缓存头

18:28.680 --> 18:30.680
就带上这个东西

18:30.680 --> 18:31.680
你刻不断的话

18:31.680 --> 18:32.680
你不需要去动

18:32.680 --> 18:33.680
有些都自动完成了

18:35.680 --> 18:36.680
好

18:36.680 --> 18:37.680
那么这个时候

18:37.680 --> 18:38.680
就到了服务器那边了

18:38.680 --> 18:40.680
服务器一看

18:40.680 --> 18:42.680
你把情况都告诉我了

18:42.680 --> 18:43.680
你是想问一下

18:43.680 --> 18:44.680
这个文件变没有

18:45.680 --> 18:46.680
加上这两个消息头

18:46.680 --> 18:47.680
那么这个时候

18:47.680 --> 18:48.680
服务器可能要去判定一下

18:48.680 --> 18:50.680
他可能有两种结果

18:50.680 --> 18:51.680
一种就是缓存已经失销了

18:51.680 --> 18:52.680
不能用了

18:52.680 --> 18:54.680
这个缓存你赶快删了吧

18:54.680 --> 18:55.680
我给你新的

18:55.680 --> 18:57.680
另外一个就是缓存仍然有效

18:57.680 --> 18:59.680
第一种缓存失销的比较简单

18:59.680 --> 19:01.680
那就服务器给一个正常响应就完事了

19:01.680 --> 19:02.680
我给你想一个新的内容

19:02.680 --> 19:04.680
然后又给你带上一个消息头

19:04.680 --> 19:05.680
让你去缓存新的

19:05.680 --> 19:07.680
那么这就很简单

19:07.680 --> 19:08.680
关键是

19:08.680 --> 19:09.680
第二个

19:09.680 --> 19:10.680
如果说服务器觉得

19:10.680 --> 19:11.680
他缓存仍然有效

19:11.680 --> 19:12.680
你还可以继续用

19:12.680 --> 19:14.680
那么他怎么来告诉呢

19:14.680 --> 19:16.680
他就不会给他想硬帖

19:16.680 --> 19:18.680
因为你还可以继续用

19:18.680 --> 19:19.680
我干嘛还要重新给你一遍呢

19:19.680 --> 19:20.680
他就不给了

19:20.680 --> 19:21.680
他就给他一个想硬码

19:21.680 --> 19:23.680
叫304

19:23.680 --> 19:24.680
Modified

19:24.680 --> 19:26.680
那么如果说有些人看到

19:26.680 --> 19:27.680
一些304的状态码

19:27.680 --> 19:28.680
就这么个意思

19:28.680 --> 19:30.680
就告诉

19:30.680 --> 19:31.680
浏览器

19:31.680 --> 19:32.680
你还可以继续用

19:32.680 --> 19:34.680
同时在想硬头上

19:34.680 --> 19:36.680
带上新的缓存指令

19:36.680 --> 19:38.680
那么带上这个新的

19:38.680 --> 19:40.680
你接着

19:40.680 --> 19:42.680
有可以缓存多少时间

19:42.680 --> 19:44.680
现在的人就是标记是啥

19:44.680 --> 19:46.680
那些东西都会告诉浏览器

19:46.680 --> 19:47.680
浏览器就会更新

19:47.680 --> 19:49.680
就这么个意思

19:49.680 --> 19:50.680
那么这样子

19:50.680 --> 19:51.680
就相当于是你服务器

19:51.680 --> 19:52.680
告诉浏览器

19:52.680 --> 19:53.680
说你的资源仍然可以用

19:53.680 --> 19:55.680
我给你了一个新的缓存时间

19:55.680 --> 19:57.680
你咱们更新一下

19:57.680 --> 19:58.680
就可以了

19:58.680 --> 19:59.680
而浏览器那边

19:59.680 --> 20:00.680
就可以继续使用缓存的

20:00.680 --> 20:01.680
我们来看一下

20:01.680 --> 20:02.680
没那么普通

20:02.680 --> 20:03.680
第一是请求

20:03.680 --> 20:04.680
没有缓存的时候

20:04.680 --> 20:05.680
那就正常请求

20:05.680 --> 20:06.680
正常请求的话

20:06.680 --> 20:07.680
那么服务器

20:07.680 --> 20:09.680
就给他这么一个想硬头

20:09.680 --> 20:10.680
就缓存指令

20:10.680 --> 20:12.680
那么他就会把加入到缓存

20:12.680 --> 20:13.680
有消息过了之后

20:13.680 --> 20:15.680
他就会协商缓存了

20:15.680 --> 20:16.680
你看一下

20:16.680 --> 20:17.680
这个文件

20:17.680 --> 20:18.680
从这个时间

20:18.680 --> 20:19.680
这个电号

20:19.680 --> 20:20.680
你看还能用吗

20:20.680 --> 20:22.680
服务器说用吧

20:22.680 --> 20:23.680
用吧

20:23.680 --> 20:24.680
来继续给我缓存

20:24.680 --> 20:25.680
3600秒

20:25.680 --> 20:27.680
3600秒的一个小时

20:27.680 --> 20:28.680
那么把这些信息

20:28.680 --> 20:29.680
又全部重新

20:29.680 --> 20:30.680
告诉浏览器

20:30.680 --> 20:31.680
是个三银式

20:31.680 --> 20:32.680
拿出模具败的

20:32.680 --> 20:33.680
然后浏览器看

20:33.680 --> 20:34.680
还可以继续用

20:34.680 --> 20:35.680
那我大胆的

20:35.680 --> 20:36.680
继续用这个

20:37.680 --> 20:38.680
就是缓存内容就行了

20:39.680 --> 20:40.680
注意啊

20:40.680 --> 20:41.680
一定要注意的就是

20:41.680 --> 20:43.680
三银式这个想硬结果

20:43.680 --> 20:44.680
它是不包含想硬体的

20:44.680 --> 20:46.680
比方说你请求个图片

20:46.680 --> 20:47.680
你本来缓存了

20:47.680 --> 20:48.680
对吧

20:48.680 --> 20:49.680
你后来时间过了

20:49.680 --> 20:50.680
你重新许留服务器的时候

20:50.680 --> 20:52.680
服务器觉得这个图片没有变

20:52.680 --> 20:54.680
那么他不会重新给你

20:54.680 --> 20:55.680
传议式图片内容

20:55.680 --> 20:56.680
他只是告诉你

20:56.680 --> 20:57.680
就是告诉你一句话

20:57.680 --> 20:58.680
图片没变

20:58.680 --> 20:59.680
然后把这些标记信息

20:59.680 --> 21:00.680
重新告诉你一下

21:00.680 --> 21:01.680
那么客户端那边

21:01.680 --> 21:02.680
更新一下

21:02.680 --> 21:03.680
就可以继续使用缓存了

21:03.680 --> 21:04.680
好

21:04.680 --> 21:05.680
这是关于这一块

21:06.680 --> 21:07.680
那么这接下来

21:07.680 --> 21:09.680
后边的跟面试题

21:09.680 --> 21:10.680
就没有什么关系了

21:10.680 --> 21:12.680
就作为一个了解吧

21:12.680 --> 21:14.680
听一听的多学一点

21:14.680 --> 21:15.680
没什么好

21:15.680 --> 21:16.680
没什么坏处

21:16.680 --> 21:18.680
能理解就理解

21:18.680 --> 21:19.680
因为它里边

21:19.680 --> 21:20.680
其实缓存里边细节

21:20.680 --> 21:22.680
还是蛮多的

21:22.680 --> 21:23.680
但是面试的时候

21:23.680 --> 21:25.680
其实你说清楚

21:25.680 --> 21:26.680
这两个就行了

21:26.680 --> 21:28.680
服务器那边

21:28.680 --> 21:30.680
就相当于这张图

21:30.680 --> 21:31.680
就把这张图

21:31.680 --> 21:33.680
给它描述清楚

21:33.680 --> 21:34.680
就可以了

21:34.680 --> 21:35.680
第一是怎么回事

21:35.680 --> 21:37.680
然后后边有了缓存过后怎么回事

21:37.680 --> 21:39.680
缓存失效过后又怎么回事

21:39.680 --> 21:41.680
然后三零四又是怎么回事

21:41.680 --> 21:43.680
给它说清楚就完事了

21:43.680 --> 21:45.680
那么关键后边细节的话

21:45.680 --> 21:47.680
我们作为一个扩展

21:47.680 --> 21:48.680
扩展约度就可以了

21:48.680 --> 21:50.680
首先是这个开启康处

21:50.680 --> 21:51.680
这个玩意就是

21:51.680 --> 21:52.680
服务器给它响应的开启康处

21:52.680 --> 21:54.680
就是控制缓存的缓存指令

21:54.680 --> 21:56.680
那么这一块我们只看到了

21:56.680 --> 21:57.680
MaxA级

21:57.680 --> 21:59.680
表示的缓存的过解

21:59.680 --> 22:01.680
就是有效时间

22:01.680 --> 22:04.680
其实它还可以写很多的纸

22:04.680 --> 22:06.680
比方它可以写public和private

22:06.680 --> 22:07.680
它写到这

22:07.680 --> 22:08.680
然后public

22:08.680 --> 22:10.680
你看我们这边

22:10.680 --> 22:12.680
我刚才的图片好像就是这样

22:24.680 --> 22:25.680
这里写个public

22:25.680 --> 22:27.680
它也可以写个private

22:27.680 --> 22:30.680
public表示公共的private表示私有的

22:30.680 --> 22:32.680
那么这个东西到底是

22:32.680 --> 22:34.680
这个东西其实没有什么本质的作用

22:34.680 --> 22:36.680
其实流量器还也不管这个东西的

22:36.680 --> 22:39.680
它可能是给一些别的客户端说的

22:39.680 --> 22:41.680
其实它就表明

22:41.680 --> 22:42.680
服务器表明

22:42.680 --> 22:44.680
我这个资源服务器是个化牢

22:44.680 --> 22:47.680
明明一个MaxA级就够了

22:47.680 --> 22:49.680
就是个化牢

22:49.680 --> 22:51.680
而且特别喜欢跟别人交流

22:51.680 --> 22:53.680
它要把自己的情况清清楚楚的

22:53.680 --> 22:54.680
告诉别人

22:54.680 --> 22:55.680
这个文件是公用的

22:55.680 --> 22:56.680
公开资源

22:56.680 --> 22:58.680
所有的人看到的都是一样的

22:58.680 --> 23:00.680
private就告诉这个是私有的

23:00.680 --> 23:02.680
可能要登录之后你才能看得到的

23:02.680 --> 23:03.680
这些东西

23:03.680 --> 23:05.680
它只是做个标记

23:05.680 --> 23:07.680
那么拿到这个标记过后

23:07.680 --> 23:09.680
客户端那边他要做什么处理

23:09.680 --> 23:11.680
那就完全看客户端是什么程序了

23:11.680 --> 23:13.680
流量器其实是不看这个的

23:13.680 --> 23:15.680
跟这个流量器看的不看这个

23:15.680 --> 23:17.680
它只看这个MaxA级

23:17.680 --> 23:18.680
这是这两个

23:18.680 --> 23:20.680
有的时候它这里不写MaxA级

23:20.680 --> 23:22.680
它可能写的是low catch

23:22.680 --> 23:24.680
这个是啥意思呢

23:24.680 --> 23:26.680
就是告诉客户端你把这个资源

23:26.680 --> 23:27.680
还是还出来

23:27.680 --> 23:29.680
low catch这个名字有点特别

23:29.680 --> 23:30.680
容易造成误解

23:30.680 --> 23:31.680
就好像是不缓存的意思

23:31.680 --> 23:32.680
不是的

23:32.680 --> 23:35.680
说你还是可以把它缓存一下

23:35.680 --> 23:38.680
但是你之后不要直接用它

23:38.680 --> 23:40.680
你之后要用它的时候

23:40.680 --> 23:42.680
每一次都来问一下

23:42.680 --> 23:44.680
我便没有

23:44.680 --> 23:47.680
是这么一个意思

23:47.680 --> 23:52.680
相当于是在这儿

23:52.680 --> 23:54.680
如果说他给的不是那个资源级

23:54.680 --> 23:56.680
给的是low catch

23:56.680 --> 23:58.680
那么客户端那边还是有这个东西

23:58.680 --> 24:00.680
还是有缓存的

24:00.680 --> 24:01.680
只不过他不会

24:01.680 --> 24:02.680
以后的请求的时候

24:02.680 --> 24:03.680
他不会直接从缓存里面读

24:03.680 --> 24:06.680
以后的每一次都是写上缓存

24:06.680 --> 24:07.680
是这么一个意思

24:07.680 --> 24:08.680
那么这种做法

24:08.680 --> 24:13.680
一般常见于一些

24:13.680 --> 24:15.680
变动比较

24:15.680 --> 24:16.680
变动你要说他频繁

24:16.680 --> 24:18.680
他也不一定频繁

24:18.680 --> 24:20.680
但是你要说他不频繁

24:20.680 --> 24:23.680
可能他有的时候又会变动

24:23.680 --> 24:25.680
比方说

24:25.680 --> 24:26.680
我们之前说

24:26.680 --> 24:27.680
页面一般是不缓存的

24:27.680 --> 24:29.680
但是有些页面他确实

24:29.680 --> 24:30.680
不怎么变动

24:30.680 --> 24:31.680
像文章详情

24:31.680 --> 24:32.680
你写了一篇新闻

24:32.680 --> 24:34.680
这篇新闻可能在过两网上

24:34.680 --> 24:35.680
发出去过后

24:35.680 --> 24:37.680
他一直就没变了

24:37.680 --> 24:38.680
这篇新闻

24:38.680 --> 24:40.680
我们一般会把它做成静态化

24:40.680 --> 24:42.680
它不会随着时间变化而变化

24:42.680 --> 24:44.680
那么这种新闻你可以缓存

24:44.680 --> 24:46.680
你可以把整个页面

24:46.680 --> 24:48.680
我可以让你把整个页面缓存下来

24:48.680 --> 24:50.680
是这么个意思

24:50.680 --> 24:51.680
那么一缓存过后

24:51.680 --> 24:52.680
那万一有一天

24:52.680 --> 24:53.680
表了一个新闻里面

24:53.680 --> 24:55.680
有些错误的报道

24:55.680 --> 24:56.680
主要写错了

24:56.680 --> 24:57.680
错别字

24:57.680 --> 24:59.680
或者是一些用词不大

24:59.680 --> 25:01.680
或者是你发了一些争议

25:01.680 --> 25:04.680
那么这个新闻可能会要变动

25:04.680 --> 25:06.680
这个新闻可能会有变动

25:06.680 --> 25:08.680
我也说不准什么时候会有变动

25:08.680 --> 25:09.680
那么这个时候

25:09.680 --> 25:10.680
他可能会这么做

25:10.680 --> 25:12.680
就是做一个LOCACH

25:12.680 --> 25:13.680
你把这个新闻

25:13.680 --> 25:14.680
你去缓存吧

25:14.680 --> 25:15.680
缓存

25:15.680 --> 25:16.680
以后我不会给你发了

25:16.680 --> 25:17.680
我不会给你

25:17.680 --> 25:18.680
表现一个新闻很多

25:18.680 --> 25:20.680
有一万字

25:20.680 --> 25:21.680
那么每次去发

25:21.680 --> 25:22.680
还是比较费事

25:22.680 --> 25:24.680
我还要从数据库里边去读

25:24.680 --> 25:25.680
做一些处理

25:25.680 --> 25:27.680
我可以发给你还是挺费事的

25:27.680 --> 25:29.680
所以说你那边就存吧

25:29.680 --> 25:30.680
存着

25:30.680 --> 25:31.680
但是你不能一直用它

25:31.680 --> 25:32.680
万一有错了

25:32.680 --> 25:33.680
对吧

25:33.680 --> 25:35.680
你看到了是一个错误的新闻

25:35.680 --> 25:37.680
所以说你每一次

25:37.680 --> 25:39.680
想重新看这个新闻的时候

25:39.680 --> 25:40.680
你都来问你一下我

25:40.680 --> 25:41.680
就是写上缓存

25:41.680 --> 25:42.680
你问一下我

25:42.680 --> 25:44.680
我的东西变了没变

25:44.680 --> 25:45.680
就这么意思

25:45.680 --> 25:46.680
我一般来说

25:46.680 --> 25:47.680
我都会告诉你

25:47.680 --> 25:48.680
没变了

25:48.680 --> 25:49.680
你就可以使用这里边的东西了

25:49.680 --> 25:51.680
我不用把新闻给你重新传一次

25:51.680 --> 25:53.680
可以接受传输的时间

25:53.680 --> 25:55.680
但是如果说有一天我变了

25:55.680 --> 25:56.680
你马上就会知道

25:56.680 --> 25:57.680
对吧

25:57.680 --> 25:58.680
马上就会知道

25:58.680 --> 25:59.680
因为你收不到这个三连四的

25:59.680 --> 26:00.680
你收到了是两半

26:00.680 --> 26:02.680
那么你就会更新你的缓存

26:02.680 --> 26:04.680
它一般是用于这么一个作用

26:04.680 --> 26:05.680
像这个

26:05.680 --> 26:07.680
CS、CSS

26:07.680 --> 26:09.680
像图片这些人一般都不会用的

26:09.680 --> 26:12.680
一般都是使叫缓存吧你就

26:12.680 --> 26:13.680
你不要来问我了

26:13.680 --> 26:15.680
因为它不会变的

26:15.680 --> 26:16.680
然后就是都是

26:16.680 --> 26:18.680
这个东西比较狠一点

26:18.680 --> 26:19.680
就告诉你

26:19.680 --> 26:20.680
完全不要缓存

26:20.680 --> 26:21.680
任何缓存都不要用

26:21.680 --> 26:22.680
完全不要保存

26:22.680 --> 26:24.680
这时候就全部重新的传一次

26:24.680 --> 26:25.680
这个就比较狠了

26:25.680 --> 26:26.680
当然这样子做的话

26:26.680 --> 26:28.680
就是属于那种变动

26:28.680 --> 26:30.680
非常非常频繁的资源

26:30.680 --> 26:32.680
我们会用这种方式

26:32.680 --> 26:34.680
那么我们其实看一下页面吧

26:34.680 --> 26:36.680
我们看一下百度的页面

26:36.680 --> 26:37.680
它用的是啥

26:39.680 --> 26:40.680
它用的

26:40.680 --> 26:41.680
它啥也没写

26:41.680 --> 26:42.680
啥也没写的话

26:42.680 --> 26:44.680
每一次都还是要重新寝求

26:45.680 --> 26:47.680
那么这个MAXA就之前说了

26:47.680 --> 26:49.680
不再坠述

26:49.680 --> 26:51.680
OK 这是关于開始控制

26:52.680 --> 26:55.680
这个制断其实是很早的一个制断

26:55.680 --> 26:57.680
但是在响用头里边

26:57.680 --> 27:00.680
我们之前响用头里面就是在四个制断

27:00.680 --> 27:02.680
它还可以有一个Xper

27:02.680 --> 27:04.680
我看一下百度这里有没有

27:04.680 --> 27:06.680
你看Xper

27:06.680 --> 27:08.680
好像少许个S吧

27:11.680 --> 27:13.680
这个制断其实是一个

27:13.680 --> 27:16.680
为了支持早期版本的ADDP

27:16.680 --> 27:17.680
1.0的版本

27:17.680 --> 27:19.680
现在基本上普遍使用的是1.1

27:19.680 --> 27:20.680
1.0的版本的时候

27:20.680 --> 27:22.680
它用来指定过期时间

27:22.680 --> 27:23.680
当时它不用的不是MAXA

27:23.680 --> 27:26.680
它用的是这个制断来指定过期时间点

27:26.680 --> 27:28.680
现在基本上用的

27:28.680 --> 27:30.680
基本上都在开始控制里边用MAXA

27:30.680 --> 27:31.680
来指定的

27:31.680 --> 27:33.680
所以说现在对于大部分浏览器而言

27:33.680 --> 27:35.680
这个制断是可以不要的

27:35.680 --> 27:36.680
不用的

27:36.680 --> 27:37.680
只是很多服务器

27:37.680 --> 27:39.680
为了支持各种版本的浏览器

27:39.680 --> 27:42.680
它也给你加了这个制断

27:43.680 --> 27:44.680
然后下面这个就是

27:44.680 --> 27:47.680
记录缓存时的有效期

27:47.680 --> 27:49.680
就是它到底怎么制造这个缓存

27:49.680 --> 27:50.680
有没有过期

27:50.680 --> 27:52.680
它这里边是一个逻辑判断的

27:53.680 --> 27:54.680
首先受到服务器的响应的时候

27:54.680 --> 27:56.680
它看一下你有没有MAXA一击

27:56.680 --> 27:57.680
有没有这个制断

27:57.680 --> 27:58.680
你看刚才我们看服务

27:58.680 --> 28:01.680
百度这一块是没有这个制断的

28:04.680 --> 28:05.680
没有这个制断的

28:07.680 --> 28:09.680
刚才说里边是没有MAXA一击的

28:09.680 --> 28:11.680
有的时候有可能有有可能没有

28:11.680 --> 28:12.680
如果说你有MAXA一击的话

28:12.680 --> 28:15.680
那么它就会找到有没有DET制断

28:15.680 --> 28:17.680
我们之前看了服务器

28:17.680 --> 28:20.680
除了MAXA一击之外

28:20.680 --> 28:22.680
是不是还给了我们的DET制断

28:22.680 --> 28:23.680
那么由这两个制断的话

28:23.680 --> 28:25.680
它就可以确定过期时间点了

28:25.680 --> 28:26.680
对不对

28:26.680 --> 28:27.680
非常简单就是

28:27.680 --> 28:29.680
你这个DET制断加上MAXA一击

28:29.680 --> 28:30.680
如果说你没有DET制断

28:30.680 --> 28:31.680
但是有MAXA一击的话

28:31.680 --> 28:34.680
它就是用扣不断的时间加上MAXA一击

28:34.680 --> 28:36.680
它就是一支这么一套模具

28:36.680 --> 28:37.680
如果说你连MAXA一击都没有的话

28:37.680 --> 28:39.680
就像这里没有MAXA一击的话

28:39.680 --> 28:42.680
那么它会去看LAST Modify的制断

28:42.680 --> 28:44.680
就是文件上一次修改时间

28:45.680 --> 28:46.680
你看这里有没有呢

28:46.680 --> 28:48.680
LAST Modify的

28:48.680 --> 28:49.680
是有

28:49.680 --> 28:50.680
也没有

28:50.680 --> 28:52.680
那如果是LAST Modify的制断也没有的话

28:52.680 --> 28:53.680
它就不缓存了

28:53.680 --> 28:54.680
根本就不缓存了

28:54.680 --> 28:55.680
是这么个意思

28:55.680 --> 28:58.680
如果说有LAST Modify的制断的话

28:58.680 --> 28:59.680
那么它就会用当前时间

28:59.680 --> 29:00.680
减去LAST Modify的

29:00.680 --> 29:02.680
反正就是用这个做个算法

29:02.680 --> 29:04.680
来确定这个MAXA一击

29:04.680 --> 29:06.680
就是这么一套模具

29:10.680 --> 29:12.680
这里有个小的细节

29:12.680 --> 29:13.680
就是MAXA一击

29:14.680 --> 29:18.680
还有这个PROGMA

29:18.680 --> 29:20.680
这也是1.0的消息头

29:20.680 --> 29:21.680
了解一下就行了

29:22.680 --> 29:26.680
它的作用跟那个LOCACHE作用是一样的

29:26.680 --> 29:28.680
只不过现在1.1%里边

29:28.680 --> 29:30.680
都是使用的是LOCACHE

29:30.680 --> 29:31.680
你看这

29:31.680 --> 29:34.680
再加上一个PROGMA LOCACHE

29:34.680 --> 29:36.680
那么跟现在的就是CATCH CONTROL LOCACHE

29:36.680 --> 29:37.680
是一样的

29:37.680 --> 29:39.680
就是浮气响应

29:39.680 --> 29:41.680
就是那个请求的时候

29:46.250 --> 29:49.250
它出现的请求东是向浮气表达

29:49.250 --> 29:51.250
不要考虑任何缓存

29:51.250 --> 29:53.250
你给我一个正常结果

29:53.250 --> 29:55.250
就这么个意思

29:55.250 --> 29:58.070
How Very

29:58.070 --> 30:00.070
这个玩意是

30:00.070 --> 30:02.070
有的时候还是蛮有用的

30:02.070 --> 30:04.070
就是有些资源呢

30:05.070 --> 30:08.070
它可能要区分请求投的

30:09.070 --> 30:11.070
它跟请求路径有关系

30:11.070 --> 30:13.070
还跟请求投有关系

30:13.070 --> 30:14.070
我这个虚下去的例子

30:14.070 --> 30:16.070
比方说你请求一个NEWS

30:18.070 --> 30:20.070
用接着请求去请求这个例子

30:20.070 --> 30:22.070
得到了是一个

30:22.070 --> 30:24.070
新闻

30:24.070 --> 30:26.070
列表

30:26.070 --> 30:28.070
那么这个页面我们假设

30:28.070 --> 30:30.070
是可以缓存的

30:30.070 --> 30:32.070
但是呢

30:32.070 --> 30:33.070
它跟

30:33.070 --> 30:35.070
每个人看到的新闻列表

30:35.070 --> 30:36.070
它有可能不一样

30:36.070 --> 30:38.070
它可能跟COOKE有关系

30:38.070 --> 30:40.070
比方说COOKE也是这个用户

30:40.070 --> 30:41.070
UID等于

30:41.070 --> 30:44.070
这个用户它看到的新闻列表

30:44.070 --> 30:45.070
还是这个请求

30:45.070 --> 30:46.070
还是这个路径

30:46.070 --> 30:48.070
它看到新闻列表是这个列表

30:48.070 --> 30:49.070
那么另一个用户看到新闻列表

30:49.070 --> 30:51.070
可能是另外一个列表

30:51.070 --> 30:52.070
那么这个时候要做缓存的话

30:52.070 --> 30:54.070
是不是还要区分COOKE

30:54.070 --> 30:56.070
你不能光同路径和

30:56.070 --> 30:57.070
这个地方的区分

30:57.070 --> 30:58.070
你还要通过COOKE来区分

30:58.070 --> 31:00.070
那么Very就是起这么一个作用

31:00.070 --> 31:03.070
它是用来区分指定的消息投

31:03.070 --> 31:04.070
因为我这里以COOKE为例

31:04.070 --> 31:06.070
不一定也是COOKE

31:06.070 --> 31:07.070
比如呢

31:07.070 --> 31:09.070
你用接着去请求这个例子

31:09.070 --> 31:10.070
那么请求的COOKE不一样

31:10.070 --> 31:12.070
那么得到的页面也不一样

31:12.070 --> 31:13.070
按照之前的做法

31:13.070 --> 31:14.070
它如果说只匹配

31:14.070 --> 31:16.070
请求方法和请求路径的话

31:16.070 --> 31:17.070
哪怕你COOKE变了

31:17.070 --> 31:19.070
它得到的仍然是之前的页面

31:19.070 --> 31:21.070
那么正确的做法是什么呢

31:21.070 --> 31:24.070
是要验证消息投动的COOKE

31:24.070 --> 31:26.070
比方说这里的一个逻辑

31:26.070 --> 31:27.070
可不可以请求服务器

31:27.070 --> 31:28.070
请求这个例子

31:28.070 --> 31:29.070
给它带来一个COOKE

31:29.070 --> 31:31.070
服务器给它一个响应结果

31:31.070 --> 31:32.070
那么这个时候呢

31:32.070 --> 31:34.070
它就会加一个响应头

31:34.070 --> 31:35.070
服务器那边觉得

31:35.070 --> 31:36.070
COOKE不一样

31:36.070 --> 31:37.070
那也不一样

31:37.070 --> 31:38.070
所以说要高速浏览器

31:38.070 --> 31:41.070
你要区分COOKE

31:41.070 --> 31:43.070
浏览器在记录的时候

31:43.070 --> 31:45.070
它就会加一个COOKE

31:45.070 --> 31:46.070
123

31:46.070 --> 31:48.070
COOKE之前请求的是123

31:48.070 --> 31:50.070
它就加一个这个东西

31:50.070 --> 31:51.070
那么将来呢

31:51.070 --> 31:52.070
如果说你请求这个例子

31:52.070 --> 31:53.070
COOKE还是123

31:53.070 --> 31:54.070
那么就命中了

31:54.070 --> 31:55.070
那么就直接使用法循结果

31:55.070 --> 31:56.070
那如果说你将来

31:56.070 --> 31:57.070
这个方法没变

31:57.070 --> 31:58.070
但是请求路径也没变

31:58.070 --> 32:00.070
但是COOKE变了

32:00.070 --> 32:01.070
那这个时候就无法命中了

32:01.070 --> 32:02.070
于是它要重新

32:02.070 --> 32:03.070
从服务器方程请求

32:03.070 --> 32:05.070
服务器再给它一个响应

32:05.070 --> 32:06.070
那么这个时候呢

32:06.070 --> 32:07.070
它就进度新的COOKE

32:07.070 --> 32:08.070
这个路径

32:08.070 --> 32:10.070
那么有个新的缓存

32:10.070 --> 32:12.070
就这么个意思

32:13.070 --> 32:14.070
那么最后呢

32:14.070 --> 32:15.070
我说一下

32:15.070 --> 32:16.070
我们跟我们开发相关的

32:16.070 --> 32:19.070
开发相关对我们前段开发者而言

32:19.070 --> 32:20.070
为什么说

32:20.070 --> 32:21.070
CSS

32:21.070 --> 32:22.070
GS

32:22.070 --> 32:23.070
那些东西

32:23.070 --> 32:24.070
直接给它缓存了

32:24.070 --> 32:25.070
十年一百年都没问题

32:25.070 --> 32:26.070
难道说将来

32:26.070 --> 32:28.070
GS永远不会变化吗

32:28.070 --> 32:29.070
不是的

32:29.070 --> 32:31.070
是因为我们现在前段

32:31.070 --> 32:33.070
都是基于工程化来开发的

32:33.070 --> 32:34.070
就是利用了很多的

32:34.070 --> 32:35.070
构建工具

32:35.070 --> 32:36.070
比方说像微派的

32:36.070 --> 32:37.070
那么它里边

32:37.070 --> 32:38.070
会有个文件指纹

32:38.070 --> 32:39.070
对不对

32:39.070 --> 32:40.070
每个文件

32:40.070 --> 32:41.070
内容不变

32:41.070 --> 32:43.070
它的哈希指就不变

32:43.070 --> 32:44.070
文件内容一变

32:44.070 --> 32:45.070
它的哈希指就变化了

32:45.070 --> 32:46.070
对不对

32:46.070 --> 32:47.070
我们是不是经常用这种

32:47.070 --> 32:48.070
这种做法

32:48.070 --> 32:49.070
那么这样做法的好处

32:49.070 --> 32:50.070
又在于呢

32:50.070 --> 32:51.070
这个文件

32:51.070 --> 32:53.070
我就可以让它缓存十年

32:53.070 --> 32:54.070
为什么呢

32:54.070 --> 32:56.070
如果说将来文件变了

32:56.070 --> 32:57.070
它就不再是这个文件了

32:57.070 --> 32:59.070
它路径就会变

32:59.070 --> 33:00.070
对吧

33:00.070 --> 33:01.070
一看那个文件变了

33:01.070 --> 33:02.070
它的哈希指是不是变了

33:02.070 --> 33:03.070
哈希指一变

33:03.070 --> 33:04.070
它的路径是

33:04.070 --> 33:05.070
请求路径是不是变了

33:05.070 --> 33:06.070
那请求路径变了

33:06.070 --> 33:07.070
它之前的缓存自然而来

33:07.070 --> 33:09.070
就命中不了了

33:09.070 --> 33:10.070
就会使用新的

33:10.070 --> 33:12.070
所以说它现在不存在

33:12.070 --> 33:13.070
这样的一个问题

33:13.070 --> 33:14.070
过去呢

33:14.070 --> 33:15.070
没有这种工程化工具

33:15.070 --> 33:17.070
那么过去是怎么做的呢

33:17.070 --> 33:18.070
我们过去呢

33:18.070 --> 33:19.070
会用

33:19.070 --> 33:20.070
要么就是手动

33:20.070 --> 33:21.070
要么就是用一些小工具

33:21.070 --> 33:22.070
它会通过这个地

33:22.070 --> 33:24.070
也是让地址发生变化

33:24.070 --> 33:25.070
比方说我们

33:25.070 --> 33:26.070
请求这个地址的时候

33:26.070 --> 33:27.070
你给我缓存十年吧

33:27.070 --> 33:28.070
无所谓

33:28.070 --> 33:30.070
那将来如果说文件变化了

33:30.070 --> 33:31.070
我会去手动

33:31.070 --> 33:32.070
改一下这个地址

33:32.070 --> 33:33.070
改成1.0.1

33:33.070 --> 33:34.070
对吧

33:34.070 --> 33:36.070
所以说地址路径变了

33:36.070 --> 33:37.070
请求路径是不是变了

33:37.070 --> 33:38.070
路径变了

33:39.070 --> 33:40.070
那么这里有个潜力条件

33:40.070 --> 33:41.070
就是页面

33:41.070 --> 33:43.070
我们一般来说

33:43.070 --> 33:44.070
不缓存

33:44.070 --> 33:45.070
为什么

33:45.070 --> 33:46.070
因为页面都缓存下来了

33:46.070 --> 33:47.070
过后呢

33:47.070 --> 33:48.070
那就没得搞了

33:48.070 --> 33:49.070
你地址

33:49.070 --> 33:50.070
你请求地址都没法更新

33:50.070 --> 33:52.070
你还是用了之前的页面

33:52.070 --> 33:54.070
页面变成这个样子过后

33:54.070 --> 33:56.070
你还用了之前的缓存页面

33:56.070 --> 33:58.070
页面我们一般不缓存

33:58.070 --> 34:00.070
缓存的是外部这些资源

34:00.070 --> 34:01.070
那么就让页面

34:01.070 --> 34:04.070
永远都是实时的最新的

34:04.070 --> 34:05.070
那么页面里边

34:05.070 --> 34:06.070
带来的一些超链接

34:06.070 --> 34:08.070
它有可能路径会发生变化

34:08.070 --> 34:10.070
比方说之前是这个路径

34:10.070 --> 34:12.070
然后后来哈希一遍变成另外一个路径

34:12.070 --> 34:13.070
那么还会请求新的路径

34:13.070 --> 34:14.070
请求新的路径的时候

34:14.070 --> 34:16.070
它就无法运动缓存

34:16.070 --> 34:17.070
就这么一个逻辑

34:17.070 --> 34:19.070
那么最后来我们来总结一下

34:21.070 --> 34:23.070
其实也很简单了对不对

34:23.070 --> 34:24.070
服务器那边

34:24.070 --> 34:25.070
从服务器的视角来看的话

34:25.070 --> 34:27.070
它就是有两种情求

34:27.070 --> 34:29.070
一种就是普通情求

34:29.070 --> 34:32.070
没有任何的缓存指令

34:32.070 --> 34:34.070
它就是没有这个东西

34:34.070 --> 34:36.070
没有这些东西

34:36.070 --> 34:37.070
这服务器

34:37.070 --> 34:38.070
那么我就给它一个正常的响应

34:38.070 --> 34:40.070
如果说我需要让它缓存的话

34:40.070 --> 34:41.070
我就会给它加上开机康处

34:41.070 --> 34:43.070
让它缓存

34:43.070 --> 34:44.070
如果服务器呢

34:44.070 --> 34:46.070
还有可能会是到另外一种情求

34:46.070 --> 34:48.070
就是带有缓存指令的

34:48.070 --> 34:50.070
就是写上缓存

34:50.070 --> 34:51.070
就带有这个东西的

34:51.070 --> 34:52.070
那么服务器呢

34:52.070 --> 34:53.070
它就会给它一个三零四

34:53.070 --> 34:55.070
表示你还接着用缓存吗

34:55.070 --> 34:57.070
我不给你响应了

34:57.070 --> 34:59.070
然后过的就是两百

34:59.070 --> 35:00.070
那这个缓存不能再用了

35:00.070 --> 35:01.070
我给你新的

35:01.070 --> 35:03.070
这服务器的视角

35:03.070 --> 35:04.070
那浏览器的视角

35:04.070 --> 35:06.070
那就是我们刚才说的

35:06.070 --> 35:09.070
就看服务器的响应

35:09.070 --> 35:11.070
就每一次请求的时候

35:11.070 --> 35:12.070
要判断缓存

35:12.070 --> 35:14.070
道理是普通请求

35:14.070 --> 35:17.070
还是写上请求

35:17.070 --> 35:19.070
还是直接使用缓存

35:19.070 --> 35:21.070
它会进行判断

35:21.070 --> 35:23.070
那么请求过去服务器响应呢

35:23.070 --> 35:25.070
它有可能带了开机康处

35:25.070 --> 35:26.070
带了开机康处

35:26.070 --> 35:28.070
那就有缓存就更新

35:28.070 --> 35:30.070
没有缓存就添加

35:30.070 --> 35:32.070
如果说得到是三零四的话

35:32.070 --> 35:34.070
就使用之前的缓存了

35:34.070 --> 35:37.070
这就是他们整个的逻辑

35:37.070 --> 35:39.070
还是比较简单的

35:39.070 --> 35:40.070
面试的时候

35:40.070 --> 35:41.070
能够把这张图给它描述清楚

35:41.070 --> 35:43.070
第一次请求怎么样

35:43.070 --> 35:45.070
后续有了缓存之后怎么样

35:45.070 --> 35:47.070
缓存过期的过后有怎么样

35:47.070 --> 35:49.070
然后给它描述清楚

35:49.070 --> 35:50.070
那就OK了

35:50.070 --> 35:53.070
这是关于ATV里面的缓存

