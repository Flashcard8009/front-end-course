WEBVTT

00:00.750 --> 00:02.790
大家好 我是谢老师

00:02.790 --> 00:07.150
这节课我们来看一下拉鸡回收和内存泄漏

00:07.670 --> 00:10.230
这里有道面试题 它就问到你

00:10.470 --> 00:15.590
请介绍一下javascript中拉鸡回收站的极值

00:15.850 --> 00:18.150
这里的话就会涉及到什么知识点

00:18.410 --> 00:20.710
那就是首先是一个拉鸡回收

00:20.970 --> 00:24.050
和拉鸡回收相关的还有一个是什么呢

00:24.310 --> 00:27.370
关于内存泄漏的概念

00:27.630 --> 00:28.910
我们这边我们来看一下

00:29.550 --> 00:31.970
首先第一个什么是内存泄漏

00:32.230 --> 00:35.050
我们知道我们程序运行的话它是需要内存的

00:36.070 --> 00:37.870
对不对 我们所有的东西

00:38.130 --> 00:39.410
比如你声明一个辩量

00:39.670 --> 00:41.710
或者随便就不说辩成吧

00:41.970 --> 00:44.270
我们就说比如说你无论是看电影还是听歌

00:44.530 --> 00:46.570
最终的话它是运行的是一段代码

00:47.090 --> 00:48.370
对吧 执行的是一个程序

00:48.630 --> 00:50.930
最终这个程序的话它会被夹载到哪里去了

00:51.190 --> 00:52.970
会被夹载到内存里面

00:54.510 --> 00:55.010
看到没有

00:55.270 --> 00:57.070
所以你操作系统

00:57.330 --> 00:58.610
你在就是

00:59.110 --> 01:01.930
执行操作的时候你必须要有这个内存

01:02.450 --> 01:04.490
理论上来讲的话你这个内存越大

01:04.750 --> 01:07.310
那你用起来的这个体验就越流畅

01:07.570 --> 01:08.850
你内存越小

01:09.370 --> 01:11.150
那你用着你的这个电脑

01:11.410 --> 01:12.690
你就感觉越卡

01:12.950 --> 01:15.510
对吧 尤其是我们感觉这个为什么这个电脑这么卡

01:15.770 --> 01:17.810
原因很简单就是你的内存不够用了

01:18.310 --> 01:20.610
用所有东西啊无论你是玩游戏还是

01:20.870 --> 01:22.150
也好看电影也好

01:22.410 --> 01:24.210
最终的话它都会被夹载到

01:24.470 --> 01:25.230
内存里面

01:25.490 --> 01:28.810
CPU只能和什么呢只能和内存打交道

01:29.370 --> 01:30.910
他只能和内存打交道

01:31.670 --> 01:31.930
好

01:32.190 --> 01:34.750
那我们写程序那自然而然比如我们声明一个辩量

01:35.010 --> 01:36.530
挖一个i等于1

01:36.790 --> 01:39.870
那自然而然是不是内存也要给我分配一个空间

01:40.890 --> 01:41.410
对不对

01:41.670 --> 01:42.690
也要给我分配一个空间

01:42.950 --> 01:44.990
那这里的话就会涉及到一个问题

01:45.510 --> 01:49.090
你不能只给我分配然后接下来分配就不停的分配不停的分配

01:49.350 --> 01:51.890
那最终的话我这个内存是不是会越用越小

01:52.410 --> 01:55.230
对因为我内存的大小是固定的

01:55.750 --> 01:58.050
就我整个内存的这个大小是固定的

01:58.930 --> 02:00.810
那你这边的只分配不回收

02:01.070 --> 02:02.690
那我整个内存就会越来越小

02:02.950 --> 02:04.150
那最终就会导致什么呢

02:04.410 --> 02:07.210
啊就是你内存占用越来越高

02:07.730 --> 02:10.290
那轻则影响这个系统的这个性能

02:10.810 --> 02:12.290
就你感觉用上去很卡

02:12.550 --> 02:14.890
重则的话导致就是你的这个程序

02:15.150 --> 02:16.530
就直接就崩溃了

02:17.710 --> 02:21.050
所以我们没有用到的内存不用这个辩量已经用完了

02:21.810 --> 02:22.330
对吧

02:22.590 --> 02:23.850
而比如我在函数里面

02:24.890 --> 02:25.810
声明了一个辩量

02:26.010 --> 02:26.890
i是1

02:27.150 --> 02:29.090
然后我的函数已经执行完毕了

02:29.610 --> 02:32.290
执行完毕之后然后接下来我的这个辩量

02:32.550 --> 02:33.190
这个i

02:34.210 --> 02:35.490
他是不是就应该被回收

02:36.510 --> 02:39.490
对不对他就是啊我们称之为要把它释放

02:39.750 --> 02:41.390
或者叫做要把它回收掉

02:42.150 --> 02:45.230
不然的话就会造成的不然就会造成内存泄漏

02:45.990 --> 02:47.790
什么叫做内存泄漏其实很简单

02:48.050 --> 02:52.390
就是你该回收的这些没用的辩量你没有回收

02:53.670 --> 02:55.450
你想想我比如说啊我举个例子

02:56.490 --> 02:57.290
比如说我们这边

02:57.550 --> 02:58.050
嗯

03:00.780 --> 03:01.800
创建一个文件

03:04.210 --> 03:04.730
呃

03:07.510 --> 03:08.030
ok

03:08.550 --> 03:10.590
这节课的代码都不需要运行啊

03:10.850 --> 03:12.270
就比如说我这边我方形

03:13.150 --> 03:14.430
方形test

03:16.560 --> 03:18.440
哇一个i等于一个e ok

03:18.700 --> 03:21.080
好了那接下来我这边我调用这个方法

03:21.340 --> 03:22.280
调用这个函数

03:22.540 --> 03:24.240
然后调用这个函数之后

03:25.260 --> 03:27.040
他会执行这里面的代码

03:27.320 --> 03:27.820
对不对

03:28.080 --> 03:28.960
执行这里面的代码

03:28.960 --> 03:31.040
然后加这边你是不是声明了个辩量i

03:31.400 --> 03:32.800
让我是不是内存里面叫

03:33.040 --> 03:34.060
分配一个地址啊

03:35.600 --> 03:36.120
对不对

03:36.360 --> 03:37.640
我给你进行一个内存的分配

03:37.900 --> 03:39.180
好当我执行完之后

03:39.440 --> 03:40.200
他还有没有用

03:41.480 --> 03:42.260
他说就没有用了

03:42.760 --> 03:44.040
对没有用那你就需要干嘛

03:44.300 --> 03:46.360
所以你就需要把这个辩量给我回收掉

03:46.860 --> 03:51.480
那不然我这边我调用一次啊调用一次你给我分配一个调用一次你给我分配一个

03:51.740 --> 03:53.520
那最终你的这个内存是不是就会被

03:54.040 --> 03:54.800
越用越小

03:55.820 --> 03:56.840
对不对啊

03:57.360 --> 03:58.380
说这边就是

03:58.640 --> 04:01.720
什么叫做内存泄漏其实很简单就是你该回收的

04:03.240 --> 04:05.800
该回收的你没有及时的回收

04:06.060 --> 04:07.240
或者没有及时的

04:07.500 --> 04:08.120
释放

04:09.400 --> 04:10.680
就是不再用的内存啊

04:10.940 --> 04:11.960
不再用到的内存

04:12.220 --> 04:13.740
你没有及时的回收

04:14.000 --> 04:15.540
或者没有及时的释放

04:15.800 --> 04:16.560
那这个就叫做

04:16.820 --> 04:17.580
内存泄漏

04:19.120 --> 04:20.400
英语叫做这个

04:20.660 --> 04:21.680
memory leak

04:21.940 --> 04:22.960
leak就是泄漏的意思

04:24.240 --> 04:26.800
好那接下来我们来看一下这个垃圾回收

04:27.060 --> 04:28.600
在我们这个jama script里面

04:28.860 --> 04:29.620
这个垃圾回收

04:29.880 --> 04:30.900
他是如何做的

04:31.520 --> 04:35.460
就有些语言的话他是要求什么呢要求你手动释放

04:35.720 --> 04:36.700
比如说

04:38.020 --> 04:39.120
比如说

04:40.580 --> 04:42.620
好但是这样子呢就比较麻烦

04:42.880 --> 04:46.980
比如说有些时候我们比如用C原写代码的时候啊写hi了

04:47.240 --> 04:49.020
你忘记去释放那个

04:49.280 --> 04:50.560
释放某一个辩量了

04:50.820 --> 04:51.840
那就会导致你

04:52.100 --> 04:54.660
就经常就是你的这个程序就崩溃掉

04:55.940 --> 04:58.500
说后面的话就是后面的一些新的语言比如说jama

04:59.020 --> 05:00.380
从jama开始的话他就提

05:00.800 --> 05:04.420
就是提供了什么呢提供了这个自动的这个垃圾回收机制

05:04.940 --> 05:06.740
就你程序员的话你不需要去管了

05:07.000 --> 05:09.560
你只需要写什么呢只需要写你的业务逻辑

05:10.060 --> 05:12.620
啊就是你写一段代码是不是要实现某个业务

05:13.140 --> 05:15.180
对不对你主要去注重你的业务逻辑

05:15.440 --> 05:18.760
那像这种垃圾回收这种这种事情啊

05:19.280 --> 05:21.320
就我这边语言的话我这边

05:21.580 --> 05:24.900
会给你实现啊自动的来进行一个垃圾回收

05:25.160 --> 05:26.960
那比如说我们的这个JS

05:27.220 --> 05:30.280
JS的话他也是啊具有自动垃圾回收

05:30.420 --> 05:30.880
机制

05:31.400 --> 05:33.200
自动来做的程序员不需要管

05:33.720 --> 05:36.520
啊那这个什么叫做自动垃圾回收机制呢

05:36.780 --> 05:38.580
他就是垃圾收集器

05:38.840 --> 05:40.100
会定期的

05:40.360 --> 05:43.180
找出那些不再继续使用的辩量

05:43.700 --> 05:44.460
然后

05:44.720 --> 05:45.480
释放内存

05:46.760 --> 05:48.300
可不可以啊就这个

05:48.560 --> 05:49.580
动作他是自动的

05:49.840 --> 05:51.880
在后台自动的这个进行一个

05:52.140 --> 05:52.660
执行

05:54.700 --> 05:56.760
但是这个过程呢他不是

05:57.020 --> 05:57.780
实实的

05:58.240 --> 06:00.300
啊为什么因为他开销一般他比较大

06:00.800 --> 06:02.600
啊说说这个垃圾回收

06:02.860 --> 06:05.660
回收器的话他一般是在固定的时间

06:05.920 --> 06:09.000
间隔这个周期性的进行一个执行

06:09.260 --> 06:09.760
啊

06:10.020 --> 06:11.560
好那我们这边我们来看段代码

06:11.820 --> 06:14.380
啊这段代码也非常简单首先这边有一个F1

06:14.640 --> 06:16.160
F1里面是不是声明了一个

06:16.420 --> 06:18.220
辩量叫做这个OB界

06:18.720 --> 06:21.540
那只要你声明一个辩量是不是我内存要给你分配空间

06:22.300 --> 06:22.820
对不对

06:23.080 --> 06:24.600
好大家这边有个F2

06:24.860 --> 06:27.440
我是不是也是声明了一个这个OB界

06:28.260 --> 06:29.520
声明了一个这个OB界之后

06:29.780 --> 06:31.060
这样我这边做了一件事情

06:31.320 --> 06:31.820
我干嘛呀

06:32.080 --> 06:33.880
我说把这个对象是不是返回出去

06:34.640 --> 06:35.160
对不对

06:35.420 --> 06:39.000
好那接下来这边同样是调用这个F1和F2

06:39.260 --> 06:40.280
那这个A的话

06:40.540 --> 06:42.320
因为这边没有返回之所以是antify

06:42.580 --> 06:43.400
那接下来这边B

06:43.660 --> 06:44.880
B的话是不是就拿到这个对象

06:45.660 --> 06:47.960
说说当你执行这两句代码的时候

06:48.460 --> 06:49.480
执行完毕之后

06:49.740 --> 06:52.040
然后你F1里面的这个OB界

06:53.080 --> 06:53.840
他就会干嘛呢

06:54.100 --> 06:56.920
他就会被这个垃圾回收器自动的释放

06:57.380 --> 06:58.660
为什么因为你没用了吗

06:59.420 --> 07:02.760
对不对已经没用了你这个F1执行完毕之后你这个对象

07:03.520 --> 07:04.560
这再也没有用出了

07:04.820 --> 07:07.360
对不对他就会被这个垃圾回收器自动释放

07:07.620 --> 07:10.180
但我们刚才说过他是怎么的他不是实时的

07:10.440 --> 07:13.520
不是说你调用完这个F1他立马就释放了不是

07:13.780 --> 07:15.560
他是这个每隔一段时间

07:15.820 --> 07:17.340
这个定期的这个执行

07:17.860 --> 07:19.140
那么这个F2

07:19.400 --> 07:21.060
F2的这个对象

07:21.320 --> 07:22.480
他会不会被释放呢

07:22.980 --> 07:23.740
他不会

07:24.260 --> 07:25.800
不会为什么呢原因很简单

07:26.000 --> 07:27.540
因为你这边是不是return

07:27.800 --> 07:30.360
是把他返回到外部然后谁接受到了

07:30.620 --> 07:32.160
是不是这个B接受到了

07:32.660 --> 07:34.960
B接受到了也就是说B这个辩量

07:35.220 --> 07:38.040
他还保留了这个对象的这个引用

07:39.320 --> 07:39.820
对不对

07:40.080 --> 07:43.160
说这一块垃圾他是不会被释放的

07:43.680 --> 07:45.200
他是不会被释放的

07:45.460 --> 07:45.980
可能没有

07:46.740 --> 07:49.040
好这就是一个非常简单的例子

07:50.320 --> 07:53.920
好然后这里就出现一个问题啊到底哪个辩量

07:54.900 --> 07:56.420
再用哪个没有用

07:57.460 --> 07:59.620
啊那究竟我们这个就是

07:59.880 --> 08:00.780
垃圾回收

08:01.040 --> 08:03.860
就是这个垃圾回收器是吧垃圾收集器

08:04.360 --> 08:06.680
你这边定期了要找这个垃圾

08:06.940 --> 08:09.740
对吧找到之后然后接下来把他这个释放掉

08:10.000 --> 08:11.780
那你究竟你怎么找的

08:12.040 --> 08:13.320
啊究竟怎么找的

08:13.580 --> 08:16.900
那这里通常的话其实就是有两种方式

08:17.160 --> 08:19.220
一个叫做标记清除

08:19.720 --> 08:21.780
一个叫做引用技术

08:22.500 --> 08:25.640
啊那现在目前来讲的话用的比较多的就是这个

08:26.340 --> 08:30.940
标记清除啊因为这个引用技术的话他有一般有一个这个bug

08:31.200 --> 08:33.520
就是循环引用啊我们一个一个来看嘛

08:34.280 --> 08:36.580
那首先的话我们这边来看这个标记清除

08:37.860 --> 08:41.960
呃街市中最常用的这个回收方式就是什么就是标记清除

08:42.480 --> 08:45.280
什么叫做标记清除啊比如说我们这边举个例子

08:45.800 --> 08:47.840
比如你在函数中声明的一个辩量

08:48.100 --> 08:50.920
那就会将这个辩量标记为进入环境

08:51.140 --> 08:54.460
就给他打一个标签说白了啊就好比你那个

08:54.960 --> 08:57.540
超市里面的每个东西上面是不是贴一个标签

08:58.040 --> 08:58.540
对不对

08:59.060 --> 09:02.400
好从逻辑上来讲永远不能释放进入环境

09:02.660 --> 09:05.720
辩量所占的类传因为我打的标记是不叫做进入环境

09:06.240 --> 09:09.300
对不对所以只要你的辩量他的标签为进入环境

09:10.320 --> 09:12.380
他就不能被这个清除啊

09:12.900 --> 09:14.940
然后当这个辩量离开的时候

09:15.460 --> 09:17.500
我们就干嘛了这个再给他打一个标记

09:17.760 --> 09:20.320
叫做离开环境啊比如说这边举个例子

09:20.540 --> 09:23.100
A等于10是不是声明了个A辩量

09:23.360 --> 09:26.340
那这边给他打个标记叫做什么叫做进入环境

09:26.860 --> 09:27.700
好这边B

09:27.960 --> 09:30.780
等于20打个标记叫做进入环境

09:31.280 --> 09:32.900
好然后接下来这边是不是调用这个

09:33.160 --> 09:35.380
调用完了之后然后接下来这个

09:35.640 --> 09:36.740
就是Test

09:37.000 --> 09:38.200
这边调用这个函数

09:38.460 --> 09:39.720
调用完B之后

09:39.980 --> 09:42.800
那A B的话我就又会给他打一个标记

09:43.060 --> 09:44.600
叫什么叫做离开环境

09:45.360 --> 09:47.980
然后回头你的那个垃圾回收

09:48.420 --> 09:48.940
回收器

09:49.920 --> 09:51.400
他就会看你的这些辩量

09:51.660 --> 09:53.240
是不是看他的这个标记是什么

09:54.000 --> 09:54.400
对不对

09:54.660 --> 09:57.080
如果你是进入环境好我不回收

09:57.600 --> 10:00.400
如果你是这个离开环境OK

10:00.660 --> 10:02.460
那我是不是就把你回收掉

10:03.220 --> 10:04.760
看到没有啊

10:05.020 --> 10:05.800
说这边

10:06.560 --> 10:07.580
我们来看一下啊

10:08.100 --> 10:10.400
这边垃圾回收器在运行的时候

10:10.660 --> 10:13.460
会给存储在内存中的所有辩量

10:13.720 --> 10:15.260
加上这个标记

10:15.940 --> 10:18.840
然后他会去掉环这个环境中辩量

10:19.100 --> 10:22.180
以及被环境中辩量引用了这个辩量的这个标记

10:22.440 --> 10:23.720
之后的话

10:24.480 --> 10:26.780
再被标加上标记的辩量

10:27.040 --> 10:28.820
将被视为准备删除的辩量

10:29.080 --> 10:31.140
就之后再加标记的话加的就是这个

10:31.640 --> 10:32.920
离开环境的这个标记

10:34.200 --> 10:36.240
然后最后这个垃圾回收器

10:36.500 --> 10:38.800
他完成内存这个清除工作

10:39.060 --> 10:41.120
消除那些带这个标记

10:41.380 --> 10:42.640
带这个离开环境的

10:42.900 --> 10:44.440
这种标记值的这个辩量

10:45.420 --> 10:47.200
回收他们所占用的

10:47.460 --> 10:48.220
内存空间

10:49.000 --> 10:52.840
目前来讲的话就是IE9以上然后FireFox

10:53.100 --> 10:55.660
就这些浏览器就是我们常用的这些浏览器

10:55.920 --> 10:57.200
用的都是什么呢都是

10:57.700 --> 10:58.720
标记清除法

10:59.240 --> 11:00.260
或者类似的

11:00.520 --> 11:02.560
和这个这个策略类似的这种

11:03.080 --> 11:05.120
垃圾回收的这种方式

11:05.380 --> 11:06.920
这个叫做标记清除

11:07.420 --> 11:08.920
其实你就简单理解就是

11:09.180 --> 11:11.280
你进入到这个环境我给你打一个标记

11:11.540 --> 11:13.060
出去之后我给你打一个标记

11:13.260 --> 11:14.800
那两个标记是不是肯定是不一样的

11:15.580 --> 11:17.100
对不对那回头的话我就找

11:17.620 --> 11:20.180
找就是哪个是这种标记的

11:20.440 --> 11:23.240
他不见了他就是打了标记叫做离开环境

11:23.500 --> 11:26.060
那就标记可能是其他的一个单词啊或者之类的

11:26.320 --> 11:28.120
反正我就找了一个特定的单词

11:28.380 --> 11:30.420
对吧只要是这个值的

11:30.680 --> 11:31.700
只要是这个值的

11:31.960 --> 11:33.240
那我就把他回收掉

11:34.000 --> 11:34.520
怎么样

11:34.780 --> 11:36.560
这就是这个标记清除

11:37.840 --> 11:38.880
那还有种方式

11:39.380 --> 11:42.460
还有种方式是什么呢还有种方式叫做引用技术

11:43.260 --> 11:44.020
引用技术

11:44.280 --> 11:46.680
就是我去对你的一个这个辩量

11:46.940 --> 11:48.580
你的引用次数

11:48.840 --> 11:50.680
我去进行一个技术

11:50.940 --> 11:51.720
比较举个例子

11:51.980 --> 11:52.860
我们看这段代码

11:53.380 --> 11:55.300
这边那是不是有一个这个A这个对象

11:56.060 --> 11:59.640
啊这边A的话你是不是创建了一个这个A它是一个对象

11:59.900 --> 12:00.940
那既然是对象那

12:01.200 --> 12:03.240
你这边说要分配一个内存地址

12:03.740 --> 12:05.280
对不对好那他这边就

12:05.540 --> 12:06.560
记住你这个A

12:06.820 --> 12:09.900
啊A的话他被引用了就这个对象这个对象这个地址

12:10.160 --> 12:12.460
被引用被谁引用被A引用

12:12.920 --> 12:14.000
好那既然我就技术

12:14.260 --> 12:15.020
技术唯一

12:15.780 --> 12:18.600
好然后接下来我这边的话我这边这个A

12:18.860 --> 12:21.420
A的话是不是就指向这个对象的地址啊

12:21.940 --> 12:22.960
对不对指向他的

12:23.220 --> 12:24.740
然后我又把他给这个B

12:25.520 --> 12:29.620
让我这个A指向的这个对象的引用次数是不是就再次增加了

12:30.380 --> 12:30.900
对不对

12:31.140 --> 12:32.420
变成这个2

12:33.700 --> 12:37.540
好那既然我又把这个A我再次给谁呢又再次给C

12:38.060 --> 12:40.100
那A指向的这个对象就这个对象

12:41.080 --> 12:43.380
他的引用次数是不是就又增加了

12:43.640 --> 12:45.440
对不对他现在就是分别有A

12:46.200 --> 12:46.700
B

12:46.960 --> 12:47.480
C

12:47.740 --> 12:51.320
这三个引用者说他的引用次数就是多少呢就是3

12:52.600 --> 12:57.200
好那你看这边这边那下行代码下行代码我这个B我是不是重新给他负责

12:57.460 --> 12:59.500
负责为了一个新的对象

13:00.020 --> 13:02.060
那负责为一个新的对象之后

13:02.580 --> 13:03.340
这个对象

13:04.380 --> 13:06.420
他就被谁呢他是不是被B引用者的

13:07.180 --> 13:09.500
对不对那这个对象他的引用次数就是

13:09.700 --> 13:10.420
1

13:10.680 --> 13:14.820
那既然这个对象这个对象的话他由于这个B已经没有再引用他了

13:15.080 --> 13:16.780
他的引用次数就变成2几

13:17.140 --> 13:18.160
就重新变成2

13:18.920 --> 13:19.180
对不对

13:19.440 --> 13:20.720
那我就根据这个引用

13:20.980 --> 13:23.480
引用的这个次数来进行一个技术

13:23.740 --> 13:26.360
直到什么呢直到你的这个引用

13:26.620 --> 13:27.120
次数

13:27.380 --> 13:28.660
为0的时候

13:29.420 --> 13:33.720
为0的时候让我就会发现那现在的话你的整个这个

13:33.980 --> 13:36.080
程序里面是没有任何的变量

13:36.340 --> 13:37.100
去引用他

13:37.620 --> 13:39.400
对不对因为你这个引用次数为0的吗

13:39.800 --> 13:41.300
让我这个垃圾回收器

13:41.800 --> 13:43.080
那我就会回收

13:43.340 --> 13:44.620
这个没有用的这个对象

13:45.640 --> 13:45.900
看到没有

13:47.940 --> 13:49.480
好这个网景浏览器

13:49.740 --> 13:53.580
最早就是使用什么呢使用这个引用技术的这个策略

13:53.840 --> 13:55.620
但是很快他遇到了一个问题

13:56.140 --> 13:57.680
叫什么呢叫做循环引用

13:57.940 --> 13:59.460
什么叫做循环引用我们看一下

13:59.980 --> 14:00.740
首先这个对象

14:01.260 --> 14:03.300
这个对象是被A引用

14:03.820 --> 14:05.360
对不对然后接下这个对象

14:05.860 --> 14:07.400
这个对象被B引用

14:07.620 --> 14:10.160
好然后接下来我又把B给了谁

14:10.420 --> 14:12.220
就给了A的一个属性

14:13.500 --> 14:14.000
看到没有

14:14.260 --> 14:15.540
给了A的一个属性

14:15.800 --> 14:17.340
然后接下来我又把A

14:17.600 --> 14:19.380
给了一个B的一个属性

14:20.660 --> 14:22.200
这个形成了一个这个循环啊

14:22.960 --> 14:24.500
对不对我们这边我们来看一下

14:24.760 --> 14:27.320
好以上代码A和B的引用次数都是2

14:27.580 --> 14:29.360
FN执行完毕之后

14:29.620 --> 14:30.400
两个对象都

14:30.660 --> 14:31.680
离开这个环境

14:31.940 --> 14:35.000
在这个标记清除的方式下是没有问题的

14:35.460 --> 14:37.760
但是在引用技术策略下

14:38.020 --> 14:40.080
A和B的引用次数都不为例

14:40.580 --> 14:43.400
为什么因为你这边要把B给了这个A点PRO

14:44.420 --> 14:46.720
对不对那他这边的话是不是就还被引用者了

14:47.240 --> 14:48.000
包括这边也是

14:48.260 --> 14:49.280
这边这个A对象

14:49.540 --> 14:50.820
你给了B点PRO

14:51.080 --> 14:52.880
那是不是他也仍然被引用者了

14:53.640 --> 14:54.160
对不对

14:54.420 --> 14:55.940
说说这个垃圾

14:56.460 --> 15:00.300
所以说这两个变量他就不会被垃圾回收器回收

15:00.800 --> 15:02.600
而且你的这个FN函数

15:02.820 --> 15:05.100
你如果调用的这个次数越多

15:05.360 --> 15:06.900
那他就会造成这个

15:07.160 --> 15:07.920
内存泄露

15:08.180 --> 15:09.720
因为他一直不释放嘛

15:10.480 --> 15:12.020
对不对他一直不释放

15:12.280 --> 15:14.320
那你调用的次数越多那就越占内存

15:14.840 --> 15:16.880
在I17和I18上面

15:17.140 --> 15:19.200
这个内存他就会直线上升

15:19.460 --> 15:19.960
OK

15:21.240 --> 15:24.820
这就是我们这个垃圾回收常见的两种方式啊

15:25.080 --> 15:26.100
一个叫做标记

15:26.360 --> 15:26.880
标记法

15:27.380 --> 15:29.680
一个叫做什么呢一个叫做引用技术

15:29.940 --> 15:32.240
但是引用技术的话有一个问题就是

15:32.440 --> 15:33.640
循环引用的问题

15:34.400 --> 15:35.520
对不对啊

15:36.040 --> 15:38.080
好然后接下来看下这道题

15:38.860 --> 15:42.680
请介绍一下JS中垃圾回收的这个机制

15:43.200 --> 15:45.320
那这个首先JS中的话它是这个

15:45.760 --> 15:47.300
自动垃圾回收机制

15:47.560 --> 15:49.080
你这一点你要打出来

15:49.860 --> 15:50.820
它是自动的

15:51.080 --> 15:53.940
它不像这个有塞鱼啊就是我写了代码

15:54.200 --> 15:56.000
我还要手动的去释放内存

15:56.260 --> 15:57.020
啊这个不需要

15:57.540 --> 16:00.860
而第二就是这个垃圾收集器的话它是按照固定的时间啊

16:00.900 --> 16:02.500
就是周期性的执行

16:03.000 --> 16:04.640
啊这个刚才也说了对吧

16:05.160 --> 16:11.060
好那JS中啊常见的垃圾回收的方式这两种一个是标记清楚一个是引用技术

16:11.320 --> 16:13.180
啊那接下来标记清楚

16:13.440 --> 16:17.200
它的工作原理是什么样子的啊你把它大纸的概括一下

16:17.460 --> 16:18.480
然后引用技术

16:18.740 --> 16:19.760
它的工作原理

16:20.020 --> 16:25.140
大概是什么样子的你把它概括一下啊当我这边的话我也已经写了啊

16:25.400 --> 16:27.700
那你可以用自己的这个语言

16:28.200 --> 16:29.240
再组织一遍

16:29.700 --> 16:31.740
再把它就是你脑袋里再想一想

16:32.000 --> 16:35.080
想一想之后然后自己就是用自己的话再组织一遍

16:35.580 --> 16:37.140
标记的话就是打上一个标记

16:37.900 --> 16:39.340
然后回头的话你出

16:39.600 --> 16:40.200
出去那个

16:40.460 --> 16:44.040
就是离开那个环境之后再打一个离开的这个标记

16:44.300 --> 16:44.800
对吧

16:45.060 --> 16:50.940
那回头我这个垃圾回收器的话就针对这个所有打打了这个离开标记的这个变量

16:51.200 --> 16:53.000
就同意进行一个回收

16:54.280 --> 16:55.820
那么引用技术的话那就是什么

16:56.080 --> 16:57.600
是不是看你的这个引用次数

16:58.060 --> 16:59.340
如果引用次数为0

16:59.600 --> 17:03.440
说明就是没有引用了没有引用了让我是不是就是进行回收

17:03.700 --> 17:06.520
但是你这边可以再说一下就是引用技术

17:07.020 --> 17:08.000
它存在一个什么

17:08.260 --> 17:09.080
是循环引用

17:09.580 --> 17:11.380
对了一旦这个循环引用的话

17:11.640 --> 17:14.440
那这个分配的变量它就不会被

17:14.960 --> 17:16.240
垃圾这个回收器

17:16.500 --> 17:17.000
回收

17:17.260 --> 17:19.060
那就会存在一些问题

17:20.340 --> 17:25.200
这就是关于这个垃圾回收和内存泄漏啊大家下来的话把这一块

17:25.460 --> 17:26.220
再看一看

17:26.220 --> 17:28.980
好这期课就先到这里啊再见

