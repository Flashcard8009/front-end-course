WEBVTT

00:00.880 --> 00:02.920
大家好 我是谢老师

00:03.440 --> 00:07.020
这节课的话我们来看一下关于这个事件循环

00:07.280 --> 00:09.840
虽然这个名字叫做露的事件循环

00:10.100 --> 00:13.160
它其实这里的话我们要介绍的不仅是露的

00:13.680 --> 00:15.480
我们会介绍就是浏览器中

00:15.740 --> 00:17.260
它的这个事件循环

00:17.780 --> 00:18.540
是什么样子的

00:18.800 --> 00:20.580
然后露的介石中

00:20.840 --> 00:21.880
它这个事件循环

00:22.140 --> 00:22.900
又是什么样子的

00:23.400 --> 00:24.680
我们一点点来看

00:24.940 --> 00:26.740
这个东西比较多

00:27.000 --> 00:28.520
可能要讲一个多小时

00:29.300 --> 00:30.320
我们这边一点点来看

00:30.880 --> 00:33.940
首先的话我们这边先搞清楚一个东西

00:34.200 --> 00:37.540
现在讲事件循环之前我们先弄清楚

00:37.800 --> 00:39.340
进程和县程

00:40.100 --> 00:41.120
什么是进程

00:41.380 --> 00:42.400
什么是县程

00:43.160 --> 00:47.780
我们经常说就是JS是一门单县程语言

00:48.540 --> 00:49.320
它指的是什么呢

00:49.580 --> 00:50.840
它指的是就是

00:51.100 --> 00:52.640
只有一个县程

00:52.900 --> 00:55.720
来运行我们的这个java script

00:56.740 --> 00:59.540
但其实并不是说我们整个浏览器是单县程的

01:00.000 --> 01:02.560
那我们这边先来看一下吧,先看一下这个县程和

01:02.820 --> 01:03.840
进程的概念

01:04.620 --> 01:05.120
那进程

01:05.380 --> 01:06.400
进程是什么呢

01:06.660 --> 01:09.220
进程的话是这个CPU

01:09.480 --> 01:12.040
它资源分配的最小单位

01:13.320 --> 01:14.600
而这个县程

01:14.860 --> 01:16.380
是CPU调度的

01:16.640 --> 01:17.400
最小单位

01:17.660 --> 01:21.500
一个是资源分配的最小单位,一个是调度的最小单位

01:22.020 --> 01:24.580
而这边的话举了一个很形象的例子就

01:24.840 --> 01:28.160
这个进程和县程的关系就好比是这个工厂

01:28.620 --> 01:29.900
和这个工人

01:30.160 --> 01:30.920
的关系

01:31.180 --> 01:32.200
比如这个进程

01:32.460 --> 01:34.500
进程就好比是一个工厂

01:35.020 --> 01:37.840
比如说我这边的话我有两个工厂是吧

01:38.100 --> 01:40.660
那就相当于我计算机里面有两个进程

01:40.920 --> 01:42.200
每个进程

01:42.460 --> 01:43.980
每个进程有什么呢

01:44.240 --> 01:46.540
有自己的这个资源

01:47.300 --> 01:48.860
对吧有自己的这个资源

01:49.360 --> 01:50.120
而县程

01:50.380 --> 01:53.460
县程好比什么呢,县程就好比这个工人

01:54.740 --> 01:56.280
一个一个的这个功能

01:56.740 --> 02:01.100
这个工人的话他是什么呢,他是在这个工厂里面进行这个工作

02:01.360 --> 02:04.420
他们是不是可以共享这个工厂的这个资源

02:05.700 --> 02:07.500
对不对,他可以共享工厂资源

02:07.760 --> 02:11.080
所以说这个工厂和工人他们的关系就是

02:11.340 --> 02:12.620
1比n的关系

02:13.120 --> 02:13.900
一个工厂

02:14.400 --> 02:16.200
对应了n个工人

02:16.720 --> 02:17.480
一个工厂

02:17.740 --> 02:19.020
他就是一个进程

02:19.520 --> 02:21.320
然后一个工人就是一个县程

02:21.840 --> 02:24.640
然后一个工厂下面有好几个工人

02:24.840 --> 02:29.140
那一个这个进程下面就可以有好几个县程

02:30.220 --> 02:30.740
对不对

02:32.020 --> 02:32.540
好这边

02:33.040 --> 02:35.100
也就是说一个进程

02:35.600 --> 02:38.940
有一个或多个县程组成

02:39.440 --> 02:43.540
县程是一个进程中代码的不同执行路线

02:44.820 --> 02:45.780
还有就是什么呢

02:46.040 --> 02:49.940
还有就是一个进程的内存空间是可以共享的

02:50.440 --> 02:51.480
每个县程

02:51.740 --> 02:53.780
都可以用这些内存空间

02:53.980 --> 02:56.540
因为我们这边一个进程相当于是一个工厂

02:56.800 --> 02:58.080
那我这边每一个工人

02:58.340 --> 03:02.180
每个工人都可以用这个工厂里面的这个资源

03:02.940 --> 03:03.460
明白没有

03:03.720 --> 03:05.000
这就是这个

03:05.260 --> 03:07.560
进程和这个县程

03:07.820 --> 03:09.340
首先把这个搞清楚

03:10.380 --> 03:12.940
然后多个工厂之间是独立存在的

03:13.180 --> 03:15.240
也就是说我这边的话比如我这儿有个工厂

03:15.500 --> 03:16.260
这儿有个工厂

03:16.520 --> 03:18.820
两个工厂之间是互不影响的

03:19.080 --> 03:20.600
那就好比你计算机里面

03:20.800 --> 03:21.780
两个进程

03:22.040 --> 03:24.140
对吧你比如说打开音乐

03:24.640 --> 03:27.200
听歌那他肯定是有一个进程

03:27.460 --> 03:29.520
那接下来你打开你的这个浏览器

03:30.280 --> 03:31.560
他至少又有个进程

03:31.820 --> 03:34.640
那接下来你比如说写代码

03:34.900 --> 03:36.180
他有一个进程

03:36.440 --> 03:39.500
那这个不同的进程之间他们是不会相互

03:39.760 --> 03:40.260
影响的

03:40.780 --> 03:41.280
好吧

03:42.060 --> 03:43.580
好接下来下一个概念

03:44.100 --> 03:45.900
多进程和多县程

03:47.440 --> 03:49.220
那什么是这个多进程呢

03:49.220 --> 03:51.020
在同一时间里

03:51.280 --> 03:52.800
同一个计算机系统

03:53.060 --> 03:53.560
允许

03:53.820 --> 03:56.640
两个或两个以上的进程

03:57.160 --> 03:58.440
处于这个运行状态

03:58.700 --> 04:01.500
也就是我们一个计算机其实可以就是有多个进程

04:02.020 --> 04:04.840
多进程带来的好处是明显的

04:05.100 --> 04:06.880
比如你可以听歌的同时

04:07.140 --> 04:08.940
打开编辑器来敲带嘛

04:09.200 --> 04:11.500
这两个进程之间他们是不会

04:11.760 --> 04:12.520
相互影响的

04:13.020 --> 04:15.580
你看我这边比如说开了很多的这个软件比如

04:15.840 --> 04:16.860
开了这个QQ

04:17.120 --> 04:18.660
是吧开了这个叮叮

04:18.860 --> 04:20.400
好大家这边又开了vscode

04:20.660 --> 04:22.700
大家这边又开了一些其他的这些软件

04:22.960 --> 04:24.760
他们这些都是独立的进程

04:25.520 --> 04:26.300
之间不会

04:26.560 --> 04:27.320
相互影响

04:29.120 --> 04:30.900
好什么叫做多县程呢

04:31.160 --> 04:32.700
就我一个程序

04:32.960 --> 04:34.480
就是我一个进程里面

04:34.740 --> 04:37.560
就允许有什么呢有多个县程

04:38.060 --> 04:40.120
来执行这个不同的这个任务

04:40.880 --> 04:43.700
那最典型的就是什么呢最典型的就是我们的这个

04:43.960 --> 04:44.720
浏览器

04:45.480 --> 04:47.280
比如说我们这边有个浏览器

04:47.480 --> 04:49.780
浏览器我们这边让我们比如说打开一个

04:51.540 --> 04:53.120
打开一个这个网页

04:53.900 --> 04:55.160
打开一个b站

04:56.440 --> 04:57.600
打开一个网页

04:57.860 --> 04:59.780
那当我们打开一个这个

05:01.820 --> 05:05.920
当我们打开一个这个网页的时候啊你看着这个网页啊他渲染出来了

05:06.180 --> 05:09.500
但其实他是有好几个进程而好几个县程

05:09.760 --> 05:10.520
在工作

05:10.780 --> 05:12.060
就这么一个网页啊

05:12.320 --> 05:15.640
就这么一个网页同时其实有好几个县程

05:15.900 --> 05:17.180
在同时工作

05:17.740 --> 05:18.260
OK

05:19.020 --> 05:26.700
好这就是这个多县程啊一个程序中可以同时运行多个不同的县程来执行不同的任务

05:28.700 --> 05:31.820
好然后接下来我们以这个浏览器为例

05:32.080 --> 05:34.120
那浏览器的话呢这个比较特殊

05:34.380 --> 05:37.460
他的话就是我们这个谷歌浏览器啊

05:37.720 --> 05:40.780
谷歌浏览器它是你一个标签页就是一个进程

05:41.040 --> 05:42.320
比如我这边再开一个

05:42.580 --> 05:43.600
再开一个京东

05:45.800 --> 05:48.360
一个标签页比如我这边是不是有两个标签页

05:48.720 --> 05:49.240
对不对

05:49.480 --> 05:53.320
一个标签页就是一个进程也就是说这个标签页

05:53.840 --> 05:58.200
是一个进程这个标签页是一个进程两个互不干扰

05:58.960 --> 06:00.500
哎这是就是这个

06:00.760 --> 06:02.280
谷歌浏览器它的一个特点

06:02.800 --> 06:03.300
啊

06:03.560 --> 06:06.900
他这边有什么好处呢就是比如说我这个网页崩了

06:07.400 --> 06:11.000
假设我这个网页崩了他不会去影响这个网页

06:11.500 --> 06:15.340
对不对因为我们刚才说了就是进程和进程之间他是相互隔离的

06:16.120 --> 06:16.620
对不对

06:16.880 --> 06:18.420
之间不会相互影响

06:18.620 --> 06:22.720
当时谷歌在设计这个浏览器的时候他就是故意把这个

06:22.980 --> 06:25.020
浏览器设成多进程的

06:25.800 --> 06:29.640
就好比你这边你在开了这个比如三个标签页啊比我们再一边

06:29.900 --> 06:30.400
再开一个

06:30.920 --> 06:31.940
开一个比如淘宝

06:34.460 --> 06:35.740
开了三个标签页对不对

06:36.000 --> 06:39.580
开了三个标签页就等同于我这下面开了三个程序

06:40.360 --> 06:41.880
哎基本上就等价于这个

06:42.140 --> 06:43.160
开了三个程序

06:43.420 --> 06:46.500
啊然后他们之间每个标签页之间

06:46.760 --> 06:47.780
是互不影响的

06:48.040 --> 06:50.080
你哪怕比如说这个崩了淘宝崩了

06:50.180 --> 06:53.000
我后面这两个压根就不受影响

06:54.020 --> 06:56.060
那你这边的话可以在这个位置

06:57.100 --> 06:58.880
我看是在

06:59.400 --> 07:00.420
这边任务管理器

07:01.440 --> 07:02.220
你可以看一下

07:04.030 --> 07:04.550
看到没有

07:05.310 --> 07:06.850
这边你看我这边是不是就有

07:07.110 --> 07:10.170
一个进程两个进程三个进程

07:10.430 --> 07:10.950
看到没有

07:11.470 --> 07:14.270
哎一个标签页就是一个进程

07:15.810 --> 07:20.410
好那这边他还一些其他的进程啊比如GPU进程然后还一些其他的进程

07:21.130 --> 07:21.630
OK

07:23.170 --> 07:24.970
好那这样我们这边继续往下面看

07:25.490 --> 07:28.810
好一个进程中有多个现成

07:29.070 --> 07:32.910
也就说我这边的话我们刚说了每个标签页是不是一个进程

07:33.170 --> 07:36.230
对不对那一个标签页下面其实又有多个进程

07:36.490 --> 07:38.790
为你这个页面来服务

07:39.050 --> 07:40.830
不是说我这边把这个页面

07:41.350 --> 07:44.170
把这个页面炫出来啊就一个

07:44.430 --> 07:46.730
这个进程然后一个现成就搞定了

07:46.990 --> 07:47.490
不是

07:47.850 --> 07:52.450
我这边的话开启一个进程之后其实里面有至少5个现成

07:52.710 --> 07:53.790
来同时工作

07:54.050 --> 07:55.890
那哪几个现成的我们来看一下

07:57.690 --> 08:04.090
好然后浏览器内核是多现成啊然后接下来一般的话由以下长柱现成组成

08:04.350 --> 08:06.130
首先的话是GUI

08:06.390 --> 08:07.410
渲染现成

08:07.930 --> 08:10.230
然后是JS引擎现成

08:10.490 --> 08:12.530
所以说为什么我们说那个JS

08:12.790 --> 08:14.070
他是单现成语言

08:14.330 --> 08:16.630
因为执行JS代码就只有一个现成

08:17.690 --> 08:20.770
明白吧但不是说我整个浏览器

08:21.530 --> 08:23.330
是单现成的那不可能

08:23.590 --> 08:24.870
对不对那不可能

08:26.410 --> 08:29.210
好然后接下来还有这个定时器触发现成

08:29.730 --> 08:34.330
事件触发现成啊一部这个http请求现成

08:34.590 --> 08:37.790
看到没有啊这边他其实至少有这么一些

08:38.050 --> 08:41.250
现成那么来看一下每个现成是干嘛的

08:43.050 --> 08:46.110
好首先第一个的话GUI渲染现成

08:46.570 --> 08:50.790
那这个是干嘛的呢啊这个很简单啊顾名思义GUI GUI

08:51.050 --> 08:54.190
那他就是渲染我们这个UI的啊你看这边

08:54.450 --> 08:56.390
主要负责页面的渲染

08:56.810 --> 08:58.730
解析HTML CSS

08:58.990 --> 09:00.650
构建这个多母数

09:01.170 --> 09:01.670
怎么样

09:02.190 --> 09:03.210
好大家下一个

09:03.470 --> 09:06.810
下一个是这个JS引擎现成

09:07.070 --> 09:09.870
他就是干嘛呢他主要就是负责这个

09:10.130 --> 09:12.170
处理这个JS的脚本

09:12.890 --> 09:16.530
好但是你要注意他和什么呢他和GUI现成是

09:16.790 --> 09:17.290
互次的

09:18.070 --> 09:18.830
什么意思啊

09:19.330 --> 09:24.210
也就是说我比如说我这个现成在工作的时候那你这个的话你就要暂停一下

09:24.710 --> 09:27.270
啊说说以前我们为什么说就是这个JS

09:27.530 --> 09:29.310
会组设这个

09:29.570 --> 09:31.870
HTML和CSS的这个构建

09:32.130 --> 09:35.210
就是我们那个时候说的就是会组设这个页面的渲染

09:35.470 --> 09:39.050
对不对为什么原因就是这两个现成

09:39.310 --> 09:40.850
他是互次的

09:41.350 --> 09:41.870
对不对

09:42.070 --> 09:44.630
我这个现成工作的时候你暂停一下

09:44.890 --> 09:48.730
那既然你没有工作的时候我这边才继续渲染这个页面

09:50.010 --> 09:55.390
原因也很简单因为我现在的话我这边在渲染页面你这边万一执行这个脚本

09:55.650 --> 09:57.430
要修改这个多母

09:57.690 --> 09:59.490
让我这个渲染的是不是要重新改

09:59.990 --> 10:02.310
对不对说我这边干脆就等你这边

10:02.570 --> 10:04.850
执行完了之后我这边再来

10:05.110 --> 10:05.630
渲染

10:05.890 --> 10:08.950
啊说我们一般都是什么的都是把那个JS

10:09.210 --> 10:10.230
是放到最下面的

10:10.690 --> 10:14.530
大家还记不记得就我们一般写这个JS的时候是不是放在这个

10:14.790 --> 10:16.330
比较这个时候我的这个P标签

10:18.110 --> 10:19.910
好然后接下来这个这个是我的HTML代码

10:20.170 --> 10:21.190
然后我们的这个script

10:21.950 --> 10:23.750
是不是写在这个最下面的

10:24.270 --> 10:24.770
对不对

10:26.310 --> 10:27.850
啊这是JS

10:28.610 --> 10:30.670
好然后接下来的话定时期

10:31.430 --> 10:32.710
定时期现成

10:32.970 --> 10:36.750
啊这个就是干嘛呢这个就是拿来执行比如说set timeout呀

10:37.010 --> 10:38.030
set interval呀

10:38.290 --> 10:40.130
这个现成就是用来计时的

10:40.610 --> 10:43.310
啊比如说大家我不知道大家有没有思考过这么一个问题啊

10:43.570 --> 10:44.970
比如说我这边写一段代码

10:45.810 --> 10:48.630
啊然后接下来这边nog一个Hello

10:48.890 --> 10:51.190
好然后接下来我们这边set timeout

10:52.470 --> 10:54.010
比如说function

10:55.790 --> 10:57.850
好大家比如说一秒钟之后

10:58.870 --> 11:00.670
然后打印输出

11:02.210 --> 11:04.710
打印输出一个world

11:04.970 --> 11:06.290
好很简单的一段代码

11:06.550 --> 11:09.510
那这边的话他这个整个这个JS现成

11:09.670 --> 11:11.250
就会去执行这段代码

11:11.510 --> 11:14.330
那执行这段代码那接下来的话我这边假设

11:14.590 --> 11:17.390
啊这这后面还有代码啊后面还有同步的代码

11:17.910 --> 11:18.670
有这边nog

11:19.190 --> 11:20.210
呃一

11:20.470 --> 11:21.230
然后二

11:21.750 --> 11:22.270
然后

11:24.050 --> 11:24.830
然后这边

11:25.590 --> 11:27.630
3啊假设后面有很多啊

11:27.890 --> 11:29.690
后面后面有很多同步的代码

11:29.950 --> 11:33.530
好那接下来我这代码在执行的时候首先是不是执行第14行

11:34.290 --> 11:34.810
对不对

11:35.070 --> 11:35.830
14行执行

11:36.090 --> 11:38.390
14行执行之后然后接下来这边

11:38.750 --> 11:40.650
这边他发现是一个异部代码

11:40.910 --> 11:43.210
他是不是扔到这个异部处理的模块里面

11:43.710 --> 11:47.810
那扔过去那当我执行第18行的时候

11:48.070 --> 11:50.110
那请问这个一秒的计时开始没有

11:51.350 --> 11:52.430
是不是已经开始了

11:53.190 --> 11:53.710
对不对

11:53.970 --> 11:55.490
已经开始计时了

11:55.750 --> 11:58.570
那这里就有个问题了谁在计时

11:59.590 --> 12:04.190
啊我这边让我JS只有一个现成一个现成要负责是不执行整个这个代码

12:04.450 --> 12:05.990
对不对一句一句的去执行

12:06.250 --> 12:08.290
那我这个计时的工作谁来

12:08.430 --> 12:09.110
执行呢

12:09.630 --> 12:12.950
不可能是我执行这个代码的这个现成单执行

12:13.470 --> 12:19.110
那谁来执行呢其实就是浏览器里面还有一个叫做定时器的现成

12:19.870 --> 12:23.030
看到没有啊我们是交给他来进行这个

12:23.450 --> 12:24.210
计时操作的

12:26.270 --> 12:29.070
好下一个是这个事件触发现成

12:29.330 --> 12:30.870
这个顾名思义就是什么呢

12:31.130 --> 12:31.890
就是

12:32.150 --> 12:35.730
响应这个用户他的这个定义了一些事件

12:36.250 --> 12:36.750
看到没有啊

12:36.950 --> 12:41.310
一些事件还有一些就是定时器结束之后一些毁掉函数

12:42.330 --> 12:45.410
好然后接下来还有就是什么呢还有就是发这个异步请求

12:46.170 --> 12:51.030
啊我们知道我们现在的一个页面比如我们这边一个页面很多是不通过阿甲课师

12:51.810 --> 12:53.590
发送请求大家异步

12:53.850 --> 12:54.630
确认出来的

12:55.130 --> 13:01.530
对不对异步确认出来的那这个发送请求的话其实专门有一个http请求现成

13:02.550 --> 13:03.070
看到没有

13:03.430 --> 13:07.630
哎说说我们一个页面啊比如说我们这边整个这个一个页面

13:08.150 --> 13:11.470
他的这个渲染不是说就是直接就一个现成就搞定了

13:12.230 --> 13:14.550
他其实是一个多个现成

13:14.810 --> 13:16.070
相互协作

13:16.590 --> 13:19.430
最终然后你看到了这么一个页面

13:20.190 --> 13:22.990
明白没有啊说这几个这个现成

13:23.510 --> 13:25.430
大家再看一下啊每个现成

13:25.690 --> 13:29.390
大致他是干什么的你大致有这么一个了解

13:29.910 --> 13:31.190
啊大致有这么一个了解

13:31.650 --> 13:36.290
好然后完事了之后那既然我们就来看这个关于浏览器中的

13:36.550 --> 13:41.950
事件循环啊我们这边先来介绍浏览器中的事件循环然后再介绍漏的

13:42.210 --> 13:44.250
JS中的事件循环好吧

13:47.160 --> 13:53.560
浏览器的这个事件循环啊首先有个知识点就是什么呢就是红任务和微任务

13:54.080 --> 13:55.360
这个你一定要知道

13:55.620 --> 14:01.500
就是在我们这个浏览器里面啊一部任务他分为两种一个叫做红任务

14:02.220 --> 14:04.520
一个叫做什么呢一个叫做微任务

14:05.040 --> 14:09.640
啊然后各自有一个对立啊各自有对立红任务对立

14:09.900 --> 14:10.660
有一个

14:11.680 --> 14:12.200
有一个

14:12.720 --> 14:16.040
啊红任务对立可以有多啊这里其实是一个啊

14:16.800 --> 14:18.860
红任务对立有一个

14:25.410 --> 14:30.550
然后微对这个微任务对立有一个啊也就是说这边一个红任务

14:31.050 --> 14:33.350
对立一个微任务对立

14:33.810 --> 14:37.650
那常见的话比如红任务比如set timeout呀set interval呀

14:37.910 --> 14:42.250
啊set immediate啊这些这些的话是属于什么呢是属于红任务

14:42.770 --> 14:44.810
然后接下来的话这边这个微任务

14:45.330 --> 14:47.370
啊微任务的话就是比如说这个

14:48.150 --> 14:50.210
啊等一下这里有问题

14:51.730 --> 14:56.330
这边的话这个浏览器中这个是没有的啊set

14:56.850 --> 14:59.410
这个immediate啊这个是漏的环境才有的

15:00.110 --> 15:03.710
好然后接下来话这个io拆入这些啊也没有

15:03.710 --> 15:05.550
我们就把就把前面的去掉吧

15:06.550 --> 15:07.310
啊set

15:09.390 --> 15:10.310
set timeout

15:10.630 --> 15:15.270
set interval啊还有就浏览器里面还有些什么呢啊比如说这个

15:16.350 --> 15:16.950
request

15:18.390 --> 15:20.150
request animation

15:20.870 --> 15:21.550
然后frame

15:23.430 --> 15:26.550
啊这个的话浏览器里面它也是属于这个红任务

15:26.830 --> 15:29.270
那微任务微任务的话然后浏览器是没有这个

15:31.810 --> 15:36.810
没有这个啊然后接下来这个promise这个它算是微任务啊然后接下来还有这个

15:37.090 --> 15:37.970
这个也是微任务

15:38.450 --> 15:41.610
也就是这些任务啊set timeout set interval

15:41.930 --> 15:44.850
然后这个request animation frame这些

15:45.250 --> 15:50.130
这些的话它是属于红任务那这些的话它属于什么呢属于微任务

15:50.650 --> 15:53.130
说它在执行你一部任务的时候

15:53.410 --> 15:57.530
你如果红任务它就会放到红任务的队列

15:58.390 --> 16:02.550
如果是微任务它就会放入到微任务的队列

16:03.110 --> 16:09.350
看到没有啊就看这张图啊这张图非常形象啊它怎么执行的好比如说我这边有一大部分的代码

16:09.950 --> 16:12.830
对不对一大部分的代码好首先我执行这个代码

16:13.630 --> 16:14.790
啊同步代码一

16:15.550 --> 16:16.070
呃

16:16.670 --> 16:20.070
这边执行呃应该是从从上往下啊

16:20.330 --> 16:25.190
那这边的话执行执行完了之后然后如果遇到这个异部的代码交给谁呢

16:25.410 --> 16:28.210
交给这个就是啊其他的现成

16:28.970 --> 16:32.310
我们说了嘛就是你那个浏览器是不是有多个现场

16:32.570 --> 16:37.170
对不对有这个定时器的现场有请求的现场有事件出发的现场

16:37.430 --> 16:38.970
交给其他现场处理

16:39.490 --> 16:43.570
其他现场处理完了之后然后接下来他就会把这个任务放到哪里呢

16:43.830 --> 16:44.850
放到这个

16:45.110 --> 16:48.170
呃有的会放入到这个红任务队列

16:48.950 --> 16:52.290
有的会放入什么呢会放入到微任务队列

16:53.010 --> 16:53.430
OK

16:53.690 --> 16:58.310
好那完事之后等我整个这个同步代码执行完毕之后

16:58.570 --> 17:02.730
然后接下来的话我就会去从红任务和微任务代码里面

17:03.250 --> 17:05.810
去这个取这个你任务的执行结果

17:06.330 --> 17:07.610
来进行一个执行

17:07.870 --> 17:14.510
那我究竟是先执行微任务里面的这个任务结果还是这个红任务里面的这个任务结果呢

17:14.770 --> 17:16.770
啊他顺序是这个样子的

17:17.030 --> 17:19.890
先执行这个微任务队列

17:20.870 --> 17:23.670
把微任务队列全部清空

17:24.190 --> 17:26.510
然后接下来取出一个红任务

17:27.270 --> 17:28.030
来进行执行

17:28.790 --> 17:30.590
执行完了之后然后接下来

17:30.850 --> 17:35.190
此时比如说我在执行这个红任务的时候又产生了一些微任务

17:35.450 --> 17:40.590
好等我这个红任务执行完之后让我又来把你的所有微任务队列清空

17:41.590 --> 17:44.430
清空完了之后然后接下来执行下一个

17:45.190 --> 17:45.710
红任务

17:46.210 --> 17:48.670
好执行完之后假如这个时候又产生微任务了

17:48.890 --> 17:51.110
好那接下来这边又把这个微任务

17:51.370 --> 17:52.210
队列清空

17:52.470 --> 17:55.530
也就是我每执行一个红任务

17:55.790 --> 17:59.630
都需要去把什么呢把这个微任务队列清空

18:00.390 --> 18:03.210
看到没有他就是这样子的一个顺序

18:03.470 --> 18:05.010
我们这边我们来看一下啊

18:05.510 --> 18:11.150
好一开始执行站为空啊然后我们可以把执行站认为是一个存储函数调用的站结构

18:11.650 --> 18:13.970
然后先进后出是吧

18:14.230 --> 18:16.270
然后这个时候然后微任务队列

18:16.790 --> 18:17.290
是空的

18:17.550 --> 18:18.570
一开始是空的

18:18.870 --> 18:23.270
然后红任务队列尤且只有一个script脚本啊也就是说这边

18:23.790 --> 18:26.350
这边script也分到这个红任务里面了是吧

18:27.110 --> 18:30.190
就一开始script脚本也分到这个

18:30.450 --> 18:32.750
红任务里面那一开始是不是只有一个红任务

18:33.010 --> 18:33.270
OK

18:33.770 --> 18:35.050
好那接下来完事之后

18:36.070 --> 18:37.610
完事之后然后

18:37.870 --> 18:38.390
这里

18:39.410 --> 18:45.290
执行同步代码同步代码然后执行的时候他会判断啊就是执行代码的时候

18:45.550 --> 18:47.350
他执行代码的时候他会判断

18:47.550 --> 18:48.830
你这个是同步任务

18:49.090 --> 18:50.370
还是异步任务

18:50.630 --> 18:52.930
如果是异步任务调用什么

18:53.190 --> 18:55.230
是不调用其他的这个现成

18:55.750 --> 18:57.030
是不是来进行这个处理

18:57.290 --> 18:59.850
对不对那这个时候他就会产生什么呢

19:00.110 --> 19:01.890
产生红任务和

19:02.150 --> 19:02.910
微任务

19:03.430 --> 19:05.990
各自被推入到各自的队列

19:06.250 --> 19:08.030
红任务进红任务的队列

19:08.290 --> 19:12.650
微任务进微任务的队列前提是你这个现成已经把它处理完了

19:13.410 --> 19:14.950
比如说我这边发送请求

19:15.150 --> 19:17.470
请求然后接下来请求已经完毕了

19:17.970 --> 19:19.770
完毕了然后内容已经拿到了

19:20.030 --> 19:22.830
拿到了之后大家是不该执行这个请求的这个回调

19:23.090 --> 19:25.150
对不对那这个回调就是一个任务

19:25.410 --> 19:26.430
那这个任务就是

19:26.690 --> 19:27.710
进这个

19:27.970 --> 19:30.010
红任务队列或者进微任务队列

19:31.550 --> 19:34.350
好然后推入到各自的任务队列之后

19:34.610 --> 19:36.910
等这个整个同步代码

19:37.170 --> 19:38.190
执行完毕

19:38.450 --> 19:39.470
那这个script

19:39.730 --> 19:41.790
他就会被移出红任务队列

19:42.290 --> 19:44.850
让我一个红任务执行完了是不是就应该执行

19:45.250 --> 19:45.930
微任务了

19:46.450 --> 19:50.790
对不对说接下来话就是什么了就是处理所有的微任务

19:51.050 --> 19:51.810
你注意哦

19:52.070 --> 19:54.630
当一个红任务执行完毕之后

19:54.890 --> 19:57.710
会执行所有的微任务

19:57.970 --> 19:59.250
注意是所有的

19:59.490 --> 20:02.570
他会把你这边所有的微任务全部清空

20:03.590 --> 20:07.690
清空完毕之后再执行下一个红任务

20:10.250 --> 20:13.050
好大家执行渲染操作更新页面

20:13.250 --> 20:14.530
然后接下来这边

20:14.790 --> 20:18.630
检查是否存在微博Walker

20:18.890 --> 20:20.430
如果有进行这个处理

20:20.690 --> 20:22.730
微博Walker的话我们这边不会涉及到

20:22.990 --> 20:24.270
然后接下来后面就是什么了

20:24.530 --> 20:26.830
后面他就是反复执行这个过程

20:27.590 --> 20:28.630
看到没有直到什么了

20:28.890 --> 20:30.670
直到你两个队列都清空

20:31.170 --> 20:32.450
这个队列没有东西了

20:32.710 --> 20:33.730
这个队列

20:33.990 --> 20:34.750
也没有任务了

20:35.010 --> 20:36.290
好那接下来我整个代码

20:36.550 --> 20:37.330
才执行完毕

20:38.090 --> 20:38.850
看到没有

20:39.110 --> 20:41.670
我们这边可以看这么一个例子吗

20:42.390 --> 20:43.670
我们这边我们看一个例子

20:45.450 --> 20:47.510
我看我这边有没有举例子啊有有有

20:47.770 --> 20:49.550
这边我们就拿这个例子

20:53.050 --> 20:55.090
放到我们的这个这边

20:59.420 --> 21:00.940
我们这边我们来分析一下

21:01.200 --> 21:02.740
分析一下最终这个代码

21:03.000 --> 21:04.020
他输出什么

21:07.000 --> 21:08.800
这里我们来一起分析一下

21:09.300 --> 21:10.580
好首先的话他这边

21:10.840 --> 21:13.140
整个这个脚本开始执行

21:13.400 --> 21:14.420
那首先第14行

21:14.680 --> 21:17.240
第14行是不是同步代码

21:17.460 --> 21:19.860
那同步代码是不是直接输出啊

21:20.520 --> 21:22.320
对不对那首先直接输出

21:22.820 --> 21:23.840
这个script start

21:24.100 --> 21:25.380
好然后接下来到这里

21:25.900 --> 21:27.940
到这里的话他是一个异步任务

21:28.200 --> 21:30.760
异步任务的话那接下来的话整个这个

21:31.520 --> 21:33.060
他会被推出到哪个

21:33.320 --> 21:34.340
是不是红任务队列

21:34.860 --> 21:37.160
对不对说接下来他有一个红任务

21:38.440 --> 21:39.720
红任务

21:40.480 --> 21:41.000
队列

21:41.260 --> 21:43.000
那红任务队列然后就是这个

21:43.260 --> 21:44.080
set time out

21:45.360 --> 21:45.860
对吧

21:46.140 --> 21:48.580
好那接下来有一个这个promise resolve

21:49.020 --> 21:52.100
这个是什么呢这个是不是会被推入到微任务队列

21:52.980 --> 21:54.020
好微任务

21:57.370 --> 21:58.290
好微任务队列

21:58.530 --> 22:00.570
好大家这边是不是就是这个promise 1

22:02.370 --> 22:02.730
对不对

22:02.990 --> 22:04.450
然后加这边的话继续这个任

22:04.690 --> 22:05.810
然后加这个是不是也是

22:06.570 --> 22:08.170
推入到这个微任务队列

22:08.530 --> 22:09.910
promise 2

22:10.930 --> 22:11.430
对吧

22:15.770 --> 22:18.190
好然后接下来到这里25行

22:18.450 --> 22:20.190
25行这个是不是一个同步代码

22:20.450 --> 22:22.050
同步代码是不是直接输出

22:23.010 --> 22:23.410
对不对

22:23.670 --> 22:24.430
直接输出

22:24.690 --> 22:25.210
好完事了

22:25.470 --> 22:27.750
完事了之后然后接下来这边有两个队列

22:28.010 --> 22:30.070
一个红任务队列一个微任务队列

22:30.330 --> 22:32.870
那他一开始的话我们这个script

22:33.130 --> 22:37.490
他首先刚才的话是算着这个红任务那是不是就算着执行完了

22:37.750 --> 22:39.530
对不对那执行完了就该干嘛

22:39.790 --> 22:41.590
清空整个微任务队列

22:42.090 --> 22:44.410
对不对整个微任务队列都要清空

22:44.670 --> 22:46.450
所以这边的话就是应该是输出什么了

22:46.710 --> 22:47.990
输出promise 1

22:49.770 --> 22:50.290
以及

22:50.810 --> 22:51.570
promise

22:51.770 --> 22:52.290
2

22:52.810 --> 22:54.590
那这样我们整个这个微任务队列

22:55.370 --> 22:56.390
是不是也就清空了

22:56.890 --> 22:57.410
对不对

22:57.670 --> 22:59.450
好清空完了之后然后接下来

22:59.970 --> 23:00.730
输出什么

23:00.990 --> 23:02.270
是不是输出set timeout

23:03.550 --> 23:04.570
set

23:05.850 --> 23:06.370
timeout

23:07.390 --> 23:07.910
看了没有啊

23:08.170 --> 23:10.970
他这边的话就是这个样子的我们这边我们来看一下嘛

23:14.400 --> 23:14.900
好

23:15.160 --> 23:15.680
检查

23:18.460 --> 23:18.980
看了没有

23:19.240 --> 23:21.020
script start,script end

23:21.280 --> 23:23.080
然后promise 1,promise 2

23:23.340 --> 23:24.100
set timeout

23:24.860 --> 23:27.680
说像你在做这种题的时候他比如他问你

23:27.940 --> 23:31.780
这种他输出什么的时候你干嘛呢你就像我这个样子

23:32.040 --> 23:35.100
把红任务队列写出来把微任务队列

23:35.360 --> 23:35.880
写出来

23:36.640 --> 23:38.440
看了没有,红任务队列

23:39.980 --> 23:41.000
红任务队列

23:41.260 --> 23:42.020
有点些

23:42.280 --> 23:44.320
然后微任务队列有点些

23:44.580 --> 23:50.720
你把它一个一个你把它写出来写出来之后然后接下来再来进行这个分析

23:52.520 --> 23:53.280
就可以了

23:54.000 --> 23:54.520
明白吧

23:55.020 --> 23:55.280
好

23:55.540 --> 23:57.580
好,那接下来我们这边来看一下这里

23:58.360 --> 23:59.880
执行流程

24:00.660 --> 24:04.240
红任务和微任务的执行流程总结起来就是什么呢

24:04.500 --> 24:06.800
当某个红任务执行完后

24:07.060 --> 24:10.640
会查看是否这个微任务队列是否有任务

24:11.160 --> 24:11.920
如果有

24:12.180 --> 24:17.040
把这个微任务里面的所有任务注意所有任务全部清空

24:17.300 --> 24:18.840
然后如果没有

24:19.100 --> 24:22.680
读取什么呢读取红任务队列最前排的这个任务

24:23.140 --> 24:23.960
然后加执行

24:24.220 --> 24:29.340
执行完了之后,然后你如果在执行这个任务的过程中你又遇到了微任务

24:29.600 --> 24:30.600
那把这个微任务

24:30.860 --> 24:32.660
添加到这个微任务队列

24:32.920 --> 24:34.960
等我当前的这个红任务

24:35.220 --> 24:37.520
执行完毕之后我再去

24:37.780 --> 24:40.600
处理微任务队列里面的所有任务

24:41.360 --> 24:42.140
依此类推

24:42.640 --> 24:43.680
就是这张图你看

24:43.940 --> 24:47.520
首先红任务是吧然后执行执行看是否有微任务

24:47.780 --> 24:49.820
要把所有的微任务清空

24:50.080 --> 24:51.860
然后加这边浏览器渲染

24:52.080 --> 24:54.880
然后完了之后又过来处理下一个红任务

24:55.140 --> 24:55.640
对不对

24:55.900 --> 24:59.500
处理完了之后看是否有微任务如果没有那加浏览器渲染

24:59.760 --> 25:01.540
那就执行下一个红任务

25:02.300 --> 25:05.380
它就分为这种两种不同的这种任务

25:05.640 --> 25:06.140
好吧

25:06.660 --> 25:08.960
好,那接下来我们这边我们再来看一道题

25:09.220 --> 25:09.740
这个题

25:11.260 --> 25:12.560
这样题我们来看一下

25:13.840 --> 25:15.620
好,这边的话我们把它注释掉

25:18.520 --> 25:19.800
这个的话是

25:20.060 --> 25:21.080
题目1

25:24.520 --> 25:26.560
好,然后接下来这边题目2

25:31.500 --> 25:32.420
格式换一下

25:32.680 --> 25:34.580
好,我们来分析一下这道题

25:36.380 --> 25:39.440
好,这里的话我们首先还是先搞两个对立

25:39.700 --> 25:41.740
一个是红任务

25:42.000 --> 25:42.520
对立

25:43.540 --> 25:44.040
对吧

25:44.300 --> 25:46.620
一个是什么呢,一个是微任务

25:47.900 --> 25:48.400
对立

25:48.920 --> 25:49.420
OK

25:49.940 --> 25:50.460
好,把这

25:50.960 --> 25:51.480
注释一下

25:52.240 --> 25:53.780
好,然后完了之后一开始

25:54.540 --> 25:56.340
一开始是不是这个promise

25:56.860 --> 25:59.160
promise是属于什么,是属于微任务

25:59.680 --> 26:00.180
对不对

26:00.180 --> 26:01.960
好,那接下来首先这个promise

26:02.220 --> 26:04.020
被推入到这个微任务

26:04.780 --> 26:05.300
OK

26:05.560 --> 26:07.860
好,然后接下来这个send timeout

26:08.120 --> 26:10.160
这个send timeout是不是属于红任务

26:10.420 --> 26:11.700
好,那接下来这个send timeout

26:11.960 --> 26:13.500
被推入到红任务里面

26:14.000 --> 26:14.520
OK

26:14.780 --> 26:16.820
好,那接下来一开始一开始是不是就是

26:17.080 --> 26:19.120
你script完了是不是首先清空微任务

26:19.380 --> 26:22.200
清空微任务它就会执行这个微任务里面的代码

26:22.460 --> 26:24.240
微任务里面的代码首先第1个

26:24.500 --> 26:26.800
是不是打印输出promise一

26:27.060 --> 26:28.860
对不对,所以首先第1步

26:29.320 --> 26:30.340
它是输出什么呢

26:30.600 --> 26:32.140
输出promise一

26:34.920 --> 26:35.440
看到没有

26:35.700 --> 26:39.280
好,接下来完事之后,然后接下来这边有一个这个

26:39.540 --> 26:40.820
send timeout2

26:41.080 --> 26:46.200
那这个的话就又会干嘛呢,是不是又会被推入到红任务里面

26:46.700 --> 26:49.000
对不对,send timeout2

26:49.520 --> 26:52.840
OK,好,那接下来我整个这个微任务是不是就清空了

26:53.360 --> 26:55.160
对不对,这个就清空了,就没了

26:57.800 --> 26:58.580
这个就没了

26:59.080 --> 27:01.640
好,没了之后,然后接下来我就取什么呀

27:01.640 --> 27:03.180
是不是取我的这个

27:04.200 --> 27:08.560
取我的这个这个红任务是不是取出来执行,那首先执行这个send timeout

27:09.060 --> 27:12.380
那执行这个send timeout,然后这边是不是打印输出

27:12.900 --> 27:13.940
send timeout1

27:16.260 --> 27:19.580
对不对,send timeout1,好,然后接下来这个又是一个什么

27:20.360 --> 27:21.900
这个是不是又是一个微任务

27:22.160 --> 27:23.940
好,那接下来微任务干嘛

27:24.200 --> 27:24.960
就推入到这里面

27:25.480 --> 27:27.020
大家这个我就执行完了

27:28.040 --> 27:30.080
send timeout,外层的这个send timeout

27:30.600 --> 27:31.360
我就执行完了

27:32.080 --> 27:34.900
好执行完了之后,那现在我们来看一下这个任务队列

27:35.400 --> 27:37.200
现在的任务队列是不是就是这边

27:37.960 --> 27:39.240
微任务是不是又有东西了

27:39.500 --> 27:42.060
那我就又干干嘛,是不是又该把微任务

27:42.580 --> 27:46.420
把这个任务清空,那这个任务的话是不是打印输出promise2

27:46.920 --> 27:50.780
对不对,所以接下来的话这边就是打印输出promise2

27:52.820 --> 27:53.320
OK

27:53.580 --> 27:55.880
好,完事之后,让我这个微任务

27:56.920 --> 27:58.960
微任务再一次被清空

27:59.220 --> 28:01.260
好,那接下来我就又把红任务

28:01.740 --> 28:05.320
取一个任务出来执行,那这个是不是就是send timeout2

28:05.580 --> 28:08.740
对不对,所以接下来这边就是send timeout2

28:11.130 --> 28:11.650
看了没有

28:11.910 --> 28:14.970
好,那接下来我们来执行一下,看一下是不是这样子的结果

28:15.750 --> 28:16.250
走

28:20.390 --> 28:21.150
好,这边

28:22.190 --> 28:23.210
promise1

28:23.470 --> 28:24.490
send timeout1

28:24.750 --> 28:25.710
promise2

28:25.970 --> 28:26.790
send timeout2

28:27.050 --> 28:29.870
你看,是不是和我们的这个分析就是一模一样的

28:30.630 --> 28:31.150
对不对

28:31.410 --> 28:32.030
一模一样的

28:32.290 --> 28:36.010
所以说这个的话就是浏览器里面的这个事件队列

28:36.210 --> 28:37.650
它是怎么这个执行的

28:37.910 --> 28:39.290
你一定要把这个顺序

28:39.550 --> 28:40.310
把它理清楚

28:40.570 --> 28:41.590
就这边

28:42.110 --> 28:43.630
一定要把这个顺序理清楚

28:44.150 --> 28:47.490
其实也很简单,就一个红任务队列一个微任务队列

28:47.990 --> 28:51.270
对不对,所有的异部任务它就是要么是进红任务队列

28:51.530 --> 28:53.370
要么是进微任务队列

28:53.890 --> 28:55.430
然后完事之后,然后接下来

28:55.690 --> 28:56.690
同步

28:57.210 --> 28:58.750
任务执行完毕之后

28:59.010 --> 29:01.050
首先清空微任务队列

29:01.310 --> 29:03.110
然后接下来取一个红任务执行

29:03.610 --> 29:05.910
执行完了之后大家又把如果这个微任务

29:06.390 --> 29:10.310
这个队列里面又有微任务了,又再一次把这个队列是不是清空

29:10.570 --> 29:12.610
对不对,就是这样子的顺序

29:12.870 --> 29:15.170
好,整个这个浏览器

29:15.430 --> 29:16.450
就是这个样子的

29:16.710 --> 29:18.750
你这边可以再看一下

29:19.010 --> 29:20.050
一定要把这个搞清楚

29:20.810 --> 29:24.130
好,这个搞清楚之后,然后接下来我们就来看这个

29:24.390 --> 29:27.210
LoadJS里面的事件循环了

29:27.470 --> 29:27.970
好吧

29:30.030 --> 29:34.890
LoadJS中的这个事件循环的话,它和浏览器中是不一样的

29:35.610 --> 29:37.910
我们来看一下,你看这个图你就会发现

29:38.170 --> 29:40.210
你看我们这个LoadJS这个

29:40.470 --> 29:44.830
整个这个事件循环,是明显比这个刚才的浏览器

29:45.330 --> 29:46.110
浏览器

29:46.370 --> 29:47.890
是明显要复杂很多

29:48.150 --> 29:50.710
对不对,因为它是和这个操作系统打交道

29:50.970 --> 29:55.830
所以它这边的话一定会复杂一些,我们浏览器的话,你看这边是不是两个队列

29:56.610 --> 29:59.410
对不对,一个微任务队列,一个红任务队列

29:59.670 --> 30:01.990
就完事了,但是你看一下这个LoadJS

30:02.490 --> 30:04.790
LoadJS的话,它这边你看

30:05.050 --> 30:06.370
这儿一个队列

30:06.630 --> 30:07.770
这儿一个队列

30:08.030 --> 30:08.790
这儿一个队列

30:09.190 --> 30:12.630
也就是说它的这个任务队列的话,不止两个

30:13.290 --> 30:14.050
不止两个

30:14.310 --> 30:19.690
为什么呢,因为它这边封装了一些不同操作系统的一些底层的一些特性

30:19.950 --> 30:22.510
说它的话就会更加复杂一些

30:22.770 --> 30:24.550
但是我们这边的话还是

30:24.810 --> 30:27.630
把它搞明白了,我们来看一下

30:29.410 --> 30:33.250
可以看出LoadJS的事件循环比浏览器端

30:33.510 --> 30:34.290
复杂很多

30:34.490 --> 30:36.810
LoadJS的运行机制是这样子的

30:37.310 --> 30:41.410
首先V8引擎来解析这个JavaScript的这个脚本

30:41.670 --> 30:44.470
解析后调用这个Load的这个API

30:44.730 --> 30:46.010
然后接下来这个库

30:46.790 --> 30:48.830
这是它用这个C++写的

30:49.090 --> 30:52.930
那它来负责这个LoadAPI的这个执行

30:53.190 --> 30:55.750
其实就是直接就是和操作系统打交道了

30:56.010 --> 30:58.050
调用操作系统的一些API

30:58.310 --> 31:00.990
大家执行,执行了之后然后把这个

31:01.250 --> 31:04.190
不同的这个任务分配给不同的这个现成

31:04.490 --> 31:06.330
形成一个事件循环

31:06.590 --> 31:09.150
然后最后的话把这个这些任务

31:09.410 --> 31:12.730
以异步的方式,然后把这些执行结果

31:12.990 --> 31:14.270
返回给V8引擎

31:14.530 --> 31:17.350
把V8引擎再将结果返回给用户

31:17.850 --> 31:20.430
看到没有,整个这个流程

31:20.930 --> 31:22.990
我记得以前有一张图

31:23.490 --> 31:25.550
我看一下我看我这张图还在不在

31:27.330 --> 31:29.110
Load

31:30.150 --> 31:30.650
这边

31:31.630 --> 31:32.910
嗯

31:33.670 --> 31:34.950
我看是哪个来着

31:36.230 --> 31:37.510
应该是在

31:37.770 --> 31:39.050
核心知识

31:40.070 --> 31:41.610
好像就在核心知识里面

31:42.630 --> 31:43.670
在

31:44.670 --> 31:45.710
不在这里

31:46.990 --> 31:47.750
我看一下

31:48.790 --> 31:50.050
是进阶吗

31:50.310 --> 31:55.460
以前有一张图

31:56.220 --> 31:57.520
有一张图

31:57.780 --> 32:01.360
就是讲这个Load接式的这个架构的

32:03.240 --> 32:04.260
这里这里

32:04.520 --> 32:05.280
就这张图

32:05.800 --> 32:08.100
看到没有,这个就是整个这个

32:08.620 --> 32:11.700
这个就是整个Load接式它的一个架构

32:12.200 --> 32:14.260
看到没有,它底层有个酷,就是这个

32:14.500 --> 32:16.300
LIBUV这个酷

32:16.560 --> 32:18.860
这个它就是用这个C加加写的

32:19.120 --> 32:21.920
然后接下来这个酷的话就会去调用这个

32:22.180 --> 32:23.460
操作系统的

32:23.720 --> 32:25.260
不同的那个就是

32:26.020 --> 32:27.300
就是去调

32:27.560 --> 32:29.100
操作系统的这个API

32:29.360 --> 32:32.680
大家执行,执行完了之后然后返回给这个Load

32:33.140 --> 32:35.960
Load然后接下来返回给这个V8引擎

32:37.240 --> 32:37.740
不不不

32:38.000 --> 32:41.080
这边它执行完了之后返回给这个V8引擎

32:42.620 --> 32:43.120
这里

32:43.380 --> 32:46.200
看到没有,它执行完了之后,然后以异布的形式

32:46.460 --> 32:47.740
就返回给V8引擎

32:48.260 --> 32:48.760
对吧

32:49.020 --> 32:51.320
整个这个流程,我把这张图放过来吧

32:52.080 --> 32:53.620
把这张架构图

32:53.880 --> 32:54.380
放过来

33:02.630 --> 33:04.150
在这下面

33:06.310 --> 33:09.630
在这下面,把这个整个这张图,结个图

33:10.150 --> 33:10.910
放到笔记里面

33:14.600 --> 33:17.160
然后整个架构图如下

33:19.880 --> 33:20.900
整个

33:21.400 --> 33:22.440
架构

33:23.200 --> 33:23.960
图

33:24.220 --> 33:25.000
如下

33:25.760 --> 33:26.520
所示

33:28.060 --> 33:28.580
OK

33:30.780 --> 33:32.320
这是Load

33:32.580 --> 33:33.340
它的一个架构

33:33.600 --> 33:36.160
好,那我们来看它的这个事件循环

33:37.440 --> 33:40.760
这个LIBUV这个引擎

33:40.960 --> 33:43.080
它将这个事件循环分成了什么呢

33:43.320 --> 33:44.600
分成了6个阶段

33:45.360 --> 33:46.640
看到没有,6个阶段

33:47.420 --> 33:48.960
好,然后加这边分别是什么呢

33:49.200 --> 33:50.740
分别是这个Timers

33:51.260 --> 33:52.540
然后接下来这个Pending

33:52.800 --> 33:53.560
Callbacks

33:53.820 --> 33:55.360
然后接下来这边Prepare

33:55.620 --> 33:57.660
准备阶段,然后加这个Pro

33:57.920 --> 33:58.680
然后Check

33:58.940 --> 34:00.460
然后最后是Close

34:00.720 --> 34:01.240
Callbacks

34:02.000 --> 34:03.280
整个6个阶段

34:03.540 --> 34:04.560
我们来看一下

34:05.080 --> 34:05.860
从上图中

34:06.120 --> 34:09.940
大致可以看出Load.js的事件循环顺序,它是什么呢

34:10.140 --> 34:11.420
首先外部输入数据

34:11.680 --> 34:13.720
就是轮循阶段,就是这个Pro阶段

34:13.980 --> 34:14.760
从这开始

34:15.020 --> 34:15.520
过来

34:16.040 --> 34:18.860
过来之后,然后接下来进入什么呢,进入这个Check

34:19.620 --> 34:21.920
Check完了之后,进入这个Close

34:22.180 --> 34:22.940
Callback

34:23.460 --> 34:26.280
然后完了之后,然后接下来你看这边一个箭头指回去

34:26.540 --> 34:28.320
然后接下来这个Timers

34:28.580 --> 34:29.600
然后这个

34:29.860 --> 34:30.880
PendingCallbacks

34:31.140 --> 34:32.680
然后接下来这边Prepare

34:33.440 --> 34:34.460
衔制阶段

34:34.720 --> 34:36.260
过了之后,然后就又轮循

34:36.520 --> 34:38.060
看到没有,反复这样子

34:38.280 --> 34:40.060
形成一个事件循环

34:40.820 --> 34:42.620
那每个阶段它是做什么的呢

34:42.880 --> 34:43.640
我们来看一下

34:43.900 --> 34:44.680
Timers

34:45.180 --> 34:46.720
Timers就最上面这个

34:46.980 --> 34:47.740
最上面这个

34:48.260 --> 34:50.300
Timers的话它就是主要就是

34:50.560 --> 34:51.840
一些计时器

34:52.100 --> 34:53.880
SetTimeout,SetInterval这些

34:54.140 --> 34:54.660
计时器

34:55.920 --> 34:57.980
好,然后接下来这个IoCallbacks

34:58.500 --> 34:59.520
就是这边

34:59.780 --> 35:01.300
这边它是处理

35:01.560 --> 35:05.140
上一轮循环中少数未执行的一些IO回调

35:05.660 --> 35:07.200
然后接下来这个Prepare

35:07.400 --> 35:09.720
Prepare的话是它这个底层用的

35:10.220 --> 35:11.500
No的接是底层用的

35:11.760 --> 35:13.040
好,然后接下这个Pro

35:13.800 --> 35:15.340
Pro的话就是什么呢

35:15.600 --> 35:17.660
Pro的话就是我们的轮循阶段

35:18.160 --> 35:19.700
这个阶段是非常重要的

35:20.200 --> 35:23.900
我们很多操作比如这个Io操作呀,网络呀

35:24.160 --> 35:26.860
读取文件呀,这边都是在这个阶段

35:27.640 --> 35:29.420
然后接下来的话是一个Check阶段

35:29.940 --> 35:31.680
Check的话主要就是执行什么呢

35:31.940 --> 35:33.520
执行这个SetImmediate

35:34.040 --> 35:34.540
回调

35:34.800 --> 35:35.880
最后一个

35:36.140 --> 35:37.100
CloseCallback

35:37.660 --> 35:41.720
它就是执行这个Socket里面的Close事件回调

35:42.280 --> 35:46.620
那对于我们来讲,我们只需要关心什么呢,我们只需要关心这三个阶段

35:47.140 --> 35:48.420
一个是Timer

35:49.180 --> 35:50.460
一个是Pro

35:51.220 --> 35:52.520
一个是Check

35:53.020 --> 35:54.560
其他的话你不用管

35:54.820 --> 35:58.140
其他的这些阶段啊,就这个阶段这个阶段

35:58.400 --> 35:59.680
以及这个阶段你不用管

35:59.940 --> 36:03.140
你看这个阶段明确告诉你是不是漏了GS内部使用的

36:03.400 --> 36:04.800
对不对,我们想用也用不了的

36:05.560 --> 36:07.100
好,那我们来看一下这三个阶段

36:07.400 --> 36:12.280
我们日常开发中绝大多数异部任务都是这三个阶段

36:13.300 --> 36:13.800
看到没有

36:14.320 --> 36:15.600
好,那接下来首先第一个

36:15.860 --> 36:18.420
第一个是什么呢,第一个是Timer阶段

36:18.680 --> 36:21.740
Timer阶段它是执行这个SetTimeOut

36:22.000 --> 36:23.800
和SetInterval的这个回调

36:24.060 --> 36:25.580
然后由这个Pro阶段

36:25.840 --> 36:26.600
来控制的

36:26.860 --> 36:29.160
Pro阶段就是我们的轮迅阶段

36:29.680 --> 36:35.560
然后同样漏的GS中的这个定时器,它指定的时间不是准确的时间

36:36.020 --> 36:37.300
只能尽快执行

36:37.560 --> 36:38.700
这个我们一会儿看个例子

36:38.960 --> 36:39.600
大家就知道了

36:40.120 --> 36:42.940
首先你先知道这个Timer阶段它是干嘛用的

36:43.700 --> 36:44.720
它的话是不是

36:44.980 --> 36:46.520
你这个SetTimeOut

36:46.780 --> 36:49.340
就是放你这个SetTimeOut和SetInterval

36:49.600 --> 36:50.360
就这种

36:51.120 --> 36:52.220
异部任务的这个

36:52.480 --> 36:53.180
回调任务的

36:53.940 --> 36:54.460
对不对

36:54.720 --> 36:56.760
好,然后接下来的话重要的是这个

36:57.280 --> 36:58.300
Pro这个阶段

36:59.840 --> 37:03.420
Pro的话是一个至关重要的阶段

37:03.680 --> 37:05.460
系统的话会做两件事情

37:05.580 --> 37:06.280
我们看一下

37:06.540 --> 37:08.660
首先第1个就是回到这个Timer阶段

37:08.920 --> 37:10.880
执行Timer阶段的这个回调

37:11.660 --> 37:15.240
第2个就是什么呢,第2个就是执行这个IO的这个回调

37:15.500 --> 37:18.260
并且在进入该阶段时

37:18.520 --> 37:20.360
如果没有设定这个Timer

37:20.620 --> 37:22.920
它会发生以下两件事情

37:23.180 --> 37:24.460
哪两阶段我们来看一下

37:24.720 --> 37:27.260
首先如果你这个Pro对列不为空

37:27.520 --> 37:29.200
那Pro的话我们称之为什么

37:29.460 --> 37:30.600
称之为这个轮迅

37:31.120 --> 37:31.620
对不对

37:31.880 --> 37:32.640
轮迅阶段

37:32.840 --> 37:37.460
那你这个轮迅阶段你这个阶段里面本身就里面有一些这个回调任务

37:37.960 --> 37:39.500
比如说我这阶段本身就有

37:39.760 --> 37:40.780
几个回调任务

37:41.040 --> 37:42.060
那我就把这个

37:42.320 --> 37:44.880
就是处于我这个Pro这个阶段的回调任务

37:45.140 --> 37:46.680
全部挨着挨着去做

37:47.180 --> 37:47.700
对不对

37:47.960 --> 37:48.980
挨着挨着去做

37:49.240 --> 37:51.800
你看这边如果它不为空

37:52.560 --> 37:55.880
它会干嘛呢,它会便利你的回调对列

37:56.140 --> 37:57.160
并同步执行

37:57.420 --> 38:00.500
直到这个对列为空或者达到系统限制

38:00.760 --> 38:01.780
也就是说我这个

38:02.000 --> 38:03.520
这个Pro这个对列里面

38:04.040 --> 38:05.820
你把这个就想象成六个对列

38:06.080 --> 38:07.620
然后我这个对列里面

38:08.380 --> 38:10.940
我这个对列里面啊比如说有一些任务

38:11.200 --> 38:11.960
两个

38:12.220 --> 38:12.740
三个

38:13.000 --> 38:16.840
那我就挨着挨着把这个每个这个回调任务挨着挨着执行

38:17.340 --> 38:18.120
这是

38:18.380 --> 38:18.880
第一件事

38:19.140 --> 38:20.420
好,然后接下来的话

38:20.680 --> 38:22.720
如果对列为空

38:23.240 --> 38:24.260
为空说明什么

38:24.520 --> 38:27.080
说明我这个Pro这个对列是不是已经没有回调任务了

38:27.580 --> 38:31.420
没有回调任务那接下来我看有没有set immediate

38:31.880 --> 38:32.900
回调需要执行

38:33.160 --> 38:35.720
set immediate是属于哪个阶段的呢

38:35.980 --> 38:37.260
是属于这个check阶段的

38:38.540 --> 38:40.980
也就是说其实很简单就是我这个对列

38:41.240 --> 38:42.380
是不是已经清空了

38:43.140 --> 38:44.420
我这对列清空了吧

38:44.680 --> 38:46.740
清空了接下来是不是应该是执行

38:47.000 --> 38:48.260
下一个对列的任务了

38:49.180 --> 38:49.700
对不对

38:49.960 --> 38:52.880
执行这个对列的任务,这个对列的任务就只放什么呢

38:53.140 --> 38:55.440
只放这个set immediate

38:55.940 --> 38:57.740
就这个函数的这个回调

38:58.000 --> 39:01.320
就是执行这个set immediate的这个回调任务

39:01.840 --> 39:02.340
OK

39:02.920 --> 39:03.420
好

39:04.180 --> 39:08.280
然后如果没有这个set immediate回调要执行

39:08.540 --> 39:10.340
那现在是不是就全部都是空的

39:10.840 --> 39:12.640
对不对,它也是空的

39:12.900 --> 39:13.920
它也是空的

39:14.420 --> 39:15.960
大家这个timers也是空的

39:16.220 --> 39:18.780
让我这边的话我就干嘛了,我这边就一直等

39:19.300 --> 39:21.860
等看有没有这个其他的这个异部任务

39:22.620 --> 39:24.660
就还有这个异部任务会进入这个对列的

39:24.920 --> 39:27.740
不管你是进哪个对列,你进这个对列也好

39:28.260 --> 39:29.280
进这个对列也好

39:29.540 --> 39:30.820
你进这个对列也好

39:31.040 --> 39:32.820
反正你如果还有异部要

39:33.080 --> 39:35.640
就是异部政府要进入这个对列

39:35.900 --> 39:36.920
那我就在这干嘛呢

39:37.180 --> 39:37.940
我就在这等着

39:38.700 --> 39:40.500
等着假设比如说我这边有个这个timers

39:41.520 --> 39:44.600
有个timers,然后接下来这个时间到了,比我设的一秒钟

39:44.860 --> 39:47.660
一秒钟到了,然后再一秒钟之后的那个回调政府

39:47.920 --> 39:49.200
进入到这个timers了

39:49.460 --> 39:52.780
好,那接下来我就走走走走走走到你这

39:53.040 --> 39:54.840
好,来我来执行你的这个

39:55.600 --> 39:56.120
回调任务

39:56.840 --> 39:59.400
看到没有,执行到之后人家过来过来过来

39:59.660 --> 40:01.700
好,那接下来我又在这等着

40:02.460 --> 40:04.000
说他为什么叫做轮寻

40:04.260 --> 40:06.060
看到没有,他叫做轮寻对列

40:06.580 --> 40:08.100
我就又在这等着

40:08.860 --> 40:09.380
明白没有

40:09.640 --> 40:11.940
我再总结一下吧,什么意思

40:12.200 --> 40:14.000
就是我们之前浏览器

40:15.540 --> 40:18.860
我们先回到我们的浏览器,浏览器的话你这个异部

40:19.120 --> 40:23.980
异部的一些回调任务,是不是要么进红任务对列,要么进这个微任务对列

40:24.500 --> 40:26.020
对不对,这个很好理解,对不对

40:26.220 --> 40:27.400
那你这个

40:28.160 --> 40:29.180
load的话

40:29.440 --> 40:30.720
他是有6个

40:31.760 --> 40:32.260
看到没有

40:32.520 --> 40:33.540
他是有6个

40:33.800 --> 40:39.180
6个的话,然后有些异部任务进这个对列,有些异部任务进这个对列,因为我们

40:39.440 --> 40:41.220
就是最重要的就是这三个

40:41.480 --> 40:42.260
timers

40:42.760 --> 40:44.040
pro和这个check

40:44.560 --> 40:47.360
那有些异部任务进这个对列

40:47.620 --> 40:51.200
有些异部任务是进这个对列,有些异部任务是进这个对列

40:51.460 --> 40:53.000
其实就这个对列就一个

40:53.520 --> 40:55.300
就什么呢,就那个set immediate

40:55.500 --> 40:57.300
这个的话就其实也就

40:57.560 --> 40:59.340
set timeout,set interval

40:59.600 --> 41:02.680
好,然后其他的的话,其他的异部任务基本上都是进这个对列

41:04.220 --> 41:04.720
看到没有

41:04.980 --> 41:06.000
都是进这个对列

41:06.260 --> 41:12.400
进这个对列之后,然后这样我就挨在一起处理,把这个对列清空之后,然后接下来我执行这个

41:12.660 --> 41:13.940
对列的这个回调任务

41:14.200 --> 41:16.500
然后接下来完事之后,然后这样你如果这个对列

41:16.760 --> 41:19.060
也有回调任务,然后我再把你给清空

41:19.320 --> 41:21.100
那家走走走走,然后又在这

41:21.620 --> 41:22.120
等着

41:23.100 --> 41:25.400
等着如果有一个异部任务过来了

41:25.660 --> 41:27.700
然后接下来的话,他进到哪里了,进到这里

41:27.960 --> 41:29.240
好,那接下来我赶紧

41:29.500 --> 41:33.080
走走走走,走过来,把他的回调任务给执行了

41:33.600 --> 41:35.640
执行完了之后,然后接下来我又在这

41:35.900 --> 41:36.660
因为他又下来了嘛

41:36.920 --> 41:38.200
下来我又在这等着

41:39.480 --> 41:43.580
看到没有,又在这等着,我看就是还有没有异部任务,知道什么了

41:43.840 --> 41:45.620
知道所有的异部任务都执行完毕

41:46.380 --> 41:47.920
那我这边是不是就整个任务

41:48.180 --> 41:48.960
执行结束

41:49.720 --> 41:50.480
对不对

41:50.680 --> 41:52.980
其实他这边其实就是这六个对列

41:53.240 --> 41:56.840
就异部任务会被分配到不同的这个对列里面

41:58.880 --> 42:00.560
这是关于这个pro

42:00.820 --> 42:02.980
好,然后接下来我们这边我们说

42:03.240 --> 42:05.800
就是我们刚才在说这个timer的时候我们说过

42:06.060 --> 42:07.840
timer中的这个定时器

42:08.100 --> 42:12.440
他指定的这个时间不是准确的时间,只能尽快执行,为什么

42:12.700 --> 42:14.740
为什么,我们这边我们举个例子

42:15.000 --> 42:17.060
这边有个例子,我们把这个例子写一下

42:18.340 --> 42:20.140
来到我们的这个漏的结实

42:20.680 --> 42:21.920
好,比如说我们这边

42:22.740 --> 42:25.040
const一个start

42:26.320 --> 42:28.620
等于一个data点唠

42:29.400 --> 42:31.700
这个干嘛呢,这个获取当前的时间戳

42:33.480 --> 42:34.260
获取

42:38.120 --> 42:41.460
获取当前的时间戳

42:41.720 --> 42:42.220
ok

42:42.480 --> 42:44.280
好,接下来一个set amount

42:45.040 --> 42:46.820
好,提问啊,提问

42:47.080 --> 42:49.400
这个set amount的这个回调函数,进哪个对列

42:50.680 --> 42:51.700
他进哪个对列

42:52.120 --> 42:53.700
是不是进这个

42:54.980 --> 42:55.740
timer这个对列

42:56.520 --> 42:57.800
对不对,进timer这个对列

42:58.060 --> 42:58.560
ok

43:00.720 --> 43:03.280
好,然后接下来的话这边比如说fn1

43:05.990 --> 43:08.550
好,然后接下来的话我这个的话我让他干嘛呢

43:08.810 --> 43:12.390
我这个的话我让他就是200毫秒之后

43:13.150 --> 43:16.230
200毫秒之后这个异步任务进入timer这个对列

43:16.490 --> 43:18.270
好,然后接下来我在这里面我干嘛呢

43:18.530 --> 43:20.330
我就打印一下

43:20.850 --> 43:22.890
就是他的这个时间

43:23.870 --> 43:26.950
比如说我这边执行的是set timeout

43:28.230 --> 43:33.090
对吧,那他花费的时间就是我这边再来获取当前的时间戳

43:34.870 --> 43:36.410
好,然后接下来减去一个什么呢

43:36.670 --> 43:37.950
减去一个start

43:38.970 --> 43:40.770
ok,好,我们先来执行一下这个代码

43:43.480 --> 43:44.260
先来执行

43:47.870 --> 43:51.710
这边是不是稍微有那么一点点延迟,是不是大概是不是200毫秒

43:51.970 --> 43:53.250
对不对,再来执行

43:53.750 --> 43:55.290
基本上是200毫秒

43:55.550 --> 43:57.590
好,你看我现在接下来我做一个操作

43:58.670 --> 44:00.210
Const

44:00.470 --> 44:01.470
fs

44:01.750 --> 44:03.830
等于一个require

44:05.620 --> 44:07.140
requirefs

44:07.900 --> 44:10.220
好,然后接下来我这边我来读取文件

44:10.480 --> 44:12.780
读取文件的回调任务进哪个对列

44:13.300 --> 44:14.300
是不是进这个对列

44:15.340 --> 44:16.620
进这个pro这个对列

44:16.880 --> 44:19.940
对不对,ok,好,那接下来你看我这边做什么事情

44:20.200 --> 44:21.740
好,然后加这边file

44:23.810 --> 44:27.910
file,然后加我读取什么呢,就读取这个文件吧,index.js

44:28.170 --> 44:32.250
然后加这边utf-8,把编码指定一下

44:32.770 --> 44:35.590
好,然后加这边我们这个function,比如说f2

44:37.370 --> 44:40.710
他干嘛呢,他这边的话就是打印一下

44:41.470 --> 44:44.290
打印一下,好,文件读取结束

44:46.090 --> 44:47.370
文件读取

44:48.650 --> 44:49.150
结束

44:49.670 --> 44:51.470
好,然后接下来的话我这边

44:52.230 --> 44:54.030
Const一个start

44:54.790 --> 44:56.330
等于一个这个data

44:57.310 --> 44:58.590
点no

44:59.350 --> 45:02.170
我这边干嘛呢,我这边是不是获取当前的时间戳

45:02.430 --> 45:04.230
获取了之后,然后这样我做一个操作

45:04.990 --> 45:05.510
while

45:06.270 --> 45:07.550
只要你这个

45:07.810 --> 45:10.370
我就是实时的去获取这个

45:10.630 --> 45:11.910
当前的这个时间戳

45:12.150 --> 45:15.750
如果你这个时间戳,减去刚才的这个时间戳

45:18.210 --> 45:20.770
小于多少呢,小于一个这个500

45:21.270 --> 45:23.590
500毫秒,那这样我就一直使循环

45:23.850 --> 45:25.370
啊,这个循环我也不需要做什么

45:25.890 --> 45:26.650
我不需要做什么

45:27.110 --> 45:28.950
也就是说我这边的话就强行是不是

45:29.210 --> 45:29.990
拖时间

45:30.750 --> 45:32.030
对不对,这里的话就是

45:32.290 --> 45:33.310
强行

45:34.070 --> 45:35.610
强行拖时间

45:38.780 --> 45:39.540
强行

45:39.800 --> 45:40.820
延时

45:42.100 --> 45:42.860
延时多少

45:43.120 --> 45:43.900
是500毫秒

45:45.180 --> 45:45.680
OK

45:45.940 --> 45:47.220
好,那接下来我们来看一下

45:47.480 --> 45:48.240
我们来看一下

45:48.500 --> 45:49.520
这个代码非常有意思

45:51.320 --> 45:52.080
这个代码非常有意思

45:52.340 --> 45:55.920
刚才我们在没写这段代码的时候,我们可以看到这个set amount

45:56.180 --> 45:58.480
是不是就是在你设置了200毫秒对吧

45:58.680 --> 46:02.020
那是不是大致就是在200毫秒之后,是不是执行了这个任务

46:02.520 --> 46:05.600
对不对,好,那现在它是什么样的顺序呢,我们来看一下

46:05.860 --> 46:06.620
好,首先这边

46:07.660 --> 46:08.420
第一行代码

46:08.940 --> 46:10.460
第一行代码是不是这个

46:10.980 --> 46:11.740
同步任务

46:12.000 --> 46:13.020
对不对,它先执行

46:13.280 --> 46:15.080
好,执行之后,然后接下来这边

46:15.840 --> 46:16.340
这个

46:16.600 --> 46:18.660
这个set timeout它是不是是一个异步任务

46:19.420 --> 46:22.500
对不对,说它会进什么呢,它会进Timer这个队列

46:24.830 --> 46:25.350
看到没有

46:25.610 --> 46:27.150
它会进这个Timer这个队列

46:27.390 --> 46:29.450
Timer这个队列,然后接下来这边是不是有一个

46:29.650 --> 46:30.430
set timeout

46:31.970 --> 46:32.470
对不对

46:32.730 --> 46:37.070
好,然后接下来这边引入,引入之后再加这个,这个是不是又是一个

46:37.330 --> 46:38.110
异步的任务

46:38.610 --> 46:41.170
对不对,那这个异步的任务,它的这个

46:41.430 --> 46:42.410
这个任务

46:42.670 --> 46:45.290
回调任务,它会进哪个呢,它会进这个pro

46:47.490 --> 46:48.250
pro队列

46:50.900 --> 46:51.420
pro队列

46:51.940 --> 46:52.440
ok

46:52.700 --> 46:56.280
好,然后接下来pro队列就有一个什么呀,是不是就有一个读取文件

46:57.560 --> 46:59.620
对不对,它就有一个读取文件

47:01.160 --> 47:01.660
好

47:01.860 --> 47:04.340
然后我们这两个队列,两个异步队列

47:04.580 --> 47:08.520
谁先这个任务先出现了,是不是pro这个队列的任务先出现

47:09.280 --> 47:12.360
对不对,因为我这边读取这个文件,这个文件也没多少

47:12.620 --> 47:13.600
它这个

47:13.860 --> 47:17.480
回调任务先出现,也就说这里我们结合着这个图来看

47:17.740 --> 47:21.320
它是不是这个队列里面,先出现就是那个

47:21.840 --> 47:22.600
那个

47:22.860 --> 47:24.640
读文件的那个回调任务

47:24.900 --> 47:26.700
对不对,那接下来它就会执行咯

47:27.220 --> 47:28.240
注意它就会执行

47:28.500 --> 47:30.540
如果这个时候你后面又有一个任务

47:30.740 --> 47:32.280
那接下来我会挨在这执行

47:32.540 --> 47:34.580
先执行它,再执行后面的

47:34.840 --> 47:35.620
再执行后面的

47:35.880 --> 47:36.880
挨在这执行

47:37.140 --> 47:39.200
好,那接下来我先执行我的第一个

47:39.720 --> 47:41.760
读文件的这个回调任务

47:42.020 --> 47:43.040
那这个回调任务

47:43.800 --> 47:49.680
这个回调任务的话,你看这边打印输出文件读取结束,然后既然我这边是不是强行延时

47:49.940 --> 47:50.720
500毫秒

47:50.980 --> 47:53.780
那在这个延时的时候,那我这边的话

47:55.060 --> 47:56.340
这边这个timer

47:56.600 --> 47:59.940
是不是我的那个set timeout等200毫秒,是不是这个任务就出现了

48:00.740 --> 48:02.120
对不对,我这边

48:02.540 --> 48:03.300
我写一下

48:04.840 --> 48:07.920
就是首先的话这个读文件的这个任务

48:08.180 --> 48:09.460
先进这个队列

48:09.960 --> 48:13.300
先进这个队列,我是不是先就执行什么,是不是先执行这个任务

48:13.560 --> 48:15.860
对不对,执行这个任务,然后接下来

48:16.120 --> 48:18.400
它有一个500毫秒的延时

48:18.660 --> 48:21.740
但是还没到500毫秒的时候,那接下来我这个

48:22.500 --> 48:23.480
set timeout

48:23.740 --> 48:25.840
200毫秒的那个回调任务

48:26.100 --> 48:27.880
也已经就是准备就区了

48:28.140 --> 48:28.900
进入这个回调了

48:29.100 --> 48:31.160
但我这边我会不会结束它呢

48:31.920 --> 48:32.960
我会不会结束它呢

48:33.460 --> 48:37.040
我不会结束它,我会等着什么呢,等着我整个这个任务

48:37.300 --> 48:38.840
执行完毕之后

48:39.340 --> 48:40.880
再去干嘛呢,再去执行它

48:41.140 --> 48:42.420
说说你看到这里

48:43.440 --> 48:46.260
你看到这里,这里的话虽然写的是

48:46.780 --> 48:47.280
200

48:47.800 --> 48:50.100
但是实际上,把这个清空

48:52.300 --> 48:53.580
实际上你看这边

48:54.100 --> 48:54.600
走

48:55.380 --> 48:55.760
你看

48:56.020 --> 48:57.940
这花了差不多500多毫秒

48:58.580 --> 49:01.740
对不对,为什么,原因就是我这个pro这个队列

49:02.000 --> 49:04.800
pro这个队列我要等待什么呢,等待它

49:05.060 --> 49:07.120
全部执行完毕之后

49:07.880 --> 49:10.440
才来执行这个后面的代码

49:10.700 --> 49:13.000
看到没有,就是我们这边所说的

49:14.280 --> 49:15.560
在哪里呢

49:18.650 --> 49:19.430
在

49:20.450 --> 49:21.230
我看一下

49:25.860 --> 49:26.380
这边

49:27.920 --> 49:28.680
就这里

49:29.160 --> 49:31.240
如果这个pro队列不为空

49:31.480 --> 49:36.100
它会干嘛呢,它会便利你整个回调队列,指的是这个pro这个队列

49:36.360 --> 49:38.660
这个整个队列并同步执行

49:38.920 --> 49:42.240
让我在同步执行的时候,哪怕你这个时候有timer了

49:42.500 --> 49:44.800
我不管你,我这边已经开始执行了

49:45.320 --> 49:47.620
对不对,我已经开始执行了,你这个timer

49:47.880 --> 49:48.900
哪怕已经到了

49:49.160 --> 49:53.000
你timer的这个回调任务已经放入这个timer这个队列了,让我不管

49:53.260 --> 49:55.560
我要先把我的这个队列执行完

49:55.820 --> 49:57.100
然后我再去执行你的

49:57.360 --> 49:58.120
timer队列

49:58.880 --> 50:00.940
看到没有,它这边就是这个样子的

50:02.720 --> 50:05.800
那比如说这里,这里我们可以进一步验证,怎么验证呢

50:06.060 --> 50:07.840
那我们比如说这边再把它复制一份

50:09.120 --> 50:09.900
我们再来一个

50:11.940 --> 50:16.040
你看这边,这边这个是文件结束,让我们这边稍微做一下区别文件结束

50:16.560 --> 50:17.060
OK

50:17.320 --> 50:19.880
好,那接下来的话这个,这个是不是仍然会进哪里

50:20.140 --> 50:22.440
仍然是不是会进这个timer这个队列

50:22.700 --> 50:24.240
对不对,好大家这两个

50:24.500 --> 50:25.760
这个读文件

50:26.220 --> 50:28.520
会进什么呢,会进这个就是pro队列

50:28.780 --> 50:31.100
这个是不仍然会进这个pro队列

50:31.600 --> 50:34.160
OK,好那接下来我现在这个pro队列是不是有东西

50:34.420 --> 50:37.740
好那接下来我这边先执行这个pro队列的回调任务

50:38.000 --> 50:40.560
答应出他文件读取结束

50:40.820 --> 50:43.380
大家这边是不是强行延时500毫秒

50:43.640 --> 50:47.220
延时500毫秒的时候,那这样我这边这个timer这个队列

50:47.720 --> 50:50.800
它这个回调任务就已经进这个timer队列了,那没

50:51.060 --> 50:52.600
那没办法,你跟我等着

50:53.060 --> 50:56.640
对不对,你跟我等着,我这边的话我要先清空这个pro这个队列

50:56.900 --> 50:59.720
好,大家这边500毫秒到了,然后接下来这边

50:59.980 --> 51:01.760
pro队列又有任务了

51:02.540 --> 51:04.320
对不对,我pro队列还有任务

51:04.580 --> 51:07.920
那接下来这边文件读取结束2,那这边是不是又延时

51:08.180 --> 51:09.140
500毫秒

51:09.400 --> 51:10.980
对不对,那你就只有给我一直等着

51:11.760 --> 51:13.540
看到没有,你就只有给我一直等着

51:13.800 --> 51:15.580
说我们这边呢,我们这边来执行

51:15.840 --> 51:16.360
走

51:18.160 --> 51:20.200
看到没有,是不是就是1000多毫秒

51:21.080 --> 51:24.540
你看这边,明明我这边设置的是200毫秒,但是我这边的话

51:25.060 --> 51:26.340
是不是1000多毫秒呀

51:27.100 --> 51:27.620
看到没有

51:27.880 --> 51:32.740
为什么,就是因为这边的话这个队列,你就一定要把这个搞清楚

51:33.780 --> 51:34.540
明白没有

51:34.800 --> 51:36.580
一定要把这个搞清楚

51:37.860 --> 51:41.180
好,然后接下来的话是一个这个check这个阶段

51:41.440 --> 51:42.980
这个阶段没什么好说的

51:43.240 --> 51:44.780
就是这个set immediate

51:45.300 --> 51:46.820
它的话就会被接入

51:47.080 --> 51:49.380
就是会加入到这个check这个

51:49.640 --> 51:50.140
队列

51:50.400 --> 51:51.940
这个set immediate

51:52.460 --> 51:55.520
它就和那个set time out,然后你把那个时间设置为零

51:55.780 --> 51:56.540
是一样的

51:56.800 --> 51:59.620
它就是在那个pro

52:00.140 --> 52:03.720
这个pro这个阶段执行完之后,然后立马执行这个check阶段

52:03.980 --> 52:05.520
执行这里面的这个回调

52:05.780 --> 52:07.560
比如我们把这个例子我们来看一下嘛

52:09.690 --> 52:10.990
把这注释掉

52:14.280 --> 52:16.320
这边的话是check阶段

52:23.510 --> 52:25.570
好,首先的话这边的话log

52:26.590 --> 52:27.870
log一个

52:28.850 --> 52:29.610
start

52:30.130 --> 52:31.930
好,然后接下来这边的话set time out

52:34.130 --> 52:36.430
好,这边的话一个回调函数

52:36.950 --> 52:37.970
这个的话是零

52:39.490 --> 52:41.050
好,然后接下来这边的话log

52:41.810 --> 52:44.110
log什么呢,log timer

52:44.610 --> 52:45.650
这个time 1

52:46.930 --> 52:49.230
好,然后接下来的话这边有一个这个promise

52:50.250 --> 52:52.050
promise这个resolve

52:53.330 --> 52:54.350
然后点认

52:56.680 --> 52:59.000
好,然后接下来这边就是这个function

53:01.000 --> 53:02.280
然后这边log

53:03.100 --> 53:05.000
这个是promise

53:05.260 --> 53:09.800
好,然后完事之后,然后又是一个set time out

53:10.060 --> 53:10.840
复制一份

53:12.120 --> 53:14.400
set time out,好,这边是time out

53:15.440 --> 53:16.200
然后promise

53:16.960 --> 53:19.520
好,然后最后一个promise

53:21.320 --> 53:24.640
promise,然后这边是这个promise 3

53:24.900 --> 53:27.200
好,然后最后是这个end

53:29.480 --> 53:33.840
ok,好,那接下来我们来分析一下这一段代码

53:34.040 --> 53:34.560
它是

53:34.820 --> 53:37.380
怎么样的一个这个运作方式

53:38.660 --> 53:41.220
好,在分析之前的话,我这边要介绍一个知识

53:41.480 --> 53:43.000
因为这边涉及到这个promise

53:43.260 --> 53:44.760
promise

53:46.080 --> 53:46.840
promise

53:47.100 --> 53:48.120
会被

53:50.400 --> 53:51.680
会被干嘛呢

53:51.940 --> 53:52.700
会

53:53.480 --> 53:57.060
会被放入到微任务

53:57.560 --> 53:58.080
对立

53:58.840 --> 54:01.400
ok,这是首先第一点,然后接下来这边第二点

54:01.920 --> 54:05.240
就是我们刚才在讲这个浏览器的事件循环的时候

54:05.440 --> 54:06.740
我们回到浏览器的事件循环

54:07.240 --> 54:11.080
浏览器的事件循环是吧,首先先把微任务对立清拷

54:11.340 --> 54:14.400
然后竟然取出红任务对立的一个红任务执行

54:14.660 --> 54:15.940
然后竟然如果有微任务

54:16.200 --> 54:19.780
先放入到微任务对立,然后等我这个红任务执行完了之后

54:20.040 --> 54:21.140
是不是又把这个微任务

54:21.400 --> 54:21.900
清拷

54:22.340 --> 54:23.880
对不对,那这个

54:24.640 --> 54:27.200
这个load它是什么样子的,load是这个样子的

54:27.460 --> 54:30.020
就我这边是不是有不同的对立,timers对立

54:30.280 --> 54:34.380
pro对立,check对立,对不对,然后接下来每当我这边

54:35.460 --> 54:36.220
执行一个

54:37.500 --> 54:40.060
这个对立里面的这个任务的时候

54:40.320 --> 54:43.380
然后这样我就需要干嘛呢,我就需要去把这个微任务

54:43.640 --> 54:45.680
就假设这边有个微任务对立

54:45.940 --> 54:48.000
我就需要把这个微任务去把它清拷

54:48.760 --> 54:50.040
其实和上面是一样的

54:50.560 --> 54:52.860
对不对,就我这边timers,timers比如说我这边

54:53.120 --> 54:54.900
一会儿比如说有两个任务,一个

54:55.160 --> 54:55.660
两个

54:55.920 --> 54:57.720
好,那接下来我这边的话执行

54:57.980 --> 55:00.740
这个第1个之前我先去把这个微任务

55:01.000 --> 55:04.640
这边有个微任务对立先清拷,清拷了我再执行它

55:05.040 --> 55:07.400
它执行完了之后,那家如果有微任务

55:07.660 --> 55:11.760
如果又有微任务,那我又去把微任务清拷,那家再执行第2个

55:12.280 --> 55:12.780
看到没有

55:13.040 --> 55:14.580
好,我们这边我们来写一下

55:15.600 --> 55:16.620
然后会

55:17.900 --> 55:19.440
先清拷

55:20.200 --> 55:21.480
微任务对立

55:23.020 --> 55:23.540
对立

55:24.760 --> 55:25.340
对立

55:26.860 --> 55:27.620
再

55:28.400 --> 55:29.240
执行

55:29.680 --> 55:30.700
其他

55:30.960 --> 55:32.760
这个任务

55:33.240 --> 55:35.520
对立的这个回调任务

55:38.640 --> 55:39.400
回调

55:42.250 --> 55:42.770
OK

55:43.010 --> 55:45.010
好,那接下来我们就来分析一下

55:45.270 --> 55:46.090
我说小一点

55:48.910 --> 55:49.930
好,首先干嘛呢

55:50.690 --> 55:51.730
算了,还是放大一点吧

55:51.990 --> 55:52.490
就这么大

55:52.750 --> 55:54.790
好,首先第一步我们从26行开始

55:55.050 --> 55:56.530
26行这个是不是一个同步带吗

55:56.790 --> 55:57.290
对不对

55:58.370 --> 55:59.410
首先的话打印出来

56:00.170 --> 56:00.670
start

56:00.930 --> 56:03.490
好,然后接下来这边是不是这个set timeout

56:04.250 --> 56:04.770
是不是一步

56:05.030 --> 56:06.570
对不对,一步的话接下来进什么

56:06.770 --> 56:08.570
进这个timeout这个对立

56:09.330 --> 56:11.650
对不对,那家这边有一个这个set timeout

56:12.930 --> 56:13.950
我们假设这个set

56:14.210 --> 56:15.990
假设这个是set timeout一嘛

56:16.250 --> 56:17.530
假设这个,因为下面还有一个

56:18.050 --> 56:19.070
好,那家这边

56:19.330 --> 56:21.370
这边的话是不是又是一个一步的

56:21.890 --> 56:25.210
对不对,那接下来这边的话就是一个set timeout二

56:28.640 --> 56:29.140
对吧

56:29.400 --> 56:31.440
好,然后接下来这边是不是有一个promise

56:32.200 --> 56:34.520
promise的话它是进什么,是不是进微任务对立

56:35.040 --> 56:36.060
好,所以接下来这边的话

56:36.320 --> 56:37.080
微任务

56:39.160 --> 56:39.940
进微任务

56:40.140 --> 56:41.220
好,微任务的话就是什么

56:41.480 --> 56:43.020
是不是这个打印输出promise3

56:44.800 --> 56:46.340
对吧,然后接下来这边到43行

56:46.600 --> 56:48.640
43行是什么,是不是同步的带吗

56:48.900 --> 56:50.180
对不对,所以这边的话就直接

56:50.700 --> 56:51.460
打印输出

56:53.000 --> 56:54.020
OK,完了

56:54.280 --> 56:58.120
完了之后,然后接下来要开始执行各个对立的这个回调任务了

56:58.380 --> 56:58.880
谁

56:59.140 --> 56:59.660
先执行

56:59.920 --> 57:02.460
我这边微任务对立先有回调任务

57:02.720 --> 57:03.740
所以我先干嘛呢

57:04.000 --> 57:06.040
先把微任务对立清空

57:06.300 --> 57:07.320
所以接下来的话这边

57:07.580 --> 57:08.860
promise3

57:09.580 --> 57:11.380
怎么样,先把微任务对立清空

57:11.640 --> 57:13.680
清空了之后,然后接下来我这边

57:13.940 --> 57:15.720
也没有这个pro之类的

57:15.980 --> 57:17.260
是不是直接来到这个timer

57:18.280 --> 57:20.840
对不对,直接来到timer,然后执行set timeout1

57:21.100 --> 57:23.140
set timeout1,然后首先输出什么

57:23.400 --> 57:24.440
是输出这个

57:25.200 --> 57:25.960
timeout1

57:27.760 --> 57:30.580
对不对,输出timer1,然后接下来这个又是一个什么

57:31.080 --> 57:32.360
是不是又是一个微任务

57:32.620 --> 57:35.180
好,然后接下来把这个放入到微任务对立

57:35.940 --> 57:40.040
放入到微任务对立之后,然后发现微任务对立没有清空哦

57:40.300 --> 57:41.840
我在执行下一个

57:42.100 --> 57:44.140
就是我这个set timeout1是不是已经执行完了

57:44.660 --> 57:45.160
对不对

57:45.420 --> 57:49.520
我理论上来讲该执行下一个了,但我在执行下一个之前我发现

57:50.020 --> 57:51.320
微任务对立又有东西了

57:51.820 --> 57:53.100
所以我这边的话我就干嘛呢

57:53.620 --> 57:54.640
我这里的话就是

57:55.660 --> 57:56.680
把这个清空

57:59.090 --> 57:59.590
对吧

57:59.850 --> 58:01.390
打印输出这个promise1

58:01.650 --> 58:03.950
好,清空之后再来执行第2个

58:04.210 --> 58:04.970
set timeout2

58:05.230 --> 58:06.250
打印输出什么呢

58:06.450 --> 58:07.990
打印输出timeout2

58:09.790 --> 58:11.070
然后接下来把这个

58:12.090 --> 58:13.370
把这个放入到什么呢

58:13.630 --> 58:15.670
放入到这个promise2里面

58:15.930 --> 58:17.470
我这个timeout就已经清空了

58:17.730 --> 58:19.010
这个对立就已经清空了

58:19.270 --> 58:20.290
好,然后接下来这边

58:21.570 --> 58:22.330
promise2

58:22.590 --> 58:24.130
好,那接下来最后的话就是把这个

58:26.710 --> 58:27.730
这个打印输出

58:27.990 --> 58:30.810
说打印出来的结果就是应该是什么呢,就应该是start

58:31.070 --> 58:31.570
and

58:31.830 --> 58:32.850
promise3

58:33.110 --> 58:36.430
timeout1,promise1,timeout2,promise2

58:36.950 --> 58:37.470
看了没有

58:37.870 --> 58:39.470
好,那我们这边我们来看一下是不是

58:40.230 --> 58:40.750
走

58:42.290 --> 58:43.570
startand

58:43.830 --> 58:48.170
promise3,timeout1,promise1,timeout2,promise2

58:48.950 --> 58:49.450
看了没有

58:49.710 --> 58:52.010
说这边的话你一定要注意

58:52.270 --> 58:52.790
一定要注意

58:55.760 --> 58:57.220
这边的话是这个

58:57.480 --> 58:59.340
但是这边其实没有用到check

58:59.600 --> 59:01.140
是吧,并没有用到check

59:01.400 --> 59:03.440
好,我们把这个代码我们把它改一下吧

59:03.700 --> 59:07.020
我们看怎么改一下,让它能够用到这个check

59:08.020 --> 59:11.840
我看一下我这后面有没有讲到set

59:12.100 --> 59:13.640
那个set

59:14.140 --> 59:14.900
immediate

59:15.160 --> 59:16.180
就check阶段的

59:17.220 --> 59:18.240
刚才是这个例子

59:18.740 --> 59:19.780
是吧,刚才是这个例子

59:20.540 --> 59:21.560
哦,这有,这有

59:21.820 --> 59:23.360
OK,好,那我们直接在这看

59:24.120 --> 59:25.400
好,一些注意点

59:25.660 --> 59:26.680
首先第一个

59:26.940 --> 59:28.720
就是这个set timeout

59:28.980 --> 59:31.040
它和这个set immediate

59:31.300 --> 59:32.320
它们两者的区别

59:32.580 --> 59:33.860
set immediate

59:34.100 --> 59:36.420
它设计是在什么呢,是在这个pro阶段

59:36.620 --> 59:37.660
完成时

59:37.920 --> 59:39.180
也就是说check阶段

59:39.440 --> 59:40.720
也就是说在这个阶段

59:41.240 --> 59:42.260
这个check阶段

59:42.520 --> 59:45.840
check阶段来执行这个set immediate

59:46.100 --> 59:47.900
而你的这个set timeout

59:48.160 --> 59:51.740
set timeout是在这个pro阶段空闲时

59:52.240 --> 59:54.800
且设定时间到达后执行

59:55.060 --> 59:58.140
然后它是在什么呢,它是在这个timeout这个阶段

59:58.900 --> 01:00:00.700
对不对,在这个timeout这个阶段

01:00:00.960 --> 01:00:05.040
就是首先这两者的话有这么一个区别

01:00:05.340 --> 01:00:06.900
好,那接下来我们来看这个代码

01:00:08.060 --> 01:00:09.600
这边的话set timeout

01:00:09.860 --> 01:00:10.880
这个的话是0

01:00:11.140 --> 01:00:11.900
这个的话

01:00:12.160 --> 01:00:14.200
这个的话你可以把理解成也是set timeout0

01:00:14.460 --> 01:00:16.760
但这个的话谁先谁后呢

01:00:17.020 --> 01:00:18.560
这个的话其实说不准

01:00:19.320 --> 01:00:21.640
这个说不准,有可能这个set timeout

01:00:22.660 --> 01:00:23.940
这个set timeout

01:00:24.200 --> 01:00:26.700
在前,有可能这个set immediate

01:00:26.960 --> 01:00:27.520
在前

01:00:27.780 --> 01:00:29.060
为什么,我们来看一下

01:00:29.320 --> 01:00:31.100
首先我们来执行一下,我们先看一下是不是

01:00:33.260 --> 01:00:34.280
把这个注释掉

01:00:38.010 --> 01:00:38.790
我们看下面

01:00:41.220 --> 01:00:42.240
格式画一下

01:00:43.000 --> 01:00:44.040
好,我们这边要走

01:00:45.320 --> 01:00:48.640
你看现在第一次是把immediate先执行,那timeout

01:00:48.900 --> 01:00:49.660
要走

01:00:51.200 --> 01:00:52.220
走,你看这一次

01:00:52.480 --> 01:00:54.280
所以timeout在前,immediate

01:00:54.540 --> 01:00:55.300
在后面

01:00:55.560 --> 01:00:56.840
对不对,好,为什么

01:00:57.100 --> 01:00:59.400
这个的话结合这边这个图来看

01:01:00.420 --> 01:01:01.200
结合这个图

01:01:01.700 --> 01:01:04.520
好,为什么会这个样子呢,我们来看一下

01:01:05.280 --> 01:01:07.320
把这个的话代码放到这里

01:01:11.320 --> 01:01:12.600
把这个先关掉

01:01:15.660 --> 01:01:17.960
OK,好,我们结合这个图,我们来看

01:01:19.500 --> 01:01:22.060
你这边的话这个set timeout

01:01:22.820 --> 01:01:24.360
它的回调任务是进哪里

01:01:24.620 --> 01:01:26.420
是不是进这个timeout这个阶段

01:01:26.920 --> 01:01:29.480
对不对,进这个timeout是这个任务队列

01:01:29.740 --> 01:01:32.040
而这个set immediate

01:01:32.300 --> 01:01:33.840
它是进什么呢,进这个

01:01:34.340 --> 01:01:35.120
进这个check

01:01:35.880 --> 01:01:36.640
这个任务队列

01:01:36.900 --> 01:01:41.000
但是你这边的话虽然设置这个,就是你这边写的是0

01:01:41.260 --> 01:01:43.060
但它不可能完全达到0

01:01:43.520 --> 01:01:45.320
它一般的话就是可能是1毫秒

01:01:45.580 --> 01:01:47.620
或者是2毫秒3毫秒

01:01:48.140 --> 01:01:50.440
说这个的话就取决于你这个电脑

01:01:50.700 --> 01:01:53.000
每一次在执行这个代码的时候

01:01:53.260 --> 01:01:57.100
看就是他们这个任务哪一个先被放到这个任务队列

01:01:57.600 --> 01:01:59.400
有可能我这边让我这次执行

01:01:59.660 --> 01:02:02.980
效果很好,立马就是这个set timeout的回调任务

01:02:03.240 --> 01:02:07.600
就直接已经放入到timeout队列了,那我肯定就是先把timeout

01:02:08.080 --> 01:02:08.880
先执行

01:02:09.140 --> 01:02:11.440
执行到之后,然后走走走走走

01:02:11.700 --> 01:02:14.000
poor空的是吧,然后再到check

01:02:14.260 --> 01:02:17.580
到check的话,然后在check阶段,肯定是立即执行

01:02:17.840 --> 01:02:18.860
set immediate

01:02:20.140 --> 01:02:22.440
看没有,所以它就是先是timeout

01:02:22.700 --> 01:02:23.720
再是immediate

01:02:23.980 --> 01:02:28.340
也有可能是什么呢,也有可能我这次执行的时候,我电脑卡了一下

01:02:28.840 --> 01:02:30.640
卡了一下之后,然后接下来的话

01:02:30.900 --> 01:02:34.480
我这个回调任务还没有放入到timeout队列

01:02:34.940 --> 01:02:36.740
所以说我这边就

01:02:37.000 --> 01:02:39.300
就往后走了,走走走走

01:02:39.560 --> 01:02:40.580
走到这个check

01:02:40.840 --> 01:02:42.620
check的话就把这个输出了

01:02:42.880 --> 01:02:45.180
对不对,输出了之后再回头再来看

01:02:45.440 --> 01:02:48.760
timeout是有了,再来清空timeout队列

01:02:49.540 --> 01:02:50.300
看到没有

01:02:50.560 --> 01:02:54.660
说说这个的话就是前后关系,它是不一定的

01:02:54.920 --> 01:02:57.720
它是不一定的,取决于就是你的电脑

01:02:57.980 --> 01:02:59.780
它当时执行这段代码

01:03:00.040 --> 01:03:01.820
它的一个就是状态

01:03:02.080 --> 01:03:03.880
刚才的话也给大家看了

01:03:04.680 --> 01:03:05.700
对不对,也看了

01:03:05.960 --> 01:03:07.440
有些时候那个timeout

01:03:07.700 --> 01:03:09.800
在前,我们这边再来看一次嘛

01:03:19.630 --> 01:03:21.670
有些时候是timeout在前

01:03:22.190 --> 01:03:23.470
这个timeout在前

01:03:23.730 --> 01:03:25.770
有些时候是不是就是immediate在前

01:03:26.030 --> 01:03:27.830
对不对,这个是不一定的

01:03:29.870 --> 01:03:32.170
这是这个第一个注意点

01:03:35.730 --> 01:03:36.490
然后

01:03:36.750 --> 01:03:43.910
当当二者在一部IO内部调用时,总是先调用这个set immediate

01:03:44.130 --> 01:03:45.770
再执行set timeout

01:03:46.030 --> 01:03:47.950
什么意思呢,就是我这边的话

01:03:48.730 --> 01:03:51.030
比如说我们这边,我把这个代码注释掉

01:03:53.180 --> 01:03:54.580
比如说我们这边

01:03:54.840 --> 01:04:01.850
constfs等于一个requirefs

01:04:02.610 --> 01:04:10.720
好,然后再在这边fs.readfileindex.js

01:04:11.220 --> 01:04:15.480
好,然后接下这边UTF-8,然后再加这边的话

01:04:15.740 --> 01:04:16.600
function

01:04:16.600 --> 01:04:23.260
好,然后接下来在这边的话,我们设置两个,一个是set timeout

01:04:27.900 --> 01:04:28.920
0,是吧

01:04:29.180 --> 01:04:30.980
好,这边就是log一下

01:04:32.000 --> 01:04:34.820
log一下这个timeout

01:04:35.080 --> 01:04:36.620
然后一个是什么呢,一个是这个

01:04:37.120 --> 01:04:38.140
直接拿过来

01:04:40.360 --> 01:04:41.380
一个是这个

01:04:42.140 --> 01:04:45.220
好,那它这个话一定是什么呢,一定是它先输出

01:04:45.480 --> 01:04:46.760
然后才输出它

01:04:47.260 --> 01:04:48.540
我们来看一下是不是

01:04:50.750 --> 01:04:51.250
看到没有

01:04:52.030 --> 01:04:52.530
看到没有

01:04:53.810 --> 01:04:54.330
看到没有

01:04:54.590 --> 01:04:56.890
一定是什么呢,一定是它先输出

01:04:57.150 --> 01:04:57.910
才输出它

01:04:58.170 --> 01:05:01.750
为什么呢,你这边的话,仍然是可以结合这个图来看

01:05:02.010 --> 01:05:04.570
我这边把这个图再次把它打开

01:05:06.850 --> 01:05:09.150
说小一点

01:05:10.430 --> 01:05:12.230
我们再次结合这个图

01:05:17.630 --> 01:05:20.190
这个图在这个位置

01:05:20.450 --> 01:05:24.290
好,我们这边的话,这个fs.readfile

01:05:24.550 --> 01:05:26.090
它是进哪个任务队列

01:05:26.850 --> 01:05:28.130
它是进哪个任务队列

01:05:28.330 --> 01:05:30.630
它是不是进这个pro这个任务队列

01:05:31.670 --> 01:05:32.170
对不对

01:05:32.430 --> 01:05:33.970
它进这个pro这个任务队列

01:05:34.230 --> 01:05:38.470
进这个pro这个任务队列之后,然后接下来的话,这边这个time

01:05:38.730 --> 01:05:39.610
这个set timeout

01:05:39.870 --> 01:05:41.150
它是进times

01:05:41.650 --> 01:05:44.210
而它是进哪里,它是进checks

01:05:44.970 --> 01:05:45.750
进这个check

01:05:46.510 --> 01:05:47.790
那你这个pro

01:05:48.050 --> 01:05:51.370
执行完了之后,马上就是什么呀,是不是就是check

01:05:51.630 --> 01:05:53.930
所以它这边的话,一定是它先输出

01:05:54.650 --> 01:05:55.150
没有没有

01:05:55.410 --> 01:05:57.410
check完了之后,然后接下来再干嘛呀

01:05:57.670 --> 01:05:59.250
是不是踩进这个timeout啊

01:06:00.030 --> 01:06:00.790
对不对

01:06:01.050 --> 01:06:03.090
说说为什么就是这里

01:06:03.350 --> 01:06:06.170
你如果是写在这个,就是比如说IO的读取啊

01:06:06.430 --> 01:06:08.730
就IO的请求啊,或者文件的读取啊

01:06:08.990 --> 01:06:11.810
它一定是先执行set image,为什么

01:06:12.070 --> 01:06:13.590
因为它是check呀

01:06:14.110 --> 01:06:15.630
它是在这个check这个

01:06:15.890 --> 01:06:16.910
任务队列里面

01:06:17.170 --> 01:06:18.410
对不对,你这个pro

01:06:18.670 --> 01:06:21.410
因为我们这个读取文件,它是在pro这个任务队列吗

01:06:21.670 --> 01:06:23.330
对不对,你pro任务队列

01:06:24.650 --> 01:06:25.930
完了之后就是check呀

01:06:26.690 --> 01:06:27.410
明白没有

01:06:27.670 --> 01:06:31.810
所以注意啊注意,它有些时候面试题它就会考你这些

01:06:33.350 --> 01:06:33.850
ok

01:06:34.370 --> 01:06:35.410
好,然后接下来下一个

01:06:35.910 --> 01:06:39.750
下一个就是关于这个process.legstick

01:06:41.030 --> 01:06:45.390
process.legstick的话,它也是进入这个wizern队列

01:06:45.890 --> 01:06:50.510
但是呢,它比这个promise任,它的优先级要高一些

01:06:51.010 --> 01:06:53.330
那我们这边让我们把这个这段代码来看一下

01:06:54.410 --> 01:06:55.410
把这段代码

01:07:01.080 --> 01:07:02.620
这边的话是这个

01:07:05.330 --> 01:07:06.350
开一个中端

01:07:11.830 --> 01:07:13.110
桌面上

01:07:13.870 --> 01:07:15.150
我们来分析一下这个

01:07:19.780 --> 01:07:20.820
我们这边来分析一下

01:07:21.080 --> 01:07:22.100
好,首先这边

01:07:22.880 --> 01:07:23.380
这边

01:07:23.640 --> 01:07:25.420
这边是不是有一个set timeout

01:07:26.460 --> 01:07:29.020
对不对,那这个set timeout它是进什么

01:07:29.260 --> 01:07:30.300
是不是进这个timers啊

01:07:31.060 --> 01:07:32.340
对不对,进这个timers

01:07:33.880 --> 01:07:37.980
timers,这边首先有一个set timeout

01:07:39.260 --> 01:07:39.760
ok

01:07:42.170 --> 01:07:42.830
进这个

01:07:43.090 --> 01:07:44.270
好,那接下来的话就是这个

01:07:44.710 --> 01:07:45.470
legstick

01:07:45.730 --> 01:07:47.010
legstick它是什么

01:07:47.270 --> 01:07:48.810
它是不是进wizern队列

01:07:49.070 --> 01:07:52.650
对不对,它压根就不属于那六个队列里面的任何一个队列

01:07:52.910 --> 01:07:53.670
它是wizern

01:07:55.210 --> 01:07:56.230
wizern队列

01:07:57.010 --> 01:07:57.510
ok

01:07:57.770 --> 01:07:58.270
进去

01:07:58.530 --> 01:08:01.110
啊,然后接下来就是这个legstick

01:08:02.370 --> 01:08:04.170
好,那接下来我整个这个

01:08:04.430 --> 01:08:06.730
代码完了,完了,接下来我就开始

01:08:06.990 --> 01:08:08.270
应该从各个队列里面

01:08:08.530 --> 01:08:10.570
取这个回调任务是不是来执行的

01:08:10.830 --> 01:08:11.330
对不对

01:08:11.530 --> 01:08:14.870
好,那接下来我首先这边console.loglegstick

01:08:15.630 --> 01:08:17.430
因为先执行wizern队列嘛

01:08:17.690 --> 01:08:18.710
legstick

01:08:19.210 --> 01:08:19.990
先执行

01:08:20.250 --> 01:08:22.550
执行完了之后,然后接下来发现你这边

01:08:23.050 --> 01:08:25.370
是不是又是一个要进入wizern队列

01:08:25.630 --> 01:08:27.410
好,那这样我又放了wizern队列里面

01:08:27.930 --> 01:08:30.230
放了wizern队列里面,然后这样我又得执行咯

01:08:30.730 --> 01:08:33.550
对不对,所以接下来这边又执行这个legstick

01:08:36.650 --> 01:08:38.450
然后这边是不是又放了一个进去

01:08:38.710 --> 01:08:40.490
又打印这个,是不是legstick

01:08:41.010 --> 01:08:42.550
对不对,所以接下来的话又是什么

01:08:42.930 --> 01:08:44.290
打印legstick

01:08:45.050 --> 01:08:48.550
然后这边又是wizern,也就是我这边一直在执行wizern

01:08:48.790 --> 01:08:49.930
结果它又一直干嘛

01:08:50.190 --> 01:08:52.230
往我的wizern队列里面添加wizern

01:08:52.490 --> 01:08:54.530
就导致我这边要一直执行什么

01:08:54.790 --> 01:08:56.830
执行这个wizern队列里面的wizern

01:08:57.090 --> 01:08:57.870
直到什么呢

01:08:58.130 --> 01:09:00.430
直到我这边四个都打印出来之后

01:09:00.690 --> 01:09:02.730
我的wizern队列是不是确确实实就

01:09:02.990 --> 01:09:03.750
清空了

01:09:04.270 --> 01:09:05.290
对不对,就没了

01:09:05.550 --> 01:09:07.850
没了之后,然后接下来我再来执行什么

01:09:08.110 --> 01:09:09.630
执行这个time里面的

01:09:09.890 --> 01:09:11.690
那接下来首先打印出什么

01:09:11.890 --> 01:09:13.230
打印出time1

01:09:13.490 --> 01:09:13.990
对不对

01:09:14.770 --> 01:09:15.530
打印出

01:09:16.550 --> 01:09:17.330
time1

01:09:17.590 --> 01:09:18.850
然后再打印出什么

01:09:19.110 --> 01:09:20.390
再打印出promise

01:09:22.190 --> 01:09:23.210
promise

01:09:23.470 --> 01:09:25.010
好,我们这边我们来看一下是不是

01:09:25.770 --> 01:09:26.270
走

01:09:27.830 --> 01:09:28.330
看到没有

01:09:28.590 --> 01:09:29.090
走

01:09:29.870 --> 01:09:30.370
看到没有

01:09:30.630 --> 01:09:31.650
就是这个样子的

01:09:31.910 --> 01:09:33.450
这是关于这个

01:09:33.970 --> 01:09:36.010
processlegstick

01:09:36.270 --> 01:09:40.870
它是会放入到wizern队列的,并且它的优先级比这个

01:09:41.070 --> 01:09:42.610
这个promise任

01:09:42.870 --> 01:09:43.630
都还要高

01:09:43.890 --> 01:09:45.170
那我们这边我们可以看一下

01:09:45.430 --> 01:09:46.970
比如说我们这边这段代码

01:09:47.730 --> 01:09:49.010
我们来分析一下

01:09:50.550 --> 01:09:51.830
把这段代码分析一下

01:09:56.290 --> 01:09:57.810
这边的话是要证明什么呢

01:09:58.590 --> 01:09:59.610
证明

01:10:00.890 --> 01:10:02.430
证明这个

01:10:02.690 --> 01:10:04.730
这个这个legstick

01:10:06.620 --> 01:10:07.640
legstick

01:10:07.900 --> 01:10:09.680
和这个promise

01:10:12.800 --> 01:10:13.820
都是

01:10:14.580 --> 01:10:17.920
放入wizern队列

01:10:19.240 --> 01:10:20.260
但是

01:10:21.540 --> 01:10:22.560
前者

01:10:22.820 --> 01:10:24.620
比后者

01:10:26.160 --> 01:10:27.940
的优先级

01:10:28.700 --> 01:10:29.220
高

01:10:29.740 --> 01:10:31.520
那我们这边我们来看一下

01:10:31.780 --> 01:10:32.660
首先的话这边

01:10:32.920 --> 01:10:34.340
还是来进行这个分析

01:10:36.600 --> 01:10:38.960
好,首先的话这边两个settimeout

01:10:39.220 --> 01:10:42.020
所以这边就是一个什么呢,就是一个timeout队列

01:10:42.280 --> 01:10:44.020
好,timeout队列,然后接下来的话

01:10:44.280 --> 01:10:45.860
首先这个settimeout

01:10:46.900 --> 01:10:47.400
1

01:10:48.120 --> 01:10:50.420
对吧,放进去,让settimeout2

01:10:50.680 --> 01:10:51.360
放进去

01:10:51.620 --> 01:10:56.320
好,完事之后,然后接下来也没有其他的队列了,那我接下来先就执行这个timeout队列

01:10:56.580 --> 01:10:59.900
settimeout1,首先是不是打印出这个timeout1

01:11:00.160 --> 01:11:00.660
对不对

01:11:00.920 --> 01:11:02.720
首先是打印出

01:11:04.500 --> 01:11:05.780
timeout1

01:11:06.300 --> 01:11:08.600
好,完事之后,然后加这个promise

01:11:08.860 --> 01:11:11.420
它是不是会被放到这个wizern队列

01:11:11.920 --> 01:11:15.780
对不对,让我下面这个同样也是会被放入到wizern队列

01:11:16.760 --> 01:11:18.560
接下来就是这个wizern

01:11:20.630 --> 01:11:21.390
wizern队列

01:11:21.650 --> 01:11:24.470
好,我这个的话会被放入到wizern队列

01:11:25.750 --> 01:11:27.790
然后接下来这个lextick

01:11:28.310 --> 01:11:30.610
所以也会被放入到wizern队列

01:11:30.870 --> 01:11:33.930
好,那接下来我整个settimeout1

01:11:34.450 --> 01:11:35.470
是不是就执行完了

01:11:35.730 --> 01:11:38.030
对不对,执行完了之后

01:11:38.790 --> 01:11:40.330
wizern队里面是不是有东西了

01:11:40.590 --> 01:11:43.150
有东西,然后叫先清空wizern队

01:11:43.410 --> 01:11:44.430
那这边的话就是

01:11:44.690 --> 01:11:46.990
lextick优先级更高一些

01:11:47.310 --> 01:11:49.090
说这边是先打印出什么呢

01:11:49.350 --> 01:11:50.990
先打印出lextick

01:11:51.250 --> 01:11:53.710
再打印出promise1

01:11:56.420 --> 01:11:57.180
看到没有

01:11:57.440 --> 01:11:59.240
好,接下来完事之后

01:11:59.500 --> 01:12:02.560
接下来执行什么呢,现在wizern队列就清空了

01:12:02.820 --> 01:12:05.640
清空了,接下来这边首先打印出timeout2

01:12:05.880 --> 01:12:06.920
然后加promise2

01:12:07.180 --> 01:12:08.700
对吧,好,这个就不错了

01:12:08.960 --> 01:12:11.780
这边就是timeout2

01:12:12.040 --> 01:12:15.120
然后promise2

01:12:16.140 --> 01:12:16.760
看到没有

01:12:17.020 --> 01:12:19.200
好,那接下来我们来看一下是不是这样子的

01:12:19.460 --> 01:12:21.560
load index,走

01:12:22.580 --> 01:12:25.400
timeout1,lextick,promise1

01:12:25.660 --> 01:12:27.180
timeout2,promise2

01:12:28.460 --> 01:12:28.980
看到没有

01:12:29.500 --> 01:12:30.260
是不是这样子的

01:12:30.780 --> 01:12:32.300
说这边的话就证明了什么呢

01:12:32.560 --> 01:12:34.100
证明了我们的这个

01:12:34.360 --> 01:12:35.380
lextick

01:12:35.900 --> 01:12:37.300
它要比这个promise

01:12:37.540 --> 01:12:39.220
它的优先级要高一些

01:12:39.480 --> 01:12:40.760
这是就是

01:12:41.020 --> 01:12:42.040
这么两个注意点

01:12:43.580 --> 01:12:45.620
好,最后就是总结一下就是

01:12:45.880 --> 01:12:47.660
load接使和事件

01:12:47.860 --> 01:12:49.400
和这个浏览器

01:12:49.660 --> 01:12:51.200
它的这个事件队列

01:12:51.460 --> 01:12:52.980
应该叫做事件队列

01:12:54.280 --> 01:12:55.040
的差异

01:12:55.540 --> 01:12:58.360
那这个浏览器,浏览器的话是不是就两个队列

01:12:58.620 --> 01:12:59.900
浏览器环境下

01:13:00.660 --> 01:13:01.180
就

01:13:01.940 --> 01:13:03.480
两个队列

01:13:04.500 --> 01:13:06.040
两个队列

01:13:06.300 --> 01:13:08.600
一个什么呢,一个红任务

01:13:09.380 --> 01:13:09.880
队列

01:13:10.140 --> 01:13:10.900
一个

01:13:11.160 --> 01:13:12.440
微任务

01:13:13.220 --> 01:13:13.720
队列

01:13:14.240 --> 01:13:14.740
对吧

01:13:14.940 --> 01:13:18.280
然后微任务对这个微任务的这个任务队列

01:13:18.540 --> 01:13:20.880
是在每个红任务执行完后

01:13:21.140 --> 01:13:21.640
执行

01:13:22.160 --> 01:13:25.240
对吧,我一个红任务执行完了,那这样我叫取一个微任务

01:13:25.500 --> 01:13:29.340
不是取一个微任务,就是把这个微任务任务队列全部清空

01:13:29.600 --> 01:13:30.860
那再执行下一个

01:13:31.120 --> 01:13:31.900
红任务

01:13:32.400 --> 01:13:32.900
对不对

01:13:33.160 --> 01:13:34.700
然后接下来在load接使中

01:13:34.960 --> 01:13:37.780
微任务的话是在事件循环各个

01:13:38.040 --> 01:13:39.560
阶段之间执行的

01:13:39.820 --> 01:13:42.120
也就是说一个阶段执行完毕

01:13:42.380 --> 01:13:44.180
就会去执行这个微任务队列

01:13:44.380 --> 01:13:45.920
这个描述其实不太准确

01:13:46.180 --> 01:13:47.200
这边让我们把它改一下

01:13:47.460 --> 01:13:49.260
就是这个load接使中

01:13:51.040 --> 01:13:52.060
就是每个阶段

01:13:53.860 --> 01:13:54.640
每个

01:13:55.140 --> 01:13:58.460
阶段的每个任务

01:13:58.980 --> 01:14:01.800
执行完毕之后

01:14:02.560 --> 01:14:04.360
就会

01:14:04.620 --> 01:14:05.640
清空

01:14:06.400 --> 01:14:07.940
这个微任务

01:14:09.480 --> 01:14:09.980
队列

01:14:10.500 --> 01:14:11.520
应该是这个样子

01:14:12.300 --> 01:14:14.080
对不对,因为我有很多个任务队列吗

01:14:14.180 --> 01:14:16.220
这边就是每个任务队列

01:14:16.480 --> 01:14:17.500
每个

01:14:17.760 --> 01:14:18.540
任务

01:14:18.800 --> 01:14:19.300
队列

01:14:19.820 --> 01:14:23.900
因为在load的环境中,它是不是一共有这么多个任务队列

01:14:24.160 --> 01:14:29.540
对不对,每个任务队列的每个任务执行完毕之后,就会清空这个微任务队列

01:14:29.800 --> 01:14:30.820
比如我们刚才看这里

01:14:31.340 --> 01:14:32.620
这里就是一个很明显的

01:14:32.880 --> 01:14:34.660
这边set timeout set timeout

01:14:34.920 --> 01:14:35.680
是不是都是

01:14:36.200 --> 01:14:37.480
进入这个timeout队列

01:14:37.980 --> 01:14:39.780
对不对,它是timeout队列里面的两个任务

01:14:40.040 --> 01:14:42.080
让我这边的话我只要这个

01:14:43.060 --> 01:14:45.100
只要这个timeout

01:14:45.360 --> 01:14:48.180
执行完了,那接下来我就会去清空

01:14:48.440 --> 01:14:49.200
微任务队列

01:14:49.460 --> 01:14:49.960
对不对

01:14:50.480 --> 01:14:51.760
这是关于这个

01:14:52.260 --> 01:14:56.360
load的阶矢,它与浏览器事件对列了一个差异

01:14:56.620 --> 01:14:57.140
OK

01:14:57.900 --> 01:15:01.480
最后的话是关于这个整体解答

01:15:01.740 --> 01:15:04.560
然后总结一下load的阶矢中事件循环

01:15:04.820 --> 01:15:06.600
和浏览器有什么不同

01:15:06.860 --> 01:15:09.160
那我们load的话是不是就分为六个阶段

01:15:09.380 --> 01:15:12.440
对不对,每个阶段的话你把它自己把它总结一下

01:15:12.700 --> 01:15:16.280
然后接下来浏览器和load的阶矢

01:15:18.080 --> 01:15:19.620
load的端你就把这句话

01:15:20.120 --> 01:15:21.140
在load中

01:15:23.680 --> 01:15:24.700
在load中

01:15:24.960 --> 01:15:25.720
就这句话

01:15:26.480 --> 01:15:27.260
前面就不要了

01:15:29.040 --> 01:15:30.600
然后在浏览器中

01:15:30.840 --> 01:15:32.640
浏览器中是这个

01:15:33.400 --> 01:15:33.920
对吧

01:15:36.560 --> 01:15:37.080
OK

01:15:37.340 --> 01:15:39.120
但这个是鄙视的时候

01:15:39.380 --> 01:15:41.940
鄙视的时候你可以这样子写下,如果是面试

01:15:42.360 --> 01:15:44.880
就是那种口头面试官问你的时候

01:15:45.140 --> 01:15:47.520
那你就可以给他详细的展开说一说

01:15:47.780 --> 01:15:49.580
就不要只回答两句话就完了

01:15:49.840 --> 01:15:51.360
对吧,详细给他说一下

01:15:51.620 --> 01:15:53.420
比如说浏览器

01:15:53.680 --> 01:15:55.960
一个是红任务对列,一个是微任务对列

01:15:56.220 --> 01:15:59.300
哪些进入微任务,哪些进入红任务

01:15:59.560 --> 01:16:00.060
对不对

01:16:00.320 --> 01:16:02.880
面试的时候尽量给面试官多说一点

01:16:03.400 --> 01:16:04.920
不要一个问题

01:16:05.180 --> 01:16:08.000
人家问你,然后你一秒钟就回答完了

01:16:08.260 --> 01:16:09.800
对吧,尽量一个问题能够回答

01:16:10.060 --> 01:16:11.320
到一两分钟

01:16:11.540 --> 01:16:14.340
那这个面试官对你的印象是比较好的

01:16:15.620 --> 01:16:18.700
好,这是关于这个整个这个事件循环

01:16:18.960 --> 01:16:20.740
大家下来的话把这个这个部分

01:16:21.260 --> 01:16:22.540
再把它看一下

01:16:22.800 --> 01:16:24.840
这个部分确实比较偏理论

01:16:25.100 --> 01:16:26.640
平时写代码你用不到

01:16:27.140 --> 01:16:28.180
写代码是用不到的

01:16:28.440 --> 01:16:29.440
比较偏理论

01:16:29.960 --> 01:16:30.480
但是呢

01:16:30.740 --> 01:16:33.800
你知道的话他主要就是什么,主要就是面试的时候爱问

01:16:34.560 --> 01:16:35.080
好吧

01:16:35.340 --> 01:16:37.900
好,这节课的话就先到这里,再见

