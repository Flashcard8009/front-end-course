WEBVTT

00:01.010 --> 00:03.050
大家好 我是谢老师

00:03.310 --> 00:08.430
这节课的话我们来看一下就是关于JES中浮点数精度的问题

00:08.690 --> 00:10.730
其实浮点数精度的话

00:10.990 --> 00:12.790
不是说只有JES里面采用

00:13.050 --> 00:18.170
凡是采用了IEE 754标准的语言

00:18.430 --> 00:21.490
它都会存在浮点数精度问题

00:21.750 --> 00:25.070
具体是什么问题 我们一点点来看

00:25.590 --> 00:28.410
首先的话这边有一道题

00:28.410 --> 00:33.790
为什么Consol.log0.2加0.1等于这个0.3

00:34.050 --> 00:35.830
得到的值是False

00:36.350 --> 00:38.910
那这个的话可能好多同学都没注意到过

00:39.170 --> 00:40.450
那我们这边我们来看一下

00:41.210 --> 00:41.970
这边

00:42.750 --> 00:44.530
比如说我们这边log

00:45.810 --> 00:49.650
0.1加上一个0.2

00:51.190 --> 00:53.490
然后走

00:54.270 --> 00:56.050
你会发现这边打印出来的是多少

00:56.770 --> 00:59.370
0.30004004

00:59.890 --> 01:00.650
看到没有

01:00.910 --> 01:02.950
它就不像我们想象的就是

01:03.210 --> 01:04.750
算出来应该是0.3

01:05.010 --> 01:06.030
但是它这边的话

01:06.290 --> 01:08.070
得出来的是什么呢 是0.3

01:08.330 --> 01:10.130
然后0004004

01:10.650 --> 01:12.690
那自然而然你这边的话

01:13.710 --> 01:14.470
你让它

01:14.730 --> 01:16.790
判断它是否等于0.3

01:17.050 --> 01:18.830
它自然而然肯定得出的是什么

01:19.350 --> 01:20.370
是不是False

01:20.890 --> 01:23.190
对不对 因为你得出的是这个值

01:23.910 --> 01:26.210
那为什么它得出的是这个值呢

01:26.470 --> 01:29.030
原因很简单 那就是因为我们的浮点数

01:29.290 --> 01:30.050
它精度

01:30.310 --> 01:31.070
有问题

01:31.590 --> 01:33.130
那它具体有什么样的问题呢

01:33.390 --> 01:34.410
我们这边我们来看一下

01:35.690 --> 01:40.290
在Jet中 整数和浮点数都属于Lumber数据类型

01:40.550 --> 01:41.830
这个大家是知道的

01:42.090 --> 01:43.370
对吧 它不像其他语言

01:43.630 --> 01:46.690
比如像Java,Java的话整形是int

01:47.210 --> 01:49.510
然后浮点形有Float double

01:49.770 --> 01:50.790
但是在Jet里面

01:51.050 --> 01:52.570
它都属于这个Lumber

01:52.950 --> 01:57.390
都是以什么呢 都是以64位浮点数的形式来存储的

01:57.890 --> 02:00.970
所以当你打印这个比如说1.00的时候

02:01.230 --> 02:02.510
结果是什么呢 是1

02:02.770 --> 02:04.290
而不是这个1.00

02:04.550 --> 02:05.570
你这边可以看一下

02:07.400 --> 02:08.680
不用我们这边log

02:09.960 --> 02:11.240
1.00

02:11.760 --> 02:13.280
那我本来是想打印一个什么

02:13.540 --> 02:14.320
是浮点数

02:14.820 --> 02:16.620
但是你这边的话打印出来是多少

02:16.880 --> 02:18.160
是不是打印出来是1啊

02:18.920 --> 02:19.420
看到没有

02:19.680 --> 02:20.460
打印出来是1

02:21.440 --> 02:23.240
好 它还有一些什么样的问题呢

02:23.480 --> 02:24.200
我们来看一下

02:24.460 --> 02:27.840
首先第一个就是浮点数运算结果的判断

02:28.100 --> 02:30.400
比如你看这边Java 这个干什么已经看了

02:30.920 --> 02:31.420
对不对

02:31.680 --> 02:35.780
得到的是这个 还有些其他的比较0.7加0.1

02:36.040 --> 02:37.060
得到的是这么多

02:37.320 --> 02:39.100
0.2加0.4

02:39.360 --> 02:40.500
得到是这么多

02:40.760 --> 02:42.680
这边大家可以看一下 我把这个

02:43.200 --> 02:44.220
拿过来

02:47.380 --> 02:48.160
把这个注射掉

02:48.920 --> 02:51.740
把拿过来 我们来看 来验证一下是不是

02:53.080 --> 02:53.580
这边

02:56.500 --> 02:57.000
看到没有

02:57.520 --> 02:58.680
是不是都不精准

02:59.160 --> 03:01.860
这个我们数学里面计算出来是不是0.3

03:02.120 --> 03:04.040
这个是0.8 这个是0.6

03:04.300 --> 03:06.220
你会发现它是不是要么多一点

03:06.480 --> 03:08.140
比如像这个 这个是不是要么多一点

03:08.380 --> 03:09.040
要么什么呀

03:09.300 --> 03:10.060
是不是少一点

03:10.560 --> 03:12.880
对不对 也就是说在Java里面 它那个浮点数

03:13.140 --> 03:13.900
是没办法

03:14.160 --> 03:15.440
精确计算的

03:15.700 --> 03:17.220
这是第一个问题

03:17.480 --> 03:18.500
就是我们浮点数

03:18.760 --> 03:20.300
没办法精确计算

03:20.820 --> 03:21.840
好 比较场景2

03:22.820 --> 03:26.660
将小数乘以10的n四方取整

03:26.920 --> 03:28.460
比如这种是什么场景呢

03:28.460 --> 03:30.240
比如我们经常这个前臂的单位

03:30.500 --> 03:31.260
你从圆

03:31.780 --> 03:33.060
转成这个分

03:33.320 --> 03:34.720
那你经常写出来就是什么

03:34.980 --> 03:36.500
这个圆成一个这个

03:36.760 --> 03:37.260
100

03:37.920 --> 03:38.420
对不对

03:38.680 --> 03:39.720
圆成一个100

03:39.960 --> 03:41.760
因为你这个一圆就是十角

03:42.020 --> 03:43.560
一角是10分

03:43.820 --> 03:45.600
那这边是不是应该是圆成一个100

03:45.860 --> 03:47.900
那加后面这个代表这个镜子

03:49.180 --> 03:50.460
那你这边的话 比如说我们这边

03:51.080 --> 03:52.460
0.58元

03:53.220 --> 03:55.460
0.58元照理说是不是就是

03:56.800 --> 03:57.580
58分

03:58.100 --> 03:59.880
对不对 58分 那乘以一个100

03:59.880 --> 04:01.160
但是得到的是57

04:01.420 --> 04:02.440
你这边可以看一下

04:05.600 --> 04:06.640
比如说我们这边

04:06.900 --> 04:07.920
把上面的注射掉

04:14.600 --> 04:15.120
然后

04:18.740 --> 04:19.240
走

04:20.000 --> 04:20.260
看不看

04:20.780 --> 04:21.540
它不是58

04:21.800 --> 04:22.460
而是多少呢

04:22.720 --> 04:23.840
而是57

04:24.100 --> 04:25.380
是不是又是一个轻度问题

04:26.140 --> 04:26.660
看不看

04:27.420 --> 04:28.460
再比如说

04:28.980 --> 04:30.060
再比如说这里

04:30.260 --> 04:32.580
四蛇五入保留这个N位

04:32.840 --> 04:35.900
比如说我们知道这个Lumber它有个方法叫做to fixed

04:36.660 --> 04:37.940
它是不是可以就是

04:38.200 --> 04:40.760
就是你这个保留几位小数

04:41.540 --> 04:42.040
对吧

04:42.300 --> 04:45.120
但是你看这边 比如说我这边1.335

04:45.620 --> 04:48.440
然后保留两位 保留两位照理说应该是1.34

04:49.220 --> 04:52.280
对不对 但是你得出的是多少呢 得出的是1.33

04:52.540 --> 04:53.820
把这个镜子也看一下

04:56.860 --> 04:57.900
把这个注射掉

04:59.680 --> 05:00.700
好 这边走

05:01.620 --> 05:03.580
是不是1.33 而且你注射它是个制服串

05:04.320 --> 05:08.080
它是个制服串 你不信的话 你可以去查一下这个to fixed

05:08.340 --> 05:10.120
它返回的是一个制服串

05:10.380 --> 05:12.680
而不是数字 你看数字的颜色是不是都不一样

05:14.220 --> 05:14.980
这是黄色

05:15.240 --> 05:16.020
这是不是白色

05:16.780 --> 05:18.580
对不对 代表它是制服串

05:19.860 --> 05:21.380
好 那为什么会有

05:21.640 --> 05:22.420
这些问题呢

05:22.680 --> 05:26.500
上面其实这些问题啊 这边列举了这么几个场景 场景1

05:26.760 --> 05:27.660
场景2

05:27.860 --> 05:30.940
场景3 列举了这么几个问题 其实就想说明一个问题

05:31.700 --> 05:34.780
什么问题 就是你浮点数 是不是它存在精度问题

05:35.300 --> 05:36.300
没办法

05:36.820 --> 05:38.260
是不精准的进行计算

05:39.140 --> 05:41.180
对不对 主要就想说明这个问题

05:41.440 --> 05:43.060
那为什么会有这样的问题呢

05:43.320 --> 05:44.260
我们来看一下

05:45.540 --> 05:48.340
究竟是什么原因 导致这个精度丢失呢

05:48.600 --> 05:49.880
其实是这个样子的

05:50.400 --> 05:52.700
就是我们计算机底层

05:52.960 --> 05:54.240
它只有零合一

05:55.260 --> 05:56.280
这个大家应该是知道的

05:57.260 --> 05:59.040
所以所有的这个运算

05:59.300 --> 06:01.900
那最后都是什么呢 都是做二净值的运算

06:02.160 --> 06:04.740
无论你什么数 我不管你是什么数

06:05.000 --> 06:06.780
我最终我要先把你干嘛呀

06:07.040 --> 06:09.340
我先把你转成二净值

06:10.880 --> 06:14.460
可不可以啊 先转成二净值 转成二净值之后 然后接下来

06:14.720 --> 06:16.260
再来做这个计算

06:17.020 --> 06:20.340
好 那我们十净值 十净值的话转二净值 很简单

06:20.600 --> 06:21.880
就直接这个相处

06:22.400 --> 06:24.700
相处你不停的处于这个二

06:25.160 --> 06:26.440
然后接下来取于数

06:26.700 --> 06:29.260
它就是一个二净值 但是我们浮炼数呢

06:29.520 --> 06:30.540
浮炼数怎么表示呢

06:30.800 --> 06:31.820
我们来看一下

06:33.360 --> 06:36.420
这里的话举了个例子 但这个的话是

06:36.680 --> 06:37.960
C元的例子

06:38.220 --> 06:40.780
就是我们这边首先要了解清楚

06:41.040 --> 06:44.880
计算机浮炼数的表示方法 这里以这个

06:45.140 --> 06:45.900
C元为例

06:46.660 --> 06:47.940
C元的话它这边

06:48.200 --> 06:51.280
它这个浮炼数比我们以它的Float32位

06:51.740 --> 06:54.740
它的Float是32位的 我们那个接识它是多少位

06:55.000 --> 06:56.860
接识是不是十六四位的

06:57.120 --> 07:00.700
位数多一点 但其实道理是一样的 我们这边我们来看一下

07:03.520 --> 07:07.860
计算机的浮炼数是用这个I111754标准

07:08.120 --> 07:09.920
你记住这个标准的名字

07:10.180 --> 07:13.500
基本上来讲就所有的编程语言

07:13.760 --> 07:17.080
它要表示这个浮炼数都是采用的是

07:17.340 --> 07:18.120
这个标准

07:18.540 --> 07:22.940
说说所有的编程语言它都会存在这个浮炼数的精度问题

07:23.700 --> 07:26.100
那这个标准 这个标准具体说了个什么事呢

07:26.660 --> 07:30.100
这个标准的话它其实就是这边以32位为例

07:30.360 --> 07:34.460
它就是把这个32位分成了什么呢 分成了三段

07:35.980 --> 07:37.020
分成了三段

07:37.280 --> 07:38.020
第一段

07:38.500 --> 07:39.420
占一位

07:39.780 --> 07:41.380
表示什么呢 表示你的符号位

07:41.620 --> 07:43.160
带称为S

07:43.680 --> 07:44.340
第二段

07:44.580 --> 07:45.980
是这个占八位

07:46.240 --> 07:48.020
它代表就是你的这个指数

07:48.840 --> 07:52.680
就决定了你这个数字具体的这个大小

07:52.940 --> 07:54.220
然后接下来第三段

07:54.480 --> 07:56.020
第三段占23位

07:56.280 --> 07:58.060
你看加起来是不是刚好32位

07:58.580 --> 07:59.080
对不对

07:59.340 --> 08:02.420
它代表什么呢 代表尾数也就是后面这这么多

08:03.180 --> 08:05.980
代表你的尾数也就是说你的这个小数部分

08:06.500 --> 08:08.300
用来表示你的小数部分

08:09.060 --> 08:10.600
说你一个这个小数

08:10.860 --> 08:13.420
它的计算公式其实是这样子计算出来的

08:14.180 --> 08:14.700
看到没有

08:14.960 --> 08:17.500
有一个这个很复杂的这个公式

08:18.580 --> 08:19.860
有这么一个这个公式

08:20.120 --> 08:21.900
而这个公式的话其实你不太

08:22.420 --> 08:24.740
不太需要去深究它

08:25.500 --> 08:26.260
不太需要去深究它

08:26.520 --> 08:28.060
但是你只需要知道什么呢

08:28.320 --> 08:29.600
我需要你知道的就是

08:29.860 --> 08:31.080
在计算机中

08:31.340 --> 08:32.300
它浮点数

08:32.560 --> 08:33.940
它是分成了这么三段

08:35.740 --> 08:37.280
看到没有 分成了这么三段

08:37.540 --> 08:40.860
然后接下来的话每一段有特殊的含义

08:41.120 --> 08:41.880
第一段

08:42.140 --> 08:42.900
表示符号

08:43.160 --> 08:43.920
第二段

08:44.180 --> 08:45.220
是代表指数

08:45.460 --> 08:47.780
第三段表示你的尾数

08:47.980 --> 08:48.700
你知道这个

08:48.960 --> 08:50.540
首先这个知识点你知道

08:50.800 --> 08:52.600
然后接下来这个小数的计算这个

08:52.860 --> 08:54.900
你知道有这么一个这个公式

08:55.660 --> 08:56.180
就可以了

08:56.700 --> 08:57.980
知道有这么一个公式

08:58.240 --> 08:59.760
那你看一下它的这个尾数

09:00.020 --> 09:02.840
尾数它是不是这边就只有这么23位

09:03.600 --> 09:03.860
对不对

09:04.120 --> 09:05.140
只有这么23位

09:05.660 --> 09:06.160
那有

09:06.420 --> 09:08.460
它既然这个位数它是有限制的

09:08.720 --> 09:09.740
那必然就会有什么呀

09:10.000 --> 09:11.040
就会有阶段

09:11.800 --> 09:14.100
对不对它不可能无限的进行一个表示

09:14.360 --> 09:16.400
但是我们数学里面比如我们的小数

09:16.600 --> 09:18.060
比如有些数 比如说

09:18.320 --> 09:19.420
元州率

09:19.680 --> 09:23.260
它是不是它可以无限的 对不对 3.1415926可以无限的

09:23.520 --> 09:24.540
那个小数部分

09:24.800 --> 09:26.080
那我这个我没办法呀

09:26.600 --> 09:29.400
对不对 我没那么多位数来表示你那个

09:30.180 --> 09:33.500
来表示你的小数部分 那我必然就是什么呢 我会给你阶段

09:33.760 --> 09:35.300
那我既然会给你阶段

09:35.560 --> 09:37.080
那必然就会产生什么呢

09:37.340 --> 09:38.380
产生这个

09:39.140 --> 09:39.900
这个

09:40.160 --> 09:40.680
精度的问题

09:41.440 --> 09:41.940
对不对

09:42.980 --> 09:44.000
好我们继续往下面看

09:44.720 --> 09:47.020
那上面是以这个32位为例

09:47.280 --> 09:50.600
那这个在接识里面 接识的时候它是这个64位

09:50.860 --> 09:52.400
64位的话基本上就是

09:52.660 --> 09:53.940
首先第一位是不变的

09:54.200 --> 09:55.980
第一位仍然是什么呢 仍然是

09:56.240 --> 09:56.740
符号位

09:57.260 --> 09:59.320
0代表正数1代表附数

09:59.820 --> 10:01.100
好 然后接下来的话

10:01.860 --> 10:03.660
这的话就变成了11位

10:03.920 --> 10:05.700
刚才上面是8位吗

10:05.960 --> 10:07.240
这边就变成了11位

10:07.500 --> 10:08.780
好 然后接下来的话这边

10:09.040 --> 10:11.600
尾数部分 尾数部分就变成了52位

10:11.860 --> 10:13.140
刚才是23位

10:13.340 --> 10:15.140
这个的话 位数就要多一些

10:15.400 --> 10:17.440
位数多一些的话 它精度就要高一些

10:17.700 --> 10:18.220
但是呢

10:18.480 --> 10:20.820
它也不是说能够精确的表示

10:21.060 --> 10:21.540
符点数

10:24.100 --> 10:25.380
好 那我们这边我们来看一下

10:25.640 --> 10:27.420
这里写了 既然

10:27.680 --> 10:28.960
你限定了位数

10:29.220 --> 10:31.260
那必然它就有阶段的这个可能

10:31.520 --> 10:32.800
那比如我们举个例子

10:33.820 --> 10:37.680
比如说这边0.1加0.2 它为什么就得到了

10:39.460 --> 10:41.260
它为什么就得到这个值呢

10:41.820 --> 10:44.220
那首先的话 我们这边就需要把这个数

10:44.980 --> 10:45.820
转称什么呢

10:46.080 --> 10:47.620
转称一个二净子

10:47.880 --> 10:49.660
然后接下来把这个数

10:50.180 --> 10:51.580
转称一个二净子

10:51.840 --> 10:53.760
然后二净子和二净子

10:54.260 --> 10:55.540
进行一个计算

10:55.800 --> 10:57.340
然后最后再把那个二净子

10:57.600 --> 10:58.620
再把它转换回来

10:59.380 --> 11:00.420
那我们举个例子

11:01.440 --> 11:03.220
比如说我们要将这个0.1

11:03.740 --> 11:05.020
我们要转这个二净子

11:05.540 --> 11:08.460
整数的话我们是除二取

11:08.980 --> 11:10.900
除二取 这个大家应该是知道吧

11:11.300 --> 11:12.260
就是这边

11:12.700 --> 11:13.980
这边这个净子的转换

11:13.980 --> 11:15.740
不知道的话你可以下去看一下

11:16.740 --> 11:17.740
就是

11:18.180 --> 11:20.540
这个都是属于基础知识了

11:21.700 --> 11:24.260
就这个比如说我普通的一个十净子

11:25.940 --> 11:28.140
十净子 比较这边150

11:28.500 --> 11:30.660
150我要把它转成二净子怎么办

11:30.660 --> 11:32.900
就除二取 除以二

11:33.140 --> 11:35.020
得到75 是不是余数为零

11:35.260 --> 11:36.140
再除以二

11:36.420 --> 11:38.140
得到37 余数是1

11:38.140 --> 11:39.060
再除以二

11:39.260 --> 11:40.900
除二取 直到什么呢

11:40.940 --> 11:41.820
直到这个3

11:42.060 --> 11:42.660
是零

11:42.900 --> 11:44.700
然后接下来把它的余数倒过来

11:45.460 --> 11:47.500
把它余数倒过来 倒过来就是这个

11:47.780 --> 11:48.780
就是它的二净子

11:49.060 --> 11:50.180
这个是整数

11:50.820 --> 11:52.540
好 那接下来我们这边的小数

11:52.540 --> 11:53.700
小数的话我们这边可以

11:53.940 --> 11:54.860
乘二

11:55.180 --> 11:56.380
乘二取整

11:56.820 --> 11:57.940
比如我们这边我们来看一下

11:58.220 --> 11:59.140
0.1乘以二

11:59.380 --> 12:00.540
直是0.2

12:00.780 --> 12:02.540
小数部分是比也是0.2

12:02.820 --> 12:05.180
对不对 然后整数部分为零

12:05.620 --> 12:07.420
OK 接下来的话那你这边

12:07.700 --> 12:10.180
小数部分是0.2 那接下来这个0.2

12:10.340 --> 12:11.460
就再来乘以二

12:11.700 --> 12:14.540
然后得到0.4 小数部分是0.4

12:14.780 --> 12:16.060
整数是零

12:16.340 --> 12:19.140
然后0.4再乘以0.2 得到0.8

12:19.380 --> 12:21.940
小数部分是0.8 整数是零

12:22.220 --> 12:23.500
好 接下来这边

12:24.020 --> 12:25.540
0.8再乘以二

12:26.060 --> 12:27.060
这不得到1.6

12:27.580 --> 12:29.620
1.6小数部分是0.6

12:29.620 --> 12:32.180
整数部分你注意 整数部分是不变成一了

12:32.460 --> 12:32.980
对不对

12:33.220 --> 12:34.500
小数部分是0.6

12:34.740 --> 12:36.820
好 再加0.6再乘以个二

12:37.300 --> 12:38.860
这不得到1.2

12:39.320 --> 12:41.120
然后小数部分是0.2

12:41.380 --> 12:42.640
然后接下来整数部分是一

12:42.900 --> 12:44.960
你看从这开始小数部分就又是多少了

12:45.220 --> 12:45.980
是不是0.2

12:46.500 --> 12:48.280
是不是回到哪里了 是不是回到这一步了

12:48.800 --> 12:50.080
他就是一个无线循环

12:51.100 --> 12:53.400
对不对 从0.2开始他就开始无线了这个

12:53.660 --> 12:54.680
进行一个循环

12:54.940 --> 12:59.300
所以你0.1转成二进字就是说多少呢 就是0.

12:59.540 --> 13:00.060
这边

13:00.320 --> 13:02.100
0 0 0

13:02.360 --> 13:04.660
1 1 0 你看这边 是不是

13:04.920 --> 13:06.720
0 0 0

13:07.180 --> 13:09.900
1 1 0 是不是到这个位置啊

13:10.500 --> 13:13.200
对不对 是不是到这个位置啊 到这个位置然后接下来

13:13.460 --> 13:14.860
从0.2开始

13:16.140 --> 13:18.200
0.2开始的话 他这边又是多少

13:18.700 --> 13:20.700
所以你再乘以一个二 是不是0.4啊

13:20.960 --> 13:22.540
对不对 那就接下来的话

13:23.460 --> 13:24.580
就应该是

13:25.100 --> 13:30.220
0.2乘以一个0.4 那这边的话就应该是

13:30.980 --> 13:31.760
0

13:32.020 --> 13:33.820
1 1 0

13:34.800 --> 13:39.400
对不对 0.1 1 0 然后后面就一直是0.1 1 0 0 1 1 0 你看下这边

13:39.920 --> 13:41.400
0 0 0

13:41.660 --> 13:46.060
1 1 0 然后后面就一直是0.1 1 0

13:46.320 --> 13:50.160
完了之后他就要又循环 0.1 1 0

13:50.420 --> 13:52.460
0.1 1 0

13:52.720 --> 13:55.780
他就是无线这样子循环 但我不可能无线的这样子存储吧

13:56.300 --> 13:58.100
对不对 我这边只能存多少个

13:58.600 --> 13:59.640
这不只能存

13:59.880 --> 14:00.640
52个

14:01.160 --> 14:02.700
对不对 那我就会给你截断

14:03.000 --> 14:04.180
我会给你截断

14:05.460 --> 14:09.560
然后0.2 0.2转出来也是一样的 也是一个无线循环

14:10.080 --> 14:13.660
所以你把两个加起来 加起来的话最终得到的就是这个字

14:15.420 --> 14:17.500
看到没有 他就是二进之相加嘛

14:18.020 --> 14:23.140
得到的就是这个字 这个字要将你再把它转成十进字 所以他就约等于

14:23.400 --> 14:25.700
0.3 0 0 0 0 0 4

14:26.460 --> 14:30.040
就这么简单 看到没有 就是因为你的这个

14:31.020 --> 14:36.040
伏点数 你这个转成二进字他是无线的 无线的让我在我的那个

14:36.520 --> 14:40.040
在这边存储的时候 在这边存储的时候 我只有这么多位

14:40.600 --> 14:42.800
啊 只有这么多个格子 拿给你存

14:43.560 --> 14:48.840
对不对 那我就只有就是超出的部分我就干嘛呢 你看 超出的部分是不是自动进一设定

14:49.640 --> 14:52.560
对不对 我会有一个这个截断的这个操作

14:53.640 --> 14:57.080
那既然我有一个截断的操作 那这边的话 这肯定就不可能

14:57.520 --> 14:59.160
精确的进行一个保存

15:00.240 --> 15:01.320
对不对啊

15:03.000 --> 15:10.680
好 再比如说 再比如说比如说你这边console.log 1.335 to fix2 为什么得到是1.33

15:11.280 --> 15:17.640
其实到底是一样的 他把这个1.335首先进行一个这个二进字的转换 转出来是多少呢

15:19.200 --> 15:22.760
转出来是1.334999啊 反正这么多

15:23.440 --> 15:27.440
那你看这边 这边那是不是1.334呀 他有没有到1.335

15:28.200 --> 15:37.160
这没有 对不对 那你这边的话 to fix的 那这边是不是就舍去了 舍去说他得到的是什么呢 得到的是1.33

15:39.680 --> 15:45.360
啊 包括什么呢 包括我们的这个整数 整数他同样存在这个精度问题

15:46.120 --> 15:46.960
啊 比如说你看这边

15:48.120 --> 15:51.520
比如打印这个 我这两行带帮我们拿过来看一下

15:55.990 --> 16:06.310
啊 这边这边都是打印1957199啊 这么多 对吧 打印出来是你看 后面的话我明明是991 这边变成多少 是不是990啊 包括这个

16:08.070 --> 16:11.270
这边的0991是否等于0992

16:12.190 --> 16:13.110
好 我们来看一下

16:14.190 --> 16:22.270
看了没有 是不是去啊 对不对 为什么 为什么整数也有问题啊 原因很简单 我们说过 在那个结实中

16:22.670 --> 16:28.270
他的Lumber全部都是按照什么来处理的 都是按照辅典数来处理的

16:28.910 --> 16:35.910
说你整数他也是按辅典数来存的 那么他自然而然也会存在什么 这不也会存在这个精度问题

16:37.390 --> 16:40.750
啊 那你整数整数那最大是多少位呢 最大是54位

16:41.470 --> 16:45.910
啊 那你最大值就是2的53次方减1 最小就是负的

16:46.390 --> 16:50.830
这个2的53次方减1 那只要你超过了这个范围

16:51.350 --> 16:56.270
那他必然就会存在什么呢 就是精度的这个问题 他就会把有些

16:57.150 --> 17:01.990
精度给你舍去啊 说就是会出现上面的这个结果

17:03.030 --> 17:07.230
所以你面试的时候他比如他问你啊 有这边为什么这个整数

17:08.030 --> 17:13.630
他也会存在这个精度问题 其实原因就是什么 原因的话是不是因为你的这个整数

17:14.590 --> 17:16.030
他也是按照辅典数

17:16.790 --> 17:25.870
是不是来进行处理的 对不对 他考你的话他只会考你就是你知不知道为什么啊 他不会考你 比如说不会考你这个这么难的这个公式的

17:27.710 --> 17:27.910
啊

17:29.710 --> 17:34.230
然后就这个问题的话并不只是这个结实种才会出现

17:34.750 --> 17:42.710
啊 几乎所有的编程语言他都是 只要你采用了这个 ii 745 这边写错了啊 ii 754我看看

17:44.070 --> 17:45.470
是 ii

17:46.790 --> 17:48.150
754啊 754

17:49.150 --> 17:55.110
这边 只要你是采用这个 ii 754 这个标准 那他就一定会存在这个问题

17:56.350 --> 18:00.430
只不过很多其他语言的话 他就是封装了一些这个方法

18:01.110 --> 18:08.830
来避免这个精度的问题 并且一般就是这种高精度的啊 用我们计算什么钱币啊 特别是金融方面的项目

18:09.430 --> 18:11.230
金融方面的项目对这个小数

18:11.830 --> 18:16.310
是不是这个要求非常高 对不对 那这种的话一般都是什么呢 都是交给后端

18:17.590 --> 18:22.830
啊 交给后端 后端的比如什么加娃啊 或者撇去屁啊 他们都有成熟的这种相应的这种库

18:23.390 --> 18:29.710
来进行处理啊 我们前端把这个数据拿到 然后显示出来就可以了啊 后端都有成熟的库

18:30.110 --> 18:32.990
来解决 那你如果非要在前端

18:33.870 --> 18:40.070
做这个转换啊 那怎么办啊 那这边的话我推荐你就是直接去使用相应的这个库

18:42.190 --> 18:47.350
直接使用相应的库就可以了 比如这边的话 推荐有这么几个库啊 比如这个mess

18:48.310 --> 18:52.510
mess.s 点节奢 它是专门为这个节奢

18:53.630 --> 19:00.230
和load.s提供的这个数学库啊 就是它可以在load里面用啊 浏览器里面也可以用啊

19:01.990 --> 19:04.870
啊 我看一下了 我看一下是不是浏览器里面可以用

19:05.870 --> 19:07.710
对面mess.js

19:12.760 --> 19:13.080
这边

19:15.120 --> 19:23.760
mess.js啊 它是一个mess library for javascript and load.js 啊 它官网就是这么介绍的啊 就这个

19:26.880 --> 19:30.000
还说我这个叫mess.js org

19:31.320 --> 19:33.720
mess.js.org

19:34.520 --> 19:34.720
这个

19:36.440 --> 19:39.640
好 我看一下打的开报应该打的开啊 这边

19:41.720 --> 19:50.000
for javascript and load.js啊 然后提供了一些就是这个大型的这个数的这个计算的这个支持

19:50.800 --> 19:54.920
看见没有啊 你这边就直接使用这个库就可以了啊

19:55.760 --> 20:06.080
啊 还有就是其他的比如这个dismal.js 啊 或者这个big.js 都是一些就是关于这个节奢中处理这个浮炼数的这个

20:06.480 --> 20:11.800
库啊 直接使用这个库啊 就不要自己去写 你自己去写的话也容易写错

20:12.560 --> 20:18.680
对不对 但是一般来讲的话在开发中的话 像这种精度问题啊 都是交给后端去处理的

20:19.640 --> 20:27.800
明白吧 因为后端的这个库更加成熟一些 前端的话一般就是我们拿到这个数 我们就是进行一个展示就可以了

20:29.200 --> 20:32.880
啊 这就是关于这个节奢中啊 这个浮炼数精度的这个问题

20:33.600 --> 20:38.480
好 回到我们再来看这道题啊 为什么得到的值是false 你看他问其实问的都很浅

20:39.440 --> 20:43.120
对不对 他问的很浅 他其实就是想问你知不知道这个精度问题

20:43.880 --> 20:50.320
啊 那为什么 那原因很简单 是不是就是浮炼数存在这个精度问题啊 他英语叫做round off

20:51.040 --> 20:51.880
啊 精度问题

20:53.080 --> 21:01.600
不能够进行精确的计算啊 然后你把这么几个点把它打出来 哪几个点了 首先他采用了这个ie754

21:02.080 --> 21:08.400
标准 他看你知不知道这个规范啊 第二个就是什么 第二个就是在节奢中所有的这个数

21:08.840 --> 21:13.840
都是什么呢 都是以这个浮炼数的形式来称出的 就哪怕你是整数

21:14.680 --> 21:21.160
啊 哪怕是整数啊 这是第二点你就把它达到 第三点就是什么呢 第三点就是如果他还要这个问的话你就说这个

21:21.760 --> 21:26.760
浮炼数他六十四位分成了这个三段 对不对 每一段他是干什么的

21:27.240 --> 21:32.280
再把这一点打到 那基本上就非常ok了 好吧 好

21:33.160 --> 21:42.120
这就是关于这个接时钟这个浮炼数精度的问题啊 下来的话大家自己再把它看一下 好 这期课就先到这里啊 再见

