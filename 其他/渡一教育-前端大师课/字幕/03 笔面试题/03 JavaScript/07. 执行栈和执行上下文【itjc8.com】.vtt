WEBVTT

00:00.880 --> 00:04.880
大家好 我是谢老师 这节课的话 我们来看一下这个

00:05.640 --> 00:13.960
呃 执行站以及执行上下文啊 这个的话是街市面试里面经常会被问到的问题啊 执行上下文是什么

00:14.280 --> 00:20.240
不要这道题 谈谈你对这个javascript中执行上下文的这个理解

00:20.840 --> 00:25.400
那我们这边的话 分为这么几个部分来讲 首先的话 介绍什么是执行上下文

00:25.960 --> 00:33.240
然后要解释一下什么是站 因为这边的话就是 我们标题都叫执行站 是吧 这边呢 也要介绍一下什么是站

00:33.800 --> 00:40.400
站的这种数据结构 然后接下来就是 关于我们这个执行上下文 它具体做什么事情

00:40.760 --> 00:43.520
啊 我们从这三个方面来进行介绍

00:44.280 --> 00:50.400
好 我们一个一个来看 首先第一个执行上下文 执行上下文的话英文全称叫做这个

00:51.080 --> 00:52.400
excusing context

00:53.240 --> 00:57.360
它翻译成中文 其实就是你看这个excusing 是不是就是执行的意思

00:57.880 --> 01:02.320
来加context context 它是这个内容 啊 这边呢 你翻译成上下文

01:02.920 --> 01:06.960
啊 所以这个翻译出来的话 也非常直接 就是执行上下文

01:07.520 --> 01:13.720
它什么意思呢 它指的是 代码执行前要进行的这个准备工作

01:14.640 --> 01:21.000
它需要创建那么一个环境啊 或者说创建一个上下文 必须有上下文

01:21.560 --> 01:25.960
才能执行代码 啊 当这里的代码包含什么呢 包含比如说全局代码

01:27.080 --> 01:29.560
全局代码 以及什么呢 我们的韩束代码

01:31.280 --> 01:36.480
可不可以啊 也就是说代码在执行之前 必须要有一个上下文环境

01:37.160 --> 01:44.120
有了上下文环境之后 然后接下来才开始执行代码啊 那这样我们继续往下面看

01:44.680 --> 01:51.560
而运行接下来马时啊 当代码执行进入到一个环境时 就会为该这个该环境

01:51.960 --> 01:59.480
创建一个执行上下文 对不对 比如说我现在要运行一个韩束啊 比如我这边举举个例子啊 比如我这边function

02:00.840 --> 02:01.400
function a

02:02.760 --> 02:07.560
ok 好 它是在这个执行的时候 比如说我这边调用的时候 它不是在定义的时候

02:08.120 --> 02:12.200
我这边只是定义了一个a 那这样我这边执行的时候 你看我这边是不是调用这个

02:12.760 --> 02:18.920
这个a这个韩束 当我调用的时候 然后接下来它就会干嘛呢 它就会先创建

02:20.680 --> 02:31.240
创建一个执行上下文 创建一个执行上下文环境 然后开始

02:33.240 --> 02:33.880
执行代码

02:34.840 --> 02:40.040
看到没有啊 比如说我们这边随便写一个啊 比如哇一个i等于一个10

02:42.200 --> 02:44.760
等于一个10 然后加这边log i

02:45.400 --> 02:48.840
好了 以前我们对这个韩束的调用的认识就是啊 你这边

02:49.560 --> 02:54.600
调用这个a韩束 调用这个a韩束的价 进到这里的价开始执行代码 一举一举的执行

02:54.920 --> 03:03.000
但其实在执行代码之前 它还有一个过程 什么过程呢 就是创建这个上下文环境

03:03.960 --> 03:06.440
明白没有 创建上下文环境

03:07.160 --> 03:14.120
好 那这样我们这边来看一下 好 我们这边首先来看一下在接识中执行环境啊 对应的有全局环境

03:15.080 --> 03:21.400
韩束环境 以及还有一个叫做遗物的韩束环境 但这个的话现在已经不推荐使用了啊 这个

03:22.200 --> 03:27.080
到时候单独有个章节来介绍这个遗物 你可以简单联写就是全局环境

03:27.560 --> 03:32.680
韩束环境 那么对应的这个上下文就有什么呢 对应的上下文就有

03:33.000 --> 03:37.240
全局上下文 韩束上下文 和这个遗物韩束上下文

03:37.960 --> 03:43.800
看不看 你说有我们全局也是有一个上下文的 什么意思 也就是说比如说我们这边

03:46.230 --> 03:52.790
比如说我们这边 我们这边就写一个哇一个i等于一个e 好 然后接下来这边log

03:53.190 --> 04:01.430
这个i 很简单的两行代码 对不对 那你认为的话进来之后 然后就直接先执行第一行代码再执行第二行代码

04:01.990 --> 04:09.030
但其实呢 他在执行具体的代码之前 他会先创建一个上下文的这个环境

04:10.230 --> 04:11.190
这边 在

04:12.870 --> 04:23.190
在执行上面的全局代码之前 还有一个准备工作 所以他是一个准备工作

04:24.150 --> 04:34.230
就是我们这边也说的有在哪里 在这里看到没有 就是代码执行前进行的准备工作 什么准备工作呢 创建一个

04:36.070 --> 04:38.790
创建一个全局上下文

04:39.670 --> 04:44.470
也就是说我们在执行代码的时候 这个代码一定是需要这个上下文环境的

04:45.270 --> 04:48.390
由了上下文环境 然后接下来才开始执行代码

04:49.750 --> 04:52.870
没有没有 好 然后接下来我们这边继续

04:54.150 --> 04:59.910
接着是运行时 首先会进入全局环境 所以说首先是什么 首先是全局上下文

05:00.950 --> 05:07.750
那肯定首先是全局上下文 好 然后接下来的话后面他会调用函数 注意是调用函数的时候

05:08.070 --> 05:15.270
不是说声明的时候 给我们这边把这个加粗 他是调用的时候 那这个时候呢就会进入到函数执行环境

05:15.430 --> 05:19.030
就会生成对应的这个函数执行上下文

05:19.750 --> 05:25.110
那我们的代码是可以声明多个函数的 说函数的执行上下文也会有多个

05:25.990 --> 05:31.590
那这个有多个的话 那我们怎么管理呢 我们这边就通过一个叫做站的形式

05:32.790 --> 05:35.030
来进行管理 我们来看一下这个站

05:35.990 --> 05:43.830
这里有张图 大家看一下 站的这种数据结构 它就类似于一个什么呢 类似于一个这个乒乓球盒子

05:44.390 --> 05:51.030
这张图大家应该是之前是看过的哈 乒乓球盒子 只有什么呢 只有一个出入口

05:52.390 --> 06:00.950
看到没有 只有一个出入口 那只有一个出入口那就会导致什么呀 是不是先进后出 后进先出

06:01.830 --> 06:03.830
对不对 你先放进去的 比如我们这边1号球

06:04.710 --> 06:09.750
先放进去了 先放进去的话 那他肯定是你要出来 是不是最后才能出来 那加这个5号球

06:10.470 --> 06:14.310
5号球的话 他是不是就是最后放进去 但是他是不是最先出来

06:14.950 --> 06:16.790
这个就是我们站的这个结构

06:17.590 --> 06:18.630
那我们这边呢 这个

06:19.510 --> 06:27.270
你看这边这个站 这边有个站底 这边有个这个站底 那放在这个最下面的这个数据 他一定是最后才销毁的

06:29.030 --> 06:36.870
好 我们这边我们看一下 站遵循先进后出 后进先出 也就是这个lifo原则

06:37.510 --> 06:44.150
这个的话就是这几个单词的缩写 last in 就最后进 first out 最后出

06:45.510 --> 06:48.390
好 那接下来我们来看一下我们的这个执行站

06:49.270 --> 06:58.070
执行站有个特点 什么是特点呢 就是处于站底的永远是全局环境的这个执行上下问

06:58.710 --> 07:03.510
而处于这个站顶的是当前执行寒书上下问

07:04.070 --> 07:08.230
啊 比如说我们这边我们举个例子 就这边就用这段代码来举例吗

07:09.750 --> 07:15.670
就用这段代码 好 这里 这里的话我把它站过来 然后把上面的这个注射掉

07:16.710 --> 07:19.270
ok 好 那现在我的话我要执行这段代码

07:19.910 --> 07:26.150
那我要执行这段代码的话 那首先他必须要有一个什么呀 是不是得有一个全局上下问

07:26.710 --> 07:29.430
对不对 我这边画一个全局上下问

07:30.150 --> 07:32.630
首先的话你必须啊 我们这边是一个站

07:33.750 --> 07:42.630
是一个站 okay 那接下来正式开始执行这段代码之前 他首先的话肯定是干嘛呢

07:45.430 --> 07:47.030
我能不能测销了 这个

07:48.230 --> 07:59.380
嗯 方度 okay 好 执行这段代码之前的话 他肯定是有个全局上下问啊 说这边的话会有一个全局上下问

08:00.020 --> 08:01.380
就是什么呢 就是我们的globo

08:02.980 --> 08:03.940
globo

08:04.660 --> 08:06.100
啊 我这个稍微写慢一点

08:06.900 --> 08:07.860
globo

08:08.500 --> 08:12.580
所以先创建一个全局上下文 你先不关他那个上下文里面有什么

08:13.060 --> 08:17.860
啊 反正我告诉你必须要有这个必须要有一个这个上下文环境

08:18.260 --> 08:19.220
才能执行代码

08:20.020 --> 08:23.300
那我说必须先要执行先要创建这么一个这个

08:24.260 --> 08:27.460
全局上下文 对不对 就这个啊 全局上下文

08:27.780 --> 08:33.700
好 创建了这个之后咱家就开始执行代码 执行代码的话 那讲上我们这边可以多写点啊 比如这边

08:35.780 --> 08:36.260
log

08:36.660 --> 08:37.780
啊 比如这边的话 hello

08:38.980 --> 08:41.140
然后接下来的话 这边log

08:42.020 --> 08:42.980
比如说world

08:44.180 --> 08:49.220
啊 比如我们有这么一段代码 好了 接下来他首先先执行第一句就这句

08:50.020 --> 08:51.380
就这句啊 就这句

08:52.100 --> 08:55.700
这句先执行这句 执行了这句之后 然后接下来这边

08:56.180 --> 08:58.900
这边是不是声明了一个这个函数啊

08:59.540 --> 09:03.780
对不对 那你声明就声明 这边不管他 好 然后接下来的话这里

09:04.500 --> 09:07.220
这里是不是开始 就这一块 这一块

09:07.940 --> 09:09.940
这一块的话是不是开始调用了

09:10.580 --> 09:17.300
一旦你调用这个函数啊 我们都知道调用函数是不是会进入到这个函数里面 开始执行函数里面的这个代码

09:18.100 --> 09:24.740
好 那接下来他在执行这个函数里面的代码之前 他会声明一个什么呢 他会创建一个这个

09:25.380 --> 09:25.620
附

09:26.580 --> 09:28.820
这个函数的这个函数上下文

09:29.540 --> 09:32.820
看不看 这个执行上下文 对

09:35.850 --> 09:38.250
这个快捷键不好用呢

09:39.530 --> 09:40.890
这边world

09:41.770 --> 09:46.730
我看这边写的是那个呀 是这个 我看是不是

09:47.450 --> 09:48.570
马上哈 我看一下

09:50.010 --> 09:55.480
不好用呢 是要按住这个吗 还是按住这个

09:56.200 --> 09:58.200
啊 也不好算了吧 那我就在这里

09:58.760 --> 10:00.200
好好把这个测销一下

10:02.490 --> 10:06.330
再测销一下 okay 好 他这边呢 就是执行到这个负的时候

10:06.970 --> 10:12.490
那他就会创建一个这个负的函数的这个执行上下文啊 说说在这边

10:13.690 --> 10:16.250
他就会有这么一个上下文叫做这个负

10:17.210 --> 10:20.170
所以先要把这个上下文环境创建好

10:21.130 --> 10:23.610
对不对 创建好之后的价才开始执行

10:23.930 --> 10:29.290
开始执行 然后接下来的话 假设他这边有些其他的代码啊 这款就不写了啊 假设有些其他代码

10:29.290 --> 10:32.890
他就正常的执行 执行之后 然后接下来的话

10:33.850 --> 10:37.050
假设我这边有一个这个bar 但你必须要调用啊

10:37.850 --> 10:43.930
啊 但下面调用的是吧 这边 这边return的时候 这边是不是调用的 好 当你调用的时候

10:45.210 --> 10:52.490
调用这个bar这个函数 他就又会干嘛呢 又会创建一个这个bar的执行上下文

10:53.930 --> 11:00.090
看到没有 把这个bar的执行上下文创建好 创建好之后 然后接下来是不是执行这个bar

11:00.970 --> 11:06.890
里面的这个内容 对不对 执行执行 执行到直到什么 直到这个bar这个函数里面 没有代码

11:07.370 --> 11:12.330
可以运行的 然后呢 那我整个这个bar这个函数是不是就执行完了

11:12.730 --> 11:18.010
执行完了之后 然后接下来bar这个执行上下文 他就会干完了 他就会出战

11:19.450 --> 11:23.930
看到没有 他就会弹出去 弹出去让现在我们的站顶就只有什么 这不只有这个for

11:24.650 --> 11:30.090
这不只有这个for 对不对 只有这个for 好 复 复的话 然后再假设这下面

11:30.970 --> 11:36.170
那这不可能下面还有代码 这边都已经return了 好 人家这个复 复的代码是不是也执行完了

11:36.890 --> 11:42.410
对不对 复的代码也执行完了 然后接下这个复这个执行上下文 他就也会出战

11:43.370 --> 11:47.050
弹出去 弹出去 让现在的话是不是就只有一个globo

11:47.930 --> 11:53.610
对不对 然后重新来到你的这个globo这个执行上下文 那继续往后面执行啊 比如这边

11:53.930 --> 11:57.450
有个console.log执行 执行完了之后呢 接下来我全局

11:58.250 --> 12:08.250
整个这个全局上下文里面是没有代码了 没有代码之后的啊 接下来最后一步 然后就是我的这个全局上下文啊 他也会出战

12:09.370 --> 12:15.050
看到没有 他就是这样子的一个过程啊 好 我把这个

12:16.090 --> 12:17.210
把它解冻

12:18.330 --> 12:22.010
OK啊 说这边这边有张图 我来看一下这里有张图

12:22.730 --> 12:25.450
首先的话 是不是 先是这个globo context

12:26.010 --> 12:32.410
全局上下文入战 好 然后接下来这边调用 注意他是在调用的时候 我反复强调啊 调用的时候

12:32.970 --> 12:37.770
是不是生成一个这个复的这个上下文环境 对不对 然后复入战

12:38.650 --> 12:40.330
入战之后 然后接下来的话 这边

12:40.810 --> 12:43.450
复里面又干嘛呢 又调用了这个bar这个函数

12:43.930 --> 12:49.930
那接下bar这个上下文又入战 入战之后 然后接下来的话 因为有这个bar这个函数上下文了

12:50.090 --> 12:52.650
说开始执行bar里面的代码 一句一句执行

12:53.130 --> 12:58.170
执行完了之后 然后接下bar这个上下文他就出战了 出战然后下占领就是什么

12:58.810 --> 12:59.450
就是复

13:00.490 --> 13:05.050
对不对 就是复 那复执行完了之后 然后下复这个他也出战了

13:05.450 --> 13:08.730
出战之后 然后接下来就只剩下什么呢 只剩下全局

13:09.850 --> 13:15.930
就只剩下全局 全局然后接下来也执行完了的话 那就没有了 那接下来最后这个这个也就出战了

13:16.810 --> 13:20.330
看到没有 整个过程就是这个样子的 我们这边我们可以看一下

13:21.530 --> 13:28.090
执行上下文可存在多个 因为你比如说你一调用函数 是不是就会生成一个函数上下文

13:29.290 --> 13:36.010
虽然没有明确的数量限制 但是如果超过占分配的空间 就会造成堆占溢出

13:36.650 --> 13:42.170
经常常见于什么呢 就是帝规调用的时候 比如我这边调复 调复是不是就会生成一个

13:42.570 --> 13:47.450
复的函数上下文 生成之后 然后接下来这边过来 过来这边又在调用

13:47.850 --> 13:55.530
他就又会生成一个复的函数上下文 大家他就一直生成这个函数上下文 但是呢 你又没有就

13:56.330 --> 14:03.130
你这边是帝规的调用 对不对 大家他就一直来来来来来来到上面 直到什么直到爆占

14:03.610 --> 14:05.290
这就是我们的堆占溢出

14:06.330 --> 14:09.210
ok 这就是我们的这个占的数据结构

14:09.530 --> 14:16.410
好 这个明白了之后 然后接下来我们就来看一下 关于我们的这个执行上下文

14:16.970 --> 14:18.170
他具体做什么

14:18.810 --> 14:26.570
我们说就前面说过 当运行这个代码之前 他必须要有一个什么呀 是必须要有一个执行上下文环境

14:28.250 --> 14:33.370
有了这个执行上下文环境之后 我是不是才可以做这个具体的事情

14:33.850 --> 14:42.010
对不对 那他这个执行上下文他是做这个准备工作的 让他具体做一些什么样的准备工作呢 我们来看一下

14:42.810 --> 14:47.290
我们的执行上下文他做的工作 其实就是和他的生命周期有关

14:47.850 --> 14:52.250
他的生命周期主要是两个阶段 一个是创建阶段

14:53.370 --> 14:59.210
一个是什么呢 一个是这个执行代码阶段 那其实重点是什么 重点是这个

14:59.850 --> 15:00.490
创建阶段

15:01.210 --> 15:02.410
主要是这个创建阶段

15:03.530 --> 15:12.250
创建阶段我们来看一下 当函数被调用时会进入函数环境 创建一个执行上下文 那标志者什么呢 标志者进入了创建阶段

15:12.650 --> 15:16.970
那创建阶段要做什么事情呢 创建阶段主要有三件事情

15:17.930 --> 15:24.010
首先第一个是创建变量对象 那这个的话也就是我们平时所说的这个vo

15:28.280 --> 15:28.680
vio

15:29.480 --> 15:33.160
看到没有 vio的话他其实全程就是什么呢 就是这个variable

15:35.080 --> 15:35.640
variable

15:36.440 --> 15:37.000
variable

15:39.990 --> 15:40.950
variable

15:44.890 --> 15:46.490
variable object

15:47.530 --> 15:49.210
也就是你可以把它看作是一个对象

15:50.010 --> 15:56.890
啊是个对象这个对象既然是对象他是不是就有这个属性或者方法 对不对 那这边他就是有三个属性

15:57.450 --> 16:00.890
他这边呢就是首先会初始化这个arguments对象

16:02.330 --> 16:03.210
并且给他复制

16:03.930 --> 16:04.410
然后呢

16:04.970 --> 16:09.050
他除了这个初始化arguments对象 然后还有就是传递的那个

16:09.610 --> 16:10.730
传递的这个行参

16:11.370 --> 16:12.410
这里其实还有一个

16:15.240 --> 16:16.200
这里复制一份

16:21.610 --> 16:25.050
好这里这里的话就是确定函数的行参

16:31.960 --> 16:38.440
行参啊 并且的这个行参是有值的啊 然后接下来话确定什么呢 确定这个arguments对象

16:39.000 --> 16:43.560
啊 并且是有值的好 然后接下来什么呢 接下来话是这个函数的声明

16:44.120 --> 16:47.640
啊 但这种声明的话是注意啊 这种声明是普通

16:48.840 --> 16:50.440
普通就是确定

16:51.880 --> 16:54.040
确定普通字面量

16:55.320 --> 17:03.640
形式的函数说这个声明啊 并且也是付了值的 最后就是什么呢 最后就是确定这个变量声明

17:05.080 --> 17:11.640
啊 就是你在这个函数里面声明了哪些变量 但是呢这个变量啊 他是没有复制的

17:13.000 --> 17:18.440
看到没有 他是没有复制的 也就是我们整个这个变量对象包含了这么几个东西

17:19.240 --> 17:21.240
啊 这个我们一会举例子啊 我们先

17:21.640 --> 17:27.240
大致有这么一个这个印象 一会我们举例子 这是他做的第一个事情 创建变量对象

17:28.120 --> 17:32.120
变量对象里面 就是有这么几个东西会被确定

17:32.680 --> 17:37.640
这是第一步 大家第二步 第二步他是会确定这个类似的这个指向

17:38.280 --> 17:43.560
以类似究竟指向哪里 然后接下来下一步 下一步就是确定这个作用预

17:44.520 --> 17:50.200
啊 确定作用预 好 那接下来我们先着重看一下什么呢 先着重看一下这个变量对象

17:51.720 --> 17:59.400
啊 变量对象就是这个vio 是吧 vio的话 你就可以把它看作是一个这个对象 我们说了嘛 就是variable object

17:59.800 --> 18:02.680
你可以把它看作是一个对象 那这个对象里面

18:03.720 --> 18:10.760
啊 就这里啊 这里variable object 他对应的是不是也是一个对象 那这个对象里面对应的就是有这么几个东西

18:11.480 --> 18:12.920
啊 我们找个例子 我们来看一下

18:14.840 --> 18:15.960
啊 比方就找这个例子

18:17.000 --> 18:19.240
就找这个例子 我们把这个例子我们把分析一下

18:21.850 --> 18:34.230
然后把这注释掉 ok 好 我这边的话我有这么一段代码 好来我们来看一下这段代码 他的一个这个

18:35.270 --> 18:42.070
嗯 这个这个函数上下文啊 然后接下来他是经历了一个什么样的这个阶段 首先的话是不是先执行代码

18:42.550 --> 18:49.750
执行代码首先进入什么是全局上下文 全局上下文 然后接下来的话这边执行 这边的话首先这个for

18:50.790 --> 18:54.710
啊 给他复制是一个函数 然后接下来这边是不是调用这个

18:55.270 --> 18:55.510
for

18:56.150 --> 18:59.030
调用这个for的话 然后接下来是不是会生成一个

19:00.950 --> 19:04.630
生成一个什么呀 生成一个是不是for

19:05.430 --> 19:09.590
的这个函数上下文环境

19:11.110 --> 19:16.710
对了吧啊 那个全局上下文环境我们就先不说了啊 他首先肯定是先有一个全局上下文环境

19:17.110 --> 19:19.110
啊 生成 生成之后 然后接下来的话 这边

19:20.310 --> 19:24.150
这边的话就开始执行代码 执行代码大家执行到这边34行的时候

19:24.710 --> 19:31.430
是在调用函数 调用函数就会生成一个这个函数的上下文环境 那上下文环境是不是分为两个阶段

19:32.070 --> 19:36.790
对不对 那首先第一个阶段 第一个阶段就是什么呢 就是我们的创建阶段

19:38.230 --> 19:38.870
创建

19:39.590 --> 19:40.550
这个上下文

19:44.460 --> 19:45.340
阶段啊

19:45.900 --> 19:53.500
创建这个上下文阶段 那这个创建阶段的话 他就会干嘛呢 你可以把这个上下文理解成是一个对象

19:54.060 --> 19:55.340
就什么对象呢 就是这里

19:55.740 --> 19:57.340
就这个

19:58.620 --> 20:03.420
就这个对象啊 上下文 你就把它想象成是一个对象

20:05.180 --> 20:08.700
那这个对象里面就会确定 那么几个东西 首先是一个唯有

20:09.740 --> 20:13.260
对不对 好 然后接下来还会确定什么 是Z的指向

20:13.980 --> 20:17.740
而既然还会确定什么呢 确定你这个函数里面 它的这个scorp

20:18.540 --> 20:19.020
作用预

20:19.740 --> 20:22.940
啊 会确定这么几个 好 然后这两个先注释

20:23.340 --> 20:25.980
这两个专门有课程啊 包括这个Z的指向

20:26.380 --> 20:31.740
那包括这个作用预和作用预链啊 这个scorp 我是放在那个作用预和作用预链

20:32.300 --> 20:37.820
里面讲的啊 这个Z 是Z的话也是有专门有一节课 关于确定这个Z的指向

20:38.140 --> 20:42.380
啊 这个都是有单独的课程的 说这节课我们主要看什么呢 主要看vio

20:43.020 --> 20:44.940
那这个vio的话你又可以把它

20:45.500 --> 20:52.940
想象成是一个对象 对不对 想象成一个对象 这样我们看一下这个vio里面要确定一些什么东西

20:53.660 --> 20:54.060
我们把

20:56.140 --> 20:56.860
把这儿拿过来

20:58.460 --> 21:02.970
把这儿拿过来啊 vio vio里面

21:04.170 --> 21:04.650
vio

21:09.140 --> 21:13.540
vio里面要确定的东西

21:14.340 --> 21:16.340
有点些啊 是不是就这么一些

21:17.140 --> 21:17.540
对不对

21:18.500 --> 21:19.300
啊 把这个

21:22.260 --> 21:23.300
把这个删掉

21:23.780 --> 21:27.900
他把那个markdown的那个也复制过来了

21:29.740 --> 21:30.860
啊 把这个删掉

21:32.220 --> 21:35.660
其实注射掉就可以了 是吧 直接注射掉吧

21:36.460 --> 21:36.860
就这样子

21:37.740 --> 21:38.060
OK

21:39.740 --> 21:42.140
啊 还是把这个删了吧 看着不好看

21:42.860 --> 21:47.180
好 他这边就会确定这么一些东西 首先就是确定你韩束的这个行餐

21:47.740 --> 21:51.340
那么看一下这个韩束 这个韩束这边是不是有一个这个i

21:52.220 --> 21:58.540
对不对 传递过来的 i 啊 说这边的话他就会在这个上下文环境里面记录一下啊 我有一个i

21:58.940 --> 22:01.980
然后接下来你注意 这个的话他这个行餐他是会复制的

22:03.020 --> 22:05.820
他是会复制的 而且你这边是不是传递的是10

22:06.620 --> 22:08.780
对不对 说这边的话他拿到这个10

22:10.300 --> 22:15.020
好 第二步 第二步就是什么呢 第二步就是拿到就是我们的这个argument对象

22:15.500 --> 22:18.620
我们知道这个是一个是不是这个围书组对象

22:19.660 --> 22:20.860
argument

22:21.740 --> 22:24.780
对吧 他是个对象 对象 然后接下来他的第零象

22:25.580 --> 22:31.020
第零象对应的只是10 然后他有一个这个认识属性对应的是1

22:31.820 --> 22:34.380
看到没有 把这个确定 这个的话也是会复制的

22:34.780 --> 22:41.180
好 然后接下来确定什么呢 确定这个普通字面量形式的韩束声明 我们来看这边b

22:41.660 --> 22:43.740
b的话是不是普通字面量形式

22:44.460 --> 22:47.740
这不是啊 对不对 好 然后接下来的话这边

22:48.780 --> 22:50.700
c 哎c他是不是就找到了

22:51.340 --> 22:56.780
对不对 c 找到 找到之后 然后接下来他就会干嘛呢 他就会指向

22:58.460 --> 23:01.260
指向c那个韩束

23:02.540 --> 23:09.020
看到没有 大家最后一步 最后一步确定变量声明 这边声明了一个什么 是声明了一个b

23:10.220 --> 23:15.980
看到没有 声明了一个b 所以他这边的话就会有这么一个b 有这么一个b 但是呢 他会不会复制呢

23:16.540 --> 23:18.620
会不会复制啊 他不会复制

23:19.580 --> 23:23.020
啊 不会复制 不会复制那就是多少 这不就是undefy

23:24.300 --> 23:26.540
看到没有 哎 这个的话就是我们的这个

23:27.900 --> 23:33.740
执行上下文啊 他在创建阶段 他其实就会确定这么一个变量对象出来

23:34.780 --> 23:39.180
啊 确定了之后 然后接下来下一步才是干嘛呢 下一步才开始执行代码

23:39.660 --> 23:41.980
接下来第二步 执行代码

23:44.250 --> 23:48.730
执行代码 那执行代码就一步一步执行呗 那首先的话你这边是不是有这个

23:49.450 --> 23:54.330
这里有一个这个 哦 这里刚才还漏了一个是吧 刚才还漏了一个 这边还有一个这个a

23:55.930 --> 23:57.130
这边呢 首先有一个a

23:58.250 --> 24:02.090
有一个a a的话也是什么 这个undefy

24:02.890 --> 24:08.010
对不对 好那接下来开始执行 执行的话那就是一步一步代码执行 那首先给这个a复制

24:08.410 --> 24:10.250
那这个a是不是就变成这个Hello

24:11.050 --> 24:12.490
对不对 我们把这个复制一份

24:13.370 --> 24:15.610
接下来开始执行代码 我们把这个w复制一份

24:17.700 --> 24:20.500
好 那接下来首先执行第一行代码

24:20.900 --> 24:24.100
第一行代码是不是就是复制为Hello 那接下来这个a

24:24.660 --> 24:26.900
就变成什么 是变成制服创的

24:27.860 --> 24:34.180
Hello 对不对 好那接下来这边b b对应的是一个什么 b对应的是不是一个这个private b函数

24:35.620 --> 24:38.340
对不对 对应的是一个这个private b

24:38.740 --> 24:40.100
那它是一个函数

24:43.210 --> 24:48.170
看到没有 啊 但我们这边没有多余的代码啊 没有多余的代码 那我比如说我举个例子

24:48.890 --> 24:53.850
我这边的话我先就来log什么呢log这个b

24:55.370 --> 25:00.250
我一来我就logb 请问这边打印出这个b b是多少

25:02.390 --> 25:09.830
请问这边打印这个b b是多少 你看 你是不是就按照这边来进行分析 这个是我们生存好的这个函数上下温

25:10.470 --> 25:15.750
然后接下来完了之后上这个上下温创下好之后 然后下第二步是不是开始执行代码

25:16.230 --> 25:22.230
那执行代码你一来就干嘛呢 一来就打印这个b 打印这个b是多少 b是undefy

25:23.270 --> 25:25.590
undefy 所以他这边的话这个位置

25:26.550 --> 25:30.470
这个位置一定打印出什么 一定打印出undefy

25:31.270 --> 25:37.110
啊 这其实也就是说变量提升 以前我们是不是讲过一个变量提升啊 对不对 当时我们没有细讲

25:37.750 --> 25:40.230
啊 那这里的话你就知道这个变量提升

25:40.790 --> 25:43.750
他是怎么来的 包括我这边的话我打印一个c

25:44.710 --> 25:46.790
我们先讲过这个函数是不是也会有提升

25:47.350 --> 25:49.510
就是普通啊 普通形式就这种形式

25:49.910 --> 25:51.830
声明了函数 他也会有提升

25:52.310 --> 25:54.710
那为什么有提升 原因很简单

25:55.030 --> 26:01.190
他在创建上下温环境的时候 他这边这个vio里面他就有这个c 并且这个c是有直的

26:01.510 --> 26:03.110
这个直指向那个函数

26:03.750 --> 26:07.110
说接下来的话你这边打印这个c的时候 他打印出来的是什么呢

26:07.830 --> 26:09.350
打印出来就是一个function

26:09.910 --> 26:11.670
啊 不信的话你这边可以测试一下

26:14.070 --> 26:15.350
我们这边load index

26:16.390 --> 26:20.230
看到没有 一个是undefy 一个是这个function c

26:21.030 --> 26:26.710
啊 所以一定要把这个就是上下温啊 这个创建上下温环境他的这个两个阶段

26:27.110 --> 26:31.750
一个是创建阶段 一个是执行阶段 执行阶段其实没什么好说的

26:31.990 --> 26:35.350
他就是一句一句执行代码 关键是这个创建阶段

26:36.230 --> 26:38.470
创建阶段他会确定哪些东西

26:39.430 --> 26:42.230
一个是确定vio 一个是确定z

26:42.470 --> 26:43.750
一个是确定scope

26:44.310 --> 26:45.350
啊 但这个z

26:46.070 --> 26:49.350
单独有一节课啊 就是讲z指向scope

26:50.070 --> 26:55.510
单独有一节课 作用域和作用域练啊 那这样就只剩什么呢 只剩这个vio

26:56.470 --> 27:01.190
只剩这个vio啊 vio的话大家他会确定一些什么样的这个东西

27:01.670 --> 27:03.270
一定要把它搞清楚

27:04.070 --> 27:06.070
好吧好回到我们这边

27:07.030 --> 27:15.030
回到这边啊 我们来看一下啊 这里有必要说一下辩量对象啊 当这个处于这个执行上下温建立阶段的时候

27:15.270 --> 27:17.030
我们可以将整个上下温

27:17.430 --> 27:22.470
看作是一个对象啊 该对象有三个属性 那是不是就是variable object

27:22.950 --> 27:24.230
然后加这个作用域

27:25.030 --> 27:26.470
scope chain 然后加这个z

27:26.950 --> 27:29.430
然后加这边这个variable object

27:29.990 --> 27:31.430
是不是也可以看作是一个对象

27:32.150 --> 27:32.630
对不对

27:33.190 --> 27:34.390
好 那接下来这个

27:35.350 --> 27:35.910
这里

27:36.710 --> 27:39.510
这里的话 然后分为两个阶段啊

27:40.150 --> 27:40.790
一个是

27:43.110 --> 27:44.630
这边是在哪里

27:46.900 --> 27:48.180
好 这边是这 这上面

27:48.580 --> 27:50.100
好 首先的话是创建阶段

27:50.660 --> 27:55.220
对吧 创建阶段 然后确定这三个刚才说了 好 然后加这边的话是执行阶段

27:55.460 --> 27:56.820
执行阶段的话 是不是就是

27:57.140 --> 27:58.820
一行一行的这个调用代码

27:59.300 --> 28:00.980
不不 调用的嘛 就执行代码

28:01.620 --> 28:03.540
所以一句一句的这个执行代码

28:04.180 --> 28:04.740
对不对

28:05.700 --> 28:07.300
好 这个是我们刚才那个例子

28:07.540 --> 28:10.900
这个例子我们再来看一下嘛 这边这个variable object

28:11.140 --> 28:13.460
对应的这边argument是这个i

28:13.700 --> 28:16.260
然后加这个c 然后a和b都是什么

28:16.500 --> 28:17.540
都是undefine

28:18.580 --> 28:19.060
明白没有

28:19.460 --> 28:21.140
你一定要把这个看明白

28:21.380 --> 28:24.740
你把这个看明白之后 然后加它随便怎么考你这个题

28:24.980 --> 28:26.500
你就都明白是怎么回事了

28:26.740 --> 28:28.340
比如说我们这边我们取点例子

28:30.100 --> 28:32.260
这个刚才说了啊 这个就不说了

28:33.140 --> 28:33.940
这就不说了

28:34.340 --> 28:36.580
好 比如说我们这边 我们来看一下这道题

28:38.100 --> 28:39.780
把这道题拿过来

28:42.140 --> 28:43.420
把上面注射掉啊

28:45.670 --> 28:46.230
把这个

28:48.150 --> 28:48.630
这样子

28:49.750 --> 28:50.790
把这个注射掉

28:51.190 --> 28:52.310
把这个注射掉

28:53.350 --> 28:55.670
好 你去面试的时候经常会遇到这些

28:56.630 --> 28:57.430
像这些题

28:57.830 --> 28:59.190
那这些题它就是什么呢

28:59.430 --> 29:02.710
它就是考察你这个执行上下文的知识

29:03.350 --> 29:03.830
对不对

29:04.070 --> 29:05.350
好 那接下来我们看这边

29:05.670 --> 29:07.830
这边是不是一个立即执行函数

29:08.630 --> 29:13.030
那既然是一个立即执行函数的话 那这边的话是不是也会创建一个函数上下文

29:13.590 --> 29:13.990
对不对

29:14.790 --> 29:15.590
上面的代码

29:21.400 --> 29:28.600
上面的代码也会创建一个函数上下文

29:29.080 --> 29:33.560
对吧 那既然它会创建一个函数上下文 那我们的这个上下文是分两个阶段

29:34.360 --> 29:35.160
啊 上下文

29:36.120 --> 29:36.760
上下文

29:37.800 --> 29:38.280
分为

29:40.860 --> 29:41.340
分为

29:42.220 --> 29:42.940
两个阶段

29:44.220 --> 29:46.620
那两个阶段呢 一个是创建阶段

29:48.550 --> 29:49.430
然后一个是什么

29:50.390 --> 29:51.510
一个是创建阶段

29:51.670 --> 29:54.470
一个是执行阶段

29:54.950 --> 29:56.310
对吧 那首先我们来看什么呢

29:56.390 --> 29:57.590
看这个创建阶段

29:58.870 --> 30:00.870
那创建阶段的话这里

30:02.790 --> 30:05.590
这边就是有这么一个这个我就直接写成

30:05.910 --> 30:06.550
算了算了

30:06.550 --> 30:06.870
还是

30:07.990 --> 30:08.870
还是写这个吧

30:09.270 --> 30:10.630
it's q形 context

30:12.150 --> 30:12.950
啊 写成这个

30:13.910 --> 30:14.310
啊 这个

30:15.830 --> 30:19.910
啊 这个是我们的执行上下文 执行上下文我们说过 是不是可以把它看作是一个

30:20.150 --> 30:20.710
对象

30:21.270 --> 30:23.110
对象里面让家确定几个东西

30:23.510 --> 30:26.550
三个 第一个是vio vio也是一个对象

30:26.790 --> 30:29.430
那第二个确定什么 是确定Z式的指向

30:29.670 --> 30:31.750
那家确定什么 是作用预列

30:32.390 --> 30:32.870
对不对

30:33.750 --> 30:34.950
啊 这两个的话先不看

30:36.230 --> 30:37.430
好 我们就来看这个vio

30:37.830 --> 30:40.870
那这个vio的话 然后接下来这边确定什么

30:41.430 --> 30:43.030
你把这边的话拿过来

30:43.670 --> 30:45.670
你可能现在还记不住 你就把它拿过来

30:46.950 --> 30:49.270
拿过来一个一个看 那首先看什么呢

30:49.510 --> 30:51.190
首先看这个

30:51.430 --> 30:52.230
行参

30:52.870 --> 30:53.750
那我们看这边

30:53.990 --> 30:55.830
这边的话有没有行参

30:56.550 --> 30:59.430
你这边在执行这个立即执行还说的时候 是不是没有传参

30:59.910 --> 31:01.430
对不对 没有传参 那这边没有

31:02.070 --> 31:03.990
没有 然后接下来看这个arguments

31:04.390 --> 31:06.070
那arguments是不是也就不用看了

31:06.550 --> 31:06.870
对不对

31:07.110 --> 31:08.550
好 然后接下来确定什么呢

31:08.790 --> 31:11.910
确定普通字面量形式声明的还说

31:12.150 --> 31:12.950
那接下我们来找

31:13.670 --> 31:16.070
普通字面量形式 是不是找到这个vio

31:17.110 --> 31:18.390
对不对 找到vio

31:18.870 --> 31:24.390
vio的话 干嘛呀 是不是就是指向vio

31:25.110 --> 31:25.750
还说

31:27.270 --> 31:27.750
对不对

31:27.990 --> 31:29.590
哎呀 他指向这个vio还说

31:29.910 --> 31:31.830
好 然后接下来完事之后 下一步

31:32.070 --> 31:34.390
下一步是不是确定这个变量声明

31:34.710 --> 31:36.150
那接下来你去看一下

31:36.390 --> 31:36.790
这边

31:37.270 --> 31:39.350
这边的话是不是有这个vio

31:39.590 --> 31:41.350
哎 你注意 这里有一个支持点

31:41.750 --> 31:44.150
我这边是不是又声明了一个这个vio

31:44.950 --> 31:49.270
当我又声明一个vio的时候 但是由于我这边是不是已经有vio了

31:50.310 --> 31:52.870
对不对 已经有vio了 他接下来他就不会再

31:53.510 --> 31:56.470
就是声明这个变量了 也就是他不会再这样子

31:57.750 --> 31:59.030
就不会在这边

31:59.270 --> 32:00.790
然后又来一个这个antify

32:01.190 --> 32:03.670
对不起 他不会了 为什么呢 因为你上面的话

32:03.910 --> 32:06.310
已经这边已经确定了 这边有一个vio了

32:06.950 --> 32:09.030
明白没有 就同名的这个声明他就

32:09.430 --> 32:11.910
不会再做这个变量声明了

32:12.150 --> 32:14.630
就是负啊 负的话就不会再做了

32:14.870 --> 32:15.990
好 那下这个bar

32:16.550 --> 32:19.750
bar的话是不是没有 对不对 说接下来他会有一个什么呢

32:19.990 --> 32:20.950
他会有一个bar

32:21.750 --> 32:24.310
bar的话是一个antify

32:24.870 --> 32:26.470
我这边让我要说明一下

32:27.190 --> 32:29.350
呃 天在哪里呢 天在这里吧

32:29.830 --> 32:31.430
就是再进行

32:33.270 --> 32:34.790
再进行变量

32:36.550 --> 32:38.150
声明的时候

32:38.870 --> 32:43.190
如果发现该变量名

32:44.550 --> 32:46.150
已经存在

32:47.030 --> 32:51.750
则不会再声明

32:52.790 --> 32:55.590
看到没有 那我们这边这个for是不是就是一个典型的例子

32:56.310 --> 32:56.790
对不对

32:58.470 --> 32:59.910
好 你看那我的这个

33:00.870 --> 33:02.310
呃这个vio就创建好了

33:03.030 --> 33:04.070
这vio就这么简单

33:04.710 --> 33:07.510
对不对 就这么简单啊 一个for一个bar

33:08.150 --> 33:10.710
好 然后完事之后 然后再这边开始执行代码 然后再

33:10.950 --> 33:11.750
第二步

33:12.230 --> 33:13.270
啊 第二步

33:13.790 --> 33:16.070
第二步就是什么呢 第二步就是执行代码

33:17.350 --> 33:19.670
执行代码 那执行代码 那你就把这个代码拿过来喽

33:20.470 --> 33:22.230
对不对 拿过来一句一句执行呗

33:23.510 --> 33:25.430
那我们这边就是一句一句的执行

33:26.870 --> 33:30.950
啊 那接下首先console.log type of for是什么

33:31.190 --> 33:32.470
for是不是一个函数啊

33:32.710 --> 33:34.150
说这边的话会打印出什么呀

33:34.390 --> 33:36.070
会打印出方形

33:36.310 --> 33:37.830
好 然后接下来的话这边

33:38.870 --> 33:40.150
好 把这个vio也复制一份吧

33:41.590 --> 33:42.150
放到这里

33:44.020 --> 33:44.740
放到这里

33:45.940 --> 33:49.620
ok 好 然后再这边console.log type of bar

33:50.500 --> 33:52.820
bar的话你现在指的是什么 什么undefine

33:53.060 --> 33:56.180
说他接下来他这边的话是undefine

33:57.060 --> 34:01.300
对不对 然后再执行第三行代码 第三行代码是不给这个for复制啊 是不是一个hello

34:01.780 --> 34:05.380
对不对 那接下来我这个for 他就不再是指向一个函数了 你注意

34:05.780 --> 34:09.060
他就不再是指向一个函数 他就是一个什么呢 他就是一个hello

34:09.620 --> 34:10.580
是一个制服创的

34:10.980 --> 34:11.460
hello

34:15.510 --> 34:15.910
hello

34:16.550 --> 34:18.470
好 然后接下来这边给bar复制

34:18.710 --> 34:21.110
bar的话复制是不是就变成这么一个函数啊

34:21.750 --> 34:24.390
对不对 好 我们假设给这个函数给个名字嘛 a

34:24.630 --> 34:25.750
好 那接下来这边就是

34:25.990 --> 34:26.470
function

34:27.190 --> 34:27.590
这个a

34:28.310 --> 34:29.270
所以他是一个函数

34:29.910 --> 34:33.190
对不对 好 大家这个你就不管他 这个他在那个

34:33.590 --> 34:36.390
创建上下文环境的时候 他这边就已经就是

34:37.110 --> 34:41.510
已经就是确定好了 对不对 这里就不管他 然后再执行最后一局代码

34:41.990 --> 34:46.150
打印这个for 打印这个复的话那复是什么 复是不是hello

34:46.950 --> 34:50.710
对不对 大家type of for type of for 然后接下来是什么

34:51.350 --> 34:52.470
是不是stream啊

34:54.790 --> 34:55.670
是不是stream

34:56.230 --> 35:00.470
对不对 好 那你这边让你执行一下这个代码 把这些多余的我们把他注射掉

35:00.870 --> 35:03.190
你执行一下这个代码 你看和解老师

35:03.830 --> 35:05.030
推测的一不一样

35:05.910 --> 35:06.790
好 那就在这边

35:07.030 --> 35:07.430
load

35:08.150 --> 35:08.710
看到没有

35:09.190 --> 35:09.830
function

35:10.070 --> 35:10.870
undefine

35:11.110 --> 35:11.750
hello

35:11.990 --> 35:12.390
stream

35:13.110 --> 35:14.390
function

35:14.630 --> 35:15.670
undefine

35:15.910 --> 35:17.110
对吧 hello stream

35:17.910 --> 35:21.030
看到没有 你只要把这个执行上下文

35:21.910 --> 35:24.950
你把这个就他两个阶段 其实主要就是创建阶段

35:25.510 --> 35:27.990
创建阶段他的这个vio里面

35:28.470 --> 35:29.830
要确定哪些东西

35:30.390 --> 35:31.750
你把它就是搞清楚

35:32.150 --> 35:35.990
然后这种题随便考啊 随便考考不到你的

35:36.870 --> 35:37.430
明白没有

35:38.150 --> 35:40.870
这是这道题 但是你下来的话 你肯定要看一下

35:41.830 --> 35:43.430
是不是你下来自角看一下

35:43.990 --> 35:45.510
好 这是这道题

35:45.990 --> 35:48.070
好 然后加这边的话 然后还有道题

35:48.550 --> 35:50.790
我看刚才做的是哪道题 刚才做的是这道题是吧

35:51.670 --> 35:52.950
好 这边分析这个

35:53.190 --> 35:55.030
这个变量对象这些啊

35:55.030 --> 35:56.230
然后一步一步分析

35:56.630 --> 35:57.510
哦 好像没了

35:58.630 --> 35:59.830
好像就没了

36:00.070 --> 36:01.750
好 这边让我再找一道题吧

36:02.550 --> 36:03.910
我看我以前这边

36:04.230 --> 36:04.950
还没有题

36:07.700 --> 36:10.260
我再给大家找两道题啊

36:10.980 --> 36:11.540
啊

36:12.820 --> 36:13.860
工作

36:17.340 --> 36:20.140
每个位置来着

36:22.490 --> 36:23.770
然后练习

36:28.410 --> 36:30.970
好像找不到了

36:33.700 --> 36:35.220
好像找不到了

36:35.220 --> 36:37.780
我好像是写到这里面一起

36:37.780 --> 36:39.060
啊 这这这

36:39.060 --> 36:40.340
啊 这个是this

36:41.620 --> 36:42.900
这是this相关的练习

36:42.900 --> 36:44.420
啊 好像找不到了

36:45.380 --> 36:47.940
啊 这边让 但其实你把这个

36:48.740 --> 36:50.900
你把这个就是刚才我们写的这道题

36:51.620 --> 36:53.540
这道题一旦你能够理解的话

36:53.540 --> 36:55.540
你做其他题应该是没有问题的

36:56.100 --> 36:56.660
好吧

36:56.900 --> 36:57.380
好

36:57.620 --> 36:58.180
OK

36:58.420 --> 37:00.740
好 那我们来总结一下啊 来总结一下

37:00.740 --> 37:03.060
回到我们这边最上面 我们来总结一下

37:03.700 --> 37:06.100
关于这个执行站和执行上下文

37:06.100 --> 37:07.940
首先第一个 什么是执行上下文

37:09.060 --> 37:10.340
它是不是它是一个环境

37:10.820 --> 37:13.540
对不对 它是你一个代码执行的环境

37:14.180 --> 37:16.420
必须要先有上下文

37:16.980 --> 37:20.500
有了上下文之后 然后接下来才能执行代码

37:20.500 --> 37:21.860
其实执行代码就是这个

37:22.580 --> 37:25.380
上下文生命周期里面的 是不是其中一个

37:26.180 --> 37:28.340
对不对 我们这个执行上下文 我们刚刚看了嘛

37:28.340 --> 37:30.180
它的生命周期有两个 一个是

37:30.820 --> 37:32.500
准备工作 一个是执行代码

37:33.060 --> 37:34.660
所以我们的执行代码其实就是这个

37:35.220 --> 37:36.900
上下文生命周期中的

37:36.900 --> 37:38.260
不是其中一点

37:39.220 --> 37:41.540
好 所以首先要先有这个执行上下文

37:42.100 --> 37:44.900
好 然后接下来这个执行上下文分类

37:44.900 --> 37:47.540
可以分为什么呢 可以分为全局执行上下文

37:47.540 --> 37:50.500
函数执行上下文 当然还有这个以往

37:50.500 --> 37:52.900
然后你要注意 函数执行上下文

37:52.900 --> 37:55.060
它是在什么时候产生的

37:56.260 --> 37:58.980
是在什么时候产生的 是不是在调用的时候

38:00.180 --> 38:03.700
对不对 在调用的时候 它会产生函数上下文

38:04.420 --> 38:07.220
然后接下来 这边关于这个站的数据结构

38:07.220 --> 38:10.500
这个其实很简单 是吧 这个没什么好说的

38:10.660 --> 38:12.900
就是先进后出后进先出

38:12.900 --> 38:15.140
你的全局上下文一定是在最下面

38:15.860 --> 38:18.340
然后函数上下文只要调用一个函数

38:18.340 --> 38:20.580
这边就会生成一个函数上下文

38:21.060 --> 38:24.740
对不对 然后既然你在执行这个函数里面的代码的时候

38:25.220 --> 38:27.540
如果又调用函数 它就又会

38:28.500 --> 38:29.780
是不是生成一个函数上下文

38:30.260 --> 38:33.060
对不对 然后执行完之后这个上下文就会出站

38:34.980 --> 38:37.540
好 然后关于这个上下文的生命周期

38:37.540 --> 38:40.020
就两个阶段 一个创建阶段

38:40.100 --> 38:42.980
一个执行阶段 执行阶段其实没什么好说的

38:43.460 --> 38:47.860
就是挨着一句一句执行代码 关键是创建阶段

38:48.420 --> 38:50.580
创建阶段它会确定三个东西

38:51.060 --> 38:55.620
一个是辨量对象 一个是认识的指向 一个是作用欲

38:56.340 --> 39:00.820
把这三个确定 但这两个的话我们单独有课程来讲

39:00.820 --> 39:03.460
所以主要是什么 主要是辨量对象

39:04.180 --> 39:07.300
辨量对象它究竟确定了什么东西

39:07.460 --> 39:10.820
其实就是这四个东西 对不对 行参 阿格文字

39:11.380 --> 39:14.660
然后字面量形式的函数生命和这个辨量生命

39:15.220 --> 39:18.180
然后这个辨量生命这边有个注意点 什么注意点

39:18.740 --> 39:20.180
就是如果我这边的话

39:21.300 --> 39:25.460
就前面 前面比如说已经有这个辨量了 就辨量名已经有了

39:25.460 --> 39:27.540
那这边的话是不是不会再生命这个辨量了

39:28.420 --> 39:30.100
对不对 主要就是这个

39:30.820 --> 39:33.220
其他的话就没什么了

39:33.860 --> 39:34.980
其他的话就没什么了

39:35.460 --> 39:38.580
好吧 好 这边的话关于这个整体解答

39:39.140 --> 39:41.380
谈谈你对这个JS执行上下

39:42.180 --> 39:43.380
文占的这个理解

39:43.940 --> 39:48.100
那这个的话 你就把上面的内容自己理解了之后消化了之后

39:48.500 --> 39:51.220
要用自己的话 把它总结出来

39:51.700 --> 39:52.500
我这边的话

39:53.220 --> 39:56.500
有一些参考 有些参考 你可以看我这个参考

39:56.500 --> 39:59.380
如果你觉得我这个参考比较长的话 你可以用自己的话

40:00.260 --> 40:01.220
把它总结出来

40:01.220 --> 40:05.460
好吧 好 这节课就先到这里 再见

