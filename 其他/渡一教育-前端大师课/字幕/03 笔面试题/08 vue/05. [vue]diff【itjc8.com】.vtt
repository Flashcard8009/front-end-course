WEBVTT

00:00.000 --> 00:03.840
就咱们就业阶段 这个伍佑这个课

00:04.340 --> 00:06.600
我不会讲的太难

00:06.840 --> 00:09.540
太难的话 你们就听不懂了 就没什么意义了

00:10.240 --> 00:14.040
但是我也不能太简单 我得去找一个平衡

00:14.860 --> 00:17.800
那么大家在听那个伍佑就业阶段的课的时候

00:17.800 --> 00:20.560
就尽量听 能够吸收多少呢

00:20.560 --> 00:23.000
就吸收多少 也不要有太大的心理压力

00:23.120 --> 00:26.360
因为这一部分的课 你听一点

00:26.360 --> 00:28.680
那么也是有几率就业的

00:28.880 --> 00:32.040
再多听一点的就业的几率增加一点

00:32.360 --> 00:35.720
就说这一块的课 要说百分之百全部吸收的话

00:35.720 --> 00:37.840
那个可能性不是很大

00:38.280 --> 00:41.240
但是你只要能够吸收个百分之六七十

00:41.480 --> 00:43.120
那你的就业几率就已经很高了

00:43.120 --> 00:45.280
而且是拿高兴的就业几率

00:45.720 --> 00:51.320
所以大家尽量听 因为就业阶段主要就是讲面试题

00:51.680 --> 00:57.040
已经我们平时开发中可能遇到一些雕砖的场景

00:57.040 --> 00:58.320
我们就讲这些东西

00:59.640 --> 01:02.840
好 这一课我们讲啥呢 讲无忧的跌幅算法

01:03.560 --> 01:06.160
然后这个东西是可能会面试题问到的

01:06.160 --> 01:08.120
让你去产售一下无忧的跌幅算法

01:08.120 --> 01:09.680
那么又是一个很大的题了

01:09.680 --> 01:12.960
要尽可能多的去给面试官说

01:12.960 --> 01:14.920
你说理解的东西

01:15.320 --> 01:18.040
下边有个参考回答 参考回答不用去备

01:18.040 --> 01:19.240
需要大家理解

01:19.400 --> 01:21.400
那么如果说你直接去看这个参考回答的话

01:21.400 --> 01:22.480
你是看不懂的

01:22.640 --> 01:23.520
那怎么办呢

01:23.520 --> 01:25.400
所以说我首先要跟你讲懂

01:25.640 --> 01:27.000
讲懂了之后呢

01:27.080 --> 01:28.640
你再自己去看这个参考回答

01:28.640 --> 01:29.720
你就知道什么意思了

01:30.160 --> 01:31.400
好 咱们来看一下吧

01:33.120 --> 01:35.720
我们首先要知道这个Dev是什么

01:35.720 --> 01:37.400
Dev就是比较两棵树

01:37.840 --> 01:40.200
我们是Render会生成两棵树吗

01:40.200 --> 01:41.720
对吧 新的一棵树

01:41.720 --> 01:42.640
旧的一棵树

01:42.640 --> 01:44.600
然后对两棵树进行对比更新

01:44.600 --> 01:45.160
就是Dev

01:45.520 --> 01:46.840
Dev是什么叫Defference

01:47.720 --> 01:48.520
找差异

01:49.440 --> 01:51.080
好 我们首先来看第一个问题

01:51.080 --> 01:52.360
就Dev的时机

01:52.680 --> 01:54.160
就是个Dev的事情

01:54.280 --> 01:55.800
它发生在什么时候

01:56.440 --> 01:58.040
那么这个东西要怎么去理解呢

01:58.040 --> 01:59.600
当然你可以说非常简单

01:59.600 --> 02:01.680
数据更新的时候就会发生Dev

02:01.680 --> 02:04.680
因为数据更新的时候会导致重现了

02:05.240 --> 02:07.320
重现了是不是就是Render

02:07.320 --> 02:09.480
然后得到一个许多节点树

02:09.480 --> 02:10.960
跟旧的树进行对比

02:11.320 --> 02:13.000
但是这个东西太笼统了

02:13.000 --> 02:16.120
我还是希望大家更加生气的去了解它

02:16.120 --> 02:17.800
当然我们这个就业阶段呢

02:18.680 --> 02:20.280
也不可能讲得太深

02:20.400 --> 02:21.200
你讲得太深的话

02:21.200 --> 02:22.880
就直接变成圆骂分析了

02:23.160 --> 02:24.080
然后圆骂分析了

02:24.080 --> 02:25.600
那又不是一个难度了

02:25.600 --> 02:27.200
一个难度等级都不一样了

02:27.600 --> 02:28.600
所以不会讲得太深

02:28.600 --> 02:29.800
我尽量给大家讲

02:30.040 --> 02:31.080
这里边可能会

02:31.480 --> 02:34.160
其实已经触及到圆骂部分了

02:34.160 --> 02:35.760
但是没有设计太多

02:37.320 --> 02:38.320
一个是Dev的时机

02:38.320 --> 02:39.720
就什么时候会发生Dev呢

02:40.040 --> 02:40.920
它是这样子

02:41.400 --> 02:44.960
你首先得理解这个界面是怎么出来的

02:46.240 --> 02:46.840
是这样

02:47.040 --> 02:49.040
当我们组建创建的时候呢

02:49.480 --> 02:52.000
或者是它一代的属性

02:52.000 --> 02:53.120
数据啊

02:53.600 --> 02:55.440
属性就是组建的属性

02:55.600 --> 02:56.800
数据就是自己的data

02:56.800 --> 02:57.320
对吧

02:57.320 --> 02:59.200
那么这两个人都是想用式的

02:59.480 --> 03:00.600
这两个东西变化

03:00.600 --> 03:02.280
是不是都会导致组建重券上

03:02.760 --> 03:04.520
创建的时候要渲染一次

03:04.520 --> 03:07.360
组建属性和或者是数据变化的时候

03:07.360 --> 03:08.200
又会渲染

03:08.920 --> 03:09.840
因此呢

03:09.840 --> 03:10.560
在这个时候呢

03:10.560 --> 03:11.760
它会运行一个函数

03:11.760 --> 03:12.320
什么叫渲染

03:12.320 --> 03:13.200
就是一个函数

03:14.000 --> 03:15.760
这个函数会做两件事

03:15.840 --> 03:16.960
它不是Render函数

03:17.080 --> 03:18.520
它不是我们之前的Render函数

03:18.640 --> 03:19.520
它会做两件事

03:19.520 --> 03:20.960
因为我们之前讲Render

03:21.280 --> 03:22.960
是为了大家方便理解

03:23.240 --> 03:25.120
那我们来看一下这个函数来做什么事

03:25.600 --> 03:26.800
第一件事

03:26.800 --> 03:28.440
它会运行一个方法叫做

03:29.040 --> 03:29.920
下滑线Render

03:29.920 --> 03:31.280
其实这个下滑线Render呢

03:31.440 --> 03:32.920
就是我们配置的Render

03:33.400 --> 03:34.440
它内部呢

03:34.440 --> 03:35.920
其实还要做一些别的事情啊

03:35.920 --> 03:36.360
只不过呢

03:36.360 --> 03:37.200
它最核心的就是

03:37.200 --> 03:38.960
调用我们配置的Render

03:38.960 --> 03:40.160
如果说你没有配置Render的话

03:40.160 --> 03:41.040
它就会编译

03:41.200 --> 03:41.960
编译模板

03:42.080 --> 03:42.840
生成Render

03:43.160 --> 03:44.320
都是一个意思啊

03:45.240 --> 03:46.120
它会运行这个函数

03:46.120 --> 03:47.160
其实你可以看一下吧

03:47.680 --> 03:48.320
我们这里呢

03:48.320 --> 03:49.720
就新建一个文件吧

03:59.600 --> 04:00.760
导入这个Wheel

04:05.570 --> 04:06.250
我们这里面

04:06.250 --> 04:07.330
六一个Wheel

04:08.130 --> 04:09.610
这里我简单的做一下

04:10.130 --> 04:10.610
行了

04:10.930 --> 04:12.290
我们把这个Wheel输出来

04:16.100 --> 04:17.380
我们来看一下这个实力里边

04:17.380 --> 04:19.220
因为实力本质上也就是个组件

04:19.220 --> 04:19.700
对吧

04:19.980 --> 04:21.300
Wheel组件也是

04:21.380 --> 04:22.700
本质上都是这个Wheel

04:22.820 --> 04:23.620
构造函数

04:23.900 --> 04:24.980
然后我们打开它

04:25.340 --> 04:26.500
然后它里边呢

04:26.500 --> 04:27.420
Wheel组件里边呢

04:27.420 --> 04:28.940
它会有一个函数

04:30.700 --> 04:32.820
叫做Render

04:33.020 --> 04:33.460
对吧

04:34.420 --> 04:35.580
所以它做了第一件事

04:35.580 --> 04:36.620
就是调整这个函数

04:36.620 --> 04:37.460
这个函数的作用呢

04:37.460 --> 04:39.900
其实就是调用我们给它写的一个Render

04:40.220 --> 04:40.860
作用是什么

04:40.860 --> 04:42.180
就得到一颗虚拟动物数

04:42.300 --> 04:42.780
对吧

04:43.540 --> 04:44.660
这最核心的

04:45.700 --> 04:46.020
好

04:46.020 --> 04:47.340
那么这个当然是得到一个数的

04:47.340 --> 04:48.900
返回的是这个数的根结点

04:49.820 --> 04:50.020
好

04:50.020 --> 04:51.060
这是第一件事

04:52.140 --> 04:53.980
那这件事做了过后还没完

04:53.980 --> 04:55.140
它还要做一件事

04:55.420 --> 04:57.420
它还要运行一个函数叫做Update

04:57.900 --> 04:58.820
叫做更新

04:59.820 --> 05:02.060
它会把我们刚才使用Render的一个函数

05:02.100 --> 05:03.260
生成了一个虚拟节点

05:03.500 --> 05:05.100
传输到这个函数里边去

05:05.660 --> 05:07.060
这个函数要做什么事情呢

05:07.060 --> 05:08.620
这个函数的作用就是

05:09.300 --> 05:11.340
对新旧两颗数进行对比

05:11.340 --> 05:12.580
是在它在做这个事

05:12.780 --> 05:14.820
最终完成真实动物的更新

05:15.140 --> 05:15.820
我这里呢

05:15.820 --> 05:18.220
给大家裸立了一下它的核心代码

05:18.220 --> 05:19.420
让它原代码里边

05:19.780 --> 05:21.260
跟这个东西有所区别

05:21.420 --> 05:22.460
但是差不多

05:22.620 --> 05:23.780
都是这么一个意识

05:24.260 --> 05:25.660
那么这个东西是在做什么呢

05:25.780 --> 05:26.340
你看

05:27.500 --> 05:29.220
它是实际上定义了一个函数

05:29.980 --> 05:31.220
会运行一个函数吗

05:31.220 --> 05:32.500
定了就这个函数

05:33.020 --> 05:34.180
这个函数呢

05:34.180 --> 05:35.900
它要做的事情特别简单

05:36.700 --> 05:40.500
它就是先调用Render生成一个虚拟动物数

05:41.380 --> 05:42.860
然后得到一个更节点

05:42.860 --> 05:44.500
把这个更节点作为一个函数

05:44.500 --> 05:46.460
传到这个Update函数里边去

05:46.460 --> 05:47.460
调用这个Update

05:48.300 --> 05:49.100
没了意思吗

05:49.100 --> 05:50.900
你看一下有没有这个Update函数呢

05:51.500 --> 05:52.100
Update

05:54.390 --> 05:55.390
我找一找

06:01.540 --> 06:02.940
在这Update函数

06:02.940 --> 06:03.740
是吧

06:03.780 --> 06:05.220
它做的就这么两件事

06:06.020 --> 06:09.220
然后它做了一件我们之前学习过的东西

06:09.220 --> 06:10.220
就是Water

06:10.820 --> 06:11.460
还记得吗

06:11.460 --> 06:12.620
Water来干嘛的

06:12.620 --> 06:14.220
Water是不是

06:15.220 --> 06:18.620
监听一个函数的执行过程

06:18.620 --> 06:20.940
看一下这个函数的执行过程期间

06:20.940 --> 06:23.820
用到了哪些想应识数据

06:23.820 --> 06:25.500
那么就把这个Water

06:26.580 --> 06:28.580
作为依赖收集进去

06:28.580 --> 06:29.820
之前我们讲过的

06:29.820 --> 06:31.820
所以说之前的可能你还得理解

06:31.900 --> 06:32.820
它怎么办呢

06:32.820 --> 06:33.820
它就把这个函数传进去

06:34.820 --> 06:37.820
Water的默认功能就是把这个函数运行一遍

06:37.820 --> 06:39.820
看一下这个函数的执行期间

06:39.820 --> 06:41.820
用到了哪些想应识数据

06:41.820 --> 06:42.820
一用到

06:43.820 --> 06:45.820
这个Water就被收集为依赖了

06:45.820 --> 06:48.820
将来一个对应的想应数据变化的时候

06:48.820 --> 06:50.820
是不是会重新运行这个Water

06:50.820 --> 06:51.820
那么重新运行Water

06:51.820 --> 06:53.820
就相当于是重新运行这个函数

06:53.820 --> 06:55.820
这就是为什么

06:55.820 --> 06:57.820
我们的数据变化过后

06:57.820 --> 06:59.820
它能够自动渲染界面

06:59.820 --> 07:01.820
就这个原因

07:01.820 --> 07:03.820
它是把这个函数加进去的

07:03.820 --> 07:05.820
而不是直接加了Render

07:05.820 --> 07:07.820
其实我们可以从这个结构里面

07:07.820 --> 07:09.820
可以看得到在哪呢

07:11.820 --> 07:13.820
在这你看这个Water

07:13.820 --> 07:15.820
这是我们的组件里面的Water

07:15.820 --> 07:17.820
这个Water里面你看

07:17.820 --> 07:19.820
它记录的函数是什么函数

07:19.820 --> 07:21.820
记录的函数是这种函数

07:21.820 --> 07:23.820
一个函数调用Vn

07:23.820 --> 07:25.820
Vn就相当于是jS

07:25.820 --> 07:27.820
就相当于是那个

07:30.460 --> 07:31.460
在这

07:31.460 --> 07:33.460
这个Vn就相当于是那个当前的组件

07:33.460 --> 07:35.460
调用这个Update

07:35.460 --> 07:37.460
然后这个调用Render

07:37.460 --> 07:39.460
这个Hydrating不用管

07:39.460 --> 07:41.460
就这么个意思

07:41.460 --> 07:43.460
因为我们哪里可以用到想应数数据呢

07:43.460 --> 07:45.460
是不是在Render的时候

07:45.460 --> 07:47.460
Render是不是生成距离节点

07:47.460 --> 07:48.460
那距离节点生成过程中

07:48.460 --> 07:50.460
是不是可能会用到一些

07:50.460 --> 07:52.460
当前组件的属性

07:52.460 --> 07:53.460
当前组件的数据

07:53.460 --> 07:55.460
那么就收取为一代了

07:55.460 --> 07:56.460
把6G为一代

07:56.460 --> 07:58.460
把Racher收取为一代

07:58.460 --> 08:00.460
将来数据变化

08:00.460 --> 08:02.460
我们又要得到新的

08:02.460 --> 08:04.460
就会重新运行这个函数

08:04.460 --> 08:06.460
那么就会得到新的距离动物数

08:06.460 --> 08:08.460
重新运行一次Render

08:08.460 --> 08:10.460
然后又重新运行Update

08:10.460 --> 08:12.460
把新的动物传进去

08:14.460 --> 08:15.460
OK

08:15.460 --> 08:17.460
那我们这几刻要讲的这个Dev

08:17.460 --> 08:19.460
就发生在这个Update

08:19.460 --> 08:20.460
函数的运行过程中

08:20.460 --> 08:21.460
我们这几刻

08:21.460 --> 08:22.460
之前我们研究了Render

08:22.460 --> 08:24.460
对吧 认件已经搞定了

08:24.460 --> 08:25.460
现在我们要研究一下

08:25.460 --> 08:27.460
这个距离节点数物生成出来了

08:27.460 --> 08:29.460
我交给了这个传输的Update

08:29.460 --> 08:31.460
那它到底是怎么做的

08:31.460 --> 08:33.460
怎么把这个界面更新的

08:33.460 --> 08:35.460
渲染到页面上去的

08:35.460 --> 08:37.460
怎么来处理这个差异的

08:37.460 --> 08:39.460
好 我们来看一下

08:39.460 --> 08:41.460
这个Update的函数

08:41.460 --> 08:43.460
Update的函数在干什么呢

08:43.460 --> 08:45.460
它接受到一个参数就是Vload

08:45.460 --> 08:48.460
那么这就是蓄力动物

08:48.460 --> 08:51.460
蓄力动物数的那个根结点

08:51.460 --> 08:53.460
这就是新生成的

08:53.460 --> 08:54.460
蓄力动物数

08:54.460 --> 08:56.460
就是当前的蓄力动物数

08:56.460 --> 08:58.460
同时Update的函数

08:58.460 --> 09:01.460
会通过当前组建的Vload属性

09:01.460 --> 09:02.460
还记得吗

09:02.460 --> 09:05.460
咱们每一个组建都有一个属性叫Vload

09:05.460 --> 09:07.460
这个Vload我们之前是见过的

09:07.460 --> 09:09.460
那么这个属性记录了什么

09:09.460 --> 09:11.460
记录了当前组建的

09:11.460 --> 09:14.460
当前就是之前的

09:14.460 --> 09:16.460
就是我们之前生成的一个

09:16.460 --> 09:17.460
蓄力动物数过后

09:17.460 --> 09:19.460
是不是挂在到这个Vload里边去了

09:19.460 --> 09:21.460
对吧 放到这里边去了

09:21.460 --> 09:22.460
那么现在又新生成的一个

09:22.460 --> 09:23.460
蓄力动物数

09:23.460 --> 09:25.460
这作为参数传进来了

09:25.460 --> 09:28.460
也就是Update函数了 是这个样子

09:28.460 --> 09:31.460
OK Update函数

09:31.460 --> 09:32.460
它传入一个Vload

09:32.460 --> 09:35.460
这个传入的Vload就是新的

09:35.460 --> 09:38.460
Vload就是新的

09:38.460 --> 09:40.460
然后之前的

09:40.460 --> 09:44.460
是不是就在ZSVload里面

09:44.460 --> 09:47.460
对不对 那么就是旧的

09:47.460 --> 09:49.460
那么怎么来对比新就两个数

09:49.460 --> 09:51.460
对比这两个

09:51.460 --> 09:53.460
知道了吧

09:53.460 --> 09:56.460
那么Update函数它会做什么事情呢

09:56.460 --> 09:58.460
它首先啊

09:58.460 --> 10:01.460
它会对这个Vload重新复制

10:01.460 --> 10:04.460
因为伟大码来表述就是这样子

10:04.460 --> 10:06.460
它会首先对这个Vload

10:06.460 --> 10:08.460
因为这是还是一个旧的数对吧

10:08.460 --> 10:10.460
那么我给它复制为新的数

10:10.460 --> 10:12.460
这样子呢一来

10:12.460 --> 10:15.460
先不说什么真实动物

10:15.460 --> 10:17.460
至少蓄力动物现在是不是已经正确了

10:17.460 --> 10:20.460
所以它做的事情特别特别简单

10:20.460 --> 10:22.460
你之前有一颗数

10:22.460 --> 10:24.460
现在有一颗数传来了

10:24.460 --> 10:25.460
我要更新

10:25.460 --> 10:27.460
那我就让现在的蓄力节点

10:27.460 --> 10:29.460
指向新的数就完事了

10:29.460 --> 10:31.460
对吧 但是这样子

10:31.460 --> 10:33.460
虽然蓄力节点正确了

10:33.460 --> 10:35.460
但是真实动物还不正确

10:35.460 --> 10:37.460
没有改变真实动物

10:37.460 --> 10:39.460
所以说呢 如果说只看蓄力动物的话

10:39.460 --> 10:41.460
这一步就已经结束了

10:41.460 --> 10:42.460
就已经OK了

10:42.460 --> 10:44.460
但是我要搞定真实动物

10:44.460 --> 10:46.460
那怎么办呢 那就必须要进行Def

10:46.460 --> 10:48.460
进行比较

10:48.460 --> 10:50.460
旧的那颗数它可以暂存起来

10:50.460 --> 10:52.460
old load

10:52.460 --> 10:53.460
v load

10:53.460 --> 10:56.020
等于什么

10:56.020 --> 10:57.020
this v load

10:57.020 --> 10:59.020
对吧 这个单码很好理解吧

10:59.020 --> 11:00.020
我先把之前的那颗数

11:00.020 --> 11:02.020
保存到这个变量里面

11:02.020 --> 11:04.020
然后呢让我现在这个

11:04.020 --> 11:06.020
蓄力节点数呢指向新的

11:06.020 --> 11:07.020
那么我们要对比什么

11:07.020 --> 11:08.020
对比它和它

11:08.020 --> 11:09.020
对吧

11:09.020 --> 11:10.020
对比的目的是什么

11:10.020 --> 11:11.020
要搞清楚

11:11.020 --> 11:13.020
对比的目的是为了

11:13.020 --> 11:16.020
对比的目的是为了

11:16.020 --> 11:18.020
更新真实动物

11:18.020 --> 11:20.020
如果说不考虑真实动物的话

11:20.020 --> 11:21.020
这件事就完了

11:21.020 --> 11:22.020
就结束了

11:22.020 --> 11:23.020
还要做啥吗

11:23.020 --> 11:24.020
不用做啥了

11:24.020 --> 11:25.020
但是我们界面上

11:25.020 --> 11:26.020
看不到变化

11:26.020 --> 11:27.020
虽然蓄力节点已经正确

11:27.020 --> 11:28.020
看不到变化

11:28.020 --> 11:30.020
为什么 因为真实动物没有变

11:30.020 --> 11:32.020
真实动物还跟旧的数是一样的

11:32.020 --> 11:33.020
所以对比的目的

11:33.020 --> 11:36.020
是要控制真实动物

11:36.020 --> 11:37.020
这就是

11:37.020 --> 11:39.020
update函数而做的事

11:39.020 --> 11:40.020
所以说

11:40.020 --> 11:41.020
首先呢

11:41.020 --> 11:42.020
让它指向新的数

11:42.020 --> 11:44.020
那么新的数就已经OK了

11:44.020 --> 11:45.020
你看着

11:45.020 --> 11:47.020
比方这个节点发生变化了

11:47.020 --> 11:48.020
它之前有一个数

11:48.020 --> 11:49.020
然后呢

11:49.020 --> 11:50.020
我们现在变化了过后

11:50.020 --> 11:52.020
是不是会触发这个watcher

11:52.020 --> 11:54.020
触发watcher就会运行这个函数

11:54.020 --> 11:56.020
这个函数就会重新运行

11:56.020 --> 11:57.020
那么过去形成一个新的数

11:57.020 --> 11:58.020
然后重新运行update

11:58.020 --> 12:00.020
那么update首先要做的事情

12:00.020 --> 12:01.020
就让这个节点的关联的

12:01.020 --> 12:03.020
就是一个下滑线V漏的

12:03.020 --> 12:05.020
它指向新的数

12:05.020 --> 12:06.020
然后接下来还没完

12:06.020 --> 12:07.020
我要更新真实动物

12:07.020 --> 12:08.020
所以说要进行

12:08.020 --> 12:09.020
地幅算法

12:09.020 --> 12:11.020
那么地幅算法的过程呢

12:11.020 --> 12:12.020
在5u里边

12:12.020 --> 12:13.020
它是一个函数完成的

12:13.020 --> 12:15.020
函数名字叫patch

12:15.020 --> 12:16.020
所以我们有的时候

12:16.020 --> 12:19.020
把5u里边的dev也叫patch算法

12:19.020 --> 12:22.020
好 接下来我们继续往后看

12:22.020 --> 12:24.020
那么接下来它要做什么事情呢

12:24.020 --> 12:26.020
它首先要看一下

12:26.020 --> 12:27.020
救的数是不是存在

12:27.020 --> 12:29.020
因为它有可能的话

12:29.020 --> 12:30.020
是第一次

12:30.020 --> 12:34.020
它有可能是第一次渲染

12:34.020 --> 12:35.020
第一次渲染的时候

12:35.020 --> 12:36.020
它没有救出的吧

12:36.020 --> 12:37.020
唯独的为空

12:37.020 --> 12:38.020
唯浪

12:38.020 --> 12:39.020
或者是为安迪范

12:39.020 --> 12:40.020
它总之它没有救的东西

12:40.020 --> 12:42.020
那么它只有一颗新的数

12:42.020 --> 12:43.020
那么这个时候

12:43.020 --> 12:45.020
其实做的事情特别特别简单

12:45.020 --> 12:46.020
不涉及到patch

12:46.020 --> 12:47.020
不涉及到对比

12:47.020 --> 12:49.020
它做的事情特别简单

12:49.020 --> 12:50.020
那怎么做呢

12:50.020 --> 12:52.020
如果说救的数不存在的话

12:52.020 --> 12:53.020
那么也就是说

12:53.020 --> 12:55.020
它下面接下来在这里

12:55.020 --> 12:56.020
在对比的时候

12:56.020 --> 12:58.020
它发现这个o的v漏的是

12:58.020 --> 12:59.020
或者是安迪范的

12:59.020 --> 13:00.020
就是没东西

13:00.020 --> 13:01.020
没东西的话

13:01.020 --> 13:03.020
它做的事情特别简单

13:03.020 --> 13:05.020
它就按照这个新的v漏的

13:05.020 --> 13:07.020
生成真实动物就OK了

13:07.020 --> 13:08.020
那么这件事情呢

13:08.020 --> 13:09.020
我相信同学们

13:09.020 --> 13:11.020
不少的同学都能自己

13:11.020 --> 13:12.020
自己弄得出来

13:12.020 --> 13:14.020
就是一个数的便利

13:14.020 --> 13:15.020
对吧

13:15.020 --> 13:16.020
v都是一个根据点

13:16.020 --> 13:17.020
便利这颗数

13:17.020 --> 13:18.020
每便利一个节点

13:18.020 --> 13:19.020
根据一个节点的信息

13:19.020 --> 13:21.020
去创建真实动物

13:21.020 --> 13:23.020
就完事了

13:23.020 --> 13:24.020
于是呢

13:24.020 --> 13:26.020
如果说第一次加载组建

13:26.020 --> 13:27.020
于是它会调用内部的

13:27.020 --> 13:28.020
patch函数

13:28.020 --> 13:29.020
它实际上

13:29.020 --> 13:30.020
为什么说这里还会调用

13:30.020 --> 13:31.020
patch函数呢

13:31.020 --> 13:32.020
patch就是对比的函数

13:32.020 --> 13:34.020
它会传两个参数进去

13:34.020 --> 13:36.020
一个参数呢就是

13:37.020 --> 13:38.020
顺便说一下

13:38.020 --> 13:40.020
它的一个小的细节

13:40.020 --> 13:42.020
但是本质上都是一样的

13:42.020 --> 13:43.020
那么如果说

13:43.020 --> 13:44.020
一个是闹的话

13:44.020 --> 13:45.020
它会传两个参数进去

13:45.020 --> 13:47.020
一个是新的节点

13:47.020 --> 13:49.020
一个是新的节点

13:49.020 --> 13:50.020
一个是旧的节点

13:50.020 --> 13:51.020
旧的节点呢

13:51.020 --> 13:52.020
由于是闹

13:52.020 --> 13:53.020
它会传一个什么

13:53.020 --> 13:55.020
传一个真实动物元素

13:55.020 --> 13:56.020
就是我们平时

13:56.020 --> 13:57.020
无忧的挂载的时候

13:57.020 --> 13:58.020
是不是一个真实动物元素

13:58.020 --> 14:00.020
不管是组建还是根实力

14:00.020 --> 14:02.020
都会有个真实动物

14:02.020 --> 14:03.020
组建的真实动物

14:03.020 --> 14:04.020
就是副组建的位置的

14:04.020 --> 14:06.020
那个副元素

14:06.020 --> 14:07.020
总之它会

14:07.020 --> 14:08.020
会有一个真实动物

14:08.020 --> 14:09.020
就是应该把真实的

14:09.020 --> 14:11.020
真实的动物挂在耳区

14:12.020 --> 14:14.020
那么这个时候呢

14:14.020 --> 14:15.020
它传这个派系

14:15.020 --> 14:16.020
派系还说

14:16.020 --> 14:17.020
就传递了两个参数

14:17.020 --> 14:18.020
相当于是这里

14:18.020 --> 14:20.020
说如果说

14:25.020 --> 14:27.020
把它显成伟蛋了

14:30.400 --> 14:33.480
一些伟蛋

14:33.480 --> 14:37.900
如果说

14:44.280 --> 14:47.230
没东西

14:47.230 --> 14:48.230
没东西的话

14:48.230 --> 14:49.230
我就会运行派系

14:50.230 --> 14:51.230
它派系呢

14:51.230 --> 14:52.230
实际上它是内部的

14:52.230 --> 14:53.230
一个函数叫派系

14:53.230 --> 14:55.230
是这么一个函数

14:55.230 --> 14:57.230
能不能找到啊

14:57.230 --> 15:00.820
往下走

15:00.820 --> 15:02.820
就这个函数

15:02.820 --> 15:03.820
其实这个函数

15:03.820 --> 15:04.820
里边呢

15:04.820 --> 15:05.820
它是调用了另外一个模块的

15:05.820 --> 15:06.820
派系都差不多

15:06.820 --> 15:07.820
都差不多

15:07.820 --> 15:08.820
它会调用这个函数

15:08.820 --> 15:09.820
它传入一个

15:09.820 --> 15:10.820
它传入一个旧的节点

15:10.820 --> 15:11.820
是什么的

15:11.820 --> 15:12.820
旧的节点呢

15:12.820 --> 15:13.820
就是一个EL

15:13.820 --> 15:14.820
这个EL哪来的呢

15:14.820 --> 15:15.820
就是ZS

15:15.820 --> 15:17.820
就当前组建的

15:17.820 --> 15:18.820
那个EL

15:18.820 --> 15:20.820
每个组建系都有一个EL

15:21.820 --> 15:23.820
就是那个元素位置

15:23.820 --> 15:24.820
这个组建的生成东西

15:24.820 --> 15:26.820
应该放哪个元素的位置

15:26.820 --> 15:27.820
就这么个意思

15:27.820 --> 15:28.820
然后呢

15:28.820 --> 15:30.820
传入一个新的节点

15:30.820 --> 15:31.820
它会

15:31.820 --> 15:32.820
用一个真实动物

15:32.820 --> 15:34.820
跟那个新的虚拟动物

15:34.820 --> 15:35.820
进行对比

15:35.820 --> 15:36.820
那么这样子一对比的

15:36.820 --> 15:37.820
其实最终的结果

15:37.820 --> 15:38.820
就都一样

15:38.820 --> 15:39.820
它会新成

15:39.820 --> 15:40.820
按照这个东西

15:40.820 --> 15:41.820
它不管了

15:41.820 --> 15:42.820
它只会按照它

15:42.820 --> 15:44.820
来生成一个新的虚拟动物

15:44.820 --> 15:46.820
新的那个真实动物

15:47.820 --> 15:48.820
然后呢

15:48.820 --> 15:49.820
把个真实动物的根结点

15:49.820 --> 15:50.820
挂得到这个位置

15:50.820 --> 15:51.820
它就做这么一件事

15:51.820 --> 15:52.820
说这个过程呢

15:52.820 --> 15:53.820
其实特别简单

15:54.820 --> 15:55.820
那么我们来看一下

15:55.820 --> 15:56.820
下面这张图

15:56.820 --> 15:57.820
如果说它没有旧的动物

15:57.820 --> 15:58.820
特别简单

15:58.820 --> 16:00.820
按照新的虚拟动物数

16:00.820 --> 16:01.820
循环遍地

16:01.820 --> 16:02.820
地规

16:02.820 --> 16:03.820
那个地规

16:03.820 --> 16:04.820
随便怎么地规都行

16:04.820 --> 16:05.820
你可以

16:05.820 --> 16:07.820
那个生收

16:07.820 --> 16:08.820
就是

16:08.820 --> 16:09.820
生度遍地

16:09.820 --> 16:11.820
也可以广度遍地

16:11.820 --> 16:12.820
总之你把遍地完成

16:12.820 --> 16:14.820
完成过后呢

16:14.820 --> 16:16.820
每循环到一个节点

16:16.820 --> 16:17.820
那么按照这个节点

16:17.820 --> 16:18.820
提供的信息

16:18.820 --> 16:19.820
因为我们知道

16:19.820 --> 16:20.820
很多信息

16:20.820 --> 16:22.820
那么这个元素的

16:22.820 --> 16:23.820
标签名

16:24.820 --> 16:26.820
这个元素的各种属性

16:26.820 --> 16:27.820
这个元素里边

16:27.820 --> 16:28.820
有哪些事件

16:28.820 --> 16:29.820
全部都记住好了

16:29.820 --> 16:30.820
那么你按照它

16:30.820 --> 16:31.820
记住的东西

16:31.820 --> 16:32.820
生成虚拟动

16:34.820 --> 16:35.820
刚才我还忘了说

16:35.820 --> 16:37.820
一个非常重要的点

16:37.820 --> 16:38.820
就是我们生成虚拟动物数

16:38.820 --> 16:40.820
再次重生

16:40.820 --> 16:41.820
是一个组件

16:41.820 --> 16:42.820
对于一颗虚拟动物数

16:42.820 --> 16:43.820
哪个组件更新了

16:43.820 --> 16:45.820
我只选了

16:45.820 --> 16:46.820
调用那个组件的

16:46.820 --> 16:48.820
每个组件都有一个这个东西

16:48.820 --> 16:49.820
你看我是在

16:49.820 --> 16:50.820
构造函数内部写的

16:50.820 --> 16:51.820
说每个组件

16:51.820 --> 16:53.820
都是一个构造函数的实力

16:53.820 --> 16:55.820
每个组件都有这么一个函数

16:55.820 --> 16:56.820
所以说

16:56.820 --> 16:58.820
当某一个数据变化的时候

16:58.820 --> 17:00.820
运行的是某一个组件的

17:00.820 --> 17:01.820
这个东西

17:01.820 --> 17:03.820
那么生成的是某一个

17:03.820 --> 17:04.820
组件的虚拟动物数

17:05.820 --> 17:06.820
我们回到这儿来

17:07.820 --> 17:09.820
刚才循环遍地

17:09.820 --> 17:10.820
每一个节点

17:10.820 --> 17:11.820
那么是不是可以

17:11.820 --> 17:12.820
通过这个节点

17:12.820 --> 17:13.820
去生成一个真实动

17:13.820 --> 17:15.820
换件元素呗

17:15.820 --> 17:16.820
然后给一个元素

17:16.820 --> 17:17.820
设置各种属性

17:17.820 --> 17:18.820
还有什么时间

17:18.820 --> 17:19.820
有加什么时间

17:19.820 --> 17:20.820
对吧

17:20.820 --> 17:21.820
就生成真实动物了

17:21.820 --> 17:22.820
然后呢

17:22.820 --> 17:23.820
把每一个虚拟节点

17:23.820 --> 17:25.820
是不是有个属性叫AOM

17:25.820 --> 17:26.820
还记得吗

17:27.820 --> 17:28.820
每一个虚拟节点

17:28.820 --> 17:30.820
都有个属性叫做AOM

17:30.820 --> 17:31.820
它进入它的真实节点

17:31.820 --> 17:33.820
它一开始是NOW

17:33.820 --> 17:35.820
一开始肯定没有这个AOM

17:35.820 --> 17:36.820
Element

17:37.820 --> 17:38.820
然后每一个节点

17:38.820 --> 17:39.820
是不是生成一个真实动物

17:39.820 --> 17:41.820
然后把个真实动物呢

17:41.820 --> 17:43.820
设置到这个虚拟节点的AOM里边

17:43.820 --> 17:44.820
这个过程

17:44.820 --> 17:46.820
这个这一步是很重要的

17:46.820 --> 17:47.820
非常重要的

17:47.820 --> 17:48.820
是不是

17:48.820 --> 17:49.820
那么这样子

17:49.820 --> 17:50.820
就每一个虚拟节点

17:50.820 --> 17:51.820
对应一个真实节点

17:51.820 --> 17:52.820
每个虚拟节点

17:52.820 --> 17:53.820
对应一个真实节点

17:53.820 --> 17:54.820
当然它会设置

17:54.820 --> 17:55.820
这个真实节点之间的

17:55.820 --> 17:56.820
复制关系

17:56.820 --> 17:57.820
这个东西也不难

17:57.820 --> 17:59.820
设置好了过后

17:59.820 --> 18:00.820
那么这样子

18:00.820 --> 18:01.820
然后把个真实节点

18:01.820 --> 18:02.820
根结点挂得到哪呢

18:02.820 --> 18:03.820
挂得到这个位置

18:04.820 --> 18:05.820
对吧

18:05.820 --> 18:06.820
那么这样子

18:06.820 --> 18:07.820
一做

18:07.820 --> 18:08.820
元素就创建出来了

18:08.820 --> 18:09.820
创建好了

18:09.820 --> 18:10.820
各种元素

18:10.820 --> 18:11.820
然后把它

18:11.820 --> 18:12.820
设置到一面的

18:12.820 --> 18:13.820
某一个位置

18:13.820 --> 18:14.820
是不是就完事了

18:14.820 --> 18:15.820
这是第一次

18:15.820 --> 18:16.820
存在的时候

18:16.820 --> 18:17.820
要做的事情特别简单

18:17.820 --> 18:18.820
但是这样子

18:18.820 --> 18:19.820
这个地方

18:19.820 --> 18:20.820
也不是面试

18:20.820 --> 18:21.820
要考察的内容

18:21.820 --> 18:22.820
面试主要考察的

18:22.820 --> 18:23.820
就是就数存在

18:24.820 --> 18:26.820
那么就是什么情况呢

18:26.820 --> 18:27.820
你看那个图

18:27.820 --> 18:28.820
就是说我现在

18:28.820 --> 18:29.820
有一颗就数

18:30.820 --> 18:31.820
它之前一生成好的数

18:31.820 --> 18:32.820
你看

18:32.820 --> 18:33.820
之前的那个

18:33.820 --> 18:35.820
组建的V漏的

18:35.820 --> 18:37.820
是不是指向它的

18:37.820 --> 18:38.820
对不对

18:38.820 --> 18:39.820
好

18:39.820 --> 18:40.820
现在呢

18:40.820 --> 18:42.820
由于我们数据变化

18:42.820 --> 18:43.820
属性变化

18:43.820 --> 18:44.820
然后导致

18:44.820 --> 18:45.820
我们运行了

18:45.820 --> 18:46.820
update还说

18:46.820 --> 18:47.820
又重新的生成了一颗数

18:49.820 --> 18:50.820
一个新数

18:50.820 --> 18:51.820
这个新数的结构

18:51.820 --> 18:53.820
可能跟就数不一样

18:53.820 --> 18:54.820
而且新数里面

18:54.820 --> 18:55.820
是没有真实节点的

18:55.820 --> 18:56.820
没有真实元素的

18:57.820 --> 18:58.820
那么现在

18:58.820 --> 18:59.820
它要做的事情

18:59.820 --> 19:00.820
我们刚才说了

19:00.820 --> 19:01.820
它首先要做的事情

19:01.820 --> 19:03.820
是把这个V漏的属性

19:03.820 --> 19:04.820
给它变一下

19:05.820 --> 19:06.820
之前是指向这的

19:06.820 --> 19:07.820
对吧

19:07.820 --> 19:08.820
现在不再指向这了

19:08.820 --> 19:09.820
现在指向谁呢

19:09.820 --> 19:10.820
指向这

19:11.820 --> 19:12.820
指向新数

19:12.820 --> 19:13.820
那就数呢

19:13.820 --> 19:14.820
我用一个变量保存

19:14.820 --> 19:15.820
那么接下来

19:15.820 --> 19:16.820
问题是

19:16.820 --> 19:17.820
我新数已经正确了

19:18.820 --> 19:19.820
虚动数已经正确了

19:19.820 --> 19:20.820
那怎么样

19:20.820 --> 19:22.820
才能跟就数最对比

19:22.820 --> 19:23.820
然后最终来打到

19:23.820 --> 19:25.820
改变真实

19:25.820 --> 19:26.820
改变这个

19:27.820 --> 19:28.820
真实动物的目的

19:29.820 --> 19:30.820
而且不仅如此

19:30.820 --> 19:31.820
我还要把这些

19:31.820 --> 19:32.820
真实动物呢

19:33.820 --> 19:35.820
挂载到新数里面去

19:35.820 --> 19:36.820
就要做这么一个过程

19:36.820 --> 19:37.820
也就是说我要

19:37.820 --> 19:38.820
拍起算法

19:38.820 --> 19:39.820
核心要做的事情就是

19:39.820 --> 19:40.820
根据这两个东西

19:41.820 --> 19:42.820
变成这个样子

19:43.820 --> 19:44.820
没了意思吧

19:44.820 --> 19:45.820
该创建新的元素

19:45.820 --> 19:46.820
要创建新的元素

19:46.820 --> 19:47.820
该删除旧的元素

19:47.820 --> 19:48.820
要删除旧的元素

19:48.820 --> 19:49.820
该移动就要移动

19:49.820 --> 19:50.820
没了意思吧

19:50.820 --> 19:52.820
所以说它最核心的

19:53.820 --> 19:55.820
是要做这么两件事

19:56.820 --> 19:58.820
完成所有真实动物的

19:58.820 --> 20:00.820
注意小化处理

20:00.820 --> 20:01.820
就哪些真实动物

20:01.820 --> 20:02.820
需要新创建

20:02.820 --> 20:03.820
哪些真实动物

20:03.820 --> 20:04.820
需要销毁

20:04.820 --> 20:05.820
哪些真实动物

20:05.820 --> 20:06.820
需要移动

20:06.820 --> 20:07.820
哪些真实动物

20:07.820 --> 20:08.820
需要更改属性

20:08.820 --> 20:09.820
但是尽量的

20:09.820 --> 20:10.820
不要改动太大

20:10.820 --> 20:11.820
因为真实动物操作

20:11.820 --> 20:12.820
是比较耗费效率的

20:13.820 --> 20:14.820
比较花时间的

20:14.820 --> 20:15.820
注意小化处理真实动物

20:16.820 --> 20:17.820
然后让新数的节点

20:17.820 --> 20:19.820
对应到合适的真实动物

20:19.820 --> 20:20.820
就是现在的哪个节点

20:20.820 --> 20:22.820
要对应之前的哪个真实动物

20:22.820 --> 20:23.820
就这么个意思

20:23.820 --> 20:24.820
这就是拍效的过程

20:24.820 --> 20:25.820
好 接下来

20:25.820 --> 20:26.820
看一下拍起的过程

20:26.820 --> 20:29.140
它对比流程

20:29.140 --> 20:30.140
首先为了

20:30.140 --> 20:32.140
为了后边方便解释

20:32.140 --> 20:33.140
我给大家

20:33.140 --> 20:34.140
首先要说一些数语

20:34.140 --> 20:35.140
以后我说到

20:35.140 --> 20:36.140
看到这个兼兼符号

20:36.140 --> 20:37.140
这个兼兼符号结束

20:37.140 --> 20:38.140
说明号开始

20:38.140 --> 20:39.140
说明号结束

20:39.140 --> 20:40.140
然后这里边

20:40.140 --> 20:41.140
就表示这个意思

20:41.140 --> 20:42.140
我给大家首先解释一下

20:42.140 --> 20:44.140
以后反而看到这个东西

20:44.140 --> 20:45.140
相同

20:45.140 --> 20:46.140
那么什么叫相同呢

20:46.140 --> 20:48.140
指的是两个节点的

20:48.140 --> 20:49.140
标签内容

20:51.140 --> 20:52.140
同时

20:52.140 --> 20:53.140
气质

20:53.140 --> 20:54.140
均相同

20:55.140 --> 20:56.140
音铺这边

20:56.140 --> 20:57.140
还要看type属性

20:57.140 --> 20:58.140
注意哦

20:58.140 --> 20:59.140
这是指的是两个虚拟节点

21:01.140 --> 21:02.140
好 我来描述一下

21:02.140 --> 21:03.140
这是啥意思

21:06.140 --> 21:07.140
比方说吧

21:07.140 --> 21:08.140
比方说

21:09.140 --> 21:10.140
我这里

21:11.140 --> 21:12.140
我这里随便写个啊

21:14.140 --> 21:15.140
随便写两个两个节点

21:19.140 --> 21:20.140
寻哪儿呢

21:20.140 --> 21:21.140
我就

21:21.140 --> 21:22.140
我写这吧

21:22.140 --> 21:32.580
相同

21:33.580 --> 21:34.580
什么叫相同

21:35.580 --> 21:39.740
好 比方说

21:39.740 --> 21:41.740
我现在有两个元素

21:42.740 --> 21:43.740
两个元素

21:43.740 --> 21:46.250
一个元素呢

21:46.250 --> 21:47.250
是这样子的

21:47.250 --> 21:49.250
它最终会生成虚拟节点

21:49.250 --> 21:50.250
对吧

21:51.250 --> 21:52.250
一个元素是

21:53.250 --> 21:55.250
我们写个简单点的

21:56.250 --> 21:58.250
另外一个也是

22:00.250 --> 22:01.250
那么请问

22:01.250 --> 22:02.250
在我们刚才的定义下

22:02.250 --> 22:03.250
这两个

22:03.250 --> 22:04.250
相不相同呢

22:06.250 --> 22:07.250
什么叫相同

22:07.250 --> 22:08.250
相同的定义是啥

22:08.250 --> 22:10.250
是指两个虚拟节点的

22:10.250 --> 22:11.250
标签内容

22:13.250 --> 22:14.250
气质均相同

22:14.250 --> 22:15.250
但音铺这元素

22:15.250 --> 22:16.250
还看type属性

22:16.250 --> 22:17.250
那么这里是不是音铺这元素

22:17.250 --> 22:18.250
不是吧

22:18.250 --> 22:19.250
那么就看什么

22:19.250 --> 22:21.250
它们的标签内容

22:21.250 --> 22:22.250
相不相同

22:22.250 --> 22:23.250
标签内容是什么

22:23.250 --> 22:24.250
都是一起

22:25.250 --> 22:26.250
相同的对吧

22:26.250 --> 22:27.250
那么key值相不相同

22:27.250 --> 22:28.250
什么叫key值

22:28.250 --> 22:29.250
就是我们平时

22:29.250 --> 22:31.250
特别是写循环的时候

22:31.250 --> 22:32.250
循环元素

22:32.250 --> 22:33.250
生成元素的时候

22:33.250 --> 22:34.250
会写个key

22:34.250 --> 22:35.250
对吧

22:35.250 --> 22:36.250
用v4的时候

22:36.250 --> 22:37.250
会写个key

22:37.250 --> 22:38.250
对不对

22:38.250 --> 22:39.250
那个就是key值

22:39.250 --> 22:40.250
其实不仅v4里面

22:40.250 --> 22:41.250
可以写key

22:41.250 --> 22:42.250
任何元素

22:42.250 --> 22:44.250
在任何地方都可以写key

22:44.250 --> 22:45.250
要这意思吧

22:45.250 --> 22:46.250
都可以写key

22:46.250 --> 22:47.250
好 那么我们来看一下

22:47.250 --> 22:48.250
那现在key值相不相同呢

22:49.250 --> 22:50.250
现在key值

22:50.250 --> 22:52.250
而如果是不是你没有写key值

22:52.250 --> 22:53.250
好 没有写key值

22:53.250 --> 22:55.250
它生成就是生成两个蓄力动物

22:55.250 --> 22:56.250
一个蓄力动物呢

22:56.250 --> 22:57.250
是这个样子的

22:58.250 --> 23:00.250
就是tag

23:00.250 --> 23:01.250
vnq

23:02.250 --> 23:03.250
key值是什么

23:03.250 --> 23:04.250
我们只看关键信息

23:04.250 --> 23:05.250
key值是undefined

23:07.250 --> 23:08.250
另一个蓄力动物

23:08.250 --> 23:09.250
是不是也是一样的

23:09.250 --> 23:10.250
那你说

23:10.250 --> 23:11.250
这两个蓄力动物

23:11.250 --> 23:12.250
相不相同

23:12.250 --> 23:13.250
它们就相同

23:13.250 --> 23:15.250
不用去看它的内部元素

23:15.250 --> 23:17.250
不用去看它内部元素

23:17.250 --> 23:18.250
内部元素

23:18.250 --> 23:20.250
那是文闷节点

23:20.250 --> 23:21.250
我们不用去看它

23:21.250 --> 23:22.250
这两个是相同的

23:22.250 --> 23:24.250
好 我们再来看

23:25.250 --> 23:27.250
如果说是这种情况

23:27.250 --> 23:31.930
key

23:32.930 --> 23:33.930
w1

23:33.930 --> 23:35.930
这里有key

23:35.930 --> 23:39.300
key2

23:39.300 --> 23:41.300
那么这两个蓄力动物

23:41.300 --> 23:42.300
相不相同

23:42.300 --> 23:44.300
所以不相同

23:44.300 --> 23:45.300
为什么 因为key值不同

23:45.300 --> 23:46.300
必须要key值和标象内容

23:46.300 --> 23:47.300
玩都一样

23:47.300 --> 23:48.300
它要相同

23:48.300 --> 23:50.300
好 再来看

23:50.300 --> 23:52.300
如果说这种情况

23:53.300 --> 23:54.300
input元素

23:55.300 --> 23:56.300
input元素

23:56.300 --> 23:58.300
它除了看key值

23:58.300 --> 24:00.300
和看标签内容之外

24:00.300 --> 24:01.300
还要看什么

24:01.300 --> 24:02.300
还要看type属性

24:03.300 --> 24:04.300
因为input元素

24:04.300 --> 24:06.300
type属性的差异比较大

24:12.200 --> 24:13.200
那么这两个相不相同

24:13.200 --> 24:14.200
它就不相同

24:14.200 --> 24:15.200
因为它还要看type属性

24:16.200 --> 24:17.200
这就是什么样相同

24:17.200 --> 24:19.200
先把这个数语解释清楚

24:19.200 --> 24:20.200
其实这个玩意

24:20.200 --> 24:22.200
在Wu的圆码里面

24:22.200 --> 24:23.200
是一个函数

24:23.200 --> 24:24.200
叫做

24:24.200 --> 24:25.200
叫做synload

24:25.200 --> 24:26.200
synvload

24:26.200 --> 24:27.200
它判断两个蓄力动物

24:27.200 --> 24:28.200
蓄力减点是不是

24:28.200 --> 24:29.200
同一个蓄力减点

24:30.200 --> 24:31.200
好

24:31.200 --> 24:33.200
然后再看这个

24:33.200 --> 24:34.200
abc

24:34.200 --> 24:36.200
和bcd相不相同

24:36.200 --> 24:39.510
这有点反直觉

24:39.510 --> 24:40.510
相不相同呢

24:40.510 --> 24:42.510
相同的

24:42.510 --> 24:43.510
为什么呢

24:43.510 --> 24:45.510
他们的内容是什么

24:45.510 --> 24:47.510
他们深深的蓄力减点

24:47.510 --> 24:48.510
type

24:48.510 --> 24:49.510
他们没有表现

24:49.510 --> 24:50.510
对吧

24:50.510 --> 24:51.510
没有表现

24:51.510 --> 24:52.510
type就是indefend

24:53.510 --> 24:54.510
indefend

24:54.510 --> 24:56.510
它是这样子的

24:56.510 --> 24:57.510
indefend

24:58.510 --> 24:59.510
它的什么

24:59.510 --> 25:00.510
keyz呢

25:00.510 --> 25:02.510
肯定就没有keyz

25:02.510 --> 25:03.510
indefend

25:04.510 --> 25:05.510
它也没发射式keyz

25:05.510 --> 25:06.510
对吧

25:06.510 --> 25:07.510
然后它有一个type属性

25:08.510 --> 25:09.510
abc

25:10.510 --> 25:11.510
因为它是这样子的

25:11.510 --> 25:12.510
另外一个蓄力动物

25:12.510 --> 25:13.510
是这样子的

25:13.510 --> 25:16.780
bcd

25:17.780 --> 25:18.780
所以它比较两个蓄力动物的时候

25:18.780 --> 25:19.780
看了什么

25:19.780 --> 25:20.780
type

25:21.780 --> 25:22.780
看不看这个

25:23.780 --> 25:24.780
它为什么要用

25:24.780 --> 25:25.780
这种方式来比较

25:25.780 --> 25:27.780
为什么不完全比较呢

25:27.780 --> 25:28.780
注意

25:28.780 --> 25:29.780
为什么呢

25:29.780 --> 25:30.780
因为它相不相同

25:30.780 --> 25:31.780
它会影响到

25:31.780 --> 25:33.780
后边它的处理方式

25:33.780 --> 25:34.780
相同的过程

25:34.780 --> 25:36.780
它不是说不处理

25:36.780 --> 25:37.780
它还是要处理的

25:37.780 --> 25:39.780
但是它就不会去

25:39.780 --> 25:40.780
删除那个元素

25:40.780 --> 25:42.780
不会去动那个元素

25:42.780 --> 25:43.780
知道吧

25:43.780 --> 25:45.780
它只是改动这个元素就行了

25:45.780 --> 25:46.780
对吧

25:46.780 --> 25:47.780
它是这么个意识

25:47.780 --> 25:49.780
它是不是同一个内容的东西

25:49.780 --> 25:51.780
就是我能不能去改动它

25:51.780 --> 25:52.780
而不要去删除它

25:52.780 --> 25:53.780
就这么个意识

25:53.780 --> 25:54.780
你看这两个文贝节点

25:54.780 --> 25:55.780
虽然不一样

25:55.780 --> 25:56.780
但是当时是不是可以改动

25:56.780 --> 25:57.780
文贝节点了什么

25:57.780 --> 25:58.780
value

25:59.780 --> 26:00.780
load value

26:00.780 --> 26:01.780
就完事了

26:02.780 --> 26:03.780
这就是什么叫相同

26:03.780 --> 26:04.780
给它解释清楚

26:05.780 --> 26:06.780
第二个属于

26:06.780 --> 26:07.780
新建元素

26:07.780 --> 26:08.780
这个很好的意见

26:08.780 --> 26:10.780
使得是在一个虚拟节点

26:10.780 --> 26:11.780
根据一个虚拟节点

26:11.780 --> 26:12.780
提供的信息

26:12.780 --> 26:13.780
创建一个真实动物元素

26:13.780 --> 26:14.780
那么之前在

26:14.780 --> 26:15.780
第一次

26:15.780 --> 26:16.780
选了时候

26:16.780 --> 26:17.780
就在做这个事

26:17.780 --> 26:18.780
根据某一个节点

26:18.780 --> 26:20.780
创建一个真实动物

26:20.780 --> 26:21.780
然后把个真实动物

26:21.780 --> 26:22.780
放到这个节点

26:22.780 --> 26:23.780
哪个属性

26:23.780 --> 26:24.780
之前说过

26:24.780 --> 26:25.780
这个属性

26:27.780 --> 26:28.780
这个属性里面去

26:28.780 --> 26:29.780
这叫做创建元素

26:29.780 --> 26:30.780
以后我说到

26:30.780 --> 26:31.780
创建元素的都是这个意识

26:32.780 --> 26:34.780
什么叫消费元素

26:34.780 --> 26:35.780
就是非常简单

26:35.780 --> 26:36.780
就调用之前

26:36.780 --> 26:37.780
虚拟节点里面的AOM

26:37.780 --> 26:38.780
把它移除掉

26:38.780 --> 26:40.780
把个真实元素移除掉

26:40.780 --> 26:41.780
消费元素

26:41.780 --> 26:42.780
一说是真实元素

26:43.780 --> 26:44.780
什么叫更新呢

26:45.780 --> 26:47.780
是只对两个虚拟节点

26:47.780 --> 26:48.780
进行对比

26:49.780 --> 26:50.780
现在是要对比的

26:50.780 --> 26:51.780
就对比其中

26:51.780 --> 26:53.780
某两个真实节点

26:53.780 --> 26:54.780
比方说

26:54.780 --> 26:55.780
对比这个

26:55.780 --> 26:56.780
这个

26:57.780 --> 26:58.780
那么

26:58.780 --> 26:59.780
这叫做更新

27:00.780 --> 27:01.780
但是你要注意

27:01.780 --> 27:02.780
这里有一个田径条件

27:02.780 --> 27:04.780
它仅发生在

27:04.780 --> 27:05.780
两个虚拟节点

27:05.780 --> 27:06.780
相同

27:06.780 --> 27:07.780
是不是刚才解释过

27:07.780 --> 27:09.780
相同的情况下

27:10.780 --> 27:12.780
那么具体它怎么更新的

27:12.780 --> 27:13.780
因为相同才会

27:13.780 --> 27:14.780
让它再进行更新

27:14.780 --> 27:15.780
不相同的话

27:15.780 --> 27:17.780
可能就新建和消费了

27:17.780 --> 27:18.780
那么

27:18.780 --> 27:19.780
相同的时候

27:19.780 --> 27:20.780
具体怎么去更新的

27:20.780 --> 27:21.780
我们以后再说

27:22.780 --> 27:23.780
还有接下来下一个

27:24.780 --> 27:25.780
对比止节点

27:26.780 --> 27:27.780
是什么意思呢

27:27.780 --> 27:29.780
就是对两个虚拟节点

27:29.780 --> 27:30.780
止节点进行对比

27:30.780 --> 27:31.780
比方说

27:31.780 --> 27:32.780
它和它

27:32.780 --> 27:33.780
对比完了

27:33.780 --> 27:34.780
然后还没完

27:34.780 --> 27:36.780
还要把它的止节点

27:36.780 --> 27:38.780
和它的止节点进行对比

27:38.780 --> 27:40.780
实际上唯一的对比的时候

27:40.780 --> 27:41.780
实际上是遵循一个

27:41.780 --> 27:42.780
叫深度优先便利

27:43.780 --> 27:44.780
先看自己

27:44.780 --> 27:45.780
自己OK

27:45.780 --> 27:46.780
然后再看止节点

27:46.780 --> 27:47.780
对吧

27:47.780 --> 27:49.780
看每一个止节点的时候

27:49.780 --> 27:50.780
如果说这个止节点

27:51.780 --> 27:52.780
跟这个止节点

27:52.780 --> 27:53.780
OK

27:53.780 --> 27:54.780
那么再看这个止节点

27:54.780 --> 27:55.780
跟这个止节点

27:55.780 --> 27:56.780
所有止节点

27:56.780 --> 27:57.780
和它的所有止节点

27:57.780 --> 27:58.780
好

27:58.780 --> 27:59.780
然后这个OK了过后

27:59.780 --> 28:00.780
再看它

28:00.780 --> 28:01.780
再看它

28:01.780 --> 28:02.780
和它

28:02.780 --> 28:03.780
如果说这两个止节点

28:03.780 --> 28:04.780
OK

28:04.780 --> 28:05.780
那么这两个止节点

28:05.780 --> 28:06.780
OK了过后

28:06.780 --> 28:07.780
还要看它

28:07.780 --> 28:08.780
和它

28:08.780 --> 28:10.780
原来的意思吧

28:10.780 --> 28:11.780
是深度优先的

28:13.780 --> 28:15.780
我这里给大家

28:15.780 --> 28:16.780
画一张图吧

28:16.780 --> 28:19.420
比方说

28:19.420 --> 28:20.420
这里有一个

28:22.420 --> 28:23.420
这样

28:23.420 --> 28:24.420
弄个圆

28:24.420 --> 28:30.380
这是一个

28:30.380 --> 28:32.380
我就简单的画一下

28:32.380 --> 28:38.590
这样

28:39.590 --> 28:40.590
这样

28:40.590 --> 28:41.590
这样

28:42.590 --> 28:45.160
这样

28:45.160 --> 28:49.650
这样

28:49.650 --> 28:50.650
然后另一棵树

28:50.650 --> 28:52.650
另一棵树是这样

28:52.650 --> 28:53.650
这样

28:53.650 --> 28:54.650
这样

28:54.650 --> 28:55.650
这样

28:55.650 --> 28:57.650
就画得一样吧

28:57.650 --> 28:58.650
行就两棵树

28:58.650 --> 28:59.650
然后我简单的

28:59.650 --> 29:00.650
给它点一点吧

29:00.650 --> 29:01.650
简单点一点

29:06.370 --> 29:07.370
简单说一下

29:07.370 --> 29:08.370
它的对比

29:08.370 --> 29:09.370
它的对比顺序

29:09.370 --> 29:10.370
它怎么对比的

29:11.370 --> 29:12.370
它对比顺序是怎么样的

29:12.370 --> 29:13.370
它是这样子

29:13.370 --> 29:15.370
首先对比这一块

29:15.370 --> 29:17.370
首先对比这一块

29:17.370 --> 29:18.370
这两个节点

29:19.370 --> 29:21.370
那么对比OK了过后

29:21.370 --> 29:23.370
那么接下来对比它的止元数

29:23.370 --> 29:25.370
这两个节点的止元数

29:25.370 --> 29:26.370
好

29:26.370 --> 29:27.370
但是对比止元数的时候

29:27.370 --> 29:28.370
是一次对比的

29:28.370 --> 29:29.370
比方说

29:29.370 --> 29:30.370
它

29:30.370 --> 29:31.370
和

29:33.370 --> 29:34.370
它

29:34.370 --> 29:36.370
和它进行对比

29:36.370 --> 29:37.370
对比的

29:37.370 --> 29:38.370
如果说它OK的话

29:38.370 --> 29:40.370
然后就对比他们两个的

29:40.370 --> 29:41.370
止元数

29:41.370 --> 29:42.370
所以又对比这一块

29:43.370 --> 29:44.370
又对比这一块

29:45.370 --> 29:46.370
又对比这一块

29:46.370 --> 29:47.370
对吧

29:47.370 --> 29:48.370
那么对比它的时候

29:48.370 --> 29:49.370
也是一个一个来

29:49.370 --> 29:50.370
它

29:50.370 --> 29:51.370
如果说跟它OK的话

29:51.370 --> 29:52.370
那么是不是对比这两个的

29:52.370 --> 29:53.370
止元数

29:53.370 --> 29:54.370
这两个没有止元数

29:54.370 --> 29:55.370
那就OK了

29:55.370 --> 29:56.370
然后现在是它

29:56.370 --> 29:57.370
跟它OK

29:57.370 --> 29:58.370
它跟它OK的话

29:58.370 --> 29:59.370
又对比他们两个止元数

29:59.370 --> 30:00.370
那么也没有止元数

30:00.370 --> 30:01.370
OK了

30:01.370 --> 30:02.370
那么接下来

30:02.370 --> 30:03.370
才把这个止元数

30:03.370 --> 30:04.370
对比完成了

30:04.370 --> 30:05.370
是不是深度便利

30:05.370 --> 30:08.130
然后呢

30:08.130 --> 30:09.130
再看这里

30:09.130 --> 30:10.130
它对比这

30:10.130 --> 30:11.130
它对比这

30:11.130 --> 30:12.130
OK

30:12.130 --> 30:13.130
那么又对比它的止元数

30:13.130 --> 30:14.130
就这么个意思

30:14.130 --> 30:15.130
就是深度便利

30:15.130 --> 30:16.130
大家了解一下

30:17.130 --> 30:19.130
这是更新

30:19.130 --> 30:20.130
对

30:20.130 --> 30:21.130
更新

30:21.130 --> 30:22.130
如果说自己

30:22.130 --> 30:23.130
更新完了过后

30:23.130 --> 30:25.130
还要操作它的止元数

30:26.130 --> 30:27.130
那么就会进入到

30:27.130 --> 30:29.130
对比止元

30:29.130 --> 30:30.130
对比止节点

30:30.130 --> 30:31.130
就两个叙利节点的

30:31.130 --> 30:32.130
止节点性对比

30:32.130 --> 30:34.130
具体过程以后来描述

30:34.130 --> 30:35.130
好

30:35.130 --> 30:36.130
简单的说一下

30:36.130 --> 30:37.130
这几个数字

30:37.130 --> 30:38.130
那么接下来

30:38.130 --> 30:39.130
我们来说详细流程

30:39.130 --> 30:40.130
详细流程其实

30:40.130 --> 30:41.130
最核心的

30:41.130 --> 30:42.130
就是两个地方

30:42.130 --> 30:43.130
一个是更节点

30:43.130 --> 30:45.130
一个是对比止节点

30:45.130 --> 30:46.130
就是这两件事

30:46.130 --> 30:47.130
对吧

30:47.130 --> 30:48.130
核心的东西就说完了

30:48.130 --> 30:49.130
我们来看一下

30:50.130 --> 30:51.130
首先一个比较简单

30:51.130 --> 30:52.130
就是对比更节点

30:52.130 --> 30:53.130
它拿到两棵数

30:53.130 --> 30:54.130
新数和就数

30:54.130 --> 30:55.130
它首先对更节点

30:55.130 --> 30:56.130
进行对比

30:56.130 --> 30:58.130
那么它到底是怎么对比的呢

30:58.130 --> 30:59.130
它判断的就是

30:59.130 --> 31:01.130
两个更节点

31:01.130 --> 31:02.130
是不是

31:02.130 --> 31:04.130
同一个节点

31:05.130 --> 31:06.130
它判断的是比方说

31:06.130 --> 31:07.130
就数一个更节点

31:07.130 --> 31:08.130
后边都没画了

31:08.130 --> 31:09.130
它就直接没画了

31:09.130 --> 31:11.130
新数的一个更节点

31:11.130 --> 31:12.130
那么比方说

31:12.130 --> 31:13.130
它们两个的key都是5

31:14.130 --> 31:15.130
以前的就数

31:15.130 --> 31:17.130
是不是有一个真实动物

31:17.130 --> 31:18.130
这是它的真实动物

31:18.130 --> 31:19.130
比方真实动物

31:19.130 --> 31:20.130
是一个SE元素

31:20.130 --> 31:21.130
里面一个文字就是5

31:21.130 --> 31:22.130
比方说

31:22.130 --> 31:23.130
一个粒子

31:23.130 --> 31:24.130
比方说

31:24.130 --> 31:25.130
这是SE元素

31:25.130 --> 31:26.130
里面一个文字就是5

31:26.130 --> 31:27.130
那么就节点

31:27.130 --> 31:28.130
它是虚节点里面

31:28.130 --> 31:29.130
一个key值

31:29.130 --> 31:30.130
key值也是5

31:30.130 --> 31:31.130
新节点也是5

31:31.130 --> 31:32.130
首先

31:32.130 --> 31:33.130
它看一下

31:33.130 --> 31:34.130
两个节点

31:34.130 --> 31:35.130
是不是相同的

31:35.130 --> 31:36.130
相同

31:36.130 --> 31:37.130
概念我们是不是

31:37.130 --> 31:38.130
之前说过

31:38.130 --> 31:39.130
内形相同

31:39.130 --> 31:40.130
key值相同

31:40.130 --> 31:41.130
那么比方说

31:41.130 --> 31:42.130
它们都是SE

31:42.130 --> 31:43.130
key值也一样

31:43.130 --> 31:44.130
它们就相同

31:44.130 --> 31:45.130
那么如果说

31:45.130 --> 31:46.130
它也是SE

31:47.130 --> 31:48.130
key值变成2

31:48.130 --> 31:49.130
它就不相同

31:49.130 --> 31:50.130
或者是key值相同

31:50.130 --> 31:51.130
但是它元素内形变了

31:51.130 --> 31:52.130
变成了

31:52.130 --> 31:53.130
变成了另外一个叫做

31:53.130 --> 31:54.130
SE元素

31:54.130 --> 31:56.130
那么它就不相同

31:56.130 --> 31:57.130
你要这意思吧

31:57.130 --> 31:58.130
那么比

31:58.130 --> 31:59.130
如果说

31:59.130 --> 32:00.130
它们不相同的话

32:00.130 --> 32:02.130
特别特别简单

32:03.130 --> 32:04.130
如果说不相同

32:05.130 --> 32:07.130
不相同的话

32:07.130 --> 32:08.130
那么直接

32:08.130 --> 32:09.130
创建

32:09.130 --> 32:10.130
比方说

32:10.130 --> 32:11.130
它们这里是6

32:12.130 --> 32:13.130
key值不一样

32:13.130 --> 32:14.130
那么直接

32:14.130 --> 32:15.130
创建一个新的

32:15.130 --> 32:17.130
新的真实节点

32:18.130 --> 32:20.130
它进入这个流程了

32:21.130 --> 32:23.130
它就当救出物存在了

32:24.130 --> 32:26.130
它进入这个流程了

32:26.130 --> 32:27.130
直接按照新数来

32:27.130 --> 32:28.130
创建一个完整的

32:28.130 --> 32:29.130
真实动物书

32:29.130 --> 32:30.130
救出不要了

32:30.130 --> 32:31.130
然后把这个5

32:31.130 --> 32:32.130
直接销毁

32:32.130 --> 32:33.130
销毁元素

32:36.720 --> 32:37.720
销毁元素

32:37.720 --> 32:38.720
直接把这个5

32:38.720 --> 32:39.720
直接销毁

32:39.720 --> 32:40.720
不要了

32:40.720 --> 32:41.720
是不是特别简单

32:42.720 --> 32:44.720
都是不相同的情况

32:44.720 --> 32:45.720
绝大部分情况

32:45.720 --> 32:46.720
我们在一个组建里边

32:46.720 --> 32:47.720
它的根结点

32:47.720 --> 32:48.720
都是相同的

32:48.720 --> 32:51.720
那么如果说是相同的情况

32:52.720 --> 32:53.720
相同的情况

32:53.720 --> 32:54.720
它会进入

32:54.720 --> 32:55.720
对比

32:55.720 --> 32:57.720
它会进入更新的流程

32:58.720 --> 33:00.720
它到底是怎么来更新的

33:00.720 --> 33:01.720
看下面

33:01.720 --> 33:02.720
不相同特别简单

33:02.720 --> 33:03.720
请点点

33:03.720 --> 33:04.720
第一规创建元素

33:04.720 --> 33:05.720
然后就建点销毁元素

33:06.720 --> 33:07.720
相同的话

33:07.720 --> 33:09.720
还会进入更新流程

33:09.720 --> 33:10.720
怎么更新的

33:11.720 --> 33:12.720
它首先把旧节点

33:12.720 --> 33:13.720
因为它

33:13.720 --> 33:14.720
相同的意味着

33:14.720 --> 33:15.720
什么呢

33:15.720 --> 33:16.720
这个真实动物

33:16.720 --> 33:17.720
我们要重复使用

33:17.720 --> 33:18.720
就这就是

33:18.720 --> 33:19.720
相同的意思

33:19.720 --> 33:20.720
就是我不能把它删掉

33:20.720 --> 33:22.720
那么它会让新的节点

33:22.720 --> 33:23.720
里面那个属性

33:23.720 --> 33:24.720
叫A我们属性

33:24.720 --> 33:25.720
A里面属性

33:25.720 --> 33:26.720
指向新节点

33:26.720 --> 33:27.720
指向那个真实动物

33:27.720 --> 33:28.720
那么这样的新节点

33:28.720 --> 33:29.720
是不是也可以

33:29.720 --> 33:30.720
找到同样的真实动物呢

33:30.720 --> 33:31.720
对吧

33:32.720 --> 33:33.720
然后做什么呢

33:33.720 --> 33:35.720
然后对比新节点

33:35.720 --> 33:36.720
和旧节点的属性

33:36.720 --> 33:37.720
有变化的

33:37.720 --> 33:39.720
会更新到真实动物里面去

33:39.720 --> 33:40.720
它会把这个V漏的拿出来

33:40.720 --> 33:41.720
是个对象吧

33:41.720 --> 33:43.720
这个V漏的拿出来是个对象

33:43.720 --> 33:44.720
那么看一下

33:44.720 --> 33:45.720
它里面有哪些属性

33:45.720 --> 33:46.720
比方说

33:46.720 --> 33:47.720
它的内央是有没有变化呀

33:47.720 --> 33:48.720
它的一个各种

33:48.720 --> 33:50.720
一个制定属性有没有变化呀

33:50.720 --> 33:52.720
事件里面不会变

33:52.720 --> 33:53.720
总之它会对比里面

33:53.720 --> 33:54.720
各种属性

33:54.720 --> 33:55.720
看一下

33:55.720 --> 33:56.720
哪些属性是有变化的

33:56.720 --> 33:58.720
会把有变化的

33:58.720 --> 33:59.720
设置到真实动物里面去

33:59.720 --> 34:00.720
那么这样子

34:00.720 --> 34:01.720
这两个节点

34:01.720 --> 34:02.720
这一步做完了

34:02.720 --> 34:03.720
是不是真实动物里面

34:03.720 --> 34:04.720
就已经OK了

34:04.720 --> 34:05.720
对吧

34:05.720 --> 34:06.720
就已经反映了

34:06.720 --> 34:08.720
新的区别节点里面的东西了

34:08.720 --> 34:09.720
对不对

34:09.720 --> 34:10.720
因为说

34:10.720 --> 34:11.720
这个会不会断开

34:11.720 --> 34:12.720
不需要断开

34:12.720 --> 34:13.720
断开干嘛呀

34:13.720 --> 34:14.720
因为就是我们已经不用了

34:14.720 --> 34:15.720
就这一部分

34:15.720 --> 34:16.720
将来你就看不到了

34:16.720 --> 34:17.720
它连就连了吧

34:17.720 --> 34:18.720
很快拉进回头期

34:18.720 --> 34:19.720
就会把它毁收掉

34:19.720 --> 34:21.720
你不用去管它了

34:21.720 --> 34:22.720
它只需要把新数连过去

34:22.720 --> 34:23.720
就行了

34:23.720 --> 34:24.720
对不对

34:24.720 --> 34:25.720
也就是说

34:25.720 --> 34:26.720
从土上看的话

34:26.720 --> 34:27.720
它就变成这个样子

34:27.720 --> 34:28.720
这一步对比完了过后

34:28.720 --> 34:29.720
实际上这个AOM

34:29.720 --> 34:30.720
这边也有了

34:30.720 --> 34:31.720
他们是同一个

34:32.720 --> 34:33.720
那意思吧

34:33.720 --> 34:34.720
这个AOM

34:34.720 --> 34:35.720
这边也有了

34:35.720 --> 34:37.720
而它会按照这边的信息

34:37.720 --> 34:38.720
跟这边的信息

34:38.720 --> 34:39.720
循环对比

34:39.720 --> 34:40.720
循环的每一个属性对比

34:40.720 --> 34:42.720
哪些属性需要更新到这里

34:42.720 --> 34:43.720
就更新到这里

34:43.720 --> 34:44.720
表面要是要做改变

34:44.720 --> 34:45.720
就设一支Class Name

34:45.720 --> 34:46.720
对吧

34:46.720 --> 34:47.720
就完了

34:48.720 --> 34:49.720
好

34:49.720 --> 34:51.720
下一步做什么呢

34:51.720 --> 34:53.720
现在我们目前只看了跟节点

34:53.720 --> 34:54.720
相同的情况下

34:54.720 --> 34:56.720
我只看了跟节点

34:56.720 --> 34:57.720
更新流程还没完

34:57.720 --> 34:58.720
我还要干嘛

34:58.720 --> 35:00.720
我还要

35:00.720 --> 35:01.720
开始对比止节点

35:01.720 --> 35:03.720
就这个流程了

35:03.720 --> 35:04.720
我这个节点看了

35:04.720 --> 35:05.720
我还要对比止节点

35:05.720 --> 35:06.720
真正麻烦了在这

35:06.720 --> 35:08.720
怎么去对比止节点

35:09.720 --> 35:10.720
好 看下面

35:16.210 --> 35:17.210
对比止节点是比较复杂的

35:17.210 --> 35:18.210
就是这两块

35:20.210 --> 35:21.210
这一块

35:23.210 --> 35:25.210
对比止节点的时候

35:25.210 --> 35:26.210
记住一个原则

35:26.210 --> 35:28.210
就伍佑他自己的原则

35:28.210 --> 35:30.210
他说能够不要去

35:30.210 --> 35:31.210
因为我们的虚拟节点

35:31.210 --> 35:32.210
其实已经好了

35:32.210 --> 35:33.210
不需要你去

35:33.210 --> 35:34.210
改动虚拟动物书

35:34.210 --> 35:36.210
虚拟动物书不需要你改

35:36.210 --> 35:38.210
你要改的就是真实动物

35:38.210 --> 35:40.210
动的就是真实动物

35:40.210 --> 35:41.210
那么动真实动物的效率

35:41.210 --> 35:42.210
是比较低的

35:42.210 --> 35:43.210
比较耗实的

35:43.210 --> 35:44.210
所以伍佑的原则就是

35:44.210 --> 35:46.210
能不要动就尽量不要动

35:46.210 --> 35:48.210
尽量啥也别做

35:48.210 --> 35:50.210
对比这两块的时候

35:50.210 --> 35:51.210
尽量啥也别做

35:52.210 --> 35:53.210
其实对比这两块

35:53.210 --> 35:54.210
其实就是两个数数

35:54.210 --> 35:55.210
一个是止节点的数数

35:55.210 --> 35:57.210
另外一个是止节点的数数

35:57.210 --> 35:58.210
尽量啥也别做

35:58.210 --> 35:59.210
但是有的时候没办法

35:59.210 --> 36:00.210
比方说这里多了个虚拟

36:00.210 --> 36:01.210
也不可能不做

36:01.210 --> 36:03.210
你必须要创建一个新的虚拟动物书

36:03.210 --> 36:05.210
所以不行的话

36:05.210 --> 36:06.210
那么尽量的是

36:06.210 --> 36:07.210
改动元素属性

36:09.210 --> 36:11.210
比方这个节点

36:14.210 --> 36:15.210
跟这个节点

36:15.210 --> 36:16.210
他们都是同一个节点

36:16.210 --> 36:17.210
我改动属性就行了

36:17.210 --> 36:19.210
你不要去动他的元素

36:19.210 --> 36:20.210
解构

36:21.210 --> 36:22.210
都是这一块

36:22.210 --> 36:24.210
如果说还不行的话

36:24.210 --> 36:26.210
那么尽量的移动元素

36:26.210 --> 36:28.210
不要删除和创建

36:28.210 --> 36:29.210
都是为了效率

36:29.210 --> 36:30.210
如果说还不行

36:30.210 --> 36:31.210
那就没办法了

36:31.210 --> 36:33.210
只能删除了创建元素

36:33.210 --> 36:35.210
这是他们的总体原则

36:35.210 --> 36:37.210
那么接下来讲的事情

36:37.210 --> 36:38.210
就是他的具体怎么去实现的

36:38.210 --> 36:39.210
怎么去

36:40.210 --> 36:42.210
因为我们的虚拟动物已经好了

36:42.210 --> 36:44.210
怎么去改动真实动

36:44.210 --> 36:45.210
那么这里有张图

36:46.210 --> 36:47.210
大家尽量听

36:47.210 --> 36:48.210
尽量听

36:49.210 --> 36:50.210
当时面试的时候

36:50.210 --> 36:52.210
能够回答出关键点就OK了

36:54.710 --> 36:55.710
那么他意思呢

36:55.710 --> 36:59.600
比方说了就节点

36:59.600 --> 37:01.600
他们的副节点都一样

37:01.600 --> 37:03.600
这是某一个节点的止节点

37:03.600 --> 37:05.600
这也是某一个止节点的止节点

37:05.600 --> 37:06.600
他们两个的副节点

37:06.600 --> 37:08.600
我们之前已经对比过了

37:08.600 --> 37:09.600
够行了

37:09.600 --> 37:10.600
OK了

37:10.600 --> 37:11.600
那么现在搞定止节点

37:11.600 --> 37:12.600
那么这是一块止节点

37:12.600 --> 37:14.600
这是一块止节点

37:14.600 --> 37:16.600
那么这个里边数字

37:16.600 --> 37:17.600
表示它的key值

37:17.600 --> 37:18.600
用key值来区分

37:18.600 --> 37:19.600
我们这里能为了方便

37:19.600 --> 37:20.600
用key值来区分

37:20.600 --> 37:22.600
他们是不是同一个节点

37:22.600 --> 37:23.600
然后这里边

37:23.600 --> 37:25.600
是以前的旧的动物数

37:25.600 --> 37:26.600
旧的这个节点

37:26.600 --> 37:28.600
它对应的真实动物

37:28.600 --> 37:30.600
以他们真实动物的

37:30.600 --> 37:31.600
顺序跟那个旧的

37:31.600 --> 37:32.600
旧的动物是一样的

37:32.600 --> 37:34.600
一定是一样的

37:34.600 --> 37:36.600
所以说现在的是这个样子的

37:36.600 --> 37:38.600
然后你就可以把想象成li

37:38.600 --> 37:39.600
li远处

37:39.600 --> 37:40.600
一个地的li

37:40.600 --> 37:41.600
每个5

37:41.600 --> 37:42.600
地的li

37:42.600 --> 37:43.600
每个2

37:43.600 --> 37:44.600
假设吗

37:44.600 --> 37:45.600
就这么个意思

37:45.600 --> 37:46.600
现在呢

37:46.600 --> 37:47.600
我们要做的事情

37:47.600 --> 37:49.600
是要去对比旧的

37:49.600 --> 37:50.600
旧的这个止节点

37:50.600 --> 37:52.600
和新的止节点

37:52.600 --> 37:53.600
他们的差异

37:53.600 --> 37:54.600
然后目标是什么

37:54.600 --> 37:56.600
目标不是改动这些东西

37:56.600 --> 37:57.600
目标是

37:57.600 --> 37:59.600
改动真实动物

37:59.600 --> 38:00.600
并且把个真实动物

38:00.600 --> 38:01.600
对应到新的

38:01.600 --> 38:03.600
旧的动物里面去

38:03.600 --> 38:04.600
他唯有是怎么做的呢

38:04.600 --> 38:06.600
唯有他分别用了

38:06.600 --> 38:07.600
两个指针

38:07.600 --> 38:10.600
指向数的头和尾

38:10.600 --> 38:11.600
你看这里

38:11.600 --> 38:12.600
新数也是一样

38:12.600 --> 38:14.600
两个指针指向数的头和尾

38:14.600 --> 38:15.600
具体怎么做

38:15.600 --> 38:16.600
他看着啊

38:16.600 --> 38:17.600
他这样来的

38:17.600 --> 38:18.600
我不会这里

38:18.600 --> 38:19.600
把详细的代码

38:19.600 --> 38:20.600
或者是

38:20.600 --> 38:21.600
详细的一些细节

38:21.600 --> 38:22.600
给大家说出来

38:22.600 --> 38:23.600
我们只是说

38:23.600 --> 38:24.600
它是个大致的流程

38:24.600 --> 38:25.600
一回到时候

38:25.600 --> 38:26.600
一定要说两个关键点

38:26.600 --> 38:28.600
就是头尾指针

38:29.600 --> 38:30.600
好

38:30.600 --> 38:31.600
看一下怎么做的

38:31.600 --> 38:32.600
首先他对比

38:32.600 --> 38:34.600
旧数和新数的

38:34.600 --> 38:36.600
头指针

38:36.600 --> 38:37.600
看一下两个一不一样

38:37.600 --> 38:38.600
一不一样呢

38:38.600 --> 38:39.600
一样

38:39.600 --> 38:41.600
如果说两个一样

38:41.600 --> 38:44.600
就进入更新流程

38:44.600 --> 38:46.600
就进入这个流程

38:46.600 --> 38:48.600
是不是相当于是个帝国一样

38:48.600 --> 38:49.600
就这个流程

38:49.600 --> 38:50.600
好了

38:50.600 --> 38:51.600
我们来看看

38:51.600 --> 38:52.600
进入这个流程

38:52.600 --> 38:53.600
会做什么事情

38:53.600 --> 38:54.600
进入这个流程

38:54.600 --> 38:55.600
会做什么事情

38:55.600 --> 38:56.600
刚才说了

38:56.600 --> 38:57.600
两个节点一样

38:57.600 --> 38:59.600
首先连起来

38:59.600 --> 39:00.600
对吧

39:00.600 --> 39:01.600
让新节点的

39:01.600 --> 39:03.600
也指向这个真实冬

39:03.600 --> 39:04.600
都一样的

39:04.600 --> 39:05.600
我这个东西都不用删除

39:05.600 --> 39:07.600
还是用之前的复用

39:07.600 --> 39:09.600
说指向新的真实冬

39:09.600 --> 39:10.600
改动真实冬没

39:10.600 --> 39:11.600
没有改动

39:11.600 --> 39:12.600
然后

39:12.600 --> 39:13.600
但是还是要对比一下

39:13.600 --> 39:15.600
看一下新的V2的里面

39:15.600 --> 39:16.600
有没有一些属性

39:16.600 --> 39:18.600
央视发生变化

39:18.600 --> 39:19.600
这个东西很简单

39:19.600 --> 39:21.600
循环每一个属性

39:21.600 --> 39:22.600
新的虚拟动物

39:22.600 --> 39:23.600
是一个对象

39:23.600 --> 39:24.600
循环的对象

39:24.600 --> 39:25.600
里面一些关键性

39:25.600 --> 39:26.600
一些配置

39:26.600 --> 39:27.600
都进行对比

39:27.600 --> 39:28.600
看哪些变化的

39:28.600 --> 39:29.600
变化的部分

39:29.600 --> 39:31.600
更新到真实冬

39:31.600 --> 39:33.600
反正就进入更新流程

39:33.600 --> 39:36.600
我之后就不重复了

39:36.600 --> 39:37.600
就完事了

39:37.600 --> 39:38.600
然后还要做什么

39:38.600 --> 39:39.600
还要去对比

39:39.600 --> 39:42.600
这两个元素的指节点

39:42.600 --> 39:43.600
这一步还没完

39:43.600 --> 39:45.600
对比它的指节点

39:45.600 --> 39:46.600
指节点

39:46.600 --> 39:47.600
所以又要进入这个流程

39:47.600 --> 39:48.600
是个低规的过程

39:48.600 --> 39:49.600
为什么说是深度变律呢

39:49.600 --> 39:51.600
就还没有看后边的

39:51.600 --> 39:53.600
我就要把这两个指节点搞定

39:53.600 --> 39:55.600
我这里就考虑没有指节点

39:55.600 --> 39:57.600
或者时间点就已经搞定了

39:57.600 --> 39:59.600
那么这个东西就算搞定了

39:59.600 --> 40:01.600
就ok了

40:01.600 --> 40:02.600
接下来

40:02.600 --> 40:06.910
他会把两个投资人往后移动

40:06.910 --> 40:07.910
移动过后

40:07.910 --> 40:09.910
又来比较两个投资人

40:09.910 --> 40:10.910
一样吗

40:10.910 --> 40:11.910
那就不一样了

40:11.910 --> 40:12.910
因为他两个key是不同的

40:12.910 --> 40:13.910
不一样的时候

40:13.910 --> 40:14.910
是不是要稍稍毁

40:14.910 --> 40:15.910
三出来不是

40:15.910 --> 40:16.910
先不着急

40:16.910 --> 40:18.910
我一定要去找到一个一样的

40:18.910 --> 40:20.910
然后他会比较为自身

40:20.910 --> 40:22.910
两个投资人不一样

40:22.910 --> 40:24.910
就比较为自身

40:24.910 --> 40:25.910
为自身是不一样的

40:25.910 --> 40:26.910
那又来

40:26.910 --> 40:28.910
这个事情又开始了

40:28.910 --> 40:30.910
然后连过来

40:30.910 --> 40:32.910
新节点也只像个真实动物

40:32.910 --> 40:34.910
然后去更新这个真实动物的主线

40:34.910 --> 40:37.910
然后去搞定指援数就完了

40:37.910 --> 40:38.910
好

40:38.910 --> 40:41.910
接下来两个为自身往前移动

40:41.910 --> 40:42.910
又来

40:42.910 --> 40:43.910
下一次

40:43.910 --> 40:45.910
又来比较投资人一样吗

40:45.910 --> 40:46.910
还是不一样

40:46.910 --> 40:48.910
为自身的也不一样

40:48.910 --> 40:49.910
还不够

40:49.910 --> 40:50.910
这一定要得到一样的

40:50.910 --> 40:52.910
他尽量要稍稍去动

40:52.910 --> 40:55.910
然后他会比较这边的投和这边的尾

40:55.910 --> 40:56.910
一样吗

40:56.910 --> 40:57.910
又一样

40:57.910 --> 40:58.910
一样怎么办

40:58.910 --> 41:03.630
来连过来

41:03.630 --> 41:05.630
连过来

41:05.630 --> 41:06.630
连过来过后

41:06.630 --> 41:08.630
他又附用这个真实动物

41:08.630 --> 41:09.630
他尽量少了

41:09.630 --> 41:10.630
不要去改动

41:10.630 --> 41:12.630
附用这个真实动物

41:12.630 --> 41:13.630
然后又是更新属性

41:13.630 --> 41:15.630
把属性更新到真实动物里面去

41:15.630 --> 41:16.630
从头到尾

41:16.630 --> 41:19.630
他不会去动那个虚的动物的

41:19.630 --> 41:21.630
还有件事情没完

41:21.630 --> 41:24.630
就是把这个真实动物的位置

41:25.630 --> 41:27.630
之前动物元素的位置顺序是这样子的

41:27.630 --> 41:29.630
他会把这个真实动物的位置移到哪

41:29.630 --> 41:32.630
移到这个的尾指针后边去

41:32.630 --> 41:33.630
他会移动到这

41:33.630 --> 41:35.630
现在跑哪去了

41:35.630 --> 41:39.330
现在跑这边来了

41:39.330 --> 41:43.640
现在没办法了

41:43.640 --> 41:45.640
必须要移动

41:45.640 --> 41:47.640
这一步会导致动物元素

41:47.640 --> 41:50.640
真实动物的改变顺序

41:50.640 --> 41:53.640
好 又来

41:53.640 --> 41:56.640
接下来这个指针往前移动

41:56.640 --> 41:58.640
然后这个指针往前移动

41:58.640 --> 41:59.640
又来

41:59.640 --> 42:01.640
头头不同

42:01.640 --> 42:03.640
尾尾不同

42:03.640 --> 42:05.640
头尾不同

42:05.640 --> 42:08.640
还有这边的头尾也不同

42:08.640 --> 42:10.640
好 都不同了怎么办

42:10.640 --> 42:12.640
以这个东西为基准

42:12.640 --> 42:13.640
他可以以头

42:13.640 --> 42:14.640
这边新书的投资人为基准

42:14.640 --> 42:16.640
然后看一下这个东西

42:16.640 --> 42:19.640
在救赎里边存不存在

42:19.640 --> 42:21.640
存在的话在哪个位置

42:21.640 --> 42:22.640
就找到他了

42:22.640 --> 42:24.640
这一步其实他用了一些技巧了

42:24.640 --> 42:26.640
我们这里都不展开说了

42:26.640 --> 42:27.640
这两个是不是找到了

42:27.640 --> 42:29.640
他会去找

42:29.640 --> 42:31.640
找到这两个过后相同了

42:31.640 --> 42:32.640
对吧 相同了怎么办

42:32.640 --> 42:37.100
又复用

42:37.100 --> 42:38.100
复用

42:38.100 --> 42:40.100
然后又去对比更新元素

42:40.100 --> 42:42.100
更新了

42:42.100 --> 42:44.100
更新了过后位置是要调整

42:44.100 --> 42:45.100
对不对

42:45.100 --> 42:47.100
位置要调整

42:47.100 --> 42:48.100
以后这边移动的

42:48.100 --> 42:51.100
就不会看他了

42:51.100 --> 42:53.100
位置要调整到哪去

42:53.100 --> 42:55.100
他要调整到

42:55.100 --> 42:58.930
这个之前

42:58.930 --> 43:00.930
调整到这个之前

43:00.930 --> 43:01.930
OK

43:01.930 --> 43:05.240
好 那么接下来呢

43:05.240 --> 43:07.240
这个东西只这个东西移动

43:07.240 --> 43:09.240
又来看

43:09.240 --> 43:11.240
头 头不同

43:11.240 --> 43:12.240
尾尾不同

43:12.240 --> 43:13.240
头尾不同

43:13.240 --> 43:14.240
头尾

43:14.240 --> 43:15.240
相同 是吧

43:15.240 --> 43:16.240
相同又干嘛

43:16.240 --> 43:20.260
又来 又来

43:20.260 --> 43:22.260
又连接起来

43:22.260 --> 43:24.260
这个玩意其实就是一个复职

43:24.260 --> 43:27.260
把他底 真实的复职给他底

43:27.260 --> 43:29.260
对吧 一样的

43:29.260 --> 43:31.260
好 然后对比更新

43:31.260 --> 43:33.260
真实动物元素

43:33.260 --> 43:34.260
OK

43:34.260 --> 43:35.260
好 这边头尾相同

43:35.260 --> 43:37.260
是不是要移动元素

43:37.260 --> 43:39.260
那么移动到哪去呢

43:39.260 --> 43:42.570
他会移动到这个

43:42.570 --> 43:44.570
这个投资人前面

43:44.570 --> 43:46.570
他会移动到这个投资人前面

43:46.570 --> 43:48.570
这个投资人前面

43:48.570 --> 43:49.570
OK

43:49.570 --> 43:50.570
很简单的对吧

43:50.570 --> 43:52.570
这个投资人是不是会指向一个虚动

43:52.570 --> 43:54.570
虚动物会指向一个真实元素

43:54.570 --> 43:55.570
对吧

43:55.570 --> 43:56.570
用他的复元素的

43:56.570 --> 43:57.570
insertp4

43:57.570 --> 43:58.570
是不是可以搞定的

43:58.570 --> 43:59.570
非常简单

43:59.570 --> 44:01.570
好 然后移动

44:01.570 --> 44:03.570
这边往这边移动

44:03.570 --> 44:05.570
这边往这边移动

44:05.570 --> 44:07.570
好 接下来看这个疤

44:07.570 --> 44:08.570
头尾相同

44:08.570 --> 44:09.570
头尾重合了

44:09.570 --> 44:10.570
重合还OK

44:10.570 --> 44:11.570
然后看一下

44:11.570 --> 44:13.570
头头相不相同 不相同

44:13.570 --> 44:15.570
尾尾相不相同 不相同

44:15.570 --> 44:16.570
头尾都不相同

44:16.570 --> 44:18.570
都不相同怎么办

44:18.570 --> 44:19.570
没办法了

44:19.570 --> 44:20.570
那他去找什么

44:20.570 --> 44:21.570
就进入刚才的流程了

44:21.570 --> 44:23.570
找一下 直接找

44:23.570 --> 44:25.570
疤在救赎里面存不存在

44:25.570 --> 44:26.570
无论你在什么位置

44:26.570 --> 44:27.570
无所谓

44:27.570 --> 44:29.570
看你存不存在

44:29.570 --> 44:30.570
发现不存在

44:30.570 --> 44:31.570
那这个时候

44:31.570 --> 44:32.570
就确实没办法了

44:32.570 --> 44:34.570
不存在只能兴建了

44:34.570 --> 44:35.570
兴建一个帮

44:35.570 --> 44:37.570
真实元素

44:37.570 --> 44:38.570
救赎没有的

44:38.570 --> 44:40.570
然后呢

44:40.570 --> 44:46.760
指向 指过去

44:46.760 --> 44:47.760
指过去

44:47.760 --> 44:48.760
好

44:48.760 --> 44:50.760
那救赎不管了

44:50.760 --> 44:51.760
然后呢

44:51.760 --> 44:52.760
头智人往后移动

44:52.760 --> 44:54.760
好 移动到这

44:54.760 --> 44:55.760
所以头智人

44:55.760 --> 44:57.760
已经不再是有效的了

44:57.760 --> 44:59.760
头智人超出了这个位置

44:59.760 --> 45:02.760
这个已经搞定了

45:02.760 --> 45:04.760
头智人已经超过了

45:04.760 --> 45:05.760
维治症

45:05.760 --> 45:07.760
是不是循环结束

45:07.760 --> 45:08.760
OK了

45:08.760 --> 45:09.760
好

45:09.760 --> 45:10.760
循环结束过后

45:10.760 --> 45:11.760
最后

45:11.760 --> 45:12.760
然后看一下

45:12.760 --> 45:13.760
救赎的两个头

45:13.760 --> 45:14.760
头位指针

45:14.760 --> 45:15.760
是不是还是正常的

45:15.760 --> 45:16.760
发现还是正常的

45:16.760 --> 45:17.760
说明还有一些

45:17.760 --> 45:18.760
节点没处理完

45:18.760 --> 45:19.760
然后这个时候

45:19.760 --> 45:20.760
他会循环

45:20.760 --> 45:22.760
从头智人循环到维治症

45:22.760 --> 45:23.760
每一个节点拿出来看

45:23.760 --> 45:24.760
把所有的节点

45:24.760 --> 45:25.760
全部销毁

45:25.760 --> 45:26.760
他不是销毁节点

45:26.760 --> 45:28.760
销毁的是真实动物

45:28.760 --> 45:30.760
全部销毁

45:30.760 --> 45:31.760
好

45:31.760 --> 45:32.760
那么这样子一处理完

45:32.760 --> 45:33.760
我们不用

45:33.760 --> 45:34.760
不去看救赎

45:34.760 --> 45:35.760
救赎就不看了

45:35.760 --> 45:36.760
救赎没意义了

45:36.760 --> 45:37.760
因为救赎现在

45:37.760 --> 45:38.760
拿不到了

45:38.760 --> 45:39.760
你找不到救赎了

45:39.760 --> 45:40.760
这一处理完过后

45:40.760 --> 45:41.760
救赎一不看

45:41.760 --> 45:42.760
你看新赎

45:42.760 --> 45:44.760
是不是就已经OK了

45:44.760 --> 45:45.760
整个过程里

45:45.760 --> 45:46.760
再好好体会一下

45:46.760 --> 45:47.760
是不是我们只新建了

45:47.760 --> 45:48.760
一个元素

45:48.760 --> 45:49.760
其他的元素

45:49.760 --> 45:50.760
都是尽量的

45:50.760 --> 45:51.760
能不动就不动

45:51.760 --> 45:52.760
实在不行了

45:52.760 --> 45:53.760
才移动

45:53.760 --> 45:55.760
你要这意思吧

45:55.760 --> 45:57.760
这就是他的对比过程

45:58.760 --> 45:59.760
对比指引的过程

46:01.760 --> 46:02.760
这就是咱们

46:02.760 --> 46:04.760
整个无忧的

46:04.760 --> 46:05.760
跌幅过程

46:05.760 --> 46:06.760
我们在最后再总结一下

46:06.760 --> 46:08.760
首先是跌幅的时机

46:08.760 --> 46:10.760
什么时候发生跌幅

46:11.760 --> 46:12.760
是在updats寒宿

46:12.760 --> 46:14.760
运行的过程中发生跌幅

46:14.760 --> 46:15.760
为什么会有updats寒宿

46:15.760 --> 46:16.760
updats寒宿干嘛的

46:16.760 --> 46:17.760
它是跟

46:17.760 --> 46:19.760
传入一个虚的节点

46:19.760 --> 46:20.760
这虚的节点就是

46:20.760 --> 46:21.760
Render生成的

46:21.760 --> 46:22.760
说明确定了一颗新宿

46:22.760 --> 46:24.760
然后把当前

46:24.760 --> 46:26.760
对象里边的那个Vload

46:27.760 --> 46:29.760
跟当前对象里边的Vload

46:29.760 --> 46:30.760
进行对比

46:31.760 --> 46:33.760
是不是就数进行对比

46:34.760 --> 46:36.760
对比的过程就是

46:38.760 --> 46:40.760
使用了是派起寒宿来进行对比

46:40.760 --> 46:41.760
它的过程就是

46:42.760 --> 46:43.760
首先进行根结点比较

46:43.760 --> 46:44.760
根结点

46:44.760 --> 46:45.760
如果说

46:45.760 --> 46:46.760
不相同的话

46:46.760 --> 46:47.760
它直接扔掉就数

46:47.760 --> 46:48.760
直接创建新宿的

46:48.760 --> 46:49.760
真实动物就OK了

46:49.760 --> 46:51.760
如果说这根结点相同的话

46:51.760 --> 46:53.760
更新真实节点的属性

46:53.760 --> 46:55.760
然后对比直接点

46:55.760 --> 46:56.760
那么对比直接点

46:56.760 --> 46:57.760
是一个递归的过程

46:57.760 --> 46:58.760
对比的方式

46:58.760 --> 46:59.760
就是用两个指示

46:59.760 --> 47:00.760
就OK

47:00.760 --> 47:01.760
那么最后来我们来看一下

47:01.760 --> 47:03.760
我们的参考伟大

47:03.760 --> 47:05.760
给大家练一下

47:05.760 --> 47:07.760
当组建创建和更新的时候

47:07.760 --> 47:10.760
伍佑会执行内部的updats寒宿

47:10.760 --> 47:11.760
你说到这一点

47:11.760 --> 47:13.760
说明你演技都已经很深了

47:14.760 --> 47:16.760
该寒宿的内部

47:16.760 --> 47:18.760
调用Render寒宿

47:19.760 --> 47:21.760
生成

47:21.760 --> 47:22.760
你这里说的有问题

47:22.760 --> 47:24.760
该寒宿

47:24.760 --> 47:29.860
使用应该说

47:29.860 --> 47:31.860
使用Render寒宿生成的

47:31.860 --> 47:33.860
虚拟动物宿

47:33.860 --> 47:35.860
和

47:35.860 --> 47:37.860
将新旧两树进行对比

47:38.860 --> 47:39.860
将新旧两树进行对比

47:39.860 --> 47:41.860
找到差一点最终更新

47:41.860 --> 47:43.860
更新到真实动物

47:44.860 --> 47:46.860
然后对比差异的过程叫做deaf

47:46.860 --> 47:47.860
伍佑在内部

47:47.860 --> 47:48.860
通过一个叫patch的寒宿

47:48.860 --> 47:49.860
完成该过程

47:49.860 --> 47:50.860
我们有的说

47:50.860 --> 47:51.860
伍佑的

47:51.860 --> 47:53.860
deaf方法就是patch

47:53.860 --> 47:54.860
在对比的过程中

47:54.860 --> 47:55.860
它用深度优先

47:55.860 --> 47:56.860
组成比较的方式

47:56.860 --> 47:58.860
我叫做同级比较

47:58.860 --> 48:02.970
同层比较

48:02.970 --> 48:03.970
什么叫同层比较呢

48:03.970 --> 48:04.970
就是说

48:04.970 --> 48:05.970
它比较的过程

48:05.970 --> 48:07.970
它不会跨越

48:07.970 --> 48:08.970
这个树的结构

48:09.970 --> 48:10.970
它不会说

48:10.970 --> 48:11.970
它不会说新树的这个

48:11.970 --> 48:12.970
这个节点

48:12.970 --> 48:13.970
跑去跟就树的

48:13.970 --> 48:14.970
这个节点进行对比

48:14.970 --> 48:15.970
不会的

48:15.970 --> 48:16.970
你看刚才的逻辑

48:16.970 --> 48:17.970
它不可能出现这种情况的

48:17.970 --> 48:19.970
它是组成比较的

48:23.340 --> 48:24.340
在判断两个节点

48:24.340 --> 48:25.340
适合相同的时候

48:25.340 --> 48:26.340
它是通过

48:26.340 --> 48:27.340
虚拟节点的key和tag来进行判断的

48:27.340 --> 48:29.340
就是局建节点内形和key

48:29.340 --> 48:30.340
判断是不是相同的

48:30.340 --> 48:31.340
具体来说

48:31.340 --> 48:32.340
首先对根节点进行对比

48:32.340 --> 48:33.340
如果说相同

48:33.340 --> 48:35.340
那么就节点的关联的真实动物

48:35.340 --> 48:36.340
挂着到刑界点上

48:36.340 --> 48:37.340
然后根据

48:37.340 --> 48:39.340
需要更新属性的真实动物

48:39.340 --> 48:41.340
它一定是操作真实动物

48:41.340 --> 48:42.340
而不去改动者

48:42.340 --> 48:43.340
虚拟动物

48:43.340 --> 48:44.340
虚拟动物已经ok了

48:44.340 --> 48:46.340
然后再对比起指节点树树

48:46.340 --> 48:47.340
如果不相同的话

48:47.340 --> 48:48.340
那么直接创建

48:48.340 --> 48:50.340
把销毁就的

48:50.340 --> 48:52.340
在对比指节点树树的时候

48:52.340 --> 48:53.340
它比较复杂一点

48:53.340 --> 48:54.340
要回答关键点是

48:54.340 --> 48:55.340
要回答出双指针

48:55.340 --> 48:56.340
对每个节点

48:56.340 --> 48:57.340
使用了两个指针

48:57.340 --> 48:58.340
分辨几次向头位

48:58.340 --> 49:00.340
然后不断向中间靠拢来进行对比

49:00.340 --> 49:01.340
这样的作用的目的是

49:01.340 --> 49:02.340
尽量附用真实动物

49:02.340 --> 49:04.340
尽量少的消费和创建真实动物

49:04.340 --> 49:05.340
如果发现相同

49:05.340 --> 49:06.340
那么才进入

49:06.340 --> 49:08.340
跟节点一样的对比流程

49:08.340 --> 49:09.340
就是更新流程

49:09.340 --> 49:10.340
如果不同的话

49:10.340 --> 49:11.340
那么则移动

49:11.340 --> 49:13.340
动不到合适的位置

49:13.340 --> 49:14.340
真实动物

49:14.340 --> 49:15.340
这样地规遍立下去

49:15.340 --> 49:17.340
把整个数比较完

49:17.340 --> 49:18.340
好

49:18.340 --> 49:20.340
这是咱们如何去回答这个面试题

49:20.340 --> 49:21.340
说完了面试题

49:21.340 --> 49:22.340
这一刻时间比较长

49:22.340 --> 49:23.340
说完了面试题

49:23.340 --> 49:25.340
我还有一些东西要说

49:25.340 --> 49:28.340
就是对我们开发有什么影响没

49:28.340 --> 49:29.340
这个dev

49:29.340 --> 49:30.340
对我们开发有什么影响没

49:30.340 --> 49:32.340
它是有影响的

49:32.340 --> 49:33.340
我们来说一下

49:33.340 --> 49:35.340
主要发生的影响的位置

49:35.340 --> 49:37.340
我这里主要举了两个例子

49:37.340 --> 49:39.340
我们首先看第1个例子

49:39.340 --> 49:40.340
第1个例子是我们

49:40.340 --> 49:42.340
开发时遇到最常见的一个例子

49:42.340 --> 49:45.340
就是我们在循环一个数组

49:45.340 --> 49:48.340
然后生成一些

49:48.340 --> 49:49.340
虚拟动物的时候

49:49.340 --> 49:51.340
我们要注意给它加上keyz

49:51.340 --> 49:53.340
来看一下为什么

49:54.340 --> 49:55.340
这里我们有个数组

49:55.340 --> 49:56.340
numbers

49:56.340 --> 49:57.340
你看这是个数组

49:57.340 --> 49:58.340
我们在循环它

49:58.340 --> 49:59.340
现在我们没有加keyz

49:59.340 --> 50:01.340
然后输出一个n

50:01.340 --> 50:03.340
接下来我们有一个

50:03.340 --> 50:04.340
两个对数组的操作

50:04.340 --> 50:05.340
一个是reverse

50:05.340 --> 50:07.340
一个是unshift

50:07.340 --> 50:08.340
一个是翻转数组

50:08.340 --> 50:09.340
一个是头部插入

50:09.340 --> 50:10.340
那么这样子

50:10.340 --> 50:11.340
会有什么样的影响呢

50:11.340 --> 50:13.340
我们打开看一下吧

50:13.340 --> 50:15.340
效果是没有任何问题的

50:15.340 --> 50:17.340
我们先看看翻转数组

50:17.340 --> 50:18.340
你看是不是翻转了

50:18.340 --> 50:19.340
对吧

50:19.340 --> 50:21.340
我们为了看点方便

50:22.340 --> 50:25.720
一二三四五

50:25.720 --> 50:27.720
翻转都没问题

50:27.720 --> 50:28.720
头部插入

50:28.720 --> 50:30.720
前面插入一个一板

50:30.720 --> 50:31.720
都没问题对吧

50:31.720 --> 50:33.720
为什么说这样子不好呢

50:33.720 --> 50:34.720
为什么要加上keyz呢

50:34.720 --> 50:35.720
现在可以解释了

50:35.720 --> 50:37.720
所以我们看这里

50:37.720 --> 50:39.720
如果说你不加keyz的话

50:39.720 --> 50:40.720
那么它会生成两次

50:40.720 --> 50:41.720
第一次是就的

50:41.720 --> 50:42.720
对吧一开始加来的时候

50:42.720 --> 50:44.720
是一二三四五是就的

50:44.720 --> 50:46.720
但是它有没有keyz

50:46.720 --> 50:47.720
它只有一个元素类型

50:47.720 --> 50:48.720
元素类型都一样

50:48.720 --> 50:50.720
元素类型都是li

50:51.720 --> 50:53.720
然后呢

50:55.720 --> 50:57.720
然后新接点也是5个li

50:57.720 --> 50:59.720
都没有keyz

50:59.720 --> 51:01.720
真实元素里边

51:01.720 --> 51:03.720
有一个数字一二三四五

51:03.720 --> 51:05.720
如果不加keyz会怎么样

51:05.720 --> 51:07.720
它会认为这两个是

51:07.720 --> 51:08.720
相同的接点

51:08.720 --> 51:09.720
导续过后

51:09.720 --> 51:10.720
导续过后

51:10.720 --> 51:11.720
应该是五四三二一

51:11.720 --> 51:12.720
但是它认为

51:12.720 --> 51:14.720
这两个是相同的接点

51:14.720 --> 51:15.720
因为它没有keyz

51:15.720 --> 51:16.720
元素类型又一样

51:16.720 --> 51:18.720
于是它会怎么样

51:18.720 --> 51:20.720
它会把这两个新旧接点

51:20.720 --> 51:21.720
进行对比

51:21.720 --> 51:23.720
发现就进入更新流程

51:23.720 --> 51:25.720
更新流程里边会怎么样

51:25.720 --> 51:27.720
如果说有样式

51:27.720 --> 51:29.720
如果说里边li有样式

51:29.720 --> 51:30.720
没问题

51:30.720 --> 51:31.720
那就去复制样式

51:31.720 --> 51:32.720
那把这堆全部复制

51:32.720 --> 51:34.720
把也属性更新

51:34.720 --> 51:35.720
更新到真实动

51:35.720 --> 51:36.720
然后呢

51:36.720 --> 51:38.720
它会去

51:38.720 --> 51:40.720
便利它的指元素

51:40.720 --> 51:41.720
进入便利指元素了

51:41.720 --> 51:43.720
然后对指元素进行更新

51:43.720 --> 51:45.720
但是你想一想

51:45.720 --> 51:46.720
由于这两个东西

51:46.720 --> 51:48.720
本来不是一个

51:48.720 --> 51:49.720
但是呢

51:49.720 --> 51:50.720
我们把它当成一个了

51:50.720 --> 51:51.720
那么它类

51:51.720 --> 51:52.720
指元素的更新

51:52.720 --> 51:53.720
是不是非常大

51:53.720 --> 51:54.720
一会说

51:54.720 --> 51:55.720
拉去什么大的

51:55.720 --> 51:56.720
就是把它改成

51:56.720 --> 51:57.720
五就完事了呗

51:57.720 --> 51:58.720
是

51:58.720 --> 51:59.720
在这个例子里面

51:59.720 --> 52:00.720
是不大

52:00.720 --> 52:01.720
它只有一个数字

52:01.720 --> 52:02.720
但是你想想

52:02.720 --> 52:03.720
真实的情况里边

52:03.720 --> 52:04.720
它有可能说

52:04.720 --> 52:05.720
这里边有可能有div

52:05.720 --> 52:06.720
div里边有可能p元素

52:06.720 --> 52:07.720
p元素里边

52:07.720 --> 52:08.720
可能有双元素

52:08.720 --> 52:09.720
然后这里边

52:09.720 --> 52:10.720
是不是可能有image

52:10.720 --> 52:11.720
这边很多东西都不一样

52:11.720 --> 52:12.720
是不是它

52:12.720 --> 52:13.720
那么它这里边

52:13.720 --> 52:14.720
虽然从y一边li

52:14.720 --> 52:15.720
没有什么改动

52:15.720 --> 52:16.720
但是这里边的改动东西

52:16.720 --> 52:17.720
是不是特别多

52:18.720 --> 52:19.720
对吧

52:19.720 --> 52:20.720
一面前有的时候

52:20.720 --> 52:21.720
它可能有

52:21.720 --> 52:22.720
如果说有数据的时候

52:22.720 --> 52:23.720
要显示

52:23.720 --> 52:24.720
没有图片的时候就不显示

52:24.720 --> 52:26.720
所以元素结构都不一样

52:26.720 --> 52:27.720
所以从这里边

52:27.720 --> 52:28.720
改动是不是特别大

52:29.720 --> 52:30.720
那么造成了效率的问题

52:30.720 --> 52:31.720
因为我们想一想

52:31.720 --> 52:32.720
这个道理

52:32.720 --> 52:34.720
你看到一个列表的时候

52:34.720 --> 52:36.720
我要把这个列表倒去

52:36.720 --> 52:37.720
你觉得是

52:37.720 --> 52:38.720
每一个每一个层

52:38.720 --> 52:39.720
里边去改动

52:39.720 --> 52:40.720
好了

52:40.720 --> 52:41.720
还是把它移动出去

52:41.720 --> 52:42.720
去好一点

52:43.720 --> 52:44.720
虽然说

52:44.720 --> 52:45.720
我们单从单次改动

52:45.720 --> 52:46.720
和移动出去来讲

52:46.720 --> 52:47.720
肯定是单次改动

52:48.720 --> 52:49.720
效率要高一些

52:49.720 --> 52:50.720
但是改动东西太多了

52:50.720 --> 52:51.720
也不行了

52:51.720 --> 52:52.720
里边很多内容基本上

52:52.720 --> 52:53.720
全部要变完

52:53.720 --> 52:54.720
那肯定也不行了

52:55.720 --> 52:56.720
这个效率很低的

52:56.720 --> 52:57.720
所以还不如期

52:57.720 --> 52:58.720
移动元素要好一点

52:58.720 --> 52:59.720
对不对

52:59.720 --> 53:00.720
但是目前

53:00.720 --> 53:01.720
由于它没有加气质

53:01.720 --> 53:02.720
它就是

53:02.720 --> 53:03.720
它就是改动所有的那种

53:03.720 --> 53:05.720
虽然我们只有一个n

53:05.720 --> 53:06.720
就可以磨粒这种情况

53:06.720 --> 53:08.720
里边实际上是改完了的

53:08.720 --> 53:09.720
如果说里边有

53:09.720 --> 53:10.720
1000个职员数

53:10.720 --> 53:11.720
全部改完

53:11.720 --> 53:12.720
全部一个一个对比完

53:12.720 --> 53:13.720
改完

53:13.720 --> 53:14.720
对不对

53:14.720 --> 53:15.720
那么我们如果说

53:15.720 --> 53:16.720
没有气质的话

53:16.720 --> 53:17.720
那就是

53:17.720 --> 53:19.720
它去改一百东西

53:19.720 --> 53:20.720
改成1

53:20.720 --> 53:21.720
然后连过来

53:21.720 --> 53:22.720
这里改成

53:22.720 --> 53:23.720
这里是

53:23.720 --> 53:24.720
对

53:24.720 --> 53:25.720
这里是改成5连过来

53:25.720 --> 53:26.720
这里改成4

53:26.720 --> 53:27.720
这里改成3

53:27.720 --> 53:28.720
3不用动

53:28.720 --> 53:29.720
2

53:29.720 --> 53:30.720
1

53:30.720 --> 53:31.720
除了这个玩意

53:31.720 --> 53:32.720
全部改完

53:32.720 --> 53:33.720
里边的所有东西

53:33.720 --> 53:34.720
全部改完

53:34.720 --> 53:35.720
那么这样子

53:35.720 --> 53:36.720
效率比较低

53:36.720 --> 53:37.720
但是如果说

53:38.720 --> 53:39.720
它有了气质

53:39.720 --> 53:40.720
就不一样了

53:40.720 --> 53:41.720
比方说这里呢

53:42.720 --> 53:43.720
这里5

53:43.720 --> 53:44.720
4

53:44.720 --> 53:45.720
3

53:45.720 --> 53:46.720
2

53:46.720 --> 53:47.720
1

53:47.720 --> 53:48.720
说明这种情况

53:48.720 --> 53:49.720
当然是

53:49.720 --> 53:50.720
真实情况里面

53:50.720 --> 53:51.720
可能是某一个东西的ID

53:51.720 --> 53:52.720
都一样

53:53.720 --> 53:54.720
有了气质过后

53:54.720 --> 53:55.720
它是怎么样的呢

53:55.720 --> 53:56.720
它是不是就变成移动了

53:56.720 --> 53:57.720
对吧

53:57.720 --> 53:58.720
头头不相同

53:58.720 --> 53:59.720
尾位不相同

53:59.720 --> 54:00.720
然后头位相同

54:00.720 --> 54:01.720
然后是不是移动

54:01.720 --> 54:03.720
把这种移过来

54:03.720 --> 54:04.720
然后呢

54:04.720 --> 54:05.720
干嘛呀

54:05.720 --> 54:07.720
这个玩意往这边指

54:07.720 --> 54:09.720
这个玩意往这边指

54:09.720 --> 54:10.720
接下来

54:10.720 --> 54:11.720
把这个玩意

54:11.720 --> 54:12.720
2.1过来

54:17.610 --> 54:18.610
2是移动到这

54:19.610 --> 54:20.610
移动到尾巴后边

54:22.610 --> 54:23.610
刚才是

54:24.610 --> 54:25.610
整运的

54:25.610 --> 54:26.610
刚才是这个玩意

54:26.610 --> 54:27.610
重新再重新再重新再重新的

54:27.610 --> 54:28.610
总之它会移动到

54:28.610 --> 54:29.610
一个合适的位置

54:29.610 --> 54:30.610
对吧

54:30.610 --> 54:31.610
好

54:31.610 --> 54:32.610
再来

54:32.610 --> 54:33.610
应该是它和头位

54:33.610 --> 54:34.610
头位比较

54:34.610 --> 54:35.610
头位比较的话

54:35.610 --> 54:36.610
那么这里的

54:36.610 --> 54:37.610
应该移过来

54:38.610 --> 54:39.610
然后再对比里边的

54:39.610 --> 54:40.610
对吧

54:40.610 --> 54:41.610
但是里边的

54:41.610 --> 54:42.610
所以说对真实动物的

54:42.610 --> 54:43.610
改动是很小的

54:43.610 --> 54:44.610
一不是没有动

54:44.610 --> 54:45.610
你想吧

54:45.610 --> 54:46.610
这里边虽然会不会对比

54:46.610 --> 54:47.610
会对比

54:47.610 --> 54:48.610
但对比的速度很快

54:48.610 --> 54:50.610
但是改动真实动物是很慢的

54:50.610 --> 54:52.610
它会不会改动真实动物

54:52.610 --> 54:53.610
它只是移动了位置

54:53.610 --> 54:54.610
它没有改动真实动物

54:54.610 --> 54:55.610
里边的一个东西都没改

54:55.610 --> 54:57.610
因为它里边都是一样的

54:57.610 --> 54:58.610
对吧

54:58.610 --> 54:59.610
然后

54:59.610 --> 55:01.610
这边往这边移动

55:01.610 --> 55:02.610
这边往这边移动

55:02.610 --> 55:04.610
然后又是2.2

55:04.610 --> 55:05.610
这个玩意移过来

55:05.610 --> 55:06.610
然后移动

55:08.610 --> 55:09.610
3.3

55:09.610 --> 55:10.610
就不用动了

55:10.610 --> 55:13.180
3.1

55:13.180 --> 55:14.180
要动了

55:14.180 --> 55:15.180
要动

55:15.180 --> 55:16.180
移动到这

55:17.180 --> 55:19.180
然后再过来

55:19.180 --> 55:20.180
是就是移动到这

55:20.180 --> 55:22.180
最后5不用动了

55:23.180 --> 55:24.180
就变成这样子的

55:24.180 --> 55:25.180
5321

55:25.180 --> 55:27.180
当然这边会连起来

55:27.180 --> 55:29.180
这样子是不是就没有改动

55:29.180 --> 55:30.180
它里边的东西

55:30.180 --> 55:31.180
我们

55:31.180 --> 55:32.180
但是我们脑袋里面一定要想

55:32.180 --> 55:33.180
它里面东西很多的

55:33.180 --> 55:34.180
它不是一个数字而已

55:34.180 --> 55:35.180
它里面很

55:35.180 --> 55:36.180
一大块的

55:36.180 --> 55:37.180
甚至还有一些指住键

55:37.180 --> 55:39.180
指住键里面还有指住键

55:39.180 --> 55:40.180
那么这样子

55:40.180 --> 55:41.180
如果说

55:41.180 --> 55:42.180
移动操作的话

55:42.180 --> 55:43.180
要去改的话

55:43.180 --> 55:45.180
要改动量太大了

55:45.180 --> 55:47.180
基本很多东西都要变

55:47.180 --> 55:48.180
这就是

55:48.180 --> 55:49.180
为什么我们要加上key

55:50.180 --> 55:51.180
加上key过后

55:51.180 --> 55:52.180
它就能知道

55:52.180 --> 55:53.180
哪个节点对于哪个节点

55:53.180 --> 55:55.180
然后还有一个更加明显的

55:55.180 --> 55:56.180
就是头部插入

55:56.180 --> 55:57.180
你看

55:57.180 --> 55:59.180
如果说你不进行更改的话

55:59.180 --> 56:00.180
多恐怖这个事情

56:07.740 --> 56:09.740
头部我们现在插入一个

56:10.740 --> 56:11.740
100

56:11.740 --> 56:13.740
就这些都没有key

56:13.740 --> 56:14.740
你自己想吧

56:14.740 --> 56:16.740
都没有key的情况下

56:16.740 --> 56:18.740
我们在头部里边插入一个100

56:22.070 --> 56:23.070
都没有key

56:23.070 --> 56:24.070
那你想一想

56:24.070 --> 56:26.070
现在的情况又是怎么情况

56:27.070 --> 56:30.070
如果说你没有key指的话

56:30.070 --> 56:31.070
相同

56:31.070 --> 56:33.070
先把它改成100

56:33.070 --> 56:34.070
然后再把它

56:34.070 --> 56:35.070
改成5

56:35.070 --> 56:36.070
再把它改成4

56:36.070 --> 56:37.070
再把它改成3

56:37.070 --> 56:38.070
再把它改成2

56:38.070 --> 56:39.070
然后1没有

56:39.070 --> 56:41.070
1没有去创建一个1

56:41.070 --> 56:42.070
要用这种方式

56:42.070 --> 56:43.070
那没办法

56:43.070 --> 56:44.070
都对应不上

56:44.070 --> 56:45.070
都是对应上的

56:45.070 --> 56:46.070
头都是对应上的

56:46.070 --> 56:47.070
对吧

56:47.070 --> 56:48.070
那没办法

56:48.070 --> 56:49.070
那于是

56:49.070 --> 56:50.070
我们就看到这样一个

56:50.070 --> 56:51.070
神奇的现象

56:51.070 --> 56:52.070
我们检查

56:52.070 --> 56:53.070
看一下前面

56:53.070 --> 56:54.070
头部插入100

56:54.070 --> 56:55.070
你看是不是

56:55.070 --> 56:56.070
每个li都改动过了

56:56.070 --> 56:57.070
对吧

56:57.070 --> 56:59.070
这个是最后一个是新建的

56:59.070 --> 57:01.070
这个1是新建

57:01.070 --> 57:03.070
头部插入5

57:03.070 --> 57:04.070
5是新建的

57:04.070 --> 57:05.070
再刷新

57:05.070 --> 57:06.070
我们来看一下

57:06.070 --> 57:07.070
散了一下

57:07.070 --> 57:08.070
对吧

57:08.070 --> 57:10.070
头部插入是不是散了一下

57:10.070 --> 57:11.070
如果说

57:11.070 --> 57:13.070
我们加上key会怎么样呢

57:14.070 --> 57:15.070
刚才第1个情况

57:15.070 --> 57:16.070
已经演示过了

57:16.070 --> 57:17.070
加上个key

57:17.070 --> 57:19.070
然后我们来再看

57:19.070 --> 57:20.070
头部插入

57:20.070 --> 57:22.070
是不是只增加了一个li

57:22.070 --> 57:23.070
对吧

57:23.070 --> 57:25.070
那是它是怎么回事的

57:25.070 --> 57:26.070
那么一开始是

57:26.070 --> 57:28.070
1 2 3 4 5

57:28.070 --> 57:29.070
那么这边

57:29.070 --> 57:31.070
1 2 3 4 5

57:31.070 --> 57:33.070
全面是100

57:33.070 --> 57:34.070
那里看吧

57:34.070 --> 57:35.070
怎么弄的呢

57:35.070 --> 57:37.070
1跟100不行

57:37.070 --> 57:38.070
5跟5

57:38.070 --> 57:39.070
是不是可以

57:39.070 --> 57:40.070
那么5跟5可以的话

57:40.070 --> 57:41.070
怎么样

57:41.070 --> 57:42.070
重复用这个元数就行了

57:42.070 --> 57:43.070
把连过来对吧

57:43.070 --> 57:44.070
连过来

57:44.070 --> 57:45.070
就连过来就可以了

57:45.070 --> 57:47.070
然后往这边移动

57:47.070 --> 57:48.070
这边移动

57:48.070 --> 57:49.070
4跟4是不是可以

57:49.070 --> 57:50.070
尾部相同对吧

57:50.070 --> 57:51.070
移动

57:51.070 --> 57:52.070
移动

57:52.070 --> 57:53.070
3跟3可以

57:53.070 --> 57:54.070
不动

57:54.070 --> 57:55.070
2跟2可以

57:55.070 --> 57:56.070
不动

57:56.070 --> 57:57.070
然后移动到这了

57:57.070 --> 57:59.070
1跟1也可以

57:59.070 --> 58:00.070
1跟1可以

58:00.070 --> 58:01.070
然后的移动

58:01.070 --> 58:03.070
那么这边就的数据完了

58:03.070 --> 58:04.070
对吧

58:04.070 --> 58:05.070
那么新的数还剩一个节点

58:05.070 --> 58:06.070
新建一个

58:06.070 --> 58:07.070
新建一个插到的

58:07.070 --> 58:08.070
它前面就完事了

58:08.070 --> 58:09.070
是不是只新建了一个节点

58:09.070 --> 58:10.070
现在都没有移动

58:10.070 --> 58:12.070
连移动都没有移动

58:12.070 --> 58:13.070
对吧

58:13.070 --> 58:14.070
这样子的效率会高很多

58:14.070 --> 58:15.070
加上Key

58:15.070 --> 58:16.070
这样Key主要是

58:16.070 --> 58:18.070
解决效率的问题

58:18.070 --> 58:19.070
好

58:19.070 --> 58:20.070
这是第一个例子

58:20.070 --> 58:21.070
解释清楚了

58:21.070 --> 58:23.070
第二个例子是这个

58:23.070 --> 58:24.070
看一下吧

58:24.070 --> 58:25.070
这里有个D

58:26.070 --> 58:27.070
我们来看一下例子

58:27.070 --> 58:28.070
看一下效果就知道了

58:28.070 --> 58:30.070
就说我这里要切换手机号登录

58:30.070 --> 58:31.070
和账号登录

58:31.070 --> 58:32.070
这个例子非常简单

58:32.070 --> 58:34.070
我这里有个DIV

58:34.070 --> 58:35.070
点击A元数

58:35.070 --> 58:36.070
我就有个属性

58:36.070 --> 58:37.070
叫做是不是

58:37.070 --> 58:39.070
是否是账号登录

58:39.070 --> 58:40.070
一开始没人委屈

58:40.070 --> 58:41.070
如果说点击

58:41.070 --> 58:42.070
第一个A元数

58:42.070 --> 58:43.070
我就把A元数

58:43.070 --> 58:44.070
点击第二个A元数

58:44.070 --> 58:45.070
我就把A元数

58:45.070 --> 58:46.070
表示手机号登录

58:46.070 --> 58:47.070
就不是账号登录了

58:47.070 --> 58:49.070
这里我是阻止没人行为

58:49.070 --> 58:50.070
不然还有一个超链接

58:50.070 --> 58:51.070
要刷新一面

58:51.070 --> 58:53.070
然后下边有两个DIV

58:53.070 --> 58:54.070
一个DIV

58:54.070 --> 58:55.070
如果说是账号登录

58:55.070 --> 58:56.070
我就显示这个地方

58:56.070 --> 58:57.070
我就显示这个

58:57.070 --> 58:58.070
如果说是手机号登录

58:58.070 --> 58:59.070
我就显示这个

59:00.070 --> 59:01.070
就这么简单

59:01.070 --> 59:02.070
对吧

59:02.070 --> 59:03.070
然后我们这里

59:03.070 --> 59:04.070
是不是可以切换了

59:04.070 --> 59:05.070
但是现在有一个问题

59:05.070 --> 59:06.070
什么问题呢

59:06.070 --> 59:07.070
就是我账号里边输入一东西

59:07.070 --> 59:08.070
我切换到手机号的时候

59:08.070 --> 59:09.070
它还在

59:09.070 --> 59:10.070
那为什么还在呢

59:10.070 --> 59:11.070
那么这里就需要

59:11.070 --> 59:13.070
用那个虚拟动物点点的

59:13.070 --> 59:14.070
地府算法去理解

59:15.070 --> 59:16.070
你看这两个DIV

59:16.070 --> 59:17.070
要么显示这个

59:17.070 --> 59:18.070
要么显示这个对吧

59:18.070 --> 59:20.070
就要么生成这个虚拟动物

59:20.070 --> 59:21.070
要么生成这个虚拟动物

59:21.070 --> 59:22.070
两个生成的虚拟动物

59:22.070 --> 59:23.070
是不是一都一样的

59:23.070 --> 59:24.070
它们没有keyz

59:24.070 --> 59:25.070
keyz undefend

59:25.070 --> 59:27.070
keyz一样嘛

59:27.070 --> 59:29.070
新的输了是这个DIV

59:30.070 --> 59:31.070
keyz也一样

59:31.070 --> 59:32.070
也是undefend

59:32.070 --> 59:33.070
两个DIV的类型

59:33.070 --> 59:34.070
也是一样

59:34.070 --> 59:35.070
说前后两个DIV

59:35.070 --> 59:36.070
就丢出了这个DIV

59:36.070 --> 59:37.070
然后切换过后

59:37.070 --> 59:38.070
就是新输的DIV

59:38.070 --> 59:39.070
是不是都是同一个节点

59:39.070 --> 59:40.070
相同节点

59:41.070 --> 59:42.070
对吧

59:42.070 --> 59:43.070
它把它当成相同节点

59:43.070 --> 59:44.070
于是里面对比

59:44.070 --> 59:45.070
你发现这个节点

59:45.070 --> 59:46.070
也跟这个节点

59:46.070 --> 59:47.070
也是相同节点

59:47.070 --> 59:48.070
而这个节点跟这个节点

59:48.070 --> 59:49.070
是相同节点

59:49.070 --> 59:50.070
只是内容不一样

59:50.070 --> 59:51.070
内容不一样更新

59:51.070 --> 59:52.070
它就会把账号

59:52.070 --> 59:53.070
改成手机号

59:53.070 --> 59:54.070
然后这个节点

59:54.070 --> 59:55.070
和这个节点

59:55.070 --> 59:56.070
也是相同节点

59:56.070 --> 59:57.070
因为它们都是

59:57.070 --> 59:58.070
银铺的元素

59:58.070 --> 59:59.070
type的都有一text

59:59.070 --> 01:00:00.070
都是相同节点

01:00:00.070 --> 01:00:01.070
好都是相同节点的话

01:00:01.070 --> 01:00:03.070
那么它只会

01:00:03.070 --> 01:00:04.070
它就会重复用这个节点

01:00:04.070 --> 01:00:05.070
重复用几个节点

01:00:05.070 --> 01:00:06.070
就导致了

01:00:06.070 --> 01:00:07.070
它里边内容没有消失

01:00:07.070 --> 01:00:08.070
看到没

01:00:08.070 --> 01:00:09.070
就这个问题

01:00:09.070 --> 01:00:10.070
那么这个问题

01:00:10.070 --> 01:00:11.070
怎么解决呢

01:00:11.070 --> 01:00:12.070
我只要把它

01:00:12.070 --> 01:00:13.070
让它前后

01:00:13.070 --> 01:00:14.070
认为是不相同的节点

01:00:14.070 --> 01:00:15.070
是不是就完事了

01:00:15.070 --> 01:00:16.070
那怎么办呢

01:00:16.070 --> 01:00:17.070
我可以在这里

01:00:17.070 --> 01:00:18.070
加上一个key

01:00:18.070 --> 01:00:20.070
它为1

01:00:20.070 --> 01:00:21.070
加上个key

01:00:21.070 --> 01:00:22.070
它为2

01:00:23.070 --> 01:00:24.070
对吧

01:00:24.070 --> 01:00:25.070
那么这样子

01:00:25.070 --> 01:00:26.070
虽然说

01:00:26.070 --> 01:00:27.070
元素内容和type

01:00:27.070 --> 01:00:28.070
都是相同的

01:00:28.070 --> 01:00:29.070
但是key也不一样

01:00:29.070 --> 01:00:30.070
它们不是相同节点

01:00:30.070 --> 01:00:31.070
不是相同节点怎么办

01:00:31.070 --> 01:00:32.070
那这个东西只能扔掉

01:00:32.070 --> 01:00:33.070
这个东西

01:00:33.070 --> 01:00:34.070
创建

01:00:34.070 --> 01:00:35.070
因为key为2的东西

01:00:35.070 --> 01:00:36.070
在里边找不到了

01:00:36.070 --> 01:00:37.070
没有key为2的

01:00:37.070 --> 01:00:38.070
好

01:00:38.070 --> 01:00:39.070
保存

01:00:39.070 --> 01:00:40.070
再看一下

01:00:40.070 --> 01:00:41.070
账号

01:00:41.070 --> 01:00:42.070
接完手机号是没了

01:00:42.070 --> 01:00:43.070
对吧

01:00:43.070 --> 01:00:44.070
那么这一张

01:00:44.070 --> 01:00:45.070
也可以通过key子来处理

01:00:45.070 --> 01:00:46.070
然后key子

01:00:46.070 --> 01:00:47.070
也可以加到这

01:00:47.070 --> 01:00:48.070
加到这的话

01:00:48.070 --> 01:00:50.830
它影响的范围就更廣了

01:00:50.830 --> 01:00:51.830
影响到什么呢

01:00:51.830 --> 01:00:52.830
就是说

01:00:52.830 --> 01:00:53.830
这整个div

01:00:53.830 --> 01:00:54.830
它对比的时候

01:00:54.830 --> 01:00:55.830
它跟它

01:00:55.830 --> 01:00:56.830
对比不上

01:00:56.830 --> 01:00:57.830
那么整个div

01:00:57.830 --> 01:00:58.830
全部消费

01:00:58.830 --> 01:00:59.830
这里边

01:00:59.830 --> 01:01:00.830
整个div

01:01:00.830 --> 01:01:01.830
全部内容重新上节

01:01:01.830 --> 01:01:02.830
那么到时候

01:01:02.830 --> 01:01:03.830
真正的开发里边

01:01:03.830 --> 01:01:04.830
根据你自己的需要

01:01:04.830 --> 01:01:05.830
来进行

01:01:05.830 --> 01:01:06.830
处理

01:01:06.830 --> 01:01:07.830
这是关于这两个例子

01:01:07.830 --> 01:01:09.830
其实key子对我们的影响

01:01:09.830 --> 01:01:10.830
在开发的时候

01:01:10.830 --> 01:01:11.830
绝大部分情况下

01:01:11.830 --> 01:01:13.830
就是在循环的时候

01:01:13.830 --> 01:01:14.830
加上就ok了

01:01:15.830 --> 01:01:16.830
好了

01:01:16.830 --> 01:01:17.830
那么咱们这节课

01:01:17.830 --> 01:01:18.830
对于这个div

01:01:18.830 --> 01:01:19.830
就聊到这里

