WEBVTT

00:01.010 --> 00:03.890
这个特响讲一个面识题

00:03.890 --> 00:08.250
面识题呢就说 问你如何去理解

00:08.250 --> 00:09.810
无忧的虚拟动

00:09.810 --> 00:13.250
那你看这种面识题就是一个非常宽泛的面识题

00:13.250 --> 00:14.610
他问你理解

00:14.610 --> 00:17.850
那你理解的话就是怎么回答呢

00:17.850 --> 00:20.450
知无不言 言无不尽

00:20.450 --> 00:23.450
你把你能够想到的跟他相关的全部回答出来

00:23.450 --> 00:25.850
稍微组织一下语言全部回答出来

00:25.850 --> 00:28.050
因为像这种比较宽泛的问题呢

00:28.050 --> 00:30.250
他就想知道你到底理解了多少

00:30.690 --> 00:32.810
如果说你非常简要的给他回答了

00:32.810 --> 00:34.290
他认为你只知道这么多

00:34.290 --> 00:37.290
所以说你尽量的回答详细一点

00:37.290 --> 00:40.330
那么这里我给他做没这道面识题的意思呢

00:40.330 --> 00:42.530
给他说一下这个面识题怎么去回答

00:42.530 --> 00:46.210
不要去理解了过后用自己的语言描述出来

00:46.210 --> 00:47.690
平时没事的时候

00:47.690 --> 00:50.290
像说三步的时候在公交地鞋上的时候

00:50.290 --> 00:51.330
就可以回忆一下

00:51.330 --> 00:52.250
如果说问到这样的问题

00:52.250 --> 00:54.530
我用自己的语言组织一下怎么去回答

00:54.530 --> 00:56.370
所以用前条链你得理解

00:56.370 --> 00:59.090
这是第一个我要给大家讲这个面识题

00:59.290 --> 01:01.850
第二个是我希望通过这个面识题

01:01.850 --> 01:03.810
加深大家对舞优的理解

01:05.530 --> 01:07.690
好那么这个具体的面识题里边

01:09.290 --> 01:09.850
你能不能回答

01:09.850 --> 01:11.730
你可以从这个四个方面去回答

01:11.730 --> 01:14.690
第一个什么到底什么东西是蓄力冬

01:15.370 --> 01:18.170
蓄力冬的本质上就是一个普通的介绍

01:18.170 --> 01:20.170
像这个笔记里面有些图

01:20.170 --> 01:21.970
你在面试的时候肯定是没发画图的

01:21.970 --> 01:23.490
那么这个图的目的呢

01:23.490 --> 01:26.090
主要是为了变于我来讲解

01:26.170 --> 01:28.770
给你讲解 把你让你更讲理解

01:29.770 --> 01:32.290
好 蓄力冬本质上就是一个普通的介绍对象

01:32.290 --> 01:33.610
这是我们以前说过的 对吧

01:33.610 --> 01:35.970
那么这个介绍对象在哪里可以看得到呢

01:36.690 --> 01:37.930
在哪里可以看得到呢

01:37.930 --> 01:41.850
我们可以在每个组建里边

01:41.850 --> 01:43.530
可以写上这么一个生命中心函数

01:43.530 --> 01:44.130
叫Mounted

01:44.650 --> 01:46.690
在Mounted里边我们输出一下Z

01:47.210 --> 01:48.050
看一下吧

01:49.010 --> 01:51.890
是不是得到这个组建的实力

01:52.610 --> 01:53.090
对吧

01:53.610 --> 01:54.770
这个是监过的吧

01:54.770 --> 01:55.810
得到组建实力

01:56.130 --> 01:57.610
这是图建实力里边有很多属性

01:57.610 --> 02:00.090
多了开头的你可以用下滑线开头的

02:01.370 --> 02:04.010
这里面有一个属性叫做下滑线Vnode

02:05.050 --> 02:06.010
这就是这个组建

02:07.010 --> 02:08.250
它生成出来的蓄力冬

02:09.250 --> 02:10.650
所以说你可以通过这种方式

02:10.650 --> 02:12.570
来看到这个组建生成了蓄力冬

02:12.570 --> 02:13.770
但它是一个塑形结构

02:14.650 --> 02:16.010
你看是不是一个DIV

02:16.890 --> 02:17.930
是不是一个普通的介绍对象

02:18.530 --> 02:19.730
对不对 是个普通的介绍对象吧

02:20.610 --> 02:22.370
然后这个他描述了什么

02:22.370 --> 02:23.210
描述了是这个东西

02:24.170 --> 02:24.690
DIV

02:25.050 --> 02:26.770
然后DIV里面有两个指示元素

02:26.770 --> 02:27.650
一个是Image

02:27.970 --> 02:30.250
一个是什么Hello World

02:30.250 --> 02:31.130
是另外一个组建

02:31.130 --> 02:32.290
另外一个组建比较特殊

02:33.090 --> 02:34.850
你看是不是形成了这么一种结构了

02:34.850 --> 02:35.690
一个塑形结构

02:36.210 --> 02:36.850
就这么个意思

02:37.530 --> 02:39.050
本质上就是个普通的介绍对象

02:39.050 --> 02:40.210
他用来描述什么呢

02:40.210 --> 02:42.490
描述试图的界面结构

02:42.730 --> 02:45.850
他描述说我这个界面上有什么东西

02:45.850 --> 02:47.410
他的结构应该是什么样子

02:47.410 --> 02:48.530
他并不显示界面

02:49.090 --> 02:50.490
虚动物他并不显示界面

02:50.490 --> 02:51.890
他只是用来进行描述的

02:52.490 --> 02:53.810
他描述说我这个DIV

02:53.970 --> 02:55.450
你看简单看一下

02:55.450 --> 02:56.650
简单看一下就行了

02:56.650 --> 02:58.730
它是一个构造函数通过被揉的窗间的

02:59.250 --> 03:01.530
它的标签名是DIV

03:01.530 --> 03:01.970
在哪里呢

03:01.970 --> 03:02.330
在这

03:03.210 --> 03:04.290
标签名是DIV

03:04.810 --> 03:08.130
然后它的复原处不用管

03:09.090 --> 03:12.730
这里它的Data表示这个DIV的哪些属性

03:13.410 --> 03:15.970
DIV哪些数据有一些属性

03:15.970 --> 03:16.890
A为1

03:16.890 --> 03:17.410
B为2

03:17.410 --> 03:18.250
ID为App

03:18.250 --> 03:19.210
你看A为1

03:19.210 --> 03:19.730
B为2

03:19.730 --> 03:20.490
ID为App

03:21.130 --> 03:21.930
看没问题吧

03:22.370 --> 03:25.170
然后它有哪些指援数呢

03:25.170 --> 03:25.770
Children

03:25.770 --> 03:26.050
对吧

03:26.050 --> 03:26.690
一个数组

03:27.090 --> 03:28.010
有个Image

03:28.010 --> 03:30.290
Image里边有哪些属性的

03:30.290 --> 03:31.170
你看有Alt

03:31.170 --> 03:32.170
有SRC

03:32.170 --> 03:32.730
你看

03:33.170 --> 03:33.690
Alt

03:33.690 --> 03:34.490
SRC

03:35.330 --> 03:36.050
没问题吧

03:36.050 --> 03:38.290
它通过这种方式来描述

03:38.290 --> 03:39.610
因为普通的界对象

03:39.610 --> 03:41.930
来描述我们界面上应该有哪些东西

03:41.930 --> 03:43.090
它并不生成前面

03:43.930 --> 03:44.930
就这么个意思

03:45.730 --> 03:45.970
好

03:45.970 --> 03:47.370
接下来我们再往下看

03:47.650 --> 03:49.770
在尾右中的每一个组件

03:49.770 --> 03:51.170
是不是都有一个Render函数

03:51.250 --> 03:52.170
我们之前学过的

03:52.730 --> 03:54.050
这个Render函数用来干嘛的

03:54.050 --> 03:55.730
就用来创建蓄力动物的

03:55.930 --> 03:56.570
还记得吗

03:56.570 --> 03:57.290
当时我们学过

03:57.290 --> 03:59.730
在很早的时候入门的时候

03:59.730 --> 04:00.090
对吧

04:00.530 --> 04:01.490
学过这个Render函数

04:01.490 --> 04:03.050
这个Render函数是会创建蓄力动物的

04:03.050 --> 04:05.250
通过这个A型函数来创建的蓄力动

04:05.250 --> 04:06.170
比方说DIV

04:06.170 --> 04:08.130
它里边的内容是ABC

04:08.130 --> 04:08.570
是吧

04:08.570 --> 04:10.170
创建了这么一个蓄力动

04:10.810 --> 04:11.410
没问题吧

04:12.010 --> 04:12.450
好

04:13.010 --> 04:14.210
于是呢

04:14.210 --> 04:15.490
就意味着

04:15.770 --> 04:16.730
你看这个逻辑

04:16.730 --> 04:18.690
每个组件是不是有人的函数

04:18.690 --> 04:20.290
每个人的函数是不是都会返回

04:20.290 --> 04:21.170
一个蓄力动物数

04:21.170 --> 04:21.770
对吧

04:21.770 --> 04:23.290
有些人说不是蓄力动物数

04:23.290 --> 04:24.370
是一个蓄力动物

04:24.370 --> 04:26.090
那你可以没有给他写数型结构

04:26.090 --> 04:26.970
那你看吧

04:27.250 --> 04:28.810
我给他一个数组

04:28.810 --> 04:29.250
对吧

04:29.250 --> 04:30.610
他的所有指援数

04:30.610 --> 04:31.570
这是第一个

04:31.570 --> 04:34.010
第一个指援数是一个H1

04:34.010 --> 04:36.090
通过是不是通过A型函数来创建

04:36.090 --> 04:37.730
A型的内容是

04:38.330 --> 04:39.290
开头1

04:40.490 --> 04:42.450
所以一个指援数了

04:42.450 --> 04:44.210
然后再来一个H2

04:44.770 --> 04:45.730
开头2

04:47.250 --> 04:47.970
2

04:47.970 --> 04:50.050
那我现在把个模板去掉

04:50.770 --> 04:51.330
你看

04:51.330 --> 04:52.410
现在说创建

04:52.410 --> 04:54.210
这边一种蓄力动物底结构了

04:54.210 --> 04:54.890
两开头1

04:54.890 --> 04:55.650
开头2

04:55.890 --> 04:56.210
是吧

04:56.210 --> 04:57.930
然后我们再来看目前的蓄力动物

04:57.930 --> 04:59.370
DIV里面切入去

04:59.370 --> 05:00.970
是不是有两个H1 H2

05:01.170 --> 05:01.490
对吧

05:01.490 --> 05:02.050
于是他就

05:02.050 --> 05:03.450
这个蓄力动物最终是通过

05:03.450 --> 05:04.770
这个Render函数来创建的

05:05.610 --> 05:06.810
通过它来创建的

05:07.210 --> 05:08.010
懂了意思吧

05:08.770 --> 05:09.970
所以说这就意味着

05:09.970 --> 05:11.290
每一个组件

05:11.290 --> 05:13.410
它都有自己的蓄力动物数

05:13.410 --> 05:14.690
它形成这么一种关系

05:14.690 --> 05:15.850
这是我们的组件数

05:15.850 --> 05:16.450
副组件

05:16.450 --> 05:16.810
直辱件

05:16.810 --> 05:17.250
直辱件

05:17.250 --> 05:17.890
直辱件

05:18.130 --> 05:19.290
每一个组件

05:19.330 --> 05:20.370
它都有一个Render函数

05:20.370 --> 05:21.210
通过这个Render函数

05:21.210 --> 05:22.730
它会产生一个蓄力动物数

05:23.290 --> 05:25.010
那么我们可以怎么来验证这一点

05:25.290 --> 05:26.970
你看我在ABB这个组件里边

05:26.970 --> 05:28.410
输出一下自己的蓄力动物数

05:28.410 --> 05:29.690
然后在Hallower的这个组件里边

05:29.690 --> 05:30.930
我们也可以做同样的事情

05:30.930 --> 05:31.650
Mounted

05:32.050 --> 05:32.890
输出一下

05:32.890 --> 05:34.330
ZisVeload

05:35.330 --> 05:35.530
好

05:35.530 --> 05:35.850
保存

05:36.810 --> 05:37.930
给他做个标记吧

05:37.930 --> 05:40.010
这里我们是Hallower的组件

05:41.650 --> 05:43.050
这个是我们App组件

05:46.070 --> 05:46.310
好

05:46.310 --> 05:46.830
保存

05:47.190 --> 05:47.750
刷新

05:47.950 --> 05:48.990
你看Hallower的组件

05:48.990 --> 05:49.790
是不是有自己的

05:50.390 --> 05:51.390
我们看一下是App组件

05:51.430 --> 05:53.630
刚才他看到过DIV里边有两个元素

05:54.310 --> 05:55.390
这里的Emergy

05:55.390 --> 05:56.150
还有一个组件

05:56.150 --> 05:56.910
这个组件

05:56.910 --> 05:58.070
那就是对应到它了

05:58.070 --> 05:59.310
那么这颗蓄力动物数

05:59.630 --> 06:02.470
就是DIV里边有8个元素

06:02.470 --> 06:03.830
Ace, Ape, Ache3

06:03.830 --> 06:04.510
你看吧

06:05.830 --> 06:07.550
Ace, Ape, Ache3

06:07.550 --> 06:08.110
对不对

06:08.110 --> 06:09.710
它就形成这么一种结构了

06:10.190 --> 06:12.190
那么将来如果说组件更新了

06:12.630 --> 06:13.190
更新了过后

06:13.190 --> 06:14.190
它只管渲染

06:14.190 --> 06:15.030
不要这个组件更新了

06:15.030 --> 06:15.870
它只管渲染这个

06:15.870 --> 06:16.790
它自己的重新渲染

06:16.790 --> 06:18.270
它自己的蓄力动物数就OK了

06:18.710 --> 06:19.830
这是解释清楚了

06:19.830 --> 06:20.830
什么叫蓄力动物

06:20.870 --> 06:22.310
以它跟组件之间的关系

06:23.190 --> 06:23.310
好

06:23.310 --> 06:24.030
第二个问题

06:24.030 --> 06:25.390
为什么需要蓄力动物

06:27.390 --> 06:27.870
为什么呢

06:27.870 --> 06:28.710
这是因为组

06:28.710 --> 06:30.750
这是由那个5U的框架

06:30.750 --> 06:32.310
它的结构所决定的

06:33.030 --> 06:34.270
5U框架是怎么来处理

06:34.270 --> 06:35.550
见面更新的事情的

06:35.910 --> 06:37.910
你看一开始我们要选择一个组件

06:37.910 --> 06:40.150
是不是得运行一个运动轮转函数

06:40.710 --> 06:42.110
这是5U的设计

06:43.230 --> 06:44.110
那之后呢

06:44.430 --> 06:45.030
还有什么情况

06:45.030 --> 06:46.310
还会运行运动轮转函数呢

06:47.150 --> 06:48.790
它不仅发生在组件创建的时候

06:48.830 --> 06:53.110
同时发生在试图依赖的数据更新的时候

06:53.110 --> 06:53.750
这啥意思啊

06:53.750 --> 06:54.190
这句话

06:54.470 --> 06:56.710
就一开始逐渐一开始会得到一个

06:57.070 --> 06:59.190
得到就运行轮转函数来渲染界面

06:59.950 --> 07:00.870
还有什么情况呢

07:00.870 --> 07:01.790
还有说我们

07:02.150 --> 07:03.430
界面中依赖的数据

07:03.430 --> 07:05.590
你看这界面中是不是用到了这个数据

07:06.110 --> 07:06.590
对不对

07:06.870 --> 07:07.830
用到了这个数据

07:07.830 --> 07:10.030
就表示这个界面依赖这个数据

07:10.030 --> 07:10.550
就是试图

07:10.550 --> 07:11.310
试图就是界面

07:11.830 --> 07:12.710
依赖这个数据

07:13.830 --> 07:15.190
那么如果说这个数据更新的

07:15.190 --> 07:16.430
界面就会重新渲染

07:16.430 --> 07:17.670
就是重新运行轮转

07:18.310 --> 07:20.110
重新运行这个组件的轮转函数

07:20.630 --> 07:21.390
就这么个意思

07:23.230 --> 07:25.350
后边我们讲想定是数据的时候

07:25.350 --> 07:26.630
还会详细点说这个问题

07:27.950 --> 07:30.710
那如果说你看轮转函数是不是调用的非常频繁

07:30.870 --> 07:31.870
一开始要调用一次

07:31.870 --> 07:33.310
后来数据任何变化

07:33.310 --> 07:34.390
只要一代的数据变化了

07:34.390 --> 07:35.270
它都会重新调用

07:35.990 --> 07:37.910
由于它运行的比较频繁

07:38.390 --> 07:41.430
如果说我们在轮转函数里边直接

07:42.230 --> 07:43.510
创建真实的动物

07:44.670 --> 07:45.430
那会怎么样呢

07:46.430 --> 07:48.870
真实的动物的创建更新插入

07:49.870 --> 07:50.870
它有很多的问题

07:50.870 --> 07:52.230
一是它的属性非常多

07:52.230 --> 07:53.230
有一些同学觉得

07:53.230 --> 07:54.990
这个vivo的属性好多

07:55.990 --> 07:57.590
你就觉得这个东西多了

07:57.590 --> 07:58.710
那我们来看一下真实动物

07:59.470 --> 08:00.150
DIR

08:01.070 --> 08:01.670
Documents

08:01.670 --> 08:03.030
我们创建一个真实动物

08:04.070 --> 08:04.550
DIV

08:04.550 --> 08:05.830
你看一下它的属性是多少

08:10.190 --> 08:11.390
这是真实动物的属性

08:12.310 --> 08:13.430
属性里边还套属性

08:13.430 --> 08:13.750
对吧

08:14.350 --> 08:14.710
你看

08:15.310 --> 08:15.790
这些东西

08:16.510 --> 08:17.110
然后

08:18.430 --> 08:19.230
还没完

08:19.230 --> 08:19.790
下面

08:20.230 --> 08:20.950
还有它的

08:21.510 --> 08:22.990
它是一个继承结构

08:22.990 --> 08:23.670
它的复原数

08:23.670 --> 08:24.430
你看这些属性

08:25.430 --> 08:26.870
然后你看了这些东西过后

08:26.870 --> 08:27.950
再来看我们的虚拟动

08:28.590 --> 08:29.830
是不是就感觉舒服多了

08:30.390 --> 08:31.510
我们把这个求准折起来

08:32.510 --> 08:33.350
是不是就亲切多了

08:33.830 --> 08:35.670
而且它只是一个GES对象

08:35.670 --> 08:38.790
而真正恐怖的还不仅是它的属性很多

08:39.230 --> 08:40.670
还因为创建它

08:40.670 --> 08:42.350
我们把它往页面上更新

08:42.350 --> 08:43.630
去改动它的属性

08:43.630 --> 08:45.710
所以有可能会导致页面的重拍重绘

08:46.230 --> 08:47.670
那么那个效率是非常恐怖的

08:48.310 --> 08:49.830
这里我又有一个简单的例子

08:50.350 --> 08:52.310
就对比GES对象和真实动物对象

08:52.310 --> 08:52.950
给它看一下

08:52.950 --> 08:53.590
非常简单

08:54.350 --> 08:56.870
我这里定义了一个次数一千万次

08:57.510 --> 08:59.270
我这里边计时开始

08:59.670 --> 09:00.510
这里计时结束

09:00.910 --> 09:02.350
中间我就循环一千万次

09:02.350 --> 09:03.670
创建了一个普通的GES对象

09:04.230 --> 09:05.070
创建了一千万次

09:06.030 --> 09:07.350
我们看记录一下时间

09:08.150 --> 09:10.390
然后这里我又重新计时开始

09:10.390 --> 09:11.350
这是个计时标记

09:12.590 --> 09:13.630
又循环一千万次

09:13.950 --> 09:14.950
这里不一样了

09:14.990 --> 09:16.150
我创建的不是普通对象了

09:16.150 --> 09:18.150
创建的是一个普通的元素DAV

09:18.150 --> 09:19.630
我这里还没有把它加到页面上去

09:20.470 --> 09:22.070
加到页面上去更加恐怖

09:22.070 --> 09:23.870
我只是创建了一个对象而已

09:24.550 --> 09:26.510
这里还没有引起什么重拍重绘

09:26.510 --> 09:27.470
这些事情

09:28.350 --> 09:30.950
于是我们这里时间结束

09:30.950 --> 09:33.070
我们来看一下他们的用时情况

09:34.430 --> 09:35.670
转

09:36.310 --> 09:38.430
其实这里主要等待的时间是哪呢

09:38.430 --> 09:40.390
就是创建ATM元素

09:40.390 --> 09:40.950
真实动物

09:41.350 --> 09:41.950
看下控制台

09:42.630 --> 09:44.670
GES创建的时间

09:44.670 --> 09:46.950
一千万次只用了129毫秒

09:47.950 --> 09:49.830
而真实动物创建了用了4秒多

09:50.550 --> 09:51.670
差距特别大

09:51.950 --> 09:52.470
差了多少倍

09:52.470 --> 09:53.390
差了40多倍

09:54.990 --> 09:56.270
所以说我们

09:58.390 --> 09:59.310
为什么需要虚拟动物

09:59.310 --> 10:01.270
主要是考虑到效率问题

10:01.710 --> 10:02.790
如果说你轮到喊数里边

10:02.790 --> 10:03.790
老去操作真实动物

10:03.790 --> 10:05.470
拿效率的是惨不人度的

10:06.390 --> 10:08.430
因此为了解决效率问题

10:08.430 --> 10:10.670
它会使用虚拟动物来替代真实动物

10:12.030 --> 10:13.150
就是这个问题要回答清楚

10:13.910 --> 10:14.830
接下来下面这个点

10:16.510 --> 10:18.230
我们光有虚拟动物不够

10:18.830 --> 10:19.990
你界面咋显示呢

10:20.670 --> 10:23.030
那里弄得倒是挺嗨的

10:23.030 --> 10:24.670
比方说我们这里有这么一个对象

10:25.270 --> 10:26.030
这个对象里边

10:26.670 --> 10:28.070
是不是就类似于一个虚拟动

10:28.070 --> 10:30.390
还记住了我这个界面上应该有啥

10:30.390 --> 10:31.550
应该有个DIV

10:31.550 --> 10:33.150
它的文本应该是ABC

10:33.150 --> 10:34.950
假设有这么一个虚拟动物

10:34.950 --> 10:36.030
在界面上有反应吗

10:36.590 --> 10:37.470
没有任何反应

10:37.950 --> 10:38.950
它看不见

10:38.950 --> 10:39.630
用户看不见

10:39.630 --> 10:41.710
我最终还是得把它深层到真实动物

10:42.430 --> 10:43.430
那这个时候又怎么办

10:43.430 --> 10:46.590
那就涉及到虚拟动物如何来转换为真实动物

10:47.870 --> 10:49.590
这里要分成两种情况来说

10:50.110 --> 10:50.950
一种是第一种

10:50.950 --> 10:52.830
第一个一开始的时候

10:53.150 --> 10:54.950
就组建最开始创建的时候

10:54.950 --> 10:56.350
我要用到这个组建了

10:56.350 --> 10:57.430
什么创建个组建实力

10:57.870 --> 10:58.990
那我要选择那个组建吧

10:58.990 --> 10:59.990
它要运行Render函数

11:00.270 --> 11:01.470
也有这个组建的Render函数

11:01.470 --> 11:02.830
第一次被运行的时候

11:03.550 --> 11:04.390
界面上没东西

11:04.950 --> 11:05.750
那怎么办呢

11:05.750 --> 11:08.830
它首先创建出虚拟动物数

11:09.670 --> 11:10.990
它又要运行Render

11:11.150 --> 11:12.070
只要运行Render

11:12.070 --> 11:13.430
它一定生成一个虚拟动物数

11:14.350 --> 11:16.830
然后它会根据虚拟动物数

11:17.550 --> 11:18.390
它会根据这个东西

11:18.390 --> 11:19.510
比方说Hello World这个组建

11:19.510 --> 11:20.910
它会根据我们的虚拟动物数

11:21.270 --> 11:22.950
这里边记录了我界面上应该有啥

11:23.150 --> 11:25.830
然后一个一个来创建真实动物

11:25.830 --> 11:27.790
也就是创建真实动物的操作是少不了的

11:29.030 --> 11:31.270
它只能说尽量的去扫创建

11:32.110 --> 11:33.910
一开始都要创建出来

11:35.630 --> 11:36.630
创建出来过后

11:36.830 --> 11:38.150
它会把这个真实动物

11:38.150 --> 11:39.750
挂载到页面合适的位置

11:39.750 --> 11:40.910
比方说Hello World这个组建

11:41.470 --> 11:45.150
它通过副组建的确定位置应该在哪个地方

11:45.550 --> 11:47.790
比方说它应该在副组建的DIV

11:47.790 --> 11:49.590
在这个1米几下面

11:50.390 --> 11:53.590
于是它就把这个组建挂载到相应的位置

11:53.990 --> 11:56.110
把这个组建生成了真实动物

11:56.110 --> 11:57.070
挂载到那里

11:57.470 --> 11:59.750
而且它生成了真实动物之后

12:00.590 --> 12:04.030
它每一个虚拟动物都会对应一个真实动物

12:04.310 --> 12:05.310
咱一说你看

12:05.590 --> 12:07.870
我们最终的Hello World这个组建

12:08.910 --> 12:10.190
Hello World这个组建你看

12:11.190 --> 12:12.670
第一次轮到的时候

12:12.870 --> 12:13.830
生成了Vload

12:15.270 --> 12:16.470
它是一个DIV

12:16.470 --> 12:18.110
那么DIV是不是对应一个元素

12:18.110 --> 12:18.790
你看这里

12:18.790 --> 12:19.630
对应一个真实动物

12:19.630 --> 12:20.710
这是个真实动物元素

12:20.710 --> 12:21.150
你看

12:21.910 --> 12:23.070
是不是真实动物元素

12:24.310 --> 12:24.990
没问题吧

12:24.990 --> 12:25.990
那么对应哪招

12:25.990 --> 12:27.790
好那么它的指元素有H1

12:27.790 --> 12:28.670
这是个虚拟动物

12:28.670 --> 12:29.750
这个H1元素

12:29.870 --> 12:31.990
H1的虚拟动物它又对应一个真实动物

12:33.190 --> 12:33.990
是不是H1

12:34.990 --> 12:36.150
它创建好真实动物过后

12:36.150 --> 12:37.230
它会跟那个虚拟动物

12:37.230 --> 12:39.870
把它做一个属性挂进去

12:40.030 --> 12:41.750
那么这样子的形成一个对应关系

12:41.750 --> 12:43.550
哪个虚拟动物对应哪个真实动物

12:44.030 --> 12:44.870
所以第一次

12:44.870 --> 12:45.790
其实

12:46.750 --> 12:49.750
就是如果说我们的界面只需要渲染一次

12:49.750 --> 12:51.070
后边不需要重新渲染

12:51.070 --> 12:52.550
数据变化不需要重新渲染

12:52.550 --> 12:54.470
其实5U的效率是更加低的

12:54.470 --> 12:55.150
发现没

12:55.790 --> 12:57.870
因为它比直接操作真实动物

12:57.870 --> 12:59.150
还要多一个步骤

12:59.150 --> 13:00.230
就是生成虚拟动物

13:00.830 --> 13:02.510
因为它最终还是要生成真实动物的

13:02.790 --> 13:04.390
第一次它效率还是不高的

13:04.910 --> 13:07.150
但是后续的就不一样了

13:07.430 --> 13:08.870
因为后续我们界面要变化

13:09.270 --> 13:10.390
那么这个时候就不一样了

13:11.110 --> 13:12.390
后边如果说一个组建

13:12.390 --> 13:14.350
受到响应式数据的变化的影响

13:14.350 --> 13:15.830
不要有某一个一代数据变了

13:15.830 --> 13:17.270
我要重新运行Render

13:17.270 --> 13:18.150
那这个时候就不一样了

13:19.310 --> 13:20.510
重新调到Render函数

13:20.510 --> 13:23.030
那么它这个时候会创建一个新的虚拟动物数

13:23.030 --> 13:24.790
因为它是普通的界式对象

13:25.270 --> 13:26.150
它并不会

13:26.910 --> 13:28.110
效率并不会差很多

13:28.110 --> 13:29.230
而且效率非常快

13:29.230 --> 13:30.630
刚才看到了1000万次

13:30.870 --> 13:32.590
创建一个1000万个界式对象

13:32.590 --> 13:33.750
也就用100多毫秒

13:34.190 --> 13:36.510
其实我们一个组建哪有那么多界式对象

13:36.950 --> 13:37.910
并没有那么多对吧

13:38.270 --> 13:40.070
有个一两百个都不得了了

13:40.630 --> 13:42.070
所以说它这个效率很高的

13:42.430 --> 13:43.630
生成一个新的虚拟动物数

13:44.070 --> 13:45.910
然后这个时候它不会去动真实动物

13:46.310 --> 13:48.950
它会用新的虚拟动物数

13:49.230 --> 13:51.310
和旧的虚拟动物数来进行对比

13:52.310 --> 13:54.550
看一下它对比里边

13:54.550 --> 13:56.350
这个它们的属性有没有什么变化

13:56.350 --> 13:58.190
它们的指节点有没有什么变化

13:59.030 --> 14:00.310
找到了变化点

14:00.310 --> 14:01.750
比方到这个东西发现属性变了

14:02.270 --> 14:03.070
找到变化点

14:04.070 --> 14:08.190
然后只去更新就数的这个变化的东西

14:08.190 --> 14:09.470
它只需更新这个东西

14:09.470 --> 14:11.270
其实这个过程叫做patch

14:12.030 --> 14:13.550
我们后边会讲这个算法

14:15.110 --> 14:15.870
讲一个patch

14:17.150 --> 14:19.190
这个过程就是patch对比更新

14:19.710 --> 14:22.270
那么发现我这个虚拟节点其他都一样

14:22.790 --> 14:24.590
只有这个东西发生变化了

14:24.590 --> 14:25.870
那么只更新这一块

14:26.350 --> 14:29.430
由于我们之前那棵树里边是不是有一个L

14:29.430 --> 14:31.230
是不是有一个对应的真实动物

14:31.710 --> 14:32.190
对不对

14:32.190 --> 14:34.110
那么这个时候它发现这个节点变了

14:34.110 --> 14:35.950
它只会去更新这个节点的真实动

14:35.950 --> 14:36.550
所以说

14:36.550 --> 14:37.790
而且更新的时候

14:37.790 --> 14:39.110
它会按照什么变化

14:39.110 --> 14:40.150
比方属性变化了

14:40.150 --> 14:41.310
那我就更新它的属性

14:42.710 --> 14:45.070
那么它会用一个方式叫做

14:45.070 --> 14:46.390
注意小量更新

14:46.390 --> 14:49.870
就是说我尽量少的去更新

14:49.870 --> 14:51.670
只更新必要的东西

14:51.670 --> 14:55.710
来达到尽量少的真实动物的变化

14:55.710 --> 14:57.030
所以说忽悠的渲染

14:57.030 --> 14:59.150
它第一次效率其实还不如真实动物

14:59.150 --> 14:59.950
直接用真实动物

14:59.990 --> 15:00.990
因为它会多一个补仇

15:00.990 --> 15:01.950
生殖人蓄力动物

15:02.630 --> 15:04.190
但是后续的效率就很高了

15:04.190 --> 15:06.830
后续的效率它尽量少的去更改真实动物

15:07.630 --> 15:08.670
这边还有不少的细节

15:08.670 --> 15:10.870
我们后边还会去详细的说

15:12.070 --> 15:12.830
就这么个意思

15:12.830 --> 15:14.830
蓄力动物是如何来转换成真实动物的

15:15.350 --> 15:17.030
就这么一个做法

15:18.150 --> 15:18.430
好

15:18.430 --> 15:20.790
这是第三个点

15:21.190 --> 15:21.390
好

15:21.390 --> 15:21.950
第四个点

15:22.430 --> 15:23.670
你可以回答一下

15:24.390 --> 15:26.470
无版和蓄力动物的关系

15:26.470 --> 15:28.030
其实这个东西也不一定说

15:28.510 --> 15:30.150
不一定说面试的时候需要回答

15:30.150 --> 15:31.790
这主要是为了我给你讲清楚

15:31.790 --> 15:32.750
也同时分不清楚

15:32.750 --> 15:34.270
就是我们这里写的这个模板

15:34.270 --> 15:36.630
根本的蓄力动物到底是一个什么多关系呢

15:38.430 --> 15:39.550
这里给大家详细说一下

15:40.070 --> 15:42.670
无诱框架里边它有很多的核心模块

15:42.670 --> 15:44.190
比方有响应式数据的模块

15:44.190 --> 15:45.830
又处理运行室的模块

15:46.670 --> 15:49.310
有那个compile模块

15:50.030 --> 15:51.190
叫做编译模块

15:51.190 --> 15:52.350
它的任务是什么呢

15:52.350 --> 15:54.550
它的主要的任务就是把这个模板

15:55.790 --> 15:56.990
注意我们的写的模板

15:57.950 --> 15:58.870
比看这个阳

15:58.870 --> 16:00.590
比看这个界面花里扶烧的

16:01.430 --> 16:03.790
其实这个模板本质上就是一个制服串

16:03.790 --> 16:04.710
还记得吗

16:04.710 --> 16:05.790
我们之前说过

16:05.790 --> 16:07.590
配置的模板就是一个制服串

16:07.590 --> 16:08.950
就这么一个东西

16:08.950 --> 16:11.390
就这个东西就全在这个tempure里面

16:11.390 --> 16:12.110
明白的意思吧

16:12.110 --> 16:13.750
只是我们开发的时候

16:13.750 --> 16:14.990
为了有些工具

16:14.990 --> 16:16.990
为了让我们开发的好看

16:16.990 --> 16:17.870
可以让你提到这

16:17.870 --> 16:19.710
它最终还是会形成一个制服串

16:20.590 --> 16:22.190
它的任务是什么呢

16:22.190 --> 16:24.310
它的任务是把这个模板制服串

16:24.310 --> 16:26.190
转换成一个Render函数

16:27.470 --> 16:28.670
最终我们要选择虚拟动

16:28.670 --> 16:29.750
一定是Render函数

16:29.750 --> 16:30.590
没有别的了

16:31.230 --> 16:32.270
所以说你如果说

16:32.270 --> 16:33.870
但是Render函数自己写的话

16:33.870 --> 16:34.710
很恶心

16:34.710 --> 16:35.510
所以说

16:35.510 --> 16:37.190
为了让你开发方便

16:37.190 --> 16:38.990
给你搞出一个模板的东西

16:38.990 --> 16:40.350
只是为了让你开发方便

16:40.350 --> 16:42.030
最终还是会形成Render函数

16:42.790 --> 16:44.670
因为我们只有通过Render函数

16:44.670 --> 16:47.630
才能得到虚拟动的数

16:48.470 --> 16:49.470
那么编译的模块

16:49.470 --> 16:50.350
它是负责什么了

16:50.350 --> 16:51.790
负责将我们这个制服串

16:51.790 --> 16:53.190
变成Render函数

16:53.750 --> 16:54.510
那么你可以说一下

16:54.510 --> 16:55.510
它是怎么来变的

16:55.630 --> 16:57.470
这个东西就涉及到原码分析了

16:57.470 --> 16:58.590
我们这里简单的说

16:58.590 --> 16:59.630
就提两个点

16:59.630 --> 17:02.310
它的编译过程分为两个步骤

17:02.310 --> 17:03.830
第一个步骤是把模板制服串

17:03.830 --> 17:04.910
转换成ASD

17:04.910 --> 17:05.830
什么叫ASD

17:05.830 --> 17:07.150
叫做抽象语法数

17:08.150 --> 17:09.150
抽象语法数

17:10.270 --> 17:11.310
这个玩意儿是什么呢

17:11.310 --> 17:13.630
它就是用一种介石数型结构

17:13.630 --> 17:15.590
来描述我们原始的代码

17:16.390 --> 17:18.110
它有点像虚拟动的数

17:18.110 --> 17:19.110
但是还不是

17:19.110 --> 17:19.470
还不是

17:19.470 --> 17:20.430
还有很多事情要做

17:20.430 --> 17:20.990
后边

17:20.990 --> 17:23.110
那么它先作为第一个转换

17:23.110 --> 17:24.430
我们可以给它看一下吧

17:24.550 --> 17:25.510
这个东西了解就行了

17:26.990 --> 17:27.790
有一个网站

17:27.790 --> 17:28.910
专门来看一下

17:28.910 --> 17:30.790
来分析ASD的

17:30.790 --> 17:31.750
来看我们这里

17:32.950 --> 17:34.230
左边有一个ATM文档

17:35.390 --> 17:36.990
那么右边它就生成了一个

17:38.150 --> 17:39.310
抽象语法数

17:39.310 --> 17:40.710
就类似于这么一种结构

17:40.710 --> 17:42.230
我们可以用接上来看一下吧

17:42.230 --> 17:46.070
你看我们的这个节点

17:46.070 --> 17:48.030
Nem是什么ATM

17:48.030 --> 17:49.070
看什么这个节点

17:49.070 --> 17:50.350
这个节点有一些指节点

17:50.350 --> 17:51.950
你看指节点里边有Body

17:52.950 --> 17:54.950
BodyI should be able to

17:54.950 --> 17:56.150
因为这东西不可看

17:56.150 --> 17:57.430
然后有个指节点

17:57.430 --> 17:58.230
H1

17:58.230 --> 18:02.310
H的切号准的Value值是My First Heading

18:02.310 --> 18:03.430
看到没

18:03.430 --> 18:04.990
是不是形成这么一种用

18:04.990 --> 18:08.670
用一个对象的结构来描述出来

18:08.670 --> 18:10.110
我们见面上到底写的是啥

18:10.110 --> 18:11.670
这是抽象语法数

18:11.670 --> 18:14.830
非常类似于虚拟动

18:14.830 --> 18:16.030
但是还不一样

18:16.030 --> 18:16.630
还不一样

18:16.630 --> 18:18.030
我们这里有一部设计的

18:18.030 --> 18:19.830
目前还不设计到原码分析

18:19.830 --> 18:21.750
所以说点到机子

18:22.110 --> 18:23.790
首先把它转换成抽象语法数

18:23.790 --> 18:27.230
然后再将抽象语法数转换成RenderHand数

18:27.230 --> 18:28.430
它分为这么两个过程

18:28.430 --> 18:30.750
追踪目标就有一个生成RenderHand数

18:32.550 --> 18:34.870
那么下面我们还可以再详细说一下

18:34.870 --> 18:36.870
如果使用传统的引入方式

18:36.870 --> 18:38.310
什么叫传统的引入方式呢

18:38.310 --> 18:40.350
就是我们用Squibs元素

18:40.350 --> 18:41.310
SRC

18:41.310 --> 18:43.510
然后什么什么VU.js

18:43.510 --> 18:46.750
通过原式的各种方式来引入VU

18:46.750 --> 18:49.470
那么如果说用这种方式来引入VU的话

18:49.470 --> 18:55.310
或者是VU.cli的配置中开启了Runtime Compiler

18:56.950 --> 18:58.070
啥意思

18:58.070 --> 19:01.470
我们VU.cli里边不是有一个配置文件吗

19:01.470 --> 19:04.630
叫做VU.config.js

19:04.630 --> 19:05.470
对吧

19:05.470 --> 19:08.460
是不是有这个

19:08.460 --> 19:09.620
我们在配置文件里面

19:09.620 --> 19:12.780
如果说开启了Runtime Compiler

19:14.500 --> 19:19.140
就这种情况和我们用传统的方式引入的情况下

19:19.140 --> 19:21.060
那么会发生什么事呢

19:22.060 --> 19:26.780
编译的时间发生在组建第一次夹载时

19:26.780 --> 19:30.460
这里这些说法还不是很准确

19:31.820 --> 19:34.630
我们这样说吧

19:36.030 --> 19:38.190
不用这个货了

19:38.190 --> 19:40.590
如果使用传统的引入方式

19:40.590 --> 19:42.910
我们就最早的时候

19:42.910 --> 19:45.550
在入门阶段前几节课的时候那种方式

19:45.550 --> 19:46.590
不用VU.cli

19:46.590 --> 19:47.710
那么这个时候呢

19:47.710 --> 19:50.030
编译的时间发生在组建第一次夹载的时候

19:50.030 --> 19:51.230
就我要选这个组建

19:51.710 --> 19:52.830
选这个组建它就模办

19:52.830 --> 19:53.550
模办是什么呢

19:53.550 --> 19:54.750
模办本质上就是个置物串

19:54.750 --> 19:55.750
它就是个配置

19:57.750 --> 19:59.310
模办本质上不就是这个玩意吗

19:59.310 --> 20:00.630
是不是一个配置一个置物串

20:00.630 --> 20:03.030
它会把这个置服串模办里面的置物串

20:03.030 --> 20:04.670
这里边有什么DEV这些东西

20:04.670 --> 20:08.470
把这个置服串编译成为Render函数

20:09.350 --> 20:10.390
它会发生在这

20:10.390 --> 20:11.390
这个时候

20:11.990 --> 20:13.830
这称之为运行式编译

20:13.830 --> 20:15.230
在运行的时候

20:15.230 --> 20:16.390
选了这个组建也发现

20:16.390 --> 20:17.710
它就只有模办没有Render函数

20:17.710 --> 20:20.390
那进一边

20:21.350 --> 20:23.830
那么如果说你用的是VU.cli

20:23.830 --> 20:24.950
那就不一样了

20:25.950 --> 20:27.630
编译发生在打包的时候

20:27.630 --> 20:29.790
就是用NPMRumble的

20:29.790 --> 20:31.710
打包到生成结果的时候

20:31.710 --> 20:32.710
那你说打包的时候

20:32.710 --> 20:35.390
它自动就把这个模办编成了Render函数

20:35.390 --> 20:36.470
也就是打包结果里面

20:36.470 --> 20:38.110
它并没有模办了

20:38.110 --> 20:39.390
它只有Render函数

20:39.390 --> 20:40.830
没了意思吧

20:40.830 --> 20:42.470
那么这称之为模办预编译

20:42.470 --> 20:43.950
在运行之前

20:43.950 --> 20:45.470
我打包的时候就给你编译好

20:45.470 --> 20:46.910
编译成Render函数

20:46.910 --> 20:48.950
所以为什么建议大家用VU.cli

20:48.990 --> 20:50.990
不要用那种传统的方式引入

20:50.990 --> 20:52.790
传统的方式

20:52.790 --> 20:53.750
就这个原因

20:53.750 --> 20:56.470
你传统的方式运行的时候在编译

20:56.470 --> 20:59.270
那么是不是会降低运行性能

20:59.270 --> 21:02.710
而我们这个用VU.cli是打包的时候编译

21:02.710 --> 21:04.390
那么称之为模办预编译

21:04.390 --> 21:05.350
那么这个时候运行的时候

21:05.350 --> 21:06.630
就不需要编译了

21:06.630 --> 21:07.670
性能就提高了

21:07.670 --> 21:10.830
因为编译它是一个极其耗费性能的操作

21:10.830 --> 21:12.030
非常耗费性能

21:12.030 --> 21:13.390
主要的性能损失在这

21:13.390 --> 21:14.430
转换成抽象与法术

21:14.430 --> 21:17.270
这个非常费性能的

21:17.270 --> 21:19.550
因此我们通过预编译的方式

21:19.550 --> 21:21.550
可以有效的提高运行使得性能

21:21.550 --> 21:22.750
就运行的时候你不需要编译了

21:22.750 --> 21:25.070
本身就是已经是Render函数了

21:25.070 --> 21:25.710
没了意思吧

21:25.710 --> 21:27.910
其实我们可以看一下

21:27.910 --> 21:29.030
像这些东西

21:29.030 --> 21:31.550
它在编译结果里面其实已经不存在了

21:31.550 --> 21:33.350
我们来看一下

21:33.350 --> 21:35.270
现在我们打个包

21:35.270 --> 21:36.910
NPM装Build

21:36.910 --> 21:37.910
打个包

21:37.910 --> 21:39.030
其实打包

21:39.030 --> 21:41.750
我们不仅是在运行Build的时候会打包

21:41.750 --> 21:43.630
运行Render函数的时候也会打包

21:43.630 --> 21:44.990
只是它没有形成文件

21:44.990 --> 21:46.390
文件而已

21:46.430 --> 21:48.110
内存里面打包

21:48.110 --> 21:48.870
好我们来看一下

21:48.870 --> 21:50.630
主要看一下打包结果里面还存不存在

21:50.630 --> 21:52.070
这个H1

21:52.070 --> 21:53.550
复制一下

21:53.550 --> 21:55.550
看一下打包结果里面介绍

21:55.550 --> 21:57.990
里面有没有生成一个H1元素

21:57.990 --> 21:58.630
有吗

21:58.630 --> 21:59.350
没有吧

21:59.350 --> 22:00.350
另外一个介绍文件

22:02.190 --> 22:03.270
你看没有吧

22:03.270 --> 22:04.510
是没有了

22:04.510 --> 22:05.590
变成了什么了

22:05.590 --> 22:07.670
变成了虚拟动物了

22:07.670 --> 22:09.230
变成了Render函数了

22:09.230 --> 22:11.750
它变成了Render函数了

22:11.750 --> 22:13.030
生成一个Render函数

22:13.030 --> 22:14.830
生成Render函数

22:14.830 --> 22:15.870
它变成Render函数了

22:15.910 --> 22:16.950
是这么个意思

22:16.950 --> 22:18.750
所以说它叫做预变异

22:18.750 --> 22:20.790
预变异它运行的时候还需要变异吗

22:20.790 --> 22:21.270
不需要

22:21.270 --> 22:22.670
它本身就是Render函数了

22:22.670 --> 22:24.470
变异的目标不就生成Render函数了

22:25.990 --> 22:28.910
而且Viuclean还会做一件事

22:28.910 --> 22:31.430
由于运行的时候已经不需要变异了

22:31.430 --> 22:33.310
所以Viuclean在打包的时候

22:33.310 --> 22:36.230
会排除掉Viu中的compile模块

22:36.230 --> 22:37.430
变异模块已经不需要了

22:37.430 --> 22:38.710
后面不需要变异了

22:38.710 --> 22:40.990
以减少打包体积

22:40.990 --> 22:43.190
那么这个行为是通通什么控制的呢

22:43.190 --> 22:44.990
才是通过这个东西控制的

22:45.030 --> 22:47.270
这个玩意就是控制打包结构里面

22:47.270 --> 22:48.990
要不要包含运行时变异

22:49.550 --> 22:50.430
要不要包含

22:50.430 --> 22:51.670
默认是不包含的

22:51.670 --> 22:52.670
你不需要变异模块了

22:53.510 --> 22:54.790
那么如果说你不包含的话

22:54.790 --> 22:57.190
有的时候就会遇到像这么一个问题

22:57.190 --> 22:58.510
也不算是问题吧

22:58.510 --> 22:59.750
就是如果说你要这么写的话

22:59.750 --> 23:00.750
就是不行的

23:00.750 --> 23:02.150
你不要这个template

23:02.150 --> 23:04.070
我在这里写个template

23:04.070 --> 23:05.430
那就不行

23:05.430 --> 23:07.470
比方说我们这里能写上个template

23:07.470 --> 23:08.790
用个字幕刷的形式

23:08.790 --> 23:10.030
因为如果说你写到这的话

23:10.030 --> 23:11.230
它就没法进行预变异了

23:11.230 --> 23:12.990
预变异只是单文件总监

23:12.990 --> 23:13.870
你必须要把它写到这

23:13.910 --> 23:15.110
它才会进行预变异

23:15.110 --> 23:16.950
一般写到这它就没法进行预变异了

23:16.950 --> 23:18.430
它就是运行式变异了

23:18.430 --> 23:19.790
比方说我们这里写个吧

23:19.790 --> 23:20.590
随便写一个

23:21.350 --> 23:22.070
我们现在

23:23.270 --> 23:24.270
不要运行式变异

23:24.270 --> 23:26.310
默认情况下它没有运行式变异

23:26.310 --> 23:28.110
我们来看一下现在会不会出问题

23:28.110 --> 23:28.870
N屏幕装

23:28.870 --> 23:29.110
是

23:36.460 --> 23:37.100
好

23:37.100 --> 23:37.940
放心

23:37.940 --> 23:38.660
你看

23:38.660 --> 23:40.060
它告诉你

23:40.060 --> 23:42.820
你现在用的是什么呢

23:42.820 --> 23:43.940
反正说了一大堆

23:43.940 --> 23:46.180
它说就是个变异器不可用

23:46.220 --> 23:48.460
所以说了你现在没有运行式变异

23:49.180 --> 23:52.460
建议你能使用预变异

23:52.460 --> 23:53.380
也就是啥意思呢

23:53.380 --> 23:55.260
你不要用这种方式来写模板

23:55.260 --> 23:57.140
你还是老老实实把模板写到上面

23:57.140 --> 23:58.100
就这么个意思

23:58.100 --> 23:59.420
写到上面它就会进行预变异

23:59.420 --> 24:01.580
运行式变异目前是没有的

24:01.580 --> 24:02.580
那如果说你一定要

24:02.580 --> 24:04.660
有的时候你一定要一个运行式变异

24:04.660 --> 24:05.260
那怎么办呢

24:05.260 --> 24:06.420
你就把这个夹上

24:06.420 --> 24:07.740
但是我不太建议大家

24:07.740 --> 24:08.860
除非破不得意

24:08.860 --> 24:10.380
某些特殊情况破不得意

24:10.380 --> 24:10.780
否则的话

24:10.780 --> 24:12.420
不要去动这个东西

24:12.420 --> 24:13.740
那么这样子的打包结果里面

24:13.740 --> 24:14.500
会不会多一个

24:14.500 --> 24:15.620
它就会把变异

24:15.620 --> 24:18.100
变异器也会打包到打包结果里面

24:18.100 --> 24:19.940
那么这个样子就区别的运行式变异了

24:19.940 --> 24:21.180
那现在目前就可以了

24:22.020 --> 24:22.940
我要重新运行

24:26.020 --> 24:27.300
现在我们加上运行式变异

24:28.300 --> 24:30.020
改动配置完之后要重新运行

24:30.020 --> 24:31.460
你看现在是不是可以了

24:31.460 --> 24:33.060
但是不建议大家这样去做

24:34.260 --> 24:35.420
这个地方我给大家说一下

24:39.980 --> 24:40.740
接着继续看

24:41.940 --> 24:43.060
无办的存在

24:43.060 --> 24:44.060
它的目的是什么呢

24:44.060 --> 24:45.460
我们刚才说了

24:45.460 --> 24:47.220
它只是为了让开发人员

24:47.700 --> 24:49.220
方便的书写界面带

24:49.220 --> 24:50.940
让你写得舒服一点

24:50.940 --> 24:52.780
因为你写这个Render函数写得恶心

24:54.580 --> 24:55.060
但是呢

24:55.060 --> 24:56.340
五佑在运行的时候

24:56.340 --> 24:58.100
最终是需要的是Render函数

24:58.100 --> 24:58.860
而不是模办

24:58.860 --> 25:00.300
它要不要模办无所谓

25:00.300 --> 25:01.740
我要的就是这个Render函数

25:01.740 --> 25:03.420
模办的存在只是为了方便我们

25:04.420 --> 25:04.860
因此呢

25:04.860 --> 25:06.140
模办中的各种语法

25:06.140 --> 25:08.340
什么大鬍子语法呢

25:08.340 --> 25:10.780
才有什么那些指令的特殊语法

25:10.780 --> 25:12.620
在蓄力动物里面根本就不存在

25:12.620 --> 25:14.180
它都会变成蓄力动物的配置

25:14.180 --> 25:15.780
那么这一点怎么去理解呢

25:15.780 --> 25:18.530
我给大家看一下吧

25:18.610 --> 25:20.850
我们随便写一点给大家看一下

25:20.850 --> 25:21.850
这个Hello World

25:21.850 --> 25:23.170
我稍微去做一些改动

25:25.090 --> 25:26.010
这些东西都不要了

25:26.010 --> 25:27.290
你乱七八糟的玩意都不要了

25:28.410 --> 25:29.490
写一个

25:29.490 --> 25:31.210
这就写一个Message吧

25:32.330 --> 25:34.050
你看这是什么模办语法

25:34.050 --> 25:34.410
然后呢

25:34.410 --> 25:35.650
我再利用个属性绑定

25:35.650 --> 25:36.570
你看啊

25:36.570 --> 25:37.530
属性绑定

25:38.610 --> 25:39.930
就绑定个啥呀

25:39.930 --> 25:40.850
绑定个M

25:40.850 --> 25:42.730
我就随便绑定一个Message

25:42.730 --> 25:43.650
也绑定一个Message

25:44.930 --> 25:46.490
然后就这样子写了

25:46.490 --> 25:47.650
然后我给大家注写一个实现

25:49.010 --> 25:49.730
Click

25:50.730 --> 25:51.330
实现

25:53.370 --> 25:54.170
写个啥呀

25:54.170 --> 25:55.570
写个Handle吧

25:57.370 --> 25:57.970
写个啥呀

25:58.770 --> 26:00.330
点击过和Message变成

26:01.370 --> 26:01.930
ABC

26:03.130 --> 26:04.410
就这么一个点的东西啊

26:04.410 --> 26:05.770
然后我们输出一个蓄力动

26:05.770 --> 26:06.570
你看一下

26:07.250 --> 26:08.610
这些模办语法

26:08.610 --> 26:10.170
它在蓄力动物里面到底是个啥

26:11.130 --> 26:11.810
还有没有这些

26:11.810 --> 26:12.970
还有没有这些冒号啊

26:12.970 --> 26:13.970
这些东西还有没有

26:14.530 --> 26:15.330
根本就不存在了

26:23.320 --> 26:23.880
这里

26:29.460 --> 26:30.900
来看Hello World

26:30.900 --> 26:31.820
这蓄力节点

26:32.460 --> 26:32.980
你看啊

26:32.980 --> 26:34.940
在DIV里边

26:34.940 --> 26:36.980
我们看一下我们在DIV里边

26:37.740 --> 26:40.260
所以一个class是静态的

26:40.260 --> 26:41.780
我们的class会变成啥呀

26:41.780 --> 26:42.820
会变成这个

26:45.480 --> 26:46.680
class跑哪去了

26:46.680 --> 26:48.560
这里变成一个Static class

26:48.560 --> 26:49.080
Hello

26:50.440 --> 26:52.320
然后我们这个A会变成啥呀

26:52.320 --> 26:53.680
会变成A-D-T-R-S

26:53.680 --> 26:55.200
A是不是直接算出来了

26:55.200 --> 26:55.880
结果是什么

26:55.880 --> 26:57.120
就是个Message的值

26:57.520 --> 26:58.480
Message的值是什么

26:58.560 --> 26:59.480
传过来就是这个

26:59.480 --> 27:01.360
Welcome to your Viewer App

27:01.960 --> 27:02.440
看没

27:02.960 --> 27:04.760
然后我们的Click会变成啥呀

27:04.760 --> 27:06.000
Click会变成这个On

27:06.560 --> 27:07.840
Click变成一个函数

27:07.840 --> 27:08.360
对吧

27:09.760 --> 27:10.680
你来这个意思吧

27:11.400 --> 27:12.560
然后我们的内容了

27:12.560 --> 27:14.120
这个组件内容呢

27:14.120 --> 27:15.360
712G Veload的

27:15.360 --> 27:16.680
就是个文本节点

27:16.680 --> 27:17.720
内容是什么呢

27:17.720 --> 27:18.880
内容就直接算出来了

27:18.880 --> 27:20.280
Welcome to your Viewer

27:20.280 --> 27:20.920
解释

27:22.040 --> 27:22.920
所以这个玩意就是

27:22.920 --> 27:25.120
这就是它生存的最终结果

27:25.120 --> 27:26.280
根本就没有这些东西了

27:26.280 --> 27:27.600
运行的是根本就不存在的

27:27.640 --> 27:29.320
这些包含这些乱七八糟的东西

27:29.320 --> 27:30.720
所以要这样子写呢

27:30.720 --> 27:32.320
跟我们自己手动写

27:32.960 --> 27:34.040
Render是一样的

27:34.040 --> 27:36.000
那么现在自己手动写一个呗

27:36.520 --> 27:37.480
我们不要这个

27:38.080 --> 27:39.280
我怎么去注释呢

27:39.280 --> 27:40.240
好像不好的注释

27:40.240 --> 27:41.080
我们直接写一个吧

27:41.080 --> 27:41.600
Render

27:42.200 --> 27:43.160
在ViuClick里边

27:43.160 --> 27:44.480
我再说一下

27:44.480 --> 27:45.840
如果说你这个Templates

27:45.840 --> 27:47.200
和Render同时存在的话

27:47.200 --> 27:48.160
它是这样操作的

27:48.160 --> 27:49.040
这不是Viu的功能

27:49.040 --> 27:50.200
是ViuClick的功能

27:50.680 --> 27:51.760
ViuClick它打包的时候

27:51.760 --> 27:53.040
会进行一个预编译

27:53.040 --> 27:54.040
它发现你有模办

27:54.040 --> 27:54.760
它就会把模办

27:54.760 --> 27:56.040
生成一个Render函数

27:56.240 --> 27:56.760
给你

27:57.160 --> 27:58.160
配置到组件里边

27:58.160 --> 27:59.600
哪怕你自己写着Render

27:59.600 --> 28:00.720
它也会给你覆盖

28:00.720 --> 28:02.120
这是ViuClick的功能

28:02.120 --> 28:03.280
我要给你说清楚

28:03.280 --> 28:04.480
在Viu里边不是这样子

28:04.480 --> 28:06.080
Viu里边如果说你有模办

28:06.840 --> 28:07.600
同时又有Render

28:07.600 --> 28:08.800
它一定是先任Render

28:08.800 --> 28:09.560
不认模办的

28:09.560 --> 28:11.920
但是ViuClick它有一个打包过程

28:11.920 --> 28:12.520
它打包的时候

28:12.520 --> 28:14.480
会把这个东西生成Render给你覆盖过来

28:14.480 --> 28:15.920
也就是打包结果里边

28:15.920 --> 28:16.800
它只有Render了

28:16.800 --> 28:18.720
所以打包结果给Viu在运行的话

28:18.720 --> 28:19.520
它发现只有Render

28:19.520 --> 28:21.240
那就给它直接运行Render

28:21.240 --> 28:22.280
是这么一个逻辑

28:22.280 --> 28:23.080
搞清楚

28:24.080 --> 28:24.960
那么现在有模办

28:25.000 --> 28:25.920
我们先把这个写出来

28:26.920 --> 28:27.640
我的模办里边

28:27.640 --> 28:28.880
它不是有一个A型函数吗

28:28.880 --> 28:30.400
刚才函数名字也可以随便秘密

28:30.400 --> 28:32.080
你不要说CreateElement也可以

28:33.480 --> 28:35.080
这只是一个形状而已

28:35.080 --> 28:35.640
随便秘密

28:35.640 --> 28:37.280
我们还是惯定用A型

28:38.200 --> 28:38.880
A型函数

28:39.880 --> 28:41.080
标签名DIV

28:42.680 --> 28:45.600
然后它的属性

28:46.160 --> 28:47.080
第二个产出可以配置

28:47.760 --> 28:48.640
属性有什么

28:49.360 --> 28:50.360
有Class

28:52.040 --> 28:52.480
为什么

28:52.480 --> 28:52.880
Hello

28:53.600 --> 28:55.400
还有什么属性

28:56.000 --> 28:57.760
还有A这个属性

28:57.760 --> 28:59.760
那么这里我们是不是要配置到

28:59.760 --> 29:00.840
ATTRS里面

29:02.040 --> 29:04.440
可以是一个又是很自定义的属性

29:05.040 --> 29:05.960
A为什么呢

29:05.960 --> 29:06.480
Message

29:06.480 --> 29:07.160
Message是什么

29:07.160 --> 29:09.040
Message就是是不是Z叫Message

29:10.320 --> 29:11.760
然后还有什么Click

29:11.760 --> 29:13.040
那么我们就用On来配置

29:13.040 --> 29:13.680
事件

29:13.680 --> 29:14.880
事件就是Click

29:14.880 --> 29:15.600
点击的时候

29:15.600 --> 29:17.320
这些东西我们不用去记忆

29:17.320 --> 29:19.120
也不用去学

29:19.120 --> 29:21.120
怎么去用这个A型函数

29:21.120 --> 29:22.120
那个不重要

29:22.320 --> 29:23.440
给它看一下

29:23.440 --> 29:25.040
区议动物到底是长什么样子的

29:25.040 --> 29:26.080
点击的时候

29:26.080 --> 29:26.600
变成什么

29:26.600 --> 29:28.440
变成一个函数

29:28.440 --> 29:29.440
这个函数要做的事情

29:29.440 --> 29:33.040
就是ZS.Message升为ABC

29:33.040 --> 29:34.120
变成这个样子

29:34.120 --> 29:35.640
然后它里边的类值

29:35.640 --> 29:36.280
只是什么

29:36.280 --> 29:37.520
它的指援数

29:37.520 --> 29:39.480
指援数就是ZS.Message

29:43.370 --> 29:44.210
不办不要了

29:44.210 --> 29:45.210
你看我们使用Render函数

29:45.210 --> 29:47.050
自己来形成一个Render

29:49.490 --> 29:49.850
小心

29:52.950 --> 29:53.350
点击

29:54.430 --> 29:54.710
这是什么

29:55.710 --> 29:57.230
哦

29:57.230 --> 29:58.510
不能直接改属性

29:58.510 --> 29:59.230
无所谓

29:59.230 --> 30:01.030
反正我们懂这个意思就行了

30:01.030 --> 30:02.070
我怎么去直接改属性

30:02.790 --> 30:03.590
你看

30:03.590 --> 30:04.470
真正的Class

30:04.470 --> 30:05.310
看没有

30:05.310 --> 30:06.310
ATRS

30:06.310 --> 30:07.830
为什么刚才是State Class

30:07.830 --> 30:08.670
现在是个Class

30:08.670 --> 30:09.670
这个东西不用去管

30:11.430 --> 30:12.510
那么我们看一下元素

30:15.630 --> 30:18.310
我看一下这个DV

30:18.310 --> 30:18.910
Class

30:18.910 --> 30:20.190
你看是不是加进去了

30:20.190 --> 30:21.630
对不对

30:21.630 --> 30:21.830
好

30:21.830 --> 30:23.150
那么这就是

30:23.190 --> 30:25.630
它本质上应该是一个Render函数

30:25.630 --> 30:26.750
反回的东西

30:26.750 --> 30:28.590
模办只是方便我们写代码

30:28.590 --> 30:29.350
这样的代码

30:29.350 --> 30:29.950
太恶心了

30:29.950 --> 30:30.870
你自己写的

30:30.870 --> 30:31.550
没了意思吧

30:31.550 --> 30:32.270
是这么个意思

30:35.270 --> 30:36.950
这是关于这个

30:36.950 --> 30:38.870
虚拟动物和模办的关系

30:38.870 --> 30:40.670
那么这一刻我就讲到这了

30:40.670 --> 30:42.230
把虚拟动物的

30:42.230 --> 30:43.990
跟它紧密相关的东西的

30:43.990 --> 30:45.270
给大家说清楚

30:45.270 --> 30:47.070
这个虚拟动物后面还会反复的

30:47.070 --> 30:49.070
去用到为了讲解其他概念的时候

30:49.070 --> 30:50.470
还会反复的看

30:50.470 --> 30:52.390
先把这个概念给大家讲解了

30:52.390 --> 30:52.670
好了

30:52.670 --> 30:53.830
这一刻我们就到这了

