WEBVTT

00:00.000 --> 00:03.000
OK 咱们进入到伍佑的就业阶段

00:03.000 --> 00:06.000
这个就业阶段讲啥呢 主要就是

00:06.000 --> 00:09.000
因为我们入门阶段是讲了一个贯穿案例 对吧

00:09.000 --> 00:12.000
那么这个项目中呢 其实80%的

00:12.000 --> 00:15.000
我们平时开发里边的功能都用上了

00:15.000 --> 00:18.000
但是有一些东西呢 我们没有遇到

00:18.000 --> 00:20.000
那么在就业阶段里边给它补充一下

00:20.000 --> 00:23.000
我个人觉得呢 有可能大家需要知道的东西

00:23.000 --> 00:26.000
但是我们有没有用到的东西呢 给它补充

00:26.000 --> 00:29.000
另外呢 就是主要讲一些面试题

00:29.000 --> 00:31.000
包括一些深层次的原理啊

00:31.000 --> 00:33.000
包括一些常见的一些面试问题啊

00:33.000 --> 00:35.000
把它拿出来 给大家讲一讲

00:35.000 --> 00:38.000
好 这些课呢 我们就围绕一个面试题啊 叫做

00:38.000 --> 00:42.000
伍佑组建 他们有哪些通信方式

00:42.000 --> 00:45.000
其实在入门阶段的时候呢 我给大家做了一个

00:45.000 --> 00:47.000
思维岛图

00:47.000 --> 00:49.000
这个思维岛图里边呢 就给大家总结了一下

00:49.000 --> 00:52.000
伍佑有哪些组建的通信方式对吧

00:52.000 --> 00:54.000
那么这些课呢 我再给大家总结一下

00:54.000 --> 00:57.000
很多东西呢 我们已经学过了

00:57.000 --> 00:59.000
有些呢 我们还没有学过 没有学过呢

00:59.000 --> 01:01.000
我给大家讲一讲

01:01.000 --> 01:03.000
这里边呢 其实在就业阶段里边呢

01:03.000 --> 01:05.000
有很多的知识啊

01:05.000 --> 01:07.000
平时开发呢 不怎么会用得到

01:07.000 --> 01:09.000
但是那面试的时候又要问

01:09.000 --> 01:11.000
所以说也是一个无奈之举

01:11.000 --> 01:13.000
本来如果说面试的不问的话

01:13.000 --> 01:15.000
我都懒得给你讲了 遇到了的话

01:15.000 --> 01:17.000
问问老师 或者是看一下官方稳当

01:17.000 --> 01:19.000
都能够解决 但是那面试要问

01:19.000 --> 01:21.000
要问的话 你给大家总结一下

01:21.000 --> 01:23.000
我们组建之间通信呢

01:23.000 --> 01:25.000
主要分为两个层面

01:25.000 --> 01:27.000
这是复制组建通信

01:27.000 --> 01:29.000
这个很好理解吧

01:29.000 --> 01:31.000
我们有个组建书 对不对

01:31.000 --> 01:33.000
这个组建书里边有复制组建

01:33.000 --> 01:35.000
直接关系就是复制组建

01:35.000 --> 01:37.000
那么复制组建之间怎么去通信

01:37.000 --> 01:39.000
另外一个层面呢 就是跨越

01:39.000 --> 01:41.000
组建怎么去通信

01:41.000 --> 01:43.000
怎么要跨组建呢

01:43.000 --> 01:45.000
就它不是复制组建 它有可能是

01:45.000 --> 01:47.000
有可能不是 它有可能是

01:47.000 --> 01:49.000
组先元素和后代元素

01:49.000 --> 01:51.000
也有可能是兄弟元素

01:51.000 --> 01:53.000
所以说呢 这种情况下呢

01:53.000 --> 01:55.000
我给大家总结了一下

01:55.000 --> 01:57.000
首先我们来看复制组建

01:57.000 --> 01:59.000
首先大家要知道的是

01:59.000 --> 02:01.000
在5u本身里边啊 就是你不安装

02:01.000 --> 02:03.000
其他任何插件 也不用去

02:03.000 --> 02:05.000
搞些什么妖儿子

02:05.000 --> 02:07.000
那么5u本身 它这个功能里边呢

02:07.000 --> 02:09.000
给你提供的通信方式

02:09.000 --> 02:11.000
绝大部分都是复制组建通信

02:11.000 --> 02:13.000
你想跨越复制组建

02:13.000 --> 02:15.000
你还挺难办的

02:15.000 --> 02:17.000
所以说我们首先看这里啊

02:17.000 --> 02:19.000
你可以看到这个复制组建通信里边

02:19.000 --> 02:21.000
绝大部分都是使用的是

02:21.000 --> 02:23.000
通信功能 第一个是Prop

02:23.000 --> 02:25.000
没什么好说的啊 就是属性

02:25.000 --> 02:27.000
复制组建 传到制组建

02:27.000 --> 02:29.000
学过的Event 这是什么

02:29.000 --> 02:31.000
制组建发送一个通知

02:31.000 --> 02:33.000
到复制组建 告诉我

02:33.000 --> 02:35.000
我发生了一件事了啊

02:35.000 --> 02:37.000
我处理不了 你去处理

02:37.000 --> 02:39.000
这是这两个啊 然后呢

02:39.000 --> 02:41.000
下面这个是style和class

02:41.000 --> 02:43.000
这个玩意呢

02:43.000 --> 02:45.000
它的通信呢 范围比较窄

02:45.000 --> 02:47.000
就是传递样式的

02:47.000 --> 02:49.000
也就是什么意思呢 就是复制组建

02:49.000 --> 02:51.000
跟那个制组建传递样式

02:51.000 --> 02:53.000
啥意思呢 下面有个例子啊 非常简单

02:53.000 --> 02:55.000
我都不用去给大家写代码了

02:55.000 --> 02:57.000
这里边有个复制组建

02:57.000 --> 02:59.000
它用到了一个制组建

02:59.000 --> 03:01.000
给它传进了一个什么呢 style和class

03:01.000 --> 03:03.000
注意哦 这里不是一个元素

03:03.000 --> 03:05.000
你想啊 你把style和class

03:05.000 --> 03:07.000
写到这个DIV里边 很好理解

03:07.000 --> 03:09.000
那你写到这个制定义组建里边啥意思啊

03:09.000 --> 03:11.000
什么意思呢 非常简单

03:11.000 --> 03:13.000
它的意思就是说

03:13.000 --> 03:15.000
把这个style和class

03:15.000 --> 03:17.000
直接传递到这个制组建的根源书

03:17.000 --> 03:19.000
我们来看一下这个制组建啊

03:19.000 --> 03:21.000
这个制组建里边其实只生明了

03:21.000 --> 03:23.000
一个属性 就是message

03:23.000 --> 03:25.000
那么并没有生明这两个属性

03:25.000 --> 03:27.000
对吧 那么按你说这两个属性是无效的

03:27.000 --> 03:29.000
但是呢 我又考虑到

03:29.000 --> 03:31.000
有可能呢 你要修改一些

03:31.000 --> 03:33.000
制组建的样式 你可能会需要

03:33.000 --> 03:35.000
这个东西 所以说它可以做了这么一个规则

03:35.000 --> 03:37.000
就是说

03:37.000 --> 03:39.000
你可以在副组建里边 虽然没有这两个属性

03:39.000 --> 03:41.000
但是呢 你可以传递过去

03:41.000 --> 03:43.000
于是呢 它在制组建里边

03:43.000 --> 03:45.000
它就会把这个属性的

03:45.000 --> 03:47.000
划到根源书

03:47.000 --> 03:49.000
如果说它根源书已经有这两个属性了

03:49.000 --> 03:51.000
那么它就进行合并

03:51.000 --> 03:53.000
比方说这里非常简单 给它一个图

03:53.000 --> 03:55.000
一看就明白了

03:55.000 --> 03:57.000
这里给它一个图

03:57.000 --> 03:59.000
这里呢 这副组建使用了这个东西

03:59.000 --> 04:01.000
我把它放这

04:01.000 --> 04:03.000
然后制组建呢

04:03.000 --> 04:05.000
它的元素是这个

04:05.000 --> 04:07.000
它并没有生明这两个属性

04:07.000 --> 04:13.770
然后最终生成的atm代码里边

04:13.770 --> 04:15.770
atm代码是什么呢 就这个

04:15.770 --> 04:17.770
好 你看一下

04:17.770 --> 04:19.770
你变成这个样子的

04:19.770 --> 04:21.770
好 这边的class呢 跟这个class合并变成这个样子的

04:21.770 --> 04:23.770
没问题吧

04:23.770 --> 04:25.770
这是关于style和class

04:25.770 --> 04:27.770
它做了一个特殊的处理

04:27.770 --> 04:29.770
好 下面这个

04:29.770 --> 04:31.770
这句话多余的

04:31.770 --> 04:33.770
好 接下来还有一个 attribute

04:33.770 --> 04:35.770
那么这个玩意呢 也没有讲过

04:35.770 --> 04:37.770
平时开发很少很少会用到

04:37.770 --> 04:39.770
给大家说一说吧

04:39.770 --> 04:41.770
啥意思呢 就是刚才我们看到

04:41.770 --> 04:43.770
style和class呢 它有个特点

04:43.770 --> 04:45.770
就是 制组建它没有生明这两个属性

04:45.770 --> 04:47.770
它仍然可以传递过去

04:47.770 --> 04:49.770
那么除了这两个特殊的属性之外呢

04:49.770 --> 04:51.770
其实其它的

04:51.770 --> 04:53.770
任何没有生明的属性

04:53.770 --> 04:55.770
都可以传过去

04:55.770 --> 04:57.770
传过去了 我们把它叫做 attribute

04:57.770 --> 04:59.770
啥意思呢

04:59.770 --> 05:01.770
这个 attribute的规则啊 它不包括style和class

05:01.770 --> 05:03.770
我们来看一下吧

05:03.770 --> 05:05.770
我们这个的副主建里边呢

05:05.770 --> 05:07.770
有一个用到了植主建

05:07.770 --> 05:09.770
给它传递了两个并不存在的属性

05:09.770 --> 05:11.770
一个是data A 一个是data B

05:11.770 --> 05:13.770
对吧 这属于植主建里面并不存在的两个属性

05:13.770 --> 05:15.770
然后植主建是这个样子

05:15.770 --> 05:17.770
看一下吧 这植主建的样子

05:17.770 --> 05:19.770
植主建里面并没有生明

05:19.770 --> 05:21.770
它只生明了一个message

05:21.770 --> 05:23.770
这个属性是ok的 这两个属性并没有生明

05:23.770 --> 05:25.770
那么这两个属性就属于 attribute

05:25.770 --> 05:27.770
它就属于 attribute

05:33.770 --> 05:35.770
好 然后我们接下来继续看

05:35.770 --> 05:37.770
然后植主建

05:37.770 --> 05:39.770
它最终会生成一个什么样的atmail呢

05:39.770 --> 05:43.980
生成渲染的结果就是这个样子

05:43.980 --> 05:45.980
它就变成这个样子了

05:45.980 --> 05:47.980
也就是这两个属性

05:47.980 --> 05:49.980
attribute 它就会附着在

05:49.980 --> 05:51.980
植主建的根源数上面

05:51.980 --> 05:53.980
就这么简单

05:53.980 --> 05:55.980
而且不仅如此

05:55.980 --> 05:57.980
你还可以通过

05:57.980 --> 05:59.980
在植主建里边可以通过

05:59.980 --> 06:01.980
这个属性 一个特殊的属性

06:01.980 --> 06:03.980
叫做 attribute atr

06:03.980 --> 06:05.980
通过这个可以得到一个对象

06:05.980 --> 06:07.980
这个对象里边就是

06:07.980 --> 06:09.980
进入了是副主建传递过来的

06:09.980 --> 06:11.980
所有 attribute 是想搞清楚

06:11.980 --> 06:13.980
attribute 是什么意思

06:13.980 --> 06:15.980
就是它没有生命这个属性

06:15.980 --> 06:17.980
但是你传过来了 那就属于 attribute

06:17.980 --> 06:19.980
但是 style 和 class 除外

06:19.980 --> 06:21.980
style 如果说你这边

06:21.980 --> 06:23.980
传递了一个 style 和 class

06:23.980 --> 06:25.980
虽然说我可以把它

06:25.980 --> 06:27.980
附着在根源数上面

06:27.980 --> 06:29.980
但是这里是得不到的

06:29.980 --> 06:31.980
通过这个属性是得不到的

06:31.980 --> 06:33.980
这个属性只能得到 attribute

06:33.980 --> 06:35.980
就除了 style 和 class 这两个特殊的属性

06:35.980 --> 06:37.980
其他的没有生明的东西

06:37.980 --> 06:39.980
都属于 attribute

06:39.980 --> 06:41.980
像这些啊 细节啊

06:41.980 --> 06:43.980
同样说 我们这一课学了这么多东西

06:43.980 --> 06:45.980
又有一大堆新东西

06:45.980 --> 06:47.980
我哪记得住啊 没有让你去记

06:47.980 --> 06:49.980
我反复给大家强调

06:49.980 --> 06:51.980
不要去背这些东西

06:51.980 --> 06:53.980
他也傻了背东西 我都记不住

06:53.980 --> 06:55.980
我就是上课的时候

06:55.980 --> 06:57.980
临时背一下课 给他写下来

06:57.980 --> 06:59.980
要让我去记住 我都记不住

06:59.980 --> 07:01.980
这些细节 没关系

07:01.980 --> 07:03.980
因为他并不影响你开发

07:03.980 --> 07:05.980
他一会面试的时候 怎么还面试

07:05.980 --> 07:07.980
他不会问这么细的

07:07.980 --> 07:09.980
有哪些同性方式 你把这些

07:09.980 --> 07:11.980
目录给他回答出来就OK了

07:11.980 --> 07:13.980
我这个人带着大家过一下

07:13.980 --> 07:15.980
简单的过一下就OK

07:15.980 --> 07:17.980
这个品质开发也不怎么用得到的

07:17.980 --> 07:19.980
好 就这一块

07:19.980 --> 07:21.980
然后这里有一点要说明

07:21.980 --> 07:23.980
这个行为是可以禁用的

07:23.980 --> 07:25.980
什么行为呢 就是

07:25.980 --> 07:27.980
复主键的 attribute 它会复作在

07:27.980 --> 07:29.980
植入键的根元素上这个行为

07:29.980 --> 07:31.980
它是可以禁用的 怎么禁用呢

07:31.980 --> 07:33.980
非常简单 你只要在植入键里面去配置了一下

07:33.980 --> 07:35.980
比方说这里 你去配置一下

07:35.980 --> 07:37.980
植入键里面配置了 Inherit

07:37.980 --> 07:39.980
继承 对吧

07:39.980 --> 07:41.980
就说了

07:41.980 --> 07:43.980
继承

07:43.980 --> 07:45.980
GTRS 把设为 Force

07:45.980 --> 07:47.980
那么只要一设为 Force

07:47.980 --> 07:49.980
这个东西不影响 这个东西仍然可以获取

07:49.980 --> 07:51.980
但是呢

07:51.980 --> 07:53.980
它就不会复作在根元素上面了

07:53.980 --> 07:55.980
根元素上面就没有这个东西了

07:55.980 --> 07:57.980
你要这意思吧 就这么个意思

07:57.980 --> 07:59.980
好 这是关于这个 attribute

07:59.980 --> 08:01.980
既然那么看下一个

08:01.980 --> 08:03.980
LATV修饰服 这东西呢

08:03.980 --> 08:05.980
就简单了解一下就行了

08:05.980 --> 08:07.980
它什么意思呢 就是说

08:07.980 --> 08:09.980
副主键可以使用LATV修饰服

08:09.980 --> 08:13.980
把试键注册到植入键的根元素上面

08:13.980 --> 08:15.980
你看前面几个都好像

08:15.980 --> 08:17.980
这个东西 这个东西 这个东西

08:17.980 --> 08:19.980
都是影响植入键根元素的

08:19.980 --> 08:21.980
你看啊 这里有个例子

08:21.980 --> 08:23.980
我在副主键里面注册了一个

08:23.980 --> 08:25.980
使用了一个 Hello World 的主键

08:25.980 --> 08:27.980
给它注册了一个试键

08:27.980 --> 08:29.980
但是不好意思 植入键里面

08:29.980 --> 08:31.980
根本就没有这个试键

08:31.980 --> 08:33.980
我们来看植元素吧

08:33.980 --> 08:35.980
植元素就这个样子

08:35.980 --> 08:37.980
连接代码都没有

08:37.980 --> 08:39.980
也就是这个网上要植元素

08:39.980 --> 08:41.980
它能够出发这个click 试键吧

08:41.980 --> 08:43.980
它不是一个元素 它不是个DNA

08:43.980 --> 08:45.980
不是一个 HE 标签 它只是一个主键

08:45.980 --> 08:47.980
那么注册的试键

08:47.980 --> 08:49.980
是不是要植元素用AMAT

08:49.980 --> 08:51.980
去出发这个试键啊

08:51.980 --> 08:53.980
不然的话 这个试键永远不会出发

08:53.980 --> 08:55.980
但是这里的试键注册的时候

08:55.980 --> 08:57.980
我用了一个特别的修饰服

08:57.980 --> 08:59.980
叫做LATV

09:00.980 --> 09:02.980
于是这个试键

09:02.980 --> 09:04.980
它就不是我们之前学过的那个

09:04.980 --> 09:06.980
主键制定试键了

09:06.980 --> 09:07.980
它是会把这个click 试键

09:07.980 --> 09:09.980
直接放到这个根元素上面

09:09.980 --> 09:11.980
植入键的根元素DNA上面

09:11.980 --> 09:12.980
就这么简单

09:12.980 --> 09:13.980
于是通过这种方式

09:13.980 --> 09:15.980
副主键又多了一种

09:15.980 --> 09:17.980
可以影响到植入键根元素的行为了

09:17.980 --> 09:19.980
对吧 它们之间又产生了一个通信

09:19.980 --> 09:21.980
于是你看 现在的结果里边

09:21.980 --> 09:23.980
点击这个DNA

09:23.980 --> 09:25.980
点击这个植入键的DNA

09:25.980 --> 09:27.980
它就会弹出 会出出一个E

09:27.980 --> 09:29.980
为什么 之前那个主键

09:29.980 --> 09:30.980
这个世界函数就是输出E

09:30.980 --> 09:31.980
明儿的意思吧

09:31.980 --> 09:33.980
就是LATV

09:33.980 --> 09:34.980
了解一下就行了

09:34.980 --> 09:35.980
不用特别去在意这个东西

09:35.980 --> 09:38.980
这个LATV是讲过了对吧

09:38.980 --> 09:39.980
就是副主键里边

09:39.980 --> 09:41.980
给它传了一些函数进来

09:41.980 --> 09:43.980
传了一些处理函数进来

09:43.980 --> 09:44.980
那么植入键里边

09:44.980 --> 09:45.980
可以通过LATV

09:45.980 --> 09:48.980
或者所有的传递外的处理函数

09:48.980 --> 09:49.980
VMODE

09:49.980 --> 09:52.980
我们讲过的是做双向绑定的

09:52.980 --> 09:54.980
那么这里我这里不展开讲了

09:54.980 --> 09:56.980
因为这里边还有一些东西

09:56.980 --> 09:58.980
它也是容易出现面试推特的地方

09:58.980 --> 10:01.980
所以我打算了单独拿一些课来讲

10:01.980 --> 10:03.980
好 接下来是这个SYNC修饰服

10:03.980 --> 10:04.980
没学过啊

10:04.980 --> 10:05.980
这个SYNC修饰服

10:05.980 --> 10:09.980
它能作用类似于VMODE

10:09.980 --> 10:11.980
它也是做双向绑定

10:11.980 --> 10:12.980
这个玩意呢

10:12.980 --> 10:14.980
实际上是一个设计的缺陷

10:14.980 --> 10:15.980
给大家说一下

10:15.980 --> 10:16.980
在五右三里边

10:16.980 --> 10:18.980
其实这两个东西就合并了

10:18.980 --> 10:19.980
合并成一个了

10:19.980 --> 10:21.980
这个SYNC修饰服就没了

10:21.980 --> 10:23.980
过去的设计的时候

10:23.980 --> 10:25.980
当时设计出来一个VMODE

10:25.980 --> 10:26.980
来做一个双向绑定

10:26.980 --> 10:27.980
对吧

10:27.980 --> 10:28.980
VMODE其实是一个语法堂

10:28.980 --> 10:30.980
其实SYNC它也是一个语法堂

10:30.980 --> 10:31.980
都是来做双向绑定的

10:31.980 --> 10:33.980
比如说我们写的代码是怎么写的

10:33.980 --> 10:34.980
还记得吗

10:34.980 --> 10:37.980
代码是这样子写的对吧

10:37.980 --> 10:38.980
一个INPUT元素

10:38.980 --> 10:41.980
我们是用VMODE对不对

10:41.980 --> 10:44.980
我们绑定一个数据

10:44.980 --> 10:45.980
比方说LOCKING ID

10:45.980 --> 10:47.980
我们当时是这样写的对吧

10:47.980 --> 10:49.980
那么INPUT元素变化的时候

10:49.980 --> 10:52.980
它会重新给它复制

10:52.980 --> 10:55.980
然后我们LOCKING ID变化的

10:55.980 --> 10:56.980
值变化的时候

10:56.980 --> 10:58.980
也会重新给INPUT的复制

10:58.980 --> 11:00.980
也就是我这个数据传递给INPUT

11:00.980 --> 11:01.980
INPUT改变的时候

11:01.980 --> 11:03.980
就重新影响我这个数据

11:03.980 --> 11:04.980
双向绑定

11:04.980 --> 11:05.980
其实我刚刚刚给它说了

11:05.980 --> 11:06.980
它的本质是什么呢

11:06.980 --> 11:08.980
本质就是一个属性

11:08.980 --> 11:11.980
一个属性的名字叫VALUE

11:11.980 --> 11:13.980
属性的名字叫做INPUT

11:13.980 --> 11:14.980
对不对

11:14.980 --> 11:15.980
它本质就是这样子写的

11:15.980 --> 11:17.980
它是一个语法堂而已

11:17.980 --> 11:18.980
LOCKING ID

11:18.980 --> 11:19.980
复制为什么

11:20.980 --> 11:22.980
TALKING ID

11:22.980 --> 11:24.980
VALUE

11:30.990 --> 11:31.990
所以应该是这样子写的

11:31.990 --> 11:33.990
那么把合并成为VALUE的

11:33.990 --> 11:35.990
VALUE的这个玩意

11:35.990 --> 11:36.990
一个组件

11:36.990 --> 11:38.990
它只能用一次

11:38.990 --> 11:39.990
它只能绑定一个

11:39.990 --> 11:41.990
那如果说我要绑定多个数据

11:41.990 --> 11:42.990
那你就不好办了

11:42.990 --> 11:43.990
这种学习

11:43.990 --> 11:46.990
在我们普通的表单元素里面

11:46.990 --> 11:47.990
倒是不会遇到

11:47.990 --> 11:49.990
但是如果说你是一个自定义

11:49.990 --> 11:51.990
组件的时候有可能会遇到

11:51.990 --> 11:53.990
我下面取了一个简单的例子

11:53.990 --> 11:55.990
比方说我这里有个直组件

11:55.990 --> 11:56.990
这个直组件里边

11:56.990 --> 11:58.990
我们把它写一写吧

11:58.990 --> 12:00.990
我这里有个空的项目

12:00.990 --> 12:01.990
我把它写一个

12:01.990 --> 12:02.990
写个组件

12:02.990 --> 12:04.990
叫NUMBERS

12:04.990 --> 12:06.990
然后把这个代码复制一下吧

12:06.990 --> 12:08.990
你看一下这个直组件

12:08.990 --> 12:09.990
这个直组件特别有意思

12:09.990 --> 12:11.990
它有两个P元素

12:11.990 --> 12:14.990
要接受两个属性

12:14.990 --> 12:16.990
第一个P元素来显示NUM1

12:16.990 --> 12:17.990
几个数字

12:17.990 --> 12:19.990
第二个P元素来显示NUM2

12:19.990 --> 12:20.990
显示另一个属效

12:20.990 --> 12:22.990
这个属性就表示说

12:22.990 --> 12:24.990
是副组件给我们的数据

12:24.990 --> 12:25.990
我这里能改吗

12:25.990 --> 12:26.990
肯定不能改

12:26.990 --> 12:28.990
但是这个组件里面有两个按钮

12:28.990 --> 12:29.990
一个按钮是简

12:29.990 --> 12:30.990
一个按钮是加

12:30.990 --> 12:31.990
那过去的做法怎么办

12:31.990 --> 12:32.990
你看这里也是一样

12:32.990 --> 12:34.990
针对两个数字有两个按钮

12:34.990 --> 12:36.990
现在有两个数据

12:36.990 --> 12:38.990
我直组件不能去改它

12:38.990 --> 12:40.990
因为是属性传过来的

12:40.990 --> 12:41.990
那我怎么办呢

12:41.990 --> 12:42.990
按照过去的做法

12:42.990 --> 12:43.990
是不是一定是这样子

12:43.990 --> 12:45.990
触发一个事件

12:45.990 --> 12:47.990
副组件去注册这个事件

12:47.990 --> 12:48.990
我把一个新的纸

12:48.990 --> 12:49.990
我期望的是

12:49.990 --> 12:50.990
点了简过后

12:50.990 --> 12:51.990
原来的数字上简1

12:51.990 --> 12:53.990
我就把这个简1的纸

12:53.990 --> 12:54.990
传给你

12:54.990 --> 12:56.990
要不要改变这个数据

12:56.990 --> 12:57.990
你自己去弄

12:57.990 --> 12:59.990
也有它的整个过程是这样子

12:59.990 --> 13:01.990
简单化一下吧

13:01.990 --> 13:05.990
就是说副组件

13:05.990 --> 13:09.990
这是副组件

13:09.990 --> 13:14.780
然后这是直组件

13:14.780 --> 13:15.780
副组件传递给直组件

13:15.780 --> 13:16.780
两个东西

13:16.780 --> 13:17.780
对吧

13:17.780 --> 13:21.780
一个是那么一

13:21.780 --> 13:24.780
一个是那么二

13:24.780 --> 13:29.240
副组件传过来的

13:29.240 --> 13:30.240
直组件是没有权力改它的

13:30.240 --> 13:31.240
但是直组件

13:31.240 --> 13:32.240
它是有一个能力

13:32.240 --> 13:33.240
它就是触发事件

13:33.240 --> 13:35.240
直组件是不是通过事件触发

13:35.240 --> 13:36.240
交给副组件

13:36.240 --> 13:38.240
比方说触发了一个什么事件呢

13:38.240 --> 13:39.240
触发了一个

13:39.240 --> 13:40.240
我这里事件名字

13:40.240 --> 13:41.240
就写了一个特殊的名字

13:41.240 --> 13:42.240
这个名字写没什么特殊的

13:42.240 --> 13:44.240
它也是一个事件名而已

13:44.240 --> 13:45.240
比方说触发一个什么事件呢

13:45.240 --> 13:49.240
触发一个叫做update

13:49.240 --> 13:51.240
update

13:51.240 --> 13:52.240
那么一这个事件

13:52.240 --> 13:53.240
事件的名字叫这个

13:53.240 --> 13:54.240
然后给它的一个新的数字

13:54.240 --> 13:56.240
比方说那么一之前的值呢

13:56.240 --> 13:58.240
是二

13:58.240 --> 13:59.240
那么现在给它的值呢

13:59.240 --> 14:00.240
就减1了

14:00.240 --> 14:03.870
减1了变成1了

14:03.870 --> 14:05.870
懂了意思吧

14:05.870 --> 14:06.870
好那么触发给副组件

14:06.870 --> 14:08.870
那么副组件要不要处理呢

14:08.870 --> 14:09.870
那个和副组件有没有

14:09.870 --> 14:10.870
看怎么去处理

14:10.870 --> 14:11.870
那么假设副组件呢

14:11.870 --> 14:12.870
它的处理方式就是

14:12.870 --> 14:14.870
把这个一重新复制给那么一

14:14.870 --> 14:15.870
因为这个数据是副组件的

14:15.870 --> 14:16.870
对吧

14:16.870 --> 14:18.870
副组件是有权力改改的

14:18.870 --> 14:19.870
重新复制给那么一过后呢

14:19.870 --> 14:22.870
那么接下来副组件是不是

14:22.870 --> 14:23.870
就改动了这个那么一

14:23.870 --> 14:24.870
改动那么一是不是

14:24.870 --> 14:25.870
去重新宣展

14:25.870 --> 14:26.870
那么重新宣展

14:26.870 --> 14:27.870
重新把这个那么一

14:27.870 --> 14:29.870
传递给值组件

14:29.870 --> 14:31.870
那么值组件就重新宣展

14:31.870 --> 14:32.870
那么得到新的那么一了

14:32.870 --> 14:34.870
它又过去是这种模式对吧

14:34.870 --> 14:35.870
那么这里呢

14:35.870 --> 14:36.870
我要讲的那个

14:36.870 --> 14:37.870
圣可这个修饰服呢

14:37.870 --> 14:38.870
它并没有改变这种模式

14:38.870 --> 14:40.870
它只是一个愚法堂而已

14:40.870 --> 14:41.870
其实不用这个愚法堂

14:41.870 --> 14:42.870
我们仍然OK

14:42.870 --> 14:43.870
仍然可以做

14:43.870 --> 14:44.870
比方说我们怎么做呢

14:44.870 --> 14:45.870
看一下啊

14:45.870 --> 14:47.870
副组件写好了

14:47.870 --> 14:48.870
变成这个样子了

14:48.870 --> 14:49.870
那么我们再写副组件

14:49.870 --> 14:50.870
副组件写

14:50.870 --> 14:51.870
我们去导入

14:51.870 --> 14:53.870
numbers

14:53.870 --> 14:54.870
from

14:54.870 --> 14:56.870
components

14:56.870 --> 14:57.870
numbers

14:57.870 --> 14:59.870
注册一下吧

14:59.870 --> 15:01.870
components

15:01.870 --> 15:02.870
numbers

15:02.870 --> 15:03.870
好

15:03.870 --> 15:04.870
我们不用那个新知识

15:04.870 --> 15:05.870
看怎么能弄啊

15:05.870 --> 15:06.870
我们这里呢

15:06.870 --> 15:07.870
就一个DIV

15:07.870 --> 15:08.870
比方说我们这里

15:08.870 --> 15:09.870
就直接写个numbers

15:09.870 --> 15:14.140
它不是有两个属性吗

15:14.140 --> 15:15.140
那两个属性

15:15.140 --> 15:16.140
我这里写两个数据

15:16.140 --> 15:18.140
这数据是属于副组件

15:18.140 --> 15:20.140
比方说就

15:20.140 --> 15:21.140
n1

15:21.140 --> 15:22.140
0

15:22.140 --> 15:23.140
n2

15:24.140 --> 15:26.140
随便写个吧

15:26.140 --> 15:27.140
然后它就有两个属性

15:27.140 --> 15:28.140
要传的一个是那么一

15:28.140 --> 15:29.140
对吧

15:29.140 --> 15:30.140
我们传n1

15:30.140 --> 15:31.140
然后呢

15:31.140 --> 15:32.140
一个是那么二

15:32.140 --> 15:33.140
我们传一个

15:33.140 --> 15:34.140
n2

15:35.140 --> 15:36.140
好保存啊

15:36.140 --> 15:37.140
我们来看一下

15:37.140 --> 15:38.140
现在说的

15:38.140 --> 15:39.140
就已经传过去了对吧

15:39.140 --> 15:40.140
那么现在能改变吗

15:40.140 --> 15:41.140
不能改变

15:41.140 --> 15:42.140
为什么不能改变的

15:42.140 --> 15:43.140
因为它拋出了时间

15:43.140 --> 15:45.140
你并没有处理这个时间

15:45.140 --> 15:46.140
好那我现在处理这个时间吧

15:46.140 --> 15:48.140
它拋出了两个时间

15:48.140 --> 15:50.140
一个是期望跟改n1的

15:50.140 --> 15:52.140
一个是期望跟改n2的

15:52.140 --> 15:53.140
那么第一个时间

15:53.140 --> 15:55.140
它的时间名字叫做update

15:57.140 --> 15:58.140
那么一

15:58.140 --> 15:59.140
当然这个时间名字

15:59.140 --> 16:00.140
可以随便取

16:00.140 --> 16:01.140
可以取个abc都可以

16:01.140 --> 16:02.140
我们就用这个名字吧

16:02.140 --> 16:03.140
update

16:03.140 --> 16:04.140
那么一

16:04.140 --> 16:06.140
当发生这个时间的时候

16:06.140 --> 16:08.140
它是不是会传一个数据过来啊

16:08.140 --> 16:09.140
传一个新的数据过来

16:09.140 --> 16:10.140
我要做的是什么事情呢

16:10.140 --> 16:12.140
我就把这个新的数据

16:12.140 --> 16:13.140
把event

16:13.140 --> 16:15.140
是不是拿到这个时间参数

16:15.140 --> 16:16.140
把这个新的数据

16:16.140 --> 16:17.140
复制给谁

16:17.140 --> 16:18.140
复制给n1

16:18.140 --> 16:19.140
所以玩笑了

16:20.140 --> 16:22.140
你看一下n1是不能改变的

16:22.140 --> 16:24.840
说能改变的

16:24.840 --> 16:25.840
对不对就这么简单

16:25.840 --> 16:26.840
用到新字是吧

16:26.840 --> 16:27.840
没有吧

16:27.840 --> 16:28.840
然后接下来

16:28.840 --> 16:29.840
另外一个也是一样

16:29.840 --> 16:30.840
那么二

16:30.840 --> 16:32.840
如果出发这个时间的时候

16:32.840 --> 16:34.840
它把我把它传过来的这个字呢

16:35.840 --> 16:36.840
复制给什么

16:36.840 --> 16:37.840
复制给n2

16:37.840 --> 16:38.840
n2一改变

16:38.840 --> 16:39.840
是不是要重新券的东西

16:39.840 --> 16:40.840
就这么简单

16:41.840 --> 16:43.840
你看数据都可以了

16:43.840 --> 16:44.840
对不对

16:44.840 --> 16:45.840
非常简单

16:45.840 --> 16:46.840
但是这样子写的话

16:46.840 --> 16:47.840
其实

16:48.840 --> 16:49.840
本质上就已经完成了

16:49.840 --> 16:50.840
但是写的话

16:50.840 --> 16:51.840
我觉得有点麻烦

16:51.840 --> 16:52.840
因为这个

16:52.840 --> 16:53.840
我就无非就是希望了

16:53.840 --> 16:54.840
把这个n1

16:54.840 --> 16:55.840
这个数据呢

16:55.840 --> 16:56.840
绑定到这个属性

16:56.840 --> 16:57.840
当的e里边

16:58.840 --> 17:00.840
如果说属性期望变化的时候

17:00.840 --> 17:02.840
我就简单给n1复制而已

17:02.840 --> 17:04.840
复制就完事了

17:04.840 --> 17:05.840
那么其实呢

17:05.840 --> 17:06.840
这里可以利用一个愚法堂

17:06.840 --> 17:07.840
什么愚法堂呢

17:08.840 --> 17:09.840
把这个复制一下

17:12.920 --> 17:14.920
我就可以不要写这两个东西了

17:14.920 --> 17:16.920
我在n1下面加一个修饰服

17:16.920 --> 17:17.920
sync

17:17.920 --> 17:18.920
那个表示有什么意思

17:18.920 --> 17:19.920
sync or s

17:19.920 --> 17:20.920
同步的意思

17:21.920 --> 17:22.920
这样子写呢

17:22.920 --> 17:23.920
效果完全一样

17:24.920 --> 17:25.920
看没

17:25.920 --> 17:26.920
说效果完全一样

17:27.920 --> 17:29.920
因为你这样子写了过后

17:29.920 --> 17:31.920
它展开过后就变成这个样子了

17:32.920 --> 17:33.920
一模一样

17:34.920 --> 17:35.920
它只是一个愚法堂而已

17:35.920 --> 17:36.920
对吧

17:36.920 --> 17:38.920
你这样子是不是可以简化一下操作

17:38.920 --> 17:39.920
对不对

17:39.920 --> 17:41.920
展开之后它就变成这个样子了

17:41.920 --> 17:42.920
所以说呢

17:42.920 --> 17:43.920
如果说你要利用这个

17:43.920 --> 17:44.920
sync修饰服的话

17:44.920 --> 17:45.920
就要要求你的

17:45.920 --> 17:46.920
事件触发的名字

17:46.920 --> 17:47.920
也要写成这种格式

17:48.920 --> 17:49.920
也要写成这种格式

17:49.920 --> 17:50.920
你自己去对比看一下吧

17:51.920 --> 17:53.920
因为它展开之后就变成这个样子了

17:53.920 --> 17:54.920
如果说你

17:54.920 --> 17:55.920
植树剑没有触发这个事件的话

17:55.920 --> 17:56.920
那个事件就监听不到

17:57.920 --> 17:58.920
就这么简单

17:59.920 --> 18:01.920
好 这是关于这个sync or s

18:02.920 --> 18:05.230
好 这是这个

18:05.230 --> 18:07.230
接下来是这个parent children

18:07.230 --> 18:09.230
这个玩意用的也很少很少

18:09.230 --> 18:12.230
那么它是用于在组建里边

18:12.230 --> 18:15.230
获取当前组建的副组建和植树建的实力

18:15.230 --> 18:16.230
啥意思呢

18:16.230 --> 18:18.230
比方说我这个app里边

18:18.230 --> 18:19.230
我可以通过

18:20.230 --> 18:21.230
qt的里边

18:21.230 --> 18:26.980
我们这里取消掉

18:26.980 --> 18:28.980
这里再加个app

18:28.980 --> 18:30.980
好 我们在qt里边输出一下

18:30.980 --> 18:32.980
这个z 是不是当前组建实力

18:32.980 --> 18:34.980
它里边有个特殊的属性叫tilted

18:36.980 --> 18:37.980
得到的是什么呢

18:37.980 --> 18:38.980
得到的是当前组建里边

18:38.980 --> 18:41.980
用到了哪些植组建

18:41.980 --> 18:42.980
不包含元素

18:42.980 --> 18:43.980
元素它不管

18:43.980 --> 18:44.980
它就看植组建

18:44.980 --> 18:45.980
好 咱们来看一下吧

18:46.980 --> 18:47.980
检查

18:47.980 --> 18:48.980
检查

18:51.350 --> 18:52.350
这体是不是太小了

18:52.350 --> 18:53.350
你们看不清楚

19:00.260 --> 19:01.260
这写错了吗

19:01.260 --> 19:02.260
输出一下ZS

19:06.260 --> 19:09.260
这个时候输出的时间太早了

19:14.700 --> 19:16.700
刮载了之后才知道

19:17.700 --> 19:19.700
你看是不是两个输出的长度为二

19:19.700 --> 19:20.700
是不是有两个植组建

19:20.700 --> 19:21.700
一个植组建它

19:21.700 --> 19:23.700
他们不是一个植组建吗

19:23.700 --> 19:25.700
植组建都是一个植组建

19:25.700 --> 19:27.700
但是它的实力不一样

19:28.700 --> 19:29.700
就好像一个构造寒树

19:29.700 --> 19:31.700
可以创建多个堆箱一样

19:31.700 --> 19:32.700
这里也是一样

19:32.700 --> 19:34.700
它两个实力不一样

19:34.700 --> 19:35.700
一个

19:35.700 --> 19:36.700
这边有一个组建实力

19:36.700 --> 19:38.700
非常像一个五佑

19:38.700 --> 19:39.700
五佑的实力一样

19:40.700 --> 19:42.700
这就是通过qt准

19:42.700 --> 19:44.700
可以拿到这个植组建的实力

19:44.700 --> 19:45.700
当然拿到这个植组建的实力

19:45.700 --> 19:46.700
有什么用呢

19:46.700 --> 19:47.700
那里I做什么

19:47.700 --> 19:48.700
是做什么

19:48.700 --> 19:50.700
实力包含了个组建的所有信息

19:51.700 --> 19:52.700
包括了个数据

19:52.700 --> 19:53.700
这种东西都可以拿到

19:53.700 --> 19:54.700
对不对

19:54.700 --> 19:56.700
这是关于这个

19:56.700 --> 19:57.700
那么植组建里边

19:57.700 --> 19:59.700
也可以通过mounted

20:01.700 --> 20:03.700
可以获取到它的副组建的信息

20:03.700 --> 20:04.700
parade

20:05.700 --> 20:06.700
小心

20:06.700 --> 20:07.700
你看

20:09.700 --> 20:10.700
副组建

20:11.700 --> 20:12.700
这里输出了两次

20:12.700 --> 20:13.700
为什么

20:13.700 --> 20:14.700
因为我用了两次这个numbers

20:14.700 --> 20:16.700
两个numbers都会挂载

20:17.700 --> 20:18.700
是不是副组建的信息

20:19.700 --> 20:20.700
n1n2

20:21.700 --> 20:22.700
通过这个东西也可以获取

20:23.700 --> 20:24.700
评说中看法不怎么会用的

20:24.700 --> 20:25.700
了解就行了

20:25.700 --> 20:26.700
知道有这么一个东西存在

20:26.700 --> 20:27.700
就ok了

20:28.700 --> 20:30.700
下面这个是跟插槽相关的

20:30.700 --> 20:31.700
这插槽相关的

20:31.700 --> 20:32.700
我们后边会单独打一些课

20:32.700 --> 20:33.700
来讲插槽

20:33.700 --> 20:34.700
它也是可以利用它

20:34.700 --> 20:36.700
来进行组建的通信的

20:36.700 --> 20:37.700
后续将它也讲解

20:37.700 --> 20:38.700
用的也很少

20:39.700 --> 20:40.700
下面是个rave

20:40.700 --> 20:41.700
这个没什么好说的

20:41.700 --> 20:42.700
讲过的

20:42.700 --> 20:43.700
它是在副组建里边

20:43.700 --> 20:45.700
可以拿到一个植组建的实力

20:45.700 --> 20:46.700
比较多给这个组建的

20:46.700 --> 20:47.700
加一个rave

20:49.700 --> 20:50.700
n

20:51.700 --> 20:52.700
那么这样子

20:52.700 --> 20:53.700
我在monty的里边

20:53.700 --> 20:54.700
我们再输出一下

20:58.700 --> 21:00.700
是不是可以拿到这个组建的实力

21:00.700 --> 21:01.700
之前我们只是用它

21:01.700 --> 21:03.700
来拿到一个动物元素

21:03.700 --> 21:04.700
写到动物元素上面

21:04.700 --> 21:05.700
它其实可以加在主建上面

21:05.700 --> 21:06.700
那么这样子

21:06.700 --> 21:07.700
可以拿到这个组建的实力

21:08.700 --> 21:09.700
没问题吧

21:11.700 --> 21:12.700
那么这些东西平时开发

21:12.700 --> 21:13.700
都不怎么会用得到

21:13.700 --> 21:14.700
不用去纠结

21:14.700 --> 21:16.700
也不用去有太多的负担

21:16.700 --> 21:18.700
去纯粹是应付这个面词题

21:19.700 --> 21:21.700
而且你不用回答这么详细

21:21.700 --> 21:22.700
你去把一个目录

21:22.700 --> 21:23.700
给它说一下就行了

21:24.700 --> 21:25.700
这是关于rave

21:26.700 --> 21:27.700
因为我

21:27.700 --> 21:28.700
啥都不跟你说

21:28.700 --> 21:29.700
印象都没有

21:29.700 --> 21:30.700
说了一下

21:30.700 --> 21:31.700
简单说一下

21:31.700 --> 21:32.700
你至少有点印象

21:32.700 --> 21:34.700
这是副组建通信

21:35.700 --> 21:37.700
现在我们来看一个夸组建通信

21:37.700 --> 21:38.700
就是它那个组建成绩

21:38.700 --> 21:40.700
它不一定是副组建关系

21:40.700 --> 21:41.700
它有可能是

21:41.700 --> 21:43.700
有可能是兄弟元素

21:43.700 --> 21:45.700
有可能是祖先和后代元素

21:45.700 --> 21:46.700
说不准

21:46.700 --> 21:47.700
甚至有可能是一个组建

21:47.700 --> 21:48.700
跟一个GS模块

21:49.700 --> 21:50.700
那么这样

21:50.700 --> 21:51.700
这个东西怎么来通信

21:51.700 --> 21:53.700
我们是不是也学过了一些

21:53.700 --> 21:54.700
首先我们看第1个

21:54.700 --> 21:56.700
那么在夸组建通信的时候

21:56.700 --> 21:57.700
我首先说一点

21:57.700 --> 21:59.700
除了这个第1个之外

21:59.700 --> 22:01.700
第1个是Will给你提供的功能

22:01.700 --> 22:03.700
它可以在夸组建之间

22:03.700 --> 22:04.700
进行通信

22:04.700 --> 22:06.700
但是兄弟元素不行

22:06.700 --> 22:07.700
只能是

22:07.700 --> 22:08.700
祖先和后代是可以的

22:08.700 --> 22:09.700
副织也可以

22:09.700 --> 22:10.700
没问题

22:11.700 --> 22:12.700
除了这个东西之外

22:12.700 --> 22:13.700
后续了什么Rot

22:13.700 --> 22:14.700
Wilkes

22:14.700 --> 22:15.700
Stone

22:15.700 --> 22:16.700
还有EventBus

22:16.700 --> 22:17.700
这些东西

22:17.700 --> 22:19.700
都是利用一个第三方的东西

22:19.700 --> 22:22.700
利用一个间接的方式来进行通信

22:22.700 --> 22:23.700
它没法直接通信

22:25.700 --> 22:26.700
好,我们来看一下吧

22:26.700 --> 22:27.700
首先是Provide

22:27.700 --> 22:28.700
应借个字

22:28.700 --> 22:29.700
这个平时我们开发也不怎么用的

22:29.700 --> 22:31.700
你可能要写一些

22:31.700 --> 22:32.700
公共的库

22:33.700 --> 22:34.700
一些组建库的时候

22:34.700 --> 22:35.700
可能会用的

22:36.700 --> 22:37.700
这用的也比较少

22:38.700 --> 22:39.700
说一下吧

22:39.700 --> 22:40.700
看一个例子

22:40.700 --> 22:41.700
一个例子非常简单

22:41.700 --> 22:42.700
副组建里边

22:42.700 --> 22:43.700
这是副组建的配置对象

22:43.700 --> 22:44.700
对吧

22:44.700 --> 22:45.700
副组建里边

22:45.700 --> 22:46.700
我们可以通过一个特殊的配置

22:46.700 --> 22:47.700
叫做Provide

22:47.700 --> 22:48.700
表示提供

22:48.700 --> 22:50.700
提供一个一些数据

22:50.700 --> 22:52.700
那么就是属性名

22:52.700 --> 22:53.700
属性值

22:53.700 --> 22:54.700
属性名属性值

22:54.700 --> 22:55.700
你就可以提供就完事了

22:55.700 --> 22:56.700
配置个对象

22:57.700 --> 22:58.700
很简单吧

22:58.700 --> 23:00.700
然后在植住建里边

23:00.700 --> 23:02.700
可能是植住建

23:02.700 --> 23:03.700
也可能是后代组建

23:03.700 --> 23:04.700
都可以

23:04.700 --> 23:05.700
在植住建里边

23:05.700 --> 23:07.700
可以通过这个应借个字

23:08.700 --> 23:10.700
声明我这个植住建

23:10.700 --> 23:12.700
要用到哪些提供的数据

23:13.700 --> 23:14.700
那么潜力条件

23:14.700 --> 23:15.700
它的主

23:15.700 --> 23:16.700
它的祖先元素

23:16.700 --> 23:18.700
就祖先祖建

23:18.700 --> 23:19.700
必须要有提供的数据

23:19.700 --> 23:20.700
比方说你这就写个

23:20.700 --> 23:21.700
写个ABC

23:21.700 --> 23:22.700
不好意思

23:22.700 --> 23:23.700
之前的祖先祖建

23:23.700 --> 23:24.700
他没有提供这个东西

23:24.700 --> 23:25.700
没有提供

23:25.700 --> 23:26.700
他只提供这么一个数据

23:26.700 --> 23:27.700
他没有提供ABC

23:27.700 --> 23:28.700
那就拿不到

23:28.700 --> 23:29.700
那意思吧

23:29.700 --> 23:30.700
那么我这里写个副

23:30.700 --> 23:32.700
表示说我要拿到这个

23:32.700 --> 23:33.700
祖先祖建

23:33.700 --> 23:34.700
提供的这个副的数据

23:34.700 --> 23:35.700
那么这样子一显呢

23:36.700 --> 23:37.700
偶和度就高了

23:37.700 --> 23:38.700
偶和度

23:38.700 --> 23:39.700
就是你这里

23:39.700 --> 23:40.700
要有个假设

23:40.700 --> 23:41.700
假设

23:41.700 --> 23:42.700
我这个祖建

23:42.700 --> 23:43.700
必须要

23:43.700 --> 23:44.700
有哪些副主建

23:44.700 --> 23:45.700
就是必须要提供

23:45.700 --> 23:46.700
这个数据的副主建

23:46.700 --> 23:47.700
才能使用我这个

23:47.700 --> 23:48.700
植住建

23:48.700 --> 23:49.700
不然的话

23:49.700 --> 23:50.700
这个数据拿不到

23:50.700 --> 23:51.700
那么于是呢

23:51.700 --> 23:52.700
我就可以在这个

23:52.700 --> 23:53.700
植住建里面

23:53.700 --> 23:54.700
使用这个数据

23:54.700 --> 23:55.700
非常简单

23:55.700 --> 23:56.700
那么这里边有一个

23:56.700 --> 23:57.700
详细的文档

23:57.700 --> 23:58.700
你可以去看一下

23:58.700 --> 23:59.700
它还有一些

23:59.700 --> 24:00.700
比较特殊的用法

24:00.700 --> 24:01.700
有兴趣可以看一下

24:01.700 --> 24:02.700
简单了解一下就OK了

24:03.700 --> 24:04.700
你要的意思吧

24:04.700 --> 24:05.700
那么它是可以跨越成绩的

24:05.700 --> 24:06.700
我们还是给它演示一下吧

24:07.700 --> 24:08.700
这一代码了

24:08.700 --> 24:09.700
我就不保存了

24:09.700 --> 24:10.700
这些保存有什么

24:10.700 --> 24:11.700
没多少意义

24:11.700 --> 24:12.700
就是简单过一下就行了

24:12.700 --> 24:14.700
不用太多的去压力

24:14.700 --> 24:15.700
比方说过这里

24:15.700 --> 24:17.700
就写这么一些主建

24:19.700 --> 24:20.700
我就写一个写写主建

24:24.700 --> 24:27.340
没有什么好够

24:28.340 --> 24:29.340
写好写的

24:29.340 --> 24:33.630
再来一个B

24:33.630 --> 24:34.630
B

24:34.630 --> 24:35.630
那么这个A主建的里边

24:35.630 --> 24:36.630
用到了B主建

24:36.630 --> 24:37.630
APP又用到了A

24:37.630 --> 24:38.630
以为它形成这么一个

24:38.630 --> 24:39.630
成绩关系

24:40.630 --> 24:42.630
APP你不要包含了A

24:42.630 --> 24:43.630
A里面包含了B

24:44.630 --> 24:47.630
我现在要让APP

24:47.630 --> 24:48.630
提供一些数据

24:48.630 --> 24:49.630
在B里面过去

24:49.630 --> 24:51.630
是不是跨越成绩了

24:51.630 --> 24:52.630
好 咱们试一下

24:54.630 --> 24:56.630
我们在APP里面取

24:56.630 --> 24:57.630
首先去用这个A

24:58.630 --> 24:59.630
A这个主建

25:00.630 --> 25:01.630
这都不要了

25:01.630 --> 25:02.630
使用这个A

25:04.940 --> 25:06.940
然后A里面要去使用B

25:11.880 --> 25:12.880
直接写个B吧

25:12.880 --> 25:17.110
看不出来

25:18.110 --> 25:19.110
手动导致吧

25:21.110 --> 25:22.110
B

25:22.110 --> 25:23.110
这里注册一下

25:26.110 --> 25:27.110
好了 你看现在就形成了

25:27.110 --> 25:28.110
APP用A

25:28.110 --> 25:29.110
你不要用B

25:29.110 --> 25:30.110
现在我们在APP里面

25:30.110 --> 25:31.110
我们给它提供一个数据

25:33.110 --> 25:34.110
提供一个数据

25:34.110 --> 25:35.110
比方说这个数据

25:35.110 --> 25:36.110
就是A为1

25:36.110 --> 25:37.110
B为2

25:37.110 --> 25:38.110
就这样吧

25:39.110 --> 25:40.110
好 接下来

25:40.110 --> 25:41.110
我们在B里面

25:41.110 --> 25:42.110
如何去获取

25:42.110 --> 25:43.110
我们可以用Injects

25:45.110 --> 25:46.110
我们要获取这个数据A

25:46.110 --> 25:47.110
要获取这个数据B

25:48.110 --> 25:49.110
好 最后我们created

25:50.110 --> 25:51.110
来输出一下

25:52.110 --> 25:53.110
ZS A ZS B

25:53.110 --> 25:54.110
看能不能拿到

25:56.490 --> 25:57.490
刷新

25:57.490 --> 25:58.490
这里包错了

25:58.490 --> 25:59.490
到什么意思了

26:06.020 --> 26:07.020
这是啥意思

26:08.020 --> 26:09.020
刷新一下

26:11.020 --> 26:12.020
你这个就去掉了

26:12.020 --> 26:13.020
看一下什么情况

26:14.020 --> 26:16.020
这里哪里包错了

26:16.020 --> 26:18.020
这个错误提示不算友好

26:19.020 --> 26:21.020
用它的主建A

26:22.020 --> 26:24.020
A里边用到了主建B

26:25.020 --> 26:26.020
我先把B缺掉了

26:28.020 --> 26:29.020
这里没问题

26:29.020 --> 26:31.020
这个不是没有一个根源说

26:35.580 --> 26:37.580
你看 是不是输出了一和

26:37.580 --> 26:38.580
所以跨越主建通信了

26:39.580 --> 26:41.580
OK 这是关于Provide和Injects

26:42.580 --> 26:43.580
好 接下来是Rotor

26:43.580 --> 26:45.580
Rotor其实我们讲过的

26:45.580 --> 26:47.580
它可以做到一个间接通信

26:47.580 --> 26:48.580
对不对

26:49.580 --> 26:50.580
我还是举个例子

26:50.580 --> 26:51.580
比方说我们之前

26:51.580 --> 26:53.580
其实做过这么一个效果的

26:55.580 --> 26:56.580
就是我们有个地次栏

26:58.580 --> 26:59.580
现在我们有一些主建

26:59.580 --> 27:01.580
比方说有一个分业主建

27:02.580 --> 27:04.580
有一个列表主建

27:05.580 --> 27:06.580
他们之间可能没有什么关系

27:06.580 --> 27:07.580
可能是兄弟元素

27:07.580 --> 27:08.580
有可能是父子

27:08.580 --> 27:09.580
说不准是什么关系

27:09.580 --> 27:10.580
无所谓

27:11.580 --> 27:12.580
现在的情况

27:12.580 --> 27:13.580
就是说

27:13.580 --> 27:16.580
分业主建有可能会改变地次栏

27:17.580 --> 27:19.580
而列表主建在监听地次栏

27:20.580 --> 27:22.580
它的监听地次栏

27:22.580 --> 27:23.580
于是地次栏

27:23.580 --> 27:25.580
这些主建当改变地次栏的时候

27:25.580 --> 27:27.580
地次栏就会通知列表主建

27:27.580 --> 27:29.580
让它做出一些改变

27:29.580 --> 27:30.580
就这么个意思

27:30.580 --> 27:31.580
非常简单

27:31.580 --> 27:33.580
也就是它两个主建之间

27:33.580 --> 27:34.580
没法直接通信

27:34.580 --> 27:35.580
它是利用一个第三者

27:35.580 --> 27:36.580
对不对

27:36.580 --> 27:37.580
就这么个意思

27:38.580 --> 27:39.580
这是Rotor

27:39.580 --> 27:40.580
那么其实我们

27:40.580 --> 27:42.580
就算自己不携带

27:42.580 --> 27:44.580
Rotor主建这种通信方式

27:44.580 --> 27:45.580
也是存在的

27:45.580 --> 27:47.580
比方说我们页面上有个超链接

27:47.580 --> 27:49.580
这个超链接是不是Rotor Link的主建

27:49.580 --> 27:50.580
它是个主建

27:50.580 --> 27:51.580
只不过

27:51.580 --> 27:53.580
只有Rotor给你写好的主建

27:54.580 --> 27:55.580
这个主建有什么作用

27:55.580 --> 27:56.580
不就是改变地次栏吗

27:56.580 --> 27:57.580
对不对

27:58.580 --> 27:59.580
改变地次栏为何

27:59.580 --> 28:01.580
为什么可以渲染不同的页面呢

28:01.580 --> 28:03.580
使用Rotor View

28:03.580 --> 28:05.580
怎么写到APP地表的东西

28:06.580 --> 28:07.580
对吧

28:07.580 --> 28:09.580
根据地址渲染不同的主建

28:09.580 --> 28:11.580
根据路由配置来渲染不同的主建

28:11.580 --> 28:13.580
它就起这么一个作用

28:13.580 --> 28:15.580
它在监听地次的变化

28:15.580 --> 28:16.580
它在改变地址

28:16.580 --> 28:18.580
实际上就已经有这么一个间接通信了

28:18.580 --> 28:20.580
就这么个意思

28:21.580 --> 28:22.580
ViewX没什么好说的

28:22.580 --> 28:24.580
已经讲的非常多了

28:24.580 --> 28:25.580
花了好几节课

28:25.580 --> 28:28.580
它就是一个大型的数据仓库

28:28.580 --> 28:30.580
它可以跟踪数据的变化

28:30.580 --> 28:32.580
而且它里面用到了一些模式

28:32.580 --> 28:35.580
比方说Multation

28:35.580 --> 28:37.580
不能写一步操作

28:38.580 --> 28:40.580
Action是可以写一步操作的

28:41.580 --> 28:43.580
这是关于ViewX

28:43.580 --> 28:45.580
下面是Store模式

28:45.580 --> 28:47.580
这是什么玩意儿呢

28:48.580 --> 28:50.580
这是View官方给你推荐的

28:50.580 --> 28:51.580
他说

28:51.580 --> 28:54.580
如果说你做的是一些中小型的项目

28:54.580 --> 28:57.580
其实你没有必要去用ViewX

28:57.580 --> 28:59.580
它有点太大了

28:59.580 --> 29:00.580
太繁瑣了

29:00.580 --> 29:01.580
太重了

29:01.580 --> 29:04.580
你可以使用一种非常非常简单的方式

29:04.580 --> 29:06.580
来完成一个数据共享

29:06.580 --> 29:08.580
那么可以达到不同的主建

29:08.580 --> 29:10.580
使用同一块数据

29:10.580 --> 29:11.580
非常简单

29:11.580 --> 29:12.580
我给大家画一个图吧

29:12.580 --> 29:13.580
简单的不得了

29:13.580 --> 29:18.140
就是你准备好一个GS模块

29:18.140 --> 29:20.140
一个GS模块

29:24.460 --> 29:31.860
这是有读吧

29:33.860 --> 29:35.860
写英文和数字不行

29:37.860 --> 29:38.860
还可以

29:38.860 --> 29:40.860
为什么后面不行

29:40.860 --> 29:42.860
英文和数字不能夹在一起吗

29:44.860 --> 29:45.860
这什么鬼啊

29:45.860 --> 29:47.860
这个软件有点问题

29:47.860 --> 29:49.860
比方说普通的GS模块

29:49.860 --> 29:51.860
一个普通模块

29:51.860 --> 29:56.500
然后现在有一些主建

29:56.500 --> 30:00.770
主建

30:01.770 --> 30:03.770
还有一个主建

30:03.770 --> 30:05.770
还有一个主建

30:05.770 --> 30:07.770
那么现在我要做的事情

30:07.770 --> 30:09.770
就是说我这里的模块

30:09.770 --> 30:10.770
提供什么

30:10.770 --> 30:11.770
提供共享数据

30:11.770 --> 30:13.770
这个模块就是共享数据

30:13.770 --> 30:15.770
共享数据

30:15.770 --> 30:16.770
模块

30:16.770 --> 30:18.770
它里面其实做的事情很简单

30:18.770 --> 30:20.770
就是一个普通的介石对象

30:20.770 --> 30:22.770
主建A需要用这个共享数据

30:22.770 --> 30:24.770
哪里拿去用就行了

30:24.770 --> 30:26.770
简单的不得了

30:27.770 --> 30:29.770
你要用什么数据

30:29.770 --> 30:30.770
你拿去用

30:30.770 --> 30:32.770
主建B要用什么数据

30:32.770 --> 30:33.770
哪去用

30:33.770 --> 30:35.770
任何组建都可以有权利修改

30:35.770 --> 30:37.770
任何组建都可以修改

30:37.770 --> 30:39.770
而这个数据一遍就会通知其他

30:39.770 --> 30:41.770
共享数据不就是

30:41.770 --> 30:43.770
要做一些基本的事情吗

30:43.770 --> 30:44.770
那我们来看一下吧

30:44.770 --> 30:49.170
怎么来写这个单吧

30:49.170 --> 30:50.170
这就是一个仓库

30:50.170 --> 30:52.170
一个普通的对象介石对象

30:52.170 --> 30:53.170
login user setting

30:53.170 --> 30:54.170
比较拳击设置

30:54.170 --> 30:56.170
还有些别的什么一些数据

30:56.170 --> 30:58.170
配置到对象里面就行了

30:58.170 --> 31:00.170
当然一个对象你可以分成多个模块

31:00.170 --> 31:01.170
把整合成一个对象都可以

31:01.170 --> 31:02.170
无所谓

31:02.170 --> 31:03.170
就是个普通的介石对象

31:03.170 --> 31:05.170
没有任何的技术难度

31:05.170 --> 31:07.170
然后呢主建A要用这个数据

31:07.170 --> 31:08.170
怎么用呢

31:08.170 --> 31:09.170
login user

31:09.170 --> 31:10.170
把这个对象

31:10.170 --> 31:12.170
把导入这个store

31:12.170 --> 31:14.170
把这个对象放过来就行了

31:14.170 --> 31:16.170
因为只要这个对象一放过来

31:16.170 --> 31:17.170
这个对象呢

31:17.170 --> 31:19.170
因为他把它放到data里面的

31:19.170 --> 31:20.170
所以说这个对象就会瞬间

31:20.170 --> 31:22.170
变成享用式的数据

31:22.170 --> 31:23.170
因为我们之前说过

31:23.170 --> 31:25.170
主建里面的配置在data里面的数据

31:25.170 --> 31:27.170
都是享用式的

31:27.170 --> 31:29.170
而且是地规进行享用式

31:29.170 --> 31:30.170
它里面一个数据

31:30.170 --> 31:31.170
它里面是个对象

31:31.170 --> 31:32.170
对象里面所有东西

31:32.170 --> 31:34.170
全部会变成享用式

31:34.170 --> 31:35.170
好那么主建B

31:35.170 --> 31:36.170
要用这个东西呢

31:36.170 --> 31:37.170
也是用同一个

31:37.170 --> 31:38.170
用这个setting

31:38.170 --> 31:40.170
如果说他也要用到

31:40.170 --> 31:41.170
login user

31:41.170 --> 31:43.170
写就完事了

31:43.170 --> 31:44.170
login user

31:44.170 --> 31:45.170
因为这样子一来的话

31:45.170 --> 31:46.170
你就可以保证

31:46.170 --> 31:48.170
你看主建B的这个数据

31:48.170 --> 31:49.170
和主建A的这个数据

31:49.170 --> 31:51.170
是不是用了同一个对象

31:51.170 --> 31:52.170
对吧

31:52.170 --> 31:53.170
而且这个对象是享用式的

31:53.170 --> 31:54.170
不是你自己

31:54.170 --> 31:55.170
把它写成享用式

31:55.170 --> 31:56.170
是你配置到data里面

31:56.170 --> 31:58.170
所以还自动变成享用式的

31:58.170 --> 32:00.170
所以说这样子一来的话

32:00.170 --> 32:02.170
他们用的是同一个数据

32:02.170 --> 32:03.170
而且它又是享用式的

32:03.170 --> 32:04.170
是不是就已经完了

32:04.170 --> 32:07.610
不信我们试一下吧

32:07.610 --> 32:09.610
现在我们做一个简单的数据仓库

32:09.610 --> 32:10.610
就写个store

32:10.610 --> 32:11.610
叫js

32:11.610 --> 32:13.610
导出一个数据仓库

32:13.610 --> 32:15.610
非常非常简单

32:15.610 --> 32:17.610
我们就写一个

32:17.610 --> 32:21.690
写个什么

32:21.690 --> 32:23.690
写个login user吧

32:25.690 --> 32:27.690
或者就写个简单的

32:28.690 --> 32:29.690
number

32:30.690 --> 32:32.690
value等于1

32:32.690 --> 32:36.380
然后呢

32:36.380 --> 32:39.820
double number

32:39.820 --> 32:40.820
等于

32:40.820 --> 32:41.820
我写个啥

32:41.820 --> 32:42.820
我都不知道我写啥了

32:42.820 --> 32:43.820
就写个value等于1吧

32:43.820 --> 32:45.820
我就这样写得得了

32:45.820 --> 32:46.820
最好把写成对象

32:46.820 --> 32:48.820
保证他们的地址是一样的

32:48.820 --> 32:49.820
因为你写成

32:49.820 --> 32:50.820
你直接把写个1的话

32:50.820 --> 32:51.820
那么就保证

32:51.820 --> 32:52.820
包含传辑的时候

32:52.820 --> 32:53.820
就是一个直传辑了

32:53.820 --> 32:55.820
他们就互不干扰了

32:55.820 --> 32:56.820
那意思

32:56.820 --> 32:57.820
我们尽量把它

32:57.820 --> 32:58.820
它们是一个东西

32:58.820 --> 32:59.820
把写成对象

32:59.820 --> 33:01.820
那么我们就一个简单的store

33:01.820 --> 33:03.820
我们就到APP里边

33:03.820 --> 33:09.630
去使用这个store

33:12.630 --> 33:13.630
然后我们这里

33:13.630 --> 33:14.630
APP里边一个数

33:14.630 --> 33:15.630
数据

33:15.630 --> 33:17.630
就number吧

33:17.630 --> 33:21.140
storm.number

33:21.140 --> 33:22.140
当然这边

33:22.140 --> 33:23.140
其实你可以把这个store

33:23.140 --> 33:24.140
这个number加到哪呢

33:24.140 --> 33:25.140
加到这个

33:25.140 --> 33:27.140
优的实力里面去

33:27.140 --> 33:28.140
我再把它弄了

33:28.140 --> 33:29.140
就这样子写

33:29.140 --> 33:30.140
它就会变成想用式的

33:30.140 --> 33:31.140
它是个对象

33:31.140 --> 33:32.140
它就变成想用式的

33:32.140 --> 33:33.140
我们这里显示的时候

33:33.140 --> 33:34.140
就显示一个

33:34.140 --> 33:35.140
这些东西不要了

33:35.140 --> 33:39.470
这里我写个APP吗

33:39.470 --> 33:41.470
这边写个A

33:41.470 --> 33:44.470
这里我显示的时候

33:44.470 --> 33:45.470
显示的时候

33:45.470 --> 33:47.470
就显示这个number

33:47.470 --> 33:49.470
点value

33:50.470 --> 33:51.470
好,你看

33:51.470 --> 33:52.470
现在是不是显示出来

33:52.470 --> 33:53.470
那个1啊

33:53.470 --> 33:54.470
对不对

33:54.470 --> 33:55.470
我们写到这

33:55.470 --> 33:58.100
这上面吧

33:58.100 --> 33:59.100
就显示出一个1

33:59.100 --> 34:00.100
对吧

34:00.100 --> 34:01.100
那么我们可以加个按钮

34:01.100 --> 34:02.100
去改变它

34:02.100 --> 34:03.100
任何人都可以改变它

34:03.100 --> 34:04.100
保证

34:04.100 --> 34:05.100
比方说加

34:05.100 --> 34:06.100
点加的时候

34:06.100 --> 34:07.100
我要做的事情很简单

34:07.100 --> 34:08.100
就是number

34:08.100 --> 34:09.100
点value加加

34:10.100 --> 34:11.100
点击

34:11.100 --> 34:12.100
一看是不是可以加

34:13.100 --> 34:14.100
没问题吧

34:14.100 --> 34:15.100
它是想用式的数据

34:15.100 --> 34:17.100
它一改变就会变成这个页面

34:17.100 --> 34:18.100
好,这个主键A里面

34:18.100 --> 34:20.100
也可以做同样的事情

34:20.100 --> 34:21.100
主键A里面

34:21.100 --> 34:23.100
我们也可以使用这个Stone

34:23.100 --> 34:26.060
它其实功能效果了

34:26.060 --> 34:27.060
跟那个VX

34:27.060 --> 34:29.060
本质上是一样的

34:29.060 --> 34:32.750
它也有个数据

34:36.750 --> 34:37.750
number

34:37.750 --> 34:38.750
也是用的是

34:38.750 --> 34:40.750
这个Stone里面的number

34:41.750 --> 34:43.750
好,我们在主键A里面

34:43.750 --> 34:45.750
也用同样的事情

34:47.750 --> 34:49.750
显示这个number.value

34:49.750 --> 34:51.750
然后也有一个按钮

34:51.750 --> 34:53.750
点击

34:54.750 --> 34:55.750
click

34:55.750 --> 35:00.340
store.number

35:01.340 --> 35:02.340
好,保存

35:02.340 --> 35:03.340
你看

35:03.340 --> 35:04.340
你看它加了过后

35:04.340 --> 35:05.340
是不是另外一个主键也会变化

35:05.340 --> 35:06.340
它减了

35:07.340 --> 35:08.340
保存

35:09.340 --> 35:10.340
不是store

35:10.340 --> 35:12.340
就是number.value

35:19.340 --> 35:20.340
是不是

35:20.340 --> 35:21.340
这也是可以

35:21.340 --> 35:23.340
就是实现一个非常简单的数据共享

35:23.340 --> 35:25.340
这种东西就更加简单了

35:25.340 --> 35:26.340
对不对

35:26.340 --> 35:28.340
比VX简单很多了

35:28.340 --> 35:29.340
但是这个缺陷在哪呢

35:29.340 --> 35:30.340
缺陷就在于

35:30.340 --> 35:32.340
它无法跟踪数据的变化

35:32.340 --> 35:34.340
如果主键数变得复杂了

35:34.340 --> 35:36.340
任何一个主键都有权力去改动它

35:36.340 --> 35:38.340
而且可以随意改动

35:38.340 --> 35:40.340
到时候双固数据一旦出了问题

35:40.340 --> 35:42.340
你又不知道它到底是哪一个步骤出了问题

35:42.340 --> 35:44.340
数据是怎么样从一个状态

35:44.340 --> 35:45.340
变成另一个状态的

35:45.340 --> 35:47.340
也很难去跟踪

35:47.340 --> 35:48.340
你要去跟踪的话

35:48.340 --> 35:49.340
你怎么办呢

35:49.340 --> 35:50.340
你又要去设计

35:50.340 --> 35:52.340
到时候改的时候就不能直接改了

35:52.340 --> 35:55.340
你要调用我一个函数来进行更改

35:55.340 --> 35:57.340
最终你也会设计设计

35:57.340 --> 35:59.340
你会变成VX

35:59.340 --> 36:01.340
你还不如直接去使用VX

36:01.340 --> 36:02.340
好,这是关于Stone

36:02.340 --> 36:04.340
好,最后来是个event bus

36:04.340 --> 36:06.340
这东西其实也是利用一个第三者

36:06.340 --> 36:08.340
你看这些跨主键的东西

36:08.340 --> 36:09.340
除了第一个之外

36:09.340 --> 36:11.340
都是利用第三者

36:11.340 --> 36:15.340
世界总线是不是也讲过了

36:15.340 --> 36:17.340
就是这里的一个

36:17.340 --> 36:19.340
这里的世界总线

36:19.340 --> 36:22.720
它其实就是个观察者模式

36:22.720 --> 36:25.720
世界总线

36:25.720 --> 36:29.720
这边是一个主键

36:29.720 --> 36:32.720
这边又是另外一个主键

36:32.720 --> 36:34.720
这些主键一开始

36:34.720 --> 36:35.720
会告诉世界总线

36:35.720 --> 36:37.720
我要监听某一个世界

36:37.720 --> 36:38.720
比方说我要告诉它

36:38.720 --> 36:40.720
我要监听一个世界A

36:40.720 --> 36:44.420
监听

36:44.420 --> 36:47.420
世界A

36:47.420 --> 36:49.420
我一个打字

36:49.420 --> 36:53.420
真是神奇这个软件

36:53.420 --> 36:54.420
再试一下

36:54.420 --> 36:55.420
但是你一拳一拳

36:55.420 --> 36:56.420
它就变成A了

36:56.420 --> 36:58.420
天呐,我不知道怎么回事

36:58.420 --> 37:00.420
监听某一个世界

37:00.420 --> 37:01.420
然后这边的主键

37:01.420 --> 37:06.180
它会触发某一个世界

37:06.180 --> 37:07.180
它会触发

37:07.180 --> 37:20.750
它触发的世界过后

37:20.750 --> 37:21.750
世界总线

37:21.750 --> 37:22.750
就会通知那些

37:22.750 --> 37:24.750
之前监听这些世界的主键

37:24.750 --> 37:26.750
那么它去运行某一个函数

37:26.750 --> 37:27.750
世界总线

37:27.750 --> 37:28.750
当时我们自己写过代码

37:28.750 --> 37:29.750
也可以利用这个

37:29.750 --> 37:30.750
唯有的实力

37:30.750 --> 37:32.750
都可以完成

37:32.750 --> 37:33.750
好了,这些就是

37:33.750 --> 37:34.750
给大家总结了一下

37:34.750 --> 37:37.750
这个主键之间的通信方式

37:37.750 --> 37:39.750
不用去太过在意

37:39.750 --> 37:40.750
里边的很多的细节

37:40.750 --> 37:42.750
因为这里边的

37:42.750 --> 37:43.750
很多东西

37:43.750 --> 37:44.750
我们其实也不怎么

37:44.750 --> 37:45.750
会用得到

37:45.750 --> 37:46.750
其实用得最多的

37:46.750 --> 37:47.750
也就是Prob和Event

37:47.750 --> 37:48.750
这两个

37:48.750 --> 37:50.750
也是非常推荐大家使用的

37:50.750 --> 37:52.750
其他的就

37:52.750 --> 37:54.750
用的还不一定是好事

37:54.750 --> 37:56.750
像这些东西

37:56.750 --> 37:57.750
像这些东西用的

37:57.750 --> 37:58.750
它不一定是好事

37:58.750 --> 38:01.750
因为它会打破单向数据流

38:01.750 --> 38:02.750
单向数据流

38:02.750 --> 38:04.750
就是数据从副主键

38:04.750 --> 38:06.750
流到执主键

38:06.750 --> 38:07.750
执主键发生一件事

38:07.750 --> 38:08.750
通知副主键

38:08.750 --> 38:09.750
让副主键改变数据

38:09.750 --> 38:11.750
重新往下流

38:11.750 --> 38:12.750
这是单向数据流

38:12.750 --> 38:14.750
那么你要用这些东西的话

38:14.750 --> 38:15.750
就有可能会改变

38:15.750 --> 38:16.750
单向数据流

38:16.750 --> 38:18.750
所以说不太推荐这些东西

38:18.750 --> 38:21.750
我们推荐的就是入门阶段

38:21.750 --> 38:22.750
我们给大家写了个项目里边

38:22.750 --> 38:25.750
常用的这些东西方式就OK了

38:25.750 --> 38:26.750
好 这是关于这几颗

38:26.750 --> 38:27.750
平时如果说面试的时候

38:27.750 --> 38:28.750
遇到的话

38:28.750 --> 38:29.750
把这个目标给它回答出来

38:29.750 --> 38:30.750
就OK

38:30.750 --> 38:32.750
好 这就是我的内容

