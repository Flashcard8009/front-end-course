WEBVTT

00:00.110 --> 00:03.110
上课之前呢 咱们还是说一下啊

00:03.110 --> 00:06.110
无忧阶段 这个就业阶段的课呢

00:06.110 --> 00:09.110
主要有这么两个目的

00:09.110 --> 00:11.110
一个目的呢 就是

00:11.110 --> 00:13.110
经验面试官

00:13.110 --> 00:18.700
就是很多有的时候呢 面试官出了一个问题

00:18.700 --> 00:22.700
这个问题呢 它本身 它并没有期待说你能够回答

00:22.700 --> 00:25.700
非常深入的答案

00:25.700 --> 00:27.700
可能就是按部就班的回答就ok了

00:27.700 --> 00:31.700
但是呢 如果说你能够回答出来一个深入的答案的话

00:31.700 --> 00:34.700
可能会把他吓到 有可能他自己都不会

00:34.700 --> 00:37.700
我们要起到这么一个目的 因为我希望呢

00:37.700 --> 00:40.700
听了就业阶段的课 你是能够拿到高薪的啊

00:40.700 --> 00:43.700
我们一定要去追求高薪 有个好的起步

00:43.700 --> 00:47.700
这是我的第一个目的 所以说我讲的呢 可能会比较深

00:47.700 --> 00:51.700
第二点呢 我是希望通过就业阶段的课呢

00:51.700 --> 00:55.700
让大家对一个技术啊 有一些深入的了解

00:55.700 --> 00:58.700
那么这个东西起什么作用呢 倒不是说你将来

00:58.700 --> 01:02.700
去用这个技术去写东西的时候 比方说你用五幼写东西的时候

01:02.700 --> 01:05.700
你会写出一些什么不一样的东西 有可能会

01:05.700 --> 01:09.700
但是呢 大部分时候呢 它其实并不影响你后边的写代嘛

01:09.700 --> 01:13.700
但是它会影响什么呢 它会影响你的思维

01:13.700 --> 01:15.700
就是训练思维

01:15.700 --> 01:18.700
就是我们在五幼的时候啊 你会看到

01:18.700 --> 01:21.700
五幼在设计的时候 或者是一些我们讲其他技术的时候

01:21.700 --> 01:23.700
讲就业阶段也是类似的道理

01:23.700 --> 01:26.700
它在设计的时候呢 它会考虑到很多的问题

01:26.700 --> 01:29.700
那么它怎么样用一个精妙的设计 去解决这些问题的

01:29.700 --> 01:32.700
尽管了这些问题的 你们将来可能不会遇到

01:32.700 --> 01:37.700
但是呢 通过这样的去看别人的这种思路呢

01:37.700 --> 01:39.700
对你会有所启发

01:39.700 --> 01:42.700
那么将来呢 它会形成你的

01:42.700 --> 01:44.700
它会融入到你的学业里边

01:44.700 --> 01:46.700
将来如果说你遇到一些复杂的问题的时候

01:46.700 --> 01:48.700
可能会对你又说启发

01:48.700 --> 01:50.700
你可能会参照一些 五幼是这么做

01:50.700 --> 01:54.700
来解决这个问题的 那么我也可以用类似的方案

01:54.700 --> 01:57.700
那么这些东西呢 它不是说一时半火能够看到效果的

01:57.700 --> 02:01.700
它可能几年之后 几个月之后 几年之后

02:01.700 --> 02:03.700
当你突然有一天遇到某一个问题的时候呢

02:03.700 --> 02:07.700
你会发现 这个问题呢 我以前是见过的

02:07.700 --> 02:10.700
那么我能够想到一些方案来解决

02:10.700 --> 02:11.700
这是起到这么一个作用

02:11.700 --> 02:14.700
其实最主要的作用呢 还是面向就业

02:14.700 --> 02:16.700
这是最实用的作用

02:16.700 --> 02:19.700
因此呢 在听就业阶段的课的时候

02:19.700 --> 02:22.700
我希望了同学们 不要那么大的心理压力

02:22.700 --> 02:25.700
轻松一点 你能够理解多少就尽量理解多少

02:25.700 --> 02:27.700
因为我讲的本身就比较深

02:27.700 --> 02:29.700
哪怕你就业阶段有这么多课

02:29.700 --> 02:32.700
哪怕你就对其中一两节课

02:32.700 --> 02:35.700
认真的听懂了 那么到时候就业的时候

02:35.700 --> 02:38.700
也发现有一个公司刚好问到这个问题

02:38.700 --> 02:43.700
那么你这个问题呢 就可以回答出非常非常优质的答案

02:43.700 --> 02:46.700
那么就在其他的面试中 走里边呢

02:46.700 --> 02:47.700
能够脱颖而出

02:47.700 --> 02:49.700
我希望能够达成这么一个效果

02:49.700 --> 02:52.700
因为我们毕竟是希望大家能够拿到一个高薪

02:52.700 --> 02:55.700
而不刺紧紧简单的找到一个工作

02:55.700 --> 02:59.700
好吧 这节课呢 我们讲这个computed

03:00.700 --> 03:02.700
为什么讲他呢 其实他这个国争

03:02.700 --> 03:04.700
其实他这个玩意儿跟那个

03:04.700 --> 03:06.700
你们之后的开发没有什么关系

03:06.700 --> 03:09.700
你学到入门阶段computed你就会用了

03:09.700 --> 03:13.700
你听不听这节课呢 跟你开发没什么关系

03:13.700 --> 03:16.700
但是呢 因为我们面试体系比较有一个

03:16.700 --> 03:18.700
非常常见的一个问题

03:18.700 --> 03:22.700
对于伍佑的 就是他会问你computed和message

03:22.700 --> 03:24.700
有什么样的区别

03:24.700 --> 03:27.700
那么这种回答呢 他可能

03:27.700 --> 03:30.700
10个面试官可能有9.9个

03:30.700 --> 03:33.700
他认为你都应该回答出这么几个点

03:33.700 --> 03:35.700
那么我们来看一下这几个点

03:35.700 --> 03:37.700
标准而前线的回答

03:37.700 --> 03:39.700
网上一说 报数适合的回答

03:39.700 --> 03:41.700
就是computed作为计算属性

03:41.700 --> 03:43.700
message只能当成方法来调用 对吧

03:43.700 --> 03:46.700
我们能读取computed的时候

03:46.700 --> 03:48.700
把它当成属性来读的 你看

03:48.700 --> 03:50.700
这里有一个简单的例子

03:50.700 --> 03:52.700
就是一个first name 一个last name

03:52.700 --> 03:54.700
两个名字 然后呢 附货name

03:54.700 --> 03:57.700
是个计算属性 那么它是两个名字的拼接

03:57.700 --> 03:59.700
然后呢 他 我们知道计算属性

03:59.700 --> 04:01.700
它也能够复职 对它复职

04:01.700 --> 04:03.700
复职的时候呢 我就把这个复的值呢

04:03.700 --> 04:05.700
用空格分割

04:05.700 --> 04:07.700
左边的那个呢 就是first name

04:07.700 --> 04:08.700
右边的那个就是last name

04:08.700 --> 04:10.700
对吧 非常简单啊 我们来看一下吧

04:10.700 --> 04:12.700
这是拼接出来的 对吧

04:12.700 --> 04:14.700
first name last name 拼接出来的

04:14.700 --> 04:17.700
拼接出来的话 我给它可以复职

04:17.700 --> 04:22.700
复联 复职 复职为计算属性

04:22.700 --> 04:24.700
那么复职的时候呢 它会把这个值呢

04:24.700 --> 04:25.700
用空格来分割

04:25.700 --> 04:27.700
左边那一块呢 就给first name

04:27.700 --> 04:29.700
右边那一块呢 就给last name 你看

04:31.700 --> 04:33.700
对吧 非常简单 那么这样一复职呢

04:33.700 --> 04:34.700
它名字有变

04:34.700 --> 04:35.700
对吧 这是非常简单

04:35.700 --> 04:37.700
平时我们使用的时候呢

04:37.700 --> 04:38.700
没有任何问题

04:38.700 --> 04:40.700
然后这里有个修炼

04:40.700 --> 04:42.700
是否显示 它默认为趣

04:42.700 --> 04:44.700
然后呢 我点击这个按钮过后呢

04:44.700 --> 04:45.700
可以把它变成force

04:45.700 --> 04:47.700
再点击一下呢 右边变成趣

04:47.700 --> 04:49.700
那么这个 HE元数呢 它就会

04:49.700 --> 04:52.700
通过这个属性来决定 是否要显示

04:52.700 --> 04:53.700
这个非常简单

04:53.700 --> 04:55.700
对我们开发来讲的话

04:55.700 --> 04:58.700
你回这些东西就OK了 就完全OK了

04:58.700 --> 05:00.700
因此呢 我们再回答了什么呢

05:00.700 --> 05:02.700
就是计算属性呢 可以当成属性来使用

05:02.700 --> 05:05.700
你看 是不是当成属性来使用

05:05.700 --> 05:06.700
对吧 并不会有方法调用吧

05:06.700 --> 05:08.700
它不会这样子写吧

05:08.700 --> 05:10.700
对吧 好 这是这个 第一个区别

05:10.700 --> 05:12.700
第二个区别呢 它是带有getal and setal的

05:12.700 --> 05:14.700
因此呢 可以复职

05:16.700 --> 05:17.700
应该是复职

05:17.700 --> 05:18.700
就对计算属性呢

05:18.700 --> 05:19.700
我们刚才也看到啊

05:19.700 --> 05:20.700
我们是可以对它这个

05:20.700 --> 05:22.700
forlame来进行复职的

05:22.700 --> 05:24.700
而方法的时候 是不是不能复职啊

05:24.700 --> 05:26.700
对吧 方法你只能调用

05:26.700 --> 05:28.700
如果说forlame做成一个方法的话

05:28.700 --> 05:29.700
你是不是不能复职

05:29.700 --> 05:30.700
那都是一个区别

05:30.700 --> 05:31.700
然后computed呢

05:31.700 --> 05:33.700
它无法接收多个残数

05:33.700 --> 05:35.700
就是我们要读它的值的时候

05:35.700 --> 05:36.700
它没有残数啊

05:36.700 --> 05:38.700
getal是没有残数的

05:38.700 --> 05:40.700
所以说你没法给它传一个残数

05:40.700 --> 05:41.700
但是方法是不是可以

05:41.700 --> 05:42.700
调用方法的时候

05:42.700 --> 05:44.700
就可以传任意多个残数啊

05:44.700 --> 05:45.700
对不对

05:45.700 --> 05:47.700
然后呢 就是computed的具有缓存

05:47.700 --> 05:48.700
而方法没有

05:48.700 --> 05:49.700
就是说什么意思呢

05:49.700 --> 05:52.700
如果说我这里使用多个forlame的话

05:52.700 --> 05:53.700
那么这里的getal呢

05:53.700 --> 05:55.700
实际上只运行一次

05:55.700 --> 05:57.700
它是有缓存的

05:57.700 --> 05:58.700
而方法的话它不会有

05:58.700 --> 05:59.700
因为方法的话

05:59.700 --> 06:01.700
它会每一次在这里呢

06:01.700 --> 06:02.700
调用的时候

06:02.700 --> 06:03.700
它都会重新执行一次

06:03.700 --> 06:04.700
对吧

06:04.700 --> 06:05.700
所以说呢 这是计算属性

06:05.700 --> 06:06.700
跟方法的一些

06:06.700 --> 06:08.700
显而易见的区别

06:08.700 --> 06:10.700
那么你如果说你回答这样的话

06:10.700 --> 06:11.700
是肯定没问题的啊

06:11.700 --> 06:12.700
就是说你

06:12.700 --> 06:14.700
这节课听完了

06:14.700 --> 06:15.700
你如果说实在听不懂

06:15.700 --> 06:17.700
你至少能够回答出这么几个点

06:17.700 --> 06:18.700
这是入门阶段

06:18.700 --> 06:20.700
就应该能够回答出来了

06:20.700 --> 06:22.700
但是我还是希望大家能够

06:22.700 --> 06:23.700
去深入的回答

06:23.700 --> 06:24.700
因为我们要达到一个

06:24.700 --> 06:25.700
经验面试观众目的

06:25.700 --> 06:26.700
那你要深入的回答的话

06:26.700 --> 06:27.700
你就必须要去理解

06:27.700 --> 06:29.700
computed的深入的原理

06:29.700 --> 06:30.700
它到底是怎么回事

06:30.700 --> 06:32.700
那么我看一下下面的回答

06:32.700 --> 06:33.700
一边给大家看这个回答

06:33.700 --> 06:34.700
一边给大家讲解

06:34.700 --> 06:35.700
让大家理解

06:35.700 --> 06:37.700
更接近底层原理的回答

06:37.700 --> 06:38.700
那么这个回答里面

06:38.700 --> 06:40.700
就会解释computed的

06:40.700 --> 06:42.700
它到底是怎么做的

06:42.700 --> 06:43.700
它怎么做出来的

06:43.700 --> 06:45.700
其实有了前面的知识

06:45.700 --> 06:46.700
积累的过后

06:46.700 --> 06:47.700
你再看这个computed的

06:47.700 --> 06:48.700
其实并不难

06:48.700 --> 06:50.700
首先就要回答

06:50.700 --> 06:51.700
首先我们回答出来

06:51.700 --> 06:52.700
对message的处理

06:52.700 --> 06:53.700
message处理

06:53.700 --> 06:54.700
我们之前是不是讲过

06:54.700 --> 06:55.700
它特别特别的

06:55.700 --> 06:57.700
简单的不得了

06:57.700 --> 06:58.700
它怎么回事呢

06:58.700 --> 07:01.700
它就是去循环便利的配置

07:01.700 --> 07:03.700
你这里不是一个配置吗

07:03.700 --> 07:04.700
配置里边

07:04.700 --> 07:05.700
我们可以配置一些message

07:05.700 --> 07:07.700
它就循环便利的message里面

07:07.700 --> 07:08.700
所有属性

07:08.700 --> 07:10.700
比方说a这个方法

07:10.700 --> 07:13.700
然后b有一些参数

07:13.700 --> 07:14.700
一些方法

07:14.700 --> 07:16.700
它就循环便利的message里面

07:16.700 --> 07:17.700
每一个属性

07:17.700 --> 07:18.700
每一个属性是不是对应一个方式

07:18.700 --> 07:19.700
对吧

07:19.700 --> 07:21.700
它要做的事情特别特别简单

07:21.700 --> 07:22.700
它就把这个方式

07:22.700 --> 07:23.700
放到哪呢

07:23.700 --> 07:25.700
放到这个5u实例里边去了

07:25.700 --> 07:27.700
你看ab

07:27.700 --> 07:29.700
放到实例里边去过后

07:29.700 --> 07:30.700
然后把对应的方式

07:30.700 --> 07:32.700
使用一个方法叫band

07:33.700 --> 07:34.700
使用这个方法吧

07:34.700 --> 07:35.700
是绑定z

07:35.700 --> 07:36.700
把z绑定为谁

07:36.700 --> 07:38.700
绑定为这个组件实例

07:38.700 --> 07:39.700
就完事了

07:39.700 --> 07:41.700
它没有什么特别的

07:41.700 --> 07:43.700
所以说你先把message的处理

07:43.700 --> 07:44.700
给它回答出来

07:44.700 --> 07:45.700
因为message的处理

07:45.700 --> 07:48.700
跟compute的处理是不一样的

07:48.700 --> 07:49.700
对message的处理非常简单

07:49.700 --> 07:51.700
只要便利它的每一个属性

07:51.700 --> 07:53.700
将其每一个属性对应的函数

07:53.700 --> 07:54.700
使用band

07:54.700 --> 07:55.700
绑定当前组件实例

07:55.700 --> 07:57.700
那么就这样子的函数里面的z

07:57.700 --> 07:59.700
始终指向当前组件实例

07:59.700 --> 08:02.700
然后复制引用

08:02.700 --> 08:04.700
复制函数的引用到组件实例中

08:04.700 --> 08:05.700
那么组件实例里面

08:05.700 --> 08:07.700
是不是可以通过a和b

08:07.700 --> 08:08.700
直接拿到这个方法

08:08.700 --> 08:10.700
这个方法来绑定z的

08:10.700 --> 08:14.700
那么这是对message的处理

08:14.700 --> 08:16.700
好 接下来就开始回答

08:16.700 --> 08:17.700
对computed的处理

08:17.700 --> 08:18.700
那么它会稍微复杂一点

08:18.700 --> 08:20.700
我们看它怎么来处理的

08:20.700 --> 08:22.700
首先回答时间

08:22.700 --> 08:24.700
对computed的处理

08:24.700 --> 08:25.700
是什么时候处理的

08:25.700 --> 08:26.700
什么时候呢

08:26.700 --> 08:28.700
就是出发生命周期勾字函数

08:28.700 --> 08:29.700
before create

08:29.700 --> 08:30.700
之前我们讲生命周期

08:30.700 --> 08:31.700
是不是讲了

08:31.700 --> 08:32.700
before create过后

08:32.700 --> 08:33.700
是不是要处理大的东西

08:33.700 --> 08:34.700
处理data

08:34.700 --> 08:35.700
变成享用式

08:35.700 --> 08:37.700
还要处理computed

08:37.700 --> 08:38.700
它会做一系列的事情

08:38.700 --> 08:39.700
其中就包含了

08:39.700 --> 08:41.700
对computed的处理

08:41.700 --> 08:43.700
那么它到底是怎么处理的呢

08:43.700 --> 08:44.700
我们来看

08:44.700 --> 08:46.700
它会遍地computed的配置中的

08:46.700 --> 08:47.700
所有属性

08:47.700 --> 08:48.700
因为我们computed里面

08:48.700 --> 08:49.700
是不是配置很多的

08:49.700 --> 08:50.700
很多的计算属性

08:50.700 --> 08:52.700
它会一个一个遍地

08:52.700 --> 08:54.700
那么拿到每一个属性过后

08:54.700 --> 08:55.700
它会做什么事呢

08:55.700 --> 08:56.700
对每一个属性

08:56.700 --> 08:58.700
创建一个watcher对象

08:58.700 --> 09:00.700
你看这个watcher到处会用

09:01.700 --> 09:02.700
watcher

09:02.700 --> 09:03.700
到一个属性

09:03.700 --> 09:05.700
比方说我们这里一个four name

09:05.700 --> 09:07.700
它就对应一个watcher

09:07.700 --> 09:08.700
我们怎么来知道这一点的

09:08.700 --> 09:09.700
其实我们可以

09:09.700 --> 09:10.700
我这里打印出来的这个

09:10.700 --> 09:12.700
主建实力

09:12.700 --> 09:13.700
这个五佑实力

09:13.700 --> 09:14.700
其实本质上就是个主建实力

09:14.700 --> 09:15.700
你看

09:15.700 --> 09:16.700
我们打印出来的这个vm

09:16.700 --> 09:18.700
我们来看一下这个vm里面

09:18.700 --> 09:19.700
其实有东西的

09:19.700 --> 09:20.700
往下找

09:20.700 --> 09:22.700
找这个computed watchers

09:22.700 --> 09:23.700
看到没

09:23.700 --> 09:24.700
这里保存的是什么呢

09:24.700 --> 09:25.700
保存就是

09:25.700 --> 09:26.700
每一个计算属性的watcher

09:26.700 --> 09:27.700
你看

09:27.700 --> 09:28.700
four name是不是一个watcher

09:28.700 --> 09:29.700
还记得吗

09:29.700 --> 09:31.700
watcher用来干嘛的

09:31.700 --> 09:33.700
它用来干嘛的呀

09:33.700 --> 09:35.700
它是不是就是来

09:35.700 --> 09:36.700
传一个函数进去

09:36.700 --> 09:37.700
对吧

09:37.700 --> 09:38.700
执行那个函数

09:38.700 --> 09:39.700
收集依赖

09:39.700 --> 09:40.700
然后只要依赖一遍

09:40.700 --> 09:42.700
是不是就会重新执行

09:42.700 --> 09:43.700
这个函数

09:43.700 --> 09:44.700
对不对

09:44.700 --> 09:45.700
就这么简单

09:45.700 --> 09:46.700
这个watcher

09:46.700 --> 09:47.700
像我们之前的Render

09:47.700 --> 09:48.700
不就是

09:48.700 --> 09:49.700
放在watcher里面对吧

09:49.700 --> 09:50.700
对不对

09:51.700 --> 09:52.700
它会为每一个计算属性

09:52.700 --> 09:54.700
创建一个watcher

09:54.700 --> 09:56.700
并且它会传入一个函数

09:56.700 --> 09:57.700
这个函数呢

09:57.700 --> 09:58.700
会收集依赖

09:58.700 --> 09:59.700
那么这个函数

09:59.700 --> 10:00.700
是什么东西呢

10:00.700 --> 10:01.700
什么东西会传进去呢

10:01.700 --> 10:02.700
其实就是getter

10:02.700 --> 10:04.700
就是我们配置的getter函数

10:04.700 --> 10:06.700
就这个函数

10:06.700 --> 10:07.700
不是set

10:07.700 --> 10:08.700
set不管

10:08.700 --> 10:09.700
就这个getter函数

10:09.700 --> 10:10.700
它会传进去

10:10.700 --> 10:11.700
有这个函

10:11.700 --> 10:12.700
其实我们看它本质

10:12.700 --> 10:13.700
就是把这个函数

10:13.700 --> 10:14.700
传到watcher里面

10:14.700 --> 10:15.700
那么你想

10:15.700 --> 10:17.700
以运行的getter函数

10:17.700 --> 10:19.700
是不是就收集到依赖

10:19.700 --> 10:20.700
那么就会

10:20.700 --> 10:21.700
first name

10:21.700 --> 10:22.700
和last name

10:22.700 --> 10:23.700
他们都会记录

10:23.700 --> 10:24.700
有一个watcher在用

10:24.700 --> 10:25.700
哪个watcher呢

10:25.700 --> 10:26.700
就是这个计算属性的watcher

10:26.700 --> 10:27.700
那么于是有一天

10:27.700 --> 10:29.700
当这两个属性变化的时候

10:29.700 --> 10:31.700
是不会重新运行这个watcher

10:31.700 --> 10:32.700
就这么简单

10:32.700 --> 10:33.700
咱们又来看

10:33.700 --> 10:35.700
继续看

10:35.700 --> 10:38.700
那么它又要怎么处理的

10:38.700 --> 10:41.700
但是这里有一点不一样了

10:41.700 --> 10:42.700
这个watcher函数

10:42.700 --> 10:43.700
功能非常强大

10:43.700 --> 10:45.700
我们不分心圆满的话

10:45.700 --> 10:46.700
也不会详细的来说它

10:46.700 --> 10:48.700
但是我这里给它介绍一下

10:48.700 --> 10:49.700
给它介绍一下

10:49.700 --> 10:52.700
和宣传函数不一样

10:52.700 --> 10:54.700
我们为计算属性

10:54.700 --> 10:55.700
创建的watcher

10:55.700 --> 10:56.700
它不会立即执行

10:56.700 --> 10:57.700
就是它里边挂了一个什么呢

10:57.700 --> 10:59.700
挂了一个getter

10:59.700 --> 11:00.700
getter函数

11:00.700 --> 11:02.700
它不会立即执行的

11:02.700 --> 11:03.700
因为我们render的函数

11:03.700 --> 11:05.700
就是我们之前讲的

11:05.700 --> 11:06.700
updates component

11:06.700 --> 11:07.700
那个函数

11:07.700 --> 11:08.700
传到watcher里面

11:08.700 --> 11:10.700
就是更新主线的

11:10.700 --> 11:11.700
它会立即执行

11:11.700 --> 11:13.700
来对主线进行第一次宣传

11:13.700 --> 11:15.700
然后同时收集依赖

11:15.700 --> 11:16.700
但是watcher函数

11:16.700 --> 11:19.700
它并不会立即执行

11:19.700 --> 11:20.700
并不会

11:20.700 --> 11:21.700
有些同学说

11:21.700 --> 11:22.700
那不对呀

11:22.700 --> 11:25.700
那我这里看到了getter函数

11:26.700 --> 11:27.700
输出一下

11:28.700 --> 11:29.700
我这里看到getter

11:29.700 --> 11:30.700
不是立即执行的吗

11:30.700 --> 11:31.700
那是因为

11:31.700 --> 11:33.700
我们模板里面用到了它

11:33.700 --> 11:34.700
如果说我们模板里面

11:34.700 --> 11:35.700
没有在它

11:35.700 --> 11:36.700
你看一下会不会执行

11:36.700 --> 11:37.700
所以不会执行

11:37.700 --> 11:38.700
那不会执行

11:38.700 --> 11:39.700
这个watcher有没有创建

11:39.700 --> 11:40.700
我们看一下

11:40.700 --> 11:41.700
你看watcher

11:41.700 --> 11:42.700
是不是还是创建的

11:42.700 --> 11:43.700
所以这个watcher里面

11:43.700 --> 11:45.700
函数它不是立即执行的

11:45.700 --> 11:46.700
那么它到底是怎么执行的

11:46.700 --> 11:47.700
我们马上来说

11:47.700 --> 11:49.700
它不会立即执行

11:49.700 --> 11:50.700
因为它要考虑到

11:50.700 --> 11:51.700
一个计算属性

11:51.700 --> 11:53.700
是不是在模板里面用到了

11:53.700 --> 11:54.700
如果说模板里面

11:54.700 --> 11:55.700
没有用到的话

11:55.700 --> 11:56.700
它就不会执行

11:56.700 --> 11:57.700
就在渲染函数里面

11:57.700 --> 11:58.700
模板其实就在渲染函数里面

11:58.700 --> 11:59.700
对吧

11:59.700 --> 12:00.700
轮到函数里面

12:00.700 --> 12:01.700
没有用到

12:01.700 --> 12:02.700
它就不会执行

12:02.700 --> 12:03.700
它是用到的时候再执行

12:03.700 --> 12:05.700
并不是一开始有执行一次

12:05.700 --> 12:06.700
这个东西是跟渲染函数

12:06.700 --> 12:07.700
不一样的

12:07.700 --> 12:09.700
这个点你可以把它回答出来

12:10.700 --> 12:12.700
它为什么没有立即执行呢

12:12.700 --> 12:13.700
是因为它在

12:13.700 --> 12:14.700
创建watcher的时候

12:14.700 --> 12:15.700
watcher里面有个配置

12:15.700 --> 12:16.700
叫做lessie

12:16.700 --> 12:17.700
你是不是

12:17.700 --> 12:19.700
懒家在的意思

12:19.700 --> 12:20.700
偷懒的意思

12:20.700 --> 12:21.700
也叫做延迟

12:21.700 --> 12:23.700
它把它设置为q

12:23.700 --> 12:24.700
于是

12:24.700 --> 12:26.700
它由于受它的影响

12:26.700 --> 12:27.700
这个watcher不会立即执行

12:27.700 --> 12:28.700
我们来对比一下

12:28.700 --> 12:30.700
我们的组建里面有一个watcher

12:30.700 --> 12:32.700
这个就是渲染函数

12:32.700 --> 12:36.080
你看它的lessie

12:39.080 --> 12:40.080
less is force

12:40.080 --> 12:41.080
对吧

12:41.080 --> 12:42.080
渲染函数的less is force

12:42.080 --> 12:43.080
就是渲染函数

12:43.080 --> 12:45.080
它不是延迟执行的

12:45.080 --> 12:47.080
它是立即执行的

12:47.080 --> 12:49.080
但是我们这个watcher

12:49.080 --> 12:50.080
我们这个watcher

12:50.080 --> 12:52.080
就是计算属性里面的watcher

12:52.080 --> 12:53.080
你看一下

12:53.080 --> 12:54.080
lessie

12:54.080 --> 12:55.080
是不是为q

12:55.080 --> 12:57.080
说明它是延迟执行的

12:57.080 --> 12:58.080
它并不是立即执行的

12:58.080 --> 13:00.080
那么它什么时候执行的

13:00.080 --> 13:01.080
不着急

13:01.080 --> 13:02.080
看着啊

13:03.080 --> 13:04.080
好

13:04.080 --> 13:05.080
那么接下来有两个关键点

13:05.080 --> 13:06.080
非常非常关键的点

13:06.080 --> 13:07.080
这关键点一开始

13:07.080 --> 13:08.080
可能不是很那么好理解

13:08.080 --> 13:09.080
以后我们看完了之后

13:09.080 --> 13:10.080
你就会理解了

13:10.080 --> 13:12.080
当你把这个lessie

13:12.080 --> 13:13.080
设为q的时候

13:13.080 --> 13:14.080
就是这个watcher

13:14.080 --> 13:15.080
lessie设为q的时候

13:15.080 --> 13:16.080
watcher内部

13:16.080 --> 13:17.080
会保存两个

13:17.080 --> 13:18.080
非常关键的属性

13:18.080 --> 13:19.080
来实现这个缓存

13:19.080 --> 13:20.080
也就是我现在要解释

13:20.080 --> 13:22.080
计算属性的缓存

13:22.080 --> 13:23.080
是怎么实现的

13:23.080 --> 13:24.080
它里面会设置到

13:24.080 --> 13:25.080
两个核心的属性

13:25.080 --> 13:27.080
一个是value

13:27.080 --> 13:29.080
一个是dirty

13:31.080 --> 13:32.080
我们来看一下这两个属性

13:32.080 --> 13:34.080
value属性来保存什么呢

13:34.080 --> 13:35.080
value属性保存

13:35.080 --> 13:36.080
就是个getter函数

13:36.080 --> 13:37.080
运行的结果

13:38.080 --> 13:39.080
那么由于这个计算属性

13:39.080 --> 13:41.080
一开始并没有执行这个getter

13:41.080 --> 13:42.080
延迟执行吧

13:42.080 --> 13:43.080
所以这个value属性

13:43.080 --> 13:44.080
一开始是什么呢

13:44.080 --> 13:45.080
一开始是undefend

13:46.080 --> 13:48.080
最开始是undefend

13:48.080 --> 13:50.080
然后呢

13:50.080 --> 13:51.080
你看啊

13:51.080 --> 13:52.080
我们给它演示一下

13:52.080 --> 13:53.080
如果说没有用这个

13:53.080 --> 13:54.080
计算属性

13:54.080 --> 13:55.080
你看一下

13:55.080 --> 13:57.080
看一下这个value

13:58.080 --> 14:00.080
在computer的地方

14:00.080 --> 14:01.080
watcher

14:02.080 --> 14:03.080
它里面一个value属性

14:03.080 --> 14:04.080
你看 是不是undefend

14:04.080 --> 14:06.080
一开始没有执行

14:06.080 --> 14:07.080
当然后来就执行了

14:07.080 --> 14:09.080
我们一会来看

14:09.080 --> 14:10.080
另外一个属性叫dirty

14:10.080 --> 14:12.080
dirty是什么意思呢

14:12.080 --> 14:13.080
它表示的是

14:13.080 --> 14:15.080
当前这个value

14:15.080 --> 14:17.080
是不是一个张值

14:17.080 --> 14:18.080
就是这个value

14:18.080 --> 14:19.080
有没有过时

14:19.080 --> 14:21.080
那么dirty现在的

14:21.080 --> 14:22.080
值是什么呢

14:22.080 --> 14:24.080
你想一想一个道理

14:24.080 --> 14:25.080
张值就是过时的意思

14:25.080 --> 14:27.080
就是它已经不是一个

14:27.080 --> 14:28.080
正确的值了

14:28.080 --> 14:29.080
就是张值

14:29.080 --> 14:31.080
还是之前的值

14:31.080 --> 14:32.080
那么现在这个value

14:32.080 --> 14:33.080
是不是之前的值了

14:33.080 --> 14:34.080
是不是张值了

14:34.080 --> 14:35.080
为什么

14:35.080 --> 14:36.080
因为value目前的值

14:36.080 --> 14:37.080
是undefend的

14:37.080 --> 14:39.080
但它本来应该的值是什么

14:39.080 --> 14:40.080
应该的值是什么

14:40.080 --> 14:42.080
first name加上last name

14:42.080 --> 14:43.080
而first name加上last name

14:43.080 --> 14:44.080
应该等于什么

14:44.080 --> 14:45.080
远近 对吧

14:45.080 --> 14:46.080
是不是它应该的值

14:46.080 --> 14:47.080
应该是远近

14:47.080 --> 14:48.080
但是它目前的值

14:48.080 --> 14:49.080
是undefend的

14:49.080 --> 14:50.080
一开始的时候

14:50.080 --> 14:52.080
dirty为true

14:52.080 --> 14:54.080
表示目前有问题的值

14:54.080 --> 14:56.080
是有问题的

14:56.080 --> 14:57.080
接下来我们继续看

14:57.080 --> 14:58.080
把这两个属性体验清楚

14:58.080 --> 15:00.080
你看它怎么在操作的

15:00.080 --> 15:02.080
然后watcher创建好了之后

15:02.080 --> 15:04.080
伍佑会使用代理模式

15:04.080 --> 15:07.080
将计算属性挂载到属键实力地板

15:07.080 --> 15:08.080
代理模式我们知道

15:08.080 --> 15:11.080
就是一个object

15:11.080 --> 15:15.080
defend property

15:15.080 --> 15:17.080
然后哪个对象

15:18.080 --> 15:20.080
当前的组建实力

15:20.080 --> 15:21.080
然后哪个属性

15:21.080 --> 15:23.080
for name这个属性

15:23.080 --> 15:25.080
当这个属性运行get的时候

15:25.080 --> 15:27.080
它会怎么样

15:27.080 --> 15:29.080
get的时候

15:29.080 --> 15:30.080
它会运行什么

15:30.080 --> 15:32.080
它会运行watcher

15:32.080 --> 15:34.080
其实这里还要做一些事情

15:34.080 --> 15:37.080
那么最终肯定是要运行watcher

15:37.080 --> 15:39.080
运行watcher

15:39.080 --> 15:40.080
那么它到底要不要运行watcher

15:40.080 --> 15:42.080
我们一会再说

15:42.080 --> 15:43.080
好

15:43.080 --> 15:44.080
当我们读取

15:44.080 --> 15:46.080
那么这样子就是形成代理

15:46.080 --> 15:47.080
就是我们访问

15:47.080 --> 15:49.080
组建实力里面的for name

15:49.080 --> 15:50.080
实际上就访问到了什么

15:50.080 --> 15:52.080
访问到watcher

15:52.080 --> 15:54.080
好,我们来看

15:54.080 --> 15:56.080
当我们读取计算属性的时候

15:56.080 --> 16:00.080
伍佑首先会检查watcher是否是章指

16:03.080 --> 16:05.080
它怎么做的,它就在这里get

16:05.080 --> 16:06.080
get的时候干嘛

16:06.080 --> 16:10.080
它首先判断一下watcher

16:10.080 --> 16:11.080
dirty

16:11.080 --> 16:13.080
是不是v2

16:13.080 --> 16:15.080
判断dirty是不是v2

16:15.080 --> 16:16.080
维修说明什么

16:16.080 --> 16:18.080
维修说明目前这个计算属性

16:18.080 --> 16:20.080
目前的值是有问题的

16:20.080 --> 16:22.080
所以有问题on the side

16:22.080 --> 16:25.080
有问题的时候是不是要重新计算

16:25.080 --> 16:28.080
因此如果说它是章指的话

16:28.080 --> 16:31.080
那么就会运行watcher重新计算

16:31.080 --> 16:33.080
那么重新一计算理想一下

16:33.080 --> 16:35.080
重新一计算是不是

16:35.080 --> 16:37.080
就会运行get

16:37.080 --> 16:40.080
来,我们来看一下这个过程

16:40.080 --> 16:42.080
目前计算属性是这个样子的

16:43.080 --> 16:45.080
放下好了,然后我们来渲染模板

16:45.080 --> 16:47.080
渲染模板的时候是不是就遇到了那个计算属性

16:47.080 --> 16:48.080
你用到那个计算属性

16:48.080 --> 16:51.080
是不是就相当于是运行到这里的get

16:51.080 --> 16:53.080
运行到这里的get

16:53.080 --> 16:54.080
因为我们的计算属面在哪里

16:54.080 --> 16:55.080
在图件实地里面

16:55.080 --> 16:57.080
就相当于运行到这里的get

16:57.080 --> 16:59.080
而以运行这里的get就相当于

16:59.080 --> 17:00.080
就会怎么样了

17:00.080 --> 17:02.080
以运行这里的get

17:02.080 --> 17:04.080
是不是就一开始它是dirty

17:04.080 --> 17:06.080
维修,是不是就章指

17:06.080 --> 17:08.080
那么这个时候是不是就会执行watcher

17:08.080 --> 17:11.080
执行watcher就是相当于是执行get

17:11.080 --> 17:13.080
而这里一执行get会怎么样呢

17:13.080 --> 17:15.080
是不是就输出get

17:15.080 --> 17:18.080
然后呢,使用到了属性first name

17:18.080 --> 17:20.080
和last name

17:20.080 --> 17:22.080
那么这里就会发生这么几件事情

17:22.080 --> 17:24.080
第一件事情,搜集一代

17:24.080 --> 17:26.080
这个时候复活那边是不是运行了

17:26.080 --> 17:27.080
get就运行了

17:27.080 --> 17:29.080
那么get它就会搜集一代

17:30.080 --> 17:32.080
那么我们看一下first name

17:32.080 --> 17:36.840
和last name

17:36.840 --> 17:38.840
它们就有两个一代

17:38.840 --> 17:40.840
至少有一个一代

17:40.840 --> 17:41.840
打个一代的

17:41.840 --> 17:47.620
就是我们计算属性的watcher

17:47.620 --> 17:48.620
我们知道

17:48.620 --> 17:49.620
每个属性它都会搜集一代

17:49.620 --> 17:50.620
是谁在用我

17:50.620 --> 17:52.620
那么last name是不是会搜集到一个一代

17:52.620 --> 17:57.620
就是也是计算属性的watcher

17:57.620 --> 18:00.620
对不对,会搜集到这个一代

18:00.620 --> 18:03.620
你看这是进行一代搜集

18:03.620 --> 18:04.620
一代搜集完了过后

18:04.620 --> 18:06.620
接下来就把两个东西运行出来了

18:06.620 --> 18:08.620
两个一拼接是不是就远近

18:08.620 --> 18:10.620
于是这个value值就变成这个样子了

18:10.620 --> 18:12.620
它又会重新更新这个value值

18:12.620 --> 18:16.620
变成远近

18:16.620 --> 18:18.620
dirty它就会把它设为force

18:18.620 --> 18:19.620
它不再是张子的

18:19.620 --> 18:21.620
目前就是已经是正确的事了

18:21.620 --> 18:23.620
远着意思吧

18:23.620 --> 18:24.620
那么这样子

18:24.620 --> 18:26.620
就把复活那边的是不是显示到这了

18:26.620 --> 18:27.620
同时又搜集好了一代

18:27.620 --> 18:29.620
同时又不再是张子了

18:29.620 --> 18:31.620
这是第一次夹载的时候

18:31.620 --> 18:33.620
我们来看一下

18:33.620 --> 18:35.620
你看这里我怎么说的

18:35.620 --> 18:38.620
当我们读取计算属性的时候

18:38.620 --> 18:39.620
在哪里读取的

18:39.620 --> 18:41.620
当然也可以在其他地方读取

18:41.620 --> 18:42.620
只要你用到了

18:42.620 --> 18:44.620
那么唯有就会检查起对应的watcher

18:44.620 --> 18:45.620
是否是张子

18:45.620 --> 18:46.620
刚才是张子对吧

18:46.620 --> 18:47.620
如果是

18:47.620 --> 18:48.620
它就会运行的get韩数

18:48.620 --> 18:50.620
以运行是不是就计算一代了

18:50.620 --> 18:51.620
就搜集到了一代了

18:51.620 --> 18:53.620
一代就搜集些了

18:53.620 --> 18:54.620
并且得到对应的值

18:54.620 --> 18:56.620
对应的值是不是就拿到了远近

18:56.620 --> 18:57.620
它会保存在

18:57.620 --> 18:59.620
把这个值保存在watcher的value里边

18:59.620 --> 19:01.620
同时设置dirty为force

19:01.620 --> 19:02.620
不再是张子了

19:02.620 --> 19:03.620
然后把这个值返回

19:03.620 --> 19:04.620
返回的时候计算

19:04.620 --> 19:06.620
五万里面是不是就看到了远近

19:06.620 --> 19:08.620
对不对

19:08.620 --> 19:11.620
就这么个意思

19:11.620 --> 19:13.620
这里有一个巧妙点

19:13.620 --> 19:15.620
这个巧妙点我不大詳细的讲了

19:15.620 --> 19:17.620
因为这里边要说一道别拉分析了

19:17.620 --> 19:19.620
它在搜集依赖的时候

19:19.620 --> 19:20.620
它其实依赖的数据

19:20.620 --> 19:23.620
不仅会搜集到计算属性的watcher

19:23.620 --> 19:26.620
它还会搜集到组建的watcher

19:26.620 --> 19:31.190
组建的渲染韩数的watcher

19:31.190 --> 19:32.190
你看着

19:32.190 --> 19:33.190
它为什么要这样说

19:33.190 --> 19:34.190
一会就明白了

19:34.190 --> 19:36.190
它会搜集到两个watcher

19:36.190 --> 19:37.190
一个是计算属性的watcher

19:37.190 --> 19:38.190
一个是组建的watcher

19:38.190 --> 19:39.190
也就是这两个属性变化的时候

19:39.190 --> 19:42.190
它不仅会重新运行这个watcher

19:42.190 --> 19:45.190
还会运行这个watcher

19:45.190 --> 19:46.190
没了意思吧

19:46.190 --> 19:48.190
好 来看

19:48.190 --> 19:49.190
接下来我们来看一下

19:49.190 --> 19:50.190
这个属性变化的时候

19:50.190 --> 19:52.190
当属性的一代变化的时候

19:52.190 --> 19:57.190
它会首先触发watcher的执行

19:57.190 --> 19:59.190
那么首先触发

19:59.190 --> 20:06.580
那个计算属性的watcher执行

20:06.580 --> 20:08.580
它会触发这个watcher的执行

20:08.580 --> 20:09.580
那么我们来看一下

20:09.580 --> 20:11.580
比方说我现在给它做一件事

20:11.580 --> 20:14.580
一件first name变化

20:14.580 --> 20:18.580
变成abc

20:18.580 --> 20:19.580
这样子一回车

20:19.580 --> 20:20.580
是不是这个东西变了

20:20.580 --> 20:21.580
first name变了

20:21.580 --> 20:23.580
那么它会首先触发这个watcher的执行

20:23.580 --> 20:25.580
那么这个watcher做的事情是什么呢

20:25.580 --> 20:28.580
做的事情特别特别简单

20:28.580 --> 20:30.580
它就把dirty社围出

20:30.580 --> 20:31.580
没了

20:31.580 --> 20:33.580
它就把dirty社围出

20:33.580 --> 20:35.580
其他一件事都不做

20:35.580 --> 20:36.580
你看

20:36.580 --> 20:37.580
虽然我们最终见面改变的

20:37.580 --> 20:38.580
但是呢

20:38.580 --> 20:39.580
实际上它最开始的时候

20:39.580 --> 20:42.580
是只是把它dirty社围去

20:42.580 --> 20:43.580
dirty社围去过后

20:43.580 --> 20:44.580
这个watcher是不是执行完了

20:44.580 --> 20:45.580
就执行完了

20:45.580 --> 20:48.580
然后再执行组建的watcher

20:48.580 --> 20:50.580
组建watcher是不是重新渲染界面

20:50.580 --> 20:51.580
你想一想

20:51.580 --> 20:52.580
由于依赖的时候

20:52.580 --> 20:54.580
它同时收集到组建的watcher

20:54.580 --> 20:56.580
因此组建会重新渲染

20:56.580 --> 20:58.580
而重新渲染的时候

20:58.580 --> 20:59.580
又读到了计算属性

20:59.580 --> 21:00.580
你看

21:00.580 --> 21:01.580
重新一渲染的时候

21:01.580 --> 21:02.580
它是不是这里

21:02.580 --> 21:04.580
又在用计算属性了

21:04.580 --> 21:05.580
而用计算属性的时候

21:05.580 --> 21:06.580
刚才是怎么说的

21:06.580 --> 21:07.580
流程是什么

21:07.580 --> 21:09.580
用计算属性的时候

21:09.580 --> 21:12.580
它会检查watcher是不是脏脂

21:12.580 --> 21:14.580
现在是不是又变成脏脂了

21:14.580 --> 21:15.580
如果是

21:15.580 --> 21:17.580
是不是又重新运行的gatter函数

21:17.580 --> 21:19.580
并得到对应的值

21:19.580 --> 21:21.580
又得到这个abc

21:21.580 --> 21:22.580
得到对应的值

21:22.580 --> 21:24.580
计算依赖又重新计算依赖

21:24.580 --> 21:25.580
当然依赖是一样的

21:25.580 --> 21:26.580
还是用到了first level

21:26.580 --> 21:27.580
很大实内

21:27.580 --> 21:28.580
并得到对应的值

21:28.580 --> 21:29.580
然后保存在value里边

21:29.580 --> 21:30.580
然后把它设为force

21:30.580 --> 21:31.580
然后返回

21:31.580 --> 21:32.580
一返回

21:32.580 --> 21:33.580
那么见面上是不是

21:33.580 --> 21:34.580
选了abc进了

21:34.580 --> 21:35.580
对不对

21:35.580 --> 21:37.580
它是这么来做的

21:37.580 --> 21:38.580
它分成两步

21:38.580 --> 21:39.580
第一步呢

21:39.580 --> 21:40.580
计算属性的watcher

21:40.580 --> 21:41.580
直接把它张纸设为shoot

21:41.580 --> 21:43.580
实际上啥都不做

21:43.580 --> 21:45.580
主键的watcher在用到的时候

21:45.580 --> 21:46.580
他发现已经是张纸了

21:46.580 --> 21:48.580
然后再重新计算

21:48.580 --> 21:49.580
对不对

21:49.580 --> 21:50.580
就这么个意思

21:50.580 --> 21:51.580
那如果说

21:51.580 --> 21:52.580
我们主键里边用到了

21:52.580 --> 21:54.580
很多次forlame的

21:54.580 --> 21:55.580
那么你看

21:55.580 --> 21:56.580
在主键的渲染的模板中

21:56.580 --> 21:57.580
一开始

21:57.580 --> 22:01.400
我们看最开始的情况

22:01.400 --> 22:02.400
最开始的情况

22:02.400 --> 22:04.400
第一次用到forlame

22:04.400 --> 22:06.400
第一次用到的时候

22:06.400 --> 22:07.400
他发现是张纸

22:07.400 --> 22:08.400
于是要算

22:08.400 --> 22:09.400
算出来了过后

22:09.400 --> 22:10.400
有了一代

22:10.400 --> 22:11.400
同时这里变成了远近

22:11.400 --> 22:13.400
然后变成了force

22:13.400 --> 22:15.400
如果说他发现不是张纸

22:15.400 --> 22:16.400
第二次在用的时候

22:16.400 --> 22:18.400
他发现已经不是张纸了

22:18.400 --> 22:19.400
他就不会再运行这个get了

22:19.400 --> 22:20.400
不会再算了

22:20.400 --> 22:22.400
而是直接返回

22:22.400 --> 22:23.400
他的value

22:23.400 --> 22:24.400
它是这么来做

22:24.400 --> 22:25.400
换成的

22:25.400 --> 22:26.400
所以这个get了

22:26.400 --> 22:27.400
它只运行了一次

22:27.400 --> 22:28.400
就这个原因

22:28.400 --> 22:29.400
所以说这里

22:29.400 --> 22:30.400
我们再把它写完上一点

22:30.400 --> 22:31.400
就是

22:33.400 --> 22:35.400
如果不是张纸

22:37.400 --> 22:38.400
如果

22:38.400 --> 22:39.400
dirty

22:39.400 --> 22:40.400
为force

22:40.400 --> 22:43.400
则直接返回

22:43.400 --> 22:44.400
value

22:44.400 --> 22:45.400
忘记了value

22:46.400 --> 22:47.400
写完吧

22:47.400 --> 22:48.400
忘记了value

22:49.400 --> 22:50.400
OK

22:50.400 --> 22:52.400
它就是这么来做的

22:53.400 --> 22:55.400
那么对于setter

22:55.400 --> 22:57.400
setter的这个函数

22:57.400 --> 22:58.400
就是我们计算属性里面

22:58.400 --> 22:59.400
可能会有setter

22:59.400 --> 23:01.400
setter其实特别简单

23:01.400 --> 23:02.400
简单的不得了

23:02.400 --> 23:03.400
它就是

23:03.400 --> 23:05.400
在受制计算属性的时候

23:05.400 --> 23:06.400
直接运行setter

23:06.400 --> 23:07.400
就完事了

23:07.400 --> 23:08.400
也就是这么的意思呢

23:08.400 --> 23:09.400
就是我们

23:09.400 --> 23:10.400
当然不是一个代理模式

23:10.400 --> 23:11.400
对吧

23:11.400 --> 23:12.400
define property

23:13.400 --> 23:14.400
property

23:14.400 --> 23:15.400
里面

23:16.400 --> 23:18.400
不是一个get和set

23:18.400 --> 23:19.400
对不对

23:19.400 --> 23:21.900
get函数

23:21.900 --> 23:22.900
跟着函数就是

23:22.900 --> 23:23.900
刚才我们说的那个流程

23:23.900 --> 23:25.900
那么set函数呢

23:26.900 --> 23:27.900
它就直接调用

23:27.900 --> 23:28.900
你配置的这个set函数

23:28.900 --> 23:29.900
就完事了

23:29.900 --> 23:31.900
set函数是特别简单的

23:31.900 --> 23:32.900
直接调用

23:32.900 --> 23:35.900
你配置的setter

23:36.900 --> 23:37.900
为什么呢

23:37.900 --> 23:39.900
因为你一旦去设置它的时候

23:39.900 --> 23:40.900
是不是

23:40.900 --> 23:41.900
运行这个函数

23:41.900 --> 23:42.900
这个函数呢

23:42.900 --> 23:43.900
就相当于是给它重新复制的

23:43.900 --> 23:44.900
重新复制是不是

23:44.900 --> 23:45.900
一旦变化

23:45.900 --> 23:46.900
一旦变化是不是

23:46.900 --> 23:47.900
又来了啊

23:47.900 --> 23:48.900
首先把它设为q

23:48.900 --> 23:49.900
对不对

23:49.900 --> 23:51.900
一设为q过后呢

23:51.900 --> 23:52.900
就先运行这个一把设为q

23:52.900 --> 23:53.900
然后再运行

23:53.900 --> 23:54.900
主线的watcher

23:54.900 --> 23:55.900
那么主线重新渲染

23:55.900 --> 23:56.900
重新渲染

23:56.900 --> 23:57.900
是不是就发现

23:57.900 --> 23:58.900
它的dirty為q

23:58.900 --> 23:59.900
用到了时候呢

23:59.900 --> 24:01.900
就把它更改一个新的值了

24:01.900 --> 24:02.900
就这么个意思

24:02.900 --> 24:03.900
好

24:03.900 --> 24:04.900
我们再来看个例子

24:04.900 --> 24:05.900
其实我就讲完了

24:05.900 --> 24:06.900
我们再来看一个例子

24:06.900 --> 24:07.900
这里有点少

24:08.900 --> 24:10.900
如果说我在介面是这样的写的

24:10.900 --> 24:11.900
刚才我们看到这里

24:12.900 --> 24:13.900
那么现在呢

24:13.900 --> 24:14.900
我看一下

24:14.900 --> 24:15.900
给它看一下这个点

24:15.900 --> 24:16.900
目前运行的意思

24:16.900 --> 24:17.900
为什么主件用到这个

24:17.900 --> 24:19.900
用到这个计算属性

24:19.900 --> 24:20.900
对吧

24:20.900 --> 24:21.900
用到一个计算属性

24:21.900 --> 24:22.900
发现它一开始是张字

24:22.900 --> 24:24.900
因此把它算出来

24:24.900 --> 24:25.900
算出来过后呢

24:25.900 --> 24:26.900
它就变成了这个

24:26.900 --> 24:28.900
它就不再是张字了

24:28.900 --> 24:30.900
这是目前的情况

24:30.900 --> 24:32.900
然后既然让我们点击这个投稿

24:32.900 --> 24:33.900
切换显示

24:34.900 --> 24:35.900
你会发现Gate

24:35.900 --> 24:36.900
没在运行的

24:37.900 --> 24:38.900
Gate 是不是没有运行的

24:39.900 --> 24:40.900
为什么没有运行Gate

24:41.900 --> 24:42.900
我们来看一下吧

24:42.900 --> 24:46.660
当我们切换显示的时候

24:47.660 --> 24:48.660
那么这里

24:51.660 --> 24:54.040
我看一下

24:54.040 --> 24:55.040
我这里再设置一个吧

24:56.040 --> 24:57.040
我再设置一个

24:58.040 --> 24:59.040
都好

25:00.040 --> 25:01.040
把first name

25:02.040 --> 25:03.040
设置为abc

25:04.040 --> 25:05.040
那你看一下

25:05.040 --> 25:06.040
那你看一下

25:06.040 --> 25:07.040
目前的Gate要不要运行

25:09.350 --> 25:11.730
放心

25:11.730 --> 25:12.730
点击

25:12.730 --> 25:13.730
是不是还是没有运行Gate

25:14.730 --> 25:15.730
起得怪了

25:15.730 --> 25:16.730
这个依赖数

25:16.730 --> 25:17.730
依赖变化过后

25:17.730 --> 25:18.730
first name是依赖的

25:18.730 --> 25:19.730
对吧

25:19.730 --> 25:20.730
依赖变化过后

25:20.730 --> 25:21.730
为什么没有运行Gate

25:21.730 --> 25:22.730
你看着它怎么回事

25:23.730 --> 25:25.730
目前最开始的时候

25:25.730 --> 25:26.730
是这个样子

25:26.730 --> 25:27.730
dirty 为force

25:27.730 --> 25:28.730
只能为远近

25:28.730 --> 25:29.730
已经算过一次了

25:29.730 --> 25:31.730
于是一开始一定是运行Gate

25:32.730 --> 25:33.730
好 接下来

25:33.730 --> 25:35.730
当我们现在把

25:35.730 --> 25:37.730
这个showname变化

25:37.730 --> 25:38.730
变成force

25:38.730 --> 25:39.730
然后这个东西不用管

25:39.730 --> 25:40.730
这个东西会导致见面重新选择

25:40.730 --> 25:41.730
我们来看一下

25:41.730 --> 25:42.730
showname

25:43.730 --> 25:45.730
它这里面只有一个主键的water

25:46.730 --> 25:47.730
然后变成force

25:47.730 --> 25:49.730
接下来把first name变成abc

25:49.730 --> 25:50.730
那么现在都两个都变了

25:50.730 --> 25:51.730
都变了过后

25:51.730 --> 25:53.730
好 我们在

25:53.730 --> 25:54.730
雕度器里边

25:54.730 --> 25:56.730
它作为把我们的water

25:56.730 --> 25:57.730
放到雕度器里面

25:57.730 --> 25:58.730
是一步执行的

25:58.730 --> 26:00.730
好 那么接下来我们来看

26:00.730 --> 26:01.730
首先会做什么呢

26:01.730 --> 26:02.730
showname变了

26:02.730 --> 26:03.730
会不会运行

26:03.730 --> 26:05.730
主键的water 没问题

26:05.730 --> 26:06.730
然后first name变了

26:06.730 --> 26:07.730
会不会运行

26:07.730 --> 26:08.730
计算属性的water

26:08.730 --> 26:09.730
是不是都会运行

26:10.730 --> 26:11.730
那么我们来看一下

26:12.730 --> 26:13.730
怎么运行的

26:13.730 --> 26:14.730
先运行这个

26:14.730 --> 26:15.730
其实都无所谓

26:15.730 --> 26:16.730
都一样

26:16.730 --> 26:17.730
我们来看吧

26:18.730 --> 26:20.730
首先运行的是

26:20.730 --> 26:21.730
那么我们就这样子写吧

26:21.730 --> 26:23.730
把first name写前面

26:23.730 --> 26:25.730
最终的结果都一样的

26:25.730 --> 26:26.730
跟前后没关系

26:28.730 --> 26:29.730
你看

26:29.730 --> 26:32.810
是不是还是不会运行

26:32.810 --> 26:33.810
来看怎么回事

26:33.810 --> 26:35.810
那么首先它会运行

26:35.810 --> 26:36.810
什么计算属性的water

26:36.810 --> 26:37.810
对吧

26:37.810 --> 26:38.810
我们首先对这个

26:38.810 --> 26:39.810
first name设为abc了

26:39.810 --> 26:41.810
它会运行计算属性的water

26:41.810 --> 26:42.810
计算属性的water

26:42.810 --> 26:43.810
它做了什么事

26:43.810 --> 26:44.810
它是不是运行get

26:44.810 --> 26:45.810
并不是

26:45.810 --> 26:46.810
它只是把dirty 设为去

26:46.810 --> 26:47.810
没了

26:48.810 --> 26:49.810
好 接下来会运行

26:49.810 --> 26:50.810
主键的water

26:50.810 --> 26:51.810
无论是对first name的改变

26:51.810 --> 26:52.810
还是对showname的改变

26:52.810 --> 26:53.810
是不是都会运行

26:53.810 --> 26:54.810
主键的water

26:54.810 --> 26:55.810
而运行

26:55.810 --> 26:56.810
主键的water

26:56.810 --> 26:57.810
渲染一模板

26:57.810 --> 26:58.810
发现

26:58.810 --> 26:59.810
这里

26:59.810 --> 27:00.810
不生成a71

27:00.810 --> 27:01.810
它用到了什么

27:01.810 --> 27:02.810
用到了这个

27:02.810 --> 27:03.810
因为它不生成a71

27:03.810 --> 27:04.810
所以说里边东西

27:04.810 --> 27:05.810
不会运行

27:05.810 --> 27:06.810
不会运行

27:06.810 --> 27:07.810
是不是

27:07.810 --> 27:09.810
这一次依赖收集

27:09.810 --> 27:10.810
它就没有用到

27:10.810 --> 27:11.810
它就没有运行这个

27:11.810 --> 27:12.810
复活列名

27:12.810 --> 27:13.810
没有运行这个复活列名

27:13.810 --> 27:14.810
是不是就没有运行get

27:14.810 --> 27:16.810
对不对

27:16.810 --> 27:17.810
是不是就没有运行get

27:17.810 --> 27:18.810
好 然后

27:18.810 --> 27:19.810
渲染出按钮

27:19.810 --> 27:20.810
按钮里边

27:20.810 --> 27:21.810
也没有用到复活列名

27:21.810 --> 27:22.810
所以说

27:22.810 --> 27:23.810
虽然说

27:23.810 --> 27:24.810
它目前已经是张纸了

27:24.810 --> 27:25.810
但是get是没有运行的

27:25.810 --> 27:26.810
你看着

27:26.810 --> 27:27.810
打开

27:28.810 --> 27:30.810
然后点击口口

27:30.810 --> 27:31.810
看一下这个vm

27:32.810 --> 27:33.810
就是我们的主键实力

27:33.810 --> 27:34.810
你看里边的computed

27:35.810 --> 27:36.810
这里边的watcher

27:36.810 --> 27:37.810
它的b6等于多少

27:37.810 --> 27:38.810
还是远近

27:38.810 --> 27:40.810
但是目前标记了

27:40.810 --> 27:41.810
这个dirty

27:41.810 --> 27:42.810
是不是去

27:42.810 --> 27:44.810
表示目前已经是张纸了

27:44.810 --> 27:45.810
刚才

27:45.810 --> 27:46.810
这个一代数据变了

27:46.810 --> 27:47.810
它一马来变成张纸了

27:47.810 --> 27:49.810
但是目前还没有计算

27:49.810 --> 27:50.810
还没有计算新的值

27:50.810 --> 27:51.810
原来这意思吧

27:52.810 --> 27:54.810
好 然后我们再点击投稿

27:54.810 --> 27:55.810
再点击投稿的时候

27:55.810 --> 27:57.810
是不是就可以显示了

27:57.810 --> 27:58.810
第一步

27:59.810 --> 28:00.810
dirty

28:00.810 --> 28:01.810
现在已经为粗了

28:01.810 --> 28:02.810
不用再设置为粗了

28:02.810 --> 28:03.810
然后再点击投稿的时候

28:04.810 --> 28:05.810
由于

28:06.810 --> 28:07.810
我们重新渲染

28:07.810 --> 28:08.810
重新渲染是不是

28:08.810 --> 28:10.810
又用到了getter

28:11.810 --> 28:12.810
又用到了复活列名

28:13.810 --> 28:14.810
运行getter

28:14.810 --> 28:15.810
那么这一次get

28:15.810 --> 28:16.810
它发现已经是张纸了

28:16.810 --> 28:17.810
它会做一件事

28:17.810 --> 28:18.810
重新运算

28:18.810 --> 28:19.810
因此我们看到的getter

28:19.810 --> 28:20.810
重新运行的getter

28:20.810 --> 28:21.810
然后把它

28:21.810 --> 28:22.810
设置为目前的值

28:22.810 --> 28:23.810
abc进

28:23.810 --> 28:24.810
然后把它设为forced

28:25.810 --> 28:26.810
明显的意思吧

28:26.810 --> 28:27.810
它是用这种方式来处理

28:27.810 --> 28:28.810
好 这是关于

28:28.810 --> 28:29.810
计算处理的处理方式

28:29.810 --> 28:32.810
以它为什么具有缓存

28:32.810 --> 28:33.810
如果你要回答的时候

28:33.810 --> 28:34.810
关键点

28:35.810 --> 28:36.810
关键点是什么呢

28:36.810 --> 28:37.810
一定要有watcher

28:37.810 --> 28:38.810
有这两个

28:38.810 --> 28:39.810
就算三个属性

28:39.810 --> 28:40.810
一个是nessy

28:40.810 --> 28:41.810
一个是value

28:41.810 --> 28:42.810
一个是dirty

28:42.810 --> 28:43.810
你把这三个点回答上

28:43.810 --> 28:44.810
那么这道面试

28:44.810 --> 28:45.810
一定能够拿到

28:45.810 --> 28:46.810
非常高的分数

28:47.810 --> 28:48.810
好吧

28:48.810 --> 28:49.810
这是关于

28:49.810 --> 28:50.810
咱们compute的

28:50.810 --> 28:51.810
它的核心原理

