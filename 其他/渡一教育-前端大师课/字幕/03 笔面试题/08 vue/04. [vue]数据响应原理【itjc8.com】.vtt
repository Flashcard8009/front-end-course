WEBVTT

00:00.110 --> 00:05.610
这些科的东西呢 不是说你一时半火就能够理解的

00:05.610 --> 00:08.110
需要离下来不断的去消化

00:08.110 --> 00:11.110
这些科的问题就很简单

00:11.110 --> 00:15.110
它就会让你去铲述5又2的享用式原理

00:15.110 --> 00:18.110
凡是遇到什么铲述的这种话题啊

00:18.110 --> 00:21.110
你能够说多少就尽量说

00:21.110 --> 00:23.110
这里边有一个链接

00:23.110 --> 00:26.110
这是5又官方的一个铲述

00:26.110 --> 00:28.110
不过它铲述的呢比较简单

00:28.110 --> 00:30.110
这里有一张图片给大家看一下

00:30.110 --> 00:32.110
在这就这张图

00:32.110 --> 00:34.110
我简单的说一下它什么意思

00:34.110 --> 00:36.110
它整篇文章都在说这个事

00:36.110 --> 00:38.110
它说什么意思呢

00:38.110 --> 00:41.110
如果说你在面试的时候遇到这样的问题

00:41.110 --> 00:44.110
那么你把这张图给它阐述出来

00:44.110 --> 00:47.110
不能说错肯定是正确的

00:47.110 --> 00:48.110
正确肯定是正确的

00:48.110 --> 00:50.110
也是比较完善的

00:50.110 --> 00:52.110
那么分数呢

00:52.110 --> 00:54.110
不要说1%的话

00:54.110 --> 00:56.110
分数呢就是80分90分

00:56.110 --> 00:58.110
那也非常不错了

00:58.110 --> 01:00.110
那么我来说一下这张图

01:00.110 --> 01:02.110
这张图啥意思呢

01:02.110 --> 01:03.110
它就这么几个部件

01:03.110 --> 01:05.110
这是5又的响应式原理

01:05.110 --> 01:06.110
什么叫响应式啊

01:06.110 --> 01:08.110
就是数据变化过后呢

01:08.110 --> 01:10.110
要去做一些事就叫响应式

01:10.110 --> 01:11.110
啥意思呢

01:11.110 --> 01:13.110
它首先把我们的数据呢

01:13.110 --> 01:15.110
变成一个getter和setter

01:15.110 --> 01:16.110
怎么来变的呢

01:16.110 --> 01:18.110
它是通过objects

01:18.110 --> 01:20.110
通过objects

01:20.110 --> 01:22.110
define property

01:22.110 --> 01:24.110
它通过这种方式对吧

01:24.110 --> 01:27.110
变定对象的每一个属性

01:27.110 --> 01:29.110
把每一个属性变成一个get

01:29.110 --> 01:30.110
和set含数

01:30.110 --> 01:31.110
那么这样子呢

01:31.110 --> 01:32.110
读取属性的时候

01:32.110 --> 01:34.110
它就会运行getter

01:34.110 --> 01:35.110
给属性复辞的时候呢

01:35.110 --> 01:36.110
它就会运行setter

01:36.110 --> 01:37.110
对吧

01:37.110 --> 01:39.110
它变成这么一个响应式数据

01:39.110 --> 01:40.110
然后呢

01:40.110 --> 01:41.110
这个响应式数据呢

01:41.110 --> 01:43.110
怎么来跟我们的界面挂勾呢

01:43.110 --> 01:44.110
你看我们的组件里面

01:44.110 --> 01:45.110
不是有rander含数吗

01:45.110 --> 01:46.110
对吧

01:46.110 --> 01:47.110
我们模板里面写的任何东西

01:47.110 --> 01:49.110
全部会变成rander含数

01:49.110 --> 01:51.110
会生成虚的解动物数

01:51.110 --> 01:52.110
对吧

01:52.110 --> 01:53.110
这是我们之前讲过的

01:53.110 --> 01:54.110
这一个步骤是讲过了

01:54.110 --> 01:55.110
对吧

01:55.110 --> 01:56.110
组件的rander含数

01:56.110 --> 01:57.110
会生成一个虚的动物数

01:57.110 --> 01:58.110
然后呢

01:58.110 --> 01:59.110
它会影响到我们的界面

01:59.110 --> 02:00.110
那么怎么样

02:00.110 --> 02:01.110
把这个rander含数

02:01.110 --> 02:03.110
跟我们的响应式数据连接起来呢

02:03.110 --> 02:05.110
它是这样子的

02:05.110 --> 02:06.110
你看啊

02:06.110 --> 02:09.110
当我们运行的运行

02:09.110 --> 02:10.110
rander含数的时候

02:10.110 --> 02:11.110
rander含数啊

02:11.110 --> 02:13.110
它里边不是会用到一些数据吗

02:13.110 --> 02:14.110
比方说啊

02:14.110 --> 02:16.110
我们rander含数里边

02:16.110 --> 02:18.110
用se含数来生成一个se元数

02:18.110 --> 02:20.110
那么这个se元数的内容呢

02:20.110 --> 02:22.110
它可能会用到我们的一些数据

02:22.110 --> 02:24.110
就是se叫message

02:24.110 --> 02:25.110
你看这个message

02:25.110 --> 02:27.110
是不是就来自于响应式数据啊

02:27.110 --> 02:28.110
对吧

02:28.110 --> 02:30.110
那么用这个message的时候

02:30.110 --> 02:32.110
它是不是会运行这个getter

02:32.110 --> 02:33.110
对不对

02:33.110 --> 02:34.110
那么这个getter呢

02:34.110 --> 02:35.110
它就会做什么事情呢

02:35.110 --> 02:36.110
它就会记录

02:36.110 --> 02:40.110
当前有一个含数叫做rander

02:40.110 --> 02:42.110
那么它用到了我这个属性

02:42.110 --> 02:43.110
它就会记录下来

02:43.110 --> 02:44.110
就是像那一式

02:44.110 --> 02:46.110
在本子小本们拿出来

02:46.110 --> 02:47.110
记录了一句话

02:47.110 --> 02:49.110
有一个含数rander

02:49.110 --> 02:50.110
它用到了我

02:50.110 --> 02:52.110
这叫做enite搜集

02:52.110 --> 02:53.110
你看看

02:53.110 --> 02:54.110
client as a dependency

02:54.110 --> 02:56.110
就表示enite搜集

02:56.110 --> 02:57.110
它搜集的是谁呢

02:57.110 --> 02:58.110
搜集的东西

02:58.110 --> 03:00.110
一个东西叫做watcher

03:00.110 --> 03:01.110
表示一个观察器

03:01.110 --> 03:03.110
一个观察者

03:03.110 --> 03:04.110
那么这个watcher呢

03:04.110 --> 03:06.110
实际上它这里不是观察者模式啊

03:06.110 --> 03:08.110
实际上是发布订阅模式

03:08.110 --> 03:09.110
不过我们现在不去

03:09.110 --> 03:10.110
研究原码的话

03:10.110 --> 03:12.110
也不用去申究

03:12.110 --> 03:13.110
反正就是一个

03:13.110 --> 03:14.110
有一个东西watcher

03:14.110 --> 03:15.110
他在看

03:15.110 --> 03:16.110
他就说我现在呢

03:16.110 --> 03:18.110
就是有一个属性

03:18.110 --> 03:20.110
用到了rander含数

03:20.110 --> 03:21.110
它就记录下来了

03:21.110 --> 03:22.110
原来的意思吧

03:22.110 --> 03:24.110
watcher它会观察

03:24.110 --> 03:25.110
将来有一天

03:25.110 --> 03:27.110
我对zmessage重新复制

03:27.110 --> 03:29.110
复制一个不一样的值

03:29.110 --> 03:30.110
那么这个时候

03:30.110 --> 03:31.110
它就会运行这个setter对吧

03:31.110 --> 03:32.110
对它属性重新复制

03:32.110 --> 03:33.110
它会运行setter

03:33.110 --> 03:35.110
那么setter它就会根据

03:35.110 --> 03:36.110
我这个属性呢

03:36.110 --> 03:38.110
以前有一个watcher

03:38.110 --> 03:39.110
在观察我

03:39.110 --> 03:41.110
那么这个watcher呢

03:41.110 --> 03:43.110
我就会去通知他

03:43.110 --> 03:45.110
叫dotify 叫派发更新

03:45.110 --> 03:46.110
我们把它去通知

03:46.110 --> 03:47.110
通知这个watcher

03:47.110 --> 03:49.110
我现在数据变化了

03:49.110 --> 03:50.110
那么这个watcher

03:50.110 --> 03:51.110
它会做什么事情呢

03:51.110 --> 03:53.110
它发现以前是运行

03:53.110 --> 03:55.110
rander含数来搜集的遗弹

03:55.110 --> 03:57.110
于是它就会重新

03:57.110 --> 03:59.110
去触发rander含数的执行

03:59.110 --> 04:01.110
那么这个rander含数

04:01.110 --> 04:02.110
重新执行

04:02.110 --> 04:03.110
是不是又重新生成的虚例动物数

04:03.110 --> 04:05.110
那么整个过程就是这样子的

04:05.110 --> 04:06.110
这张图呢

04:06.110 --> 04:08.110
解释的是比较简单

04:08.110 --> 04:09.110
但是呢

04:09.110 --> 04:10.110
也把这个道理呢

04:10.110 --> 04:11.110
就说明白了

04:11.110 --> 04:12.110
几个重要的部件

04:12.110 --> 04:13.110
一个是rander含数

04:13.110 --> 04:14.110
一个是我们的

04:14.110 --> 04:16.110
响应式数据

04:16.110 --> 04:18.110
rander含数在运行的时候呢

04:18.110 --> 04:19.110
它用到了响应式数据

04:19.110 --> 04:20.110
于是搜集的遗弹

04:20.110 --> 04:22.110
当我们的数据变化的时候呢

04:22.110 --> 04:23.110
它会通知watcher

04:23.110 --> 04:25.110
watcher会重新运行这个rander含数

04:25.110 --> 04:27.110
整个过程就是这个样子

04:27.110 --> 04:29.110
那么如果说你把这一点

04:29.110 --> 04:30.110
回答出来了

04:30.110 --> 04:32.110
也非常的ok

04:32.110 --> 04:33.110
但是呢

04:33.110 --> 04:35.110
我们的杜一德课程

04:35.110 --> 04:38.110
肯定是要追求极致的

04:38.110 --> 04:40.110
面试效果

04:40.110 --> 04:41.110
也就是说

04:41.110 --> 04:42.110
我希望呢

04:42.110 --> 04:44.110
你给他回答的尽量的详细一点

04:44.110 --> 04:45.110
尽量的是能够回答出来

04:45.110 --> 04:46.110
把它吓一跳

04:46.110 --> 04:48.110
把它听蒙了

04:48.110 --> 04:49.110
那么我们要怎么回答呢

04:49.110 --> 04:50.110
我们下来

04:50.110 --> 04:51.110
接下来呢

04:51.110 --> 04:52.110
我给大家讲解

04:52.110 --> 04:53.110
无忧里边

04:53.110 --> 04:56.110
响应式原理的一些

04:56.110 --> 04:57.110
深入的东西

04:57.110 --> 04:58.110
但是呢

04:58.110 --> 04:59.110
我要给大家提个行

04:59.110 --> 05:00.110
深入的东西呢

05:00.110 --> 05:02.110
可能难度比较高

05:02.110 --> 05:04.110
需要慢慢地去消化

05:04.110 --> 05:05.110
如果说你实在消化不了

05:05.110 --> 05:06.110
能够理解多少

05:06.110 --> 05:07.110
理解多少

05:07.110 --> 05:08.110
如果实在不行的话

05:08.110 --> 05:09.110
那你把这张图

05:09.110 --> 05:10.110
刚才我说的

05:10.110 --> 05:11.110
给他回答出来

05:11.110 --> 05:12.110
也ok

05:12.110 --> 05:13.110
好

05:13.110 --> 05:14.110
接下来我来说一下

05:14.110 --> 05:16.110
深入的东西

05:16.110 --> 05:17.110
什么叫响应式

05:17.110 --> 05:20.110
响应式的最终目标

05:20.110 --> 05:23.110
是我们对象本身

05:23.110 --> 05:26.110
或者是属性变化的时候

05:26.110 --> 05:27.110
什么叫本身

05:27.110 --> 05:28.110
比方说我们的宿主

05:28.110 --> 05:29.110
是一个对象

05:29.110 --> 05:30.110
对吧

05:30.110 --> 05:31.110
宿主里边

05:31.110 --> 05:33.110
我们往宿主里边加一个

05:33.110 --> 05:35.110
扑洗一个数据

05:35.110 --> 05:36.110
那么这就是

05:36.110 --> 05:38.110
对象本身发生变化

05:38.110 --> 05:39.110
明白的意思吧

05:39.110 --> 05:41.110
或者是我们有一个空对象

05:41.110 --> 05:42.110
或者是你被有一些数据

05:42.110 --> 05:45.110
我们现在不去改动这些属性

05:45.110 --> 05:47.110
我而是往对象里边加一个属性

05:47.110 --> 05:48.110
或者是删除一个属性

05:48.110 --> 05:51.110
这叫做对象本身的变化

05:51.110 --> 05:52.110
本身变化

05:52.110 --> 05:54.110
或者是对象属性变化

05:54.110 --> 05:55.110
那属性变化就很好理解的

05:55.110 --> 05:58.110
我对A重新复制就是属性变化

05:58.110 --> 05:59.110
对吧

05:59.110 --> 06:00.110
无论是本身变化

06:00.110 --> 06:02.110
还是属性变化

06:02.110 --> 06:03.110
那么这个时候

06:03.110 --> 06:04.110
将会运行

06:04.110 --> 06:07.110
将会触发一些行为

06:07.110 --> 06:08.110
运行一些函数

06:08.110 --> 06:09.110
这就是

06:09.110 --> 06:10.110
最常见的当然

06:10.110 --> 06:11.110
这个函数就是Render函数

06:11.110 --> 06:12.110
如果我们说重宣了

06:12.110 --> 06:13.110
指的是什么

06:13.110 --> 06:15.110
就是重新运行Render

06:15.110 --> 06:17.110
但是我们要把它抽象成为一个

06:17.110 --> 06:18.110
一般性的概念

06:18.110 --> 06:20.110
它不一定是Render函数

06:20.110 --> 06:21.110
比方说还有什么函数呢

06:21.110 --> 06:24.110
还比方说我们在配置里边的Warch

06:24.110 --> 06:26.110
或者是我们调用Z-Warch

06:26.110 --> 06:27.110
是不是讲过的

06:27.110 --> 06:29.110
来观察某一个东西发生变化

06:29.110 --> 06:30.110
变化的时候运行一个函数

06:30.110 --> 06:31.110
那么这也是想象式

06:31.110 --> 06:33.110
就是有一个数据变化了

06:33.110 --> 06:34.110
它会运行

06:34.110 --> 06:36.110
它会自动的去运行一些函数

06:36.110 --> 06:37.110
这个函数不一定是Render

06:37.110 --> 06:39.110
但是绝大部分情况下的就是Render

06:39.110 --> 06:41.110
那么这叫做数据象象式

06:42.110 --> 06:43.110
我给大家讲明白

06:43.110 --> 06:44.110
你们会要

06:44.110 --> 06:45.110
要参考这个文档

06:45.110 --> 06:46.110
组织成自己的语言

06:46.110 --> 06:47.110
给它阐述出去

06:47.110 --> 06:50.110
这是数据象象令人的中级目标

06:51.110 --> 06:52.110
那么为了实现这一点

06:52.110 --> 06:54.110
无忧是怎么做的呢

06:54.110 --> 06:56.110
它用到了几个核心部件

06:56.110 --> 06:57.110
一个叫Observer

06:57.110 --> 06:58.110
一个叫Dep

06:58.110 --> 06:59.110
一个叫Water

06:59.110 --> 07:01.110
一个叫Scheduler

07:01.110 --> 07:02.110
好

07:02.110 --> 07:03.110
我们来一个个看

07:03.110 --> 07:04.110
每一个部件

07:04.110 --> 07:05.110
它做的

07:05.110 --> 07:06.110
它解决一个问题

07:06.110 --> 07:08.110
首先我们看Observer

07:08.110 --> 07:09.110
它解决什么问题呢

07:09.110 --> 07:11.110
因为我们的对象

07:12.110 --> 07:13.110
它是一种

07:13.110 --> 07:14.110
是一个普通对象

07:14.110 --> 07:16.110
普通对一个普通对象的复职

07:17.110 --> 07:19.110
比方说OB借AKR重新复职

07:19.110 --> 07:22.110
是没有任何人能够收到任何通知的

07:22.110 --> 07:23.110
它没有任何一个程序

07:23.110 --> 07:25.110
能够监测到这个A已经被改变了

07:25.110 --> 07:26.110
所以说Observer

07:26.110 --> 07:27.110
要解决这个问题

07:27.110 --> 07:28.110
它怎么解决

07:28.110 --> 07:29.110
它怎么解决呢

07:30.110 --> 07:31.110
它就是把一个普通的对象

07:31.110 --> 07:33.110
转换成享用式的对象

07:33.110 --> 07:35.110
解决的方式非常简单

07:35.110 --> 07:37.110
它就是循环便利

07:37.110 --> 07:39.110
便利对象的每一个属性

07:39.110 --> 07:40.110
这个很好说了吧

07:40.110 --> 07:41.110
对吧

07:41.110 --> 07:42.110
便利它的每一个属性

07:42.110 --> 07:43.110
通过define property

07:43.110 --> 07:45.110
重新定义这个属性

07:45.110 --> 07:46.110
一重新定义

07:46.110 --> 07:47.110
是不是里面就可以

07:47.110 --> 07:48.110
带一个get方法

07:48.110 --> 07:49.110
然后一个set方法

07:49.110 --> 07:50.110
对吧

07:50.110 --> 07:51.110
那么我们把它称之为getter

07:51.110 --> 07:52.110
和setter

07:52.110 --> 07:53.110
那么就把它

07:53.110 --> 07:54.110
把这个属性变成了一个

07:54.110 --> 07:56.110
去由访问器的属性

07:56.110 --> 07:58.110
那么这样子一来的话

07:58.110 --> 07:59.110
将来读这个属性的值

07:59.110 --> 08:01.110
是不是会运行一个函数

08:01.110 --> 08:03.110
将来给这个属性的负值

08:03.110 --> 08:04.110
是不是运行set函数

08:04.110 --> 08:06.110
它就做这么一件事

08:06.110 --> 08:08.110
访问属性或者是

08:08.110 --> 08:09.110
设置属性的时候

08:09.110 --> 08:10.110
五用它至少

08:10.110 --> 08:11.110
不要说

08:11.110 --> 08:13.110
先不说它具体做什么

08:13.110 --> 08:14.110
它至少有机会了

08:14.110 --> 08:15.110
对吧

08:15.110 --> 08:16.110
去做一些事情

08:16.110 --> 08:17.110
因为它会运行

08:17.110 --> 08:18.110
触犯一个函数执行

08:18.110 --> 08:19.110
对吧

08:19.110 --> 08:20.110
于是它就变成这个样子

08:20.110 --> 08:21.110
一个原式对象

08:21.110 --> 08:22.110
经过Observer

08:22.110 --> 08:23.110
这个原式对象就变了

08:23.110 --> 08:24.110
它里边的属性

08:24.110 --> 08:25.110
就不再是一个普通属性了

08:25.110 --> 08:27.110
每一个属性都变成了

08:27.110 --> 08:28.110
有一个getter和setter

08:28.110 --> 08:31.110
这个图只是简略的说明

08:31.110 --> 08:32.110
它具体的情况

08:32.110 --> 08:33.110
是这个样子的

08:33.110 --> 08:34.110
就是有两个属性

08:34.110 --> 08:35.110
一个a 一个b

08:36.110 --> 08:38.110
那么经过Observer

08:38.110 --> 08:39.110
Observer是个构造器

08:39.110 --> 08:41.110
构造器我们用不了

08:42.110 --> 08:43.110
它是内部使用的

08:43.110 --> 08:45.110
它会把它变成什么呢

08:45.110 --> 08:47.110
变成一个这个东西

08:48.110 --> 08:49.110
a

08:49.110 --> 08:50.110
a里面有一个

08:52.110 --> 08:53.110
让我写开一点吧

08:53.110 --> 08:54.110
a

08:54.110 --> 08:56.110
a里面有一个get函数

08:57.110 --> 08:58.110
有一个set函数

08:59.110 --> 09:00.110
然后b

09:00.110 --> 09:02.110
b里面有一个get

09:03.110 --> 09:04.110
一个set

09:04.110 --> 09:05.110
原来的意思吧

09:05.110 --> 09:06.110
它通过什么

09:06.110 --> 09:07.110
什么来解决的

09:07.110 --> 09:08.110
通过define property

09:08.110 --> 09:09.110
我这里行的很简略

09:09.110 --> 09:11.110
它不是说把它变成一个对象了

09:11.110 --> 09:12.110
它只是通过define property

09:12.110 --> 09:13.110
把它变成一个

09:13.110 --> 09:14.110
具有getter和setter函数

09:14.110 --> 09:15.110
这样子

09:15.110 --> 09:17.110
读它的值是否运行函数

09:17.110 --> 09:18.110
给它复制运行函数

09:18.110 --> 09:19.110
对吧

09:19.110 --> 09:20.110
那么就有机会

09:20.110 --> 09:21.110
做一些别的事情了

09:21.110 --> 09:22.110
现在我们先暂时

09:22.110 --> 09:23.110
不着急说

09:23.110 --> 09:24.110
它到底做什么别的事情

09:24.110 --> 09:25.110
我们来单说

09:25.110 --> 09:27.110
这个东西它怎么变的

09:27.110 --> 09:29.110
很简单 就是变例

09:29.110 --> 09:30.110
那如果说对象里面

09:30.110 --> 09:31.110
再套对象

09:31.110 --> 09:33.110
那它又怎么办呢

09:34.110 --> 09:35.110
对象里面再套对象的话

09:35.110 --> 09:37.110
那么它就进行一规便利

09:37.110 --> 09:38.110
它就做这么一件事

09:39.110 --> 09:40.110
这个函

09:40.110 --> 09:41.110
这个东西它内

09:41.110 --> 09:42.110
是5u内部的东西

09:42.110 --> 09:43.110
我们用不了

09:43.110 --> 09:44.110
但是我们可以简介地使用它

09:44.110 --> 09:45.110
怎么使用它呢

09:45.110 --> 09:46.110
5u里面

09:46.110 --> 09:47.110
给我们提供了一个构造

09:47.110 --> 09:48.110
就是静态方法

09:48.110 --> 09:49.110
叫做obverber

09:49.110 --> 09:50.110
里面传一个对象

09:50.110 --> 09:52.110
其实它就是简介地调用它

09:52.110 --> 09:54.110
那么我们来看一下

09:54.110 --> 09:56.110
这里的我们新建一个页面

09:56.110 --> 09:57.110
新建一个页面

10:00.110 --> 10:01.110
为了这里

10:01.110 --> 10:02.110
因为我们要看

10:02.110 --> 10:05.110
这里这些客家要开发东西的不少

10:05.110 --> 10:07.110
所以说我们为了简单

10:07.110 --> 10:08.110
我就直接引用了

10:08.110 --> 10:09.110
我就没有用脚手架

10:09.110 --> 10:11.110
直接引用了这个东西

10:11.110 --> 10:12.110
这个5u介石

10:13.110 --> 10:14.110
到底是一样

10:14.110 --> 10:17.810
这个5u有这个构造函数里面

10:17.810 --> 10:20.810
有个方法叫做obverber

10:20.810 --> 10:21.810
这个方法

10:21.810 --> 10:22.810
它里面传一个对象进去

10:22.810 --> 10:25.810
比方说我们这里有个ob

10:25.810 --> 10:26.810
里面就有一个a等于1

10:26.810 --> 10:27.810
b等于2

10:27.810 --> 10:29.810
然后再一个c等于一个对象

10:29.810 --> 10:31.810
c的对象里面d

10:32.810 --> 10:33.810
3

10:33.810 --> 10:34.810
1

10:34.810 --> 10:35.810
4

10:35.810 --> 10:37.810
然后这个f又是一个数组

10:37.810 --> 10:39.810
数组里面又是一个对象

10:39.810 --> 10:42.810
对象里面比方说a有点1

10:42.810 --> 10:44.810
b有点2

10:44.810 --> 10:46.810
然后还有一些数字

10:46.810 --> 10:48.810
我就随便写一些

10:48.810 --> 10:49.810
就这么一个对象

10:49.810 --> 10:50.810
我把对象传进去

10:50.810 --> 10:51.810
它的作用很简单

10:51.810 --> 10:54.810
它就把对象变成一个想象式数据

10:54.810 --> 10:55.810
好,咱们来看一下

10:56.810 --> 10:59.890
运行出来

10:59.890 --> 11:00.890
我们看一下这个ob

11:01.890 --> 11:02.890
你看

11:02.890 --> 11:03.890
是不是变了

11:03.890 --> 11:04.890
变成了a,是不是想象数据

11:04.890 --> 11:06.890
想象数据在浏览器的界面里面

11:06.890 --> 11:07.890
就是这个样子

11:07.890 --> 11:08.890
它有个点点点

11:08.890 --> 11:10.890
它现在不知道什么值

11:10.890 --> 11:11.890
要点一下过后

11:11.890 --> 11:12.890
它告诉你

11:12.890 --> 11:14.890
看下面这个就是单词

11:15.890 --> 11:16.890
看下面这个

11:21.160 --> 11:24.730
下面这个提示

11:24.730 --> 11:25.730
叫 evoke

11:25.730 --> 11:26.730
调用属性的getter

11:26.730 --> 11:28.730
它调用那个函数

11:28.730 --> 11:29.730
看到没

11:29.730 --> 11:30.730
才能得到

11:30.730 --> 11:31.730
我们这四个属性

11:31.730 --> 11:32.730
是不是都是想象式的

11:32.730 --> 11:33.730
然后我们展开C

11:33.730 --> 11:35.730
C里边的东西也是想象式的

11:35.730 --> 11:36.730
它有一个低规的调用过程

11:36.730 --> 11:38.730
它把你深度的去看

11:38.730 --> 11:39.730
每一个对象

11:39.730 --> 11:40.730
每一个属性

11:40.730 --> 11:41.730
把它变成想象式

11:41.730 --> 11:43.730
然后我们再看数组

11:43.730 --> 11:44.730
再看数组

11:44.730 --> 11:46.730
数组里边有个123

11:46.730 --> 11:47.730
而且第一个是一个对象

11:47.730 --> 11:49.730
对象的它也变成了想象式

11:49.730 --> 11:51.730
它是深度变立的

11:51.730 --> 11:54.730
这就是它的调用方式

11:56.730 --> 11:58.730
那么这个件事情

11:58.730 --> 11:59.730
如果说在组建里边

11:59.730 --> 12:00.730
它发生在什么时候呢

12:00.730 --> 12:01.730
组建里面

12:01.730 --> 12:02.730
我们都知道

12:02.730 --> 12:03.730
它会把组建的配置

12:03.730 --> 12:04.730
这个data配置

12:04.730 --> 12:05.730
它返回的数据

12:05.730 --> 12:06.730
变成想象式对吧

12:06.730 --> 12:07.730
那么这件事情发生在什么时候呢

12:07.730 --> 12:08.730
它发生在

12:08.730 --> 12:10.730
这个两个生命东西喊出之间

12:10.730 --> 12:12.730
就是在before create之后

12:12.730 --> 12:14.730
可以的之前

12:14.730 --> 12:16.730
也就是before create的时候

12:16.730 --> 12:17.730
是没有数据想象式的

12:17.730 --> 12:18.730
它完了过后

12:18.730 --> 12:19.730
才会有数据想象式

12:19.730 --> 12:21.730
这个我们以前也讲过

12:23.730 --> 12:24.730
那么具体来说

12:24.730 --> 12:25.730
我们现在还没有完

12:25.730 --> 12:26.730
这个observer

12:26.730 --> 12:28.730
你还可以给面试官说一说

12:28.730 --> 12:30.730
那么它有的是

12:30.730 --> 12:32.730
它里边还有一些细节的问题

12:32.730 --> 12:34.730
比方说它的做

12:34.730 --> 12:37.730
因为它的做法是循环变立对象的属性

12:37.730 --> 12:38.730
那如果说对象

12:38.730 --> 12:39.730
它没有一个属性

12:39.730 --> 12:40.730
一开始没有

12:40.730 --> 12:41.730
后边才有

12:41.730 --> 12:42.730
那么这种属性

12:42.730 --> 12:43.730
它是监测不到的

12:43.730 --> 12:44.730
你想啊

12:44.730 --> 12:45.730
我有一个对象

12:45.730 --> 12:46.730
这个对象里边呢

12:46.730 --> 12:48.730
就是有两个属性

12:48.730 --> 12:49.730
一个a

12:49.730 --> 12:50.730
一个b

12:50.730 --> 12:51.730
好 我把这个对象

12:51.730 --> 12:52.730
拿去变成数据想象式

12:52.730 --> 12:53.730
于是呢

12:53.730 --> 12:54.730
a变成数据想象式的

12:54.730 --> 12:55.730
b变成数据想象式的

12:55.730 --> 12:56.730
将来有一天

12:56.730 --> 12:58.730
我们把这个对象里边加一个属性

12:58.730 --> 12:59.730
这种情况下

12:59.730 --> 13:00.730
它能监测到吗

13:00.730 --> 13:01.730
它监测不到

13:01.730 --> 13:02.730
因为这个属性

13:02.730 --> 13:03.730
它以前没有

13:03.730 --> 13:04.730
它就不知道以后

13:04.730 --> 13:05.730
会有这个属性

13:05.730 --> 13:06.730
它监测不到

13:06.730 --> 13:07.730
也没有什么能力

13:07.730 --> 13:08.730
给它监测到

13:08.730 --> 13:09.730
当然s6过后呢

13:09.730 --> 13:10.730
到了5又3

13:10.730 --> 13:11.730
它就使用proxy

13:11.730 --> 13:12.730
那就能监测到了

13:12.730 --> 13:13.730
现在是监测不到的

13:13.730 --> 13:14.730
你没法监测到

13:14.730 --> 13:16.730
一开始没有这个属性

13:16.730 --> 13:17.730
那么如果说

13:17.730 --> 13:20.730
将来我们dnxobga

13:20.730 --> 13:22.730
这个东西它也监测不到

13:22.730 --> 13:23.730
它没法监测

13:23.730 --> 13:24.730
监测不到

13:24.730 --> 13:25.730
那监测不到怎么办呢

13:25.730 --> 13:29.730
监测不到的话

13:29.730 --> 13:30.730
那就没办法

13:30.730 --> 13:32.730
所以你不能用这种方式

13:32.730 --> 13:34.730
去给对象新增属性

13:34.730 --> 13:35.730
或者是删除属性

13:35.730 --> 13:36.730
因为它监测不到

13:36.730 --> 13:38.730
以前在s6之前

13:38.730 --> 13:39.730
它是没有任何办法的

13:39.730 --> 13:41.730
5又2是基于s5的

13:41.730 --> 13:43.730
所以说它没有任何办法

13:43.730 --> 13:44.730
监测到

13:44.730 --> 13:47.300
稍等一下

13:47.300 --> 13:48.300
那么怎么办

13:48.300 --> 13:49.300
为了解决这个问题

13:49.300 --> 13:51.300
它提供了一种折腾的方案

13:51.300 --> 13:52.300
就说你以后

13:52.300 --> 13:54.300
要对对象新增一个属性

13:54.300 --> 13:55.300
你要使用

13:55.300 --> 13:56.300
它提供了一个set方法

13:56.300 --> 13:57.300
这个set方法挂在

13:57.300 --> 13:59.300
到5又的实力里面去了

13:59.300 --> 14:00.300
你可以通过这种方式

14:00.300 --> 14:02.300
来给它新增一个属性

14:02.300 --> 14:04.300
比如objc

14:04.300 --> 14:07.300
给它加一个属性

14:07.300 --> 14:08.300
那么这样子

14:08.300 --> 14:09.300
它就可以监测到了

14:09.300 --> 14:10.300
因为要调用函数

14:10.300 --> 14:11.300
函数里面是不是可以

14:11.300 --> 14:12.300
做一些事情

14:12.300 --> 14:13.300
对吧

14:13.300 --> 14:14.300
那么dnx的时候

14:14.300 --> 14:15.300
你可以使用

14:20.300 --> 14:21.300
没问题吧

14:21.300 --> 14:22.300
那么这样子是可以的

14:22.300 --> 14:24.300
它是能监测到的

14:24.300 --> 14:25.300
我们举个例子吧

14:26.300 --> 14:28.300
我们再来一个test2

14:28.300 --> 14:29.300
这一刻我们可能时间

14:29.300 --> 14:30.300
比较长

14:30.300 --> 14:31.300
我们慢慢讲

14:36.300 --> 14:37.300
比方说我们这里的

14:37.300 --> 14:38.300
就不用这种方式了

14:39.300 --> 14:40.300
比方说这里

14:40.300 --> 14:41.300
我们有一个

14:41.300 --> 14:43.300
有些数据

14:43.300 --> 14:45.300
he

14:45.300 --> 14:46.300
它里面用到了一些数据

14:46.300 --> 14:47.300
什么数据

14:47.300 --> 14:49.300
那就是obj.a

14:49.300 --> 14:51.300
然后呢

14:51.300 --> 14:54.300
obj.b

14:54.300 --> 14:56.610
然后一个

14:56.610 --> 14:57.610
够了

14:57.610 --> 14:58.610
就这两个

14:58.610 --> 14:59.610
我们这里输出

14:59.610 --> 15:00.610
这样子写

15:00.610 --> 15:02.610
a等于

15:03.610 --> 15:05.610
obj.b等于

15:05.610 --> 15:06.610
好

15:06.610 --> 15:08.610
我这里留一个v

15:09.610 --> 15:10.610
el

15:10.610 --> 15:11.610
vab

15:12.610 --> 15:13.610
返回一个vm

15:16.430 --> 15:17.430
不用返回了吧

15:17.430 --> 15:18.430
就这样

15:18.430 --> 15:20.430
这里边有一个数据

15:21.430 --> 15:23.430
返回一个obj

15:23.430 --> 15:24.430
一个对象

15:24.430 --> 15:25.430
对象里面目前

15:25.430 --> 15:26.430
只有一个数据a

15:27.430 --> 15:28.430
也等于

15:29.430 --> 15:30.430
没有这个b这个数据

15:30.430 --> 15:31.430
好

15:31.430 --> 15:32.430
我们首先来看一下

15:32.430 --> 15:33.430
目前的效果

15:33.430 --> 15:35.430
所以b里面没有值

15:35.430 --> 15:36.430
对吧

15:36.430 --> 15:37.430
好

15:37.430 --> 15:38.430
接下来我们使用

15:38.430 --> 15:39.430
下面有两个按钮

15:39.430 --> 15:41.430
一个按钮的就是dneta

15:43.430 --> 15:44.430
好

15:44.430 --> 15:46.430
一个按钮的是addb

15:47.430 --> 15:48.430
好

15:48.430 --> 15:49.430
dneta的话

15:49.430 --> 15:50.430
我们再写个实践

15:50.430 --> 15:52.430
删除一个数据a

15:52.430 --> 15:53.430
我们怎么删除呢

15:53.430 --> 15:54.430
如果说我用

15:54.430 --> 15:55.430
方式这种写法

15:55.430 --> 15:57.430
dneta obj.a

15:57.430 --> 15:58.430
你看一下行不行

15:58.430 --> 16:00.430
刷新点击

16:00.430 --> 16:01.430
有效果吗

16:01.430 --> 16:02.430
是不是没有效果

16:02.430 --> 16:03.430
那我们来看一下

16:03.430 --> 16:05.430
属性是不是删除了

16:05.430 --> 16:06.430
看一下

16:06.430 --> 16:07.430
vm

16:07.430 --> 16:08.430
属性是不是删除了

16:08.430 --> 16:09.430
看一下a

16:10.430 --> 16:11.430
obj

16:13.430 --> 16:15.430
属性没有删除

16:16.430 --> 16:18.430
我还没点击

16:18.430 --> 16:19.430
应该是没有点击

16:19.430 --> 16:20.430
点击

16:20.430 --> 16:21.430
看一下vm

16:22.430 --> 16:23.430
obj

16:24.430 --> 16:26.430
你看是不是没有a属性的

16:26.430 --> 16:28.430
obj里面是不是没有a属性的

16:28.430 --> 16:29.430
属性确实是删除了

16:29.430 --> 16:31.430
但是他不知道

16:31.430 --> 16:32.430
他不知道被删了

16:32.430 --> 16:34.430
因为这个东西他收不到通知

16:34.430 --> 16:35.430
知道吧

16:35.430 --> 16:36.430
所以说他建议你呢

16:36.430 --> 16:37.430
使用z

16:37.430 --> 16:38.430
当然这个模板里面就比较使用z了

16:38.430 --> 16:40.430
那就直接使用dnet

16:40.430 --> 16:41.430
删除哪个

16:41.430 --> 16:42.430
删除z点obj

16:42.430 --> 16:44.430
但是这里就不用z了

16:44.430 --> 16:45.430
obj

16:45.430 --> 16:46.430
哪个属性

16:46.430 --> 16:47.430
a这个属性

16:47.430 --> 16:48.430
这样子还可以受到通知

16:48.430 --> 16:49.430
因为你在调用函数

16:49.430 --> 16:51.430
这函数是5又给你提供的

16:51.430 --> 16:52.430
他就能知道你在你想干嘛

16:52.430 --> 16:53.430
你想想删除a

16:53.430 --> 16:55.430
他就能做出一些反应

16:55.430 --> 16:56.430
好 删除a

16:56.430 --> 16:57.430
你看现在是不可以的

16:57.430 --> 16:58.430
同样的道理

16:58.430 --> 16:59.430
添加一个b属性

17:01.430 --> 17:02.430
添加一个b属性

17:03.430 --> 17:04.430
就是我们可以要用

17:04.430 --> 17:05.430
使用set

17:05.430 --> 17:06.430
你直接添加他肯定不行的

17:06.430 --> 17:07.430
他不知道

17:09.430 --> 17:10.430
我们直接添加一次吧

17:10.430 --> 17:11.430
objb

17:11.430 --> 17:14.740
等于messurelion

17:14.740 --> 17:15.740
保存

17:15.740 --> 17:16.740
添加b

17:16.740 --> 17:17.740
你看

17:17.740 --> 17:18.740
他实际上已经添加了

17:18.740 --> 17:19.740
我们来看这里

17:24.740 --> 17:25.740
obj

17:25.740 --> 17:26.740
你看

17:26.740 --> 17:27.740
他说b已经添加了

17:27.740 --> 17:28.740
但是他不是一个想用式数据

17:28.740 --> 17:29.740
看到没

17:29.740 --> 17:30.740
因为他不知道

17:30.740 --> 17:31.740
你这里添加了b

17:31.740 --> 17:32.740
他没法做出一些反应

17:32.740 --> 17:34.740
那该怎么来添加呢

17:34.740 --> 17:35.740
应该是用这种方式

17:36.740 --> 17:37.740
set

17:37.740 --> 17:38.740
obj

17:38.740 --> 17:40.740
如果说你寫到一个messurelion

17:40.740 --> 17:41.740
要用z

17:41.740 --> 17:42.740
dolarset

17:42.740 --> 17:43.740
z掉obj

17:43.740 --> 17:44.740
我这里没有

17:45.740 --> 17:46.740
这里b

17:47.740 --> 17:48.740
他的值是什么呢

17:48.740 --> 17:50.740
值是一个messurelion

17:51.740 --> 17:52.740
保存

17:52.740 --> 17:53.740
刷新

17:53.740 --> 17:54.740
现在是不是可以了

17:54.740 --> 17:55.740
我们再来看一下这个vn

17:56.740 --> 17:58.740
现在我们通过set添加的属性

17:58.740 --> 17:59.740
他就是一个想用式的

17:59.740 --> 18:00.740
你看

18:00.740 --> 18:01.740
b是不是想用式的

18:02.740 --> 18:03.740
看到没

18:03.740 --> 18:04.740
就这么个意思

18:05.740 --> 18:07.740
那么如果说数组呢

18:07.740 --> 18:09.740
都是对象的情况

18:09.740 --> 18:11.740
数组他怎么变成想用式的呢

18:11.740 --> 18:13.740
我们来看一下数组

18:14.740 --> 18:16.740
数组是这个样子的

18:16.740 --> 18:18.740
比如说我们这里有一个数组

18:21.740 --> 18:22.740
123

18:22.740 --> 18:23.740
是

18:23.740 --> 18:25.740
我们这里把数组渲染出来

18:25.740 --> 18:27.740
我们这里就用一个ulli

18:27.740 --> 18:28.740
li

18:29.740 --> 18:30.740
v4

18:32.740 --> 18:33.740
n

18:33.740 --> 18:34.740
r

18:34.740 --> 18:35.740
渲染出来

18:35.740 --> 18:37.740
为难的去写什么t

18:37.740 --> 18:38.740
好

18:38.740 --> 18:39.740
数组出不出来了

18:39.740 --> 18:41.740
那么现在我们往数组里面加一下

18:41.740 --> 18:42.740
加一下

18:43.740 --> 18:44.740
或者是

18:45.740 --> 18:46.740
我们对这个数组排序

18:49.500 --> 18:50.500
就是

18:51.500 --> 18:52.500
resort

18:52.500 --> 18:53.500
resort

18:53.500 --> 18:54.500
对数组排序

18:54.500 --> 18:56.500
对数组排序就是特别简单

18:56.500 --> 18:57.500
click

18:57.500 --> 18:58.500
我们就随机排个序

18:59.500 --> 19:00.500
怎么随机排个序呢

19:00.500 --> 19:01.500
我就有这样子吧

19:03.500 --> 19:04.500
我就把这个数组

19:04.500 --> 19:05.500
arr

19:05.500 --> 19:06.500
调它的sort

19:07.500 --> 19:08.500
是一个sort的方法吧

19:08.500 --> 19:09.500
数组里面是一个sort

19:10.500 --> 19:11.500
sort的方法

19:11.500 --> 19:13.820
然后呢

19:13.820 --> 19:14.820
排序的时候呢

19:14.820 --> 19:16.820
我们反而回一个

19:17.820 --> 19:18.820
mas

19:18.820 --> 19:19.820
这个东西我不讲了啊

19:19.820 --> 19:21.820
随机排序的方案不讲了

19:21.820 --> 19:22.820
那么对数组重新排序

19:22.820 --> 19:23.820
改变了这个数组

19:23.820 --> 19:24.820
好

19:24.820 --> 19:25.820
保存

19:25.820 --> 19:26.820
现在我们点击resort

19:27.820 --> 19:28.820
是不是数组重新排序了

19:28.820 --> 19:29.820
他也会跟着变化

19:30.820 --> 19:31.820
那么他为什么能够实现这一点呢

19:31.820 --> 19:33.820
当然我们对数组进行铺鞋啊

19:33.820 --> 19:34.820
对数组进行删除啊

19:34.820 --> 19:35.820
pop啊这些东西

19:35.820 --> 19:37.820
他都会导致界面刷新

19:38.820 --> 19:39.820
但是这个铺鞋啊

19:39.820 --> 19:41.820
这些像我们这个sort的方法

19:41.820 --> 19:42.820
铺鞋方法

19:42.820 --> 19:43.820
pop方法

19:43.820 --> 19:44.820
他们都是都是哪来的

19:44.820 --> 19:45.820
都是

19:45.820 --> 19:46.820
arr

19:46.820 --> 19:47.820
根本提供的对吧

19:48.820 --> 19:49.820
你觉得

19:50.820 --> 19:52.820
浏览器里面这个耳锐对象

19:52.820 --> 19:53.820
他根本提供的这些方法里面

19:53.820 --> 19:55.820
他会通知无忧吗

19:56.820 --> 19:57.820
通知就见鬼了

19:57.820 --> 19:58.820
对吧他怎么知道无忧

19:58.820 --> 19:59.820
你在用无忧

19:59.820 --> 20:01.820
他连无忧是啥都不知道

20:01.820 --> 20:02.820
可能他不是不知道

20:02.820 --> 20:03.820
他根本就不想去考虑这些问题

20:03.820 --> 20:05.820
因为浏览器他要考虑通用性

20:06.820 --> 20:07.820
所以他不可能去通知无忧的

20:07.820 --> 20:08.820
那么无忧他怎么来

20:08.820 --> 20:09.820
收到通知的呢

20:09.820 --> 20:10.820
你调用方法的时候

20:10.820 --> 20:11.820
无忧他怎么知道

20:11.820 --> 20:12.820
你在改变数组呢

20:13.820 --> 20:14.820
我们来看一下这个数组就明白了

20:14.820 --> 20:15.820
我们来输出一下

20:15.820 --> 20:16.820
bm

20:16.820 --> 20:17.820
点什么

20:17.820 --> 20:18.820
我们的arr

20:18.820 --> 20:19.820
看一下这个数组

20:20.820 --> 20:21.820
这个数组一看上去

20:21.820 --> 20:22.820
好像不太对劲

20:23.820 --> 20:24.820
比方他多了这么一个东西

20:24.820 --> 20:25.820
对吧他不太对劲

20:25.820 --> 20:26.820
不是好像不像

20:26.820 --> 20:27.820
不太像是一个普通的数组

20:28.820 --> 20:29.820
我们来看一下是怎么回事

20:30.820 --> 20:31.820
他那个圆形

20:31.820 --> 20:32.820
他一个隐释圆形

20:32.820 --> 20:33.820
因为我们知道

20:33.820 --> 20:35.820
puxia这些方法都是在隐释圆形上

20:35.820 --> 20:36.820
对吧隐释圆形

20:37.820 --> 20:39.820
他不就不是一个数组的

20:39.820 --> 20:40.820
圆形

20:40.820 --> 20:42.820
本来应该是这个样子的

20:42.820 --> 20:45.820
就是我们的arr.proto

20:46.820 --> 20:47.820
应该等于什么呢

20:48.820 --> 20:52.820
应该等于arr.proto type

20:53.820 --> 20:54.820
proto type对吧

20:54.820 --> 20:55.820
应该是这样子的

20:55.820 --> 20:57.820
但是结果了他不是

20:57.820 --> 20:58.820
结果是什么呢

20:58.820 --> 21:02.820
结果是他把他做了一个新的对象出来

21:03.820 --> 21:05.820
他做了这个新的对象出来

21:06.820 --> 21:09.820
就是无忧自己搞的一个对象

21:09.820 --> 21:11.820
这个对象里边有各种各样的方法

21:11.820 --> 21:12.820
pop

21:12.820 --> 21:13.820
puxia reverse

21:13.820 --> 21:14.820
sort

21:15.820 --> 21:16.820
sort

21:16.820 --> 21:17.820
看我们的sort都在里边

21:18.820 --> 21:19.820
自己搞了一个对象

21:19.820 --> 21:21.820
他把我们的数组的隐释圆形改成arr.proto

21:21.820 --> 21:22.820
你看这意思吧

21:22.820 --> 21:23.820
于是我们调用的方法

21:23.820 --> 21:25.820
实际上不是arr.proto type的方法

21:26.820 --> 21:27.820
调用的是什么

21:27.820 --> 21:28.820
无忧自己的方法

21:28.820 --> 21:29.820
无忧自己的方法

21:29.820 --> 21:30.820
肯定要通知无忧

21:30.820 --> 21:31.820
你在更改数组

21:32.820 --> 21:33.820
对吧

21:33.820 --> 21:35.820
那么为了让我们的数组

21:35.820 --> 21:36.820
他才又是一个数组

21:37.820 --> 21:38.820
为了让我们这个东西

21:38.820 --> 21:40.820
仍然保持数组的特性

21:40.820 --> 21:41.820
比方说你调用一些什么

21:42.820 --> 21:43.820
数组里边的一些别的方法

21:43.820 --> 21:45.820
他不会改变数组本身的

21:45.820 --> 21:46.820
比方说filter

21:46.820 --> 21:47.820
map

21:47.820 --> 21:48.820
他真正可以用

21:48.820 --> 21:49.820
所以说他又把自己

21:49.820 --> 21:51.820
搞了对象的隐释圆形

21:51.820 --> 21:54.510
proto

21:54.510 --> 21:55.510
指向什么

21:56.510 --> 22:00.510
指向就是arr.proto type

22:01.510 --> 22:02.510
他做了这么一件事

22:02.510 --> 22:03.510
所以说用当图

22:03.510 --> 22:04.510
其实非常容易看到这一点

22:04.510 --> 22:05.510
我们的数组

22:06.510 --> 22:07.510
他的隐释圆形

22:07.510 --> 22:08.510
是无忧自己的对象

22:08.510 --> 22:10.510
那么他的隐释圆形

22:10.510 --> 22:11.510
是他

22:11.510 --> 22:12.510
以前本来是这个样子的

22:12.510 --> 22:14.510
以前他本来是

22:14.510 --> 22:15.510
这样子

22:16.510 --> 22:17.510
现在呢

22:17.510 --> 22:18.510
中间加了一个

22:18.510 --> 22:19.510
形成了一套圆形链

22:20.510 --> 22:21.510
所以说他仍然是一个数组

22:21.510 --> 22:23.510
他仍然可以用这里边的东西

22:23.510 --> 22:24.510
但是如果说你用到

22:24.510 --> 22:25.510
什么proto

22:26.510 --> 22:27.510
用到sort

22:27.510 --> 22:28.510
他就会变成他的

22:28.510 --> 22:29.510
他里边的东西

22:29.510 --> 22:30.510
明儿的意思

22:31.510 --> 22:33.510
这是对于数组的处理方式

22:33.510 --> 22:35.510
而由于种种原因

22:35.510 --> 22:36.510
数组

22:36.510 --> 22:38.510
它是监控不到数组里边的属性的

22:38.510 --> 22:39.510
所以说

22:39.510 --> 22:40.510
如果说你去做了这么一件事

22:42.950 --> 22:44.950
签计first

22:44.950 --> 22:45.950
改变数组的第一项

22:45.950 --> 22:46.950
你去做这么一件事

22:46.950 --> 22:47.950
它是监控不到的

22:48.950 --> 22:49.950
AR0

22:49.950 --> 22:51.950
给这个某一个下标

22:51.950 --> 22:54.950
就是给某一个元素重新复制

22:54.950 --> 22:55.950
它监控不到

22:56.950 --> 22:57.950
它是监控不到的

22:57.950 --> 22:59.950
比方说给它变成一版

22:59.950 --> 23:00.950
你看吧

23:01.950 --> 23:02.950
刷新

23:02.950 --> 23:03.950
签计first

23:04.950 --> 23:05.950
变没变

23:05.950 --> 23:06.950
它变的

23:06.950 --> 23:07.950
它数据肯定是变的

23:07.950 --> 23:08.950
数据是跑不掉的

23:09.950 --> 23:10.950
我们的AR

23:11.950 --> 23:12.950
所以变了一版

23:12.950 --> 23:13.950
界面不知道

23:13.950 --> 23:14.950
它不知道的改了

23:14.950 --> 23:15.950
它就是什么意思

23:15.950 --> 23:17.950
它监控不到的下标复制

23:18.950 --> 23:19.950
它监控不到的

23:22.950 --> 23:23.950
那么怎么办呢

23:23.950 --> 23:25.950
那这个玩意怎么办呢

23:25.950 --> 23:27.950
那我们还是可以用set

23:28.950 --> 23:30.950
set什么AR

23:30.950 --> 23:31.950
哪个属性

23:31.950 --> 23:32.950
0这个属性

23:32.950 --> 23:33.950
重新复制为啥

23:33.950 --> 23:34.950
100

23:34.950 --> 23:35.950
这样它就能监控到了

23:35.950 --> 23:36.950
对吧

23:36.950 --> 23:37.950
签计first

23:37.950 --> 23:38.950
它就能监控到了

23:38.950 --> 23:39.950
就这么个意思

23:40.950 --> 23:41.950
这些数据

23:41.950 --> 23:43.950
那如果说是这种情况了

23:43.950 --> 23:44.950
比方说这里是个对象

23:44.950 --> 23:45.950
对象里边

23:48.950 --> 23:49.950
我能不能这样子

23:49.950 --> 23:50.950
它这样子能不能监控到

23:50.950 --> 23:52.950
看着AR0

23:52.950 --> 23:53.950
D2

23:53.950 --> 23:54.950
N

23:54.950 --> 23:57.330
变成

23:58.330 --> 23:59.330
它能不能监控到了

24:00.330 --> 24:01.330
这样子是可以的

24:01.330 --> 24:02.330
为什么

24:02.330 --> 24:03.330
因为这个对象

24:03.330 --> 24:04.330
它是响音式的

24:04.330 --> 24:05.330
我们之前演示过的吧

24:05.330 --> 24:06.330
只要遇到对象

24:06.330 --> 24:07.330
它一定是响音式的

24:07.330 --> 24:08.330
还会深度变的

24:08.330 --> 24:10.330
它只是监控不到啥

24:10.330 --> 24:12.330
它只是监控不到

24:12.330 --> 24:14.330
直接给输出某一个下标

24:14.330 --> 24:16.330
像这种它监控不到

24:16.330 --> 24:17.330
但是呢

24:17.330 --> 24:18.330
对输出里边

24:18.330 --> 24:20.330
某一个对象的东西复制

24:20.330 --> 24:21.330
它仍然可以监控到

24:21.330 --> 24:22.330
它只是监控不到

24:22.330 --> 24:24.330
对一个下标直接复制

24:24.330 --> 24:25.330
明白了意思吗

24:25.330 --> 24:26.330
好

24:26.330 --> 24:27.330
放心

24:27.330 --> 24:28.330
签计first

24:28.330 --> 24:29.330
看是不是可以监控到

24:29.330 --> 24:30.330
就这么个意思

24:30.330 --> 24:31.330
这就是

24:32.330 --> 24:34.330
它做的事情

24:34.330 --> 24:35.330
说来说去

24:35.330 --> 24:36.330
说了那么多细节

24:36.330 --> 24:38.330
说来说去就只有一件事

24:38.330 --> 24:39.330
它把一个普通的对象

24:39.330 --> 24:41.330
让它所有的属性

24:41.330 --> 24:43.330
尽量的都变成一个响音式的

24:43.330 --> 24:45.330
读取属性

24:45.330 --> 24:47.330
改变属性

24:47.330 --> 24:49.330
可以受到通知

24:49.330 --> 24:51.330
如果说你要征新增属性

24:51.330 --> 24:52.330
或者是

24:52.330 --> 24:53.330
删除属性的话

24:53.330 --> 24:54.330
你要用它特有的方法

24:54.330 --> 24:55.330
才能完成

24:55.330 --> 24:56.330
好

24:56.330 --> 24:57.330
这是针对那个

24:57.330 --> 24:59.330
Observer就讲完了

24:59.330 --> 25:01.330
那么你可以看一下

25:01.330 --> 25:02.330
这个文档

25:02.330 --> 25:03.330
面设时候你可以组织一下

25:03.330 --> 25:04.330
字的语言把这个意思说到

25:04.330 --> 25:05.330
按照这个文档

25:05.330 --> 25:06.330
把这个意思说到

25:06.330 --> 25:07.330
你不要去背

25:07.330 --> 25:08.330
文档你背不住的

25:08.330 --> 25:09.330
这是Observer做的事

25:09.330 --> 25:11.330
好 今天我们先看下一个

25:11.330 --> 25:12.330
叫Dep

25:12.330 --> 25:14.330
这些可能反正不是很好讲

25:14.330 --> 25:16.330
一是不好讲

25:16.330 --> 25:17.330
二是不好理解

25:17.330 --> 25:19.330
东西比较深

25:21.330 --> 25:22.330
Dep

25:22.330 --> 25:24.330
这个玩意是啥

25:24.330 --> 25:26.330
你看前边

25:26.330 --> 25:28.330
它把它编成了这个东西了

25:28.330 --> 25:29.330
那你说

25:29.330 --> 25:31.330
它get的时候要做啥

25:31.330 --> 25:32.330
要做啥

25:32.330 --> 25:33.330
你说它要做啥吗

25:33.330 --> 25:35.330
那set的时候要做啥

25:35.330 --> 25:36.330
要做啥

25:36.330 --> 25:37.330
set很简单

25:37.330 --> 25:38.330
我重新运行Render

25:38.330 --> 25:39.330
那运行哪一个组件

25:39.330 --> 25:40.330
哪一个Render

25:40.330 --> 25:41.330
你知道吗

25:42.330 --> 25:43.330
来吧

25:43.330 --> 25:44.330
set就是一个函数

25:45.330 --> 25:46.330
我这里就简单写下

25:46.330 --> 25:48.330
现在你写

25:48.330 --> 25:49.330
你来填空

25:49.330 --> 25:50.330
这是一个set函数

25:50.330 --> 25:51.330
它都有传了一个新的值

25:52.330 --> 25:54.330
来吧你说

25:55.330 --> 25:56.330
这里要跟

25:56.330 --> 25:58.330
比方说你要运行Render

25:58.330 --> 25:59.330
运行Render函数

26:00.330 --> 26:01.330
那你说怎么运行

26:02.330 --> 26:03.330
你来吧

26:03.330 --> 26:04.330
你不可能直接写个Render

26:04.330 --> 26:05.330
哪个Render

26:05.330 --> 26:06.330
有这么多组件

26:06.330 --> 26:07.330
每个组件都有Render

26:07.330 --> 26:08.330
运行哪个组件

26:08.330 --> 26:09.330
哪个Render

26:09.330 --> 26:10.330
你知道吗

26:11.330 --> 26:12.330
根本就不知道

26:12.330 --> 26:13.330
而且它真的是

26:13.330 --> 26:14.330
只运行Render吗

26:14.330 --> 26:15.330
我们说了

26:15.330 --> 26:17.330
想用式的

26:17.330 --> 26:19.330
核心目标是什么

26:19.330 --> 26:20.330
set

26:20.330 --> 26:22.330
当我们数据变化的时候

26:22.330 --> 26:25.330
会运行某一些函数

26:26.330 --> 26:28.330
它不一定是一个函数

26:28.330 --> 26:29.330
它可能要运行多个函数

26:29.330 --> 26:30.330
为什么

26:30.330 --> 26:31.330
比方说

26:31.330 --> 26:33.330
我有一个Render函数的是

26:33.330 --> 26:34.330
有一个Render函数

26:34.330 --> 26:36.330
要用到了一个想用式数据

26:36.330 --> 26:37.330
还有一个Watch

26:37.330 --> 26:38.330
还有三个Watch

26:39.330 --> 26:40.330
也用到了这个数据

26:40.330 --> 26:41.330
那么这个数据变化

26:41.330 --> 26:42.330
你不得都得运行吗

26:43.330 --> 26:44.330
比方说有三个Watch

26:44.330 --> 26:46.330
都用到了这个数据

26:46.330 --> 26:47.330
那你这个数据变化

26:47.330 --> 26:48.330
是不是要运行Render

26:48.330 --> 26:49.330
要运行它

26:49.330 --> 26:50.330
要运行它

26:50.330 --> 26:51.330
要运行一些函数

26:51.330 --> 26:53.330
那到底运行哪些函数

26:53.330 --> 26:54.330
根本就不知道

26:55.330 --> 26:56.330
那么怎么来解决这个问题

26:56.330 --> 26:58.330
这个问题要靠Dep来解决

26:59.330 --> 27:01.330
就是你读属性的时候

27:01.330 --> 27:02.330
到底要做啥

27:02.330 --> 27:03.330
属性变化的时候

27:03.330 --> 27:04.330
到底要做啥

27:04.330 --> 27:05.330
这个问题

27:06.330 --> 27:07.330
它解决不了

27:07.330 --> 27:08.330
它只是负责表

27:08.330 --> 27:09.330
它变成这种格式

27:09.330 --> 27:12.330
至少我能做啥

27:12.330 --> 27:13.330
但是做啥我不知道

27:13.330 --> 27:14.330
那么这个问题

27:14.330 --> 27:15.330
要靠Dep来解决

27:15.330 --> 27:16.330
它怎么解决呢

27:16.330 --> 27:17.330
Dep的含义叫做Dependency

27:17.330 --> 27:18.330
表示依赖的意思

27:19.330 --> 27:21.330
它是这个样子的

27:21.330 --> 27:22.330
VU

27:22.330 --> 27:23.330
它在把它变成

27:23.330 --> 27:24.330
响应式对象的时候

27:24.330 --> 27:25.330
就它这一步

27:25.330 --> 27:26.330
它把它变成

27:26.330 --> 27:27.330
响应式对象的时候

27:27.330 --> 27:29.330
它会对每一个属性

27:30.330 --> 27:31.330
对象本身

27:31.330 --> 27:32.330
属主本身

27:32.330 --> 27:34.330
创建一个Dep实力

27:34.330 --> 27:35.330
啥意思

27:35.330 --> 27:36.330
这啥意思

27:40.410 --> 27:42.410
我们用这种方式

27:42.410 --> 27:43.410
给大家讲吧

27:44.410 --> 27:45.410
比方说

27:45.410 --> 27:46.410
我们有一个对象

27:46.410 --> 27:49.230
A为1

27:50.230 --> 27:51.230
B为2

27:52.230 --> 27:53.230
C是一个属主

27:55.540 --> 27:56.540
属主里面1,2,3

27:56.540 --> 27:57.540
属主

27:58.540 --> 27:59.540
D又是一个对象

28:01.980 --> 28:02.980
对象里面有A为1

28:03.980 --> 28:04.980
B为2

28:04.980 --> 28:05.980
看着

28:06.980 --> 28:08.980
把这个对象交给Observer

28:09.980 --> 28:10.980
交给Observer之后

28:10.980 --> 28:11.980
它是不是变成一个响应式数据了

28:11.980 --> 28:13.980
变成响应式数据过后

28:13.980 --> 28:15.980
它会为每一个需要

28:15.980 --> 28:16.980
响应的地方

28:16.980 --> 28:18.980
添加一个Dep对象

28:18.980 --> 28:19.980
Dep对象一会要干嘛

28:19.980 --> 28:20.980
我们一会再说

28:20.980 --> 28:22.980
它会添加哪几个呢

28:22.980 --> 28:23.980
首先这个对象

28:23.980 --> 28:24.980
它会有一个Dep

28:25.980 --> 28:26.980
它会有一个Dep

28:27.980 --> 28:28.980
这个属性

28:28.980 --> 28:29.980
它会有一个Dep

28:29.980 --> 28:30.980
都不一样的

28:30.980 --> 28:31.980
它们都是不同的对象

28:32.980 --> 28:34.980
然后这个属性有一个Dep

28:35.980 --> 28:36.980
这是一个属主

28:36.980 --> 28:38.980
属主里面就只有一个Dep

28:38.980 --> 28:40.980
除非它的属性是对象

28:40.980 --> 28:41.980
那么对象里面又要有Dep

28:41.980 --> 28:43.980
但是如果说不是对象的话

28:43.980 --> 28:44.980
那么就是属主本身有一个Dep

28:45.980 --> 28:46.980
这叫属主本身

28:46.980 --> 28:47.980
那么D呢

28:47.980 --> 28:48.980
它是一个对象

28:48.980 --> 28:49.980
它本身有个Dep

28:49.980 --> 28:51.980
然后有个属性

28:51.980 --> 28:52.980
它有个Dep

28:52.980 --> 28:53.980
属性B有个Dep

28:53.980 --> 28:55.980
这Dep用来干嘛的

28:55.980 --> 28:57.980
它就在观察

28:57.980 --> 28:58.980
它就在看

28:58.980 --> 29:00.980
到底是谁用到了我

29:01.980 --> 29:02.980
就这么个意思

29:02.980 --> 29:04.980
它是来做依赖收集的

29:04.980 --> 29:05.980
它来做两件事情

29:05.980 --> 29:06.980
一个是纪录依赖

29:06.980 --> 29:07.980
就是谁在用我

29:08.980 --> 29:09.980
第二是派发更新

29:09.980 --> 29:10.980
就是我变了

29:10.980 --> 29:11.980
我要通知谁

29:12.980 --> 29:13.980
它有两个事情要做

29:14.980 --> 29:15.980
所以说当我们

29:15.980 --> 29:16.980
读取想应对象的

29:16.980 --> 29:17.980
某一个属性的时候

29:17.980 --> 29:18.980
它就会纪录依赖

29:18.980 --> 29:19.980
这个人用到了我

29:20.980 --> 29:21.980
当我们改变某一个属性的时候

29:21.980 --> 29:22.980
它就会派发更新

29:23.980 --> 29:24.980
那些用我的人

29:24.980 --> 29:25.980
听好了

29:25.980 --> 29:26.980
我已经变了

29:27.980 --> 29:28.980
它在用这个属性的时候

29:28.980 --> 29:29.980
它会纪录依赖

29:30.980 --> 29:31.980
谁它的时候

29:31.980 --> 29:32.980
它会派发更新

29:32.980 --> 29:33.980
明儿这意思吧

29:33.980 --> 29:34.980
好

29:34.980 --> 29:35.980
咱们来看一个

29:35.980 --> 29:36.980
实际的一个效果

29:36.980 --> 29:37.980
其实跟这个例子的

29:37.980 --> 29:40.980
就已经能够很好的说明这一点了

29:41.980 --> 29:42.980
我们这个玩意儿

29:43.980 --> 29:44.980
最终会成为什么

29:44.980 --> 29:45.980
是不是成为Render

29:46.980 --> 29:47.980
会成为Render函数

29:48.980 --> 29:49.980
对不对

29:49.980 --> 29:50.980
那么Render函数里面是咋写的呢

29:51.980 --> 29:52.980
Render函数里面就这样子写的

29:53.980 --> 29:54.980
Render函数

29:55.980 --> 29:56.980
简单写一下个伟代

29:58.980 --> 29:59.980
Render函数返回什么呢

29:59.980 --> 30:01.980
返回一个H

30:01.980 --> 30:02.980
DIV

30:02.980 --> 30:04.980
DIV里面有啥呀

30:05.980 --> 30:06.980
就是你们看模板

30:06.980 --> 30:07.980
要看它的本质是咋

30:07.980 --> 30:08.980
本质是不是就是Render

30:08.980 --> 30:10.980
DIV里面有很多指源数

30:10.980 --> 30:11.980
第一个指源数是咋呀

30:11.980 --> 30:12.980
H

30:13.980 --> 30:14.980
H1

30:14.980 --> 30:16.980
H1里面用是咋呀

30:16.980 --> 30:17.980
是这个

30:17.980 --> 30:18.980
用到了

30:18.980 --> 30:19.980
里面是一个字不串

30:19.980 --> 30:20.980
它的指源数是一个字不串

30:20.980 --> 30:21.980
字不串里面

30:22.980 --> 30:23.980
写一大堆

30:23.980 --> 30:24.980
然后这里有一个什么

30:24.980 --> 30:26.980
OB界点A

30:27.980 --> 30:28.980
是不是这个东西跑这来了

30:29.980 --> 30:30.980
那么说明是不是这个函数

30:30.980 --> 30:31.980
它用到了它

30:31.980 --> 30:32.980
对不对

30:32.980 --> 30:33.980
就这个意思

30:33.980 --> 30:34.980
那么它就会记录一代

30:34.980 --> 30:35.980
谁用到了我

30:35.980 --> 30:36.980
Render用到了我

30:36.980 --> 30:37.980
明白了意思吧

30:38.980 --> 30:39.980
好 所以说你看这个模板

30:39.980 --> 30:40.980
你应该怎么看

30:40.980 --> 30:42.980
就是我这个模板中用到了谁

30:42.980 --> 30:43.980
用到了这个A

30:43.980 --> 30:44.980
用到了这个B对吧

30:44.980 --> 30:46.980
我要把模板渲染出来

30:46.980 --> 30:47.980
渲染这个模板的过程中

30:47.980 --> 30:49.980
是不是必须要有A

30:49.980 --> 30:50.980
必须要有B

30:50.980 --> 30:51.980
对不对

30:51.980 --> 30:52.980
那么也就说

30:52.980 --> 30:53.980
Render函数它用到了什么

30:53.980 --> 30:54.980
用到了A

30:54.980 --> 30:55.980
用到了B

30:55.980 --> 30:56.980
我们就认为

30:56.980 --> 30:58.980
对于数向A

30:58.980 --> 30:59.980
对于数向A

30:59.980 --> 31:00.980
它记录了一个依赖

31:00.980 --> 31:01.980
谁依赖我

31:01.980 --> 31:02.980
Render函数

31:02.980 --> 31:03.980
对于数向B

31:03.980 --> 31:05.980
它又记录了一个依赖

31:05.980 --> 31:06.980
它就Render函数用到了我

31:06.980 --> 31:07.980
那么发生了个格式的话

31:07.980 --> 31:08.980
就这样子

31:11.870 --> 31:12.870
看着

31:13.870 --> 31:19.960
它会怎么来记录呢

31:20.960 --> 31:21.960
放个行

31:21.960 --> 31:29.840
放个行

31:29.840 --> 31:30.840
好 假设我们这里

31:30.840 --> 31:31.840
还有一个属性

31:32.840 --> 31:34.840
假设我们这里还有一个属性

31:35.840 --> 31:37.840
K 等于3

31:37.840 --> 31:38.840
好吧

31:38.840 --> 31:39.840
我们这里的价格八成

31:39.840 --> 31:43.840
Change

31:43.840 --> 31:44.840
K

31:44.840 --> 31:45.840
好 我们这里的

31:45.840 --> 31:46.840
给它做出个实验

31:47.840 --> 31:48.840
Click

31:48.840 --> 31:49.840
K加加

31:49.840 --> 31:51.840
好 来看吧

31:51.840 --> 31:52.840
我们的模板中

31:52.840 --> 31:54.840
用到了我们这里还有一个K

31:54.840 --> 31:55.840
等于3

31:56.840 --> 31:57.840
我们的模板的渲染过程中

31:57.840 --> 31:58.840
它要用到什么数据

31:58.840 --> 31:59.840
它首先要用到OB界

31:59.840 --> 32:01.840
你看 是不是在读取OB界

32:01.840 --> 32:03.840
OB界的Gate 是不是会运行

32:04.840 --> 32:05.840
看啊

32:06.840 --> 32:07.840
Gate是不是会运行

32:07.840 --> 32:08.840
Gate是不是会运行

32:08.840 --> 32:09.840
只要Gate运行

32:09.840 --> 32:10.840
它会记录遗难

32:10.840 --> 32:11.840
它会记录

32:11.840 --> 32:13.840
原来这个OB界里面

32:13.840 --> 32:14.840
是不是有一个Dep

32:14.840 --> 32:15.840
Dep会记录

32:15.840 --> 32:16.840
有一个东西

32:16.840 --> 32:18.840
谁 Render

32:18.840 --> 32:19.840
它在遗难

32:19.840 --> 32:20.840
遗难这个OB界

32:21.840 --> 32:22.840
那么这个OB界里面

32:22.840 --> 32:23.840
有个E

32:23.840 --> 32:24.840
E等于E

32:24.840 --> 32:25.840
它是不是在用E

32:25.840 --> 32:26.840
Es也是一个属性

32:26.840 --> 32:27.840
它里面也有一个Dep

32:27.840 --> 32:28.840
它会记录

32:28.840 --> 32:29.840
有个方法

32:29.840 --> 32:30.840
Render

32:30.840 --> 32:31.840
它的用到了我

32:32.840 --> 32:33.840
它就会记录下来

32:33.840 --> 32:34.840
比如说Gate运行的时候

32:34.840 --> 32:35.840
会做什么事情

32:35.840 --> 32:36.840
就会做这件事情

32:36.840 --> 32:37.840
它会记录谁在用我

32:38.840 --> 32:39.840
Render在用我

32:40.840 --> 32:41.840
那么

32:41.840 --> 32:42.840
应该在这

32:42.840 --> 32:43.840
这才是代码

32:44.840 --> 32:45.840
那么这个OB界B

32:45.840 --> 32:46.840
是不是又来记录

32:46.840 --> 32:47.840
又读到OB界了

32:47.840 --> 32:48.840
是不是又要记录

32:48.840 --> 32:49.840
Render在用了OB界

32:49.840 --> 32:50.840
Render已经记录了

32:50.840 --> 32:51.840
它就不会再记录了

32:51.840 --> 32:52.840
不会重新记录

32:53.840 --> 32:54.840
它这里是一个列表

32:54.840 --> 32:55.840
它不是说记录一个函数

32:55.840 --> 32:57.840
因为有可能还有别的在用它

32:57.840 --> 32:58.840
比方说还有一个Warch

32:59.840 --> 33:00.840
Warch函数

33:00.840 --> 33:01.840
也有可能会

33:01.840 --> 33:02.840
Warch的时候

33:02.840 --> 33:03.840
我们运行一个回调函数

33:03.840 --> 33:04.840
回调函数里面

33:04.840 --> 33:05.840
是不是也有可能会用到它

33:05.840 --> 33:07.840
因为它可能有很多东西

33:07.840 --> 33:08.840
依赖它

33:08.840 --> 33:09.840
只不过我们最常见的是Render

33:09.840 --> 33:11.840
我这里就是说Render

33:11.840 --> 33:13.840
好 接下来我下看

33:14.840 --> 33:15.840
接下来

33:15.840 --> 33:16.840
这个代码是没有运行的

33:16.840 --> 33:18.840
在渲染的时候是没有运行的

33:18.840 --> 33:19.840
是要点击过后才运行

33:19.840 --> 33:20.840
渲染的时候是不会运行的

33:20.840 --> 33:21.840
所以说这个东西

33:21.840 --> 33:22.840
直接忽略

33:22.840 --> 33:23.840
事件里面东西直接忽略

33:23.840 --> 33:24.840
好 这里

33:24.840 --> 33:26.840
在循环ARR是吧

33:26.840 --> 33:27.840
那么这个ARR里面

33:27.840 --> 33:28.840
是不是有Dep

33:33.010 --> 33:38.370
这个ARR是不是有Dep

33:38.370 --> 33:39.370
那么这个Dep里面

33:39.370 --> 33:41.370
它是不是也要记录Render

33:41.370 --> 33:43.370
好 那么下面

33:43.370 --> 33:45.370
我们循环这个就不说了

33:45.370 --> 33:48.380
循环

33:48.380 --> 33:50.380
然后这边

33:50.380 --> 33:52.380
我们就全部改成数字

33:52.380 --> 33:53.380
改成数字

33:53.380 --> 33:54.380
我们把这个问题说清楚

33:54.380 --> 33:55.380
一

33:55.380 --> 34:04.040
截去first

34:04.040 --> 34:05.040
这个不要了

34:06.040 --> 34:09.040
好 接下来我们继续往下看

34:09.040 --> 34:10.040
下面的K

34:12.040 --> 34:13.040
用到了K吗

34:13.040 --> 34:14.040
有没有用到K

34:14.040 --> 34:15.040
并没有用到K

34:15.040 --> 34:17.040
它要点击过后才会使用K

34:17.040 --> 34:18.040
渲染的时候

34:18.040 --> 34:19.040
我们只看渲染的时候

34:19.040 --> 34:20.040
需要K吗

34:20.040 --> 34:21.040
不需要

34:21.040 --> 34:22.040
K的它的Dep是没有

34:22.040 --> 34:24.040
没有记录任何东西的

34:24.040 --> 34:25.040
整个过程就是这样子

34:25.040 --> 34:26.040
它变成这个样子

34:27.040 --> 34:28.040
于是呢

34:28.040 --> 34:30.040
将来我们去改变的时候

34:30.040 --> 34:31.040
比方说我改变了

34:31.040 --> 34:32.040
就调用了数组的

34:32.040 --> 34:33.040
护洗方法

34:33.040 --> 34:34.040
是改动了数组

34:34.040 --> 34:35.040
改动了数组

34:35.040 --> 34:37.040
它就会重新运行Render

34:37.040 --> 34:38.040
改动了这个A

34:38.040 --> 34:40.040
也会重新运行Render

34:40.040 --> 34:41.040
那么删除这个A

34:41.040 --> 34:42.040
删除这个A的时候

34:42.040 --> 34:44.040
它出发的是这个

34:44.040 --> 34:45.040
出发的这个OB界

34:45.040 --> 34:46.040
OB界它会

34:46.040 --> 34:48.040
因为之前记录了这个Render

34:48.040 --> 34:50.040
它也会运行Render

34:50.040 --> 34:52.040
它添加了这个B过后

34:52.040 --> 34:54.040
添加了这个B过后

34:54.040 --> 34:55.040
那么它出发的

34:55.040 --> 34:57.040
也是这个OB界的依赖

34:57.040 --> 34:59.040
那么它也会运行Render

34:59.040 --> 35:00.040
就要派发重新

35:00.040 --> 35:01.040
看了再看这张图

35:01.040 --> 35:03.040
Get的时候记录依赖

35:03.040 --> 35:04.040
Set的时候

35:04.040 --> 35:05.040
它不一定是Set

35:05.040 --> 35:06.040
有可能是

35:06.040 --> 35:07.040
用set啊

35:07.040 --> 35:08.040
用delete啊

35:08.040 --> 35:09.040
或者是用数组的护洗

35:09.040 --> 35:10.040
它都会派发重新

35:10.040 --> 35:11.040
原来的意思吧

35:11.040 --> 35:13.040
所以说我们才能得到

35:13.040 --> 35:14.040
看着啊

35:14.040 --> 35:15.040
删除A

35:16.040 --> 35:17.040
删除A

35:17.040 --> 35:18.040
它能收到通知

35:18.040 --> 35:19.040
因为它重新运行Render

35:19.040 --> 35:20.040
重新运行Render

35:20.040 --> 35:21.040
是不是就重新

35:21.040 --> 35:22.040
生产区域多么粗啊

35:22.040 --> 35:23.040
对吧

35:23.040 --> 35:25.040
那么添加B

35:25.040 --> 35:27.040
是不是也会出发这个

35:27.040 --> 35:28.040
重新运行

35:28.040 --> 35:29.040
当然了

35:29.040 --> 35:30.040
如果说我们改动A

35:30.040 --> 35:31.040
那毫无疑问

35:31.040 --> 35:32.040
没问题

35:32.040 --> 35:33.040
删除A

35:33.040 --> 35:34.040
A

35:34.040 --> 35:35.040
A3

35:38.040 --> 35:39.040
WMOB界

35:39.040 --> 35:40.040
A

35:40.040 --> 35:41.040
A3

35:41.040 --> 35:42.040
所以也可以

35:42.040 --> 35:43.040
那么它就会出发这个Render

35:43.040 --> 35:44.040
出发这个遗难

35:44.040 --> 35:45.040
在这里出发

35:45.040 --> 35:46.040
派发重新

35:46.040 --> 35:47.040
它也会运行Render

35:47.040 --> 35:48.040
它就这么一个意思

35:48.040 --> 35:49.040
它就起这么一个作用

35:49.040 --> 35:50.040
它是用来记录的

35:50.040 --> 35:51.040
好

35:51.040 --> 35:52.040
同样的

35:52.040 --> 35:53.040
我们改动数组

35:53.040 --> 35:54.040
resource

35:55.040 --> 35:56.040
resource的时候

35:56.040 --> 35:57.040
是不是它出发了

35:57.040 --> 35:58.040
一个数组的Render

35:58.040 --> 35:59.040
出发这个数组的遗难

35:59.040 --> 36:00.040
派发重新

36:00.040 --> 36:01.040
那么就会运行Render

36:02.040 --> 36:03.040
好

36:03.040 --> 36:04.040
现在我们签几K

36:04.040 --> 36:05.040
改变K的时候

36:05.040 --> 36:06.040
还会不会运行

36:06.040 --> 36:07.040
改变K

36:07.040 --> 36:08.040
有没有运行

36:08.040 --> 36:09.040
并没有运行

36:09.040 --> 36:10.040
但是有没有改变K

36:10.040 --> 36:11.040
肯定是改变了

36:11.040 --> 36:12.040
数据肯定是变了

36:12.040 --> 36:13.040
你看K

36:13.040 --> 36:14.040
所以变成11了

36:14.040 --> 36:15.040
对吧

36:15.040 --> 36:16.040
签几K

36:16.040 --> 36:17.040
再点了几下

36:17.040 --> 36:19.040
再看一下VM.K

36:19.040 --> 36:20.040
说15了

36:20.040 --> 36:21.040
数据变了

36:21.040 --> 36:22.040
但是由于K里边

36:22.040 --> 36:24.040
它没有收集到这个遗难

36:24.040 --> 36:26.040
就是Render它并不遗难这个K

36:26.040 --> 36:28.040
就是我的界面并不用不到这个K

36:28.040 --> 36:30.040
所以说它就不会出发界面更新

36:30.040 --> 36:31.040
那么这样子

36:31.040 --> 36:32.040
是不是为了提高效率的

36:32.040 --> 36:33.040
对吧

36:33.040 --> 36:34.040
收集我要用到的东西

36:34.040 --> 36:35.040
跟我无关的东西

36:35.040 --> 36:36.040
你变化就变化了

36:36.040 --> 36:37.040
跟我没关系

36:38.040 --> 36:39.040
注意它不一定是Render

36:39.040 --> 36:40.040
还是说它又可能是Watch

36:40.040 --> 36:41.040
它可能是别的东西

36:41.040 --> 36:42.040
都是这样子的

36:42.040 --> 36:44.040
就这个函数里边用到了什么

36:44.040 --> 36:45.040
只有用到的东西变了

36:45.040 --> 36:46.040
我才会出发更新

36:47.040 --> 36:49.040
这是Depth它的作用

36:50.040 --> 36:52.040
那么这里能我有一个小的问题

36:52.040 --> 36:53.040
问大家

36:58.040 --> 36:59.040
这个问题它不一定

36:59.040 --> 37:00.040
不是那么好看得到

37:00.040 --> 37:02.040
看得到这个效果

37:02.040 --> 37:03.040
我就问这么一个问题

37:03.040 --> 37:05.040
我这里没有写这句话

37:06.040 --> 37:08.040
当我点击这个按钮的时候

37:08.040 --> 37:10.040
给对象添加了

37:10.040 --> 37:12.040
添加了一个属性B

37:13.040 --> 37:15.040
会不会重新选择

37:16.040 --> 37:17.040
会不会重新选择

37:19.040 --> 37:20.040
你回答一下

37:21.040 --> 37:22.040
会不会

37:22.040 --> 37:23.040
会

37:23.040 --> 37:24.040
主要是会的

37:24.040 --> 37:25.040
也同样说

37:25.040 --> 37:26.040
那就怪了

37:26.040 --> 37:27.040
我这界面上没有用到B

37:27.040 --> 37:28.040
你添加一个B

37:28.040 --> 37:29.040
跟我有啥关系呢

37:29.040 --> 37:30.040
是

37:30.040 --> 37:31.040
但是它没办法

37:31.040 --> 37:32.040
它没有办法

37:32.040 --> 37:33.040
为什么呢

37:33.040 --> 37:34.040
你看

37:34.040 --> 37:35.040
界面上虽然没有用到B

37:35.040 --> 37:36.040
它就没有用到OB界

37:37.040 --> 37:38.040
有没有用到OB界

37:38.040 --> 37:40.040
OB界是不是有一个Dep

37:40.040 --> 37:42.040
记录了一个Render

37:42.040 --> 37:44.040
当你往OB界加一个属性的时候

37:44.040 --> 37:45.040
它触发的是谁

37:45.040 --> 37:47.040
触发的是它的Render

37:47.040 --> 37:48.040
触发的不是B的

37:48.040 --> 37:50.040
现在B都没存在

37:50.040 --> 37:51.040
不存在

37:51.040 --> 37:52.040
根本就不可能手机依赖

37:52.040 --> 37:54.040
所以它触发的是它的

37:54.040 --> 37:56.040
明儿的意思吧

37:56.040 --> 37:57.040
所以说

37:57.040 --> 37:58.040
仍然会运行

37:58.040 --> 38:00.040
怎么来证明这一点呢

38:00.040 --> 38:02.040
因为我现在也看不到

38:02.040 --> 38:03.040
看不到这个效果

38:03.040 --> 38:04.040
我现在界面上没有B了

38:04.040 --> 38:05.040
看不到这个效果

38:05.040 --> 38:06.040
怎么来证明这一点呢

38:06.040 --> 38:07.040
我们看着

38:08.040 --> 38:10.420
我讲的很细啊

38:10.420 --> 38:11.420
这一块

38:11.420 --> 38:13.420
就希望了你了解得更加

38:13.420 --> 38:14.420
深入一点

38:14.420 --> 38:15.420
我们把显示Render喊出

38:15.420 --> 38:16.420
就非常紧

38:16.420 --> 38:17.420
看得非常清楚了

38:17.420 --> 38:18.420
输出一个Render

38:20.420 --> 38:21.420
然后返回来是什么呢

38:21.420 --> 38:22.420
返回来就是H

38:22.420 --> 38:24.420
就返回一个H1元素吧

38:24.420 --> 38:26.420
返回来还是返回一个DIV吧

38:26.420 --> 38:28.420
DIV里面有两个指源数

38:28.420 --> 38:29.420
第一个指源数是一个H1

38:29.420 --> 38:31.420
H1里面显示啥呢

38:31.420 --> 38:34.420
显示的是OB界

38:34.420 --> 38:36.420
OB界叫A等于

38:36.420 --> 38:37.420
OB界叫A

38:37.420 --> 38:38.420
它只显示A

38:38.420 --> 38:39.420
它不显示B

38:39.420 --> 38:40.420
然后呢

38:40.420 --> 38:42.420
下面有一个按钮

38:45.420 --> 38:47.420
按钮的文字是

38:47.420 --> 38:48.420
ADDD

38:49.420 --> 38:51.420
然后按钮组成一个事件

38:52.420 --> 38:53.420
Click

38:53.420 --> 38:55.420
其实我就把模板的代码写到这儿来了

38:55.420 --> 38:56.420
写一段

38:56.420 --> 38:57.420
点击的时候干嘛呀

38:57.420 --> 39:00.420
我要去给它加一个属性B

39:00.420 --> 39:03.420
怎么加ZS

39:03.420 --> 39:05.420
哪个对象ZS OBGN

39:05.420 --> 39:06.420
对吧

39:06.420 --> 39:08.420
往对象里面加一个属性

39:08.420 --> 39:10.420
哪个属性B

39:10.420 --> 39:11.420
指示什么

39:11.420 --> 39:13.420
指示123吧

39:13.420 --> 39:15.420
好你看我加的属性是B

39:15.420 --> 39:16.420
我选择是有没有用到B

39:16.420 --> 39:17.420
没有

39:19.420 --> 39:20.420
OB界是 not defined

39:20.420 --> 39:22.420
这个是ZS OBGN

39:23.420 --> 39:24.420
好

39:25.420 --> 39:26.420
是不是有运点

39:27.420 --> 39:29.420
为什么就这个原因

39:29.420 --> 39:30.420
因为它虽然没有1代B

39:30.420 --> 39:31.420
它是1代的OB界

39:31.420 --> 39:33.420
而你加属性的时候

39:33.420 --> 39:35.420
它触发的是OB界的东西

39:35.420 --> 39:36.420
这一块

39:36.420 --> 39:37.420
所以说

39:37.420 --> 39:38.420
为什么我用它建议你

39:38.420 --> 39:41.420
不要去随便用ZS

39:41.420 --> 39:43.420
不要去用这些东西

39:45.420 --> 39:46.420
那么比方说

39:47.420 --> 39:48.420
那么比方说是一样的道理

39:48.420 --> 39:50.420
如果说它有一个属性C

39:52.420 --> 39:53.420
那我这里把属性C删除了

39:53.420 --> 39:55.420
它也是要发生变化的

39:56.420 --> 39:57.420
删除属性C

39:58.420 --> 40:00.420
虽然还没有用到属性C

40:00.420 --> 40:04.580
删除属性C

40:04.580 --> 40:05.580
你看是不是也有人的

40:06.580 --> 40:07.580
它也要重新运行

40:07.580 --> 40:08.580
对吧

40:08.580 --> 40:09.580
但是我改变K就不会

40:16.410 --> 40:18.410
改变K是不是也没有重新运动

40:18.410 --> 40:19.410
对吧

40:19.410 --> 40:20.410
所以说我又建议你了

40:20.410 --> 40:22.410
就尽量不要除非迫不得力

40:22.410 --> 40:23.410
不要去用这些玩意儿

40:24.410 --> 40:25.410
应该呢

40:25.410 --> 40:27.410
你如果说的一开始

40:27.410 --> 40:28.410
一开始没有B

40:28.410 --> 40:29.410
后来要有B

40:29.410 --> 40:30.410
那一开始把B定义出来

40:30.410 --> 40:32.410
让它变成想用式的

40:32.410 --> 40:33.410
哪怕你该定义为OB都行

40:33.410 --> 40:35.410
知道这个属性是想用式的

40:36.410 --> 40:37.410
对不对

40:37.410 --> 40:38.410
那以后我给B复制的

40:38.410 --> 40:39.410
就不用用这种set方式了

40:39.410 --> 40:40.410
就直接给它复制

40:40.410 --> 40:41.410
对吧

40:41.410 --> 40:42.410
那么这样子

40:42.410 --> 40:43.410
它就知道了

40:43.410 --> 40:44.410
我一个界面上有没有依赖B

40:44.410 --> 40:46.410
它只会出发B的更新

40:46.410 --> 40:48.410
它就不会出发OB界的更新了

40:48.410 --> 40:50.410
所以建议大家不要去用这些东西

40:50.410 --> 40:52.910
会影响效率的

40:54.910 --> 40:55.910
好

40:55.910 --> 40:56.910
那么这是关于这个deb

40:56.910 --> 40:57.910
它要做的事情

40:57.910 --> 40:58.910
你看

40:58.910 --> 40:59.910
这个是一年的

40:59.910 --> 41:00.910
这是非常观点

41:00.910 --> 41:01.910
非常紧密的

41:01.910 --> 41:03.910
不然复制把它变成getter setter

41:03.910 --> 41:04.910
然后

41:04.910 --> 41:06.910
同时就为每一个想用对象

41:06.910 --> 41:07.910
每一个属性

41:07.910 --> 41:08.910
每一个数组

41:08.910 --> 41:09.910
给它加上一个deb

41:09.910 --> 41:10.910
都是不一样deb

41:10.910 --> 41:12.910
那么当它读取对象

41:12.910 --> 41:13.910
读取属性

41:13.910 --> 41:14.910
读取这个数组的一些东西的时候

41:14.910 --> 41:15.910
它就会记录

41:15.910 --> 41:16.910
有东西在用到我

41:16.910 --> 41:18.910
将来我变化的时候

41:18.910 --> 41:19.910
我就会通知

41:19.910 --> 41:20.910
好就deb

41:20.910 --> 41:22.910
接下来看下一个watcher

41:22.910 --> 41:27.060
它又是接着上面的问题

41:27.060 --> 41:29.060
用题又来了

41:29.060 --> 41:30.060
deb

41:30.060 --> 41:33.060
它怎么知道是谁在用我

41:33.060 --> 41:35.060
这个就是非常神奇的地方

41:35.060 --> 41:37.060
它怎么知道是谁在用

41:37.060 --> 41:38.060
那么再看吧

41:38.060 --> 41:39.060
那你现在写

41:39.060 --> 41:40.060
现在有一个

41:40.060 --> 41:42.060
现在你再用一个getter

41:42.060 --> 41:44.060
你再写个gat寒数

41:44.060 --> 41:45.060
因为5u的代码

41:45.060 --> 41:46.060
它也是人写出来的

41:46.060 --> 41:47.060
它就是神

41:47.060 --> 41:48.060
它也不能改变

41:48.060 --> 41:50.060
监视的基本逻辑

41:50.060 --> 41:52.060
现在有一个寒数gat

41:52.060 --> 41:53.060
请问

41:53.060 --> 41:55.060
你怎么知道

41:55.060 --> 41:59.060
谁在调用这个寒数

41:59.060 --> 42:00.060
换句话说

42:00.060 --> 42:01.060
谁在使用这个属性

42:01.060 --> 42:03.060
你怎么知道

42:03.060 --> 42:04.060
你在这个寒数里边

42:04.060 --> 42:05.060
换句话说

42:05.060 --> 42:09.060
我们有一个寒数

42:09.060 --> 42:10.060
你在这个寒数里边

42:10.060 --> 42:12.060
你怎么知道是哪个寒数在用你

42:12.060 --> 42:13.060
在调用你

42:13.060 --> 42:14.060
你怎么知道

42:14.060 --> 42:16.060
你怎么知道是Render寒数在调用你

42:16.060 --> 42:17.060
还是别的寒数

42:17.060 --> 42:18.060
因为它不一定是Render

42:18.060 --> 42:19.060
有可能是别的寒数

42:19.060 --> 42:22.060
你怎么知道

42:22.060 --> 42:23.060
那怎么知道

42:23.060 --> 42:24.060
5u通过一个巧妙的办法

42:24.060 --> 42:26.060
叫做watcher

42:26.060 --> 42:27.060
它怎么来做的事情

42:27.060 --> 42:29.060
这个事情

42:29.060 --> 42:31.060
当某个寒数的执行过程中

42:31.060 --> 42:33.060
用到了响应式数据

42:33.060 --> 42:34.060
那么响应式数据

42:34.060 --> 42:35.060
它就必须要知道

42:35.060 --> 42:36.060
是谁在用自己

42:36.060 --> 42:38.060
是Render在用自己

42:38.060 --> 42:39.060
还是用别的寒数在用自己

42:39.060 --> 42:41.060
怎么来解决这个问题

42:41.060 --> 42:44.060
你就不能直接执行Render寒数

42:44.060 --> 42:45.060
这个寒数你就不能直接执行

42:45.060 --> 42:46.060
比方你

42:46.060 --> 42:47.060
一个Render寒数里边

42:47.060 --> 42:48.060
用到了一个属性

42:48.060 --> 42:49.060
这个属性里边

42:49.060 --> 42:50.060
有了一个属性

42:50.060 --> 42:51.060
它里边有一个gat

42:51.060 --> 42:52.060
gat方法

42:52.060 --> 42:54.060
然后这个属性的

42:54.060 --> 42:56.060
obj.a的gat方法

42:56.060 --> 42:58.060
那么你用到了这个obj.a

42:58.060 --> 43:00.060
是不是用到了这个gat方法

43:00.060 --> 43:01.060
你如果说

43:01.060 --> 43:02.060
直接调用Render寒数

43:02.060 --> 43:03.060
直接去调用它

43:03.060 --> 43:04.060
你是不可能知道的

43:04.060 --> 43:05.060
这个寒数里边是不可能知道

43:05.060 --> 43:07.060
是哪个寒数在用自己的

43:07.060 --> 43:08.060
那怎么办呢

43:08.060 --> 43:09.060
它是通过一个watcher东西

43:09.060 --> 43:11.060
你必须要把这个寒数交给谁

43:11.060 --> 43:12.060
交给watcher

43:12.060 --> 43:13.060
怎么说

43:13.060 --> 43:15.060
用一个watcher

43:15.060 --> 43:16.060
你把这个寒数Render寒数给它

43:16.060 --> 43:18.060
就这个意思

43:18.060 --> 43:20.060
让watcher是帮你做这件事情

43:20.060 --> 43:21.060
不然的话

43:21.060 --> 43:23.060
你肯定是不知道的

43:23.060 --> 43:25.060
那它为什么watcher就给知道的呢

43:25.060 --> 43:27.060
其实watcher本

43:27.060 --> 43:28.060
对于我们开发者而言

43:28.060 --> 43:29.060
其实就是我们

43:29.060 --> 43:31.060
平时用的那个watcher寒数

43:32.060 --> 43:33.060
就是它的内部

43:33.060 --> 43:35.060
就会创建一个watcher

43:35.060 --> 43:37.060
一个观察者

43:37.060 --> 43:39.060
那它怎么来做的呢

43:40.060 --> 43:41.060
它是这样子的

43:41.060 --> 43:43.060
watcher在执行那个寒数之前

43:43.060 --> 43:45.060
你不是给它那个寒数吗

43:45.060 --> 43:46.060
你给它一个Render寒数

43:46.060 --> 43:47.060
给它watcher

43:47.060 --> 43:48.060
它不会立即执行

43:48.060 --> 43:49.060
它执行之前

43:49.060 --> 43:51.060
会设置一个全聚变量

43:51.060 --> 43:53.060
比方说

43:53.060 --> 43:55.060
current

43:55.060 --> 43:57.060
watcher

43:57.060 --> 43:59.060
它会等于这是

43:59.060 --> 44:00.060
表示

44:00.060 --> 44:02.060
我当前那个watcher

44:02.060 --> 44:03.060
给一个全聚变量

44:03.060 --> 44:04.060
而是全聚的

44:04.060 --> 44:05.060
你可以认为

44:05.060 --> 44:06.060
当然它不是在Windows里面

44:06.060 --> 44:07.060
你可以认为它在Windows里面

44:07.060 --> 44:08.060
就一个全聚的

44:08.060 --> 44:10.060
表示

44:10.060 --> 44:12.060
接下来

44:12.060 --> 44:15.060
在执行

44:15.060 --> 44:18.500
在执行我

44:18.500 --> 44:19.500
然后再去运行

44:19.500 --> 44:21.500
你给它的Render寒数

44:21.500 --> 44:22.500
当然不一定是Render寒数

44:22.500 --> 44:23.500
可能别的寒数

44:23.500 --> 44:24.500
再去运行Render寒数

44:24.500 --> 44:26.500
在Render寒数的运行期间

44:26.500 --> 44:27.500
它是不是

44:27.500 --> 44:29.500
里面就会用到一些属性

44:29.500 --> 44:30.500
属性里面是什么

44:30.500 --> 44:32.500
属性里面就是运行Gate方法

44:32.500 --> 44:34.500
属性里面的Gate方法

44:34.500 --> 44:36.500
Gate方法是不要搜集一代

44:36.500 --> 44:37.500
搜集一代的

44:37.500 --> 44:38.500
它用的是什么搜集一代

44:38.500 --> 44:39.500
用的是Dep这个对象

44:39.500 --> 44:40.500
我之前说过

44:40.500 --> 44:41.500
Dep它用来搜集一代的

44:41.500 --> 44:42.500
它里面的寒数要Depend

44:42.500 --> 44:44.500
它用过它来搜集一代的

44:44.500 --> 44:46.500
在这个寒数里面

44:46.500 --> 44:49.500
它是不是可以检查这个全聚变量

44:49.500 --> 44:50.500
它一检查

44:50.500 --> 44:52.500
原来有一个watcher在这

44:52.500 --> 44:53.500
说明了

44:53.500 --> 44:54.500
哪个在用我

44:54.500 --> 44:56.500
哪个在用我这个属性

44:56.500 --> 44:57.500
是不是就是这个东西

44:57.500 --> 44:59.500
它就会把这个watcher记录下来

45:00.500 --> 45:02.500
好等到这个Render运行完了过后

45:02.500 --> 45:04.500
它再会把这个watcher清空

45:04.500 --> 45:06.500
基本逻辑是这样子

45:10.500 --> 45:12.500
它就保证了

45:12.500 --> 45:13.500
我这个Render寒数在运

45:13.500 --> 45:15.500
就是我给它的寒数在运行的过程中

45:15.500 --> 45:16.500
它能够搜集到

45:16.500 --> 45:17.500
从哪里搜集

45:17.500 --> 45:19.500
就通过这个全聚变量搜集

45:19.500 --> 45:21.500
所以它这个基本逻辑变成这样子了

45:21.500 --> 45:24.500
当我们读取一个属性的时候

45:24.500 --> 45:26.500
那个Dep对象

45:26.500 --> 45:27.500
它就能够知道

45:27.500 --> 45:29.500
是某一个watcher

45:29.500 --> 45:30.500
通过检查全聚变量

45:30.500 --> 45:32.500
它就知道某一个watcher在用我

45:32.500 --> 45:34.500
那个watcher里边就记录了

45:34.500 --> 45:35.500
某一个寒数对吧

45:35.500 --> 45:36.500
比较Render寒数

45:36.500 --> 45:37.500
再记录在里边

45:37.500 --> 45:38.500
等我到时候

45:38.500 --> 45:39.500
派发更新的时候

45:39.500 --> 45:40.500
我说我变了

45:40.500 --> 45:41.500
告诉谁

45:41.500 --> 45:42.500
就找到那些

45:42.500 --> 45:44.500
所有用到我的watcher

45:44.500 --> 45:45.500
有很多有可能有很多

45:45.500 --> 45:46.500
都用到这个属性了

45:46.500 --> 45:48.500
不同的寒数都可能会用到这个属性

45:48.500 --> 45:50.500
那么就告诉这些watcher

45:50.500 --> 45:51.500
我变了

45:51.500 --> 45:53.500
那么这个watcher最终

45:53.500 --> 45:54.500
它就会重新运行

45:54.500 --> 45:55.500
之前那个寒数

45:55.500 --> 45:56.500
每个watcher里边

45:56.500 --> 45:57.500
一个寒数

45:57.500 --> 45:58.500
一个watcher对应

45:58.500 --> 45:59.500
Render

45:59.500 --> 46:00.500
一个watcher对应一些自定义的寒数

46:00.500 --> 46:01.500
都有可能

46:02.500 --> 46:03.500
所以说

46:03.500 --> 46:05.500
那么它就它的基本逻辑

46:05.500 --> 46:07.500
其实在我们的主键实力里边

46:07.500 --> 46:08.500
每一个主键

46:08.500 --> 46:09.500
每个主键不都有一个Render吗

46:09.500 --> 46:10.500
每一个主键

46:10.500 --> 46:12.500
它就有一个对应的watcher

46:12.500 --> 46:13.500
怎么来证明这一点

46:13.500 --> 46:14.500
我们看一下

46:14.500 --> 46:15.500
随便找个主键

46:15.500 --> 46:16.500
随便找个主键

46:16.500 --> 46:17.500
可以

46:20.000 --> 46:21.000
时间有点早

46:22.000 --> 46:25.460
说出一下

46:27.460 --> 46:28.460
你看一下吧

46:28.460 --> 46:31.220
watcher

46:33.220 --> 46:35.220
这个watcher对应到的是谁

46:35.220 --> 46:36.220
对应到的就是

46:36.220 --> 46:38.220
那个主键的Render寒数

46:39.220 --> 46:40.220
就是Render寒数

46:40.220 --> 46:42.220
也就是我们主键的Render寒数

46:42.220 --> 46:43.220
它怎么一个流程

46:43.220 --> 46:45.220
它会把Render寒数交给谁

46:45.220 --> 46:46.220
交给watcher

46:47.220 --> 46:49.220
Render寒数交给谁

46:49.220 --> 46:50.220
交给watcher

46:50.220 --> 46:51.220
交给主键里面的watcher

46:53.220 --> 46:54.220
交给他

46:54.220 --> 46:56.220
然后由watcher去运行Render

46:56.220 --> 46:57.220
运行的过程中

46:57.220 --> 46:58.220
是不是Render里边

46:58.220 --> 46:59.220
用到了哪些属性

46:59.220 --> 47:01.220
要用到OB界点

47:01.220 --> 47:02.220
OB界点B

47:02.220 --> 47:03.220
用到了一个数组

47:03.220 --> 47:04.220
那么这些属性里边

47:04.220 --> 47:05.220
它是不是可以记录下

47:05.220 --> 47:07.220
哪个watcher在用我

47:07.220 --> 47:08.220
将来这个数据变化的时候

47:08.220 --> 47:09.220
它就会通知这个watcher

47:09.220 --> 47:10.220
这个watcher里边是不是有个Render寒数

47:10.220 --> 47:12.220
它就会重新运行Render

47:12.220 --> 47:13.220
就这么

47:13.220 --> 47:15.220
它是用这种方式来处理的

47:15.220 --> 47:17.860
所以watcher首先会

47:17.860 --> 47:19.860
把Render寒数运行一次

47:19.860 --> 47:20.860
来收集依赖

47:20.860 --> 47:21.860
怎么运行就这种方式

47:22.860 --> 47:23.860
来收集依赖

47:23.860 --> 47:24.860
然后呢

47:24.860 --> 47:25.860
于是在那些Render中

47:25.860 --> 47:26.860
用到了响应式数据

47:26.860 --> 47:27.860
就会记录这个watcher

47:27.860 --> 47:28.860
将来数据变化的时候

47:28.860 --> 47:30.860
它就会重新选的

47:30.860 --> 47:31.860
重新宣传的过程中

47:31.860 --> 47:32.860
其实又会重新寄

47:32.860 --> 47:34.860
重新宣传是不是要重新用到

47:34.860 --> 47:36.860
可能比较有一个判断

47:38.860 --> 47:39.860
某一个数字是技术的时候

47:39.860 --> 47:40.860
宣传这个界面

47:40.860 --> 47:41.860
偶数的时候宣传另外一个界面

47:41.860 --> 47:42.860
是不是专业

47:42.860 --> 47:43.860
那有可能

47:43.860 --> 47:44.860
一开始宣传的界面

47:44.860 --> 47:46.860
一第二个是宣传的界面

47:46.860 --> 47:48.860
二那么它会重新运行宣传

47:48.860 --> 47:49.860
那么会重新记录依赖

47:49.860 --> 47:51.860
那么这些数也非常非常细的东西

47:51.860 --> 47:52.860
但是我们知道

47:52.860 --> 47:54.860
至少知道的整体流程就是

47:54.860 --> 47:56.860
getter的时候记录的是谁

47:56.860 --> 47:57.860
记录的是watcher

47:57.860 --> 47:58.860
拍发更新的时候

47:58.860 --> 47:59.860
触发的是watcher

48:01.860 --> 48:03.860
再看scheduler

48:03.860 --> 48:05.860
叫做叫调度器

48:05.860 --> 48:06.860
这就是它意思

48:06.860 --> 48:08.860
一个问题是一年的

48:08.860 --> 48:10.860
还有什么问题要解决呢

48:10.860 --> 48:12.860
那你想

48:13.860 --> 48:14.860
如果说你看

48:14.860 --> 48:17.860
像我们刚才那个Render函数

48:18.860 --> 48:21.860
有多少的东西会记录它

48:22.860 --> 48:23.860
是不是有很多

48:24.860 --> 48:26.860
是不是有很多东西会记录它

48:26.860 --> 48:27.860
哪些东西会记录它

48:27.860 --> 48:29.860
之前说过的

48:29.860 --> 48:31.860
哪些东西

48:31.860 --> 48:32.860
首先它

48:32.860 --> 48:33.860
它会记录吧

48:33.860 --> 48:35.860
它里面有个deb

48:35.860 --> 48:36.860
它会记录吧

48:36.860 --> 48:37.860
有deb

48:37.860 --> 48:38.860
谁倒是没有

48:38.860 --> 48:40.860
ARR是不是记录它

48:40.860 --> 48:41.860
没了嘛

48:41.860 --> 48:42.860
现在至少有三个吧

48:42.860 --> 48:43.860
那如果说界面多了

48:43.860 --> 48:45.860
肯定有很多东西都会

48:45.860 --> 48:47.860
都觉得这个Render函数

48:47.860 --> 48:48.860
用到了它

48:48.860 --> 48:49.860
那如果说有一段代码

48:49.860 --> 48:50.860
我可能一段代码

48:50.860 --> 48:52.860
就要改变很多数据

48:52.860 --> 48:53.860
是不是会导致个Render函数

48:53.860 --> 48:54.860
触发了很多次

48:54.860 --> 48:55.860
我改了

48:55.860 --> 48:57.860
又添加了一个属性B

48:57.860 --> 48:58.860
又往一个数组里面加了一项

48:58.860 --> 48:59.860
然后又从数组里面

48:59.860 --> 49:00.860
删了一项

49:00.860 --> 49:01.860
又给数组重新排序了

49:01.860 --> 49:02.860
又给数组

49:02.860 --> 49:03.860
然后用reverse

49:03.860 --> 49:04.860
来的一个翻转

49:05.860 --> 49:06.860
每一步都要会导致

49:06.860 --> 49:07.860
Render函数重新运行

49:08.860 --> 49:09.860
它拍发更新吧

49:10.860 --> 49:11.860
那这样子运行是不是太平凡了

49:12.860 --> 49:13.860
那怎么办呢

49:14.860 --> 49:15.860
它怎么办

49:15.860 --> 49:16.860
它就靠一个调入器

49:16.860 --> 49:17.860
所以它怎么来做的

49:17.860 --> 49:18.860
比如说你用到属性ABCD

49:18.860 --> 49:20.860
那么ABCD都会记录遗难

49:20.860 --> 49:21.860
于是我这个代码

49:21.860 --> 49:22.860
就会触发四次更新

49:23.860 --> 49:24.860
但这显然是不合适的

49:25.860 --> 49:26.860
我最好了是

49:26.860 --> 49:27.860
等你弄完了过后

49:27.860 --> 49:28.860
我再去触发更新

49:28.860 --> 49:29.860
那怎么办呢

49:29.860 --> 49:31.860
那就最好的做法是这样子的

49:32.860 --> 49:33.860
那个watcher

49:33.860 --> 49:34.860
它收到了拍发更新的通知

49:34.860 --> 49:35.860
就是你通知的时候

49:35.860 --> 49:36.860
通知谁通知watcher

49:36.860 --> 49:38.860
watcher它不是立即执行那个

49:38.860 --> 49:39.860
相应的函数

49:39.860 --> 49:40.860
比方Render函数

49:40.860 --> 49:41.860
它不是立即执行

49:42.860 --> 49:43.860
而是把自己

49:43.860 --> 49:44.860
当前那个watcher交回

49:44.860 --> 49:45.860
一个东西叫调入器的东西

49:46.860 --> 49:47.860
这个调入器

49:47.860 --> 49:48.860
它里面有个对立

49:48.860 --> 49:49.860
可以把相应的数据

49:49.860 --> 49:51.860
它里面就寄入了

49:51.860 --> 49:53.860
我现在要运行哪些watcher

49:54.860 --> 49:55.860
为什么有多个呢

49:55.860 --> 49:56.860
什么有可能一个数据

49:56.860 --> 49:57.860
比方说A这个数据

49:57.860 --> 49:58.860
有可能有多个

49:58.860 --> 49:59.860
多个watcher都会用它

50:00.860 --> 50:01.860
不一定是Render函数

50:01.860 --> 50:02.860
每个有函数一个watcher

50:03.860 --> 50:04.860
不一定是Render函数

50:04.860 --> 50:05.860
又可能是别的什么函数

50:05.860 --> 50:06.860
制定一个函数

50:06.860 --> 50:07.860
都有可能会用到它

50:08.860 --> 50:09.860
所以说呢

50:09.860 --> 50:10.860
当它变化的时候

50:10.860 --> 50:11.860
那么我们需要

50:11.860 --> 50:13.860
去执行不同的东西

50:13.860 --> 50:14.860
那么每一个都是一个watcher

50:14.860 --> 50:16.860
它说需要维护一个对立

50:16.860 --> 50:17.860
对立里面

50:18.860 --> 50:19.860
一个watcher它只会出现一次

50:20.860 --> 50:21.860
比方说这里

50:21.860 --> 50:22.860
运行了四个复职

50:23.860 --> 50:24.860
这一句话会干嘛

50:25.860 --> 50:26.860
会让watcher

50:26.860 --> 50:27.860
把自己添加到

50:27.860 --> 50:28.860
这个调度器的对立

50:29.860 --> 50:30.860
但是那个对立里面

50:30.860 --> 50:31.860
一开始没有

50:31.860 --> 50:32.860
那就加进去了

50:33.860 --> 50:34.860
它就往对立里面

50:34.860 --> 50:35.860
加了一个watcher

50:35.860 --> 50:36.860
有可能对立里面

50:36.860 --> 50:37.860
还有一些别的watcher

50:37.860 --> 50:38.860
那么现在就比方说

50:38.860 --> 50:39.860
当前的watcher叫watcher3

50:40.860 --> 50:41.860
它会加进去

50:43.860 --> 50:44.860
然后第二步呢

50:44.860 --> 50:45.860
又给B复职

50:45.860 --> 50:46.860
那么又是一个watcher

50:46.860 --> 50:47.860
对吧

50:47.860 --> 50:48.860
那还是同一个watcher

50:48.860 --> 50:49.860
都是Render函数

50:49.860 --> 50:50.860
同一个watcher

50:50.860 --> 50:51.860
但是呢

50:51.860 --> 50:52.860
发现已经在了

50:52.860 --> 50:53.860
所以它不会重复加

50:54.860 --> 50:55.860
加这个对立

50:56.860 --> 50:57.860
现在不运行吗

50:58.860 --> 50:59.860
那么对立什么时候运行

50:59.860 --> 51:00.860
调度器呢

51:00.860 --> 51:02.860
它会把对立的执行

51:03.860 --> 51:04.860
放到

51:04.860 --> 51:05.860
微对立中

51:05.860 --> 51:06.860
它怎么放到的

51:06.860 --> 51:07.860
它是通过一个

51:07.860 --> 51:08.860
工具方法叫next tick

51:09.860 --> 51:10.860
next tick里边

51:11.860 --> 51:12.860
它是一个函数

51:13.860 --> 51:14.860
它要做的事情很简单

51:15.860 --> 51:16.860
你给它传一个函数进去

51:17.860 --> 51:18.860
next tick

51:19.860 --> 51:20.860
你给它传一个函数进去

51:21.860 --> 51:22.860
这个函数

51:22.860 --> 51:23.860
它会被放到微对立

51:25.860 --> 51:26.860
它的代码其实非常简单

51:27.860 --> 51:28.860
我写一个

51:28.860 --> 51:29.860
它的核心代码就行了

51:30.860 --> 51:31.860
它的核心代码就是

51:31.860 --> 51:32.860
你给它传一个函数

51:32.860 --> 51:33.860
它把这个函数呢

51:33.860 --> 51:34.860
用这种方式来执行

51:40.860 --> 51:43.620
它用这种方式来执行

51:44.620 --> 51:45.620
是不是这个函数跑到微对立里面去了

51:46.620 --> 51:47.620
当然呢

51:47.620 --> 51:48.620
它为了考虑兼容性

51:49.620 --> 51:50.620
不同的流量器

51:50.620 --> 51:51.620
它的做法

51:51.620 --> 51:52.620
做法不一样

51:52.620 --> 51:53.620
这里有一个链接

51:53.620 --> 51:54.620
你可以去看一下

51:54.620 --> 51:55.620
它的异不更新对立

51:55.620 --> 51:56.620
它有可能

51:56.620 --> 51:57.620
它会检查

51:57.620 --> 51:58.620
依次检查

51:58.620 --> 51:59.620
有没有Promise

51:59.620 --> 52:00.620
有没有这个东西

52:00.620 --> 52:01.620
有没有这个东西

52:01.620 --> 52:02.620
这个玩意是

52:02.620 --> 52:03.620
漏了解释环境里边

52:03.620 --> 52:05.620
现在还没有学习漏了解释

52:06.620 --> 52:08.620
如果说这些环境都不支持的话

52:08.620 --> 52:09.620
它就不能用微对立的

52:09.620 --> 52:10.620
它只能用这些

52:10.620 --> 52:11.620
太冒头了

52:11.620 --> 52:12.620
就这么个意思

52:12.620 --> 52:13.620
它会考虑兼容性

52:13.620 --> 52:14.620
我们呢

52:14.620 --> 52:15.620
就可以认为

52:15.620 --> 52:16.620
它就是一个Promise

52:16.620 --> 52:17.620
放到微对立里面去了

52:18.620 --> 52:19.620
所以说

52:19.620 --> 52:20.620
通过Watcher执行的函数

52:21.620 --> 52:22.620
第一次立即执行

52:22.620 --> 52:23.620
但是后续的

52:23.620 --> 52:24.620
派发更新过后的执行了

52:24.620 --> 52:25.620
就是一步的

52:26.620 --> 52:27.620
好像没一个总体流程图

52:28.620 --> 52:32.080
首先

52:32.080 --> 52:33.080
原始对象

52:33.080 --> 52:34.080
我们看这一块

52:34.080 --> 52:36.080
首先原始对象

52:37.080 --> 52:38.080
交给Observer

52:38.080 --> 52:39.080
它会把它变成一个

52:39.080 --> 52:40.080
响应式对象

52:40.080 --> 52:41.080
它就有getter

52:41.080 --> 52:42.080
setter

52:43.080 --> 52:44.080
那么这一步就完了

52:44.080 --> 52:45.080
等着

52:46.080 --> 52:47.080
突然有一天

52:47.080 --> 52:48.080
有一个函数要执行

52:48.080 --> 52:50.080
比方说我们的Render函数

52:50.080 --> 52:55.570
有个Render函数要执行

52:58.570 --> 52:59.570
Render函数

53:00.570 --> 53:01.570
它执行的时候

53:02.570 --> 53:03.570
它不是直接执行

53:03.570 --> 53:04.570
它是交给谁

53:04.570 --> 53:05.570
交给Watcher

53:06.570 --> 53:07.570
来执行执行

53:08.570 --> 53:09.570
交给Watcher来执行

53:10.570 --> 53:11.570
好

53:11.570 --> 53:12.570
Watcher怎么执行的呢

53:12.570 --> 53:13.570
它就是设置一个

53:13.570 --> 53:14.570
全球变量

53:14.570 --> 53:15.570
然后再去运行这个函数

53:15.570 --> 53:16.570
然后于是

53:17.570 --> 53:18.570
执行的过程中

53:18.570 --> 53:19.570
它就用到了

53:19.570 --> 53:20.570
这个响应式对象里面的一些属性

53:21.570 --> 53:22.570
所以说这个属性

53:22.570 --> 53:23.570
它就被收集进来了

53:26.710 --> 53:28.710
这个属性它就被收集进来了

53:29.710 --> 53:30.710
那么就会记录

53:30.710 --> 53:31.710
这个属性它用到了这个Watcher

53:31.710 --> 53:33.710
另外一个属性也用到了这个Watcher

53:33.710 --> 53:35.710
还有一些对象用到这个Watcher

53:35.710 --> 53:36.710
还有一些数组也用到这个Watcher

53:36.710 --> 53:37.710
还会记录下来

53:38.710 --> 53:39.710
好 这一步就完成了

53:40.710 --> 53:41.710
好 见面就渲染出来了

53:41.710 --> 53:42.710
对吧

53:42.710 --> 53:43.710
那么有一天我们点击按钮

53:43.710 --> 53:44.710
或者是出发一些事情

53:44.710 --> 53:45.710
改变了数据

53:48.710 --> 53:49.710
数据变了

53:49.710 --> 53:50.710
现在进入下一个步骤

53:51.710 --> 53:52.710
现在数据变了

53:53.710 --> 53:54.710
它就做派发更新

53:54.710 --> 53:56.710
刚才之前不是记录了

53:56.710 --> 53:57.710
这个属性有一个Watcher

53:57.710 --> 53:58.710
有一个Watcher用到了我

53:59.710 --> 54:01.710
同时这个Watcher

54:01.710 --> 54:03.710
我变了要去搞定这件事情

54:03.710 --> 54:05.710
这个Watcher怎么办的呢

54:05.710 --> 54:06.710
它不是立即执行这个函数

54:06.710 --> 54:07.710
不然的话

54:07.710 --> 54:08.710
它就会重复执行很多次

54:08.710 --> 54:11.710
因为有可能很多数据都不停的变化

54:11.710 --> 54:13.710
它是把自己交给个调度器

54:13.710 --> 54:14.710
这个调度器

54:14.710 --> 54:16.710
它里边已经有了很多的Watcher了

54:16.710 --> 54:18.710
可能有已经有一些Watcher了

54:18.710 --> 54:19.710
那么

54:19.710 --> 54:21.710
调度器的作用就是

54:21.710 --> 54:23.710
把这个Watcher添加到对列里面去

54:24.710 --> 54:25.710
添加对列里面

54:25.710 --> 54:27.710
而对列里面现在不会执行的

54:27.710 --> 54:29.710
它会把对列的执行的过程

54:29.710 --> 54:31.710
交给这个NextTick

54:31.710 --> 54:32.710
这个NextTick里面

54:32.710 --> 54:34.710
也有可能有一些别的函数

54:35.710 --> 54:37.710
那么这个Scheduler

54:37.710 --> 54:38.710
这个调度器

54:38.710 --> 54:39.710
它就会把执行这个对列的

54:39.710 --> 54:41.710
它会生成一个函数

54:41.710 --> 54:42.710
就是执行这个对列的函数

54:42.710 --> 54:44.710
它把执行这个对列的函数

54:44.710 --> 54:45.710
比方到这里

54:45.710 --> 54:47.710
它就会交给NextTick

54:47.710 --> 54:48.710
NextTick里面

54:48.710 --> 54:50.710
这些函数全是在对列里面

54:50.710 --> 54:51.710
通过Promise定

54:51.710 --> 54:53.710
放到对列里面去的

54:53.710 --> 54:55.710
因此它会进行

54:55.710 --> 54:56.710
一一步的

54:56.710 --> 54:58.710
将来等于同步代码执行完了

54:58.710 --> 55:00.710
那么它就会进入这个对列

55:00.710 --> 55:02.710
一一步的去执行

55:02.710 --> 55:04.710
fn1 fn2按照顺序

55:04.710 --> 55:05.710
然后执行这些东西

55:06.710 --> 55:08.710
那么执行这个Watcher的时候

55:08.710 --> 55:10.710
是不是又运行到谁

55:10.710 --> 55:11.710
又运行到Render函数

55:11.710 --> 55:12.710
又回到之前的

55:14.710 --> 55:15.710
执行这个

55:15.710 --> 55:16.710
又重新执行这个Watcher

55:16.710 --> 55:17.710
重新执行Watcher

55:17.710 --> 55:18.710
是不是又相当于是

55:18.710 --> 55:20.710
又运行到Render函数

55:20.710 --> 55:21.710
而Render函数的运行过程中

55:21.710 --> 55:23.710
是不是又用到了一个详硬式数据

55:23.710 --> 55:25.710
那么又重新收集一代

55:25.710 --> 55:27.710
之前的一代就取消掉了

55:27.710 --> 55:28.710
现在我们重新收集一代

55:28.710 --> 55:29.710
因为每一式宣传可能

55:29.710 --> 55:31.710
一代的东西不一样

55:31.710 --> 55:32.710
可能又判断来循环

55:32.710 --> 55:33.710
一代东西不一样

55:33.710 --> 55:34.710
重新收集一代

55:34.710 --> 55:36.710
那么将来这个一代的数据又变化了

55:36.710 --> 55:37.710
变化了又来这时候

55:37.710 --> 55:39.710
整个流程循环往复

55:39.710 --> 55:40.710
它就这么一个过程

55:42.710 --> 55:43.710
如果说你能够把这样的一个

55:43.710 --> 55:45.710
详细的东西讲清楚的话

55:45.710 --> 55:46.710
那里这个面试

55:47.710 --> 55:49.710
可能至少一半的时间就过完了

55:49.710 --> 55:50.710
因为面试的时候

55:50.710 --> 55:51.710
差不多一个小时了

55:51.710 --> 55:52.710
一半的时间就过完了

55:53.710 --> 55:54.710
那你想啊

55:54.710 --> 55:55.710
你个面试总是长

55:55.710 --> 55:56.710
基本上是不变的

55:56.710 --> 55:58.710
你能够把自己熟悉的东西

55:58.710 --> 55:59.710
深入了解的东西

55:59.710 --> 56:01.710
特别能够显示自己的能力的东西

56:01.710 --> 56:03.710
你尽量的说的长一点多一点

56:03.710 --> 56:04.710
占用的面试时间多一点

56:04.710 --> 56:05.710
是不是就把主动签

56:05.710 --> 56:06.710
放到自己手里边了

56:06.710 --> 56:08.710
面试关系没有多少时间下来问你了

56:08.710 --> 56:09.710
而且你把这个问题

56:09.710 --> 56:10.710
回到这么详细

56:10.710 --> 56:11.710
你也要这么透彻

56:11.710 --> 56:12.710
这面试关系就会

56:12.710 --> 56:14.710
直接把面试关系吓到了

56:16.710 --> 56:17.710
我希望了

56:17.710 --> 56:19.710
大家还是能够尽量的底线

56:20.710 --> 56:21.710
那么这里有两道题

56:22.710 --> 56:23.710
测出题一

56:24.710 --> 56:25.710
有一个模板

56:25.710 --> 56:26.710
显示个Message

56:26.710 --> 56:27.710
显示个OBGA

56:27.710 --> 56:28.710
好

56:28.710 --> 56:29.710
这里呢一个Cos

56:31.710 --> 56:32.710
Increase

56:32.710 --> 56:33.710
然后呢

56:33.710 --> 56:34.710
这里有点这个按钮呢

56:34.710 --> 56:36.710
设置个对象的A等于1

56:37.710 --> 56:38.710
问题的是

56:39.710 --> 56:41.710
点击这个按钮

56:42.710 --> 56:47.180
会不会导致界面炫了

56:47.180 --> 56:48.180
把数据在这

56:48.180 --> 56:49.180
数据在这

56:49.180 --> 56:52.620
会不会导致界面炫了

56:55.060 --> 56:56.060
点这个按钮

56:56.060 --> 56:57.060
这不会啊

56:57.060 --> 56:58.060
因为他根本就没有用到这个数据

56:58.060 --> 56:59.060
对吧

56:59.060 --> 57:00.060
所以他不会

57:00.060 --> 57:02.060
他没有收集到这个依赖

57:02.060 --> 57:04.060
怎么来确定这还会不会呢

57:04.060 --> 57:05.060
其实我这里呢

57:05.060 --> 57:06.060
我把这个模板呢

57:06.060 --> 57:08.060
给你熟写成了一个Render函数

57:08.060 --> 57:10.060
这样你看得更加清楚一点

57:10.060 --> 57:11.060
Render函数我输出一个Render

57:11.060 --> 57:13.060
然后DIV两个H1 H2

57:13.060 --> 57:14.060
你看吧H1 H2

57:14.060 --> 57:16.060
就熟写变成了一个Botten各种事件

57:16.060 --> 57:17.060
就是一模一样的

57:17.060 --> 57:18.060
一模一样的

57:18.060 --> 57:19.060
就看这个模板就行了

57:19.060 --> 57:20.060
那么我们这里

57:20.060 --> 57:21.060
好处在于

57:21.060 --> 57:23.060
他会输出这个Render

57:23.060 --> 57:24.060
我们看得更加清楚一点

57:24.060 --> 57:25.060
我们点击这个

57:25.060 --> 57:27.060
是没有这个Render函数

57:27.060 --> 57:30.060
因为他用的是无关的数据

57:30.060 --> 57:31.060
但这个就不一样了

57:31.060 --> 57:32.060
因为我们的模板东西

57:32.060 --> 57:34.060
是不是一代的OBG

57:34.060 --> 57:36.060
OBG里面的DIV

57:36.060 --> 57:37.060
就会记录这个Render函数

57:37.060 --> 57:38.060
所以说

57:38.060 --> 57:40.060
我们给这个OBG的A

57:40.060 --> 57:42.060
设置一个属性1的时候

57:42.060 --> 57:44.060
那么它是会运行的

57:44.060 --> 57:46.060
运行Render的

57:46.060 --> 57:48.060
运行Render

57:48.060 --> 57:49.060
没问题吧

57:49.060 --> 57:50.060
那如果说改一下一个代码

57:50.060 --> 57:52.060
把设置B为一呢

57:53.060 --> 57:55.060
会不会运行Render呢

57:55.060 --> 57:57.060
也会

57:58.060 --> 58:00.060
为什么是

58:00.060 --> 58:02.060
我这里设置的是B啊

58:02.060 --> 58:03.060
先看

58:03.060 --> 58:05.060
刷新一下啊

58:05.060 --> 58:07.060
为什么我

58:08.060 --> 58:10.060
设置B为一啊

58:10.060 --> 58:11.060
我这里写的

58:11.060 --> 58:12.060
哦

58:12.060 --> 58:13.060
这下面Render

58:13.060 --> 58:16.060
其中是这个Render

58:16.060 --> 58:18.060
设置B为一

58:18.060 --> 58:19.060
所以也会运行Render

58:19.060 --> 58:20.060
尽管界面没有用到

58:20.060 --> 58:21.060
对吧

58:21.060 --> 58:22.060
之前讲过了

58:22.060 --> 58:24.060
当然一般来说

58:24.060 --> 58:25.060
面试的事情

58:25.060 --> 58:27.060
不会靠调装的题

58:27.060 --> 58:28.060
好

58:28.060 --> 58:29.060
第二个测试题

58:29.060 --> 58:30.060
看一下啊

58:30.060 --> 58:31.060
同样的道理

58:31.060 --> 58:33.060
我也把它写成那个Render函数了

58:33.060 --> 58:34.060
一模一样的

58:34.060 --> 58:35.060
跟那个界面

58:35.060 --> 58:36.060
效果一模一样的

58:36.060 --> 58:38.060
A71里边有一些标题

58:38.060 --> 58:39.060
ABCD用到ABCD

58:39.060 --> 58:40.060
四个数据

58:40.060 --> 58:41.060
所以都有一代

58:41.060 --> 58:43.060
然后让我们对点击按钮

58:43.060 --> 58:44.060
调用一个方法

58:44.060 --> 58:46.060
这个方法的做的事情呢

58:46.060 --> 58:48.060
给ABCD重新复制

58:48.060 --> 58:49.060
但是复制之前呢

58:49.060 --> 58:50.060
我使用了一个NextTik

58:50.060 --> 58:51.060
主要这个NextTik呢

58:51.060 --> 58:53.060
它是暴露给开发者的

58:53.060 --> 58:54.060
它通过ZS

58:54.060 --> 58:56.060
就是无忧的实力里边的一个方法

58:56.060 --> 58:58.060
叫NextTik暴露给开发者

58:58.060 --> 58:59.060
这个函数用起来非常简单

58:59.060 --> 59:00.060
你传一个函数进去

59:00.060 --> 59:02.060
它就把它放在围队那边去执行

59:02.060 --> 59:03.060
就这么个意思

59:03.060 --> 59:06.060
没有什么特别的模法

59:06.060 --> 59:07.060
我干嘛呀

59:07.060 --> 59:10.060
我通过ID来达到这个A71元数

59:10.060 --> 59:12.060
然后呢得到这个A71元数

59:12.060 --> 59:15.060
里边的内容

59:15.060 --> 59:17.060
那请问你输出啥

59:17.060 --> 59:20.820
点击这个按钮输出啥

59:20.820 --> 59:21.820
输出啥呀

59:21.820 --> 59:22.820
我们来看一下吧

59:22.820 --> 59:24.820
它一开始是啥

59:24.820 --> 59:26.820
一开始是不是1234

59:26.820 --> 59:27.820
1234

59:27.820 --> 59:28.820
对吧

59:28.820 --> 59:30.820
一开始显示是1234

59:30.820 --> 59:32.820
接下来我们点击

59:32.820 --> 59:33.820
点击这个按钮

59:33.820 --> 59:35.820
就触发这个函数嘛

59:35.820 --> 59:36.820
点这个按钮的时候干嘛呀

59:36.820 --> 59:38.820
我们首先往围队里边

59:38.820 --> 59:40.820
是不是加了一个东西

59:40.820 --> 59:41.820
那个Tik

59:41.820 --> 59:43.820
我直接往围队里边加了一个函数

59:43.820 --> 59:44.820
我们把它叫做FN1嘛

59:44.820 --> 59:46.820
那我们来看一下这个头

59:46.820 --> 59:52.370
围队里边是加了一个函数

59:52.370 --> 59:54.370
FN1

59:54.370 --> 59:56.370
然后接下来我干嘛呀

59:56.370 --> 59:59.370
接下来我给F值

59:59.370 --> 01:00:01.370
F值是不是导致了数据变化

01:00:01.370 --> 01:00:02.370
一旦的数据变化

01:00:02.370 --> 01:00:04.370
一旦的数据变化干嘛呀

01:00:04.370 --> 01:00:06.370
还会是不是把WATCH交给调入T

01:00:06.370 --> 01:00:08.370
调入T就生成了一个

01:00:08.370 --> 01:00:09.370
把WATCH 添加了对列

01:00:09.370 --> 01:00:10.370
比如说对列里面只有这个WATCH

01:00:10.370 --> 01:00:12.370
确实也没有别的WATCH了

01:00:12.370 --> 01:00:15.370
然后把对列的值型

01:00:15.370 --> 01:00:16.370
加通过NextTik

01:00:16.370 --> 01:00:18.370
是不是加到围队里面

01:00:18.370 --> 01:00:19.370
所以说FN1过了

01:00:19.370 --> 01:00:21.370
现在围队里面又有一个东西了

01:00:21.370 --> 01:00:23.370
Qt

01:00:23.370 --> 01:00:24.370
WATCH

01:00:24.370 --> 01:00:25.370
那么这个WATCH

01:00:25.370 --> 01:00:27.370
其实就是我们刚才的WATCH

01:00:27.370 --> 01:00:29.370
然后有给B负值

01:00:29.370 --> 01:00:32.370
B负值的话是不是又往这里面加对列

01:00:32.370 --> 01:00:33.370
又往这里面加

01:00:33.370 --> 01:00:34.370
不好意思 这个对列里面

01:00:34.370 --> 01:00:35.370
只有一个WATCH

01:00:35.370 --> 01:00:36.370
已经有了

01:00:36.370 --> 01:00:37.370
还就不会加进去了

01:00:37.370 --> 01:00:39.370
然后给C负值

01:00:39.370 --> 01:00:40.370
给D负值

01:00:40.370 --> 01:00:41.370
那么这些负值

01:00:41.370 --> 01:00:44.370
其实本质上都是往这里面加

01:00:44.370 --> 01:00:46.370
都是往这里面加

01:00:46.370 --> 01:00:47.370
好

01:00:47.370 --> 01:00:49.370
然后最后我们同步代码运行完了

01:00:49.370 --> 01:00:50.370
接下来我们运行围队列

01:00:50.370 --> 01:00:52.370
是不是FN1要先运行

01:00:52.370 --> 01:00:55.370
而运行FN1的时候

01:00:55.370 --> 01:00:57.370
有没有重新渲染

01:00:57.370 --> 01:00:58.370
所以还没有执行这个WATCH

01:00:58.370 --> 01:01:00.370
还没有重新渲染

01:01:00.370 --> 01:01:01.370
因为我们只有执行WATCH的时候

01:01:01.370 --> 01:01:03.370
它会执行Render重新渲染

01:01:03.370 --> 01:01:04.370
对吧

01:01:04.370 --> 01:01:05.370
所以还没有执行WATCH

01:01:05.370 --> 01:01:07.370
对列里面只有一个WATCH

01:01:07.370 --> 01:01:08.370
还没有执行这个WATCH

01:01:08.370 --> 01:01:09.370
所以说

01:01:09.370 --> 01:01:10.370
它没有重新渲染

01:01:10.370 --> 01:01:11.370
所以说这个时候得到的是什么

01:01:11.370 --> 01:01:13.370
得到的就是1230

01:01:13.370 --> 01:01:15.370
FN1得到的就是1230

01:01:17.870 --> 01:01:20.870
然后再去执行这个WATCH

01:01:20.870 --> 01:01:22.870
那么这个时候界面才会变化

01:01:22.870 --> 01:01:25.870
那么这个时候才会运行Render

01:01:25.870 --> 01:01:26.870
发生界面变化

01:01:27.870 --> 01:01:28.870
你看一下吧

01:01:31.870 --> 01:01:39.100
这里运行Render

01:01:39.100 --> 01:01:40.100
一开始渲染了一次

01:01:40.100 --> 01:01:41.100
然后签几O

01:01:41.100 --> 01:01:42.100
1234

01:01:42.100 --> 01:01:44.100
然后再重新运行Render

01:01:44.100 --> 01:01:45.100
对吧

01:01:45.100 --> 01:01:47.100
那如果说你这样的代码改一下

01:01:49.100 --> 01:01:50.100
你代码稍微改一下

01:01:51.100 --> 01:01:53.100
那是不是就是得到的最新的值了

01:01:53.100 --> 01:01:54.100
为什么呢

01:01:54.100 --> 01:01:57.100
因为一开始改这几句话

01:01:57.100 --> 01:01:58.100
是不是都会导致

01:01:58.100 --> 01:02:00.100
把XQ是WATCH

01:02:00.100 --> 01:02:01.100
放到对列前面

01:02:01.100 --> 01:02:02.100
然后再放

01:02:02.100 --> 01:02:05.600
后面再放这个FN1

01:02:05.600 --> 01:02:07.600
是不是再放这个这个函数

01:02:07.600 --> 01:02:08.600
那么运行的时候

01:02:08.600 --> 01:02:09.600
是不是先运行这个WATCH

01:02:09.600 --> 01:02:10.600
运行WATCH

01:02:10.600 --> 01:02:12.600
就是运行Render重新渲染

01:02:12.600 --> 01:02:13.600
运行渲染过后

01:02:13.600 --> 01:02:14.600
然后再运行FN1

01:02:14.600 --> 01:02:15.600
是不是就得到渲染之后的结果了

01:02:15.600 --> 01:02:17.600
所以那个Stick有的时候

01:02:17.600 --> 01:02:18.600
可以做什么事情

01:02:18.600 --> 01:02:19.600
就是你改动了数据

01:02:19.600 --> 01:02:21.600
你希望了改动了数据过后

01:02:21.600 --> 01:02:23.600
得到一个按照新的界面

01:02:23.600 --> 01:02:25.600
在新的界面上去做一些事情

01:02:25.600 --> 01:02:27.600
比方说通过一些原生的多么操作

01:02:27.600 --> 01:02:28.600
去做一些事情

01:02:28.600 --> 01:02:29.600
那么就可以用那个Stick

01:02:29.600 --> 01:02:31.600
但是你一定要写到后面

01:02:31.600 --> 01:02:32.600
你看一下

01:02:32.600 --> 01:02:35.980
现在是不是可以了

01:02:35.980 --> 01:02:36.980
对吧

01:02:36.980 --> 01:02:39.540
那如果说写到这儿呢

01:02:39.540 --> 01:02:40.540
写到这儿呢

01:02:41.540 --> 01:02:42.540
就一样的

01:02:42.540 --> 01:02:43.540
一样的

01:02:43.540 --> 01:02:44.540
对吧

01:02:44.540 --> 01:02:45.540
第一个数据变了

01:02:45.540 --> 01:02:46.540
加了这个WATCH

01:02:46.540 --> 01:02:47.540
加了WATCH

01:02:47.540 --> 01:02:48.540
是不是就加到微粒列里面去了

01:02:48.540 --> 01:02:49.540
对吧

01:02:49.540 --> 01:02:50.540
加到微粒列里面去了

01:02:50.540 --> 01:02:51.540
那么后续了

01:02:51.540 --> 01:02:52.540
在微粒里面引诱了

01:02:52.540 --> 01:02:53.540
就不用再加了

01:02:54.540 --> 01:02:55.540
加WATCH

01:02:55.540 --> 01:02:57.540
然后加这个FN

01:02:57.540 --> 01:02:58.540
然后后面引诱了

01:02:58.540 --> 01:02:59.540
还就不会加这个WATCH

01:02:59.540 --> 01:03:00.540
所以说还是一样的

01:03:02.540 --> 01:03:03.540
还是一样的

01:03:03.540 --> 01:03:04.540
在那个Stick

01:03:04.540 --> 01:03:05.540
那如果说这里呢

01:03:05.540 --> 01:03:06.540
有的是面试贴为了考虑

01:03:06.540 --> 01:03:07.540
这里

01:03:07.540 --> 01:03:09.540
这里再来一个Setter mouse

01:03:09.540 --> 01:03:11.540
前面再来一个Setter mouse

01:03:11.540 --> 01:03:13.920
输出123

01:03:13.920 --> 01:03:15.920
那么123是什么输出

01:03:15.920 --> 01:03:16.920
一定是最后

01:03:16.920 --> 01:03:17.920
因为它是红队的

01:03:17.920 --> 01:03:18.920
对吧

01:03:18.920 --> 01:03:19.920
它是红队的

01:03:19.920 --> 01:03:23.320
一定是最后

01:03:23.320 --> 01:03:24.320
好

01:03:24.320 --> 01:03:26.320
咱们这就可能那种

01:03:26.320 --> 01:03:27.320
那种时间比较长

01:03:27.320 --> 01:03:28.320
讲的也比较多

01:03:28.320 --> 01:03:29.320
也比较深

01:03:29.320 --> 01:03:30.320
所以大家慢慢下去

01:03:30.320 --> 01:03:31.320
慢慢去消化

01:03:31.320 --> 01:03:32.320
如果说实在不行的话

01:03:32.320 --> 01:03:33.320
那你至少呢

01:03:33.320 --> 01:03:35.320
也要把这个东西能回答出来

01:03:36.320 --> 01:03:37.320
其实这个就是个简队图

01:03:37.320 --> 01:03:38.320
对吧

01:03:38.320 --> 01:03:39.320
确认的时候用到了数据

01:03:39.320 --> 01:03:40.320
数据的

01:03:40.320 --> 01:03:41.320
记录WATCH

01:03:41.320 --> 01:03:42.320
数据变化的时候

01:03:42.320 --> 01:03:43.320
通知WATCH

01:03:43.320 --> 01:03:45.320
WATCH就是重新运行Render

01:03:45.320 --> 01:03:46.320
它就是个简队的图

01:03:46.320 --> 01:03:47.320
OK

01:03:47.320 --> 01:03:48.320
那么这里可能那种

01:03:48.320 --> 01:03:49.320
就到这了

