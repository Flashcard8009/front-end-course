WEBVTT

00:00.750 --> 00:04.090
模块画 模块画这一块的题呢

00:04.590 --> 00:08.690
主要就是问你common.js和es module的区别

00:08.950 --> 00:09.710
就是这两个

00:10.470 --> 00:12.790
会不会出代码题呢 它会

00:13.290 --> 00:15.090
出代码题主要就是

00:15.350 --> 00:18.930
一个是common.js的考察 一个是es module的考察

00:19.430 --> 00:21.750
两个考察点呢 可能不太一样

00:22.010 --> 00:24.550
咱们这节课呢 因为我们模块画已经学习了嘛 对吧

00:24.810 --> 00:27.630
我们这节课呢 就对这两个模块画标准啊

00:27.890 --> 00:29.930
来做一些总结 以及呢

00:30.130 --> 00:31.210
补充一些知识

00:31.970 --> 00:33.770
我们先来看一下common.js

00:34.290 --> 00:38.890
common.js呢 以物称为CMG

00:40.170 --> 00:41.710
记住它几个关键词

00:41.970 --> 00:48.610
其实它也不用记 这些关键词呢 我也没有去记过 我就是想一想它有什么样哪些特点啊 把罗列出来就可以了

00:49.130 --> 00:52.450
那么这些关键词呢 第一个就是社区标准 它不是官方的

00:52.710 --> 00:56.050
我们之前讲那个common.js的时候也讲过它的那段历史

00:56.550 --> 00:58.610
它是最早出来的 不是官方的

00:59.110 --> 00:59.890
社区标准

01:00.390 --> 01:02.950
所以说呢 支持 瀏覽器肯定不会支持它

01:03.210 --> 01:04.230
这这么一个特点啊

01:04.750 --> 01:09.870
第二个特点呢 是它使用函数实现的 因为它不是一个官方的标准

01:10.390 --> 01:11.650
它是一个社区标准

01:11.910 --> 01:12.930
社区标准啊

01:13.190 --> 01:13.970
一般来说

01:14.230 --> 01:14.990
它不会给你

01:15.250 --> 01:17.030
创建一些新的语法出来

01:17.290 --> 01:19.030
什么叫做新的语法啊

01:19.290 --> 01:21.390
比方说你们学习那个es6

01:22.150 --> 01:23.430
什么net 关键词

01:23.690 --> 01:24.970
concept 关键词

01:25.230 --> 01:26.770
那么这些玩意是新的语法

01:27.230 --> 01:30.390
这种语法呀 一般只有官方才有权力

01:30.670 --> 01:31.830
来推出新语法

01:32.090 --> 01:34.390
民间标准的话 它没有新语法出现

01:34.670 --> 01:36.190
它一般都是利用官方的一些

01:36.450 --> 01:39.650
给你创建一个函数啊 给你搞一个新的对象出来啊

01:39.910 --> 01:41.310
对吧 这些没有新的语法

01:41.570 --> 01:43.630
它只有新的API 可能没有新的语法

01:44.630 --> 01:47.970
这是它这么一个特点啊 使用它使用的是函数的实现

01:48.230 --> 01:50.030
什么函数啊 是不是require函数

01:50.430 --> 01:53.470
对吧 我们导入一个模块 使用的就是require函数

01:53.870 --> 01:55.650
它把这个函数给你搞了一个函数出来

01:56.350 --> 01:58.350
那么一会呢 我们可以说一下require函数

01:58.350 --> 01:59.550
它到底是怎么做的

02:00.950 --> 02:04.150
好 然后它仅支持漏的环境

02:05.150 --> 02:06.550
就是浏览器很你不知道它

02:06.750 --> 02:09.450
因为它本身就是漏的 漏的那个社区搞出来的

02:09.450 --> 02:11.150
所以说它支持的是漏的环境

02:11.950 --> 02:14.050
然后它是一个特点 是动态依赖

02:14.350 --> 02:15.350
什么叫动态依赖呢

02:15.550 --> 02:17.950
你看这个require啊 它本身是一个函数

02:18.450 --> 02:20.150
它就是一个普通的函数调用

02:20.750 --> 02:24.350
所以说呢 这个函数啊 它可以出现在任何地方

02:24.850 --> 02:27.850
它可以出现在判断里边 可以出现在循环里边

02:27.850 --> 02:29.850
可以出现在任何你想象的到的地方

02:30.350 --> 02:32.150
它只是一个普通的函数调用而已

02:33.150 --> 02:35.050
甚至还可以出现在函数调用里边

02:36.150 --> 02:38.050
它是动态依赖 什么叫动态依赖呢

02:38.750 --> 02:41.350
就是说它必须要代码运行之后

02:42.350 --> 02:43.850
才能确定依赖关系

02:44.250 --> 02:45.750
究竟不运行这段代码

02:46.350 --> 02:47.650
永远不知道它依赖谁

02:47.650 --> 02:49.650
比方说啊 我们这里的一个代码

02:50.150 --> 02:53.650
判断啥啥啥 然后呢 我们这里require

02:55.350 --> 02:58.350
然后l是呢 我require b

02:58.350 --> 03:02.350
你说这个判断 你说这个函数如果说不运行的话

03:02.350 --> 03:05.350
它知道依赖谁吗 就不知道依赖谁 叫动态依赖

03:05.350 --> 03:07.350
对吧 只有运行到这句话的时候

03:07.350 --> 03:09.350
哎 我才知道了啊 我原来依赖A

03:10.350 --> 03:12.350
没有运行到这句话 我就不依赖A

03:12.350 --> 03:15.350
它要运行的时候才能确定的话 叫动态依赖

03:15.350 --> 03:18.350
而且呢 它这个动态依赖是同步执行的

03:18.350 --> 03:20.350
那么这又是什么意思呢

03:20.350 --> 03:22.350
就这句话 因为这句话我们之前讲过

03:23.350 --> 03:25.350
就导入一个模块A 对吧

03:25.350 --> 03:27.350
那么比方说运行到了这句话

03:27.350 --> 03:32.350
那导入模块A 它是不是要去读这个A这个文件啊

03:32.350 --> 03:34.350
是不是得读啊 对不对

03:34.350 --> 03:37.350
那么它要读这个文件 读文件是不是需要时间

03:38.350 --> 03:41.350
读文件它是要跟硬盘 硬盘打交道

03:41.350 --> 03:42.350
我们把它叫做IO

03:44.350 --> 03:46.350
像什么网络的传输啊

03:46.350 --> 03:50.350
什么硬盘的数据读取啊 这些东西都属于IO

03:50.350 --> 03:53.350
那么IO操作是比较费事的

03:53.350 --> 03:56.350
跟我们平时写的代码都是在内存里边的吧

03:56.350 --> 03:58.350
内存里边操作速度很快的

03:58.350 --> 04:00.350
那快的不是一个数量级的

04:00.350 --> 04:02.350
他们就不是一个水平的选手

04:02.350 --> 04:06.350
所以说呢 它这个硬盘的读取是需要耗费时间的

04:06.350 --> 04:09.350
但是呢 它不是用异部的方式来处理

04:09.350 --> 04:11.350
那比方说我们说的夸张一点

04:12.350 --> 04:14.350
读取硬盘可能需要一年

04:14.350 --> 04:17.350
那么这一块代码它就会卡着等着一年

04:18.350 --> 04:19.350
等一年之后呢

04:19.350 --> 04:21.350
我们拿到这个模块的导出结果

04:21.350 --> 04:22.350
懂了意思吧

04:22.350 --> 04:24.350
它不会像一个异部的厂

04:24.350 --> 04:25.350
你什么要异部呢

04:25.350 --> 04:26.350
就是你去读 我不管了

04:26.350 --> 04:27.350
我接着往后运行

04:27.350 --> 04:28.350
等你读完了之后

04:28.350 --> 04:29.350
我运行一个回调函数

04:29.350 --> 04:31.350
比方向这种解决吧

04:31.350 --> 04:33.350
我运行一个回调函数

04:33.350 --> 04:35.350
用这种方式来处理

04:35.350 --> 04:37.350
它不是 它是同步的

04:37.350 --> 04:38.350
同步的就是一什么

04:38.350 --> 04:39.350
我一定要等它读完了之后

04:39.350 --> 04:40.350
我才继续往后运行

04:40.350 --> 04:41.350
把后边代码等着

04:42.350 --> 04:43.350
这是有这么一个特点

04:43.350 --> 04:45.350
它是同步执行的

04:45.350 --> 04:48.350
这是CommonJS的这么一些特点

04:48.350 --> 04:49.350
你只要在面试的时候

04:49.350 --> 04:51.350
无论是问你CommonJS

04:51.350 --> 04:53.350
你怎么去理解它 阐述一下

04:53.350 --> 04:54.350
不管你怎么去回答

04:54.350 --> 04:57.350
你把这些东西关键字回答出来

04:57.350 --> 04:58.350
那决定是满分了

04:59.350 --> 05:01.350
那么这是CommonJS

05:01.350 --> 05:04.350
这一块容易考一些面试题

05:04.350 --> 05:05.350
就是一些代码题

05:05.350 --> 05:07.350
那么这个代码题主要考察什么呢

05:07.350 --> 05:10.350
我们来看一下CommonJS的原理

05:10.350 --> 05:12.350
只要你知道它的原理之后

05:12.350 --> 05:15.350
那么所有的CommonJS的代码题

05:15.350 --> 05:16.350
你都不用怕了

05:16.350 --> 05:17.350
一点都不用怕了

05:17.350 --> 05:18.350
反之

05:18.350 --> 05:20.350
如果说你不知道它的原理

05:20.350 --> 05:22.350
那么你就老是要去背

05:22.350 --> 05:24.350
背的东西就特别容易忘记

05:24.350 --> 05:25.350
而且特别容易记错

05:25.350 --> 05:26.350
你知道原理之后

05:26.350 --> 05:27.350
理解的原理

05:27.350 --> 05:28.350
什么都不用怕了

05:29.350 --> 05:30.350
好 咱们来看一下

05:30.350 --> 05:31.350
它的原理

05:31.350 --> 05:33.350
其实你就理解这个Require函数

05:33.350 --> 05:34.350
就这么一点东西

05:35.350 --> 05:36.350
Require函数

05:36.350 --> 05:38.350
就凭是我们再用那个

05:38.350 --> 05:40.350
露德界史去导入一个模块的时候

05:40.350 --> 05:42.350
不知道有使用那个Require函数吗

05:42.350 --> 05:43.350
那个Require函数

05:43.350 --> 05:45.350
它到底是怎么在执行

05:46.350 --> 05:47.350
我们知道这个Require函数

05:47.350 --> 05:49.350
它一边要传一个什么

05:49.350 --> 05:50.350
传一个路径对吧

05:50.350 --> 05:51.350
我们其实它这里呢

05:51.350 --> 05:53.350
把它称之为模块的ID

05:53.350 --> 05:54.350
那么我们不管吧

05:54.350 --> 05:55.350
我们就当它是路径吧

05:55.350 --> 05:57.350
Require比方说点A

05:57.350 --> 05:59.350
那么这一块是不是一个路径啊

05:59.350 --> 06:00.350
当然它是一个相对的路径

06:01.350 --> 06:03.350
那么它首先看什么呢

06:03.350 --> 06:05.350
首先根据这个路径

06:05.350 --> 06:06.350
就是模块的ID

06:07.350 --> 06:08.350
每个模块

06:08.350 --> 06:10.350
它都有一个唯一的文件路径

06:10.350 --> 06:11.350
对吧

06:11.350 --> 06:12.350
那么这个唯一的文件路径

06:12.350 --> 06:13.350
就是它的ID

06:13.350 --> 06:15.350
那么根据这个模块ID

06:15.350 --> 06:17.350
看一下这个模块以前读过吗

06:17.350 --> 06:18.350
读过的时候

06:18.350 --> 06:19.350
它肯定有缓存

06:19.350 --> 06:21.350
它就把缓存直接返回了

06:21.350 --> 06:23.350
它做了这么一个处理

06:23.350 --> 06:24.350
全是伟代

06:24.350 --> 06:26.350
伟代就是来说明它的逻辑

06:26.350 --> 06:28.350
并不是真正可以执行的代码

06:28.350 --> 06:30.350
这是第一步

06:30.350 --> 06:31.350
接下来呢

06:31.350 --> 06:32.350
如果说它没有缓存

06:32.350 --> 06:33.350
那么就到了这一行了

06:33.350 --> 06:34.350
对吧

06:34.350 --> 06:35.350
到后边的代码了

06:35.350 --> 06:36.350
没有缓存的时候

06:36.350 --> 06:37.350
它就要运行模块了

06:37.350 --> 06:39.350
那它怎么来运行模块呢

06:39.350 --> 06:41.350
它是给你创建了这么一个纸寒树

06:41.350 --> 06:43.350
我们就给它取个名字叫ROM

06:43.350 --> 06:45.350
有这么一个寒树

06:45.350 --> 06:47.350
这个寒树有五个寒树

06:47.350 --> 06:49.350
我们这个五个寒树到底是啥

06:49.350 --> 06:50.350
我们先不管

06:50.350 --> 06:52.350
我们知道这里有一块寒树

06:52.350 --> 06:55.350
一会儿它就会调用这个寒树来运行

06:55.350 --> 06:57.350
我们平时写的模块代码

06:57.350 --> 06:59.350
全部放到这个寒树里边了

06:59.350 --> 07:01.350
比方说我们之前写了一个模块A

07:01.350 --> 07:03.350
A.js

07:03.350 --> 07:05.350
那么这个A那边写了很多很多的东西

07:06.350 --> 07:08.350
那么这些代码全部都是放到

07:08.350 --> 07:10.350
这个寒树里边的

07:10.350 --> 07:11.350
那么这就解

07:11.350 --> 07:12.350
这就有说明了什么了

07:12.350 --> 07:14.350
说明了我们模块的代码

07:14.350 --> 07:16.350
为什么不会污染全局

07:16.350 --> 07:17.350
为什么呢

07:17.350 --> 07:19.350
就是因为它在寒树里边运行

07:19.350 --> 07:21.350
懂了意思吧

07:21.350 --> 07:22.350
那我们如何来证明

07:22.350 --> 07:23.350
我们的模块代码

07:23.350 --> 07:25.350
真的就在寒树里边运行的

07:25.350 --> 07:26.350
就是非常简单

07:26.350 --> 07:28.350
我这里给大家看一下

07:28.350 --> 07:31.350
我们这里就输出一个

07:31.350 --> 07:35.940
就输出一个

07:36.940 --> 07:37.940
ARCHEMENT

07:37.940 --> 07:38.940
因为我们知道

07:38.940 --> 07:40.940
这个寒树的环境里边的

07:43.940 --> 07:45.940
因为我们知道寒树环境里边

07:45.940 --> 07:48.940
有一个特有的东西叫做ARCHEMENT

07:49.940 --> 07:51.940
那么我们来看一下

07:51.940 --> 07:53.940
或者就输出一下

07:55.940 --> 07:56.940
运行

07:57.940 --> 07:58.940
说明什么

07:58.940 --> 08:00.940
说明ARCHEMENT有没有

08:00.940 --> 08:01.940
它有

08:01.940 --> 08:03.940
它长度是多少

08:03.940 --> 08:06.940
说明它有五个参数

08:06.940 --> 08:08.940
当前的代码在寒树里边

08:08.940 --> 08:10.940
它同时有五个参数

08:10.940 --> 08:11.940
那我们来数一数

08:11.940 --> 08:12.940
这里是不是五个参数

08:12.940 --> 08:14.940
一 二 三 四 五

08:14.940 --> 08:16.940
就这么个意思

08:16.940 --> 08:18.940
我们的模块代码实际上在这

08:18.940 --> 08:19.940
懂了意思吧

08:19.940 --> 08:20.940
那么这个寒树准备好了

08:20.940 --> 08:21.940
在现在还没有运行

08:21.940 --> 08:24.940
它是如何来运行的呢

08:24.940 --> 08:26.940
我们接着往下看

08:26.940 --> 08:28.940
它在运行这个寒树之前

08:28.940 --> 08:29.940
这里在运行寒树

08:29.940 --> 08:30.940
在运行寒树之前

08:30.940 --> 08:31.940
创建了这么一个对象

08:31.940 --> 08:32.940
叫做MODU

08:32.940 --> 08:33.940
这个对象

08:33.940 --> 08:34.940
这个对象里边

08:34.940 --> 08:35.940
又有一个属性

08:35.940 --> 08:37.940
叫做EXPORT

08:37.940 --> 08:38.940
这个属性

08:38.940 --> 08:40.940
这个属性又是一个空对象

08:40.940 --> 08:41.940
然后它做了一个

08:41.940 --> 08:42.940
什么事呢

08:42.940 --> 08:43.940
它开始调用寒树了

08:43.940 --> 08:44.940
它怎么调用呢

08:44.940 --> 08:45.940
用CORD的方式来调用

08:45.940 --> 08:46.940
我们知道CORD的方式

08:46.940 --> 08:47.940
有什么特点

08:47.940 --> 08:48.940
是不是

08:48.940 --> 08:50.940
它可以绑定Z

08:50.940 --> 08:52.940
它把Z绑定为谁了

08:52.940 --> 08:55.940
绑定为这个对象

08:55.940 --> 08:57.940
然后传第一个参数

08:57.940 --> 08:58.940
第一个参数

08:58.940 --> 08:59.940
传给谁

08:59.940 --> 09:01.940
传给这个EXPORT

09:02.940 --> 09:03.940
它把这个东西

09:03.940 --> 09:04.940
这个空对象

09:04.940 --> 09:06.940
又传给了这个行参EXPORT

09:06.940 --> 09:09.940
然后又把require寒树

09:10.940 --> 09:12.940
require寒树本身

09:12.940 --> 09:14.940
又传给了第二个参数

09:14.940 --> 09:15.940
看不看

09:16.940 --> 09:17.940
然后接下来

09:17.940 --> 09:19.940
又把MODU

09:20.940 --> 09:22.940
又传给了第三个参数

09:23.940 --> 09:24.940
MODU是什么

09:24.940 --> 09:25.940
就是这个东西

09:25.940 --> 09:26.940
然后接下来

09:26.940 --> 09:27.940
第四个参数

09:27.940 --> 09:29.940
两个下滑线file name

09:29.940 --> 09:30.940
这个表示什么意思呢

09:30.940 --> 09:32.940
表示你不是要运行模块吗

09:32.940 --> 09:34.940
这里有个模块代码在这

09:34.940 --> 09:36.940
那么这个模块是一个文件

09:36.940 --> 09:37.940
它的文件路径是什么

09:37.940 --> 09:38.940
模块的路径

09:38.940 --> 09:40.940
它传给了这个

09:41.940 --> 09:42.940
然后最后一个

09:42.940 --> 09:43.940
模块所在的目录

09:43.940 --> 09:44.940
它又是一个路径

09:44.940 --> 09:45.940
传给了这个

09:45.940 --> 09:47.940
它就把这些数信息

09:47.940 --> 09:48.940
全部传给模块

09:48.940 --> 09:50.940
由于这些东西

09:50.940 --> 09:51.940
我们不用去背

09:51.940 --> 09:52.940
但是我们要抓住

09:52.940 --> 09:53.940
它几个关键点

09:53.940 --> 09:54.940
首先我们来看一下

09:54.940 --> 09:55.940
这样子传递过后

09:55.940 --> 09:57.940
解释了一个什么样的现象

09:57.940 --> 09:59.940
解释了我们的模块代码

09:59.940 --> 10:00.940
在这里运行

10:00.940 --> 10:01.940
说明我们这个模块代码

10:01.940 --> 10:02.940
在函数里边

10:02.940 --> 10:04.940
那能不能使用函数的参数

10:04.940 --> 10:06.940
是不是可以

10:06.940 --> 10:07.940
那么这些参数

10:07.940 --> 10:08.940
是不是都可以使用

10:08.940 --> 10:09.940
这就解释

10:09.940 --> 10:10.940
首先第一个

10:10.940 --> 10:11.940
我们在模块代码里边

10:11.940 --> 10:12.940
可以使用这个export

10:12.940 --> 10:15.320
为什么呢

10:15.320 --> 10:16.320
因为它是

10:16.320 --> 10:18.320
我们函数的参数

10:18.320 --> 10:19.320
看一下

10:19.320 --> 10:21.320
是不是一个空对象

10:21.320 --> 10:22.320
那我们来看一下

10:22.320 --> 10:23.320
这边是不是

10:23.320 --> 10:24.320
应该是个空对象

10:24.320 --> 10:25.320
这个export是怎么传过来的

10:25.320 --> 10:26.320
传递的是module.export

10:26.320 --> 10:28.320
是不是传到这个空对象

10:28.320 --> 10:30.320
把空对象传过来了

10:30.320 --> 10:31.320
对吧

10:31.320 --> 10:32.320
那我们在模块代码里边

10:32.320 --> 10:33.320
你能不能使用require

10:33.320 --> 10:34.320
可不可以

10:34.320 --> 10:35.320
当然可以

10:35.320 --> 10:36.320
为什么呢

10:36.320 --> 10:38.320
因为它是函数的参数

10:38.320 --> 10:39.320
我们在这里边

10:39.320 --> 10:42.320
能不能使用那个module

10:42.320 --> 10:43.320
当然我们当然可以

10:43.320 --> 10:45.320
我们知道在common.js里面导出

10:45.320 --> 10:47.320
是不是都是用module.export

10:47.320 --> 10:48.320
那么module是什么

10:48.320 --> 10:49.320
就是这个东西

10:49.320 --> 10:50.320
它把这个东西传过来

10:50.320 --> 10:52.320
然后我们在模块代码里边

10:52.320 --> 10:53.320
能不能使用file name

10:53.320 --> 10:54.320
dl name

10:54.320 --> 10:55.320
dl name

10:55.320 --> 10:56.320
也可以

10:56.320 --> 10:57.320
然后我们这里说出

10:57.320 --> 10:59.320
file name

11:00.320 --> 11:02.320
然后dl name

11:03.320 --> 11:04.320
然后运行

11:05.320 --> 11:07.320
你看是不是得到了这么两个

11:07.320 --> 11:08.320
我们分开吧

11:08.320 --> 11:09.320
分开

11:09.320 --> 11:10.320
这两段来运行

11:12.320 --> 11:14.320
dl name

11:14.320 --> 11:17.890
dl name

11:17.890 --> 11:18.890
好运行

11:19.890 --> 11:20.890
你看是不是得到了

11:20.890 --> 11:22.890
模块的完整的路径

11:22.890 --> 11:23.890
以及模块所在的

11:23.890 --> 11:24.890
目录的路径都能拿到

11:24.890 --> 11:25.890
为什么可以用这两个

11:25.890 --> 11:27.890
因为它们是函数的参数

11:27.890 --> 11:28.890
对吧

11:28.890 --> 11:29.890
这是我们模块里面

11:29.890 --> 11:30.890
可以用的东西

11:30.890 --> 11:31.890
当然除此之外

11:31.890 --> 11:32.890
我们当然也可以使用一些

11:32.890 --> 11:34.890
全局的辩量

11:34.890 --> 11:36.890
在load接受里面的全局辩量

11:36.890 --> 11:37.890
好

11:37.890 --> 11:38.890
那么我们

11:38.890 --> 11:39.890
然后最后运行的模块

11:39.890 --> 11:41.890
是不是就把代码运行的一边

11:41.890 --> 11:42.890
运行之后

11:42.890 --> 11:43.890
大家看

11:43.890 --> 11:44.890
后边还有两句

11:44.890 --> 11:45.890
第一句

11:45.890 --> 11:46.890
第一件事

11:46.890 --> 11:48.890
是要把module.export

11:48.890 --> 11:49.890
把这个玩意

11:49.890 --> 11:50.890
运行之后

11:50.890 --> 11:51.890
这个东西是不是有可能

11:51.890 --> 11:52.890
会被更改

11:52.890 --> 11:53.890
怎么更改呢

11:53.890 --> 11:54.890
因为我们在模块里面

11:54.890 --> 11:55.890
是不是会容易写这种代码

11:55.890 --> 11:57.890
module.export

11:57.890 --> 11:58.890
对吧

11:58.890 --> 11:59.890
给它复制

11:59.890 --> 12:00.890
复制为一些别的内容

12:00.890 --> 12:01.890
那么这个玩意

12:01.890 --> 12:02.890
一改的话

12:02.890 --> 12:03.890
你想

12:03.890 --> 12:04.890
我们把module

12:04.890 --> 12:05.890
传进去了

12:05.890 --> 12:06.890
是不是传到这儿了

12:06.890 --> 12:07.890
对吧

12:07.890 --> 12:08.890
那么它通过这个module

12:08.890 --> 12:10.890
那么这里的module

12:10.890 --> 12:11.890
是不是就是这个的module

12:11.890 --> 12:12.890
对吧

12:12.890 --> 12:13.890
它传过去了

12:13.890 --> 12:14.890
传过去了之后

12:14.890 --> 12:15.890
它通过

12:15.890 --> 12:16.890
更改这个export

12:16.890 --> 12:17.890
是不是就可以把

12:17.890 --> 12:18.890
这个东西改过

12:18.890 --> 12:19.890
变成什么

12:19.890 --> 12:20.890
变成123了

12:20.890 --> 12:21.890
懂了意思吗

12:21.890 --> 12:22.890
好

12:22.890 --> 12:23.890
那么这个传过去之后

12:23.890 --> 12:24.890
它就可以在模块

12:24.890 --> 12:25.890
在这里运行过程中

12:25.890 --> 12:26.890
可以去改这个东西

12:26.890 --> 12:27.890
那改完了之后呢

12:27.890 --> 12:29.890
就函数运行结束之后

12:29.890 --> 12:31.890
那么它会把这个module.export

12:31.890 --> 12:33.890
加入到缓存

12:33.890 --> 12:34.890
表示这个函数

12:34.890 --> 12:36.890
这个模块已经运行完了

12:36.890 --> 12:38.890
那么它的运行结果呢

12:38.890 --> 12:39.890
就从这里拿

12:39.890 --> 12:41.890
这就是它的运行结果

12:41.890 --> 12:42.890
把这个运行结果

12:42.890 --> 12:43.890
加入到缓存

12:43.890 --> 12:45.890
那么好处有什么

12:45.890 --> 12:46.890
好处之后

12:46.890 --> 12:47.890
再去读这个模块的时候

12:47.890 --> 12:48.890
它就不用再来一遍了

12:48.890 --> 12:50.890
它直接从缓存那边去去

12:50.890 --> 12:51.890
就这个意思

12:51.890 --> 12:52.890
好

12:52.890 --> 12:53.890
最后把require函数

12:53.890 --> 12:54.890
不得有个返回值吗

12:54.890 --> 12:55.890
对吧

12:55.890 --> 12:56.890
好处这个模块

12:56.890 --> 12:57.890
是不是有个返回值

12:57.890 --> 12:58.890
它返回的是什么

12:58.890 --> 13:01.890
返回的就是module.export

13:01.890 --> 13:03.890
那这个就是整个代码

13:03.890 --> 13:04.890
你把这个代码理解清楚过后

13:04.890 --> 13:06.890
所有的面试题都能做了

13:06.890 --> 13:07.890
那么我们看下

13:07.890 --> 13:09.890
面试题最容易怎么去考

13:09.890 --> 13:11.890
它主要就考虑是什么呢

13:11.890 --> 13:13.890
主要就考虑这几个东西

13:13.890 --> 13:14.890
Z的指向

13:14.890 --> 13:16.890
模块里面Z的指向

13:16.890 --> 13:18.890
以及呢就全聚啊

13:18.890 --> 13:19.890
全聚代码那边

13:19.890 --> 13:21.890
就这里边代码

13:21.890 --> 13:22.890
不

13:22.890 --> 13:23.890
因为这里边

13:23.890 --> 13:24.890
有可能再写函数对吧

13:24.890 --> 13:25.890
那么那就说不准了

13:25.890 --> 13:27.890
那就跟我们以前的Z的指向

13:27.890 --> 13:29.890
位置是一样的吧

13:29.890 --> 13:30.890
那我们关键是看全聚啊

13:30.890 --> 13:32.890
就说直接在这里呢

13:32.890 --> 13:33.890
输出一个Z

13:33.890 --> 13:34.890
它是啥

13:34.890 --> 13:36.890
都是比较容易考的点

13:36.890 --> 13:37.890
它是什么

13:37.890 --> 13:38.890
当然是个空队箱

13:38.890 --> 13:39.890
为什么是个空队箱

13:39.890 --> 13:41.890
你看Z是绑定的是啥

13:41.890 --> 13:42.890
绑定的就是个module.export

13:42.890 --> 13:43.890
是不是空队箱

13:43.890 --> 13:44.890
对不对

13:44.890 --> 13:46.890
那么这个一个是Z的指向

13:46.890 --> 13:47.890
一个是呢这个

13:47.890 --> 13:49.890
第一个参数export

13:49.890 --> 13:50.890
第一个参数是什么呢

13:50.890 --> 13:51.890
也跟Z是一样的

13:51.890 --> 13:52.890
你看到没

13:52.890 --> 13:53.890
是不是一样的

13:53.890 --> 13:54.890
对吧

13:54.890 --> 13:55.890
然后呢

13:55.890 --> 13:56.890
module

13:56.890 --> 13:57.890
module

13:57.890 --> 13:58.890
module是什么

13:58.890 --> 14:00.890
module就整个这个对象

14:00.890 --> 14:02.890
它可以用这种方式来考虑

14:02.890 --> 14:03.890
把这个地方要理解清楚

14:03.890 --> 14:05.890
所以说我们可以认为呢

14:05.890 --> 14:06.890
在load.js里面

14:06.890 --> 14:09.890
就是在那个common.js里面

14:09.890 --> 14:10.890
任何一个模块

14:10.890 --> 14:12.890
它运行之前

14:12.890 --> 14:14.890
你脑袋里面就想

14:14.890 --> 14:15.890
它有三个东西

14:15.890 --> 14:17.890
第一个是Z

14:17.890 --> 14:19.890
第二个是export

14:19.890 --> 14:21.890
是不是都是Z是绑定的

14:21.890 --> 14:23.890
export是它的参数

14:23.890 --> 14:26.890
然后还有一个就是module.export

14:26.890 --> 14:29.890
这三个东西是一样的

14:29.890 --> 14:31.890
你想一想是不是一样的

14:31.890 --> 14:32.890
你自己去对一下这个带吧

14:32.890 --> 14:33.890
是不是一样的

14:33.890 --> 14:35.890
Z是这个东西

14:35.890 --> 14:36.890
对吧

14:36.890 --> 14:38.890
然后呢

14:38.890 --> 14:39.890
export

14:39.890 --> 14:41.890
是不是也是这个东西

14:41.890 --> 14:43.890
它们都指向同一个对象

14:43.890 --> 14:44.890
然后还有什么呢

14:44.890 --> 14:45.890
还有module

14:45.890 --> 14:46.890
module是整个对象传进来

14:46.890 --> 14:47.890
然后呢

14:47.890 --> 14:48.890
它一个属性export

14:48.890 --> 14:49.890
那么这个属性export

14:49.890 --> 14:50.890
是不是也是这个东西

14:50.890 --> 14:52.890
说这三个东西是一样的

14:52.890 --> 14:54.890
但是它最终

14:54.890 --> 14:56.890
模块运行完之后

14:56.890 --> 14:57.890
它使用的是什么的

14:57.890 --> 14:58.890
它返回的是什么的

14:58.890 --> 15:00.890
就是这个require寒数返回的是什么

15:00.890 --> 15:02.890
返回的是这个module

15:02.890 --> 15:03.890
export

15:03.890 --> 15:04.890
返回的是它

15:04.890 --> 15:05.890
跟Z是没关系

15:05.890 --> 15:06.890
跟它也没关系

15:06.890 --> 15:08.890
但是在模块运行过程中

15:08.890 --> 15:10.890
它们这三个是一样的

15:10.890 --> 15:11.890
运行完了之后返回这个

15:11.890 --> 15:12.890
好

15:12.890 --> 15:14.890
咱们来看一下

15:14.890 --> 15:15.890
看一下这样子

15:15.890 --> 15:17.890
会有容易出什么样的链事题呢

15:17.890 --> 15:19.890
比方说它就这样子写

15:19.890 --> 15:20.890
很简单的

15:20.890 --> 15:22.890
zA等于1

15:22.890 --> 15:23.890
zB等于2

15:23.890 --> 15:25.890
那么这样子写了过后

15:25.890 --> 15:27.890
这个模块就这么一简单嘛

15:27.890 --> 15:29.890
比方说我们这里再来一个

15:29.890 --> 15:30.890
index.js

15:30.890 --> 15:32.890
然后它呢去导入

15:34.890 --> 15:37.890
导入这个1

15:37.890 --> 15:39.890
我们这里呢

15:39.890 --> 15:41.890
输出这个module

15:42.890 --> 15:44.890
好 那么它就问你

15:44.890 --> 15:47.650
放大一点

15:47.650 --> 15:48.650
好 那么它问你

15:48.650 --> 15:50.650
index.js输出完了

15:50.650 --> 15:53.650
你得到这个module到底是啥

15:53.650 --> 15:54.650
那能是啥呢

15:54.650 --> 15:55.650
你想啊

15:55.650 --> 15:57.650
它们都指向的是同一个对象

15:57.650 --> 15:58.650
对吧

15:58.650 --> 16:00.650
它们都是一个对象

16:00.650 --> 16:02.650
那么这个模块运行完了之后

16:02.650 --> 16:03.650
你现在它通过Z

16:03.650 --> 16:05.650
往这个对象里面加了一个啥呀

16:05.650 --> 16:06.650
加了一个

16:06.650 --> 16:08.650
数向A

16:08.650 --> 16:10.650
又往这个B里面加

16:10.650 --> 16:12.650
又往对象里面加了一个B

16:12.650 --> 16:13.650
等于2

16:13.650 --> 16:15.650
因为它们都是同一个对象

16:15.650 --> 16:16.650
所以说运行完了之后

16:16.650 --> 16:17.650
它

16:17.650 --> 16:19.650
因为我们最终用的是它嘛

16:19.650 --> 16:21.650
它是不是也是这个东西

16:21.650 --> 16:23.650
所以说最终运行的结果呢

16:23.650 --> 16:24.650
是什么

16:24.650 --> 16:26.650
就是A1 B2

16:29.650 --> 16:32.540
怎么了

16:33.540 --> 16:36.540
这个东西不能再重新被复制了

16:36.540 --> 16:38.540
因为已经有这个关键字了

16:38.540 --> 16:39.540
我们用AM吧

16:40.540 --> 16:41.540
换个名字

16:41.540 --> 16:42.540
就是A1 B2

16:42.540 --> 16:43.540
对吧

16:43.540 --> 16:44.540
这是一种情况

16:44.540 --> 16:46.540
那我们可以玩出很多的花样来

16:46.540 --> 16:48.540
比如说我这个模块啥也不写

16:48.540 --> 16:49.540
啥也不写我导入进来

16:49.540 --> 16:51.540
得到的结果是什么呢

16:51.540 --> 16:52.540
那你看看吧

16:52.540 --> 16:54.540
一开始是什么情况

16:54.540 --> 16:56.540
执行这个A1这个模块

16:56.540 --> 16:57.540
那么执行这个模块

16:57.540 --> 16:59.540
这个模块一开始就准备好这三个东西了

16:59.540 --> 17:00.540
对吧

17:00.540 --> 17:01.540
然后运行里边啥都没有

17:01.540 --> 17:02.540
没有的话就是空对象

17:02.540 --> 17:04.540
最终它是不是空对象

17:04.540 --> 17:05.540
那是空对象

17:05.540 --> 17:07.540
所以说得到的结果就是空对象

17:08.540 --> 17:10.540
那再比如说

17:10.540 --> 17:12.540
那我这里呢Z是A等于1

17:12.540 --> 17:15.540
然后呢Export B等于2

17:15.540 --> 17:17.540
那这样得到结果呢

17:17.540 --> 17:18.540
那不一样的吗

17:18.540 --> 17:20.540
Z里边你通过Z是个对象吗

17:20.540 --> 17:21.540
加一个1

17:21.540 --> 17:23.540
那Export数也是个对象

17:23.540 --> 17:24.540
B等于2

17:24.540 --> 17:25.540
对吧

17:25.540 --> 17:26.540
加一个2

17:26.540 --> 17:28.540
好 那么我们这里呢运行出来

17:28.540 --> 17:30.540
那不就还是A等于1B等于2吗

17:30.540 --> 17:31.540
对吧 没问题吧

17:31.540 --> 17:33.540
所以说我们有的时候呢

17:33.540 --> 17:34.540
在写模块的时候

17:34.540 --> 17:36.540
比方说我们要用common.js

17:36.540 --> 17:37.540
导出多个东西

17:37.540 --> 17:38.540
导出多个东西的时候呢

17:38.540 --> 17:40.540
我们可以用怎么写法

17:40.540 --> 17:41.540
用module.export

17:41.540 --> 17:43.540
给它付一个对象的

17:43.540 --> 17:44.540
这些东西对吧

17:44.540 --> 17:45.540
也可以写什么呢

17:45.540 --> 17:47.540
也可以写成这种格式

17:47.540 --> 17:48.540
A等于1

17:48.540 --> 17:49.540
当然也可以用Z

17:49.540 --> 17:50.540
所以Z呢

17:50.540 --> 17:51.540
我们平时开发用的少一点

17:51.540 --> 17:53.540
但是它其实效果是一样的

17:53.540 --> 17:55.540
这个数也是一样的

17:55.540 --> 17:57.540
那这样子肯定得到结果

17:57.540 --> 17:59.540
也是这个东西

17:59.540 --> 18:01.540
好 那么接下来呢

18:01.540 --> 18:02.540
它可能会跟那个

18:02.540 --> 18:03.540
你们学的

18:03.540 --> 18:05.540
你们之前学习的这个引用类型

18:05.540 --> 18:07.540
还是类型来进行

18:07.540 --> 18:09.540
穿插的考验

18:09.540 --> 18:10.540
比方说它这样子写啊

18:10.540 --> 18:11.540
A等于1

18:11.540 --> 18:14.540
然后呢我们通过这个module.export

18:14.540 --> 18:15.540
D等于2

18:15.540 --> 18:16.540
那么这种方式呢

18:16.540 --> 18:18.540
得到的结果是什么呢

18:18.540 --> 18:19.540
这导入的结果

18:19.540 --> 18:20.540
那不一样的吗

18:20.540 --> 18:21.540
你看啊

18:21.540 --> 18:23.540
我们通过A等于1

18:23.540 --> 18:25.540
那么是不是export是什么

18:25.540 --> 18:26.540
是这个对象

18:26.540 --> 18:27.540
找到这个对象

18:27.540 --> 18:29.540
里面加一个属性A等于1

18:29.540 --> 18:30.540
然后接下来呢

18:30.540 --> 18:32.540
通过module.export

18:32.540 --> 18:33.540
module.export

18:33.540 --> 18:34.540
所以也是这个对象啊

18:34.540 --> 18:36.540
里面加一个属性B等于2

18:36.540 --> 18:38.540
所以也是一样的

18:38.540 --> 18:39.540
好 我们再运行

18:39.540 --> 18:41.540
A等于B等于2

18:41.540 --> 18:44.540
但是它可能会这样子考虑

18:44.540 --> 18:45.540
比方说我们这里呢

18:45.540 --> 18:48.540
给它复制一个新的对象B等于2

18:48.540 --> 18:50.540
那这样子是不是有变化呢

18:50.540 --> 18:52.540
这样子确实有变化

18:52.540 --> 18:53.540
为什么有变化

18:53.540 --> 18:54.540
大家来看着啊

18:54.540 --> 18:56.540
一开始是空对象没错吧

18:56.540 --> 18:58.540
然后呢Z三个都是一样的啊

18:58.540 --> 18:59.540
接下来呢通过export

18:59.540 --> 19:00.540
export是什么

19:00.540 --> 19:01.540
是这个对象吧

19:01.540 --> 19:04.540
然后里面加一个属性A等于1

19:04.540 --> 19:05.540
没问题吧

19:05.540 --> 19:06.540
好 接下来

19:06.540 --> 19:08.540
module.export

19:08.540 --> 19:09.540
是不是找到这个对象

19:09.540 --> 19:10.540
A怎么样

19:10.540 --> 19:13.540
给它重新复制

19:14.540 --> 19:16.540
不是给这个对象重新复制

19:16.540 --> 19:18.540
是给这个东西重新复制

19:18.540 --> 19:20.540
这样子一重新复制

19:20.540 --> 19:23.540
它就不再指向这个对象了

19:23.540 --> 19:24.540
同学们

19:24.540 --> 19:25.540
因为你该改了

19:25.540 --> 19:26.540
它本来指向这个对象的

19:26.540 --> 19:28.540
它本来里面从那个地址

19:28.540 --> 19:30.540
这个地址是指向这个对象的

19:30.540 --> 19:31.540
但是你给它重新复制

19:31.540 --> 19:32.540
一个新的对象

19:32.540 --> 19:33.540
是不是地址改了啊

19:33.540 --> 19:35.540
改成什么了

19:35.540 --> 19:36.540
它就不再指向这个对象了

19:36.540 --> 19:39.540
改成了指向一个新的对象

19:39.540 --> 19:40.540
这个新的对象的是

19:40.540 --> 19:42.540
有一个B等于2

19:42.540 --> 19:43.540
变成这种逻辑了

19:43.540 --> 19:45.540
那么它们之间是不是被分离了

19:45.540 --> 19:46.540
分离了之后

19:46.540 --> 19:48.540
那最终运行结束之后

19:48.540 --> 19:49.540
用的是谁

19:49.540 --> 19:50.540
用的是它

19:50.540 --> 19:51.540
所以说我们最终得到结果

19:51.540 --> 19:52.540
只有B等于2

19:52.540 --> 19:53.540
跟它们两个

19:53.540 --> 19:54.540
已经没有什么关系了

19:54.540 --> 19:55.540
现在

19:55.540 --> 19:56.540
好 咱们来看一下运行

19:56.540 --> 19:58.540
只有B等于2

19:58.540 --> 20:00.540
当然我们平时写代码的话

20:00.540 --> 20:02.540
千万千万不要这样去写

20:02.540 --> 20:03.540
这样子写的话

20:03.540 --> 20:04.540
特别容易导致混乱

20:04.540 --> 20:05.540
它们两个分割

20:05.540 --> 20:06.540
它们这些东西分割了

20:06.540 --> 20:08.540
你要么就用module.export

20:08.540 --> 20:09.540
就复一次值

20:09.540 --> 20:11.540
用个对象给它加多个信息

20:11.540 --> 20:14.540
要么就使用export一个一个加

20:14.540 --> 20:15.540
但是不要混着用

20:15.540 --> 20:17.540
混着用特别容易导致这个问题

20:17.540 --> 20:18.540
对吧

20:18.540 --> 20:20.540
这跟刚才的情况是不一样的

20:20.540 --> 20:21.540
比方说刚才是这样的写

20:21.540 --> 20:23.540
这样的写又不一样了

20:23.540 --> 20:24.540
比方说现在我们这样的写

20:24.540 --> 20:25.540
又怎么来理解呢

20:25.540 --> 20:28.540
那看着吧

20:28.540 --> 20:30.540
它们一开始是一个东西

20:30.540 --> 20:32.540
是一个对象

20:32.540 --> 20:33.540
一开始是一个对象

20:33.540 --> 20:34.540
现在呢

20:34.540 --> 20:35.540
我们

20:35.540 --> 20:37.540
通过这个export

20:37.540 --> 20:38.540
找一个对象

20:38.540 --> 20:39.540
给它加了一个属性

20:39.540 --> 20:40.540
不是对export重新复制

20:40.540 --> 20:42.540
是给它里面对象里面

20:42.540 --> 20:44.540
一个属性重新复制

20:44.540 --> 20:45.540
所以找到对象

20:45.540 --> 20:46.540
重新给它加了一个属性

20:46.540 --> 20:47.540
没问题

20:47.540 --> 20:48.540
然后呢

20:48.540 --> 20:49.540
又找到export

20:49.540 --> 20:50.540
找到这个变量

20:50.540 --> 20:51.540
这个变量呢

20:51.540 --> 20:53.540
它又对应到一个对象

20:53.540 --> 20:55.540
不是给它重新复制

20:55.540 --> 20:56.540
给它重新复制

20:56.540 --> 20:57.540
它就脱离了

20:57.540 --> 20:59.540
就变了

20:59.540 --> 21:00.540
吃给谁

21:00.540 --> 21:03.540
给对象里面加一个属性

21:03.540 --> 21:04.540
重新复制

21:04.540 --> 21:05.540
复制为什么

21:05.540 --> 21:06.540
复制为一个对象

21:06.540 --> 21:07.540
比等于

21:07.540 --> 21:09.540
变成这个样子了

21:09.540 --> 21:11.540
那么现在我们来看一下

21:11.540 --> 21:12.540
没问题是吧

21:12.540 --> 21:13.540
你把这个东西

21:13.540 --> 21:14.540
理解清楚了

21:14.540 --> 21:15.540
这种各种各样的题呢

21:15.540 --> 21:17.540
都可以水晶应变了

21:17.540 --> 21:18.540
好

21:18.540 --> 21:19.540
咱们来看一下

21:19.540 --> 21:20.540
这一块的代码题

21:20.540 --> 21:21.540
比方

21:21.540 --> 21:26.190
我们下面有一道面式题

21:26.190 --> 21:29.820
这里

21:29.820 --> 21:30.820
就这个题

21:30.820 --> 21:31.820
那么请问

21:31.820 --> 21:32.820
这个代码

21:32.820 --> 21:37.460
导出了什么样的结果

21:37.460 --> 21:38.460
来吧

21:38.460 --> 21:39.460
我们来看一下

21:39.460 --> 21:40.460
这道题吧

21:40.460 --> 21:41.460
非常容易解议

21:41.460 --> 21:42.460
那么首先你就画出来

21:42.460 --> 21:43.460
平时做这种代码题的时候

21:43.460 --> 21:44.460
最好

21:44.460 --> 21:45.460
像老师这样子

21:45.460 --> 21:46.460
把它画一下

21:46.460 --> 21:48.460
在纸上打个操告

21:48.460 --> 21:50.460
这三个东西是一个对象吧

21:50.460 --> 21:51.460
然后通过这个exports

21:51.460 --> 21:53.460
里面找到一个a

21:53.460 --> 21:54.460
给它复制为什么呢

21:54.460 --> 21:55.460
复制为a

21:55.460 --> 21:56.460
这个没问题吧

21:56.460 --> 21:58.460
然后找到module的exports

21:58.460 --> 21:59.460
找到这个东西

21:59.460 --> 22:00.460
但是不是给它重新复制

22:00.460 --> 22:01.460
是给它里面一个属性

22:01.460 --> 22:03.460
找到对象里面的属性

22:03.460 --> 22:05.460
加一个b

22:05.460 --> 22:06.460
然后又到z

22:06.460 --> 22:08.460
z不是还是个对象吗

22:08.460 --> 22:09.460
给它再加一个属性

22:09.460 --> 22:10.460
c

22:10.460 --> 22:12.460
复制为c

22:12.460 --> 22:13.460
接下来呢

22:13.460 --> 22:15.460
又对xmodule的exports

22:15.460 --> 22:16.460
是吧

22:16.460 --> 22:17.460
给它重新改了

22:17.460 --> 22:19.460
它本来是指向这个对象的

22:19.460 --> 22:20.460
结果一改

22:20.460 --> 22:21.460
它就不再指向这个对象了

22:21.460 --> 22:22.460
指向了谁呢

22:22.460 --> 22:24.460
指向了另外一个对象

22:24.460 --> 22:26.460
d等于d

22:26.460 --> 22:28.460
那么请问最后导出什么了

22:28.460 --> 22:29.460
导出当然就是一个d

22:29.460 --> 22:30.460
就其他啥都没有

22:30.460 --> 22:31.460
我们运行一下

22:31.460 --> 22:33.460
不就是只有一个d吗

22:33.460 --> 22:34.460
所以说这一块

22:34.460 --> 22:36.460
你就按照这种方式来解题

22:36.460 --> 22:38.460
就已经问题都没有

22:38.460 --> 22:40.460
这是common.js

22:40.460 --> 22:42.460
我们来看一下exmodule

22:42.460 --> 22:44.460
首先抓住它几个关键词

22:44.460 --> 22:50.790
关键词

22:50.790 --> 22:52.790
官方标准

22:52.790 --> 22:54.790
随着es2015

22:54.790 --> 22:56.790
就是es6一起发布的

22:56.790 --> 22:57.790
官方标准

22:57.790 --> 22:59.790
那么既然是官方标准

22:59.790 --> 23:01.790
所有环境都会支持

23:01.790 --> 23:03.790
你得适配官方吧

23:03.790 --> 23:04.790
loader环境里边也能支持

23:04.790 --> 23:06.790
现在也能支持了

23:06.790 --> 23:07.790
过去还不能支持

23:07.790 --> 23:08.790
现在你要支持的话

23:08.790 --> 23:09.790
但是得出一些处理

23:09.790 --> 23:11.790
不过我们在loader环境里边

23:11.790 --> 23:12.790
就使用esmodule

23:12.790 --> 23:15.790
就使用了common.js

23:15.790 --> 23:17.790
那么既然是官方标准的话

23:17.790 --> 23:19.790
因为官方他权力大

23:19.790 --> 23:20.790
他说了算

23:20.790 --> 23:22.790
所以他搞了一些新的语法出来

23:22.790 --> 23:24.790
你们回顾一下esmodule

23:24.790 --> 23:26.790
它是不是导入模块

23:26.790 --> 23:27.790
是用这样的鞋的

23:27.790 --> 23:28.790
这是不是新语法

23:28.790 --> 23:29.790
这是新语法

23:29.790 --> 23:30.790
是不是新语法

23:30.790 --> 23:32.790
当然是新语法

23:32.790 --> 23:35.790
这个语法以前哪有

23:35.790 --> 23:36.790
还有导出的时候

23:36.790 --> 23:37.790
是一个sport关键字

23:37.790 --> 23:39.790
导出

23:39.790 --> 23:42.790
那么这些都是新语法

23:42.790 --> 23:47.790
同时支持静态依赖和动态依赖

23:47.790 --> 23:48.790
都支持

23:48.790 --> 23:50.790
什么叫静态依赖呢

23:50.790 --> 23:51.790
静态依赖就是

23:51.790 --> 23:53.790
我们之前写的这个代码

23:53.790 --> 23:58.000
过来我们再代码里边写吧

23:58.000 --> 24:01.000
再来一个esmodule

24:01.000 --> 24:03.000
我们这里一个模块a

24:03.000 --> 24:06.000
到静态依赖是什么意思呢

24:06.000 --> 24:08.000
比如我们这里模块a

24:08.000 --> 24:09.000
然后一个index.js

24:09.000 --> 24:11.000
它导入模块a

24:11.000 --> 24:12.000
这个模块a的时候

24:12.000 --> 24:13.000
它可以怎么导入呢

24:13.000 --> 24:15.000
静态依赖是用这种方式

24:15.000 --> 24:20.380
导入一个esmodule

24:20.380 --> 24:21.380
没问题吧

24:21.380 --> 24:23.380
那么这就是一个静态依赖

24:23.380 --> 24:25.380
表示我这个模块

24:25.380 --> 24:27.380
肯定依赖建设

24:27.380 --> 24:28.380
由于它是静态依赖

24:28.380 --> 24:29.380
所以说这个代码

24:29.380 --> 24:30.380
导入代码

24:30.380 --> 24:32.380
它不能像common建设那样

24:32.380 --> 24:33.380
随意导写到什么

24:33.380 --> 24:34.380
判断、循环里边

24:34.380 --> 24:36.380
甚至函数里面不能

24:36.380 --> 24:37.380
它必须要写到

24:37.380 --> 24:38.380
这个模块的最顶部

24:38.380 --> 24:40.380
一开始叫声明

24:40.380 --> 24:41.380
我这个模块

24:41.380 --> 24:42.380
在这些过程中

24:42.380 --> 24:44.380
我要可能会用到哪些模块

24:44.380 --> 24:46.380
一开始叫声明

24:46.380 --> 24:49.380
叫静态依赖

24:49.380 --> 24:51.380
这个跟那个common.js

24:51.380 --> 24:52.380
不一样了

24:52.380 --> 24:53.380
common.js动态依赖

24:53.380 --> 24:54.380
是一个require函数

24:54.380 --> 24:56.380
require函数可以寫到任何地方

24:56.380 --> 24:59.380
require函数

24:59.380 --> 25:00.380
可以寫到这些地方

25:00.380 --> 25:01.380
都可以

25:01.380 --> 25:03.380
但是这个代码是绝对不行的

25:03.380 --> 25:04.380
你这个东西

25:04.380 --> 25:05.380
它就爆错了

25:05.380 --> 25:08.380
叫语法错

25:08.380 --> 25:10.380
当然我这个是node环境

25:10.380 --> 25:16.380
我们的浏览器环境

25:16.380 --> 25:17.380
我们浏览器里边

25:17.380 --> 25:19.380
去读取这个

25:19.380 --> 25:20.380
index的解释

25:20.380 --> 25:23.380
然后tap给它设置为module

25:23.380 --> 25:25.380
好 接下来我们就打开

25:25.380 --> 25:32.100
好 你看

25:32.100 --> 25:33.100
是不是语法错误

25:33.100 --> 25:34.100
对吧

25:34.100 --> 25:35.100
它直接可以爆语法错了

25:35.100 --> 25:36.100
它根本就识别不了的

25:36.100 --> 25:37.100
这个东西

25:37.100 --> 25:39.100
它必须要是静态依赖

25:39.100 --> 25:41.100
必须要放到最顶部

25:41.100 --> 25:42.100
如果不放到最顶部

25:42.100 --> 25:44.100
好像也没有爆错

25:44.100 --> 25:46.100
这是不对的显化

25:46.100 --> 25:47.100
当然浏览器

25:47.100 --> 25:48.100
它有纠错功能

25:48.100 --> 25:49.100
所以说呢

25:49.100 --> 25:50.100
它发现你不在最顶部

25:50.100 --> 25:52.100
它最终会给你提到最顶部

25:52.100 --> 25:54.100
但最好不要去写功能单

25:54.100 --> 25:55.100
导入语句

25:55.100 --> 25:56.100
用es6的导入语句

25:56.100 --> 25:58.100
一定要放到最顶部

25:58.100 --> 26:02.570
那么现在

26:02.570 --> 26:03.570
这边没有导出

26:03.570 --> 26:05.570
你看到错误已经不一样了

26:05.570 --> 26:06.570
对不对

26:06.570 --> 26:07.570
它没有导出

26:07.570 --> 26:09.570
这里爆错了

26:09.570 --> 26:11.570
插插插

26:11.570 --> 26:14.570
就随便写个吧

26:14.570 --> 26:15.570
好 就没有爆错了

26:15.570 --> 26:16.570
对吧

26:16.570 --> 26:17.570
然后如果说你写到这

26:17.570 --> 26:18.570
再看一下

26:18.570 --> 26:19.570
写到这

26:19.570 --> 26:20.570
爆错了

26:20.570 --> 26:21.570
对吧

26:21.570 --> 26:22.570
语法错误

26:22.570 --> 26:23.570
这是它静态依赖的特点

26:23.570 --> 26:24.570
必须要写到最顶部

26:24.570 --> 26:25.570
不能放到任何

26:25.570 --> 26:26.570
判断循环

26:26.570 --> 26:27.570
喊数里面都不行

26:27.570 --> 26:28.570
OK

26:28.570 --> 26:31.570
这是这么一个特点

26:31.570 --> 26:32.570
好

26:32.570 --> 26:33.570
然后下一个

26:33.570 --> 26:34.570
还有就是

26:34.570 --> 26:36.570
它不仅支持静态依赖

26:36.570 --> 26:37.570
静态依赖什么意思

26:37.570 --> 26:38.570
在代码运行前

26:38.570 --> 26:39.570
就还没有运行代码

26:39.570 --> 26:41.570
我就必须要确定依赖关系

26:41.570 --> 26:43.570
它还支持动态依赖

26:43.570 --> 26:44.570
过去了

26:44.570 --> 26:45.570
动态依赖没有形成标准

26:45.570 --> 26:46.570
但是现在

26:46.570 --> 26:47.570
好像在去年

26:47.570 --> 26:48.570
2020年

26:49.570 --> 26:50.570
什么要动态依赖

26:50.570 --> 26:51.570
而且大家接触过

26:51.570 --> 26:52.570
你们用无忧的时候

26:52.570 --> 26:53.570
是不是有一些

26:53.570 --> 26:54.570
什么路由懒家债

26:54.570 --> 26:55.570
这个东西

26:55.570 --> 26:56.570
对吧

26:56.570 --> 26:57.570
我们可以这样的携带

26:57.570 --> 26:58.570
Import

26:58.570 --> 27:00.570
又把它变成一个函数的

27:00.570 --> 27:01.570
就有点像Require函数了

27:01.570 --> 27:02.570
对不对

27:02.570 --> 27:03.570
Adder也是

27:03.570 --> 27:04.570
所以用这种方式

27:04.570 --> 27:05.570
然后这里

27:05.570 --> 27:07.570
会返回一个Promise

27:07.570 --> 27:09.570
会返回一个Promise

27:09.570 --> 27:10.570
那么我们可以用Z

27:10.570 --> 27:12.570
Promise里面的数据是什么

27:12.570 --> 27:14.570
就是导入这个模块

27:14.570 --> 27:15.570
因为家庭的模块

27:15.570 --> 27:16.570
它可能需要

27:16.570 --> 27:17.570
加在文件

27:17.570 --> 27:18.570
需要进行网络通信

27:18.570 --> 27:20.570
因为在浏览性环境里面

27:20.570 --> 27:22.570
它网络通信需要一段时间

27:22.570 --> 27:23.570
这里需要一年

27:23.570 --> 27:24.570
就是夸张一点

27:24.570 --> 27:25.570
那我不可能代码

27:25.570 --> 27:26.570
就卡在这里

27:26.570 --> 27:27.570
卡一年

27:27.570 --> 27:28.570
Require就真的会卡一年

27:28.570 --> 27:30.570
那这里就不会

27:30.570 --> 27:32.570
我们说的比较夸张

27:32.570 --> 27:34.570
肯定是没有那么长的时间

27:34.570 --> 27:36.570
这导入过后

27:36.570 --> 27:38.570
它有一个异部处理

27:38.570 --> 27:40.570
它是一个异部任务

27:40.570 --> 27:42.570
当我们模块加在完成之后

27:42.570 --> 27:43.570
还会在这里面

27:43.570 --> 27:44.570
把这个模块的所有东西

27:44.570 --> 27:48.570
放到这个参数里面

27:48.570 --> 27:50.570
保存

27:52.570 --> 27:54.570
这写错了

27:54.570 --> 27:56.570
再写到这边

27:56.570 --> 28:02.250
这边导出一个

28:02.250 --> 28:03.250
你看

28:03.250 --> 28:05.250
是不是我们加在完成之后

28:05.250 --> 28:07.250
就得到这个模块对象

28:07.250 --> 28:09.250
这个东西不用解释了吧

28:09.250 --> 28:11.250
ES module里面我讲过的

28:11.250 --> 28:12.250
它整个导出

28:12.250 --> 28:13.250
就是一个

28:13.250 --> 28:15.250
相当于是一个对象

28:15.250 --> 28:16.250
相当于是一个对象

28:16.250 --> 28:17.250
对象里面有很多属性

28:17.250 --> 28:19.250
其中一个特殊属性叫Default

28:19.250 --> 28:21.250
表示默认导出

28:21.250 --> 28:23.250
得到这么一个对象

28:23.250 --> 28:24.250
当然如果说你在这边

28:24.250 --> 28:26.250
还导出一些具名导出的话

28:26.250 --> 28:28.250
比如Code等于您

28:28.250 --> 28:29.250
保存

28:29.250 --> 28:30.250
你看

28:30.250 --> 28:31.250
这里面就有两个属性

28:31.250 --> 28:33.250
一个Code有Default

28:33.250 --> 28:34.250
没问题吧

28:34.250 --> 28:35.250
这就是

28:35.250 --> 28:37.250
它也支持动态依赖

28:37.250 --> 28:38.250
只不过它动态依赖的

28:38.250 --> 28:40.250
跟common介石还不一样

28:40.250 --> 28:41.250
common介石的动态依赖

28:41.250 --> 28:42.250
是同步的

28:42.250 --> 28:43.250
它是异部的

28:43.250 --> 28:44.250
你看这里导入的时候

28:44.250 --> 28:46.250
是不是我要把它放到

28:46.250 --> 28:47.250
Zen里面才能

28:47.250 --> 28:49.250
夹在完成之后

28:49.250 --> 28:51.250
用异部的方式来处理

28:51.250 --> 28:52.250
这个问题

28:52.250 --> 28:54.250
处理一个模块导入的结果

28:54.250 --> 28:55.250
它不会在这里等待

28:55.250 --> 28:56.250
它继续往后边运行

28:56.250 --> 28:57.250
后边待

28:57.250 --> 28:59.250
当然由于它是动态依赖

28:59.250 --> 29:00.250
所以它跟require一样

29:00.250 --> 29:03.250
可不可以写到判断里边可以

29:03.250 --> 29:04.250
写到循环里边可以

29:04.250 --> 29:05.250
写到函数里边可以

29:05.250 --> 29:06.250
那么这种动态依赖

29:06.250 --> 29:07.250
就是在运行的时候

29:07.250 --> 29:09.250
才能去领一代关系了

29:09.250 --> 29:11.250
它既支持静态

29:11.250 --> 29:12.250
也支持动态的

29:12.250 --> 29:14.250
都可以

29:14.250 --> 29:15.250
好

29:15.250 --> 29:17.250
这个点就是符号绑定

29:17.250 --> 29:18.250
ES模块的话

29:18.250 --> 29:20.250
这一块如果说出代码题

29:20.250 --> 29:21.250
最容易出的代码题

29:21.250 --> 29:23.250
就是符号绑定

29:23.250 --> 29:24.250
这是什么意思呢

29:24.250 --> 29:25.250
这是一个你们接触

29:25.250 --> 29:26.250
GSE以来

29:26.250 --> 29:28.250
前所未有的一个现象

29:28.250 --> 29:29.250
可能有些同学

29:29.250 --> 29:30.250
可能注意不到

29:30.250 --> 29:32.250
这个现象是特别奇特的

29:32.250 --> 29:34.250
甚至有些

29:34.250 --> 29:36.250
开发者的观点就是

29:36.250 --> 29:37.250
不应该你把这种现象

29:37.250 --> 29:38.250
包裹在GSE里边

29:38.250 --> 29:39.250
很奇怪

29:39.250 --> 29:41.250
因为GSE整个语言环境里边

29:41.250 --> 29:43.250
就没有这个东西

29:43.250 --> 29:44.250
这是什么意思呢

29:44.250 --> 29:46.250
比方说我们A里边

29:46.250 --> 29:48.250
导出了这么一个Code

29:48.250 --> 29:49.250
一个变量

29:49.250 --> 29:50.250
这个变量是谁的

29:50.250 --> 29:51.250
是A的

29:51.250 --> 29:52.250
对吧

29:52.250 --> 29:54.250
然后我再导出一个

29:54.250 --> 29:56.250
函数吧

29:56.250 --> 29:57.250
导出一个函数

29:57.250 --> 29:59.250
方形

29:59.250 --> 30:00.250
Increase

30:00.250 --> 30:01.250
增加

30:01.250 --> 30:02.250
这是什么意思呢

30:02.250 --> 30:05.560
它就把这个Code加加

30:05.560 --> 30:07.560
然后这些东西我都不要了

30:07.560 --> 30:08.560
这些我都不要了

30:08.560 --> 30:10.560
来 我们来试一下

30:10.560 --> 30:11.560
我们先用静态一代

30:11.560 --> 30:12.560
动态一代都是一样的

30:12.560 --> 30:13.560
来试一下

30:13.560 --> 30:14.560
我们现在

30:14.560 --> 30:17.940
from.a

30:17.940 --> 30:18.940
这里边有两个对吧

30:18.940 --> 30:19.940
有两个东西

30:19.940 --> 30:21.940
一个函数一个Code

30:21.940 --> 30:23.940
我们这里把两个都导入进来

30:23.940 --> 30:24.940
Code

30:24.940 --> 30:26.940
Increase

30:26.940 --> 30:28.940
接下来我们把这个

30:28.940 --> 30:30.940
放到分个屏

30:30.940 --> 30:31.940
就这样子

30:31.940 --> 30:32.940
看得清楚一点

30:32.940 --> 30:33.940
现在我们要做什么呢

30:33.940 --> 30:35.940
我们先输出一下Code

30:35.940 --> 30:37.940
然后再调用Increase

30:37.940 --> 30:40.940
然后再输出一下Code

30:40.940 --> 30:41.940
我们来看一下

30:41.940 --> 30:42.940
先来分析一下

30:42.940 --> 30:45.940
应该输出什么

30:45.940 --> 30:46.940
我们来分析一下

30:46.940 --> 30:47.940
你就会发现这个事情

30:47.940 --> 30:51.940
就变得很奇怪了

30:51.940 --> 30:52.940
什么情况呢

30:52.940 --> 30:53.940
我们来看一下

30:53.940 --> 30:54.940
这里有个Code

30:54.940 --> 30:55.940
这个Code是谁的

30:55.940 --> 30:57.940
是不是这个模块呢

30:57.940 --> 30:59.940
是这个模块的吧

30:59.940 --> 31:00.940
对吧

31:00.940 --> 31:01.940
也就是我们觉得

31:01.940 --> 31:03.940
这里应该有一块内存空间

31:03.940 --> 31:05.940
它的名字叫做Code

31:05.940 --> 31:06.940
这块内存空间

31:06.940 --> 31:07.940
里面有一个数据

31:07.940 --> 31:08.940
是什么呢

31:08.940 --> 31:11.940
是0

31:11.940 --> 31:15.310
这个没问题

31:15.310 --> 31:16.310
接下来有一个Increase

31:16.310 --> 31:18.310
来说这个不说了

31:18.310 --> 31:19.310
我们就关键看Code

31:19.310 --> 31:21.310
Increase来说也是有

31:21.310 --> 31:23.310
这个现象存在

31:23.310 --> 31:24.310
比方说

31:24.310 --> 31:26.310
我们现在

31:26.310 --> 31:28.310
这边导入Adder.js

31:28.310 --> 31:30.310
这边导入Adder.js

31:30.310 --> 31:32.310
导入进来过后

31:32.310 --> 31:33.310
它也有一个

31:33.310 --> 31:34.310
就是导入了两个东西

31:34.310 --> 31:36.310
一个Code,Increase

31:36.310 --> 31:37.310
按照我们

31:37.310 --> 31:39.310
正常人的思维

31:39.310 --> 31:40.310
就应该是什么呢

31:40.310 --> 31:41.310
就应该这里

31:41.310 --> 31:42.310
这里的Code

31:42.310 --> 31:43.310
跟这里的Code

31:43.310 --> 31:44.310
是不是一样的

31:44.310 --> 31:45.310
它不是一样的

31:45.310 --> 31:46.310
应该是两个变量

31:46.310 --> 31:48.310
这边有一个变量

31:48.310 --> 31:49.310
它这边有一个变量的

31:49.310 --> 31:50.310
也叫做Code

31:50.310 --> 31:51.310
名字一样

31:51.310 --> 31:52.310
因为这个名字

31:52.310 --> 31:53.310
也可以改嘛

31:53.310 --> 31:54.310
对不对

31:54.310 --> 31:55.310
你们知不知道

31:55.310 --> 31:56.310
这个名字是可以改的

31:56.310 --> 31:59.310
比方说我们这里改成C

31:59.310 --> 32:00.310
我们改成C

32:00.310 --> 32:02.310
改不改都随时都有这个现象

32:02.310 --> 32:04.310
你看吧

32:04.310 --> 32:05.310
我们把它改成C

32:05.310 --> 32:06.310
这样子

32:06.310 --> 32:07.310
大家看到就是

32:07.310 --> 32:09.310
更加清楚了

32:09.310 --> 32:10.310
这里一个变量C

32:10.310 --> 32:12.310
它也是一块内存空间吗

32:12.310 --> 32:14.310
这两个内存空间一样吗

32:14.310 --> 32:15.310
肯定不一样吧

32:15.310 --> 32:16.310
只不过

32:16.310 --> 32:18.310
内存空间里装的东西是一样的

32:18.310 --> 32:20.310
相当于是把这个变量的0

32:20.310 --> 32:23.310
复制给了这个变量C

32:23.310 --> 32:25.310
它应该是个长量

32:25.310 --> 32:27.310
它不能更改的

32:27.310 --> 32:29.310
那么复制过来了

32:29.310 --> 32:31.310
接下来我们来看一下这个现象

32:31.310 --> 32:33.310
一开始输出C

32:33.310 --> 32:34.310
肯定是输出0

32:34.310 --> 32:35.310
这个没问题

32:35.310 --> 32:36.310
一开始就输出这个0

32:36.310 --> 32:37.310
然后接下来

32:37.310 --> 32:38.310
调用一个Increase

32:38.310 --> 32:39.310
调用的是谁

32:39.310 --> 32:40.310
调用这个函数

32:40.310 --> 32:41.310
调用这个函数

32:41.310 --> 32:42.310
是不是把Code加加

32:42.310 --> 32:43.310
加的是谁

32:43.310 --> 32:44.310
加的是这个Code

32:44.310 --> 32:45.310
所以这里变成1

32:45.310 --> 32:46.310
跟这里有关系吗

32:46.310 --> 32:47.310
没有关系

32:47.310 --> 32:48.310
所以这里再输出C的时候

32:48.310 --> 32:49.310
还是输出0

32:49.310 --> 32:51.310
这才是正常的

32:51.310 --> 32:52.310
这才是符合

32:52.310 --> 32:54.310
我们企业史前端开发者的思维的

32:54.310 --> 32:56.310
这边跟这边没有什么关系

32:56.310 --> 32:57.310
其实这样子做

32:57.310 --> 32:59.310
两个0是最好的

32:59.310 --> 33:01.310
我个人认为是最好的

33:01.310 --> 33:02.310
为什么呢

33:02.310 --> 33:04.310
因为我这里有一个标识符C

33:04.310 --> 33:05.310
这个C是哪来的

33:05.310 --> 33:07.310
是在这个模块里面出现的

33:08.310 --> 33:10.310
那么只有这个模块能改变它

33:11.310 --> 33:12.310
我不可能说

33:12.310 --> 33:13.310
我去调用一个函数

33:13.310 --> 33:14.310
这个函数在别的模块里面

33:14.310 --> 33:16.310
别的模块把我这个

33:16.310 --> 33:17.310
变量给我改了

33:17.310 --> 33:18.310
这个太奇怪了

33:18.310 --> 33:19.310
那么这样子导致

33:19.310 --> 33:20.310
导致一个什么现象呢

33:20.310 --> 33:22.310
就是我现在都不能信任

33:22.310 --> 33:23.310
这个变量的值了

33:23.310 --> 33:25.310
因为我们这个模块没改

33:25.310 --> 33:26.310
别的模块给我改了

33:26.310 --> 33:27.310
这很奇怪

33:28.310 --> 33:29.310
那么我们像

33:29.310 --> 33:30.310
一个工程里面

33:30.310 --> 33:31.310
模块这么多

33:31.310 --> 33:32.310
那我写个模块的时候

33:32.310 --> 33:33.310
是不是很担心

33:33.310 --> 33:35.310
那这个变量怎么

33:35.310 --> 33:37.310
能够被别的模块改了呢

33:37.310 --> 33:38.310
对不对

33:38.310 --> 33:39.310
所以说这里呢

33:39.310 --> 33:41.310
得到了应该是两个领彩队

33:43.310 --> 33:45.310
应该在浏览器里面

33:45.310 --> 33:47.310
结果它给我得到的是零合一

33:47.310 --> 33:49.310
那这又该怎么解释呢

33:49.310 --> 33:50.310
这叫做符号绑定

33:50.310 --> 33:52.310
这是解释在这一块

33:52.310 --> 33:53.310
就模块化这一块

33:53.310 --> 33:55.310
出来的新的一个现象

33:55.310 --> 33:57.310
你们以前从来没接触过

33:57.310 --> 33:59.310
你们以前做变量负质

33:59.310 --> 34:00.310
全是我刚才说的那种情况

34:00.310 --> 34:01.310
他们虽然是

34:01.310 --> 34:02.310
同一个词

34:02.310 --> 34:03.310
但是他们是两个空间

34:03.310 --> 34:04.310
比方说我们以前

34:04.310 --> 34:05.310
经常说

34:05.310 --> 34:07.310
有一个变量A等于1

34:07.310 --> 34:08.310
然后呢

34:08.310 --> 34:10.310
有一个变量B等于A

34:10.310 --> 34:11.310
B和A是不是一个东西

34:11.310 --> 34:12.310
还不是

34:12.310 --> 34:13.310
他们是两个空间

34:13.310 --> 34:15.310
G这个空间里面是1

34:15.310 --> 34:17.310
然后B又是另外一个空间

34:17.310 --> 34:18.310
只不过把这个空间的

34:18.310 --> 34:20.310
词负质粘贴了过来

34:20.310 --> 34:21.310
对吧

34:21.310 --> 34:22.310
那么到时候

34:22.310 --> 34:23.310
我改B的时候

34:23.310 --> 34:24.310
跟A有没有关系

34:24.310 --> 34:25.310
没有关系

34:25.310 --> 34:26.310
改A的时候跟B也没有关系

34:26.310 --> 34:28.310
是这个意思

34:28.310 --> 34:29.310
是这个意思

34:29.310 --> 34:31.310
但是这里不一样

34:31.310 --> 34:32.310
怎么都不一样

34:32.310 --> 34:34.310
反正它叫做符号绑定

34:34.310 --> 34:35.310
就是说

34:35.310 --> 34:37.310
我导入的时候

34:37.310 --> 34:40.310
那个模块不是一个普通对象

34:40.310 --> 34:41.310
真不是一个普通对象

34:41.310 --> 34:43.310
这里更加不可能是解构了

34:43.310 --> 34:44.310
有些博客

34:44.310 --> 34:46.310
怎么往上贴着乱说

34:46.310 --> 34:47.310
这里是怎么解构

34:47.310 --> 34:48.310
完全不一样

34:48.310 --> 34:49.310
这里是

34:49.310 --> 34:50.310
这个符号

34:50.310 --> 34:52.310
不管你去重新怎么重新命名

34:52.310 --> 34:54.310
这个C和这边东西

34:54.310 --> 34:56.310
是一个内空空间

34:56.310 --> 34:57.310
根本就不是两个

34:57.310 --> 35:00.310
他们是同一个东西

35:00.310 --> 35:01.310
同学们

35:01.310 --> 35:03.310
以前学过C语言的话

35:03.310 --> 35:05.310
人家瞬间瞄动我的啥意思

35:05.310 --> 35:06.310
对吧

35:06.310 --> 35:07.310
这相当于什么

35:07.310 --> 35:09.310
相当于是引用地址传递

35:09.310 --> 35:11.310
当然你现在不懂C也没关系

35:11.310 --> 35:12.310
我就告诉你

35:12.310 --> 35:13.310
他们是同一个东西

35:13.310 --> 35:14.310
就是说

35:14.310 --> 35:15.310
就意味着啥呢

35:15.310 --> 35:17.310
就意味着做一块

35:19.310 --> 35:21.310
它是一块内空间

35:21.310 --> 35:24.310
这个C它没有额外的开拼内存空间

35:24.310 --> 35:26.310
根本就没有额外开拼内存空间

35:26.310 --> 35:28.310
它就是这个空间

35:28.310 --> 35:29.310
它不是说

35:29.310 --> 35:31.310
复制粘贴过来不是

35:31.310 --> 35:33.310
它就是这个空间

35:33.310 --> 35:35.310
所以你对抗存的任何改动

35:35.310 --> 35:37.310
都可以反映到C里边

35:38.310 --> 35:40.310
那么至于它为什么这样处理

35:40.310 --> 35:41.310
我觉得它里边

35:41.310 --> 35:43.310
虽然说我觉得

35:43.310 --> 35:45.310
这里会导致一些问题

35:45.310 --> 35:47.310
但是这里边是有一些智慧的

35:47.310 --> 35:49.310
有一些

35:49.310 --> 35:51.310
有些程序设计的角度

35:51.310 --> 35:52.310
有些考虑

35:52.310 --> 35:54.310
我这里就不展开了

35:55.310 --> 35:57.310
我知道它肯定有这么一些考虑

35:57.310 --> 35:58.310
就行了

35:59.310 --> 36:00.310
那么现在呢

36:00.310 --> 36:01.310
就意味着

36:01.310 --> 36:03.310
你这边如何去改变这个靠子

36:03.310 --> 36:04.310
它会反映到这

36:05.310 --> 36:06.310
懂了意思吧

36:06.310 --> 36:07.310
它会反映到这

36:08.310 --> 36:09.310
因此呢

36:09.310 --> 36:10.310
你在写这个模块的时候

36:10.310 --> 36:12.310
模块伏画榜立给你造成

36:12.310 --> 36:13.310
开发造成什么影响

36:13.310 --> 36:14.310
基本上没有什么影响

36:14.310 --> 36:16.310
因为平时你写了这么多代码

36:16.310 --> 36:17.310
对吧

36:17.310 --> 36:19.310
也不会去关注这个东西

36:19.310 --> 36:21.310
只是有的时候你会发现

36:21.310 --> 36:22.310
有一些符号

36:22.310 --> 36:24.310
就是导入进来的地方

36:24.310 --> 36:25.310
其他地方都正常了

36:25.310 --> 36:27.310
就是导入的时候

36:27.310 --> 36:28.310
这些名字

36:28.310 --> 36:29.310
就这些符号

36:29.310 --> 36:31.310
它来自于另外一个模块

36:31.310 --> 36:32.310
另外一个模块

36:32.310 --> 36:34.310
它是有能力把它进行改动的

36:35.310 --> 36:36.310
它是有能力改动的

36:38.310 --> 36:39.310
好,这就这一块就行了

36:39.310 --> 36:40.310
叫做符号绑定

36:40.310 --> 36:42.310
但是那如果说

36:42.310 --> 36:43.310
我如果说比方说

36:43.310 --> 36:44.310
这像这种情况

36:45.310 --> 36:46.310
那我就这样子写了

36:51.570 --> 36:52.570
这样子写

36:53.570 --> 36:55.570
两个零还是一个零一个一

36:56.570 --> 36:58.570
这样子写就是两个零了

36:58.570 --> 36:59.570
为什么呢

36:59.570 --> 37:02.570
因为它哪两个是一个东西

37:02.570 --> 37:04.570
我所想找到哪两个是一个东西

37:05.570 --> 37:07.570
只有在导入的时候

37:07.570 --> 37:09.570
这个符号跟这边的符号是一个东西

37:09.570 --> 37:10.570
就说什么了

37:10.570 --> 37:14.570
我就它和它是一块空间

37:14.570 --> 37:16.570
所以你改它的时候也就改它

37:16.570 --> 37:18.570
但是我把这个空间

37:18.570 --> 37:20.570
但是C跟他们是不是一个空间

37:20.570 --> 37:22.570
现在它就不是一个空间了

37:22.570 --> 37:23.570
换一个

37:23.570 --> 37:24.570
它就不是一个空间了

37:24.570 --> 37:26.570
所以当将来它改了

37:26.570 --> 37:27.570
跟它有关系吗

37:27.570 --> 37:28.570
没关系

37:28.570 --> 37:30.570
它又是独立一个空间

37:30.570 --> 37:31.570
那么这个空间只不过

37:31.570 --> 37:32.570
一开始的时候

37:32.570 --> 37:34.570
把它空间的纸复制粘贴过来

37:34.570 --> 37:35.570
是两块空间了

37:35.570 --> 37:36.570
现在

37:36.570 --> 37:38.570
现在它就没问题了

37:40.570 --> 37:42.570
就跑到这里进去了

37:42.570 --> 37:43.570
两个零了

37:43.570 --> 37:44.570
OK

37:44.570 --> 37:45.570
这就是关于符号绑定

37:45.570 --> 37:46.570
我要说的事情

37:46.570 --> 37:47.570
好

37:47.570 --> 37:48.570
这是ES module

37:48.570 --> 37:49.570
这个符号绑定

37:49.570 --> 37:50.570
你看一下了

37:50.570 --> 37:51.570
其实就是这个道理

37:51.570 --> 37:52.570
好

37:52.570 --> 37:53.570
最后来看一下面试题

37:53.570 --> 37:54.570
最重要的面试题

37:54.570 --> 37:55.570
就是两个模号

37:55.570 --> 37:56.570
它的区别站什么地方

37:56.570 --> 37:58.570
你把一关键词回答到就行了

37:58.570 --> 37:59.570
OK

37:59.570 --> 38:00.570
CommonJS社区

38:00.570 --> 38:02.570
ES module是官方

38:02.570 --> 38:04.570
CommonJS使用的是API

38:04.570 --> 38:06.570
就是用函数的方式来实现模块化

38:06.570 --> 38:08.570
ES module是使用新语法

38:08.570 --> 38:10.570
来实现模块化的

38:10.570 --> 38:12.570
CommonJS只有在漏的环境里边支持

38:12.570 --> 38:13.570
ESM

38:13.570 --> 38:14.570
各种环境都支持

38:14.570 --> 38:16.570
CommonJS是动态的一代

38:16.570 --> 38:17.570
同步执行

38:17.570 --> 38:19.570
ES module是

38:19.570 --> 38:20.570
既支持动态

38:20.570 --> 38:21.570
也支持静态

38:21.570 --> 38:23.570
它的动态一代是异步执行的

38:23.570 --> 38:24.570
而CommonJS

38:24.570 --> 38:26.570
ES module有符号绑定

38:26.570 --> 38:27.570
CommonJS呢

38:27.570 --> 38:28.570
没有

38:28.570 --> 38:30.570
CommonJS是没有符号绑定的

38:30.570 --> 38:32.570
只有普通还是调用

38:32.570 --> 38:34.570
然后Export

38:34.570 --> 38:36.570
Export Default是什么区别

38:36.570 --> 38:38.570
这个你们看一下就行了

38:38.570 --> 38:40.570
下面的模块导出什么样的结果

38:40.570 --> 38:41.570
讲过了对吧

38:41.570 --> 38:42.570
CommonJS

38:42.570 --> 38:43.570
那么下面代码输出什么样的结果

38:43.570 --> 38:45.570
这时候就考虑是符号绑定

38:45.570 --> 38:46.570
这个符号绑定

38:46.570 --> 38:48.570
就跟刚才我写的是一样的

38:48.570 --> 38:49.570
只不过这里

38:49.570 --> 38:50.570
用了这种模式

38:50.570 --> 38:51.570
用了这种模式

38:51.570 --> 38:53.570
这种模式跟这种模式是一样的

38:54.570 --> 38:55.570
OK

38:55.570 --> 38:57.570
这个东西没有什么好说的

38:57.570 --> 38:58.570
那看吧看一下吧

38:58.570 --> 38:59.570
导入

38:59.570 --> 39:00.570
就来吧

39:00.570 --> 39:01.570
看一下

39:07.270 --> 39:08.270
它是想绕一下

39:08.270 --> 39:09.270
你绕不到的

39:09.270 --> 39:10.270
你知道吧

39:10.270 --> 39:12.270
关键点理解性主要绕不到的

39:12.270 --> 39:14.270
它这个模块的名字叫Counter

39:14.270 --> 39:20.620
好

39:20.620 --> 39:21.620
这里

39:21.620 --> 39:22.620
越南流浪型环境里面

39:22.620 --> 39:23.620
远色环境里面

39:23.620 --> 39:24.620
要加上后隧

39:24.620 --> 39:27.820
好

39:27.820 --> 39:28.820
那么现在我们来看一下

39:28.820 --> 39:29.820
这里

39:29.820 --> 39:30.820
这里这个cault

39:30.820 --> 39:31.820
导出一个cault

39:31.820 --> 39:33.820
导出一个increase

39:33.820 --> 39:34.820
那么这两个

39:34.820 --> 39:35.820
我就用那个

39:35.820 --> 39:37.820
同一个颜色的线来标注了

39:38.820 --> 39:39.820
换一个颜色

39:39.820 --> 39:40.820
红色

39:40.820 --> 39:43.820
这个东西跟我们这道题没关系

39:43.820 --> 39:45.820
这个东西跟这个东西是一个东西

39:46.820 --> 39:47.820
就是同一块内存空间

39:47.820 --> 39:49.820
它都不是两块内存空间复制

39:49.820 --> 39:51.820
是同一块内存空间

39:51.820 --> 39:52.820
好

39:52.820 --> 39:53.820
然后呢

39:53.820 --> 39:55.820
它又导入了一次counter

39:55.820 --> 39:56.820
又导入了一次

39:56.820 --> 39:57.820
那么这一次导入了

39:57.820 --> 39:58.820
是导入所有的吧

39:58.820 --> 39:59.820
整个模块

39:59.820 --> 40:01.820
那么这个counter里面

40:01.820 --> 40:03.820
有一个属性叫counter

40:03.820 --> 40:04.820
对吧

40:04.820 --> 40:05.820
这个没问题吧

40:05.820 --> 40:07.820
这边是导出了一个对象

40:07.820 --> 40:11.650
这边是导出了一个对象

40:11.650 --> 40:13.650
这个对象里面

40:14.650 --> 40:16.650
有一个cault

40:17.650 --> 40:19.650
等于1

40:19.650 --> 40:21.650
还有一个increase

40:21.650 --> 40:22.650
一个函数

40:23.650 --> 40:24.650
那么现在呢

40:24.650 --> 40:25.650
我们这里画一下

40:25.650 --> 40:27.650
这边的counter

40:27.650 --> 40:29.650
导入的counter

40:29.650 --> 40:33.410
这是导出的

40:33.410 --> 40:35.410
这是导入的

40:35.410 --> 40:37.410
导入了一个counter

40:37.410 --> 40:42.170
有一个counter

40:42.170 --> 40:44.170
counter也是导入的对吧

40:44.170 --> 40:45.170
counter也是一个对象

40:45.170 --> 40:46.170
那么这个counter对象呢

40:46.170 --> 40:48.170
就是这个对象

40:48.170 --> 40:53.400
就是这个对象

40:53.400 --> 40:54.400
我自己画一下

40:54.400 --> 40:55.400
画个箭头就行了

40:55.400 --> 40:57.400
这个counter就是这个对象

40:57.400 --> 40:59.900
好

40:59.900 --> 41:00.900
接下来我们来画一个线

41:00.900 --> 41:01.900
再来一次

41:01.900 --> 41:05.470
导入的时候有一个counter

41:05.470 --> 41:06.470
counter

41:06.470 --> 41:07.470
跟这个导出的counter

41:07.470 --> 41:08.470
是一个东西

41:08.470 --> 41:10.470
符号绑立

41:10.470 --> 41:11.470
好

41:11.470 --> 41:12.470
接下来

41:12.470 --> 41:14.470
我们又用解构的方式

41:14.470 --> 41:16.470
从这个counter里边

41:16.470 --> 41:18.470
解构出一个counter

41:18.470 --> 41:19.470
把它复制为一个变量c

41:19.470 --> 41:20.470
因为这里重明了

41:20.470 --> 41:22.470
复制个变量c

41:22.470 --> 41:23.470
那么这样子呢

41:23.470 --> 41:25.470
又多了一个c出来了

41:25.470 --> 41:27.470
那么这个c就是另外一个空间了

41:28.470 --> 41:29.470
为什么

41:29.470 --> 41:30.470
这是一个普通的解构

41:30.470 --> 41:31.470
它不是在导入的时候绑定的

41:31.470 --> 41:32.470
只有导入的时候

41:32.470 --> 41:33.470
才能符号绑定

41:33.470 --> 41:34.470
那么剩下的东西

41:34.470 --> 41:35.470
全是正常的

41:35.470 --> 41:36.470
那么就是

41:36.470 --> 41:37.470
一个另外一个空间

41:37.470 --> 41:38.470
那么来自于什么

41:38.470 --> 41:40.470
来自于这个counter对象

41:40.470 --> 41:41.470
里面一个属性

41:41.470 --> 41:43.470
1把这个1的复制粘贴过来

41:44.470 --> 41:45.470
变成这样子了

41:45.470 --> 41:46.470
好 现在我们来继续

41:47.470 --> 41:49.470
接下来我们调用increase

41:49.470 --> 41:50.470
调用increase是counter加

41:50.470 --> 41:51.470
加的是谁

41:51.470 --> 41:52.470
加的是他

41:52.470 --> 41:53.470
变成了2了

41:53.470 --> 41:54.470
那你想一想

41:54.470 --> 41:55.470
它变成了2

41:55.470 --> 41:56.470
导入的counter

41:56.470 --> 41:57.470
跟它是一个东西

41:57.470 --> 41:58.470
是不是变成了2

41:58.470 --> 41:59.470
这个没问题吧

41:59.470 --> 42:00.470
它们是一个东西

42:01.470 --> 42:02.470
它也跟着变成了2

42:02.470 --> 42:04.470
那么这个c肯定不一样的

42:05.470 --> 42:06.470
那么于是

42:06.470 --> 42:07.470
这里输出解

42:07.470 --> 42:08.470
输出2

42:09.470 --> 42:11.470
好 再输出counter的counter

42:11.470 --> 42:12.470
counter是这个对象

42:12.470 --> 42:14.470
它里面一个属性counter

42:14.470 --> 42:15.470
那么这里也输出2

42:16.470 --> 42:17.470
然后再输出c

42:17.470 --> 42:18.470
c是啥

42:18.470 --> 42:19.470
c是1

42:19.470 --> 42:21.470
说得到的结果就是2 2 1

42:23.470 --> 42:24.470
2 2 1

42:24.470 --> 42:28.320
看一下

42:28.320 --> 42:29.320
是不是2 2 1

42:29.320 --> 42:30.320
是不是2 2 1

42:30.320 --> 42:31.320
没问题吧

42:31.320 --> 42:32.320
好 这就是

42:32.320 --> 42:34.320
咱们这个common.js和

42:34.320 --> 42:35.320
esmodule

42:35.320 --> 42:36.320
最主要的面子

42:36.320 --> 42:37.320
也就是它们区别

42:37.320 --> 42:39.320
然后呢 就是一些代码题

42:39.320 --> 42:40.320
esmodule

42:40.320 --> 42:41.320
counter是符号绑定

42:41.320 --> 42:42.320
common.js

42:42.320 --> 42:43.320
counter就是

42:43.320 --> 42:44.320
exports

42:44.320 --> 42:45.320
az

42:45.320 --> 42:46.320
这些东西

42:46.320 --> 42:47.320
好了 这就是这几个问题

42:47.320 --> 42:48.320
说有内容

