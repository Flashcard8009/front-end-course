WEBVTT

00:00.050 --> 00:02.050
咱们的露的第二天

00:02.050 --> 00:04.050
昨天呢其实也没讲啥东西

00:04.050 --> 00:06.050
昨天呢就是把露的安装了

00:06.050 --> 00:08.050
然后讲了一些基本概念

00:08.050 --> 00:10.050
在露的里边咋回事了啊怎么写代码了

00:10.050 --> 00:12.050
其实具体呢昨天也没有什么作业

00:12.050 --> 00:14.050
也没有什么练习

00:14.050 --> 00:16.050
但是从今天开始啊

00:16.050 --> 00:18.050
后边有几天那么这几天呢内容是连续的

00:18.050 --> 00:20.050
大家认真听啊

00:20.050 --> 00:22.050
如果前一天没有听懂的话

00:22.050 --> 00:24.050
后一天你就听不懂了

00:24.050 --> 00:26.050
因为我们的

00:26.050 --> 00:28.050
做的练习做的效果呢

00:28.050 --> 00:30.050
都是连续的

00:30.050 --> 00:32.050
不过大家也不用太过有担心啊

00:32.050 --> 00:34.050
因为这几天的东西呢都是比较简单的

00:34.050 --> 00:36.050
我觉得这几天的东西是不存在

00:36.050 --> 00:38.050
说学不懂

00:38.050 --> 00:40.050
做不出来的

00:40.050 --> 00:42.050
一是咱们这个视频呢有路播

00:42.050 --> 00:44.050
第二呢元代码

00:44.050 --> 00:46.050
科兰上的元代码呢是全部给人发下来的

00:46.050 --> 00:48.050
如果说你再次说你写不出来的话

00:48.050 --> 00:50.050
那一定是你自己的问题了啊

00:50.050 --> 00:52.050
因为你写不出来的话

00:52.050 --> 00:54.050
你可以看一下老师的视频

00:54.050 --> 00:56.050
也可以看一下我的元代码

00:56.050 --> 00:58.050
相关的相见

00:58.050 --> 01:00.050
因为这里边也没有什么太多的新知识

01:00.050 --> 01:02.050
没有什么太多的

01:02.050 --> 01:04.050
前置知识

01:04.050 --> 01:06.050
所以说大家只要你用心的话

01:06.050 --> 01:08.050
一定是愉静的学懂的

01:08.050 --> 01:10.050
今天咱们呢

01:10.050 --> 01:12.050
讲的是MangoDB

01:12.050 --> 01:14.050
说完了就是数据持久化

01:14.050 --> 01:16.050
就是数据库

01:16.050 --> 01:18.050
你们有些同学呢应该是听说过数据库

01:18.050 --> 01:20.050
数据库属于一种后端技术

01:20.050 --> 01:22.050
在note接识里边呢也可以

01:22.050 --> 01:24.050
操作数据库的

01:24.050 --> 01:26.050
后边你们听课的时候呢

01:26.050 --> 01:28.050
再去下载

01:28.050 --> 01:30.050
所以说你们在听课之前啊

01:30.050 --> 01:32.050
就是我讲课之前呢你可以先去下载

01:32.050 --> 01:34.050
下载啥呢我把这个链接给大家发下来

01:34.050 --> 01:36.050
下载两个东西一个是MangoDB

01:36.050 --> 01:39.550
一个是这个玩意

01:39.550 --> 01:41.550
点一个是

01:41.550 --> 01:43.550
Robo

01:43.550 --> 01:45.550
Mango

01:45.550 --> 01:47.550
就这两个玩意这两个链接

01:47.550 --> 01:49.550
进去啊点进去过后呢

01:49.550 --> 01:51.550
首先是MangoDB在哪里下载啊

01:51.550 --> 01:53.550
给大家说一下

01:53.550 --> 01:55.550
在这

01:57.550 --> 01:59.550
这里一个Community Server

01:59.550 --> 02:01.550
这个MangoDB呢以前

02:01.550 --> 02:03.550
它是开源的免费的

02:03.550 --> 02:05.550
但是现在呢开始做商用了

02:05.550 --> 02:07.550
所以一看到它变成

02:07.550 --> 02:09.550
做成商用过后呢它都官方网站

02:09.550 --> 02:11.550
文档啊这些都变化很大

02:11.550 --> 02:13.550
写的费比以前要好多了

02:13.550 --> 02:15.550
我是这种感觉

02:15.550 --> 02:17.550
凡是那种商用的东西呢

02:17.550 --> 02:19.550
它做的网站和文档做的比较好

02:19.550 --> 02:21.550
但是它还是有免费版

02:21.550 --> 02:23.550
跟了就是Community Server

02:23.550 --> 02:25.550
点进去啊

02:25.550 --> 02:27.550
然后下载的话

02:27.550 --> 02:29.550
这边选择里的操作系统

02:29.550 --> 02:31.550
你们都是Windows的啊Windows X64

02:31.550 --> 02:33.550
选中过后呢这边有一个MSI

02:33.550 --> 02:35.550
下这个文件把它下载下来

02:35.550 --> 02:37.550
当然你也可以把这个地址呢

02:37.550 --> 02:39.550
下载地址复制一下

02:39.550 --> 02:41.550
用讯内下载也可以

02:41.550 --> 02:43.550
讯内下载快一点啊这种下法

02:43.550 --> 02:45.550
才能比较慢一点

02:45.550 --> 02:47.550
把地址复制一下在讯内里边进行下载

02:47.550 --> 02:49.550
好这是第一个啊

02:49.550 --> 02:51.550
再慢慢就行了啊

02:51.550 --> 02:53.550
当前Prince Release就行了

02:53.550 --> 02:55.550
好第二个呢就是这个东西

02:55.550 --> 02:57.550
这个玩意呢我们一会会说啊

02:57.550 --> 02:59.550
它什么用它什么用先把下载下来

02:59.550 --> 03:01.550
这里点Download

03:01.550 --> 03:03.550
然后选这边啊Download

03:03.550 --> 03:05.550
Robo 3T

03:05.550 --> 03:07.550
点这个啊进去下载就玩笑了啊

03:07.550 --> 03:09.550
这两个先下载的

03:09.550 --> 03:11.550
应该要下载一会

03:11.550 --> 03:13.550
其实也下载不了多久

03:13.550 --> 03:15.550
然后呢我们再进入今天的学习

03:15.550 --> 03:17.550
安装的话我一会说吧

03:17.550 --> 03:19.550
就下一个下一个下一个

03:19.550 --> 03:21.550
好第一个就是我们这里呢先说个概念啊

03:21.550 --> 03:23.550
叫数据库

03:23.550 --> 03:25.550
为什么会出现这个概念呢

03:25.550 --> 03:27.550
嗯是他的作用呢

03:27.550 --> 03:29.550
是要做数据的持久化

03:29.550 --> 03:31.550
啥叫数据持久化

03:31.550 --> 03:33.550
我们之前写的任何程序

03:33.550 --> 03:35.550
咱们的数据在哪呢

03:35.550 --> 03:37.550
在边疆里边对吧

03:37.550 --> 03:39.550
边疆在哪呢在内存里边

03:39.550 --> 03:41.550
所以就会导致一个什么问题呢

03:41.550 --> 03:43.550
只要我们一刷新页面

03:43.550 --> 03:45.550
或者是我们一重新运行程序

03:45.550 --> 03:47.550
之前的程序一停止

03:47.550 --> 03:48.550
那么之前的边

03:48.550 --> 03:50.550
之前内存里边的所谓东西是不是就消失了

03:50.550 --> 03:52.550
或者是一重启计算机

03:52.550 --> 03:54.550
是不是所有的东西就消失了

03:54.550 --> 03:56.550
而我们有些数据呢是希望

03:56.550 --> 03:58.550
把它永久的存出下来

03:58.550 --> 04:00.550
所以他就不能在内存里边

04:00.550 --> 04:02.550
应该在哪呢应该在硬盘

04:02.550 --> 04:04.550
在硬盘里边的数据是什么呢

04:04.550 --> 04:06.550
表现形式呢就是一个文件

04:06.550 --> 04:08.550
文件了大家见过吧

04:08.550 --> 04:10.550
文件肯定是见过的

04:10.550 --> 04:12.550
文件其实就是存在硬盘里边的

04:12.550 --> 04:14.550
磁盘里边

04:14.550 --> 04:16.550
而数据库呢

04:16.550 --> 04:18.550
相当于就是一个特殊的文件

04:18.550 --> 04:20.550
一系列的特殊文件

04:20.550 --> 04:22.550
它帮你来管理文件里边的数据

04:22.550 --> 04:24.550
就相当于这么个意思

04:24.550 --> 04:26.550
它是一种的数据持久化的技术

04:26.550 --> 04:28.550
我先了解一下它的概念

04:28.550 --> 04:30.550
咱们平时用的数据库里边

04:30.550 --> 04:31.550
刚才也同学提到了

04:31.550 --> 04:34.550
MySQL 看了刚才说的同学比较多

04:34.550 --> 04:37.550
MySQL在我们后期的课程里边有讲

04:37.550 --> 04:39.550
为什么咱们五日的集训营

04:39.550 --> 04:41.550
不去讲这个MySQL呢

04:41.550 --> 04:43.550
是因为MySQL的学习曲线

04:43.550 --> 04:46.550
我们今天讲的数据库呢要长

04:46.550 --> 04:48.550
我记得当时我讲MySQL

04:48.550 --> 04:50.550
用了多少时间呢

04:50.550 --> 04:52.550
用了接信20节课

04:52.550 --> 04:54.550
讲MySQL 以及在Note接识里边

04:54.550 --> 04:56.550
它的使用用了20节课

04:56.550 --> 04:58.550
所以在五日集训营里边呢

04:58.550 --> 05:00.550
不太适合啊

05:00.550 --> 05:02.550
总之呢我们无论是什么样的数据库吧

05:02.550 --> 05:04.550
它的作用呢只有一个

05:04.550 --> 05:06.550
就持久化数据

05:06.550 --> 05:08.550
只是它们持久化数据的方式呢

05:08.550 --> 05:09.550
有些区别

05:09.550 --> 05:11.550
我们从功能上把它分为三类

05:11.550 --> 05:13.550
那是关系型数据库

05:13.550 --> 05:15.550
长期来是非常流行的

05:15.550 --> 05:17.550
就是MySQL server Oracle

05:17.550 --> 05:20.550
像这些数据库呢都是属于关系型数据库

05:20.550 --> 05:23.550
另外一种呢叫非关系型数据库

05:23.550 --> 05:25.550
就是我们今天要讲的MongoDB

05:25.550 --> 05:27.550
是最近几年慢慢流行起来的

05:27.550 --> 05:29.550
MongoDB 以及Redis

05:29.550 --> 05:31.550
这些都是非关系型数据库

05:31.550 --> 05:34.550
还有一种呢就是非常非常少见的

05:34.550 --> 05:36.550
面向对象数据库了

05:36.550 --> 05:37.550
大家接触的可能比较少

05:37.550 --> 05:40.550
一般来说一种超大型的系统

05:40.550 --> 05:41.550
可能会用到

05:41.550 --> 05:43.550
而且面向对象数据库呢一般来说

05:43.550 --> 05:44.550
是收费的

05:44.550 --> 05:46.550
我们一般接触的比较少一点

05:46.550 --> 05:48.550
我们今天晚上讲的呢

05:48.550 --> 05:51.550
是非关系型数据库的MongoDB

05:51.550 --> 05:53.550
那么非关系型数据库

05:53.550 --> 05:54.550
还有什么样的特点呢

05:54.550 --> 05:56.550
这些特点大家了解

05:56.550 --> 05:57.550
第一个特点呢

05:57.550 --> 05:59.550
就是它的大量的数据呢

05:59.550 --> 06:01.550
纯速数度比较快

06:01.550 --> 06:03.550
速度呢从速度上来说的话

06:03.550 --> 06:06.550
应该是关系型数据库的好几倍

06:06.550 --> 06:07.550
甚至几十倍

06:07.550 --> 06:08.550
它的存取速度

06:09.550 --> 06:11.550
往里边存数据

06:11.550 --> 06:12.550
从里边取数据

06:12.550 --> 06:14.550
它的速度是非常快的

06:14.550 --> 06:16.550
效率是非常高的

06:16.550 --> 06:18.550
另外一个呢就是它的使用比较简单

06:18.550 --> 06:20.550
学习成本比较低

06:20.550 --> 06:22.550
我们今天晚上学了之后呢

06:22.550 --> 06:24.550
就知道理会发现一个半小时

06:24.550 --> 06:26.550
基本上呢你就把非关系型数据库的MongoDB

06:26.550 --> 06:27.550
学的差不多了

06:27.550 --> 06:29.550
它学习成本非常低

06:29.550 --> 06:30.550
但是还有它的缺陷

06:30.550 --> 06:31.550
缺陷是什么呢

06:31.550 --> 06:34.550
就是它难以表达复杂的数据关系

06:34.550 --> 06:36.550
就是我有很多数据

06:36.550 --> 06:38.550
新闻啊新闻内别还有评论

06:38.550 --> 06:40.550
这些数据之间是不是有关系的

06:40.550 --> 06:42.550
一个内别里边有多个新闻

06:42.550 --> 06:44.550
一个一篇新闻下边有多个评论

06:44.550 --> 06:46.550
一个评论又属于一个用户

06:46.550 --> 06:47.550
对吧

06:47.550 --> 06:48.550
那么像这些东西呢

06:48.550 --> 06:50.550
都是有关系的数据

06:50.550 --> 06:52.550
如果说关系比较复杂的数据呢

06:52.550 --> 06:54.550
用非关系型数据库呢

06:54.550 --> 06:55.550
就不是那么适合了

06:55.550 --> 06:57.550
所以它有它的缺陷

06:57.550 --> 06:59.550
这些东西呢不是说

06:59.550 --> 07:01.550
一个出来过后就一定要替代另一个

07:01.550 --> 07:03.550
咱们技术领域不能这样子看问题

07:03.550 --> 07:05.550
它们各自呢有各自的优势

07:05.550 --> 07:07.550
各自的用处

07:07.550 --> 07:09.550
我们这里学习的非关系型数据库呢

07:09.550 --> 07:10.550
其实它里边呢

07:10.550 --> 07:13.550
还是分为了很多的指代别

07:13.550 --> 07:15.550
比方说像怎么坚持对型啊

07:15.550 --> 07:17.550
像什么文档型啊

07:17.550 --> 07:18.550
分为很多的指代别

07:18.550 --> 07:20.550
我们今天学习的mongoDB呢

07:20.550 --> 07:23.550
是属于非关系型数据库里边的

07:23.550 --> 07:25.550
文档型数据库

07:25.550 --> 07:27.550
它是文档型的

07:27.550 --> 07:29.550
那么文档型是一个什么样的样子呢

07:29.550 --> 07:31.550
我们一会儿就看到了啊

07:31.550 --> 07:34.550
我们这里简单的介绍一下数据库的概念

07:40.170 --> 07:42.170
优化的话

07:42.170 --> 07:44.170
mongoDB我们今天这几天不设计啊

07:44.170 --> 07:46.170
如果说要优化的话

07:46.170 --> 07:48.170
主要的手段呢去做一些索应

07:48.170 --> 07:50.170
我们这里呢看一下

07:50.170 --> 07:51.170
mongoDB的安装

07:51.170 --> 07:53.170
刚才大家应该下载下来了啊

07:53.170 --> 07:55.170
下载下来了过后呢就是两个安装包

07:55.170 --> 07:56.170
一个是mongoDB的安装包

07:56.170 --> 07:57.170
一个是robo3t的安装包

07:57.170 --> 07:59.170
我说一下啊怎么安装

07:59.170 --> 08:01.170
mongoDB呢是非常简单的安装

08:01.170 --> 08:03.170
双击过后呢直接安装

08:03.170 --> 08:04.170
下一步

08:04.170 --> 08:07.170
我这里已经安装过了啊

08:07.170 --> 08:09.170
我点千几看一下

08:11.170 --> 08:13.170
我已经安装过了

08:13.170 --> 08:15.170
大家安装的时候这样子啊

08:15.170 --> 08:16.170
大家安装的时候

08:16.170 --> 08:18.170
你安装那个mongoDB的时候呢

08:18.170 --> 08:20.170
点下一步啊

08:20.170 --> 08:22.170
到了就是一直往下

08:22.170 --> 08:24.170
点下一步啊一直往下点下一步

08:24.170 --> 08:26.170
到了这一步的时候停留一下

08:26.170 --> 08:28.170
把这个勾呢给它去掉

08:28.170 --> 08:30.170
这是mongoDB compass

08:30.170 --> 08:31.170
把这个勾给它去掉

08:31.170 --> 08:32.170
去掉有什么意义呢

08:32.170 --> 08:35.170
这个东西是安装的是mongoDB的一个UI管理器

08:35.170 --> 08:37.170
一个界面管理器啊可视化管理器

08:37.170 --> 08:39.170
这个玩意呢因为你不去掉的话

08:39.170 --> 08:41.170
它从那个官方下载很慢很慢的

08:41.170 --> 08:43.170
我们一般把它去掉

08:43.170 --> 08:45.170
因为我们一会呢会安装这个东西

08:45.170 --> 08:46.170
来作为它的可视化管理

08:46.170 --> 08:48.170
所以说你按照我的说的做

08:48.170 --> 08:49.170
把这个勾该去掉

08:49.170 --> 08:51.170
然后点下一步安装就完事了

08:51.170 --> 08:52.170
这第一个

08:52.170 --> 08:54.170
mongoDB安装好

08:54.170 --> 08:55.170
安装好

08:55.170 --> 08:56.170
mongoDB之后呢

08:56.170 --> 08:57.170
那么你的计算机上呢

08:57.170 --> 08:59.170
就已经有数据库了

08:59.170 --> 09:01.170
数据库就已经存在了

09:01.170 --> 09:02.170
只不过呢

09:02.170 --> 09:04.170
现在用起来的比较麻烦而已

09:04.170 --> 09:05.170
在哪里用呢

09:05.170 --> 09:06.170
你的mongoDB要在这里用啊

09:06.170 --> 09:08.170
你安装好了过后呢

09:08.170 --> 09:09.170
应该在你的

09:09.170 --> 09:10.170
因为这些东西没有改的话

09:10.170 --> 09:12.170
应该在你的C盘

09:12.170 --> 09:15.170
C盘下边的program files

09:15.170 --> 09:17.170
然后呢在这啊

09:17.170 --> 09:19.170
mongoDB server

09:19.170 --> 09:21.170
这里4.2啊应该在这

09:21.170 --> 09:22.170
4.2

09:22.170 --> 09:24.170
然后呢这里边有个并

09:24.170 --> 09:26.170
就是里边有一些可执行程序

09:26.170 --> 09:28.170
这里有一个mongo.exe

09:28.170 --> 09:30.170
你看在这个路径下边

09:30.170 --> 09:31.170
你们也可以看一下

09:31.170 --> 09:32.170
也可以不用看啊

09:32.170 --> 09:33.170
跟我们一会儿写在按码里

09:33.170 --> 09:34.170
没有什么关系

09:34.170 --> 09:35.170
我们双鱼打开

09:35.170 --> 09:37.170
在这里就可以写在按码了

09:37.170 --> 09:39.170
表示我们这里可以写个命令

09:39.170 --> 09:40.170
cho dbs

09:40.170 --> 09:41.170
看一下有哪些数据库

09:41.170 --> 09:43.170
mongoDB安装好了之后呢

09:43.170 --> 09:44.170
他有三个数据库

09:44.170 --> 09:45.170
admin config

09:45.170 --> 09:46.170
local

09:46.170 --> 09:47.170
不要去动他啊

09:47.170 --> 09:48.170
OK

09:48.170 --> 09:49.170
那么这里就安装好了啊

09:49.170 --> 09:50.170
关了就行了

09:50.170 --> 09:51.170
好另外一个呢

09:51.170 --> 09:52.170
就是

09:52.170 --> 09:53.170
我们目前呢

09:53.170 --> 09:56.170
其实已经可以管理数据库了

09:56.170 --> 09:57.170
这些东西跟漏的没有关系啊

09:57.170 --> 09:59.170
目前还跟漏的没有关系

09:59.170 --> 10:00.170
只不过呢

10:00.170 --> 10:01.170
我要用命令去管理

10:01.170 --> 10:02.170
就是我们刚才要进那个界面

10:02.170 --> 10:03.170
去用命令去管理

10:03.170 --> 10:04.170
比较麻烦

10:04.170 --> 10:05.170
所以说一般来说的话

10:05.170 --> 10:07.170
我们安装好一个数据库之后呢

10:07.170 --> 10:09.170
会安装一些可视化的

10:09.170 --> 10:11.170
就在窗口里面操作的一些管理工具

10:11.170 --> 10:12.170
那么这个robo3t呢

10:12.170 --> 10:14.170
就是他的管理工具

10:14.170 --> 10:15.170
我们这里双击他安装

10:15.170 --> 10:16.170
这个安装也很简单啊

10:16.170 --> 10:17.170
就是下一步

10:17.170 --> 10:18.170
下一步

10:18.170 --> 10:19.170
下一步就没了

10:19.170 --> 10:20.170
下一步

10:20.170 --> 10:21.170
下一步

10:21.170 --> 10:22.170
直接安装

10:22.170 --> 10:23.170
就没了

10:23.170 --> 10:30.100
意思是安装很简单啊

10:30.100 --> 10:32.100
安装好了之后

10:32.100 --> 10:33.100
安装好了之后呢

10:33.100 --> 10:35.100
我们需要去打开这个robo3t

10:35.100 --> 10:36.100
怎么打开呢

10:36.100 --> 10:37.100
你们安装好了之后呢

10:37.100 --> 10:40.100
桌面上应该有一个快捷方式

10:40.100 --> 10:43.100
我呢把他放到这儿了

10:43.100 --> 10:44.100
在这儿

10:44.100 --> 10:45.100
robo3t

10:45.100 --> 10:49.380
点击过后打开

10:49.380 --> 10:50.380
打开的时候呢

10:50.380 --> 10:52.380
你们这边应该是空的啊

10:52.380 --> 10:54.380
你们这边应该是空的

10:54.380 --> 10:55.380
一开始进去的时候呢

10:55.380 --> 10:56.380
会出现这么一个

10:56.380 --> 10:59.380
让你连接连接数据库

10:59.380 --> 11:00.380
数据库呢

11:00.380 --> 11:01.380
实际上是他在温斗室

11:01.380 --> 11:02.380
安装好了之后呢

11:02.380 --> 11:04.380
实际上是温斗室里面一个服务

11:04.380 --> 11:06.380
一个长期运行的一个服务

11:06.380 --> 11:07.380
所以说呢

11:07.380 --> 11:08.380
他在那里去连接那个服务

11:08.380 --> 11:09.380
这个工具

11:09.380 --> 11:10.380
他怎么来连接啊

11:10.380 --> 11:11.380
这里点击create

11:11.380 --> 11:12.380
创建一个连接

11:12.380 --> 11:14.380
好那些东西都不用动

11:14.380 --> 11:15.380
基本上都不用动

11:15.380 --> 11:17.380
我们直接点set保存

11:17.380 --> 11:18.380
那就创建了一个连接

11:18.380 --> 11:19.380
然后这里我们点这个

11:19.380 --> 11:20.380
连接

11:20.380 --> 11:21.380
好连接到过后呢

11:21.380 --> 11:22.380
你就可以看到

11:22.380 --> 11:23.380
咱们这里呢

11:23.380 --> 11:24.380
就已经有了

11:24.380 --> 11:25.380
有了三个数据库了

11:25.380 --> 11:28.380
Arduino local config

11:28.380 --> 11:30.380
所以已经有三个数据库了

11:30.380 --> 11:31.380
对不对就可以打开了

11:31.380 --> 11:32.380
我们还可以在这里

11:32.380 --> 11:33.380
又建新建一个数据库

11:33.380 --> 11:34.380
不过呢

11:34.380 --> 11:35.380
我们一般不会这样去做

11:35.380 --> 11:36.380
我们一般会用程序去控制

11:36.380 --> 11:37.380
好这里呢

11:37.380 --> 11:39.380
我们可以看到这个界面就ok了

11:39.380 --> 11:40.380
说明这些呢

11:40.380 --> 11:41.380
一切ok啊

11:41.380 --> 11:42.380
已经安装好了

11:42.380 --> 11:44.380
好接下来我们再来看啊

11:44.380 --> 11:46.380
我输标了

11:46.380 --> 11:50.900
好接下来继续

11:50.900 --> 11:51.900
接下来我们来认识一下

11:51.900 --> 11:54.900
在mongo db里面的一些核心概念

11:54.900 --> 11:55.900
第二个概念

11:55.900 --> 11:57.900
他的核心概念其实比较少

11:57.900 --> 11:58.900
也没有那么多

11:58.900 --> 11:59.900
一个说

11:59.900 --> 12:01.900
首先是db数据库

12:01.900 --> 12:03.900
数据库是啥呢

12:03.900 --> 12:04.900
数据库呢

12:04.900 --> 12:06.900
你可以把它想象成一个

12:06.900 --> 12:07.900
装数据的仓库

12:07.900 --> 12:09.900
你一个应用程序呢

12:09.900 --> 12:10.900
建立一个数据库

12:10.900 --> 12:12.900
只要一些大型的应用呢

12:12.900 --> 12:13.900
可能还会建立很多个数据库啊

12:13.900 --> 12:14.900
不过呢

12:14.900 --> 12:15.900
我们这里的应用呢

12:15.900 --> 12:16.900
你可以想象

12:16.900 --> 12:17.900
一个应用呢

12:17.900 --> 12:18.900
大部分时候呢

12:18.900 --> 12:19.900
就建立一个数据库

12:19.900 --> 12:20.900
一个数据库就够了

12:20.900 --> 12:21.900
就是一个数据仓库

12:21.900 --> 12:23.900
来存放我们应用里面的各种数据

12:23.900 --> 12:25.900
凡是你希望把它持久化

12:25.900 --> 12:27.900
永久的保存下来的数据呢

12:27.900 --> 12:29.900
你就可以建立一个数据库

12:29.900 --> 12:30.900
好

12:30.900 --> 12:31.900
那么接下来的第二个概念

12:31.900 --> 12:32.900
什么意思呢

12:32.900 --> 12:33.900
它表示集合

12:33.900 --> 12:34.900
它有点类似于什么呢

12:34.900 --> 12:36.900
类似于GS里面的数据

12:36.900 --> 12:37.900
就是我有个数据仓库

12:37.900 --> 12:38.900
这个仓库里面

12:38.900 --> 12:39.900
可以有很多的集合

12:39.900 --> 12:41.900
可以存放各种一样的数据

12:41.900 --> 12:43.900
数据里面数据可以放东西

12:43.900 --> 12:44.900
对不对

12:44.900 --> 12:45.900
好

12:45.900 --> 12:46.900
那么下一个概念叫 document

12:46.900 --> 12:48.900
表示的是文大

12:48.900 --> 12:51.900
那么它有点类似于GS里面的对象

12:51.900 --> 12:52.900
好

12:52.900 --> 12:53.900
那么这三个东西

12:53.900 --> 12:54.900
他们的关系是什么呢

12:54.900 --> 12:55.900
给他看一下

12:55.900 --> 12:56.900
下面一张图

12:56.900 --> 12:57.900
给他看一下他们的关系

12:57.900 --> 12:58.900
这就是我们的mongo db

12:58.900 --> 12:59.900
mongo db

12:59.900 --> 13:01.900
可以创建很多个数据库

13:01.900 --> 13:03.900
比方说我们一个学校数据库

13:03.900 --> 13:05.900
我们有个电影数据库

13:05.900 --> 13:07.900
那么这个东西就是 db

13:07.900 --> 13:08.900
db

13:08.900 --> 13:09.900
我们的数据仓库

13:09.900 --> 13:11.900
那么数据仓库里面

13:11.900 --> 13:12.900
可以有很多的集合

13:12.900 --> 13:14.900
就 collecting

13:14.900 --> 13:16.900
那么比方说我们学校的数据库里面

13:16.900 --> 13:18.900
可以有数据的集合

13:18.900 --> 13:19.900
比方说图书界约

13:19.900 --> 13:21.900
我们有数据的集合

13:21.900 --> 13:22.900
也有老师的集合

13:22.900 --> 13:23.900
甚至还有学生的集合

13:23.900 --> 13:24.900
等等

13:24.900 --> 13:26.900
那么一个数据库里面

13:26.900 --> 13:27.900
可能也会有很多的集合

13:27.900 --> 13:28.900
这些集合呢

13:28.900 --> 13:30.900
你可以把它想象成一个数组

13:30.900 --> 13:32.900
每一个集合里面

13:32.900 --> 13:33.900
它有很多的稳当

13:33.900 --> 13:34.900
你看它的关系

13:34.900 --> 13:35.900
一个集合里面

13:35.900 --> 13:36.900
还有很多的稳当

13:36.900 --> 13:37.900
那么这个稳当是啥呢

13:37.900 --> 13:38.900
这个稳当呢

13:38.900 --> 13:39.900
你可以把它想象成为

13:39.900 --> 13:42.900
一个gs的对象

13:42.900 --> 13:44.900
其实你们学习这个mongo db

13:44.900 --> 13:46.900
如果说之前没有买社会的知识

13:46.900 --> 13:47.900
其实学习起来

13:47.900 --> 13:48.900
更加简单一点

13:48.900 --> 13:50.900
没有之前的一些干擾

13:50.900 --> 13:51.900
就是一个gs对象

13:51.900 --> 13:53.900
你可以有这样的想象

13:53.900 --> 13:54.900
我们在比方的teacher

13:54.900 --> 13:56.900
teacher是这个集合里面

13:56.900 --> 13:57.900
它有很多的文档

13:57.900 --> 13:58.900
每一个文档就是个对象

13:58.900 --> 13:59.900
你看

13:59.900 --> 14:00.900
每个对象里面是不是有属性

14:00.900 --> 14:01.900
对吧

14:01.900 --> 14:02.900
有各种的干擾属性

14:02.900 --> 14:03.900
这些属性可以是知不出来

14:03.900 --> 14:04.900
可以是数字

14:04.900 --> 14:05.900
甚至可以是数组

14:05.900 --> 14:06.900
甚至可以是另外一个对象

14:06.900 --> 14:07.900
都可以

14:07.900 --> 14:10.900
那么第二个文档又是一个对象

14:10.900 --> 14:12.900
而且这些对象的属性

14:12.900 --> 14:13.900
都不一定是一样的

14:13.900 --> 14:14.900
你看第二个属性

14:14.900 --> 14:15.900
灯哥

14:15.900 --> 14:17.900
灯哥是不是喜欢香菜和秋葵

14:17.900 --> 14:19.900
他是不是又有多了一个数组

14:19.900 --> 14:20.900
多了一个属性

14:20.900 --> 14:21.900
这些对象

14:21.900 --> 14:22.900
他没有要求说

14:22.900 --> 14:24.900
这些属性的名字完全一次

14:24.900 --> 14:25.900
这就是mongo db

14:25.900 --> 14:28.900
它每一个就是一个普通对象而已

14:28.900 --> 14:30.900
那么文档里面就是一个

14:30.900 --> 14:31.900
js对象

14:31.900 --> 14:32.900
我们可以这样想象

14:32.900 --> 14:34.900
然后文档里面又有两个概念

14:34.900 --> 14:37.900
一个叫做主见primary key

14:37.900 --> 14:39.900
主见是什么意思呢

14:39.900 --> 14:40.900
是表示的是

14:40.900 --> 14:41.900
每一个文档

14:41.900 --> 14:44.900
就是每一个对象的唯一编号

14:44.900 --> 14:45.900
比方说老师

14:45.900 --> 14:46.900
老师是不是有可能会

14:46.900 --> 14:47.900
造成一个情况

14:47.900 --> 14:48.900
就是老师的名字

14:48.900 --> 14:50.900
老师的年龄

14:50.900 --> 14:51.900
学生

14:51.900 --> 14:52.900
住址是完全一样

14:52.900 --> 14:53.900
有没有这种特殊情况

14:53.900 --> 14:54.900
有

14:54.900 --> 14:56.900
那么到时候就分不清楚

14:56.900 --> 14:57.900
是哪一个老师了

14:57.900 --> 14:58.900
所以说我们一般来说

14:58.900 --> 15:00.900
他会给他一个唯一的编号

15:00.900 --> 15:01.900
就有点类似于

15:01.900 --> 15:04.900
咱们现实社会里面的生分证

15:04.900 --> 15:05.900
有一个唯一的编号

15:05.900 --> 15:06.900
来代表这个人

15:06.900 --> 15:08.900
或者是来代表对象

15:08.900 --> 15:09.900
这里我没有画出来

15:09.900 --> 15:11.900
但是它里面实际上是有的

15:11.900 --> 15:12.900
我们以后可以看到

15:12.900 --> 15:13.900
另外一个

15:13.900 --> 15:15.900
另外一个概念叫做field

15:15.900 --> 15:16.900
叫做之断

15:16.900 --> 15:17.900
之断啥意思呢

15:17.900 --> 15:20.900
就是对象里面的各种属性

15:20.900 --> 15:21.900
各种属性的之断

15:21.900 --> 15:22.900
比如lamb之断

15:22.900 --> 15:23.900
a之断

15:23.900 --> 15:25.900
这是个事实概念

15:25.900 --> 15:26.900
数据库集合

15:26.900 --> 15:28.900
一个数据库里面包含多个集合

15:28.900 --> 15:30.900
一个集合里面包含多个文档

15:30.900 --> 15:32.900
每个文档里面有多个之断

15:32.900 --> 15:35.900
其中有个特殊的之断就是主见

15:35.900 --> 15:36.900
这是它的概念

15:37.900 --> 15:38.900
没问题了

15:39.900 --> 15:41.900
你们凭说这个21T到底是啥

15:41.900 --> 15:43.900
到底是个啥

15:43.900 --> 15:48.500
前面有人爆出了吗

15:48.500 --> 15:49.500
我看一下

15:49.500 --> 15:53.380
一把错误解权

15:53.380 --> 15:54.380
同学的问问题

15:54.380 --> 15:56.380
就把错误解权解图

15:56.380 --> 16:04.580
他说你的mongoDB看不全

16:06.580 --> 16:07.580
好 接下来我们看一下

16:07.580 --> 16:08.580
在load里面

16:08.580 --> 16:09.580
我们关注的是在load里面

16:09.580 --> 16:11.580
如何来使用这个mongoDB

16:11.580 --> 16:13.580
就是我们现在数据库已经有了

16:13.580 --> 16:15.580
我们如何在load介石里面

16:15.580 --> 16:17.580
去操作它呢

16:18.580 --> 16:20.580
那么我们要在load介石里面去操作它

16:20.580 --> 16:22.580
需要安装一个第三方的库

16:22.580 --> 16:23.580
别人给你写好的

16:23.580 --> 16:24.580
你需要安装一下

16:24.580 --> 16:25.580
这个安装的方式

16:25.580 --> 16:26.580
我们昨天已经讲了

16:26.580 --> 16:27.580
就是用npmI

16:27.580 --> 16:29.580
然后库的名字叫做mongoes

16:29.580 --> 16:30.580
好 我们在这里呢

16:30.580 --> 16:32.580
第二天这里去新建个文件夹

16:35.460 --> 16:37.460
如果说大家安装有失败的情况下

16:37.460 --> 16:38.460
因为我这里

16:38.460 --> 16:40.460
如果说一个个去解决的话

16:40.460 --> 16:41.460
时间就太久了

16:41.460 --> 16:42.460
有失败的情况下

16:42.460 --> 16:43.460
认真听客

16:43.460 --> 16:44.460
我们下来过后

16:44.460 --> 16:45.460
问一下打印老师

16:45.460 --> 16:47.460
去里面问一下都可以

16:47.460 --> 16:48.460
我们在这里呢

16:48.460 --> 16:49.460
去建立个文件夹

16:49.460 --> 16:50.460
比方说mine app

16:50.460 --> 16:54.310
好 这里呢

16:54.310 --> 16:55.310
打开vscode

16:55.310 --> 16:58.650
拖进来了

17:06.140 --> 17:07.140
然后老过去

17:07.140 --> 17:08.140
然后这里呢

17:08.140 --> 17:10.140
打开这个中端

17:11.140 --> 17:12.140
接下来

17:12.140 --> 17:13.140
我们按照昨天的写法

17:13.140 --> 17:14.140
首先干嘛

17:14.140 --> 17:16.140
首先初始化npm init

17:16.140 --> 17:17.140
n-y

17:18.140 --> 17:19.140
初始化

17:20.140 --> 17:21.140
然后主要是目的呢

17:21.140 --> 17:22.140
是生成一个pack.json

17:22.140 --> 17:26.150
生成一下这个文件

17:26.150 --> 17:27.150
ok

17:27.150 --> 17:28.150
那么这个时候呢

17:28.150 --> 17:29.150
就是这个控制台呢

17:29.150 --> 17:30.150
这个控制台的命令行

17:30.150 --> 17:31.150
它有的时候呢

17:31.150 --> 17:32.150
会卡住

17:32.150 --> 17:33.150
卡住的原因呢

17:33.150 --> 17:34.150
是因为这个原因

17:34.150 --> 17:35.150
有点属性

17:35.150 --> 17:36.150
这里边有一个

17:37.150 --> 17:38.150
这是个windows

17:38.150 --> 17:39.150
这里边老毛病了

17:39.150 --> 17:40.150
这里有个快速编辑模式

17:40.150 --> 17:41.150
你把快速编辑模式

17:41.150 --> 17:42.150
取消了过后了

17:42.150 --> 17:43.150
它就不会卡住了

17:44.150 --> 17:45.150
快速编辑模式啥意思呢

17:45.150 --> 17:46.150
就是它允许你在这里边

17:46.150 --> 17:47.150
去选中文字

17:47.150 --> 17:48.150
进行复制粘贴

17:48.150 --> 17:50.150
它允许你这样做

17:51.150 --> 17:52.150
如果说你正在复制文字

17:52.150 --> 17:53.150
正在选中文字

17:53.150 --> 17:54.150
它会暂停的

17:54.150 --> 17:55.150
有什么意思吧

17:55.150 --> 17:56.150
如果说你把

17:56.150 --> 17:57.150
你把它勾选

17:57.150 --> 17:58.150
把勾去掉就完事了

17:58.150 --> 17:59.150
然后我这里还是把勾选上

17:59.150 --> 18:00.150
因为有的时候

18:00.150 --> 18:01.150
我要复制一下

18:01.150 --> 18:02.150
如果说它暂停

18:02.150 --> 18:03.150
那你按一下回车

18:03.150 --> 18:04.150
按一下任何键

18:04.150 --> 18:05.150
你会恢复

18:05.150 --> 18:07.150
我们这里也继续

18:07.150 --> 18:09.150
生成了个拍点节省之外

18:09.150 --> 18:10.150
之后我们接下来

18:10.150 --> 18:12.150
去安装一下

18:12.150 --> 18:14.150
安装一下这个Monguz

18:14.150 --> 18:15.150
这个东西为什么要安装它呢

18:15.150 --> 18:16.150
主要是

18:16.150 --> 18:18.150
它里边提供了一些对象

18:18.150 --> 18:19.150
函数

18:19.150 --> 18:20.150
就是一些接口

18:20.150 --> 18:23.150
可以供我们去操作Mongodb

18:24.150 --> 18:25.150
安装一下

18:25.150 --> 18:26.150
让它安装吧

18:26.150 --> 18:27.150
我们在这里

18:27.150 --> 18:28.150
去新建一个文件

18:28.150 --> 18:30.150
叫index.js

18:32.150 --> 18:33.150
新建个文件

18:33.150 --> 18:34.150
index.js

18:34.150 --> 18:35.150
来做一些测试

18:35.150 --> 18:36.150
在里边去写一些代码

18:36.150 --> 18:37.150
来操作我们的数据库

18:37.150 --> 18:38.150
看一下怎么来起

18:40.150 --> 18:41.150
要操作

18:41.150 --> 18:42.150
通过这个Monguz

18:42.150 --> 18:43.150
去操作数据库

18:43.150 --> 18:45.150
有几件事情要做

18:45.150 --> 18:46.150
第一件事情

18:46.150 --> 18:47.150
创建连接

18:47.150 --> 18:48.150
第二件事情

18:48.150 --> 18:49.150
定运议schema和model

18:49.150 --> 18:50.150
第三件事情

18:50.150 --> 18:51.150
才是真正的去操作数据库

18:51.150 --> 18:53.150
所以说有两个前提条件

18:53.150 --> 18:54.150
我们要先去做

18:54.150 --> 18:56.150
第一个叫做创建连接

18:56.150 --> 18:58.150
创建连接代码

18:58.150 --> 18:59.150
我就写好了

18:59.150 --> 19:00.150
为了节约时间

19:00.150 --> 19:01.150
我直接把它复制粘贴

19:01.150 --> 19:03.150
我来解释一下这里的代码

19:04.150 --> 19:06.150
那么连接是什么东西

19:06.150 --> 19:07.150
你可以这样子想象

19:07.150 --> 19:08.150
咱们漏的程序

19:08.150 --> 19:10.150
是运行在哪里的

19:10.150 --> 19:11.150
运行在内存里边的

19:11.150 --> 19:12.150
对吧

19:12.150 --> 19:14.150
我们的MongoDB管理的是什么

19:14.150 --> 19:17.150
管理的是磁盘里边的数据

19:17.150 --> 19:18.150
那我们的内存

19:18.150 --> 19:19.150
跟磁盘之间

19:19.150 --> 19:21.150
是不是有一道红钩

19:21.150 --> 19:22.150
他们的格式都不一样

19:22.150 --> 19:23.150
存的位置都不一样

19:23.150 --> 19:24.150
操作方式

19:24.150 --> 19:25.150
也是完全不一样的

19:25.150 --> 19:26.150
所以说

19:26.150 --> 19:27.150
需要有一个东西

19:27.150 --> 19:28.150
去把它连接起来

19:28.150 --> 19:29.150
打通一个通道

19:29.150 --> 19:31.150
把内存跟磁盘之间

19:31.150 --> 19:32.150
有一个通道

19:32.150 --> 19:33.150
让我们的程序

19:33.150 --> 19:34.150
可以通过这个通道

19:34.150 --> 19:36.150
去管理我们的数据库

19:36.150 --> 19:37.150
就这么个意思

19:37.150 --> 19:38.150
所以说

19:38.150 --> 19:39.150
我们需要连接

19:39.150 --> 19:40.150
连接产生一个通道

19:40.150 --> 19:41.150
有了这个通道之后

19:41.150 --> 19:42.150
那么后续才能

19:42.150 --> 19:43.150
对这个数据库进行操作

19:43.150 --> 19:44.150
就这么个意思

19:44.150 --> 19:45.150
那么这个连接代码

19:45.150 --> 19:46.150
什么意思呢

19:46.150 --> 19:47.150
其实这个连接代码

19:47.150 --> 19:50.150
这里有很多地方有点多余

19:50.150 --> 19:53.150
其实这句话是可以不要的

19:53.150 --> 19:54.150
下面这两句话

19:54.150 --> 19:56.150
也可以不要的

19:56.150 --> 19:57.150
就这么两句话

19:57.150 --> 19:58.150
就可以连接了

19:58.150 --> 19:59.150
你看

19:59.150 --> 20:00.150
我们昨天学的

20:00.150 --> 20:02.150
导入了个第三方库

20:02.150 --> 20:03.150
Mongus

20:03.150 --> 20:05.150
然后使用它里边的一个函数

20:05.150 --> 20:06.150
Connect

20:06.150 --> 20:07.150
叫做什么连接

20:07.150 --> 20:09.150
连接里边这里写啥呢

20:09.150 --> 20:11.150
写的就是一个连接制服串

20:11.150 --> 20:12.150
连接制服串

20:12.150 --> 20:13.150
是一个固定的写法

20:13.150 --> 20:14.150
Mongodb

20:14.150 --> 20:15.150
冒号

20:15.150 --> 20:16.150
这里写上你的本

20:16.150 --> 20:17.150
你的主机名

20:17.150 --> 20:19.150
就是你要连接哪一台

20:19.150 --> 20:20.150
计算机的数据库

20:20.150 --> 20:21.150
因为我都是

20:21.150 --> 20:22.150
安卓一台计算机商的

20:22.150 --> 20:24.150
我们的NodeGS

20:24.150 --> 20:25.150
是在这台计算机上运行

20:25.150 --> 20:26.150
我们的Mongodb

20:26.150 --> 20:28.150
也是在这台计算机上

20:28.150 --> 20:29.150
所以说

20:29.150 --> 20:31.150
本机的话就是

20:32.150 --> 20:33.150
后边写到什么呢

20:33.150 --> 20:35.150
写上你的数据库的名称

20:35.150 --> 20:37.150
你要连接的是

20:37.150 --> 20:39.150
本机的哪一个数据库

20:39.150 --> 20:41.150
那么我们这里的本机

20:41.150 --> 20:42.150
是有三个数据库

20:42.150 --> 20:43.150
对吧

20:43.150 --> 20:44.150
它默认建立的

20:44.150 --> 20:45.150
这三个数据库不要去动

20:45.150 --> 20:47.150
我们需不需要去新建一个数据库呢

20:47.150 --> 20:48.150
没有必要

20:48.150 --> 20:50.150
你这里如果说写的数据库的名字

20:50.150 --> 20:51.150
它不存在

20:51.150 --> 20:53.150
那么它也会自动的帮你新建

20:53.150 --> 20:55.150
这是Mongodb的功能

20:55.150 --> 20:56.150
你不用去管它了

20:56.150 --> 20:57.150
你这样子写

20:57.150 --> 20:58.150
没问题的

20:59.150 --> 21:00.150
当然呢

21:01.150 --> 21:02.150
你的数据库的名字

21:02.150 --> 21:03.150
可以取任何名字

21:03.150 --> 21:04.150
我这里随便取个名字

21:04.150 --> 21:05.150
叫Case测试嘛

21:06.150 --> 21:08.150
那么为什么会有这些代码呢

21:08.150 --> 21:10.150
这些代码是因为Mongodb

21:10.150 --> 21:11.150
这个库

21:11.150 --> 21:13.150
它更新了很多的版本

21:14.150 --> 21:15.150
以前的旧版本

21:15.150 --> 21:17.150
有些地方的处理方式

21:17.150 --> 21:19.150
跟新版本不太一样

21:19.150 --> 21:20.150
它为了保证兼容

21:20.150 --> 21:23.150
它不敢去改动旧版本的东西

21:23.150 --> 21:25.150
但是它希望你以后

21:25.150 --> 21:27.150
尽量的去使用新版本的功能

21:28.150 --> 21:30.150
因此它让你去手动的写代码

21:30.150 --> 21:31.150
来进行声明

21:31.150 --> 21:32.150
那么这些地方呢

21:32.150 --> 21:34.150
我们给大家简单说一下就行了

21:34.150 --> 21:37.150
也没有办法去太过细节去解释

21:37.150 --> 21:39.150
这个玩意是以前的版本

21:39.150 --> 21:42.150
对Mongodb的索应的处理方式不一样

21:42.150 --> 21:44.150
Mongodb现在变成付费了过后

21:44.150 --> 21:46.150
它的索应处理方式有更改

21:46.150 --> 21:47.150
那么相当于这个库

21:47.150 --> 21:48.150
也会有相应的更改

21:48.150 --> 21:49.150
它必须要写上这么一句话

21:49.150 --> 21:52.150
使用新的本处理索应的方式

21:52.150 --> 21:53.150
至于什么是索应

21:53.150 --> 21:54.150
它又怎么更改的

21:54.150 --> 21:55.150
跟我们没它关系了

21:55.150 --> 21:57.150
这个东西可以不写

21:57.150 --> 21:58.150
它会报一个警告

21:58.150 --> 21:59.150
它不会报错

21:59.150 --> 22:00.150
仍然可以正常执行

22:00.150 --> 22:01.150
但是它会报一个警告

22:01.150 --> 22:05.150
那么这两句话也是差不多的意思

22:05.150 --> 22:06.150
它就版本有一些处理方式

22:06.150 --> 22:08.150
新版本里面也有一些处理方式

22:08.150 --> 22:09.150
你可以不写

22:09.150 --> 22:11.150
不写的话它会报一个警告

22:11.150 --> 22:12.150
你写的过后

22:12.150 --> 22:14.150
不写的话也不会报错的

22:14.150 --> 22:15.150
也是可以正常执行的

22:15.150 --> 22:16.150
它只是要报一个警告而已

22:16.150 --> 22:18.150
所以说把这些东西加上

22:18.150 --> 22:20.150
主要的真正的功能实现的是

22:20.150 --> 22:21.150
在这一句话

22:21.150 --> 22:23.150
连接这个数据库

22:23.150 --> 22:25.150
好,那么下面这句是什么意思呢

22:25.150 --> 22:26.150
下面这句表示的是

22:26.150 --> 22:27.150
给它注册一个事件

22:27.150 --> 22:29.150
就有点类似于动物事件那种

22:29.150 --> 22:31.150
当什么什么什么的时候

22:31.150 --> 22:34.150
当这个Mangus的连接

22:34.150 --> 22:37.150
当什么打开的时候

22:37.150 --> 22:38.150
这里是个箭头

22:38.150 --> 22:39.150
大家看不懂

22:39.150 --> 22:40.150
我们换一种写法

22:40.150 --> 22:45.810
当这个连接打开的时候

22:45.810 --> 22:46.810
就连接成功的时候

22:46.810 --> 22:48.810
我们运行一个函数

22:48.810 --> 22:50.810
表示连接一打开

22:50.810 --> 22:51.810
就完了

22:51.810 --> 22:52.810
这就是数据库的连接

22:52.810 --> 22:54.810
你只要保证在操作数据库

22:54.810 --> 22:56.810
对数据库进行其他操作之前

22:57.810 --> 22:59.810
一堆数据库进行的连接就ok了

22:59.810 --> 23:03.380
好,咱们运行看一下

23:03.380 --> 23:05.380
load index

23:06.380 --> 23:07.380
连接一打开

23:07.380 --> 23:08.380
说没问题了

23:08.380 --> 23:10.380
你只要保证在最开始去执行一下

23:10.380 --> 23:12.380
这句代码就完事了

23:12.380 --> 23:13.380
这是这一部分

23:13.380 --> 23:15.380
这是连接功能

23:15.380 --> 23:16.380
好,继续看

23:16.380 --> 23:18.380
有了连接之后

23:18.380 --> 23:20.380
接下来要做下面这件事

23:20.380 --> 23:22.380
叫做定义schema和model

23:22.380 --> 23:24.380
这个我确实不知道怎么翻译

23:24.380 --> 23:26.380
schema早翻译了

23:27.380 --> 23:29.380
翻译成结构

23:30.380 --> 23:32.380
翻译成架构

23:32.380 --> 23:34.380
怎么翻译都翻译不出来这个意思

23:34.380 --> 23:35.380
就是一个结构的意思

23:35.380 --> 23:37.380
差不多是结构的意思

23:37.380 --> 23:39.380
它是一个什么样的关系的这两个东西

23:39.380 --> 23:40.380
这两个东西

23:40.380 --> 23:41.380
实际上mongoDB里面

23:41.380 --> 23:43.380
有没有这个两个概念了

23:43.380 --> 23:44.380
实际上是有的

23:44.380 --> 23:45.380
只不过这两个概念

23:45.380 --> 23:46.380
在mongoDB里面

23:46.380 --> 23:48.380
它本身的功能比较弱

23:48.380 --> 23:49.380
在我们这个库里面

23:49.380 --> 23:50.380
mongo's这个库里面

23:50.380 --> 23:51.380
它给你加强了

23:51.380 --> 23:52.380
它啥意思呢

23:52.380 --> 23:53.380
它的意思就是说

23:53.380 --> 23:55.380
我通过一个结构

23:55.380 --> 23:57.380
就去组成一个模型

23:57.380 --> 23:59.380
那么这个模型是什么意思呢

23:59.380 --> 24:00.380
这个模型就对应的是

24:00.380 --> 24:02.380
mongoDB中的文档

24:02.380 --> 24:03.380
举个例子

24:03.380 --> 24:05.380
比方说我们的数据库里面

24:05.380 --> 24:06.380
有两种模型

24:06.380 --> 24:07.380
比方说我们要存什么呢

24:07.380 --> 24:08.380
存用户

24:08.380 --> 24:10.380
存一些新闻

24:10.380 --> 24:11.380
像这些东西

24:11.380 --> 24:13.380
我们希望把它存下来

24:13.380 --> 24:14.380
那么我们这里

24:14.380 --> 24:15.380
是不是有两个模型

24:15.380 --> 24:16.380
什么叫模型

24:16.380 --> 24:18.380
用户有哪些属性啊

24:18.380 --> 24:20.380
每个属性是啥类型啊

24:20.380 --> 24:21.380
有没有什么

24:21.380 --> 24:22.380
每个属性有什么

24:22.380 --> 24:23.380
有没有什么样的限制

24:23.380 --> 24:24.380
这就是模型

24:24.380 --> 24:26.380
这些东西都是结构

24:26.380 --> 24:27.380
那么我们可以看到

24:27.380 --> 24:28.380
用户和新闻

24:28.380 --> 24:30.380
他们会形成这么两种结构

24:30.380 --> 24:31.380
用户里面有账号

24:31.380 --> 24:33.380
我这里随便举了一些例子

24:33.380 --> 24:35.380
比方说用户里面有账号

24:35.380 --> 24:37.380
登录账号登录密码

24:37.380 --> 24:39.380
然后用户的姓名

24:39.380 --> 24:40.380
用户的年龄

24:40.380 --> 24:41.380
以及用户的角色

24:41.380 --> 24:42.380
角色的是

24:42.380 --> 24:44.380
这三个字母出来的一个管理员

24:44.380 --> 24:47.380
或者是普通用户或者是VIP

24:47.380 --> 24:48.380
新闻呢

24:48.380 --> 24:49.380
它有新闻的标题

24:49.380 --> 24:50.380
新闻的内容

24:50.380 --> 24:51.380
新闻的发布日期

24:51.380 --> 24:53.380
新闻的频道

24:53.380 --> 24:54.380
新闻的连接地

24:54.380 --> 24:55.380
原始的连接地址

24:55.380 --> 24:57.380
那么有假设

24:57.380 --> 24:59.380
咱们有这么两个模型

24:59.380 --> 25:00.380
那么我们要

25:00.380 --> 25:02.380
如果说我要来操作

25:02.380 --> 25:03.380
mongo db的话

25:03.380 --> 25:04.380
我们要做什么事呢

25:04.380 --> 25:06.380
我们首先叫建立两个结构

25:06.380 --> 25:08.380
一个是关于用户的结构

25:08.380 --> 25:10.380
结构里面要定义

25:10.380 --> 25:11.380
用户里面有啥

25:11.380 --> 25:12.380
有啥有哪些属性

25:12.380 --> 25:13.380
就有哪些字段

25:13.380 --> 25:14.380
我们之前说过的

25:14.380 --> 25:15.380
对吧

25:15.380 --> 25:16.380
有哪些feal

25:16.380 --> 25:17.380
有哪些字段

25:17.380 --> 25:19.380
然后用户里面

25:19.380 --> 25:20.380
把一个字段是什么类型

25:20.380 --> 25:22.380
有没有什么约束条件

25:22.380 --> 25:24.380
然后我们再定义一个新闻的模型

25:24.380 --> 25:26.380
新闻的结构

25:26.380 --> 25:28.380
新闻里面有哪些字段

25:28.380 --> 25:29.380
哪些属性

25:29.380 --> 25:30.380
每个属性有什么类型

25:30.380 --> 25:33.380
然后通过这个结构

25:33.380 --> 25:35.380
然后去定义模型

25:35.380 --> 25:36.380
定义了模型过后

25:36.380 --> 25:37.380
这个模型就是

25:37.380 --> 25:39.380
我们数据库里面的文档

25:39.380 --> 25:41.380
可能还是有些偷向的

25:41.380 --> 25:43.380
我们写个例子就明白了

25:43.380 --> 25:44.380
比方说这里呢

25:44.380 --> 25:46.380
为了避免浪费时间

25:46.380 --> 25:48.380
我就把代码直接拷皮过来了

25:48.380 --> 25:51.380
然后给大家进行解读

25:51.380 --> 25:52.380
我先接着写

25:52.380 --> 25:53.380
前面已经打开了连接了

25:53.380 --> 25:55.380
我们接着往后写

25:55.380 --> 25:56.380
大家看

25:56.380 --> 25:57.380
下面

25:57.380 --> 25:58.380
这一部分在干嘛呢

25:58.380 --> 26:00.380
这一部分就在定义一个

26:00.380 --> 26:01.380
啊

26:01.380 --> 26:02.380
啊

26:02.380 --> 26:03.380
啊

26:03.380 --> 26:04.380
结构

26:04.380 --> 26:06.380
定义一个结构

26:06.380 --> 26:07.380
怎么定义的

26:07.380 --> 26:08.380
它通过一个构造函数

26:08.380 --> 26:09.380
叫nu

26:09.380 --> 26:10.380
一个mongus

26:10.380 --> 26:11.380
mongus不是在这里

26:11.380 --> 26:12.380
对吧

26:12.380 --> 26:13.380
我们导入进来的

26:13.380 --> 26:14.380
mongus里面有个构造函数

26:14.380 --> 26:15.380
叫schema

26:15.380 --> 26:16.380
是不是就结构

26:16.380 --> 26:18.380
创建一个结构对象

26:18.380 --> 26:19.380
用一个辩量接收一下

26:19.380 --> 26:21.380
一个辩量名字随便去

26:21.380 --> 26:22.380
然后呢

26:22.380 --> 26:23.380
这里边有个参数

26:23.380 --> 26:24.380
参数是啊

26:24.380 --> 26:25.380
这个参数是一个对象

26:25.380 --> 26:27.380
就你不是要定义一个结构吗

26:27.380 --> 26:28.380
那你要告诉我

26:28.380 --> 26:29.380
这个结构有哪些东西

26:29.380 --> 26:31.380
那你我们展开看一下

26:31.380 --> 26:32.380
哎

26:32.380 --> 26:33.380
他就告诉我了

26:33.380 --> 26:34.380
我就告诉他了

26:34.380 --> 26:35.380
我这个结构里边有什么呢

26:35.380 --> 26:36.380
我要定义一个拥护的结构

26:36.380 --> 26:37.380
这个结构里边呢

26:37.380 --> 26:39.380
有这么一些字段

26:39.380 --> 26:40.380
啊

26:40.380 --> 26:41.380
有登录账号密码

26:41.380 --> 26:42.380
拥护的名字

26:42.380 --> 26:43.380
拥护的年年

26:43.380 --> 26:44.380
拥护的角色

26:44.380 --> 26:45.380
你的意思吧

26:45.380 --> 26:46.380
我就表示的是

26:46.380 --> 26:47.380
我就告诉你了

26:47.380 --> 26:48.380
啊

26:48.380 --> 26:50.380
这个结构里边有这么一些字段

26:50.380 --> 26:51.380
那么每一个字段

26:51.380 --> 26:52.380
它里边有什么东西呢

26:52.380 --> 26:53.380
比方每个字段

26:53.380 --> 26:54.380
它的类型是什么呢

26:54.380 --> 26:55.380
它有没有什么约束呢

26:55.380 --> 26:56.380
我们把每一个字段呢

26:56.380 --> 26:57.380
配置成一个对象

26:57.380 --> 26:58.380
你看啊

26:58.380 --> 26:59.380
展开看一下

26:59.380 --> 27:00.380
我们的老铁id

27:00.380 --> 27:03.380
它的类型是一个支付串

27:03.380 --> 27:05.380
这个这个数据呢

27:05.380 --> 27:07.380
是必填的required to

27:07.380 --> 27:08.380
必填的

27:08.380 --> 27:10.380
以这些东西的约束啊

27:10.380 --> 27:11.380
它会影响到你

27:11.380 --> 27:12.380
后面对数据的操作

27:12.380 --> 27:13.380
比方说我们这里

27:13.380 --> 27:14.380
设置的必填

27:14.380 --> 27:16.380
那一会我添加一个用户的时候

27:16.380 --> 27:17.380
如果说你这个

27:17.380 --> 27:18.380
没有填写

27:18.380 --> 27:19.380
会导致一个什么问题

27:19.380 --> 27:20.380
它会导致包戳

27:20.380 --> 27:21.380
它会包戳给你看

27:21.380 --> 27:22.380
啊

27:22.380 --> 27:23.380
比方说这里Ulico

27:23.380 --> 27:25.380
我们这里打个注释了

27:25.380 --> 27:27.380
这是必填

27:27.380 --> 27:28.380
啊

27:28.380 --> 27:29.380
就是这个属性呢

27:29.380 --> 27:30.380
你是必须要写的

27:30.380 --> 27:31.380
不写不行

27:31.380 --> 27:33.380
因为我这里设置的required to

27:33.380 --> 27:35.380
这个Ulico什么意思呢

27:35.380 --> 27:37.380
这个是属性值

27:37.380 --> 27:38.380
为一

27:38.380 --> 27:39.380
啥意思

27:39.380 --> 27:41.380
比方说我们用户的登录账号

27:41.380 --> 27:42.380
你想象是不是为一的

27:42.380 --> 27:44.380
多个用户它的账号

27:44.380 --> 27:45.380
也是为一的

27:45.380 --> 27:46.380
如果说你新增的一个用户

27:46.380 --> 27:48.380
它的账号跟之前的账号有重复

27:48.380 --> 27:49.380
是不是不能加进去

27:49.380 --> 27:50.380
对吧

27:50.380 --> 27:51.380
这属性值为一

27:51.380 --> 27:53.380
那么可以看到除了类型之外

27:53.380 --> 27:54.380
这些玩意儿

27:54.380 --> 27:55.380
是不是都是跟类型

27:55.380 --> 27:57.380
跟这个数据限制有相关的

27:57.380 --> 27:58.380
对吧都有限制相关的

27:58.380 --> 27:59.380
好

27:59.380 --> 28:00.380
那么去什么意思呢

28:00.380 --> 28:01.380
去就表示的是

28:01.380 --> 28:03.380
写入数据时

28:03.380 --> 28:07.010
写入数据时

28:07.010 --> 28:08.010
哎

28:08.010 --> 28:10.010
等一下

28:10.010 --> 28:11.010
我这里说话里面

28:11.010 --> 28:12.010
没有回应吗

28:12.010 --> 28:14.010
有没有回应啊

28:14.010 --> 28:17.010
我这里说话有没有回应啊

28:18.010 --> 28:19.010
没有是吧

28:19.010 --> 28:20.010
没有就好

28:20.010 --> 28:21.010
因为我这个电脑

28:21.010 --> 28:22.010
每次重启了过后

28:22.010 --> 28:23.010
刚才重启的意思

28:23.010 --> 28:24.010
每次重启过后

28:24.010 --> 28:25.010
它都有一个回应

28:25.010 --> 28:26.010
没有就好啊

28:26.010 --> 28:28.010
这是写入数据时

28:28.010 --> 28:31.010
会自动的去掉守卫空格

28:31.010 --> 28:36.510
守卫空格

28:36.510 --> 28:38.510
刚才有朋友在问啥

28:38.510 --> 28:41.460
王狗DB

28:41.460 --> 28:43.460
是不是对甚至吧

28:43.460 --> 28:44.460
兼容性不好了

28:44.460 --> 28:45.460
怎么会兼容性不好

28:45.460 --> 28:46.460
没有问题啊

28:46.460 --> 28:47.460
没有问题的

28:47.460 --> 28:49.460
会自动去掉守卫空格

28:50.460 --> 28:52.460
这个下面表示的是

28:52.460 --> 28:54.460
有个验证有个约束

28:54.460 --> 28:55.460
约束什么呢

28:55.460 --> 28:56.460
这是一个制服串嘛

28:56.460 --> 29:00.460
制服串的最小长度

29:00.460 --> 29:01.460
微杀

29:01.460 --> 29:04.840
下边也是个约束

29:04.840 --> 29:05.840
约束

29:05.840 --> 29:06.840
这些呢

29:06.840 --> 29:07.840
会有什么影响呢

29:07.840 --> 29:08.840
会对我们后边

29:08.840 --> 29:10.840
对数据的操作有影响

29:10.840 --> 29:11.840
约束

29:11.840 --> 29:14.840
这是制服串的最大长度

29:14.840 --> 29:15.840
微

29:15.840 --> 29:16.840
是吧

29:16.840 --> 29:17.840
就这么个意思

29:17.840 --> 29:18.840
那么我们现在看一下

29:18.840 --> 29:19.840
这么多信息

29:19.840 --> 29:20.840
一个制断就搞定了

29:20.840 --> 29:21.840
对吧

29:21.840 --> 29:22.840
一个结构

29:22.840 --> 29:23.840
它不是说我要加数据

29:23.840 --> 29:24.840
我这里只是要定

29:24.840 --> 29:26.840
它的结构是什么样子

29:26.840 --> 29:27.840
没问题的

29:27.840 --> 29:28.840
那么现在我们再看

29:28.840 --> 29:29.840
下面一个

29:29.840 --> 29:30.840
locking password

29:30.840 --> 29:31.840
这啥意思呢

29:31.840 --> 29:32.840
表示的是登录密码

29:32.840 --> 29:33.840
对吧

29:33.840 --> 29:34.840
它是制服串也不说了

29:34.840 --> 29:35.840
必须要填写

29:35.840 --> 29:37.840
然后自动去掉守卫空格

29:37.840 --> 29:38.840
最小的是6

29:38.840 --> 29:39.840
最大的是18

29:39.840 --> 29:40.840
长度是18

29:40.840 --> 29:41.840
好

29:41.840 --> 29:42.840
那么下面这个

29:42.840 --> 29:43.840
是什么意思呢

29:43.840 --> 29:44.840
它会影响到后边

29:44.840 --> 29:48.840
后续对用户进行

29:49.840 --> 29:51.840
查询的时候

29:51.840 --> 29:53.840
默认情况下

29:53.840 --> 29:56.840
不要查询密码

29:56.840 --> 29:57.840
我们一般来说

29:57.840 --> 29:59.840
是不会把密码查出来的

29:59.840 --> 30:00.840
所以说我们一般来说

30:00.840 --> 30:01.840
不要去查

30:01.840 --> 30:03.840
把密码给我查出来

30:03.840 --> 30:04.840
就是那个是force

30:04.840 --> 30:05.840
这个是表示选中

30:05.840 --> 30:07.840
不要选中它

30:07.840 --> 30:08.840
就这个意思

30:08.840 --> 30:09.840
它会影响后边

30:09.840 --> 30:10.840
我们把这个模型定一号

30:10.840 --> 30:11.840
好

30:11.840 --> 30:12.840
下面

30:12.840 --> 30:13.840
你看有没有

30:13.840 --> 30:14.840
其他的看一下

30:14.840 --> 30:15.840
有没有别的要说的

30:15.840 --> 30:16.840
没有对吧

30:16.840 --> 30:17.840
制服串必须要填

30:17.840 --> 30:18.840
然后去掉守卫空格

30:18.840 --> 30:19.840
12

30:19.840 --> 30:20.840
最大的是10

30:20.840 --> 30:21.840
A级

30:21.840 --> 30:22.840
内情是数字

30:22.840 --> 30:23.840
必须要填

30:23.840 --> 30:25.840
这是最小值

30:25.840 --> 30:28.840
年龄的最小值

30:28.840 --> 30:29.840
最小值

30:29.840 --> 30:30.840
唯一

30:30.840 --> 30:33.840
最大值

30:33.840 --> 30:34.840
年龄的

30:34.840 --> 30:35.840
最大值

30:35.840 --> 30:37.840
唯一百

30:37.840 --> 30:38.840
已经很夸张了

30:38.840 --> 30:39.840
给它设置一百

30:39.840 --> 30:40.840
好

30:40.840 --> 30:41.840
那么下面是肉

30:41.840 --> 30:42.840
肉是一个制服串

30:42.840 --> 30:43.840
它必须要填

30:43.840 --> 30:44.840
而且要去掉守卫空格

30:44.840 --> 30:45.840
然后下面是个银

30:45.840 --> 30:46.840
这是啥意思呢

30:46.840 --> 30:48.840
这个表示的是

30:48.840 --> 30:50.840
该制服串

30:50.840 --> 30:51.840
这是角色

30:51.840 --> 30:53.840
用户角色

30:53.840 --> 30:54.840
角色

30:54.840 --> 30:56.840
是一个制服串

30:56.840 --> 30:58.840
你看这里是不是制服串

30:58.840 --> 31:01.840
该制服串的取值

31:01.840 --> 31:05.840
必须在这三个指中

31:05.840 --> 31:07.840
必须是

31:07.840 --> 31:09.840
这三个指

31:09.840 --> 31:11.840
复词一下

31:11.840 --> 31:15.840
必须是这三个指中的一个

31:16.840 --> 31:17.840
表示美举

31:17.840 --> 31:18.840
就表示我们用户的角色

31:18.840 --> 31:19.840
就必须要在

31:19.840 --> 31:20.840
从这三个指中选一个

31:20.840 --> 31:21.840
其他的指不正

31:21.840 --> 31:23.840
那么这些东西都会影响到

31:23.840 --> 31:24.840
后边的查询

31:24.840 --> 31:26.840
后边的数据写入

31:26.840 --> 31:28.840
这是我们定义的结构

31:28.840 --> 31:29.840
结构是不是定义好了

31:29.840 --> 31:30.840
定义好了结构过后

31:30.840 --> 31:31.840
这里面是结构的配置

31:31.840 --> 31:32.840
定义好了结构之后

31:32.840 --> 31:34.840
它会返回一个

31:34.840 --> 31:35.840
结构对象

31:35.840 --> 31:37.840
我们要使用这个结构对象

31:37.840 --> 31:38.840
去定义一个模型

31:38.840 --> 31:39.840
我们来看一下

31:39.840 --> 31:41.840
刚才的逻辑

31:41.840 --> 31:42.840
在这

31:42.840 --> 31:44.840
是不是通过一个结构

31:44.840 --> 31:45.840
去定义一个模型

31:45.840 --> 31:46.840
对吧

31:46.840 --> 31:48.840
那么我们怎么来定义模型呢

31:48.840 --> 31:49.840
就通过mongles里面一个

31:49.840 --> 31:51.840
函数叫做model

31:51.840 --> 31:52.840
model表示一名意思

31:52.840 --> 31:53.840
表示模型

31:53.840 --> 31:54.840
里面给它取一个名字

31:54.840 --> 31:55.840
模型的名字

31:55.840 --> 31:57.840
注意这个模型的名字

31:57.840 --> 31:58.840
注意这个模型的名字

31:58.840 --> 31:59.840
这个模型的名字

31:59.840 --> 32:00.840
它就会影响到

32:00.840 --> 32:05.150
我们后边生成的

32:05.150 --> 32:06.150
生成的这个地方

32:06.150 --> 32:07.150
这个东西

32:07.150 --> 32:09.150
生成的这个就是集合

32:09.150 --> 32:10.150
这个模型的名字

32:10.150 --> 32:11.150
其实就是这个集合的名字

32:11.150 --> 32:12.150
它会自动把它变成复数

32:12.150 --> 32:14.150
我们一会就看到了

32:14.150 --> 32:15.150
这样子就定义那个模型了

32:15.150 --> 32:17.150
一个U字模型

32:17.150 --> 32:19.150
那么它会返回一个结构

32:19.150 --> 32:20.150
我们会把这个结构

32:20.150 --> 32:21.150
保存到一个变量里边

32:21.150 --> 32:22.150
因为我们后边

32:22.150 --> 32:23.150
比方说

32:23.150 --> 32:24.150
后边要增加一个用户

32:24.150 --> 32:25.150
要删除一个用户

32:25.150 --> 32:27.150
要去查询用户的话

32:27.150 --> 32:29.150
都是要通过这个模型对象

32:29.150 --> 32:30.150
通过这个模型

32:30.150 --> 32:31.150
它实际上是一个什么呢

32:31.150 --> 32:33.150
实际上是一个构造函数

32:33.150 --> 32:34.150
我们可以把它当成一个

32:34.150 --> 32:35.150
就是一个对象

32:35.150 --> 32:36.150
我们通过这个玩意

32:36.150 --> 32:38.150
去操作我们的用户

32:38.150 --> 32:40.150
所以这个东西一定要记录下来

32:40.150 --> 32:41.150
我们最终操作的时候

32:41.150 --> 32:43.150
是通过这个模型在操作的

32:43.150 --> 32:44.150
这样就定义好了一个什么呢

32:44.150 --> 32:46.150
你看定义好了一个用户结构

32:46.150 --> 32:47.150
通过这个用户结构

32:47.150 --> 32:48.150
给一个模型取个名字

32:48.150 --> 32:50.150
我这个模型名字叫做U字

32:50.150 --> 32:52.150
我使用的结构是这个结构

32:52.150 --> 32:53.150
也就是说

32:53.150 --> 32:54.150
咋意思呢

32:54.150 --> 32:55.150
也就是说有些模型

32:55.150 --> 32:57.150
是可以共用一个结构的

32:57.150 --> 32:59.150
它是这么一个关系

32:59.150 --> 33:00.150
我们这个用户

33:00.150 --> 33:01.150
使用这个结构

33:01.150 --> 33:02.150
来产生一个模型

33:02.150 --> 33:03.150
把它保存起来

33:03.150 --> 33:05.150
这是一个结构

33:05.150 --> 33:07.150
接着我们去看

33:07.150 --> 33:08.150
用户写好了

33:08.150 --> 33:10.150
然后再来看一下新闻

33:10.150 --> 33:11.150
我们不是还有一个新闻吗

33:11.150 --> 33:13.150
我们把新闻复制一下

33:17.900 --> 33:18.900
这是新闻

33:18.900 --> 33:20.900
新闻也是一样的写法

33:20.900 --> 33:22.900
创建一个新闻的结构

33:22.900 --> 33:24.900
你看这里开头看一下吧

33:24.900 --> 33:25.900
这些应该都写过了

33:25.900 --> 33:26.900
没问题吧

33:26.900 --> 33:27.900
新闻的标题

33:27.900 --> 33:28.900
新闻的内容

33:28.900 --> 33:29.900
新闻的日期

33:29.900 --> 33:31.900
日期的内容我们写上带子

33:31.900 --> 33:32.900
它的默认值

33:32.900 --> 33:33.900
我们写上一个函数

33:33.900 --> 33:34.900
你看

33:34.900 --> 33:35.900
这次闹是不是函数

33:35.900 --> 33:36.900
写过了

33:36.900 --> 33:37.900
这是一个函数

33:37.900 --> 33:38.900
对不对

33:39.900 --> 33:41.900
那么为什么这里可以写函数呢

33:41.900 --> 33:42.900
这个default是什么意思呢

33:42.900 --> 33:44.900
default表示默认值

33:44.900 --> 33:45.900
默认值

33:45.900 --> 33:49.590
可以是一个值

33:49.590 --> 33:53.100
也可以是一个函数

33:54.100 --> 33:56.100
那么现在我给它的是一个值

33:56.100 --> 33:57.100
还是一个函数

33:57.100 --> 33:58.100
你看一下

33:58.100 --> 33:59.100
我现在给它的是一个值

33:59.100 --> 34:00.100
还是一个函数

34:00.100 --> 34:08.550
是它呀

34:08.550 --> 34:09.550
是一个函数

34:09.550 --> 34:10.550
对不对

34:10.550 --> 34:11.550
我刚才说了

34:11.550 --> 34:12.550
它是给它的是一个函数

34:12.550 --> 34:14.550
那如果说我这样子写了

34:14.550 --> 34:15.550
给它的是一个值

34:15.550 --> 34:16.550
还是一个函数

34:17.550 --> 34:18.550
这些是结

34:18.550 --> 34:19.550
也是基础

34:19.550 --> 34:20.550
不要让人认为

34:20.550 --> 34:21.550
这些东西是node结构的东西

34:22.550 --> 34:23.550
这些都是基础

34:24.550 --> 34:25.550
很多时候

34:26.550 --> 34:27.550
同学们有的时候

34:27.550 --> 34:29.550
真的是基础砸我不老

34:29.550 --> 34:31.550
还真不是别的东西的问题

34:31.550 --> 34:32.550
这里是值

34:32.550 --> 34:33.550
对吧

34:33.550 --> 34:34.550
它就是把函数

34:34.550 --> 34:36.550
调用过后的反回值

34:36.550 --> 34:37.550
作为它的默认值

34:37.550 --> 34:39.550
它就不是函数了

34:39.550 --> 34:40.550
它可以是一个值

34:40.550 --> 34:41.550
可以是个函数

34:41.550 --> 34:42.550
如果说它是一个函数的话

34:42.550 --> 34:44.550
它会把函数的

34:45.550 --> 34:46.550
反回值

34:46.550 --> 34:47.550
作为

34:47.550 --> 34:48.550
作为什么呢

34:49.550 --> 34:50.550
作为

34:50.550 --> 34:51.550
默认值

34:51.550 --> 34:56.780
那么问大家一个问题

34:56.780 --> 34:57.780
这个问题

34:57.780 --> 34:59.780
可能对某些同学有点难度

34:59.780 --> 35:01.780
这些东西跟node结构

35:01.780 --> 35:03.780
跟mongodb没有任何关系

35:03.780 --> 35:05.780
就纯粹是考验你的结构基础

35:06.780 --> 35:07.780
有没有掌握牢固

35:08.780 --> 35:09.780
你觉得

35:09.780 --> 35:10.780
这个问题回答不出来

35:10.780 --> 35:11.780
没关系

35:11.780 --> 35:12.780
我也会做解答

35:12.780 --> 35:14.780
你觉得我这样子写

35:16.780 --> 35:17.780
和这样子写

35:18.780 --> 35:19.780
有什么样的区别

35:25.530 --> 35:26.530
你觉得这样子写

35:26.530 --> 35:27.530
给这个小括号

35:27.530 --> 35:28.530
和不给这个小括号

35:28.530 --> 35:29.530
有什么样的区别

35:29.530 --> 35:30.530
对象是执行的

35:30.530 --> 35:35.700
功能上有什么样的区别

35:36.700 --> 35:38.700
功能上有什么样的区别

35:42.260 --> 35:43.260
是有区别的

35:43.260 --> 35:44.260
什么区别呢

35:46.260 --> 35:48.260
如果说你写的是一个函数

35:48.260 --> 35:49.260
我们刚才说了

35:50.260 --> 35:51.260
到时候

35:51.260 --> 35:52.260
我们加数据的时候

35:52.260 --> 35:53.260
我添加一篇新闻

35:54.260 --> 35:55.260
注意听

35:55.260 --> 35:57.260
这里是个非常非常细的地方

35:57.260 --> 35:59.260
我添加一篇新闻的时候

36:00.260 --> 36:02.260
由于它是一个函数

36:02.260 --> 36:03.260
它是不是会调用函数

36:03.260 --> 36:06.260
取出当时添加的时候那个时间

36:07.260 --> 36:08.260
添加的时候

36:08.260 --> 36:09.260
它会是不是调用这个函数

36:09.260 --> 36:11.260
你调用了是不是当时那个时间

36:11.260 --> 36:12.260
添加新闻的时间

36:13.260 --> 36:15.260
但是如果说你其实这样子写的

36:16.260 --> 36:17.260
那么这个时间是什么时间

36:17.260 --> 36:18.260
是添加新闻的时间吗

36:18.260 --> 36:19.260
不是

36:20.260 --> 36:22.260
是你定义这个模型的时间

36:23.260 --> 36:24.260
定义这个结构的时间

36:24.260 --> 36:25.260
因为定义这个结构

36:25.260 --> 36:26.260
它是个对象

36:26.260 --> 36:27.260
你看

36:27.260 --> 36:28.260
属性名

36:28.260 --> 36:30.260
属性值是不是要算出来

36:30.260 --> 36:31.260
这个时候是不是要算出来

36:31.260 --> 36:32.260
对吧

36:32.260 --> 36:33.260
你来调用函数

36:33.260 --> 36:34.260
它必须要算出来

36:34.260 --> 36:35.260
那么就相当于是你把这个

36:35.260 --> 36:37.260
固定的就是定义模型那个时间

36:37.260 --> 36:38.260
放到这儿了

36:39.260 --> 36:40.260
你看这个意思吧

36:40.260 --> 36:42.260
比方说我是今天定义的模型

36:43.260 --> 36:44.260
那么之后

36:44.260 --> 36:45.260
一连之后

36:45.260 --> 36:46.260
我添加新闻的时候

36:46.260 --> 36:48.260
它仍然使用的是这个

36:48.260 --> 36:50.260
我之前定义的时候那个时间点

36:50.260 --> 36:52.260
作为默认的时间

36:53.260 --> 36:54.260
看这个意思吧

36:54.260 --> 36:55.260
如果说你把它写成函数过后

36:55.260 --> 36:57.260
是不是每一次添加的时候

36:57.260 --> 36:58.260
它是个函数

36:58.260 --> 36:59.260
它必须要调用

36:59.260 --> 37:00.260
所以调用的时候

37:00.260 --> 37:02.260
它每一次添加新闻的时候

37:02.260 --> 37:03.260
写入新闻的时候

37:03.260 --> 37:04.260
没有给它写时间

37:04.260 --> 37:05.260
它就会有个默认值

37:05.260 --> 37:07.260
默认值就是当前时间

37:07.260 --> 37:08.260
这是意思吧

37:12.600 --> 37:13.600
好 下一个

37:13.600 --> 37:15.600
前面表示的是新闻频道

37:16.600 --> 37:17.600
没什么好说的

37:17.600 --> 37:18.600
另一个表示新闻链接

37:18.600 --> 37:19.600
没什么好说的

37:19.600 --> 37:21.600
最后我们定义一个模型

37:21.600 --> 37:22.600
通过这个schema

37:22.600 --> 37:23.600
定义一个模型

37:24.600 --> 37:25.600
没了

37:25.600 --> 37:27.600
你看现在是不是写成这样子了

37:27.600 --> 37:28.600
对不对

37:28.600 --> 37:30.600
我们现在对应的数据库里面

37:30.600 --> 37:32.600
两个模型

37:32.600 --> 37:33.600
一个是优质

37:33.600 --> 37:34.600
一个是news

37:35.600 --> 37:36.600
咱们来运行看一下

37:36.600 --> 37:38.600
虽然现在没有什么

37:38.600 --> 37:39.600
效果

37:39.600 --> 37:40.600
没有什么特别效果

37:40.600 --> 37:41.600
我们来运行看一下

37:41.600 --> 37:42.600
有没有报处吧

37:42.600 --> 37:45.360
没有报处的

37:45.360 --> 37:46.360
说明模型定义成功了

37:46.360 --> 37:48.360
然后我们到个robo3t里面去看一下

37:49.360 --> 37:50.360
我看一下能不能看得出来

37:50.360 --> 37:51.360
有的时候

37:51.360 --> 37:52.360
这个地方看不见

37:52.360 --> 37:54.360
点击右键刷新

37:54.360 --> 37:55.360
右键refresh刷新

37:55.360 --> 37:57.360
你看这里是不是多了一个数据库

37:57.360 --> 37:58.360
test

37:58.360 --> 37:59.360
然后展开

37:59.360 --> 38:00.360
可乐一个形式

38:00.360 --> 38:01.360
可乐一个形式

38:01.360 --> 38:02.360
为什么只有一个

38:02.360 --> 38:03.360
这个东西

38:03.360 --> 38:04.360
不用去管它

38:04.360 --> 38:05.360
因为我这个

38:05.360 --> 38:07.360
两个集合里面都没有加东西

38:07.360 --> 38:09.360
没有往里面加东西

38:09.360 --> 38:10.360
所以说

38:10.360 --> 38:11.360
它有些模型

38:11.360 --> 38:12.360
它没有出来

38:12.360 --> 38:13.360
有些集合没有出来

38:13.360 --> 38:14.360
那么这个东西

38:14.360 --> 38:15.360
到底哪个模型出来

38:15.360 --> 38:16.360
到底哪个模型不出来

38:16.360 --> 38:17.360
我们不用去升级

38:17.360 --> 38:18.360
不用去升级

38:18.360 --> 38:20.360
一般我们往里面加了数据过后

38:20.360 --> 38:21.360
它都看得见

38:22.360 --> 38:23.360
我们目前可以看到

38:23.360 --> 38:24.360
我们这里面是不是有了个news

38:24.360 --> 38:25.360
对吧

38:25.360 --> 38:26.360
news看不见

38:26.360 --> 38:27.360
可能跟它的名字有关系

38:27.360 --> 38:28.360
因为它要用复数

38:28.360 --> 38:29.360
我们这里已经是复数了

38:29.360 --> 38:30.360
可能跟它这个一关系

38:30.360 --> 38:31.360
不过不用管

38:31.360 --> 38:33.360
我们一会儿往里面加了数据过后

38:33.360 --> 38:34.360
它一定看得见

38:34.360 --> 38:36.360
我们一会儿去操作的时候

38:36.360 --> 38:37.360
怎么操作的

38:37.360 --> 38:39.360
操作数据库时

38:40.360 --> 38:43.360
使用模型进行操作

38:43.360 --> 38:44.360
哪个模型

38:44.360 --> 38:45.360
news

38:45.360 --> 38:46.360
和什么呢

38:46.360 --> 38:47.360
news

38:47.360 --> 38:49.360
用这两个模型进行操作

38:49.360 --> 38:50.360
对不对

38:50.360 --> 38:51.360
所以我们后续

38:51.360 --> 38:52.360
由于我们后续的操作

38:52.360 --> 38:53.360
只需要用它的模型

38:53.360 --> 38:54.360
因此

38:54.360 --> 38:55.360
这个代码

38:55.360 --> 38:56.360
我们要需要把它

38:56.360 --> 38:57.360
稍微的

38:57.360 --> 38:58.360
分开一下

38:59.360 --> 39:00.360
比方说

39:00.360 --> 39:01.360
这里是一个连接

39:01.360 --> 39:03.360
可以单独做一个模块

39:03.360 --> 39:05.360
这里是定义一个用户

39:05.360 --> 39:06.360
单独做一个模块

39:06.360 --> 39:08.360
这里是定义一个新闻

39:08.360 --> 39:09.360
单独做一个模块

39:09.360 --> 39:10.360
对吧

39:10.360 --> 39:11.360
最终我只需要把这个

39:11.360 --> 39:12.360
news导出

39:12.360 --> 39:13.360
这个news导出就完成了

39:13.360 --> 39:14.360
我们接下来

39:14.360 --> 39:15.360
分模块来说些

39:15.360 --> 39:16.360
我们在这里

39:16.360 --> 39:17.360
可以建立一个文件夹

39:17.360 --> 39:19.360
给它取名为models

39:19.360 --> 39:20.360
我的模型

39:20.360 --> 39:22.360
模型全部定义在这

39:22.360 --> 39:23.360
这里边

39:23.360 --> 39:24.360
给它新创建一个文件

39:24.360 --> 39:25.360
给它取个名字

39:25.360 --> 39:26.360
要做create

39:26.360 --> 39:27.360
connection

39:29.360 --> 39:31.360
表示创建连接

39:31.360 --> 39:33.360
这个地方是创建连接

39:34.360 --> 39:35.360
好

39:35.360 --> 39:36.360
来吧

39:36.360 --> 39:37.360
我们把之前的这个地方

39:38.360 --> 39:39.360
剪接

39:39.360 --> 39:40.360
展开过来

39:40.360 --> 39:41.360
创建连接

39:41.360 --> 39:42.360
创建连接

39:42.360 --> 39:43.360
需不需要导出

39:43.360 --> 39:44.360
什么东西呢

39:44.360 --> 39:45.360
不需要导出任何东西

39:45.360 --> 39:46.360
因为我们之前说过

39:46.360 --> 39:47.360
连接

39:47.360 --> 39:48.360
只需要够执行一遍

39:48.360 --> 39:49.360
就完成了

39:49.360 --> 39:50.360
你只需要执行一遍

39:50.360 --> 39:51.360
就完成了

39:51.360 --> 39:52.360
不需要做任何其他事情

39:52.360 --> 39:53.360
连接的东西

39:53.360 --> 39:54.360
就能写成一个模块

39:54.360 --> 39:55.360
然后

39:55.360 --> 39:56.360
现在我们再新建个文件

39:56.360 --> 39:57.360
给它取个名字

39:57.360 --> 39:58.360
叫User

39:58.360 --> 39:59.360
叫JS

39:59.360 --> 40:00.360
好

40:00.360 --> 40:01.360
那么这个地方

40:01.360 --> 40:02.360
我们做什么呢

40:02.360 --> 40:03.360
就定义

40:03.360 --> 40:04.360
用户的模型

40:04.360 --> 40:05.360
好

40:05.360 --> 40:06.360
那么这里

40:06.360 --> 40:07.360
我们把它复制一下

40:08.360 --> 40:09.360
剪接

40:09.360 --> 40:10.360
粘贴

40:10.360 --> 40:11.360
好

40:11.360 --> 40:12.360
刚才过来过来

40:12.360 --> 40:13.360
这里边需要用到一个mongoose

40:13.360 --> 40:14.360
这里边没有

40:14.360 --> 40:15.360
没有的话

40:15.360 --> 40:19.590
我们导入进来

40:19.590 --> 40:20.590
mongoose

40:20.590 --> 40:21.590
那么我问一下

40:21.590 --> 40:22.590
大家这个问题

40:22.590 --> 40:23.590
你看

40:23.590 --> 40:25.590
新的问题又来了

40:25.590 --> 40:27.590
我这里导入了一次mongoose

40:27.590 --> 40:29.590
我这边也导入了一次mongoose

40:29.590 --> 40:30.590
会不会导致

40:30.590 --> 40:32.590
这个第三方库执行两次

40:33.590 --> 40:34.590
会不会导致

40:34.590 --> 40:36.590
这个第三方库执行两次

40:37.590 --> 40:38.590
这不会

40:38.590 --> 40:39.590
昨天讲的这个

40:39.590 --> 40:40.590
有缓存

40:40.590 --> 40:41.590
对不对

40:41.590 --> 40:42.590
所以它只需要

40:42.590 --> 40:43.590
只会执行一次

40:43.590 --> 40:44.590
不用担心

40:44.590 --> 40:45.590
好

40:45.590 --> 40:46.590
然后再来一个

40:46.590 --> 40:47.590
我们这里的一个nose

40:47.590 --> 40:48.590
今天过后

40:48.590 --> 40:49.590
我们每天写的代码

40:49.590 --> 40:50.590
大家下来

40:50.590 --> 40:51.590
一定要去自己写一遍

40:51.590 --> 40:52.590
一定要自己去写一遍

40:52.590 --> 40:54.590
不要认为很简单

40:54.590 --> 40:55.590
你自己写出来再刷

40:55.590 --> 40:57.590
然后我们这里呢

40:57.590 --> 40:58.590
咱们过来

40:58.590 --> 41:02.160
这里我们得到mongoose

41:02.160 --> 41:03.160
require

41:04.160 --> 41:05.160
mongoose

41:07.160 --> 41:08.160
好

41:08.160 --> 41:09.160
那么现在呢

41:09.160 --> 41:10.160
一屋这儿和六十是不是没有导出

41:10.160 --> 41:11.160
对不对

41:11.160 --> 41:12.160
是不是没有导出

41:12.160 --> 41:13.160
对不对

41:13.160 --> 41:14.160
那么我们怎么来导出呢

41:14.160 --> 41:15.160
因为我们

41:15.160 --> 41:16.160
我们希望

41:16.160 --> 41:17.160
把这个模型

41:17.160 --> 41:19.160
提供给外面使用

41:19.160 --> 41:20.160
像这些结构你不用了

41:20.160 --> 41:22.160
你只需要用我的模型

41:22.160 --> 41:23.160
就行了

41:23.160 --> 41:24.160
因为我们后边操作的权

41:24.160 --> 41:25.160
是模型

41:25.160 --> 41:26.160
那么我们这里用这种方式

41:26.160 --> 41:27.160
来导出

41:27.160 --> 41:28.160
比如说用murge.export

41:28.160 --> 41:29.160
对吧

41:29.160 --> 41:31.160
是把定义的模型

41:31.160 --> 41:33.160
这个表达是个返回结构

41:33.160 --> 41:34.160
导出

41:34.160 --> 41:35.160
就完事了

41:35.160 --> 41:36.160
六十也是一样

41:36.160 --> 41:37.160
在这个地方

41:37.160 --> 41:38.160
我们写上一个

41:38.160 --> 41:39.160
murge.export

41:39.160 --> 41:40.160
对吧

41:40.160 --> 41:41.160
那复制

41:41.160 --> 41:42.160
把导出就完事了

41:42.160 --> 41:43.160
我们昨天学了的

41:43.160 --> 41:44.160
好

41:44.160 --> 41:45.160
为了让后边的使用前

41:45.160 --> 41:46.160
更加方便呢

41:46.160 --> 41:47.160
你看我这里

41:47.160 --> 41:48.160
是不是一会儿

41:48.160 --> 41:49.160
别人要用的时候

41:49.160 --> 41:50.160
要导入六十

41:50.160 --> 41:52.160
用这个新闻模型

41:52.160 --> 41:53.160
要导入这个user

41:53.160 --> 41:54.160
用这个用户模型

41:54.160 --> 41:55.160
就有点麻烦

41:55.160 --> 41:56.160
对不对

41:56.160 --> 41:57.160
所以说

41:57.160 --> 41:58.160
我们在开发的时候

41:58.160 --> 41:59.160
通常会进行下汇总

41:59.160 --> 42:00.160
我们在这里

42:00.160 --> 42:01.160
新建个文件

42:01.160 --> 42:02.160
叫index.js

42:02.160 --> 42:04.160
表示个默认文件

42:04.160 --> 42:06.160
你要用我这个模型里面的东西

42:06.160 --> 42:08.160
你只需要导入这个就行了

42:08.160 --> 42:09.160
那我这个文件怎么写呢

42:09.160 --> 42:10.160
这是一些常见的开发方式

42:10.160 --> 42:12.160
我也交给大家

42:12.160 --> 42:13.160
这里面怎么写呢

42:13.160 --> 42:14.160
首先

42:14.160 --> 42:15.160
我这里的模型里面

42:15.160 --> 42:16.160
肯定要创建连接

42:16.160 --> 42:17.160
对不对

42:17.160 --> 42:18.160
所以说

42:18.160 --> 42:19.160
我肯定要去执行一下连接

42:19.160 --> 42:20.160
所以扛一个型

42:20.160 --> 42:22.160
对吧

42:22.160 --> 42:23.160
执行一次

42:24.160 --> 42:25.160
连接

42:25.160 --> 42:27.160
连接就只需要执行一次就完事了

42:27.160 --> 42:28.160
然后接下来

42:28.160 --> 42:29.160
我要导出

42:29.160 --> 42:30.160
导出两个东西

42:30.160 --> 42:32.160
一个是导出一个news

42:34.160 --> 42:35.160
news来自于哪呢

42:35.160 --> 42:36.160
来自于

42:36.160 --> 42:39.160
我这边导入的news

42:39.160 --> 42:40.160
有些朋友看不懂了

42:40.160 --> 42:41.160
那你这样子吧

42:41.160 --> 42:43.160
我这里可以导入这个news

42:43.160 --> 42:45.160
你这里不是导出了的吗

42:45.160 --> 42:46.160
导出一个news的模型

42:46.160 --> 42:48.160
那我这里是不是可以导入

42:48.160 --> 42:50.160
对不对

42:50.160 --> 42:51.160
导入过后

42:51.160 --> 42:53.160
把这个导入的结果再导出

42:53.160 --> 42:54.160
再作为这个模型的导出

42:54.160 --> 42:55.160
不一样吗

42:55.160 --> 42:56.160
对不对

42:56.160 --> 42:57.160
不一样的吗

42:57.160 --> 42:58.160
你这样子写跟这样子写一啥去

42:58.160 --> 42:59.160
表达是吗

43:00.160 --> 43:01.160
那么我这里就是什么

43:01.160 --> 43:03.160
我导出一个news

43:03.160 --> 43:04.160
那么这里呢

43:04.160 --> 43:05.160
news来自于哪呢

43:05.160 --> 43:06.160
来自于这个模型

43:06.160 --> 43:10.160
我再导出一个user

43:10.160 --> 43:11.160
require

43:11.160 --> 43:13.160
来自于这个模型

43:13.160 --> 43:14.160
你看

43:14.160 --> 43:15.160
这是我们常见的

43:15.160 --> 43:17.160
在开发漏的程序的时候

43:17.160 --> 43:18.160
包括不仅是漏的程序

43:18.160 --> 43:20.160
包括一些别的

43:20.160 --> 43:21.160
这种模块化的应用程序

43:21.160 --> 43:23.160
我们都可以用这种方式

43:23.160 --> 43:24.160
就是我这文件夹里边

43:24.160 --> 43:25.160
有很多很多的地方

43:25.160 --> 43:26.160
要使用

43:26.160 --> 43:28.160
也就是要做了很多事情

43:28.160 --> 43:29.160
有很多别的模块

43:29.160 --> 43:31.160
但是我提供给外面的

43:31.160 --> 43:32.160
只有这个index的解释

43:32.160 --> 43:34.160
别人只需要通过这个东西

43:34.160 --> 43:35.160
可以使用的

43:35.160 --> 43:36.160
好 那么别人怎么用呢

43:36.160 --> 43:37.160
比方说我们在这里

43:37.160 --> 43:38.160
要用的时候呢

43:38.160 --> 43:39.160
怎么来用

43:39.160 --> 43:41.160
我们就可以require

43:41.160 --> 43:42.160
models

43:42.160 --> 43:43.160
我们说过

43:43.160 --> 43:44.160
如果说这是个文件夹

43:44.160 --> 43:45.160
他默认会读取什么

43:45.160 --> 43:47.160
读取index的解释

43:47.160 --> 43:48.160
导入的是什么

43:48.160 --> 43:49.160
导入的是index的解释

43:49.160 --> 43:50.160
那么导入的结果是什么呢

43:50.160 --> 43:52.160
就是一个对象

43:52.160 --> 43:54.160
是不是可以对象

43:54.160 --> 43:55.160
对吧

43:55.160 --> 43:57.160
models里边有什么呢

43:57.160 --> 43:58.160
有油字

43:58.160 --> 43:59.160
对吧

43:59.160 --> 44:00.160
对象里面导出一个油字

44:00.160 --> 44:01.160
导出了一个nil

44:01.160 --> 44:02.160
跟昨天选择的导出

44:02.160 --> 44:03.160
a和b是不是一样的

44:03.160 --> 44:04.160
这里写个a 这里写个b

44:04.160 --> 44:05.160
是一样的道理

44:05.160 --> 44:07.160
只要昨天一选择就丢了

44:07.160 --> 44:08.160
明白了意思吧

44:08.160 --> 44:09.160
那么我们可以通过这个models

44:09.160 --> 44:10.160
点nil字

44:10.160 --> 44:11.160
获取到新闻模型

44:11.160 --> 44:13.160
油字 获取到用户模型

44:13.160 --> 44:14.160
这是一种常见的台湾方式

44:14.160 --> 44:15.160
没问题吧

44:20.980 --> 44:21.980
好 咱们继续

44:22.980 --> 44:24.980
好 接下来就是正常了

44:24.980 --> 44:26.980
正常就是咱们的CRUD

44:26.980 --> 44:28.980
我们现在有了连接

44:28.980 --> 44:30.980
有了模型

44:30.980 --> 44:31.980
那么接下来呢

44:31.980 --> 44:33.980
就是对模型进行操作了

44:33.980 --> 44:35.980
操作的方式呢

44:35.980 --> 44:37.980
无外乎就是这么适用

44:37.980 --> 44:39.980
增商改查

44:39.980 --> 44:41.980
在咱们开发领域里边

44:41.980 --> 44:43.980
它叫做CRUD

44:43.980 --> 44:44.980
CRUD

44:44.980 --> 44:45.980
C什么意思

44:45.980 --> 44:46.980
creed

44:46.980 --> 44:47.980
创建

44:47.980 --> 44:48.980
retreat

44:48.980 --> 44:49.980
读取

44:49.980 --> 44:50.980
dead

44:50.980 --> 44:51.980
修改

44:51.980 --> 44:52.980
dead

44:52.980 --> 44:53.980
删除

44:53.980 --> 44:54.980
你看我们对数据的操作

44:54.980 --> 44:55.980
无非就是这么适用

44:55.980 --> 44:56.980
对不对

44:56.980 --> 44:57.980
增商改查

44:57.980 --> 44:58.980
我们一个一个说

44:58.980 --> 45:00.980
首先说新增

45:00.980 --> 45:03.980
我们怎么来新增一个对象

45:03.980 --> 45:05.980
我们写法非常简单

45:05.980 --> 45:06.980
得到它的模型

45:06.980 --> 45:08.980
然后交了一个函数叫cred

45:08.980 --> 45:10.980
那么这里边可以传一个对象

45:10.980 --> 45:11.980
可以传一个对象的数组

45:11.980 --> 45:14.980
就是新增一个和多个的区别

45:14.980 --> 45:15.980
好 咱们来看一下吧

45:15.980 --> 45:16.980
怎么来用

45:16.980 --> 45:18.980
比方说我们要新增一个用户

45:18.980 --> 45:19.980
models

45:19.980 --> 45:20.980
里边个模型叫什么

45:20.980 --> 45:21.980
user

45:21.980 --> 45:22.980
拿到模型

45:22.980 --> 45:23.980
然后我们使用什么

45:23.980 --> 45:24.980
create

45:24.980 --> 45:25.980
创建一个用户

45:25.980 --> 45:26.980
那这里边写啥呢

45:26.980 --> 45:27.980
表冲的一个用户

45:27.980 --> 45:29.980
那一个用户就是个对象

45:29.980 --> 45:31.980
一个用户就是个对象

45:31.980 --> 45:33.980
好 用户对象里边有哪些东西

45:33.980 --> 45:35.980
有什么logging id

45:35.980 --> 45:37.980
有什么abc

45:37.980 --> 45:40.980
logging password

45:40.980 --> 45:43.980
123123

45:43.980 --> 45:44.980
还有什么呢

45:44.980 --> 45:45.980
name

45:45.980 --> 45:46.980
name

45:46.980 --> 45:47.980
model

45:47.980 --> 45:48.980
还有什么呢

45:48.980 --> 45:50.980
还有ag

45:50.980 --> 45:51.980
model

45:51.980 --> 45:52.980
18岁

45:52.980 --> 45:54.980
还有啥呢

45:54.980 --> 45:55.980
还有啥呢

45:55.980 --> 45:56.980
先不管还有啥吧

45:56.980 --> 45:59.980
咱们这样子是不是写完了

45:59.980 --> 46:01.980
好 写完了过后呢

46:01.980 --> 46:03.980
我们需要有两种方式

46:03.980 --> 46:05.980
因为它这个地方是异部的

46:05.980 --> 46:06.980
什么叫异部

46:06.980 --> 46:08.980
你可以这样想想

46:08.980 --> 46:10.980
我要创建一个用户

46:10.980 --> 46:12.980
逻辑上来说的话

46:12.980 --> 46:14.980
那么这里的逻辑好像是没问题了

46:14.980 --> 46:15.980
但是它有意是异部的

46:15.980 --> 46:16.980
所以我这里要单独说明一下

46:16.980 --> 46:19.980
首先为什么它是异部的

46:19.980 --> 46:21.980
因为从技术上来说

46:21.980 --> 46:25.980
我们这里是运行的在内存里边的一个数据

46:25.980 --> 46:26.980
这是内存里边的对象

46:26.980 --> 46:28.980
它最重要到哪儿去呢

46:28.980 --> 46:30.980
最重要到硬盘里边去

46:30.980 --> 46:31.980
是吧 持盘里边去

46:31.980 --> 46:33.980
进入到数据户里边

46:33.980 --> 46:34.980
那么我们可以想象

46:34.980 --> 46:36.980
硬盘的速度要快

46:36.980 --> 46:38.980
还是内存的速度快

46:38.980 --> 46:40.980
这肯定是内存 对不对

46:40.980 --> 46:41.980
肯定是内存的速度

46:41.980 --> 46:44.980
要比持盘的速度要快的很多

46:44.980 --> 46:46.980
所以内存为什么那么贵呢

46:46.980 --> 46:48.980
硬盘就是持盘为什么那么便宜呢

46:48.980 --> 46:49.980
对不对

46:49.980 --> 46:52.980
硬盘就是我们的内存的速度要快很多

46:52.980 --> 46:54.980
因为它持盘它拖慢了这个速度

46:54.980 --> 46:56.980
你可以夸张一点想

46:56.980 --> 46:58.980
就假设我们这个内存的代码

46:58.980 --> 47:00.980
很快就运行结束了

47:00.980 --> 47:02.980
但是它把它写到持盘里边去

47:02.980 --> 47:03.980
可能要一个小时

47:03.980 --> 47:04.980
说了一点夸张

47:04.980 --> 47:06.980
可能几毫秒就完事了

47:06.980 --> 47:07.980
但是我们说夸张一点

47:07.980 --> 47:08.980
大家好理解

47:08.980 --> 47:10.980
就是这句代码它真的要把它执行完成

47:10.980 --> 47:11.980
是不是要一个小时

47:11.980 --> 47:13.980
我们这样子说夸张一点

47:13.980 --> 47:15.980
如果说它不把它做成一步的

47:15.980 --> 47:16.980
会导致一个什么问题呢

47:16.980 --> 47:18.980
它会导致后边代码运行不了了

47:18.980 --> 47:20.980
就整个程序卡住了

47:20.980 --> 47:22.980
后边代码没法运行了

47:22.980 --> 47:24.980
如果说它是同步的

47:24.980 --> 47:27.980
那么会导致后边代码无法运行

47:27.980 --> 47:29.980
无法运行

47:29.980 --> 47:31.980
没什么意思吧

47:31.980 --> 47:33.980
所以说它不能把它做成同步的

47:33.980 --> 47:34.980
那怎么办呢

47:34.980 --> 47:35.980
还会把它做成一步的

47:35.980 --> 47:37.980
就说你给我发一个命令

47:37.980 --> 47:38.980
我要去创建一个用户

47:38.980 --> 47:39.980
用户的信息呢

47:39.980 --> 47:40.980
在这

47:40.980 --> 47:41.980
这是用户的信息

47:41.980 --> 47:44.980
当我创建完成之后

47:44.980 --> 47:45.980
该干嘛呢

47:45.980 --> 47:47.980
那么这是个异部的操作

47:47.980 --> 47:48.980
异部的操作呢

47:48.980 --> 47:49.980
这里有两种写法

47:49.980 --> 47:51.980
它支持两种写法

47:51.980 --> 47:53.980
第一种写法写回调函数

47:53.980 --> 47:55.980
第二个函数写个回调函数

47:55.980 --> 48:00.300
就跟那个你们驻车事件是一样的

48:00.300 --> 48:01.300
当什么什么的时候

48:01.300 --> 48:03.300
我要去做什么什么的事

48:03.300 --> 48:05.300
当它创建完成之后

48:05.300 --> 48:07.300
我要去运行这个回调函数

48:07.300 --> 48:09.300
我们这里说出

48:09.300 --> 48:11.300
创建完成

48:12.300 --> 48:14.300
这个回调函数里边有两个参数

48:14.300 --> 48:15.300
第一个参数是

48:15.300 --> 48:18.300
表示创建的过程中有没有错误

48:18.300 --> 48:20.300
第二个参数是

48:20.300 --> 48:22.300
创建如果说没有错误

48:22.300 --> 48:24.300
创建成功之后

48:24.300 --> 48:25.300
它成功

48:25.300 --> 48:27.300
你不是创建一个用户吗

48:27.300 --> 48:29.300
那么成功那个用户对象是啥

48:29.300 --> 48:30.300
咱们呢

48:30.300 --> 48:31.300
为兆子

48:31.300 --> 48:33.300
我们这里可以这样子写

48:33.300 --> 48:35.300
判断一下

48:35.300 --> 48:37.300
有没有错误

48:37.300 --> 48:39.300
如果说有错误的话

48:40.300 --> 48:41.300
如果说有错误的话

48:41.300 --> 48:43.300
我们输出错误

48:43.300 --> 48:44.300
要是

48:44.300 --> 48:45.300
如果说没有错误的话

48:45.300 --> 48:47.300
我们就输出

48:48.300 --> 48:49.300
对象

48:49.300 --> 48:50.300
这就是创建一个用户

48:50.300 --> 48:51.300
咱们来看一下吧

48:51.300 --> 48:52.300
创建一个用户

48:52.300 --> 48:54.300
把用户用相传给你

48:54.300 --> 48:56.300
然后如果说你创建成功了

48:56.300 --> 48:57.300
如果说有错误就输出错误

48:57.300 --> 48:58.300
如果说没有错误

48:58.300 --> 48:59.300
创建成功

48:59.300 --> 49:00.300
我就把成功的对象输出

49:00.300 --> 49:01.300
咱们来运行看一下

49:02.300 --> 49:03.300
在停止

49:04.300 --> 49:06.300
漏的

49:06.300 --> 49:07.300
来吧

49:08.300 --> 49:09.300
好

49:09.300 --> 49:10.300
这里就暴涂了

49:10.300 --> 49:11.300
暴涂了说说明啥

49:11.300 --> 49:12.300
所以有错误

49:12.300 --> 49:13.300
有错误

49:13.300 --> 49:14.300
看一下什么错误

49:14.300 --> 49:15.300
那么他这里告诉你

49:15.300 --> 49:16.300
Vanidation

49:16.300 --> 49:17.300
你要学会看错误

49:17.300 --> 49:19.300
Vanidation error

49:19.300 --> 49:20.300
要什么意思

49:20.300 --> 49:21.300
验证错误

49:21.300 --> 49:22.300
怎么要验证错误

49:22.300 --> 49:23.300
刚才我定义模型的时候

49:23.300 --> 49:25.300
不是用乱七八道的大对规则吗

49:25.300 --> 49:26.300
对不对

49:26.300 --> 49:27.300
所以有规则

49:27.300 --> 49:29.300
那么这里是不是规则验证实办

49:29.300 --> 49:30.300
他告诉你什么

49:30.300 --> 49:32.300
Row is required

49:32.300 --> 49:34.300
之前有个用户角色

49:34.300 --> 49:35.300
用户角色

49:35.300 --> 49:37.300
他必须是这三个东东的一个

49:37.300 --> 49:38.300
但是我没有写用户角色

49:38.300 --> 49:39.300
所以他验证实办了

49:39.300 --> 49:41.300
因为他这里有个required to

49:41.300 --> 49:42.300
必须要填写

49:42.300 --> 49:44.300
所以我们这里也更改一下

49:44.300 --> 49:45.300
改成什么呢

49:45.300 --> 49:46.300
再加一个属性

49:46.300 --> 49:47.300
Row

49:48.300 --> 49:50.300
比方说普通用户

49:51.300 --> 49:52.300
保存

49:52.300 --> 49:54.300
接下来再停止

49:57.630 --> 49:58.630
Row的Index

49:59.630 --> 50:00.630
好

50:00.630 --> 50:01.630
那么这个时候成功了

50:01.630 --> 50:03.630
成功之后你可看到

50:03.630 --> 50:05.630
那么是不是拿到这个用户对象了

50:05.630 --> 50:06.630
对吧

50:06.630 --> 50:07.630
Login ID

50:07.630 --> 50:08.630
Login Password

50:08.630 --> 50:09.630
Name

50:09.630 --> 50:10.630
Age

50:10.630 --> 50:11.630
Row

50:11.630 --> 50:12.630
对不对

50:12.630 --> 50:13.630
还有多少两个属性

50:13.630 --> 50:14.630
我们一会再说

50:14.630 --> 50:15.630
是不是拿到个用户对象了

50:15.630 --> 50:17.630
表示新创建用户成功了

50:17.630 --> 50:19.630
这是自动写法

50:19.630 --> 50:21.630
还有另外一种写法

50:21.630 --> 50:23.630
这是我们今天晚上必须要学会的

50:23.630 --> 50:24.630
这种写法比较好理解

50:24.630 --> 50:26.630
但是写起来的比较恶心

50:26.630 --> 50:27.630
还有另外一种写法

50:28.630 --> 50:29.630
另外一种写法

50:29.630 --> 50:32.630
需要用到ES7的东西

50:32.630 --> 50:34.630
有一点黄老师

50:34.630 --> 50:35.630
怎么来ES7了

50:35.630 --> 50:36.630
不要怕

50:36.630 --> 50:38.630
我这里没有办法给你去详细的解释

50:38.630 --> 50:40.630
它到底是怎么回事

50:40.630 --> 50:42.630
但是我可以让你汇用

50:42.630 --> 50:44.630
可以让你汇起

50:44.630 --> 50:45.630
就是啥意思呢

50:45.630 --> 50:47.630
Mangus还支持新版本

50:47.630 --> 50:51.390
就是ES7的语法

50:51.390 --> 50:52.390
写法一样

50:52.390 --> 50:53.390
Prince

50:53.390 --> 50:55.390
还是创建一个用户

50:57.830 --> 50:58.830
还是创建一个用户

50:58.830 --> 51:05.560
复制一下

51:08.900 --> 51:09.900
创建一个用户

51:09.900 --> 51:11.900
那么这个是不是要等一会

51:11.900 --> 51:12.900
对吧

51:12.900 --> 51:13.900
它要等一会才能执行完成

51:13.900 --> 51:16.900
所以说它遇到这种要等一会的地方

51:16.900 --> 51:17.900
ES7里边

51:17.900 --> 51:19.900
它允许你使用一个关键字

51:19.900 --> 51:21.900
叫做await

51:22.900 --> 51:23.900
去等它

51:24.900 --> 51:25.900
你不是要等吗

51:25.900 --> 51:26.900
我就等你

51:26.900 --> 51:27.900
通过这个关键字

51:27.900 --> 51:28.900
我就可以等它完成

51:29.900 --> 51:31.900
那你要去拯救这个关键字

51:31.900 --> 51:32.900
到底是怎么回事

51:32.900 --> 51:34.900
那还得要去看一些ES

51:34.900 --> 51:36.900
首先得要学习ES6的Promise

51:36.900 --> 51:37.900
Promise搞清楚

51:37.900 --> 51:39.900
搞清楚Promise过后

51:39.900 --> 51:41.900
你才知道这个await是到底什么意思

51:41.900 --> 51:42.900
它要等一会

51:42.900 --> 51:43.900
它要等一会

51:43.900 --> 51:44.900
等一会才能完成

51:44.900 --> 51:45.900
那么我就可以在前面加上

51:45.900 --> 51:46.900
一个关键字await

51:47.900 --> 51:48.900
有了关键字过后

51:48.900 --> 51:49.900
那么这个函数

51:49.900 --> 51:51.900
当它等了完成之后

51:52.900 --> 51:54.900
它会返回一个结果

51:54.900 --> 51:55.900
会返回一个结果

51:55.900 --> 51:57.900
我们可以用个电量来接收一下

51:57.900 --> 51:58.900
result

51:59.900 --> 52:00.900
如果说它完成了过后

52:00.900 --> 52:01.900
它不是要等吗

52:01.900 --> 52:02.900
我就等它

52:02.900 --> 52:03.900
等它的完成

52:03.900 --> 52:04.900
完成了之后

52:04.900 --> 52:05.900
它会把完成的时候

52:05.900 --> 52:06.900
这个结果

52:06.900 --> 52:07.900
这个result

52:07.900 --> 52:08.900
看这

52:08.900 --> 52:09.900
回掉函数

52:09.900 --> 52:10.900
一个result

52:10.900 --> 52:11.900
复制过来

52:11.900 --> 52:12.900
它就不用写回掉函数了

52:12.900 --> 52:13.900
它就写放了

52:13.900 --> 52:14.900
跟以前的同步代

52:14.900 --> 52:15.900
差不多了

52:15.900 --> 52:16.900
没了意思吧

52:17.900 --> 52:18.900
但是

52:18.900 --> 52:19.900
而wait的关键字

52:19.900 --> 52:21.900
是必须要出现站

52:21.900 --> 52:23.900
await关键字

52:24.900 --> 52:26.900
必须要出现站

52:26.900 --> 52:27.900
标记为

52:27.900 --> 52:29.900
而sync的函数中

52:30.900 --> 52:31.900
就说你这样子运行

52:31.900 --> 52:32.900
是不是行

52:32.900 --> 52:33.900
你这样运行

52:33.900 --> 52:34.900
它要包错的

52:34.900 --> 52:35.900
我们这里运行一下

52:36.900 --> 52:37.900
no in this

52:39.900 --> 52:40.900
对了

52:40.900 --> 52:41.900
它是不是冒脱了

52:41.900 --> 52:42.900
语法都不正确了

52:42.900 --> 52:44.900
syntax error

52:44.900 --> 52:45.900
所以语法错误

52:45.900 --> 52:46.900
语法都不正确了

52:46.900 --> 52:47.900
因为这个而wait关键字

52:47.900 --> 52:49.900
是不能直接使用的

52:49.900 --> 52:50.900
它必须要放到一个

52:50.900 --> 52:51.900
而sync函数中

52:51.900 --> 52:52.900
那么我们这里怎么写呢

52:52.900 --> 52:53.900
就要这样子写

52:53.900 --> 52:55.900
要把它包到一个函数中

52:55.900 --> 52:57.900
只要我们这里写个test

52:57.900 --> 52:59.900
一个测试函数

52:59.900 --> 53:01.900
只要你在函数前边

53:01.900 --> 53:03.900
加上一个而sync

53:03.900 --> 53:04.900
只要你在函数前边

53:04.900 --> 53:05.900
加上一个而sync

53:05.900 --> 53:06.900
那么就可以了

53:06.900 --> 53:08.900
那么在这个函数里边

53:08.900 --> 53:09.900
就可以使用这个而wait了

53:10.900 --> 53:11.900
创建一个用户

53:11.900 --> 53:12.900
然后呢

53:12.900 --> 53:13.900
把用户传进去等

53:13.900 --> 53:14.900
等它完成

53:14.900 --> 53:15.900
完成之后

53:15.900 --> 53:16.900
它会给我

53:16.900 --> 53:18.900
把这个用户结果给我result

53:18.900 --> 53:19.900
我们这里输出

53:19.900 --> 53:20.900
result

53:20.900 --> 53:21.900
对了

53:21.900 --> 53:23.900
我们这里去调用一下这个test

53:23.900 --> 53:24.900
不就是有运行这个函数吗

53:24.900 --> 53:25.900
调用这个函数test

53:25.900 --> 53:26.900
那么就可以正常执行了

53:26.900 --> 53:27.900
好

53:27.900 --> 53:28.900
咱们来看一下

53:30.900 --> 53:31.900
我们可以看一下

53:31.900 --> 53:32.900
刚才我们在Robot里边

53:32.900 --> 53:33.900
你看

53:33.900 --> 53:34.900
双击打开

53:34.900 --> 53:35.900
这里说有一个

53:35.900 --> 53:36.900
有一个文档了

53:36.900 --> 53:37.900
刚才我们加了一个

53:37.900 --> 53:38.900
我这里不知道怎么方档

53:38.900 --> 53:39.900
加了一个了

53:39.900 --> 53:41.900
你看这个数据abce123123

53:41.900 --> 53:42.900
model18

53:42.900 --> 53:43.900
普通模糊

53:43.900 --> 53:44.900
对不对

53:44.900 --> 53:45.900
加进去了

53:45.900 --> 53:46.900
一个文档就是一个对象

53:46.900 --> 53:47.900
这就是一篇文档

53:47.900 --> 53:48.900
好

53:48.900 --> 53:49.900
然后我们继续

53:49.900 --> 53:50.900
我们再重新运行

53:50.900 --> 53:51.900
是load index

53:51.900 --> 53:52.900
回头

53:53.900 --> 53:54.900
这里出问题了

53:55.900 --> 53:57.900
它这里验证没有通过

53:57.900 --> 53:58.900
为什么验证没有通过呢

53:58.900 --> 54:00.900
因为这个login id重复了

54:00.900 --> 54:01.900
我们之前讲过

54:01.900 --> 54:02.900
这个地方login id

54:02.900 --> 54:04.900
我们是不是说了一个Ulic

54:04.900 --> 54:05.900
属性值必须为一

54:05.900 --> 54:07.900
那么之前文档里面

54:07.900 --> 54:08.900
一个login id

54:08.900 --> 54:10.900
有了这个login id

54:10.900 --> 54:11.900
是不是不能再写了

54:11.900 --> 54:12.900
我们这里换一个

54:12.900 --> 54:13.900
换一个乘哥

54:17.910 --> 54:18.910
保存

54:18.910 --> 54:19.910
停止

54:19.910 --> 54:20.910
load index

54:20.910 --> 54:21.910
看一下

54:22.910 --> 54:23.910
就可以了

54:23.910 --> 54:24.910
所以又加进去了

54:24.910 --> 54:25.910
效果是一样的

54:26.910 --> 54:28.910
那么像这种情况下

54:28.910 --> 54:29.910
刚才看到了

54:29.910 --> 54:30.910
我们回调函数里边

54:30.910 --> 54:31.910
不是有错误吗

54:31.910 --> 54:32.910
对吧

54:32.910 --> 54:33.910
如果说你验证失败的话

54:33.910 --> 54:34.910
是有错误的

54:34.910 --> 54:35.910
那么这个时候

54:35.910 --> 54:36.910
如果说他有验证失败

54:36.910 --> 54:37.910
他错误在哪呢

54:38.910 --> 54:39.910
错误的话

54:39.910 --> 54:40.910
这种协法的话

54:40.910 --> 54:41.910
如果说你要迫使他的错误

54:41.910 --> 54:42.910
也要这样子写

54:42.910 --> 54:43.910
也要用tracket

54:44.910 --> 54:47.800
要用tracket

54:47.800 --> 54:48.800
tracket大家知道吧

54:48.800 --> 54:49.800
就是捕获错误

54:49.800 --> 54:50.800
对吧

54:50.800 --> 54:51.800
如果他运行过程中

54:51.800 --> 54:52.800
除了错误

54:52.800 --> 54:53.800
你要用这种方式来写

54:53.800 --> 54:55.800
是否脱离到毁掉的模式

54:55.800 --> 54:56.800
他就不用写毁掉函数了

54:56.800 --> 54:57.800
他就像一个

54:57.800 --> 54:58.800
同步代码的样子去输写

54:58.800 --> 54:59.800
你可以对比一下

54:59.800 --> 55:01.800
这是这两个协法

55:01.800 --> 55:02.800
协法上的差异

55:02.800 --> 55:03.800
一是这种协法

55:03.800 --> 55:04.800
一是这种协法

55:04.800 --> 55:05.800
我更加推荐了

55:05.800 --> 55:06.800
大家使用这种协法

55:06.800 --> 55:07.800
尽管原动员

55:07.800 --> 55:08.800
现在目前呢

55:08.800 --> 55:09.800
还不是很清楚

55:09.800 --> 55:10.800
这个东西到底是什么玩意

55:10.800 --> 55:11.800
但是你只要知道

55:11.800 --> 55:12.800
怎么写就行了

55:12.800 --> 55:13.800
你创业用不少等吧

55:13.800 --> 55:14.800
我就等着你呗

55:14.800 --> 55:15.800
等完了过

55:15.800 --> 55:16.800
他就给我一个东西

55:16.800 --> 55:17.800
如果说验证失败

55:17.800 --> 55:18.800
他就会包一个错

55:18.800 --> 55:19.800
得到的错误就完事了

55:19.800 --> 55:20.800
好

55:20.800 --> 55:21.800
停止

55:21.800 --> 55:22.800
我们再看

55:22.800 --> 55:23.800
再load index

55:25.800 --> 55:26.800
那么现在

55:26.800 --> 55:27.800
就运行了这个代码

55:27.800 --> 55:28.800
对吧

55:28.800 --> 55:29.800
现在运行了这个代码

55:29.800 --> 55:30.800
有错误发生了

55:30.800 --> 55:31.800
或者说这个代码

55:31.800 --> 55:32.800
我就不输出这个 error吧

55:32.800 --> 55:33.800
是验证错误

55:33.800 --> 55:34.800
验证

55:34.800 --> 55:35.800
除错

55:36.800 --> 55:37.800
停止

55:37.800 --> 55:38.800
load index

55:40.800 --> 55:41.800
验证除错

55:41.800 --> 55:42.800
对吧

55:42.800 --> 55:43.800
那么这是这一块

55:43.800 --> 55:45.800
如何去添加一个用户

55:46.800 --> 55:47.800
没问题吧

55:47.800 --> 55:53.760
好 接下来

55:56.140 --> 55:58.140
这里我们要在这个地方讲一下

55:58.140 --> 56:00.140
刚才我们添加了用户之后

56:00.140 --> 56:03.140
你会看到新增的这个稳当

56:04.140 --> 56:05.140
重新打开

56:05.140 --> 56:06.140
你看 是不是两面稳当了

56:06.140 --> 56:07.140
新增的稳当里边

56:07.140 --> 56:09.140
你会发现他多了两个属性

56:09.140 --> 56:10.140
一个是这个属性

56:10.140 --> 56:11.140
下滑键

56:11.140 --> 56:12.140
id 这个很重要

56:12.140 --> 56:13.140
大家需要理解的

56:14.140 --> 56:15.140
他是自动生成的

56:16.140 --> 56:19.140
他用于表达这个稳当的组件

56:19.140 --> 56:20.140
我们刚才不是说了

56:20.140 --> 56:21.140
每篇文档都有个组件吗

56:21.140 --> 56:22.140
这是一篇文档

56:22.140 --> 56:23.140
这是一篇文档

56:23.140 --> 56:24.140
每篇文档

56:24.140 --> 56:25.140
他都有个组件

56:25.140 --> 56:26.140
就是一个稳一编号

56:26.140 --> 56:28.140
因为他这些信息都有可能重复

56:28.140 --> 56:29.140
但是呢

56:29.140 --> 56:31.140
稳一编号是绝对不会重复的

56:31.140 --> 56:32.140
你看

56:32.140 --> 56:33.140
他会自动生成两个稳一编号

56:33.140 --> 56:34.140
这两个稳一编号

56:34.140 --> 56:37.140
他本看上去有点像字无创

56:37.140 --> 56:38.140
但是呢

56:38.140 --> 56:39.140
他实际上是个微相

56:39.140 --> 56:41.140
但是我们可以把他当成个字无创

56:41.140 --> 56:44.140
他的对象的类型叫做Object ID

56:44.140 --> 56:46.140
但是我们可以把他当成一个字无创

56:46.140 --> 56:47.140
我们可以看一下吧

56:47.140 --> 56:48.140
点击右键

56:48.140 --> 56:49.140
add some elements

56:49.140 --> 56:51.140
你可以看一下这个字无创

56:51.140 --> 56:55.240
可以看一下

56:55.240 --> 56:56.240
这是他的id

56:56.240 --> 56:58.240
就是他的维一编号

56:58.240 --> 57:00.240
他会保存到一个自动的属性

57:00.240 --> 57:01.240
叫做下滑键 id 里面

57:01.240 --> 57:02.240
他会保存到这

57:02.240 --> 57:04.240
那么这个东西到底是什么玩意

57:04.240 --> 57:06.240
他怎么来保持全税维一的呢

57:06.240 --> 57:08.240
他是根据当前的时间戳

57:08.240 --> 57:09.240
然后呢

57:09.240 --> 57:10.240
根据你电脑的麦克地址

57:10.240 --> 57:11.240
然后呢

57:11.240 --> 57:12.240
根据你当前的进程编号

57:12.240 --> 57:14.240
然后根据一个自征量

57:14.240 --> 57:16.240
根据一套算法

57:16.240 --> 57:20.240
然后保证这个字无创绝对是全球找不到第二个

57:20.240 --> 57:22.240
他每一次生成的东西绝不可能重复

57:22.240 --> 57:24.240
他就是处于这么一个目的

57:24.240 --> 57:25.240
以及通为一种算法

57:25.240 --> 57:26.240
得到这么一个字无创

57:26.240 --> 57:27.240
第二个意思

57:27.240 --> 57:28.240
这就是他生成的维一ID

57:28.240 --> 57:30.240
我们一般不用去动他

57:30.240 --> 57:31.240
让他自动生成就完事了

57:31.240 --> 57:32.240
好 这个属性

57:32.240 --> 57:34.240
另外一个属性的就是

57:34.240 --> 57:35.240
两个下滑线V

57:35.240 --> 57:36.240
这个玩意是什么呢

57:36.240 --> 57:38.240
这个玩意是Mangoes搞出来的

57:39.240 --> 57:41.240
它就是我们Mangoes搞出来的

57:41.240 --> 57:42.240
那么这个玩意

57:42.240 --> 57:44.240
它是在内部记录版本编号

57:44.240 --> 57:46.240
比方说你这个文档里边

57:46.240 --> 57:48.240
你这个文档里边

57:48.240 --> 57:49.240
一开始没有这个文档

57:49.240 --> 57:50.240
然后新增了

57:50.240 --> 57:51.240
它就是0

57:51.240 --> 57:53.240
后面对它有了一些操作过后

57:53.240 --> 57:55.240
它就增加1234

57:55.240 --> 57:56.240
这个编版本编号

57:56.240 --> 57:57.240
它内部控制的

57:57.240 --> 57:58.240
你不用去管它

57:58.240 --> 58:00.240
好 这是这一块

58:00.240 --> 58:01.240
没问题吧

58:01.240 --> 58:03.240
这是我们的新增用户

58:03.240 --> 58:04.240
新增

58:04.240 --> 58:06.240
当然新增新文也是一样

58:06.240 --> 58:07.240
那么基于这一点

58:07.240 --> 58:08.240
我们可以

58:08.240 --> 58:10.240
我这里有一些测试的

58:10.240 --> 58:13.240
有一些测试的文件

58:13.240 --> 58:14.240
我这里有两个文件

58:14.240 --> 58:15.240
你可以把这两个文件

58:15.240 --> 58:17.240
托到你的工程里边去

58:18.240 --> 58:19.240
资源管理器打开

58:19.240 --> 58:21.240
可以张开过来

58:21.240 --> 58:22.240
我这里有两个文件

58:22.240 --> 58:24.240
这两个文件是阶层格式的

58:24.240 --> 58:25.240
一个是60

58:25.240 --> 58:26.240
这里有很多数据

58:26.240 --> 58:28.240
我们的所谓的新文都在这

58:28.240 --> 58:30.240
还有一个文件是UZS

58:30.240 --> 58:31.240
我们的用户

58:31.240 --> 58:32.240
全在这

58:32.240 --> 58:33.240
有很多

58:33.240 --> 58:35.240
那么我们现在要做的事情就是

58:35.240 --> 58:37.240
把这两个文件里面的所有数据

58:37.240 --> 58:39.240
夹到我们的数据库里面去

58:39.240 --> 58:41.240
好 来 我们来写一下

58:41.240 --> 58:44.810
我们就把一个代码上

58:45.810 --> 58:46.810
写两个函数

58:46.810 --> 58:48.810
第一个函数

58:48.810 --> 58:51.810
添加用户

58:51.810 --> 58:52.810
写一个函数

58:52.810 --> 58:53.810
添加用户

58:53.810 --> 58:54.810
用户哪来呢

58:54.810 --> 58:56.810
来自于这个文件

58:56.810 --> 58:58.810
叫做UZS.JS

58:58.810 --> 58:59.810
UZS.JS

58:59.810 --> 59:00.810
这个文件

59:00.810 --> 59:01.810
这个文件里面

59:01.810 --> 59:02.810
其实就是一个用户宿主

59:02.810 --> 59:03.810
你看一下

59:03.810 --> 59:04.810
不就是一个用户宿主

59:04.810 --> 59:05.810
对不对

59:05.810 --> 59:06.810
这种阶层格式的文件

59:06.810 --> 59:07.810
非常简单

59:07.810 --> 59:08.810
超过起来非常简单

59:08.810 --> 59:09.810
它本身就是一个宿主

59:09.810 --> 59:11.810
所以说我这里只需要

59:11.810 --> 59:13.810
导入UZS.JS

59:13.810 --> 59:16.810
REQUIRE.JS

59:16.810 --> 59:17.810
UZS.JS

59:17.810 --> 59:18.810
注意要写后续名

59:18.810 --> 59:19.810
因为它是阶层格式的

59:19.810 --> 59:20.810
不是JS

59:20.810 --> 59:21.810
写后续名

59:21.810 --> 59:22.810
然后让我们输出一下

59:22.810 --> 59:23.810
它就是一个宿主

59:23.810 --> 59:24.810
导入进来就是一个宿主

59:24.810 --> 59:25.810
你看一下吧

59:25.810 --> 59:26.810
保存

59:26.810 --> 59:28.810
No.JS

59:29.810 --> 59:30.810
你看不就是个宿主

59:30.810 --> 59:31.810
对吧

59:31.810 --> 59:32.810
还有36个项

59:32.810 --> 59:33.810
它就隐藏了

59:33.810 --> 59:34.810
数据很多

59:34.810 --> 59:35.810
显示不出来了

59:35.810 --> 59:36.810
停止

59:37.810 --> 59:38.810
就这么一个意思

59:38.810 --> 59:39.810
知道吧

59:39.810 --> 59:40.810
我们只需要把这个宿主

59:40.810 --> 59:41.810
加到数据库里面去就行了

59:41.810 --> 59:42.810
那怎么加呢

59:42.810 --> 59:43.810
非常简单

59:43.810 --> 59:44.810
我们就通过models

59:44.810 --> 59:45.810
UZS.JS

59:45.810 --> 59:47.810
然后这里

59:47.810 --> 59:48.810
REQUIRE.JS

59:48.810 --> 59:49.810
把什么传进去

59:49.810 --> 59:51.810
把这个宿主传进去

59:51.810 --> 59:52.810
传进去晚上

59:52.810 --> 59:54.810
我们这里可以等待一下它

59:54.810 --> 59:55.810
等待一下

59:55.810 --> 59:56.810
它会返回一个什么呢

59:56.810 --> 59:57.810
返回一个宿主

59:57.810 --> 59:58.810
完了过后

59:58.810 --> 59:59.810
它会返回一个宿主

59:59.810 --> 01:00:00.810
你给它反那个宿主

01:00:00.810 --> 01:00:01.810
它就会返回一个宿主

01:00:01.810 --> 01:00:02.810
就是加了哪些用户

01:00:02.810 --> 01:00:04.810
那么我这里懒得去得到的它了

01:00:04.810 --> 01:00:05.810
我直接输出

01:00:05.810 --> 01:00:07.810
添加用户

01:00:07.810 --> 01:00:09.810
测试数据成功

01:00:15.680 --> 01:00:16.680
保存

01:00:16.680 --> 01:00:17.680
这边

01:00:17.680 --> 01:00:18.680
我们调一个函数

01:00:19.680 --> 01:00:20.680
那么这个时候肯定要报错的

01:00:20.680 --> 01:00:21.680
因为它的威者

01:00:21.680 --> 01:00:22.680
它是不是必须要写到

01:00:22.680 --> 01:00:23.680
而SYNC函数里面

01:00:23.680 --> 01:00:24.680
保存

01:00:28.310 --> 01:00:30.310
添加用户测试数据成功

01:00:30.310 --> 01:00:31.310
我们来看一下

01:00:31.310 --> 01:00:32.310
我们的数据库里面

01:00:32.310 --> 01:00:33.310
打开

01:00:33.310 --> 01:00:34.310
这有很多数据了

01:00:34.310 --> 01:00:36.310
各种各样的用户

01:00:36.310 --> 01:00:37.310
有很多数据了

01:00:38.310 --> 01:00:39.310
那么这些数据搞定了

01:00:39.310 --> 01:00:40.310
那么同样的道理

01:00:40.310 --> 01:00:41.310
我们用同样的方式

01:00:41.310 --> 01:00:43.310
可以添加一些新闻

01:00:43.310 --> 01:00:45.940
比方说

01:00:45.940 --> 01:00:46.940
我们再写个函数

01:00:46.940 --> 01:00:47.940
帮个行

01:00:47.940 --> 01:00:49.940
add news

01:00:49.940 --> 01:00:50.940
添加一些新闻

01:00:50.940 --> 01:00:51.940
那么我们用同样的方式

01:00:51.940 --> 01:00:52.940
await

01:00:52.940 --> 01:00:53.940
models

01:00:53.940 --> 01:00:54.940
news

01:00:54.940 --> 01:00:55.940
create

01:00:55.940 --> 01:00:56.940
然后这里新闻

01:00:56.940 --> 01:00:57.940
新闻的宿主在哪呢

01:00:57.940 --> 01:00:58.940
在这

01:00:58.940 --> 01:00:59.940
news

01:00:59.940 --> 01:01:00.940
require

01:01:01.940 --> 01:01:02.940
news.json

01:01:03.940 --> 01:01:04.940
加进去

01:01:05.940 --> 01:01:07.940
我们这里输出

01:01:07.940 --> 01:01:08.940
输出

01:01:09.940 --> 01:01:12.940
添加新闻测试数据成功

01:01:14.940 --> 01:01:16.940
这东西一会儿给大家都发下来

01:01:16.940 --> 01:01:21.090
add news

01:01:21.090 --> 01:01:22.090
来吧

01:01:22.090 --> 01:01:23.090
这里停止

01:01:23.090 --> 01:01:24.090
然后运行

01:01:24.090 --> 01:01:25.090
loading

01:01:25.090 --> 01:01:26.090
添加新闻

01:01:26.090 --> 01:01:27.090
新闻添加成功了

01:01:27.090 --> 01:01:28.090
咱们看一下

01:01:29.090 --> 01:01:30.090
右键刷新refresh

01:01:30.090 --> 01:01:31.090
你看这个结合了

01:01:31.090 --> 01:01:32.090
news

01:01:32.090 --> 01:01:33.090
对不对

01:01:33.090 --> 01:01:34.090
打开

01:01:34.090 --> 01:01:35.090
这里面有新闻

01:01:35.090 --> 01:01:36.090
没问题吧

01:01:36.090 --> 01:01:37.090
那么现在

01:01:37.090 --> 01:01:38.090
我们数据这些东西

01:01:38.090 --> 01:01:39.090
都有了

01:01:40.090 --> 01:01:41.090
数据这些都有了

01:01:41.090 --> 01:01:42.090
都有了

01:01:43.090 --> 01:01:45.090
这些新闻都是真实的数据

01:01:46.090 --> 01:01:47.090
好了

01:01:47.090 --> 01:01:48.090
我们现在数据有了

01:01:48.090 --> 01:01:49.090
添加搞定了

01:01:49.090 --> 01:01:50.090
我把它带满了

01:01:50.090 --> 01:01:51.090
复制粘贴

01:01:51.090 --> 01:01:53.090
到另外一个文件里边

01:01:53.090 --> 01:01:54.090
这是

01:01:55.090 --> 01:01:56.090
右键

01:01:57.090 --> 01:01:58.090
这是

01:01:58.090 --> 01:01:59.090
test

01:01:59.090 --> 01:02:00.090
create

01:02:00.090 --> 01:02:01.090
添加

01:02:01.090 --> 01:02:02.090
搞定了

01:02:02.090 --> 01:02:03.090
然后那个时候把清空

01:02:04.090 --> 01:02:07.230
这个停止

01:02:07.230 --> 01:02:08.230
加上来看第二步

01:02:09.230 --> 01:02:12.740
跑了同学发信一下

01:02:12.740 --> 01:02:14.740
第二个就是重点来了

01:02:14.740 --> 01:02:15.740
就查询

01:02:15.740 --> 01:02:16.740
因为我们添加

01:02:16.740 --> 01:02:17.740
其实添加更新

01:02:17.740 --> 01:02:18.740
删除都很简单

01:02:18.740 --> 01:02:19.740
主要是查询

01:02:19.740 --> 01:02:20.740
查询这里东西比较多

01:02:21.740 --> 01:02:22.740
查询我这里讲

01:02:22.740 --> 01:02:23.740
三种查询方式

01:02:25.740 --> 01:02:26.740
前两种

01:02:26.740 --> 01:02:27.740
看看第一个

01:02:27.740 --> 01:02:28.740
第一个查询非常简单

01:02:28.740 --> 01:02:29.740
就是你根据id

01:02:29.740 --> 01:02:30.740
来查询一个单个文档

01:02:30.740 --> 01:02:31.740
如果找不到的话

01:02:31.740 --> 01:02:32.740
他就反回闹

01:02:32.740 --> 01:02:33.740
非常简单

01:02:33.740 --> 01:02:34.740
我们来看一把

01:02:34.740 --> 01:02:35.740
查询单个文档

01:02:35.740 --> 01:02:36.740
我们写个函数

01:02:36.740 --> 01:02:37.740
test

01:02:37.740 --> 01:02:38.740
方形

01:02:39.740 --> 01:02:40.740
查询

01:02:40.740 --> 01:02:41.740
models

01:02:41.740 --> 01:02:42.740
user

01:02:42.740 --> 01:02:43.740
fan

01:02:43.740 --> 01:02:44.740
id

01:02:44.740 --> 01:02:45.740
给他一个id

01:02:45.740 --> 01:02:46.740
id来自于哪

01:02:46.740 --> 01:02:47.740
我就随便找一个id

01:02:47.740 --> 01:02:48.740
我们这个

01:02:48.740 --> 01:02:50.740
就找一个一篇新闻

01:02:50.740 --> 01:02:51.740
找一篇新闻

01:02:51.740 --> 01:02:52.740
点击右键

01:02:53.740 --> 01:02:54.740
edit

01:02:54.740 --> 01:02:55.740
把这个id复制一下

01:02:56.740 --> 01:02:57.740
粘过来

01:02:58.740 --> 01:02:59.740
找一篇新闻

01:02:59.740 --> 01:03:00.740
是不是要等

01:03:00.740 --> 01:03:01.740
对不对

01:03:01.740 --> 01:03:02.740
反而是跟数据库的操作

01:03:02.740 --> 01:03:03.740
全部要等

01:03:03.740 --> 01:03:04.740
你想都不用想

01:03:04.740 --> 01:03:05.740
等他

01:03:05.740 --> 01:03:06.740
完了过后

01:03:06.740 --> 01:03:07.740
还会给你一个结果

01:03:07.740 --> 01:03:09.740
接受一下

01:03:09.740 --> 01:03:10.740
接受一下

01:03:10.740 --> 01:03:11.740
输出

01:03:11.740 --> 01:03:12.740
非常简单

01:03:12.740 --> 01:03:13.740
就是查询单个

01:03:15.740 --> 01:03:16.740
来了

01:03:16.740 --> 01:03:19.300
load index

01:03:21.300 --> 01:03:22.300
大

01:03:22.300 --> 01:03:23.300
这边没找到

01:03:23.300 --> 01:03:24.300
原因是用户

01:03:24.300 --> 01:03:25.300
应该是nil

01:03:27.300 --> 01:03:28.300
停止

01:03:28.300 --> 01:03:29.300
load index

01:03:31.620 --> 01:03:32.620
是不是查出来了

01:03:32.620 --> 01:03:33.620
这篇新闻

01:03:33.620 --> 01:03:34.620
标题

01:03:34.620 --> 01:03:35.620
内容

01:03:35.620 --> 01:03:36.620
时间

01:03:36.620 --> 01:03:37.620
频道

01:03:37.620 --> 01:03:38.620
然后的

01:03:38.620 --> 01:03:39.620
看一下是超链接

01:03:39.620 --> 01:03:40.620
这超链接都是真的

01:03:43.120 --> 01:03:44.120
那么后边

01:03:44.120 --> 01:03:45.120
我们可以做一些网页

01:03:45.120 --> 01:03:47.120
把这些数据显示到网页上

01:03:47.120 --> 01:03:48.120
这是咱们明天

01:03:48.120 --> 01:03:49.120
或者是后天的事情

01:03:49.120 --> 01:03:50.120
这篇新闻

01:03:52.120 --> 01:03:54.120
这篇新闻

01:03:54.120 --> 01:03:55.120
就通过一个id

01:03:55.120 --> 01:03:56.120
来查询单个对象

01:03:56.120 --> 01:03:57.120
特别简单

01:03:57.120 --> 01:03:58.120
好 再来

01:04:00.880 --> 01:04:01.880
把注射掉

01:04:01.880 --> 01:04:02.880
查询单个

01:04:02.880 --> 01:04:03.880
下边这个

01:04:04.880 --> 01:04:05.880
fand

01:04:05.880 --> 01:04:06.880
他不是翻得板id

01:04:06.880 --> 01:04:07.880
id就是查询单个

01:04:07.880 --> 01:04:08.880
根据id

01:04:08.880 --> 01:04:09.880
id是唯一的

01:04:09.880 --> 01:04:10.880
组件是唯一的

01:04:10.880 --> 01:04:11.880
他只能查到一个

01:04:11.880 --> 01:04:12.880
他不可能查到多个的

01:04:12.880 --> 01:04:13.880
但是fand

01:04:13.880 --> 01:04:14.880
他是不是可以查到多个

01:04:14.880 --> 01:04:15.880
他有可能根据条件

01:04:15.880 --> 01:04:16.880
他是怎么写的呢

01:04:16.880 --> 01:04:18.880
他是可以给三个参数

01:04:18.880 --> 01:04:19.880
你们要学会看文道

01:04:20.880 --> 01:04:21.880
凡是参数是直接

01:04:21.880 --> 01:04:23.880
这种光突突的在写的地方

01:04:23.880 --> 01:04:25.880
表示这个参数是必须要填的

01:04:26.880 --> 01:04:28.880
凡是参数前后加了一个中扩号的

01:04:28.880 --> 01:04:30.880
表示这个参数是可选的

01:04:30.880 --> 01:04:31.880
你可以不写

01:04:32.880 --> 01:04:33.880
fand的函数

01:04:33.880 --> 01:04:34.880
可以有三个参数

01:04:34.880 --> 01:04:35.880
也可以有一个参数

01:04:35.880 --> 01:04:36.880
也可以有两个参数

01:04:37.880 --> 01:04:38.880
有三个参数

01:04:38.880 --> 01:04:39.880
projection

01:04:39.880 --> 01:04:40.880
以及options

01:04:40.880 --> 01:04:41.880
一个来

01:04:42.880 --> 01:04:43.880
一个filter

01:04:44.880 --> 01:04:45.880
那么这个东西是什么呢

01:04:45.880 --> 01:04:47.880
这东西表示的是过滤条件

01:04:48.880 --> 01:04:49.880
就是你要查数据

01:04:49.880 --> 01:04:50.880
你要查什么样的数据呢

01:04:50.880 --> 01:04:51.880
总有些条件吧

01:04:51.880 --> 01:04:53.880
那么有条件是啥

01:04:53.880 --> 01:04:55.880
就这个filter参数

01:04:55.880 --> 01:04:56.880
他实际上是一个什么呢

01:04:56.880 --> 01:04:58.880
他实际上是一个对象

01:04:59.880 --> 01:05:01.880
他里边有非常丰富的API

01:05:01.880 --> 01:05:02.880
我们来看一下

01:05:02.880 --> 01:05:03.880
相当于列举的一些

01:05:03.880 --> 01:05:04.880
常见的filter协法

01:05:04.880 --> 01:05:05.880
列举不完

01:05:05.880 --> 01:05:07.880
这个东西也没有必要列举完

01:05:07.880 --> 01:05:08.880
这太多了

01:05:08.880 --> 01:05:09.880
就跟你们学习

01:05:10.880 --> 01:05:11.880
哪个人那么傻

01:05:11.880 --> 01:05:12.880
所有的API

01:05:12.880 --> 01:05:13.880
I再都去学习

01:05:13.880 --> 01:05:14.880
这太傻了

01:05:14.880 --> 01:05:15.880
学习几个就够了

01:05:15.880 --> 01:05:16.880
后来我后面

01:05:16.880 --> 01:05:18.880
我们直接查浑荡就完成了

01:05:18.880 --> 01:05:20.880
下面是一些filter协法

01:05:20.880 --> 01:05:21.880
一个个来

01:05:21.880 --> 01:05:22.880
比方说你看我这里

01:05:22.880 --> 01:05:23.880
可以这样子写

01:05:23.880 --> 01:05:24.880
channel 彩丁焦点

01:05:24.880 --> 01:05:25.880
啥意思呢

01:05:25.880 --> 01:05:26.880
就表示我查的是啥

01:05:26.880 --> 01:05:27.880
查的是

01:05:28.880 --> 01:05:29.880
频道

01:05:29.880 --> 01:05:31.880
新闻里边不是有个频道吗

01:05:31.880 --> 01:05:32.880
channel

01:05:32.880 --> 01:05:33.880
对吧

01:05:33.880 --> 01:05:34.880
是不是个频道属性

01:05:34.880 --> 01:05:35.880
好了查的是啥呢

01:05:35.880 --> 01:05:36.880
查的是频道等于

01:05:36.880 --> 01:05:37.880
彩丁焦点的

01:05:37.880 --> 01:05:38.880
就这么简单

01:05:38.880 --> 01:05:39.880
来扶持一下

01:05:39.880 --> 01:05:40.880
看一下吧

01:05:40.880 --> 01:05:41.880
那么这里

01:05:41.880 --> 01:05:42.880
我们用范的

01:05:45.580 --> 01:05:47.580
这边怎么写呢

01:05:47.580 --> 01:05:48.580
写上一个查询对象

01:05:48.580 --> 01:05:50.580
这里写的上一个

01:05:50.580 --> 01:05:51.580
channel

01:05:51.580 --> 01:05:52.580
查的是什么

01:05:52.580 --> 01:05:53.580
查的是所有的

01:05:53.580 --> 01:05:55.580
彩丁焦点的数据

01:05:55.580 --> 01:05:56.580
来看一下吧

01:05:56.580 --> 01:06:00.810
load index

01:06:02.810 --> 01:06:03.810
你看

01:06:03.810 --> 01:06:04.810
是不是得到一个数组

01:06:04.810 --> 01:06:05.810
看一下结尾是不是个数组

01:06:05.810 --> 01:06:06.810
对吧

01:06:06.810 --> 01:06:07.810
数组里边

01:06:07.810 --> 01:06:08.810
一篇新闻一个对象

01:06:08.810 --> 01:06:09.810
看到没

01:06:09.810 --> 01:06:10.810
里面

01:06:10.810 --> 01:06:11.810
类型

01:06:11.810 --> 01:06:12.810
频道是彩丁焦点

01:06:12.810 --> 01:06:13.810
看没

01:06:13.810 --> 01:06:14.810
上面一个新闻

01:06:14.810 --> 01:06:15.810
频道彩丁焦点

01:06:15.810 --> 01:06:16.810
对吧

01:06:16.810 --> 01:06:17.810
签了彩丁焦点

01:06:17.810 --> 01:06:18.810
没问题吧

01:06:19.810 --> 01:06:20.810
彩丁焦点对吧

01:06:20.810 --> 01:06:21.810
这就是查询所有的

01:06:21.810 --> 01:06:22.810
彩丁焦点的数据

01:06:22.810 --> 01:06:23.810
好

01:06:23.810 --> 01:06:24.810
接下来继续

01:06:24.810 --> 01:06:26.810
如果说我是用这种写法

01:06:26.810 --> 01:06:28.810
这叫模糊查询

01:06:28.810 --> 01:06:29.810
啥意思呢

01:06:29.810 --> 01:06:30.810
就是我既要查

01:06:30.810 --> 01:06:31.810
这是并且关系

01:06:31.810 --> 01:06:32.810
有两个条件了

01:06:32.810 --> 01:06:33.810
我的频道呢

01:06:33.810 --> 01:06:35.810
要等于彩丁焦点

01:06:35.810 --> 01:06:36.810
并且

01:06:36.810 --> 01:06:38.810
我的标题里边

01:06:38.810 --> 01:06:39.810
要包含中国

01:06:39.810 --> 01:06:40.810
你看这个是啥

01:06:41.810 --> 01:06:42.810
来回答我

01:06:42.810 --> 01:06:47.040
这个东西是啥

01:06:47.040 --> 01:06:48.040
是否证则表达是

01:06:48.040 --> 01:06:49.040
对不对

01:06:49.040 --> 01:06:50.040
是不是证则表达是

01:06:50.040 --> 01:06:51.040
表示的是

01:06:51.040 --> 01:06:53.040
我只要满足这个证则表达是就行了

01:06:53.040 --> 01:06:54.040
那么这个证则表达

01:06:54.040 --> 01:06:56.040
不就是一个模糊查询吗

01:06:56.040 --> 01:06:58.040
只要里面包含一个中国

01:06:58.040 --> 01:06:59.040
这两个字

01:06:59.040 --> 01:07:00.040
这就可以了

01:07:00.040 --> 01:07:01.040
那么这是这个条件

01:07:01.040 --> 01:07:02.040
我来看一下

01:07:02.040 --> 01:07:03.040
这样子写

01:07:03.040 --> 01:07:05.040
条件写成这样子

01:07:05.040 --> 01:07:06.040
保存

01:07:12.400 --> 01:07:13.400
来

01:07:14.400 --> 01:07:16.400
所以查出来只有一个

01:07:16.400 --> 01:07:17.400
还是一个数组

01:07:17.400 --> 01:07:18.400
因为他也不知道

01:07:18.400 --> 01:07:19.400
到底有多少个

01:07:19.400 --> 01:07:20.400
有可能数组一个都没有

01:07:20.400 --> 01:07:22.400
总之现在查出来了

01:07:22.400 --> 01:07:24.400
前组是彩丁焦点

01:07:24.400 --> 01:07:25.400
并且他里边

01:07:25.400 --> 01:07:26.400
包含中国两个字

01:07:26.400 --> 01:07:28.400
抬头里边包含中国两个字

01:07:28.400 --> 01:07:29.400
所以查出来了

01:07:29.400 --> 01:07:30.400
这是这种查法

01:07:30.400 --> 01:07:31.400
再来看

01:07:31.400 --> 01:07:33.400
下面是一个货者查询

01:07:33.400 --> 01:07:35.400
一个all这个条件

01:07:35.400 --> 01:07:37.400
就是说我查的是

01:07:37.400 --> 01:07:38.400
上面是并且

01:07:38.400 --> 01:07:40.400
就是把并且换成货者

01:07:40.400 --> 01:07:41.400
那该怎么写呢

01:07:41.400 --> 01:07:42.400
就是你看他怎么写法

01:07:42.400 --> 01:07:44.400
all一个多了一个特殊的

01:07:44.400 --> 01:07:45.400
多了符号

01:07:45.400 --> 01:07:46.400
一个all这是个特殊的属性

01:07:46.400 --> 01:07:48.400
他会把它解释成为一个all

01:07:48.400 --> 01:07:49.400
一个货者关系

01:07:49.400 --> 01:07:51.400
他是一个数组

01:07:51.400 --> 01:07:53.400
这里边每一个对象就是个条件

01:07:53.400 --> 01:07:55.400
这些条件之间是货者关系

01:07:55.400 --> 01:07:56.400
就不是并且关系的

01:07:56.400 --> 01:07:58.400
默认是并且关系

01:07:58.400 --> 01:07:59.400
那么现在就是

01:07:59.400 --> 01:08:01.400
这里边的所有东西

01:08:01.400 --> 01:08:03.400
所有条件全是货者关系

01:08:03.400 --> 01:08:05.400
他或者他

01:08:05.400 --> 01:08:06.400
懂这个意思吗

01:08:06.400 --> 01:08:08.400
他或者他

01:08:08.400 --> 01:08:09.400
不就是反过来吗

01:08:09.400 --> 01:08:11.400
就是前组是彩丁焦点

01:08:11.400 --> 01:08:13.400
或者里面包含中午

01:08:13.400 --> 01:08:14.400
复制一下

01:08:14.400 --> 01:08:16.400
那么我们把这个条件

01:08:16.400 --> 01:08:17.400
无非就是写条件

01:08:17.400 --> 01:08:18.400
你不用去使经营贝

01:08:18.400 --> 01:08:21.400
学开发最机会就是使经营贝了

01:08:21.400 --> 01:08:22.400
不要去使经营贝

01:08:22.400 --> 01:08:23.400
你想这些东西

01:08:23.400 --> 01:08:24.400
我可能今天晚上讲了

01:08:24.400 --> 01:08:25.400
我一会就忘了

01:08:25.400 --> 01:08:26.400
没关系

01:08:26.400 --> 01:08:27.400
你们拿到这个文档

01:08:27.400 --> 01:08:29.400
你看我为什么给你们写这个东西

01:08:29.400 --> 01:08:30.400
就是你们忘了过后

01:08:30.400 --> 01:08:32.400
你马上在这里来查询

01:08:32.400 --> 01:08:33.400
不丢人

01:08:33.400 --> 01:08:34.400
真的不丢人的

01:08:34.400 --> 01:08:36.400
你们你以为你们以后写代吗

01:08:36.400 --> 01:08:37.400
是什么都不看

01:08:37.400 --> 01:08:38.400
在那里啪啪啪

01:08:38.400 --> 01:08:39.400
不行的写代吗

01:08:39.400 --> 01:08:41.400
那叫打字不叫写代吗

01:08:41.400 --> 01:08:42.400
写代吗

01:08:42.400 --> 01:08:43.400
绝大部分时间

01:08:43.400 --> 01:08:44.400
要么在思考

01:08:44.400 --> 01:08:45.400
要么在查文的

01:08:45.400 --> 01:08:47.400
真正动手的时候

01:08:47.400 --> 01:08:48.400
其实很少的

01:08:48.400 --> 01:08:49.400
又不是练打字

01:08:49.400 --> 01:08:51.400
说查文倒是非常正常的

01:08:51.400 --> 01:08:53.400
那么这里就表示这个关系了

01:08:53.400 --> 01:08:55.400
他们之间是货者关系

01:08:55.400 --> 01:08:56.400
你知道逻辑

01:08:56.400 --> 01:08:57.400
含义搞清楚就行了

01:09:02.740 --> 01:09:03.740
你看

01:09:03.740 --> 01:09:04.740
那么这里就查出来了

01:09:04.740 --> 01:09:06.740
就是要么里边

01:09:06.740 --> 01:09:07.740
要么他是彩丁焦点

01:09:07.740 --> 01:09:09.740
要么就是标题里面包含中午

01:09:09.740 --> 01:09:11.740
中国有这么个意思

01:09:11.740 --> 01:09:13.740
这种查询方式

01:09:13.740 --> 01:09:14.740
好 继续

01:09:14.740 --> 01:09:16.740
下面我优举了一些特殊的例子

01:09:16.740 --> 01:09:17.740
比方说文查询

01:09:17.740 --> 01:09:20.740
这个pubdate发布的日期

01:09:20.740 --> 01:09:21.740
既替意义什么意思

01:09:21.740 --> 01:09:22.740
既表示什么意思

01:09:22.740 --> 01:09:24.740
既表示great

01:09:24.740 --> 01:09:26.740
greater than

01:09:26.740 --> 01:09:27.740
比什么大

01:09:27.740 --> 01:09:29.740
or equal

01:09:29.740 --> 01:09:30.740
或等于

01:09:30.740 --> 01:09:32.740
就是大于等于的意思

01:09:32.740 --> 01:09:34.740
pubdate就这个值

01:09:34.740 --> 01:09:36.740
它要大于等于什么呢

01:09:36.740 --> 01:09:37.740
大于等于就是个时间戳

01:09:37.740 --> 01:09:39.740
时间戳减去3600

01:09:39.740 --> 01:09:40.740
是不是

01:09:40.740 --> 01:09:42.740
一小时的秒数

01:09:42.740 --> 01:09:43.740
对不对

01:09:43.740 --> 01:09:45.740
成一二十四是不是二十四个小时

01:09:45.740 --> 01:09:46.740
成一千

01:09:46.740 --> 01:09:47.740
对不对

01:09:47.740 --> 01:09:48.740
一天的好妙数

01:09:48.740 --> 01:09:49.740
对吧

01:09:49.740 --> 01:09:50.740
就是当前时间

01:09:50.740 --> 01:09:51.740
减去一天的好妙数

01:09:51.740 --> 01:09:52.740
是不是昨天这个时候

01:09:52.740 --> 01:09:53.740
对吧

01:09:53.740 --> 01:09:54.740
就是我们这个发布日期

01:09:54.740 --> 01:09:55.740
要大于等于

01:09:55.740 --> 01:09:56.740
昨天这个时候

01:09:56.740 --> 01:09:58.740
就昨天之后发布的

01:09:58.740 --> 01:09:59.740
就这个意思

01:09:59.740 --> 01:10:00.740
昨天之后发布的

01:10:00.740 --> 01:10:02.740
那么我们可以通过这个底角

01:10:02.740 --> 01:10:03.740
但是这个地方可以随意写

01:10:03.740 --> 01:10:04.740
只要你写个正确的日期

01:10:04.740 --> 01:10:06.740
时间戳就行了

01:10:06.740 --> 01:10:07.740
那么这里表示

01:10:07.740 --> 01:10:09.740
发布日期要大于等于这个时候

01:10:09.740 --> 01:10:10.740
对不对

01:10:10.740 --> 01:10:11.740
你可以看一下吧

01:10:11.740 --> 01:10:15.330
复制

01:10:15.330 --> 01:10:16.330
来

01:10:16.330 --> 01:10:23.900
都赢这个事

01:10:23.900 --> 01:10:24.900
那就赢多了

01:10:24.900 --> 01:10:25.900
对吧

01:10:25.900 --> 01:10:26.900
就赢多了

01:10:26.900 --> 01:10:27.900
好

01:10:27.900 --> 01:10:29.900
那么这是各种条件的写法

01:10:29.900 --> 01:10:30.900
那么这里的

01:10:30.900 --> 01:10:31.900
其实还有一些

01:10:31.900 --> 01:10:32.900
大家注释的

01:10:32.900 --> 01:10:33.900
GT表示大于

01:10:33.900 --> 01:10:34.900
GTE表示大于等于

01:10:34.900 --> 01:10:35.900
LT表示小于

01:10:35.900 --> 01:10:36.900
LTE表示小等于

01:10:36.900 --> 01:10:37.900
NE表示不等于

01:10:37.900 --> 01:10:38.900
那是一括

01:10:38.900 --> 01:10:41.900
IN表示在某一个数组当中

01:10:41.900 --> 01:10:42.900
如果说这里写的是IN的话

01:10:42.900 --> 01:10:43.900
那么后边写个数组

01:10:43.900 --> 01:10:45.900
就表示这个值

01:10:45.900 --> 01:10:47.900
必须要在某一个提供的值当中

01:10:47.900 --> 01:10:49.900
LOT IN表示某一个值不在

01:10:49.900 --> 01:10:50.900
某一个数组中

01:10:50.900 --> 01:10:52.900
总之就是这么一些条件

01:10:52.900 --> 01:10:54.900
根据需要去拼凑的一些条件

01:10:54.900 --> 01:10:56.900
那么就可以获得非常丰富的

01:10:56.900 --> 01:10:57.900
过滤条件

01:10:57.900 --> 01:10:58.900
这是第1个参数

01:10:58.900 --> 01:10:59.900
FAN的第1个参数

01:10:59.900 --> 01:11:00.900
FILTER

01:11:00.900 --> 01:11:01.900
好

01:11:01.900 --> 01:11:02.900
第2个参数

01:11:02.900 --> 01:11:03.900
第2个参数

01:11:03.900 --> 01:11:04.900
很好写

01:11:04.900 --> 01:11:05.900
PROJECTION

01:11:05.900 --> 01:11:06.900
表示投印

01:11:06.900 --> 01:11:07.900
听上去这个名字

01:11:07.900 --> 01:11:08.900
很高端

01:11:08.900 --> 01:11:09.900
其实它一点都不高端

01:11:09.900 --> 01:11:10.900
非常简单

01:11:10.900 --> 01:11:11.900
啥意思呢

01:11:11.900 --> 01:11:12.900
它是个制服串

01:11:12.900 --> 01:11:13.900
可以选可以写可以不写

01:11:13.900 --> 01:11:14.900
不写的话就查全部

01:11:14.900 --> 01:11:15.900
啥意思呢

01:11:15.900 --> 01:11:17.900
比方说你这样子写

01:11:17.900 --> 01:11:19.900
它只查两个

01:11:19.900 --> 01:11:20.900
两个字段

01:11:20.900 --> 01:11:21.900
TITLE和PUB DATE

01:11:21.900 --> 01:11:22.900
你看一下吧

01:11:23.900 --> 01:11:24.900
前边说了半天

01:11:24.900 --> 01:11:25.900
这是条件吗

01:11:25.900 --> 01:11:26.900
这是第1个参数条件

01:11:26.900 --> 01:11:27.900
第2个参数

01:11:27.900 --> 01:11:28.900
我们写上一个制服串

01:11:28.900 --> 01:11:29.900
比方说TITLE

01:11:30.900 --> 01:11:31.900
PUB DATE

01:11:32.900 --> 01:11:33.900
你看一下

01:11:33.900 --> 01:11:34.900
这样子写的过后

01:11:34.900 --> 01:11:35.900
会怎么样呢

01:11:35.900 --> 01:11:38.600
LOT INDEX

01:11:39.600 --> 01:11:40.600
你看每个对象

01:11:40.600 --> 01:11:41.600
是不是只有一个TITLE

01:11:41.600 --> 01:11:42.600
一个PUB DATE

01:11:42.600 --> 01:11:43.600
TITLE它会自动给你带进来

01:11:43.600 --> 01:11:45.600
TITLE它会自动给你带进来

01:11:45.600 --> 01:11:46.600
TITLE你不用写

01:11:46.600 --> 01:11:47.600
它会给你带进来

01:11:47.600 --> 01:11:48.600
一般我们都要查TITLE

01:11:48.600 --> 01:11:49.600
对了

01:11:49.600 --> 01:11:50.600
是不是只有这两个属性

01:11:50.600 --> 01:11:51.600
它查有没有查

01:11:51.600 --> 01:11:52.600
有没有按照条件查

01:11:52.600 --> 01:11:53.600
有

01:11:53.600 --> 01:11:55.600
但是查出来的结果中

01:11:55.600 --> 01:11:57.600
它把一些属性给你去掉了

01:11:57.600 --> 01:11:58.600
它只保留这些属性

01:11:58.600 --> 01:12:00.600
没啥意思吧

01:12:00.600 --> 01:12:02.600
另外呢

01:12:02.600 --> 01:12:03.600
如果说你这个

01:12:03.600 --> 01:12:04.600
还有这种写法

01:12:04.600 --> 01:12:05.600
一个简号

01:12:05.600 --> 01:12:06.600
一个属性名

01:12:06.600 --> 01:12:07.600
啥意思呢

01:12:07.600 --> 01:12:09.600
就是除了就排除法

01:12:09.600 --> 01:12:10.600
除了这个属性之外

01:12:10.600 --> 01:12:11.600
都要

01:12:12.600 --> 01:12:13.600
除了这个CONTENT

01:12:13.600 --> 01:12:14.600
都要

01:12:14.600 --> 01:12:15.600
就这么个意思

01:12:15.600 --> 01:12:16.600
比方说

01:12:16.600 --> 01:12:17.600
我可以这样写

01:12:17.600 --> 01:12:18.600
比方说

01:12:19.600 --> 01:12:20.600
除了这个CONTENT

01:12:20.600 --> 01:12:21.600
你看

01:12:21.600 --> 01:12:25.680
LOT INDEX

01:12:26.680 --> 01:12:27.680
这些东西不要去背

01:12:27.680 --> 01:12:28.680
不要去背

01:12:28.680 --> 01:12:29.680
你要理解它的逻辑意思

01:12:29.680 --> 01:12:30.680
是不是

01:12:30.680 --> 01:12:31.680
没有一个CONTENT属性

01:12:31.680 --> 01:12:32.680
对吧

01:12:32.680 --> 01:12:33.680
其他属性都有

01:12:33.680 --> 01:12:34.680
那么这是查询

01:12:34.680 --> 01:12:35.680
还有

01:12:35.680 --> 01:12:36.680
继续

01:12:36.680 --> 01:12:37.680
第三个查询

01:12:37.680 --> 01:12:38.680
OPTIONS

01:12:38.680 --> 01:12:39.680
这是一个可选对象

01:12:39.680 --> 01:12:40.680
就是可以写可不写

01:12:40.680 --> 01:12:41.680
它是一个对象

01:12:41.680 --> 01:12:42.680
那么它提供一些

01:12:42.680 --> 01:12:43.680
额外的配置

01:12:43.680 --> 01:12:44.680
对于我们来说

01:12:44.680 --> 01:12:45.680
额外的配置就两

01:12:45.680 --> 01:12:46.680
就三个东西可以关心

01:12:46.680 --> 01:12:47.680
一个叫SKIP

01:12:48.680 --> 01:12:49.680
一个叫LIMIT

01:12:50.680 --> 01:12:51.680
SKIP是什么意思

01:12:51.680 --> 01:12:52.680
就是已经查出来的结果了

01:12:52.680 --> 01:12:53.680
你在这个结果的基础上

01:12:53.680 --> 01:12:55.680
进一步进行筛选

01:12:55.680 --> 01:12:56.680
挑过几个

01:12:56.680 --> 01:12:58.680
取几个

01:12:58.680 --> 01:12:59.680
知道意思吗

01:12:59.680 --> 01:13:00.680
挑过几个

01:13:00.680 --> 01:13:01.680
取几个

01:13:01.680 --> 01:13:02.680
啥意思呢

01:13:02.680 --> 01:13:03.680
比方说

01:13:03.680 --> 01:13:04.680
我们这里

01:13:04.680 --> 01:13:05.680
写第三个查数

01:13:06.680 --> 01:13:07.680
我们来看一下

01:13:07.680 --> 01:13:08.680
之前的查询结果

01:13:08.680 --> 01:13:09.680
之前的查询结果

01:13:09.680 --> 01:13:10.680
是这么一些

01:13:10.680 --> 01:13:11.680
一打对

01:13:11.680 --> 01:13:12.680
那么现在

01:13:12.680 --> 01:13:13.680
它说

01:13:13.680 --> 01:13:14.680
SKIP

01:13:14.680 --> 01:13:16.680
挑过前面一个

01:13:16.680 --> 01:13:18.680
LIMIT取一个

01:13:20.680 --> 01:13:21.680
取两个吧

01:13:21.680 --> 01:13:22.680
取两个

01:13:22.680 --> 01:13:23.680
或者挑过凌个

01:13:23.680 --> 01:13:24.680
我们看得清楚一点

01:13:24.680 --> 01:13:25.680
挑过凌个

01:13:25.680 --> 01:13:26.680
取两个

01:13:26.680 --> 01:13:27.680
我们来看一下

01:13:27.680 --> 01:13:30.890
LOAD INDEX

01:13:31.890 --> 01:13:32.890
你看

01:13:32.890 --> 01:13:33.890
是不是得到这两个

01:13:33.890 --> 01:13:34.890
我们来记一下

01:13:34.890 --> 01:13:35.890
这里是荷兰规范

01:13:35.890 --> 01:13:36.890
这里是什么成虹

01:13:36.890 --> 01:13:38.890
荷兰规范成虹

01:13:38.890 --> 01:13:39.890
那么接下来

01:13:39.890 --> 01:13:40.890
我们来挑过一个

01:13:40.890 --> 01:13:41.890
取两个

01:13:42.890 --> 01:13:43.890
来看

01:13:44.890 --> 01:13:45.890
LOAD INDEX

01:13:45.890 --> 01:13:48.200
是不是把那个

01:13:48.200 --> 01:13:49.200
第一个挑过了

01:13:49.200 --> 01:13:50.200
对吧

01:13:50.200 --> 01:13:51.200
把第一个挑过了

01:13:51.200 --> 01:13:52.200
在之前的结果基础上

01:13:52.200 --> 01:13:53.200
把这个挑过了

01:13:53.200 --> 01:13:54.200
对吧

01:13:54.200 --> 01:13:55.200
挑过了过后呢

01:13:55.200 --> 01:13:56.200
这就变成第一个了

01:13:56.200 --> 01:13:57.200
对吧

01:13:57.200 --> 01:13:58.200
取两个

01:13:58.200 --> 01:13:59.200
对吧

01:13:59.200 --> 01:14:00.200
在之前的查询结果基础上

01:14:00.200 --> 01:14:01.200
这里不是一个结果吗

01:14:01.200 --> 01:14:02.200
在结果基础上

01:14:02.200 --> 01:14:04.200
去挑过一个

01:14:04.200 --> 01:14:06.200
然后接着取几个

01:14:06.200 --> 01:14:07.200
啥意思

01:14:10.960 --> 01:14:11.960
这么得

01:14:11.960 --> 01:14:12.960
在说啥

01:14:12.960 --> 01:14:14.960
FS内置模块

01:14:14.960 --> 01:14:15.960
取结实里面可以吗

01:14:16.960 --> 01:14:17.960
可以

01:14:17.960 --> 01:14:18.960
可以

01:14:18.960 --> 01:14:19.960
但是没必要

01:14:19.960 --> 01:14:20.960
这个request直接读出来了

01:14:21.960 --> 01:14:22.960
API多

01:14:22.960 --> 01:14:23.960
只是量体是不多

01:14:23.960 --> 01:14:24.960
这是对于什么复杂的

01:14:24.960 --> 01:14:26.960
告诉我有什么复杂的

01:14:26.960 --> 01:14:28.960
这逻辑没一点都不复杂

01:14:28.960 --> 01:14:29.960
它就是API多

01:14:29.960 --> 01:14:30.960
API多没关系

01:14:30.960 --> 01:14:32.960
你不要去背这些API

01:14:32.960 --> 01:14:33.960
我也背不住

01:14:33.960 --> 01:14:34.960
我真的背不住

01:14:34.960 --> 01:14:35.960
片里是小狗

01:14:36.960 --> 01:14:37.960
这些东西你忘了过后

01:14:37.960 --> 01:14:38.960
你直接去查

01:14:38.960 --> 01:14:39.960
就完了

01:14:39.960 --> 01:14:40.960
这边写得这么清楚的文档了

01:14:40.960 --> 01:14:41.960
非常非常清楚的文档了

01:14:41.960 --> 01:14:43.960
一查就完事了

01:14:43.960 --> 01:14:44.960
平时我们用的就这么一些

01:14:44.960 --> 01:14:45.960
不要去背

01:14:45.960 --> 01:14:46.960
学大码去开发签

01:14:46.960 --> 01:14:47.960
千万不要去背

01:14:47.960 --> 01:14:48.960
珍惜自己的生命

01:14:48.960 --> 01:14:49.960
珍惜自己的身体

01:14:50.960 --> 01:14:51.960
这是这一块

01:14:51.960 --> 01:14:53.960
最后我们再看一下

01:14:53.960 --> 01:14:54.960
还有一个sort

01:14:54.960 --> 01:14:55.960
这个耳外的配置里面

01:14:55.960 --> 01:14:56.960
还有一个sort就是排序

01:14:57.960 --> 01:14:58.960
排序

01:14:58.960 --> 01:14:59.960
比方说

01:14:59.960 --> 01:15:00.960
我们现在要获得的是

01:15:00.960 --> 01:15:02.960
最新发布的新闻

01:15:02.960 --> 01:15:03.960
就一条

01:15:04.960 --> 01:15:05.960
我们怎么来获取

01:15:05.960 --> 01:15:06.960
你看着

01:15:06.960 --> 01:15:07.960
我们要获得最新发布的新闻

01:15:08.960 --> 01:15:12.960
获得最新发布的新闻

01:15:13.960 --> 01:15:14.960
一条

01:15:14.960 --> 01:15:15.960
我们只需要一条

01:15:15.960 --> 01:15:16.960
那怎么来写的代码呢

01:15:16.960 --> 01:15:17.960
我们可以这样写

01:15:18.960 --> 01:15:19.960
条件不要了

01:15:19.960 --> 01:15:20.960
没有什么筛选了

01:15:20.960 --> 01:15:21.960
对吧

01:15:21.960 --> 01:15:22.960
不要条件了

01:15:22.960 --> 01:15:23.960
一个空对象

01:15:23.960 --> 01:15:24.960
属性的

01:15:24.960 --> 01:15:25.960
属性的

01:15:25.960 --> 01:15:26.960
我们就放这吧

01:15:26.960 --> 01:15:27.960
属性放这

01:15:27.960 --> 01:15:28.960
好 第三个

01:15:28.960 --> 01:15:29.960
就是查讯的投影

01:15:29.960 --> 01:15:31.960
我们去掉这个康天子了

01:15:31.960 --> 01:15:32.960
那么这里

01:15:32.960 --> 01:15:35.960
我们就可以排序sort

01:15:35.960 --> 01:15:37.960
怎么排序

01:15:37.960 --> 01:15:38.960
你要按什么排序

01:15:38.960 --> 01:15:41.960
按新闻的发布日期

01:15:41.960 --> 01:15:43.960
生序还是将序

01:15:43.960 --> 01:15:45.960
我要得到最新发布的新闻

01:15:45.960 --> 01:15:46.960
你是要把最新发布的

01:15:46.960 --> 01:15:47.960
放前边对吧

01:15:47.960 --> 01:15:49.960
那么应该是生序还是将序

01:15:49.960 --> 01:15:55.670
生序还是将序的

01:15:55.670 --> 01:15:57.670
你要取第一条新闻

01:15:57.670 --> 01:15:58.670
是吧

01:15:58.670 --> 01:15:59.670
将序对吧

01:15:59.670 --> 01:16:00.670
如果说你啥都不写

01:16:00.670 --> 01:16:01.670
就是生序排序

01:16:01.670 --> 01:16:02.670
如果说你加一个简号

01:16:02.670 --> 01:16:03.670
就是将序

01:16:03.670 --> 01:16:04.670
有什么复杂的吗

01:16:04.670 --> 01:16:05.670
一点都不复杂

01:16:05.670 --> 01:16:06.670
就完事了

01:16:06.670 --> 01:16:07.670
就是按将序排序了

01:16:07.670 --> 01:16:08.670
然后我们不

01:16:08.670 --> 01:16:09.670
现在这样子看一下吧

01:16:09.670 --> 01:16:13.300
就新闻权是按将序排序的

01:16:13.300 --> 01:16:14.300
我们为了

01:16:14.300 --> 01:16:15.300
看得更加清楚

01:16:15.300 --> 01:16:17.300
只需要打印出他的title

01:16:17.300 --> 01:16:19.300
和pubdate

01:16:19.300 --> 01:16:21.300
看一下日期

01:16:21.300 --> 01:16:24.810
看到他们全是将序排序的

01:16:24.810 --> 01:16:25.810
自己看吧

01:16:25.810 --> 01:16:27.810
这新闻全是将序的

01:16:28.810 --> 01:16:29.810
22分

01:16:29.810 --> 01:16:31.810
21看是不是将序排序的

01:16:31.810 --> 01:16:32.810
肯定是将序排序的

01:16:32.810 --> 01:16:33.810
对吧

01:16:33.810 --> 01:16:34.810
最近的

01:16:34.810 --> 01:16:35.810
我们的时间

01:16:35.810 --> 01:16:37.810
这是国际标准时间

01:16:37.810 --> 01:16:38.810
加上北京时间

01:16:38.810 --> 01:16:40.810
加8才是北京时间的

01:16:40.810 --> 01:16:41.810
北京时间

01:16:41.810 --> 01:16:42.810
相当于是北京时间的

01:16:42.810 --> 01:16:43.810
商务时间

01:16:43.810 --> 01:16:44.810
22分

01:16:44.810 --> 01:16:45.810
那么这里

01:16:45.810 --> 01:16:46.810
就是

01:16:46.810 --> 01:16:48.810
我们现在要做的事情就是

01:16:48.810 --> 01:16:49.810
在这里取第一条

01:16:49.810 --> 01:16:50.810
对不对

01:16:50.810 --> 01:16:51.810
Limit写一

01:16:51.810 --> 01:16:52.810
对不对

01:16:52.810 --> 01:16:53.810
取第一条

01:16:53.810 --> 01:16:55.810
这就是完成的功能了

01:16:55.810 --> 01:16:57.810
这是最新的一篇新闻

01:16:57.810 --> 01:16:58.810
对吧

01:16:58.810 --> 01:17:00.810
就是数组里面第一个

01:17:00.810 --> 01:17:01.810
没问题吧

01:17:01.810 --> 01:17:02.810
这就是这个查询方式

01:17:02.810 --> 01:17:03.810
加上一个排序

01:17:03.810 --> 01:17:04.810
Sort

01:17:04.810 --> 01:17:05.810
好

01:17:05.810 --> 01:17:06.810
那么这里

01:17:06.810 --> 01:17:07.810
是不是讲了两个了

01:17:07.810 --> 01:17:08.810
查询

01:17:08.810 --> 01:17:09.810
一个是按到ID

01:17:09.810 --> 01:17:10.810
按到组件的查询

01:17:10.810 --> 01:17:12.810
一个是按照各种条件

01:17:12.810 --> 01:17:13.810
一些配置

01:17:13.810 --> 01:17:14.810
然后读到一些东西

01:17:14.810 --> 01:17:15.810
忘了去查就行了

01:17:15.810 --> 01:17:16.810
不要去背

01:17:16.810 --> 01:17:17.810
好

01:17:17.810 --> 01:17:18.810
第三个

01:17:18.810 --> 01:17:20.810
第三个查询的是查数量

01:17:20.810 --> 01:17:21.810
就是我要查询

01:17:21.810 --> 01:17:23.810
比方说满足条件的有多少个

01:17:23.810 --> 01:17:24.810
就是查数量

01:17:24.810 --> 01:17:25.810
比方说我们再来

01:17:26.810 --> 01:17:27.810
复制一下

01:17:27.810 --> 01:17:28.810
写下来

01:17:30.810 --> 01:17:31.810
来 查数量

01:17:31.810 --> 01:17:32.810
查数量非常简单了

01:17:32.810 --> 01:17:33.810
比方说我要看

01:17:33.810 --> 01:17:34.810
一共有多少条新闻

01:17:34.810 --> 01:17:35.810
当非常简单

01:17:35.810 --> 01:17:36.810
就一个Cort

01:17:36.810 --> 01:17:37.810
没了

01:17:37.810 --> 01:17:39.810
这就是一共有多少条新闻

01:17:39.810 --> 01:17:40.810
来看吧

01:17:41.810 --> 01:17:42.810
no index

01:17:44.810 --> 01:17:45.810
120个新闻

01:17:45.810 --> 01:17:46.810
对吧

01:17:46.810 --> 01:17:47.810
对

01:17:47.810 --> 01:17:49.810
他说Cort is

01:17:49.810 --> 01:17:51.810
disprocated

01:17:51.810 --> 01:17:53.810
表示这个函数已经过时了

01:17:53.810 --> 01:17:54.810
马上要去用了

01:17:54.810 --> 01:17:55.810
他说将来

01:17:55.810 --> 01:17:56.810
可能把这个函数移除了

01:17:56.810 --> 01:17:57.810
又不能用了

01:17:58.810 --> 01:17:59.810
他让你去

01:17:59.810 --> 01:18:00.810
用另外一个函数

01:18:00.810 --> 01:18:01.810
叫Cort Document

01:18:01.810 --> 01:18:02.810
那行吧

01:18:02.810 --> 01:18:03.810
他说了算

01:18:03.810 --> 01:18:04.810
你做了一篇

01:18:04.810 --> 01:18:05.810
你说了算

01:18:05.810 --> 01:18:06.810
他说你用这个函数

01:18:06.810 --> 01:18:07.810
那就用吧

01:18:07.810 --> 01:18:08.810
他说怎么样就怎么样

01:18:09.810 --> 01:18:10.810
这实贵

01:18:10.810 --> 01:18:13.180
120个

01:18:13.180 --> 01:18:14.180
对吧

01:18:14.180 --> 01:18:15.180
就查出来了

01:18:15.180 --> 01:18:16.180
120篇新闻

01:18:16.180 --> 01:18:19.180
那如果说我要查满足条件的新闻

01:18:19.180 --> 01:18:20.180
怎么办呢

01:18:20.180 --> 01:18:21.180
那这里跟条件

01:18:21.180 --> 01:18:23.180
你看这里怎么写的

01:18:23.180 --> 01:18:25.180
这里应该是Cort Document

01:18:25.180 --> 01:18:26.180
对吧

01:18:28.180 --> 01:18:29.180
对了

01:18:29.180 --> 01:18:30.180
Cort Document

01:18:30.180 --> 01:18:31.180
那么这里跟条件

01:18:31.180 --> 01:18:33.180
写法跟那个查询的条件

01:18:33.180 --> 01:18:34.180
刚才查询条件的写法

01:18:34.180 --> 01:18:35.180
完全一样

01:18:35.180 --> 01:18:36.180
比方说我要查

01:18:37.180 --> 01:18:39.180
我要查那个Channel

01:18:40.180 --> 01:18:41.180
就是叫什么来的

01:18:41.180 --> 01:18:43.180
那个频道

01:18:43.180 --> 01:18:46.180
叫那个财经焦点

01:18:46.180 --> 01:18:48.180
财经焦点的新闻

01:18:48.180 --> 01:18:50.180
好来吧

01:18:50.180 --> 01:18:51.180
停止

01:18:51.180 --> 01:18:52.180
你看可以体会到

01:18:52.180 --> 01:18:53.180
我们后段一面

01:18:53.180 --> 01:18:54.180
就在搞点什么

01:18:54.180 --> 01:18:55.180
就在搞天天跟数据打交道

01:18:55.180 --> 01:18:57.180
没有什么界面

01:18:57.180 --> 01:18:58.180
这些数据

01:18:58.180 --> 01:18:59.180
是完成界面的基础

01:18:59.180 --> 01:19:01.180
所以25条

01:19:01.180 --> 01:19:03.180
财经焦点有25条新闻

01:19:03.180 --> 01:19:04.180
可以跟条件的

01:19:04.180 --> 01:19:05.180
就这么简单

01:19:05.180 --> 01:19:06.180
这查数量

01:19:06.180 --> 01:19:08.180
能理解吗

01:19:12.390 --> 01:19:13.390
可以

01:19:13.390 --> 01:19:14.390
可以

01:19:14.390 --> 01:19:15.390
但是我们没有设计

01:19:15.390 --> 01:19:17.390
我们这个例子里面没有设计

01:19:18.390 --> 01:19:19.390
MangoDB这个东西

01:19:19.390 --> 01:19:22.390
它是不太建议去做连接的

01:19:22.390 --> 01:19:23.390
为啥呢

01:19:23.390 --> 01:19:24.390
它认为

01:19:24.390 --> 01:19:26.390
如果说你有两个模型之间

01:19:26.390 --> 01:19:27.390
有关联的话

01:19:27.390 --> 01:19:28.390
你应该把它放到一个模型里边

01:19:28.390 --> 01:19:30.390
你不应该把它分成两个模型

01:19:31.390 --> 01:19:32.390
MangoDB它的思路

01:19:32.390 --> 01:19:34.390
跟那个关系型数据困了

01:19:34.390 --> 01:19:35.390
就不太一样

01:19:35.390 --> 01:19:36.390
它本身就不是

01:19:36.390 --> 01:19:38.390
特别擅长去做关系的

01:19:38.390 --> 01:19:39.390
它可以做

01:19:39.390 --> 01:19:41.390
但是它绝对不是它的长相

01:19:41.390 --> 01:19:43.390
如果说你的数据库里边

01:19:43.390 --> 01:19:44.390
经常会出现那种

01:19:45.390 --> 01:19:47.390
模型与模型之间的关联

01:19:47.390 --> 01:19:48.390
它建议你使用关系型数据库

01:19:48.390 --> 01:19:49.390
不要用它了

01:19:49.390 --> 01:19:50.390
它是存什么的

01:19:50.390 --> 01:19:51.390
它是存那种数据量

01:19:51.390 --> 01:19:52.390
特别特别巨大

01:19:52.390 --> 01:19:54.390
比方说像日字

01:19:54.390 --> 01:19:56.390
比方说像一些访问记录

01:19:56.390 --> 01:19:57.390
登录记录

01:19:57.390 --> 01:19:59.390
像一些错误日字

01:19:59.390 --> 01:20:00.390
像一些用户

01:20:00.390 --> 01:20:02.390
单表的用户信息

01:20:02.390 --> 01:20:03.390
量非常非常大

01:20:03.390 --> 01:20:04.390
而且跟其他东西

01:20:04.390 --> 01:20:05.390
没有特别强力的关联

01:20:05.390 --> 01:20:06.390
那么像这些东西

01:20:06.390 --> 01:20:07.390
就特别适合用那个

01:20:07.390 --> 01:20:09.390
MangoDB

01:20:10.390 --> 01:20:11.390
好 这是这一块

01:20:12.390 --> 01:20:13.390
下面更新

01:20:15.770 --> 01:20:16.770
而不得什么

01:20:16.770 --> 01:20:17.770
而不得什么名字

01:20:17.770 --> 01:20:18.770
看名字就知道

01:20:18.770 --> 01:20:19.770
一个是更新单个文档

01:20:19.770 --> 01:20:20.770
一个是更新多个文档

01:20:21.770 --> 01:20:22.770
看名字就知道了

01:20:22.770 --> 01:20:23.770
它参数也非常简单

01:20:23.770 --> 01:20:24.770
第一个条件

01:20:25.770 --> 01:20:28.770
把满足什么样的条件的更新

01:20:28.770 --> 01:20:30.770
更新成什么样子

01:20:30.770 --> 01:20:32.770
一个条件一个值

01:20:32.770 --> 01:20:33.770
我们来看一下

01:20:33.770 --> 01:20:34.770
把这个复制一下

01:20:35.770 --> 01:20:36.770
这个地方

01:20:36.770 --> 01:20:37.770
给大家写一个Test

01:20:37.770 --> 01:20:38.770
这是fan

01:20:38.770 --> 01:20:39.770
查询

01:20:41.770 --> 01:20:43.770
还是用CRUD东西

01:20:48.910 --> 01:20:50.910
那么这里就是index

01:20:50.910 --> 01:20:55.910
再来

01:20:55.910 --> 01:20:56.910
那么现在我们更新

01:20:56.910 --> 01:20:59.910
比方说我们更新一个文档

01:20:59.910 --> 01:21:00.910
那么我们演示一个

01:21:00.910 --> 01:21:01.910
一个更新就完成了

01:21:02.910 --> 01:21:03.910
更新啥呢

01:21:03.910 --> 01:21:05.910
就更新这个玩意了

01:21:05.910 --> 01:21:07.910
就更新它吧

01:21:08.910 --> 01:21:09.910
第一个

01:21:09.910 --> 01:21:11.910
点击右键Edits

01:21:11.910 --> 01:21:12.910
就更新这个玩意

01:21:13.910 --> 01:21:14.910
我们要把ID

01:21:14.910 --> 01:21:15.910
等于这个玩意了

01:21:15.910 --> 01:21:16.910
更新成为什么呢

01:21:16.910 --> 01:21:17.910
更新成为

01:21:17.910 --> 01:21:19.910
把它的频道更新成为

01:21:19.910 --> 01:21:20.910
另外一个

01:21:21.910 --> 01:21:22.910
那么我们更新

01:21:22.910 --> 01:21:23.910
models

01:21:24.910 --> 01:21:25.910
news

01:21:25.910 --> 01:21:26.910
update

01:21:27.910 --> 01:21:28.910
然后更新一个

01:21:28.910 --> 01:21:29.910
更新一个

01:21:30.910 --> 01:21:31.910
那么这里

01:21:31.910 --> 01:21:32.910
我们写上

01:21:32.910 --> 01:21:33.910
第一个参数条件

01:21:34.910 --> 01:21:35.910
满足什么条件呢

01:21:35.910 --> 01:21:37.910
满足ID等于

01:21:37.910 --> 01:21:38.910
等于啥玩意

01:21:38.910 --> 01:21:39.910
等于这个玩意

01:21:39.910 --> 01:21:40.910
我们一般来说

01:21:40.910 --> 01:21:42.910
都用IT去判断

01:21:42.910 --> 01:21:43.910
比方说一个条件

01:21:43.910 --> 01:21:44.910
ID等于这个

01:21:44.910 --> 01:21:45.910
这个玩意了

01:21:45.910 --> 01:21:46.910
更新成为什么呢

01:21:46.910 --> 01:21:48.910
更新成为

01:21:48.910 --> 01:21:49.910
新的一个字

01:21:49.910 --> 01:21:50.910
但是我不要给它

01:21:50.910 --> 01:21:51.910
所谓的字

01:21:51.910 --> 01:21:52.910
我只需要给它一个就行了

01:21:52.910 --> 01:21:53.910
签了

01:21:53.910 --> 01:21:55.910
我只需要更新这个就完成了

01:21:55.910 --> 01:21:56.910
把这个签弄了

01:21:56.910 --> 01:21:57.910
更新成为什么呢

01:21:57.910 --> 01:21:59.910
更新成为那个财经什么玩意

01:22:00.910 --> 01:22:01.910
那个财经啥

01:22:02.910 --> 01:22:03.910
财经焦点

01:22:04.910 --> 01:22:05.910
啥意思

01:22:05.910 --> 01:22:06.910
就是这个意思

01:22:06.910 --> 01:22:07.910
把

01:22:08.910 --> 01:22:09.910
ID

01:22:10.910 --> 01:22:11.910
等于

01:22:11.910 --> 01:22:12.910
等于

01:22:13.910 --> 01:22:14.910
这个玩意

01:22:15.910 --> 01:22:16.910
的

01:22:16.910 --> 01:22:17.910
文档

01:22:18.910 --> 01:22:20.910
进行更新

01:22:20.910 --> 01:22:21.910
更新成为什么呢

01:22:21.910 --> 01:22:22.910
怎么来更新呢

01:22:22.910 --> 01:22:24.910
用这个玩意

01:22:24.910 --> 01:22:28.610
用这个玩意

01:22:28.610 --> 01:22:29.610
去覆盖旧文档

01:22:29.610 --> 01:22:32.690
覆盖

01:22:34.690 --> 01:22:35.690
旧文档

01:22:35.690 --> 01:22:36.690
就这么个意思

01:22:39.770 --> 01:22:40.770
这就是更新

01:22:40.770 --> 01:22:41.770
我们来试一下吧

01:22:42.770 --> 01:22:43.770
等待一下

01:22:43.770 --> 01:22:44.770
等待一下

01:22:44.770 --> 01:22:45.770
然后那么就输出

01:22:46.770 --> 01:22:48.770
给看下它的结果

01:22:48.770 --> 01:22:49.770
更新完了过

01:22:49.770 --> 01:22:50.770
它会告诉你一个结果

01:22:53.720 --> 01:22:54.720
保存

01:22:54.720 --> 01:22:55.720
我们来

01:22:57.720 --> 01:22:58.720
你看

01:22:58.720 --> 01:22:59.720
是不是它告诉你

01:23:00.720 --> 01:23:02.720
ok1表示没问题

01:23:02.720 --> 01:23:03.720
没问题

01:23:03.720 --> 01:23:05.720
Modified表示的是

01:23:05.720 --> 01:23:06.720
更新的调数

01:23:06.720 --> 01:23:08.720
那么这个就是影响的行数

01:23:08.720 --> 01:23:09.720
一共就一个

01:23:09.720 --> 01:23:10.720
一个就一个

01:23:10.720 --> 01:23:11.720
我们来看一下吧

01:23:11.720 --> 01:23:12.720
重新打开一次

01:23:13.720 --> 01:23:14.720
我再重新打开

01:23:15.720 --> 01:23:16.720
你看是不是把它变成了

01:23:16.720 --> 01:23:17.720
采集交变了

01:23:17.720 --> 01:23:18.720
对吧

01:23:18.720 --> 01:23:19.720
就这么一个意思

01:23:19.720 --> 01:23:20.720
这是更新

01:23:20.720 --> 01:23:21.720
特别简单

01:23:21.720 --> 01:23:22.720
那么如果说了更新多个数据的话

01:23:22.720 --> 01:23:23.720
你就在这里

01:23:23.720 --> 01:23:24.720
继续写就完事了

01:23:24.720 --> 01:23:25.720
更新一个

01:23:25.720 --> 01:23:26.720
更新多个的话就写Many

01:23:26.720 --> 01:23:27.720
Many的话

01:23:27.720 --> 01:23:28.720
但是也要条件能够匹配多个

01:23:28.720 --> 01:23:30.720
update的文档表示说

01:23:30.720 --> 01:23:32.720
就是你条件你匹配到了多个

01:23:33.720 --> 01:23:34.720
我也只更新一个

01:23:34.720 --> 01:23:36.720
如果你是update's many的话

01:23:36.720 --> 01:23:37.720
你匹配到了多个

01:23:37.720 --> 01:23:38.720
匹配到多少

01:23:38.720 --> 01:23:39.720
我就更新多少

01:23:39.720 --> 01:23:40.720
就是这么个意思

01:23:40.720 --> 01:23:41.720
这是更新

01:23:41.720 --> 01:23:42.720
非常简单

01:23:42.720 --> 01:23:43.720
最后来来一个删除

01:23:43.720 --> 01:23:44.720
没什么好说的了

01:23:44.720 --> 01:23:45.720
给个条件

01:23:45.720 --> 01:23:46.720
满足条件的删除一个

01:23:46.720 --> 01:23:47.720
给个条件

01:23:47.720 --> 01:23:48.720
满足条件的删除多个

01:23:48.720 --> 01:23:49.720
我难得取例子了

01:23:49.720 --> 01:23:50.720
就更新

01:23:50.720 --> 01:23:51.720
那么现在我们就学完了

01:23:51.720 --> 01:23:52.720
这个mango DB里边

01:23:52.720 --> 01:23:54.720
我们今天晚上要掌握的东西

01:23:54.720 --> 01:23:56.720
跟我们后边有相关的东西

01:23:56.720 --> 01:23:57.720
我们都学完了

01:23:57.720 --> 01:23:58.720
这是update

01:23:58.720 --> 01:24:00.720
删除你们可以自己去写一写

01:24:00.720 --> 01:24:01.720
晚上

01:24:01.720 --> 01:24:02.720
那么接下来

01:24:02.720 --> 01:24:03.720
我们要做的事情

01:24:03.720 --> 01:24:04.720
作业

01:24:04.720 --> 01:24:05.720
练习

01:24:05.720 --> 01:24:06.720
有些练习

01:24:06.720 --> 01:24:07.720
你们要自己去说

01:24:07.720 --> 01:24:08.720
有些练习我要讲一讲

01:24:10.720 --> 01:24:12.720
让你编写两个模块

01:24:12.720 --> 01:24:14.720
实现对应的函数

01:24:14.720 --> 01:24:15.720
一定要去实现

01:24:15.720 --> 01:24:16.720
我们后边要用的

01:24:16.720 --> 01:24:18.720
咱们后边是要用的

01:24:18.720 --> 01:24:20.720
明天的课程里边要用

01:24:20.720 --> 01:24:21.720
比方说第一个模块

01:24:21.720 --> 01:24:22.720
user service

01:24:22.720 --> 01:24:23.720
你怎么来写

01:24:23.720 --> 01:24:25.720
你可以在这里面建一个文件夹

01:24:25.720 --> 01:24:27.720
给它取个名字叫service

01:24:27.720 --> 01:24:29.720
表示我有些服务

01:24:29.720 --> 01:24:31.720
或者用复数形式也行

01:24:31.720 --> 01:24:32.720
比方说我们这里用service

01:24:32.720 --> 01:24:33.720
复数

01:24:33.720 --> 01:24:34.720
这里新建两个文件

01:24:34.720 --> 01:24:36.720
一个是user service

01:24:36.720 --> 01:24:38.720
叫js

01:24:38.720 --> 01:24:39.720
一个是什么呢

01:24:39.720 --> 01:24:41.720
一个是news service

01:24:42.720 --> 01:24:44.720
叫js

01:24:44.720 --> 01:24:45.720
对吧

01:24:45.720 --> 01:24:47.720
那么按照常例来说

01:24:47.720 --> 01:24:48.720
我

01:24:48.720 --> 01:24:49.720
这里是不是要

01:24:49.720 --> 01:24:50.720
应该建一个index叫js

01:24:50.720 --> 01:24:51.720
对吧

01:24:51.720 --> 01:24:52.720
把导出

01:24:52.720 --> 01:24:53.720
我们刚才写过了类似的写法

01:24:53.720 --> 01:24:54.720
然后呢

01:24:54.720 --> 01:24:56.720
什么news service

01:24:56.720 --> 01:24:57.720
we require

01:24:57.720 --> 01:24:59.720
news service

01:24:59.720 --> 01:25:00.720
对吧

01:25:02.720 --> 01:25:03.720
然后下面

01:25:03.720 --> 01:25:05.720
exports

01:25:05.720 --> 01:25:07.720
user service

01:25:07.720 --> 01:25:09.720
就是跟用户相关的操作

01:25:09.720 --> 01:25:11.720
跟新闻相关的操作

01:25:11.720 --> 01:25:12.720
把它分成模块来写

01:25:12.720 --> 01:25:14.720
user service

01:25:14.720 --> 01:25:15.720
写好了

01:25:15.720 --> 01:25:16.720
那么这两个模块里面

01:25:16.720 --> 01:25:17.720
去写它的东西

01:25:17.720 --> 01:25:18.720
该导出什么就导出什么

01:25:18.720 --> 01:25:20.720
比方说这个news service

01:25:20.720 --> 01:25:21.720
user service里面

01:25:21.720 --> 01:25:22.720
我这里都跟它写好了

01:25:22.720 --> 01:25:23.720
你去实现就完事了

01:25:23.720 --> 01:25:25.720
你把它复制一下

01:25:25.720 --> 01:25:26.720
你去实现就完事了

01:25:26.720 --> 01:25:29.740
注册不用说了吧

01:25:29.740 --> 01:25:31.740
注册怎么写

01:25:31.740 --> 01:25:32.740
是不是往这里面

01:25:32.740 --> 01:25:33.740
把这个对象加到

01:25:33.740 --> 01:25:34.740
数据库里面去完事了

01:25:34.740 --> 01:25:35.740
我写一个吧

01:25:35.740 --> 01:25:37.740
哪个简单的

01:25:37.740 --> 01:25:39.740
mongus

01:25:39.740 --> 01:25:41.740
就是models

01:25:41.740 --> 01:25:42.740
require

01:25:42.740 --> 01:25:43.740
返回上一级目录

01:25:43.740 --> 01:25:44.740
找到什么了

01:25:44.740 --> 01:25:45.740
找到models

01:25:45.740 --> 01:25:46.740
就完事了

01:25:46.740 --> 01:25:47.740
就从这个模块里面

01:25:47.740 --> 01:25:48.740
导入什么了

01:25:48.740 --> 01:25:49.740
导入这个玩意

01:25:49.740 --> 01:25:50.740
对不对 我之前写过了

01:25:51.740 --> 01:25:52.740
当然你可以导入过后

01:25:52.740 --> 01:25:53.740
得到它的优势

01:25:53.740 --> 01:25:55.740
直接拿到优势

01:25:55.740 --> 01:25:56.740
这样子更加方便

01:25:56.740 --> 01:25:57.740
就看你怎么写

01:25:57.740 --> 01:25:58.740
都一样

01:25:58.740 --> 01:25:59.740
灵活的运用就完事了

01:25:59.740 --> 01:26:01.740
那么这里我们要

01:26:01.740 --> 01:26:03.740
注册无非就是新增

01:26:03.740 --> 01:26:04.740
注册无非就是新增

01:26:04.740 --> 01:26:05.740
优势

01:26:06.740 --> 01:26:08.740
create

01:26:08.740 --> 01:26:09.740
什么了

01:26:09.740 --> 01:26:10.740
优势

01:26:10.740 --> 01:26:11.740
obg

01:26:11.740 --> 01:26:13.740
然后是不是要等待它

01:26:13.740 --> 01:26:14.740
我也只要等待它

01:26:14.740 --> 01:26:15.740
等待完了过

01:26:15.740 --> 01:26:17.740
会返回一个结果

01:26:17.740 --> 01:26:18.740
把这个结果拿到

01:26:18.740 --> 01:26:19.740
把这个结果返回

01:26:19.740 --> 01:26:21.740
对不对 就完事了

01:26:21.740 --> 01:26:22.740
要不要测试一下

01:26:22.740 --> 01:26:23.740
那我们来测试一下吧

01:26:23.740 --> 01:26:24.740
你看我这个地方

01:26:24.740 --> 01:26:25.740
是不是导出了

01:26:25.740 --> 01:26:26.740
导出了过后

01:26:26.740 --> 01:26:27.740
这个地方是不是

01:26:27.740 --> 01:26:28.740
优势导出了

01:26:28.740 --> 01:26:29.740
那我们怎么来测试

01:26:29.740 --> 01:26:30.740
来测试

01:26:31.740 --> 01:26:32.740
来吧

01:26:32.740 --> 01:26:33.740
我们这里就可以使用

01:26:33.740 --> 01:26:34.740
require

01:26:34.740 --> 01:26:35.740
导入什么了

01:26:35.740 --> 01:26:37.740
导入services里面的东西

01:26:37.740 --> 01:26:41.820
services

01:26:42.820 --> 01:26:43.820
那么这个services里面

01:26:43.820 --> 01:26:44.820
是不是有个

01:26:44.820 --> 01:26:45.820
优势services

01:26:45.820 --> 01:26:46.820
这边导入的

01:26:46.820 --> 01:26:47.820
就是一层层导出

01:26:47.820 --> 01:26:49.820
一层层导入就完事了

01:26:49.820 --> 01:26:50.820
这是优势services里面

01:26:50.820 --> 01:26:51.820
是不是有一个require

01:26:51.820 --> 01:26:52.820
对吧

01:26:52.820 --> 01:26:53.820
注册

01:26:53.820 --> 01:26:55.820
那这里面是不是可以写上

01:26:55.820 --> 01:26:56.820
注册用户

01:26:56.820 --> 01:26:57.820
那么注册用户

01:26:57.820 --> 01:26:58.820
我们就随便写一个吧

01:26:58.820 --> 01:26:59.820
随便写一个

01:26:59.820 --> 01:27:01.820
我们在这里随便复制一个

01:27:02.820 --> 01:27:04.820
在我们之前的测试数据里面

01:27:04.820 --> 01:27:07.640
随便复制一个

01:27:07.640 --> 01:27:08.640
再测试一下

01:27:08.640 --> 01:27:09.640
就是每一些个函数

01:27:09.640 --> 01:27:10.640
你要去测试一下

01:27:10.640 --> 01:27:11.640
可能不正确

01:27:11.640 --> 01:27:13.640
因为这里面随便写个账号

01:27:13.640 --> 01:27:14.640
好

01:27:14.640 --> 01:27:15.640
那么这个玩意

01:27:15.640 --> 01:27:16.640
因为它也是一个

01:27:16.640 --> 01:27:17.640
你看

01:27:17.640 --> 01:27:18.640
它是这个逻辑

01:27:18.640 --> 01:27:19.640
我这边用户

01:27:19.640 --> 01:27:20.640
它是不是要等待

01:27:20.640 --> 01:27:21.640
就是这个函数

01:27:21.640 --> 01:27:22.640
是不是要等待别人

01:27:22.640 --> 01:27:23.640
是不是造成了

01:27:23.640 --> 01:27:24.640
这个函数也需要等待

01:27:24.640 --> 01:27:25.640
对不对

01:27:25.640 --> 01:27:28.640
明白我的意思吗

01:27:28.640 --> 01:27:29.640
它要等待

01:27:29.640 --> 01:27:30.640
就是我这个函数

01:27:30.640 --> 01:27:31.640
在执行的过程中

01:27:31.640 --> 01:27:32.640
要去等待它

01:27:32.640 --> 01:27:33.640
是不是造成了

01:27:33.640 --> 01:27:34.640
这个函数也需要等待

01:27:34.640 --> 01:27:35.640
对不对

01:27:35.640 --> 01:27:36.640
这个函数

01:27:36.640 --> 01:27:37.640
是不是也要等待

01:27:37.640 --> 01:27:38.640
你可以这样的想

01:27:38.640 --> 01:27:39.640
所有的标记

01:27:39.640 --> 01:27:40.640
这个函数

01:27:40.640 --> 01:27:41.640
它都需要等待

01:27:41.640 --> 01:27:43.640
所以说这边也是一样

01:27:43.640 --> 01:27:45.640
我也需要等待

01:27:45.640 --> 01:27:47.640
只是简单的把它封装一下

01:27:47.640 --> 01:27:49.640
其他也没有什么区别

01:27:49.640 --> 01:27:52.400
Test

01:27:52.400 --> 01:27:54.400
简单的封装一下

01:27:56.400 --> 01:27:57.400
可以测试一下

01:27:57.400 --> 01:27:58.400
Result

01:27:58.400 --> 01:28:00.710
输出

01:28:00.710 --> 01:28:03.150
没有什么区别

01:28:03.150 --> 01:28:08.450
就是简单的封装一下

01:28:08.450 --> 01:28:10.450
loaded index

01:28:10.450 --> 01:28:12.450
加进去了

01:28:12.450 --> 01:28:13.450
对不对

01:28:13.450 --> 01:28:14.450
出去加进去了

01:28:14.450 --> 01:28:15.450
这是注册

01:28:15.450 --> 01:28:16.450
对吧注册一个用户

01:28:16.450 --> 01:28:17.450
当然如果说

01:28:17.450 --> 01:28:18.450
这些东西数据有误

01:28:18.450 --> 01:28:19.450
比方说我们在重新运行时

01:28:19.450 --> 01:28:20.450
是不是就要报错了

01:28:20.450 --> 01:28:21.450
报错是正常的

01:28:21.450 --> 01:28:22.450
该报错的

01:28:22.450 --> 01:28:24.450
因为它的毕竟这个不正确

01:28:24.450 --> 01:28:25.450
对不对

01:28:25.450 --> 01:28:26.450
这东西不正确

01:28:26.450 --> 01:28:27.450
好

01:28:27.450 --> 01:28:28.450
那么这里也是写完了

01:28:28.450 --> 01:28:29.450
接下来再看

01:28:29.450 --> 01:28:30.450
这边

01:28:30.450 --> 01:28:32.450
我们到Ulta Service里面

01:28:32.450 --> 01:28:33.450
Galaxy有点不写了

01:28:33.450 --> 01:28:35.450
根据ID来获取一个用户

01:28:35.450 --> 01:28:36.450
不写了

01:28:36.450 --> 01:28:37.450
你们自己去写

01:28:37.450 --> 01:28:38.450
我明天

01:28:38.450 --> 01:28:39.450
给大家把一个代码

01:28:39.450 --> 01:28:40.450
给它发下来

01:28:40.450 --> 01:28:41.450
那么这个Maukey

01:28:41.450 --> 01:28:42.450
登录

01:28:42.450 --> 01:28:43.450
登录的时候

01:28:43.450 --> 01:28:44.450
是不是要给过一个账号

01:28:44.450 --> 01:28:45.450
一个密码

01:28:45.450 --> 01:28:46.450
给过一个账号

01:28:46.450 --> 01:28:47.450
然后这里说得很清楚了

01:28:47.450 --> 01:28:49.450
登录成功反回用户对象

01:28:49.450 --> 01:28:50.450
登录失败反回闹

01:28:50.450 --> 01:28:52.450
怎么写呢

01:28:52.450 --> 01:28:53.450
怎么写呢

01:28:53.450 --> 01:28:54.450
你这样子写呗

01:28:54.450 --> 01:28:55.450
你看我们之前

01:28:55.450 --> 01:28:56.450
许多学过的一个

01:28:56.450 --> 01:28:57.450
通过这个模型

01:28:57.450 --> 01:28:59.450
用Fan的

01:28:59.450 --> 01:29:00.450
第一个什么呢

01:29:00.450 --> 01:29:01.450
第一个条件

01:29:01.450 --> 01:29:02.450
条件是啥

01:29:02.450 --> 01:29:03.450
locking ID

01:29:03.450 --> 01:29:04.450
是不是要等于

01:29:04.450 --> 01:29:05.450
这个给我的locking ID

01:29:05.450 --> 01:29:06.450
locking password

01:29:06.450 --> 01:29:07.450
是不是要等于

01:29:07.450 --> 01:29:08.450
这个给我的

01:29:08.450 --> 01:29:09.450
locking password

01:29:09.450 --> 01:29:10.450
就完了嘛

01:29:10.450 --> 01:29:11.450
这个东西要等于它

01:29:11.450 --> 01:29:12.450
这个玩意

01:29:12.450 --> 01:29:13.450
这个玩意

01:29:13.450 --> 01:29:14.450
是不是要等于它

01:29:14.450 --> 01:29:15.450
就完了嘛

01:29:16.450 --> 01:29:17.450
不用什么排序

01:29:17.450 --> 01:29:18.450
什么都不用

01:29:18.450 --> 01:29:19.450
就是查就行了

01:29:19.450 --> 01:29:20.450
看能不能查到东西

01:29:21.450 --> 01:29:22.450
result

01:29:23.450 --> 01:29:24.450
看能不能查到东西

01:29:24.450 --> 01:29:27.450
如果说result的nance

01:29:27.450 --> 01:29:28.450
反回的是一个数组

01:29:28.450 --> 01:29:29.450
对不对

01:29:29.450 --> 01:29:30.450
nance等于0

01:29:30.450 --> 01:29:31.450
是啥

01:29:31.450 --> 01:29:32.450
啥意思

01:29:32.450 --> 01:29:33.450
是不是找不到啊

01:29:33.450 --> 01:29:34.450
找不到账号

01:29:34.450 --> 01:29:35.450
等于这个账号

01:29:35.450 --> 01:29:36.450
密码等于这个密码

01:29:36.450 --> 01:29:37.450
找不到的话

01:29:37.450 --> 01:29:38.450
反回怎么反回

01:29:38.450 --> 01:29:39.450
我写的很清楚了

01:29:40.450 --> 01:29:41.450
如果说能找到的话

01:29:41.450 --> 01:29:42.450
是不是就反回

01:29:42.450 --> 01:29:43.450
这个对象

01:29:43.450 --> 01:29:44.450
反回这个数组的第1项

01:29:44.450 --> 01:29:45.450
登录

01:29:45.450 --> 01:29:46.450
看能不能求个1

01:29:46.450 --> 01:29:49.210
看能不能求个1

01:29:50.210 --> 01:29:51.210
非常简单

01:29:51.210 --> 01:29:52.210
对吧

01:29:52.210 --> 01:29:54.210
那么该是由在你们自己写

01:29:54.210 --> 01:29:55.210
很简单的

01:29:55.210 --> 01:29:56.210
然后下面就是一个

01:29:56.210 --> 01:29:58.210
就是我都给你写完了

01:29:58.210 --> 01:29:59.210
new service

01:29:59.210 --> 01:30:00.210
这个呢

01:30:00.210 --> 01:30:01.210
稍微要反应说一点

01:30:01.210 --> 01:30:05.420
其实也没什么好反应说的

01:30:05.420 --> 01:30:06.420
复制一下吧

01:30:06.420 --> 01:30:07.420
new service

01:30:11.900 --> 01:30:12.900
什么意思呢

01:30:12.900 --> 01:30:13.900
还要分页

01:30:13.900 --> 01:30:14.900
就分页

01:30:14.900 --> 01:30:16.900
给我一个页嘛

01:30:16.900 --> 01:30:17.900
给我一个页容量

01:30:17.900 --> 01:30:18.900
什么叫页容量

01:30:18.900 --> 01:30:20.900
就是每页显示多少条

01:30:21.900 --> 01:30:23.900
给我一个查询关键字

01:30:24.900 --> 01:30:26.900
我要给他一个结果

01:30:26.900 --> 01:30:27.900
就是说

01:30:27.900 --> 01:30:30.900
按照你这个关键字的条件

01:30:30.900 --> 01:30:31.900
我给你查出来的

01:30:31.900 --> 01:30:33.900
总得一共有多少条数据

01:30:33.900 --> 01:30:35.900
但是由于你分了页了

01:30:35.900 --> 01:30:36.900
所以我不可能把

01:30:36.900 --> 01:30:38.900
所有的数据全部给你的

01:30:38.900 --> 01:30:39.900
我给你的一部分

01:30:39.900 --> 01:30:40.900
这是一个新闻数组

01:30:40.900 --> 01:30:41.900
对吧

01:30:41.900 --> 01:30:42.900
这是个分页查询

01:30:42.900 --> 01:30:43.900
分页查询是

01:30:43.900 --> 01:30:44.900
每一个做开发的同学

01:30:44.900 --> 01:30:45.900
不管你是做学前端

01:30:45.900 --> 01:30:46.900
还是学后端

01:30:46.900 --> 01:30:48.900
最最最基本的

01:30:48.900 --> 01:30:49.900
你要掌握的

01:30:50.900 --> 01:30:51.900
那么在芒果地位里面

01:30:51.900 --> 01:30:52.900
怎么来做分页查询呢

01:30:53.900 --> 01:30:54.900
你看啊

01:30:54.900 --> 01:30:56.900
我们来这样子的输利

01:30:56.900 --> 01:30:57.900
首先我们看条件

01:30:58.900 --> 01:30:59.900
条件是什么

01:31:00.900 --> 01:31:01.900
条件不就是

01:31:01.900 --> 01:31:02.900
标题

01:31:02.900 --> 01:31:03.900
等于这个

01:31:03.900 --> 01:31:04.900
包含那个关键字

01:31:04.900 --> 01:31:05.900
内容

01:31:05.900 --> 01:31:06.900
包含那个关键字

01:31:06.900 --> 01:31:07.900
频道

01:31:07.900 --> 01:31:08.900
包含那个关键字

01:31:08.900 --> 01:31:09.900
对吧

01:31:09.900 --> 01:31:10.900
那我们刚才

01:31:10.900 --> 01:31:11.900
回忆一下我们之前的

01:31:11.900 --> 01:31:12.900
写了个六是条件

01:31:12.900 --> 01:31:13.900
打写的

01:31:13.900 --> 01:31:14.900
这样的

01:31:14.900 --> 01:31:15.900
条件打写的

01:31:15.900 --> 01:31:16.900
是不是应该写个

01:31:16.900 --> 01:31:17.900
对吧

01:31:17.900 --> 01:31:18.900
是或者吗

01:31:18.900 --> 01:31:19.900
对吧

01:31:19.900 --> 01:31:20.900
或者关系

01:31:20.900 --> 01:31:21.900
包含该关键字均可

01:31:21.900 --> 01:31:22.900
或者关系

01:31:22.900 --> 01:31:23.900
就是说什么呢

01:31:23.900 --> 01:31:24.900
第一个条件

01:31:24.900 --> 01:31:25.900
就是说我们的

01:31:25.900 --> 01:31:26.900
标题

01:31:26.900 --> 01:31:27.900
title

01:31:27.900 --> 01:31:28.900
包含什么关键字

01:31:28.900 --> 01:31:29.900
对吧

01:31:29.900 --> 01:31:30.900
包含关键字怎么写的

01:31:30.900 --> 01:31:31.900
是不是

01:31:31.900 --> 01:31:32.900
正的表达是

01:31:32.900 --> 01:31:33.900
听我的是不是放中间

01:31:33.900 --> 01:31:34.900
是不是放在这

01:31:34.900 --> 01:31:35.900
但是你能不能

01:31:35.900 --> 01:31:36.900
直接这样子写

01:31:36.900 --> 01:31:37.900
这些是不是把写成

01:31:37.900 --> 01:31:38.900
静态字不错了

01:31:39.900 --> 01:31:40.900
来

01:31:40.900 --> 01:31:41.900
解释基础的知识又来了

01:31:41.900 --> 01:31:42.900
所以说

01:31:42.900 --> 01:31:43.900
你们学到后边

01:31:43.900 --> 01:31:44.900
其实真的考验

01:31:44.900 --> 01:31:45.900
你们真正

01:31:45.900 --> 01:31:46.900
给你们造成考验

01:31:46.900 --> 01:31:47.900
基础

01:31:47.900 --> 01:31:48.900
永远都是基础

01:31:49.900 --> 01:31:50.900
其实你们后边学习到

01:31:50.900 --> 01:31:51.900
很多API的东西

01:31:51.900 --> 01:31:52.900
都是小事

01:31:53.900 --> 01:31:54.900
一看文章都知道了

01:31:54.900 --> 01:31:55.900
关键就在有基础

01:31:55.900 --> 01:31:56.900
你们找不到

01:31:56.900 --> 01:31:57.900
那我这里

01:31:57.900 --> 01:31:58.900
提问的应该是动态的

01:31:58.900 --> 01:31:59.900
怎么办呢

01:32:00.900 --> 01:32:01.900
那这个东西多的

01:32:01.900 --> 01:32:02.900
就更加扯淡了

01:32:02.900 --> 01:32:03.900
你这个

01:32:03.900 --> 01:32:04.900
能这样子写吗

01:32:04.900 --> 01:32:05.900
这个是什么

01:32:05.900 --> 01:32:06.900
正的表达是

01:32:06.900 --> 01:32:07.900
多的表示

01:32:07.900 --> 01:32:08.900
正的表达是结束

01:32:09.900 --> 01:32:10.900
能这样子写吗

01:32:10.900 --> 01:32:11.900
肯定是不能这样子写的

01:32:11.900 --> 01:32:12.900
那怎么办呢

01:32:16.430 --> 01:32:18.430
根据根据没关系

01:32:18.430 --> 01:32:19.430
应该怎么办呢

01:32:19.430 --> 01:32:21.430
应该用new expression

01:32:21.430 --> 01:32:22.430
对吧

01:32:22.430 --> 01:32:23.430
所以应该用这种方式

01:32:23.430 --> 01:32:24.430
这里是不是可以允许你

01:32:24.430 --> 01:32:25.430
用一个制服圈

01:32:25.430 --> 01:32:26.430
来作为正的表达式的内容

01:32:27.430 --> 01:32:28.430
对不对

01:32:28.430 --> 01:32:29.430
所以允许你用一个制服圈

01:32:29.430 --> 01:32:30.430
来作为正的表达式的内容

01:32:30.430 --> 01:32:31.430
所以应该这样子写

01:32:34.900 --> 01:32:35.900
对吧

01:32:35.900 --> 01:32:36.900
应该这样子写

01:32:36.900 --> 01:32:37.900
那么我们把这个放在这

01:32:37.900 --> 01:32:38.900
你永远不要忘记了

01:32:38.900 --> 01:32:39.900
正的表达式

01:32:39.900 --> 01:32:40.900
它只是一个对象而已

01:32:40.900 --> 01:32:41.900
它只是一个对象而已

01:32:41.900 --> 01:32:42.900
两个鞋杠

01:32:42.900 --> 01:32:43.900
只是创建正的表达

01:32:43.900 --> 01:32:45.900
是自面量的一种方式

01:32:47.900 --> 01:32:48.900
如果它不是自面量

01:32:48.900 --> 01:32:50.900
那应该用构造函数来创建

01:32:51.900 --> 01:32:52.900
这是一个条件

01:32:52.900 --> 01:32:53.900
另一个条件是什么呢

01:32:53.900 --> 01:32:54.900
内容

01:32:54.900 --> 01:32:55.900
内容是不是也是

01:32:55.900 --> 01:32:56.900
应该保满足正的表达式的

01:32:56.900 --> 01:32:57.900
对吧

01:32:57.900 --> 01:32:58.900
这条件满足一个就行了

01:32:58.900 --> 01:32:59.900
然后呢

01:32:59.900 --> 01:33:00.900
还有什么呢

01:33:00.900 --> 01:33:01.900
还有频道

01:33:01.900 --> 01:33:02.900
channel

01:33:02.900 --> 01:33:03.900
满足正的表达式就行了

01:33:03.900 --> 01:33:04.900
这三个条件

01:33:04.900 --> 01:33:05.900
或者关系

01:33:05.900 --> 01:33:06.900
都可以

01:33:07.900 --> 01:33:08.900
是不是都可以

01:33:09.900 --> 01:33:10.900
这就是它的条件

01:33:10.900 --> 01:33:11.900
那你是不是还可以

01:33:11.900 --> 01:33:12.900
把这个条件

01:33:12.900 --> 01:33:13.900
写成一个变量

01:33:13.900 --> 01:33:14.900
抗力性

01:33:14.900 --> 01:33:15.900
不要把程序写死了

01:33:15.900 --> 01:33:17.900
程序是极其灵活的

01:33:18.900 --> 01:33:19.900
你被越往后边学

01:33:19.900 --> 01:33:21.900
就会发现程序灵活的不得了

01:33:21.900 --> 01:33:24.270
这样子写可以

01:33:24.270 --> 01:33:25.270
另外一种写法也可以

01:33:25.270 --> 01:33:27.270
不要去把它写死了

01:33:27.270 --> 01:33:28.270
这样子写是不是可以

01:33:28.270 --> 01:33:29.270
无非就是个对象

01:33:29.270 --> 01:33:30.270
因为它条件就是个对象

01:33:30.270 --> 01:33:31.270
所以说我完全可以

01:33:31.270 --> 01:33:32.270
把写到对象里面

01:33:33.270 --> 01:33:34.270
对吧

01:33:34.270 --> 01:33:35.270
这条件

01:33:36.270 --> 01:33:37.270
投印那些

01:33:37.270 --> 01:33:38.270
不写了

01:33:38.270 --> 01:33:39.270
投印就设置为辣

01:33:39.270 --> 01:33:40.270
因为我们说过

01:33:40.270 --> 01:33:41.270
第二个材料就是投印

01:33:41.270 --> 01:33:42.270
就是你要选中哪些字段

01:33:42.270 --> 01:33:43.270
我全部选中

01:33:43.270 --> 01:33:44.270
不用管了

01:33:44.270 --> 01:33:45.270
全部选中

01:33:45.270 --> 01:33:47.270
那么第三个就是分页了

01:33:47.270 --> 01:33:48.270
分页的

01:33:48.270 --> 01:33:49.270
我们是不是

01:33:49.270 --> 01:33:51.270
按照日期的将去排序

01:33:51.270 --> 01:33:52.270
这个很简单

01:33:53.270 --> 01:33:54.270
top date

01:33:54.270 --> 01:33:55.270
按照日期的将去排序

01:33:55.270 --> 01:33:56.270
然后呢

01:33:56.270 --> 01:33:57.270
接下来就是分件了

01:33:58.270 --> 01:34:00.270
第几页没想到的条件

01:34:00.270 --> 01:34:01.270
其实这个很简单

01:34:01.270 --> 01:34:02.270
你稍微转换一下施度

01:34:03.270 --> 01:34:04.270
如果说

01:34:04.270 --> 01:34:05.270
假如啊

01:34:05.270 --> 01:34:06.270
你这样想吧

01:34:06.270 --> 01:34:07.270
第一页

01:34:07.270 --> 01:34:09.270
没想到是10条

01:34:09.270 --> 01:34:11.270
那里的数据是多少呢

01:34:11.270 --> 01:34:13.270
是不是挑过0个

01:34:13.270 --> 01:34:15.270
取多少个

01:34:15.270 --> 01:34:16.270
取10个

01:34:16.270 --> 01:34:17.270
对吧

01:34:17.270 --> 01:34:20.270
挑过0个取10个

01:34:20.270 --> 01:34:23.270
第二页没想到是10条

01:34:23.270 --> 01:34:24.270
skip

01:34:24.270 --> 01:34:25.270
挑过多少个呢

01:34:25.270 --> 01:34:27.270
挑过10个

01:34:27.270 --> 01:34:31.350
取多少个取10个

01:34:31.350 --> 01:34:32.350
第三页

01:34:32.350 --> 01:34:33.350
没想到是10条

01:34:33.350 --> 01:34:34.350
挑过多少个

01:34:34.350 --> 01:34:36.350
挑过20个

01:34:36.350 --> 01:34:38.350
取多少个取10个

01:34:38.350 --> 01:34:39.350
有什么样的规律呢

01:34:39.350 --> 01:34:43.140
第一

01:34:43.140 --> 01:34:45.140
配几页

01:34:45.140 --> 01:34:48.140
每页显示Limit条

01:34:48.140 --> 01:34:49.140
那么挑过多少

01:34:49.140 --> 01:34:53.560
挑过多少呢

01:34:53.560 --> 01:34:57.580
挑过多少啊

01:34:57.580 --> 01:34:58.580
这个应该能看出来吧

01:34:58.580 --> 01:34:59.580
这个

01:35:00.580 --> 01:35:01.580
能看出来吧

01:35:01.580 --> 01:35:02.580
应该

01:35:02.580 --> 01:35:03.580
好好看一样

01:35:04.580 --> 01:35:06.580
我水都喝干了

01:35:07.580 --> 01:35:08.580
配几简易乘以Limit条

01:35:08.580 --> 01:35:09.580
对吧

01:35:09.580 --> 01:35:10.580
你不能把它写死的

01:35:10.580 --> 01:35:11.580
目前倒是10

01:35:11.580 --> 01:35:12.580
但是背景是10的

01:35:12.580 --> 01:35:13.580
我不能把它写死的

01:35:13.580 --> 01:35:15.580
配几简易乘以什么

01:35:15.580 --> 01:35:16.580
Limit条

01:35:16.580 --> 01:35:17.580
那么取多少条呢

01:35:17.580 --> 01:35:19.580
取就是取Limit条

01:35:19.580 --> 01:35:20.580
不对

01:35:21.580 --> 01:35:22.580
扶子粘贴过来

01:35:22.580 --> 01:35:25.140
这就是分页带

01:35:25.140 --> 01:35:26.140
对吧

01:35:26.140 --> 01:35:27.140
你给我第几页

01:35:27.140 --> 01:35:28.140
我就简易乘以Limit条

01:35:28.140 --> 01:35:29.140
挑过这么多

01:35:29.140 --> 01:35:30.140
然后呢

01:35:30.140 --> 01:35:31.140
取多少就取这么多

01:35:31.140 --> 01:35:32.140
对吧 这条件

01:35:32.140 --> 01:35:33.140
那么这样子

01:35:33.140 --> 01:35:34.140
你查出来

01:35:34.140 --> 01:35:35.140
位置

01:35:35.140 --> 01:35:36.140
是不是就是一个数组

01:35:36.140 --> 01:35:37.140
这个数组

01:35:37.140 --> 01:35:38.140
是不是我们的data

01:35:38.140 --> 01:35:39.140
是不是

01:35:39.140 --> 01:35:40.140
就是我们这个玩意儿

01:35:40.140 --> 01:35:41.140
对吧

01:35:42.140 --> 01:35:43.140
我这个玩意儿

01:35:43.140 --> 01:35:44.140
是不是就是我们

01:35:44.140 --> 01:35:45.140
要查的这个数组

01:35:45.140 --> 01:35:46.140
新闻数组是不是出来了

01:35:46.140 --> 01:35:47.140
但是还有一个新闻

01:35:47.140 --> 01:35:48.140
什么总数量

01:35:48.140 --> 01:35:49.140
是不是还要查数量

01:35:49.140 --> 01:35:50.140
对吧

01:35:50.140 --> 01:35:51.140
数量怎么查

01:35:51.140 --> 01:35:52.140
60

01:35:52.140 --> 01:35:53.140
靠

01:35:53.140 --> 01:35:54.140
对吧

01:35:54.140 --> 01:35:55.140
我呢

01:35:55.140 --> 01:35:56.140
不能用这个靠子

01:35:56.140 --> 01:35:57.140
靠子Documents

01:35:57.140 --> 01:35:58.140
虽然用这个

01:35:58.140 --> 01:35:59.140
有没有条件

01:35:59.140 --> 01:36:00.140
当然有条件

01:36:00.140 --> 01:36:01.140
因为这个有keyword

01:36:01.140 --> 01:36:02.140
当然肯定有条件

01:36:02.140 --> 01:36:04.140
那么条件是哪呢

01:36:04.140 --> 01:36:05.140
条件是哪呢

01:36:05.140 --> 01:36:07.140
条件不就是这个费用字吗

01:36:07.140 --> 01:36:08.140
知道吧

01:36:08.140 --> 01:36:09.140
知道我刚才为啥

01:36:09.140 --> 01:36:10.140
把提出去了吧

01:36:10.140 --> 01:36:11.140
提出可以重复用

01:36:11.140 --> 01:36:12.140
你不用才重新写的

01:36:12.140 --> 01:36:14.140
无非就是同一个条件

01:36:14.140 --> 01:36:16.140
同一个条件

01:36:16.140 --> 01:36:17.140
没问题吧

01:36:17.140 --> 01:36:19.140
那么这个数量

01:36:19.140 --> 01:36:20.140
对吧

01:36:20.140 --> 01:36:21.140
好

01:36:21.140 --> 01:36:22.140
那么

01:36:22.140 --> 01:36:23.140
头头

01:36:23.140 --> 01:36:24.140
二位

01:36:24.140 --> 01:36:25.140
也等待

01:36:25.140 --> 01:36:27.580
好

01:36:27.580 --> 01:36:28.580
完了

01:36:28.580 --> 01:36:29.580
完了过后

01:36:29.580 --> 01:36:30.580
我们返回

01:36:30.580 --> 01:36:31.580
返回什么了

01:36:31.580 --> 01:36:32.580
我们返回一个对象

01:36:32.580 --> 01:36:33.580
对象里面一个头发属性

01:36:33.580 --> 01:36:34.580
等于什么

01:36:34.580 --> 01:36:35.580
等于头头

01:36:35.580 --> 01:36:36.580
还有data属性

01:36:36.580 --> 01:36:39.150
等于data属性

01:36:39.150 --> 01:36:40.150
就完了

01:36:43.150 --> 01:36:44.150
好

01:36:44.150 --> 01:36:45.150
咱们来测试一下

01:36:45.150 --> 01:36:46.150
我们这里

01:36:46.150 --> 01:36:47.150
比方说

01:36:47.150 --> 01:36:48.150
我们这一test

01:36:48.150 --> 01:36:49.150
我们这里

01:36:49.150 --> 01:36:50.150
使用这个

01:36:50.150 --> 01:36:52.150
news service

01:36:52.150 --> 01:36:54.150
get news

01:36:54.150 --> 01:36:55.150
每页显示两

01:36:55.150 --> 01:36:56.150
三条

01:36:56.150 --> 01:36:57.150
关键字

01:36:57.150 --> 01:36:58.150
关键字查个啥

01:36:59.150 --> 01:37:00.150
有啥新闻

01:37:00.150 --> 01:37:01.150
查个

01:37:02.150 --> 01:37:05.420
新官

01:37:05.420 --> 01:37:06.420
输出

01:37:06.420 --> 01:37:07.420
result

01:37:07.420 --> 01:37:11.400
运行

01:37:11.400 --> 01:37:16.020
看啥

01:37:16.020 --> 01:37:17.020
所以总数有36个

01:37:17.020 --> 01:37:18.020
对吧

01:37:18.020 --> 01:37:19.020
一共有

01:37:19.020 --> 01:37:20.020
查出来一共有36条数据

01:37:20.020 --> 01:37:21.020
但他给我了几条了

01:37:21.020 --> 01:37:22.020
给我了三条

01:37:22.020 --> 01:37:23.020
一条

01:37:24.020 --> 01:37:25.020
第二条

01:37:27.020 --> 01:37:28.020
第三条

01:37:28.020 --> 01:37:29.020
没了

01:37:29.020 --> 01:37:30.020
要分上一页的

01:37:30.020 --> 01:37:31.020
一共有36条数据

01:37:31.020 --> 01:37:32.020
每页显示三条

01:37:32.020 --> 01:37:33.020
给我第一页

01:37:33.020 --> 01:37:34.020
所以给我三条数据

01:37:35.020 --> 01:37:36.020
如果说我这里写个2

01:37:36.020 --> 01:37:37.020
他就给我

01:37:37.020 --> 01:37:38.020
每页显示三条

01:37:38.020 --> 01:37:39.020
给我第二页

01:37:39.020 --> 01:37:40.020
查询条件还是新官

01:37:41.020 --> 01:37:43.390
不一样吗

01:37:43.390 --> 01:37:44.390
这就查出来了

01:37:44.390 --> 01:37:45.390
我们后端做的是什么

01:37:45.390 --> 01:37:47.390
就是数据处理

01:37:47.390 --> 01:37:48.390
前端

01:37:48.390 --> 01:37:49.390
我们做的是什么

01:37:49.390 --> 01:37:50.390
把这些数据

01:37:50.390 --> 01:37:51.390
渲染到页面上

01:37:51.390 --> 01:37:52.390
每人做一件事

01:37:52.390 --> 01:37:53.390
好

01:37:53.390 --> 01:37:54.390
今天晚上

01:37:54.390 --> 01:37:56.900
我们就把数据处理

01:37:57.900 --> 01:37:58.900
好了

01:37:58.900 --> 01:37:59.900
没了

01:37:59.900 --> 01:38:00.900
今天晚上的东西没了

01:38:00.900 --> 01:38:01.900
东西是有点多

01:38:01.900 --> 01:38:02.900
实际上

01:38:02.900 --> 01:38:03.900
今天晚上的东西

01:38:03.900 --> 01:38:04.900
真的不复杂

01:38:04.900 --> 01:38:05.900
你告诉我哪一块复杂了

01:38:05.900 --> 01:38:06.900
哪一块复杂了

01:38:06.900 --> 01:38:08.900
没有这种地方复杂的

01:38:08.900 --> 01:38:09.900
就是东西读

01:38:09.900 --> 01:38:10.900
没事

01:38:10.900 --> 01:38:11.900
比方说你要

01:38:11.900 --> 01:38:12.900
你首先你要知道干嘛

01:38:12.900 --> 01:38:13.900
你写代码的时候

01:38:13.900 --> 01:38:14.900
你要知道干嘛

01:38:14.900 --> 01:38:15.900
我要做什么

01:38:15.900 --> 01:38:16.900
我要做查询

01:38:16.900 --> 01:38:17.900
OK

01:38:17.900 --> 01:38:18.900
我就看一下查询该怎么做

01:38:18.900 --> 01:38:19.900
查询该怎么做呢

01:38:19.900 --> 01:38:20.900
找到模型

01:38:20.900 --> 01:38:21.900
模型在哪呢

01:38:21.900 --> 01:38:22.900
你至于去找

01:38:22.900 --> 01:38:23.900
你的模型写到哪呢

01:38:23.900 --> 01:38:24.900
然后用什么方法呢

01:38:24.900 --> 01:38:25.900
用办的方法

01:38:25.900 --> 01:38:26.900
那么这个费用手写上

01:38:26.900 --> 01:38:27.900
看一下费用手写怎么写

01:38:27.900 --> 01:38:28.900
那么你想想

01:38:28.900 --> 01:38:29.900
你跟应该怎么写查询条件

01:38:29.900 --> 01:38:30.900
你的查询条件

01:38:30.900 --> 01:38:31.900
那么在这里必须对

01:38:31.900 --> 01:38:32.900
应该用什么样的方式

01:38:32.900 --> 01:38:33.900
来写查询条件

01:38:33.900 --> 01:38:34.900
那么投影呢

01:38:34.900 --> 01:38:35.900
需要去写不需要去拉倒

01:38:35.900 --> 01:38:37.900
那么这一些额外的配置

01:38:37.900 --> 01:38:38.900
需要去写不需要拉倒

01:38:38.900 --> 01:38:40.900
所以你要用这种查询的方式

01:38:40.900 --> 01:38:42.900
来看这个技术问题的话

01:38:42.900 --> 01:38:43.900
很多问题不是问题

01:38:43.900 --> 01:38:44.900
但是你如果说

01:38:44.900 --> 01:38:45.900
你要用API的角度去

01:38:45.900 --> 01:38:47.900
看这个技术问题的话

01:38:47.900 --> 01:38:48.900
那就很多地方全是问题

01:38:48.900 --> 01:38:50.900
因为英文单词又多

01:38:50.900 --> 01:38:52.900
因为乱七八糟的一大堆API

01:38:52.900 --> 01:38:53.900
根本就背不住

01:38:53.900 --> 01:38:54.900
看了冤枉了

01:38:54.900 --> 01:38:55.900
正常的

01:38:55.900 --> 01:38:56.900
但是你要知道逻辑在哪

01:38:56.900 --> 01:38:57.900
我们的学课就是

01:38:57.900 --> 01:38:58.900
增商改查

01:38:58.900 --> 01:38:59.900
是个操纵的

01:38:59.900 --> 01:39:00.900
对不对

01:39:00.900 --> 01:39:01.900
大家要做争

01:39:01.900 --> 01:39:02.900
还是做删

01:39:02.900 --> 01:39:03.900
还是做改

01:39:03.900 --> 01:39:04.900
还是做查

01:39:04.900 --> 01:39:07.210
那就查相应的文章的玩手

01:39:09.210 --> 01:39:12.840
连点福气明天讲

01:39:12.840 --> 01:39:16.660
逻辑都没有清楚

01:39:16.660 --> 01:39:18.660
逻辑没清楚的话

01:39:18.660 --> 01:39:19.660
你重新看一下视频吧

01:39:19.660 --> 01:39:20.660
这个逻辑

01:39:20.660 --> 01:39:21.660
我也不知道男在哪

01:39:21.660 --> 01:39:23.660
问题是没有任何男的地方

01:39:23.660 --> 01:39:25.660
一个用户一个新闻

01:39:25.660 --> 01:39:26.660
增加

01:39:26.660 --> 01:39:27.660
就是增加吧

01:39:27.660 --> 01:39:28.660
就增加一个用户

01:39:28.660 --> 01:39:29.660
增加一个新闻

01:39:29.660 --> 01:39:30.660
查询就是查询

01:39:30.660 --> 01:39:31.660
用户查询新闻

01:39:31.660 --> 01:39:32.660
更新就是更新

01:39:32.660 --> 01:39:33.660
删除删除

01:39:34.660 --> 01:39:35.660
那就好好去看一下

01:39:35.660 --> 01:39:36.660
后边的视频回放

01:39:36.660 --> 01:39:37.660
好吧

01:39:38.660 --> 01:39:39.660
好了

01:39:39.660 --> 01:39:40.660
那我头也讲干了

01:39:40.660 --> 01:39:42.660
我这水倒就喝干了

01:39:42.660 --> 01:39:43.660
我休息了

01:39:43.660 --> 01:39:44.660
卓越就是这些

01:39:45.660 --> 01:39:46.660
卓越就是这些玩意

01:39:46.660 --> 01:39:48.660
你把这东西写一遍

01:39:48.660 --> 01:39:49.660
是不是因为

01:39:49.660 --> 01:39:50.660
又开始出现了幻觉了

01:39:50.660 --> 01:39:51.660
又开始出现了幻觉

01:39:51.660 --> 01:39:52.660
觉得这东西简单

01:39:52.660 --> 01:39:53.660
应该不用写

01:39:54.660 --> 01:39:55.660
所以说出现了幻觉

01:39:55.660 --> 01:39:56.660
如果说你以前写过

01:39:56.660 --> 01:39:57.660
这种做法

01:39:57.660 --> 01:39:59.660
写过的类似的代码

01:39:59.660 --> 01:40:00.660
是写过的

01:40:00.660 --> 01:40:01.660
那你可以不用写

01:40:01.660 --> 01:40:02.660
那你可以

01:40:02.660 --> 01:40:03.660
接到我后边听就行了

01:40:03.660 --> 01:40:04.660
但是如果说你

01:40:04.660 --> 01:40:05.660
但是你后边学习的话

01:40:05.660 --> 01:40:06.660
我们要做个效果出来

01:40:06.660 --> 01:40:07.660
你还是得写

01:40:08.660 --> 01:40:09.660
如果说你没有写过的话

01:40:09.660 --> 01:40:10.660
你一定要去写一遍

01:40:10.660 --> 01:40:12.660
千万不要出现幻觉了

01:40:13.660 --> 01:40:14.660
好

01:40:14.660 --> 01:40:15.660
来吧

01:40:15.660 --> 01:40:16.660
那我就讲到这了

