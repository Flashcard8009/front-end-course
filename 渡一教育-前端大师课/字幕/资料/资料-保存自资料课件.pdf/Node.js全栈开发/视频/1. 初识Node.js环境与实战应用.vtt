WEBVTT

00:00.580 --> 00:01.580
控制一下情绪啊

00:02.580 --> 00:06.280
那咱们就不废话了啊 直接开始 这五天呢 咱们是讲这个漏的

00:07.380 --> 00:12.180
漏的呢 最近我刚发布完 录了之前预算的时候呢

00:12.680 --> 00:17.180
打算录四十节课 结果录出来了录了有七十节课

00:17.580 --> 00:18.580
有越录越多

00:19.380 --> 00:25.280
不过呢 讲的应该是在目前的所有培训机构里边啊 应该是讲的是最权的

00:25.380 --> 00:27.980
我能够想到的 如果说后边忘了的话

00:28.080 --> 00:31.180
有些东西忘了我讲的话 我再给他补充上啊

00:31.880 --> 00:34.780
能想到的基本上是讲完了啊 非常非常全了

00:34.980 --> 00:41.980
那么这五天呢 是其实就是在那个课程里边 给他惊炼的去提取了一些最核心 最基础的东西啊

00:42.580 --> 00:46.480
实际上呢 学习漏的还是需要一些前置知识的

00:47.380 --> 00:52.980
但是我们这个极性赢了 因为要面向很多的可能是基础比较薄热的同学

00:52.980 --> 00:55.580
所以说我们把前置知识呢 一部分一部分砍

00:55.780 --> 00:58.580
砍到后边呢 只剩下ATM和CSS和GS的

00:58.780 --> 01:00.780
也就是你听这五天的极性赢

01:01.780 --> 01:07.080
你只需要学习ATM和CSS以及GS基础 主要是GS基础就可以了

01:07.680 --> 01:11.980
但是你要去深入的了解漏的里边更多的知识的话 你还要学习更多的知识啊

01:12.780 --> 01:17.180
好 来吧 咱们就直接开始 今天晚上呢 就这几天的时间啊

01:18.080 --> 01:24.380
时间有限 所以说我们要最漏的的讲解呢 主要是集中在他最核心的东西

01:24.680 --> 01:30.880
因为很多同学呢 学前端没有怎么接触过后端 不知道后端是什么样子的

01:31.180 --> 01:34.980
说这几天的东西呢 我们相当于是给大家把这个拼图啊 拼完整

01:35.980 --> 01:40.980
前端其实也需要知道后端一些知识 你像你们以后在特别是大城市

01:41.380 --> 01:45.780
一二线城市去就业的时候 很多公司都要求前端开发人员

01:45.980 --> 01:49.380
不说你会写多少了 以后端是怎么回事你得知道

01:49.980 --> 01:54.280
不然的话你经常在公司里边跟后端同学打架 跟后端同事打架也不是个事 对不对

01:54.380 --> 02:01.580
说的有点夸张啊 实际上就是说明这个交流是有障碍的 因为后端啊 他往往是了解前端的

02:02.380 --> 02:08.580
不说别的吧 不像什么view啊reaction一框架可能不懂 但是呢 前端的也就是介石 他是懂的

02:09.380 --> 02:17.780
但是后前端的同学呢 可能完全不了解后端啊 这是前几年的一个情况 但是学着咱们技术的发展

02:18.780 --> 02:27.580
现在呢 市面上的很多公司都要求前端开发者呢 要知道一些后端的东西啊 甚至呢 要可能会自己要求你能够搭建一些后端的服务器

02:27.780 --> 02:29.780
说这几天的课程对你们来说也挺重要的

02:30.780 --> 02:33.580
好 那咱们废话不多说啊 直接开始来进入这个漏的学期

02:34.080 --> 02:39.280
今天呢我们主要是认识漏的里边的一些核心概念来搭建一个漏的开发环境

02:39.580 --> 02:42.380
好 我们这里首先说一下啊 跟漏的环境到底是怎么回事

02:43.380 --> 02:48.180
这里呢 我居然准备了两张图 一个是浏览器环境 一个是漏的环境

02:49.380 --> 02:53.380
浏览器环境大家都接触过的啊 我们写的介石呢 是交给浏览器执行的

02:53.680 --> 02:57.680
那么这样的环境是怎么回事呢 就是你的介石代码 它到底写的是个啥

02:58.480 --> 03:03.980
写的是个啥呢 一是一个是耶稣语法 什么叫耶稣语法 它是一个语言标准

03:04.880 --> 03:08.080
你们可能有的人都还没有听说过这个耶稣这个词啊

03:08.680 --> 03:14.080
它实际上是一个语言标准 你们在介石里面使用的那个定义辨量 VAR 对吧

03:14.380 --> 03:19.580
或者是使用判断 IF 或者是使用 FOR 循环 这些语法规则

03:20.180 --> 03:25.080
就是使用的是耶稣语法 那么什么叫做浏览器API呢

03:25.380 --> 03:29.580
就是除了语法层面的东西之外 浏览器还给你提供了一些API

03:29.880 --> 03:34.880
什么叫API 就是一些对象啊 一些函数啊这些东西 可以让你使用 浏览器能看得懂

03:35.380 --> 03:39.380
那么这些API呢 无论是语法和API 它都交给浏览器执行

03:40.180 --> 03:45.380
那么浏览器给你提供了哪些API呢 比方说窗口的操作能力

03:46.080 --> 03:54.180
什么 Set Timeout 或者是 Console Log 或者是 Set Interval 或者是获取窗口的尺寸

03:54.180 --> 03:56.780
这些东西呢 都是属于浏览器给你提供的API

03:56.980 --> 04:00.580
包括什么页面上的动物元素 怎么来操作动物元素

04:00.580 --> 04:03.180
这些也是属于浏览器给你提供的API

04:03.380 --> 04:05.180
那么这些东西全是交给浏览器执行

04:05.380 --> 04:11.380
浏览器在执行的时候呢 最终它会把这些代码翻译成操作系统能够看得懂的语言

04:11.880 --> 04:14.880
交给操作系统去执行 它是这么一种模具

04:15.680 --> 04:20.180
而另一方面呢 就是loader环境是什么呀 loader环境是跟浏览器环境差不多

04:21.080 --> 04:24.680
你可以看到这个图里边loader环境呢也是写介事代码

04:24.980 --> 04:28.480
代码的写法呢都是一样的 使用的语法也完全一样

04:28.480 --> 04:32.680
定义辨量 循环判断完全一样 还是使用一页式语法

04:33.280 --> 04:35.480
但是呢 它就没有浏览器的API了

04:35.480 --> 04:37.180
因为它不在浏览器里边执行

04:37.680 --> 04:39.980
它在哪执行呢 它在loader环境里边执行

04:41.680 --> 04:44.880
有点卡吧 有点卡刷新一下 刷新一下

04:45.880 --> 04:49.080
我今天那个网线坏了 所以说我没有插有线网

04:49.080 --> 04:53.180
我用的是无线网 无线网可能稍微的插那么一点点

04:53.280 --> 04:56.080
但是也插不掉大区 因为我的路由器就在我旁边

04:56.180 --> 04:59.180
就在我手旁边 我这个网间没问题的

04:59.480 --> 05:02.480
那么我的介事代码实际上是交给另外一个环境

05:02.480 --> 05:04.180
叫loader环境 交给它来执行

05:04.180 --> 05:06.880
就是我们介事代码的执行环境是不一样的

05:07.380 --> 05:09.680
而环境不同了 就会造成API不一样

05:09.680 --> 05:12.580
你看这两张图无非差一点就在哪呢 差一点就在API

05:13.480 --> 05:16.580
loader的API实际上要比浏览器的API多很多很多

05:16.880 --> 05:19.480
多超级多 只不过那么平时用的呢

05:19.580 --> 05:22.980
没有那么多 这是两个环境的区别

05:23.880 --> 05:25.580
那么这两个环境具体有什么区别呢

05:25.580 --> 05:26.780
一个就是API不同

05:27.180 --> 05:29.180
你看这两张图里边不就是API不同吗

05:29.680 --> 05:31.580
由于API不同 我们可以对比一下

05:31.680 --> 05:34.580
浏览器里边的API它提供的功能是有限的

05:34.980 --> 05:36.580
为什么它给你提供有限的功能呢

05:36.580 --> 05:38.580
它为什么不给你提供完整的功能呢

05:38.580 --> 05:44.580
因为用户上网的时候 是不是会执行你写的介事代码

05:45.380 --> 05:47.380
用户是信任浏览器的

05:47.380 --> 05:49.880
如果说你给你提供完整的介事功能的话

05:49.880 --> 05:51.080
就会导致一个问题

05:51.380 --> 05:53.780
用户莫名其妙地执行了一些危险的代码

05:53.780 --> 05:55.380
是不是造成了一些安全性问题

05:55.580 --> 05:57.380
对不对 所以说浏览器呢

05:57.380 --> 06:00.580
它为了安全 为了保护用户的隐私

06:00.680 --> 06:02.380
它很多功能是不给你提供的

06:02.880 --> 06:05.580
比方说你要随意地读取用户电脑上的文件

06:06.380 --> 06:08.580
因为我记得好多年好多年以前

06:08.580 --> 06:10.280
我刚刚毕业的时候那家公司

06:10.380 --> 06:14.280
他让我能不能让用户看我们网站的时候

06:14.280 --> 06:15.780
把他蹬在登录的QQ号

06:16.880 --> 06:18.580
发送到我们网站把它记住下来

06:19.080 --> 06:20.980
我说承切做不到 这个东西真做不到

06:20.980 --> 06:22.380
因为浏览器它不准利这样做

06:22.380 --> 06:23.980
除非你要写个病毒

06:23.980 --> 06:25.380
让用户中毒才行

06:25.380 --> 06:28.080
否则的话这个浏览器是不会鱼去的这样做的

06:28.080 --> 06:29.580
因为浏览器有安全限制

06:30.080 --> 06:31.180
可以说明一个道理就是

06:31.180 --> 06:33.380
浏览器里边很多事情你是不能做的

06:34.680 --> 06:36.380
但是在Note里面就不一样了

06:36.380 --> 06:38.780
Note它是提供了非常完整的功能

06:38.780 --> 06:40.680
你在操作系统上能做的事情

06:40.680 --> 06:42.380
在Note的环境里面都能做

06:42.380 --> 06:44.280
它都给你提供了相应的API

06:44.280 --> 06:45.880
包括什么文件处理

06:45.880 --> 06:47.180
包括进程的控制

06:47.180 --> 06:51.580
甚至利用Note可以推出的QQ微信

06:51.580 --> 06:53.080
或者是进入一个游戏

06:53.080 --> 06:54.480
进程控制它也可以做

06:54.480 --> 06:56.080
在浏览器里面是不能做的

06:56.080 --> 06:57.180
还有网络通信

06:57.180 --> 06:58.780
这些事情的操作系统能做的

06:58.780 --> 06:59.980
在Note的环境里面都能做

06:59.980 --> 07:02.380
所以我们可以看到Note的功能来更加完整

07:02.980 --> 07:05.380
只不过用户链脑上一般不会安装Note的

07:05.380 --> 07:06.580
它一般就会安装浏览器

07:06.580 --> 07:07.980
它不会安装这个环境

07:07.980 --> 07:09.980
我们这个环境一般是在服务器用的

07:09.980 --> 07:13.380
我们应该是在明天后天讲服务器

07:13.380 --> 07:15.180
我们今天只是认识一下Note的

07:15.180 --> 07:17.180
另外一个是使用场景上来看

07:17.180 --> 07:19.680
就是我们以后在具体的工作中

07:19.680 --> 07:23.080
哪些地方我们要写浏览器能识别的介石

07:23.080 --> 07:26.180
哪些地方我们要写Note的能识别的介石

07:26.180 --> 07:27.580
在Note里面写的介石

07:27.580 --> 07:29.580
我们把它叫做Note的介石

07:29.580 --> 07:30.780
浏览器里面的介石

07:30.780 --> 07:33.180
我们主要是为了提高用户体验

07:33.180 --> 07:35.980
就是用户来访问我们的网页

07:35.980 --> 07:37.780
我们用介石给它做出很多好看的

07:37.780 --> 07:38.880
好玩的动画效果

07:38.880 --> 07:39.280
对吧

07:39.280 --> 07:40.780
也动态效果

07:40.780 --> 07:43.180
甚至我们可以获取从服务器获取一些数据

07:43.180 --> 07:44.180
我们通过网络通信

07:44.180 --> 07:46.080
从服务器获取一些数据

07:46.080 --> 07:47.580
这是浏览器里面的介石

07:47.580 --> 07:50.580
Note的介石我们往往在公司里面开发的时候

07:50.580 --> 07:51.980
往往是提供Web服务

07:51.980 --> 07:53.980
那么什么叫做Web服务

07:53.980 --> 07:56.380
什么又怎么来写这个Web服务

07:56.380 --> 07:59.180
我们在明天后天的课程里面再详细说

07:59.180 --> 08:01.180
我们今天只是安装了解一下就行了

08:01.180 --> 08:02.680
他们的关系大概是这样子

08:02.680 --> 08:05.680
就是我们以后写完了一个完整的网站

08:05.680 --> 08:09.480
就是如果说我们网站从浏览器端写到服务器端

08:09.480 --> 08:10.380
两边都写完了

08:10.380 --> 08:13.280
他们之间有什么样的关系呢

08:13.280 --> 08:15.180
在浏览器端写的介石

08:15.180 --> 08:17.580
就是这个介石给浏览器执行的

08:17.580 --> 08:20.080
那么它里面可能会用到一些数据

08:20.080 --> 08:21.680
比如说新闻列表啊

08:21.680 --> 08:22.480
电影列表啊

08:22.480 --> 08:24.080
用户信息之类的数据

08:24.080 --> 08:26.680
它可能要从服务器去获取

08:26.680 --> 08:27.280
它怎么获取

08:27.280 --> 08:29.280
它是通过一个技术叫阿迦克斯

08:29.280 --> 08:30.580
从服务器去获取

08:30.580 --> 08:31.380
而服务器呢

08:31.380 --> 08:32.580
就可以支持很多语言了

08:32.580 --> 08:34.280
比方加把写一个服务器

08:34.280 --> 08:36.680
c下pagp这些都可以写服务器

08:36.680 --> 08:39.380
而我们现在介石也可以写服务器了

08:39.380 --> 08:40.180
那么这个服务器呢

08:40.180 --> 08:41.780
就是个漏的环境

08:41.780 --> 08:42.980
你可以在头脑中想想啊

08:42.980 --> 08:44.480
我们将来在公司里面

08:44.480 --> 08:46.180
真实的运行环境里面呢

08:46.180 --> 08:48.180
就是用户那边是一个扭烂期

08:48.180 --> 08:50.180
在执行我们写的介石

08:50.180 --> 08:51.680
然后服务器那边呢

08:51.680 --> 08:53.480
是一个漏的环境

08:53.480 --> 08:55.380
它里面也在运行段介石

08:55.380 --> 08:57.180
有两都是用介石写的

08:57.180 --> 08:57.580
但是呢

08:57.580 --> 08:59.180
它们的功效是不一样的

08:59.180 --> 08:59.980
是它们的关系

08:59.980 --> 09:00.680
能听懂吧

09:00.680 --> 09:01.280
更加很简单

09:01.280 --> 09:01.680
对吧

09:01.680 --> 09:02.480
它们有个共同点

09:02.480 --> 09:03.980
就是都能够执行

09:03.980 --> 09:05.180
一页是标准的语言

09:05.180 --> 09:05.780
它们的一页

09:05.780 --> 09:08.080
它们的执行的语言标准是一样的

09:08.080 --> 09:09.380
这是关于漏的环境

09:09.380 --> 09:15.670
简单的介绍一下

09:15.670 --> 09:17.170
爬虫我们在后期的像

09:17.170 --> 09:18.970
后期的漏的里面有讲

09:18.970 --> 09:19.970
但是这五天呢

09:19.970 --> 09:21.870
估计是没有时间讲了

09:21.870 --> 09:23.470
漏起是不复杂

09:23.470 --> 09:25.870
它是基本原类分件

09:25.870 --> 09:27.470
第二个就是漏的安装

09:28.370 --> 09:29.370
你们去这个网

09:29.370 --> 09:29.970
这个地址

09:29.970 --> 09:32.170
我在这里面发下来

09:32.170 --> 09:32.670
这个地址

09:32.670 --> 09:33.870
现在就可以去下载

09:33.870 --> 09:34.870
主要你网说过后

09:34.870 --> 09:36.070
不影响你听课的话

09:36.070 --> 09:36.970
你就可以下载

09:36.970 --> 09:38.170
进入这个地址过后呢

09:41.070 --> 09:42.270
进入这个地址过后

09:43.670 --> 09:44.570
下载哪个版本呢

09:44.570 --> 09:46.570
下载就是下载长期知识版

09:46.570 --> 09:48.170
我不管你们那边长期知识版是

09:48.170 --> 09:48.870
应该是一样的

09:48.870 --> 09:51.070
现在是在直播

09:51.070 --> 09:52.870
12.2 16.3

09:52.870 --> 09:54.970
长期知识版去下载就完事了

09:54.970 --> 09:55.870
它有一个追行版本

09:55.870 --> 09:56.470
追行版本呢

09:56.470 --> 09:58.870
我们一般在开在试验的时候

09:58.870 --> 10:00.670
如果说你要长先去体验一下

10:00.670 --> 10:01.370
追行功能的话

10:01.370 --> 10:02.770
可以下载追行版

10:02.770 --> 10:03.270
但是呢

10:03.270 --> 10:05.170
一般在真正的公司里面开发的话

10:05.170 --> 10:06.270
一般都是长期知识版

10:06.270 --> 10:07.270
因为追行版里边

10:07.270 --> 10:09.170
还有一些不太稳定的东西

10:09.170 --> 10:10.070
刚才有同学说到了

10:10.070 --> 10:11.270
这个漏的版本

10:11.270 --> 10:13.070
漏的版本实际上是这样子啊

10:13.070 --> 10:14.370
它有两个分水里

10:14.370 --> 10:16.070
一个是10这个版本

10:16.070 --> 10:17.170
漏的10这个版本

10:17.170 --> 10:18.870
一个是12这个版本

10:18.870 --> 10:20.070
有两个分水里

10:20.070 --> 10:21.170
这两个版本呢

10:21.170 --> 10:22.470
更新的东西都比较多

10:22.470 --> 10:23.970
更新的动作也比较大

10:23.970 --> 10:25.370
现在就是12.16

10:25.570 --> 10:26.870
你们下载追行版就完事了

10:28.670 --> 10:29.770
下载完了过后呢

10:29.770 --> 10:30.570
安装怎么安装呢

10:30.570 --> 10:31.970
安装实际上非常简单

10:32.770 --> 10:35.470
next next next finish

10:35.470 --> 10:36.570
下一步下一步完成

10:36.570 --> 10:37.070
就完事了

10:37.070 --> 10:37.870
啥都不用改

10:37.870 --> 10:39.270
啥都不要去改它

10:39.270 --> 10:40.670
安装完成就完事了

10:40.670 --> 10:41.470
没有什么好说的

10:41.470 --> 10:42.670
你们去安装就知道了

10:42.670 --> 10:44.070
真的没有什么好说的

10:44.070 --> 10:45.270
安装完了过后呢

10:45.270 --> 10:46.370
你要去验证一下

10:46.370 --> 10:47.970
你是不是安装成功了

10:47.970 --> 10:49.270
怎么验证呢

10:49.270 --> 10:51.370
你安住windows键加R

10:52.970 --> 10:53.670
今天发一下

10:55.570 --> 10:57.070
windows键加R

10:57.070 --> 10:57.870
就是这个

10:57.870 --> 10:59.270
windows平台就是个MSI

10:59.970 --> 11:02.470
加R输入一个CMD

11:02.470 --> 11:03.570
打开控制台

11:03.570 --> 11:05.370
控制台里边输入load

11:06.370 --> 11:08.570
横杠V一回车

11:08.570 --> 11:09.770
我这里好像不是16

11:09.770 --> 11:10.270
无所谓

11:11.570 --> 11:12.570
我这个版本是

11:13.370 --> 11:14.870
12.14.0

11:14.870 --> 11:15.970
那么可以通过这个命令

11:15.970 --> 11:17.270
可以查看load的版本

11:18.170 --> 11:19.070
如果说你这个命令

11:19.070 --> 11:20.470
能够成功的识别出来

11:20.470 --> 11:21.770
说明load的安装没问题了

11:22.870 --> 11:24.670
另外load的安装完了过后呢

11:24.670 --> 11:26.770
它会自动的帮你安装一个NPM

11:26.770 --> 11:27.970
NPM到底是什么东西呢

11:27.970 --> 11:29.170
我们一会就知道了

11:29.170 --> 11:30.570
我们一会会讲

11:30.570 --> 11:32.470
它会自带的安装一个NPM

11:32.470 --> 11:34.470
所以我们可以理解它为什么

11:34.470 --> 11:35.770
一个全家统

11:35.770 --> 11:36.970
一个强制安装

11:36.970 --> 11:38.170
那么我们来看一下NPM

11:38.170 --> 11:38.970
有没有安装成功

11:38.970 --> 11:40.370
我们可以输入NPM

11:40.370 --> 11:40.970
钢杯

11:41.970 --> 11:43.970
我这边版本是6.13

11:43.970 --> 11:45.670
里面应该差不多

11:45.670 --> 11:46.270
那么这两个

11:46.270 --> 11:47.470
如果说测试没问题的话

11:47.470 --> 11:49.270
那么load安装成功了

11:49.270 --> 11:51.570
这是关于load的安装

11:51.570 --> 11:52.670
安装完了过后

11:52.770 --> 11:55.470
接下来就马上来编写一个load的程序

11:55.470 --> 11:56.770
那怎么来编写个load的程序呢

11:56.770 --> 12:00.870
随便一个位置去建立一个文件夹

12:00.870 --> 12:02.470
里边存放load的营用

12:02.470 --> 12:03.870
比方说我们就在这吧

12:03.870 --> 12:06.870
新建一个文件夹

12:06.870 --> 12:11.970
给它取个名字叫做myfirstload

12:11.970 --> 12:13.270
就随便取个名字

12:13.270 --> 12:14.370
一个文件夹

12:14.370 --> 12:15.970
然后把这个文件夹放到哪呢

12:15.970 --> 12:16.970
放到vscode里边

12:16.970 --> 12:18.070
拖进来

12:18.070 --> 12:18.770
放进来

12:20.670 --> 12:22.470
用vscode来打开这个文件夹

12:22.470 --> 12:23.870
然后这个文件夹里边

12:23.870 --> 12:25.770
从此以后就没有什么页面了

12:25.770 --> 12:27.170
不要去写什么css

12:27.170 --> 12:28.770
不要去写什么atmr

12:28.770 --> 12:31.170
那么这些东西都是浏览器相关的

12:31.170 --> 12:33.070
load里边就只有js

12:33.070 --> 12:34.670
所以你随便写个js

12:34.670 --> 12:36.470
js文件名字无所谓

12:36.470 --> 12:37.170
应这个是吧

12:37.170 --> 12:38.970
比方说叫js

12:38.970 --> 12:40.570
那么这个js里边写啥呢

12:40.570 --> 12:41.570
随便写啥

12:41.570 --> 12:44.670
只要你符合es标准的代码都可以写

12:44.670 --> 12:47.470
比方说我们这里就输出一个

12:47.470 --> 12:48.370
一条输出语句

12:48.370 --> 12:49.670
输出一个123

12:50.670 --> 12:52.670
或者是输出一个正常的吧

12:52.670 --> 12:53.970
Hello

12:53.970 --> 12:56.370
load还是要一点仪式感

12:56.370 --> 12:57.570
好

12:57.570 --> 12:59.270
保存

12:59.270 --> 13:01.370
那么现在我们的js代码就写完了

13:01.370 --> 13:02.570
好 写完怎么运行的

13:02.570 --> 13:03.870
从此以后我们的代码呢

13:03.870 --> 13:05.870
它不再浏览器端运行的

13:05.870 --> 13:06.570
说这两天呢

13:06.570 --> 13:09.670
如果说里心里边想看到非常丰富的效果

13:09.670 --> 13:10.870
不好意思没有

13:10.870 --> 13:13.170
因为这不是浏览器端要做的事

13:13.170 --> 13:14.970
这不是load服务器要做的事

13:14.970 --> 13:15.970
服务器没有什么效果

13:15.970 --> 13:17.370
它关注的是数据

13:17.370 --> 13:21.770
我们主要是把另外一块拼图给大家讲了

13:21.770 --> 13:22.870
好了 怎么运行呢

13:22.870 --> 13:23.770
运行的时候呢

13:23.770 --> 13:26.570
你要进入这个cmd来运行

13:26.570 --> 13:27.670
就是这个控制台

13:27.670 --> 13:28.970
这个控制台怎么运行呢

13:28.970 --> 13:31.270
你要首先要进入这个目录

13:31.270 --> 13:32.570
比方说我们目录在这

13:32.570 --> 13:34.770
你可以把这个目录复制一下

13:34.770 --> 13:35.270
复制一下

13:35.270 --> 13:36.770
然后我们这里先切换盘幅

13:36.770 --> 13:37.770
切换到地盘

13:37.770 --> 13:38.870
因为我这里来地盘

13:38.870 --> 13:40.470
然后使用cd秘密

13:41.770 --> 13:43.170
一个双腰

13:43.170 --> 13:44.470
进入到这个目录

13:44.470 --> 13:45.670
你看是不是进入到这个目录了

13:45.670 --> 13:47.570
前面提示服势这个目录

13:47.570 --> 13:49.170
然后我们要运行哪个文件呢

13:49.170 --> 13:51.370
我们要运行这个index.js这个文件

13:51.370 --> 13:54.570
OK 那么我们现在使用loadindex

13:54.570 --> 13:55.770
可以不用写后维

13:55.770 --> 13:57.470
.js可以写也可以不写

13:57.470 --> 13:59.770
我们这样子使用这个命令一回车

13:59.770 --> 14:01.470
你看是不是就输出了这个结果

14:01.470 --> 14:02.670
它得这样子运行

14:02.670 --> 14:05.470
如果说你之前接触过什么C语言C++

14:05.470 --> 14:06.970
或者是夹棒

14:06.970 --> 14:08.370
是不是有点类似

14:08.370 --> 14:10.070
对夹棒你们刚开始学的时候

14:10.070 --> 14:11.870
是不是也让你用这种方式来玩

14:11.870 --> 14:13.070
对不对

14:13.070 --> 14:13.870
那么这就是

14:14.070 --> 14:16.570
它其实像load的这个东西

14:16.570 --> 14:18.570
它是属于后端的部分了

14:18.570 --> 14:20.870
因此本质上

14:20.870 --> 14:22.070
从功能的角度来说

14:22.070 --> 14:23.870
夹棒能做的事它都能做

14:23.870 --> 14:25.370
都能做的

14:25.370 --> 14:26.870
所以说这里的就是不是运行出来了

14:26.870 --> 14:27.270
对不对

14:27.270 --> 14:28.070
就运行出来了

14:28.070 --> 14:28.770
好 这样子

14:28.770 --> 14:31.070
但是有的时候运行很麻烦

14:31.070 --> 14:32.070
因为我们要打开控制台

14:32.070 --> 14:33.270
要去进入这个目录很麻烦

14:33.270 --> 14:35.970
我们也可以在这里点击右键

14:35.970 --> 14:37.970
在中端中打开

14:37.970 --> 14:39.370
你看这里是不是开一个中端

14:39.370 --> 14:40.370
在中端中里边

14:40.370 --> 14:42.070
就在vscode里边也可以直接运行

14:42.070 --> 14:43.370
你看这里是不是一个中端

14:43.370 --> 14:46.170
对吧 它也是一个目录提示服

14:46.170 --> 14:47.670
然后我们这里是用load的

14:47.670 --> 14:48.470
index

14:48.470 --> 14:48.970
回车

14:48.970 --> 14:50.370
你看是不是也可以得到结果

14:50.370 --> 14:50.570
对吧

14:50.570 --> 14:52.170
也可以用这种方式来运行

14:52.170 --> 14:53.170
也可以呢

14:53.170 --> 14:54.470
我比较喜欢的方式

14:54.470 --> 14:56.170
还是要单独去开一个窗口

14:56.170 --> 14:59.170
所以说你可以在vscode里面去设置一下

14:59.170 --> 15:04.070
在文件首选像这个设置里边

15:04.070 --> 15:08.370
设置里边去找一下这个叫做terminal

15:08.370 --> 15:09.470
中端

15:09.470 --> 15:12.670
中端的explore

15:13.670 --> 15:15.170
explore

15:15.170 --> 15:16.670
就这个玩意

15:16.670 --> 15:18.470
中端的启动的中端类型

15:18.470 --> 15:20.270
你把它选择为extrinal

15:20.270 --> 15:21.570
表示外部中端

15:21.570 --> 15:25.170
它默认的是集成中端

15:25.170 --> 15:26.370
默认是集成中端

15:26.370 --> 15:28.070
就在vscode里面打开中端

15:28.070 --> 15:29.570
那么你可以把设置为外部的

15:29.570 --> 15:30.670
设置为外部了之后

15:30.670 --> 15:31.970
你在这里点击右键

15:31.970 --> 15:32.670
中端中打开了

15:32.670 --> 15:34.470
你看直接可以开了一个cmd

15:34.470 --> 15:36.170
而且目录已经到这个目录了

15:36.170 --> 15:36.370
对吧

15:36.370 --> 15:37.170
所以非常方便

15:37.170 --> 15:39.570
我们在这里出loading这个事

15:39.570 --> 15:40.870
可以看到执行结果

15:40.870 --> 15:41.370
没问题吧

15:41.370 --> 15:43.870
这就是load的执行

15:43.870 --> 15:44.870
非常简单

15:44.870 --> 15:46.870
这是这一部分

15:46.870 --> 15:48.370
后边慢慢来

15:48.370 --> 15:50.070
现在我们开始进入loading去认识

15:50.070 --> 15:52.070
里边有些东西了

15:52.070 --> 15:54.070
我们首先要认识的是load里边

15:54.070 --> 15:57.270
有一个全局对象叫做globo

15:57.270 --> 15:58.270
这有点对比

15:58.270 --> 16:03.270
对比下来有点类似于浏览器里边的

16:03.270 --> 16:04.070
比加碼好

16:04.070 --> 16:05.770
因为它是介式语言

16:05.770 --> 16:07.270
介式语言是不用编译的

16:07.270 --> 16:09.070
对不对

16:09.070 --> 16:11.270
后边都是跟控制台打交道

16:11.270 --> 16:12.970
你可以看到它主要是关注的是功能

16:12.970 --> 16:14.570
而不是界面

16:14.570 --> 16:15.370
莎布兰也可以

16:15.370 --> 16:17.270
莎布兰的话打开中端

16:17.270 --> 16:17.970
你去查一下吧

16:17.970 --> 16:18.370
百度吧

16:18.370 --> 16:19.670
这种百度都可以查得到的

16:19.670 --> 16:21.170
都可以

16:21.170 --> 16:23.570
WS直接运行也是一样的

16:23.570 --> 16:25.870
WS是说的是

16:25.870 --> 16:27.570
好 咱们继续

16:27.570 --> 16:30.270
这里load的全局对象globo

16:30.270 --> 16:31.270
因为我们浏览器端

16:31.270 --> 16:32.570
不是一个全局对象window吗

16:32.570 --> 16:33.970
对不对

16:33.970 --> 16:37.950
浏览器端有个全局对象

16:37.950 --> 16:38.850
window

16:38.850 --> 16:41.350
当时window全局对象有什么作用呢

16:41.350 --> 16:43.250
它作用就是它里边的所有属性

16:43.250 --> 16:44.250
是不是可以直接用

16:44.250 --> 16:44.550
对不对

16:44.550 --> 16:46.050
window里边有个什么document

16:46.050 --> 16:47.350
所以说我们可以在浏览器里边

16:47.350 --> 16:48.650
直接使用document

16:48.650 --> 16:50.250
window里边有个什么erlase

16:50.250 --> 16:51.250
所以说我们在浏览器里边

16:51.250 --> 16:52.250
可以直接使用erlase

16:52.250 --> 16:52.750
对不对

16:52.750 --> 16:54.150
但是load的环境里边

16:54.150 --> 16:56.550
它的全局对象就根本就不是window了

16:56.550 --> 16:57.150
为啥呢

16:57.150 --> 16:58.550
因为浏览器端

16:58.550 --> 16:59.750
它的window表示啥

16:59.750 --> 17:01.550
表示浏览器窗口

17:01.550 --> 17:02.650
而我们load的环境里边

17:02.650 --> 17:03.850
有没有什么浏览器窗口

17:03.850 --> 17:05.650
跟浏览器一毛钱关系都没有

17:05.650 --> 17:06.050
对不对

17:06.050 --> 17:09.250
所以说它跟浏览器没有关系了

17:09.250 --> 17:10.850
浏览器里边的全局对象是window

17:10.850 --> 17:12.650
load里边的全局对象呢

17:12.650 --> 17:13.850
叫做globo

17:13.850 --> 17:14.750
叫做globo

17:14.750 --> 17:14.950
好

17:14.950 --> 17:16.850
咱们来输出一下globo

17:16.850 --> 17:18.650
你看一下

17:18.650 --> 17:19.750
保存

17:19.750 --> 17:21.150
我们这里重新运行

17:21.150 --> 17:23.250
按一下光标上

17:23.250 --> 17:24.350
通过光标

17:24.350 --> 17:25.850
就前后左右的光标

17:25.850 --> 17:27.450
按一下上就会回到之前的命令

17:27.450 --> 17:28.550
就回车运行

17:28.550 --> 17:30.650
因为看到globo是一个对象

17:30.650 --> 17:32.050
它对象里边包含了一些

17:32.050 --> 17:33.650
其他的乱七八糟的属性

17:33.650 --> 17:34.650
对不对

17:34.650 --> 17:36.150
包含了一些什么

17:36.150 --> 17:37.350
刚才我们用到了什么呢

17:37.350 --> 17:38.250
刚才我们用到了

17:38.250 --> 17:41.620
就是console

17:41.620 --> 17:42.320
它有些对象

17:42.320 --> 17:43.620
它其实里边还有一些属性

17:43.620 --> 17:46.020
它只是没有给你打印出来

17:46.020 --> 17:47.920
globo里面我们刚才是不是用到console

17:47.920 --> 17:48.520
对不对

17:48.520 --> 17:49.920
console为什么可以在

17:49.920 --> 17:52.920
可以在load的环境里边使用呢

17:52.920 --> 17:55.320
那么我这里问大家一个常识性的问题

17:55.320 --> 17:57.820
我觉得这个问题可能有同学都会犯错

17:57.820 --> 18:02.320
console这个东西是不是属于语言标准的

18:02.320 --> 18:04.520
它是不是属于我们的语言标准

18:04.520 --> 18:06.720
就是夜市语法

18:06.720 --> 18:09.520
控制台console是不是呢

18:10.520 --> 18:11.220
不是对吧

18:11.220 --> 18:12.220
不是非常好

18:12.220 --> 18:15.420
它是属于扭烂器给你提供的

18:15.420 --> 18:17.020
那么为什么load里边也可以使用呢

18:17.020 --> 18:19.820
因为load里边给它提供了一个一模一样的

18:19.820 --> 18:21.820
符合我们比较符合我们的开发

18:21.820 --> 18:24.520
开发习惯给它提供了一个一模一样的而已

18:24.520 --> 18:26.020
所以它不是语言标准

18:26.020 --> 18:28.020
那么console为什么可以使用呢

18:28.020 --> 18:32.820
就是因为我们来输出一下globo的console

18:32.820 --> 18:35.420
你看它里边有没有console的属性

18:35.420 --> 18:38.220
保存

18:38.220 --> 18:42.220
我们这里输入clear或者是lcls可以清屏

18:42.220 --> 18:45.220
我们这里使用load的重新运行式

18:45.220 --> 18:47.320
你看是不是能打印出来

18:47.320 --> 18:47.720
对不对

18:47.720 --> 18:49.320
说明这个console是存在的

18:49.320 --> 18:51.020
我们之所以在这里可以使用console

18:51.020 --> 18:54.120
是不是因为它全具对象里边有个属性的console

18:54.120 --> 18:55.920
这就跟扭烂器一样的

18:55.920 --> 18:57.720
扭烂器的全具对象里边有哪些属性

18:57.720 --> 18:58.320
我们可以直接用

18:58.320 --> 18:59.720
这里也是一样

18:59.720 --> 19:02.220
那么我们刚才还看到globo里边还有什么

19:02.220 --> 19:04.520
还有set timeout,set interval对不对

19:04.520 --> 19:06.620
这么这些都可以使用

19:06.620 --> 19:07.920
因为它是全具对象的

19:07.920 --> 19:09.020
同样的道理

19:09.020 --> 19:12.720
像这些玩意儿set timeout

19:12.720 --> 19:15.220
像这个玩意儿和扭烂器里边

19:15.220 --> 19:17.020
效果是完全一样的

19:17.020 --> 19:18.320
效果完全一样

19:18.320 --> 19:19.320
我们输出一个

19:19.320 --> 19:22.320
然后123

19:22.320 --> 19:23.720
保存

19:23.720 --> 19:27.000
我这里用自动保存吧

19:27.000 --> 19:30.200
我们这里清屏

19:30.200 --> 19:32.900
clear,cls

19:32.900 --> 19:34.900
clear它在power shell里边才能用

19:34.900 --> 19:36.200
在这里边不能用

19:36.200 --> 19:37.500
运行

19:37.500 --> 19:39.300
你看等一秒钟过后才输出123

19:39.300 --> 19:40.200
对不对

19:40.200 --> 19:42.400
所以set timeout也是能用的

19:42.400 --> 19:42.900
为什么呢

19:42.900 --> 19:44.200
它也不是语言标准

19:44.200 --> 19:45.500
它也是漏的环境里边

19:45.500 --> 19:46.900
给你提供了一个一模一样的

19:46.900 --> 19:49.100
跟你扭烂器用法一模一样的东西

19:49.100 --> 19:49.800
同样的道理

19:49.800 --> 19:55.810
我们还可以使用set interval

19:55.810 --> 19:57.210
你看它可以不断的

19:57.210 --> 19:59.710
每隔一秒钟运行一段代

19:59.710 --> 20:00.710
对不对

20:00.710 --> 20:03.910
要停止的话按concule加C

20:03.910 --> 20:07.010
按两下concule加C就可以停止程序

20:07.010 --> 20:09.810
这就是这个漏的环境里边的全具

20:09.810 --> 20:12.110
全具对象,全具对象就是globo

20:12.110 --> 20:13.110
那么这个全具对象里边

20:13.110 --> 20:14.310
其实还有一些东西

20:14.310 --> 20:15.910
只不过这五天的课程里边

20:15.910 --> 20:18.310
我们只讲我们需要用到的

20:18.310 --> 20:19.910
这一部分

20:19.910 --> 20:20.910
全具对象

20:20.910 --> 20:21.910
这三个

20:21.910 --> 20:23.510
然后接下来重点来了

20:23.510 --> 20:25.810
因为前面都没有什么难度

20:25.810 --> 20:26.910
重点在这

20:26.910 --> 20:28.510
common.js

20:28.510 --> 20:30.310
跟扭烂器差别就非常大了

20:30.310 --> 20:32.010
这个地方

20:32.010 --> 20:33.410
什么叫common.js呢

20:33.410 --> 20:36.010
首先知道common.js是一个规范

20:36.010 --> 20:36.610
什么叫规范

20:36.610 --> 20:40.410
它就是我不做任何具体的事情

20:40.410 --> 20:41.210
我跟你说

20:41.310 --> 20:43.810
我希望是这个世界是什么样子的

20:43.810 --> 20:45.710
然后你去给我实现

20:45.710 --> 20:47.110
它说的东西就是规范

20:47.110 --> 20:48.610
我希望大家都遵守

20:48.610 --> 20:49.710
那就是规范

20:49.710 --> 20:51.310
那么common.js是什么规范呢

20:51.310 --> 20:53.510
是一个模块化规范

20:53.510 --> 20:55.210
什么叫做模块化规范

20:55.210 --> 20:56.810
它又来解决什么样的问题呢

20:56.810 --> 20:59.110
我们再给大家引出一个问题

20:59.110 --> 21:00.310
在扭烂器端实际上

21:00.310 --> 21:02.910
我们有一个非常严重的问题

21:02.910 --> 21:05.910
在扭烂器端使用介石

21:05.910 --> 21:10.310
传统的扭烂器中使用介石

21:10.310 --> 21:12.410
它有两个非常严重的问题

21:12.410 --> 21:13.910
第一个问题呢就是

21:13.910 --> 21:17.010
全局变量无涨

21:17.010 --> 21:17.410
对不对

21:17.410 --> 21:18.910
是不是有这么一个问题

21:18.910 --> 21:19.810
第二个问题是咋了

21:19.810 --> 21:24.310
第二个问题就是依赖顺序混乱

21:24.310 --> 21:26.410
你们可以在脑袋里面想一想

21:26.410 --> 21:29.310
在扭烂器里边我们是不是要写页面

21:29.310 --> 21:31.410
我们的介石是不是在页面中引用的

21:31.410 --> 21:33.510
用script元素引用的

21:33.510 --> 21:35.110
对不对

21:35.110 --> 21:36.210
那么每一个介石

21:36.210 --> 21:38.510
它凡是在全局定义的变量

21:38.510 --> 21:40.210
比较说我们这样子

21:40.210 --> 21:42.810
每一个介石中全局定义的变量

21:42.810 --> 21:46.210
是不是都会挂载到温豆里面

21:46.210 --> 21:48.010
就挂得到一个全局对象里面

21:48.010 --> 21:48.610
对不对

21:48.610 --> 21:51.010
那么是不是造成了全局变量的无涨

21:51.010 --> 21:52.610
那么一个介石里边用了一个变量

21:52.610 --> 21:54.010
另一个介石是不是不能用了

21:54.010 --> 21:55.110
如果说一旦使用的话

21:55.110 --> 21:57.210
那么就把造成了变量名称冲突

21:57.210 --> 21:59.910
那么可能会得到一些意想不到的结果

21:59.910 --> 22:00.710
所以造成的问题

22:00.710 --> 22:01.310
这是第一个问题

22:01.310 --> 22:02.510
很麻烦的

22:02.510 --> 22:05.910
第二个问题是依赖顺序混乱

22:05.910 --> 22:07.210
你们平时还没有写过那种

22:07.210 --> 22:09.210
复杂的网站

22:09.210 --> 22:10.610
以前的写一些复杂的网站

22:10.610 --> 22:13.210
在传统的一个软件里面使用介石的时候

22:13.210 --> 22:17.010
你会发现网列上引用了超级多的介石单

22:17.010 --> 22:21.310
可能一个网站里边可能有二三十个介石文件

22:21.310 --> 22:22.910
那么哪些文件要先引用

22:22.910 --> 22:24.110
哪些文件要后引用

22:24.110 --> 22:25.810
因为后边的东西可能要引用

22:25.810 --> 22:28.010
可能要用到前面的东西

22:28.010 --> 22:29.910
所以造成了一个依赖关系

22:29.910 --> 22:32.010
特别难以管理

22:32.010 --> 22:34.610
而且现在的前端我告诉你

22:34.610 --> 22:36.910
要比以前的前端要复杂多

22:36.910 --> 22:38.510
多的多

22:38.510 --> 22:41.610
那一个网站里面就可能不是二三十个介石

22:41.610 --> 22:44.010
可能是两三千个介石

22:44.010 --> 22:45.010
有点夸张

22:45.010 --> 22:45.810
一点不夸张

22:45.810 --> 22:48.310
你们往后边写就你们就知道了

22:48.310 --> 22:49.910
那这样子的情况下

22:49.910 --> 22:52.110
依赖关系这么复杂

22:52.110 --> 22:53.610
产生了各种复杂的依赖关系

22:53.610 --> 22:55.310
你占用原式的用

22:55.310 --> 22:57.810
原数去引用介石的话

22:57.810 --> 22:59.510
那基本上是不可能的

22:59.510 --> 23:01.010
所以说要解决这个问题

23:01.010 --> 23:02.610
就必须要使用模块化

23:02.610 --> 23:05.110
那么common介石就是为了解决这个问题的

23:05.110 --> 23:06.010
这个common介石

23:06.010 --> 23:08.510
浏览器端目前还不支持

23:08.510 --> 23:09.610
他也没有打算支持

23:09.610 --> 23:10.810
因为现在的官方

23:10.810 --> 23:12.310
就是依也使官方出来了

23:12.310 --> 23:13.910
他的官方的模块化标准

23:13.910 --> 23:15.510
这是民间的

23:15.510 --> 23:16.910
这是在官方出来之前

23:16.910 --> 23:19.010
他出来的民间标准

23:19.010 --> 23:20.710
那么所以说浏览器环境不支持

23:20.710 --> 23:22.910
但是漏的环境支持得非常好

23:22.910 --> 23:23.710
因为漏的环境

23:23.710 --> 23:26.910
它是在我这剧场的连份我忘了

23:26.910 --> 23:28.610
有没有哪个同学跟我说一下

23:28.610 --> 23:29.610
漏的是哪

23:29.610 --> 23:30.910
是什么时候出来了

23:30.910 --> 23:32.310
好像是12年

23:32.310 --> 23:33.610
我当时讲课的时候我记得

23:33.610 --> 23:34.410
我现在都忘了

23:34.410 --> 23:35.910
好像是12年出来的

23:35.910 --> 23:38.010
那个时候还没有

23:38.010 --> 23:39.410
还没有出来ES6

23:39.410 --> 23:40.010
对不对

23:40.010 --> 23:42.410
因为还没有出来1909年

23:42.410 --> 23:43.510
那就是1909年

23:43.510 --> 23:44.610
听你的

23:44.610 --> 23:46.210
这些我忘了

23:46.210 --> 23:47.410
总之漏的出来的时候

23:47.410 --> 23:49.810
它是还没有出ES6的

23:49.810 --> 23:51.810
因此官方没有提模块化

23:51.810 --> 23:54.410
因此它只能自己搞一个模块化标准

23:54.410 --> 23:56.210
所以说我们这里

23:56.210 --> 23:57.710
学新漏的据中的一个点

23:57.710 --> 23:59.810
要学新common介石它的模块化标准

23:59.810 --> 24:01.210
它是什么意思呢

24:01.210 --> 24:02.610
它就是说这五个点

24:02.610 --> 24:04.910
彻底离界清楚了就差不多了

24:04.910 --> 24:05.810
第一个点

24:05.810 --> 24:09.510
它认为一个介石文件就是一个模块

24:09.510 --> 24:10.810
这是一个介石文件

24:10.810 --> 24:11.510
它是一个模块

24:11.510 --> 24:12.510
然后在这里

24:12.510 --> 24:13.610
再建立一个介石文件

24:13.610 --> 24:15.310
比较说A点介石

24:15.310 --> 24:18.110
这个又是一个模块

24:18.110 --> 24:19.410
每个介石文件就是个模块

24:19.410 --> 24:20.610
这是它第一个规则

24:20.610 --> 24:22.610
第二个规则就是

24:22.610 --> 24:25.510
每个模块内的所有的变量

24:25.510 --> 24:27.010
均为局部变量

24:27.010 --> 24:28.810
不会污染全局

24:28.810 --> 24:30.310
啥意思呢

24:30.310 --> 24:32.110
比方说这个index的模块

24:32.110 --> 24:34.210
我定义了一个A这个变量

24:34.210 --> 24:36.110
那么我来输出看一下

24:36.110 --> 24:39.710
Global全局变量里面有没有这个A

24:39.710 --> 24:43.100
咱们运行看一下

24:43.100 --> 24:44.100
是不是undefined的

24:44.100 --> 24:44.800
对不对

24:44.800 --> 24:47.000
因此它每一个模块它的变量

24:47.000 --> 24:48.900
哪怕你定义的是全局变量

24:48.900 --> 24:51.800
它都不会污染我们真正的全局变量

24:51.800 --> 24:53.100
它都是局部的

24:53.100 --> 24:55.200
都是局部使用的

24:55.200 --> 24:56.900
这是第二个点

24:56.900 --> 24:58.100
第三个点

24:58.100 --> 25:01.300
每一个模块如果说要暴露一些东西

25:01.300 --> 25:04.300
给其他模块使用需要导出

25:04.300 --> 25:06.700
比方说我这个模块A这个模块

25:06.700 --> 25:07.900
A点GS一个模块

25:07.900 --> 25:09.100
这个模块里面写的代码

25:09.100 --> 25:11.300
在别的GS里面是用不了的

25:11.300 --> 25:12.700
比方说我这里定一个变量A

25:12.700 --> 25:14.100
在index里面GS里面

25:14.100 --> 25:15.700
不可能用到这里面的变量A

25:15.700 --> 25:16.900
用不到的

25:16.900 --> 25:17.800
你怎么用啊

25:17.800 --> 25:18.500
根本就没法用

25:18.500 --> 25:20.000
因为它这里面又没有页面

25:20.000 --> 25:22.200
它又不可能说同时运行两个GS

25:22.200 --> 25:23.700
它运行的时候都是一个GS

25:23.700 --> 25:24.900
一个GS运行

25:24.900 --> 25:25.600
对吧

25:25.600 --> 25:28.900
那我怎么来用别的GS里面写的东西呢

25:28.900 --> 25:31.500
需要在别的GS里面导出

25:31.500 --> 25:32.700
比方说这个模块

25:32.700 --> 25:34.000
我要导出两个东西

25:34.000 --> 25:36.100
一个是一个数字3

25:36.100 --> 25:37.300
我要把数字3导出

25:37.300 --> 25:38.900
第二个我要导出一个函数

25:38.900 --> 25:40.000
那怎么办呢

25:40.000 --> 25:40.900
怎么导出呢

25:40.900 --> 25:44.200
它要使用一个特别的方式来导出

25:44.200 --> 25:47.300
导出的时候使用这种协法

25:47.300 --> 25:48.400
export

25:48.400 --> 25:50.600
第二 啥啥啥等于啥啥啥

25:50.600 --> 25:51.900
还有三种协法

25:51.900 --> 25:52.900
第一种协法

25:52.900 --> 25:54.000
export

25:54.000 --> 25:55.000
第二

25:55.000 --> 25:57.800
比方说我们这里写个A等于3

25:57.800 --> 26:00.100
那么就相当于是导出了一个什么呢

26:00.100 --> 26:01.600
导出了一个对象

26:01.600 --> 26:05.200
这个对象里边的一个属性等于3

26:05.200 --> 26:06.200
没了意思吧

26:06.200 --> 26:11.700
然后我们比方说再写一个B等于123

26:11.700 --> 26:13.400
那么就相当于是导出了

26:13.400 --> 26:14.700
刚才导出一个3对不对

26:14.700 --> 26:17.300
那么现在又导出了一个A等于3

26:17.300 --> 26:18.900
B等于123

26:18.900 --> 26:20.100
没了意思吧

26:20.100 --> 26:21.900
相当于是用这种方式来导出的

26:21.900 --> 26:23.900
它最终导出的是一个对象

26:23.900 --> 26:24.200
好

26:24.200 --> 26:25.600
那么这是一种导出方式

26:25.600 --> 26:26.700
另外一种导出方式呢

26:26.700 --> 26:29.700
它是使用module

26:29.700 --> 26:30.700
module

26:30.700 --> 26:32.400
第二export

26:32.400 --> 26:34.000
这导出方式都可以

26:34.000 --> 26:36.100
我们一会来讲区别

26:36.100 --> 26:37.500
用这种方式来导出

26:37.500 --> 26:38.400
那么这种方式呢

26:38.400 --> 26:39.300
你写啥

26:39.300 --> 26:40.200
它就导出啥

26:40.200 --> 26:41.400
比方说你写个3

26:41.400 --> 26:42.900
那么就导出了什么呢

26:42.900 --> 26:44.600
导出了就是一个3

26:44.600 --> 26:45.300
如果说

26:45.300 --> 26:46.600
所以说这个module.export

26:46.600 --> 26:48.500
能我们往往只写一次

26:48.500 --> 26:51.200
比方说你这里又重新复制

26:51.200 --> 26:53.000
export等于一个对象

26:53.000 --> 26:55.400
一个对象里边A

26:56.100 --> 26:57.300
Hello

26:57.300 --> 26:59.200
那么这个相当于是导出什么呢

26:59.200 --> 27:02.300
相当于是导出了一个对象

27:02.300 --> 27:03.500
对象里面一个属性A

27:03.500 --> 27:04.500
A的值为Hello

27:04.500 --> 27:05.700
当然是不是函数也可以

27:05.700 --> 27:07.200
A的值可以是任何东西

27:07.200 --> 27:09.600
当然这个等个也可以是任何东西

27:09.600 --> 27:11.600
可以导出一个函数

27:11.600 --> 27:13.200
这是这种方式

27:13.200 --> 27:14.400
还有一种方式呢

27:14.400 --> 27:17.300
还有一种方式是使用zease

27:17.300 --> 27:18.800
zease.sasa等于sasa

27:18.800 --> 27:20.300
这种方式用的很少

27:20.300 --> 27:25.590
那么它的效果跟这种效果差不多的

27:25.590 --> 27:26.690
这里大家注意

27:26.690 --> 27:28.090
这里是容易出面试题的

27:28.090 --> 27:30.690
我们以后会详细说它的具体的区别

27:32.690 --> 27:33.890
这种方式也是一样的

27:33.890 --> 27:34.890
这种方式相当于

27:34.890 --> 27:36.490
这样写的过后了A等于3

27:36.490 --> 27:38.290
导出了过后了A等于3不变

27:38.290 --> 27:40.990
然后再导出一个B等于123

27:40.990 --> 27:41.590
不要理是吧

27:41.590 --> 27:43.090
这是它的导出方式

27:44.090 --> 27:45.390
导出方式

27:45.390 --> 27:46.390
那么导出了过后

27:46.390 --> 27:48.490
其他模块怎么来用呢

27:48.490 --> 27:50.090
比方说我要运行的模块

27:50.090 --> 27:51.190
是index的模块

27:51.190 --> 27:52.490
你看我刚才运行的是不是它

27:52.490 --> 27:53.590
当然你也可以运行的

27:53.590 --> 27:55.390
你可以运行这个A这个模块

27:55.390 --> 27:58.290
我们一般来说入口模块的话

27:58.290 --> 28:01.790
我们把要运行的模块叫做入口模块

28:01.790 --> 28:04.990
就是以这个模块为旗电来进行运行

28:04.990 --> 28:06.690
就这个加码差不多的

28:06.690 --> 28:08.590
那么这样子运行的时候

28:08.590 --> 28:11.190
这个模块里面可能会用到别的模块的东西

28:11.190 --> 28:13.390
比方说我这里要用这个模块A

28:13.390 --> 28:14.090
要用这个模块

28:14.090 --> 28:15.590
那怎么来写的太满了

28:15.590 --> 28:16.190
跟小姐呢

28:16.190 --> 28:17.590
你这样写require

28:19.590 --> 28:20.590
一边写上

28:20.590 --> 28:22.590
首先写上一个底耳结槓

28:22.590 --> 28:23.590
表示当前目录

28:23.590 --> 28:26.790
或者是底耳结槓回到之前的目录都行

28:26.790 --> 28:28.090
但是你必须要写

28:28.090 --> 28:29.590
当前目录底耳结槓

28:29.590 --> 28:30.290
找到哪个模块

28:30.290 --> 28:31.090
找到A这个模块

28:31.090 --> 28:32.390
可以不写后续名

28:32.390 --> 28:33.590
它会自动去找

28:33.590 --> 28:35.490
我要找到这个模块

28:35.490 --> 28:38.190
把这个模块导出的东西返回

28:39.690 --> 28:41.090
那么这个模块导出东西是

28:41.090 --> 28:43.190
导出东西不就这个玩意吗

28:43.190 --> 28:44.190
不就这个玩意吗

28:44.190 --> 28:45.990
所以说我这里返回

28:45.990 --> 28:46.390
你看一下

28:46.390 --> 28:48.290
我这用个变量来接收一下

28:48.290 --> 28:49.290
results

28:49.290 --> 28:50.490
来接收一下

28:50.490 --> 28:51.790
我们这输出results

28:52.790 --> 28:56.170
你看一下得到的结果是

28:56.170 --> 28:57.170
不就是A等于3

28:57.170 --> 28:58.170
B等于123

28:58.170 --> 28:59.170
对不对

28:59.170 --> 29:00.170
这边导出啥

29:00.170 --> 29:01.170
这边得到啥

29:01.170 --> 29:03.170
而且这个模块会被执行一次

29:03.170 --> 29:04.170
比较重点在这里

29:04.170 --> 29:05.170
写上一个输出

29:05.170 --> 29:09.610
A模块执行了

29:09.610 --> 29:10.610
我们再运行

29:12.610 --> 29:13.610
你看是不是运行了

29:13.610 --> 29:15.610
它会把这个模块执行

29:15.610 --> 29:16.610
执行完了过后

29:16.610 --> 29:18.110
是不是就确定了导出了什么东西

29:18.110 --> 29:19.610
导出的是这个东西

29:19.610 --> 29:21.110
把这个东西返回

29:21.110 --> 29:22.110
给这个变量

29:22.110 --> 29:23.110
因为我们运行的是

29:23.110 --> 29:24.610
运行的是index的模块

29:24.610 --> 29:26.110
运行require

29:26.110 --> 29:27.110
require表示导入

29:27.110 --> 29:28.110
导入这个模块

29:28.110 --> 29:29.110
于是把这个模块执行一次

29:29.110 --> 29:30.110
执行完了过后

29:30.110 --> 29:31.110
把这个东西作为导出

29:31.110 --> 29:32.110
作为返回结果

29:32.110 --> 29:33.110
保存个变量里边

29:33.110 --> 29:34.110
那么这个变量的值

29:34.110 --> 29:35.110
就是这个东西了

29:35.110 --> 29:37.110
它是用这种模式来进行的

29:37.110 --> 29:39.110
那么我们这样子写了过后

29:39.110 --> 29:41.110
问大家一个问题

29:41.110 --> 29:42.110
我这个模块里边

29:42.110 --> 29:44.110
能不能定义相同的变量名称A

29:44.110 --> 29:47.680
能不能定义这边

29:47.680 --> 29:51.520
相同的变量名称A

29:51.520 --> 29:52.520
有警告的话

29:52.520 --> 29:53.520
你要告诉我

29:53.520 --> 29:54.520
它警告是什么

29:54.520 --> 29:58.160
可以是吧

29:59.160 --> 30:00.160
可以对不对

30:00.160 --> 30:01.160
为什么可以呢

30:01.160 --> 30:02.160
就是因为我刚才说了

30:02.160 --> 30:04.160
模块内的所有变量

30:04.160 --> 30:06.160
均为局部变量

30:06.160 --> 30:08.160
不会污染全局

30:08.160 --> 30:09.160
说这里没问题

30:09.160 --> 30:11.160
这里没问题

30:11.160 --> 30:12.160
一点问题都没有

30:12.160 --> 30:14.160
人上可以直接执行

30:14.160 --> 30:15.160
对不对

30:15.160 --> 30:16.160
跟那个模块里没有任何关系

30:16.160 --> 30:17.160
这个A是这个模块的

30:17.160 --> 30:19.160
这个A是另外一个模块的

30:19.160 --> 30:20.160
它们没有什么关系

30:20.160 --> 30:21.160
自己模块使用自己的

30:21.160 --> 30:23.160
没有什么顾不干的

30:23.160 --> 30:25.160
那么我又问大家一个问题

30:25.160 --> 30:26.160
这里要反复的理解

30:27.160 --> 30:29.160
这一块是我们今天晚上的重点

30:29.160 --> 30:31.160
比方说我这里

30:31.160 --> 30:33.160
写了一个方形

30:33.160 --> 30:35.160
我导出的是一个方形

30:41.000 --> 30:42.000
是一个球合的

30:46.000 --> 30:48.000
导出了一个方形的名字叫做球合

30:50.000 --> 30:52.380
那么这边来

30:52.380 --> 30:53.380
请问这里

30:53.380 --> 30:55.380
是不是必须要写上

30:55.380 --> 30:57.380
上还是可以写别的

30:57.380 --> 30:58.380
这些都是

30:58.380 --> 30:59.380
非常灵活的

30:59.380 --> 31:01.380
你要理解它的本质含义

31:01.380 --> 31:03.380
这里是不是只能写上

31:03.380 --> 31:05.380
还是可以写别的

31:06.380 --> 31:07.380
可以写别的对吧

31:07.380 --> 31:09.380
因为它只是一个变量

31:09.380 --> 31:11.380
要理解一个代码

31:11.380 --> 31:12.380
require A什么意思

31:12.380 --> 31:14.380
就是把这个地方执行一边

31:14.380 --> 31:15.380
执行一边

31:15.380 --> 31:16.380
是不是执行完了过后

31:16.380 --> 31:17.380
它就能够确定导出了

31:17.380 --> 31:18.380
对吧

31:18.380 --> 31:19.380
导出的是什么

31:19.380 --> 31:21.380
导出的是一个函数

31:21.380 --> 31:22.380
这个函数

31:22.380 --> 31:23.380
它有两个参数

31:23.380 --> 31:24.380
对不对

31:24.380 --> 31:25.380
就是个函数

31:25.380 --> 31:26.380
导出的是一个函数

31:26.380 --> 31:27.380
然后呢

31:27.380 --> 31:28.380
执行完了过后

31:28.380 --> 31:30.380
它就会把导出的结果

31:30.380 --> 31:31.380
复制给这个变量

31:32.380 --> 31:33.380
对不对

31:33.380 --> 31:34.380
是不是可以给它一个复制

31:34.380 --> 31:35.380
这个变量可以是任何东西吗

31:35.380 --> 31:36.380
对不对

31:36.380 --> 31:37.380
好

31:37.380 --> 31:38.380
咱们来看一下吧

31:38.380 --> 31:39.380
CLS

31:42.380 --> 31:43.380
运行

31:43.380 --> 31:44.380
你看

31:44.380 --> 31:45.380
是不是执行了

31:45.380 --> 31:46.380
M2执行了

31:46.380 --> 31:47.380
其实呢

31:47.380 --> 31:48.380
我这里

31:48.380 --> 31:49.380
也可以安装一个插件

31:49.380 --> 31:50.380
这个插件的名字叫做

31:51.380 --> 31:52.380
叫做code run

31:52.380 --> 31:56.330
叫做run

31:57.330 --> 31:58.330
连不上呢

31:58.330 --> 31:59.330
这两天

31:59.330 --> 32:00.330
你们都懂

32:00.330 --> 32:01.330
中所走之的原因

32:01.330 --> 32:02.330
这两天

32:02.330 --> 32:03.330
那个网啊

32:03.330 --> 32:06.330
反正连国外的服务器都不是很好

32:06.330 --> 32:08.330
因为一些中所走之的原因

32:08.330 --> 32:09.330
这里呢

32:09.330 --> 32:11.330
我们搜索一下这个code run

32:11.330 --> 32:12.330
你们去安装一下吧

32:12.330 --> 32:13.330
这里是个插件

32:13.330 --> 32:14.330
这里连不上了

32:14.330 --> 32:15.330
这是个插件

32:15.330 --> 32:16.330
安装好之后

32:16.330 --> 32:17.330
也可以非常轻松的来执行

32:17.330 --> 32:19.330
点击右键 run code

32:20.330 --> 32:21.330
它会多一个菜单

32:21.330 --> 32:22.330
run code

32:22.330 --> 32:23.330
你看

32:23.330 --> 32:24.330
可以在这里看到

32:24.330 --> 32:25.330
执行了

32:25.330 --> 32:26.330
这个函数了

32:26.330 --> 32:27.330
对不对

32:27.330 --> 32:28.330
没有什么问题的

32:28.330 --> 32:29.330
那么我再问大家一个问题

32:29.330 --> 32:31.330
这里能不能定义变两上

32:31.330 --> 32:35.800
我能不能定义一个变两上

32:35.800 --> 32:39.170
可不可以

32:39.170 --> 32:40.170
对

32:40.170 --> 32:41.170
code run

32:41.170 --> 32:42.170
就是关

32:42.170 --> 32:43.170
能不能

32:43.170 --> 32:44.170
可以的

32:44.170 --> 32:45.170
始终记住

32:45.170 --> 32:47.170
模块之间是隔离的

32:47.170 --> 32:48.170
没有任何关系

32:48.170 --> 32:49.170
你这边随便用啥名字

32:49.170 --> 32:50.170
跟另外一边

32:50.170 --> 32:51.170
没有什么关系的

32:51.170 --> 32:52.170
对不对

32:52.170 --> 32:54.170
这边是没有任何关系的

32:54.170 --> 32:55.170
所以这边的名字

32:55.170 --> 32:56.170
随便用

32:56.170 --> 32:57.170
那么这样子一来的话

32:57.170 --> 32:59.170
你看你开发的时候

33:00.170 --> 33:02.170
行李负担是不是减少很多了

33:02.170 --> 33:04.170
变量里数一遍定义

33:04.170 --> 33:05.170
不管你这个模块里边

33:05.170 --> 33:06.170
要用到别一个的打

33:06.170 --> 33:08.170
一些模块里数一遍定义变量

33:08.170 --> 33:10.170
一点关系都没有

33:10.170 --> 33:12.170
变量名的重复干扰

33:12.170 --> 33:14.170
它只存在模块内部

33:14.170 --> 33:15.170
只存在这个模块内部

33:15.170 --> 33:16.170
只要出了这个模块

33:16.170 --> 33:18.170
就跟它一点关系都没有了

33:18.170 --> 33:19.170
没了意思吧

33:19.170 --> 33:20.170
所以说不用担心

33:20.170 --> 33:21.170
好

33:21.170 --> 33:22.170
接下来我们看本字了

33:23.170 --> 33:24.170
练书体里边

33:25.170 --> 33:27.170
可能会经常用各种方式

33:27.170 --> 33:28.170
来恶心的

33:28.170 --> 33:30.170
考虑这个玩意儿

33:30.170 --> 33:31.170
跟这个玩意儿

33:31.170 --> 33:32.170
跟这个玩意儿的区别

33:33.170 --> 33:35.170
那么你要解答

33:35.170 --> 33:36.170
这些练书体

33:36.170 --> 33:38.170
千万不要去使劲用背

33:38.170 --> 33:39.170
我也不知道

33:39.170 --> 33:40.170
它会出现什么样

33:40.170 --> 33:41.170
变态的解法

33:41.170 --> 33:42.170
但是你只要理解

33:42.170 --> 33:43.170
它这个require

33:43.170 --> 33:45.170
函数的原理

33:45.170 --> 33:46.170
因为我们导入

33:46.170 --> 33:47.170
是通过这个require导入的

33:47.170 --> 33:48.170
你看下这个require

33:48.170 --> 33:50.170
是怎么执行的

33:50.170 --> 33:51.170
就彻底明白了

33:51.170 --> 33:52.170
它会怎么

33:52.170 --> 33:55.170
它会那些面试体

33:55.170 --> 33:56.170
笔试体怎么来做

33:57.170 --> 33:59.170
我下面给大家写了一个require的

33:59.170 --> 34:00.170
伟代码

34:00.170 --> 34:01.170
当时是伟代码

34:01.170 --> 34:02.170
你不可能说

34:02.170 --> 34:04.170
真的去能够require写出来

34:04.170 --> 34:05.170
这是伟代码

34:05.170 --> 34:06.170
因为它要设计到

34:06.170 --> 34:08.170
几成加载文件的

34:08.170 --> 34:10.170
而且把文件进行解析执行

34:10.170 --> 34:11.170
所以说你不可能说

34:11.170 --> 34:12.170
真的把它写出来

34:12.170 --> 34:14.170
但是我们用伟代码的方式

34:14.170 --> 34:16.170
来帮助大家梳理一下

34:16.170 --> 34:17.170
看它怎么执行的

34:17.170 --> 34:19.170
它代码一共就有30来行

34:19.170 --> 34:20.170
而且并不复杂

34:20.170 --> 34:21.170
我们看它的逻辑

34:21.170 --> 34:23.170
我们当我们使用require函数的时候

34:23.170 --> 34:25.170
它的require函数逻辑是什么

34:25.170 --> 34:27.170
这个地方写的是啥呢

34:27.170 --> 34:28.170
这个地方它有一个参数

34:28.170 --> 34:31.170
这个参数叫做磨块路径

34:32.170 --> 34:34.170
这个玩意叫做磨块路径

34:34.170 --> 34:35.170
就是我们这个玩意

34:35.170 --> 34:36.170
就会传到这个参数里面去

34:36.170 --> 34:38.170
那么require是怎么执行的呢

34:38.170 --> 34:41.170
首先它要获取磨块ID

34:41.170 --> 34:42.170
什么叫ID就是编号

34:42.170 --> 34:43.170
就像你们身份帧号一样

34:43.170 --> 34:45.170
把每个磨块一个唯一编号

34:45.170 --> 34:46.170
那么这个编号

34:46.170 --> 34:48.170
实际上是怎么来的

34:48.170 --> 34:50.170
实际上就是个磨块的绝对路径

34:51.170 --> 34:54.170
就是这个磨块的绝对路径

34:54.170 --> 34:55.170
就是它的编号

34:55.170 --> 34:57.170
所以说它首先要通过一种方式

34:57.170 --> 35:00.170
这个怎么来获取它绝对路径

35:00.170 --> 35:01.170
我们不涉及

35:01.170 --> 35:02.170
我们以后可以讲一讲

35:02.170 --> 35:03.170
现在我们只需要知道

35:03.170 --> 35:04.170
它的逻辑就是

35:04.170 --> 35:07.170
根据你提供的这个路径

35:07.170 --> 35:09.170
来得到这个磨块的绝对路径

35:09.170 --> 35:10.170
什么叫绝对路径呢

35:10.170 --> 35:12.170
比方说地盘

35:12.170 --> 35:14.170
下面的某个文件夹

35:14.170 --> 35:15.170
下面某一个文件夹

35:15.170 --> 35:16.170
下面的某一个文件夹

35:16.170 --> 35:17.170
下面的ADS

35:17.170 --> 35:19.170
这叫绝对路径

35:19.170 --> 35:20.170
没了意思吧

35:20.170 --> 35:22.170
这是这一步它要做的事

35:22.170 --> 35:24.170
获取这个磨块的绝对路径

35:24.170 --> 35:25.170
那么把它得到一个字母串

35:25.170 --> 35:27.170
这就是个字母串

35:27.170 --> 35:30.170
接下来它看一个全局的缓存

35:30.170 --> 35:31.170
这是一个全局的对象

35:31.170 --> 35:32.170
一个缓存

35:32.170 --> 35:34.170
看一下这个磨块

35:34.170 --> 35:36.170
通过把这个东西作为属性

35:36.170 --> 35:38.170
看一下这个变量有没有缓存

35:38.170 --> 35:39.170
那什么意思呢

35:39.170 --> 35:41.170
你可以想象这个开启

35:41.170 --> 35:44.170
它是这么个样子

35:44.170 --> 35:45.170
开启

35:45.170 --> 35:46.170
不要慌啊

35:46.170 --> 35:47.170
我一点点给你解释

35:47.170 --> 35:49.170
这个地方对初学者来说

35:49.170 --> 35:50.170
可能稍微复杂一点

35:50.170 --> 35:51.170
其实你理解了过后

35:51.170 --> 35:53.170
这一块很简单

35:53.170 --> 35:55.170
就是它里边有可能有很多东西

35:55.170 --> 35:56.170
比如说启动一个磨块的路径

35:56.170 --> 36:00.830
我看一下这个磨块的路径是哪吗

36:00.830 --> 36:02.830
这个磨块的路径就是属性名

36:02.830 --> 36:05.830
这是它的属性名

36:05.830 --> 36:07.830
还要转移是吧

36:07.830 --> 36:09.830
还要转移

36:09.830 --> 36:13.800
转移吧

36:13.800 --> 36:15.800
转移

36:15.800 --> 36:17.800
这是它的磨块ID

36:17.800 --> 36:19.800
那么后面就是它磨块的缓存

36:19.800 --> 36:21.800
这个缓存是什么呢

36:21.800 --> 36:23.800
这个缓存就是它导出的结果

36:23.800 --> 36:25.800
上一次导出的结果

36:25.800 --> 36:27.800
它首先看一下这个磨块里面

36:27.800 --> 36:29.800
这个开启里面有没有这个缓存

36:29.800 --> 36:31.800
把磨块ID传进去

36:31.800 --> 36:32.800
看一下有没有这个缓存

36:32.800 --> 36:33.800
如果说有的话

36:33.800 --> 36:35.800
直接返回这个缓存结果

36:35.800 --> 36:36.800
啥都不做了

36:36.800 --> 36:37.800
这部分很简单

36:37.800 --> 36:40.800
但是一开始肯定是没有缓存的

36:40.800 --> 36:42.800
一开始肯定是没有的

36:42.800 --> 36:43.800
那怎么办呢

36:43.800 --> 36:44.800
如果说没有缓存

36:44.800 --> 36:45.800
进入下面逻辑

36:45.800 --> 36:46.800
下面有一个辅助函数

36:46.800 --> 36:47.800
这个辅助函数

36:47.800 --> 36:48.800
我们一会再说

36:48.800 --> 36:50.800
好 接下来再看

36:50.800 --> 36:52.800
它给你创建了一个对象

36:52.800 --> 36:53.800
叫做名字

36:53.800 --> 36:54.800
叫做margeau

36:54.800 --> 36:56.800
里面有个属性

36:56.800 --> 36:57.800
叫做export

36:57.800 --> 36:59.800
它里面有一个对象

36:59.800 --> 37:02.800
接下来我们就继续往后看

37:02.800 --> 37:04.800
接下来它调用了一个函数

37:04.800 --> 37:05.800
怎么调用的呢

37:05.800 --> 37:06.800
expute margeau

37:06.800 --> 37:07.800
就调用这个函数

37:07.800 --> 37:08.800
这个函数

37:08.800 --> 37:09.800
是它的一个内部函数

37:09.800 --> 37:10.800
一个辅助函数

37:10.800 --> 37:11.800
它调用这个函数

37:11.800 --> 37:12.800
这个函数

37:12.800 --> 37:13.800
它使用什么方式在调用的

37:13.800 --> 37:14.800
call

37:14.800 --> 37:15.800
知道吧

37:15.800 --> 37:16.800
这个call的方式

37:16.800 --> 37:17.800
是绑定z的

37:17.800 --> 37:18.800
对不对

37:18.800 --> 37:19.800
它把什么传进去了

37:19.800 --> 37:21.800
它把这个对象是不是传进去了

37:21.800 --> 37:23.800
把这个对象作为z

37:23.800 --> 37:25.800
是不是传进去了

37:25.800 --> 37:26.800
对不对

37:26.800 --> 37:28.800
绑定了对象的z

37:28.800 --> 37:30.800
接下来我们继续看

37:30.800 --> 37:31.800
它第一个参数传的啥

37:31.800 --> 37:32.800
第一个参数就是

37:32.800 --> 37:34.800
把整个margeau传进去

37:34.800 --> 37:35.800
第二个参数传的啥

37:35.800 --> 37:36.800
第二个参数就是

37:36.800 --> 37:38.800
把export传进去

37:38.800 --> 37:40.800
传到这个

37:40.800 --> 37:41.800
你看z

37:41.800 --> 37:43.800
跟这个东西是不是一样的

37:43.800 --> 37:44.800
是不是一样的

37:44.800 --> 37:45.800
z

37:45.800 --> 37:46.800
跟这个第二个参数

37:46.800 --> 37:47.800
是不是一样的

37:47.800 --> 37:50.800
第三个参数是

37:50.800 --> 37:52.800
表示模块的

37:52.800 --> 37:54.800
目录的决定路径

37:54.800 --> 37:55.800
什么意思呢

37:55.800 --> 37:56.800
我导致的模块是什么

37:56.800 --> 37:57.800
导致的模块是这个

37:57.800 --> 37:58.800
adder解释

37:58.800 --> 37:59.800
注意听

37:59.800 --> 38:00.800
这个地方一定要注意听

38:00.800 --> 38:02.800
不然的话你会觉得很糟的

38:02.800 --> 38:03.800
adder解释不导致的

38:03.800 --> 38:04.800
那么它的

38:04.800 --> 38:05.800
这个模块的

38:05.800 --> 38:06.800
这个模块的

38:06.800 --> 38:07.800
目录的决定路径

38:07.800 --> 38:08.800
是不是这个

38:08.800 --> 38:10.800
是不是这个玩意

38:10.800 --> 38:11.800
目录的决定路径

38:11.800 --> 38:13.800
不就是这个玩意吗

38:13.800 --> 38:14.800
好

38:14.800 --> 38:15.800
模块的决定路径是什么

38:15.800 --> 38:16.800
模块的决定路径是这个

38:16.800 --> 38:18.800
后面加上一个adder解释

38:18.800 --> 38:20.800
这是模块的决定路径

38:20.800 --> 38:22.800
你看懂吧

38:22.800 --> 38:23.800
好

38:23.800 --> 38:24.800
那么接下来

38:24.800 --> 38:28.880
这个函数是怎么执行的呢

38:28.880 --> 38:29.880
这个函数

38:29.880 --> 38:31.880
这个函数里边

38:31.880 --> 38:34.880
就是adder解释的代码

38:34.880 --> 38:35.880
就是我们这个代码

38:35.880 --> 38:36.880
实际上在哪呢

38:36.880 --> 38:40.710
实际上在这

38:40.710 --> 38:41.710
我们刚才说了

38:41.710 --> 38:42.710
require是不是导致

38:42.710 --> 38:43.710
模块的执行

38:43.710 --> 38:44.710
我们的模块代码

38:44.710 --> 38:45.710
从哪过来才能执行啊

38:45.710 --> 38:47.710
我们的代码在哪呢

38:47.710 --> 38:49.710
我们的代码就在这

38:49.710 --> 38:51.710
这解释了什么呢

38:51.710 --> 38:53.710
这就解释到模块里边

38:53.710 --> 38:55.710
为什么可以使用module

38:55.710 --> 38:57.710
为什么可以使用exports

38:57.710 --> 38:59.710
因为它是函数

38:59.710 --> 39:00.710
看呗

39:00.710 --> 39:02.710
为什么可以使用z

39:02.710 --> 39:04.710
z它是这里绑定了的

39:04.710 --> 39:07.710
而且模块里边还可以使用啥呀

39:07.710 --> 39:10.710
还可以使用dir内

39:10.710 --> 39:13.710
还可以使用file内

39:13.710 --> 39:15.710
还可以使用这两个东西

39:15.710 --> 39:16.710
不信我们试一下

39:16.710 --> 39:17.710
把这个注释一下

39:18.710 --> 39:19.710
你看

39:19.710 --> 39:20.710
我在a模块

39:20.710 --> 39:21.710
你看我导入a

39:21.710 --> 39:22.710
把a模块运行一次

39:22.710 --> 39:23.710
我这里不输出了

39:23.710 --> 39:25.710
我把a模块运行一次

39:25.710 --> 39:27.710
运行一次过a模块里边

39:27.710 --> 39:28.710
是不是输出这两个东西

39:28.710 --> 39:31.470
你看

39:31.470 --> 39:34.470
所在目录的绝对路径

39:34.470 --> 39:36.470
模块的自己的绝对路径

39:36.470 --> 39:37.470
对吧

39:37.470 --> 39:38.470
模块里边凭什么可以用这两个

39:38.470 --> 39:39.470
那么

39:39.470 --> 39:40.470
为什么呢

39:40.470 --> 39:41.470
就是因为

39:41.470 --> 39:42.470
模块里边代码

39:42.470 --> 39:43.470
实际上是在一个

39:43.470 --> 39:45.470
函数环境里边执行

39:45.470 --> 39:46.470
而函数环境里边

39:46.470 --> 39:48.470
是不是就有这么四个参数

39:48.470 --> 39:49.470
对不对

39:49.470 --> 39:50.470
好

39:50.470 --> 39:51.470
那么我再问大家一个问题

39:53.470 --> 39:54.470
我在模块里边

39:54.470 --> 39:55.470
我们输出这个东西

39:55.470 --> 40:02.110
输出多少

40:02.110 --> 40:07.620
我们在模块里边

40:07.620 --> 40:08.620
输出这个东西

40:08.620 --> 40:09.620
你觉得输出多少

40:09.620 --> 40:12.380
对

40:12.380 --> 40:13.380
就是弄的

40:13.380 --> 40:14.380
把我们的GS文件的代码

40:14.380 --> 40:16.380
包容到一个函数里边去了

40:16.380 --> 40:17.380
说我们来看一下吧

40:17.380 --> 40:19.380
优先运行装扣的

40:19.380 --> 40:20.380
你看

40:22.380 --> 40:23.380
它里边还有一个参数

40:23.380 --> 40:24.380
还有一个参数

40:24.380 --> 40:25.380
那个参数呢

40:25.380 --> 40:27.380
我们倒是用不到

40:27.380 --> 40:28.380
倒是用不到

40:29.380 --> 40:30.380
这个参数叫

40:30.380 --> 40:31.380
是啥来着

40:31.380 --> 40:32.380
还有一个参数

40:32.380 --> 40:33.380
当时我举个例子的时候

40:34.380 --> 40:35.380
还有一个

40:35.380 --> 40:36.380
一个是X4

40:36.380 --> 40:38.380
一个是DLN

40:38.380 --> 40:40.380
还有一个叫啥参数呢

40:40.380 --> 40:41.380
还有一个

40:41.380 --> 40:42.380
我们来试一下吧

40:42.380 --> 40:43.380
我们打一下

40:43.380 --> 40:44.380
打一下它的参数

40:44.380 --> 40:45.380
我们看一下

40:45.380 --> 40:46.380
最后一个

40:46.380 --> 40:47.380
我们看一下

40:47.380 --> 40:48.380
最后一个是啥

40:48.380 --> 40:49.380
把前两个去了

40:49.380 --> 40:50.380
它里边还有一个

40:50.380 --> 40:53.880
这是FileN

40:53.880 --> 40:54.880
这是DLN

40:54.880 --> 40:56.880
DLN那边是最后一个

40:56.880 --> 40:58.880
我这里写的寫法

40:59.880 --> 41:01.880
这是文件名

41:01.880 --> 41:02.880
第二个呢

41:03.880 --> 41:04.880
这个是啥

41:06.880 --> 41:08.880
它

41:08.880 --> 41:10.880
这个第三个是码酒

41:10.880 --> 41:12.880
第三个是码酒

41:12.880 --> 41:14.880
我可以再试验一下吧

41:14.880 --> 41:15.880
试验一下就知道了

41:15.880 --> 41:19.520
第二个呢

41:19.520 --> 41:20.520
第二个

41:20.520 --> 41:22.520
对对对对

41:22.520 --> 41:24.520
我把这个东西写丢了

41:24.520 --> 41:25.520
还有一个这个

41:26.520 --> 41:27.520
还有一个这个东西

41:27.520 --> 41:29.520
还有一个什么呢

41:29.520 --> 41:32.520
还有一个就是require本身

41:32.520 --> 41:34.520
它的顺序应该是这样子

41:34.520 --> 41:36.520
DIRNM在这

41:36.520 --> 41:38.520
DIRNM在这

41:39.520 --> 41:40.520
你们可以根据这个

41:40.520 --> 41:41.520
Occument来看一下

41:41.520 --> 41:42.520
就可以调整一下

41:42.520 --> 41:43.520
我这里主要是给大家说一下

41:43.520 --> 41:45.520
它里边可以用到哪些东西

41:45.520 --> 41:48.520
这里边第三个是码酒

41:48.520 --> 41:50.520
这里边是require

41:50.520 --> 41:52.520
这个是export

41:52.520 --> 41:53.520
应该是这样子

41:53.520 --> 41:54.520
应该是这样子的顺序

41:54.520 --> 41:55.520
无所谓吧

41:55.520 --> 41:56.520
我们不用管它顺序

41:56.520 --> 41:57.520
总之它这些东西

41:57.520 --> 41:58.520
都会传给它

41:58.520 --> 42:00.520
还有一个参数是require

42:00.520 --> 42:02.520
我这里就直接写到最后吧

42:02.520 --> 42:04.520
直接写到最后

42:04.520 --> 42:06.520
DIRNM

42:06.520 --> 42:09.080
require

42:09.080 --> 42:10.080
为什么呢

42:10.080 --> 42:11.080
为什么还要把require传进去了

42:11.080 --> 42:12.080
这个require是啥

42:12.080 --> 42:14.080
这个require其实就是

42:14.080 --> 42:16.080
我们这个函数本身require

42:16.080 --> 42:17.080
就是这个函数本身

42:17.080 --> 42:18.080
要把这东西传进去

42:18.080 --> 42:19.080
为什么要把它传进去了

42:19.080 --> 42:20.080
因为这个模块里边

42:20.080 --> 42:22.080
它是不是有可能导入别的模块

42:22.080 --> 42:23.080
对不对

42:23.080 --> 42:25.080
它是不是有可能会导入别的模块

42:25.080 --> 42:26.080
那么它导入别的模块

42:26.080 --> 42:27.080
是不是要用到这个require函数

42:27.080 --> 42:29.080
所以你不可以传给它的话

42:29.080 --> 42:30.080
它在函数里边

42:30.080 --> 42:31.080
哪去找这个require函数呢

42:31.080 --> 42:32.080
它找不到了

42:32.080 --> 42:33.080
没意思吧

42:33.080 --> 42:35.080
所以它会把require函数传进去

42:35.080 --> 42:37.080
像我们这个入口模块

42:37.080 --> 42:38.080
它其实也是当成一个

42:38.080 --> 42:39.080
模块环境执行的

42:39.080 --> 42:41.080
它也是在一个函数环境里边执行

42:41.080 --> 42:43.080
就是我们这个index来的介绍

42:43.080 --> 42:44.080
它也是通过这种方式

42:44.080 --> 42:46.080
把require传给我们的

42:46.080 --> 42:48.080
弄到底层的处理方式

42:48.080 --> 42:49.080
那么我们通过这种方式

42:49.080 --> 42:50.080
你看模块里边

42:50.080 --> 42:51.080
它可以使用它

42:51.080 --> 42:52.080
可以使用它

42:52.080 --> 42:53.080
可以使用它

42:53.080 --> 42:54.080
可以使用它

42:54.080 --> 42:58.460
这些东西都不是权局编样的

42:58.460 --> 42:59.460
就是看一下

42:59.460 --> 43:00.460
这些玩意儿

43:00.460 --> 43:01.460
它们都不是权局编样的

43:01.460 --> 43:04.460
你在global里边找require

43:04.460 --> 43:08.950
undefined

43:08.950 --> 43:09.950
看到没

43:09.950 --> 43:12.950
你在global里边找DIR

43:12.950 --> 43:13.950
能找到吗

43:13.950 --> 43:14.950
找不到

43:14.950 --> 43:15.950
那就起来怪了

43:15.950 --> 43:16.950
它不是权局编样

43:16.950 --> 43:17.950
我们怎么可能会使用

43:17.950 --> 43:18.950
能够使用了

43:18.950 --> 43:19.950
就是因为它是在一个函数

43:19.950 --> 43:20.950
环境里边执行

43:20.950 --> 43:22.950
这些东西全是函数的参数

43:22.950 --> 43:24.950
这是它的本质

43:25.950 --> 43:26.950
全是函数的参数

43:26.950 --> 43:27.950
我们这里写的顺序

43:27.950 --> 43:28.950
实际顺序不太一样

43:28.950 --> 43:30.950
大家可以自己下来

43:30.950 --> 43:31.950
根据这个argument

43:31.950 --> 43:32.950
这个结果

43:32.950 --> 43:33.950
可以看一下它的实际的顺序

43:34.950 --> 43:36.950
好 那么这就是模块的执行方式

43:37.950 --> 43:39.950
知道这个执行方式之后

43:39.950 --> 43:44.600
我们再来看这些面试题

43:46.600 --> 43:47.600
我把这个注射掉

43:47.600 --> 43:49.600
我们再来看那个模块里边的面试题

43:50.600 --> 43:51.600
首先这个

43:51.600 --> 43:52.600
这里还没修完

43:52.600 --> 43:53.600
还有一点点

43:53.600 --> 43:55.600
模块执行完了过后

43:55.600 --> 43:57.600
它会做一件事

43:57.600 --> 43:59.600
因为这是一个require函数

43:59.600 --> 44:00.600
它会做一件事

44:00.600 --> 44:01.600
做什么事呢

44:01.600 --> 44:02.600
把模块的执行完了过后

44:02.600 --> 44:04.600
它会把这个modular export

44:04.600 --> 44:06.600
保存在缓存里边

44:07.600 --> 44:09.600
保存在缓存里边

44:09.600 --> 44:10.600
保存在这

44:11.600 --> 44:12.600
保存到之后理想一下

44:13.600 --> 44:15.600
模块的决定度径就是模块的id

44:16.600 --> 44:18.600
它就把它作为属性保存在这

44:19.600 --> 44:20.600
好 保存完了过后

44:22.600 --> 44:23.600
然后呢

44:23.600 --> 44:25.600
这边是模块的倒出结果

44:25.600 --> 44:30.450
之前的倒出结果

44:30.450 --> 44:31.450
export

44:31.450 --> 44:32.450
倒出结果

44:35.080 --> 44:36.080
34

44:36.080 --> 44:38.080
它下一次在倒入模块的时候

44:38.080 --> 44:40.080
是不是在这里就进入判断了

44:40.080 --> 44:42.080
之前那个模块id相同

44:42.080 --> 44:44.080
那么这里是不是有缓存了

44:44.080 --> 44:45.080
它就不会再去执行这个模块了

44:45.080 --> 44:46.080
后面再马上就不会运行了

44:46.080 --> 44:48.080
它直接返回这个缓存结果

44:48.080 --> 44:49.080
对吧

44:49.080 --> 44:51.080
这是node接使对模块化的缓存方式

44:51.080 --> 44:52.080
好 那么接下来的面试题

44:52.080 --> 44:53.080
各种面试题来了

44:53.080 --> 44:54.080
第一个面试题

44:54.080 --> 44:55.080
最简单的

44:56.080 --> 44:57.080
输出123

44:59.650 --> 45:00.650
我们这里

45:00.650 --> 45:01.650
倒入多少次呢

45:03.650 --> 45:06.480
点错了

45:06.480 --> 45:07.480
倒多少次

45:07.480 --> 45:08.480
顺便写个

45:10.480 --> 45:11.480
快捷键那边

45:11.480 --> 45:17.480
用输了这边一步不输了

45:17.480 --> 45:18.480
复制一下了

45:19.480 --> 45:21.480
我都直接快成神经病了

45:21.480 --> 45:22.480
两个系统

45:22.480 --> 45:23.480
迈克系统跟温州市系统

45:23.480 --> 45:24.480
换了换去用

45:24.480 --> 45:25.480
好 那么这样子

45:25.480 --> 45:27.480
我们使用了六次

45:27.480 --> 45:28.480
倒入了六次

45:28.480 --> 45:29.480
那么请问一下

45:29.480 --> 45:31.480
这边的输出

45:31.480 --> 45:32.480
会输出几次

45:32.480 --> 45:35.980
有时候都知道了

45:35.980 --> 45:36.980
所以只答应一次

45:37.980 --> 45:38.980
对吧 一次

45:38.980 --> 45:39.980
为什么 第二次它就有缓存了

45:39.980 --> 45:40.980
同一个模块

45:40.980 --> 45:41.980
它是有缓存结果的

45:41.980 --> 45:42.980
同一个模块

45:42.980 --> 45:43.980
它是有缓存的

45:43.980 --> 45:44.980
之前已经缓存过了

45:44.980 --> 45:45.980
它只要执行一次就够了

45:45.980 --> 45:46.980
执行一次不合

45:46.980 --> 45:47.980
它之前的缓存结果

45:47.980 --> 45:48.980
就已经出来了

45:48.980 --> 45:49.980
所以我只要把这个缓存结果

45:49.980 --> 45:50.980
拿出来就行了

45:50.980 --> 45:51.980
好 这是第一个

45:51.980 --> 45:52.980
再来

45:53.980 --> 45:54.980
我这里使用

45:54.980 --> 45:55.980
exports

45:55.980 --> 45:57.980
点A等于3

45:57.980 --> 45:58.980
exports

45:58.980 --> 46:00.980
点B等于123

46:00.980 --> 46:01.980
module

46:02.980 --> 46:03.980
B等于4吗

46:03.980 --> 46:04.980
module

46:04.980 --> 46:05.980
exports

46:06.980 --> 46:07.980
exports

46:08.980 --> 46:09.980
等于什么呢

46:12.980 --> 46:16.360
点C等于5

46:16.360 --> 46:17.360
温力

46:17.360 --> 46:18.360
我这边导入

46:18.360 --> 46:20.360
这个模块的时候

46:20.360 --> 46:21.360
把导入的结果

46:21.360 --> 46:22.360
放到一个变量里面

46:22.360 --> 46:23.360
那么这个变量里面

46:23.360 --> 46:26.800
有几个属性

46:26.800 --> 46:27.800
分别是啥

46:27.800 --> 46:28.800
属性分别是啥

46:28.800 --> 46:33.920
几个属性呢

46:36.920 --> 46:37.920
一个

46:37.920 --> 46:38.920
好好看一下

46:38.920 --> 46:39.920
三个

46:39.920 --> 46:40.920
是不是三个

46:41.920 --> 46:44.940
来吧

46:44.940 --> 46:45.940
是不是三个属性

46:45.940 --> 46:46.940
为什么是三个属性呢

46:46.940 --> 46:50.380
我们来看一下一个代码

46:50.380 --> 46:52.380
这里给exportsA

46:52.380 --> 46:53.380
等于3

46:53.380 --> 46:54.380
exports到底是个啥玩意儿呢

46:54.380 --> 46:55.380
你看一下

46:55.380 --> 46:57.380
exports不就是个对象吗

46:57.380 --> 46:58.380
你看exports

46:58.380 --> 46:59.380
给他的是他

46:59.380 --> 47:00.380
给他的就是一个对象

47:00.380 --> 47:01.380
就是这个module的exports

47:01.380 --> 47:03.380
是不是对象

47:03.380 --> 47:04.380
那么这个exports传给他

47:04.380 --> 47:06.380
是不是传的出这个对象给他

47:06.380 --> 47:07.380
那么他是不是在这个对象里面

47:07.380 --> 47:08.380
加属性

47:08.380 --> 47:09.380
加A等于A和B

47:09.380 --> 47:10.380
两个属性加进去了

47:10.380 --> 47:11.380
对吧

47:11.380 --> 47:12.380
那么这个对象里面

47:12.380 --> 47:13.380
是不是有两个属性了

47:13.380 --> 47:14.380
A

47:14.380 --> 47:15.380
等于3

47:15.380 --> 47:16.380
B等于4

47:16.380 --> 47:17.380
是不是加进去了

47:17.380 --> 47:18.380
相当于是往这里面加

47:18.380 --> 47:19.380
对吧

47:19.380 --> 47:21.380
接下来用module.exports.c

47:21.380 --> 47:22.380
等于5

47:22.380 --> 47:23.380
那是什么意思呢

47:23.380 --> 47:24.380
你看module在哪

47:24.380 --> 47:25.380
module在这对不对

47:25.380 --> 47:26.380
我们是不是通过

47:26.380 --> 47:27.380
把人module整个对象传给他

47:27.380 --> 47:28.380
他通过这个对象

47:28.380 --> 47:29.380
是不是

47:29.380 --> 47:31.380
又通过这个module.exports

47:31.380 --> 47:32.380
是不是又给他

47:32.380 --> 47:33.380
加了一个属性C

47:34.380 --> 47:35.380
所以加进来了

47:35.380 --> 47:36.380
那么最终

47:36.380 --> 47:37.380
我们用的是

47:37.380 --> 47:39.380
用的就是module.exports

47:39.380 --> 47:40.380
所以用了这个玩意儿

47:40.380 --> 47:41.380
module.exports

47:41.380 --> 47:42.380
用了这个玩意儿

47:42.380 --> 47:43.380
对吧

47:43.380 --> 47:44.380
返回的

47:44.380 --> 47:45.380
这个require寒数返回的

47:45.380 --> 47:46.380
也是这个玩意儿

47:46.380 --> 47:48.380
缓存的也是这个玩意儿

47:48.380 --> 47:49.380
是吧

47:49.380 --> 47:50.380
是不是3个属性

47:50.380 --> 47:51.380
没问题吧

47:51.380 --> 47:57.530
好

47:57.530 --> 48:00.550
再来

48:00.550 --> 48:01.550
这样子

48:01.550 --> 48:02.550
面试他就会

48:02.550 --> 48:05.880
各种恶心

48:05.880 --> 48:06.880
这样子

48:06.880 --> 48:09.640
这样子有几个属性

48:09.640 --> 48:10.640
出来

48:10.640 --> 48:11.640
有几个属性

48:12.640 --> 48:13.640
这样子

48:13.640 --> 48:14.640
是不是就只有一个了

48:14.640 --> 48:15.640
为什么呢

48:15.640 --> 48:16.640
我们又来看吧

48:16.640 --> 48:17.640
一开始给他的是一个

48:17.640 --> 48:18.640
什么呢

48:18.640 --> 48:19.640
给他的是一个空对象

48:19.640 --> 48:20.640
对吧

48:20.640 --> 48:21.640
空对象

48:21.640 --> 48:22.640
然后呢

48:22.640 --> 48:23.640
把那些乱七八糟传给他

48:23.640 --> 48:24.640
然后接下来干嘛呢

48:24.640 --> 48:25.640
接下来干了什么事

48:25.640 --> 48:26.640
exportsA

48:26.640 --> 48:27.640
等于3

48:27.640 --> 48:28.640
B

48:28.640 --> 48:29.640
等于3

48:29.640 --> 48:30.640
因为他都是一个对象

48:30.640 --> 48:31.640
对不对

48:31.640 --> 48:32.640
B等于4

48:32.640 --> 48:33.640
对吧

48:33.640 --> 48:34.640
这样子好像是没问题的

48:34.640 --> 48:35.640
但是接下来

48:35.640 --> 48:36.640
这句话

48:36.640 --> 48:37.640
出现问题了

48:37.640 --> 48:38.640
这句话是干嘛的

48:38.640 --> 48:39.640
通过margell.exports

48:39.640 --> 48:40.640
通过这个margell

48:40.640 --> 48:41.640
找到什么

48:41.640 --> 48:42.640
找到这个exports

48:43.640 --> 48:46.640
然后给他重新复制为一个新的对象

48:47.640 --> 48:49.640
是不是该重新复制为一个新的对象了

48:50.640 --> 48:51.640
新的对象一个属性

48:51.640 --> 48:52.640
C等于5

48:53.640 --> 48:54.640
对不对

48:54.640 --> 48:55.640
是不是变成这个样子

48:55.640 --> 48:56.640
该复制为一个新的对象

48:56.640 --> 48:57.640
那么这样子一来的话

48:57.640 --> 48:59.640
最终使用的是margell.exports

48:59.640 --> 49:02.640
是不是得到只有一个属性5

49:02.640 --> 49:03.640
看一下吧

49:03.640 --> 49:04.640
右键

49:04.640 --> 49:05.640
软扣的

49:05.640 --> 49:06.640
清楚

49:06.640 --> 49:07.640
再重新来

49:07.640 --> 49:08.640
就得到一个属性5

49:08.640 --> 49:09.640
那么之前的一说

49:09.640 --> 49:11.640
之前的没用了

49:11.640 --> 49:12.640
当然就没用了

49:12.640 --> 49:14.640
那就没用了

49:14.640 --> 49:15.640
好

49:15.640 --> 49:16.640
再来

49:16.640 --> 49:17.640
看能不能绕不晕啊

49:17.640 --> 49:18.640
发觉没

49:18.640 --> 49:19.640
如果说我把你绕不晕的话

49:19.640 --> 49:20.640
那就

49:20.640 --> 49:21.640
练习就绕不晕

49:21.640 --> 49:27.960
现在有几个属性的

49:27.960 --> 49:28.960
三个

49:29.960 --> 49:30.960
呵呵

49:32.960 --> 49:35.790
有几个

49:35.790 --> 49:36.790
现在还是只有一个

49:37.790 --> 49:38.790
还是只有一个

49:38.790 --> 49:40.790
那这又怎么解释呢

49:40.790 --> 49:41.790
你给我解释啊

49:41.790 --> 49:42.790
这个又怎么解释呢

49:42.790 --> 49:43.790
好来吧

49:45.790 --> 49:46.790
你看啊

49:46.790 --> 49:47.790
这个地方是很粗暴的

49:48.790 --> 49:49.790
我现在

49:49.790 --> 49:50.790
一开始的时候

49:50.790 --> 49:51.790
这个对象

49:52.790 --> 49:53.790
给到谁

49:53.790 --> 49:54.790
给到exports

49:54.790 --> 49:55.790
对不对

49:55.790 --> 49:56.790
是不是给到他

49:56.790 --> 49:57.790
那么接下来

49:57.790 --> 49:59.790
他说了一件什么事

49:59.790 --> 50:00.790
margell.exports

50:00.790 --> 50:02.790
复制过一个新的对象

50:02.790 --> 50:04.790
是不是不再是之前的对象了

50:04.790 --> 50:05.790
对吧

50:05.790 --> 50:07.790
那么之前的这个exports

50:07.790 --> 50:09.790
还指向的是什么

50:09.790 --> 50:10.790
指向的是

50:10.790 --> 50:11.790
之前的那个对象

50:11.790 --> 50:12.790
空对象

50:12.790 --> 50:13.790
但是接下来

50:13.790 --> 50:14.790
我们用margell.exports

50:14.790 --> 50:15.790
把一个exports改了

50:15.790 --> 50:16.790
是吧

50:16.790 --> 50:19.790
他里边的margell.exports

50:19.790 --> 50:20.790
改了

50:20.790 --> 50:21.790
改成什么了

50:21.790 --> 50:22.790
改成一个新的对象了

50:22.790 --> 50:23.790
c等于3

50:24.790 --> 50:25.790
c等于5

50:25.790 --> 50:26.790
那么

50:26.790 --> 50:27.790
是不是这里变成c等于5

50:27.790 --> 50:29.790
但是之前那个空对象

50:29.790 --> 50:31.790
是不是还是由他来指向的

50:31.790 --> 50:32.790
对不对

50:32.790 --> 50:33.790
他还是还是指向了

50:33.790 --> 50:34.790
这个空对象

50:34.790 --> 50:35.790
这是涉及到什么呢

50:35.790 --> 50:36.790
这是涉及到

50:36.790 --> 50:38.790
gs基础里面的对象引用地址

50:39.790 --> 50:40.790
明白的意思吧

50:40.790 --> 50:41.790
也就说

50:41.790 --> 50:42.790
我们看到的对象

50:42.790 --> 50:43.790
现在看到的

50:43.790 --> 50:44.790
c等于5的对象

50:44.790 --> 50:45.790
已经不再是

50:45.790 --> 50:47.790
之前的那个空对象了

50:47.790 --> 50:48.790
已经不再是之前

50:48.790 --> 50:49.790
最开始的空对象了

50:49.790 --> 50:50.790
明白的意思吧

50:50.790 --> 50:52.790
已经不再是他了

50:52.790 --> 50:53.790
但是呢

50:53.790 --> 50:54.790
我们之前那个参数

50:54.790 --> 50:55.790
指向的还是

50:55.790 --> 50:56.790
之前的那个对象

50:56.790 --> 50:57.790
我这里给大家画个图

50:57.790 --> 50:59.790
免得大家蒙了

51:00.790 --> 51:01.790
画个图就明白了

51:08.640 --> 51:09.640
这是我们的

51:11.640 --> 51:12.640
march

51:13.640 --> 51:14.640
march一开始是什么样子

51:14.640 --> 51:16.640
一开始里边是一个

51:17.640 --> 51:18.640
一个对象

51:18.640 --> 51:19.640
对象里边有个什么呢

51:19.640 --> 51:21.640
有一个exports

51:21.640 --> 51:24.600
对吧

51:24.600 --> 51:25.600
有一个exports

51:25.600 --> 51:27.600
这个exports指向谁呢

51:27.600 --> 51:28.600
指向另外一个对象

51:28.600 --> 51:30.600
指向另外一个空对象

51:31.600 --> 51:32.600
指向另外一个空对象

51:32.600 --> 51:34.600
我用两个大括号表示吧

51:35.600 --> 51:36.600
这样呢

51:36.600 --> 51:37.600
用箭头连接一下啊

51:40.360 --> 51:41.360
没问题吧

51:41.360 --> 51:42.360
这是目前的情况

51:42.360 --> 51:43.360
march是一个对象

51:43.360 --> 51:44.360
march里边有个

51:44.360 --> 51:45.360
有个属向exports

51:45.360 --> 51:46.360
他指向一个空对象

51:46.360 --> 51:47.360
然后呢

51:47.360 --> 51:48.360
接下来我们去调用

51:48.360 --> 51:49.360
这个函数

51:49.360 --> 51:50.360
就是执行那个模块

51:50.360 --> 51:51.360
执行那个模块的时候

51:51.360 --> 51:52.360
模块里面不是有两个东西吗

51:52.360 --> 51:53.360
一个是什么呢

51:53.360 --> 51:54.360
一个是march

51:54.360 --> 51:55.360
模块里面的march

51:55.360 --> 51:56.360
是不是直接把march

51:56.360 --> 51:57.360
传过去了

51:57.360 --> 51:58.360
所以march里面的march

51:58.360 --> 51:59.360
也是一样

52:03.330 --> 52:04.330
march里面的march

52:04.330 --> 52:07.990
也是一样的

52:07.990 --> 52:08.990
march里面的march

52:08.990 --> 52:09.990
就是模块里面的march

52:09.990 --> 52:11.990
然后模块里面的什么exports

52:12.990 --> 52:13.990
指向的是谁呢

52:13.990 --> 52:14.990
模块里面的exports

52:14.990 --> 52:15.990
指向的是这个

52:15.990 --> 52:18.940
指向的是这个东西

52:18.940 --> 52:20.940
你看一下我们带码

52:20.940 --> 52:21.940
模块里面的march

52:21.940 --> 52:22.940
就是exports

52:22.940 --> 52:24.940
把这个对象的地址

52:24.940 --> 52:25.940
复制给什么呢

52:25.940 --> 52:26.940
传递给参数exports

52:26.940 --> 52:27.940
传递给他

52:27.940 --> 52:28.940
所以他指向的是他

52:28.940 --> 52:29.940
那么接下来我们来看

52:29.940 --> 52:31.940
他怎么来变动的

52:32.940 --> 52:33.940
我们这里呢

52:33.940 --> 52:34.940
把march.exports

52:34.940 --> 52:35.940
复制为一个新的对象

52:35.940 --> 52:36.940
C等于5

52:36.940 --> 52:37.940
那么就相当于

52:37.940 --> 52:38.940
是不是一个新的对象出来了

52:38.940 --> 52:39.940
一个新的对象

52:39.940 --> 52:40.940
C等于5

52:41.940 --> 52:42.940
然后让这个什么

52:42.940 --> 52:43.940
march.exports

52:43.940 --> 52:44.940
是不是指向他

52:45.940 --> 52:46.940
去指向他

52:46.940 --> 52:47.940
那么你看一下这个结构

52:47.940 --> 52:49.940
是不是原来的这个exports

52:49.940 --> 52:50.940
模块里面原来的exports

52:50.940 --> 52:51.940
还指向了原来的东西

52:51.940 --> 52:52.940
对不对

52:52.940 --> 52:53.940
march.exports

52:53.940 --> 52:54.940
指向的是他了

52:54.940 --> 52:55.940
能看懂了吗

52:56.940 --> 52:57.940
能看懂了吗

52:58.940 --> 52:59.940
这样的图应该看懂了吧

52:59.940 --> 53:00.940
那么所以说

53:00.940 --> 53:01.940
你后边再去改

53:01.940 --> 53:02.940
这个exports里面的东西

53:03.940 --> 53:04.940
再去改这两个东西

53:04.940 --> 53:05.940
是改动了什么

53:05.940 --> 53:06.940
改动了原来的对象

53:06.940 --> 53:07.940
但是原来的对象

53:07.940 --> 53:08.940
跟导出已经没关系了

53:08.940 --> 53:09.940
因为我们导出的时候

53:09.940 --> 53:11.940
始终导出的是什么

53:11.940 --> 53:12.940
march.exports

53:13.940 --> 53:14.940
始终导出这个

53:14.940 --> 53:15.940
这是它的原理

53:15.940 --> 53:16.940
如果说你不想知道原理

53:16.940 --> 53:17.940
我就想知道怎么做提

53:17.940 --> 53:18.940
那里就记住

53:18.940 --> 53:20.940
只要这个玩意重新复制

53:20.940 --> 53:22.940
跟它就毫无关系了

53:22.940 --> 53:24.940
一点关系都没了

53:24.940 --> 53:25.940
你看这个图举

53:25.940 --> 53:26.940
知道为什么没关系了

53:26.940 --> 53:28.940
只要给它重新复制

53:28.940 --> 53:30.940
给这个exports重新复制

53:30.940 --> 53:32.940
那么跟这个exports

53:32.940 --> 53:33.940
就没有任何关系了

53:34.940 --> 53:35.940
一样的意思吧

53:35.940 --> 53:36.940
同时跟什么

53:36.940 --> 53:39.940
同时跟ZS有没有任何关系的

53:39.940 --> 53:40.940
因为绑定了ZS

53:40.940 --> 53:41.940
绑定了也是一个玩意

53:41.940 --> 53:42.940
对吧

53:42.940 --> 53:45.890
ZS

53:45.890 --> 53:47.890
ZS绑定了也是一个玩意

53:48.890 --> 53:49.890
模块里边的ZS

53:49.890 --> 53:50.890
绑定了也是一个玩意

53:50.890 --> 53:52.890
跟它就没有任何关系了

53:52.890 --> 53:54.890
那么我们可以再来

53:54.890 --> 53:55.890
随便再来新面

53:55.890 --> 53:56.890
就行吧

53:56.890 --> 53:59.460
然后我们这里放进去

53:59.460 --> 54:01.460
只要可以用个立名寒书

54:01.460 --> 54:02.460
随便一个发立名寒书都行

54:02.460 --> 54:04.460
然后exports

54:04.460 --> 54:06.460
A等于3

54:06.460 --> 54:08.460
2exports

54:08.460 --> 54:09.460
B等于3

54:09.460 --> 54:12.350
那么这里

54:12.350 --> 54:13.350
比方说我们这里

54:13.350 --> 54:14.350
输出绿道数点

54:14.350 --> 54:15.350
A

54:15.350 --> 54:16.350
输出啥

54:17.350 --> 54:18.350
看一下啊

54:18.350 --> 54:19.350
这是一个寒书

54:20.350 --> 54:21.350
AB

54:21.350 --> 54:22.350
对吧

54:22.350 --> 54:23.350
这边输出啥

54:23.350 --> 54:27.260
就是undefended

54:27.260 --> 54:28.260
对不对

54:28.260 --> 54:29.260
就undefended了

54:29.260 --> 54:30.260
这肯定就是undefended

54:30.260 --> 54:33.340
这它没关系了

54:33.340 --> 54:34.340
对吧

54:34.340 --> 54:35.340
那我怎么来理解呢

54:35.340 --> 54:36.340
就是这样子

54:36.340 --> 54:37.340
exports它变成一个什么

54:37.340 --> 54:38.340
变成一个寒书了

54:38.340 --> 54:39.340
给它复制一个寒书

54:39.340 --> 54:41.340
那跟之前那个exports有啥关系了

54:41.340 --> 54:42.340
一点关系都没有

54:42.340 --> 54:43.340
对吧

54:43.340 --> 54:44.340
之前一个sports

54:44.340 --> 54:45.340
再加个2

54:45.340 --> 54:46.340
加一个3

54:46.340 --> 54:48.340
但是导出的是啥

54:48.340 --> 54:50.340
导出的是modularexports

54:50.340 --> 54:51.340
你看吧

54:51.340 --> 54:52.340
导出的是什么呢

54:52.340 --> 54:54.340
导出的是modularexports

54:54.340 --> 54:55.340
就是真正返回的

54:55.340 --> 54:57.340
这个寒书返回的结果

54:57.340 --> 54:58.340
是modularexports

54:58.340 --> 55:00.340
跟之前的exports

55:00.340 --> 55:01.340
没有任何关系的

55:01.340 --> 55:02.340
就你们以后

55:02.340 --> 55:04.340
先弹码注意一下

55:04.340 --> 55:05.340
如果说你怕出错的话

55:05.340 --> 55:07.340
那么两种选一种

55:07.340 --> 55:09.340
这种邪法

55:09.340 --> 55:10.340
可以

55:10.340 --> 55:11.340
这种邪法也可以

55:11.340 --> 55:12.340
但是不要混折

55:12.340 --> 55:13.340
混折就容易出错

55:15.340 --> 55:17.340
如果说掌控不好的话

55:17.340 --> 55:18.340
因为平时我们写的话

55:18.340 --> 55:20.340
一般就之后使用这个

55:20.340 --> 55:22.340
要么就是全部使用这个

55:22.340 --> 55:23.340
不要混折用

55:23.340 --> 55:24.340
好 那么再来一个例子

55:24.340 --> 55:27.340
这里边我们再来一个

55:28.340 --> 55:29.340
比方说

55:30.340 --> 55:31.340
啥都不行

55:31.340 --> 55:32.340
这个模块是空的

55:32.340 --> 55:33.340
啥都没有

55:33.340 --> 55:34.340
啥都没有

55:34.340 --> 55:36.340
那么这个result是啥

55:36.340 --> 55:44.130
请问一下这个result是啥

55:44.130 --> 55:45.130
result

55:45.130 --> 55:46.130
好好想一想

55:46.130 --> 55:51.750
这个result到底是啥

55:51.750 --> 55:52.750
空对象

55:52.750 --> 55:53.750
它不是说没有指

55:53.750 --> 55:54.750
它是空对象

55:54.750 --> 55:55.750
它是空对象

55:55.750 --> 55:56.750
你看没

55:56.750 --> 55:57.750
为什么是空对象

55:57.750 --> 55:58.750
你看这个逻辑吗

55:58.750 --> 56:00.750
它最开始的结果是什么

56:00.750 --> 56:02.750
最开始的就是这样子

56:02.750 --> 56:05.060
最开始就是这样子

56:05.060 --> 56:06.060
对吧 指向有空对象

56:06.060 --> 56:07.060
然后传给你

56:07.060 --> 56:08.060
把module传给你

56:08.060 --> 56:09.060
然后传给你的模块

56:09.060 --> 56:10.060
对吧 这下面是模块

56:10.060 --> 56:11.060
里面的东西

56:11.060 --> 56:13.060
模块里面的module

56:13.060 --> 56:14.060
exports z

56:14.060 --> 56:15.060
对不对

56:15.060 --> 56:16.060
z怎么一般都不会用

56:16.060 --> 56:17.060
一般都不会用

56:17.060 --> 56:18.060
那么这就是

56:18.060 --> 56:19.060
它的最初的情况

56:19.060 --> 56:20.060
所以说你啥都没写的话

56:20.060 --> 56:21.060
那么导出的结果是啥

56:21.060 --> 56:22.060
导出的结果就是

56:22.060 --> 56:23.060
module的exports

56:23.060 --> 56:24.060
就是这个玩意

56:24.060 --> 56:25.060
所以就是个空对象

56:25.060 --> 56:26.060
那么我又问大家一个问题

56:26.060 --> 56:28.060
这里底儿要爆出吗

56:28.060 --> 56:32.840
要爆出吗

56:32.840 --> 56:33.840
要不要爆出了

56:33.840 --> 56:34.840
这里

56:34.840 --> 56:35.840
所以不会爆出

56:35.840 --> 56:36.840
它会输出ond犯的

56:36.840 --> 56:37.840
因为它空对象里面

56:37.840 --> 56:39.840
读取属性是不会爆出的

56:39.840 --> 56:40.840
从大俄和ond犯里面

56:40.840 --> 56:41.840
读取属性要爆出的

56:41.840 --> 56:43.840
对吧 这里是有点糟

56:43.840 --> 56:44.840
这里是有点糟

56:45.840 --> 56:46.840
下来过后

56:46.840 --> 56:47.840
你好好去理解一下

56:47.840 --> 56:48.840
这个代码

56:48.840 --> 56:49.840
你把这个代码

56:49.840 --> 56:50.840
好好去看一下

56:50.840 --> 56:51.840
看一下这个伪代码

56:51.840 --> 56:52.840
多看几次

56:52.840 --> 56:53.840
就不糟了

56:53.840 --> 56:54.840
这个代码你只要看懂了

56:54.840 --> 56:56.840
基本上所有的关于

56:56.840 --> 56:57.840
common介绍模块化的题

56:57.840 --> 56:58.840
难不道理了

56:58.840 --> 56:59.840
难不道理

56:59.840 --> 57:00.840
因为它的本质里

57:00.840 --> 57:01.840
就知道是怎么回事

57:02.840 --> 57:03.840
这是这一块

57:03.840 --> 57:04.840
关于common介绍

57:04.840 --> 57:05.840
模块化的东西

57:05.840 --> 57:06.840
其实我们平时开发的话

57:06.840 --> 57:08.840
跟我们平时开发有多少关系

57:08.840 --> 57:09.840
没多少关系

57:09.840 --> 57:10.840
放轻松一点

57:10.840 --> 57:12.840
平时我们开发的导出就用它

57:12.840 --> 57:13.840
要么就用它

57:13.840 --> 57:14.840
随便

57:14.840 --> 57:16.840
两个不要混着用就完事了

57:16.840 --> 57:18.840
一个要么就用它

57:18.840 --> 57:20.840
这是关于这一块

57:21.840 --> 57:22.840
接下来

57:22.840 --> 57:23.840
我们来说一下

57:23.840 --> 57:24.840
模块的查照

57:24.840 --> 57:26.840
这里也是容易出面是题

57:26.840 --> 57:27.840
因为这两个地方

57:27.840 --> 57:28.840
我实际上说白了

57:28.840 --> 57:30.840
我这个代码培训我不想讲的

57:30.840 --> 57:31.840
这个模块查照我也不想讲的

57:31.840 --> 57:33.840
这是容易出面是题

57:33.840 --> 57:35.840
模块查照是怎么找的

57:35.840 --> 57:37.840
它是根据情况

57:37.840 --> 57:38.840
模块路径

57:38.840 --> 57:40.840
如果说你这个开头

57:40.840 --> 57:41.840
或者是这个开头

57:41.840 --> 57:43.840
它是从当前模块路径

57:43.840 --> 57:45.840
出发去查照

57:45.840 --> 57:46.840
啥意思呢

57:46.840 --> 57:47.840
比方说这里

57:47.840 --> 57:48.840
这里很简单

57:48.840 --> 57:49.840
我们把这个保留一下

57:49.840 --> 57:50.840
我们用

57:50.840 --> 57:52.840
换一个B点解释

57:53.840 --> 57:54.840
B点解释

57:56.840 --> 57:58.840
我们这里也写一个

57:59.840 --> 58:00.840
A

58:00.840 --> 58:01.840
那么这里是不是导入模块

58:01.840 --> 58:03.840
导入模块的时候

58:04.840 --> 58:05.840
它离底儿的鞋杠

58:05.840 --> 58:07.840
或者是底儿的鞋杠开头

58:07.840 --> 58:08.840
它的查照方式是

58:08.840 --> 58:09.840
从当前模式

58:09.840 --> 58:10.840
就是说从这个模块

58:10.840 --> 58:12.840
B点解释出来的模式

58:12.840 --> 58:13.840
就在执行它嘛

58:13.840 --> 58:15.840
从这个模块的模式的出发

58:15.840 --> 58:16.840
去找什么

58:16.840 --> 58:18.840
找A

58:18.840 --> 58:19.840
A点解释

58:19.840 --> 58:20.840
那也可以这样的写

58:20.840 --> 58:22.840
比方说我们这里写个Sub

58:22.840 --> 58:25.480
把这里面新建一个

58:25.480 --> 58:26.480
A点解释

58:26.480 --> 58:28.480
如果说我这里写上

58:28.480 --> 58:31.480
RequireSub

58:31.480 --> 58:32.480
对吧

58:32.480 --> 58:33.480
是不是也可以

58:33.480 --> 58:34.480
也没问题的

58:34.480 --> 58:35.480
运行看一下吧

58:35.480 --> 58:37.480
现在就是露的B了

58:37.480 --> 58:38.480
运行B这个模块

58:38.480 --> 58:39.480
你看是不是没问题

58:39.480 --> 58:40.480
对吧 它没有爆错嘛

58:40.480 --> 58:41.480
它没问题

58:41.480 --> 58:42.480
模块能找到

58:42.480 --> 58:43.480
从当前模路出发

58:43.480 --> 58:44.480
对吧 这个很简单

58:44.480 --> 58:45.480
很好理解

58:45.480 --> 58:47.480
返回上级模路也是一样

58:47.480 --> 58:48.480
也很好理解

58:48.480 --> 58:49.480
这是这一块

58:49.480 --> 58:50.480
这种炒炒的方式

58:50.480 --> 58:51.480
好 另一种炒炒方式

58:51.480 --> 58:53.480
如果说你的模块路径

58:53.480 --> 58:55.480
不是一个开头

58:55.480 --> 58:57.480
那么它的炒炒方式

58:57.480 --> 58:58.480
就不会不一样了

58:58.480 --> 59:00.480
它会怎么炒到呢

59:00.480 --> 59:03.480
比方说我们在B里边写上

59:03.480 --> 59:08.480
Require

59:08.480 --> 59:09.480
Fs

59:09.480 --> 59:12.430
如果说

59:12.430 --> 59:14.430
你不是以底儿的鞋杠

59:14.430 --> 59:16.430
和底儿的鞋杠开头

59:16.430 --> 59:17.430
那么它的炒炒方式

59:17.430 --> 59:18.430
逻辑都不一样

59:18.430 --> 59:19.430
第一个

59:19.430 --> 59:20.430
它看一下

59:20.430 --> 59:21.430
是不是内置模块

59:21.430 --> 59:23.430
怎么叫内置模块

59:23.430 --> 59:25.430
就是安装好了

59:25.430 --> 59:26.430
漏的GS过后

59:26.430 --> 59:28.430
它给你自带的模块

59:28.430 --> 59:29.430
它有一些功能

59:29.430 --> 59:30.430
给你做了一些模块

59:30.430 --> 59:31.430
给你带进来了

59:31.430 --> 59:32.430
它看一下

59:32.430 --> 59:33.430
是不是内置模块

59:33.430 --> 59:35.430
内置模块有一些特殊的名字

59:35.430 --> 59:36.430
比方说Fs

59:36.430 --> 59:38.430
我们以后会说一下

59:38.430 --> 59:40.430
这个Fs就是一个内置模块

59:40.430 --> 59:41.430
你看我们有没有写

59:41.430 --> 59:42.430
这个Fs文件

59:42.430 --> 59:44.430
没有写吧

59:44.430 --> 59:45.430
没有写对不对

59:45.430 --> 59:47.430
我们来运行一下

59:47.430 --> 59:48.430
漏的B

59:48.430 --> 59:49.430
你看能不能打印出来

59:49.430 --> 59:50.430
可以打印出来

59:50.430 --> 59:51.430
它里面是一个对象

59:51.430 --> 59:53.430
有超级多的属性方法

59:53.430 --> 59:54.430
它里面是可以

59:54.430 --> 59:57.430
是能找到这个模块的

59:57.430 --> 59:59.430
它是一个内置模块

59:59.430 --> 01:00:03.960
Fs是个内置模块

01:00:03.960 --> 01:00:04.960
这是这种方式

01:00:04.960 --> 01:00:05.960
好

01:00:05.960 --> 01:00:06.960
另一种情况就是

01:00:06.960 --> 01:00:08.960
如果它不是内置模块

01:00:08.960 --> 01:00:09.960
比方说我这里写的是什么呢

01:00:09.960 --> 01:00:11.960
写的是ABC

01:00:11.960 --> 01:00:13.960
require

01:00:13.960 --> 01:00:14.960
require

01:00:14.960 --> 01:00:15.960
这里写的是ABC

01:00:15.960 --> 01:00:16.960
对吧

01:00:16.960 --> 01:00:17.960
我不是以底儿鞋杠

01:00:17.960 --> 01:00:18.960
底儿鞋杠开头

01:00:18.960 --> 01:00:19.960
所以说你们要用自己的模块的话

01:00:19.960 --> 01:00:20.960
一定要以底儿鞋杠

01:00:20.960 --> 01:00:21.960
和底儿鞋杠开头

01:00:21.960 --> 01:00:22.960
因为它的查到方式

01:00:22.960 --> 01:00:23.960
还是正常的查到方式

01:00:23.960 --> 01:00:24.960
如果说你不是

01:00:24.960 --> 01:00:25.960
一种方式开头

01:00:25.960 --> 01:00:26.960
那么ABC

01:00:26.960 --> 01:00:27.960
它在哪里去找呢

01:00:27.960 --> 01:00:28.960
它找的方式特别奇怪

01:00:28.960 --> 01:00:31.960
它是在一个特殊的目录里边去找

01:00:31.960 --> 01:00:32.960
首先看一下

01:00:32.960 --> 01:00:33.960
是不是内置模块

01:00:33.960 --> 01:00:34.960
ABC不是内置模块

01:00:34.960 --> 01:00:36.960
不是内置模块

01:00:36.960 --> 01:00:38.960
那么它会把它当做

01:00:38.960 --> 01:00:40.960
是第三方模块

01:00:40.960 --> 01:00:41.960
怎么要第三方模块

01:00:41.960 --> 01:00:42.960
就别人给你写的

01:00:42.960 --> 01:00:43.960
不是node写的

01:00:43.960 --> 01:00:45.960
也不是你写的

01:00:45.960 --> 01:00:46.960
是别人写的

01:00:46.960 --> 01:00:47.960
比方说什么

01:00:47.960 --> 01:00:48.960
require

01:00:48.960 --> 01:00:49.960
require

01:00:49.960 --> 01:00:50.960
这些东西

01:00:51.960 --> 01:00:52.960
第三方模块

01:00:52.960 --> 01:00:53.960
第三方模块

01:00:53.960 --> 01:00:54.960
node里边

01:00:54.960 --> 01:00:55.960
它认为是在

01:00:55.960 --> 01:00:56.960
所有的第三方模块

01:00:56.960 --> 01:00:57.960
都应该在一个

01:00:57.960 --> 01:00:58.960
统一的目录下面

01:00:59.960 --> 01:01:00.960
在哪里呢

01:01:00.960 --> 01:01:01.960
在这么一个目录

01:01:01.960 --> 01:01:04.960
叫做node modules

01:01:04.960 --> 01:01:05.960
在这个目录下面

01:01:05.960 --> 01:01:07.960
它会在这个目录里面去找

01:01:07.960 --> 01:01:08.960
它找一下这个目录里边

01:01:08.960 --> 01:01:09.960
有没有什么

01:01:09.960 --> 01:01:12.960
有没有ABC.js

01:01:13.960 --> 01:01:14.960
如果说有的话

01:01:14.960 --> 01:01:15.960
它就找到了

01:01:16.960 --> 01:01:17.960
它就找到了

01:01:17.960 --> 01:01:18.960
就这么简单

01:01:18.960 --> 01:01:19.960
我们这里能不能找到

01:01:20.960 --> 01:01:21.960
如果说我这样子写的话

01:01:21.960 --> 01:01:22.960
能不能找到

01:01:22.960 --> 01:01:26.610
这代码肯定给你们

01:01:26.610 --> 01:01:28.610
代码写的挺乱的

01:01:28.610 --> 01:01:29.610
能不能找到 是不是可以的

01:01:29.610 --> 01:01:30.610
对不对

01:01:30.610 --> 01:01:31.610
可以的

01:01:31.610 --> 01:01:32.610
我们来运行看一下吧

01:01:32.610 --> 01:01:33.610
右键运行

01:01:33.610 --> 01:01:34.610
ABC

01:01:34.610 --> 01:01:35.610
对吧 是不是能找到

01:01:35.610 --> 01:01:36.610
好

01:01:36.610 --> 01:01:37.610
如果说这里边

01:01:37.610 --> 01:01:39.610
也找不到这个ABC.js文件

01:01:39.610 --> 01:01:40.610
那怎么办呢

01:01:40.610 --> 01:01:41.610
它会去找这个

01:01:41.610 --> 01:01:44.610
它会去找这个ABC的目录

01:01:45.610 --> 01:01:46.610
它会去找这个

01:01:46.610 --> 01:01:47.610
比方说我们这里

01:01:47.610 --> 01:01:48.610
没有这个ABC.js文件

01:01:48.610 --> 01:01:49.610
它会去找这个目录

01:01:49.610 --> 01:01:50.610
下面的什么

01:01:50.610 --> 01:01:52.610
index.js

01:01:52.610 --> 01:01:54.610
这叫做缺省文件名

01:01:54.610 --> 01:01:56.610
然后我们这里输出一个

01:01:56.610 --> 01:01:58.610
ABC.index

01:01:58.610 --> 01:01:59.610
叫缺省文件名

01:01:59.610 --> 01:02:00.610
就是我可以不写文件名

01:02:00.610 --> 01:02:01.610
可以写个目录的名字

01:02:01.610 --> 01:02:02.610
那么它会自动的

01:02:02.610 --> 01:02:03.610
去找这个目录

01:02:03.610 --> 01:02:05.610
下面的index.js

01:02:05.610 --> 01:02:06.610
我们来看一下吧

01:02:06.610 --> 01:02:08.610
右键运行

01:02:08.610 --> 01:02:10.610
可以获取到 对吧

01:02:10.610 --> 01:02:11.610
那如果说

01:02:11.610 --> 01:02:12.610
都同时存在的话

01:02:12.610 --> 01:02:13.610
它一定是文件优先

01:02:13.610 --> 01:02:15.610
这是个原则

01:02:15.610 --> 01:02:16.610
文件优先

01:02:16.610 --> 01:02:17.610
找到文件

01:02:17.610 --> 01:02:18.610
我就不要去找目录了

01:02:18.610 --> 01:02:19.610
它一定是这个原则

01:02:19.610 --> 01:02:20.610
假如说我们这里有个ABC目录

01:02:20.610 --> 01:02:21.610
有一个ABC.js

01:02:21.610 --> 01:02:22.610
它找到谁呢

01:02:22.610 --> 01:02:23.610
它一定是找到文件

01:02:23.610 --> 01:02:25.610
文件优先ABC

01:02:25.610 --> 01:02:26.610
文件更加精确

01:02:26.610 --> 01:02:27.610
它也符合于

01:02:27.610 --> 01:02:28.610
软件设计的原则

01:02:28.610 --> 01:02:29.610
更加精确的东西

01:02:29.610 --> 01:02:31.610
一定是优先几重高的

01:02:31.610 --> 01:02:32.610
然后找不到

01:02:32.610 --> 01:02:33.610
才去找这个目录

01:02:33.610 --> 01:02:35.610
目录下面的index.js

01:02:35.610 --> 01:02:36.610
原来是吧

01:02:36.610 --> 01:02:38.610
它是这种查到方式

01:02:38.610 --> 01:02:40.610
是它的模块查到方式

01:02:40.610 --> 01:02:41.610
那么最后

01:02:41.610 --> 01:02:42.610
我们说一下缺省

01:02:42.610 --> 01:02:43.610
缺省就是说

01:02:43.610 --> 01:02:44.610
你在模块里边

01:02:44.610 --> 01:02:45.610
如果说存留到后追名

01:02:45.610 --> 01:02:46.610
就是调JS

01:02:46.610 --> 01:02:47.610
你可以不写

01:02:47.610 --> 01:02:48.610
默认后追名就是调JS

01:02:48.610 --> 01:02:50.610
如果说你在模块路径里边

01:02:50.610 --> 01:02:51.610
省略了文件名

01:02:51.610 --> 01:02:52.610
那么文件名

01:02:52.610 --> 01:02:53.610
它默认为

01:02:53.610 --> 01:02:54.610
index.js

01:02:54.610 --> 01:02:56.610
比方说像这个情况

01:02:56.610 --> 01:02:57.610
如果说找不到这个文件

01:02:57.610 --> 01:02:58.610
那么它就看到了

01:02:58.610 --> 01:02:59.610
有这个目录

01:02:59.610 --> 01:03:00.610
目录倒是有的

01:03:00.610 --> 01:03:01.610
是文件没有

01:03:01.610 --> 01:03:02.610
文件没有的情况下

01:03:02.610 --> 01:03:03.610
那么你又没有写

01:03:03.610 --> 01:03:04.610
你只写那个目录

01:03:04.610 --> 01:03:05.610
没有写文件名

01:03:05.610 --> 01:03:06.610
它默认就是

01:03:06.610 --> 01:03:07.610
index.js

01:03:07.610 --> 01:03:08.610
实际上这一块

01:03:08.610 --> 01:03:09.610
还有一些

01:03:09.610 --> 01:03:10.610
非常非常细的细节

01:03:10.610 --> 01:03:11.610
它不是说一定是这样子

01:03:11.610 --> 01:03:12.610
太细的东西

01:03:12.610 --> 01:03:13.610
我们就不在

01:03:13.610 --> 01:03:15.610
集训里面讲了

01:03:15.610 --> 01:03:16.610
太细了

01:03:16.610 --> 01:03:17.610
这里是关于这个

01:03:17.610 --> 01:03:18.610
index.js的件事

01:03:18.610 --> 01:03:20.610
可以省略了

01:03:20.610 --> 01:03:23.610
这样子可以找到的

01:03:23.610 --> 01:03:24.610
这是这个模块

01:03:24.610 --> 01:03:26.610
查到了路径

01:03:26.610 --> 01:03:27.610
查到的方式

01:03:27.610 --> 01:03:28.610
也是面试的时候

01:03:28.610 --> 01:03:29.610
你问到的题

01:03:29.610 --> 01:03:30.610
这一块咱们

01:03:30.610 --> 01:03:31.610
common.js结束

01:03:31.610 --> 01:03:32.610
common.js

01:03:32.610 --> 01:03:33.610
对于我们开发而言

01:03:33.610 --> 01:03:34.610
其实没有那么复杂

01:03:34.610 --> 01:03:36.610
我花了比较多的时间

01:03:36.610 --> 01:03:37.610
但是其实

01:03:37.610 --> 01:03:38.610
我们开发的时候

01:03:38.610 --> 01:03:39.610
真的没有那么复杂

01:03:39.610 --> 01:03:40.610
就是你要写单码

01:03:40.610 --> 01:03:41.610
写一个

01:03:41.610 --> 01:03:42.610
需要导出就导出

01:03:42.610 --> 01:03:43.610
需要导入就导入

01:03:43.610 --> 01:03:44.610
导入有两种方式

01:03:44.610 --> 01:03:45.610
导入自己的

01:03:46.610 --> 01:03:47.610
导入别人的

01:03:47.610 --> 01:03:48.610
就是放了个load

01:03:48.610 --> 01:03:49.610
码就是目录下面的

01:03:49.610 --> 01:03:51.610
那么你就直接写上名字

01:03:51.610 --> 01:03:52.610
就完事了

01:03:52.610 --> 01:03:54.610
就平时跟我们开发而言的话

01:03:54.610 --> 01:03:55.610
那么只有这点区别

01:03:55.610 --> 01:03:56.610
其他没有什么区别

01:03:57.610 --> 01:03:58.610
好 先让我们看下一个

01:03:59.610 --> 01:04:00.610
把load基础打好

01:04:00.610 --> 01:04:01.610
我们明天后天

01:04:01.610 --> 01:04:03.610
才可以讲东西

01:04:03.610 --> 01:04:04.610
NPM的使用

01:04:04.610 --> 01:04:05.610
我们刚才说了

01:04:05.610 --> 01:04:06.610
安装load的时候

01:04:06.610 --> 01:04:08.610
还会默认安装这个NPM

01:04:08.610 --> 01:04:09.610
这个NPM是什么呢

01:04:09.610 --> 01:04:11.610
它都叫做保管运气

01:04:11.610 --> 01:04:12.610
保管运气

01:04:12.610 --> 01:04:13.610
是咱们后期的

01:04:13.610 --> 01:04:14.610
专门一个课程

01:04:14.610 --> 01:04:15.610
大概有十多节课

01:04:15.610 --> 01:04:17.610
来讲保管运气

01:04:17.610 --> 01:04:19.610
保管运气有很多

01:04:19.610 --> 01:04:21.610
其中最常见的

01:04:21.610 --> 01:04:22.610
就是NPM

01:04:22.610 --> 01:04:24.610
也是全球通用的

01:04:24.610 --> 01:04:25.610
啥叫保管运气呢

01:04:27.610 --> 01:04:28.610
就是你平时开发的时候

01:04:28.610 --> 01:04:30.610
你不可能全部去自己写代

01:04:30.610 --> 01:04:32.610
我们把它叫做造轮子

01:04:32.610 --> 01:04:33.610
所有的轮子

01:04:33.610 --> 01:04:34.610
你不是全部自己造的

01:04:34.610 --> 01:04:35.610
别人一定给你写好的东西

01:04:35.610 --> 01:04:37.610
你可以直接拿过来用

01:04:37.610 --> 01:04:38.610
我们以前咋用的

01:04:38.610 --> 01:04:40.610
我们以前都是先把它

01:04:40.610 --> 01:04:42.610
先进入它的官网

01:04:42.610 --> 01:04:44.610
然后百度去收一下

01:04:44.610 --> 01:04:45.610
收一下它在哪里下载

01:04:45.610 --> 01:04:46.610
下载过后

01:04:46.610 --> 01:04:47.610
去看它的文档

01:04:47.610 --> 01:04:48.610
怎么去用

01:04:48.610 --> 01:04:49.610
对不对

01:04:49.610 --> 01:04:51.610
有了保管运气过后

01:04:51.610 --> 01:04:53.610
下载一些别人写好的节词

01:04:53.610 --> 01:04:55.610
更加的方便

01:04:55.610 --> 01:04:56.610
更加的方便

01:04:56.610 --> 01:04:58.610
那么怎么来用呢

01:04:58.610 --> 01:05:01.610
首先你要做的一件事情是

01:05:01.610 --> 01:05:04.610
因为NPM它有个官方网站

01:05:04.610 --> 01:05:07.610
叫做NPM节词角套

01:05:07.610 --> 01:05:08.610
这个东西不用发达

01:05:08.610 --> 01:05:10.610
就NPM就几个字母

01:05:10.610 --> 01:05:11.610
打一下就出来了

01:05:11.610 --> 01:05:12.610
NPM节词点抗

01:05:12.610 --> 01:05:15.610
这里边它就里边保存了

01:05:15.610 --> 01:05:19.610
所有的发布到NPM上面的包

01:05:19.610 --> 01:05:21.610
就是一些第三方模块

01:05:21.610 --> 01:05:22.610
发布到上面的

01:05:22.610 --> 01:05:23.610
它全部保存下来的

01:05:23.610 --> 01:05:24.610
在这里边很多很多

01:05:24.610 --> 01:05:26.610
比方说我们在这里可以收Jquery

01:05:26.610 --> 01:05:27.610
有的同学听过

01:05:27.610 --> 01:05:29.610
有的同学用过

01:05:29.610 --> 01:05:32.610
Jquery它也放到NPM上面的

01:05:32.610 --> 01:05:34.610
当然在漏的环境里边

01:05:34.610 --> 01:05:36.610
用Jquery就有点搞笑了

01:05:36.610 --> 01:05:38.610
因为Jquery是真正浏览器环境的

01:05:38.610 --> 01:05:40.610
那么这些东西都在NPM上面

01:05:40.610 --> 01:05:42.610
那么我们只需要使用一个

01:05:42.610 --> 01:05:43.610
简单的命令

01:05:43.610 --> 01:05:44.610
就可以安装

01:05:44.610 --> 01:05:46.610
把它下载下来安装

01:05:46.610 --> 01:05:48.610
并且可以非常方便的使用

01:05:48.610 --> 01:05:49.610
那么在你用之前的

01:05:49.610 --> 01:05:52.610
首先你要去运行一下这个命令

01:05:52.610 --> 01:05:56.840
运行一下这个命令

01:05:56.840 --> 01:05:57.840
这个命令要干嘛呢

01:05:57.840 --> 01:05:58.840
因为它里边的包

01:05:58.840 --> 01:06:00.840
全是放到国外的服务器上的

01:06:00.840 --> 01:06:01.840
你下载的时候

01:06:01.840 --> 01:06:03.840
会让你下载到怀疑人生

01:06:03.840 --> 01:06:06.840
最好你把它设置一下

01:06:06.840 --> 01:06:08.840
让NPM下载的时候

01:06:08.840 --> 01:06:12.840
不要从它官网的服务器去下载

01:06:12.840 --> 01:06:14.840
从国内的淘宝

01:06:14.840 --> 01:06:15.840
一个镜像园

01:06:15.840 --> 01:06:16.840
淘宝地址去下载

01:06:16.840 --> 01:06:17.840
淘宝地址呢

01:06:17.840 --> 01:06:18.840
这个地址呢

01:06:18.840 --> 01:06:20.840
它里边保存了NPM上面的

01:06:20.840 --> 01:06:21.840
所有的包

01:06:21.840 --> 01:06:23.840
而且不时的进行同步

01:06:23.840 --> 01:06:25.840
所以说在这里下载就非常快了

01:06:25.840 --> 01:06:27.840
所以说你先运行一下这个命令

01:06:27.840 --> 01:06:29.840
这个命令一辈子只需要运行一次

01:06:29.840 --> 01:06:30.840
运行一次过后

01:06:30.840 --> 01:06:31.840
之后就不用运行了

01:06:31.840 --> 01:06:33.840
我们后边下载就非常方便了

01:06:33.840 --> 01:06:34.840
那怎么来下载呢

01:06:34.840 --> 01:06:35.840
非常简单

01:06:35.840 --> 01:06:36.840
你首先要进入这个目录

01:06:36.840 --> 01:06:38.840
要说我们进入这个目录

01:06:38.840 --> 01:06:39.840
这是我们的目录

01:06:39.840 --> 01:06:41.840
接下来我们要做这么一件事

01:06:41.840 --> 01:06:42.840
首先运行一个命令

01:06:42.840 --> 01:06:44.840
叫做NPM INIT

01:06:45.840 --> 01:06:48.840
用这个NPM命令初始化我们工程

01:06:48.840 --> 01:06:49.840
一回车

01:06:49.840 --> 01:06:50.840
它会问你很多问题

01:06:50.840 --> 01:06:51.840
这些问题呢

01:06:51.840 --> 01:06:53.840
你自己根据需要去回答

01:06:53.840 --> 01:06:54.840
我一个都不想回答

01:06:54.840 --> 01:06:55.840
我全部保持默认

01:06:55.840 --> 01:06:56.840
第一个

01:06:56.840 --> 01:06:58.840
问你你的工程的名字

01:06:58.840 --> 01:06:59.840
它默认就是文件名字

01:06:59.840 --> 01:07:00.840
这个文件名字里边

01:07:00.840 --> 01:07:01.840
不能有中文

01:07:01.840 --> 01:07:02.840
不能有空格那些那些

01:07:02.840 --> 01:07:03.840
如果说有的话

01:07:03.840 --> 01:07:04.840
你就去边换一个

01:07:04.840 --> 01:07:06.840
然后问你的版本

01:07:06.840 --> 01:07:08.840
默认 全都默认

01:07:08.840 --> 01:07:09.840
也可以用什么呢

01:07:09.840 --> 01:07:10.840
用什么方式来

01:07:11.840 --> 01:07:12.840
把它删掉

01:07:12.840 --> 01:07:13.840
也可以用这种方式

01:07:13.840 --> 01:07:15.840
如果说你的目录没有问题的话

01:07:15.840 --> 01:07:16.840
目录里边没有中文

01:07:16.840 --> 01:07:17.840
没有空格那些那些

01:07:17.840 --> 01:07:18.840
那些乱七八糟的制服

01:07:18.840 --> 01:07:20.840
就是纯英文加短红线的话

01:07:20.840 --> 01:07:22.840
那么你可以用NPM INIT

01:07:22.840 --> 01:07:23.840
加上一个横杠Y

01:07:23.840 --> 01:07:25.840
所有的保持默认

01:07:25.840 --> 01:07:26.840
一回车

01:07:26.840 --> 01:07:27.840
它就可以生成了这个

01:07:27.840 --> 01:07:28.840
生成了一个文件

01:07:28.840 --> 01:07:29.840
它其实就是

01:07:29.840 --> 01:07:30.840
帮你生成一个文件

01:07:30.840 --> 01:07:32.840
这个文件你手动加也可以

01:07:32.840 --> 01:07:34.840
叫做Package.json

01:07:34.840 --> 01:07:35.840
这个文件里边

01:07:35.840 --> 01:07:36.840
提供了一些重要的信息

01:07:36.840 --> 01:07:37.840
这些信息

01:07:37.840 --> 01:07:39.840
我们一会再说

01:07:39.840 --> 01:07:40.840
我们接下来

01:07:40.840 --> 01:07:41.840
做好的这件事情过后

01:07:41.840 --> 01:07:44.840
那么你就可以安装

01:07:44.840 --> 01:07:47.840
你想要的一些第三方库了

01:07:47.840 --> 01:07:49.840
比方说我安装一个啥呢

01:07:49.840 --> 01:07:51.840
我安装一个楼单

01:07:51.840 --> 01:07:52.840
有没有学过

01:07:52.840 --> 01:07:53.840
没关系

01:07:53.840 --> 01:07:54.840
我们随便安装一些吧

01:07:54.840 --> 01:07:55.840
怎么安装呢

01:07:55.840 --> 01:07:57.840
安装的方式就是NPM

01:07:57.840 --> 01:07:59.840
加上一个参数I

01:07:59.840 --> 01:08:02.840
叫做Install安装

01:08:02.840 --> 01:08:04.840
后面写上你要安装的名字

01:08:04.840 --> 01:08:06.840
安装什么样的库的名字

01:08:06.840 --> 01:08:07.840
库的名字呢

01:08:08.840 --> 01:08:10.840
库的名字

01:08:10.840 --> 01:08:11.840
一回车

01:08:11.840 --> 01:08:15.600
它就安装了

01:08:15.600 --> 01:08:20.320
它真的安装

01:08:20.320 --> 01:08:21.320
安装好了

01:08:21.320 --> 01:08:23.320
安装好了之后

01:08:23.320 --> 01:08:24.320
我可以看到

01:08:24.320 --> 01:08:26.320
Node module 下面

01:08:26.320 --> 01:08:27.320
多了一个文件夹

01:08:27.320 --> 01:08:28.320
看到没

01:08:28.320 --> 01:08:30.320
多了一个文件夹

01:08:30.320 --> 01:08:31.320
这个文件夹哪来的

01:08:31.320 --> 01:08:33.320
这个文件夹就是安装的时候

01:08:33.320 --> 01:08:35.320
安装的时候

01:08:35.320 --> 01:08:37.320
它给我们带的楼单

01:08:37.320 --> 01:08:38.320
对吧

01:08:38.320 --> 01:08:39.320
这是它安装的东西

01:08:39.320 --> 01:08:40.320
它会自动的

01:08:40.320 --> 01:08:42.320
安装的东西下载到楼单

01:08:42.320 --> 01:08:44.320
而且还会生成一个Lock文件

01:08:44.320 --> 01:08:46.320
这个Lock文件是跟版本相关的

01:08:46.320 --> 01:08:48.320
因为这些第三方库都有版本

01:08:48.320 --> 01:08:50.320
它会在这里面锁定版本

01:08:50.320 --> 01:08:51.320
你不用管它

01:08:51.320 --> 01:08:52.320
也不要去删它

01:08:52.320 --> 01:08:53.320
安装好了

01:08:53.320 --> 01:08:54.320
安装好了过后

01:08:54.320 --> 01:08:56.320
那么这里面是不是就可以用了

01:08:56.320 --> 01:08:57.320
我们来看一下怎么来用

01:08:57.320 --> 01:08:58.320
比方说我们在index里面

01:08:58.320 --> 01:09:00.320
把它就注释掉

01:09:00.320 --> 01:09:02.320
前面都注释了

01:09:02.320 --> 01:09:03.320
接下来我们使用一下

01:09:03.320 --> 01:09:04.320
怎么来使用呢

01:09:04.320 --> 01:09:05.320
因为它就是用模块化的方式

01:09:05.320 --> 01:09:06.320
来书写的

01:09:06.320 --> 01:09:07.320
所以说你

01:09:08.320 --> 01:09:09.320
写上它

01:09:11.320 --> 01:09:12.320
就写上就完事了

01:09:12.320 --> 01:09:15.320
它就会把它的导出结果给你返回

01:09:15.320 --> 01:09:16.320
它导出结果是什么呢

01:09:16.320 --> 01:09:17.320
随便用个什么变量

01:09:17.320 --> 01:09:18.320
results

01:09:18.320 --> 01:09:20.320
随便用个什么变量来保存一下

01:09:20.320 --> 01:09:21.320
results 你看一下

01:09:21.320 --> 01:09:23.320
你就可以用它导出的结果了

01:09:27.320 --> 01:09:28.320
这里面是不是有很多

01:09:28.320 --> 01:09:29.320
对不对

01:09:29.320 --> 01:09:30.320
我们来用一下吧

01:09:30.320 --> 01:09:31.320
随便用一下吧

01:09:31.320 --> 01:09:32.320
这楼单写

01:09:32.320 --> 01:09:33.320
我们通常用一个变量

01:09:33.320 --> 01:09:34.320
叫做下滑线

01:09:34.320 --> 01:09:35.320
一般来说

01:09:35.320 --> 01:09:37.320
一般上用一个下滑线来保存

01:09:37.320 --> 01:09:38.320
作为楼单写

01:09:38.320 --> 01:09:39.320
这个库也挺有名的

01:09:39.320 --> 01:09:40.320
那么这里呢

01:09:40.320 --> 01:09:42.320
我们可以使用它里面一个函数叫创渴

01:09:42.320 --> 01:09:43.320
它是一个对象

01:09:43.320 --> 01:09:44.320
导出了一个对象

01:09:44.320 --> 01:09:45.320
对象里面一个函数叫创渴

01:09:45.320 --> 01:09:46.320
创渴有什么用呢

01:09:46.320 --> 01:09:47.320
比方说

01:09:47.320 --> 01:09:48.320
我们给它一个数组

01:09:48.320 --> 01:09:49.320
3

01:09:49.320 --> 01:09:50.320
12345

01:09:50.320 --> 01:09:51.320
6

01:09:51.320 --> 01:09:52.320
然后第二个参数给它一个2

01:09:52.320 --> 01:09:54.320
它会返回一个新的数组

01:09:54.320 --> 01:09:55.320
6

01:09:55.320 --> 01:09:56.320
保存一下吧

01:09:56.320 --> 01:09:57.320
输出

01:09:57.320 --> 01:09:58.320
看一下

01:09:58.320 --> 01:09:59.320
什么意思呢

01:09:59.320 --> 01:10:01.320
它就会把前面的数组分割成两个一组

01:10:01.320 --> 01:10:03.320
两个一组进行分割

01:10:03.320 --> 01:10:04.320
两个一组

01:10:04.320 --> 01:10:06.320
123456

01:10:06.320 --> 01:10:07.320
它会把它分割成这样子

01:10:07.320 --> 01:10:08.320
这个东西

01:10:08.320 --> 01:10:09.320
就是这么一个库

01:10:09.320 --> 01:10:11.320
主要是通过它来说明

01:10:11.320 --> 01:10:14.320
怎么来下载一个第三方库

01:10:14.320 --> 01:10:15.320
怎么来去使用它

01:10:15.320 --> 01:10:17.320
是不是非常简单啊

01:10:17.320 --> 01:10:18.320
跟我们过去相比

01:10:18.320 --> 01:10:20.320
我们是不是不用去进它的官方网站

01:10:20.320 --> 01:10:21.320
不用去下载什么戒业史

01:10:21.320 --> 01:10:22.320
一个命令就可以搞定了

01:10:22.320 --> 01:10:23.320
而且用的时候

01:10:23.320 --> 01:10:25.320
就是一个魔幻化的方式来使用

01:10:25.320 --> 01:10:26.320
没意思吧

01:10:27.320 --> 01:10:30.150
可以啊

01:10:30.150 --> 01:10:31.150
楼单写可以的

01:10:32.150 --> 01:10:33.150
那么接下来我们再来看

01:10:33.150 --> 01:10:34.150
当我们安装好了

01:10:34.150 --> 01:10:36.150
之后我们看一下拍几点节省

01:10:36.150 --> 01:10:37.150
这个文件

01:10:37.150 --> 01:10:39.150
这个文件里边有些地方出现了变动

01:10:39.150 --> 01:10:41.150
你看这里有个dependence

01:10:42.150 --> 01:10:43.150
什么意思呢

01:10:43.150 --> 01:10:45.150
表示的是依赖

01:10:45.150 --> 01:10:46.150
它说的意思就是说

01:10:46.150 --> 01:10:48.150
我们的工程里边

01:10:48.150 --> 01:10:50.150
依赖了楼单写

01:10:50.150 --> 01:10:52.150
就是我们工程里边要用到楼单写

01:10:52.150 --> 01:10:53.150
因为你安装了

01:10:53.150 --> 01:10:54.150
你安装不用了

01:10:54.150 --> 01:10:55.150
你安装它干嘛呢

01:10:55.150 --> 01:10:58.150
你们工程里边要用到楼单写

01:10:58.150 --> 01:10:59.150
它会记录下来

01:10:59.150 --> 01:11:01.150
那么记录这个玩意有什么用呢

01:11:01.150 --> 01:11:03.150
有什么用呢

01:11:04.150 --> 01:11:05.150
你看啊

01:11:05.150 --> 01:11:06.150
如果说今天我开发完了

01:11:06.150 --> 01:11:08.150
我要把代码发给你们

01:11:08.150 --> 01:11:09.150
如果说我把整个工程

01:11:09.150 --> 01:11:10.150
全部发给你们的话

01:11:10.150 --> 01:11:11.150
是不是要把这个东西

01:11:11.150 --> 01:11:12.150
也拷贝给你们

01:11:12.150 --> 01:11:13.150
你看一下这个

01:11:13.150 --> 01:11:15.150
这个东西里边有多少文件

01:11:16.150 --> 01:11:17.150
所以文件变得很大

01:11:18.150 --> 01:11:19.150
而且呢

01:11:19.150 --> 01:11:20.150
江南呢

01:11:20.150 --> 01:11:21.150
我去安装一些

01:11:21.150 --> 01:11:22.150
别的玩意的时候

01:11:22.150 --> 01:11:23.150
比方说我去安装什么

01:11:23.150 --> 01:11:24.150
安装viu

01:11:24.150 --> 01:11:25.150
你们以后要学习的

01:11:26.150 --> 01:11:27.150
NPMI

01:11:27.150 --> 01:11:28.150
viu

01:11:28.150 --> 01:11:30.150
你们以后一定要学习viu的

01:11:31.150 --> 01:11:32.150
你看一下

01:11:32.150 --> 01:11:33.150
说来这个多吓人

01:11:34.150 --> 01:11:35.150
展开看一下

01:11:35.150 --> 01:11:36.150
刷新

01:11:37.150 --> 01:11:39.150
viu倒是没有什么依赖

01:11:40.150 --> 01:11:41.150
viu倒是没有什么依赖

01:11:41.150 --> 01:11:42.150
我就安装那个吧

01:11:42.150 --> 01:11:44.150
我就安装viu cd

01:11:46.150 --> 01:11:47.150
没有什么依赖

01:11:47.150 --> 01:11:48.150
我来看一下吧

01:11:50.780 --> 01:11:51.780
前面都是一些警告

01:11:51.780 --> 01:11:53.780
有些过期了

01:11:53.780 --> 01:11:55.780
它里边它是它内部模块的问题

01:11:55.780 --> 01:11:59.690
不用管了

01:11:59.690 --> 01:12:00.690
停了

01:12:01.690 --> 01:12:05.540
就别停了

01:12:05.540 --> 01:12:07.540
这个东西安装到侯联

01:12:07.540 --> 01:12:08.540
安装太久了

01:12:08.540 --> 01:12:10.540
我再来再换一个安装

01:12:10.540 --> 01:12:12.540
再换成安装那个react

01:12:12.540 --> 01:12:14.540
就是vipack

01:12:14.540 --> 01:12:18.000
安装这个

01:12:18.000 --> 01:12:20.000
安装一个稍微没有那么快的

01:12:20.000 --> 01:12:22.000
这个东西里面也是要学习的

01:12:22.000 --> 01:12:24.000
这是一个很大的一个知识点

01:12:25.000 --> 01:12:26.000
安装吧

01:12:26.000 --> 01:12:29.400
我想说啥呢

01:12:29.400 --> 01:12:31.400
就是安装一个模块的时候

01:12:31.400 --> 01:12:32.400
你会发现

01:12:32.400 --> 01:12:33.400
这个模块本身

01:12:33.400 --> 01:12:34.400
它也有依赖

01:12:34.400 --> 01:12:36.400
不要说你安装一个A模块

01:12:36.400 --> 01:12:37.400
它可能要用到B模块

01:12:37.400 --> 01:12:38.400
B模块又要用到C模块

01:12:38.400 --> 01:12:40.400
结果导测这个ModeMarch

01:12:40.400 --> 01:12:41.400
就是里边

01:12:41.400 --> 01:12:42.400
它会下载很多

01:12:42.400 --> 01:12:45.400
它会把依赖的模块也会自动下载下来

01:12:45.400 --> 01:12:47.400
而且对你的依赖版本也会记录下来

01:12:47.400 --> 01:12:52.830
有那么夸张的安装

01:12:53.830 --> 01:12:54.830
过后来刷新看一下

01:12:54.830 --> 01:12:55.830
你看一下

01:12:55.830 --> 01:12:56.830
这里面有多少模块

01:12:56.830 --> 01:12:57.830
你看一下吧

01:12:59.830 --> 01:13:01.830
这些东西这么多模块

01:13:01.830 --> 01:13:02.830
而这个文件价有多大呢

01:13:02.830 --> 01:13:03.830
我给大家看一下

01:13:03.830 --> 01:13:04.830
这个文件价有多大

01:13:04.830 --> 01:13:06.830
U件属性

01:13:07.830 --> 01:13:08.830
有20多兆

01:13:08.830 --> 01:13:10.830
而且你们以后在真实的开发里面

01:13:10.830 --> 01:13:12.830
这个文件价有几百兆

01:13:12.830 --> 01:13:13.830
上级

01:13:13.830 --> 01:13:14.830
一点都不奇怪的

01:13:14.830 --> 01:13:16.830
因为这有异代的模块泰国了

01:13:16.830 --> 01:13:17.830
你看我们现在工程里边

01:13:17.830 --> 01:13:18.830
异代什么

01:13:18.830 --> 01:13:19.830
异代NodeMarch

01:13:19.830 --> 01:13:20.830
异代VU

01:13:20.830 --> 01:13:21.830
异代React

01:13:21.830 --> 01:13:22.830
异代Wipack

01:13:22.830 --> 01:13:23.830
对吧

01:13:23.830 --> 01:13:24.830
直接异代是它

01:13:24.830 --> 01:13:25.830
但它们里边说也有异代

01:13:25.830 --> 01:13:27.830
它们的异代也会被自动下载下来

01:13:27.830 --> 01:13:28.830
知道这个意思吗

01:13:28.830 --> 01:13:29.830
所以说我们到时候

01:13:29.830 --> 01:13:31.830
我在给你们发代码的时候

01:13:31.830 --> 01:13:32.830
比方说你们以后在公司里边

01:13:32.830 --> 01:13:34.830
要把代码讨备走

01:13:34.830 --> 01:13:36.830
你是不可能把这个文件价考走的

01:13:36.830 --> 01:13:37.830
你会干嘛呢

01:13:37.830 --> 01:13:38.830
比方说你考备的时候

01:13:38.830 --> 01:13:40.830
你只会把别的文件价考走

01:13:40.830 --> 01:13:41.830
比方说我把这里删掉

01:13:41.830 --> 01:13:44.460
删掉

01:13:45.460 --> 01:13:46.460
你看

01:13:46.460 --> 01:13:48.460
你只会考备别的文件

01:13:48.460 --> 01:13:49.460
别的文件是你自己写的

01:13:49.460 --> 01:13:50.460
比较简单

01:13:50.460 --> 01:13:52.460
但是你只要把这个文件带上

01:13:52.460 --> 01:13:54.460
这里边是不是记录了异代关系

01:13:54.460 --> 01:13:56.460
而且它的版本号是不是记录下来了

01:13:56.460 --> 01:13:58.460
记录了异代关系过后

01:13:58.460 --> 01:13:59.460
到了另一台电脑

01:13:59.460 --> 01:14:00.460
它是不是可以轻松地还原

01:14:00.460 --> 01:14:01.460
怎么还原

01:14:01.460 --> 01:14:03.460
还原的方式非常简单

01:14:03.460 --> 01:14:05.460
NPMI

01:14:05.460 --> 01:14:06.460
不要给后边写任何东西

01:14:06.460 --> 01:14:08.460
一回车它就还原了

01:14:08.460 --> 01:14:10.460
这个命令它就会按照你

01:14:10.460 --> 01:14:12.460
之前在package.get里边记录的异代

01:14:12.460 --> 01:14:14.460
我的工程中记录了有这些异代

01:14:14.460 --> 01:14:15.460
对吧

01:14:15.460 --> 01:14:16.460
那我就按照这个异代

01:14:16.460 --> 01:14:17.460
把它重新还原

01:14:17.460 --> 01:14:18.460
重新下载一次

01:14:18.460 --> 01:14:20.460
我就不用去考备了

01:14:20.460 --> 01:14:26.370
懂这个意思吧

01:14:26.370 --> 01:14:27.370
懂这个意思吧

01:14:27.370 --> 01:14:28.370
非常简单

01:14:28.370 --> 01:14:29.370
那就还原了

01:14:29.370 --> 01:14:30.370
就还原了

01:14:30.370 --> 01:14:32.370
你看这个代码就可以运行

01:14:32.370 --> 01:14:33.370
对吧

01:14:33.370 --> 01:14:34.370
所以我们的代码

01:14:34.370 --> 01:14:35.370
要运行的时候

01:14:35.370 --> 01:14:36.370
肯定要用到这个目录

01:14:36.370 --> 01:14:37.370
但是我们考备的时候

01:14:37.370 --> 01:14:38.370
不用考备这个目录

01:14:38.370 --> 01:14:39.370
因为考备过后

01:14:39.370 --> 01:14:40.370
我们只需要通过这个命令

01:14:40.370 --> 01:14:42.370
就可以把还原

01:14:42.370 --> 01:14:44.370
它的版本那些东西都是一样的

01:14:44.370 --> 01:14:46.370
这是关于这个

01:14:46.370 --> 01:14:48.370
npm区下载一个包

01:14:48.370 --> 01:14:50.370
这里边还有些命令

01:14:50.370 --> 01:14:51.370
比方说什么呢

01:14:51.370 --> 01:14:53.370
加上一个横杠地

01:14:53.370 --> 01:14:54.370
加上横杠地是什么意思呢

01:14:54.370 --> 01:14:55.370
大写的地

01:14:55.370 --> 01:14:56.370
表示开发意耐

01:14:56.370 --> 01:14:57.370
啥意思呢

01:14:57.370 --> 01:14:58.370
比方比方说

01:14:58.370 --> 01:15:00.370
就目前的现实演的例子

01:15:00.370 --> 01:15:02.370
你看我们的写代码是没有提示的

01:15:02.370 --> 01:15:04.370
require

01:15:04.370 --> 01:15:06.370
这个require

01:15:06.370 --> 01:15:07.370
现在倒是提示的

01:15:07.370 --> 01:15:08.370
因为它有第三方模块里面

01:15:08.370 --> 01:15:10.370
按了一个require

01:15:10.370 --> 01:15:12.370
按了那个相应的包了

01:15:12.370 --> 01:15:14.370
我们把它删掉吧

01:15:14.370 --> 01:15:15.370
好 删掉过后

01:15:15.370 --> 01:15:17.370
你看我们写个require

01:15:17.370 --> 01:15:19.370
关掉 关掉重新来

01:15:19.370 --> 01:15:25.880
它现在又出来了这个提示

01:15:25.880 --> 01:15:27.880
这个vscode它是这样子

01:15:27.880 --> 01:15:28.880
如果说你

01:15:28.880 --> 01:15:30.880
我这个重新打开一次

01:15:30.880 --> 01:15:32.880
重新打开一次

01:15:32.880 --> 01:15:34.880
把这个文件打开

01:15:34.880 --> 01:15:36.880
这个vscode它有的时候

01:15:36.880 --> 01:15:42.950
它出不来这个智能提示

01:15:42.950 --> 01:15:43.950
重新打开一次

01:15:43.950 --> 01:15:44.950
试一下

01:15:44.950 --> 01:15:45.950
因为我们刚才按到

01:15:45.950 --> 01:15:46.950
第三方库的时候

01:15:46.950 --> 01:15:47.950
它已经把它

01:15:47.950 --> 01:15:51.450
把那个漏掉的环境夹在进来了

01:15:51.450 --> 01:15:53.450
你看 现在是不是没有提示

01:15:53.450 --> 01:15:54.450
require这个东西

01:15:54.450 --> 01:15:55.450
它不是

01:15:55.450 --> 01:15:56.450
它这个东西不叫提示

01:15:56.450 --> 01:15:57.450
之前我们写过这个东西

01:15:57.450 --> 01:15:58.450
它才会出来的

01:15:58.450 --> 01:16:00.450
如果说你没有写过的话

01:16:00.450 --> 01:16:01.450
没有写过的话

01:16:01.450 --> 01:16:02.450
你看是没有智能提示的

01:16:02.450 --> 01:16:03.450
那么如果说

01:16:03.450 --> 01:16:05.450
你要在vscode的环境里面

01:16:05.450 --> 01:16:06.450
产生一些对漏的智能提示

01:16:06.450 --> 01:16:07.450
你怎么办呢

01:16:07.450 --> 01:16:09.450
你可以安装一个第三方库

01:16:09.450 --> 01:16:11.450
叫做npmi

01:16:11.450 --> 01:16:13.450
叫什么呢

01:16:13.450 --> 01:16:14.450
taps

01:16:14.450 --> 01:16:15.450
写个漏的

01:16:15.450 --> 01:16:17.450
安装一下这个库

01:16:17.450 --> 01:16:18.450
有了这个库

01:16:18.450 --> 01:16:19.450
过后在vscode里面

01:16:19.450 --> 01:16:20.450
就可以智能提示了

01:16:28.400 --> 01:16:30.400
今天晚上的网好像有点慢了

01:16:30.400 --> 01:16:34.090
应该是在直播的原因吧

01:16:34.090 --> 01:16:38.430
安装过后就是智能提示的

01:16:38.430 --> 01:16:40.430
但是大家想一想这个问题

01:16:40.430 --> 01:16:42.430
就是说这个网

01:16:42.430 --> 01:16:43.430
跟我们开发

01:16:43.430 --> 01:16:45.430
跟我们代码运行有没有关系

01:16:45.430 --> 01:16:46.430
没有什么关系

01:16:46.430 --> 01:16:48.430
它只是在开发阶段

01:16:48.430 --> 01:16:50.430
让我们开发更加舒服而已

01:16:50.430 --> 01:16:51.430
那我们写代码

01:16:51.430 --> 01:16:52.430
更加舒服有智能提示而已

01:16:52.430 --> 01:16:54.430
它跟我们的代码

01:16:54.430 --> 01:16:55.430
怎么去运行

01:16:55.430 --> 01:16:56.430
没有任何关系

01:16:56.430 --> 01:16:57.430
你看现在就智能提示了

01:16:57.430 --> 01:16:59.430
require

01:16:59.430 --> 01:17:00.430
你看是不是有智能提示的

01:17:01.430 --> 01:17:03.430
它跟我们的运行

01:17:03.430 --> 01:17:04.430
是没有任何关系的

01:17:04.430 --> 01:17:06.430
只是让我们写代码舒服一点

01:17:07.430 --> 01:17:08.430
那么这个依赖

01:17:08.430 --> 01:17:09.430
它就是不是跟我们

01:17:09.430 --> 01:17:10.430
之前的依赖就有区别

01:17:10.430 --> 01:17:11.430
像这个伍佑依赖

01:17:11.430 --> 01:17:13.430
楼大喜依赖是不是就有区别

01:17:13.430 --> 01:17:14.430
这些东西都是要参与运行的

01:17:14.430 --> 01:17:16.430
而这个网是不需要参与运行的

01:17:16.430 --> 01:17:17.430
那怎么办呢

01:17:17.430 --> 01:17:18.430
我们通常情况下

01:17:18.430 --> 01:17:20.430
是要希望把这个依赖

01:17:20.430 --> 01:17:22.430
变成一个开发依赖

01:17:22.430 --> 01:17:23.430
把起到这

01:17:24.430 --> 01:17:25.430
就是这个代码

01:17:25.430 --> 01:17:26.430
这个东西

01:17:26.430 --> 01:17:28.430
它只是在我们开发阶段

01:17:28.430 --> 01:17:29.430
有帮助

01:17:29.430 --> 01:17:31.430
在运行的时候就没有帮助了

01:17:31.430 --> 01:17:33.430
它根本不参与运行的

01:17:33.430 --> 01:17:35.430
这个东西实际上是

01:17:35.430 --> 01:17:37.430
我们后边的另外一个课程

01:17:37.430 --> 01:17:38.430
叫type script

01:17:38.430 --> 01:17:40.430
里边讲的东西

01:17:40.430 --> 01:17:41.430
那么我们就可以

01:17:41.430 --> 01:17:42.430
依赖有两种

01:17:42.430 --> 01:17:43.430
一种是普通依赖

01:17:43.430 --> 01:17:45.430
就是我们要参与运行的

01:17:45.430 --> 01:17:46.430
一种就是跟最终运行

01:17:46.430 --> 01:17:47.430
没有什么关系的

01:17:47.430 --> 01:17:49.430
只是在开发阶段使用的

01:17:49.430 --> 01:17:50.430
叫开发依赖

01:17:50.430 --> 01:17:51.430
没了意思吧

01:17:51.430 --> 01:17:52.430
如果说

01:17:52.430 --> 01:17:53.430
你要安装一个开发依赖的话

01:17:53.430 --> 01:17:55.430
你可以使用这种方式

01:17:55.430 --> 01:17:57.430
我把这里全部删的

01:17:57.430 --> 01:17:59.430
咱们过后来我们用NPMI

01:17:59.430 --> 01:18:00.430
横杠地加个参数

01:18:00.430 --> 01:18:02.430
表示Development

01:18:02.430 --> 01:18:03.430
开发的

01:18:03.430 --> 01:18:04.430
开发的依赖

01:18:04.430 --> 01:18:05.430
后面写上

01:18:05.430 --> 01:18:06.430
酷的名字

01:18:06.430 --> 01:18:07.430
包的名字

01:18:07.430 --> 01:18:11.190
把你这样去安装

01:18:11.190 --> 01:18:12.190
那我们

01:18:12.190 --> 01:18:13.190
难得等了

01:18:13.190 --> 01:18:17.910
完了过后

01:18:17.910 --> 01:18:18.910
我是把这个

01:18:18.910 --> 01:18:19.910
把这个删一下

01:18:19.910 --> 01:18:20.910
这个删一下

01:18:20.910 --> 01:18:24.050
出来

01:18:24.050 --> 01:18:26.050
你说你不应该手动去控制这个玩意

01:18:26.050 --> 01:18:28.050
不应该去手动去改它

01:18:28.050 --> 01:18:29.050
我刚才手动改了

01:18:29.050 --> 01:18:31.050
所以我把那个Lock文件删一下

01:18:31.050 --> 01:18:32.050
好

01:18:32.050 --> 01:18:33.050
完了

01:18:33.050 --> 01:18:34.050
过后了你看

01:18:34.050 --> 01:18:36.050
这里是不是记录到开发依赖去的

01:18:36.050 --> 01:18:37.050
它自动会记录到开发依赖

01:18:37.050 --> 01:18:39.050
这个文件一般不要去手动去改它

01:18:39.050 --> 01:18:41.050
这是关于依赖和开发依赖

01:18:41.050 --> 01:18:43.050
我们后边的哪些东西

01:18:43.050 --> 01:18:45.050
至于具体哪些东西我用开发依赖

01:18:45.050 --> 01:18:47.050
哪些东西我用依赖的关系呢

01:18:47.050 --> 01:18:49.050
我们学到每一个酷的时候

01:18:49.050 --> 01:18:50.050
再具体的说

01:18:50.050 --> 01:18:51.050
这是关于NPMI

01:18:51.050 --> 01:18:52.050
好

01:18:52.050 --> 01:18:53.050
最后

01:18:53.050 --> 01:18:55.050
最后几分钟的时间

01:18:55.050 --> 01:18:58.840
217

01:18:58.840 --> 01:19:00.840
217是拿回大声

01:19:02.840 --> 01:19:03.840
最后我们说一下

01:19:03.840 --> 01:19:04.840
内置模块

01:19:04.840 --> 01:19:05.840
你们刚才我们说了

01:19:05.840 --> 01:19:07.840
这Node接式安装好了过后

01:19:07.840 --> 01:19:09.840
它会自带有一些模块

01:19:09.840 --> 01:19:10.840
自带有一些模块

01:19:10.840 --> 01:19:11.840
我们怎么来用呢

01:19:11.840 --> 01:19:12.840
就是直接使用它的模块名

01:19:12.840 --> 01:19:13.840
不需要安装

01:19:13.840 --> 01:19:14.840
它已经安装好了

01:19:14.840 --> 01:19:15.840
有两个内置模块

01:19:15.840 --> 01:19:16.840
一个是PASS

01:19:16.840 --> 01:19:17.840
我们说一下

01:19:17.840 --> 01:19:18.840
这是我们后边都要用的

01:19:18.840 --> 01:19:21.980
PASS模块

01:19:21.980 --> 01:19:23.980
我们来得到

01:19:23.980 --> 01:19:24.980
PASS

01:19:24.980 --> 01:19:25.980
它内置模块

01:19:25.980 --> 01:19:26.980
内置模块里边

01:19:26.980 --> 01:19:27.980
它是一个对象

01:19:27.980 --> 01:19:29.980
对象里边有很多的方法

01:19:29.980 --> 01:19:30.980
我们只需要用到

01:19:30.980 --> 01:19:31.980
它其中一个方法

01:19:31.980 --> 01:19:34.980
叫做result

01:19:34.980 --> 01:19:35.980
这个方法

01:19:35.980 --> 01:19:36.980
这个方法有什么用呢

01:19:36.980 --> 01:19:38.980
它可以把多个路径

01:19:38.980 --> 01:19:41.980
拼接成一个绝对路径

01:19:41.980 --> 01:19:42.980
它可以把多个路径

01:19:42.980 --> 01:19:43.980
拼接成一个绝对路径

01:19:43.980 --> 01:19:44.980
啥意思呢

01:19:44.980 --> 01:19:45.980
比方说

01:19:45.980 --> 01:19:46.980
我们在这里

01:19:46.980 --> 01:19:47.980
写上一个

01:19:47.980 --> 01:19:48.980
第二鞋杠

01:19:48.980 --> 01:19:49.980
SUB

01:19:49.980 --> 01:19:50.980
然后呢

01:19:50.980 --> 01:19:52.980
第二个再写上一个

01:19:52.980 --> 01:19:54.980
写上一个A

01:19:54.980 --> 01:19:55.980
A点解释

01:19:55.980 --> 01:19:56.980
你看一下吧

01:19:56.980 --> 01:19:57.980
它会把这个东西

01:19:57.980 --> 01:19:59.980
拼接成一个绝对路径

01:19:59.980 --> 01:20:00.980
返回一个什么

01:20:00.980 --> 01:20:01.980
返回一个字母串

01:20:01.980 --> 01:20:02.980
result

01:20:02.980 --> 01:20:03.980
输出

01:20:03.980 --> 01:20:04.980
这是我们后边

01:20:04.980 --> 01:20:05.980
可能会用的

01:20:05.980 --> 01:20:06.980
我们今天晚上就讲

01:20:06.980 --> 01:20:07.980
两个内置模块

01:20:07.980 --> 01:20:12.380
index

01:20:12.380 --> 01:20:13.380
你看得到的是什么

01:20:13.380 --> 01:20:14.380
是不是一个绝对路径

01:20:14.380 --> 01:20:16.380
SUB.A

01:20:16.380 --> 01:20:17.380
SUB.A点解释

01:20:17.380 --> 01:20:18.380
SUB下面的A点解释

01:20:18.380 --> 01:20:20.380
是不是一个绝对路径

01:20:20.380 --> 01:20:21.380
就出来了

01:20:21.380 --> 01:20:23.380
它是可以把一片段

01:20:23.380 --> 01:20:25.380
拼接成一个绝对路径

01:20:25.380 --> 01:20:26.380
那么注意

01:20:26.380 --> 01:20:27.380
周里边有个底耳鞋杠

01:20:27.380 --> 01:20:29.380
它的含义不一样

01:20:29.380 --> 01:20:30.380
它的含义不一样

01:20:30.380 --> 01:20:31.380
它的含义不是说

01:20:31.380 --> 01:20:33.380
从当前这个index

01:20:33.380 --> 01:20:34.380
的解释出发

01:20:34.380 --> 01:20:36.380
它是从什么出发呢

01:20:36.380 --> 01:20:37.380
也就是说

01:20:37.380 --> 01:20:38.380
这个东西跟周里边的

01:20:38.380 --> 01:20:39.380
点解杠不一样的

01:20:39.380 --> 01:20:41.380
这个地方是从什么出发

01:20:41.380 --> 01:20:42.380
就除了这个require寒树之外

01:20:42.380 --> 01:20:43.380
其他的所有寒树

01:20:43.380 --> 01:20:44.380
它的底耳鞋杠

01:20:44.380 --> 01:20:45.380
含义是什么呢

01:20:45.380 --> 01:20:46.380
含义是活动目录

01:20:46.380 --> 01:20:47.380
是这个目录

01:20:47.380 --> 01:20:49.380
从这个目录出发

01:20:49.380 --> 01:20:52.380
比方说

01:20:52.380 --> 01:20:53.380
我在周里运行

01:20:53.380 --> 01:20:54.380
load

01:20:54.380 --> 01:20:56.380
my first

01:20:56.380 --> 01:20:57.380
first load

01:20:57.380 --> 01:20:58.380
下面的什么

01:20:58.380 --> 01:21:00.380
index解释

01:21:00.380 --> 01:21:02.380
你看我运行这个路径

01:21:02.380 --> 01:21:03.380
我在这个

01:21:03.380 --> 01:21:04.380
第一天这个目录下面

01:21:04.380 --> 01:21:05.380
去运行load的

01:21:05.380 --> 01:21:06.380
运行什么呢

01:21:06.380 --> 01:21:07.380
运行这个目录下面的

01:21:07.380 --> 01:21:08.380
index解释

01:21:08.380 --> 01:21:09.380
对吧

01:21:09.380 --> 01:21:10.380
我们可以用这种方式来运行

01:21:10.380 --> 01:21:11.380
你看一下

01:21:11.380 --> 01:21:12.380
它得到路径

01:21:12.380 --> 01:21:14.380
跟刚才就不一样了

01:21:14.380 --> 01:21:15.380
怎么样

01:21:15.380 --> 01:21:16.380
跟刚才不一样了

01:21:16.380 --> 01:21:18.380
因为它找路径的时候

01:21:18.380 --> 01:21:20.380
如果说看到这个底耳鞋杠

01:21:20.380 --> 01:21:21.380
它是以当前

01:21:21.380 --> 01:21:23.380
活动目录出发

01:21:23.380 --> 01:21:24.380
以这个目录出发

01:21:24.380 --> 01:21:25.380
这个地方搞清楚

01:21:25.380 --> 01:21:26.380
这个地方

01:21:26.380 --> 01:21:27.380
因为我为什么要说呢

01:21:27.380 --> 01:21:28.380
要特别强调呢

01:21:28.380 --> 01:21:29.380
平时我们开发

01:21:29.380 --> 01:21:30.380
好像没有什么问题

01:21:30.380 --> 01:21:31.380
主要是有面试底

01:21:31.380 --> 01:21:32.380
主要是面试底

01:21:33.380 --> 01:21:34.380
好

01:21:34.380 --> 01:21:35.380
这个地方我说一下

01:21:35.380 --> 01:21:36.380
想到没了

01:21:36.380 --> 01:21:37.380
这是pys

01:21:37.380 --> 01:21:38.380
pys我们经常会怎么用呢

01:21:38.380 --> 01:21:40.380
经常会这样子用

01:21:40.380 --> 01:21:42.380
比方说我要找这个A点解释

01:21:42.380 --> 01:21:43.380
我会怎么来写呢

01:21:43.380 --> 01:21:44.380
我会这样子写

01:21:44.380 --> 01:21:46.380
我前边会加上一个

01:21:46.380 --> 01:21:48.380
DIR内

01:21:48.380 --> 01:21:50.380
啥意思

01:21:50.380 --> 01:21:51.380
表示当前模块

01:21:51.380 --> 01:21:52.380
就是index解释

01:21:52.380 --> 01:21:53.380
这个模块所在的目录

01:21:53.380 --> 01:21:54.380
对吧

01:21:54.380 --> 01:21:55.380
我们之前说了

01:21:55.380 --> 01:21:56.380
模块的话里面有个DIR内

01:21:56.380 --> 01:21:58.380
当前模块所在的目录

01:21:58.380 --> 01:22:00.380
就index解释所在的目录

01:22:00.380 --> 01:22:01.380
然后从这个目录出发

01:22:01.380 --> 01:22:02.380
去找什么呢

01:22:02.380 --> 01:22:04.380
找薩德文件夹

01:22:04.380 --> 01:22:05.380
下面的A点解释

01:22:05.380 --> 01:22:07.380
一般会这样子写

01:22:07.380 --> 01:22:09.380
这样子写的过去没问题

01:22:09.380 --> 01:22:10.380
在这里写解释

01:22:10.380 --> 01:22:11.380
解释钢就没问题了

01:22:11.380 --> 01:22:12.380
因为这里写解释钢

01:22:12.380 --> 01:22:13.380
不是第一个解释钢了

01:22:13.380 --> 01:22:15.380
它是以这个地方为出发点

01:22:15.380 --> 01:22:16.380
那你不写也可以

01:22:16.380 --> 01:22:17.380
好

01:22:17.380 --> 01:22:18.380
我们这里运行

01:22:19.380 --> 01:22:20.380
你看

01:22:20.380 --> 01:22:21.380
找到A点解释的

01:22:21.380 --> 01:22:22.380
对吧

01:22:22.380 --> 01:22:23.380
也找到了

01:22:23.380 --> 01:22:24.380
这样子

01:22:24.380 --> 01:22:25.380
这要好处在什么呢

01:22:25.380 --> 01:22:28.380
在于你在任何目录区运行

01:22:28.380 --> 01:22:30.380
first

01:22:30.380 --> 01:22:31.380
你在任何目录区运行

01:22:31.380 --> 01:22:33.380
都得到是一样的结果

01:22:33.380 --> 01:22:35.380
所以一样的结果

01:22:35.380 --> 01:22:36.380
对吧

01:22:36.380 --> 01:22:38.380
我们一般会用这种方式在运行

01:22:38.380 --> 01:22:39.380
来得到一个

01:22:39.380 --> 01:22:41.380
某一个模块的决定路径

01:22:41.380 --> 01:22:42.380
好

01:22:42.380 --> 01:22:43.380
这是这个

01:22:43.380 --> 01:22:44.380
另外一个我再说一下

01:22:44.380 --> 01:22:46.380
另外一个就是内置模块

01:22:46.380 --> 01:22:47.380
叫FS

01:22:47.380 --> 01:22:48.380
内置模块

01:22:48.380 --> 01:22:49.380
来吧

01:22:49.380 --> 01:22:51.380
我们用requiredFS

01:22:53.380 --> 01:22:55.380
这个玩意是读取文件内容的

01:22:55.380 --> 01:22:56.380
读取文件内容

01:22:56.380 --> 01:22:57.380
比方说我这里有个文件

01:22:57.380 --> 01:22:59.380
这里边写上一个

01:22:59.380 --> 01:23:01.380
test.txt

01:23:01.380 --> 01:23:03.380
一个文本文件

01:23:03.380 --> 01:23:05.380
这是一本书比方说

01:23:07.380 --> 01:23:08.380
登革是个好人

01:23:08.380 --> 01:23:11.010
表有这个文件

01:23:11.010 --> 01:23:13.010
我要把这个文件内容读出来

01:23:13.010 --> 01:23:14.010
那怎么来读呢

01:23:14.010 --> 01:23:15.010
就可以使用这个FS模块

01:23:15.010 --> 01:23:16.010
在浏览器环境里边

01:23:16.010 --> 01:23:17.010
是不是做不到的

01:23:17.010 --> 01:23:18.010
在loader环境里边就可以

01:23:18.010 --> 01:23:20.010
FS里边有个函数叫做

01:23:20.010 --> 01:23:21.010
readfile

01:23:22.010 --> 01:23:23.010
第一个参数写上路径

01:23:23.010 --> 01:23:25.010
你要从哪里去读

01:23:25.010 --> 01:23:26.010
一般来说

01:23:26.010 --> 01:23:28.010
我们这里是要写绝对路径的

01:23:28.010 --> 01:23:29.010
那我怎么来写绝对路径的

01:23:29.010 --> 01:23:30.010
我们是不是可以

01:23:30.010 --> 01:23:31.010
用刚才我们的模块

01:23:31.010 --> 01:23:32.010
requiredFS

01:23:33.010 --> 01:23:34.010
刚才我们有写过一个模块的

01:23:34.010 --> 01:23:35.010
pys对吧

01:23:35.010 --> 01:23:36.010
pys不是一个东西

01:23:36.010 --> 01:23:37.010
叫做绝对路径吗

01:23:37.010 --> 01:23:39.010
得到绝对路径吗

01:23:39.010 --> 01:23:40.010
result

01:23:40.010 --> 01:23:42.010
从当前目录出发

01:23:42.010 --> 01:23:43.010
找什么呢

01:23:43.010 --> 01:23:46.010
找这个test.txt

01:23:46.010 --> 01:23:47.010
对不对

01:23:50.010 --> 01:23:53.010
这是ABS file name

01:23:53.010 --> 01:23:55.010
得到文件的路径

01:23:55.010 --> 01:23:56.010
我们来看一下

01:23:56.010 --> 01:23:57.010
输出

01:23:58.010 --> 01:24:00.010
我们把这个输出掉

01:24:00.010 --> 01:24:02.520
运行

01:24:02.520 --> 01:24:03.520
看一下

01:24:03.520 --> 01:24:04.520
是不是找到文件路径了

01:24:04.520 --> 01:24:05.520
对不对

01:24:05.520 --> 01:24:08.520
然后把文件路径制服串

01:24:08.520 --> 01:24:11.520
再传递给

01:24:11.520 --> 01:24:12.520
readfile

01:24:12.520 --> 01:24:13.520
把文件路径传过去

01:24:13.520 --> 01:24:14.520
file name

01:24:14.520 --> 01:24:16.520
然后第二参数是一个回调函数

01:24:16.520 --> 01:24:18.520
它会把回调函数的

01:24:18.520 --> 01:24:19.520
第一个参数表示错误

01:24:19.520 --> 01:24:21.520
读文件有没有错误

01:24:21.520 --> 01:24:22.520
为什么要回调函数的模式

01:24:22.520 --> 01:24:24.520
为什么不用返回值呢

01:24:24.520 --> 01:24:25.520
因为读文件

01:24:25.520 --> 01:24:26.520
它是需要一个过程的

01:24:26.520 --> 01:24:28.520
它不是瞬间就读出来

01:24:28.520 --> 01:24:29.520
它是要跟磁盘打交道

01:24:29.520 --> 01:24:30.520
因为我们知道

01:24:30.520 --> 01:24:32.520
内存的运行速度很快

01:24:32.520 --> 01:24:33.520
但是呢

01:24:33.520 --> 01:24:34.520
硬盘的运行速度就很慢了

01:24:34.520 --> 01:24:35.520
所以说

01:24:35.520 --> 01:24:37.520
它等硬盘把数据给我

01:24:37.520 --> 01:24:39.520
所以说它等要等一会

01:24:39.520 --> 01:24:40.520
那么这里第一个参数就是

01:24:40.520 --> 01:24:41.520
有没有错误

01:24:41.520 --> 01:24:42.520
比如文件不存在

01:24:42.520 --> 01:24:44.520
那些就是有错误对吧

01:24:44.520 --> 01:24:45.520
如果说没有错误的话

01:24:45.520 --> 01:24:46.520
它就是闹

01:24:46.520 --> 01:24:48.520
第二个参数就是文件内容

01:24:48.520 --> 01:24:49.520
文件内容

01:24:49.520 --> 01:24:50.520
我们输出这个文件内容

01:24:50.520 --> 01:24:53.020
你看一下

01:24:53.020 --> 01:24:54.020
运行

01:24:55.020 --> 01:24:56.020
诶

01:24:57.020 --> 01:24:58.020
得到了试试吗

01:24:58.020 --> 01:24:59.020
undefined

01:25:00.020 --> 01:25:02.020
再来一次

01:25:03.020 --> 01:25:05.020
文件名写错了

01:25:05.020 --> 01:25:06.020
文件名写错了

01:25:08.020 --> 01:25:09.020
文件名写错了

01:25:09.020 --> 01:25:11.650
那么

01:25:11.650 --> 01:25:12.650
刚才那种情况

01:25:12.650 --> 01:25:13.650
Error是应该有指的

01:25:13.650 --> 01:25:14.650
Error是应该有指的

01:25:14.650 --> 01:25:15.650
表示有错误

01:25:15.650 --> 01:25:16.650
你看

01:25:16.650 --> 01:25:17.650
是不是有错误

01:25:17.650 --> 01:25:18.650
no such file

01:25:18.650 --> 01:25:19.650
or directory

01:25:19.650 --> 01:25:20.650
表示这个文件是不存在的

01:25:21.650 --> 01:25:22.650
我们再翻一下

01:25:22.650 --> 01:25:23.650
文件名

01:25:23.650 --> 01:25:24.650
刚才写错了

01:25:25.650 --> 01:25:28.220
再来运行

01:25:29.220 --> 01:25:30.220
你看

01:25:30.220 --> 01:25:31.220
这个东西看不懂对吧

01:25:31.220 --> 01:25:32.220
看不懂

01:25:32.220 --> 01:25:33.220
那么很简单

01:25:33.220 --> 01:25:34.220
它是一个buffer

01:25:34.220 --> 01:25:35.220
它是一个二进字格式

01:25:35.220 --> 01:25:36.220
那么我们非常简单

01:25:36.220 --> 01:25:37.220
在这个地方写上第二个参数

01:25:37.220 --> 01:25:39.220
表示文件的编码

01:25:39.220 --> 01:25:40.220
我们写上一个utf-8

01:25:41.220 --> 01:25:44.220
表示我们的文件是utf-8编码

01:25:44.220 --> 01:25:46.220
那你就不要给我二进字格式了

01:25:46.220 --> 01:25:47.220
你直接把这个二进字

01:25:47.220 --> 01:25:48.220
用utf-8编码的编码

01:25:48.220 --> 01:25:49.220
转换成字不串

01:25:49.220 --> 01:25:50.220
就这么个意思

01:25:50.220 --> 01:25:52.220
我们再来一双扣的

01:25:52.220 --> 01:25:53.220
是吧

01:25:53.220 --> 01:25:54.220
登个是个好的

01:25:54.220 --> 01:25:55.220
读出来了

01:25:55.220 --> 01:25:56.220
读的环境里面是可以读文件的

01:25:56.220 --> 01:25:58.220
正是因为读的环境里边

01:25:58.220 --> 01:25:59.220
可以读文件

01:26:00.220 --> 01:26:02.220
才有了webpack

01:26:02.220 --> 01:26:04.220
才有了

01:26:04.220 --> 01:26:05.220
雕塑架

01:26:05.220 --> 01:26:06.220
什么rex叫雕塑架

01:26:06.220 --> 01:26:07.220
vue雕塑架

01:26:07.220 --> 01:26:09.220
这些它都集于一个前提

01:26:09.220 --> 01:26:11.220
就是在读的环境里边要读文件

01:26:11.220 --> 01:26:13.220
这就是为什么vue雕塑架

01:26:13.220 --> 01:26:14.220
rex雕塑架

01:26:14.220 --> 01:26:15.220
要依赖读的

01:26:15.220 --> 01:26:17.220
它要在读的环境里面

01:26:17.220 --> 01:26:18.220
就是这个原因

01:26:18.220 --> 01:26:20.220
当然还有很多同学

01:26:20.220 --> 01:26:21.220
还没有学到vue

01:26:21.220 --> 01:26:22.220
还没有学到rex

01:26:22.220 --> 01:26:23.220
还没有学到雕塑架

01:26:23.220 --> 01:26:24.220
没关系

01:26:24.220 --> 01:26:25.220
你们早晚会接触的

01:26:25.220 --> 01:26:27.220
给你们说什么一点

01:26:27.220 --> 01:26:29.220
这几天上我们倒是拥不到

01:26:29.220 --> 01:26:31.220
不会直接用到读文件

01:26:31.220 --> 01:26:33.220
但是我给大家提醒

01:26:33.220 --> 01:26:35.220
读的里边是可以读文件的

01:26:35.220 --> 01:26:37.220
这就是它雕塑架实现的基础

01:26:37.220 --> 01:26:39.660
好了

01:26:39.660 --> 01:26:41.660
那么今天晚上我们要讲的东西就这些了

01:26:41.660 --> 01:26:42.660
总结一下吧

01:26:42.660 --> 01:26:44.660
读的安装那些东西没什么好说的

01:26:44.660 --> 01:26:45.660
全体对象

01:26:45.660 --> 01:26:47.660
可以跟Windows对比

01:26:47.660 --> 01:26:49.660
然后关键是common.js

01:26:49.660 --> 01:26:50.660
common.js对于我们后边

01:26:50.660 --> 01:26:51.660
要几天的学习呢

01:26:51.660 --> 01:26:52.660
这些东西都没用

01:26:52.660 --> 01:26:54.660
这些远达马分析都没用

01:26:54.660 --> 01:26:56.660
跟你们面是有关系的

01:26:56.660 --> 01:26:58.660
跟我们后边几天有影响的就是

01:26:58.660 --> 01:27:00.660
你要知道一个模块怎么导出

01:27:00.660 --> 01:27:01.660
一个模块怎么导入

01:27:01.660 --> 01:27:02.660
就够了

01:27:02.660 --> 01:27:03.660
然后mcm的使用

01:27:03.660 --> 01:27:05.660
你只需要知道这些命令就可以了

01:27:05.660 --> 01:27:06.660
先把这个东西运行一次

01:27:06.660 --> 01:27:08.660
设置一下原地址

01:27:08.660 --> 01:27:10.660
然后每个工程里需要出实化

01:27:10.660 --> 01:27:12.660
怎么去安装

01:27:12.660 --> 01:27:13.660
然后呢

01:27:13.660 --> 01:27:16.660
怎么去用开发一代安装

01:27:16.660 --> 01:27:18.660
这些东西你们知道怎么去使用

01:27:18.660 --> 01:27:20.660
然后内置模块只需要知道一个pass

01:27:20.660 --> 01:27:22.660
pass的resolve怎么用

01:27:22.660 --> 01:27:25.660
这是跟后面几天学习有关系的

01:27:25.660 --> 01:27:26.660
其他都没有什么关系

01:27:26.660 --> 01:27:27.660
其他都是认识一下

01:27:27.660 --> 01:27:29.660
有些地方是跟面试有关系的

01:27:29.660 --> 01:27:31.660
好 其他就没啥了

01:27:31.660 --> 01:27:32.660
隔壁街是你裂开了吗

01:27:32.660 --> 01:27:34.660
裂开赶快喉咙

01:27:34.660 --> 01:27:36.660
向后边不要离开不要走

01:27:36.660 --> 01:27:38.660
因为还有学老师

01:27:38.660 --> 01:27:40.660
因为刚才只是做了一个开场

01:27:40.660 --> 01:27:41.660
后边还有

01:27:41.660 --> 01:27:43.660
因为这几天的课程是这样子

01:27:43.660 --> 01:27:45.660
我讲负责了讲技术内容

01:27:45.660 --> 01:27:47.660
学老师负责一些答疑

01:27:47.660 --> 01:27:49.660
讲一些关于就业 面试

01:27:49.660 --> 01:27:51.660
将来的技术职业规划

01:27:51.660 --> 01:27:52.660
大家先不要走

01:27:52.660 --> 01:27:53.660
我这里面就直接下播了

01:27:53.660 --> 01:27:55.660
让学老师来接

01:27:55.660 --> 01:27:56.660
欢迎学老师

01:27:56.660 --> 01:27:58.660
我等一下把东西全部给大家发下来

