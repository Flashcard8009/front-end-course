WEBVTT

00:00.000 --> 00:06.500
说一下 这几天每次上集训银行的课

00:06.500 --> 00:08.000
很多同学心里边全掉药的

00:08.000 --> 00:11.500
就担心 后边我们不是有一个达标反线吗

00:11.500 --> 00:13.500
不用担心这个东西

00:13.500 --> 00:17.500
首先这几天的知识你肯定是买不了吃亏买不了上当

00:17.500 --> 00:22.000
另外就是达标反线 几乎是每一位同学都能够反线的

00:22.000 --> 00:25.000
就是来看一下你没有好好的听课

00:25.000 --> 00:28.000
你只要听了课 这个考试题是我出的

00:28.000 --> 00:31.000
放心 放一百个心 非常简单的

00:31.000 --> 00:33.000
一定是能够达标反线的

00:33.000 --> 00:35.000
不用担心 好好听课就行了

00:35.000 --> 00:39.000
这一次是小班 人不多

00:39.000 --> 00:41.000
小班也挺好的

00:41.000 --> 00:44.000
我可以多看一下同学们的评论

00:44.000 --> 00:46.000
给同学们多互动一下

00:46.000 --> 00:49.000
人多的时候 有的时候人多口渣

00:49.000 --> 00:52.000
一大堆不停的刷 我也看不清楚

00:52.000 --> 00:55.000
好了 那咱们就开始了吧

00:55.000 --> 00:57.000
这几天是讲算法

00:57.000 --> 01:00.000
每一天会有一些代码

01:00.000 --> 01:03.000
课堂代码 需要大家下课之后

01:03.000 --> 01:06.000
把课堂上的代码自己去写一遍

01:06.000 --> 01:08.000
不然的话 效果不佳

01:08.000 --> 01:10.000
光听课的话 效果不佳

01:10.000 --> 01:13.000
你听课 加上你后边听完课之后

01:13.000 --> 01:15.000
把我们课堂上讲的东西 练习题

01:15.000 --> 01:18.000
把它做一下 效果是最好的

01:18.000 --> 01:20.000
然后每一天的课是有一些笔记

01:20.000 --> 01:22.000
我一会会说一下笔记

01:22.000 --> 01:25.000
用什么样的工具可以打开

01:25.000 --> 01:27.000
首先我们在上课之前

01:27.000 --> 01:29.000
给大家说一下课程

01:29.000 --> 01:31.000
为什么会安排这样的一个课程

01:31.000 --> 01:33.000
因为平时在 我有的时候

01:33.000 --> 01:36.000
也会去上一些公开直播课

01:36.000 --> 01:38.000
有同学听过 是吧

01:38.000 --> 01:40.000
有没有同学听过我的课

01:42.000 --> 01:44.000
这个同学幽默了

01:44.000 --> 01:46.000
周永杰同学

01:46.000 --> 01:49.000
如果说你学过其他语言的话也行

01:49.000 --> 01:51.000
大概能听懂

01:51.000 --> 01:53.000
如果说你一门语言都没有学过的话

01:53.000 --> 01:55.000
那听起来可能

01:55.000 --> 01:56.000
就不是吃力的问题了

01:56.000 --> 01:58.000
可能是听不懂的问题了

01:58.000 --> 02:01.000
至少得会一门语言

02:01.000 --> 02:03.000
没有听过课的同学

02:03.000 --> 02:05.000
有段时间没有上公开直播课了

02:05.000 --> 02:07.000
以前上公开直播课的时候

02:07.000 --> 02:09.000
老师发现大家有一个

02:09.000 --> 02:12.000
特别是初学者 有一个问题就是

02:12.000 --> 02:14.000
老师写的代码了听

02:14.000 --> 02:16.000
我能听得懂

02:16.000 --> 02:18.000
但是自己一提笔来写

02:18.000 --> 02:19.000
就完全不会

02:19.000 --> 02:21.000
就是一听就懂

02:21.000 --> 02:22.000
一写就蒙

02:22.000 --> 02:25.000
我相信很多同学都有这样的一个问题

02:25.000 --> 02:26.000
另外呢

02:26.000 --> 02:28.000
可能学到后边的时候

02:28.000 --> 02:30.000
特别是想到一些比较深的

02:30.000 --> 02:32.000
深的复杂的代码的时候

02:32.000 --> 02:33.000
你会发现

02:33.000 --> 02:35.000
每一句代码我都能看得懂

02:35.000 --> 02:37.000
但是连起来

02:37.000 --> 02:39.000
我就不知道啥意思了

02:39.000 --> 02:41.000
我相信这样的同学也不再少数

02:41.000 --> 02:42.000
一个是能听懂

02:42.000 --> 02:43.000
但是我写不出来

02:43.000 --> 02:45.000
一个是呢

02:45.000 --> 02:46.000
我听的时候

02:46.000 --> 02:47.000
每一句代码我能看得懂

02:47.000 --> 02:48.000
一个辨量嘛

02:48.000 --> 02:49.000
写个循环嘛

02:49.000 --> 02:50.000
但是呢

02:50.000 --> 02:51.000
连起来我就不知道啥意思了

02:51.000 --> 02:53.000
那么这些问题呢

02:53.000 --> 02:54.000
归根结底呢

02:54.000 --> 02:55.000
就是一个程序思维的问题

02:55.000 --> 02:57.000
那么这个程序思维

02:57.000 --> 02:58.000
怎么去训练起来呢

02:58.000 --> 02:59.000
主要是

02:59.000 --> 03:01.000
训练最快些的方式

03:01.000 --> 03:02.000
就通过算法

03:02.000 --> 03:03.000
所以说呢

03:03.000 --> 03:04.000
很多时候啊

03:04.000 --> 03:06.000
你们去一些大厂

03:06.000 --> 03:08.000
去应聘的时候将来

03:08.000 --> 03:10.000
他为什么这么喜欢考算法

03:10.000 --> 03:12.000
这也是一个重要的原因

03:12.000 --> 03:14.000
特别是在笑招的时候

03:14.000 --> 03:16.000
就是我们学这个课了

03:16.000 --> 03:18.000
一方面是为了在面试体中

03:18.000 --> 03:20.000
完成前端面试期的

03:20.000 --> 03:22.000
大部分的算法体力

03:22.000 --> 03:23.000
因为特别是笑招

03:23.000 --> 03:24.000
笑招的公司

03:24.000 --> 03:26.000
特别喜欢考算法

03:26.000 --> 03:27.000
为啥呢

03:27.000 --> 03:28.000
因为他觉得你在学校里边

03:28.000 --> 03:31.000
学的都是一些理论性的知识

03:31.000 --> 03:34.000
可能没有什么项目实战经验

03:34.000 --> 03:35.000
那么这个时候呢

03:35.000 --> 03:36.000
他也不要求你

03:36.000 --> 03:38.000
有什么项目实战经验

03:38.000 --> 03:40.000
可能一个毕业设计够了

03:40.000 --> 03:41.000
那么更多的时候呢

03:41.000 --> 03:42.000
他会考察你

03:42.000 --> 03:43.000
这个人

03:43.000 --> 03:45.000
是不是有可述性

03:45.000 --> 03:46.000
那么他怎么来考察呢

03:46.000 --> 03:47.000
就是看你的逻辑思维能力

03:47.000 --> 03:49.000
你的程序思维能力强不强

03:49.000 --> 03:51.000
如果说这个方面的能力比较强的话

03:51.000 --> 03:53.000
你这个人可述性比较好

03:53.000 --> 03:54.000
那么到了公司里边

03:54.000 --> 03:55.000
我慢慢培养呗

03:55.000 --> 03:58.000
大厂他也不会太担心人才的流失

03:58.000 --> 04:00.000
他是能够留住人的

04:00.000 --> 04:01.000
所以说呢

04:01.000 --> 04:04.000
很多大厂愿意去考很多的算法体

04:04.000 --> 04:05.000
你看现在字节跳动

04:05.000 --> 04:06.000
最近这几年

04:06.000 --> 04:09.000
每一年的算法体就越来越多了

04:09.000 --> 04:10.000
在前端啊

04:10.000 --> 04:12.000
前几年还比较简单

04:12.000 --> 04:13.000
后来呢

04:13.000 --> 04:14.000
算法体就简单

04:14.000 --> 04:15.000
占了比中了就越来越大了

04:15.000 --> 04:16.000
这是一个

04:16.000 --> 04:18.000
我为什么要用这个课

04:18.000 --> 04:19.000
第二个呢

04:19.000 --> 04:22.000
是我希望了通过学习这个课啊

04:22.000 --> 04:24.000
你们将来会学到后边啊

04:24.000 --> 04:25.000
学到咱们后期的课程里边

04:25.000 --> 04:27.000
后期的课程里边呢

04:27.000 --> 04:28.000
有一些课程呢

04:28.000 --> 04:30.000
是跟底层代码分析有关系的

04:30.000 --> 04:31.000
比方说我们后面讲

04:31.000 --> 04:32.000
Wheel啊有Wheel的代码

04:32.000 --> 04:33.000
远代码分析

04:33.000 --> 04:34.000
讲Wheel Rotor

04:34.000 --> 04:35.000
Wheel X

04:35.000 --> 04:37.000
讲Rex Rotor

04:37.000 --> 04:38.000
什么Ridax

04:38.000 --> 04:39.000
讲这些技术的时候呢

04:39.000 --> 04:41.000
都有它的手写实现

04:41.000 --> 04:42.000
那么到时候呢

04:42.000 --> 04:43.000
你可能很多人就听不懂了

04:43.000 --> 04:45.000
那么没有这个算法的能力的话

04:45.000 --> 04:46.000
你可能听这些课呢

04:46.000 --> 04:47.000
也比较吃力

04:47.000 --> 04:49.000
所以说学习这个算法

04:49.000 --> 04:50.000
可能还有这么一个目的

04:50.000 --> 04:52.000
其实这两个都是小事

04:52.000 --> 04:53.000
因为有些人说

04:53.000 --> 04:54.000
我不准备进大厂

04:54.000 --> 04:55.000
大厂太难了

04:55.000 --> 04:56.000
千去万绑过度

04:56.000 --> 04:57.000
木桥太难了

04:57.000 --> 04:59.000
我也没打算去做什么

04:59.000 --> 05:01.000
底层技术分析

05:01.000 --> 05:03.000
也不要打算去熟悉一些东西

05:03.000 --> 05:05.000
那么更多的时候

05:05.000 --> 05:06.000
我们算法课的目的

05:06.000 --> 05:08.000
是为了锻炼大家的

05:08.000 --> 05:11.000
开发思维和代码转换能力

05:11.000 --> 05:13.000
那么我这里说一下啊

05:13.000 --> 05:15.000
开发思维啥意思

05:15.000 --> 05:16.000
解决什么问题呢

05:16.000 --> 05:19.000
就解决的是我拿到一个效果

05:19.000 --> 05:20.000
拿到一个功能

05:20.000 --> 05:22.000
我完全是懵的状态

05:22.000 --> 05:24.000
我不知道怎么去下手

05:24.000 --> 05:26.000
很多人都有这样的一个问题

05:26.000 --> 05:27.000
我看到这个效果

05:27.000 --> 05:28.000
我不知道怎么去下手

05:28.000 --> 05:29.000
怎么把它实现

05:29.000 --> 05:31.000
而如果你有这样的问题的话

05:31.000 --> 05:33.000
学这个算法课呢

05:33.000 --> 05:34.000
在一定程度上

05:34.000 --> 05:35.000
会帮助到你

05:35.000 --> 05:36.000
当然你要说

05:36.000 --> 05:37.000
我通过这五天时间

05:37.000 --> 05:39.000
是不是就彻底解决这个问题呢

05:39.000 --> 05:40.000
那也不够

05:40.000 --> 05:41.000
那么通过这五天呢

05:41.000 --> 05:43.000
你一定是不是会上升一个课

05:43.000 --> 05:44.000
但是呢

05:44.000 --> 05:45.000
你要说彻底解决个问题

05:45.000 --> 05:47.000
这就是一个长时间的练习

05:47.000 --> 05:48.000
而且呢

05:48.000 --> 05:49.000
这个代码课呢

05:49.000 --> 05:50.000
这个算法课呢

05:50.000 --> 05:51.000
这五天的时间啊

05:51.000 --> 05:52.000
也是咱们从

05:52.000 --> 05:54.000
我们后期的算法课里边

05:54.000 --> 05:56.000
给大家抽离到一部分出来的啊

05:56.000 --> 05:57.000
还有一些更复杂的

05:57.000 --> 05:58.000
在后期的课程里边

05:58.000 --> 06:00.000
这是开发思维

06:00.000 --> 06:01.000
另一方面呢

06:01.000 --> 06:03.000
叫做代码转换能力

06:03.000 --> 06:05.000
这个能力呢

06:05.000 --> 06:07.000
对于初学者而言

06:07.000 --> 06:08.000
可能更加重要

06:08.000 --> 06:10.000
什么叫代码转换能力呢

06:10.000 --> 06:11.000
就是思维你不用想的

06:11.000 --> 06:13.000
老师提供给你

06:13.000 --> 06:15.000
有没有一些成熟的方案提供给你

06:15.000 --> 06:16.000
给你的一个思维

06:16.000 --> 06:17.000
但是你没有办法

06:17.000 --> 06:19.000
用代码把它实现

06:19.000 --> 06:21.000
你知道什么意思

06:21.000 --> 06:22.000
我这样做可以达到目标

06:22.000 --> 06:24.000
但是我不知道怎么去下手写代码

06:24.000 --> 06:26.000
那就是代码转换能力

06:26.000 --> 06:27.000
你不能把一个思维

06:27.000 --> 06:30.000
一个方案转换成代码

06:30.000 --> 06:31.000
那么这也是很多同学

06:31.000 --> 06:33.000
在刚刚学习编程的时候

06:33.000 --> 06:34.000
特别欠缺了

06:34.000 --> 06:35.000
说我们这个算法课呢

06:35.000 --> 06:36.000
最重要的目的

06:36.000 --> 06:38.000
实际上是这两个

06:38.000 --> 06:39.000
当然你如果说有自己

06:39.000 --> 06:40.000
有这个雄心

06:40.000 --> 06:42.000
去冲击大厂

06:42.000 --> 06:44.000
去研究一些

06:44.000 --> 06:46.000
底层的代码实现

06:46.000 --> 06:47.000
那么你还会

06:47.000 --> 06:48.000
通过这个算法课呢

06:48.000 --> 06:50.000
获得这方面的能力

06:50.000 --> 06:52.000
这是对课程说的说明

06:52.000 --> 06:55.850
听过一次是

06:55.850 --> 06:57.850
一样的

06:57.850 --> 06:58.850
因为小额课呢

06:58.850 --> 07:00.850
我们不能把它设置得太难

07:00.850 --> 07:02.850
然后呢还是一样

07:02.850 --> 07:03.850
在课程说明之后呢

07:03.850 --> 07:04.850
我说一下

07:04.850 --> 07:05.850
这个一些

07:05.850 --> 07:06.850
我可以对算法的

07:06.850 --> 07:07.850
一些常见的问题

07:07.850 --> 07:08.850
因为我们这个课呢

07:08.850 --> 07:10.850
名字叫做数据结构与算法

07:10.850 --> 07:11.850
首先我解释一下

07:11.850 --> 07:13.850
什么叫数据结构

07:14.850 --> 07:15.850
如果说你学过

07:15.850 --> 07:16.850
任何一门语言

07:16.850 --> 07:17.850
你至少都用过一个数据

07:17.850 --> 07:18.850
对吧

07:18.850 --> 07:19.850
为什么要有数据

07:19.850 --> 07:20.850
因为我们有

07:21.850 --> 07:23.850
意识差不多的一组数据

07:23.850 --> 07:24.850
比方说学生成绩

07:24.850 --> 07:26.850
比方说我们的

07:26.850 --> 07:27.850
很多文章

07:28.850 --> 07:29.850
有一些意识含义

07:29.850 --> 07:30.850
差不多的数据

07:30.850 --> 07:31.850
我们可能需要一个

07:31.850 --> 07:33.850
东西把它组织起来

07:33.850 --> 07:34.850
那么我们这个东西

07:34.850 --> 07:35.850
就是数据

07:35.850 --> 07:37.850
数据呢就是数据结构的一种

07:37.850 --> 07:38.850
什么叫数据结构呢

07:38.850 --> 07:40.850
就是研究数据关系的

07:40.850 --> 07:41.850
我们这几天呢

07:41.850 --> 07:42.850
会陆续的

07:42.850 --> 07:43.850
接触一些数据结构

07:43.850 --> 07:44.850
比方说数据啊

07:44.850 --> 07:45.850
链表今天我们会接触

07:45.850 --> 07:46.850
数据和链表

07:46.850 --> 07:47.850
然后呢

07:47.850 --> 07:48.850
数

07:48.850 --> 07:49.850
然后图

07:49.850 --> 07:50.850
每一种数据结构呢

07:50.850 --> 07:52.850
它有自己各自的特点

07:52.850 --> 07:53.850
到时候呢

07:53.850 --> 07:54.850
我们结束了过后呢

07:54.850 --> 07:56.850
大家就会有有所体会吧

07:56.850 --> 07:57.850
简单说一下

07:57.850 --> 07:58.850
什么叫数据结构

07:58.850 --> 07:59.850
它是用来组织

07:59.850 --> 08:00.850
各种数据的

08:00.850 --> 08:02.850
来组织数据之间关系的

08:02.850 --> 08:04.850
那么什么又叫做算法呢

08:04.850 --> 08:05.850
因为我们这个课

08:05.850 --> 08:06.850
叫做数据结构与算法

08:06.850 --> 08:08.850
什么叫算法呢

08:08.850 --> 08:09.850
算法其实

08:09.850 --> 08:10.850
它的概念含义

08:10.850 --> 08:11.850
特别简单

08:11.850 --> 08:12.850
就是给你一个

08:12.850 --> 08:13.850
以示的东西

08:13.850 --> 08:14.850
你给我算出一个位置的东西

08:14.850 --> 08:16.850
这就是算法

08:16.850 --> 08:17.850
然后给你一个数据

08:17.850 --> 08:18.850
你把这个数据排序好

08:18.850 --> 08:19.850
这就是个算法

08:19.850 --> 08:20.850
你要通过什么样的

08:20.850 --> 08:22.850
计算的方式

08:22.850 --> 08:23.850
把这个东西实现

08:23.850 --> 08:25.850
根据以示来求位置

08:25.850 --> 08:27.850
这就是算法

08:27.850 --> 08:28.850
那么算法跟数据结构啊

08:28.850 --> 08:30.850
实际上是有一些关系的

08:30.850 --> 08:31.850
长期的算法呢

08:31.850 --> 08:32.850
比方说我们这里

08:32.850 --> 08:33.850
有几些议业算法

08:33.850 --> 08:35.850
我们都学的会讲到

08:35.850 --> 08:36.850
算法跟数据结构

08:36.850 --> 08:37.850
有什么样的关系呢

08:37.850 --> 08:38.850
数据结构关系的是

08:38.850 --> 08:40.850
我怎么来存这个数据

08:40.850 --> 08:41.850
养一个数据

08:41.850 --> 08:42.850
我把一个数据

08:42.850 --> 08:43.850
挨干一个

08:43.850 --> 08:44.850
纯刀的数据里边去

08:44.850 --> 08:45.850
包括我们后面

08:45.850 --> 08:46.850
还会学一些图

08:46.850 --> 08:47.850
还会学一些数

08:47.850 --> 08:48.850
用什么样的结构

08:48.850 --> 08:50.850
来表示数据之间的关系

08:50.850 --> 08:51.850
它关心的是

08:51.850 --> 08:53.850
怎么来存这个数据

08:53.850 --> 08:55.850
而算法呢

08:55.850 --> 08:56.850
关心的是

08:56.850 --> 08:58.850
我怎么样把这个东西

08:58.850 --> 09:00.850
变成另一个东西

09:00.850 --> 09:01.850
那么这两个东西

09:01.850 --> 09:02.850
有什么关系呢

09:02.850 --> 09:04.850
因为有了数据结构之后

09:04.850 --> 09:05.850
比方说有个数据

09:05.850 --> 09:07.850
就设计到排序吧

09:07.850 --> 09:09.850
设计到查找吧

09:09.850 --> 09:10.850
对不对

09:10.850 --> 09:11.850
那么一定会设计到

09:11.850 --> 09:12.850
多多少少会设计到

09:12.850 --> 09:13.850
跟这个数据结构

09:13.850 --> 09:15.850
相关的一些技术

09:15.850 --> 09:16.850
所以说数据结构

09:16.850 --> 09:17.850
跟算法之间

09:17.850 --> 09:20.850
联系常常是非常紧密的

09:20.850 --> 09:21.850
我们拿到一个问题之后

09:21.850 --> 09:22.850
我们会常常想

09:22.850 --> 09:23.850
这个问题

09:23.850 --> 09:24.850
我用什么东西

09:24.850 --> 09:25.850
来存这个数据呢

09:25.850 --> 09:26.850
用什么样的结构

09:26.850 --> 09:27.850
来存这个数据呢

09:27.850 --> 09:28.850
存了之后

09:28.850 --> 09:29.850
我如何从这个结构中

09:29.850 --> 09:30.850
找到我们想要的东西呢

09:30.850 --> 09:31.850
所以说数据结构

09:31.850 --> 09:32.850
跟算法往往是

09:32.850 --> 09:33.850
联系比较紧密的

09:33.850 --> 09:35.850
你看里面学这个

09:35.850 --> 09:37.850
计算计算业的同学

09:37.850 --> 09:38.850
里面那个课程里边

09:38.850 --> 09:39.850
这个数据结构跟算法

09:39.850 --> 09:40.850
对不对

09:40.850 --> 09:41.850
好

09:41.850 --> 09:43.850
这是两个简单的概念

09:43.850 --> 09:46.850
给大家先解释一下

09:46.850 --> 09:47.850
然后就是说

09:47.850 --> 09:48.850
这个数据结构跟算法

09:48.850 --> 09:49.850
要用什么样的结构

09:49.850 --> 09:50.850
已经语言了

09:50.850 --> 09:51.850
就是我们这几天

09:51.850 --> 09:52.850
用什么样的语言来编写了

09:52.850 --> 09:53.850
因为毕竟是

09:53.850 --> 09:55.850
面向前端的同学吧

09:55.850 --> 09:56.850
所以说我们会

09:56.850 --> 09:57.850
使用借识语言

09:57.850 --> 09:59.850
但是实际上呢

09:59.850 --> 10:00.850
算法也好

10:00.850 --> 10:02.850
数据结构也好

10:02.850 --> 10:03.850
它跟具体的语言

10:03.850 --> 10:05.850
没有什么关系

10:05.850 --> 10:06.850
你用 C 和可以

10:06.850 --> 10:07.850
你用 C 加也可以

10:07.850 --> 10:09.850
你用 PSP 都可以

10:09.850 --> 10:10.850
所以说我刚才同学问

10:10.850 --> 10:11.850
我没有学过

10:11.850 --> 10:13.850
借识能不能学这门课呢

10:13.850 --> 10:15.850
你只要学过一门语言就行

10:15.850 --> 10:17.850
你把这个思维

10:17.850 --> 10:18.850
因为算法主要是

10:18.850 --> 10:19.850
研究的思维

10:19.850 --> 10:20.850
计算方式

10:20.850 --> 10:22.850
你把这个思维方式技术

10:22.850 --> 10:23.850
把体会到

10:23.850 --> 10:24.850
那么你用

10:24.850 --> 10:25.850
其他的语言去实现

10:25.850 --> 10:26.850
没有任何问题

10:26.850 --> 10:27.850
因为别的语言

10:27.850 --> 10:28.850
也有函数嘛

10:28.850 --> 10:29.850
也有变量嘛

10:29.850 --> 10:30.850
也有循环

10:30.850 --> 10:31.850
也有数数

10:31.850 --> 10:32.850
不都一样吗

10:32.850 --> 10:33.850
对不对

10:33.850 --> 10:34.850
在这种基础结构上

10:34.850 --> 10:35.850
都一样

10:35.850 --> 10:36.850
所以说

10:36.850 --> 10:37.850
我这几天呢

10:37.850 --> 10:38.850
还是使用

10:38.850 --> 10:39.850
借识语言去实现

10:41.850 --> 10:42.850
好

10:42.850 --> 10:44.850
说到一个比较沉重的话题的

10:44.850 --> 10:46.850
配置要求

10:46.850 --> 10:47.850
就是你学这个课呢

10:47.850 --> 10:49.850
有些同学学的比较轻松一点

10:49.850 --> 10:52.850
有些同学学的比较困难一点

10:52.850 --> 10:54.850
那么为什么会出现这样的问题呢

10:54.850 --> 10:55.850
主要是

10:55.850 --> 10:57.850
一个是知识

10:57.850 --> 10:59.850
最低的限度

10:59.850 --> 11:00.850
你学这门课呢

11:00.850 --> 11:02.850
你得有这些知识

11:02.850 --> 11:03.850
我都不要求你

11:03.850 --> 11:04.850
会动物操作

11:04.850 --> 11:05.850
就是会操作

11:05.850 --> 11:07.850
因为它们各种元素不要求

11:07.850 --> 11:09.850
但是你至少得学习过

11:09.850 --> 11:13.850
任何一门语言的基础

11:13.850 --> 11:14.850
比方说变量啊

11:14.850 --> 11:15.850
判断啊

11:15.850 --> 11:16.850
循环数数

11:16.850 --> 11:17.850
函数

11:17.850 --> 11:18.850
啊

11:18.850 --> 11:19.850
构造函数

11:19.850 --> 11:20.850
植内形

11:20.850 --> 11:21.850
引用内形

11:21.850 --> 11:22.850
这些最基本的东西你得知道

11:22.850 --> 11:23.850
你看任何语言

11:23.850 --> 11:25.850
是不是都跑不掉这东西

11:25.850 --> 11:27.850
谁语言谁压迦都跑不掉

11:27.850 --> 11:28.850
对不对

11:28.850 --> 11:29.850
好

11:29.850 --> 11:30.850
然后呢

11:30.850 --> 11:31.850
就是

11:31.850 --> 11:32.850
如果说你学到

11:32.850 --> 11:33.850
更多的东西

11:33.850 --> 11:34.850
还更好

11:34.850 --> 11:35.850
之外呢

11:35.850 --> 11:36.850
如果说你

11:36.850 --> 11:37.850
结束了帝规

11:37.850 --> 11:38.850
知道作用运练

11:38.850 --> 11:39.850
知道执行划卡文

11:39.850 --> 11:40.850
执行战

11:40.850 --> 11:41.850
知道这些知识呢

11:41.850 --> 11:42.850
那么听这一课呢

11:42.850 --> 11:43.850
就更加轻松了

11:43.850 --> 11:44.850
啊

11:45.850 --> 11:46.850
这是知识部分

11:47.850 --> 11:49.850
还有就是代码量

11:49.850 --> 11:51.850
代码量的话

11:52.850 --> 11:53.850
我不知道

11:53.850 --> 11:55.850
有没有满足这个要求啊

11:55.850 --> 11:56.850
代码量的话

11:56.850 --> 11:57.850
你得写过写

11:57.850 --> 11:59.850
写个500行代码

11:59.850 --> 12:01.850
如果说你没有写个500行代码

12:01.850 --> 12:02.850
你听起来了

12:02.850 --> 12:04.850
可能有些东西比较吃力

12:05.850 --> 12:06.850
可能不是很好理解

12:06.850 --> 12:07.850
代码你都认识

12:07.850 --> 12:08.850
有了这些知识

12:08.850 --> 12:09.850
你都认识代码

12:09.850 --> 12:10.850
代码都没问题

12:10.850 --> 12:11.850
都能认识

12:11.850 --> 12:12.850
但是你连在一起

12:12.850 --> 12:13.850
就不知道啥意思了

12:13.850 --> 12:14.850
可能有点感觉

12:14.850 --> 12:16.850
吃力跟不上

12:16.850 --> 12:17.850
这种感觉

12:17.850 --> 12:18.850
如果说你没有500行代码

12:18.850 --> 12:20.850
500行其实量不多啊

12:20.850 --> 12:21.850
因为你平时

12:21.850 --> 12:22.850
听我们的公开直播课的话

12:22.850 --> 12:23.850
你看我们的

12:23.850 --> 12:24.850
公开直播课里面

12:24.850 --> 12:25.850
三个效果

12:25.850 --> 12:26.850
基本上就够500行代码了

12:26.850 --> 12:27.850
你把三个效果

12:27.850 --> 12:28.850
实现了

12:28.850 --> 12:29.850
就够了

12:29.850 --> 12:30.850
这最低配置

12:30.850 --> 12:31.850
当然最好了

12:31.850 --> 12:32.850
你有3000行代码

12:32.850 --> 12:33.850
那就是差不多

12:33.850 --> 12:34.850
实现了10个效果

12:34.850 --> 12:35.850
那么这样子

12:35.850 --> 12:36.850
你听起来就

12:36.850 --> 12:37.850
稍微比较轻松了

12:37.850 --> 12:39.850
这是听我们这个课的

12:39.850 --> 12:40.850
配置要求

12:40.850 --> 12:41.850
我以为说

12:41.850 --> 12:42.850
那我现在还没有

12:42.850 --> 12:43.850
达到这样的要求

12:43.850 --> 12:44.850
怎么办呢

12:44.850 --> 12:45.850
没关系

12:45.850 --> 12:46.850
你先听这个意思

12:46.850 --> 12:47.850
多多少少领词

12:47.850 --> 12:48.850
能够听懂一些的

12:48.850 --> 12:49.850
听这个意思

12:49.850 --> 12:50.850
反正这个课

12:50.850 --> 12:51.850
你不用担心

12:51.850 --> 12:52.850
不用担心

12:52.850 --> 12:53.850
打标的问题

12:53.850 --> 12:54.850
你只要听了课

12:54.850 --> 12:55.850
你一定能打标的

12:55.850 --> 12:56.850
打标的问题

12:56.850 --> 12:57.850
没有任何逻辑问题

12:57.850 --> 12:58.850
才应该

12:58.850 --> 12:59.850
所以你一定能打标的

12:59.850 --> 13:00.850
不用担心那个

13:00.850 --> 13:01.850
然后这个课呢

13:01.850 --> 13:02.850
反正后面有录播

13:02.850 --> 13:03.850
你们慢慢看

13:03.850 --> 13:04.850
好吧

13:04.850 --> 13:06.850
这是关于这个听课

13:06.850 --> 13:08.850
先提前说一下

13:08.850 --> 13:09.850
好 所以说一下这个

13:09.850 --> 13:10.850
就是每一天

13:10.850 --> 13:11.850
我会有一个笔记

13:11.850 --> 13:12.850
就像这些这样的笔记

13:12.850 --> 13:13.850
这个笔记

13:13.850 --> 13:15.850
是一个markdown文件

13:15.850 --> 13:16.850
我们做开发的

13:16.850 --> 13:18.850
不可能去用什么word

13:18.850 --> 13:19.850
来写

13:19.850 --> 13:20.850
一般都使用markdown

13:20.850 --> 13:21.850
来写文档

13:21.850 --> 13:22.850
写笔记

13:22.850 --> 13:23.850
也就是说

13:23.850 --> 13:24.850
你们不用记笔记了

13:24.850 --> 13:25.850
看我的

13:25.850 --> 13:26.850
认真听课就行了

13:26.850 --> 13:27.850
看我的笔记就行了

13:27.850 --> 13:28.850
这个markdown文件

13:28.850 --> 13:29.850
有很多工具都可以打开

13:29.850 --> 13:31.850
包括我们的VSCode

13:31.850 --> 13:32.850
可以打开

13:32.850 --> 13:33.850
那么当然建议大家

13:33.850 --> 13:34.850
去下这个pipro

13:34.850 --> 13:35.850
这个网站

13:35.850 --> 13:36.850
进去了

13:36.850 --> 13:37.850
给它翻一下

13:38.850 --> 13:44.230
就进这个网站

13:44.230 --> 13:45.230
这个网站呢

13:45.230 --> 13:46.230
往下拉

13:46.230 --> 13:48.230
找到download

13:48.230 --> 13:49.230
找到你的操作系统

13:49.230 --> 13:50.230
windows一下

13:50.230 --> 13:51.230
windows mic就下来

13:51.230 --> 13:52.230
下来下来

13:52.230 --> 13:53.230
下一步下一步下一步

13:53.230 --> 13:54.230
就安装了

13:54.230 --> 13:55.230
安装完了之后

13:55.230 --> 13:56.230
你就可以在这里

13:56.230 --> 13:57.230
双击打开

13:57.230 --> 13:58.230
在这双击打开

13:58.230 --> 14:00.230
这个课件就可以打开了

14:00.230 --> 14:02.230
这是关于这个笔记

14:02.230 --> 14:03.230
好了

14:03.230 --> 14:04.230
当然开发

14:04.230 --> 14:05.230
就是开发工具

14:05.230 --> 14:07.230
我选用的是VSCode

14:07.230 --> 14:08.230
也不一定你们

14:08.230 --> 14:09.230
非要用这个VSCode

14:09.230 --> 14:10.230
你可以选择

14:10.230 --> 14:11.230
任何一个

14:11.230 --> 14:13.230
你喜欢的开发工具都可以

14:13.230 --> 14:14.230
好

14:14.230 --> 14:17.230
这是一些前面的知识

14:17.230 --> 14:18.230
好了

14:18.230 --> 14:19.230
那么接下来

14:19.230 --> 14:20.230
就进入正题了

14:20.230 --> 14:22.230
就讲我们知识部分了

14:22.230 --> 14:23.230
今天晚上

14:23.230 --> 14:25.230
会涉及到一个知识

14:25.230 --> 14:26.230
就是地规

14:26.230 --> 14:27.230
我担心有同学

14:27.230 --> 14:28.230
我看一下

14:28.230 --> 14:29.230
有没有同学

14:29.230 --> 14:30.230
没有接触过地规的

14:30.230 --> 14:32.230
没有接触过地规的Q格1

14:32.230 --> 14:33.230
接触过了Q格2

14:33.230 --> 14:36.230
我看一下吧

14:36.230 --> 14:38.230
有同学还是没有接触过的

14:38.230 --> 14:39.230
不熟悉

14:39.230 --> 14:40.230
2

14:40.230 --> 14:41.230
1

14:41.230 --> 14:42.230
好

14:42.230 --> 14:43.230
行

14:43.230 --> 14:44.230
来吧

14:44.230 --> 14:45.230
我先讲一讲地规

14:45.230 --> 14:46.230
当然了

14:46.230 --> 14:47.230
这个地规

14:47.230 --> 14:48.230
你要把它理解清楚了

14:48.230 --> 14:49.230
你需要这个知识

14:49.230 --> 14:51.230
你需要

14:51.230 --> 14:52.230
知道那个

14:52.230 --> 14:53.230
执行上下文

14:53.230 --> 14:54.230
执行战

14:54.230 --> 14:55.230
你至少得知道这个

14:55.230 --> 14:56.230
你才能把地规

14:56.230 --> 14:58.230
测测滴滴的理解清楚

14:58.230 --> 14:59.230
但是我讲这个东西

14:59.230 --> 15:01.230
就实际上太长了

15:02.230 --> 15:04.230
这个网线不是一两句话

15:04.230 --> 15:05.230
能解释清楚的

15:05.230 --> 15:06.230
它在讲一节课的

15:06.230 --> 15:07.230
所以说这个时间

15:07.230 --> 15:08.230
就太长了

15:08.230 --> 15:09.230
大家可以去下去看一下

15:09.230 --> 15:12.230
咱们诚哥的公益课程

15:12.230 --> 15:13.230
咱们的既然是公益课程

15:13.230 --> 15:15.230
也不要讲到执行上下文和执行战

15:15.230 --> 15:16.230
把它看一下

15:16.230 --> 15:18.230
就能够彻底的去理解地规了

15:18.230 --> 15:20.230
那么这里呢

15:20.230 --> 15:21.230
尽管你有些同学

15:21.230 --> 15:22.230
没有这样的知识

15:22.230 --> 15:23.230
那怎么来理解这个地规呢

15:23.230 --> 15:25.230
我同一个比较简单的方式

15:25.230 --> 15:28.230
帮助大家去理解

15:28.230 --> 15:29.230
首先大家要知道

15:29.230 --> 15:30.230
这个地规

15:30.230 --> 15:32.230
这个东西是老来的

15:32.230 --> 15:33.230
不是现在出来的

15:33.230 --> 15:34.230
早就出来了

15:34.230 --> 15:35.230
几十年前就出来了

15:35.230 --> 15:37.230
这是一种编程思想

15:37.230 --> 15:39.230
它还真不是某一个代码

15:39.230 --> 15:40.230
某一种代码

15:40.230 --> 15:42.230
它是一种编程思想的产物

15:42.230 --> 15:43.230
什么编程思想呢

15:43.230 --> 15:46.230
是寒树式编程思想

15:46.230 --> 15:47.230
什么叫寒树式编程

15:47.230 --> 15:49.230
寒树式编程思想呢

15:49.230 --> 15:51.230
有人说是不是就写个寒树了

15:51.230 --> 15:52.230
不是的

15:52.230 --> 15:54.230
寒树式编程思想

15:54.230 --> 15:55.230
它不是写寒树

15:55.230 --> 15:56.230
它内地的寒树

15:56.230 --> 15:58.230
指的不是我们自己写的寒树

15:58.230 --> 16:00.230
不是我们在一个代码里面的寒树

16:00.230 --> 16:03.230
指的是数学寒树

16:03.230 --> 16:06.230
寒树式实为它是指的是

16:06.230 --> 16:07.230
我用从一个

16:07.230 --> 16:11.230
从数学寒树的角度去出发

16:11.230 --> 16:14.230
来去建立一个数学模型

16:14.230 --> 16:17.230
来去研究我们的一个问题

16:17.230 --> 16:18.230
怎么从一个数学

16:18.230 --> 16:20.230
怎么把它演变成一个数学寒树

16:20.230 --> 16:22.230
然后来分析这个寒树里面的

16:22.230 --> 16:24.230
一些位置数的关系

16:24.230 --> 16:26.230
这是寒树式编程思想

16:27.230 --> 16:29.230
寒树式可能会有点深

16:29.230 --> 16:30.230
我们点到记字

16:30.230 --> 16:34.230
从它是从一个数学的角度去思维

16:34.230 --> 16:37.230
那么我们从一个寒树式的编程思想

16:37.230 --> 16:38.230
去出发

16:38.230 --> 16:41.230
就非常非常容易把一些问题

16:41.230 --> 16:43.230
转换成地轨模式

16:43.230 --> 16:44.230
什么叫地轨模式呢

16:44.230 --> 16:46.230
我给大家看一个问题

16:46.230 --> 16:48.230
典型的一个问题就是

16:48.230 --> 16:49.230
非波拉气数列

16:49.230 --> 16:50.230
什么叫非波拉气数列

16:50.230 --> 16:51.230
就这么一个数列

16:51.230 --> 16:52.230
第一位以为1

16:52.230 --> 16:53.230
第二位为1

16:53.230 --> 16:55.230
现在忘记编程

16:56.230 --> 16:57.230
不要去想编程

16:57.230 --> 16:59.230
我们就想数学

16:59.230 --> 17:00.230
一个数列

17:00.230 --> 17:01.230
第一位为1

17:01.230 --> 17:02.230
第二位也是1

17:02.230 --> 17:04.230
后面就是浅量为强加

17:04.230 --> 17:05.230
你看这个

17:05.230 --> 17:06.230
这一位

17:06.230 --> 17:08.230
等于第一位加第二位

17:08.230 --> 17:10.230
这一位等于第二位加第三位

17:10.230 --> 17:11.230
看来

17:11.230 --> 17:13.230
这一位等于第三位加第四位

17:13.230 --> 17:15.230
就这么一个数列

17:15.230 --> 17:16.230
那么现在

17:16.230 --> 17:18.230
我要求数学

17:18.230 --> 17:21.230
我要求地n位的值

17:21.230 --> 17:22.230
那么如果说

17:22.230 --> 17:24.230
从寒树式编程来出发的话

17:24.230 --> 17:25.230
就怎么来去想这个问题呢

17:25.230 --> 17:26.230
不要去想带嘛

17:26.230 --> 17:27.230
不要去想带嘛

17:27.230 --> 17:32.590
就想数学

17:32.590 --> 17:34.590
怎么来想这个问题

17:34.590 --> 17:36.590
把这个拖过去

17:36.590 --> 17:39.930
好 看着啊

17:39.930 --> 17:41.930
我们可以这样子来

17:41.930 --> 17:43.930
我在数学里面

17:43.930 --> 17:45.930
假设有一个函数f

17:45.930 --> 17:46.930
fn

17:46.930 --> 17:48.930
n是第几位的值吗

17:48.930 --> 17:50.930
fn来表示地n位的值

17:50.930 --> 17:52.930
n表示第几位

17:52.930 --> 17:54.930
fn来表示地n位的值

17:54.930 --> 17:55.930
假设有这么一个函数

17:55.930 --> 17:56.930
那么这个函数

17:56.930 --> 17:57.930
有什么样的特点呢

17:57.930 --> 17:58.930
我们可以推到出

17:58.930 --> 18:00.930
它第一位固定为1

18:00.930 --> 18:03.930
也就是说f1等于1

18:03.930 --> 18:04.930
对不对

18:04.930 --> 18:05.930
第一位固定为1嘛

18:05.930 --> 18:10.690
第二位也固定为1

18:10.690 --> 18:12.690
有这么一个规则

18:12.690 --> 18:13.690
然后呢

18:13.690 --> 18:14.690
如果说

18:14.690 --> 18:16.690
那么fn等于几呢

18:16.690 --> 18:17.690
就是n大于

18:17.690 --> 18:20.690
n大于2的情况下

18:20.690 --> 18:21.690
fn等于几呢

18:21.690 --> 18:22.690
我们可以推到出

18:22.690 --> 18:24.690
fn等于它前一位

18:24.690 --> 18:25.690
再加上前一位

18:25.690 --> 18:26.690
对吧

18:26.690 --> 18:28.690
所以我们等于fn-1

18:28.690 --> 18:31.690
加上fn-2

18:31.690 --> 18:32.690
不要去想待嘛

18:32.690 --> 18:34.690
不要去想待嘛

18:34.690 --> 18:35.690
从数学的角度

18:35.690 --> 18:37.690
这个玩意儿能不能理解

18:37.690 --> 18:38.690
能理解的话

18:38.690 --> 18:39.690
求个1

18:39.690 --> 18:43.130
我还是把这些东西

18:43.130 --> 18:45.130
放到同一个桌面吧

18:45.130 --> 18:48.890
能理解吧

18:48.890 --> 18:49.890
是不是很好理解

18:49.890 --> 18:50.890
对不对

18:50.890 --> 18:51.890
其实有的时候呢

18:51.890 --> 18:52.890
学到后面呢

18:52.890 --> 18:53.890
很多朋友觉得

18:53.890 --> 18:55.890
函数式编程思维太难了

18:55.890 --> 18:56.890
感觉太不适应了

18:56.890 --> 18:58.890
其实函数式编程思维

18:58.890 --> 19:00.890
还是非常非常符合

19:00.890 --> 19:02.890
我们正常人的思维

19:02.890 --> 19:03.890
只不过呢

19:03.890 --> 19:04.890
很多同学学到后面

19:04.890 --> 19:06.890
把我们平时开发的那种思维

19:06.890 --> 19:07.890
叫另一式编程思维

19:07.890 --> 19:09.890
摸得太熟了

19:09.890 --> 19:10.890
所以说觉得函数式

19:10.890 --> 19:12.890
太乖了的东西

19:12.890 --> 19:13.890
那么如果说

19:13.890 --> 19:14.890
从数学的角度

19:14.890 --> 19:16.890
能够分析出这么一个玩意儿的话

19:16.890 --> 19:18.890
这也写错了

19:18.890 --> 19:19.890
fn等于

19:19.890 --> 19:20.890
对对对

19:20.890 --> 19:21.890
那么如果说

19:21.890 --> 19:22.890
我们从数学的角度

19:22.890 --> 19:23.890
能够分析出这么一个玩意儿的话

19:23.890 --> 19:24.890
那么我们再来想

19:24.890 --> 19:25.890
这个玩意儿

19:25.890 --> 19:28.890
如何把它转换成待嘛呢

19:28.890 --> 19:29.890
这样子一想的话

19:29.890 --> 19:30.890
你看这个思维角度

19:30.890 --> 19:31.890
都不一样了

19:31.890 --> 19:32.890
你看没

19:32.890 --> 19:33.890
不同的思维角度

19:33.890 --> 19:36.890
你会得到不同的待嘛

19:36.890 --> 19:38.890
那怎么来写成待嘛呢

19:38.890 --> 19:40.890
待嘛里面不是一个函数

19:40.890 --> 19:42.890
叫方可行吗

19:42.890 --> 19:43.890
对不对

19:43.890 --> 19:45.890
我就写个f函数嘛

19:45.890 --> 19:48.890
你不是要求记n位的值吗

19:48.890 --> 19:49.890
那我就写个fn吗

19:49.890 --> 19:53.580
那么这个fn函数的值

19:53.580 --> 19:54.580
等于多少呢

19:54.580 --> 19:56.580
有这么一个规律

19:56.580 --> 19:57.580
n等于1的时候

19:57.580 --> 19:58.580
结果为1

19:58.580 --> 19:59.580
n等于2的时候

19:59.580 --> 20:00.580
结果为1

20:00.580 --> 20:01.580
到底是不是写个判断

20:01.580 --> 20:03.580
n等于1的时候

20:03.580 --> 20:05.580
或者是n等于2的时候

20:05.580 --> 20:09.900
那么结果就是1

20:09.900 --> 20:11.900
反之

20:11.900 --> 20:12.900
n不是1

20:12.900 --> 20:13.900
也不是2

20:13.900 --> 20:14.900
那么又等于什么呢

20:14.900 --> 20:15.900
fn-1

20:15.900 --> 20:17.900
加上fn-2

20:17.900 --> 20:20.900
对它fn-1

20:20.900 --> 20:22.900
加上fn-2

20:22.900 --> 20:24.900
就是下面一个单

20:24.900 --> 20:26.900
看下面

20:26.900 --> 20:29.400
看这一块

20:29.400 --> 20:30.400
对呀

20:30.400 --> 20:31.400
用不同的思维

20:31.400 --> 20:32.400
你用命运式

20:32.400 --> 20:35.400
编程思维一定是得不到这样的结果的

20:35.400 --> 20:36.400
什么叫命运式编程思维

20:36.400 --> 20:39.400
就是你们以前编程的时候

20:39.400 --> 20:40.400
什么定义什么编辆啊

20:40.400 --> 20:42.400
想的是怎么去写形怀啊

20:42.400 --> 20:43.400
怎么去定义个数组啊

20:43.400 --> 20:45.400
用这种方式去想的话

20:45.400 --> 20:47.400
一定是得不到这样的答案的

20:47.400 --> 20:49.400
但是你用函数式编程的思维去想

20:49.400 --> 20:51.400
就很容易得出这样的答案

20:51.400 --> 20:53.400
这个大家们看上去有点怪

20:53.400 --> 20:54.400
怪在哪呢

20:54.400 --> 20:56.400
这个函数的那一步啊

20:56.400 --> 20:57.400
它调用了自己

20:57.400 --> 20:58.400
对不对

20:58.400 --> 21:00.400
f函数那一步调用了自己

21:00.400 --> 21:01.400
是不是有点怪

21:01.400 --> 21:03.400
那么这个东西

21:03.400 --> 21:05.400
你怎么样才觉得不怪呢

21:05.400 --> 21:07.400
你就必须要去学习这个

21:07.400 --> 21:09.400
执行上下文和执行上下文和执行站了

21:09.400 --> 21:11.400
你就觉得不怪了

21:11.400 --> 21:12.400
那么现在就觉得有点怪

21:12.400 --> 21:13.400
那么现在我告诉你

21:13.400 --> 21:15.400
觉得有点怪没关系

21:15.400 --> 21:17.400
没有关系

21:17.400 --> 21:18.400
你只要觉得

21:18.400 --> 21:21.400
你只要它只要从数学上

21:21.400 --> 21:23.400
逻辑是合理的

21:23.400 --> 21:25.400
那么这个变成代码过后

21:25.400 --> 21:27.400
一定是正确的

21:27.400 --> 21:29.400
从数学逻辑上一定是合理的话

21:29.400 --> 21:31.400
那么到这个代码一定是正确的

21:31.400 --> 21:32.400
你不用去管

21:32.400 --> 21:34.400
所以我们写地规的时候

21:34.400 --> 21:37.400
包括有工作了很多年之后的开发者

21:37.400 --> 21:39.400
写一些复杂的地规

21:39.400 --> 21:40.400
他脑袋都要晕

21:40.400 --> 21:41.400
为什么呢

21:41.400 --> 21:42.400
因为他脑袋里面想的是

21:42.400 --> 21:45.400
命令式变成思维

21:45.400 --> 21:47.400
实际案例有啊

21:47.400 --> 21:48.400
实际案例有啊

21:48.400 --> 21:49.400
以后我们看到一个

21:49.400 --> 21:50.400
练表的结构里面

21:50.400 --> 21:52.400
就有很多种地规啊

21:52.400 --> 21:54.400
如果脑袋里面一直想的是

21:54.400 --> 21:55.400
命令式变成思维

21:55.400 --> 21:58.400
那看到地规一定是蒙的

21:58.400 --> 21:59.400
写地规的时候

21:59.400 --> 22:01.400
他的思维方式都不一样

22:01.400 --> 22:02.400
一定不要去想

22:02.400 --> 22:03.400
他到底是怎么去执行的

22:03.400 --> 22:05.400
不要去想这个问题

22:05.400 --> 22:06.400
他只要逻辑合理

22:06.400 --> 22:07.400
结果一定正确

22:07.400 --> 22:10.970
看一下吧

22:10.970 --> 22:17.930
打开我们的Basecode

22:17.930 --> 22:19.930
这里让我们新鲜一个

22:19.930 --> 22:24.260
一个人去买

22:24.260 --> 22:27.260
这里让我们写个脚本

22:27.260 --> 22:28.260
刚才那个代码的

22:28.260 --> 22:29.260
把它复制一下

22:29.260 --> 22:30.260
这就是求非不拉弃

22:30.260 --> 22:31.260
输列的敌人位

22:31.260 --> 22:35.260
看一下这个函数是正确的

22:35.260 --> 22:36.260
接下来把运行出来

22:36.260 --> 22:40.150
点旧件运行出来

22:40.150 --> 22:41.150
检查

22:41.150 --> 22:42.150
咱们刚才不是写了

22:42.150 --> 22:43.150
这么一个函数吧

22:43.150 --> 22:44.150
F对吧

22:44.150 --> 22:45.150
上半点啊

22:45.150 --> 22:46.150
F我们来看一下

22:46.150 --> 22:48.150
F1是不等于1

22:48.150 --> 22:50.150
F2是不等于1

22:50.150 --> 22:52.150
F3是不等于2

22:52.150 --> 22:54.150
F5是不等于5

22:54.150 --> 22:56.150
F6是不等于8

22:56.150 --> 22:57.150
对不对

22:57.150 --> 22:58.150
所以没问题

22:58.150 --> 22:59.150
他只要有一个

22:59.150 --> 23:01.150
逻辑式合理的结果

23:01.150 --> 23:02.150
一定没问题

23:02.150 --> 23:04.150
好 地规点到这

23:04.150 --> 23:05.150
够了

23:05.150 --> 23:07.150
不影响写单码了

23:08.150 --> 23:09.150
这几天我们会陆续

23:09.150 --> 23:11.150
接触很多的地规场景

23:11.150 --> 23:13.150
有非常非常多的地规场景

23:13.150 --> 23:16.150
特别是在后边求那个

23:16.150 --> 23:18.150
讲到最后一天的时候

23:18.150 --> 23:20.150
那个什么

23:20.150 --> 23:22.150
那个动态规划的时候

23:22.150 --> 23:24.150
地规用的比较多

23:24.150 --> 23:26.150
包括后边我们学书啊 图啊

23:26.150 --> 23:27.150
可能都会用到地规

23:27.150 --> 23:28.150
所以我们今天呢

23:28.150 --> 23:29.150
先开一个头

23:29.150 --> 23:30.150
地规呢

23:30.150 --> 23:31.150
今天的地规还比较简单

23:31.150 --> 23:32.150
后边呢

23:32.150 --> 23:34.150
会陆续的变了一些复杂

23:34.150 --> 23:35.150
咱们慢慢来

23:35.150 --> 23:36.150
一步一步来

23:36.150 --> 23:38.150
好了 只选择选择做铺垫

23:38.150 --> 23:39.150
那么接下来开始进入

23:39.150 --> 23:40.150
正题了

23:40.150 --> 23:42.150
讲我们的今天的内容

23:42.150 --> 23:47.380
内容啊 线性结构

23:47.380 --> 23:48.380
刚才我们说了

23:48.380 --> 23:50.380
什么叫数据结构

23:50.380 --> 23:52.380
研究数据关系的

23:52.380 --> 23:53.380
在数据结构里面

23:53.380 --> 23:55.380
有很多种分类方式

23:55.380 --> 23:57.380
其中呢就比较包括

23:57.380 --> 23:58.380
通过数据

23:58.380 --> 24:00.380
就是通过数据关系来分类

24:00.380 --> 24:01.380
把它分成

24:01.380 --> 24:02.380
线性结构

24:02.380 --> 24:04.380
数 图啊等等结构

24:04.380 --> 24:06.380
那么什么叫线性结构呢

24:06.380 --> 24:07.380
线性结构

24:07.380 --> 24:08.380
指的是这么一种结构

24:08.380 --> 24:12.380
就是有一些并列的数据

24:12.380 --> 24:15.380
他们呢可能会有先后次据

24:15.380 --> 24:17.380
那么这样子组装成了的结构呢

24:17.380 --> 24:18.380
就叫做线性结构

24:18.380 --> 24:20.380
比方说我们的数据

24:20.380 --> 24:22.380
是不是有一大堆数据

24:22.380 --> 24:24.380
比方说我们全班的同学

24:24.380 --> 24:25.380
每个同学是一个数据

24:25.380 --> 24:26.380
每个同学是一个数据

24:26.380 --> 24:27.380
是不是一个线性的数据

24:27.380 --> 24:29.380
他们有个并列关系

24:29.380 --> 24:30.380
那么通过这样并列关系

24:30.380 --> 24:31.380
组装起来的数据呢

24:31.380 --> 24:33.380
就是一个线性结构

24:33.380 --> 24:34.380
还包括什么

24:34.380 --> 24:35.380
电表 站 对列

24:35.380 --> 24:37.380
今天我们讲不到站和对列

24:37.380 --> 24:40.380
终点是讲电表和数据

24:40.380 --> 24:43.380
一个个来 数据

24:43.380 --> 24:45.380
我讲到这个数据的时候呢

24:45.380 --> 24:48.380
讲的是数据结构里面的数据

24:48.380 --> 24:50.380
这是一个抽象概念

24:50.380 --> 24:52.380
它还不是我们GS里面的数据

24:52.380 --> 24:54.380
我们以后会单独说一下

24:54.380 --> 24:55.380
GS里面的数据

24:55.380 --> 24:57.380
它有什么样的不一样

24:57.380 --> 24:59.380
注意啊 现在忘掉GS的数据

24:59.380 --> 25:01.380
我们先来讲一讲这个

25:01.380 --> 25:05.380
数据结构里面的数据是什么回事

25:05.380 --> 25:08.380
在绝大部分语言里边

25:08.380 --> 25:10.380
数据呢 就除了介事

25:10.380 --> 25:12.380
特别是强内形语言

25:12.380 --> 25:15.380
比如加瓦呀 C加加呀 C语言里边

25:15.380 --> 25:16.380
他们的数据呢

25:16.380 --> 25:17.380
就是数据结构里面

25:17.380 --> 25:18.380
说的这种数据

25:18.380 --> 25:19.380
那么这样的数据

25:19.380 --> 25:21.380
是什么样的一个特点呢

25:21.380 --> 25:23.380
它是一块连续的内存空间

25:23.380 --> 25:25.380
你们以后在练书的时候

25:25.380 --> 25:27.380
如果说考这些基本概念的话

25:27.380 --> 25:29.380
它可能会考虑这些数据的特点

25:29.380 --> 25:31.380
它是一块连续的内存空间

25:31.380 --> 25:34.380
它有固定数量的元素组成

25:34.380 --> 25:38.380
那点啊 连续 固定数量

25:38.380 --> 25:40.380
由于它是这样的特点

25:40.380 --> 25:42.380
于是呢 还有下面的基本特征

25:42.380 --> 25:45.380
一个来 首先内存空间是连续的

25:45.380 --> 25:47.380
它不会说在内存里边

25:47.380 --> 25:49.380
数据比较数据有五下

25:49.380 --> 25:51.380
它不会说这三项在一块内存

25:51.380 --> 25:53.380
突然中间隔开了

25:53.380 --> 25:55.380
然后后边两项在另一块内存

25:55.380 --> 25:58.380
不会了 数据一定是连续的

25:58.380 --> 26:00.380
好 数据动的元素

26:00.380 --> 26:01.380
数量是固定的

26:01.380 --> 26:03.380
它不能增加 也不能减少

26:04.380 --> 26:06.380
你在创建一个数组的时候

26:06.380 --> 26:08.380
就必须要指定长度

26:08.380 --> 26:10.380
你看跟介石数组是不是不一样

26:10.380 --> 26:11.380
介石数组的时候

26:11.380 --> 26:13.380
在创建的时候需要指定长度吗

26:13.380 --> 26:15.380
可以指定也可以不指定 对吧

26:15.380 --> 26:16.380
以后可以慢慢加

26:16.380 --> 26:19.380
但是真正的在数据结构里边的数组

26:19.380 --> 26:20.380
是不行的

26:20.380 --> 26:22.380
它必须在创建的时候

26:22.380 --> 26:24.380
就指定长度

26:25.380 --> 26:27.380
那么你看 像 比方 C

26:28.380 --> 26:30.380
是不是这样写的 C 语言

26:31.380 --> 26:35.080
是不是这里要写个长度

26:35.080 --> 26:36.080
对吧 表示一个

26:36.080 --> 26:38.080
创建一个长度为3的数组

26:38.080 --> 26:39.080
那么从此以后

26:39.080 --> 26:41.080
这个数组的长度永远为3

26:41.080 --> 26:42.080
它不能变的

26:42.080 --> 26:44.080
而且数组还有一个特点

26:44.080 --> 26:46.080
就是元素的每个元素

26:46.080 --> 26:48.080
数据里边不是有很多元素吗

26:48.080 --> 26:51.080
每个元素占用的内存大小

26:51.080 --> 26:53.080
是完全一样的

26:53.080 --> 26:54.080
比方它占一个字节

26:54.080 --> 26:56.080
它也占一个字节

26:56.080 --> 26:58.080
所谓的占的大小全部一样

26:58.080 --> 27:00.080
那你想一想

27:01.080 --> 27:03.080
这是个逻辑问题

27:03.080 --> 27:06.080
想一想这样的一个特点

27:06.080 --> 27:07.080
这样一些基本特征

27:07.080 --> 27:09.080
它会衍生出

27:09.080 --> 27:11.080
什么样的特点呢

27:11.080 --> 27:13.080
来 我们一个个看

27:13.080 --> 27:15.080
跟着我示威走

27:15.080 --> 27:19.740
第一个

27:19.740 --> 27:21.740
如果说我要通过一个下标

27:21.740 --> 27:24.740
去找到对应的元素

27:24.740 --> 27:26.740
效率是非常高的

27:26.740 --> 27:27.740
在数组里边

27:27.740 --> 27:28.740
效率非常高

27:28.740 --> 27:31.740
因此数组的便利速度快

27:31.740 --> 27:32.740
啥意思

27:32.740 --> 27:33.740
为什么呢

27:33.740 --> 27:34.740
大家想想为什么

27:34.740 --> 27:36.740
比方说这是一个数组

27:36.740 --> 27:39.740
我们来推演一下

27:39.740 --> 27:41.740
数组是一块连续的空间

27:41.740 --> 27:44.740
因此我只需要知道

27:44.740 --> 27:45.740
数组的第一个下标

27:45.740 --> 27:46.740
它的内存地址

27:46.740 --> 27:47.740
因为我们相当于是

27:47.740 --> 27:49.740
内存空间里边有很多的

27:49.740 --> 27:50.740
你可以把内存空间

27:50.740 --> 27:52.740
想象成一块一块组成的

27:52.740 --> 27:53.740
每一块的一个编号

27:53.740 --> 27:54.740
比方说

27:54.740 --> 27:55.740
内存地址

27:55.740 --> 27:57.740
这个内存地址就是1

27:57.740 --> 27:59.740
假设这个内存地址

27:59.740 --> 28:02.740
是1

28:02.740 --> 28:03.740
每一个空间

28:03.740 --> 28:04.740
数组里边

28:04.740 --> 28:08.560
每一个空间的大小固定

28:08.560 --> 28:09.560
手地址

28:09.560 --> 28:10.560
我记一下

28:10.560 --> 28:11.560
手地址

28:11.560 --> 28:13.560
假设为1

28:13.560 --> 28:14.560
编号嘛

28:14.560 --> 28:15.560
内存地址有个编号

28:15.560 --> 28:16.560
然后呢

28:16.560 --> 28:20.560
每个空间

28:20.560 --> 28:21.560
每个元素

28:21.560 --> 28:22.560
占

28:22.560 --> 28:23.560
假设

28:23.560 --> 28:25.560
占

28:25.560 --> 28:29.640
两个字节

28:29.640 --> 28:30.640
那么你想想

28:30.640 --> 28:31.640
这个空间的编号

28:31.640 --> 28:32.640
是多少是1

28:32.640 --> 28:33.640
那么这个空间编号

28:33.640 --> 28:34.640
是多少

28:34.640 --> 28:35.640
是不是3

28:35.640 --> 28:36.640
这个空间编号

28:36.640 --> 28:37.640
是多少

28:37.640 --> 28:38.640
是不是5

28:38.640 --> 28:39.640
对吧

28:39.640 --> 28:40.640
这个空间编号是7

28:40.640 --> 28:41.640
这个空间编号是9

28:41.640 --> 28:42.640
连续的吧

28:42.640 --> 28:43.640
每个元素占用的大小

28:43.640 --> 28:44.640
一定

28:44.640 --> 28:46.640
这是数值的特点

28:46.640 --> 28:47.640
那么这句话

28:47.640 --> 28:48.640
怎么来理解

28:48.640 --> 28:49.640
通过下标

28:49.640 --> 28:50.640
来找到对应的元素

28:50.640 --> 28:51.640
效率极高

28:51.640 --> 28:53.640
为什么极高呢

28:53.640 --> 28:54.640
假设

28:54.640 --> 28:56.640
我们现在要找下标

28:56.640 --> 28:58.640
找下标为

28:58.640 --> 29:00.640
3的

29:00.640 --> 29:01.640
元素

29:01.640 --> 29:03.640
因为我们在内存里边

29:03.640 --> 29:05.640
只要找到内存的地址

29:05.640 --> 29:06.640
就能够拿到

29:06.640 --> 29:07.640
内存里边的数据

29:07.640 --> 29:08.640
对吧

29:08.640 --> 29:09.640
所以我们要拿到

29:09.640 --> 29:10.640
下标为3的东西

29:10.640 --> 29:11.640
拿到这个东西

29:11.640 --> 29:12.640
我们只需要知道

29:12.640 --> 29:13.640
这个内存的地址

29:13.640 --> 29:14.640
在哪就行了

29:14.640 --> 29:15.640
这些都是计算机

29:15.640 --> 29:16.640
内部去实现的

29:16.640 --> 29:17.640
我们只需要

29:17.640 --> 29:19.640
从逻辑上去理解

29:19.640 --> 29:22.640
还为什么效率高呢

29:22.640 --> 29:24.640
你想一想这个道理

29:24.640 --> 29:27.640
我手地址是已知的

29:27.640 --> 29:28.640
每个空间占用的

29:28.640 --> 29:30.640
大小是已知的

29:30.640 --> 29:31.640
我现在要找到

29:31.640 --> 29:32.640
下标为3

29:32.640 --> 29:33.640
是不是做一个简单的

29:33.640 --> 29:35.640
算数题就完事了

29:35.640 --> 29:39.020
怎么来做这个算数题

29:39.020 --> 29:40.020
想一想

29:40.020 --> 29:43.020
1 3 5 7

29:43.020 --> 29:44.020
怎么来做这个算数题

29:44.020 --> 29:45.020
是不是就是

29:45.020 --> 29:47.020
手地址加上

29:47.020 --> 29:49.020
每个空间占用的字节

29:49.020 --> 29:52.020
诚意下标

29:52.020 --> 29:53.020
是不是一个算数题

29:53.020 --> 29:54.020
就完事了

29:54.020 --> 29:55.020
下标为3

29:55.020 --> 29:56.020
得到的地址是多少

29:56.020 --> 29:57.020
下标为3

29:57.020 --> 29:58.020
得到的地址就是7

29:58.020 --> 29:59.020
对吧

29:59.020 --> 30:00.020
那下标为2呢

30:00.020 --> 30:02.020
得到的地址是不是就是5

30:02.020 --> 30:03.020
一个计算

30:03.020 --> 30:05.020
一个普通的算数运算

30:05.020 --> 30:08.020
瞬间就可以找到这个地址

30:08.020 --> 30:09.020
那么你想想

30:09.020 --> 30:10.020
一个数组如果说很长很长

30:10.020 --> 30:11.020
有一意向

30:11.020 --> 30:13.020
那么这个index

30:13.020 --> 30:45.990
最高是不是9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999

30:45.990 --> 30:48.990
我们有办法去添加和删除数据

30:48.990 --> 30:50.990
为什么呢?因为数组的长度是固定的

30:50.990 --> 30:52.990
你不能添加,你不能加一个

30:52.990 --> 30:54.990
你不能删一个

30:54.990 --> 30:57.990
但是呢,我们可以通过另外一些方式来完成

30:57.990 --> 31:00.990
怎么完成呢?我给大家看一个图

31:05.990 --> 31:07.990
比方说,这是一个数组

31:07.990 --> 31:10.990
我要在它的墨尾加一下

31:10.990 --> 31:12.990
我要在它墨尾加一下

31:12.990 --> 31:14.990
不好意思,加不了

31:14.990 --> 31:17.990
它空间是连续的,而且不能增加,也不能减少

31:17.990 --> 31:20.990
那我怎么办呢?我可以这样做

31:20.990 --> 31:27.290
我可以再建立一个新的数组

31:27.290 --> 31:30.290
建立一个新的空的数组,没有任何东西

31:30.290 --> 31:34.290
长度是原来的数组加一

31:34.290 --> 31:36.290
这是第一步

31:36.290 --> 31:39.290
第二步,把原来的数组每一项

31:39.290 --> 31:41.290
复制过来

31:41.290 --> 31:44.290
复制到新的内存空间

31:44.290 --> 31:48.290
然后在最后一项,加上一个新的内容

31:48.290 --> 31:51.290
你要增加一项,只能这样做

31:51.290 --> 31:55.290
因为每一个数组,它的空间尺寸是不能变的

31:55.290 --> 31:57.290
是不能变化的

31:57.290 --> 31:59.290
所以你要加一项,你只能这样做

31:59.290 --> 32:01.290
建立一个新的数组

32:01.290 --> 32:03.290
那么你想一想,这个内存空间是不是有浪费

32:03.290 --> 32:05.290
我就为了加一项,你搞得这么多

32:05.290 --> 32:08.290
那如果说这个数组很长呢,数组有一万项呢

32:08.290 --> 32:10.290
那这里是不是要搞一万个出来

32:10.290 --> 32:12.290
就为了加一项,看到没

32:12.290 --> 32:14.290
就停到不断的去复制

32:14.290 --> 32:16.290
这是不是数组的缺陷

32:16.290 --> 32:18.290
它虽然是便利数组高

32:18.290 --> 32:20.290
但是呢,如果说你要真的去完成

32:20.290 --> 32:22.290
添加和删除数据

32:22.290 --> 32:25.290
就会增加额外的内存开销和时间开销

32:25.290 --> 32:27.290
内存开销

32:27.290 --> 32:29.290
开销主要发生在新建的数据

32:29.290 --> 32:31.290
比较内山一个数据也是一样

32:31.290 --> 32:32.290
我要把这个删了

32:32.290 --> 32:34.290
那怎么办呢,我叫新建一个数据

32:34.290 --> 32:36.290
它比原来的数据少一项

32:36.290 --> 32:38.290
然后以复制过来

32:38.290 --> 32:40.290
复制过来,它不复制

32:40.290 --> 32:41.290
它复制过来

32:41.290 --> 32:43.290
这样子完成删除的操作

32:43.290 --> 32:45.290
当然你可以在里边

32:45.290 --> 32:47.290
通过一些算法的优化呀

32:47.290 --> 32:49.290
比如说我要增加一个

32:49.290 --> 32:51.290
不用一个空间一个空间增加

32:51.290 --> 32:52.290
我一下增加很多空间

32:52.290 --> 32:54.290
可以通过一些方式来优化

32:54.290 --> 32:55.290
但是呢,总归

32:55.290 --> 32:57.290
会造成内存的浪费

32:57.290 --> 32:59.290
和时间的浪费

32:59.290 --> 33:01.290
所以数组呢,在数据里面的数组

33:01.290 --> 33:04.290
它是不适合做添加和删除的

33:04.290 --> 33:06.290
这不是它的想象

33:06.290 --> 33:09.600
还有什么问题呢

33:09.600 --> 33:11.600
数组需要的空间很大

33:11.600 --> 33:13.600
如果说一个数组

33:13.600 --> 33:15.600
比方说这个数组长度为一万

33:15.600 --> 33:17.600
我要装很多很多的数据

33:17.600 --> 33:19.600
而这个时候呢,你的计算机

33:19.600 --> 33:22.600
可能已经非常非常忙了

33:22.600 --> 33:24.600
它已经在运行很多程序了

33:24.600 --> 33:26.600
那么这个时候内存不足了

33:26.600 --> 33:28.600
它装不下那么多了

33:28.600 --> 33:30.600
这个时候就比较麻烦了

33:30.600 --> 33:32.600
那么怎么跟麻烦法

33:32.600 --> 33:33.600
它跟操作系统有关系

33:33.600 --> 33:35.600
可能一些操作系统会自换内存

33:35.600 --> 33:36.600
会浪费很多空间

33:36.600 --> 33:38.600
因为它要找到连续的空间

33:38.600 --> 33:39.600
它空间可能够

33:39.600 --> 33:40.600
但是它不连续,也不行

33:40.600 --> 33:42.600
比方说空间可能是这个样子的

33:46.980 --> 33:47.980
这个空间被占用了

33:47.980 --> 33:49.980
这个空间,我用这个东西

33:49.980 --> 33:51.980
这个是空显的

33:52.980 --> 33:54.980
我要长度为五的数组

33:54.980 --> 33:58.670
假设长度为五的数组

33:58.670 --> 34:00.670
我们目前的内存空间是这样子

34:00.670 --> 34:08.950
长度呢,倒是有五个

34:08.950 --> 34:11.950
现在空显的有六个

34:11.950 --> 34:13.950
但是我装不下

34:13.950 --> 34:15.950
连续的五个装不下

34:15.950 --> 34:16.950
懂我的意思吧

34:16.950 --> 34:18.950
所以说有的时候在极端情况下

34:18.950 --> 34:20.950
可能还会遇到这样的问题

34:20.950 --> 34:22.950
总之呢,数组有它的优点

34:22.950 --> 34:23.950
有它的缺点

34:23.950 --> 34:25.950
优点就是变点数多快

34:25.950 --> 34:26.950
快得吓死人

34:26.950 --> 34:27.950
那么缺点就是

34:27.950 --> 34:29.950
它不适合做天家山厨

34:29.950 --> 34:32.950
有的时候如果说数组量太大了

34:32.950 --> 34:33.950
会遇到这样的问题

34:33.950 --> 34:37.330
这是数组的这些特点

34:37.330 --> 34:39.330
以后面试起的时候

34:39.330 --> 34:40.330
考一些基本概念的时候

34:40.330 --> 34:41.330
可能会问到这些问题

34:41.330 --> 34:43.330
然后这里我就说回到

34:43.330 --> 34:44.330
介石语言

34:44.330 --> 34:46.330
介石语言还没有真正的数组

34:46.330 --> 34:47.330
没有

34:47.330 --> 34:49.330
在ES6之前

34:49.330 --> 34:50.330
它没有真正意义的数组

34:50.330 --> 34:52.330
我们平时用了介石数组

34:52.330 --> 34:53.330
实际上是一个对象

34:53.330 --> 34:54.330
大家看到过了,那个数组

34:54.330 --> 34:56.330
其实它是一个对象

34:56.330 --> 34:57.330
它是个对象

34:57.330 --> 34:58.330
那个对

34:58.330 --> 35:00.330
对象里不就是一个

35:00.330 --> 35:02.330
R2

35:02.330 --> 35:03.330
随便写个吧

35:03.330 --> 35:04.330
就这个玩意吧

35:04.330 --> 35:05.330
R2

35:05.330 --> 35:06.330
它实际上是个对象

35:06.330 --> 35:08.330
对象的属性0为3

35:08.330 --> 35:09.330
属性1为4

35:09.330 --> 35:11.330
属性2为1

35:11.330 --> 35:12.330
它实际上是个对象

35:12.330 --> 35:14.330
是一个哈希表

35:14.330 --> 35:16.330
但是在ES6之后

35:16.330 --> 35:17.330
它是有真正的数组

35:17.330 --> 35:18.330
ES6之后有了

35:18.330 --> 35:20.330
咱们在ES6的课程里边

35:20.330 --> 35:22.330
会有详细的说

35:22.330 --> 35:23.330
这里不展开了

35:23.330 --> 35:25.330
内容化数在平时我们开发的时候

35:25.330 --> 35:27.330
用的也不多

35:27.330 --> 35:28.330
可能在漏的介石里边

35:28.330 --> 35:29.330
可能会用到

35:29.330 --> 35:32.330
因为目前的ES6之后

35:32.330 --> 35:34.330
就算有内容化数组

35:34.330 --> 35:35.330
真正的数组

35:35.330 --> 35:36.330
但是它只能存数字

35:36.330 --> 35:38.330
因此功能很有限

35:38.330 --> 35:40.330
所以说目前介石

35:40.330 --> 35:41.330
只能说

35:41.330 --> 35:42.330
它具备的是

35:42.330 --> 35:44.330
一个不完善的数组

35:44.330 --> 35:45.330
只有这个内容化数组

35:45.330 --> 35:47.330
以后你们学了ES6之后

35:47.330 --> 35:48.330
就会学习

35:48.330 --> 35:49.330
这是介石的数组

35:49.330 --> 35:50.330
所以说数字都要一块

35:50.330 --> 35:52.330
我们把基本干净过一遍

35:52.330 --> 35:53.330
就OK了

35:53.330 --> 35:55.700
点到介石

35:55.700 --> 35:56.700
重点在下面

35:56.700 --> 35:57.700
练表

35:57.700 --> 35:58.700
这是我们会

35:58.700 --> 35:59.700
今天晚上

35:59.700 --> 36:01.700
很多代码产生在这

36:01.700 --> 36:02.700
因为介石里边

36:02.700 --> 36:04.700
是没有练表的

36:05.700 --> 36:06.700
我们要去

36:06.700 --> 36:08.700
如果说有要练表的话

36:08.700 --> 36:09.700
需要自己写

36:09.700 --> 36:16.380
帮他们看到数组的特点

36:16.380 --> 36:17.380
它有它的优势

36:17.380 --> 36:18.380
也有它的缺陷

36:18.380 --> 36:21.380
那么为了弥补它的缺陷

36:21.380 --> 36:23.380
就搞出了这么一个数据结构

36:23.380 --> 36:25.380
叫练表

36:25.380 --> 36:28.380
练表是什么情况呢

36:28.380 --> 36:29.380
它每个元素

36:29.380 --> 36:32.380
它也是可以存处很多元素

36:32.380 --> 36:33.380
每个元素

36:33.380 --> 36:36.380
它除了存处数据之外

36:36.380 --> 36:38.380
还需要一个额外的内存

36:38.380 --> 36:39.380
因为它每个元素

36:39.380 --> 36:40.380
它有两个内存

36:40.380 --> 36:41.380
一个内存存数据

36:41.380 --> 36:42.380
比如说存一个数字1

36:42.380 --> 36:43.380
存一个制服串

36:43.380 --> 36:45.380
存一个对象都行

36:45.380 --> 36:48.380
然后还有一个内存

36:48.380 --> 36:51.380
这个内存它存的是一个地址

36:51.380 --> 36:55.380
所以说我们之前的那个配置要求

36:55.380 --> 36:56.380
你得会知道一个

36:56.380 --> 36:57.380
指内心和引用内心

36:57.380 --> 36:58.380
还得知道地址

36:58.380 --> 36:59.380
像我们介石里面

36:59.380 --> 37:01.380
对象不就是地址吗

37:01.380 --> 37:02.380
对吧

37:02.380 --> 37:03.380
我们平时写的这个东西

37:03.380 --> 37:04.380
写个ob介

37:04.380 --> 37:05.380
随便写一个

37:05.380 --> 37:06.380
想写一个

37:06.380 --> 37:07.380
那么这个编辖里面存的是

37:07.380 --> 37:09.380
存的是一个内存地址

37:09.380 --> 37:10.380
对吧

37:10.380 --> 37:12.380
这个地址指向这个对象

37:12.380 --> 37:13.380
是这个意思

37:13.380 --> 37:14.380
好

37:14.380 --> 37:15.380
我们看回来

37:15.380 --> 37:17.700
粘表里面

37:17.700 --> 37:18.700
每一个元素

37:18.700 --> 37:20.700
它有两个空间

37:20.700 --> 37:21.700
一个是存自己的数据

37:21.700 --> 37:22.700
先不要去想代码

37:22.700 --> 37:24.700
我们后面会慢慢给大家说代码

37:24.700 --> 37:26.700
然后还有一个内存空间存地址

37:26.700 --> 37:27.700
这个地址有什么用呢

37:27.700 --> 37:30.700
它会指向粘表的下一个

37:30.700 --> 37:31.700
下一个内存空间

37:31.700 --> 37:33.700
下一个内存空间也是一样

37:33.700 --> 37:35.700
有个空间它存自己

37:35.700 --> 37:37.700
有个空间它存地址

37:37.700 --> 37:39.700
这个地址又指向下一个

37:39.700 --> 37:40.700
这个空间也是一样

37:40.700 --> 37:41.700
又指向下一个

37:41.700 --> 37:42.700
那么到摸尾的时候

37:42.700 --> 37:43.700
这个地址没东西了

37:43.700 --> 37:44.700
后面没有东西了

37:44.700 --> 37:46.700
后面没有这个元素了

37:46.700 --> 37:47.700
OK

37:47.700 --> 37:48.700
指向大了

37:48.700 --> 37:51.700
它是这么一种结构

37:51.700 --> 37:53.700
由于它是这种结构

37:53.700 --> 37:56.700
因此你想象了个道理

37:56.700 --> 37:58.700
粘表在内存中

37:58.700 --> 38:01.700
它不要求是连续的

38:01.700 --> 38:03.700
所以可以不要求连续

38:03.700 --> 38:04.700
你看

38:04.700 --> 38:05.700
比方这个地址

38:05.700 --> 38:06.700
这一块空间

38:06.700 --> 38:07.700
跟这一块空间之间

38:07.700 --> 38:08.700
隔了很多东西

38:08.700 --> 38:09.700
中间隔了很多

38:09.700 --> 38:10.700
隔了一大堆

38:10.700 --> 38:11.700
没关系

38:11.700 --> 38:12.700
没关系

38:12.700 --> 38:14.700
因为我找到第一个

38:14.700 --> 38:16.700
我就能通过这个空间的地址

38:16.700 --> 38:17.700
找到下一个空间

38:17.700 --> 38:18.700
对吧

38:18.700 --> 38:19.700
甭管它隔了千山万水

38:19.700 --> 38:20.700
我通过那个地址

38:20.700 --> 38:21.700
是不是能找到

38:21.700 --> 38:22.700
对不对

38:22.700 --> 38:24.700
就有点像那个

38:24.700 --> 38:25.700
有点像你们我

38:25.700 --> 38:26.700
有没有搞过那个

38:26.700 --> 38:27.700
在学校里面

38:27.700 --> 38:28.700
有没有玩过那个

38:28.700 --> 38:29.700
找保障那个游戏

38:29.700 --> 38:30.700
对吧

38:30.700 --> 38:31.700
你找到一个

38:31.700 --> 38:32.700
它可以提供下一个线索

38:32.700 --> 38:33.700
再找到一个

38:33.700 --> 38:34.700
给你提供下一个线索

38:34.700 --> 38:36.700
就这个意思

38:36.700 --> 38:37.700
一个地址只向另一个

38:37.700 --> 38:39.700
它不要求是连续的

38:39.700 --> 38:41.700
而且我们可以看到

38:41.700 --> 38:42.700
在这种结构里边

38:42.700 --> 38:43.700
我们是不是只要找到

38:43.700 --> 38:45.700
第一个节点

38:45.700 --> 38:46.700
我们把每一个元素

38:46.700 --> 38:47.700
叫做一个节点

38:47.700 --> 38:48.700
只要找到第一个节点

38:48.700 --> 38:49.700
是不是可以找到

38:49.700 --> 38:50.700
所有节点呢

38:50.700 --> 38:51.700
对不对

38:51.700 --> 38:52.700
找到第一个

38:52.700 --> 38:53.700
我又可以通过

38:53.700 --> 38:54.700
第一个找到第二个

38:54.700 --> 38:55.700
我又可以通过第二个

38:55.700 --> 38:56.700
找到第三个

38:56.700 --> 38:57.700
就可以找到所有节点

38:57.700 --> 38:58.700
对不对

38:58.700 --> 38:59.700
所以说我们

38:59.700 --> 39:00.700
在单一码里边

39:00.700 --> 39:01.700
或者在逻辑里边

39:01.700 --> 39:02.700
怎么来表示一个链表

39:02.700 --> 39:03.700
你只需要给我

39:03.700 --> 39:04.700
一个节点就够了

39:04.700 --> 39:05.700
你不需要全部给我

39:05.700 --> 39:07.700
你给我一个节点

39:07.700 --> 39:08.700
我就能把整个链

39:08.700 --> 39:09.700
全部找出来

39:09.700 --> 39:10.700
比方说你给我这个节点

39:11.700 --> 39:12.700
你给我这个节点

39:12.700 --> 39:13.700
我就能找到一个链表

39:13.700 --> 39:14.700
哪个链表呢

39:14.700 --> 39:15.700
这个

39:15.700 --> 39:16.700
这个

39:16.700 --> 39:17.700
对吧

39:17.700 --> 39:18.700
就找到这三个

39:18.700 --> 39:19.700
对不对

39:19.700 --> 39:20.700
找不回去

39:20.700 --> 39:21.700
找不回去的

39:21.700 --> 39:22.700
只要单向链表

39:22.700 --> 39:23.700
如果说双向链表

39:23.700 --> 39:24.700
链表的话

39:24.700 --> 39:25.700
它还能找回去

39:25.700 --> 39:26.700
我这里只谈单向链表

39:26.700 --> 39:28.700
它只能找到这三个

39:28.700 --> 39:29.700
你给我这个

39:29.700 --> 39:30.700
我能找到啥

39:30.700 --> 39:31.700
我能找到这个

39:31.700 --> 39:32.700
这个

39:32.700 --> 39:33.700
这个

39:33.700 --> 39:34.700
对不对

39:34.700 --> 39:35.700
是不是这个意思

39:35.700 --> 39:36.700
那么有的时候

39:36.700 --> 39:37.700
我们画图的时候

39:37.700 --> 39:38.700
可能会简略

39:38.700 --> 39:39.700
简略画法

39:39.700 --> 39:40.700
就是这个链表节点

39:40.700 --> 39:41.700
指向下一个

39:41.700 --> 39:42.700
这个指向下一个

39:42.700 --> 39:44.700
它里面有两个类伸空间

39:44.700 --> 39:46.700
好了

39:46.700 --> 39:47.700
来

39:47.700 --> 39:48.700
我们来把这个

39:48.700 --> 39:49.700
道理认识清楚过后

39:49.700 --> 39:50.700
我们来看一下

39:50.700 --> 39:55.780
基于链表的这个特点

39:55.780 --> 39:59.780
它有什么样的一些性质呢

39:59.780 --> 40:02.780
链表的长度是可以变化的

40:02.780 --> 40:04.780
随时可以非常

40:04.780 --> 40:07.780
高效率的增加和删除

40:07.780 --> 40:08.780
所以它插入

40:08.780 --> 40:09.780
增加元素和

40:09.780 --> 40:12.780
删除元素的效率极高

40:12.780 --> 40:14.780
为什么这样说呢

40:14.780 --> 40:15.780
看着啊

40:15.780 --> 40:20.590
比方说这个玩意

40:20.590 --> 40:21.590
这是个链表吧

40:21.590 --> 40:24.590
我要在C和D中

40:24.590 --> 40:26.590
加入一个F节点

40:26.590 --> 40:28.590
怎么办呢

40:28.590 --> 40:30.590
我不需要再去像数组的样子

40:30.590 --> 40:31.590
搞一个新的空间出来

40:31.590 --> 40:32.590
不需要

40:32.590 --> 40:36.590
我只需要去新创建一个F节点

40:36.590 --> 40:37.590
把F节点里面

40:37.590 --> 40:38.590
不是有两个吗

40:38.590 --> 40:39.590
也是一样

40:39.590 --> 40:40.590
每个节点都是有两个东西

40:40.590 --> 40:41.590
一个地址

40:41.590 --> 40:43.590
一个自己的数据

40:43.590 --> 40:44.590
这个节点里面

40:44.590 --> 40:48.590
我只要把它的下一个指向谁

40:48.590 --> 40:52.590
我把它的下一个指向地

40:52.590 --> 40:55.590
然后把C节点指向谁

40:55.590 --> 40:56.590
指向F

40:56.590 --> 40:57.590
这些你看

40:57.590 --> 40:59.590
这些节点的内存空间不动

40:59.590 --> 41:01.590
动都不要动

41:01.590 --> 41:03.590
这个F节点的内存空间在哪

41:03.590 --> 41:04.590
无所谓

41:04.590 --> 41:05.590
随便它在哪

41:05.590 --> 41:06.590
它在这也好

41:06.590 --> 41:07.590
在这也好

41:07.590 --> 41:08.590
无所谓

41:08.590 --> 41:09.590
随便它在哪

41:09.590 --> 41:10.590
是不是都能形成一条列

41:10.590 --> 41:11.590
你看现在从A找到B

41:11.590 --> 41:12.590
B找到C

41:12.590 --> 41:13.590
C就找到F了

41:13.590 --> 41:14.590
F就找到D了

41:14.590 --> 41:16.590
所以增加一个非常简单

41:16.590 --> 41:19.590
然后再看三处

41:19.590 --> 41:21.590
比方说

41:21.590 --> 41:22.590
就刚才这种情况吧

41:22.590 --> 41:24.590
我要三处F节点

41:24.590 --> 41:25.590
怎么三处

41:25.590 --> 41:28.590
一步完成

41:28.590 --> 41:30.590
我只需要把C节点

41:30.590 --> 41:31.590
指向不要再指向F

41:31.590 --> 41:32.590
指向地

41:32.590 --> 41:33.590
完了

41:33.590 --> 41:35.590
这个东西管都不用管它

41:35.590 --> 41:36.590
这个F节点管都不用管它

41:36.590 --> 41:37.590
为什么不用管它呢

41:37.590 --> 41:39.590
因为你从A节点开始

41:39.590 --> 41:41.590
再也找不到F节点了

41:41.590 --> 41:42.590
A找B

41:42.590 --> 41:43.590
B找C

41:43.590 --> 41:44.590
谁找D

41:44.590 --> 41:46.590
F节点是找不到的

41:46.590 --> 41:47.590
那么就感觉上

41:47.590 --> 41:49.590
F节点三处了一样

41:49.590 --> 41:52.590
很多计划机语言

41:52.590 --> 41:53.590
它都有垃圾回收

41:53.590 --> 41:54.590
叫长能介石也有

41:54.590 --> 41:56.590
它发现一个东西找不到了

41:56.590 --> 41:58.590
它就自动给它回收掉了

41:58.590 --> 42:00.590
自动给它三处掉了

42:00.590 --> 42:01.590
是不是非常简单

42:01.590 --> 42:03.590
三处和新增

42:03.590 --> 42:04.590
是极其简单的

42:04.590 --> 42:07.590
在电表里边

42:07.590 --> 42:10.590
这个特点

42:10.590 --> 42:12.590
它有什么不好的电表

42:12.590 --> 42:13.590
它不好的地方在于

42:13.590 --> 42:14.590
它每一个元素

42:14.590 --> 42:16.590
它有两个内存

42:16.590 --> 42:17.590
是不是会增加

42:17.590 --> 42:19.590
额外的内存开销

42:19.590 --> 42:21.590
肯定用额外的内存开销

42:21.590 --> 42:23.590
还有什么不好呢

42:23.590 --> 42:25.590
它便利效率低

42:25.590 --> 42:27.590
比方说

42:27.590 --> 42:28.590
这个电表

42:28.590 --> 42:30.590
我要找到节点D

42:30.590 --> 42:31.590
怎么办呢

42:31.590 --> 42:33.590
我只能从A开始

42:33.590 --> 42:34.590
因为我们刚才说了

42:34.590 --> 42:35.590
表示一个电表

42:35.590 --> 42:36.590
就告诉它一个节点就行了

42:36.590 --> 42:38.590
那么我们就用A节点来表示

42:38.590 --> 42:39.590
一个电表

42:39.590 --> 42:40.590
因为给了A节点

42:40.590 --> 42:41.590
就能找到所有的节点

42:41.590 --> 42:42.590
那么我给了A节点过来

42:42.590 --> 42:44.590
我要找D

42:44.590 --> 42:45.590
在数组里边

42:45.590 --> 42:47.590
说一个公式就出来了

42:47.590 --> 42:48.590
数组里边是一个公式

42:48.590 --> 42:50.590
一个数学运算就出来了

42:50.590 --> 42:51.590
在电表里面不行

42:51.590 --> 42:54.590
因为它的内存空间不连续

42:54.590 --> 42:56.590
那怎么办呢

42:56.590 --> 42:57.590
你只能从A找B

42:57.590 --> 42:59.590
B找C

42:59.590 --> 43:00.590
C找D

43:00.590 --> 43:02.590
终于把它找到了

43:02.590 --> 43:04.590
以后我们会写这样的代法

43:04.590 --> 43:07.590
它的便利速度是比较慢的

43:07.590 --> 43:10.590
这是它电表的这么一些特点

43:10.590 --> 43:11.590
这一块

43:11.590 --> 43:13.590
我们讲了一大堆理论

43:13.590 --> 43:14.590
这些概念

43:14.590 --> 43:20.780
听懂的话就可以

43:20.780 --> 43:21.780
还可以

43:21.780 --> 43:23.780
还可以吧

43:23.780 --> 43:24.780
好

43:24.780 --> 43:26.780
既能看见这种清楚了

43:26.780 --> 43:27.780
那咱们剩下的东西

43:27.780 --> 43:29.780
就全是代码了

43:29.780 --> 43:30.780
来吧

43:30.780 --> 43:31.780
今天就是我们七道题

43:31.780 --> 43:33.780
也是你们下来的作业

43:33.780 --> 43:34.780
也是咱们课的上来写的代码

43:34.780 --> 43:35.780
你光听课

43:35.780 --> 43:36.780
听懂了

43:36.780 --> 43:37.780
你不去写

43:37.780 --> 43:39.780
也是容易出现幻觉

43:39.780 --> 43:41.780
一定要去写

43:41.780 --> 43:42.780
首先第一个问题

43:42.780 --> 43:44.780
如何来表示一个电表

43:44.780 --> 43:47.780
在我们的代码里面

43:47.780 --> 43:54.940
如何来表示一个电表

43:54.940 --> 43:56.940
我们可以用一个对象

43:56.940 --> 43:57.940
来表示电表

43:57.940 --> 43:59.940
对象里面有两个

43:59.940 --> 44:00.940
在介石里面

44:00.940 --> 44:01.940
有两个属性

44:01.940 --> 44:03.940
一个属性来存

44:03.940 --> 44:04.940
存它的数据

44:04.940 --> 44:05.940
随便什么数据

44:05.940 --> 44:06.940
字不算也行

44:06.940 --> 44:07.940
数字也行

44:07.940 --> 44:08.940
随便它

44:08.940 --> 44:10.940
另外一个

44:10.940 --> 44:12.940
就是属性的

44:12.940 --> 44:13.940
来存它的地址

44:13.940 --> 44:14.940
下一个地址

44:14.940 --> 44:15.940
懂了意思吧

44:15.940 --> 44:16.940
也就是说

44:16.940 --> 44:17.940
我们在介石里面

44:17.940 --> 44:20.940
可以用一个漏的对象

44:20.940 --> 44:22.940
对象里面有两个属性

44:22.940 --> 44:23.940
来表示一个节点

44:23.940 --> 44:24.940
那么怎么写呢

44:24.940 --> 44:25.940
我们可以写个

44:25.940 --> 44:26.940
逗招函数

44:28.940 --> 44:29.940
你给我一个值

44:29.940 --> 44:31.940
value

44:31.940 --> 44:33.940
啥意思

44:33.940 --> 44:35.940
把这个value给我

44:35.940 --> 44:36.940
好

44:36.940 --> 44:37.940
然后我这里给你

44:37.940 --> 44:38.940
创建一个对象

44:38.940 --> 44:39.940
对象里面的属性value

44:39.940 --> 44:40.940
就等于你给我

44:40.940 --> 44:42.940
负责这个value

44:42.940 --> 44:44.940
对象的那个时程

44:44.940 --> 44:46.940
就是它下一个节点

44:46.940 --> 44:48.940
地址就等于漏

44:48.940 --> 44:49.940
默认为漏

44:49.940 --> 44:50.940
这就是一个链表

44:50.940 --> 44:52.940
这就是一个链表节点

44:52.940 --> 44:53.940
好

44:53.940 --> 44:54.940
那么来尝试一下

44:54.940 --> 44:55.940
这个链表节点

44:55.940 --> 44:57.940
真的能够得到一个链表吗

44:57.940 --> 44:59.940
我来试一下吧

44:59.940 --> 45:01.940
我们创建一个节点

45:01.940 --> 45:02.940
6一个漏的

45:02.940 --> 45:03.940
对吧

45:03.940 --> 45:04.940
给它存一个字不算

45:04.940 --> 45:05.940
它的数据

45:05.940 --> 45:06.940
数据随便

45:06.940 --> 45:07.940
字不算

45:07.940 --> 45:08.940
一个数字都可以

45:08.940 --> 45:09.940
随便存什么数据

45:09.940 --> 45:10.940
就跟数据一样

45:10.940 --> 45:11.940
数据里面随便

45:11.940 --> 45:12.940
可以存什么数据

45:12.940 --> 45:13.940
那么这里也是一样

45:13.940 --> 45:15.940
存进去

45:15.940 --> 45:16.940
于是

45:16.940 --> 45:17.940
我们现在就建立了个节点了

45:17.940 --> 45:18.940
对吧

45:18.940 --> 45:19.940
现在什么节点呢

45:19.940 --> 45:21.940
就建立了这么一个节点

45:21.940 --> 45:23.940
给它复制一下

45:23.940 --> 45:24.940
就建立这么一个节点

45:24.940 --> 45:25.940
对吧

45:25.940 --> 45:27.940
字不算存了一个a

45:27.940 --> 45:28.940
然后一个地址

45:28.940 --> 45:29.940
地址指向谁

45:29.940 --> 45:30.940
指向now

45:30.940 --> 45:31.940
没有地址

45:31.940 --> 45:32.940
好 接下来

45:32.940 --> 45:33.940
我们再建立一个节点b

45:33.940 --> 45:35.940
6一个漏的b

45:35.940 --> 45:36.940
同样的方式

45:36.940 --> 45:37.940
我们可以建一个节点c

45:37.940 --> 45:41.090
节点d

45:41.090 --> 45:42.090
c

45:42.090 --> 45:43.090
d

45:43.090 --> 45:45.090
就建立了四个节点

45:45.090 --> 45:46.090
那么目前这四个节点

45:46.090 --> 45:47.090
是孤立的对吧

45:47.090 --> 45:50.090
abcd

45:50.090 --> 45:55.490
bcd

45:55.490 --> 45:57.490
这四个节点是孤立的

45:57.490 --> 45:59.490
那如果把它们连在一起呢

45:59.490 --> 46:01.490
我们就可以用这种方式

46:01.490 --> 46:03.490
adder next

46:03.490 --> 46:05.490
adder下一个节点

46:05.490 --> 46:06.490
为什么呢

46:06.490 --> 46:07.490
为b

46:07.490 --> 46:08.490
那么这样子一来

46:08.490 --> 46:09.490
是不是把b这个对象

46:09.490 --> 46:10.490
就这个对象

46:10.490 --> 46:11.490
它的地址

46:11.490 --> 46:12.490
这个是对象吧

46:12.490 --> 46:13.490
对象的地址

46:13.490 --> 46:14.490
复制给某一个属性

46:14.490 --> 46:15.490
那么就相当于

46:15.490 --> 46:16.490
把这个对象的地址

46:16.490 --> 46:17.490
复制给谁

46:17.490 --> 46:18.490
复制给这个对象的

46:18.490 --> 46:19.490
next

46:19.490 --> 46:20.490
这个属性

46:20.490 --> 46:21.490
能看到吗

46:21.490 --> 46:23.490
所以说就相当于这样的

46:23.490 --> 46:25.490
它这个属性next

46:25.490 --> 46:26.490
指向谁

46:26.490 --> 46:27.490
指向这个玩意儿

46:27.490 --> 46:28.490
对吧

46:28.490 --> 46:29.490
就是不是指向过来了

46:29.490 --> 46:30.490
那么同样的方式

46:30.490 --> 46:31.490
我们是不是可以来

46:31.490 --> 46:32.490
b点next

46:32.490 --> 46:33.490
等于什么c

46:33.490 --> 46:34.490
c点next

46:34.490 --> 46:35.490
等于什么d

46:35.490 --> 46:36.490
不就完了吗

46:36.490 --> 46:38.490
就把整个练表

46:38.490 --> 46:39.490
表示出来了

46:39.490 --> 46:40.490
好

46:40.490 --> 46:41.490
我们运行看一下

46:41.490 --> 46:43.490
点牛点检查

46:43.490 --> 46:45.490
控制台就帮我们看一下

46:45.490 --> 46:46.490
怎么来表示整个练表呢

46:46.490 --> 46:47.490
我们刚才说了

46:47.490 --> 46:48.490
表示整个练表很简单

46:48.490 --> 46:49.490
你用一个节点

46:49.490 --> 46:50.490
就可以表示整个练表

46:50.490 --> 46:52.490
比方我用个节点a

46:52.490 --> 46:54.490
这就是整个练表

46:54.490 --> 46:55.490
你看整个练表

46:55.490 --> 46:56.490
我们可以看到

46:56.490 --> 46:57.490
节点a对吧

46:57.490 --> 46:58.490
它的职位a

46:58.490 --> 46:59.490
下一个是谁呢

46:59.490 --> 47:01.490
你看下一个是不是又是个节点

47:01.490 --> 47:02.490
next

47:02.490 --> 47:03.490
就是一个节点b

47:03.490 --> 47:04.490
b的下一个

47:04.490 --> 47:05.490
你看是不是节点c

47:05.490 --> 47:06.490
c的下一个

47:06.490 --> 47:08.490
是不是节点d

47:08.490 --> 47:09.490
d的下一个

47:10.490 --> 47:11.490
你看就是

47:11.490 --> 47:12.490
所以通过a

47:12.490 --> 47:13.490
能够找到整个练表

47:13.490 --> 47:14.490
那么同样的

47:14.490 --> 47:16.490
我如果说写个b呢

47:16.490 --> 47:18.490
大家它就找不到a了

47:18.490 --> 47:19.490
你看b这个节点

47:19.490 --> 47:21.490
b的下一个是c

47:21.490 --> 47:22.490
c的下一个是d

47:22.490 --> 47:23.490
d的下一个没了

47:23.490 --> 47:25.490
这就是节点的

47:25.490 --> 47:27.490
就是这个练表的

47:27.490 --> 47:28.490
这种表达方式

47:28.490 --> 47:30.490
我们后边会学习数

47:30.490 --> 47:31.490
会学习图

47:31.490 --> 47:33.490
都是类似的表达方式

47:33.490 --> 47:34.490
这种表达方式要会

47:34.490 --> 47:36.490
能听懂的话就得一

47:44.140 --> 47:45.140
还有点感冒

47:45.140 --> 47:49.540
抽着再卖点啊

47:49.540 --> 47:50.540
行

47:50.540 --> 47:53.170
好

47:53.170 --> 47:55.170
那么接下来就是这7道题

47:55.170 --> 47:57.170
这7道题研究的是啥呢

47:57.170 --> 47:59.170
就是练表这个数据结构

47:59.170 --> 48:00.170
已经出来了

48:00.170 --> 48:02.170
它里面可以玩哪些

48:02.170 --> 48:03.170
稍操作呢

48:03.170 --> 48:04.170
各种操作怎么来玩呢

48:04.170 --> 48:06.170
它让你每一道题呢

48:06.170 --> 48:07.170
写函数去实现

48:07.170 --> 48:08.170
第一个

48:08.170 --> 48:10.170
编地打印

48:10.170 --> 48:12.170
啥意思呢

48:12.170 --> 48:13.170
这不是一个练表吗

48:13.170 --> 48:14.170
出来了吗对吧

48:14.170 --> 48:16.170
希望你呢写一个函数

48:16.170 --> 48:17.170
这个函数的名字呢

48:17.170 --> 48:19.170
叫做print

48:19.170 --> 48:21.170
你给我一个啥呢

48:21.170 --> 48:23.170
你给我一个结点

48:23.170 --> 48:24.170
练表吧

48:24.170 --> 48:25.170
用一个结点是不是

48:25.170 --> 48:27.170
可以代表练表

48:27.170 --> 48:28.170
刚才说了对吧

48:28.170 --> 48:29.170
你给我一个结点

48:29.170 --> 48:31.170
再表示整个练表

48:31.170 --> 48:32.170
我要把整个练表

48:32.170 --> 48:34.170
全部打印出来

48:34.170 --> 48:40.140
打印整个练表

48:40.140 --> 48:42.140
这些事情特别好玩

48:42.140 --> 48:44.140
来吧

48:44.140 --> 48:47.140
怎么来打印整个练表

48:48.140 --> 48:49.140
怎么来打印

48:49.140 --> 48:50.140
咦咱们可以

48:50.140 --> 48:52.140
是不是可以这样子来做

48:52.140 --> 48:54.140
你给了我一个结点对吧

48:54.140 --> 48:56.140
我先把这个结点打印一下

48:56.140 --> 49:00.220
如果说这个结点

49:00.220 --> 49:02.220
比方这样子

49:02.220 --> 49:03.220
我写出来

49:03.220 --> 49:06.220
其实就是一个循环对不对

49:06.220 --> 49:08.220
n等名字

49:08.220 --> 49:09.220
我先把这个结点

49:09.220 --> 49:11.220
复制给n

49:11.220 --> 49:15.220
然后呢我判断一下

49:15.220 --> 49:17.220
歪我循环

49:17.220 --> 49:20.220
n是不是存在

49:20.220 --> 49:22.220
这个结点是不是存在

49:22.220 --> 49:25.220
那么如果说存在的话

49:25.220 --> 49:27.220
我就把这个结点打印出来

49:27.220 --> 49:29.220
是不是结点的n.value

49:29.220 --> 49:30.220
对吧

49:30.220 --> 49:31.220
结点里面的值吗

49:31.220 --> 49:33.220
它保存了数据

49:33.220 --> 49:34.220
看这儿啊

49:34.220 --> 49:35.220
你给我一个结点

49:35.220 --> 49:36.220
我判断一下

49:36.220 --> 49:37.220
这个结点的

49:37.220 --> 49:38.220
这个结点是不是存在

49:38.220 --> 49:39.220
存在的话

49:39.220 --> 49:41.220
我就打印它的值

49:41.220 --> 49:43.220
打印完了过后呢

49:43.220 --> 49:45.220
你看我这个画的度

49:45.220 --> 49:46.220
慢一点

49:46.220 --> 49:47.220
n在这儿对吧

49:47.220 --> 49:49.220
n一开始在这儿

49:49.220 --> 49:50.220
我看一下这个

49:50.220 --> 49:51.220
这个结点有没有值

49:51.220 --> 49:53.660
有值

49:53.660 --> 49:54.660
好这儿吧

49:54.660 --> 49:55.660
好这儿

49:55.660 --> 49:56.660
n在这儿

49:56.660 --> 49:57.660
看一下这个结点有没有值

49:57.660 --> 49:58.660
有值

49:58.660 --> 49:59.660
把它打印出来

49:59.660 --> 50:00.660
打印出来了没完

50:00.660 --> 50:03.660
我是把这个结点的下一个

50:03.660 --> 50:05.660
重新复制给n

50:05.660 --> 50:06.660
对不对

50:06.660 --> 50:07.660
你看啊

50:07.660 --> 50:10.660
我又把这个结点的下一个

50:10.660 --> 50:13.660
是不是重新复制给n

50:13.660 --> 50:14.660
那么这样子是不是

50:14.660 --> 50:15.660
进入下一次循环

50:15.660 --> 50:16.660
n还是有值

50:16.660 --> 50:17.660
还是有值

50:17.660 --> 50:18.660
是不是打印b

50:18.660 --> 50:19.660
对不对

50:19.660 --> 50:20.660
打印b

50:20.660 --> 50:21.660
打印完了过后

50:21.660 --> 50:25.300
我又把n的下一个复制给n

50:25.300 --> 50:27.300
是不是又打印c

50:27.300 --> 50:29.300
又把n的下一个复制给n

50:29.300 --> 50:31.300
是不是打印d

50:31.300 --> 50:33.300
然后又把n的下一个复制给n

50:33.300 --> 50:34.300
是不是没了

50:34.300 --> 50:36.300
这个时候n是不是闹

50:36.300 --> 50:38.300
循环是不是为空

50:38.300 --> 50:39.300
判断为假

50:39.300 --> 50:40.300
进不了循环了

50:40.300 --> 50:42.300
循环结束

50:42.300 --> 50:44.300
是不是打印整个链表了

50:44.300 --> 50:45.300
好咱们来试一下啊

50:45.300 --> 50:46.300
print

50:46.300 --> 50:47.300
这里传啥

50:47.300 --> 50:49.300
传a吧

50:49.300 --> 50:51.300
就是把a传进去可以了

50:51.300 --> 50:52.300
a传进去

50:52.300 --> 50:54.300
然后就表示整个链表

50:54.300 --> 50:55.300
看一下能不能打印出来

50:55.300 --> 50:56.300
删新

50:56.300 --> 50:57.300
abcd

50:57.300 --> 50:58.300
是不是出来了

50:58.300 --> 50:59.300
好

50:59.300 --> 51:00.300
这个代码应该能看懂啊

51:00.300 --> 51:01.300
这个代码

51:01.300 --> 51:02.300
这个代码并不难啊

51:02.300 --> 51:07.300
能看懂吗

51:07.300 --> 51:08.300
很好啊

51:08.300 --> 51:09.300
很好

51:09.300 --> 51:11.300
因为同样给你影响到地规了

51:11.300 --> 51:12.300
对吧

51:12.300 --> 51:13.300
好

51:13.300 --> 51:14.300
然后我们这里

51:14.300 --> 51:15.300
刚才看a对吧

51:15.300 --> 51:16.300
那么这里写b呢

51:16.300 --> 51:17.300
是一样的

51:17.300 --> 51:18.300
把b传进去

51:18.300 --> 51:19.300
打印什么bcd

51:19.300 --> 51:20.300
对不对

51:20.300 --> 51:21.300
你传什么节点还打印

51:21.300 --> 51:22.300
从那个节点开始去找

51:22.300 --> 51:23.300
对吧

51:23.300 --> 51:24.300
打印bcd

51:25.300 --> 51:26.300
好

51:26.300 --> 51:27.300
那么想想啊

51:27.300 --> 51:28.300
咱们

51:28.300 --> 51:30.300
这里还有没有更好的写法了

51:30.300 --> 51:32.300
这是只是一种循环的写法

51:32.300 --> 51:34.300
老实的写法

51:34.300 --> 51:35.300
这个代码我就删了

51:35.300 --> 51:36.300
这个代码没什么好说的了

51:36.300 --> 51:37.300
非常简单

51:37.300 --> 51:39.300
还有没有更好的写法呢

51:39.300 --> 51:40.300
来看一下

51:40.300 --> 51:41.300
我们用地规的方式

51:41.300 --> 51:43.300
看能不能写

51:43.300 --> 51:45.300
地规的方式就

51:45.300 --> 51:46.300
特别粗暴了

51:46.300 --> 51:47.300
地规的方式

51:47.300 --> 51:49.300
怎么来分析这个问题的

51:49.300 --> 51:50.300
我要打印一个

51:50.300 --> 51:51.300
它就不是打印整个链表了

51:51.300 --> 51:52.300
对吧

51:52.300 --> 51:54.300
链表是由节点组成的

51:54.300 --> 51:56.300
我把链表分

51:56.300 --> 51:57.300
分割成一个一个的节点

51:57.300 --> 51:59.300
我就考虑打印我这个节点

51:59.300 --> 52:01.300
打印完我这个

52:01.300 --> 52:02.300
打印后边

52:02.300 --> 52:03.300
对不对

52:03.300 --> 52:05.300
所以用地规的方式来做的话

52:05.300 --> 52:07.300
只存在这么一个问题

52:07.300 --> 52:10.670
打印自己

52:10.670 --> 52:11.670
打印

52:11.670 --> 52:13.670
打印下一个

52:13.670 --> 52:16.370
好

52:16.370 --> 52:17.370
首先能不能打印自己呢

52:17.370 --> 52:18.370
能

52:18.370 --> 52:19.370
如果说判断一下

52:19.370 --> 52:21.370
弄得有值的时候

52:21.370 --> 52:22.370
如果说你没有值的话

52:22.370 --> 52:23.370
没有值的话

52:23.370 --> 52:24.370
那么说明

52:24.370 --> 52:25.370
节点都没了对吧

52:25.370 --> 52:26.370
我怎么打印的

52:26.370 --> 52:27.370
没法打印

52:27.370 --> 52:29.370
如果说没有节点

52:29.370 --> 52:31.370
没有节点

52:31.370 --> 52:32.370
无法打印

52:32.370 --> 52:35.370
这个逻辑没问题吧

52:35.370 --> 52:36.370
没有节点无法打印

52:36.370 --> 52:38.370
有节点的话

52:38.370 --> 52:39.370
打印自己边

52:39.370 --> 52:40.370
弄得别白的

52:40.370 --> 52:42.370
打印下边

52:42.370 --> 52:43.370
自己是不是打印完了

52:43.370 --> 52:45.370
打印完自己过后呢

52:45.370 --> 52:46.370
打印下一个

52:46.370 --> 52:47.370
打印下一个

52:47.370 --> 52:49.370
是不是又是重复了逻辑

52:49.370 --> 52:51.370
就完全是重复了逻辑

52:51.370 --> 52:52.370
什么吧

52:54.370 --> 52:58.640
就没有循环了

52:58.640 --> 52:59.640
可以吗

52:59.640 --> 53:00.640
我们先试一下

53:00.640 --> 53:02.640
说ABCD就出来了

53:02.640 --> 53:03.640
对不对

53:03.640 --> 53:04.640
我们今天呢

53:04.640 --> 53:07.640
要能够汇写这些简单的地规

53:07.640 --> 53:08.640
后边的地规场景

53:08.640 --> 53:10.640
会逐渐的变得复杂

53:10.640 --> 53:14.340
今天我们试一个开头

53:14.340 --> 53:15.340
你看啊

53:15.340 --> 53:18.340
他这个东西是怎么试路呢

53:18.340 --> 53:19.340
我甭管这个电表有多长

53:19.340 --> 53:21.340
我官都不管

53:21.340 --> 53:22.340
你不是打印节点吗

53:22.340 --> 53:23.340
我就打印自己

53:23.340 --> 53:24.340
打印自己

53:24.340 --> 53:26.340
打印后边的逻辑是一样的

53:26.340 --> 53:27.340
对吧

53:27.340 --> 53:28.340
打印自己和后边

53:28.340 --> 53:30.340
是不是就把整个打印完了

53:30.340 --> 53:31.340
打印自己和后边

53:31.340 --> 53:32.340
那么打印后边的逻辑

53:32.340 --> 53:33.340
也是一样的

53:33.340 --> 53:35.340
打印自己和后边

53:35.340 --> 53:36.340
那么打印后边的逻辑

53:36.340 --> 53:37.340
也是一样的

53:37.340 --> 53:38.340
打印自己和后边

53:38.340 --> 53:40.340
这就是地规的试路

53:40.340 --> 53:43.340
打印自己和后边

53:43.340 --> 53:45.340
看懂没

53:45.340 --> 53:46.340
有点不适应没关系

53:46.340 --> 53:48.340
慢慢去体会

53:48.340 --> 53:50.340
这打印整个电表

53:50.340 --> 53:54.950
第一个

53:54.950 --> 53:55.950
插件

53:55.950 --> 53:56.950
插件以后完了再说吧

53:56.950 --> 53:57.950
我这插件没有

53:57.950 --> 53:59.950
没安装多少插件

53:59.950 --> 54:01.950
还穿了个小霸王

54:01.950 --> 54:03.950
这个玩意儿还是那个

54:03.950 --> 54:06.950
还是你们老薛给我推荐的

54:06.950 --> 54:10.650
我毫不猶豫下载下来了

54:10.650 --> 54:12.650
这是打印电表

54:12.650 --> 54:14.650
好像一个

54:14.650 --> 54:18.600
获取电表的长度

54:18.600 --> 54:20.600
比方说我们这里要写的函数

54:20.600 --> 54:21.600
搞不信

54:21.600 --> 54:23.600
gasnance

54:23.600 --> 54:24.600
你给我一个电表

54:24.600 --> 54:25.600
电表就是一个节点

54:25.600 --> 54:27.600
一个节点可以代表整个电表

54:27.600 --> 54:31.980
获取电表的

54:31.980 --> 54:34.980
电表的长度

54:34.980 --> 54:36.980
我们想一想

54:36.980 --> 54:37.980
可以一开始用地规来想

54:37.980 --> 54:38.980
今天晚上有很多地规

54:38.980 --> 54:41.980
要把地规一定要好好练一下

54:41.980 --> 54:49.420
获取电表的长度怎么来获取

54:49.420 --> 54:50.420
怎么来获取呢

54:50.420 --> 54:52.420
你可以参考一下这个东西

54:52.420 --> 54:54.420
参考一下这个东西

54:54.420 --> 54:57.420
打印自己和后边的

54:57.420 --> 55:00.740
那电表的长度怎么获取呢

55:00.740 --> 55:04.050
我们可以用这种方式

55:04.050 --> 55:05.050
电表的长度

55:05.050 --> 55:07.050
你给了我一个节点

55:07.050 --> 55:08.050
你不要看上面

55:08.050 --> 55:11.050
你给了我一个节点

55:11.050 --> 55:13.050
我要通过这个节点

55:13.050 --> 55:15.050
去找整个电表的长度

55:15.050 --> 55:16.050
我可以用循环

55:16.050 --> 55:17.050
但是我不打算用循环

55:17.050 --> 55:20.050
循环的方式你们自己去写

55:20.050 --> 55:21.050
那我怎么来想这个问题呢

55:21.050 --> 55:22.050
你给了我一个节点

55:22.050 --> 55:23.050
那这一个节点

55:23.050 --> 55:25.050
要不要算长度呢

55:25.050 --> 55:26.050
这个节点要不要算长度

55:26.050 --> 55:28.050
那得算吧

55:28.050 --> 55:29.050
那有两种情况呗

55:29.050 --> 55:30.050
这个节点有没有

55:30.050 --> 55:31.050
那万一你给我一个空节点的

55:31.050 --> 55:32.050
万一给过的节点是这个玩意

55:32.050 --> 55:34.050
是个空节点的

55:34.050 --> 55:35.050
那就没有长度对吧

55:35.050 --> 55:36.050
所以说我这里要看到

55:36.050 --> 55:38.050
要看到一个特殊的情况

55:38.050 --> 55:40.050
漏的有没有

55:40.050 --> 55:41.050
有没有给我节点

55:41.050 --> 55:42.050
没有给我节点

55:42.050 --> 55:44.050
ok 那就是0

55:44.050 --> 55:46.050
对吧 长度就是0

55:46.050 --> 55:48.050
没有节点

55:48.050 --> 55:51.050
长度为0

55:51.050 --> 55:53.050
那有节点呢

55:53.050 --> 55:54.050
你如果说给了我节点呢

55:54.050 --> 55:56.050
你给了我一个节点

55:56.050 --> 55:57.050
那长度是怎么呢

55:57.050 --> 55:59.050
那这个节点得算一个长度吧

55:59.050 --> 56:00.050
那是不是1

56:00.050 --> 56:02.050
是不是1

56:02.050 --> 56:03.050
加上

56:03.050 --> 56:06.050
后边链表的长度

56:06.050 --> 56:08.680
1

56:08.680 --> 56:10.680
加上后边链表的长度

56:10.680 --> 56:12.680
那是不是这个代表就写出来了

56:12.680 --> 56:14.680
1

56:14.680 --> 56:18.680
加上

56:18.680 --> 56:19.680
后边链表是不是

56:19.680 --> 56:20.680
0的代表就会代替

56:20.680 --> 56:21.680
因为链表只要一个节点

56:21.680 --> 56:22.680
就会代替链表

56:22.680 --> 56:23.680
对吧

56:23.680 --> 56:24.680
后边这个节点

56:24.680 --> 56:25.680
是不是代替

56:25.680 --> 56:26.680
后边整个链表

56:26.680 --> 56:28.680
你把这个节点传进去

56:28.680 --> 56:29.680
是不是

56:29.680 --> 56:31.680
加上你自己就完成了

56:31.680 --> 56:33.680
你看这个逻辑

56:33.680 --> 56:38.380
get length

56:38.380 --> 56:40.380
A传进去

56:40.380 --> 56:43.750
小心

56:43.750 --> 56:44.750
get length

56:44.750 --> 56:45.750
A传进去

56:45.750 --> 56:47.750
长度为4

56:47.750 --> 56:49.750
get length B传进去

56:49.750 --> 56:51.750
长度为3

56:51.750 --> 56:52.750
你懂它怎么运

56:52.750 --> 56:54.750
你懂它怎么运行的吗

56:54.750 --> 56:55.750
你看一看

56:55.750 --> 56:57.750
如果说我把D传进去

56:57.750 --> 56:58.750
我把D传进去

56:58.750 --> 57:00.750
get length D传进去

57:01.750 --> 57:02.750
D传进去

57:02.750 --> 57:03.750
是1

57:03.750 --> 57:04.750
为什么是1

57:04.750 --> 57:05.750
因为是1

57:05.750 --> 57:07.750
加上后边链表的长度

57:07.750 --> 57:08.750
后边链表是不是

57:08.750 --> 57:09.750
nau

57:09.750 --> 57:10.750
nau的长度是0

57:11.750 --> 57:12.750
nau的长度是0

57:12.750 --> 57:13.750
对吧

57:13.750 --> 57:14.750
比如1加0

57:14.750 --> 57:15.750
是不是1

57:15.750 --> 57:17.750
于是这个链表的长度为1

57:17.750 --> 57:19.750
那么我把C传进去的时候

57:19.750 --> 57:20.750
你想想

57:20.750 --> 57:21.750
我把C传进去的时候

57:21.750 --> 57:24.750
是不是1加上后边链表的长度

57:24.750 --> 57:25.750
后边链表的长度

57:25.750 --> 57:26.750
是不是我刚才算过了

57:26.750 --> 57:27.750
对不对

57:27.750 --> 57:29.750
它用同样的方式算得出来

57:29.750 --> 57:32.750
所以1加上1是不是就2

57:32.750 --> 57:34.750
那么这个链表是不是2

57:34.750 --> 57:36.750
然后B算这个链表的时候

57:36.750 --> 57:38.750
是不是1加上后边的2

57:38.750 --> 57:39.750
是不是3

57:39.750 --> 57:40.750
那么算这个链表的时候

57:40.750 --> 57:42.750
是1加上后边的3

57:42.750 --> 57:43.750
是不是4

57:43.750 --> 57:44.750
对不对

57:44.750 --> 57:45.750
正方向推回去

57:45.750 --> 57:46.750
我反方向推回来

57:46.750 --> 57:48.750
正方向推回去也是一样

57:48.750 --> 57:49.750
这个链表的长度有多少

57:49.750 --> 57:51.750
1加上后边的

57:51.750 --> 57:52.750
后边怎么算的

57:52.750 --> 57:54.750
又是1加上后边的

57:54.750 --> 57:55.750
那么这个就怎么算的

57:55.750 --> 57:57.750
又是1加上后边的

57:57.750 --> 57:58.750
那么这个怎么算的

57:58.750 --> 58:00.750
1加上0

58:04.750 --> 58:05.750
这是地规方式

58:05.750 --> 58:07.750
地规可以把很多

58:07.750 --> 58:09.750
复杂的问题

58:09.750 --> 58:13.190
变得非常简单

58:14.190 --> 58:15.190
再来

58:15.190 --> 58:16.190
下一个

58:16.190 --> 58:22.020
通过下标获取链表的某个数据

58:22.020 --> 58:25.100
我讲得不快吧

58:25.100 --> 58:27.100
应该还行

58:27.100 --> 58:28.100
通过下标

58:28.100 --> 58:30.100
得到我们链表中的某个数据

58:30.100 --> 58:32.100
比方说

58:32.100 --> 58:39.600
get value

58:39.600 --> 58:42.600
你给我一个链表

58:42.600 --> 58:44.600
你给我一个下标

58:44.600 --> 58:45.600
当链表里面有没有下标

58:45.600 --> 58:46.600
哪有下标

58:46.600 --> 58:47.600
根本就没有下标

58:47.600 --> 58:48.600
哪有下标

58:48.600 --> 58:49.600
看哪有下标

58:49.600 --> 58:50.600
没有下标

58:50.600 --> 58:52.600
你自己想办法

58:52.600 --> 58:53.600
你给我一个链表

58:53.600 --> 58:54.600
给我一个下标

58:54.600 --> 58:57.600
我要把对应下标的值

58:57.600 --> 58:59.600
返回给你

58:59.600 --> 59:03.230
这块有啥意思呢

59:03.230 --> 59:04.230
就是说

59:04.230 --> 59:05.230
如果说我get value

59:05.230 --> 59:07.230
我这里输出get value

59:07.230 --> 59:09.230
把链表a给你

59:09.230 --> 59:10.230
下标0给你

59:10.230 --> 59:11.230
你得给我啥

59:11.230 --> 59:12.230
你得给我一个a

59:12.230 --> 59:13.230
制服串a

59:13.230 --> 59:15.230
对吧

59:15.230 --> 59:16.230
我把这个链表给你

59:16.230 --> 59:18.230
你给的一个下标0

59:18.230 --> 59:21.230
你得给我一个制服串a吧

59:21.230 --> 59:22.230
我把这个链表给你

59:22.230 --> 59:23.230
你给的一个下标1

59:23.230 --> 59:25.230
你得给我一个制服串b吧

59:25.230 --> 59:27.230
就这么个意思

59:27.230 --> 59:29.230
就这么个意思

59:29.230 --> 59:34.670
那怎么做呢

59:34.670 --> 59:41.540
我就这样子来

59:41.540 --> 59:43.540
我就一个点

59:43.540 --> 59:44.540
还是一个节点

59:44.540 --> 59:45.540
一个节点去找

59:45.540 --> 59:48.980
这个节点的下标是0

59:48.980 --> 59:49.980
对吧

59:49.980 --> 59:50.980
我们一开始认为

59:50.980 --> 59:52.980
从0开始来算

59:52.980 --> 59:54.980
0跟你要找的下标

59:54.980 --> 59:57.980
是不是等相等的

59:57.980 --> 59:58.980
比较说明

59:58.980 --> 59:59.980
index等于2

59:59.980 --> 01:00:00.980
我们要找的下标为2

01:00:00.980 --> 01:00:03.980
给的链表节点是a

01:00:03.980 --> 01:00:07.980
那么我需要一个东西去找

01:00:07.980 --> 01:00:09.980
看一下

01:00:09.980 --> 01:00:10.980
当前这个下标

01:00:10.980 --> 01:00:11.980
跟这个下标是不是相等

01:00:11.980 --> 01:00:12.980
的话

01:00:12.980 --> 01:00:13.980
那我直接把这个节点返回了

01:00:13.980 --> 01:00:14.980
对吧

01:00:14.980 --> 01:00:15.980
就是我们要找的

01:00:15.980 --> 01:00:16.980
不相等的话

01:00:16.980 --> 01:00:18.980
我移动到下一个节点

01:00:18.980 --> 01:00:20.980
同时把下标加1

01:00:20.980 --> 01:00:23.680
对不对

01:00:23.680 --> 01:00:25.680
也就是我现在要做什么事情呢

01:00:25.680 --> 01:00:27.680
我需要一个函数

01:00:27.680 --> 01:00:28.680
这个函数呢

01:00:28.680 --> 01:00:31.680
你告诉我当前的下标

01:00:31.680 --> 01:00:35.500
和当前的节点

01:00:35.500 --> 01:00:36.500
你告诉我当前的下标

01:00:36.500 --> 01:00:38.500
和当前的节点

01:00:38.500 --> 01:00:44.290
这也是我们将来

01:00:44.290 --> 01:00:46.290
后面这几天

01:00:46.290 --> 01:00:48.290
有可能会遇到的这种解放

01:00:48.290 --> 01:00:49.290
就是这个函数呢

01:00:49.290 --> 01:00:50.290
它不是很好地规的

01:00:50.290 --> 01:00:53.290
我们可能需要一个辅助函数

01:00:53.290 --> 01:00:54.290
这个辅助函数呢

01:00:54.290 --> 01:00:56.290
你给我当前的节点

01:00:56.290 --> 01:00:58.290
和当前的下标

01:00:58.290 --> 01:01:04.460
根据当前节点

01:01:04.460 --> 01:01:07.460
和当前下标

01:01:07.460 --> 01:01:14.090
得到对应的值

01:01:14.090 --> 01:01:15.090
那么这个东西

01:01:15.090 --> 01:01:17.090
就是我们刚才分析的

01:01:17.090 --> 01:01:19.090
如果说curr index

01:01:19.090 --> 01:01:23.090
当前的下标不等于index

01:01:23.090 --> 01:01:24.090
对吧

01:01:24.090 --> 01:01:26.090
那这个节点不是我要找的呀

01:01:26.090 --> 01:01:27.090
因为我要找到节点

01:01:27.090 --> 01:01:29.090
下标一定要是跟它相等的吧

01:01:29.090 --> 01:01:31.090
比较你要找下标为2

01:01:31.090 --> 01:01:33.090
我的下标目前才是0

01:01:33.090 --> 01:01:35.090
这个节点肯定是

01:01:35.090 --> 01:01:37.090
不是我要的

01:01:37.090 --> 01:01:38.090
懂我的意思吗

01:01:38.090 --> 01:01:41.090
如果不相等怎么办

01:01:41.090 --> 01:01:42.090
怎么办

01:01:42.090 --> 01:01:43.090
是不是找下一个

01:01:43.090 --> 01:01:50.740
当前节点的下一个

01:01:50.740 --> 01:01:54.740
同时下标加1

01:01:54.740 --> 01:01:59.400
看一下啊

01:01:59.400 --> 01:02:01.400
就像刚才画的图一样

01:02:01.400 --> 01:02:03.400
我看一下这个节点

01:02:03.400 --> 01:02:05.400
这个节点的当前节点是

01:02:05.400 --> 01:02:07.400
当前的下标是不是0

01:02:07.400 --> 01:02:08.400
那你看一下

01:02:08.400 --> 01:02:09.400
0不等于index

01:02:09.400 --> 01:02:10.400
不相等

01:02:10.400 --> 01:02:11.400
那肯定这个节点

01:02:11.400 --> 01:02:12.400
不是我要找的呀

01:02:12.400 --> 01:02:13.400
对不对

01:02:13.400 --> 01:02:14.400
是不是不是我要找的

01:02:14.400 --> 01:02:15.400
不是我要找的怎么办

01:02:15.400 --> 01:02:16.400
不是我要找的

01:02:16.400 --> 01:02:18.400
那我就只能

01:02:18.400 --> 01:02:19.400
到节点B

01:02:19.400 --> 01:02:20.400
到下一个

01:02:20.400 --> 01:02:22.400
下标变成1

01:02:22.400 --> 01:02:25.400
所以又看下一个

01:02:25.400 --> 01:02:27.400
对不对

01:02:27.400 --> 01:02:28.400
当然

01:02:28.400 --> 01:02:29.400
当然如果说

01:02:29.400 --> 01:02:30.400
还有一种特殊情况

01:02:30.400 --> 01:02:31.400
就是看到最后了

01:02:31.400 --> 01:02:33.400
然后我的下标是

01:02:33.400 --> 01:02:35.400
下标是什么6

01:02:35.400 --> 01:02:36.400
没有这个地方

01:02:36.400 --> 01:02:37.400
下标已经到了

01:02:37.400 --> 01:02:39.400
地后面已经是闹了

01:02:39.400 --> 01:02:40.400
那么这里下标才是多少

01:02:40.400 --> 01:02:42.400
0,1,2,3,4

01:02:42.400 --> 01:02:43.400
下标是4

01:02:43.400 --> 01:02:44.400
但是这个节点都没了

01:02:44.400 --> 01:02:45.400
它没了节点

01:02:45.400 --> 01:02:46.400
它又没有下一个了

01:02:46.400 --> 01:02:47.400
说这个时候

01:02:47.400 --> 01:02:49.400
前面我们还可以再瘫短一下

01:02:49.400 --> 01:02:51.400
如果说当前节点都没了

01:02:51.400 --> 01:02:52.400
就找到空气了

01:02:52.400 --> 01:02:54.400
就找到地球的边缘了

01:02:54.400 --> 01:02:55.400
那么这个时候

01:02:55.400 --> 01:02:57.400
那就没有找到了

01:02:57.400 --> 01:02:58.400
没有找到了

01:02:58.400 --> 01:02:59.400
那么我就return

01:02:59.400 --> 01:03:02.780
没有找到

01:03:02.780 --> 01:03:03.780
找到了

01:03:03.780 --> 01:03:04.780
都找没了

01:03:04.780 --> 01:03:05.780
都找到边缘去了

01:03:05.780 --> 01:03:06.780
都没了

01:03:06.780 --> 01:03:07.780
下标都还不相等

01:03:07.780 --> 01:03:08.780
那里要怎么办

01:03:08.780 --> 01:03:09.780
就把我逼疯了

01:03:09.780 --> 01:03:10.780
没了

01:03:10.780 --> 01:03:11.780
找不到了

01:03:11.780 --> 01:03:12.780
看这里是不是一个逻辑

01:03:12.780 --> 01:03:13.780
好

01:03:13.780 --> 01:03:14.780
单凡能找到

01:03:14.780 --> 01:03:16.780
然后下标是2

01:03:16.780 --> 01:03:17.780
那么这里

01:03:17.780 --> 01:03:18.780
找到1了

01:03:18.780 --> 01:03:23.010
找到1了

01:03:23.010 --> 01:03:24.010
那么现在是不是

01:03:24.010 --> 01:03:25.010
还得下一个

01:03:25.010 --> 01:03:26.010
还得下一个

01:03:26.010 --> 01:03:28.010
对不对

01:03:28.010 --> 01:03:30.380
还得下一个

01:03:30.380 --> 01:03:31.380
懂了意思吧

01:03:31.380 --> 01:03:32.380
好

01:03:32.380 --> 01:03:33.380
那么现在

01:03:33.380 --> 01:03:34.380
这是没有节点的情况

01:03:34.380 --> 01:03:35.380
这是下标不相等的情况

01:03:35.380 --> 01:03:37.380
那么L是不是下标相等的

01:03:37.380 --> 01:03:39.380
下标相等

01:03:39.380 --> 01:03:40.380
下标相等是不是非常简单

01:03:40.380 --> 01:03:42.380
就是当前的这个节点的

01:03:42.380 --> 01:03:44.380
value是

01:03:44.380 --> 01:03:45.380
对吧

01:03:45.380 --> 01:03:47.380
直接把这个value值返回去了

01:03:47.380 --> 01:03:49.380
这就是我们这个辅助函数

01:03:49.380 --> 01:03:50.380
以后这个辅助函数过后

01:03:50.380 --> 01:03:52.380
那么后边的就很简单了

01:03:52.380 --> 01:03:53.380
我这个函数

01:03:53.380 --> 01:03:54.380
要怎么来运行的

01:03:55.380 --> 01:03:56.380
直接返回

01:03:59.380 --> 01:04:01.380
一开始从哪个节点开始找

01:04:01.380 --> 01:04:03.380
一开始是不是从它开始找

01:04:03.380 --> 01:04:04.380
一开始的下标是多少

01:04:04.380 --> 01:04:06.380
下标是不是0

01:04:06.380 --> 01:04:08.380
仍然是没有任何循环

01:04:08.380 --> 01:04:11.380
通过这个辅助函数的方式

01:04:11.380 --> 01:04:12.380
低规辅助函数

01:04:12.380 --> 01:04:14.380
来实现了一个过程

01:04:14.380 --> 01:04:15.380
这也是我们后边几天

01:04:15.380 --> 01:04:18.380
要用到的一种常见的方式

01:04:18.380 --> 01:04:20.380
这个方式也要学会

01:04:20.380 --> 01:04:21.380
有的时候

01:04:21.380 --> 01:04:22.380
这个东西不是很好低规

01:04:22.380 --> 01:04:23.380
可能还少一些东西

01:04:23.380 --> 01:04:24.380
那么我们需要

01:04:24.380 --> 01:04:26.380
通过一个辅助函数去完成

01:04:26.380 --> 01:04:27.380
好好看一下

01:04:27.380 --> 01:04:28.380
我从最开始的节点

01:04:28.380 --> 01:04:30.380
下标0开始找

01:04:30.380 --> 01:04:31.380
你没有找到

01:04:31.380 --> 01:04:32.380
您这个下标

01:04:32.380 --> 01:04:33.380
跟它不相当

01:04:33.380 --> 01:04:34.380
不相当

01:04:34.380 --> 01:04:35.380
我下后找

01:04:35.380 --> 01:04:36.380
对吧

01:04:36.380 --> 01:04:37.380
往后找

01:04:37.380 --> 01:04:38.380
咱们来看一下

01:04:38.380 --> 01:04:39.380
get value

01:04:39.380 --> 01:04:40.380
这个函数出来了

01:04:40.380 --> 01:04:41.380
小心

01:04:41.380 --> 01:04:43.380
get value

01:04:43.380 --> 01:04:45.380
把列表A传进去

01:04:45.380 --> 01:04:46.380
下标0

01:04:46.380 --> 01:04:48.380
你看是不是找到A

01:04:48.380 --> 01:04:49.380
下标1

01:04:49.380 --> 01:04:50.380
是不是找到B

01:04:50.380 --> 01:04:51.380
下标2

01:04:51.380 --> 01:04:52.380
找到C

01:04:52.380 --> 01:04:53.380
那么下标6

01:04:53.380 --> 01:04:54.380
就找到LOW

01:04:54.380 --> 01:04:55.380
找不到了

01:04:55.380 --> 01:04:57.380
这是get value

01:04:57.380 --> 01:04:59.380
这个方式的实现

01:04:59.380 --> 01:05:06.130
有问题就问了

01:05:06.130 --> 01:05:11.040
下一个

01:05:11.040 --> 01:05:17.120
应该找到一种感觉了吧

01:05:17.120 --> 01:05:18.120
感觉应该出来了吧

01:05:18.120 --> 01:05:20.120
再来

01:05:20.120 --> 01:05:21.120
通过下标

01:05:21.120 --> 01:05:23.120
设置列表中的

01:05:23.120 --> 01:05:25.120
某个数据

01:05:25.120 --> 01:05:26.120
啥意思

01:05:26.120 --> 01:05:28.120
set value

01:05:28.120 --> 01:05:29.120
你给我一个列表

01:05:29.120 --> 01:05:30.120
给我一个下标

01:05:30.120 --> 01:05:32.120
给我一个value值

01:05:32.120 --> 01:05:34.120
我要去设置这个列表

01:05:34.120 --> 01:05:36.120
对应下标的value值

01:05:36.120 --> 01:05:37.120
比方说

01:05:37.120 --> 01:05:38.120
我到时候

01:05:38.120 --> 01:05:39.120
调用的时候

01:05:39.120 --> 01:05:40.120
这样调用

01:05:40.120 --> 01:05:43.200
我这样子来

01:05:43.200 --> 01:05:44.200
set value

01:05:44.200 --> 01:05:45.200
把列表A给力

01:05:45.200 --> 01:05:47.200
然后下标为2

01:05:47.200 --> 01:05:49.200
我要把它变成

01:05:49.200 --> 01:05:50.200
K

01:05:52.200 --> 01:05:53.200
怎么弄呢

01:05:53.200 --> 01:05:54.200
那我的目标

01:05:54.200 --> 01:05:57.200
是不是要把它变成K

01:05:57.200 --> 01:05:58.200
对吧

01:05:58.200 --> 01:05:59.200
跟到get value的

01:05:59.200 --> 01:06:01.200
到底是不是一样的

01:06:01.200 --> 01:06:03.200
还是一样的

01:06:03.200 --> 01:06:04.200
有啥区别呢

01:06:04.200 --> 01:06:06.200
还不是从头开始

01:06:06.200 --> 01:06:07.200
只能从头开始来

01:06:07.200 --> 01:06:08.200
下标相等吗

01:06:08.200 --> 01:06:09.200
不相等下一个

01:06:09.200 --> 01:06:10.200
相等吗

01:06:10.200 --> 01:06:11.200
不相等下一个

01:06:11.200 --> 01:06:12.200
对吧

01:06:12.200 --> 01:06:13.200
还是一样

01:06:13.200 --> 01:06:15.200
那么set value还说

01:06:15.200 --> 01:06:17.200
我来写一下

01:06:17.200 --> 01:06:18.200
是不是也需要一个辅助的

01:06:18.200 --> 01:06:20.200
set value

01:06:20.200 --> 01:06:23.200
给我当前的节列

01:06:23.200 --> 01:06:26.200
给我一个当前的下标

01:06:26.200 --> 01:06:27.200
值

01:06:27.200 --> 01:06:28.200
就是这个值

01:06:28.200 --> 01:06:29.200
不管了

01:06:31.200 --> 01:06:36.200
设置当前节点的值

01:06:37.200 --> 01:06:38.200
好

01:06:38.200 --> 01:06:39.200
首先我看一下

01:06:39.200 --> 01:06:40.200
有没有当前节点

01:06:40.200 --> 01:06:41.200
你不要跑到列表外边去了

01:06:41.200 --> 01:06:42.200
一直找

01:06:42.200 --> 01:06:43.200
一个下标很大

01:06:43.200 --> 01:06:44.200
一直往后找

01:06:44.200 --> 01:06:45.200
跑到节点外边去了

01:06:45.200 --> 01:06:46.200
不好了

01:06:46.200 --> 01:06:47.200
首先我看一下

01:06:47.200 --> 01:06:48.200
这个节点还有没有

01:06:48.200 --> 01:06:49.200
都没有这个节点

01:06:49.200 --> 01:06:50.200
我干嘛了

01:06:50.200 --> 01:06:51.200
不能干嘛了

01:06:51.200 --> 01:06:53.200
节点都没了

01:06:53.200 --> 01:06:54.200
都没了

01:06:54.200 --> 01:06:55.200
停止

01:06:55.200 --> 01:06:57.200
后面都没东西了

01:06:57.200 --> 01:06:58.200
不要再找了

01:06:58.200 --> 01:07:00.200
如果说节点还有

01:07:00.200 --> 01:07:01.200
那么我判断一下

01:07:01.200 --> 01:07:03.200
判断一下一个节点

01:07:03.200 --> 01:07:04.200
当前下标

01:07:04.200 --> 01:07:06.200
是不是等于这个应代的

01:07:06.200 --> 01:07:07.200
刚才判断不等于

01:07:07.200 --> 01:07:08.200
都是一样的

01:07:08.200 --> 01:07:10.200
逻辑都是一样的

01:07:10.200 --> 01:07:13.200
找到了对应的节点

01:07:13.200 --> 01:07:17.470
找到对应节点干嘛呢

01:07:17.470 --> 01:07:18.470
这不是对应节点吗

01:07:18.470 --> 01:07:19.470
你要干嘛

01:07:19.470 --> 01:07:21.470
你不就是把这个节点的

01:07:21.470 --> 01:07:24.470
value 值设置为这个 value

01:07:24.470 --> 01:07:25.470
对不对

01:07:25.470 --> 01:07:26.470
出去设置它

01:07:26.470 --> 01:07:27.470
这找到了

01:07:27.470 --> 01:07:28.470
对吧

01:07:28.470 --> 01:07:29.470
都找到了

01:07:29.470 --> 01:07:31.470
没有找到怎么办

01:07:31.470 --> 01:07:32.470
又找下一个

01:07:32.470 --> 01:07:34.470
says value

01:07:34.470 --> 01:07:36.470
把当前节点的下一个人

01:07:36.470 --> 01:07:37.470
进去

01:07:37.470 --> 01:07:40.470
同时下标加一

01:07:40.470 --> 01:07:41.470
你看

01:07:41.470 --> 01:07:42.470
跟那个 gets value

01:07:42.470 --> 01:07:43.470
是不是

01:07:43.470 --> 01:07:44.470
道理差不多

01:07:44.470 --> 01:07:45.470
对比一下这两个

01:07:45.470 --> 01:07:46.470
还说

01:07:46.470 --> 01:07:49.980
道理都是一样的

01:07:49.980 --> 01:07:50.980
这种方式

01:07:50.980 --> 01:07:51.980
要慢慢的去熟悉

01:07:51.980 --> 01:07:54.980
后面还用的比较多

01:07:54.980 --> 01:07:55.980
这种方式

01:07:55.980 --> 01:07:56.980
解决复杂问题

01:07:56.980 --> 01:07:58.980
超级厉害的

01:07:59.980 --> 01:08:01.980
他把一些很复杂的问题

01:08:01.980 --> 01:08:03.980
变成了一个问题了

01:08:03.980 --> 01:08:04.980
就是当个节点的问题

01:08:04.980 --> 01:08:05.980
把一个列表的问题

01:08:05.980 --> 01:08:07.980
变成一个当个节点的问题

01:08:07.980 --> 01:08:08.980
对吧

01:08:08.980 --> 01:08:09.980
好

01:08:09.980 --> 01:08:10.980
那么最后我们就是

01:08:10.980 --> 01:08:11.980
在这个函数里面

01:08:11.980 --> 01:08:13.980
无非就是调用它去实现

01:08:13.980 --> 01:08:14.980
says value

01:08:14.980 --> 01:08:15.980
调用它

01:08:15.980 --> 01:08:16.980
列表节点

01:08:16.980 --> 01:08:18.980
一开始就从它开始

01:08:18.980 --> 01:08:20.980
然后下标就从您开始

01:08:20.980 --> 01:08:21.980
对不对

01:08:21.980 --> 01:08:22.980
就完了

01:08:22.980 --> 01:08:23.980
这是 says value

01:08:23.980 --> 01:08:24.980
来试一下

01:08:24.980 --> 01:08:27.290
好

01:08:27.290 --> 01:08:28.290
来吧

01:08:28.290 --> 01:08:29.290
says value

01:08:29.290 --> 01:08:30.290
列表A传进去

01:08:30.290 --> 01:08:32.290
下标0传进去

01:08:32.290 --> 01:08:33.290
直

01:08:33.290 --> 01:08:34.290
我把第一个改成K

01:08:34.290 --> 01:08:35.290
看能不能改

01:08:35.290 --> 01:08:36.290
好

01:08:36.290 --> 01:08:37.290
改完了

01:08:37.290 --> 01:08:38.290
我们看一下A这个列表

01:08:38.290 --> 01:08:39.290
它只是变成K了

01:08:39.290 --> 01:08:40.290
后边的东西都没变

01:08:42.290 --> 01:08:43.290
好

01:08:43.290 --> 01:08:44.290
再来

01:08:44.290 --> 01:08:45.290
我要把

01:08:46.290 --> 01:08:48.290
把下标为2的变成K

01:08:49.290 --> 01:08:50.290
好

01:08:50.290 --> 01:08:51.290
来看一下一个列表

01:08:51.290 --> 01:08:52.290
第一个没动

01:08:52.290 --> 01:08:53.290
第二个B没动

01:08:53.290 --> 01:08:55.290
第三个是不是变成K了

01:08:55.290 --> 01:08:56.290
下标为2

01:08:57.290 --> 01:08:58.290
对不对

01:09:00.290 --> 01:09:02.290
咱们学数据结构和算法

01:09:02.290 --> 01:09:04.290
基本上都是从列表开始学习的

01:09:04.290 --> 01:09:05.290
因为列表是最简单的

01:09:05.290 --> 01:09:07.290
也是对能锻炼这些

01:09:07.290 --> 01:09:08.290
抽象思维的

01:09:08.290 --> 01:09:10.290
把这个东西先搞熟悉

01:09:10.290 --> 01:09:11.290
下来过后大家一定要去写一遍

01:09:11.290 --> 01:09:13.290
一定要去写一遍

01:09:13.290 --> 01:09:14.290
不管有多难

01:09:14.290 --> 01:09:15.290
你先把这个砍过了

01:09:15.290 --> 01:09:17.290
那么后边就比较轻松一点

01:09:17.290 --> 01:09:19.290
你这个砍不过

01:09:19.290 --> 01:09:21.290
后边要学习的就有点头痛

01:09:22.290 --> 01:09:23.290
好

01:09:23.290 --> 01:09:24.290
这是这一块

01:09:24.290 --> 01:09:25.290
来

01:09:25.290 --> 01:09:28.370
坚持

01:09:28.370 --> 01:09:29.370
坚持 加油

01:09:29.370 --> 01:09:31.370
为什么说一个算法集训营

01:09:31.370 --> 01:09:33.370
它能够提升你的开发能力呢

01:09:33.370 --> 01:09:35.370
它是一个思维的集中训练

01:09:35.370 --> 01:09:37.370
就是纯粹训练思维的

01:09:46.970 --> 01:09:48.970
它说不得表面意思就是

01:09:48.970 --> 01:09:50.970
你给一个对象是NOW

01:09:50.970 --> 01:09:51.970
一个变量是NOW

01:09:51.970 --> 01:09:54.970
你再给一个NOW的变量

01:09:54.970 --> 01:09:55.970
SRC属性复制

01:09:55.970 --> 01:09:57.970
它表面的意思就是这个意思

01:09:57.970 --> 01:09:59.970
具体的代码里面

01:09:59.970 --> 01:10:00.970
是什么情况

01:10:00.970 --> 01:10:01.970
你要去看一下代码

01:10:02.970 --> 01:10:03.970
就调识一下代码

01:10:03.970 --> 01:10:05.970
表面的意思就是有一个东西是NOW

01:10:06.970 --> 01:10:07.970
你再给它这个属性

01:10:07.970 --> 01:10:08.970
SRC复制

01:10:09.970 --> 01:10:10.970
好听课

01:10:10.970 --> 01:10:11.970
好听课

01:10:11.970 --> 01:10:12.970
先把这个东西

01:10:12.970 --> 01:10:13.970
课听完了之后

01:10:13.970 --> 01:10:14.970
慢慢去写你的代码

01:10:16.970 --> 01:10:17.970
好 第五题

01:10:17.970 --> 01:10:19.970
在链表莫伟加上一个新节点

01:10:25.480 --> 01:10:26.480
我刚才说了

01:10:26.480 --> 01:10:27.480
在链表有新增

01:10:28.480 --> 01:10:29.480
我们给它加一个方法

01:10:29.480 --> 01:10:30.480
叫NDD

01:10:32.480 --> 01:10:33.480
给我一个链表

01:10:35.860 --> 01:10:36.860
给我一个新的值

01:10:37.860 --> 01:10:39.860
我要在链表的莫伟

01:10:39.860 --> 01:10:40.860
加上这个新的节点

01:10:41.860 --> 01:10:42.860
懂了意思吗

01:10:42.860 --> 01:10:43.860
比方说你给我

01:10:43.860 --> 01:10:44.860
你给我这个链表

01:10:44.860 --> 01:10:45.860
比方说我们到时候

01:10:45.860 --> 01:10:46.860
这样调用

01:10:48.860 --> 01:10:49.860
这样调用

01:10:49.860 --> 01:10:50.860
调一个NDD

01:10:50.860 --> 01:10:52.860
把这个链表A给它

01:10:52.860 --> 01:10:53.860
然后给它一个值

01:10:53.860 --> 01:10:55.860
比方说给它一个K

01:10:55.860 --> 01:10:56.860
这里原来是C

01:10:58.860 --> 01:10:59.860
给它一个K

01:11:00.860 --> 01:11:01.860
然后呢

01:11:01.860 --> 01:11:02.860
调完这个方法之后

01:11:02.860 --> 01:11:03.860
我希望这个链表

01:11:03.860 --> 01:11:04.860
会变成这个样子

01:11:04.860 --> 01:11:05.860
这里会多一个节点

01:11:07.860 --> 01:11:08.860
是个K节点

01:11:08.860 --> 01:11:09.860
K节点的后面

01:11:11.860 --> 01:11:12.860
懂了意思吗

01:11:12.860 --> 01:11:13.860
新增一个

01:11:13.860 --> 01:11:16.940
咋说

01:11:16.940 --> 01:11:21.660
关键点在哪

01:11:21.660 --> 01:11:22.660
关键点

01:11:22.660 --> 01:11:23.660
是不是一定要找到

01:11:23.660 --> 01:11:24.660
最后一个节点

01:11:25.660 --> 01:11:26.660
是不是

01:11:27.660 --> 01:11:28.660
这个节点我懂吗

01:11:28.660 --> 01:11:29.660
不懂它呀

01:11:29.660 --> 01:11:30.660
这个节点我懂它干嘛

01:11:30.660 --> 01:11:31.660
它不是最后一个

01:11:31.660 --> 01:11:32.660
看下一个

01:11:32.660 --> 01:11:33.660
不是最后一个

01:11:33.660 --> 01:11:34.660
看下一个

01:11:34.660 --> 01:11:35.660
不是最后一个

01:11:35.660 --> 01:11:36.660
一开始这个样子

01:11:36.660 --> 01:11:37.660
看下一个

01:11:37.660 --> 01:11:38.660
它是不是最后一个了

01:11:38.660 --> 01:11:40.660
好 到了最后一个节点

01:11:40.660 --> 01:11:41.660
干嘛

01:11:41.660 --> 01:11:42.660
建一个新的节点

01:11:42.660 --> 01:11:43.660
值就是这个值

01:11:45.660 --> 01:11:46.660
然后把刚才的

01:11:46.660 --> 01:11:47.660
最后一个节点

01:11:47.660 --> 01:11:48.660
下一个指向它

01:11:48.660 --> 01:11:49.660
不就完了吗

01:11:50.660 --> 01:11:51.660
是不是这么个逻辑

01:11:52.660 --> 01:11:53.660
是不是这么个逻辑

01:11:54.660 --> 01:11:55.660
好 来吧

01:11:56.660 --> 01:11:57.660
那这个玩意怎么玩

01:11:59.660 --> 01:12:00.660
我就看一下

01:12:00.660 --> 01:12:01.660
这个节点是不是

01:12:01.660 --> 01:12:02.660
最后一个

01:12:02.660 --> 01:12:03.660
它不是

01:12:03.660 --> 01:12:04.660
我就看下一个

01:12:05.660 --> 01:12:06.660
判断一下

01:12:06.660 --> 01:12:11.420
no.next

01:12:11.420 --> 01:12:12.420
有没有值

01:12:13.420 --> 01:12:14.420
这个节点

01:12:14.420 --> 01:12:15.420
下一个有没有值

01:12:16.420 --> 01:12:17.420
有值

01:12:18.420 --> 01:12:20.420
当前节点

01:12:20.420 --> 01:12:22.420
还不是最后一个

01:12:22.420 --> 01:12:23.420
对吧

01:12:23.420 --> 01:12:24.420
它后面还有容器

01:12:24.420 --> 01:12:25.420
它后面是不是还有东西

01:12:25.420 --> 01:12:26.420
它肯定不是最后一个

01:12:26.420 --> 01:12:28.420
不是最后一个干嘛

01:12:29.420 --> 01:12:30.420
又继续

01:12:31.420 --> 01:12:32.420
下一个给它

01:12:33.420 --> 01:12:34.420
值呢

01:12:34.420 --> 01:12:35.420
还是这个值

01:12:35.420 --> 01:12:36.420
不变

01:12:36.420 --> 01:12:37.420
下一个给你

01:12:37.420 --> 01:12:38.420
又来

01:12:39.420 --> 01:12:40.420
是不是逻辑

01:12:40.420 --> 01:12:41.420
你看吧

01:12:41.420 --> 01:12:42.420
我先看到

01:12:42.420 --> 01:12:43.420
A是不是最后一个

01:12:43.420 --> 01:12:44.420
不是

01:12:44.420 --> 01:12:45.420
不去看下一个

01:12:45.420 --> 01:12:46.420
看都不看了

01:12:46.420 --> 01:12:47.420
直接跳到下一个

01:12:47.420 --> 01:12:48.420
所以又重新来这个过程

01:12:48.420 --> 01:12:49.420
A看B

01:12:49.420 --> 01:12:50.420
B下一个还有值吗

01:12:50.420 --> 01:12:51.420
还有值

01:12:51.420 --> 01:12:52.420
又继续看C

01:12:52.420 --> 01:12:53.420
C下一个还有值吗

01:12:53.420 --> 01:12:54.420
还有值

01:12:54.420 --> 01:12:55.420
就看D

01:12:55.420 --> 01:12:56.420
D下一个没有值了

01:12:57.420 --> 01:12:58.420
D的next

01:12:58.420 --> 01:12:59.420
是不是通了

01:12:59.420 --> 01:13:00.420
那么EV进不去

01:13:00.420 --> 01:13:05.480
进不去GNOS

01:13:05.480 --> 01:13:07.480
当前节点

01:13:07.480 --> 01:13:09.480
已经是最后一个了

01:13:09.480 --> 01:13:10.480
那怎么办

01:13:10.480 --> 01:13:11.480
刚才说了

01:13:11.480 --> 01:13:12.480
是不是第一步

01:13:12.480 --> 01:13:13.480
创建一个新的节点

01:13:14.480 --> 01:13:15.480
创建一个新的节点

01:13:15.480 --> 01:13:17.480
留漏

01:13:17.480 --> 01:13:18.480
留一个漏

01:13:18.480 --> 01:13:19.480
这个节点对象吧

01:13:19.480 --> 01:13:20.480
值呢

01:13:20.480 --> 01:13:21.480
值就是这个值

01:13:21.480 --> 01:13:22.480
对吧

01:13:22.480 --> 01:13:23.480
值就是这个值

01:13:23.480 --> 01:13:24.480
给它传进来的值

01:13:25.480 --> 01:13:26.480
好 这是新的节点

01:13:26.480 --> 01:13:27.480
然后呢

01:13:29.480 --> 01:13:30.480
新的节点我是不是要把

01:13:30.480 --> 01:13:31.480
当前节点的下一个

01:13:31.480 --> 01:13:32.480
指向新的节点

01:13:32.480 --> 01:13:33.480
就完了

01:13:33.480 --> 01:13:34.480
对不对

01:13:34.480 --> 01:13:36.480
好 把当前节点

01:13:36.480 --> 01:13:37.480
漏的

01:13:37.480 --> 01:13:39.480
下一个指向新节点

01:13:39.480 --> 01:13:40.480
就完了

01:13:40.480 --> 01:13:42.480
看上去好像挺富长的样子

01:13:42.480 --> 01:13:43.480
你看几行戴了

01:13:43.480 --> 01:13:44.480
就搞定了

01:13:44.480 --> 01:13:45.480
就添加节点

01:13:46.480 --> 01:13:47.480
好 来吧

01:13:47.480 --> 01:13:48.480
试一下

01:13:48.480 --> 01:13:49.480
刷新

01:13:52.480 --> 01:13:53.480
ADD

01:13:53.480 --> 01:13:54.480
练表A传进去

01:13:54.480 --> 01:13:55.480
新的节点K

01:13:57.480 --> 01:13:58.480
我们看一下这个A节点

01:13:58.480 --> 01:13:59.480
A这个练表

01:13:59.480 --> 01:14:00.480
A的下一个B

01:14:00.480 --> 01:14:01.480
B的下一个C

01:14:01.480 --> 01:14:02.480
C的下一个D

01:14:02.480 --> 01:14:03.480
D的下一个K

01:14:03.480 --> 01:14:04.480
K的下一个

01:14:04.480 --> 01:14:05.480
没了

01:14:05.480 --> 01:14:06.480
对吧

01:14:06.480 --> 01:14:07.480
所以添加了一个新的节点

01:14:07.480 --> 01:14:08.480
我们可以利用

01:14:08.480 --> 01:14:09.480
之前的函数

01:14:09.480 --> 01:14:10.480
Print打印一下

01:14:10.480 --> 01:14:11.480
A

01:14:11.480 --> 01:14:12.480
说ABCD

01:14:12.480 --> 01:14:13.480
K

01:14:19.310 --> 01:14:20.310
还行吧

01:14:20.310 --> 01:14:22.310
能跟着它吗

01:14:22.310 --> 01:14:24.310
今天还不是很难

01:14:24.310 --> 01:14:25.310
今天东西不是很难

01:14:25.310 --> 01:14:26.310
加油 同学们

01:14:26.310 --> 01:14:27.310
加油

01:14:27.310 --> 01:14:29.310
所以思维训练

01:14:29.310 --> 01:14:31.310
肯定是比职权

01:14:31.310 --> 01:14:33.310
比平时我们开发的一些简单效果

01:14:33.310 --> 01:14:36.750
要断点人的补

01:14:37.750 --> 01:14:38.750
还挺多做

01:14:38.750 --> 01:14:40.750
行 拿下来

01:14:40.750 --> 01:14:41.750
下一个

01:14:42.750 --> 01:14:43.750
没关系

01:14:43.750 --> 01:14:44.750
你先听

01:14:44.750 --> 01:14:45.750
听得懂再说

01:14:45.750 --> 01:14:46.750
听得懂了

01:14:46.750 --> 01:14:47.750
下来过后

01:14:47.750 --> 01:14:48.750
再去回忆一下

01:14:48.750 --> 01:14:49.750
咱们的思维

01:14:49.750 --> 01:14:50.750
再写一遍

01:14:50.750 --> 01:14:51.750
一定要去写一遍

01:14:53.750 --> 01:14:56.750
在练表的某一个节点之后

01:14:56.750 --> 01:14:57.750
你看可以玩说

01:14:57.750 --> 01:14:58.750
很多花样这种题

01:14:58.750 --> 01:15:00.750
其实后面还有很多很多的题

01:15:00.750 --> 01:15:01.750
也复杂的东西

01:15:01.750 --> 01:15:03.750
我没有那么多时间了

01:15:03.750 --> 01:15:04.750
没有加进来

01:15:04.750 --> 01:15:05.750
还可以玩说很多花样

01:15:05.750 --> 01:15:07.750
练表某一个节点之后

01:15:07.750 --> 01:15:08.750
加入一个新节点

01:15:08.750 --> 01:15:10.750
就是Insert

01:15:10.750 --> 01:15:11.750
它不是在墨尾加了

01:15:11.750 --> 01:15:12.750
它是中间加

01:15:12.750 --> 01:15:13.750
给我一个练表

01:15:13.750 --> 01:15:19.340
给我一个

01:15:19.340 --> 01:15:21.340
节点的

01:15:23.340 --> 01:15:24.340
加上哪儿呢

01:15:24.340 --> 01:15:26.340
一个节点之后

01:15:26.340 --> 01:15:28.340
Insert承诺的

01:15:28.340 --> 01:15:30.340
不给下标了

01:15:30.340 --> 01:15:32.340
因为下标的东西做过了

01:15:32.340 --> 01:15:35.340
我们给一个Insert承诺的

01:15:35.340 --> 01:15:36.340
然后呢

01:15:36.340 --> 01:15:37.340
给一个新节点

01:15:37.340 --> 01:15:39.340
New Value

01:15:40.340 --> 01:15:41.340
有关系

01:15:41.340 --> 01:15:42.340
反正又回放了

01:15:42.340 --> 01:15:43.340
慢慢看

01:15:43.340 --> 01:15:44.340
啥意思

01:15:44.340 --> 01:15:45.340
就是说

01:15:45.340 --> 01:15:47.340
我给了一个Insert

01:15:47.340 --> 01:15:49.340
这个练表

01:15:49.340 --> 01:15:50.340
我要往哪儿加呢

01:15:50.340 --> 01:15:54.420
我要往那个

01:15:54.420 --> 01:15:55.420
一个节点之后

01:15:55.420 --> 01:15:58.420
比方说我要往那个

01:15:58.420 --> 01:16:00.420
Insert Value

01:16:00.420 --> 01:16:01.420
就漏的吧

01:16:01.420 --> 01:16:06.940
我要在C这个节点之后

01:16:06.940 --> 01:16:09.940
加上一个新的值

01:16:10.940 --> 01:16:13.320
这样子的话

01:16:13.320 --> 01:16:16.320
好像这个A是多余的

01:16:16.320 --> 01:16:19.320
好像这个A有点多余

01:16:19.320 --> 01:16:20.320
那这个新节点

01:16:20.320 --> 01:16:21.320
我就不能写节点了

01:16:21.320 --> 01:16:24.320
我要写节点值的

01:16:24.320 --> 01:16:31.420
Insert Value

01:16:32.420 --> 01:16:34.420
那么这个地方

01:16:34.420 --> 01:16:35.420
我们应该这样传

01:16:35.420 --> 01:16:36.420
传这个

01:16:36.420 --> 01:16:37.420
传字不算

01:16:37.420 --> 01:16:39.420
在这个练表中

01:16:39.420 --> 01:16:40.420
我要去找这个值

01:16:40.420 --> 01:16:41.420
找到过后

01:16:41.420 --> 01:16:43.420
在它后边加上这个值

01:16:43.420 --> 01:16:45.730
看到吗

01:16:45.730 --> 01:16:47.730
我在这个练表中

01:16:47.730 --> 01:16:48.730
要去找这个值

01:16:48.730 --> 01:16:49.730
找到之后

01:16:49.730 --> 01:16:51.730
我要在它的后边

01:16:51.730 --> 01:16:55.100
加上这个值

01:16:55.100 --> 01:16:56.100
如果找不到

01:16:56.100 --> 01:16:57.100
那就是摸尾

01:16:57.100 --> 01:16:58.100
如果找不到这个值

01:16:58.100 --> 01:17:00.100
就是摸尾

01:17:00.100 --> 01:17:01.100
听上去有点复杂

01:17:01.100 --> 01:17:02.100
对吧

01:17:02.100 --> 01:17:03.100
其实你用

01:17:03.100 --> 01:17:04.100
回的方式来看的话

01:17:04.100 --> 01:17:05.100
也没有那么复杂

01:17:05.100 --> 01:17:07.990
看着

01:17:08.990 --> 01:17:09.990
你给了不是

01:17:09.990 --> 01:17:10.990
给了我一个节点吗

01:17:10.990 --> 01:17:11.990
来

01:17:11.990 --> 01:17:12.990
我就从这里开始

01:17:12.990 --> 01:17:13.990
我看一下

01:17:13.990 --> 01:17:14.990
这个节点是不是我要找的

01:17:14.990 --> 01:17:16.990
这个节点是不是等于这个

01:17:16.990 --> 01:17:18.990
等于你传过来这个值

01:17:18.990 --> 01:17:19.990
这个节点的Value

01:17:19.990 --> 01:17:20.990
是不是等于你传过来这个值

01:17:20.990 --> 01:17:21.990
是的话

01:17:21.990 --> 01:17:22.990
就是我要找的

01:17:22.990 --> 01:17:24.990
我要做一系列操作

01:17:25.990 --> 01:17:26.990
不是的话

01:17:26.990 --> 01:17:27.990
我要看下一个

01:17:27.990 --> 01:17:28.990
一直看到什么

01:17:28.990 --> 01:17:29.990
什么都没有

01:17:29.990 --> 01:17:30.990
什么都没有的话

01:17:30.990 --> 01:17:32.990
什么都没有的情况下

01:17:32.990 --> 01:17:33.990
我看到什么都没有

01:17:33.990 --> 01:17:34.990
是不是就变成了

01:17:34.990 --> 01:17:36.990
摸尾添加的逻辑了

01:17:36.990 --> 01:17:37.990
我们现在搞定

01:17:37.990 --> 01:17:38.990
第一个逻辑

01:17:38.990 --> 01:17:39.990
就什么都没有了

01:17:39.990 --> 01:17:40.990
你给我

01:17:40.990 --> 01:17:41.990
漏的都没东西了

01:17:44.990 --> 01:17:45.990
漏的没东西

01:17:45.990 --> 01:17:46.990
应该在这

01:17:46.990 --> 01:17:47.990
已经到摸尾了

01:17:47.990 --> 01:17:48.990
摸尾都还不是

01:17:48.990 --> 01:17:49.990
首先看一下

01:17:49.990 --> 01:17:50.990
这几种情况

01:17:50.990 --> 01:17:51.990
我们来分析一下

01:17:51.990 --> 01:17:52.990
第一个是目前

01:17:52.990 --> 01:17:53.990
它是

01:17:53.990 --> 01:17:54.990
因此而为的

01:17:54.990 --> 01:17:55.990
它是

01:17:55.990 --> 01:18:00.500
当前节点之后

01:18:00.500 --> 01:18:04.500
要加入新节点

01:18:04.500 --> 01:18:05.500
对不对

01:18:05.500 --> 01:18:06.500
是不是当前

01:18:06.500 --> 01:18:07.500
它是

01:18:07.500 --> 01:18:08.500
已经找到了

01:18:08.500 --> 01:18:09.500
找到这个节点

01:18:09.500 --> 01:18:10.500
比较C

01:18:10.500 --> 01:18:11.500
是不是找到了

01:18:11.500 --> 01:18:12.500
找到这个节点了

01:18:12.500 --> 01:18:14.500
它的后边加上新节点

01:18:14.500 --> 01:18:15.500
对吧

01:18:15.500 --> 01:18:16.500
是这种情况

01:18:18.500 --> 01:18:19.500
还有什么情况呢

01:18:19.500 --> 01:18:20.500
LC

01:18:22.500 --> 01:18:23.500
还有就是

01:18:23.500 --> 01:18:24.500
当前的节点的

01:18:24.500 --> 01:18:26.500
下一个都没了

01:18:26.500 --> 01:18:28.500
它不是这个值

01:18:28.500 --> 01:18:29.500
比方说

01:18:29.500 --> 01:18:30.500
这种情况

01:18:31.500 --> 01:18:32.500
这种情况

01:18:32.500 --> 01:18:33.500
C

01:18:33.500 --> 01:18:34.500
T

01:18:34.500 --> 01:18:35.500
它不是吗

01:18:35.500 --> 01:18:36.500
你看

01:18:36.500 --> 01:18:37.500
它不是吗

01:18:37.500 --> 01:18:38.500
下一个

01:18:38.500 --> 01:18:39.500
它不是吗

01:18:39.500 --> 01:18:40.500
它不是吗

01:18:40.500 --> 01:18:41.500
它的下一个都没了

01:18:41.500 --> 01:18:42.500
对吧

01:18:42.500 --> 01:18:43.500
没法再下一个了

01:18:43.500 --> 01:18:44.500
它再下一个就没了

01:18:44.500 --> 01:18:45.500
已经到处有个节点的

01:18:45.500 --> 01:18:47.500
后面都没东西了

01:18:47.500 --> 01:18:48.500
那于是LC

01:18:48.500 --> 01:18:49.500
什么情况

01:18:49.500 --> 01:18:50.500
是漏的

01:18:50.500 --> 01:18:51.500
第二

01:18:51.500 --> 01:18:52.500
next

01:18:52.500 --> 01:18:53.500
没东西了

01:18:53.500 --> 01:18:57.700
已经没东西了

01:18:57.700 --> 01:18:58.700
到了摸尾了

01:18:58.700 --> 01:19:02.460
当前节点

01:19:02.460 --> 01:19:04.460
也不是

01:19:04.460 --> 01:19:05.460
同时

01:19:05.460 --> 01:19:07.460
已经到了

01:19:07.460 --> 01:19:08.460
墨尾

01:19:08.460 --> 01:19:09.460
这个条稍微复杂点

01:19:09.460 --> 01:19:12.840
是不是这种情况

01:19:12.840 --> 01:19:14.840
还有一个LC就是

01:19:14.840 --> 01:19:15.840
没有到墨尾

01:19:15.840 --> 01:19:16.840
但是也不是

01:19:16.840 --> 01:19:17.840
比方说

01:19:17.840 --> 01:19:18.840
像这个

01:19:18.840 --> 01:19:19.840
没有到墨尾

01:19:19.840 --> 01:19:20.840
但是也不是

01:19:20.840 --> 01:19:21.840
对吧

01:19:21.840 --> 01:19:22.840
三种情况

01:19:22.840 --> 01:19:23.840
一个情况

01:19:23.840 --> 01:19:24.840
一个情况来

01:19:24.840 --> 01:19:25.840
这个条稍微复杂点

01:19:25.840 --> 01:19:26.840
没有到墨尾

01:19:26.840 --> 01:19:27.840
同时也不是

01:19:27.840 --> 01:19:28.840
这个情况比较简单

01:19:28.840 --> 01:19:29.840
对吧

01:19:29.840 --> 01:19:30.840
直接看下一个就完事了

01:19:30.840 --> 01:19:31.840
就直接看下一个

01:19:31.840 --> 01:19:32.840
那么直接

01:19:32.840 --> 01:19:33.840
insert

01:19:34.840 --> 01:19:35.840
load

01:19:36.840 --> 01:19:37.840
next

01:19:37.840 --> 01:19:42.900
下一个

01:19:42.900 --> 01:19:43.900
然后呢

01:19:43.900 --> 01:19:44.900
insert value

01:19:44.900 --> 01:19:45.900
这个不变

01:19:45.900 --> 01:19:47.900
有value不变

01:19:47.900 --> 01:19:49.900
对不对

01:19:49.900 --> 01:19:53.340
所以LC变成这种情况

01:19:53.340 --> 01:19:55.340
当前节点

01:19:55.340 --> 01:19:57.340
不是

01:19:57.340 --> 01:19:58.340
不是

01:19:58.340 --> 01:19:59.340
同时

01:19:59.340 --> 01:20:00.340
又

01:20:00.340 --> 01:20:02.340
没有到墨尾

01:20:02.340 --> 01:20:03.340
对吧

01:20:03.340 --> 01:20:04.340
那就直接下一个

01:20:04.340 --> 01:20:06.340
直接看下一个

01:20:06.340 --> 01:20:07.340
好

01:20:07.340 --> 01:20:08.340
那么剩下的事情

01:20:08.340 --> 01:20:09.340
说前面的情况

01:20:09.340 --> 01:20:10.340
搞定就完事了

01:20:10.340 --> 01:20:11.340
一个一个来

01:20:11.340 --> 01:20:12.340
慢慢来

01:20:12.340 --> 01:20:13.340
第一个情况就是

01:20:13.340 --> 01:20:14.340
这个条件已经找到了

01:20:14.340 --> 01:20:15.340
就是我们找到了

01:20:15.340 --> 01:20:16.340
比方我现在

01:20:16.340 --> 01:20:17.340
这个节点是D

01:20:17.340 --> 01:20:18.340
对吧

01:20:18.340 --> 01:20:19.340
通过我艰苦的寻找

01:20:19.340 --> 01:20:20.340
A找完找B

01:20:20.340 --> 01:20:21.340
B找完找C

01:20:21.340 --> 01:20:22.340
C找完找D

01:20:22.340 --> 01:20:23.340
D就是

01:20:23.340 --> 01:20:24.340
或者是

01:20:24.340 --> 01:20:25.340
它是C

01:20:25.340 --> 01:20:26.340
那什么找这儿来

01:20:26.340 --> 01:20:27.340
都有可能对吧

01:20:27.340 --> 01:20:28.340
那它就是

01:20:28.340 --> 01:20:30.340
是了怎么办

01:20:30.340 --> 01:20:32.340
是不是来一个新节点

01:20:32.340 --> 01:20:33.340
K

01:20:34.340 --> 01:20:35.340
先来一个新节点

01:20:35.340 --> 01:20:36.340
K再说

01:20:37.340 --> 01:20:38.340
来一个新节点

01:20:39.340 --> 01:20:40.340
new load

01:20:40.340 --> 01:20:41.340
new一个 load

01:20:41.340 --> 01:20:42.340
new value

01:20:43.340 --> 01:20:44.340
就来个新节点

01:20:45.340 --> 01:20:46.340
好新节点已经出来了

01:20:46.340 --> 01:20:47.340
然后呢

01:20:47.340 --> 01:20:48.340
然后怎么办呢

01:20:48.340 --> 01:20:49.340
把这个节点

01:20:49.340 --> 01:20:50.340
下一个

01:20:51.340 --> 01:20:52.340
D

01:20:52.340 --> 01:20:53.340
是不是把K指向

01:20:53.340 --> 01:20:54.340
它的下

01:20:54.340 --> 01:20:55.340
它的下一个要指向它

01:20:58.230 --> 01:20:59.230
对不对

01:20:59.230 --> 01:21:00.230
新节点的下一个

01:21:00.230 --> 01:21:01.230
是不是要指向

01:21:01.230 --> 01:21:02.230
它的下一个

01:21:03.230 --> 01:21:04.230
新节点的下一个

01:21:04.230 --> 01:21:05.230
是不是要指向

01:21:05.230 --> 01:21:06.230
它的下一个

01:21:06.230 --> 01:21:08.670
一步步来啊

01:21:08.670 --> 01:21:10.670
新节点的下一个

01:21:10.670 --> 01:21:11.670
应该等于

01:21:11.670 --> 01:21:13.670
load的的下一个

01:21:14.670 --> 01:21:15.670
因为我打猪是

01:21:15.670 --> 01:21:16.670
都不知道怎么打

01:21:16.670 --> 01:21:17.670
你只能看图

01:21:18.670 --> 01:21:19.670
好完没完

01:21:19.670 --> 01:21:21.670
然后呢

01:21:21.670 --> 01:21:22.670
是不是要把

01:21:22.670 --> 01:21:23.670
它

01:21:23.670 --> 01:21:24.670
当前节点的下一个

01:21:25.670 --> 01:21:27.670
指向新节点

01:21:27.670 --> 01:21:29.670
这就完成插入了

01:21:30.670 --> 01:21:31.670
当前节点

01:21:31.670 --> 01:21:32.670
是load的

01:21:32.670 --> 01:21:33.670
下一个指向什么

01:21:33.670 --> 01:21:34.670
new load

01:21:35.670 --> 01:21:36.670
这两句话是

01:21:36.670 --> 01:21:37.670
不能写反的哦

01:21:38.670 --> 01:21:40.670
可以自己去琢磨一下

01:21:40.670 --> 01:21:41.670
为什么不能写反

01:21:43.670 --> 01:21:44.670
那么这种情况

01:21:44.670 --> 01:21:45.670
是不是搞定了

01:21:45.670 --> 01:21:46.670
搞定了

01:21:46.670 --> 01:21:49.690
那这种情况呢

01:21:51.690 --> 01:21:52.690
当前节点也不是

01:21:52.690 --> 01:21:53.690
但是同时

01:21:53.690 --> 01:21:54.690
已经到末尾了

01:21:54.690 --> 01:21:55.690
什么情况

01:21:55.690 --> 01:21:56.690
就这种情况

01:21:57.690 --> 01:21:59.690
我要找到节点是T

01:21:59.690 --> 01:22:00.690
怎么会没有这个节点

01:22:01.690 --> 01:22:02.690
都找到这了

01:22:02.690 --> 01:22:03.690
都还没有这个节点

01:22:03.690 --> 01:22:04.690
那怎么办呢

01:22:04.690 --> 01:22:05.690
没办法

01:22:05.690 --> 01:22:06.690
我只能把这个东西

01:22:06.690 --> 01:22:07.690
放到最后了

01:22:07.690 --> 01:22:08.690
那么这种情况

01:22:08.690 --> 01:22:09.690
就比较简单了

01:22:09.690 --> 01:22:10.690
就是新建个节点

01:22:10.690 --> 01:22:11.690
一样的

01:22:11.690 --> 01:22:12.690
新建个节点

01:22:12.690 --> 01:22:13.690
然后呢

01:22:13.690 --> 01:22:14.690
直接把当前节点

01:22:14.690 --> 01:22:15.690
下一个

01:22:16.690 --> 01:22:17.690
复制为T就行了

01:22:18.690 --> 01:22:19.690
当前节点下一个

01:22:19.690 --> 01:22:20.690
复制为new load

01:22:21.690 --> 01:22:22.690
对吧

01:22:22.690 --> 01:22:23.690
新建个节点

01:22:23.690 --> 01:22:24.690
把当前节点的下一个

01:22:24.690 --> 01:22:25.690
复制给T

01:22:25.690 --> 01:22:26.690
就完事了

01:22:27.690 --> 01:22:28.690
好来看一下

01:22:28.690 --> 01:22:31.450
那个insert

01:22:31.450 --> 01:22:32.450
insert

01:22:35.450 --> 01:22:36.450
insert

01:22:36.450 --> 01:22:37.450
节点

01:22:37.450 --> 01:22:38.450
就是这个链表

01:22:38.450 --> 01:22:39.450
我要在这个

01:22:39.450 --> 01:22:40.450
C后边

01:22:40.450 --> 01:22:41.450
插入一个K

01:22:43.450 --> 01:22:44.450
好看一下这个链表

01:22:44.450 --> 01:22:46.450
A B C

01:22:46.450 --> 01:22:48.450
C后边是变K了

01:22:48.450 --> 01:22:49.450
K后边变成了

01:22:49.450 --> 01:22:50.450
以前的D了

01:22:50.450 --> 01:22:51.450
对不对

01:22:51.450 --> 01:22:52.450
对不对

01:22:52.450 --> 01:22:55.210
D后边就没了

01:22:55.210 --> 01:22:56.210
插入

01:22:56.210 --> 01:22:57.210
然后我们看一下

01:22:57.210 --> 01:22:58.210
这种情况

01:22:58.210 --> 01:22:59.210
找不到的情况

01:22:59.210 --> 01:23:00.210
insert

01:23:00.210 --> 01:23:01.210
这个链表里面

01:23:01.210 --> 01:23:02.210
我们要找T后边加一个K

01:23:02.210 --> 01:23:03.210
但是没有T这个节点

01:23:03.210 --> 01:23:04.210
它只能加到末尾了

01:23:04.210 --> 01:23:05.210
好看一下

01:23:05.210 --> 01:23:06.210
A后边是B

01:23:06.210 --> 01:23:07.210
B后边是C

01:23:07.210 --> 01:23:08.210
C后边是K

01:23:09.210 --> 01:23:10.210
这个有问题

01:23:10.210 --> 01:23:11.210
有问题

01:23:11.210 --> 01:23:12.210
刷新意思

01:23:12.210 --> 01:23:15.540
看一下

01:23:16.540 --> 01:23:17.540
A后边是B

01:23:17.540 --> 01:23:18.540
B后边是C

01:23:18.540 --> 01:23:19.540
C后边是D

01:23:19.540 --> 01:23:20.540
D后边是K

01:23:20.540 --> 01:23:21.540
没问题的

01:23:21.540 --> 01:23:22.540
刚才应该是之前

01:23:22.540 --> 01:23:23.540
没刷新

01:23:23.540 --> 01:23:24.540
我只是把这里点了

01:23:24.540 --> 01:23:25.540
没刷新

01:23:26.540 --> 01:23:27.540
好 这边没问题了

01:23:29.540 --> 01:23:30.540
好 这是插入

01:23:30.540 --> 01:23:33.370
最后一个问题

01:23:33.370 --> 01:23:34.370
删除

01:23:35.370 --> 01:23:36.370
留给你们的自行思考

01:23:36.370 --> 01:23:38.370
明天我上课的时候

01:23:38.370 --> 01:23:39.370
再加

01:23:39.370 --> 01:23:40.370
好吧

01:23:41.370 --> 01:23:43.370
这个删除可能会有一点点复杂

01:23:43.370 --> 01:23:44.370
加油

01:23:44.370 --> 01:23:46.370
大家可以在群里边讨论

01:23:46.370 --> 01:23:48.370
怎么来去做删除

01:23:48.370 --> 01:23:50.370
一个链表 一个节点

01:23:50.370 --> 01:23:51.370
我把函数写到这

01:23:51.370 --> 01:23:52.370
你们去完成

01:23:52.370 --> 01:23:53.370
东西

01:23:53.370 --> 01:23:54.370
dnx

01:23:54.370 --> 01:23:56.370
或者要remove

01:23:56.370 --> 01:23:58.370
给我一个链表

01:23:59.370 --> 01:24:01.370
给我一个

01:24:01.370 --> 01:24:02.370
纸吧

01:24:02.370 --> 01:24:03.370
给我一个纸

01:24:03.370 --> 01:24:04.370
或者给我一个下标

01:24:04.370 --> 01:24:05.370
给我一个纸

01:24:05.370 --> 01:24:06.370
都行

01:24:06.370 --> 01:24:11.500
来

01:24:11.500 --> 01:24:14.500
删除指定值的节点

01:24:14.500 --> 01:24:16.500
不考虑

01:24:16.500 --> 01:24:19.500
链表中有重复的值

01:24:19.500 --> 01:24:20.500
不考虑

01:24:20.500 --> 01:24:21.500
不考虑

01:24:21.500 --> 01:24:22.500
就认为这个链表

01:24:22.500 --> 01:24:23.500
没有重复的值

01:24:23.500 --> 01:24:25.500
比不到一个就够了

01:24:25.500 --> 01:24:26.500
我们把它简化一点

01:24:26.500 --> 01:24:27.500
大家可以想一想

01:24:27.500 --> 01:24:28.500
怎么去做

01:24:28.500 --> 01:24:32.380
把这个问题留给你们

01:24:33.380 --> 01:24:35.380
明天我上课之前讲

01:24:35.380 --> 01:24:36.380
今天我们就

01:24:36.380 --> 01:24:37.380
差不多到这了

01:24:39.380 --> 01:24:40.380
也不算复杂

01:24:40.380 --> 01:24:41.380
也不算那么的简单

01:24:41.380 --> 01:24:42.380
可能对于一个同学

01:24:42.380 --> 01:24:43.380
不是那么适应

01:24:43.380 --> 01:24:44.380
一开始

01:24:44.380 --> 01:24:45.380
这个弹表

01:24:45.380 --> 01:24:46.380
其实不是那么适应

01:24:46.380 --> 01:24:47.380
慢慢去锻炼吧

01:24:48.380 --> 01:24:49.380
加油

01:24:49.380 --> 01:24:50.380
同学加油

01:24:50.380 --> 01:24:51.380
因为这个程序

01:24:51.380 --> 01:24:52.380
做开放

01:24:52.380 --> 01:24:53.380
肯定要经过这么一个阶段的

01:24:53.380 --> 01:24:55.380
有了这个阶段的集讯

01:24:55.380 --> 01:24:56.380
对之后

01:24:56.380 --> 01:24:57.380
你们以后遇到这些

01:24:57.380 --> 01:24:58.380
那些什么效果

01:24:58.380 --> 01:25:00.380
就觉得非常非常简单

01:25:00.380 --> 01:25:01.380
好了

01:25:02.380 --> 01:25:03.380
那就吧

01:25:03.380 --> 01:25:04.380
今天我们就

01:25:04.380 --> 01:25:05.380
时间也差不多了

01:25:05.380 --> 01:25:06.380
今天我就到这

01:25:06.380 --> 01:25:07.380
接下来

01:25:07.380 --> 01:25:08.380
大家不要离开

01:25:08.380 --> 01:25:09.380
弹表以后

01:25:09.380 --> 01:25:10.380
就发给你们

01:25:10.380 --> 01:25:11.380
不要离开

01:25:11.380 --> 01:25:12.380
那个徐老师

01:25:13.380 --> 01:25:14.380
徐老师

01:25:14.380 --> 01:25:15.380
给大家欣送一下

01:25:15.380 --> 01:25:17.380
让大家表演一个

01:25:17.380 --> 01:25:18.380
展家的节目

01:25:18.380 --> 01:25:19.380
好徐老师在吗

01:25:20.380 --> 01:25:21.380
好

01:25:21.380 --> 01:25:22.380
OK

01:25:22.380 --> 01:25:23.380
我在这边交给你的

