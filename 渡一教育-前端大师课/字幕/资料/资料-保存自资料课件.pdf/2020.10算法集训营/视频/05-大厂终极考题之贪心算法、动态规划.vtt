WEBVTT

00:01.140 --> 00:06.140
刚才看到了这么一个眼睛好像会了一点

00:06.140 --> 00:09.140
手和脑子 你放屁

00:09.140 --> 00:14.140
这个玩意有点相极了我在抖音上看魔术解密

00:14.140 --> 00:17.140
极向

00:17.140 --> 00:20.140
所以白了就是要多练习一下

00:20.140 --> 00:24.140
不多练习的话你光是听是没有多少效果的

00:24.140 --> 00:27.140
来吧 今天咱们最后一天了

00:27.140 --> 00:29.140
最后一天呢

00:29.140 --> 00:32.140
咱们的算法课呢 虽然说只有五天时间

00:32.140 --> 00:34.140
每天也只有一个半小时

00:34.140 --> 00:37.140
但是呢 课程水小 武藏俱全

00:37.140 --> 00:39.140
基本上把那个算法里边啊

00:39.140 --> 00:43.140
呃 常见的一些问题啊都拿出来讲了

00:43.140 --> 00:46.140
算法和数据结构呢 他们联系的比较紧密

00:46.140 --> 00:48.140
在大城的面试底当中呢

00:48.140 --> 00:50.140
呃 很用可能就是把数据结构呢

00:50.140 --> 00:52.140
拿出一些基本的算法来考察的

00:52.140 --> 00:56.140
呃 另外一些呢 就是数据结构啊跟算法呀

00:56.140 --> 00:58.140
一旦是个数据结构 它的算法呢

00:58.140 --> 01:00.140
相对来说比较固定

01:00.140 --> 01:02.140
比方说 图

01:02.140 --> 01:04.140
图的搜索 深搜和广搜

01:04.140 --> 01:07.140
数的深搜和广搜 对吧 数的层次

01:07.140 --> 01:09.140
啊 计算数的层次

01:09.140 --> 01:12.140
那么这些呢 呃 都是

01:12.140 --> 01:14.140
比较固定的啊 比方说排序算法

01:14.140 --> 01:15.140
就那么一些排序

01:15.140 --> 01:17.140
然后都相当于是比较固定的

01:17.140 --> 01:20.140
你去研究研究一种文汇

01:20.140 --> 01:22.140
但是呢 有些算法呢

01:22.140 --> 01:24.140
它就不是很固定的

01:25.140 --> 01:27.140
它变成了一个现实问题

01:27.140 --> 01:29.140
拿一个现实问题来考察你

01:29.140 --> 01:31.140
如果说你们将来在就业大厂

01:31.140 --> 01:33.140
或者是高薪的时候

01:33.140 --> 01:35.140
出现了这么一种算法题

01:35.140 --> 01:37.140
那就比较骚扰了

01:37.140 --> 01:39.140
因为你一定没有见过

01:39.140 --> 01:42.140
它跟你出了题啊 是你一定没有见过的

01:42.140 --> 01:44.140
它不可能说 拿一个

01:44.140 --> 01:46.140
以前出过的题来考察你

01:46.140 --> 01:48.140
往上受得到的 不太会啊

01:48.140 --> 01:49.140
一般来说就是一个

01:49.140 --> 01:51.140
从来没有遇到过的问题

01:51.140 --> 01:53.140
让你临时的去想 去想方案

01:53.140 --> 01:55.140
这样就比较难度了

01:55.140 --> 01:57.140
那么今天晚上咱们就来说

01:57.140 --> 01:58.140
这种类型的题

01:58.140 --> 02:00.140
那么这种类型的题呢

02:00.140 --> 02:02.140
千奇百怪

02:02.140 --> 02:05.140
而且呢 你很难去找到一些规律

02:05.140 --> 02:07.140
那么在这些题里边呢

02:07.140 --> 02:09.140
用的比较多的这种思路啊

02:09.140 --> 02:10.140
只能说一个方向

02:10.140 --> 02:11.140
一个大致的方向

02:11.140 --> 02:12.140
一个大致的思路呢

02:12.140 --> 02:13.140
用的比较多的

02:13.140 --> 02:15.140
就是贪心算法和动态规划

02:15.140 --> 02:16.140
当然不是说

02:16.140 --> 02:18.140
我今天晚上一讲贪心算法

02:18.140 --> 02:19.140
一讲动态规划

02:19.140 --> 02:20.140
那么以后你们

02:20.140 --> 02:22.140
凡是动态规划的题

02:22.140 --> 02:23.140
你都会做了

02:23.140 --> 02:25.140
但是不可能的

02:25.140 --> 02:26.140
因为这里边

02:26.140 --> 02:27.140
你在去具体问题

02:27.140 --> 02:28.140
具体分析

02:28.140 --> 02:30.140
到底用贪心算法好一点

02:30.140 --> 02:32.140
可能还是用动态规划好一点

02:32.140 --> 02:34.140
具体问题具体分析

02:34.140 --> 02:35.140
那么落到实处的时候

02:35.140 --> 02:37.140
比方说我用动态规划

02:37.140 --> 02:39.140
那么具体怎么去规划

02:39.140 --> 02:40.140
这个一路是要具体问题

02:40.140 --> 02:41.140
具体分析

02:41.140 --> 02:42.140
说这一部分的题啊

02:42.140 --> 02:44.140
极其的灵活

02:44.140 --> 02:46.140
它能数据结构

02:46.140 --> 02:47.140
没有必然的联系

02:47.140 --> 02:49.140
它需要你灵活

02:49.140 --> 02:50.140
具体的问题去具体分析

02:50.140 --> 02:53.140
具体去处理

02:53.140 --> 02:54.140
那么我们今天晚上的

02:54.140 --> 02:56.140
会有三道联系题

02:56.140 --> 02:58.140
来给大家体验一下

02:58.140 --> 02:59.140
贪心算法的动态规划

02:59.140 --> 03:01.140
到底是一个什么回事

03:01.140 --> 03:04.140
首先我们来说这个贪心算法

03:04.140 --> 03:05.140
这个玩意儿呢

03:05.140 --> 03:06.140
其实就是我们

03:06.140 --> 03:08.140
昨天讲那个普林姆算法

03:08.140 --> 03:09.140
普林姆算法

03:09.140 --> 03:12.140
就是典型的贪心算法

03:12.140 --> 03:14.140
啥叫贪心算法呀

03:14.140 --> 03:16.140
就是我不考虑全局

03:16.140 --> 03:18.140
我就管我眼前

03:18.140 --> 03:20.140
我就管眼前

03:20.140 --> 03:23.140
我能够拿到一个最优的解

03:23.140 --> 03:25.140
我就拿拿

03:25.140 --> 03:26.140
拿完了过后了

03:26.140 --> 03:27.140
下一步

03:27.140 --> 03:28.140
我又能拿到一个最优解

03:28.140 --> 03:30.140
我又去拿

03:30.140 --> 03:31.140
拿完了之后

03:31.140 --> 03:33.140
就是一个整体的最优解

03:33.140 --> 03:34.140
啥意思呢

03:34.140 --> 03:35.140
你们玩游戏

03:35.140 --> 03:36.140
我也不知道你们

03:36.140 --> 03:37.140
现在玩啥游戏

03:37.140 --> 03:38.140
比方说我玩什么

03:38.140 --> 03:40.140
那个什么英雄联盟

03:40.140 --> 03:42.140
或者说那个王者荣耀

03:42.140 --> 03:43.140
对吧

03:43.140 --> 03:44.140
哎

03:44.140 --> 03:46.140
下路已经残血了

03:46.140 --> 03:47.140
去不去啊

03:47.140 --> 03:49.140
如果说贪心算法的话

03:49.140 --> 03:50.140
那我一定去

03:50.140 --> 03:51.140
我不考虑全局的

03:51.140 --> 03:52.140
我不管有些人

03:52.140 --> 03:53.140
有没有人在拆我家

03:53.140 --> 03:54.140
有没有人在打大楼

03:54.140 --> 03:55.140
我不管

03:55.140 --> 03:56.140
我看到他残血了

03:56.140 --> 03:57.140
我一定不杀过去

03:57.140 --> 03:59.140
我也不管我现在的血量是多少

03:59.140 --> 04:00.140
就是贪心算法

04:00.140 --> 04:03.140
就大可这么去体会一下

04:03.140 --> 04:05.140
就是我只管眼前

04:05.140 --> 04:06.140
你看昨天的普林姆算法

04:06.140 --> 04:07.140
是不是只管眼前

04:07.140 --> 04:08.140
我只管目前

04:08.140 --> 04:10.140
到这个村落中

04:10.140 --> 04:11.140
最近的那个点

04:11.140 --> 04:12.140
是啥

04:12.140 --> 04:13.140
连接写完事了

04:13.140 --> 04:14.140
我不考虑全局的

04:14.140 --> 04:15.140
我也不考虑说

04:15.140 --> 04:16.140
我连了这个点过后

04:16.140 --> 04:18.140
会不会造成后续的问题啊

04:18.140 --> 04:19.140
我不考虑的

04:19.140 --> 04:20.140
我就管眼前

04:20.140 --> 04:21.140
这有贪心算法

04:21.140 --> 04:22.140
贪心算法

04:22.140 --> 04:24.140
因为他这种模式啊

04:24.140 --> 04:26.140
他的计算效率是极其高的

04:26.140 --> 04:27.140
为什么呢

04:27.140 --> 04:29.140
因为我考虑的很少

04:29.140 --> 04:32.140
我就考虑这一次的最有解

04:32.140 --> 04:34.140
我不考虑什么全局

04:34.140 --> 04:35.140
哎有的时候呢

04:35.140 --> 04:36.140
就臭巧了

04:36.140 --> 04:37.140
比方说像昨天的普林姆算法

04:37.140 --> 04:40.140
我每一次拿局部的最有解

04:40.140 --> 04:41.140
累计出来

04:41.140 --> 04:43.140
哎就是一个全局的最有解

04:43.140 --> 04:45.140
那么这样子的

04:45.140 --> 04:46.140
这种场景呢

04:46.140 --> 04:49.140
就非常适合用贪心算法

04:49.140 --> 04:50.140
那么今天呢

04:50.140 --> 04:51.140
我给大家再看一道题啊

04:51.140 --> 04:55.140
就是一个经典的找零问题

04:55.140 --> 04:56.140
什么叫找零问题

04:56.140 --> 04:58.140
大家看一下这个题

04:58.140 --> 04:59.140
假设呢

04:59.140 --> 05:01.140
你开了一家商店

05:01.140 --> 05:02.140
这个时候

05:02.140 --> 05:03.140
商店里面有个系统

05:03.140 --> 05:04.140
比方说

05:04.140 --> 05:06.140
科普给力给力的一些钱啊

05:06.140 --> 05:07.140
这个钱呢

05:07.140 --> 05:08.140
然后你计算出掉

05:08.140 --> 05:09.140
找多少钱

05:09.140 --> 05:10.140
那我要找多少钱

05:10.140 --> 05:11.140
很好计算

05:11.140 --> 05:13.140
我们客户给的钱

05:13.140 --> 05:15.140
去商品的价格

05:15.140 --> 05:16.140
就是要找到钱

05:16.140 --> 05:18.140
比方说我们要找46分钱

05:18.140 --> 05:20.140
啊硬币

05:20.140 --> 05:22.140
而我在货柜里边呢

05:22.140 --> 05:23.140
有面额

05:23.140 --> 05:24.140
有这么一些面额

05:24.140 --> 05:25.140
当然不是人民币的面额

05:25.140 --> 05:26.140
就举个例子

05:26.140 --> 05:28.140
有25分

05:28.140 --> 05:29.140
有10分

05:29.140 --> 05:30.140
有5分

05:30.140 --> 05:31.140
有1分

05:31.140 --> 05:32.140
有这么一些面额的硬币

05:32.140 --> 05:33.140
那么现在呢

05:33.140 --> 05:35.140
我们的系统需要计算

05:35.140 --> 05:36.140
因为营业

05:36.140 --> 05:37.140
也营业员一天

05:37.140 --> 05:38.140
找钱子

05:38.140 --> 05:39.140
反复的去找

05:39.140 --> 05:40.140
找到头昏脑脏

05:40.140 --> 05:41.140
就保不清

05:41.140 --> 05:42.140
可能会出错

05:42.140 --> 05:44.140
所以说需要系统给他算出来

05:44.140 --> 05:45.140
怎么样找

05:45.140 --> 05:47.140
用到的硬币数最小

05:47.140 --> 05:48.140
就跟他说一个结果

05:48.140 --> 05:50.140
比方说你25分

05:50.140 --> 05:51.140
找一个10分

05:51.140 --> 05:52.140
找两个

05:52.140 --> 05:53.140
5分找一个

05:53.140 --> 05:54.140
1分找一个

05:54.140 --> 05:55.140
这样子的营业员

05:55.140 --> 05:56.140
就看着这个屏幕

05:56.140 --> 05:57.140
就把它找完了

05:57.140 --> 05:58.140
什么意思呢

05:58.140 --> 06:00.140
所以我们要设计一个算法

06:00.140 --> 06:01.140
怎么样做

06:01.140 --> 06:02.140
才能保证

06:02.140 --> 06:04.140
我找的金额是准确的

06:04.140 --> 06:05.140
同时呢

06:05.140 --> 06:09.770
用到的硬币数最小

06:09.770 --> 06:10.770
其实这个就是

06:10.770 --> 06:12.770
求一个全局的最优节

06:12.770 --> 06:13.770
我怎么样做

06:13.770 --> 06:15.770
才能得到一个全局的

06:15.770 --> 06:17.770
最好的结果

06:17.770 --> 06:18.770
那么有的时候呢

06:18.770 --> 06:20.770
我们可以把这个全局的最优节

06:20.770 --> 06:21.770
切分为

06:21.770 --> 06:23.770
一些一个一个的局部问题

06:23.770 --> 06:25.770
我们去寻求局部的最优节

06:25.770 --> 06:28.770
就像我们昨天的普林母算法

06:28.770 --> 06:30.770
我只管这一次

06:30.770 --> 06:31.770
找到最近的个春落

06:31.770 --> 06:33.770
就可以了

06:33.770 --> 06:34.770
那么这个找零问题呢

06:34.770 --> 06:36.770
我们仍然可以这样做

06:36.770 --> 06:38.770
我们只要能够保证

06:38.770 --> 06:40.770
局部的最优节

06:40.770 --> 06:41.770
给加起来

06:41.770 --> 06:42.770
就是全局最优节

06:42.770 --> 06:43.770
那么我们就可以用这种

06:43.770 --> 06:44.770
参与算法

06:44.770 --> 06:45.770
参与算法就是这样子做的

06:45.770 --> 06:46.770
好

06:46.770 --> 06:48.770
咱们来看一下找零问题啊

06:48.770 --> 06:54.870
打开一下

06:54.870 --> 06:55.870
好 这里呢

06:55.870 --> 06:57.870
我们新建文件

06:57.870 --> 06:58.870
找零问题

06:58.870 --> 06:59.870
exchange

06:59.870 --> 07:08.220
找零问题

07:08.220 --> 07:09.220
比方说

07:09.220 --> 07:10.220
我们现在需要

07:10.220 --> 07:11.220
设计这么一个函数

07:11.220 --> 07:12.220
这个函数的名字呢

07:12.220 --> 07:13.220
就叫做exchange

07:13.220 --> 07:15.220
找零

07:15.220 --> 07:16.220
然后呢

07:16.220 --> 07:18.220
这个函数有两个参数

07:18.220 --> 07:20.220
就是你找零的数

07:20.220 --> 07:22.220
你一定要找多少钱

07:22.220 --> 07:24.220
偷偷

07:24.220 --> 07:25.220
第二个参数呢

07:25.220 --> 07:27.220
就是目前的面额

07:27.220 --> 07:28.220
目前的面额呢

07:28.220 --> 07:30.220
用

07:30.220 --> 07:31.220
我就不知道

07:31.220 --> 07:32.220
面额用啥

07:32.220 --> 07:33.220
用啥单词

07:33.220 --> 07:34.220
我查一下

07:34.220 --> 07:36.220
查一下面额

07:36.220 --> 07:40.490
面额

07:40.490 --> 07:42.490
一汉池殿

07:42.490 --> 07:44.490
delomination

07:44.490 --> 07:48.120
那就delomination

07:48.120 --> 07:50.120
好 这是面额

07:50.120 --> 07:51.120
打个注释啊

07:51.120 --> 07:52.120
这个偷偷表示

07:52.120 --> 07:54.120
一共要找的函数

07:54.120 --> 07:56.120
找零

07:56.120 --> 07:57.120
函数

07:57.120 --> 07:59.120
这个delomination呢

07:59.120 --> 08:01.120
表示目前的面额

08:01.120 --> 08:03.120
目前的面额

08:03.120 --> 08:04.120
好 那么到时候

08:04.120 --> 08:05.120
我调用这个方法的话

08:05.120 --> 08:06.120
怎么来调用呢

08:06.120 --> 08:07.120
我就需要

08:07.120 --> 08:08.120
调用这样子

08:08.120 --> 08:10.120
比方说找46分钱

08:10.120 --> 08:11.120
面额有哪些呢

08:11.120 --> 08:12.120
有25一个数组

08:12.120 --> 08:13.120
马上进去

08:13.120 --> 08:16.120
有25 有10 有5 有1

08:16.120 --> 08:18.120
好 他会返回一个结果

08:18.120 --> 08:19.120
返回的结果呢

08:19.120 --> 08:20.120
是一个数组

08:21.120 --> 08:22.120
接受一下

08:22.120 --> 08:23.120
然后输出这个数组

08:23.120 --> 08:25.120
比方说这个数组

08:25.120 --> 08:26.120
期望的结果

08:26.120 --> 08:28.120
期望的结果是啥

08:28.120 --> 08:30.120
最好的找零结果是啥

08:30.120 --> 08:31.120
这就是

08:31.120 --> 08:33.120
25找一个

08:33.120 --> 08:35.120
10分找一个

08:35.120 --> 08:36.120
再10分找一个

08:36.120 --> 08:37.120
对吧

08:37.120 --> 08:38.120
然后呢 就是45了

08:38.120 --> 08:40.120
然后再找一块

08:40.120 --> 08:41.120
找一分

08:41.120 --> 08:43.120
这就是我们的期望的结果

08:43.120 --> 08:44.120
也就是说

08:44.120 --> 08:45.120
我们这个函数

08:45.120 --> 08:46.120
就要得到这样的结果

08:46.120 --> 08:48.500
那么大家看一下

08:48.500 --> 08:50.500
这样的结果是怎么出来的

08:50.500 --> 08:51.500
你想一想

08:51.500 --> 08:52.500
你不用程序来写

08:52.500 --> 08:53.500
你就是用人来找

08:53.500 --> 08:56.500
你的脑袋是怎么去思维的

08:56.500 --> 08:57.500
比方说你们就

08:57.500 --> 08:59.500
以现实生活中吧

08:59.500 --> 09:01.500
我们要找75块钱

09:01.500 --> 09:02.500
76块钱

09:02.500 --> 09:04.500
你怎么找的

09:04.500 --> 09:05.500
是不是一定

09:05.500 --> 09:07.500
我们心里边是这样的想的

09:07.500 --> 09:08.500
我们尝试着

09:08.500 --> 09:10.500
用注意大的面额去匹配

09:10.500 --> 09:12.500
看能不能找

09:12.500 --> 09:13.500
不能找的话

09:13.500 --> 09:14.500
就退而求其次

09:14.500 --> 09:16.500
用第二大的面额去匹配

09:16.500 --> 09:18.500
明儿的意思吧

09:18.500 --> 09:19.500
比方说我们

09:19.500 --> 09:21.500
我们有100的面额

09:21.500 --> 09:23.500
100也找不了

09:23.500 --> 09:25.500
76块钱找不了100

09:25.500 --> 09:27.500
那么我们就用第二大的面额

09:27.500 --> 09:29.500
是不是用50

09:29.500 --> 09:31.500
用50的面额去看一下

09:31.500 --> 09:33.500
50的面额能不能找

09:33.500 --> 09:35.500
懂那意思吧

09:35.500 --> 09:37.500
咱们用这种模式

09:37.500 --> 09:38.500
来做

09:38.500 --> 09:39.500
这种模式实际上

09:39.500 --> 09:41.500
它就是一个弹形算法

09:41.500 --> 09:42.500
我每一次

09:42.500 --> 09:43.500
我也不管这一次面额

09:43.500 --> 09:44.500
找了过后

09:44.500 --> 09:45.500
剩下的情况

09:45.500 --> 09:46.500
是不是最有解

09:46.500 --> 09:47.500
我就先找了再说

09:47.500 --> 09:48.500
面额尝试去找

09:48.500 --> 09:50.500
找了再说

09:50.500 --> 09:52.500
就是这么个意思

09:52.500 --> 09:53.500
好

09:53.500 --> 09:54.500
那么接下来

09:54.500 --> 09:55.500
也就是说

09:55.500 --> 09:57.500
我要做的事情是什么呢

09:57.500 --> 09:59.500
我这个找零

09:59.500 --> 10:00.500
我要目标是要

10:00.500 --> 10:01.500
把这个东西找完

10:01.500 --> 10:02.500
对不对

10:02.500 --> 10:04.500
把这个找零的种数找完

10:04.500 --> 10:05.500
那么我们这里

10:05.500 --> 10:06.500
要不断的去找

10:06.500 --> 10:07.500
不断的尝试去找

10:07.500 --> 10:08.500
那么我们这里

10:08.500 --> 10:09.500
可以写个外要循环

10:09.500 --> 10:10.500
什么时候

10:10.500 --> 10:12.500
我要继续尝试去找呢

10:12.500 --> 10:14.500
就是我还有钱要找

10:14.500 --> 10:16.500
对吧

10:16.500 --> 10:19.500
没有钱需要找

10:19.500 --> 10:20.500
对

10:20.500 --> 10:22.500
继续找零

10:22.500 --> 10:23.500
所以我们可以写出

10:23.500 --> 10:24.500
这个外要循环

10:24.500 --> 10:25.500
然后呢

10:25.500 --> 10:27.500
我们需要一个结果的数组

10:27.500 --> 10:33.600
这是存放找零结果的数组

10:33.600 --> 10:37.600
存放找零结果的数组

10:37.600 --> 10:38.600
因为这个数组呢

10:38.600 --> 10:39.600
比方说我找了一个零

10:39.600 --> 10:40.600
找了25

10:40.600 --> 10:41.600
我就往这个数组里面放一下

10:41.600 --> 10:42.600
同意是吧

10:42.600 --> 10:43.600
我们先把这个东西

10:43.600 --> 10:44.600
准备好

10:44.600 --> 10:45.600
有一个找零的数组

10:45.600 --> 10:47.600
然后呢有个找零的种数

10:47.600 --> 10:48.600
只要找零的种数

10:48.600 --> 10:49.600
说明还有钱需要找

10:49.600 --> 10:51.600
那么我们得继续找

10:51.600 --> 10:52.600
最后呢

10:52.600 --> 10:54.600
我们当然毫无疑问的

10:54.600 --> 10:55.600
就返回这个围道子

10:55.600 --> 10:56.600
因为除了这个外要循环

10:56.600 --> 10:58.600
是不是一定找完了

10:58.600 --> 10:59.600
他没有找完

10:59.600 --> 11:00.600
还得继续循环

11:00.600 --> 11:01.600
除了循环

11:01.600 --> 11:02.600
一定是找完了

11:02.600 --> 11:06.170
这个代码结构能看懂吗

11:06.170 --> 11:07.170
能看懂QQ1

11:07.170 --> 11:08.170
到了第五天了

11:08.170 --> 11:09.170
这个代码结构呢

11:09.170 --> 11:10.170
应该很多同学都能看懂了

11:10.170 --> 11:13.860
OK

11:13.860 --> 11:14.860
好

11:14.860 --> 11:15.860
那么我们接下来

11:15.860 --> 11:16.860
在外要循环里边写

11:16.860 --> 11:17.860
这里边咋写呢

11:17.860 --> 11:18.860
就是你就想

11:18.860 --> 11:19.860
循环里边就是

11:19.860 --> 11:20.860
每一次要做什么

11:20.860 --> 11:22.860
每一次我要做啥呢

11:22.860 --> 11:23.860
刚才什么时候分析过的

11:23.860 --> 11:25.860
每一次我要做的事情就是

11:25.860 --> 11:28.860
尝试着用最大的面额

11:28.860 --> 11:30.860
去找零

11:30.860 --> 11:31.860
我也不管找了过后

11:31.860 --> 11:32.860
后面会怎么样

11:32.860 --> 11:33.860
我不管

11:33.860 --> 11:34.860
我就要用最大面额去找

11:34.860 --> 11:35.860
这就是贪心算法

11:35.860 --> 11:37.860
我不考虑

11:37.860 --> 11:39.860
这一次对后面造成的影响

11:39.860 --> 11:40.860
我就考虑这一次

11:40.860 --> 11:41.860
是不是最优的

11:41.860 --> 11:42.860
是不是局部最优的

11:42.860 --> 11:43.860
好是局部最优

11:43.860 --> 11:44.860
我就可以

11:44.860 --> 11:46.860
我就直接拿来用

11:46.860 --> 11:49.860
他要算法的效率是极其高的

11:49.860 --> 11:50.860
那么这里怎么找呢

11:50.860 --> 11:52.860
其实这里要做的事情就是

11:52.860 --> 11:58.860
找出面额中最大的

11:58.860 --> 12:00.860
能找的面额

12:00.860 --> 12:01.860
你不能说是最大的面额

12:01.860 --> 12:03.860
比方说最大的面额有100的

12:03.860 --> 12:04.860
比方说这里面额有100

12:04.860 --> 12:06.860
100肯定不能用

12:06.860 --> 12:08.860
也就是说我们要能找

12:08.860 --> 12:09.860
这个面额至少要能找

12:09.860 --> 12:11.860
同时它是最大面额

12:11.860 --> 12:13.860
那么这个实际上是一个

12:13.860 --> 12:15.860
变种的求最大的问题

12:15.860 --> 12:17.860
只是条件变了一下

12:17.860 --> 12:18.860
那么现在就转换成了一个

12:18.860 --> 12:19.860
什么

12:19.860 --> 12:21.860
转换成了一个求最大值的问题

12:21.860 --> 12:23.860
那么在学了 CS 也好

12:23.860 --> 12:24.860
学了加瓦也好

12:24.860 --> 12:25.860
学了什么

12:25.860 --> 12:26.860
关系把它任何语言

12:26.860 --> 12:28.860
你只要学过循环

12:28.860 --> 12:29.860
你都得会

12:29.860 --> 12:31.860
这种基本的求最大值

12:31.860 --> 12:32.860
去小值的问题

12:32.860 --> 12:34.860
那么我们怎么求

12:34.860 --> 12:36.860
最大值先来一个

12:36.860 --> 12:38.860
最大值先来一个

12:38.860 --> 12:39.860
拉我也好

12:39.860 --> 12:40.860
0也好

12:40.860 --> 12:41.860
或者是负的以菲的体也好

12:41.860 --> 12:42.860
负无穷大也好

12:42.860 --> 12:43.860
总之呢

12:43.860 --> 12:44.860
你先给他一个

12:44.860 --> 12:45.860
求是值

12:45.860 --> 12:47.860
小的不能占小的值

12:47.860 --> 12:49.860
后面他只要发现比他大的

12:49.860 --> 12:50.860
就替换他

12:50.860 --> 12:51.860
然后循环

12:51.860 --> 12:52.860
循环啥

12:52.860 --> 12:53.860
循环所谓的面额

12:53.860 --> 12:55.860
我们要从面额东去找

12:55.860 --> 12:57.860
当然在循环所谓的面额

13:01.500 --> 13:02.500
好

13:02.500 --> 13:03.500
每一次循环

13:03.500 --> 13:04.500
是不是拿到这个面额

13:04.500 --> 13:06.500
看一下这个面额

13:06.500 --> 13:08.500
首先看一下这个面额

13:08.500 --> 13:11.500
是不是比这个 Max 大

13:11.500 --> 13:13.500
比他大说明啥

13:13.500 --> 13:14.500
说明是不是

13:14.500 --> 13:16.500
还有一个面额比他大呀

13:16.500 --> 13:18.500
但是光比他大还不行

13:18.500 --> 13:19.500
还有一个条件

13:19.500 --> 13:20.500
请问同学

13:20.500 --> 13:22.500
这个条件问号位置

13:22.500 --> 13:23.500
应该写啥

13:23.500 --> 13:25.500
那么这个判断里面

13:25.500 --> 13:26.500
当然非常简单的

13:26.500 --> 13:28.500
就是这样的写法

13:28.500 --> 13:30.500
就是说我找到一个面额

13:30.500 --> 13:31.500
比他还要大

13:31.500 --> 13:32.500
那么肯定要把他

13:32.500 --> 13:33.500
重新复制给他

13:33.500 --> 13:34.500
对吧

13:34.500 --> 13:35.500
那么他要记住

13:35.500 --> 13:36.500
更大的面额

13:36.500 --> 13:37.500
但是呢

13:37.500 --> 13:38.500
光大没用

13:38.500 --> 13:39.500
还有一个条件是啥

13:39.500 --> 13:40.500
这个问号位置写啥

13:40.500 --> 13:41.500
前功体

13:41.500 --> 13:50.220
来把代码补完

13:50.220 --> 13:51.220
对不对

13:51.220 --> 13:54.220
他小于等于头头

13:54.220 --> 13:56.220
等于也是可以的

13:56.220 --> 13:57.220
比方说还剩下5块钱

13:57.220 --> 13:58.220
需要找到

13:58.220 --> 14:00.220
找到就不就是5块吗

14:00.220 --> 14:01.220
等于也是可以的

14:01.220 --> 14:02.220
非常好

14:02.220 --> 14:03.220
所以这个面额

14:03.220 --> 14:05.220
不仅要比他大

14:05.220 --> 14:06.220
台呢

14:06.220 --> 14:08.220
要小于等于头头

14:08.220 --> 14:09.220
就说我要能找

14:09.220 --> 14:10.220
那么这样子

14:10.220 --> 14:11.220
一找出来

14:11.220 --> 14:12.220
是不是

14:12.220 --> 14:13.220
以这个循环

14:13.220 --> 14:14.220
一结束

14:14.220 --> 14:16.220
这个边疆里边一定记住了

14:16.220 --> 14:18.220
我目前能找的

14:18.220 --> 14:19.220
最大面额

14:19.220 --> 14:20.220
对不对

14:20.220 --> 14:21.220
里边记住的是

14:21.220 --> 14:23.220
目前能找的最大面额

14:23.220 --> 14:24.220
那是不是找出来了

14:24.220 --> 14:26.220
局部就有解释的求出来了

14:26.220 --> 14:27.220
求出来怎么办

14:27.220 --> 14:28.220
剩下的事情就很简单了

14:28.220 --> 14:29.220
那我就找呗

14:29.220 --> 14:30.220
我根本就不用

14:30.220 --> 14:31.220
考虑后边的东西

14:31.220 --> 14:32.220
我直接找

14:32.220 --> 14:34.220
那么现在就结束

14:34.220 --> 14:38.220
加入干面额

14:38.220 --> 14:40.220
这张全会一定找出去

14:40.220 --> 14:42.220
我不管后边

14:42.220 --> 14:43.220
然后呢

14:43.220 --> 14:45.220
我的找零总数

14:45.220 --> 14:47.220
是要减去

14:47.220 --> 14:48.220
next

14:48.220 --> 14:49.220
对吧

14:49.220 --> 14:51.220
找零总数减少

14:51.220 --> 14:52.220
因为我找了

14:52.220 --> 14:54.220
找零总数减少

14:54.220 --> 14:56.220
这就是弹性删

14:56.220 --> 14:57.220
你说它的效率有多高

14:57.220 --> 14:59.220
效率非常非常高

14:59.220 --> 15:00.220
它没有回数

15:00.220 --> 15:01.220
它不是说

15:01.220 --> 15:02.220
我不回过来看

15:02.220 --> 15:04.220
什么叫回过来看呢

15:04.220 --> 15:06.220
不知道大家想不想过下棋啊

15:06.220 --> 15:08.220
下棋下棋的时候

15:08.220 --> 15:10.220
就特别典型的例子

15:10.220 --> 15:11.220
就是我走这一步棋

15:11.220 --> 15:12.220
有个棋放在这儿了

15:12.220 --> 15:13.220
等着我吃

15:13.220 --> 15:14.220
弹性删法是吗

15:14.220 --> 15:15.220
我马上就把吃了

15:15.220 --> 15:18.220
我管的不管后边了

15:18.220 --> 15:19.220
但是呢

15:19.220 --> 15:21.220
如果说你要考虑全局的话

15:21.220 --> 15:22.220
你是不是还得想一想

15:22.220 --> 15:23.220
我这个吃了

15:23.220 --> 15:25.220
会对我后续的指力

15:25.220 --> 15:27.220
造成什么样的影响呢

15:27.220 --> 15:28.220
会对我整个棋局

15:28.220 --> 15:31.220
有没有更不好的影响呢

15:31.220 --> 15:34.220
我要往后边想很多很多的部

15:34.220 --> 15:35.220
然后我再来决定

15:35.220 --> 15:36.220
要不要吃

15:36.220 --> 15:37.220
但是弹性删法没有

15:37.220 --> 15:38.220
弹性删法我不管

15:38.220 --> 15:39.220
我就管眼前

15:39.220 --> 15:41.220
眼前是最优的

15:41.220 --> 15:43.220
那我整个全局就是最优的

15:43.220 --> 15:44.220
对吧

15:44.220 --> 15:46.220
那么如果说

15:46.220 --> 15:48.220
将来你们遇到一些问题啊

15:48.220 --> 15:51.220
局部最优解就是全局最优解

15:51.220 --> 15:53.220
大胆的使用弹性删法

15:53.220 --> 15:54.220
它的效率极高

15:54.220 --> 15:55.220
好

15:55.220 --> 15:56.220
咱们来看一下这个藻林

15:56.220 --> 15:59.550
藻林结果

15:59.550 --> 16:00.550
当然最难的

16:00.550 --> 16:01.550
也就是判断

16:01.550 --> 16:02.550
它到底是不是一个

16:02.550 --> 16:03.550
全局最优解

16:03.550 --> 16:05.550
这是最难的

16:05.550 --> 16:06.550
好你看

16:06.550 --> 16:07.550
是不是找出来了

16:07.550 --> 16:09.550
二十五十十一

16:09.550 --> 16:10.550
对不对

16:10.550 --> 16:11.550
是不是最优解

16:11.550 --> 16:13.550
这就是个最优解

16:13.550 --> 16:14.550
还有比这个更优的吗

16:14.550 --> 16:15.550
没有了

16:15.550 --> 16:17.550
不要说我再来一个例子

16:17.550 --> 16:20.550
不要说我要找七十六块钱

16:20.550 --> 16:21.550
你看一下

16:21.550 --> 16:22.550
找出来的结果

16:22.550 --> 16:24.550
三个二十五

16:24.550 --> 16:25.550
就是七十五

16:25.550 --> 16:27.550
再找一个一块

16:27.550 --> 16:28.550
说最优解

16:28.550 --> 16:31.550
当然是最优解

16:31.550 --> 16:32.550
也就是说呢

16:32.550 --> 16:34.550
目前的情况下

16:34.550 --> 16:36.550
在我们这个面额

16:36.550 --> 16:38.550
面额的规则下

16:38.550 --> 16:39.550
藻林问题呢

16:39.550 --> 16:42.550
是可以用弹性删法

16:42.550 --> 16:44.550
包括我们现实生活中

16:44.550 --> 16:45.550
现实生活中是什么呢

16:45.550 --> 16:46.550
一百块钱

16:46.550 --> 16:48.550
五十块钱

16:48.550 --> 16:50.550
二十块钱

16:50.550 --> 16:52.550
然后还有十块钱

16:52.550 --> 16:53.550
还有五块钱

16:53.550 --> 16:54.550
还有两块

16:54.550 --> 16:55.550
现在还有两块

16:55.550 --> 16:56.550
好像有

16:56.550 --> 16:58.550
两块钱一块钱

16:58.550 --> 17:00.550
在这种面额设置下面

17:00.550 --> 17:02.550
是非常适合用弹性删法

17:02.550 --> 17:04.550
比方说我们找七十六

17:04.550 --> 17:05.550
看一下

17:05.550 --> 17:06.550
在这种面额情况下

17:06.550 --> 17:08.550
当然这里不需要按顺序写

17:08.550 --> 17:10.550
你可以换顺序

17:10.550 --> 17:13.550
不过我按顺序写出来了

17:13.550 --> 17:15.550
大家看得清楚一点

17:16.550 --> 17:18.550
五十二十五一

17:18.550 --> 17:19.550
对不对

17:19.550 --> 17:20.550
我们平时藻林就是这样找的

17:20.550 --> 17:22.550
就是按了弹性删法找的

17:22.550 --> 17:26.440
但是有潜力条件

17:26.440 --> 17:28.440
它要一个合适的面额才行

17:28.440 --> 17:31.440
如果说你的面额不合适

17:31.440 --> 17:33.440
我们来看一下弹性删法还行吗

17:33.440 --> 17:35.440
比方说

17:35.440 --> 17:39.440
我举这么一个例子

17:39.440 --> 17:45.440
我有一个五十的面额

17:45.440 --> 17:46.440
等一下

17:46.440 --> 17:48.440
我看一下怎么弄的比较好

17:48.440 --> 17:49.440
这个例子

17:49.440 --> 17:52.440
我有一个五十的面额

17:52.440 --> 17:56.940
有一个三十

17:56.940 --> 17:59.940
三十五的面额

17:59.940 --> 18:01.940
假设

18:01.940 --> 18:07.940
然后再有一个五要

18:07.940 --> 18:09.940
大家看一下

18:09.940 --> 18:10.940
这种情况下

18:10.940 --> 18:15.860
你们认为的最有写是什么

18:15.860 --> 18:25.440
你们认为的最有写

18:26.440 --> 18:29.440
如果说的面额是这么一些

18:29.440 --> 18:31.440
我要找七十六块钱

18:31.440 --> 18:35.260
那么最有写应该是什么

18:35.260 --> 18:36.260
你看

18:36.260 --> 18:38.260
这有差异了对吧

18:38.260 --> 18:39.260
有同学说

18:39.260 --> 18:41.260
三十五五要确实

18:41.260 --> 18:43.260
这就是最有写

18:43.260 --> 18:44.260
两个三十五

18:44.260 --> 18:45.260
一个五

18:45.260 --> 18:46.260
一个一

18:46.260 --> 18:48.260
但是如果说利用贪心删法的话

18:48.260 --> 18:49.260
出来的结果

18:49.260 --> 18:51.260
就这个结果

18:51.260 --> 18:52.260
它不管全局的

18:52.260 --> 18:54.260
它就管演把钱

18:54.260 --> 18:55.260
而演把钱的最有写

18:55.260 --> 18:57.260
一定是全局的最有写

18:57.260 --> 18:59.260
那你看这种特殊情况

18:59.260 --> 19:00.260
就出现问题了

19:00.260 --> 19:01.260
不过在我们现实生活中

19:01.260 --> 19:03.260
不会有这样的面额的

19:03.260 --> 19:04.260
我们现实生活中

19:04.260 --> 19:05.260
在这种找零问题上

19:05.260 --> 19:06.260
直接用贪心删法就可以了

19:06.260 --> 19:07.260
但是如果说

19:07.260 --> 19:08.260
出现那种比较游戏里边

19:08.260 --> 19:09.260
游戏里面的面额

19:09.260 --> 19:11.260
是不是有可能

19:11.260 --> 19:12.260
签起百怪的

19:12.260 --> 19:13.260
那么这个时候

19:13.260 --> 19:14.260
就不一定了

19:14.260 --> 19:15.260
你看

19:15.260 --> 19:16.260
删心

19:16.260 --> 19:17.260
贪心删法

19:17.260 --> 19:18.260
就是每一次

19:18.260 --> 19:19.260
总想找最大的

19:19.260 --> 19:20.260
结果你不考虑后续

19:20.260 --> 19:21.260
只管演钱

19:21.260 --> 19:23.260
你倒是把照最大的找了

19:23.260 --> 19:24.260
但是后边你发现

19:24.260 --> 19:26.260
影响到了全局

19:26.260 --> 19:27.260
对吧

19:27.260 --> 19:28.260
导致了五十找完了过

19:28.260 --> 19:29.260
还有二十六

19:29.260 --> 19:30.260
二十六三十五找不了了

19:30.260 --> 19:32.260
只能找两张十块

19:32.260 --> 19:33.260
对吧

19:33.260 --> 19:35.260
反而导致了不是最有写

19:35.260 --> 19:36.260
那么这种结果

19:36.260 --> 19:37.260
能不能接受

19:37.260 --> 19:39.260
那要看具体情况

19:39.260 --> 19:40.260
比方说

19:40.260 --> 19:41.260
一个了不拉实的国家

19:41.260 --> 19:42.260
它的面额

19:42.260 --> 19:43.260
就非常奇怪

19:43.260 --> 19:44.260
它就这样的

19:44.260 --> 19:45.260
就是这样的面额

19:45.260 --> 19:46.260
那这个时候

19:46.260 --> 19:49.260
你要去受制这个找零问题

19:49.260 --> 19:50.260
你不能用权

19:50.260 --> 19:51.260
那个贪心删法

19:51.260 --> 19:52.260
可能会得到

19:52.260 --> 19:53.260
得到的结果

19:53.260 --> 19:55.260
但是那你会一想

19:55.260 --> 19:57.260
你不要你的残民经历一想

19:57.260 --> 19:58.260
也无所谓

19:58.260 --> 20:00.260
就多找一张钱吧

20:00.260 --> 20:01.260
它至少没有过

20:01.260 --> 20:02.260
找出来这个东西吧

20:02.260 --> 20:04.260
它至少没有找出来这个东西吧

20:04.260 --> 20:06.260
找七十六张一

20:06.260 --> 20:07.260
没有吧

20:07.260 --> 20:09.260
这个东西还能接受

20:09.260 --> 20:10.260
对吧

20:10.260 --> 20:11.260
虽然它不是最有写

20:11.260 --> 20:12.260
但是非常接近最有写

20:12.260 --> 20:13.260
还能接受

20:13.260 --> 20:14.260
那要看你的产品

20:14.260 --> 20:15.260
是怎么设计的

20:15.260 --> 20:17.260
那与其我用更多的

20:17.260 --> 20:18.260
消耗更多的时间

20:18.260 --> 20:19.260
消耗更多的效率

20:19.260 --> 20:20.260
去算这个东西

20:20.260 --> 20:21.260
我还不如就用

20:21.260 --> 20:23.260
就用这个贪心删法

20:23.260 --> 20:24.260
它效率又高

20:24.260 --> 20:25.260
虽然说有的时候

20:25.260 --> 20:26.260
不是最有写

20:26.260 --> 20:28.260
但是也差不到哪去

20:28.260 --> 20:29.260
懂我的意思吧

20:29.260 --> 20:31.260
所以说要看情况的

20:31.260 --> 20:32.260
那么将来有的时候

20:32.260 --> 20:35.260
尽管它不是全局最有写

20:35.260 --> 20:37.260
但是我们有的时候

20:37.260 --> 20:38.260
也可以接受

20:38.260 --> 20:40.260
那要看具体的情况

20:40.260 --> 20:42.260
这就是贪心删法

20:42.260 --> 20:44.260
大家体会这么个意思

20:44.260 --> 20:46.260
就是我就找局部最有写

20:46.260 --> 20:48.260
我不管全局

20:48.260 --> 20:50.260
如果说局部最有写的

20:50.260 --> 20:52.260
累计结果就是全局最有写

20:52.260 --> 20:53.260
那最好

20:53.260 --> 20:55.260
但是有的时候不是

20:55.260 --> 20:56.260
不是的话

20:56.260 --> 20:57.260
参与删法的结果

20:57.260 --> 20:59.260
就会出现偏差

20:59.260 --> 21:00.260
那我要如果说

21:00.260 --> 21:02.260
要得到一个完整的

21:02.260 --> 21:03.260
绝对没有偏差的

21:03.260 --> 21:06.260
准确结果怎么办呢

21:06.260 --> 21:07.260
动态规划

21:07.260 --> 21:13.620
动态规划它就不一样了

21:13.620 --> 21:17.620
它不去求什么局部最有写

21:17.620 --> 21:18.620
它每一个环节

21:18.620 --> 21:20.620
全是考虑全局

21:20.620 --> 21:22.620
一直要考虑全局的

21:23.620 --> 21:24.620
所以说呢

21:24.620 --> 21:26.620
动态规划用这动态规划求出来的

21:26.620 --> 21:28.620
一定是最准确的结果

21:28.620 --> 21:29.620
当然了

21:29.620 --> 21:31.620
它的效率也会非常的差

21:31.620 --> 21:32.620
它要比这个圈

21:32.620 --> 21:34.620
贪心删法的效率要差很多

21:34.620 --> 21:35.620
不过呢

21:35.620 --> 21:36.620
我们可以想一些办法

21:36.620 --> 21:38.620
来优化它的效率

21:38.620 --> 21:39.620
那么动态规划呢

21:39.620 --> 21:40.620
从概念上来说

21:40.620 --> 21:41.620
虽然概念大家可能听的

21:41.620 --> 21:43.620
不是比较抽象

21:43.620 --> 21:45.620
我给大家说一说

21:45.620 --> 21:47.620
动态规划它的做法呢

21:47.620 --> 21:49.620
就是它的场景极其灵活

21:49.620 --> 21:50.620
你们以后呢

21:50.620 --> 21:52.620
如果说遇到刷法题

21:52.620 --> 21:54.620
刷法题中最难的

21:54.620 --> 21:56.620
就是动态规划

21:56.620 --> 21:57.620
场景极其灵活

21:57.620 --> 21:59.620
你都不知道它可以考什么场景

21:59.620 --> 22:01.620
你去看那个立刻上

22:01.620 --> 22:03.620
专门做刷法题的一个网站

22:03.620 --> 22:04.620
那个网站里边

22:04.620 --> 22:05.620
最难的问题里边

22:05.620 --> 22:08.620
绝大部分都是动态规划的问题

22:08.620 --> 22:09.620
动态规划的问题

22:09.620 --> 22:10.620
关键点

22:10.620 --> 22:11.620
你要把它分解成

22:11.620 --> 22:12.620
一个复杂的问题

22:12.620 --> 22:13.620
就要把它分解成

22:13.620 --> 22:15.620
重复的指问题

22:15.620 --> 22:19.190
那么在求重复的指问题的时候

22:19.190 --> 22:21.190
我们还要去做一些缓存

22:21.190 --> 22:23.190
来优化效率

22:23.190 --> 22:25.190
基本上就是这样的套路

22:25.190 --> 22:27.190
就是动态规划

22:27.190 --> 22:28.190
那么如果再复杂点的话

22:28.190 --> 22:29.190
我们可能会做

22:29.190 --> 22:31.190
我们在不停的规划的过程中

22:31.190 --> 22:32.190
在不停的

22:32.190 --> 22:34.190
重复这个过程的过程中

22:34.190 --> 22:37.190
我们还可能会修正之前的结果

22:37.190 --> 22:39.190
那么这就是更复杂的问题

22:39.190 --> 22:40.190
不过今天晚上

22:40.190 --> 22:42.190
我们还不会设计这么复杂

22:42.190 --> 22:43.190
那么这里有两道题

22:43.190 --> 22:44.190
我们来做一说

22:44.190 --> 22:46.190
大家大概体会一下

22:46.190 --> 22:47.190
动态规划

22:47.190 --> 22:51.500
其实是一个什么样的意识

22:51.500 --> 22:52.500
一个问题

22:52.500 --> 22:54.500
青蛙跳台接问题

22:54.500 --> 22:57.500
这个问题我特别有印象

22:57.500 --> 22:59.500
几年前我一个朋友

22:59.500 --> 23:03.500
开了一家骚儿编程培训机构

23:03.500 --> 23:04.500
我有天没事

23:04.500 --> 23:05.500
我去看

23:05.500 --> 23:08.500
就是一些小学生

23:08.500 --> 23:10.500
小学三年级四年级

23:10.500 --> 23:12.500
就这样子的一个小学生

23:12.500 --> 23:14.500
一个班人很少

23:14.500 --> 23:18.500
大概就snack人不到

23:18.500 --> 23:21.500
那天晚上的老师有事

23:21.500 --> 23:22.500
让他们来上自习

23:22.500 --> 23:24.500
我就跑过去看一下

23:24.500 --> 23:26.500
我刚才出了一道题

23:26.500 --> 23:28.500
就是这个青蛙跳台接的问题

23:28.500 --> 23:29.500
我也没让他们编程

23:29.500 --> 23:32.500
我就说你告诉我结果就行了

23:32.500 --> 23:35.500
让我吃惊热事

23:35.500 --> 23:38.500
那里边有三个还是四个同学

23:38.500 --> 23:40.500
都能够得到准确的结果

23:40.500 --> 23:41.500
剩下的同学

23:41.500 --> 23:42.500
虽然说没得到准确的结果

23:42.500 --> 23:44.500
但是他们也有一些自己的思路

23:44.500 --> 23:45.500
我就感慨

23:45.500 --> 23:47.500
现在的小孩真的不得了

23:47.500 --> 23:50.500
三四年级就这样的思路了

23:50.500 --> 23:52.500
那么这个青蛙跳台接的问题

23:52.500 --> 23:54.500
是什么问题呢

23:54.500 --> 23:55.500
题很简单

23:55.500 --> 23:57.500
就是我有N级台接

23:57.500 --> 23:59.500
比方说有10级台接

23:59.500 --> 24:01.500
一直青蛙从一开始

24:01.500 --> 24:03.500
就最底下开始跳

24:03.500 --> 24:05.500
它每一次能可以跳一级

24:05.500 --> 24:07.500
或者是跳两级

24:07.500 --> 24:09.500
可以跳一级可以跳两级

24:09.500 --> 24:12.500
请问一共有多少种跳法

24:12.500 --> 24:13.500
可以跳完台接

24:13.500 --> 24:15.500
大家可以思考一下

24:16.500 --> 24:22.630
这个问题你该怎么去解

24:22.630 --> 24:24.630
现在真的是一代一代的想

24:24.630 --> 24:28.330
像你们有很多人还没毕业

24:28.330 --> 24:30.330
毕业出来过后

24:30.330 --> 24:32.330
经过几年的社会断练

24:34.330 --> 24:36.330
你们将来一定是比我们这些

24:36.330 --> 24:41.110
这一代人还要强

24:41.110 --> 24:48.010
看一下有没有什么思路

24:48.010 --> 24:49.010
你们想着

24:49.010 --> 24:51.010
我再给大家看一下PBT

24:51.010 --> 25:03.280
看着

25:04.280 --> 25:06.280
这里是青蛙

25:06.280 --> 25:08.280
比方说有1级台

25:09.280 --> 25:11.280
两种

25:11.280 --> 25:13.280
两种不止

25:13.280 --> 25:15.280
比方说这里有异级台接

25:15.280 --> 25:17.280
只有一级

25:17.280 --> 25:19.280
然后这只青蛙有几种方式

25:19.280 --> 25:21.280
跳上异级台接呢

25:21.280 --> 25:23.280
是不是只有一种

25:23.280 --> 25:25.280
你看

25:25.280 --> 25:26.280
它只能有这种跳法

25:26.280 --> 25:27.280
还能怎么跳吗

25:27.280 --> 25:28.280
你告诉我

25:28.280 --> 25:30.280
它是不是只能有一种跳法

25:30.280 --> 25:31.280
跳完整个台接

25:31.280 --> 25:33.280
这是一级青蛙

25:33.280 --> 25:34.280
异级台接

25:34.280 --> 25:35.280
那两级台接呢

25:35.280 --> 25:37.280
它有几种跳法呢

25:37.280 --> 25:38.280
看着

25:39.280 --> 25:40.280
这是第一种

25:40.280 --> 25:43.420
看

25:43.420 --> 25:44.420
第一种

25:44.420 --> 25:48.380
X和Y是啥

25:48.380 --> 25:49.380
X和Y是啥

25:49.380 --> 25:51.940
第一种

25:51.940 --> 25:52.940
每一次跳异级

25:52.940 --> 25:53.940
对不对

25:53.940 --> 25:55.940
还没有别的跳法呢

25:55.940 --> 25:56.940
还有一种

25:56.940 --> 25:57.940
直接跳两级

25:57.940 --> 25:59.940
因为青蛙可以跳异级

25:59.940 --> 26:00.940
或跳两级的

26:00.940 --> 26:01.940
那么直接跳两级

26:01.940 --> 26:02.940
是不是第二种跳法

26:02.940 --> 26:06.900
对不对

26:06.900 --> 26:08.900
之前的一个小学生

26:08.900 --> 26:09.900
他就是这样子想的

26:09.900 --> 26:11.900
我先不用那么

26:11.900 --> 26:13.900
那些复杂的就是逻辑

26:13.900 --> 26:15.900
我先就是一个个四

26:15.900 --> 26:17.900
然后找出一些规矩

26:17.900 --> 26:20.900
然后跳三级台接

26:20.900 --> 26:21.900
有几种跳法

26:21.900 --> 26:23.900
我们开始记录一下

26:23.900 --> 26:25.900
一级台接有几种跳法

26:25.900 --> 26:26.900
只有一种

26:26.900 --> 26:27.900
两级台接有几种跳法

26:27.900 --> 26:28.900
两种

26:28.900 --> 26:30.900
三级台接有几种跳法

26:30.900 --> 26:31.900
看一下

26:32.900 --> 26:33.900
第一种

26:34.900 --> 26:36.900
每一次跳异级

26:36.900 --> 26:38.900
是不是第一种

26:38.900 --> 26:39.900
第二种

26:39.900 --> 26:41.900
我第一次跳两级

26:41.900 --> 26:42.900
第二次跳异级

26:42.900 --> 26:43.900
什么两

26:43.900 --> 26:44.900
第二种

26:45.900 --> 26:46.900
第三种

26:46.900 --> 26:48.900
第一次跳异级

26:48.900 --> 26:50.900
第二次跳两级

26:51.900 --> 26:52.900
是不是一共三种

26:52.900 --> 26:59.770
三的n-1

26:59.770 --> 27:00.770
处于

27:00.770 --> 27:05.840
处于二次方

27:05.840 --> 27:07.840
三的n

27:07.840 --> 27:08.840
级数

27:08.840 --> 27:10.840
分成级数是偶数是吧

27:10.840 --> 27:11.840
那你一会自己

27:11.840 --> 27:13.840
自己来套进去算一下吧

27:13.840 --> 27:16.840
然后四级台接

27:16.840 --> 27:18.840
四级台接怎么跳的

27:19.840 --> 27:20.840
第一种

27:20.840 --> 27:22.840
一

27:22.840 --> 27:24.840
全部跳异级

27:24.840 --> 27:25.840
这第一种

27:25.840 --> 27:26.840
对吧

27:26.840 --> 27:27.840
第二种

27:27.840 --> 27:29.840
我一开始跳两级

27:29.840 --> 27:30.840
然后呢

27:30.840 --> 27:31.840
再跳异级

27:31.840 --> 27:32.840
再跳异级

27:32.840 --> 27:33.840
这第二种

27:33.840 --> 27:35.840
第三种

27:35.840 --> 27:36.840
我一开始跳两级

27:36.840 --> 27:37.840
我再跳两级

27:37.840 --> 27:39.840
什么第三种

27:39.840 --> 27:41.840
第四种

27:41.840 --> 27:42.840
我跳异级

27:42.840 --> 27:43.840
再跳两级

27:43.840 --> 27:45.840
再跳异级

27:45.840 --> 27:46.840
所以第四种

27:46.840 --> 27:47.840
第五种

27:47.840 --> 27:48.840
我跳异级

27:48.840 --> 27:49.840
跳异级

27:49.840 --> 27:51.840
再跳两级

27:51.840 --> 27:52.840
一共有五种跳法

27:52.840 --> 27:57.840
我就学到这

27:57.840 --> 28:01.470
看到规律了没

28:01.470 --> 28:03.470
应该有同学看到规律的

28:03.470 --> 28:05.470
一级台接有一种跳法

28:05.470 --> 28:07.470
两级台接有两种跳法

28:07.470 --> 28:08.470
三级台也有三种跳法

28:08.470 --> 28:11.470
四级台也有五种跳法

28:11.470 --> 28:12.470
哎

28:12.470 --> 28:13.470
不找到规律了嘛

28:13.470 --> 28:14.470
对不对

28:14.470 --> 28:15.470
有的时候呢

28:15.470 --> 28:16.470
我们

28:16.470 --> 28:18.470
不把问题想的那么复杂

28:18.470 --> 28:20.470
就用那种穷局法

28:20.470 --> 28:22.470
先找他几个

28:22.470 --> 28:23.470
找他几个找出来过后

28:23.470 --> 28:24.470
我们来找规律

28:24.470 --> 28:25.470
你看你们以后在

28:25.470 --> 28:28.470
公司里边去比试题的时候

28:28.470 --> 28:30.470
他就会出现那种逻辑题

28:30.470 --> 28:32.470
他没跟大马没有什么关系

28:32.470 --> 28:33.470
他就给你前面

28:33.470 --> 28:34.470
又写了几个数字

28:34.470 --> 28:36.470
后面让你推测下一个数字市场

28:36.470 --> 28:37.470
就找规律

28:37.470 --> 28:38.470
就有的时候

28:38.470 --> 28:39.470
我们找不到没有试路的时候

28:39.470 --> 28:40.470
用这种方式

28:40.470 --> 28:41.470
我告诉大家

28:41.470 --> 28:42.470
很有用

28:42.470 --> 28:43.470
相当有用

28:43.470 --> 28:45.470
你不要小喊他

28:45.470 --> 28:46.470
当时的一小ken

28:46.470 --> 28:49.470
他就用这种方式推倒出来了

28:49.470 --> 28:50.470
好那么

28:50.470 --> 28:51.470
但是我们现在没有验证

28:51.470 --> 28:52.470
就是说

28:52.470 --> 28:54.470
现在其实就是一个非波拉气数列

28:54.470 --> 28:55.470
第一位为一

28:55.470 --> 28:56.470
第二位为二

28:56.470 --> 28:58.470
后面的东西是前两位相加

28:58.470 --> 28:59.470
三等于一加二

28:59.470 --> 29:01.470
五等于二加三

29:01.470 --> 29:03.470
那么我们现在只是一个推倒

29:03.470 --> 29:04.470
它并不能证明对不对

29:04.470 --> 29:06.470
那么我们要从逻辑上来证明

29:06.470 --> 29:07.470
这个确实是这样子

29:07.470 --> 29:11.300
怎么证明的

29:11.300 --> 29:13.300
那么我们可以用这种方式

29:13.300 --> 29:14.300
来去证明

29:14.300 --> 29:15.300
你看

29:15.300 --> 29:17.300
我这个地方呢

29:17.300 --> 29:19.300
我也不知道有多少集台阶

29:19.300 --> 29:20.300
我也不知道

29:20.300 --> 29:21.300
但是呢

29:21.300 --> 29:23.300
我就考虑最后一挑

29:23.300 --> 29:25.300
我要跳到这吗

29:25.300 --> 29:27.300
我就考虑最后一挑

29:27.300 --> 29:28.300
最后一跳

29:28.300 --> 29:30.300
要么就跳一集

29:30.300 --> 29:31.300
要么就跳两集

29:31.300 --> 29:32.300
是不是没有别的情况

29:32.300 --> 29:34.300
你不可能跳三集

29:34.300 --> 29:36.300
最后一挑

29:36.300 --> 29:38.300
最后一挑

29:38.300 --> 29:40.300
我不管你前边是什么情况

29:40.300 --> 29:42.300
我就看最后一跳

29:42.300 --> 29:44.300
要么就跳一集

29:44.300 --> 29:46.300
一集

29:46.300 --> 29:50.990
这有多少种跳法

29:50.990 --> 29:53.990
能够保证最后跳一集

29:53.990 --> 29:56.990
加上跳两集

29:56.990 --> 29:57.990
对不对

29:57.990 --> 29:59.990
也就是说我跳到

29:59.990 --> 30:01.990
这个青蛙跳到这

30:01.990 --> 30:03.990
有多少种跳法呢

30:03.990 --> 30:06.990
就是最后一跳是一集的

30:06.990 --> 30:08.990
挑法

30:08.990 --> 30:09.990
有多少种

30:09.990 --> 30:11.990
再加上最后一集

30:11.990 --> 30:13.990
是跳两集的情况

30:13.990 --> 30:15.990
有多少种

30:15.990 --> 30:17.990
能理解这个意思吗

30:17.990 --> 30:19.990
最后一跳是跳一集的情况

30:19.990 --> 30:20.990
比方前面

30:20.990 --> 30:22.990
我不管你前面有多少种跳法跳到这

30:22.990 --> 30:24.990
比方前面有十种跳法跳到这

30:24.990 --> 30:26.990
那么跳一集的情况就是十种

30:26.990 --> 30:28.990
最后一跳跳一集

30:28.990 --> 30:30.990
你只要能够保证跳到这就行

30:30.990 --> 30:31.990
是不是

30:31.990 --> 30:33.990
只要能够保证跳到这

30:33.990 --> 30:35.990
那我前面不管你有多少种跳法跳到这

30:35.990 --> 30:37.990
那么就是你十种跳法就是十种

30:37.990 --> 30:39.990
最后一跳跳一集

30:39.990 --> 30:41.990
最后一跳跳两集呢

30:41.990 --> 30:45.990
我不管你前面有多少种跳法跳到这

30:45.990 --> 30:47.990
你只要能够保证你跳到这

30:47.990 --> 30:49.990
比方说有五种跳法可以跳到这

30:49.990 --> 30:52.990
那么我最后一跳跳两集

30:52.990 --> 30:55.990
是把你这两种跳法加起来

30:55.990 --> 30:58.990
就是一共有多少种跳法

30:58.990 --> 31:00.990
这个逻辑能理解吧

31:00.990 --> 31:04.940
能不能理解这个

31:04.940 --> 31:07.940
我就管最后一跳

31:07.940 --> 31:09.940
你只要最后一跳跳一集的情况

31:09.940 --> 31:11.940
你必须要跳到这才能跳一集

31:11.940 --> 31:13.940
所以我只要能够知道跳到这

31:13.940 --> 31:15.940
有多少种情况

31:15.940 --> 31:18.940
比方说有十种情况能跳到这

31:18.940 --> 31:21.940
那么最后一跳那就完了

31:21.940 --> 31:22.940
对不对

31:22.940 --> 31:23.940
这就是十种情况

31:23.940 --> 31:24.940
最后一跳跳一集

31:24.940 --> 31:26.940
最后一跳跳两集的情况呢

31:26.940 --> 31:28.940
就是有多少种跳法能跳到这

31:28.940 --> 31:31.940
那么我最后一跳跳两集就完事了

31:31.940 --> 31:33.940
这就是

31:33.940 --> 31:35.940
我们通过这种模式

31:35.940 --> 31:38.940
得到准确的得到这个逻辑结果

31:38.940 --> 31:40.940
那么我们患而言之

31:40.940 --> 31:42.940
最后一跳跳一集的情况

31:42.940 --> 31:44.940
比方说我们要跳N级台阶

31:44.940 --> 31:46.940
FN

31:46.940 --> 31:48.940
就是FN的纸

31:48.940 --> 31:50.940
就是跳N级台阶一共有多少种跳法

31:50.940 --> 31:52.940
那么等于他跳最后一集多少种跳法

31:52.940 --> 31:54.940
跳最后两集

31:54.940 --> 31:56.940
最后一跳跳两集多少种跳法

31:56.940 --> 31:58.940
那么最后一跳跳一集有多少种跳法呢

31:58.940 --> 32:00.940
是不是等于什么

32:00.940 --> 32:02.940
等于FN-1

32:02.940 --> 32:04.940
我只要能够算出

32:04.940 --> 32:06.940
有多少种跳法能跳到这

32:06.940 --> 32:08.940
是不是就能算出

32:08.940 --> 32:11.940
最后一跳是一集的情况

32:11.940 --> 32:13.940
对不对

32:13.940 --> 32:15.940
我算出FN-1

32:15.940 --> 32:16.940
有多少种跳法能跳到这

32:16.940 --> 32:18.940
那么我就能算出

32:18.940 --> 32:20.940
最后一跳是一集的情况

32:20.940 --> 32:22.940
那么跳两集呢

32:22.940 --> 32:24.940
那么就是FN-2

32:24.940 --> 32:26.940
你看这样子的逻辑推到出来了

32:26.940 --> 32:28.940
我只要能够算出有多少种跳法跳到这

32:28.940 --> 32:30.940
我就知道了

32:30.940 --> 32:32.940
最后一跳跳两集的情况是多少种

32:32.940 --> 32:34.940
那么这两种异乡家

32:34.940 --> 32:36.940
是不是就是跳FN

32:36.940 --> 32:38.940
的所有情况

32:38.940 --> 32:39.940
对不对

32:39.940 --> 32:41.940
这不就是一个肥不大计数的公司吗

32:41.940 --> 32:43.940
那么最后呢我们给个中指条件就是

32:43.940 --> 32:45.940
F1

32:45.940 --> 32:47.940
只有一种

32:47.940 --> 32:48.940
F2

32:48.940 --> 32:49.940
只有两种

32:49.940 --> 32:50.940
对吧

32:50.940 --> 32:51.940
给出一个中指条件

32:51.940 --> 32:53.940
其他的F3 F4

32:53.940 --> 32:57.320
都是也用这样的过程

32:57.320 --> 32:58.320
原来意思吧

32:58.320 --> 32:59.320
好那么现在呢

32:59.320 --> 33:01.320
如果说你这个东西能分析出来

33:01.320 --> 33:02.320
能够听懂的话

33:02.320 --> 33:04.950
那么这个代码就很好写了

33:04.950 --> 33:05.950
青蛙啊

33:05.950 --> 33:13.260
Flock

33:13.260 --> 33:14.260
N

33:14.260 --> 33:16.260
相当于是个FN

33:16.260 --> 33:18.260
如果说N等于1

33:18.260 --> 33:20.260
那我就只有一种

33:20.260 --> 33:21.260
N等于2

33:21.260 --> 33:23.260
然后我只有两种

33:23.260 --> 33:25.260
对不对

33:25.260 --> 33:27.260
好那么这两个是不需要运算的

33:27.260 --> 33:28.260
对不对

33:28.260 --> 33:29.260
那么剩下的是需要运算的

33:29.260 --> 33:30.260
剩下的是怎么运算的

33:30.260 --> 33:32.260
就是Gem

33:32.260 --> 33:33.260
N

33:33.260 --> 33:34.260
加上

33:34.260 --> 33:36.260
Gem

33:36.260 --> 33:37.260
对吧

33:37.260 --> 33:39.260
GemN-1

33:39.260 --> 33:41.260
加上GemN-2

33:41.260 --> 33:43.260
对吧

33:43.260 --> 33:44.260
给出了

33:44.260 --> 33:47.820
好你去看一下啊

33:47.820 --> 33:49.820
跳四集台阶

33:49.820 --> 33:50.820
Gem

33:50.820 --> 33:52.820
有五种跳法

33:52.820 --> 33:53.820
到实际台阶

33:53.820 --> 33:55.820
有89种跳法

33:55.820 --> 33:56.820
没问题吧

33:56.820 --> 33:57.820
这就是那个

33:57.820 --> 33:59.820
青蛙跳台阶的问题

33:59.820 --> 34:00.820
好

34:00.820 --> 34:01.820
但是呢

34:01.820 --> 34:02.820
我做动态规划的时候啊

34:02.820 --> 34:04.820
不仅仅是要把它分解成那种

34:04.820 --> 34:05.820
重复的止问题

34:05.820 --> 34:07.820
你看这就是重复的止问题

34:07.820 --> 34:09.820
不仅仅是要这样分解

34:09.820 --> 34:11.820
还要考虑一个效率问题

34:11.820 --> 34:13.820
为什么要考虑效率问题呢

34:13.820 --> 34:15.820
我给大家自己输出一下

34:15.820 --> 34:17.820
大家看一下

34:17.820 --> 34:18.820
这个函数

34:18.820 --> 34:19.820
就这个地方

34:19.820 --> 34:20.820
我们不管吧

34:20.820 --> 34:22.820
这个地方因为它没有什么运算

34:22.820 --> 34:23.820
效率很高的

34:23.820 --> 34:24.820
我就看这个地方

34:24.820 --> 34:25.820
需要大量的运算

34:25.820 --> 34:26.820
对吧

34:26.820 --> 34:27.820
我要调用自己

34:27.820 --> 34:28.820
自己要算出来过后

34:28.820 --> 34:29.820
我才能

34:29.820 --> 34:30.820
加上还要调用一次自己

34:30.820 --> 34:31.820
要算出来过后相加

34:31.820 --> 34:32.820
我才能得到结果

34:32.820 --> 34:33.820
那么我们主要关注在这

34:33.820 --> 34:35.820
效率主要损失在这

34:35.820 --> 34:37.820
我就看跳四集台阶

34:37.820 --> 34:39.820
它这个函数会运行多好吃

34:39.820 --> 34:41.820
会算出几个N

34:41.820 --> 34:42.820
看一下吧

34:42.820 --> 34:50.260
当前正在运算的N的值

34:50.260 --> 34:51.260
N输出

34:51.260 --> 34:54.980
来

34:54.980 --> 34:55.980
我们降谱10

34:55.980 --> 35:00.700
你看它算什么

35:00.700 --> 35:01.700
先算10

35:01.700 --> 35:02.700
算N的值10

35:02.700 --> 35:03.700
算10的时候

35:03.700 --> 35:04.700
它就必须要去算9

35:04.700 --> 35:05.700
对不对

35:05.700 --> 35:06.700
N-1

35:06.700 --> 35:07.700
它是不是必须要去算9

35:07.700 --> 35:09.700
它要重新运行这个函数

35:09.700 --> 35:10.700
那么N就变成9了

35:10.700 --> 35:11.700
然后算9的时候

35:11.700 --> 35:12.700
又必须要算8

35:12.700 --> 35:13.700
算8的时候必须算7

35:13.700 --> 35:14.700
算7的时候必须算6

35:14.700 --> 35:15.700
算5

35:15.700 --> 35:16.700
算4

35:16.700 --> 35:17.700
算3

35:17.700 --> 35:18.700
算1

35:18.700 --> 35:19.700
以下就算出来

35:19.700 --> 35:20.700
这个不同意不管

35:20.700 --> 35:22.700
那么为什么又在重新算3

35:22.700 --> 35:23.700
又在重新算4

35:23.700 --> 35:24.700
又在重新算3

35:24.700 --> 35:26.700
所以有很多重复的计算

35:26.700 --> 35:28.700
有大量的重复计算

35:28.700 --> 35:29.700
看到没

35:29.700 --> 35:30.700
那么这个重复

35:30.700 --> 35:31.700
这些计算计算的多好吃呢

35:31.700 --> 35:32.700
如果说我们用变价

35:32.700 --> 35:34.700
codes等于0

35:34.700 --> 35:35.700
每一次计算

35:35.700 --> 35:37.700
我们codes加加

35:37.700 --> 35:38.700
codes加加

35:38.700 --> 35:39.700
最后呢

35:39.700 --> 35:40.700
我们运行完了过后

35:40.700 --> 35:46.900
输出一下这个codes

35:46.900 --> 35:48.900
最后我们来输出一下这个codes

35:53.660 --> 35:54.660
运行

35:54.660 --> 35:55.660
然后我们输出一下codes

35:55.660 --> 36:00.760
看看运算的多好吃

36:00.760 --> 36:02.760
运算了54次

36:02.760 --> 36:03.760
效率是不是低

36:03.760 --> 36:05.760
那如果说我这里再夸张一点

36:05.760 --> 36:07.760
我这里跳跳多少节呢

36:07.760 --> 36:09.760
跳15集

36:09.760 --> 36:14.520
然后我们再运行的codes

36:14.520 --> 36:17.520
它算了609次

36:17.520 --> 36:18.520
为什么会算这么多呢

36:18.520 --> 36:19.520
因为你会发现

36:19.520 --> 36:22.520
它里面有大量的重复计算

36:22.520 --> 36:23.520
为什么会出现

36:23.520 --> 36:25.520
大量的重复计算呢

36:25.520 --> 36:26.520
你看吧

36:26.520 --> 36:27.520
我们随便举个例子

36:27.520 --> 36:29.520
随便拿个降不实

36:29.520 --> 36:31.520
就降不5

36:31.520 --> 36:32.520
降不5等于什么

36:32.520 --> 36:36.520
等于降不4加上降不3

36:36.520 --> 36:37.520
对不对

36:37.520 --> 36:39.520
好 那么你得算4吧

36:39.520 --> 36:40.520
是不是得算4

36:40.520 --> 36:41.520
4以前没算过 对吧

36:41.520 --> 36:42.520
那么现在算呗

36:42.520 --> 36:43.520
降不4呢

36:43.520 --> 36:44.520
又等于什么

36:44.520 --> 36:46.520
降不3加上降不2

36:46.520 --> 36:47.520
降不2可以直接算出来

36:47.520 --> 36:48.520
就是直接是2

36:48.520 --> 36:49.520
那没问题

36:49.520 --> 36:50.520
那么我这里看一下

36:50.520 --> 36:51.520
算了几次

36:51.520 --> 36:52.520
算了5 对不对

36:52.520 --> 36:54.520
是不是算了4 算了3

36:54.520 --> 36:56.520
好 那么现在4就算出来了

36:56.520 --> 36:58.520
4算出来了过后

36:58.520 --> 37:01.520
对 降不3还得算

37:01.520 --> 37:03.520
降不3又等于什么

37:03.520 --> 37:06.520
降不2加上降不1

37:06.520 --> 37:07.520
降不2就等于2

37:07.520 --> 37:08.520
这个东西不需要算

37:08.520 --> 37:10.520
降不1那就等于1

37:10.520 --> 37:11.520
好 那么现在是不是算过5

37:11.520 --> 37:15.520
算过4 算过3

37:15.520 --> 37:17.520
好 那么现在4是不是算出来了

37:17.520 --> 37:18.520
它要加上降不3

37:18.520 --> 37:20.520
是不是你又得重新算一次3

37:20.520 --> 37:22.520
我又得去重新算一次3

37:22.520 --> 37:23.520
看到没

37:23.520 --> 37:24.520
这个重复计算就这样

37:24.520 --> 37:25.520
就是这样来的

37:25.520 --> 37:27.520
我又得去重新算一次3

37:27.520 --> 37:29.520
那么这是降不5的情况

37:29.520 --> 37:30.520
那不说有降不6呢

37:30.520 --> 37:31.520
这个值越高

37:31.520 --> 37:34.960
它的情况就越严重

37:34.960 --> 37:35.960
等于什么

37:35.960 --> 37:39.960
降不5加上降不4

37:39.960 --> 37:40.960
那你看

37:40.960 --> 37:41.960
刚才我们把降不5算出来了

37:41.960 --> 37:42.960
对吧

37:42.960 --> 37:44.960
好 不用把降不5算出来了

37:44.960 --> 37:45.960
结果呢

37:45.960 --> 37:46.960
就都已经有个重复了

37:46.960 --> 37:47.960
对不对

37:47.960 --> 37:48.960
要算一个降不3

37:48.960 --> 37:49.960
那么这个时候

37:49.960 --> 37:50.960
我又要重新算这个降不4

37:50.960 --> 37:52.960
是不是又得走一次这个流程

37:52.960 --> 37:53.960
又得走它

37:53.960 --> 37:54.960
又得走它

37:54.960 --> 37:56.960
对不对

37:56.960 --> 37:57.960
那么这个值越高

37:57.960 --> 38:00.960
它的重复的情况就越严重

38:00.960 --> 38:02.960
那怎么办呢

38:02.960 --> 38:05.960
我们可以用一个方式来搞定

38:05.960 --> 38:07.960
就是用缓存

38:07.960 --> 38:09.960
已经算过的情况

38:09.960 --> 38:11.960
我就不需要再重新算了

38:11.960 --> 38:14.960
好 那么这个东西怎么来做呢

38:14.960 --> 38:16.960
比方说我们这里

38:16.960 --> 38:18.960
非常简单

38:18.960 --> 38:20.960
我这里呢

38:20.960 --> 38:23.960
只需要给一个缓存就行了

38:23.960 --> 38:25.960
这个缓存能不能给外面的也可以

38:25.960 --> 38:26.960
当然了

38:26.960 --> 38:27.960
给外面的影响全局

38:27.960 --> 38:28.960
我们注意好了

38:28.960 --> 38:29.960
像那种缓存的情况

38:29.960 --> 38:31.960
今天我们昨天那个

38:31.960 --> 38:33.960
图的伸手和广收一样

38:33.960 --> 38:35.960
我们一般写到内部

38:35.960 --> 38:38.960
内部里边建立一个缓存

38:38.960 --> 38:39.960
就一个数书吧

38:39.960 --> 38:40.960
这个缓存可以是个对象

38:40.960 --> 38:41.960
可以是个数书

38:41.960 --> 38:42.960
可以是任何东西

38:42.960 --> 38:43.960
只要你能够把准确的

38:43.960 --> 38:45.960
把结果缓存起来

38:45.960 --> 38:48.960
缓存

38:48.960 --> 38:51.960
N对应的结果

38:51.960 --> 38:52.960
就是这个N

38:52.960 --> 38:53.960
只要一算过了过后

38:53.960 --> 38:55.960
我就把它缓存起来

38:55.960 --> 38:56.960
我写了这么一个数书

38:56.960 --> 38:57.960
然后有了缓存过后

38:57.960 --> 38:58.960
我们就不能用它来定位了

38:58.960 --> 38:59.960
不然的话

38:59.960 --> 39:01.960
每一次缓存都会用一个新的数书

39:01.960 --> 39:02.960
所以说我们这里

39:02.960 --> 39:03.960
需要写一个内部缓书

39:03.960 --> 39:04.960
这样吧

39:04.960 --> 39:08.660
把这个东西扔过来

39:08.660 --> 39:11.100
扔过来

39:11.100 --> 39:12.100
看一下N1

39:12.100 --> 39:13.100
N2

39:13.100 --> 39:14.100
这种情况不用管

39:14.100 --> 39:16.100
这种情况瞬间就输结果了

39:16.100 --> 39:18.100
我们主要是关注

39:18.100 --> 39:19.100
正常的情况

39:19.100 --> 39:20.100
在这里的情况

39:20.100 --> 39:21.100
这里的情况

39:21.100 --> 39:23.100
我们首先要看的是

39:23.100 --> 39:27.100
看缓存中有没有记录

39:27.100 --> 39:28.100
那么缓存怎么缓存呢

39:28.100 --> 39:29.100
你自己去设计

39:29.100 --> 39:30.100
比较弄

39:30.100 --> 39:31.100
这个很简单

39:31.100 --> 39:33.100
比较弄开起

39:33.100 --> 39:35.100
开起N

39:35.100 --> 39:37.100
那么就等于某一次的结果

39:37.100 --> 39:38.100
比较说我们就是数书

39:38.100 --> 39:39.100
就可以这样做

39:39.100 --> 39:40.100
我们用N作为下标

39:40.100 --> 39:41.100
来记录这个结果

39:41.100 --> 39:42.100
对吧

39:42.100 --> 39:43.100
我们可以这样

39:43.100 --> 39:44.100
完全可以这样做

39:44.100 --> 39:45.100
那么我们怎么来看缓存中

39:45.100 --> 39:46.100
有没有结果结果呢

39:46.100 --> 39:47.100
非常简单

39:47.100 --> 39:48.100
我们就看一下

39:48.100 --> 39:50.100
开起N存不存在

39:50.100 --> 39:51.100
对吧

39:51.100 --> 39:52.100
这数书里边

39:52.100 --> 39:53.100
这个下标

39:53.100 --> 39:54.100
以N为下标的值

39:54.100 --> 39:55.100
存不存在

39:55.100 --> 39:56.100
如果说存在的话

39:56.100 --> 39:57.100
我就不算了

39:57.100 --> 39:58.100
算都不算了

39:58.100 --> 39:59.100
还算啥

39:59.100 --> 40:00.100
不算了

40:00.100 --> 40:03.410
有缓存

40:03.410 --> 40:05.410
直接改回

40:05.410 --> 40:08.490
好

40:08.490 --> 40:09.490
没有缓存

40:09.490 --> 40:10.490
然后呢

40:10.490 --> 40:11.490
我才信息计算

40:11.490 --> 40:12.490
那么这个时候

40:12.490 --> 40:13.490
我就记录一下

40:13.490 --> 40:14.490
算了

40:14.490 --> 40:16.490
这个主要是测试

40:16.490 --> 40:19.490
计算次数加1

40:19.490 --> 40:20.490
那么这个时候

40:20.490 --> 40:22.490
测试输出一下

40:22.490 --> 40:23.490
都是测试的

40:23.490 --> 40:25.490
最后我们把算出来

40:25.490 --> 40:26.490
算出来过后

40:26.490 --> 40:27.490
我们是不是保存起来

40:27.490 --> 40:28.490
它就是绕齿保存起来

40:28.490 --> 40:29.490
保存到哪呢

40:29.490 --> 40:31.490
保存到Catch

40:31.490 --> 40:32.490
N里边

40:32.490 --> 40:33.490
是吧

40:33.490 --> 40:34.490
把它缓存起来

40:34.490 --> 40:38.490
把结果缓存起来

40:38.490 --> 40:43.270
以共将来使用

40:43.270 --> 40:44.270
好

40:44.270 --> 40:45.270
最后呢

40:45.270 --> 40:46.270
把它开起N

40:46.270 --> 40:47.270
回来吧

40:47.270 --> 40:48.270
绕齿保存

40:48.270 --> 40:50.650
都一样

40:50.650 --> 40:52.650
这就是加了缓存过后的解放

40:52.650 --> 40:53.650
其实呢

40:53.650 --> 40:54.650
就是在关键节点

40:54.650 --> 40:56.650
运算之前

40:56.650 --> 40:58.650
看一下有没有缓存

40:58.650 --> 40:59.650
有的话

40:59.650 --> 41:00.650
就直接得结果了

41:00.650 --> 41:02.650
不要往后算了

41:02.650 --> 41:04.650
没有缓存去算

41:04.650 --> 41:05.650
算完了把它缓存起来

41:05.650 --> 41:06.650
无非就加了这么减小

41:06.650 --> 41:07.650
对吧

41:07.650 --> 41:08.650
整个程序的模型

41:08.650 --> 41:09.650
其实没有变的

41:09.650 --> 41:10.650
最后我们雕了一下

41:10.650 --> 41:11.650
就jump

41:11.650 --> 41:13.650
把这个N传进去

41:13.650 --> 41:17.730
不就完了吗

41:17.730 --> 41:18.730
好

41:18.730 --> 41:19.730
我们来看一下

41:19.730 --> 41:21.730
这种我们有了缓存过后

41:21.730 --> 41:23.730
它的情况

41:23.730 --> 41:24.730
jump

41:24.730 --> 41:26.730
跳十五次

41:27.730 --> 41:28.730
小心

41:28.730 --> 41:30.730
jump

41:30.730 --> 41:31.730
这里写错了

41:31.730 --> 41:34.730
这里应该用下滑线

41:34.730 --> 41:35.730
这个

41:35.730 --> 41:36.730
不然的话

41:36.730 --> 41:37.730
重新掉到它过后了

41:37.730 --> 41:39.730
缓存又被清空了

41:42.730 --> 41:45.170
你看

41:45.170 --> 41:46.170
是不是

41:46.170 --> 41:47.170
结果都是一样

41:47.170 --> 41:48.170
结果都是准确的

41:48.170 --> 41:49.170
有987

41:49.170 --> 41:50.170
你看

41:50.170 --> 41:51.170
算的量是不是少了很多

41:51.170 --> 41:53.170
是不是没有重复运算了

41:53.170 --> 41:54.170
运算时务

41:54.170 --> 41:55.170
十四十三十二十一

41:55.170 --> 41:56.170
是不是没有重复的运算了

41:56.170 --> 41:58.170
然后我们来看一下

41:58.170 --> 42:00.170
它只运算了十三次

42:01.170 --> 42:02.170
所以这样子

42:02.170 --> 42:03.170
效率就大幅度提升了

42:03.170 --> 42:04.170
那么这种场景

42:04.170 --> 42:06.170
就是典型的

42:06.170 --> 42:07.170
以时间

42:07.170 --> 42:09.170
以空间换时间

42:09.170 --> 42:10.170
我用

42:10.170 --> 42:11.170
我去

42:11.170 --> 42:13.170
我减少你的计算时间

42:13.170 --> 42:14.170
但是呢

42:14.170 --> 42:15.170
我增加了

42:15.170 --> 42:16.170
我的内存空间

42:16.170 --> 42:17.170
你看

42:17.170 --> 42:18.170
这里的不是一个开启值吗

42:18.170 --> 42:19.170
对不对

42:19.170 --> 42:20.170
这个开启值

42:20.170 --> 42:21.170
实际上里边

42:21.170 --> 42:22.170
保持了东西的

42:22.170 --> 42:23.170
我们来看一下

42:23.170 --> 42:24.170
开启值保持了什么东西

42:24.170 --> 42:25.170
输出开启

42:26.170 --> 42:27.170
比方这个

42:28.170 --> 42:30.170
把开启输出

42:31.170 --> 42:32.170
jump

42:32.170 --> 42:33.170
十五

42:33.170 --> 42:34.170
你看这个开启

42:35.170 --> 42:36.170
输出了

42:36.170 --> 42:37.170
台阶为三

42:37.170 --> 42:38.170
那么有三次

42:38.170 --> 42:39.170
有三种跳法

42:39.170 --> 42:41.170
台阶为四有五种跳法

42:41.170 --> 42:42.170
台阶为五有八种跳法

42:42.170 --> 42:43.170
台阶为六有十三种

42:43.170 --> 42:44.170
就是把每一

42:44.170 --> 42:46.170
把这些就是

42:46.170 --> 42:48.170
我们之前计算的结果

42:48.170 --> 42:49.170
都缓存起来了

42:49.170 --> 42:50.170
那么就没有

42:50.170 --> 42:51.170
比方我们到时候要用

42:51.170 --> 42:52.170
八这个结果

42:52.170 --> 42:53.170
我们就没有必要再去算

42:53.170 --> 42:54.170
七再去算六再去算五

42:54.170 --> 42:55.170
没有必要了

42:55.170 --> 42:56.170
直接把个三个十

42:56.170 --> 42:57.170
就直接取出来

42:57.170 --> 42:58.170
典型的以时间

42:58.170 --> 42:59.170
换空间

42:59.170 --> 43:00.170
懂了意思吗

43:00.170 --> 43:01.170
当然这里边有很多测试代码

43:01.170 --> 43:02.170
把这些测试代码

43:02.170 --> 43:03.170
清楚就是一个

43:03.170 --> 43:04.170
干净的

43:05.170 --> 43:06.170
东台伟华代码

43:07.170 --> 43:08.170
好 这一块没问题吧

43:08.170 --> 43:09.170
能听懂了吗

43:10.170 --> 43:16.320
不要把它想复杂了

43:17.320 --> 43:19.320
就是把之前的代码

43:19.320 --> 43:20.320
加一个缓存

43:21.320 --> 43:22.320
缓存用啥缓存随便

43:23.320 --> 43:24.320
你按用啥用啥

43:24.320 --> 43:25.320
总之你得找一个东西

43:25.320 --> 43:26.320
把它存起来

43:26.320 --> 43:27.320
甭管你找啥

43:27.320 --> 43:28.320
然后我现在

43:28.320 --> 43:29.320
用的是输出的

43:29.320 --> 43:30.320
一会我可能用对象

43:30.320 --> 43:31.320
不用啥都可以

43:31.320 --> 43:32.320
只要你能找个东西

43:32.320 --> 43:33.320
把它存存一下

43:34.320 --> 43:35.320
那么有了这个缓存过后

43:35.320 --> 43:37.320
就是你每一算一个结果

43:37.320 --> 43:38.320
算之前我看一下

43:38.320 --> 43:39.320
有没有

43:39.320 --> 43:40.320
有缓存我就返回了

43:41.320 --> 43:42.320
没有缓存的我就去算

43:42.320 --> 43:43.320
就正常地算

43:43.320 --> 43:44.320
算完了过后

43:44.320 --> 43:45.320
把它缓存起来

43:46.320 --> 43:47.320
就完了

43:47.320 --> 43:48.320
这就是

43:48.320 --> 43:49.320
解这种分制法里边

43:49.320 --> 43:51.320
解这种地规分制法里边

43:52.320 --> 43:53.320
在计算的过程中

43:53.320 --> 43:54.320
加入一个缓存

43:55.320 --> 43:56.320
来提高它的运行效率

44:01.700 --> 44:02.700
因为算n的时候

44:02.700 --> 44:04.700
缓存里边有1-n-1的值

44:05.700 --> 44:07.700
因此直接使用输出所谓

44:07.700 --> 44:10.700
会比eve来收缩

44:10.700 --> 44:11.700
更高效点吧

44:12.700 --> 44:13.700
算n的时候

44:13.700 --> 44:15.700
缓存里边有

44:16.700 --> 44:17.700
不一定啊

44:17.700 --> 44:19.700
你算n的时候缓存里边

44:19.700 --> 44:21.700
我这里是在用所谓呀

44:21.700 --> 44:22.700
我这不就是所谓吗

44:23.700 --> 44:24.700
什么什么意思啊

44:26.700 --> 44:27.700
而且这句话也不对呀

44:27.700 --> 44:29.700
你算n的时候缓存里边

44:29.700 --> 44:31.700
不一定有1-n-1的值啊

44:31.700 --> 44:32.700
不一定的

44:32.700 --> 44:33.700
比方说你一开始

44:33.700 --> 44:34.700
又再算15对吧

44:34.700 --> 44:35.700
那这个时候反正是空的啊

44:35.700 --> 44:36.700
啥都没有

44:37.700 --> 44:38.700
啥都没有

44:39.700 --> 44:40.700
这个缓存就是

44:40.700 --> 44:41.700
我之前算了

44:41.700 --> 44:42.700
算了一次过后

44:42.700 --> 44:43.700
甭管我算了是啥

44:44.700 --> 44:45.700
无所谓

44:45.700 --> 44:46.700
我不管我算的是10

44:46.700 --> 44:47.700
还是10

44:47.700 --> 44:48.700
无所谓

44:48.700 --> 44:49.700
只要我算过了

44:49.700 --> 44:50.700
我就以后就不要算了

44:50.700 --> 44:51.700
就算这一次

44:51.700 --> 44:52.700
就不要再算了

44:52.700 --> 44:53.700
我把保存起来

44:53.700 --> 44:54.700
就这么一个意思

44:54.700 --> 44:58.870
如果说有些同学

44:58.870 --> 44:59.870
还是觉得

44:59.870 --> 45:00.870
应的话

45:00.870 --> 45:02.870
可能问题还是修在地规这里

45:02.870 --> 45:04.870
以前在上我这个课之前

45:04.870 --> 45:06.870
可能没有怎么建过地规

45:06.870 --> 45:07.870
然后地规这一块

45:07.870 --> 45:09.870
你要用那个什么

45:09.870 --> 45:10.870
用

45:11.870 --> 45:12.870
命令式编程

45:12.870 --> 45:13.870
就是我们普通编程的那种

45:13.870 --> 45:14.870
思维去想的话

45:14.870 --> 45:15.870
那一定是编程

45:15.870 --> 45:16.870
因为地规它本身

45:16.870 --> 45:17.870
就不是这个领域的东西

45:17.870 --> 45:19.870
它是含书式编程的东西

45:19.870 --> 45:20.870
那如果说你一定要用

45:20.870 --> 45:22.870
命令式编程的思想去想的话

45:22.870 --> 45:23.870
你就必须要知道

45:24.870 --> 45:25.870
执行站

45:25.870 --> 45:27.870
执行上下文

45:27.870 --> 45:28.870
至少得知道这两个

45:28.870 --> 45:30.870
执行站和执行上下文

45:30.870 --> 45:32.870
我都不说什么作用意念的

45:32.870 --> 45:33.870
你把这两个搞清楚

45:33.870 --> 45:34.870
你才能够用个

45:34.870 --> 45:35.870
命令式编程的思维

45:35.870 --> 45:37.870
搞清楚地规是咋回事

45:38.870 --> 45:39.870
不然的话你肯定搞不清楚的

45:39.870 --> 45:40.870
比方说有同学就

45:40.870 --> 45:41.870
就在想这个问题

45:41.870 --> 45:43.870
我这个函数都返回了

45:43.870 --> 45:44.870
我这个缓存

45:44.870 --> 45:45.870
将来怎么可能会用得上呢

45:45.870 --> 45:46.870
对吧

45:46.870 --> 45:47.870
就会有这样的一些问题

45:50.440 --> 45:52.440
好 这是那个

45:52.440 --> 45:53.440
这个题

45:53.440 --> 45:54.440
说实话这个题

45:54.440 --> 45:55.440
还算是比较简单的

45:57.440 --> 45:58.440
第二题

45:58.440 --> 45:59.440
如果说你面试

45:59.440 --> 46:00.440
遇到这种难度的题

46:01.440 --> 46:02.440
那

46:02.440 --> 46:03.440
对前端来说

46:03.440 --> 46:05.440
也就是难度到底了

46:05.440 --> 46:07.440
基本上难度就到底了

46:07.440 --> 46:08.440
我今天晚上

46:08.440 --> 46:09.440
给大家讲讲

46:09.440 --> 46:10.440
那个公共秩序的问题

46:11.440 --> 46:12.440
讲完了之后

46:12.440 --> 46:13.440
我没有办法保证

46:13.440 --> 46:15.440
以后你遇到类似的问题

46:15.440 --> 46:16.440
你还能做出来

46:16.440 --> 46:17.440
因为每道题

46:17.440 --> 46:18.440
这种动态规划的题

46:18.440 --> 46:19.440
极其的灵活

46:20.440 --> 46:21.440
有的人提到

46:21.440 --> 46:22.440
我看了半天

46:22.440 --> 46:23.440
我都要想半天

46:23.440 --> 46:25.440
我才能找到思路

46:25.440 --> 46:26.440
所以说这里

46:26.440 --> 46:27.440
因为它极其的灵活

46:27.440 --> 46:28.440
所以说你不是很容易

46:28.440 --> 46:29.440
在里面找规律

46:29.440 --> 46:31.440
你唯一能够做的事情就是

46:31.440 --> 46:32.440
不断地去训练

46:32.440 --> 46:34.440
不断地去训练自己的思维

46:34.440 --> 46:35.440
然后能够保证

46:35.440 --> 46:37.440
拿个一个问题给力

46:37.440 --> 46:38.440
有点方向

46:38.440 --> 46:40.440
不然的话一点方向都没有

46:40.440 --> 46:41.440
当然这样能够

46:41.440 --> 46:43.440
能够在面试题的时候

46:43.440 --> 46:44.440
能够完成这样的题

46:44.440 --> 46:46.440
就是这种难度的题的同学

46:46.440 --> 46:47.440
那里肯定

46:47.440 --> 46:49.440
警察长肯定是没问题的

46:49.440 --> 46:50.440
你的思维能力

46:50.440 --> 46:51.440
已经是非常厉害了

46:51.440 --> 46:52.440
在这种方面

46:52.440 --> 46:53.440
相对来比

46:53.440 --> 46:57.100
比较少一点

46:57.100 --> 46:59.100
什么叫最长公共秩序的

46:59.100 --> 47:03.880
longest common stream

47:03.880 --> 47:04.880
有的时候

47:04.880 --> 47:05.880
我们可能会比较

47:05.880 --> 47:07.880
两个字无端的相似程度

47:07.880 --> 47:09.880
原来你在搜索引擎里边

47:09.880 --> 47:10.880
你搜一个东西

47:10.880 --> 47:12.880
哪些排名靠前

47:12.880 --> 47:14.880
哪些排名靠后

47:14.880 --> 47:16.880
所以越能够匹配你的搜索结果的

47:16.880 --> 47:17.880
越靠前

47:17.880 --> 47:19.880
当然你摆住除外

47:19.880 --> 47:21.880
就增长的搜索引擎

47:21.880 --> 47:23.880
越能够匹配你的搜索结果的

47:23.880 --> 47:25.880
所以越应该靠前

47:25.880 --> 47:27.880
然后这就涉及到一个问题

47:27.880 --> 47:29.880
他怎么知道哪个结果

47:29.880 --> 47:31.880
更加匹配你的搜索

47:31.880 --> 47:32.880
他怎么知道

47:32.880 --> 47:34.880
当然他一个综合考虑

47:34.880 --> 47:37.880
那么其中一个考虑点就是

47:37.880 --> 47:39.880
相似度

47:39.880 --> 47:41.880
跟你的搜索持

47:41.880 --> 47:44.880
跟他的搜索结果

47:44.880 --> 47:45.880
这么多结果里边

47:45.880 --> 47:46.880
哪个结果更加相似

47:46.880 --> 47:47.880
更相似的

47:47.880 --> 47:48.880
我们就

47:48.880 --> 47:51.880
他排名靠前的机率就越高

47:51.880 --> 47:56.190
那么怎么评判相似度呢

47:56.190 --> 47:58.190
其实就是比较两个字不算

47:58.190 --> 48:00.190
有多少相同的

48:00.190 --> 48:02.190
公共秩序率

48:02.190 --> 48:04.190
那么这里就涉及到一个

48:04.190 --> 48:07.190
求最长公共秩序率的问题

48:07.190 --> 48:08.190
什么意思

48:08.190 --> 48:10.190
比方说这里有两个字不算

48:10.190 --> 48:11.190
随便我瞎写的

48:11.190 --> 48:13.190
两个字不算

48:13.190 --> 48:14.190
这两个字不算

48:14.190 --> 48:17.190
他们的最长公共秩序率是啥呀

48:17.190 --> 48:19.190
就是按照一看

48:19.190 --> 48:20.190
这里边有很多字符

48:20.190 --> 48:23.190
这些字符就出现了先后顺序

48:23.190 --> 48:24.190
那么这里边有很多字符

48:24.190 --> 48:27.190
他们里边也有出现了先后顺序

48:27.190 --> 48:28.190
我们找出那些

48:28.190 --> 48:31.190
出现的先后顺序一致

48:31.190 --> 48:32.190
同时在两个字不算里边

48:32.190 --> 48:35.190
都出现过的字符

48:35.190 --> 48:36.190
看上去有点云

48:36.190 --> 48:37.190
是吧

48:37.190 --> 48:38.190
看上去很复杂

48:38.190 --> 48:39.190
那么他的最长公共秩序率

48:39.190 --> 48:40.190
是什么呢

48:40.190 --> 48:41.190
就这个东西

48:41.190 --> 48:43.190
LCS可以计算出的相似度

48:43.190 --> 48:44.190
你看啊

48:44.190 --> 48:52.190
LCS可以计算出的相似度

48:52.190 --> 48:59.190
LCS可以计算出的相似度

48:59.190 --> 49:00.190
看到没

49:00.190 --> 49:04.270
这就是最长公共秩序率

49:04.270 --> 49:05.270
如果说两个字不算的

49:05.270 --> 49:07.270
最长公共秩序率

49:07.270 --> 49:08.270
越长

49:08.270 --> 49:10.270
那么两个字不算就越相似

49:10.270 --> 49:11.270
这是一个什么

49:11.270 --> 49:13.270
你们邀请的个毕业论文

49:13.270 --> 49:14.270
对不对

49:14.270 --> 49:15.270
不是有些网站

49:15.270 --> 49:17.270
可以通过一些系统来判断

49:17.270 --> 49:19.270
你这个毕业论文是不是超的

49:19.270 --> 49:20.270
我怎么判断呢

49:20.270 --> 49:21.270
我就可以用这种方式

49:21.270 --> 49:23.270
我把两篇文章拿过来

49:23.270 --> 49:24.270
一篇文章就是个字符算

49:24.270 --> 49:26.270
两个字符算扔进去

49:26.270 --> 49:28.270
我看一下他们相似度有多高

49:28.270 --> 49:31.270
相似度达到一定程度的时候

49:31.270 --> 49:32.270
那么很有可能的

49:32.270 --> 49:34.270
毕业论文就是东坪牺牲来的

49:34.270 --> 49:35.270
就超来的

49:35.270 --> 49:36.270
我甭管你去

49:36.270 --> 49:37.270
甭管你怎么去改

49:37.270 --> 49:39.270
改他的就是里边的文字

49:39.270 --> 49:40.270
他的公共纸序率

49:40.270 --> 49:42.270
他是纸序率不是纸圈

49:42.270 --> 49:43.270
纸圈要求连续

49:43.270 --> 49:44.270
不如要求连续的

49:44.270 --> 49:47.270
只要能够出现大量的这种

49:47.270 --> 49:48.270
公共纸序率

49:48.270 --> 49:51.270
那么两篇论文的十字八九

49:51.270 --> 49:53.270
都是借鉴 超过来的

49:53.270 --> 49:54.270
懂我的意思吧

49:54.270 --> 49:56.270
就是最长公共纸序

49:56.270 --> 49:59.580
从来这个意识能不能理解

49:59.580 --> 50:00.580
意识能不能理解

50:00.580 --> 50:06.010
能理解是吧

50:06.010 --> 50:07.010
好

50:07.010 --> 50:09.010
那么现在我们来看

50:09.010 --> 50:10.010
这是怎么写

50:10.010 --> 50:12.010
怎么写的问题

50:12.010 --> 50:16.790
LCS

50:16.790 --> 50:17.790
东西

50:17.790 --> 50:18.790
LCS

50:18.790 --> 50:19.790
你给我个字不错

50:19.790 --> 50:20.790
一给我一个字不错

50:20.790 --> 50:23.790
二我来求最长公共纸序

50:23.790 --> 50:28.790
得到两个字不错的

50:28.790 --> 50:31.790
最长公共纸序率

50:31.790 --> 50:33.790
所以要是最长

50:33.790 --> 50:34.790
比方说你找的时候

50:34.790 --> 50:36.790
你不能给我这样子找

50:36.790 --> 50:38.790
第一个有什么

50:38.790 --> 50:40.790
有算

50:41.790 --> 50:42.790
算

50:43.790 --> 50:44.790
得

50:44.790 --> 50:46.790
那么这里也有算

50:46.790 --> 50:47.790
得

50:47.790 --> 50:48.790
它也是公共纸序率

50:48.790 --> 50:49.790
但它不是最长的

50:49.790 --> 50:51.790
一定要导出最长的

50:51.790 --> 50:53.790
才能找到相似度

50:53.790 --> 50:54.790
那么现在我们怎么

50:54.790 --> 50:55.790
就是这个

50:55.790 --> 50:56.790
这个还需要返回

50:56.790 --> 50:57.790
返回一个结果

50:57.790 --> 50:58.790
这个体返回的结果

50:58.790 --> 50:59.790
是一个字不错

50:59.790 --> 51:00.790
这个字不错就是

51:00.790 --> 51:01.790
最长公共纸序率

51:01.790 --> 51:02.790
怎么找

51:02.790 --> 51:05.940
这个体

51:05.940 --> 51:06.940
如果说你要

51:06.940 --> 51:07.940
一开始就用

51:07.940 --> 51:09.940
全局的思维去的话

51:09.940 --> 51:10.940
你脑袋要想炸

51:10.940 --> 51:11.940
你都想不出来

51:11.940 --> 51:12.940
好的就办法

51:12.940 --> 51:14.940
太复杂了

51:14.940 --> 51:16.940
情况太多了

51:16.940 --> 51:17.940
所以说我们这里

51:17.940 --> 51:18.940
遇到这种复杂问题

51:18.940 --> 51:19.940
一定得想办法

51:19.940 --> 51:21.940
千方百计的去想办法

51:21.940 --> 51:25.940
怎么去找到重复指过程

51:25.940 --> 51:26.940
它一定可以分解

51:26.940 --> 51:28.940
为很多重复的指过程

51:28.940 --> 51:29.940
也就是说

51:29.940 --> 51:30.940
把它就是

51:30.940 --> 51:31.940
用低规压用循环

51:31.940 --> 51:32.940
这种方式

51:32.940 --> 51:33.940
去重复它

51:33.940 --> 51:34.940
直到一个

51:34.940 --> 51:37.940
终结条件为止

51:37.940 --> 51:38.940
那么怎么来

51:38.940 --> 51:39.940
重复它呢

51:39.940 --> 51:43.850
首先

51:43.850 --> 51:44.850
我们可以去除掉

51:44.850 --> 51:46.850
一个终指条件

51:46.850 --> 51:50.480
什么终结条件呢

51:50.480 --> 51:51.480
就是

51:51.480 --> 51:52.480
我们先不着急去除

51:52.480 --> 51:53.480
我们先看一个

51:53.480 --> 51:59.990
看下面这张图

51:59.990 --> 52:01.990
我们比方说

52:01.990 --> 52:02.990
看的时候

52:02.990 --> 52:03.990
看两个字不错

52:03.990 --> 52:05.990
我就用一个下标

52:05.990 --> 52:06.990
I指向

52:06.990 --> 52:07.990
第一个字不错的

52:07.990 --> 52:08.990
第一个位置

52:08.990 --> 52:10.990
用下标界

52:10.990 --> 52:11.990
指向下标

52:11.990 --> 52:12.990
这个字不错

52:12.990 --> 52:13.990
也就是说

52:13.990 --> 52:14.990
我们现在

52:14.990 --> 52:15.990
有两个变量

52:15.990 --> 52:16.990
I和界

52:16.990 --> 52:17.990
他们分别去指向

52:17.990 --> 52:19.990
第一个字不错的

52:19.990 --> 52:20.990
任何一个位置

52:20.990 --> 52:21.990
界呢

52:21.990 --> 52:22.990
去指向

52:22.990 --> 52:23.990
第二个字不错的

52:23.990 --> 52:24.990
任何一个位置

52:24.990 --> 52:25.990
一开始

52:25.990 --> 52:26.990
他们都在第一个位置

52:26.990 --> 52:27.990
那么现在

52:27.990 --> 52:28.990
我们就把它

52:28.990 --> 52:29.990
分解成了一个指问题

52:29.990 --> 52:30.990
什么指问题

52:30.990 --> 52:31.990
当I指向

52:31.990 --> 52:32.990
第一个字不错的

52:32.990 --> 52:34.990
某一个位置的时候

52:34.990 --> 52:36.990
和界指向

52:36.990 --> 52:37.990
第二个字不错的

52:37.990 --> 52:38.990
某一个位置的时候

52:38.990 --> 52:42.370
该位置

52:42.370 --> 52:44.370
如何处理

52:44.370 --> 52:46.370
就变成这样的一个问题了

52:46.370 --> 52:47.370
就分解出来了

52:47.370 --> 52:48.370
好

52:48.370 --> 52:50.370
那么为了适配这个问题

52:50.370 --> 52:51.370
我这里需要写一个

52:51.370 --> 52:53.810
辅助函数

52:53.810 --> 52:55.810
LCS

52:56.810 --> 52:57.810
I

52:57.810 --> 53:00.120
界

53:00.120 --> 53:01.120
通过它来去算

53:01.120 --> 53:02.120
它去算

53:02.120 --> 53:03.120
I会不断的移动

53:03.120 --> 53:04.120
界也不会

53:04.120 --> 53:06.120
也会不断的移动

53:06.120 --> 53:08.120
其实这个东西呢

53:08.120 --> 53:09.120
是动态规划

53:09.120 --> 53:10.120
也用到了算法里边的

53:10.120 --> 53:11.120
一个双邮标

53:11.120 --> 53:12.120
我们这里

53:12.120 --> 53:13.120
最终返回的是什么

53:13.120 --> 53:14.120
LCS

53:14.120 --> 53:15.120
I

53:15.120 --> 53:16.120
一开始是0

53:16.120 --> 53:17.120
界也是0

53:17.120 --> 53:19.120
一开始就从0开始

53:19.120 --> 53:21.120
I和界是啥意思

53:21.120 --> 53:22.120
把它说是

53:22.120 --> 53:23.120
I指向

53:23.120 --> 53:25.120
第一个字不错的

53:25.120 --> 53:27.120
中的某个位置

53:27.120 --> 53:29.120
界

53:29.120 --> 53:30.120
指向

53:30.120 --> 53:32.120
第二个字不错的

53:32.120 --> 53:34.120
中的某个位置

53:34.120 --> 53:36.120
这个函数要干嘛

53:36.120 --> 53:37.120
看

53:37.120 --> 53:40.120
这两个位置如何处理

53:40.120 --> 53:44.120
两个位置如何处理

53:44.120 --> 53:45.120
也就是说

53:45.120 --> 53:46.120
我们把一个整体的问题

53:46.120 --> 53:49.820
变成了一个局部的问题

53:49.820 --> 53:51.820
好 看一下

53:51.820 --> 53:53.820
那怎么处理呢

53:53.820 --> 53:55.820
I会不断的移动

53:55.820 --> 53:57.820
界会不断的移动

53:57.820 --> 53:58.820
I只会

53:58.820 --> 53:59.820
它不会往前移动

53:59.820 --> 54:00.820
它就会往后移动

54:00.820 --> 54:02.820
不断的往后移动

54:02.820 --> 54:04.820
界也是不断的往后移动

54:04.820 --> 54:05.820
懂了意思吧

54:05.820 --> 54:06.820
好 那么现在的

54:06.820 --> 54:07.820
我们的问题就是

54:07.820 --> 54:08.820
指向这个位置

54:08.820 --> 54:10.820
如何来处理

54:10.820 --> 54:12.820
那么大家想一想

54:12.820 --> 54:13.820
如果说

54:13.820 --> 54:16.820
我们看一下激动情况

54:16.820 --> 54:18.820
如果说是这种情况

54:19.820 --> 54:21.820
我们先从一些简单的地方看

54:21.820 --> 54:22.820
现在我们问题已经分解了

54:22.820 --> 54:23.820
分解成

54:23.820 --> 54:25.820
只看这个位置了

54:25.820 --> 54:27.820
只看这个位置了

54:27.820 --> 54:28.820
如果说

54:28.820 --> 54:29.820
I指向的位置

54:29.820 --> 54:31.820
和界指向的位置

54:31.820 --> 54:33.820
他们制服是相同的

54:33.820 --> 54:38.090
我就问大家这么一个问题

54:38.090 --> 54:39.090
他们的制服是相同的

54:39.090 --> 54:40.090
就这个位置而言

54:40.090 --> 54:41.090
不用去考虑其他的

54:41.090 --> 54:43.090
就这个位置而言

54:43.090 --> 54:45.090
要不要进入公共秩序的

54:45.090 --> 54:49.960
要不要

54:49.960 --> 54:51.960
你觉得要不要吗

54:51.960 --> 54:52.960
我不管其他的

54:52.960 --> 54:54.960
我就管I指向这个位置

54:54.960 --> 54:55.960
跟界指向的位置

54:55.960 --> 54:56.960
是相同的

54:56.960 --> 54:57.960
不管界在哪

54:57.960 --> 54:58.960
一开始界在这

54:58.960 --> 54:59.960
刚才是界是0

54:59.960 --> 55:00.960
界会不断的移动

55:00.960 --> 55:01.960
对吧

55:01.960 --> 55:02.960
比方说已经到这了

55:02.960 --> 55:04.960
他们两个是相同的

55:04.960 --> 55:05.960
要不要进入公共秩序的

55:05.960 --> 55:07.960
一定要

55:07.960 --> 55:08.960
一定要

55:08.960 --> 55:10.960
为什么呢

55:10.960 --> 55:11.960
因为以后

55:11.960 --> 55:12.960
那如果说不进

55:12.960 --> 55:13.960
那万一进了过后

55:13.960 --> 55:14.960
会对后续造成影响

55:14.960 --> 55:16.960
不会的

55:16.960 --> 55:17.960
不会的

55:17.960 --> 55:18.960
为什么不会

55:18.960 --> 55:19.960
比方说

55:19.960 --> 55:20.960
我们这里进入

55:20.960 --> 55:24.960
这里的

55:24.960 --> 55:26.960
我们现在发现相同的

55:26.960 --> 55:27.960
对吧发现相同的

55:27.960 --> 55:28.960
直接记录

55:28.960 --> 55:30.960
然后

55:30.960 --> 55:31.960
I往后别移动

55:31.960 --> 55:32.960
接往后别移动

55:32.960 --> 55:33.960
移位

55:33.960 --> 55:34.960
是不是L就不看了

55:34.960 --> 55:36.960
那么就相当于是看后边的

55:36.960 --> 55:37.960
对不对

55:37.960 --> 55:38.960
对不对

55:38.960 --> 55:39.960
后边有多少

55:39.960 --> 55:40.960
然后再加上前面的L

55:40.960 --> 55:41.960
是不是一定是最长的

55:41.960 --> 55:42.960
后边的最长

55:42.960 --> 55:43.960
加上前面的L

55:43.960 --> 55:44.960
是不是一定最长的

55:44.960 --> 55:46.960
对吧

55:46.960 --> 55:47.960
所以说

55:47.960 --> 55:48.960
这种情况

55:48.960 --> 55:49.960
我们可以非常简单分析

55:49.960 --> 55:50.960
还有什么情况

55:50.960 --> 55:51.960
可以分析的出来

55:51.960 --> 55:53.960
I指向这个位置的

55:53.960 --> 55:54.960
I都没有制服了

55:54.960 --> 55:56.960
I都跑到制服上外别去了

55:56.960 --> 55:57.960
那么我问大家

55:57.960 --> 55:59.960
这种情况下

55:59.960 --> 56:00.960
他们有

56:00.960 --> 56:02.960
目前这个指向的制服

56:02.960 --> 56:04.960
有没有公共秩序的

56:04.960 --> 56:05.960
有没有

56:05.960 --> 56:12.190
I都指向这个位置的

56:12.190 --> 56:14.190
是不是肯定没有

56:14.190 --> 56:15.190
你都跟一个空制服说

56:15.190 --> 56:16.190
去比较了

56:16.190 --> 56:17.190
它怎么来的

56:17.190 --> 56:18.190
就是公共秩序的

56:18.190 --> 56:20.190
而且永远不用再移动了

56:20.190 --> 56:21.190
不需要后边再看了

56:21.190 --> 56:22.190
看都不用再看了

56:22.190 --> 56:23.190
同样道理

56:23.190 --> 56:25.190
戒指向的这种位置

56:25.190 --> 56:26.190
他们不断地移动

56:26.190 --> 56:27.190
我也不知道

56:27.190 --> 56:29.190
怎么会移动的

56:29.190 --> 56:30.190
总之他们会不断地移动

56:30.190 --> 56:31.190
移动到这个位置

56:31.190 --> 56:32.190
不用往后看了

56:32.190 --> 56:33.190
所以说

56:33.190 --> 56:35.190
我们先把这种情况去除掉

56:35.190 --> 56:36.190
如果说

56:36.190 --> 56:37.190
I的值

56:37.190 --> 56:38.190
大于等于

56:38.190 --> 56:41.190
STR1.0

56:41.190 --> 56:43.190
或者是戒的值

56:43.190 --> 56:47.190
大于等于STR2.0

56:47.190 --> 56:49.190
I和戒已经超出范围了

56:49.190 --> 56:51.190
这个时候没法比较了

56:51.190 --> 56:52.190
你没有办法去找

56:52.190 --> 56:53.190
什么公共秩序了

56:53.190 --> 56:55.570
一个制服都入为空了

56:55.570 --> 56:56.570
所以说这个地方

56:56.570 --> 56:57.570
反馈啥

56:57.570 --> 56:58.570
反馈啥

56:58.570 --> 56:59.570
想一下

56:59.570 --> 57:00.570
反馈啥

57:00.570 --> 57:01.570
反馈啥

57:01.570 --> 57:02.570
能不能把这个地方想到

57:02.570 --> 57:03.570
这个地方想到

57:03.570 --> 57:05.880
都很了不起了

57:05.880 --> 57:12.140
反馈啥

57:12.140 --> 57:13.140
非常好

57:13.140 --> 57:17.370
非常好

57:17.370 --> 57:18.370
STR3.0也非常好

57:18.370 --> 57:19.370
非常棒

57:19.370 --> 57:33.780
反馈空制服

57:33.780 --> 57:34.780
他们有没有公共秩序了

57:34.780 --> 57:35.780
有公共秩序的是啥

57:35.780 --> 57:37.780
就是空制服装

57:37.780 --> 57:38.780
空制服装不就是

57:38.780 --> 57:39.780
没有公共秩序的吗

57:39.780 --> 57:40.780
对了

57:40.780 --> 57:41.780
非常好

57:41.780 --> 57:43.780
反馈空制服装

57:43.780 --> 57:44.780
好

57:44.780 --> 57:45.780
那么这是这种

57:45.780 --> 57:46.780
比较特殊的情况

57:46.780 --> 57:47.780
那么咱们

57:47.780 --> 57:48.780
后面的情况就是

57:48.780 --> 57:49.780
I和戒都是正常的

57:49.780 --> 57:51.780
I和戒都正常

57:51.780 --> 57:52.780
就是I在这

57:52.780 --> 57:53.780
戒在这

57:53.780 --> 57:54.780
可能I在这

57:54.780 --> 57:55.780
戒在这

57:55.780 --> 57:56.780
那么这里有分很多种情况了

57:56.780 --> 57:57.780
我们一个个来说

57:57.780 --> 57:58.780
比方说

57:58.780 --> 57:59.780
I和戒

57:59.780 --> 58:00.780
两个制服

58:00.780 --> 58:02.780
出现了相等

58:02.780 --> 58:03.780
一个个来

58:03.780 --> 58:04.780
这里有很多种情况

58:04.780 --> 58:05.780
一个个来

58:05.780 --> 58:07.780
如果说I这个制服

58:07.780 --> 58:09.780
就是STR1I

58:09.780 --> 58:10.780
等于了

58:10.780 --> 58:13.780
STR2I

58:13.780 --> 58:14.780
原老师你为什么

58:14.780 --> 58:15.780
老师写这种

58:15.780 --> 58:16.780
三个等号

58:16.780 --> 58:17.780
为什么不写两个等号

58:17.780 --> 58:19.780
这是规范史的

58:19.780 --> 58:20.780
不是说两个等号

58:20.780 --> 58:22.780
就不可以

58:22.780 --> 58:23.780
因为戒是

58:23.780 --> 58:24.780
他这个拙来型语言

58:24.780 --> 58:26.780
有一些不严谨性

58:26.780 --> 58:28.780
但是我们写代码的时候

58:28.780 --> 58:29.780
尽量严谨

58:29.780 --> 58:30.780
特别是对于这种

58:30.780 --> 58:31.780
与两个等号

58:31.780 --> 58:32.780
两个等号

58:32.780 --> 58:34.780
会忽略掉一个内心的判断

58:34.780 --> 58:35.780
我最后

58:35.780 --> 58:36.780
把写严谨一点

58:36.780 --> 58:37.780
很多公司里边

58:37.780 --> 58:38.780
他也要求你

58:38.780 --> 58:39.780
代码风格上

58:39.780 --> 58:40.780
也要求你写三个等号

58:40.780 --> 58:42.780
这准备来说一下

58:42.780 --> 58:43.780
那么这里

58:43.780 --> 58:46.780
两个相等了

58:46.780 --> 58:47.780
说这两

58:47.780 --> 58:48.780
这个制服

58:48.780 --> 58:49.780
当前

58:49.780 --> 58:51.780
这个制服

58:51.780 --> 58:54.780
一定进入

58:54.780 --> 58:55.780
追藏

58:55.780 --> 58:56.780
公共

58:56.780 --> 58:58.780
止序列

58:58.780 --> 58:59.780
对不对

58:59.780 --> 59:00.780
一定进入

59:00.780 --> 59:01.780
公共止序列

59:01.780 --> 59:02.780
因为多他一个不多少

59:02.780 --> 59:03.780
他一个不少

59:03.780 --> 59:04.780
把这个制服

59:04.780 --> 59:05.780
你就这样子想吧

59:05.780 --> 59:07.780
那我讲这个制服一蓄掉

59:07.780 --> 59:08.780
那

59:08.780 --> 59:09.780
那这里边还

59:09.780 --> 59:10.780
不还在算吗

59:10.780 --> 59:11.780
对不对

59:11.780 --> 59:12.780
还在算

59:12.780 --> 59:13.780
算出来的

59:13.780 --> 59:14.780
公共止序列

59:14.780 --> 59:15.780
再把刚才的制服加上

59:15.780 --> 59:16.780
是不是一定是最长的

59:16.780 --> 59:17.780
对吧

59:17.780 --> 59:18.780
你把这个东西

59:18.780 --> 59:19.780
这种情况下

59:19.780 --> 59:20.780
算出一个最长

59:20.780 --> 59:21.780
公共止序列

59:21.780 --> 59:22.780
再把刚才的制服加上

59:22.780 --> 59:23.780
那一定是最长的

59:23.780 --> 59:24.780
所以说你

59:24.780 --> 59:25.780
不用考虑

59:25.780 --> 59:26.780
一定要算上

59:26.780 --> 59:28.780
那怎么算上呢

59:29.780 --> 59:32.780
就是直接返回

59:32.780 --> 59:33.780
我的最长公共止序列

59:33.780 --> 59:34.780
是啥

59:34.780 --> 59:35.780
就是当前这个制服

59:35.780 --> 59:36.780
因为他们是一样的

59:36.780 --> 59:37.780
说到这个碍合界

59:37.780 --> 59:38.780
也是一样的

59:38.780 --> 59:39.780
当前这个制服

59:39.780 --> 59:43.220
加上什么

59:43.220 --> 59:44.220
加上啥

59:44.220 --> 59:46.220
加上碍合界

59:46.220 --> 59:49.220
都往后边移动一位

59:49.220 --> 59:51.220
那么去算

59:51.220 --> 59:52.220
那么又接下来算

59:52.220 --> 59:54.220
碍等于这个情况下

59:54.220 --> 59:55.220
碍等于这个情况下

59:55.220 --> 59:56.220
后边的最长公共止序列

59:56.220 --> 59:57.220
借等于

59:57.220 --> 59:58.220
这个位置的情况下

59:58.220 --> 59:59.220
后边的公共止序

59:59.220 --> 01:00:00.220
最长公共止序列

01:00:00.220 --> 01:00:02.220
明白的意思吗

01:00:02.220 --> 01:00:03.220
是不是这种情况

01:00:03.220 --> 01:00:04.220
如果说相同的话

01:00:04.220 --> 01:00:05.220
那么就把

01:00:05.220 --> 01:00:06.220
往后边移动一位

01:00:06.220 --> 01:00:07.220
是不是重新

01:00:07.220 --> 01:00:09.220
通过LCS来算

01:00:09.220 --> 01:00:10.220
i加1

01:00:10.220 --> 01:00:14.360
接加1

01:00:14.360 --> 01:00:17.360
对不对

01:00:17.360 --> 01:00:18.360
最长公共止序列

01:00:18.360 --> 01:00:19.360
是不是等于这个

01:00:19.360 --> 01:00:20.360
我这个制服要算

01:00:20.360 --> 01:00:21.360
然后后边的

01:00:21.360 --> 01:00:22.360
最长公共止序列

01:00:22.360 --> 01:00:23.360
加上我这个制服

01:00:23.360 --> 01:00:24.360
拼接起来

01:00:24.360 --> 01:00:26.360
不就是最长公共止序列吗

01:00:26.360 --> 01:00:28.360
这两个相同的情况

01:00:28.360 --> 01:00:30.360
那里看这个逻辑

01:00:30.360 --> 01:00:31.360
比方说到这了

01:00:31.360 --> 01:00:33.360
i和系又相同

01:00:33.360 --> 01:00:34.360
是不是他又得

01:00:34.360 --> 01:00:35.360
把这个制服算上

01:00:35.360 --> 01:00:37.360
又得往后移动

01:00:37.360 --> 01:00:38.360
s又相同

01:00:38.360 --> 01:00:39.360
又得把这个制服算上

01:00:39.360 --> 01:00:41.360
一次往后移动

01:00:41.360 --> 01:00:43.360
懂了意思吗

01:00:43.360 --> 01:00:44.360
好

01:00:44.360 --> 01:00:45.360
那么接下来

01:00:45.360 --> 01:00:46.360
这是这种情况

01:00:46.360 --> 01:00:48.360
第二种情况

01:00:48.360 --> 01:00:50.360
不相等了

01:00:50.360 --> 01:00:52.360
两个制服不相等了

01:00:52.360 --> 01:00:53.360
不相等

01:00:53.360 --> 01:00:54.360
你咋办

01:00:54.360 --> 01:00:56.360
这是最关键的

01:00:56.360 --> 01:00:57.360
比方说

01:00:57.360 --> 01:00:59.360
第一个制服就不相等

01:00:59.360 --> 01:01:01.360
不相等咋办

01:01:01.360 --> 01:01:02.360
不相等

01:01:02.360 --> 01:01:03.360
这个制服

01:01:03.360 --> 01:01:05.360
你不能说就直接不要

01:01:05.360 --> 01:01:06.360
你不能说直接把这个制服

01:01:06.360 --> 01:01:07.360
就去掉了

01:01:07.360 --> 01:01:08.360
i往后移动一个

01:01:08.360 --> 01:01:09.360
接往后移动一个

01:01:09.360 --> 01:01:10.360
那就完蛋了

01:01:10.360 --> 01:01:12.360
因为有可能接后边

01:01:12.360 --> 01:01:13.360
因为有可能

01:01:13.360 --> 01:01:14.360
这个制服算后边

01:01:14.360 --> 01:01:16.360
有跟这个位置相等的

01:01:16.360 --> 01:01:17.360
你不能把i移动

01:01:17.360 --> 01:01:18.360
你接移动

01:01:18.360 --> 01:01:19.360
那同样的道理

01:01:19.360 --> 01:01:20.360
你不能把接不动

01:01:20.360 --> 01:01:21.360
i移动

01:01:21.360 --> 01:01:22.360
那同样的问题

01:01:22.360 --> 01:01:23.360
对不对

01:01:23.360 --> 01:01:24.360
所以说他这里到底

01:01:24.360 --> 01:01:26.360
谁移动的问题

01:01:26.360 --> 01:01:27.360
两个一起移动

01:01:27.360 --> 01:01:28.360
还是我不动

01:01:28.360 --> 01:01:30.360
还是你不动

01:01:30.360 --> 01:01:31.360
那么到底是什么情况

01:01:31.360 --> 01:01:35.950
到底哪个移动的问题

01:01:35.950 --> 01:01:36.950
哪个移动的

01:01:36.950 --> 01:01:38.950
都要看

01:01:38.950 --> 01:01:39.950
第一种情况是

01:01:39.950 --> 01:01:40.950
i不动

01:01:40.950 --> 01:01:43.950
接往后边移动一个

01:01:43.950 --> 01:01:44.950
那么来算出这个制服串

01:01:44.950 --> 01:01:45.950
跟这个

01:01:45.950 --> 01:01:47.950
跟接后边这个制服串的

01:01:47.950 --> 01:01:49.950
最长功能直去列

01:01:49.950 --> 01:01:50.950
然后再看

01:01:50.950 --> 01:01:51.950
接不动

01:01:51.950 --> 01:01:54.950
i移动

01:01:54.950 --> 01:01:57.950
算出

01:01:57.950 --> 01:01:59.950
接后边这个制服串

01:01:59.950 --> 01:02:01.950
跟i后边这个制服串的

01:02:01.950 --> 01:02:02.950
最长功能直去列

01:02:02.950 --> 01:02:03.950
然后比较

01:02:03.950 --> 01:02:05.950
看哪个更长

01:02:05.950 --> 01:02:06.950
因为我们要算到

01:02:06.950 --> 01:02:07.950
最长功能直去列

01:02:07.950 --> 01:02:08.950
所以说看哪个更长

01:02:08.950 --> 01:02:09.950
所以说

01:02:09.950 --> 01:02:10.950
这里的做法

01:02:10.950 --> 01:02:11.950
分两种情况

01:02:11.950 --> 01:02:14.950
i不动

01:02:14.950 --> 01:02:15.950
还有就是

01:02:15.950 --> 01:02:16.950
接不动

01:02:16.950 --> 01:02:21.310
好

01:02:21.310 --> 01:02:22.310
第一个是i不动

01:02:22.310 --> 01:02:23.310
i不动的话

01:02:23.310 --> 01:02:24.310
我们来算最长功能直去列

01:02:24.310 --> 01:02:25.310
该怎么算

01:02:25.310 --> 01:02:26.310
lcs

01:02:26.310 --> 01:02:28.310
i不动

01:02:28.310 --> 01:02:29.310
接移动

01:02:29.310 --> 01:02:31.940
算出来一个

01:02:31.940 --> 01:02:32.940
最长功能直去列

01:02:35.580 --> 01:02:36.580
对不对

01:02:37.580 --> 01:02:38.580
好

01:02:38.580 --> 01:02:39.580
第二个是接不动

01:02:39.580 --> 01:02:41.580
其他代码并不多

01:02:41.580 --> 01:02:45.270
就逻辑比较复杂

01:02:45.270 --> 01:02:46.270
i加1

01:02:46.270 --> 01:02:49.220
接不动

01:02:49.220 --> 01:02:50.220
所以算法

01:02:50.220 --> 01:02:51.220
两个最长功能直去列

01:02:51.220 --> 01:02:52.220
那你看吧

01:02:52.220 --> 01:02:53.220
主要怎么算

01:02:53.220 --> 01:02:54.220
我算这个时候

01:02:54.220 --> 01:02:55.220
i不要动

01:02:55.220 --> 01:02:56.220
i不动

01:02:56.220 --> 01:02:57.220
接动

01:02:57.220 --> 01:02:58.220
那么这个又继续算

01:02:58.220 --> 01:02:59.220
又重复整个过程

01:02:59.220 --> 01:03:00.220
他们不想等

01:03:00.220 --> 01:03:01.220
不想等的话

01:03:01.220 --> 01:03:02.220
又来

01:03:02.220 --> 01:03:03.220
i动

01:03:03.220 --> 01:03:04.220
接不动

01:03:04.220 --> 01:03:05.220
或者是i不动

01:03:05.220 --> 01:03:06.220
接动

01:03:06.220 --> 01:03:08.220
总共就用这种方式

01:03:08.220 --> 01:03:10.220
把整个字幕上搜索完

01:03:10.220 --> 01:03:12.220
懂了意思吧

01:03:12.220 --> 01:03:13.220
好

01:03:13.220 --> 01:03:15.220
然后

01:03:15.220 --> 01:03:17.220
两个比较大小

01:03:17.220 --> 01:03:19.220
如果说lcs

01:03:19.220 --> 01:03:20.220
i.nce

01:03:20.220 --> 01:03:21.220
小于了

01:03:21.220 --> 01:03:22.220
lcs

01:03:22.220 --> 01:03:24.220
i.nce

01:03:24.220 --> 01:03:25.220
或者我们用个

01:03:25.220 --> 01:03:26.220
三不一算伏也行

01:03:26.220 --> 01:03:27.220
那么最后的

01:03:27.220 --> 01:03:28.220
最长功能直去

01:03:28.220 --> 01:03:29.220
是什么

01:03:29.220 --> 01:03:30.220
如果说lcs

01:03:30.220 --> 01:03:31.220
i.nce

01:03:31.220 --> 01:03:32.220
大于了

01:03:32.220 --> 01:03:33.220
lcs

01:03:33.220 --> 01:03:34.220
i.nce

01:03:34.220 --> 01:03:35.220
lcs

01:03:35.220 --> 01:03:36.220
i.nce

01:03:36.220 --> 01:03:37.220
否则的话

01:03:37.220 --> 01:03:39.980
lcs

01:03:39.980 --> 01:03:40.980
大一码多吗

01:03:40.980 --> 01:03:41.980
不多

01:03:41.980 --> 01:03:44.360
你看就这么几行代码

01:03:44.360 --> 01:03:46.360
单逻辑付展

01:03:46.360 --> 01:03:47.360
你没有失路的话

01:03:47.360 --> 01:03:50.120
这个代码是写不出来的

01:03:50.120 --> 01:03:52.120
就写完了

01:03:52.120 --> 01:03:54.880
就写完了

01:03:54.880 --> 01:03:55.880
好

01:03:55.880 --> 01:04:01.460
咱们来看一下吧

01:04:01.460 --> 01:04:02.460
运算

01:04:02.460 --> 01:04:04.460
我们这里

01:04:04.460 --> 01:04:05.460
就调用吧

01:04:05.460 --> 01:04:07.460
lcs

01:04:07.460 --> 01:04:08.460
两个字幕刷

01:04:08.460 --> 01:04:11.220
第一个字幕刷扔进去

01:04:11.220 --> 01:04:12.220
看看能不能得到结果

01:04:12.220 --> 01:04:13.220
正确的结果

01:04:13.220 --> 01:04:18.000
第一个字幕刷扔进去

01:04:18.000 --> 01:04:20.700
vout

01:04:20.700 --> 01:04:21.700
vout

01:04:21.700 --> 01:04:25.930
刷新

01:04:26.930 --> 01:04:27.930
等吧

01:04:27.930 --> 01:04:28.930
我们看他要算多久

01:04:30.930 --> 01:04:31.930
你知道这个计算量

01:04:31.930 --> 01:04:32.930
有多庞大

01:04:32.930 --> 01:04:33.930
就知道了

01:04:33.930 --> 01:04:35.930
相当庞大的计算量

01:04:35.930 --> 01:04:36.930
你看

01:04:36.930 --> 01:04:37.930
挨动

01:04:37.930 --> 01:04:38.930
挨不动

01:04:38.930 --> 01:04:39.930
借动

01:04:39.930 --> 01:04:40.930
这是一种情况

01:04:40.930 --> 01:04:41.930
那这种情况

01:04:41.930 --> 01:04:42.930
后面又是不是又可以分化

01:04:42.930 --> 01:04:43.930
我也有很多情况

01:04:43.930 --> 01:04:44.930
那么还有一种借动

01:04:44.930 --> 01:04:45.930
刷完了过后

01:04:45.930 --> 01:04:46.930
我还要算借动

01:04:46.930 --> 01:04:47.930
借不动

01:04:47.930 --> 01:04:48.930
挨动

01:04:48.930 --> 01:04:49.930
这又是种情况

01:04:49.930 --> 01:04:50.930
那这种情况

01:04:50.930 --> 01:04:51.930
是不是又得重复计算

01:04:51.930 --> 01:04:52.930
后面又是不是又可以分解为

01:04:52.930 --> 01:04:53.930
很多很多情况

01:04:53.930 --> 01:04:54.930
那后面挨动吧

01:04:54.930 --> 01:04:56.930
后面挨还是不动呢

01:04:56.930 --> 01:04:57.930
后面借动呢

01:04:57.930 --> 01:04:58.930
还是借不动呢

01:04:58.930 --> 01:04:59.930
那么后面

01:04:59.930 --> 01:05:01.930
比方说又分化这种情况

01:05:01.930 --> 01:05:03.930
所以又分化成很多情况

01:05:03.930 --> 01:05:05.930
这个计算量超级超级大

01:05:05.930 --> 01:05:07.930
你看都还没有算完

01:05:07.930 --> 01:05:08.930
我记得

01:05:10.930 --> 01:05:11.930
以前

01:05:11.930 --> 01:05:12.930
上一次我在上级训训的时候

01:05:12.930 --> 01:05:13.930
我刚才算了

01:05:13.930 --> 01:05:14.930
多好几个

01:05:14.930 --> 01:05:15.930
算了算了

01:05:15.930 --> 01:05:16.930
三分钟还是四分钟

01:05:16.930 --> 01:05:18.930
计算量超级大

01:05:18.930 --> 01:05:19.930
总之他在算

01:05:19.930 --> 01:05:20.930
他在算

01:05:20.930 --> 01:05:21.930
我们有钱他会把算完了

01:05:21.930 --> 01:05:22.930
要这种邪法呢

01:05:22.930 --> 01:05:24.930
逻辑肯定是没问题的

01:05:24.930 --> 01:05:25.930
我们以后可能可以

01:05:25.930 --> 01:05:26.930
等他算完了

01:05:26.930 --> 01:05:27.930
可以看一下

01:05:27.930 --> 01:05:29.930
逻辑肯定是没问题的

01:05:29.930 --> 01:05:30.930
那问题在哪呢

01:05:30.930 --> 01:05:31.930
那个计算量太大了

01:05:31.930 --> 01:05:33.930
那这里边有没有重复的计算

01:05:33.930 --> 01:05:34.930
肯定是有

01:05:34.930 --> 01:05:36.930
肯定是有重复计算

01:05:36.930 --> 01:05:38.930
跑了跑不掉的

01:05:38.930 --> 01:05:40.930
那么我现在就剩下一个问题

01:05:40.930 --> 01:05:43.930
就是怎么来消除重复计算

01:05:43.930 --> 01:05:45.930
是不是又在缓存

01:05:45.930 --> 01:05:46.930
对吧

01:05:46.930 --> 01:05:47.930
又在缓存

01:05:47.930 --> 01:05:49.930
啊怎么缓存呢

01:05:49.930 --> 01:05:51.930
水源咋缓存吧

01:05:51.930 --> 01:05:53.930
刚才我们用数组缓存

01:05:53.930 --> 01:05:55.930
现在我们用对相缓存吧

01:05:55.930 --> 01:05:57.930
现在我们用对相缓存

01:05:57.930 --> 01:05:59.930
OB借

01:05:59.930 --> 01:06:00.930
对相缓存

01:06:00.930 --> 01:06:01.930
一个对相

01:06:01.930 --> 01:06:03.930
我就开启了

01:06:03.930 --> 01:06:05.930
用数组也行啊

01:06:05.930 --> 01:06:06.930
总之问题总能

01:06:06.930 --> 01:06:07.930
总能找到一个地方存

01:06:07.930 --> 01:06:09.930
把那结果存起来

01:06:09.930 --> 01:06:11.930
想办法呗

01:06:11.930 --> 01:06:12.930
那么现在无非就是

01:06:12.930 --> 01:06:14.930
不同的I不同的借得到的结果

01:06:14.930 --> 01:06:15.930
就是I和借却低下来

01:06:15.930 --> 01:06:16.930
结果一定是相同的

01:06:16.930 --> 01:06:17.930
对吧

01:06:17.930 --> 01:06:19.930
那么不同的I不同的借得到的结果

01:06:19.930 --> 01:06:20.930
可能不一样

01:06:20.930 --> 01:06:22.930
那么比方说我们是怎么来存的

01:06:22.930 --> 01:06:23.930
就是我们用属性的名字

01:06:23.930 --> 01:06:25.930
我们就有这样子写啊

01:06:25.930 --> 01:06:26.930
属性的名字呢

01:06:26.930 --> 01:06:28.930
我们就是I衡杠借

01:06:28.930 --> 01:06:30.930
I是个数字衡杠

01:06:30.930 --> 01:06:31.930
属性的名字

01:06:31.930 --> 01:06:33.930
等于某一个结果

01:06:33.930 --> 01:06:34.930
比方说我们就是用

01:06:34.930 --> 01:06:36.930
这种方式来写吧

01:06:36.930 --> 01:06:37.930
利用数组的话

01:06:37.930 --> 01:06:38.930
也可以要签一个二维数组

01:06:38.930 --> 01:06:39.930
对不对

01:06:39.930 --> 01:06:40.930
签个二维数组也行啊

01:06:40.930 --> 01:06:42.930
总归例子能找到办法的

01:06:42.930 --> 01:06:43.930
那这种情况

01:06:43.930 --> 01:06:44.930
我们不用看了

01:06:44.930 --> 01:06:45.930
这种情况不设计运算

01:06:45.930 --> 01:06:46.930
那么这里设计到运算了

01:06:47.930 --> 01:06:49.930
还在算啊

01:06:49.930 --> 01:06:50.930
这种情况啊

01:06:50.930 --> 01:06:51.930
设计到运算了

01:06:51.930 --> 01:06:53.930
那么这里设计到运算的时候呢

01:06:53.930 --> 01:06:54.930
我们怎么来做呢

01:06:54.930 --> 01:06:58.560
首先判断有没有缓存

01:06:58.560 --> 01:06:59.560
怎么来判断有没有缓存

01:06:59.560 --> 01:07:00.560
是不是要通过这个属性

01:07:00.560 --> 01:07:02.560
构造出这么一个属性名字

01:07:02.560 --> 01:07:04.560
然后从缓存里面去取啊

01:07:04.560 --> 01:07:05.560
好

01:07:05.560 --> 01:07:06.560
我们的属性名字要构造一个

01:07:06.560 --> 01:07:07.560
啊

01:07:07.560 --> 01:07:08.560
呃

01:07:08.560 --> 01:07:09.560
太起

01:07:09.560 --> 01:07:10.560
T

01:07:10.560 --> 01:07:11.560
这是缓存的

01:07:11.560 --> 01:07:13.560
缓存的名字

01:07:13.560 --> 01:07:14.560
你取到ES6过后呢

01:07:14.560 --> 01:07:15.560
这里还可以用Mac

01:07:15.560 --> 01:07:16.560
都可以啊

01:07:16.560 --> 01:07:17.560
缓存的名字等于什么呢

01:07:17.560 --> 01:07:18.560
等于

01:07:18.560 --> 01:07:19.560
I

01:07:19.560 --> 01:07:20.560
拼接一个

01:07:20.560 --> 01:07:21.560
很刚

01:07:21.560 --> 01:07:23.560
拼接一个界

01:07:23.560 --> 01:07:24.560
如果我们自行约定的啊

01:07:24.560 --> 01:07:25.560
也I约定什么

01:07:25.560 --> 01:07:27.560
比方于中间约定个A

01:07:27.560 --> 01:07:28.560
还是约定了什么

01:07:28.560 --> 01:07:29.560
无所谓

01:07:29.560 --> 01:07:31.560
都这么约定一个属性名字

01:07:31.560 --> 01:07:33.560
这是我们缓存的

01:07:33.560 --> 01:07:35.560
属性名字

01:07:35.560 --> 01:07:36.560
啊

01:07:36.560 --> 01:07:37.560
好

01:07:37.560 --> 01:07:38.560
那么我们来看一下

01:07:38.560 --> 01:07:39.560
通过这个属性名字

01:07:39.560 --> 01:07:40.560
在开启里面

01:07:40.560 --> 01:07:41.560
有没有这个值呢

01:07:41.560 --> 01:07:42.560
开启

01:07:42.560 --> 01:07:43.560
对吧

01:07:43.560 --> 01:07:45.560
我们用个属性表达式

01:07:45.560 --> 01:07:46.560
用这个属性

01:07:46.560 --> 01:07:47.560
这个属性的名字

01:07:47.560 --> 01:07:48.560
去看一下这个缓存里面

01:07:48.560 --> 01:07:49.560
有没有这个值呢

01:07:49.560 --> 01:07:50.560
如果说有的话

01:07:50.560 --> 01:07:51.560
说有缓存

01:07:51.560 --> 01:07:52.560
啊

01:07:52.560 --> 01:07:53.560
有缓存

01:07:53.560 --> 01:07:54.560
有缓存的话

01:07:54.560 --> 01:07:55.560
没反悔什么了

01:07:55.560 --> 01:07:56.560
就反悔这个缓存结果

01:07:56.560 --> 01:07:57.560
就不用算了

01:07:57.560 --> 01:07:58.560
不用算了

01:07:58.560 --> 01:07:59.560
算计算量太大了

01:07:59.560 --> 01:08:00.560
总的意思吧

01:08:00.560 --> 01:08:01.560
他还在算啊

01:08:03.560 --> 01:08:04.560
计算量太大了

01:08:04.560 --> 01:08:06.560
是不是说缓存结果反悔了

01:08:06.560 --> 01:08:07.560
就跟那个

01:08:07.560 --> 01:08:08.560
之前那个青蛙跳台

01:08:08.560 --> 01:08:09.560
这个道理是一样的

01:08:09.560 --> 01:08:10.560
就是你算之前

01:08:10.560 --> 01:08:11.560
看有没有缓存

01:08:11.560 --> 01:08:12.560
然后缓存

01:08:12.560 --> 01:08:13.560
你用出主页号

01:08:13.560 --> 01:08:14.560
用对象页号随便你

01:08:14.560 --> 01:08:15.560
你按用啥用啥

01:08:15.560 --> 01:08:17.560
只要你能够把结构存起来

01:08:17.560 --> 01:08:18.560
你能够

01:08:18.560 --> 01:08:19.560
非常方便的能够找到

01:08:19.560 --> 01:08:20.560
就行了

01:08:20.560 --> 01:08:22.560
有缓存直接反悔缓存

01:08:22.560 --> 01:08:23.560
好没有缓存了

01:08:23.560 --> 01:08:24.560
那就算呗

01:08:24.560 --> 01:08:25.560
那算呗标

01:08:25.560 --> 01:08:26.560
这是一个结果

01:08:26.560 --> 01:08:27.560
没有缓存的话

01:08:27.560 --> 01:08:28.560
我就

01:08:28.560 --> 01:08:30.560
我就设置有缓存呗

01:08:30.560 --> 01:08:31.560
啊

01:08:31.560 --> 01:08:33.560
catch result

01:08:33.560 --> 01:08:35.560
一开始没有值嘛

01:08:35.560 --> 01:08:36.560
好

01:08:36.560 --> 01:08:37.560
这是

01:08:37.560 --> 01:08:39.560
计算结果

01:08:39.560 --> 01:08:40.560
计算结果

01:08:40.560 --> 01:08:41.560
我们就用一个

01:08:41.560 --> 01:08:42.560
relouse的

01:08:42.560 --> 01:08:43.560
计算结果

01:08:43.560 --> 01:08:44.560
那如果说

01:08:44.560 --> 01:08:45.560
这种情况的话

01:08:45.560 --> 01:08:47.560
我就把结果保存到这儿

01:08:47.560 --> 01:08:48.560
如果说这种情况的话

01:08:48.560 --> 01:08:50.560
我就把结果保存到这儿

01:08:50.560 --> 01:08:52.560
我就先不着急返回了

01:08:52.560 --> 01:08:54.560
我先把个结果保存起来

01:08:54.560 --> 01:08:55.560
保存起来过后呢

01:08:55.560 --> 01:08:57.560
在最后我再把它缓存起来

01:08:57.560 --> 01:08:59.560
缓存结果

01:08:59.560 --> 01:09:00.560
怎么缓存

01:09:00.560 --> 01:09:01.560
catch

01:09:01.560 --> 01:09:02.560
catch

01:09:02.560 --> 01:09:04.560
刚才的属性名

01:09:04.560 --> 01:09:05.560
等于什么

01:09:05.560 --> 01:09:06.560
等于relouse

01:09:06.560 --> 01:09:07.560
缓存起来

01:09:07.560 --> 01:09:08.560
最后呢

01:09:08.560 --> 01:09:09.560
才把relouse返回

01:09:10.560 --> 01:09:11.560
就完了

01:09:11.560 --> 01:09:12.560
缓存有多复杂呢

01:09:12.560 --> 01:09:13.560
就是你在计算之前

01:09:13.560 --> 01:09:14.560
计算之后呢

01:09:14.560 --> 01:09:15.560
把它缓存起来

01:09:15.560 --> 01:09:17.560
避免重复因算

01:09:17.560 --> 01:09:18.560
喜欢的

01:09:18.560 --> 01:09:22.320
它还在算

01:09:22.320 --> 01:09:23.320
别算了吧

01:09:23.320 --> 01:09:24.320
你别算了

01:09:24.320 --> 01:09:25.320
这么也算了

01:09:25.320 --> 01:09:26.320
我等不了你

01:09:26.320 --> 01:09:27.320
好

01:09:27.320 --> 01:09:28.320
来看

01:09:28.320 --> 01:09:31.530
一刷新

01:09:31.530 --> 01:09:32.530
你看有了缓存过后你看

01:09:32.530 --> 01:09:33.530
速度是不是非常快

01:09:33.530 --> 01:09:34.530
这边它还在算

01:09:34.530 --> 01:09:36.530
都还没算完

01:09:36.530 --> 01:09:37.530
计算量太大了

01:09:37.530 --> 01:09:38.530
但是有了缓存过后

01:09:38.530 --> 01:09:39.530
是不是速度快了很多

01:09:39.530 --> 01:09:41.530
一下就出来了

01:09:41.530 --> 01:09:43.530
效果差异是天差地别

01:09:43.530 --> 01:09:44.530
天差地别的

01:09:44.530 --> 01:09:45.530
而因为

01:09:45.530 --> 01:09:46.530
但是呢

01:09:46.530 --> 01:09:47.530
空间换时间

01:09:47.530 --> 01:09:51.800
我们来看一下空间的情况

01:09:51.800 --> 01:09:52.800
速度开

01:09:52.800 --> 01:09:53.800
看一下空间

01:09:53.800 --> 01:09:55.800
它缓存里边缓存了啥

01:09:55.800 --> 01:09:56.800
它为了避免重复因算

01:09:56.800 --> 01:09:58.800
你看一下缓存了啥

01:09:58.800 --> 01:09:59.800
i得于0

01:09:59.800 --> 01:10:00.800
j得于0的时候

01:10:00.800 --> 01:10:01.800
它是缓存这个值

01:10:01.800 --> 01:10:02.800
你看

01:10:03.800 --> 01:10:04.800
缓存了各种i的情况

01:10:04.800 --> 01:10:06.800
j的情况

01:10:06.800 --> 01:10:07.800
是

01:10:07.800 --> 01:10:09.800
用到了很多的空间

01:10:09.800 --> 01:10:10.800
不同的i和j

01:10:10.800 --> 01:10:11.800
得到了

01:10:11.800 --> 01:10:12.800
就场公共子续列

01:10:12.800 --> 01:10:14.800
是不一样的

01:10:14.800 --> 01:10:15.800
用了空间

01:10:15.800 --> 01:10:17.800
去换取这个时间

01:10:17.800 --> 01:10:18.800
换了是绝对值得的

01:10:18.800 --> 01:10:19.800
你看一下

01:10:19.800 --> 01:10:20.800
这都还在算

01:10:20.800 --> 01:10:21.800
不知道算了啥时候

01:10:21.800 --> 01:10:24.750
好

01:10:24.750 --> 01:10:26.750
这就是

01:10:26.750 --> 01:10:27.750
这个最成功子续的问题

01:10:27.750 --> 01:10:28.750
通过这两个问题

01:10:28.750 --> 01:10:29.750
再给大家

01:10:29.750 --> 01:10:30.750
见识一下

01:10:30.750 --> 01:10:31.750
动态规划

01:10:31.750 --> 01:10:32.750
到底是

01:10:32.750 --> 01:10:33.750
怎么一做

01:10:44.230 --> 01:10:45.230
地规它不一定会导致

01:10:45.230 --> 01:10:46.230
对战异出

01:10:47.230 --> 01:10:48.230
地规它不一定

01:10:48.230 --> 01:10:49.230
导致对战异出

01:10:49.230 --> 01:10:50.230
因为

01:10:50.230 --> 01:10:51.230
地规

01:10:51.230 --> 01:10:52.230
它这里

01:10:52.230 --> 01:10:53.230
它这里还不是

01:10:53.230 --> 01:10:54.230
对战异出的问题

01:10:54.230 --> 01:10:55.230
因为它会不断的

01:10:55.230 --> 01:10:56.230
入战

01:10:56.230 --> 01:10:57.230
也不会不断的出战

01:10:58.230 --> 01:10:59.230
它的含书不断的入战

01:10:59.230 --> 01:11:00.230
又会不断的出战

01:11:01.230 --> 01:11:03.230
只用那种无限地规

01:11:03.230 --> 01:11:04.230
它只有入战

01:11:04.230 --> 01:11:05.230
没有出战

01:11:05.230 --> 01:11:06.230
这才会导致异出

01:11:07.230 --> 01:11:08.230
但是我们这个地方

01:11:08.230 --> 01:11:09.230
是不断的在入战

01:11:09.230 --> 01:11:10.230
又不断的在出战

01:11:10.230 --> 01:11:11.230
战是没有异出的

01:11:12.230 --> 01:11:13.230
它就是计算量太大了

01:11:13.230 --> 01:11:14.230
它算

01:11:14.230 --> 01:11:15.230
一直没算完

01:11:15.230 --> 01:11:16.230
还得算

01:11:16.230 --> 01:11:17.230
它有出战

01:11:17.230 --> 01:11:18.230
对不对

01:11:18.230 --> 01:11:19.230
那么要解决

01:11:19.230 --> 01:11:20.230
这个

01:11:20.230 --> 01:11:21.230
地规导致占空间

01:11:22.230 --> 01:11:24.230
占用比较多的问题

01:11:24.230 --> 01:11:26.230
可以使用伪地规

01:11:26.230 --> 01:11:27.230
但是这个伪地规

01:11:27.230 --> 01:11:29.230
浏览器是支持的

01:11:29.230 --> 01:11:30.230
是支持优化的

01:11:30.230 --> 01:11:31.230
但是

01:11:31.230 --> 01:11:32.230
斗的环境不支持

01:11:32.230 --> 01:11:34.230
以后有没有会接触斗的

01:11:34.230 --> 01:11:35.230
至少我前段时间

01:11:35.230 --> 01:11:37.230
看斗的还没有支持

01:11:37.230 --> 01:11:38.230
最后就知道

01:11:38.230 --> 01:11:39.230
现在那个十五

01:11:39.230 --> 01:11:40.230
这个版本出来过后

01:11:40.230 --> 01:11:41.230
有没有支持伪地规

01:11:41.230 --> 01:11:42.230
我现在再去试验一下

01:11:43.230 --> 01:11:44.230
但是有意说

01:11:44.230 --> 01:11:45.230
一

01:11:45.230 --> 01:11:46.230
这个伪地规的代码

01:11:46.230 --> 01:11:47.230
它怎么不是人看的

01:11:47.230 --> 01:11:48.230
就一个

01:11:48.230 --> 01:11:49.230
非不拉弃数列

01:11:49.230 --> 01:11:50.230
你把它变成伪地规的形式

01:11:50.230 --> 01:11:52.230
它就不是人看的代码

01:11:52.230 --> 01:11:53.230
意思吧

01:11:53.230 --> 01:11:54.230
说有的时候

01:11:54.230 --> 01:11:56.230
地规这个情况

01:11:56.230 --> 01:11:58.230
还得看情况

01:11:59.230 --> 01:12:00.230
就有的时候

01:12:00.230 --> 01:12:01.230
我们为了增强代码的

01:12:01.230 --> 01:12:02.230
可读性

01:12:02.230 --> 01:12:03.230
发现了它就算

01:12:03.230 --> 01:12:04.230
占的空间

01:12:05.230 --> 01:12:06.230
占用一点

01:12:06.230 --> 01:12:07.230
并没有导致占益出

01:12:07.230 --> 01:12:09.230
在我们的可接受范围内

01:12:09.230 --> 01:12:11.230
就是我们的测试数据范围内

01:12:11.230 --> 01:12:12.230
是没有导致占益出的

01:12:12.230 --> 01:12:13.230
那OK

01:12:13.230 --> 01:12:14.230
那OK我就不用去优化它了

01:12:14.230 --> 01:12:15.230
那有的时候

01:12:15.230 --> 01:12:16.230
它确实导致了占益出

01:12:16.230 --> 01:12:17.230
那我得

01:12:18.230 --> 01:12:19.230
把它变成伪地规形式

01:12:19.230 --> 01:12:20.230
确实伪地规代码

01:12:20.230 --> 01:12:21.230
是没法看的

01:12:22.230 --> 01:12:23.230
但是有的时候

01:12:23.230 --> 01:12:24.230
我们的环境

01:12:24.230 --> 01:12:25.230
又不支持伪地规

01:12:25.230 --> 01:12:26.230
那怎么办

01:12:26.230 --> 01:12:27.230
那就得把它变成

01:12:27.230 --> 01:12:28.230
循环

01:12:28.230 --> 01:12:29.230
循环的格式

01:12:30.230 --> 01:12:31.230
所有的地规理论上

01:12:31.230 --> 01:12:32.230
都能变循环

01:12:33.230 --> 01:12:34.230
所有的循环理论上

01:12:34.230 --> 01:12:35.230
都能变地规

01:12:35.230 --> 01:12:36.230
它们两个

01:12:36.230 --> 01:12:37.230
是可以相互转换的

01:12:37.230 --> 01:12:38.230
其实只是

01:12:38.230 --> 01:12:41.540
设计代码可读性的问题

01:12:41.540 --> 01:12:42.540
好

01:12:42.540 --> 01:12:43.540
这是

01:12:43.540 --> 01:12:44.540
这两个题

01:12:45.540 --> 01:12:46.540
你别算了

01:12:47.540 --> 01:12:48.540
都不知道算了

01:12:49.540 --> 01:12:50.540
然后就是

01:12:51.540 --> 01:12:52.540
我们这几天的

01:12:52.540 --> 01:12:53.540
算法课结束了

01:12:54.540 --> 01:12:55.540
大家就考试

01:12:55.540 --> 01:12:56.540
考试不用担心

01:12:56.540 --> 01:12:57.540
考试不会让你

01:12:57.540 --> 01:12:58.540
去写任何代码的

01:12:58.540 --> 01:12:59.540
就是几道选择题

01:12:59.540 --> 01:13:00.540
我出的

01:13:00.540 --> 01:13:02.540
选择题的答案呢

01:13:02.540 --> 01:13:03.540
基本上你只要听了课

01:13:03.540 --> 01:13:04.540
你只要

01:13:04.540 --> 01:13:05.540
听了课

01:13:05.540 --> 01:13:06.540
我都不要求你

01:13:06.540 --> 01:13:07.540
认真证的听课理

01:13:07.540 --> 01:13:08.540
有没有听懂

01:13:08.540 --> 01:13:09.540
你只要听了

01:13:09.540 --> 01:13:10.540
你一定能做得出来

01:13:10.540 --> 01:13:11.540
而且都不用

01:13:11.540 --> 01:13:12.540
不用邀请全队

01:13:13.540 --> 01:13:14.540
说大家不用去担心这个

01:13:14.540 --> 01:13:15.540
只要你这几天

01:13:15.540 --> 01:13:16.540
大家能够在这里

01:13:16.540 --> 01:13:17.540
学到东西

01:13:17.540 --> 01:13:18.540
有收获就可以了

01:13:18.540 --> 01:13:19.540
好

01:13:19.540 --> 01:13:20.540
最后可以给大家

01:13:20.540 --> 01:13:21.540
出几道思考题

01:13:21.540 --> 01:13:22.540
就出一道思考题

01:13:22.540 --> 01:13:23.540
领域背包问题

01:13:24.540 --> 01:13:25.540
可以尝试着

01:13:25.540 --> 01:13:26.540
用动态规划

01:13:26.540 --> 01:13:27.540
去做一做

01:13:27.540 --> 01:13:28.540
虽然说还是比较有难度的

01:13:28.540 --> 01:13:30.540
领域背包问题

01:13:30.540 --> 01:13:35.010
什么叫领域背包问题呢

01:13:35.010 --> 01:13:36.010
就是说

01:13:36.010 --> 01:13:37.010
我有个背包

01:13:37.010 --> 01:13:38.010
背包有个体积

01:13:38.010 --> 01:13:40.010
背包体积

01:13:40.010 --> 01:13:42.010
体积 尾飞

01:13:42.010 --> 01:13:44.010
总之是个位置数

01:13:44.010 --> 01:13:45.010
要通过参数传递

01:13:45.010 --> 01:13:46.010
传递进去的

01:13:46.010 --> 01:13:48.010
然后我有一些物品

01:13:48.010 --> 01:13:49.010
每个物品

01:13:49.010 --> 01:13:51.010
它有两个属性

01:13:51.010 --> 01:13:53.010
一个是它占用的空间

01:13:53.010 --> 01:13:54.010
比方说

01:13:54.010 --> 01:13:56.010
它有空间20

01:13:56.010 --> 01:13:58.010
一个是它的价值

01:13:58.010 --> 01:14:00.010
Price

01:14:00.010 --> 01:14:01.010
50

01:14:01.010 --> 01:14:02.010
对吧

01:14:02.010 --> 01:14:03.010
每个物品只有一个

01:14:03.010 --> 01:14:05.010
拿了就不用再拿了

01:14:05.010 --> 01:14:08.700
有很多这样的物品

01:14:08.700 --> 01:14:09.700
每个物品占用一些空间

01:14:09.700 --> 01:14:11.700
占用一些价值

01:14:11.700 --> 01:14:13.700
30

01:14:13.700 --> 01:14:15.700
90

01:14:15.700 --> 01:14:16.700
65

01:14:16.700 --> 01:14:18.700
100

01:14:18.700 --> 01:14:20.700
20

01:14:20.700 --> 01:14:22.700
25

01:14:22.700 --> 01:14:24.700
10

01:14:24.700 --> 01:14:26.700
20

01:14:26.700 --> 01:14:27.700
比方说

01:14:27.700 --> 01:14:28.700
就有这么一些物品

01:14:28.700 --> 01:14:29.700
一大堆物品

01:14:29.700 --> 01:14:31.700
这又是个参数

01:14:31.700 --> 01:14:33.700
它说应该是个数数

01:14:33.700 --> 01:14:35.700
那么问

01:14:35.700 --> 01:14:36.700
在这个背包的体积

01:14:36.700 --> 01:14:37.700
这样子的体积情况下

01:14:37.700 --> 01:14:39.700
我怎么选用物品

01:14:39.700 --> 01:14:43.700
才能保证我得到的价值最大

01:14:43.700 --> 01:14:45.700
背包要能装下背包

01:14:45.700 --> 01:14:46.700
同时

01:14:46.700 --> 01:14:47.700
得到的价值最大

01:14:47.700 --> 01:14:48.700
就是个领域背包问题

01:14:48.700 --> 01:14:49.700
这个得

01:14:49.700 --> 01:14:50.700
要得到一个准确的答案

01:14:50.700 --> 01:14:51.700
得用什么

01:14:52.700 --> 01:14:53.700
你不能乱选

01:14:53.700 --> 01:14:54.700
因为局部最有解

01:14:54.700 --> 01:14:55.700
它不一定是选举最有解

01:14:55.700 --> 01:14:56.700
你选了一个过后

01:14:56.700 --> 01:14:57.700
哦哦哦

01:14:57.700 --> 01:14:58.700
后边都会放不下了

01:14:58.700 --> 01:15:01.700
你等于在看情况了

01:15:01.700 --> 01:15:03.700
你可以尝试着去

01:15:03.700 --> 01:15:04.700
想一下

01:15:04.700 --> 01:15:05.700
还有一个问题

01:15:05.700 --> 01:15:06.700
还有一个思考题呢

01:15:06.700 --> 01:15:07.700
就是这个早零问题

01:15:07.700 --> 01:15:08.700
如果说我要得到

01:15:08.700 --> 01:15:10.700
一定要得到一个准确的答案

01:15:10.700 --> 01:15:12.700
那就不能用它一算了

01:15:12.700 --> 01:15:13.700
因为不同

01:15:13.700 --> 01:15:15.700
有些面额是拿不到准确的答案的

01:15:15.700 --> 01:15:17.700
所以说你在用动态规划

01:15:17.700 --> 01:15:18.700
动态规划在这里

01:15:18.700 --> 01:15:19.700
怎么去说

01:15:19.700 --> 01:15:20.700
这两个思考题

01:15:20.700 --> 01:15:21.700
都不简单

01:15:21.700 --> 01:15:22.700
都不简单的

01:15:22.700 --> 01:15:24.700
如果说你能够自己

01:15:24.700 --> 01:15:26.700
能够做出这两道思考题

01:15:26.700 --> 01:15:28.700
你一定要去冲击一下大厂

01:15:28.700 --> 01:15:30.700
你是有机会的

01:15:30.700 --> 01:15:32.700
当然你光靠算法去冲击大厂

01:15:32.700 --> 01:15:33.700
那也不行

01:15:33.700 --> 01:15:34.700
你还得配合

01:15:34.700 --> 01:15:37.700
咱们全端的一些核心知识

01:15:37.700 --> 01:15:38.700
传统手艺不能丢

01:15:38.700 --> 01:15:39.700
也算法虽然说

01:15:39.700 --> 01:15:40.700
冲击大厂很有帮助

01:15:40.700 --> 01:15:41.700
但是你这些传统手艺

01:15:41.700 --> 01:15:43.700
你还是不能丢的

01:15:43.700 --> 01:15:44.700
好了

01:15:44.700 --> 01:15:45.700
其他的别的

01:15:45.700 --> 01:15:47.700
今天我最后一天

01:15:47.700 --> 01:15:48.700
也不知道搞得

01:15:48.700 --> 01:15:50.700
太幸福了

01:15:50.700 --> 01:15:52.700
到这我就可以了

01:15:52.700 --> 01:15:53.700
同学们有啥问题吗

01:15:53.700 --> 01:15:54.700
没啥问题的话

01:15:54.700 --> 01:15:56.700
我就交给学老师了

01:16:01.420 --> 01:16:02.420
OK

01:16:02.420 --> 01:16:05.930
那学老师在不在呢

01:16:06.930 --> 01:16:07.930
运动是吧

01:16:07.930 --> 01:16:09.930
运动慢慢去看迴放吧

01:16:09.930 --> 01:16:10.930
咱们反正有迴放的

01:16:10.930 --> 01:16:11.930
我也是

01:16:11.930 --> 01:16:13.930
经济详细的给大家讲的

01:16:13.930 --> 01:16:15.930
笔记也写了

01:16:15.930 --> 01:16:16.930
该画的图

01:16:16.930 --> 01:16:17.930
该解释的地方

01:16:17.930 --> 01:16:18.930
全是解释到位的

01:16:18.930 --> 01:16:19.930
如果还运动的话

01:16:19.930 --> 01:16:21.930
那可能是你之前的基础

01:16:21.930 --> 01:16:22.930
地方不牢靠

01:16:22.930 --> 01:16:23.930
没关系

01:16:23.930 --> 01:16:24.930
你下载车要慢慢去补

01:16:24.930 --> 01:16:25.930
你不能说

01:16:25.930 --> 01:16:26.930
一直扔这

01:16:26.930 --> 01:16:27.930
还用了就是

01:16:27.930 --> 01:16:28.930
你之前的代码量

01:16:28.930 --> 01:16:29.930
还不够

01:16:29.930 --> 01:16:30.930
那些虚写

