WEBVTT

00:00.110 --> 00:02.750
咱们还是八点五分就开始上课

00:02.750 --> 00:05.670
今天呢就是我一个人了啊

00:05.670 --> 00:06.950
又当爹又当妈了

00:08.070 --> 00:12.550
那个薛老师呢今天去搞公开子路特去了

00:13.550 --> 00:15.070
只有我一个人

00:15.470 --> 00:18.030
摩尼卡呢又不知道跑哪去也去了

00:19.630 --> 00:20.790
就我一个人啊

00:20.790 --> 00:29.080
好久都没有见到摩尼卡了

00:29.080 --> 00:35.620
稍微等一等啊

00:35.620 --> 00:40.180
因为很多同学都是八点五分可能才来

00:40.500 --> 00:42.620
二十六个人差不多吧

00:42.620 --> 00:43.380
人到差不多了

00:43.380 --> 00:50.250
咱们也可以开跳一下啊

00:51.370 --> 00:53.410
今天咱们讲这个数

00:55.410 --> 00:57.210
特别有意识的这么一个数据结构

00:59.210 --> 01:00.730
里边设计到算法非常多

01:00.730 --> 01:02.090
咱们减了一些出来

01:03.330 --> 01:09.410
后期课咱们后期课的算法课里边可能有三分之二吧

01:10.410 --> 01:13.890
至少一半至少一半的课程都在讲这个数

01:13.930 --> 01:15.690
因为他里边设计到很多很多的算法

01:16.690 --> 01:18.170
但是呢我考虑到啊

01:18.170 --> 01:20.410
咱们这个集训营啊

01:20.410 --> 01:23.770
你没办法把这个数的所有的算法给大家一列决出来

01:23.770 --> 01:24.570
不然太多了

01:25.770 --> 01:26.650
然后呢另外呢

01:26.650 --> 01:28.690
要考虑到一个深度的问题

01:28.690 --> 01:31.690
也毕竟有一同学还在考虑到他那个接受度的问题啊

01:31.690 --> 01:37.370
所以说我们精选了一些数里边的一些基本的算法

01:38.770 --> 01:41.730
一些常见的算法选出来给大家讲一下

01:41.730 --> 01:42.210
题呢

01:42.210 --> 01:43.770
今天晚上还是跟昨天一样啊

01:43.770 --> 01:44.570
做一些题

01:45.530 --> 01:47.330
这一题呢有简单的有难的

01:48.970 --> 01:50.250
就这么五道题啊

01:50.250 --> 01:51.290
有些简单有些难

01:52.170 --> 01:53.490
每天差不多就这样子啊

01:53.490 --> 01:55.810
五道题又倒题四道题三道题

01:55.810 --> 01:56.650
基本上都是这样子啊

01:56.650 --> 01:58.090
有些题简单也挺难

01:59.570 --> 02:00.130
讲完之后呢

02:00.130 --> 02:01.370
下边慢慢去琢磨吧

02:02.770 --> 02:04.650
街市刚刚看完元雄链啊

02:04.650 --> 02:07.210
那里走的路很长

02:08.010 --> 02:09.050
不过没关系啊

02:09.050 --> 02:12.330
所有的开发者呢都是从零基础来的

02:12.330 --> 02:13.410
一步一步走的

02:13.450 --> 02:14.730
这完一步就少一步

02:20.020 --> 02:20.700
这几年啊

02:21.700 --> 02:22.860
前端的要求啊

02:23.860 --> 02:25.460
是一年比一年高

02:26.460 --> 02:26.860
知道吧

02:27.860 --> 02:30.420
尤特别是赶上了这几年呢

02:30.420 --> 02:31.260
经济形势呢

02:31.260 --> 02:33.980
不是很好竞争了也比较大

02:33.980 --> 02:34.660
说要求呢

02:34.660 --> 02:36.220
会逐渐的提高

02:36.220 --> 02:36.660
因此呢

02:36.660 --> 02:37.580
大家要学的话

02:37.580 --> 02:38.420
赶快学吧

02:38.420 --> 02:39.140
别拖了

02:39.140 --> 02:43.160
你拖到后面要求的越来越高了

02:43.160 --> 02:46.610
当然对后端也是一样

02:46.610 --> 02:48.130
不想往前了呀

02:48.170 --> 02:49.290
那要走什么方向啊

02:50.970 --> 02:52.330
你要走什么方向啊

02:52.330 --> 02:53.730
所有行业都不容易啊

02:53.730 --> 02:59.620
都不容易的

02:59.620 --> 03:00.940
咱们这几代人吧

03:02.540 --> 03:05.580
不然是为什么说什么中华民族的伟大复兴呢

03:06.620 --> 03:08.580
咱们是几代人要干的几十代人的事

03:09.540 --> 03:10.700
怎么不辛苦肯定辛苦

03:11.700 --> 03:12.500
不然咋复兴了

03:19.800 --> 03:21.880
就面试的时候遭火箭

03:21.880 --> 03:23.560
工作的时候你挪失是吧

03:23.560 --> 03:26.320
今晚都是现在一个常态了

03:26.320 --> 03:28.480
要求越来越高

03:30.440 --> 03:32.680
以前确实以前钱都要求很低的

03:34.200 --> 03:35.920
十年前钱都要求低得不得了

03:36.640 --> 03:39.880
你只需要回aq嘛和css以及gfs够了

03:39.880 --> 03:40.880
就这三个就够了

03:40.880 --> 03:41.600
你可以就业了

03:41.600 --> 03:42.280
不过那个时候呢

03:42.280 --> 03:43.320
薪水是没法看的

03:44.200 --> 03:44.760
那个薪水呢

03:44.760 --> 03:47.120
可能比那个前台行政啊

03:47.120 --> 03:49.320
前台啊高了一点啊油线

03:50.120 --> 03:51.360
那个薪水是没法看的

03:53.360 --> 03:55.680
不是咱们技术行业有个比赛的嘛

03:55.680 --> 03:56.000
对不对

03:56.320 --> 03:58.520
以前前端是随随底层

03:58.520 --> 04:00.120
彼此面子最底层

04:00.120 --> 04:02.520
知道吧

04:02.520 --> 04:03.720
后来慢慢上来过后了

04:03.720 --> 04:07.520
因为当然随之而来的是东西

04:07.520 --> 04:08.120
东西呢

04:08.120 --> 04:09.520
学的东西就越来越多了

04:09.520 --> 04:11.120
越来越复杂了

04:11.120 --> 04:17.750
领罗斯是一个什么样的工作难度啊

04:17.750 --> 04:19.750
啥工作难度呢

04:19.750 --> 04:22.350
就是给你一个最基本的功能

04:22.350 --> 04:24.150
你要能够把实现

04:24.150 --> 04:25.750
就这个难度

04:25.750 --> 04:27.150
它没有任何的复杂度

04:27.150 --> 04:28.550
就纯粹的是马带嘛

04:28.950 --> 04:30.550
脑袋里边可能都不用去思考

04:30.550 --> 04:32.050
啪啪啪把带嘛敲出来

04:32.050 --> 04:33.050
实现就完事了

04:33.050 --> 04:33.850
就是个体力活

04:35.250 --> 04:38.250
领罗斯

04:38.250 --> 04:39.450
但是说是这样子说呢

04:39.450 --> 04:40.250
有点夸张了

04:40.250 --> 04:41.450
因为你平时开发的时候

04:41.450 --> 04:43.550
必须会遇到一些比较麻烦的问题

04:43.550 --> 04:43.950
问题呢

04:43.950 --> 04:44.650
你没有见过

04:44.650 --> 04:45.950
没有见过的自己去分析

04:47.350 --> 04:48.350
所以说开发思维呢

04:48.350 --> 04:49.550
特别重要

04:49.550 --> 04:51.550
你就掌握了开发思维

04:51.550 --> 04:54.550
掌握了解决问题的能力

04:54.550 --> 04:55.950
你把这个能力掌握了

04:55.950 --> 04:56.850
任何问题

04:56.850 --> 04:59.350
任何没有见过的问题出现

04:59.350 --> 05:04.020
你都不会慌

05:04.020 --> 05:07.720
那种思考难度比选择排序难吗

05:07.720 --> 05:08.820
那不一定

05:08.820 --> 05:10.120
不一定

05:10.120 --> 05:10.920
比如说你挪事

05:10.920 --> 05:12.520
你挪事肯定没有

05:12.520 --> 05:14.020
你挪事的肯定没有

05:14.020 --> 05:14.320
但是呢

05:14.320 --> 05:15.820
出现一些没遇到过的问题

05:15.820 --> 05:17.320
你还是得分析去思考

05:17.320 --> 05:18.320
关键是很多问题呢

05:18.320 --> 05:19.820
它不会给你方案的

05:19.820 --> 05:20.920
你看我们这几千的算法

05:20.920 --> 05:22.620
和基本上还会给你方案

05:22.620 --> 05:23.020
对吧

05:23.020 --> 05:24.920
我给你说一种思路

05:24.920 --> 05:25.220
然后呢

05:25.220 --> 05:26.320
你把它写成带吧

05:26.320 --> 05:26.520
不过呢

05:26.520 --> 05:28.320
就连就这个东西呢

05:28.320 --> 05:29.320
对于很多同学来讲

05:29.320 --> 05:30.420
还是难度有点高

05:30.420 --> 05:31.420
不过

05:31.420 --> 05:33.620
总得经历这个阶段

05:33.620 --> 05:35.220
所有人都得经历这个阶段

05:35.220 --> 05:36.020
所有的学开发的

05:36.020 --> 05:37.520
都得经历这个阶段

05:37.520 --> 05:39.720
你首先要搞定第一件事

05:39.720 --> 05:41.320
就是给了你思路了

05:41.320 --> 05:42.320
方法都给力了

05:42.320 --> 05:42.520
啊

05:42.520 --> 05:43.420
方案都给力了

05:43.420 --> 05:44.520
你能你能够用带马

05:44.520 --> 05:46.520
把它写出来

05:46.520 --> 05:48.420
先把这个东西要先过关

05:48.420 --> 05:49.620
这过关了过后呢

05:49.620 --> 05:52.420
再说别人没有给你方案

05:52.420 --> 05:54.520
你自己去想这个方案

05:54.520 --> 05:55.220
哈哈

05:55.220 --> 05:59.160
再说这个这件事

05:59.160 --> 05:59.360
好

05:59.360 --> 05:59.960
来了

05:59.960 --> 06:01.360
数

06:01.360 --> 06:03.260
差不多了啊

06:03.260 --> 06:06.040
数

06:06.040 --> 06:07.840
首先还是一样的规矩

06:07.840 --> 06:09.540
首先了解概念

06:09.540 --> 06:11.940
因为数这里边的算法很多啊

06:11.940 --> 06:13.240
你们以后如果说

06:13.240 --> 06:14.440
去特别是骁招

06:14.440 --> 06:16.340
骁招遇到大厂的时候呢

06:16.340 --> 06:18.440
他面他的算法题比较多

06:18.440 --> 06:19.640
那么数的算法题呢

06:19.640 --> 06:21.440
我估摸着吧

06:21.440 --> 06:23.640
平均下来得三个三分之一

06:23.640 --> 06:25.440
所以说数的算法

06:25.440 --> 06:27.840
大家要引起重视啊

06:27.840 --> 06:28.240
嗯

06:28.240 --> 06:28.840
数呢

06:28.840 --> 06:30.240
什么首先了解他的概念

06:30.240 --> 06:31.340
基本概念

06:31.340 --> 06:32.740
也有因为他的面试题里面

06:32.740 --> 06:33.740
可能有些题比较简单

06:33.740 --> 06:34.940
就是考虑基本概念

06:34.940 --> 06:36.340
就完事了

06:36.340 --> 06:36.640
嗯

06:36.640 --> 06:37.140
然后呢

06:37.140 --> 06:39.640
再来了解他的一些常见的算法

06:39.640 --> 06:40.740
什么叫数呢

06:40.740 --> 06:42.040
数就是这么一种结构

06:42.040 --> 06:43.240
就这么种结构

06:43.240 --> 06:44.240
平时见过没

06:44.240 --> 06:46.940
见过数结构没

06:46.940 --> 06:48.940
平时见过数结构没

06:48.940 --> 06:52.040
什么见过什么样的数结构

06:52.040 --> 06:52.940
只要你学了解识

06:52.940 --> 06:55.940
你一定是接触接触过的

06:55.940 --> 06:57.940
哪哪一种是数结构

06:57.940 --> 07:00.140
我们接触了解识里边

07:00.140 --> 07:01.340
对不就是多么

07:01.340 --> 07:02.240
对不对

07:02.440 --> 07:03.940
文件夹也是啊

07:03.940 --> 07:04.940
你要文件夹文件夹

07:04.940 --> 07:05.640
文件夹这边套文件夹

07:05.640 --> 07:05.940
对吧

07:05.940 --> 07:07.440
文件夹这边套文件

07:07.440 --> 07:08.640
也是一种数结构

07:08.640 --> 07:10.240
他动物就是一个典型的数结构

07:10.240 --> 07:12.240
不然我们为什么叫动物数呢

07:12.240 --> 07:13.040
对不对

07:13.040 --> 07:14.440
就是就就是数结构

07:15.640 --> 07:15.840
啊

07:15.840 --> 07:17.440
那么这个数结构呢

07:18.140 --> 07:20.840
他就是有很多的节点组成

07:20.840 --> 07:23.340
每个节点可以指向0个

07:23.340 --> 07:24.740
或多个其他节点

07:25.840 --> 07:27.240
你看像这个节点

07:27.240 --> 07:28.340
他就指向0个节点

07:28.340 --> 07:29.340
后边没节点了

07:30.140 --> 07:30.840
那么像这个节点

07:30.840 --> 07:32.240
他就指向两个节点

07:32.240 --> 07:33.640
这是数结构

07:33.640 --> 07:36.440
他有点类似于练表的二维结构

07:36.440 --> 07:38.140
练表一个节点只能指向一个

07:38.140 --> 07:39.440
然后数呢可以指向多个

07:40.740 --> 07:40.840
好

07:40.840 --> 07:42.240
那么数有什么特点呢

07:42.240 --> 07:43.440
我们把数呢有的时候

07:43.440 --> 07:45.640
会把它叫做单根无环图

07:46.340 --> 07:47.940
单根无环

07:49.840 --> 07:52.440
无环图啊

07:52.440 --> 07:53.440
明天我们讲图

07:54.840 --> 07:56.040
那么什么叫单根呢

07:56.940 --> 07:57.740
单根的意思呢

07:57.740 --> 07:58.440
就是说

07:58.440 --> 07:59.840
如果一个节点A

07:59.840 --> 08:00.840
只向一个节点B

08:01.440 --> 08:03.340
那么你只能通过A找到B

08:03.340 --> 08:05.840
你不可能说通过其他节点找到B

08:05.840 --> 08:06.540
啥意思

08:06.540 --> 08:08.540
就说比方说这是个A节点啊

08:08.540 --> 08:09.340
这是个B节点

08:10.240 --> 08:12.440
你只能通过他去找到他

08:13.240 --> 08:15.340
你不能通过别的地方去找到他

08:15.340 --> 08:16.140
就是单根性

08:16.840 --> 08:17.140
对吧

08:18.140 --> 08:18.840
那么比方说啊

08:18.840 --> 08:20.840
我们这里有张图看一下啊

08:23.040 --> 08:24.940
比方说这里有一个A节点

08:25.840 --> 08:27.140
这里有一个B节点

08:27.740 --> 08:29.440
那么只能通过A来找到B

08:29.440 --> 08:29.940
对吧

08:29.940 --> 08:32.540
那如果说有一天我们这里有一个指向

08:34.840 --> 08:35.240
啊

08:35.240 --> 08:37.140
比方说这里有个指向啊

08:37.140 --> 08:37.840
这里是C

08:38.240 --> 08:39.040
那么大家看一下

08:39.040 --> 08:40.940
这种结构还是还是数结构吗

08:41.740 --> 08:42.640
还是不是数结构

08:43.140 --> 08:43.940
他就不是了

08:43.940 --> 08:46.140
因为他不符合单根原则

08:46.540 --> 08:47.640
一看B这个节点

08:48.140 --> 08:49.940
他用两个地方可以通向他

08:49.940 --> 08:50.940
A可以通向他

08:51.040 --> 08:52.040
C也可以通向他

08:52.440 --> 08:52.940
对不对

08:53.040 --> 08:54.940
那么这就不是一个单根结构了

08:55.240 --> 08:55.440
啊

08:55.440 --> 08:56.740
所以这就不是一个数

08:57.240 --> 08:57.640
没啥意思吧

08:57.640 --> 08:59.540
这就这么就这么就这么简单

09:00.540 --> 09:01.140
嗯

09:01.140 --> 09:02.640
然后呢什么叫无环呢

09:02.640 --> 09:03.640
那么无环其实有

09:03.640 --> 09:04.840
就是单根的补充

09:05.440 --> 09:07.240
因为一个节点

09:07.240 --> 09:08.740
他只能通过另一个节点

09:08.740 --> 09:10.040
一条路径指向他

09:10.040 --> 09:11.340
他就不可能形成环

09:11.740 --> 09:13.040
那比方说我们刚才看到这个

09:13.040 --> 09:13.940
是不是就形成环了

09:13.940 --> 09:15.240
这里有个圈你看到没

09:15.740 --> 09:17.040
就有个圈对吧

09:17.240 --> 09:18.040
那么有个圈的话

09:18.040 --> 09:19.040
那就不是一个数了

09:19.140 --> 09:19.540
是吧

09:19.540 --> 09:20.740
数是无环的

09:21.340 --> 09:22.140
就这么意思啊

09:22.140 --> 09:23.940
所以叫做单根无环读

09:25.040 --> 09:25.340
好

09:25.340 --> 09:27.440
然后数里边呢有一大堆的数语

09:27.440 --> 09:28.340
一大条一大堆

09:28.340 --> 09:30.240
但是每个数语呢都非常简单

09:30.240 --> 09:31.240
一个个说啊

09:31.940 --> 09:32.640
因为以后呢

09:32.640 --> 09:35.540
我们做讲解一些算法的时候呢

09:35.540 --> 09:36.740
可能会用到这些数语

09:36.740 --> 09:38.340
不然的话你不知道我在说什么

09:39.140 --> 09:40.940
第一个叫做数的度

09:41.840 --> 09:42.640
他要度呢

09:43.040 --> 09:44.340
非常简单就是一个节点的

09:44.340 --> 09:45.740
指节点数量

09:46.340 --> 09:47.040
比方说啊

09:48.440 --> 09:49.140
这个节点

09:49.940 --> 09:51.140
他有几个指节点呢

09:51.140 --> 09:52.140
他有三个指节点

09:52.140 --> 09:53.540
对吧123

09:54.240 --> 09:56.340
那么也就是他的度是多少呢

09:56.340 --> 09:57.640
他的度呢就是3

09:58.140 --> 09:58.340
对吧

09:58.340 --> 09:59.740
这就非常简单啊

09:59.740 --> 10:01.240
就是一个节点的度

10:02.040 --> 10:02.940
就度的干点

10:03.340 --> 10:04.040
那么还有一个度呢

10:04.040 --> 10:05.240
叫做数的度

10:06.040 --> 10:07.240
刚才是一个节点的度

10:07.240 --> 10:08.840
那么还有一个东西叫做数的度

10:09.440 --> 10:10.540
什么叫数的度呢

10:10.740 --> 10:13.140
就整颗数中不是有很多节点吗

10:14.540 --> 10:17.940
那么找到那个度数最高的节点

10:19.040 --> 10:20.940
他的度就是整颗数的度

10:21.440 --> 10:22.340
那么大家想一想吧

10:22.340 --> 10:23.840
按照这样的定义的话

10:24.840 --> 10:26.640
这样的一这样一颗数

10:27.040 --> 10:28.240
他的度是多少

10:30.620 --> 10:32.120
这样一颗数他的度是多少

10:34.900 --> 10:35.200
对吧

10:35.200 --> 10:36.000
不就是3吗

10:36.300 --> 10:37.300
非常简单对不对

10:37.400 --> 10:39.000
把基本干点要认识啊

10:40.200 --> 10:41.000
嗯然后呢

10:41.000 --> 10:43.800
还有一个就是节点的层

10:44.900 --> 10:45.700
啥意思呢

10:45.800 --> 10:46.500
就是

10:47.100 --> 10:48.200
你把整颗数呢

10:49.700 --> 10:50.900
想说人这是第一层

10:51.300 --> 10:52.200
这是第二层

10:52.700 --> 10:53.700
这是第三层

10:54.000 --> 10:54.900
这是第四层

10:55.200 --> 10:56.200
所以非常简单

10:56.300 --> 10:57.600
那这个节点是第几层的

10:57.600 --> 10:58.400
就第三层

10:58.900 --> 11:01.000
这就是节点的层

11:02.200 --> 11:02.600
好

11:02.800 --> 11:06.000
然后还有一个就是数的高度或深度

11:07.600 --> 11:08.300
一个意思啊

11:08.300 --> 11:09.900
说说一颗数的高度

11:09.900 --> 11:11.900
或者说一颗数的深度

11:12.300 --> 11:13.300
都是一个意思

11:13.500 --> 11:14.200
啥意思呢

11:14.400 --> 11:17.300
就是数中的节点的最大层次

11:18.200 --> 11:19.600
比方说这个这颗数中

11:20.000 --> 11:21.300
哪个节点的层最大

11:21.400 --> 11:22.200
不就是他吗

11:22.700 --> 11:24.200
他的层次多少是4

11:24.500 --> 11:24.900
对吧

11:24.900 --> 11:27.300
那么这颗数的节层就是

11:27.600 --> 11:28.600
他的深度呢

11:28.600 --> 11:29.300
就是4

11:29.800 --> 11:30.800
啊非常简单

11:31.800 --> 11:33.600
这深度啊

11:33.700 --> 11:35.200
叶子什么叫叶子呢

11:35.300 --> 11:36.800
其实你把这个这个玩意啊

11:37.100 --> 11:37.700
这个玩意呢

11:37.700 --> 11:38.700
一看成是一个

11:39.300 --> 11:40.200
倒的一颗数

11:40.200 --> 11:41.500
倒过来的一颗数

11:42.700 --> 11:44.100
啊那么这数数的根

11:44.300 --> 11:44.700
对不对

11:44.700 --> 11:46.500
往上分支分支分支

11:46.500 --> 11:47.500
这数的支

11:47.500 --> 11:48.700
啊支分支

11:48.800 --> 11:49.900
然后这就数的叶子

11:49.900 --> 11:50.700
什么叫叶子呢

11:50.700 --> 11:52.800
就是他已经没有再分支了

11:53.200 --> 11:53.500
也就是说

11:53.500 --> 11:55.100
换句用专业数语来讲

11:55.100 --> 11:55.700
就是什么呢

11:55.700 --> 11:57.300
他的杜维因理容

11:58.400 --> 11:59.900
杜维因理容他就是叶子

12:00.400 --> 12:02.300
你可以把它看成一个家谱

12:02.300 --> 12:03.300
对吧家谱图

12:03.800 --> 12:05.100
你们现在不都是叶子吗

12:05.100 --> 12:05.600
对不对

12:05.700 --> 12:07.000
还没有开支上叶嘛

12:07.100 --> 12:08.300
那你就是叶子呢

12:10.400 --> 12:11.400
这是那个

12:12.000 --> 12:13.100
叶子节点

12:13.300 --> 12:14.300
还什么叫分支节点呢

12:14.300 --> 12:15.300
就是不是叶子节点

12:15.300 --> 12:15.900
就是分支节点

12:15.900 --> 12:17.100
你看他这里表有哪些

12:17.100 --> 12:18.200
哪些是分支节点

12:18.200 --> 12:19.100
他是分支

12:19.200 --> 12:20.000
他是分支

12:20.000 --> 12:20.700
他是分支

12:20.700 --> 12:21.400
他是分支

12:21.400 --> 12:21.900
对吧

12:21.900 --> 12:23.200
那么这些节点都是叶子

12:24.500 --> 12:25.400
好就是这个啊

12:26.200 --> 12:26.600
啊

12:26.600 --> 12:27.300
指节点

12:27.300 --> 12:27.800
副节点

12:27.800 --> 12:28.300
非常简单

12:28.300 --> 12:28.500
对吧

12:28.500 --> 12:29.700
还没有没什么好说的吗

12:29.700 --> 12:30.800
SB的副节点

12:30.800 --> 12:32.100
B是A的指节点

12:32.300 --> 12:33.500
那么这个是比较说

12:33.500 --> 12:34.700
D是A的副节点

12:34.700 --> 12:35.900
SD的指节点

12:36.200 --> 12:37.500
就这么一个意思啊

12:38.700 --> 12:40.400
这是指节点副节点

12:40.400 --> 12:41.900
那什么叫兄弟节点呢

12:41.900 --> 12:43.500
就是有同一个父亲

12:43.700 --> 12:44.500
就是兄弟

12:44.800 --> 12:46.900
然后B和C就是兄弟节点

12:47.000 --> 12:47.900
互为兄弟

12:48.200 --> 12:50.400
C和E互为兄弟

12:50.600 --> 12:51.500
啊非常简单

12:52.100 --> 12:53.600
那么如果说这个F呢

12:53.800 --> 12:55.300
E和F是不是兄弟

12:56.200 --> 12:57.700
这个两个玩意儿是不是兄弟

12:59.740 --> 13:00.540
E和F

13:01.640 --> 13:03.240
这不是啊对不对

13:03.540 --> 13:05.640
你不能说他是表哥啊表妹

13:05.640 --> 13:06.640
没有这个说法

13:06.940 --> 13:07.840
他没有同一个父亲

13:07.840 --> 13:08.740
他不是同一个父亲的

13:08.740 --> 13:09.640
他就不是兄弟

13:10.340 --> 13:11.540
好这是兄弟节点啊

13:12.040 --> 13:13.640
祖先节点后代节点

13:13.640 --> 13:14.940
这些玩意儿没什么好说的

13:14.940 --> 13:15.640
跟那个多目

13:15.640 --> 13:16.940
多目数呢是一样的

13:16.940 --> 13:18.340
什么叫祖先节点的

13:18.340 --> 13:19.840
就是他的父亲

13:19.840 --> 13:21.040
或者是父亲的父亲

13:21.040 --> 13:22.940
或者是父亲的父亲的父亲都行

13:23.340 --> 13:24.240
都叫祖先

13:24.440 --> 13:26.240
那么比方B的祖先是谁呢

13:26.540 --> 13:28.640
A和D都是他的祖先

13:28.940 --> 13:30.640
那么A呢既是他的父亲

13:30.740 --> 13:31.940
又是他的祖先

13:32.240 --> 13:33.540
对吧很好的理解呗

13:34.540 --> 13:35.840
呃然后呢

13:36.440 --> 13:39.160
同样的啊B呢是A的

13:39.340 --> 13:41.540
子节点同时呢B又是A的

13:42.040 --> 13:43.040
后代节点

13:43.240 --> 13:44.540
儿子不就是后代吗

13:44.940 --> 13:45.840
那么B呢

13:46.540 --> 13:48.240
是D的后代

13:48.940 --> 13:49.740
就这么个意思

13:50.240 --> 13:52.240
好这是书里边的一些

13:52.440 --> 13:53.540
常见的书语啊

13:53.640 --> 13:54.440
他要知道

13:54.740 --> 13:56.540
呃然后我们来看一下

13:56.540 --> 13:57.940
书的代码表示方式

13:58.840 --> 13:59.440
怎么呢

13:59.540 --> 14:01.340
用一个代码来表示一颗书

14:02.740 --> 14:03.440
啊去

14:08.230 --> 14:09.630
呃表示书呢

14:09.630 --> 14:10.530
其实我们

14:11.630 --> 14:13.230
跟那个链表是一样的

14:13.630 --> 14:15.230
链表是有什么组成的

14:15.230 --> 14:16.430
只有节点组成的

14:16.430 --> 14:18.130
对吧书的也是一样

14:18.130 --> 14:19.630
他也是由节点组成的

14:20.130 --> 14:21.130
每一个节点

14:21.130 --> 14:22.430
他既然有指向

14:22.530 --> 14:23.130
你看啊

14:23.130 --> 14:24.530
这个每一个节点是不是有指向

14:24.530 --> 14:25.930
那跟链表是不是一样的

14:26.130 --> 14:27.330
链表里边

14:27.630 --> 14:29.430
不是有一个东西在保存数据

14:29.530 --> 14:30.330
有另一个东西

14:30.330 --> 14:31.330
来保存一个地址

14:31.330 --> 14:33.130
对吧地址指向别的数据

14:33.630 --> 14:35.330
那么书每一个节点也是一样

14:35.530 --> 14:37.330
他有一个东西来保存数据

14:38.330 --> 14:38.930
比较Race

14:38.930 --> 14:39.630
比较Wide

14:40.130 --> 14:41.530
他用来保存数据的吧

14:42.030 --> 14:43.830
节点中的数据

14:44.430 --> 14:44.930
然后呢

14:44.930 --> 14:45.930
还有另外一个属性

14:45.930 --> 14:48.430
要指向其他的节点

14:48.930 --> 14:50.730
但是跟链表不一样的是

14:50.730 --> 14:52.230
链表是不是只有一个

14:52.230 --> 14:53.730
对吧链表是不是当时有Mex

14:54.030 --> 14:55.730
只有一个东西来指向别的

14:55.730 --> 14:57.230
但是书里边是有多个

14:58.130 --> 14:59.930
他是不是有多个要指向多个

14:59.930 --> 15:00.330
因此呢

15:00.330 --> 15:02.230
他的指向必须要是一个数据

15:02.630 --> 15:03.130
7号据

15:03.630 --> 15:04.530
就这么一个意思

15:05.330 --> 15:08.230
指向其他节点的数据

15:08.230 --> 15:10.930
也就是说这个节点的指节点

15:10.930 --> 15:11.930
他的指一个数据

15:12.030 --> 15:13.830
那你看动物对象里面不就这样吗

15:13.830 --> 15:15.430
一个动物对象里面不用切号据吗

15:15.430 --> 15:15.730
对吧

15:15.730 --> 15:16.230
7号据

15:16.430 --> 15:17.330
这个7号据呢

15:17.830 --> 15:18.830
不就是一个数据吗

15:19.030 --> 15:19.230
是吧

15:19.230 --> 15:20.130
一个伪数据吗

15:20.430 --> 15:20.930
对不对

15:20.930 --> 15:22.830
那么指向的是别的节点

15:23.230 --> 15:23.430
啊

15:23.430 --> 15:24.230
这个也是一样

15:24.630 --> 15:25.430
那比方说

15:25.530 --> 15:27.830
我要表示这么一棵树

15:27.930 --> 15:29.130
还是数据点多了啊

15:29.730 --> 15:31.830
我能不能我把稍微的减换一下

15:31.830 --> 15:37.030
a b c d e f

15:37.030 --> 15:37.630
啊够了

15:37.630 --> 15:38.530
这几个节点不要

15:38.830 --> 15:40.630
然后比方说我要表示这么一棵树

15:40.630 --> 15:42.130
那怎么来写的这个代码呢

15:44.030 --> 15:44.930
首先节点a

15:45.630 --> 15:46.330
6一个load

15:46.630 --> 15:47.530
里面保存一个数据

15:47.530 --> 15:48.430
数据无所谓啊

15:48.430 --> 15:49.730
就一个字路刷a嘛

15:50.030 --> 15:51.230
然后有这么一些节点啊

15:51.430 --> 15:54.030
a b c d

15:54.430 --> 15:56.330
e一棵还有个f

15:58.410 --> 15:59.810
e f

16:00.710 --> 16:03.210
啊然后呢这里是b c

16:03.910 --> 16:06.110
d e f

16:06.510 --> 16:08.410
那么是不是创建这么多多个节点

16:08.510 --> 16:10.510
然后呢再去搞定他们的关系

16:10.710 --> 16:13.410
n里边呢指节点有两个b和c

16:13.610 --> 16:16.410
那于是呢我把在x这个求据里面

16:16.910 --> 16:18.510
啊铺起一个什么的

16:18.910 --> 16:20.510
b和c

16:22.110 --> 16:22.610
对不对

16:22.710 --> 16:25.310
那么这样子a直接点是不是有两个b和c

16:25.710 --> 16:28.410
好然后呢b节点的指节点的有三个

16:30.010 --> 16:31.310
啊b的指节点的有

16:33.210 --> 16:34.110
d e f

16:34.510 --> 16:36.410
d f就完事了

16:37.510 --> 16:38.010
好

16:38.410 --> 16:39.810
我们把它运行出来看一下啊

16:43.860 --> 16:45.060
那么这个数据建立好了

16:45.160 --> 16:46.960
建立好过后我们怎么来表示

16:46.960 --> 16:48.060
得到整棵树呢

16:48.360 --> 16:49.760
其实跟那个链表一样

16:49.860 --> 16:51.560
我们只需要找到数的根

16:51.860 --> 16:52.960
就行了对不对

16:53.160 --> 16:55.060
比方说我们找到这个a节点

16:55.260 --> 16:56.560
那么就可以找到整棵树

16:56.760 --> 16:58.860
因为a的节点里边有两个指节点

16:59.160 --> 17:00.160
b和c

17:00.660 --> 17:02.460
而b里边有两个指节点

17:03.260 --> 17:04.960
哦三个指节点d e f

17:05.260 --> 17:07.460
对吧那d e f里边就没有指节点了

17:07.460 --> 17:09.060
就用为空数数

17:09.460 --> 17:11.860
好了吗c的里边也没有指节点了

17:11.960 --> 17:13.360
所以说我们只要找到数的根

17:13.460 --> 17:15.960
就可以找到整棵树跟那个链表是一样的

17:16.060 --> 17:18.060
链表里边只要找到一个链表的头

17:18.160 --> 17:19.360
就可以找到整个链表

17:19.760 --> 17:20.860
那么同样的道理呢

17:21.160 --> 17:22.960
如果说我给的是b节点呢

17:23.560 --> 17:25.960
我给的不是a节点我给的是b节点的

17:26.160 --> 17:27.260
那我找的是哪棵树呢

17:27.260 --> 17:28.360
找到就是这棵树

17:29.960 --> 17:31.460
a能不能找到找不到了

17:31.560 --> 17:32.860
c能不能找到找不到了

17:32.960 --> 17:34.360
跟那个链表是不是一样的道理

17:34.860 --> 17:36.760
对吧我把他当成根节点的话

17:36.760 --> 17:37.760
我就找到这棵树

17:37.860 --> 17:38.660
那么看一下啊

17:38.760 --> 17:40.060
b里边有三个指节点嘛

17:40.060 --> 17:40.760
d e f

17:40.860 --> 17:41.560
后面就没了

17:42.560 --> 17:44.960
好这就是树啊这个概念

17:46.360 --> 17:49.160
好但是树呢不是我们今天晚上的重点

17:49.860 --> 17:53.160
我们今天晚上讲一种特殊的一棵树

17:53.360 --> 17:54.460
叫做二叉树

17:55.460 --> 17:56.660
啥叫二叉树呢

17:57.560 --> 17:59.160
就是树的度啊

17:59.560 --> 18:00.360
它为二

18:01.460 --> 18:02.760
刚才说讲过度的概念

18:03.560 --> 18:05.760
那么这样的树呢就是一棵二叉树

18:05.760 --> 18:07.260
那你回忆一下什么叫度

18:07.660 --> 18:08.660
什么叫树的度

18:09.160 --> 18:10.160
树的度为二

18:10.160 --> 18:12.160
这个树呢就是一个二叉树

18:13.260 --> 18:15.460
好那么现在呢我给大家看一下啊

18:16.860 --> 18:19.360
看一下能不能分清楚什么是二叉树

18:20.260 --> 18:21.260
首先这个玩意

18:21.460 --> 18:22.460
是不是二叉树

18:24.950 --> 18:25.650
这个玩意

18:26.750 --> 18:27.950
这棵树是不是二叉树

18:29.760 --> 18:30.960
是对不对

18:31.460 --> 18:33.960
那你不能说它只有一个节点它也不是二叉树

18:34.060 --> 18:36.060
它有一个节点但是这棵树还是二啊

18:37.260 --> 18:39.260
它的那个度还是二对不对

18:39.560 --> 18:42.060
所以说呢它是一棵二叉树啊

18:42.860 --> 18:43.660
然后再来看

18:47.360 --> 18:49.060
这样的一棵树是不是二叉树

18:56.500 --> 18:57.400
这不是了

18:57.500 --> 19:00.700
因为这个树的度呢是三对不对

19:01.000 --> 19:02.500
所以二叉树很简单啊

19:02.500 --> 19:04.200
你只要这个树是度为二

19:04.200 --> 19:05.200
它就是二叉树

19:05.200 --> 19:05.800
那再看

19:05.900 --> 19:07.100
这棵树是不是二叉树

19:10.420 --> 19:10.920
这个树

19:12.720 --> 19:14.220
是不是还是对不对

19:14.420 --> 19:15.220
它度为二

19:16.220 --> 19:18.220
它说二叉树的概念了特别简单啊

19:18.420 --> 19:19.920
度为二就是二叉树

19:20.420 --> 19:22.520
由于二叉树有这么一个特点

19:22.720 --> 19:25.520
它的指节点数量是极其有限的

19:25.820 --> 19:27.820
最多最多就两个啊

19:27.820 --> 19:29.520
你可以没有表他就没有

19:29.520 --> 19:31.320
你可以只有一个表他就有一个

19:31.820 --> 19:33.520
但是最多只能有两个

19:33.920 --> 19:36.120
因此呢二叉树的表示法呢

19:36.120 --> 19:38.420
跟普通的树呢有一点点差异

19:38.420 --> 19:40.020
我们来看一下二叉树的表示法

19:42.660 --> 19:43.360
3

19:44.160 --> 19:44.560
2

19:48.080 --> 19:49.380
它是用这种方式来表示的

19:49.480 --> 19:50.580
他不是一个数组

19:50.580 --> 19:51.780
因为他们觉得没必要

19:52.280 --> 19:54.080
我就一个左节点一个右节点

19:54.080 --> 19:54.480
对吧

19:54.580 --> 19:56.080
一个左分支一个右分支

19:56.380 --> 19:57.680
要么两个分子都没有

19:57.780 --> 19:59.380
要么了有一个分支啊

19:59.380 --> 20:00.480
要么两个分子都有

20:00.580 --> 20:01.480
就这么几种情况

20:01.480 --> 20:03.280
我没有必要再去用一个数组了

20:03.880 --> 20:04.580
什么意思吧

20:04.580 --> 20:06.180
所以从了二叉树的表示方式呢

20:06.180 --> 20:08.180
我们往往用使用这种方式来表示

20:08.380 --> 20:09.180
用一个东西

20:09.180 --> 20:10.380
用这个属性来存

20:10.580 --> 20:12.180
每个节点里边的数据

20:12.380 --> 20:13.080
管理存啥

20:13.080 --> 20:13.580
随便的存啥

20:13.580 --> 20:15.980
你存一个对象存一个数字随便的存

20:16.480 --> 20:17.680
然后呢我来表示

20:17.680 --> 20:18.980
跟其他节点的关系

20:18.980 --> 20:19.980
左节点是啥

20:20.080 --> 20:21.380
我的右分支是啥

20:22.780 --> 20:23.180
啊

20:23.380 --> 20:25.480
相当于是有点像那个练表的

20:25.580 --> 20:26.380
这个变种

20:26.780 --> 20:27.280
对不对

20:27.980 --> 20:29.680
好那么这是二叉树的表示方式

20:30.080 --> 20:31.880
然后接下来就是全部是代码了啊

20:31.880 --> 20:32.580
以后来

20:34.810 --> 20:35.510
第一道题

20:35.810 --> 20:37.110
第一道题呢有三个小题

20:39.380 --> 20:41.180
就是要便利整颗

20:41.680 --> 20:42.480
二叉树

20:43.680 --> 20:45.280
那么便利的方式呢

20:45.580 --> 20:46.380
有三种

20:47.380 --> 20:48.580
一种叫先续便利

20:48.580 --> 20:49.480
一种叫终续便利

20:49.480 --> 20:50.380
一种叫后续便利

20:50.380 --> 20:51.180
我们一个个来

20:51.280 --> 20:52.380
什么叫便利

20:53.080 --> 20:55.280
就是把它所有节点拿出来

20:55.280 --> 20:56.380
一个一个拿出来

20:56.480 --> 20:57.180
拿出来干嘛

20:57.180 --> 20:58.480
无所谓比方说输出嘛

20:58.680 --> 20:59.880
啊比方我们就输出

21:00.280 --> 21:01.580
那么输出怎么来输出

21:01.580 --> 21:03.780
要把每一个节点全部便利到

21:05.560 --> 21:06.060
看啊

21:07.760 --> 21:09.160
我们这里呢随便来一个啊

21:09.160 --> 21:10.660
这里再来一个分子

21:14.900 --> 21:16.300
啊比方有这么一个数啊

21:16.700 --> 21:22.000
a b c d e f

21:22.700 --> 21:23.500
有这么一个数

21:23.700 --> 21:24.800
这是一个二叉树啊

21:26.100 --> 21:27.900
啊那么这里还有一个小的规则啊

21:27.900 --> 21:29.700
就是说如果说这个比方

21:29.700 --> 21:31.100
C这个节点它只有一个分子

21:31.100 --> 21:31.500
对吧

21:31.600 --> 21:32.700
我们通常认为呢

21:32.700 --> 21:34.100
这个分子是左分子

21:34.100 --> 21:35.200
而不是右分子

21:35.700 --> 21:37.200
啊通常是这么认为的啊

21:37.600 --> 21:39.800
这是一个习惯上的一种啊

21:40.300 --> 21:40.800
做法

21:41.500 --> 21:43.300
那么比方说我们要便利这颗树

21:43.300 --> 21:44.700
我们先不着急携带嘛

21:45.500 --> 21:47.300
那么有哪些便利方式呢

21:47.700 --> 21:50.100
首先第一种方式叫做前续便利

21:50.800 --> 21:52.300
什么叫做前续便利

21:52.700 --> 21:53.700
啊前续便利呢

21:53.700 --> 21:55.700
他的说起来叫d l r

21:56.200 --> 21:57.400
这个d呢就是自己

21:57.700 --> 21:58.700
就是自己这个节点

21:58.800 --> 22:00.200
l呢就是左节点

22:00.500 --> 22:02.500
r呢lap什么right啊

22:02.700 --> 22:03.700
d呢叫degree啊

22:03.700 --> 22:05.700
就是自己自己左右

22:06.000 --> 22:06.800
那啥意思呢

22:06.900 --> 22:08.400
就是我在便利的时候

22:08.600 --> 22:09.800
先便利自己

22:09.800 --> 22:11.100
就是把自己靠前

22:11.200 --> 22:12.200
靠前来便利

22:13.100 --> 22:15.100
然后再便利左边的一颗树

22:15.200 --> 22:16.800
然后再便利右边的一颗树

22:17.300 --> 22:17.800
别人是吧

22:17.800 --> 22:19.600
这就是前续便利

22:19.700 --> 22:22.300
先便利自己也叫做先续便利

22:22.500 --> 22:24.100
那么比方说像这个树的话

22:24.300 --> 22:25.800
前续便利该怎么写的

22:26.700 --> 22:27.800
从先从a开始

22:28.500 --> 22:30.300
a这个节点先便利自己

22:30.400 --> 22:31.300
所以先打印a

22:32.500 --> 22:34.400
然后再便利左分子

22:35.000 --> 22:36.300
然后再便利右分子

22:39.880 --> 22:41.380
有好

22:41.480 --> 22:44.880
便利左分子的时候又是用同样的规则

22:45.080 --> 22:45.980
又是一样的

22:47.480 --> 22:50.180
便利b的时候也是先便利自己

22:51.680 --> 22:53.280
然后再便利b的左边

22:53.280 --> 22:54.480
再便利b的右边

22:54.680 --> 22:56.080
那b的左边说已经出来了

22:56.080 --> 22:56.880
对吧 d

22:57.380 --> 22:58.580
右边呢就是e

22:59.380 --> 22:59.880
看没

23:00.680 --> 23:02.280
好然后再看a的右边

23:02.280 --> 23:03.880
a的右边呢e也是一样

23:04.180 --> 23:05.680
先便利自己c

23:06.280 --> 23:07.780
再便利他的左边f

23:08.580 --> 23:09.580
啊右边没有了

23:10.080 --> 23:13.580
于是呢aabdcf

23:13.980 --> 23:15.980
就是他的前续便利结构

23:16.480 --> 23:17.880
先自己再左右

23:19.780 --> 23:20.980
好那么现在呢

23:20.980 --> 23:23.180
我给大家写一个写一个树

23:23.380 --> 23:25.980
那么大家把它的前续便利写出来

23:30.130 --> 23:31.230
啊有的时候呢面试的时候

23:31.230 --> 23:32.530
可能就直接是这种题

23:32.630 --> 23:34.030
直接用这种题来考虑

23:34.230 --> 23:35.930
他都不让你不让你去写单嘛

23:36.230 --> 23:37.330
他给你一颗树啊

23:37.330 --> 23:38.530
考虑这基本知识

23:38.930 --> 23:39.530
知不知道

23:40.230 --> 23:40.830
给你一颗树

23:40.830 --> 23:42.630
让你把它前续便利结构写出来

23:44.500 --> 23:46.400
哎哎这这还不对啊

23:46.800 --> 23:47.700
第一

23:48.900 --> 23:49.600
fg

23:50.400 --> 23:53.100
好这颗树的前续便利结构是什么

23:56.320 --> 23:58.220
对吧有时候应该有点感觉了

23:58.220 --> 23:59.220
对吧要滴规了

24:00.420 --> 24:07.720
abdgecfabdgecf

24:07.720 --> 24:08.320
看一下啊

24:08.420 --> 24:09.920
首先看a a左边

24:09.920 --> 24:12.320
a左边左边这颗树啊

24:12.720 --> 24:13.720
是不是左边这颗树

24:13.820 --> 24:15.620
左边这颗树呢又得又得是

24:16.120 --> 24:17.820
就得是先便利自己b

24:19.120 --> 24:19.520
b

24:19.520 --> 24:21.520
然后呢b的左边

24:22.220 --> 24:22.820
是什么呢

24:23.420 --> 24:24.220
又是这颗树

24:24.220 --> 24:25.820
这颗树呢又得先便利自己d

24:26.420 --> 24:27.920
然后呢便利左分之g

24:27.920 --> 24:28.920
右分之没了啊

24:28.920 --> 24:29.820
这个数完成

24:29.920 --> 24:31.620
这个数完成了过后还有b的右边

24:31.720 --> 24:32.620
b的右边是什么呢

24:32.620 --> 24:32.920
e

24:33.320 --> 24:33.620
对吧

24:33.620 --> 24:34.620
那么这一坨呢

24:34.620 --> 24:36.220
才把a的左边便利完成了

24:36.320 --> 24:37.420
然后是a的右边

24:37.420 --> 24:39.420
a的右边呢又是一样的cf

24:40.120 --> 24:43.020
说abdgecf

24:43.120 --> 24:43.820
很好啊

24:44.520 --> 24:45.720
好就是前续便利

24:45.920 --> 24:48.220
那么这个前续便利用代码来怎么写呢

24:49.020 --> 24:50.920
啊比方说我们现在建立一棵树啊

24:51.120 --> 24:52.420
就来创建这么一棵树

24:52.420 --> 24:53.820
这个树呢就用这棵树吧

24:54.320 --> 24:56.080
一共这么多个节点啊

24:56.080 --> 24:57.320
abcdef

24:57.320 --> 24:57.820
g

24:58.120 --> 24:58.620
来吧

24:58.920 --> 24:59.520
解决

25:00.620 --> 25:01.720
啊自己复制一下吧

25:03.320 --> 25:03.820
复制

25:04.120 --> 25:07.420
上天有这么一个abcdef啊还有一个g

25:09.560 --> 25:10.360
六一个load

25:11.560 --> 25:11.960
t

25:12.160 --> 25:13.460
好来说他们的关系

25:13.560 --> 25:14.760
a的左右呢

25:14.760 --> 25:16.060
a的neft为什么呢

25:16.060 --> 25:16.660
为b

25:17.160 --> 25:18.060
a的right

25:18.260 --> 25:18.760
为

25:19.460 --> 25:20.360
vc

25:22.160 --> 25:23.060
abc

25:23.060 --> 25:25.160
b的左边呢 db

25:25.660 --> 25:27.060
b的neft为d

25:27.960 --> 25:29.460
b的right为e

25:30.460 --> 25:32.260
好然后c的左边呢

25:32.260 --> 25:32.860
vf

25:33.260 --> 25:34.760
c的左边vf

25:36.160 --> 25:38.160
好然后呢 d的左边呢为g

25:39.160 --> 25:41.360
d的左边neft为g

25:41.460 --> 25:44.060
好那么这样子就把树的关系设置好了

25:44.160 --> 25:45.960
根据点是啥根据点就是这个 a

25:46.560 --> 25:48.260
好现在我们来写个函数啊

25:48.560 --> 25:49.860
来进行前续便利

25:50.660 --> 25:52.960
还可以在行李门或者在自己在

25:53.860 --> 25:54.260
g4

25:54.260 --> 25:55.660
g4门里边或者在编辑器里边

25:55.660 --> 25:57.260
自己可以尝试着写一下啊

25:58.060 --> 25:59.260
dl

26:00.460 --> 26:01.760
你给我一棵树

26:02.160 --> 26:03.960
那你怎么给我一棵树跟念表一样

26:03.960 --> 26:05.460
是不是给我一个根据点就可以了

26:05.760 --> 26:06.860
你给我一个根据点啊

26:06.860 --> 26:07.460
一个load

26:07.960 --> 26:09.660
我就把这个树便利出来

26:10.060 --> 26:10.760
咋便利呢

26:11.560 --> 26:12.360
很好写

26:13.260 --> 26:14.360
啥叫前续便利

26:15.360 --> 26:17.860
先便利自己当然首先得有自己啊

26:17.860 --> 26:19.860
你自己都没有那就不要扯淡了

26:20.460 --> 26:21.560
首先得有自己

26:21.660 --> 26:23.360
如果说你自己都没有没有这个节点

26:23.360 --> 26:24.060
那我便利啥呀

26:24.060 --> 26:24.860
就没发便利了

26:26.060 --> 26:28.260
好如果说你有这个节点我咋便利呢

26:28.460 --> 26:30.660
先便利自己把自己打印出来再说

26:31.060 --> 26:32.160
啊先便利自己

26:32.860 --> 26:33.660
先自己

26:34.060 --> 26:36.760
然后呢再左右怎么再左右

26:39.320 --> 26:41.220
把左边的那部分扔进去

26:41.320 --> 26:42.620
重新来一次对吧

26:42.920 --> 26:44.820
然后再把右边那一部分扔进去

26:45.120 --> 26:46.220
又来重新来一次

26:46.220 --> 26:47.020
不就完了吗

26:47.020 --> 26:48.120
这就是前续便利

26:49.120 --> 26:50.720
啊看上去好像很复杂的样子

26:50.720 --> 26:52.020
其实写出来极其简单

26:52.320 --> 26:53.120
前续便利

26:54.930 --> 26:56.530
好咱们来试一下啊

26:59.070 --> 27:00.070
dlr

27:01.270 --> 27:02.170
我就小写吧

27:02.670 --> 27:03.470
dlr

27:05.070 --> 27:05.970
dlr

27:07.470 --> 27:10.170
呃然后这里写上那个节点

27:10.170 --> 27:10.570
a

27:12.370 --> 27:13.170
倒是不存在

27:14.670 --> 27:15.570
打开错了是吧

27:16.270 --> 27:16.670
二

27:17.670 --> 27:18.770
dlr

27:18.770 --> 27:19.770
把那个节点a

27:19.770 --> 27:20.670
跟进点扔进去

27:22.670 --> 27:23.470
这下面就是大写

27:23.470 --> 27:24.470
啊算了就大写吧

27:25.470 --> 27:26.370
大写大写

27:27.170 --> 27:28.070
dlr

27:28.070 --> 27:28.970
a扔进去

27:29.270 --> 27:32.070
看 a b d g e c f

27:32.770 --> 27:34.270
对就前续便利

27:35.270 --> 27:36.370
好那么同样道理呢

27:36.370 --> 27:38.870
接下来是终续便利和后续便利

27:39.170 --> 27:39.670
来吧

27:39.870 --> 27:41.370
终续便利啥意思呢

27:41.370 --> 27:44.070
就是先左再自己再右边

27:45.670 --> 27:46.370
叫做

27:46.670 --> 27:47.970
l d r

27:47.970 --> 27:48.470
对吧

27:48.770 --> 27:51.170
先左再自己再右边

27:51.470 --> 27:52.470
那我不用说了了

27:52.570 --> 27:53.870
大家把这个书的终续便利

27:53.870 --> 27:54.970
结果写出来看一下

27:57.010 --> 27:57.710
面试题的时候

27:57.710 --> 27:59.510
有的时候还要考虑舔控题

27:59.810 --> 28:00.910
直接考虑舔控题

28:01.010 --> 28:02.410
给你这一颗书啊看图

28:02.610 --> 28:04.410
然后呢前续便利是啥让你写出来的

28:04.510 --> 28:06.710
终续便利后续便利是啥让你写出来

28:07.010 --> 28:08.110
那么什么叫后续便利

28:08.110 --> 28:10.410
就先左再右再自己

28:12.310 --> 28:13.210
先看终续便利

28:16.660 --> 28:17.460
终续便利是啥啊

28:19.160 --> 28:19.860
好好想想

28:21.860 --> 28:24.660
先左再右再自己

28:27.600 --> 28:28.800
那么你一个这样子看呗

28:29.900 --> 28:30.800
整颗书

28:31.600 --> 28:32.900
从节点书啊哪个节点书啊

28:32.900 --> 28:34.000
a这个节点书啊

28:34.500 --> 28:35.700
那是不是a的左边

28:37.100 --> 28:38.700
然后呢a自己

28:39.000 --> 28:40.400
然后呢a的右边

28:41.500 --> 28:42.000
对不对

28:44.840 --> 28:45.540
就是这样子

28:46.940 --> 28:47.340
嗯

28:47.840 --> 28:50.140
我看一下还没有看还没有看到正确答案啊

28:50.440 --> 28:52.240
我现在还没有目前还没有看到正确答案

28:53.040 --> 28:54.140
还有没有别的答案

28:55.950 --> 28:58.550
先左再自己再右

28:59.150 --> 29:01.650
那么对于左边那颗书是不是一样的

29:03.490 --> 29:04.890
啊还没有正确答案

29:06.090 --> 29:10.190
g d b e s

29:11.790 --> 29:13.590
啊接近了啊

29:13.590 --> 29:14.790
但还是不是正确的

29:15.090 --> 29:15.990
还不是正确的

29:16.590 --> 29:18.290
接近了啊还不是正确的

29:20.650 --> 29:23.650
先左对于左边那颗书是不是也是一样的

29:23.650 --> 29:25.150
啊这个这个答案是正确的啊

29:25.450 --> 29:26.950
不没这个同意答案是正确的

29:27.850 --> 29:30.150
先左左边那颗书也是一样的道理

29:30.950 --> 29:33.150
对这颗书而言他也在重复这个过程啊

29:33.150 --> 29:34.350
他也在这种区别里啊

29:34.450 --> 29:37.450
所以他也得先左再右再自己再e

29:37.450 --> 29:40.250
所以说他应该是先对这颗书啊

29:40.450 --> 29:43.250
对这颗书而言他也得是先左再自己

29:43.250 --> 29:45.250
然后再e右边的个e对吧

29:45.250 --> 29:47.050
那么他的左边是又是一颗书

29:47.550 --> 29:49.650
又是一颗书那么这颗书也得一样

29:49.950 --> 29:50.850
他的先左

29:51.650 --> 29:53.450
再自己那么他没有右边了

29:53.490 --> 29:54.450
那么这样子一来了

29:54.450 --> 29:56.650
他才把a的左边便利完成

29:56.650 --> 29:57.650
然后是a自己

29:57.650 --> 29:58.650
然后是a的右边

29:58.750 --> 29:59.950
a的右边属于一样吧

29:59.950 --> 30:00.350
对吧

30:00.350 --> 30:01.250
所以也一样

30:01.850 --> 30:04.750
对这颗书而言他也得先左再自己啊

30:04.750 --> 30:06.350
我们只有一个分支的时候

30:06.350 --> 30:07.850
一般认为他是左分支啊

30:08.450 --> 30:12.950
那么他先左再自己右右边没有

30:14.250 --> 30:16.350
所以说他正确的写的结果呢

30:16.350 --> 30:17.350
是这个东西

30:18.150 --> 30:21.150
啊我看有一个同学写的呀的

30:23.700 --> 30:24.700
一个同学是写的

30:25.400 --> 30:26.600
有一个啊对对

30:26.600 --> 30:27.500
这个同学写的

30:28.700 --> 30:30.400
好那么现在这个代码怎么写呢

30:30.400 --> 30:31.500
代码也许许写的

30:31.700 --> 30:32.700
他可以尝试一下啊

30:32.700 --> 30:33.500
这个代码咋写

30:36.120 --> 30:37.620
这一部分还是比较简单的啊

30:38.020 --> 30:39.020
l d r

30:39.720 --> 30:41.320
no 这是终续便利

30:43.020 --> 30:44.420
终续便利

30:45.520 --> 30:46.120
来吧

30:46.220 --> 30:46.920
还一样

30:48.420 --> 30:50.120
没有节点就不要便利了

30:50.920 --> 30:51.820
别别便利了

30:52.620 --> 30:54.120
好有节点呢

30:54.220 --> 30:55.420
先左边

30:56.120 --> 30:57.020
再自己

30:58.520 --> 30:59.320
再右边

31:00.720 --> 31:02.020
对吧先左边

31:02.220 --> 31:02.820
left

31:03.720 --> 31:07.360
再自己再右边

31:10.280 --> 31:10.880
对吧

31:10.880 --> 31:11.980
是不是极其简单

31:12.180 --> 31:14.080
跟那个前续便利代码

31:14.280 --> 31:15.880
我们就这个地方调了一下顺序吗

31:16.580 --> 31:17.580
啊这是终续便利

31:17.780 --> 31:18.580
好看一下吧

31:18.980 --> 31:19.580
放心

31:20.180 --> 31:21.880
呃终续便利我们来走一下

31:23.580 --> 31:24.680
l d r

31:25.580 --> 31:26.480
a 传进去

31:26.680 --> 31:27.280
一看呀

31:27.380 --> 31:28.180
做到结果

31:28.280 --> 31:30.880
g d b e a f c

31:31.780 --> 31:32.780
啊这是终续便利

31:33.480 --> 31:34.580
来又来啊

31:36.080 --> 31:36.880
后续便利

31:37.980 --> 31:38.680
我不说了吧

31:38.680 --> 31:40.280
不用解释后续便利啥意思了吧

31:41.480 --> 31:42.680
叫做l r d

31:43.580 --> 31:44.780
来后续便利写出来

31:52.230 --> 31:53.030
后续便利

31:56.990 --> 31:58.790
先左再右再自己

31:59.190 --> 32:00.190
最后是自己

32:01.690 --> 32:03.590
当然对左分之而言也是同样

32:03.990 --> 32:06.290
对所有的数而言都是一样

32:07.690 --> 32:12.590
g d e b a

32:13.490 --> 32:14.590
f c

32:14.990 --> 32:15.490
啊

32:17.090 --> 32:17.590
不对

32:18.990 --> 32:22.290
g d e b

32:23.090 --> 32:24.790
f c a

32:24.790 --> 32:25.890
啊这个都要的啊

32:26.090 --> 32:27.390
这个都要的啊

32:27.390 --> 32:27.890
后边

32:29.390 --> 32:31.190
f c f

32:31.190 --> 32:31.890
啊这个不对

32:32.890 --> 32:33.890
啊这个都要的啊

32:33.890 --> 32:35.090
就跟王子同样是都要的

32:35.390 --> 32:37.190
然后来看一下是一样的啊

32:37.190 --> 32:37.990
先左边

32:37.990 --> 32:39.190
然后再右边

32:39.390 --> 32:40.890
然后呢再自己

32:41.390 --> 32:42.990
那么l左边也是一样啊

32:43.290 --> 32:45.090
对这颗数而言也是一样

32:45.090 --> 32:47.290
他也得先左边再右边再自己

32:47.290 --> 32:48.790
那么他的左边又是一颗数

32:48.790 --> 32:50.090
对吧又是一颗数

32:50.090 --> 32:50.690
那么这个数呢

32:50.690 --> 32:52.590
也得是先左边再右边再自己

32:52.790 --> 32:54.090
那么对这颗数而言

32:54.090 --> 32:54.690
知道啊

32:54.690 --> 32:56.190
这就是g d对不对

32:56.690 --> 32:57.890
那么这边就是g d

32:58.090 --> 32:59.690
然后呢这边左边的数完了

32:59.690 --> 33:00.890
然后是右边这颗数

33:01.090 --> 33:01.490
e

33:02.290 --> 33:04.190
啊然后呢再自己 b

33:05.190 --> 33:05.990
那么这样子呢

33:05.990 --> 33:07.490
就把这颗数鞭定出来了

33:08.390 --> 33:09.290
然后呢再是

33:09.390 --> 33:10.890
这颗数整颗数的右边

33:10.890 --> 33:12.990
整个数的右边是不是就是fc

33:13.290 --> 33:14.490
对吧先左再右

33:14.490 --> 33:15.190
他没有右

33:15.290 --> 33:16.190
然后再自己

33:16.390 --> 33:17.590
然后呢最后再是 a

33:20.490 --> 33:21.990
g d e b

33:22.190 --> 33:23.390
f c a对

33:23.990 --> 33:25.290
好那么我们来写代码

33:26.190 --> 33:26.990
后续便利

33:28.090 --> 33:29.390
是不是很简单了后续便利

33:30.890 --> 33:32.290
啊第一部分是非常简单的啊

33:32.890 --> 33:34.390
啊l r d

33:37.190 --> 33:38.690
这是后续便利

33:39.390 --> 33:40.490
后续便利

33:41.490 --> 33:43.590
后续便利怎么写的还是一样啊

33:43.590 --> 33:44.290
首先

33:44.890 --> 33:46.890
他的有没有的话就没法玩

33:47.390 --> 33:48.790
然后呢在左边

33:49.390 --> 33:50.290
l r d

33:50.490 --> 33:51.690
loaded left

33:52.090 --> 33:54.190
然后呢在右边l r d

33:54.690 --> 33:55.890
loaded right

33:56.390 --> 33:57.390
然后再自己

33:57.390 --> 33:58.690
输出loaded right

33:59.190 --> 34:00.090
对不对就完了

34:00.090 --> 34:01.090
那就是后续便利

34:01.690 --> 34:02.790
好我先看一下啊

34:02.790 --> 34:03.690
l r d

34:05.290 --> 34:05.790
你看

34:06.190 --> 34:09.390
g d e b f c a

34:10.390 --> 34:11.390
好这是后续便利

34:11.390 --> 34:13.190
前续便利中续便利后续便利

34:14.190 --> 34:15.190
还有以后呢

34:15.190 --> 34:16.290
你们遇到的题呢

34:16.290 --> 34:17.290
一般是天空题

34:19.870 --> 34:23.570
好这是二叉树的便利打印

34:23.870 --> 34:24.670
最基本的

34:26.540 --> 34:27.440
好第二道题呢

34:27.440 --> 34:29.140
就稍微有点难度了

34:31.470 --> 34:32.070
注意听呢

34:32.270 --> 34:33.070
打起精神

34:34.570 --> 34:37.570
要根据前续便利和

34:37.870 --> 34:39.570
中续便利的结果

34:40.370 --> 34:42.470
得到一颗二叉树

34:44.410 --> 34:45.210
神奇口气啊

34:45.210 --> 34:45.810
注意听啊

34:46.110 --> 34:49.010
根据前续便利和中续便利的结果

34:49.210 --> 34:51.110
得到一颗二叉树

34:51.110 --> 34:52.710
首先我们理解一下啥意思

34:53.410 --> 34:54.710
就是一颗树啊

34:55.510 --> 34:59.510
他只要把前续便利和中续便利告诉你

35:00.210 --> 35:02.510
你就能够还原这颗二叉树

35:04.210 --> 35:05.010
啥意思呢

35:06.410 --> 35:07.410
我们比方说啊

35:07.910 --> 35:10.110
我给你一个前续便利的结果

35:12.660 --> 35:14.760
前续便利的结果是啥呢

35:14.760 --> 35:16.060
比方说就这颗树啊

35:16.160 --> 35:17.760
前续便利的结果是

35:17.960 --> 35:18.660
a

35:19.560 --> 35:20.160
b

35:21.360 --> 35:22.360
dg

35:22.360 --> 35:22.960
e

35:23.760 --> 35:25.260
啊我都怕自己写错了

35:25.460 --> 35:27.160
我看一下前续便利的结果

35:27.360 --> 35:27.960
l

35:28.260 --> 35:28.860
dl

35:28.860 --> 35:29.160
r

35:30.360 --> 35:33.160
就是 a b d g e c f

35:33.760 --> 35:36.860
好然后呢把中续便利的结果给的

35:37.360 --> 35:38.360
l d r

35:41.320 --> 35:43.820
g d b e a f c

35:46.570 --> 35:48.470
只要给你这么两个东西

35:48.470 --> 35:50.370
你就能够把这个二叉树还原

35:51.370 --> 35:54.270
你就已经能够确定他的二叉树长什么样子了

35:54.770 --> 35:55.470
懂我的意思吧

35:55.970 --> 35:56.970
凭什么能确定

35:57.170 --> 35:58.170
我们来梳理一下

35:58.470 --> 35:59.470
凭什么能确定

35:59.570 --> 36:00.470
这是前续

36:02.980 --> 36:03.780
这是中续

36:05.380 --> 36:06.580
我现在要做的事情

36:06.580 --> 36:10.380
就是根据前续便利的结果和中续的便利结果

36:10.380 --> 36:11.580
还原一颗叉树

36:11.580 --> 36:13.080
也就是说我们需要这么一个函数

36:13.480 --> 36:15.280
叫做get续

36:17.680 --> 36:19.280
你给我前续便利的结果

36:19.280 --> 36:21.780
比方说我们用一个参数名字叫做

36:22.480 --> 36:23.280
dl

36:23.280 --> 36:23.580
r

36:23.880 --> 36:24.880
中续便利的结果

36:24.880 --> 36:26.880
l r d l d r

36:29.850 --> 36:34.350
根据前续和中续便利结果

36:35.150 --> 36:36.450
得到一颗

36:38.460 --> 36:39.460
二叉树

36:41.060 --> 36:43.660
那么到时候调用的时候怎么调用调用这个方法呢

36:44.460 --> 36:46.060
前面我就不用建立这个数了啊

36:46.060 --> 36:47.060
不用建立这个数了

36:47.260 --> 36:49.660
然后呢在后边我们假设这个函数写好了

36:49.660 --> 36:50.460
我就这样调

36:50.760 --> 36:51.560
get续

36:52.060 --> 36:52.660
前续便利呢

36:52.660 --> 36:55.960
就说 a b d g e c f

36:57.360 --> 36:58.560
中续便利的就是

36:58.560 --> 37:01.560
g d b e f c

37:02.560 --> 37:03.960
你会反而回一个结果

37:05.560 --> 37:07.260
这个结果就是一个数的节点

37:07.360 --> 37:08.660
通过这个节点就是整颗数

37:09.360 --> 37:10.060
懂了意思吧

37:10.960 --> 37:12.260
我就要写这么一个函数

37:13.360 --> 37:15.460
那么首先我们先不着急写函数

37:15.560 --> 37:17.060
我们首先想一想

37:17.260 --> 37:18.760
逻辑上通吗

37:19.760 --> 37:20.860
逻辑上通不通

37:22.160 --> 37:23.560
好咱们来梳理一下啊

37:23.560 --> 37:24.660
看一下逻辑通不通

37:27.980 --> 37:30.280
我们现在比方说我都不知道这个数长啥样

37:30.380 --> 37:31.780
我只知道这个便利结果

37:32.280 --> 37:33.880
好了那我们首先看一下

37:34.480 --> 37:36.380
前续便利里边

37:36.680 --> 37:38.080
有一个什么样的特点啊

37:38.980 --> 37:39.780
前续便利

37:40.780 --> 37:42.880
是不是第一个一定是根结点

37:43.680 --> 37:45.280
他是不是一定是根结点

37:46.180 --> 37:47.880
所以说根结点是不是就直接出来了

37:48.980 --> 37:50.180
根结点是不是出来了

37:50.280 --> 37:51.280
他一定是根结点

37:51.280 --> 37:51.780
对不对

37:52.880 --> 37:53.380
啊

37:54.480 --> 37:54.980
好

37:55.180 --> 37:57.480
但是呢光看前续便利结果

37:57.580 --> 38:00.380
我并不知道这一部分哪一部分是左

38:00.680 --> 38:01.580
哪一部分是右

38:01.580 --> 38:01.880
对吧

38:01.880 --> 38:02.980
他是和在一起的

38:03.980 --> 38:04.880
先是自己

38:04.880 --> 38:06.080
然后再左再右

38:06.080 --> 38:07.580
但是我不知道哪一部分是左

38:07.580 --> 38:08.780
哪一部分是右

38:09.980 --> 38:10.280
哎

38:10.280 --> 38:12.080
但是我们配合终续便利

38:12.080 --> 38:13.280
是不是可以看得很清楚

38:14.280 --> 38:15.480
配合终续便利

38:15.480 --> 38:16.280
你看一下

38:16.580 --> 38:17.780
根结点是这个

38:18.780 --> 38:20.280
在终续便利中

38:20.680 --> 38:22.680
这个玩意儿出现在哪呢

38:23.480 --> 38:24.480
是出现在这

38:26.580 --> 38:28.180
那么我们根据终续便利的

38:28.180 --> 38:29.580
配合终续便利的结果

38:29.580 --> 38:30.480
我会发现

38:31.280 --> 38:33.780
终续便利是先左再自己

38:34.080 --> 38:34.780
再右

38:35.080 --> 38:38.980
那么也就意味着在终续便利中左边的

38:39.480 --> 38:41.280
这是左边的终续便利对吧

38:42.180 --> 38:43.080
左边的

38:45.400 --> 38:48.400
终续是不是基地必异

38:48.900 --> 38:51.200
然后呢右边的终续

38:51.700 --> 38:53.000
是不是fc

38:53.200 --> 38:54.100
对不对啊

38:54.100 --> 38:55.500
因为他对左分之也是终续

38:55.500 --> 38:56.900
对右分之也是终续吗

38:57.700 --> 38:59.600
终续便利的结果左分之

38:59.900 --> 39:01.800
是基地必异

39:01.900 --> 39:03.700
右分之是fc

39:03.700 --> 39:04.900
是不是这个能得到

39:05.900 --> 39:06.500
没问题吧

39:06.900 --> 39:09.900
然后对于前续前续而言

39:11.200 --> 39:13.300
由于他左分之有四个

39:13.700 --> 39:15.800
那么对于前续而言是不是也得四个

39:15.800 --> 39:17.100
你不可能说前续

39:17.600 --> 39:19.300
左分之有四个终续变成了五个

39:19.300 --> 39:21.200
不可能数量一定是一致的对不对

39:21.400 --> 39:22.400
你甭管用什么顺序

39:22.400 --> 39:24.000
但是数量一定是一致的

39:24.200 --> 39:26.500
所以说我们可以根据终续便利得到

39:26.500 --> 39:27.800
左分之的数量

39:27.900 --> 39:29.400
是不是这里可以分割一下

39:29.900 --> 39:30.800
那么也就是我们这里

39:30.800 --> 39:32.700
可以参考终续便利得到的吗

39:32.700 --> 39:34.200
得到左边的

39:35.500 --> 39:36.300
前续

39:36.900 --> 39:37.400
是什么

39:37.600 --> 39:38.700
bdg1

39:39.300 --> 39:40.000
然后呢

39:40.200 --> 39:41.500
右边的前续

39:43.000 --> 39:45.400
前续是什么cf

39:47.660 --> 39:48.260
看到没

39:50.240 --> 39:50.940
看到没啊

39:52.340 --> 39:54.540
我一个前续一个终续

39:54.540 --> 39:56.040
我能得到自己是谁

39:57.040 --> 39:57.440
对不对

39:57.440 --> 39:58.840
是不是得到自己自己是谁

39:58.940 --> 40:02.040
同时能够得到左边的前续和左边的终续

40:02.440 --> 40:04.640
右边的前续和右边的终续

40:04.940 --> 40:06.340
那是不是又是个低规啊

40:06.840 --> 40:08.540
对于左边这个数要还原

40:08.540 --> 40:09.840
是不是也是一样的

40:10.240 --> 40:11.640
左边这个数怎么还原

40:11.840 --> 40:12.940
左边这个数

40:14.750 --> 40:16.250
前续告诉你了终续告诉你了

40:16.250 --> 40:17.750
是不是重复这个过程啊

40:18.150 --> 40:19.250
是不是重复这个过程

40:19.250 --> 40:21.250
前续变成高数里终续变成高数里

40:21.250 --> 40:22.750
来年还原这颗数

40:23.350 --> 40:23.750
对不对

40:23.750 --> 40:24.850
是不是又重复这个过程

40:24.850 --> 40:27.350
右边也是一样前续高数里终续高数里

40:27.350 --> 40:28.450
你来还原这颗数

40:29.550 --> 40:30.250
那么这颗数

40:30.250 --> 40:31.050
这颗数左边

40:31.050 --> 40:31.850
这颗数一还原

40:31.850 --> 40:33.150
是不是变成左边的一颗数了

40:33.450 --> 40:35.550
然后把A的Left指向

40:35.850 --> 40:36.750
指向这颗数

40:37.150 --> 40:39.250
把A的Right指向这颗数

40:41.700 --> 40:44.300
这一部分逻辑能听懂的东西就可以了

40:47.200 --> 40:48.100
逻辑能不能懂

40:48.400 --> 40:49.600
我先不说写单嘛

40:50.900 --> 40:52.700
这就是就是个低规过程对吧

40:52.900 --> 40:55.300
我要根据前续和终续来还原这颗数

40:55.600 --> 40:56.600
自己很容易拿到

40:56.700 --> 40:57.700
自己非常容易拿到

40:58.100 --> 40:59.000
拿到自己过后

40:59.000 --> 41:01.100
我能拿到左边的前续和左边的终续

41:01.700 --> 41:03.100
那又是不是重复这个过程

41:03.400 --> 41:04.600
把左边的颗数达到

41:04.900 --> 41:07.100
然后能够达到右边的前续和右边的终续

41:07.200 --> 41:08.500
那么就把右边数拿到

41:08.800 --> 41:10.500
那自己能拿到左边拿到了

41:10.500 --> 41:11.300
右边拿到了

41:11.300 --> 41:13.600
那就把自己的Left指向左边

41:13.900 --> 41:15.700
自己的Right指向右边就完事了

41:17.400 --> 41:18.800
好那么这个函数怎么写

41:19.900 --> 41:20.800
说是好说

41:20.800 --> 41:21.200
说是好

41:21.200 --> 41:22.600
写下来的还是有点

41:22.800 --> 41:23.800
少写麻烦

41:24.000 --> 41:25.200
不到底慢慢写

41:26.000 --> 41:28.000
要遇到这种复杂问题一定不能着急

41:28.300 --> 41:30.600
你得一步一步慢一步一步慢慢来

41:32.710 --> 41:33.610
首先第一个

41:35.780 --> 41:37.680
因为有可能会出现一种情况

41:37.680 --> 41:39.380
左边右边没在没有了

41:39.380 --> 41:39.780
对吧

41:40.080 --> 41:40.680
右边没有了

41:40.680 --> 41:41.780
或者左边没有了

41:42.480 --> 41:42.980
对吧

41:43.180 --> 41:43.980
比方说像这个

41:43.980 --> 41:44.680
像这颗数

41:45.080 --> 41:47.080
这个数数是少了一个右边

41:47.280 --> 41:47.780
对不对

41:47.880 --> 41:49.580
那你看对于这颗数而言

41:49.580 --> 41:51.680
他要怀疑左边好说

41:52.480 --> 41:53.380
自己是C吗

41:53.780 --> 41:54.680
左边是F吗

41:54.880 --> 41:56.180
前续变律和终续变律都是F

41:56.180 --> 41:57.380
那右边是不是没有了

41:57.380 --> 41:58.580
没有是不是空置不穿

41:58.780 --> 41:59.180
因此呢

41:59.180 --> 42:00.780
我们首先判断一种情况

42:01.780 --> 42:02.580
就是说

42:03.380 --> 42:05.180
dlr.lens

42:07.410 --> 42:08.310
等于0

42:10.110 --> 42:12.410
并且ldr.lens

42:12.810 --> 42:13.510
等于0

42:14.810 --> 42:16.310
所以两个字不算是空的对吧

42:17.710 --> 42:20.110
没有前续和终续

42:20.310 --> 42:20.910
那说明啥

42:20.910 --> 42:22.310
说明没有节点呗

42:22.610 --> 42:23.810
没有节点范围啥

42:25.810 --> 42:26.810
那这个数就是哪

42:28.920 --> 42:29.620
是这个意思

42:30.320 --> 42:31.120
这个数就是哪

42:33.890 --> 42:34.290
好

42:34.290 --> 42:35.790
那么接下来进入正常情况

42:36.790 --> 42:37.890
他有东西

42:38.990 --> 42:39.990
有东西咋办

42:42.920 --> 42:43.920
有东西咋办呢

42:44.920 --> 42:46.320
首先得到自己

42:46.520 --> 42:47.520
一步一步来啊

42:47.720 --> 42:48.920
首先得到自己

42:49.620 --> 42:50.520
前续是不是

42:50.920 --> 42:52.120
前续的第一个

42:52.420 --> 42:53.420
他一定是自己

42:54.120 --> 42:55.320
甭管你是怎么序列啊

42:55.320 --> 42:56.920
只要你第一个一定是自己

42:57.120 --> 42:58.420
首先拿到自己再说

42:59.120 --> 43:00.220
自己怎么拿到呢

43:00.420 --> 43:02.720
是不是拿到前续变律的

43:04.120 --> 43:05.620
第一个制服

43:06.420 --> 43:07.420
拿到第一个制服

43:08.020 --> 43:08.920
那么我们这里呢

43:09.020 --> 43:10.120
比如用一个啊

43:10.120 --> 43:12.020
叫route value

43:15.460 --> 43:18.160
通过前续变律的

43:18.460 --> 43:20.860
第一个制服

43:24.260 --> 43:24.960
得到

43:28.060 --> 43:30.060
跟节点的value值

43:30.360 --> 43:30.760
对吧

43:31.460 --> 43:32.360
跟节点的value值

43:32.360 --> 43:33.560
比方这个前续变律

43:33.560 --> 43:34.060
这个终续变律

43:34.060 --> 43:34.660
它跟节点是啥

43:34.660 --> 43:35.460
跟节点是b

43:35.660 --> 43:36.360
这个前续变律

43:36.360 --> 43:37.760
终续变律跟节点是啥

43:37.760 --> 43:38.560
跟节点就是a

43:38.760 --> 43:39.060
对吧

43:39.160 --> 43:40.360
那么得到它的value值

43:41.060 --> 43:42.160
然后是不是得到通过

43:42.160 --> 43:42.860
这个value值

43:42.860 --> 43:44.460
来创建一个节点啊

43:44.560 --> 43:45.660
这个只是一个字无窜

43:46.460 --> 43:47.660
只是一个字无窜解决

43:48.060 --> 43:49.260
它并不是一个节点

43:49.260 --> 43:50.460
我再创建一个节点啊

43:50.460 --> 43:50.960
route

43:51.560 --> 43:52.860
六一个node

43:53.860 --> 43:54.460
值是啥

43:54.460 --> 43:55.660
值就是route value

43:57.460 --> 43:59.160
创建跟节点

44:00.860 --> 44:01.960
通过跟节点的value值

44:01.960 --> 44:02.860
创建个跟节点

44:03.060 --> 44:04.060
跟节点是不是拿到了

44:04.260 --> 44:05.360
那跟节点拿到过后呢

44:05.360 --> 44:06.760
我们只需要做一件事

44:06.760 --> 44:09.260
就是route.naves等于啥啥啥

44:09.360 --> 44:10.460
把这个啥啥啥搞定

44:10.560 --> 44:12.760
然后呢route.route等于啥啥啥

44:12.760 --> 44:13.760
把这个啥啥啥搞定

44:13.760 --> 44:15.160
最后呢返回这个route就完了

44:17.070 --> 44:17.870
你说还有啥吗

44:17.870 --> 44:18.670
说没啥了

44:18.970 --> 44:19.770
就这么一件事

44:20.370 --> 44:21.770
搞定naves搞定route

44:22.170 --> 44:24.070
好然后呢返回route就完事了

44:25.170 --> 44:26.370
啊这是我们要做的事

44:26.470 --> 44:27.970
那么现在一步一步搞定啊

44:28.770 --> 44:30.270
为了搞定naves

44:30.270 --> 44:31.670
为了搞定route

44:31.670 --> 44:33.870
我们是不是按照刚才的分析

44:33.970 --> 44:36.270
得得的首先我们要搞定naves

44:36.270 --> 44:38.670
我就必须要得到左边的前续

44:38.770 --> 44:39.970
和左边的中续

44:41.570 --> 44:42.170
是不是这样子

44:43.370 --> 44:45.170
我得得到左边的前续

44:45.770 --> 44:46.870
和左边的中续

44:47.870 --> 44:49.270
当我首先第一个问题

44:49.370 --> 44:51.670
我怎么来得到左边的前续呢

44:52.070 --> 44:52.970
我现在得到他了

44:53.770 --> 44:55.870
我怎么来得到左边的前续呢

44:56.270 --> 44:57.970
首先我怎么来得到左边的中续

45:00.970 --> 45:02.470
是不是找这个玩意儿

45:02.870 --> 45:04.670
在中续边的中的位置

45:06.170 --> 45:07.870
这个位置前边的不就是中续吗

45:07.970 --> 45:08.770
左边的中续吗

45:10.370 --> 45:10.770
对不对

45:10.770 --> 45:11.570
是不是这个道理

45:11.770 --> 45:13.570
这个玩这个玩意儿右边的不就是

45:14.270 --> 45:14.970
右边的中续

45:16.070 --> 45:17.270
好一步一步来啊

45:17.470 --> 45:19.070
所以说我们这里要搞定的是什么呢

45:19.170 --> 45:20.070
搞定的是

45:20.370 --> 45:22.170
找这个节点这个是值对吧

45:22.270 --> 45:23.570
当前根结点的值

45:23.670 --> 45:26.070
这个值呢在中续中的位置

45:29.650 --> 45:31.050
route index

45:32.150 --> 45:32.750
啥意思呢

45:32.750 --> 45:33.850
我跟变量名字都不好

45:33.850 --> 45:34.850
不是很好取的啊

45:34.850 --> 45:35.850
我就打号注释

45:36.050 --> 45:37.550
有的时候变量名字不是很好取的

45:37.550 --> 45:38.450
所以多打注释

45:39.450 --> 45:47.150
根结点在终续变立中的位置

45:48.650 --> 45:49.650
这个打写

45:51.620 --> 45:52.420
终续变立

45:52.620 --> 45:57.780
ldr index2

45:58.780 --> 45:59.380
什么呢

46:01.320 --> 46:02.220
能跟上吗

46:02.220 --> 46:03.220
括号里边写啥

46:04.920 --> 46:06.120
我这个小括号里边写啥

46:06.820 --> 46:07.620
那天空体

46:10.180 --> 46:11.180
小括号里边写啥

46:12.580 --> 46:14.880
对就是不就是不就是route value吗

46:14.980 --> 46:15.580
很好啊

46:16.380 --> 46:18.480
就要写上route value

46:19.980 --> 46:21.480
那么这样子的是不是把这个

46:21.480 --> 46:22.880
这个地方的位置拿到了

46:24.380 --> 46:25.380
拿到这个位置

46:25.380 --> 46:26.980
我要得到终续变立

46:26.980 --> 46:27.780
怎么得到

46:28.680 --> 46:30.680
啊那么现在就是得到什么

46:31.080 --> 46:33.980
左边的终续变立

46:33.980 --> 46:35.180
ldr

46:36.380 --> 46:40.480
这是左边的终续变立

46:41.680 --> 46:42.280
怎么写

46:42.880 --> 46:43.780
是不是就是

46:43.980 --> 46:46.380
终续变立里边结续字无错

46:46.380 --> 46:47.480
substream

46:48.180 --> 46:48.780
对吧

46:49.180 --> 46:50.280
subsstream

46:51.380 --> 46:53.580
骑士的位置从零开始

46:53.880 --> 46:54.880
结束位置呢

46:54.880 --> 46:56.180
他取不到结束位置啊

46:56.480 --> 46:57.680
他取不到结束位置的

46:57.680 --> 46:59.280
结束位置不就是这个位置吗

47:00.480 --> 47:04.480
那么是不是就是route indexed

47:05.480 --> 47:07.380
这样子说拿到左边的终续变立

47:08.980 --> 47:09.480
对不对

47:10.080 --> 47:11.280
好我们这里输出一下吧

47:11.380 --> 47:12.180
慢慢写啊

47:13.180 --> 47:13.780
ldr

47:14.280 --> 47:15.680
首先看一下左边的终续变立

47:15.680 --> 47:16.680
这么对不对

47:20.470 --> 47:21.370
gdbe

47:21.370 --> 47:21.870
看到没

47:22.170 --> 47:22.870
gdbe

47:22.870 --> 47:24.070
左边的终续什么拿到的

47:25.270 --> 47:27.770
好拿到了左边的终续过后

47:27.870 --> 47:28.670
但是还没完啊

47:28.670 --> 47:30.770
我还得拿左边的前续啊

47:31.770 --> 47:32.970
左边的前续等于啥啊

47:34.980 --> 47:35.980
左边的前续等于啥

47:37.080 --> 47:38.680
前续是不是等于

47:38.880 --> 47:40.480
从前续变立里边取

47:41.580 --> 47:42.280
第一个是根

47:42.280 --> 47:43.180
那不能不能取嘛

47:43.180 --> 47:44.380
那就从第二个开始取

47:44.580 --> 47:45.980
对吧取多少个呢

47:46.680 --> 47:47.880
终续变立有几个

47:47.880 --> 47:48.580
他就取几个

47:48.580 --> 47:49.580
终续变立是4个

47:50.780 --> 47:51.380
你不能说钱

47:51.380 --> 47:52.180
终续变立是4个

47:52.180 --> 47:53.580
前续变立是3个那不可能

47:54.480 --> 47:55.280
终续变立的数量

47:55.280 --> 47:56.980
一定跟前续变立的数量是一样的

47:57.180 --> 47:59.380
那么前续变立的左边一定是4个

47:59.780 --> 48:00.380
所以说呢

48:00.380 --> 48:02.680
前续变立的左边是什么什么东西

48:02.880 --> 48:03.580
net

48:04.480 --> 48:05.880
dlr是什么

48:06.280 --> 48:07.780
就是dlr

48:07.780 --> 48:09.780
之前的前续变立supstream

48:12.010 --> 48:12.910
从哪个位置开始取

48:13.010 --> 48:14.610
从下标为一的位置开始取

48:15.010 --> 48:16.910
后边第二个参数全穿nace

48:17.010 --> 48:17.910
取几个呢

48:19.210 --> 48:20.810
啊这个地方问号位置填啥

48:20.910 --> 48:22.210
又是到填空题又来

48:23.310 --> 48:24.210
问号位置填啥

48:31.180 --> 48:33.580
rude indexed

48:34.980 --> 48:36.580
加1啊这个是长度啊

48:36.580 --> 48:37.580
这个地方是长度啊

48:37.580 --> 48:38.780
不是结束桌标

48:40.680 --> 48:41.780
哎这个是对的啊

48:41.880 --> 48:43.980
napsldr.nace

48:44.680 --> 48:46.080
就是终续变立的长度

48:46.780 --> 48:49.880
napsldr.nace

48:53.420 --> 48:54.620
你看不就喜欢了吗

48:54.620 --> 48:55.520
好说说一下啊

48:55.620 --> 48:57.620
左边的前续变立

48:58.920 --> 49:00.020
左边的终续变立

49:00.920 --> 49:02.620
看一下是不是我们刚才分析的结果

49:05.000 --> 49:07.000
前续变立bdg1

49:07.000 --> 49:08.800
终续变立gd比

49:09.200 --> 49:10.000
看是不是出来了

49:11.000 --> 49:13.200
好那么这是是不是得到了左边的前续

49:13.200 --> 49:14.200
和左边的终续

49:15.000 --> 49:15.600
那又来

49:16.600 --> 49:18.800
左边的左边的前续

49:19.400 --> 49:20.500
有点糟对吧

49:20.600 --> 49:22.200
但是糟它并不复杂这一块

49:22.200 --> 49:23.200
其实真不复杂

49:23.300 --> 49:25.500
你小心一点慢慢一句话一句话

49:25.500 --> 49:26.900
写一个参数一个参数起

49:26.900 --> 49:28.100
你绝对能写对的

49:28.700 --> 49:29.900
有的朋友他写单码

49:29.900 --> 49:31.300
他写不出来还是着急啊

49:31.300 --> 49:32.600
特别特别着急

49:32.900 --> 49:34.100
我又不知道他急啥

49:34.600 --> 49:35.700
你有大把大把的时间

49:35.700 --> 49:37.300
你要说你工作了倒是很急

49:37.300 --> 49:37.700
对吧

49:37.700 --> 49:38.500
家伙吹的紧

49:38.500 --> 49:39.500
你倒是很急

49:39.500 --> 49:41.100
你在学东西你急啥呢

49:41.300 --> 49:42.800
你还有大把大把的时间

49:42.800 --> 49:43.500
一天嘛

49:43.500 --> 49:45.100
我就用一天就写几行大把

49:45.100 --> 49:45.600
我不行

49:45.600 --> 49:46.700
我就不行写不出来

49:46.700 --> 49:47.800
这一定能写出来了

49:47.800 --> 49:49.300
只要你写出来的一次

49:49.300 --> 49:50.700
你这一辈子不用怕他

49:50.700 --> 49:51.800
你永远写出来了

49:53.500 --> 49:54.800
你不用着急啊写单码

49:54.800 --> 49:55.700
一定要慢一点

49:55.800 --> 49:57.300
特别是刚开始学的时候

49:59.100 --> 49:59.300
好

49:59.300 --> 50:00.000
然后呢

50:00.000 --> 50:01.300
一路边的前续

50:01.300 --> 50:02.400
还要得到右边的前续

50:02.400 --> 50:03.300
和右边的终续

50:03.300 --> 50:03.800
对吧

50:04.200 --> 50:05.000
那又来了

50:05.800 --> 50:06.500
又来了

50:06.800 --> 50:08.000
首先我们一个个来

50:08.300 --> 50:09.500
一路边的终续

50:09.900 --> 50:10.600
Rise

50:11.900 --> 50:12.500
终续

50:12.700 --> 50:14.000
LDR

50:15.200 --> 50:16.200
右边的终续等于啥

50:20.160 --> 50:21.860
是不是之前这个位置

50:22.060 --> 50:23.660
加一从这个下边开始取

50:23.660 --> 50:24.460
取到结尾

50:24.860 --> 50:25.160
对不对

50:25.160 --> 50:26.260
不就是右边终续吗

50:26.560 --> 50:27.260
那么怎么写

50:27.860 --> 50:29.760
那么就是终续遍地

50:31.830 --> 50:32.730
Suppers Stream 也好

50:32.730 --> 50:34.330
Suppers STR 也好

50:34.830 --> 50:36.030
哪个位置开始取

50:37.330 --> 50:38.030
Root

50:38.930 --> 50:39.730
Index

50:40.030 --> 50:40.730
加一

50:42.640 --> 50:43.840
从这个位置开始取

50:44.740 --> 50:45.840
取到什么了取到结尾

50:45.940 --> 50:46.940
第二参数不要了

50:47.440 --> 50:49.440
那么这样取出来是不是右边的

50:51.940 --> 50:52.540
终续

50:55.030 --> 50:55.130
好

50:55.130 --> 50:55.930
输出一下啊

50:56.230 --> 50:56.930
Rise

50:57.130 --> 50:57.930
LDR

51:00.480 --> 51:01.180
FC

51:01.280 --> 51:02.480
对不对右边的终续

51:03.580 --> 51:04.780
好右边的终续取出来了

51:04.880 --> 51:06.880
然后现在我们要取右边的前续

51:08.280 --> 51:09.080
DR

51:10.680 --> 51:11.880
右边的前续咋取了

51:13.790 --> 51:14.390
咋取了

51:15.090 --> 51:16.190
不得也是一样吧

51:17.790 --> 51:18.690
这算一个吗

51:19.690 --> 51:20.090
对吧

51:20.090 --> 51:20.890
算一个吗

51:21.390 --> 51:22.390
这个长度是已知的

51:22.390 --> 51:22.790
对吧

51:22.790 --> 51:23.990
我们刚才已经算出来了

51:24.190 --> 51:24.990
所以已知的

51:25.190 --> 51:25.790
这个玩意儿

51:25.990 --> 51:26.790
长度已知

51:27.590 --> 51:29.090
那就是这个玩意儿加一的

51:30.490 --> 51:31.690
是不是跟玩意儿加一

51:32.190 --> 51:33.390
这个玩意儿的长度加一

51:34.090 --> 51:34.590
对不对

51:34.790 --> 51:36.290
那因为现在下标是从0开始的

51:36.290 --> 51:36.990
不就是这样吗

51:37.390 --> 51:38.590
啊这个长度以前是多少吧

51:38.590 --> 51:39.390
以前是4吗

51:39.490 --> 51:39.890
对不对

51:39.890 --> 51:40.890
4的长度为4

51:40.890 --> 51:41.990
加上一是不是就5

51:42.190 --> 51:44.090
那么就下标从5开始取

51:44.390 --> 51:47.290
那012345

51:47.390 --> 51:48.690
不就是从这里开始吗

51:49.090 --> 51:50.590
所以说这里的前续便利

51:51.090 --> 51:51.990
DLR

51:52.390 --> 51:53.090
substitute

51:54.990 --> 51:56.090
从哪个位置开始取呢

51:56.190 --> 51:57.390
从Left

51:57.990 --> 51:59.290
DLR

52:00.190 --> 52:02.690
之前的左边的这个前续便利

52:03.690 --> 52:04.990
要长度

52:08.790 --> 52:10.090
这就是右边

52:11.290 --> 52:12.190
右边的

52:14.690 --> 52:15.390
前续

52:16.590 --> 52:16.790
好

52:16.790 --> 52:17.890
我们来输出一下啊

52:18.090 --> 52:19.490
右边的前续

52:19.790 --> 52:21.190
右边的中续

52:23.870 --> 52:25.170
你看右边的前续

52:25.170 --> 52:26.070
右边的中续

52:26.370 --> 52:27.270
不就出来了吗

52:28.870 --> 52:29.670
我相信啊

52:29.670 --> 52:30.870
我绝对相信

52:31.670 --> 52:33.370
80%的同学

52:33.670 --> 52:35.570
他只要能够静下心来洗

52:36.570 --> 52:37.470
不急躁

52:37.570 --> 52:40.270
我会不知道现在为什么那么多朋友会很非常非常急躁

52:40.570 --> 52:42.770
只要不急躁他绝对能写出来的

52:42.870 --> 52:44.270
我能把这个分析到这种程度

52:44.270 --> 52:45.470
他绝对能写出来的

52:45.870 --> 52:47.770
写不出来的主要原因就是特别着急

52:49.270 --> 52:49.970
不要着急

52:49.970 --> 52:51.270
你越紧越写不出来

52:53.280 --> 52:53.980
好那么

52:53.980 --> 52:55.280
这样子写出来的过后

52:55.280 --> 52:57.080
那左边的前续左边的中续有了

52:57.080 --> 52:58.480
右边的前续右边的中续有了

52:58.480 --> 53:00.080
那么按照我们刚才分析咋写

53:00.880 --> 53:01.980
输的左边等于啥

53:02.380 --> 53:03.380
又来一次呗

53:03.480 --> 53:04.380
是不是又来一次

53:04.780 --> 53:05.580
get去

53:06.080 --> 53:07.580
这玩意不就返回一个节点吗

53:08.080 --> 53:10.480
我现在把左边的左边的前续给力

53:11.980 --> 53:12.680
左边的

53:13.480 --> 53:14.380
终续给力

53:15.580 --> 53:18.280
对哈左边的前续左边的终续给力

53:18.280 --> 53:19.480
那你给我得到一棵树

53:19.580 --> 53:21.680
这棵树的节点的就是我的左分枝

53:22.380 --> 53:23.380
然后呢右边

53:23.780 --> 53:24.580
是不是get to

53:26.080 --> 53:26.780
右边的

53:27.980 --> 53:29.080
前前续

53:30.180 --> 53:31.280
右边的终续

53:32.080 --> 53:32.680
你给我

53:32.880 --> 53:34.280
那就是这棵树的右分枝

53:34.580 --> 53:34.980
是吧

53:35.580 --> 53:37.780
搞定的左分枝搞定的右分枝把这棵树返回

53:37.780 --> 53:38.280
就按时

53:39.980 --> 53:40.480
get to

53:41.180 --> 53:42.380
好最后呢我们来看一下

53:44.980 --> 53:46.080
无限低规了是吧

53:46.580 --> 53:48.080
好看一下哪里出了问题啊

53:48.080 --> 53:48.980
无限低规了

53:50.580 --> 53:51.380
呃

53:51.980 --> 53:52.980
哪里出了问题呢

53:58.560 --> 53:59.360
输出一下啊

53:59.860 --> 54:00.460
输出一下

54:00.460 --> 54:03.760
left dl r left dl r

54:04.760 --> 54:07.660
然后呢right dl r right

54:08.360 --> 54:09.360
l d r

54:11.360 --> 54:12.560
哎呦和哎呦和

54:13.060 --> 54:13.760
都全是

54:17.470 --> 54:19.770
前面的没问题啊后边全是空的了啊

54:20.770 --> 54:24.470
啊空的了过后全是空字不出了啊

54:25.570 --> 54:26.870
全是空字不出了

54:27.670 --> 54:29.470
空字不出了他应该等于零了

54:29.870 --> 54:30.670
他不应该

54:30.970 --> 54:32.970
他不应该进入这吗

54:33.770 --> 54:34.770
哦得得写错了

54:35.070 --> 54:36.170
得写错了nice

54:36.770 --> 54:37.770
有反正错误

54:38.970 --> 54:39.570
啊刷新

54:41.070 --> 54:43.270
好那么现在就构建着构建了好了这棵树

54:43.270 --> 54:44.870
那么这棵树我们来看一下这漏的啊

54:45.970 --> 54:47.170
a 里边r b c

54:49.080 --> 54:50.180
不就是刚才那棵树吗

54:50.380 --> 54:51.380
a 里边b c

54:52.280 --> 54:55.080
然后b c c 后边那是一个f

54:55.780 --> 54:57.180
怎么样c 的左分之f

54:57.180 --> 54:58.080
右分之没有

54:58.280 --> 54:59.780
左分之f 里边就没东西了

55:00.180 --> 55:01.680
啊那么右边是正确的

55:01.780 --> 55:02.680
然后看左边

55:02.780 --> 55:04.480
b 里边呢有什么 d 和e

55:05.220 --> 55:06.280
b 里边d 和e

55:06.980 --> 55:09.180
好d d 呢 d 后边呢有g

55:09.780 --> 55:11.380
d 后边有g 后边就没了

55:11.880 --> 55:13.580
然后呢e 后边呢啥都没有

55:14.080 --> 55:15.180
是不是这个数就还原了

55:15.280 --> 55:16.080
对不对啊

55:16.080 --> 55:19.380
这就是根据前续和根据中续来还原一棵

55:19.580 --> 55:20.480
一棵二叉树

55:20.480 --> 55:22.180
那么这样子呢我就不用去构建

55:22.180 --> 55:23.280
哪怕这个树再复杂

55:23.280 --> 55:24.880
我就只要把便利节目给他

55:24.880 --> 55:27.380
他就能把树把这个树根结点拿到

55:32.150 --> 55:34.450
好这是一道稍微的复杂一点的题啊

55:37.170 --> 55:38.130
能听懂懂同学Q个一

55:38.130 --> 55:39.130
让我看一下有多少呢

55:39.330 --> 55:39.830
多么先

55:40.830 --> 55:42.430
你他有点有有点复杂

55:42.430 --> 55:43.530
其实他也不复杂了

55:43.530 --> 55:44.630
其实就是有点

55:45.230 --> 55:45.930
凡数

55:46.830 --> 55:48.130
只是有点凡数啊

55:49.130 --> 55:49.830
还行是吧

55:49.830 --> 55:50.530
还行啊

55:50.530 --> 55:51.630
我看这份同学还是可以

55:51.730 --> 55:52.530
需要看回话

55:52.630 --> 55:53.830
啊没关系慢慢来吧

55:54.230 --> 55:55.030
只要你下来决心

55:55.030 --> 55:56.230
你一定是能搞定的

55:57.830 --> 55:59.030
啊你看

55:59.530 --> 56:01.530
我独大你们跟那个社会独大你们

56:01.530 --> 56:02.430
他是不一样的

56:02.830 --> 56:03.930
我独大完了过后呢

56:03.930 --> 56:05.030
我还有抢救手段

56:05.030 --> 56:06.230
对吧我得鼓励鼓励你

56:06.430 --> 56:07.630
不能让你去过去了

56:08.030 --> 56:09.130
社会独大完了过后

56:09.130 --> 56:09.630
他就

56:10.430 --> 56:11.830
他就停止任职了啊

56:11.830 --> 56:14.330
你可能就直接直接就回不过来气了

56:14.930 --> 56:16.130
我还能把他抢救回来

56:16.130 --> 56:19.540
把牙耗伤过后再重新独大

56:19.640 --> 56:22.140
这就是老师独大跟那个社会独大的区别啊

56:23.740 --> 56:24.540
大家不要怕啊

56:24.540 --> 56:26.040
接下来还有个数的深度啊

56:26.040 --> 56:27.340
数的深度就比较简单了

56:27.440 --> 56:28.640
这会比较简单了啊

56:29.540 --> 56:30.640
来什么叫数的深度

56:30.640 --> 56:31.440
我们之前说了

56:31.640 --> 56:34.440
就是呢数的最大程式就是数的深度

56:35.240 --> 56:36.440
那么个深度怎么算呢

56:38.610 --> 56:39.710
比较有这么一棵树啊

56:39.810 --> 56:41.010
这个树呢就是刚才这个树

56:41.010 --> 56:42.610
这个树的深度是多少你1234

56:42.610 --> 56:43.510
1234

56:43.910 --> 56:44.810
深度为4

56:45.110 --> 56:46.410
那么现在我们需要个函数

56:47.010 --> 56:47.610
方形

56:48.210 --> 56:49.510
get deep

56:50.610 --> 56:51.610
给我一个数

56:52.010 --> 56:53.410
我来算这个数的深度

56:55.110 --> 56:57.610
计算数的深度

57:00.260 --> 57:01.060
好怎么来算

57:02.860 --> 57:04.860
首先我先把这个单码给你写出来

57:05.260 --> 57:07.260
就是如果说你节点都没有给我

57:07.260 --> 57:08.160
你节点都没有

57:10.330 --> 57:11.230
那我的深度是多少的

57:11.230 --> 57:12.230
深度肯定是0啊

57:12.530 --> 57:13.430
那还能是多少呢

57:14.230 --> 57:16.030
你节点都没有一个数的深度肯定是0

57:17.630 --> 57:18.430
那么接下来

57:18.730 --> 57:19.630
有意思就来了

57:21.930 --> 57:23.430
那节点它有节点呢

57:23.930 --> 57:24.830
深度是多少的

57:29.980 --> 57:31.180
当然节目是4嘛

57:31.180 --> 57:31.880
它身体啊

57:31.880 --> 57:33.780
你并不知道数长什么样子

57:33.780 --> 57:34.380
你得算

57:35.680 --> 57:36.680
你给我一个节点

57:36.680 --> 57:38.380
那么这个数的其实深度是多少呢

57:39.480 --> 57:41.180
你只要这个节点有值

57:41.180 --> 57:42.780
是不是至少为1

57:44.180 --> 57:45.680
深度至少为1

57:45.880 --> 57:46.380
对不对

57:47.280 --> 57:47.780
好

57:48.280 --> 57:51.280
1也就是它1应该加上什么呢

57:51.880 --> 57:52.980
听听好啊

57:52.980 --> 57:56.180
加上左边这颗数的

57:56.980 --> 58:00.280
深度和右边这颗数的深度的最大值

58:01.680 --> 58:02.380
然后左边这颗

58:02.380 --> 58:04.180
左边这颗数的深度为几

58:05.680 --> 58:06.180
为3

58:06.580 --> 58:07.880
右边这颗数的深度为几

58:07.880 --> 58:08.380
为2

58:08.380 --> 58:10.380
那么2和3求最大值是不是3

58:10.680 --> 58:12.280
3加上它自己1

58:12.280 --> 58:13.080
这就是4

58:14.580 --> 58:15.580
这是不是又是第一回

58:15.680 --> 58:16.080
对吧

58:16.080 --> 58:17.180
那么求左边又怎么求的

58:17.180 --> 58:17.880
它又是一样

58:17.880 --> 58:18.580
求左边的话

58:18.580 --> 58:19.380
它就是它

58:19.480 --> 58:20.180
它是1

58:20.180 --> 58:22.180
加上它左边的深度

58:22.280 --> 58:23.380
右边的深度的最大值

58:24.380 --> 58:25.580
明白这个意思吧

58:26.080 --> 58:27.280
那就是没有回事啊

58:27.280 --> 58:28.080
所以说呢

58:28.180 --> 58:30.080
这一块呢是极其简单的

58:30.480 --> 58:31.780
怎么玩呢就是

58:33.180 --> 58:34.180
get deep

58:36.600 --> 58:38.100
把左边的颗数扔进去

58:38.900 --> 58:40.000
就是左边的深度

58:41.500 --> 58:42.300
然后呢

58:43.000 --> 58:44.000
get deep

58:45.400 --> 58:46.800
右边的颗数扔进去

58:47.800 --> 58:48.900
是不是右边的深度

58:49.900 --> 58:51.000
左边的深度

58:51.600 --> 58:52.700
右边的深度

58:52.900 --> 58:53.700
求什么呢

58:53.800 --> 58:54.900
求最大值

58:57.540 --> 58:58.440
求最大值

58:59.240 --> 58:59.740
是吧

58:59.740 --> 59:01.240
就是左边的深度和右边的深度

59:01.240 --> 59:02.340
求就最大值

59:02.440 --> 59:04.440
然后加上自己

59:05.340 --> 59:06.040
就玩个招来

59:06.340 --> 59:07.940
就是又赚数的深度

59:08.440 --> 59:08.640
好

59:08.640 --> 59:09.540
咱们来看一下啊

59:09.540 --> 59:11.040
是不是能够集算出来的

59:11.740 --> 59:12.440
get deep

59:14.380 --> 59:14.980
load

59:15.880 --> 59:16.280
4

59:16.880 --> 59:17.180
对

59:17.180 --> 59:18.480
是不是非常容易就算出来了啊

59:18.480 --> 59:18.980
这个多

59:18.980 --> 59:20.180
第一个就它就这个好处啊

59:20.180 --> 59:21.780
你只要逻辑正确

59:21.780 --> 59:22.980
能够把它进行分解

59:22.980 --> 59:24.580
这是个重复的指行为

59:25.580 --> 59:26.780
能够把它分解出来

59:26.980 --> 59:28.280
有这么一个重复的行为

59:28.680 --> 59:30.080
它就可以重复的调整自己

59:30.580 --> 59:31.980
然后整个蛋白机器简单

59:34.340 --> 59:35.540
哎非常非常好啊

59:35.540 --> 59:38.640
就是一加上左右两颗求最大深度

59:38.740 --> 59:39.340
就完事

59:41.480 --> 59:41.780
好

59:41.780 --> 59:43.580
这是数的深度

59:44.680 --> 59:45.380
再下一个

59:51.630 --> 59:52.130
加油

59:52.130 --> 59:52.830
还有两道

59:56.160 --> 59:58.160
这以前就是专门来训练大家思维的

59:58.360 --> 01:00:00.060
其实这些算法到底中国总统来

01:00:00.060 --> 01:00:01.560
我觉得不算不太重要

01:00:02.160 --> 01:00:03.860
你可能学了过后就忘了忘了也没关系

01:00:03.860 --> 01:00:05.460
只要你思维到了训练

01:00:05.460 --> 01:00:06.460
你就会有收获

01:00:08.260 --> 01:00:09.960
原来查询二叉数

01:00:12.600 --> 01:00:14.400
就是在二一颗二叉数里边

01:00:14.400 --> 01:00:15.900
找一个东西存不存在

01:00:15.900 --> 01:00:17.000
这是查询二叉数

01:00:18.200 --> 01:00:19.700
那么查询的时候呢

01:00:20.100 --> 01:00:21.900
由于它搜索的路径不一样

01:00:21.900 --> 01:00:24.600
我们把它是分为深度优先和

01:00:25.100 --> 01:00:26.200
广度优先

01:00:27.500 --> 01:00:29.100
什么叫深度优先呢

01:00:29.500 --> 01:00:30.400
深度优先指的是啊

01:00:30.400 --> 01:00:31.900
比方说我在这颗数里边找

01:00:31.900 --> 01:00:33.300
这个一存不存在

01:00:33.900 --> 01:00:34.900
那么怎么找呢

01:00:34.900 --> 01:00:37.400
我就其实就是一个先续编辑

01:00:37.700 --> 01:00:39.400
先看自己自己不是吗

01:00:39.600 --> 01:00:40.700
不是找左分支

01:00:40.900 --> 01:00:42.400
左分支又看先看自己

01:00:42.600 --> 01:00:43.900
不是吗啊

01:00:44.100 --> 01:00:45.200
然后又找左分支

01:00:45.200 --> 01:00:46.700
左分支又看自己不是吗

01:00:46.800 --> 01:00:47.700
又找左分支

01:00:47.700 --> 01:00:48.900
又看自己不是吗

01:00:49.300 --> 01:00:49.800
好

01:00:50.000 --> 01:00:50.800
不是去找右分支

01:00:50.800 --> 01:00:51.800
这里没有右分支

01:00:51.800 --> 01:00:52.900
又回到这边来

01:00:52.900 --> 01:00:54.100
刚才左分支找了没有

01:00:54.300 --> 01:00:55.200
自己也找了没有

01:00:55.200 --> 01:00:56.400
然后找了左分支也没有

01:00:56.400 --> 01:00:57.400
然后又找右分支

01:00:57.900 --> 01:00:59.100
这就是深度优先

01:01:00.000 --> 01:01:00.900
这有点像啥呢

01:01:00.900 --> 01:01:03.400
有点有点像里面在网上找一些资料

01:01:03.500 --> 01:01:04.400
找资料的时候

01:01:04.400 --> 01:01:06.200
你把在百度里面搜索结果

01:01:07.100 --> 01:01:08.200
进入点击到第一个

01:01:08.200 --> 01:01:09.100
第一个一般是广告

01:01:09.100 --> 01:01:10.200
我们就随便吧

01:01:10.200 --> 01:01:11.200
点了第一个进去

01:01:12.000 --> 01:01:12.700
发现不是

01:01:12.900 --> 01:01:14.400
不是过后你不出去

01:01:14.500 --> 01:01:15.400
你没有出去

01:01:15.400 --> 01:01:16.900
然后继续往里边点

01:01:16.900 --> 01:01:19.100
往他的深度这个网站里边

01:01:19.100 --> 01:01:20.300
其他的链接里边去点

01:01:20.600 --> 01:01:22.100
把这个网站全部找完

01:01:22.100 --> 01:01:22.800
是不是

01:01:23.100 --> 01:01:23.700
而不是

01:01:23.700 --> 01:01:24.900
然后再出来

01:01:25.500 --> 01:01:26.300
找下一个

01:01:26.300 --> 01:01:27.600
就是深度优先

01:01:28.300 --> 01:01:28.900
那么深度优先

01:01:28.900 --> 01:01:30.100
刚才是搜索出去是什么

01:01:30.200 --> 01:01:35.100
就是 a b d g e

01:01:36.300 --> 01:01:37.300
深度优先搜索

01:01:39.730 --> 01:01:41.230
那什么叫广度优先呢

01:01:41.430 --> 01:01:43.130
广度优先就是你搜索结果

01:01:43.130 --> 01:01:43.930
第一条不满意

01:01:43.930 --> 01:01:44.530
不满意过后了

01:01:44.530 --> 01:01:47.230
我没有没有往这个网站里边继续点了

01:01:47.630 --> 01:01:48.930
我马上就出来点第二个了

01:01:50.330 --> 01:01:51.830
我把看完第一页

01:01:51.830 --> 01:01:53.930
看完了就是搜索结果全部都不是

01:01:53.930 --> 01:01:55.730
然后在每一个网站进去过后

01:01:55.730 --> 01:01:57.030
再往里边去点链接

01:01:57.230 --> 01:01:57.830
啥意思呢

01:01:57.830 --> 01:01:59.330
就是广度优先是这样搜的

01:01:59.330 --> 01:02:00.430
一层一层搜的

01:02:00.930 --> 01:02:02.030
先搜 a 不是吗

01:02:02.330 --> 01:02:03.930
然后再看 b c 不是吗

01:02:04.030 --> 01:02:04.930
然后再看第一

01:02:04.930 --> 01:02:05.830
哎找到了

01:02:07.030 --> 01:02:07.330
看呗

01:02:07.330 --> 01:02:08.830
这就是广度优先搜索

01:02:08.830 --> 01:02:10.130
它是一层一层搜的

01:02:10.130 --> 01:02:11.730
那就两种搜索方式

01:02:12.130 --> 01:02:13.030
那我们一个个来

01:02:13.130 --> 01:02:14.930
首先来看深度优先

01:02:17.670 --> 01:02:18.570
deep first

01:02:21.080 --> 01:02:21.680
search

01:02:22.780 --> 01:02:23.580
deep search

01:02:26.010 --> 01:02:27.110
给我一棵树

01:02:27.210 --> 01:02:28.210
树就是一个点吗

01:02:28.210 --> 01:02:29.510
一个根基点就表示一个树

01:02:29.610 --> 01:02:31.010
然后呢给我一个talkit

01:02:31.810 --> 01:02:32.810
你要搜索的字

01:02:33.810 --> 01:02:36.110
深度优先搜索

01:02:37.810 --> 01:02:38.510
大大搜

01:02:38.910 --> 01:02:40.010
是不是就是一个

01:02:40.510 --> 01:02:41.710
就是一个那个什么

01:02:43.210 --> 01:02:44.010
前续遍地

01:02:45.010 --> 01:02:46.310
首先这个节点有没有

01:02:46.310 --> 01:02:48.110
你没有的话就拿到了啊

01:02:48.710 --> 01:02:49.410
有没有

01:02:50.210 --> 01:02:51.210
没有的话

01:02:51.310 --> 01:02:52.210
那我能找到吗

01:02:52.210 --> 01:02:53.310
肯定找不到了呀

01:02:53.510 --> 01:02:54.310
return force

01:02:54.710 --> 01:02:56.110
节点都没有我打咋找吗

01:02:56.210 --> 01:02:57.610
就没有表示没有找到

01:02:58.210 --> 01:02:59.110
啊没有找到

01:03:00.810 --> 01:03:01.810
然后接下来

01:03:02.410 --> 01:03:04.110
有节点有节点怎么办

01:03:04.210 --> 01:03:06.610
先看自己看自己是不是

01:03:06.910 --> 01:03:09.010
如果说自己漏的解v6

01:03:09.010 --> 01:03:10.010
等于那talkit

01:03:14.510 --> 01:03:16.610
是不是自己就是自己就是

01:03:17.010 --> 01:03:18.210
那么是不是找到了找到了

01:03:18.210 --> 01:03:20.010
返回返回什么返回去

01:03:21.510 --> 01:03:25.090
找到了好

01:03:25.090 --> 01:03:25.790
然后呢

01:03:26.290 --> 01:03:27.290
自己不是

01:03:27.890 --> 01:03:28.490
那怎么办

01:03:28.490 --> 01:03:30.390
自己不是是不是先看左边

01:03:30.790 --> 01:03:31.690
再看右边

01:03:32.790 --> 01:03:33.190
好

01:03:33.190 --> 01:03:35.790
那么如果说左边又来deep search

01:03:36.290 --> 01:03:37.090
重新搜

01:03:37.590 --> 01:03:38.690
load their left

01:03:38.690 --> 01:03:39.790
把左边扔进去

01:03:39.790 --> 01:03:40.890
talkit还是一样

01:03:40.990 --> 01:03:42.490
看左边有没有找到

01:03:43.190 --> 01:03:44.490
左边找到了

01:03:45.090 --> 01:03:45.890
是不是就找到了

01:03:47.830 --> 01:03:48.530
是不是找到了

01:03:49.430 --> 01:03:49.930
对不对

01:03:51.130 --> 01:03:51.530
好

01:03:51.530 --> 01:03:53.230
那不说左边没有找到了

01:03:53.230 --> 01:03:55.530
那只只能寄希望于右边了

01:03:55.830 --> 01:03:57.330
右边没有那就真没有了

01:03:57.430 --> 01:03:58.930
说直接返回右边

01:03:59.230 --> 01:04:00.030
deep search

01:04:00.170 --> 01:04:01.230
load their right

01:04:01.630 --> 01:04:02.130
talkit

01:04:02.630 --> 01:04:03.730
你看是不是这样的模具

01:04:05.070 --> 01:04:05.730
自己有没有

01:04:05.730 --> 01:04:06.930
如果说自己决定都没有的话

01:04:06.930 --> 01:04:07.830
肯定没有找到

01:04:08.630 --> 01:04:09.430
然后呢

01:04:09.430 --> 01:04:11.530
如果说自己有的话

01:04:12.230 --> 01:04:13.630
有找到了有的话

01:04:13.630 --> 01:04:14.830
那看是自己是不是

01:04:14.930 --> 01:04:16.030
是的话就直接找到了

01:04:16.430 --> 01:04:17.130
不用看了

01:04:17.730 --> 01:04:18.230
对吧

01:04:18.630 --> 01:04:20.330
然后如果自己也不是的话

01:04:20.330 --> 01:04:21.230
那么先看左边

01:04:21.230 --> 01:04:22.130
如果左边是的话

01:04:22.130 --> 01:04:22.830
就不用看了

01:04:22.930 --> 01:04:23.730
直接找到了

01:04:25.130 --> 01:04:26.030
那左边不是的话

01:04:26.030 --> 01:04:27.230
只能寄希望于右边

01:04:27.230 --> 01:04:28.230
那右边返回的是去

01:04:28.230 --> 01:04:28.930
就返回去

01:04:28.930 --> 01:04:29.830
右边返回的是force

01:04:29.830 --> 01:04:30.730
就返回force

01:04:31.530 --> 01:04:31.930
对不对

01:04:31.930 --> 01:04:32.730
那左边是force

01:04:32.730 --> 01:04:33.830
还不能说一定找不到

01:04:33.830 --> 01:04:34.830
因为还要看右边

01:04:36.130 --> 01:04:36.830
懂了意思吧

01:04:38.700 --> 01:04:39.700
那么其实这一方

01:04:39.700 --> 01:04:40.800
这个地方可以

01:04:41.200 --> 01:04:41.900
减一些啊

01:04:41.900 --> 01:04:42.800
可以减一些

01:04:42.900 --> 01:04:44.600
就是其实就是减些为啥呢

01:04:45.000 --> 01:04:45.900
就这个玩意儿

01:04:46.100 --> 01:04:46.700
或者

01:04:48.870 --> 01:04:49.470
这个玩意儿

01:04:49.770 --> 01:04:50.170
对不对

01:04:50.170 --> 01:04:51.070
说可以减一些

01:04:51.570 --> 01:04:53.170
因为他返回去的话

01:04:53.170 --> 01:04:54.770
那么后边的代表是不是不会运行

01:04:55.570 --> 01:04:56.370
因为或者的话

01:04:56.370 --> 01:04:57.070
第一个为去

01:04:57.070 --> 01:04:57.970
他就短路算法

01:04:57.970 --> 01:04:58.370
对不对

01:04:58.770 --> 01:04:59.870
短路规则

01:05:00.070 --> 01:05:00.670
前面为处

01:05:00.670 --> 01:05:01.570
后边就不会算了

01:05:01.670 --> 01:05:02.370
不会运算

01:05:02.670 --> 01:05:03.670
前面为force

01:05:04.370 --> 01:05:05.870
后边才会运算

01:05:05.870 --> 01:05:07.170
后边为处还是去

01:05:07.370 --> 01:05:08.270
但是后边为force的话

01:05:08.270 --> 01:05:08.970
两个都为force

01:05:08.970 --> 01:05:09.770
那就force

01:05:10.470 --> 01:05:10.870
对不对

01:05:10.970 --> 01:05:11.670
前看左边

01:05:11.670 --> 01:05:12.370
再看右边

01:05:12.670 --> 01:05:14.270
这就是深度优先搜索

01:05:15.470 --> 01:05:16.170
懂了意思吧

01:05:16.370 --> 01:05:16.570
好

01:05:16.570 --> 01:05:17.170
咱们来看一下

01:05:17.170 --> 01:05:18.070
深度优先搜索啊

01:05:18.070 --> 01:05:19.070
我们搜索

01:05:19.070 --> 01:05:20.270
搜索的搜索路径

01:05:20.570 --> 01:05:21.770
load the value

01:05:22.870 --> 01:05:23.970
看一下他搜索到哪

01:05:25.070 --> 01:05:26.270
到他的搜索路径啊

01:05:26.570 --> 01:05:27.870
比方说咱们来个

01:05:28.070 --> 01:05:28.870
steep search

01:05:30.270 --> 01:05:30.770
load

01:05:31.270 --> 01:05:31.870
搜索这个数

01:05:31.870 --> 01:05:32.270
搜索什么呢

01:05:32.270 --> 01:05:33.070
搜索这个e

01:05:33.270 --> 01:05:34.370
看他搜索的顺序呢

01:05:34.870 --> 01:05:36.570
abdge

01:05:37.670 --> 01:05:39.570
abdge

01:05:39.570 --> 01:05:40.570
看是不是深度优先

01:05:40.670 --> 01:05:41.570
他一条线是走

01:05:41.570 --> 01:05:42.770
一条路是走到黑的

01:05:43.370 --> 01:05:44.670
他最后找到了这个e

01:05:44.870 --> 01:05:46.270
他如果说我找不到呢

01:05:46.870 --> 01:05:47.870
刚才是找到了对吧

01:05:48.470 --> 01:05:49.170
找一个k

01:05:49.170 --> 01:05:50.770
找不到force

01:05:50.770 --> 01:05:52.270
那不就是abdge

01:05:52.270 --> 01:05:52.770
cf

01:05:52.770 --> 01:05:54.470
不就是一个前续便利吗

01:05:55.570 --> 01:05:57.170
换设备没关系啊换一下吧

01:06:05.460 --> 01:06:05.560
好

01:06:05.560 --> 01:06:06.560
这是深度优先

01:06:06.560 --> 01:06:07.160
没问题吧

01:06:07.160 --> 01:06:08.060
深度优先啊

01:06:09.160 --> 01:06:09.360
好

01:06:09.360 --> 01:06:11.260
然后接下来是广度优先

01:06:12.260 --> 01:06:12.860
广度优先呢

01:06:12.860 --> 01:06:15.860
他戴满了稍微的那么丢丢的凡数啊

01:06:16.260 --> 01:06:17.460
也不是很难说了

01:06:18.060 --> 01:06:19.660
就是广度优先啊braze

01:06:22.310 --> 01:06:23.210
咱这些都也没有

01:06:25.210 --> 01:06:26.910
啊应该是啊braze

01:06:27.610 --> 01:06:28.710
呃search

01:06:30.310 --> 01:06:31.010
还是一样

01:06:31.010 --> 01:06:31.810
参数一样

01:06:31.810 --> 01:06:32.710
你给我一棵树

01:06:32.710 --> 01:06:33.610
给我一个目标纸

01:06:33.610 --> 01:06:35.810
我来看一下这个树里面目标纸是不存在

01:06:36.210 --> 01:06:37.310
啊是广度优先

01:06:38.310 --> 01:06:40.010
广度优先搜索

01:06:41.310 --> 01:06:41.510
好

01:06:41.510 --> 01:06:43.110
广度优先咋搜呢

01:06:43.410 --> 01:06:44.210
刚才说了

01:06:44.210 --> 01:06:45.610
它是一层一层看的

01:06:45.910 --> 01:06:47.510
每一层是不是有很多节点

01:06:47.510 --> 01:06:48.810
第一层只有一个嘛

01:06:49.410 --> 01:06:50.310
第二层有两个

01:06:50.310 --> 01:06:51.410
第三层有三个

01:06:51.410 --> 01:06:52.310
第四层只有一个

01:06:52.310 --> 01:06:54.710
每一层差一次有不确定数量的节点

01:06:56.010 --> 01:06:57.010
那么这个时候呢

01:06:57.010 --> 01:06:59.310
我们是不是应该从一个数组里面去搜

01:06:59.310 --> 01:07:00.510
把第一层有一个

01:07:00.610 --> 01:07:02.710
第二层是不是装了一个数组里面有两个

01:07:02.710 --> 01:07:04.110
第三层有三个

01:07:04.810 --> 01:07:05.210
对不对

01:07:05.210 --> 01:07:06.910
所以要放了一个数组里面去搜

01:07:07.010 --> 01:07:07.410
于是呢

01:07:07.410 --> 01:07:09.210
我们肯定是需要一个辅助函数

01:07:09.210 --> 01:07:10.310
为什么需要辅助函数呢

01:07:10.310 --> 01:07:11.110
因为这里没有数组

01:07:12.410 --> 01:07:13.310
怎么还多的意思啊

01:07:13.310 --> 01:07:14.210
所以没有数组

01:07:14.310 --> 01:07:16.110
我需要一个辅助函数啊

01:07:16.110 --> 01:07:16.910
就是

01:07:20.910 --> 01:07:22.910
你给我一个数组

01:07:22.910 --> 01:07:23.310
然后呢

01:07:23.310 --> 01:07:25.310
我从数组里面去搜这个目标字

01:07:26.110 --> 01:07:28.110
那么我其实我这个函数

01:07:28.110 --> 01:07:29.210
实际上是调了他谁

01:07:29.210 --> 01:07:29.810
调了他

01:07:29.810 --> 01:07:30.510
这种模式呢

01:07:30.510 --> 01:07:31.910
我们已经过很多次了

01:07:32.410 --> 01:07:33.510
一开始都给他一个

01:07:33.510 --> 01:07:34.510
只有一个节点的数组

01:07:34.510 --> 01:07:36.210
因为跟节点是不是只有一个

01:07:36.210 --> 01:07:37.710
意思是把它放到一个数组里面

01:07:37.710 --> 01:07:39.210
格式改转换一下

01:07:39.210 --> 01:07:40.210
然后他可以成一样

01:07:40.210 --> 01:07:41.410
他可以成我都不用写了

01:07:42.410 --> 01:07:44.410
因为本来他的手不会变的

01:07:45.110 --> 01:07:45.910
是不是就这样子

01:07:47.310 --> 01:07:47.710
对不对

01:07:47.710 --> 01:07:49.110
我把它放到一个数组里面

01:07:49.110 --> 01:07:50.010
因为我需要

01:07:50.010 --> 01:07:50.610
这个函数呢

01:07:50.610 --> 01:07:52.110
是每一层都是一个数组

01:07:52.110 --> 01:07:53.410
这说的都是一个数组

01:07:53.410 --> 01:07:54.410
我地规认是他

01:07:55.010 --> 01:07:55.610
第一层完了

01:07:55.610 --> 01:07:56.710
我和第二层又是个数组

01:07:56.710 --> 01:07:57.710
第三层又是个数组

01:07:58.110 --> 01:07:58.610
是吧

01:07:58.710 --> 01:07:59.710
是这么个意思啊

01:08:00.810 --> 01:08:01.210
好

01:08:01.210 --> 01:08:01.910
那么也就是说

01:08:01.910 --> 01:08:03.610
我一开始搜索跟节点的时候呢

01:08:03.610 --> 01:08:04.210
我在

01:08:04.410 --> 01:08:05.710
我在内部封装一下

01:08:06.310 --> 01:08:07.510
把它放到一个数组里面

01:08:07.710 --> 01:08:07.910
啊

01:08:07.910 --> 01:08:08.710
格式统一

01:08:09.510 --> 01:08:10.210
我说要问一下

01:08:10.210 --> 01:08:10.910
我不担心啊

01:08:11.010 --> 01:08:12.110
这块有没有问题啊

01:08:12.410 --> 01:08:13.610
就这个格式有没有问题

01:08:14.810 --> 01:08:16.210
我这样子写能不能理解

01:08:16.910 --> 01:08:18.710
他是要一层一层去搜数组

01:08:19.710 --> 01:08:20.510
因为他这个玩意

01:08:20.510 --> 01:08:21.810
他传过来的不是数组

01:08:21.810 --> 01:08:22.210
所以说呢

01:08:22.210 --> 01:08:23.610
我需要一个辅助函数啊

01:08:24.410 --> 01:08:25.910
把它当成一个数组来编辑

01:08:26.110 --> 01:08:26.210
啊

01:08:26.210 --> 01:08:26.610
因此呢

01:08:26.610 --> 01:08:28.010
我这里交用一下这个函数

01:08:28.010 --> 01:08:29.410
这个函数还没有写啊

01:08:30.010 --> 01:08:30.510
能可以写吗

01:08:30.510 --> 01:08:31.010
这个函数

01:08:31.710 --> 01:08:32.610
我有点慌啊

01:08:37.560 --> 01:08:38.360
理解不了啊

01:08:38.360 --> 01:08:39.260
哪里有问题啊

01:08:41.140 --> 01:08:41.640
啊

01:08:43.040 --> 01:08:44.240
那我再解释一下吧

01:08:44.440 --> 01:08:45.340
再解释一下吧

01:08:45.640 --> 01:08:46.540
就是广度有限

01:08:46.540 --> 01:08:48.040
你现在不要考 考虑这个函数啊

01:08:48.040 --> 01:08:48.940
你不要看它

01:08:49.340 --> 01:08:50.240
广度有限搜数

01:08:50.240 --> 01:08:51.540
它是不是一层一层搜的

01:08:52.640 --> 01:08:53.340
它不像那个

01:08:53.340 --> 01:08:53.800
深度有限

01:08:53.800 --> 01:08:54.840
它是一个节点一个节点来了

01:08:54.840 --> 01:08:55.240
对吧

01:08:55.440 --> 01:08:57.540
广度有限它是一层一层搜的

01:08:57.640 --> 01:08:58.440
第一层

01:09:00.240 --> 01:09:00.940
是一个数组

01:09:01.040 --> 01:09:02.440
这个数组里面只有一个节点

01:09:02.940 --> 01:09:04.540
第二层还是一个数组

01:09:04.540 --> 01:09:05.840
这个数组里面有两个节点

01:09:06.140 --> 01:09:07.040
第三层

01:09:07.640 --> 01:09:08.340
还是一个数组

01:09:08.340 --> 01:09:09.540
这个数组里面有三个节点

01:09:09.640 --> 01:09:10.440
第四层

01:09:10.740 --> 01:09:11.340
还是一个数组

01:09:11.340 --> 01:09:12.640
这个数组里面有一个节点

01:09:13.840 --> 01:09:14.740
这样能理解吧

01:09:15.040 --> 01:09:15.680
那么也就说

01:09:15.680 --> 01:09:17.280
我需要有这么一个函数

01:09:17.280 --> 01:09:18.280
这个函数呢

01:09:18.280 --> 01:09:19.380
它接收一个数组

01:09:20.280 --> 01:09:21.480
不过它的函数是啥吧

01:09:21.480 --> 01:09:22.580
它接收一个数组

01:09:23.180 --> 01:09:24.480
那么它是不是这个函数

01:09:24.480 --> 01:09:26.280
就满足这个搜索的方案

01:09:26.580 --> 01:09:26.880
对吧

01:09:26.880 --> 01:09:27.880
它接收一个数组

01:09:27.980 --> 01:09:29.580
那么它就便利这个数组搜

01:09:29.780 --> 01:09:30.380
搜不到

01:09:30.380 --> 01:09:31.880
那么就重新调问这个函数

01:09:31.880 --> 01:09:32.680
进行下一层

01:09:33.180 --> 01:09:33.380
对

01:09:33.380 --> 01:09:34.680
是不是这里要传一个数组

01:09:34.980 --> 01:09:35.880
但是呢

01:09:35.980 --> 01:09:37.380
我外面的函数呢

01:09:37.980 --> 01:09:39.880
以为这个要统一

01:09:39.880 --> 01:09:41.280
因为传的是根基点

01:09:41.280 --> 01:09:42.280
所以外面这个函数

01:09:42.280 --> 01:09:43.880
它接收的不是数组

01:09:44.680 --> 01:09:46.080
所以有点不满足要求

01:09:46.380 --> 01:09:47.480
我们要做的是

01:09:47.480 --> 01:09:48.480
我们要实现它

01:09:48.480 --> 01:09:49.780
深入广度优先

01:09:49.780 --> 01:09:50.780
我们需要一层一层

01:09:50.780 --> 01:09:51.880
每一层是一个数组

01:09:52.880 --> 01:09:53.280
但是呢

01:09:53.280 --> 01:09:54.380
我们外面传进来的

01:09:54.380 --> 01:09:55.180
它不是一个数组

01:09:55.180 --> 01:09:55.780
那么转

01:09:55.780 --> 01:09:56.880
换一下不就完了吗

01:09:57.580 --> 01:09:58.480
我写个函数

01:09:58.480 --> 01:09:59.480
它接收一个数组

01:09:59.480 --> 01:10:00.580
那么你传的不是数组

01:10:00.580 --> 01:10:01.880
我就把封装成数组

01:10:01.880 --> 01:10:02.280
调问进去

01:10:02.280 --> 01:10:02.880
不完了吗

01:10:03.280 --> 01:10:04.080
能理解了吧

01:10:05.180 --> 01:10:06.180
就这么个意思啊

01:10:09.210 --> 01:10:09.910
任意名称

01:10:09.910 --> 01:10:10.810
任意名称都可以

01:10:12.010 --> 01:10:12.610
只是呢

01:10:12.710 --> 01:10:14.110
习惯上的我会这样子写

01:10:14.710 --> 01:10:15.610
习惯上这样子写

01:10:15.710 --> 01:10:17.210
因为下滑在街市里面

01:10:17.210 --> 01:10:18.110
下滑线开头的

01:10:18.110 --> 01:10:19.810
一般表示内部的东西

01:10:20.110 --> 01:10:21.310
外面的不要用

01:10:21.510 --> 01:10:22.510
就是这个意思

01:10:23.210 --> 01:10:24.610
是一个命名的规范而已

01:10:27.800 --> 01:10:29.000
然后你只能讲到这

01:10:29.000 --> 01:10:30.200
我不知道怎么去讲了

01:10:31.000 --> 01:10:32.900
那你就把它看完吧

01:10:32.900 --> 01:10:34.300
看完你就大概就明白了

01:10:36.120 --> 01:10:37.620
不要告诉我看不懂这个

01:10:37.620 --> 01:10:39.320
这个就是把它放到一个数组里面

01:10:39.520 --> 01:10:40.920
数组的第一项就是这个值

01:10:42.220 --> 01:10:42.820
那么这个

01:10:42.820 --> 01:10:44.820
我现在我们就把问题转换到这个函数了

01:10:44.820 --> 01:10:45.920
这个函数怎么做呢

01:10:46.120 --> 01:10:46.920
它是一个数组

01:10:46.920 --> 01:10:48.520
我要从这个数组里面去收

01:10:49.520 --> 01:10:50.020
怎么收

01:10:50.420 --> 01:10:52.020
首先这个数组有没有长度

01:10:56.040 --> 01:10:56.740
数组

01:10:57.840 --> 01:10:58.740
是空白的

01:10:59.340 --> 01:11:00.140
那没东西

01:11:01.340 --> 01:11:02.640
没东西但能不能找到

01:11:04.740 --> 01:11:05.640
那里边能不能找到

01:11:05.640 --> 01:11:06.640
一定找不到啊

01:11:07.040 --> 01:11:08.040
一定找不到啊

01:11:09.040 --> 01:11:09.640
直接里面

01:11:11.940 --> 01:11:12.840
是不是一定找不到

01:11:15.260 --> 01:11:16.160
出手没东西啊

01:11:16.360 --> 01:11:17.960
好 那么数组有东西

01:11:20.060 --> 01:11:21.460
出手有东西不要这一层

01:11:22.160 --> 01:11:23.460
有东西那可怎么办呢

01:11:23.560 --> 01:11:25.460
是循环这个数组

01:11:26.560 --> 01:11:27.560
一个一个看

01:11:28.160 --> 01:11:29.360
他说要一个一个看

01:11:29.860 --> 01:11:31.760
看一下这个数组里面这一项是不是

01:11:32.260 --> 01:11:32.960
好来吧

01:11:33.660 --> 01:11:34.560
循环这个数组

01:11:34.760 --> 01:11:35.360
获循环

01:11:35.960 --> 01:11:36.760
i等于0

01:11:38.360 --> 01:11:39.320
i小于

01:11:39.560 --> 01:11:40.060
loads

01:11:41.260 --> 01:11:41.960
i加加

01:11:43.060 --> 01:11:44.860
循环这小写的非常没到手啊

01:11:44.860 --> 01:11:46.160
都不用过脑袋子

01:11:46.960 --> 01:11:48.260
好 循环这个数组

01:11:48.960 --> 01:11:50.760
一项一项的去看

01:11:51.260 --> 01:11:52.960
看一下这一项

01:11:54.940 --> 01:11:55.940
这一项的什么

01:11:56.140 --> 01:11:56.940
value值

01:11:57.540 --> 01:11:58.640
然后循环这个数组

01:11:58.740 --> 01:11:59.840
拿到这一项的b

01:11:59.940 --> 01:12:00.740
拿到这个玩意

01:12:01.540 --> 01:12:02.540
看一下他是不是

01:12:02.540 --> 01:12:04.340
我说把这个图直接贴过来吧

01:12:04.940 --> 01:12:05.540
贴过来

01:12:12.890 --> 01:12:13.290
啊

01:12:13.490 --> 01:12:14.290
一项一项看

01:12:14.290 --> 01:12:15.890
比方说看这个b和c

01:12:15.890 --> 01:12:16.590
这个数组

01:12:16.890 --> 01:12:18.190
看这一项是不是

01:12:18.290 --> 01:12:19.090
什么叫是不是呢

01:12:19.090 --> 01:12:21.090
就是他点value等于这个 target

01:12:22.390 --> 01:12:23.590
如果说他試的话

01:12:23.790 --> 01:12:24.590
試的话怎么办

01:12:24.590 --> 01:12:25.690
試的话就直接坦克出了

01:12:25.690 --> 01:12:25.890
对吧

01:12:25.890 --> 01:12:26.490
找都找到

01:12:26.490 --> 01:12:27.290
还找他呀

01:12:27.290 --> 01:12:27.890
就不找了

01:12:28.290 --> 01:12:29.490
后面的一定不看了

01:12:29.790 --> 01:12:30.290
比方b

01:12:30.290 --> 01:12:30.990
他已经试了

01:12:30.990 --> 01:12:31.990
我们找的就是b

01:12:32.190 --> 01:12:32.590
结束了

01:12:32.590 --> 01:12:33.490
不要让我后找了

01:12:34.090 --> 01:12:34.590
别上处吧

01:12:34.590 --> 01:12:35.390
这个没问题吧

01:12:35.990 --> 01:12:37.490
那如果说b不是呢

01:12:40.040 --> 01:12:40.940
b不是咋办

01:12:41.140 --> 01:12:42.240
当然得往后找啊

01:12:42.240 --> 01:12:43.340
数组还没有循环完

01:12:43.340 --> 01:12:44.540
那么同时呢

01:12:44.540 --> 01:12:46.640
我们需要把b的指节点

01:12:46.940 --> 01:12:48.540
就贴件到一个新的数组里边

01:12:48.540 --> 01:12:50.840
因为他将来还要找后边这一层啊

01:12:51.140 --> 01:12:51.740
明了意思吧

01:12:51.740 --> 01:12:52.940
就要找后边这一层

01:12:53.240 --> 01:12:53.640
因此呢

01:12:53.640 --> 01:12:55.240
我们这里需要一个新的数组

01:12:55.240 --> 01:12:57.140
就next layer

01:12:59.530 --> 01:13:01.730
下一层的节点

01:13:03.030 --> 01:13:03.930
那么这个怎么办呢

01:13:03.930 --> 01:13:04.530
如果说

01:13:04.730 --> 01:13:06.130
他试的话就直接返回了

01:13:06.130 --> 01:13:07.430
反复都结束了

01:13:07.730 --> 01:13:08.930
那如果说不是的话

01:13:08.930 --> 01:13:10.930
我们是不是往那个next layer里边

01:13:11.630 --> 01:13:12.430
固形一个

01:13:12.930 --> 01:13:15.130
加加什么加两个加b的什么

01:13:15.230 --> 01:13:15.830
b的

01:13:17.630 --> 01:13:19.530
左节点和b的右节点

01:13:19.530 --> 01:13:20.730
当然b的左节点也要存在

01:13:20.730 --> 01:13:22.030
b的右节点也要存在啊

01:13:22.130 --> 01:13:23.230
所以说在这里呢

01:13:23.530 --> 01:13:24.130
呃

01:13:24.230 --> 01:13:25.730
我们这里最好判断一下啊

01:13:25.730 --> 01:13:26.830
如果说no

01:13:27.530 --> 01:13:29.330
i.next是存在的

01:13:29.430 --> 01:13:30.630
他有左节点

01:13:31.030 --> 01:13:31.630
有左节点的话

01:13:31.630 --> 01:13:32.730
我们把左节点加进去

01:13:33.730 --> 01:13:35.930
no i.next

01:13:35.930 --> 01:13:37.930
把他左节点加进去

01:13:38.330 --> 01:13:39.530
同样的道理

01:13:39.530 --> 01:13:40.930
如果他有右节点的话

01:13:42.330 --> 01:13:43.930
我们把右节点加进去

01:13:46.190 --> 01:13:48.090
这样子循环结束过后

01:13:48.090 --> 01:13:49.790
哪怕这一层没有找到

01:13:49.790 --> 01:13:50.690
不要我们找e

01:13:50.790 --> 01:13:52.290
哪怕没有找到这一层

01:13:52.790 --> 01:13:53.690
循环结束过后

01:13:53.690 --> 01:13:54.690
你想一想这个道理

01:13:55.790 --> 01:13:56.690
b不是

01:13:56.790 --> 01:13:58.290
那么b的左节点和右节点

01:13:58.290 --> 01:13:59.590
是不是加到这个数组里边去了

01:14:00.190 --> 01:14:01.090
又找c

01:14:01.090 --> 01:14:01.890
c也不是

01:14:01.890 --> 01:14:03.190
一说c的左节点

01:14:03.290 --> 01:14:04.790
右节点又点点没有对吧

01:14:04.890 --> 01:14:05.590
左节点

01:14:05.790 --> 01:14:06.690
右节点他都直接点

01:14:06.690 --> 01:14:07.890
是不是加到这个数组里边去了

01:14:07.990 --> 01:14:10.090
那么这个数组里边是不是记录了d e f

01:14:10.490 --> 01:14:11.790
是不是记录了下一层

01:14:12.090 --> 01:14:12.490
对吧

01:14:12.490 --> 01:14:14.590
也就是这个复活循环是找我们这一层

01:14:14.690 --> 01:14:15.690
我们这一层没有

01:14:15.890 --> 01:14:17.290
然后下一层已经有值了

01:14:17.290 --> 01:14:18.990
下一层的数组里边已经有东西了

01:14:19.090 --> 01:14:19.990
然后怎么办

01:14:20.890 --> 01:14:21.790
然后怎么办了

01:14:21.990 --> 01:14:23.090
然后呢我就

01:14:24.090 --> 01:14:24.890
返回

01:14:25.090 --> 01:14:26.890
直接找去找下一层的结果

01:14:27.590 --> 01:14:28.490
那个是没有

01:14:29.390 --> 01:14:30.390
所以地轨雕用

01:14:31.290 --> 01:14:32.490
自己这一层已经搞定了

01:14:32.590 --> 01:14:33.790
那么接下来就是下一层

01:14:34.790 --> 01:14:36.190
这是广度游戏搜索

01:14:38.710 --> 01:14:39.710
那么我们可以看一下

01:14:39.710 --> 01:14:41.210
广度游戏它的搜索顺序

01:14:42.410 --> 01:14:43.010
怎么看呢

01:14:43.010 --> 01:14:44.810
每次许就看每次许完的

01:14:45.110 --> 01:14:46.410
每次许完你的看啥

01:14:46.410 --> 01:14:46.810
对吧

01:14:47.110 --> 01:14:48.210
搜索一下load

01:14:49.210 --> 01:14:49.710
哎

01:14:53.090 --> 01:14:53.890
广度游戏

01:14:55.090 --> 01:14:57.490
bridge search load

01:14:57.890 --> 01:14:59.290
搜索什么不要说ok吗

01:15:00.990 --> 01:15:02.190
看搜索顺序

01:15:02.190 --> 01:15:02.890
先看a

01:15:02.890 --> 01:15:04.190
然后再看b和c

01:15:04.590 --> 01:15:05.890
然后再看d e f

01:15:06.190 --> 01:15:06.990
然后再看g

01:15:07.590 --> 01:15:08.690
后面实在找不到了

01:15:08.890 --> 01:15:09.390
force

01:15:09.890 --> 01:15:10.690
好再看啊

01:15:11.090 --> 01:15:12.190
我们搜索这个e

01:15:13.590 --> 01:15:16.790
说找a找bc找d找e找到了

01:15:17.490 --> 01:15:18.190
i去

01:15:18.790 --> 01:15:19.590
广度游戏

01:15:29.990 --> 01:15:32.690
好那么搜索这一块是不是因为了

01:15:33.290 --> 01:15:34.490
你看最后道理的啊

01:15:34.990 --> 01:15:37.490
最后道理比较两颗二差数

01:15:37.490 --> 01:15:38.390
得到他们的差异

01:15:39.190 --> 01:15:40.090
这个玩意儿呢

01:15:40.290 --> 01:15:42.090
跟你们以后学到这个view

01:15:42.290 --> 01:15:43.490
学到这个reference呢

01:15:43.490 --> 01:15:44.490
有没有关系呢

01:15:45.090 --> 01:15:46.090
没啥关系啊

01:15:46.490 --> 01:15:48.890
但是呢有没有启发呢有启发

01:15:49.490 --> 01:15:51.290
将来呢我们课程里边

01:15:51.590 --> 01:15:54.490
会有无诱的和reference的原码分析

01:15:55.090 --> 01:15:56.690
原码分析里边呢就涉及到

01:15:57.690 --> 01:15:59.290
差异算法啊

01:15:59.390 --> 01:16:00.490
无诱里边叫patch

01:16:00.990 --> 01:16:02.090
reference里边叫diff

01:16:03.790 --> 01:16:04.890
道理都差不多

01:16:05.290 --> 01:16:06.490
就是有两棵树

01:16:06.790 --> 01:16:09.490
你要把这两棵树的差异点全部找出来

01:16:11.590 --> 01:16:12.590
现在我们来看一下

01:16:16.320 --> 01:16:17.120
比方说这里

01:16:18.120 --> 01:16:19.420
这里有一棵树

01:16:23.540 --> 01:16:24.640
这里也有一棵树

01:16:27.050 --> 01:16:30.150
这棵树呢比方说这里是

01:16:38.500 --> 01:16:39.800
画面颜色啊k

01:16:40.900 --> 01:16:43.800
然后呢这边是一开始是

01:16:44.400 --> 01:16:58.600
这边好这边是t

01:17:02.750 --> 01:17:03.550
好看一下

01:17:06.130 --> 01:17:08.930
比较这棵树和这棵树进行比较

01:17:11.420 --> 01:17:13.020
比较的结果就是差异

01:17:13.020 --> 01:17:14.320
他们有哪些差异

01:17:15.420 --> 01:17:17.120
那么我们首先说两棵树我们知道

01:17:17.120 --> 01:17:19.220
对吧两个根结点传进去就可以比较了

01:17:19.220 --> 01:17:20.020
非常简单

01:17:20.420 --> 01:17:22.220
根结点一传进去就可以比较

01:17:22.220 --> 01:17:23.120
极限到简单

01:17:24.020 --> 01:17:26.220
现在关键是我们怎么来表示差异呢

01:17:26.620 --> 01:17:28.520
差异的表示方式呢其实也很简单

01:17:28.920 --> 01:17:30.520
我们可以用个数组有很多差异吗

01:17:30.520 --> 01:17:32.120
一个差异就是一个数组的一下

01:17:32.720 --> 01:17:34.520
一个差异就是一个对象

01:17:35.220 --> 01:17:36.520
我们比较说简单一点啊

01:17:37.220 --> 01:17:38.520
第一个差异点是什么呢

01:17:39.420 --> 01:17:41.020
A的左分之就这个节点

01:17:42.720 --> 01:17:43.420
这个节点

01:17:43.820 --> 01:17:44.920
这个节点呢

01:17:45.920 --> 01:17:48.320
到这个节点它是一个修改

01:17:48.820 --> 01:17:49.320
对不对

01:17:50.220 --> 01:17:51.220
其他没它变化

01:17:51.220 --> 01:17:52.620
就是把它的直变了

01:17:53.120 --> 01:17:54.820
也就是说我们这里可以这样子写

01:17:55.620 --> 01:17:58.120
那一型是修改

01:18:00.280 --> 01:18:01.080
这是第一个差异

01:18:01.780 --> 01:18:03.080
原来的节点是什么呢

01:18:03.080 --> 01:18:03.680
orange

01:18:03.880 --> 01:18:06.180
原来的节点是B low的

01:18:07.180 --> 01:18:07.880
low的B

01:18:09.080 --> 01:18:10.980
这是个对象啊一个节点对象

01:18:11.880 --> 01:18:13.880
好然后呢新的节点是什么呢

01:18:14.880 --> 01:18:16.480
呃或者是from

01:18:16.480 --> 01:18:17.680
从什么变成什么

01:18:17.880 --> 01:18:19.080
从low的B

01:18:19.380 --> 01:18:20.180
变成了

01:18:21.480 --> 01:18:23.280
变成了什么low的k

01:18:25.080 --> 01:18:25.780
原来的意思吧

01:18:25.880 --> 01:18:26.980
就是是不是第一个差异

01:18:26.980 --> 01:18:27.880
内形是修改

01:18:27.980 --> 01:18:30.680
原来从原来的B节点变成了k节点

01:18:32.750 --> 01:18:34.050
好就是第一个啊

01:18:35.750 --> 01:18:37.550
第二个内形

01:18:39.780 --> 01:18:41.380
那么就这里啊这里的内形

01:18:41.480 --> 01:18:42.780
这里内形是不是三除

01:18:43.980 --> 01:18:44.780
第二个差异

01:18:45.580 --> 01:18:46.080
三除

01:18:47.780 --> 01:18:49.180
从原来到什么节点呢

01:18:49.480 --> 01:18:51.380
从原来的low的G

01:18:51.580 --> 01:18:52.280
G节点

01:18:52.980 --> 01:18:54.880
然后这里应该是to啊变成什么

01:18:55.580 --> 01:18:55.980
to

01:18:56.880 --> 01:18:57.880
变成了什么节点呢

01:18:57.880 --> 01:18:58.580
变成一个mao

01:18:59.480 --> 01:19:00.080
没有了

01:19:00.380 --> 01:19:01.780
对吧G节点被删除了

01:19:02.480 --> 01:19:05.080
就是我们要记住它的变化信息

01:19:06.180 --> 01:19:07.680
好再来还有什么呢

01:19:07.680 --> 01:19:08.680
这边还有新增

01:19:10.280 --> 01:19:10.980
新增

01:19:13.020 --> 01:19:15.220
从原来什么节点从原来的mao节点

01:19:15.420 --> 01:19:16.920
以前没有这个T节点的

01:19:17.520 --> 01:19:20.720
那么现在to变成什么low的T

01:19:21.520 --> 01:19:22.920
这就是我们现在要做的事情

01:19:23.220 --> 01:19:25.220
我给他这棵树给他这棵树

01:19:25.420 --> 01:19:27.120
然后呢他要告诉我这个结果

01:19:27.820 --> 01:19:31.120
就是树的对比算法啊差异算法

01:19:33.830 --> 01:19:36.130
好首先懂你们有没有懂我这个意思

01:19:36.530 --> 01:19:38.430
我要做的事情的目标也没有理解

01:19:39.430 --> 01:19:40.430
我要做什么事也没有理解

01:19:40.430 --> 01:19:41.430
理解的话Q个1

01:19:42.430 --> 01:19:43.930
这是咱们今天的最后一道题了啊

01:19:44.330 --> 01:19:44.930
加油

01:19:48.060 --> 01:19:49.360
一件事了好来

01:19:52.060 --> 01:19:52.660
加油啊

01:19:54.060 --> 01:19:55.960
来我讲可以讲的有点累了

01:19:56.860 --> 01:19:57.860
啊加油

01:19:58.860 --> 01:19:59.460
好来吧

01:20:00.460 --> 01:20:03.460
东西我就把这个函数呢取名为

01:20:04.960 --> 01:20:06.760
你给我一个low的1

01:20:06.860 --> 01:20:08.360
你给我一个low的2

01:20:12.700 --> 01:20:13.200
对比

01:20:14.800 --> 01:20:17.500
两棵树的差异

01:20:18.500 --> 01:20:19.700
啊返回差异结果

01:20:20.000 --> 01:20:23.200
对吧返回差异结果返回差异结果

01:20:23.200 --> 01:20:24.900
结果是什么了结果结果就是个输出

01:20:25.100 --> 01:20:26.300
输出里面每一项是个对象

01:20:26.400 --> 01:20:27.300
记住他的差异

01:20:27.900 --> 01:20:29.900
然后比方说我们现在就准备好两棵树吧

01:20:30.200 --> 01:20:32.000
这是树这是第一棵树

01:20:32.300 --> 01:20:34.300
刚才就是我们一开始的第一棵树

01:20:34.400 --> 01:20:35.400
然后呢第二棵树

01:20:35.700 --> 01:20:36.500
low的2

01:20:37.700 --> 01:20:38.400
第二棵树

01:20:38.600 --> 01:20:40.000
第二棵树呢我们只剩在哪

01:20:40.000 --> 01:20:41.700
就用之前的那个函数来搞定

01:20:42.000 --> 01:20:43.600
第二棵树呢我看一下啊

01:20:44.100 --> 01:20:46.600
第二棵树是前续便利中续便利

01:20:46.600 --> 01:20:47.600
我重新来写一下

01:20:48.100 --> 01:20:49.500
前续便利是

01:20:51.100 --> 01:20:51.800
a

01:20:52.800 --> 01:20:54.400
前续便利 a

01:20:54.400 --> 01:20:55.000
k

01:20:55.300 --> 01:20:55.900
d

01:20:55.900 --> 01:20:56.500
e

01:20:57.600 --> 01:20:58.300
c

01:20:58.400 --> 01:20:59.300
ft

01:20:59.500 --> 01:21:00.800
这是他前续便利结果

01:21:04.060 --> 01:21:05.160
好中续便利

01:21:08.030 --> 01:21:09.130
中续便利是

01:21:09.930 --> 01:21:10.630
呃

01:21:13.030 --> 01:21:13.430
d

01:21:13.430 --> 01:21:13.830
k

01:21:13.830 --> 01:21:14.330
e

01:21:15.630 --> 01:21:16.230
a

01:21:16.730 --> 01:21:17.130
f

01:21:17.130 --> 01:21:17.430
c

01:21:17.430 --> 01:21:17.830
t

01:21:20.120 --> 01:21:21.820
啊我先把两棵树打拿到啊

01:21:22.320 --> 01:21:24.320
这样方便一点拿到这两棵树

01:21:25.920 --> 01:21:28.020
好接下来我要调用的就是这个地幅算法

01:21:28.220 --> 01:21:30.620
把low的1传进去把low的2传进去

01:21:30.920 --> 01:21:31.520
low的1

01:21:32.320 --> 01:21:33.520
low的2传进去

01:21:33.520 --> 01:21:35.720
你给我返回个结构返回个结构是什么

01:21:35.920 --> 01:21:36.520
就是

01:21:37.220 --> 01:21:37.720
realt

01:21:38.020 --> 01:21:40.320
就是差一点最后我们输出这个差一点

01:21:41.520 --> 01:21:42.420
就是我们要做的事

01:21:43.120 --> 01:21:43.620
来吧

01:21:45.120 --> 01:21:46.620
怎么来算怎么来比较差异

01:21:48.420 --> 01:21:50.720
其实这个函数呢看上去好像很复杂的样子

01:21:50.720 --> 01:21:51.820
其实他一点都不复杂

01:21:52.520 --> 01:21:53.320
一点都不复杂

01:21:54.920 --> 01:21:56.720
仍然是一个低规的过程

01:21:57.020 --> 01:21:59.020
你只管当前一年就行了

01:21:59.420 --> 01:22:02.020
我只生我什么后边的东西我全部不管

01:22:02.120 --> 01:22:03.120
我只管我自己

01:22:03.620 --> 01:22:06.020
low的1和low的2他到底是什么回事

01:22:06.720 --> 01:22:09.720
也就是我这个节点跟这个节点到底发生了什么事情

01:22:09.720 --> 01:22:10.520
有没有变化

01:22:10.920 --> 01:22:11.920
我就管这个事情

01:22:12.720 --> 01:22:16.720
那么也就说我要比较的无非就是他和他有什么不同

01:22:18.320 --> 01:22:20.620
然后他比较往的过在比较左边在比较右边

01:22:20.820 --> 01:22:22.020
无非就是这么一回事吧

01:22:22.220 --> 01:22:22.720
对不对

01:22:23.320 --> 01:22:24.020
好来吧

01:22:25.020 --> 01:22:27.720
我先用一个数组来装

01:22:28.620 --> 01:22:29.420
装差异

01:22:30.020 --> 01:22:31.120
来装一些差异

01:22:33.380 --> 01:22:35.080
好首先一个判断啊

01:22:36.280 --> 01:22:37.580
如果说low的1没有

01:22:37.780 --> 01:22:39.080
low的1没有值

01:22:42.800 --> 01:22:43.800
两个节点都没有值

01:22:43.800 --> 01:22:44.700
那有差异吗

01:22:45.000 --> 01:22:46.200
那咋有差异呢

01:22:46.200 --> 01:22:48.400
两个都没有没有没有值啊

01:22:48.700 --> 01:22:49.800
比方说你像比方

01:22:50.000 --> 01:22:53.100
1的左接电和1这边的1的左接电都没有东西

01:22:53.100 --> 01:22:54.500
这个左接电都是空的

01:22:54.500 --> 01:22:55.700
这边左接电也是空的

01:22:55.800 --> 01:22:56.400
那有差异吗

01:22:56.400 --> 01:22:57.400
肯定没有差异啊

01:22:58.200 --> 01:22:59.400
对不对 是不是没有差异

01:23:00.700 --> 01:23:02.100
啊两个都没有值

01:23:02.100 --> 01:23:04.300
那么后边也他也没不可能有什么分支

01:23:04.300 --> 01:23:05.300
也不可能有6分支

01:23:05.300 --> 01:23:06.800
这不可能有差异了

01:23:06.800 --> 01:23:08.300
说直接把这东西倒出来返回

01:23:09.000 --> 01:23:09.400
啊

01:23:09.700 --> 01:23:11.200
要返回个空数组就可以了

01:23:12.900 --> 01:23:15.500
两个节点都没有值

01:23:16.500 --> 01:23:18.100
不可能有差异

01:23:18.600 --> 01:23:21.100
啊返回空数组

01:23:21.800 --> 01:23:22.300
即可

01:23:23.600 --> 01:23:24.700
好接下来又下一个

01:23:25.600 --> 01:23:26.700
你给我一个来啊

01:23:27.300 --> 01:23:27.800
好

01:23:28.100 --> 01:23:30.200
两个都没有值的情况考虑了

01:23:30.200 --> 01:23:32.400
那么就一定是至少有一个有值

01:23:33.200 --> 01:23:34.300
那我一个个来啊

01:23:34.700 --> 01:23:35.800
首先这种情况

01:23:36.000 --> 01:23:37.700
漏的1没有值

01:23:39.500 --> 01:23:40.500
漏的1

01:23:42.100 --> 01:23:42.800
没有值

01:23:45.480 --> 01:23:46.880
漏的2有值

01:23:48.180 --> 01:23:48.980
有变化没

01:23:51.150 --> 01:23:51.850
有变化没

01:23:52.550 --> 01:23:53.850
漏的1没有值

01:23:54.250 --> 01:23:55.450
漏的2有值

01:23:55.550 --> 01:23:56.250
有没有变化

01:23:57.450 --> 01:23:58.350
这个变化是啥

01:23:59.350 --> 01:24:00.950
是不是新增啊

01:24:01.350 --> 01:24:02.450
这就是新增啊

01:24:02.450 --> 01:24:03.150
你看啊

01:24:03.650 --> 01:24:05.050
漏的1没有值

01:24:05.550 --> 01:24:08.350
你看这里面这边C的right是没有值

01:24:09.050 --> 01:24:10.950
C这边C的right是有值

01:24:11.450 --> 01:24:12.350
漏的1没有值

01:24:12.350 --> 01:24:13.250
漏的2有值

01:24:13.250 --> 01:24:14.250
说明就是新增啊

01:24:14.650 --> 01:24:15.250
对不对

01:24:15.250 --> 01:24:17.550
那是说需要往这result里边

01:24:17.950 --> 01:24:18.850
扑洗一个

01:24:20.650 --> 01:24:21.550
加入一个

01:24:22.150 --> 01:24:23.150
加入一个什么呢

01:24:24.750 --> 01:24:25.550
加入一个什么呢

01:24:25.650 --> 01:24:26.750
加入一个变化

01:24:27.750 --> 01:24:28.550
变化是什么呢

01:24:28.550 --> 01:24:29.350
变化是

01:24:29.650 --> 01:24:31.550
太等于新增

01:24:32.950 --> 01:24:33.750
啊新增

01:24:35.150 --> 01:24:35.650
好

01:24:35.750 --> 01:24:37.150
服装原来的节点是什么呢

01:24:37.150 --> 01:24:39.250
原来节点肯定是漏的1吧

01:24:39.250 --> 01:24:40.150
漏的1就没有值

01:24:40.150 --> 01:24:41.550
没有值相当于就是漏的

01:24:41.550 --> 01:24:42.550
漏的1反正也没有值

01:24:42.550 --> 01:24:44.550
你这里写的漏的1是一样的

01:24:44.750 --> 01:24:46.250
因为这里漏的1是没有值的

01:24:46.750 --> 01:24:48.350
所以说这里的服装就是漏的

01:24:48.750 --> 01:24:49.450
原来没有

01:24:49.450 --> 01:24:51.450
现在有了有了是什么

01:24:51.450 --> 01:24:52.450
有的是漏的2

01:24:53.250 --> 01:24:53.750
你看

01:24:54.150 --> 01:24:55.450
所以加入一个差异

01:24:55.850 --> 01:24:56.650
有新增

01:24:57.350 --> 01:24:58.350
好那么想一想

01:24:58.450 --> 01:24:59.950
如果说这种情况下

01:24:59.950 --> 01:25:01.150
还需要比较左边

01:25:01.150 --> 01:25:02.550
还需要表达他的右边吗

01:25:03.050 --> 01:25:03.650
你看啊

01:25:04.650 --> 01:25:05.150
C

01:25:05.750 --> 01:25:07.150
还左有以前右边都没有

01:25:07.150 --> 01:25:08.750
这边各节点没有是空的

01:25:08.950 --> 01:25:10.350
然后这里新增了一个T

01:25:10.350 --> 01:25:12.250
那么哪怕T后边还有东西

01:25:12.550 --> 01:25:13.850
还需要往后比比较吗

01:25:13.850 --> 01:25:14.650
没法比较了

01:25:15.250 --> 01:25:16.550
因为这边的分支都没有

01:25:16.550 --> 01:25:18.650
他怎么跟他同一个城市比较了

01:25:19.250 --> 01:25:20.750
那没法跟同一个城市比较

01:25:20.750 --> 01:25:22.250
所以说不用往后比较了

01:25:22.250 --> 01:25:22.750
知道吧

01:25:23.350 --> 01:25:24.050
不用往后比较了

01:25:24.050 --> 01:25:25.150
因为他以前没有啊

01:25:25.150 --> 01:25:25.950
这是空的

01:25:26.150 --> 01:25:26.950
你要说这里有的

01:25:26.950 --> 01:25:29.050
我们希望往后比较再一次比较吗

01:25:29.050 --> 01:25:30.150
他说这里没有啊

01:25:30.150 --> 01:25:30.850
啥都没有

01:25:31.050 --> 01:25:31.750
你这里新增了

01:25:31.750 --> 01:25:33.150
哪怕你这个新增一棵树

01:25:33.250 --> 01:25:34.350
由于一个级的

01:25:34.550 --> 01:25:36.150
有几千万个节点都无所谓的

01:25:36.250 --> 01:25:37.250
反正都是新增的

01:25:38.050 --> 01:25:38.550
没什么意思吧

01:25:38.550 --> 01:25:38.950
所以说了

01:25:38.950 --> 01:25:40.450
这里的就结束了

01:25:42.250 --> 01:25:43.050
就结束了

01:25:43.450 --> 01:25:44.450
这种情况下

01:25:44.650 --> 01:25:45.750
这种情况

01:25:46.450 --> 01:25:49.250
不需要继续往后比较

01:25:50.250 --> 01:25:52.050
你之前少了一个短了一个

01:25:52.050 --> 01:25:52.750
都要知道了

01:25:53.550 --> 01:25:53.950
好

01:25:54.650 --> 01:25:55.450
然后再看

01:25:56.950 --> 01:26:00.150
右来就是漏的一有值

01:26:01.250 --> 01:26:03.550
并且呢漏的二没有值

01:26:04.850 --> 01:26:05.750
这是什么情况

01:26:07.720 --> 01:26:08.820
左边那个有值

01:26:08.820 --> 01:26:09.620
右边那个没有值

01:26:09.620 --> 01:26:10.520
这是什么情况

01:26:15.000 --> 01:26:16.000
就是三处啊

01:26:16.200 --> 01:26:16.400
对啊

01:26:16.400 --> 01:26:16.900
就是三处的

01:26:16.900 --> 01:26:17.400
看这里

01:26:18.000 --> 01:26:18.700
就这个玩意

01:26:19.600 --> 01:26:20.200
就是

01:26:20.600 --> 01:26:21.500
这边既

01:26:22.000 --> 01:26:22.700
以前有

01:26:22.700 --> 01:26:23.500
但是现在没有了

01:26:23.500 --> 01:26:24.200
说三处

01:26:24.900 --> 01:26:25.000
好

01:26:25.000 --> 01:26:26.000
那么同样的道理

01:26:26.000 --> 01:26:27.600
我们这个大马扶植一下啊

01:26:29.200 --> 01:26:30.200
这里就是三处

01:26:31.400 --> 01:26:32.200
原来节点是什么

01:26:32.200 --> 01:26:33.300
原来节点是漏的一

01:26:34.100 --> 01:26:34.700
新的节点呢

01:26:34.700 --> 01:26:35.500
新的节点是大

01:26:35.800 --> 01:26:37.600
这种情况是不是也不需要往后比较了

01:26:37.600 --> 01:26:38.300
怎么比较了

01:26:38.300 --> 01:26:39.400
比方说你以前

01:26:39.600 --> 01:26:41.100
以前这边后边还有节点啊

01:26:41.100 --> 01:26:41.900
这边后边还有

01:26:41.900 --> 01:26:42.400
还有

01:26:42.900 --> 01:26:44.900
但是你把这个东西都删了

01:26:45.000 --> 01:26:45.900
那后边怎么比较了

01:26:45.900 --> 01:26:47.300
他没有对应的东西比较了

01:26:47.300 --> 01:26:47.800
知道吧

01:26:48.100 --> 01:26:49.900
你要删这把整个这个地方都删了

01:26:50.100 --> 01:26:51.800
所以说他没办法往后比较了

01:26:52.700 --> 01:26:53.900
就有一个缺失的情况下

01:26:53.900 --> 01:26:55.400
他是没法继续往后比较的

01:26:56.500 --> 01:26:57.700
好这是这两个情况

01:26:59.510 --> 01:27:00.110
再来

01:27:01.410 --> 01:27:02.410
还有什么情况呢

01:27:03.210 --> 01:27:06.410
现在我们考虑了两个没有值的情况

01:27:06.410 --> 01:27:08.510
还有就是一个有值一个没有值的情况

01:27:08.510 --> 01:27:10.110
那么现在是不是都两个都有值的

01:27:10.410 --> 01:27:11.710
两个都有值的话

01:27:12.010 --> 01:27:12.910
他什么情况

01:27:13.410 --> 01:27:15.910
就是漏的1.6

01:27:17.310 --> 01:27:19.010
如果说不等于

01:27:21.790 --> 01:27:23.690
漏的2.6

01:27:24.990 --> 01:27:25.890
这是咋情况

01:27:26.790 --> 01:27:27.890
两个都有值

01:27:28.590 --> 01:27:29.290
但是呢

01:27:29.290 --> 01:27:30.390
他的值不一样

01:27:30.390 --> 01:27:31.390
这是什么情况呢

01:27:33.550 --> 01:27:34.350
是不是修改

01:27:34.450 --> 01:27:34.750
对吧

01:27:34.750 --> 01:27:35.050
于是呢

01:27:35.050 --> 01:27:35.950
我们加住一个

01:27:36.050 --> 01:27:38.650
其实这个体数真的不复杂啊修改

01:27:39.550 --> 01:27:40.850
原来的情况是漏的1

01:27:40.850 --> 01:27:42.150
变成了什么变成了漏的2

01:27:43.550 --> 01:27:43.750
是吧

01:27:43.750 --> 01:27:45.350
往这个数组里边加一项

01:27:45.350 --> 01:27:46.350
加一项变化

01:27:47.050 --> 01:27:47.950
好但是注意哦

01:27:47.950 --> 01:27:49.350
这个东西不能停止哦

01:27:49.450 --> 01:27:51.250
因为两个几点都有值

01:27:51.250 --> 01:27:52.750
你变了过后你不能停止

01:27:52.750 --> 01:27:53.550
比方说像这个啊

01:27:53.550 --> 01:27:54.850
B变成了K

01:27:55.050 --> 01:27:56.150
你不能停止比较

01:27:56.150 --> 01:27:57.150
你还得往B

01:27:57.150 --> 01:28:00.550
把B的左边和K的左边要进行进一步比较

01:28:00.550 --> 01:28:03.050
B的右边和K的右边进行比较

01:28:03.050 --> 01:28:04.350
还把D的左边

01:28:04.550 --> 01:28:06.650
和D这边D的左边进行比较

01:28:07.150 --> 01:28:07.650
比较啊

01:28:07.650 --> 01:28:09.850
他只要没有缺失你是不能停止的

01:28:11.150 --> 01:28:12.750
那么我们这里只是加了

01:28:12.750 --> 01:28:13.750
加入一个修改而已

01:28:13.750 --> 01:28:14.850
但是不能停

01:28:15.250 --> 01:28:15.750
知道吧

01:28:16.250 --> 01:28:17.150
那是相等的

01:28:17.150 --> 01:28:17.750
相等的话

01:28:17.750 --> 01:28:20.850
那就他至少目前没有没有变化

01:28:20.850 --> 01:28:21.350
但是呢

01:28:21.350 --> 01:28:22.350
他的左接电有没有变化

01:28:22.350 --> 01:28:23.650
不知道右接电有没有变化

01:28:23.650 --> 01:28:24.750
不知道也就说

01:28:25.950 --> 01:28:27.450
当全节点不相等

01:28:27.650 --> 01:28:29.250
我给他加入一个变化

01:28:29.750 --> 01:28:30.050
啊

01:28:31.150 --> 01:28:33.950
加入修改的变化

01:28:38.100 --> 01:28:38.500
啊

01:28:40.400 --> 01:28:41.900
不能停止

01:28:43.000 --> 01:28:43.700
不能停止

01:28:43.700 --> 01:28:45.000
我们出了这个判断之后

01:28:45.000 --> 01:28:46.100
无论他相不相等

01:28:46.700 --> 01:28:47.900
只要两个节点有值

01:28:48.300 --> 01:28:49.100
不管他相不相等

01:28:49.100 --> 01:28:50.100
我都不能停止

01:28:50.100 --> 01:28:51.500
还要去比较什么左边

01:28:51.500 --> 01:28:52.700
还要去比较右边

01:28:53.200 --> 01:28:53.700
对不对

01:28:53.700 --> 01:28:54.100
于是呢

01:28:54.100 --> 01:28:56.900
我要拿到什么拿到左边的不同

01:28:58.100 --> 01:28:58.900
是不是重新调用

01:28:58.900 --> 01:28:59.600
地规调用

01:28:59.900 --> 01:29:00.400
地规

01:29:01.300 --> 01:29:02.700
loader一點 left

01:29:03.100 --> 01:29:04.700
啊loader二点 left

01:29:06.500 --> 01:29:06.900
是吧

01:29:08.400 --> 01:29:11.100
左数的差异

01:29:11.800 --> 01:29:13.300
还要拿到右数的差异

01:29:14.200 --> 01:29:14.700
地规

01:29:15.000 --> 01:29:16.100
loader一点

01:29:20.100 --> 01:29:20.900
啊对了啊

01:29:20.900 --> 01:29:22.600
loader一点 right

01:29:23.100 --> 01:29:24.500
loader二点 right

01:29:25.000 --> 01:29:26.500
这是右数的差异

01:29:28.630 --> 01:29:31.330
右数的差异

01:29:32.030 --> 01:29:34.030
好左数的差异右数的差异

01:29:34.230 --> 01:29:35.130
这是那个数组

01:29:35.130 --> 01:29:35.930
这也是一个数组

01:29:35.930 --> 01:29:37.530
因为这个函数反而就是个数组

01:29:37.530 --> 01:29:38.130
对不对

01:29:38.230 --> 01:29:39.030
好这是一个数组

01:29:39.030 --> 01:29:39.830
这是一个数组

01:29:40.330 --> 01:29:40.830
然后呢

01:29:40.830 --> 01:29:42.130
我要把这个数组的所有东西

01:29:42.130 --> 01:29:43.230
讲到这个这个里边

01:29:44.130 --> 01:29:44.730
对不对

01:29:44.830 --> 01:29:45.530
然后呢

01:29:45.630 --> 01:29:47.130
还要把这个这个数组的所有东西

01:29:47.130 --> 01:29:48.130
讲到这个这个里边

01:29:48.130 --> 01:29:49.430
所以我们可以用concuit

01:29:50.230 --> 01:29:51.830
without concuit

01:29:52.030 --> 01:29:53.130
连接数组吧

01:29:53.430 --> 01:29:54.830
连接什么连接left

01:29:55.830 --> 01:29:56.230
def

01:29:58.130 --> 01:29:59.130
连接concuit

01:29:59.130 --> 01:30:00.630
连接右边的差异

01:30:01.730 --> 01:30:02.330
连接

01:30:02.430 --> 01:30:03.830
那么反复了一个新数组

01:30:04.830 --> 01:30:05.230
return

01:30:06.230 --> 01:30:06.730
对不对

01:30:06.730 --> 01:30:07.630
合并差异

01:30:08.330 --> 01:30:09.030
合并

01:30:09.430 --> 01:30:09.930
差异

01:30:10.730 --> 01:30:13.130
当然如果说你学你学过es6的话啊

01:30:13.230 --> 01:30:14.930
es6是每个学生都必须要学的啊

01:30:14.930 --> 01:30:16.730
你现在没学以后也不能跑掉的

01:30:17.330 --> 01:30:18.630
非常非常基础的啊

01:30:18.730 --> 01:30:19.930
那你可以这样子学啊

01:30:19.930 --> 01:30:20.630
反复的什么

01:30:20.630 --> 01:30:22.330
反复的without

01:30:22.930 --> 01:30:24.130
然后呢nef stiff

01:30:24.530 --> 01:30:26.130
然后呢press stiff

01:30:26.330 --> 01:30:27.430
这样子学习来个家

01:30:27.830 --> 01:30:28.930
轻松易懂啊

01:30:28.930 --> 01:30:30.230
把所有的数组全部展开

01:30:30.330 --> 01:30:31.430
合并到一起发挥

01:30:35.190 --> 01:30:36.490
啊当然你还可以这样写啊

01:30:36.490 --> 01:30:37.890
还可以写啊

01:30:38.390 --> 01:30:41.390
用es6的话还可以写without push

01:30:42.590 --> 01:30:43.490
nef stiff

01:30:45.390 --> 01:30:47.690
然后呢without push

01:30:48.390 --> 01:30:49.190
right stiff

01:30:49.490 --> 01:30:49.790
对吧

01:30:49.790 --> 01:30:51.090
比展开运算的都可以啊

01:30:51.090 --> 01:30:52.790
最后把result返回啊都行啊

01:30:52.790 --> 01:30:53.790
不管用啥写法

01:30:53.790 --> 01:30:54.290
总归呢

01:30:54.290 --> 01:30:54.990
你说把这两个

01:30:54.990 --> 01:30:55.890
不把这些两个

01:30:55.990 --> 01:30:57.690
这些不同的数组全部合并在一起

01:30:57.890 --> 01:30:58.990
这全都是差异对吧

01:30:58.990 --> 01:30:59.490
反复

01:30:59.790 --> 01:31:00.390
就完事了

01:31:00.790 --> 01:31:02.590
这就是整个差异算了

01:31:02.590 --> 01:31:03.890
啊我这个以后呢

01:31:03.890 --> 01:31:04.890
你们学到without

01:31:04.890 --> 01:31:05.690
学习来个车

01:31:06.290 --> 01:31:08.690
当然了肯定他那个地方要复杂多

01:31:09.190 --> 01:31:10.390
他考虑的情况更多

01:31:10.790 --> 01:31:11.290
因为他不

01:31:11.290 --> 01:31:12.690
他还不仅仅是二杀数

01:31:13.490 --> 01:31:14.590
他是个普通的数

01:31:14.990 --> 01:31:16.790
那么这里边情况很多的啊

01:31:16.790 --> 01:31:17.390
考虑东西很多

01:31:17.390 --> 01:31:18.690
特别像现在without3

01:31:18.890 --> 01:31:20.190
那这里比情况又多了

01:31:20.490 --> 01:31:21.690
因为他做了很多的优化

01:31:21.690 --> 01:31:22.590
那就不一样

01:31:22.590 --> 01:31:24.190
但是那基本的思维呢

01:31:24.190 --> 01:31:25.090
就是这样的思维

01:31:25.090 --> 01:31:26.490
我要得到这个差异结果

01:31:26.690 --> 01:31:27.790
最后让我们看一下吧

01:31:29.390 --> 01:31:30.390
数据有三下

01:31:30.990 --> 01:31:32.390
修改了修改了什么呢

01:31:32.590 --> 01:31:33.990
他把b修改成的k

01:31:34.690 --> 01:31:36.790
删除他把g变成了貓

01:31:37.390 --> 01:31:39.190
新增他把他以前没有

01:31:39.190 --> 01:31:40.090
现在多了个t

01:31:41.290 --> 01:31:41.690
有意思吧

01:31:41.690 --> 01:31:43.990
这样子我是不是拿到两个数的差异点了

01:31:44.290 --> 01:31:44.890
就ok了

01:31:48.940 --> 01:31:49.340
好了

01:31:50.440 --> 01:31:51.840
这就是今天的内容

01:31:52.440 --> 01:31:52.740
哎行吧

01:31:52.740 --> 01:31:55.340
今天的内容是不是比昨天要稍微好一点啊

01:31:55.340 --> 01:31:57.040
稍微有意思点

01:31:57.440 --> 01:31:58.640
对不对啊

01:31:58.640 --> 01:31:59.740
不管是什么情况吧

01:31:59.740 --> 01:32:01.640
反正就是听源弹弹的思维

01:32:02.640 --> 01:32:05.240
啊这五如果今天都是对象

01:32:05.540 --> 01:32:09.340
加啊大家的模板支持通用类型的可以啊

01:32:09.540 --> 01:32:10.140
可以啊

01:32:10.640 --> 01:32:13.340
呃只是呢对象这一块呢

01:32:13.540 --> 01:32:14.340
对象这一块呢

01:32:14.340 --> 01:32:16.140
就是今天晚上的写的东西啊

01:32:16.340 --> 01:32:17.940
跟你是不是对象使用没啥关系

01:32:18.540 --> 01:32:19.440
先没啥关系的

01:32:20.040 --> 01:32:21.740
就是在这一块有关系

01:32:22.640 --> 01:32:23.840
这个aplot

01:32:24.740 --> 01:32:25.840
就这个aplot

01:32:25.840 --> 01:32:26.240
这

01:32:27.940 --> 01:32:29.340
我这里是按个制服创来处理

01:32:29.540 --> 01:32:31.040
我默认他是一个

01:32:31.740 --> 01:32:33.040
默认他是一个什么呢

01:32:33.040 --> 01:32:35.640
是一个每个地方是一个制服啊

01:32:35.840 --> 01:32:36.340
但是呢

01:32:36.340 --> 01:32:37.740
因为我不想把他搞复杂了

01:32:37.740 --> 01:32:38.240
知道吧

01:32:38.440 --> 01:32:39.840
因为很多人连这个东西

01:32:40.040 --> 01:32:40.440
呃

01:32:40.840 --> 01:32:41.940
听起来都还是比较吃力

01:32:41.940 --> 01:32:42.740
说慢慢来嘛

01:32:42.840 --> 01:32:44.040
翻的一口一口吃

01:32:44.140 --> 01:32:45.040
也不能说

01:32:45.340 --> 01:32:46.340
我都不会走路

01:32:46.340 --> 01:32:47.540
也要让我去白面挂栏

01:32:47.540 --> 01:32:48.740
那这不不现实啊

01:32:48.740 --> 01:32:49.540
也一步步来

01:32:50.040 --> 01:32:51.140
正常正常的情况呢

01:32:51.140 --> 01:32:52.540
这里应该传一个数数五进来

01:32:53.740 --> 01:32:55.540
比方说你每个点点是个对象嘛

01:32:55.840 --> 01:32:57.440
那你给我传这样的东西进来

01:32:58.440 --> 01:32:59.640
get to

01:33:00.340 --> 01:33:01.640
他应该传的是一个数组

01:33:01.640 --> 01:33:02.840
我的前续便利

01:33:03.340 --> 01:33:04.440
第一个对象啊

01:33:04.440 --> 01:33:05.840
就啥啥啥对象

01:33:05.940 --> 01:33:07.840
第二个前续变论的结果是个对象

01:33:07.840 --> 01:33:09.540
第三个前续便利

01:33:09.540 --> 01:33:09.940
对吧

01:33:10.240 --> 01:33:11.140
等于是这个东西

01:33:11.640 --> 01:33:12.740
他得传一个数组

01:33:13.040 --> 01:33:14.240
但是他说数组呢

01:33:14.340 --> 01:33:14.840
看上去呢

01:33:14.840 --> 01:33:15.940
一次不是很好看

01:33:16.040 --> 01:33:17.340
不是很好理解

01:33:17.540 --> 01:33:17.840
啊

01:33:17.840 --> 01:33:19.540
什么也没必要啊

01:33:19.540 --> 01:33:21.440
我们今天晚上训练这个思维就行了

01:33:22.040 --> 01:33:24.140
其实他跟他里面保存啥东西是没关系的

01:33:24.340 --> 01:33:25.440
是没有任何关系的

01:33:25.840 --> 01:33:26.540
你看这个地方

01:33:26.540 --> 01:33:28.340
比较的时候我当他是知误川了吗

01:33:28.340 --> 01:33:29.340
别当他是知误川

01:33:29.740 --> 01:33:30.740
我只是比较原理了

01:33:30.740 --> 01:33:31.840
外面管他是啥都可以

01:33:32.540 --> 01:33:33.740
管他是啥都无所谓

01:33:38.650 --> 01:33:41.050
get是要比这个c和java那样子灵活的多

01:33:41.050 --> 01:33:41.850
你说的是犯行

01:33:41.850 --> 01:33:42.250
对吧

01:33:42.350 --> 01:33:44.450
那个java的犯行家就是很幽默的

01:33:44.450 --> 01:33:46.550
大家都知道犯行就搞笑的

01:33:49.050 --> 01:33:49.850
c sharp

01:33:50.550 --> 01:33:51.450
倒是有犯行

01:33:51.650 --> 01:33:52.750
那个倒是真犯行

01:33:53.050 --> 01:33:53.650
我犯行

01:33:53.650 --> 01:33:55.450
但是get是完全没有必要

01:33:55.450 --> 01:33:56.950
玩乐get是弱烈型语言

01:33:56.950 --> 01:33:57.850
他不需要犯行

01:33:58.850 --> 01:34:00.050
他随便怎么传都可以

01:34:01.450 --> 01:34:02.650
get是弱烈型啊

01:34:03.050 --> 01:34:04.850
犯行是因为他们是强烈型

01:34:05.450 --> 01:34:06.050
他们是强烈型

01:34:06.050 --> 01:34:07.650
他没办法搞出来的

01:34:07.650 --> 01:34:08.850
搞出来的烈型适配

01:34:09.350 --> 01:34:10.850
get是完全不需要烈型适配的

01:34:10.850 --> 01:34:11.650
灵活的多

01:34:12.650 --> 01:34:13.050
好了

01:34:14.050 --> 01:34:15.050
今天晚上就到这了

01:34:16.050 --> 01:34:16.850
慢慢就消化吧

01:34:17.250 --> 01:34:18.250
好了慢慢就消化

01:34:19.250 --> 01:34:21.650
明天晚上的题就要少很多了

01:34:22.050 --> 01:34:22.850
当然了

01:34:23.650 --> 01:34:24.450
也有意识了

01:34:24.850 --> 01:34:25.650
也更加有意识了

01:34:26.050 --> 01:34:27.250
更加贴合实际了

01:34:28.450 --> 01:34:30.050
当然他难度也相应的增加了

01:34:32.560 --> 01:34:33.760
好这就是今天晚上的东西

01:34:33.760 --> 01:34:35.160
那今天那个虚论师

01:34:35.160 --> 01:34:36.960
虚论师也来不了了

01:34:36.960 --> 01:34:37.760
所以说

01:34:38.260 --> 01:34:39.160
我们就早睡早起

01:34:39.160 --> 01:34:39.760
好吧

01:34:39.760 --> 01:34:40.560
早点休息吧

01:34:40.760 --> 01:34:41.960
那就拜拜

01:34:44.070 --> 01:34:45.670
等一下把这个代码给发给大家啊

