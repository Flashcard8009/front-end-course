WEBVTT

00:00.000 --> 00:04.000
我们要今天的晚上要用到一个新的知识啊 叫做带

00:04.000 --> 00:08.820
带的是一种数据结构 这种数据有了非常简单

00:08.820 --> 00:10.820
它就是一块空间

00:10.820 --> 00:13.820
我们可以往这个空间里边放数据

00:13.820 --> 00:15.820
怎么放呢

00:15.820 --> 00:18.820
你看啊 我们的数据是这样子放进来的

00:18.820 --> 00:20.820
从外边往里边放

00:20.820 --> 00:23.820
放进来的数据呢 就在带的顶部

00:23.820 --> 00:25.820
我们把它这个过程的叫做入带

00:25.820 --> 00:28.820
或者叫做压带 它的单词叫push

00:28.820 --> 00:30.820
如果说我们要拿数据的话

00:30.820 --> 00:32.820
我们不能拿下边的数据

00:32.820 --> 00:34.820
我们只能拿顶端的数据

00:34.820 --> 00:36.820
于是呢 我们把个数据拿出来

00:36.820 --> 00:38.820
我们把它叫做出带

00:38.820 --> 00:40.820
或者叫弹带 都一个意思

00:40.820 --> 00:42.820
就这么一种数据结构

00:42.820 --> 00:44.820
我们今天晚上呢 就会用到这个

00:44.820 --> 00:46.820
带的这么一种数据结构

00:46.820 --> 00:48.820
那么这种数据结构加发script里边有没有呢

00:48.820 --> 00:50.820
没有 还没有这种结构

00:50.820 --> 00:52.820
加发script里边有的是什么呢

00:52.820 --> 00:54.820
有的是数据

00:54.820 --> 00:56.820
但是呢 我们可以利用数据呢

00:56.820 --> 00:58.820
用类似的结构 怎么来做

00:58.820 --> 01:00.820
给大家看一下 非常简单啊

01:00.820 --> 01:02.820
比方说我们这里有个数据

01:02.820 --> 01:04.820
它虽然不是一个带

01:04.820 --> 01:06.820
4 3 2

01:06.820 --> 01:08.820
那么 但是呢 我们可以把它当成一个带

01:08.820 --> 01:10.820
这个带里边有三个数据

01:10.820 --> 01:12.820
这个是在带的顶部

01:12.820 --> 01:14.820
这个是在第二个位置

01:14.820 --> 01:16.820
这个是在带的顶部

01:16.820 --> 01:18.820
我们可以这样子去认为

01:18.820 --> 01:20.820
于是呢 我们可以怎么去操作呢

01:20.820 --> 01:22.820
比方说我们要入带

01:22.820 --> 01:24.820
我们是不是可以用push

01:24.820 --> 01:26.820
我们要出带 怎么来出带呢

01:26.820 --> 01:28.820
push

01:28.820 --> 01:30.820
它是不是有相应的函数

01:30.820 --> 01:32.820
出带 出带的是结构是怎么来的

01:32.820 --> 01:34.820
出带的结构是1 就把这个东西出带的

01:34.820 --> 01:36.820
然后我们再看一下这个数组

01:36.820 --> 01:38.820
AR 是不是带里面只有4 3 2

01:38.820 --> 01:40.820
对吧 它虽然是横向的

01:40.820 --> 01:42.820
你想象成数向的

01:42.820 --> 01:44.820
交换一下方向就完事了

01:44.820 --> 01:46.820
这是底部 这是顶部

01:46.820 --> 01:48.820
如果说我要得到带顶呢

01:48.820 --> 01:50.820
是不是可以通过这种方式

01:50.820 --> 01:52.820
AR-1

01:52.820 --> 01:54.820
可以得到带的顶部

01:54.820 --> 01:56.820
所以得到带的顶部是2

01:56.820 --> 01:58.820
对吧 虽然说GS数组

01:58.820 --> 02:00.820
它并不是一个带的结构

02:00.820 --> 02:02.820
但是我们可以把它当成一个带

02:02.820 --> 02:04.820
来进行使用

02:04.820 --> 02:06.820
为了方便我们后边的使用

02:06.820 --> 02:08.820
我们这里可以把它去做一个封装

02:08.820 --> 02:10.820
我们先来封装一下

02:10.820 --> 02:12.820
今天晚上我们要把这道题

02:12.820 --> 02:17.100
叫做动态表达式

02:17.100 --> 02:19.100
接下来我们写上这么一个构造函数

02:19.100 --> 02:21.100
叫stack 就带的意思

02:21.100 --> 02:23.100
这个构造函数里面

02:23.100 --> 02:24.100
就是希望

02:24.100 --> 02:25.100
希望有了这个动态函数过后

02:25.100 --> 02:27.100
我们就可以通过它来创建一个站

02:27.100 --> 02:29.100
比方说假设我们的站码写好了

02:29.100 --> 02:31.100
我们希望怎么样呢

02:31.100 --> 02:33.100
我们希望有这么一个站

02:33.100 --> 02:34.100
stack

02:34.100 --> 02:36.100
我们可以通过一个new一个stack

02:36.100 --> 02:37.100
创建一个站

02:37.100 --> 02:38.100
然后我们可以通过

02:38.100 --> 02:39.100
这个站里面的函数

02:39.100 --> 02:40.100
poosh

02:40.100 --> 02:41.100
往站里面加入一个

02:41.100 --> 02:43.100
于是这站里面就变成什么了

02:43.100 --> 02:45.100
就变成了一个1

02:45.100 --> 02:47.100
如果说我再加入一个

02:47.100 --> 02:49.100
poosh2

02:49.100 --> 02:51.100
那么这个站里面变成了

02:52.100 --> 02:54.100
如果说我可以通过

02:54.100 --> 02:56.730
poosh

02:56.730 --> 02:57.730
那么就

02:57.730 --> 02:58.730
站里面变成了1

02:58.730 --> 03:00.730
就弹出顶部

03:00.730 --> 03:01.730
然后我们站来

03:01.730 --> 03:02.730
stack

03:02.730 --> 03:03.730
这里比方说3

03:03.730 --> 03:05.730
那么站里面变成了1

03:05.730 --> 03:06.730
3

03:06.730 --> 03:08.730
就非常简单

03:08.730 --> 03:09.730
然后我们可以通过这个

03:09.730 --> 03:10.730
getstop

03:10.730 --> 03:11.730
这样有这么一个函数

03:11.730 --> 03:12.730
那么就可以得到

03:12.730 --> 03:14.730
这个站的顶部的数据

03:14.730 --> 03:15.730
就是3

03:15.730 --> 03:17.730
我们就希望有这么一个

03:17.730 --> 03:18.730
构造函数

03:18.730 --> 03:19.730
可以帮我们做这件事

03:19.730 --> 03:20.730
其实它用数组

03:20.730 --> 03:21.730
也完全可以说

03:21.730 --> 03:22.730
但是我们把它稍微的

03:22.730 --> 03:23.730
封装一下

03:23.730 --> 03:24.730
便于后续的操作

03:24.730 --> 03:26.730
那么这个东西怎么来做呢

03:26.730 --> 03:27.730
你们用学过的get

03:27.730 --> 03:28.730
应该很容易实现

03:28.730 --> 03:30.730
我们就在这个

03:30.730 --> 03:31.730
构造函数的内部

03:31.730 --> 03:33.730
去维护这么一个数组

03:33.730 --> 03:34.730
我们给它一个下滑线

03:34.730 --> 03:35.730
这是一种秘密规范

03:35.730 --> 03:37.730
表示这里边是我内部的东西

03:37.730 --> 03:39.730
你外面的人

03:39.730 --> 03:40.730
不要去使用

03:40.730 --> 03:42.730
你给它维护这么一个数组

03:42.730 --> 03:44.730
其实就是里边

03:44.730 --> 03:45.730
你就是利用这个数组

03:45.730 --> 03:46.730
来做这件事

03:46.730 --> 03:47.730
我们给它写上一些

03:47.730 --> 03:48.730
原型方法

03:48.730 --> 03:49.730
stack

03:49.730 --> 03:50.730
如果说同学

03:50.730 --> 03:52.730
你还没有

03:52.730 --> 03:54.730
还没有接触过构造函数

03:54.730 --> 03:55.730
还没有接触过

03:55.730 --> 03:56.730
原型这个东西的话

03:56.730 --> 03:58.730
那你好好把基础看一下

03:58.730 --> 03:59.730
这些东西都是有免费的

03:59.730 --> 04:00.730
基础课程的

04:00.730 --> 04:01.730
整个的get课程

04:01.730 --> 04:03.730
你们好好去看一下

04:03.730 --> 04:04.730
这些都是get课基础

04:04.730 --> 04:06.730
首先我们要学一门语言

04:06.730 --> 04:07.730
首先得学会它的

04:07.730 --> 04:08.730
语法过一择

04:08.730 --> 04:10.730
学会它怎么去说话

04:10.730 --> 04:11.730
先把话说清楚

04:11.730 --> 04:12.730
然后再来说

04:12.730 --> 04:13.730
我怎么把话说好

04:13.730 --> 04:14.730
怎么来用话

04:14.730 --> 04:15.730
怎么能用我的语言

04:15.730 --> 04:16.730
去解决一些问题

04:16.730 --> 04:18.730
首先要学好这个语言本身

04:18.730 --> 04:19.730
学语言本身其实并不难

04:19.730 --> 04:20.730
像学接课的话

04:20.730 --> 04:22.730
一个月就可以搞定了

04:22.730 --> 04:23.730
好

04:23.730 --> 04:24.730
我们把这个propertype里边

04:24.730 --> 04:25.730
加入一些函数

04:25.730 --> 04:26.730
这里边不是要提供

04:26.730 --> 04:27.730
三个函数吗

04:27.730 --> 04:28.730
一个是poosh

04:28.730 --> 04:29.730
一个是pop

04:29.730 --> 04:30.730
一个是skidpop

04:30.730 --> 04:31.730
首先是poosh

04:31.730 --> 04:32.730
我们该加成一个函数

04:32.730 --> 04:34.730
这个函数要接收一个参数

04:34.730 --> 04:36.730
我就给它一个参数吧

04:36.730 --> 04:37.730
随便一个东西

04:37.730 --> 04:38.730
data

04:38.730 --> 04:39.730
我要说的事情是什么事情

04:39.730 --> 04:40.730
我就把data加到

04:40.730 --> 04:43.100
这个数组里边去

04:43.100 --> 04:44.100
data

04:44.100 --> 04:45.100
poosh

04:45.100 --> 04:46.100
就加到数组里边去

04:46.100 --> 04:47.100
非常简单

04:47.100 --> 04:48.100
那么这样子

04:48.100 --> 04:49.100
我一调问这个方法

04:49.100 --> 04:50.100
poosh

04:50.100 --> 04:51.100
里边的数组里边

04:51.100 --> 04:53.100
多了一个e

04:53.100 --> 04:54.100
我就用

04:54.100 --> 04:56.100
内部围护一个数组

04:56.100 --> 04:57.100
然后向外

04:57.100 --> 04:58.100
暴露一个方法

04:58.100 --> 05:00.100
我们把它封装一下

05:00.100 --> 05:01.100
stack

05:01.100 --> 05:02.100
当然它还有一些方法

05:02.100 --> 05:03.100
poosh

05:03.100 --> 05:05.100
分析

05:05.100 --> 05:06.100
这什么意思

05:06.100 --> 05:07.100
它不需要参数

05:07.100 --> 05:09.100
它需要把占顶的元素

05:09.100 --> 05:10.100
移出来

05:10.100 --> 05:11.100
那怎么做呢

05:11.100 --> 05:12.100
其实也是一样的

05:12.100 --> 05:13.100
我们可以调用

05:13.100 --> 05:15.100
里边的数组的方法

05:15.100 --> 05:16.100
this

05:16.100 --> 05:17.100
data

05:17.100 --> 05:18.100
poosh

05:18.100 --> 05:19.100
是一样的

05:20.100 --> 05:23.540
然后还有一个方法叫get top

05:23.540 --> 05:24.540
可说太

05:24.540 --> 05:25.540
get top

05:25.540 --> 05:27.540
就得到占顶的元素

05:27.540 --> 05:29.540
就占顶有啥

05:29.540 --> 05:30.540
这个玩意怎么弄呢

05:30.540 --> 05:31.540
直接返回

05:31.540 --> 05:33.540
当前这个数组

05:33.540 --> 05:35.540
里边的最后一下

05:35.540 --> 05:36.540
so this

05:36.540 --> 05:37.540
gettas

05:39.540 --> 05:40.540
这些都是基础

05:40.540 --> 05:42.540
基础的不能再基础的东西

05:42.540 --> 05:43.540
这些东西

05:43.540 --> 05:45.540
首先要把这个东西搞定

05:45.540 --> 05:46.540
好 那么就玩算了

05:46.540 --> 05:48.540
接着我们来看一下吧

05:48.540 --> 05:50.540
到底行不行

05:50.540 --> 05:52.540
好 我们这里边

05:52.540 --> 05:53.540
打上一个断点

05:53.540 --> 05:55.540
我们现在运行它

05:59.540 --> 06:00.540
好

06:00.540 --> 06:01.540
我们现在目前

06:01.540 --> 06:02.540
已经创建好了这么一个东西

06:02.540 --> 06:03.540
你看

06:03.540 --> 06:04.540
它里边是一个数组

06:04.540 --> 06:05.540
gettas

06:05.540 --> 06:06.540
里边是个空数组

06:06.540 --> 06:07.540
好 接下来

06:07.540 --> 06:08.540
我们

06:08.540 --> 06:09.540
一步一步运行

06:09.540 --> 06:10.540
运行到第一步

06:10.540 --> 06:11.540
运行这一步的时候

06:11.540 --> 06:12.540
是不是运行这个函数

06:12.540 --> 06:13.540
这个函数里边是往数组

06:13.540 --> 06:14.540
里边加了一下

06:14.540 --> 06:15.540
对吧

06:15.540 --> 06:17.540
你看这个stack里边

06:17.540 --> 06:18.540
里边的维护的数组里边

06:18.540 --> 06:19.540
就多了一个e

06:19.540 --> 06:20.540
对不对

06:20.540 --> 06:21.540
然后呢

06:21.540 --> 06:22.540
我们再运行下一句话

06:22.540 --> 06:23.540
运行完下一句话过后

06:23.540 --> 06:24.540
你看stack里边

06:24.540 --> 06:26.540
所以多了一个e2

06:26.540 --> 06:28.540
我们其实可以在这里

06:28.540 --> 06:29.540
在这里呢

06:29.540 --> 06:33.540
把这个东西添加到监视

06:33.540 --> 06:34.540
可以看到监视结果

06:34.540 --> 06:36.540
你看现在是不是e2了

06:36.540 --> 06:37.540
现在我们接下来pub

06:37.540 --> 06:38.540
弹出

06:38.540 --> 06:39.540
弹出的话

06:39.540 --> 06:40.540
是不是弹出最后一下

06:40.540 --> 06:42.540
最后一项出战

06:42.540 --> 06:43.540
好 下一步

06:43.540 --> 06:44.540
你看

06:44.540 --> 06:45.540
是不是最后一项出战了

06:45.540 --> 06:46.540
只有一个e

06:46.540 --> 06:47.540
看来我们再pub

06:47.540 --> 06:49.540
往里边压一个东西

06:49.540 --> 06:50.540
压占

06:50.540 --> 06:51.540
加入一个3

06:51.540 --> 06:52.540
所以加到里边去了

06:52.540 --> 06:53.540
3

06:53.540 --> 06:54.540
最后让我们get top

06:54.540 --> 06:56.540
得到它顶部的值

06:56.540 --> 06:57.540
得到它顶部的值

06:57.540 --> 06:58.540
我这里没有得到

06:58.540 --> 07:00.540
用个变量吧

07:00.540 --> 07:02.540
得到它顶部的值

07:02.540 --> 07:04.540
我们就下面出出

07:04.540 --> 07:05.540
好

07:05.540 --> 07:06.540
运行

07:06.540 --> 07:08.540
我之前改动代码

07:08.540 --> 07:09.540
重新来

07:09.540 --> 07:14.330
我端点打到这

07:14.330 --> 07:15.330
好 我们运行

07:15.330 --> 07:16.330
你看这个r的值

07:16.330 --> 07:17.330
是不是3

07:17.330 --> 07:18.330
就得到占顶元素

07:18.330 --> 07:19.330
对吧

07:19.330 --> 07:20.330
非常简单

07:20.330 --> 07:21.330
就写上这么一个

07:21.330 --> 07:22.330
构造函数

07:22.330 --> 07:23.330
主要是来封装一下

07:23.330 --> 07:24.330
我们占的操作

07:24.330 --> 07:25.330
这是入占

07:25.330 --> 07:26.330
这是出占

07:26.330 --> 07:28.330
这是得到占顶元素

07:28.330 --> 07:30.330
这一块没问题吧

07:30.330 --> 07:31.330
这一块没问题吧

07:31.330 --> 07:32.330
没问题的话

07:32.330 --> 07:33.330
就可以

07:33.330 --> 07:37.790
有问题咋出问题

07:37.790 --> 07:39.790
好 这是非常简单一个步骤

07:39.790 --> 07:40.790
我们先准备好

07:40.790 --> 07:41.790
因为以后

07:41.790 --> 07:42.790
我们可能会用到

07:42.790 --> 07:43.790
因为今天晚上

07:43.790 --> 07:44.790
我们肯定会用到

07:44.790 --> 07:45.790
这个占的操作

07:45.790 --> 07:48.170
好 接下来继续

07:48.170 --> 07:49.170
下来

07:49.170 --> 07:50.170
我给大家留一个思考题

07:50.170 --> 07:51.170
这个思考题

07:51.170 --> 07:52.170
你可能

07:52.170 --> 07:53.170
如果说你

07:53.170 --> 07:54.170
目前刚刚开始

07:54.170 --> 07:55.170
结束程序的话

07:55.170 --> 07:56.170
这个思考题

07:56.170 --> 07:57.170
可能现在你做起来

07:57.170 --> 07:58.170
比较吃力

07:58.170 --> 07:59.170
将来你可以尝试

07:59.170 --> 08:00.170
做一做

08:00.170 --> 08:01.170
就是不用数组

08:01.170 --> 08:02.170
组合来实现一个占

08:02.170 --> 08:03.170
你可以下期那个

08:03.170 --> 08:04.170
好好去想一想

08:04.170 --> 08:06.170
不用数怎么去实现个占

08:06.170 --> 08:07.170
我这里用了数组

08:09.170 --> 08:10.170
好 这是关于

08:10.170 --> 08:11.170
占的这么一个数据结构

08:11.170 --> 08:12.170
非常的简单

08:12.170 --> 08:13.170
好 现在我们回到

08:13.170 --> 08:14.170
这道题了

08:16.170 --> 08:17.170
要解决这道问题

08:17.170 --> 08:18.170
可不简单

08:18.170 --> 08:19.170
很多的东西

08:19.170 --> 08:21.170
需要去处理

08:21.170 --> 08:22.170
因为我们拿到手的

08:22.170 --> 08:24.170
只有一个制服串

08:24.170 --> 08:25.170
它就是一个普通的制服串

08:25.170 --> 08:27.170
它只有很多制服组成

08:27.170 --> 08:29.170
为了编语我们

08:29.170 --> 08:30.170
今天晚上的书写

08:30.170 --> 08:31.170
其实我们要把

08:31.170 --> 08:32.170
这道题写完

08:32.170 --> 08:33.170
算可不简单的

08:33.170 --> 08:34.170
还有很多事情要做

08:34.170 --> 08:35.170
但是因为我们

08:35.170 --> 08:37.170
今天晚上的时间有限

08:37.170 --> 08:38.170
我也不想把它

08:38.170 --> 08:39.170
搞得太复杂了

08:39.170 --> 08:40.170
搞成你们完了

08:40.170 --> 08:41.170
睡不着觉

08:41.170 --> 08:42.170
所以说我把它

08:42.170 --> 08:43.170
做了一些少量的简化

08:43.170 --> 08:44.170
首先 第一个简化

08:44.170 --> 08:46.170
我们要假设

08:46.170 --> 08:47.170
制服串S里面

08:47.170 --> 08:49.170
至少包含一个运算服

08:49.170 --> 08:51.170
它不存在这种情况

08:51.170 --> 08:52.170
它不存在说

08:52.170 --> 08:53.170
你这个制服串

08:53.170 --> 08:54.170
就是一个S

08:54.170 --> 08:55.170
它不存在这种情况

08:55.170 --> 08:56.170
它至少得有一个

08:56.170 --> 08:57.170
运算服

08:57.170 --> 08:59.170
我先做这么一个假设

08:59.170 --> 09:01.170
这是第一个

09:01.170 --> 09:04.170
第二个就是说

09:04.170 --> 09:05.170
我这个制服串里面的

09:05.170 --> 09:06.170
操作数

09:06.170 --> 09:07.170
什么叫操作数

09:07.170 --> 09:08.170
我们知道一个表达

09:08.170 --> 09:09.170
是它是有操作数

09:09.170 --> 09:11.170
和操作服组成的

09:11.170 --> 09:12.170
什么叫操作服

09:12.170 --> 09:13.170
就在玩

09:13.170 --> 09:14.170
这就是操作服

09:14.170 --> 09:15.170
这一符号就操作服

09:15.170 --> 09:16.170
什么叫操作数

09:16.170 --> 09:18.170
就是符号作用的

09:18.170 --> 09:20.170
东西就是操作数

09:20.170 --> 09:22.170
你看

09:22.170 --> 09:23.170
不会用到

09:23.170 --> 09:24.170
ES6的很多东西

09:24.170 --> 09:25.170
不会用的

09:25.170 --> 09:26.170
我尽量都不会用

09:26.170 --> 09:29.060
ES6的

09:29.060 --> 09:30.060
你学过ES6过后

09:30.060 --> 09:31.060
你要把ES5

09:31.060 --> 09:32.060
或者是ES3

09:32.060 --> 09:33.060
转换成ES6

09:33.060 --> 09:34.060
其实很简单

09:36.060 --> 09:37.060
我们这里边

09:37.060 --> 09:39.060
假设操作数

09:39.060 --> 09:41.060
都是数字字面量

09:41.060 --> 09:42.060
就是它不存在

09:42.060 --> 09:43.060
这种情况

09:43.060 --> 09:44.060
它不存在

09:44.060 --> 09:45.060
这里边是一个面量

09:45.060 --> 09:46.060
也不存在说

09:46.060 --> 09:48.060
这里边要用一个函数

09:48.060 --> 09:50.060
它不存在这种情况

09:50.060 --> 09:51.060
这种情况不考虑

09:51.060 --> 09:53.060
要考虑这种情况的话

09:53.060 --> 09:55.060
它问题就更加复杂了

09:55.060 --> 09:57.060
你要设计到抽象与法术了

09:57.060 --> 09:58.060
这个玩意就不用去考虑了

09:58.060 --> 09:59.060
我们就考虑

09:59.060 --> 10:02.060
它是一个普通的字面量

10:02.060 --> 10:03.060
就只有数字

10:03.060 --> 10:04.060
但是这个数字

10:04.060 --> 10:05.060
你要考虑一点

10:05.060 --> 10:06.060
它有可能是小数

10:07.060 --> 10:08.060
最终你要完成这个蛋

10:08.060 --> 10:09.060
所以我们最重要

10:09.060 --> 10:10.060
实现的是什么呢

10:10.060 --> 10:12.060
是一个函数

10:12.060 --> 10:13.060
我们最重要

10:13.060 --> 10:14.060
实现这个玩意

10:14.060 --> 10:15.060
你给我一个字不串

10:15.060 --> 10:17.060
你给我把它字不串的结果

10:17.060 --> 10:18.060
运算出来

10:18.060 --> 10:19.060
这是一个字不串

10:19.060 --> 10:20.060
你给我

10:20.060 --> 10:21.060
返回的是什么呢

10:21.060 --> 10:23.060
返回的是一个Number

10:23.060 --> 10:26.690
运算结果

10:26.690 --> 10:32.150
这是运算表达式

10:32.150 --> 10:36.150
运算一个表达式

10:36.150 --> 10:38.150
返回结果

10:38.150 --> 10:39.150
我们要实现这个函数

10:39.150 --> 10:40.150
但是这个函数

10:40.150 --> 10:41.150
你如果说直接写的话

10:41.150 --> 10:42.150
你要蒙的

10:42.150 --> 10:43.150
这里边有很多事情

10:43.150 --> 10:44.150
你没有解决

10:44.150 --> 10:47.150
首先我们可以想象得到

10:47.150 --> 10:48.150
这个函数至少要解决

10:48.150 --> 10:49.150
这么一个问题

10:49.150 --> 10:51.150
就是优先级的问题

10:51.150 --> 10:52.150
你看这里边

10:52.150 --> 10:53.150
表达式里边

10:53.150 --> 10:54.150
是不是有很多优先级

10:54.150 --> 10:55.150
有乘号

10:55.150 --> 10:56.150
有加号

10:56.150 --> 10:57.150
有可能有小过号

10:57.150 --> 10:59.150
有可能有求予符号

10:59.150 --> 11:00.150
有可能有除号

11:00.150 --> 11:02.150
加渐乘除求予

11:02.150 --> 11:04.150
那么这些都是运算符

11:04.150 --> 11:05.150
那么这些运算符

11:05.150 --> 11:07.150
之间会有一些优先级的关系

11:07.150 --> 11:08.150
那么这个东西

11:08.150 --> 11:09.150
我们至少要把定义下来

11:09.150 --> 11:11.150
就哪个优先级高

11:11.150 --> 11:12.150
哪个优先级低

11:12.150 --> 11:14.150
我们至少要把定义下来

11:14.150 --> 11:15.150
要把这件事情做了

11:15.150 --> 11:16.150
那么这个定义的优先级

11:16.150 --> 11:18.150
到底怎么去用

11:18.150 --> 11:19.150
到底怎么去算

11:19.150 --> 11:20.150
那我们一会再说

11:20.150 --> 11:21.150
那至少有个定义

11:22.150 --> 11:23.150
那么这就受到

11:23.150 --> 11:24.150
第一个问题了

11:24.150 --> 11:26.150
定义操作符的优先级

11:26.150 --> 11:27.150
那么这个问题

11:27.150 --> 11:29.150
你会用什么方式来定义

11:30.150 --> 11:31.150
同学们有没有什么想法

11:31.150 --> 11:32.150
就是你用一个变量

11:32.150 --> 11:33.150
来保存

11:33.150 --> 11:35.150
每个运算符的优先级

11:35.150 --> 11:36.150
你会用什么方式来定义

11:39.420 --> 11:40.420
如果说哪个你的话

11:45.210 --> 11:46.210
用什么方式呢

11:47.210 --> 11:48.210
其实我这里

11:48.210 --> 11:50.210
想到一种比较好的方式

11:50.210 --> 11:52.210
就是用一个对象

11:52.210 --> 11:53.210
用一个对象来定义

11:53.210 --> 11:54.210
是比较好的

11:54.210 --> 11:55.210
于是我们可能

11:55.210 --> 11:57.210
会尝试着去写书

11:57.210 --> 11:58.210
就是我们事情要一步一步来

11:58.210 --> 12:00.210
千万不能着急

12:00.210 --> 12:01.210
包括我现在

12:01.210 --> 12:02.210
不光是你们

12:02.210 --> 12:03.210
包括我现在

12:03.210 --> 12:04.210
这么多年开发经验了

12:04.210 --> 12:06.210
也这么多年教学经验了

12:06.210 --> 12:07.210
像做一些复杂问题

12:07.210 --> 12:08.210
如果说我感觉他复杂了

12:08.210 --> 12:10.210
我特要让自己冷静下来

12:10.210 --> 12:11.210
一旦心态急到的话

12:11.210 --> 12:12.210
说不出来的

12:13.210 --> 12:14.210
我们首先定义一个变量

12:14.210 --> 12:16.210
就表示operators

12:16.210 --> 12:20.350
所谓的运算符

12:20.350 --> 12:21.350
那么这些运算符

12:21.350 --> 12:22.350
里边有各种各样的优先级

12:22.350 --> 12:23.350
我们可以

12:23.350 --> 12:24.350
我首先想到

12:24.350 --> 12:25.350
我用什么方式来表达

12:25.350 --> 12:26.350
这个优先级呢

12:26.350 --> 12:28.350
我可能会用这种方式

12:28.350 --> 12:29.350
看着啊

12:29.350 --> 12:30.350
我们可以

12:30.350 --> 12:31.350
因为属性名

12:31.350 --> 12:32.350
它可以是一个制服串

12:32.350 --> 12:33.350
像介石里面特别方便

12:33.350 --> 12:34.350
它属性名

12:34.350 --> 12:35.350
可以是一个制服串

12:35.350 --> 12:36.350
任何制服串都可以

12:36.350 --> 12:37.350
像夹吧语言啊

12:37.350 --> 12:38.350
像这些

12:38.350 --> 12:39.350
还有一点麻烦对吧

12:39.350 --> 12:40.350
它的属性名

12:40.350 --> 12:41.350
还不能有特殊制服

12:41.350 --> 12:42.350
但介石语言没有这个问题

12:42.350 --> 12:43.350
因此呢

12:43.350 --> 12:44.350
我就可以用一个

12:44.350 --> 12:45.350
加号来表达的属性名

12:46.350 --> 12:47.350
比方加号

12:47.350 --> 12:48.350
它的优先级是以

12:48.350 --> 12:50.350
减号的优先级

12:51.350 --> 12:52.350
就随便听一个数字

12:52.350 --> 12:53.350
来表示优先级一

12:53.350 --> 12:54.350
然后呢

12:54.350 --> 12:56.350
减号优先级是二

12:57.350 --> 12:59.350
除号优先级是二

12:59.350 --> 13:00.350
他们优先级都一样

13:00.350 --> 13:01.350
然后求语符号

13:01.350 --> 13:03.350
优先级也是二

13:03.350 --> 13:04.350
麦克也可以

13:04.350 --> 13:05.350
对麦克也可以

13:05.350 --> 13:07.350
但是属性不行啊

13:07.350 --> 13:09.350
还是表达人可以的

13:09.350 --> 13:10.350
就是我们要通过

13:10.350 --> 13:11.350
这种方式来表达出来

13:11.350 --> 13:12.350
那这样的

13:12.350 --> 13:13.350
是不是可以表达了

13:13.350 --> 13:14.350
那到时候我看一下

13:14.350 --> 13:15.350
加号的优先级是多少

13:15.350 --> 13:16.350
我是不可以用这种方式啊

13:16.350 --> 13:17.350
operator

13:17.350 --> 13:19.350
也给它传一个加号

13:19.350 --> 13:20.350
是不是属性名传进去

13:20.350 --> 13:21.350
是不是拿到它的

13:21.350 --> 13:22.350
优先级数字了

13:22.350 --> 13:23.350
对吧 就非常的方便

13:23.350 --> 13:25.350
我们来定义它的优先级

13:26.350 --> 13:28.350
其实写到这呢

13:28.350 --> 13:29.350
其实没有啥问题啊

13:29.350 --> 13:30.350
你把优先级

13:30.350 --> 13:31.350
已经定义出来了

13:31.350 --> 13:32.350
但是呢

13:32.350 --> 13:33.350
如果说将来

13:33.350 --> 13:34.350
我要做加法运算的时候

13:34.350 --> 13:35.350
因为知道啊

13:35.350 --> 13:36.350
到时候

13:36.350 --> 13:37.350
我们从制服

13:37.350 --> 13:38.350
制服创分析出来的结果

13:38.350 --> 13:40.350
它是一个普通的制服

13:40.350 --> 13:41.350
比方说拿到它

13:41.350 --> 13:42.350
它是一个普通的制服

13:42.350 --> 13:43.350
拿到它

13:43.350 --> 13:44.350
它又是个普通的数字

13:44.350 --> 13:45.350
它又能是数字

13:45.350 --> 13:47.350
我拿到这个制服的时候

13:47.350 --> 13:48.350
我要怎么运算呢

13:48.350 --> 13:49.350
是不是五减三

13:50.350 --> 13:51.350
我拿到这个制服的时候

13:51.350 --> 13:52.350
有两个数字

13:53.350 --> 13:54.350
这里啊

13:54.350 --> 13:55.350
我拿到这个制服的时候

13:55.350 --> 13:56.350
有两个数字

13:56.350 --> 13:57.350
二和三

13:57.350 --> 13:58.350
变成二加三

13:58.350 --> 13:59.350
所以每一个符号

13:59.350 --> 14:01.350
它的运算方式不一样

14:01.350 --> 14:03.350
那我怎么样在这里边

14:03.350 --> 14:04.350
又可以表达出

14:04.350 --> 14:06.350
每个符号的运算方式呢

14:08.350 --> 14:09.350
其实这里边

14:09.350 --> 14:10.350
涉及到一些

14:10.350 --> 14:11.350
面向对象的思想啊

14:11.350 --> 14:12.350
只是呢 我没有

14:12.350 --> 14:13.350
特别的去用内容来做

14:13.350 --> 14:14.350
其实面向对象呢

14:14.350 --> 14:15.350
你不一定要写内

14:15.350 --> 14:16.350
你不一定要写

14:16.350 --> 14:17.350
按照那个

14:17.350 --> 14:18.350
学家外啊

14:18.350 --> 14:19.350
学其他

14:19.350 --> 14:20.350
谁瞎不语言啊

14:20.350 --> 14:21.350
那种标准的写法

14:21.350 --> 14:22.350
你知道吧

14:22.350 --> 14:23.350
思想注入进去就行了

14:23.350 --> 14:24.350
就说这里边

14:24.350 --> 14:25.350
运用到了一些多态的思想啊

14:25.350 --> 14:26.350
不过我不大想

14:26.350 --> 14:27.350
去特别的说

14:28.350 --> 14:29.350
就算每一个运算

14:29.350 --> 14:30.350
它的算

14:30.350 --> 14:31.350
计算方式不一样

14:31.350 --> 14:32.350
但是呢

14:32.350 --> 14:33.350
我们认为

14:33.350 --> 14:34.350
每个运算符

14:36.350 --> 14:37.350
都有一个能力

14:37.350 --> 14:38.350
什么能力呢

14:39.350 --> 14:41.350
将两个数字

14:41.350 --> 14:42.350
进行运算

14:43.350 --> 14:44.350
只是

14:44.350 --> 14:45.350
方式不一样

14:47.350 --> 14:48.350
你看一下是不是这个道理

14:49.350 --> 14:50.350
加减乘除求予

14:50.350 --> 14:52.350
是不是都是两个数字进行运算

14:52.350 --> 14:53.350
当然我们在

14:53.350 --> 14:55.350
真实代表里边

14:55.350 --> 14:56.350
其实不只有

14:56.350 --> 14:57.350
二元运算符

14:57.350 --> 14:58.350
还有什么三元啊

14:58.350 --> 14:59.350
还有一元

14:59.350 --> 15:00.350
这些东西我们不考虑的啊

15:00.350 --> 15:01.350
今天往上就考虑

15:01.350 --> 15:02.350
加减乘除求予

15:02.350 --> 15:03.350
其他不考虑

15:04.350 --> 15:05.350
是不是都是两个数字

15:05.350 --> 15:06.350
参与运算

15:06.350 --> 15:07.350
只是方式不一样

15:07.350 --> 15:09.350
那么我们来如何来

15:09.350 --> 15:10.350
表达出

15:10.350 --> 15:12.350
加号的运算方式是什么

15:12.350 --> 15:14.350
减号的运算方式是什么

15:14.350 --> 15:15.350
乘号除号求予

15:15.350 --> 15:16.350
的运算方式是什么

15:16.350 --> 15:18.350
如何来表达出来了

15:18.350 --> 15:20.350
那里面有没有什么好的想法

15:21.350 --> 15:22.350
扩号不管啊

15:22.350 --> 15:23.350
扩号它不是

15:23.350 --> 15:24.350
扩号它不是运算

15:24.350 --> 15:26.350
它是只是会改变那个

15:26.350 --> 15:28.350
会影响运算顺序

15:28.350 --> 15:29.350
它本身不参与运算

15:30.350 --> 15:31.350
扩号我们以后来说

15:31.350 --> 15:32.350
因为一讲啊

15:32.350 --> 15:33.350
扩号是不是

15:33.350 --> 15:34.350
不参与运算

15:34.350 --> 15:35.350
你把两个数字

15:35.350 --> 15:36.350
扔给扩号

15:36.350 --> 15:37.350
它干嘛的

15:40.350 --> 15:41.350
衣服判断的是

15:41.350 --> 15:42.350
这里怎么表达

15:42.350 --> 15:43.350
衣服判断呢

15:43.350 --> 15:44.350
你没法表达衣服判断

15:44.350 --> 15:45.350
这是个对象啊

15:45.350 --> 15:46.350
对象判断

15:46.350 --> 15:47.350
其实像这些问题

15:47.350 --> 15:48.350
今天晚上我们

15:48.350 --> 15:49.350
虽然说只是说的这个

15:49.350 --> 15:50.350
运算符

15:50.350 --> 15:51.350
其实你这边可以学习到

15:51.350 --> 15:53.350
很多的程序开发思想

15:54.350 --> 15:55.350
怎么来表达呢

15:56.350 --> 15:57.350
你看着啊

15:57.350 --> 15:58.350
我可以用这种方式来表达

15:59.350 --> 16:01.350
我把这个加号啊

16:01.350 --> 16:03.350
它之前我只是用一个

16:03.350 --> 16:04.350
优先级来表示

16:04.350 --> 16:05.350
现在发现了一个优先级

16:05.350 --> 16:06.350
还不够

16:06.350 --> 16:07.350
我还要把表达出

16:07.350 --> 16:09.350
这个加号的运算方式

16:09.350 --> 16:10.350
我就可以用这种方式

16:10.350 --> 16:12.350
既然你一个信息不够

16:12.350 --> 16:14.350
那就说明你有多个信息

16:14.350 --> 16:15.350
我就可以用对象

16:16.350 --> 16:18.350
这个加号是一个对象

16:18.350 --> 16:19.350
对象里面有两个属性

16:19.350 --> 16:21.350
一个是优先级

16:21.350 --> 16:22.350
level

16:22.350 --> 16:23.350
一

16:23.350 --> 16:24.350
这个表示什么

16:24.350 --> 16:25.350
表示优先级

16:26.350 --> 16:28.350
那他怎么来参与运算的呢

16:28.350 --> 16:29.350
我们就给他写个函数

16:29.350 --> 16:30.350
叫做comput

16:31.350 --> 16:32.350
他不是把

16:32.350 --> 16:33.350
给两个数字来进行运算吗

16:33.350 --> 16:34.350
一个数字a

16:34.350 --> 16:35.350
一个数字b

16:35.350 --> 16:37.350
我就把发给a加d

16:37.350 --> 16:38.350
这边就表达出来了

16:38.350 --> 16:39.350
对吧

16:39.350 --> 16:40.350
我们要追求的是一个对象

16:40.350 --> 16:41.350
他能够把他的信息

16:41.350 --> 16:42.350
表达出来

16:42.350 --> 16:43.350
现在你看

16:43.350 --> 16:44.350
这个信息的是不是变多了

16:44.350 --> 16:46.350
以前我只是表达出

16:46.350 --> 16:47.350
这个加号的优先级

16:47.350 --> 16:48.350
是1

16:48.350 --> 16:49.350
直接一个数字

16:49.350 --> 16:50.350
现在发现他信息更多了

16:50.350 --> 16:51.350
除了有优先级之外

16:51.350 --> 16:53.350
他还有个运算规则

16:53.350 --> 16:54.350
你给我两个数字

16:54.350 --> 16:56.350
我给你一个运算结果

16:56.350 --> 16:57.350
那么减好的话

16:57.350 --> 16:58.350
是不是也可以用这种方式

16:58.350 --> 16:59.350
来表达

16:59.350 --> 17:00.350
level

17:00.350 --> 17:01.350
一

17:01.350 --> 17:02.350
comput

17:03.350 --> 17:04.350
分析

17:04.350 --> 17:05.350
a和d

17:05.350 --> 17:06.350
减好的话

17:06.350 --> 17:08.350
就反过来a减b

17:08.350 --> 17:10.350
呈号的话是不一样的

17:10.350 --> 17:11.350
把他复制一下

17:14.050 --> 17:18.280
呈

17:18.280 --> 17:19.280
呃

17:19.280 --> 17:20.280
这里是2

17:20.280 --> 17:21.280
这里是

17:21.280 --> 17:22.280
这里是2

17:22.280 --> 17:23.280
这里是

17:23.280 --> 17:24.280
除

17:24.280 --> 17:28.450
呃

17:28.450 --> 17:29.450
这里是2

17:29.450 --> 17:30.450
啊

17:30.450 --> 17:31.450
这里是求余

17:31.450 --> 17:32.450
你看

17:32.450 --> 17:33.450
现在我这个对象

17:33.450 --> 17:34.450
内容变多了

17:34.450 --> 17:35.450
他表达的信息

17:35.450 --> 17:36.450
是不是更多了

17:36.450 --> 17:37.450
像这些

17:37.450 --> 17:38.450
这些都是开发技巧啊

17:38.450 --> 17:39.450
就是如果说

17:39.450 --> 17:40.450
你们一开始

17:40.450 --> 17:41.450
以后做一些

17:41.450 --> 17:42.450
练习也好

17:42.450 --> 17:43.450
做一些项目也好

17:43.450 --> 17:44.450
你们一开始

17:44.450 --> 17:45.450
会需要一个东西

17:45.450 --> 17:46.450
来表达出

17:46.450 --> 17:48.450
定义出一些东西

17:48.450 --> 17:49.450
完善

17:49.450 --> 17:51.450
尽量的定义多一点

17:51.450 --> 17:52.450
把信息量重复一下

17:52.450 --> 17:54.450
那么你可以用这种格式

17:54.450 --> 17:56.450
能理解这个意思吗

17:56.450 --> 17:57.450
好

17:57.450 --> 17:58.450
我们来看一下啊

17:58.450 --> 17:59.450
将来这样的定义

17:59.450 --> 18:00.450
有什么好处呢

18:00.450 --> 18:02.450
你看着有什么好处

18:02.450 --> 18:04.450
我们现在就来测试一下啊

18:04.450 --> 18:05.450
比方说我将来

18:05.450 --> 18:06.450
从制服创意里边

18:06.450 --> 18:07.450
慢慢去取

18:07.450 --> 18:08.450
取出来一个数字呢

18:08.450 --> 18:09.450
叫做1

18:09.450 --> 18:10.450
假设我们取出来了啊

18:10.450 --> 18:11.450
一个数字呢

18:11.450 --> 18:12.450
叫做3

18:12.450 --> 18:13.450
或者是

18:13.450 --> 18:14.450
一个2

18:14.450 --> 18:15.450
一个3

18:15.450 --> 18:16.450
又取出来一个

18:16.450 --> 18:17.450
就算符

18:17.450 --> 18:18.450
叫做加

18:18.450 --> 18:19.450
都是从制服创意里边

18:19.450 --> 18:20.450
取出来的啊

18:20.450 --> 18:21.450
取出一个A

18:21.450 --> 18:22.450
取出一个B

18:22.450 --> 18:23.450
取出一个加

18:23.450 --> 18:24.450
我也不知道

18:24.450 --> 18:25.450
因为将来我们

18:25.450 --> 18:26.450
从制服创意里面

18:26.450 --> 18:27.450
一个一个取

18:27.450 --> 18:28.450
我也不知道取出来的是啥

18:28.450 --> 18:29.450
它有可能是别的数字

18:29.450 --> 18:30.450
有可能是别的数字

18:30.450 --> 18:31.450
有可能是别的符号

18:31.450 --> 18:32.450
但是甭管你取出来

18:32.450 --> 18:33.450
是什么数字

18:33.450 --> 18:34.450
什么符号

18:34.450 --> 18:35.450
我们是不是都可以

18:35.450 --> 18:36.450
用统一的一个表达式

18:36.450 --> 18:37.450
叫做operators

18:37.450 --> 18:39.450
OP传进去

18:39.450 --> 18:40.450
去把加号传进去

18:40.450 --> 18:41.450
是不是可以拿到

18:41.450 --> 18:42.450
拿到什么

18:42.450 --> 18:43.450
拿到这个对象

18:43.450 --> 18:44.450
拿到这个对象过去

18:44.450 --> 18:45.450
都可以拿到优先节

18:45.450 --> 18:46.450
但是我们是不是可以拿到

18:46.450 --> 18:47.450
这个computer

18:47.450 --> 18:48.450
可以拿到这个计算

18:48.450 --> 18:49.450
这个函数

18:49.450 --> 18:50.450
我们是不是可以拿到

18:50.450 --> 18:51.450
这个computer

18:51.450 --> 18:52.450
这个函数

18:52.450 --> 18:54.450
然后把A和B传进去

18:54.450 --> 18:56.450
是不是可以运算出一个结果

18:56.450 --> 18:59.450
出一个 without

18:59.450 --> 19:00.450
你看啊

19:00.450 --> 19:01.450
我把符号

19:01.450 --> 19:02.450
甭管你是什么符号

19:02.450 --> 19:03.450
符号传进去

19:03.450 --> 19:06.450
然后把两个数字传进去

19:06.450 --> 19:07.450
它始终能够得到

19:07.450 --> 19:08.450
一个正确的运算结果

19:08.450 --> 19:10.450
其实这就是一个多态

19:10.450 --> 19:11.450
多态的场景

19:11.450 --> 19:12.450
我们运行看一下

19:12.450 --> 19:13.450
是不是2加3

19:13.450 --> 19:14.450
等于一个5

19:15.450 --> 19:16.450
对不对

19:16.450 --> 19:17.450
那将来

19:17.450 --> 19:18.450
这个样子写有什么好说

19:18.450 --> 19:19.450
为什么不直接写个A加B呢

19:19.450 --> 19:21.450
是因为我们这三个东西

19:21.450 --> 19:22.450
是可能会变化的

19:22.450 --> 19:23.450
将来可能拿出来

19:23.450 --> 19:24.450
另外一个数字

19:24.450 --> 19:25.450
又可能拿出来

19:25.450 --> 19:26.450
另外一个数字

19:26.450 --> 19:27.450
这里又可能拿出来

19:27.450 --> 19:28.450
另外一个数字

19:28.450 --> 19:29.450
我们下面的代码不用变

19:29.450 --> 19:31.450
它就可以直接来进行运算

19:31.450 --> 19:32.450
你看看

19:32.450 --> 19:33.450
是不是拿出来2

19:33.450 --> 19:34.450
为什么呢

19:34.450 --> 19:35.450
因为现在我们通过OP

19:35.450 --> 19:36.450
这个减号

19:36.450 --> 19:37.450
是不是可以拿到

19:37.450 --> 19:38.450
这个对象了

19:38.450 --> 19:39.450
拿到这个对象

19:39.450 --> 19:40.450
这个对象里面

19:40.450 --> 19:41.450
是不是也有一个computer

19:41.450 --> 19:42.450
你给我两个数字

19:42.450 --> 19:43.450
相减的结果

19:44.450 --> 19:45.450
这一块能理解吧

19:46.450 --> 19:47.450
能不能理解

19:47.450 --> 19:48.450
我们现在要

19:48.450 --> 19:49.450
目前做的事情

19:51.450 --> 19:54.080
好

19:55.080 --> 19:56.080
我就把这件事情先做了

19:56.080 --> 19:57.080
你看

19:57.080 --> 19:58.080
现在我们离我们的

19:58.080 --> 19:59.080
最终目标还很远很远

19:59.080 --> 20:00.080
不过呢

20:00.080 --> 20:01.080
我们又慢慢的

20:01.080 --> 20:03.080
往前推进了一小步了

20:03.080 --> 20:04.080
其实开发程序

20:04.080 --> 20:05.080
就是这样子

20:05.080 --> 20:06.080
一点一点的推进

20:06.080 --> 20:07.080
你要想刷

20:07.080 --> 20:08.080
一下子写完

20:08.080 --> 20:09.080
那是不可能的

20:09.080 --> 20:10.080
哪里可能

20:10.080 --> 20:11.080
走的时候比较安小

20:11.080 --> 20:12.080
你不能这样子

20:13.080 --> 20:15.650
不行

20:15.650 --> 20:16.650
你不行

20:16.650 --> 20:17.650
有人说能不能

20:17.650 --> 20:18.650
这是基础

20:18.650 --> 20:19.650
能不能这样子写

20:19.650 --> 20:20.650
肯定是不行的

20:20.650 --> 20:21.650
因为这样子写的话

20:21.650 --> 20:22.650
就相当于是怎么写的

20:22.650 --> 20:23.650
就相当于是

20:23.650 --> 20:24.650
你是这样子写的

20:25.650 --> 20:27.650
你读的属性名是OP

20:28.650 --> 20:29.650
而不是把OP

20:29.650 --> 20:31.650
这个值作为属性名

20:32.650 --> 20:33.650
那意思吧

20:33.650 --> 20:37.980
运算符可以用switch case

20:37.980 --> 20:38.980
更方便

20:38.980 --> 20:40.980
根据运算符来决定

20:40.980 --> 20:44.980
两个操作数的运算

20:45.980 --> 20:47.980
你是可以这样做

20:47.980 --> 20:48.980
但是我觉得

20:48.980 --> 20:49.980
你的这样做的结构

20:49.980 --> 20:51.980
肯定没有这样子好

20:51.980 --> 20:52.980
为什么呢

20:52.980 --> 20:53.980
这样子做以后是可以扩展的

20:53.980 --> 20:54.980
不要说我们也将来

20:54.980 --> 20:56.980
出了更多的运算符了

20:56.980 --> 20:57.980
那么我们只需要

20:57.980 --> 20:58.980
更改这个对象就行了

20:58.980 --> 20:59.980
其他大码一行不用改

20:59.980 --> 21:00.980
知道吧

21:00.980 --> 21:02.980
一行都不用改

21:02.980 --> 21:03.980
我们只需要

21:03.980 --> 21:04.980
更加这个对象就行了

21:04.980 --> 21:06.980
而且你要从效率上来讲的话

21:06.980 --> 21:07.980
那样子的话

21:07.980 --> 21:08.980
其实要比较慢一点

21:08.980 --> 21:09.980
为什么比较慢一点

21:09.980 --> 21:11.980
你每一次拿出符号过后

21:11.980 --> 21:12.980
是不是都要进行判断

21:13.980 --> 21:15.980
我们这里不用去判断

21:15.980 --> 21:16.980
直接通过符号

21:16.980 --> 21:17.980
拿到对象

21:17.980 --> 21:18.980
然后直接调了

21:21.940 --> 21:23.940
这是关于定义

21:23.940 --> 21:28.660
定义操作符

21:28.660 --> 21:29.660
好

21:29.660 --> 21:30.660
操作符意定义好了

21:30.660 --> 21:31.660
我们的占也准备好了

21:31.660 --> 21:32.660
还有什么事情

21:32.660 --> 21:33.660
我们需要准备

21:33.660 --> 21:34.660
这都是我们提前准备的

21:34.660 --> 21:35.660
为了方便我们

21:35.660 --> 21:36.660
后边进行运算

21:36.660 --> 21:38.660
要提前准备一些东西

21:38.660 --> 21:39.660
操作符

21:39.660 --> 21:40.660
准备好了

21:40.660 --> 21:41.660
占也准备好了

21:41.660 --> 21:43.660
还有什么东西呢

21:43.660 --> 21:44.660
我们向往下看

21:44.660 --> 21:46.660
定义操作符的优先仪

21:47.660 --> 21:48.660
你过了

21:48.660 --> 21:49.660
讲完了

21:50.660 --> 21:51.660
接下来还有一件

21:51.660 --> 21:52.660
非常重要的事情

21:53.660 --> 21:55.660
就是要去提取

21:55.660 --> 21:56.660
操作符和操作书

21:56.660 --> 21:57.660
你看吧

21:57.660 --> 21:58.660
一个字书串里面

21:58.660 --> 21:59.660
有这么多东西

22:00.660 --> 22:02.660
有一些是操作符

22:02.660 --> 22:03.660
像这些玩意儿

22:03.660 --> 22:04.660
这些玩意儿

22:05.660 --> 22:06.660
这些玩意儿

22:06.660 --> 22:07.660
都是操作符

22:07.660 --> 22:09.660
有一些是操作书

22:09.660 --> 22:10.660
你看

22:10.660 --> 22:11.660
像这里

22:12.660 --> 22:13.660
像这个玩意儿

22:13.660 --> 22:14.660
这个玩意儿

22:15.660 --> 22:17.660
都是操作书

22:17.660 --> 22:19.660
我怎么去提取他们

22:19.660 --> 22:20.660
而且不能乱提取

22:20.660 --> 22:21.660
你不能说

22:21.660 --> 22:22.660
把全部的数字拿出来

22:22.660 --> 22:23.660
又把全部的操作符拿出来

22:23.660 --> 22:24.660
那样子

22:24.660 --> 22:25.660
我就不知道顺序了

22:25.660 --> 22:27.660
我最好的提取是怎么了

22:27.660 --> 22:29.660
最好是要能够通过一种方式

22:29.660 --> 22:31.660
就是我先拿下一个

22:33.660 --> 22:34.660
最好是通过这种方式

22:34.660 --> 22:36.660
你看就这个表拿式

22:36.660 --> 22:37.660
我拿下一个

22:37.660 --> 22:39.660
下一个拿出来就是一个小过号

22:39.660 --> 22:41.660
我再拿下一个

22:41.660 --> 22:43.660
下一个拿出来是一个实物

22:43.660 --> 22:44.660
我再拿下一个

22:44.660 --> 22:46.660
下一个是一个操作符

22:46.660 --> 22:47.660
百分号

22:47.660 --> 22:49.660
再拿下一个又是一个货符

22:49.660 --> 22:51.660
再拿下一个又是一个5

22:51.660 --> 22:52.660
再拿下一个又是一个减

22:52.660 --> 22:53.660
对吧

22:53.660 --> 22:54.660
我要一个一个去取

22:54.660 --> 22:55.660
取一个看一个

22:55.660 --> 22:57.660
从头到尾取一个看一个

22:57.660 --> 22:59.660
空格全部忽略

22:59.660 --> 23:01.660
空格全部忽略

23:01.660 --> 23:03.660
那么有没有什么办法

23:03.660 --> 23:05.660
能够帮我们去做这件事情的

23:05.660 --> 23:07.660
就是我还不涉及运算

23:07.660 --> 23:09.660
现在算都还是另外一回事

23:09.660 --> 23:10.660
还找得很

23:10.660 --> 23:11.660
我先要能够一个一个拿出来

23:11.660 --> 23:12.660
因为我要一个个拿出来看

23:12.660 --> 23:14.660
我要接下来要怎么处处理

23:14.660 --> 23:15.660
懂我的意思吧

23:15.660 --> 23:16.660
因此呢

23:16.660 --> 23:17.660
基于这样的需求

23:17.660 --> 23:18.660
我们现在还不能去写

23:18.660 --> 23:20.660
这个computer函数

23:20.660 --> 23:22.660
我们先要去写一个东西

23:22.660 --> 23:25.660
我把它称之为扫描器

23:25.660 --> 23:26.660
它能够把这个字不出来

23:26.660 --> 23:28.660
一个一个扫描出来

23:28.660 --> 23:30.660
扫描下一个拿到个操作符

23:30.660 --> 23:32.660
扫描下一个拿到个操作数

23:32.660 --> 23:33.660
而且它要告诉我

23:33.660 --> 23:34.660
下一个东西是啥

23:34.660 --> 23:36.660
它是操作符啊

23:36.660 --> 23:37.660
还是操作数

23:37.660 --> 23:38.660
它是操作符

23:38.660 --> 23:39.660
哪个符号

23:39.660 --> 23:40.660
它是操作数的话

23:40.660 --> 23:41.660
哪个数字

23:41.660 --> 23:42.660
于是呢

23:42.660 --> 23:44.660
我们就出现这样的一个需求

23:44.660 --> 23:45.660
现在占还没有出来

23:45.660 --> 23:49.220
还不设立到占

23:49.220 --> 23:51.220
就是提取操作符和操作数

23:51.220 --> 23:52.220
我希望呢

23:52.220 --> 23:54.220
有这么一个东西

23:54.220 --> 23:55.220
一个构造函数

23:55.220 --> 23:57.220
叫做适则运算扫描器

23:57.220 --> 23:58.220
我自己一个安的名字

23:58.220 --> 24:00.220
叫scanner

24:00.220 --> 24:01.220
然后呢

24:01.220 --> 24:04.220
它里面提供的一个函数叫next

24:04.220 --> 24:05.220
我希望啊

24:05.220 --> 24:06.220
这个代码没写

24:06.220 --> 24:07.220
我希望呢

24:07.220 --> 24:09.220
你能把代码完成之后呢

24:09.220 --> 24:10.220
达到这么一个效果

24:10.220 --> 24:12.220
我给它一个适则运算

24:12.220 --> 24:13.220
你看啊

24:13.220 --> 24:14.220
我创建一个扫描器

24:14.220 --> 24:15.220
给它一个适则运算

24:15.220 --> 24:16.220
接下来

24:16.220 --> 24:17.220
我就可以用这种方式

24:17.220 --> 24:19.220
调用下一个

24:19.220 --> 24:20.220
调用这个next

24:20.220 --> 24:21.220
它就会得到一个什么呢

24:21.220 --> 24:22.220
得到

24:22.220 --> 24:23.220
它就告诉我

24:23.220 --> 24:24.220
下一个东西呢

24:24.220 --> 24:25.220
是一个数字

24:25.220 --> 24:26.220
是操作

24:26.220 --> 24:28.220
操作数

24:28.220 --> 24:29.220
然后呢

24:29.220 --> 24:30.220
得到它的值呢

24:30.220 --> 24:32.220
是2.5

24:32.220 --> 24:33.220
啊

24:33.220 --> 24:34.220
有同学能够感受到

24:34.220 --> 24:35.220
对吧

24:35.220 --> 24:36.220
昨天东西好像能用的

24:36.220 --> 24:37.220
但是我不大想用昨天东西

24:37.220 --> 24:38.220
如果用昨天的双子针的话

24:38.220 --> 24:39.220
能不能扫描出来的

24:39.220 --> 24:40.220
能扫描出来

24:40.220 --> 24:41.220
这会把它变得非常复杂

24:41.220 --> 24:43.220
我不想把它变得非常复杂

24:43.220 --> 24:44.220
因为我们后面

24:44.220 --> 24:45.220
还有更复杂的东西

24:45.220 --> 24:47.220
我尽量把这一块弄得简单

24:47.220 --> 24:48.220
好

24:48.220 --> 24:50.220
然后再一次调用这个next呢

24:50.220 --> 24:52.220
我得到的就是一个符号

24:52.220 --> 24:53.220
就它了

24:53.220 --> 24:54.220
operator

24:54.220 --> 24:55.220
它是一个符号

24:55.220 --> 24:56.220
于是呢

24:56.220 --> 24:57.220
得到它的 value 值呢

24:57.220 --> 24:58.220
是一个

24:58.220 --> 24:59.220
乘号

24:59.220 --> 25:00.220
再扫描一下呢

25:00.220 --> 25:01.220
得到的下一个呢

25:01.220 --> 25:02.220
又是一个符号

25:02.220 --> 25:03.220
这个玩意

25:03.220 --> 25:04.220
它的 value 值呢

25:04.220 --> 25:05.220
是这个

25:05.220 --> 25:06.220
然后呢

25:06.220 --> 25:07.220
它再下一个人

25:07.220 --> 25:08.220
是一个数字

25:08.220 --> 25:09.220
2

25:09.220 --> 25:10.220
它的 value 值是2

25:10.220 --> 25:11.220
它的 value 值是个符号

25:11.220 --> 25:12.220
它是 value 值是加

25:12.220 --> 25:13.220
对吧

25:13.220 --> 25:14.220
一个个扫描

25:14.220 --> 25:15.220
扫描到最后

25:15.220 --> 25:16.220
一看

25:16.220 --> 25:17.220
又过耗完了

25:17.220 --> 25:18.220
最后呢

25:18.220 --> 25:19.220
它就告诉老师

25:19.220 --> 25:20.220
哪有了

25:20.220 --> 25:21.220
没东西了

25:21.220 --> 25:22.220
没了意思吧

25:22.220 --> 25:24.220
我希望有这么一个功能

25:24.220 --> 25:25.220
我们先把这个功能做了

25:25.220 --> 25:27.220
我们现在都还不设计到运算

25:27.220 --> 25:28.220
先把这些东西

25:28.220 --> 25:29.220
准备好

25:29.220 --> 25:30.220
有超过符了

25:30.220 --> 25:31.220
人字以后会用

25:31.220 --> 25:32.220
有这个粘了

25:32.220 --> 25:33.220
人字以后会用

25:33.220 --> 25:34.220
然后呢

25:34.220 --> 25:35.220
我们现在

25:35.220 --> 25:36.220
把一些基础工作做好

25:36.220 --> 25:38.790
现在我们还需要这个东西

25:38.790 --> 25:39.790
扫描器

25:39.790 --> 25:40.790
接下来

25:40.790 --> 25:42.790
你做一个问题的时候

25:42.790 --> 25:43.790
你就要拋棄

25:43.790 --> 25:45.790
其他的任何所有的干扰

25:45.790 --> 25:47.790
专心自治的去解决这个问题

25:47.790 --> 25:48.790
你整个世界

25:48.790 --> 25:49.790
整个思维

25:49.790 --> 25:50.790
全在这个问题身上

25:50.790 --> 25:52.790
不要去想别的

25:52.790 --> 25:53.790
这个问题是一个独立的问题

25:53.790 --> 25:55.790
就说我给你一个表的

25:55.790 --> 25:56.790
表达是你怎么样

25:56.790 --> 25:58.790
一个一个取出来

25:58.790 --> 25:59.790
怎么样取出来呢

25:59.790 --> 26:00.790
我们这里呢

26:00.790 --> 26:01.790
就可以想到

26:01.790 --> 26:02.790
可以用一个

26:02.790 --> 26:03.790
用政则

26:03.790 --> 26:04.790
你被有一些空白

26:04.790 --> 26:05.790
我们先把空白去掉

26:05.790 --> 26:06.790
昨天我说

26:06.790 --> 26:07.790
最好呢

26:07.790 --> 26:08.790
为了提高效率

26:08.790 --> 26:09.790
最好是一个一个去扫描

26:09.790 --> 26:10.790
当然可以

26:10.790 --> 26:11.790
最好的方式是一个个扫描

26:11.790 --> 26:12.790
但是呢

26:12.790 --> 26:13.790
这一块呢

26:13.790 --> 26:14.790
会把这个问题

26:14.790 --> 26:15.790
变得非常复杂啊

26:15.790 --> 26:16.790
因为以后呢

26:16.790 --> 26:17.790
我们还有一些更复杂的问题

26:17.790 --> 26:18.790
需要处理

26:18.790 --> 26:19.790
所以说这一块呢

26:19.790 --> 26:20.790
我就尽量简单

26:20.790 --> 26:21.790
我又先

26:21.790 --> 26:22.790
你给我一个s

26:22.790 --> 26:23.790
就把一个制补串

26:23.790 --> 26:25.790
我就先把这个制补串

26:25.790 --> 26:27.790
保存到我们的对象里面

26:27.790 --> 26:28.790
就是我们的

26:28.790 --> 26:30.790
这个制补串保存起来

26:30.790 --> 26:35.130
去掉所有的空白

26:35.130 --> 26:36.130
所有的空白制服

26:36.130 --> 26:37.130
空白制服是不是

26:37.130 --> 26:38.130
血缸壁

26:38.130 --> 26:41.130
去掉所有的空白制服

26:41.130 --> 26:43.130
我们可以测试一下吧

26:43.130 --> 26:44.130
这个政策表达是

26:44.130 --> 26:51.090
这里看一下

26:51.090 --> 26:54.090
我写到前边吧

26:54.090 --> 26:56.090
写到前边

26:56.090 --> 27:02.160
空白制服不是壁吗

27:02.160 --> 27:07.520
我觉得空白制服是壁啊

27:07.520 --> 27:08.520
血缸壁

27:08.520 --> 27:14.010
不是空白制服吗

27:14.010 --> 27:17.010
那空白制服是啥呀

27:17.010 --> 27:18.010
我查一下

27:18.010 --> 27:19.010
我一点忘了

27:19.010 --> 27:20.010
你们有没有同学知道

27:20.010 --> 27:21.010
空白制服记得是

27:21.010 --> 27:22.010
血缸壁啊

27:22.010 --> 27:23.010
对对对

27:23.010 --> 27:24.010
好像是血缸s

27:24.010 --> 27:25.010
对对对

27:25.010 --> 27:26.010
血缸s

27:26.010 --> 27:27.010
挤错了

27:27.010 --> 27:28.010
空白制服是血缸s

27:28.010 --> 27:29.010
你看

27:29.010 --> 27:30.010
是不是匹配到所有的空白制服了

27:30.010 --> 27:31.010
包括换行

27:31.010 --> 27:32.010
包括タイプ间

27:32.010 --> 27:33.010
包括那个轨车

27:33.010 --> 27:34.010
都是空白制服

27:34.010 --> 27:35.010
这些空白制服

27:35.010 --> 27:36.010
我不要

27:36.010 --> 27:37.010
运算里面

27:37.010 --> 27:38.010
我们不需要空白制服

27:38.010 --> 27:39.010
所以说呢

27:39.010 --> 27:40.010
我把这个空白制服

27:40.010 --> 27:43.010
全部替换成

27:43.010 --> 27:45.010
空制服上

27:45.010 --> 27:46.010
好

27:46.010 --> 27:47.010
那么这样子

27:47.010 --> 27:48.010
里面就没有任何的空白制服了

27:48.010 --> 27:50.010
方便我们后续处理

27:50.010 --> 27:51.010
接下来

27:51.010 --> 27:53.010
我们要调用这个next

27:53.010 --> 27:54.010
调用这个玩意

27:54.010 --> 27:55.010
这个玩意呢

27:55.010 --> 27:56.010
每一次调用

27:56.010 --> 27:57.010
是不是要从这个制服串的

27:57.010 --> 27:58.010
前边取一个

27:58.010 --> 27:59.010
对吧

27:59.010 --> 28:00.010
比方说制服串是这个

28:01.010 --> 28:02.010
制服串是这个

28:06.240 --> 28:07.240
制服串是这个

28:07.240 --> 28:08.240
那么我们现在是不是要

28:08.240 --> 28:10.240
从制服串前边取一个啊

28:10.240 --> 28:11.240
对不对

28:11.240 --> 28:12.240
那怎么来取呢

28:12.240 --> 28:13.240
我们可以利用

28:13.240 --> 28:14.240
政策表达式来匹配

28:14.240 --> 28:15.240
比方说我们准备好

28:15.240 --> 28:16.240
这么一个政策表达式

28:16.240 --> 28:17.240
this

28:17.240 --> 28:18.240
保存起来

28:18.240 --> 28:19.240
一开始就保存起来

28:19.240 --> 28:20.240
这么一个政策表达式

28:20.240 --> 28:22.240
是专门来匹配数字的

28:22.240 --> 28:24.240
匹配数字的政策表达式

28:24.240 --> 28:25.240
把它称之为

28:25.240 --> 28:27.240
number expression

28:28.240 --> 28:29.240
这是用于

28:31.240 --> 28:32.240
前面这个打个数字啊

28:32.240 --> 28:33.240
这是

28:33.240 --> 28:34.240
区掉所有

28:35.240 --> 28:36.240
空白制服

28:37.240 --> 28:38.240
方便后续处理

28:40.240 --> 28:41.240
那么这个东西呢

28:41.240 --> 28:42.240
是一个政策表达式

28:42.240 --> 28:43.240
它是用来匹配

28:44.240 --> 28:45.240
匹配

28:46.240 --> 28:47.240
制服串

28:47.240 --> 28:49.240
开头的数字

28:51.240 --> 28:52.240
所以匹配这个

28:52.240 --> 28:53.240
那么它有可能是

28:53.240 --> 28:54.240
有可能是2

28:54.240 --> 28:55.240
有可能是23

28:55.240 --> 28:56.240
有可能是这个

28:56.240 --> 28:57.240
说不准是啥

28:57.240 --> 28:58.240
那么我们怎么来写呢

28:58.240 --> 28:59.240
这个政策表达式

28:59.240 --> 29:01.240
它要一开始呢

29:01.240 --> 29:02.240
是不是一定是一个数字

29:02.240 --> 29:04.240
它一定是以数字开头的

29:04.240 --> 29:05.240
对吧

29:05.240 --> 29:06.240
所以说我们可以写个

29:06.240 --> 29:08.240
它一定是以邪杠地开头

29:10.240 --> 29:11.240
有可能有些东西

29:11.240 --> 29:12.240
还没有学过政策表达式

29:12.240 --> 29:13.240
哪里这里呢

29:13.240 --> 29:14.240
只能听个意思

29:14.240 --> 29:15.240
政策表达式这一块

29:15.240 --> 29:16.240
只能听个意思

29:17.240 --> 29:18.240
它一定是一个数字开头

29:19.240 --> 29:20.240
你看吧

29:20.240 --> 29:21.240
现在我们匹配一下

29:22.240 --> 29:23.240
你看现在是不是匹配不上

29:23.240 --> 29:24.240
但是如果说你写个1

29:24.240 --> 29:25.240
看1是不是匹配上了

29:26.240 --> 29:27.240
数字是不是匹配上了

29:27.240 --> 29:28.240
它以数字开头

29:29.240 --> 29:30.240
然后呢

29:30.240 --> 29:31.240
后标有可能是啥呢

29:32.240 --> 29:34.240
这个1开始是一个数字开头

29:34.240 --> 29:35.240
这个数字是不是有可能

29:35.240 --> 29:36.240
会出现一次或多次

29:36.240 --> 29:38.240
你看目前只匹配到一个数字

29:38.240 --> 29:39.240
对不对

29:40.240 --> 29:41.240
把后标去掉

29:41.240 --> 29:42.240
目前是不是只匹配到一个数字

29:42.240 --> 29:44.240
但我们要整个匹配进去

29:44.240 --> 29:45.240
因此它要匹配什么呢

29:45.240 --> 29:46.240
它以数字开头

29:46.240 --> 29:47.240
而且这个数字

29:47.240 --> 29:49.240
可能会出现一次或多次

29:49.240 --> 29:50.240
你要写个加号

29:52.680 --> 29:53.680
是不是这个可以匹配了

29:54.680 --> 29:55.680
它还没完

29:55.680 --> 29:56.680
有可能它有小数

29:57.680 --> 29:58.680
它有可能是这个样子

29:59.680 --> 30:00.680
你看它有可能是这个样子

30:00.680 --> 30:01.680
那这样子的话

30:01.680 --> 30:02.680
你只匹配了什么

30:02.680 --> 30:03.680
只匹配到前边

30:03.680 --> 30:04.680
没有匹配

30:04.680 --> 30:05.680
后边这一部分

30:05.680 --> 30:06.680
那么也就说

30:06.680 --> 30:07.680
后边这一部分

30:07.680 --> 30:09.680
它有可能会出现0次

30:10.680 --> 30:11.680
或一次

30:11.680 --> 30:12.680
就后边这一坨

30:12.680 --> 30:13.680
它有可能有

30:13.680 --> 30:14.680
有可能没有

30:14.680 --> 30:15.680
对吧

30:15.680 --> 30:16.680
有可能没有

30:17.680 --> 30:18.680
对

30:19.680 --> 30:20.680
后边这一坨

30:20.680 --> 30:21.680
它有可能没有

30:22.680 --> 30:23.680
也有可能有

30:23.680 --> 30:24.680
所以说后边

30:24.680 --> 30:25.680
我们用个扩幅

30:25.680 --> 30:26.680
把扩起来

30:26.680 --> 30:27.680
做一个分组

30:27.680 --> 30:28.680
后边扩幅里边

30:28.680 --> 30:29.680
有可能有

30:29.680 --> 30:30.680
有可能没有

30:31.680 --> 30:32.680
可能会0次

30:32.680 --> 30:33.680
或一次

30:33.680 --> 30:35.680
那里边该怎么写的

30:35.680 --> 30:36.680
里边它会出现什么

30:36.680 --> 30:37.680
出现一开始

30:37.680 --> 30:38.680
会出现一个底

30:39.680 --> 30:40.680
就要底是特殊制服

30:40.680 --> 30:41.680
你要转移

30:41.680 --> 30:42.680
它一开始

30:42.680 --> 30:43.680
可能会出现一个底

30:43.680 --> 30:44.680
你看看

30:44.680 --> 30:45.680
这里是不是出现一个底

30:45.680 --> 30:46.680
然后呢

30:46.680 --> 30:47.680
后边有可能会出现

30:47.680 --> 30:48.680
多个数字

30:49.680 --> 30:50.680
这一坨

30:50.680 --> 30:51.680
一个底跟上

30:51.680 --> 30:52.680
多个数字

30:52.680 --> 30:53.680
那么这一坨

30:53.680 --> 30:54.680
它可能会出现0次

30:54.680 --> 30:55.680
或一次

30:55.680 --> 30:56.680
就是匹配

30:56.680 --> 30:57.680
以数字开头的

30:57.680 --> 30:58.680
这么一个字不错

30:58.680 --> 30:59.680
你看是不是匹配

30:59.680 --> 31:00.680
刚好匹配到这

31:00.680 --> 31:01.680
比方说我们这里

31:01.680 --> 31:02.680
写个

31:02.680 --> 31:03.680
加上什么

31:03.680 --> 31:04.680
加上5

31:04.680 --> 31:05.680
减去

31:05.680 --> 31:06.680
我们只匹配开头

31:06.680 --> 31:07.680
只匹配开头

31:07.680 --> 31:08.680
是不把这个匹配上的

31:08.680 --> 31:09.680
对不对

31:09.680 --> 31:10.680
那么这是一个

31:10.680 --> 31:11.680
这是一个基础

31:11.680 --> 31:12.680
这个表的是

31:12.680 --> 31:13.680
如果还没学习的话

31:14.680 --> 31:15.680
最好是

31:15.680 --> 31:16.680
赶快把基础部分搞定吧

31:18.680 --> 31:19.680
扩号开始不管

31:19.680 --> 31:21.680
因为它只匹配数字

31:21.680 --> 31:22.680
扩号是什么

31:22.680 --> 31:23.680
扩号是符号

31:23.680 --> 31:24.680
符号是另外一个

31:24.680 --> 31:25.680
表达是匹配

31:25.680 --> 31:26.680
对吧

31:26.680 --> 31:27.680
那么我们数字的表达

31:27.680 --> 31:28.680
是匹配好了

31:28.680 --> 31:29.680
但是有可能

31:29.680 --> 31:30.680
它不是数字

31:30.680 --> 31:31.680
一开始

31:31.680 --> 31:32.680
它又可能是符号

31:32.680 --> 31:33.680
也说它只有两种情况

31:33.680 --> 31:34.680
这个表达是

31:34.680 --> 31:35.680
一开始要么是数字

31:35.680 --> 31:36.680
要么是符号

31:36.680 --> 31:37.680
对吧

31:37.680 --> 31:38.680
一开始要么是数字

31:38.680 --> 31:39.680
要么是符号

31:39.680 --> 31:40.680
它又可能是这个

31:40.680 --> 31:41.680
符号

31:41.680 --> 31:42.680
对不对

31:42.680 --> 31:43.680
我们说了

31:43.680 --> 31:44.680
我们还要写个

31:44.680 --> 31:45.680
写个重则表达

31:45.680 --> 31:46.680
是来匹配符号的

31:46.680 --> 31:47.680
叫做

31:47.680 --> 31:48.680
Operation

31:48.680 --> 31:49.680
或者叫OP吧

31:49.680 --> 31:50.680
Operation

31:50.680 --> 31:51.680
Expression

31:51.680 --> 31:52.680
这是匹配

31:53.680 --> 31:54.680
字符串

31:54.680 --> 31:55.680
开头的符号

31:55.680 --> 31:56.680
我们只匹配开头

32:00.400 --> 32:01.400
对了

32:03.400 --> 32:04.400
好

32:04.400 --> 32:05.400
符号一开始

32:05.400 --> 32:06.400
符号是什么

32:06.400 --> 32:07.400
符号就是那么几种

32:07.400 --> 32:08.400
对吧

32:08.400 --> 32:09.400
所以说

32:09.400 --> 32:10.400
我们用个中扩符

32:10.400 --> 32:11.400
扩起来

32:11.400 --> 32:12.400
就出现这个中扩符

32:12.400 --> 32:13.400
里面出现的符号

32:13.400 --> 32:14.400
任何一种都可以

32:14.400 --> 32:16.400
目前没有多个符号的情况

32:16.400 --> 32:17.400
我们只匹配一个符号

32:17.400 --> 32:18.400
符号有哪些

32:19.400 --> 32:20.400
有可能有

32:22.400 --> 32:23.400
有可能有扩号

32:24.400 --> 32:25.400
对不对

32:25.400 --> 32:26.400
有可能会有扩号

32:28.400 --> 32:29.400
有可能会有什么

32:29.400 --> 32:30.400
也有可能会有右扩号

32:30.400 --> 32:32.400
哪有可能这种情况

32:32.400 --> 32:33.400
哪有可能一开始

32:33.400 --> 32:34.400
字不出来是有右扩号的

32:34.400 --> 32:35.400
是这样子的

32:35.400 --> 32:36.400
因为我们每一次

32:36.400 --> 32:37.400
从字不出来

32:37.400 --> 32:38.400
开头去取

32:38.400 --> 32:39.400
比方取完一个

32:39.400 --> 32:40.400
我就把开头给它删了

32:41.400 --> 32:42.400
又取下一个

32:42.400 --> 32:43.400
所以从开头取

32:43.400 --> 32:44.400
又删了

32:44.400 --> 32:45.400
再取下一个

32:45.400 --> 32:46.400
又删了

32:46.400 --> 32:47.400
再取下一个

32:47.400 --> 32:48.400
又删了

32:48.400 --> 32:49.400
再取下一个

32:49.400 --> 32:50.400
又删了

32:50.400 --> 32:51.400
是这么一个意思

32:51.400 --> 32:52.400
所以说

32:52.400 --> 32:53.400
我们始终是取

32:53.400 --> 32:54.400
这个字不出来

32:54.400 --> 32:55.400
开头的那部分

32:55.400 --> 32:56.400
它有可能

32:56.400 --> 32:57.400
有任何的符号

32:57.400 --> 32:58.400
它有可能有

32:58.400 --> 32:59.400
有可能有扩符

32:59.400 --> 33:00.400
左扩符

33:00.400 --> 33:01.400
有可能有右扩符

33:01.400 --> 33:02.400
对吧

33:02.400 --> 33:03.400
都有可能会有

33:03.400 --> 33:04.400
还有可能会出现什么

33:04.400 --> 33:06.400
还有可能会出现加号

33:06.400 --> 33:07.400
比方说这种情况

33:07.400 --> 33:08.400
出现一个加号

33:08.400 --> 33:10.400
还有可能会出现一个什么

33:10.400 --> 33:11.400
减号

33:12.400 --> 33:14.400
出现一个减号

33:14.400 --> 33:16.400
还有可能会出现一个乘号

33:16.400 --> 33:17.400
你看加了这个乘号过后

33:17.400 --> 33:18.400
这里就出现问题了

33:18.400 --> 33:19.400
减号匹配不到了

33:19.400 --> 33:20.400
是因为这个减号

33:20.400 --> 33:22.400
有特殊含义

33:22.400 --> 33:23.400
而且这个小库号

33:23.400 --> 33:24.400
也匹配不到了

33:24.400 --> 33:25.400
因为它有特殊含义

33:25.400 --> 33:26.400
所以我们最好把这些东西

33:26.400 --> 33:27.400
都转移

33:27.400 --> 33:28.400
它是一个普通的左扩号

33:28.400 --> 33:30.400
一个普通的右扩号

33:30.400 --> 33:31.400
一个普通的加号

33:31.400 --> 33:32.400
一个普通的减号

33:32.400 --> 33:34.400
一个普通的新号

33:35.400 --> 33:36.400
那么这样子

33:36.400 --> 33:37.400
就避免这个奇异

33:37.400 --> 33:38.400
减号是不是能匹配了

33:38.400 --> 33:39.400
还有可能会出现

33:39.400 --> 33:41.400
加减乘除

33:41.400 --> 33:43.400
除号是不是一个写杠

33:43.400 --> 33:44.400
都进行转移

33:44.400 --> 33:45.400
然后还有一个什么

33:45.400 --> 33:46.400
求予

33:46.400 --> 33:47.400
求予是不是百分号

33:47.400 --> 33:49.400
无非就是这么几种符号

33:49.400 --> 33:50.400
我们把这些符号

33:50.400 --> 33:51.400
全部匹配到

33:51.400 --> 33:52.400
你看现在能不能匹配

33:52.400 --> 33:53.400
减号能不能匹配了吧

33:53.400 --> 33:55.400
左扩号能不能匹配了吧

33:55.400 --> 33:57.400
右扩号能不能匹配了吧

33:57.400 --> 33:58.400
你看

33:58.400 --> 33:59.400
然后呢

33:59.400 --> 34:00.400
加号

34:00.400 --> 34:01.400
减号

34:01.400 --> 34:02.400
乘号

34:02.400 --> 34:04.400
乘号

34:04.400 --> 34:05.400
除号

34:05.400 --> 34:06.400
求予

34:06.400 --> 34:07.400
都能匹配了

34:07.400 --> 34:08.400
这是匹配符号的

34:08.400 --> 34:09.400
好

34:09.400 --> 34:10.400
两个表达是匹配好了

34:10.400 --> 34:11.400
一个是匹配

34:11.400 --> 34:12.400
数字

34:13.400 --> 34:14.400
一个是匹配

34:14.400 --> 34:15.400
字符

34:16.400 --> 34:17.400
准备好

34:17.400 --> 34:18.400
接下来

34:18.400 --> 34:19.400
准备了半天

34:19.400 --> 34:20.400
还把证则表达试写完

34:20.400 --> 34:21.400
还没有去做这个

34:21.400 --> 34:22.400
下一个

34:22.400 --> 34:24.400
这个还说干嘛

34:24.400 --> 34:25.400
说白了

34:25.400 --> 34:26.400
这个还说

34:26.400 --> 34:27.400
就要做的事情

34:27.400 --> 34:28.400
就一件事情

34:28.400 --> 34:29.400
从

34:29.400 --> 34:31.400
支付串S

34:31.400 --> 34:33.400
开头的位置

34:33.400 --> 34:37.970
取一个符号

34:37.970 --> 34:39.970
或者是数字

34:39.970 --> 34:41.970
就要做这么一件事

34:41.970 --> 34:43.970
而支付串开头的位置

34:43.970 --> 34:44.970
要么就是符号

34:44.970 --> 34:45.970
要么就是数字

34:45.970 --> 34:46.970
它没有别的情况了

34:46.970 --> 34:48.970
空白支付已经去掉了

34:48.970 --> 34:49.970
它只有这种情况了

34:49.970 --> 34:51.970
其他的那些非法支付

34:51.970 --> 34:52.970
就是

34:52.970 --> 34:54.970
一些乱七八糟的中文在里边

34:54.970 --> 34:55.970
我们就不管了

34:55.970 --> 34:56.970
我们认为它是一个合法的

34:56.970 --> 34:57.970
证则表达试

34:57.970 --> 34:59.970
我们不去做任何的验证

34:59.970 --> 35:01.970
那些验证的事情

35:01.970 --> 35:02.970
也挺复杂的

35:02.970 --> 35:03.970
我们这里

35:03.970 --> 35:04.970
就是取他的符号

35:04.970 --> 35:05.970
那怎么取呢

35:05.970 --> 35:06.970
首先

35:06.970 --> 35:07.970
判断一下

35:07.970 --> 35:08.970
这个支付串还有没有

35:08.970 --> 35:09.970
就取完没

35:09.970 --> 35:10.970
因为这个支付串取一段

35:10.970 --> 35:11.970
三一段取一段三一段

35:11.970 --> 35:12.970
有可能又取没了

35:12.970 --> 35:13.970
对吧

35:13.970 --> 35:14.970
啥都没了

35:14.970 --> 35:15.970
所以说呢

35:15.970 --> 35:16.970
如果说这个支付串

35:16.970 --> 35:17.970
已经取没了

35:17.970 --> 35:19.970
支付串S

35:19.970 --> 35:20.970
等于0

35:20.970 --> 35:22.970
支付串没东西了

35:22.970 --> 35:24.970
支付串没东西了

35:24.970 --> 35:26.970
没东西了怎么办

35:26.970 --> 35:27.970
就返回了

35:27.970 --> 35:28.970
你看我们之前的要求

35:28.970 --> 35:29.970
不是这样吗

35:29.970 --> 35:30.970
没有东西了

35:30.970 --> 35:32.970
取完了就返回了

35:32.970 --> 35:33.970
对吧

35:33.970 --> 35:34.970
好否则的话

35:34.970 --> 35:35.970
有东西

35:35.970 --> 35:36.970
怎么办

35:36.970 --> 35:37.970
有东西

35:37.970 --> 35:38.970
首先看一下

35:38.970 --> 35:39.970
他是不是数字

35:39.970 --> 35:40.970
不是数字就是符号

35:40.970 --> 35:41.970
对吧

35:41.970 --> 35:42.970
他还能有啥

35:42.970 --> 35:43.970
不是数字就是符号

35:43.970 --> 35:44.970
其实这个表达

35:44.970 --> 35:45.970
我觉得都没有必要要了

35:45.970 --> 35:46.970
要么就是数字

35:46.970 --> 35:47.970
要么就是符号

35:47.970 --> 35:48.970
不是数字就是符号

35:48.970 --> 35:49.970
对吧

35:49.970 --> 35:50.970
就这个表达

35:50.970 --> 35:51.970
我觉得都没有什么要了

35:51.970 --> 35:52.970
必要了

35:52.970 --> 35:53.970
你看之前没有考虑到

35:53.970 --> 35:54.970
现在考虑到了

35:54.970 --> 35:55.970
其实没必要的

35:55.970 --> 35:56.970
好那么我们就用

35:56.970 --> 35:57.970
这个挣着表达

35:57.970 --> 35:58.970
去匹配一下

35:58.970 --> 35:59.970
怎么匹配

35:59.970 --> 36:00.970
我们是不是可以用march

36:00.970 --> 36:02.970
什么叫march

36:02.970 --> 36:06.280
看一下吧

36:06.280 --> 36:08.280
我用个字母串

36:08.280 --> 36:10.280
我们去march一下

36:10.280 --> 36:12.280
这是个我们挣的表达式

36:12.280 --> 36:14.280
我们现在把挣的表达式写

36:14.280 --> 36:16.280
可以写

36:16.280 --> 36:17.280
挣的表达式

36:17.280 --> 36:18.280
然后我用个字母串

36:18.280 --> 36:20.280
字母串是这个

36:20.280 --> 36:22.280
就这个吧

36:22.280 --> 36:24.280
就这个吧

36:24.280 --> 36:25.280
就这个

36:25.280 --> 36:26.280
23.4

36:26.280 --> 36:31.340
好

36:31.340 --> 36:32.340
我们希望了

36:32.340 --> 36:33.340
通过这个字母串

36:33.340 --> 36:35.340
去匹配这个挣的表达式

36:35.340 --> 36:36.340
对吧

36:36.340 --> 36:37.340
反过来

36:37.340 --> 36:38.340
用这个挣的表达式

36:38.340 --> 36:39.340
去匹配这个字母串

36:39.340 --> 36:40.340
匹配的结果

36:40.340 --> 36:42.340
给我一下

36:42.340 --> 36:43.340
怎么来的

36:43.340 --> 36:45.340
是不是s点march

36:45.340 --> 36:46.340
对吧

36:46.340 --> 36:47.340
把挣的表达式

36:47.340 --> 36:48.340
传进去

36:48.340 --> 36:49.340
所以匹配

36:49.340 --> 36:50.340
你看反回的结果

36:50.340 --> 36:51.340
就匹配出来了

36:51.340 --> 36:52.340
匹配出来一个什么

36:52.340 --> 36:55.340
23.4

36:55.340 --> 36:56.340
对不对

36:56.340 --> 36:57.340
后边的东西不用管

36:57.340 --> 36:58.340
我们只看第一个

36:58.340 --> 36:59.340
是不是匹配出来23.4

36:59.340 --> 37:00.340
匹配出来了

37:00.340 --> 37:01.340
它如果说

37:01.340 --> 37:03.340
一开始它不是一个数字

37:03.340 --> 37:04.340
一开始它可能是这样子的

37:04.340 --> 37:05.340
可能是一个扩耗

37:05.340 --> 37:07.340
1加2

37:07.340 --> 37:08.340
那么现在

37:08.340 --> 37:09.340
就匹配一下

37:09.340 --> 37:11.340
匹配数字

37:11.340 --> 37:12.340
是不是匹配出来就是闹

37:12.340 --> 37:13.340
对吧

37:13.340 --> 37:14.340
那么我们就可以

37:14.340 --> 37:15.340
通过它匹配出来的结果

37:15.340 --> 37:16.340
来看一下

37:16.340 --> 37:18.340
它到底是匹配上了呀

37:18.340 --> 37:19.340
还是没有匹配上

37:19.340 --> 37:20.340
没有匹配上

37:20.340 --> 37:22.720
一开始就是符号

37:22.720 --> 37:23.720
不用去记

37:23.720 --> 37:25.720
看代码一定不能去记

37:25.720 --> 37:26.720
你要在记

37:26.720 --> 37:27.720
就在背代码了

37:27.720 --> 37:28.720
也背不住的

37:28.720 --> 37:29.720
你就算真

37:29.720 --> 37:30.720
专心知识的

37:30.720 --> 37:31.720
去背每一行写来打

37:31.720 --> 37:32.720
你也背不住的

37:32.720 --> 37:33.720
一定要去听诗路

37:33.720 --> 37:37.990
听这种感觉

37:37.990 --> 37:38.990
对

37:38.990 --> 37:39.990
还有一个复述的情况

37:39.990 --> 37:40.990
对

37:40.990 --> 37:41.990
忘了

37:41.990 --> 37:43.990
忘了还有一个复述的情况

37:43.990 --> 37:45.990
谢谢那个

37:45.990 --> 37:47.990
王志鸿同学

37:47.990 --> 37:48.990
对

37:48.990 --> 37:49.990
那么复述的这么个表达

37:49.990 --> 37:50.990
稍微改一下

37:50.990 --> 37:51.990
就它一开始

37:51.990 --> 37:55.690
它有可能是一个简号

37:55.690 --> 37:57.690
它出现零次或一次

37:57.690 --> 37:58.690
你看一下

37:58.690 --> 37:59.690
这种表达是

37:59.690 --> 38:00.690
一开始

38:00.690 --> 38:01.690
它有可能是一个简号

38:01.690 --> 38:02.690
出现零次或一次

38:02.690 --> 38:03.690
有可能是这种情况

38:03.690 --> 38:04.690
它也能匹配上

38:04.690 --> 38:05.690
有这个简号

38:05.690 --> 38:06.690
没这个简号都可以

38:06.690 --> 38:07.690
是吧

38:07.690 --> 38:08.690
还有复述

38:08.690 --> 38:09.690
忘了

38:09.690 --> 38:10.690
差点忘了

38:10.690 --> 38:11.690
好

38:11.690 --> 38:12.690
怎么能匹配它

38:12.690 --> 38:14.690
它要么就是

38:14.690 --> 38:15.690
要么就是数字

38:15.690 --> 38:21.510
要么就是一个符号

38:21.510 --> 38:22.510
对吧

38:22.510 --> 38:23.510
好

38:23.510 --> 38:24.510
这么一个东西

38:24.510 --> 38:28.210
好

38:28.210 --> 38:29.210
对

38:29.210 --> 38:30.210
还有同学就说

38:30.210 --> 38:31.210
这个简号

38:31.210 --> 38:32.210
它有可能是一个符号

38:32.210 --> 38:34.210
有可能是一个

38:34.210 --> 38:35.210
有可能是一个符号

38:35.210 --> 38:36.210
有可能是一个数字

38:36.210 --> 38:38.210
那么这个问题

38:38.210 --> 38:39.210
我想一想

38:39.210 --> 38:43.210
我一开始把它当成一个

38:43.210 --> 38:44.210
这个问题

38:44.210 --> 38:45.210
还有点麻烦

38:45.210 --> 38:47.210
因为这个问题还涉及到

38:47.210 --> 38:49.210
你这个表达是怎么去

38:49.210 --> 38:52.710
怎么去认为

38:52.710 --> 38:53.710
我目前的设计人

38:53.710 --> 38:55.710
是没有考虑这个问题的

38:55.710 --> 38:58.710
就这种情况你怎么去看

38:58.710 --> 39:00.710
这种情况你怎么去看

39:00.710 --> 39:01.710
这种情况

39:01.710 --> 39:03.710
你要把它看成符号

39:03.710 --> 39:05.710
你要把它看成一个

39:05.710 --> 39:06.710
它去到空格之后

39:06.710 --> 39:08.710
是这个样子

39:08.710 --> 39:09.710
去到空格之后是这个样子

39:09.710 --> 39:11.710
你要把它看成符号

39:11.710 --> 39:12.710
要把它看成

39:12.710 --> 39:13.710
看成是什么

39:14.710 --> 39:16.710
原来的意思

39:16.710 --> 39:17.710
要把它看成一个数字

39:17.710 --> 39:18.710
那这种情况

39:18.710 --> 39:19.710
我们不考虑吧

39:19.710 --> 39:20.710
不考虑吧

39:20.710 --> 39:21.710
如果说要考虑这种情况的话

39:21.710 --> 39:22.710
我们这一块的

39:22.710 --> 39:24.710
就是这个的代码要改

39:24.710 --> 39:26.710
代码会改得比较复杂

39:26.710 --> 39:28.710
目前复杂还不是在做

39:28.710 --> 39:31.710
还不是去做这件事情

39:31.710 --> 39:33.710
这种情况会把它变得非常复杂

39:33.710 --> 39:34.710
以后我完了过后

39:34.710 --> 39:35.710
给大家说一下思路吧

39:35.710 --> 39:36.710
就这个东西

39:36.710 --> 39:38.710
该怎么去做

39:38.710 --> 39:39.710
那么这个东西

39:39.710 --> 39:40.710
你就不能用一个 next 函数了

39:40.710 --> 39:42.710
你至少要分成两个函数

39:42.710 --> 39:44.710
一个是 next number

39:44.710 --> 39:46.710
一个是 next operator

39:46.710 --> 39:48.710
要让外部的人来控制

39:48.710 --> 39:50.710
他到底期望得到的是符号

39:50.710 --> 39:52.710
还是得到的是数字

39:52.710 --> 39:53.710
原来的意思吧

39:53.710 --> 39:54.710
要让外面的人期望

39:54.710 --> 39:55.710
他得到的是数字

39:55.710 --> 39:56.710
我就按着数字去去

39:56.710 --> 39:58.710
期望他得到的是符号

39:58.710 --> 39:59.710
就按照符号去去

39:59.710 --> 40:00.710
那么这样的

40:00.710 --> 40:01.710
会把这个事情变得复杂

40:01.710 --> 40:03.710
我们现在不考虑这个情况吧

40:03.710 --> 40:04.710
不考虑这个

40:04.710 --> 40:05.710
不考虑这个复杂的情况

40:05.710 --> 40:06.710
以后完了过后

40:06.710 --> 40:07.710
我给大家说一下吧

40:07.710 --> 40:08.710
复杂的情况

40:08.710 --> 40:09.710
怎么去复杂

40:09.710 --> 40:13.220
我们现在不考虑复杂

40:13.220 --> 40:14.220
就考虑正数

40:14.220 --> 40:15.220
好

40:15.220 --> 40:16.220
接下来我们这个 next 函数

40:16.220 --> 40:17.220
我们现在如果说

40:17.220 --> 40:18.220
字无算已经没东西了

40:18.220 --> 40:19.220
那肯定是取不出来了

40:19.220 --> 40:21.220
那如果说有东西呢

40:21.220 --> 40:22.220
按照我们刚才说的

40:22.220 --> 40:28.280
匹配不上符号

40:28.280 --> 40:29.280
匹配不上那个数字

40:29.280 --> 40:30.280
那就是符号

40:30.280 --> 40:31.280
好

40:31.280 --> 40:32.280
来吧

40:32.280 --> 40:33.280
来匹配一下

40:33.280 --> 40:34.280
我们用什么匹配

40:34.280 --> 40:37.280
是用 this.s.march

40:37.280 --> 40:38.280
匹配啥

40:38.280 --> 40:39.280
匹配的数字

40:39.280 --> 40:41.280
number expression

40:41.280 --> 40:42.280
匹配的数字

40:42.280 --> 40:43.280
得到一个什么结果呢

40:43.280 --> 40:44.280
得到一个march

40:44.280 --> 40:46.280
得到一个匹配结果

40:46.280 --> 40:49.280
尝试着匹配什么

40:49.280 --> 40:51.280
匹配数字

40:51.280 --> 40:53.280
尝试匹配数字

40:53.280 --> 40:55.280
如果说没有匹配上

40:55.280 --> 40:57.280
就是有可能有两种情况

40:57.280 --> 40:58.280
一种是匹配上了

40:58.280 --> 40:59.280
一种是没有匹配上

40:59.280 --> 41:00.280
如果说没有匹配上

41:00.280 --> 41:02.280
说明啥呀

41:02.280 --> 41:05.280
说明下一个是符号

41:05.280 --> 41:06.280
是不是下一个是符号

41:06.280 --> 41:07.280
那么我们用一个变量来

41:07.280 --> 41:08.280
记录一下

41:08.280 --> 41:09.280
下一个东西到底是啥

41:09.280 --> 41:11.280
without

41:11.280 --> 41:13.280
记录一下

41:13.280 --> 41:15.280
下一个东西

41:15.280 --> 41:17.280
如果说下一个是符号的话

41:17.280 --> 41:18.280
我应该给他什么

41:18.280 --> 41:19.280
就是给他这么一个东西

41:19.280 --> 41:20.280
一个对象

41:20.280 --> 41:21.280
告诉他是一个符号

41:21.280 --> 41:23.280
他的纸呢是一个这个东西

41:23.280 --> 41:24.280
好,所以说我们这里的

41:24.280 --> 41:28.810
定一个 result

41:28.810 --> 41:30.810
好,这里边我们写两个属性

41:30.810 --> 41:31.810
一个是 type

41:31.810 --> 41:32.810
他的 nation 是一个 operator

41:32.810 --> 41:34.810
是一个符号

41:34.810 --> 41:35.810
好 value

41:35.810 --> 41:36.810
他的纸呢是一个什么呢

41:36.810 --> 41:38.810
是一个

41:38.810 --> 41:39.810
是啥呀

41:39.810 --> 41:41.810
他如果说是一个符号的话

41:41.810 --> 41:43.810
是不是就是字不出的

41:43.810 --> 41:44.810
第一个单词

41:44.810 --> 41:45.810
就是字

41:45.810 --> 41:46.810
如果说他一开始是一个符号

41:46.810 --> 41:48.810
比方说一开始是这个

41:48.810 --> 41:49.810
是不是他就是字不出的

41:49.810 --> 41:50.810
第一个单词

41:50.810 --> 41:51.810
对吧

41:51.810 --> 41:52.810
刚才同学提醒的好

41:52.810 --> 41:53.810
有可能是付出的情况

41:53.810 --> 41:54.810
还要复杂一些

41:54.810 --> 41:55.810
然后呢

41:55.810 --> 41:56.810
如果说是个加号的话

41:56.810 --> 41:57.810
他有可能是表示是正数

41:57.810 --> 41:58.810
他有可能是这个样子

41:58.810 --> 42:00.810
他表示是加上一个正数

42:00.810 --> 42:01.810
对吧

42:01.810 --> 42:03.810
那个情况还要复杂一些

42:03.810 --> 42:05.810
我以后完了时候

42:05.810 --> 42:07.810
给他说一下吧

42:07.810 --> 42:08.810
好,value

42:08.810 --> 42:09.810
我们不考虑这些情况

42:09.810 --> 42:10.810
不考虑前面符号的问题

42:10.810 --> 42:11.810
value 是什么呢

42:11.810 --> 42:12.810
value 就是他的

42:12.810 --> 42:14.810
第一个字符

42:14.810 --> 42:15.810
什么符

42:15.810 --> 42:16.810
什么字符呢

42:16.810 --> 42:18.810
就是

42:18.810 --> 42:22.340
字符创

42:22.340 --> 42:24.340
ZS.0

42:24.340 --> 42:25.340
什么这样子

42:25.340 --> 42:26.340
下一个就是符号

42:26.340 --> 42:27.340
比方这个东西下一个是符号

42:27.340 --> 42:28.340
是不是就是个字符创的

42:28.340 --> 42:29.340
第一个位置

42:29.340 --> 42:30.340
对吧

42:30.340 --> 42:32.340
好,这是符号的情况

42:32.340 --> 42:34.340
l 就是表什么意思

42:34.340 --> 42:36.340
表是下一个是数字

42:36.340 --> 42:37.340
下一个是数字的话

42:37.340 --> 42:38.340
我们就知道

42:38.340 --> 42:39.340
应该等于什么呢

42:39.340 --> 42:40.340
等于type

42:40.340 --> 42:41.340
等于number

42:41.340 --> 42:42.340
你看我们这里的要求

42:42.340 --> 42:43.340
他是数字的话

42:43.340 --> 42:44.340
type为number

42:44.340 --> 42:45.340
value 呢

42:45.340 --> 42:46.340
应该是什么呢

42:47.340 --> 42:48.340
看一下刚才

42:48.340 --> 42:51.340
S的值

42:51.340 --> 42:53.340
march

42:53.340 --> 42:55.340
他匹配出来是不是一个数组啊

42:55.340 --> 42:56.340
这个march

42:56.340 --> 42:58.340
就这个玩意是不是一个数组

42:58.340 --> 43:00.340
这个玩意是不是一个数组

43:00.340 --> 43:01.340
这个数组的第一项

43:01.340 --> 43:03.340
是不是就是那个数字

43:03.340 --> 43:05.340
什么就是匹配出来的数字

43:05.340 --> 43:06.340
对不对

43:06.340 --> 43:07.340
好,所以说呢

43:07.340 --> 43:08.340
这一块呢

43:08.340 --> 43:10.340
我们可以用个加号

43:10.340 --> 43:12.340
把它变成一个数字

43:12.340 --> 43:14.340
也就是march

43:14.340 --> 43:18.610
march0

43:18.610 --> 43:20.610
把它变成数字

43:20.610 --> 43:21.610
要么就是符号

43:21.610 --> 43:23.610
要么就是数字

43:23.610 --> 43:24.610
好,匹配完了过后

43:24.610 --> 43:26.610
甭管你是一个符号

43:26.610 --> 43:29.610
还是说你是一个数字

43:29.610 --> 43:30.610
是不是那个东西

43:30.610 --> 43:31.610
我都不要了呀

43:31.610 --> 43:32.610
我只要后边这一坨标

43:32.610 --> 43:33.610
一开始匹配出来

43:33.610 --> 43:34.610
这么一个玩意

43:34.610 --> 43:35.610
那这一坨我就不要了

43:35.610 --> 43:36.610
我只要后边这一部分

43:36.610 --> 43:38.610
是不是我要更改这个s

43:38.610 --> 43:40.610
s 要等于什么呢

43:40.610 --> 43:42.610
要更改成为

43:42.610 --> 43:44.610
原来的东西

43:44.610 --> 43:53.740
substream

43:53.740 --> 43:55.740
分开来写吧

43:55.740 --> 43:56.740
如果说你是符号的话

43:56.740 --> 43:57.740
我们是不是就去掉

43:57.740 --> 43:58.740
第一个字符

43:58.740 --> 44:01.740
是不是从位置一开始去

44:01.740 --> 44:03.740
对吧

44:03.740 --> 44:05.740
如果说一开始是一个符号

44:05.740 --> 44:06.740
比方说我们把

44:06.740 --> 44:07.740
已经到这了

44:07.740 --> 44:08.740
那么我们把这个去掉

44:08.740 --> 44:09.740
是不是从这里开始去

44:09.740 --> 44:11.740
去后面这一坨

44:11.740 --> 44:12.740
对不对

44:12.740 --> 44:13.740
好,如果说下一个

44:13.740 --> 44:14.740
不是符号

44:14.740 --> 44:15.740
是一个数字的话

44:15.740 --> 44:16.740
那么它的s呢

44:16.740 --> 44:17.740
应该等于什么呢

44:17.740 --> 44:20.630
s substream

44:20.630 --> 44:22.630
去掉前面几个

44:22.630 --> 44:23.630
是不是这个匹配的

44:23.630 --> 44:24.630
数字有几个

44:24.630 --> 44:25.630
比方这个匹配到这个数字

44:25.630 --> 44:27.630
当数字长度为3

44:27.630 --> 44:28.630
那么就从第四个位

44:28.630 --> 44:30.630
就从下标为3的位置

44:30.630 --> 44:31.630
开始去

44:31.630 --> 44:32.630
从这里开始去

44:32.630 --> 44:33.630
那么是不是该这么写

44:33.630 --> 44:35.630
march 理由表面

44:35.630 --> 44:38.630
是不是这样

44:38.630 --> 44:39.630
好,最后呢

44:39.630 --> 44:41.630
我们返回

44:41.630 --> 44:42.630
你知道

44:42.630 --> 44:43.630
那么这个lux

44:43.630 --> 44:44.630
还是说就写好了

44:44.630 --> 44:45.630
好,现在呢

44:45.630 --> 44:46.630
我要让你们看得清楚

44:46.630 --> 44:47.630
这个执行的过程

44:47.630 --> 44:48.630
首先运行一下吧

44:48.630 --> 44:49.630
看对不对

44:49.630 --> 44:51.630
啊,装扣的

44:51.630 --> 44:53.630
你看,是不是对了

44:53.630 --> 44:54.630
它取出来分别是

44:54.630 --> 44:55.630
2.5 数字

44:55.630 --> 44:56.630
乘号

44:56.630 --> 44:57.630
operator

44:57.630 --> 44:58.630
呃

44:58.630 --> 45:00.630
这一块 operator

45:00.630 --> 45:01.630
呃,然后呢

45:01.630 --> 45:02.630
2

45:02.630 --> 45:03.630
number

45:03.630 --> 45:04.630
加号

45:04.630 --> 45:05.630
操作符

45:05.630 --> 45:06.630
3

45:06.630 --> 45:07.630
数字

45:07.630 --> 45:08.630
货号

45:08.630 --> 45:09.630
操作符

45:09.630 --> 45:10.630
结束了

45:10.630 --> 45:11.630
后面成当了

45:11.630 --> 45:12.630
好,如果说呢

45:12.630 --> 45:14.630
我们来调试一下

45:14.630 --> 45:15.630
看它到底是怎么执行的

45:15.630 --> 45:16.630
我们可以在这里

45:16.630 --> 45:17.630
打个断解

45:17.630 --> 45:19.630
运行,看一下

45:19.630 --> 45:21.630
看吧

45:21.630 --> 45:24.630
目前这个s

45:24.630 --> 45:27.630
目前这个s

45:27.630 --> 45:28.630
是不是这个

45:28.630 --> 45:29.630
这个支付圈

45:29.630 --> 45:30.630
好,我们尝试去匹配

45:30.630 --> 45:31.630
好,匹配出来了

45:31.630 --> 45:32.630
现在有匹配出来了吗

45:32.630 --> 45:33.630
是不是匹配出来了

45:33.630 --> 45:34.630
2.5

45:34.630 --> 45:35.630
对吧

45:35.630 --> 45:36.630
诶,你发现

45:36.630 --> 45:37.630
这个刊断进不了

45:37.630 --> 45:38.630
它不是符号

45:38.630 --> 45:39.630
它是数字

45:39.630 --> 45:40.630
于是呢,进入这个

45:40.630 --> 45:41.630
我们生成一个对象

45:41.630 --> 45:42.630
在对象里边

45:42.630 --> 45:43.630
告诉它

45:43.630 --> 45:44.630
我们的类型是number

45:44.630 --> 45:45.630
数字呢,是2.5

45:45.630 --> 45:46.630
把它转换成数字

45:46.630 --> 45:47.630
转成数字类型

45:47.630 --> 45:48.630
然后把这个s

45:48.630 --> 45:49.630
这个支付圈

45:49.630 --> 45:50.630
结去一下

45:50.630 --> 45:51.630
长度多少

45:51.630 --> 45:52.630
长度为3

45:52.630 --> 45:53.630
march的0

45:53.630 --> 45:54.630
是不是2.5

45:54.630 --> 45:55.630
这个支付圈

45:55.630 --> 45:56.630
长度为3

45:56.630 --> 45:57.630
从下边为3的位置

45:57.630 --> 45:58.630
开始取

45:58.630 --> 45:59.630
以取出来重新复制

45:59.630 --> 46:00.630
这个s是不是少了

46:00.630 --> 46:01.630
前面那一坨就没了

46:01.630 --> 46:03.630
对吧,只剩下这个了

46:03.630 --> 46:05.630
好,那么第一步是不是取完了

46:05.630 --> 46:06.630
接下来,我们下一次

46:06.630 --> 46:07.630
下一次再取的时候

46:07.630 --> 46:09.630
s的纸呢,变成这个样子了

46:09.630 --> 46:10.630
那么又尝试的

46:10.630 --> 46:11.630
用数字去匹配

46:11.630 --> 46:12.630
匹配出来了吗

46:12.630 --> 46:13.630
是不是匹配不出来

46:13.630 --> 46:14.630
匹配不出来

46:14.630 --> 46:15.630
它就是符号

46:15.630 --> 46:16.630
于是呢,得到这个

46:16.630 --> 46:17.630
得到一个符号

46:17.630 --> 46:18.630
乘号

46:18.630 --> 46:19.630
operator

46:19.630 --> 46:20.630
好,最后呢

46:20.630 --> 46:21.630
我们把这个s呢

46:21.630 --> 46:22.630
重新复制

46:22.630 --> 46:23.630
在这

46:24.630 --> 46:25.630
好

46:26.630 --> 46:29.390
符号

46:29.390 --> 46:30.390
对了,没问题

46:30.390 --> 46:31.390
在这

46:31.390 --> 46:32.390
你看,是不是乘号没了

46:35.220 --> 46:36.220
看一下前面

46:36.220 --> 46:37.220
这个z

46:37.220 --> 46:39.220
你看,s是不是乘号没了

46:39.220 --> 46:41.220
好,再一下一次呢

46:41.220 --> 46:43.220
就是取出了个扩号

46:43.220 --> 46:44.220
数字匹配不上

46:44.220 --> 46:45.220
这个march

46:45.220 --> 46:46.220
没有值

46:46.220 --> 46:48.220
然后呢

46:48.220 --> 46:49.220
再往下走

46:49.220 --> 46:51.220
说生成一个result

46:51.220 --> 46:52.220
operator

46:52.220 --> 46:53.220
小扩号

46:53.220 --> 46:54.220
然后把s重新复制

46:54.220 --> 46:55.220
是不是扩号没了

46:55.220 --> 46:56.220
就这样子

46:56.220 --> 46:57.220
一步一步把它

46:57.220 --> 46:58.220
整个字不出来

46:58.220 --> 46:59.220
全部匹配出来

46:59.220 --> 47:00.220
这是我们那个扫描器

47:00.220 --> 47:01.220
这个扫描器呢

47:01.220 --> 47:02.220
刚才有同学提醒了

47:02.220 --> 47:03.220
好啊

47:03.220 --> 47:04.220
没有考虑复数的问题

47:04.220 --> 47:05.220
确实呢

47:05.220 --> 47:06.220
我这个备课的时候

47:06.220 --> 47:07.220
我也确实没有考虑

47:07.220 --> 47:10.220
那么要考虑复数的问题的话

47:10.220 --> 47:11.220
以后我可以跟你说一下

47:11.220 --> 47:12.220
其实呢

47:12.220 --> 47:13.220
复数的问题呢

47:13.220 --> 47:14.220
它涉及到另外一个东西

47:14.220 --> 47:15.220
就表示

47:15.220 --> 47:16.220
操作符的源

47:17.220 --> 47:19.220
操作符的源

47:20.220 --> 47:21.220
你们在学那个

47:21.220 --> 47:22.220
GS的时候

47:22.220 --> 47:23.220
是不是学过操作符啊

47:23.220 --> 47:24.220
就运算符

47:24.220 --> 47:26.220
运算符又加建成熟

47:26.220 --> 47:28.220
还有什么三目运算符

47:28.220 --> 47:29.220
其实还有这个运算符

47:29.220 --> 47:32.220
叫做正数和复数

47:32.220 --> 47:34.220
它们也是运算符

47:34.220 --> 47:35.220
它叫做一源运算符

47:35.220 --> 47:37.220
它长相一样的啊

47:37.220 --> 47:38.220
一源运算符

47:38.220 --> 47:40.220
那么这个涉及到源的话

47:40.220 --> 47:41.220
那就这个问题呢

47:41.220 --> 47:42.220
要把它做成一个

47:42.220 --> 47:43.220
通用性的表达

47:43.220 --> 47:44.220
是比较复杂的啊

47:44.220 --> 47:45.220
以后我可以跟大家说一下

47:45.220 --> 47:46.220
如果说源的话

47:46.220 --> 47:47.220
怎么来处理

47:54.060 --> 47:55.060
能把much

47:56.060 --> 47:57.060
改成replace

47:58.060 --> 47:59.060
然后反回之吗

48:02.060 --> 48:03.060
你用replace啊

48:05.560 --> 48:06.560
你用replace你

48:07.560 --> 48:08.560
替换成啥呀

48:08.560 --> 48:10.560
你要打算把它替换成啥呀

48:12.560 --> 48:13.560
替换成空置无窜

48:14.560 --> 48:15.560
但是你怎么制

48:16.560 --> 48:18.560
你是在用回调函数来写吗

48:20.560 --> 48:22.560
那样子反而比较麻烦一点吧

48:22.560 --> 48:24.560
你好好想一想呢

48:24.560 --> 48:25.560
你第一个掺书你

48:25.560 --> 48:27.560
肯定不能直接写个空置无窜啊

48:27.560 --> 48:28.560
因为你要写个回调函数啊

48:28.560 --> 48:29.560
不然的话你怎么知道

48:29.560 --> 48:31.560
你匹配的到底是啥呀

48:31.560 --> 48:32.560
你不知道你

48:32.560 --> 48:34.560
你不知道你匹配的到底是啥

48:34.560 --> 48:35.560
你怎么去放了

48:35.560 --> 48:38.510
放到这个位置呢

48:38.510 --> 48:40.510
匹配测试用了什么插件

48:40.510 --> 48:41.510
完了你每次问我插件

48:41.510 --> 48:42.510
我都急不住

48:45.510 --> 48:46.510
叫做

48:47.510 --> 48:48.510
叫做啥

48:48.510 --> 48:49.510
插件一会我给你查一查吧

48:49.510 --> 48:50.510
一会你记得问我一下

48:50.510 --> 48:51.510
下了课的时候

48:51.510 --> 48:52.510
记得问我一下

48:52.510 --> 48:53.510
我一会给你查一查吧

48:53.510 --> 48:54.510
我一忘了

48:55.510 --> 48:56.510
好了

48:56.510 --> 48:57.510
那么现在呢

48:57.510 --> 48:58.510
我们是不是把这个函数

48:58.510 --> 49:01.140
就写好了呀

49:01.140 --> 49:02.140
这个函数就写好了

49:03.140 --> 49:04.140
好

49:04.140 --> 49:05.140
这个函数呢

49:05.140 --> 49:06.140
其实有了

49:06.140 --> 49:07.140
有了这个

49:07.140 --> 49:08.140
够早函数的辅助之后啊

49:08.140 --> 49:10.140
其实我们可以用一个循环

49:10.140 --> 49:11.140
来把整个表拿出

49:11.140 --> 49:12.140
一个一个拿出来

49:12.140 --> 49:13.140
怎么循环呢

49:13.140 --> 49:14.140
其实看你非常简单

49:15.140 --> 49:16.140
我就写个变量

49:16.140 --> 49:17.140
n嘛

49:18.140 --> 49:19.140
然后写个yl循环

49:19.140 --> 49:21.140
n等于scanner

49:21.140 --> 49:22.140
那个是

49:22.140 --> 49:23.140
这个能看懂吗

49:23.140 --> 49:24.140
啥意思

49:24.140 --> 49:25.140
就是我取下一个

49:25.140 --> 49:26.140
下一个取

49:26.140 --> 49:27.140
从来复制给n

49:28.140 --> 49:29.140
然后顺便看一下

49:29.140 --> 49:30.140
这个表达是

49:30.140 --> 49:31.140
这个表达是什么

49:31.140 --> 49:32.140
这个表达就是

49:32.140 --> 49:33.140
这个预算结果

49:33.140 --> 49:34.140
你可以把你演成

49:34.140 --> 49:35.140
就是n

49:35.140 --> 49:36.140
看一下这个n有没有值

49:36.140 --> 49:37.140
有值的话

49:37.140 --> 49:38.140
是不是取出来了

49:38.140 --> 49:39.140
取出来下一个

49:39.140 --> 49:40.140
取出来下一个

49:40.140 --> 49:41.140
我就把下一个输出

49:41.140 --> 49:42.140
所以一个循环就可以搞定了

49:42.140 --> 49:43.140
然后刻了一看一下

49:44.140 --> 49:45.140
所以这样子呢

49:45.140 --> 49:46.140
就可以通过这个snext

49:46.140 --> 49:47.140
就可以拿到

49:47.140 --> 49:48.140
他整个表达

49:48.140 --> 49:49.140
里面每一块东西

49:49.140 --> 49:50.140
数字

49:50.140 --> 49:51.140
操作符

49:51.140 --> 49:52.140
操作符

49:52.140 --> 49:53.140
操作符

49:53.140 --> 49:54.140
数字操作符

49:54.140 --> 49:55.140
就一个个拿出来了

49:56.140 --> 49:58.140
那么这是一个扫描器

49:58.140 --> 49:59.140
又搞定了

50:00.140 --> 50:01.140
以后呢

50:01.140 --> 50:02.140
我们在这里期算的时候

50:02.140 --> 50:03.140
就一个一个拿出来看

50:04.140 --> 50:05.140
好接下来

50:05.140 --> 50:06.140
我们再来下一个

50:06.140 --> 50:07.140
现在我们有三个东西了

50:07.140 --> 50:09.140
一个是站

50:09.140 --> 50:10.140
人造

50:10.140 --> 50:12.140
一个是我们的操作符定义

50:12.140 --> 50:13.140
人造

50:13.140 --> 50:15.140
一个是我们的扫描器

50:15.140 --> 50:16.140
人造

50:16.140 --> 50:18.140
他们各自有各自的作用

50:18.140 --> 50:20.140
接下来进入到核心问题了

50:20.140 --> 50:22.140
就是处理预算逻辑

50:22.140 --> 50:23.140
那么处理预算逻辑

50:23.140 --> 50:25.140
用到的是逆波兰算法

50:25.140 --> 50:26.140
逆波兰算法

50:26.140 --> 50:27.140
把它展开说

50:27.140 --> 50:29.140
底边这些细节其实蛮多的

50:29.140 --> 50:30.140
就像刚才有人说的

50:30.140 --> 50:31.140
一个增数复数的问题

50:31.140 --> 50:32.140
其实也设计到这个问题

50:32.140 --> 50:34.140
就是操作数的源是多少

50:34.140 --> 50:36.140
你到底这个操作符

50:36.140 --> 50:37.140
因为像我们目前

50:37.140 --> 50:38.140
遇到的操作符都是二元吧

50:38.140 --> 50:39.140
对吧

50:39.140 --> 50:40.140
加号两个数吗

50:40.140 --> 50:41.140
乘号两个数

50:41.140 --> 50:42.140
都是二元的

50:42.140 --> 50:43.140
它有可能有一元的

50:43.140 --> 50:45.140
像增数复数就是一元的

50:46.140 --> 50:47.140
还有什么

50:47.140 --> 50:48.140
还有如果说家家

50:48.140 --> 50:49.140
减减的又是一元的

50:49.140 --> 50:51.140
那时候我们目前不设计

50:51.140 --> 50:52.140
还有什么呢

50:52.140 --> 50:53.140
还有三目运算符

50:53.140 --> 50:54.140
问号猫号来说是三元的

50:54.140 --> 50:55.140
所以还设计到一个

50:55.140 --> 50:56.140
操作数的源

50:56.140 --> 50:57.140
还设计到操作数

50:57.140 --> 50:59.140
到底是右结合还是左结合

50:59.140 --> 51:00.140
都比较麻烦

51:00.140 --> 51:02.140
比方说像乘号加号就左结合

51:02.140 --> 51:03.140
从做到右进行运算的

51:03.140 --> 51:05.140
还有一些操作符是右结合的

51:05.140 --> 51:06.140
比方说等号

51:06.140 --> 51:07.140
复值符号

51:07.140 --> 51:08.140
是不是往右边往左边算的

51:08.140 --> 51:09.140
对吧

51:09.140 --> 51:10.140
跟我还是都不一定的

51:10.140 --> 51:11.140
所以说

51:11.140 --> 51:12.140
这里比较问题比较复杂

51:12.140 --> 51:14.140
我们不用去考虑那么复杂的问题

51:14.140 --> 51:16.140
我们就考虑最简单的

51:16.140 --> 51:18.140
就是都是二元

51:18.140 --> 51:20.140
都是字面量

51:20.140 --> 51:21.140
甚至没有复数

51:21.140 --> 51:22.140
那么这个问题怎么处理

51:22.140 --> 51:24.840
怎么处理呢

51:24.840 --> 51:26.840
我这里给他做了一个演示稿

51:26.840 --> 51:28.840
首先看一下我们人怎么处理的

51:28.840 --> 51:30.840
人是怎么处理的呢

51:30.840 --> 51:31.840
你可能会觉得

51:31.840 --> 51:32.840
你先算扩号里边的

51:32.840 --> 51:34.840
但是如果说扩号多了

51:34.840 --> 51:35.840
扩号里边掏扩号的

51:35.840 --> 51:36.840
演用看花

51:36.840 --> 51:37.840
最好是怎么处理的

51:37.840 --> 51:38.840
最好我们要找到

51:38.840 --> 51:39.840
一种通用的规律

51:39.840 --> 51:42.840
就是你不用靠直觉

51:42.840 --> 51:44.840
你用这种办法

51:44.840 --> 51:45.840
无论怎么复杂的

51:45.840 --> 51:46.840
复杂的表达是

51:46.840 --> 51:47.840
都能算出来

51:47.840 --> 51:48.840
怎么算呢

51:48.840 --> 51:49.840
可以用这种方式来算

51:49.840 --> 51:50.840
看着我把折注

51:50.840 --> 51:52.840
从左到右进行看

51:52.840 --> 51:53.840
一个一个看

51:53.840 --> 51:55.840
首先看三

51:55.840 --> 51:56.840
是个数字

51:56.840 --> 51:57.840
一个数字能算吗

51:57.840 --> 51:59.840
没法算

51:59.840 --> 52:01.840
看一个下一个符号加

52:01.840 --> 52:02.840
能算吗

52:02.840 --> 52:03.840
没法算

52:03.840 --> 52:05.840
下一个数字能算吗

52:05.840 --> 52:06.840
现在能算

52:06.840 --> 52:09.790
能不能算

52:09.790 --> 52:12.620
现在能不能算

52:12.620 --> 52:13.620
端点吗

52:13.620 --> 52:14.620
端点

52:14.620 --> 52:15.620
直接点一下前面的就行了

52:15.620 --> 52:16.620
点一下前面的就行了

52:16.620 --> 52:17.620
然后运行

52:17.620 --> 52:18.620
点这个

52:18.620 --> 52:19.620
然后运行和调试

52:19.620 --> 52:21.620
就可以了

52:21.620 --> 52:22.620
是没法算

52:22.620 --> 52:23.620
你现在能敢算吗

52:23.620 --> 52:24.620
万一后边是成号呢

52:24.620 --> 52:25.620
是不敢算

52:25.620 --> 52:26.620
不能算的

52:26.620 --> 52:27.620
因此你目前

52:27.620 --> 52:28.620
你还不能算

52:28.620 --> 52:30.620
你只能继续往后看

52:30.620 --> 52:32.620
直到看到下一个符号

52:32.620 --> 52:34.620
前面的能不能算了

52:34.620 --> 52:36.620
现在能不能算了

52:36.620 --> 52:37.620
敢不敢算了

52:37.620 --> 52:41.400
现在

52:41.400 --> 52:43.400
所以可以算了

52:43.400 --> 52:44.400
还不能吗

52:44.400 --> 52:46.400
那么胆小吗

52:46.400 --> 52:48.400
可不可以算了

52:48.400 --> 52:49.400
后边是加号

52:49.400 --> 52:51.400
无论你后边写的是啥

52:51.400 --> 52:53.400
是不是不影响前面的结果

52:53.400 --> 52:54.400
这前面可以算出来了

52:54.400 --> 52:56.780
五

52:56.780 --> 52:57.780
然后继续往后看

52:57.780 --> 52:58.780
一敢算吗

52:58.780 --> 52:59.780
不敢算

52:59.780 --> 53:00.780
万一后面是成了

53:00.780 --> 53:02.780
哎后边是加

53:02.780 --> 53:04.780
所以优先级相同

53:04.780 --> 53:08.110
可以算了

53:08.110 --> 53:09.110
这样往后看

53:09.110 --> 53:10.110
小货号能算吗

53:10.110 --> 53:11.110
没法算

53:11.110 --> 53:12.110
扔这

53:12.110 --> 53:13.110
二能算吗

53:13.110 --> 53:14.110
没法算

53:14.110 --> 53:15.110
加

53:15.110 --> 53:16.110
能算吗

53:16.110 --> 53:17.110
没法算

53:17.110 --> 53:18.110
你怎么算吗

53:18.110 --> 53:19.110
这个东西没法算

53:19.110 --> 53:20.110
好

53:20.110 --> 53:21.110
然后

53:21.110 --> 53:22.110
三能算吗

53:22.110 --> 53:23.110
不敢算

53:23.110 --> 53:25.110
你不知道后边是啥

53:26.110 --> 53:27.110
成

53:27.110 --> 53:28.110
能算吗

53:28.110 --> 53:29.110
现在能不能算

53:29.110 --> 53:30.110
现在

53:30.110 --> 53:33.510
二和三能不能算

53:33.510 --> 53:36.270
能不能算

53:36.270 --> 53:37.270
不敢算

53:37.270 --> 53:38.270
你敢算

53:38.270 --> 53:39.270
肯定不敢算

53:39.270 --> 53:40.270
后边还是成

53:40.270 --> 53:41.270
优先级更高

53:41.270 --> 53:42.270
也就是遇到更高的优先级

53:42.270 --> 53:43.270
是不敢算的

53:43.270 --> 53:44.270
你只有遇到

53:44.270 --> 53:45.270
第一句他的优先级

53:45.270 --> 53:46.270
他敢算

53:46.270 --> 53:47.270
你还不能算

53:47.270 --> 53:48.270
还要往后看

53:48.270 --> 53:49.270
五能算吗

53:49.270 --> 53:50.270
有时候说能算了

53:50.270 --> 53:52.270
但是我要考虑一般性规律

53:52.270 --> 53:54.270
为什么要考虑一般性规律呢

53:54.270 --> 53:55.270
万一

53:55.270 --> 53:56.270
将来还要出了一个优先级

53:56.270 --> 53:58.270
他的优先级比他还要高

53:59.270 --> 54:00.270
那就不能算了

54:00.270 --> 54:01.270
比较说我们以后遇到什么

54:01.270 --> 54:02.270
加加减减

54:02.270 --> 54:04.270
优先级比他还要高

54:04.270 --> 54:05.270
也不敢算

54:05.270 --> 54:07.270
一定要看到下一个优先级

54:07.270 --> 54:08.270
不才能算

54:08.270 --> 54:09.270
直到

54:09.270 --> 54:10.270
现在看到了

54:10.270 --> 54:11.270
减的优先级

54:11.270 --> 54:12.270
是不是比成号低

54:12.270 --> 54:13.270
那里可以算了

54:14.270 --> 54:15.270
三五一十五

54:15.270 --> 54:16.270
所以一定可以算出来了

54:16.270 --> 54:17.270
十五

54:17.270 --> 54:18.270
好

54:18.270 --> 54:19.270
然后再来看

54:19.270 --> 54:20.270
减的优先级

54:20.270 --> 54:21.270
是不是比加号

54:21.270 --> 54:22.270
比加号一样

54:22.270 --> 54:23.270
所以一样的也可以算

54:23.270 --> 54:24.270
十七

54:25.270 --> 54:26.270
可以算了

54:26.270 --> 54:27.270
好

54:27.270 --> 54:28.270
再往后走

54:28.270 --> 54:29.270
敢算吗

54:29.270 --> 54:30.270
不敢算

54:30.270 --> 54:31.270
扩耗

54:31.270 --> 54:32.270
看到优扩耗了

54:32.270 --> 54:33.270
马上开始运算

54:33.270 --> 54:34.270
运算到什么地方

54:34.270 --> 54:35.270
运算到左扩耗

54:35.270 --> 54:36.270
扩耗这个位置

54:36.270 --> 54:37.270
十六

54:37.270 --> 54:38.270
可以算了

54:38.270 --> 54:39.270
对吧

54:39.270 --> 54:42.100
然后扩耗就没了

54:42.100 --> 54:45.110
扩耗就没了

54:45.110 --> 54:46.110
好

54:46.110 --> 54:47.110
现在敢算吗

54:47.110 --> 54:48.110
不敢算

54:48.110 --> 54:49.110
还要看下一个

54:49.110 --> 54:50.110
减号

54:50.110 --> 54:51.110
是不是可以算了

54:51.110 --> 54:52.110
这个是什么

54:52.110 --> 54:53.110
二十二

54:53.110 --> 54:54.110
我们先考一下

54:54.110 --> 54:55.110
感性的认识一下

54:55.110 --> 54:56.110
怎么算的

54:56.110 --> 54:57.110
扩耗没法算

54:57.110 --> 54:58.110
看到三没法算

54:58.110 --> 54:59.110
看到加没法算

54:59.110 --> 55:01.110
看到二也不敢算

55:02.110 --> 55:03.110
五

55:04.110 --> 55:05.110
再下一个

55:05.110 --> 55:06.110
看到五不敢算

55:06.110 --> 55:07.110
看到成

55:07.110 --> 55:08.110
也不敢算了

55:08.110 --> 55:10.110
看到二也不敢算

55:10.110 --> 55:11.110
一定要看到下一个

55:11.110 --> 55:12.110
看到这了

55:12.110 --> 55:13.110
可以算了

55:13.110 --> 55:14.110
然后呢

55:14.110 --> 55:16.110
二乘以五十

55:16.110 --> 55:18.110
一定要算到左扩耗为止

55:18.110 --> 55:19.110
五减十

55:20.110 --> 55:21.110
复五

55:22.110 --> 55:23.110
好

55:23.110 --> 55:24.110
然后呢

55:24.110 --> 55:25.110
敢算吗

55:25.110 --> 55:26.110
也不敢算

55:26.110 --> 55:30.220
现在敢算吗

55:30.220 --> 55:31.220
不敢算

55:31.220 --> 55:32.220
还往后看

55:32.220 --> 55:33.220
后面没了

55:33.220 --> 55:34.220
是不是可以算出来了

55:34.220 --> 55:35.220
十二减复五

55:35.220 --> 55:37.220
就是二十二加五

55:37.220 --> 55:40.100
二十七

55:40.100 --> 55:42.100
懂得意思吗

55:42.100 --> 55:43.100
如果说你

55:43.100 --> 55:44.100
虽然这个方式

55:44.100 --> 55:46.100
看上去有点少

55:46.100 --> 55:47.100
但是呢

55:47.100 --> 55:49.100
是不是一个通用的规律啊

55:49.100 --> 55:50.100
你用这种方式

55:50.100 --> 55:51.100
你一定可以算出

55:51.100 --> 55:52.100
无论多么负担的表达

55:52.100 --> 55:53.100
都可以算得出来

55:53.100 --> 55:55.100
都可以用这种方式

55:55.100 --> 55:57.100
我们要做程序开发

55:57.100 --> 55:59.100
一定要去找他的通用规律

55:59.100 --> 56:00.100
那么我们现在就要

56:00.100 --> 56:01.100
用这种通用规律

56:01.100 --> 56:03.100
这通用规律是啥呢

56:03.100 --> 56:04.100
看这张图

56:04.100 --> 56:06.100
我们要准备好两个战

56:06.100 --> 56:08.100
一个是战略叫做数字战

56:08.100 --> 56:10.100
一个战略叫做符号战

56:10.100 --> 56:12.100
数字战顾名实印

56:12.100 --> 56:14.100
是往里边放数字的

56:14.100 --> 56:15.100
符号战呢

56:15.100 --> 56:17.100
我们往里边放符号的

56:17.100 --> 56:18.100
我们来看一下

56:18.100 --> 56:19.100
怎么来处理这个问题

56:19.100 --> 56:23.250
遇到第一个数字

56:23.250 --> 56:24.250
是数字

56:24.250 --> 56:25.250
遇到数字

56:25.250 --> 56:26.250
什么都不用管

56:26.250 --> 56:27.250
总结一下

56:27.250 --> 56:29.250
数字

56:29.250 --> 56:31.250
遇到数字

56:31.250 --> 56:34.250
直接扔入

56:35.250 --> 56:39.520
直接压入数字战

56:39.520 --> 56:42.540
想都不用想

56:42.540 --> 56:43.540
直接进战

56:43.540 --> 56:44.540
遇到数字

56:44.540 --> 56:45.540
因为没法算

56:45.540 --> 56:46.540
你光看一个数字怎么算

56:46.540 --> 56:47.540
没法算

56:47.540 --> 56:49.540
你只能把它压入到数字战

56:49.540 --> 56:51.540
进去

56:51.540 --> 56:52.540
好

56:52.540 --> 56:53.540
下一个

56:53.540 --> 56:54.540
遇到加号

56:54.540 --> 56:55.540
就遇到符号了

56:55.540 --> 56:57.540
遇到符号

56:57.540 --> 57:01.620
要分很多种情况

57:01.620 --> 57:03.620
如果

57:03.620 --> 57:05.620
符号战

57:05.620 --> 57:06.620
空的

57:06.620 --> 57:08.620
就符号战里面没东西

57:08.620 --> 57:09.620
就战顶是没东西的

57:09.620 --> 57:11.620
那么这个时候

57:11.620 --> 57:12.620
想都不要想

57:12.620 --> 57:15.620
你直接把符号扔进去

57:15.620 --> 57:17.620
等待运算

57:17.620 --> 57:18.620
扔进去

57:18.620 --> 57:19.620
现在还不能算

57:19.620 --> 57:20.620
现在没法算

57:20.620 --> 57:21.620
现在不能算

57:21.620 --> 57:22.620
只能扔进去

57:22.620 --> 57:23.620
战里面东西都是没法算的

57:23.620 --> 57:24.620
目前还没法算的

57:24.620 --> 57:25.620
扔进去

57:25.620 --> 57:27.620
等着来进行运算

57:27.620 --> 57:28.620
好

57:28.620 --> 57:29.620
接下来下一个

57:29.620 --> 57:30.620
看到二了

57:30.620 --> 57:32.620
数字直接扔入数字战

57:32.620 --> 57:33.620
二

57:33.620 --> 57:34.620
再下一个

57:34.620 --> 57:35.620
符号

57:35.620 --> 57:36.620
好

57:36.620 --> 57:37.620
今后来

57:37.620 --> 57:38.620
现在符号有什么情况

57:38.620 --> 57:39.620
这个情况是

57:39.620 --> 57:40.620
这个符号

57:40.620 --> 57:41.620
跟我们符号战的

57:41.620 --> 57:42.620
战顶的符号

57:42.620 --> 57:45.620
就是上一个符号

57:45.620 --> 57:48.620
看比较优先级

57:48.620 --> 57:50.620
如果

57:50.620 --> 57:52.620
符号战

57:52.620 --> 57:55.620
就是当前符号

57:55.620 --> 57:56.620
优先级

57:56.620 --> 57:58.620
小于等于

57:58.620 --> 58:00.620
战顶符号

58:00.620 --> 58:01.620
就战顶有东西

58:01.620 --> 58:03.620
它不是空的

58:03.620 --> 58:04.620
小于等于它

58:04.620 --> 58:05.620
怎么办

58:05.620 --> 58:07.620
运算

58:07.620 --> 58:10.620
咋运算

58:10.620 --> 58:12.620
怎么运算

58:12.620 --> 58:14.620
怎么运算呢

58:14.620 --> 58:16.620
运算的方式是这样子的

58:16.620 --> 58:18.620
看下面的运算定义

58:18.620 --> 58:20.620
如果说符号战是空的

58:20.620 --> 58:21.620
如果说没东西

58:21.620 --> 58:22.620
你没法运算

58:22.620 --> 58:24.620
如果说符号战是左货号

58:24.620 --> 58:26.620
如果说符号战里面有左货号

58:26.620 --> 58:27.620
直接弹出就行了

58:27.620 --> 58:28.620
一后面可以看到这种情况

58:28.620 --> 58:29.620
现在我们看这个

58:29.620 --> 58:30.620
如果符号战里面

58:30.620 --> 58:32.620
是一个正常的符号

58:32.620 --> 58:33.620
怎么办

58:33.620 --> 58:35.620
弹出去

58:35.620 --> 58:36.620
弹出去

58:36.620 --> 58:38.620
然后同时弹出

58:38.620 --> 58:40.620
两个数字

58:40.620 --> 58:42.620
算出来

58:42.620 --> 58:43.620
2加3

58:43.620 --> 58:44.620
算出来多少

58:44.620 --> 58:45.620
等于5

58:45.620 --> 58:47.620
把算出来的数字

58:47.620 --> 58:49.620
压入到数字战

58:49.620 --> 58:51.620
所以变成这样子的

58:51.620 --> 58:52.620
2加3等于5

58:52.620 --> 58:53.620
变成这样子的

58:53.620 --> 58:55.620
这就是运算的方式

58:55.620 --> 58:56.620
弹出一个符号

58:56.620 --> 58:57.620
弹出两个数字

58:57.620 --> 58:58.620
进行运算

58:58.620 --> 58:59.620
把算出来的结果

58:59.620 --> 59:00.620
放到数字战里面

59:00.620 --> 59:01.620
这就是运算

59:01.620 --> 59:02.620
我以后

59:02.620 --> 59:03.620
说到运算

59:03.620 --> 59:04.620
都是这个意思

59:04.620 --> 59:05.620
弹出来

59:06.620 --> 59:07.620
好

59:07.620 --> 59:11.250
运算完了过后

59:11.250 --> 59:13.250
继续判断

59:13.250 --> 59:15.250
偏不说继续判断

59:15.250 --> 59:19.250
将当前符号入战

59:19.250 --> 59:20.250
当前的符号

59:20.250 --> 59:21.250
是不是加号

59:21.250 --> 59:22.250
刚才看到加号了

59:22.250 --> 59:23.250
对吧

59:23.250 --> 59:24.250
把当前的符号入战

59:24.250 --> 59:25.250
现在又要等着相加了

59:25.250 --> 59:26.250
你看

59:26.250 --> 59:27.250
是不是5加上

59:27.250 --> 59:28.250
看

59:29.250 --> 59:30.250
继续往后看

59:30.250 --> 59:31.250
看到数字1

59:31.250 --> 59:33.250
数字直接入战

59:34.250 --> 59:35.250
继续往后看

59:35.250 --> 59:36.250
看到加号

59:36.250 --> 59:37.250
看到加号

59:37.250 --> 59:38.250
是不是优先级小于

59:38.250 --> 59:39.250
等于占顶符号

59:39.250 --> 59:40.250
怎么办

59:40.250 --> 59:41.250
弹出来运算

59:42.250 --> 59:43.250
弹出来

59:43.250 --> 59:45.250
1加上5

59:45.250 --> 59:47.250
或者5加上1都行

59:47.250 --> 59:48.250
得多少

59:48.250 --> 59:49.250
得元6

59:49.250 --> 59:50.250
进去

59:52.250 --> 59:53.250
好

59:53.250 --> 59:54.250
进去过后

59:54.250 --> 59:55.250
不要忘记了

59:55.250 --> 59:56.250
这里算出来的

59:56.250 --> 59:57.250
6

59:57.250 --> 01:00:01.140
然后把这个加号入战

01:00:01.140 --> 01:00:02.140
继续往后看

01:00:02.140 --> 01:00:04.140
看到扩幅怎么办

01:00:04.140 --> 01:00:06.140
看到扩幅

01:00:06.140 --> 01:00:07.140
如果说占空

01:00:07.140 --> 01:00:08.140
的

01:00:08.140 --> 01:00:09.140
或者是

01:00:09.140 --> 01:00:11.140
当前符号

01:00:11.140 --> 01:00:13.140
是左扩号

01:00:13.140 --> 01:00:14.140
这种情况下

01:00:14.140 --> 01:00:15.140
想都不想

01:00:15.140 --> 01:00:16.140
因为扩幅

01:00:16.140 --> 01:00:17.140
现在是没法算的

01:00:17.140 --> 01:00:18.140
根本就没法算

01:00:18.140 --> 01:00:20.140
没法算的话只能入战

01:00:20.140 --> 01:00:21.140
只能入战

01:00:21.140 --> 01:00:23.140
你看这里的情况

01:00:23.140 --> 01:00:27.280
我慢慢的去梳理

01:00:28.280 --> 01:00:29.280
好

01:00:29.280 --> 01:00:30.280
入战

01:00:30.280 --> 01:00:31.280
入战完了过后

01:00:31.280 --> 01:00:32.280
继续往后看

01:00:32.280 --> 01:00:33.280
又是数字对吧

01:00:33.280 --> 01:00:34.280
数字现在没法算

01:00:34.280 --> 01:00:35.280
没法算只能入战

01:00:35.280 --> 01:00:36.280
只能入战

01:00:36.280 --> 01:00:37.280
2

01:00:37.280 --> 01:00:38.280
又是一个符号

01:00:38.280 --> 01:00:39.280
好

01:00:39.280 --> 01:00:40.280
你看

01:00:40.280 --> 01:00:41.280
现在是一个加号

01:00:41.280 --> 01:00:42.280
加号跟占顶符号

01:00:42.280 --> 01:00:43.280
什么

01:00:43.280 --> 01:00:44.280
占顶是什么

01:00:44.280 --> 01:00:45.280
占顶是扩号

01:00:45.280 --> 01:00:48.280
也就是当前符号是扩号

01:00:48.280 --> 01:00:52.280
或者是占顶是扩号

01:00:52.280 --> 01:00:54.280
这种情况都是没法算的

01:00:54.280 --> 01:00:55.280
就你现在多了个符号

01:00:55.280 --> 01:00:56.280
现在占顶是扩号

01:00:56.280 --> 01:00:57.280
怎么算

01:00:57.280 --> 01:00:58.280
没法算

01:00:58.280 --> 01:00:59.280
当前符号是个扩号

01:00:59.280 --> 01:01:00.280
直接入战

01:01:00.280 --> 01:01:01.280
占顶是扩号

01:01:01.280 --> 01:01:02.280
也没法算

01:01:02.280 --> 01:01:03.280
还是要入战

01:01:03.280 --> 01:01:04.280
凡是那种没法算的地方

01:01:04.280 --> 01:01:05.280
我们只能入战

01:01:05.280 --> 01:01:07.280
等着一会来算

01:01:07.280 --> 01:01:08.280
占顶是扩号

01:01:08.280 --> 01:01:09.280
只能入战

01:01:09.280 --> 01:01:10.280
好

01:01:10.280 --> 01:01:11.280
于是还要入战

01:01:11.280 --> 01:01:12.280
继续往后看

01:01:12.280 --> 01:01:13.280
数字

01:01:14.280 --> 01:01:15.280
是不是数字

01:01:15.280 --> 01:01:16.280
好

01:01:16.280 --> 01:01:17.280
入战

01:01:17.280 --> 01:01:18.280
没法算

01:01:18.280 --> 01:01:19.280
没法算只能入战

01:01:19.280 --> 01:01:20.280
再往下看

01:01:20.280 --> 01:01:21.280
乘号

01:01:21.280 --> 01:01:22.280
乘号是什么情况

01:01:22.280 --> 01:01:23.280
乘号的优先级

01:01:23.280 --> 01:01:24.280
所以比它高

01:01:24.280 --> 01:01:25.280
是不是还是没法算

01:01:27.280 --> 01:01:29.280
当前符号

01:01:29.280 --> 01:01:31.280
优先级高

01:01:32.280 --> 01:01:33.280
这种情况

01:01:33.280 --> 01:01:34.280
也没法算

01:01:34.280 --> 01:01:35.280
也要只能入战

01:01:35.280 --> 01:01:36.280
没办法

01:01:36.280 --> 01:01:37.280
入战

01:01:38.280 --> 01:01:39.280
继续往后看

01:01:39.280 --> 01:01:40.280
数字

01:01:40.280 --> 01:01:41.280
没问题

01:01:42.280 --> 01:01:43.280
入战

01:01:43.280 --> 01:01:44.280
好

01:01:44.280 --> 01:01:45.280
下一个

01:01:45.280 --> 01:01:46.280
减号

01:01:46.280 --> 01:01:47.280
现在看到减号了

01:01:47.280 --> 01:01:48.280
现在我们准备好一个减号

01:01:48.280 --> 01:01:50.280
现在看到减号了

01:01:50.280 --> 01:01:51.280
减号的优先级

01:01:51.280 --> 01:01:53.280
是不是比它低

01:01:53.280 --> 01:01:54.280
是不是比它低

01:01:54.280 --> 01:01:55.280
怎么办

01:01:55.280 --> 01:01:56.280
弹出运算

01:01:56.280 --> 01:01:57.280
弹一个乘号出来

01:01:57.280 --> 01:01:58.280
弹两个数字出来

01:01:58.280 --> 01:01:59.280
5和3

01:01:59.280 --> 01:02:00.280
3乘以5多

01:02:00.280 --> 01:02:01.280
多少

01:02:01.280 --> 01:02:02.280
是不是15

01:02:02.280 --> 01:02:03.280
反而说运算

01:02:03.280 --> 01:02:04.280
就是这个意思

01:02:04.280 --> 01:02:05.280
好

01:02:05.280 --> 01:02:06.280
接下来

01:02:06.280 --> 01:02:07.280
我们是不是这里算出来15

01:02:08.280 --> 01:02:09.280
接下来

01:02:09.280 --> 01:02:11.280
减号是不是还要看一下

01:02:11.280 --> 01:02:12.280
减号的优先级

01:02:12.280 --> 01:02:13.280
比加号还要低

01:02:13.280 --> 01:02:14.280
对吧

01:02:14.280 --> 01:02:15.280
比加号要低

01:02:15.280 --> 01:02:16.280
就还得看

01:02:16.280 --> 01:02:17.280
因此

01:02:17.280 --> 01:02:18.280
如果说

01:02:18.280 --> 01:02:19.280
这里运算完了过后

01:02:19.280 --> 01:02:20.280
你还没完

01:02:20.280 --> 01:02:22.280
还要低规

01:02:22.280 --> 01:02:24.280
查看

01:02:24.280 --> 01:02:25.280
只要低规查看

01:02:25.280 --> 01:02:26.280
看一下目前

01:02:26.280 --> 01:02:27.280
就是弹出来

01:02:27.280 --> 01:02:28.280
运算完了过后

01:02:28.280 --> 01:02:29.280
还能不能入战

01:02:30.280 --> 01:02:31.280
还能不能就是

01:02:31.280 --> 01:02:32.280
正常的入战

01:02:32.280 --> 01:02:33.280
反正你还是入不了

01:02:33.280 --> 01:02:34.280
加号的优先级

01:02:34.280 --> 01:02:35.280
比它的跟它相等

01:02:35.280 --> 01:02:37.280
因此加号要弹出来

01:02:37.280 --> 01:02:38.280
15和2弹出来

01:02:38.280 --> 01:02:39.280
是不是17

01:02:39.280 --> 01:02:40.280
算出来

01:02:41.280 --> 01:02:42.280
17

01:02:43.280 --> 01:02:44.280
算出来17

01:02:44.280 --> 01:02:47.940
然后这里

01:02:52.300 --> 01:02:53.300
算出来17

01:02:53.300 --> 01:02:54.300
然后现在

01:02:54.300 --> 01:02:55.300
我们再看一个减号

01:02:55.300 --> 01:02:57.300
减号又要尝试入战

01:02:57.300 --> 01:02:58.300
也发现

01:02:58.300 --> 01:02:59.300
现在能不能入战了

01:02:59.300 --> 01:03:00.300
可以入战了

01:03:00.300 --> 01:03:01.300
为什么

01:03:01.300 --> 01:03:02.300
因为粘顶是扩耗

01:03:02.300 --> 01:03:03.300
粘顶是扩耗

01:03:03.300 --> 01:03:04.300
可以直接入战

01:03:04.300 --> 01:03:05.300
这种情况

01:03:05.300 --> 01:03:08.440
不是直接入战

01:03:08.440 --> 01:03:09.440
粘顶是扩耗

01:03:09.440 --> 01:03:10.440
进来了

01:03:10.440 --> 01:03:11.440
又来

01:03:12.440 --> 01:03:13.440
下一个

01:03:13.440 --> 01:03:14.440
1

01:03:14.440 --> 01:03:15.440
入战

01:03:17.440 --> 01:03:18.440
再下一个

01:03:18.440 --> 01:03:19.440
右货号

01:03:19.440 --> 01:03:20.440
看到右货号

01:03:20.440 --> 01:03:24.740
咋办

01:03:24.740 --> 01:03:25.740
看到的是

01:03:25.740 --> 01:03:26.740
我们写到前面

01:03:27.740 --> 01:03:28.740
因为这些都是特殊符号

01:03:34.390 --> 01:03:36.390
右货号我们直接写上面

01:03:36.390 --> 01:03:43.420
看到右货号

01:03:43.420 --> 01:03:46.790
看到右货号怎么办

01:03:46.790 --> 01:03:47.790
那么这个时候

01:03:47.790 --> 01:03:48.790
你就不要入战了

01:03:48.790 --> 01:03:50.790
右货号是不需要入战的

01:03:50.790 --> 01:03:51.790
看到右货号

01:03:51.790 --> 01:03:53.790
直接一直运算

01:03:53.790 --> 01:03:54.790
一直运算

01:03:54.790 --> 01:03:56.790
运算到组合号为止

01:03:58.790 --> 01:03:59.790
运算到

01:04:02.230 --> 01:04:03.230
左货号

01:04:04.230 --> 01:04:05.230
出战为止

01:04:05.230 --> 01:04:07.230
一直要运算

01:04:09.230 --> 01:04:10.230
怎么运算的

01:04:10.230 --> 01:04:12.230
首先减号弹出来

01:04:12.230 --> 01:04:13.230
弹一个什么1

01:04:13.230 --> 01:04:14.230
1放下面

01:04:14.230 --> 01:04:15.230
弹一个17

01:04:15.230 --> 01:04:16.230
17-1

01:04:16.230 --> 01:04:17.230
是不是16

01:04:17.230 --> 01:04:18.230
注意这个顺序

01:04:18.230 --> 01:04:19.230
不能去1-17

01:04:20.230 --> 01:04:21.230
是不是16

01:04:21.230 --> 01:04:22.230
好

01:04:22.230 --> 01:04:24.230
然后这个运算完了

01:04:24.230 --> 01:04:25.230
接下来遇到一个左货号

01:04:25.230 --> 01:04:27.230
看运算怎么定义的

01:04:27.230 --> 01:04:29.230
如果说专顶是左货号

01:04:29.230 --> 01:04:30.230
直接弹出

01:04:30.230 --> 01:04:32.230
你看这里是不是16

01:04:33.230 --> 01:04:34.230
专顶是左货号

01:04:34.230 --> 01:04:35.230
直接弹出

01:04:35.230 --> 01:04:36.230
不用管了

01:04:36.230 --> 01:04:37.230
好

01:04:37.230 --> 01:04:38.230
那么现在左货号弹出了

01:04:38.230 --> 01:04:39.230
是吧

01:04:39.230 --> 01:04:40.230
表示货号没了

01:04:40.230 --> 01:04:41.230
货号没了

01:04:41.230 --> 01:04:42.230
变成这个样子了

01:04:42.230 --> 01:04:43.230
所以又来

01:04:43.230 --> 01:04:44.230
继续

01:04:44.230 --> 01:04:45.230
遇到减号

01:04:45.230 --> 01:04:46.230
是不是要开始算这个

01:04:46.230 --> 01:04:47.230
是吧

01:04:47.230 --> 01:04:48.230
按照这样的规律

01:04:48.230 --> 01:04:49.230
是不是直到

01:04:49.230 --> 01:04:50.230
它全部完成

01:04:51.230 --> 01:04:52.230
看到没

01:04:52.230 --> 01:04:54.230
这就是遇到符号

01:04:54.230 --> 01:04:57.570
怎么办

01:04:57.570 --> 01:04:58.570
这就是我们的规律

01:04:58.570 --> 01:04:59.570
现在我们要把这个东西

01:04:59.570 --> 01:05:00.570
写成代码

01:05:01.570 --> 01:05:02.570
喝水

01:05:03.570 --> 01:05:11.900
写代码的时候

01:05:11.900 --> 01:05:12.900
我们这里写代码

01:05:12.900 --> 01:05:14.900
写代码的时候

01:05:15.900 --> 01:05:16.900
有两个问题要解决

01:05:16.900 --> 01:05:17.900
第一个问题就是符

01:05:17.900 --> 01:05:19.900
什么叫运算

01:05:19.900 --> 01:05:20.900
什么叫运算

01:05:20.900 --> 01:05:21.900
你看

01:05:21.900 --> 01:05:22.900
这里我们comput

01:05:22.900 --> 01:05:24.900
是不是要准备好两个站

01:05:24.900 --> 01:05:25.900
一个叫数字站

01:05:25.900 --> 01:05:27.900
我们用NumberStack

01:05:27.900 --> 01:05:28.900
六一个Stack

01:05:28.900 --> 01:05:29.900
所以站我们一写好了

01:05:29.900 --> 01:05:30.900
这是数字站

01:05:30.900 --> 01:05:32.900
用来放数字的站

01:05:33.900 --> 01:05:35.900
另外一个是符号站

01:05:35.900 --> 01:05:36.900
OPStack

01:05:36.900 --> 01:05:37.900
六一个Stack

01:05:38.900 --> 01:05:44.260
这是符号站

01:05:44.260 --> 01:05:45.260
一个是数字站

01:05:45.260 --> 01:05:46.260
一个是符号站

01:05:47.260 --> 01:05:48.260
好数字

01:05:48.260 --> 01:05:50.260
如果说是数字站的话

01:05:50.260 --> 01:05:52.260
准备好两个站

01:05:52.260 --> 01:05:54.260
一会我们要进行运算

01:05:54.260 --> 01:05:56.260
那么运算的话

01:05:56.260 --> 01:05:58.260
我们可以把它写成一个函数

01:05:58.260 --> 01:06:00.260
这个过程可以写成一个函数

01:06:00.260 --> 01:06:01.260
什么叫运算

01:06:01.260 --> 01:06:03.260
我们这里写个函数

01:06:03.260 --> 01:06:04.260
叫做comput

01:06:06.260 --> 01:06:07.260
这做什么事情的

01:06:07.260 --> 01:06:08.260
做运算的

01:06:08.260 --> 01:06:10.260
什么叫做运算

01:06:10.260 --> 01:06:11.260
我们刚才定义了

01:06:11.260 --> 01:06:13.260
如果说符号站是空的

01:06:13.260 --> 01:06:14.260
什么都不要做

01:06:14.260 --> 01:06:16.260
啥都不用做

01:06:16.260 --> 01:06:18.260
我怎么来判断符号站是不是空的呢

01:06:18.260 --> 01:06:19.260
符号站就是符号站

01:06:19.260 --> 01:06:21.260
怎么来判断它是不是空的呢

01:06:21.260 --> 01:06:23.260
就看一下OPStack

01:06:23.260 --> 01:06:24.260
getstop

01:06:24.260 --> 01:06:26.260
它顶部的东西有没有东西

01:06:26.260 --> 01:06:30.150
看一下有没有东西

01:06:30.150 --> 01:06:32.150
如果说没有东西

01:06:32.150 --> 01:06:34.150
是不是站是空的

01:06:34.150 --> 01:06:36.150
站是空的

01:06:36.150 --> 01:06:37.150
对吧

01:06:37.150 --> 01:06:39.150
站是空的我什么也不用做

01:06:39.150 --> 01:06:41.150
运算我就不用运算

01:06:41.150 --> 01:06:43.150
就computed

01:06:43.150 --> 01:06:44.150
起个辅助还说

01:06:44.150 --> 01:06:46.150
因为我们以后不会不断的进行运算的

01:06:46.150 --> 01:06:48.150
站是空的也不用做

01:06:48.150 --> 01:06:49.150
还有什么情况呢

01:06:49.150 --> 01:06:50.150
就站顶呢

01:06:50.150 --> 01:06:51.150
它不是空的

01:06:51.150 --> 01:06:52.150
但是站顶是什么

01:06:52.150 --> 01:06:53.150
站顶是一个组合货号

01:06:53.150 --> 01:06:55.150
那么直接弹出就可以了

01:06:55.150 --> 01:06:57.150
所以我们判断一下

01:06:57.150 --> 01:06:59.150
如果说站顶不是空的

01:06:59.150 --> 01:07:01.150
它是一个什么组合货号

01:07:01.150 --> 01:07:02.150
等于什么

01:07:02.150 --> 01:07:03.150
等于组合货号

01:07:03.150 --> 01:07:07.980
站顶是组合货号

01:07:07.980 --> 01:07:08.980
你要怎么运算吗

01:07:08.980 --> 01:07:09.980
你说怎么运算吗

01:07:09.980 --> 01:07:10.980
它站顶是组合货号

01:07:10.980 --> 01:07:11.980
不要说我们这里

01:07:11.980 --> 01:07:13.980
上面这里是一个货号

01:07:13.980 --> 01:07:14.980
你要打运算吗

01:07:14.980 --> 01:07:15.980
你没办运算啊

01:07:15.980 --> 01:07:16.980
你直接把弹出就完事了

01:07:16.980 --> 01:07:17.980
好怎么弹出

01:07:17.980 --> 01:07:19.980
是不是就是OPStack

01:07:19.980 --> 01:07:20.980
帕

01:07:20.980 --> 01:07:22.980
弹出即可

01:07:22.980 --> 01:07:23.980
对吧

01:07:23.980 --> 01:07:25.980
而且可以告诉他吗

01:07:25.980 --> 01:07:27.980
我这个是不是遇到了空了

01:07:27.980 --> 01:07:28.980
或者是遇到了

01:07:28.980 --> 01:07:30.980
所以起个返回职吗

01:07:30.980 --> 01:07:31.980
告诉外面的人啊

01:07:31.980 --> 01:07:34.980
返回的是一个布尔

01:07:34.980 --> 01:07:39.980
是否运算了

01:07:39.980 --> 01:07:40.980
是否运算了

01:07:40.980 --> 01:07:41.980
目前站是空的

01:07:41.980 --> 01:07:42.980
肯定没有运算

01:07:42.980 --> 01:07:44.980
如果说那个

01:07:44.980 --> 01:07:45.980
是组合货号的话

01:07:45.980 --> 01:07:46.980
也没有运算

01:07:46.980 --> 01:07:47.980
是弧

01:07:47.980 --> 01:07:49.980
好 else

01:07:49.980 --> 01:07:50.980
是不是这个时候要运算了

01:07:50.980 --> 01:07:51.980
站顶是

01:07:51.980 --> 01:07:52.980
站顶是什么

01:07:52.980 --> 01:07:53.980
是正常的东西

01:07:53.980 --> 01:07:54.980
它不是组合货号

01:07:54.980 --> 01:07:55.980
那么就加点成熟

01:07:55.980 --> 01:07:56.980
求鱼

01:07:56.980 --> 01:07:57.980
那么这个时候怎么运算

01:07:57.980 --> 01:07:58.980
就谈两次啊

01:07:58.980 --> 01:07:59.980
符号站谈一次

01:07:59.980 --> 01:08:01.980
数字站谈两次

01:08:01.980 --> 01:08:04.980
好符号站谈一次

01:08:04.980 --> 01:08:07.980
谈一次

01:08:07.980 --> 01:08:08.980
然后呢

01:08:08.980 --> 01:08:09.980
数字站谈出来

01:08:09.980 --> 01:08:10.980
就是这个东西啊

01:08:10.980 --> 01:08:11.980
就这个东西

01:08:11.980 --> 01:08:12.980
数字站呢

01:08:12.980 --> 01:08:14.980
谈两次

01:08:14.980 --> 01:08:16.980
或者这个东西叫OP嘛

01:08:16.980 --> 01:08:17.980
就是我们的符号

01:08:17.980 --> 01:08:20.980
或者操作符

01:08:20.980 --> 01:08:21.980
数字站都谈两次

01:08:21.980 --> 01:08:22.980
第一个数字是什么

01:08:22.980 --> 01:08:24.980
谈出来的数字是

01:08:24.980 --> 01:08:26.980
NumberStack

01:08:27.980 --> 01:08:28.980
第二个数字

01:08:28.980 --> 01:08:30.980
NumberStack

01:08:30.980 --> 01:08:31.980
数字站谈两次

01:08:31.980 --> 01:08:33.980
然后用这个符号

01:08:33.980 --> 01:08:35.980
跟这两个数字进行运算

01:08:35.980 --> 01:08:36.980
是不是可以用到

01:08:36.980 --> 01:08:37.980
之前这个东西了

01:08:37.980 --> 01:08:39.980
符号

01:08:39.980 --> 01:08:40.980
两个数字

01:08:40.980 --> 01:08:41.980
是可以的

01:08:41.980 --> 01:08:45.500
看怎么写

01:08:45.500 --> 01:08:46.500
OP

01:08:46.500 --> 01:08:49.500
叫做operators

01:08:49.500 --> 01:08:50.500
属性名字是啥

01:08:50.500 --> 01:08:51.500
属性名字

01:08:51.500 --> 01:08:52.500
是不是就是这个符号

01:08:52.500 --> 01:08:53.500
就是符号

01:08:53.500 --> 01:08:54.500
我们之前写过的

01:08:54.500 --> 01:08:55.500
它这个是一个

01:08:55.500 --> 01:08:56.500
方法要computer

01:08:56.500 --> 01:08:57.500
计算

01:08:57.500 --> 01:08:58.500
两个数字

01:08:58.500 --> 01:08:59.500
说一定要注意顺序

01:08:59.500 --> 01:09:01.500
比方说这里是简的话

01:09:01.500 --> 01:09:02.500
它是后进来的

01:09:02.500 --> 01:09:03.500
它是先进来的

01:09:03.500 --> 01:09:04.500
所以一定是

01:09:04.500 --> 01:09:06.500
它简它Number2简Number1

01:09:06.500 --> 01:09:07.500
对吧

01:09:07.500 --> 01:09:09.500
除也是Number2除亦Number1

01:09:09.500 --> 01:09:10.500
所以说你这里

01:09:10.500 --> 01:09:12.500
顺序是Number2Number1

01:09:12.500 --> 01:09:13.500
是不是运算

01:09:13.500 --> 01:09:14.500
运算是不是拿到

01:09:14.500 --> 01:09:16.500
一个运算结果

01:09:16.500 --> 01:09:18.500
看这个定义啊

01:09:18.500 --> 01:09:19.500
如果说其他符号

01:09:19.500 --> 01:09:20.500
谈出符号

01:09:20.500 --> 01:09:21.500
谈出两个数字

01:09:21.500 --> 01:09:22.500
然后算

01:09:22.500 --> 01:09:23.500
算出来的结果

01:09:23.500 --> 01:09:24.500
压入到数字站

01:09:24.500 --> 01:09:25.500
所以说结果

01:09:25.500 --> 01:09:26.500
还要干嘛

01:09:26.500 --> 01:09:27.500
还要压入到NumberStack

01:09:27.500 --> 01:09:29.500
图形数字站

01:09:29.500 --> 01:09:31.500
这就是一个computer

01:09:33.500 --> 01:09:35.500
这就是一个computer

01:09:36.500 --> 01:09:37.500
今天晚上

01:09:37.500 --> 01:09:41.520
可能肯定是有难度的

01:09:41.520 --> 01:09:42.520
下去过后

01:09:42.520 --> 01:09:43.520
慢慢去消化吧

01:09:43.520 --> 01:09:44.520
如果说你现在觉得

01:09:44.520 --> 01:09:46.520
超出你目前的认知太多

01:09:46.520 --> 01:09:47.520
那么你可以

01:09:47.520 --> 01:09:48.520
等一等

01:09:48.520 --> 01:09:49.520
等一段时间

01:09:49.520 --> 01:09:50.520
再来看

01:09:50.520 --> 01:09:51.520
这个道理

01:09:51.520 --> 01:09:52.520
其实是非常训练

01:09:52.520 --> 01:09:53.520
逻辑示威的

01:09:53.520 --> 01:09:54.520
好 咱们来测试一下吧

01:09:54.520 --> 01:09:55.520
单独测试一下

01:09:55.520 --> 01:09:56.520
比方说

01:09:56.520 --> 01:09:57.520
我们在数字站里面

01:09:57.520 --> 01:09:58.520
加两个东西

01:09:58.520 --> 01:10:00.520
一个2

01:10:01.520 --> 01:10:02.520
再加一个3

01:10:02.520 --> 01:10:04.520
然后算2-3

01:10:04.520 --> 01:10:05.520
看一下吧

01:10:06.520 --> 01:10:08.520
然后符号站里面加一个

01:10:08.520 --> 01:10:09.520
加一个符号

01:10:09.520 --> 01:10:10.520
减

01:10:11.520 --> 01:10:13.520
数字站里面有两个2和3

01:10:13.520 --> 01:10:15.520
符号站里面有一个减

01:10:15.520 --> 01:10:16.520
那么就算2-3

01:10:16.520 --> 01:10:17.520
看一下

01:10:17.520 --> 01:10:19.520
computer算完了过后

01:10:19.520 --> 01:10:21.520
你论上应该是

01:10:21.520 --> 01:10:23.520
这个玩意里面是空的

01:10:23.520 --> 01:10:24.520
这个玩意里面

01:10:24.520 --> 01:10:26.520
只有一个-1

01:10:26.520 --> 01:10:27.520
应该是这样子才对

01:10:28.520 --> 01:10:29.520
我们来看一下吧

01:10:29.520 --> 01:10:30.520
打个半点

01:10:30.520 --> 01:10:31.520
运行

01:10:31.520 --> 01:10:32.520
点对吧

01:10:32.520 --> 01:10:33.520
运行

01:10:33.520 --> 01:10:34.520
诺诺解释

01:10:35.520 --> 01:10:36.520
好 运行到这了

01:10:36.520 --> 01:10:37.520
你看

01:10:37.520 --> 01:10:38.520
现在算完了

01:10:38.520 --> 01:10:39.520
算完了

01:10:39.520 --> 01:10:40.520
我们来看一下

01:10:40.520 --> 01:10:41.520
这个站里面

01:10:46.520 --> 01:10:47.520
我的东西呢

01:10:48.520 --> 01:10:49.520
我下面

01:10:49.520 --> 01:10:50.520
等一下

01:10:50.520 --> 01:10:51.520
我再加一句话吧

01:10:54.520 --> 01:10:55.520
第八个

01:11:00.910 --> 01:11:09.750
诺解释

01:11:09.750 --> 01:11:10.750
对

01:11:10.750 --> 01:11:11.750
他跑

01:11:11.750 --> 01:11:12.750
他已经推出这个环境了

01:11:12.750 --> 01:11:14.750
他一推出这个寒树环境了

01:11:14.750 --> 01:11:16.750
我就看不到这两个字了

01:11:16.750 --> 01:11:17.750
那我不行

01:11:17.750 --> 01:11:19.750
为了看到我这两个字

01:11:19.750 --> 01:11:20.750
加个输出逾得了

01:11:21.750 --> 01:11:22.750
加个输出逾得了

01:11:22.750 --> 01:11:23.750
再来

01:11:23.750 --> 01:11:31.130
停不到这来吗

01:11:31.130 --> 01:11:32.130
那行了吧

01:11:32.130 --> 01:11:34.130
那我点这吧

01:11:34.130 --> 01:11:36.130
下面因为边量定义吧

01:11:36.130 --> 01:11:37.130
我必须要他停到这来

01:11:37.130 --> 01:11:39.130
我要看一下这两个东西

01:11:40.130 --> 01:11:42.130
我知道了

01:11:42.130 --> 01:11:43.130
没调用

01:11:44.130 --> 01:11:45.130
我都没调用

01:11:45.130 --> 01:11:46.130
我的天

01:11:46.130 --> 01:11:49.630
现在应该没问题了

01:11:49.630 --> 01:11:50.630
运行

01:11:50.630 --> 01:11:51.630
诺解释

01:11:51.630 --> 01:11:52.630
好 现在没问题了

01:11:52.630 --> 01:11:53.630
你看这两个站

01:11:55.630 --> 01:11:57.630
数字那里面只有一个负一

01:11:57.630 --> 01:11:58.630
符号站是空的

01:11:58.630 --> 01:12:00.630
然后我们为了看到清楚

01:12:00.630 --> 01:12:02.630
我们再来重新运行

01:12:02.630 --> 01:12:03.630
诺解释

01:12:03.630 --> 01:12:05.630
你看运行

01:12:05.630 --> 01:12:06.630
计算之前

01:12:06.630 --> 01:12:07.630
这两个站是什么情况

01:12:07.630 --> 01:12:08.630
一个二 一个三

01:12:08.630 --> 01:12:10.630
符号站是什么情况

01:12:10.630 --> 01:12:12.630
符号站运行

01:12:12.630 --> 01:12:13.630
符号站是什么情况

01:12:13.630 --> 01:12:14.630
符号站是一个负数

01:12:14.630 --> 01:12:15.630
一个减号

01:12:15.630 --> 01:12:17.630
那么运算完了之后

01:12:17.630 --> 01:12:19.630
是不是就减号没了

01:12:19.630 --> 01:12:20.630
变成负一了

01:12:20.630 --> 01:12:21.630
看到没

01:12:21.630 --> 01:12:22.630
这是运算

01:12:22.630 --> 01:12:23.630
旁边有这个函数

01:12:23.630 --> 01:12:24.630
只要一调用这个函数

01:12:24.630 --> 01:12:25.630
它就会运算一次

01:12:25.630 --> 01:12:27.630
就这么个意思

01:12:27.630 --> 01:12:29.630
这个函数没写好了

01:12:29.630 --> 01:12:31.630
还有什么函数呢

01:12:31.630 --> 01:12:32.630
我们还可以写个辅助函数

01:12:32.630 --> 01:12:33.630
这两个辅助函数写完

01:12:33.630 --> 01:12:35.630
那么整个程序就差不多了

01:12:35.630 --> 01:12:37.630
什么辅助函数

01:12:37.630 --> 01:12:39.630
就是处理一个符号

01:12:39.630 --> 01:12:41.630
operate

01:12:42.630 --> 01:12:43.630
operate

01:12:43.630 --> 01:12:45.630
处理符号

01:12:45.630 --> 01:12:49.630
处理一次操作

01:12:49.630 --> 01:12:52.630
处理一次操作

01:12:52.630 --> 01:12:53.630
啥意思

01:12:53.630 --> 01:12:57.630
就是把这个逻辑写到函数里面

01:12:57.630 --> 01:12:59.630
你给我一个符号

01:12:59.630 --> 01:13:01.630
你给我一个符号

01:13:01.630 --> 01:13:02.630
这就是你给我的符号

01:13:02.630 --> 01:13:03.630
那么这个符号

01:13:03.630 --> 01:13:05.630
我要做什么操作

01:13:05.630 --> 01:13:06.630
你看吧

01:13:06.630 --> 01:13:08.630
这里两个可以按照这个模具来写

01:13:08.630 --> 01:13:10.630
怎么写

01:13:10.630 --> 01:13:12.630
如果说你给我的符号

01:13:12.630 --> 01:13:13.630
是啥呀

01:13:13.630 --> 01:13:14.630
是一个右扩号

01:13:14.630 --> 01:13:16.630
做啥

01:13:16.630 --> 01:13:17.630
你给我的符号

01:13:17.630 --> 01:13:18.630
是一个右扩号

01:13:18.630 --> 01:13:19.630
我能做啥

01:13:19.630 --> 01:13:21.630
我是不是要一直运算

01:13:21.630 --> 01:13:22.630
算到什么情况下

01:13:22.630 --> 01:13:24.630
算到它左扩号出站为止

01:13:24.630 --> 01:13:25.630
我们知道刚才我写的

01:13:25.630 --> 01:13:26.630
这个compute

01:13:26.630 --> 01:13:27.630
左扩号怎么出站的时候

01:13:27.630 --> 01:13:28.630
是不是返回force

01:13:28.630 --> 01:13:30.630
也就是你只要返回的是q

01:13:30.630 --> 01:13:31.630
这里没返回

01:13:31.630 --> 01:13:32.630
你只要返回的是q

01:13:32.630 --> 01:13:33.630
表示你运算了

01:13:33.630 --> 01:13:35.630
你参与了一个正常运算

01:13:35.630 --> 01:13:36.630
那我就继续

01:13:36.630 --> 01:13:38.630
直到你给我返回一个force

01:13:38.630 --> 01:13:39.630
说明左扩号已经没了

01:13:39.630 --> 01:13:40.630
你算那个左扩号

01:13:40.630 --> 01:13:42.630
或者是空的空的就不管它了

01:13:42.630 --> 01:13:44.630
所以说这里该怎么写

01:13:44.630 --> 01:13:45.630
是一个while循环

01:13:45.630 --> 01:13:47.630
compute你直接去算

01:13:47.630 --> 01:13:49.630
你算到你不能算为止

01:13:49.630 --> 01:13:51.630
就这么一个意思

01:13:51.630 --> 01:13:57.140
一直算到左扩号

01:13:57.140 --> 01:13:58.140
就完事了

01:13:58.140 --> 01:13:59.140
就这样算

01:13:59.140 --> 01:14:00.140
你只要正常运算

01:14:00.140 --> 01:14:01.140
就一直拿出来算

01:14:01.140 --> 01:14:02.140
一直拿出来算

01:14:02.140 --> 01:14:03.140
算到什么情况为止

01:14:03.140 --> 01:14:04.140
还只要遇到了左扩号

01:14:04.140 --> 01:14:05.140
它返回force

01:14:05.140 --> 01:14:06.140
那么这个函数

01:14:06.140 --> 01:14:09.450
这个循环就结束了

01:14:09.450 --> 01:14:11.450
这是处理一次操作

01:14:11.450 --> 01:14:13.450
你给我的是右扩号

01:14:13.450 --> 01:14:14.450
那就这样算

01:14:14.450 --> 01:14:15.450
那lcf

01:14:15.450 --> 01:14:17.450
你给我的不是右扩号

01:14:17.450 --> 01:14:19.450
然后我要很多的情况了

01:14:19.450 --> 01:14:21.450
有很多情况了

01:14:21.450 --> 01:14:23.450
哪些情况呢

01:14:23.450 --> 01:14:24.450
我们要看一下

01:14:24.450 --> 01:14:25.450
这个符号站是不是空的

01:14:25.450 --> 01:14:27.450
那么我们要得到占顶

01:14:27.450 --> 01:14:29.450
要得到目前的占顶

01:14:29.450 --> 01:14:33.820
top open

01:14:33.820 --> 01:14:35.820
就是符号站

01:14:35.820 --> 01:14:38.820
get top

01:14:38.820 --> 01:14:45.700
得到目前的占顶

01:14:46.700 --> 01:14:50.780
看一下目前的占顶

01:14:50.780 --> 01:14:51.780
如果说没东西

01:14:51.780 --> 01:14:52.780
占都是空的

01:14:52.780 --> 01:14:53.780
我们之前是不总结过的

01:14:53.780 --> 01:14:55.780
占是空的

01:14:55.780 --> 01:14:56.780
还有什么情况呢

01:14:56.780 --> 01:14:58.780
或者是当前符号

01:14:58.780 --> 01:15:00.780
当前符号是什么

01:15:00.780 --> 01:15:02.780
是一个左扩号

01:15:02.780 --> 01:15:07.780
或者是占顶是一个左扩号

01:15:07.780 --> 01:15:11.780
或者是当前符号的优先级

01:15:11.780 --> 01:15:13.780
当前符号的优先级怎么来算

01:15:13.780 --> 01:15:14.780
是不是从这里拿

01:15:14.780 --> 01:15:16.780
operator里面了

01:15:17.780 --> 01:15:19.780
我们来拿

01:15:19.780 --> 01:15:21.780
从operators

01:15:21.780 --> 01:15:22.780
当前符号传进去

01:15:22.780 --> 01:15:24.780
是不是拿到当前符号的信息

01:15:24.780 --> 01:15:27.780
里面有个什么一个level

01:15:27.780 --> 01:15:29.780
当前符号的优先级

01:15:29.780 --> 01:15:33.780
高于占顶的符号

01:15:33.780 --> 01:15:34.780
operators

01:15:34.780 --> 01:15:35.780
占顶的符号是什么

01:15:35.780 --> 01:15:36.780
top open

01:15:36.780 --> 01:15:38.780
这些都是基础开发能力

01:15:38.780 --> 01:15:40.780
这些要掌握的滚瓜烂熟

01:15:40.780 --> 01:15:41.780
如何你这些

01:15:41.780 --> 01:15:42.780
什么通过一个表达

01:15:42.780 --> 01:15:44.780
是来取属性的值

01:15:44.780 --> 01:15:45.780
取对象的属性

01:15:45.780 --> 01:15:47.780
这些都还不属的话

01:15:47.780 --> 01:15:49.780
这些函数你根本就掌控不了

01:15:49.780 --> 01:15:51.780
我们经常说一个函数的

01:15:51.780 --> 01:15:53.780
就是代码的掌控能力

01:15:53.780 --> 01:15:54.780
什么叫掌控能力

01:15:54.780 --> 01:15:55.780
从大局出发

01:15:55.780 --> 01:15:57.780
你知道怎么去划分函数

01:15:57.780 --> 01:15:59.780
知道怎么去写对象

01:15:59.780 --> 01:16:01.780
这种大局关的能力

01:16:01.780 --> 01:16:02.780
你没有几年开发信息

01:16:02.780 --> 01:16:03.780
肯定是出不来的

01:16:03.780 --> 01:16:04.780
这个是没办法

01:16:04.780 --> 01:16:06.780
一般老师会给你说

01:16:06.780 --> 01:16:07.780
你多去看代码了

01:16:07.780 --> 01:16:09.780
会有一点人感觉

01:16:09.780 --> 01:16:11.780
但是用细节上的掌控能力

01:16:11.780 --> 01:16:12.780
你是必须要有的

01:16:12.780 --> 01:16:14.780
就是你怎么去取一个对象的属性

01:16:14.780 --> 01:16:15.780
怎么用动态表达是

01:16:15.780 --> 01:16:18.780
这东西你就要用得非常非常熟练的

01:16:18.780 --> 01:16:19.780
这怎么办

01:16:19.780 --> 01:16:20.780
只能多练

01:16:20.780 --> 01:16:22.780
跟着老师多练

01:16:22.780 --> 01:16:24.780
然后大于他的level

01:16:24.780 --> 01:16:25.780
说明说

01:16:25.780 --> 01:16:27.780
他的优先级数比他高

01:16:27.780 --> 01:16:31.280
优先级比他高怎么办

01:16:31.280 --> 01:16:33.850
怎么办

01:16:33.850 --> 01:16:34.850
优先级比他高

01:16:34.850 --> 01:16:36.850
是不是直接入战

01:16:36.850 --> 01:16:37.850
什么都不用管了

01:16:37.850 --> 01:16:38.850
啥都不用管了

01:16:38.850 --> 01:16:40.850
你这个符号直接入战

01:16:40.850 --> 01:16:42.850
OP stack push

01:16:42.850 --> 01:16:44.850
当前符号直接入战

01:16:47.160 --> 01:16:49.160
把这个注释拿过来

01:16:49.160 --> 01:16:55.030
这是第二种情况

01:16:55.030 --> 01:16:59.500
是吧

01:16:59.500 --> 01:17:01.500
还有什么情况呢

01:17:01.500 --> 01:17:03.500
你现在的符号

01:17:03.500 --> 01:17:05.500
优先级比他低

01:17:05.500 --> 01:17:08.500
小于等于他

01:17:08.500 --> 01:17:11.870
就是当前符号的

01:17:11.870 --> 01:17:12.870
占顶符号

01:17:12.870 --> 01:17:13.870
所以你看是不是只剩下

01:17:13.870 --> 01:17:14.870
这种情况了

01:17:14.870 --> 01:17:15.870
还有别的情况了

01:17:15.870 --> 01:17:17.870
没有别的情况

01:17:17.870 --> 01:17:18.870
没有别的情况

01:17:18.870 --> 01:17:20.870
左货号的问题已经解决了

01:17:20.870 --> 01:17:21.870
左货号问题已经解决了

01:17:21.870 --> 01:17:22.870
跟左货号没关系了

01:17:22.870 --> 01:17:23.870
然后呢

01:17:23.870 --> 01:17:25.870
占顶又有东西

01:17:25.870 --> 01:17:26.870
你的优先级

01:17:26.870 --> 01:17:27.870
又比他

01:17:27.870 --> 01:17:28.870
一不是比他大

01:17:28.870 --> 01:17:30.870
只能是比他小于等于他

01:17:30.870 --> 01:17:31.870
那么这个时候呢

01:17:31.870 --> 01:17:32.870
怎么办

01:17:32.870 --> 01:17:33.870
第一规查看

01:17:33.870 --> 01:17:34.870
首先是

01:17:34.870 --> 01:17:35.870
目前要算一次

01:17:35.870 --> 01:17:36.870
对吧

01:17:36.870 --> 01:17:37.870
目前要运算一次

01:17:37.870 --> 01:17:39.870
目前肯定要运算一次

01:17:39.870 --> 01:17:42.870
运算一次

01:17:42.870 --> 01:17:43.870
然后呢

01:17:43.870 --> 01:17:44.870
运算一次还没完

01:17:44.870 --> 01:17:45.870
还要看一下

01:17:45.870 --> 01:17:46.870
之前的那个

01:17:46.870 --> 01:17:47.870
比方我们刚才说的

01:17:47.870 --> 01:17:48.870
情况

01:17:48.870 --> 01:17:50.870
这里算完了

01:17:50.870 --> 01:17:51.870
这里目前

01:17:51.870 --> 01:17:52.870
比方说有一个

01:17:52.870 --> 01:17:55.870
有一个家

01:17:55.870 --> 01:17:56.870
现在要进入

01:17:56.870 --> 01:17:58.870
现在要进入一个检

01:17:58.870 --> 01:17:59.870
那是不是比他

01:17:59.870 --> 01:18:00.870
小于等于他

01:18:00.870 --> 01:18:01.870
对不对

01:18:01.870 --> 01:18:02.870
那么先算家

01:18:02.870 --> 01:18:03.870
算完了过还没完

01:18:03.870 --> 01:18:04.870
还要看一下

01:18:04.870 --> 01:18:05.870
之前这个东西

01:18:05.870 --> 01:18:06.870
是吧

01:18:06.870 --> 01:18:07.870
看一下之前这个东西

01:18:07.870 --> 01:18:08.870
所以说呢

01:18:08.870 --> 01:18:09.870
这里呢

01:18:09.870 --> 01:18:10.870
你还得

01:18:10.870 --> 01:18:12.870
第一规的去做这件事情

01:18:12.870 --> 01:18:13.870
怎么第一规呢

01:18:13.870 --> 01:18:15.870
就是再重新来一次

01:18:15.870 --> 01:18:16.870
你看

01:18:16.870 --> 01:18:17.870
再重新来一次

01:18:17.870 --> 01:18:19.870
OP全民局

01:18:19.870 --> 01:18:20.870
就完了

01:18:20.870 --> 01:18:21.870
就完了

01:18:21.870 --> 01:18:22.870
那么这个逻辑出来了

01:18:22.870 --> 01:18:23.870
handle operation

01:18:23.870 --> 01:18:25.870
处理一次操作

01:18:25.870 --> 01:18:26.870
就这样处理

01:18:26.870 --> 01:18:27.870
遇到诱惑号怎么办

01:18:27.870 --> 01:18:28.870
遇到左诱惑号怎么办

01:18:28.870 --> 01:18:29.870
这些东西

01:18:29.870 --> 01:18:30.870
这些情况都怎么办

01:18:30.870 --> 01:18:31.870
就全部写完

01:18:32.870 --> 01:18:33.870
你看

01:18:33.870 --> 01:18:34.870
现在我们用了两个函数

01:18:34.870 --> 01:18:35.870
一个是comput

01:18:35.870 --> 01:18:37.870
一个是handle operation

01:18:37.870 --> 01:18:39.870
那么接下来呢

01:18:39.870 --> 01:18:41.870
但其实就已经

01:18:41.870 --> 01:18:42.870
已经没了

01:18:42.870 --> 01:18:43.870
就已经没了

01:18:43.870 --> 01:18:44.870
我们不断的往前推进

01:18:44.870 --> 01:18:46.870
这个函数就已经写出来了

01:18:46.870 --> 01:18:47.870
怎么出来的

01:18:47.870 --> 01:18:48.870
首先

01:18:48.870 --> 01:18:50.870
我们用它来创建一个扫描器

01:18:50.870 --> 01:18:51.870
scanner

01:18:51.870 --> 01:18:53.870
又一个scanner

01:18:53.870 --> 01:18:55.870
你看了怎么出来的啊

01:18:55.870 --> 01:18:57.870
用这个支付车创建一个扫描器

01:18:57.870 --> 01:18:59.870
然后呢不断的去扫描

01:18:59.870 --> 01:19:00.870
下一个

01:19:01.870 --> 01:19:03.870
为什么之前写过了个代码

01:19:03.870 --> 01:19:05.870
等于scanner.next

01:19:05.870 --> 01:19:07.870
所以调用这个next函数

01:19:07.870 --> 01:19:08.870
一个一个往下一个拿东西

01:19:08.870 --> 01:19:09.870
对吧

01:19:09.870 --> 01:19:10.870
拿下一个

01:19:10.870 --> 01:19:11.870
如果说拿到了下一个

01:19:11.870 --> 01:19:13.870
是什么呢

01:19:13.870 --> 01:19:15.870
他拿到了下一个

01:19:15.870 --> 01:19:16.870
我们刚才写过一个函数

01:19:16.870 --> 01:19:17.870
来说啊

01:19:17.870 --> 01:19:18.870
拿到的他要么就是一个operator

01:19:18.870 --> 01:19:19.870
要么就是个number

01:19:19.870 --> 01:19:20.870
对吧

01:19:20.870 --> 01:19:24.440
如果说拿到的是一个number

01:19:24.440 --> 01:19:27.440
就是他的time等于

01:19:27.440 --> 01:19:28.440
number

01:19:28.440 --> 01:19:30.440
所以拿到的是一个数字

01:19:30.440 --> 01:19:31.440
那怎么办

01:19:31.440 --> 01:19:32.440
直接入数字帐

01:19:32.440 --> 01:19:33.440
number stack to

01:19:35.440 --> 01:19:36.440
直接进入数字帐

01:19:36.440 --> 01:19:37.440
next叫value

01:19:37.440 --> 01:19:39.440
进去

01:19:39.440 --> 01:19:40.440
以后我写完了

01:19:40.440 --> 01:19:42.440
给大家演示一下整个过程啊

01:19:42.440 --> 01:19:43.440
ls

01:19:43.440 --> 01:19:44.440
说明什么

01:19:44.440 --> 01:19:45.440
拿到的是不是number

01:19:45.440 --> 01:19:46.440
是符号

01:19:46.440 --> 01:19:47.440
符号怎么办

01:19:47.440 --> 01:19:49.440
handle operation

01:19:49.440 --> 01:19:50.440
把符号扔过去

01:19:50.440 --> 01:19:52.440
你去处理一下这个符号

01:19:52.440 --> 01:19:53.440
对吧

01:19:53.440 --> 01:19:54.440
拿一个处理一个

01:19:54.440 --> 01:19:55.440
拿一个处理一个

01:19:55.440 --> 01:19:58.440
直到把整个全部东西拿完

01:19:58.440 --> 01:19:59.440
拿完了过后

01:19:59.440 --> 01:20:00.440
最后

01:20:00.440 --> 01:20:02.440
最后还不要不要

01:20:02.440 --> 01:20:03.440
不要掉以清清啊

01:20:03.440 --> 01:20:04.440
最后还有可能会出现这种情况

01:20:04.440 --> 01:20:05.440
就全部

01:20:05.440 --> 01:20:06.440
后面全部算完了

01:20:06.440 --> 01:20:07.440
然后就是一个非常简单的

01:20:07.440 --> 01:20:08.440
6加16

01:20:08.440 --> 01:20:09.440
6

01:20:09.440 --> 01:20:10.440
然后这里的一个加号

01:20:10.440 --> 01:20:11.440
加上16

01:20:11.440 --> 01:20:13.440
是不是整个表达是就结束了

01:20:13.440 --> 01:20:14.440
结束过后

01:20:14.440 --> 01:20:15.440
是不是还要得算一下

01:20:15.440 --> 01:20:16.440
循环音结束了

01:20:16.440 --> 01:20:17.440
还要算一下

01:20:17.440 --> 01:20:18.440
符号站里面有东西就要一直算

01:20:18.440 --> 01:20:19.440
算到符号站里面

01:20:19.440 --> 01:20:20.440
没有东西位置

01:20:20.440 --> 01:20:21.440
就要一直算

01:20:21.440 --> 01:20:22.440
所以说到这里呢

01:20:22.440 --> 01:20:24.440
我们就应该要一直算

01:20:24.440 --> 01:20:25.440
算到这个符号站没东西

01:20:25.440 --> 01:20:27.440
因此起个wile循环

01:20:27.440 --> 01:20:29.880
compute

01:20:29.880 --> 01:20:30.880
一直算

01:20:31.880 --> 01:20:33.880
将符号站算完

01:20:33.880 --> 01:20:35.880
将符号站

01:20:35.880 --> 01:20:36.880
清空

01:20:36.880 --> 01:20:37.880
算完

01:20:37.880 --> 01:20:39.880
算完了过后

01:20:39.880 --> 01:20:41.880
数字站的顶度

01:20:41.880 --> 01:20:42.880
你看算出来过后

01:20:42.880 --> 01:20:43.880
这里是不是24

01:20:43.880 --> 01:20:44.880
这里就加号是不是没了

01:20:44.880 --> 01:20:46.880
然后这里的数变成了22了

01:20:46.880 --> 01:20:48.880
数站的顶部就是最终的值

01:20:48.880 --> 01:20:50.880
最后返回数站的顶部

01:20:50.880 --> 01:20:52.880
就是number stack

01:20:52.880 --> 01:20:54.880
get top

01:20:54.880 --> 01:20:55.880
就写完了

01:21:00.320 --> 01:21:01.320
为了验证这一点

01:21:06.950 --> 01:21:07.950
这里没懂吗

01:21:07.950 --> 01:21:08.950
这个玩意吗

01:21:08.950 --> 01:21:10.950
这个玩意就是这里的逻辑

01:21:10.950 --> 01:21:11.950
就这里的逻辑

01:21:11.950 --> 01:21:12.950
就处理一次符号

01:21:12.950 --> 01:21:14.950
刚才我们总结过逻辑

01:21:14.950 --> 01:21:15.950
总结过的

01:21:15.950 --> 01:21:16.950
看到诱过号

01:21:16.950 --> 01:21:17.950
我该怎么去算

01:21:17.950 --> 01:21:18.950
该怎么去怎么去入站

01:21:18.950 --> 01:21:19.950
看到那个

01:21:19.950 --> 01:21:20.950
诱过号

01:21:20.950 --> 01:21:22.950
这些东西又该怎么去弄

01:21:22.950 --> 01:21:23.950
看到这个

01:21:23.950 --> 01:21:24.950
优先级小微等于的是

01:21:24.950 --> 01:21:25.950
在怎么去弄

01:21:25.950 --> 01:21:26.950
刚才总结过的

01:21:26.950 --> 01:21:27.950
下来的话

01:21:27.950 --> 01:21:28.950
你可以看一下

01:21:28.950 --> 01:21:29.950
那一段的录播

01:21:29.950 --> 01:21:31.950
就把这个逻辑写进去

01:21:31.950 --> 01:21:32.950
好

01:21:32.950 --> 01:21:33.950
接下来我们来看一下

01:21:33.950 --> 01:21:37.800
它怎么运行的

01:21:37.800 --> 01:21:38.800
来吧

01:21:38.800 --> 01:21:39.800
我在这里呢

01:21:39.800 --> 01:21:40.800
打个断片

01:21:40.800 --> 01:21:41.800
接下来

01:21:41.800 --> 01:21:43.800
我运算一个东西

01:21:43.800 --> 01:21:44.800
运算

01:21:44.800 --> 01:21:45.800
运算啥呀

01:21:45.800 --> 01:21:47.800
我看一下有没有

01:21:47.800 --> 01:21:49.800
什么表达是可以

01:21:49.800 --> 01:21:51.800
就这个表达是吧

01:21:51.800 --> 01:21:52.800
哎呦

01:21:52.800 --> 01:21:53.800
表达是已经没了

01:21:53.800 --> 01:21:57.010
没了

01:21:57.010 --> 01:21:59.010
表达是已经没了

01:21:59.010 --> 01:22:00.010
就这个吧

01:22:00.010 --> 01:22:01.010
就这个吧

01:22:01.010 --> 01:22:03.380
来吧

01:22:03.380 --> 01:22:04.380
看一下怎么算的

01:22:04.380 --> 01:22:06.380
首先看它算得对不对

01:22:06.380 --> 01:22:07.380
非常好

01:22:07.380 --> 01:22:08.380
输出非常好

01:22:08.380 --> 01:22:09.380
来看一下对不对

01:22:09.380 --> 01:22:10.380
6加4

01:22:10.380 --> 01:22:12.380
来算一下吧

01:22:12.380 --> 01:22:14.380
出现问题了

01:22:14.380 --> 01:22:15.380
等一下

01:22:15.380 --> 01:22:19.660
调试一下问题

01:22:19.660 --> 01:22:20.660
这里出现问题了

01:22:20.660 --> 01:22:21.660
我看一下

01:22:21.660 --> 01:22:25.220
它是在这里出现的问题

01:22:25.220 --> 01:22:29.860
就是比较两个優先级的时候

01:22:29.860 --> 01:22:30.860
我看一下

01:22:30.860 --> 01:22:32.860
哪里出的问题

01:22:32.860 --> 01:22:34.860
看到右扩号

01:22:34.860 --> 01:22:40.020
算没问题

01:22:40.020 --> 01:22:42.020
呃

01:22:42.020 --> 01:22:43.020
这里

01:22:43.020 --> 01:22:44.020
它说这个东西

01:22:44.020 --> 01:22:46.020
有一个东西是now

01:22:46.020 --> 01:22:49.340
我想一想啊

01:22:49.340 --> 01:22:50.340
如果说是左扩号

01:22:50.340 --> 01:22:52.340
顶部是左扩号

01:22:52.340 --> 01:22:57.700
那么就直接住站

01:22:57.700 --> 01:22:58.700
如果说是

01:22:58.700 --> 01:23:01.700
如果说優先级

01:23:01.700 --> 01:23:03.700
左右扩号没有

01:23:03.700 --> 01:23:04.700
没有

01:23:04.700 --> 01:23:06.700
哦对对对

01:23:06.700 --> 01:23:09.700
但是也不对啊

01:23:09.700 --> 01:23:11.700
它前面判断了左扩号

01:23:11.700 --> 01:23:12.700
哦这里是

01:23:12.700 --> 01:23:13.700
这里写错了啊

01:23:13.700 --> 01:23:14.700
左扩号

01:23:14.700 --> 01:23:15.700
知道了

01:23:15.700 --> 01:23:16.700
这里是左扩号

01:23:16.700 --> 01:23:19.260
好

01:23:19.260 --> 01:23:20.260
预算

01:23:20.260 --> 01:23:21.260
27

01:23:21.260 --> 01:23:22.260
看一下吧

01:23:22.260 --> 01:23:24.260
22

01:23:24.260 --> 01:23:25.260
5

01:23:25.260 --> 01:23:27.580
10

01:23:27.580 --> 01:23:28.580
复

01:23:28.580 --> 01:23:29.580
是不是27

01:23:29.580 --> 01:23:30.580
对吧

01:23:30.580 --> 01:23:31.580
正确的

01:23:31.580 --> 01:23:33.580
看一下整个预算过程

01:23:33.580 --> 01:23:35.580
预算

01:23:35.580 --> 01:23:36.580
预算过程

01:23:36.580 --> 01:23:37.580
一个一个拿

01:23:37.580 --> 01:23:39.580
是不是拿到第一个

01:23:39.580 --> 01:23:41.580
把这个打开

01:23:41.580 --> 01:23:43.580
看一下我们目前的那个手指

01:23:43.580 --> 01:23:44.580
那个手指

01:23:44.580 --> 01:23:46.580
把这个填到监视

01:23:46.580 --> 01:23:48.580
然后把两个站填到监视

01:23:48.580 --> 01:23:52.490
填到监视

01:23:52.490 --> 01:23:53.490
好走起来啊

01:23:53.490 --> 01:23:54.490
看监视

01:23:54.490 --> 01:23:55.490
就看这几个东西就行了

01:23:55.490 --> 01:23:58.990
这个不要了

01:23:58.990 --> 01:24:00.990
好看一下啊

01:24:00.990 --> 01:24:05.330
就这个

01:24:05.330 --> 01:24:06.330
好现在呢

01:24:06.330 --> 01:24:07.330
我们拿出来的是什么

01:24:07.330 --> 01:24:08.330
下一个数字是什么

01:24:08.330 --> 01:24:18.360
下一个数字是这个

01:24:18.360 --> 01:24:19.360
下一个数字是6

01:24:19.360 --> 01:24:20.360
对吧

01:24:20.360 --> 01:24:21.360
拿出来的6

01:24:21.360 --> 01:24:22.360
6是什么

01:24:22.360 --> 01:24:23.360
是一个数字

01:24:23.360 --> 01:24:24.360
那么数字直接入占

01:24:24.360 --> 01:24:26.360
你看数字占是多了个6了

01:24:26.360 --> 01:24:27.360
对不对

01:24:27.360 --> 01:24:28.360
多了个6

01:24:28.360 --> 01:24:29.360
然后下一个

01:24:29.360 --> 01:24:30.360
下一个是什么了

01:24:30.360 --> 01:24:31.360
下一个是

01:24:31.360 --> 01:24:32.360
加号

01:24:32.360 --> 01:24:33.360
加号了

01:24:33.360 --> 01:24:34.360
处理这个

01:24:34.360 --> 01:24:36.360
处理这个就是符号

01:24:36.360 --> 01:24:37.360
处理符号的时候

01:24:37.360 --> 01:24:38.360
符号占是空的

01:24:38.360 --> 01:24:39.360
夹号直接入占

01:24:39.360 --> 01:24:40.360
夹号直接入占

01:24:40.360 --> 01:24:41.360
下一个

01:24:41.360 --> 01:24:42.360
下一个有什么

01:24:42.360 --> 01:24:43.360
下一个又是16

01:24:43.360 --> 01:24:44.360
16是一个数字

01:24:44.360 --> 01:24:46.360
数字直接入占

01:24:46.360 --> 01:24:47.360
然后再下一个是什么了

01:24:47.360 --> 01:24:48.360
再下一个是简号

01:24:48.360 --> 01:24:49.360
简号的优先级

01:24:49.360 --> 01:24:51.360
是不是小微等于加号的

01:24:51.360 --> 01:24:52.360
那应该怎么办

01:24:52.360 --> 01:24:53.360
应该把加号弹出

01:24:53.360 --> 01:24:54.360
然后这个两个数字

01:24:54.360 --> 01:24:56.360
相加22入占

01:24:56.360 --> 01:24:57.360
这个运算完了过后

01:24:57.360 --> 01:24:58.360
这里是22

01:24:58.360 --> 01:24:59.360
这里是空的

01:24:59.360 --> 01:25:02.360
然后再加上一个简号

01:25:02.360 --> 01:25:03.360
处理完了过后

01:25:03.360 --> 01:25:06.360
所以一个简号变成了22

01:25:06.360 --> 01:25:08.360
好 再来

01:25:08.360 --> 01:25:09.360
下一个

01:25:09.360 --> 01:25:10.360
下一个是组货号

01:25:10.360 --> 01:25:12.360
组货号直接入占

01:25:12.360 --> 01:25:13.360
然后再下一个

01:25:13.360 --> 01:25:15.360
再下一个是数字3

01:25:15.360 --> 01:25:17.360
数字直接入占

01:25:17.360 --> 01:25:18.360
然后再下一个

01:25:18.360 --> 01:25:20.360
就看到非常清楚了

01:25:20.360 --> 01:25:21.360
夹号

01:25:21.360 --> 01:25:22.360
占顶是组货号

01:25:22.360 --> 01:25:23.360
没法算

01:25:23.360 --> 01:25:25.360
只能入占

01:25:25.360 --> 01:25:26.360
就夹号直接入占

01:25:26.360 --> 01:25:27.360
再下一个

01:25:27.360 --> 01:25:30.360
数字2直接入占

01:25:30.360 --> 01:25:31.360
再下一个

01:25:31.360 --> 01:25:32.360
简号

01:25:32.360 --> 01:25:33.360
好 简号的优先级

01:25:33.360 --> 01:25:34.360
是小微等于加号的

01:25:34.360 --> 01:25:35.360
余少怎么样

01:25:35.360 --> 01:25:36.360
加号弹出

01:25:36.360 --> 01:25:37.360
3加2等于5

01:25:37.360 --> 01:25:38.360
直接入占

01:25:38.360 --> 01:25:39.360
就把这个这一块

01:25:39.360 --> 01:25:40.360
替换成5

01:25:40.360 --> 01:25:41.360
就把这个东西

01:25:42.360 --> 01:25:44.360
把这个玩意替换成5

01:25:44.360 --> 01:25:45.360
替换成5

01:25:45.360 --> 01:25:47.360
然后把夹号的出占

01:25:47.360 --> 01:25:48.360
变成什么

01:25:48.360 --> 01:25:49.360
变成简号入占

01:25:50.360 --> 01:25:51.360
你要的意思吧

01:25:51.360 --> 01:25:53.360
好 继续看

01:25:53.360 --> 01:25:54.360
看是不是这样子

01:25:55.360 --> 01:25:57.360
这变成5简号入占

01:25:57.360 --> 01:25:58.360
然后再下一个

01:25:58.360 --> 01:25:59.360
再下一个是5

01:25:59.360 --> 01:26:00.360
又是5

01:26:00.360 --> 01:26:02.360
那么数字直接入占

01:26:02.360 --> 01:26:03.360
然后再下一个

01:26:04.360 --> 01:26:06.360
乘号优先级比它大

01:26:06.360 --> 01:26:07.360
直接入占

01:26:07.360 --> 01:26:08.360
再下一个

01:26:08.360 --> 01:26:10.360
2直接入占

01:26:11.360 --> 01:26:12.360
然后再下一个

01:26:12.360 --> 01:26:13.360
又货号

01:26:13.360 --> 01:26:14.360
那么这个时候

01:26:14.360 --> 01:26:15.360
要一个个算了

01:26:15.360 --> 01:26:17.360
对吧 要一个一个进行算

01:26:17.360 --> 01:26:18.360
首先算什么呢

01:26:18.360 --> 01:26:19.360
算那个

01:26:19.360 --> 01:26:22.360
我们就直接算完了

01:26:22.360 --> 01:26:24.360
我这里下一个

01:26:24.360 --> 01:26:25.360
下一个就直接算完了

01:26:25.360 --> 01:26:26.360
它一直要算到左货号

01:26:26.360 --> 01:26:27.360
把左货号

01:26:27.360 --> 01:26:28.360
然后直到出占为止

01:26:28.360 --> 01:26:30.360
所以算出来货号里面就是负5

01:26:30.360 --> 01:26:32.360
对吧 要算到左货号为止

01:26:32.360 --> 01:26:33.360
好 算出来就是负5

01:26:33.360 --> 01:26:34.360
那么最后呢

01:26:34.360 --> 01:26:36.360
就循环结束了

01:26:36.360 --> 01:26:37.360
就循环结束了

01:26:37.360 --> 01:26:38.360
循环结束了

01:26:38.360 --> 01:26:39.360
是不是占里面还有东西

01:26:39.360 --> 01:26:40.360
那么要把占清空

01:26:40.360 --> 01:26:42.360
是不是要一直运算

01:26:42.360 --> 01:26:43.360
直到把占清空为止

01:26:43.360 --> 01:26:44.360
现在只有一个了

01:26:44.360 --> 01:26:45.360
然后一运算

01:26:45.360 --> 01:26:46.360
是不是就

01:26:46.360 --> 01:26:47.360
这个东西出占

01:26:47.360 --> 01:26:48.360
这两个东西一减

01:26:48.360 --> 01:26:49.360
是不是就是

01:26:51.360 --> 01:26:53.360
22减去负5

01:26:53.360 --> 01:26:54.360
是不是就27

01:26:54.360 --> 01:26:56.360
这样子运算完了过

01:26:56.360 --> 01:26:57.360
是不是27

01:26:57.360 --> 01:26:58.360
最后得到占定

01:26:58.360 --> 01:26:59.360
就完成

01:27:00.360 --> 01:27:03.360
就整个的过程

01:27:03.360 --> 01:27:04.360
那么这个玩意呢

01:27:04.360 --> 01:27:06.360
它确实比较复杂一点

01:27:06.360 --> 01:27:07.360
我现在呢

01:27:07.360 --> 01:27:08.360
这个东西讲完了

01:27:08.360 --> 01:27:09.360
将来呢

01:27:09.360 --> 01:27:11.360
大家可以去尝试做一下

01:27:11.360 --> 01:27:12.360
可能会比较耗费时间

01:27:12.360 --> 01:27:14.360
可能会耗费你一两天

01:27:14.360 --> 01:27:15.360
反正之前呢

01:27:15.360 --> 01:27:16.360
我是在学校里面

01:27:16.360 --> 01:27:17.360
是耗了几天的时间吧

01:27:17.360 --> 01:27:18.360
搞定的

01:27:18.360 --> 01:27:19.360
然后呢

01:27:19.360 --> 01:27:20.360
接下来我跟大家说一下

01:27:20.360 --> 01:27:21.360
就是之前呢

01:27:21.360 --> 01:27:22.360
有一个坑

01:27:22.360 --> 01:27:23.360
就是关于负数的情况

01:27:23.360 --> 01:27:24.360
就是有可能

01:27:24.360 --> 01:27:26.360
它的数字是这样子写的

01:27:26.360 --> 01:27:28.360
3加上一个正额

01:27:28.360 --> 01:27:30.360
减去一个负5

01:27:30.360 --> 01:27:31.360
那么这种情况呢

01:27:31.360 --> 01:27:33.360
做法是怎么做的呢

01:27:33.360 --> 01:27:34.360
你要把它当

01:27:34.360 --> 01:27:35.360
它也当成一个符号

01:27:35.360 --> 01:27:36.360
它还是一个符号

01:27:36.360 --> 01:27:37.360
它还是一个符号

01:27:37.360 --> 01:27:38.360
只不过这个符号呢

01:27:38.360 --> 01:27:39.360
还比较特殊

01:27:39.360 --> 01:27:40.360
它算长得跟它一样

01:27:40.360 --> 01:27:41.360
但它的意识不一样

01:27:41.360 --> 01:27:43.360
它是表示正负关系

01:27:43.360 --> 01:27:45.360
它是一个一元运算符

01:27:46.360 --> 01:27:47.360
你看我们的符号

01:27:47.360 --> 01:27:49.360
它是有二元一元

01:27:49.360 --> 01:27:50.360
三元对吧

01:27:50.360 --> 01:27:51.360
那么我们怎么来处理

01:27:51.360 --> 01:27:52.360
一元运算符呢

01:27:52.360 --> 01:27:53.360
你要这样子做

01:27:53.360 --> 01:27:54.360
你需要在这个地方呢

01:27:54.360 --> 01:27:56.360
定义符号的时候呢

01:27:56.360 --> 01:27:57.360
就还要多定一些

01:27:57.360 --> 01:27:58.360
它不仅有优先级

01:27:58.360 --> 01:28:00.360
它还有几元

01:28:00.360 --> 01:28:02.360
它还有几元

01:28:02.360 --> 01:28:04.360
那么这个

01:28:04.360 --> 01:28:06.360
几元的话就是

01:28:07.360 --> 01:28:09.360
单词叫啥名字呢

01:28:09.360 --> 01:28:11.360
那就元嘛

01:28:11.360 --> 01:28:12.360
这是一个二元的啊

01:28:12.360 --> 01:28:14.360
这是一个二元的

01:28:14.360 --> 01:28:16.360
这是一个

01:28:16.360 --> 01:28:17.360
二元的

01:28:17.360 --> 01:28:19.360
现在我们目前都是二元的对吧

01:28:19.360 --> 01:28:20.360
那么一会儿呢

01:28:20.360 --> 01:28:21.360
有个正号

01:28:21.360 --> 01:28:22.360
正号呢你可以用一个

01:28:22.360 --> 01:28:23.360
特殊的加号表示

01:28:23.360 --> 01:28:26.250
比方说

01:28:26.250 --> 01:28:28.250
用一个A塔加号嘛

01:28:28.250 --> 01:28:29.250
它表示它表示的是一个

01:28:29.250 --> 01:28:30.250
不是一个普通的加号

01:28:30.250 --> 01:28:32.250
是一个正号

01:28:32.250 --> 01:28:33.250
那么像这个符号呢

01:28:33.250 --> 01:28:34.250
它的元呢

01:28:34.250 --> 01:28:35.250
它就是一个一元的

01:28:35.250 --> 01:28:36.250
对吧

01:28:36.250 --> 01:28:37.250
到时候你分析

01:28:37.250 --> 01:28:38.250
是的是你要分析出来

01:28:38.250 --> 01:28:40.250
它到底是一个普通的加号

01:28:40.250 --> 01:28:41.250
还是一个正复符号

01:28:41.250 --> 01:28:43.250
那么需要去分析

01:28:43.250 --> 01:28:44.250
如果分析出来

01:28:44.250 --> 01:28:45.250
它是一个正号的话

01:28:45.250 --> 01:28:46.250
那么你可以用一个

01:28:46.250 --> 01:28:47.250
特殊之符来表示

01:28:47.250 --> 01:28:48.250
给大家前面加上

01:28:48.250 --> 01:28:49.250
一个A塔呀之类的东西

01:28:49.250 --> 01:28:50.250
来表示

01:28:50.250 --> 01:28:51.250
它是一个一元预算符

01:28:51.250 --> 01:28:53.250
那么一元预算符的时候

01:28:53.250 --> 01:28:54.250
算的时候

01:28:54.250 --> 01:28:55.250
它就是这样子算的

01:28:55.250 --> 01:28:56.250
它不能传两个参数进来

01:28:56.250 --> 01:28:58.250
它只能传一个参数

01:28:58.250 --> 01:28:59.250
那么反过来是什么

01:28:59.250 --> 01:29:00.250
反过来就是它

01:29:00.250 --> 01:29:02.250
那如果说你是一个A塔简号呢

01:29:02.250 --> 01:29:03.250
A塔简呢

01:29:03.250 --> 01:29:04.250
那么反过来

01:29:04.250 --> 01:29:06.250
就应该是负A

01:29:06.250 --> 01:29:07.250
那意思吧

01:29:07.250 --> 01:29:08.250
你要用这种方式预算

01:29:08.250 --> 01:29:09.250
那么到时候

01:29:09.250 --> 01:29:11.250
也会影响你的初战规则

01:29:11.250 --> 01:29:12.250
你初战的时候呢

01:29:12.250 --> 01:29:14.250
它就只能谈出一个数字

01:29:14.250 --> 01:29:15.250
你就不能谈两个了

01:29:15.250 --> 01:29:17.250
你只能谈一个数字出来

01:29:17.250 --> 01:29:18.250
那么这个情况

01:29:18.250 --> 01:29:20.250
要比较复杂一点

01:29:21.250 --> 01:29:22.250
好

01:29:22.250 --> 01:29:23.250
那么今天晚上就到这了

01:29:23.250 --> 01:29:24.250
其实我再重申一次

01:29:24.250 --> 01:29:25.250
这个玩意呢

01:29:25.250 --> 01:29:26.250
它并不会影响

01:29:26.250 --> 01:29:28.250
你们以后的开发

01:29:28.250 --> 01:29:29.250
你不会这个

01:29:29.250 --> 01:29:30.250
以后就不能选选

01:29:30.250 --> 01:29:31.250
那就不能做算了

01:29:31.250 --> 01:29:32.250
它不存在的

01:29:32.250 --> 01:29:33.250
它会影响到怎么呢

01:29:33.250 --> 01:29:34.250
它会影响到你的信心

01:29:34.250 --> 01:29:35.250
如果说你

01:29:35.250 --> 01:29:36.250
开发的话

01:29:36.250 --> 01:29:37.250
你就会心情大蒸

01:29:38.250 --> 01:29:39.250
那么对你之后的学习有好处

01:29:39.250 --> 01:29:40.250
而且呢

01:29:40.250 --> 01:29:41.250
你通过这个做这个例子呢

01:29:42.250 --> 01:29:44.250
你可以对只能逻辑思维

01:29:44.250 --> 01:29:46.250
以及一些棘手的问题的处理呢

01:29:46.250 --> 01:29:48.250
锻炼一些技巧

01:29:49.250 --> 01:29:50.250
将来遇到了

01:29:50.250 --> 01:29:51.250
虽然跟这个问题毫无关系

01:29:51.250 --> 01:29:52.250
但是呢

01:29:52.250 --> 01:29:53.250
你至少处理一些技巧的东西呢

01:29:53.250 --> 01:29:54.250
是有了

01:29:54.250 --> 01:29:55.250
你至少不说别的

01:29:56.250 --> 01:29:58.250
你这些怎么读属性啊

01:29:58.250 --> 01:29:59.250
什么政策表达

01:29:59.250 --> 01:30:00.250
是这一块是不是得到练习了

01:30:00.250 --> 01:30:01.250
对吧

01:30:02.250 --> 01:30:03.250
OK

01:30:03.250 --> 01:30:04.250
好了

01:30:04.250 --> 01:30:05.250
看来就到这了

