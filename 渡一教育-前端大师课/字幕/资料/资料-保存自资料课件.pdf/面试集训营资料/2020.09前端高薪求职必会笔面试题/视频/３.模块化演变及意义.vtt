WEBVTT

00:00.000 --> 00:05.000
来吧 你从来问到Promise的应用场景是吧

00:05.000 --> 00:07.500
昨天到时是这样啊

00:07.500 --> 00:09.200
任何一个技术呢

00:09.200 --> 00:12.500
首先你要知道它出现为什么为什么会出现这个东西

00:12.500 --> 00:14.000
这是你首先要理解的

00:14.000 --> 00:16.500
为什么会出现它要解决什么样的问题

00:16.500 --> 00:20.000
第二个呢是理解它的怎么去使用

00:20.000 --> 00:22.500
它是解决方案是什么

00:22.500 --> 00:25.500
就像我们昨天讲的Promise的模型段

00:25.500 --> 00:28.500
它是用什么样的理念去解决这个问题的

00:28.500 --> 00:32.000
很重要 因为你们以后在开发的过程中啊

00:32.000 --> 00:34.000
会遇到各种奇葩的场景

00:34.000 --> 00:36.000
你们以后到公司里面就知道了

00:36.000 --> 00:38.500
这里边应该有一些已经参加工作的人

00:38.500 --> 00:41.000
有些非常极端的场景

00:41.000 --> 00:45.000
一时半会一点往上 百度 谷歌完全找不到解决办法

00:45.000 --> 00:46.000
其他理智与惹想

00:46.000 --> 00:47.000
那么这个时候呢

00:47.000 --> 00:49.000
以前期积累的这些经验

00:49.000 --> 00:52.000
就是去看别人的那些技术是怎么去解决问题的

00:52.000 --> 00:54.000
那么就会帮助到你

00:54.000 --> 00:55.000
第二个

00:55.000 --> 00:57.500
第三个呢就是理解它的一些技术细节

00:57.500 --> 01:00.000
包括我们昨天说的Promise API

01:00.000 --> 01:00.500
对不对

01:00.500 --> 01:02.000
它到底是怎么去解决的

01:02.000 --> 01:05.000
它用的是什么样的一种代码结构

01:05.000 --> 01:07.000
这是你大家需要理解的

01:07.000 --> 01:09.000
然后最后才差的应用场景

01:09.000 --> 01:12.000
其实如果说你前期代码量积累的足够的话

01:12.000 --> 01:13.500
都不用我讲了

01:13.500 --> 01:15.000
你自己都明白它的应用场景了

01:15.000 --> 01:18.500
因为比方说你以前没有用Promise之前

01:18.500 --> 01:21.500
你写了过来表演写过一个项目

01:21.500 --> 01:22.500
那个项目呢

01:22.500 --> 01:24.000
涉及到两三千行代码吧

01:24.000 --> 01:25.000
也不多

01:25.000 --> 01:29.000
那个里面你一定可能会遇到很多很多的异部场景

01:29.000 --> 01:31.000
包括网络通信对吧

01:31.000 --> 01:33.000
最多的网络通信的情况

01:33.000 --> 01:34.000
那么这些东西呢

01:34.000 --> 01:35.000
你被毁掉函数

01:35.000 --> 01:37.000
早的搞得痛不欲生了

01:37.000 --> 01:40.000
这个时候你看到Promise就跟那个

01:40.000 --> 01:42.000
九汉逢甘路一样

01:42.000 --> 01:43.000
它像玉固枝一样

01:43.000 --> 01:44.000
就看到就行了

01:44.000 --> 01:46.000
这个时候不用我告诉你

01:46.000 --> 01:49.000
他的应用场景你马上就明白了

01:49.000 --> 01:50.000
而如果说我要说的话

01:50.000 --> 01:52.000
这个Promise的应用场景呢

01:52.000 --> 01:54.000
有两个

01:54.000 --> 01:57.000
一个呢是有一些API

01:57.000 --> 02:00.000
就是有些数组环境给你提供的API

02:00.000 --> 02:02.000
它已经决定就是封装成一个Promise

02:02.000 --> 02:03.000
你直接用就行了

02:03.000 --> 02:06.000
比方说我们在ES6里面讲到这个废棋API

02:06.000 --> 02:07.000
里面以后都会学习的

02:07.000 --> 02:08.000
它就是一个函数

02:08.000 --> 02:10.000
这个函数反过来就是个Promise

02:10.000 --> 02:12.000
你不用你去自己封装了

02:12.000 --> 02:13.000
它给你写好了

02:13.000 --> 02:15.000
然后你直接拿来就用

02:15.000 --> 02:17.000
拿到Promise过来就是Zing

02:17.000 --> 02:18.000
对不对

02:18.000 --> 02:19.000
然后开启

02:19.000 --> 02:20.000
然后链是调用

02:20.000 --> 02:22.000
或者是用ES7的Async and Wait

02:22.000 --> 02:23.000
都可以用

02:23.000 --> 02:25.000
包括在NoteJS里面

02:25.000 --> 02:27.000
你们以后需要Note

02:27.000 --> 02:29.000
NoteJS里面什么

02:29.000 --> 02:30.000
这个模块

02:30.000 --> 02:32.000
不太不知这个模块

02:32.000 --> 02:34.000
这个流的处理

02:34.000 --> 02:36.000
这里面也有很多的Promise

02:36.000 --> 02:37.000
文件处理

02:37.000 --> 02:38.000
这里面有很多的Promise

02:38.000 --> 02:41.000
那么你直接拿过来就用就行了

02:41.000 --> 02:42.000
而有的时候呢

02:42.000 --> 02:46.000
可能你拿到的还是一个毁掉模式

02:46.000 --> 02:47.000
那么这个时候呢

02:47.000 --> 02:48.000
你就可以封装

02:48.000 --> 02:50.000
比方说像咱们昨天举的这个例子

02:50.000 --> 02:53.630
我们的浏览器里面不是给我们提供了一个

02:53.630 --> 02:54.630
Set Timeout函数吗

02:54.630 --> 02:55.630
对不对

02:55.630 --> 02:57.630
那么这个函数还是一个传统的方式

02:57.630 --> 02:59.630
就是一个毁掉

02:59.630 --> 03:00.630
毁掉函数的这种模式

03:00.630 --> 03:01.630
那么这个时候呢

03:01.630 --> 03:03.630
你可以手动的把它封装一下

03:03.630 --> 03:04.630
把它变成一个Promise

03:04.630 --> 03:05.630
怎么变呢

03:05.630 --> 03:07.630
我们昨天写过

03:07.630 --> 03:10.630
你给我一个传一个时间

03:10.630 --> 03:13.630
我给你返回一个Promise

03:13.630 --> 03:15.630
Result

03:15.630 --> 03:17.630
然后Set Timeout

03:17.630 --> 03:19.630
Direct

03:19.630 --> 03:20.630
这里面啥都不用做

03:20.630 --> 03:21.630
Result

03:21.630 --> 03:22.630
完事

03:22.630 --> 03:23.630
封装一个Direct函数

03:23.630 --> 03:24.630
那么以为这个函数过后了

03:24.630 --> 03:25.630
我们是会别人使用的

03:25.630 --> 03:26.630
就非常方便的

03:26.630 --> 03:27.630
就不像以前那样子

03:27.630 --> 03:28.630
等待多少时间

03:28.630 --> 03:29.630
要去用一个毁掉函数

03:29.630 --> 03:30.630
以后呢

03:30.630 --> 03:31.630
我们就不用毁掉函数了

03:31.630 --> 03:33.630
比方说我们自己随便写一个

03:33.630 --> 03:35.630
Test

03:35.630 --> 03:37.630
我先输出一个1

03:37.630 --> 03:38.630
然后呢

03:38.630 --> 03:39.630
等待

03:39.630 --> 03:41.630
1秒钟

03:41.630 --> 03:42.630
输出一个2

03:42.630 --> 03:45.630
再等待

03:45.630 --> 03:47.630
去内

03:47.630 --> 03:48.630
1秒钟

03:48.630 --> 03:50.630
然后输出一个3

03:50.630 --> 03:51.630
明儿的意思吧

03:51.630 --> 03:53.630
我们这里输出一下Test

03:53.630 --> 03:55.630
运行

03:55.630 --> 03:56.630
一等待1秒2

03:56.630 --> 03:58.630
然后再输出3

03:58.630 --> 03:59.630
什么意思

03:59.630 --> 04:00.630
甚至呢

04:00.630 --> 04:01.630
你还可以这样子玩

04:01.630 --> 04:02.630
你还可以这样子玩

04:02.630 --> 04:03.630
快好

04:03.630 --> 04:04.630
这里

04:04.630 --> 04:06.630
Cod

04:06.630 --> 04:07.630
Cod

04:07.630 --> 04:09.630
Wild

04:09.630 --> 04:10.630
一个使循环

04:10.630 --> 04:11.630
每一次输出

04:11.630 --> 04:13.630
Cod加加

04:13.630 --> 04:14.630
这样子是不是

04:14.630 --> 04:15.630
达到一个

04:15.630 --> 04:16.630
达到一个

04:16.630 --> 04:18.630
这里还有一个

04:18.630 --> 04:19.630
1秒钟

04:19.630 --> 04:20.630
这里是不是

04:20.630 --> 04:21.630
还达到一个

04:21.630 --> 04:22.630
SetsInterval的效果

04:22.630 --> 04:23.630
你看一下

04:23.630 --> 04:24.630
0

04:24.630 --> 04:25.630
1

04:25.630 --> 04:26.630
2

04:26.630 --> 04:27.630
就一直输出下去

04:27.630 --> 04:29.630
C停止

04:29.630 --> 04:31.630
就应用场地还是很多的

04:31.630 --> 04:32.630
要不然

04:32.630 --> 04:33.630
要不然就是他给你返回个Promise

04:33.630 --> 04:35.630
你自己去拿过来用

04:35.630 --> 04:36.630
要不然呢

04:36.630 --> 04:37.630
就是你自己去封撞一下

04:37.630 --> 04:38.630
比方说我们以后

04:38.630 --> 04:40.630
在Note.js里边会学些

04:40.630 --> 04:41.630
流处理

04:41.630 --> 04:42.630
流处里边有些App

04:42.630 --> 04:44.630
它就不是给你封撞的Promise

04:44.630 --> 04:45.630
比方说我们从流里边

04:45.630 --> 04:46.630
一块一块读数据

04:46.630 --> 04:47.630
总归有一天

04:47.630 --> 04:48.630
要把这个数据读完

04:48.630 --> 04:49.630
读完的时候

04:49.630 --> 04:50.630
我们的任务完成

04:50.630 --> 04:51.630
那么这个时候

04:51.630 --> 04:52.630
你可以封装一个函数

04:52.630 --> 04:54.630
而且像这个Promise

04:54.630 --> 04:55.630
这个东西

04:55.630 --> 04:56.630
你写的东西

04:56.630 --> 04:58.630
越底层

04:58.630 --> 04:59.630
它用到的东西

04:59.630 --> 05:00.630
你可能自己

05:00.630 --> 05:01.630
封装的就越多

05:01.630 --> 05:02.630
什么意思呢

05:02.630 --> 05:03.630
就比方你以后

05:03.630 --> 05:04.630
工作之后

05:04.630 --> 05:06.630
以后工作之后

05:06.630 --> 05:08.630
你有可能干两件事

05:08.630 --> 05:09.630
第一件事就是

05:09.630 --> 05:10.630
我们比方说到马龙

05:10.630 --> 05:12.630
我不希望他去干马龙

05:12.630 --> 05:14.630
但是呢

05:14.630 --> 05:15.630
现实是很多同学

05:15.630 --> 05:17.630
很多就是开发者

05:17.630 --> 05:18.630
就从事了马龙工作

05:18.630 --> 05:19.630
这样马龙工作呢

05:19.630 --> 05:21.630
没有什么技术含量

05:21.630 --> 05:22.630
现在就是干业务

05:22.630 --> 05:23.630
给你这一块功能

05:23.630 --> 05:24.630
你把实现

05:24.630 --> 05:25.630
你把做出来

05:25.630 --> 05:26.630
这一块功能给他做出来

05:26.630 --> 05:27.630
没有任何难度

05:27.630 --> 05:29.630
直接做出来就完事了

05:29.630 --> 05:30.630
那么这样的活

05:30.630 --> 05:31.630
你是平时

05:31.630 --> 05:33.630
是很少封装东西的

05:33.630 --> 05:34.630
因为你只是

05:34.630 --> 05:36.630
简单地把功能实现

05:36.630 --> 05:37.630
但是有的时候

05:37.630 --> 05:38.630
你要去写一些底层的东西

05:38.630 --> 05:39.630
比方说我要写个库

05:39.630 --> 05:41.630
我要写个插件

05:41.630 --> 05:42.630
这个库和插件

05:42.630 --> 05:43.630
需要给更多的人

05:43.630 --> 05:44.630
去使用

05:44.630 --> 05:46.630
比如说这个公司

05:46.630 --> 05:47.630
干活的过程中

05:47.630 --> 05:48.630
经常遇到一些

05:48.630 --> 05:49.630
同样的共性问题

05:49.630 --> 05:50.630
那么这些问题

05:50.630 --> 05:51.630
需要有公共的插件

05:51.630 --> 05:52.630
或者公共的库来解决

05:52.630 --> 05:53.630
那么这个时候

05:53.630 --> 05:55.630
你要考虑很多很多的问题

05:55.630 --> 05:56.630
你不仅要考虑

05:56.630 --> 05:57.630
如何去封装的问题

05:57.630 --> 05:58.630
如何去提取重复代码

05:58.630 --> 06:00.630
如何在各种场景里面应用

06:00.630 --> 06:02.630
而且还应用的方便

06:02.630 --> 06:03.630
还要考虑更多的

06:03.630 --> 06:04.630
设计模式

06:04.630 --> 06:05.630
如何让代码

06:05.630 --> 06:06.630
更加容易维护

06:06.630 --> 06:07.630
还要考虑效率

06:07.630 --> 06:08.630
还要知道一些算法的东西

06:08.630 --> 06:09.630
你考虑的东西

06:09.630 --> 06:10.630
就越多

06:10.630 --> 06:11.630
所以越底层的东西

06:11.630 --> 06:12.630
考虑的东西

06:12.630 --> 06:14.630
越商城的东西

06:14.630 --> 06:16.630
就是直接写功能的东西

06:16.630 --> 06:18.630
就是考虑的东西就越少

06:18.630 --> 06:19.630
一样的意思吧

06:19.630 --> 06:21.630
就这么回事

06:21.630 --> 06:23.630
好 今天咱们讲这个

06:23.630 --> 06:25.630
模块画

06:25.630 --> 06:28.630
后边有两道面试题

06:28.630 --> 06:31.630
模块画这一个东西

06:31.630 --> 06:33.630
是咱们前端

06:33.630 --> 06:37.630
真正兴起的一个根本原因

06:37.630 --> 06:39.630
大家知道以前前端

06:39.630 --> 06:40.630
是干嘛的吗

06:40.630 --> 06:42.630
我们把它叫做夜面展

06:42.630 --> 06:43.630
什么叫夜面展

06:43.630 --> 06:45.630
就是

06:45.630 --> 06:46.630
设计人员给我们

06:46.630 --> 06:47.630
设计好了一个设计稿

06:47.630 --> 06:48.630
生成一个PSD

06:48.630 --> 06:50.630
就是Forto Shop的文件

06:50.630 --> 06:52.630
然后这个文件之后呢

06:52.630 --> 06:53.630
来 夜面展

06:53.630 --> 06:54.630
过来过来过来

06:54.630 --> 06:56.630
我给你一个设计稿

06:56.630 --> 06:58.630
你把它变成静态夜面

06:58.630 --> 07:00.630
完了 这是前端干的活

07:00.630 --> 07:01.630
有技术还的吗

07:01.630 --> 07:02.630
有一点点

07:02.630 --> 07:03.630
不多

07:03.630 --> 07:05.630
没有什么难度的

07:05.630 --> 07:06.630
还原设计稿

07:06.630 --> 07:07.630
那么现在

07:07.630 --> 07:08.630
还有没有这样的工作

07:08.630 --> 07:09.630
这么轻松的工作

07:09.630 --> 07:11.630
有些小公司还有

07:11.630 --> 07:13.630
但是这种工作

07:13.630 --> 07:14.630
越来越少了

07:14.630 --> 07:15.630
现在薪水大域

07:15.630 --> 07:16.630
是没法看的

07:16.630 --> 07:19.630
可能跟行政

07:19.630 --> 07:20.630
前台小门

07:20.630 --> 07:22.630
可能搞不了多少

07:22.630 --> 07:24.630
因为它没有什么技术含量

07:24.630 --> 07:26.630
为什么前端能够兴起的

07:26.630 --> 07:27.630
以前前端为什么不能兴起

07:27.630 --> 07:28.630
因为以前前端

07:28.630 --> 07:30.630
它无法形成工程

07:30.630 --> 07:31.630
为什么没有办法

07:31.630 --> 07:32.630
形成工程呢

07:32.630 --> 07:33.630
就有两个重要原因

07:33.630 --> 07:34.630
一个是

07:34.630 --> 07:36.630
全局变量污染

07:36.630 --> 07:37.630
一个是难以管理的

07:37.630 --> 07:38.630
一代关系

07:38.630 --> 07:39.630
主要说

07:39.630 --> 07:40.630
一个全局变量污染了

07:40.630 --> 07:42.630
它都是深有体会

07:42.630 --> 07:44.630
以写一个GS的时候

07:44.630 --> 07:46.630
里边定义的每一个变量

07:46.630 --> 07:48.630
全是全局变量

07:48.630 --> 07:49.630
它会挂到

07:49.630 --> 07:51.630
是挂在这个Windows里边

07:51.630 --> 07:54.630
它会把全局变量给污染了

07:54.630 --> 07:56.630
这个问题能不能解决

07:56.630 --> 07:57.630
我想一想

07:57.630 --> 07:58.630
这个问题能不能解决

07:58.630 --> 08:01.260
过去

08:01.260 --> 08:02.260
能不能解决

08:02.260 --> 08:04.260
这个全局变量污染问题

08:04.260 --> 08:06.260
有没有什么办法呢

08:06.260 --> 08:08.260
当然有很多人

08:08.260 --> 08:09.260
那是ES6

08:09.260 --> 08:10.260
那是ES6出来的

08:10.260 --> 08:12.260
就是ES6之前

08:12.260 --> 08:13.260
能不能解决

08:13.260 --> 08:15.260
全局变量污染的问题呢

08:15.260 --> 08:17.260
事实上是很难解决的

08:17.260 --> 08:18.260
当时很多人就提出了

08:18.260 --> 08:19.260
很多模式

08:19.260 --> 08:21.260
什么立即执行函数

08:21.260 --> 08:23.260
什么单对向模式

08:23.260 --> 08:25.260
还搞出乱七八糟的一大堆东西

08:25.260 --> 08:26.260
都是为了解决这个问题

08:26.260 --> 08:27.260
这个问题

08:27.260 --> 08:29.260
但是得不到彻底的解决

08:29.260 --> 08:32.260
为什么得不到彻底的解决呢

08:32.260 --> 08:33.260
是因为你总要暴露

08:33.260 --> 08:34.260
一些东西给别人用吧

08:34.260 --> 08:36.260
比方说有一天

08:36.260 --> 08:37.260
马逸同学

08:37.260 --> 08:39.260
来吧来来来过来

08:39.260 --> 08:40.260
我们公司现在

08:40.260 --> 08:42.260
经常要用到一些

08:42.260 --> 08:44.260
跟日期相关的处理

08:44.260 --> 08:46.260
麻烦你写一个解决文件

08:46.260 --> 08:48.260
你把这些日期相关的处理

08:48.260 --> 08:50.260
给我们暴露一些函数

08:50.260 --> 08:52.260
以后大家就不用重复地去写了

08:52.260 --> 08:54.260
直接用你写的函数就行了

08:54.260 --> 08:56.260
那你是不是得把函数暴露出来

08:56.260 --> 08:57.260
对不对

08:57.260 --> 08:58.260
把他放到全局里边

08:58.260 --> 08:59.260
你不把他放到全局里边

08:59.260 --> 09:00.260
别人怎么用的

09:00.260 --> 09:01.260
有的时候没有办法

09:01.260 --> 09:02.260
只能去污染

09:02.260 --> 09:05.260
就他们无法形成一个

09:06.260 --> 09:07.260
一个正常的关系

09:07.260 --> 09:08.260
要么就暴露给全局

09:08.260 --> 09:10.260
要么就完全不暴露

09:10.260 --> 09:11.260
他们没有办法形成一个

09:11.260 --> 09:12.260
正常的关系

09:12.260 --> 09:14.260
什么要正常的关系

09:14.260 --> 09:16.260
我张山用你的时候

09:16.260 --> 09:17.260
你暴露给我

09:17.260 --> 09:18.260
我不用你的时候

09:18.260 --> 09:20.260
你就一点都不暴露

09:20.260 --> 09:22.260
他没有办法形成这种关系

09:22.260 --> 09:23.260
因为以前的GS

09:23.260 --> 09:25.260
他就没有去设置这个东西

09:25.260 --> 09:26.260
这个东西很关键的

09:26.260 --> 09:27.260
不要小看这个东西

09:27.260 --> 09:30.260
这个东西就导致了

09:30.260 --> 09:33.260
GS是不可能开发大型项目的

09:33.260 --> 09:34.260
开发不了

09:34.260 --> 09:36.260
就是说它是什么落类型

09:36.260 --> 09:37.260
它是什么单线程

09:37.260 --> 09:39.260
这些都是小事

09:39.260 --> 09:40.260
而且单线程有的时候

09:40.260 --> 09:42.260
还有它的优势

09:42.260 --> 09:44.260
为什么露到GS会出现

09:44.260 --> 09:45.260
有点扯远了

09:45.260 --> 09:47.260
露了GS为什么会出现

09:47.260 --> 09:49.260
就是因为以前的外国服务器

09:49.260 --> 09:50.260
全是多线程的

09:50.260 --> 09:51.260
很多外国服务器

09:51.260 --> 09:52.260
都是多线程的

09:52.260 --> 09:54.260
东线程有严重的

09:54.260 --> 09:55.260
囤土量的问题

09:55.260 --> 09:56.260
都扯远了

09:56.260 --> 09:57.260
不扯远了

09:57.260 --> 09:59.260
单线程有它的优势

09:59.260 --> 10:00.260
并不是这些原因

10:00.260 --> 10:01.260
导致了GS

10:01.260 --> 10:02.260
无法开发大型项目

10:02.260 --> 10:03.260
根本的原因

10:03.260 --> 10:05.260
是因为它也没有模块化

10:05.260 --> 10:06.260
它没有办法分成

10:06.260 --> 10:07.260
每一个一个模块

10:07.260 --> 10:08.260
模块有模块时间

10:08.260 --> 10:09.260
互不干扰

10:09.260 --> 10:10.260
你干你的我干我的

10:10.260 --> 10:11.260
我要用你的时候

10:11.260 --> 10:12.260
你就暴露给我

10:12.260 --> 10:13.260
我不用你的时候

10:13.260 --> 10:14.260
你就自己玩

10:14.260 --> 10:15.260
它没办法形成这种关系

10:15.260 --> 10:17.260
所以导致了

10:17.260 --> 10:18.260
GS的工程

10:18.260 --> 10:19.260
它不可能很大

10:19.260 --> 10:21.260
这是第一个问题

10:21.260 --> 10:22.260
第二个问题是

10:22.260 --> 10:23.260
难以管理的依赖关系

10:23.260 --> 10:24.260
如果说

10:24.260 --> 10:26.260
这也是又是另外一个原因了

10:26.260 --> 10:27.260
就是GS工程

10:27.260 --> 10:29.260
为什么不能做得很大呢

10:29.260 --> 10:31.260
是因为一旦做大了过后

10:31.260 --> 10:32.260
你的文件一定很多

10:32.260 --> 10:34.260
有很多的GS文件

10:34.260 --> 10:35.260
那问题就来了

10:35.260 --> 10:36.260
你们如果说

10:36.260 --> 10:39.260
以前开发过一些传统项目

10:39.260 --> 10:40.260
可能很多人都没有开发过

10:40.260 --> 10:42.260
因为你们毕竟是

10:42.260 --> 10:43.260
新时代的人了

10:43.260 --> 10:44.260
一定是零零厚了

10:44.260 --> 10:45.260
也是九五厚了

10:45.260 --> 10:47.260
像我这种

10:49.260 --> 10:50.260
我也是十大岁

10:51.260 --> 10:53.260
我是听以前老人说的

10:53.260 --> 10:54.260
老人说的

10:54.260 --> 10:56.260
那么那个时代的关系

10:56.260 --> 10:58.260
就很麻烦

10:58.260 --> 10:59.260
就是有很多的GS

10:59.260 --> 11:01.260
它会怎么办呢

11:02.260 --> 11:03.260
不要看一下

11:03.260 --> 11:05.260
我们昨天的把关了

11:05.260 --> 11:07.260
它会有这么一个问题

11:07.260 --> 11:08.260
我在页面上

11:08.260 --> 11:09.260
就要引用很多的GS

11:09.260 --> 11:11.260
要写很多的script

11:11.260 --> 11:12.260
script的元素

11:12.260 --> 11:13.260
这倒没啥

11:13.260 --> 11:14.260
我去写的

11:14.260 --> 11:15.260
写的有什么大不了吗

11:15.260 --> 11:16.260
我去写吧

11:16.260 --> 11:17.260
A点GS

11:17.260 --> 11:18.260
引用一个

11:18.260 --> 11:19.260
就个例子

11:19.260 --> 11:21.260
然后呢

11:21.260 --> 11:23.260
引用一个B点GS

11:24.260 --> 11:25.260
然后呢

11:25.260 --> 11:26.260
引用一个C

11:26.260 --> 11:27.260
我就写到这儿吧

11:27.260 --> 11:29.260
我随便找个地方写吧

11:29.260 --> 11:31.260
你没懂我意思就写吧

11:33.830 --> 11:34.830
有写结束了

11:34.830 --> 11:35.830
要写的是吧

11:35.830 --> 11:43.710
好

11:43.710 --> 11:45.710
我给你声称一下吧

11:45.710 --> 11:46.710
script元素

11:46.710 --> 11:47.710
src

11:48.710 --> 11:49.710
等于

11:49.710 --> 11:50.710
点儿写干A

11:50.710 --> 11:52.710
多了点GS

11:52.710 --> 11:54.710
这个乘一个

11:55.710 --> 11:56.710
10

11:56.710 --> 11:57.710
真的算

11:58.710 --> 12:00.710
我要引用一大堆GS

12:00.710 --> 12:02.710
比方说乘一个20

12:02.710 --> 12:04.710
你觉得20很多吗

12:04.710 --> 12:05.710
21也都不多

12:06.710 --> 12:08.710
一运行出来

12:08.710 --> 12:09.710
抱错了

12:09.710 --> 12:11.710
某一个GS说

12:12.710 --> 12:13.710
你要引用我

12:13.710 --> 12:15.710
先得引用另外一个

12:15.710 --> 12:17.710
他说比方这个A9

12:17.710 --> 12:20.710
A9他又依赖这个S

12:20.710 --> 12:21.710
你得先引用S

12:21.710 --> 12:23.710
再去引用A9

12:23.710 --> 12:25.710
这个调整一下

12:25.710 --> 12:26.710
调整一下运行

12:26.710 --> 12:27.710
又抱错了

12:27.710 --> 12:29.710
这个A5说

12:29.710 --> 12:31.710
你得先引用S2

12:31.710 --> 12:32.710
再能引用我

12:32.710 --> 12:33.710
你懂我意思吗

12:33.710 --> 12:34.710
以前这种问题

12:34.710 --> 12:36.710
严重的不得了

12:36.710 --> 12:38.710
为什么有这种问题呢

12:38.710 --> 12:40.710
你们自己写的GS文件

12:40.710 --> 12:41.710
倒是

12:41.710 --> 12:42.710
这个问题倒是可以规避

12:42.710 --> 12:43.710
但是代码一多了

12:43.710 --> 12:44.710
也不好规避

12:44.710 --> 12:45.710
更要命的是

12:45.710 --> 12:46.710
你要用别人写的

12:46.710 --> 12:48.710
你要用第三方库

12:48.710 --> 12:49.710
你们知道

12:49.710 --> 12:50.710
像你们有些同学

12:50.710 --> 12:51.710
学过的结块

12:51.710 --> 12:52.710
结块里边

12:52.710 --> 12:53.710
不是有很多的

12:53.710 --> 12:54.710
第三方库吗

12:54.710 --> 12:55.710
要先引用结块

12:55.710 --> 12:56.710
再引用他

12:56.710 --> 12:57.710
对不对

12:58.710 --> 13:00.710
先引用结块才能引用

13:00.710 --> 13:01.710
那么如果说

13:01.710 --> 13:02.710
这种库一多了

13:02.710 --> 13:03.710
第三方库一多了

13:03.710 --> 13:04.710
这种依赖关系

13:04.710 --> 13:05.710
复杂得不得了

13:05.710 --> 13:07.710
而且这种关系

13:07.710 --> 13:08.710
你是很难预测的

13:08.710 --> 13:09.710
什么叫很难预测的

13:09.710 --> 13:10.710
你光看这个

13:10.710 --> 13:11.710
你能确定依赖关系吗

13:11.710 --> 13:12.710
一般的代码

13:12.710 --> 13:14.710
盯着看一年

13:14.710 --> 13:15.710
你都不知道

13:15.710 --> 13:16.710
他的依赖关系是什么

13:16.710 --> 13:17.710
你都不知道

13:17.710 --> 13:18.710
哪个依赖了哪一个

13:18.710 --> 13:19.710
你看不清楚

13:19.710 --> 13:21.710
依赖关系是很难管理的

13:21.710 --> 13:22.710
这也是他为什么

13:22.710 --> 13:24.710
难以形成大型的引用

13:24.710 --> 13:26.710
明白的意思吗

13:26.710 --> 13:27.710
其实我们今天的课呢

13:27.710 --> 13:28.710
是来自于

13:28.710 --> 13:29.710
咱们后期的这个

13:29.710 --> 13:30.710
魔幻化课程

13:30.710 --> 13:31.710
魔幻化是单独的一个课

13:31.710 --> 13:32.710
把这里抽离出来的

13:32.710 --> 13:34.710
把一些

13:34.710 --> 13:35.710
一些细致末节的

13:35.710 --> 13:36.710
给它省略了

13:36.710 --> 13:38.710
核心中的给它拿出来讲

13:38.710 --> 13:39.710
那么这个问题

13:39.710 --> 13:40.710
必须要解决

13:40.710 --> 13:41.710
不解决这个问题

13:41.710 --> 13:42.710
既也是前端

13:42.710 --> 13:43.710
要想发展

13:43.710 --> 13:44.710
那是不可能的

13:44.710 --> 13:45.710
想什么前后端分离

13:45.710 --> 13:46.710
不要想那里

13:46.710 --> 13:47.710
后端老老实实

13:47.710 --> 13:48.710
老老实实

13:48.710 --> 13:49.710
像以前的样子

13:49.710 --> 13:50.710
给我用模板引擎

13:50.710 --> 13:51.710
给我渲染页面

13:51.710 --> 13:52.710
不要找我了

13:52.710 --> 13:54.710
我就给你切图

13:54.710 --> 13:55.710
那这个问题必须要解决

13:55.710 --> 13:56.710
这个问题解决的方案

13:56.710 --> 13:57.710
就一种

13:57.710 --> 13:58.710
魔幻化

13:58.710 --> 14:00.710
既也是有很多年啊

14:00.710 --> 14:02.710
因为历史上的

14:02.710 --> 14:04.710
种种原因

14:04.710 --> 14:05.710
打了流战期大战

14:05.710 --> 14:06.710
有很多年

14:06.710 --> 14:08.710
既也是基本上是没动的

14:08.710 --> 14:10.710
将近有十多年的时间

14:10.710 --> 14:12.710
既也是完全没有更新

14:12.710 --> 14:13.710
还有一个重要的原因

14:13.710 --> 14:14.710
是一个ES4

14:14.710 --> 14:15.710
你们现在知道

14:15.710 --> 14:16.710
ES标准

14:16.710 --> 14:17.710
你们玩的是吗

14:17.710 --> 14:18.710
ES6

14:18.710 --> 14:19.710
ES7

14:19.710 --> 14:20.710
ES8

14:20.710 --> 14:21.710
以前的是ES4

14:21.710 --> 14:22.710
那个版本

14:22.710 --> 14:23.710
这么重要的版本

14:23.710 --> 14:24.710
它流产了

14:24.710 --> 14:25.710
它没出来

14:25.710 --> 14:26.710
没出来

14:26.710 --> 14:28.710
它有整个十年的空档期

14:28.710 --> 14:30.710
既也是完全没有更新

14:30.710 --> 14:32.710
而这十年时间内

14:32.710 --> 14:33.710
整个技术领域发展

14:33.710 --> 14:34.710
是非常非常迅速的

14:34.710 --> 14:36.710
既也是跟不上

14:36.710 --> 14:38.710
其他的技术都在发展

14:38.710 --> 14:39.710
它没有跟上

14:39.710 --> 14:40.710
那么这个

14:40.710 --> 14:42.710
这几年的就是

14:42.710 --> 14:43.710
最近这十年啊

14:43.710 --> 14:44.710
既也是还是猛敢

14:44.710 --> 14:46.710
疯狂地补以前的东西

14:46.710 --> 14:47.710
所以为什么

14:47.710 --> 14:48.710
这十年的既也是要补的东西

14:48.710 --> 14:49.710
这么多

14:49.710 --> 14:50.710
就是因为以前

14:50.710 --> 14:52.710
它欠缺的东西

14:52.710 --> 14:53.710
基本上

14:53.710 --> 14:54.710
正常的一个语言

14:54.710 --> 14:55.710
它都有魔幻化

14:55.710 --> 14:56.710
但以前既也是

14:56.710 --> 14:58.710
就是没有

14:58.710 --> 15:00.710
那么没有怎么办呢

15:00.710 --> 15:01.710
官方靠不住

15:01.710 --> 15:02.710
还得靠自己

15:02.710 --> 15:03.710
于是社区

15:03.710 --> 15:04.710
又粘出来了

15:04.710 --> 15:05.710
那个时候

15:05.710 --> 15:07.710
还有个历史的关系

15:07.710 --> 15:08.710
我在我后几颗成片

15:08.710 --> 15:09.710
慢慢去聊了这个事

15:09.710 --> 15:11.710
我们这里不多说了

15:11.710 --> 15:12.710
就是漏的出现了

15:12.710 --> 15:13.710
漏的出现了过后

15:13.710 --> 15:15.710
推动了魔幻化

15:15.710 --> 15:16.710
就是你流烂器

15:16.710 --> 15:17.710
我管不着了

15:17.710 --> 15:18.710
你流烂器

15:18.710 --> 15:19.710
你流烂器

15:19.710 --> 15:20.710
按照官方的来

15:20.710 --> 15:21.710
对不对

15:21.710 --> 15:22.710
官方没有魔幻化

15:22.710 --> 15:23.710
你也没办法

15:23.710 --> 15:24.710
那么漏的

15:24.710 --> 15:26.710
我完全可以

15:26.710 --> 15:27.710
不用按照官方的来

15:27.710 --> 15:28.710
我们自己考一个

15:28.710 --> 15:29.710
魔幻化出来

15:29.710 --> 15:30.710
于是出现了

15:30.710 --> 15:31.710
common.js

15:31.710 --> 15:32.710
common.js

15:32.710 --> 15:33.710
是社区规范

15:33.710 --> 15:35.710
它不是官方的

15:35.710 --> 15:36.710
谁最先支持

15:36.710 --> 15:38.710
就是漏的支持

15:38.710 --> 15:41.710
就是漏的社区搞出来的

15:41.710 --> 15:42.710
另外一个

15:42.710 --> 15:44.710
后来官方又做不住了

15:44.710 --> 15:45.710
首先不是官方做不住

15:45.710 --> 15:47.710
有些民间的社区

15:47.710 --> 15:48.710
做不住了

15:48.710 --> 15:49.710
你漏的玩的魔幻化

15:49.710 --> 15:50.710
玩的那么好

15:50.710 --> 15:51.710
而且你漏的

15:51.710 --> 15:52.710
有了魔幻化之后

15:52.710 --> 15:53.710
迅速的发展

15:53.710 --> 15:54.710
漏的社区迅速的发展

15:54.710 --> 15:55.710
很多的第三方顾

15:55.710 --> 15:56.710
不断的涌现

15:56.710 --> 15:57.710
为什么了

15:57.710 --> 15:58.710
可以拆分了

15:58.710 --> 15:59.710
很多事情

15:59.710 --> 16:00.710
我可以把它拆分的

16:00.710 --> 16:02.710
更成更加小的魔幻

16:02.710 --> 16:03.710
不像以前

16:03.710 --> 16:04.710
我只能形成一个

16:04.710 --> 16:05.710
很大的解释文件

16:05.710 --> 16:06.710
你看那个

16:06.710 --> 16:07.710
query的解释文件

16:07.710 --> 16:08.710
是不是很大

16:08.710 --> 16:09.710
几千行代

16:09.710 --> 16:10.710
它真的是这样子

16:10.710 --> 16:11.710
一行行敲出来的吗

16:11.710 --> 16:12.710
不是

16:12.710 --> 16:14.710
它是细分成很多文件的

16:14.710 --> 16:15.710
最后一打包

16:15.710 --> 16:18.710
合并成为一个大文件

16:18.710 --> 16:20.710
那么你要做一个大的工程

16:20.710 --> 16:22.710
就必须要把这东西细分

16:22.710 --> 16:24.710
而且他们之间互不赶早

16:24.710 --> 16:26.710
就是形成一个一个的小模块

16:26.710 --> 16:29.710
比方说咱们做日期处理

16:29.710 --> 16:31.710
关于日期处理

16:31.710 --> 16:33.710
我就形成一个解释

16:33.710 --> 16:35.710
关于随机数的处理

16:35.710 --> 16:36.710
我就形成一个解释

16:36.710 --> 16:37.710
对吧

16:37.710 --> 16:38.710
关于页面的轮波图

16:38.710 --> 16:39.710
我就形成一个解释

16:39.710 --> 16:41.710
关于页面的分页

16:41.710 --> 16:42.710
我就形成一个解释

16:42.710 --> 16:43.710
会形成一个页面

16:43.710 --> 16:44.710
一个工程里面

16:44.710 --> 16:46.710
会形成很多很多的解释

16:46.710 --> 16:48.710
那么这就是魔幻细分

16:48.710 --> 16:50.710
魔幻细分必须要有个前提

16:50.710 --> 16:51.710
就是魔幻化

16:51.710 --> 16:52.710
没用魔幻化

16:52.710 --> 16:53.710
魔幻细分根本不存在

16:53.710 --> 16:55.710
因为这两个问题又出来了

16:55.710 --> 16:56.710
是吧

16:56.710 --> 16:57.710
偶性实力

16:57.710 --> 16:58.710
你没法细分

16:58.710 --> 16:59.710
所以弄的

16:59.710 --> 17:00.710
首先支持魔幻化

17:00.710 --> 17:02.710
它的标准是common解释

17:02.710 --> 17:03.710
社区标准

17:03.710 --> 17:05.710
于是弄得迅速发展

17:05.710 --> 17:07.710
于是弄很多前端的

17:07.710 --> 17:08.710
开发者做不做了

17:08.710 --> 17:10.710
弄得玩得那么开心

17:10.710 --> 17:12.710
那我们流量系怎么办呢

17:12.710 --> 17:14.710
后妈都挺照顾我们的

17:14.710 --> 17:16.710
后班都挺照顾解释的

17:16.710 --> 17:17.710
流量系反而

17:17.710 --> 17:19.710
琴巴反而不理我们

17:19.710 --> 17:20.710
怎么办呢

17:20.710 --> 17:22.710
我们又自己考一个

17:22.710 --> 17:23.710
所以说呢

17:23.710 --> 17:24.710
很多前端开发者

17:24.710 --> 17:25.710
前端社区又搞出了

17:25.710 --> 17:28.710
AMD, CMD, UMD大堆

17:28.710 --> 17:30.710
又搞出了一些魔幻化标准

17:30.710 --> 17:32.710
后来官方终于做不住了

17:32.710 --> 17:33.710
说你们别玩了

17:33.710 --> 17:35.710
我还是给你们统一一下

17:35.710 --> 17:36.710
因为你们玩的东西

17:36.710 --> 17:38.710
流量系它又不甩你们

17:38.710 --> 17:39.710
流量系只支持官方的

17:39.710 --> 17:40.710
它又不甩你们

17:40.710 --> 17:41.710
所以说我给你们

17:41.710 --> 17:42.710
考一个官方的出来

17:42.710 --> 17:44.710
于是出现了ES6

17:44.710 --> 17:45.710
明儿的意思

17:45.710 --> 17:46.710
它是这么一个逻辑关系

17:46.710 --> 17:47.710
先出现了社区

17:47.710 --> 17:48.710
然后出现了官方

17:48.710 --> 17:50.710
这两个军事魔幻化标准

17:50.710 --> 17:51.710
什么叫标准

17:51.710 --> 17:52.710
就是我告诉大家

17:52.710 --> 17:53.710
就跟昨天一样

17:53.710 --> 17:55.710
Promise A加规范一样

17:55.710 --> 17:56.710
我告诉大家

17:56.710 --> 17:58.710
应该怎么来玩这个事情

17:58.710 --> 17:59.710
那么这个标准出现过后

17:59.710 --> 18:01.710
具体的宿主环境

18:01.710 --> 18:02.710
比如流量系

18:02.710 --> 18:03.710
漏的环境

18:03.710 --> 18:05.710
你就去实现这个标准

18:05.710 --> 18:07.710
就像咱们的GS一样

18:07.710 --> 18:08.710
ES是什么

18:08.710 --> 18:09.710
ES是语言标准

18:09.710 --> 18:10.710
就是说

18:10.710 --> 18:11.710
我告诉你

18:11.710 --> 18:12.710
语言是什么

18:12.710 --> 18:13.710
语言就是说话

18:13.710 --> 18:14.710
我告诉你

18:14.710 --> 18:15.710
判断该怎么来说

18:15.710 --> 18:17.710
我利用你的义符

18:17.710 --> 18:19.710
循环我们应该怎么来说

18:19.710 --> 18:20.710
用一个for

18:20.710 --> 18:22.710
或者是while

18:22.710 --> 18:23.710
编量该怎么来定义

18:23.710 --> 18:25.710
这是语言标准

18:25.710 --> 18:27.710
那么一个语言标准出来过后

18:27.710 --> 18:28.710
那些宿主环境

18:28.710 --> 18:29.710
标准流量系

18:29.710 --> 18:30.710
官方都说了

18:30.710 --> 18:31.710
衣服应该这样子写

18:31.710 --> 18:32.710
你不这样子写

18:32.710 --> 18:33.710
我就给你报错

18:33.710 --> 18:34.710
你这样子写了

18:34.710 --> 18:36.710
我就拿来给你解释执行

18:36.710 --> 18:37.710
这是宿主环境般的事

18:37.710 --> 18:39.710
具体实现

18:39.710 --> 18:40.710
解释就说吧

18:40.710 --> 18:43.710
这是它的一个背景

18:43.710 --> 18:44.710
好

18:44.710 --> 18:45.710
那么我们今天就学习

18:45.710 --> 18:46.710
这两个博化标准

18:46.710 --> 18:47.710
一个是comment界

18:47.710 --> 18:48.710
一个是ES6

18:48.710 --> 18:49.710
comment界也是

18:49.710 --> 18:51.710
浏览器是不支持的

18:51.710 --> 18:52.710
因为它不是官方的

18:52.710 --> 18:55.710
浏览器只支持两个东西

18:55.710 --> 18:57.710
一个是官方的

18:57.710 --> 18:59.710
一个是自己厂家搞的

18:59.710 --> 19:00.710
你说浏览器里面

19:00.710 --> 19:01.710
有些什么厂商潜罪

19:01.710 --> 19:02.710
对不对

19:02.710 --> 19:03.710
你自己厂家搞的

19:03.710 --> 19:05.710
还有就是官方的

19:05.710 --> 19:06.710
所以说第三方搞的

19:06.710 --> 19:08.710
它完全不甩它的

19:08.710 --> 19:09.710
comment界是

19:09.710 --> 19:10.710
但是它不甩它的原因

19:10.710 --> 19:11.710
还有一些别的原因

19:11.710 --> 19:13.710
我这里不展开了

19:13.710 --> 19:14.710
所以说目前

19:14.710 --> 19:15.710
comment界是需要

19:15.710 --> 19:16.710
浏览的环境才支持的

19:16.710 --> 19:18.710
因此我要讲这个模块话

19:18.710 --> 19:19.710
你就必须安装漏

19:19.710 --> 19:20.710
必须安装漏的

19:26.430 --> 19:27.430
现在安装漏的

19:27.430 --> 19:28.430
漏的官方地址在这

19:28.430 --> 19:34.560
给大家发过来一下吧

19:34.560 --> 19:36.560
这故事是听过是吧

19:36.560 --> 19:37.560
我这故事是原创的

19:37.560 --> 19:38.560
记得哪听过的

19:38.560 --> 19:40.560
我发现网上有一些博客

19:40.560 --> 19:42.560
就把我这个笔记拿过去

19:42.560 --> 19:43.560
直接当博客内容

19:43.560 --> 19:45.560
官方地址在这

19:45.560 --> 19:47.560
打开过后

19:47.560 --> 19:49.560
下载哪一个呢

19:49.560 --> 19:50.560
就直接下载就行了

19:50.560 --> 19:51.560
下载这个长期支持吧

19:52.560 --> 19:53.560
12.8.4

19:53.560 --> 19:54.560
你们那边应该是差不多

19:54.560 --> 19:55.560
点击过下载

19:55.560 --> 19:56.560
下载完了过后

19:56.560 --> 19:57.560
就是一个EXE文件

19:57.560 --> 19:58.560
安装下一步

19:58.560 --> 20:00.560
安装就完事了

20:00.560 --> 20:02.560
很简单的

20:02.560 --> 20:03.560
安装完了过后

20:03.560 --> 20:05.560
你要打开你的命令行

20:05.560 --> 20:06.560
看一下安装是不是成功了

20:06.560 --> 20:08.560
我给大家说一下安装

20:08.560 --> 20:09.560
命令行在哪呢

20:09.560 --> 20:10.560
你如果说麦普系统的话

20:10.560 --> 20:11.560
你懂的

20:11.560 --> 20:12.560
麦普系统肯定知道

20:12.560 --> 20:13.560
命令行在哪

20:14.560 --> 20:15.560
打开这个吧

20:15.560 --> 20:16.560
打开这个

20:16.560 --> 20:20.190
特命的

20:20.190 --> 20:22.190
这个命令行

20:22.190 --> 20:24.190
如果你是Windows的话

20:24.190 --> 20:26.190
Windows的话

20:26.190 --> 20:27.190
我给大家说一下

20:27.190 --> 20:29.570
Windows

20:29.570 --> 20:31.570
按住Windows键

20:31.570 --> 20:33.570
加R

20:33.570 --> 20:35.570
弹出一个那个框框

20:35.570 --> 20:36.570
对不对

20:36.570 --> 20:37.570
弹出一个运行框

20:37.570 --> 20:38.570
我这里没有把蓄地机开

20:38.570 --> 20:39.570
我忘了

20:39.570 --> 20:41.570
打开一个就是运行框

20:41.570 --> 20:43.570
然后在里面输入CMD

20:43.570 --> 20:44.570
一回车就出来了

20:44.570 --> 20:45.570
非常简单的

20:45.570 --> 20:46.570
非常简单

20:49.570 --> 20:50.570
打开命令行

20:50.570 --> 20:51.570
打开命令行之后

20:51.570 --> 20:53.570
在里面输入一个命令

20:53.570 --> 20:55.570
安装好了过后

20:55.570 --> 20:56.570
你需要重启这个中端

20:56.570 --> 20:57.570
这个中端命令行

20:57.570 --> 20:59.570
你需要重新关键重启

20:59.570 --> 21:01.570
如果说一开始打开的话

21:01.570 --> 21:02.570
输入一个漏的

21:02.570 --> 21:03.570
一个红杠斌

21:03.570 --> 21:04.570
表示漏的的版本

21:04.570 --> 21:05.570
我这里的版本

21:05.570 --> 21:06.570
我这里的漏的可能

21:06.570 --> 21:07.570
那边不太一样

21:07.570 --> 21:08.570
没关系

21:08.570 --> 21:09.570
跟我们今天学的没关系

21:09.570 --> 21:10.570
今天反正也不选漏的

21:10.570 --> 21:12.570
学的是他们的模块化

21:12.570 --> 21:14.570
我这里版本要高一点

21:14.570 --> 21:16.570
这是安装好漏的过后

21:16.570 --> 21:17.570
你就看到这个东西了

21:17.570 --> 21:18.570
当然他漏的

21:18.570 --> 21:19.570
安装过程中

21:19.570 --> 21:20.570
还自带了一个东西

21:20.570 --> 21:21.570
包管令器

21:21.570 --> 21:23.570
包管令器又是我们另外一个课程

21:23.570 --> 21:24.570
模块化和包管令器

21:24.570 --> 21:26.570
都是前装的重要的一个知识

21:26.570 --> 21:28.570
因为这两个知识之后

21:28.570 --> 21:31.570
前装才真正的开始进入了工程化

21:32.570 --> 21:33.570
说回来

21:33.570 --> 21:34.570
安装好漏的之后

21:34.570 --> 21:36.570
漏的环境里面就不一样了

21:36.570 --> 21:37.570
漏的环境里面

21:37.570 --> 21:39.570
要执行一个东西

21:39.570 --> 21:41.570
它不像浏览器那样子

21:41.570 --> 21:42.570
浏览器里面

21:42.570 --> 21:44.570
是不是有写很多的元素

21:44.570 --> 21:45.570
一个个去引用

21:45.570 --> 21:46.570
可以引用很多

21:46.570 --> 21:48.570
漏的不是这样子

21:48.570 --> 21:49.570
漏的里面要执行一个东西

21:49.570 --> 21:50.570
然后这个文件

21:50.570 --> 21:51.570
这个介石文件

21:51.570 --> 21:52.570
它直接执行介石文件

21:52.570 --> 21:53.570
它不能执行ATML

21:53.570 --> 21:54.570
它不能执行这个玩意

21:54.570 --> 21:56.570
这个玩意漏的是不认识的

21:56.570 --> 21:57.570
它只能认识介石

21:58.570 --> 21:59.570
那么在这个环境里面

21:59.570 --> 22:01.570
你要怎么去执行介石呢

22:01.570 --> 22:03.570
就跟那个Java

22:03.570 --> 22:04.570
跟那个CCR

22:04.570 --> 22:06.570
跟一些后端语言差不多

22:06.570 --> 22:08.570
它是有一个入口文件

22:08.570 --> 22:10.570
你直接把入口文件给它

22:10.570 --> 22:12.570
它就从那个入口文件开始执行

22:12.570 --> 22:13.570
那具体怎么执行呢

22:13.570 --> 22:14.570
比方说这里呢

22:14.570 --> 22:16.570
我们点击右键

22:16.570 --> 22:18.570
在中端中打开

22:18.570 --> 22:19.570
我们刚才不是看到一个中端吗

22:19.570 --> 22:20.570
对不对

22:20.570 --> 22:21.570
点击右键

22:21.570 --> 22:22.570
中端打开

22:22.570 --> 22:23.570
那么这个时候呢

22:23.570 --> 22:24.570
中端里面呢

22:24.570 --> 22:25.570
就会显示出这个

22:25.570 --> 22:26.570
你目前的目录

22:26.570 --> 22:28.570
就显示你目前的目录

22:28.570 --> 22:29.570
有的人说

22:29.570 --> 22:30.570
老师啊

22:30.570 --> 22:31.570
不对啊

22:31.570 --> 22:32.570
你这边点击右键

22:32.570 --> 22:33.570
打开中端

22:33.570 --> 22:34.570
为什么在这里打开

22:34.570 --> 22:35.570
全是细节问题啊

22:35.570 --> 22:36.570
这个问题我简单说一下

22:36.570 --> 22:38.570
我那边打开是这个样子的

22:38.570 --> 22:39.570
对

22:39.570 --> 22:40.570
里面那边打开

22:40.570 --> 22:41.570
应该是这个样子的

22:41.570 --> 22:42.570
当然这个样子

22:42.570 --> 22:43.570
也没什么问题

22:43.570 --> 22:44.570
也没有什么问题

22:44.570 --> 22:45.570
那么如果说

22:45.570 --> 22:46.570
你想像我这样子

22:46.570 --> 22:48.570
在一个新的中端窗口里面

22:48.570 --> 22:49.570
打开的话

22:49.570 --> 22:50.570
你需要去设置一下

22:50.570 --> 22:51.570
打开你的设置

22:51.570 --> 22:53.570
这里有一个

22:53.570 --> 22:54.570
手选项

22:54.570 --> 22:55.570
设置

22:55.570 --> 22:56.570
我有点忘了

22:56.570 --> 22:57.570
我看找一找

22:57.570 --> 22:58.570
还能不能找得到啊

22:58.570 --> 23:00.570
这些设置谁记得住啊

23:00.570 --> 23:01.570
呃

23:01.570 --> 23:02.570
臀

23:02.570 --> 23:03.570
鸣

23:03.570 --> 23:04.570
喽

23:04.570 --> 23:07.390
我看一下啊

23:10.020 --> 23:11.020
中端

23:11.020 --> 23:12.020
找这个中端啊

23:13.020 --> 23:14.020
收一收

23:14.020 --> 23:16.020
我记得是有一个配置

23:16.020 --> 23:17.020
它是可以控制

23:17.020 --> 23:19.020
你在哪个窗口内

23:19.020 --> 23:20.020
打开

23:21.020 --> 23:22.020
哦这啊

23:22.020 --> 23:23.020
叫做

23:23.020 --> 23:24.020
不对不对不对

23:24.020 --> 23:25.020
还不行

23:25.020 --> 23:27.020
哦这是啊

23:27.020 --> 23:28.020
启动中端的类型

23:28.020 --> 23:29.020
我这里选择的是

23:29.020 --> 23:30.020
外部

23:30.020 --> 23:31.020
外部的中端

23:31.020 --> 23:33.020
那么它默认的是什么

23:33.020 --> 23:34.020
集成的集成的就是

23:34.020 --> 23:35.020
你们看到这个样子

23:35.020 --> 23:36.020
把调成外部的就行了

23:36.020 --> 23:38.020
这无所谓的啊都一样

23:38.020 --> 23:39.020
那找到这个目的过后呢

23:39.020 --> 23:40.020
你看我们目前这个

23:40.020 --> 23:41.020
中端的目的

23:41.020 --> 23:43.020
就是我们这个文件夹

23:43.020 --> 23:44.020
我们现在运行什么呢

23:44.020 --> 23:46.020
运行漏的一个命令

23:46.020 --> 23:47.020
后面跟上

23:47.020 --> 23:48.020
你要运行的模块

23:48.020 --> 23:49.020
运行的文件

23:49.020 --> 23:51.020
一点解释

23:51.020 --> 23:52.020
就可以了

23:52.020 --> 23:53.020
这里给相对路径

23:53.020 --> 23:54.020
回车

23:54.020 --> 23:56.020
你看这个解释在运行

23:56.020 --> 23:57.020
对不对

23:57.020 --> 23:59.020
完全不需要浏览器啊

23:59.020 --> 24:00.020
直接执行解释

24:00.020 --> 24:01.020
这就是漏的环境

24:01.020 --> 24:03.020
漏的环境里面有很多知识啊

24:03.020 --> 24:05.020
我们这里主要是要说它的模块话

24:05.020 --> 24:06.020
按一下

24:06.020 --> 24:07.020
如果它一直不停的执行的话

24:07.020 --> 24:08.020
如果说你希望停止

24:08.020 --> 24:10.020
按一下康硕加C

24:10.020 --> 24:11.020
就停止了

24:11.020 --> 24:12.020
就这么简单

24:12.020 --> 24:14.020
这就是漏的环境

24:14.020 --> 24:16.020
好那么这就是漏的环境

24:16.020 --> 24:17.020
如何安装说完了

24:17.020 --> 24:18.020
对吧

24:18.020 --> 24:20.020
那么漏的运行文件的时候

24:20.020 --> 24:21.020
是给它一个解释

24:21.020 --> 24:22.020
你不能给几个

24:22.020 --> 24:23.020
它只能运行一个

24:23.020 --> 24:24.020
给它一个解释

24:24.020 --> 24:25.020
这个解释文件

24:25.020 --> 24:27.020
就称为入口文件

24:27.020 --> 24:28.020
就是以这个解释

24:28.020 --> 24:29.020
开始来进行运行

24:29.020 --> 24:31.020
从上到下进行运行

24:31.020 --> 24:33.020
就这么一回事

24:33.020 --> 24:34.020
漏的环境里面

24:34.020 --> 24:35.020
我要简单说一下

24:35.020 --> 24:37.020
它里边也是遵循

24:37.020 --> 24:38.020
eS标准的

24:38.020 --> 24:39.020
什么叫遵循eS标准呢

24:39.020 --> 24:41.020
就是eS标准里面

24:41.020 --> 24:42.020
规定的东西

24:42.020 --> 24:44.020
它都能遵循

24:44.020 --> 24:46.020
我顺便问一下

24:46.020 --> 24:47.020
这些基础

24:47.020 --> 24:49.020
长过得脑不脑的好

24:49.020 --> 24:52.020
console有log

24:52.020 --> 24:54.020
是不是eS标准

24:54.020 --> 25:00.280
这个玩意是不是eS标准

25:00.280 --> 25:04.450
我测试一下

25:04.450 --> 25:09.360
知道吧

25:09.360 --> 25:10.360
是吧

25:13.360 --> 25:15.360
这个玩意不是

25:15.360 --> 25:16.360
这个玩意不是

25:16.360 --> 25:20.440
set come out

25:20.440 --> 25:22.440
是不是eS标准

25:22.440 --> 25:28.760
这个玩意

25:28.760 --> 25:29.760
不知道是吧

25:29.760 --> 25:31.760
这些都不是

25:31.760 --> 25:33.760
eS标准里面有什么东西

25:33.760 --> 25:35.760
就是eS标准里面

25:35.760 --> 25:36.760
它并没有说

25:36.760 --> 25:37.760
我这个语言

25:37.760 --> 25:39.760
它只能在浏览器里面运行

25:39.760 --> 25:41.760
它完全没有说的

25:41.760 --> 25:43.760
当然大家可能没有去看过

25:43.760 --> 25:45.760
eS官方的文档

25:45.760 --> 25:46.760
它是完全没有说的

25:46.760 --> 25:47.760
它就说我这个语言

25:47.760 --> 25:48.760
长什么样子

25:48.760 --> 25:49.760
应该是什么样子

25:49.760 --> 25:50.760
应该怎么去说话

25:50.760 --> 25:51.760
判断应该怎么说

25:51.760 --> 25:52.760
询判应该怎么说

25:52.760 --> 25:54.760
出主应该怎么表达

25:54.760 --> 25:57.760
出主里面有哪些常用方法

25:57.760 --> 25:59.760
它就是规定这些事的

25:59.760 --> 26:00.760
远行远行链

26:00.760 --> 26:02.760
eS标准里面的

26:02.760 --> 26:03.760
什么执行上下文

26:03.760 --> 26:05.760
eS标准里面的

26:05.760 --> 26:07.760
这些东西才是eS标准的

26:07.760 --> 26:08.760
其他的东西呢

26:08.760 --> 26:09.760
像浏览器

26:09.760 --> 26:10.760
这些东西全是输出

26:10.760 --> 26:12.760
环境提供的

26:12.760 --> 26:13.760
concept look是什么意思

26:13.760 --> 26:15.760
在浏览器的控制台中

26:15.760 --> 26:16.760
输出一个

26:17.760 --> 26:18.760
谁贪猫是什么意思

26:18.760 --> 26:20.760
让浏览器的计时

26:20.760 --> 26:21.760
现成开始计时

26:21.760 --> 26:22.760
计时完了过后

26:22.760 --> 26:24.760
运行一个毁掉函数

26:24.760 --> 26:25.760
对不对

26:25.760 --> 26:26.760
像里面以后学的

26:27.760 --> 26:29.760
不拉不拉不拉不拉

26:29.760 --> 26:30.760
什么意思

26:30.760 --> 26:32.760
高速浏览器的网络现成

26:32.760 --> 26:34.760
让它去发生一个网络琴球

26:34.760 --> 26:37.760
这些全是数组环境给你提供的

26:37.760 --> 26:39.760
你可能说不对啊

26:39.760 --> 26:40.760
那你到loader环境里面

26:40.760 --> 26:42.760
凭什么还能用呢

26:42.760 --> 26:43.760
为什么还能用呢

26:43.760 --> 26:44.760
因为loader环境里面

26:44.760 --> 26:46.760
给你提供了一个一模一样的

26:46.760 --> 26:49.760
它给你提供了一个一模一样的

26:49.760 --> 26:50.760
其实这个东西还跟浏览器

26:50.760 --> 26:51.760
有点点区别的

26:51.760 --> 26:53.760
返回类型不一样

26:53.760 --> 26:54.760
它功能是一样的

26:54.760 --> 26:55.760
对吧

26:55.760 --> 26:57.760
loader里面还可以输出

26:57.760 --> 26:59.760
为什么可以用concelogue

26:59.760 --> 27:01.760
因为它给你做了一个一模一样的

27:01.760 --> 27:03.760
是这么回事

27:03.760 --> 27:05.760
loader既然是里面

27:05.760 --> 27:06.760
首先你能够使用的是

27:06.760 --> 27:09.760
一定是所有的ES标准都可以支持

27:09.760 --> 27:11.760
像什么循环、输足、判断

27:11.760 --> 27:12.760
对象这些东西都可以支持

27:12.760 --> 27:13.760
协法完全一样

27:13.760 --> 27:14.760
定义辩量啊

27:14.760 --> 27:16.760
这都是一样的

27:16.760 --> 27:18.760
但是你不能使用浏览器

27:18.760 --> 27:19.760
特有的API

27:19.760 --> 27:21.760
像有一些常用的API

27:21.760 --> 27:23.760
它就做了一个一模一样的出来

27:23.760 --> 27:25.760
像concelogue一样

27:25.760 --> 27:26.760
做了一个一模一样的

27:26.760 --> 27:28.760
但是有些API你是没法用的

27:28.760 --> 27:29.760
像这里面你去给我用什么

27:29.760 --> 27:31.760
用这个document

27:31.760 --> 27:32.760
你看呀

27:32.760 --> 27:34.760
我在loader环境里面去用document

27:34.760 --> 27:35.760
loader

27:35.760 --> 27:36.760
一点点解释

27:36.760 --> 27:38.760
告诉你一个document是啥玩意

27:38.760 --> 27:39.760
it's not defined

27:39.760 --> 27:40.760
它不存在

27:40.760 --> 27:41.760
对吧

27:41.760 --> 27:45.650
你去在里面去用什么window

27:45.650 --> 27:46.650
window在哪儿

27:46.650 --> 27:47.650
窗口

27:47.650 --> 27:48.650
窗口啥

27:48.650 --> 27:49.650
窗口能吃吗

27:49.650 --> 27:50.650
没有

27:50.650 --> 27:52.650
loader环境里面没有这些东西

27:52.650 --> 27:53.650
没了意思吧

27:53.650 --> 27:54.650
就loader环境

27:54.650 --> 27:55.650
中点来了

27:55.650 --> 27:57.650
中点不是loader环境

27:57.650 --> 27:59.650
我们今天说的中点是模块化

27:59.650 --> 28:01.650
loader里面以后慢慢去学东西

28:01.650 --> 28:02.650
loader不得了

28:02.650 --> 28:04.650
模块化

28:04.650 --> 28:06.650
loader里面

28:06.650 --> 28:08.650
你不用做任何事情

28:08.650 --> 28:09.650
模块化

28:09.650 --> 28:10.650
自动开启

28:10.650 --> 28:11.650
标准

28:11.650 --> 28:12.650
自动式

28:12.650 --> 28:13.650
common.es

28:13.650 --> 28:15.650
虽然说目前loader

28:15.650 --> 28:17.650
在它的就是先行版本里面

28:17.650 --> 28:19.650
已经支持了es模块化

28:19.650 --> 28:20.650
只不过了

28:20.650 --> 28:22.650
现在还在试验过程当中

28:22.650 --> 28:23.650
出了好多年了

28:24.650 --> 28:26.650
这个东西你可以不用管

28:26.650 --> 28:27.650
现在都可以不用管

28:27.650 --> 28:29.650
因为那个东西没有得用

28:29.650 --> 28:31.650
目前绝大部分第三方库

28:31.650 --> 28:32.650
还有我们自己写的码

28:32.650 --> 28:33.650
在loader环境里面

28:33.650 --> 28:35.650
都是使用的是common.es

28:35.650 --> 28:37.650
这是一个什么样的回忆犯

28:37.650 --> 28:39.650
还用了很多年了

28:39.650 --> 28:42.650
它说一个GS文件

28:42.650 --> 28:43.650
一个GS文件

28:43.650 --> 28:44.650
它就是一个模块

28:45.650 --> 28:46.650
这个是个GS

28:46.650 --> 28:47.650
它就是个模块

28:47.650 --> 28:49.650
这个模块里面的

28:49.650 --> 28:50.650
一个模块就相对于是什么呢

28:50.650 --> 28:51.650
就是一个独立的功能

28:51.650 --> 28:53.650
它跟其他东西是相对隔离的

28:53.650 --> 28:55.650
比方说你要做一个网页

28:55.650 --> 28:57.650
这个网页很大

28:57.650 --> 28:58.650
对不对

28:58.650 --> 28:59.650
那么这个网页里面

28:59.650 --> 29:00.650
有各种各样的功能

29:00.650 --> 29:01.650
像轮波图

29:01.650 --> 29:03.650
分页一个功能

29:03.650 --> 29:05.650
显示一个列表

29:05.650 --> 29:06.650
一个功能

29:06.650 --> 29:07.650
另外的意思吧

29:07.650 --> 29:09.650
就是一个相对独立的功能模块

29:09.650 --> 29:11.650
那么这个功能里面

29:11.650 --> 29:13.650
所有全局代码

29:13.650 --> 29:14.650
产生了什么边量

29:14.650 --> 29:15.650
函数

29:15.650 --> 29:17.650
不会造成任何污染

29:17.650 --> 29:19.650
只在模块内部使用

29:20.650 --> 29:21.650
你看啊

29:21.650 --> 29:22.650
就这个东西

29:22.650 --> 29:23.650
我就随便瞎写一个

29:23.650 --> 29:25.650
在这里

29:25.650 --> 29:26.650
进行我误录吧

29:26.650 --> 29:27.650
commonGS

29:27.650 --> 29:31.110
这里

29:33.110 --> 29:34.110
随便来一个

29:34.110 --> 29:35.110
atorGS

29:35.110 --> 29:36.110
比方说

29:36.110 --> 29:38.110
这里边我订一个边量A等于E

29:38.110 --> 29:39.110
这个网页

29:39.110 --> 29:41.110
会不会对全局边量产生污染呢

29:41.110 --> 29:43.110
我们来看一下吧

29:43.110 --> 29:44.110
loader环境

29:44.110 --> 29:45.110
loader环境里边

29:45.110 --> 29:47.110
它的全局边量叫做Globo

29:47.110 --> 29:49.110
它叫做Globo

29:49.110 --> 29:51.110
在ES2020

29:51.110 --> 29:52.110
就今年出来过后来

29:52.110 --> 29:54.110
有多了一个关键字叫Globo RACE

29:54.110 --> 29:56.110
这个东西里边没有学习不用管

29:56.110 --> 29:57.110
它的全局边量叫做Globo

29:57.110 --> 29:59.110
我们按照以前的做法

29:59.110 --> 30:00.110
在浏览器里边

30:00.110 --> 30:01.110
它一定是跑到Windows上面去了

30:01.110 --> 30:02.110
那么我们来看一下

30:02.110 --> 30:04.110
它会不会跑到Globo上面去

30:05.110 --> 30:06.110
Globo

30:09.110 --> 30:10.110
看一下吧

30:10.110 --> 30:11.110
我推荐大家

30:11.110 --> 30:12.110
安装好了loader之后

30:12.110 --> 30:13.110
安装一个插件

30:13.110 --> 30:15.110
叫做CodeRonger

30:15.110 --> 30:17.110
这样子运行代码方便一点

30:17.110 --> 30:18.110
CodeRonger

30:18.110 --> 30:19.110
就这个玩意

30:19.110 --> 30:21.110
安装完就完事了

30:21.110 --> 30:22.110
它有什么好处呢

30:22.110 --> 30:24.110
它就是你可以点击右键直接运行

30:24.110 --> 30:25.110
拿来去输的命令

30:25.110 --> 30:27.110
我们点击右键直接运行

30:27.110 --> 30:28.110
绑敌犯的

30:28.110 --> 30:29.110
看到没

30:29.110 --> 30:30.110
就是它输出了结果

30:30.110 --> 30:32.110
相当于是绑敌运行的一个loader

30:32.110 --> 30:34.620
明白吧

30:34.620 --> 30:36.620
那么这里它输出了一个什么

30:36.620 --> 30:37.620
绑敌犯的

30:37.620 --> 30:39.620
说明它并没有污染全局边量

30:39.620 --> 30:40.620
当然同样的道理

30:40.620 --> 30:42.620
什么任何的全局函数

30:42.620 --> 30:44.620
都不会对全局边量

30:44.620 --> 30:49.400
造成任何的污染

30:49.400 --> 30:50.400
你看看

30:50.400 --> 30:52.400
它不会污染全局

30:52.400 --> 30:53.400
那么除非你

30:53.400 --> 30:54.400
伤心病狂的

30:54.400 --> 30:55.400
一定要污染全局

30:55.400 --> 30:56.400
有些不污染全局

30:56.400 --> 30:57.400
我就不说

30:57.400 --> 30:59.400
那它没办法了

30:59.400 --> 31:00.400
那它没办法了

31:00.400 --> 31:01.400
你这样子

31:01.400 --> 31:02.400
它有什么办法呢

31:02.400 --> 31:03.400
一定要污染全局

31:03.400 --> 31:04.400
但是不要这样做

31:04.400 --> 31:05.400
永远不要去这样做

31:05.400 --> 31:06.400
这是第一个规范

31:06.400 --> 31:07.400
是吧

31:07.400 --> 31:08.400
自动遵守的

31:08.400 --> 31:10.400
弄到里边已经开启了

31:10.400 --> 31:11.400
第二个

31:11.400 --> 31:13.400
一个届也是一个模块

31:13.400 --> 31:14.400
那么我们的程序里边

31:14.400 --> 31:16.400
应该是有很多的模块

31:16.400 --> 31:17.400
那么我这个模块

31:17.400 --> 31:18.400
写了很多东西

31:18.400 --> 31:19.400
比方说我写的

31:19.400 --> 31:21.400
一大群有30多个变量

31:21.400 --> 31:22.400
有50多个函数

31:22.400 --> 31:23.400
假设

31:23.400 --> 31:24.400
当然没有那么大群的模块

31:24.400 --> 31:26.400
有这么多东西

31:26.400 --> 31:27.400
我希望把这些函数啊

31:27.400 --> 31:28.400
变量啊

31:28.400 --> 31:30.400
一部分我不是全部

31:30.400 --> 31:31.400
我包露一部分

31:31.400 --> 31:32.400
给别的模块使用

31:32.400 --> 31:33.400
你要用我就包露给你

31:33.400 --> 31:35.400
你不用举办法

31:35.400 --> 31:36.400
那么这个该怎么做呢

31:36.400 --> 31:37.400
那么这个过程啊

31:37.400 --> 31:40.400
叫做模块导出

31:40.400 --> 31:41.400
就是把

31:41.400 --> 31:42.400
我这个模块里边的东西

31:42.400 --> 31:43.400
包露给别人使用

31:43.400 --> 31:44.400
叫做模块导出

31:44.400 --> 31:45.400
比方说我这里写个

31:45.400 --> 31:46.400
写个介绍

31:46.400 --> 31:47.400
叫做YouTube

31:47.400 --> 31:49.400
或者叫做Random

31:49.400 --> 31:50.400
专门来处理随机数的

31:50.400 --> 31:51.400
对不对

31:51.400 --> 31:53.400
在处理随机数的时候呢

31:53.400 --> 31:55.900
我就导

31:55.900 --> 31:56.900
我导出

31:56.900 --> 31:57.900
怎么导出呢

31:57.900 --> 31:58.900
导出的方式在

31:58.900 --> 31:59.900
common.js里边非常简单

31:59.900 --> 32:00.900
就是module

32:00.900 --> 32:02.900
your export

32:02.900 --> 32:03.900
有一个对象

32:03.900 --> 32:04.900
一个对象名字叫做module

32:04.900 --> 32:05.900
它有个属性

32:05.900 --> 32:07.900
属性叫做export

32:07.900 --> 32:08.900
你只要给这个属性复制

32:08.900 --> 32:09.900
你复什么制

32:09.900 --> 32:10.900
它就导出什么

32:10.900 --> 32:11.900
你复什么制

32:11.900 --> 32:12.900
那随便你复什么制

32:12.900 --> 32:13.900
复出一个

32:13.900 --> 32:14.900
复制为一个1

32:14.900 --> 32:15.900
它就导出一个1

32:15.900 --> 32:16.900
复制为一个

32:16.900 --> 32:17.900
字母串

32:17.900 --> 32:18.900
还有导出一个字母串

32:18.900 --> 32:19.900
复制为一个函数

32:19.900 --> 32:20.900
它就导出一个函数

32:20.900 --> 32:22.900
复制为一个对象

32:22.900 --> 32:24.900
它就导出一个对象

32:24.900 --> 32:25.900
明白了意思吧

32:25.900 --> 32:26.900
就这么简单

32:26.900 --> 32:27.900
比方说我这里要复制

32:27.900 --> 32:28.900
要复制一个什么

32:28.900 --> 32:29.900
复制一个函数

32:29.900 --> 32:30.900
这个函数呢

32:30.900 --> 32:32.900
产生一个水移数

32:32.900 --> 32:34.900
就是给我个最小只

32:34.900 --> 32:35.900
给我一个最大只

32:35.900 --> 32:36.900
产生一个水移数

32:36.900 --> 32:37.900
return mass

32:37.900 --> 32:38.900
floor

32:38.900 --> 32:39.900
函数

32:39.900 --> 32:40.900
这个函数我估计

32:40.900 --> 32:41.900
有些同学不知道

32:41.900 --> 32:42.900
因为我每次

32:42.900 --> 32:43.900
公开直播课的时候

32:43.900 --> 32:44.900
都讲了无数实词的

32:44.900 --> 32:45.900
没关系

32:45.900 --> 32:46.900
如果说你没有

32:46.900 --> 32:47.900
见过这种函数

32:47.900 --> 32:48.900
不是重点

32:48.900 --> 32:49.900
你听课一定要听重点

32:49.900 --> 32:50.900
无限在哪里

32:50.900 --> 32:51.900
不要被这些细致默契干扰了

32:51.900 --> 32:52.900
它就是

32:52.900 --> 32:53.900
给我一个最小只

32:53.900 --> 32:54.900
给我一个最大只

32:54.900 --> 32:55.900
我给你返回一个水移整数

32:55.900 --> 32:56.900
在这个範围内的

32:56.900 --> 32:57.900
也不用去管它怎么写的

32:57.900 --> 32:59.900
一定要听重点

32:59.900 --> 33:01.900
那么现在呢

33:01.900 --> 33:02.900
这个模块

33:02.900 --> 33:03.900
我导出一个函数

33:03.900 --> 33:04.900
那么这个模块里边

33:04.900 --> 33:05.900
我还要定义了很多边量

33:05.900 --> 33:06.900
A等于1

33:06.900 --> 33:07.900
为了辅助

33:07.900 --> 33:08.900
当然这个边量

33:08.900 --> 33:09.900
没有任何意义

33:09.900 --> 33:10.900
我只说明这个问题

33:10.900 --> 33:11.900
它不会污染

33:11.900 --> 33:12.900
定义了三个边量

33:12.900 --> 33:13.900
然后我还定义了

33:13.900 --> 33:14.900
一些别的函数

33:14.900 --> 33:15.900
无所谓

33:15.900 --> 33:16.900
这些东西

33:16.900 --> 33:17.900
只是这个模块

33:17.900 --> 33:18.900
内部的东西

33:18.900 --> 33:19.900
不会暴露出去的

33:19.900 --> 33:20.900
只有这个

33:20.900 --> 33:21.900
那么这个玩意

33:21.900 --> 33:22.900
会不会污染全军了

33:22.900 --> 33:23.900
也不会

33:23.900 --> 33:24.900
你看它怎么玩的

33:24.900 --> 33:26.900
我这个模块就写完了

33:26.900 --> 33:27.900
写完了

33:27.900 --> 33:28.900
好 写完之后呢

33:28.900 --> 33:29.900
我在另一个模块里边

33:29.900 --> 33:30.900
要用

33:30.900 --> 33:31.900
比方说我这个

33:31.900 --> 33:32.900
一个Index的介石

33:32.900 --> 33:33.900
它又是个模块

33:33.900 --> 33:34.900
在Note环境里边

33:34.900 --> 33:35.900
所有的介石

33:35.900 --> 33:36.900
全部是模块

33:36.900 --> 33:37.900
那么在这个介石里边

33:37.900 --> 33:38.900
我要用它

33:38.900 --> 33:39.900
对吧

33:39.900 --> 33:40.900
它不是写了一些东西吗

33:40.900 --> 33:41.900
我不想

33:41.900 --> 33:42.900
我要用随机的

33:42.900 --> 33:43.900
那我要用你的

33:43.900 --> 33:44.900
用你的东西

33:44.900 --> 33:45.900
这个过程叫什么

33:45.900 --> 33:46.900
叫导入

33:46.900 --> 33:47.900
叫做导入

33:48.900 --> 33:49.900
导入怎么导入呢

33:50.900 --> 33:51.900
在common介石里边

33:51.900 --> 33:52.900
非常简单

33:52.900 --> 33:54.900
使用一个函数require

33:54.900 --> 33:55.900
里边写上模块的入境

33:55.900 --> 33:56.900
就可以了

33:57.900 --> 33:58.900
比方说我这里要用的是什么

33:58.900 --> 33:59.900
用这里边导出的东西

33:59.900 --> 34:00.900
对不对

34:00.900 --> 34:01.900
好 我们这里用

34:04.600 --> 34:06.600
好 这里边写的是一个制服串

34:06.600 --> 34:08.600
一个制服串写的是啥呢

34:08.600 --> 34:09.600
就是

34:09.600 --> 34:10.600
你要用哪一个模块

34:10.600 --> 34:11.600
用哪个呢

34:11.600 --> 34:12.600
用软A的介石的

34:12.600 --> 34:14.600
你写上它们的路径

34:14.600 --> 34:15.600
注意

34:15.600 --> 34:17.600
特别特别重要的一个点

34:17.600 --> 34:20.600
这个路径必须要以底尔斜杠

34:20.600 --> 34:22.600
或者是底尔的斜杠开头

34:23.600 --> 34:24.600
或者是一个绝对路径

34:24.600 --> 34:26.600
就C排案到了哪个文件夹

34:26.600 --> 34:28.600
绝对路径很少写

34:28.600 --> 34:29.600
相对路径的话

34:29.600 --> 34:30.600
一定要以底尔斜杠

34:30.600 --> 34:31.600
和底尔斜杠开头

34:31.600 --> 34:32.600
这跟我们以前的柳烂期

34:32.600 --> 34:33.600
不一样

34:33.600 --> 34:34.600
柳烂期里边说是

34:34.600 --> 34:36.600
底尔斜杠可以省略

34:36.600 --> 34:37.600
这里一定不能省略

34:37.600 --> 34:38.600
省略过后

34:38.600 --> 34:39.600
就变成别的意思了

34:39.600 --> 34:40.600
那个意思

34:40.600 --> 34:41.600
你要写保管一期之后

34:41.600 --> 34:42.600
就知道了

34:42.600 --> 34:43.600
那么

34:43.600 --> 34:44.600
这里

34:44.600 --> 34:45.600
我们比方说

34:45.600 --> 34:46.600
我们当前的目录

34:46.600 --> 34:48.600
使用哪个模块呢

34:49.600 --> 34:50.600
后面的底尔斜杠

34:50.600 --> 34:51.600
你可以写

34:51.600 --> 34:52.600
也可以不写

34:52.600 --> 34:53.600
不写的话

34:53.600 --> 34:54.600
它自动给你加上

34:54.600 --> 34:55.600
于是它还是找到哪个模块

34:55.600 --> 34:56.600
找到这个模块

34:56.600 --> 34:57.600
就导致了

34:58.600 --> 35:00.600
所以这是一个函数

35:00.600 --> 35:01.600
这是数主环境

35:01.600 --> 35:02.600
这个环境里面

35:02.600 --> 35:03.600
给我们提供的函数

35:03.600 --> 35:04.600
柳烂期里边

35:04.600 --> 35:05.600
这些东西都没有

35:06.600 --> 35:07.600
这个函数

35:07.600 --> 35:08.600
它会有一个返回值

35:08.600 --> 35:09.600
返回什么呢

35:10.600 --> 35:11.600
注意听

35:11.600 --> 35:12.600
它返回的结果

35:12.600 --> 35:13.600
就是这边

35:14.600 --> 35:15.600
你给这个玩意儿付的值

35:15.600 --> 35:16.600
一个付值啥

35:16.600 --> 35:17.600
它就返回啥

35:17.600 --> 35:22.900
那么你把它保存到边量里边

35:22.900 --> 35:23.900
不要意思吧

35:23.900 --> 35:24.900
除了这个模块呢

35:24.900 --> 35:26.900
它不会污染其他任何东西

35:26.900 --> 35:27.900
谁要用它

35:28.900 --> 35:29.900
它就把这个玩意儿

35:29.900 --> 35:30.900
导致给谁

35:30.900 --> 35:31.900
那么

35:31.900 --> 35:32.900
我要用它

35:32.900 --> 35:33.900
我导致你来

35:33.900 --> 35:34.900
导致现在过后呢

35:35.900 --> 35:36.900
保存了哪个边量

35:36.900 --> 35:38.900
边量名义自己随便取

35:38.900 --> 35:39.900
无非就是

35:39.900 --> 35:40.900
调一个函数

35:40.900 --> 35:41.900
保存了一个边量里边吧

35:41.900 --> 35:42.900
把函数的返回结果

35:42.900 --> 35:43.900
保存了边量里边

35:43.900 --> 35:44.900
边量在你这个模块里边

35:44.900 --> 35:45.900
随便取

35:45.900 --> 35:46.900
而另一个模块

35:46.900 --> 35:47.900
有可能是不同的边量

35:47.900 --> 35:48.900
无所谓

35:48.900 --> 35:49.900
这样子是不是不会产生

35:49.900 --> 35:50.900
任何的污染

35:50.900 --> 35:51.900
对不对

35:51.900 --> 35:52.900
我要用它的时候

35:52.900 --> 35:53.900
我给它定一个名字

35:53.900 --> 35:54.900
保存进来

35:54.900 --> 35:55.900
好那么这里

35:55.900 --> 35:56.900
我输出一下

35:57.900 --> 35:58.900
输出一下

35:59.900 --> 36:00.900
这个

36:00.900 --> 36:02.900
Type Results

36:02.900 --> 36:03.900
大家觉得我个Type

36:03.900 --> 36:08.100
这个输出什么结果

36:08.100 --> 36:09.100
这个玩意儿输出什么结果

36:09.100 --> 36:15.940
今天晚上一定要认真听

36:15.940 --> 36:16.940
今天晚上

36:16.940 --> 36:17.940
讲到后边有些东西

36:17.940 --> 36:18.940
有点难

36:18.940 --> 36:19.940
是不是方形啊

36:19.940 --> 36:20.940
非常好啊

36:20.940 --> 36:21.940
运行看一下

36:21.940 --> 36:22.940
是不是方形

36:22.940 --> 36:23.940
好

36:23.940 --> 36:24.940
那如果说我这边

36:24.940 --> 36:25.940
显得是1呢

36:26.940 --> 36:27.940
那就是number

36:27.940 --> 36:28.940
对吧

36:28.940 --> 36:29.940
你倒出啥

36:29.940 --> 36:31.940
我这边就返回啥

36:31.940 --> 36:32.940
没啥意思吧

36:32.940 --> 36:33.940
就这么简单

36:33.940 --> 36:34.940
然后呢

36:34.940 --> 36:35.940
我再问大家一个问题

36:35.940 --> 36:36.940
我这边不是定义了

36:36.940 --> 36:37.940
三个边量吗

36:37.940 --> 36:38.940
abc

36:38.940 --> 36:39.940
我这里输出

36:39.940 --> 36:41.940
abc

36:41.940 --> 36:45.820
输出啥

36:45.820 --> 36:46.820
我这三个输出啥呀

36:46.820 --> 36:51.480
说unlit犯的

36:51.480 --> 36:52.480
能够理解unlit犯的

36:52.480 --> 36:53.480
就很不错了

36:53.480 --> 36:54.480
至少你知道

36:54.480 --> 36:55.480
它这个东西不存在

36:55.480 --> 36:56.480
对不对

36:56.480 --> 36:57.480
这三个东西不存在

36:57.480 --> 36:58.480
实际上它报错的

36:58.480 --> 36:59.480
实际上它报错的

36:59.480 --> 37:00.480
它告诉你

37:00.480 --> 37:01.480
is not defined

37:01.480 --> 37:02.480
没有这个变量

37:02.480 --> 37:03.480
b没有这个变量

37:03.480 --> 37:04.480
c没有这个变量

37:04.480 --> 37:05.480
根本就没有

37:05.480 --> 37:06.480
你在用啥呢

37:06.480 --> 37:07.480
实际上它报错

37:07.480 --> 37:08.480
所以说

37:08.480 --> 37:09.480
这个模块里边

37:09.480 --> 37:10.480
内部的东西

37:10.480 --> 37:11.480
没有暴露的东西

37:11.480 --> 37:13.480
是不是完全被隐藏了

37:13.480 --> 37:14.480
对不对

37:14.480 --> 37:15.480
就这一点

37:16.480 --> 37:17.480
这就是它

37:17.480 --> 37:18.480
整个的common

37:18.480 --> 37:19.480
介绍模块化

37:19.480 --> 37:20.480
大致的结构

37:20.480 --> 37:22.480
那么这样子一来的话

37:23.480 --> 37:24.480
有时候肯定要用

37:24.480 --> 37:25.480
应用

37:25.480 --> 37:26.480
这个应用在项目里边

37:26.480 --> 37:27.480
开发到项目

37:27.480 --> 37:28.480
或者是学到5.6的东西

37:28.480 --> 37:29.480
你自然而然就明白了

37:29.480 --> 37:31.480
这是个自然而然的过程

37:31.480 --> 37:32.480
或者说你之前开发

37:32.480 --> 37:33.480
写过很多单

37:33.480 --> 37:34.480
你看到这里

37:34.480 --> 37:35.480
应该就明白了

37:35.480 --> 37:36.480
这个模块

37:36.480 --> 37:37.480
发挥大家的一个

37:37.480 --> 37:38.480
什么样的影响

37:38.480 --> 37:39.480
所以我们可以把它

37:39.480 --> 37:40.480
分得很细很细了

37:40.480 --> 37:41.480
我们就可以写成

37:41.480 --> 37:42.480
类似有下面那种结构

37:42.480 --> 37:43.480
我给一个入口模块

37:43.480 --> 37:44.480
比方说一个index

37:44.480 --> 37:45.480
了解也是

37:45.480 --> 37:46.480
A

37:46.480 --> 37:47.480
它又去依赖

37:47.480 --> 37:48.480
模块A和模块B

37:48.480 --> 37:49.480
将终于是在

37:49.480 --> 37:50.480
入口模块里边

37:50.480 --> 37:51.480
导入了一个A

37:51.480 --> 37:52.480
require一个B

37:52.480 --> 37:53.480
require是可以

37:53.480 --> 37:54.480
到处写的

37:54.480 --> 37:55.480
我写到这

37:56.480 --> 37:57.480
比方说

37:57.480 --> 37:58.480
某一个判断

37:58.480 --> 37:59.480
判断什么的成功了

37:59.480 --> 38:00.480
我用去导入

38:00.480 --> 38:01.480
另外一个模块

38:01.480 --> 38:02.480
都可以

38:02.480 --> 38:03.480
去到任何为止都可以

38:03.480 --> 38:05.480
也导入A

38:05.480 --> 38:06.480
对不对

38:06.480 --> 38:07.480
都可以

38:07.480 --> 38:09.480
那么我可以去

38:09.480 --> 38:10.480
在入口模块里边

38:10.480 --> 38:11.480
去导入模块A

38:11.480 --> 38:12.480
而模块A里边

38:12.480 --> 38:13.480
就这个模块里边

38:13.480 --> 38:14.480
是不是有可能会导入

38:14.480 --> 38:15.480
其他模块

38:15.480 --> 38:16.480
对不对

38:16.480 --> 38:17.480
模块A导入模块B

38:17.480 --> 38:18.480
导入模块C

38:18.480 --> 38:19.480
导入模块D

38:19.480 --> 38:20.480
然后模块B

38:20.480 --> 38:21.480
又导入模块D

38:21.480 --> 38:22.480
E

38:22.480 --> 38:23.480
对不对

38:23.480 --> 38:24.480
会形成一个

38:24.480 --> 38:25.480
非常非常庞大的

38:25.480 --> 38:26.480
形

38:26.480 --> 38:27.480
对不对

38:27.480 --> 38:28.480
会形成这么一种结构

38:28.480 --> 38:29.480
我这里能给大家看

38:29.480 --> 38:34.300
一个真实的工程

38:34.300 --> 38:36.300
真实的工程

38:36.300 --> 38:38.300
有些同学并不莫生

38:38.300 --> 38:41.300
就是刚刚出来的

38:41.300 --> 38:43.300
五幼X

38:43.300 --> 38:44.300
五幼3

38:44.300 --> 38:46.300
刚刚出来的五幼3

38:46.300 --> 38:48.300
这是五幼3的原码

38:48.300 --> 38:49.300
当然我不知道

38:49.300 --> 38:50.300
里面去看原码

38:50.300 --> 38:51.300
我们来看一下

38:51.300 --> 38:52.300
五幼3里边

38:52.300 --> 38:55.300
它有多少个薄块

38:55.300 --> 38:56.300
看着

38:56.300 --> 38:58.300
这是它的原代码

38:58.300 --> 39:00.300
这是它的文件夹

39:00.300 --> 39:01.300
这里面每一个文件

39:01.300 --> 39:02.300
都是个模块

39:02.300 --> 39:03.300
你看一下

39:03.300 --> 39:04.300
有多少一代关系

39:04.300 --> 39:05.300
你看

39:05.300 --> 39:06.300
没有模块的话

39:06.300 --> 39:08.300
它能赶完这种事情

39:08.300 --> 39:09.300
它怎么玩

39:09.300 --> 39:11.300
我都不知道它怎么去玩

39:11.300 --> 39:13.300
当然这个是TypeScript的代码

39:13.300 --> 39:15.300
你可以把它相互介绍

39:15.300 --> 39:17.300
这是它的不同的模块

39:17.300 --> 39:18.300
这是它的响应式模块

39:18.300 --> 39:19.300
就是这个模块

39:19.300 --> 39:20.300
我们在

39:20.300 --> 39:23.300
最后一天会给大家讲

39:23.300 --> 39:25.300
你看它的代码

39:25.300 --> 39:26.300
它还是

39:26.300 --> 39:28.300
这还是五幼3自己写的代码

39:28.300 --> 39:29.300
它在写代码的过程中

39:29.300 --> 39:31.300
它不是完全自己写的

39:31.300 --> 39:33.300
它还要用到别人写好的

39:33.300 --> 39:35.300
它安装了别人

39:35.300 --> 39:36.300
就是它依赖了别人写好的

39:36.300 --> 39:38.300
也就是第三方库

39:38.300 --> 39:39.300
你看有多少

39:39.300 --> 39:42.620
你看这一边有多少

39:42.620 --> 39:44.620
这里边的一代关系极其复杂

39:44.620 --> 39:45.620
你说一下

39:45.620 --> 39:46.620
没有模块的话

39:46.620 --> 39:47.620
这个东西你敢玩吗

39:47.620 --> 39:48.620
怎么玩的事情

39:48.620 --> 39:49.620
没法玩的

39:49.620 --> 39:50.620
里面以后的工程

39:50.620 --> 39:51.620
也跟它差不多

39:51.620 --> 39:53.620
也跟它差不多

39:53.620 --> 39:54.620
是吧

39:54.620 --> 39:57.620
那么这是Common GS

39:57.620 --> 39:58.620
基本东西那就讲完了

39:58.620 --> 39:59.620
Common GS

39:59.620 --> 40:01.620
接下来是细节了

40:01.620 --> 40:02.620
练习题考的时候

40:02.620 --> 40:04.620
基本上就考虑细节

40:04.620 --> 40:06.620
这个细节

40:06.620 --> 40:08.620
需要让大家认真地理解一下

40:08.620 --> 40:09.620
可能这一部分

40:09.620 --> 40:11.620
对某些同学来说

40:11.620 --> 40:12.620
可能比较难

40:12.620 --> 40:13.620
因为我相信

40:13.620 --> 40:14.620
来听咱们科的同学

40:14.620 --> 40:17.620
有一部分同学

40:17.620 --> 40:19.620
可能目前的代码

40:19.620 --> 40:20.620
代码量

40:20.620 --> 40:22.620
开发了写的代码行数

40:22.620 --> 40:24.620
还没有2000行

40:24.620 --> 40:25.620
那看相距来

40:25.620 --> 40:26.620
可能就比较牢火了

40:26.620 --> 40:28.620
这里边是伟代

40:28.620 --> 40:29.620
高速理什么了

40:29.620 --> 40:30.620
高速理这个require

40:30.620 --> 40:31.620
到底在干吗

40:31.620 --> 40:32.620
我这里不是

40:32.620 --> 40:33.620
调了一个require吗

40:33.620 --> 40:34.620
它有没有什么移位

40:34.620 --> 40:36.620
这个require来的

40:36.620 --> 40:38.620
我们在浏览器里边知道

40:38.620 --> 40:39.620
我们这里边

40:39.620 --> 40:40.620
可以直接用的函数

40:40.620 --> 40:41.620
变量

40:41.620 --> 40:42.620
你看在浏览器里边

40:42.620 --> 40:43.620
我在浏览器里边

40:43.620 --> 40:44.620
可以直接用的函数

40:44.620 --> 40:45.620
变量

40:45.620 --> 40:47.620
是不是都是全具变量里边的

40:47.620 --> 40:49.620
我们为什么可以用console

40:49.620 --> 40:50.620
为什么

40:51.620 --> 40:52.620
对不对

40:52.620 --> 40:54.620
为什么可以用alert

40:54.620 --> 40:56.620
因为window里边有alert

40:56.620 --> 40:58.620
为什么可以用document

40:58.620 --> 41:00.620
因为window里边有document

41:00.620 --> 41:01.620
是不是

41:01.620 --> 41:02.620
全具对象里边

41:02.620 --> 41:03.620
所有的东西都是

41:03.620 --> 41:04.620
暴露在外的

41:04.620 --> 41:05.620
那么这里

41:05.620 --> 41:07.620
为什么可以直接用require

41:07.620 --> 41:09.620
给人的感觉好像是什么

41:09.620 --> 41:10.620
好像就是

41:10.620 --> 41:11.620
你这个require

41:11.620 --> 41:13.620
应该是全具里边

41:13.620 --> 41:14.620
因为什么global

41:14.620 --> 41:16.620
global里边console

41:16.620 --> 41:17.620
看一看

41:17.620 --> 41:19.620
global里边

41:19.620 --> 41:20.620
对不对

41:20.620 --> 41:21.620
是不是有函数

41:21.620 --> 41:22.620
是个对象

41:22.620 --> 41:24.620
对象里面有log

41:25.620 --> 41:26.620
那么这个

41:26.620 --> 41:27.620
既然require可以直接用

41:27.620 --> 41:28.620
那么这个require

41:28.620 --> 41:29.620
也应该是暴露在

41:29.620 --> 41:30.620
global里边的

41:35.620 --> 41:36.620
你看这边

41:36.620 --> 41:37.620
marge

41:37.620 --> 41:38.620
哪来的

41:38.620 --> 41:39.620
marge

41:39.620 --> 41:40.620
为什么可以用

41:40.620 --> 41:42.620
它一定是暴露在global里边的

41:42.620 --> 41:43.620
我们输出一下global marge

41:46.990 --> 41:47.990
就很奇怪了

41:47.990 --> 41:48.990
对不对

41:48.990 --> 41:49.990
那么随之而然

41:49.990 --> 41:50.990
那就是一大堆面试题了

41:50.990 --> 41:51.990
正在路上

41:52.990 --> 41:54.990
那么你要理解require

41:54.990 --> 41:55.990
marge

41:55.990 --> 41:56.990
为什么可以用

41:56.990 --> 41:58.990
你就必须要理解

41:58.990 --> 41:59.990
common.s

41:59.990 --> 42:01.990
它怎么实现魔法

42:02.990 --> 42:03.990
因为lode

42:03.990 --> 42:04.990
它不是官方

42:04.990 --> 42:05.990
官方只有es

42:05.990 --> 42:06.990
就是欧洲的基础

42:06.990 --> 42:07.990
基地制造商协会

42:08.990 --> 42:09.990
所以lode不是官方

42:09.990 --> 42:11.990
它不敢去给你改语法的

42:11.990 --> 42:13.990
它不敢去给你新增什么语法

42:13.990 --> 42:14.990
它只能动api

42:14.990 --> 42:15.990
什么叫api

42:15.990 --> 42:16.990
就是对象和函数

42:16.990 --> 42:17.990
魔力一个函数

42:17.990 --> 42:18.990
魔力一个对象之类的

42:18.990 --> 42:19.990
它只能去玩这些事情

42:20.990 --> 42:21.990
谁要它

42:21.990 --> 42:22.990
不是官方的

42:22.990 --> 42:23.990
那没办法

42:24.990 --> 42:26.990
因此require函数

42:26.990 --> 42:27.990
它是怎么来的呢

42:27.990 --> 42:28.990
它是这样子玩的

42:29.990 --> 42:30.990
注意听

42:32.990 --> 42:33.990
当你在

42:33.990 --> 42:35.990
雕用require的时候

42:35.990 --> 42:40.330
我跟你说它发生了什么事情

42:40.330 --> 42:42.330
当你在雕用require的时候

42:42.330 --> 42:44.330
实际上它内部有一个函数

42:44.330 --> 42:45.330
叫require

42:45.330 --> 42:46.330
有这么一个函数

42:46.330 --> 42:47.330
要require

42:47.330 --> 42:48.330
当然解释不了

42:48.330 --> 42:49.330
为什么可以用

42:49.330 --> 42:50.330
它为什么暴露出来的

42:50.330 --> 42:51.330
没关系

42:51.330 --> 42:52.330
你听着

42:52.330 --> 42:54.330
那么这个require函数是怎么写的呢

42:54.330 --> 42:56.330
我把个代码给它复制一下

42:56.330 --> 42:58.330
这些是伟代码

42:58.330 --> 43:01.330
除非你升入到lode阶势的圆码部分

43:01.330 --> 43:03.330
你去干预它的圆码运行

43:03.330 --> 43:04.330
你要去写C++

43:04.330 --> 43:05.330
插件

43:05.330 --> 43:06.330
否则的话你是无法干预

43:06.330 --> 43:07.330
lode的执行的

43:07.330 --> 43:08.330
因此呢

43:08.330 --> 43:09.330
这个代码是没法执行的

43:09.330 --> 43:10.330
只能说告诉你们

43:10.330 --> 43:11.330
原理是什么

43:11.330 --> 43:13.330
假设lode写了这么一个函数

43:13.330 --> 43:14.330
require

43:14.330 --> 43:16.330
那么这个函数是怎么工作的呢

43:16.330 --> 43:17.330
首先这个函数一定要有个参数

43:17.330 --> 43:18.330
对吧

43:18.330 --> 43:19.330
为什么有个参数

43:19.330 --> 43:20.330
你看

43:20.330 --> 43:21.330
这里我不是传了一个模块路径过来吗

43:21.330 --> 43:22.330
对不对

43:22.330 --> 43:23.330
有可能带后罪名

43:23.330 --> 43:24.330
有可能没有带

43:24.330 --> 43:25.330
带不带后罪名都一样

43:25.330 --> 43:27.330
传了一个模块路径过来

43:27.330 --> 43:28.330
那么它接下来

43:28.330 --> 43:29.330
做了一系列的事情

43:29.330 --> 43:31.330
一大堆事情

43:31.330 --> 43:32.330
一步一步给大家说

43:32.330 --> 43:33.330
它做了什么事情

43:33.330 --> 43:35.330
你把这个代码看懂了

43:35.330 --> 43:37.330
所有的common GS的面试体

43:37.330 --> 43:39.330
随便它怎么着

43:39.330 --> 43:42.330
一共就这么点代码

43:42.330 --> 43:43.330
对不对

43:43.330 --> 43:44.330
你今天看不懂

43:44.330 --> 43:46.330
以后回去多看几遍

43:46.330 --> 43:47.330
实在看不懂

43:47.330 --> 43:49.330
代码实在太少了

43:49.330 --> 43:51.330
回去多写点代码

43:51.330 --> 43:53.330
跟着咱们的公益开课神

43:53.330 --> 43:55.330
或者是最好能够成为咱们的后期

43:55.330 --> 43:57.330
学员能够系统地进行训练

43:57.330 --> 43:58.330
我给大家说一下

43:58.330 --> 44:00.330
它怎么过运行的

44:00.330 --> 44:01.330
首先它做的第一件事

44:01.330 --> 44:04.330
当然它不是最真实的情况

44:04.330 --> 44:05.330
最真实的情况还要复杂一点

44:05.330 --> 44:07.330
我给它讲一个关键步骤

44:07.330 --> 44:09.330
首先第一步

44:09.330 --> 44:11.330
你这里不是给它一个相对路径吗

44:11.330 --> 44:12.330
对吧

44:12.330 --> 44:15.330
首先得到绝对路径

44:15.330 --> 44:17.330
通过一个静态函数

44:17.330 --> 44:18.330
就是它的require里边

44:18.330 --> 44:19.330
require不是个函数吗

44:19.330 --> 44:21.330
函数里边是不是可以加属性

44:21.330 --> 44:23.330
它有个属性叫result

44:23.330 --> 44:24.330
得到一个属性

44:24.330 --> 44:27.330
这个函数是把一个相对路径

44:27.330 --> 44:29.330
转换成绝对路径

44:29.330 --> 44:32.830
其实你可以运行看一下

44:32.830 --> 44:34.830
输出

44:34.830 --> 44:36.830
require

44:36.830 --> 44:39.830
它里边有一个result

44:39.830 --> 44:41.830
我给它一个相对路径

44:41.830 --> 44:43.830
相对路径是retail

44:43.830 --> 44:47.040
不用写后绝了

44:47.040 --> 44:48.040
它给我返回一个绝对路径

44:48.040 --> 44:50.040
就这么简单

44:50.040 --> 44:51.040
你看一下

44:51.040 --> 44:53.040
点击有点运行

44:53.040 --> 44:55.040
看一下是不是个绝对路径

44:55.040 --> 44:56.040
在你们Windows里边

44:56.040 --> 44:58.040
它应该是某个盘幅

44:58.040 --> 44:59.040
C盘D盘

44:59.040 --> 45:00.040
某个文件夹

45:00.040 --> 45:01.040
没有文件夹

45:01.040 --> 45:02.040
我这里有的是

45:02.040 --> 45:03.040
运进Desktop

45:03.040 --> 45:04.040
魔幻化

45:04.040 --> 45:05.040
GMS

45:06.040 --> 45:07.040
得到一个绝对路径

45:07.040 --> 45:14.830
就这么简单

45:15.830 --> 45:17.830
好 继续

45:17.830 --> 45:18.830
第一步

45:18.830 --> 45:19.830
把相对路径

45:19.830 --> 45:20.830
转换成绝对路径

45:20.830 --> 45:21.830
它为什么要转换成绝对路径

45:21.830 --> 45:24.830
因为相对路径是有可能会重复的

45:24.830 --> 45:26.830
绝对路径是不是不可能重复

45:26.830 --> 45:27.830
对不对

45:27.830 --> 45:28.830
有没有可能说

45:28.830 --> 45:30.830
两个绝对路径不一样

45:30.830 --> 45:31.830
但是是同一个模块的

45:31.830 --> 45:32.830
不可能

45:32.830 --> 45:33.830
两个绝对路径不一样

45:33.830 --> 45:34.830
它就是不同的文件

45:34.830 --> 45:36.830
不同的文件就是不同的模块

45:36.830 --> 45:37.830
绝对路径跟模块

45:37.830 --> 45:38.830
是不是一对一关系

45:38.830 --> 45:40.830
它一定要得到绝对路径

45:40.830 --> 45:41.830
因为相对路径是有可能重复的

45:41.830 --> 45:42.830
你看这个文件讲下面

45:42.830 --> 45:43.830
有一个retail.js

45:43.830 --> 45:44.830
有没有可能

45:44.830 --> 45:45.830
一个字幕录下面

45:45.830 --> 45:47.830
它还有一个retail.js

45:47.830 --> 45:48.830
对不对

45:48.830 --> 45:50.830
相对路径是有可能会重复的

45:50.830 --> 45:51.830
但是绝对路径不会

45:51.830 --> 45:52.830
不用举例子

45:52.830 --> 45:54.830
大家都明白

45:54.830 --> 45:56.830
因此它要得到一个绝对路径

45:56.830 --> 45:59.830
由于绝对路径跟模块是一对一的关系

45:59.830 --> 46:00.830
它做了这么一件事

46:00.830 --> 46:01.830
它首先判断

46:01.830 --> 46:03.830
这个模块运行过枚

46:03.830 --> 46:04.830
它怎么判断的呢

46:04.830 --> 46:05.830
你又可以理解为

46:05.830 --> 46:06.830
有一个对象

46:06.830 --> 46:07.830
有一个权局对象

46:07.830 --> 46:09.830
这个权局对象是那一步的

46:09.830 --> 46:10.830
你看不到的

46:10.830 --> 46:11.830
比方说对象名字要个开启

46:11.830 --> 46:13.830
这个对象可能是这样子写的

46:13.830 --> 46:15.830
为了让大家好理解

46:15.830 --> 46:16.830
它就是个对象

46:16.830 --> 46:17.830
里面是空的

46:17.830 --> 46:19.830
一会儿执行一个模块

46:19.830 --> 46:21.830
它就把这个模块的绝对路径

46:21.830 --> 46:22.830
比如user

46:22.830 --> 46:23.830
什么的盘

46:23.830 --> 46:24.830
什么的盘

46:24.830 --> 46:25.830
哪个文件

46:25.830 --> 46:26.830
retail.js

46:26.830 --> 46:27.830
做它的属性名

46:27.830 --> 46:28.830
属性值呢

46:28.830 --> 46:30.830
就是它执行的结果

46:30.830 --> 46:31.830
就是这个模块执行完了

46:31.830 --> 46:32.830
执行完了过后

46:32.830 --> 46:33.830
这个module

46:33.830 --> 46:35.830
exporter返回了这种东西

46:35.830 --> 46:36.830
就是这个东西

46:36.830 --> 46:38.830
它为什么要把它记录下来

46:38.830 --> 46:41.830
避免模块重复执行

46:41.830 --> 46:42.830
不然下一次

46:42.830 --> 46:44.830
又要全部的重新再走一遍

46:44.830 --> 46:45.830
这就很麻烦

46:45.830 --> 46:46.830
所以它首先判断一下

46:46.830 --> 46:48.830
这个模块有没有缓存

46:48.830 --> 46:49.830
看对象里面有没有这个缓存

46:49.830 --> 46:51.830
有没有这个绝对路径存在

46:51.830 --> 46:52.830
如果有的话

46:52.830 --> 46:54.830
直接把缓存结果返回去完事

46:54.830 --> 46:55.830
直接结束

46:55.830 --> 46:57.830
说明一下

46:57.830 --> 46:58.830
光看到这

46:58.830 --> 47:00.830
你是不是至少说明到这个问题

47:00.830 --> 47:02.830
至少这段辩识体能做出来了

47:04.830 --> 47:05.830
单独开个问题

47:05.830 --> 47:06.830
这是原理

47:07.830 --> 47:09.830
把一个弹码放到这边

47:19.300 --> 47:20.300
也就是它这里边

47:20.300 --> 47:21.300
肯定是有缓存的

47:21.300 --> 47:22.300
将来会要缓存的

47:22.300 --> 47:23.300
那么通过这一点

47:23.300 --> 47:30.970
我们至少可以知道一件事

47:30.970 --> 47:32.970
我导入了这么多次模块

47:32.970 --> 47:33.970
没导入一次

47:33.970 --> 47:39.430
我这边输出一个

47:39.430 --> 47:40.430
等于0

47:40.430 --> 47:43.430
然后输出一个靠数加加

47:43.430 --> 47:45.430
或者是我们就

47:45.430 --> 47:47.430
我就输出一个1

47:47.430 --> 47:48.430
就输出一个1

47:48.430 --> 47:50.430
那么这个1输出几次

47:50.430 --> 47:52.430
想一想

47:52.430 --> 47:54.430
我这边导入了很多次

47:54.430 --> 47:55.430
回忆一下

47:55.430 --> 47:57.430
我们刚才的Require函输

47:57.430 --> 48:03.050
这个1输出几次

48:03.050 --> 48:04.050
能跟上吗

48:06.050 --> 48:08.050
我导入这个Ride模块

48:08.050 --> 48:10.050
是不是只输出一次

48:10.050 --> 48:11.050
对不对

48:11.050 --> 48:12.050
因为它有模块缓存

48:12.050 --> 48:13.050
所以它一直输出一次

48:13.050 --> 48:14.050
导入这些次

48:14.050 --> 48:16.050
是不是全用的时候缓存结果

48:16.050 --> 48:18.050
跟之前那是一样的

48:19.050 --> 48:21.050
那么比方说我这里

48:21.050 --> 48:22.050
有一个Result2

48:22.050 --> 48:24.050
有一个Result2

48:24.050 --> 48:25.050
那么我再问大家

48:25.050 --> 48:29.050
Result等不等于Result2

48:29.050 --> 48:31.050
我这些东西

48:32.050 --> 48:37.150
是不是相等的

48:37.150 --> 48:38.150
是不是相等的

48:38.150 --> 48:40.150
一定是相等的

48:40.150 --> 48:42.150
它用的就是之前缓存的结果

48:42.150 --> 48:44.150
那如果说每一次都是运行一次的话

48:44.150 --> 48:46.150
你看每一次都会创建一个新的函数

48:46.150 --> 48:47.150
遇到方便关键的时候

48:47.150 --> 48:49.150
是不是一个新的函数表达出来了

48:49.150 --> 48:50.150
那就肯定是不一样的

48:50.150 --> 48:51.150
它实际上是一样的

48:51.150 --> 48:52.150
这是它有缓存

48:52.150 --> 48:54.150
我们再一步一步看

48:54.150 --> 48:56.150
好 现在看到了缓存了

48:56.150 --> 48:57.150
好 接下来

48:57.150 --> 48:59.150
如果说没有缓存了

49:00.150 --> 49:02.150
一开始没东西

49:02.150 --> 49:03.150
没有缓存

49:03.150 --> 49:04.150
没有缓存怎么办呢

49:04.150 --> 49:06.150
它就开始真人八经执行一次的

49:06.150 --> 49:08.150
你看它怎么执行的

49:09.150 --> 49:12.150
它的内部生成了一个Require函数

49:12.150 --> 49:14.150
内部生成的

49:14.150 --> 49:17.150
这个函数有一大堆参数

49:17.150 --> 49:18.150
注意看

49:18.150 --> 49:20.150
这个函数你可能好多都看不懂

49:20.150 --> 49:22.150
这是什么啊 这个玩意

49:22.150 --> 49:23.150
你别管

49:23.150 --> 49:24.150
这个函数有一大堆参数

49:24.150 --> 49:26.150
我告诉大家

49:26.150 --> 49:28.150
你们现在比方说我们岛落是什么

49:28.150 --> 49:29.150
Require岛落是这个

49:29.150 --> 49:31.150
Redo

49:31.150 --> 49:32.150
那么这个时候

49:32.150 --> 49:35.150
它就会把那个Redo文件读出来

49:35.150 --> 49:37.150
它会把这个东西读出来

49:37.150 --> 49:39.150
把这个文件的所有内容

49:39.150 --> 49:41.150
看着啊 注意看

49:41.150 --> 49:44.150
把这个文件的所有内容放到这个函数内部

49:44.150 --> 49:45.150
这会放到这

49:45.150 --> 49:49.420
这个文件的所有内容放到这

49:49.420 --> 49:51.420
现在看懂了吗

49:51.420 --> 49:53.420
为什么它这里边不会污染全局

49:53.420 --> 49:55.420
为什么你的模块代码里边这些东西

49:55.420 --> 49:56.420
不会污染全局

49:56.420 --> 49:58.420
因为它这个东西就在函数里边运行的

49:58.420 --> 50:00.420
它是在函数里边运行的

50:00.420 --> 50:01.420
看到没有

50:01.420 --> 50:02.420
看到没

50:02.420 --> 50:05.420
为什么这里边可以用module

50:05.420 --> 50:08.420
因为它这里边有个函数叫module

50:08.420 --> 50:10.420
为什么这里边有一个export

50:10.420 --> 50:11.420
因为以后里面就知道了

50:11.420 --> 50:13.420
它这个module哪来的

50:13.420 --> 50:14.420
module就是给你勾到的一个对象

50:14.420 --> 50:16.420
对象里边一个属性叫export

50:16.420 --> 50:18.420
因为它所以说你这里可以用

50:18.420 --> 50:19.420
明白这个意思吗

50:19.420 --> 50:20.420
除了这个东西之外呢

50:20.420 --> 50:22.420
它可以传入什么file name

50:22.420 --> 50:23.420
file name表示当前

50:23.420 --> 50:25.420
当前模块的文件的决定路径

50:25.420 --> 50:28.420
DIR name表示当前模块的所在的目录

50:28.420 --> 50:29.420
你看说

50:29.420 --> 50:30.420
所以说我们这里边可以用什么

50:30.420 --> 50:33.420
所有的模块里边都可以用

50:33.420 --> 50:34.420
file name

50:34.420 --> 50:39.120
DIR name

50:39.120 --> 50:40.120
点右边运行

50:40.120 --> 50:41.120
你看

50:41.120 --> 50:42.120
是不是当前模块的

50:42.120 --> 50:43.120
应这个时候的这个文件

50:43.120 --> 50:44.120
模块的决定路径

50:44.120 --> 50:46.120
应这个时候的模块的所在的目录

50:46.120 --> 50:47.120
为什么可以用

50:47.120 --> 50:49.120
它可以传进来的

50:49.120 --> 50:50.120
看到没

50:50.120 --> 50:51.120
就说我们的模块

50:51.120 --> 50:53.120
实际上真实的执行环境

50:53.120 --> 50:55.120
是一个函数环境

50:55.120 --> 50:57.120
怎么可以证明呢

50:57.120 --> 50:59.120
给它看一个不得了的事情

50:59.120 --> 51:01.120
argument

51:01.120 --> 51:03.120
是不是函数内部才有argument

51:03.120 --> 51:04.120
gallance

51:04.120 --> 51:06.120
你觉得应该有东西吗

51:06.120 --> 51:07.120
运行

51:07.120 --> 51:09.120
你看输出5

51:09.120 --> 51:10.120
说明是吧

51:10.120 --> 51:11.120
没骗一门吧

51:11.120 --> 51:13.120
这个东西一定是函数环境

51:13.120 --> 51:14.120
它的参数数量是几个

51:14.120 --> 51:15.120
五个

51:15.120 --> 51:17.120
五个参数

51:17.120 --> 51:19.120
你的模块代码实际上是在这里

51:19.120 --> 51:21.120
它的内部给你处理过的

51:21.120 --> 51:23.120
这才是它为什么没有去

51:23.120 --> 51:24.120
五盏全局

51:24.120 --> 51:26.120
你看意思吧

51:26.120 --> 51:28.120
这里是你的模块代码

51:28.120 --> 51:29.120
看清楚

51:29.120 --> 51:31.120
这是它定义好的一个函数

51:31.120 --> 51:32.120
但这个函数没调用

51:32.120 --> 51:33.120
没调用它不会执行的

51:33.120 --> 51:34.120
它马上会调用

51:34.120 --> 51:35.120
它怎么调用的

51:35.120 --> 51:37.120
你看这里边有这么多参数

51:37.120 --> 51:38.120
它首先准备好这些参数

51:38.120 --> 51:39.120
它现在要为这个函数

51:39.120 --> 51:40.120
准备参数了

51:40.120 --> 51:42.120
因为这个模块的执行过程中

51:42.120 --> 51:43.120
要用到那些东西

51:43.120 --> 51:44.120
有可能会用到

51:44.120 --> 51:46.120
这两个东西你们现在用不到的

51:46.120 --> 51:47.120
顺便说一下

51:47.120 --> 51:48.120
你们以后都会学习的

51:48.120 --> 51:49.120
你要知道

51:49.120 --> 51:50.120
它就是在函数参数里边

51:50.120 --> 51:51.120
glob里边是没有的

51:51.120 --> 51:52.120
那么现在还要

51:52.120 --> 51:53.120
开始为这个函数

51:53.120 --> 51:54.120
准备参数

51:54.120 --> 51:55.120
它怎么准备的

51:55.120 --> 51:56.120
它首先生成一个对象

51:56.120 --> 51:57.120
对象里边有很多东西

51:57.120 --> 51:58.120
它不是说只有这个

51:58.120 --> 51:59.120
不过跟我们

51:59.120 --> 52:01.120
我们现在只关心这个

52:01.120 --> 52:02.120
模块化里边只关心这个

52:02.120 --> 52:04.120
module一个对象

52:04.120 --> 52:06.120
对象里边有个属性叫exports

52:06.120 --> 52:08.120
是一个空对象

52:09.120 --> 52:11.120
然后它又定了个变量exports

52:11.120 --> 52:13.120
又把module的exports

52:13.120 --> 52:15.120
给复制过来了

52:15.120 --> 52:16.120
那么这个东西

52:16.120 --> 52:18.120
跟这个东西是不是一样的

52:18.120 --> 52:19.120
这两个不是完全一样的

52:19.120 --> 52:20.120
对吧

52:20.120 --> 52:21.120
都是一个空对象

52:21.120 --> 52:22.120
然后file name

52:22.120 --> 52:23.120
这个东西

52:23.120 --> 52:24.120
你看一下就行了

52:24.120 --> 52:25.120
它有办法的

52:25.120 --> 52:26.120
得到的环境里边

52:26.120 --> 52:28.120
是可以得到文件的相关信息的

52:28.120 --> 52:30.120
它就得到当前模块的

52:30.120 --> 52:31.120
就相当于是当前模块的

52:31.120 --> 52:32.120
就是决定路径

52:32.120 --> 52:33.120
对不对

52:33.120 --> 52:34.120
dl那边

52:34.120 --> 52:36.120
它根据用了个什么

52:36.120 --> 52:37.120
就是路径处理

52:37.120 --> 52:39.120
它得到它的文件夹路径

52:39.120 --> 52:40.120
这个两个都很容易得到的

52:40.120 --> 52:41.120
你不用去管

52:41.120 --> 52:43.120
得到一个文件路径和目录

52:43.120 --> 52:44.120
是不是

52:44.120 --> 52:45.120
这个数据有了

52:45.120 --> 52:46.120
这个数据有了

52:46.120 --> 52:47.120
module是不是有了

52:47.120 --> 52:48.120
对不对

52:48.120 --> 52:49.120
还有什么require

52:49.120 --> 52:50.120
require是什么

52:50.120 --> 52:51.120
为什么在这里边

52:51.120 --> 52:53.120
可以用require

52:53.120 --> 52:55.120
因为它把这个require

52:55.120 --> 52:57.120
它把这个函数给你传过来了

52:57.120 --> 52:59.120
它把整个require函数给你传过来了

52:59.120 --> 53:01.120
它把这个函数

53:01.120 --> 53:03.120
这个函数给你传过来了

53:03.120 --> 53:04.120
对吧

53:04.120 --> 53:05.120
为什么可以用require

53:05.120 --> 53:06.120
因为在这里边

53:06.120 --> 53:08.120
它把这个函数本身给你传过来了

53:08.120 --> 53:09.120
所以这里边可以用require

53:09.120 --> 53:10.120
你看

53:10.120 --> 53:11.120
现在的参数是数量

53:11.120 --> 53:12.120
它有了

53:12.120 --> 53:13.120
它有了

53:13.120 --> 53:14.120
它有了

53:14.120 --> 53:15.120
它也有了

53:15.120 --> 53:16.120
是不是它也有了

53:16.120 --> 53:17.120
依次传过去

53:17.120 --> 53:18.120
第一个参数

53:18.120 --> 53:19.120
看着跟我鼠标走

53:19.120 --> 53:20.120
第一个参数

53:20.120 --> 53:21.120
第二个参数

53:21.120 --> 53:22.120
第二个参数

53:22.120 --> 53:23.120
函数传进去

53:23.120 --> 53:24.120
第三个参数

53:24.120 --> 53:25.120
第四个参数

53:25.120 --> 53:26.120
第五个参数

53:26.120 --> 53:28.120
那么第一个是啥

53:28.120 --> 53:29.120
它用quare来调用的

53:29.120 --> 53:31.120
第一个是不是绑定z

53:31.120 --> 53:33.120
是不是绑定z

53:33.120 --> 53:34.120
z绑定了指向谁

53:34.120 --> 53:35.120
指向的是不是

53:35.120 --> 53:36.120
还是它

53:36.120 --> 53:37.120
对不对

53:37.120 --> 53:38.120
是不是还是它

53:38.120 --> 53:39.120
说明啥

53:39.120 --> 53:40.120
在模块内部

53:40.120 --> 53:41.120
你是可以用z的

53:41.120 --> 53:42.120
z等于谁

53:42.120 --> 53:45.500
就等于这个exports

53:45.500 --> 53:46.500
你看看

53:46.500 --> 53:47.500
是不是true

53:47.500 --> 53:48.500
对吧

53:48.500 --> 53:49.500
那么z是不是global

53:49.500 --> 53:50.500
不是

53:50.500 --> 53:51.500
它不像浏览区的样子

53:51.500 --> 53:52.500
浏览区在拳句里边

53:52.500 --> 53:53.500
z是不是就是window

53:53.500 --> 53:54.500
对吧

53:54.500 --> 53:55.500
它z是不是global

53:55.500 --> 53:56.500
不是

53:56.500 --> 53:57.500
你看一下z是啥玩意

53:57.500 --> 53:59.500
是不是一个空队箱

53:59.500 --> 54:00.500
看见

54:00.500 --> 54:01.500
是不是空队箱

54:01.500 --> 54:03.500
它是这么玩的

54:03.500 --> 54:05.500
然后运行

54:05.500 --> 54:06.500
那么运行

54:06.500 --> 54:07.500
相当于是不是运行

54:07.500 --> 54:08.500
这个函数

54:08.500 --> 54:09.500
以运行玩的过后

54:09.500 --> 54:10.500
那么目标模块

54:10.500 --> 54:11.500
比方我倒入的是rider

54:11.500 --> 54:12.500
那么rider是不是就运行完了

54:12.500 --> 54:13.500
好

54:13.500 --> 54:14.500
运行完了之后

54:14.500 --> 54:15.500
它会做出一件什么事呢

54:15.500 --> 54:18.500
它会把marge的exports的值

54:18.500 --> 54:19.500
对吧

54:19.500 --> 54:20.500
它一开始是空队箱

54:20.500 --> 54:21.500
但是我把marge传给你过后了

54:21.500 --> 54:22.500
我鬼知道你里面

54:22.500 --> 54:23.500
执行了什么代码

54:23.500 --> 54:24.500
你执行完了过后

54:24.500 --> 54:26.500
marge.exports是不是不是空的了

54:26.500 --> 54:27.500
它又不是空队箱了

54:27.500 --> 54:28.500
变成一个函数了

54:28.500 --> 54:29.500
不管它是啥

54:29.500 --> 54:31.500
总之我把require运行了一遍

54:31.500 --> 54:33.500
法里德模块运行了一遍

54:33.500 --> 54:34.500
把marge给你

54:34.500 --> 54:35.500
运行完了过后

54:35.500 --> 54:39.500
我就把marge.exports的东西缓存起来

54:39.500 --> 54:40.500
你看

54:40.500 --> 54:41.500
刚才没有缓存

54:41.500 --> 54:42.500
现在是不是有缓存了

54:42.500 --> 54:43.500
有了缓存过后

54:43.500 --> 54:44.500
下一次是不是不用执行了

54:44.500 --> 54:45.500
对吧

54:45.500 --> 54:46.500
缓存的是什么

54:46.500 --> 54:47.500
缓存的是一个方可形

54:47.500 --> 54:48.500
对吧

54:48.500 --> 54:49.500
这边是不是缓存的是一个方可形

54:49.500 --> 54:52.500
它把marge.exports缓存的是一个方可形

54:52.500 --> 54:53.500
我就不写了

54:53.500 --> 54:56.500
然后再把整个require返回

54:56.500 --> 54:57.500
require函数返回

54:57.500 --> 55:00.500
返回这个marge.exports

55:00.500 --> 55:05.760
看到没

55:05.760 --> 55:10.070
只有Node能运行另外的那个吗

55:10.070 --> 55:11.070
什么叫另外的那个

55:11.070 --> 55:12.070
Node里面

55:12.070 --> 55:14.070
每一个GS都是这样子

55:14.070 --> 55:16.070
都是放到这里边运行的

55:16.070 --> 55:17.070
每一个GS

55:17.070 --> 55:18.070
每一个GS模块

55:18.070 --> 55:21.070
都是放到这个函数里边运行的

55:21.070 --> 55:24.450
它变成这个样子

55:24.450 --> 55:25.450
所以说这里边呢

55:25.450 --> 55:26.450
你把这个东西看懂了之后

55:26.450 --> 55:30.450
其实可以发现很多有趣的现象

55:30.450 --> 55:31.450
我在Node里边

55:31.450 --> 55:33.450
你看我在rider里边

55:33.450 --> 55:34.450
我可以这样导出

55:34.450 --> 55:36.450
那如果说我这种情况

55:36.450 --> 55:37.450
A.GS 你看着啊

55:37.450 --> 55:38.450
A.GS

55:38.450 --> 55:39.450
我一啥都不写

55:39.450 --> 55:40.450
一行代码不写

55:40.450 --> 55:42.450
然后我到index里边去

55:42.450 --> 55:43.450
一行代码不写

55:43.450 --> 55:50.100
我require.a

55:50.100 --> 55:51.100
我输出a

55:51.100 --> 55:56.840
请问a是个啥

55:56.840 --> 55:58.840
对 这是Node的特点

55:58.840 --> 56:03.330
a是个啥

56:03.330 --> 56:06.330
青牙东西看懂了的

56:06.330 --> 56:07.330
是不是空对象

56:07.330 --> 56:09.330
为什么你看这个原理

56:09.330 --> 56:11.330
当你运行这个

56:11.330 --> 56:13.330
就是这个东西是空的

56:13.330 --> 56:14.330
你的模块里边啥都没写的

56:14.330 --> 56:15.330
那么相当于是

56:15.330 --> 56:16.330
我在这边导入你这个模块

56:16.330 --> 56:17.330
A的时候

56:17.330 --> 56:18.330
那么A这个模块里

56:18.330 --> 56:19.330
啥单码都没有

56:19.330 --> 56:20.330
这里边也是空的

56:20.330 --> 56:22.330
那么它就空调用一次

56:22.330 --> 56:23.330
空调用一次

56:23.330 --> 56:24.330
Marcho的Exports

56:24.330 --> 56:25.330
原来是啥又是啥

56:25.330 --> 56:26.330
对不对

56:26.330 --> 56:27.330
它最终运行的结果

56:27.330 --> 56:28.330
就是模块

56:28.330 --> 56:30.330
它导出的结果一定是这个

56:30.330 --> 56:32.330
所以它就是个空对象

56:32.330 --> 56:34.330
还有这个空对象

56:34.330 --> 56:35.330
明儿的意思吧

56:35.330 --> 56:36.330
好 那么我现在写

56:36.330 --> 56:38.330
你看着我可以有各种模儿法

56:38.330 --> 56:40.330
我可以这样子写

56:40.330 --> 56:45.110
我可以这样子写

56:45.110 --> 56:46.110
那么导出的是啥呢

56:46.110 --> 56:47.110
你看啊

56:47.110 --> 56:48.110
导出一个对象里边

56:48.110 --> 56:49.110
A和B

56:49.110 --> 56:51.110
A等于B等于2

56:51.110 --> 56:53.110
这样是不是要方便一下

56:53.110 --> 56:54.110
当然想导出多个的时候

56:54.110 --> 56:56.110
是不是可以用它

56:56.110 --> 56:57.110
是不是可以用它

56:57.110 --> 56:58.110
为什么呢

56:58.110 --> 57:00.110
因为这个Exports是这个参数

57:00.110 --> 57:02.110
它就是这个对象

57:02.110 --> 57:03.110
对不对

57:03.110 --> 57:04.110
Exports叫A等于1

57:04.110 --> 57:06.110
相当于往这个对象里边

57:06.110 --> 57:07.110
放一个A等于1

57:07.110 --> 57:08.110
叫B等于2

57:08.110 --> 57:10.110
相当于放一个B等于2

57:11.110 --> 57:12.110
对吧

57:12.110 --> 57:13.110
是不是

57:13.110 --> 57:14.110
那么它目前的方

57:14.110 --> 57:16.110
目前的跟这种写法

57:16.110 --> 57:17.110
是完全一样的

57:17.110 --> 57:20.110
Marcho叫Exports叫A等于1

57:20.110 --> 57:22.110
Marcho叫Exports B等于2

57:22.110 --> 57:24.110
是完全一样的

57:24.110 --> 57:25.110
因为它们本来

57:25.110 --> 57:26.110
就是一个东西嘛

57:26.110 --> 57:28.110
是不是一个东西

57:28.110 --> 57:29.110
对吧

57:29.110 --> 57:30.110
但是呢

57:30.110 --> 57:31.110
我们现在继续玩

57:32.110 --> 57:33.110
它们用Z是一样的

57:33.110 --> 57:35.110
Z也是指向那个东西的

57:35.110 --> 57:36.110
都是那个同一个对象

57:36.110 --> 57:40.110
Z和Exports和什么

57:40.110 --> 57:42.110
Marcho叫Exports

57:42.110 --> 57:43.110
都是一样的

57:43.110 --> 57:44.110
都等于这个对象

57:44.110 --> 57:46.110
就这么简单

57:47.110 --> 57:49.110
好 接下来我们来玩一些

57:49.110 --> 57:51.110
滑的浮哨的

57:51.110 --> 57:52.110
现在呢

57:52.110 --> 57:55.550
我们这样走玩

57:55.550 --> 57:57.550
Exports B等于2

57:57.550 --> 58:02.860
Marcho叫Exports

58:02.860 --> 58:04.860
等于3

58:04.860 --> 58:08.560
这个会不会输出啥

58:09.560 --> 58:10.560
我这边来

58:10.560 --> 58:11.560
导致A

58:11.560 --> 58:12.560
它导致的是个啥

58:16.470 --> 58:17.470
还能弄一下不错

58:17.470 --> 58:18.470
青牙

58:18.470 --> 58:19.470
蚂蚁同学都很不错

58:19.470 --> 58:20.470
它导致的是什么

58:20.470 --> 58:21.470
导致的就是3

58:22.470 --> 58:23.470
为什么呢

58:23.470 --> 58:24.470
因为

58:24.470 --> 58:25.470
你看

58:25.470 --> 58:27.470
它们本来是一样的

58:27.470 --> 58:28.470
对吧

58:28.470 --> 58:30.470
现在你看个奇怪的现象

58:30.470 --> 58:31.470
本来是一样的

58:31.470 --> 58:32.470
然后呢

58:32.470 --> 58:33.470
你通过Exports给

58:33.470 --> 58:34.470
夹了一个A

58:34.470 --> 58:35.470
是不是相当于往这个对象里面

58:35.470 --> 58:36.470
夹一个A

58:36.470 --> 58:37.470
夹了一个B

58:37.470 --> 58:38.470
是不是夹了一个B

58:39.470 --> 58:40.470
对不对

58:40.470 --> 58:41.470
那么对象

58:41.470 --> 58:42.470
本来是导致这个的

58:42.470 --> 58:43.470
但是你手键

58:43.470 --> 58:45.470
写了一句Marcho.Exports

58:45.470 --> 58:46.470
是我手键

58:46.470 --> 58:47.470
写了一句Marcho.Exports

58:47.470 --> 58:48.470
等于3

58:48.470 --> 58:49.470
不好意思

58:49.470 --> 58:50.470
从此以后Marcho.Exports

58:50.470 --> 58:52.470
不再指向这个对象了

58:52.470 --> 58:54.470
它单独单飞了

58:54.470 --> 58:56.470
它等于3了

58:56.470 --> 58:57.470
不好意思

58:57.470 --> 58:58.470
最终

58:58.470 --> 58:59.470
我们看到的原理里边

58:59.470 --> 59:00.470
最终用的是什么

59:00.470 --> 59:02.470
用的就是它

59:03.470 --> 59:04.470
它是脑袋

59:04.470 --> 59:05.470
用的是它

59:05.470 --> 59:06.470
所以说现在呢

59:06.470 --> 59:08.470
模块导出的就是3了

59:08.470 --> 59:09.470
缓存的当然也是3

59:09.470 --> 59:11.470
因此就变成3了

59:11.470 --> 59:13.470
明儿的意思吧

59:13.470 --> 59:14.470
我们又继续

59:14.470 --> 59:16.470
我们又继续看着

59:16.470 --> 59:18.470
我们又要这样子写

59:21.470 --> 59:23.470
等于3

59:23.470 --> 59:28.130
我把这个写后边

59:28.130 --> 59:34.660
这又是啥

59:34.660 --> 59:38.700
这又是啥

59:38.700 --> 59:39.700
不要被吓到了

59:39.700 --> 59:40.700
不要被吓到了

59:40.700 --> 59:41.700
勇敢一点

59:41.700 --> 59:42.700
仍然是3

59:42.700 --> 59:44.700
听懂了就要大胆的说

59:44.700 --> 59:45.700
还是3

59:45.700 --> 59:46.700
没有任何问题

59:46.700 --> 59:47.700
运行

59:47.700 --> 59:48.700
说还是3

59:48.700 --> 59:49.700
它不是一样的吧

59:49.700 --> 59:50.700
一开始本来是

59:50.700 --> 59:51.700
本来都是一家人

59:51.700 --> 59:52.700
对不对

59:52.700 --> 59:57.040
一开始都是一家人

59:57.040 --> 59:59.040
我讲的有点慢了

59:59.040 --> 01:00:01.040
然后呢

01:00:01.040 --> 01:00:02.040
首先它就单飞了

01:00:02.040 --> 01:00:05.040
它跑了

01:00:05.040 --> 01:00:06.040
跑了

01:00:06.040 --> 01:00:08.040
然后后边呢

01:00:08.040 --> 01:00:09.040
这两个东西

01:00:09.040 --> 01:00:10.040
这两个

01:00:10.040 --> 01:00:11.040
后妈生的

01:00:11.040 --> 01:00:12.040
随便怎么玩

01:00:12.040 --> 01:00:14.040
跟它是不是没关系了

01:00:14.040 --> 01:00:15.040
跟它没关系了

01:00:15.040 --> 01:00:16.040
那么这个时候呢

01:00:16.040 --> 01:00:17.040
这两个东西

01:00:17.040 --> 01:00:19.040
跟它相当于是脱钩了

01:00:19.040 --> 01:00:20.040
一旦脱钩了

01:00:20.040 --> 01:00:21.040
会怎么样

01:00:21.040 --> 01:00:22.040
一旦脱钩了

01:00:22.040 --> 01:00:23.040
跟它就没关系了

01:00:23.040 --> 01:00:24.040
因为最多我们导出是它

01:00:24.040 --> 01:00:25.040
没有意思吧

01:00:25.040 --> 01:00:26.040
好

01:00:26.040 --> 01:00:27.040
那么看了这个东西过后了

01:00:27.040 --> 01:00:29.040
我们先来做一个面试题

01:00:29.040 --> 01:00:30.040
这代码输出啥

01:00:30.040 --> 01:00:38.150
有两个模块

01:00:38.150 --> 01:00:39.150
A.js

01:00:39.150 --> 01:00:45.600
index.js

01:00:45.600 --> 01:00:47.600
说尽量不要混折用

01:00:47.600 --> 01:00:50.600
你要单用那个exports可以

01:00:50.600 --> 01:00:51.600
就是说你平时写代码的时候

01:00:51.600 --> 01:00:53.600
你导出模块

01:00:53.600 --> 01:00:54.600
你如果说有很多东西

01:00:54.600 --> 01:00:55.600
需要导出

01:00:55.600 --> 01:00:56.600
你可以这样子写

01:00:56.600 --> 01:00:59.600
导出第一个东西

01:00:59.600 --> 01:01:02.600
然后呢导出第二个东西

01:01:02.600 --> 01:01:04.600
它可以是任何东西

01:01:04.600 --> 01:01:06.600
你可以这样子写

01:01:06.600 --> 01:01:07.600
或者是

01:01:07.600 --> 01:01:08.600
你可以这样子写

01:01:08.600 --> 01:01:10.600
module.exports

01:01:10.600 --> 01:01:11.600
导出一个对象

01:01:11.600 --> 01:01:12.600
对象里边呢

01:01:12.600 --> 01:01:14.600
第一个东西

01:01:14.600 --> 01:01:15.600
第二个东西

01:01:15.600 --> 01:01:17.600
效果都是一样的

01:01:17.600 --> 01:01:18.600
尽量不要混折写

01:01:18.600 --> 01:01:19.600
混折写的话

01:01:19.600 --> 01:01:22.550
就乱了

01:01:22.550 --> 01:01:30.760
你看看这个题

01:01:30.760 --> 01:01:32.760
你把上面那个

01:01:32.760 --> 01:01:34.760
common.js的

01:01:34.760 --> 01:01:37.760
原理的代码看懂之后呢

01:01:37.760 --> 01:01:39.760
这些随便留这么考

01:01:39.760 --> 01:01:46.490
考不到理的

01:01:46.490 --> 01:01:47.490
说实在呀

01:01:47.490 --> 01:01:48.490
那么我们一个个看呗

01:01:48.490 --> 01:01:50.490
首先这个玩意是啥

01:01:50.490 --> 01:01:52.490
这个玩意不就是

01:01:52.490 --> 01:01:53.490
读去寒树残树的

01:01:53.490 --> 01:01:54.490
第二个残树吗

01:01:54.490 --> 01:01:55.490
那里看一下

01:01:55.490 --> 01:01:57.490
寒树残树的第二个残树是啥

01:01:57.490 --> 01:01:58.490
这是第一个

01:01:58.490 --> 01:01:59.490
第二个不就是require

01:01:59.490 --> 01:02:00.490
所以它这样的写

01:02:00.490 --> 01:02:01.490
纯粹是恶心理的

01:02:01.490 --> 01:02:03.490
它就是这样的写的

01:02:03.490 --> 01:02:04.490
纯粹是恶心理的

01:02:04.490 --> 01:02:05.490
对不对

01:02:05.490 --> 01:02:06.490
然后呢

01:02:06.490 --> 01:02:07.490
倒入什么a.js

01:02:07.490 --> 01:02:08.490
是不是倒入它

01:02:08.490 --> 01:02:09.490
那是不是把a.j

01:02:09.490 --> 01:02:10.490
执行一遍

01:02:10.490 --> 01:02:11.490
好执行一遍的

01:02:11.490 --> 01:02:12.490
你看啊

01:02:12.490 --> 01:02:13.490
它一开始

01:02:13.490 --> 01:02:14.490
一开始的时候是这个样子

01:02:14.490 --> 01:02:17.490
z是等于exports

01:02:17.490 --> 01:02:19.490
等于mortul

01:02:19.490 --> 01:02:20.490
exports

01:02:20.490 --> 01:02:22.490
三个是一家人的

01:02:22.490 --> 01:02:24.490
本来是一家人的

01:02:24.490 --> 01:02:25.490
然后呢

01:02:25.490 --> 01:02:26.490
它把a

01:02:26.490 --> 01:02:27.490
设为1

01:02:27.490 --> 01:02:28.490
我这就换一个好吗

01:02:28.490 --> 01:02:29.490
什么都是等于这个

01:02:29.490 --> 01:02:31.490
然后a等于1

01:02:31.490 --> 01:02:32.490
对吧一开始没问题

01:02:32.490 --> 01:02:33.490
然后呢

01:02:33.490 --> 01:02:35.490
mortul.exports.b等于2

01:02:35.490 --> 01:02:36.490
又来

01:02:36.490 --> 01:02:37.490
又加上一个2

01:02:37.490 --> 01:02:38.490
对不对

01:02:38.490 --> 01:02:39.490
然后呢

01:02:39.490 --> 01:02:40.490
mortul.exports

01:02:40.490 --> 01:02:41.490
重新给它复制了

01:02:41.490 --> 01:02:46.020
重新复制了

01:02:46.020 --> 01:02:47.020
变成了什么

01:02:47.020 --> 01:02:48.020
变成了一个方形

01:02:48.020 --> 01:02:49.020
一个函数

01:02:49.020 --> 01:02:50.020
对不对

01:02:50.020 --> 01:02:51.020
然后呢

01:02:51.020 --> 01:02:53.020
又用mortul.exports.c

01:02:53.020 --> 01:02:54.020
所以这个函数

01:02:54.020 --> 01:02:55.020
上面有了个c

01:02:55.020 --> 01:02:56.020
对不对

01:02:56.020 --> 01:02:57.020
这个函数是一个对象

01:02:57.020 --> 01:02:58.020
因为函数

01:02:58.020 --> 01:02:59.020
它本质上是一个对象

01:02:59.020 --> 01:03:00.020
里面是对家属性的

01:03:00.020 --> 01:03:02.020
函数里面有个c3

01:03:02.020 --> 01:03:04.020
对不对

01:03:04.020 --> 01:03:05.020
好

01:03:05.020 --> 01:03:06.020
然后呢

01:03:06.020 --> 01:03:07.020
exports.d

01:03:07.020 --> 01:03:08.020
等于4

01:03:08.020 --> 01:03:09.020
exports还在玩以前的东西

01:03:09.020 --> 01:03:10.020
d等于4

01:03:10.020 --> 01:03:11.020
然后呢

01:03:11.020 --> 01:03:12.020
z

01:03:12.020 --> 01:03:13.020
还在玩以前的

01:03:13.020 --> 01:03:14.020
z

01:03:14.020 --> 01:03:15.020
e等于什么

01:03:15.020 --> 01:03:16.020
5

01:03:16.020 --> 01:03:18.020
d等于5

01:03:18.020 --> 01:03:20.020
然后console.log

01:03:20.020 --> 01:03:21.020
z是不等于exports

01:03:21.020 --> 01:03:22.020
当然是等于说

01:03:22.020 --> 01:03:24.020
第一个输出

01:03:24.020 --> 01:03:26.020
第一个输出是q

01:03:26.020 --> 01:03:27.020
对不对

01:03:27.020 --> 01:03:28.020
第二个输出

01:03:28.020 --> 01:03:30.020
z是不等于mortul.exports

01:03:30.020 --> 01:03:31.020
肯定不等了

01:03:31.020 --> 01:03:33.020
两个一分割

01:03:33.020 --> 01:03:34.020
然后又说出

01:03:34.020 --> 01:03:35.740
portul.exports

01:03:35.740 --> 01:03:36.740
肯定也不等吧

01:03:36.740 --> 01:03:37.740
portul.exports

01:03:38.020 --> 01:03:39.020
就要前三个输出portul.exports

01:03:39.020 --> 01:03:40.020
好那么这个模块是不运行完了

01:03:40.020 --> 01:03:42.020
运行完了过后

01:03:42.020 --> 01:03:43.020
这边的request

01:03:43.020 --> 01:03:44.020
是不可以返回了

01:03:44.020 --> 01:03:45.020
返回什么

01:03:45.020 --> 01:03:46.020
mortul.exports

01:03:46.020 --> 01:03:47.020
返回这个

01:03:47.020 --> 01:03:48.020
能返回的是什么呢

01:03:48.020 --> 01:03:49.020
返回的

01:03:49.020 --> 01:03:50.020
那么a 就是这个玩意

01:03:50.020 --> 01:03:51.020
对吧

01:03:51.020 --> 01:03:52.020
a就是这个玩意

01:03:52.020 --> 01:03:53.020
那a 是什么呢

01:03:53.020 --> 01:03:54.020
输出type of a

01:03:54.020 --> 01:03:55.020
是不是输出一个方式

01:03:55.020 --> 01:03:56.020
对不对

01:03:56.020 --> 01:03:57.020
好

01:03:57.020 --> 01:03:58.020
然后输出a

01:03:58.020 --> 01:03:59.020
a属性

01:03:59.020 --> 01:04:02.020
防d2

01:04:02.020 --> 01:04:03.020
b属性

01:04:03.020 --> 01:04:06.620
C属性是不是有

01:04:06.620 --> 01:04:08.620
这个函数里每个属性是3

01:04:08.620 --> 01:04:09.220
对不对

01:04:09.220 --> 01:04:11.020
然后后边说又是两个

01:04:11.020 --> 01:04:16.550
又是两个

01:04:16.550 --> 01:04:17.350
那么最后输出一个

01:04:17.350 --> 01:04:17.950
argument

01:04:17.950 --> 01:04:19.150
所以我们看过了

01:04:19.150 --> 01:04:19.750
输出

01:04:19.750 --> 01:04:21.550
那么最后的输出结果就是这样子

01:04:21.550 --> 01:04:22.550
就是看一下

01:04:22.550 --> 01:04:25.440
啊

01:04:25.440 --> 01:04:27.440
这个就暂停过来

01:04:27.440 --> 01:04:28.440
这是A

01:04:28.440 --> 01:04:29.840
然后应这个时候就导入A

01:04:29.840 --> 01:04:31.040
应这个时候我们再带嘛

01:04:31.040 --> 01:04:32.240
直接暂停过来

01:04:32.240 --> 01:04:36.820
啊运行看一下吧

01:04:36.820 --> 01:04:37.820
人

01:04:37.820 --> 01:04:40.390
怎么样

01:04:40.390 --> 01:04:42.190
我这边写错了啊

01:04:42.190 --> 01:04:46.780
扛错点LOG

01:04:46.780 --> 01:04:48.780
扛错点LOG

01:04:48.780 --> 01:04:49.780
运行

01:04:49.780 --> 01:04:50.380
你看

01:04:50.380 --> 01:04:51.980
True Force Force Function

01:04:51.980 --> 01:04:55.780
Undefine的分在3

01:04:55.780 --> 01:04:56.980
关键点啊

01:04:56.980 --> 01:04:58.580
不要去记那些乱七八糟的规则

01:04:58.580 --> 01:04:59.780
网上有很多

01:04:59.780 --> 01:05:00.780
杂牌教程

01:05:00.780 --> 01:05:00.980
对吧

01:05:00.980 --> 01:05:01.980
告诉你

01:05:01.980 --> 01:05:03.380
这个该怎么用

01:05:03.380 --> 01:05:03.980
这个该怎么用

01:05:03.980 --> 01:05:05.980
不要去记那些具体的规则

01:05:05.980 --> 01:05:07.580
你把这个玩意看懂了

01:05:07.580 --> 01:05:08.780
以不变硬万变

01:05:08.780 --> 01:05:09.580
随便它怎么考

01:05:09.580 --> 01:05:10.980
考不到你的

01:05:10.980 --> 01:05:12.780
这是comment.js

01:05:12.780 --> 01:05:17.000
好

01:05:17.000 --> 01:05:17.600
等完了

01:05:17.600 --> 01:05:20.000
下面这个也是6.9

01:05:20.000 --> 01:05:20.600
啊

01:05:20.600 --> 01:05:22.800
现在时间有点紧啊

01:05:22.800 --> 01:05:24.200
因为种种原因吧

01:05:24.200 --> 01:05:26.400
我却不一啰啰啰扯了

01:05:26.400 --> 01:05:27.600
就是comment.js呢

01:05:27.600 --> 01:05:29.800
在浏览器里边是很麻烦的

01:05:29.800 --> 01:05:31.000
要是在浏览器里边实现

01:05:31.000 --> 01:05:32.900
loader环境里边可以玩得很开心

01:05:32.900 --> 01:05:34.400
但是在浏览器里边就很麻烦

01:05:34.400 --> 01:05:35.800
遇到很多问题

01:05:35.800 --> 01:05:36.800
这些问题呢

01:05:36.800 --> 01:05:38.300
还不仅仅是浏览器

01:05:38.300 --> 01:05:40.500
高奥不愿意不愿意去支持他

01:05:40.500 --> 01:05:41.200
是他

01:05:41.200 --> 01:05:42.600
确实遇到了很多难题

01:05:42.600 --> 01:05:44.400
他不敢支持

01:05:44.400 --> 01:05:46.200
没有找到很合适的办法

01:05:46.200 --> 01:05:47.100
那么这个问题呢

01:05:47.100 --> 01:05:49.400
后来又出现了AMD, CMD, UMD

01:05:49.400 --> 01:05:52.500
大堆基于浏览器的模块号标准

01:05:52.500 --> 01:05:53.400
能不能解决问题呢

01:05:53.400 --> 01:05:54.300
能部分解决

01:05:54.300 --> 01:05:55.900
就是学习来

01:05:55.900 --> 01:05:58.000
跟吃到那个啥一样难受

01:05:58.000 --> 01:05:59.500
非常有恶心的一个代码

01:05:59.500 --> 01:06:01.900
直到ES6标准出现

01:06:01.900 --> 01:06:03.100
ES6标准就是

01:06:03.100 --> 01:06:03.700
官方又出来了

01:06:03.700 --> 01:06:03.900
对吧

01:06:03.900 --> 01:06:05.000
官方总是来得很迟

01:06:05.000 --> 01:06:06.300
但是总是来的

01:06:06.300 --> 01:06:06.800
那总不

01:06:06.800 --> 01:06:07.400
这是官方

01:06:07.400 --> 01:06:08.100
知道吗

01:06:08.100 --> 01:06:09.300
官方总是迟到

01:06:09.300 --> 01:06:11.000
但从不缺息

01:06:11.000 --> 01:06:12.800
那总归是来了

01:06:12.800 --> 01:06:14.000
来了过后呢

01:06:14.000 --> 01:06:15.400
他就说你们别闹了啊

01:06:15.400 --> 01:06:16.800
我又来给主持大局了

01:06:16.900 --> 01:06:17.500
我跟你们说

01:06:17.500 --> 01:06:19.300
你们按照我的来

01:06:19.300 --> 01:06:20.800
他又出现了一个ES6

01:06:20.800 --> 01:06:22.600
我们把有的时候也不

01:06:22.600 --> 01:06:25.700
把简单称为ES module

01:06:25.700 --> 01:06:28.100
在这个

01:06:28.100 --> 01:06:29.800
官方的模块号标准出来过后

01:06:29.800 --> 01:06:31.500
很多浏览器厂商

01:06:31.500 --> 01:06:32.700
更新了浏览器版本

01:06:32.700 --> 01:06:33.800
我该是适应的

01:06:33.800 --> 01:06:35.400
基本上的现代的浏览器啊

01:06:35.400 --> 01:06:36.600
像我们做开发的人

01:06:36.600 --> 01:06:38.700
那浏览器一定是支持ES module的

01:06:38.700 --> 01:06:41.100
但是除了一些

01:06:41.100 --> 01:06:42.500
非不是我们这个行业的人

01:06:42.500 --> 01:06:43.900
可能浏览器比较老一点啊

01:06:43.900 --> 01:06:45.500
比方说

01:06:45.500 --> 01:06:46.300
有关部门

01:06:47.000 --> 01:06:48.600
有关部门总是很神奇的

01:06:48.600 --> 01:06:50.200
他的浏览器呢

01:06:50.200 --> 01:06:51.900
就是很奇葩的版本

01:06:51.900 --> 01:06:52.800
因此

01:06:52.800 --> 01:06:53.500
绝大部分啊

01:06:53.500 --> 01:06:55.600
浏览器都已经支持了ES module

01:06:55.600 --> 01:06:56.700
包括你们现在看到的

01:06:56.700 --> 01:06:57.500
Viu3出来了

01:06:57.500 --> 01:06:57.800
对吧

01:06:57.800 --> 01:07:00.600
Viu3有个工具叫做Vit

01:07:00.600 --> 01:07:01.800
速度是不是比这个

01:07:01.800 --> 01:07:03.400
VPAC快很多很多

01:07:03.400 --> 01:07:04.300
他为什么那么快

01:07:04.300 --> 01:07:05.400
他就是利用浏览器

01:07:05.400 --> 01:07:07.200
原生支持的ES module

01:07:07.200 --> 01:07:09.100
来实现的

01:07:09.100 --> 01:07:10.000
那么他怎么来用呢

01:07:10.000 --> 01:07:10.900
在浏览器里边

01:07:10.900 --> 01:07:11.800
非常简单

01:07:11.800 --> 01:07:12.700
那浏览器在引用

01:07:12.700 --> 01:07:13.800
GS文件的时候呢

01:07:13.800 --> 01:07:15.300
就不要去

01:07:15.300 --> 01:07:16.500
一个SRC就完了

01:07:16.500 --> 01:07:18.000
多说一句吧

01:07:18.000 --> 01:07:18.900
以前的那种方式

01:07:18.900 --> 01:07:19.900
我也支持

01:07:19.900 --> 01:07:20.900
现在我多了一种方式

01:07:20.900 --> 01:07:22.900
加上一个Type等于Module

01:07:22.900 --> 01:07:23.700
于是

01:07:23.700 --> 01:07:24.400
呼

01:07:24.400 --> 01:07:25.300
你这个文件

01:07:25.300 --> 01:07:26.900
就不是一个普通的文件了

01:07:26.900 --> 01:07:29.600
你是一个非常成熟的模块文件

01:07:29.600 --> 01:07:30.900
就不是小孩子的

01:07:30.900 --> 01:07:31.600
好来看一下

01:07:31.600 --> 01:07:34.300
浏览器的模块还不要准

01:07:34.300 --> 01:07:37.930
也是Module

01:07:37.930 --> 01:07:38.530
好来吧

01:07:38.530 --> 01:07:40.030
我们这里建一个浏览器

01:07:40.030 --> 01:07:43.350
别听不了

01:07:43.350 --> 01:07:43.850
好比方说

01:07:43.850 --> 01:07:44.650
我这里有个文件啊

01:07:44.650 --> 01:07:46.650
1.GS

01:07:46.650 --> 01:07:48.050
或者叫你这个是吧

01:07:48.050 --> 01:07:50.950
有点不能太噁心了

01:07:50.950 --> 01:07:52.950
你这个是个GS

01:07:52.950 --> 01:07:54.550
然后你用一个啊

01:07:54.550 --> 01:07:55.750
Screws

01:07:55.750 --> 01:07:56.950
SRC

01:07:56.950 --> 01:07:58.350
以前是不是这样来用的

01:07:58.350 --> 01:07:59.050
对不对

01:07:59.050 --> 01:07:59.250
好

01:07:59.250 --> 01:08:00.450
现在给他多加一句啊

01:08:00.450 --> 01:08:01.750
Type等于Module

01:08:01.750 --> 01:08:03.750
从此以后

01:08:03.750 --> 01:08:05.950
这个GS还是一个GS

01:08:05.950 --> 01:08:06.350
但是呢

01:08:06.350 --> 01:08:08.750
它就是一个模块化的GS的

01:08:08.750 --> 01:08:10.850
这里边定义的所有的权距变量

01:08:10.850 --> 01:08:12.050
不再污染权距了

01:08:12.050 --> 01:08:14.050
除非你手里

01:08:14.050 --> 01:08:15.750
就开始做这种事情啊

01:08:15.750 --> 01:08:17.250
除非你自己手中去做这种事情

01:08:17.350 --> 01:08:18.850
否则的话不会污染权距了

01:08:18.850 --> 01:08:19.750
你看一下吧

01:08:19.750 --> 01:08:20.650
打开

01:08:20.650 --> 01:08:22.250
现在跟头的环境没关系了啊

01:08:22.250 --> 01:08:23.250
要挑转出来了

01:08:23.250 --> 01:08:24.250
跟头的环境没关系了

01:08:25.750 --> 01:08:26.250
看一下

01:08:26.250 --> 01:08:27.250
我们现在说

01:08:27.250 --> 01:08:27.850
看一下A

01:08:27.850 --> 01:08:28.750
Window点A

01:08:29.950 --> 01:08:30.950
打不出来对吧

01:08:32.050 --> 01:08:32.850
说Andy犯的

01:08:32.850 --> 01:08:34.050
根本就没有这个东西对吧

01:08:34.050 --> 01:08:35.150
然后直接打个A的

01:08:35.150 --> 01:08:36.150
他就说这个变量不存在

01:08:37.950 --> 01:08:39.150
说不会污染权距的

01:08:39.150 --> 01:08:41.350
跟那个Common件是一样的

01:08:41.350 --> 01:08:43.450
那么是不是也要遇到同样的问题

01:08:43.450 --> 01:08:45.250
就是模块怎么导出呢

01:08:45.250 --> 01:08:46.650
模块又怎么导入呢

01:08:46.650 --> 01:08:47.350
首先说导出

01:08:48.750 --> 01:08:50.250
在ES module里边

01:08:50.250 --> 01:08:50.650
在

01:08:51.650 --> 01:08:52.850
官方的模块化里边

01:08:52.850 --> 01:08:53.850
因为官方嘛

01:08:53.850 --> 01:08:54.850
他毕竟是要

01:08:55.550 --> 01:08:56.350
你懂的对吧

01:08:57.050 --> 01:08:58.250
跟别的那种

01:08:58.250 --> 01:08:59.650
妖艳啥

01:08:59.650 --> 01:09:00.450
不太一样的

01:09:01.550 --> 01:09:02.850
你看Common件是

01:09:02.850 --> 01:09:04.550
他们还非常苦逼的用那个

01:09:05.150 --> 01:09:05.850
函数啊

01:09:05.850 --> 01:09:06.650
这些用必包

01:09:06.650 --> 01:09:07.450
其实就是必包

01:09:07.450 --> 01:09:07.750
对不对

01:09:07.750 --> 01:09:09.150
把一个把一个模块

01:09:09.150 --> 01:09:10.450
放到一个必包环境里边

01:09:11.050 --> 01:09:11.950
在模块里边用的东西

01:09:11.950 --> 01:09:13.750
就是必包环境的东西

01:09:13.750 --> 01:09:15.050
他还要去用这种东西

01:09:15.650 --> 01:09:17.250
那么在Common件

01:09:17.250 --> 01:09:19.150
在ES ES module里边

01:09:19.150 --> 01:09:20.150
他是官方的

01:09:20.150 --> 01:09:21.650
我直接给你出语法

01:09:23.050 --> 01:09:24.250
什么锐块含书

01:09:24.250 --> 01:09:25.550
什么模具对象

01:09:25.550 --> 01:09:26.150
统统不要

01:09:26.150 --> 01:09:28.050
我直接给你搞语法

01:09:28.050 --> 01:09:29.450
新语法出现了

01:09:30.950 --> 01:09:32.150
首先要搞清楚概念

01:09:32.150 --> 01:09:33.350
ES module里边

01:09:33.350 --> 01:09:34.350
他要导出

01:09:35.150 --> 01:09:36.750
他不是一个真正的对象

01:09:37.250 --> 01:09:38.150
他跟我们平时用的

01:09:38.150 --> 01:09:38.950
一个GS对象不一样的

01:09:38.950 --> 01:09:39.450
但是呢

01:09:39.450 --> 01:09:40.050
没关系

01:09:40.050 --> 01:09:41.650
你们就把它看成一个对象

01:09:41.850 --> 01:09:43.150
效果是一样的

01:09:43.150 --> 01:09:43.750
啊

01:09:46.040 --> 01:09:47.040
他是什么东西呢

01:09:47.040 --> 01:09:47.440
他

01:09:47.440 --> 01:09:49.240
你怕看成是一个对象啊

01:09:49.240 --> 01:09:50.440
他导出了一个对象

01:09:50.440 --> 01:09:50.840
那么

01:09:51.640 --> 01:09:52.640
那个Common介石

01:09:52.640 --> 01:09:53.340
所以也是一样

01:09:53.340 --> 01:09:54.240
他也导出了对象

01:09:54.240 --> 01:09:54.840
不过Common介石

01:09:54.840 --> 01:09:55.840
导出的是真正的介石

01:09:55.840 --> 01:09:56.140
对象

01:09:56.140 --> 01:09:57.140
他这个不是真正的

01:09:57.840 --> 01:09:58.840
其里边知道就行了

01:09:58.840 --> 01:09:59.540
这里边要说的

01:09:59.540 --> 01:10:00.640
也很细叶的东西

01:10:01.140 --> 01:10:02.640
我们就把它看成是个对象

01:10:03.540 --> 01:10:04.940
这个对象里边有什么东西

01:10:04.940 --> 01:10:06.440
全凭有自己来定

01:10:06.840 --> 01:10:08.240
你可以认为这个对象是空的

01:10:08.640 --> 01:10:09.440
没有什么东西

01:10:09.440 --> 01:10:10.040
它有什么东西

01:10:10.040 --> 01:10:10.940
你自己来定

01:10:12.040 --> 01:10:12.640
其中

01:10:13.840 --> 01:10:14.440
对象里边

01:10:14.540 --> 01:10:15.640
不是有很多属性吗

01:10:15.640 --> 01:10:16.040
对不对

01:10:17.040 --> 01:10:18.640
那么这里边有哪些属性

01:10:18.640 --> 01:10:20.140
导出的对象里边有哪些属性

01:10:20.140 --> 01:10:20.840
你自己来定

01:10:21.840 --> 01:10:23.640
我们把这个定属性

01:10:23.640 --> 01:10:25.540
就定某一个属性的名字是啥

01:10:25.540 --> 01:10:26.640
导出的值是啥

01:10:26.640 --> 01:10:27.840
某一个属性的名字是啥

01:10:27.840 --> 01:10:29.240
导出的这个值是啥

01:10:29.240 --> 01:10:31.240
我们把它叫做基本导出

01:10:31.240 --> 01:10:32.740
或者叫做居民导出

01:10:33.540 --> 01:10:34.940
居民导出

01:10:35.540 --> 01:10:38.040
因为叫做land export

01:10:39.440 --> 01:10:40.240
他有名字的

01:10:40.240 --> 01:10:41.440
他属性是有名字的

01:10:41.440 --> 01:10:42.540
叫做居民导出

01:10:43.040 --> 01:10:45.340
而其中有一个特殊的属性

01:10:46.340 --> 01:10:47.640
他的名字叫做default

01:10:48.140 --> 01:10:48.640
非常特殊

01:10:48.640 --> 01:10:49.640
他的名字叫default

01:10:49.640 --> 01:10:50.640
这个就是特殊属性

01:10:51.540 --> 01:10:52.640
那么这种导出呢

01:10:52.640 --> 01:10:53.940
叫做默认导出

01:10:55.240 --> 01:10:55.940
那么从这个

01:10:55.940 --> 01:10:56.940
从这个对象结构里边

01:10:56.940 --> 01:10:58.040
可以看得非常清楚

01:10:59.140 --> 01:11:00.540
基本导出是不是可以多个

01:11:00.540 --> 01:11:02.340
就居民导出是不是可以有多个

01:11:02.440 --> 01:11:03.440
他有不同的名字吗

01:11:03.440 --> 01:11:04.340
名字你自己去

01:11:04.940 --> 01:11:06.640
默认导出是不是只有一个

01:11:07.340 --> 01:11:07.840
对不对

01:11:08.840 --> 01:11:09.040
好

01:11:09.040 --> 01:11:10.540
他接下来就是一大堆东西的

01:11:10.540 --> 01:11:11.340
大堆语法

01:11:11.440 --> 01:11:13.140
这些语法你千万不要去背啊

01:11:13.140 --> 01:11:13.940
你背的话

01:11:13.940 --> 01:11:15.640
作为老师我就觉得很愁畅

01:11:16.040 --> 01:11:17.340
觉得你们太辛苦了

01:11:17.540 --> 01:11:18.840
我从那边背过这个弯啊

01:11:19.140 --> 01:11:20.040
也不要去背

01:11:20.440 --> 01:11:21.740
对他有没有任何意义

01:11:22.740 --> 01:11:23.840
应该是什么呢

01:11:23.840 --> 01:11:25.640
应该是知道就行了

01:11:25.640 --> 01:11:26.840
他有哪些导出方式

01:11:26.840 --> 01:11:29.040
以后我们在具体写的时候

01:11:29.640 --> 01:11:30.540
你就会用这

01:11:30.540 --> 01:11:31.740
你不只忘了某种方式

01:11:31.740 --> 01:11:32.840
一开始忘了很正常

01:11:33.240 --> 01:11:34.840
你写个十回二十回

01:11:34.840 --> 01:11:35.840
你自然就记得了

01:11:35.840 --> 01:11:36.840
比如说现在

01:11:36.840 --> 01:11:39.240
你们最开始在学习这个介石的时候

01:11:40.240 --> 01:11:43.140
道区名车里边乱七八糟的东西是不是很恶心

01:11:43.140 --> 01:11:43.540
对吧

01:11:43.740 --> 01:11:45.140
一大的东西是不是很陌生

01:11:45.140 --> 01:11:46.140
现在还陌生吗

01:11:46.840 --> 01:11:47.940
如果说你现在还陌生的话

01:11:47.940 --> 01:11:49.940
再一把两个确实不太够啊

01:11:50.240 --> 01:11:51.240
现在肯定不陌生了

01:11:51.240 --> 01:11:52.440
这里边的东西非常熟了

01:11:52.440 --> 01:11:52.840
对吧

01:11:52.840 --> 01:11:54.040
你是背过的吗

01:11:54.140 --> 01:11:54.940
没有背过吧

01:11:54.940 --> 01:11:55.940
不需要去背吧

01:11:55.940 --> 01:11:56.740
背也背不住

01:11:56.740 --> 01:11:58.440
你是不断的学大码的过程中

01:11:58.440 --> 01:11:59.140
自然就熟悉了

01:11:59.140 --> 01:12:00.340
这些也是一样啊

01:12:00.340 --> 01:12:01.040
这个魔画画里面

01:12:01.040 --> 01:12:02.040
以后天天都要写的

01:12:02.640 --> 01:12:04.640
你写啥都是都是用魔画画写的

01:12:05.640 --> 01:12:06.340
我们来看一下

01:12:06.340 --> 01:12:07.240
看一下就行了

01:12:07.240 --> 01:12:08.040
体验一下

01:12:08.540 --> 01:12:09.640
Exports

01:12:10.340 --> 01:12:11.940
VaA等于E

01:12:11.940 --> 01:12:13.440
它就是一个基本导出

01:12:13.740 --> 01:12:15.740
它为什么要这样子用基本导出呢

01:12:15.740 --> 01:12:18.240
因为你必须要是一个声名语句

01:12:20.410 --> 01:12:21.710
什么叫做声名语句

01:12:23.010 --> 01:12:23.810
提出来了

01:12:24.310 --> 01:12:25.710
这个玩意是声名语句

01:12:26.010 --> 01:12:27.910
这个玩意是声名和父子一起的

01:12:27.910 --> 01:12:29.510
它同样属于声名语句

01:12:29.610 --> 01:12:30.010
对吧

01:12:30.010 --> 01:12:31.510
这个表达是没有指的

01:12:32.110 --> 01:12:33.510
这个表达是是没有指的

01:12:34.110 --> 01:12:34.610
啊

01:12:35.110 --> 01:12:36.510
这个玩意是声名语句

01:12:38.520 --> 01:12:39.920
这是不是声名语句

01:12:39.920 --> 01:12:40.220
对吧

01:12:40.220 --> 01:12:41.420
声名一个函数

01:12:41.720 --> 01:12:42.020
对吧

01:12:42.020 --> 01:12:43.220
其实基础不要丢啊

01:12:43.320 --> 01:12:44.520
传统手艺不能丢

01:12:46.320 --> 01:12:49.120
居民导出必须要有名字

01:12:49.120 --> 01:12:49.620
为什么

01:12:49.620 --> 01:12:50.820
因为他导出了这个东西

01:12:50.820 --> 01:12:52.520
他必须要有属性名啊

01:12:52.720 --> 01:12:53.520
你不给他名字

01:12:53.520 --> 01:12:54.620
他没办法玩

01:12:54.820 --> 01:12:56.420
所以他必须要有名字

01:12:57.020 --> 01:12:57.820
要有名字

01:12:57.820 --> 01:12:59.920
只有声名语句才有名字

01:12:59.920 --> 01:13:01.420
你看定一个边量A

01:13:01.620 --> 01:13:02.420
有名字吧

01:13:02.520 --> 01:13:03.620
那么他导出的是什么

01:13:03.620 --> 01:13:04.320
导出一个对象

01:13:04.320 --> 01:13:06.220
对象里面那个属性名A等于E

01:13:07.420 --> 01:13:08.520
那么定一个边量B

01:13:08.520 --> 01:13:09.220
B是一个函数

01:13:09.320 --> 01:13:10.420
相当于是导出一个B

01:13:10.420 --> 01:13:11.020
这个B呢

01:13:11.020 --> 01:13:12.120
是一个函方式

01:13:12.620 --> 01:13:13.320
明儿意思吧

01:13:14.120 --> 01:13:14.420
好

01:13:14.420 --> 01:13:15.420
也可以用这种方式

01:13:15.420 --> 01:13:16.420
声名一个函数

01:13:16.520 --> 01:13:17.420
方形没色的

01:13:17.420 --> 01:13:19.020
那么相当于是基本导出

01:13:19.020 --> 01:13:20.120
没色的等于方形

01:13:20.120 --> 01:13:21.820
那么现在对象里面说有三个东西的

01:13:22.120 --> 01:13:23.420
A B 没色的

01:13:23.420 --> 01:13:24.020
对不对

01:13:24.820 --> 01:13:25.220
好

01:13:26.720 --> 01:13:29.220
你能不能这样子写导出看一下啊

01:13:30.620 --> 01:13:31.620
那就比方这个啊

01:13:31.820 --> 01:13:32.420
expo

01:13:33.220 --> 01:13:34.320
他直接又提示你了

01:13:34.320 --> 01:13:34.720
对吧

01:13:35.920 --> 01:13:36.920
能不能这样子写呢

01:13:37.520 --> 01:13:38.120
不行

01:13:39.220 --> 01:13:40.120
为什么不行啊

01:13:40.120 --> 01:13:41.620
老师这里不是

01:13:42.020 --> 01:13:42.720
有名字吗

01:13:42.720 --> 01:13:43.220
名字A

01:13:43.220 --> 01:13:43.520
对啊

01:13:43.520 --> 01:13:44.420
你看着有名字

01:13:44.420 --> 01:13:45.920
程序看到他就没名字了

01:13:45.920 --> 01:13:46.420
为什么呢

01:13:46.420 --> 01:13:47.920
因为你这个是表达式

01:13:48.120 --> 01:13:49.320
不是声名语句

01:13:49.420 --> 01:13:50.420
表达式意味着什么

01:13:50.420 --> 01:13:51.820
他把表达式算出来

01:13:51.920 --> 01:13:53.520
一算出来是不是这里变成三了

01:13:53.620 --> 01:13:54.620
那还有名字吗

01:13:55.220 --> 01:13:56.120
就没名字了

01:13:57.220 --> 01:13:57.620
啊

01:13:57.820 --> 01:13:58.820
那也说同样

01:13:58.820 --> 01:14:00.020
能不能这样子写呢

01:14:00.020 --> 01:14:01.420
那这不是有名字吗

01:14:01.420 --> 01:14:01.720
不对

01:14:01.720 --> 01:14:02.920
这是个表达式

01:14:03.020 --> 01:14:04.520
负值表达式

01:14:04.520 --> 01:14:06.320
负值表达式的值等于什么

01:14:06.320 --> 01:14:08.220
等于边量的值

01:14:08.320 --> 01:14:09.820
负完负完过后的值

01:14:10.320 --> 01:14:11.020
是不等于啥

01:14:11.120 --> 01:14:12.620
还是一样还是没名字

01:14:12.920 --> 01:14:14.420
居民导出必须要有名字

01:14:14.420 --> 01:14:15.920
所以说不能让你这样子写

01:14:16.220 --> 01:14:18.120
那么他如果说你已经有个边量

01:14:18.120 --> 01:14:18.720
你怎么写了

01:14:18.720 --> 01:14:19.420
你不要去背啊

01:14:19.420 --> 01:14:20.720
再说也是千万不要去背

01:14:20.720 --> 01:14:21.620
你会很累的

01:14:21.920 --> 01:14:22.520
没有必要背

01:14:22.520 --> 01:14:24.420
你只需要知道他有很多种方式

01:14:24.920 --> 01:14:27.620
有很多种方式基本进行居民导出

01:14:27.620 --> 01:14:29.620
有很多种方式默认导出

01:14:29.620 --> 01:14:30.620
知道这个就行了

01:14:30.720 --> 01:14:32.620
以后用哪个字去看一下

01:14:32.620 --> 01:14:34.320
这个文档文档给你写得很清楚了

01:14:34.820 --> 01:14:36.320
那么如果说你这样子写是可以的

01:14:37.320 --> 01:14:38.720
没同学说这个是谁写的是啥

01:14:38.720 --> 01:14:39.520
是不是一个对象啊

01:14:39.520 --> 01:14:40.120
不是

01:14:40.320 --> 01:14:41.320
他不是一个对象

01:14:42.020 --> 01:14:42.720
对一个对象

01:14:42.720 --> 01:14:43.720
因为我知道有些同学呢

01:14:43.720 --> 01:14:44.320
学到ESU

01:14:44.320 --> 01:14:45.520
但是没有学到很扎实

01:14:45.620 --> 01:14:46.520
他不是一个对象啊

01:14:46.520 --> 01:14:47.820
这是一个语法

01:14:48.320 --> 01:14:49.520
他就是这么个语法

01:14:49.720 --> 01:14:51.120
没有为什么他就这样规定的

01:14:51.320 --> 01:14:52.520
一用一个方块号一扩

01:14:52.620 --> 01:14:53.420
一扩起来

01:14:53.820 --> 01:14:55.020
他就知道了哦

01:14:55.220 --> 01:14:56.120
你要干嘛呀

01:14:56.220 --> 01:14:58.120
你是要把他的值

01:14:58.920 --> 01:15:02.620
导出同时把这个标识服的名字

01:15:02.620 --> 01:15:04.420
作为导出的名字

01:15:05.320 --> 01:15:06.120
那么导出是怎么来

01:15:06.120 --> 01:15:07.120
导出就是A

01:15:07.120 --> 01:15:07.720
懂没啥

01:15:09.120 --> 01:15:10.420
他是个新的语法

01:15:11.120 --> 01:15:12.720
那么这名字能不能改呢

01:15:12.720 --> 01:15:13.520
可以改啊

01:15:13.920 --> 01:15:15.720
你看对象语法还可以这样的写吗

01:15:15.720 --> 01:15:16.520
不能这样的写吧

01:15:16.820 --> 01:15:18.220
那么相当于是导出的是什么

01:15:18.420 --> 01:15:19.620
我只用他的纸

01:15:19.620 --> 01:15:20.820
但是不用他的名字

01:15:20.820 --> 01:15:22.420
名字我改一下改成碳布

01:15:22.520 --> 01:15:23.920
他居民导出导出的是这个

01:15:24.820 --> 01:15:25.320
看没

01:15:25.520 --> 01:15:26.420
反正一大堆啊

01:15:26.420 --> 01:15:26.920
还有

01:15:27.120 --> 01:15:28.320
那么现在是默认导出

01:15:28.320 --> 01:15:30.120
默认导出的话是不需要名字的

01:15:30.720 --> 01:15:32.120
你看一下默认导出需要名字吗

01:15:32.120 --> 01:15:33.920
他的名字固定为default

01:15:34.020 --> 01:15:34.820
他不需要名字

01:15:34.820 --> 01:15:36.020
所以导出三可以啊

01:15:36.020 --> 01:15:36.620
没问题

01:15:36.620 --> 01:15:38.320
那么就相当于是default等于三

01:15:38.620 --> 01:15:39.820
那么导出一个方式

01:15:39.820 --> 01:15:40.520
没问题啊

01:15:40.520 --> 01:15:42.020
而且让你default等于一个方式

01:15:42.420 --> 01:15:42.920
对不对

01:15:43.020 --> 01:15:44.120
也可以用这种写法

01:15:44.120 --> 01:15:45.420
反正语法非常非常多

01:15:45.420 --> 01:15:46.420
你不要去记啊

01:15:46.920 --> 01:15:47.720
不要去记

01:15:48.220 --> 01:15:50.020
我这用文化话不知拥有多少年了

01:15:50.020 --> 01:15:51.620
也要让我自己默写出来

01:15:51.620 --> 01:15:52.320
我写不出来

01:15:53.520 --> 01:15:54.220
当时你这片子

01:15:54.220 --> 01:15:55.120
那不可能写不出来

01:15:55.620 --> 01:15:56.420
有什么个意思

01:15:56.420 --> 01:15:57.220
不要去记啊

01:15:58.320 --> 01:15:59.420
导出方式

01:16:00.720 --> 01:16:01.720
这一方没问题吧

01:16:02.820 --> 01:16:03.420
没问题啊

01:16:04.020 --> 01:16:04.920
对一个位置

01:16:05.820 --> 01:16:06.720
没问题 Q&A

01:16:09.400 --> 01:16:10.500
我想把导出说了

01:16:14.520 --> 01:16:15.520
你们做开发的

01:16:16.020 --> 01:16:17.120
在学习的过程中啊

01:16:17.120 --> 01:16:18.920
很多东西都不要去背的啊

01:16:18.920 --> 01:16:20.320
特别像这种API

01:16:20.620 --> 01:16:21.820
就是具体怎么用

01:16:21.820 --> 01:16:22.620
你不要去背

01:16:24.120 --> 01:16:25.820
原理你是一定要知道的

01:16:25.820 --> 01:16:26.920
你一定要彻底底下的

01:16:26.920 --> 01:16:27.520
他也不是背

01:16:27.520 --> 01:16:28.320
要理解

01:16:28.720 --> 01:16:30.320
但是头脑里面反复的去想

01:16:31.620 --> 01:16:32.520
导入呢

01:16:32.620 --> 01:16:34.020
我这比较导出了一个玩意啊

01:16:34.020 --> 01:16:35.020
比方说导出了

01:16:35.420 --> 01:16:36.420
就这么一个玩意吧

01:16:36.620 --> 01:16:37.520
导出一个

01:16:38.220 --> 01:16:39.020
就这样写吧

01:16:39.120 --> 01:16:39.820
写简单一点

01:16:40.820 --> 01:16:42.120
哇A等于3

01:16:42.620 --> 01:16:44.320
啊然后再一个export

01:16:44.320 --> 01:16:45.820
哇B等于4

01:16:47.620 --> 01:16:49.220
然后再export B4

01:16:49.320 --> 01:16:50.320
导出个默认的

01:16:50.520 --> 01:16:51.420
导出个RY

01:16:51.820 --> 01:16:52.420
导出个3

01:16:52.420 --> 01:16:53.120
导出一个5

01:16:54.720 --> 01:16:56.420
比方说就这么导出了

01:16:57.820 --> 01:16:59.120
啊我们点另外一个模块吧

01:16:59.620 --> 01:17:00.420
A点T也是

01:17:03.420 --> 01:17:03.720
啊

01:17:04.220 --> 01:17:05.120
好像这么导出了

01:17:05.620 --> 01:17:06.720
那么这边要导入

01:17:07.620 --> 01:17:09.020
对吧导入怎么导入呢

01:17:10.220 --> 01:17:11.620
不能不能用require啊

01:17:11.620 --> 01:17:12.720
就require不存在了啊

01:17:13.220 --> 01:17:15.820
那么他要用新的语法就是import

01:17:18.120 --> 01:17:19.720
刚才不是导出了一个对象吗

01:17:20.120 --> 01:17:21.420
我们把它写一下啊

01:17:21.820 --> 01:17:23.320
导出刚才导出的是咋玩意

01:17:23.320 --> 01:17:24.520
导出的是这么一个东西

01:17:27.840 --> 01:17:29.340
这个变迁真的说太好用了

01:17:30.140 --> 01:17:31.140
讲课太好用了

01:17:32.910 --> 01:17:34.010
A等于3

01:17:35.010 --> 01:17:36.010
B等于4

01:17:36.410 --> 01:17:37.910
然后一个什么default

01:17:38.210 --> 01:17:39.010
等于5

01:17:39.510 --> 01:17:39.910
对不对

01:17:39.910 --> 01:17:40.910
这是他导出的东西

01:17:40.910 --> 01:17:41.910
现在我们要把它导入

01:17:42.350 --> 01:17:43.810
那么导入的时候呢

01:17:44.910 --> 01:17:46.710
我们要用关键字import

01:17:47.710 --> 01:17:49.810
如果说你要导入所有的东西

01:17:50.010 --> 01:17:51.010
就写个型号

01:17:52.110 --> 01:17:54.910
然后用个二字关键字给它定个名字

01:17:55.410 --> 01:17:56.210
随便一个名字

01:17:56.210 --> 01:17:57.410
一个名字就是一个变量名

01:17:57.410 --> 01:17:58.410
一个标识符的名字

01:17:58.410 --> 01:17:59.010
随便说嘛

01:17:59.010 --> 01:18:00.210
随便什么名字都可以

01:18:01.010 --> 01:18:01.410
哦

01:18:01.810 --> 01:18:03.210
然后关键字服装

01:18:03.210 --> 01:18:04.410
你看是语法啊

01:18:04.410 --> 01:18:05.610
它不但是API了

01:18:07.710 --> 01:18:09.910
同样的调邪杠调邪杠开头

01:18:10.410 --> 01:18:11.710
然后是A点解释

01:18:11.710 --> 01:18:12.510
注意邀请权啊

01:18:12.510 --> 01:18:13.910
这里不能省略调解释啊

01:18:13.910 --> 01:18:15.710
在浏览器环境里边是不能省略的

01:18:16.710 --> 01:18:18.710
以后你们学到构建融剧过后

01:18:18.710 --> 01:18:19.610
什么在微拍啊

01:18:19.610 --> 01:18:21.010
这些东西里边是可以省略的啊

01:18:21.010 --> 01:18:22.010
在这里边不能省略

01:18:22.810 --> 01:18:23.410
写全

01:18:24.010 --> 01:18:25.010
这就全部导入了

01:18:25.510 --> 01:18:27.310
整个对象放到了O里边

01:18:28.110 --> 01:18:29.110
我们输出一下O

01:18:29.510 --> 01:18:30.210
看一下啊

01:18:30.210 --> 01:18:31.210
我们页面引用了什么

01:18:31.210 --> 01:18:32.410
引用了IN这个设计的解释

01:18:32.410 --> 01:18:33.810
IN这个设计的解释引用了什么

01:18:33.810 --> 01:18:34.910
引用了A点解释

01:18:35.510 --> 01:18:36.210
好看一下

01:18:39.270 --> 01:18:39.770
控制3

01:18:42.070 --> 01:18:42.570
是不是

01:18:42.570 --> 01:18:43.870
整个对象里边有A

01:18:43.870 --> 01:18:44.470
3

01:18:44.670 --> 01:18:45.070
B

01:18:45.070 --> 01:18:45.470
4

01:18:45.470 --> 01:18:45.870
D4

01:18:45.870 --> 01:18:46.270
是什么

01:18:46.270 --> 01:18:46.670
5

01:18:47.170 --> 01:18:48.270
后边不用看了啊

01:18:49.170 --> 01:18:50.370
就他就这么个对象

01:18:50.370 --> 01:18:51.470
那就全部导入

01:18:51.470 --> 01:18:53.370
但他还有很多方式了啊

01:18:54.070 --> 01:18:54.870
导入的时候呢

01:18:54.870 --> 01:18:56.070
比较多你直向导入

01:18:56.070 --> 01:18:57.670
那种居民导出的东西

01:18:57.670 --> 01:18:58.570
就带名字的东西

01:18:58.570 --> 01:18:59.370
那么很简单

01:19:00.370 --> 01:19:00.970
你看一下

01:19:01.370 --> 01:19:02.170
我这里导入

01:19:02.770 --> 01:19:03.570
不要导入A

01:19:03.570 --> 01:19:04.670
我就导入A

01:19:04.770 --> 01:19:05.670
那么我看一下A

01:19:06.870 --> 01:19:08.370
那边就把强度也是把A

01:19:08.370 --> 01:19:09.170
这个等于3

01:19:09.170 --> 01:19:09.870
放到这里边了啊

01:19:09.870 --> 01:19:11.070
名字一定要对应上

01:19:11.270 --> 01:19:11.970
这里边名字

01:19:11.970 --> 01:19:12.970
名字一定要对应上

01:19:12.970 --> 01:19:13.570
是不是3

01:19:14.270 --> 01:19:14.770
对不对

01:19:15.470 --> 01:19:16.070
B

01:19:17.270 --> 01:19:18.070
导入两个吧

01:19:18.070 --> 01:19:18.670
A

01:19:18.670 --> 01:19:19.670
都好B

01:19:21.610 --> 01:19:22.710
这也输出一下啊

01:19:22.710 --> 01:19:23.410
也都好B

01:19:23.410 --> 01:19:24.510
分开啊

01:19:24.510 --> 01:19:26.510
就导入这两个3和4

01:19:27.310 --> 01:19:27.510
哎

01:19:27.510 --> 01:19:29.010
那我要导入默认的怎么办呢

01:19:29.010 --> 01:19:30.510
默认的你可以直接写到外边

01:19:30.710 --> 01:19:30.910
啊

01:19:30.910 --> 01:19:32.010
你可以直接写到外边

01:19:32.810 --> 01:19:34.980
都好啊

01:19:34.980 --> 01:19:35.580
D吧

01:19:38.160 --> 01:19:38.960
哎哦这里

01:19:38.960 --> 01:19:40.160
不那些都好啊

01:19:40.560 --> 01:19:41.760
哦应该写前边

01:19:42.160 --> 01:19:43.060
你看我都忘了

01:19:43.060 --> 01:19:43.360
对对对

01:19:43.360 --> 01:19:44.360
你们还寄他干嘛

01:19:44.360 --> 01:19:45.360
你看我都忘了

01:19:46.160 --> 01:19:48.460
哈哈同时同时导入的时候

01:19:48.560 --> 01:19:49.260
同时导入

01:19:49.260 --> 01:19:50.760
这个的写前面都好啊

01:19:51.160 --> 01:19:51.860
写前面都好

01:19:52.260 --> 01:19:52.860
得这么写

01:19:53.160 --> 01:19:53.660
对不对

01:19:53.660 --> 01:19:55.860
那么相当于是把默认导入的东西

01:19:55.860 --> 01:19:57.160
导出的东西放到这个边

01:19:57.160 --> 01:19:58.060
标识服

01:19:58.160 --> 01:19:58.860
地里边

01:20:00.060 --> 01:20:00.560
你看

01:20:01.660 --> 01:20:02.460
说35

01:20:02.760 --> 01:20:03.060
对不对

01:20:03.060 --> 01:20:04.160
他那个名字随便取啊

01:20:04.160 --> 01:20:05.360
这这里边不能随便取

01:20:05.560 --> 01:20:08.360
默认导入的导入的时候是随便取的

01:20:08.660 --> 01:20:08.960
对不对

01:20:08.960 --> 01:20:11.360
当然还有很多的导入方式你可以自己去看

01:20:11.760 --> 01:20:13.260
啊包括这种这种啊

01:20:13.260 --> 01:20:14.060
不导入任何东西

01:20:14.060 --> 01:20:15.560
就是把一个模块执行一遍

01:20:15.960 --> 01:20:16.460
也可以啊

01:20:16.460 --> 01:20:17.260
有很多的方式啊

01:20:17.260 --> 01:20:18.260
想让大家可以自己去看

01:20:18.260 --> 01:20:19.760
诸师给大家写的非常详细的

01:20:20.760 --> 01:20:21.460
看关键点

01:20:24.560 --> 01:20:25.760
他有什么不一样的地方

01:20:27.920 --> 01:20:29.320
es6.9呢

01:20:29.320 --> 01:20:32.720
他采用的是预家的模式叫静态依赖的模式

01:20:33.920 --> 01:20:37.020
所有的导入代码会提升到代码顶部

01:20:37.920 --> 01:20:38.520
啥意思

01:20:42.740 --> 01:20:43.740
我们输出这个a

01:20:45.140 --> 01:20:46.840
按理说是不能输出的

01:20:47.040 --> 01:20:48.640
因为我这个时候没有导入啊

01:20:48.740 --> 01:20:49.240
对不对

01:20:49.240 --> 01:20:51.040
你要运行的导入过后才有a吗

01:20:51.140 --> 01:20:52.140
你看能不能输出

01:20:53.740 --> 01:20:54.440
输出3

01:20:54.840 --> 01:20:55.340
对不对

01:20:56.140 --> 01:20:56.740
那为什么

01:20:56.740 --> 01:20:57.840
因为他真正执行的时候

01:20:57.840 --> 01:20:58.840
他跑到上面去

01:20:59.640 --> 01:21:01.140
而且不建议大家

01:21:01.540 --> 01:21:02.440
把这个玩意

01:21:02.640 --> 01:21:05.040
写到其他语句的后边不建议

01:21:05.040 --> 01:21:06.040
这是不规范的

01:21:06.740 --> 01:21:09.340
导入语句一定要取到最上边

01:21:09.840 --> 01:21:11.640
以这个模块里边有哪些依赖

01:21:11.640 --> 01:21:12.740
一定要取到最上边

01:21:12.840 --> 01:21:14.340
因为你不写他要给你处理

01:21:14.340 --> 01:21:15.740
何必让麻烦他处理呢

01:21:15.740 --> 01:21:16.640
不要让他处理

01:21:16.740 --> 01:21:18.240
不要他导入别的解释啊

01:21:18.640 --> 01:21:20.040
解释要导入什么东西

01:21:20.140 --> 01:21:21.540
然后只导入一个默认的

01:21:21.940 --> 01:21:22.340
对不对

01:21:22.940 --> 01:21:24.040
这东西很常见吧

01:21:24.640 --> 01:21:25.040
啊

01:21:25.040 --> 01:21:26.840
那么你就写到全部取到最上边

01:21:27.640 --> 01:21:28.240
为什么

01:21:29.140 --> 01:21:30.140
他为什么要这样做

01:21:30.740 --> 01:21:32.440
而且他是不允许的写到什么

01:21:32.440 --> 01:21:33.240
判断里边的

01:21:33.240 --> 01:21:33.640
对吧

01:21:33.740 --> 01:21:34.740
比较说的这样的写

01:21:35.140 --> 01:21:36.640
他直接就报语法错误了

01:21:38.580 --> 01:21:40.080
你想你想这样的写不行的

01:21:43.170 --> 01:21:44.070
他直接语法说了

01:21:44.070 --> 01:21:44.770
他都不认识的

01:21:44.770 --> 01:21:45.870
完全不知道你在干嘛了

01:21:46.170 --> 01:21:46.870
他不允许的

01:21:46.870 --> 01:21:48.170
什么循环里边

01:21:48.170 --> 01:21:49.370
判断里边都不要写

01:21:49.370 --> 01:21:50.470
他一定在最上边

01:21:51.270 --> 01:21:52.570
所有代码执行之前

01:21:52.670 --> 01:21:53.270
为什么

01:21:53.570 --> 01:21:54.770
因为他是静态的

01:21:55.570 --> 01:21:58.870
他一定要先分析依赖关系再指教

01:21:58.970 --> 01:22:00.170
跟那个漏的环境的

01:22:00.170 --> 01:22:01.670
common介石就完全不一样

01:22:02.270 --> 01:22:04.170
common介石可以放到循环的

01:22:04.170 --> 01:22:05.070
可以放到判断的

01:22:05.070 --> 01:22:05.670
为什么呢

01:22:05.770 --> 01:22:07.970
因为他是在运行过程中

01:22:08.370 --> 01:22:09.470
确定依赖的

01:22:09.670 --> 01:22:11.670
他是运行到了这一句话

01:22:11.870 --> 01:22:12.370
哦

01:22:12.370 --> 01:22:14.070
我再去把这个夹带进来

01:22:15.270 --> 01:22:15.570
好

01:22:15.570 --> 01:22:16.670
然后运行A

01:22:16.670 --> 01:22:18.570
A里边运行到了这一句话

01:22:19.070 --> 01:22:19.270
哦

01:22:19.270 --> 01:22:20.570
我又去把B夹带进来

01:22:21.470 --> 01:22:22.070
原来是吧

01:22:22.070 --> 01:22:24.270
他是在运行中去确定依赖关系的

01:22:24.270 --> 01:22:25.470
而E也是不一样

01:22:25.770 --> 01:22:27.370
他是进入他依赖关系

01:22:27.470 --> 01:22:30.170
他是在最开始运行之前就要确认

01:22:30.270 --> 01:22:31.570
他运行之前咋确认呢

01:22:31.570 --> 01:22:32.970
你看你页面上引用的是什么

01:22:32.970 --> 01:22:34.470
引用的是应带的设计介石吧

01:22:34.470 --> 01:22:35.770
他就把前进行读出来

01:22:36.170 --> 01:22:37.270
看有哪些鸡蛋

01:22:38.070 --> 01:22:39.670
我先运都不预协后边带嘛

01:22:40.170 --> 01:22:41.670
然后先把这鸡带全部夹带鸡带

01:22:41.670 --> 01:22:43.770
看一下A把A下载下来

01:22:43.970 --> 01:22:45.070
看一下A又没有别的鸡带了

01:22:45.070 --> 01:22:45.570
A

01:22:45.770 --> 01:22:46.770
A里边移带了什么

01:22:46.770 --> 01:22:47.570
移带了B

01:22:47.670 --> 01:22:48.070
对吧

01:22:48.170 --> 01:22:48.370
好

01:22:48.370 --> 01:22:49.470
他就把B下载下来

01:22:49.470 --> 01:22:50.270
又看一下B

01:22:50.470 --> 01:22:53.870
他把所有的要移带的模块全部夹带进来过后

01:22:54.470 --> 01:22:55.870
再来进行运行

01:22:56.470 --> 01:22:57.670
他是这么一种模式

01:22:57.670 --> 01:22:58.970
所以你不能放到判断里边

01:22:58.970 --> 01:23:02.970
因为他没方法运行的过程中去确定这个鸡带关系

01:23:02.970 --> 01:23:04.270
他的最开始确定的

01:23:05.070 --> 01:23:06.870
不能把他放到判断循环里边

01:23:06.970 --> 01:23:09.170
第三个是导入内容是放到常量里边的

01:23:09.170 --> 01:23:09.870
是不能更改的

01:23:09.870 --> 01:23:11.170
这里边还有很多细节

01:23:11.170 --> 01:23:12.370
我可能没有时间讲了

01:23:13.070 --> 01:23:14.270
因为模块是一个课程

01:23:14.270 --> 01:23:15.270
大家理解一下

01:23:15.470 --> 01:23:17.070
我现在今天只有一个半小时

01:23:17.470 --> 01:23:20.570
我在想课的时候讲了七八节课

01:23:22.570 --> 01:23:23.170
就是什么意思呢

01:23:23.170 --> 01:23:24.370
这个A是不能改的

01:23:24.370 --> 01:23:25.170
就这个意思

01:23:25.170 --> 01:23:26.370
你去改一下他试一下

01:23:26.370 --> 01:23:27.270
再说出一下A

01:23:28.170 --> 01:23:28.870
他告诉你

01:23:29.470 --> 01:23:32.670
assignment to constant variable

01:23:34.370 --> 01:23:37.170
你在尝试给一个常量负责

01:23:37.170 --> 01:23:37.970
这么要常量

01:23:38.770 --> 01:23:40.370
就是永远不可能变得亮

01:23:40.870 --> 01:23:42.170
3.1是15926

01:23:42.170 --> 01:23:43.170
太不会变

01:23:43.170 --> 01:23:44.670
越地距离不会变

01:23:44.770 --> 01:23:45.370
对吧

01:23:45.570 --> 01:23:46.970
这些都是不会变得亮

01:23:48.470 --> 01:23:50.170
是不能给他重新负责的

01:23:50.170 --> 01:23:51.070
它是常量

01:23:52.670 --> 01:23:53.070
继续

01:23:53.070 --> 01:23:55.070
还有就是他也是使用了缓存

01:23:55.070 --> 01:23:56.670
保证了每个模块加在意思

01:23:57.670 --> 01:23:58.370
好

01:23:58.370 --> 01:23:59.570
这就是一夜时冒酒

01:24:01.170 --> 01:24:01.970
那么这两个模块

01:24:01.970 --> 01:24:02.970
发标准学了之后

01:24:02.970 --> 01:24:04.870
你就会极大的概率

01:24:04.870 --> 01:24:05.870
遇到这么一个问题

01:24:06.070 --> 01:24:06.670
对比

01:24:08.370 --> 01:24:09.170
以后遇到这种题

01:24:09.170 --> 01:24:10.070
像那种问答题

01:24:10.070 --> 01:24:11.570
就是面试的时候问答题

01:24:13.170 --> 01:24:15.070
你能够回答详尽一点

01:24:15.170 --> 01:24:16.870
就尽量回答详细一点

01:24:17.270 --> 01:24:19.270
而你能够回答的详细程度

01:24:19.970 --> 01:24:22.470
决定了你能跟面试官聊多久

01:24:22.970 --> 01:24:24.570
你能跟面试官聊多久

01:24:25.470 --> 01:24:27.670
决定了你的薪水的待遇的高低

01:24:27.670 --> 01:24:29.370
和你面试成功的机遇

01:24:29.970 --> 01:24:31.070
那么你能够

01:24:32.470 --> 01:24:33.970
聊出什么东西

01:24:33.970 --> 01:24:34.770
你能够回答

01:24:35.370 --> 01:24:37.070
怎么样才能够回答到越多

01:24:37.570 --> 01:24:38.970
取决于你的知识机内

01:24:39.770 --> 01:24:42.270
和接纳到代码的数量和你的表达能力

01:24:42.270 --> 01:24:44.170
这都是需要系统的训练的

01:24:45.370 --> 01:24:47.370
比方说我们今天就不要说别的了

01:24:47.470 --> 01:24:48.870
就是咱们今天学习了过后

01:24:48.870 --> 01:24:50.770
你能回答出一个什么样的问题

01:24:50.770 --> 01:24:52.170
这今天我下午给大家写的

01:24:52.970 --> 01:24:53.470
你对比一下

01:24:53.470 --> 01:24:55.070
那今天就我们今天的知识

01:24:55.170 --> 01:24:57.470
其实这里边还会回答出好多好多东西的

01:24:59.070 --> 01:24:59.870
那不可以怎么回答

01:24:59.870 --> 01:25:00.470
common介石

01:25:00.470 --> 01:25:01.870
首先我们要说一下common介石

01:25:01.870 --> 01:25:03.470
聊清楚把它每个点聊清楚

01:25:03.770 --> 01:25:05.270
它的标准就不一样

01:25:05.270 --> 01:25:06.670
它是个社区化标准

01:25:07.570 --> 01:25:08.170
谁在知识呢

01:25:08.170 --> 01:25:09.170
no的环境知识

01:25:09.370 --> 01:25:09.570
对吧

01:25:09.570 --> 01:25:10.970
环境标准说清楚

01:25:11.770 --> 01:25:13.470
它的特点是不产生新的语法

01:25:13.470 --> 01:25:14.370
还没有新的语法吗

01:25:14.370 --> 01:25:15.370
没有出现关键字

01:25:15.470 --> 01:25:16.970
它只是用什么require

01:25:16.970 --> 01:25:18.170
模绝一些对象

01:25:18.170 --> 01:25:18.970
一些新的函数

01:25:18.970 --> 01:25:19.470
对不对

01:25:19.470 --> 01:25:20.870
是使用API实现的

01:25:21.470 --> 01:25:22.570
它的本质是什么呢

01:25:22.770 --> 01:25:24.370
要把它

01:25:24.370 --> 01:25:25.870
要加弹的模块代码

01:25:25.870 --> 01:25:26.770
是放到一个B包

01:25:26.770 --> 01:25:28.570
终于是一个函数里边去咨询的

01:25:28.770 --> 01:25:30.570
那么这里其实你可以详细地描述

01:25:31.770 --> 01:25:32.770
是不是我们刚才的代码

01:25:33.270 --> 01:25:35.670
你可以按照你的理解给它描述得很详细

01:25:35.670 --> 01:25:35.970
对不对

01:25:35.970 --> 01:25:36.670
所以描述很多

01:25:36.670 --> 01:25:37.570
比如它一个require

01:25:37.570 --> 01:25:38.770
内部生产的require函数

01:25:38.770 --> 01:25:39.770
有五个参数

01:25:39.770 --> 01:25:40.470
一个参数是啥

01:25:40.470 --> 01:25:41.070
第二个参数是啥

01:25:41.070 --> 01:25:41.770
不啦不啦不啦

01:25:42.670 --> 01:25:43.870
怎么在处理缓存的

01:25:43.870 --> 01:25:44.170
对吧

01:25:44.670 --> 01:25:45.570
一大部分要聊清楚

01:25:45.570 --> 01:25:46.070
然后最后呢

01:25:46.070 --> 01:25:47.670
我们总结说一下

01:25:48.170 --> 01:25:48.870
因此呢

01:25:48.970 --> 01:25:50.870
no的环境中的所有的介石文件

01:25:50.870 --> 01:25:52.070
在咨询的时候

01:25:52.770 --> 01:25:53.770
no的环境里边按

01:25:54.170 --> 01:25:56.270
都是放到一个函数环境里边咨询的

01:25:56.670 --> 01:25:58.370
这就是为了什么

01:25:58.470 --> 01:25:59.970
模块内部可以访问

01:25:59.970 --> 01:26:01.070
很多函数的函数

01:26:01.070 --> 01:26:02.170
比较说opement

01:26:02.970 --> 01:26:03.970
比方说什么exports

01:26:03.970 --> 01:26:05.270
都是函数的参数

01:26:05.870 --> 01:26:06.870
是不是你这样回答

01:26:06.870 --> 01:26:08.070
就理解得很透彻了

01:26:08.070 --> 01:26:09.270
还能怎么透彻呢

01:26:10.870 --> 01:26:11.570
而且呢

01:26:11.670 --> 01:26:13.070
对Z时的指向是不是有影响

01:26:13.070 --> 01:26:13.370
对不对

01:26:13.370 --> 01:26:14.070
它Z时的指向呢

01:26:14.070 --> 01:26:15.170
因为它的函数调用的时候

01:26:15.170 --> 01:26:16.170
是用扩来调用的

01:26:16.170 --> 01:26:17.270
所以Z时的指向

01:26:17.570 --> 01:26:18.470
是有影响的

01:26:20.170 --> 01:26:21.770
核心的还有核心的一个特征

01:26:21.770 --> 01:26:23.470
就是comment介石是动态的模块

01:26:23.470 --> 01:26:23.870
还是标准

01:26:23.870 --> 01:26:24.670
什么叫动态的

01:26:24.870 --> 01:26:26.570
就是在运行的过程中

01:26:26.670 --> 01:26:28.170
才能去夹展的

01:26:28.670 --> 01:26:30.670
依赖关系是在运行过程中确定的

01:26:30.770 --> 01:26:32.870
这就意味着在导入导出模块的时候

01:26:33.070 --> 01:26:35.170
它不限制你导出在哪个位置

01:26:35.270 --> 01:26:36.170
导入在哪个位置

01:26:36.170 --> 01:26:36.870
它不限制

01:26:37.370 --> 01:26:39.170
运行的运行到了那一句话

01:26:39.170 --> 01:26:40.170
它自然就导出了

01:26:40.370 --> 01:26:41.170
运行到这一句话

01:26:41.170 --> 01:26:42.070
自然就导出了

01:26:42.970 --> 01:26:43.470
没有了

01:26:43.870 --> 01:26:44.270
好

01:26:44.370 --> 01:26:45.070
comment介石里的

01:26:45.070 --> 01:26:45.670
聊完了之后

01:26:45.670 --> 01:26:46.970
再来聊这个es module

01:26:47.570 --> 01:26:48.070
对吧

01:26:48.370 --> 01:26:49.170
那么目前呢

01:26:49.170 --> 01:26:50.570
它是漏的和卤断起军之时

01:26:50.570 --> 01:26:51.470
它是漏的环境的

01:26:51.770 --> 01:26:53.270
你们以后学会学漏的了

01:26:53.470 --> 01:26:55.170
我漏的有一些课是讲了这个东西的

01:26:55.370 --> 01:26:55.870
但是呢

01:26:56.370 --> 01:26:57.170
不怎么会用啊

01:26:58.070 --> 01:27:00.070
我们现在开发的时候

01:27:00.070 --> 01:27:01.070
不怎么会去用它

01:27:02.170 --> 01:27:03.270
它引入了新的语法

01:27:03.270 --> 01:27:04.170
因为它是官方的

01:27:04.170 --> 01:27:04.870
它厉害呗

01:27:05.970 --> 01:27:06.770
它是静态的

01:27:06.770 --> 01:27:08.470
它最大的核心区别

01:27:08.470 --> 01:27:09.270
它是静态的

01:27:09.370 --> 01:27:10.470
comment介石是动态的

01:27:11.270 --> 01:27:12.570
它是在执行之前

01:27:12.570 --> 01:27:13.770
就要确定依赖关系

01:27:13.770 --> 01:27:15.270
然后夹展所有的文件

01:27:16.070 --> 01:27:17.370
夹展完了之后再运行

01:27:17.670 --> 01:27:18.370
那么这种情况

01:27:18.370 --> 01:27:19.570
会在一些不好的地方

01:27:19.570 --> 01:27:21.670
比方说浏览器环境下面会传承多次寻求

01:27:21.670 --> 01:27:22.270
你看一下吧

01:27:23.470 --> 01:27:24.070
联系博客

01:27:24.070 --> 01:27:26.670
我们看一下网络通信点击这个介石啊

01:27:26.870 --> 01:27:27.670
刷新你看一下

01:27:27.670 --> 01:27:28.870
所以寻求了两个

01:27:28.970 --> 01:27:29.970
一个是index

01:27:30.470 --> 01:27:31.170
一个是a

01:27:31.170 --> 01:27:31.970
一个是index

01:27:31.970 --> 01:27:32.970
所以寻求了两个

01:27:33.170 --> 01:27:33.570
对吧

01:27:33.970 --> 01:27:35.670
现在大家可能还不太清楚服务器

01:27:35.670 --> 01:27:36.670
那边是怎么回事啊

01:27:36.770 --> 01:27:37.170
没关系

01:27:37.170 --> 01:27:38.970
你知道看到有两只网络的东西吗

01:27:39.970 --> 01:27:41.170
那如果说我们模块多了

01:27:41.170 --> 01:27:43.670
你看我们刚才给大家看了个五又的元代吗

01:27:43.870 --> 01:27:44.670
它的模块里边

01:27:44.670 --> 01:27:45.770
它整个工程里边

01:27:46.070 --> 01:27:47.570
就是成败上千个模块

01:27:47.770 --> 01:27:48.870
那你用这种方式

01:27:49.370 --> 01:27:50.370
是不是在点亮点亮

01:27:50.470 --> 01:27:51.770
这就是为什么我又会出现

01:27:51.770 --> 01:27:53.670
你看看你聊的事情还有很多的

01:27:53.970 --> 01:27:54.770
你可以继续聊

01:27:54.770 --> 01:27:54.870
哎

01:27:54.870 --> 01:27:56.170
这就是为什么会出现

01:27:56.170 --> 01:27:56.970
为派克呀

01:27:57.270 --> 01:27:58.070
什么高铺啊

01:27:58.070 --> 01:27:59.470
这些乱七八糟的打包工具

01:27:59.470 --> 01:27:59.670
对吧

01:27:59.670 --> 01:28:00.470
它是怎么出现的

01:28:00.470 --> 01:28:01.870
那些东西又是什么样的原理

01:28:01.970 --> 01:28:04.170
为什么在为派克里边又支持同时支持

01:28:04.170 --> 01:28:06.570
common介石和es module

01:28:07.370 --> 01:28:07.670
对不对

01:28:07.670 --> 01:28:09.270
我经常我经常听到同学说

01:28:09.470 --> 01:28:11.670
为什么我又支持common介石

01:28:11.670 --> 01:28:14.670
又支持es module

01:28:16.070 --> 01:28:17.170
有的时候我看到这种问题啊

01:28:17.170 --> 01:28:18.270
我真的是枯萧不得

01:28:18.270 --> 01:28:18.970
因为呢

01:28:19.070 --> 01:28:20.570
它这个问题本身就是有问题的

01:28:20.570 --> 01:28:21.570
我又哪支持这个

01:28:21.970 --> 01:28:22.970
我又根本就不支持

01:28:23.170 --> 01:28:24.370
是为派克的支持

01:28:24.770 --> 01:28:26.670
是那些脚头加工具在支持

01:28:27.270 --> 01:28:28.470
我又哪支持这个东西

01:28:29.370 --> 01:28:31.070
由于它使用的是静态依赖啊

01:28:31.070 --> 01:28:32.670
所以它要求导入导出的单码

01:28:32.670 --> 01:28:33.770
必须要放到顶层

01:28:33.770 --> 01:28:34.470
它不能写到判断

01:28:34.470 --> 01:28:35.570
不能写到循环里边

01:28:35.670 --> 01:28:36.170
你们理解

01:28:36.170 --> 01:28:38.670
知识一定要理解得准确啊

01:28:38.670 --> 01:28:39.370
特别重要

01:28:39.370 --> 01:28:40.970
不然的话有的时候要闹消化了

01:28:41.570 --> 01:28:42.470
只有这个时候呢

01:28:42.470 --> 01:28:43.370
只有只有这样子

01:28:43.370 --> 01:28:45.170
单码在运行前

01:28:45.870 --> 01:28:47.270
才能确定一代关系

01:28:47.670 --> 01:28:48.470
一不放到顶层

01:28:48.470 --> 01:28:49.270
一放到判断里边

01:28:49.270 --> 01:28:49.970
它都没有运行

01:28:49.970 --> 01:28:51.870
它怎么知道判断成功还是失败的

01:28:53.470 --> 01:28:53.970
而且呢

01:28:53.970 --> 01:28:54.870
它导入模型的时候

01:28:54.870 --> 01:28:55.870
会把导入的结果呢

01:28:55.870 --> 01:28:57.370
绑定到标识符里边

01:28:57.570 --> 01:28:58.470
这是个标识符

01:28:58.770 --> 01:29:00.070
有的人可能说这是解构

01:29:00.570 --> 01:29:01.070
求求你吧

01:29:01.070 --> 01:29:01.870
这不是解构

01:29:02.270 --> 01:29:03.170
不是解构啊

01:29:03.170 --> 01:29:04.070
这是标识符

01:29:04.070 --> 01:29:05.570
解构的语法跟它的都有

01:29:05.570 --> 01:29:07.170
看上去有一点相似对吧

01:29:07.270 --> 01:29:08.370
解构率学完了过后

01:29:08.370 --> 01:29:09.970
你会发现它语法有很多不同的

01:29:12.010 --> 01:29:12.810
它是不可更改的

01:29:12.810 --> 01:29:13.510
它是常量

01:29:13.810 --> 01:29:14.010
对吧

01:29:14.010 --> 01:29:15.310
它里边还有很多细节啊

01:29:15.310 --> 01:29:15.810
还有很多细节

01:29:15.810 --> 01:29:17.010
它绑定是怎么回事

01:29:17.010 --> 01:29:18.410
它就是要签到细节

01:29:18.710 --> 01:29:20.010
但是你这样回答的话

01:29:20.110 --> 01:29:21.210
80分啊

01:29:21.210 --> 01:29:22.710
你就这个体80分

01:29:22.710 --> 01:29:23.710
偷偷的拿下

01:29:27.030 --> 01:29:27.530
啊

01:29:28.530 --> 01:29:29.330
没事啊

01:29:29.330 --> 01:29:29.630
没事

01:29:29.630 --> 01:29:30.630
它是没有用vipack

01:29:30.930 --> 01:29:31.930
它用的是road app

01:29:31.930 --> 01:29:32.530
它的

01:29:33.430 --> 01:29:34.930
构建环境用的是road app

01:29:35.730 --> 01:29:36.230
那个

01:29:37.830 --> 01:29:40.530
它的开发生产环境用的是road app

01:29:40.730 --> 01:29:42.730
它的开发环境用的是那种

01:29:42.730 --> 01:29:44.230
它是基于另外一个灵感啊

01:29:44.230 --> 01:29:45.630
叫做es dev server

01:29:45.630 --> 01:29:46.830
大家听说过没有啊

01:29:46.930 --> 01:29:47.830
这个是稠远了啊

01:29:47.830 --> 01:29:48.630
这个是稠远了

01:29:49.230 --> 01:29:51.330
它是基于一个es dev server的

01:29:51.330 --> 01:29:52.430
提供了灵感啊

01:29:52.430 --> 01:29:53.530
那个原理呢

01:29:53.630 --> 01:29:55.830
就是你用在开发间的无所谓吧

01:29:55.830 --> 01:29:58.130
你开发间的浏览器下载多一点就下载多一点的

01:29:58.330 --> 01:30:00.030
开发间的反正就是本机运行

01:30:00.030 --> 01:30:00.330
对不对

01:30:00.330 --> 01:30:02.030
到到了生产上你可能不能这样子啊

01:30:04.100 --> 01:30:05.400
前端不需要

01:30:06.500 --> 01:30:08.100
这个肯定不是解构啊

01:30:08.700 --> 01:30:10.100
这个还能是解构啊

01:30:11.400 --> 01:30:11.900
兄弟

01:30:12.300 --> 01:30:13.100
这个肯定不是解构啊

01:30:13.100 --> 01:30:13.600
我也不用

01:30:20.350 --> 01:30:21.550
解构是可以这样子写的

01:30:23.650 --> 01:30:24.850
你这样子写试试一下

01:30:25.750 --> 01:30:26.550
我是要解构出来

01:30:26.550 --> 01:30:27.550
它堆箱里边的T

01:30:27.550 --> 01:30:28.650
我能写这样的写吗

01:30:28.650 --> 01:30:29.450
肯定不是解构啊

01:30:29.450 --> 01:30:30.550
它是个新语法啊

01:30:32.730 --> 01:30:35.230
前端不需要为派盒只需要依赖包啊

01:30:37.520 --> 01:30:39.020
为派盒就是为前端准备的

01:30:39.720 --> 01:30:40.820
它不是为漏的准备的

01:30:40.820 --> 01:30:42.520
它虽然漏的环境也可以用

01:30:42.520 --> 01:30:43.120
但是

01:30:43.920 --> 01:30:45.120
它不是为漏的准备的

01:30:45.120 --> 01:30:46.520
它就是因为前端

01:30:46.920 --> 01:30:48.820
它尽管有了es module

01:30:49.220 --> 01:30:51.220
仍然有很多问题没有解决

01:30:51.720 --> 01:30:52.920
所以说需要这么一个东西

01:30:55.130 --> 01:30:55.330
好

01:30:55.330 --> 01:30:57.830
这些东西你们以后学到了一个具体的技术的时候呢

01:30:58.530 --> 01:30:59.030
啊

01:30:59.130 --> 01:31:00.330
你自然就清楚了

01:31:00.430 --> 01:31:01.530
这里非常清楚了

01:31:02.930 --> 01:31:03.730
好了ok啊

01:31:03.730 --> 01:31:05.230
那咱们今天我就讲到这了

01:31:05.230 --> 01:31:06.630
我今天又又超时了

01:31:08.030 --> 01:31:08.530
啊

01:31:08.530 --> 01:31:09.030
ok啊

01:31:09.030 --> 01:31:09.930
我先去了说吧

01:31:09.930 --> 01:31:11.030
朋友们拜拜明天见

