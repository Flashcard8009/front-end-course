WEBVTT

00:00.110 --> 00:02.110
今天讲啥呢

00:02.110 --> 00:05.110
今天讲这个时间

00:05.110 --> 00:08.110
一个第三方库叫做moment

00:08.110 --> 00:11.110
要讲清楚这个第三方库呢

00:11.110 --> 00:13.110
有一个非常重要的一个知识

00:13.110 --> 00:16.110
就是关于程序里边的时间的知识

00:16.110 --> 00:18.110
我可能担心有些同学

00:18.110 --> 00:20.110
这一块知识是基础知识

00:20.110 --> 00:22.110
可能担心有些同学呢

00:22.110 --> 00:25.110
我也不知道你们在哪里去写的基础

00:25.110 --> 00:28.110
就有可能导致了基础层次不及

00:28.110 --> 00:30.110
说这里还是我们把它总结一下

00:30.110 --> 00:32.110
如果说你这一块没问题

00:32.110 --> 00:33.110
那么ok

00:33.110 --> 00:34.110
你就当副席了

00:34.110 --> 00:36.110
如果说这一块有问题

00:36.110 --> 00:37.110
就注意着听

00:37.110 --> 00:40.680
或者说以前没有接触过这一块

00:40.680 --> 00:42.680
这一块的知识呢

00:42.680 --> 00:45.680
跟具体的语言倒还没有什么关系

00:45.680 --> 00:47.680
你像你们集合学什么加瓦呀

00:47.680 --> 00:48.680
谁拍摄啊

00:48.680 --> 00:50.680
学任何计算机语言

00:50.680 --> 00:53.680
他们这一块的知识都是相通的

00:53.680 --> 00:55.680
我们首先看一下

00:55.680 --> 00:57.680
在我们的编程里边

00:57.680 --> 01:00.680
这一块它一般有哪些单位

01:00.680 --> 01:01.680
一个说

01:01.680 --> 01:03.680
这个东西不用解释吧

01:03.680 --> 01:05.680
一个小时一天等于二十四个小时

01:05.680 --> 01:07.680
一个小时等于六十分钟

01:07.680 --> 01:08.680
一分钟等于六十秒

01:08.680 --> 01:10.680
那么接下来是ms

01:10.680 --> 01:12.680
毫秒mediate second

01:12.680 --> 01:13.680
一秒钟等于一千毫秒

01:13.680 --> 01:15.680
然后接下来是纳秒

01:15.680 --> 01:18.680
一毫秒了等于一千纳秒

01:18.680 --> 01:19.680
纳秒这个单位呢

01:19.680 --> 01:23.680
我们平时呢也不怎么会用到

01:23.680 --> 01:25.680
纳秒就是一

01:25.680 --> 01:27.680
说是计算机能够处理的

01:27.680 --> 01:28.680
能够识别的

01:28.680 --> 01:29.680
就普通计算机

01:29.680 --> 01:31.680
一般家用计算机和服务器

01:31.680 --> 01:33.680
能够识别的最小单位的

01:33.680 --> 01:34.680
一般来说

01:34.680 --> 01:37.680
一大秒的时间很短的

01:37.680 --> 01:41.680
一纳秒光只能跑3米

01:41.680 --> 01:43.680
30公分

01:43.680 --> 01:46.680
然后呢一个cpu

01:46.680 --> 01:48.680
运行一条指令

01:48.680 --> 01:50.680
比方说java

01:50.680 --> 01:53.680
那么这个时候然后经过

01:53.680 --> 01:55.680
各位数纳秒的时间

01:55.680 --> 01:57.680
那就看有些cpu快一点

01:57.680 --> 01:58.680
可能就一纳秒

01:58.680 --> 01:59.680
有些cpu慢一点的

01:59.680 --> 02:00.680
可能就两纳秒

02:00.680 --> 02:01.680
而且同样的cpu

02:01.680 --> 02:04.680
在不同的状况下

02:04.680 --> 02:06.680
它可能是运行的时间不一样

02:06.680 --> 02:08.680
纳秒是一个非常非常小的单位

02:08.680 --> 02:09.680
那么在往下呢

02:09.680 --> 02:11.680
其实还有

02:11.680 --> 02:12.680
还有什么皮妙

02:12.680 --> 02:13.680
那些单位

02:13.680 --> 02:14.680
我们就不考虑了

02:14.680 --> 02:15.680
那些东西是跟那个

02:15.680 --> 02:16.680
科研相关的吧

02:16.680 --> 02:17.680
我们就不考虑了

02:17.680 --> 02:19.680
我们最小的一条纳秒

02:19.680 --> 02:21.680
而像我们编程的时候呢

02:21.680 --> 02:22.680
一般来说

02:22.680 --> 02:23.680
不管纳秒

02:23.680 --> 02:24.680
一般来说

02:24.680 --> 02:26.680
我们精确的纳秒就ok了

02:26.680 --> 02:28.680
这是一个基本单位

02:28.680 --> 02:29.680
先聊一下

02:29.680 --> 02:30.680
那么接下来是两个概念

02:30.680 --> 02:32.680
一个是gmt

02:32.680 --> 02:33.680
一个是utc

02:33.680 --> 02:37.680
两个非常非常重要的概念

02:37.680 --> 02:38.680
什么叫gmt呢

02:38.680 --> 02:40.680
为什么要出现这两个东西呢

02:40.680 --> 02:43.680
它是因为我们各地的时间啊

02:43.680 --> 02:45.680
是不一样的

02:45.680 --> 02:46.680
说实话

02:46.680 --> 02:48.680
我们各地的时间是一样的

02:48.680 --> 02:49.680
就是我现在在这里

02:49.680 --> 02:50.680
给你们讲课

02:50.680 --> 02:51.680
我现在在哪呢

02:51.680 --> 02:52.680
我在成都啊

02:52.680 --> 02:54.680
也使用的是东巴区的时间

02:54.680 --> 02:55.680
对吧

02:55.680 --> 02:57.680
全球化分为24个市区

02:57.680 --> 03:00.680
我这个史识此刻

03:00.680 --> 03:04.680
跟目前的纽约市的史识此刻

03:04.680 --> 03:06.680
是一样的

03:06.680 --> 03:08.680
我们都生活在这个地球上

03:08.680 --> 03:11.680
都共同的在经历这个时间的流逝

03:11.680 --> 03:13.680
我说的这个史识此刻

03:13.680 --> 03:15.680
和目前伦敦那个人

03:15.680 --> 03:16.680
有同样一个人

03:16.680 --> 03:17.680
比方同样一个老师

03:17.680 --> 03:18.680
也在授课

03:18.680 --> 03:19.680
他说的那个史识此刻

03:19.680 --> 03:20.680
两个人说的时间点

03:20.680 --> 03:23.680
是完全一样的

03:23.680 --> 03:26.680
但是写出来就不一样了

03:26.680 --> 03:27.680
尽管两个时间点

03:27.680 --> 03:28.680
是完全一样的

03:28.680 --> 03:29.680
写出来不一样了

03:29.680 --> 03:31.680
比方说我现在是

03:31.680 --> 03:33.680
晚上8点11分

03:33.680 --> 03:35.680
是我的史识此刻

03:35.680 --> 03:36.680
他的史识此刻呢

03:36.680 --> 03:37.680
跟我是一样的

03:37.680 --> 03:40.680
但是他可能就是

03:40.680 --> 03:41.680
比方说早上

03:41.680 --> 03:44.680
早上凌晨两点钟

03:44.680 --> 03:45.680
所以有这个可能

03:45.680 --> 03:46.680
对吧

03:46.680 --> 03:47.680
尽管都是同一时刻

03:47.680 --> 03:50.680
它是表现出来的东西

03:50.680 --> 03:52.680
不一样了

03:52.680 --> 03:53.680
那么怎么办呢

03:53.680 --> 03:54.680
怎么来解决这个问题呢

03:54.680 --> 03:56.680
如果说咱们计算机里边

03:56.680 --> 03:57.680
不管

03:57.680 --> 03:59.680
而我们的程序

03:59.680 --> 04:01.680
是不是要跟不确定的人使用

04:01.680 --> 04:02.680
你写的程序

04:02.680 --> 04:05.680
可能是中国的要用

04:05.680 --> 04:06.680
然后其他国家也在用

04:06.680 --> 04:08.680
那么是不是会导致问题

04:08.680 --> 04:09.680
对不对

04:09.680 --> 04:11.680
所以说我们在计算机里边

04:11.680 --> 04:12.680
就不能出现那种

04:12.680 --> 04:14.680
差异性的表示方式

04:14.680 --> 04:15.680
都表示同一个时刻

04:15.680 --> 04:18.680
你用这种方式来表示

04:18.680 --> 04:19.680
另外一个呢

04:19.680 --> 04:20.680
用另外一种方式来表示

04:20.680 --> 04:22.680
我就必须要把它统一起来

04:22.680 --> 04:23.680
于是呢

04:23.680 --> 04:24.680
就多出来一些概念啊

04:24.680 --> 04:25.680
一个是GMT

04:25.680 --> 04:26.680
当然这两个概念

04:26.680 --> 04:27.680
不是根据计算机出来的

04:27.680 --> 04:29.680
它不是计算机搞出来的

04:29.680 --> 04:30.680
是原本就有的

04:30.680 --> 04:32.680
只不过我们计算机里边呢

04:32.680 --> 04:33.680
用到了这些概念

04:33.680 --> 04:34.680
一个GMT

04:34.680 --> 04:35.680
叫做隔离微制时间

04:35.680 --> 04:36.680
隔离微制呢

04:36.680 --> 04:39.680
是英国的一个市

04:39.680 --> 04:40.680
本出值互线

04:40.680 --> 04:42.680
会划过它

04:42.680 --> 04:43.680
它的哪个时区呢

04:43.680 --> 04:45.680
就是零时区

04:45.680 --> 04:46.680
隔离微制时间呢

04:46.680 --> 04:48.680
其实就是一个时区的时间

04:48.680 --> 04:50.680
就是零时区的时间

04:50.680 --> 04:51.680
它也叫做太阳

04:51.680 --> 04:52.680
它是用的是太阳时

04:52.680 --> 04:53.680
什么叫太阳时呢

04:53.680 --> 04:56.680
就是根据地球自专

04:56.680 --> 04:57.680
和太阳

04:57.680 --> 04:58.680
就是地球公传

04:58.680 --> 04:59.680
自专和公传

04:59.680 --> 05:01.680
来确定时间

05:01.680 --> 05:02.680
我怎么知道

05:02.680 --> 05:03.680
现在是十二点了

05:03.680 --> 05:04.680
我是根据这个地球

05:04.680 --> 05:07.680
和自专和太阳公传

05:07.680 --> 05:09.680
通过一些方式来算出来的

05:09.680 --> 05:10.680
叫太阳时

05:10.680 --> 05:12.680
能够精确到好秒

05:12.680 --> 05:13.680
但是后来呢

05:13.680 --> 05:14.680
发现用这种计时呢

05:14.680 --> 05:15.680
用这种东西

05:15.680 --> 05:17.680
来统一全球的时间呢

05:17.680 --> 05:18.680
好像呢

05:18.680 --> 05:19.680
又没有那么精确了

05:19.680 --> 05:21.680
因为它有误差

05:21.680 --> 05:22.680
误差呢

05:22.680 --> 05:24.680
其实也不大

05:24.680 --> 05:25.680
我现在记不清楚了

05:25.680 --> 05:29.680
好像是过

05:29.680 --> 05:30.680
过一万年

05:30.680 --> 05:31.680
会有一秒钟

05:31.680 --> 05:32.680
好像是

05:32.680 --> 05:33.680
我记不清

05:33.680 --> 05:34.680
很清楚了

05:34.680 --> 05:35.680
大家可以去查一查

05:35.680 --> 05:36.680
是有误差的

05:36.680 --> 05:37.680
那么这个误差呢

05:37.680 --> 05:38.680
一般来说是

05:38.680 --> 05:39.680
没有什么影响

05:39.680 --> 05:40.680
但是呢

05:40.680 --> 05:42.680
遇到一些科研项目的时候

05:42.680 --> 05:44.680
它对精度要求非常非常高

05:44.680 --> 05:46.680
可能高到疲倦

05:46.680 --> 05:47.680
那么那个时候呢

05:47.680 --> 05:49.680
这个误差就难以忍受了

05:49.680 --> 05:50.680
于是呢

05:50.680 --> 05:52.680
后来就搞出了这么一个东西

05:52.680 --> 05:53.680
叫做UTC

05:53.680 --> 05:55.680
世界协调师

05:55.680 --> 05:56.680
这个玩意呢

05:56.680 --> 05:58.680
它就跟时趋完全没有关系了

05:58.680 --> 06:00.680
它跟时趋完全没有关系了

06:00.680 --> 06:02.680
它是一个原子中

06:02.680 --> 06:03.680
然后具体的东西

06:03.680 --> 06:04.680
我也不要问我

06:04.680 --> 06:05.680
我也不知道

06:05.680 --> 06:06.680
什么原理不知道

06:06.680 --> 06:07.680
它是用原子时间

06:07.680 --> 06:08.680
为技术的标准

06:08.680 --> 06:10.680
它跟地球的自钻

06:10.680 --> 06:11.680
和地球的弓钻

06:11.680 --> 06:12.680
没有直接关系

06:12.680 --> 06:14.680
它用原子来计时

06:14.680 --> 06:15.680
非常非常的精确

06:15.680 --> 06:17.680
它能精确到辣秒

06:17.680 --> 06:18.680
这个玩意呢

06:18.680 --> 06:19.680
好像要过50万年

06:19.680 --> 06:21.680
才有疫苗的误差

06:21.680 --> 06:22.680
那么这个就是

06:22.680 --> 06:24.680
我们目前最精准的计时

06:24.680 --> 06:26.680
就是UTC计时

06:26.680 --> 06:27.680
所以有了UTC之后呢

06:27.680 --> 06:29.680
这个TMT这种计时

06:29.680 --> 06:30.680
统一计时的方式呢

06:30.680 --> 06:32.680
就基本上不再使用了

06:32.680 --> 06:33.680
我们程序里边呢

06:33.680 --> 06:35.680
有的时候会看到这个字母

06:35.680 --> 06:36.680
叫GMT

06:36.680 --> 06:37.680
会看到这个字母

06:37.680 --> 06:38.680
比方说给它看一下

06:40.680 --> 06:41.680
这边有点简单

06:41.680 --> 06:42.680
给它

06:42.680 --> 06:44.680
你们都学过那个日期对象

06:44.680 --> 06:48.720
对吧

06:48.720 --> 06:49.720
D

06:49.720 --> 06:51.720
DV一个带子

06:51.720 --> 06:52.720
创建的日期对象

06:52.720 --> 06:54.720
日期对象里每个方法

06:54.720 --> 06:56.720
叫2GMT

06:56.720 --> 06:58.720
把当前的日期呢

06:58.720 --> 07:00.720
转换成GMT时间

07:00.720 --> 07:02.720
这个是个GMT时间

07:02.720 --> 07:03.720
那么这个GMT时间

07:03.720 --> 07:04.720
什么格式呢

07:04.720 --> 07:05.720
就是星期一

07:05.720 --> 07:06.720
星期五

07:06.720 --> 07:07.720
28号

07:07.720 --> 07:09.720
就是月份的缩写

07:09.720 --> 07:11.720
就是8月28号

07:11.720 --> 07:12.720
星期五

07:12.720 --> 07:13.720
2020年

07:13.720 --> 07:15.720
12点14分

07:15.720 --> 07:16.720
54

07:16.720 --> 07:17.720
来表示此时此刻

07:17.720 --> 07:19.720
也就是此时此刻

07:19.720 --> 07:21.720
在英国的隔离位置

07:21.720 --> 07:22.720
是12点

07:22.720 --> 07:23.720
中午12点

07:23.720 --> 07:24.720
后面写个GMT

07:24.720 --> 07:26.720
一样的意思吧

07:26.720 --> 07:27.720
这是GMT时间

07:27.720 --> 07:28.720
那么另外一个呢

07:28.720 --> 07:29.720
就是

07:30.720 --> 07:32.720
UTC时间

07:32.720 --> 07:33.720
UTC时间

07:33.720 --> 07:34.720
你会发现这两个

07:34.720 --> 07:36.720
字母上是完全一样的

07:36.720 --> 07:37.720
为什么呢

07:37.720 --> 07:38.720
就是

07:38.720 --> 07:39.720
以前啊

07:39.720 --> 07:40.720
它是这么一个浏览

07:40.720 --> 07:41.720
以前

07:41.720 --> 07:43.720
没有UTC的时候

07:43.720 --> 07:45.720
全球要统一时间

07:45.720 --> 07:46.720
比如你说一个时间

07:46.720 --> 07:47.720
我说一个时间

07:47.720 --> 07:48.720
我们两个时间的

07:48.720 --> 07:49.720
哪个在前哪个在后

07:49.720 --> 07:50.720
我们是不是要把它

07:50.720 --> 07:51.720
转换成统一个时趋

07:51.720 --> 07:52.720
才能比较

07:52.720 --> 07:53.720
对吧

07:53.720 --> 07:54.720
比方说我

07:54.720 --> 07:55.720
就一个例子

07:56.720 --> 07:57.720
比方说

07:57.720 --> 07:59.720
现在的隔离位置

07:59.720 --> 08:01.720
隔离位置时间

08:01.720 --> 08:03.720
是2020年

08:03.720 --> 08:05.720
8月28号

08:05.720 --> 08:06.720
零点

08:06.720 --> 08:07.720
比方说啊

08:07.720 --> 08:09.720
它有一个时间是零点

08:09.720 --> 08:10.720
那么我现在呢

08:10.720 --> 08:12.720
是在那个北京

08:12.720 --> 08:14.720
北京时间

08:14.720 --> 08:16.720
2020年

08:16.720 --> 08:18.720
8月28号

08:18.720 --> 08:20.720
8点钟

08:20.720 --> 08:21.720
那么请问

08:21.720 --> 08:22.720
哪个时间在前

08:22.720 --> 08:23.720
哪个时间在后

08:23.720 --> 08:26.860
这两个时间

08:26.860 --> 08:27.860
哪个时间在前

08:27.860 --> 08:31.560
哪个时间在后啊

08:31.560 --> 08:33.560
北京是东巴区

08:33.560 --> 08:38.730
东巴区

08:38.730 --> 08:39.730
哪个时间在前

08:39.730 --> 08:40.730
哪个时间在后呢

08:40.730 --> 08:41.730
什么叫前后啊

08:41.730 --> 08:42.730
就是哪个大哪个小

08:42.730 --> 08:43.730
什么叫哪个大

08:43.730 --> 08:44.730
哪个时间就靠后

08:44.730 --> 08:45.730
就是还没来

08:45.730 --> 08:47.730
比方说我现在是12点钟

08:47.730 --> 08:48.730
那么另外一个时间

08:48.730 --> 08:49.730
是14点钟

08:49.730 --> 08:51.730
14点就比12点大

08:51.730 --> 08:52.730
你还类似吧

08:52.730 --> 08:53.730
这是时间的大小

08:53.730 --> 08:54.730
那么哪个大

08:54.730 --> 08:55.730
哪个大呢

08:55.730 --> 08:57.730
实际上他们是一样的

08:57.730 --> 08:58.730
为什么呢

08:58.730 --> 08:59.730
你们比较时间的时候

08:59.730 --> 09:01.730
不能通过文本去比较

09:01.730 --> 09:02.730
是不能通过文本去比较

09:02.730 --> 09:04.730
因为他们时趋都不一样

09:04.730 --> 09:05.730
隔离位置是什么时趋

09:05.730 --> 09:07.730
是零时趋

09:07.730 --> 09:08.730
什么时趋都不一样

09:08.730 --> 09:09.730
时趋不一样的话

09:09.730 --> 09:11.730
你没法比较啊

09:11.730 --> 09:12.730
比方说你现在

09:12.730 --> 09:14.730
北京时间是8点钟

09:14.730 --> 09:16.730
那我把它换成零时趋的话

09:16.730 --> 09:18.730
换成隔离位置时间

09:18.730 --> 09:20.730
它就是28号零点

09:20.730 --> 09:22.730
所以你必须要把它换成

09:22.730 --> 09:24.730
同一时趋你才能够比较大小

09:24.730 --> 09:26.730
不再同一时趋就不能比较

09:26.730 --> 09:28.730
那么问题就来了

09:28.730 --> 09:30.730
那我换成哪个时趋呢

09:30.730 --> 09:31.730
那到底换成北京时间

09:31.730 --> 09:33.730
还是换成隔离位置时间呢

09:33.730 --> 09:34.730
你说换成北京时间

09:34.730 --> 09:35.730
那美国人也不干了

09:35.730 --> 09:36.730
美国人说

09:36.730 --> 09:38.730
那我为什么不换成纽约时间呢

09:38.730 --> 09:39.730
美国有好几个时趋

09:39.730 --> 09:40.730
不像咱们中国

09:40.730 --> 09:41.730
咱们中国只有一个时趋

09:41.730 --> 09:43.730
整个中国统一使用

09:43.730 --> 09:44.730
统一时间

09:44.730 --> 09:46.730
美国它是有时差的

09:46.730 --> 09:50.730
东岸和西汉的时间都不一样的

09:50.730 --> 09:52.730
一个国家有好几个时趋

09:52.730 --> 09:53.730
用纽约时间还是用什么

09:53.730 --> 09:55.730
还是用那个洛杉矶时间呢

09:55.730 --> 09:57.730
搞不清楚了

09:57.730 --> 09:58.730
就公说公有礼

09:58.730 --> 09:59.730
婆说婆有礼

09:59.730 --> 10:00.730
那么这个时候就没办法了

10:00.730 --> 10:01.730
那怎么办呢

10:01.730 --> 10:03.730
大家都用零时趋

10:03.730 --> 10:04.730
隔离位置

10:04.730 --> 10:05.730
大约东西要问了

10:05.730 --> 10:07.730
凭什么隔离位置就是零时趋

10:07.730 --> 10:10.730
凭什么北京不是零时趋呢

10:11.730 --> 10:13.730
这个东西没有科学道理

10:13.730 --> 10:15.730
就是人为规定的

10:15.730 --> 10:17.730
就是人为规定的

10:17.730 --> 10:19.730
这种计时方式

10:19.730 --> 10:21.730
最先在英国被发明

10:21.730 --> 10:23.730
他们就把自己搞了个零时趋

10:23.730 --> 10:25.730
因此我们要比较时间

10:25.730 --> 10:26.730
就必须要有一个

10:26.730 --> 10:28.730
统一的时趋来比较

10:28.730 --> 10:31.730
那么以前在UTC出来之前

10:31.730 --> 10:32.730
我们用的是什么呢

10:32.730 --> 10:34.730
用的是隔离位置时间

10:34.730 --> 10:36.730
就凡是我们世界上

10:36.730 --> 10:37.730
要处理时间

10:37.730 --> 10:38.730
要比较时间

10:38.730 --> 10:39.730
要对时间做处理

10:39.730 --> 10:41.730
都要先转换成隔离位置时间

10:41.730 --> 10:43.730
然后再进一步处理

10:43.730 --> 10:44.730
后来呢

10:44.730 --> 10:45.730
发现不需要了

10:45.730 --> 10:47.730
我们有了原子时

10:47.730 --> 10:49.730
这东西更加精确

10:49.730 --> 10:50.730
所以说现在的就用UTC

10:50.730 --> 10:52.730
来表示时间了

10:52.730 --> 10:53.730
UTC还是以隔离位置

10:53.730 --> 10:55.730
当地的时间为准

10:55.730 --> 10:56.730
不过它的计时方式

10:56.730 --> 10:58.730
就不是用自转和公转了

10:58.730 --> 11:00.730
是用原子及时了

11:00.730 --> 11:01.730
明儿的意思吧

11:01.730 --> 11:02.730
所以说现在的UTC

11:02.730 --> 11:04.730
就替代了GNT

11:04.730 --> 11:07.730
但是我们在书写习惯上

11:07.730 --> 11:09.730
还是习惯于书写

11:09.730 --> 11:11.730
GNT的这种方式

11:11.730 --> 11:13.730
因此你这里看到的

11:13.730 --> 11:14.730
UTC String

11:14.730 --> 11:16.730
还是用的是GNT的格式

11:16.730 --> 11:18.730
但是你要知道

11:18.730 --> 11:20.730
它本质的计时

11:20.730 --> 11:22.730
已经不再是用GNT的那种太阳

11:22.730 --> 11:23.730
太阳时了

11:23.730 --> 11:26.730
其实这东西就是一个概念的区别

11:26.730 --> 11:28.730
就过去了隔离位置

11:28.730 --> 11:29.730
它用的是什么吗

11:29.730 --> 11:30.730
计时方式呢

11:30.730 --> 11:31.730
用自转和公转来计时

11:31.730 --> 11:32.730
现在用什么呢

11:32.730 --> 11:34.730
用那个原子计时了

11:34.730 --> 11:36.730
它就把之前的T代掉了

11:36.730 --> 11:38.730
因此你现在无论是使用它

11:38.730 --> 11:39.730
还是使用它

11:39.730 --> 11:41.730
最终使用的都是

11:41.730 --> 11:43.730
原子计时

11:43.730 --> 11:44.730
只不过得到的时间

11:44.730 --> 11:46.730
格式还是

11:46.730 --> 11:48.730
沿用了习惯的原来的格式

11:48.730 --> 11:49.730
我这一块

11:49.730 --> 11:50.730
我不知道能不能解释清楚

11:50.730 --> 11:52.730
能不能理解这一块

11:52.730 --> 11:54.730
就是以前它用自转和公转来计时

11:54.730 --> 11:56.730
但是现在没有用了

11:56.730 --> 11:59.730
已经把它转换成用原子计时了

11:59.730 --> 12:01.730
但是书写的格式还是一样的

12:01.730 --> 12:03.730
所以说这里能用UTC和GNT

12:03.730 --> 12:05.730
得到的结果是完全一样的

12:05.730 --> 12:06.730
如果习惯上的

12:06.730 --> 12:09.730
还用GNT这种格式来书写而已

12:09.730 --> 12:10.730
能听懂吗

12:10.730 --> 12:16.770
听懂了QAE啊

12:16.770 --> 12:18.770
为什么老师还有文化20名编辖

12:18.770 --> 12:19.770
因为为了你们啊

12:19.770 --> 12:20.770
为了你们看得懂我

12:20.770 --> 12:24.720
因为毕竟还有很多同学

12:24.720 --> 12:26.720
没有学过ESU

12:26.720 --> 12:27.720
老师的时候

12:27.720 --> 12:29.720
你不能光考虑自己写的爽不爽

12:29.720 --> 12:30.720
好 这里把这个人

12:30.720 --> 12:31.720
赶点搞清楚

12:31.720 --> 12:33.720
这是GNT和UTC的

12:33.720 --> 12:34.720
格式基本都是这样子

12:34.720 --> 12:36.720
都是用GNT的方式

12:36.720 --> 12:37.720
另外呢

12:37.720 --> 12:38.720
给大家说一下

12:38.720 --> 12:39.720
顺便提一个

12:39.720 --> 12:41.720
日期的书写其实格式非常非常多

12:41.720 --> 12:42.720
不同的国家

12:42.720 --> 12:44.720
有不同的国家的书写方式

12:44.720 --> 12:45.720
书写习惯

12:45.720 --> 12:47.720
那么我们能不能统一的

12:47.720 --> 12:49.720
用一种习惯来书写呢

12:49.720 --> 12:50.720
后来ISO

12:50.720 --> 12:51.720
就是国际标准组织呢

12:51.720 --> 12:52.720
就搞了一个标准出来

12:52.720 --> 12:55.720
编号尾8601

12:55.720 --> 12:57.720
这个标准就规定全球啊

12:57.720 --> 12:59.720
如果说

12:59.720 --> 13:01.720
你书写的日期

13:01.720 --> 13:03.720
要跟别人的日期呢

13:03.720 --> 13:04.720
要保持格式一致的话

13:04.720 --> 13:07.720
我就统一一种格式来书写

13:07.720 --> 13:08.720
用什么格式呢

13:08.720 --> 13:11.720
用这种格式

13:11.720 --> 13:13.720
连月日

13:13.720 --> 13:14.720
中间加一个字母T

13:14.720 --> 13:16.720
小时分钟秒

13:16.720 --> 13:17.720
后边是毫秒

13:17.720 --> 13:19.720
后边加个字母Z

13:19.720 --> 13:20.720
这是

13:20.720 --> 13:22.720
连月日

13:22.720 --> 13:23.720
小时分钟秒

13:23.720 --> 13:24.720
后边是毫秒

13:24.720 --> 13:26.720
它就是提供了一个统一标准

13:26.720 --> 13:27.720
因此呢

13:27.720 --> 13:28.720
你在电视对象里边呢

13:28.720 --> 13:29.720
你可以看到这个

13:29.720 --> 13:32.720
叫做2ISO

13:32.720 --> 13:35.720
它只是日期的不同格式而已

13:35.720 --> 13:36.720
是不完全一样的

13:36.720 --> 13:37.720
顺便说一下

13:37.720 --> 13:38.720
这个ISO标准里边

13:38.720 --> 13:39.720
它的书写日期

13:39.720 --> 13:42.720
仍然是使用格林位置时间

13:42.720 --> 13:43.720
也就是UTC

13:43.720 --> 13:44.720
也就是GNT

13:44.720 --> 13:45.720
你可以认为他们都是一样的

13:45.720 --> 13:47.720
只是书写格式不一样而已

13:47.720 --> 13:49.720
都是使用的是临时区的时间

13:49.720 --> 13:51.720
以后你说到什么

13:51.720 --> 13:53.720
ISO8601

13:53.720 --> 13:54.720
或者是UTC和GNT

13:54.720 --> 13:57.720
他们指的时间完全一样

13:57.720 --> 13:58.720
只不过呢

13:58.720 --> 14:00.720
书写的格式不一样

14:00.720 --> 14:01.720
这两个书写格式呢

14:01.720 --> 14:03.720
是这种

14:03.720 --> 14:04.720
这个书写格式呢

14:04.720 --> 14:05.720
是这种

14:05.720 --> 14:06.720
时间都是同样的时间

14:06.720 --> 14:09.720
表示的方格式不一样

14:09.720 --> 14:10.720
把这两个说清楚

14:10.720 --> 14:11.720
接下来再看下一个概念

14:11.720 --> 14:14.720
Ulicus是时间初

14:14.720 --> 14:16.720
这个东西是计算机里边搞出来的

14:16.720 --> 14:18.720
以前计算机出现之前就没有了

14:18.720 --> 14:20.720
这前面两个计算机出现就有了

14:20.720 --> 14:23.720
那么这个东西是计算机出现之后出来的

14:23.720 --> 14:25.720
这个玩意是什么呢

14:25.720 --> 14:26.720
它指的是

14:26.720 --> 14:28.720
当时有一个Ulicus系统

14:28.720 --> 14:31.720
是在1969年发布的

14:31.720 --> 14:33.720
在开始立项开发

14:33.720 --> 14:35.720
到1971年发布

14:35.720 --> 14:37.720
那么1971年发布在发布之前

14:37.720 --> 14:38.720
1970年干嘛呢

14:38.720 --> 14:39.720
在编写它的代码

14:39.720 --> 14:41.720
那么它里边要计时

14:41.720 --> 14:43.720
它里边计时它的时间怎么表示呢

14:43.720 --> 14:44.720
它在想啊

14:44.720 --> 14:46.720
如果说我用这个制服圈来表示的话

14:46.720 --> 14:49.720
就会很浪费计算机的空间

14:49.720 --> 14:50.720
因为那个时候呢

14:50.720 --> 14:52.720
计算机的内存很小很小

14:52.720 --> 14:54.720
可能1kb都没有

14:54.720 --> 14:57.720
那么如果说我们就要尽量减少

14:57.720 --> 14:58.720
它的内存占用

14:58.720 --> 15:00.720
你说如果说你用制服圈来记录的话

15:00.720 --> 15:02.720
就会很占用内存

15:02.720 --> 15:03.720
为什么呢

15:03.720 --> 15:04.720
因为一个制服就是个编码

15:04.720 --> 15:05.720
一个编码呢

15:05.720 --> 15:07.720
就算是阿斯可马吧

15:07.720 --> 15:10.720
阿斯可马也不得占一个字节嘛

15:10.720 --> 15:11.720
对不对

15:11.720 --> 15:12.720
一个编码就是一个字节

15:12.720 --> 15:14.720
一个字节是不是8位

15:14.720 --> 15:16.720
你看一下这个东西有多少位

15:16.720 --> 15:17.720
是不是有很多位了

15:17.720 --> 15:18.720
占用很多位的内存

15:18.720 --> 15:21.720
它觉得这个太浪费空间了

15:21.720 --> 15:22.720
于是呢

15:22.720 --> 15:24.720
它又提出来一个概念啊

15:24.720 --> 15:26.720
就是我用一个数字能不能表示时间呢

15:26.720 --> 15:28.720
就一个很长的数字

15:28.720 --> 15:29.720
于是它又提出来

15:29.720 --> 15:31.720
我用UTC时间

15:31.720 --> 15:35.720
1970年1月1日凌晨

15:35.720 --> 15:37.720
把它作为歧视时间

15:37.720 --> 15:40.720
到指定时间经过的好秒数

15:40.720 --> 15:41.720
经过的秒数

15:41.720 --> 15:43.720
我就认为是一个时间

15:43.720 --> 15:44.720
比方说

15:44.720 --> 15:46.720
我用一个E来表示

15:46.720 --> 15:47.720
表示时间

15:47.720 --> 15:48.720
表示什么呢

15:48.720 --> 15:50.720
就表示的是

15:50.720 --> 15:56.720
1970年1月1号0.0分1秒

15:56.720 --> 15:58.720
就相对于这个时间

15:58.720 --> 15:59.720
过了1秒

15:59.720 --> 16:00.720
对呀

16:00.720 --> 16:02.720
我说的是UTC时间

16:02.720 --> 16:04.720
说的是UTC时间

16:04.720 --> 16:05.720
没了意思吧

16:05.720 --> 16:06.720
那如果说我用-1呢

16:06.720 --> 16:07.720
-1代表示的话

16:07.720 --> 16:09.720
就表示的是

16:09.720 --> 16:13.720
1969年12月31号

16:13.720 --> 16:15.720
22点

16:15.720 --> 16:18.720
23点59分

16:18.720 --> 16:19.720
59秒

16:19.720 --> 16:20.720
没了意思吧

16:20.720 --> 16:21.720
这就是U的时间戳

16:21.720 --> 16:22.720
那么它就可以用一个

16:22.720 --> 16:25.720
很小的内存占用

16:25.720 --> 16:28.720
就可以表示一个完整的时间了

16:28.720 --> 16:29.720
但是后两个计算机的内存

16:29.720 --> 16:31.720
越来越大的

16:31.720 --> 16:33.720
发现的利用表来表示

16:33.720 --> 16:35.720
根本就不精准

16:35.720 --> 16:36.720
而且现在的遮点内存占用

16:36.720 --> 16:38.720
已经完全不是这了

16:38.720 --> 16:39.720
因此目前

16:39.720 --> 16:41.720
几乎是所有的语言里面

16:41.720 --> 16:43.720
使用时间戳的时候呢

16:43.720 --> 16:45.720
都用的是好秒数

16:45.720 --> 16:48.720
就是从1970年1月1号凌晨

16:48.720 --> 16:49.720
到一个指定的时间

16:49.720 --> 16:51.720
经过的好秒数来表示

16:51.720 --> 16:53.720
叫U的时间戳

16:53.720 --> 16:54.720
那么为了区分呢

16:54.720 --> 16:56.720
我们通常习惯上

16:56.720 --> 16:58.720
我们说时间戳

16:58.720 --> 17:00.720
那么就说的是好秒数

17:00.720 --> 17:02.720
说U那个是时间戳

17:02.720 --> 17:04.720
我们就说的是秒数

17:04.720 --> 17:07.720
习惯上这么去区分一下

17:07.720 --> 17:08.720
没了意思

17:08.720 --> 17:11.720
这里是关于这个时间戳

17:11.720 --> 17:12.720
那么无论是

17:12.720 --> 17:14.720
那么现在多了一个了

17:14.720 --> 17:15.720
无论是时间戳

17:15.720 --> 17:16.720
还是GNT

17:16.720 --> 17:17.720
还是UTC

17:17.720 --> 17:18.720
还是ISO 80

17:18.720 --> 17:19.720
8601

17:19.720 --> 17:22.720
它们都是零时区的时间

17:22.720 --> 17:24.720
都是相对于零时区的

17:24.720 --> 17:25.720
这是这个

17:25.720 --> 17:26.720
好 既然那么看

17:26.720 --> 17:28.720
跟我们程序相关的

17:28.720 --> 17:31.720
我们在开发程序的时候

17:31.720 --> 17:33.720
会遇到很多的时间处理

17:33.720 --> 17:35.720
比方说文章的发布日期

17:35.720 --> 17:36.720
比方说我们的生日啊

17:36.720 --> 17:37.720
注册的时候

17:37.720 --> 17:38.720
要填写用户的生日啊

17:38.720 --> 17:39.720
等等等等

17:39.720 --> 17:42.720
有很多的时间处理

17:42.720 --> 17:43.720
现在我就不清楚

17:43.720 --> 17:44.720
同学们到底有没有

17:44.720 --> 17:45.720
这块知识

17:45.720 --> 17:46.720
我就把讲了

17:46.720 --> 17:47.720
我们在处理时间的时候

17:47.720 --> 17:49.720
会怎么来处理呢

17:49.720 --> 17:50.720
因为我们的程序

17:50.720 --> 17:51.720
可能是有

17:51.720 --> 17:52.720
比方说英国人在用

17:52.720 --> 17:53.720
美国人也在用

17:53.720 --> 17:54.720
咱们国内的用户

17:54.720 --> 17:55.720
在用

17:55.720 --> 17:56.720
有很多的差异 对吧

17:56.720 --> 17:57.720
那么这些差异

17:57.720 --> 17:58.720
我们要把汇集型来

17:58.720 --> 17:59.720
保存到服务器上

17:59.720 --> 18:00.720
尽管你们现在

18:00.720 --> 18:01.720
还没有学过服务器

18:01.720 --> 18:02.720
将来我们在

18:02.720 --> 18:03.720
讲服务器的时候

18:03.720 --> 18:04.720
就会讲到那个

18:04.720 --> 18:05.720
时间的处理

18:05.720 --> 18:07.720
服务器再怎么去完成

18:07.720 --> 18:08.720
那么我们服务器

18:08.720 --> 18:09.720
如何来处理不同的

18:09.720 --> 18:13.720
不同的差异的时间呢

18:13.720 --> 18:14.720
好 看着

18:14.720 --> 18:17.720
我们程序对时间的计算

18:17.720 --> 18:19.720
什么叫计算

18:19.720 --> 18:21.720
我在某一个时间上

18:21.720 --> 18:22.720
加一天

18:22.720 --> 18:23.720
这叫计算

18:23.720 --> 18:24.720
注意听哦

18:24.720 --> 18:25.720
我在某一个时间上

18:25.720 --> 18:26.720
加一天

18:26.720 --> 18:27.720
加一个小时

18:27.720 --> 18:28.720
减一个小时

18:28.720 --> 18:29.720
这叫计算

18:29.720 --> 18:31.720
我把某一个时间的连

18:31.720 --> 18:32.720
设成某一个连

18:32.720 --> 18:34.720
这叫计算

18:34.720 --> 18:35.720
程序里边的

18:35.720 --> 18:36.720
还有就是

18:36.720 --> 18:38.720
时间之与时间之间的比较

18:38.720 --> 18:40.720
这个时间和那个时间

18:40.720 --> 18:41.720
哪个大

18:41.720 --> 18:42.720
哪个在前哪个在后

18:42.720 --> 18:43.720
是不是进行比较

18:43.720 --> 18:44.720
是吧

18:44.720 --> 18:45.720
那么这也是

18:45.720 --> 18:46.720
时间的计算

18:46.720 --> 18:48.720
所有对时间的计算

18:48.720 --> 18:50.720
第二个存储

18:50.720 --> 18:51.720
怎么样存储

18:51.720 --> 18:52.720
比方说用户注册

18:52.720 --> 18:53.720
注册的信息是不是到服务器上

18:53.720 --> 18:55.720
服务器要把它存储下来

18:55.720 --> 18:56.720
要把它存下来

18:56.720 --> 18:57.720
那有的人说

18:57.720 --> 18:58.720
我要学前端

18:58.720 --> 18:59.720
我要知道这些东西吗

18:59.720 --> 19:00.720
你要知道

19:00.720 --> 19:01.720
你不知道这些东西

19:01.720 --> 19:02.720
你很难在公司里

19:02.720 --> 19:05.720
跟那个后端开放里面偷偷

19:05.720 --> 19:06.720
几乎以前没有要求

19:06.720 --> 19:07.720
现在现在的前端呢

19:07.720 --> 19:10.720
特别是一线程式

19:10.720 --> 19:11.720
基本上都有要求

19:11.720 --> 19:12.720
硬性要求

19:12.720 --> 19:13.720
你必须要知道后端

19:13.720 --> 19:14.720
那么知道的方式

19:14.720 --> 19:16.720
就是你要学新楼的

19:16.720 --> 19:17.720
那么现在呢

19:17.720 --> 19:18.720
就存储

19:18.720 --> 19:19.720
把时间存下来

19:19.720 --> 19:20.720
存到哪儿呢

19:20.720 --> 19:21.720
存到数据户

19:21.720 --> 19:23.720
程序对时间的计算也好

19:23.720 --> 19:24.720
存的也好

19:24.720 --> 19:27.720
一定要使用UTC时间

19:27.720 --> 19:29.720
或者时间戳也可以

19:29.720 --> 19:30.720
时间戳呢

19:30.720 --> 19:31.720
它本身也是零时区嘛

19:31.720 --> 19:32.720
对吧

19:32.720 --> 19:34.720
总之你要使用零时区的

19:34.720 --> 19:35.720
你绝对不能使用什么

19:35.720 --> 19:37.720
本地时间

19:37.720 --> 19:39.720
比方说你做了一个程序

19:39.720 --> 19:40.720
做了一个程序呢

19:40.720 --> 19:41.720
现在呢

19:41.720 --> 19:42.720
用户注册

19:42.720 --> 19:43.720
用户注册填写的时间

19:43.720 --> 19:44.720
我问你啊

19:44.720 --> 19:46.720
我就问你一个问题

19:46.720 --> 19:51.270
用户的

19:51.270 --> 19:52.270
让人填写生日

19:52.270 --> 19:54.270
用户填的生日是什么呢

19:54.270 --> 19:56.270
1970年

19:56.270 --> 19:59.270
1月1号

19:59.270 --> 20:01.270
零点

20:01.270 --> 20:02.270
生日的话

20:02.270 --> 20:03.270
10分秒

20:03.270 --> 20:04.270
一般都是零点

20:04.270 --> 20:06.270
一般都不会让它填10分秒

20:06.270 --> 20:08.270
这是用户的生日

20:08.270 --> 20:09.270
你存的时候

20:09.270 --> 20:10.270
要存哪个时间

20:10.270 --> 20:16.020
存的时候要存哪个时间

20:16.020 --> 20:18.020
一把时间给我打出来

20:18.020 --> 20:26.350
存的时候

20:26.350 --> 20:27.350
我就写两个时间嘛

20:27.350 --> 20:28.350
你们来选

20:28.350 --> 20:29.350
第一个存的时间

20:29.350 --> 20:30.350
是这个

20:30.350 --> 20:31.350
你存起来

20:31.350 --> 20:32.350
要存到数据户里边

20:32.350 --> 20:33.350
竟然你们

20:33.350 --> 20:34.350
警网里面现在没有数据户

20:34.350 --> 20:36.350
刚刚刚刚还给大家讲了

20:36.350 --> 20:38.350
第二个时间

20:38.350 --> 20:49.980
是时间

20:49.980 --> 20:51.980
是时间8对多少

20:51.980 --> 20:52.980
是

20:53.980 --> 20:55.980
A还是B

20:55.980 --> 20:58.420
A还是B

20:58.420 --> 20:59.420
是不是B

20:59.420 --> 21:00.420
对吧

21:00.420 --> 21:01.420
刚才说了

21:01.420 --> 21:02.420
存的时候呢

21:02.420 --> 21:04.420
一定要存UTC时间

21:05.420 --> 21:06.420
他们两个

21:06.420 --> 21:07.420
他们两个是不是同一个时间

21:07.420 --> 21:08.420
再问一下

21:08.420 --> 21:10.420
他们两个是不是同一个时间

21:10.420 --> 21:12.420
一个是北京时间

21:14.420 --> 21:15.420
UTC

21:15.420 --> 21:17.420
他们两个是不是同一个时间

21:17.420 --> 21:20.250
是不是

21:20.250 --> 21:21.250
肯定是同一个时间

21:21.250 --> 21:22.250
对吧

21:22.250 --> 21:23.250
只是表现出来

21:23.250 --> 21:24.250
是在不同的时区

21:24.250 --> 21:26.250
他们是同一个时刻

21:26.250 --> 21:28.250
同一个时刻

21:28.250 --> 21:30.250
这一块容易绕运

21:30.250 --> 21:31.250
因为你第一次

21:31.250 --> 21:32.250
在程序里面接触时间

21:32.250 --> 21:33.250
这些概念的时候

21:33.250 --> 21:34.250
特别容易绕运

21:34.250 --> 21:36.250
我给大家慢慢的讲

21:36.250 --> 21:37.250
那么现在

21:37.250 --> 21:38.250
既然是同一个时刻

21:38.250 --> 21:39.250
那无所谓吧

21:39.250 --> 21:40.250
对吧

21:40.250 --> 21:41.250
统一存一个

21:41.250 --> 21:42.250
存哪个呢

21:42.250 --> 21:44.250
我们统一存UTC时间

21:44.250 --> 21:45.250
这样子呢

21:45.250 --> 21:46.250
不管是你的用户

21:46.250 --> 21:47.250
是在中国

21:47.250 --> 21:49.250
还是全世界任何一个国家

21:49.250 --> 21:50.250
我们都记录了时间

21:50.250 --> 21:52.250
都是同一个零时区的时间

21:52.250 --> 21:53.250
时间是统一的

21:53.250 --> 21:54.250
这样子呢

21:54.250 --> 21:55.250
比较容易要把一些时间

21:55.250 --> 21:56.250
拿出来计算

21:56.250 --> 21:57.250
才不至于出问题

21:57.250 --> 21:58.250
不然的话你一会

21:58.250 --> 22:00.250
程序里面存一个北京时间

22:00.250 --> 22:01.250
一会存一个

22:01.250 --> 22:02.250
什么隔离微制时间

22:02.250 --> 22:03.250
你程序里面都不知道

22:03.250 --> 22:04.250
这个时间是哪个

22:04.250 --> 22:05.250
哪个时区的

22:05.250 --> 22:06.250
这个时间是哪个时区的

22:06.250 --> 22:07.250
搞不清楚了

22:07.250 --> 22:08.250
那么到时候

22:08.250 --> 22:09.250
就运算的时候

22:09.250 --> 22:10.250
一定会出问题

22:10.250 --> 22:11.250
就会混乱

22:11.250 --> 22:12.250
所以我们一定要用

22:12.250 --> 22:13.250
一个零时区的时间

22:13.250 --> 22:14.250
当你用时间说

22:14.250 --> 22:16.250
也完全没问题

22:16.250 --> 22:17.250
然后呢

22:17.250 --> 22:18.250
但是这些东西

22:18.250 --> 22:19.250
不能给用户看一下

22:19.250 --> 22:20.250
用户明明天的是

22:20.250 --> 22:22.250
我的生日是1970年

22:22.250 --> 22:23.250
1月1号

22:23.250 --> 22:24.250
结果呢

22:24.250 --> 22:25.250
你注册完了过

22:25.250 --> 22:26.250
你给我显示的生日

22:26.250 --> 22:27.250
是1965年

22:27.250 --> 22:28.250
那是不是

22:28.250 --> 22:29.250
生日不一样

22:29.250 --> 22:30.250
肯定不行

22:30.250 --> 22:31.250
因此呢

22:31.250 --> 22:32.250
我们在跟用户交互的时候

22:32.250 --> 22:35.250
在显示给用户看的时候

22:35.250 --> 22:37.250
再重新把零时区的时间

22:37.250 --> 22:40.250
转换成本地时间

22:40.250 --> 22:41.250
什么叫本地

22:41.250 --> 22:42.250
用户

22:42.250 --> 22:43.250
OK 那我就给你

22:43.250 --> 22:44.250
按中国时间来展示

22:44.250 --> 22:45.250
你在英国

22:45.250 --> 22:46.250
我就按英国的时间

22:46.250 --> 22:47.250
来展示

22:47.250 --> 22:48.250
所以说

22:48.250 --> 22:50.250
它整个的逻辑图在这

22:50.250 --> 22:52.250
我们有个系统注册

22:52.250 --> 22:53.250
生日呢

22:53.250 --> 22:54.250
英国的一个用户

22:54.250 --> 22:57.250
填的是2000年1月1号

22:57.250 --> 22:58.250
然后呢

22:58.250 --> 23:00.250
我存的是一个时间出

23:00.250 --> 23:02.250
一个时间出一个数字

23:02.250 --> 23:03.250
然后展示给

23:03.250 --> 23:05.250
这个英国用户看的时候呢

23:05.250 --> 23:07.250
我就把它转换成

23:07.250 --> 23:08.250
零时区

23:08.250 --> 23:09.250
转换的零时区

23:09.250 --> 23:10.250
直接远不弄得出来

23:10.250 --> 23:11.250
2000年1月1号

23:11.250 --> 23:12.250
然后呢

23:12.250 --> 23:13.250
另外一个中国用户

23:13.250 --> 23:14.250
也在用我们的系统

23:14.250 --> 23:15.250
它也在注册

23:15.250 --> 23:16.250
它的生日呢

23:16.250 --> 23:18.250
是2000年1月1号

23:18.250 --> 23:19.250
我存便再问一下

23:19.250 --> 23:20.250
这两个时间

23:20.250 --> 23:22.250
是不是一个时间

23:22.250 --> 23:23.250
这两个时间

23:23.250 --> 23:24.250
是不是一个时间

23:24.250 --> 23:28.350
这两个

23:28.350 --> 23:30.350
就不是同一个时刻了

23:30.350 --> 23:31.350
对吧

23:31.350 --> 23:32.350
他们不是同一个时刻生的

23:32.350 --> 23:33.350
啊

23:33.350 --> 23:34.350
因此他们不是同一个时间

23:34.350 --> 23:35.350
啊

23:35.350 --> 23:36.350
因此他这里得到了时间戳

23:36.350 --> 23:37.350
是不是不一样

23:37.350 --> 23:38.350
对吧

23:38.350 --> 23:39.350
我们可以看

23:39.350 --> 23:40.350
通过时间戳

23:40.350 --> 23:41.350
是不是就可以对比两个时间了

23:41.350 --> 23:42.350
这个东西是没有任何期的

23:42.350 --> 23:43.350
对不对

23:43.350 --> 23:44.350
然后呢

23:44.350 --> 23:45.350
但是呢

23:45.350 --> 23:46.350
我不能

23:46.350 --> 23:47.350
其实这个点的

23:47.350 --> 23:48.350
应该是在格林威治时间

23:48.350 --> 23:50.350
就是1999年12月31号

23:50.350 --> 23:51.350
对吧

23:51.350 --> 23:52.350
还没有跨越2000年

23:52.350 --> 23:54.350
但是我跟这个用户展示的时候

23:54.350 --> 23:55.350
我要把它重新换创成

23:55.350 --> 23:57.350
本地时间展示

23:57.350 --> 23:58.350
对吧

23:58.350 --> 24:00.350
这才是一个完整的流程

24:00.350 --> 24:01.350
你写的时候

24:01.350 --> 24:02.350
跟用户写的时候

24:02.350 --> 24:03.350
就让你写本地时间

24:03.350 --> 24:04.350
我给你转换成零时区

24:04.350 --> 24:05.350
然后呢

24:05.350 --> 24:06.350
给你展示的时候

24:06.350 --> 24:07.350
再给你换创成

24:07.350 --> 24:08.350
当地时间展示

24:08.350 --> 24:10.350
这是对时间的处理

24:10.350 --> 24:11.350
好

24:11.350 --> 24:12.350
为了确保大家

24:12.350 --> 24:13.350
你写的这些东西

24:13.350 --> 24:16.790
我下面有些问题

24:16.790 --> 24:17.790
一个了

24:17.790 --> 24:18.790
第一个问题

24:18.790 --> 24:19.790
用户的生日

24:19.790 --> 24:22.790
是本地时间还是UTC时间

24:22.790 --> 24:26.100
用户写生日的时候

24:26.100 --> 24:27.100
写的那个生日

24:27.100 --> 24:29.100
是本地时间还是UTC

24:29.100 --> 24:30.100
对吧

24:30.100 --> 24:31.100
是本地对不对

24:31.100 --> 24:32.100
没有哪个人

24:32.100 --> 24:35.480
去用UTC时间写生日

24:35.480 --> 24:37.480
然后第二个

24:37.480 --> 24:38.480
如果要比较

24:38.480 --> 24:39.480
两个日期的大小

24:39.480 --> 24:40.480
是比较本地时间

24:40.480 --> 24:44.880
还是比较UTC

24:44.880 --> 24:45.880
是不是UTC

24:45.880 --> 24:46.880
对吧

24:46.880 --> 24:48.880
第三个

24:48.880 --> 24:50.880
如果要显示一篇文章的

24:50.880 --> 24:51.880
发布日期

24:51.880 --> 24:53.880
是显示本地时间

24:53.880 --> 24:57.190
还是显示UTC

24:57.190 --> 24:58.190
本地

24:58.190 --> 24:59.190
凡是给用户展现出来

24:59.190 --> 25:01.190
看的都是本地

25:01.190 --> 25:02.190
没有谁愿意看到那个UTC

25:02.190 --> 25:04.190
就是UTC时间

25:04.190 --> 25:05.190
是我们程序那一步

25:05.190 --> 25:06.190
在处理时间的时候

25:06.190 --> 25:07.190
要用的

25:07.190 --> 25:09.190
跟用户的东西

25:09.190 --> 25:10.190
跟用户打交了东西

25:10.190 --> 25:11.190
全是本地

25:11.190 --> 25:12.190
比如说你上网

25:12.190 --> 25:13.190
这么多年了

25:13.190 --> 25:15.190
有这么多年网零了

25:15.190 --> 25:16.190
也没有哪个网站

25:17.190 --> 25:19.190
让你去学这个UTC概念吧

25:19.190 --> 25:20.190
不需要吧

25:20.190 --> 25:21.190
全是本地时间

25:21.190 --> 25:23.190
然后比较第四

25:23.190 --> 25:24.190
有两个时间

25:24.190 --> 25:25.190
北京时间

25:25.190 --> 25:26.190
8月28号10点

25:26.190 --> 25:28.190
和格林威治时间

25:29.190 --> 25:30.190
凌晨两点

25:30.190 --> 25:32.190
哪个大哪个小

25:32.190 --> 25:33.190
一样

25:33.190 --> 25:34.190
一样

25:34.190 --> 25:35.190
很好

25:35.190 --> 25:36.190
第五题

25:36.190 --> 25:37.190
北京的时间

25:37.190 --> 25:38.190
戳为零

25:38.190 --> 25:39.190
和格林威治的时间

25:39.190 --> 25:40.190
戳为零

25:40.190 --> 25:41.190
他们的时间一样吗

25:41.190 --> 25:42.190
这是我遇到一个同学的

25:42.190 --> 25:48.130
问的问题

25:48.130 --> 25:49.130
这个题

25:53.020 --> 25:56.020
这个题一定不能回答不一样

25:56.020 --> 25:57.020
尽管这道题

25:57.020 --> 25:59.020
本身是有问题的

26:01.020 --> 26:02.020
本身就是有问题的

26:02.020 --> 26:03.020
这个题

26:03.020 --> 26:04.020
因为这是我遇到一个同学

26:04.020 --> 26:05.020
他在问这个问题

26:05.020 --> 26:06.020
我当时看到这个问题

26:06.020 --> 26:07.020
我想了半天

26:07.020 --> 26:08.020
我该怎么回复他

26:08.020 --> 26:09.020
你为什么呢

26:09.020 --> 26:10.020
因为他没搞清楚一个概念

26:10.020 --> 26:13.020
时间戳他是没有时趋的

26:13.020 --> 26:15.020
时间戳永远都是零时趋

26:15.020 --> 26:16.020
不存在什么

26:16.020 --> 26:17.020
北京的时间戳

26:17.020 --> 26:19.020
和格林威治的时间戳

26:19.020 --> 26:20.020
不存在的

26:20.020 --> 26:23.020
时间戳一定是零时趋的

26:23.020 --> 26:24.020
零时趋的时间

26:24.020 --> 26:26.020
相对于零时趋的

26:27.020 --> 26:28.020
所以说

26:28.020 --> 26:29.020
时间戳为零

26:29.020 --> 26:30.020
就表示的是

26:30.020 --> 26:31.020
相对于零时趋

26:31.020 --> 26:33.020
1970年1月1号凌晨

26:33.020 --> 26:34.020
过了0秒

26:34.020 --> 26:36.020
他们的时间是一样的

26:36.020 --> 26:38.020
这个说法是有问题的

26:38.020 --> 26:39.020
你不要去看这个说法

26:39.020 --> 26:40.020
这个说法是有问题的

26:40.020 --> 26:42.020
以后你遇到这样的问题

26:42.020 --> 26:43.020
你先告诉他

26:43.020 --> 26:44.020
该科普一下

26:44.020 --> 26:45.020
时间戳是没有时趋的

26:45.020 --> 26:47.020
没有位置的

26:47.020 --> 26:48.020
不存在北京的时间戳

26:49.020 --> 26:50.020
第六题

26:50.020 --> 26:52.020
一个中国用户注册

26:52.020 --> 26:53.020
填写的生日

26:53.020 --> 26:55.020
是1970年1月1号

26:56.020 --> 26:58.020
他出生的UTC时间是多少

26:58.020 --> 27:03.920
能不能打出来

27:03.920 --> 27:08.700
出生的UTC时间

27:08.700 --> 27:09.700
不方便打出来吗

27:09.700 --> 27:11.700
刚才其实也说到了

27:11.700 --> 27:12.700
对 非常好

27:12.700 --> 27:15.700
1969年12月31号

27:15.700 --> 27:16.700
12月31号

27:16.700 --> 27:18.700
如果说加上10分秒的话

27:18.700 --> 27:20.700
因为我们填写生日的时候

27:20.700 --> 27:22.700
一般都是用凌晨来算的

27:22.700 --> 27:24.700
如果说要进去到10分秒的话

27:24.700 --> 27:27.700
是晚上的23点

27:27.700 --> 27:31.700
下午的16点0分0秒

27:31.700 --> 27:32.700
减去8个小时

27:32.700 --> 27:34.700
24减8

27:34.700 --> 27:36.700
就是16

27:36.700 --> 27:37.700
差8个小时

27:37.700 --> 27:38.700
对 差8个小时

27:38.700 --> 27:40.700
减8个小时就行了

27:40.700 --> 27:41.700
时间戳是多少

27:41.700 --> 27:43.700
这是当面识题

27:43.700 --> 27:44.700
时间戳是多少

27:44.700 --> 27:45.700
如果说用户填写的生日

27:45.700 --> 27:47.700
是1970年1月1号

27:47.700 --> 27:50.700
那么你在程序里边存出的时候

27:50.700 --> 27:56.260
时间戳用什么数字存出

27:56.260 --> 27:57.260
时间戳

27:57.260 --> 28:02.270
复一 复八

28:02.270 --> 28:03.270
不对哦

28:03.270 --> 28:05.270
好好想想

28:05.270 --> 28:08.270
程序里边存出的时间戳应该是多少

28:08.270 --> 28:10.270
用户填写的生日

28:10.270 --> 28:11.270
哎 这才对嘛

28:11.270 --> 28:12.270
对吧

28:12.270 --> 28:13.270
一小时等于3600秒

28:13.270 --> 28:16.270
应该等于复八乘以3600

28:16.270 --> 28:18.270
这是它的时间戳

28:18.270 --> 28:20.780
好了

28:20.780 --> 28:21.780
那么

28:21.780 --> 28:22.780
这是这一块

28:22.780 --> 28:24.780
前面的时间的基本知识

28:24.780 --> 28:25.780
那么接下来

28:25.780 --> 28:26.780
我们来看这个第三方库

28:26.780 --> 28:29.340
摸摸着

28:29.340 --> 28:31.340
我们DS里边有一个时期

28:32.340 --> 28:34.340
叫做DS

28:34.340 --> 28:36.340
它就能够处理时间了

28:36.340 --> 28:38.340
DS对象呢

28:38.340 --> 28:40.340
就是一个搞笑的

28:40.340 --> 28:41.340
它自己玩一玩

28:41.340 --> 28:43.340
学习系列式基础的时候

28:43.340 --> 28:46.340
用它来了解我们的时间的这些基本概念

28:46.340 --> 28:47.340
是很不错的

28:47.340 --> 28:49.340
但是要用它开发项目

28:49.340 --> 28:51.340
特别是跟我们时间

28:51.340 --> 28:54.340
处理时间比较多的那种项目里边

28:54.340 --> 28:56.340
这个对象就是搞笑的

28:56.340 --> 28:58.340
功能非常非常的简陋

28:58.340 --> 28:59.340
而且呢

28:59.340 --> 29:01.340
有的时候处理一下非常不方便

29:01.340 --> 29:02.340
因此我们一般来说

29:02.340 --> 29:04.340
会用一个第三方库

29:04.340 --> 29:06.340
来处理时间叫做moment

29:06.340 --> 29:08.340
你们将来的做到项目里边

29:08.340 --> 29:09.340
咱们后期有讲了

29:09.340 --> 29:10.340
做项目

29:10.340 --> 29:11.340
做到项目里边

29:11.340 --> 29:12.340
还会接触另外一个库

29:12.340 --> 29:14.340
叫DSFMS

29:14.340 --> 29:15.340
那个库呢

29:15.340 --> 29:17.340
就是跟这个库演化出来的

29:17.340 --> 29:18.340
不过体积更小

29:18.340 --> 29:19.340
不过我们现在学了

29:19.340 --> 29:20.340
就学它

29:20.340 --> 29:21.340
moment

29:21.340 --> 29:22.340
这个库平时

29:22.340 --> 29:23.340
它在做什么事情呢

29:23.340 --> 29:24.340
它就把这些复杂的问题

29:24.340 --> 29:25.340
这乱七八糟的时间

29:25.340 --> 29:26.340
处理问题

29:26.340 --> 29:28.340
全部给我们简化了

29:28.340 --> 29:30.340
不管你是什么本地时间

29:30.340 --> 29:31.340
它要是什么时间戳

29:31.340 --> 29:32.340
还有什么乱七八糟的

29:32.340 --> 29:34.340
其他日期格式

29:34.340 --> 29:36.340
通通可以通过这个库

29:36.340 --> 29:39.340
转换成一个moment对象

29:39.340 --> 29:40.340
有点像杰克雷对吧

29:40.340 --> 29:41.340
你给它个选择器

29:41.340 --> 29:42.340
它给你一个杰克雷对象

29:42.340 --> 29:43.340
它这里也是一样

29:43.340 --> 29:44.340
你给它本地时间

29:44.340 --> 29:45.340
给它一个时间戳都行

29:45.340 --> 29:47.340
随便你给它什么玩意

29:47.340 --> 29:49.340
它就转换成一个moment对象

29:49.340 --> 29:50.340
而这个对象内部

29:50.340 --> 29:52.340
它一直持续地使用

29:52.340 --> 29:53.340
时间戳来处理

29:53.340 --> 29:55.340
是不是把它变成统一的

29:55.340 --> 29:57.340
不用你手动处理的

29:57.340 --> 29:58.340
无论是什么

29:58.340 --> 30:00.340
到它里边全是时间戳

30:00.340 --> 30:01.340
它里边的运算

30:01.340 --> 30:02.340
什么改动时间

30:02.340 --> 30:03.340
对吧运算

30:03.340 --> 30:04.340
还有比较啊

30:04.340 --> 30:06.340
全是用时间戳来控制

30:06.340 --> 30:07.340
这里是统一的

30:07.340 --> 30:09.340
你就不用管了

30:09.340 --> 30:11.340
然后需要显示的时候

30:11.340 --> 30:13.340
它自动的转换成本地时间

30:13.340 --> 30:14.340
来显示

30:14.340 --> 30:15.340
比方你在中国

30:15.340 --> 30:16.340
它就会转换中国时间

30:16.340 --> 30:17.340
你在英国

30:17.340 --> 30:19.340
你它就会转换在英国时间

30:19.340 --> 30:20.340
它会自动完成

30:20.340 --> 30:21.340
你不用管了

30:21.340 --> 30:22.340
就把这一复杂的问题

30:22.340 --> 30:24.340
就给简化了

30:24.340 --> 30:26.340
你就不用去手动处理这些问题了

30:26.340 --> 30:28.340
我们会一般会用这个

30:28.340 --> 30:29.340
摩托车库

30:29.340 --> 30:30.340
当然它里边功能更多

30:30.340 --> 30:32.340
我今天晚上可以体验一下

30:32.340 --> 30:34.340
今天晚上我们一边来讲效果

30:34.340 --> 30:36.340
一般来讲它里边的什么的

30:36.340 --> 30:37.340
它的用法

30:37.340 --> 30:38.340
看效果之前

30:38.340 --> 30:39.340
我们还是要简单的说一下

30:39.340 --> 30:43.040
它的官方文档

30:43.040 --> 30:46.040
摩托车的官方文档

30:46.040 --> 30:48.040
最近老师这个东西

30:48.040 --> 30:49.040
你会发现了

30:49.040 --> 30:51.040
很多技术的官方文档

30:51.040 --> 30:52.040
都有这些标语

30:52.040 --> 30:53.040
最近说

30:53.040 --> 30:56.040
咱们灯塔国又出事了

30:56.040 --> 30:57.040
我们看它中

30:57.040 --> 31:00.040
还有一个民间中文网

31:00.040 --> 31:06.040
民间中文网

31:06.040 --> 31:08.040
也稍微有点卡

31:08.040 --> 31:09.040
翻译过来的

31:09.040 --> 31:11.040
那么这里是它的中文文档

31:11.040 --> 31:14.040
以后我们会边看边用

31:14.040 --> 31:18.060
不是说好中文文档吗

31:18.060 --> 31:20.370
所以边用文了

31:20.370 --> 31:21.370
中文文档

31:21.370 --> 31:22.370
无所谓

31:22.370 --> 31:23.370
我以后给你说

31:23.370 --> 31:26.370
然后就是它的文档

31:26.370 --> 31:28.370
接下来我们要把它引用进来

31:28.370 --> 31:30.370
它的介石要引用进来

31:30.370 --> 31:31.370
引用介石

31:31.370 --> 31:34.370
用我们前几天看到的CDN

31:34.370 --> 31:36.370
先演示几个

31:36.370 --> 31:37.370
给大家看一下

31:37.370 --> 31:42.280
它的一些常见的用法的效果

31:42.280 --> 31:44.280
我今天有点卡

31:44.280 --> 31:50.730
稍等一下

31:50.730 --> 31:58.260
网络打不开

31:58.260 --> 32:09.320
CDN挂了

32:09.320 --> 32:17.880
百度还有一个CDN

32:17.880 --> 32:18.880
打不开了

32:18.880 --> 32:19.880
打不开了

32:19.880 --> 32:20.880
我这里把这边复制一下

32:20.880 --> 32:22.880
把这边复制一下

32:22.880 --> 32:23.880
它有两个介石

32:23.880 --> 32:25.880
一个介石是在这

32:25.880 --> 32:26.880
我们先用这个介石

32:26.880 --> 32:29.450
先看一下

32:29.450 --> 32:30.450
这个介石

32:30.450 --> 32:32.450
引用进来

32:32.450 --> 32:33.450
然后我们在这里边看一下

32:33.450 --> 32:34.450
它怎么来用

32:34.450 --> 32:37.450
它里边给你们提供了一个

32:37.450 --> 32:39.450
函数叫做 moment

32:39.450 --> 32:40.450
调用这个函数

32:40.450 --> 32:43.450
它就可以返回一个 moment对象

32:43.450 --> 32:45.450
如果说你什么参数都不传的话

32:45.450 --> 32:49.450
它默认就是当前时间

32:49.450 --> 32:50.450
有人说

32:50.450 --> 32:51.450
那当前时间是本地的

32:51.450 --> 32:54.450
还是隔离为之的呢

32:54.450 --> 32:56.450
如果说

32:56.450 --> 32:57.450
它问到你这个问题

32:57.450 --> 32:59.450
表的有个同意的问题

33:00.450 --> 33:01.450
它传的时间

33:01.450 --> 33:02.450
是当前时间

33:02.450 --> 33:03.450
当前时间是本地时间

33:03.450 --> 33:14.880
还是UTC的时间呢

33:14.880 --> 33:16.880
我就问你

33:16.880 --> 33:19.880
北京的史实时刻

33:19.880 --> 33:21.880
跟UTC的史实时刻

33:21.880 --> 33:25.900
是不是一样的

33:25.900 --> 33:26.900
是不是一样的

33:26.900 --> 33:28.900
不一样嘛

33:28.900 --> 33:29.900
你目前

33:29.900 --> 33:30.900
你现在在做的事情

33:30.900 --> 33:33.900
跟隔离为之在做的人

33:33.900 --> 33:34.900
在做的事情不一样嘛

33:34.900 --> 33:37.900
所以说此时此刻跟此去无关

33:37.900 --> 33:39.900
不要说北京的史实时刻和

33:39.900 --> 33:42.900
隔离为之的史实都一样

33:42.900 --> 33:44.900
它总之就是当前时间

33:44.900 --> 33:49.900
返回一个 moment对象

33:49.900 --> 33:52.900
它对象里面提供了很多的方法

33:52.900 --> 33:53.900
来帮助你

33:53.900 --> 33:54.900
来控制时间

33:54.900 --> 33:55.900
我们来看一下吧

33:55.900 --> 33:59.850
首先我们来看一个非常有意思的

33:59.850 --> 34:02.850
就是它这里面不仅仅是支持空参数

34:02.850 --> 34:04.850
还可以传一些别的参数

34:04.850 --> 34:07.850
比如说你可以传一个1970年

34:07.850 --> 34:09.850
1月1号

34:09.850 --> 34:11.850
本地时间的1970年

34:11.850 --> 34:12.850
1月1号

34:12.850 --> 34:13.850
如果说你传了这样的格式的话

34:13.850 --> 34:15.850
它就把它当成一个本地时间

34:15.850 --> 34:17.850
你把本地时间传进去了

34:17.850 --> 34:18.850
它可以转换成时间

34:18.850 --> 34:19.850
一个对象

34:19.850 --> 34:20.850
好 那么现在呢

34:20.850 --> 34:22.850
我们来看一下

34:22.850 --> 34:23.850
这个对象里面可以做哪一套呢

34:23.850 --> 34:24.850
首先一个非常方便的操作就是

34:24.850 --> 34:26.850
它可以转换成时间初

34:26.850 --> 34:27.850
怎么转换呢

34:27.850 --> 34:28.850
非常简单

34:28.850 --> 34:30.850
你把转换的数字就完成了

34:30.850 --> 34:31.850
你写个加号

34:31.850 --> 34:32.850
写个加号是什么意思

34:32.850 --> 34:34.850
就是把这个对象转成数字

34:34.850 --> 34:36.850
先看一下效果

34:36.850 --> 34:42.680
空参

34:42.680 --> 34:43.680
你看一下

34:43.680 --> 34:44.680
是不是一个时间初

34:44.680 --> 34:45.680
对吧

34:45.680 --> 34:46.680
得到一个时间初

34:46.680 --> 34:47.680
那么怎么回事呢

34:47.680 --> 34:48.680
就是你

34:48.680 --> 34:49.680
这个我们学过借识

34:49.680 --> 34:50.680
前面加个加号是吧

34:50.680 --> 34:51.680
表示正数

34:51.680 --> 34:53.680
那么是不是一个数学运算

34:53.680 --> 34:55.680
那么后面跟着对象怎么办呢

34:55.680 --> 34:57.680
对象怎么把它转换成数字

34:58.680 --> 35:00.680
又问基础知识了

35:00.680 --> 35:01.680
这都是基础知识

35:01.680 --> 35:04.680
对象转换成数字

35:04.680 --> 35:07.310
它过程是什么

35:07.310 --> 35:09.310
是什么规则

35:09.310 --> 35:12.310
对象转换的数字规则是什么

35:12.310 --> 35:18.250
对象一个对象怎么转换成数字

35:18.250 --> 35:20.250
调用Number

35:20.250 --> 35:24.260
对象在隐释

35:24.260 --> 35:26.260
在做隐释转换的时候

35:26.260 --> 35:28.260
因为你在做数学运算

35:28.260 --> 35:30.260
在做隐释转换的时候

35:30.260 --> 35:33.260
它会调用对象的Value属性

35:33.260 --> 35:36.260
调用这个属性

35:36.260 --> 35:38.260
你看一下Value

35:38.260 --> 35:43.260
小心

35:43.260 --> 35:44.260
这个时间现在

35:44.260 --> 35:45.260
今天晚上出问题了

35:46.260 --> 35:48.260
刚好上课的时候出问题了

35:48.260 --> 35:49.260
变卡了

35:49.260 --> 35:50.260
是不是一样的

35:50.260 --> 35:52.260
所以说你这里用加号

35:52.260 --> 35:53.260
用隐释转换

35:53.260 --> 35:54.260
和直接调用Value

35:54.260 --> 35:56.260
转换的结果是一样的

35:56.260 --> 35:57.260
包括对象之间

35:57.260 --> 35:58.260
在比较大小的时候

35:58.260 --> 35:59.260
对吧 谁大谁小

35:59.260 --> 36:01.260
也会它内部会调用Value

36:01.260 --> 36:03.260
所以它这里面对象里面

36:03.260 --> 36:05.260
还有五份就给你做了一个Value函数

36:05.260 --> 36:07.260
因此它会给那个时间戳之间

36:07.260 --> 36:09.260
非常轻松地转换的时间戳

36:09.260 --> 36:10.260
你看时间戳是不是

36:10.260 --> 36:13.260
-288000

36:13.260 --> 36:14.260
是不是

36:14.260 --> 36:15.260
为什么是这个时间

36:15.260 --> 36:17.260
你看着啊

36:17.260 --> 36:18.260
我给的时间是什么

36:18.260 --> 36:22.260
我给的时间是1970年1月1号

36:22.260 --> 36:23.260
那么相对于

36:23.260 --> 36:25.260
相对于来说

36:25.260 --> 36:26.260
隔离为止时间

36:26.260 --> 36:28.260
是不是还要找8个小时

36:28.260 --> 36:30.260
对吧 基本上前到8个小时

36:30.260 --> 36:32.260
8×3600

36:32.260 --> 36:34.260
28800

36:34.260 --> 36:36.260
是不是28800

36:36.260 --> 36:38.260
为什么有多了3位

36:38.260 --> 36:39.260
是不是豪妙

36:39.260 --> 36:40.260
对吧

36:40.260 --> 36:42.260
它真正的时间戳是负的

36:42.260 --> 36:43.260
负的

36:43.260 --> 36:44.260
就这么个意思

36:44.260 --> 36:45.260
它可以把本地时间

36:45.260 --> 36:46.260
转换成无面车

36:46.260 --> 36:47.260
也可以干嘛呢

36:47.260 --> 36:49.260
也可以把当前时间

36:49.260 --> 36:50.260
得到一个无面车对象

36:50.260 --> 36:51.260
对吧 这就是

36:51.260 --> 36:53.260
1970年1月1号

36:53.260 --> 36:54.260
UTC时间1.70年1月1号

36:54.260 --> 36:55.260
到当前时间

36:55.260 --> 36:57.260
经过了豪妙数

36:57.260 --> 36:58.260
它这里面都用的是豪妙

36:58.260 --> 36:59.260
没有用表

36:59.260 --> 37:00.260
就这么个意思

37:00.260 --> 37:01.260
然后我们这里面

37:01.260 --> 37:02.260
还可以看到

37:02.260 --> 37:08.520
有很多好玩的事情

37:08.520 --> 37:09.520
能不能把中文文章

37:09.520 --> 37:11.520
调出来

37:11.520 --> 37:12.520
调出来算了吧

37:12.520 --> 37:13.520
咱们来看一下

37:13.520 --> 37:15.520
这里面有哪些好玩的事情

37:15.520 --> 37:17.520
我们这里有一个get set

37:17.520 --> 37:19.520
就得到日期的某一部分

37:19.520 --> 37:20.520
跟get set对象是不是差不多

37:20.520 --> 37:21.520
得到小时

37:21.520 --> 37:22.520
你看

37:22.520 --> 37:23.520
调用一个小时

37:23.520 --> 37:24.520
hour

37:24.520 --> 37:25.520
是不是得到一个小时

37:25.520 --> 37:26.520
对吧

37:26.520 --> 37:27.520
得到的是什么

37:27.520 --> 37:28.520
是UTC的小时

37:28.520 --> 37:30.520
还是北京时间的小时

37:30.520 --> 37:31.520
凡是要得到的东西

37:31.520 --> 37:32.520
得到出来的结果

37:32.520 --> 37:34.520
全是本地时间的

37:34.520 --> 37:36.520
全是本地时间的

37:36.520 --> 37:37.520
设置小时

37:37.520 --> 37:38.520
也是当成本地时间

37:38.520 --> 37:39.520
去设置小时

37:39.520 --> 37:40.520
但它内部的使用

37:40.520 --> 37:42.520
内部的全是用UTC

37:42.520 --> 37:43.520
就是时间出来处理

37:43.520 --> 37:45.520
所以你就不用去管它

37:45.520 --> 37:46.520
是不是时间错了

37:46.520 --> 37:47.520
你跟它交过的东西

37:47.520 --> 37:49.520
如果说没有什么特殊情况

37:49.520 --> 37:51.520
基本上都是本地时间

37:51.520 --> 37:53.520
它让内部给你处理的

37:53.520 --> 37:54.520
全是时间错

37:54.520 --> 37:56.520
内部的你不用管了

37:56.520 --> 37:57.520
你要这意思吧

37:57.520 --> 37:59.520
比方说我这里要得到小时

37:59.520 --> 38:01.520
输出小时

38:01.520 --> 38:04.520
m hour

38:04.520 --> 38:06.520
看一下吧

38:06.520 --> 38:07.520
当年的小时

38:07.520 --> 38:08.520
是不是20

38:08.520 --> 38:09.520
20是本地的

38:09.520 --> 38:10.520
对吧

38:10.520 --> 38:11.520
UTC时间是不是不是20

38:11.520 --> 38:12.520
而减8

38:12.520 --> 38:14.520
然后再看

38:14.520 --> 38:15.520
得到分钟

38:15.520 --> 38:16.520
得到秒

38:16.520 --> 38:17.520
得到那个毫秒

38:17.520 --> 38:18.520
不用说了吧

38:18.520 --> 38:19.520
都差不多

38:19.520 --> 38:20.520
sacred的得到毫秒

38:20.520 --> 38:21.520
sacred的得到秒

38:21.520 --> 38:23.520
每年得到分钟

38:23.520 --> 38:24.520
那么除了得到之外

38:24.520 --> 38:25.520
还可以设置

38:25.520 --> 38:26.520
你还可以设置它

38:26.520 --> 38:27.520
比方说

38:27.520 --> 38:28.520
得到当前的时间

38:28.520 --> 38:29.520
我把小时

38:29.520 --> 38:30.520
设置成

38:30.520 --> 38:31.520
设置成多少呢

38:31.520 --> 38:32.520
设置成10

38:32.520 --> 38:33.520
保存

38:33.520 --> 38:34.520
你看

38:34.520 --> 38:36.520
得到30-50点了

38:36.520 --> 38:37.520
得到30-50点

38:37.520 --> 38:38.520
非常简单

38:38.520 --> 38:39.520
可以非常轻松的

38:39.520 --> 38:40.520
去设置这个时间

38:40.520 --> 38:41.520
那么这个设置的时候

38:41.520 --> 38:43.520
是不是会改动这个moment

38:43.520 --> 38:44.520
对不对

38:44.520 --> 38:45.520
是不是会改动这个moment

38:45.520 --> 38:46.520
然后再看

38:46.520 --> 38:47.520
然后呢

38:47.520 --> 38:48.520
我们再看这个

38:49.520 --> 38:50.520
很多函数呢

38:50.520 --> 38:51.520
我们一会儿在做练习的时候

38:51.520 --> 38:52.520
再说

38:52.520 --> 38:53.520
叫做format

38:53.520 --> 38:54.520
format非常舒服

38:54.520 --> 38:56.520
就是它可以把一个时间的格式化

38:56.520 --> 38:58.520
格式化成本地时间

38:58.520 --> 38:59.520
它怎么来判断

38:59.520 --> 39:00.520
到底是哪个地方呢

39:00.520 --> 39:02.520
它根据你的操作系统

39:02.520 --> 39:03.520
操作系统里边不是有死区吗

39:03.520 --> 39:05.520
你们Windows的操作系统也好

39:05.520 --> 39:06.520
Mac的操作系统也好

39:06.520 --> 39:08.520
它不都有死区设置吗

39:08.520 --> 39:10.520
操作系统设置的是哪个死区

39:10.520 --> 39:12.520
它就按照哪个死区的时间来显示

39:12.520 --> 39:13.520
好那么比方说

39:13.520 --> 39:14.520
我们这里呢

39:14.520 --> 39:16.520
可以用这个函数

39:18.520 --> 39:20.520
有好的格式

39:20.520 --> 39:21.520
我要把展示出来

39:21.520 --> 39:23.520
我们可以用format

39:23.520 --> 39:24.520
展示

39:24.520 --> 39:26.520
format里边有哪

39:26.520 --> 39:27.520
这里边传什么呢

39:27.520 --> 39:28.520
传它的格式

39:28.520 --> 39:29.520
格式

39:29.520 --> 39:30.520
一看下面有很多格式

39:30.520 --> 39:32.520
月份

39:32.520 --> 39:34.520
两位数的月份

39:34.520 --> 39:35.520
还有这个单词的月份

39:35.520 --> 39:36.520
都可以

39:36.520 --> 39:37.520
表示我们这里的

39:37.520 --> 39:40.960
年可以用YYY

39:40.960 --> 39:42.960
四位数的年

39:42.960 --> 39:44.960
多少年

39:44.960 --> 39:45.960
那么这个位置

39:45.960 --> 39:47.960
它就会被年所替换

39:47.960 --> 39:49.960
被四位数的年替换

39:49.960 --> 39:50.960
然后呢

39:50.960 --> 39:51.960
两个M表示月

39:51.960 --> 39:53.960
多少月

39:53.960 --> 39:54.960
那么日期呢

39:54.960 --> 39:56.960
两个D表示多少

39:56.960 --> 39:57.960
哪一天

39:57.960 --> 39:58.960
但是每一个都还不同的

39:58.960 --> 39:59.960
比方说

39:59.960 --> 40:00.960
D

40:00.960 --> 40:01.960
还有

40:02.960 --> 40:03.960
两个D

40:03.960 --> 40:04.960
两位数的

40:04.960 --> 40:05.960
一位数的就是这个

40:05.960 --> 40:06.960
如果说

40:06.960 --> 40:07.960
那么发生在表示的话

40:07.960 --> 40:08.960
就DO

40:08.960 --> 40:09.960
就这么个意思

40:11.960 --> 40:12.960
几点几分呢

40:12.960 --> 40:13.960
用两个H

40:13.960 --> 40:15.960
表示24小时字的

40:15.960 --> 40:17.960
小时部分

40:17.960 --> 40:18.960
10

40:18.960 --> 40:19.960
多少分呢

40:19.960 --> 40:21.960
两个小系的M表示分

40:21.960 --> 40:22.960
秒呢

40:22.960 --> 40:24.960
用两个S表示秒

40:24.960 --> 40:26.960
你看一下

40:26.960 --> 40:27.960
这样子的

40:27.960 --> 40:28.960
它就会把

40:28.960 --> 40:29.960
格式化成一个置不串

40:29.960 --> 40:30.960
就格式化成这个置不串

40:30.960 --> 40:31.960
它把这个时间

40:31.960 --> 40:32.960
本地时间里边

40:32.960 --> 40:34.960
每一个部分安进去

40:34.960 --> 40:36.960
格式化成这么一个置不串

40:36.960 --> 40:37.960
明白的意思吧

40:37.960 --> 40:38.960
就这么个意思

40:38.960 --> 40:39.960
如果说你还要得到什么

40:39.960 --> 40:40.960
星期

40:41.960 --> 40:42.960
这就是星期

40:42.960 --> 40:43.960
四个D

40:44.960 --> 40:45.960
Frighted

40:45.960 --> 40:46.960
对吧

40:46.960 --> 40:47.960
哎有一套

40:47.960 --> 40:48.960
开始不爽了

40:48.960 --> 40:49.960
那我为什么

40:49.960 --> 40:51.960
我怎么能换成中文呢

40:52.960 --> 40:53.960
可以的

40:53.960 --> 40:55.960
如果说你要把它换成中文的话

40:55.960 --> 40:56.960
非常简单

40:56.960 --> 40:58.960
你需要安装一个语言包

40:58.960 --> 41:00.960
你需要安装一个语言包

41:00.960 --> 41:02.960
那么一个语言包在哪呢

41:02.960 --> 41:03.960
在这

41:04.960 --> 41:06.960
我开个CD号上打开了

41:06.960 --> 41:07.960
这里是搜一下

41:07.960 --> 41:09.960
moment.js

41:09.960 --> 41:10.960
你看这

41:10.960 --> 41:11.960
哎呦

41:11.960 --> 41:12.960
天哪

41:12.960 --> 41:13.960
又要开半点

41:13.960 --> 41:14.960
你看这个版本里边

41:14.960 --> 41:15.960
是不是这里边

41:15.960 --> 41:16.960
locale开头的

41:16.960 --> 41:17.960
下面全是语言包

41:17.960 --> 41:18.960
这就这么说

41:18.960 --> 41:19.960
这是阿富汗吗

41:19.960 --> 41:20.960
这是啥

41:20.960 --> 41:21.960
这是啥

41:21.960 --> 41:22.960
反正不同的国家

41:22.960 --> 41:23.960
又不同的语言

41:23.960 --> 41:24.960
一大堆的语言包

41:24.960 --> 41:25.960
不同的国家的语言

41:26.960 --> 41:27.960
我们用什么

41:27.960 --> 41:28.960
中文语言包

41:28.960 --> 41:30.960
把这个标签复制一下

41:32.960 --> 41:33.960
粘过来

41:33.960 --> 41:35.960
先引用moment

41:35.960 --> 41:36.960
再引用语言包

41:37.960 --> 41:38.960
不然的话

41:38.960 --> 41:39.960
不然就是英文

41:39.960 --> 41:41.960
它moment的本体在这

41:41.960 --> 41:42.960
这是没压缩的

41:42.960 --> 41:43.960
这是压缩的

41:43.960 --> 41:44.960
然后先引用moment

41:44.960 --> 41:45.960
再引用它的语言包

41:45.960 --> 41:47.960
引用了语言包

41:47.960 --> 41:48.960
过后

41:48.960 --> 41:49.960
就表示你的系统里边

41:49.960 --> 41:50.960
支持别的语言了

41:50.960 --> 41:51.960
那怎么来

41:51.960 --> 41:53.960
但是它还是没有应用这个语言

41:53.960 --> 41:55.960
还是没有应用这个语言

41:59.960 --> 42:00.960
这种情况

42:00.960 --> 42:01.960
它就直接给我应用了

42:01.960 --> 42:02.960
那行吧

42:02.960 --> 42:03.960
它就直接应用吧

42:03.960 --> 42:04.960
实际上你们以后

42:04.960 --> 42:05.960
学了模块化之后

42:05.960 --> 42:07.960
就是在工程里边

42:07.960 --> 42:09.960
工程里边它是不会直接应用的

42:09.960 --> 42:11.960
你得写一句单码去导入

42:11.960 --> 42:12.960
那属行吧

42:12.960 --> 42:13.960
它就直接应用了

42:13.960 --> 42:14.960
就直接应用吧

42:14.960 --> 42:16.960
因为这种传统的开发方式

42:17.960 --> 42:18.960
不一样

42:18.960 --> 42:19.960
跟你们以后

42:19.960 --> 42:20.960
真正的开发项目的格式

42:20.960 --> 42:21.960
是不一样的

42:21.960 --> 42:22.960
因为你们真正开发项目

42:22.960 --> 42:24.960
一定是有角色加

42:24.960 --> 42:25.960
就保管一系的

42:26.960 --> 42:27.960
不管吧

42:27.960 --> 42:28.960
现在我们还是用传统的

42:28.960 --> 42:29.960
来学习知识

42:29.960 --> 42:30.960
没关系

42:30.960 --> 42:31.960
行吧

42:31.960 --> 42:32.960
你看

42:32.960 --> 42:33.960
所以变成星期五了

42:33.960 --> 42:34.960
好

42:34.960 --> 42:35.960
我问你

42:35.960 --> 42:37.960
引用语言包

42:37.960 --> 42:39.960
你看大家的理解能力

42:39.960 --> 42:41.960
引用语言包

42:42.960 --> 42:45.960
会不会导致导致

42:45.960 --> 42:47.960
显示的时间变化

42:48.960 --> 42:49.960
同一个时间

42:50.960 --> 42:51.960
引用不同的语言包

42:51.960 --> 42:56.870
会不会导致时间的变化

42:56.870 --> 42:57.870
你们好好想一想

43:04.410 --> 43:10.130
当我刚才没有用语言包的时候

43:10.130 --> 43:11.130
这个时间

43:13.130 --> 43:15.130
不还是这个时间吗

43:15.130 --> 43:17.130
用不用语言包

43:17.130 --> 43:19.130
它不会导致

43:19.130 --> 43:22.130
显示本地时间发生变化

43:22.130 --> 43:24.130
本地时间跟什么有关

43:24.130 --> 43:26.130
跟你在位置有关

43:26.130 --> 43:27.130
你在日本

43:27.130 --> 43:29.130
那就是九区

43:29.130 --> 43:30.130
对吧

43:30.130 --> 43:31.130
我这里有个十区图

43:31.130 --> 43:32.130
小离后下来

43:32.130 --> 43:33.130
大家可以看一看

43:33.130 --> 43:35.130
实际试一图

43:35.130 --> 43:37.130
每个国家

43:37.130 --> 43:39.130
不同的十区

43:39.130 --> 43:40.130
上面有个十区

43:41.130 --> 43:42.130
日本是多少

43:42.130 --> 43:44.130
日本是九区

43:44.130 --> 43:45.130
对吧

43:45.130 --> 43:46.130
东九区

43:46.130 --> 43:47.130
加九就表示你

43:47.130 --> 43:49.130
在UTC时间上面加九个小时

43:49.130 --> 43:51.130
就这个意思

43:51.130 --> 43:53.130
你的时间

43:53.130 --> 43:54.130
显示的本地时间

43:54.130 --> 43:56.130
只跟你的位置有关

43:56.130 --> 43:57.130
你在不同的位置

43:57.130 --> 43:58.130
显示的时间不一样

43:58.130 --> 44:00.130
语言是什么

44:00.130 --> 44:01.130
跟你显示出来的时候

44:01.130 --> 44:03.130
可能有些单词

44:03.130 --> 44:05.130
我把单词给你编一下

44:05.130 --> 44:06.130
有些单词

44:06.130 --> 44:07.130
换成德语

44:07.130 --> 44:08.130
换成西班牙语

44:08.130 --> 44:09.130
换成中文

44:09.130 --> 44:10.130
我说我举个例子

44:10.130 --> 44:12.130
你现在人在英国

44:12.130 --> 44:13.130
你人在英国

44:13.130 --> 44:15.130
但是你看不懂英文

44:15.130 --> 44:16.130
你也不管

44:16.130 --> 44:17.130
你为什么不到英国去

44:17.130 --> 44:18.130
比方说你那边去旅游

44:18.130 --> 44:19.130
你又看不懂英文

44:19.130 --> 44:20.130
那么那个时候

44:20.130 --> 44:22.130
比方你上网的时候

44:22.130 --> 44:24.130
不还是用的是中文吗

44:24.130 --> 44:26.130
但是影响你的时间吗

44:26.130 --> 44:27.130
你不影响你的时间吗

44:27.130 --> 44:28.130
你不能说我用中文

44:28.130 --> 44:29.130
在那边的时间就不一样了

44:29.130 --> 44:30.130
那肯定不是

44:30.130 --> 44:31.130
时间还是一样的

44:31.130 --> 44:32.130
能理解吗

44:32.130 --> 44:36.630
只是你显示的语言不一样了

44:36.630 --> 44:37.630
听懂的QV

44:37.630 --> 44:39.630
听懂长声

44:40.630 --> 44:44.630
OK

44:44.630 --> 44:49.160
好 那么这里就是

44:49.160 --> 44:50.160
调调一下语言

44:50.160 --> 44:52.160
然后另外一个还有好玩的

44:52.160 --> 44:54.160
给大家看一下这个

44:54.160 --> 44:56.160
moments里边还有一个函数

44:58.160 --> 45:00.160
moments 地片

45:00.160 --> 45:01.160
还有这个display

45:01.160 --> 45:03.160
显示 就是显示的意思

45:03.160 --> 45:04.160
显示各种格式

45:04.160 --> 45:06.160
这个玩意还挺有意思的

45:06.160 --> 45:09.160
ten from now

45:09.160 --> 45:11.160
就是这个时间到现在

45:11.160 --> 45:13.160
从现在开始到这个时间

45:13.160 --> 45:16.160
就这个时间到现在

45:16.160 --> 45:18.160
的差异性

45:18.160 --> 45:19.160
那么这个东西

45:19.160 --> 45:20.160
你们平时上网的时候

45:20.160 --> 45:22.160
经常看到

45:22.160 --> 45:25.470
比方说我们这里说的差异

45:25.470 --> 45:26.470
am from now

45:26.470 --> 45:27.470
你看一下

45:27.470 --> 45:33.280
10小时前

45:33.280 --> 45:34.280
你们平时刷抖音

45:34.280 --> 45:35.280
刷微博

45:35.280 --> 45:36.280
是不是经常看到这个

45:36.280 --> 45:37.280
对吧

45:37.280 --> 45:38.280
10小时前 几分钟前

45:38.280 --> 45:39.280
刚刚

45:39.280 --> 45:40.280
就这个东西

45:40.280 --> 45:41.280
它就可以通过

45:41.280 --> 45:42.280
非常轻松的

45:42.280 --> 45:44.280
通过这个函数来搞定

45:44.280 --> 45:45.280
那么如果说你没有

45:45.280 --> 45:46.280
这个语言包的话

45:46.280 --> 45:47.280
是不是就是英文显示

45:47.280 --> 45:49.280
ten hours go

45:49.280 --> 45:51.280
这样子中文就变这个样子

45:51.280 --> 45:52.280
就这么一个意思

45:52.280 --> 45:53.280
非常简单的

45:53.280 --> 45:54.280
好了

45:54.280 --> 45:55.280
那么接下来说了半天

45:55.280 --> 45:57.280
我们接下来要开说效果了

45:57.280 --> 45:58.280
我们做什么效果呢

45:58.280 --> 45:59.280
看着

45:59.280 --> 46:00.280
做这个效果

46:00.280 --> 46:01.280
做完了过后呢

46:01.280 --> 46:02.280
基本上你把moments

46:02.280 --> 46:03.280
承托了 基本上认识清楚了

46:03.280 --> 46:05.280
前面有这么一个东西

46:05.280 --> 46:07.280
中国 英国 纽约 西里

46:07.280 --> 46:08.280
有这么一个玩意

46:08.280 --> 46:10.280
然后它显示本地的时间

46:10.280 --> 46:12.280
每个地方显示本地的时间

46:12.280 --> 46:13.280
你可以想

46:13.280 --> 46:14.280
像用电视函数的

46:14.280 --> 46:16.280
用原生的电视函数

46:16.280 --> 46:17.280
做起来

46:17.280 --> 46:18.280
肯定都能做

46:18.280 --> 46:19.280
因为它本身

46:19.280 --> 46:20.280
这个moments

46:20.280 --> 46:21.280
本身那一步

46:21.280 --> 46:23.280
也是借助了这个电视的

46:23.280 --> 46:25.280
多多少套借助了一些

46:25.280 --> 46:26.280
但是一些时间下

46:26.280 --> 46:27.280
肯定很麻烦

46:27.280 --> 46:28.280
而且下面有生日

46:28.280 --> 46:29.280
你看着

46:29.280 --> 46:31.280
比方说

46:31.280 --> 46:38.820
登革的生日

46:38.820 --> 46:39.820
然后下面就可以显示

46:39.820 --> 46:41.820
显示这么一个玩意

46:41.820 --> 46:43.820
出生日期年龄

46:43.820 --> 46:44.820
然后呢

46:44.820 --> 46:45.820
也从出生日期

46:45.820 --> 46:46.820
那天开始

46:46.820 --> 46:47.820
到现在

46:47.820 --> 46:48.820
就不断的变化

46:48.820 --> 46:49.820
你还有多少天

46:49.820 --> 46:50.820
就会迎来

46:50.820 --> 46:52.820
你的下一个生日

46:52.820 --> 46:53.820
而且呢

46:53.820 --> 46:55.820
你将在什么什么什么

46:55.820 --> 46:56.820
这个地方

46:56.820 --> 46:57.820
还有一些变化

46:57.820 --> 46:58.820
比方说

46:58.820 --> 47:00.820
我这里写个8月29号

47:00.820 --> 47:01.820
你看

47:01.820 --> 47:02.820
这里会显示明天

47:02.820 --> 47:03.820
你在明天

47:03.820 --> 47:04.820
会迎来下一个生日

47:04.820 --> 47:05.820
那么如果说

47:05.820 --> 47:07.820
你这里写个27号

47:07.820 --> 47:08.820
他告诉你

47:08.820 --> 47:09.820
你在昨天过的生日

47:09.820 --> 47:11.820
非常非常有好的显示

47:11.820 --> 47:12.820
我们就来做这个效果

47:12.820 --> 47:13.820
做完了

47:13.820 --> 47:14.820
那么咱们这些会就结束了

47:14.820 --> 47:15.820
基本上你

47:15.820 --> 47:16.820
做完了之后

47:17.820 --> 47:18.820
很多细节

47:18.820 --> 47:19.820
你除了还圆骂

47:19.820 --> 47:20.820
你不知道怎么去实现的

47:20.820 --> 47:21.820
但是

47:21.820 --> 47:22.820
至少用的话

47:22.820 --> 47:23.820
还可以用的

47:24.820 --> 47:25.820
好来吧

47:26.820 --> 47:27.820
我们这里的

47:27.820 --> 47:28.820
有这个银这个是

47:28.820 --> 47:29.820
银面

47:29.820 --> 47:30.820
这个银面上

47:30.820 --> 47:31.820
什么布局这些玩意

47:31.820 --> 47:32.820
我已经写好了

47:32.820 --> 47:33.820
你不用再写了

47:33.820 --> 47:34.820
布局这些东西

47:34.820 --> 47:35.820
已经写好了

47:35.820 --> 47:36.820
这里

47:36.820 --> 47:42.530
这个介石

47:42.530 --> 47:43.530
就是效果

47:43.530 --> 47:45.530
我打开错了

47:45.530 --> 47:46.530
我打开错了

47:46.530 --> 47:47.530
我打开练习

47:47.530 --> 47:50.610
打开这个

47:55.860 --> 47:57.860
这个镜摊银面

47:57.860 --> 47:58.860
已经写好了

47:58.860 --> 48:00.860
用了什么布压

48:00.860 --> 48:01.860
这就不重讲了

48:01.860 --> 48:02.860
然后

48:02.860 --> 48:03.860
这里边

48:03.860 --> 48:04.860
用了一个银这个是个介石

48:04.860 --> 48:05.860
前面用了什么

48:05.860 --> 48:06.860
介块位

48:06.860 --> 48:07.860
布压的介石

48:07.860 --> 48:08.860
还有用了某面尺

48:08.860 --> 48:10.860
用了鱼元包

48:10.860 --> 48:11.860
然后再用了一个

48:11.860 --> 48:12.860
我们自己要写的

48:12.860 --> 48:13.860
银这个是个介石

48:13.860 --> 48:15.860
在这空的

48:15.860 --> 48:17.860
我们就是要写这个介石

48:17.860 --> 48:18.860
然后这个银面上有啥

48:18.860 --> 48:20.860
你看就是这么一些元素

48:20.860 --> 48:22.860
我们一部分一部分来

48:22.860 --> 48:23.860
首先看这一部分

48:23.860 --> 48:25.860
我要把每一个不同的

48:25.860 --> 48:26.860
时区的时间

48:26.860 --> 48:27.860
显示到这

48:27.860 --> 48:28.860
显示什么

48:28.860 --> 48:29.860
显示不同的国家的

48:29.860 --> 48:30.860
本地时间

48:30.860 --> 48:31.860
看着怎么做

48:31.860 --> 48:32.860
你看着

48:32.860 --> 48:33.860
我们这里

48:33.860 --> 48:34.860
有些label

48:34.860 --> 48:35.860
这个东西不用去改

48:35.860 --> 48:36.860
中国是什么

48:36.860 --> 48:37.860
时间显示到这

48:37.860 --> 48:38.860
时间显示到这

48:38.860 --> 48:39.860
然后

48:39.860 --> 48:40.860
英国时间显示到

48:40.860 --> 48:41.860
这个DIV里边

48:41.860 --> 48:43.860
纽约显示到这

48:43.860 --> 48:45.860
西尼显示到这

48:45.860 --> 48:46.860
好

48:46.860 --> 48:47.860
那么现在

48:47.860 --> 48:48.860
我们要出一个问题

48:48.860 --> 48:49.860
就是我怎么样

48:49.860 --> 48:50.860
非常方便的

48:50.860 --> 48:51.860
同时去设置

48:51.860 --> 48:52.860
这些DIV里边的

48:52.860 --> 48:53.860
我不能

48:53.860 --> 48:54.860
最好不要用判断

48:54.860 --> 48:55.860
判断就很傻

48:55.860 --> 48:56.860
就非常非常傻

48:56.860 --> 48:57.860
我判断你

48:57.860 --> 48:58.860
如果说你是

48:58.860 --> 48:59.860
这个DIV

48:59.860 --> 49:00.860
我给你用中国的时间显示

49:00.860 --> 49:02.860
判断你是用英国的

49:02.860 --> 49:03.860
用这个地方显示

49:03.860 --> 49:04.860
判断你是纽约

49:04.860 --> 49:05.860
这样显示

49:05.860 --> 49:06.860
就很傻

49:06.860 --> 49:07.860
那么我们想一想

49:07.860 --> 49:09.860
中国 英国 纽约 西尼

49:09.860 --> 49:10.860
他们有什么样

49:10.860 --> 49:11.860
在时间上

49:11.860 --> 49:12.860
有什么样的差异

49:12.860 --> 49:14.860
无非就是时区不一样

49:14.860 --> 49:15.860
对吧

49:15.860 --> 49:16.860
是不是就是时区不一样

49:16.860 --> 49:17.860
其他的处理

49:17.860 --> 49:18.860
是不是完全一样的

49:18.860 --> 49:19.860
因此

49:19.860 --> 49:20.860
我们这里可以看到

49:20.860 --> 49:22.860
一边学习第三方

49:22.860 --> 49:23.860
或者是一边

49:23.860 --> 49:24.860
老师会交给你

49:24.860 --> 49:26.860
去一些常见的处理方式

49:26.860 --> 49:27.860
我们可以用一个

49:27.860 --> 49:29.860
自定义属性的叫肉

49:29.860 --> 49:33.260
这个属性有吗

49:33.260 --> 49:34.260
没有

49:34.260 --> 49:35.260
跟这个元素有关系吗

49:35.260 --> 49:36.260
没关系

49:36.260 --> 49:37.260
我只是一个

49:37.260 --> 49:38.260
自定义属性的

49:38.260 --> 49:39.260
你写ABC都可以

49:39.260 --> 49:40.260
随便你下线

49:40.260 --> 49:41.260
我们用一个

49:41.260 --> 49:42.260
比较友好的名字

49:42.260 --> 49:44.260
叫肉 表示时区

49:44.260 --> 49:46.260
时区的中国是什么

49:46.260 --> 49:47.260
东巴区

49:47.260 --> 49:49.260
英国呢

49:49.260 --> 49:50.260
领区

49:50.260 --> 49:51.260
我们是用这个来表示

49:51.260 --> 49:52.260
对吧

49:53.260 --> 49:54.260
纽约

49:54.260 --> 49:56.260
纽约是多少

49:56.260 --> 49:58.260
我看一下纽约的时间

49:58.260 --> 49:59.260
纽约

49:59.260 --> 50:01.260
刚才不是一个图吗

50:01.260 --> 50:05.150
纽约

50:05.150 --> 50:09.040
这边

50:10.040 --> 50:12.040
纽约 New York

50:12.040 --> 50:14.040
这个颜色

50:14.040 --> 50:15.040
复武

50:15.040 --> 50:16.040
复武区

50:16.040 --> 50:17.040
就西武区

50:17.040 --> 50:19.040
纽约的话就是复武

50:19.040 --> 50:20.040
也就是它在临时区上

50:20.040 --> 50:21.040
要减5个小时

50:21.040 --> 50:23.040
中国是要加8个小时

50:23.040 --> 50:24.040
对吧

50:24.040 --> 50:27.540
西里

50:27.540 --> 50:29.540
西里

50:29.540 --> 50:31.920
往下走

50:31.920 --> 50:33.920
西的里 在这

50:33.920 --> 50:34.920
时区

50:34.920 --> 50:36.920
东时区

50:36.920 --> 50:37.920
这边

50:37.920 --> 50:39.920
我写个诗

50:39.920 --> 50:40.920
好 接下来

50:40.920 --> 50:41.920
就是你看是不是

50:41.920 --> 50:42.920
差一点就解决了

50:42.920 --> 50:43.920
以后你们遇到

50:43.920 --> 50:44.920
那种类似的情况

50:44.920 --> 50:45.920
也可以这样做

50:45.920 --> 50:46.920
我用自定义属性

50:46.920 --> 50:47.920
来解决差异

50:47.920 --> 50:48.920
其他的都完全一样

50:48.920 --> 50:50.920
有啥区别呢

50:50.920 --> 50:51.920
那么接下来

50:51.920 --> 50:52.920
我要做的一个事情

50:52.920 --> 50:53.920
我就写一个函数

50:53.920 --> 50:56.920
叫做set global

50:56.920 --> 50:58.920
設置各个全球

50:58.920 --> 51:01.920
各个国家的时间

51:01.920 --> 51:04.920
设置全球各国

51:04.920 --> 51:06.920
各地区时间

51:06.920 --> 51:07.920
那么这个地方

51:07.920 --> 51:08.920
要干嘛呢

51:08.920 --> 51:09.920
无非就是

51:09.920 --> 51:11.920
要把

51:11.920 --> 51:12.920
要把那个什么的

51:12.920 --> 51:13.920
要把这些DIV

51:13.920 --> 51:14.920
全部拿到

51:14.920 --> 51:15.920
然后改变

51:15.920 --> 51:16.920
这个DIV的什么

51:16.920 --> 51:17.920
内文本

51:17.920 --> 51:18.920
是不是

51:18.920 --> 51:19.920
把这些DIV

51:19.920 --> 51:20.920
全部拿到

51:20.920 --> 51:21.920
然后改变DIV的

51:21.920 --> 51:22.920
内文本

51:22.920 --> 51:23.920
那怎么来

51:23.920 --> 51:24.920
全部拿到了

51:24.920 --> 51:25.920
我们可以用接块位

51:25.920 --> 51:27.920
选中什么

51:27.920 --> 51:29.920
用属性选择器

51:29.920 --> 51:31.920
选中属性带肉的

51:31.920 --> 51:32.920
对吧

51:32.920 --> 51:34.920
只要你属性带肉就行

51:34.920 --> 51:37.920
这是不是个CSS选择器

51:37.920 --> 51:38.920
CSS是不是

51:38.920 --> 51:39.920
写过没

51:39.920 --> 51:40.920
你肯定写过对吧

51:40.920 --> 51:41.920
CSS里边

51:41.920 --> 51:43.920
这是一个属性选择器

51:43.920 --> 51:44.920
带这个属性的元素

51:44.920 --> 51:45.920
全部选中

51:45.920 --> 51:46.920
那么接块位

51:46.920 --> 51:47.920
它是支持CSS选择器的

51:47.920 --> 51:48.920
因此选中了

51:48.920 --> 51:50.920
选中了所有的这些DIV

51:50.920 --> 51:51.920
输出DIV

51:51.920 --> 51:52.920
你看一下吧

51:52.920 --> 51:57.640
CSS选中

51:57.640 --> 51:58.640
点击有点

51:59.640 --> 52:00.640
共产

52:00.640 --> 52:01.640
你看是不是选中了4个

52:01.640 --> 52:02.640
对吧

52:03.640 --> 52:04.640
第2个DIV

52:04.640 --> 52:05.640
第2个DIV

52:05.640 --> 52:06.640
第3个DIV

52:06.640 --> 52:07.640
第4个DIV

52:07.640 --> 52:08.640
那是不是全部选中了

52:08.640 --> 52:09.640
然后干嘛呢

52:09.640 --> 52:11.640
然后是不是可以循环这些DIV

52:11.640 --> 52:12.640
是不是可以循环

52:12.640 --> 52:13.640
来吧

52:13.640 --> 52:14.640
可以循环

52:14.640 --> 52:15.640
等于你

52:15.640 --> 52:16.640
当然接块位里边

52:16.640 --> 52:17.640
还有一个意义

52:17.640 --> 52:18.640
还是来循环

52:18.640 --> 52:19.640
不过大家没有学过

52:19.640 --> 52:20.640
免得

52:20.640 --> 52:21.640
不要无畏的增加难度

52:21.640 --> 52:23.640
我们就干脆用破循环

52:23.640 --> 52:25.640
循环这些DIV

52:25.640 --> 52:26.640
每一次循环

52:26.640 --> 52:27.640
是不是可以拿到其中一个

52:28.640 --> 52:29.640
对吧

52:29.640 --> 52:31.640
这是选中

52:31.640 --> 52:33.640
所有属性

52:33.640 --> 52:36.640
带有肉的元素

52:36.640 --> 52:37.640
循环这些元素

52:37.640 --> 52:38.640
每循环一次

52:38.640 --> 52:39.640
是不是拿到一个

52:39.640 --> 52:40.640
来说说

52:40.640 --> 52:43.140
你看

52:43.140 --> 52:44.140
是不是一个人拿到了

52:44.140 --> 52:45.140
每个元素里边

52:45.140 --> 52:46.140
是不是一个属性

52:46.140 --> 52:47.140
叫做肉

52:47.140 --> 52:48.140
是不是有这么一个属性

52:48.140 --> 52:49.140
来吧

52:49.140 --> 52:50.140
那么这个属性呢

52:50.140 --> 52:51.140
是不是可以通过

52:51.140 --> 52:52.140
接块位拿到

52:52.140 --> 52:53.140
这是一个什么

52:53.140 --> 52:54.140
多么对象

52:54.140 --> 52:55.140
你看

52:55.140 --> 52:56.140
我们刚才都输出了的

52:56.140 --> 52:57.140
是一个多么对象

52:57.140 --> 52:58.140
我要把它

52:58.140 --> 53:00.140
转换成接块位对象

53:00.140 --> 53:01.140
我这样转

53:02.140 --> 53:03.140
那么拿属性

53:03.140 --> 53:04.140
拿什么属性呢

53:04.140 --> 53:05.140
prob

53:05.140 --> 53:06.140
拿什么

53:06.140 --> 53:07.140
叫做肉

53:07.140 --> 53:08.140
看它的值

53:09.140 --> 53:12.140
是哪一个时趋

53:12.140 --> 53:13.140
4个AngieFind

53:13.140 --> 53:14.140
为什么呢

53:14.140 --> 53:15.140
因为这个prob

53:15.140 --> 53:16.140
是内置属性

53:16.140 --> 53:17.140
你像这种属性

53:17.140 --> 53:18.140
至定义属性

53:18.140 --> 53:19.140
你要通过另外一个

53:19.140 --> 53:21.140
ADTR去拿

53:21.140 --> 53:23.140
获取至定义属性

53:23.140 --> 53:25.140
肉的值

53:25.140 --> 53:26.140
好你看

53:26.140 --> 53:27.140
这样的获取出来

53:27.140 --> 53:29.140
是不是80-10

53:29.140 --> 53:30.140
是吧

53:30.140 --> 53:31.140
时趋获取出来的

53:31.140 --> 53:32.140
但是你要注意

53:32.140 --> 53:33.140
这个时趋是一个

53:33.140 --> 53:34.140
制服串

53:34.140 --> 53:35.140
制定义属性

53:35.140 --> 53:36.140
获取出来的东西

53:36.140 --> 53:37.140
全是制服串

53:37.140 --> 53:38.140
它不可能是数字的

53:38.140 --> 53:39.140
属性的值

53:39.140 --> 53:41.140
元素里边属性的值

53:41.140 --> 53:42.140
全是制服串

53:42.140 --> 53:43.140
那么这个时候

53:43.140 --> 53:44.140
要把它转换成数字

53:44.140 --> 53:45.140
很简单

53:45.140 --> 53:46.140
加个加号

53:46.140 --> 53:47.140
非常简单

53:47.140 --> 53:48.140
它这制服串转换成数字

53:48.140 --> 53:49.140
就完事了

53:49.140 --> 53:50.140
你看变成蓝色了

53:50.140 --> 53:51.140
对吧

53:51.140 --> 53:52.140
这是数字的

53:52.140 --> 53:53.140
完了

53:53.140 --> 53:54.140
每个DIV

53:54.140 --> 53:55.140
它代表的时趋是不达到了

53:55.140 --> 53:59.310
现在的处理方式

53:59.310 --> 54:00.310
是一样的

54:00.310 --> 54:01.310
中国

54:01.310 --> 54:02.310
英国

54:02.310 --> 54:03.310
纽约

54:03.310 --> 54:04.310
西尼

54:04.310 --> 54:05.310
他们记录的时间

54:05.310 --> 54:06.310
我请问大家

54:06.310 --> 54:07.310
这四个时间

54:07.310 --> 54:08.310
是不是表示的

54:08.310 --> 54:09.310
同一个时刻

54:10.310 --> 54:14.100
这四个时间

54:14.100 --> 54:15.100
是不是表示的

54:15.100 --> 54:16.100
同一个时刻

54:16.100 --> 54:17.100
对吧

54:17.100 --> 54:18.100
已经回答过

54:18.100 --> 54:19.100
很多四个问题了

54:19.100 --> 54:20.100
肯定是同一个时刻

54:20.100 --> 54:21.100
因此

54:21.100 --> 54:22.100
他们的时间

54:22.100 --> 54:23.100
都是一样的

54:23.100 --> 54:24.100
都是闹

54:24.100 --> 54:25.100
对吧

54:25.100 --> 54:26.100
闹是什么呢

54:26.100 --> 54:27.100
moment

54:28.100 --> 54:29.100
时刻的时间

54:29.100 --> 54:30.100
这才是深圳的时间

54:30.100 --> 54:31.100
内部是时间戳

54:32.100 --> 54:33.100
然后呢

54:33.100 --> 54:34.100
只不过我显示的时候呢

54:34.100 --> 54:36.100
把它转换成不同的时区

54:36.100 --> 54:37.100
来显示

54:37.100 --> 54:38.100
怎么转换呢

54:40.100 --> 54:41.100
非常简单

54:41.100 --> 54:42.100
闹里面呢

54:42.100 --> 54:43.100
有一个

54:43.100 --> 54:44.100
就是moment对象里边

54:44.100 --> 54:45.100
有个函数啊

54:45.100 --> 54:46.100
叫做

54:46.100 --> 54:47.100
查一下问答

54:49.100 --> 54:54.100
moment

54:54.100 --> 54:55.100
这边中文了

54:55.100 --> 54:56.100
乖不乖吗

54:56.100 --> 54:57.100
无所谓

54:57.100 --> 54:58.100
显示

54:58.100 --> 54:59.100
它里边有个函数

54:59.100 --> 55:00.100
叫做操作

55:00.100 --> 55:02.100
UTC offset

55:02.100 --> 55:05.600
设置一个时区偏移量

55:05.600 --> 55:08.600
它以UTC为标准

55:08.600 --> 55:10.600
设置UTC时间的偏移量

55:10.600 --> 55:11.600
就设置时区

55:11.600 --> 55:12.600
有这样理解

55:12.600 --> 55:14.600
UTC offset

55:14.600 --> 55:16.600
office有偏移量的意思

55:16.600 --> 55:17.600
比方说你冬八区

55:17.600 --> 55:18.600
你就设置个八

55:18.600 --> 55:20.600
那么它会不会改变时间呢

55:20.600 --> 55:21.600
它不会改变时间

55:21.600 --> 55:22.600
它内部时间出

55:22.600 --> 55:23.600
冻都没冻

55:23.600 --> 55:25.600
它会影响什么的

55:25.600 --> 55:26.600
相当于是在你电脑上

55:26.600 --> 55:27.600
改了一个时区

55:27.600 --> 55:29.600
当然没有冻你的电脑

55:29.600 --> 55:30.600
并没有冻你的电脑

55:30.600 --> 55:32.600
只是它在显示的时候

55:32.600 --> 55:34.600
将来就会用另外一个时区

55:34.600 --> 55:35.600
来显示

55:35.600 --> 55:36.600
时间根本就没变

55:36.600 --> 55:37.600
那么这里呢

55:37.600 --> 55:38.600
改变什么

55:38.600 --> 55:39.600
改变它的偏移量

55:39.600 --> 55:40.600
偏移量为什么呢

55:40.600 --> 55:41.600
偏移量为咒

55:41.600 --> 55:42.600
对吧

55:42.600 --> 55:44.600
偏移量为咒

55:44.600 --> 55:45.600
这是时区吗

55:45.600 --> 55:46.600
好

55:46.600 --> 55:47.600
然后呢

55:47.600 --> 55:48.600
这个地方返回的是什么呢

55:48.600 --> 55:50.600
返回的仍然

55:50.600 --> 55:51.600
它是个链式编程

55:51.600 --> 55:52.600
返回的是仍然是

55:52.600 --> 55:54.600
无闷者对象

55:54.600 --> 55:55.600
仍然是无闷者对象

55:55.600 --> 55:56.600
所以说你可以继续来做

55:56.600 --> 55:57.600
我们刚才是不是

55:57.600 --> 55:59.600
讲了这个format函数

55:59.600 --> 56:00.600
对吧

56:00.600 --> 56:01.600
连

56:02.600 --> 56:03.600
月

56:03.600 --> 56:04.600
日

56:04.600 --> 56:05.600
小时

56:05.600 --> 56:06.600
分钟

56:06.600 --> 56:07.600
亮

56:08.600 --> 56:09.600
得到这个字符串

56:11.600 --> 56:12.600
输出

56:13.600 --> 56:14.600
你看一下

56:15.600 --> 56:16.600
就得到

56:16.600 --> 56:17.600
中国

56:17.600 --> 56:18.600
9.04分

56:18.600 --> 56:19.600
英国

56:19.600 --> 56:20.600
纽约

56:20.600 --> 56:21.600
西里

56:22.600 --> 56:23.600
没问题吧

56:23.600 --> 56:24.600
好那么现在我主费

56:24.600 --> 56:25.600
就是把这个字符串

56:25.600 --> 56:26.600
设置到什么

56:26.600 --> 56:27.600
设置到这个DIV里面去

56:27.600 --> 56:28.600
DIV

56:28.600 --> 56:29.600
用什么

56:29.600 --> 56:30.600
Tex

56:30.600 --> 56:31.600
或者是atm都可以

56:31.600 --> 56:32.600
所以它的内文本

56:32.600 --> 56:33.600
微

56:33.600 --> 56:36.940
Ten

56:36.940 --> 56:37.940
你看

56:37.940 --> 56:38.940
是不是显示完了

56:38.940 --> 56:40.940
然后不停的走动

56:40.940 --> 56:42.940
那太简单了对吧

56:42.940 --> 56:43.940
你设置一个什么

56:43.940 --> 56:44.940
set interval

56:44.940 --> 56:46.940
每隔一秒钟

56:46.940 --> 56:48.940
每隔一秒钟

56:48.940 --> 56:49.940
然后重新调用一下

56:49.940 --> 56:50.940
这个函数

56:50.940 --> 56:51.940
set global time

56:51.940 --> 56:52.940
所以完事了

56:52.940 --> 56:57.020
继续简单

56:57.020 --> 56:58.020
好这一会儿

56:58.020 --> 56:59.020
能听懂的同学Q和E呢

57:04.060 --> 57:05.060
OK

57:05.060 --> 57:07.430
好

57:07.430 --> 57:08.430
下一个函数

57:08.430 --> 57:09.430
就有点

57:09.430 --> 57:10.430
凡数了

57:10.430 --> 57:11.430
它不误的

57:11.430 --> 57:12.430
一点都不复杂

57:12.430 --> 57:13.430
就是麻烦了

57:13.430 --> 57:14.430
有点麻烦了

57:14.430 --> 57:15.430
就在这

57:15.430 --> 57:16.430
这个函数

57:17.430 --> 57:18.430
就是

57:18.430 --> 57:19.430
这里一个生日

57:19.430 --> 57:20.430
这里一个日期

57:20.430 --> 57:21.430
就input

57:21.430 --> 57:22.430
type day and date

57:22.430 --> 57:23.430
知道吧

57:23.430 --> 57:24.430
type day and date

57:24.430 --> 57:26.430
atm5的一个小知识

57:26.430 --> 57:27.430
就是这里边

57:27.430 --> 57:29.430
可以是一个日期选择

57:29.430 --> 57:32.430
是可以是一个日期选择的

57:32.430 --> 57:33.430
当然这是原生的

57:33.430 --> 57:34.430
一般来说

57:34.430 --> 57:35.430
我们在真实的项目里边

57:35.430 --> 57:36.430
会用一些另外的

57:36.430 --> 57:37.430
第三方库

57:37.430 --> 57:38.430
这些第三方库

57:38.430 --> 57:39.430
可以帮我们生成

57:39.430 --> 57:41.430
一个可以选择日期的文本框

57:41.430 --> 57:43.430
保证在不同的流量器里边

57:43.430 --> 57:44.430
样式完全一致

57:44.430 --> 57:45.430
因为这个东西

57:45.430 --> 57:46.430
这个原生的

57:46.430 --> 57:47.430
一是

57:47.430 --> 57:49.430
如何有遇到一些旧流量器

57:49.430 --> 57:50.430
它可能不兼容

57:50.430 --> 57:51.430
二是

57:51.430 --> 57:52.430
在不同的流量器里边

57:52.430 --> 57:53.430
样式不一样

57:53.430 --> 57:54.430
因为它调用的是

57:54.430 --> 57:56.430
操作系统的日期选择

57:56.430 --> 57:57.430
有些不同的操作系统

57:57.430 --> 57:58.430
都不一样

57:58.430 --> 57:59.430
所以你要获得

57:59.430 --> 58:00.430
统一的感官的话

58:00.430 --> 58:01.430
正常情况下

58:01.430 --> 58:02.430
一般会使用

58:02.430 --> 58:03.430
第三方库

58:03.430 --> 58:04.430
不过我这里不用管了

58:04.430 --> 58:05.430
我们的界面

58:05.430 --> 58:06.430
不是我们的重点

58:06.430 --> 58:07.430
无闷什么

58:07.430 --> 58:08.430
也不管你的界面

58:08.430 --> 58:09.430
它主要是

58:09.430 --> 58:10.430
做数据处理的

58:10.430 --> 58:11.430
好

58:11.430 --> 58:12.430
那么现在这里

58:12.430 --> 58:14.430
就是一个文本框

58:14.430 --> 58:16.430
那么这里边可以填日期

58:16.430 --> 58:18.430
填完了过后

58:18.430 --> 58:20.430
我要把日期

58:20.430 --> 58:21.430
它的一些描述

58:21.430 --> 58:22.430
显示到下边

58:22.430 --> 58:24.430
这个DIV里边

58:24.430 --> 58:25.430
我要显示到这儿

58:25.430 --> 58:27.430
这个ID为BurstInfo

58:27.430 --> 58:29.430
就是生日信息

58:29.430 --> 58:30.430
显示到这个DIV里边

58:30.430 --> 58:31.430
好

58:31.430 --> 58:32.430
来吧

58:32.430 --> 58:34.430
我们来写个函数

58:34.430 --> 58:39.260
叫做SinsBurstInfo

58:39.260 --> 58:40.260
什么意思这个函数

58:40.260 --> 58:44.260
根据当前文本框中

58:44.260 --> 58:48.260
填写的生日

58:48.260 --> 58:50.260
生成

58:50.260 --> 58:52.260
生日信息

58:52.260 --> 58:53.260
填冲到

58:53.260 --> 58:55.260
填冲到哪儿呢

58:55.260 --> 58:56.260
填冲到这个

58:56.260 --> 58:58.260
ID为BurstInfo的

58:58.260 --> 59:01.260
元素中

59:01.260 --> 59:02.260
一调用这个函数

59:02.260 --> 59:03.260
它马上就获取

59:03.260 --> 59:05.260
获取这个文本框的值

59:05.260 --> 59:07.260
然后把它填冲到

59:07.260 --> 59:09.260
这个元素里边

59:09.260 --> 59:10.260
所以说这里边

59:10.260 --> 59:11.260
我是不是要得到两个元素

59:11.260 --> 59:13.260
第一个就是文本框的值

59:13.260 --> 59:15.260
ID为BurstInfo

59:15.260 --> 59:16.260
下边的什么

59:16.260 --> 59:17.260
Info的元素

59:17.260 --> 59:18.260
这个很简单

59:18.260 --> 59:20.260
用结块位一下就获取到了

59:20.260 --> 59:22.260
ID为BurstInfo

59:22.260 --> 59:25.260
下边的Info的元素

59:25.260 --> 59:27.260
是拿到这个元素了

59:27.260 --> 59:28.260
拿到这个元素了

59:28.260 --> 59:29.260
然后干嘛

59:29.260 --> 59:30.260
获取它的值

59:30.260 --> 59:31.260
怎么获取它的值呢

59:31.260 --> 59:33.260
这块位里边有个函数叫做

59:33.260 --> 59:35.260
Wa

59:35.260 --> 59:36.260
就可以直接获取到

59:36.260 --> 59:37.260
一个元素的值

59:37.260 --> 59:38.260
好,来吧

59:38.260 --> 59:39.260
得到一个元素的值

59:39.260 --> 59:42.260
就是你生成的这个TSD

59:42.260 --> 59:43.260
文本

59:43.260 --> 59:46.890
我们来输出一下TSD

59:46.890 --> 59:47.890
一开始

59:47.890 --> 59:49.890
一开始我这里啥都没写

59:49.890 --> 59:50.890
我来调用这个函数

59:50.890 --> 59:51.890
SitsBurstInfo

59:51.890 --> 59:53.890
是不是空白的

59:53.890 --> 59:54.890
空白的

59:54.890 --> 59:55.890
啥都没有

59:55.890 --> 59:56.890
空字不刷

59:56.890 --> 59:58.890
然后我这里去选择一个

59:58.890 --> 01:00:01.890
2000年1月1号

01:00:01.890 --> 01:00:02.890
你看啊

01:00:02.890 --> 01:00:04.890
现在SitsBurstInfo

01:00:04.890 --> 01:00:05.890
有问题对吧

01:00:05.890 --> 01:00:06.890
得到这么一个制服串

01:00:06.890 --> 01:00:07.890
注意它是制服串

01:00:07.890 --> 01:00:08.890
是制服串

01:00:08.890 --> 01:00:09.890
好,那么接下来

01:00:09.890 --> 01:00:11.890
我就是不是要把这个制服串

01:00:11.890 --> 01:00:12.890
转换成Moment

01:00:12.890 --> 01:00:14.890
因为我肯定要做很多的日期处理

01:00:14.890 --> 01:00:15.890
超级多的日期处理

01:00:15.890 --> 01:00:17.890
所以我要把它转换成Moment

01:00:17.890 --> 01:00:18.890
好,那么这里呢

01:00:18.890 --> 01:00:19.890
我们来转换

01:00:19.890 --> 01:00:21.890
来吧

01:00:21.890 --> 01:00:22.890
时间

01:00:22.890 --> 01:00:25.890
生日BurstInfo

01:00:25.890 --> 01:00:30.890
生成生日的Moment对象

01:00:30.890 --> 01:00:33.580
BurstInfo

01:00:33.580 --> 01:00:34.580
好,New一个什么呢

01:00:34.580 --> 01:00:35.580
New一个

01:00:35.580 --> 01:00:36.580
就是Moment

01:00:36.580 --> 01:00:37.580
调用Moment

01:00:37.580 --> 01:00:39.580
把什么TST串进去

01:00:39.580 --> 01:00:41.580
对吧

01:00:41.580 --> 01:00:42.580
但是

01:00:42.580 --> 01:00:44.580
这样子串得到了BurstInfo

01:00:44.580 --> 01:00:46.580
是不是有可能是无效的

01:00:46.580 --> 01:00:50.020
是不是有可能是无效的

01:00:50.020 --> 01:00:51.020
你看啊

01:00:51.020 --> 01:00:52.020
我现在啥都没写

01:00:52.020 --> 01:00:57.680
你现在也看得不是很明白

01:00:57.680 --> 01:00:59.680
我这里把它变成加号嘛

01:00:59.680 --> 01:01:00.680
变成加号

01:01:00.680 --> 01:01:01.680
把它转换成什么

01:01:01.680 --> 01:01:03.680
转换成时间戳

01:01:03.680 --> 01:01:04.680
你看一下

01:01:04.680 --> 01:01:05.680
我现在啥都没写

01:01:06.680 --> 01:01:07.680
NAN

01:01:07.680 --> 01:01:08.680
是不是无效的时间

01:01:08.680 --> 01:01:10.680
比方说我这里只写了一半

01:01:10.680 --> 01:01:11.680
还没写完

01:01:12.680 --> 01:01:13.680
是NAN

01:01:13.680 --> 01:01:14.680
无效的时间

01:01:14.680 --> 01:01:15.680
对吧

01:01:15.680 --> 01:01:16.680
好,那么这个时候呢

01:01:16.680 --> 01:01:17.680
怎么办呢

01:01:17.680 --> 01:01:18.680
如果说无效的话

01:01:18.680 --> 01:01:19.680
我们要做特殊处理

01:01:19.680 --> 01:01:21.680
我就不要做后续的事情了

01:01:21.680 --> 01:01:22.680
所以我判断这个日期

01:01:22.680 --> 01:01:23.680
是不是有效

01:01:23.680 --> 01:01:24.680
怎么判断呢

01:01:24.680 --> 01:01:26.680
在这个Moment对象里边

01:01:26.680 --> 01:01:27.680
有一个函数叫做Valid

01:01:27.680 --> 01:01:29.680
叫EaseValid

01:01:29.680 --> 01:01:31.680
文档里边有给你提示的

01:01:33.680 --> 01:01:34.680
在哪呢

01:01:34.680 --> 01:01:37.680
在查取

01:01:38.680 --> 01:01:39.680
制定性

01:01:40.680 --> 01:01:41.680
国际化

01:01:42.680 --> 01:01:43.680
取值

01:01:43.680 --> 01:01:44.680
操作

01:01:44.680 --> 01:01:45.680
解析

01:01:45.680 --> 01:01:46.680
这里EaseValid

01:01:46.680 --> 01:01:47.680
有这么一个函数

01:01:47.680 --> 01:01:48.680
那么这个函数

01:01:48.680 --> 01:01:50.680
它会返回一个布尔

01:01:50.680 --> 01:01:51.680
高数里

01:01:51.680 --> 01:01:52.680
它是有效的

01:01:52.680 --> 01:01:53.680
还是无效的

01:01:53.680 --> 01:01:55.680
返回处就表示有效

01:01:55.680 --> 01:01:57.680
返回Force就表示无效

01:01:57.680 --> 01:01:58.680
那么这也加个感当号

01:01:58.680 --> 01:01:59.680
什么意思

01:01:59.680 --> 01:02:00.680
就是

01:02:00.680 --> 01:02:02.680
如果日期无效

01:02:02.680 --> 01:02:03.680
如果说日期是无效的

01:02:03.680 --> 01:02:04.680
怎么办呢

01:02:05.680 --> 01:02:06.680
那我甭管你以前

01:02:06.680 --> 01:02:08.680
在这里边生存了多少数据

01:02:08.680 --> 01:02:09.680
全部给你清空

01:02:09.680 --> 01:02:10.680
因为你这一次填写的日期

01:02:10.680 --> 01:02:11.680
是无效的

01:02:11.680 --> 01:02:12.680
对吧

01:02:12.680 --> 01:02:13.680
就把这个BurseInfo

01:02:13.680 --> 01:02:15.680
给它全部清空

01:02:15.680 --> 01:02:20.420
对吧

01:02:20.420 --> 01:02:21.420
也可以调用

01:02:21.420 --> 01:02:22.420
解块位的Amity

01:02:22.420 --> 01:02:23.420
这是解块位的函数

01:02:23.420 --> 01:02:24.420
解块位的函数

01:02:24.420 --> 01:02:25.420
Amity

01:02:25.420 --> 01:02:27.420
清空元素

01:02:27.420 --> 01:02:28.420
内部

01:02:28.420 --> 01:02:29.420
把这元素内部全部清空

01:02:29.420 --> 01:02:30.420
然后

01:02:30.420 --> 01:02:32.420
结束整个函数

01:02:32.420 --> 01:02:33.420
结束

01:02:33.420 --> 01:02:34.420
因为这个日期无效

01:02:34.420 --> 01:02:35.420
你不要做任何事情

01:02:35.420 --> 01:02:37.420
清空元素内部

01:02:37.420 --> 01:02:38.420
然后结束

01:02:38.420 --> 01:02:39.420
就完事了

01:02:40.420 --> 01:02:41.420
那么剩下的事情

01:02:41.420 --> 01:02:42.420
是不是就是日期有效

01:02:43.420 --> 01:02:44.420
日期有效

01:02:45.420 --> 01:02:46.420
还有另外一个事

01:02:46.420 --> 01:02:47.420
还有另外一个事

01:02:47.420 --> 01:02:48.420
还有一种情况

01:02:48.420 --> 01:02:49.420
是日期无效

01:02:50.420 --> 01:02:51.420
就是你的日期

01:02:51.420 --> 01:02:52.420
虽然是有效的

01:02:52.420 --> 01:02:53.420
但是你的生日

01:02:53.420 --> 01:02:54.420
天气的是将来

01:02:55.420 --> 01:02:56.420
就超过今天了

01:02:57.420 --> 01:02:58.420
超过今天了

01:02:58.420 --> 01:02:59.420
是不是日期

01:02:59.420 --> 01:03:00.420
你不能在未来

01:03:00.420 --> 01:03:01.420
生下来吧

01:03:01.420 --> 01:03:02.420
所以说

01:03:02.420 --> 01:03:03.420
将来的日期也是无效的

01:03:03.420 --> 01:03:05.420
那怎么来判断将来呢

01:03:06.420 --> 01:03:07.420
那你现在可以获取到

01:03:07.420 --> 01:03:08.420
当前时间

01:03:08.420 --> 01:03:09.420
到

01:03:09.420 --> 01:03:10.420
当前时间

01:03:10.420 --> 01:03:11.420
当前时间

01:03:12.420 --> 01:03:13.420
就是

01:03:14.420 --> 01:03:15.420
某位置

01:03:15.420 --> 01:03:16.420
对吧

01:03:16.420 --> 01:03:17.420
当前时间

01:03:18.420 --> 01:03:19.420
当前时间

01:03:21.420 --> 01:03:23.420
我们判断生日

01:03:23.420 --> 01:03:24.420
是不是一定是

01:03:24.420 --> 01:03:26.420
跟那个几小时几分

01:03:26.420 --> 01:03:27.420
没有什么直接关系

01:03:27.420 --> 01:03:28.420
对吧

01:03:28.420 --> 01:03:29.420
跟几小时几分

01:03:29.420 --> 01:03:30.420
没有直接关系

01:03:30.420 --> 01:03:31.420
我们判断生日呢

01:03:31.420 --> 01:03:32.420
我们判断生日呢

01:03:32.420 --> 01:03:33.420
往往是干嘛呢

01:03:33.420 --> 01:03:34.420
往往是那个

01:03:34.420 --> 01:03:36.420
一天的开始

01:03:36.420 --> 01:03:37.420
比方说

01:03:37.420 --> 01:03:38.420
我写的是

01:03:38.420 --> 01:03:39.420
2000年1月1号

01:03:39.420 --> 01:03:40.420
它指的是2000年

01:03:40.420 --> 01:03:42.420
1月1号凌晨

01:03:42.420 --> 01:03:43.420
因此你这里边

01:03:44.420 --> 01:03:45.420
这个生日

01:03:45.420 --> 01:03:46.420
有没有超过今天

01:03:46.420 --> 01:03:48.420
我们都以凌晨为准

01:03:48.420 --> 01:03:49.420
所以我怎么来得到

01:03:49.420 --> 01:03:50.420
当前时间

01:03:50.420 --> 01:03:52.420
就当前这一天的凌晨呢

01:03:52.420 --> 01:03:53.420
两个特定

01:03:53.420 --> 01:03:57.120
今日凌晨

01:03:58.120 --> 01:03:59.120
我们怎么来得到

01:03:59.120 --> 01:04:00.120
今日凌晨呢

01:04:00.120 --> 01:04:01.120
这是当前时间

01:04:01.120 --> 01:04:02.120
当前时间是

01:04:02.120 --> 01:04:03.120
反过来是不是

01:04:03.120 --> 01:04:04.120
跟某门车对象

01:04:04.120 --> 01:04:05.120
某门车对象里面

01:04:05.120 --> 01:04:06.120
有一个属性

01:04:06.120 --> 01:04:07.120
一个方法叫做

01:04:07.120 --> 01:04:08.120
start

01:04:08.120 --> 01:04:09.120
开始

01:04:09.120 --> 01:04:11.120
设置开始于什么

01:04:11.120 --> 01:04:12.120
开始于什么

01:04:12.120 --> 01:04:13.120
开始于

01:04:13.120 --> 01:04:14.120
对

01:04:14.120 --> 01:04:15.120
这里边可以写什么

01:04:15.120 --> 01:04:16.120
year

01:04:16.120 --> 01:04:17.120
开始于今年

01:04:17.120 --> 01:04:18.120
那就是变成了

01:04:18.120 --> 01:04:20.120
2000年1月1号

01:04:20.120 --> 01:04:21.120
比方说

01:04:21.120 --> 01:04:22.120
当前时间的

01:04:22.120 --> 01:04:23.120
当前时间的今年

01:04:23.120 --> 01:04:26.120
就是2020年1月1号

01:04:26.120 --> 01:04:27.120
比方说

01:04:27.120 --> 01:04:28.120
这里开始于month

01:04:28.120 --> 01:04:29.120
就表示

01:04:29.120 --> 01:04:31.120
2020年8月1号

01:04:31.120 --> 01:04:32.120
开始

01:04:32.120 --> 01:04:33.120
start of day

01:04:33.120 --> 01:04:36.120
就表示今天的凌晨

01:04:36.120 --> 01:04:37.120
明白意思吧

01:04:37.120 --> 01:04:38.120
表示今日

01:04:38.120 --> 01:04:39.120
那么这里呢

01:04:39.120 --> 01:04:40.120
我就判断一下

01:04:40.120 --> 01:04:41.120
这是个某门车吧

01:04:41.120 --> 01:04:42.120
这也是个某门车吧

01:04:42.120 --> 01:04:46.460
两个可以比较啊

01:04:46.460 --> 01:04:48.460
如果你的日期无效

01:04:48.460 --> 01:04:50.460
或者

01:04:50.460 --> 01:04:53.460
你的生日大于今天

01:04:53.460 --> 01:04:56.460
这两种情况

01:04:56.460 --> 01:04:58.460
都是无法处理的

01:04:58.460 --> 01:05:03.280
生日大于今日

01:05:03.280 --> 01:05:04.280
好 这一块

01:05:10.050 --> 01:05:11.050
对

01:05:11.050 --> 01:05:12.050
因为我们比较

01:05:12.050 --> 01:05:13.050
生日跟他的比较

01:05:13.050 --> 01:05:16.050
都是通过凌晨来比较的

01:05:16.050 --> 01:05:19.050
那么都是无效的生日

01:05:19.050 --> 01:05:20.050
都是这一块

01:05:20.050 --> 01:05:21.050
那么接下来就是

01:05:21.050 --> 01:05:23.050
生日是有效的

01:05:23.050 --> 01:05:24.050
那有效干嘛呢

01:05:24.050 --> 01:05:25.050
你看这里边有很多信息

01:05:25.050 --> 01:05:28.050
我们要填一个个来

01:05:28.050 --> 01:05:30.050
有很多信息

01:05:30.050 --> 01:05:32.050
第一个部分

01:05:32.050 --> 01:05:34.050
把出生时间

01:05:34.050 --> 01:05:35.050
出生日期显示出来

01:05:35.050 --> 01:05:36.050
这个很简单吗

01:05:36.050 --> 01:05:37.050
这个非常非常简单

01:05:37.050 --> 01:05:38.050
那显示生日是怎么显示的

01:05:38.050 --> 01:05:40.050
我是生成一个P元数

01:05:40.050 --> 01:05:43.050
我是生成了一个P元数

01:05:43.050 --> 01:05:44.050
比方说啊

01:05:44.050 --> 01:05:45.050
这里的P

01:05:46.050 --> 01:05:49.050
这是出生日期

01:05:49.050 --> 01:05:52.050
查查查

01:05:52.050 --> 01:05:53.050
没有十分秒

01:05:53.050 --> 01:05:55.050
这是第一个段落

01:05:55.050 --> 01:05:56.050
第一个段落就是在这里

01:05:56.050 --> 01:05:57.050
那么第一段落

01:05:57.050 --> 01:05:58.050
我去生成一段IT秒

01:05:58.050 --> 01:05:59.050
我们昨天讲过

01:05:59.050 --> 01:06:00.050
模板支部串

01:06:00.050 --> 01:06:01.050
来评阶一下

01:06:01.050 --> 01:06:03.050
一个P元数

01:06:03.050 --> 01:06:04.050
P元数里面

01:06:04.050 --> 01:06:05.050
前面一个加出的

01:06:05.050 --> 01:06:06.050
我用实装嘛

01:06:06.050 --> 01:06:08.050
实装元数

01:06:08.050 --> 01:06:12.050
出生日期

01:06:12.050 --> 01:06:17.060
然后后面我用实单元数

01:06:17.060 --> 01:06:19.060
把这个玩意显示到这

01:06:19.060 --> 01:06:21.060
那么出生日期显示到这

01:06:21.060 --> 01:06:22.060
是不是特别简单

01:06:22.060 --> 01:06:23.060
怎么显示

01:06:23.060 --> 01:06:24.060
拼接什么

01:06:24.060 --> 01:06:26.060
拼接这个Birthday

01:06:26.060 --> 01:06:27.060
这是我们的

01:06:27.060 --> 01:06:28.060
这个Birthday

01:06:28.060 --> 01:06:30.060
就是生日

01:06:30.060 --> 01:06:31.060
然后用什么

01:06:31.060 --> 01:06:32.060
Format

01:06:32.060 --> 01:06:33.060
格式化

01:06:33.060 --> 01:06:34.060
年

01:06:34.060 --> 01:06:36.060
月

01:06:36.060 --> 01:06:37.060
是不是写过了

01:06:37.060 --> 01:06:39.060
前面设置的不同持续

01:06:39.060 --> 01:06:40.060
是不是都写过了

01:06:40.060 --> 01:06:41.060
就完成了

01:06:41.060 --> 01:06:42.060
P

01:06:42.060 --> 01:06:43.060
那么一会儿

01:06:43.060 --> 01:06:44.060
最后我设置的时候

01:06:44.060 --> 01:06:45.060
怎么设置呢

01:06:45.060 --> 01:06:46.060
设置的时候

01:06:46.060 --> 01:06:48.060
就设置这个

01:06:49.060 --> 01:06:51.060
这个DIV

01:06:51.060 --> 01:06:52.060
Birth Info

01:06:52.060 --> 01:06:56.100
设置它什么

01:06:56.100 --> 01:06:58.100
是它的IT秒

01:06:58.100 --> 01:06:59.100
为什么

01:06:59.100 --> 01:07:00.100
为P1

01:07:00.100 --> 01:07:01.100
你看一下

01:07:01.100 --> 01:07:06.680
没效果

01:07:06.680 --> 01:07:07.680
没效果为什么

01:07:07.680 --> 01:07:08.680
因为我现在

01:07:08.680 --> 01:07:09.680
是无效的日期

01:07:09.680 --> 01:07:12.680
我写个日期

01:07:12.680 --> 01:07:13.680
2020年7月27

01:07:14.680 --> 01:07:16.680
这一天生的

01:07:16.680 --> 01:07:17.680
你看

01:07:17.680 --> 01:07:18.680
是不是设置到进去了

01:07:18.680 --> 01:07:19.680
那么这个P元素

01:07:19.680 --> 01:07:20.680
是不是设置到

01:07:20.680 --> 01:07:21.680
它的内文本里面去了

01:07:21.680 --> 01:07:23.680
非常简单吧

01:07:23.680 --> 01:07:25.680
这件事

01:07:25.680 --> 01:07:26.680
P元素设计进去了

01:07:26.680 --> 01:07:28.680
这是第二段落

01:07:28.680 --> 01:07:30.680
第二段落是年龄

01:07:30.680 --> 01:07:35.270
一个部分一个部分珠

01:07:35.270 --> 01:07:37.270
年龄

01:07:37.270 --> 01:07:39.270
P2

01:07:39.270 --> 01:07:40.270
来吧

01:07:40.270 --> 01:07:43.860
写出来

01:07:43.860 --> 01:07:46.180
复制一下

01:07:46.180 --> 01:07:49.550
这部分先去掉

01:07:49.550 --> 01:07:53.530
年龄

01:07:53.530 --> 01:07:54.530
这个部分写啥

01:07:54.530 --> 01:07:55.530
年龄

01:07:55.530 --> 01:07:57.530
那么我这条算一下年龄

01:07:57.530 --> 01:07:59.530
年龄怎么算呢

01:07:59.530 --> 01:08:01.530
问题是年龄怎么算呢

01:08:01.530 --> 01:08:03.530
年龄其实就是

01:08:03.530 --> 01:08:07.530
出生日期到今天

01:08:07.530 --> 01:08:09.530
经过了多少年

01:08:09.530 --> 01:08:10.530
是不是

01:08:10.530 --> 01:08:11.530
出生日期

01:08:11.530 --> 01:08:12.530
这一天生的

01:08:12.530 --> 01:08:13.530
然后到今天

01:08:13.530 --> 01:08:14.530
经过了多少年

01:08:14.530 --> 01:08:15.530
可能有小数

01:08:15.530 --> 01:08:16.530
经过了1.5年

01:08:16.530 --> 01:08:17.530
那就不要把小数去掉了

01:08:17.530 --> 01:08:19.530
能不能算了

01:08:19.530 --> 01:08:20.530
可以算

01:08:20.530 --> 01:08:21.530
怎么算的呢

01:08:21.530 --> 01:08:23.530
在那个蒙门车里面

01:08:23.530 --> 01:08:24.530
有这么一个函数

01:08:24.530 --> 01:08:26.530
就是操作

01:08:26.530 --> 01:08:28.530
叫做查

01:08:28.530 --> 01:08:29.530
显示

01:08:29.530 --> 01:08:30.530
查群

01:08:30.530 --> 01:08:31.530
显示

01:08:31.530 --> 01:08:32.530
你要找一找

01:08:32.530 --> 01:08:33.530
地府

01:08:33.530 --> 01:08:35.530
地府就是查译

01:08:35.530 --> 01:08:37.530
两个日期之间的查译

01:08:37.530 --> 01:08:38.530
好

01:08:38.530 --> 01:08:40.530
来看吧

01:08:40.530 --> 01:08:41.530
第一个日期

01:08:41.530 --> 01:08:42.530
地府

01:08:42.530 --> 01:08:43.530
第二

01:08:43.530 --> 01:08:44.530
你们再写个日期

01:08:44.530 --> 01:08:45.530
两个日期之间的查译

01:08:45.530 --> 01:08:46.530
好

01:08:46.530 --> 01:08:47.530
咱们来看一下

01:08:47.530 --> 01:08:48.530
我们这里呢

01:08:48.530 --> 01:08:49.530
如果说用Birthday

01:08:49.530 --> 01:08:51.530
地府

01:08:51.530 --> 01:08:52.530
到什么呢

01:08:52.530 --> 01:08:54.530
这一天的查译

01:08:54.530 --> 01:08:55.530
哪一部分的查译呢

01:08:55.530 --> 01:08:56.530
第二个查译

01:08:56.530 --> 01:08:57.530
告诉他

01:08:57.530 --> 01:08:58.530
要求的是哪一部分的查译

01:08:58.530 --> 01:08:59.530
Ears

01:08:59.530 --> 01:09:00.530
复数

01:09:00.530 --> 01:09:01.530
为什么复数

01:09:01.530 --> 01:09:02.530
因为他可能相隔很多年

01:09:02.530 --> 01:09:03.530
对吧

01:09:03.530 --> 01:09:04.530
这里都是

01:09:04.530 --> 01:09:05.530
秘密

01:09:05.530 --> 01:09:06.530
都是很有讲究的

01:09:06.530 --> 01:09:07.530
这个日期

01:09:07.530 --> 01:09:08.530
到这个日期

01:09:08.530 --> 01:09:09.530
经过了的年份

01:09:09.530 --> 01:09:10.530
返回的是一个什么

01:09:10.530 --> 01:09:11.530
数字

01:09:11.530 --> 01:09:12.530
H

01:09:12.530 --> 01:09:13.530
不就是年龄吗

01:09:13.530 --> 01:09:14.530
是吧

01:09:14.530 --> 01:09:15.530
极其简单

01:09:15.530 --> 01:09:16.530
那么H

01:09:16.530 --> 01:09:19.220
好

01:09:19.220 --> 01:09:22.690
看一下吧

01:09:22.690 --> 01:09:24.690
这边我填一个

01:09:24.690 --> 01:09:27.320
2000年

01:09:27.320 --> 01:09:28.320
8月5号

01:09:28.320 --> 01:09:30.320
这一天

01:09:30.320 --> 01:09:32.320
Birthday

01:09:32.320 --> 01:09:33.320
我没有加进去

01:09:33.320 --> 01:09:34.320
没把P2

01:09:34.320 --> 01:09:35.320
这是P2

01:09:35.320 --> 01:09:36.320
没把P2加进去

01:09:36.320 --> 01:09:37.320
那么这边又要加P1

01:09:37.320 --> 01:09:38.320
又要加P2

01:09:38.320 --> 01:09:39.320
怎么办呢

01:09:39.320 --> 01:09:40.320
那我就加一个制服串

01:09:40.320 --> 01:09:42.320
先把P1放进去

01:09:42.320 --> 01:09:43.320
然后再把P2放进去

01:09:43.320 --> 01:09:44.320
这个非常简单

01:09:44.320 --> 01:09:46.320
没什么好说的吧

01:09:46.320 --> 01:09:47.320
这P1是个制服串

01:09:47.320 --> 01:09:48.320
P2是个制服串

01:09:48.320 --> 01:09:49.320
我再把两个制服串

01:09:49.320 --> 01:09:50.320
拼接到一起

01:09:50.320 --> 01:09:51.320
放进去

01:09:51.320 --> 01:09:53.320
然后你用加号也可以

01:09:53.320 --> 01:09:54.320
你用加号也可以

01:09:54.320 --> 01:09:55.320
你这样的写也可以

01:09:56.320 --> 01:09:57.320
拼接P2

01:09:57.320 --> 01:09:59.320
这都是程序基础里边的东西

01:09:59.320 --> 01:10:00.320
再来

01:10:00.320 --> 01:10:02.320
2000年

01:10:02.320 --> 01:10:04.320
8月15号

01:10:04.320 --> 01:10:06.320
8月15号

01:10:06.320 --> 01:10:07.320
2000年

01:10:07.320 --> 01:10:11.590
8月15号

01:10:13.590 --> 01:10:14.590
年龄

01:10:14.590 --> 01:10:15.590
富二十

01:10:15.590 --> 01:10:16.590
说明一下

01:10:16.590 --> 01:10:17.590
说明一下我放反了

01:10:17.590 --> 01:10:19.590
他这个靠后的日期

01:10:19.590 --> 01:10:20.590
应该放前一边

01:10:20.590 --> 01:10:21.590
靠前的日期

01:10:21.590 --> 01:10:23.590
应该放后边

01:10:23.590 --> 01:10:25.590
他就是他剪他

01:10:25.590 --> 01:10:27.590
他剪他

01:10:27.590 --> 01:10:29.590
相隔的年份

01:10:29.590 --> 01:10:30.590
到年龄

01:10:30.590 --> 01:10:31.590
再来

01:10:31.590 --> 01:10:33.590
2000年

01:10:33.590 --> 01:10:35.590
8月15号

01:10:35.590 --> 01:10:36.590
生日

01:10:36.590 --> 01:10:37.590
然后呢

01:10:41.590 --> 01:10:43.590
20岁

01:10:43.590 --> 01:10:44.590
然后呢

01:10:44.590 --> 01:10:47.590
如果说是8月

01:10:47.590 --> 01:10:49.590
或者是9月15号

01:10:49.590 --> 01:10:50.590
9月10号5号

01:10:50.590 --> 01:10:51.590
我们再看一下

01:10:51.590 --> 01:10:52.590
是不是19岁

01:10:52.590 --> 01:10:54.590
还没有到20年

01:10:54.590 --> 01:10:56.590
生日年龄是不是没问题的

01:10:56.590 --> 01:10:58.590
根据生日计算年龄

01:10:58.590 --> 01:10:59.590
好再来啊

01:10:59.590 --> 01:11:01.590
看一下还有啥

01:11:01.590 --> 01:11:04.590
你以在这个世界上存在了多少秒钟

01:11:07.590 --> 01:11:12.250
存在的秒数

01:11:12.250 --> 01:11:13.250
那么这个时候呢

01:11:13.250 --> 01:11:15.250
无非就是从计算什么

01:11:15.250 --> 01:11:17.250
计算生日到了

01:11:17.250 --> 01:11:18.250
是不到今天

01:11:18.250 --> 01:11:19.250
不是今天

01:11:19.250 --> 01:11:20.250
是到现在

01:11:20.250 --> 01:11:22.250
因为它要进去到秒

01:11:22.250 --> 01:11:23.250
要到现在

01:11:23.250 --> 01:11:24.250
浪

01:11:24.250 --> 01:11:26.250
当前时间

01:11:27.250 --> 01:11:28.250
就是现在的

01:11:28.250 --> 01:11:30.250
从生日到现在

01:11:30.250 --> 01:11:31.250
经过了秒数

01:11:31.250 --> 01:11:32.250
对吧

01:11:32.250 --> 01:11:33.250
非常简单

01:11:34.250 --> 01:11:35.250
等于什么呢

01:11:35.250 --> 01:11:36.250
等于

01:11:38.250 --> 01:11:39.250
剪去什么呢

01:11:39.250 --> 01:11:40.250
剪去

01:11:42.250 --> 01:11:43.250
经过了什么

01:11:43.250 --> 01:11:44.250
second秒数

01:11:45.250 --> 01:11:46.250
对吧

01:11:46.250 --> 01:11:47.250
然后呢

01:11:47.250 --> 01:11:48.250
再加一个段落

01:11:49.250 --> 01:11:50.250
p3

01:11:51.250 --> 01:11:52.250
这是

01:11:52.250 --> 01:11:53.250
这是什么意思呢

01:11:53.250 --> 01:11:54.250
你在这个世界上

01:11:54.250 --> 01:11:56.250
已经存在了多少秒

01:11:57.250 --> 01:11:58.250
就写一下吧

01:11:58.250 --> 01:12:01.900
你

01:12:02.900 --> 01:12:05.900
你在这个世界上

01:12:05.900 --> 01:12:07.900
已经存在了

01:12:08.900 --> 01:12:09.900
这里加出

01:12:10.900 --> 01:12:11.900
多少

01:12:12.900 --> 01:12:13.900
秒钟

01:12:16.660 --> 01:12:17.660
好 秒这里呢

01:12:17.660 --> 01:12:18.660
我们可是不是可以用这个

01:12:18.660 --> 01:12:19.660
second

01:12:19.660 --> 01:12:20.660
放进来就行吗

01:12:20.660 --> 01:12:21.660
对吧

01:12:21.660 --> 01:12:22.660
p3

01:12:22.660 --> 01:12:23.660
好 那么这边顺便再拼接一下p3

01:12:24.660 --> 01:12:25.660
好 再来啊

01:12:25.660 --> 01:12:26.660
你看

01:12:27.660 --> 01:12:28.660
这边

01:12:28.660 --> 01:12:29.660
2000年

01:12:30.660 --> 01:12:31.660
1月

01:12:31.660 --> 01:12:32.660
1号

01:12:32.660 --> 01:12:33.660
生的

01:12:33.660 --> 01:12:37.450
存了这么多秒

01:12:37.450 --> 01:12:38.450
对吧

01:12:39.450 --> 01:12:40.450
这这一块啊

01:12:41.450 --> 01:12:42.450
那有人说

01:12:42.450 --> 01:12:44.450
这个秒钟怎么来跳动呢

01:12:44.450 --> 01:12:45.450
那一不一样吗

01:12:45.450 --> 01:12:46.450
每隔一段时间

01:12:46.450 --> 01:12:47.450
再重新调为一下

01:12:47.450 --> 01:12:48.450
这个函数不就完了吗

01:12:48.450 --> 01:12:49.450
six percent info

01:12:49.450 --> 01:12:50.450
对吧 重新调为一下

01:12:50.450 --> 01:12:51.450
就完事了

01:12:51.450 --> 01:12:52.450
然后呢

01:12:52.450 --> 01:12:53.450
另外呢

01:12:53.450 --> 01:12:54.450
我们在顺便就把写了吧

01:12:54.450 --> 01:12:55.450
比方这个文笨框

01:12:55.450 --> 01:12:56.450
失去焦点的时候呢

01:12:56.450 --> 01:12:58.450
它也要做这个处理

01:12:58.450 --> 01:13:00.450
比方说我们这里文笨框很简单

01:13:00.450 --> 01:13:01.450
文笨框就在这

01:13:01.450 --> 01:13:02.450
文笨框

01:13:02.450 --> 01:13:03.450
做这个实现嘛

01:13:03.450 --> 01:13:04.450
文笨框

01:13:04.450 --> 01:13:05.450
不知道

01:13:05.450 --> 01:13:07.450
当失去焦点的时候

01:13:07.450 --> 01:13:08.450
是被运行是吧

01:13:08.450 --> 01:13:09.450
six percent info

01:13:11.450 --> 01:13:12.450
那么这样子呢

01:13:12.450 --> 01:13:13.450
我就不用在这里手动调用了

01:13:13.450 --> 01:13:14.450
比方说2000年

01:13:15.450 --> 01:13:16.450
1月1号

01:13:17.450 --> 01:13:18.450
失去焦点出来了

01:13:18.450 --> 01:13:19.450
每隔一段时间

01:13:19.450 --> 01:13:20.450
每隔一秒钟

01:13:20.450 --> 01:13:21.450
它这里也要出来

01:13:21.450 --> 01:13:22.450
对吧

01:13:22.450 --> 01:13:23.450
好 接下来下一个

01:13:23.450 --> 01:13:24.450
下一个就是

01:13:24.450 --> 01:13:26.450
你还有多少天

01:13:26.450 --> 01:13:27.450
你还有多少天

01:13:27.450 --> 01:13:28.450
就会迎来

01:13:29.450 --> 01:13:30.450
72岁的生日

01:13:30.450 --> 01:13:31.450
那么这里是有差异的

01:13:31.450 --> 01:13:32.450
你看着啊

01:13:32.450 --> 01:13:33.450
比方说

01:13:33.450 --> 01:13:34.450
如果说你这里是9月1号

01:13:34.450 --> 01:13:37.760
这个语言都不一样的吧

01:13:37.760 --> 01:13:38.760
还有多少天就迎来

01:13:38.760 --> 01:13:40.760
你多少岁的生日

01:13:40.760 --> 01:13:41.760
然后还有这

01:13:41.760 --> 01:13:43.760
比方说是8月27

01:13:44.760 --> 01:13:45.760
这里还是一样的

01:13:45.760 --> 01:13:46.760
这里还是一样的

01:13:46.760 --> 01:13:48.760
这里就要算两个东西

01:13:48.760 --> 01:13:50.760
一个是你下一个生日

01:13:50.760 --> 01:13:51.760
这个很简单

01:13:52.760 --> 01:13:54.760
就是你当前的年龄加一

01:13:54.760 --> 01:13:55.760
对吧

01:13:55.760 --> 01:13:56.760
当前的年龄加一

01:13:56.760 --> 01:13:57.760
这个字

01:13:57.760 --> 01:13:59.760
关键是这个字怎么算

01:14:00.760 --> 01:14:02.760
你还有多少天

01:14:02.760 --> 01:14:04.760
就会迎来这个生日

01:14:04.760 --> 01:14:05.760
这个字怎么算

01:14:11.390 --> 01:14:15.340
这个字啊

01:14:15.340 --> 01:14:18.980
想想啊

01:14:18.980 --> 01:14:20.980
是不是要算出

01:14:20.980 --> 01:14:26.060
明年的生日时间

01:14:26.060 --> 01:14:29.060
明年的生日时间

01:14:29.060 --> 01:14:31.060
减去

01:14:31.060 --> 01:14:33.060
今天

01:14:33.060 --> 01:14:34.060
非常好啊

01:14:34.060 --> 01:14:36.060
就是明年的生日

01:14:36.060 --> 01:14:38.060
减今天

01:14:38.060 --> 01:14:41.620
就要这样算

01:14:41.620 --> 01:14:48.260
下面是下个段落

01:14:49.260 --> 01:14:53.260
我没说重新構建这个文本

01:14:53.260 --> 01:14:57.730
OK 复制一下

01:14:57.730 --> 01:14:58.730
下一个

01:14:58.730 --> 01:14:59.730
这个东西很简单

01:14:59.730 --> 01:15:00.730
A级加一

01:15:00.730 --> 01:15:01.730
前面的年龄加一

01:15:01.730 --> 01:15:02.730
关键是这个

01:15:02.730 --> 01:15:05.550
我要计算什么

01:15:05.550 --> 01:15:10.550
计算明年的生日

01:15:10.550 --> 01:15:12.550
计算明年的生日

01:15:12.550 --> 01:15:14.550
明年的生日怎么算呢

01:15:15.550 --> 01:15:17.550
是不是就把生日的年份

01:15:17.550 --> 01:15:20.550
设置为明年就可以了

01:15:20.550 --> 01:15:21.550
对不对

01:15:21.550 --> 01:15:22.550
好 那么这里呢

01:15:22.550 --> 01:15:23.550
就是Birthday

01:15:23.550 --> 01:15:25.550
设置它的年份为明年

01:15:25.550 --> 01:15:27.550
它里面有个函数叫Ear

01:15:27.550 --> 01:15:28.550
我们之前给我告诉大家

01:15:28.550 --> 01:15:29.550
可以设置什么

01:15:29.550 --> 01:15:30.550
设置小时

01:15:30.550 --> 01:15:31.550
设置分钟

01:15:31.550 --> 01:15:32.550
是不是可以设置年

01:15:32.550 --> 01:15:33.550
但是你要注意啊

01:15:33.550 --> 01:15:34.550
你这样子一设置年

01:15:34.550 --> 01:15:36.550
它会把这个日期都变了

01:15:36.550 --> 01:15:37.550
你这样一设置年

01:15:37.550 --> 01:15:38.550
是不是把这个日期都变了

01:15:38.550 --> 01:15:40.550
而这个生日的日期

01:15:40.550 --> 01:15:42.550
一会儿是不是还有可能会用到

01:15:42.550 --> 01:15:43.550
还有可能在这儿

01:15:43.550 --> 01:15:44.550
可能还会用到

01:15:44.550 --> 01:15:46.550
所以我不希望改动这个东西

01:15:46.550 --> 01:15:48.550
我希望你给我返回一个新的

01:15:48.550 --> 01:15:49.550
不要改动这个玩意

01:15:50.550 --> 01:15:51.550
不然的话你一定要不要说

01:15:51.550 --> 01:15:53.550
我设置成2021年

01:15:53.550 --> 01:15:54.550
那么它就把这个日期

01:15:54.550 --> 01:15:55.550
都给我改了

01:15:55.550 --> 01:15:57.550
我是不希望看到的

01:15:57.550 --> 01:15:58.550
所以说怎么办呢

01:15:58.550 --> 01:16:00.550
我要把这个日期复制一下

01:16:00.550 --> 01:16:01.550
怎么复制

01:16:01.550 --> 01:16:02.550
非常简单

01:16:02.550 --> 01:16:03.550
moment

01:16:03.550 --> 01:16:05.550
里面包一个原来的moment

01:16:05.550 --> 01:16:07.550
它就会复制一个新的moment

01:16:08.550 --> 01:16:13.550
之所以要包一个moment

01:16:13.550 --> 01:16:18.550
是不希望改动原来的

01:16:18.550 --> 01:16:20.550
不能把这个变量给我改了

01:16:20.550 --> 01:16:23.550
我这样子的就得到一个新的日期

01:16:23.550 --> 01:16:25.550
这个日期跟原来的一模一样

01:16:25.550 --> 01:16:26.550
我们之后改了

01:16:26.550 --> 01:16:27.550
改的是这个新的日期

01:16:27.550 --> 01:16:28.550
没意思吧

01:16:28.550 --> 01:16:29.550
是它的免份

01:16:29.550 --> 01:16:30.550
免份为什么呢

01:16:30.550 --> 01:16:31.550
到底不能写死

01:16:31.550 --> 01:16:32.550
不然的话你到了2021年

01:16:32.550 --> 01:16:34.550
这个程序就不能用了

01:16:34.550 --> 01:16:36.550
因为到时候要写2022了

01:16:36.550 --> 01:16:37.550
那么应该得到什么呢

01:16:37.550 --> 01:16:40.550
得到是今年的免份

01:16:40.550 --> 01:16:41.550
我们可以用特带

01:16:41.550 --> 01:16:42.550
对吧

01:16:42.550 --> 01:16:44.550
今天的什么呢

01:16:44.550 --> 01:16:49.550
把生日这个日期的点

01:16:49.550 --> 01:16:53.550
设置为今天的点

01:16:53.550 --> 01:16:54.550
加1

01:16:54.550 --> 01:16:58.180
这句话能理解吗

01:16:58.180 --> 01:17:00.180
能理解的话QQE

01:17:00.180 --> 01:17:01.180
这就算出来了

01:17:01.180 --> 01:17:05.500
明年的生日

01:17:05.500 --> 01:17:09.580
next birth

01:17:09.580 --> 01:17:11.580
next year birth

01:17:11.580 --> 01:17:13.580
这是计算明年的生日

01:17:13.580 --> 01:17:17.780
明年的生日算出来了

01:17:17.780 --> 01:17:18.780
那剩下的就是

01:17:18.780 --> 01:17:19.780
见个多少天了

01:17:19.780 --> 01:17:20.780
对吧

01:17:20.780 --> 01:17:21.780
非常简单了

01:17:21.780 --> 01:17:22.780
多少天呢

01:17:22.780 --> 01:17:25.780
next year birth

01:17:25.780 --> 01:17:26.780
然后呢

01:17:26.780 --> 01:17:30.780
相对于今年

01:17:30.780 --> 01:17:32.780
经过的天数

01:17:32.780 --> 01:17:34.780
那么剩下的就是

01:17:34.780 --> 01:17:40.140
其实

01:17:40.140 --> 01:17:41.140
实际上

01:17:41.140 --> 01:17:43.140
这个是你还有多少这个

01:17:43.140 --> 01:17:48.460
还有

01:17:48.460 --> 01:17:55.120
这里是

01:17:55.120 --> 01:17:56.120
银烂的多少生日呢

01:17:56.120 --> 01:17:57.120
一起加1

01:17:57.120 --> 01:18:02.580
再加上p4

01:18:02.580 --> 01:18:03.580
再看啊

01:18:03.580 --> 01:18:04.580
现在呢

01:18:04.580 --> 01:18:05.580
我们要说啊

01:18:05.580 --> 01:18:09.950
这边写上

01:18:09.950 --> 01:18:14.950
2020年8月27

01:18:14.950 --> 01:18:15.950
还有364

01:18:15.950 --> 01:18:16.950
比方说这里的

01:18:16.950 --> 01:18:18.950
再设置10月

01:18:18.950 --> 01:18:19.950
未来时间的不对了

01:18:19.950 --> 01:18:20.950
对吧

01:18:20.950 --> 01:18:22.950
2000年10月27

01:18:22.950 --> 01:18:23.950
哎

01:18:23.950 --> 01:18:24.950
有问题

01:18:24.950 --> 01:18:25.950
这个地方有问题

01:18:25.950 --> 01:18:26.950
好

01:18:26.950 --> 01:18:27.950
这里有出现有出现

01:18:27.950 --> 01:18:30.390
有出现问题了

01:18:30.390 --> 01:18:31.390
这也不对对吧

01:18:31.390 --> 01:18:32.390
这个也不对

01:18:32.390 --> 01:18:33.390
为什么呢

01:18:33.390 --> 01:18:34.390
如果说我这里

01:18:34.390 --> 01:18:35.390
我们刚才都没有发

01:18:35.390 --> 01:18:36.390
就没有发现这个问题

01:18:36.390 --> 01:18:38.390
如果说我直接算

01:18:38.390 --> 01:18:39.390
明年的生日

01:18:39.390 --> 01:18:41.390
就会遇到这种情况

01:18:41.390 --> 01:18:43.390
我今年的生日还没有过

01:18:43.390 --> 01:18:45.390
是不是

01:18:45.390 --> 01:18:46.390
是不是今年的生日

01:18:46.390 --> 01:18:47.390
我有可能还没有过

01:18:47.390 --> 01:18:49.390
如果说今年的生日

01:18:49.390 --> 01:18:50.390
没有过的话

01:18:50.390 --> 01:18:51.390
哎

01:18:51.390 --> 01:18:52.390
我是不是应该

01:18:52.390 --> 01:18:54.390
按今年的生日来算啊

01:18:54.390 --> 01:18:55.390
对吧

01:18:55.390 --> 01:18:56.390
所以说我这里要算的

01:18:56.390 --> 01:18:57.390
不是明年的生日

01:18:57.390 --> 01:19:01.390
而是下一个生日的时间

01:19:01.390 --> 01:19:02.390
我要算的是怎么呢

01:19:02.390 --> 01:19:03.390
我要算的是

01:19:03.390 --> 01:19:04.390
next

01:19:04.390 --> 01:19:06.390
first

01:19:06.390 --> 01:19:08.390
下一个生日的时间

01:19:08.390 --> 01:19:10.390
它不一定是明年的

01:19:10.390 --> 01:19:11.390
有可能今年的生日

01:19:11.390 --> 01:19:12.390
还没有到

01:19:12.390 --> 01:19:13.390
还没有过

01:19:13.390 --> 01:19:14.390
那么这个东西又怎么算呢

01:19:14.390 --> 01:19:15.390
啊

01:19:15.390 --> 01:19:16.390
有稍微的麻烦一点

01:19:16.390 --> 01:19:17.390
其实一个判断就行了

01:19:17.390 --> 01:19:20.390
就判断今年的生日过美国

01:19:20.390 --> 01:19:22.390
就判断今年的生日过美国

01:19:22.390 --> 01:19:23.390
啊

01:19:23.390 --> 01:19:24.390
第一个变量啊

01:19:24.390 --> 01:19:26.390
叫做今年的生日啊

01:19:26.390 --> 01:19:27.390
this year birth

01:19:27.390 --> 01:19:33.460
这是今年的生日

01:19:33.460 --> 01:19:35.460
今年的生日

01:19:35.460 --> 01:19:36.460
今年的生日是不是很好算

01:19:36.460 --> 01:19:37.460
刚才已经算了

01:19:37.460 --> 01:19:38.460
明年的生日了

01:19:38.460 --> 01:19:39.460
今年的生日一下就算出来了

01:19:39.460 --> 01:19:40.460
就不加一就完事了

01:19:40.460 --> 01:19:41.460
对吧

01:19:41.460 --> 01:19:43.460
这是今年的生日

01:19:43.460 --> 01:19:44.460
今年的生日

01:19:44.460 --> 01:19:46.460
那么今年的生日过美国呢

01:19:46.460 --> 01:19:47.460
是不是可以判断

01:19:47.460 --> 01:19:49.460
this year

01:19:49.460 --> 01:19:51.460
当前的生日

01:19:51.460 --> 01:19:55.770
这个生日是不是大于特定

01:19:55.770 --> 01:19:56.770
大于特定

01:19:56.770 --> 01:19:58.770
大于的过后是不是

01:19:58.770 --> 01:20:01.770
还没有过

01:20:01.770 --> 01:20:02.770
对吧

01:20:02.770 --> 01:20:04.770
今年的生日还没有到

01:20:04.770 --> 01:20:05.770
那么这个时候呢

01:20:05.770 --> 01:20:07.770
next birth

01:20:07.770 --> 01:20:11.770
是不是就等于this year first

01:20:11.770 --> 01:20:12.770
对吧

01:20:12.770 --> 01:20:14.770
那么下一个生日就是今年的生日

01:20:14.770 --> 01:20:17.770
下一个生日就是今年的生日

01:20:17.770 --> 01:20:18.770
这俩稍微绕一下啊

01:20:18.770 --> 01:20:19.770
l

01:20:19.770 --> 01:20:21.770
如果说今年的生日

01:20:21.770 --> 01:20:22.770
小于等于呢

01:20:22.770 --> 01:20:23.770
这地是不是已经过了

01:20:23.770 --> 01:20:24.770
或者要么就是

01:20:24.770 --> 01:20:25.770
今年的生日

01:20:25.770 --> 01:20:27.770
要么就是之前的生日

01:20:27.770 --> 01:20:28.770
所以以过

01:20:28.770 --> 01:20:29.770
今年的生日以过

01:20:29.770 --> 01:20:30.770
那么这个时候呢

01:20:30.770 --> 01:20:31.770
next birth

01:20:31.770 --> 01:20:32.770
要等于什么呢

01:20:32.770 --> 01:20:37.100
等于明年的生日

01:20:37.100 --> 01:20:38.100
对不对

01:20:38.100 --> 01:20:39.100
总之呢

01:20:39.100 --> 01:20:40.100
next birth表示下一个生日

01:20:40.100 --> 01:20:41.100
有可能在今年

01:20:41.100 --> 01:20:42.100
有可能在明年

01:20:42.100 --> 01:20:43.100
刚才没有考虑完整

01:20:43.100 --> 01:20:44.100
对吧

01:20:44.100 --> 01:20:45.100
那么这里来把考虑完整

01:20:45.100 --> 01:20:46.100
算天的时候

01:20:46.100 --> 01:20:47.100
是下一个生日

01:20:47.100 --> 01:20:48.100
到今天的去

01:20:48.100 --> 01:20:50.100
一看

01:20:50.100 --> 01:20:52.100
2000年

01:20:52.100 --> 01:20:54.100
10月1号

01:20:54.100 --> 01:20:55.100
还有34天

01:20:55.100 --> 01:20:56.100
对吧

01:20:56.100 --> 01:20:57.100
到今年算的

01:20:57.100 --> 01:20:58.100
那如果说今年的生日过了呢

01:20:58.100 --> 01:20:59.100
8月1号

01:20:59.100 --> 01:21:01.100
就是按照明年的生日来算的

01:21:01.100 --> 01:21:03.100
这个小小的细节

01:21:06.100 --> 01:21:07.100
再来

01:21:07.100 --> 01:21:08.100
最后一个了

01:21:08.100 --> 01:21:09.100
最后一个就是

01:21:09.100 --> 01:21:13.610
你已在某一天过了生日

01:21:13.610 --> 01:21:16.610
还有一个情况就是

01:21:16.610 --> 01:21:19.610
你将在迎来的下一个生日

01:21:19.610 --> 01:21:22.610
说的语句都不一样了

01:21:22.610 --> 01:21:26.050
复制一下

01:21:26.050 --> 01:21:28.050
你已在

01:21:28.050 --> 01:21:29.050
过

01:21:29.050 --> 01:21:31.050
还有另外一种说法

01:21:31.050 --> 01:21:36.450
9月1号

01:21:36.450 --> 01:21:37.450
你将在

01:21:37.450 --> 01:21:38.450
对吧

01:21:38.450 --> 01:21:39.450
说法都不一样了

01:21:39.450 --> 01:21:40.450
那么也就是说

01:21:40.450 --> 01:21:41.450
这个P5

01:21:41.450 --> 01:21:42.450
这个P5

01:21:42.450 --> 01:21:43.450
它不一定的

01:21:43.450 --> 01:21:45.450
关键是生日过没过

01:21:45.450 --> 01:21:47.450
是不是又来判断

01:21:47.450 --> 01:21:48.450
生日过没过呢

01:21:48.450 --> 01:21:51.450
判断今年的生日

01:21:51.450 --> 01:21:52.450
是不是大于

01:21:52.450 --> 01:21:55.450
是不是生日还没过

01:21:55.450 --> 01:21:58.450
生日没有过

01:21:58.450 --> 01:22:00.450
L

01:22:00.450 --> 01:22:03.450
什么生日已经过了

01:22:03.450 --> 01:22:04.450
生日没有过的话

01:22:04.450 --> 01:22:05.450
它的文本是什么呢

01:22:05.450 --> 01:22:06.450
P5的文本

01:22:06.450 --> 01:22:08.450
文本是

01:22:08.450 --> 01:22:10.450
这个

01:22:10.450 --> 01:22:16.060
以将在

01:22:16.060 --> 01:22:17.060
这里说是

01:22:17.060 --> 01:22:19.060
那么将在这个地方

01:22:19.060 --> 01:22:20.060
这个地方写什么呢

01:22:20.060 --> 01:22:21.060
这个地方它的情况很多

01:22:21.060 --> 01:22:22.060
情况很多

01:22:22.060 --> 01:22:24.060
有星期的

01:22:24.060 --> 01:22:25.060
还有什么呢

01:22:25.060 --> 01:22:27.060
还有今天是8月28

01:22:27.060 --> 01:22:28.060
8月29的话

01:22:28.060 --> 01:22:29.060
有明天

01:22:29.060 --> 01:22:30.060
对吧

01:22:30.060 --> 01:22:31.060
还有各种不同的文本

01:22:31.060 --> 01:22:32.060
那么这种文本呢

01:22:32.060 --> 01:22:33.060
在这里边

01:22:33.060 --> 01:22:35.060
在这

01:22:35.060 --> 01:22:36.060
显示

01:22:36.060 --> 01:22:38.060
显示里边有个叫Client日利

01:22:38.060 --> 01:22:40.060
它显示日利

01:22:40.060 --> 01:22:42.060
就根据当前时间来显示日利

01:22:42.060 --> 01:22:45.060
或者是根据一个指定的时间

01:22:45.060 --> 01:22:46.060
就是你这个日期

01:22:46.060 --> 01:22:48.060
到这个指定的时间

01:22:48.060 --> 01:22:50.060
它的差值

01:22:50.060 --> 01:22:51.060
那么用一个

01:22:51.060 --> 01:22:52.060
比较友好的文本来表示

01:22:52.060 --> 01:22:53.060
比较上个星期

01:22:53.060 --> 01:22:54.060
它就会这样的显示

01:22:54.060 --> 01:22:55.060
前一天就会这样的显示

01:22:55.060 --> 01:22:56.060
同一天

01:22:56.060 --> 01:22:57.060
就今天

01:22:57.060 --> 01:22:58.060
下一天就是明天

01:22:58.060 --> 01:22:59.060
对吧

01:22:59.060 --> 01:23:00.060
它会把时间给你显示出来

01:23:00.060 --> 01:23:01.060
明白了意思吧

01:23:01.060 --> 01:23:02.060
也就是说

01:23:02.060 --> 01:23:03.060
这个地方的文本

01:23:03.060 --> 01:23:04.060
这个地方的文本呢

01:23:04.060 --> 01:23:05.060
非常简单

01:23:05.060 --> 01:23:06.060
就是你

01:23:06.060 --> 01:23:07.060
用那个什么

01:23:07.060 --> 01:23:10.060
我要计算那个生日

01:23:10.060 --> 01:23:11.060
今年的生日

01:23:11.060 --> 01:23:13.060
今年的生日

01:23:13.060 --> 01:23:16.060
用什么Client点

01:23:16.060 --> 01:23:21.810
到当前时间的日利

01:23:21.810 --> 01:23:26.810
得到今年的生日的日利显示

01:23:26.810 --> 01:23:27.810
那么这里

01:23:27.810 --> 01:23:28.810
这个地方

01:23:28.810 --> 01:23:29.810
拼接上卡

01:23:29.810 --> 01:23:30.810
好

01:23:30.810 --> 01:23:31.810
下边

01:23:31.810 --> 01:23:32.810
生日已经过了

01:23:32.810 --> 01:23:34.810
你将在

01:23:34.810 --> 01:23:36.810
你已在

01:23:36.810 --> 01:23:43.100
过了生日

01:23:43.100 --> 01:23:45.100
这里加上一个P5

01:23:45.100 --> 01:23:46.100
好

01:23:46.100 --> 01:23:47.100
看一下这个卡

01:23:47.100 --> 01:23:48.100
看一下这个辩量

01:23:48.100 --> 01:23:50.100
这边

01:23:50.100 --> 01:23:51.100
这里

01:23:51.100 --> 01:23:53.100
2000年

01:23:53.100 --> 01:23:55.100
8月

01:23:55.100 --> 01:23:57.100
29号

01:23:57.100 --> 01:23:58.100
所以明天

01:23:58.100 --> 01:23:59.100
你那里的下一个生日

01:23:59.100 --> 01:24:00.100
那么如果说

01:24:00.100 --> 01:24:01.100
这里是28号

01:24:01.100 --> 01:24:02.100
你在今天过了生日

01:24:02.100 --> 01:24:03.100
对吧

01:24:03.100 --> 01:24:04.100
27号

01:24:04.100 --> 01:24:05.100
你在昨天过了生日

01:24:05.100 --> 01:24:06.100
如果说

01:24:06.100 --> 01:24:07.100
你认可到一周

01:24:07.100 --> 01:24:08.100
他就会写

01:24:08.100 --> 01:24:11.100
26本周三

01:24:11.100 --> 01:24:12.100
对吧

01:24:12.100 --> 01:24:13.100
你看看

01:24:13.100 --> 01:24:15.100
原来的意思吧

01:24:15.100 --> 01:24:16.100
就这么个意思

01:24:16.100 --> 01:24:18.100
就这么个意思

01:24:18.100 --> 01:24:19.100
好

01:24:19.100 --> 01:24:20.100
那么现在呢

01:24:20.100 --> 01:24:21.100
就是说

01:24:21.100 --> 01:24:22.100
这里边呢

01:24:22.100 --> 01:24:24.100
我不希望他显示这个时间

01:24:24.100 --> 01:24:25.100
那么怎么办呢

01:24:25.100 --> 01:24:26.100
他这里边

01:24:26.100 --> 01:24:27.100
这个Client点

01:24:27.100 --> 01:24:28.100
他还可以给格式

01:24:28.100 --> 01:24:30.100
给不同的格式

01:24:30.100 --> 01:24:32.100
就掉入Client点的时候呢

01:24:32.100 --> 01:24:33.100
第一个参数

01:24:33.100 --> 01:24:34.100
你可以写

01:24:34.100 --> 01:24:35.100
可以不写

01:24:35.100 --> 01:24:36.100
表示当前时间

01:24:36.100 --> 01:24:37.100
就这个这一天

01:24:37.100 --> 01:24:38.100
到

01:24:38.100 --> 01:24:39.100
根据当前时间

01:24:39.100 --> 01:24:40.100
到这一天的距离

01:24:40.100 --> 01:24:41.100
来算出一个

01:24:41.100 --> 01:24:42.100
比较友好的文字

01:24:42.100 --> 01:24:43.100
如果说你

01:24:43.100 --> 01:24:44.100
写这里的

01:24:44.100 --> 01:24:45.100
也可以写另外一个日期

01:24:45.100 --> 01:24:46.100
也可以

01:24:46.100 --> 01:24:47.100
第二个参数是可以给

01:24:47.100 --> 01:24:48.100
配置格式

01:24:48.100 --> 01:24:50.100
如果说是同一天的话

01:24:50.100 --> 01:24:51.100
你显示什么呢

01:24:51.100 --> 01:24:52.100
就显示今天

01:24:52.100 --> 01:24:53.100
我就不要显示

01:24:53.100 --> 01:24:54.100
什么小时分钟了

01:24:54.100 --> 01:24:56.100
如果说是下一天呢

01:24:56.100 --> 01:24:58.100
你又显示明天

01:24:58.100 --> 01:25:02.300
如果说是

01:25:02.300 --> 01:25:03.300
下个星期呢

01:25:03.300 --> 01:25:05.300
你就把星期显示出来

01:25:05.300 --> 01:25:07.300
上一个

01:25:07.300 --> 01:25:09.300
上一天就显示昨天

01:25:09.300 --> 01:25:11.300
那么上一个

01:25:11.300 --> 01:25:13.300
上一个某个星期呢

01:25:13.300 --> 01:25:14.300
就把星期显示出来就行了

01:25:14.300 --> 01:25:15.300
滴滴滴就是星期

01:25:15.300 --> 01:25:17.300
然后其他情况下

01:25:17.300 --> 01:25:18.300
我就正常显示

01:25:18.300 --> 01:25:21.000
年

01:25:21.000 --> 01:25:22.000
月

01:25:22.000 --> 01:25:23.000
日

01:25:23.000 --> 01:25:24.000
什么意思啊

01:25:24.000 --> 01:25:26.000
就可以规定他的格式

01:25:26.000 --> 01:25:27.000
不然的话

01:25:27.000 --> 01:25:28.000
还有个默认格式

01:25:28.000 --> 01:25:29.000
默认格式是要把

01:25:29.000 --> 01:25:30.000
时间分钟都要带出来的

01:25:30.000 --> 01:25:31.000
好

01:25:31.000 --> 01:25:32.000
那么这样子就没问题了

01:25:32.000 --> 01:25:35.380
2000

01:25:35.380 --> 01:25:37.380
10月1号

01:25:39.380 --> 01:25:40.380
然后呢

01:25:40.380 --> 01:25:43.380
8月29号

01:25:43.380 --> 01:25:44.380
明天

01:25:44.380 --> 01:25:46.940
好

01:25:46.940 --> 01:25:47.940
这就是这个默认格式

01:25:47.940 --> 01:25:48.940
滴滴滴的使用啊

01:25:48.940 --> 01:25:49.940
大家可以去看一下

01:25:49.940 --> 01:25:50.940
它的文道啊

01:25:50.940 --> 01:25:51.940
还有很多很多好玩的东西

01:25:51.940 --> 01:25:53.940
我们今天就讲到这了

