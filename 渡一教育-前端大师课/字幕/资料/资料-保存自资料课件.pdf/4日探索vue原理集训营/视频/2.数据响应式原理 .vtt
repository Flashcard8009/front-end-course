WEBVTT

00:00.000 --> 00:01.280
好 咱们开始啊

00:01.800 --> 00:03.840
来讲咱们今天的核心内容

00:04.860 --> 00:08.200
今天讲什么呢 我们今天会讲一个伍佑里边

00:08.700 --> 00:10.500
注意重要的一个模块

00:11.000 --> 00:12.280
就是数据想要式

00:13.820 --> 00:16.900
这个模块应该说是伍佑里边设计的

00:17.160 --> 00:18.940
注意精妙的一个系统

00:19.460 --> 00:21.500
伍佑就好像是一个精密的机器

00:21.760 --> 00:22.780
一个精妙的机器

00:23.300 --> 00:24.320
非常的智能

00:24.580 --> 00:27.660
我们用起来的特别的好用 对吧 里面都用过伍佑

00:28.420 --> 00:30.480
学习的时候有好学 有好用

00:30.980 --> 00:33.300
那么其实它里边的东西挺复杂的

00:33.800 --> 00:37.380
它里面其实它最复杂的设计到最精妙的

00:37.640 --> 00:38.920
也就是它的想用式系统

00:39.440 --> 00:42.500
那么我们今天呢 可以通过学习这个想用式系统

00:43.020 --> 00:46.340
能够一方面的能够解决 以后遇到

00:46.600 --> 00:47.880
这样的类似的面试题

00:48.660 --> 00:51.980
有些东西遇到面试题 老师只是几句话就给他打发了

00:52.500 --> 00:53.260
就很尴尬

00:53.720 --> 00:57.060
我们尽量多聊一点 多听一下咱们杜依的课

00:57.060 --> 00:58.340
你会发现面试题的时候

00:58.840 --> 01:01.920
回答面试题的时候可以聊的东西越来越多

01:02.420 --> 01:03.460
这东西聊不完的

01:04.220 --> 01:06.260
而且你聊的越深你会发现

01:06.520 --> 01:09.600
它里边东西还跟你一些其他的东西又关联起来了

01:10.360 --> 01:11.900
隐身的话就是无穷无尽

01:13.180 --> 01:14.960
一方面去应对这个面试题

01:15.220 --> 01:20.600
另一方面我们也可以学习啊 为了去设计这个想用式系统的一些思想

01:21.060 --> 01:24.800
还有一方面呢 就是我们能够帮助我们更加深入的去理解

01:25.060 --> 01:26.440
我以为它到底是什么运作的

01:27.460 --> 01:28.740
好吧 那我们就来看

01:29.780 --> 01:32.580
首先我解释一下啊 什么叫做

01:33.340 --> 01:34.120
想用式

01:35.140 --> 01:38.980
我们这里说的想用式可不是CSS3那边那个没见查群啊

01:38.980 --> 01:40.260
有同学学过CSS3

01:40.780 --> 01:44.360
有一个没见查群做什么想用式页面 那个东西跟这个没关系啊

01:44.620 --> 01:46.420
这个东西叫做数据想用式

01:48.620 --> 01:49.580
数据想用式

01:50.580 --> 01:52.640
仔细听啊 慢慢给你强调的思想

01:54.040 --> 01:55.880
怎么叫做数据想用式呢

01:56.480 --> 02:00.640
你看啊 咱们的维尤里边呢 有一个非常鲜明的一个特点

02:01.240 --> 02:03.880
这跟其他的前动怀上都不太一样

02:04.640 --> 02:05.400
来看一下吧

02:06.200 --> 02:07.640
我们就随便见一个页面吧

02:08.400 --> 02:09.080
DIV

02:09.400 --> 02:12.880
昨天其实大家 你只好学过维尤 你肯定是有过了解啊

02:12.880 --> 02:15.280
我们这里呢 就引用这个维尤的解释

02:15.280 --> 02:16.100
维尤的解释

02:22.810 --> 02:25.050
好 那么我们这里呢 去扭一个维尤

02:26.930 --> 02:28.370
创建一个维尤实力

02:28.730 --> 02:30.890
然后呢 这里边我们可以给他一些数据对吧

02:31.050 --> 02:33.770
这个数据的意思呢 就是说 我这个界面上

02:34.010 --> 02:38.490
这个组件里边 有哪些数据可能会跟显示相关

02:38.850 --> 02:39.810
那么就可以写到这儿

02:39.930 --> 02:42.930
比方说咱们这里有个标题啊 非常简单的写一个

02:43.050 --> 02:43.850
有个标题

02:44.290 --> 02:45.290
比方说叫

02:46.850 --> 02:47.290
哈喽

02:48.030 --> 02:48.550
维尤

02:49.670 --> 02:51.790
啊 这样子不就创建了一个维尤实力吗

02:52.030 --> 02:54.430
然后呢 我们这里呢 把它保存 保存那个变量里边

02:54.670 --> 02:57.750
保存到变量的目的呢 是以后我们调试的时候方便一点

02:58.630 --> 03:01.910
接下来呢 我们在这个DIV里面就写一些我们要显示的东西

03:02.030 --> 03:04.590
因为我们的数据跟我们的显示东西呢 是分开的

03:04.830 --> 03:07.550
这个玩意相当于是模拔 对吧 我们之前昨天讲过

03:07.790 --> 03:10.990
好 这边我们就写个A型元素 里边呢 写上一个标题

03:12.910 --> 03:13.350
开头

03:14.150 --> 03:15.110
非常的简单啊

03:15.350 --> 03:16.750
然后呢 这里把运行出来

03:20.930 --> 03:24.450
这里没显示啊 没显示出来是因为我这里没有写一个配置叫e

03:24.690 --> 03:26.450
表示这个维尤要控制哪一个

03:27.210 --> 03:28.770
要挂载到哪一个元素

03:29.210 --> 03:30.970
里边啊 ID为APP的元素

03:32.450 --> 03:34.250
好 保存啊 你看是不是显示出来了

03:35.010 --> 03:37.570
那也就是我们现在数据跟我们的界面是不是关联起来了

03:38.610 --> 03:42.210
而且呢 我们会发现 在我们的维尤实力里边啊 就在这个地方

03:42.370 --> 03:43.010
这个里边

03:43.610 --> 03:44.730
它有一个属像

03:44.970 --> 03:45.690
叫做抬头

03:46.010 --> 03:48.530
这个属像哪来的呢 它其实就是在来自于这

03:49.090 --> 03:49.890
来自于这个抬头

03:50.610 --> 03:52.090
我们可以看到这个属性的值呢

03:52.090 --> 03:53.410
就是我们刚才配置的这个值

03:53.410 --> 03:54.290
啊哈勒维尤

03:55.730 --> 03:57.930
那什么叫做数据想用式呢

03:58.730 --> 04:00.450
数据想用式的意思呢

04:00.890 --> 04:02.570
理面上的意思是这样子的

04:03.290 --> 04:06.650
就是我们如果说去改动了这个数据

04:07.330 --> 04:09.210
这是是不是一个数据 是一个数据吗

04:09.450 --> 04:11.810
我们去改动了数据呢 它会怎么样呢

04:12.050 --> 04:14.090
它会重新的渲染界面

04:14.610 --> 04:16.010
这就是数据想用式

04:16.370 --> 04:18.210
就看得见的 对吧 这是我们看得见的

04:18.210 --> 04:19.370
非常明显的一个效果

04:20.250 --> 04:21.850
但是呢 你在面试的时候

04:22.090 --> 04:24.730
也回答 首先你回答什么叫做数据想用式

04:25.090 --> 04:26.170
但是你不能这样说

04:26.850 --> 04:28.570
为什么这样 不能这样说呢

04:28.650 --> 04:30.170
因为这样子说不准确

04:31.450 --> 04:34.050
我尽管很多面试者都是这样说的啊

04:34.050 --> 04:36.090
问你什么叫做五幼的数据想用式

04:36.090 --> 04:37.610
就是数据变化了

04:37.730 --> 04:38.850
一面重新渲染

04:39.290 --> 04:41.530
对吧 或者是组建重新运行的轮段

04:41.770 --> 04:42.410
重新渲染

04:42.610 --> 04:44.730
尽管你可以这样说 但是呢 并不准确

04:45.330 --> 04:45.890
为什么呢

04:46.050 --> 04:49.690
因为五幼里边的数据想用式系统是高度抽象的

04:50.930 --> 04:54.170
有些同学可能就害怕这两个字 抽象

04:54.170 --> 04:54.970
其实你们

04:55.530 --> 04:56.810
我们作为一个人类

04:58.010 --> 05:00.410
之所以成为人类啊 跟其他动物有所不同

05:00.410 --> 05:02.130
就是因为我们特别善于抽象

05:02.370 --> 05:03.170
就是我们的

05:04.250 --> 05:08.090
说的自然语言 你们说的汉语 英语全都是抽象

05:09.050 --> 05:10.890
你看你们听来听来听这个课

05:11.250 --> 05:14.490
你们全凭我一张嘴

05:14.850 --> 05:16.850
别人讲 只有声音出来

05:16.850 --> 05:18.690
但是你们就理解我说的是什么意识

05:18.870 --> 05:19.310
为什么呢

05:19.310 --> 05:21.190
因为这些语言本身就是抽象

05:21.910 --> 05:23.190
像我跟你说一个苹果

05:23.710 --> 05:25.950
我又没有给哪一个苹果在你面前 不需要

05:26.190 --> 05:28.470
但是我就说出这两个字 发出这两个音

05:28.470 --> 05:29.670
你就知道我在说什么

05:30.470 --> 05:31.670
语言就是抽象

05:32.750 --> 05:34.430
因为抽象为什么要抽象呢

05:34.430 --> 05:35.630
计划机世界也是一样

05:36.350 --> 05:37.150
为什么要抽象

05:37.150 --> 05:39.550
因为抽象能够提取共同点

05:40.430 --> 05:42.310
能够极大的降低

05:43.590 --> 05:44.270
沟通成本

05:44.270 --> 05:46.750
像我们自然世界里边 人跟人之间的沟通成本

05:47.130 --> 05:48.610
可以不断地通过一些抽象

05:48.610 --> 05:49.690
一些专用名词

05:49.690 --> 05:49.970
对吧

05:49.970 --> 05:52.250
一些数语来进行降低

05:52.250 --> 05:53.290
降低这个沟通成本

05:54.890 --> 05:56.050
我们计划机世界里边

05:56.050 --> 05:57.570
跟计划机世界中的都是沟通成本

05:57.570 --> 05:59.250
我们也需要通过抽象来降低

06:00.650 --> 06:01.410
我又他去

06:01.410 --> 06:03.050
他怎么来看待这个事呢

06:03.050 --> 06:04.250
我们说回来 说远了

06:05.130 --> 06:06.610
我又他怎么来看待这个事呢

06:07.170 --> 06:09.170
就是他里面上是改动了数据

06:09.170 --> 06:10.250
我就要宣展界面

06:11.490 --> 06:13.850
那么我们再进一步想一想

06:14.730 --> 06:16.690
我们的数据是在哪里边的

06:16.750 --> 06:17.950
是不是在一个对象里边

06:18.710 --> 06:19.590
我们的数据是在这

06:20.710 --> 06:21.910
是不是在一个对象里边

06:21.910 --> 06:24.110
就是他原始数据是在一个对象里边

06:25.030 --> 06:27.270
好 那么我们就进一步抽象成为什么呢

06:27.270 --> 06:28.310
就把这句话

06:28.310 --> 06:30.630
就是我们一开始是这样想的啊

06:30.630 --> 06:33.030
改变了一个数据

06:34.710 --> 06:36.670
界面重新宣展

06:37.950 --> 06:38.470
对吧

06:38.470 --> 06:39.870
但是这句话呢不够抽象

06:41.790 --> 06:42.870
没有普世性

06:43.910 --> 06:46.270
那么我们把它进一步描述一下

06:46.330 --> 06:50.410
就是改变了对象的一个属性

06:52.810 --> 06:54.090
或者是改动了对象

06:54.650 --> 06:55.450
改变了对象

06:57.370 --> 07:00.090
然后界面重新宣展是什么意思啊

07:00.090 --> 07:01.130
什么叫重新宣展

07:01.130 --> 07:02.810
是不是运行了Render函数

07:03.290 --> 07:04.890
Render不是宣展函数吗

07:04.890 --> 07:06.050
我们昨天讲过的啊

07:06.050 --> 07:07.370
生存虚丽节点

07:07.370 --> 07:09.450
运行Render函数

07:10.610 --> 07:13.410
这样子说是不是更加准确一点了啊

07:13.410 --> 07:14.890
更加抽象一点了啊

07:14.890 --> 07:16.430
就是我不一定是改变这里的数据

07:16.430 --> 07:17.790
我可能是改变任何数据

07:17.790 --> 07:19.510
就是改变了一个对象

07:19.510 --> 07:20.390
那么这个对象呢

07:20.390 --> 07:22.390
他就他就会触发一个Render函数指向

07:24.150 --> 07:25.390
那么我们进一步再想

07:26.390 --> 07:28.830
他能够Render他无非就是一个函数而已

07:28.830 --> 07:29.030
对吧

07:29.030 --> 07:30.230
他没有什么特别的呀

07:30.230 --> 07:31.110
我们昨天也看到了

07:31.110 --> 07:32.630
Render函数没有什么特别的

07:32.630 --> 07:33.590
他里边传了一个函数

07:33.590 --> 07:34.590
A型来

07:34.590 --> 07:37.870
A型来也就是方便我们来创建虚拟动物的

07:37.870 --> 07:38.070
对吧

07:38.070 --> 07:39.590
你完全可以不用那个A型

07:39.590 --> 07:40.830
你自己去写个普隆函数

07:40.830 --> 07:43.710
你只要把那些属性填完也可以

07:43.770 --> 07:44.850
他并没有什么特别的

07:44.850 --> 07:47.290
所以我们进一步把它抽象成什么了

07:47.290 --> 07:48.570
改变了对象

07:50.410 --> 07:53.130
运行某些函数

07:54.810 --> 08:01.540
这叫数据想用式

08:01.540 --> 08:03.220
这叫数据想用式在五幼

08:03.220 --> 08:05.780
他的原码里边啊

08:05.780 --> 08:06.780
真正反映出来

08:06.780 --> 08:08.580
他要解决什么问题

08:08.580 --> 08:09.500
他要解决什么问题的

08:09.500 --> 08:13.140
无论他的数据想用式实际上是跟那些

08:13.140 --> 08:15.660
组建的一些东西其实关联不大的

08:15.680 --> 08:18.360
他其实就是在监控一个对象的变化

08:18.360 --> 08:19.760
这个对象一旦变了

08:19.760 --> 08:21.720
我要去运行某一些函数

08:23.440 --> 08:24.320
有点抽象了是吧

08:24.320 --> 08:26.560
那我们来给大家看一下

08:26.560 --> 08:28.560
给大家看一个比较实际的一个例子

08:28.560 --> 08:30.480
比方说我这个态度还是不变

08:30.480 --> 08:31.840
现在我们不用这个模板了

08:33.480 --> 08:35.320
以后这个DIV的保留啊

08:35.320 --> 08:37.160
不知道不然他不知道挂载到了

08:37.160 --> 08:39.640
现在我用一个Render函数的函数啊

08:39.640 --> 08:40.760
一个Render函数我们首先写过了

08:40.760 --> 08:41.040
对吧

08:41.040 --> 08:42.360
我们生成一个A型元数

08:43.340 --> 08:45.580
A型元数的内容就是ZS.Title

08:46.620 --> 08:48.460
那么这里呢我输出一下Render

08:48.460 --> 08:49.380
输出Render的目的呢

08:49.380 --> 08:51.300
就主要是为了让你们看得清楚

08:51.300 --> 08:52.660
这个Render函数也没有运行

08:53.660 --> 08:55.180
好现在呢我们来看一下

08:55.180 --> 08:56.220
是不是一开始运行了Render

08:56.220 --> 08:56.940
一开始要圈了

08:57.740 --> 08:57.980
对吧

08:57.980 --> 08:58.820
运行了Render

08:58.820 --> 09:00.460
然后接下来我们改变那个Title

09:03.120 --> 09:04.520
是不是Render重新运行了

09:04.520 --> 09:05.400
至于又输出了Render

09:06.040 --> 09:06.400
重新运

09:06.400 --> 09:07.760
这个很好理解吧

09:07.760 --> 09:08.320
对不对

09:08.320 --> 09:09.280
那么接下来我们再来看

09:10.320 --> 09:12.120
再来看一个有意思的

09:12.120 --> 09:13.640
我接下来我写一个生命周休函数

09:14.620 --> 09:16.540
当然我可以用一些别的生命周休函数

09:16.540 --> 09:16.780
这些可以

09:16.780 --> 09:17.340
无所谓

09:17.340 --> 09:18.260
我主要的目的呢

09:18.260 --> 09:21.220
是让要让他来运行一段代码

09:21.220 --> 09:22.620
这段码是这样的写的

09:22.620 --> 09:23.580
ZS.Warch

09:25.060 --> 09:25.740
这Warch呢

09:25.740 --> 09:27.380
你们应该没有学过啊

09:27.380 --> 09:28.820
我们有里边应该没有学过这个Warch

09:28.820 --> 09:30.220
那我今天说一下啊

09:30.220 --> 09:31.300
每一个组建里边

09:31.300 --> 09:33.620
它都有一个实力方法叫做Warch

09:33.620 --> 09:35.140
这个方法里边呢

09:35.140 --> 09:36.060
它的用法很多啊

09:36.060 --> 09:37.740
我这里就说一种用法

09:37.740 --> 09:39.980
它里边可以传一个函数进去

09:39.980 --> 09:42.140
我这里就写个箭头函数啊

09:42.140 --> 09:43.180
箭头函数里面得回

09:43.180 --> 09:45.560
它是基本功啊

09:45.560 --> 09:46.120
有学无诱

09:46.120 --> 09:48.360
不可能不能不会箭头函数

09:48.360 --> 09:50.560
那就那就搞笑了

09:51.680 --> 09:52.680
那么这里呢

09:52.680 --> 09:53.800
传的是一个函数啊

09:55.400 --> 09:56.600
这个函数里边呢

09:56.600 --> 09:57.000
比较多

09:57.000 --> 10:00.080
我就随便输出一个Warch

10:02.080 --> 10:04.760
这里我们输出ZS

10:04.760 --> 10:06.040
点开头

10:06.040 --> 10:06.840
输出一个标题

10:08.840 --> 10:10.480
在这里把输出一个标题

10:10.480 --> 10:11.080
这啥意思

10:11.080 --> 10:12.840
我给你简单简单说一下啊

10:12.900 --> 10:14.340
Warch是什么意思

10:14.340 --> 10:14.940
Warch呢

10:14.940 --> 10:16.100
就是它的意思呢

10:16.100 --> 10:18.540
就是传入一个函数

10:20.220 --> 10:20.980
一个函数

10:22.260 --> 10:26.420
它会立即运行改函数啊

10:26.420 --> 10:27.180
就这个意思

10:27.180 --> 10:29.020
它会立即运行改函数

10:29.020 --> 10:36.180
之后如果它里面的数据有变化

10:36.180 --> 10:37.500
会重新运行

10:38.740 --> 10:39.940
它就这个意思啊

10:39.940 --> 10:40.980
就它里边有什么数据

10:40.980 --> 10:42.420
是不是有这个Title数据

10:42.480 --> 10:44.520
那么这个数据将来会有变化

10:44.520 --> 10:45.960
那么它也会重新运行

10:45.960 --> 10:47.280
那么接下来我们再来看这个效果

10:48.400 --> 10:51.920
所以一开始就输出了Warcher,Rom,Holo,View

10:51.920 --> 10:53.160
然后又输出了Render

10:53.160 --> 10:54.520
所以这两个函数都运行了

10:54.520 --> 10:55.400
这个函数运行了吧

10:56.640 --> 10:58.160
这个函数运行了吧

10:58.160 --> 10:58.560
对不对

10:58.560 --> 11:00.040
现在我们来改动数据

11:00.040 --> 11:01.560
改动这个Title

11:01.560 --> 11:03.680
改成一个Nihao,View

11:03.680 --> 11:07.340
那么我们来看一下

11:07.340 --> 11:09.580
是不是两个函数又重新运行

11:09.580 --> 11:11.340
Warcher,Rom,Nihao,View

11:11.340 --> 11:13.020
然后运行了Render

11:13.040 --> 11:13.920
这说明了啥啊

11:15.040 --> 11:16.480
说明了啥

11:16.480 --> 11:18.600
说明了刚才我们说的是不是对的

11:18.600 --> 11:19.440
数据响应式

11:19.440 --> 11:21.440
它不仅仅是改变了一个数据

11:21.440 --> 11:23.280
就只运行个Render函数

11:23.280 --> 11:25.000
数据响应式是什么意思

11:25.000 --> 11:27.400
改变了一个对象

11:27.400 --> 11:29.080
我们先改动的是这个对象里边的东西

11:29.080 --> 11:29.640
对吧

11:29.640 --> 11:30.800
改变了这个对象

11:30.800 --> 11:33.240
它会运行某一些函数

11:34.800 --> 11:35.600
明白了意思吧

11:35.600 --> 11:37.120
它会运行某一些函数

11:37.120 --> 11:39.520
这才叫做数据响应式

11:39.520 --> 11:40.560
这些函数呢

11:40.620 --> 11:44.220
只不过我们见的比较多的是Render

11:44.220 --> 11:46.300
Render只是这一些函数中的一个

11:47.660 --> 11:48.700
这一块也没有理解

11:48.700 --> 11:49.580
理解了一块Q和E

11:51.020 --> 11:52.580
Q和E是神明周期函数

11:52.580 --> 11:54.340
就是它组建一开始的时候会运行

11:57.340 --> 12:00.180
就先把这个概念要认识准确

12:00.180 --> 12:01.980
如果说你不认识准确的话

12:01.980 --> 12:03.180
那你就觉得怪怪的

12:03.180 --> 12:05.180
特别是咱们后边去讲那个DEF的时候

12:05.180 --> 12:06.940
你就觉得更怪了

12:06.940 --> 12:08.740
它为什么要这样子写

12:08.740 --> 12:10.620
因为它可能会运行任何函数

12:10.640 --> 12:11.880
然后再加一个Whorl

12:13.280 --> 12:16.040
Whorl1,Worl2,Worl你看着

12:17.360 --> 12:18.700
那么一开始会输出三个

12:20.360 --> 12:21.000
输出三个

12:21.000 --> 12:22.920
然后改变,抬头

12:22.920 --> 12:23.560
改变了过后

12:24.880 --> 12:26.520
三个函数都会运行

12:26.520 --> 12:27.360
看到没

12:27.360 --> 12:27.880
这是

12:29.280 --> 12:30.600
这就是数据响应式

12:30.600 --> 12:32.600
它不是运行某一个特定的函数

12:35.160 --> 12:35.880
问号啥意思

12:35.880 --> 12:37.000
问号有什么问题要问

12:37.000 --> 12:37.840
问出来

12:37.840 --> 12:38.480
你给我打个问号

12:38.480 --> 12:39.720
我也不知道我怎么回答你

12:40.520 --> 12:41.920
我只能给你回三个感叹

12:42.380 --> 12:46.710
你说的很好

12:46.710 --> 12:50.710
好,接下来我们再来看这个面试期该怎么回答

12:50.710 --> 12:57.710
数据享用式的最终目标是当对象本身或者是对象属性发生变化的时候将会运行一些函数

12:57.710 --> 13:00.710
你把这个观点给编试官表达清楚

13:00.710 --> 13:05.710
那么只不过最常见的运行的函数是Render函数

13:05.710 --> 13:07.710
只是这么一回事

13:07.710 --> 13:10.710
好,那么回答这个题的时候你要回答出这么几个关键点

13:10.710 --> 13:14.710
一个是Observer,一个Stab,一个是Water,一个是Scheduler

13:14.710 --> 13:17.710
那么我一个个说啊,这些东西到底是啥

13:17.710 --> 13:20.710
首先呢,我们要解决的第一个问题

13:20.710 --> 13:22.710
你看我们一边给大家讲这个面试题

13:22.710 --> 13:26.710
我一边还会告诉大家它的设计思路是什么

13:26.710 --> 13:29.710
我们现在有了目标,我们的目标是什么

13:29.710 --> 13:31.710
改变了对象就要运行某一些函数

13:31.710 --> 13:33.710
但是这个目标好实现吗

13:33.710 --> 13:35.710
不好实现

13:35.710 --> 13:37.710
为什么不好实现,我们先拋开五六

13:37.710 --> 13:39.710
你看一下某一个代码

13:39.710 --> 13:42.710
你看那个问题还挺麻烦的

13:42.710 --> 13:44.710
我的目标现在跟五六没关系了

13:44.710 --> 13:46.710
就是改变了一个对象,我要运行函数

13:46.710 --> 13:48.710
那来吧,我现在有个对象

13:48.710 --> 13:50.710
这对象里边呢,有一个...

13:50.710 --> 13:52.710
我们反映一下Molica啊

13:52.710 --> 13:58.500
有一个Molica,这是对象

13:58.500 --> 14:00.500
然后呢,我又有一个函数

14:00.500 --> 14:03.870
没捨的

14:03.870 --> 14:05.870
我就输出吧,没捨的

14:05.870 --> 14:07.870
那么现在我要做的事情是啥

14:07.870 --> 14:11.870
我要做的事情呢,就是我还是写的一面啊

14:12.870 --> 14:27.460
我现在要做的目标就是

14:27.460 --> 14:30.460
如果说我改动了对象的属性

14:30.460 --> 14:33.460
它要自动地运行这个函数

14:33.460 --> 14:37.340
它要自动地运行这个函数

14:37.340 --> 14:39.340
你说这个东西怎么弄

14:39.340 --> 14:40.340
没发目

14:40.340 --> 14:42.340
你会发现真没发目

14:42.340 --> 14:44.340
因为这个GS

14:44.340 --> 14:47.340
它是悄无声息地给对象属性复职的

14:47.340 --> 14:49.340
你又不知道对象属性了

14:49.340 --> 14:51.340
这个对象属性什么时候会重新复职

14:51.340 --> 14:53.340
你并不知道

14:53.340 --> 14:54.340
所以说呢

14:54.340 --> 14:57.340
你什么时候去调用这个函数你根本就不知道

14:57.340 --> 14:58.340
那怎么办呢

14:58.340 --> 15:00.340
我又去怎么来设计这个东西的呢

15:00.340 --> 15:02.340
它是利用了ES5

15:02.340 --> 15:04.340
这个应该很多同学都知道

15:04.340 --> 15:05.340
叫数据结实,对吧

15:05.340 --> 15:09.340
它是利用了ES5里面的一个非常特殊的API

15:09.340 --> 15:12.340
叫做Object Define Property

15:12.340 --> 15:14.340
那我们来看一下这个API

15:14.340 --> 15:16.340
这个API特别有意思

15:16.340 --> 15:18.340
现在我们比方说

15:18.340 --> 15:20.340
我们用一个Object Define Property

15:20.340 --> 15:22.340
这是一个函数

15:22.340 --> 15:24.340
这个函数要传入这么几个函数

15:24.340 --> 15:26.340
给大家看一下吧

15:26.340 --> 15:27.340
我们先把A级

15:27.340 --> 15:29.340
我们先假设把A级去掉

15:29.340 --> 15:30.340
它传入这么几个函数

15:30.340 --> 15:32.340
第一个函数是对象

15:32.340 --> 15:34.340
第二个函数是属性的名字

15:34.340 --> 15:36.340
A级

15:36.340 --> 15:37.340
啥意思

15:37.340 --> 15:40.340
我要向这个对象里边定义一个属性

15:40.340 --> 15:42.340
你看这跟我们以前写法不一样了

15:42.340 --> 15:44.340
以前我们定义一个属性该咋写

15:44.340 --> 15:45.340
所以该写到这

15:45.340 --> 15:47.340
或者是写到哪呢

15:47.340 --> 15:49.340
或者是我们用这种方式

15:49.340 --> 15:51.340
都可以定义一个属性

15:51.340 --> 15:53.340
那么现在的定义属性

15:53.340 --> 15:55.340
它用的是这种方式

15:55.340 --> 15:57.340
这种方式定义属性

15:57.340 --> 15:59.340
跟我们之前的那种写法有什么区别呢

15:59.340 --> 16:02.780
它可以把这个属性

16:02.780 --> 16:04.780
给它进行一些配置

16:04.780 --> 16:06.780
配置是第三个函数

16:06.780 --> 16:07.780
是一个对象

16:07.780 --> 16:09.780
不是说这个属性只是一个对象

16:09.780 --> 16:11.780
只是针对这个属性做一些配置

16:11.780 --> 16:13.780
这个配置对象里边很多东西

16:13.780 --> 16:15.780
我不再去说了

16:15.780 --> 16:17.780
如果说没有学过这一块的话

16:17.780 --> 16:19.780
你们将来学到A15的话

16:19.780 --> 16:21.780
你们肯定会学习到这个东西

16:21.780 --> 16:23.780
我这里就说它两个配置

16:23.780 --> 16:25.780
其中一个配置叫做get

16:25.780 --> 16:27.780
这是一个函数

16:27.780 --> 16:29.780
这里我用这种写法了

16:29.780 --> 16:30.780
就相当于是这种写法

16:30.780 --> 16:31.780
是一样的

16:31.780 --> 16:33.780
这是ES6的一种锁写

16:33.780 --> 16:37.100
是一样的

16:37.100 --> 16:38.100
get函数

16:38.100 --> 16:39.100
这个函数什么意思呢

16:39.100 --> 16:40.100
当

16:40.100 --> 16:43.100
读取属性值时

16:43.100 --> 16:46.100
会运行该函数

16:46.100 --> 16:49.100
该函数的返回结果

16:50.100 --> 16:52.100
G属性值

16:53.100 --> 16:57.100
文凭把这个函数叫做get

16:57.100 --> 16:59.100
就这么个意思

16:59.100 --> 17:01.100
比方说我这个函数里面

17:01.100 --> 17:03.100
就输出一个get

17:03.100 --> 17:07.100
然后我返回一个17

17:07.100 --> 17:08.100
接下来我们来看一下

17:08.100 --> 17:10.100
输出一下OB戒

17:10.100 --> 17:11.100
来看一下OB戒

17:11.100 --> 17:12.100
或者我们的浏览器里面

17:12.100 --> 17:14.100
直接打印吧

17:14.100 --> 17:15.100
看一下浏览器里面

17:15.100 --> 17:16.100
只能打印看一个OB戒

17:16.100 --> 17:18.100
OB戒里面我们展开看一下

17:19.100 --> 17:20.100
对吧

17:20.100 --> 17:21.100
而且这个属性有点怪

17:21.100 --> 17:22.100
它是属性

17:22.100 --> 17:23.100
没有直接显示出来

17:23.100 --> 17:25.100
它直接变成三个底

17:25.100 --> 17:26.100
下面还有一个提示

17:26.100 --> 17:28.100
提示什么invoke

17:28.100 --> 17:29.100
invoke什么意思

17:29.100 --> 17:30.100
调用

17:30.100 --> 17:31.100
property什么意思

17:31.100 --> 17:32.100
属性getter

17:32.100 --> 17:33.100
什么意思

17:33.100 --> 17:34.100
就是让我们

17:34.100 --> 17:35.100
这个属性的

17:35.100 --> 17:36.100
现在的值是什么

17:36.100 --> 17:37.100
不知道

17:37.100 --> 17:39.100
不知道它的值是什么

17:39.100 --> 17:40.100
让我如果说

17:40.100 --> 17:41.100
你要查看它的值的话

17:41.100 --> 17:42.100
你这里可以点

17:42.100 --> 17:43.100
就是调试的时候

17:43.100 --> 17:44.100
你可以点击一下

17:44.100 --> 17:45.100
点击一下的时候

17:45.100 --> 17:47.100
它就会调用属性里面的

17:47.100 --> 17:48.100
getter方法

17:48.100 --> 17:50.100
它就会调用这个方法

17:50.100 --> 17:51.100
而把这个方法的

17:51.100 --> 17:52.100
返回结果

17:52.100 --> 17:53.100
作为它的属性值

17:53.100 --> 17:54.100
就这么个意思

17:54.100 --> 17:55.100
让我们点击一下

17:56.100 --> 17:57.100
是不是输出了17

17:58.100 --> 17:59.100
得到17

17:59.100 --> 18:00.100
并且你会看到

18:00.100 --> 18:01.100
这里打印出来一个get

18:01.100 --> 18:02.100
说明什么

18:02.100 --> 18:03.100
说明我们的get方法

18:03.100 --> 18:04.100
是运行的

18:04.100 --> 18:05.100
这里返回到17

18:05.100 --> 18:06.100
那么这里得到17

18:06.100 --> 18:07.100
那么换而言之

18:07.100 --> 18:08.100
如果说我们

18:08.100 --> 18:09.100
直接这样子写

18:09.100 --> 18:10.100
A级

18:10.100 --> 18:11.100
直接这样子写一回车

18:11.100 --> 18:12.100
得到结果是什么

18:13.100 --> 18:14.100
也是一样的

18:14.100 --> 18:16.100
你再读取属性值

18:16.100 --> 18:17.100
那么

18:17.100 --> 18:18.100
这个属性的返

18:18.100 --> 18:20.100
它就会运行getter

18:20.100 --> 18:22.100
它的返回结果17

18:24.100 --> 18:25.100
运行get

18:25.100 --> 18:27.100
getter返回结果17

18:27.100 --> 18:29.100
这就是属性的getter

18:29.100 --> 18:31.100
那么除了属性的getter之外

18:31.100 --> 18:34.100
它还有一个东西叫做setter

18:35.100 --> 18:37.100
它还有一个东西叫做setter

18:37.100 --> 18:38.100
这也是一个方法

18:38.100 --> 18:39.100
也是一个函数

18:39.100 --> 18:40.100
那么这个函数

18:40.100 --> 18:41.100
它还有一个参数

18:41.100 --> 18:42.100
这个函数是没参数的

18:42.100 --> 18:43.100
因为你读取属性值

18:43.100 --> 18:44.100
不需要参数

18:44.100 --> 18:45.100
直接读就行了

18:46.100 --> 18:48.100
那么这个参数

18:48.100 --> 18:50.100
就是你给它付的薪值

18:50.100 --> 18:51.100
比方说6W

18:51.100 --> 18:52.100
啥意思呢

18:52.100 --> 18:53.100
比方说我这两个这些

18:53.100 --> 18:55.100
我obgeta

18:55.100 --> 18:58.100
A级等于20

18:58.100 --> 18:59.100
那么这个时候

18:59.100 --> 19:00.100
这个20

19:00.100 --> 19:02.100
它就会作为参数

19:02.100 --> 19:04.100
传递给这个6W

19:04.100 --> 19:05.100
它就会调用这个set

19:05.100 --> 19:06.100
这是负值

19:06.100 --> 19:07.100
它不是读取值

19:07.100 --> 19:08.100
它是负值

19:08.100 --> 19:10.100
负值就会运行setter

19:10.100 --> 19:14.100
并且它会把你要付的值

19:14.100 --> 19:15.100
作为参数

19:15.100 --> 19:17.100
传给它

19:17.100 --> 19:18.100
然后运行这个函数

19:18.100 --> 19:20.100
直接把这个函数运行一遍

19:20.100 --> 19:21.100
就ok了

19:21.100 --> 19:22.100
那如果说同意

19:22.100 --> 19:23.100
有朋友说那如果说

19:23.100 --> 19:24.100
这里不写的不是20

19:24.100 --> 19:25.100
谁都是1乘1

19:25.100 --> 19:26.100
2

19:26.100 --> 19:27.100
1

19:27.100 --> 19:28.100
加2乘1

19:28.100 --> 19:29.100
3

19:29.100 --> 19:30.100
减去5

19:30.100 --> 19:32.100
它怎么传呢

19:32.100 --> 19:33.100
一样的

19:33.100 --> 19:34.100
它这是个表达式

19:34.100 --> 19:35.100
它会把表达式算出来

19:35.100 --> 19:36.100
1加6

19:36.100 --> 19:37.100
等于7

19:37.100 --> 19:38.100
7.5等于2

19:38.100 --> 19:39.100
那么它就会把这个2

19:39.100 --> 19:42.100
传递给这个6W

19:42.100 --> 19:43.100
明儿的意思吧

19:43.100 --> 19:44.100
那么也就是说

19:44.100 --> 19:46.100
当一个属性

19:46.100 --> 19:48.100
它有了getter和setter之后

19:48.100 --> 19:49.100
它就不再是一个正常的属性了

19:49.100 --> 19:51.100
它变得不太正常了

19:51.100 --> 19:54.100
你读取这个属性的时候

19:54.100 --> 19:56.100
它是运行一个函数

19:56.100 --> 19:57.100
你付值的时候

19:57.100 --> 19:59.100
它也是运行一个函数

19:59.100 --> 20:00.100
那么比方说

20:00.100 --> 20:04.100
这里我们就输出一个set

20:04.100 --> 20:05.100
那么这里我们就

20:05.100 --> 20:06.100
啥子不做

20:06.100 --> 20:07.100
啥子不做

20:07.100 --> 20:08.100
今天让我们来看一下

20:08.100 --> 20:10.100
obj.ag

20:10.100 --> 20:12.100
我这里一回车得到多少

20:12.100 --> 20:14.470
对吗

20:14.470 --> 20:15.470
17对不对

20:15.470 --> 20:16.470
17

20:16.470 --> 20:18.780
这个没问题吧

20:18.780 --> 20:19.780
它实际上

20:19.780 --> 20:21.780
这就换了你脑袋里边要想象成

20:21.780 --> 20:24.780
它在运行一个函数就是getter

20:24.780 --> 20:26.780
它运行那个函数

20:26.780 --> 20:27.780
这个函数的版图结果

20:27.780 --> 20:28.780
它当然是17

20:28.780 --> 20:29.780
你把它想象成这个东西

20:29.780 --> 20:30.780
就很容易理解了

20:30.780 --> 20:32.780
不得到结果是17

20:32.780 --> 20:33.780
然后呢

20:33.780 --> 20:34.780
我现在做这么一件事

20:34.780 --> 20:36.780
我给它付值为一个

20:36.780 --> 20:38.780
28吧

20:38.780 --> 20:40.780
比方说给它付值一个28

20:40.780 --> 20:41.780
那么它会运行什么

20:41.780 --> 20:42.780
运行set

20:42.780 --> 20:45.780
并且输出一下流报

20:45.780 --> 20:47.780
我给它付值28

20:47.780 --> 20:50.670
它会运行set

20:50.670 --> 20:51.670
对吧

20:51.670 --> 20:52.670
我会调问这个函数

20:52.670 --> 20:54.670
并且把28拿出参数传进去

20:54.670 --> 20:57.670
于是我们可以看到set28

20:57.670 --> 20:58.670
那么我先接下来问大家

20:58.670 --> 20:59.670
如果说我在这里

20:59.670 --> 21:02.670
再去得到这个A级得到多少呢

21:02.670 --> 21:03.670
得到多少

21:03.670 --> 21:09.930
你们说啊

21:09.930 --> 21:13.140
这个东西

21:13.140 --> 21:14.140
你不要把它想复杂了

21:14.140 --> 21:15.140
你这句话来干嘛呀

21:15.140 --> 21:16.140
你这句话

21:16.140 --> 21:18.140
实际上是在调用这个setter

21:18.140 --> 21:20.140
把28返进去

21:20.140 --> 21:22.140
那这个函数做了啥事呀

21:22.140 --> 21:23.140
它做了啥

21:23.140 --> 21:24.140
它就做了一个输出

21:24.140 --> 21:25.140
它还做了啥事

21:25.140 --> 21:26.140
啥都没做

21:26.140 --> 21:27.140
然后呢

21:27.140 --> 21:28.140
将来去调

21:28.140 --> 21:29.140
调用这个A级的时候

21:29.140 --> 21:30.140
它在做什么

21:30.140 --> 21:32.140
又在运行函数给它

21:32.140 --> 21:34.140
那么这个函数返回啥呀

21:34.140 --> 21:37.140
这个函数返回的不还是实行吗

21:37.140 --> 21:41.220
不还是实行吗

21:41.220 --> 21:42.220
不是啊

21:42.220 --> 21:43.220
不是啊

21:43.220 --> 21:44.220
不是

21:44.220 --> 21:45.220
不是这样子的

21:45.220 --> 21:47.220
我们平时用的这个负值啊

21:47.220 --> 21:48.220
这些东西

21:48.220 --> 21:49.220
负值啊

21:49.220 --> 21:50.220
这些东西都是正常的啊

21:50.220 --> 21:52.220
都是正常的属性

21:52.220 --> 21:53.220
那个

21:53.220 --> 21:54.220
跟这个不一样啊

21:54.220 --> 21:56.220
这个东西它就不再是一个正常的属性了

21:56.220 --> 21:58.220
它本质上变成两个函数了

21:58.220 --> 22:00.220
本质上把这个属性变成两个函数了

22:00.220 --> 22:01.220
直播写的时候呢

22:01.220 --> 22:03.220
还是按照属性的那种写法

22:03.220 --> 22:06.220
它本质上是一个函数了啊

22:06.220 --> 22:07.220
一般的意思吧

22:07.220 --> 22:08.220
所以说

22:08.220 --> 22:09.220
如果说我要用这种方式

22:09.220 --> 22:10.220
把它变成一个正常的属性

22:10.220 --> 22:11.220
得怎么样呢

22:11.220 --> 22:13.220
我得做一些处理

22:13.220 --> 22:14.220
比方说我这里呢

22:14.220 --> 22:16.220
写一个变量啊

22:16.220 --> 22:18.220
intelawade

22:18.220 --> 22:19.220
随便我们

22:19.220 --> 22:20.220
intelawade吧

22:20.220 --> 22:21.220
随便写个

22:21.220 --> 22:22.220
intelawade

22:22.220 --> 22:23.220
就内部的A级值

22:23.220 --> 22:24.220
比方说一台是17

22:24.220 --> 22:26.220
那么我这里返回这个变量

22:26.220 --> 22:27.220
那么set的时候呢

22:27.220 --> 22:28.220
我给这个变量复制

22:28.220 --> 22:29.220
复制为6吧

22:29.220 --> 22:30.220
这样子可以的

22:30.220 --> 22:31.220
这样子

22:31.220 --> 22:33.220
你就把它变成了

22:33.220 --> 22:35.220
看上去像是一个正常属性的啊

22:35.220 --> 22:36.220
只不过呢

22:36.220 --> 22:37.220
它还是不是正常属性

22:37.220 --> 22:39.220
还是不是正常属性啊

22:41.220 --> 22:42.220
你看啊

22:42.220 --> 22:43.220
这样子get的时候

22:43.220 --> 22:44.220
是不是返回17

22:44.220 --> 22:45.220
set的时候

22:45.220 --> 22:46.220
是不是给它重新复制

22:46.220 --> 22:48.220
比方说你给它复制28

22:48.220 --> 22:49.220
它是不是变成28了

22:49.220 --> 22:50.220
然后将来再get的时候

22:50.220 --> 22:51.220
是不是返回28了

22:51.220 --> 22:53.220
那么现在就没问题了

22:53.220 --> 22:54.220
再看一下

22:54.220 --> 22:55.220
obj-A级

22:55.220 --> 22:56.220
17对吧

22:56.220 --> 22:59.220
obj-A级等于28

22:59.220 --> 23:00.220
然后这样子呢

23:00.220 --> 23:01.220
这个值是不是变成28了

23:01.220 --> 23:02.220
你看一下这个值

23:02.220 --> 23:03.220
变成28了

23:03.220 --> 23:04.220
那么这样子

23:04.220 --> 23:05.220
再去读这个A级

23:05.220 --> 23:07.220
是不是返回了这个变量值

23:07.220 --> 23:08.220
返回来就28

23:08.220 --> 23:11.220
那么这样子是可以的啊

23:11.220 --> 23:12.220
你如果说你要把它变成一个

23:12.220 --> 23:14.220
看上去像一个正常属性

23:14.220 --> 23:15.220
你的样子的话

23:15.220 --> 23:16.220
你再用这种方式

23:16.220 --> 23:17.220
但它还是不是

23:17.220 --> 23:18.220
它仍然不是正常属性啊

23:18.220 --> 23:19.220
它毕竟是两个方法

23:19.220 --> 23:21.220
它毕竟是一个方法

23:21.220 --> 23:24.220
这个属性变成了两个方法了

23:24.220 --> 23:26.220
它不再是正常属性

23:26.220 --> 23:27.220
有的人说

23:27.220 --> 23:28.220
那这里能不能这样子写呢

23:28.220 --> 23:29.220
thisA级

23:29.220 --> 23:31.220
等于new one

23:31.220 --> 23:32.220
能不能这样子写呢

23:32.220 --> 23:33.220
同学们

23:33.220 --> 23:36.870
我都不说这里

23:36.870 --> 23:37.870
这里应该写啥了

23:37.870 --> 23:38.870
这里get应该写啥

23:38.870 --> 23:39.870
我都不说了

23:39.870 --> 23:41.870
那这里是能不能这样子写呢

23:41.870 --> 23:42.870
这样写是不行的啊

23:42.870 --> 23:44.870
为什么说这样子不写不行呢

23:44.870 --> 23:45.870
那咱们来看一下

23:46.870 --> 23:49.440
obj-a级

23:49.440 --> 23:50.440
等于20

23:53.140 --> 23:55.140
我觉得挺暗的

23:56.140 --> 23:57.140
不要再说了

23:59.700 --> 24:00.700
为什么会出现这种情况呢

24:01.700 --> 24:02.700
它有地规雕用

24:03.700 --> 24:04.700
你这句话实在干嘛呀

24:05.700 --> 24:06.700
是不是在运行setter

24:07.700 --> 24:08.700
因为你在给它复制

24:08.700 --> 24:09.700
对吧

24:09.700 --> 24:10.700
是不是给它复制

24:11.700 --> 24:13.700
这里的认识就是这个对象

24:13.700 --> 24:14.700
是不是给这个A级复制

24:14.700 --> 24:16.700
复制的话是不是要运行setter

24:16.700 --> 24:17.700
运行setter的时候

24:17.700 --> 24:18.700
是不是又要给A级复制

24:18.700 --> 24:19.700
又要复制的话

24:19.700 --> 24:20.700
是不是又要运行setter

24:20.700 --> 24:21.700
对吧

24:21.700 --> 24:22.700
是不是死去还了

24:23.700 --> 24:24.700
所以说这样子写不行了

24:24.700 --> 24:25.700
你得用这种方式

24:26.700 --> 24:27.700
说了半天我就想说这个

24:27.700 --> 24:29.700
那么我想说的是什么意思呢

24:29.700 --> 24:30.700
就是说

24:31.700 --> 24:32.700
你为什么要搞了半天

24:33.700 --> 24:34.700
搞成这个样子呢

24:35.700 --> 24:36.700
我们的目标

24:37.700 --> 24:39.700
就是不能让它是一个正常属性

24:39.700 --> 24:41.700
你是一个正常属性

24:41.700 --> 24:42.700
我是监听不到的

24:42.700 --> 24:44.700
就是你如果说你是一个正常属性

24:44.700 --> 24:46.700
我这里不去重新定义

24:47.700 --> 24:48.700
不去重新定义

24:49.700 --> 24:51.700
那么我将来给它属性复制也好

24:52.700 --> 24:53.700
读它的值也好

24:53.700 --> 24:54.700
我是不知道的

24:55.700 --> 24:57.700
鬼知道哪一天用复给它复了一个

24:57.700 --> 24:58.700
重新复了一个值

24:58.700 --> 24:59.700
我不知道

25:00.700 --> 25:01.700
我真得刷新

25:05.550 --> 25:06.550
用复比较重新复了一个值

25:06.550 --> 25:08.550
我根本就不知道重新复制的

25:08.550 --> 25:09.550
所以说呢

25:09.550 --> 25:11.550
我就没有办法去做一些别的事情

25:12.550 --> 25:13.550
而我们把它用这种方式

25:13.550 --> 25:14.550
去定义了过后

25:14.550 --> 25:15.550
这个属性不再是一个正常属性

25:15.550 --> 25:17.550
它变成两个方法了

25:17.550 --> 25:19.550
当你读这个属性的值的时候

25:19.550 --> 25:20.550
是不是我可以监听到

25:20.550 --> 25:22.550
我知道你在读这个属性的值

25:22.550 --> 25:23.550
比方说你这里

25:23.550 --> 25:25.550
你正在

25:26.550 --> 25:29.550
你正在读取A级属性

25:29.550 --> 25:32.550
我可以做一些别的事情

25:32.550 --> 25:34.550
那么做什么别的事情随便

25:34.550 --> 25:36.550
随便你要做什么别的事情都可以

25:36.550 --> 25:37.550
你是不是可以在这里写单码

25:37.550 --> 25:39.550
可以写很多很多的单码

25:39.550 --> 25:40.550
因为这是个方法

25:40.550 --> 25:41.550
对吧

25:42.550 --> 25:43.550
你看现在

25:43.550 --> 25:48.440
你还说运行这句话

25:48.440 --> 25:49.440
然后sets的时候呢

25:49.440 --> 25:51.440
我是不是也可以做一些别的事情

25:51.440 --> 25:52.440
比方说sets的时候

25:52.440 --> 25:53.440
我做什么事情呢

25:53.440 --> 25:55.440
我要调用mesh的

25:56.440 --> 25:57.440
我讲说啊

25:57.440 --> 25:58.440
调用这个mesh

26:00.440 --> 26:01.440
所以可以了

26:01.440 --> 26:02.440
你看

26:02.440 --> 26:03.440
接下来有一次现象就出现了

26:03.440 --> 26:04.440
A级

26:04.440 --> 26:05.440
我给它复作为10

26:05.440 --> 26:07.440
什么mesh的都被调用了

26:07.440 --> 26:08.440
这就是5u

26:08.440 --> 26:10.440
为什么能够监听到属性的电话

26:10.440 --> 26:11.440
你看5u这边

26:11.440 --> 26:14.440
我给这个type属性重新复制了

26:14.440 --> 26:15.440
复制到过去

26:15.440 --> 26:16.440
见面就变了

26:16.440 --> 26:18.440
那么它里面一定调用了某一个函数

26:18.440 --> 26:19.440
对吧

26:19.440 --> 26:21.440
是不是它里面一定调用了一些东西

26:21.440 --> 26:23.440
那么来看一下这个5u里面

26:23.440 --> 26:25.440
这个东西是不是数据想用式

26:25.440 --> 26:26.440
看一下是不是

26:26.440 --> 26:28.440
我们可以找到这个5u的实力

26:28.440 --> 26:29.440
vm

26:29.440 --> 26:31.440
vm里面找到一个title

26:31.440 --> 26:32.440
你看

26:33.440 --> 26:36.440
是不是跟我们刚才写的东西是一样的

26:36.440 --> 26:37.440
是一个想用式数据

26:37.440 --> 26:38.440
对吧

26:38.440 --> 26:39.440
它是要

26:39.440 --> 26:41.440
但有getter和setter的东西

26:41.440 --> 26:42.440
你点击过后

26:42.440 --> 26:43.440
它在读去

26:43.440 --> 26:44.440
调用getter

26:44.440 --> 26:45.440
然后运行

26:45.440 --> 26:46.440
把返回结果

26:46.440 --> 26:47.440
放照

26:47.440 --> 26:48.440
然后我们再看这个

26:48.440 --> 26:49.440
在我们的option是

26:49.440 --> 26:51.440
option是什么意思

26:51.440 --> 26:54.900
到这个地方

26:54.900 --> 26:56.900
已经把它变成那个了

26:56.900 --> 26:57.900
我们看不到了

26:57.900 --> 26:59.900
我们看这个吧

26:59.900 --> 27:00.900
看一下找一找

27:01.900 --> 27:02.900
这个data

27:02.900 --> 27:03.900
这个data实际上是什么了

27:03.900 --> 27:05.900
这个data就是我们这里配置的data

27:05.900 --> 27:07.900
就相对于是我们这里

27:07.900 --> 27:08.900
这里配置的data

27:08.900 --> 27:09.900
就这个对象

27:09.900 --> 27:10.900
那么这个对象

27:10.900 --> 27:12.900
它其实也变成想用式的

27:12.900 --> 27:13.900
你看title

27:13.900 --> 27:15.900
所以变成一个getter和setter

27:15.900 --> 27:16.900
你看getter title

27:16.900 --> 27:17.900
一个方法

27:17.900 --> 27:18.900
setter title

27:18.900 --> 27:19.900
一个方法

27:19.900 --> 27:20.900
那么点击过后

27:20.900 --> 27:21.900
它可以得到这个结果

27:21.900 --> 27:22.900
于是我们将来去

27:22.900 --> 27:23.900
其实我们将来去

27:23.900 --> 27:25.900
给它复制的时候

27:25.900 --> 27:26.900
它其实就是给它复制

27:26.900 --> 27:28.900
它是做了一个处理的

27:28.900 --> 27:30.900
那么给它复制的时候

27:30.900 --> 27:32.900
它就会做一些别的事情

27:32.900 --> 27:33.900
首先我们解决

27:33.900 --> 27:34.900
第一个问题

27:34.900 --> 27:35.900
就是它为什么

27:35.900 --> 27:37.900
能够监听到数据的变化

27:37.900 --> 27:41.410
首先说我们回到这儿来

27:41.410 --> 27:42.410
唯有它第一件事情

27:42.410 --> 27:43.410
就是Observer

27:43.410 --> 27:44.410
这个Observer

27:44.410 --> 27:45.410
什么意思

27:45.410 --> 27:46.410
叫观察者

27:46.410 --> 27:47.410
这件事情

27:47.410 --> 27:48.410
目标非常简单

27:48.410 --> 27:50.410
就是把一个普通的对象

27:50.410 --> 27:52.410
转换成想用式对象

27:52.410 --> 27:54.410
什么叫想用式对象呢

27:54.410 --> 27:55.410
想用式对象

27:55.410 --> 27:56.410
它里面每一个属性

27:56.410 --> 27:58.410
都不再是一个正常属性了

27:58.410 --> 27:59.410
它变成了

27:59.410 --> 28:01.410
就有一个getter和setter的属性

28:01.410 --> 28:02.410
它怎么做的呢

28:02.410 --> 28:03.410
其实这做法

28:03.410 --> 28:04.410
我们也可以想象得到

28:04.410 --> 28:05.410
它就是对这个属性的

28:05.410 --> 28:07.410
每一个属性的进行便利

28:07.410 --> 28:08.410
这个好多吧

28:08.410 --> 28:09.410
便利对象里面

28:09.410 --> 28:10.410
每一个属性

28:10.410 --> 28:12.410
然后对每一个属性

28:12.410 --> 28:13.410
通过Observer

28:13.410 --> 28:14.410
DefineProperty

28:14.410 --> 28:15.410
转换为

28:15.410 --> 28:17.410
把这个属性转换为

28:17.410 --> 28:18.410
带有getter和setter的属性

28:18.410 --> 28:19.410
那么这样一来呢

28:19.410 --> 28:20.410
当我们访问

28:20.410 --> 28:22.410
和设置这个属性的时候

28:22.410 --> 28:23.410
它就会运行get

28:23.410 --> 28:25.410
会运行set

28:25.410 --> 28:26.410
那么在getter

28:26.410 --> 28:27.410
setter里边

28:27.410 --> 28:28.410
是不是就有机会去

28:28.410 --> 28:29.410
做一些别的事情

28:29.410 --> 28:30.410
它就会有机会去

28:30.410 --> 28:31.410
做一些别的事情

28:34.410 --> 28:35.410
这里有张简单的图

28:35.410 --> 28:37.410
就是我们给它一个原式对象

28:37.410 --> 28:38.410
然后呢

28:38.410 --> 28:39.410
经过这个Observer

28:39.410 --> 28:40.410
这个Observer

28:40.410 --> 28:42.410
是用里边的东西

28:42.410 --> 28:43.410
是里边的一个构造函数

28:43.410 --> 28:44.410
在外面是用不了的

28:44.410 --> 28:46.410
它里边有个构造函数

28:46.410 --> 28:47.410
通过这个Observer

28:47.410 --> 28:48.410
就把这个对象就变了

28:48.410 --> 28:50.410
它就变成一个响音式对象了

28:50.410 --> 28:52.410
每一个属性都有getter和setter

28:52.410 --> 28:53.410
虽然说

28:53.410 --> 28:55.410
我们用不了这个Observer

28:55.410 --> 28:56.410
但是呢

28:56.410 --> 28:59.410
伍佑给我们提供了一个

28:59.410 --> 29:00.410
全局函数

29:00.410 --> 29:01.410
就是在伍佑构造系里边

29:01.410 --> 29:02.410
一个全局函数

29:02.410 --> 29:03.410
Observer

29:03.410 --> 29:04.410
传入一个对象

29:04.410 --> 29:05.410
那么它可以

29:05.410 --> 29:06.410
通过这个函数

29:06.410 --> 29:07.410
它其实

29:07.410 --> 29:09.410
它就帮我们去

29:09.410 --> 29:10.410
通过Observer

29:10.410 --> 29:12.410
来创建一个响音式对象

29:12.410 --> 29:13.410
我们可以看一下

29:13.410 --> 29:16.490
再来我们再加一个

29:16.490 --> 29:17.490
demo2

29:17.490 --> 29:18.490
这里的边

29:18.490 --> 29:19.490
我去引用一下

29:19.490 --> 29:21.490
这个伍佑的getter

29:21.490 --> 29:27.040
看着啊

29:27.040 --> 29:29.040
现在我们都不去

29:29.040 --> 29:30.040
建什么模板啊

29:30.040 --> 29:31.040
那些东西

29:31.040 --> 29:32.040
我们就单用它的

29:32.040 --> 29:33.040
响音式系统

29:33.040 --> 29:34.040
伍佑里边有一个函数

29:34.040 --> 29:36.040
叫做Observer

29:36.040 --> 29:37.040
这个函数

29:37.040 --> 29:38.040
里边传入的是什么呢

29:38.040 --> 29:40.040
传入的是一个对象

29:40.040 --> 29:41.040
我们来看一下

29:41.040 --> 29:42.040
这个对象

29:44.040 --> 29:45.040
有没有

29:45.040 --> 29:46.040
有点吧

29:48.040 --> 29:49.040
Malik

29:50.040 --> 29:51.040
A

29:53.040 --> 29:54.040
就把对象传进去

29:54.040 --> 29:55.040
这个对象

29:55.040 --> 29:56.040
实际上是一个

29:56.040 --> 29:57.040
非常普通的对象

29:57.040 --> 29:58.040
如果说我们

29:58.040 --> 29:59.040
不做任何处理的话

29:59.040 --> 30:00.040
我们来凶手一下

30:05.170 --> 30:06.170
你看

30:06.170 --> 30:07.170
一个非常普通的对象

30:07.170 --> 30:08.170
每个属性都非常普通

30:08.170 --> 30:09.170
它并不是

30:09.170 --> 30:10.170
一个响音式对象

30:10.170 --> 30:11.170
但是我们

30:11.170 --> 30:12.170
只要去

30:12.170 --> 30:13.170
调用Observer

30:13.170 --> 30:14.170
把对象传进去了

30:14.170 --> 30:15.170
这个对象就变了

30:15.170 --> 30:19.080
好

30:19.080 --> 30:20.080
我们来看一下

30:20.080 --> 30:21.080
接下来

30:21.080 --> 30:22.080
看一下这个优者

30:23.080 --> 30:24.080
你看对象

30:24.080 --> 30:25.080
是不是有点变化

30:25.080 --> 30:26.080
它的A级变成了什么

30:26.080 --> 30:27.080
变成了一个

30:27.080 --> 30:29.080
具有Getter和Setter的东西

30:29.080 --> 30:30.080
Name变成了一个

30:30.080 --> 30:32.080
具有Getter和Setter的东西

30:32.080 --> 30:33.080
看到没

30:33.080 --> 30:34.080
所以有变化

30:34.080 --> 30:35.080
而且你要注意

30:35.080 --> 30:36.080
它对里边

30:36.080 --> 30:37.080
这个对象里边

30:37.080 --> 30:38.080
所有的属性

30:38.080 --> 30:39.080
它都会发生变化

30:40.080 --> 30:41.080
包括

30:42.080 --> 30:43.080
嵌透了对象

30:43.080 --> 30:44.080
比较多

30:44.080 --> 30:45.080
它有阻止

30:45.080 --> 30:46.080
阻止的话

30:46.080 --> 30:47.080
Provance

30:47.080 --> 30:48.080
台中疆

30:48.080 --> 30:49.080
City

30:50.080 --> 30:51.080
H2B

30:53.080 --> 30:54.080
起错了

30:55.080 --> 30:56.080
H2B

30:57.080 --> 30:59.650
好

30:59.650 --> 31:00.650
咱们再看

31:01.650 --> 31:02.650
也就是它里边

31:02.650 --> 31:03.650
有个D规遍你

31:03.650 --> 31:04.650
深度D规遍你

31:04.650 --> 31:05.650
你看

31:05.650 --> 31:06.650
这三个属性是不是变了

31:06.650 --> 31:07.650
变了吧

31:08.650 --> 31:09.650
点击

31:09.650 --> 31:10.650
就变了

31:10.650 --> 31:11.650
都是Getter和Setter

31:11.650 --> 31:12.650
然后这个

31:12.650 --> 31:13.650
这里边又是一个对象

31:13.650 --> 31:14.650
这个对象里边的属性

31:14.650 --> 31:15.650
它也变了

31:16.650 --> 31:17.650
就是你的对象

31:17.650 --> 31:18.650
无论千套多生的层次

31:18.650 --> 31:19.650
它都会把它变成

31:19.650 --> 31:20.650
Getter和Setter

31:20.650 --> 31:21.650
都是想用式的

31:22.650 --> 31:23.650
那么也就对这些属性的

31:23.650 --> 31:25.650
复制和读取

31:25.650 --> 31:26.650
无诱都能够坚定到

31:27.650 --> 31:28.650
还不仅如此

31:28.650 --> 31:29.650
我们还可以写的更多

31:29.650 --> 31:30.650
比方说

31:31.650 --> 31:32.650
这个Molica

31:32.650 --> 31:33.650
它有很多的学生

31:33.650 --> 31:34.650
对吧

31:34.650 --> 31:35.650
Students

31:36.650 --> 31:37.650
Students是一个数组

31:38.650 --> 31:39.650
数组里边

31:39.650 --> 31:40.650
每个学生又是个对象

31:40.650 --> 31:41.650
咱们来看一下

31:42.650 --> 31:43.650
每个学生有自己的Name

31:45.650 --> 31:46.650
小王

31:47.650 --> 31:48.650
A级

31:49.650 --> 31:50.650
水

31:50.650 --> 31:51.650
水边写个

31:51.650 --> 31:55.940
小张

31:55.940 --> 31:56.940
水

31:56.940 --> 31:58.940
找到是个幼儿园的老师

31:59.940 --> 32:00.940
咱们就写两个吧

32:00.940 --> 32:01.940
接下来我们来看一下

32:01.940 --> 32:03.940
数组里边的对象会不会变

32:03.940 --> 32:04.940
有点

32:05.940 --> 32:06.940
这三个

32:06.940 --> 32:07.940
这些属性其实全变了

32:07.940 --> 32:08.940
包括这个

32:08.940 --> 32:09.940
这个数组本身

32:09.940 --> 32:10.940
它是个属性

32:10.940 --> 32:12.940
属性肯定会变成想用式的

32:12.940 --> 32:13.940
它里边的数组

32:14.940 --> 32:15.940
数组里边

32:15.940 --> 32:16.940
是不是有对象

32:16.940 --> 32:17.940
这个对象里面的属性

32:17.940 --> 32:18.940
是个想用式

32:18.940 --> 32:19.940
看到没

32:19.940 --> 32:21.940
它也是有想用式

32:23.940 --> 32:24.940
这就是

32:24.940 --> 32:25.940
唯有这个函数的作用

32:25.940 --> 32:27.940
它能够把一个对象

32:27.940 --> 32:29.940
整个对象里边的所有东西

32:29.940 --> 32:30.940
变成想用式的

32:31.940 --> 32:32.940
明白了意思吧

32:33.940 --> 32:34.940
听到这一块

32:34.940 --> 32:35.940
没什么问题的话

32:35.940 --> 32:41.330
就可以

32:41.330 --> 32:42.330
咱们接着往下聊

32:43.330 --> 32:44.330
但是这个东西

32:44.330 --> 32:45.330
你会发现

32:45.330 --> 32:47.330
它有一个明显的缺陷

32:47.330 --> 32:49.330
有什么缺陷呢

32:49.330 --> 32:50.330
你看

32:50.330 --> 32:52.330
之后我这样子一做的话

32:52.330 --> 32:53.330
从此以后

32:55.960 --> 32:56.960
由着

32:56.960 --> 32:57.960
里面

32:57.960 --> 32:59.960
所有的东西

32:59.960 --> 33:01.960
都是想用式的

33:02.960 --> 33:03.960
就是它里边的东西

33:03.960 --> 33:04.960
全都是getal和setal

33:04.960 --> 33:05.960
一读去

33:05.960 --> 33:06.960
能坚定

33:06.960 --> 33:07.960
以复职

33:07.960 --> 33:08.960
能坚定

33:08.960 --> 33:10.960
那么真的如此吗

33:10.960 --> 33:13.660
好

33:13.660 --> 33:14.660
那我们来试验一下

33:14.660 --> 33:15.660
首先我问大家

33:15.660 --> 33:17.660
刚才有一个给大家看过了

33:17.660 --> 33:18.660
你这个东西肯定是想用式的

33:18.660 --> 33:19.660
对吧

33:19.660 --> 33:20.660
这个毫无疑问

33:20.660 --> 33:21.660
那如果说

33:21.660 --> 33:27.020
这种东西呢

33:27.020 --> 33:28.020
那么我这样做

33:28.020 --> 33:36.320
是不是想用式的

33:36.320 --> 33:39.210
好好看看

33:39.210 --> 33:45.270
这样做是不是想用式啊

33:45.270 --> 33:46.270
这样做得适啊

33:46.270 --> 33:47.270
同学们得适

33:47.270 --> 33:49.270
为什么得适呢

33:49.270 --> 33:51.710
刚才我们给大家

33:51.710 --> 33:56.050
看过的有点对象啊

33:56.050 --> 33:57.050
所以我来干吗

33:57.050 --> 33:58.050
我现在在干吗

33:58.050 --> 33:59.050
是不是读去由这里边的

33:59.050 --> 34:00.050
这个东西

34:00.050 --> 34:01.050
得读到数据的第一项

34:01.050 --> 34:02.050
数据的第一项

34:02.050 --> 34:03.050
是不是个对象

34:03.050 --> 34:04.050
给它的name属性复职

34:04.050 --> 34:05.050
你看个name属性

34:05.050 --> 34:07.050
是不是有getal

34:07.050 --> 34:08.050
是不是有getal

34:08.050 --> 34:09.050
这个name属性

34:09.050 --> 34:11.050
我在给name属性复职的时候

34:11.050 --> 34:12.050
是不是在调用setname

34:13.050 --> 34:14.050
对不对

34:14.050 --> 34:16.050
数想用式啊

34:16.050 --> 34:17.050
我懂你们的意思

34:17.050 --> 34:18.050
所以说

34:18.050 --> 34:19.050
你们有些东西呢

34:19.050 --> 34:20.050
是没有理解清楚的

34:20.050 --> 34:22.050
你们是没有理解清楚的啊

34:22.050 --> 34:23.050
我一会会讲到你们的疑惑

34:23.050 --> 34:24.050
我知道了

34:24.050 --> 34:25.050
我知道你们的疑惑在了

34:25.050 --> 34:29.060
这些东西都是想用式的啊

34:29.060 --> 34:30.060
没有任何疑问

34:30.060 --> 34:31.060
包括利用什么

34:31.060 --> 34:32.060
那这些东西

34:32.060 --> 34:33.060
都是了啊

34:33.060 --> 34:35.060
给它的什么provence复职

34:35.060 --> 34:36.060
都是没问题

34:36.060 --> 34:37.060
现在我们来看

34:37.060 --> 34:38.060
其中一个情况

34:39.060 --> 34:43.300
那么我请问大家

34:43.300 --> 34:45.300
这个set是想用式吗

34:45.300 --> 34:47.300
这个set是

34:47.300 --> 34:50.610
这个玩意是想用式吗

34:50.610 --> 34:55.650
这个玩意就不是了

34:55.650 --> 34:57.650
为什么不是啊

34:57.650 --> 34:58.650
首先你要清楚

34:58.650 --> 34:59.650
这些数据

34:59.650 --> 35:00.650
它为什么是想用式

35:00.650 --> 35:01.650
不是说

35:01.650 --> 35:02.650
它刷了一下

35:02.650 --> 35:03.650
就自动变成想用式

35:03.650 --> 35:04.650
不是的

35:04.650 --> 35:05.650
它为什么是想用式

35:05.650 --> 35:06.650
是因为我们在

35:06.650 --> 35:07.650
这个还是在便利它

35:07.650 --> 35:09.650
在进行深度便利

35:09.650 --> 35:11.650
它把每一个属性拿出来

35:11.650 --> 35:12.650
使用opt这个是

35:12.650 --> 35:13.650
define property

35:14.650 --> 35:16.650
重新定义过

35:16.650 --> 35:17.650
但是

35:17.650 --> 35:19.650
当时在重新定义的时候

35:19.650 --> 35:21.650
它知不知道有这么一个属性存在

35:21.650 --> 35:22.650
它不知道

35:22.650 --> 35:23.650
当时是没有这个属性的

35:23.650 --> 35:24.650
对吧

35:24.650 --> 35:25.650
它并不知道有这个属性存在

35:25.650 --> 35:27.650
这个属性是在定义之后

35:27.650 --> 35:28.650
重新加的

35:28.650 --> 35:30.650
加了一个普通的属性

35:30.650 --> 35:31.650
除非你在这里

35:31.650 --> 35:33.650
也用opt的define property

35:33.650 --> 35:34.650
也去定义这个set

35:34.650 --> 35:35.650
但是你没有

35:35.650 --> 35:36.650
这要做太麻烦了

35:36.650 --> 35:37.650
你没有这样做

35:37.650 --> 35:38.650
你用平时的写法

35:38.650 --> 35:39.650
这样的写的

35:39.650 --> 35:40.650
那么它就不是想用式的

35:40.650 --> 35:41.650
因为这个时候

35:41.650 --> 35:43.650
想用式数据

35:43.650 --> 35:44.650
此时

35:44.650 --> 35:46.650
想用

35:48.650 --> 35:51.650
数据想用式的处理

35:52.650 --> 35:54.650
已经结束了

35:54.650 --> 35:55.650
已经结束了

35:55.650 --> 35:56.650
在这里处理的

35:56.650 --> 35:57.650
已经结束了

35:57.650 --> 35:58.650
所以说这个属性

35:58.650 --> 36:00.650
就是一个普通属性

36:00.650 --> 36:02.650
普通属性

36:02.650 --> 36:04.650
是一个普通属性

36:04.650 --> 36:05.650
如果说你以后

36:05.650 --> 36:06.650
学到5u3之后

36:06.650 --> 36:07.650
你才知道

36:07.650 --> 36:09.650
为什么5u3要用proxy

36:09.650 --> 36:10.650
proxy

36:10.650 --> 36:12.650
5u3你用es6的proxy

36:12.650 --> 36:13.650
它就可以监听到

36:13.650 --> 36:14.650
但是

36:14.650 --> 36:15.650
用这种方式

36:15.650 --> 36:16.650
它就监听不到了

36:16.650 --> 36:17.650
proxy的proxy

36:17.650 --> 36:18.650
它就监听不到

36:18.650 --> 36:19.650
我们来看一下

36:19.650 --> 36:20.650
所以我们看一下这个优点

36:20.650 --> 36:22.650
你会发现这个set是

36:22.650 --> 36:23.650
厚历积群

36:23.650 --> 36:24.650
对吧

36:24.650 --> 36:25.650
厚历积群

36:25.650 --> 36:26.650
它就不是想用式的

36:26.650 --> 36:27.650
它是一个普通属性

36:27.650 --> 36:28.650
你后面夹的

36:28.650 --> 36:29.650
那么这是

36:29.650 --> 36:30.650
这是搞不定的

36:30.650 --> 36:31.650
对吧

36:31.650 --> 36:33.650
那么再看

36:36.650 --> 36:44.180
这种东西它能监听到吗

36:44.180 --> 36:45.180
5u3

36:45.180 --> 36:48.180
能知道我删除了属性吗

36:48.180 --> 36:49.180
你觉得它能知道

36:49.180 --> 36:57.100
我删除了属性吗

36:57.100 --> 36:58.100
它知道就见了鬼了

36:58.100 --> 37:00.100
它里面只用一个getter和setter

37:00.100 --> 37:01.100
getter是读数据的时候

37:01.100 --> 37:02.100
对吧

37:02.100 --> 37:03.100
运行

37:03.100 --> 37:04.100
setter是复制的时候运行

37:04.100 --> 37:05.100
那你说它这里在读去

37:05.100 --> 37:06.100
还是复制呢

37:06.100 --> 37:08.100
都不是

37:08.100 --> 37:10.100
我再用一种特殊语法去删除它

37:10.100 --> 37:12.100
我又是不可能知道的

37:12.100 --> 37:13.100
不可能知道的

37:13.100 --> 37:15.100
我在删除它

37:15.100 --> 37:17.100
所以它这里一定不是想用式的

37:20.540 --> 37:21.540
既不会运行setter

37:21.540 --> 37:23.540
也不会运行getter

37:23.540 --> 37:24.540
明白吧

37:24.540 --> 37:26.540
说这个东西是不是监听不到

37:26.540 --> 37:27.540
对不对

37:28.540 --> 37:30.540
因此就是因为有这样的缺陷

37:30.540 --> 37:33.540
就它这种数据想用式的设计

37:33.540 --> 37:35.540
天生就有这样的缺陷

37:35.540 --> 37:36.540
这是5u不是说

37:36.540 --> 37:38.540
它的开发能力强就能解决的

37:38.540 --> 37:39.540
这是天生的缺陷

37:39.540 --> 37:40.540
搞不定

37:40.540 --> 37:41.540
因此

37:41.540 --> 37:42.540
在5u里边

37:42.540 --> 37:44.540
它怎么来处理这个问题呢

37:44.540 --> 37:46.540
它根本提供了两个实力方法

37:46.540 --> 37:47.540
一个是set

37:47.540 --> 37:48.540
一个是delete

37:48.540 --> 37:49.540
说

37:49.540 --> 37:51.540
如果说你真的有这样的需求

37:51.540 --> 37:53.540
就是你要加一些属性

37:53.540 --> 37:54.540
或者是一会儿

37:54.540 --> 37:55.540
你要删一些属性

37:55.540 --> 37:56.540
你真的有这样的需求

37:56.540 --> 37:57.540
你就不能这样子写了

37:57.540 --> 37:58.540
你这样子写

37:58.540 --> 37:59.540
我确实监听不到

37:59.540 --> 38:01.540
我不知道你这三个属性

38:01.540 --> 38:03.540
我也不知道你加了属性

38:03.540 --> 38:04.540
麻烦你

38:04.540 --> 38:06.540
你调这两个方法来吧

38:06.540 --> 38:08.540
不然的话我真的搞不定的

38:08.540 --> 38:09.540
所以我们再回到

38:09.540 --> 38:10.540
5u的安定里边

38:10.540 --> 38:11.540
我们来看一下

38:11.540 --> 38:12.540
这边我们就

38:12.540 --> 38:13.540
不用这个runed

38:13.540 --> 38:14.540
runed我就去掉了

38:15.540 --> 38:16.540
我去掉了

38:17.540 --> 38:19.540
现在我们做一个简单的事情

38:20.540 --> 38:21.540
这边我就显示一个

38:21.540 --> 38:22.540
显示一个

38:23.540 --> 38:24.540
年龄

38:24.540 --> 38:26.540
我就显示一个年龄

38:26.540 --> 38:27.540
年龄是什么呢

38:27.540 --> 38:28.540
A级

38:28.540 --> 38:29.540
那我有这个属性吗

38:29.540 --> 38:30.540
肯定没有

38:30.540 --> 38:31.540
所以没有这个属性啊

38:33.540 --> 38:36.540
然后我下面有一个按钮

38:36.540 --> 38:37.540
三处年龄

38:39.860 --> 38:40.860
来试一下吧

38:41.860 --> 38:43.860
那么我希望呢

38:43.860 --> 38:45.860
或者是设置年龄吧

38:45.860 --> 38:48.860
设置年龄为17

38:48.860 --> 38:51.680
click

38:52.680 --> 38:54.680
我这里写两个方法

38:54.680 --> 38:57.310
没设置

38:57.310 --> 38:59.310
我得稍微的讲快一点啊

38:59.310 --> 39:02.310
handledadad

39:02.310 --> 39:05.620
其实也不着急

39:05.620 --> 39:06.620
今天就我一个人讲

39:06.620 --> 39:07.620
我慢慢来

39:07.620 --> 39:08.620
你们不着急

39:08.620 --> 39:09.620
我就不着急

39:14.190 --> 39:15.190
我有两个方法

39:15.190 --> 39:16.190
这个点这个呢

39:16.190 --> 39:17.190
我就掉了这个方法

39:18.190 --> 39:19.190
点这个呢

39:20.190 --> 39:21.190
我就掉了另外一个方法

39:21.190 --> 39:24.190
handledadad

39:24.190 --> 39:25.190
好

39:25.190 --> 39:26.190
现在我们来看啊

39:26.190 --> 39:27.190
我一开始给它的数据有A级吗

39:27.190 --> 39:28.190
肯定是没有的

39:28.190 --> 39:29.190
对不对

39:29.190 --> 39:30.190
没有A级

39:30.190 --> 39:31.190
所以它一开始能显示吗

39:31.190 --> 39:33.190
它一开始显示不出来的东西啊

39:33.190 --> 39:35.190
A级是

39:35.190 --> 39:40.870
not defined

39:40.870 --> 39:41.870
没关系

39:41.870 --> 39:42.870
它爆出去爆错吧

39:42.870 --> 39:47.140
它爆出去爆错吧

39:47.140 --> 39:50.140
我不希望它能让它爆错

39:50.140 --> 39:51.140
不希望它爆错

39:51.140 --> 39:53.140
管它能爆出来爆错吧

39:53.140 --> 39:55.140
但是现在这个按钮显示不出来啊

39:55.140 --> 39:56.140
我就这样子啊

39:56.140 --> 39:58.140
这样我这里用个对象啊

39:58.140 --> 40:00.140
油热油热里边

40:00.140 --> 40:03.140
我们读的是油热点A级啊

40:03.140 --> 40:04.140
不然就上下文

40:04.140 --> 40:05.140
它爆到一下爆错了

40:05.140 --> 40:07.140
好我们读这个油热点A级

40:08.140 --> 40:09.140
明儿的意思吧

40:09.140 --> 40:10.140
读这个油热点A级

40:10.140 --> 40:11.140
现在呢我们现在

40:11.140 --> 40:13.140
一开始没有这个A级的时候

40:13.140 --> 40:14.140
它显示不出来任何东西

40:14.140 --> 40:16.140
现在我们想点击这个按钮的时候

40:16.140 --> 40:17.140
点这个按钮的时候

40:17.140 --> 40:19.140
然后把年龄设为17

40:19.140 --> 40:21.140
就是它应该添加属性

40:21.140 --> 40:22.140
那么添加属性的时候

40:22.140 --> 40:24.140
我们肯定不能这样做

40:24.140 --> 40:25.140
这样做行吗

40:25.140 --> 40:26.140
哦这样

40:26.140 --> 40:28.140
就是Z是油热点A级

40:28.140 --> 40:29.140
这样做行吗

40:29.140 --> 40:31.140
这样都不行

40:31.140 --> 40:32.140
为什么不行呢

40:32.140 --> 40:33.140
我们来看一下

40:33.140 --> 40:36.140
首先点击一下

40:36.140 --> 40:38.140
为大家记一个问题

40:38.140 --> 40:39.140
数据变美

40:39.140 --> 40:41.140
首先这里边的数据变美

40:41.140 --> 40:49.190
啊数据肯定变了

40:49.190 --> 40:50.190
你这样的复词呢

40:50.190 --> 40:52.190
不变就见鬼了啊

40:52.190 --> 40:53.190
数据肯定是变了啊

40:53.190 --> 40:54.190
你看一下吧

40:54.190 --> 40:56.190
5U有点油热

40:56.190 --> 40:57.190
你看

40:57.190 --> 40:58.190
是不是数据变了

40:58.190 --> 41:00.190
但是只是5U它不知道

41:00.190 --> 41:01.190
它没有东西可运行

41:01.190 --> 41:02.190
它没有运行

41:02.190 --> 41:03.190
所以说呢

41:03.190 --> 41:04.190
将这种添加属性呢

41:04.190 --> 41:06.190
如果说你真的需要这样做

41:06.190 --> 41:08.190
那么今天你呢使用什么

41:08.190 --> 41:10.190
Z set

41:10.190 --> 41:12.190
第一个参数传对象

41:12.190 --> 41:13.190
你要给哪个对象添加

41:13.190 --> 41:15.190
给Z点油热

41:15.190 --> 41:17.190
添加什么属性

41:17.190 --> 41:19.190
添加A级属性

41:19.190 --> 41:21.190
然后属性的值是啥呀

41:21.190 --> 41:23.190
属性的值是17

41:23.190 --> 41:24.190
那么这

41:24.190 --> 41:25.190
因为你在调用方法

41:25.190 --> 41:26.190
这个方法是谁写的

41:26.190 --> 41:27.190
是不是5U写的

41:27.190 --> 41:28.190
那么这个方法里边

41:28.190 --> 41:29.190
它是不是可以玩很多事情

41:29.190 --> 41:30.190
它是不是又可以用

41:30.190 --> 41:32.190
那个Object是DefineProperty

41:32.190 --> 41:33.190
重新往这个对象里边

41:33.190 --> 41:34.190
定一个A级属性

41:34.190 --> 41:35.190
对不对

41:36.190 --> 41:38.190
这样子说可以的

41:38.190 --> 41:39.190
好来试一下

41:40.190 --> 41:41.190
是不是可以显示出来了

41:41.190 --> 41:42.190
然后我们再看

41:42.190 --> 41:43.190
它里边的东西

41:43.190 --> 41:46.500
A级变成想象式了

41:46.500 --> 41:47.500
有点

41:47.500 --> 41:48.500
你看

41:48.500 --> 41:49.500
这个A级属变成想象式了

41:49.500 --> 41:50.500
对吧

41:50.500 --> 41:51.500
因为你在调用方法

41:51.500 --> 41:52.500
这个方法里边

41:52.500 --> 41:53.500
它是绑立定义的

41:53.500 --> 41:54.500
用Object DefineProperty

41:54.500 --> 41:55.500
那么同样的

41:55.500 --> 41:56.500
你删除属性

41:56.500 --> 41:58.500
一用这种方式删除

41:58.500 --> 41:59.500
它是不知道的

41:59.500 --> 42:00.500
根本就不知道你删了

42:00.500 --> 42:01.500
3.3它肯定是删了

42:01.500 --> 42:03.500
但是它不知道

42:03.500 --> 42:04.500
删除

42:04.500 --> 42:05.500
你看一下

42:05.500 --> 42:07.500
数据看一下3.3

42:07.500 --> 42:08.500
它们也没有A级了

42:08.500 --> 42:09.500
是不是删除了

42:09.500 --> 42:11.500
那么3.3只是它不知道而已

42:11.500 --> 42:13.500
因此你需要用这种方式

42:13.500 --> 42:14.500
用Delete

42:14.500 --> 42:15.500
这个Delete的方式

42:15.500 --> 42:16.500
就是让5又知道

42:16.500 --> 42:17.500
你在删除属性

42:17.500 --> 42:19.500
因为这是5又写的方法

42:19.500 --> 42:20.500
还知道了

42:20.500 --> 42:21.500
原来你在删除

42:21.500 --> 42:22.500
哪个属性

42:22.500 --> 42:23.500
删除A级的属性

42:23.500 --> 42:24.500
于是这个方法里边

42:24.500 --> 42:26.500
会重新删这个界面

42:27.500 --> 42:30.140
是不是可以了

42:30.140 --> 42:31.140
但是你们以后

42:31.140 --> 42:32.140
在实际的开发中

42:32.140 --> 42:35.140
建议不要用这种方式

42:35.140 --> 42:37.140
首先没有必要去删除属性

42:37.140 --> 42:38.140
如果说你觉得它不爽

42:38.140 --> 42:39.140
你想不要显示

42:39.140 --> 42:40.140
不要显示的话

42:40.140 --> 42:42.140
你把它设为空置无窜就行了

42:42.140 --> 42:44.140
你不要去删除

42:44.140 --> 42:46.140
另外也不要去动态添加属性

42:46.140 --> 42:48.140
这样子非常容易出错

42:48.140 --> 42:49.140
主要是

42:49.140 --> 42:50.140
因为你一不小心的话

42:50.140 --> 42:51.140
就变成直接写了

42:51.140 --> 42:52.140
所以建议你这样子写

42:52.140 --> 42:53.140
如果说你界面上

42:53.140 --> 42:54.140
要显示A级

42:54.140 --> 42:55.140
但是一开始又不显示的话

42:55.140 --> 42:57.140
你把它设为一个空置无窜

42:58.140 --> 43:03.470
为什么可以写U2.A级

43:03.470 --> 43:05.470
为什么呢

43:05.470 --> 43:06.470
什么意思

43:07.470 --> 43:09.470
为什么可以写U2.A级

43:09.470 --> 43:10.470
因为我这个A级

43:10.470 --> 43:12.470
放在U2对象里边

43:12.470 --> 43:13.470
Data里边的配置

43:13.470 --> 43:15.470
全部会到这里边

43:15.470 --> 43:17.470
这个Z就是它

43:17.470 --> 43:19.470
我们来输出一下

43:19.470 --> 43:25.700
这个Z就是它

43:25.700 --> 43:27.700
这个Z就是它

43:27.700 --> 43:28.700
那么这些东西

43:28.700 --> 43:30.700
是不是全会到VM里边

43:30.700 --> 43:31.700
那么这个Z是U2

43:31.700 --> 43:39.660
是不是就是VM.U2

43:39.660 --> 43:40.660
一开始

43:40.660 --> 43:41.660
什么意思

43:41.660 --> 43:43.660
一开始没有写A级

43:43.660 --> 43:45.660
我一开始没有写A级

43:45.660 --> 43:46.660
有时候这里是吧

43:46.660 --> 43:49.660
那么这里是这样子的

43:49.660 --> 43:51.660
这个好像是一道模板编译

43:51.660 --> 43:52.660
它是这样子

43:52.660 --> 43:53.660
所以它找这个U2

43:53.660 --> 43:55.660
这个U2是不是存在的

43:55.660 --> 43:56.660
U2是不是存在的

43:56.660 --> 43:57.660
对不对

43:57.660 --> 43:59.660
那么只是读这个U2里边的属性

43:59.660 --> 44:01.660
是undefined对不对

44:01.660 --> 44:02.660
那么这里就相当于是

44:02.660 --> 44:03.660
反回那个什么

44:03.660 --> 44:04.660
反回那个undefined

44:04.660 --> 44:05.660
这个不爆出了

44:05.660 --> 44:07.660
是不是不爆出了

44:09.660 --> 44:10.660
反回到undefined的时候

44:10.660 --> 44:12.660
不爆出了

44:12.660 --> 44:14.660
那么是这么个意思

44:16.660 --> 44:18.660
那如果说你直接写A级的话

44:18.660 --> 44:19.660
如果说你这里没有A级

44:19.660 --> 44:20.660
直接写A级的话

44:20.660 --> 44:21.660
这要爆出的

44:21.660 --> 44:22.660
因为它早变那个上下文

44:22.660 --> 44:24.660
它找不到A级的东西

44:24.660 --> 44:26.660
就好必说什么呢

44:26.660 --> 44:28.660
就好必说你在GS里边

44:28.660 --> 44:29.660
你没有定义一个变量

44:29.660 --> 44:30.660
你去用它

44:30.660 --> 44:31.660
那肯定要爆出

44:31.660 --> 44:33.660
但是你有一个变量

44:33.660 --> 44:35.660
但是我通过读它的属性

44:35.660 --> 44:36.660
而不是变量的方式

44:36.660 --> 44:38.660
它就不爆出

44:38.660 --> 44:42.040
是一样的道理

44:44.040 --> 44:45.040
那么建议大家以后

44:45.040 --> 44:46.040
很真实的开发中

44:46.040 --> 44:48.040
如果说你有这样的需求

44:48.040 --> 44:49.040
那么你应该这样子写

44:49.040 --> 44:51.040
这样子写比较好一点

44:51.040 --> 44:52.040
都要用这种写法

44:52.040 --> 44:54.040
这种写法是非常容易出问题的

44:54.040 --> 44:57.040
优热点A级实习

44:57.040 --> 44:58.040
删除就算了吧

44:58.040 --> 45:00.040
删除我就有这样子写

45:00.040 --> 45:02.040
这些是优热点A级

45:02.040 --> 45:03.040
这种方式

45:03.040 --> 45:05.040
这样子是比较好的

45:05.040 --> 45:07.040
效果是一样

45:07.040 --> 45:09.040
这样子就避免了这种情况

45:09.040 --> 45:10.040
但这种情况

45:10.040 --> 45:11.040
是5又20解决不了的

45:11.040 --> 45:13.040
5又3是可以解决的

45:13.040 --> 45:14.040
5又3

45:14.040 --> 45:15.040
这两个函数是直接给你干掉了

45:15.040 --> 45:16.040
就没有了

45:16.040 --> 45:18.040
这是关于对象

45:18.040 --> 45:19.040
它对新增属性和

45:19.040 --> 45:21.040
三处属性的处理方式

45:21.040 --> 45:22.040
现在我讲下一个

45:22.040 --> 45:24.040
数组

45:24.040 --> 45:26.040
数组5又咋了

45:26.040 --> 45:28.040
问题又严重了

45:28.040 --> 45:30.040
我们来看一下

45:30.040 --> 45:32.040
现在我们再加一些信息吧

45:32.040 --> 45:33.040
比方说

45:33.040 --> 45:35.040
我们这个数据里边

45:35.040 --> 45:36.040
还有一些信息

45:36.040 --> 45:38.040
Hobbies

45:38.040 --> 45:41.040
它的I好

45:41.040 --> 45:43.040
说我们来一个

45:43.040 --> 45:44.040
Name

45:46.040 --> 45:47.040
它又怎么I好呢

45:47.040 --> 45:49.040
比方说它I好

45:49.040 --> 45:51.040
读书

45:53.040 --> 45:54.040
I好

45:54.040 --> 45:56.040
音乐

45:56.040 --> 45:57.040
它

45:57.040 --> 45:58.040
I好

45:58.040 --> 45:59.040
钢管

45:59.040 --> 46:01.800
好

46:01.800 --> 46:02.800
那么现在我要做的事情

46:02.800 --> 46:03.800
是把这个

46:03.800 --> 46:04.800
数组里边的东西

46:04.800 --> 46:05.800
显示到界面上去

46:05.800 --> 46:06.800
我就显示吧

46:06.800 --> 46:07.800
随便找个地方

46:07.800 --> 46:08.800
显示就OK了

46:08.800 --> 46:10.800
我这用个H22元数

46:10.800 --> 46:12.800
我就简单的显示一下

46:12.800 --> 46:13.800
我又懒得去循环了

46:13.800 --> 46:14.800
我就直接Hobbies

46:14.800 --> 46:16.800
它会用节省格式的

46:16.800 --> 46:17.800
支付创来显示出来

46:17.800 --> 46:18.800
你看

46:18.800 --> 46:20.800
是不是显示出来了

46:20.800 --> 46:21.800
那么现在我们来继续

46:21.800 --> 46:22.800
继续来观看这个

46:22.800 --> 46:24.800
Hobbies

46:24.800 --> 46:28.370
这是一个数组对吧

46:28.370 --> 46:29.370
那么如果说

46:29.370 --> 46:31.370
我对数组的变动

46:31.370 --> 46:32.370
可不像对象那么简单

46:32.370 --> 46:33.370
对象的变动的话

46:33.370 --> 46:34.370
无非就是属性复制

46:34.370 --> 46:35.370
属性读取

46:35.370 --> 46:36.370
然后呢

46:36.370 --> 46:37.370
加一个属性

46:37.370 --> 46:38.370
三一个属性

46:38.370 --> 46:39.370
加和三

46:39.370 --> 46:40.370
坚固不到

46:40.370 --> 46:41.370
我就必须要

46:41.370 --> 46:43.370
但是数组可不一样啊

46:43.370 --> 46:45.370
数组里边还有这些东西

46:45.370 --> 46:46.370
它有一些方法

46:46.370 --> 46:48.370
可以改动数组本身

46:48.370 --> 46:49.370
比方说我们这里呢

46:49.370 --> 46:50.370
有Hobbies

46:50.370 --> 46:52.370
我是有複习方法

46:52.370 --> 46:54.370
这可以改动数组本身啊

46:54.370 --> 46:56.370
对吧

46:56.370 --> 46:57.370
那么我们再来一个

46:57.370 --> 46:58.370
加一个蹦低

46:58.370 --> 47:01.510
好

47:01.510 --> 47:02.510
那么我们现在

47:02.510 --> 47:03.510
改动那个数组本身

47:03.510 --> 47:04.510
一改动

47:04.510 --> 47:05.510
你看见面是不是

47:05.510 --> 47:06.510
还是有刷新

47:06.510 --> 47:07.510
还是有刷新说明什么

47:07.510 --> 47:08.510
说明仍然有数据

47:08.510 --> 47:09.510
那么就起得怪了

47:09.510 --> 47:10.510
这个方法是

47:10.510 --> 47:12.510
是无优血的吗

47:12.510 --> 47:13.510
这是数组里边的

47:13.510 --> 47:14.510
複习方法啊

47:14.510 --> 47:15.510
对吧

47:15.510 --> 47:16.510
这是数组

47:16.510 --> 47:17.510
就是和浏览器本身写的

47:17.510 --> 47:18.510
浏览器他知不知道

47:18.510 --> 47:19.510
你在用无优啊

47:19.510 --> 47:20.510
肯定不知道

47:20.510 --> 47:21.510
他连无优事啥都不知道

47:21.510 --> 47:22.510
所以说呢

47:22.510 --> 47:23.510
你在调用数组的

47:23.510 --> 47:24.510
複习方法

47:24.510 --> 47:25.510
无优是怎么知道的

47:25.510 --> 47:26.510
他怎么知道

47:26.510 --> 47:27.510
你往数组里边

47:27.510 --> 47:28.510
加了一个

47:28.510 --> 47:30.510
然后重新去见面

47:30.510 --> 47:31.510
那么这里呢

47:31.510 --> 47:32.510
他用到了一个技巧

47:32.510 --> 47:33.510
这些技巧

47:33.510 --> 47:36.510
都是可以学习的

47:36.510 --> 47:37.510
你本来的

47:37.510 --> 47:38.510
这个数组呢

47:38.510 --> 47:39.510
是这个样子的

47:39.510 --> 47:41.510
回到GS基础了

47:41.510 --> 47:43.510
数组的隐私圆形

47:43.510 --> 47:45.510
是指向数组的圆形的

47:45.510 --> 47:46.510
本来是这样子的

47:46.510 --> 47:47.510
对吧

47:47.510 --> 47:48.510
我们可以在见面

47:48.510 --> 47:49.510
我们可以在浏览器里边

47:49.510 --> 47:51.510
看一下吧

47:51.510 --> 47:52.510
我们一个数组

47:52.510 --> 47:53.510
随便给个数组

47:53.510 --> 47:55.510
随便下给个

47:55.510 --> 47:57.510
这个数组的隐私圆形

47:57.510 --> 48:01.140
Protor啊

48:01.140 --> 48:02.140
是不是应该等于

48:02.140 --> 48:04.140
Array点Protor type

48:04.140 --> 48:05.140
它隐私圆形

48:05.140 --> 48:06.140
应该是等于数组的圆形

48:06.140 --> 48:08.140
就是我这里画的那张图

48:08.140 --> 48:09.140
但是如果说你

48:09.140 --> 48:11.140
它保持这样子的话

48:11.140 --> 48:12.140
它就完蛋了

48:12.140 --> 48:13.140
迺形方法

48:13.140 --> 48:14.520
调用的是谁的看一下

48:14.520 --> 48:15.520
篤锡方法

48:15.520 --> 48:17.020
调用的是它里边的

48:17.020 --> 48:18.540
微物知道吗

48:18.540 --> 48:21.420
没有压根就不知道

48:21.420 --> 48:22.420
所以说它有对数组了

48:22.420 --> 48:23.860
必须要做特殊处理

48:23.860 --> 48:25.620
怎么特殊处理呢

48:25.620 --> 48:27.380
它就在数组的隐私圆形

48:27.380 --> 48:28.380
连上啊就圆形

48:28.380 --> 48:30.140
连上中间

48:30.140 --> 48:34.140
加了一个自己建议的对象

48:34.140 --> 48:36.620
那么就变成这个样子了

48:36.620 --> 48:37.140
我调的数组

48:37.140 --> 48:37.660
是谁的帏

48:37.660 --> 48:38.860
是持伍

48:38.860 --> 48:39.540
就是我们为里面的

48:39.540 --> 48:40.940
呦里边的

48:40.940 --> 48:47.220
我们可以非常清楚地看到,在5u里面的书主跟我们正常的书主就有点区别

48:47.220 --> 48:55.020
你看,5u里面的Hobby式,它是一个书主,它的隐私元凶,它是不是等于书主的元凶呢?

48:55.020 --> 49:05.220
Force,不是,然后我们再进一步验证,我们的Hobby式里面的铺洗方法,是不是等于书主元凶里面的铺洗方法呢?

49:05.220 --> 49:06.660
按理说应该是,对吧?

49:06.660 --> 49:17.060
不是,怎么回事呢?中间夹了一个,夹了一个自定义对象,那么重新改造了这个圆形链,对吧?

49:17.060 --> 49:25.900
你如果说基础那一块掌握得比较老后的话,你自己都知道这个代码该怎么细写,那么我可以更加清楚地看到就是VM Hobbies,

49:25.900 --> 49:36.100
你会看到它的圆形不太一样,Poto,好像是一个Array,它名字一样而已,明显不是我们那个Array,对吧?

49:36.100 --> 50:02.470
你可以看到这个对象,这个对象是啥?我们这里解过来,你看这个东西,这个东西就是这个东西,这个是我们的书主,那么是这个东西,它的隐私元凶是这个东西,

50:02.470 --> 50:24.640
然后再进一步看,隐私元凶的隐私元凶,这才是书主,你看这个才是书主,与各种各样的Field,Map这些方法,看到没?是这么一回事儿,有这个是这个,然后这个I2是这个,

50:24.640 --> 50:37.960
下面这个才是我们真正的书主,它形成了这么一条圆形链,所以说我们当我们雕用这个书主里面的方法的时候,它首先找自己自己肯定没有,然后找到这个圆形链上,就找到五六里面的方法,

50:37.960 --> 50:55.380
所以你看五六从定义到Pub,从定义到Pub系,这些是不是都会改变书主的方法,这些方法都会导致书主的变化,都会导致书主的变化,你看,它监控了所有有可能会导致书主变化的方法,

50:55.540 --> 51:04.520
那么这些方法,如果说你一旦雕用,是不是你一定改变了书主,所以它就会通知界面刷新,或者我们严格一点说它就会运行一些别的相关函数,

51:04.900 --> 51:16.300
因为数据小意思是,就是数据变化我们要运行一些函数嘛,对吧,那么雕用这些方法的时候,它就会,除了改动书主之外,当然它内部的实现上也会,最终也会去雕容真实书主的方法啊,

51:16.300 --> 51:24.060
但是它会额外的做一件事儿,就是就会去运行一些函数,最终导致我们界面上刷新,原来意思吧,它是用这么种方式来处理的啊,

51:24.780 --> 51:32.820
这也快点听懂吧,我先提个一啊,那肯定是少了啊,它不需要监控所有的方法啊,

51:32.940 --> 51:45.660
你像用什么feature啊这些东西,这个方法会不会改动书主啊,它不会改动书主,对吧,像用什么for each啊,像用什么maf啊这些,它都不会改变书主,所以说它不会去监控这些东西,

51:45.900 --> 51:54.980
因此你在书主里边去雕什么雕feature的时候,它自己找自己,自己不存在,找它,它也不存在,就会用到书主的最终的feature,所以说你会看到里边,

51:56.060 --> 52:07.260
vm-hobbies,互习,跟这个书主的互习一样吗,不一样,但是你会看到hobbies叫什么feature,跟这个书主的feature一样吗,

52:07.700 --> 52:16.260
那个就一样的,就是又一样的,这就是一个元凶链嘛,它对演戏上做了一些拦截啊,

52:17.940 --> 52:24.820
好,这是关于这一块,所以说书主是不是也能先控到啊,无论你是对书主的添加还是用pub,移除,

52:25.380 --> 52:35.380
你看,是不是都可以,那么但是,书主有个地方它是监控不到的,就是你通过下标对书主直接复制,它监控不到,

52:35.780 --> 52:44.690
比方说,你用vm-hobbies,你直接给某一个改动书主的某一项,

52:45.730 --> 52:51.730
通过下标直接去改动书主的某一项监控不到,比方说改成英文,read,

52:52.690 --> 52:59.250
所以监控不到,那数据变没变,数据肯定是变的,数据肯定是变的,还监控不到,

52:59.250 --> 53:03.490
为什么呢,因为针对书主下标,它是没法做出想用式的,

53:05.490 --> 53:12.530
这是过去的介绍它的一个问题,也不算问题嘛,就是一个feature,就是一个特点,

53:12.530 --> 53:16.450
书主的下标是没有办法通过obj的defineproperty变成想用式的,

53:16.610 --> 53:21.170
但是现在可以了,但是现在尽管可以了,

53:21.170 --> 53:29.490
也就是你可以通过这种方式,obj是defineproperty数据传进去,

53:29.490 --> 53:34.290
好比是,然后通过下标零把它定义成一个数据想用式,

53:34.290 --> 53:37.650
把下标零这个位置变成一个想用式,它有getter,

53:37.650 --> 53:42.290
尽管现在是可以的,但是也不应该这样做,为什么呢,

53:42.290 --> 53:44.530
因为数据里面有很多特殊的情况,

53:44.530 --> 53:47.970
像这种比方书主里面,你如果把它变成想用式了,

53:47.970 --> 53:52.210
你通过什么feature,通过map,这一方法得到了新书主,

53:52.210 --> 53:56.690
它又不但是想用式了,就变成又会造成很多怪异的问题,

53:56.690 --> 54:06.450
所以综合严而总之就是对书主而言,针对下标的修改和读取是不能有想用式的,

54:06.450 --> 54:10.450
就这么个意思,针对下标的读取和修改是不能有想用式的,

54:10.450 --> 54:12.210
所以说这个东西它监控不到,

54:12.290 --> 54:15.170
那现在就随便回答一下,之前那个问题,

54:19.070 --> 54:25.390
user.students0.ln,它是想用式吗?

54:26.430 --> 54:30.670
之前回答过,它是想用式,

54:30.670 --> 54:33.870
因为我这里不是修改书主某一项,

54:34.350 --> 54:37.630
我是修改这一项里边的东西,里边的东西是想用式的,

54:37.950 --> 54:40.030
只是你要修改这一项不是想用式的,

54:40.030 --> 54:44.430
就是你如果说用这种方式来复制,它是没有想用式的,

54:44.510 --> 54:46.430
它是不知道的,能理解吗?

54:46.430 --> 54:48.430
你用这种方式是没有想用式的,

54:48.430 --> 54:53.220
无想用式,

54:53.220 --> 54:55.220
这一块理解了吗?

54:55.220 --> 55:00.060
你要出个意义啊,

55:00.060 --> 55:02.060
所以说如果说,

55:02.060 --> 55:06.060
如果说你要一定要去修改书主某一个下标的话,

55:06.060 --> 55:08.060
那怎么办呢?

55:08.060 --> 55:10.060
第一种方式是使用那个set,

55:10.060 --> 55:12.060
使用那个set,

55:12.060 --> 55:14.060
你把那个书主传进去,

55:14.060 --> 55:16.060
好比是你要修改第一个下标为0的,

55:16.060 --> 55:18.060
你要把修改为red,这样子是可以的,

55:18.060 --> 55:20.060
因为通过这个方法呢,

55:20.060 --> 55:22.060
它就会通知,

55:22.060 --> 55:24.060
它就会在方法里边,

55:24.060 --> 55:26.060
它就会运行一些函数,导致界面刷新,

55:26.060 --> 55:28.060
这样子是可以的,

55:28.060 --> 55:30.060
然后呢,你也可以用这种方式啊,

55:32.060 --> 55:34.060
用啥方式呢?

55:34.060 --> 55:36.060
用啥方式也不是很好,

55:36.060 --> 55:38.060
在这个例子下面用啥方式,

55:38.060 --> 55:40.060
就用这种方式吧,

55:40.060 --> 55:42.060
或者是你把第一项删除了,

55:42.060 --> 55:44.060
然后再加一项啊也可以,

55:44.060 --> 55:47.500
比方说你这样吧,

55:47.500 --> 55:49.500
好比是,

55:49.500 --> 55:51.500
short吧,

55:51.500 --> 55:53.500
short,第一项删掉,

55:53.500 --> 55:55.500
删掉过后要用onshort,

55:55.500 --> 55:57.500
再加重新加一项,

55:57.500 --> 55:59.500
加一项那个,

55:59.500 --> 56:01.500
这样子是可以的,

56:01.500 --> 56:03.500
这些方法呢,无忧都有拦截,

56:03.500 --> 56:05.500
OK,那么这是我们的采访,

56:05.500 --> 56:07.500
哎呦,讲的也慢啊,

56:07.500 --> 56:09.500
采访第一部分讲完啊,

56:09.500 --> 56:11.500
啥意思,第一步要做的事情呢,

56:11.500 --> 56:13.500
就一个,就是要把一个对象变成想用式,

56:13.500 --> 56:15.500
你看它里边有很多细节啊,

56:15.500 --> 56:17.500
数组是怎么变想用式的,

56:17.500 --> 56:19.500
对象用式是怎么变想用式的啊,

56:19.500 --> 56:21.500
这件事情呢,

56:21.500 --> 56:23.500
发生这件事情呢,是发生在生命周期函数

56:23.500 --> 56:25.500
before create之后,

56:25.500 --> 56:27.500
crate的之前,

56:27.500 --> 56:29.500
也就是说,

56:29.500 --> 56:31.500
你在这个生命周期函数里边,

56:31.500 --> 56:33.500
它的数据就一定有想用式的,

56:33.500 --> 56:35.500
但是在这个生命周期函数里边,

56:35.500 --> 56:37.500
数据还没有想用式,

56:37.500 --> 56:39.500
它是发生的时间点是在这,

56:39.500 --> 56:41.500
第一部分的目标,

56:41.500 --> 56:43.500
就是把数据变成想用式,

56:43.500 --> 56:45.500
这样的话,

56:45.500 --> 56:47.500
我又能够听到,

56:47.500 --> 56:49.500
它直到它变了,

56:49.500 --> 56:51.500
就是它的目的,

56:51.500 --> 56:53.500
好,现在我们进入第二部分,

56:53.500 --> 56:55.500
要不我们开始一点复杂了,

56:55.500 --> 56:57.500
那么接下来,咱们的犹豫习大神,

56:57.500 --> 56:59.500
肯定就遇到了一个非常严重的问题,

56:59.500 --> 57:01.500
我现在直到它数据变了,

57:01.500 --> 57:03.500
我也直到你在读它的数据,

57:03.500 --> 57:05.500
但是你读它数据的时候,

57:05.500 --> 57:07.500
我要干嘛呢?

57:07.500 --> 57:09.500
数据变了,我又应该干嘛呢?

57:10.500 --> 57:12.500
就是你现在有两个问题没解决,

57:12.500 --> 57:14.500
读取数据的时候,

57:14.500 --> 57:17.500
到底,我除了把数据只给你,

57:17.500 --> 57:19.500
我还要有什么事情可以做呢?

57:19.500 --> 57:21.500
当数据变化的时候,

57:21.500 --> 57:24.500
我又有什么要用数据可以做呢?

57:24.500 --> 57:26.500
那么要解决这两个问题,

57:26.500 --> 57:27.500
需要依靠一个东西,

57:27.500 --> 57:29.500
一个东西是由于自己发明出来的,

57:29.500 --> 57:30.500
叫做DEP,

57:30.500 --> 57:32.500
它的全程叫做Dependency,

57:32.500 --> 57:33.500
叫做依赖,

57:33.500 --> 57:35.500
这是一个构造器,

57:35.500 --> 57:37.500
这个构造器我们也是用不了的,

57:37.500 --> 57:38.500
内部使用的,

57:38.500 --> 57:39.500
其实这里可以看一下,

57:39.500 --> 57:40.500
这些响应数据,

57:40.500 --> 57:42.500
它们里面都有一个东西,

57:42.500 --> 57:44.500
VM,

57:44.500 --> 57:46.500
我们随便找一个吧,

57:46.500 --> 57:47.500
找了一个有的,

57:47.500 --> 57:48.500
你看这个,

57:48.500 --> 57:50.500
不是个响应数据吗?

57:50.500 --> 57:52.500
刚才这个响应数据,

57:52.500 --> 57:53.500
是个响应数据吧,

57:53.500 --> 57:55.500
你看它里面,

57:55.500 --> 57:57.500
是不是有一个叫OB,

57:57.500 --> 57:59.500
这个玩意儿,

57:59.500 --> 58:03.070
里面是一个东西叫DEP,

58:03.070 --> 58:05.070
包括我们的数据,

58:05.070 --> 58:07.070
VMTOPIS,

58:07.070 --> 58:08.070
这个数据里面,

58:08.070 --> 58:10.070
它有个OB,

58:11.070 --> 58:12.070
OB是什么意思?

58:12.070 --> 58:13.070
就是里面玩那个,

58:13.070 --> 58:15.070
经常看一些什么电竞比赛,

58:15.070 --> 58:17.070
对吧,那些采一看就叫OB,

58:17.070 --> 58:18.070
就有一个东西在看它,

58:18.070 --> 58:19.070
看它到底变一变,

58:19.070 --> 58:22.070
它有一个DEP,看到没?

58:22.070 --> 58:24.070
那么这个东西是什么意思呢?

58:24.070 --> 58:27.070
它要做两件事,

58:27.070 --> 58:30.070
当我们读一个属性的时候,

58:30.070 --> 58:31.070
它要知道,

58:31.070 --> 58:33.070
谁在读,

58:33.070 --> 58:34.070
就谁在用我,

58:34.070 --> 58:35.070
这个过程叫做,

58:35.070 --> 58:38.070
依赖收集,

58:38.070 --> 58:39.070
记录依赖,

58:39.070 --> 58:42.070
拿个小本记一下,

58:42.070 --> 58:45.070
这个界面,

58:45.070 --> 58:46.070
第一个界面,

58:46.070 --> 58:48.070
在读摩利卡的爱好,

58:48.070 --> 58:50.070
拿个小本记一下,

58:50.070 --> 58:52.070
谁在用我,

58:52.070 --> 58:53.070
第二件事呢,

58:53.070 --> 58:54.070
它还有一个责任,

58:54.070 --> 58:55.070
它还有一个职责,

58:55.070 --> 58:56.070
就是派发更新,

58:56.070 --> 58:58.070
将来这个数据变了,

58:58.070 --> 58:59.070
我要通知那些

58:59.070 --> 59:01.070
曾经用到我的人,

59:01.070 --> 59:03.070
就要派发更新,

59:04.070 --> 59:06.070
这是澳洲的两件事,

59:06.070 --> 59:07.070
好,那么今天呢,

59:07.070 --> 59:08.070
我们还要解决一个问题,

59:08.070 --> 59:09.070
就是这个DEP,

59:09.070 --> 59:11.070
这个东西,

59:11.070 --> 59:12.070
它到底是一个,

59:12.070 --> 59:13.070
它到底跟我们的对象,

59:13.070 --> 59:14.070
跟我们的响应式对象,

59:14.070 --> 59:16.070
到底是一个什么样的关系呢?

59:16.070 --> 59:17.070
它是这么一种关系,

59:17.070 --> 59:18.070
大家看着啊,

59:18.070 --> 59:20.070
我这里是不是有个对象,

59:20.070 --> 59:23.070
咱们这里是不有个对象吗?

59:23.070 --> 59:26.070
这个对象是不是数据响应式的?

59:26.070 --> 59:27.070
怎么讲过了,

59:27.070 --> 59:29.070
是一个数据响应式对象,

59:29.070 --> 59:32.580
这样写吧,

59:32.580 --> 59:33.580
注意听,

59:33.580 --> 59:35.580
这个数据响应式对象里边,

59:35.580 --> 59:36.580
这些位置,

59:36.580 --> 59:38.580
全部都有一个响应的DEP,

59:38.580 --> 59:40.580
在看,在监听,

59:40.580 --> 59:41.580
第一个位置,

59:41.580 --> 59:42.580
就是对象本身,

59:42.580 --> 59:45.890
它会有个DEP,

59:45.890 --> 59:46.890
每一个属性,

59:46.890 --> 59:47.890
才会有个DEP,

59:47.890 --> 59:48.890
它们都不一样的啊,

59:48.890 --> 59:49.890
这个DEP跟这个DEP是不一样的,

59:49.890 --> 59:50.890
都是,

59:50.890 --> 59:51.890
因为每一个DEP,

59:51.890 --> 59:52.890
它都是通过

59:52.890 --> 59:53.890
勾到韩式创建出来的,

59:53.890 --> 59:55.890
所以每个DEP都不一样的啊,

59:55.890 --> 59:56.890
这个DEP呢,

59:56.890 --> 59:57.890
负责监听什么?

59:57.890 --> 59:59.890
监听这个对象本身的变化,

59:59.890 --> 01:00:00.890
那么这个DEP呢,

01:00:00.890 --> 01:00:02.890
负责监听这个属性的变化,

01:00:02.890 --> 01:00:04.890
就是你给这个属性复制,

01:00:04.890 --> 01:00:05.890
那么就表示,

01:00:05.890 --> 01:00:06.890
这个属性变了,

01:00:06.890 --> 01:00:08.890
好,那么这个U上呢,

01:00:08.890 --> 01:00:09.890
你看这个U上啊,

01:00:09.890 --> 01:00:10.890
这个U的这个位置,

01:00:10.890 --> 01:00:11.890
有很多个DEP,

01:00:11.890 --> 01:00:12.890
首先是,

01:00:12.890 --> 01:00:14.890
这个属性本身有个DEP,

01:00:14.890 --> 01:00:15.890
这个U上,

01:00:15.890 --> 01:00:16.890
属性本身,

01:00:16.890 --> 01:00:17.890
就是你可以输,

01:00:17.890 --> 01:00:18.890
给这个U上重新复制,

01:00:18.890 --> 01:00:19.890
比方说有一天,

01:00:19.890 --> 01:00:20.890
你用ZS点U上,

01:00:20.890 --> 01:00:22.890
给U上重新复制的时候,

01:00:22.890 --> 01:00:24.890
那么就是这个DEP在处理,

01:00:24.890 --> 01:00:25.890
明儿的意思吧?

01:00:25.890 --> 01:00:26.890
好,

01:00:26.890 --> 01:00:27.890
然后呢,

01:00:27.890 --> 01:00:28.890
这个ZS是个对象,

01:00:28.890 --> 01:00:29.890
对吧,

01:00:29.890 --> 01:00:31.890
这个对象本身是有个DEP,

01:00:31.890 --> 01:00:32.890
对方就很浪漫了,

01:00:32.890 --> 01:00:33.890
那么这个对象,

01:00:33.890 --> 01:00:34.890
本身的对付有什么用啊?

01:00:34.890 --> 01:00:36.890
这种情况它有用,

01:00:36.890 --> 01:00:37.890
比方说,

01:00:37.890 --> 01:00:39.890
我将来通过这种方式啊,

01:00:39.890 --> 01:00:40.890
ZS,

01:00:40.890 --> 01:00:41.890
ZS,

01:00:41.890 --> 01:00:42.890
U上,

01:00:42.890 --> 01:00:44.890
加一个属性内,

01:00:44.890 --> 01:00:46.890
摩利卡,

01:00:46.890 --> 01:00:47.890
那么这个,

01:00:47.890 --> 01:00:48.890
这个事情就是,

01:00:48.890 --> 01:00:49.890
这个对付在处理,

01:00:49.890 --> 01:00:50.890
啊,

01:00:50.890 --> 01:00:51.890
因为你说吧,

01:00:51.890 --> 01:00:52.890
不让它,

01:00:52.890 --> 01:00:53.890
不是它处理谁处理呢?

01:00:53.890 --> 01:00:55.890
我既没有给它复制,

01:00:55.890 --> 01:00:56.890
也没有读它的指,

01:00:56.890 --> 01:00:57.890
对吧?

01:00:57.890 --> 01:00:59.890
我也没有去读,

01:00:59.890 --> 01:01:00.890
也没有去改动,

01:01:00.890 --> 01:01:01.890
我是给它加属性,

01:01:01.890 --> 01:01:02.890
所以说,

01:01:02.890 --> 01:01:04.890
是这个对象本身的DEP来处理,

01:01:04.890 --> 01:01:05.890
像这种情况,

01:01:05.890 --> 01:01:06.890
它很多个DEP,

01:01:06.890 --> 01:01:08.890
那么这个A级本身有个DEP,

01:01:08.890 --> 01:01:09.890
好,

01:01:09.890 --> 01:01:10.890
下面属性,

01:01:10.890 --> 01:01:11.890
这个属性是个DEP,

01:01:11.890 --> 01:01:12.890
好,

01:01:12.890 --> 01:01:13.890
下面Hobbies,

01:01:13.890 --> 01:01:14.890
这个属性,

01:01:14.890 --> 01:01:15.890
属性本身是一个DEP,

01:01:15.890 --> 01:01:17.890
你看这里边好多DEP,

01:01:17.890 --> 01:01:19.890
我记得以前有,

01:01:19.890 --> 01:01:21.890
有一个非常变态的面试题,

01:01:21.890 --> 01:01:22.890
他问你,

01:01:22.890 --> 01:01:23.890
给你一个想象是对象,

01:01:23.890 --> 01:01:24.890
他问你,

01:01:24.890 --> 01:01:27.460
这里边有多少个DEP对象,

01:01:27.460 --> 01:01:28.460
好,

01:01:28.460 --> 01:01:29.460
那么这里边,

01:01:29.460 --> 01:01:30.460
Hobbies,

01:01:30.460 --> 01:01:31.460
Hobbies是个数组,

01:01:31.460 --> 01:01:32.460
这个数组里边,

01:01:32.460 --> 01:01:33.460
如果说是对象的话,

01:01:33.460 --> 01:01:34.460
那还有DEP,

01:01:34.460 --> 01:01:35.460
那么它不是对象,

01:01:35.460 --> 01:01:36.460
它是一个字五串,

01:01:36.460 --> 01:01:37.460
字五串是原式字,

01:01:37.460 --> 01:01:38.460
它没法用DEP,

01:01:38.460 --> 01:01:39.460
所以说,

01:01:39.460 --> 01:01:41.460
这个属性本身有个DEP,

01:01:41.460 --> 01:01:42.460
然后,

01:01:42.460 --> 01:01:44.460
这个数组本身有个DEP,

01:01:44.460 --> 01:01:46.460
所以这里边有多少个DEP,

01:01:46.460 --> 01:01:47.460
有一,

01:01:47.460 --> 01:01:48.460
二,

01:01:48.460 --> 01:01:49.460
三,

01:01:49.460 --> 01:01:50.460
四,

01:01:50.460 --> 01:01:53.340
五,

01:01:53.340 --> 01:01:54.340
六,

01:01:54.340 --> 01:01:55.340
七,

01:01:55.340 --> 01:01:56.340
八,

01:01:56.340 --> 01:01:57.340
有八个DEP,

01:01:57.340 --> 01:01:58.340
这个DEP干嘛的,

01:01:58.340 --> 01:01:59.340
这个DEP是坚定这个的,

01:01:59.340 --> 01:02:00.340
比方说,

01:02:00.340 --> 01:02:01.340
有一天我给这个Hobbies,

01:02:01.340 --> 01:02:02.340
重新复制,

01:02:02.340 --> 01:02:03.340
不再是数组了,

01:02:03.340 --> 01:02:05.340
那么就是这个DEP的坚定,

01:02:05.340 --> 01:02:06.340
然后呢,

01:02:06.340 --> 01:02:08.340
有一天我给它的PUSH的时候,

01:02:08.340 --> 01:02:09.340
PUSH,

01:02:09.340 --> 01:02:10.340
它的时候,

01:02:10.340 --> 01:02:12.340
是它在坚定,

01:02:12.340 --> 01:02:13.340
明白了意思吗?

01:02:13.340 --> 01:02:15.340
这一块能听懂吗?

01:02:15.340 --> 01:02:17.340
这一块,

01:02:17.340 --> 01:02:22.000
它就超级多了一个DEP,

01:02:22.000 --> 01:02:23.000
在里边坚定,

01:02:23.000 --> 01:02:25.000
那么我再举个例子啊,

01:02:25.000 --> 01:02:27.000
每个DEP的指责是什么,

01:02:27.000 --> 01:02:28.000
一个是搜集依赖,

01:02:28.000 --> 01:02:29.000
依赖搜集,

01:02:29.000 --> 01:02:30.000
什么叫依赖搜集,

01:02:30.000 --> 01:02:32.000
就是看谁在拥有,

01:02:32.000 --> 01:02:34.000
这个DEP,

01:02:34.000 --> 01:02:35.000
这个DEP呢,

01:02:35.000 --> 01:02:36.000
我们一般都用不到啊,

01:02:36.000 --> 01:02:37.000
就看这个DEP,

01:02:37.000 --> 01:02:38.000
这个DEP我就先不写了吧,

01:02:38.000 --> 01:02:39.000
这个DEP我一般一梦到,

01:02:39.000 --> 01:02:41.000
就是跟对象我们一般用不到,

01:02:41.000 --> 01:02:42.000
就看这个DEP,

01:02:42.000 --> 01:02:43.000
这个DEP呢,

01:02:43.000 --> 01:02:44.000
它坚定什么呢?

01:02:44.000 --> 01:02:45.000
坚定你,

01:02:45.000 --> 01:02:47.000
有没有在读我的抬头?

01:02:47.000 --> 01:02:48.000
有的话我就进行依赖搜集,

01:02:48.000 --> 01:02:49.000
其实依赖搜集呢,

01:02:49.000 --> 01:02:50.000
它实际上在内部呢,

01:02:50.000 --> 01:02:53.000
调用了一个函数叫DEPEND,

01:02:53.000 --> 01:02:54.000
你看,

01:02:54.000 --> 01:02:55.000
我们不是有个响应识对象吗?

01:02:55.000 --> 01:02:56.000
响应识对象有一个,

01:02:56.000 --> 01:02:57.000
不是GETTA和SETTA吗?

01:02:57.000 --> 01:02:58.000
对吧?

01:02:58.000 --> 01:02:59.000
当你读它的时候,

01:02:59.000 --> 01:03:00.000
你会调用DEPEND,

01:03:00.000 --> 01:03:01.000
表示,

01:03:01.000 --> 01:03:02.000
诶,有人在读我了,

01:03:02.000 --> 01:03:03.000
我记录一下,

01:03:03.000 --> 01:03:04.000
拿个小板记录一下,

01:03:04.000 --> 01:03:05.000
将来我的属性一变,

01:03:05.000 --> 01:03:06.000
我就会调用另一个方法,

01:03:06.000 --> 01:03:07.000
叫做NOTEPEND,

01:03:07.000 --> 01:03:08.000
表示更新了,

01:03:08.000 --> 01:03:09.000
诶,你们听好了啊,

01:03:09.000 --> 01:03:10.000
我现在变了,

01:03:10.000 --> 01:03:11.000
你们该干嘛去干嘛?

01:03:11.000 --> 01:03:12.000
啊,

01:03:12.000 --> 01:03:13.000
我们可以去,

01:03:13.000 --> 01:03:14.000
其实我们这里呢,

01:03:14.000 --> 01:03:15.000
可以给大家看一下,

01:03:15.000 --> 01:03:16.000
五月的元码啊,

01:03:16.000 --> 01:03:17.000
呃,这是五月的元码,

01:03:17.000 --> 01:03:18.000
我们这里,

01:03:18.000 --> 01:03:19.000
其实可以去搜一下吧,

01:03:19.000 --> 01:03:20.000
就是搜索啊,

01:03:20.000 --> 01:03:21.000
DEP,

01:03:21.000 --> 01:03:22.000
这个DEP,

01:03:22.000 --> 01:03:25.270
啊,

01:03:25.270 --> 01:03:26.270
这些必有的东西,

01:03:26.270 --> 01:03:27.270
不用管了啊,

01:03:28.270 --> 01:03:29.270
我一看这儿,

01:03:29.270 --> 01:03:30.270
看到没?

01:03:30.270 --> 01:03:32.270
啊,我这个是Defend property,

01:03:32.270 --> 01:03:33.270
看关键代码,

01:03:33.270 --> 01:03:34.270
其他东西都不用管了,

01:03:34.270 --> 01:03:36.270
这里边有些干扰箱很多,

01:03:36.270 --> 01:03:37.270
呃,get,

01:03:37.270 --> 01:03:38.270
是不是get的方法,

01:03:38.270 --> 01:03:39.270
get的方法里边,

01:03:39.270 --> 01:03:40.270
是不是有一个DEPEND的,

01:03:40.270 --> 01:03:42.270
表示我在搜集依赖,

01:03:42.270 --> 01:03:43.270
针对这个属性,

01:03:43.270 --> 01:03:45.270
有人在读我,

01:03:45.270 --> 01:03:46.270
运行到get,

01:03:46.270 --> 01:03:47.270
说肯定有人在读我,

01:03:47.270 --> 01:03:48.270
对吧,

01:03:48.270 --> 01:03:49.270
搜集依赖,

01:03:49.270 --> 01:03:50.270
诶,将来在settle的时候,

01:03:50.270 --> 01:03:52.270
我如果说有变化,

01:03:52.270 --> 01:03:53.270
你看一下啊,

01:03:53.270 --> 01:03:55.270
我如果说有变化的话,

01:03:55.270 --> 01:03:57.270
是不是我这里给note犯,

01:03:57.270 --> 01:03:58.270
对不对,

01:03:58.270 --> 01:03:59.270
而且呢,

01:03:59.270 --> 01:04:00.270
我这里还有一个判断啊,

01:04:00.270 --> 01:04:01.270
如果说我的值,

01:04:01.270 --> 01:04:03.270
如果说你给我修改,

01:04:03.270 --> 01:04:04.270
修改的值,

01:04:04.270 --> 01:04:05.270
跟原来的值是一样的,

01:04:05.270 --> 01:04:06.270
那我就,

01:04:06.270 --> 01:04:07.270
啥子不管,

01:04:07.270 --> 01:04:08.270
只有跟原来的值

01:04:08.270 --> 01:04:09.270
不一样的情况下,

01:04:09.270 --> 01:04:10.270
来,

01:04:10.270 --> 01:04:11.270
那我们就note犯,

01:04:11.270 --> 01:04:12.270
是不是有一个拍发更新,

01:04:12.270 --> 01:04:13.270
对吧,

01:04:13.270 --> 01:04:14.270
所以说呢,

01:04:14.270 --> 01:04:15.270
我们,

01:04:15.270 --> 01:04:16.270
基于,

01:04:16.270 --> 01:04:17.270
基于此呢,

01:04:17.270 --> 01:04:18.270
你会发现,

01:04:18.270 --> 01:04:19.270
栽培诱里边呢,

01:04:19.270 --> 01:04:20.270
有一个非常智能的现象,

01:04:20.270 --> 01:04:21.270
什么现象呢?

01:04:21.270 --> 01:04:22.270
给大家看一下啊,

01:04:22.270 --> 01:04:23.270
我这里就,

01:04:23.270 --> 01:04:24.270
这样吧,

01:04:24.270 --> 01:04:25.270
这样写啊,

01:04:26.270 --> 01:04:27.270
这东西就暂时,

01:04:27.270 --> 01:04:28.270
删掉了啊,

01:04:28.270 --> 01:04:29.270
好,

01:04:29.270 --> 01:04:30.270
看着啊,

01:04:30.270 --> 01:04:31.270
就这么一个,

01:04:31.270 --> 01:04:32.270
人过来,

01:04:32.270 --> 01:04:33.270
你看我们的界面上,

01:04:33.270 --> 01:04:34.270
用到了谁?

01:04:34.270 --> 01:04:35.270
你首先要清楚啊,

01:04:35.270 --> 01:04:36.270
你现在学到现在呢,

01:04:36.270 --> 01:04:37.270
你应该知道,

01:04:37.270 --> 01:04:38.270
这个东西,

01:04:38.270 --> 01:04:39.270
应该是个Render函数,

01:04:39.270 --> 01:04:40.270
它不是一个

01:04:40.270 --> 01:04:41.270
ATM字不错啊,

01:04:41.270 --> 01:04:43.270
它是个Render函数,

01:04:43.270 --> 01:04:44.270
最终会变成Render函数,

01:04:44.270 --> 01:04:45.270
也说这个Render函数里边,

01:04:45.270 --> 01:04:46.270
一定用到了这个

01:04:46.270 --> 01:04:48.270
user.ag,

01:04:48.270 --> 01:04:49.270
是不是一定用到了

01:04:49.270 --> 01:04:50.270
user.ag,

01:04:50.270 --> 01:04:51.270
或者说,

01:04:51.270 --> 01:04:52.270
我干脆把它写成

01:04:52.270 --> 01:04:53.270
Render函数,

01:04:53.270 --> 01:04:55.270
去把它写成Render函数,

01:04:55.270 --> 01:04:59.160
好,看着啊,

01:04:59.160 --> 01:05:00.160
现在呢,

01:05:00.160 --> 01:05:01.160
我们Return,

01:05:01.160 --> 01:05:02.160
什么呢,

01:05:02.160 --> 01:05:03.160
ag,

01:05:03.160 --> 01:05:04.160
我就难得写,

01:05:04.160 --> 01:05:05.160
DIV啦,

01:05:05.160 --> 01:05:06.160
就一个ag,

01:05:06.160 --> 01:05:07.160
ag里边的内容呢,

01:05:07.160 --> 01:05:08.160
就是,

01:05:08.160 --> 01:05:09.160
年年,

01:05:09.160 --> 01:05:10.160
冒号,

01:05:10.160 --> 01:05:11.160
听接个字符创,

01:05:11.160 --> 01:05:12.160
就是es6的听接语法啊,

01:05:12.160 --> 01:05:13.160
听接个字符创,

01:05:13.160 --> 01:05:14.160
就是js.user.ag,

01:05:14.160 --> 01:05:15.160
好,

01:05:15.160 --> 01:05:16.160
不要模板,

01:05:16.160 --> 01:05:17.160
模板还是,

01:05:17.160 --> 01:05:18.160
不然,

01:05:18.160 --> 01:05:19.160
它不知道发展的位置,

01:05:19.160 --> 01:05:20.160
好,

01:05:20.160 --> 01:05:21.160
现在我们Render,

01:05:21.160 --> 01:05:22.160
我们这里输出一个Render,

01:05:22.160 --> 01:05:24.730
这样看的非常清楚,

01:05:24.730 --> 01:05:25.730
你看,

01:05:25.730 --> 01:05:26.730
渲染的吧,

01:05:26.730 --> 01:05:27.730
对不对,

01:05:28.730 --> 01:05:29.730
我们先暂时,

01:05:29.730 --> 01:05:30.730
先用这个吧,

01:05:30.730 --> 01:05:32.730
先暂时用抬头吧,

01:05:32.730 --> 01:05:35.730
先暂时用抬头啊,

01:05:35.730 --> 01:05:36.730
好说明问题,

01:05:36.730 --> 01:05:37.730
用的是它啊,

01:05:37.730 --> 01:05:38.730
抬头,

01:05:38.730 --> 01:05:39.730
好,

01:05:39.730 --> 01:05:40.730
运行到Render,

01:05:40.730 --> 01:05:41.730
那么接下来我们看,

01:05:41.730 --> 01:05:44.730
如果说我现在去改变这个Lin,

01:05:44.730 --> 01:05:46.730
你觉得会不会重新渲染了,

01:05:46.730 --> 01:05:50.260
同学们,

01:05:50.260 --> 01:05:59.300
你们觉得会不会重新渲染,

01:05:59.300 --> 01:06:00.300
会吧,

01:06:00.300 --> 01:06:01.300
好,

01:06:01.300 --> 01:06:03.300
那么我们来看一下,

01:06:03.300 --> 01:06:05.300
有没有运行Render啊,

01:06:05.300 --> 01:06:06.300
是没有,

01:06:06.300 --> 01:06:08.300
这就是它无忧它智能的地方,

01:06:08.300 --> 01:06:10.300
它有一个依赖收集,

01:06:10.300 --> 01:06:11.300
你看啊,

01:06:12.300 --> 01:06:13.300
我在这个Render,

01:06:13.300 --> 01:06:14.300
Render是个函数,

01:06:14.300 --> 01:06:15.300
对不对,

01:06:15.300 --> 01:06:16.300
我在Render函数中用到了谁,

01:06:16.300 --> 01:06:17.300
用到了抬头,

01:06:17.300 --> 01:06:19.300
抬头里边是不是有getter,

01:06:19.300 --> 01:06:20.300
是不是有getter东西,

01:06:20.300 --> 01:06:21.300
是不是在运行这个getter,

01:06:21.300 --> 01:06:23.300
getter里边是不是在记录,

01:06:23.300 --> 01:06:24.300
哦,

01:06:24.300 --> 01:06:25.300
谁,

01:06:25.300 --> 01:06:26.300
谁在用我,

01:06:26.300 --> 01:06:30.680
有一个Render小朋友,

01:06:30.680 --> 01:06:32.680
在用我,

01:06:32.680 --> 01:06:34.680
它就会拿个小本记录一下,

01:06:34.680 --> 01:06:35.680
对吧,

01:06:35.680 --> 01:06:36.680
然后呢,

01:06:36.680 --> 01:06:38.680
将来我如果说抬头变化的时候,

01:06:38.680 --> 01:06:43.630
然后对抬头发生变化,

01:06:43.630 --> 01:06:45.630
它为什么能够重新渲染,

01:06:45.630 --> 01:06:48.630
是因为在这里有个notify,

01:06:48.630 --> 01:06:56.630
之前用我那个叫Render的小朋友,

01:06:56.630 --> 01:06:57.630
对吧,

01:06:57.630 --> 01:06:59.630
你再来一次,

01:06:59.630 --> 01:07:01.630
再运行一次,

01:07:01.630 --> 01:07:03.630
就起这么一个作用,

01:07:03.630 --> 01:07:04.630
其实吧,

01:07:04.630 --> 01:07:05.630
所以说,

01:07:05.630 --> 01:07:06.630
你改动抬头的时候,

01:07:06.630 --> 01:07:07.630
当然没有任何问题,

01:07:07.630 --> 01:07:08.630
它会Render,

01:07:08.630 --> 01:07:09.630
但是,

01:07:09.630 --> 01:07:10.630
你改动这个name的时候,

01:07:10.630 --> 01:07:11.630
有没有Render,

01:07:11.630 --> 01:07:13.630
这个name有没有记录,

01:07:13.630 --> 01:07:14.630
记录这个Render,

01:07:14.630 --> 01:07:15.630
没有记录啊,

01:07:15.630 --> 01:07:17.630
你看,

01:07:17.630 --> 01:07:19.630
我们读它的抬头的时候,

01:07:19.630 --> 01:07:21.630
是不是这个dip在记录,

01:07:21.630 --> 01:07:22.630
这个dip在记录这个抬头,

01:07:22.630 --> 01:07:23.630
对吧,

01:07:23.630 --> 01:07:24.630
但是你的name这个dip,

01:07:24.630 --> 01:07:25.630
有没有记录啊,

01:07:25.630 --> 01:07:26.630
有没有记录它啊,

01:07:26.630 --> 01:07:27.630
没有,

01:07:27.630 --> 01:07:28.630
为什么呢,

01:07:28.630 --> 01:07:29.630
因为我在Render的运行过程中,

01:07:29.630 --> 01:07:31.630
并没有运行,

01:07:31.630 --> 01:07:32.630
并没有用到这个name,

01:07:32.630 --> 01:07:33.630
所以说,

01:07:33.630 --> 01:07:34.630
我在Render的过程中,

01:07:34.630 --> 01:07:35.630
换句话说,

01:07:35.630 --> 01:07:37.630
我在Render的执行过程中,

01:07:37.630 --> 01:07:39.630
并不会,

01:07:39.630 --> 01:07:41.630
就是并没有运行name的getter,

01:07:41.630 --> 01:07:42.630
你让它意思吧,

01:07:42.630 --> 01:07:44.630
name不是一个getter吗,

01:07:44.630 --> 01:07:46.630
getter里边才会记录依赖吗,

01:07:46.630 --> 01:07:47.630
但是name这个dip,

01:07:47.630 --> 01:07:49.630
它根本就没有记录这个依赖,

01:07:49.630 --> 01:07:50.630
所以说,

01:07:50.630 --> 01:07:52.630
我改动其它无关的属性,

01:07:52.630 --> 01:07:53.630
是不会变化的,

01:07:53.630 --> 01:07:55.630
这就是无忧智能的地方,

01:07:55.630 --> 01:07:56.630
只有改动,

01:07:56.630 --> 01:07:57.630
我们就,

01:07:57.630 --> 01:07:59.630
就是这个函数里边要用到的东西,

01:07:59.630 --> 01:08:00.630
它才会变,

01:08:00.630 --> 01:08:02.630
这种东西它是不会变的,

01:08:02.630 --> 01:08:04.630
这就是以它遗难手机,

01:08:04.630 --> 01:08:06.630
想比于reactor,

01:08:06.630 --> 01:08:07.630
要厉害的地方,

01:08:07.630 --> 01:08:08.630
知道吧,

01:08:08.630 --> 01:08:10.630
它不会自动Render的,

01:08:10.630 --> 01:08:12.630
我以前一定要摒弃,

01:08:12.630 --> 01:08:14.630
那种想法就是,

01:08:14.630 --> 01:08:15.630
我数据变了,

01:08:15.630 --> 01:08:16.630
要运行Render,

01:08:16.630 --> 01:08:17.630
你一定要摒弃这个想法,

01:08:17.630 --> 01:08:18.630
所以说,

01:08:18.630 --> 01:08:19.630
我在本节课一开始的时候,

01:08:19.630 --> 01:08:20.630
给你们说了,

01:08:20.630 --> 01:08:21.630
一定要摒弃这个想法,

01:08:21.630 --> 01:08:23.630
什么叫数据响应式,

01:08:23.630 --> 01:08:24.630
数据变化了,

01:08:24.630 --> 01:08:28.630
去运行一些合适的函数,

01:08:28.630 --> 01:08:29.630
这才叫数据响应式,

01:08:29.630 --> 01:08:30.630
并不是说,

01:08:30.630 --> 01:08:34.780
我一定要运行Render,不一定的,

01:08:34.780 --> 01:08:35.780
不写Render,

01:08:35.780 --> 01:08:36.780
它也不会更新的,

01:08:36.780 --> 01:08:38.780
只剩我们写到Render的话,

01:08:38.780 --> 01:08:39.780
我可以输出,

01:08:39.780 --> 01:08:40.780
写不写Render是一样的,

01:08:40.780 --> 01:08:41.780
因为我这样,

01:08:41.780 --> 01:08:42.780
Render这样的写,

01:08:42.780 --> 01:08:43.780
跟我在这里写,

01:08:43.780 --> 01:08:44.780
有什么区别呢,

01:08:44.780 --> 01:08:45.780
你告诉我,

01:08:45.780 --> 01:08:46.780
这个玩意,

01:08:46.780 --> 01:08:52.150
不也会变成那个Render吗?

01:08:52.150 --> 01:08:53.150
这个玩意,

01:08:53.150 --> 01:08:54.150
不也会变成Render吗?

01:08:54.150 --> 01:08:58.680
它变成Render就是这个样子,

01:08:58.680 --> 01:09:00.680
它根本不会判断的,

01:09:00.680 --> 01:09:01.680
不会判断的,

01:09:01.680 --> 01:09:03.680
你看啊,

01:09:03.680 --> 01:09:04.680
我在Render的执行过程中,

01:09:04.680 --> 01:09:05.680
你看我用到了谁,

01:09:05.680 --> 01:09:07.680
用到了这个Title,对吧,

01:09:07.680 --> 01:09:08.680
于是Title里边,

01:09:08.680 --> 01:09:09.680
是不是有个Dep,

01:09:09.680 --> 01:09:11.680
Dep里边就记录,

01:09:11.680 --> 01:09:12.680
它有一个,

01:09:12.680 --> 01:09:14.680
它里边有想象成一个数组,

01:09:14.680 --> 01:09:15.680
它记录一个Render还数,

01:09:15.680 --> 01:09:17.680
用到了我Title,

01:09:17.680 --> 01:09:18.680
它有个小半,

01:09:18.680 --> 01:09:19.680
记录一下,

01:09:19.680 --> 01:09:20.680
其他的属性有记录吗?

01:09:20.680 --> 01:09:21.680
其他的Dep有记录吗?

01:09:21.680 --> 01:09:22.680
没有记录,

01:09:22.680 --> 01:09:23.680
Render就运行完了,

01:09:23.680 --> 01:09:24.680
看到没?

01:09:24.680 --> 01:09:25.680
为什么这个Dep能记录,

01:09:25.680 --> 01:09:27.680
因为Title里边有个Gator,

01:09:27.680 --> 01:09:28.680
知道吧?

01:09:28.680 --> 01:09:29.680
不会啊,

01:09:29.680 --> 01:09:30.680
因为我没有,

01:09:30.680 --> 01:09:32.680
哪里要想啊,

01:09:32.680 --> 01:09:33.680
哪里这样想吧?

01:09:33.680 --> 01:09:35.680
Name为什么它不会记录?

01:09:35.680 --> 01:09:36.680
你要想,

01:09:36.680 --> 01:09:37.680
在什么时候记录的?

01:09:37.680 --> 01:09:38.680
它在什么时候记录的?

01:09:38.680 --> 01:09:40.680
它是不是在Gator里边记录的?

01:09:40.680 --> 01:09:44.120
是不是在Gator里边记录的?

01:09:44.120 --> 01:09:46.120
这里边有,Name有机会,

01:09:46.120 --> 01:09:48.120
运行Gator吗?

01:09:48.120 --> 01:09:49.120
有没有,

01:09:49.120 --> 01:09:50.120
这个Render的执行过程中,

01:09:50.120 --> 01:09:52.120
有没有运行Name的Gator?

01:09:52.120 --> 01:09:54.120
有没有运行Name的Gator吗?

01:09:54.120 --> 01:09:58.070
这没有雕用嘛,对不对?

01:09:58.070 --> 01:09:59.070
所以说,

01:09:59.070 --> 01:10:00.070
为什么有依赖收集,

01:10:00.070 --> 01:10:02.070
依赖收集厉害的地方就在这儿?

01:10:02.070 --> 01:10:04.070
你只有用到了它,

01:10:04.070 --> 01:10:06.070
我才会坚定它的变化,

01:10:06.070 --> 01:10:07.070
没有用到我,

01:10:07.070 --> 01:10:08.070
一变你的,

01:10:08.070 --> 01:10:09.070
我不会动的,

01:10:09.070 --> 01:10:10.070
知道了?

01:10:10.070 --> 01:10:11.070
所以说,

01:10:11.070 --> 01:10:12.070
我们可以看到,

01:10:12.070 --> 01:10:13.070
这里边,

01:10:13.070 --> 01:10:15.070
这些Depth的小笨子就是空的,

01:10:15.070 --> 01:10:17.070
根本没有东西,

01:10:17.070 --> 01:10:18.070
所以说,

01:10:18.070 --> 01:10:19.070
这里特别智能啊,

01:10:19.070 --> 01:10:20.070
比方说我这里,

01:10:20.070 --> 01:10:21.070
设这个台头,

01:10:21.070 --> 01:10:23.070
然后再显示一个ZS点,

01:10:23.070 --> 01:10:24.070
Name,

01:10:24.070 --> 01:10:25.070
现在是不是,

01:10:25.070 --> 01:10:26.070
这个小笨,

01:10:26.070 --> 01:10:27.070
记录了一个Render,

01:10:27.070 --> 01:10:29.070
然后Name这个属性,

01:10:29.070 --> 01:10:31.070
它也记录了一个Render,

01:10:31.070 --> 01:10:32.070
对吧?

01:10:32.070 --> 01:10:33.070
那么现在台头变了,

01:10:33.070 --> 01:10:34.070
要不要变,

01:10:34.070 --> 01:10:35.070
要不要运行Render,

01:10:35.070 --> 01:10:36.070
要,

01:10:36.070 --> 01:10:37.070
那这些变了,

01:10:37.070 --> 01:10:38.070
跟它有关系吗?

01:10:38.070 --> 01:10:39.070
没有关系,

01:10:39.070 --> 01:10:40.070
懂得意思吗?

01:10:40.070 --> 01:10:41.070
这些数字变了,

01:10:41.070 --> 01:10:42.070
跟它有关系吗?

01:10:42.070 --> 01:10:43.070
没关系,

01:10:43.070 --> 01:10:44.070
至于5U,

01:10:44.070 --> 01:10:45.070
它特别厉害的地方,

01:10:45.070 --> 01:10:47.070
它能够非常精准的记录,

01:10:47.070 --> 01:10:49.070
我到底用到了哪些数据?

01:10:49.070 --> 01:10:50.070
是不是很巧妙?

01:10:50.070 --> 01:10:52.070
它这种方式非常巧妙,

01:10:52.070 --> 01:10:57.280
就是一个极其精妙的系统,

01:10:57.280 --> 01:10:58.280
然后我们再看,

01:10:58.280 --> 01:11:00.280
再看一个有意思的,

01:11:00.280 --> 01:11:01.280
它到底精妙,

01:11:01.280 --> 01:11:02.280
有些地方呢,

01:11:02.280 --> 01:11:03.280
它其实自己也不好处理,

01:11:03.280 --> 01:11:04.280
比方说,

01:11:04.280 --> 01:11:06.280
我这里显示的是User点,

01:11:06.280 --> 01:11:07.280
A级,

01:11:07.280 --> 01:11:08.280
你看着啊,

01:11:08.280 --> 01:11:10.280
这就有点意思了啊,

01:11:10.280 --> 01:11:13.280
或者我Name在这里边,

01:11:13.280 --> 01:11:14.280
比方说啊,

01:11:14.280 --> 01:11:15.280
举个例子啊,

01:11:15.280 --> 01:11:17.280
我Name在这里边,

01:11:17.280 --> 01:11:19.280
然后呢,

01:11:19.280 --> 01:11:20.280
我读的,

01:11:20.280 --> 01:11:21.280
我读的是什么呢?

01:11:21.280 --> 01:11:23.280
User点Name,

01:11:23.280 --> 01:11:25.280
我记得这是一道面词题,

01:11:25.280 --> 01:11:26.280
哇,

01:11:26.280 --> 01:11:27.280
如果说出这道面词题的话,

01:11:27.280 --> 01:11:29.280
就是非常非常深,

01:11:29.280 --> 01:11:32.280
我很少看到这样的面词题,

01:11:32.280 --> 01:11:33.280
就类似的,

01:11:33.280 --> 01:11:34.280
我原题记不清楚了,

01:11:34.280 --> 01:11:36.280
就是这个意思,

01:11:36.280 --> 01:11:37.280
你必须要理解,

01:11:37.280 --> 01:11:38.280
我有这个非常深入的知识,

01:11:38.280 --> 01:11:41.280
你才能回答出来,

01:11:41.280 --> 01:11:43.280
我这里显示的是用户的姓名,

01:11:43.280 --> 01:11:47.190
好,

01:11:47.190 --> 01:11:48.190
看着啊,

01:11:48.190 --> 01:11:52.360
我用行人的,

01:11:52.360 --> 01:11:53.360
那一开始肯定要用行人的嘛,

01:11:53.360 --> 01:11:54.360
对吧,

01:11:54.360 --> 01:11:55.360
显示Molica,

01:11:55.360 --> 01:11:56.360
接下来我做这么一件事,

01:11:56.360 --> 01:11:57.360
看着,

01:11:57.360 --> 01:11:59.360
我这里set,

01:11:59.360 --> 01:12:01.360
VMUser,

01:12:01.360 --> 01:12:03.360
你说我往这个User里边,

01:12:03.360 --> 01:12:05.360
加一个属性,

01:12:05.360 --> 01:12:06.360
A级,

01:12:06.360 --> 01:12:08.360
给它设为17,

01:12:08.360 --> 01:12:09.360
请问,

01:12:09.360 --> 01:12:11.360
会不会重新运行Render?

01:12:11.360 --> 01:12:13.360
你说我现在有这么一句代吗?

01:12:13.360 --> 01:12:18.620
有这么一句代吗?

01:12:18.620 --> 01:12:30.960
会不会重新运行Render?

01:12:30.960 --> 01:12:32.960
哈哈哈,

01:12:32.960 --> 01:12:34.960
程序这个同学,

01:12:34.960 --> 01:12:36.960
情账还是蛮高的啊,

01:12:36.960 --> 01:12:38.960
情账还是蛮高的,

01:12:38.960 --> 01:12:40.960
按理说是不应该的,

01:12:40.960 --> 01:12:41.960
对不对,

01:12:41.960 --> 01:12:42.960
按道理的说,

01:12:42.960 --> 01:12:43.960
确实不应该,

01:12:43.960 --> 01:12:44.960
为什么不应该呢?

01:12:44.960 --> 01:12:46.960
因为你这里都没有用到A级啊,

01:12:46.960 --> 01:12:48.960
你都没有用到A级,对不对,

01:12:48.960 --> 01:12:49.960
那么我这里加个A级,

01:12:49.960 --> 01:12:50.960
跟你有啥关系呢?

01:12:50.960 --> 01:12:51.960
跟你的界面有啥关系呢?

01:12:51.960 --> 01:12:53.960
应该是不应该,

01:12:53.960 --> 01:12:54.960
运行的啊,

01:12:54.960 --> 01:12:55.960
但是呢,实际上,

01:12:55.960 --> 01:12:56.960
肯定要运行啊,

01:12:56.960 --> 01:12:57.960
因为我都这样温的,

01:12:57.960 --> 01:12:58.960
肯定要运行,

01:12:58.960 --> 01:12:59.960
这就是面试,

01:12:59.960 --> 01:13:00.960
那么面试这些问题,

01:13:00.960 --> 01:13:02.960
为什么?

01:13:02.960 --> 01:13:04.960
你看,

01:13:04.960 --> 01:13:06.960
那么为什么呢?

01:13:06.960 --> 01:13:08.960
把这张图文拿出来就明白了,

01:13:08.960 --> 01:13:16.690
我们这里用这种方式,

01:13:16.690 --> 01:13:18.690
给它添加属性,

01:13:18.690 --> 01:13:19.690
相当于是在通知嘛,

01:13:19.690 --> 01:13:20.690
首先我们看一下,

01:13:20.690 --> 01:13:22.690
我们Depp里面的记录,

01:13:22.690 --> 01:13:23.690
Depp里面的记录,

01:13:23.690 --> 01:13:24.690
目前我们ZS,

01:13:24.690 --> 01:13:25.690
ZS不用管它啊,

01:13:25.690 --> 01:13:27.690
比较U字,

01:13:27.690 --> 01:13:28.690
这句话是在读属性,

01:13:28.690 --> 01:13:30.690
还是在复制属性,

01:13:30.690 --> 01:13:32.690
因为这是一个表达式,对吧,

01:13:32.690 --> 01:13:34.690
表达式它是一段一段运行的,

01:13:34.690 --> 01:13:35.690
先运行这一段,

01:13:35.690 --> 01:13:38.690
这段运行出来过后再运行这一段,

01:13:38.690 --> 01:13:39.690
这段是不是在读啊?

01:13:39.690 --> 01:13:40.690
读的是啥?

01:13:40.690 --> 01:13:42.690
读的是这个属性,

01:13:42.690 --> 01:13:43.690
看到没?

01:13:43.690 --> 01:13:44.690
除了这个Depp里面,

01:13:44.690 --> 01:13:45.690
有没有记录呢?

01:13:45.690 --> 01:13:48.690
有记录,

01:13:48.690 --> 01:13:49.690
这个Depp,

01:13:49.690 --> 01:13:51.690
真的这个属性本身有记录,

01:13:51.690 --> 01:13:55.130
它会记录一个Render,

01:13:55.130 --> 01:13:58.700
那么将来如果说你有一天,

01:13:58.700 --> 01:14:00.700
你对这个U字直接重新复制,

01:14:00.700 --> 01:14:02.700
那么它就会重新运行Render,

01:14:02.700 --> 01:14:03.700
它主要是为了,

01:14:03.700 --> 01:14:04.700
为了考虑到这个问题,

01:14:04.700 --> 01:14:06.700
它同时,

01:14:06.700 --> 01:14:08.700
由于它是一个对象,

01:14:08.700 --> 01:14:10.700
由于它是一个对象,

01:14:10.700 --> 01:14:12.700
它会做这么一个特殊处理,

01:14:12.700 --> 01:14:13.700
这个对象呢,

01:14:13.700 --> 01:14:16.700
也要设置一个Render,

01:14:16.700 --> 01:14:18.700
它为什么要这样做?

01:14:18.700 --> 01:14:20.700
以后我们再看,

01:14:20.700 --> 01:14:21.700
总之它会这样做,

01:14:21.700 --> 01:14:22.700
这个对象里边,

01:14:22.700 --> 01:14:23.700
它也会记录,

01:14:23.700 --> 01:14:24.700
然后呢,

01:14:25.700 --> 01:14:26.700
这里是个Name属性,

01:14:30.700 --> 01:14:31.700
你用的是这个属性,

01:14:31.700 --> 01:14:32.700
那么这个Depp呢,

01:14:32.700 --> 01:14:33.700
也会记录,

01:14:33.700 --> 01:14:34.700
所以说这句话呢,

01:14:34.700 --> 01:14:35.700
它会导致这三个Depp,

01:14:35.700 --> 01:14:36.700
都会记录这个Render,

01:14:36.700 --> 01:14:38.700
来搅拌记录一下,

01:14:39.700 --> 01:14:40.700
那么将来呢,

01:14:40.700 --> 01:14:42.700
我通过这种方式去改动,

01:14:42.700 --> 01:14:44.700
给这个对象加一个属性,

01:14:44.700 --> 01:14:45.700
触发的是哪个Render呢?

01:14:45.700 --> 01:14:46.700
触发的是这个,

01:14:46.700 --> 01:14:47.700
触发的是这个Depp,

01:14:47.700 --> 01:14:49.700
因为它不是给U的重新复制,

01:14:49.700 --> 01:14:51.700
也不是给Name重新复制,

01:14:51.700 --> 01:14:53.700
是给这个对象加一个东西,

01:14:53.700 --> 01:14:54.700
触发的是它,

01:14:55.700 --> 01:14:56.700
除了说,

01:14:56.700 --> 01:14:57.700
由于它里边记录了Render,

01:14:57.700 --> 01:14:59.700
因此Render也要运行,

01:14:59.700 --> 01:15:01.700
那为什么它要这样做呢?

01:15:02.700 --> 01:15:03.700
它没办法,

01:15:04.700 --> 01:15:05.700
它没有办法,

01:15:06.700 --> 01:15:07.700
为什么没办法呢?

01:15:07.700 --> 01:15:08.700
因为它不知道你,

01:15:08.700 --> 01:15:10.700
后边写的属性是啥,

01:15:10.700 --> 01:15:13.700
比方说你读到这个U了,

01:15:13.700 --> 01:15:14.700
这个时候它就会自动的,

01:15:14.700 --> 01:15:16.700
往这个对象里边加一个这个东西,

01:15:16.700 --> 01:15:18.700
它就会往这里加一个东西,

01:15:18.700 --> 01:15:19.700
这个时候它还不知道你,

01:15:19.700 --> 01:15:20.700
读的属性是啥,

01:15:20.700 --> 01:15:21.700
那万一你读的是一个,

01:15:21.700 --> 01:15:22.700
不存在的属性呢?

01:15:22.700 --> 01:15:24.700
万一有一天你把这个Name删了,

01:15:24.700 --> 01:15:26.700
比方说你这里要删除Name,

01:15:26.700 --> 01:15:28.700
删除Name是不是只能通过它?

01:15:28.700 --> 01:15:30.700
如果说它这里边不记录Render的话,

01:15:30.700 --> 01:15:31.700
它会导致一个问题,

01:15:31.700 --> 01:15:33.700
将来你去delete,

01:15:33.700 --> 01:15:35.700
通过这个delete含书,

01:15:36.700 --> 01:15:38.700
删除这个U里边的Name属性的时候,

01:15:38.700 --> 01:15:40.700
它是不是通知不到啊?

01:15:40.700 --> 01:15:41.700
是不是通知不到?

01:15:41.700 --> 01:15:43.700
所以它必须得记录,

01:15:43.700 --> 01:15:44.700
这就是ES5,

01:15:44.700 --> 01:15:46.700
OBG是DefineProperty里边的,

01:15:46.700 --> 01:15:48.700
这些导致的一系列问题,

01:15:49.700 --> 01:15:50.700
所以它必须得记录,

01:15:50.700 --> 01:15:51.700
那么记录的缺点就出来了,

01:15:51.700 --> 01:15:53.700
我看它加了一个属性,

01:15:53.700 --> 01:15:54.700
你也会监听到,

01:15:54.700 --> 01:15:56.700
所以说呢,

01:15:56.700 --> 01:15:57.700
官方就建议你,

01:15:57.700 --> 01:15:58.700
他们跟你说了很详细,

01:15:58.700 --> 01:15:59.700
它会建议你,

01:15:59.700 --> 01:16:00.700
不要去使用什么CS啊,

01:16:00.700 --> 01:16:01.700
delete这些东西,

01:16:01.700 --> 01:16:02.700
就不要去用,

01:16:02.700 --> 01:16:04.700
因为后面会导致很多的问题,

01:16:04.700 --> 01:16:05.700
知道吧?

01:16:05.700 --> 01:16:06.700
比如说,

01:16:06.700 --> 01:16:08.700
尽量不要去用这些东西啊,

01:16:08.700 --> 01:16:09.700
这就是原因,

01:16:14.840 --> 01:16:15.840
不是的,

01:16:15.840 --> 01:16:16.840
那个Zest还不一样,

01:16:16.840 --> 01:16:18.840
Zest它又用了一个代理模式,

01:16:18.840 --> 01:16:20.840
那我没有那么多时间展开讲了,

01:16:20.840 --> 01:16:21.840
那个地方又不一样了,

01:16:21.840 --> 01:16:22.840
知道吧?

01:16:23.840 --> 01:16:24.840
那个Zest还不一样,

01:16:24.840 --> 01:16:26.840
Zest5又实力还不一样,

01:16:26.840 --> 01:16:28.840
Zest5又实力可不是这个玩意儿了,

01:16:28.840 --> 01:16:30.840
我刚才给你写的是这个玩意儿,

01:16:30.840 --> 01:16:31.840
是这个玩意儿,

01:16:31.840 --> 01:16:32.840
知道吧?

01:16:32.840 --> 01:16:33.840
是这个地方,

01:16:33.840 --> 01:16:35.840
而这个5又实力可不是这个玩意儿了,

01:16:42.390 --> 01:16:43.390
好,这是关于DAV,

01:16:44.390 --> 01:16:45.390
下一个,

01:16:45.390 --> 01:16:46.390
你看,问题解决了吗?

01:16:46.390 --> 01:16:47.390
还没有解决,

01:16:47.390 --> 01:16:48.390
还有很多问题,

01:16:48.390 --> 01:16:52.620
watcher,

01:16:52.620 --> 01:16:54.620
现在我们要一步一步接近真相了,

01:16:55.620 --> 01:16:56.620
那么现在就问,

01:16:56.620 --> 01:16:59.620
现在我们又回到有意义的内心事件啊,

01:16:59.620 --> 01:17:00.620
就是这个DAV呢,

01:17:00.620 --> 01:17:01.620
我现在写出来了,

01:17:01.620 --> 01:17:02.620
在这里,

01:17:02.620 --> 01:17:04.620
调那个方法dependent,

01:17:04.620 --> 01:17:05.620
拿个小半,

01:17:05.620 --> 01:17:07.620
记一下到底谁在用我,

01:17:07.620 --> 01:17:08.620
现在就问题就来了,

01:17:08.620 --> 01:17:09.620
就在这里就出问题了,

01:17:09.620 --> 01:17:13.130
我怎么知道谁在用我?

01:17:13.130 --> 01:17:14.130
我这一代吧,

01:17:14.130 --> 01:17:15.130
都是用记也是写出来的,

01:17:15.130 --> 01:17:17.130
你怎么知道,

01:17:17.130 --> 01:17:21.130
我怎么知道是哪个函数,

01:17:21.130 --> 01:17:23.130
在调用我?

01:17:23.130 --> 01:17:27.020
我知道就见了鬼了,

01:17:27.020 --> 01:17:28.020
我知道了,

01:17:28.020 --> 01:17:29.020
肯定是不知道的,

01:17:30.020 --> 01:17:31.020
我在这个地方写,

01:17:31.020 --> 01:17:33.020
我怎么知道将来是什么函数来调用我?

01:17:33.020 --> 01:17:34.020
并不知道,

01:17:34.020 --> 01:17:36.020
没意思吧?

01:17:36.020 --> 01:17:37.020
有些人说,

01:17:37.020 --> 01:17:38.020
那个Render是无忧写的,

01:17:38.020 --> 01:17:40.020
无忧肯定会告诉他,

01:17:40.020 --> 01:17:41.020
但是你又忘了,

01:17:41.020 --> 01:17:42.020
我们想一算本质的,

01:17:42.020 --> 01:17:43.020
想一算本质,

01:17:43.020 --> 01:17:44.020
不是说运行什么Render,

01:17:44.020 --> 01:17:46.020
它是要运行任何函数,

01:17:46.020 --> 01:17:48.020
就只要用到我的函数,

01:17:48.020 --> 01:17:49.020
我都要运行,

01:17:49.020 --> 01:17:51.020
不要说这里随便写个函数,

01:17:51.020 --> 01:17:53.020
我用这种方式看着,

01:17:53.020 --> 01:17:54.020
我在节目2里边,

01:17:54.020 --> 01:17:55.020
我用这种方式,

01:17:55.020 --> 01:17:56.020
有点,

01:17:56.020 --> 01:17:58.020
将来让我写个函数当心,

01:17:59.020 --> 01:18:00.020
哎,

01:18:02.020 --> 01:18:03.020
哈哈哈,

01:18:03.020 --> 01:18:04.020
我写的,

01:18:04.020 --> 01:18:05.020
我写的,

01:18:05.020 --> 01:18:06.020
我写的,

01:18:06.020 --> 01:18:07.020
我写的,

01:18:07.020 --> 01:18:08.020
我这边用到了,

01:18:08.020 --> 01:18:09.020
有点LIM,

01:18:09.020 --> 01:18:10.020
我希望的是,

01:18:10.020 --> 01:18:11.020
这个LIM变化了过后,

01:18:11.020 --> 01:18:13.020
我这个函数要重新运行,

01:18:13.020 --> 01:18:14.020
没意思吧?

01:18:14.020 --> 01:18:16.020
它可以是任何函数,

01:18:16.020 --> 01:18:17.020
它不是说,

01:18:17.020 --> 01:18:18.020
一定要是Render,

01:18:18.020 --> 01:18:19.020
所以说,

01:18:19.020 --> 01:18:20.020
它根本就不知道,

01:18:20.020 --> 01:18:21.020
到底是哪个函数来用,

01:18:21.020 --> 01:18:22.020
它不知道的,

01:18:22.020 --> 01:18:24.020
那么怎么办呢?

01:18:24.020 --> 01:18:25.020
它又想了,

01:18:25.020 --> 01:18:26.020
想出一个招,

01:18:26.020 --> 01:18:27.020
叫做Water,

01:18:27.020 --> 01:18:29.020
这个Water,

01:18:29.020 --> 01:18:31.020
是什么东西呢?

01:18:31.020 --> 01:18:33.020
你就把想像中观察着吧,

01:18:33.020 --> 01:18:35.020
那时候怎么翻译就无所谓,

01:18:35.020 --> 01:18:37.020
它是通过一种,

01:18:37.020 --> 01:18:39.020
非常巧妙的方式,

01:18:39.020 --> 01:18:40.020
来解决这个问题,

01:18:40.020 --> 01:18:41.020
它怎么来解决呢?

01:18:41.020 --> 01:18:42.020
它让你,

01:18:42.020 --> 01:18:44.020
你不要直接去运行这个函数,

01:18:44.020 --> 01:18:45.020
这个函数,

01:18:45.020 --> 01:18:46.020
你是不能直接运行的,

01:18:46.020 --> 01:18:47.020
你直接运行的,

01:18:47.020 --> 01:18:48.020
它就不知道,

01:18:48.020 --> 01:18:49.020
那么这个Gate里边,

01:18:49.020 --> 01:18:50.020
它就不知道了,

01:18:50.020 --> 01:18:51.020
你直接运行这个函数,

01:18:51.020 --> 01:18:52.020
它就不知道,

01:18:52.020 --> 01:18:53.020
到底是谁,

01:18:53.020 --> 01:18:54.020
在用我,

01:18:54.020 --> 01:18:55.020
你必须要把这个函数,

01:18:55.020 --> 01:18:56.020
交给一个东西,

01:18:56.020 --> 01:18:57.020
叫做Water,

01:18:57.020 --> 01:18:59.020
让它去运行,

01:18:59.020 --> 01:19:01.020
这有点像啥呢?

01:19:01.020 --> 01:19:02.020
有点像这个,

01:19:02.020 --> 01:19:06.800
就是什么东西函数啊?

01:19:06.800 --> 01:19:07.800
那个Water实际上是什么?

01:19:07.800 --> 01:19:09.800
实际上就是我们这里的Water,

01:19:09.800 --> 01:19:11.800
就是这个Water,

01:19:11.800 --> 01:19:12.800
就是我们,

01:19:12.800 --> 01:19:14.800
本节课一开始给大家看到的,

01:19:14.800 --> 01:19:15.800
就是这个Water,

01:19:15.800 --> 01:19:16.800
让你,

01:19:16.800 --> 01:19:17.800
比方你有什么函数,

01:19:17.800 --> 01:19:18.800
有什么事情,

01:19:18.800 --> 01:19:19.800
想说,

01:19:19.800 --> 01:19:20.800
一把这个东西,

01:19:20.800 --> 01:19:21.800
它传的这个Water,

01:19:21.800 --> 01:19:22.800
它内部呢,

01:19:22.800 --> 01:19:23.800
其实在调,

01:19:23.800 --> 01:19:24.800
它其实直接溜了一个Water,

01:19:24.800 --> 01:19:26.800
它就是溜了一个Water,

01:19:27.800 --> 01:19:28.800
没啥意思吧?

01:19:28.800 --> 01:19:29.800
一把你要做的事情呢,

01:19:29.800 --> 01:19:30.800
传给这个函数,

01:19:30.800 --> 01:19:31.800
比方说,

01:19:31.800 --> 01:19:32.800
传一个函数进去,

01:19:32.800 --> 01:19:33.800
这个函数里边用到了谁?

01:19:33.800 --> 01:19:35.800
用到了这个Z,

01:19:35.800 --> 01:19:36.800
U字,

01:19:36.800 --> 01:19:37.800
角链,

01:19:37.800 --> 01:19:38.800
比方说,

01:19:38.800 --> 01:19:39.800
我决个这么一个例子,

01:19:39.800 --> 01:19:40.800
那么我这里运行的,

01:19:40.800 --> 01:19:42.800
Water,

01:19:42.800 --> 01:19:46.180
一把这个函数传进去,

01:19:46.180 --> 01:19:48.180
让它来帮你运行这个函数,

01:19:48.180 --> 01:19:49.180
你不能直接运行,

01:19:49.180 --> 01:19:50.180
直接运行的话,

01:19:50.180 --> 01:19:51.180
它就不知道,

01:19:51.180 --> 01:19:53.180
哪个函数在运行它,

01:19:53.180 --> 01:19:54.180
那么这个东西,

01:19:54.180 --> 01:19:55.180
里边就是这个东西,

01:19:55.180 --> 01:19:56.180
就是Water,

01:19:56.180 --> 01:19:57.180
没啥意思吧?

01:19:57.180 --> 01:19:58.180
Water的作用是什么呢?

01:19:58.180 --> 01:20:00.180
它是把这个函数跟那个Water

01:20:00.180 --> 01:20:01.180
本身关联起来,

01:20:01.180 --> 01:20:02.180
就是说,

01:20:02.180 --> 01:20:04.180
一把函数交给我,

01:20:04.180 --> 01:20:05.180
我来帮你运行函数,

01:20:05.180 --> 01:20:06.180
你不要直接运行,

01:20:06.180 --> 01:20:08.180
那它到底是怎么做的,

01:20:08.180 --> 01:20:09.180
才能保证,

01:20:09.180 --> 01:20:10.180
能够记住到银带呢?

01:20:10.180 --> 01:20:12.180
它做的事情呢,

01:20:12.180 --> 01:20:13.180
其实,

01:20:13.180 --> 01:20:14.180
看上去很高端,

01:20:14.180 --> 01:20:15.180
但是呢,

01:20:15.180 --> 01:20:16.180
你觉得特别,

01:20:16.180 --> 01:20:18.180
你说了过去觉得特别简单,

01:20:18.180 --> 01:20:20.550
它怎么做的呢?

01:20:20.550 --> 01:20:21.550
我这里写个简单的,

01:20:21.550 --> 01:20:22.550
简单的伟带嘛,

01:20:22.550 --> 01:20:23.550
它礼拜带嘛,

01:20:23.550 --> 01:20:24.550
其实要复杂一些,

01:20:25.550 --> 01:20:26.550
Water,

01:20:27.550 --> 01:20:29.550
你给我传一个函数进来,

01:20:30.550 --> 01:20:31.550
我怎么弄呢?

01:20:31.550 --> 01:20:32.550
我就这样子弄,

01:20:33.550 --> 01:20:36.930
我,我这里边呢,

01:20:37.930 --> 01:20:38.930
有个方法,

01:20:38.930 --> 01:20:39.930
它有个方法叫做Water,

01:20:41.930 --> 01:20:42.930
Water Type,

01:20:42.930 --> 01:20:47.420
Water,

01:20:47.420 --> 01:20:48.420
Water什么意思啊?

01:20:48.420 --> 01:20:49.420
就运行函数啊,

01:20:49.420 --> 01:20:50.420
它首先把这个函数保存一下啊,

01:20:51.420 --> 01:20:53.420
把这个函数保存一下,

01:20:53.420 --> 01:20:54.420
然后呢,

01:20:54.420 --> 01:20:55.420
就是这一次说,

01:20:55.420 --> 01:20:56.420
你就这样,

01:20:56.420 --> 01:20:57.420
你这样理解啊,

01:20:57.420 --> 01:20:58.420
它运行,

01:20:58.420 --> 01:20:59.420
运行的时候干嘛呀?

01:20:59.420 --> 01:21:00.420
运行的时候,

01:21:00.420 --> 01:21:01.420
它就这样做,

01:21:01.420 --> 01:21:02.420
它首先把这个Water,

01:21:02.420 --> 01:21:04.420
一个权具变量啊,

01:21:04.420 --> 01:21:06.420
Global Watcher,

01:21:06.420 --> 01:21:07.420
一个权具变量,

01:21:07.420 --> 01:21:08.420
一开始为大哦,

01:21:09.420 --> 01:21:10.420
这个看上去有点晕,

01:21:10.420 --> 01:21:11.420
但是没关系,

01:21:11.420 --> 01:21:12.420
我写完了,

01:21:12.420 --> 01:21:13.420
给你解释一下,

01:21:13.420 --> 01:21:14.420
你明白了啊,

01:21:14.420 --> 01:21:15.420
Race,

01:21:15.420 --> 01:21:16.420
然后呢,

01:21:16.420 --> 01:21:18.420
Race叫Fn,

01:21:18.420 --> 01:21:19.420
调用它,

01:21:19.420 --> 01:21:20.420
然后呢,

01:21:20.420 --> 01:21:22.420
再Global Watcher,

01:21:23.420 --> 01:21:24.420
再运到,

01:21:24.420 --> 01:21:25.420
你看吧,

01:21:25.420 --> 01:21:27.920
这带嘛,

01:21:27.920 --> 01:21:28.920
我们拿过来看一下,

01:21:28.920 --> 01:21:30.920
你把这个Water里边的东西,

01:21:30.920 --> 01:21:31.920
是不是传那个寒树进去?

01:21:31.920 --> 01:21:35.490
是不是传那个寒树?

01:21:35.490 --> 01:21:36.490
这个寒树传给谁呢?

01:21:36.490 --> 01:21:37.490
是不是传给它的?

01:21:37.490 --> 01:21:38.490
对吧?

01:21:38.490 --> 01:21:39.490
它把它记录到谁?

01:21:39.490 --> 01:21:40.490
记录到这儿了,

01:21:40.490 --> 01:21:42.490
记录到它当前实力里边去了,

01:21:42.490 --> 01:21:43.490
然后调用这个方法,

01:21:43.490 --> 01:21:44.490
这个方法是不是要运行它?

01:21:44.490 --> 01:21:45.490
好,来,

01:21:45.490 --> 01:21:46.490
我们来看,

01:21:46.490 --> 01:21:50.140
这个方法是怎么运行的啊?

01:21:50.140 --> 01:21:51.140
它把当前这个Water呢,

01:21:51.140 --> 01:21:53.140
就当前的运行这个东西,

01:21:53.140 --> 01:21:56.140
保存到一个权具变量里边,

01:21:56.140 --> 01:21:58.140
然后再运行,

01:21:58.140 --> 01:21:59.140
我们这个寒树,

01:21:59.140 --> 01:22:01.140
你看啊,注意听啊,

01:22:01.140 --> 01:22:03.140
那么你想一想,

01:22:03.140 --> 01:22:04.140
在这个寒树的运行过程中,

01:22:05.140 --> 01:22:08.140
是不是可以访问到这个权具变量?

01:22:08.140 --> 01:22:11.140
好好想一想,是不是?

01:22:11.140 --> 01:22:12.140
这是个权具变量啊,

01:22:12.140 --> 01:22:14.140
情况下权具变量不是这样子写的啊,

01:22:14.140 --> 01:22:16.140
但是呢,意识是差不多的,

01:22:16.140 --> 01:22:18.140
我们这个寒树的运行过程中,

01:22:18.140 --> 01:22:20.140
是不是可以访问到这个权具变量?

01:22:20.140 --> 01:22:23.140
这个权具变量,

01:22:23.140 --> 01:22:26.140
跟这个寒树是不是关联起来的?

01:22:26.140 --> 01:22:27.140
看到没?

01:22:27.140 --> 01:22:28.140
我把Water保存到,

01:22:28.140 --> 01:22:30.140
Water保存到这个权具变量了,

01:22:30.140 --> 01:22:33.140
这个权具变量是不是跟这个寒树关联起来的?

01:22:33.140 --> 01:22:34.140
所以说,

01:22:34.140 --> 01:22:36.140
我们在搜集依赖的时候,

01:22:36.140 --> 01:22:37.140
就是这个Dep在搜集依赖的时候,

01:22:37.140 --> 01:22:41.140
它只需要去访问这个权具变量,

01:22:41.140 --> 01:22:42.140
把它记录下来,

01:22:42.140 --> 01:22:43.140
是不是就可以了?

01:22:43.140 --> 01:22:44.140
用个小本子把它记录下来,

01:22:44.140 --> 01:22:47.140
因为它是跟这个寒树关联的,

01:22:47.140 --> 01:22:48.140
看到没?

01:22:48.140 --> 01:22:50.140
也就是我们这个寒树在运行期间,

01:22:50.140 --> 01:22:52.140
能够访问这个权具变量,

01:22:52.140 --> 01:22:53.140
而这个寒树的运行期间,

01:22:53.140 --> 01:22:55.140
是不是用到了这个Gator?

01:22:55.140 --> 01:22:56.140
Gator里面是不是在记录?

01:22:56.140 --> 01:22:57.140
那么记录的时候,

01:22:57.140 --> 01:22:58.140
怎么记录的?

01:22:58.140 --> 01:22:59.140
它就记录这个权具变量,

01:22:59.140 --> 01:23:02.460
然后这个寒树运行完了,

01:23:02.460 --> 01:23:04.460
那我再把这个权具变量清空,

01:23:04.460 --> 01:23:06.460
是不是非常巧妙?

01:23:06.460 --> 01:23:08.460
这一块要好好去理解一下,

01:23:08.460 --> 01:23:09.460
不过这一块,

01:23:09.460 --> 01:23:11.460
如果实在理解不了也没关系,

01:23:11.460 --> 01:23:12.460
因为这个事情,

01:23:12.460 --> 01:23:14.460
它已经不用去给它回答这么详细,

01:23:14.460 --> 01:23:16.460
我主要是让里面理解清楚一点,

01:23:16.460 --> 01:23:21.460
它就用这种方式来去记录,

01:23:21.460 --> 01:23:22.460
它什么意思呢?

01:23:22.460 --> 01:23:24.460
就是让这个寒树的运行期间,

01:23:24.460 --> 01:23:25.460
有个权具变量,

01:23:25.460 --> 01:23:26.460
就这个意思,

01:23:26.460 --> 01:23:29.460
这个权具变量是跟这个寒树是关联的,

01:23:29.460 --> 01:23:31.460
大概就是这个意思,

01:23:31.460 --> 01:23:32.460
那么这样子呢,

01:23:32.460 --> 01:23:34.460
他们在记录的时候,

01:23:34.460 --> 01:23:37.460
那么在搜集依赖的时候呢,

01:23:37.460 --> 01:23:40.460
他就可以知道是谁在做这件事情的,

01:23:40.460 --> 01:23:42.460
其实我们如果说你要看圆栏的话,

01:23:42.460 --> 01:23:43.460
给你看一下,

01:23:43.460 --> 01:23:49.620
在这边,

01:23:49.620 --> 01:23:52.620
时间会偷了一人长啊,

01:23:52.620 --> 01:23:53.620
你看,

01:23:53.620 --> 01:23:54.620
这个Water,

01:23:54.620 --> 01:24:03.310
它Water里面有很多参数啊,

01:24:03.310 --> 01:24:04.310
你看这个Water里面有,

01:24:04.310 --> 01:24:06.310
它是用ES6的内的写法,

01:24:06.310 --> 01:24:08.310
但是参数了一大堆,

01:24:09.310 --> 01:24:10.310
它其实,

01:24:10.310 --> 01:24:12.310
核心参数就是这个东西,

01:24:12.310 --> 01:24:13.310
核心参数在这儿,

01:24:13.310 --> 01:24:16.520
Gator,

01:24:16.520 --> 01:24:18.520
就是这个参数,

01:24:18.520 --> 01:24:20.520
就是我们传入那个方形,

01:24:20.520 --> 01:24:21.520
传入那个寒树,

01:24:21.520 --> 01:24:23.520
这是我们传入的寒树,

01:24:23.520 --> 01:24:25.520
它里面参数很多,

01:24:25.520 --> 01:24:26.520
在这儿,

01:24:26.520 --> 01:24:27.520
看错了啊,

01:24:27.520 --> 01:24:28.520
它们是属性啊,看错了,

01:24:28.520 --> 01:24:29.520
这个,

01:24:29.520 --> 01:24:30.520
它可以,

01:24:30.520 --> 01:24:31.520
它就是一个寒树,

01:24:31.520 --> 01:24:33.520
我们传入的就是那个寒树,

01:24:33.520 --> 01:24:34.520
然后这里边,

01:24:34.520 --> 01:24:36.520
我们看一下关键单吧,

01:24:36.520 --> 01:24:38.520
他们在运行我们的寒树的时候,

01:24:38.520 --> 01:24:39.520
进入这个权局变量的,

01:24:39.520 --> 01:24:41.520
就是通过这句话,

01:24:41.520 --> 01:24:44.520
这句话记住权局变量,

01:24:44.520 --> 01:24:46.520
这句话是你调用另外一个寒树啊,

01:24:46.520 --> 01:24:47.520
那个寒树呢,

01:24:47.520 --> 01:24:49.520
其实它具体的情况还比较复杂啊,

01:24:49.520 --> 01:24:50.520
你看,

01:24:50.520 --> 01:24:51.520
就是这个东西,

01:24:51.520 --> 01:24:52.520
就是这个权局变量,

01:24:52.520 --> 01:24:53.520
就是它,

01:24:53.520 --> 01:24:54.520
它记住到这儿的,

01:24:54.520 --> 01:24:55.520
另外呢,

01:24:55.520 --> 01:24:56.520
它还准备了一个数组啊,

01:24:56.520 --> 01:24:57.520
用了一个,

01:24:57.520 --> 01:24:58.520
用了一个站的方式,

01:24:58.520 --> 01:24:59.520
这是,

01:24:59.520 --> 01:25:00.520
它必须要用站啊,

01:25:00.520 --> 01:25:01.520
因为它还有一些问题,

01:25:01.520 --> 01:25:02.520
必须要解决,

01:25:02.520 --> 01:25:03.520
我们这里也不深究了啊,

01:25:03.520 --> 01:25:04.520
因为这个细节讲起来,

01:25:04.520 --> 01:25:06.520
讲起来就没完没了了,

01:25:10.830 --> 01:25:12.830
好,那么这就是Water,

01:25:12.830 --> 01:25:13.830
那么有了Water过后,

01:25:13.830 --> 01:25:14.830
你始终记住啊,

01:25:14.830 --> 01:25:15.830
Water它干嘛的,

01:25:15.830 --> 01:25:16.830
它就是在记录我们

01:25:16.830 --> 01:25:18.830
执行那个寒树的,

01:25:18.830 --> 01:25:20.830
它就是在记录我们那个

01:25:20.830 --> 01:25:21.830
执行寒树,

01:25:21.830 --> 01:25:22.830
也就是我们的Render寒树,

01:25:22.830 --> 01:25:24.830
它一定是百分之百的,

01:25:24.830 --> 01:25:27.830
一定是放到Water里面去执行的,

01:25:27.830 --> 01:25:28.830
我们的Render寒树,

01:25:28.830 --> 01:25:29.830
一定在Water里面执行,

01:25:29.830 --> 01:25:31.830
它不能直接执行,

01:25:31.830 --> 01:25:32.830
直接执行的话,

01:25:32.830 --> 01:25:33.830
它就搜集不到一代了,

01:25:33.830 --> 01:25:34.830
它必须要在Water里面执行,

01:25:34.830 --> 01:25:35.830
给你们看一下代码,

01:25:35.830 --> 01:25:38.340
我们就看一下,

01:25:38.340 --> 01:25:40.340
6Water的地方吧,

01:25:41.340 --> 01:25:43.340
6Water,

01:25:43.340 --> 01:25:45.340
哪些地方在6Water啊?

01:25:48.340 --> 01:25:51.990
还不是这儿,

01:25:51.990 --> 01:25:56.460
就在这儿,

01:25:56.460 --> 01:26:00.020
还不是这儿,

01:26:00.020 --> 01:26:02.020
还不是这儿,

01:26:02.020 --> 01:26:04.020
就在这儿,看来,

01:26:05.020 --> 01:26:07.020
这里创建了一个Water,

01:26:07.020 --> 01:26:08.020
创建一个Water,

01:26:08.020 --> 01:26:09.020
传到寒树是什么,

01:26:09.020 --> 01:26:10.020
传到寒树是这个寒树,

01:26:10.020 --> 01:26:12.020
这个寒树里边所以调用了,

01:26:12.020 --> 01:26:14.020
还不是这儿,

01:26:15.020 --> 01:26:17.020
找一找,

01:26:27.340 --> 01:26:28.340
在这儿,

01:26:28.340 --> 01:26:30.340
这是我们的Render寒树,

01:26:30.340 --> 01:26:42.940
是在这儿,

01:26:42.940 --> 01:26:47.660
我看一下,再看一下,

01:26:47.660 --> 01:26:48.660
是在这儿,

01:26:48.660 --> 01:26:50.660
看这儿就行了,

01:26:50.660 --> 01:26:51.660
上面是生产环境,

01:26:51.660 --> 01:26:53.660
还有一些优化的时候,

01:26:53.660 --> 01:26:54.660
做了一些特殊处理,

01:26:54.660 --> 01:26:55.660
就看这儿,这是核心代码,

01:26:55.660 --> 01:26:56.660
它设置了一个寒树,

01:26:56.660 --> 01:26:57.660
这个寒树,

01:26:57.660 --> 01:26:59.660
它里边是不是调用了Render,

01:26:59.660 --> 01:27:00.660
对吧,

01:27:00.660 --> 01:27:01.660
然后呢,

01:27:01.660 --> 01:27:02.660
它是不是创建了Water,

01:27:02.660 --> 01:27:04.660
Water里边是把这个寒树传进去,

01:27:04.660 --> 01:27:06.660
你能看懂就看懂,

01:27:06.660 --> 01:27:08.660
反正就是这么个意思,

01:27:08.660 --> 01:27:09.660
这个寒树就传进去了,

01:27:09.660 --> 01:27:10.660
说Water,

01:27:10.660 --> 01:27:11.660
监控了是谁,

01:27:11.660 --> 01:27:12.660
这个寒树的执行,

01:27:12.660 --> 01:27:14.660
在这个寒树的执行期间,

01:27:14.660 --> 01:27:15.660
是不是,

01:27:15.660 --> 01:27:17.660
就会收集到,

01:27:17.660 --> 01:27:18.660
一代,

01:27:18.660 --> 01:27:19.660
收集的是谁的一代,

01:27:19.660 --> 01:27:20.660
它的一代,

01:27:20.660 --> 01:27:21.660
那么将来数据变化了,

01:27:21.660 --> 01:27:22.660
一个运行的是谁,

01:27:22.660 --> 01:27:23.660
运行的是这个寒树,

01:27:23.660 --> 01:27:24.660
只不过这个寒树,

01:27:24.660 --> 01:27:25.660
里边运行了Render,

01:27:25.660 --> 01:27:26.660
对吧,

01:27:26.660 --> 01:27:27.660
那么这个玩意是啥,

01:27:27.660 --> 01:27:28.660
明天讲的那种,

01:27:28.660 --> 01:27:29.660
明天讲Dev的时候,

01:27:29.660 --> 01:27:30.660
会收到它,

01:27:30.660 --> 01:27:31.660
明白了意思吧,

01:27:31.660 --> 01:27:32.660
因为,

01:27:32.660 --> 01:27:33.660
数据变了,

01:27:33.660 --> 01:27:35.660
会重新运行它,

01:27:35.660 --> 01:27:36.660
然后呢,

01:27:36.660 --> 01:27:37.660
它里边又会运行Render,

01:27:37.660 --> 01:27:38.660
所以我们觉得,

01:27:38.660 --> 01:27:39.660
Render为什么会重复运行,

01:27:39.660 --> 01:27:40.660
就这样来的,

01:27:40.660 --> 01:27:41.660
明白了意思吧,

01:27:41.660 --> 01:27:42.660
当然,

01:27:42.660 --> 01:27:43.660
它如果说,

01:27:43.660 --> 01:27:44.660
没有收集到的一代变了,

01:27:44.660 --> 01:27:45.660
那么它不会运行的,

01:27:45.660 --> 01:27:47.660
只有它一代的数据变了,

01:27:47.660 --> 01:27:48.660
它才会运行,

01:27:48.660 --> 01:27:54.170
就这么个意思,

01:27:56.170 --> 01:27:57.170
这是有大大写的,

01:27:57.170 --> 01:27:58.170
不是我写的,

01:27:59.170 --> 01:28:00.170
那么Water,

01:28:00.170 --> 01:28:01.170
它就起这么一个作用,

01:28:01.170 --> 01:28:02.170
它是用来,

01:28:02.170 --> 01:28:03.170
跟那个函数,

01:28:03.170 --> 01:28:04.170
产生关系的,

01:28:04.170 --> 01:28:05.170
这是Water,

01:28:05.170 --> 01:28:07.170
当我们数据变化的时候呢,

01:28:07.170 --> 01:28:08.170
Dev呢,

01:28:08.170 --> 01:28:09.170
它就会通知,

01:28:09.170 --> 01:28:10.170
你这个Water,

01:28:10.170 --> 01:28:11.170
重新运行了,

01:28:11.170 --> 01:28:12.170
要重新运行了,

01:28:12.170 --> 01:28:13.170
那么它就会重新运行,

01:28:13.170 --> 01:28:14.170
之前,

01:28:14.170 --> 01:28:15.170
要传递到函数,

01:28:15.170 --> 01:28:16.170
你要指动记住,

01:28:16.170 --> 01:28:17.170
Water跟这个函数,

01:28:17.170 --> 01:28:18.170
是关联在一起的,

01:28:18.170 --> 01:28:19.170
这个函数的运行过程中,

01:28:19.170 --> 01:28:21.170
它就会收集一代,

01:28:21.170 --> 01:28:22.170
收集一代谁,

01:28:22.170 --> 01:28:23.170
收集的是谁,

01:28:23.170 --> 01:28:24.170
收集的是这些Water,

01:28:24.170 --> 01:28:25.170
要收到Name,

01:28:25.170 --> 01:28:26.170
那么Name就会记录,

01:28:26.170 --> 01:28:27.170
记录的其实,

01:28:27.170 --> 01:28:28.170
不是Render,

01:28:28.170 --> 01:28:29.170
是这些Water,

01:28:29.170 --> 01:28:31.170
Water里面有这个Render,

01:28:31.170 --> 01:28:32.170
Water里面有这个函数,

01:28:32.170 --> 01:28:34.170
将来数据一旦变化,

01:28:34.170 --> 01:28:36.170
它就会通知到相应的Water,

01:28:36.170 --> 01:28:37.170
那么这个Water呢,

01:28:37.170 --> 01:28:38.170
就会重新运行这个函数,

01:28:38.170 --> 01:28:40.170
是这么一回事啊,

01:28:40.170 --> 01:28:41.170
梳理一下啊,

01:28:41.170 --> 01:28:42.170
再来一次啊,

01:28:42.170 --> 01:28:44.170
我们的Water是跟函数,

01:28:44.170 --> 01:28:45.170
关联在一起的,

01:28:45.170 --> 01:28:46.170
它一开始,

01:28:46.170 --> 01:28:47.170
会运行一次这个函数,

01:28:47.170 --> 01:28:48.170
运行的过程中,

01:28:48.170 --> 01:28:50.170
它就会记录遗难,

01:28:50.170 --> 01:28:51.170
比方说,

01:28:51.170 --> 01:28:52.170
这个函数的运行过程中,

01:28:52.170 --> 01:28:53.170
用到了这个Name,

01:28:53.170 --> 01:28:54.170
用到了这个User,

01:28:54.170 --> 01:28:55.170
它就会记录下来,

01:28:55.170 --> 01:28:56.170
记录的是谁啊,

01:28:58.170 --> 01:29:00.170
变了它就会重新通知这个Water,

01:29:00.170 --> 01:29:01.170
我这个变了要,

01:29:01.170 --> 01:29:03.170
你这个Water要重新运行哦,

01:29:03.170 --> 01:29:04.170
还有你这个Water,

01:29:04.170 --> 01:29:06.170
就刚才我们看到的这个Water,

01:29:06.170 --> 01:29:08.170
你要重新运行哦,

01:29:08.170 --> 01:29:09.170
那么由于这个Water呢,

01:29:09.170 --> 01:29:11.170
是跟函数关联的,

01:29:11.170 --> 01:29:12.170
那么它重新运行,

01:29:12.170 --> 01:29:13.170
实际上本质上,

01:29:13.170 --> 01:29:15.170
就是在运行它里面的函数,

01:29:15.170 --> 01:29:16.170
你看运行这个函数,

01:29:16.170 --> 01:29:17.170
是不是就运行了Render,

01:29:17.170 --> 01:29:18.170
那么运行这个函数,

01:29:18.170 --> 01:29:20.170
是不是就重新运行了这个东西,

01:29:20.170 --> 01:29:23.170
它就是这么一个整个过程,

01:29:23.170 --> 01:29:24.170
好,那么这里呢,

01:29:24.170 --> 01:29:25.170
说到这里呢,

01:29:25.170 --> 01:29:27.170
就说了一个特殊的Water,

01:29:27.170 --> 01:29:29.170
每一个组件都有Render函数,

01:29:29.170 --> 01:29:30.170
而Render函数呢,

01:29:30.170 --> 01:29:31.170
也是放到Water里面运行的,

01:29:31.170 --> 01:29:33.170
所以说每一个组件,

01:29:33.170 --> 01:29:35.170
至少有一个Water,

01:29:35.170 --> 01:29:37.170
每个组件至少有一个Water,

01:29:37.170 --> 01:29:38.170
其实你这里可以看得很清楚,

01:29:38.170 --> 01:29:40.170
组件里边有个VM,

01:29:40.170 --> 01:29:41.170
对啊,就是我们刚才写的那个,

01:29:41.170 --> 01:29:43.170
诶,这边啊,

01:29:43.170 --> 01:29:44.170
组件里面不是一个VM吗,

01:29:44.170 --> 01:29:45.170
每个组件都是一个实力,

01:29:45.170 --> 01:29:46.170
实力里边你会看到,

01:29:46.170 --> 01:29:48.170
下面有一个Water,

01:29:48.170 --> 01:29:51.800
这个Water是什么,

01:29:51.800 --> 01:29:53.800
就是这个组件,

01:29:53.800 --> 01:29:55.800
跟Render关联的那个Water,

01:29:55.800 --> 01:29:56.800
每个组件都有啊,

01:29:56.800 --> 01:29:57.800
都有这个Water,

01:29:57.800 --> 01:29:59.800
跟Render关联的那个Water,

01:29:59.800 --> 01:30:00.800
它还有一个属性叫Water,

01:30:00.800 --> 01:30:01.800
是个数组,

01:30:01.800 --> 01:30:02.800
这个数组呢,

01:30:02.800 --> 01:30:03.800
记住的就是,

01:30:03.800 --> 01:30:05.800
除了,就是包含Render,

01:30:05.800 --> 01:30:06.800
包含这个组件,

01:30:06.800 --> 01:30:07.800
其他的Water,

01:30:07.800 --> 01:30:08.800
你看这个组件里边,

01:30:08.800 --> 01:30:09.800
是不是有两个Water,

01:30:09.800 --> 01:30:10.800
这是一个Water,

01:30:10.800 --> 01:30:11.800
这个Render也是在一个Water里边,

01:30:11.800 --> 01:30:12.800
是不是有两个,

01:30:12.800 --> 01:30:13.800
对吧,

01:30:13.800 --> 01:30:15.800
所以这里Water是,

01:30:15.800 --> 01:30:16.800
就是两个,

01:30:16.800 --> 01:30:17.800
对不对,

01:30:17.800 --> 01:30:19.800
好,就这么个意思啊,

01:30:19.800 --> 01:30:20.800
好,这是Water,

01:30:20.800 --> 01:30:21.800
好,最后一个了啊,

01:30:21.800 --> 01:30:22.800
叫做Sketuler,

01:30:22.800 --> 01:30:23.800
就是你面试的时候啊,

01:30:23.800 --> 01:30:25.800
你自己去组织一下语言,

01:30:25.800 --> 01:30:26.800
把这四个点讲到,

01:30:26.800 --> 01:30:27.800
一定是高分,

01:30:27.800 --> 01:30:28.800
一定是满分,

01:30:28.800 --> 01:30:29.800
Sketuler,

01:30:29.800 --> 01:30:30.800
表示调度器,

01:30:30.800 --> 01:30:32.800
为什么还需要调度器呢?

01:30:32.800 --> 01:30:33.800
其实这里就,

01:30:33.800 --> 01:30:35.800
非常容易看到一个问题就是,

01:30:37.800 --> 01:30:38.800
那如果说,

01:30:38.800 --> 01:30:39.800
一个Water里边,

01:30:39.800 --> 01:30:40.800
用到了多个属性,

01:30:40.800 --> 01:30:42.800
比较用到了它,

01:30:42.800 --> 01:30:44.800
又用到了它,

01:30:44.800 --> 01:30:48.240
又用到了它,

01:30:48.240 --> 01:30:49.240
那不得了了,

01:30:49.240 --> 01:30:50.240
啊,

01:30:51.240 --> 01:30:53.240
那如果说,

01:30:53.240 --> 01:30:57.900
遇到这么一种情况,

01:30:57.900 --> 01:30:58.900
那万一有一天啊,

01:30:58.900 --> 01:30:59.900
比方我这里就举个例子,

01:30:59.900 --> 01:31:01.900
如果说你的Water在运行的过程中,

01:31:01.900 --> 01:31:03.900
用到了ABCD4的属性都用到了,

01:31:03.900 --> 01:31:04.900
那现在的,

01:31:04.900 --> 01:31:05.900
如果说有一段代码,

01:31:05.900 --> 01:31:07.900
它改动了ABCD4的属性,

01:31:07.900 --> 01:31:09.900
那是不是要触发四次?

01:31:09.900 --> 01:31:11.900
我改动A,

01:31:11.900 --> 01:31:13.900
触发Water重新运行,

01:31:13.900 --> 01:31:14.900
改动B,

01:31:14.900 --> 01:31:16.900
又触重新触发Water重新运行,

01:31:16.900 --> 01:31:17.900
又改动C,

01:31:17.900 --> 01:31:18.900
又触发Water重新运行,

01:31:18.900 --> 01:31:19.900
又改动D,

01:31:19.900 --> 01:31:20.900
有必要吗?

01:31:20.900 --> 01:31:21.900
那你能不能等我,

01:31:21.900 --> 01:31:22.900
代码运行完了过后,

01:31:22.900 --> 01:31:23.900
你再去运行啊?

01:31:23.900 --> 01:31:24.900
对吧?

01:31:24.900 --> 01:31:25.900
所以说,

01:31:25.900 --> 01:31:26.900
它考虑到这么一个问题,

01:31:26.900 --> 01:31:27.900
因此呢,

01:31:28.900 --> 01:31:30.900
你不要那么着急的运行,

01:31:30.900 --> 01:31:31.900
我知道你想运行,

01:31:31.900 --> 01:31:32.900
你想运行得不得了,

01:31:32.900 --> 01:31:33.900
但是你不要那么着急,

01:31:35.900 --> 01:31:36.900
这里呢,

01:31:36.900 --> 01:31:37.900
所以说你这里,

01:31:37.900 --> 01:31:38.900
只是某个,

01:31:38.900 --> 01:31:39.900
某个,

01:31:39.900 --> 01:31:40.900
或者是某些,

01:31:40.900 --> 01:31:42.900
因为有可能很多Water,

01:31:42.900 --> 01:31:43.900
它都会用到A,

01:31:43.900 --> 01:31:44.900
某些Water,

01:31:44.900 --> 01:31:45.900
想运行了,

01:31:47.900 --> 01:31:48.900
运行了,

01:31:48.900 --> 01:31:49.900
它不能直接运行,

01:31:49.900 --> 01:31:50.900
给调动器,

01:31:52.900 --> 01:31:53.900
这里也是,

01:31:53.900 --> 01:31:54.900
你改动了数据,

01:31:54.900 --> 01:31:55.900
那么一个数据相关的Water,

01:31:55.900 --> 01:31:56.900
想运行了,

01:31:56.900 --> 01:31:57.900
给调动器,

01:31:57.900 --> 01:31:58.900
这些Water,

01:31:58.900 --> 01:31:59.900
想运行了,

01:31:59.900 --> 01:32:00.900
给调动器,

01:32:00.900 --> 01:32:01.900
你不能直接运行,

01:32:01.900 --> 01:32:03.900
那么调动器在做什么呢?

01:32:03.900 --> 01:32:04.900
调动器里边,

01:32:04.900 --> 01:32:05.900
还维护一个对立,

01:32:05.900 --> 01:32:07.900
就像一个数据一样,

01:32:07.900 --> 01:32:08.900
比方说,

01:32:08.900 --> 01:32:09.900
我这里边呢,

01:32:09.900 --> 01:32:12.900
有一个调动器,

01:32:12.900 --> 01:32:14.900
看看调动器怎么处理,

01:32:14.900 --> 01:32:15.900
比方说,

01:32:15.900 --> 01:32:16.900
第一句话运行了,

01:32:16.900 --> 01:32:17.900
有个Water,

01:32:17.900 --> 01:32:18.900
它想运行了,

01:32:18.900 --> 01:32:19.900
那还会给调动器,

01:32:19.900 --> 01:32:20.900
那么调动器,

01:32:20.900 --> 01:32:21.900
就会激动一下,

01:32:21.900 --> 01:32:22.900
有个Water,

01:32:22.900 --> 01:32:23.900
想运行了,

01:32:23.900 --> 01:32:24.900
Water1,

01:32:24.900 --> 01:32:25.900
想运行了,

01:32:25.900 --> 01:32:26.900
又运行了这个,

01:32:26.900 --> 01:32:27.900
比方说,

01:32:27.900 --> 01:32:28.900
哪些Water要用到B,

01:32:28.900 --> 01:32:29.900
还是Water1,

01:32:29.900 --> 01:32:30.900
它又让调动器,

01:32:30.900 --> 01:32:31.900
调动器给调动器说,

01:32:31.900 --> 01:32:32.900
哎呀,

01:32:32.900 --> 01:32:33.900
还是我,

01:32:33.900 --> 01:32:34.900
我还是想运行,

01:32:34.900 --> 01:32:35.900
调动器说,

01:32:35.900 --> 01:32:36.900
哎呀,我知道了,

01:32:36.900 --> 01:32:37.900
它调动器一看,

01:32:37.900 --> 01:32:38.900
这些有一个Water1呢,

01:32:38.900 --> 01:32:39.900
算了吧,

01:32:39.900 --> 01:32:40.900
我再来一个,

01:32:40.900 --> 01:32:41.900
没什么意义,

01:32:41.900 --> 01:32:42.900
调动器不夹了,

01:32:42.900 --> 01:32:43.900
好,

01:32:43.900 --> 01:32:44.900
又给C重新复制,

01:32:44.900 --> 01:32:45.900
C说,

01:32:45.900 --> 01:32:46.900
有两个Water都用到我,

01:32:46.900 --> 01:32:49.900
Water1和Water2都用到了我,

01:32:49.900 --> 01:32:51.900
它给调动器说,

01:32:51.900 --> 01:32:52.900
调动器说,

01:32:52.900 --> 01:32:53.900
Water1已经有了,

01:32:53.900 --> 01:32:54.900
那么Water2我还没有,

01:32:54.900 --> 01:32:56.900
所以说Water2拿过来,

01:32:56.900 --> 01:32:57.900
好,

01:32:57.900 --> 01:32:58.900
这个东西呢,

01:32:58.900 --> 01:32:59.900
又说,

01:32:59.900 --> 01:33:00.900
又给调动器说,

01:33:00.900 --> 01:33:01.900
我有一个Water2,

01:33:01.900 --> 01:33:02.900
想运行我,

01:33:02.900 --> 01:33:03.900
那么调动器看,

01:33:03.900 --> 01:33:04.900
有Water2了,

01:33:04.900 --> 01:33:05.900
它就维护这么一个数组,

01:33:05.900 --> 01:33:06.900
没什么意思吧,

01:33:06.900 --> 01:33:07.900
都是调动器做的事情,

01:33:07.900 --> 01:33:09.900
保证的数组里面东西是唯一的,

01:33:09.900 --> 01:33:14.380
好,

01:33:14.380 --> 01:33:19.850
那么调动器是什么时候执行的呢,

01:33:19.850 --> 01:33:21.850
它是生成一个函数,

01:33:21.850 --> 01:33:23.850
这是一个函数,

01:33:23.850 --> 01:33:24.850
它会生成一个函数,

01:33:24.850 --> 01:33:26.850
这个函数的作用其实非常简单,

01:33:26.850 --> 01:33:28.850
循环数组,

01:33:28.850 --> 01:33:30.850
循环数组,

01:33:30.850 --> 01:33:32.850
依次执行,

01:33:32.850 --> 01:33:34.850
它就是有这么一个函数啊,

01:33:34.850 --> 01:33:35.850
就是调动器,

01:33:35.850 --> 01:33:36.850
skate it out,

01:33:36.850 --> 01:33:37.850
原码里面,

01:33:37.850 --> 01:33:38.850
它在哪儿呢,在这儿,

01:33:38.850 --> 01:33:39.850
叫做,

01:33:39.850 --> 01:33:41.850
skate it out,

01:33:41.850 --> 01:33:42.850
单码也没多好,

01:33:42.850 --> 01:33:43.850
100多好,

01:33:43.850 --> 01:33:44.850
就说的事情很简单,

01:33:44.850 --> 01:33:45.850
它就要维护一个东西,

01:33:45.850 --> 01:33:46.850
维护一个数组,

01:33:46.850 --> 01:33:50.800
一个数组,

01:33:50.800 --> 01:33:51.800
它一个函数,

01:33:51.800 --> 01:33:52.800
这个函数就是执行数组里面,

01:33:52.800 --> 01:33:53.800
每一下,

01:33:53.800 --> 01:33:54.800
然后把数组清空,

01:33:54.800 --> 01:33:56.800
把数组执行完,

01:33:56.800 --> 01:33:57.800
那么这个函数,

01:33:57.800 --> 01:33:59.800
什么时候执行呢,

01:33:59.800 --> 01:34:00.800
这个函数,

01:34:00.800 --> 01:34:01.800
它是交给一个东西,

01:34:01.800 --> 01:34:02.800
叫做next take,

01:34:02.800 --> 01:34:04.800
这个工具在执行,

01:34:04.800 --> 01:34:05.800
这个工具呢,

01:34:05.800 --> 01:34:07.800
它要做的事情也很简单,

01:34:07.800 --> 01:34:08.800
它会把这个函数,

01:34:08.800 --> 01:34:10.800
加入到维对点,

01:34:10.800 --> 01:34:13.800
维对点,

01:34:13.800 --> 01:34:14.800
你们要学过,

01:34:14.800 --> 01:34:15.800
这个要学过,

01:34:15.800 --> 01:34:17.800
事件循环的知识了啊,

01:34:17.800 --> 01:34:18.800
事件循环,

01:34:18.800 --> 01:34:19.800
这是基础知识啊,

01:34:19.800 --> 01:34:20.800
所以说,

01:34:20.800 --> 01:34:21.800
咱们记得是,

01:34:21.800 --> 01:34:22.800
很多基础知识,

01:34:22.800 --> 01:34:23.800
是极其重要的,

01:34:23.800 --> 01:34:24.800
加入到维对点,

01:34:24.800 --> 01:34:25.800
它怎么加的呢,

01:34:25.800 --> 01:34:26.800
它是利用promise,

01:34:26.800 --> 01:34:27.800
这要涉及到ES6的知识,

01:34:27.800 --> 01:34:28.800
比如说,

01:34:28.800 --> 01:34:29.800
用这种方式来加的,

01:34:29.800 --> 01:34:30.800
然后认,

01:34:30.800 --> 01:34:32.800
就把它放到个认里面了,

01:34:32.800 --> 01:34:33.800
就是这个函数,

01:34:33.800 --> 01:34:36.800
实际上是在它认里面,

01:34:36.800 --> 01:34:37.800
那么这里下面有个链接,

01:34:37.800 --> 01:34:38.800
链接呢,

01:34:38.800 --> 01:34:39.800
是5U的官方稳当,

01:34:39.800 --> 01:34:40.800
它给你详细说了,

01:34:40.800 --> 01:34:42.800
这个next take的处理方式,

01:34:42.800 --> 01:34:43.800
它是先判断,

01:34:43.800 --> 01:34:44.800
有没有promise,

01:34:44.800 --> 01:34:45.800
再判断,

01:34:45.800 --> 01:34:46.800
有没有set to immediate,

01:34:46.800 --> 01:34:48.800
你可以自己去看一下,

01:34:48.800 --> 01:34:49.800
总之这个next take,

01:34:49.800 --> 01:34:50.800
其实很简单,

01:34:50.800 --> 01:34:51.800
它就把它放到这个,

01:34:51.800 --> 01:34:52.800
其实你可以在这里看一下,

01:34:52.800 --> 01:34:53.800
那个take,

01:34:53.800 --> 01:35:04.020
你看到这里,

01:35:04.020 --> 01:35:05.020
不是,

01:35:05.020 --> 01:35:06.020
这儿,

01:35:11.300 --> 01:35:14.060
就这么个东西,

01:35:16.060 --> 01:35:17.060
那么,

01:35:17.060 --> 01:35:18.060
回到这儿,

01:35:18.060 --> 01:35:19.060
就是,

01:35:19.060 --> 01:35:20.060
它,

01:35:20.060 --> 01:35:21.060
你就想到一点,

01:35:21.060 --> 01:35:22.060
只要一点就行了,

01:35:22.060 --> 01:35:23.060
就是这个直行,

01:35:23.060 --> 01:35:24.060
这个watcher,

01:35:24.060 --> 01:35:25.060
它是要放到

01:35:25.060 --> 01:35:26.060
围队里面执行,

01:35:27.060 --> 01:35:28.060
所以说,

01:35:28.060 --> 01:35:29.060
由于它在世界循环的

01:35:29.060 --> 01:35:30.060
队列里面,

01:35:30.060 --> 01:35:31.060
因这些同步代码,

01:35:31.060 --> 01:35:33.060
不会导致watcher立即执行,

01:35:33.060 --> 01:35:34.060
这些同步代码

01:35:34.060 --> 01:35:35.060
运行完了之后,

01:35:35.060 --> 01:35:37.060
我们后边的这些watcher,

01:35:37.060 --> 01:35:39.060
就放到next take里面执行,

01:35:39.060 --> 01:35:40.060
就是放到这个

01:35:40.060 --> 01:35:41.060
围队里面执行,

01:35:41.060 --> 01:35:43.060
是这么一个意思的,

01:35:43.060 --> 01:35:44.060
那么,

01:35:44.060 --> 01:35:45.060
最后呢,

01:35:45.060 --> 01:35:46.060
我给大家看一下,

01:35:46.060 --> 01:35:47.060
个同体流程,

01:35:47.060 --> 01:35:48.060
也就是说,

01:35:48.060 --> 01:35:49.060
Render函数的执行,

01:35:49.060 --> 01:35:50.060
因为它,

01:35:50.060 --> 01:35:51.060
由于它在watcher里面,

01:35:51.060 --> 01:35:52.060
因此Render函数的执行,

01:35:52.060 --> 01:35:53.060
除了第1次之外,

01:35:53.060 --> 01:35:54.060
第1次是同步的,

01:35:54.060 --> 01:35:56.060
后边数据变入化导致的执行,

01:35:56.060 --> 01:35:58.060
都是异步的,

01:35:58.060 --> 01:36:00.060
全部都是异步的,

01:36:00.060 --> 01:36:01.060
第1次是同步的,

01:36:01.060 --> 01:36:02.060
第1次你看,

01:36:02.060 --> 01:36:03.060
这里也是同步执行的,

01:36:03.060 --> 01:36:04.060
立即执行,

01:36:04.060 --> 01:36:05.060
比方我们这里,

01:36:05.060 --> 01:36:06.060
输出一个123,

01:36:07.060 --> 01:36:11.260
在前这个123在后,

01:36:11.260 --> 01:36:13.260
watcher1123,

01:36:13.260 --> 01:36:15.260
看到没?

01:36:15.260 --> 01:36:17.260
所以它第1次是同步执行的,

01:36:17.260 --> 01:36:18.260
watcher里面喊出,

01:36:18.260 --> 01:36:19.260
第1次同步执行,

01:36:19.260 --> 01:36:20.260
后边数据变了,

01:36:20.260 --> 01:36:21.260
它就变成异步执行的,

01:36:21.260 --> 01:36:22.260
因为它不知道一个单码,

01:36:22.260 --> 01:36:23.260
到底有多少单码,

01:36:23.260 --> 01:36:24.260
会导致它变化,

01:36:24.260 --> 01:36:25.260
好,最后我们来看一下,

01:36:25.260 --> 01:36:26.260
重序流程,

01:36:26.260 --> 01:36:27.260
把重序流程过一遍,

01:36:27.260 --> 01:36:28.260
我把这个图呢,

01:36:28.260 --> 01:36:29.260
放到浏览器里面,

01:36:29.260 --> 01:36:33.790
看得清楚一点,

01:36:33.790 --> 01:36:35.790
好,其实next take的一块,

01:36:35.790 --> 01:36:36.790
那一块呢,

01:36:36.790 --> 01:36:37.790
也容易出面试题,

01:36:37.790 --> 01:36:38.790
我们没有那么多时间了,

01:36:38.790 --> 01:36:39.790
因为无用的面试题,

01:36:39.790 --> 01:36:41.790
确实出了特别,

01:36:41.790 --> 01:36:42.790
单位特别过,

01:36:42.790 --> 01:36:43.790
我们抓住重点就行了,

01:36:43.790 --> 01:36:45.790
咱们我们要讲的东西就行了,

01:36:45.790 --> 01:36:47.790
我们一开始渲染组件,

01:36:47.790 --> 01:36:49.790
不是要运行Render函数吗?

01:36:49.790 --> 01:36:50.790
我们,

01:36:50.790 --> 01:36:51.790
跟着我的思路走一遍,

01:36:51.790 --> 01:36:53.790
我们一开始说要运行Render函数,

01:36:53.790 --> 01:36:55.790
Render函数是直接运行的吗?

01:36:55.790 --> 01:36:56.790
没有,

01:36:56.790 --> 01:36:57.790
它是交给谁?

01:36:57.790 --> 01:36:58.790
交给这个watcher的,

01:36:58.790 --> 01:36:59.790
它是要把这个Render函数,

01:36:59.790 --> 01:37:01.790
交给watcher才执行,

01:37:01.790 --> 01:37:02.790
我们刚才看到过原码,

01:37:02.790 --> 01:37:04.790
对吧,它留了一个watcher,

01:37:04.790 --> 01:37:07.790
最终执行的函数里面有个Render,

01:37:07.790 --> 01:37:09.790
然后watcher的执行过程中,

01:37:09.790 --> 01:37:11.790
是不是执行这个Render函数?

01:37:11.790 --> 01:37:12.790
而Render函数执行的过程中,

01:37:12.790 --> 01:37:15.790
是不是会用到我们一些数据啊?

01:37:15.790 --> 01:37:18.790
而用到数据是不是会运行数据的getter?

01:37:18.790 --> 01:37:19.790
对不对,

01:37:19.790 --> 01:37:20.790
这个getter哪来的,

01:37:20.790 --> 01:37:21.790
是把一个原式对象,

01:37:21.790 --> 01:37:22.790
通过overlabel,

01:37:22.790 --> 01:37:23.790
转换成了每一个属性,

01:37:23.790 --> 01:37:25.790
转换成了getter setter,

01:37:25.790 --> 01:37:26.790
对吧,

01:37:26.790 --> 01:37:27.790
因此在Render函数的运行过程中,

01:37:27.790 --> 01:37:28.790
它就会用到一些数据,

01:37:28.790 --> 01:37:30.790
这些数据它就会触发它的getter执行,

01:37:30.790 --> 01:37:31.790
而触发getter执行的时候,

01:37:31.790 --> 01:37:33.790
是不是会用一代收集?

01:37:33.790 --> 01:37:34.790
它就会记录,

01:37:34.790 --> 01:37:36.790
哦,你这个watcher,

01:37:36.790 --> 01:37:38.790
用到了这些数据,

01:37:38.790 --> 01:37:43.170
对吧,这是第一块,

01:37:43.170 --> 01:37:44.170
接下来,

01:37:44.170 --> 01:37:47.170
有一天这个数据发生变化了,

01:37:47.170 --> 01:37:50.170
有一天这个数据发生变化了,

01:37:50.170 --> 01:37:53.170
之前是不是有拿小板记录过了?

01:37:53.170 --> 01:37:55.170
于是它就会通知这个watcher,

01:37:55.170 --> 01:37:56.170
你重新给把这个函数,

01:37:56.170 --> 01:37:58.170
重新给我运行一遍,

01:37:58.170 --> 01:37:59.170
而且它不会立即执行,

01:37:59.170 --> 01:38:01.170
它会把自己交给雕住器,

01:38:01.170 --> 01:38:04.170
因为它可能触发了多次变化,

01:38:04.170 --> 01:38:05.170
如果说直接执行的话,

01:38:05.170 --> 01:38:06.170
它会运行很多次,

01:38:06.170 --> 01:38:07.170
它会把自己交给雕住器,

01:38:07.170 --> 01:38:10.170
雕住器它会把这个watcher添加到一个对列,

01:38:10.170 --> 01:38:13.170
可能一个雕住器里面已经有一些watcher了,

01:38:13.170 --> 01:38:14.170
它就要添加进去,

01:38:14.170 --> 01:38:15.170
如果说已经有重复的话,

01:38:15.170 --> 01:38:16.170
就不添加,

01:38:16.170 --> 01:38:18.170
然后把执行这个对列的操作,

01:38:18.170 --> 01:38:20.170
加到那个next tick里边,

01:38:20.170 --> 01:38:21.170
这是一个事件循环的,

01:38:21.170 --> 01:38:22.170
就是事件对列,

01:38:22.170 --> 01:38:23.170
它是异步执行的,

01:38:23.170 --> 01:38:25.170
这里边的方法全是异步的,

01:38:25.170 --> 01:38:27.170
next tick里边的方法全是异步的,

01:38:27.170 --> 01:38:29.170
那么next tick里边可能有很多方法,

01:38:29.170 --> 01:38:31.170
其中一个方法就是这个,

01:38:31.170 --> 01:38:32.170
这个是干嘛的,

01:38:32.170 --> 01:38:33.170
是执行这个对列的,

01:38:33.170 --> 01:38:37.670
好,当你的同步单码执行完成之后,

01:38:37.670 --> 01:38:40.670
它是不是就重新执行fn1,

01:38:40.670 --> 01:38:41.670
fn2,

01:38:41.670 --> 01:38:43.670
然后还有这个东西,

01:38:43.670 --> 01:38:46.670
而这个东西是不是就重新执行了watcher,

01:38:46.670 --> 01:38:48.670
重新执行,

01:38:48.670 --> 01:38:50.670
watcher是不是又重新运行了人段函数,

01:38:50.670 --> 01:38:51.670
一重新运行了人段函数,

01:38:51.670 --> 01:38:53.670
是不是又重新进行了依赖收集,

01:38:53.670 --> 01:38:56.670
是不是打脚本又重新记录了一下,

01:38:56.670 --> 01:38:57.670
对吧,

01:38:57.670 --> 01:38:58.670
好,又等待了,

01:38:58.670 --> 01:39:00.670
将来有一天数据变化了,

01:39:01.670 --> 01:39:04.670
之前有个那些watcher你就去变,

01:39:04.670 --> 01:39:06.670
那么watcher又把自己交给调路器,

01:39:06.670 --> 01:39:08.670
调路器又把加到对列,

01:39:08.670 --> 01:39:09.670
然后加到next tick,

01:39:09.670 --> 01:39:11.670
然后又重新出发watcher的执行,

01:39:11.670 --> 01:39:13.670
又重新运行人段函数,

01:39:13.670 --> 01:39:15.670
人段函数一运行又重新收集依赖,

01:39:15.670 --> 01:39:17.670
因为每一次的依赖可能不一样,

01:39:17.670 --> 01:39:19.670
因为要考虑到有异复啊,

01:39:19.670 --> 01:39:20.670
又循环,对吧,

01:39:20.670 --> 01:39:22.670
每一次收集的依赖可能都不一样的,

01:39:22.670 --> 01:39:23.670
重新收集依赖,

01:39:23.670 --> 01:39:26.670
好,那么将来一个一难的向发的变化又运行watcher,

01:39:26.670 --> 01:39:29.670
看来这就是它的整个享用的过程,

