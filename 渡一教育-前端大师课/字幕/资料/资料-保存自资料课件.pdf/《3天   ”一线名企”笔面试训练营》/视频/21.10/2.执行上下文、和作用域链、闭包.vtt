WEBVTT

00:01.200 --> 00:05.200
正宁和妇灵

00:05.200 --> 00:08.200
他有正宁和妇灵

00:08.200 --> 00:13.200
而且你会发现正宁和妇灵还是不一样的

00:13.200 --> 00:16.960
这里比较的实确

00:16.960 --> 00:18.960
但是实际上他们是不一样的

00:18.960 --> 00:20.960
你说正宁和妇灵

00:20.960 --> 00:23.960
他们有什么样的区别呢

00:23.960 --> 00:25.960
其实跟我们平时开发而言的话

00:25.960 --> 00:26.960
没有啥区别

00:26.960 --> 00:28.960
因为你们平时开发

00:28.960 --> 00:31.960
可能你一辈子开发都不会遇到妇灵

00:32.960 --> 00:34.960
但是有些比较特殊的情况下

00:34.960 --> 00:36.960
可能会有一些差别

00:36.960 --> 00:37.960
比方说

00:37.960 --> 00:39.960
咱们有一个数字

00:39.960 --> 00:41.960
随便一个数字吧 123

00:41.960 --> 00:42.960
这个数字呢

00:42.960 --> 00:43.960
我们去处议一个零

00:43.960 --> 00:44.960
我们会得到一个结果

00:44.960 --> 00:45.960
叫做音飞的地

00:45.960 --> 00:46.960
这大家都知道

00:46.960 --> 00:48.960
对吧 这叫正无穷

00:48.960 --> 00:50.960
那么如果说

00:50.960 --> 00:52.960
我们的是一个富数的话

00:52.960 --> 00:54.960
除了是一个富零的话

00:54.960 --> 00:57.960
它得到的是富的音飞的地

00:57.960 --> 00:59.960
其他的没有什么区别

00:59.960 --> 01:00.960
就这个地方有区别

01:00.960 --> 01:02.960
所以我们可以看到

01:02.960 --> 01:04.960
正宁和富零

01:04.960 --> 01:06.960
他们在表现上

01:06.960 --> 01:08.960
实际上是有差异的

01:08.960 --> 01:09.960
是不一样的

01:09.960 --> 01:11.960
如果说他们一样的话

01:11.960 --> 01:13.960
都应该得到的是一个结果

01:13.960 --> 01:15.960
但是他得到的是不一样的结果

01:15.960 --> 01:16.960
我再次重生了

01:16.960 --> 01:18.960
这个玩意一般来说

01:18.960 --> 01:20.960
面试也不太会考虑

01:20.960 --> 01:22.960
你平时开发的也不太会遇到

01:22.960 --> 01:23.960
但是我在这里

01:23.960 --> 01:24.960
想到都给他说过一下

01:24.960 --> 01:27.960
他们两个是不太一样的

01:27.960 --> 01:28.960
但是呢

01:28.960 --> 01:30.960
他一个很神奇的现象就是

01:30.960 --> 01:33.960
比较正宁和富零的时候

01:33.960 --> 01:36.960
他们居然得到了的是Q

01:36.960 --> 01:38.960
那么这个问题

01:38.960 --> 01:41.960
官方他是这么解释的

01:41.960 --> 01:44.960
这个玩意是不太正常的一个现象

01:44.960 --> 01:46.960
他不好意思说

01:46.960 --> 01:47.960
这是一个bug

01:47.960 --> 01:50.960
实际上正宁和富零是不一样的

01:50.960 --> 01:52.960
这结实表现上是不一样的

01:52.960 --> 01:54.960
但是他们过去了得到

01:54.960 --> 01:55.960
通过等号也好

01:55.960 --> 01:57.960
通过那个

01:57.960 --> 01:58.960
严格相等也好

01:58.960 --> 01:59.960
得到的是Q

01:59.960 --> 02:01.960
因此呢在ES6里边

02:01.960 --> 02:03.960
他建议啊

02:03.960 --> 02:05.960
你之后再去比较两个东西

02:05.960 --> 02:07.960
是不是一样的时候啊

02:07.960 --> 02:09.960
你最好能连这个

02:09.960 --> 02:11.960
三个等号也不建议你使用了

02:11.960 --> 02:13.960
使用什么呢

02:13.960 --> 02:15.960
使用optic

02:15.960 --> 02:17.960
这是ES6的东西

02:17.960 --> 02:18.960
当你使用optic

02:18.960 --> 02:19.960
是意思来比较

02:19.960 --> 02:21.960
正宁和富零的时候呢

02:21.960 --> 02:23.960
得到的是poor

02:23.960 --> 02:24.960
optic是意思呢

02:24.960 --> 02:26.960
跟那个三个等号基本上

02:26.960 --> 02:28.960
是完全一致的

02:28.960 --> 02:29.960
它的效果是完全一致的

02:29.960 --> 02:31.960
那么就是在这个零的

02:31.960 --> 02:33.960
处理上有些区别

02:33.960 --> 02:34.960
好吧

02:34.960 --> 02:35.960
那么再给他说一下啊

02:35.960 --> 02:37.960
这个小的知识

02:37.960 --> 02:38.960
好那么进入咱们

02:38.960 --> 02:39.960
今天晚上的课题

02:39.960 --> 02:41.960
我们昨天呢学习了

02:41.960 --> 02:43.960
运算规则和值引用

02:43.960 --> 02:45.960
值和引用和运算规则

02:45.960 --> 02:46.960
那么这里呢我就把

02:46.960 --> 02:47.960
够了啊

02:47.960 --> 02:48.960
这么一个仪式感

02:48.960 --> 02:50.960
今天晚上咱们学习啥呢

02:50.960 --> 02:52.960
我们学习执行上下文

02:52.960 --> 02:54.960
以及作用率列和必包

02:54.960 --> 02:56.960
因为这一块知识呢

02:56.960 --> 02:57.960
也是

02:57.960 --> 02:59.960
学习前的同学

02:59.960 --> 03:01.960
疑问特别多的一个地方

03:01.960 --> 03:03.960
那么这一块知识

03:03.960 --> 03:04.960
其实它并不难啊

03:04.960 --> 03:05.960
听完今天晚上的课呢

03:05.960 --> 03:07.960
你就彻底的搞清楚啊

03:07.960 --> 03:08.960
这到底是怎么回事

03:08.960 --> 03:09.960
同学觉得学习

03:09.960 --> 03:10.960
也是里面的必包

03:10.960 --> 03:11.960
搞不清楚啊

03:11.960 --> 03:12.960
觉得特别烦

03:12.960 --> 03:13.960
其实

03:13.960 --> 03:14.960
它并不难

03:14.960 --> 03:15.960
好咱们来看一下啊

03:15.960 --> 03:17.960
首先是指引上下文

03:17.960 --> 03:18.960
这个玩意是咋弄玩意呢

03:18.960 --> 03:20.960
我举个例子了

03:20.960 --> 03:21.960
我们平时呢

03:21.960 --> 03:23.960
经常去定义一个函数

03:23.960 --> 03:24.960
定义完了之后呢

03:24.960 --> 03:26.960
我们去调用一个函数

03:26.960 --> 03:27.960
我们如何去看待

03:27.960 --> 03:31.960
函数定义和函数调用呢

03:31.960 --> 03:33.960
那么我们可以认为

03:33.960 --> 03:35.960
当我去定义函数的时候

03:35.960 --> 03:36.960
表达的是

03:36.960 --> 03:38.960
我可以做某一件事

03:38.960 --> 03:40.960
当我去调用函数的时候

03:40.960 --> 03:42.960
表达的是

03:42.960 --> 03:45.960
我立即要去做这件事

03:45.960 --> 03:47.960
比方说我们邓哥

03:47.960 --> 03:48.960
会跑步

03:49.960 --> 03:50.960
经常锻炼身体

03:50.960 --> 03:51.960
那么这个

03:51.960 --> 03:54.960
我们把它叫做函数定义

03:54.960 --> 03:55.960
他表达的是

03:55.960 --> 03:57.960
邓哥他可以做这件事

03:57.960 --> 03:58.960
并不代表

03:58.960 --> 03:59.960
他现在就去做了

03:59.960 --> 04:01.960
他可以做

04:01.960 --> 04:03.960
那么如果说我们说

04:03.960 --> 04:05.960
邓哥现在去跑步

04:05.960 --> 04:06.960
那么这就是函数调用

04:06.960 --> 04:07.960
他可以跑步

04:07.960 --> 04:09.960
现在我就去做这件事

04:09.960 --> 04:12.960
那么就表示

04:12.960 --> 04:14.960
他马上就要去做这件事

04:14.960 --> 04:15.960
这叫函数调用

04:15.960 --> 04:17.960
那么为什么我要去分清楚

04:17.960 --> 04:18.960
这两个概念呢

04:18.960 --> 04:19.960
因为就跟我们接下来

04:19.960 --> 04:21.960
要讲的执行生产有没有关系

04:21.960 --> 04:24.960
当你需要做一件事的时候

04:24.960 --> 04:25.960
有一些准备工作

04:25.960 --> 04:26.960
你是要去做的

04:26.960 --> 04:28.960
比方说邓哥要跑步

04:28.960 --> 04:29.960
他需要去准备一些东西

04:29.960 --> 04:30.960
对吧

04:30.960 --> 04:32.960
邓哥是一个生活非常精致的人

04:32.960 --> 04:34.960
所以说他会要准备

04:34.960 --> 04:35.960
各种跑步的装备

04:35.960 --> 04:36.960
什么男貓运动服

04:36.960 --> 04:38.960
奥特曼的运动鞋

04:38.960 --> 04:40.960
海边宝宝的同款毛巾

04:40.960 --> 04:41.960
插一插汗

04:41.960 --> 04:43.960
然后来一瓶北边的汽水

04:43.960 --> 04:45.960
这些都是他做的准备工作

04:45.960 --> 04:47.960
准备这些东西的好处是什么呢

04:47.960 --> 04:50.960
是在他在做这件事的过程中

04:50.960 --> 04:52.960
如果说我需要某些东西的时候

04:52.960 --> 04:54.960
我可以立即拿着刀

04:54.960 --> 04:55.960
就这么个意思

04:55.960 --> 04:57.960
其实我们函数也是一样

04:57.960 --> 05:00.960
当我们去调用一个函数的时候

05:00.960 --> 05:03.960
他实际上是需要做一些准备的

05:03.960 --> 05:04.960
那么这个准备呢

05:04.960 --> 05:05.960
其实在咱们邓哥的

05:05.960 --> 05:07.960
解释课程里面叫做预编译

05:07.960 --> 05:08.960
对吧

05:08.960 --> 05:09.960
他需要去做一些准备

05:09.960 --> 05:10.960
准备什么呢

05:10.960 --> 05:14.960
准备一些东西

05:14.960 --> 05:16.960
准备好这些东西过后

05:16.960 --> 05:18.960
我们将来去执行这个函数的时候

05:18.960 --> 05:19.960
要什么东西

05:19.960 --> 05:20.960
就可以直接拿到了

05:20.960 --> 05:21.960
就其中一个作用

05:21.960 --> 05:23.960
那么准备的这个东西呢

05:23.960 --> 05:26.960
就是执行上下文

05:26.960 --> 05:28.960
执行上下文的本质上

05:28.960 --> 05:30.960
它其实就是一个对象

05:30.960 --> 05:32.960
它里面可以放一些东西

05:32.960 --> 05:35.960
首先它什么时候产生这个对象

05:35.960 --> 05:37.960
是函数调用的时候

05:37.960 --> 05:39.960
什么叫做函数调用啊

05:39.960 --> 05:42.960
这是一个基础的问题啊

05:42.960 --> 05:44.960
什么叫函数调用

05:44.960 --> 05:46.960
这个玩意叫函数调用

05:46.960 --> 05:47.960
它不调吧

05:47.960 --> 05:48.960
它叫啥

05:48.960 --> 05:50.960
它叫函数的定义

05:50.960 --> 05:51.960
对不对

05:51.960 --> 05:52.960
什么叫函数调用

05:52.960 --> 05:54.960
这个玩意它叫函数调用

05:54.960 --> 05:55.960
一旦执行它

05:55.960 --> 05:56.960
对吧

05:56.960 --> 05:57.960
那么一个函数定义完了之后

05:57.960 --> 05:59.960
我可以调用很多次

05:59.960 --> 06:00.960
这叫函数调用

06:00.960 --> 06:02.960
每一次函数调用的时候

06:02.960 --> 06:04.960
它就会产生执行上下文

06:04.960 --> 06:05.960
这个玩意是啥呢

06:05.960 --> 06:06.960
这个玩意本质上

06:06.960 --> 06:07.960
就是一个对象

06:07.960 --> 06:09.960
你就可以这样认为

06:09.960 --> 06:11.960
这个对象里边可以放一些东西

06:11.960 --> 06:13.960
将来的函数执行的过程中

06:13.960 --> 06:14.960
可以从这个对象里边

06:14.960 --> 06:16.960
随时可以去拿

06:16.960 --> 06:18.960
准备好一些物品放进去

06:18.960 --> 06:22.960
那么这个对象就是执行上下文

06:22.960 --> 06:24.960
我说如果我们讲这个执行上下文

06:24.960 --> 06:25.960
首先你要理解

06:25.960 --> 06:27.960
什么时候出来的

06:27.960 --> 06:28.960
什么时候呢

06:28.960 --> 06:31.960
一定是函数的调用

06:31.960 --> 06:33.960
那么请问大家

06:33.960 --> 06:35.960
现在我就在断代吧

06:35.960 --> 06:37.960
关于这个M函数

06:37.960 --> 06:41.960
它产生了几个执行上下文

06:41.960 --> 06:44.960
就整个的执行过程

06:44.960 --> 06:49.040
产生了几个执行上下文

06:49.040 --> 06:54.040
几个呀

06:54.040 --> 06:55.040
真正听哦

06:55.040 --> 06:56.040
几个

06:56.040 --> 06:57.040
就是三个

06:57.040 --> 06:59.040
你不要看函数定义

06:59.040 --> 07:01.040
跟函数定义没关系

07:01.040 --> 07:02.040
看的是什么

07:02.040 --> 07:03.040
函数调用

07:03.040 --> 07:05.040
你调了用了几次

07:05.040 --> 07:07.040
它就产生了几个执行上下文

07:07.040 --> 07:09.040
你第一次调用产生了一个

07:09.040 --> 07:10.040
第二次调用产生了一个

07:10.040 --> 07:11.040
第三次调用产生了一个

07:11.040 --> 07:12.040
而且每个执行上下文

07:12.040 --> 07:13.040
还不一样

07:13.040 --> 07:16.040
这就是那个

07:16.040 --> 07:18.040
执行上下文产生的时机

07:18.040 --> 07:19.040
这个很重要的

07:19.040 --> 07:20.040
要记住

07:20.040 --> 07:23.040
它是函数调用的时候产生

07:23.040 --> 07:24.040
那么第二件事

07:24.040 --> 07:25.040
我们要研究它

07:25.040 --> 07:27.040
研究这个执行上下文

07:27.040 --> 07:29.040
这里边到底放了啥呀

07:29.040 --> 07:30.040
放了什么东西

07:30.040 --> 07:32.040
这里边它会放一些东西

07:32.040 --> 07:33.040
但是我们今天

07:33.040 --> 07:35.040
只看其中一个东西

07:35.040 --> 07:37.040
叫做AO

07:37.040 --> 07:38.040
你看啊

07:38.040 --> 07:39.040
我们这里一张图

07:39.040 --> 07:40.040
调用这个函数

07:40.040 --> 07:42.040
产生一个执行上下文

07:42.040 --> 07:43.040
我们把它叫做

07:43.040 --> 07:44.040
extrusion context

07:44.040 --> 07:45.040
叫做EC

07:45.040 --> 07:46.040
简称EC

07:46.040 --> 07:47.040
它里边有一个东西

07:47.040 --> 07:49.040
其实还有一些别的东西

07:49.040 --> 07:50.040
我们不去看

07:50.040 --> 07:51.040
我们只关心

07:51.040 --> 07:53.040
里边有一个东西叫AO

07:53.040 --> 07:55.040
这个AO是个啥东西呢

07:55.040 --> 07:56.040
它也是一个对象

07:56.040 --> 07:58.040
这里边它也会放一些东西

07:58.040 --> 07:59.040
所以说有的时候呢

07:59.040 --> 08:01.040
我今天晚上在讲解的过程中

08:01.040 --> 08:02.040
为了简写

08:02.040 --> 08:03.040
为了简单起见

08:03.040 --> 08:04.040
我可能就去掉

08:04.040 --> 08:05.040
外面那个货号了

08:05.040 --> 08:06.040
因为我们只看AO

08:06.040 --> 08:07.040
实际上你要知道

08:07.040 --> 08:08.040
实际上我那边

08:08.040 --> 08:10.040
还有一些别的东西

08:10.040 --> 08:11.040
那么这个AO

08:11.040 --> 08:12.040
是一个对象

08:12.040 --> 08:14.040
它这里边会放啥呢

08:14.040 --> 08:15.040
注意啊

08:15.040 --> 08:16.040
现在有没有开始执行

08:16.040 --> 08:17.040
这个函数在吗

08:17.040 --> 08:18.040
没有

08:18.040 --> 08:19.040
它都还没有执行函数

08:19.040 --> 08:21.040
它先做一些准备工作

08:21.040 --> 08:22.040
经常登革跑步一样

08:22.040 --> 08:24.040
先做一些准备

08:24.040 --> 08:25.040
那么准备就在准备

08:25.040 --> 08:26.040
这个对象

08:26.040 --> 08:27.040
准备好了之后

08:27.040 --> 08:29.040
再去执行这个函数

08:29.040 --> 08:31.040
那么这个对象里边放什么呢

08:31.040 --> 08:34.040
我们平时在函数里边

08:34.040 --> 08:38.040
用到的什么arguments

08:38.040 --> 08:40.040
还有包括我们的参数

08:40.040 --> 08:41.040
比方说有两个参数

08:41.040 --> 08:42.040
A和B

08:42.040 --> 08:45.040
包括我们函数里边的辩量

08:45.040 --> 08:47.040
包括我们的什么一些

08:47.040 --> 08:48.040
函数声明

08:48.040 --> 08:51.040
那么都会放到这个对象里边

08:51.040 --> 08:52.040
所以说我们现在

08:52.040 --> 08:53.040
我们明白了

08:53.040 --> 08:54.040
原来它准备好了

08:54.040 --> 08:55.040
这个对象之后

08:55.040 --> 08:56.040
再去执行函数

08:56.040 --> 08:57.040
这就解释了什么呢

08:57.040 --> 08:58.040
解释了函数里边

08:58.040 --> 09:00.040
为什么你可以毫无征兆的

09:00.040 --> 09:02.040
去使用这个arguments

09:02.040 --> 09:04.040
为什么可以直接

09:04.040 --> 09:10.540
可以直接使用这个玩意

09:10.540 --> 09:13.540
因为它在执行上下文字里边

09:13.540 --> 09:15.540
懂了意思吗

09:15.540 --> 09:17.540
它在执行上下文字里边

09:17.540 --> 09:19.540
正是因为它在执行上下文字里边

09:19.540 --> 09:20.540
而执行上下文字里边

09:20.540 --> 09:22.540
就是给我们准备好的东西

09:22.540 --> 09:24.540
所以说我们就可以直接使用

09:24.540 --> 09:26.540
这就是执行上下文字里边

09:26.540 --> 09:27.540
要准备的东西

09:27.540 --> 09:30.540
那么它到底是怎么准备的呢

09:30.540 --> 09:32.540
第一部分的重点

09:32.540 --> 09:35.540
它到底是怎么准备的

09:35.540 --> 09:36.540
你看这

09:36.540 --> 09:38.540
我们这里一调用了一个函数

09:38.540 --> 09:39.540
传了两个参数进去

09:39.540 --> 09:40.540
二和三

09:40.540 --> 09:41.540
这里有两个参数

09:41.540 --> 09:42.540
这个函数里边

09:42.540 --> 09:44.540
会声明一个变量C

09:44.540 --> 09:46.540
又声明了一个指函数M

09:46.540 --> 09:48.540
那么它就会产生一个执行上下文

09:48.540 --> 09:49.540
对吧

09:49.540 --> 09:50.540
我们刚才说了有arguments

09:50.540 --> 09:51.540
有什么A

09:51.540 --> 09:52.540
有B

09:52.540 --> 09:53.540
还包括这变量C

09:53.540 --> 09:55.540
还包括这个函数M

09:55.540 --> 09:56.540
都会在里边

09:56.540 --> 09:57.540
所以说我们可以在

09:57.540 --> 09:58.540
函数的运行过程中

09:58.540 --> 10:00.540
直接使用这些东西

10:00.540 --> 10:01.540
换句话说

10:01.540 --> 10:02.540
我们在函数的执行过程中

10:02.540 --> 10:03.540
我可以

10:03.540 --> 10:04.540
我能使用的东西

10:04.540 --> 10:06.540
都在执行上下文字里边

10:07.540 --> 10:08.540
执行上下文里边有

10:08.540 --> 10:09.540
我就可以用

10:09.540 --> 10:10.540
执行上下文里边没有

10:10.540 --> 10:11.540
我就用不了

10:12.540 --> 10:13.540
懂了意思吧

10:13.540 --> 10:14.540
那么我们来看一下

10:14.540 --> 10:15.540
执行上下文里边

10:15.540 --> 10:16.540
它做了哪些事

10:16.540 --> 10:17.540
其实非常简单

10:17.540 --> 10:18.540
执行上下文的整个过程

10:18.540 --> 10:20.540
就对象产生的整个过程

10:20.540 --> 10:22.540
分为三个步骤

10:22.540 --> 10:23.540
第一个步骤

10:23.540 --> 10:25.540
确定参数

10:25.540 --> 10:27.540
同时确定arguments

10:29.540 --> 10:30.540
这是啥意思

10:30.540 --> 10:31.540
来我们来举个例子

10:31.540 --> 10:33.540
比方说我这里有个函数

10:33.540 --> 10:34.540
就是M

10:34.540 --> 10:36.540
然后它有两个参数A和B

10:36.540 --> 10:38.540
然后我去雕了这个函数

10:38.540 --> 10:39.540
雕这个函数

10:39.540 --> 10:41.540
传了一个1和2进去

10:41.540 --> 10:42.540
这个函数

10:42.540 --> 10:43.540
现在还没有执行

10:43.540 --> 10:44.540
比方说现在运行

10:44.540 --> 10:46.540
我就输出AB

10:46.540 --> 10:48.540
和arguments

10:52.500 --> 10:54.500
我们就输出这三个东西

10:54.500 --> 10:56.500
现在在运行

10:56.500 --> 10:58.500
第二行的时候

10:58.500 --> 11:00.500
其实

11:00.500 --> 11:02.500
它要先做执行

11:02.500 --> 11:03.500
上下文的准备工作

11:03.500 --> 11:04.500
它要先把执行

11:04.500 --> 11:05.500
上下文确定好

11:05.500 --> 11:06.500
它怎么确定的

11:06.500 --> 11:09.500
第一步

11:09.500 --> 11:10.500
确定参数

11:10.500 --> 11:11.500
怎么确定参数呢

11:11.500 --> 11:15.500
首先它搞定arguments

11:15.500 --> 11:17.500
arguments是一个数组

11:17.500 --> 11:18.500
是一个伪数组

11:18.500 --> 11:19.500
不是一个真正的数组

11:19.500 --> 11:20.500
是一个伪数组

11:20.500 --> 11:21.500
这个伪数组里面

11:21.500 --> 11:22.500
有几项

11:22.500 --> 11:24.500
那就可能传了几个参数

11:24.500 --> 11:25.500
传了两个

11:25.500 --> 11:27.500
它有两项

11:27.500 --> 11:29.500
1和2

11:29.500 --> 11:30.500
它有两项

11:30.500 --> 11:32.500
然后有几个行参

11:32.500 --> 11:33.500
有两个行参

11:33.500 --> 11:34.500
A和B

11:34.500 --> 11:35.500
所以说

11:35.500 --> 11:36.500
它第一个行参

11:36.500 --> 11:37.500
A的值是啥呢

11:37.500 --> 11:38.500
是1

11:38.500 --> 11:39.500
B的值是啥呢

11:39.500 --> 11:41.500
是2

11:41.500 --> 11:43.500
这就是执行上下文

11:43.500 --> 11:44.500
做了第一个步骤

11:44.500 --> 11:46.500
确定参数

11:46.500 --> 11:48.500
那么这里有个小的知识点

11:48.500 --> 11:49.500
这个知识点

11:49.500 --> 11:51.500
本来不是今向的那种

11:51.500 --> 11:52.500
同学们知不知道

11:52.500 --> 11:54.500
arguments和行参之间

11:54.500 --> 11:56.500
是相互绑定的

11:56.500 --> 11:57.500
也就是

11:57.500 --> 11:58.500
什么意思呢

11:58.500 --> 11:59.500
它不是我们普通的

11:59.500 --> 12:00.500
一个JS对象

12:00.500 --> 12:01.500
就这个A的值

12:01.500 --> 12:03.500
和arguments的这些值

12:03.500 --> 12:04.500
是绑立在一起的

12:04.500 --> 12:06.500
比方说像这个A

12:06.500 --> 12:07.500
算这个A

12:07.500 --> 12:09.500
它跟这个E绑在一起

12:09.500 --> 12:12.500
然后像这个2

12:12.500 --> 12:14.500
它跟这个B绑在一起

12:14.500 --> 12:15.500
那么就意味着啥呢

12:15.500 --> 12:16.500
意味着你在

12:16.500 --> 12:17.500
执行代码的过程中

12:17.500 --> 12:19.500
如果说你改动了这个E

12:19.500 --> 12:20.500
改动了这个A

12:20.500 --> 12:22.500
那么这里也会改动

12:22.500 --> 12:23.500
改动了2

12:23.500 --> 12:24.500
改动了这个B

12:24.500 --> 12:25.500
这里也会改动

12:25.500 --> 12:26.500
比方说我们就一个意思

12:26.500 --> 12:27.500
把你这里加A

12:27.500 --> 12:28.500
复制为3

12:28.500 --> 12:29.500
B复制为4

12:29.500 --> 12:30.500
那么这里呢

12:30.500 --> 12:31.500
输出A和B

12:31.500 --> 12:32.500
和arguments

12:33.500 --> 12:34.500
你会看到

12:34.500 --> 12:35.500
前面是3和4

12:35.500 --> 12:36.500
A和B变了

12:36.500 --> 12:38.500
那么arguments也跟着变了

12:38.500 --> 12:39.500
那么同样的道理

12:39.500 --> 12:40.500
如果说你去

12:40.500 --> 12:42.500
改arguments的时候呢

12:42.500 --> 12:44.500
那么这个A和B

12:44.500 --> 12:45.500
也会相应的变化

12:45.500 --> 12:46.500
它们是绑在一起的

12:46.500 --> 12:47.500
这个当年

12:47.500 --> 12:48.500
知道就行了

12:48.500 --> 12:50.500
这不是本节课的知识

12:50.500 --> 12:51.500
这是我们执行

12:51.500 --> 12:52.500
上项文的第一步

12:52.500 --> 12:54.500
确定参数

12:54.500 --> 12:55.500
没问题吧

12:55.500 --> 12:56.500
非常简单

12:56.500 --> 12:57.500
第二步

12:57.500 --> 12:58.500
还没完

12:58.500 --> 13:00.500
还不着急执行

13:00.500 --> 13:01.500
还有第二步

13:01.500 --> 13:02.500
实际上呢

13:02.500 --> 13:04.500
叫提取函数声明

13:04.500 --> 13:06.500
这是啥意思呢

13:06.500 --> 13:07.500
因为有些函数啊

13:07.500 --> 13:08.500
它在它里边

13:08.500 --> 13:10.500
也定义了一些函数

13:10.500 --> 13:12.500
比方说我再定义一个函数C

13:12.500 --> 13:14.500
在这里定义的

13:14.500 --> 13:16.500
是不是定义了一个函数

13:16.500 --> 13:17.500
对吧

13:17.500 --> 13:19.500
这叫做函数声明

13:19.500 --> 13:20.500
可能有些同学呢

13:20.500 --> 13:21.500
没搞清楚

13:21.500 --> 13:23.500
函数声明

13:23.500 --> 13:25.500
和函数表达式的区别

13:25.500 --> 13:28.500
我这里新开一个吧

13:28.500 --> 13:31.500
这种写法叫做函数声明

13:31.500 --> 13:34.260
然后呢

13:34.260 --> 13:36.260
这种写法

13:36.260 --> 13:40.950
叫做函数表达式

13:40.950 --> 13:42.950
这叫函数表达式

13:42.950 --> 13:44.950
这不叫函数声明啊

13:44.950 --> 13:45.950
这叫函数表达式

13:45.950 --> 13:47.950
这叫做函数声明

13:47.950 --> 13:49.950
你可以简单的理解为

13:49.950 --> 13:51.950
只要你这样子写了

13:51.950 --> 13:52.950
那就是函数声明

13:52.950 --> 13:53.950
注意啊

13:53.950 --> 13:54.950
前边后边

13:54.950 --> 13:55.950
不能加任何东西

13:55.950 --> 13:56.950
干干净净的这样子写

13:56.950 --> 13:58.950
写出来就是函数声明

13:58.950 --> 13:59.950
其他的任何地方

13:59.950 --> 14:01.950
全部都是函数表达式

14:01.950 --> 14:02.950
你可以这样认为

14:02.950 --> 14:04.950
明白了

14:04.950 --> 14:06.950
再来一个区分

14:06.950 --> 14:08.950
函数声明和函数表达式的例子

14:08.950 --> 14:09.950
就是一个技巧啊

14:09.950 --> 14:11.950
这是函数声明

14:11.950 --> 14:12.950
下边呢

14:12.950 --> 14:14.950
这是函数表达式

14:14.950 --> 14:16.950
函数表达式

14:16.950 --> 14:18.950
再来一个区分他们的技巧

14:18.950 --> 14:20.950
就是

14:20.950 --> 14:22.950
所有的函数声明

14:22.950 --> 14:24.950
必须写函数明

14:24.950 --> 14:26.950
这个名字你不能省略

14:26.950 --> 14:27.950
省略的就是与法错误

14:27.950 --> 14:28.950
比方你这样子写了

14:28.950 --> 14:29.950
与法错误

14:29.950 --> 14:30.950
你看直接爆错了

14:30.950 --> 14:34.520
如果说你把他名字

14:34.520 --> 14:35.520
给他去掉

14:35.520 --> 14:36.520
他爆错了

14:36.520 --> 14:37.520
说明你这个位置

14:37.520 --> 14:39.520
是函数声明

14:39.520 --> 14:40.520
如果说你把名字

14:40.520 --> 14:41.520
给他去掉

14:41.520 --> 14:42.520
他没有爆错

14:42.520 --> 14:44.520
那他就是函数表达式

14:44.520 --> 14:45.520
你这样判断

14:45.520 --> 14:46.520
其实非常简单

14:46.520 --> 14:47.520
你只有这样子写

14:47.520 --> 14:48.520
函数声明

14:48.520 --> 14:50.520
别的写法都是函数表达式

14:50.520 --> 14:51.520
这样子

14:51.520 --> 14:52.520
我可以加名字

14:52.520 --> 14:53.520
也可以去名字

14:53.520 --> 14:54.520
他都不会爆错了

14:54.520 --> 14:55.520
分清楚啊

14:55.520 --> 14:56.520
这两个是

14:56.520 --> 14:58.520
在我们这一块的知识里面

14:58.520 --> 15:00.520
处理起来是不一样的

15:00.520 --> 15:01.520
那我现在问大家

15:01.520 --> 15:02.520
看看大家有没有掌握

15:02.520 --> 15:03.520
这一块东西

15:03.520 --> 15:06.520
请问这样的写法

15:06.520 --> 15:08.520
是函数声明

15:08.520 --> 15:11.520
还是函数表达式

15:11.520 --> 15:12.520
这个写法

15:12.520 --> 15:18.930
是函数表达式

15:18.930 --> 15:19.930
怎么看出来的

15:19.930 --> 15:20.930
他们名字

15:20.930 --> 15:21.930
名字都没有

15:21.930 --> 15:22.930
好

15:22.930 --> 15:23.930
那我现在换一个

15:23.930 --> 15:24.930
这是函数表达式

15:24.930 --> 15:25.930
然后换一个AA

15:25.930 --> 15:26.930
加个名字

15:26.930 --> 15:27.930
他是函数声明

15:27.930 --> 15:28.930
还是表达式

15:28.930 --> 15:35.530
还是表达式

15:35.530 --> 15:38.530
不要被他名字迷惑了

15:38.530 --> 15:39.530
表达式的特点

15:39.530 --> 15:40.530
就是你可以写名字

15:40.530 --> 15:41.530
也可以不写名字

15:41.530 --> 15:42.530
都行

15:42.530 --> 15:43.530
反正你就是

15:43.530 --> 15:45.530
不写名字也不爆错

15:45.530 --> 15:46.530
至于为什么这个

15:46.530 --> 15:47.530
函数表达式

15:47.530 --> 15:48.530
是因为加了个扩号

15:48.530 --> 15:50.530
加扩号就变成表达式了

15:50.530 --> 15:51.530
反正你记住

15:51.530 --> 15:52.530
函数声明只能这样子写

15:52.530 --> 15:55.530
没有别的任何写法了

15:55.530 --> 15:57.530
这里我顺便说一句

15:57.530 --> 16:00.530
函数声明呢

16:00.530 --> 16:03.530
是可以放到判断

16:03.530 --> 16:05.530
循环里边的

16:05.530 --> 16:06.530
啥意思

16:06.530 --> 16:07.530
比方说你这里写了一个判断

16:07.530 --> 16:08.530
然后在这边

16:08.530 --> 16:09.530
我不知道同学们

16:09.530 --> 16:11.530
有没有写过这样的代码

16:11.530 --> 16:13.530
在这边写个函数声明

16:13.530 --> 16:14.530
他叫不叫函数声明

16:14.530 --> 16:15.530
他叫

16:15.530 --> 16:17.530
但是这种函数声明

16:17.530 --> 16:19.530
以这一辈子做前段开发

16:19.530 --> 16:21.530
永远不要去写这个东西

16:21.530 --> 16:24.530
他出来的现象是各种怪异

16:24.530 --> 16:27.530
因为他不符合官方标准

16:27.530 --> 16:29.530
函数声明必须在顶级

16:29.530 --> 16:30.530
在函数里边写

16:30.530 --> 16:31.530
可不可以写函数声明

16:31.530 --> 16:32.530
可以

16:32.530 --> 16:33.530
但是也必须要放到顶级

16:33.530 --> 16:34.530
你不能放到判断

16:34.530 --> 16:35.530
循环里边

16:35.530 --> 16:36.530
去写函数声明

16:36.530 --> 16:38.530
你可以在循环判断里边写什么

16:38.530 --> 16:40.530
写函数表达是没有任何问题

16:40.530 --> 16:41.530
一点问题都没有

16:41.530 --> 16:43.530
但是你千万不要在这里边

16:43.530 --> 16:44.530
写函数声明

16:44.530 --> 16:45.530
而且

16:45.530 --> 16:47.530
如果说你写了函数声明的话

16:47.530 --> 16:49.530
不同的浏览器解释

16:49.530 --> 16:51.530
这个东西是不一样的

16:51.530 --> 16:52.530
这种情况

16:52.530 --> 16:54.530
面试体有没有可能出现的

16:54.530 --> 16:55.530
有

16:55.530 --> 16:57.530
但是可能出现的概率极低

16:57.530 --> 16:58.530
而且

16:58.530 --> 16:59.530
如果说面试体出现

16:59.530 --> 17:00.530
这个东西

17:00.530 --> 17:02.530
说明面试官

17:02.530 --> 17:04.530
他对这个东西不是很了解

17:04.530 --> 17:05.530
因为这个玩意

17:05.530 --> 17:07.530
是无穷无尽的坑

17:07.530 --> 17:08.530
而且

17:08.530 --> 17:09.530
不同的浏览器解释

17:09.530 --> 17:10.530
指形是不一样的

17:10.530 --> 17:12.530
这个东西是没法出题的

17:12.530 --> 17:14.530
真人把您是没法出题的

17:14.530 --> 17:15.530
我给大家说清楚

17:15.530 --> 17:16.530
这个东西永远不要在

17:16.530 --> 17:17.530
判断循环里边

17:17.530 --> 17:18.530
去写函数声明

17:18.530 --> 17:21.530
你写函数表达是没有任何问题

17:21.530 --> 17:23.530
这里我先把这个函数声明

17:23.530 --> 17:25.530
和函数表达是给大家解释清楚

17:25.530 --> 17:27.530
接下来我说下面的东西

17:27.530 --> 17:29.530
现在我们回过头来看招

17:29.530 --> 17:30.530
刚才我们说到哪儿呢

17:30.530 --> 17:31.530
说到第二步

17:31.530 --> 17:32.530
第一步确定函数

17:32.530 --> 17:33.530
第二步就是

17:33.530 --> 17:35.530
提取函数声明

17:35.530 --> 17:37.530
函数声明

17:37.530 --> 17:38.530
啥意思啊

17:38.530 --> 17:39.530
你看这儿啊

17:39.530 --> 17:41.530
我们现在有了一个函数C

17:41.530 --> 17:43.530
这是一个函数声明吧

17:43.530 --> 17:45.530
那么现在我们第一步完成了

17:45.530 --> 17:46.530
确定函数

17:46.530 --> 17:47.530
确定行参

17:47.530 --> 17:48.530
确定R个名词

17:48.530 --> 17:49.530
然后第二步

17:49.530 --> 17:50.530
就要看一下

17:50.530 --> 17:52.530
我们这个函数里边

17:52.530 --> 17:54.530
有没有函数声明

17:54.530 --> 17:55.530
有没有呢

17:55.530 --> 17:56.530
有的C

17:56.530 --> 17:58.530
语音师就把C提出来了

17:58.530 --> 17:59.530
它是一个什么的

17:59.530 --> 18:01.530
它就是一个函数C

18:01.530 --> 18:02.530
一个函数

18:03.530 --> 18:04.530
懂了意思吗

18:04.530 --> 18:05.530
再把提到这儿了

18:06.530 --> 18:07.530
这就解释了什么意思

18:07.530 --> 18:09.530
这就解释了什么现象呢

18:09.530 --> 18:11.530
当我们去执行这个函数的时候

18:11.530 --> 18:13.530
你看我在这里输出C

18:13.530 --> 18:15.530
我能不能输出

18:15.530 --> 18:16.530
我得到的是什么呢

18:16.530 --> 18:18.530
得到了居然是一个函数

18:18.530 --> 18:22.530
我们可以在函数的定义之前

18:22.530 --> 18:23.530
去使用它

18:23.530 --> 18:24.530
为什么可以使用它呢

18:24.530 --> 18:26.530
因为这个执行上下尾

18:26.530 --> 18:28.530
里边已经有这个C了

18:28.530 --> 18:30.530
这也从另一个侧面可以反映出

18:30.530 --> 18:31.530
函数在执行过程中

18:31.530 --> 18:32.530
看的是啥呀

18:32.530 --> 18:34.530
看的是就是这个执行上下尾

18:34.530 --> 18:36.530
它是从这里来去找东西的

18:36.530 --> 18:37.530
这就是我们准备好

18:37.530 --> 18:39.530
给它准备好的东西

18:39.530 --> 18:41.530
你可以使用A

18:41.530 --> 18:42.530
可以使用B

18:42.530 --> 18:43.530
可以使用C

18:43.530 --> 18:44.530
因为在执行函数的时候

18:44.530 --> 18:46.530
这个C已经有执行

18:46.530 --> 18:47.530
就解释了

18:47.530 --> 18:49.530
为什么我可以在

18:49.530 --> 18:51.530
定义函数之前就使用函数

18:51.530 --> 18:55.970
但是前例好像也是函数生物

18:55.970 --> 18:56.970
好 再来看

18:56.970 --> 18:57.970
那如果说

18:57.970 --> 19:00.970
这里边的函数是这样子写的呢

19:05.520 --> 19:07.520
这里边的函数是这样写的呢

19:07.520 --> 19:08.520
那么有第二步

19:08.520 --> 19:10.520
会不会把这个C提取出来

19:10.520 --> 19:12.520
在第二步

19:12.520 --> 19:13.520
会不会啊

19:13.520 --> 19:14.520
它就不会

19:14.520 --> 19:16.520
因为它不是函数生物

19:16.520 --> 19:17.520
说这种写法

19:17.520 --> 19:18.520
那你再去输出C

19:18.520 --> 19:19.520
你看一下

19:19.520 --> 19:21.520
这到底是undefined的

19:21.520 --> 19:22.520
这个要保清楚

19:22.520 --> 19:24.520
它只提取什么

19:24.520 --> 19:26.520
只提取函数生物

19:26.520 --> 19:28.520
这是这一步

19:28.520 --> 19:29.520
那么这一步

19:29.520 --> 19:31.520
会出现一种情况

19:31.520 --> 19:33.520
就是

19:33.520 --> 19:35.520
它的函数名字

19:35.520 --> 19:38.520
跟那个行参的名字相同了

19:38.520 --> 19:39.520
比方说这里呢

19:39.520 --> 19:41.520
我们写个函数A

19:41.520 --> 19:42.520
跟这个行

19:42.520 --> 19:43.520
这个函数的名字

19:43.520 --> 19:45.520
说跟那个行参的名字相同了

19:45.520 --> 19:47.520
那么这种情况又怎么处理呢

19:47.520 --> 19:48.520
你看

19:48.520 --> 19:50.520
遇到同名问题覆盖

19:50.520 --> 19:51.520
啥叫覆盖

19:51.520 --> 19:53.520
之前A是1

19:53.520 --> 19:55.520
现在看到这个A是一个函数了

19:55.520 --> 19:57.520
那么A就变成函数了

19:57.520 --> 19:58.520
同样的

19:58.520 --> 20:00.520
这个玩意也变成函数了

20:00.520 --> 20:02.520
因为A是跟那个绑立在一起的

20:02.520 --> 20:04.520
我们在这里会发现

20:04.520 --> 20:05.520
我这里去输出什么

20:05.520 --> 20:06.520
输出A

20:06.520 --> 20:08.520
然后输出这个archemic0

20:08.520 --> 20:11.520
它们都是函数

20:11.520 --> 20:13.520
又变成函数了

20:13.520 --> 20:14.520
这是第二步说的事

20:14.520 --> 20:15.520
第一步

20:15.520 --> 20:16.520
确定函数

20:16.520 --> 20:17.520
第二步呢

20:17.520 --> 20:19.520
提取函数生命

20:19.520 --> 20:21.520
然后遇到同名覆盖

20:21.520 --> 20:22.520
第三步

20:22.520 --> 20:25.520
提取变量生命

20:25.520 --> 20:26.520
除了函数之外呢

20:26.520 --> 20:28.520
我们这里边可能会定义一些变量

20:28.520 --> 20:31.520
比方说我这定义了一个

20:34.020 --> 20:37.020
然后再定义了一个t

20:41.020 --> 20:43.020
定义了两个变量

20:43.020 --> 20:44.020
那么变量呢

20:44.020 --> 20:46.020
这种定义方式

20:46.020 --> 20:48.020
还有一种变量定义法式的样子

20:48.020 --> 20:49.020
定义个函数

20:49.020 --> 20:50.020
无所谓吧

20:50.020 --> 20:51.020
它都是定义变量

20:51.020 --> 20:52.020
定义变量k

20:52.020 --> 20:53.020
定义变量t

20:53.020 --> 20:55.020
都可以

20:55.020 --> 20:56.020
而且呢

20:56.020 --> 20:57.020
这个变量定义

20:57.020 --> 20:59.020
你可以放到判断里边

20:59.020 --> 21:00.020
放到那个寻管里边

21:00.020 --> 21:01.020
定义都是一样的

21:01.020 --> 21:03.020
得到结果都是一样的

21:03.020 --> 21:05.020
如果说遇到了变量

21:05.020 --> 21:07.020
它就会提取这个变量

21:07.020 --> 21:09.020
并把它的值负为undefined

21:09.020 --> 21:11.020
这就是我们平时常说的

21:11.020 --> 21:14.020
变量提升

21:14.020 --> 21:15.020
提升啥意思

21:15.020 --> 21:16.020
它就提到

21:16.020 --> 21:17.020
我们以前老实说

21:17.020 --> 21:18.020
提升啥意思

21:18.020 --> 21:19.020
提升就是把它提到第1行

21:19.020 --> 21:21.020
实际上不是提到第1行

21:21.020 --> 21:22.020
是把它提到

21:22.020 --> 21:24.020
执行上下文里边

21:24.020 --> 21:25.020
那么这个地方呢

21:25.020 --> 21:26.020
就是什么呢

21:26.020 --> 21:27.020
就是k

21:27.020 --> 21:29.020
为什么undefined

21:29.020 --> 21:32.020
然后t为undefined

21:32.020 --> 21:33.020
所以说

21:33.020 --> 21:34.020
如果说你再一开始

21:34.020 --> 21:35.020
去输出这个k

21:35.020 --> 21:36.020
和t得到的结果

21:36.020 --> 21:37.020
自然而然是undefined

21:37.020 --> 21:39.020
它不会爆错的

21:39.020 --> 21:43.620
什么情况下会爆错

21:43.620 --> 21:45.620
你看这样就会爆错了

21:45.620 --> 21:47.620
为什么这样会爆错呢

21:47.620 --> 21:49.620
它告诉你abc没有定义

21:49.620 --> 21:51.620
为什么说abc没有定义呢

21:51.620 --> 21:53.620
因为在执行上下文里边

21:53.620 --> 21:54.620
找到abc的

21:54.620 --> 21:55.620
能找到吗

21:55.620 --> 21:56.620
找不到

21:56.620 --> 21:57.620
找不到

21:57.620 --> 21:58.620
那就是v定义

21:58.620 --> 21:59.620
懂了意思吗

21:59.620 --> 22:00.620
v定义就是这么来的

22:00.620 --> 22:02.620
那么k和t为什么可以呢

22:02.620 --> 22:04.620
虽然好像在定义之前

22:04.620 --> 22:05.620
不是的

22:05.620 --> 22:06.620
k和t已经被提到了

22:06.620 --> 22:08.620
执行上下文里边去了

22:08.620 --> 22:09.620
k和t是有东西的

22:09.620 --> 22:11.620
所以说你能够输出undefined

22:11.620 --> 22:12.620
这从此一个侧面

22:12.620 --> 22:13.620
就反映出

22:13.620 --> 22:14.620
我们的寒树执行

22:14.620 --> 22:15.620
找的是咋样

22:15.620 --> 22:16.620
找的就是这个执行

22:16.620 --> 22:18.620
上下文里边的东西

22:19.620 --> 22:20.620
那么现在就看

22:20.620 --> 22:21.620
第三个问题

22:21.620 --> 22:23.620
遇到同名怎么办

22:23.620 --> 22:24.620
遇到同名问题怎么办

22:24.620 --> 22:25.620
无论

22:25.620 --> 22:27.620
这跟第二步是不一样的

22:27.620 --> 22:28.620
提寒树声明的时候

22:28.620 --> 22:29.620
遇到同名问题

22:29.620 --> 22:30.620
覆盖

22:30.620 --> 22:31.620
第三步

22:31.620 --> 22:33.620
提辩量的时候遇到同名问题

22:33.620 --> 22:34.620
忽略

22:34.620 --> 22:35.620
就是他就说完了

22:35.620 --> 22:36.620
对吧

22:36.620 --> 22:38.620
比方说我们这里呢

22:40.620 --> 22:41.620
再提一个辩量

22:43.620 --> 22:44.620
a吧

22:44.620 --> 22:45.620
a等于3

22:45.620 --> 22:47.620
那这个时候呢

22:47.620 --> 22:48.620
怎么来处理这个问题呢

22:48.620 --> 22:49.620
你看提a的时候

22:49.620 --> 22:50.620
a有没有

22:50.620 --> 22:51.620
你是不是已经有了

22:51.620 --> 22:52.620
遇到了同名问题

22:52.620 --> 22:53.620
怎么办

22:53.620 --> 22:54.620
忽略

22:54.620 --> 22:56.620
当它不存在

22:56.620 --> 22:58.620
你要意思吧

22:58.620 --> 23:00.620
也就被忽略掉了

23:00.620 --> 23:01.620
这就是这个

23:01.620 --> 23:02.620
整个的执行

23:02.620 --> 23:05.620
上下文的确定过程

23:05.620 --> 23:06.620
看一下同学们

23:06.620 --> 23:07.620
这一块

23:07.620 --> 23:08.620
有没有什么问题

23:08.620 --> 23:09.620
没问题

23:09.620 --> 23:10.620
Q个1

23:10.620 --> 23:11.620
有问题

23:11.620 --> 23:12.620
打出去的问题

23:24.500 --> 23:25.500
没问题

23:25.500 --> 23:26.500
没问题的话

23:26.500 --> 23:28.500
咱们就可以利用

23:28.500 --> 23:30.500
这些现象

23:30.500 --> 23:31.500
来

23:31.500 --> 23:33.500
忽略是什么意思

23:33.500 --> 23:35.500
忽略就是不管了

23:35.500 --> 23:36.500
然后你这里遇到的

23:36.500 --> 23:37.500
同名辩量a

23:37.500 --> 23:38.500
我要第3步了

23:38.500 --> 23:39.500
进行到第3步

23:39.500 --> 23:40.500
第3步这里

23:40.500 --> 23:41.500
有一个a辩量

23:41.500 --> 23:42.500
按理说呢

23:42.500 --> 23:43.500
你是不是应该把这个a

23:43.500 --> 23:44.500
变成什么

23:45.500 --> 23:47.500
但是a已经有东西了

23:47.500 --> 23:49.500
所以已经有这个东西了

23:49.500 --> 23:50.500
那就忽略掉

23:50.500 --> 23:51.500
就不做这件事

23:51.500 --> 23:52.500
不提了

23:52.500 --> 23:53.500
我们已经有这个a了

23:53.500 --> 23:54.500
就不提了

23:54.500 --> 23:56.500
就不提取这个a了

23:56.500 --> 23:58.500
那么接着

23:58.500 --> 24:00.500
来看这个函数

24:00.500 --> 24:01.500
我们可以预见到

24:01.500 --> 24:02.500
在这里

24:02.500 --> 24:03.500
输出a

24:03.500 --> 24:04.500
那肯定是输出一个函数

24:04.500 --> 24:05.500
输出b

24:05.500 --> 24:06.500
输出2

24:06.500 --> 24:07.500
输出c

24:07.500 --> 24:08.500
也是一个函数

24:08.500 --> 24:09.500
输出t

24:09.500 --> 24:10.500
也是函d

24:10.500 --> 24:11.500
我们来看一下

24:11.500 --> 24:12.500
结果是不是我们想要的呢

24:12.500 --> 24:13.500
a是一个函数

24:13.500 --> 24:14.500
b是2

24:14.500 --> 24:15.500
c呢

24:15.500 --> 24:16.500
是一个函数

24:16.500 --> 24:17.500
函d

24:17.500 --> 24:18.500
函d

24:18.500 --> 24:19.500
没问题

24:19.500 --> 24:20.500
接下来

24:20.500 --> 24:21.500
再往下看

24:23.500 --> 24:25.500
t是函d

24:26.500 --> 24:27.500
接下来

24:27.500 --> 24:29.500
继续往后看

24:29.500 --> 24:31.500
代码到底是怎么执行的呢

24:31.500 --> 24:33.500
这个执行上下文一已经准备好了

24:33.500 --> 24:35.500
准备好了过后就开始执行代码了

24:35.500 --> 24:36.500
第二句话执行

24:36.500 --> 24:38.500
那就自然输出这些结果

24:38.500 --> 24:39.500
然后呢

24:39.500 --> 24:41.500
关键是第三句话执不执行呢

24:42.500 --> 24:44.500
第三句话执不执行

24:44.500 --> 24:45.500
第三句话

24:45.500 --> 24:46.500
不执行

24:47.500 --> 24:49.500
为什么不执行呢

24:49.500 --> 24:51.500
因为这个地方定义的函数

24:51.500 --> 24:53.500
已经被提到了哪呢

24:53.500 --> 24:54.500
提到了这了

24:54.500 --> 24:55.500
是吧

24:55.500 --> 24:56.500
就已经提到了这了

24:56.500 --> 24:57.500
所以第三句话

24:57.500 --> 24:59.500
看不看看了一眼

24:59.500 --> 25:00.500
其实他会做一些别的事

25:00.500 --> 25:01.500
不过了

25:01.500 --> 25:02.500
给我们现在没关系

25:02.500 --> 25:03.500
然后看了一眼

25:03.500 --> 25:04.500
你这个地方定义了一个函数

25:04.500 --> 25:05.500
但是我这个函数肯定是

25:05.500 --> 25:07.500
因为你是一个函数声明嘛

25:07.500 --> 25:09.500
所以说这个函数我已经提去过了

25:09.500 --> 25:10.500
所以说不管了

25:10.500 --> 25:11.500
接动往后运行

25:11.500 --> 25:13.500
第五句话执不执行呢

25:13.500 --> 25:14.500
不执行

25:14.500 --> 25:15.500
为什么呢

25:15.500 --> 25:16.500
因为他已经提去过了

25:16.500 --> 25:17.500
提去到这了

25:17.500 --> 25:18.500
说不执行

25:18.500 --> 25:19.500
相当于是这两句话

25:19.500 --> 25:20.500
就直接被忽略掉了

25:20.500 --> 25:22.500
那为什么我要强调这一点呢

25:22.500 --> 25:24.500
因为这个地方

25:24.500 --> 25:25.500
可以出面识题

25:25.500 --> 25:26.500
他怎么

25:26.500 --> 25:28.500
他会怎么来我而已

25:29.500 --> 25:37.300
你看他就这么来我而已

25:37.300 --> 25:39.300
比方就这吧

25:39.300 --> 25:40.300
我这里输出a

25:40.300 --> 25:43.300
请问a是啥

25:43.300 --> 25:45.300
请问两次输出的结果是啥

25:45.300 --> 25:47.300
我说说两次的啊

25:47.300 --> 25:50.820
第一次输出什么

25:50.820 --> 25:51.820
第一次应该大家都知道

25:51.820 --> 25:52.820
输出什么了

25:52.820 --> 25:54.820
第一次是一个函数

25:54.820 --> 25:55.820
对不对

25:55.820 --> 25:56.820
第二次输出什么呢

25:56.820 --> 25:58.820
关键是第二次

25:58.820 --> 26:00.820
第二次他会输出1

26:00.820 --> 26:02.820
好怎么来看一下啊

26:02.820 --> 26:05.520
是不是

26:05.520 --> 26:06.520
第一次输出一个函数

26:06.520 --> 26:07.520
第二次输出1

26:07.520 --> 26:08.520
为什么呢

26:08.520 --> 26:09.520
如果说你认为

26:09.520 --> 26:10.520
这句话会执行的话

26:10.520 --> 26:11.520
那就导致的

26:11.520 --> 26:12.520
那就会怎么看呢

26:12.520 --> 26:14.520
先输出一个a

26:14.520 --> 26:17.520
这里就是没有这些东西了

26:17.520 --> 26:20.520
a在执行商项文里边

26:20.520 --> 26:21.520
输出一个函数

26:21.520 --> 26:22.520
之前讲过的

26:22.520 --> 26:23.520
第一步确定参数

26:23.520 --> 26:24.520
第二步呢

26:24.520 --> 26:25.520
遇到了同名函数

26:25.520 --> 26:26.520
把它覆盖掉了

26:26.520 --> 26:27.520
变成了一个函数

26:27.520 --> 26:28.520
然后第三步提去变量

26:28.520 --> 26:29.520
变量已经存在了

26:29.520 --> 26:31.520
所以说不覆盖忽略

26:31.520 --> 26:33.520
好那么开始执行代嘛

26:33.520 --> 26:34.520
这里第二行输出啥呀

26:34.520 --> 26:35.520
自然输出一个函数

26:35.520 --> 26:36.520
然后第三行

26:36.520 --> 26:38.520
第三行是不是把a的纸改了呀

26:38.520 --> 26:40.520
是不是把a的纸改了

26:40.520 --> 26:41.520
改成什么呢

26:41.520 --> 26:42.520
这里改的是啥

26:42.520 --> 26:44.520
改的就是执行商项文里边的a

26:44.520 --> 26:45.520
知道吧

26:45.520 --> 26:46.520
函数执行过程中

26:46.520 --> 26:48.520
用到了这些短乱七八糟的

26:48.520 --> 26:49.520
什么变量啊

26:49.520 --> 26:50.520
函数声明啊

26:50.520 --> 26:52.520
全都是在执行商项文里的

26:52.520 --> 26:53.520
它改的是啥

26:53.520 --> 26:54.520
改的就是这个a

26:54.520 --> 26:55.520
所以把它改成什么

26:55.520 --> 26:56.520
改成了1了

26:56.520 --> 26:57.520
好

26:57.520 --> 26:58.520
然后呢

26:58.520 --> 26:59.520
运行到第四行

26:59.520 --> 27:00.520
第四行的时候

27:00.520 --> 27:01.520
又定了一个a函数

27:01.520 --> 27:02.520
但是呢

27:02.520 --> 27:03.520
我刚才说了

27:03.520 --> 27:04.520
不执行

27:04.520 --> 27:06.520
这个函数不执行

27:06.520 --> 27:07.520
为什么呢

27:07.520 --> 27:08.520
因为之前都已经提议过了

27:08.520 --> 27:09.520
提议过了

27:09.520 --> 27:10.520
对吧

27:10.520 --> 27:11.520
所以说这句话呢

27:11.520 --> 27:12.520
他可能做一些别的处理

27:12.520 --> 27:14.520
就忽略掉了

27:14.520 --> 27:15.520
所以到了第五行

27:15.520 --> 27:16.520
是不是输出什么

27:16.520 --> 27:17.520
就输出1

27:17.520 --> 27:18.520
是吧

27:18.520 --> 27:19.520
你要知道为什么

27:19.520 --> 27:21.520
会产生这样的一个现象

27:21.520 --> 27:22.520
好

27:22.520 --> 27:23.520
这就是

27:23.520 --> 27:24.520
然后再来啊

27:24.520 --> 27:25.520
我们再来看

27:28.520 --> 27:31.520
我们直接来一道面试题吧

27:31.520 --> 27:32.520
直接上下问

27:33.520 --> 27:34.520
来

27:34.520 --> 27:37.280
我们来看这道面试题

27:37.280 --> 27:40.280
就逼上了一道面试题

27:40.280 --> 27:42.280
然后我们来一起来做一下

27:42.280 --> 27:43.280
这道面试题

27:43.280 --> 27:44.280
我们这里有一个函数

27:44.280 --> 27:46.280
其实这就是一个典型的考察

27:46.280 --> 27:48.280
你为什么可以一眼就看出

27:48.280 --> 27:49.280
它是典型考察的

27:49.280 --> 27:50.280
是指形上下文的指示呢

27:50.280 --> 27:51.280
因为你会发现

27:51.280 --> 27:53.280
这个函数有个行参f

27:53.280 --> 27:55.280
然后有变量f

27:55.280 --> 27:56.280
有这个函数声名f

27:56.280 --> 27:58.280
那就典型的考察力

27:58.280 --> 27:59.280
这个f到底是个啥

27:59.280 --> 28:00.280
对吧

28:00.280 --> 28:01.280
在不同的时候

28:01.280 --> 28:02.280
它到底是个啥

28:02.280 --> 28:03.280
考察力这个东西

28:03.280 --> 28:04.280
那我们这个问题呢

28:04.280 --> 28:05.280
怎么来玩呢

28:05.280 --> 28:07.280
就要用指形上下文去分析

28:07.280 --> 28:09.280
首先这里有函数定义

28:09.280 --> 28:10.280
这是函数定义对吧

28:10.280 --> 28:12.280
函数定义管不管它

28:12.280 --> 28:14.280
不管它

28:14.280 --> 28:15.280
不管它

28:15.280 --> 28:17.280
我们只看函数调用

28:17.280 --> 28:18.280
调用的时候

28:18.280 --> 28:19.280
我们调用函数

28:19.280 --> 28:20.280
传了一个什么东西

28:20.280 --> 28:21.280
传了一个附进去

28:21.280 --> 28:22.280
传的是什么

28:22.280 --> 28:23.280
传的相当于是一个e

28:23.280 --> 28:24.280
对吧

28:24.280 --> 28:25.280
传了一个e进去

28:25.280 --> 28:26.280
好

28:26.280 --> 28:27.280
e传进去了

28:27.280 --> 28:31.550
那么我们看一下

28:31.550 --> 28:32.550
这个指形上下文是如何建立的

28:32.550 --> 28:33.550
第一步

28:33.550 --> 28:34.550
确定参数

28:34.550 --> 28:38.250
参数了一个org名字

28:38.250 --> 28:39.250
几个参数

28:39.250 --> 28:41.250
一个就传了一个e

28:41.250 --> 28:42.250
好

28:42.250 --> 28:43.250
当然这个东西

28:43.250 --> 28:44.250
我们这里没用

28:44.250 --> 28:45.250
没用其实

28:45.250 --> 28:46.250
你可以在做题的时候

28:46.250 --> 28:47.250
可以不写这个东西

28:47.250 --> 28:48.250
但是你一定要拿出一个

28:48.250 --> 28:49.250
长稿子

28:49.250 --> 28:51.250
写一下这个al

28:51.250 --> 28:52.250
好 接下来呢

28:52.250 --> 28:53.250
我们还要做第二步

28:53.250 --> 28:54.250
第二步说什么

28:54.250 --> 28:56.250
提取函数声名

28:56.250 --> 28:58.250
目前只有一个附e

28:58.250 --> 29:00.250
提取函数声名

29:00.250 --> 29:01.250
函数声名

29:01.250 --> 29:02.250
找一找

29:02.250 --> 29:03.250
这里边有没有函数声名

29:03.250 --> 29:04.250
有没有

29:04.250 --> 29:05.250
有

29:06.250 --> 29:07.250
在哪

29:07.250 --> 29:08.250
在这

29:08.250 --> 29:09.250
是不是在这

29:09.250 --> 29:10.250
所以说

29:10.250 --> 29:12.250
这个地方由于有同名的函数声名

29:12.250 --> 29:14.250
这个东西就变成函数了

29:14.250 --> 29:15.250
这个函数还做什么事情呢

29:15.250 --> 29:17.250
这个函数是要输出c的

29:17.250 --> 29:18.250
所以我们可以标记一下

29:18.250 --> 29:20.250
snc输出c

29:20.250 --> 29:21.250
这个标记

29:21.250 --> 29:22.250
好 第三步

29:22.250 --> 29:24.250
提取变量

29:24.250 --> 29:25.250
这里边有没有定义变量

29:25.250 --> 29:26.250
定义了好多次

29:26.250 --> 29:27.250
这个附的变量

29:27.250 --> 29:28.250
对吧

29:28.250 --> 29:29.250
甭管定义了多少次

29:29.250 --> 29:31.250
有几个变量就一个附

29:31.250 --> 29:32.250
那么这个变量

29:32.250 --> 29:33.250
要不要写成indefine的呢

29:33.250 --> 29:35.250
在这里写成indefine的呢

29:35.250 --> 29:36.250
为什么

29:36.250 --> 29:37.250
因为有同名的

29:37.250 --> 29:38.250
是不是已经有同名的了

29:38.250 --> 29:39.250
因此呢

29:39.250 --> 29:40.250
第三步

29:40.250 --> 29:41.250
有遇到同名

29:41.250 --> 29:43.250
忽略

29:43.250 --> 29:45.250
好 那么执行上下文

29:45.250 --> 29:46.250
就这么个东西

29:46.250 --> 29:47.250
好 接下来我们来看

29:47.250 --> 29:48.250
它怎么运行的

29:48.250 --> 29:50.250
运行第三行输出啥呀

29:50.250 --> 29:51.250
那自然而来

29:51.250 --> 29:53.250
它就输出一个函数

29:53.250 --> 29:54.250
对吧

29:54.250 --> 29:55.250
输出一个函数

29:55.250 --> 29:56.250
而且这个函数呢

29:56.250 --> 29:57.250
是

29:57.250 --> 29:58.250
是这个名字

29:58.250 --> 29:59.250
负

29:59.250 --> 30:01.250
其实就是这个

30:02.250 --> 30:04.250
就是这个输出c

30:04.250 --> 30:05.250
就输出c的函数

30:05.250 --> 30:06.250
标记一下

30:06.250 --> 30:07.250
输出c

30:07.250 --> 30:08.250
那么这是

30:08.250 --> 30:09.250
一开始

30:09.250 --> 30:10.250
这一行的输出

30:10.250 --> 30:11.250
一个函数

30:11.250 --> 30:12.250
然后接下来

30:12.250 --> 30:13.250
我把这个负变成了

30:13.250 --> 30:17.580
变成了一个制服串a

30:17.580 --> 30:18.580
变成了制服串a

30:18.580 --> 30:19.580
接下来

30:19.580 --> 30:20.580
我又把这个函数

30:20.580 --> 30:21.580
注意 这不是函数

30:21.580 --> 30:22.580
声明啊

30:22.580 --> 30:23.580
这是一个变量的负值

30:23.580 --> 30:24.580
用表达式

30:24.580 --> 30:25.580
负给一个变量值

30:25.580 --> 30:27.580
所以说这个地方呢

30:27.580 --> 30:28.580
又把这个f

30:28.580 --> 30:29.580
又变成了一个什么

30:29.580 --> 30:31.580
又变成了一个函数

30:31.580 --> 30:32.580
又变成一个函数

30:32.580 --> 30:33.580
它输出什么

30:33.580 --> 30:34.580
输出b

30:34.580 --> 30:35.580
好 接下来

30:35.580 --> 30:36.580
还调用这个函数

30:36.580 --> 30:37.580
调用的是哪个函数

30:37.580 --> 30:38.580
是不是这个函数

30:39.580 --> 30:40.580
这个函数输出啥

30:40.580 --> 30:41.580
输出b

30:41.580 --> 30:42.580
这里呢

30:42.580 --> 30:43.580
第一行输出完了过后

30:43.580 --> 30:44.580
第二行输出b

30:45.580 --> 30:46.580
好 接下来

30:46.580 --> 30:48.580
继续又定义了一个函数

30:48.580 --> 30:50.580
这个函数定义还有效啊

30:50.580 --> 30:51.580
没用了

30:51.580 --> 30:52.580
因为之前这个函数

30:52.580 --> 30:53.580
是不是已经没提过去了

30:53.580 --> 30:54.580
提到上下文里边去了

30:54.580 --> 30:55.580
提过了过后

30:55.580 --> 30:57.580
因为它是函数声明

30:57.580 --> 30:58.580
你可以这样简单理解

30:58.580 --> 30:59.580
函数声明

30:59.580 --> 31:00.580
把在函数里边

31:00.580 --> 31:01.580
出现的函数声明

31:01.580 --> 31:02.580
它之前提到过

31:02.580 --> 31:04.580
提到那个执行上下文之后

31:05.580 --> 31:07.580
之后就不再管它了

31:08.580 --> 31:09.580
所以说后边调用这个负

31:09.580 --> 31:10.580
是不是还是这个函数

31:11.580 --> 31:12.580
因此呢 这里

31:12.580 --> 31:13.580
第二次还是输出b

31:14.580 --> 31:15.580
所以这个最后的输出呢

31:15.580 --> 31:17.580
就是一开始输出一个函数

31:17.580 --> 31:18.580
然后输出b

31:18.580 --> 31:19.580
输出b

31:19.580 --> 31:20.580
好 看一下吧

31:21.580 --> 31:22.580
对吧 是不是没问题

31:23.580 --> 31:24.580
好 这就是

31:25.580 --> 31:26.580
执行上下文

31:26.580 --> 31:28.580
它可能会出现了这种

31:28.580 --> 31:29.580
考点

31:29.580 --> 31:30.580
那么像我这里呢

31:30.580 --> 31:31.580
想到一个事啊

31:31.580 --> 31:33.580
我在多些年代吧

31:33.580 --> 31:34.580
比方说

31:34.580 --> 31:35.580
这里再来一个

31:36.580 --> 31:37.580
再来一个

31:37.580 --> 31:44.540
这种写法的

31:45.540 --> 31:49.010
我有简单举个例子

31:49.010 --> 31:52.770
或者简单下几个例子

31:52.770 --> 31:54.770
我们这里输出b

31:55.770 --> 31:56.770
那么会输出什么呢

31:58.770 --> 31:59.770
大家都知道对吧

31:59.770 --> 32:00.770
输出的肯定是一个函数

32:01.770 --> 32:02.770
关键是b

32:02.770 --> 32:03.770
b输出的是数字2

32:04.770 --> 32:05.770
还是这个函数呢

32:06.770 --> 32:08.770
这里我把这个问题说清楚

32:09.770 --> 32:10.770
输出什么

32:10.770 --> 32:11.770
大家应该都知道

32:11.770 --> 32:12.770
对吧

32:12.770 --> 32:13.770
因为你就算不知道

32:13.770 --> 32:14.770
执行上下文应

32:14.770 --> 32:15.770
应该知道

32:15.770 --> 32:17.770
歪成的访问不了里程的东西

32:17.770 --> 32:18.770
对不对

32:18.770 --> 32:19.770
所以说输出的是2

32:19.770 --> 32:21.770
那么它是怎么理解的呢

32:21.770 --> 32:22.770
它是这样啊

32:22.770 --> 32:24.770
我们确定这个m函数的

32:24.770 --> 32:26.770
执行上下文的时候

32:26.770 --> 32:27.770
它不会管

32:27.770 --> 32:28.770
它指函数里边

32:28.770 --> 32:30.770
千套的函数生命不会管

32:30.770 --> 32:31.770
它只会管

32:31.770 --> 32:33.770
直接在m函数里边

32:33.770 --> 32:34.770
生命的函数

32:34.770 --> 32:35.770
像这种

32:35.770 --> 32:36.770
它不会管里边

32:36.770 --> 32:37.770
千套的东西

32:37.770 --> 32:38.770
这个我给大家说明一下

32:38.770 --> 32:39.770
就行了

32:39.770 --> 32:40.770
好 那么这里呢

32:41.770 --> 32:42.770
这个地方给大家说明一下

32:42.770 --> 32:43.770
然后接下来呢

32:43.770 --> 32:44.770
我给大家说一下

32:44.770 --> 32:45.770
关于这个AO

32:46.770 --> 32:47.770
因为有的时候呢

32:47.770 --> 32:49.770
你在一些网站上啊

32:49.770 --> 32:50.770
或者是一些别的教程

32:50.770 --> 32:51.770
或者是视频里边

32:51.770 --> 32:52.770
你会发现呢

32:53.770 --> 32:54.770
每个老师呢

32:54.770 --> 32:55.770
说这个地方呢

32:55.770 --> 32:56.770
说的名字不一样啊

32:56.770 --> 32:57.770
有的叫了VO

32:58.770 --> 32:59.770
有的叫GO

33:00.770 --> 33:01.770
有的叫AO

33:02.770 --> 33:03.770
就是它的名字

33:03.770 --> 33:04.770
就执行上下文里边

33:04.770 --> 33:05.770
这个对象的名字

33:05.770 --> 33:07.770
那么它这几个东西

33:07.770 --> 33:08.770
到底有什么区别呢

33:09.770 --> 33:10.770
本质上

33:10.770 --> 33:12.770
它们没有什么区别

33:13.770 --> 33:14.770
它有的时候就叫AO

33:14.770 --> 33:15.770
有的时候叫GO

33:15.770 --> 33:17.770
有的时候叫VO

33:18.770 --> 33:19.770
我这里说一下啊

33:19.770 --> 33:20.770
什么时候

33:20.770 --> 33:21.770
都指的是这个位向啊

33:22.770 --> 33:23.770
本质上没有什么区别

33:23.770 --> 33:24.770
什么时候

33:24.770 --> 33:25.770
我们把它叫做AO

33:26.770 --> 33:27.770
如果说这个函数

33:27.770 --> 33:29.770
正在执行中

33:29.770 --> 33:30.770
又正在调用它

33:31.770 --> 33:32.770
那么我就把这个对象

33:32.770 --> 33:33.770
叫AO

33:34.770 --> 33:36.770
如果说这个上下文

33:36.770 --> 33:39.770
对象是全局的执行上下文

33:41.770 --> 33:42.770
这里有个特殊情况

33:42.770 --> 33:45.770
就是不仅函数有执行上下文

33:45.770 --> 33:46.770
你调用函数的时候

33:46.770 --> 33:47.770
它又会产生执行上下文

33:48.770 --> 33:50.770
还有的时候你没有调用函数

33:50.770 --> 33:51.770
比较像这种情况

33:51.770 --> 33:52.770
没有函数

33:53.770 --> 33:57.770
我只知道你来一个A等于E

33:58.770 --> 33:59.770
那你说这个地方

33:59.770 --> 34:00.770
有没有变量提升吗

34:01.770 --> 34:02.770
肯定有啊

34:02.770 --> 34:03.770
我们对于学校那么久的企业师了

34:03.770 --> 34:04.770
对吧

34:04.770 --> 34:05.770
肯定有变量提升

34:05.770 --> 34:06.770
得到的是NG派的

34:06.770 --> 34:07.770
那为什么呢

34:08.770 --> 34:09.770
没有函数

34:09.770 --> 34:10.770
要不要执行这个代码

34:10.770 --> 34:12.770
要执行代码

34:12.770 --> 34:14.770
它就必须要准备好执行上下文

34:14.770 --> 34:16.770
那么这个地方既然没有

34:16.770 --> 34:17.770
它不在函数里边

34:17.770 --> 34:18.770
它这执行上下文是什么呢

34:18.770 --> 34:19.770
我们把它称之为一个

34:19.770 --> 34:20.770
特殊的执行上下文

34:20.770 --> 34:23.770
叫全局执行上下文

34:23.770 --> 34:25.770
那么这个全局执行上下文

34:25.770 --> 34:27.770
就叫做GO

34:28.770 --> 34:29.770
它也叫

34:29.770 --> 34:30.770
执行上下文

34:30.770 --> 34:31.770
里边的这个东西

34:31.770 --> 34:32.770
就叫做GO

34:32.770 --> 34:33.770
懂了意思吧

34:33.770 --> 34:34.770
就什么意思

34:34.770 --> 34:36.770
它只是不同的名字

34:36.770 --> 34:37.770
不同的教法

34:37.770 --> 34:38.770
因为

34:38.770 --> 34:39.770
你可以这样想象

34:39.770 --> 34:40.770
它一开始执行这个

34:40.770 --> 34:41.770
企业师代码的时候

34:41.770 --> 34:43.770
它就必须要准备好一个

34:43.770 --> 34:44.770
上下文

34:44.770 --> 34:45.770
这就叫做全局上下文

34:45.770 --> 34:47.770
同样做的事情

34:47.770 --> 34:48.770
同样是一样的

34:48.770 --> 34:49.770
比方说我来这里

34:49.770 --> 34:52.340
定义了一个函数

34:52.340 --> 34:53.340
你看

34:53.340 --> 34:55.340
这里得到的就是函数了

34:55.340 --> 34:56.340
为什么呢

34:56.340 --> 34:57.340
你看吧

34:57.340 --> 34:58.340
一样的道理

34:58.340 --> 34:59.340
你看

34:59.340 --> 35:00.340
它现在就是准备了

35:00.340 --> 35:01.340
全局上下文

35:01.340 --> 35:02.340
GO

35:02.340 --> 35:03.340
一开始确定

35:03.340 --> 35:04.340
当然全局上下文

35:04.340 --> 35:05.340
是不存在的参数的

35:05.340 --> 35:06.340
所以说

35:06.340 --> 35:07.340
参数不用管

35:07.340 --> 35:08.340
然后呢

35:08.340 --> 35:09.340
第二步

35:09.340 --> 35:10.340
直接进入到第二步

35:10.340 --> 35:11.340
第二步做什么

35:11.340 --> 35:12.340
提取函数声明

35:12.340 --> 35:13.340
是不是提取了一个A

35:13.340 --> 35:15.340
然后第三步

35:15.340 --> 35:16.340
提取变量

35:16.340 --> 35:17.340
A变量

35:17.340 --> 35:18.340
已经发现同名了

35:18.340 --> 35:19.340
所谓说

35:19.340 --> 35:20.340
这里不动

35:20.340 --> 35:21.340
忽略

35:21.340 --> 35:22.340
因此这里输出什么

35:22.340 --> 35:23.340
输出的就是

35:23.340 --> 35:25.340
这就是GO的意思

35:25.340 --> 35:27.340
还有这个是VO

35:27.340 --> 35:28.340
VO就是什么意思呢

35:28.340 --> 35:29.340
它既不是GO

35:29.340 --> 35:30.340
也不是当前

35:30.340 --> 35:32.340
正在执行的函数

35:32.340 --> 35:34.340
那么它就是VO

35:34.340 --> 35:35.340
那么这就是

35:35.340 --> 35:36.340
啥意思呢

35:36.340 --> 35:37.340
我再举个例子

35:37.340 --> 35:38.340
比方说就

35:38.340 --> 35:42.290
这种情况

35:42.290 --> 35:44.290
外面是一个A

35:44.290 --> 35:47.290
里边有一个B

35:47.290 --> 35:49.290
然后这里调用B

35:49.290 --> 35:51.290
然后这里去调用A

35:51.290 --> 35:53.290
咱们来吕吕

35:53.290 --> 35:54.290
产生了多少个

35:54.290 --> 35:55.290
执行上下文呢

35:55.290 --> 35:56.290
首先呢

35:56.290 --> 35:57.290
最歪一层

35:57.290 --> 35:58.290
是不是有一个

35:58.290 --> 35:59.290
全局的执行上下文

35:59.290 --> 36:00.290
GO

36:00.290 --> 36:01.290
对吧

36:01.290 --> 36:02.290
这里边有些东西

36:02.290 --> 36:03.290
有什么呢

36:03.290 --> 36:04.290
有FN

36:04.290 --> 36:05.290
好就没了

36:05.290 --> 36:06.290
然后接下来

36:06.290 --> 36:08.290
代码执行到21行的时候

36:08.290 --> 36:10.290
是不是又会产生A的执行上下文

36:10.290 --> 36:11.290
那么这个时候

36:11.290 --> 36:12.290
A的执行上下文是什么

36:12.290 --> 36:13.290
AO

36:13.290 --> 36:14.290
正在执行A

36:14.290 --> 36:15.290
对吧

36:15.290 --> 36:16.290
正在执行A

36:16.290 --> 36:17.290
那么执行A的时候

36:17.290 --> 36:18.290
A的上下文里边

36:18.290 --> 36:20.290
是不是会产生B的定义

36:20.290 --> 36:21.290
对吧

36:21.290 --> 36:22.290
B是一个函数

36:22.290 --> 36:23.290
好 没了

36:23.290 --> 36:24.290
然后呢

36:24.290 --> 36:27.290
运行到第18行的时候

36:27.290 --> 36:29.290
是不是又会产生B的上下文

36:29.290 --> 36:30.290
对不对

36:30.290 --> 36:32.290
虽然B里边别的东西

36:32.290 --> 36:33.290
但是B

36:33.290 --> 36:34.290
这些调用B

36:34.290 --> 36:35.290
它肯定会产生B的上下文

36:35.290 --> 36:36.290
那么这个时候

36:36.290 --> 36:38.290
就转而去执行B了

36:38.290 --> 36:39.290
它就没有执行A了

36:39.290 --> 36:41.290
A先暂停一下

36:41.290 --> 36:43.290
先把B执行完了再说

36:43.290 --> 36:44.290
A的上下文

36:44.290 --> 36:46.290
它名字就变了

36:46.290 --> 36:47.290
这个名字没有任何关系

36:47.290 --> 36:49.290
因为它不影响任何东西

36:49.290 --> 36:51.290
只是我们交法上就变了

36:51.290 --> 36:53.290
只是交法上变成没有了

36:53.290 --> 36:54.290
现在的AO呢

36:54.290 --> 36:56.290
就变成了这个B的执行上下文

36:56.290 --> 36:58.290
当然这个是空的东西

36:58.290 --> 36:59.290
就这么意思

36:59.290 --> 37:00.290
明白了吧

37:00.290 --> 37:01.290
所以说

37:01.290 --> 37:02.290
这个只是说法的不一样

37:02.290 --> 37:03.290
它本质上的东西

37:03.290 --> 37:05.290
都是一个意思

37:05.290 --> 37:07.290
这就是关于这个执行上下文

37:07.290 --> 37:08.290
好

37:08.290 --> 37:09.290
接下来我们来看一下

37:09.290 --> 37:11.290
这个第二题

37:14.290 --> 37:16.290
这一句是全局的

37:20.050 --> 37:22.050
好 看一下这第二题

37:22.050 --> 37:23.050
摆多了一道面试

37:23.050 --> 37:27.190
其实我们把执行

37:27.190 --> 37:28.190
执行上下文

37:28.190 --> 37:29.190
它整个姿势还是比较简单的

37:29.190 --> 37:30.190
搞清楚了之后

37:30.190 --> 37:32.190
这些题其实非常轻松的

37:32.190 --> 37:34.190
来看一下吧

37:34.190 --> 37:35.190
因为这里边

37:35.190 --> 37:36.190
它没有涉及到

37:36.190 --> 37:38.190
全局的执行上下文分析文

37:38.190 --> 37:39.190
就不分析全局了

37:39.190 --> 37:40.190
雕用这个没涉的

37:40.190 --> 37:41.190
只分析这个没涉的

37:41.190 --> 37:43.190
那么这个执行上下文

37:43.190 --> 37:45.190
里边有哪些东西呢

37:45.190 --> 37:46.190
首先第一步

37:46.190 --> 37:47.190
确定参数

37:47.190 --> 37:48.190
参数有三个

37:48.190 --> 37:50.190
A等于1

37:50.190 --> 37:53.190
B等于2

37:53.190 --> 37:55.190
C等于3

37:55.190 --> 37:57.190
然后接下来

37:57.190 --> 37:58.190
第二步

37:58.190 --> 37:59.190
做什么

37:59.190 --> 38:00.190
做函数声明的提取

38:00.190 --> 38:02.190
这里边有没有函数声明

38:02.190 --> 38:04.190
我们来看一下

38:04.190 --> 38:07.700
有多少个答案写出来了

38:07.700 --> 38:08.700
挺不错的

38:08.700 --> 38:10.700
这里边有没有函数声明

38:10.700 --> 38:17.820
一个都没有

38:17.820 --> 38:18.820
这个玩意叫啥

38:18.820 --> 38:20.820
叫函数表达式

38:20.820 --> 38:21.820
这个玩意叫啥

38:21.820 --> 38:23.820
叫函数表达式

38:23.820 --> 38:24.820
函数表达式

38:24.820 --> 38:25.820
函数表达式

38:25.820 --> 38:26.820
全都是函数表达式

38:26.820 --> 38:28.820
没有一个函数声明

38:28.820 --> 38:29.820
所以说第二步就没了

38:29.820 --> 38:30.820
就直接忽略了

38:30.820 --> 38:31.820
第三步

38:31.820 --> 38:32.820
提取变量

38:32.820 --> 38:33.820
有没有变量

38:33.820 --> 38:34.820
有变量

38:34.820 --> 38:35.820
几个变量

38:35.820 --> 38:36.820
两个变量

38:36.820 --> 38:37.820
定力变量

38:37.820 --> 38:38.820
A定力变量

38:38.820 --> 38:39.820
B

38:39.820 --> 38:40.820
对吧

38:40.820 --> 38:41.820
两个变量

38:41.820 --> 38:42.820
那么这两个变量

38:42.820 --> 38:43.820
A

38:44.820 --> 38:45.820
要变成undefined吗

38:45.820 --> 38:46.820
不变

38:46.820 --> 38:47.820
为什么

38:47.820 --> 38:48.820
A同名了

38:48.820 --> 38:49.820
变量同名了

38:49.820 --> 38:50.820
是不是执行商项目里

38:50.820 --> 38:51.820
已经有了

38:51.820 --> 38:52.820
因此出现了同名

38:52.820 --> 38:53.820
同名怎么麽

38:53.820 --> 38:55.820
独立

38:55.820 --> 38:56.820
所以说不动

38:56.820 --> 38:57.820
B呢

38:57.820 --> 38:58.820
是不是也有同名的

38:58.820 --> 39:00.820
独立

39:00.820 --> 39:01.820
好因此

39:01.820 --> 39:02.820
我们在第三行

39:02.820 --> 39:03.820
输出啥

39:03.820 --> 39:04.820
第三行

39:04.820 --> 39:05.820
输出

39:05.820 --> 39:06.820
1

39:06.820 --> 39:07.820
2

39:07.820 --> 39:08.820
3

39:08.820 --> 39:09.820
第三行

39:09.820 --> 39:10.820
就会输出这个

39:10.820 --> 39:11.820
好

39:11.820 --> 39:12.820
接下来第四行运行

39:12.820 --> 39:13.820
运行第四行

39:13.820 --> 39:15.820
是不是把这个A变了

39:15.820 --> 39:16.820
A就变成了啥

39:16.820 --> 39:18.820
变成了一个制服串了

39:18.820 --> 39:19.820
B变成了啥

39:19.820 --> 39:21.820
B变成了一个函数B了

39:21.820 --> 39:22.820
对吧

39:26.820 --> 39:28.820
变成一个函数B了

39:28.820 --> 39:29.820
好

39:29.820 --> 39:30.820
接下来

39:30.820 --> 39:31.820
关键是678行

39:31.820 --> 39:32.820
首先问大家

39:32.820 --> 39:33.820
第一个问题

39:33.820 --> 39:34.820
678行

39:34.820 --> 39:35.820
值不值行

39:36.820 --> 39:44.420
要不要值行

39:44.420 --> 39:45.420
要不要值行

39:45.420 --> 39:50.680
你们觉得

39:50.680 --> 39:51.680
要值行

39:51.680 --> 39:53.680
这里出现了表达式

39:53.680 --> 39:54.680
你不得算一下

39:54.680 --> 39:55.680
这个表达式是啥

39:55.680 --> 39:56.680
得算一下

39:56.680 --> 39:57.680
但是呢

39:57.680 --> 39:58.680
这个值行过了

39:58.680 --> 39:59.680
跟没值行是一样的

39:59.680 --> 40:00.680
为什麽呢

40:00.680 --> 40:01.680
你只有

40:01.680 --> 40:03.680
你就写了一个函数表达式

40:03.680 --> 40:04.680
然后呢

40:04.680 --> 40:05.680
没有函数了

40:05.680 --> 40:06.680
你又没有调用它

40:06.680 --> 40:07.680
对吧

40:07.680 --> 40:08.680
我们平时写立即值行函数

40:08.680 --> 40:09.680
是不是还在

40:09.680 --> 40:10.680
还在在后边写两个破号

40:10.680 --> 40:11.680
这才要调用

40:11.680 --> 40:12.680
对吧

40:12.680 --> 40:13.680
而且它调用过后

40:13.680 --> 40:14.680
也没有什麽影响

40:14.680 --> 40:15.680
所以说呢

40:15.680 --> 40:16.680
这些行

40:16.680 --> 40:17.680
要不要值行

40:17.680 --> 40:18.680
要值行

40:18.680 --> 40:19.680
它值行

40:19.680 --> 40:20.680
没有什麽影响

40:20.680 --> 40:22.680
由于它是函数表达式

40:22.680 --> 40:23.680
你给它写个ABC

40:23.680 --> 40:24.680
写不写名字

40:24.680 --> 40:25.680
它都是一样的

40:25.680 --> 40:27.680
它就用这个东西来干扰你

40:27.680 --> 40:28.680
它其实干扰的是什麽的

40:28.680 --> 40:29.680
它就

40:29.680 --> 40:30.680
看你

40:30.680 --> 40:31.680
会不会认为

40:31.680 --> 40:32.680
这个东西又会覆盖

40:32.680 --> 40:33.680
这里边东西

40:33.680 --> 40:34.680
不会

40:34.680 --> 40:35.680
不会

40:35.680 --> 40:36.680
因为它是一个表达式

40:36.680 --> 40:38.680
除非你定义变量

40:38.680 --> 40:39.680
那就不一样了

40:39.680 --> 40:40.680
你定义变量就不一样了

40:40.680 --> 40:41.680
比方说

40:41.680 --> 40:42.680
定一个变量

40:42.680 --> 40:43.680
就要复职

40:43.680 --> 40:44.680
那就不一样了

40:44.680 --> 40:45.680
但是你不是变量

40:45.680 --> 40:46.680
它是个函数表达式

40:46.680 --> 40:47.680
你写不写名字

40:47.680 --> 40:48.680
都是无所谓的

40:48.680 --> 40:49.680
所以说

40:49.680 --> 40:50.680
这三句话

40:50.680 --> 40:51.680
值不值行

40:51.680 --> 40:52.680
值行的就没值行

40:52.680 --> 40:53.680
是一样的

40:53.680 --> 40:54.680
就定了三个函数

40:54.680 --> 40:55.680
定了第一个函数

40:55.680 --> 40:56.680
定完就扔掉了

40:56.680 --> 40:57.680
定了第二个函数

40:57.680 --> 40:58.680
定完就扔掉了

40:58.680 --> 40:59.680
因为你又没有值行它

40:59.680 --> 41:00.680
对吧

41:00.680 --> 41:01.680
而且只是一个表达式

41:01.680 --> 41:02.680
表达式

41:02.680 --> 41:03.680
就相当于是

41:03.680 --> 41:04.680
你在这里写的一个1加1

41:04.680 --> 41:05.680
有什麽用吗

41:05.680 --> 41:06.680
以后这个玩意儿

41:06.680 --> 41:07.680
值不值行

41:07.680 --> 41:08.680
值行

41:08.680 --> 41:09.680
它算出来的2

41:09.680 --> 41:10.680
然后呢

41:10.680 --> 41:11.680
没有然后

41:11.680 --> 41:12.680
好

41:12.680 --> 41:13.680
所有这三句话

41:13.680 --> 41:14.680
值行

41:14.680 --> 41:15.680
但是无效果

41:15.680 --> 41:16.680
最后呢

41:16.680 --> 41:17.680
输出ABC

41:17.680 --> 41:18.680
得到的是什麽呢

41:18.680 --> 41:19.680
制服串A

41:19.680 --> 41:20.680
B

41:20.680 --> 41:23.820
方式B

41:23.820 --> 41:24.820
C

41:24.820 --> 41:26.820
这就是最终的结果

41:27.820 --> 41:28.820
那么做这种题

41:28.820 --> 41:29.820
注意好的方式

41:29.820 --> 41:30.820
因为这种

41:30.820 --> 41:32.820
执行商项文是很简单的

41:32.820 --> 41:33.820
不复杂吧

41:33.820 --> 41:34.820
同学们听到现在不复杂

41:35.820 --> 41:36.820
就这麽三步

41:36.820 --> 41:37.820
一二三

41:37.820 --> 41:38.820
就可以确定执行商项文了

41:38.820 --> 41:39.820
说这种题呢

41:39.820 --> 41:40.820
一定要小心啊

41:40.820 --> 41:41.820
你画一个图

41:41.820 --> 41:42.820
或者拿出炒告纸

41:43.820 --> 41:44.820
到时候呢

41:44.820 --> 41:45.820
是在那个

41:45.820 --> 41:46.820
电脑上做的

41:46.820 --> 41:47.820
所以说你可以打开个鸡翅板

41:47.820 --> 41:48.820
像我这样子

41:48.820 --> 41:49.820
画一画

41:49.820 --> 41:50.820
对吧 写一些

41:50.820 --> 41:51.820
记录一下那是保证

41:51.820 --> 41:52.820
没有任何问题的

41:52.820 --> 41:53.820
好

41:53.820 --> 41:55.820
然后看一下第三题

41:55.820 --> 41:56.820
在这

41:56.820 --> 42:01.220
看一下这道题

42:01.220 --> 42:02.220
这道题呢

42:02.220 --> 42:03.220
它连着这个

42:03.220 --> 42:07.110
奥比名词一起来考

42:07.110 --> 42:08.110
一样的道理啊

42:08.110 --> 42:09.110
同学们也可以分析啊

42:09.110 --> 42:10.110
也可以跟

42:10.110 --> 42:11.110
跟着我的思路来分析

42:11.110 --> 42:12.110
它调用了两次

42:12.110 --> 42:13.110
那没关系啊

42:13.110 --> 42:15.110
我就看第一次呢

42:15.110 --> 42:16.110
调用第一次

42:16.110 --> 42:17.110
第一次

42:17.110 --> 42:18.110
中国不得产生

42:18.110 --> 42:19.110
一个执行商项文吗

42:19.110 --> 42:21.110
第一次产生执行商项文

42:21.110 --> 42:22.110
第一步做什么

42:22.110 --> 42:23.110
提取参数

42:23.110 --> 42:24.110
参数有几个

42:24.110 --> 42:25.110
两个

42:25.110 --> 42:26.110
A等于解

42:26.110 --> 42:27.110
等于B

42:27.110 --> 42:28.110
B等于解啊

42:28.110 --> 42:30.110
是不是没传啊

42:30.110 --> 42:31.110
没传

42:31.110 --> 42:32.110
但是它写的寻常的

42:32.110 --> 42:33.110
对吧

42:33.110 --> 42:34.110
没有传

42:34.110 --> 42:35.110
没有传是什么呀

42:35.110 --> 42:36.110
Undefend

42:36.110 --> 42:37.110
那么这里猶豫

42:37.110 --> 42:38.110
它用到了Orcumence

42:38.110 --> 42:40.110
那么这个Orcumence

42:40.110 --> 42:42.490
这里就是

42:42.490 --> 42:43.490
一个指示了

42:43.490 --> 42:44.490
请问这个Orcumence

42:44.490 --> 42:46.490
有几项

42:47.490 --> 42:52.460
那我单独来看一个吧

42:52.460 --> 42:54.460
这里有个函数

42:56.460 --> 42:57.460
M吧

42:57.460 --> 43:00.780
AB

43:00.780 --> 43:01.780
那么这里输出AB

43:01.780 --> 43:05.280
和Orcumence

43:05.280 --> 43:08.280
Orcumence

43:08.280 --> 43:13.260
然后调用M的时候

43:13.260 --> 43:14.260
我只传了一个E

43:14.260 --> 43:15.260
那么请问

43:15.260 --> 43:20.550
这个Orcumence有几项

43:20.550 --> 43:21.550
是一个

43:21.550 --> 43:22.550
运行员

43:23.550 --> 43:24.550
是不是只有一个

43:25.550 --> 43:27.550
那么问题又来了

43:28.550 --> 43:31.550
那么现在我只传了一个参数E

43:32.550 --> 43:34.550
那如果说我传两个参数呢

43:34.550 --> 43:36.550
第二参数传Undefend呢

43:36.550 --> 43:38.550
Orcumence有几项

43:38.550 --> 43:40.550
这种情况有几项呢

43:40.550 --> 43:44.250
什么两项

43:44.250 --> 43:45.250
它是不一样的

43:45.250 --> 43:46.250
虽然说

43:46.250 --> 43:47.250
第二参数B都是Undefend的

43:47.250 --> 43:48.250
你传不传

43:48.250 --> 43:49.250
不传也是Undefend的

43:49.250 --> 43:50.250
B不是Undefend的

43:50.250 --> 43:51.250
但是

43:51.250 --> 43:52.250
它是不一样的

43:52.250 --> 43:54.250
现在Orcumence就有两项了

43:54.250 --> 43:56.250
如果说你只传了一个参数

43:56.250 --> 43:58.250
那么我们来看一下

43:59.250 --> 44:00.250
我们改动B

44:00.250 --> 44:02.250
比方说我把B负责为2

44:02.250 --> 44:04.250
对Orcumence有影响吗

44:04.250 --> 44:06.250
是不是没有影响

44:06.250 --> 44:09.250
如果说你只传了一个参数的话

44:09.250 --> 44:11.250
那么目前是这个样子的

44:11.250 --> 44:12.250
你只传了一个参数

44:12.250 --> 44:14.250
它的E是什么呢

44:14.250 --> 44:16.250
B是什么

44:16.250 --> 44:18.250
是Undefend

44:19.250 --> 44:20.250
Orcumence就是什么

44:20.250 --> 44:22.250
我就这样的写了

44:22.250 --> 44:23.250
简单一点

44:23.250 --> 44:24.250
只有一项

44:24.250 --> 44:25.250
因此呢

44:25.250 --> 44:27.250
这个地方

44:27.250 --> 44:29.250
跟这个地方关联在一起的

44:29.250 --> 44:30.250
但是B

44:30.250 --> 44:32.250
是不是就没有关联

44:32.250 --> 44:33.250
因此你后边改B

44:33.250 --> 44:35.250
对Orcumence是没有影响的

44:35.250 --> 44:37.250
这是有区别的

44:37.250 --> 44:44.080
我们再回过头来看这儿

44:44.080 --> 44:45.080
刚才我们确定了参数

44:45.080 --> 44:47.080
参数S1

44:47.080 --> 44:48.080
就是这里

44:48.080 --> 44:49.080
第九行调用

44:49.080 --> 44:50.080
S1 B是什么

44:50.080 --> 44:51.080
Undefend

44:51.080 --> 44:52.080
Orcumence是几项吗

44:52.080 --> 44:53.080
一项

44:54.080 --> 44:55.080
第二步

44:55.080 --> 44:56.080
提取什么

44:56.080 --> 44:57.080
提取函数声明

44:57.080 --> 44:59.080
有没有函数声明

44:59.080 --> 45:00.080
有

45:00.080 --> 45:02.080
这个玩意不就是函数声明吗

45:02.080 --> 45:04.080
这个玩意有函数声明

45:04.080 --> 45:05.080
做什么

45:05.080 --> 45:06.080
提取

45:06.080 --> 45:07.080
函数声明

45:07.080 --> 45:08.080
遇到同名

45:08.080 --> 45:09.080
覆盖

45:09.080 --> 45:10.080
变成了什么

45:10.080 --> 45:11.080
Fn

45:11.080 --> 45:13.080
B变成了一个函数

45:13.080 --> 45:14.080
第三步

45:14.080 --> 45:15.080
提取变量

45:15.080 --> 45:16.080
有没有变量

45:16.080 --> 45:17.080
只有一个变量

45:17.080 --> 45:18.080
但是变量

45:18.080 --> 45:19.080
已经有存在同名的

45:19.080 --> 45:20.080
变量存在

45:20.080 --> 45:21.080
冲突

45:22.080 --> 45:24.080
这里边就这三个东西

45:24.080 --> 45:26.080
我们来看第三行

45:26.080 --> 45:27.080
做什么事情

45:27.080 --> 45:28.080
第一项加加

45:28.080 --> 45:29.080
它变成了2

45:29.080 --> 45:30.080
对吧

45:30.080 --> 45:31.080
由于它跟它

45:31.080 --> 45:32.080
是不是绑定在一起的

45:32.080 --> 45:34.080
所以说它也会变成2

45:35.080 --> 45:36.080
好

45:36.080 --> 45:37.080
然后我们这里输出AB

45:37.080 --> 45:38.080
输出啥

45:38.080 --> 45:39.080
输出了

45:40.080 --> 45:41.080
AB是2

45:41.080 --> 45:42.080
和一个函数

45:44.080 --> 45:45.080
对不对

45:45.080 --> 45:46.080
这一行输出结果

45:46.080 --> 45:47.080
好

45:47.080 --> 45:48.080
第五行

45:48.080 --> 45:49.080
又把A又变成了一个什么

45:49.080 --> 45:51.080
又把A又变成了一个函数

45:52.080 --> 45:53.080
注意啊

45:53.080 --> 45:54.080
A变成函数

45:54.080 --> 45:55.080
因为A跟它是绑定在一起的

45:55.080 --> 45:57.080
所以说它是不是也变成了函数

45:58.080 --> 45:59.080
对不对

45:59.080 --> 46:00.080
好

46:00.080 --> 46:01.080
然后我们输出什么

46:01.080 --> 46:02.080
这一项

46:02.080 --> 46:03.080
跟A是不是一样的

46:03.080 --> 46:04.080
那肯定是一样的

46:04.080 --> 46:05.080
它们是绑定在一起的

46:05.080 --> 46:06.080
这一项

46:06.080 --> 46:07.080
跟这个A是不是一样的

46:07.080 --> 46:08.080
那就肯定是一样的

46:09.080 --> 46:11.080
那么这第二项

46:11.080 --> 46:12.080
奥克里面的第二项

46:12.080 --> 46:13.080
第二项有东西吗

46:13.080 --> 46:14.080
没有东西

46:14.080 --> 46:15.080
第二项是什么

46:17.080 --> 46:18.080
跟B

46:18.080 --> 46:19.080
是不是一样的

46:19.080 --> 46:20.080
那肯定不一样

46:20.080 --> 46:21.080
所以说第二项是Force

46:21.080 --> 46:23.080
这就是前两行的输出

46:23.080 --> 46:24.080
对吧

46:24.080 --> 46:25.080
那么这个函数又执行完了

46:25.080 --> 46:26.080
执行完了过后

46:26.080 --> 46:28.080
这个函数执行完了就没了

46:28.080 --> 46:29.080
消费

46:29.080 --> 46:30.080
好

46:30.080 --> 46:31.080
下一次又调用这个函数

46:31.080 --> 46:33.080
那又从头来一遍

46:33.080 --> 46:34.080
又来创建执行完了文

46:34.080 --> 46:35.080
又来走一遍

46:35.080 --> 46:37.080
首先确定参数

46:37.080 --> 46:41.420
这个Opiment

46:41.420 --> 46:42.420
传了几个参数

46:42.420 --> 46:43.420
两个

46:43.420 --> 46:45.420
E和AndyFant

46:45.420 --> 46:46.420
A的值是什么

46:46.420 --> 46:47.420
B

46:47.420 --> 46:48.420
B的值呢

46:48.420 --> 46:49.420
是AndyFant

46:50.420 --> 46:51.420
变成这样子了

46:51.420 --> 46:52.420
好

46:52.420 --> 46:53.420
那么现在就绑定了

46:53.420 --> 46:54.420
A

46:54.420 --> 46:55.420
这个东西跟这个东西绑定

46:55.420 --> 46:57.420
这个东西跟这个东西绑定

46:57.420 --> 46:58.420
绑定起了

46:58.420 --> 46:59.420
然后第二步

46:59.420 --> 47:00.420
第二步做什么呢

47:00.420 --> 47:01.420
提取函数声明

47:01.420 --> 47:03.420
B是不是变成函数了

47:03.420 --> 47:04.420
变成函数了

47:04.420 --> 47:05.420
那B变成函数

47:05.420 --> 47:07.420
这个玩意不得也变成函数吗

47:07.420 --> 47:09.420
绑定在一起的呀

47:09.420 --> 47:10.420
好

47:10.420 --> 47:12.420
第三步提取变量

47:12.420 --> 47:13.420
有同名

47:13.420 --> 47:14.420
对吧

47:14.420 --> 47:15.420
忽略

47:15.420 --> 47:16.420
好

47:16.420 --> 47:17.420
又来

47:17.420 --> 47:18.420
第一步

47:18.420 --> 47:19.420
把第一项加1

47:19.420 --> 47:20.420
这个没问题

47:20.420 --> 47:21.420
它加1

47:21.420 --> 47:22.420
它变成了2

47:22.420 --> 47:23.420
没问题吧

47:23.420 --> 47:24.420
好

47:24.420 --> 47:25.420
说了

47:25.420 --> 47:26.420
这里加1过后输出A和B

47:26.420 --> 47:27.420
简单的

47:27.420 --> 47:28.420
是说2

47:28.420 --> 47:29.420
和Fn

47:29.420 --> 47:30.420
是吧

47:30.420 --> 47:31.420
跟之前是一样的

47:31.420 --> 47:32.420
好

47:32.420 --> 47:33.420
接下来

47:33.420 --> 47:34.420
把A又变成函数

47:34.420 --> 47:35.420
那是一样的呀

47:35.420 --> 47:36.420
它变成函数过后

47:36.420 --> 47:38.420
它不得也变成函数吗

47:38.420 --> 47:39.420
好

47:39.420 --> 47:40.420
然后输出

47:40.420 --> 47:41.420
这一项是不是等于A

47:41.420 --> 47:42.420
这一项是不是等于A

47:42.420 --> 47:43.420
它肯定等于

47:43.420 --> 47:44.420
绑定在一起的

47:44.420 --> 47:45.420
所以说输出数

47:45.420 --> 47:46.420
那么

47:46.420 --> 47:47.420
然后

47:47.420 --> 47:48.420
第二项是不是等于B

47:48.420 --> 47:49.420
那肯定是等于B

47:49.420 --> 47:50.420
它

47:50.420 --> 47:51.420
和它是不是一样的

47:51.420 --> 47:53.420
输出数

47:53.420 --> 47:54.420
对吧

47:54.420 --> 47:55.420
虽然说

47:55.420 --> 47:56.420
看上去

47:56.420 --> 47:57.420
没有传第二个参数

47:57.420 --> 47:58.420
和传一个ND

47:58.420 --> 47:59.420
但看上去好像是一样的

47:59.420 --> 48:00.420
但是

48:00.420 --> 48:01.420
影响的结果

48:01.420 --> 48:02.420
是不一样的

48:03.420 --> 48:04.420
来

48:04.420 --> 48:05.420
来不去知道

48:05.420 --> 48:06.420
这倒是一个解法

48:06.420 --> 48:07.420
那这大成本联系

48:07.420 --> 48:08.420
也就这样嘛

48:08.420 --> 48:09.420
对吧

48:09.420 --> 48:10.420
也没有多恐怖

48:10.420 --> 48:12.420
利用执行上下文的主持人

48:12.420 --> 48:13.420
也可以轻松的

48:13.420 --> 48:14.420
把它解出来

48:14.420 --> 48:15.420
好

48:15.420 --> 48:16.420
都是执行上下文的主持人

48:16.420 --> 48:17.420
大家可以下来之后

48:17.420 --> 48:18.420
在群里边

48:18.420 --> 48:19.420
可以互相

48:19.420 --> 48:20.420
想一些题

48:20.420 --> 48:21.420
给同学互相问一问

48:21.420 --> 48:22.420
或者是往上去

48:22.420 --> 48:23.420
你觉得

48:23.420 --> 48:24.420
找一些题

48:24.420 --> 48:25.420
想问一问

48:25.420 --> 48:26.420
执行上下文

48:26.420 --> 48:27.420
按照这种分析

48:27.420 --> 48:28.420
那就OK了

48:28.420 --> 48:30.980
就可以把解出来

48:30.980 --> 48:31.980
好

48:31.980 --> 48:32.980
这是

48:32.980 --> 48:33.980
咱们第一部分

48:33.980 --> 48:37.130
叫执行上下文

48:37.130 --> 48:38.130
看一下

48:38.130 --> 48:39.130
同学们

48:39.130 --> 48:40.130
有什么问题没有

48:40.130 --> 48:43.270
没问题了

48:43.270 --> 48:44.270
Q和E

48:44.270 --> 48:48.440
有问题的话

48:48.440 --> 48:49.440
打出你的问题

48:49.440 --> 48:50.440
听懂就好

48:50.440 --> 48:51.440
等于没有收获就好

48:51.440 --> 48:52.440
好

48:52.440 --> 48:53.440
咱们来看一下

48:53.440 --> 48:54.440
第二部分

48:54.440 --> 48:55.440
作用预念

48:56.440 --> 48:57.440
这一块

48:58.440 --> 49:01.440
其实它这个姿势挺简单的

49:02.440 --> 49:03.440
你搞清楚

49:03.440 --> 49:04.440
执行上下文的话

49:04.440 --> 49:05.440
你就很容易搞清楚

49:05.440 --> 49:06.440
作用预念

49:07.440 --> 49:08.440
因为

49:08.440 --> 49:09.440
同学们对必包招来招去

49:09.440 --> 49:10.440
招不清楚

49:10.440 --> 49:11.440
其实

49:11.440 --> 49:12.440
很多时候

49:12.440 --> 49:14.440
并不是必包本身的问题

49:14.440 --> 49:16.440
是因为程序逻辑

49:16.440 --> 49:18.440
有的时候反映不过来

49:18.440 --> 49:19.440
没有见过一些

49:19.440 --> 49:20.440
复杂的代码

49:20.440 --> 49:21.440
就是必包本身

49:21.440 --> 49:22.440
没有什么问题

49:23.440 --> 49:25.440
作用预念是什么玩意儿呢

49:25.440 --> 49:27.440
它其实就是EC

49:27.440 --> 49:28.440
形成的链条

49:28.440 --> 49:29.440
EC是啥东西

49:30.440 --> 49:32.440
exclusion context

49:32.440 --> 49:33.440
是不是就刚才我们讲

49:33.440 --> 49:34.440
这个执行上下文

49:35.440 --> 49:36.440
是不是就是那个玩意儿

49:36.440 --> 49:37.440
就是那个对象

49:37.440 --> 49:38.440
那个对象里面

49:38.440 --> 49:39.440
我们只研究了什么

49:39.440 --> 49:40.440
只研究了这个LO

49:40.440 --> 49:41.440
对吧

49:41.440 --> 49:43.440
就是这个玩意儿形成的链条

49:44.440 --> 49:46.440
那么这个链条怎么产生的呢

49:46.440 --> 49:48.440
当函数定义的时候

49:48.440 --> 49:49.440
这个链条就会产生

49:49.440 --> 49:51.440
所以说它的时间点

49:52.440 --> 49:54.440
作用预念出现的时间点

49:54.440 --> 49:55.440
是什么时间点

49:55.440 --> 49:57.440
是函数定义的时间点

49:57.440 --> 49:59.440
我们之前的执行上下文的时间点

49:59.440 --> 50:00.440
是什么

50:00.440 --> 50:02.440
是函数调用的时间点

50:03.440 --> 50:05.440
那一通就开始云了

50:05.440 --> 50:06.440
啥意思

50:07.440 --> 50:08.440
你不论说这个作用预念

50:08.440 --> 50:10.440
就是执行上下文的链条吧

50:10.440 --> 50:12.440
那执行上下文是要调用的时候

50:12.440 --> 50:13.440
才有

50:14.440 --> 50:15.440
那你为什么说函数定义的时候

50:15.440 --> 50:16.440
就有了呢

50:17.440 --> 50:19.440
咱们看下面这个例子

50:19.440 --> 50:23.940
这个例子就很容易理解了

50:24.940 --> 50:26.940
这是一段介石代码

50:27.940 --> 50:28.940
这段代码在干嘛呀

50:28.940 --> 50:30.940
在这里边有定义点量

50:30.940 --> 50:31.940
有定义函数

50:31.940 --> 50:33.940
我首先请问同学们

50:33.940 --> 50:34.940
执行这个代码

50:34.940 --> 50:36.940
要不要产生上下文啊

50:37.940 --> 50:39.940
要不要那肯定得要啊

50:39.940 --> 50:40.940
必须得要啊

50:41.940 --> 50:42.940
产生什么产生

50:42.940 --> 50:43.940
产生什么产生上下文啊

50:43.940 --> 50:45.940
是不是全局上下文

50:46.940 --> 50:47.940
所以说我们介石一边的

50:47.940 --> 50:49.940
任何一行代码

50:49.940 --> 50:50.940
它没有上下文

50:50.940 --> 50:51.940
它直都执行不了

50:51.940 --> 50:52.940
根本就没法执行

50:54.940 --> 50:55.940
任何一个代码

50:55.940 --> 50:57.940
包括函数定义

50:57.940 --> 51:00.940
都必须要有执行上下文才行

51:00.940 --> 51:01.940
没有执行上下文

51:01.940 --> 51:03.940
你聊的不要跟我聊天

51:03.940 --> 51:04.940
没法执行

51:04.940 --> 51:05.940
就好必须说

51:05.940 --> 51:06.940
邓哥不穿衣服

51:06.940 --> 51:08.940
不带任何装备

51:08.940 --> 51:09.940
直接裸奔出去了

51:09.940 --> 51:10.940
可不可以呢

51:10.940 --> 51:11.940
他有那个担

51:12.940 --> 51:13.940
但是他不一定这样去做

51:13.940 --> 51:15.940
他永远不会去这样做

51:15.940 --> 51:16.940
任何代码都是这样子

51:16.940 --> 51:18.940
他没有准备好执行上下文

51:18.940 --> 51:19.940
他不会执行的

51:19.940 --> 51:20.940
所以说这代码

51:20.940 --> 51:21.940
肯定要在一个执行上下文

51:21.940 --> 51:22.940
那边执行

51:22.940 --> 51:23.940
那么就可以

51:23.940 --> 51:24.940
就好研究了

51:24.940 --> 51:25.940
所以说你执行

51:25.940 --> 51:27.940
这个代码A的时候

51:27.940 --> 51:31.770
它在哪个上下文里边执行的

51:31.770 --> 51:32.770
是不是全局

51:32.770 --> 51:33.770
上下文里边执行的

51:33.770 --> 51:34.770
你定义这个函数

51:34.770 --> 51:35.770
M1的时候

51:35.770 --> 51:37.770
在哪里定义的

51:37.770 --> 51:38.770
在全局的

51:38.770 --> 51:40.770
上下文里边定义的

51:40.770 --> 51:41.770
所以说

51:41.770 --> 51:43.770
这个函数在定义的时候

51:43.770 --> 51:45.770
它会形成一个链条

51:45.770 --> 51:47.770
什么链条呢

51:47.770 --> 51:49.770
M1的作用运电

51:49.770 --> 51:50.770
这个链条就是作用运电

51:50.770 --> 51:51.770
M1的作用运电

51:51.770 --> 51:53.770
什么时候产生的作用运电

51:53.770 --> 51:55.770
是在定义的时候

51:55.770 --> 51:56.770
一定要注意

51:56.770 --> 51:57.770
是在定义的时候

51:57.770 --> 51:58.770
不是在执行的时候

51:58.770 --> 51:59.770
你不执行它

51:59.770 --> 52:00.770
它也有

52:00.770 --> 52:02.770
在定义的时候

52:02.770 --> 52:03.770
它会产生一个链条

52:03.770 --> 52:05.770
这个链条指向谁呢

52:05.770 --> 52:08.770
指向它当前所在的上下文

52:08.770 --> 52:09.770
当前所在的哪个上下文

52:09.770 --> 52:11.770
是不是全局

52:11.770 --> 52:13.770
这不就是理清楚了吗

52:13.770 --> 52:14.770
对吧

52:14.770 --> 52:15.770
它哪个上下文里边定义的

52:15.770 --> 52:16.770
那么这个作用运电

52:16.770 --> 52:18.770
还是指向哪个上下文

52:18.770 --> 52:20.770
全局里边有的

52:20.770 --> 52:21.770
有这个A

52:21.770 --> 52:23.770
有那个M1

52:23.770 --> 52:24.770
M1的作用运电

52:24.770 --> 52:25.770
就指向这个上下文

52:25.770 --> 52:26.770
就这么简单

52:26.770 --> 52:27.770
那现在有M2吗

52:27.770 --> 52:28.770
现在没有啊

52:28.770 --> 52:29.770
因为都没有

52:29.770 --> 52:30.770
M2是要等到什么时候

52:30.770 --> 52:32.770
是要执行M1的时候才出来

52:32.770 --> 52:33.770
那么接下来

52:33.770 --> 52:34.770
调用M1

52:34.770 --> 52:35.770
那你想啊

52:35.770 --> 52:36.770
调用M1

52:36.770 --> 52:38.770
不得产生M1的执行上下文吗

52:38.770 --> 52:40.770
别产生吧

52:40.770 --> 52:43.770
那么调用M1的执行过程中

52:43.770 --> 52:44.770
执行到这

52:44.770 --> 52:47.080
是在定义什么

52:47.080 --> 52:49.080
定义M2

52:49.080 --> 52:51.080
M2还是在哪里定义的

52:51.080 --> 52:52.080
是不是在M1的执行上下文的

52:52.080 --> 52:54.080
执行过程中定义的

52:54.080 --> 52:55.080
就说M2的作用运电

52:55.080 --> 52:56.080
指向谁啊

52:56.080 --> 52:58.080
指向M1的执行上下文

52:58.080 --> 53:00.080
就这么简单

53:00.080 --> 53:02.080
它让这个函数在哪里定义的

53:02.080 --> 53:04.080
那么这个函数的作用运电

53:04.080 --> 53:08.080
它就指向哪个上下文

53:08.080 --> 53:09.080
就这么简单

53:09.080 --> 53:10.080
所以一定是

53:10.080 --> 53:13.080
看到定义的时候的位置

53:13.080 --> 53:14.080
那么这个作用运电

53:14.080 --> 53:15.080
它到底有什么用呢

53:15.080 --> 53:16.080
你看啊

53:16.080 --> 53:17.080
M2的作用运电

53:17.080 --> 53:19.080
指向M1的执行上下文

53:19.080 --> 53:21.080
因为它是在M1的执行过程中

53:21.080 --> 53:23.080
运行的过程中定义的嘛

53:23.080 --> 53:25.080
所以它指向M1的执行上下文

53:25.080 --> 53:27.080
然后M1这个函数

53:27.080 --> 53:29.080
它的作用运电是指向的权局的

53:29.080 --> 53:31.080
所以M2它就形成了这么一个链条

53:31.080 --> 53:32.080
对吧

53:32.080 --> 53:33.080
这一个链条

53:33.080 --> 53:34.080
这一个链条

53:34.080 --> 53:35.080
M2

53:35.080 --> 53:36.080
M1它只有一个

53:36.080 --> 53:37.080
就形成了这么一个东西

53:37.080 --> 53:39.080
这个形成的东西有什么用呢

53:39.080 --> 53:40.080
有啥用呢

53:40.080 --> 53:41.080
看下面这句话

53:41.080 --> 53:44.080
当你将来在运行这个函数的时候

53:44.080 --> 53:45.080
如果你需要的东西

53:45.080 --> 53:47.080
不在当前的执行上下文中

53:47.080 --> 53:49.080
就从函数绑定的作用运电中

53:49.080 --> 53:51.080
E4去寻造

53:51.080 --> 53:54.650
这是啥意思

53:54.650 --> 53:57.920
看到了

53:57.920 --> 53:59.920
这些同学们有些同学都应该明白了

53:59.920 --> 54:02.920
明白了这是啥意思

54:02.920 --> 54:04.920
这个E4银都快到嘴根了

54:04.920 --> 54:08.360
非常显而易言

54:08.360 --> 54:09.360
B等于2

54:09.360 --> 54:12.360
然后我这里定一个M2

54:12.360 --> 54:14.360
这里输出

54:14.360 --> 54:16.360
这里再定一个C等于3

54:16.360 --> 54:19.360
输出ABC

54:19.360 --> 54:22.360
然后我们这里调用M2

54:22.360 --> 54:24.360
调用M1

54:24.360 --> 54:25.360
就是这个单

54:25.360 --> 54:26.360
我们把这个负责一下

54:26.360 --> 54:28.360
把这个

54:28.360 --> 54:31.670
这个地方剪切一下

54:31.670 --> 54:33.670
就是刚才的例子是一样的

54:33.670 --> 54:34.670
那里看

54:34.670 --> 54:35.670
我们这里形成的链条就是

54:35.670 --> 54:37.670
M1它有没有作用运电

54:37.670 --> 54:38.670
有啊

54:38.670 --> 54:40.670
指向谁指向全局的

54:40.670 --> 54:41.670
M2有没有作用运电

54:41.670 --> 54:42.670
有啊

54:42.670 --> 54:43.670
它定义的时候就指向

54:43.670 --> 54:44.670
都得到了

54:44.670 --> 54:45.670
定义的时候指向谁

54:45.670 --> 54:47.670
指向M1的

54:47.670 --> 54:49.670
那里看吧

54:49.670 --> 54:51.670
我在调用M2的时候

54:51.670 --> 54:52.670
是不是要产生

54:52.670 --> 54:53.670
刚才学过的

54:53.670 --> 54:54.670
要产生M2的

54:54.670 --> 54:55.670
执行商杨文

54:55.670 --> 54:56.670
就要产生

54:56.670 --> 54:57.670
执行商杨文有啥东西

54:57.670 --> 54:58.670
那就一个C

54:58.670 --> 54:59.670
一个C ONG3的

54:59.670 --> 55:00.670
对吧

55:00.670 --> 55:01.670
你看吧

55:01.670 --> 55:02.670
没有参数也没有函数声明

55:02.670 --> 55:03.670
就这里边

55:03.670 --> 55:04.670
没有参数没有函数声明

55:04.670 --> 55:06.670
那只有一个C ONG3的

55:06.670 --> 55:07.670
然后就开始执行了

55:07.670 --> 55:08.670
执行到第五行

55:08.670 --> 55:09.670
第五行是不是把C

55:09.670 --> 55:10.670
变成了怎么3

55:10.670 --> 55:11.670
来吧

55:11.670 --> 55:14.670
现在我要输出ABC

55:14.670 --> 55:15.670
那C没问题吧

55:15.670 --> 55:17.670
C就是不是指向商杨文有3

55:17.670 --> 55:19.670
那AB咋办呢

55:19.670 --> 55:22.670
AB是不是执行商杨文那边没有

55:22.670 --> 55:23.670
没有怎么办

55:23.670 --> 55:25.670
按理说就应该抱错了

55:25.670 --> 55:26.670
说什么A没有定义

55:26.670 --> 55:27.670
B没有定义

55:27.670 --> 55:28.670
但是他不

55:28.670 --> 55:30.670
他要再做最后一把努力

55:30.670 --> 55:32.670
比方说

55:32.670 --> 55:33.670
承泽出去跑步

55:33.670 --> 55:35.670
突然忘了穿裤子

55:35.670 --> 55:37.670
这个时候他要做最后一把努力

55:37.670 --> 55:38.670
然后到处去找一找

55:38.670 --> 55:39.670
到邻居家

55:39.670 --> 55:40.670
或者是到城嫂家

55:40.670 --> 55:41.670
去找一找

55:41.670 --> 55:42.670
自己裤子里面拿着门

55:42.670 --> 55:43.670
对吧

55:43.670 --> 55:44.670
那么这就是

55:44.670 --> 55:45.670
到哪里去找

55:45.670 --> 55:46.670
到执行

55:46.670 --> 55:48.670
到他的作用语练去找

55:48.670 --> 55:49.670
首先找什么

55:49.670 --> 55:51.670
首先找他直接指向了

55:51.670 --> 55:53.670
M1的作用语练

55:53.670 --> 55:54.670
就执行商杨文

55:54.670 --> 55:56.670
M1里面有没有A

55:56.670 --> 55:57.670
没有

55:57.670 --> 55:59.670
有没有B

55:59.670 --> 56:00.670
B有

56:00.670 --> 56:01.670
那是不是把B找到了

56:01.670 --> 56:03.670
因此还就会输出

56:03.670 --> 56:05.670
2

56:05.670 --> 56:06.670
C是3

56:06.670 --> 56:07.670
B是2

56:07.670 --> 56:08.670
那A呢

56:08.670 --> 56:09.670
A怎么办呢

56:09.670 --> 56:11.670
那A还得往上面去去找

56:11.670 --> 56:12.670
就找到权力商杨文

56:12.670 --> 56:13.670
权权杨文有什么

56:13.670 --> 56:14.670
有这个A

56:14.670 --> 56:15.670
那么这里得到的A

56:15.670 --> 56:16.670
是不是就是这个A

56:16.670 --> 56:17.670
输出1 2 3

56:17.670 --> 56:19.670
当然这个结果

56:19.670 --> 56:20.670
大家都知道

56:20.670 --> 56:21.670
输出1 2 3

56:21.670 --> 56:22.670
但是这个过程

56:22.670 --> 56:23.670
可能不是

56:23.670 --> 56:24.670
每个种类都能理解

56:24.670 --> 56:25.670
他就是这么找的

56:25.670 --> 56:27.670
先找自己的执行商杨文

56:27.670 --> 56:29.670
再找作用语练

56:29.670 --> 56:32.110
懂不懂意思吗

56:32.110 --> 56:34.110
就这么简单

56:34.110 --> 56:36.110
你制造的那些

56:36.110 --> 56:38.110
就可以作题了

56:38.110 --> 56:39.110
来

56:39.110 --> 56:40.110
我们试一下

56:40.110 --> 56:48.130
作用语练的题目

56:48.130 --> 56:49.130
好

56:49.130 --> 56:51.630
看一下

56:51.630 --> 56:52.630
其实它的现象

56:52.630 --> 56:54.630
其实很简单

56:54.630 --> 56:55.630
你如果说

56:55.630 --> 56:56.630
不用那些图来解释的话

56:56.630 --> 56:58.630
也可以解释

56:58.630 --> 56:59.630
我们都知道

56:59.630 --> 57:00.630
众所周知

57:00.630 --> 57:02.630
结识语言里边

57:02.630 --> 57:03.630
是不是函数里边

57:03.630 --> 57:05.630
可以用外边的东西

57:05.630 --> 57:07.630
这个所有人都知道吗

57:07.630 --> 57:09.630
里边可以用外边的东西

57:09.630 --> 57:12.630
然后记住一点就行了

57:12.630 --> 57:14.630
用的是哪个外边的

57:14.630 --> 57:16.630
用的是定义的时候

57:16.630 --> 57:17.630
那个外边的

57:17.630 --> 57:19.630
这是就是非常粗略的理解

57:19.630 --> 57:21.630
严格的理解的话

57:21.630 --> 57:23.630
就是刚才我画了一个图

57:23.630 --> 57:26.630
严格的理解就是这个图

57:26.630 --> 57:27.630
粗略的理解就是这样子

57:27.630 --> 57:29.630
比方说我给大家举个例子

57:29.630 --> 57:31.630
这里有一个函数

57:31.630 --> 57:32.630
me

57:32.630 --> 57:34.630
这里边有个边量a

57:34.630 --> 57:36.630
然后我这边

57:36.630 --> 57:38.630
ml

57:38.630 --> 57:39.630
这里有函数ml

57:39.630 --> 57:41.630
这个函数里边把a加加

57:41.630 --> 57:43.630
然后输出a

57:43.630 --> 57:44.630
好

57:44.630 --> 57:46.630
然后这边我调用这个ml

57:46.630 --> 57:47.630
接下来

57:47.630 --> 57:49.630
我来这里定义一个a

57:49.630 --> 57:52.630
等于10

57:52.630 --> 57:54.630
我调用

57:54.630 --> 57:55.630
嗯

57:55.630 --> 57:57.630
我想想啊

57:57.630 --> 57:59.630
我怎么来

57:59.630 --> 58:00.630
这样吧

58:00.630 --> 58:02.630
我把这ml提出来啊

58:02.630 --> 58:06.520
提出来

58:06.520 --> 58:09.020
a加加

58:09.020 --> 58:15.980
我调用me

58:15.980 --> 58:18.980
a等于10

58:18.980 --> 58:19.980
好

58:19.980 --> 58:20.980
这个函数多少

58:20.980 --> 58:22.980
你告诉我它输出2还是11

58:22.980 --> 58:33.500
这2还是11啊

58:33.500 --> 58:35.500
有分歧了是吧

58:35.500 --> 58:36.500
再好好回忆一下

58:36.500 --> 58:38.500
我刚才不断的强调了这一点

58:38.500 --> 58:43.600
刚才不断的强调的是啥

58:43.600 --> 58:45.600
是啥呀

58:45.600 --> 58:50.450
作用与电产现在什么时候

58:50.450 --> 58:53.450
是定义的时候还是调用的时候

58:53.450 --> 58:56.450
是定义的时候

58:56.450 --> 58:58.450
那你去看一下定义的时候

58:58.450 --> 59:00.450
它用的是哪个a

59:00.450 --> 59:02.450
最简单的看法

59:02.450 --> 59:04.450
定义的时候用的是哪一个a

59:04.450 --> 59:05.450
是里边这个a

59:05.450 --> 59:06.450
还是外边这个a

59:06.450 --> 59:07.450
这个a

59:07.450 --> 59:09.450
它肯定是等于10这个a

59:09.450 --> 59:10.450
对吧

59:10.450 --> 59:12.450
定义的时候它的a

59:12.450 --> 59:13.450
就是这个a

59:13.450 --> 59:16.450
这个a将来会被复制成10

59:16.450 --> 59:18.450
所以说你甭管怎么绕

59:18.450 --> 59:20.450
绕了半天跑到去

59:20.450 --> 59:22.450
通过me去跑去明显ml

59:22.450 --> 59:24.450
ml会用这个a吗

59:24.450 --> 59:25.450
不会

59:25.450 --> 59:26.450
因为ml里边自己没有a

59:26.450 --> 59:27.450
它首先自己没有a啊

59:27.450 --> 59:28.450
潜力条件

59:28.450 --> 59:29.450
仔细上下文里边

59:29.450 --> 59:31.450
它自己的仔细上下文里边没有a

59:31.450 --> 59:33.450
所以它就会从作用与电互联去找

59:33.450 --> 59:34.450
它联在哪

59:34.450 --> 59:36.450
联在它定义的时候就确定下来了

59:36.450 --> 59:37.450
定义的时候是哪个a

59:37.450 --> 59:38.450
是这个a

59:38.450 --> 59:39.450
所以加了半天加的是谁

59:39.450 --> 59:40.450
加的是这个a

59:40.450 --> 59:41.450
输出11

59:42.450 --> 59:43.450
对吧

59:43.450 --> 59:45.450
所以说它这个地方一定要搞清楚

59:45.450 --> 59:46.450
就是你们

59:46.450 --> 59:48.450
这个天下你们都能理解

59:48.450 --> 59:50.450
这是一定要搞清楚

59:50.450 --> 59:52.450
在定义的时候确定的

59:52.450 --> 59:54.450
那么如果说我们画图

59:54.450 --> 59:56.450
如果说我们来

59:56.450 --> 59:58.450
画有指向图的话

59:58.450 --> 59:59.450
那怎么来画呢

59:59.450 --> 01:00:00.450
那你看啊

01:00:00.450 --> 01:00:02.450
我们一开始是一个仔细上下文的

01:00:02.450 --> 01:00:03.450
全局的对吧

01:00:03.450 --> 01:00:06.450
全局的里边不就不有一个a吗

01:00:06.450 --> 01:00:09.450
就是理解透了过了就不用画图了

01:00:09.450 --> 01:00:10.450
不有一个a吗

01:00:10.450 --> 01:00:12.450
然后呢到了第六行

01:00:12.450 --> 01:00:15.450
是不是定义定义这个函数m2

01:00:15.450 --> 01:00:17.450
那m2的链条指向谁啊

01:00:17.450 --> 01:00:18.450
不就指向这个玩意吗

01:00:18.450 --> 01:00:20.450
这是我们认为是gou吗

01:00:20.450 --> 01:00:22.450
对吧指向gou啊

01:00:22.450 --> 01:00:24.450
全局上下文嘛

01:00:24.450 --> 01:00:26.450
m2的链条就确定下来了

01:00:26.450 --> 01:00:27.450
管它有没有调用

01:00:27.450 --> 01:00:28.450
它就确定下来了

01:00:28.450 --> 01:00:29.450
然后呢把这个a

01:00:29.450 --> 01:00:31.450
现在一开始是nd半

01:00:31.450 --> 01:00:32.450
现在变成10

01:00:32.450 --> 01:00:34.450
到了第10行过来变成10

01:00:34.450 --> 01:00:36.450
一开始来一试吧

01:00:36.450 --> 01:00:37.450
一开始是nd

01:00:37.450 --> 01:00:38.450
然后到了第10行

01:00:38.450 --> 01:00:40.450
是不是把它变成10

01:00:40.450 --> 01:00:41.450
好调用m1

01:00:41.450 --> 01:00:43.450
好m1是不是又产生

01:00:43.450 --> 01:00:45.450
m1的仔细上下文

01:00:45.450 --> 01:00:48.400
对吧

01:00:48.400 --> 01:00:49.400
m1的仔细上下文

01:00:49.400 --> 01:00:50.400
m1的仔细上下文

01:00:50.400 --> 01:00:52.400
里面不有一个a吗

01:00:52.400 --> 01:00:53.400
就是m1的啊

01:00:53.400 --> 01:00:55.400
就这样子写吧

01:00:55.400 --> 01:00:56.400
这是全局的

01:00:56.400 --> 01:00:57.400
m1的仔细上下文

01:00:57.400 --> 01:00:58.400
里面不有一个a吗

01:00:58.400 --> 01:00:59.400
然后呢把f只为1

01:00:59.400 --> 01:01:00.400
它就变成1了

01:01:00.400 --> 01:01:01.400
执行谁

01:01:01.400 --> 01:01:02.400
执行m2

01:01:02.400 --> 01:01:03.400
好是不是又产生

01:01:03.400 --> 01:01:05.400
m2的仔细上下文

01:01:05.400 --> 01:01:06.400
m2的仔细上下文

01:01:06.400 --> 01:01:08.400
里面有东西吗

01:01:08.400 --> 01:01:09.400
它没有参数

01:01:09.400 --> 01:01:10.400
又没有变量

01:01:10.400 --> 01:01:11.400
又没有函数声明

01:01:11.400 --> 01:01:12.400
说m2的仔细上下文

01:01:12.400 --> 01:01:13.400
里面啥都没有

01:01:13.400 --> 01:01:14.400
空的

01:01:14.400 --> 01:01:16.400
好接下来a加加来

01:01:16.400 --> 01:01:18.400
这个a用的是啥

01:01:18.400 --> 01:01:19.400
用的是啥

01:01:19.400 --> 01:01:20.400
首先它自己没有

01:01:20.400 --> 01:01:21.400
对吧

01:01:21.400 --> 01:01:22.400
没有找谁

01:01:22.400 --> 01:01:23.400
找它的作用意念

01:01:23.400 --> 01:01:24.400
作用意念是谁

01:01:24.400 --> 01:01:25.400
是不是基尔

01:01:25.400 --> 01:01:26.400
找这

01:01:26.400 --> 01:01:27.400
是不是就是这个a

01:01:27.400 --> 01:01:28.400
所以加加过后

01:01:28.400 --> 01:01:30.400
是不是把这个a变成11了

01:01:30.400 --> 01:01:31.400
对吧

01:01:31.400 --> 01:01:32.400
因此呢这里输出a

01:01:32.400 --> 01:01:33.400
这个a还是没有对吧

01:01:33.400 --> 01:01:34.400
自己还是没有

01:01:34.400 --> 01:01:35.400
又去找作用意念

01:01:35.400 --> 01:01:36.400
是不是找到这个a了

01:01:36.400 --> 01:01:37.400
变成11

01:01:37.400 --> 01:01:38.400
输出什么

01:01:38.400 --> 01:01:39.400
而且呢你会发现

01:01:39.400 --> 01:01:41.400
这里也输出a

01:01:41.400 --> 01:01:42.400
这里a也肯定是

01:01:42.400 --> 01:01:43.400
全聚上下文的对吧

01:01:43.400 --> 01:01:44.400
也是11

01:01:44.400 --> 01:01:45.400
那两个是11

01:01:45.400 --> 01:01:47.400
那你搞弄输的过后

01:01:47.400 --> 01:01:49.400
你就不用去画那个图了

01:01:49.400 --> 01:01:50.400
你没有输之前

01:01:50.400 --> 01:01:51.400
你可以好好画一画

01:01:51.400 --> 01:01:52.400
就按照我的逻辑画一画

01:01:52.400 --> 01:01:53.400
那肯定是没问题

01:01:53.400 --> 01:01:54.400
对吧

01:01:54.400 --> 01:01:56.400
诸位就是麻烦一点嘛

01:01:56.400 --> 01:01:57.400
输了之后你会发现

01:01:57.400 --> 01:01:59.400
这个画肯定是跟定义的时候相关的

01:01:59.400 --> 01:02:00.400
跟运行的时候

01:02:00.400 --> 01:02:01.400
一点关系都没有

01:02:01.400 --> 01:02:02.400
其实它这个颜色都提醒你了

01:02:02.400 --> 01:02:03.400
颜色是啥

01:02:03.400 --> 01:02:05.400
颜色是灰色的

01:02:05.400 --> 01:02:07.400
颜色是不是灰色的

01:02:07.400 --> 01:02:08.400
灰色的颜色

01:02:08.400 --> 01:02:10.400
说明它根本没用

01:02:10.400 --> 01:02:12.400
好清楚了吗

01:02:12.400 --> 01:02:16.990
喝水啊

01:02:16.990 --> 01:02:17.990
对 M1

01:02:17.990 --> 01:02:18.990
它的作用链的话

01:02:18.990 --> 01:02:19.990
它也是指向机油

01:02:19.990 --> 01:02:21.990
也是指向机油

01:02:21.990 --> 01:02:22.990
只是呢

01:02:22.990 --> 01:02:23.990
我们在这个题里边

01:02:23.990 --> 01:02:25.990
没有去分析这个东西

01:02:25.990 --> 01:02:27.990
有跟它没关系

01:02:27.990 --> 01:02:30.820
好

01:02:30.820 --> 01:02:31.820
然后呢

01:02:31.820 --> 01:02:32.820
我们再来解释一个吧

01:02:32.820 --> 01:02:34.820
再来解释一个

01:02:34.820 --> 01:02:39.370
比较长

01:02:39.370 --> 01:02:40.370
比较的

01:02:40.370 --> 01:02:42.370
就我们平时开发有关系的

01:02:42.370 --> 01:02:43.370
一个现象

01:02:44.370 --> 01:02:45.370
I小于10

01:02:45.370 --> 01:02:46.370
I小于个

01:02:47.370 --> 01:02:48.370
10吧

01:02:48.370 --> 01:02:49.370
I加加

01:02:54.380 --> 01:02:55.380
这个地方我们干嘛呢

01:02:57.950 --> 01:02:59.950
我们用一个set timeout

01:02:59.950 --> 01:03:04.820
0

01:03:04.820 --> 01:03:05.820
我就写个0

01:03:06.820 --> 01:03:07.820
输出I

01:03:10.580 --> 01:03:11.580
都是非常典型的例子

01:03:12.580 --> 01:03:14.580
非常典型的例子

01:03:15.580 --> 01:03:16.580
请问最后

01:03:16.580 --> 01:03:17.580
I输出啥

01:03:18.580 --> 01:03:19.580
不是我们是

01:03:19.580 --> 01:03:20.580
3嘛

01:03:20.580 --> 01:03:21.580
那就3个吧

01:03:21.580 --> 01:03:22.580
少一点啊

01:03:22.580 --> 01:03:23.580
输出啥呀

01:03:24.580 --> 01:03:26.580
现在有人要输出10

01:03:26.580 --> 01:03:27.580
没问题

01:03:27.580 --> 01:03:29.580
非常重确啊

01:03:29.580 --> 01:03:31.580
输出3是非常重确

01:03:31.580 --> 01:03:32.580
输出几个3

01:03:32.580 --> 01:03:33.580
3个3

01:03:33.580 --> 01:03:35.580
那为什么会产出这种现象呢

01:03:36.580 --> 01:03:37.580
简单来说

01:03:37.580 --> 01:03:38.580
我们用简单的解释来说

01:03:38.580 --> 01:03:39.580
然后我们再用

01:03:39.580 --> 01:03:40.580
详细的解释来解释啊

01:03:40.580 --> 01:03:42.580
简单的解释怎么解释

01:03:43.580 --> 01:03:44.580
这个set timeout

01:03:44.580 --> 01:03:45.580
涉及到另外一个知识

01:03:45.580 --> 01:03:46.580
叫做世界循环

01:03:47.580 --> 01:03:48.580
这个知识呢

01:03:48.580 --> 01:03:49.580
也是必考的知识

01:03:49.580 --> 01:03:50.580
不知道同学们有没有

01:03:50.580 --> 01:03:51.580
对这一块了解

01:03:52.580 --> 01:03:53.580
就咱们的课程里面

01:03:53.580 --> 01:03:54.580
已经讲过多次了

01:03:54.580 --> 01:03:55.580
世界循环

01:03:55.580 --> 01:03:56.580
这个东西呢

01:03:56.580 --> 01:03:57.580
我们今天晚上

01:03:57.580 --> 01:03:58.580
肯定不涉及了啊

01:03:58.580 --> 01:03:59.580
你这里呢

01:03:59.580 --> 01:04:00.580
就可以简单的这样理解

01:04:00.580 --> 01:04:01.580
这里写凝和不写凝

01:04:01.580 --> 01:04:02.580
到底都是一样的

01:04:02.580 --> 01:04:03.580
这个函数

01:04:03.580 --> 01:04:04.580
什么时候执行

01:04:05.580 --> 01:04:06.580
永远是要等

01:04:06.580 --> 01:04:08.580
所有代码执行完了之后

01:04:08.580 --> 01:04:09.580
它才会执行

01:04:09.580 --> 01:04:10.580
这个函数

01:04:11.580 --> 01:04:12.580
不是立即执行啊

01:04:12.580 --> 01:04:13.580
不是立即执行

01:04:13.580 --> 01:04:14.580
是要等所有代码

01:04:14.580 --> 01:04:15.580
执行完了之后

01:04:15.580 --> 01:04:16.580
才会执行

01:04:16.580 --> 01:04:17.580
好

01:04:17.580 --> 01:04:18.580
我们就来分析一下

01:04:18.580 --> 01:04:19.580
这个玩意儿

01:04:19.580 --> 01:04:21.580
如果说用简单的分析

01:04:21.580 --> 01:04:22.580
来说的话

01:04:22.580 --> 01:04:24.580
这个其实很好理解

01:04:25.580 --> 01:04:27.580
这里定义了几个函数

01:04:29.580 --> 01:04:30.580
这是个函数表达式

01:04:30.580 --> 01:04:31.580
定义了几个函数

01:04:31.580 --> 01:04:32.580
三个

01:04:32.580 --> 01:04:33.580
为什么呢

01:04:33.580 --> 01:04:34.580
第一是循环

01:04:34.580 --> 01:04:35.580
定义一个

01:04:36.580 --> 01:04:37.580
第二是循环

01:04:37.580 --> 01:04:38.580
定义一个

01:04:38.580 --> 01:04:39.580
就是定义了循环的三次

01:04:39.580 --> 01:04:40.580
定义了三个

01:04:40.580 --> 01:04:41.580
这三个函数

01:04:41.580 --> 01:04:43.580
他们有自己的挨吗

01:04:43.580 --> 01:04:44.580
有自己的挨吗

01:04:44.580 --> 01:04:45.580
没有

01:04:45.580 --> 01:04:46.580
他们用的是谁的挨

01:04:46.580 --> 01:04:49.580
用的是外边这个挨

01:04:49.580 --> 01:04:50.580
换句话说

01:04:50.580 --> 01:04:51.580
用的是谁的挨

01:04:51.580 --> 01:04:54.580
用的是全局上下文义的

01:04:55.580 --> 01:04:58.220
挨从零开始

01:04:58.220 --> 01:04:59.220
用的是这个挨

01:05:00.220 --> 01:05:02.220
而我们循环结束之后

01:05:02.220 --> 01:05:03.220
这个挨的值是多少

01:05:04.220 --> 01:05:05.220
循环结束之后

01:05:05.220 --> 01:05:06.220
挨的值肯定是云三

01:05:06.220 --> 01:05:07.220
等于三就不满就

01:05:07.220 --> 01:05:08.220
循环条件了

01:05:09.220 --> 01:05:10.220
最后这个函数

01:05:10.220 --> 01:05:11.220
最终运行的时候

01:05:11.220 --> 01:05:12.220
输出这个挨

01:05:12.220 --> 01:05:13.220
就是这个挨

01:05:13.220 --> 01:05:14.220
是不是全部都是输出三

01:05:14.220 --> 01:05:15.220
因为这三

01:05:15.220 --> 01:05:16.220
这里的这些函数

01:05:16.220 --> 01:05:17.220
我刚才说了

01:05:17.220 --> 01:05:18.220
这里里边

01:05:18.220 --> 01:05:19.220
涉及到一个

01:05:19.220 --> 01:05:20.220
实现群玩的就是

01:05:20.220 --> 01:05:21.220
你们以后

01:05:21.220 --> 01:05:22.220
肯定要搞清楚的

01:05:23.220 --> 01:05:24.220
现在只需要知道

01:05:24.220 --> 01:05:25.220
这个玩意一定是最后运行

01:05:26.220 --> 01:05:27.220
所有代码运行完了之后

01:05:27.220 --> 01:05:28.220
你看了

01:05:28.220 --> 01:05:29.220
我在这里输出一个一二三

01:05:31.220 --> 01:05:32.220
是不是在一二三运行之后

01:05:32.220 --> 01:05:33.220
才会运行

01:05:34.220 --> 01:05:35.220
是吧

01:05:35.220 --> 01:05:36.220
所有代码运行之后

01:05:36.220 --> 01:05:37.220
才会运行

01:05:38.220 --> 01:05:39.220
这是另外一块知识

01:05:39.220 --> 01:05:40.220
那么也就是说

01:05:40.220 --> 01:05:41.220
它最终输出三个三

01:05:41.220 --> 01:05:42.220
就是一个原因

01:05:42.220 --> 01:05:43.220
因为他们用的是

01:05:43.220 --> 01:05:44.220
同一个挨

01:05:44.220 --> 01:05:45.220
都是旗有里边

01:05:45.220 --> 01:05:46.220
如果说画图的话

01:05:46.220 --> 01:05:47.220
那么我们来怎么样画图

01:05:47.220 --> 01:05:48.220
来理解

01:05:48.220 --> 01:05:50.220
就是来写这个分析来理解

01:05:50.220 --> 01:05:51.220
首先是拳击方向文

01:05:51.220 --> 01:05:52.220
里面不得有个I吗

01:05:52.220 --> 01:05:53.220
一开始是什么

01:05:53.220 --> 01:05:54.220
OND犯的

01:05:54.220 --> 01:05:55.220
因为这是电量定义

01:05:55.220 --> 01:05:57.220
一开始是OND犯的

01:05:57.220 --> 01:05:59.220
然后把它复制为0

01:05:59.220 --> 01:06:00.220
复制为0

01:06:00.220 --> 01:06:01.220
第一次循环

01:06:01.220 --> 01:06:02.220
第一次循环

01:06:02.220 --> 01:06:03.220
是不是定义了一个函数

01:06:03.220 --> 01:06:05.220
传了一个函数进去

01:06:05.220 --> 01:06:07.220
我们把它叫做F1

01:06:08.220 --> 01:06:09.220
这个函数

01:06:09.220 --> 01:06:10.220
这个函数的咨询上

01:06:10.220 --> 01:06:11.220
它这个作用意念

01:06:11.220 --> 01:06:13.220
这里是在进行函数定义

01:06:13.220 --> 01:06:14.220
是不是函数定义

01:06:14.220 --> 01:06:15.220
定义函数的时候

01:06:15.220 --> 01:06:16.220
作用意念是不是出来了

01:06:16.220 --> 01:06:17.220
指向谁

01:06:17.220 --> 01:06:18.220
指向旗有

01:06:18.220 --> 01:06:20.220
因为在旗有里边定义

01:06:21.220 --> 01:06:22.220
没有问题吧

01:06:22.220 --> 01:06:23.220
然后呢

01:06:23.220 --> 01:06:24.220
下一次循环

01:06:24.220 --> 01:06:26.220
下一次循环

01:06:26.220 --> 01:06:29.220
是不是又定义了一个函数

01:06:29.220 --> 01:06:31.220
F2也指向旗有

01:06:31.220 --> 01:06:32.220
F3

01:06:32.220 --> 01:06:34.220
第三次循环也指向旗有

01:06:34.220 --> 01:06:35.220
对吧

01:06:35.220 --> 01:06:36.220
最后循环结束

01:06:36.220 --> 01:06:37.220
循环结束

01:06:37.220 --> 01:06:38.220
是不是这里就等于3

01:06:38.220 --> 01:06:39.220
好循环结束之后

01:06:39.220 --> 01:06:41.220
开始来一时运行

01:06:41.220 --> 01:06:42.220
运行函数1

01:06:42.220 --> 01:06:43.220
输出I

01:06:43.220 --> 01:06:44.220
I是啥

01:06:44.220 --> 01:06:45.220
它自己没有

01:06:45.220 --> 01:06:46.220
自己没有只能是3

01:06:46.220 --> 01:06:47.220
运行函数2

01:06:47.220 --> 01:06:48.220
输出I

01:06:48.220 --> 01:06:49.220
输出I

01:06:49.220 --> 01:06:50.220
只能是3

01:06:50.220 --> 01:06:51.220
懂了意思吧

01:06:51.220 --> 01:06:53.220
说这个道理就是这么来的

01:06:54.220 --> 01:06:55.220
那我有没有什么办法

01:06:55.220 --> 01:06:56.220
让它输出123吗

01:06:58.720 --> 01:06:59.720
有没有什么办法呢

01:07:00.720 --> 01:07:02.720
很多同学都应该接触过

01:07:02.720 --> 01:07:03.720
我们用什么

01:07:03.720 --> 01:07:05.720
用一个立即执行函数

01:07:05.720 --> 01:07:06.720
就可以搞定了

01:07:08.720 --> 01:07:09.720
现在我要解释一下

01:07:09.720 --> 01:07:10.720
为什么立即执行函数

01:07:10.720 --> 01:07:11.720
就可以搞定

01:07:12.720 --> 01:07:13.720
得这样子写

01:07:14.720 --> 01:07:15.720
绕了好大一圈的

01:07:15.720 --> 01:07:16.720
到底是啥意思

01:07:16.720 --> 01:07:18.720
为什么这样子写就可以了呢

01:07:19.720 --> 01:07:20.720
为什么这样子写就可以了呢

01:07:20.720 --> 01:07:21.720
好 大家看

01:07:21.720 --> 01:07:24.030
好 这样子写

01:07:24.030 --> 01:07:25.030
为什么就可以了呢

01:07:25.030 --> 01:07:26.030
我又来

01:07:26.030 --> 01:07:27.030
一开始

01:07:27.030 --> 01:07:28.030
I等于0

01:07:28.030 --> 01:07:29.030
进入第1次循环

01:07:29.030 --> 01:07:30.030
注意看

01:07:30.030 --> 01:07:31.030
第1次循环

01:07:31.030 --> 01:07:33.030
这是不是一个函数定义

01:07:35.030 --> 01:07:36.030
得是吧

01:07:37.030 --> 01:07:38.030
得是一个函数定义吧

01:07:38.030 --> 01:07:39.030
那么我们把它叫做

01:07:39.030 --> 01:07:40.030
F1

01:07:44.410 --> 01:07:45.410
F1

01:07:45.410 --> 01:07:46.410
这个函数定义

01:07:46.410 --> 01:07:48.410
它的作用预列指向谁

01:07:48.410 --> 01:07:49.410
指向既欧

01:07:51.910 --> 01:07:52.910
对不对

01:07:52.910 --> 01:07:54.910
然后立即执行这个函数

01:07:54.910 --> 01:07:55.910
就不立即执行它

01:07:55.910 --> 01:07:56.910
它不是要等一会来执行

01:07:56.910 --> 01:07:57.910
它是马上就执行的

01:07:57.910 --> 01:07:58.910
你看

01:07:58.910 --> 01:07:59.910
定义一个函数执行

01:07:59.910 --> 01:08:00.910
执行它

01:08:01.910 --> 01:08:03.910
这一执行它

01:08:03.910 --> 01:08:04.910
是不是要产生

01:08:04.910 --> 01:08:09.250
F1的执行当下文

01:08:09.250 --> 01:08:10.250
是不是要产生

01:08:10.250 --> 01:08:11.250
F1的执行当下文

01:08:11.250 --> 01:08:12.250
一个函数都执行到肯定

01:08:12.250 --> 01:08:14.250
要产生F1

01:08:14.250 --> 01:08:16.250
产生函数的执行当下文

01:08:16.250 --> 01:08:17.250
那第1步来

01:08:17.250 --> 01:08:18.250
第1步确定参数

01:08:18.250 --> 01:08:19.250
有没有参数

01:08:19.250 --> 01:08:20.250
有一个参数i

01:08:22.250 --> 01:08:23.250
所以这个i跟外面

01:08:23.250 --> 01:08:24.250
这个还不是一码事

01:08:25.250 --> 01:08:26.250
有个参数i

01:08:26.250 --> 01:08:27.250
参数到指示级

01:08:28.250 --> 01:08:29.250
它是把

01:08:29.250 --> 01:08:30.250
这里是不是传进去了

01:08:31.250 --> 01:08:32.250
把这个i传进去了

01:08:32.250 --> 01:08:33.250
相当于是

01:08:33.250 --> 01:08:35.250
把这个i的值0

01:08:35.250 --> 01:08:36.250
传给了谁

01:08:36.250 --> 01:08:38.250
传给了这个参数i

01:08:38.250 --> 01:08:40.250
那么它的指示级

01:08:40.250 --> 01:08:41.250
是不是变成0

01:08:41.250 --> 01:08:42.250
但是现在这个i

01:08:42.250 --> 01:08:43.250
还是这个i吗

01:08:43.250 --> 01:08:46.710
不是的

01:08:46.710 --> 01:08:47.710
好 接下来

01:08:47.710 --> 01:08:48.710
F1产生了

01:08:48.710 --> 01:08:49.710
对吧

01:08:50.710 --> 01:08:52.710
就是定义这个函数

01:08:52.710 --> 01:08:53.710
有没有函数定义有

01:08:53.710 --> 01:08:54.710
那么这个函数

01:08:54.710 --> 01:08:55.710
我们把它叫做

01:08:55.710 --> 01:08:57.710
SF1

01:08:57.710 --> 01:08:59.710
就是SF1的F1

01:08:59.710 --> 01:09:00.710
就这个函数了

01:09:00.710 --> 01:09:01.710
那么它没有变量

01:09:01.710 --> 01:09:02.710
没有参数的一些

01:09:02.710 --> 01:09:04.710
它又终于念没有有

01:09:04.710 --> 01:09:05.710
终于念指向台

01:09:05.710 --> 01:09:06.710
指向F1

01:09:06.710 --> 01:09:07.710
为什么指向F1

01:09:07.710 --> 01:09:08.710
因为它是在F1

01:09:08.710 --> 01:09:10.710
运行过程中定义的

01:09:11.710 --> 01:09:12.710
懂了吧

01:09:13.710 --> 01:09:14.710
它指向的

01:09:14.710 --> 01:09:15.710
最后用的i是谁的i

01:09:15.710 --> 01:09:17.710
是这个F1的i

01:09:17.710 --> 01:09:18.710
是不是0

01:09:19.710 --> 01:09:21.710
饶了半天就是到这个东西

01:09:21.710 --> 01:09:22.710
然后

01:09:22.710 --> 01:09:23.710
下一次循环

01:09:23.710 --> 01:09:24.710
第四循环结束

01:09:24.710 --> 01:09:25.710
下一次循环

01:09:25.710 --> 01:09:29.730
是不是来了一个FN2

01:09:29.730 --> 01:09:30.730
FN2指向机油

01:09:30.730 --> 01:09:31.730
但是指向机油

01:09:31.730 --> 01:09:32.730
跟我们已经不care了

01:09:32.730 --> 01:09:33.730
对吧

01:09:33.730 --> 01:09:34.730
我们已经不care这个点事了

01:09:34.730 --> 01:09:36.730
因为已经别这么影响了

01:09:36.730 --> 01:09:39.730
我们就看它执行FN2

01:09:39.730 --> 01:09:41.730
这是第二次循环的定义

01:09:41.730 --> 01:09:42.730
第二次循环定义

01:09:42.730 --> 01:09:44.730
是不是它也有一个参数

01:09:44.730 --> 01:09:45.730
传的指示多少

01:09:45.730 --> 01:09:48.730
第二次循环是不是传了一个一信的

01:09:48.730 --> 01:09:49.730
这里变成一个

01:09:49.730 --> 01:09:50.730
传了一个一信的

01:09:52.730 --> 01:09:53.730
来了

01:09:53.730 --> 01:09:54.730
它把机油的e

01:09:54.730 --> 01:09:56.730
传给了这个参数i

01:09:57.730 --> 01:09:58.730
说到后边

01:09:58.730 --> 01:09:59.730
还用说吧

01:09:59.730 --> 01:10:01.730
后边FN2

01:10:01.730 --> 01:10:02.730
是不是用的

01:10:02.730 --> 01:10:03.730
它的中用语电

01:10:03.730 --> 01:10:05.730
是不是指向了FN2

01:10:05.730 --> 01:10:06.730
这个函数的中用语电

01:10:06.730 --> 01:10:08.730
是不是指向这个函数的

01:10:08.730 --> 01:10:09.730
上下问

01:10:09.730 --> 01:10:10.730
所以说到时候

01:10:10.730 --> 01:10:11.730
输出的i

01:10:11.730 --> 01:10:12.730
它自己没有

01:10:12.730 --> 01:10:13.730
它自己没往上找

01:10:13.730 --> 01:10:14.730
第一个函数找FN1的

01:10:14.730 --> 01:10:15.730
是不是输出0

01:10:15.730 --> 01:10:16.730
第二个函数找FN2的

01:10:16.730 --> 01:10:17.730
是不是输出1

01:10:17.730 --> 01:10:18.730
对吧

01:10:18.730 --> 01:10:19.730
我们就是通过

01:10:19.730 --> 01:10:20.730
这种方式来解决了

01:10:20.730 --> 01:10:21.730
这些比较丑陋

01:10:21.730 --> 01:10:23.730
以后ES6有更好的方式

01:10:23.730 --> 01:10:24.730
因为它多了一种

01:10:24.730 --> 01:10:25.730
多用语

01:10:25.730 --> 01:10:26.730
叫做快捷中用语

01:10:26.730 --> 01:10:27.730
不过我们现在

01:10:27.730 --> 01:10:28.730
不去管它了

01:10:30.730 --> 01:10:31.730
这就是我们过去

01:10:31.730 --> 01:10:32.730
解决的方式

01:10:32.730 --> 01:10:33.730
那么这个玩意

01:10:33.730 --> 01:10:34.730
我们通常把它叫必包

01:10:34.730 --> 01:10:35.730
对吧

01:10:35.730 --> 01:10:36.730
必包

01:10:36.730 --> 01:10:37.730
那么我们学着必包

01:10:37.730 --> 01:10:38.730
跟这个玩意有啥关系呢

01:10:38.730 --> 01:10:39.730
听好

01:10:39.730 --> 01:10:43.360
该点心的东西

01:10:43.360 --> 01:10:46.360
必包它不是一个技术

01:10:46.360 --> 01:10:48.360
而是一种现象

01:10:48.360 --> 01:10:49.360
什么现象

01:10:49.360 --> 01:10:50.360
指的是

01:10:50.360 --> 01:10:52.360
你在定义函数的时候

01:10:52.360 --> 01:10:54.360
周围的环境的信息

01:10:54.360 --> 01:10:56.360
可以在函数中使用

01:10:57.360 --> 01:10:58.360
就这么简单

01:10:58.360 --> 01:11:00.360
你以为必包是高尘的东西

01:11:00.360 --> 01:11:02.360
就这么个东西

01:11:02.360 --> 01:11:04.360
它不是一门技术

01:11:04.360 --> 01:11:06.360
它就是一个现象

01:11:06.360 --> 01:11:08.360
那么我们作用预练是啥

01:11:08.360 --> 01:11:09.360
作用预练

01:11:09.360 --> 01:11:13.860
就是实现必包的技术手段

01:11:13.860 --> 01:11:14.860
你光有现象

01:11:14.860 --> 01:11:16.860
你要把实现

01:11:16.860 --> 01:11:18.860
怎么把现象弄出来了

01:11:18.860 --> 01:11:20.860
咱们既也使用的办法

01:11:20.860 --> 01:11:21.860
就是作用预练

01:11:21.860 --> 01:11:23.860
这个东西你怎么不用管

01:11:23.860 --> 01:11:24.860
既也是个语言

01:11:24.860 --> 01:11:25.860
本身就得做好了

01:11:25.860 --> 01:11:27.860
它本身就会产生这样的一个现象

01:11:27.860 --> 01:11:29.860
但是你们要知道

01:11:29.860 --> 01:11:31.860
前辈们做的东西

01:11:31.860 --> 01:11:33.860
不是一说狼狼的

01:11:33.860 --> 01:11:35.860
它肯定是要付出一些技术上的努力

01:11:35.860 --> 01:11:36.860
还能实现的

01:11:36.860 --> 01:11:37.860
它的努力

01:11:37.860 --> 01:11:38.860
做法就是作用预练

01:11:38.860 --> 01:11:40.860
好 请说了吧

01:11:40.860 --> 01:11:50.830
所谓的必包有多复杂

01:11:50.830 --> 01:11:51.830
请问同学们

01:11:51.830 --> 01:11:53.830
这里有没有必包

01:11:53.830 --> 01:11:54.830
这个现象里面

01:11:54.830 --> 01:11:59.900
有没有产生必包

01:11:59.900 --> 01:12:01.900
有

01:12:01.900 --> 01:12:03.900
只要你在函数里面

01:12:03.900 --> 01:12:05.900
用到了函数外面的东西

01:12:05.900 --> 01:12:07.900
除了再明确一点

01:12:07.900 --> 01:12:09.900
你用到了作用预练上的东西

01:12:09.900 --> 01:12:11.900
你就有必包

01:12:11.900 --> 01:12:13.900
就这么简单

01:12:13.900 --> 01:12:15.900
所以说必包它本身并不复杂

01:12:15.900 --> 01:12:17.900
其实你在这里

01:12:17.900 --> 01:12:18.900
打个端点

01:12:18.900 --> 01:12:19.900
你可以看到非常非常清楚

01:12:19.900 --> 01:12:21.900
我们用一个调试模式执行

01:12:21.900 --> 01:12:22.900
那么执行到这

01:12:22.900 --> 01:12:24.900
你看这里是不是产生了必包

01:12:24.900 --> 01:12:25.900
它告诉你

01:12:25.900 --> 01:12:26.900
你用这个A

01:12:26.900 --> 01:12:27.900
用的是什么

01:12:27.900 --> 01:12:29.900
Y层环境的这个边量A

01:12:30.900 --> 01:12:32.900
当然有的时候

01:12:32.900 --> 01:12:34.900
我们可能把必包想得特别复杂

01:12:34.900 --> 01:12:36.900
不是必包复杂

01:12:36.900 --> 01:12:37.900
必包一点都不复杂

01:12:37.900 --> 01:12:39.900
主要是我们有的时候写代码

01:12:39.900 --> 01:12:41.900
写了代码本身复杂

01:12:41.900 --> 01:12:47.340
是我们代码本身比较复杂

01:12:47.340 --> 01:12:49.340
B等于2

01:12:49.340 --> 01:12:53.420
C等于3

01:12:53.420 --> 01:12:55.420
输出ABC

01:12:55.420 --> 01:12:57.420
函数里面套函数

01:12:57.420 --> 01:12:59.420
或者是反应会函数等等等等

01:12:59.420 --> 01:13:00.420
是那个复杂度

01:13:00.420 --> 01:13:01.420
是代码本身带来的

01:13:01.420 --> 01:13:04.420
跟一包没有太大的支援关系

01:13:04.420 --> 01:13:06.420
好,这么来看一下

01:13:06.420 --> 01:13:07.420
再打点打算

01:13:07.420 --> 01:13:11.370
它自己有C,对吧

01:13:11.370 --> 01:13:13.370
自己的指线好像我那边有C

01:13:13.370 --> 01:13:15.370
然后呢

01:13:15.370 --> 01:13:17.370
它中央域链上有A

01:13:17.370 --> 01:13:19.370
A里面提供了B

01:13:19.370 --> 01:13:21.370
它的Y层的最外层有

01:13:21.370 --> 01:13:23.370
有这个A

01:13:23.370 --> 01:13:24.370
对吧

01:13:24.370 --> 01:13:26.370
就这么个意思

01:13:26.370 --> 01:13:29.370
好,我们回过头来看这个面试题

01:13:29.370 --> 01:13:31.370
来,第一道面试题

01:13:38.050 --> 01:13:40.050
这道面试题我一看就知道在考什么

01:13:40.050 --> 01:13:42.050
考那个作用域链

01:13:42.050 --> 01:13:44.050
或者说我们把它叫B包

01:13:44.050 --> 01:13:46.050
都是一个意思

01:13:46.050 --> 01:13:47.050
为什么我可以看出来了

01:13:47.050 --> 01:13:49.050
不是因为我把它放到这个目录下面的

01:13:49.050 --> 01:13:51.050
是因为

01:13:51.050 --> 01:13:54.050
有些函数里面它本来没有这个东西的

01:13:54.050 --> 01:13:56.050
然后来强行把这个东西

01:13:56.050 --> 01:13:58.050
然后去打印某个东西的纸

01:13:58.050 --> 01:14:01.050
那就典型的是考查的作用域链

01:14:01.050 --> 01:14:03.050
怎么分析啊

01:14:03.050 --> 01:14:04.050
这个题呢其实

01:14:04.050 --> 01:14:05.050
抓住关键点

01:14:05.050 --> 01:14:06.050
你看它做啥

01:14:06.050 --> 01:14:08.050
调用A

01:14:08.050 --> 01:14:10.050
A里面做了一个循环

01:14:10.050 --> 01:14:13.050
然后又再调用B

01:14:13.050 --> 01:14:16.050
B里面又再做了一些东西

01:14:16.050 --> 01:14:18.050
又再调用C

01:14:18.050 --> 01:14:20.050
C里面你看

01:14:20.050 --> 01:14:22.050
C里面只有个A加加

01:14:22.050 --> 01:14:24.050
你始终搞清楚

01:14:24.050 --> 01:14:26.050
这个函数里面的

01:14:26.050 --> 01:14:29.050
作用域链它在定义的时候确定的

01:14:29.050 --> 01:14:32.050
所以说考作用域链的话

01:14:32.050 --> 01:14:34.050
那么你就搞清楚一件事

01:14:34.050 --> 01:14:36.050
这个作用域链指向谁

01:14:36.050 --> 01:14:38.050
肯定是指向既有

01:14:38.050 --> 01:14:40.050
既有里面不得有个I吗

01:14:40.050 --> 01:14:42.050
既有里面是不是有个I

01:14:42.050 --> 01:14:45.870
这个I的指数多少

01:14:45.870 --> 01:14:47.870
11对吧

01:14:47.870 --> 01:14:48.870
目前是这样子吧

01:14:48.870 --> 01:14:49.870
代码预讯到第12行的时候

01:14:49.870 --> 01:14:51.870
对吧C产生的作用域链指向谁

01:14:51.870 --> 01:14:53.870
指向既有

01:14:53.870 --> 01:14:54.870
既有里面有个I

01:14:54.870 --> 01:14:56.870
好然后调用A

01:14:56.870 --> 01:14:58.870
调用A的话又产生了

01:14:58.870 --> 01:15:00.870
又来到一个循环对吧

01:15:00.870 --> 01:15:01.870
我们把A画一下吧

01:15:01.870 --> 01:15:04.870
A到那个A函数

01:15:04.870 --> 01:15:06.870
A函数的指向一下文

01:15:06.870 --> 01:15:07.870
画一下吧

01:15:07.870 --> 01:15:08.870
它有没有一个I

01:15:08.870 --> 01:15:09.870
变量I

01:15:09.870 --> 01:15:10.870
还有个函数B

01:15:10.870 --> 01:15:11.870
函数B都无所谓了

01:15:11.870 --> 01:15:12.870
我们都可以不用画了

01:15:12.870 --> 01:15:13.870
有个变量I

01:15:13.870 --> 01:15:14.870
变量I循环的时势

01:15:14.870 --> 01:15:15.870
循环结束过后

01:15:15.870 --> 01:15:16.870
I的指数多少啊

01:15:16.870 --> 01:15:18.870
是不是10

01:15:18.870 --> 01:15:20.870
然后调用B

01:15:20.870 --> 01:15:22.870
B里面有I吗

01:15:22.870 --> 01:15:23.870
B定义的时候

01:15:23.870 --> 01:15:24.870
你看

01:15:24.870 --> 01:15:25.870
B定义的时候

01:15:25.870 --> 01:15:29.870
是不是指向FnA

01:15:29.870 --> 01:15:30.870
它的作用域�

01:15:30.870 --> 01:15:31.870
是不是指向FnA

01:15:31.870 --> 01:15:32.870
这个东西一眼就看出来了

01:15:32.870 --> 01:15:33.870
说B里面

01:15:33.870 --> 01:15:34.870
它本身自己没有

01:15:34.870 --> 01:15:35.870
定义变量I

01:15:35.870 --> 01:15:36.870
自己没有I

01:15:36.870 --> 01:15:37.870
没有I的话

01:15:37.870 --> 01:15:38.870
用了I是谁的

01:15:38.870 --> 01:15:39.870
是不是用的是这个

01:15:39.870 --> 01:15:41.870
FnA的I

01:15:41.870 --> 01:15:42.870
变成11

01:15:42.870 --> 01:15:44.870
然后调用C

01:15:44.870 --> 01:15:46.870
C里面就做了一件事

01:15:46.870 --> 01:15:47.870
I加加

01:15:47.870 --> 01:15:49.870
那加的是谁的I

01:15:49.870 --> 01:15:50.870
你看C里面自己没有I吧

01:15:50.870 --> 01:15:51.870
没有I找谁

01:15:51.870 --> 01:15:53.870
找它的作用域链

01:15:53.870 --> 01:15:54.870
作用域链是个全局的

01:15:54.870 --> 01:15:55.870
加的是它

01:15:55.870 --> 01:15:57.870
好C运行结束

01:15:57.870 --> 01:15:58.870
然后这里输出I

01:15:58.870 --> 01:16:00.870
B里面输出I

01:16:00.870 --> 01:16:01.870
B里面有I吗

01:16:01.870 --> 01:16:02.870
B里面有I

01:16:02.870 --> 01:16:03.870
B里面有I

01:16:03.870 --> 01:16:04.870
作用域链上去找

01:16:04.870 --> 01:16:05.870
链上是谁

01:16:05.870 --> 01:16:06.870
链上是

01:16:06.870 --> 01:16:08.870
还说A的I

01:16:08.870 --> 01:16:09.870
输出什么

01:16:09.870 --> 01:16:10.870
输出11

01:16:10.870 --> 01:16:12.870
输出11

01:16:12.870 --> 01:16:13.870
好

01:16:13.870 --> 01:16:14.870
B运行结束

01:16:14.870 --> 01:16:15.870
B运行结束过后

01:16:15.870 --> 01:16:16.870
A也没了

01:16:16.870 --> 01:16:17.870
好最后

01:16:17.870 --> 01:16:18.870
外面输出I

01:16:18.870 --> 01:16:19.870
外面有I吗

01:16:19.870 --> 01:16:20.870
外面有

01:16:20.870 --> 01:16:21.870
就是全局太阳文的I

01:16:21.870 --> 01:16:22.870
是吧

01:16:22.870 --> 01:16:23.870
然后第二个

01:16:23.870 --> 01:16:24.870
输出2

01:16:24.870 --> 01:16:25.870
所得到的结果是11

01:16:25.870 --> 01:16:26.870
12

01:16:26.870 --> 01:16:27.870
抓出关键点

01:16:27.870 --> 01:16:28.870
其实你都不用画的东西

01:16:28.870 --> 01:16:29.870
就看明白了

01:16:29.870 --> 01:16:30.870
它考来考去

01:16:30.870 --> 01:16:31.870
考察你

01:16:31.870 --> 01:16:32.870
看你

01:16:32.870 --> 01:16:33.870
认为这个C里面的I

01:16:33.870 --> 01:16:34.870
到底是什么 I

01:16:36.870 --> 01:16:37.870
本管

01:16:37.870 --> 01:16:38.870
就记住

01:16:38.870 --> 01:16:39.870
无论C在哪里去调用

01:16:39.870 --> 01:16:40.870
无所谓

01:16:41.870 --> 01:16:42.870
它自己没有 I

01:16:42.870 --> 01:16:44.870
它只能从作用域链去找

01:16:44.870 --> 01:16:45.870
作用链

01:16:45.870 --> 01:16:46.870
它定义的时候就确定了

01:16:46.870 --> 01:16:47.870
所以它的

01:16:47.870 --> 01:16:48.870
控制的I

01:16:48.870 --> 01:16:49.870
只能是全局的 I

01:16:50.870 --> 01:16:51.870
无论它怎么去找

01:16:52.870 --> 01:16:53.870
无论它掏了多少

01:16:53.870 --> 01:16:54.870
多少层还是去调用C

01:16:54.870 --> 01:16:55.870
没有关系的

01:16:58.440 --> 01:16:59.440
是吧

01:17:00.440 --> 01:17:02.750
第二题

01:17:02.750 --> 01:17:03.750
还多了一张面试令

01:17:07.830 --> 01:17:08.830
有点糟

01:17:08.830 --> 01:17:16.460
有点糟

01:17:16.460 --> 01:17:17.460
来吧

01:17:18.460 --> 01:17:19.460
来吧

01:17:20.460 --> 01:17:21.460
这里有个函数

01:17:21.460 --> 01:17:22.460
FN

01:17:22.460 --> 01:17:23.460
调用这个FN

01:17:23.460 --> 01:17:24.460
返回了一个数组

01:17:24.460 --> 01:17:25.460
返回了这个数组

01:17:26.460 --> 01:17:27.460
好

01:17:27.460 --> 01:17:28.460
我们来看一下

01:17:28.460 --> 01:17:29.460
FN里面怎么玩的

01:17:30.460 --> 01:17:31.460
FN里面

01:17:31.460 --> 01:17:32.460
有一个数组

01:17:32.460 --> 01:17:33.460
叫AR

01:17:34.460 --> 01:17:35.460
这个AR最终返回了

01:17:35.460 --> 01:17:36.460
对吧

01:17:36.460 --> 01:17:37.460
跟列舌是一样的

01:17:37.460 --> 01:17:38.460
列舌跟AR

01:17:38.460 --> 01:17:39.460
是一样的

01:17:39.460 --> 01:17:40.460
我们

01:17:40.460 --> 01:17:41.460
就看一下这个数组吧

01:17:42.460 --> 01:17:43.460
这个数组里边

01:17:43.460 --> 01:17:44.460
它循环了5次

01:17:44.460 --> 01:17:46.460
每一次循环

01:17:46.460 --> 01:17:48.460
复制为一个函数

01:17:48.460 --> 01:17:49.460
说说这里的数组里边

01:17:49.460 --> 01:17:50.460
全是函数

01:17:50.460 --> 01:17:51.460
第一个是一个函数

01:17:52.460 --> 01:17:53.460
这个函数做什么事情

01:17:53.460 --> 01:17:54.460
如果说写全的话

01:17:54.460 --> 01:17:55.460
就这样子

01:17:55.460 --> 01:17:56.460
Return I

01:17:57.460 --> 01:17:58.460
这个函数做这么一件事情

01:17:58.460 --> 01:17:59.460
Return I

01:17:59.460 --> 01:18:00.460
这就是这个函数

01:18:00.460 --> 01:18:02.460
第二个相当又是一个函数

01:18:03.460 --> 01:18:04.460
但每个函数是不一样的

01:18:05.460 --> 01:18:06.460
定了5次

01:18:06.460 --> 01:18:07.460
对不对

01:18:07.460 --> 01:18:08.460
定了这么一些函数

01:18:09.460 --> 01:18:10.460
如果说你

01:18:11.460 --> 01:18:12.460
比较熟练的话

01:18:12.460 --> 01:18:13.460
你都不用写那么全

01:18:13.460 --> 01:18:14.460
写个FN1

01:18:14.460 --> 01:18:15.460
FN2

01:18:15.460 --> 01:18:17.460
就这么5个函数

01:18:17.460 --> 01:18:18.460
对不对

01:18:19.460 --> 01:18:20.460
就写到这了

01:18:20.460 --> 01:18:21.460
那么接下来问题

01:18:21.460 --> 01:18:22.460
这个函数里边

01:18:22.460 --> 01:18:23.460
它自己有i吗

01:18:24.460 --> 01:18:25.460
自己有i就见了鬼了

01:18:25.460 --> 01:18:26.460
对吧

01:18:26.460 --> 01:18:27.460
自己没有i

01:18:27.460 --> 01:18:28.460
没有定义i

01:18:28.460 --> 01:18:29.460
那么

01:18:29.460 --> 01:18:30.460
我们就看作用预练了

01:18:31.460 --> 01:18:32.460
这个函数是在什么时候定义的

01:18:32.460 --> 01:18:33.460
是不是在循环

01:18:34.460 --> 01:18:35.460
这个函数

01:18:35.460 --> 01:18:36.460
在什么时候定义的

01:18:36.460 --> 01:18:38.460
是不是在循环的时候定义的

01:18:39.460 --> 01:18:41.460
是不是循环的时候定义的

01:18:42.460 --> 01:18:43.460
循环的时候定义

01:18:43.460 --> 01:18:44.460
那么

01:18:44.460 --> 01:18:45.460
循环

01:18:45.460 --> 01:18:46.460
它所谓的上下文是什么

01:18:46.460 --> 01:18:48.460
是不是FN的上下文

01:18:49.460 --> 01:18:50.460
这个FN的上下文

01:18:51.460 --> 01:18:52.460
里边有个什么

01:18:52.460 --> 01:18:53.460
有个变量i

01:18:54.460 --> 01:18:55.460
是吧

01:18:55.460 --> 01:18:56.460
i从0开始以后

01:18:56.460 --> 01:18:57.460
下一次循环变成1

01:18:57.460 --> 01:18:58.460
再变成2变成3

01:18:58.460 --> 01:18:59.460
变4变5

01:18:59.460 --> 01:19:00.460
对不对

01:19:00.460 --> 01:19:01.460
所以它的指向是谁

01:19:01.460 --> 01:19:02.460
指向的是FN的上下文

01:19:03.460 --> 01:19:04.460
这些还有权势

01:19:05.460 --> 01:19:06.460
这全是指向FN的

01:19:06.460 --> 01:19:08.460
上下文就是作用预练

01:19:08.460 --> 01:19:09.460
我这个指向就是作用预练的意思

01:19:09.460 --> 01:19:10.460
它自己没有i

01:19:10.460 --> 01:19:11.460
没有i

01:19:11.460 --> 01:19:12.460
它用的就是i

01:19:12.460 --> 01:19:13.460
就是这个i

01:19:13.460 --> 01:19:14.460
它只能用这个i用不了别的了

01:19:14.460 --> 01:19:17.770
实际上它还有说吗

01:19:17.770 --> 01:19:18.770
它一直绕了半天

01:19:18.770 --> 01:19:20.770
不就是绕回我们刚才的话题了吗

01:19:20.770 --> 01:19:22.770
然后循环这个数组

01:19:22.770 --> 01:19:23.770
然后把这个函数

01:19:23.770 --> 01:19:27.590
依次取出来调用

01:19:27.590 --> 01:19:28.590
那你看嘛

01:19:28.590 --> 01:19:29.590
调用的结果是什么

01:19:29.590 --> 01:19:31.590
法规的i不都是5

01:19:31.590 --> 01:19:32.590
对不对

01:19:33.590 --> 01:19:34.590
全都是5

01:19:34.590 --> 01:19:35.590
除了这道题呢

01:19:35.590 --> 01:19:37.590
它本身没有什么复杂的

01:19:37.590 --> 01:19:38.590
这没有什么复杂的

01:19:39.590 --> 01:19:40.590
就是就是我刚才说的

01:19:40.590 --> 01:19:41.590
那个必保问题的编组

01:19:41.590 --> 01:19:46.340
好

01:19:46.340 --> 01:19:47.340
再看下一道题

01:19:47.340 --> 01:19:51.350
上一道题的编组

01:19:51.350 --> 01:19:55.050
这我给你辩的

01:19:55.050 --> 01:19:59.150
我给你辩的

01:19:59.150 --> 01:20:01.150
这道题你们告诉我答案

01:20:01.150 --> 01:20:03.150
我相信很多同学都能告诉我答案了

01:20:03.150 --> 01:20:17.660
跟上一题为的区别就是

01:20:17.660 --> 01:20:18.660
我把这个代码

01:20:18.660 --> 01:20:19.660
放到一个立即执行函数里面

01:20:19.660 --> 01:20:20.660
掏了一下

01:20:25.130 --> 01:20:27.130
有同学说01234

01:20:27.130 --> 01:20:28.130
同不同意

01:20:28.130 --> 01:20:33.060
同意

01:20:33.060 --> 01:20:34.060
我同意

01:20:34.060 --> 01:20:35.060
你们不知道

01:20:35.060 --> 01:20:36.060
我同意

01:20:36.060 --> 01:20:37.060
01234

01:20:37.060 --> 01:20:39.060
为什么掏了一下就知道了

01:20:39.060 --> 01:20:40.060
怎么解释过了

01:20:40.060 --> 01:20:41.060
相当于是这段做法

01:20:41.060 --> 01:20:42.060
相当于是什么呢

01:20:42.060 --> 01:20:44.060
之前为什么全是5

01:20:44.060 --> 01:20:46.060
是因为我这个函数里面的i

01:20:46.060 --> 01:20:47.060
它自己没有i

01:20:47.060 --> 01:20:49.060
这个函数里面没有i

01:20:49.060 --> 01:20:51.060
之前为什么全是5

01:20:51.060 --> 01:20:52.060
是因为我这个函数的i

01:20:52.060 --> 01:20:53.060
用的是谁的i

01:20:53.060 --> 01:20:55.060
用的是fn里面的这个i

01:20:55.060 --> 01:20:57.060
这个i最后就是5

01:20:57.060 --> 01:20:58.060
所以说

01:20:58.060 --> 01:21:00.060
这些函数里面i全都变成5了

01:21:00.060 --> 01:21:01.060
用的是这个i

01:21:01.060 --> 01:21:02.060
那我现在

01:21:02.060 --> 01:21:04.060
现在给它编了一下

01:21:04.060 --> 01:21:05.060
给它掏了一层

01:21:05.060 --> 01:21:06.060
对吧

01:21:06.060 --> 01:21:07.060
掏了一层这个玩意

01:21:07.060 --> 01:21:08.060
那么

01:21:08.060 --> 01:21:09.060
你想这个道理

01:21:09.060 --> 01:21:10.060
那这里边没有i

01:21:10.060 --> 01:21:11.060
用的中央语电是谁

01:21:11.060 --> 01:21:13.060
它是在这个函数的执行过程中定义的

01:21:13.060 --> 01:21:15.060
所以它用的是这个i

01:21:15.060 --> 01:21:17.060
这个i跟这个i一样吗

01:21:17.060 --> 01:21:18.060
不一样

01:21:18.060 --> 01:21:20.060
所以它名字一样

01:21:20.060 --> 01:21:21.060
这个i是什么

01:21:21.060 --> 01:21:22.060
这个函数的参数

01:21:22.060 --> 01:21:23.060
这个i是啥

01:21:23.060 --> 01:21:24.060
这个i是它里面的变量

01:21:24.060 --> 01:21:25.060
能一样吗

01:21:25.060 --> 01:21:26.060
肯定不一样

01:21:26.060 --> 01:21:27.060
对吧

01:21:27.060 --> 01:21:28.060
所以说

01:21:28.060 --> 01:21:30.060
这个i

01:21:30.060 --> 01:21:32.060
在每一次循环的时候固定下来的

01:21:32.060 --> 01:21:33.060
第一次循环

01:21:33.060 --> 01:21:34.060
产生

01:21:34.060 --> 01:21:35.060
第一次循环

01:21:35.060 --> 01:21:37.060
产生第一个函数

01:21:37.060 --> 01:21:38.060
这里实际上产生了很多个

01:21:38.060 --> 01:21:39.060
我们就单看这个函数

01:21:39.060 --> 01:21:40.060
单看这个函数

01:21:40.060 --> 01:21:42.060
我们把它叫做f吧

01:21:42.060 --> 01:21:43.060
第一次循环

01:21:43.060 --> 01:21:44.060
我们把它叫做f1

01:21:44.060 --> 01:21:46.060
那么它的i是多少

01:21:46.060 --> 01:21:47.060
i就是0

01:21:47.060 --> 01:21:48.060
因为为什么

01:21:48.060 --> 01:21:49.060
因为把变量0传过来了

01:21:49.060 --> 01:21:50.060
对吧

01:21:50.060 --> 01:21:51.060
第二次循环

01:21:51.060 --> 01:21:53.060
i等于e

01:21:53.060 --> 01:21:54.060
为什么是e

01:21:54.060 --> 01:21:56.060
又产生一个函数f

01:21:56.060 --> 01:21:57.060
然后呢

01:21:57.060 --> 01:21:58.060
把第二次循环的i

01:21:58.060 --> 01:21:59.060
就e传过来了

01:21:59.060 --> 01:22:00.060
所以我们之后

01:22:00.060 --> 01:22:02.060
这里边的函数用的i

01:22:02.060 --> 01:22:03.060
用的是d

01:22:03.060 --> 01:22:04.060
用的是它

01:22:04.060 --> 01:22:05.060
用的是它

01:22:05.060 --> 01:22:06.060
对吧

01:22:06.060 --> 01:22:07.060
每一个用一个

01:22:07.060 --> 01:22:08.060
就是这么解决的

01:22:08.060 --> 01:22:10.060
这个问题

01:22:10.060 --> 01:22:11.060
好

01:22:11.060 --> 01:22:13.060
这就是咱们今天晚上的

01:22:13.060 --> 01:22:15.060
那种整体上还是不复杂

01:22:15.060 --> 01:22:16.060
对不对

01:22:16.060 --> 01:22:18.060
一讲应该就明白了

01:22:18.060 --> 01:22:19.060
指令上下文

01:22:19.060 --> 01:22:20.060
就是这么一个东西

01:22:20.060 --> 01:22:21.060
准备好一个

01:22:21.060 --> 01:22:22.060
准备好一个对象

01:22:22.060 --> 01:22:24.060
里边不停地给他安一些东西

01:22:24.060 --> 01:22:26.060
然后还说指令的过程中

01:22:26.060 --> 01:22:27.060
就可以时间使用了

01:22:27.060 --> 01:22:28.060
怎么准备的

01:22:28.060 --> 01:22:29.060
123

01:22:29.060 --> 01:22:31.060
三个步骤

01:22:31.060 --> 01:22:33.060
终于链一定记住

01:22:33.060 --> 01:22:34.060
在定义的时候

01:22:34.060 --> 01:22:37.060
就形成链条了

01:22:37.060 --> 01:22:38.060
执行函数的过程中

01:22:38.060 --> 01:22:39.060
自己没有的东西

01:22:39.060 --> 01:22:41.060
就要终于链上去找

01:22:41.060 --> 01:22:43.060
关键点就这么一些

01:22:43.060 --> 01:22:44.060
然后抓住这些关键点

01:22:44.060 --> 01:22:45.060
去做题

01:22:45.060 --> 01:22:46.060
实在不行

01:22:46.060 --> 01:22:48.060
就用最笨的办法

01:22:48.060 --> 01:22:49.060
你别看这些办法笨

01:22:49.060 --> 01:22:51.060
非常的扎实

01:22:51.060 --> 01:22:53.060
我就画一个对象出来

01:22:53.060 --> 01:22:55.060
我第一步做啥

01:22:55.060 --> 01:22:56.060
第二步做啥

01:22:56.060 --> 01:22:57.060
第三步做啥

01:22:57.060 --> 01:22:58.060
把写出来

01:22:58.060 --> 01:22:59.060
终于链的时候

01:22:59.060 --> 01:23:00.060
就像我刚才的样子

01:23:01.060 --> 01:23:02.060
定义函数的时候

01:23:02.060 --> 01:23:04.060
就把链条给他写出来

01:23:04.060 --> 01:23:05.060
最笨的办法就是这样子的

01:23:05.060 --> 01:23:06.060
虽然麻烦

01:23:06.060 --> 01:23:09.060
但是保证你做的没问题

01:23:09.060 --> 01:23:10.060
好了

