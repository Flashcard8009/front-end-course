WEBVTT

00:00.000 --> 00:05.360
好 同学们 那咱们开始上课了 经过我们前两天的学习呢 我们已经

00:06.960 --> 00:11.280
把这四个东西 对吧 这一时继续有 我们不说别的 我们该把

00:12.000 --> 00:17.760
讲过的东西 同学们能搞清楚就可以了 那像我们这个行业

00:18.560 --> 00:23.760
面试题 它的考点呢 就这么一些 你搞定一个就少一个

00:24.720 --> 00:30.320
对吧 所以说还是有收获的 我们通过这两天的学习呢 搞定了四个重要的知识点

00:31.600 --> 00:33.440
那么以后呢 你们在桌面试题的时候

00:34.480 --> 00:39.760
不管它是一个单独的考题 还是说它综合性的考题 至少这些知识

00:40.400 --> 00:43.840
你们不用再害怕了 对吧 你们已经完全搞清楚了

00:44.480 --> 00:49.920
那么今天呢 我们去搞定这两个知识 一个是圆形链 一个是热识的指向

00:50.880 --> 00:53.040
一个一个来 首先说圆形链

00:54.240 --> 00:58.800
因为呢 我们刚才看到同学 还有同学不知道圆形是啥的

00:59.600 --> 01:05.760
我本来以为呢 这一块呢 我就可以快速的把它过一下就行了 那不行啊 好像还得详细的讲

01:06.560 --> 01:12.000
不知道圆形 那不知道圆形的同学呢 估计连勾到函数 可能搞得不是很清楚

01:12.560 --> 01:13.520
那我们慢慢来吧

01:14.480 --> 01:18.160
首先大家看这么一块代码 这个代码呢 这里写了一个函数

01:19.120 --> 01:20.400
然后传了两个参数

01:21.200 --> 01:24.160
啊 一个first name 姓一个名 对吧 姓名

01:24.960 --> 01:26.960
这里边呢 我们使用了 this啊 给它复制

01:27.600 --> 01:32.400
复制到两个属性里边 然后呢 又加了一个属性 那这些都不重要

01:33.120 --> 01:36.080
关键是下边的东西是啥 这个玩意儿是啥

01:37.440 --> 01:38.400
这个玩意儿又是啥

01:39.840 --> 01:41.440
我们给它定义了两个函数

01:42.400 --> 01:46.560
这个东西是啥东西啊 然后呢 接下来我们通过六来创建一个对象

01:47.280 --> 01:52.640
U1 这到底是什么玩意儿啊 说说它也不是什么东西 你有U2又是什么东西

01:53.600 --> 01:58.320
啊 为什么这里创建了U2 一个用户对象之后呢 我就可以使用这个say hi

01:59.440 --> 02:06.480
就可以使用它了 为什么可以使用这些问题呢 我都要搞清楚 这是解释非常非常基础的问题

02:07.440 --> 02:11.520
啊 那么我们下面用一张图就可以完全解释 上面这个现象

02:18.110 --> 02:20.750
稍微的放小一点啊

02:23.380 --> 02:27.060
好 同学们来看啊 下面这张图 我们对照着这个

02:28.100 --> 02:29.700
对照着上面这个图来看

02:30.900 --> 02:32.900
首先呢 我们这里定义了一个函数

02:34.100 --> 02:38.820
U2 对吧 定义了一个函数 函数在GS里边是啥

02:39.940 --> 02:45.300
我们其实前两天已经给大家说过了 我们GS里边是有很多的数据类型

02:45.860 --> 02:46.900
有原始类型

02:47.940 --> 02:50.580
包括什么now undefend the number stream

02:51.300 --> 02:53.300
不令对吧 这么五种类型

02:53.940 --> 02:55.620
还有一种叫做对象类型

02:56.260 --> 03:01.300
对象类型我们把叫做引用类型 引用类型有哪些呢 只有一个就是对象

03:01.700 --> 03:05.860
我们当时咋说的 我说对象里边包含了什么 包含了

03:06.900 --> 03:08.180
对普通对象

03:09.540 --> 03:13.380
还包含了函数数 这些都是对象

03:14.180 --> 03:18.340
所以说我们的函数是不是一个对象啊 函数它也是对象

03:19.300 --> 03:21.620
怎么在理解上就这么理解 非常简单

03:22.020 --> 03:27.060
你这个边量A是不是对象 它是这个边量B是不是对象

03:28.340 --> 03:32.100
它是这个函数C是不是对象

03:32.580 --> 03:38.020
它是他们三个虽然说长得不一样 各有各的性格特点

03:38.820 --> 03:40.260
但是呢 他们都是对象

03:41.380 --> 03:45.380
一切GS里边 除了那五种原始类型之外

03:45.700 --> 03:48.660
当然你们以后学GS6了 还会新增一些类型

03:49.460 --> 03:52.340
除了我们目前的原始类型之外呢 其他的全是对象

03:53.140 --> 03:56.100
其实长的样子不一样 对吧 有些长成这个样子

03:56.340 --> 03:58.660
有些长成这个样子 但他们都是对象

03:59.540 --> 04:01.540
好 我们回到头 在这边来

04:01.860 --> 04:06.020
刚才我们创建了一个函数 相当于就是创建了这么一个对象

04:06.500 --> 04:07.220
就这么简单

04:08.660 --> 04:13.780
当我们创建一个函数的时候 除了创建这个函数对象本身之外呢

04:14.740 --> 04:18.740
它同时会附带一个东西 就是函数的圆形

04:19.380 --> 04:21.380
那么这个圆形 名字叫做Perl's Type

04:21.780 --> 04:23.700
这个圆形呢 它也是一个对象

04:25.860 --> 04:29.860
它有什么用 我们一会再看吧 我这里的不可能有太多的时间而已

04:30.340 --> 04:33.940
因为这是基础知识 有太多的时间去讲各道函数 去讲圆形

04:34.260 --> 04:36.100
我们把它基本逻辑理清楚就可以了

04:37.300 --> 04:41.060
那么我们也就是说啥意思呢 你只要看到了一个函数

04:41.460 --> 04:47.380
不管它是什么函数 只要看到一个函数 实际上产生了几个对象 产生了两个

04:48.100 --> 04:52.340
一个是函数本身的对象 一个是函数的圆形对象

04:52.980 --> 04:55.620
一个函数一定是有两个对象出来

04:56.100 --> 04:59.220
一个是函数本身 一个是函数的圆形

04:59.940 --> 05:04.420
那么我们用个箭头啥意思呢 表示这个玩意儿呢 是函数本身

05:05.060 --> 05:07.700
这个是函数本身 这个是函数的圆形

05:08.180 --> 05:09.380
用Perl's Type

05:10.340 --> 05:14.020
好 那么我们再来看一下 到底真的是不是这样子呢

05:14.020 --> 05:17.780
还是说 哎 袁老师是不是在下扯 我肯定没有下扯的啊

05:17.780 --> 05:21.860
比方说我们这里有个函数 当然这个名字是啥 无所谓

05:22.580 --> 05:27.700
几个对象 两个 一个是函数本身 我们用Console DIR来看一下

05:27.700 --> 05:29.620
你看这个玩意儿不就是个对象吗

05:30.660 --> 05:33.460
对吧 它还有一些属性 是一个对象吧

05:33.940 --> 05:37.860
然后同时还有另外一个对象 叫做Adder Prototype

05:40.260 --> 05:44.020
就是你不做任何事情 你就在这里写函数 两个对象出来

05:44.020 --> 05:47.700
一个是函数本身 一个是函数的圆形

05:48.180 --> 05:53.700
所以说 先把这两个东西搞清楚 一个是函数本身 一个是函数的圆形

05:53.700 --> 05:58.900
但是这个圆形里边 一开始是空的 没东西 啥东西都没有

06:00.580 --> 06:03.620
那么接下来你看我做了什么事 我给这个圆形

06:03.620 --> 06:06.660
你看这个user.prototype 是不是函数的圆形

06:07.620 --> 06:10.340
我可以通过这种方式 因为它是一个对象嘛 对吧

06:10.340 --> 06:14.020
所以说我可以通过这种方式 往对象里边加属性 可不可以

06:14.660 --> 06:17.860
你不要把它想那么多 好像 哎哟 这有是不是好特殊啊

06:17.860 --> 06:21.460
这个有一个函数 有一个函数的好特殊一点特殊都没有

06:21.460 --> 06:22.900
就是一个普通的对象

06:23.860 --> 06:25.540
所以说它就是一个普通对象

06:25.540 --> 06:28.260
因此你可不可以往里边加属性 当然可以啊

06:28.260 --> 06:32.900
我加了一个属性是一个函数 我加了另外一个属性是一个函数

06:32.900 --> 06:34.420
所以说这里就多了两个属性了

06:35.380 --> 06:37.220
这个好理解吧 两个都是函数

06:38.260 --> 06:40.180
那么也就是说 这段代码能看懂吗

06:41.140 --> 06:41.860
就对应到这儿

06:43.060 --> 06:43.700
对应到这儿

06:44.420 --> 06:45.700
就是我们上面这一段代码

06:46.260 --> 06:48.980
定义了一个函数 往圆形里边扎扎东西

06:49.540 --> 06:52.180
这有点相当于是啥呢 函数就是你的家

06:54.100 --> 06:58.260
这个圆形呢 就是你家里边的保险柜

06:59.540 --> 07:00.740
家里边的储物间

07:01.700 --> 07:02.660
它可以放东西的

07:03.140 --> 07:05.060
往里边随便放一些 想放啥放啥

07:05.620 --> 07:08.020
你放一个 将这些属性是函数可以

07:08.500 --> 07:10.820
那不是函数 你要把这个负责为负责为支付串

07:10.820 --> 07:13.940
也可以 负责为数字也可以 反正你随便放

07:14.740 --> 07:15.220
懂了意思吧

07:15.860 --> 07:18.340
那么目前上来这个代码就解释清楚了

07:18.900 --> 07:21.460
那接下来看下面这一段啊 下面这一段有如何理解

07:22.180 --> 07:23.860
那么我们现在用6的一个优责

07:24.660 --> 07:26.340
查了一些参数 对吧 这个函数有参数吗

07:27.060 --> 07:29.140
创建了一个用户 6

07:29.940 --> 07:32.980
当我们知道函数有两种调用方式

07:33.140 --> 07:34.500
一种是直接调用

07:35.220 --> 07:36.500
像这种方式直接调用

07:36.980 --> 07:38.260
那就把函数运行一遍

07:38.500 --> 07:39.860
对吧 创建 执行 创下文

07:39.860 --> 07:40.660
我们昨天讲的

07:40.660 --> 07:42.340
然后把这个函数代码运行一遍

07:42.660 --> 07:43.780
该反悔啥 反悔啥

07:44.660 --> 07:47.060
还有一种方式呢 是通过6来调用

07:47.940 --> 07:49.540
通过6调用的时候呢

07:50.820 --> 07:52.580
这就涉及到构造函数的知识了啊

07:53.700 --> 07:56.100
如果还不清楚构造函数的同学啊

07:56.580 --> 07:59.380
抓紧把函数搞定吧 看完吧 成了的函数

07:59.860 --> 08:03.380
简单说一下 通过6来调用函数的时候呢

08:03.620 --> 08:04.900
你就可以认为

08:05.060 --> 08:07.940
它在函数里边呢 它会自动的加两行代码

08:08.580 --> 08:12.100
第一行代码呢 使用Z式等于一个空队像最后一行代码

08:12.580 --> 08:14.340
反回这个Z式

08:14.980 --> 08:17.540
你就可以这样认为啊 中间是你这个函数代码

08:18.340 --> 08:21.700
它会自动给你加两行 第一行是这个 第二行是最后一行是这个

08:22.260 --> 08:25.140
所以说通过6来创建 当然你直接调用就没有啊

08:25.460 --> 08:28.260
直接调用就没有 通过6来调用函数的时候呢

08:28.900 --> 08:32.660
也就这个表达是 它会返回一个队像 你看这玩意是不是队像

08:32.820 --> 08:33.780
它会返回一个队像

08:35.540 --> 08:39.060
那么你可以接收一下 对吧 它知道一个队像 就这么个意思

08:39.300 --> 08:42.260
你看哈 我这里通过6来调用U字 那里看

08:43.220 --> 08:46.420
它在这里的时候 是不是有这么一句话

08:46.580 --> 08:49.060
它在最后的位置是不是应该有这么一句话

08:49.300 --> 08:51.860
说中间它是不是可以往Z式这个队像里边加东西

08:52.660 --> 08:55.140
加一个属性 加一个属性 加一个属性

08:55.700 --> 08:57.300
然后最后呢 它会把这个Z式返回

08:57.300 --> 08:58.500
所以说这个A那就是一个

08:59.540 --> 09:00.180
就是一个队像

09:00.820 --> 09:01.620
就这么简单

09:02.740 --> 09:04.340
好 我们再回过头来看啊 看这边

09:05.300 --> 09:08.260
当我们使用6的时候呢 会产生新的队像

09:08.820 --> 09:10.820
你看啊 我们这里 6的一个U字

09:11.060 --> 09:12.660
一会儿到我们U6的一个U字

09:12.660 --> 09:14.020
是不是创建了两个队像啊

09:14.180 --> 09:15.700
因此呢 这里有多了两个队像

09:15.700 --> 09:16.420
一个是U1

09:16.980 --> 09:18.420
保存了变量U1里边的

09:18.420 --> 09:19.220
一个是U2

09:19.780 --> 09:21.220
保存了变量U2里边的

09:22.020 --> 09:24.500
好理解吧 它们都是通过6来创建的

09:24.740 --> 09:26.340
那么这个东西相当于是什么呢

09:26.500 --> 09:27.380
这是你的家

09:27.700 --> 09:29.140
这是你家里的保险柜

09:29.700 --> 09:31.380
这就是你家里边的成员

09:33.140 --> 09:33.860
你的父亲

09:35.140 --> 09:35.780
你的母亲

09:36.820 --> 09:38.500
你自己 你的女朋友

09:38.740 --> 09:39.380
你的小孩

09:40.180 --> 09:42.340
那么你家里边的成员理论上

09:42.340 --> 09:43.860
是不是可以无限增加的

09:44.500 --> 09:44.900
对吧

09:45.540 --> 09:46.980
啊 家族心望嘛

09:47.940 --> 09:49.700
直直纯纯无穷进也 是吧

09:49.700 --> 09:50.900
都可以往家族里边

09:51.460 --> 09:53.060
是不是可以不停地增加成员

09:53.220 --> 09:54.420
这是一个不恰当的例子啊

09:54.420 --> 09:55.620
但是可以说明这个问题

09:55.940 --> 09:58.100
所以说你相当于是每U6一次啊

09:58.420 --> 10:00.900
就相当于是为你家里边增加了一个成员

10:01.300 --> 10:02.740
啊 就创建了一个新的队像

10:02.740 --> 10:04.180
它们都是属于你这个家的

10:05.540 --> 10:07.380
好 这个能理解了吧

10:07.700 --> 10:09.460
这两个U1U2能理解了吧

10:09.460 --> 10:11.460
当然你完全可以去创建U3U4

10:11.700 --> 10:13.380
无论你创建多少个 都无所谓

10:13.380 --> 10:15.300
它都是你这个U2的成员

10:15.860 --> 10:17.060
啊 你可以这样理解

10:18.340 --> 10:20.180
好 那现在我要解释这个东西了

10:21.300 --> 10:22.500
这个玩意儿是它呢

10:22.660 --> 10:24.740
这个玩意儿叫做隐氏圆形

10:25.220 --> 10:26.340
这个叫做圆形啊

10:26.340 --> 10:27.860
这个叫做隐氏圆形

10:28.260 --> 10:31.300
每一个对象它都有一个这么一个特殊的属性

10:31.300 --> 10:32.420
两个下滑线开头

10:32.740 --> 10:33.860
以来会是proto

10:33.860 --> 10:35.300
然后两个下滑线结尾

10:35.860 --> 10:37.220
这叫做隐氏圆形

10:37.220 --> 10:38.180
你看每个对象都有

10:38.740 --> 10:40.260
你只要它只要它是一个对象

10:40.260 --> 10:40.820
它一定有

10:41.780 --> 10:43.140
好 比方说随便来一个吧

10:43.380 --> 10:44.660
OBG它是不是一个对象

10:44.660 --> 10:45.300
它是一个对象

10:45.300 --> 10:45.780
它就有

10:47.860 --> 10:48.500
是不是就有

10:48.820 --> 10:50.260
你甭管这下面是啥嘛

10:50.580 --> 10:51.620
它是不是有这个属性

10:52.500 --> 10:52.980
对不对

10:53.460 --> 10:54.660
这叫隐氏圆形

10:54.660 --> 10:56.180
任何一个对象都有

10:57.140 --> 10:58.260
好 那么我们来看

10:59.140 --> 11:01.140
既然一任何一个对象都有的话

11:01.140 --> 11:01.940
那这里的对象

11:01.940 --> 11:02.660
它是不是对象

11:02.660 --> 11:03.460
它是不是对象

11:03.460 --> 11:04.180
它是不是对象

11:04.180 --> 11:04.740
是对象

11:04.740 --> 11:05.700
它们肯定有

11:06.420 --> 11:08.420
那么这个玩意儿它指向谁呢

11:08.820 --> 11:09.940
这个proto这个属性

11:09.940 --> 11:11.300
它到底是什么东西呢

11:12.980 --> 11:14.820
它其实这个属性

11:15.220 --> 11:16.740
就是这个圆形

11:18.900 --> 11:19.540
怎么理解

11:20.180 --> 11:21.460
这是你家里边的成员

11:22.500 --> 11:24.260
父亲母亲你自己的女朋友

11:24.260 --> 11:26.340
你你老婆你孩子

11:26.340 --> 11:26.660
对吧

11:27.620 --> 11:28.900
以后你们还会抱孙子

11:29.780 --> 11:30.980
都是你家里边的成员

11:31.540 --> 11:33.140
只要你是你家里边的成员

11:33.140 --> 11:35.540
那么它们就可以共享这个储物空间

11:36.100 --> 11:36.340
对吧

11:36.340 --> 11:37.540
都是家里边的人嘛

11:37.540 --> 11:37.780
对吧

11:37.780 --> 11:38.660
随便用

11:38.660 --> 11:40.340
这里边东西可以随便用

11:40.340 --> 11:40.900
所以说呢

11:41.540 --> 11:43.220
这个圆形相当于是啥

11:43.620 --> 11:45.060
圆形就相当于是

11:45.060 --> 11:46.820
这些对象的共享的空间

11:47.380 --> 11:48.260
它们有各自的

11:48.980 --> 11:49.780
有差异的东西

11:49.780 --> 11:51.300
比方说它们自己的性命不一样

11:52.020 --> 11:52.980
性别不一样

11:52.980 --> 11:53.860
年龄不一样

11:53.860 --> 11:55.300
是不是有差异的东西

11:55.300 --> 11:56.260
有差异的东西

11:56.260 --> 11:57.300
那是它们自己的属性

11:58.260 --> 11:59.060
但是呢

11:59.060 --> 12:00.900
它们也有共有的东西

12:00.900 --> 12:02.420
比方说它们都可以找打招呼

12:04.260 --> 12:04.740
对吧

12:04.740 --> 12:06.980
那么这就是这么一个意识

12:08.100 --> 12:09.700
隐士圆形指向谁

12:10.580 --> 12:12.420
你是用哪个构造函数

12:12.420 --> 12:13.540
这个东西叫做构造函数

12:13.540 --> 12:15.620
你通过六来创建的函数

12:15.620 --> 12:16.980
我们把它叫做构造函数

12:18.020 --> 12:20.260
你用的是哪一个构造函数

12:20.260 --> 12:21.060
创建的对象

12:21.940 --> 12:23.780
隐士圆形就指向谁

12:23.780 --> 12:25.140
这就是一个三角关系

12:26.260 --> 12:27.460
这个三角关系

12:27.460 --> 12:29.860
一定要是非常非常深刻的

12:30.340 --> 12:32.900
就像该一个章一样硬在里的老海里面

12:34.900 --> 12:35.940
扣的扣不下来的一种

12:37.220 --> 12:38.420
你只要看到一个函数

12:39.060 --> 12:39.700
几个东西

12:39.700 --> 12:40.340
两个对象

12:40.340 --> 12:40.660
一

12:40.660 --> 12:40.820
二

12:41.780 --> 12:43.140
通过六创建一个对象

12:43.540 --> 12:44.100
几个东西

12:44.100 --> 12:44.660
三个东西

12:45.460 --> 12:46.180
一个

12:46.180 --> 12:46.660
两个

12:46.660 --> 12:46.980
三个

12:47.700 --> 12:48.980
形成一个三角关系

12:48.980 --> 12:50.580
通过六来产生这个对象

12:50.980 --> 12:52.260
这个对象的隐士圆形

12:52.260 --> 12:55.220
指向这个构造函数的圆形

12:57.140 --> 12:57.460
好

12:57.460 --> 12:57.940
咱们再来

12:58.740 --> 13:00.340
来认识这个道理

13:02.540 --> 13:04.700
我一个同学们都知道这个东西

13:06.220 --> 13:08.220
比方说我这里六的一个尔瑞

13:09.660 --> 13:10.940
你怎么来解释这个东西

13:12.940 --> 13:13.660
几个对象

13:13.660 --> 13:14.060
三个

13:16.180 --> 13:17.220
第一个对象是啥

13:17.220 --> 13:18.260
第一个对象是尔瑞

13:20.820 --> 13:21.940
尔瑞本身

13:21.940 --> 13:23.140
尔瑞本身是一个对象

13:23.220 --> 13:23.940
它是一个函数

13:23.940 --> 13:24.820
函数也是对象

13:25.860 --> 13:26.820
然后呢

13:26.820 --> 13:28.020
另一个对象是什么呢

13:28.020 --> 13:29.060
是尔瑞的圆形

13:31.540 --> 13:32.020
圆形

13:32.660 --> 13:33.700
谁的圆形

13:33.700 --> 13:34.500
尔瑞的圆形

13:36.420 --> 13:37.540
然后溜了一个什么

13:37.540 --> 13:38.340
溜了一个尔瑞

13:38.340 --> 13:40.980
是不是在保存在ARR里边去了

13:40.980 --> 13:41.780
那么ARR

13:42.500 --> 13:43.140
也是个对象

13:44.500 --> 13:44.980
ARR

13:47.010 --> 13:47.810
它有一个什么呢

13:47.810 --> 13:49.330
它有一个隐士圆形

13:49.330 --> 13:51.170
就是两个下滑线Prot

13:51.730 --> 13:52.370
对吧

13:52.370 --> 13:54.050
通过六来产生ARR

13:54.130 --> 13:55.330
那么它的隐士圆形

13:55.330 --> 13:56.050
就指向这个

13:56.050 --> 13:57.090
这就是个三角关系

13:57.730 --> 13:59.090
要像盖章一样

13:59.090 --> 14:00.210
硬在你的脑海里边

14:01.570 --> 14:02.130
听懂了吗

14:02.850 --> 14:03.890
形成这么一个三角关系

14:04.690 --> 14:05.890
因为这一个是

14:07.410 --> 14:08.610
基础部分的内容

14:08.610 --> 14:10.450
所以说我们就讲到这了

14:11.730 --> 14:13.730
如果说你对这一块都不知道

14:13.730 --> 14:15.810
哪下来还要把基础好好抓一抓

14:16.370 --> 14:17.730
我们主要是要讲圆形链

14:18.850 --> 14:20.290
但是这个东西是圆形

14:20.290 --> 14:21.570
讲圆形链的基础

14:22.130 --> 14:23.330
你必须要知道这个东西

14:23.330 --> 14:24.530
而且非常清楚

14:24.530 --> 14:26.050
你才能听懂后面的圆形链

14:27.410 --> 14:28.930
好了那么这个就完事了

14:29.570 --> 14:30.770
那这个东西有什么用呢

14:30.770 --> 14:32.690
它为什么要形成这样的一个结构呢

14:32.690 --> 14:33.970
其实道理很简单

14:33.970 --> 14:35.090
就是我们刚才说的道理

14:35.890 --> 14:36.930
然后说你现在

14:36.930 --> 14:38.850
我们不知道朋友们现在多大啊

14:38.850 --> 14:39.650
有二十几岁的

14:39.650 --> 14:40.530
有三十几岁的

14:41.490 --> 14:41.810
对吧

14:42.530 --> 14:43.170
很多时候呢

14:43.170 --> 14:44.050
你们可能想

14:44.610 --> 14:45.730
比方想买房买车

14:46.610 --> 14:47.730
这个时候咋办呢

14:47.730 --> 14:48.770
你自己没钱

14:48.770 --> 14:49.410
没钱咋办

14:49.890 --> 14:50.370
是吧早啊

14:51.410 --> 14:52.290
家里边要一要

14:52.290 --> 14:52.850
对吧

14:53.010 --> 14:54.450
家里边支持一下

14:54.930 --> 14:57.010
那么这个圆形就相当于是

14:58.610 --> 15:00.050
自己家里边的这些人

15:00.050 --> 15:01.570
他们共享的空间

15:01.570 --> 15:02.370
你没有

15:02.370 --> 15:03.250
那么就从这儿找

15:03.810 --> 15:04.530
你有的话

15:04.530 --> 15:06.610
比方说你现在三十多岁事业有成了

15:07.650 --> 15:08.530
薪水也挺高的

15:09.090 --> 15:10.610
买房不需要家里边操心了

15:10.610 --> 15:11.730
那你自己搞定呗

15:11.730 --> 15:12.930
你不要去返家里边了

15:13.650 --> 15:14.290
懂了意思吧

15:15.170 --> 15:17.250
所以说对隐私圆形起什么作用呢

15:18.210 --> 15:20.770
当我们去找一个对象成员的时候

15:20.770 --> 15:22.370
如果说他自己没有

15:22.850 --> 15:25.410
他就会从隐私圆形里边去找

15:25.970 --> 15:26.930
这说的是啥意思

15:26.930 --> 15:28.210
比方说我们现在去看啊

15:29.330 --> 15:30.290
看去看这个带吧

15:30.290 --> 15:30.690
你看吧

15:33.810 --> 15:35.090
我这个U1里边

15:35.090 --> 15:36.610
有没有谁害这个方法

15:36.610 --> 15:37.410
有没有啊

15:37.410 --> 15:38.450
是没有的呀

15:38.450 --> 15:39.410
为什么说没有呢

15:39.410 --> 15:41.010
你看U1里边有啥

15:41.010 --> 15:41.890
就这三个属性

15:41.890 --> 15:43.010
F1那是那面

15:43.010 --> 15:43.330
F4那

15:43.810 --> 15:44.690
就这三个属性

15:44.690 --> 15:45.490
有没有谁害啊

15:46.130 --> 15:46.530
没有

15:46.530 --> 15:47.170
没有怎么办

15:47.810 --> 15:49.970
没有从隐私圆形里边找

15:49.970 --> 15:51.650
隐私圆形指向谁

15:51.650 --> 15:53.090
指向勾兆寒树的圆形

15:53.090 --> 15:54.850
勾兆寒树的圆形不是在这吗

15:54.930 --> 15:56.050
他里边是不是有谁害

15:56.610 --> 15:57.490
你看图的话

15:57.490 --> 15:58.210
看得更加清楚

15:59.010 --> 16:00.610
你看他这里边是不是有谁害

16:00.610 --> 16:02.530
所以说你调用U1点谁害

16:02.530 --> 16:03.250
是不是调用的是他

16:04.370 --> 16:05.250
懂得意思吧

16:05.250 --> 16:06.210
他就取这么一个作用

16:06.850 --> 16:08.610
那么调用U2点谁害

16:08.610 --> 16:09.490
是不是也调用的是他

16:10.290 --> 16:10.530
对吧

16:10.530 --> 16:12.290
他就起这么一个共享空间的作用

16:12.850 --> 16:13.330
你自己

16:14.690 --> 16:15.250
买不起房

16:15.250 --> 16:16.210
买不起车

16:16.210 --> 16:17.730
家里边职员一下嘛

16:17.730 --> 16:18.130
对吧

16:18.130 --> 16:18.770
是不是这个道理

16:19.330 --> 16:19.650
好

16:19.650 --> 16:21.810
这就是圆形

16:21.810 --> 16:22.850
就这么个三角关系

16:23.490 --> 16:24.210
听懂了同学

16:24.930 --> 16:25.570
没听懂的东西

16:25.570 --> 16:26.770
我看一下有什么有什么问题

16:35.410 --> 16:35.890
OK啊

16:36.690 --> 16:37.570
还是能听懂是吧

16:38.290 --> 16:39.650
有问题的话就几乎提出来

16:39.650 --> 16:40.130
如果说你

16:40.930 --> 16:41.810
不知道有问题

16:41.810 --> 16:43.250
但是不知道怎么提问的话

16:43.250 --> 16:44.290
那可能基础部分

16:44.850 --> 16:45.890
还得好好抓一抓

16:46.450 --> 16:48.050
因为可能一磨布的东西比较多

16:49.010 --> 16:50.450
那可能勾兆寒树还有问题

16:51.090 --> 16:51.410
好

16:51.410 --> 16:51.890
接下来

16:52.450 --> 16:54.610
我们才开始进入正常了

16:54.610 --> 16:55.250
圆形的

16:55.810 --> 16:58.050
那你看这个一层一层粘条的话

16:58.050 --> 16:58.610
就不得了

16:59.330 --> 17:00.610
为什么说不得了了呢

17:03.300 --> 17:04.260
所有的对象

17:05.220 --> 17:06.660
都有隐私圆形

17:06.660 --> 17:07.460
那我要问了

17:09.300 --> 17:10.260
它是不是个对象

17:11.780 --> 17:12.580
必须得是

17:13.620 --> 17:15.620
除了圆形内形全是对象

17:16.420 --> 17:17.380
它是不是对象

17:18.340 --> 17:19.220
必须得是

17:20.180 --> 17:21.940
除了圆形内形全是对象

17:22.660 --> 17:23.380
那你告诉我

17:23.380 --> 17:24.900
他们两个有没有隐私圆形的

17:25.620 --> 17:26.660
那必须得有啊

17:27.380 --> 17:28.100
那看吧

17:28.100 --> 17:29.380
我们来看一下

17:30.100 --> 17:30.980
我有一个寒树

17:30.980 --> 17:31.620
我啥都没写

17:31.620 --> 17:32.900
我就这么一个寒树

17:32.900 --> 17:34.020
寒树是不是对象

17:34.020 --> 17:34.740
是啊

17:34.740 --> 17:36.580
所以说寒树得不得

17:36.580 --> 17:37.700
应该有这么一个东西

17:38.420 --> 17:38.980
也得有

17:42.140 --> 17:42.620
你看吧

17:44.060 --> 17:44.780
是一个对象吧

17:44.780 --> 17:45.740
输出了是一个对象吧

17:45.740 --> 17:46.620
除了它有没有

17:46.620 --> 17:47.020
有

17:48.940 --> 17:49.580
然后呢

17:50.300 --> 17:52.300
寒树的圆形是不是对象

17:53.980 --> 17:55.260
它也得是对象吧

17:55.820 --> 17:56.620
说它得

17:56.620 --> 17:57.340
这个是对象

17:57.340 --> 17:58.460
它也得有这个东西

18:01.010 --> 18:01.890
看到没

18:01.890 --> 18:02.690
它也得有

18:04.450 --> 18:05.410
所有的东西

18:05.410 --> 18:06.290
只要是对象

18:06.290 --> 18:07.650
它一定有这个东西

18:07.650 --> 18:07.890
好

18:07.890 --> 18:09.410
那么又回到我们刚才的问题

18:09.410 --> 18:10.930
这个东西指向谁

18:12.530 --> 18:13.650
指向谁呢

18:13.650 --> 18:14.610
我们刚才是不是说了

18:15.250 --> 18:15.890
哎

18:15.890 --> 18:16.930
你这个对象

18:16.930 --> 18:19.090
它的隐私圆形指向谁

18:19.890 --> 18:20.690
取决于什么

18:20.690 --> 18:21.730
这个对象哪来的

18:22.690 --> 18:23.970
你这个对象哪来的

18:23.970 --> 18:25.170
理晤的是U字

18:26.450 --> 18:28.850
通过U一个U字来产生的对象

18:28.850 --> 18:30.130
所以说它的隐私圆形

18:30.130 --> 18:31.810
一定指向U字的圆形

18:32.450 --> 18:33.250
它一定指向这

18:34.610 --> 18:35.650
懂了意思吧

18:35.650 --> 18:36.850
你溜的是谁

18:36.850 --> 18:38.610
那么隐私圆形就指向谁的

18:39.330 --> 18:39.890
特特态

18:40.770 --> 18:42.370
这道理很简单

18:43.010 --> 18:43.890
就这么一个原理

18:43.890 --> 18:44.850
没有特殊情况

18:45.410 --> 18:46.930
其实有一点点特殊情况

18:46.930 --> 18:47.730
一会就看到了

18:48.690 --> 18:50.130
大部分时候都是这样子

18:51.010 --> 18:52.210
你溜的是谁

18:52.210 --> 18:54.050
那么它的隐私圆形就指向谁

18:55.890 --> 18:56.130
好

18:56.130 --> 18:57.570
那么现在的问题来了

18:57.570 --> 18:58.290
那你告诉我

18:58.290 --> 18:59.410
这个玩意我溜的是谁

19:01.650 --> 19:02.850
输主是不是对象

19:02.850 --> 19:03.170
是啊

19:04.130 --> 19:05.890
那么这个ARR溜的是谁

19:07.010 --> 19:08.290
就说没有溜

19:08.290 --> 19:09.010
哪溜了呀

19:09.010 --> 19:10.850
我看了半天就这么一行呆嘛

19:10.850 --> 19:12.850
我没有看到任何一个关键字溜呢

19:14.130 --> 19:15.090
我告诉同学们

19:15.890 --> 19:16.930
在纪念时中

19:18.050 --> 19:20.450
所有的对象都是溜出来

19:22.930 --> 19:24.450
有一个特殊

19:25.330 --> 19:26.530
我们就可以认为五特殊

19:26.530 --> 19:27.890
因为那个特殊跟我们

19:27.890 --> 19:29.090
就没啥多少关系

19:29.650 --> 19:30.450
没有特殊情况

19:31.250 --> 19:32.130
所有的对象

19:32.210 --> 19:33.010
都是溜出来

19:33.970 --> 19:36.050
那你都解释一下这个

19:36.530 --> 19:38.130
那这个对象没有溜出来呀

19:38.130 --> 19:39.650
这个对象是溜出来的

19:39.650 --> 19:40.370
你这么写

19:40.370 --> 19:41.490
它让你这么写

19:41.490 --> 19:43.170
是因为这么写着方便

19:43.970 --> 19:45.090
你写的舒服

19:45.090 --> 19:46.050
它才让你这么写

19:46.690 --> 19:48.290
它真实的代码是什么

19:48.290 --> 19:49.410
真实的代码是这个

19:51.820 --> 19:52.780
这是它真实的代码

19:53.660 --> 19:54.780
它是不是溜出来的

19:54.780 --> 19:55.660
是溜出来的

19:55.660 --> 19:56.620
那你告诉我

19:56.620 --> 19:57.980
这个玩意儿指向谁

19:57.980 --> 20:00.300
这个玩意儿ARR.proto

20:00.300 --> 20:01.660
proto是谁

20:01.740 --> 20:04.940
那一定得是ARR.proto

20:06.060 --> 20:06.620
对吧

20:06.620 --> 20:07.660
你溜的是它

20:07.660 --> 20:08.780
那么它的影视原型

20:08.780 --> 20:09.820
就指向它的原型

20:10.940 --> 20:11.820
那一定是这样子

20:15.200 --> 20:15.920
能理解了吧

20:16.720 --> 20:18.080
所有对象都是溜出来的

20:18.080 --> 20:19.440
好那一回又开始交召了

20:19.440 --> 20:20.560
那不对呀

20:20.560 --> 20:21.200
那你告诉我

20:21.200 --> 20:22.480
这个玩意儿是怎么来的呢

20:24.480 --> 20:25.760
这个对象也没有溜出来呀

20:26.320 --> 20:26.800
一样的

20:27.440 --> 20:29.360
既也是为了让你写着方便

20:29.360 --> 20:30.400
它允许你这样子

20:30.400 --> 20:31.200
暑写对象

20:31.200 --> 20:32.800
这个代码实际上是什么呢

20:32.880 --> 20:34.000
这个代码实际上是这个

20:39.300 --> 20:40.820
这是它真正的代码

20:41.460 --> 20:42.660
它是不是溜出来的

20:42.660 --> 20:43.700
也是溜出来的

20:43.700 --> 20:44.420
那么你告诉我

20:44.420 --> 20:45.380
这个OBG点

20:46.100 --> 20:46.980
proto指向谁

20:47.860 --> 20:49.300
指向ARR.proto

20:52.740 --> 20:53.220
看到没

20:53.860 --> 20:54.980
所以说你这样子写

20:55.620 --> 20:56.660
跟这样子写

20:56.660 --> 20:57.620
实际上是一样的

20:59.380 --> 20:59.940
是一样的

21:02.160 --> 21:02.720
是一样的

21:03.280 --> 21:04.800
你这里就是在溜ARR.proto

21:05.440 --> 21:06.080
好又说

21:06.080 --> 21:07.360
那这个不对呀

21:07.360 --> 21:08.160
所以这个说话

21:08.160 --> 21:09.760
我完全不无法认同

21:09.760 --> 21:10.640
那你这个东西

21:11.200 --> 21:12.240
你这个是函数啊

21:14.000 --> 21:14.880
你这个是函数啊

21:14.880 --> 21:16.400
比方我写个正是八几的函数啊

21:17.280 --> 21:18.000
A B

21:18.960 --> 21:20.000
Return A加B

21:20.560 --> 21:21.600
那这是一个函数啊

21:21.600 --> 21:22.080
你告诉我

21:22.080 --> 21:23.280
函数也是对象

21:23.280 --> 21:24.960
那函数溜的又是谁呢

21:28.900 --> 21:30.500
函数溜的是这个东西

21:30.500 --> 21:31.300
溜方

21:34.640 --> 21:36.080
A B

21:37.200 --> 21:38.560
Return A加B

21:39.920 --> 21:41.040
函数溜的是这个东西

21:42.800 --> 21:44.320
好当然你看这个函数

21:44.320 --> 21:45.360
输出的结果呢

21:45.440 --> 21:46.080
1 2

21:46.080 --> 21:47.840
那自然而然还是没问题的啊

21:49.200 --> 21:50.080
输出结果是3

21:50.800 --> 21:52.800
那么既然函数溜的是这个东西

21:52.800 --> 21:54.080
那么你看函数

21:54.960 --> 21:57.760
它的原型是不是应该等于

21:57.760 --> 21:59.040
方形的proto type

22:01.700 --> 22:02.580
是不是应该相等

22:03.540 --> 22:04.420
相等吧

22:04.420 --> 22:06.260
那我这样子写是这样子

22:06.260 --> 22:07.060
是可以相等的

22:07.060 --> 22:09.060
那这样子写是不是可以相等的

22:09.060 --> 22:09.860
肯定是可以的

22:11.380 --> 22:12.500
听懂了吗

22:12.500 --> 22:13.940
在JS语言里边

22:13.940 --> 22:15.300
所有的对象都是溜出来的

22:15.300 --> 22:16.100
没有特殊情况

22:16.820 --> 22:17.700
你看到一个对象

22:17.700 --> 22:18.740
它一定是溜出来的

22:19.460 --> 22:20.820
清见出来的

22:20.820 --> 22:22.660
那么它一定有隐私原型

22:22.660 --> 22:24.100
它的隐私原型就指向

22:24.100 --> 22:25.060
零溜的是谁

22:25.060 --> 22:25.780
它就指向谁

22:26.420 --> 22:28.420
这三个例子应该能够看得很明白了

22:29.220 --> 22:29.860
懂了意思吧

22:29.860 --> 22:31.380
听到现在能听懂的话Q和E

22:35.980 --> 22:36.860
Object of Crazy

22:36.860 --> 22:37.420
它也是

22:37.420 --> 22:38.460
它在帮你溜

22:43.780 --> 22:44.100
好

22:44.980 --> 22:45.780
那么现在呢

22:45.780 --> 22:47.860
我们搞清楚了这个问题之后

22:47.860 --> 22:48.580
我们就可以

22:50.180 --> 22:51.540
来看一下原型�了

23:00.110 --> 23:01.790
原型链是什么意思呢

23:04.030 --> 23:06.270
当我们去通过一个函数

23:06.270 --> 23:07.710
也就是我们所有的对象

23:07.710 --> 23:09.870
都是通过六一个函数创建出来的

23:10.830 --> 23:12.510
当我们去通过六一个函数

23:12.510 --> 23:13.630
创建了一个对象之后

23:13.630 --> 23:14.990
你看一下比方说这个U2

23:15.470 --> 23:16.270
它是一个函数

23:16.270 --> 23:17.310
我们自己写的函数

23:18.030 --> 23:19.310
它是不是得有一个原型

23:19.870 --> 23:20.750
函数都有原型

23:22.030 --> 23:22.350
对吧

23:22.910 --> 23:24.670
然后通过它溜了一个对象出来

23:24.670 --> 23:25.470
U1

23:25.470 --> 23:27.470
那么U1不得有个隐私原型吗

23:27.470 --> 23:28.110
它指向谁

23:28.110 --> 23:29.550
这个三角关系就出来了

23:30.430 --> 23:30.670
对吧

23:30.670 --> 23:31.710
这个三角关系就出来了

23:32.910 --> 23:33.070
好

23:33.070 --> 23:34.110
它指向这个原型

23:34.670 --> 23:35.310
好

23:35.310 --> 23:36.110
大家看

23:36.110 --> 23:38.510
我们的原型不也得是个对象吗

23:39.470 --> 23:40.350
一般来说

23:41.310 --> 23:42.030
一般来说

23:42.030 --> 23:43.550
只要你不去做一些骚操作

23:44.270 --> 23:45.070
一般来说

23:45.950 --> 23:47.470
函数这个原型对象

23:47.470 --> 23:48.750
是它自动创建的

23:49.390 --> 23:49.630
对吧

23:49.630 --> 23:51.150
你写一个函数的时候

23:51.150 --> 23:53.150
是不是你它自动一直创建原型

23:53.150 --> 23:54.270
然后我们这里写一个函数

23:54.830 --> 23:55.310
大家看

23:55.310 --> 23:56.190
我现在都没有动

23:56.190 --> 23:56.990
啥都没写

23:56.990 --> 23:58.030
我去看一下Prototype

23:58.670 --> 23:59.870
它是不是也是一个对象

24:01.070 --> 24:01.870
你看是不是一个对象

24:01.870 --> 24:03.630
它自动帮你创建了这个对象

24:04.670 --> 24:06.990
所以说函数的原型它也是一个对象

24:07.550 --> 24:08.590
它怎么来的呢

24:08.590 --> 24:10.110
它自动给你创建的

24:10.110 --> 24:11.630
它怎么来自动给你创建的呢

24:11.630 --> 24:14.030
它是通过溜一个R不解个词

24:14.030 --> 24:15.150
你看这里

24:15.150 --> 24:17.150
溜一个R不解个词创建了原型

24:17.150 --> 24:17.630
这个对象

24:18.510 --> 24:19.310
那么你看

24:19.310 --> 24:20.830
既然是溜了R不解个词

24:20.830 --> 24:22.110
上面是不是有个三角关系

24:22.110 --> 24:23.310
R不解个词是不是一个函数

24:23.950 --> 24:24.990
它不得有个原型吗

24:26.750 --> 24:27.070
对不对

24:27.790 --> 24:29.870
那么它通过溜了一个对象

24:29.870 --> 24:31.150
来作为游照的原型

24:31.150 --> 24:32.750
那这个原型的隐私原型

24:32.750 --> 24:33.950
不得指向它呢

24:33.950 --> 24:35.150
一样的道理对不对

24:35.150 --> 24:36.350
你这个对象哪来的

24:36.350 --> 24:38.990
总之对象总有一个来源吧

24:38.990 --> 24:40.350
你哪来的

24:40.350 --> 24:41.950
你溜谁创建出来的

24:43.870 --> 24:45.310
你只要溜谁创建出来的

24:45.310 --> 24:47.070
那么它就是指向这个

24:48.510 --> 24:50.430
它的函数的原型

24:50.430 --> 24:52.110
就形成了这么一个链条了

24:52.110 --> 24:53.790
所以说你会发现

24:53.790 --> 24:55.790
我们使用U1的时候

24:55.870 --> 24:58.030
它自己有些东西成员没有

24:59.550 --> 25:00.990
然后它会去哪里找

25:00.990 --> 25:03.710
它会通过隐私原型到它的原型

25:03.710 --> 25:05.150
隐私原型里面去找

25:05.150 --> 25:07.550
但是如果说隐私原型还没有

25:08.110 --> 25:11.870
它就继续找这个隐私原型的隐私原型

25:11.870 --> 25:12.990
是不是形成一个链条

25:13.710 --> 25:14.350
对吧

25:14.350 --> 25:15.950
形成了这么一个链条

25:15.950 --> 25:16.510
于是呢

25:17.070 --> 25:19.390
我们U1查找U1成员的时候

25:19.390 --> 25:20.670
比方你调用U1的属性

25:21.230 --> 25:23.310
它自己看有没有没有找这

25:23.310 --> 25:24.430
这里没有找这

25:24.510 --> 25:25.470
这就是原型链

25:27.390 --> 25:28.670
那么这个原型链呢

25:29.950 --> 25:32.190
你看这有一个特殊情况

25:32.190 --> 25:33.950
就是Objects它的原型

25:33.950 --> 25:34.670
就这个对象

25:34.670 --> 25:35.470
它也是个对象吧

25:35.470 --> 25:35.710
对吧

25:36.430 --> 25:37.310
这是特殊情况

25:38.190 --> 25:40.510
这个对象的隐私原型为now

25:42.430 --> 25:43.870
它的隐私原型为now

25:44.990 --> 25:46.270
这是比较特殊的情况

25:46.830 --> 25:47.230
当然了

25:47.230 --> 25:48.830
你也可以通过一些技巧

25:48.830 --> 25:50.510
刚才一同来说Objects crazy

25:50.510 --> 25:51.390
对吧

25:51.390 --> 25:52.990
你们以后学到这的时候

25:54.670 --> 25:56.830
它可以通过这个方法来改动

25:57.630 --> 25:58.590
它的隐私原型

25:59.630 --> 26:00.270
不改动的话

26:00.270 --> 26:01.070
那就是这个样子

26:01.950 --> 26:03.310
所以这里的特殊情况

26:03.310 --> 26:05.630
它的原型的隐私原型为now

26:05.630 --> 26:08.510
说如果说U1里面找东西找不到的话

26:08.510 --> 26:10.270
找这找不到找这

26:10.270 --> 26:10.830
再找不到

26:10.830 --> 26:11.470
那就爆出来了

26:11.470 --> 26:12.750
它就告诉你没有这个成员

26:14.350 --> 26:14.670
好

26:14.670 --> 26:16.190
比方说我们举个例子

26:16.190 --> 26:16.750
你看一下

26:17.710 --> 26:19.550
这里我们去

26:20.910 --> 26:21.630
6一个a吧

26:23.470 --> 26:24.030
6一个a

26:24.670 --> 26:28.430
然后我们输出adder tostune

26:30.660 --> 26:32.100
看一下有没有这个成员呢

26:32.820 --> 26:34.820
我们这里运行员代码

26:34.820 --> 26:36.260
它会告诉你有这个成员

26:37.140 --> 26:38.180
说明了啥

26:39.540 --> 26:40.260
说明了a

26:40.260 --> 26:42.180
首先看adder里面有没有这个成员

26:42.740 --> 26:43.700
那肯定没有吧

26:44.260 --> 26:46.020
a要有这个成员必须得这么写

26:46.020 --> 26:46.660
对吧

26:46.660 --> 26:49.300
z是adder tostune

26:50.180 --> 26:50.500
等于

26:51.220 --> 26:51.780
这样写了过

26:51.780 --> 26:53.220
它就自己就有这个成员了

26:53.220 --> 26:53.460
对吧

26:54.340 --> 26:54.580
对吧

26:54.660 --> 26:56.180
只要相当于自己有这个经济实力

26:56.180 --> 26:57.300
自己就去买房买车去了

26:57.300 --> 26:58.820
就不需要靠家里边了

26:59.380 --> 27:00.020
是这个道理吧

27:00.580 --> 27:02.580
所以它自己有的肯定用自己的

27:02.580 --> 27:03.860
那自己没有呢

27:03.860 --> 27:04.980
它去找谁呢

27:04.980 --> 27:07.140
它会去找adder元雄

27:07.700 --> 27:08.740
你看这个影视

27:08.740 --> 27:09.300
你看这个

27:10.900 --> 27:11.780
这边那个链条

27:16.030 --> 27:17.230
它会去找谁呢

27:17.230 --> 27:18.750
它会去找adder元雄

27:18.750 --> 27:18.910
对吧

27:18.910 --> 27:20.030
相当于一个u的元雄

27:20.590 --> 27:22.670
那u的元雄上有没有这个tostune呢

27:22.670 --> 27:23.470
也没有

27:23.470 --> 27:24.430
如果说u的

27:25.070 --> 27:26.830
这个adder元雄上有这个tostune的话

27:26.830 --> 27:27.870
那就直接用它了

27:27.870 --> 27:28.110
对吧

27:30.740 --> 27:31.940
所以就直接用它了

27:32.580 --> 27:34.820
但是问题是adder元雄上也没有

27:34.820 --> 27:35.700
它会去找谁

27:35.700 --> 27:37.300
找opg的元雄

27:37.940 --> 27:38.660
是不是找这儿了

27:39.460 --> 27:40.820
那这里边有没有tostune呢

27:42.260 --> 27:42.980
有tostune

27:44.260 --> 27:44.740
所以说

27:45.940 --> 27:46.740
我们可以看到

27:46.740 --> 27:49.220
这个tostune实际上就等于opg的车

27:49.220 --> 27:50.580
Prototap的tostune

27:50.580 --> 27:51.540
它们两个是相等的

27:53.820 --> 27:54.300
看到没

27:54.300 --> 27:56.380
所以说你这里可以使用这个方法

27:56.380 --> 27:56.860
来得到

27:57.580 --> 27:58.940
得到这个支付串

27:59.100 --> 28:00.540
得到支付串的表达结果

28:01.020 --> 28:01.740
就是这个原因

28:02.700 --> 28:04.060
同学们你们会发现

28:04.060 --> 28:05.260
是不是所有的对象

28:05.260 --> 28:06.460
好像都有这个tostune啊

28:07.340 --> 28:08.780
是不是所有的对象好像都有tostune

28:08.780 --> 28:09.180
说明

28:10.300 --> 28:11.340
绝大部分对象

28:11.340 --> 28:13.100
它在圆形链条上

28:13.100 --> 28:14.060
是不是到了终点

28:14.060 --> 28:14.940
是不是有这么一个东西

28:16.060 --> 28:17.100
那一定是有这么一个东西

28:17.100 --> 28:18.460
它才会出来tostune

28:19.260 --> 28:19.580
对不对

28:20.140 --> 28:20.700
这个道理吧

28:21.260 --> 28:21.420
好

28:21.420 --> 28:23.180
那么我现在就问大家一个问题

28:23.180 --> 28:24.460
你们看这个数组啊

28:25.580 --> 28:25.980
数组

28:27.100 --> 28:27.820
1 2 3

28:28.780 --> 28:30.220
数组它也有tostune

28:31.180 --> 28:31.580
但是呢

28:31.580 --> 28:32.940
它的tostune啊

28:32.940 --> 28:33.740
它得到了结果

28:33.740 --> 28:34.620
不是这种结果

28:35.580 --> 28:36.620
它是什么结果呢

28:36.620 --> 28:37.420
它是这种结果

28:38.860 --> 28:41.260
你们觉得最有可能的原因是啥

28:46.750 --> 28:48.190
为什么数组得到tostune

28:48.190 --> 28:49.550
得到的是这种结果

28:49.550 --> 28:52.990
跟我们那个opg的tostune不一样

28:53.550 --> 28:54.830
最有可能的原因是啥

28:59.150 --> 29:00.190
你就把这个玩意儿

29:00.670 --> 29:01.630
想象成数组

29:04.110 --> 29:05.070
是不是重写了

29:05.070 --> 29:06.430
它怎么重写的

29:06.430 --> 29:07.310
非常简单吧

29:07.390 --> 29:08.270
这个玩意儿是数组

29:08.270 --> 29:08.670
对吧

29:08.670 --> 29:10.110
我们通过6了一个数组

29:10.110 --> 29:11.230
这就是在6一个数组

29:12.270 --> 29:13.630
那么我们数组里边自己

29:13.630 --> 29:15.310
它这个对象自己有没有tostune没有

29:16.270 --> 29:17.070
它会去打找

29:17.070 --> 29:18.670
会去数组的原型上找

29:19.310 --> 29:19.870
有没有呢

29:21.230 --> 29:23.070
如果说它这里没有的话

29:23.070 --> 29:25.070
那它就继续会继续往上找

29:25.070 --> 29:26.670
找到opg的tostune

29:26.670 --> 29:29.070
那么opg的tostune肯定不是这个样子

29:29.070 --> 29:29.790
说明了啥

29:29.790 --> 29:31.230
说明最有可能的原因就是

29:31.230 --> 29:32.750
它在这里又加了一个tostune

29:33.390 --> 29:34.670
那么找到这它就不找了

29:34.670 --> 29:36.830
因为它找到这里已经找到tostune了

29:36.830 --> 29:37.550
这就是重写

29:38.190 --> 29:39.070
懂得意思吧

29:39.070 --> 29:40.030
就是重写

29:40.030 --> 29:41.470
所以说我们再来验证一下

29:41.470 --> 29:42.430
是不是这样子呢

29:42.430 --> 29:43.870
我们看一下它跟opg这次的

29:44.590 --> 29:45.870
tostune是不是一样的呢

29:46.830 --> 29:47.550
proto type

29:48.030 --> 29:48.510
tostune

29:49.070 --> 29:50.110
那肯定就不一样

29:52.190 --> 29:52.830
是不是force

29:54.430 --> 29:56.110
那么我们再来进一步验证

29:56.110 --> 29:57.310
是不是真的呀

29:57.310 --> 29:58.110
我们来看一下

29:58.670 --> 29:59.790
只需要去验证一下

29:59.790 --> 30:01.150
而如果在proto type上面

30:01.150 --> 30:02.190
有没有tostune就可以

30:04.220 --> 30:04.860
有没有呢

30:04.860 --> 30:05.580
是不是有

30:05.580 --> 30:06.300
说明啥

30:06.300 --> 30:07.660
说明已经板上钉钉了

30:07.660 --> 30:09.260
它在这里就给我加了一个tostune

30:10.060 --> 30:11.900
那么我这也在提示我们

30:11.900 --> 30:12.780
如果说

30:13.660 --> 30:14.140
嗯

30:14.540 --> 30:15.500
我们自己

30:16.380 --> 30:18.380
如果说自己的一个函数

30:18.380 --> 30:19.900
可不可以重写这个tostune

30:19.900 --> 30:20.540
可以

30:20.540 --> 30:22.540
在它的原型上就可以加一个tostune

30:23.900 --> 30:24.700
就这么简单

30:25.660 --> 30:27.500
那你在原型上加的东西

30:27.500 --> 30:28.620
那么就会被这些

30:28.620 --> 30:30.060
它新鲜创炼的对象

30:30.060 --> 30:30.860
都可以使用

30:31.900 --> 30:32.700
啊这就是

30:33.260 --> 30:33.500
呃

30:34.140 --> 30:35.500
原型链的概念

30:37.460 --> 30:38.660
好那么接下来

30:39.540 --> 30:40.260
就是一张

30:41.140 --> 30:41.700
神图了

30:42.260 --> 30:43.620
这个图了下去过后

30:43.620 --> 30:44.100
同学们

30:44.820 --> 30:46.980
你们把i把它保存到了

30:46.980 --> 30:47.620
保存到了

30:47.620 --> 30:48.580
好好收藏起来

30:49.540 --> 30:50.100
这个图

30:50.740 --> 30:51.620
看懂了过后

30:52.420 --> 30:54.420
你就把原型链彻底搞清楚了

30:56.260 --> 30:58.020
这就是完整的链条

30:58.900 --> 30:59.940
完整的链条怎么来

30:59.940 --> 31:00.900
怎么来看呢

31:01.460 --> 31:02.100
你看

31:02.100 --> 31:03.540
我们一步步看啊

31:03.540 --> 31:04.660
你看这一部分

31:04.660 --> 31:05.780
是不是就刚才我们解释了

31:05.780 --> 31:06.420
那个原型链

31:06.980 --> 31:08.180
这是你的自定义函数

31:08.660 --> 31:10.820
当然这个自定义函数也包括什么数组啊

31:10.820 --> 31:11.300
array

31:11.300 --> 31:11.940
对吧

31:12.260 --> 31:14.340
呃包括那个我们自己定一个函数a

31:14.340 --> 31:16.100
自己定一个函数user

31:16.100 --> 31:16.980
都是这样子吧

31:16.980 --> 31:17.380
你看

31:18.180 --> 31:20.180
通过它溜出来的对象

31:20.180 --> 31:22.180
它的隐释原型指向这

31:22.420 --> 31:23.380
这个没问题吧

31:23.380 --> 31:24.260
它的原型

31:25.140 --> 31:26.340
啊那么这个自定

31:26.340 --> 31:28.020
这个自定义函数的原型呢

31:28.020 --> 31:29.620
是通过Objects溜出来的

31:29.620 --> 31:30.740
所以它的隐释原型呢

31:30.740 --> 31:31.860
就指向上边

31:31.860 --> 31:32.980
Objects的原型

31:32.980 --> 31:34.580
那么它的隐释原型指向那

31:34.900 --> 31:36.660
那么我们看右边这一坨是啥

31:37.620 --> 31:38.260
好

31:38.260 --> 31:40.020
首先自定义函数

31:40.020 --> 31:41.860
这个函数又是哪来的

31:41.860 --> 31:42.900
什么讲过的

31:42.900 --> 31:44.260
函数通过溜谁的

31:44.260 --> 31:45.860
是不是溜方客型啊

31:46.660 --> 31:48.420
你看这个颜色就是函数

31:48.420 --> 31:49.700
函数是溜谁的

31:49.700 --> 31:51.700
溜一个方客型产生的

31:52.020 --> 31:53.300
而方客型是不是函数

31:53.300 --> 31:54.900
方客型它也是函数

31:55.300 --> 31:56.900
啊那么它又没有原型

31:56.900 --> 31:57.940
它也有原型

31:57.940 --> 31:59.540
就是方客型的原型

32:01.060 --> 32:01.860
对不对

32:01.860 --> 32:02.900
所以说

32:02.900 --> 32:04.340
这个我们自己的函数

32:04.340 --> 32:05.860
是通过溜方客型产生的

32:05.940 --> 32:07.700
因此呢我们自己的函数

32:07.700 --> 32:08.820
是不是也有隐释原型

32:08.820 --> 32:09.460
指向谁

32:09.460 --> 32:10.740
指向方客型的原型

32:12.340 --> 32:14.660
那就接下来就遇到一个问题了

32:14.660 --> 32:16.260
那它又哪来的呢

32:16.260 --> 32:17.140
它哪来的

32:18.820 --> 32:20.660
你不是说函数都是溜向吗

32:20.660 --> 32:22.180
那对象都是溜出来的吗

32:22.180 --> 32:23.380
那它又是溜谁呢

32:24.420 --> 32:25.940
那就说有一个击生蛋

32:25.940 --> 32:26.980
诞生机的问题了

32:28.580 --> 32:30.100
如果说它又去溜别的东西的话

32:30.100 --> 32:31.860
那别的东西又是哪来的呢

32:32.420 --> 32:33.300
对不对

32:33.300 --> 32:34.980
那么这个东西就无穷无尽了

32:35.060 --> 32:35.940
所以说

32:37.220 --> 32:39.220
V8引擎怎么处理的

32:40.180 --> 32:42.340
它在我们的那个解释器

32:42.340 --> 32:44.180
V8引擎启动的时候

32:44.180 --> 32:45.860
就给你安了一个函数的招

32:45.860 --> 32:46.900
你就这样理解

32:47.380 --> 32:48.900
这东西天生就有

32:50.100 --> 32:50.500
对吧

32:50.500 --> 32:51.460
天生就有

32:51.460 --> 32:53.060
它就是天生出来的

32:53.060 --> 32:54.260
这个我还也不容易

32:54.260 --> 32:54.900
不容易生疚了

32:54.900 --> 32:56.660
你不用去管它是哪来的了

32:56.660 --> 32:58.580
由于它是天生就自带的

32:58.580 --> 33:00.740
所以说它不需要溜任何东西出来

33:00.740 --> 33:02.420
这个函数是直接出来就有

33:03.380 --> 33:05.300
这个是创世纪之初

33:05.300 --> 33:06.980
宇宙当单身的时候它就有

33:07.860 --> 33:09.300
那里我问它哪来的

33:09.300 --> 33:10.420
就问不到了

33:10.420 --> 33:11.700
它就是创世神

33:11.700 --> 33:12.580
所以说呢

33:12.580 --> 33:14.340
它的引式原型比较特殊

33:14.340 --> 33:15.700
它就指向自己的原型

33:16.740 --> 33:18.260
就这个引式原型比较特殊

33:18.260 --> 33:19.300
它指向自己的原型

33:21.300 --> 33:21.540
好

33:21.540 --> 33:22.820
然后我们来来看

33:22.820 --> 33:25.220
那这个原型不也得是堆箱吗

33:25.220 --> 33:27.380
这个原型肯定是堆箱吗

33:27.380 --> 33:28.820
那这个堆箱又哪来的了

33:28.820 --> 33:30.180
是六奥伯特的产生的

33:31.140 --> 33:32.740
你不要去背这张图

33:32.740 --> 33:34.420
你背这张图你就死定了

33:34.420 --> 33:35.460
你背不住的

33:35.460 --> 33:37.460
你要去用逻辑去分析

33:37.460 --> 33:39.460
然后就算你不想用逻辑分析

33:39.460 --> 33:40.500
把这张图拿过去做题

33:40.500 --> 33:41.460
都没问题

33:41.460 --> 33:42.660
但是你不要去背啊

33:42.660 --> 33:43.700
这一背就云了

33:43.700 --> 33:46.100
你只要能看懂每一根线

33:46.100 --> 33:47.540
看懂是哪一意思就行了

33:47.540 --> 33:48.420
这个原型哪来的

33:48.420 --> 33:49.540
六奥伯特产生的

33:49.540 --> 33:51.540
那既然它是六奥伯特产生的

33:51.540 --> 33:52.740
那么它又没有引式原型

33:52.740 --> 33:53.300
它也有

33:53.300 --> 33:54.580
它的引式原型指向这种

33:57.060 --> 33:57.940
总的意思是

33:58.660 --> 34:00.660
那么奥伯特产生是一个函数吧

34:00.660 --> 34:01.780
那这个函数哪来的

34:01.780 --> 34:03.060
是六奥伯特产生的

34:03.060 --> 34:04.340
它又没有引式原型

34:04.340 --> 34:05.620
它也有引式原型

34:05.620 --> 34:06.900
云没同学们

34:06.900 --> 34:08.180
我知道同学们云云云

34:10.740 --> 34:13.300
反正你不要去背这张图

34:13.300 --> 34:14.580
你背这张图你肯定死

34:14.580 --> 34:15.860
我自己都得死

34:15.860 --> 34:17.140
你不要说你们了

34:17.140 --> 34:19.700
但是你们要能够看懂这个逻辑就可以了

34:20.980 --> 34:23.540
这张图可以解释很多的现象

34:24.820 --> 34:26.100
解释什么现象呢

34:26.420 --> 34:29.380
比方说我们把这个图弄过来

34:29.380 --> 34:30.660
首先解释这个现象

34:30.660 --> 34:36.830
一个函数a

34:38.110 --> 34:41.950
然后我们输出a

34:41.950 --> 34:44.270
有没有一个方法叫做

34:44.270 --> 34:45.390
扣

34:45.390 --> 34:47.550
有没有这个方法叫做扣呢

34:50.060 --> 34:51.180
有

34:51.180 --> 34:52.860
为什么有呢

34:52.860 --> 34:54.380
咱们看这个图

34:55.660 --> 34:57.020
s是啥

34:57.020 --> 34:58.220
s是函数

34:58.220 --> 34:59.340
我们这个s是啥

34:59.340 --> 35:00.300
s是函数

35:01.260 --> 35:02.300
然后呢

35:02.300 --> 35:04.300
它自己有没有扣这个方法

35:04.300 --> 35:05.740
这个成员有没有这个属性

35:05.740 --> 35:06.700
没有啊肯定没有

35:06.700 --> 35:07.980
除非你在这里写到什么

35:07.980 --> 35:09.260
写到adder扣

35:09.260 --> 35:10.300
对吧

35:10.300 --> 35:11.820
去给它写负责这个东西

35:11.820 --> 35:13.100
那这样子肯定有了

35:13.100 --> 35:14.380
这样就肯定有了

35:14.380 --> 35:15.660
但它自己肯定

35:15.660 --> 35:16.940
这里没有

35:16.940 --> 35:18.220
那没有怎么办呢

35:18.220 --> 35:20.540
它是不是要从引式原型找

35:20.540 --> 35:22.060
它也有原型链啊

35:22.060 --> 35:23.580
不是说只有这里才有原型链

35:23.580 --> 35:24.620
它这里也有啊

35:24.620 --> 35:25.900
引式原型去找这儿

35:25.900 --> 35:28.460
这里边有没有原型链

35:28.540 --> 35:31.020
由于这里边有扣

35:31.020 --> 35:32.300
你想想这个道理

35:32.300 --> 35:34.620
是不是所有的函数

35:34.620 --> 35:36.140
它都有这个成员扣

35:36.140 --> 35:37.420
对不对

35:37.420 --> 35:39.980
因为所有的函数都是通过它六它创建的

35:39.980 --> 35:41.260
所有的函数

35:41.260 --> 35:42.300
它的引式原型

35:42.300 --> 35:42.540
你看

35:42.540 --> 35:43.580
它是一个函数

35:43.580 --> 35:45.100
它的引式原型指向这儿

35:45.100 --> 35:46.380
它是一个函数

35:46.380 --> 35:47.660
它的引式原型指向这儿

35:47.660 --> 35:48.940
因此所有的函数

35:48.940 --> 35:50.220
它都有扣

35:50.220 --> 35:52.780
所以这个扣呢就等于

35:52.780 --> 35:54.060
等于谁呢

35:54.060 --> 35:55.340
等于方形的

35:56.060 --> 35:59.900
那么我们的数组这个儿位是不是函数

35:59.900 --> 36:03.970
那也是函数啊

36:03.970 --> 36:05.250
儿位是一个函数

36:05.250 --> 36:07.170
那么它里边有没有扣

36:07.170 --> 36:08.290
那肯定得有扣

36:08.290 --> 36:10.370
那等于这个

36:10.370 --> 36:12.370
也等于

36:12.370 --> 36:14.210
一个东西

36:14.210 --> 36:15.970
对吧

36:15.970 --> 36:17.810
好我们再来看啊

36:17.810 --> 36:19.330
那

36:19.330 --> 36:21.890
我如果说这儿有没有函数

36:21.890 --> 36:23.410
这儿有没有函数

36:23.410 --> 36:25.010
这儿有没有函数

36:25.010 --> 36:27.010
这儿有没有函数

36:27.170 --> 36:33.380
我如果说这样子写的呢

36:33.380 --> 36:36.500
我现在来回答这个问题

36:36.500 --> 36:39.900
这里有没有扣啊

36:39.900 --> 36:40.860
这个扣有没有啊

36:40.860 --> 36:47.140
你看这个图

36:47.140 --> 36:48.100
A有没有扣啊

36:48.100 --> 36:51.540
这个小A

36:51.540 --> 36:52.980
你就找一个原型链嘛

36:52.980 --> 36:54.420
你看这个A是啥

36:54.420 --> 36:58.720
小A是啥

36:58.720 --> 37:01.310
有没有啊

37:01.310 --> 37:02.670
小A是啥

37:02.670 --> 37:03.390
它是这个吗

37:03.390 --> 37:04.430
不是

37:04.430 --> 37:08.510
是通过这个溜出来的什么一个实力

37:08.510 --> 37:09.310
那自己有没有

37:09.310 --> 37:11.230
自己肯定没有

37:11.230 --> 37:12.670
自己没有上去找

37:12.670 --> 37:13.390
那这里有没有

37:13.390 --> 37:15.710
你看这里有没有吗

37:15.710 --> 37:17.390
自定义函数的原型上面

37:17.390 --> 37:19.230
就A点Prototype上面有没有扣吗

37:19.230 --> 37:20.110
我都没写对吧

37:20.110 --> 37:21.310
肯定是没有扣

37:21.310 --> 37:22.270
那继续往上找

37:22.270 --> 37:22.990
找到哪

37:22.990 --> 37:24.510
找到这个对象的原型

37:24.510 --> 37:25.390
这里有没有扣

37:25.390 --> 37:26.990
不好意思 这里没有

37:26.990 --> 37:27.550
扣在哪

37:27.550 --> 37:28.430
扣在这儿

37:28.430 --> 37:29.630
所以在这么条件上

37:29.630 --> 37:30.910
是不是找不到扣

37:30.910 --> 37:31.870
找不到它就没有

37:31.870 --> 37:36.180
那就少了地方

37:36.180 --> 37:36.820
好又来

37:36.820 --> 37:38.260
咱们来看

37:38.260 --> 37:45.660
A有没有突死军

37:45.660 --> 37:46.140
哎

37:46.140 --> 37:47.500
李永生红同学说得对

37:47.500 --> 37:50.060
这个刚才的小A是这个实力

37:50.060 --> 37:51.420
有没有突死军呢

37:54.000 --> 37:54.240
好

37:54.240 --> 37:55.760
那咱们来看一下

37:55.760 --> 37:56.560
A是啥

37:56.560 --> 37:58.320
A是自定义函数

37:58.320 --> 37:59.360
它自己有没有突死军

37:59.360 --> 38:00.960
这个成员没有

38:00.960 --> 38:01.760
找谁

38:01.760 --> 38:02.960
找方可喜这个原型

38:02.960 --> 38:03.200
对吧

38:03.200 --> 38:03.760
隐私原型嘛

38:03.760 --> 38:04.720
找到

38:04.720 --> 38:05.600
这里有没有突死军

38:05.600 --> 38:06.160
不好意思

38:06.160 --> 38:06.560
这里

38:06.560 --> 38:07.760
高复里面

38:07.760 --> 38:08.320
这里没有

38:10.160 --> 38:10.400
哎

38:10.400 --> 38:11.520
方可喜里面有没有突死军

38:11.520 --> 38:12.560
我都忘了

38:12.560 --> 38:13.120
呃

38:14.320 --> 38:15.520
方可喜我看一下啊

38:15.520 --> 38:16.640
Prototype

38:16.640 --> 38:17.200
突死军

38:19.200 --> 38:19.760
嗯

38:19.760 --> 38:20.560
是不是等于

38:21.520 --> 38:23.120
他有没有重写过啊

38:23.120 --> 38:24.080
Prototype

38:24.080 --> 38:25.120
突死军

38:25.120 --> 38:25.920
Force

38:30.110 --> 38:30.510
啊

38:30.510 --> 38:31.790
他还重写过的

38:31.790 --> 38:32.670
那实际上

38:32.670 --> 38:33.630
那说明说明啥

38:33.630 --> 38:34.830
说明这里没有突死军

38:34.830 --> 38:36.030
这里面就有突死军

38:36.030 --> 38:37.870
那么我们要说的事情呢

38:37.870 --> 38:40.110
就是如果说这里没有突死军

38:40.110 --> 38:41.630
他还要继续往上找

38:41.630 --> 38:42.990
因为这里有个隐私原型

38:42.990 --> 38:44.190
他还要找到这儿

38:45.470 --> 38:46.510
说明了啥

38:46.510 --> 38:47.790
从那个图里边我就看

38:47.790 --> 38:49.070
我们就可以看出

38:49.710 --> 38:50.990
这个玩意儿

38:50.990 --> 38:52.590
是不是就是原型的

38:52.590 --> 38:54.510
就是原型链的终点

38:56.270 --> 38:56.750
对吧

38:56.750 --> 38:58.110
所以原型链的终点

38:58.110 --> 38:59.950
无论你是这个东西

38:59.950 --> 39:01.150
还是你一个函数

39:01.950 --> 39:02.990
你绕来绕去

39:02.990 --> 39:03.630
转一圈

39:03.630 --> 39:04.910
你就都会会找到这儿

39:05.470 --> 39:07.150
所以说这里边的成员

39:07.150 --> 39:09.310
是所有的对象都有的东西

39:10.030 --> 39:10.910
除非你做了一些

39:10.910 --> 39:12.350
稍稍做改的原型链的

39:12.350 --> 39:13.070
几下

39:13.070 --> 39:13.710
否则的话

39:14.430 --> 39:15.150
这里的原

39:15.150 --> 39:16.510
这这个节点

39:16.510 --> 39:18.030
是所有解释里面

39:18.030 --> 39:19.150
所有对象

39:19.150 --> 39:20.350
他的原型链终点

39:21.070 --> 39:22.430
也就这里边的成员

39:22.510 --> 39:23.710
所有的对象都有

39:23.710 --> 39:24.430
咱们来看吧

39:25.310 --> 39:26.030
我们就可以看一下

39:26.030 --> 39:27.230
Object的Prototype

39:27.950 --> 39:28.910
他里边到底有啥

39:30.510 --> 39:31.150
有啥呢

39:31.790 --> 39:32.750
是不是图是GN

39:32.750 --> 39:33.790
还有什么Value

39:33.790 --> 39:35.630
我是我们之前解释过的

39:35.630 --> 39:36.350
还有什么意思

39:36.350 --> 39:37.390
Prototype

39:37.390 --> 39:38.990
还有什么这个这些乱七八糟的

39:39.710 --> 39:40.110
有些人

39:40.110 --> 39:40.750
大家知道

39:40.750 --> 39:41.550
有些大家不知道

39:42.030 --> 39:43.150
甭管是啥吧

39:43.150 --> 39:43.710
然后这个

39:44.430 --> 39:46.030
Value或者是这个

39:46.030 --> 39:47.310
ToLocalOstGN

39:47.870 --> 39:48.670
这个函数

39:48.670 --> 39:49.710
那所有对象都有

39:50.110 --> 39:51.150
你自己定一个对象

39:51.950 --> 39:52.510
有没有呢

39:53.230 --> 39:53.550
有

39:54.350 --> 39:55.310
你定一个函数

40:00.340 --> 40:01.140
有没有呢

40:01.140 --> 40:01.380
有

40:02.900 --> 40:03.220
啊

40:03.220 --> 40:04.260
就是就这个东西

40:05.300 --> 40:05.940
有没有呢

40:07.140 --> 40:07.380
有

40:09.140 --> 40:10.020
就是说明了

40:10.020 --> 40:10.980
说明这个玩意儿

40:10.980 --> 40:12.500
就是这个节点

40:12.500 --> 40:13.460
是所有对象

40:13.460 --> 40:14.500
他最终都会找到这

40:15.060 --> 40:16.020
这里边有的东西

40:16.020 --> 40:16.900
所有的对象都有

40:17.620 --> 40:18.500
那就这么个意思

40:19.060 --> 40:20.020
这就是原型链

40:21.860 --> 40:23.140
那么原型链这个链条

40:23.140 --> 40:24.660
我们搞清楚了之后

40:25.540 --> 40:26.420
那我们来做

40:26.420 --> 40:28.180
我们今天晚上练习的第一道题

40:32.450 --> 40:33.650
这第一道题呢

40:33.650 --> 40:34.370
是我出的

40:36.290 --> 40:38.210
我觉得把这道题弄清楚了

40:38.210 --> 40:39.730
那里原型链这一块呢

40:41.730 --> 40:43.890
至少整个链条里搞得非常清楚了

40:44.450 --> 40:45.410
应用我们再说

40:47.010 --> 40:47.410
好

40:47.890 --> 40:48.290
来吧

40:50.210 --> 40:50.690
U字儿

40:51.650 --> 40:52.370
一个函数

40:52.370 --> 40:53.650
就是我们的自定义函数

40:55.090 --> 40:56.690
它的原型里边有个什么

40:56.690 --> 40:58.130
在这里是不是有个say hello

40:58.130 --> 40:58.610
记住啊

40:58.690 --> 40:59.410
这里有个say hello

40:59.410 --> 41:01.410
我们能能够有别的颜色标净一下吧

41:03.420 --> 41:04.220
这里有个say hello

41:06.960 --> 41:07.280
好

41:07.280 --> 41:07.760
然后呢

41:09.760 --> 41:10.880
创建了两个对象

41:10.880 --> 41:11.760
U1U2

41:11.760 --> 41:13.360
那这里相当于是不是有两个实力

41:14.000 --> 41:14.640
一个U1

41:15.200 --> 41:15.840
一个U2

41:15.840 --> 41:17.360
他们都是通过6来创建的

41:17.360 --> 41:17.680
对吧

41:18.480 --> 41:18.880
好

41:18.880 --> 41:19.840
来第一个

41:19.840 --> 41:21.280
U1.say hello

41:21.280 --> 41:22.880
等不等于U2.say hello

41:24.880 --> 41:25.280
U1

41:26.720 --> 41:28.640
U1自己有没有say hello没有

41:28.640 --> 41:30.080
U2有没有say hello没有

41:30.640 --> 41:31.680
那么它就从哪里找

41:31.680 --> 41:32.560
是不是从这里找

41:32.560 --> 41:33.600
这里有没有say hello

41:33.600 --> 41:34.000
U

41:35.600 --> 41:36.480
所以说

41:36.480 --> 41:36.960
第一个

41:38.160 --> 41:38.720
是不是true

41:40.000 --> 41:40.640
对吧

41:40.640 --> 41:41.280
这个是true

41:42.720 --> 41:43.040
好

41:43.040 --> 41:43.440
第二个

41:44.160 --> 41:45.520
U2.prototype

41:46.160 --> 41:48.320
等不等于方形的prototype

41:48.320 --> 41:48.720
看图

41:50.720 --> 41:52.080
U2.prototype

41:52.080 --> 41:52.640
U2是谁

41:52.640 --> 41:53.280
U2是这个

41:54.400 --> 41:54.720
对吧

41:54.720 --> 41:55.440
是这个

41:55.440 --> 41:56.560
它的prototype是哪

41:56.560 --> 41:56.960
是这个

41:58.560 --> 41:59.440
方形是哪

41:59.520 --> 42:00.320
方形是这个

42:01.200 --> 42:02.480
prototype是啥

42:02.480 --> 42:03.440
是这个

42:03.440 --> 42:04.240
能相当吗

42:04.240 --> 42:05.280
它肯定不能相当

42:05.920 --> 42:07.360
说这个是 false

42:07.360 --> 42:08.240
一看的图

42:08.240 --> 42:09.040
无必的信息

42:10.320 --> 42:10.880
好

42:10.880 --> 42:11.760
再下一个

42:11.760 --> 42:15.040
U2.pro隐私原型

42:16.400 --> 42:18.640
是不是等于方形的prototype

42:18.640 --> 42:19.600
那你这个看图吧

42:20.160 --> 42:20.880
U2是谁

42:20.880 --> 42:21.440
是这个

42:21.440 --> 42:22.320
隐私原型是谁

42:22.960 --> 42:24.080
隐私原型是这个

42:25.040 --> 42:26.000
那么方形是谁

42:26.000 --> 42:26.480
是这个

42:26.480 --> 42:27.120
隐私原型

42:27.120 --> 42:28.240
它的原型是谁

42:28.240 --> 42:28.960
是这个

42:29.120 --> 42:29.680
是不一样的

42:33.120 --> 42:33.200
好

42:33.200 --> 42:33.760
下面这个

42:34.560 --> 42:36.160
U2.隐私原型

42:37.600 --> 42:39.520
是不是等于方形的隐私原型

42:39.520 --> 42:40.320
一样的

42:40.320 --> 42:41.440
U2.隐私原型

42:42.000 --> 42:43.520
方形的隐私原型

42:43.920 --> 42:44.480
是吧

42:44.480 --> 42:44.960
一样的

42:45.360 --> 42:45.520
去

42:46.560 --> 42:46.880
好

42:46.880 --> 42:47.440
下面这个

42:48.160 --> 42:49.520
U1的隐私原型

42:49.520 --> 42:50.560
因为这里有两个

42:50.560 --> 42:51.120
两个实例

42:52.080 --> 42:52.800
U1 U2

42:54.320 --> 42:55.440
U1的隐私原型

42:55.440 --> 42:55.840
是不是这个

42:56.960 --> 42:58.080
U2的隐私原型

42:58.160 --> 42:59.280
是不是还是这个

43:01.120 --> 43:01.440
是吧

43:01.440 --> 43:02.320
说这个是出

43:03.680 --> 43:03.920
好

43:03.920 --> 43:04.240
再来

43:04.960 --> 43:06.240
U1的隐私原型

43:06.960 --> 43:07.680
U1是这个

43:08.320 --> 43:09.200
隐私原型是这个

43:10.080 --> 43:13.200
是不是等于U2的隐私原型

43:13.200 --> 43:13.920
U2是这个

43:13.920 --> 43:14.960
隐私原型是这个

43:15.520 --> 43:16.720
那这个等于这个吗

43:16.720 --> 43:17.040
不等

43:17.680 --> 43:18.720
所以说这个是force

43:20.830 --> 43:21.790
不讲了吧

43:21.790 --> 43:22.670
你们自己下来

43:23.230 --> 43:24.110
把剩下来做完

43:25.070 --> 43:25.870
按照这个图

43:25.870 --> 43:26.430
没问题吧

43:27.230 --> 43:28.670
看能不能做出来了

43:28.670 --> 43:29.310
应该没问题吧

43:30.110 --> 43:31.550
你就用这个东西去套

43:32.350 --> 43:33.230
就是最终的结果

43:33.230 --> 43:34.670
你看前面肯定是没问题的

43:34.670 --> 43:35.310
True Force

43:35.310 --> 43:35.870
True

43:35.870 --> 43:36.270
True Force

43:37.470 --> 43:37.710
好

43:37.710 --> 43:38.510
没问题

43:38.510 --> 43:39.710
后边两个你们自己去说

43:40.990 --> 43:41.470
好

43:41.470 --> 43:42.750
这是第一道题

43:42.750 --> 43:43.870
第二道题我们来看一下

43:45.310 --> 43:47.150
它用的一个关键字叫East Tensile

43:48.350 --> 43:49.630
East Tensile有什么意思呢

43:51.310 --> 43:52.350
这里我给大家解释一下

43:53.230 --> 43:54.670
这个关键字是这么一个意思

43:54.670 --> 43:56.190
它的语法是这样子

43:56.190 --> 43:57.550
前面写一个东西

43:57.550 --> 43:59.150
然后后边East Tensile

43:59.230 --> 44:00.350
后边一个东西

44:00.350 --> 44:01.470
前提条件

44:01.470 --> 44:04.350
这个地方的东西必须是一个函数

44:05.950 --> 44:07.150
这个玩意儿必须是一个函数

44:07.150 --> 44:08.190
不是函数要报错的

44:08.190 --> 44:09.390
它没法判断

44:09.390 --> 44:10.670
它判断的是啥呢

44:11.230 --> 44:13.230
它检查A的圆形链

44:14.030 --> 44:16.750
看那个圆形链上有没有B的圆形

44:16.750 --> 44:17.550
就这么个意思

44:18.510 --> 44:19.390
比方说几个例子

44:20.110 --> 44:21.310
那比方说这里呢

44:21.310 --> 44:23.230
我们这里的自定义函数

44:23.230 --> 44:24.750
比方说这里自定函数是U字

44:25.790 --> 44:27.310
我们这里通过6一个U字

44:27.310 --> 44:28.190
创建了一个U1

44:29.390 --> 44:30.430
比方说

44:30.430 --> 44:32.110
我们丢了U1

44:32.110 --> 44:33.630
通过6一个U字

44:33.630 --> 44:34.910
创建了U1

44:34.910 --> 44:38.350
那么我们判断U1East Tensile

44:38.350 --> 44:39.390
U字

44:39.390 --> 44:41.390
它会返回一个True还是Force呢

44:41.710 --> 44:42.590
它会返回True

44:42.590 --> 44:43.230
为什么呢

44:43.230 --> 44:44.110
它找的是什么

44:44.110 --> 44:46.190
找的是U1的圆形链

44:47.070 --> 44:47.950
从这里开始找

44:47.950 --> 44:48.510
对吧

44:49.390 --> 44:50.350
圆形链

44:51.550 --> 44:52.350
圆形链

44:52.350 --> 44:54.190
这个链条上有没有什么

44:54.190 --> 44:56.110
有没有U字的圆形

44:56.110 --> 44:57.150
有没有这个的圆形

44:57.150 --> 44:57.630
有没有了

44:57.630 --> 44:58.350
那当然有了

44:59.310 --> 45:01.070
就判断了是什么

45:01.070 --> 45:01.550
True

45:01.550 --> 45:02.510
那我现在再问

45:02.510 --> 45:03.150
如果说这个

45:03.150 --> 45:04.670
我写的是Orbit这个词呢

45:04.670 --> 45:05.710
也是True

45:05.710 --> 45:06.350
为什么呢

45:06.350 --> 45:06.830
你看啊

45:07.630 --> 45:08.830
它的圆形链上

45:08.830 --> 45:11.790
有没有Orbit这个词的圆形呢

45:11.790 --> 45:13.150
Orbit这个词的圆形

45:13.150 --> 45:14.110
不在这吗

45:14.110 --> 45:14.830
有没有呢

45:14.830 --> 45:15.390
有

45:15.390 --> 45:16.990
所以说它返回来也是True

45:18.190 --> 45:18.590
对吧

45:18.590 --> 45:20.110
那如果说判断有没有放

45:20.110 --> 45:21.710
这是不是一些方形的圆形呢

45:21.710 --> 45:22.430
那就没有

45:22.430 --> 45:24.670
这条链上是没有这个方形的圆形的

45:25.470 --> 45:26.510
就这么简单

45:26.510 --> 45:27.950
这就是East Tensile

45:28.190 --> 45:29.470
判断的圆形链

45:29.470 --> 45:29.790
好

45:29.790 --> 45:30.830
咱们来做到这道题

45:33.220 --> 45:33.780
第一题

45:34.420 --> 45:34.820
第一个

45:36.500 --> 45:37.620
问你一个空对象

45:38.820 --> 45:40.100
East Tensile Object

45:42.830 --> 45:43.950
这里是True还是Force呢

45:50.260 --> 45:51.540
是不是一定是True

45:51.540 --> 45:52.420
为什么一定是True

45:52.980 --> 45:53.780
我们刚才说了

45:53.780 --> 45:55.220
只要你不去搞一些烧烧桌

45:55.780 --> 45:56.900
你是一个正常的人

45:56.900 --> 45:58.100
然后一正常的操作

45:58.820 --> 45:59.940
所有的对象

45:59.940 --> 46:01.300
不管你是哪来的对象

46:01.300 --> 46:02.740
函数也是对象

46:02.740 --> 46:03.540
数主也是对象

46:03.540 --> 46:04.740
自己定义的函数创建的

46:04.740 --> 46:05.620
都全是对象

46:06.340 --> 46:08.340
它的链条上总之有它的圆形

46:09.860 --> 46:10.820
都会有它的圆形

46:12.100 --> 46:12.740
知道了

46:12.740 --> 46:13.460
所以说

46:13.460 --> 46:14.740
那么这个肯定是True

46:16.100 --> 46:17.300
甭把你一个对象哪来的

46:17.940 --> 46:18.260
好

46:18.260 --> 46:18.660
第二个

46:20.100 --> 46:21.380
这个玩意的True是True

46:22.820 --> 46:23.940
是不是方形

46:24.660 --> 46:25.540
这个玩意有点烧

46:26.500 --> 46:26.740
好

46:26.740 --> 46:27.460
我们来看一下

46:27.460 --> 46:29.700
这个玩意一个怎么来解

46:29.700 --> 46:30.500
我还是把这个图

46:31.300 --> 46:32.020
我还是把这个图

46:32.820 --> 46:33.780
粘出来

46:36.340 --> 46:37.540
有这个图就好解多了

46:38.580 --> 46:39.780
你是一个空对象

46:39.780 --> 46:40.100
对吧

46:40.820 --> 46:41.780
你是一个空对象

46:44.060 --> 46:45.660
对象里边不得有True实运方法

46:46.700 --> 46:47.900
True实运方法哪来的

46:48.860 --> 46:49.420
哪来的

46:50.380 --> 46:51.420
是不是在这里边了

46:52.140 --> 46:53.900
在OpG的圆形里边一个属性

46:53.900 --> 46:54.380
对吧

46:54.380 --> 46:55.420
属性是一个函数

46:55.420 --> 46:57.260
总之这个玩意是不是函数

46:57.740 --> 46:58.620
它肯定是函数

46:59.500 --> 47:01.180
你甭管它都放在哪里的函数

47:01.180 --> 47:02.060
它总之是函数

47:04.480 --> 47:05.200
那你说吧

47:07.040 --> 47:07.600
你说吧

47:07.600 --> 47:08.480
函数哪来的

47:09.840 --> 47:10.960
这也是函数

47:10.960 --> 47:11.680
这个也是函数

47:11.680 --> 47:12.400
函数哪来的

47:12.880 --> 47:14.240
函数就6它出来的

47:15.440 --> 47:16.400
6它出来的

47:16.960 --> 47:18.480
只要是函数都是6它出来的

47:19.760 --> 47:20.800
这个是没有例外的

47:21.280 --> 47:21.920
没有例外

47:22.400 --> 47:23.520
除非是它自己

47:23.520 --> 47:25.200
自己就天生就有

47:25.680 --> 47:26.960
其他的函数没有任何例外

47:27.520 --> 47:29.040
因为你不是6它出来的东西

47:29.040 --> 47:29.840
就不叫函数了

47:30.800 --> 47:32.080
说函数一定是6它出来的

47:32.080 --> 47:32.720
那你说吧

47:33.680 --> 47:35.120
它的隐私元秀

47:35.600 --> 47:37.120
念条是啥

47:37.440 --> 47:39.120
念条一是先指向这个

47:39.120 --> 47:40.160
再指向这个

47:41.360 --> 47:42.320
这是它的念条

47:42.320 --> 47:43.280
说一说

47:43.280 --> 47:44.880
念条上有没有方式啊

47:45.600 --> 47:46.320
有啊

47:46.800 --> 47:48.160
有没有方式的元秀

47:48.160 --> 47:48.640
有啊

47:53.220 --> 47:54.260
啊不这个词

47:54.260 --> 47:55.300
你是天生有方式

47:55.300 --> 47:56.020
它肯定啊

47:56.020 --> 47:56.900
它是不是函数

47:56.900 --> 47:57.620
它是函数

47:58.260 --> 48:00.260
函数那念条上肯定有方式

48:00.900 --> 48:01.220
对吧

48:01.220 --> 48:02.580
因为它就是6方式来的

48:03.940 --> 48:04.980
就是它生出来的

48:04.980 --> 48:05.300
对吧

48:05.300 --> 48:06.180
就是它生出来的

48:09.780 --> 48:11.300
其实有的时候呢

48:11.300 --> 48:12.740
我们还有一个小技巧

48:13.140 --> 48:13.620
同学们

48:14.340 --> 48:16.180
因是天色为一个小技巧

48:16.660 --> 48:17.620
什么小技巧呢

48:21.230 --> 48:22.430
一般换成汉字

48:22.910 --> 48:23.390
是

48:24.670 --> 48:25.310
就可以了

48:28.140 --> 48:29.500
当然这是小技巧的话

48:30.300 --> 48:32.140
它不一定百分之百的准确

48:32.380 --> 48:32.860
为什么呢

48:32.860 --> 48:33.740
因为它的代码

48:34.380 --> 48:35.180
稍微给你

48:35.900 --> 48:37.180
给你绕些弯的话

48:37.180 --> 48:37.900
还不一定了

48:38.220 --> 48:38.700
但是呢

48:38.700 --> 48:39.580
绝大部分情况下

48:39.580 --> 48:40.620
就是只要它不绕理

48:40.620 --> 48:41.580
它不故意整理

48:42.300 --> 48:43.740
我不建议大家做面试题的时候

48:43.740 --> 48:44.060
这样做

48:44.060 --> 48:45.740
但是你平时写代码的时候

48:45.740 --> 48:46.460
你可以这样读

48:47.180 --> 48:48.780
把因是天色为读成是

48:49.180 --> 48:49.740
就可以了

48:51.020 --> 48:52.060
因为你自己写代码

48:52.060 --> 48:53.740
不可能你去整理自己

48:53.740 --> 48:54.380
对吧

48:54.380 --> 48:55.740
你都是写的这正常的代码

48:56.220 --> 48:57.900
那么百分之九十九的情况下

48:57.900 --> 48:58.620
它是成立的

48:59.100 --> 48:59.980
你把它读成是

49:01.260 --> 49:02.540
这个玩意是不是对象

49:02.540 --> 49:03.260
那是对象啊

49:03.900 --> 49:04.700
这个突出军

49:04.700 --> 49:06.060
突出军是不是含述

49:06.060 --> 49:06.700
是含述啊

49:07.180 --> 49:08.620
啊那几个读是不是含述

49:08.620 --> 49:09.740
那肯定得是含述啊

49:09.740 --> 49:11.180
这个玩意不就是含述吗

49:11.180 --> 49:12.300
方形是不是对象

49:12.300 --> 49:13.420
所有的东西都是对象

49:13.420 --> 49:14.380
那肯定是对象啊

49:14.940 --> 49:15.260
对吧

49:15.260 --> 49:16.140
一把它读成是

49:16.620 --> 49:17.500
就很容易结出来

49:20.210 --> 49:21.010
我再说一次啊

49:21.010 --> 49:21.970
做面试题的时候

49:21.970 --> 49:23.010
我不建议你这样做

49:23.010 --> 49:24.210
但是平时写代码的时候

49:24.210 --> 49:24.690
你读

49:24.690 --> 49:25.250
读代码的时候

49:25.250 --> 49:26.290
你把它读成是

49:26.290 --> 49:26.770
就可以了

49:29.060 --> 49:29.700
平多数

49:33.100 --> 49:34.380
其实这个玩意是啥呀

49:37.570 --> 49:39.170
它就在看继承

49:39.170 --> 49:41.570
就是从语义上来讲啊

49:41.570 --> 49:42.690
语义上来讲

49:42.690 --> 49:44.450
它就看的是继承关系

49:45.490 --> 49:46.610
看的就是继承关系

49:46.610 --> 49:49.010
而继承关系在我们语义上

49:49.010 --> 49:50.050
读的就是是

49:51.250 --> 49:52.530
一个东西是一个东西

49:53.330 --> 49:53.970
两个类型

49:53.970 --> 49:54.450
A类型

49:54.530 --> 49:55.250
是B类型

49:55.250 --> 49:56.210
那么A就继承B

49:57.650 --> 49:58.690
这就是语义上的

49:58.690 --> 49:59.970
为什么这里可以写成是

49:59.970 --> 50:00.690
就这个原因啊

50:01.970 --> 50:03.010
当然这也就受到

50:03.010 --> 50:04.290
另外一个知识了

50:04.290 --> 50:04.850
就继承

50:05.490 --> 50:05.970
好 看照

50:07.650 --> 50:08.610
进入了一道面试题

50:10.900 --> 50:12.420
方个形里边给它加了一个A

50:13.380 --> 50:14.500
这里给它加了一个A

50:15.860 --> 50:16.340
然后呢

50:16.340 --> 50:17.540
O不仅是给它加了一个B

50:18.740 --> 50:19.300
加了一个B

50:20.820 --> 50:21.140
来吧

50:22.180 --> 50:23.460
然后自己有一个函数A

50:24.180 --> 50:25.540
自己有一个函数A

50:25.540 --> 50:26.580
然后创建了一个A

50:26.580 --> 50:27.460
那A就是

50:27.460 --> 50:28.180
大A就是这个

50:28.180 --> 50:28.980
小A就是这个

50:28.980 --> 50:29.540
对吧

50:29.540 --> 50:31.780
然后输出A.A

50:32.660 --> 50:34.340
它里边自己有没有A

50:34.340 --> 50:34.820
没有

50:35.380 --> 50:36.420
这里边有没有A

50:36.420 --> 50:37.220
没有

50:37.220 --> 50:38.580
这里边有没有A

50:38.580 --> 50:39.460
没有

50:40.660 --> 50:41.380
那你说吧

50:42.420 --> 50:43.220
就没了

50:43.220 --> 50:43.700
对吧

50:43.700 --> 50:44.980
这个反应就只能是

50:44.980 --> 50:45.220
NG犯的

50:45.220 --> 50:46.340
A.B

50:46.340 --> 50:47.540
那这里自己有没有B

50:47.540 --> 50:48.100
没有

50:48.100 --> 50:49.060
这里有没有B

50:49.060 --> 50:49.540
没有

50:49.540 --> 50:50.340
这里没有B

50:50.340 --> 50:50.980
有

50:50.980 --> 50:52.340
所以说这里第一句话

50:52.660 --> 50:53.620
NG犯

50:53.620 --> 50:54.500
2

50:54.500 --> 50:56.180
还是很好理解的

50:56.180 --> 50:56.820
对吧

50:56.820 --> 50:58.260
然后就有了这张图

50:58.260 --> 50:59.220
这个题就跟

50:59.220 --> 51:00.260
就非常幼稚了

51:00.260 --> 51:00.740
对吧

51:00.740 --> 51:01.860
这这种题就非常幼稚了

51:01.860 --> 51:03.140
还没有我刚才给你出来的

51:03.140 --> 51:03.540
OK

51:03.540 --> 51:04.820
有点几乎还讲

51:04.820 --> 51:05.460
好

51:05.460 --> 51:06.340
那么现在呢

51:06.340 --> 51:07.300
看这下面

51:08.020 --> 51:08.580
大A

51:08.580 --> 51:09.700
大A是不是这个玩意儿

51:09.700 --> 51:10.980
它自己有没有A

51:11.620 --> 51:12.340
没有

51:12.340 --> 51:13.300
那这里没有A

51:13.300 --> 51:14.340
这里是有个A的

51:14.340 --> 51:15.220
刚才写的的

51:15.220 --> 51:16.180
这里是有个A的

51:16.180 --> 51:17.060
说这里有A

51:17.060 --> 51:18.260
A等于1

51:18.260 --> 51:20.020
它说说说这里是1

51:22.660 --> 51:23.780
啊

51:23.780 --> 51:24.660
有图就能做

51:24.660 --> 51:25.300
对吧

51:25.300 --> 51:26.580
图忘了就来了

51:26.580 --> 51:28.100
那么这里还是

51:28.100 --> 51:29.780
第一个不要去背

51:29.780 --> 51:30.740
你你清楚

51:30.740 --> 51:31.620
这个图哪来的

51:31.620 --> 51:32.100
同学们

51:32.100 --> 51:33.060
你们知道

51:33.060 --> 51:33.700
第一

51:33.700 --> 51:34.740
我背不住这个图

51:34.740 --> 51:35.460
我背不下来

51:36.740 --> 51:37.220
第二

51:37.220 --> 51:38.420
这个图是我自己画的

51:39.460 --> 51:40.260
也好神奇啊

51:40.260 --> 51:40.820
对吧

51:40.820 --> 51:41.460
你背不下来

51:41.460 --> 51:42.900
你怎么画出来的呢

51:42.900 --> 51:44.260
因为我是按照逻辑理解

51:44.260 --> 51:44.820
画出来的

51:45.540 --> 51:46.420
我先画一个

51:46.420 --> 51:47.460
我知道这个程序里边

51:47.460 --> 51:48.180
一定有方式

51:48.980 --> 51:49.860
程序里边一定有

51:49.860 --> 51:50.420
objects

51:51.380 --> 51:52.500
程序里边一定

51:52.500 --> 51:54.500
可能会有这些自定义函数

51:54.500 --> 51:56.020
我就可以把这三个画出来

51:56.020 --> 51:56.900
然后我就开始想了

51:58.100 --> 52:00.100
每个函数不得有圆形吗

52:00.100 --> 52:01.780
那自定义函数得有圆形吗

52:01.780 --> 52:02.980
方式得有圆形吗

52:02.980 --> 52:04.020
Object得有圆形吗

52:04.020 --> 52:05.300
所以说这三个我就画出来了

52:06.340 --> 52:07.540
那我就开始想了

52:07.540 --> 52:08.820
你这个函数哪来的呀

52:08.820 --> 52:09.940
那你一定是6

52:09.940 --> 52:10.980
方式创建的呀

52:10.980 --> 52:12.820
所以说这里有个6就画出来了

52:12.820 --> 52:13.460
然后呢

52:13.460 --> 52:14.580
你既然是6它出来的

52:14.580 --> 52:15.940
那它的影视圆形

52:15.940 --> 52:17.380
不得指向它吗

52:17.380 --> 52:17.780
对吧

52:17.780 --> 52:19.300
通过逻辑画出来的

52:19.300 --> 52:20.340
我背不住的

52:21.300 --> 52:22.580
哈哈哈

52:22.580 --> 52:24.180
画下去无敌了

52:24.180 --> 52:25.140
然后下面这个

52:26.020 --> 52:26.580
下面这个

52:28.500 --> 52:29.060
a.a

52:29.060 --> 52:29.860
大写的a.a

52:30.580 --> 52:31.700
那这里就是1的啊

52:31.700 --> 52:32.340
刚才说了

52:32.340 --> 52:33.540
那大写的a.b呢

52:34.100 --> 52:34.660
有没有呢

52:34.660 --> 52:35.300
有啊

52:35.300 --> 52:37.060
它自己没有

52:37.060 --> 52:38.260
这里也没有

52:38.260 --> 52:38.980
说往这上

52:40.740 --> 52:41.620
那这里有没有呢

52:41.620 --> 52:42.020
这里有

52:42.660 --> 52:43.700
那就是2

52:43.700 --> 52:44.500
所以这个输出呢

52:44.500 --> 52:45.780
就是 on 第三二一二

52:48.180 --> 52:48.980
有了这张图

52:49.140 --> 52:50.180
要做这种情形

52:50.180 --> 52:51.380
跟调打小朋友一样

52:51.380 --> 52:51.620
对吧

52:51.620 --> 52:52.180
非常简单

52:54.020 --> 52:54.500
好了

52:54.500 --> 52:55.300
那么最后呢

52:57.460 --> 52:58.740
我来说一下这个

52:58.740 --> 52:59.940
原型链维讲完了啊

53:00.820 --> 53:01.380
说一下这个

53:01.380 --> 53:01.780
哎

53:01.780 --> 53:03.460
我们刚才课前的时候

53:03.460 --> 53:04.420
说给大家

53:04.420 --> 53:05.780
我问了一下大家吗

53:05.780 --> 53:06.340
然后呢

53:06.340 --> 53:07.620
我被吓到了

53:07.620 --> 53:08.900
说说有点被吓到了啊

53:10.100 --> 53:10.420
啊

53:11.860 --> 53:12.340
继承

53:13.140 --> 53:15.140
有人可能不知道什么叫继承啊

53:16.020 --> 53:16.420
嗯

53:17.540 --> 53:18.660
我简单说一下吧

53:18.740 --> 53:19.940
这也肯定没有时间

53:19.940 --> 53:21.380
去展开说了

53:21.380 --> 53:21.540
啊

53:21.540 --> 53:22.660
继承是面向对象里面

53:22.660 --> 53:23.380
一个概念啊

53:24.020 --> 53:24.900
嗯

53:24.900 --> 53:27.140
简单说就是有两种类型啊

53:27.140 --> 53:28.020
他们

53:28.020 --> 53:28.900
行为上

53:28.900 --> 53:30.420
成员上都差不多

53:30.420 --> 53:31.300
我们可能会形成

53:31.300 --> 53:32.500
一种继承关系

53:32.500 --> 53:33.300
比方啥意思呢

53:33.300 --> 53:34.340
比方说我们有一个

53:35.060 --> 53:35.780
有一个用户

53:36.660 --> 53:38.020
还有一个vipe用户

53:39.860 --> 53:40.180
对吧

53:40.820 --> 53:41.940
有两种用户

53:41.940 --> 53:42.980
一种是普通用户

53:42.980 --> 53:44.420
一种是vipe用户

53:44.420 --> 53:45.380
那你想啊

53:45.380 --> 53:46.580
普通用户有的东西

53:46.580 --> 53:47.700
是不是vipe用户都有

53:49.620 --> 53:50.500
对不对

53:50.500 --> 53:51.860
他们两个都都是用户嘛

53:52.420 --> 53:53.220
普通用户有的

53:53.220 --> 53:54.580
vipe用户肯定都有

53:54.580 --> 53:56.100
比方普通用户有啥呢

53:56.100 --> 53:57.220
有用户的名字

53:57.220 --> 53:58.420
用户的年龄啊

53:58.420 --> 54:00.100
比方说我们做了这么一件事情

54:00.820 --> 54:02.100
用户的名字

54:02.100 --> 54:02.980
用户的年龄

54:05.780 --> 54:07.060
然后呢vipe用户呢

54:07.060 --> 54:08.180
除了用户的名字

54:08.180 --> 54:09.380
和用户的年龄之外呢

54:09.380 --> 54:09.940
还有个什么

54:09.940 --> 54:10.420
用户的

54:11.140 --> 54:12.340
鱼儿啊

54:12.340 --> 54:12.820
banans

54:16.190 --> 54:16.910
用户的鱼儿

54:22.480 --> 54:22.960
aji

54:24.160 --> 54:24.640
用户的

54:25.360 --> 54:25.920
鱼儿

54:26.880 --> 54:27.920
说多一些属性

54:27.920 --> 54:29.200
可能还会多一些方法

54:29.200 --> 54:29.360
对吧

54:29.360 --> 54:30.560
方法就写到原型上面

54:31.840 --> 54:32.880
那么比方说

54:32.880 --> 54:33.440
用户呢

54:33.440 --> 54:34.000
他有一个

54:34.560 --> 54:35.280
有一个方法

54:35.280 --> 54:37.040
叫做登陆啊

54:38.080 --> 54:38.480
比方说

54:39.360 --> 54:40.000
就写的那个方法

54:40.000 --> 54:41.360
这个方法当然我不会怕

54:41.360 --> 54:42.320
写成真实的方法

54:42.320 --> 54:43.520
就是用户登陆

54:43.520 --> 54:44.240
当你告诉我

54:44.240 --> 54:45.680
从逻辑上来讲

54:45.680 --> 54:47.200
用户有这个方法

54:47.200 --> 54:48.880
vipe用户是不是也得有

54:49.760 --> 54:50.720
那肯定得有啊

54:50.720 --> 54:52.000
用户有的东西他都得有

54:52.960 --> 54:55.200
当你在写代码的时候

54:55.200 --> 54:57.200
发现两个类型之间

54:57.200 --> 54:58.720
有这么一种关系

54:58.720 --> 55:01.120
就是怎么关系的a

55:01.120 --> 55:02.240
通过可以用

55:02.240 --> 55:04.960
可以用这句话来描述a4b

55:04.960 --> 55:06.880
你只要能够用这句话来描述

55:08.400 --> 55:09.920
他们就会形成继承关系

55:11.200 --> 55:12.640
vipe用户是

55:12.640 --> 55:14.160
用户是不是vipe用户

55:14.160 --> 55:15.040
不是

55:15.040 --> 55:16.400
那这句话有问题

55:16.400 --> 55:17.200
但是反过来

55:17.200 --> 55:18.480
vipe用户是不是

55:19.120 --> 55:20.000
用户了

55:20.000 --> 55:20.480
是

55:21.120 --> 55:21.760
vipe用户

55:21.760 --> 55:22.560
用户是不是用户

55:22.560 --> 55:22.800
是

55:23.840 --> 55:25.360
那么他们两个构造函数之间

55:25.360 --> 55:27.280
就会形成继承关系

55:27.280 --> 55:28.800
我们认为vipe

55:30.480 --> 55:31.600
vip

55:31.600 --> 55:32.080
继承

55:33.280 --> 55:34.160
vip

55:34.160 --> 55:35.760
那就有很多种说法了啊

55:35.760 --> 55:37.520
我们认为vip是vip的

55:38.080 --> 55:39.520
vipu的附类

55:39.520 --> 55:41.920
vipu是vipu的籽类

55:41.920 --> 55:43.040
我们有很多种说法

55:43.040 --> 55:44.800
但表达的都是一个意思

55:44.800 --> 55:46.640
只要你能表出是的关系

55:47.760 --> 55:48.240
也要吧

55:49.440 --> 55:49.840
好

55:49.840 --> 55:51.440
那么这个继承怎么实现呢

55:52.480 --> 55:53.440
其实继承在实现

55:53.440 --> 55:55.120
就是通过原型链来实现的

55:55.760 --> 55:56.560
那我们来画一张图

55:56.560 --> 55:57.440
你马上就明白了

56:00.900 --> 56:01.060
好

56:01.060 --> 56:02.180
因为今天同学们看到

56:02.820 --> 56:04.020
那做个调查之后

56:04.020 --> 56:05.380
本来我没打算讲这个的啊

56:06.820 --> 56:07.780
然后把我瞎了一下

56:07.780 --> 56:09.460
那我就把简单说一下了

56:12.110 --> 56:12.910
这是vip

56:16.240 --> 56:19.900
这是vip

56:19.900 --> 56:21.180
好就写着vipu这儿吧

56:26.510 --> 56:28.590
目前的情况是什么情况呢

56:28.590 --> 56:29.870
u这儿是不是一个原型

56:30.910 --> 56:31.230
对

56:31.790 --> 56:32.830
那我们把它叫做

56:33.550 --> 56:34.030
原型吧

56:38.560 --> 56:40.480
vipu这儿不也得有个原型吗

56:49.090 --> 56:50.050
是其他人不同意啊

56:50.050 --> 56:50.450
我说呀

56:50.450 --> 56:51.410
我就临时画一画

56:52.610 --> 56:54.530
目前这两个原型有关系吗

56:54.530 --> 56:55.410
是没有关系

56:56.530 --> 56:58.210
没有关系就意味着什么呢

56:58.210 --> 57:00.690
意味着通过u这儿创建的用户

57:01.250 --> 57:02.450
通过他来创建的用户

57:02.450 --> 57:03.490
它的影视原型指向罩

57:04.050 --> 57:05.570
通过vipu这儿创建的用户

57:05.570 --> 57:06.530
影视原型指向罩

57:07.090 --> 57:07.330
对吧

57:07.330 --> 57:08.530
他们两个是没有关系的

57:08.530 --> 57:10.130
他们目前的关系就是这样子

57:10.130 --> 57:11.650
就这里是opc是原型

57:12.450 --> 57:13.570
这里是opc的原型

57:14.050 --> 57:14.850
大家都知道吧

57:15.890 --> 57:17.650
最终它都会指向opc的原型

57:22.220 --> 57:23.660
目前是这么一种情况

57:23.660 --> 57:24.620
这是影视原型

57:25.580 --> 57:26.380
换一个颜色吧

57:27.020 --> 57:28.700
用这个颜色来表示影视原型

57:29.740 --> 57:31.100
这是影视原型的指向

57:31.100 --> 57:31.980
目前是这个样子的

57:31.980 --> 57:32.220
对吧

57:32.780 --> 57:35.020
所以说比方说我们创建了一个vipu这儿

57:35.660 --> 57:37.500
创建了一个vipu这儿过后呢

57:37.500 --> 57:38.300
它的影视原型

57:39.660 --> 57:41.340
它的影视原型是不是指向罩

57:41.340 --> 57:41.660
对吧

57:41.660 --> 57:43.340
vipu的影视原型指向罩

57:43.420 --> 57:45.260
那么就到了opc它的原型了

57:45.740 --> 57:46.620
那比方说再来

57:46.620 --> 57:47.980
我创建一个u这儿用户呢

57:48.780 --> 57:49.980
那我创建一个u这儿用户了

57:49.980 --> 57:51.500
那么它的影视原型指向罩

57:51.900 --> 57:52.140
对吧

57:52.700 --> 57:54.140
那继承关系是咋样

57:54.140 --> 57:55.020
是什么意思

57:55.020 --> 57:57.420
我们说vipu这儿继承u这儿

57:57.420 --> 57:58.460
其实非常简单

57:58.460 --> 58:00.380
你只要做到这件事就完成继承了

58:01.740 --> 58:02.940
你只要做到这件事就可以了

58:06.130 --> 58:07.410
你只要做成这样子就可以了

58:08.370 --> 58:10.050
那你想象这样子是不是就完成继承了

58:10.850 --> 58:12.850
你通过vipu这儿创建的用户

58:13.570 --> 58:15.330
它的影视原型是指向它没问题吧

58:16.050 --> 58:19.250
那它里边没有的东西是不是要先到u这儿的原型里面去找

58:20.530 --> 58:21.170
对不对

58:21.170 --> 58:22.450
在这里面去找找了

58:22.450 --> 58:23.970
没有再到opc身上

58:24.370 --> 58:25.490
就形成继承关系了

58:26.130 --> 58:28.210
你说你要做的所有的事情就非常简单

58:28.210 --> 58:28.930
就一件事

58:29.570 --> 58:32.290
你把这个箭头变成这个箭头就完了

58:33.730 --> 58:34.130
完了

58:34.130 --> 58:34.770
真正就完了

58:35.570 --> 58:37.250
那你要这个这个怎么来变了

58:38.370 --> 58:40.050
有一种非常简单的变法

58:40.050 --> 58:40.370
就是

58:41.410 --> 58:42.690
非常暴力的变法

58:43.170 --> 58:44.130
vipu这儿

58:45.090 --> 58:46.130
叫proto type

58:47.170 --> 58:47.730
proto

58:50.190 --> 58:51.710
这是最暴力的最简单的

58:52.270 --> 58:53.070
等于什么

58:53.070 --> 58:54.350
u这儿叫proto type

58:54.350 --> 58:55.390
不就完了吗

58:57.230 --> 58:57.710
完了

58:57.710 --> 58:58.510
一句话

58:58.510 --> 58:59.790
一看是不是就完了吗

58:59.790 --> 59:02.270
vipu这儿的原型上的影视原型

59:02.270 --> 59:03.870
你不用说改影视原型吧

59:03.870 --> 59:04.590
那它等于什么

59:04.590 --> 59:06.430
u这儿的proto type不就完了吗

59:06.430 --> 59:07.150
改没改过来

59:07.150 --> 59:07.710
改过来了

59:08.270 --> 59:08.670
完了

59:10.880 --> 59:11.440
复杂完

59:12.560 --> 59:13.920
这复杂就有鬼了是吧

59:15.120 --> 59:16.480
是不是一点都不复杂

59:16.640 --> 59:17.680
那问题在哪呢

59:17.680 --> 59:19.040
问题又在于

59:21.600 --> 59:23.520
官方他不建议你这样做

59:23.520 --> 59:24.800
不建议你用这个东西

59:25.360 --> 59:26.080
就这么简单

59:26.080 --> 59:27.360
他不让你用这个东西

59:28.320 --> 59:30.560
这个东西可能在将来不久之后

59:31.600 --> 59:33.120
他就不准利使用了

59:33.120 --> 59:34.080
他直接给你爆错了

59:35.200 --> 59:37.040
反正官方强烈不建议你用这个东西

59:37.040 --> 59:38.320
当然原因有很多

59:38.320 --> 59:39.200
反正就不建议你用

59:40.160 --> 59:40.960
那怎么办呢

59:41.920 --> 59:43.520
那我要改这个原型怎么办呢

59:43.520 --> 59:45.040
官方给你说了很清楚了

59:45.600 --> 59:48.400
你要改一个东西的影视原型

59:48.400 --> 59:50.080
他建议你用这个方法

59:50.080 --> 59:51.280
叫做objects

59:51.280 --> 59:52.240
sysproto type

59:53.520 --> 59:55.280
以前没有这个方法要写一大堆单

59:55.280 --> 59:56.480
现在有了

59:56.480 --> 59:57.040
那很简单

59:57.040 --> 59:57.840
那就非常简单了

59:58.560 --> 59:59.280
第一个参数

01:00:01.120 --> 01:00:01.840
第二个参数

01:00:02.480 --> 01:00:06.160
他会把他的影视原型设置为他

01:00:06.160 --> 01:00:06.800
就这么简单

01:00:07.600 --> 01:00:09.840
把他的影视原型设置为他

01:00:09.840 --> 01:00:11.040
那你要做的事情就是这个

01:00:13.810 --> 01:00:14.210
完了

01:00:15.170 --> 01:00:15.970
同志们

01:00:15.970 --> 01:00:16.530
一句话

01:00:16.530 --> 01:00:17.250
还是一句话

01:00:18.210 --> 01:00:18.690
写完了

01:00:20.050 --> 01:00:20.850
怎么就写完了

01:00:20.850 --> 01:00:21.810
就写完了

01:00:21.810 --> 01:00:22.130
你看

01:00:22.530 --> 01:00:24.050
VIPU的原型

01:00:24.050 --> 01:00:24.850
是不是他

01:00:24.850 --> 01:00:27.650
我要把他的影视原型改为U这点

01:00:27.650 --> 01:00:28.370
就写完了

01:00:28.930 --> 01:00:30.050
一句话就完成机身了

01:00:32.930 --> 01:00:33.570
所以说呢

01:00:33.570 --> 01:00:34.050
如果说

01:00:34.690 --> 01:00:35.650
面试题的时候

01:00:35.650 --> 01:00:35.970
考虑

01:00:36.690 --> 01:00:37.570
让你写个音

01:00:37.890 --> 01:00:38.930
就是我们课前讲的

01:00:38.930 --> 01:00:39.890
这个inherence

01:00:41.410 --> 01:00:42.130
这个方法

01:00:42.130 --> 01:00:43.490
给你传一个子函数

01:00:43.570 --> 01:00:44.530
给你传一个复函数

01:00:44.530 --> 01:00:45.810
让你用子函数

01:00:45.810 --> 01:00:46.930
去继承复函数

01:00:46.930 --> 01:00:47.330
怎么写

01:00:49.090 --> 01:00:49.490
一句话

01:00:52.990 --> 01:00:53.310
写完了

01:00:54.430 --> 01:00:54.750
收工

01:00:56.750 --> 01:00:57.390
完成继承

01:00:59.230 --> 01:00:59.790
你还有道理

01:00:59.790 --> 01:01:00.110
没了

01:01:02.030 --> 01:01:02.830
那我们来试一下

01:01:04.190 --> 01:01:05.470
我们现在就完成继承

01:01:05.470 --> 01:01:06.110
inherence

01:01:06.110 --> 01:01:09.150
把VIPU的函数传进去

01:01:09.150 --> 01:01:09.710
复函数

01:01:09.710 --> 01:01:11.070
U完成了

01:01:11.070 --> 01:01:12.190
继承完成了

01:01:12.190 --> 01:01:12.910
那我们来试一下

01:01:12.910 --> 01:01:13.950
是不是继承完成了呢

01:01:13.950 --> 01:01:15.310
来一个创建一个VIP

01:01:16.990 --> 01:01:17.870
创建一个VIP

01:01:26.350 --> 01:01:27.630
年龄18岁

01:01:27.630 --> 01:01:28.910
鱼儿30块钱

01:01:30.590 --> 01:01:31.310
好

01:01:31.310 --> 01:01:33.070
我们来输出一下VIP

01:01:33.070 --> 01:01:34.030
VIP肯定是没问题

01:01:36.980 --> 01:01:37.540
没问题

01:01:37.540 --> 01:01:37.940
然后呢

01:01:37.940 --> 01:01:39.620
我们来关键是看一下VIP

01:01:39.620 --> 01:01:40.420
他这个用户里面

01:01:40.420 --> 01:01:41.700
能不能用使用老品

01:01:41.700 --> 01:01:42.660
能不能调用老品

01:01:43.540 --> 01:01:43.940
老品

01:01:44.820 --> 01:01:45.700
看一下能不能调用

01:01:47.780 --> 01:01:48.340
是不是可以

01:01:48.900 --> 01:01:49.220
对吧

01:01:50.500 --> 01:01:51.780
妥妥的调用

01:01:51.860 --> 01:01:52.820
你还不新的话

01:01:52.820 --> 01:01:53.700
立在这里

01:01:53.700 --> 01:01:54.500
控制台里边

01:01:54.500 --> 01:01:55.940
可以看到更了清楚

01:01:55.940 --> 01:01:57.940
我们打印一下这个VIP

01:01:57.940 --> 01:01:58.820
你看VIP的

01:01:58.820 --> 01:01:59.060
是吗

01:02:00.500 --> 01:02:01.620
这是他的影视员情

01:02:01.620 --> 01:02:03.220
他以前都不是这种格式

01:02:03.220 --> 01:02:04.260
所以说这个东西

01:02:04.260 --> 01:02:05.540
两个下滑线的那种协法

01:02:06.420 --> 01:02:07.860
两个下滑线这种协法

01:02:10.260 --> 01:02:12.020
可能真的在不久的将来

01:02:12.020 --> 01:02:13.060
就会欺拥了

01:02:13.060 --> 01:02:13.700
他现在

01:02:13.700 --> 01:02:14.660
之前是两个下滑线

01:02:14.660 --> 01:02:15.540
他现在已经变成

01:02:15.540 --> 01:02:16.260
这种格式了

01:02:16.820 --> 01:02:17.940
这种格式就有典型的

01:02:17.940 --> 01:02:18.740
内部成员

01:02:18.740 --> 01:02:19.700
不允许地使用的

01:02:20.260 --> 01:02:21.060
所以说以后来

01:02:21.780 --> 01:02:23.380
可能都看不到这种面试题了

01:02:23.380 --> 01:02:24.980
就是这种协法的面试题

01:02:24.980 --> 01:02:25.460
都看不到

01:02:26.020 --> 01:02:27.460
但是他肯定要考虑

01:02:27.700 --> 01:02:28.740
原型和原型的

01:02:28.740 --> 01:02:29.700
他可能就不是

01:02:29.700 --> 01:02:30.900
像这么直接的

01:02:31.780 --> 01:02:33.060
可能就是像这种方式

01:02:33.060 --> 01:02:33.700
在考虑

01:02:35.970 --> 01:02:37.170
那么这就是他的影视员情

01:02:37.170 --> 01:02:38.050
你看影视员情是不是

01:02:38.050 --> 01:02:38.770
只想游战

01:02:38.770 --> 01:02:39.570
他是不是就完成了

01:02:39.570 --> 01:02:40.130
我们这个

01:02:41.010 --> 01:02:41.490
剑头了

01:02:42.050 --> 01:02:42.370
对吧

01:02:42.370 --> 01:02:42.610
他的

01:02:43.250 --> 01:02:44.770
他的原型

01:02:45.250 --> 01:02:46.130
是VIP游战

01:02:47.250 --> 01:02:48.610
他的影视员情

01:02:48.610 --> 01:02:49.410
只想这个游战

01:02:50.850 --> 01:02:51.410
原来的意思吧

01:02:55.060 --> 01:02:55.780
啊

01:02:58.180 --> 01:02:58.500
好

01:02:58.500 --> 01:03:00.740
那么这就是咱们完成继承

01:03:00.740 --> 01:03:02.100
当然完成继承的时候

01:03:02.100 --> 01:03:03.380
可能还有一些小的细节

01:03:03.780 --> 01:03:05.540
因为我们创建VIP邮件的时候

01:03:05.540 --> 01:03:06.580
其实像这两个代码

01:03:06.580 --> 01:03:07.700
是不是邮件里面都做了

01:03:08.740 --> 01:03:10.020
因此你只需要去调用

01:03:10.020 --> 01:03:11.300
邮件这个东西就行了

01:03:12.340 --> 01:03:12.980
对不对

01:03:12.980 --> 01:03:14.500
所以相当于是只调用

01:03:14.500 --> 01:03:15.300
这个东西就行了

01:03:15.300 --> 01:03:15.940
因此这个代码

01:03:15.940 --> 01:03:17.060
你要稍微改一下

01:03:17.060 --> 01:03:17.780
改成什么了

01:03:17.780 --> 01:03:18.580
改成邮件

01:03:19.620 --> 01:03:20.100
好

01:03:20.820 --> 01:03:22.260
这个玩意我就不展开说了

01:03:22.260 --> 01:03:23.300
你学过学到勾到

01:03:23.300 --> 01:03:24.340
还数学到基层那里

01:03:24.340 --> 01:03:25.140
自然就明白了

01:03:26.420 --> 01:03:27.140
然后调用一下

01:03:29.760 --> 01:03:30.080
ok

01:03:30.080 --> 01:03:31.920
那么这就是关于那个

01:03:33.040 --> 01:03:33.520
原型链

01:03:39.300 --> 01:03:39.620
怎么样

01:03:40.900 --> 01:03:41.620
还扛不住吧

01:03:44.210 --> 01:03:44.930
如果扛不住

01:03:44.930 --> 01:03:45.890
如果说我这样讲

01:03:45.890 --> 01:03:46.530
还扛不住的话

01:03:46.530 --> 01:03:47.090
那前边

01:03:48.210 --> 01:03:48.930
有些帐

01:03:48.930 --> 01:03:49.650
找完得还

01:03:52.190 --> 01:03:53.070
因此啊

01:03:53.070 --> 01:03:54.110
学习我建议大家

01:03:54.110 --> 01:03:54.830
真的好好

01:03:54.830 --> 01:03:56.190
踏踏实实学

01:03:56.190 --> 01:03:57.230
你挑的挑的来

01:03:57.230 --> 01:03:58.990
别看自己跑的飞快

01:03:58.990 --> 01:03:59.470
我跟你说

01:03:59.470 --> 01:03:59.950
同学们

01:03:59.950 --> 01:04:00.750
我经常遇到

01:04:01.310 --> 01:04:01.710
一些

01:04:03.150 --> 01:04:04.030
在群里边

01:04:04.030 --> 01:04:04.910
遇到一些学员的

01:04:04.910 --> 01:04:05.550
一些问题

01:04:06.990 --> 01:04:08.030
我一听看到一个问题

01:04:08.030 --> 01:04:08.910
我知道他的问题

01:04:09.550 --> 01:04:10.590
不是那个问题本身

01:04:10.590 --> 01:04:13.230
他的问题在之前的知识里边

01:04:13.230 --> 01:04:14.030
就缺了一堆

01:04:19.060 --> 01:04:21.460
学完就忘合理不学

01:04:21.460 --> 01:04:22.340
根本就没学

01:04:23.140 --> 01:04:23.940
两个概念

01:04:26.610 --> 01:04:27.890
你以前是个高手

01:04:29.810 --> 01:04:30.850
九书战场

01:04:32.210 --> 01:04:33.410
可能不熟练了

01:04:34.690 --> 01:04:35.010
合理

01:04:35.010 --> 01:04:36.450
从来就没有成为过高手

01:04:37.010 --> 01:04:37.890
两个概念

01:04:38.290 --> 01:04:39.250
那是两种人

01:04:39.650 --> 01:04:40.050
知道吧

01:04:44.620 --> 01:04:45.900
你学完就忘

01:04:45.900 --> 01:04:46.460
有个什么

01:04:46.460 --> 01:04:48.300
有个最大的好处在什么

01:04:48.300 --> 01:04:50.300
你知道曾经有这个东西

01:04:51.100 --> 01:04:52.780
你知道曾经有过

01:04:52.780 --> 01:04:54.140
你根本就没有学过

01:04:54.940 --> 01:04:56.060
那你根本就不知道

01:04:56.060 --> 01:04:57.020
这个世界上有这个东西

01:04:57.020 --> 01:04:58.140
你也压根不会

01:04:58.140 --> 01:04:59.340
不会往这个方向想

01:05:00.460 --> 01:05:02.060
知道自己不知道

01:05:02.620 --> 01:05:04.060
和不知道自己不知道

01:05:04.780 --> 01:05:05.900
这是两个概念

01:05:06.380 --> 01:05:06.780
知道吧

01:05:08.780 --> 01:05:09.980
忘记很正常

01:05:10.060 --> 01:05:10.940
我都经常忘

01:05:11.740 --> 01:05:12.060
好

01:05:12.060 --> 01:05:12.860
最后来

01:05:12.860 --> 01:05:13.660
Z是指向

01:05:16.060 --> 01:05:18.700
Z是指向并不复杂

01:05:19.740 --> 01:05:20.860
但是面试里边

01:05:22.780 --> 01:05:25.660
不能说百分之百吧

01:05:25.660 --> 01:05:27.660
应该百分之99.99

01:05:27.660 --> 01:05:28.380
他都会考虑

01:05:29.740 --> 01:05:31.180
Z是指向世界试里边

01:05:31.900 --> 01:05:32.940
一个老问题的

01:05:32.940 --> 01:05:34.140
这个问题其实并不难

01:05:34.860 --> 01:05:36.220
你只要记住一件事

01:05:37.900 --> 01:05:39.100
Z是在哪里用的

01:05:40.060 --> 01:05:41.340
都到处都可以用

01:05:42.780 --> 01:05:43.580
但是

01:05:44.540 --> 01:05:48.380
Z是指向只有在雕用时才能确定

01:05:49.100 --> 01:05:50.380
函数里边的Z是

01:05:50.860 --> 01:05:53.580
它只能在雕用的时候才能确定

01:05:54.140 --> 01:05:55.420
反复的读几遍

01:05:55.420 --> 01:05:57.740
只能只能只能

01:05:57.740 --> 01:06:00.140
所以说不要再问问我这种问题了

01:06:00.940 --> 01:06:07.890
因为老师这个Z是指向谁

01:06:07.890 --> 01:06:08.530
我不知道

01:06:08.530 --> 01:06:09.650
你问我就不知道

01:06:09.650 --> 01:06:10.770
为什么你没雕用

01:06:12.050 --> 01:06:13.330
没雕用我就不知道指向谁

01:06:15.330 --> 01:06:16.450
不要再问我这种问题了

01:06:16.850 --> 01:06:18.210
这问题本身就是有问题的

01:06:18.210 --> 01:06:22.050
只有在雕用的时候才知道Z是指向谁

01:06:22.050 --> 01:06:22.850
你不雕用它

01:06:22.850 --> 01:06:24.370
你永远不知道Z是指向谁

01:06:26.210 --> 01:06:26.610
来吧

01:06:26.610 --> 01:06:28.210
我们比方说来一个雕用

01:06:28.850 --> 01:06:29.570
Z是指向谁

01:06:30.130 --> 01:06:31.170
指向全局

01:06:31.170 --> 01:06:31.890
Global

01:06:31.890 --> 01:06:33.010
这是漏洞环境

01:06:33.010 --> 01:06:34.530
在浏览器里边就指向温豆

01:06:35.730 --> 01:06:42.800
那我如果说我这样子去雕用

01:06:42.800 --> 01:06:43.680
它Z是指向了

01:06:46.020 --> 01:06:48.660
又指向了这个对象了

01:06:52.610 --> 01:06:54.370
你说不清楚它指向谁

01:06:54.370 --> 01:06:56.050
只有雕用的时候

01:06:56.050 --> 01:06:58.050
它才知道Z是指向谁

01:06:59.410 --> 01:07:01.410
每一次雕用它可能Z是指向

01:07:01.410 --> 01:07:02.290
都可能不一样

01:07:03.250 --> 01:07:03.970
懂得意思吧

01:07:03.970 --> 01:07:05.330
所以只有在雕用的时候

01:07:05.330 --> 01:07:06.210
才知道Z是指向谁

01:07:06.210 --> 01:07:08.210
那么雕用有哪些场景

01:07:09.010 --> 01:07:11.090
会导致Z是不同的

01:07:11.090 --> 01:07:13.410
分出来就这么四个场景

01:07:13.410 --> 01:07:14.130
没了

01:07:14.130 --> 01:07:15.090
就这四个场景

01:07:15.170 --> 01:07:18.130
第一种就是全局代码里边的Z是

01:07:18.130 --> 01:07:20.050
因为全局代码它不在函数里边

01:07:20.050 --> 01:07:21.250
你也可以认为全局代码

01:07:21.250 --> 01:07:22.770
是在一个特殊的函数里边

01:07:22.770 --> 01:07:24.050
叫全局上下文

01:07:24.050 --> 01:07:31.090
全局上下文里边的Z是指向的是全局对象

01:07:31.970 --> 01:07:32.850
就像你在这里

01:07:32.850 --> 01:07:35.090
直接写的Z是指向的肯定是温豆

01:07:35.810 --> 01:07:38.610
在漏洞环境里边有一些特殊情况

01:07:38.610 --> 01:07:40.450
漏洞环境里边的因为它给你包装了

01:07:40.450 --> 01:07:42.130
所以在这种情况里面

01:07:42.290 --> 01:07:43.570
有一些特殊情况

01:07:43.570 --> 01:07:45.090
漏洞环境里边的因为它给你包装了

01:07:45.090 --> 01:07:45.810
已经函数了

01:07:45.810 --> 01:07:47.010
这个我们现在不用去管它

01:07:47.010 --> 01:07:48.130
你们将来就知道了

01:07:48.130 --> 01:07:50.130
在漏洞环境里边这里的Z是

01:07:52.210 --> 01:07:52.930
封对象

01:07:54.770 --> 01:07:55.330
不管它

01:07:55.330 --> 01:07:56.530
这个东西是比较特殊的

01:07:56.530 --> 01:07:56.930
不管它

01:07:57.570 --> 01:07:58.770
那不是一个正常情况

01:07:58.770 --> 01:08:00.130
正常因为漏洞环境里边

01:08:00.130 --> 01:08:01.650
这个环境它就不是一个全局环境

01:08:03.250 --> 01:08:05.410
在浏览器里边比较正常

01:08:05.410 --> 01:08:06.530
它Z在全局环境里边

01:08:06.530 --> 01:08:08.530
Z就是指向温豆对象

01:08:12.430 --> 01:08:13.230
指向温豆对象

01:08:14.990 --> 01:08:16.350
它也就是直接调用

01:08:16.350 --> 01:08:18.190
利用这种方式直接调用

01:08:18.190 --> 01:08:19.390
它指向的也是温豆对象

01:08:21.860 --> 01:08:22.580
这是第一种情况

01:08:23.620 --> 01:08:24.340
第二种情况

01:08:25.300 --> 01:08:26.900
通过这种格式来调用

01:08:26.900 --> 01:08:27.620
指向了谁

01:08:27.620 --> 01:08:30.260
这个函数里边指的是函数里边

01:08:30.260 --> 01:08:32.180
函数里边的Z指向谁

01:08:32.180 --> 01:08:35.140
指向你前面这个东西

01:08:35.700 --> 01:08:36.500
就是调用者

01:08:37.700 --> 01:08:39.060
那比方说我去的例子

01:08:39.060 --> 01:08:40.820
你这个单码这样子写的

01:08:41.860 --> 01:08:43.940
这个函数A里边的Z是指向谁

01:08:43.940 --> 01:08:44.740
它指向OVG

01:08:45.460 --> 01:08:46.500
那你是这样子写的

01:08:48.260 --> 01:08:50.100
这个函数E的Z是指向谁

01:08:50.100 --> 01:08:50.900
指向这个D

01:08:53.250 --> 01:08:53.970
懂了意思吧

01:08:53.970 --> 01:08:54.770
你能明白吧

01:08:55.490 --> 01:08:56.530
指向调用者

01:08:57.570 --> 01:08:58.050
好了

01:08:58.050 --> 01:08:58.850
我们来举个例子

01:09:27.700 --> 01:09:28.340
好同学们

01:09:28.340 --> 01:09:30.100
我说说啥

01:09:32.240 --> 01:09:34.560
说出的是温豆还是OVG

01:09:44.190 --> 01:09:44.350
来

01:09:45.790 --> 01:09:46.190
告诉我

01:09:47.550 --> 01:09:48.910
说出温豆还是OVG

01:09:50.430 --> 01:09:51.870
这个温豆对吧

01:09:52.670 --> 01:09:54.990
别看这个函数在哪定义的

01:09:54.990 --> 01:09:56.510
跟定义有关系吗

01:09:56.510 --> 01:09:57.150
没关系

01:09:58.110 --> 01:09:59.790
看怎么调用的

01:09:59.790 --> 01:10:00.510
你咋调用的

01:10:00.510 --> 01:10:01.390
你直接调用的吧

01:10:01.950 --> 01:10:03.230
直接调用的是不是这种情况

01:10:03.950 --> 01:10:05.070
那肯定是指向温豆

01:10:06.110 --> 01:10:07.470
我们要它放到浏览器里边

01:10:07.470 --> 01:10:08.910
因为浏览器才有温豆

01:10:08.910 --> 01:10:09.710
是不是指向温

01:10:09.710 --> 01:10:10.190
是温豆

01:10:12.930 --> 01:10:13.650
对吧

01:10:13.650 --> 01:10:14.610
就这么个意思

01:10:14.610 --> 01:10:16.210
要看怎么去调用的

01:10:16.210 --> 01:10:17.570
一定要看怎么去调用的

01:10:18.210 --> 01:10:19.570
不要去看它怎么定义的

01:10:19.570 --> 01:10:20.290
定义无所谓

01:10:20.290 --> 01:10:21.010
随便怎么定义

01:10:21.970 --> 01:10:23.090
关键看怎么调用

01:10:23.170 --> 01:10:24.290
其实为什么呢

01:10:24.290 --> 01:10:25.970
下备一个小知识

01:10:25.970 --> 01:10:27.250
我们昨天是不是学过

01:10:27.250 --> 01:10:28.930
全执行上下温

01:10:30.450 --> 01:10:32.130
Z是什么时候确定的

01:10:32.930 --> 01:10:35.250
创建执行上下温的时候

01:10:35.250 --> 01:10:36.930
我们昨天只讲了AO对吧

01:10:37.650 --> 01:10:39.410
其实Z也是在这里确定的

01:10:40.210 --> 01:10:41.810
那回忆一下昨天的东西

01:10:41.810 --> 01:10:44.130
执行上下温是在什么时候创建的

01:10:44.770 --> 01:10:46.210
函数调用的时候

01:10:47.650 --> 01:10:48.930
创建执行上下温

01:10:50.210 --> 01:10:50.850
所以

01:10:50.850 --> 01:10:51.410
所以啥

01:10:52.370 --> 01:10:53.650
你的函数不调用

01:10:53.650 --> 01:10:55.010
它知道Z是指向谁吗

01:10:55.010 --> 01:10:55.410
不知道

01:10:56.210 --> 01:10:57.410
因为只有调用的时候

01:10:57.410 --> 01:10:59.250
才能确定Z是指向谁

01:10:59.250 --> 01:11:00.370
它怎么确定的

01:11:00.370 --> 01:11:01.010
就在这

01:11:01.010 --> 01:11:01.410
规则

01:11:01.410 --> 01:11:02.130
它就这样规则

01:11:04.740 --> 01:11:04.980
好

01:11:04.980 --> 01:11:05.380
下一个

01:11:06.020 --> 01:11:08.660
如果说你用的是六一个函数

01:11:08.660 --> 01:11:09.620
用的是这种做法

01:11:10.100 --> 01:11:11.220
那Z是指向谁

01:11:11.220 --> 01:11:12.020
指向新对象

01:11:13.220 --> 01:11:13.940
里边Z是指向谁

01:11:13.940 --> 01:11:14.420
你就想起来

01:11:14.420 --> 01:11:15.060
我们刚才说的

01:11:15.060 --> 01:11:15.540
对吧

01:11:15.540 --> 01:11:16.900
如果说你写的是一个函数

01:11:17.460 --> 01:11:20.180
你掉的时候是通过六来调用的

01:11:20.180 --> 01:11:21.300
是不是还是调用

01:11:21.300 --> 01:11:22.020
那么就相对于是

01:11:22.020 --> 01:11:23.700
这个Z是指向那个新对象

01:11:23.700 --> 01:11:24.340
对吧

01:11:24.340 --> 01:11:25.540
没有这个代码

01:11:25.540 --> 01:11:26.500
就可以这样认为

01:11:27.380 --> 01:11:28.500
Z就是个新对象

01:11:28.500 --> 01:11:29.380
我这里边的Z是

01:11:30.580 --> 01:11:31.140
新对象

01:11:35.390 --> 01:11:35.870
对吧

01:11:36.190 --> 01:11:36.590
新对象

01:11:37.390 --> 01:11:37.790
是吧

01:11:38.910 --> 01:11:40.350
这个Z是个新对象

01:11:42.770 --> 01:11:45.170
我以前经常问我这种问题

01:11:45.170 --> 01:11:45.650
有同学

01:11:48.400 --> 01:11:49.200
他问我

01:11:49.200 --> 01:11:49.920
问我什么呢

01:11:49.920 --> 01:11:51.840
我都不知道该怎么去回答他

01:11:53.040 --> 01:11:53.680
他问我

01:11:53.680 --> 01:11:55.440
问老师好奇怪呀

01:11:56.160 --> 01:11:57.520
我这个地方只要

01:11:57.520 --> 01:11:58.240
我这个地方

01:11:58.240 --> 01:12:01.440
为什么P这个第一个字母大写了过后

01:12:01.440 --> 01:12:03.120
它这个Z是指向一个空对象

01:12:03.760 --> 01:12:05.440
这个P这个字母小写的过后

01:12:05.440 --> 01:12:06.880
它就指向的是全局了

01:12:08.640 --> 01:12:09.600
我都不知道该怎么回答

01:12:09.600 --> 01:12:11.120
同学们你们怎么回答啊

01:12:11.120 --> 01:12:12.000
这个应该怎么回答

01:12:14.030 --> 01:12:14.830
首先告诉他

01:12:14.830 --> 01:12:16.350
你这个问题本身就是有问题的

01:12:16.350 --> 01:12:16.590
对吧

01:12:16.590 --> 01:12:18.190
跟你这个大小写没有任何关系

01:12:18.750 --> 01:12:21.070
跟你怎么去定义这个函数没有任何关系

01:12:21.070 --> 01:12:22.270
跟你什么有关系

01:12:22.270 --> 01:12:23.950
跟你怎么去调用它有关系

01:12:24.430 --> 01:12:25.710
它为什么会产生这样的问题

01:12:25.710 --> 01:12:26.990
因为我们购习函数

01:12:26.990 --> 01:12:28.590
就是用六来使用的函数

01:12:28.590 --> 01:12:31.630
我们一般明明规则上都会把它大写

01:12:33.230 --> 01:12:34.510
明明规则上都会把它大写

01:12:34.510 --> 01:12:36.750
所以他会认为跟这个大写有关系

01:12:36.750 --> 01:12:38.110
没有一毛钱关系啊

01:12:38.110 --> 01:12:39.310
关键是看你怎么去调用

01:12:39.310 --> 01:12:40.270
你这样调的他就是

01:12:40.270 --> 01:12:41.710
管他大写小写

01:12:41.710 --> 01:12:42.590
他就是新对象

01:12:43.310 --> 01:12:44.590
你如果说不用六调用

01:12:44.590 --> 01:12:45.310
管他大写小写

01:12:45.310 --> 01:12:46.910
他都是全局

01:12:47.630 --> 01:12:48.270
就这么个意思

01:12:50.190 --> 01:12:50.590
好

01:12:50.590 --> 01:12:51.870
还有第三种情况

01:12:53.070 --> 01:12:54.270
如果说你函数

01:12:54.270 --> 01:12:55.870
这次函数调用啊

01:12:55.870 --> 01:12:56.990
这是特殊的调用方式

01:12:57.950 --> 01:12:58.990
函数里面有扩

01:12:58.990 --> 01:13:00.750
什么刚才见过的原型链里面

01:13:00.750 --> 01:13:01.710
把方式里面有扩

01:13:01.710 --> 01:13:02.750
方式里面还有OPEC

01:13:03.310 --> 01:13:04.430
方式里面还有BAND

01:13:04.990 --> 01:13:06.270
啊这三种方式

01:13:06.270 --> 01:13:08.190
这三种方式是可以让你手动的

01:13:08.190 --> 01:13:08.990
绑定Z式的

01:13:10.110 --> 01:13:10.910
这是什么意思

01:13:10.910 --> 01:13:11.870
调用函数

01:13:12.590 --> 01:13:14.030
以它为Z式

01:13:14.030 --> 01:13:14.830
你传的说什么

01:13:14.830 --> 01:13:15.630
它就是什么Z式

01:13:16.590 --> 01:13:17.390
调用函数

01:13:17.390 --> 01:13:18.510
这两个是一样的啊

01:13:18.510 --> 01:13:19.870
只是有些细微的差别

01:13:19.870 --> 01:13:20.910
不不在我们这里

01:13:20.910 --> 01:13:21.710
访问方位置列的

01:13:22.990 --> 01:13:24.590
OPEC调用函数

01:13:25.310 --> 01:13:26.590
就马上就调用函数

01:13:27.070 --> 01:13:27.870
以它为Z式

01:13:28.350 --> 01:13:29.870
那看到这种情况下的话

01:13:29.870 --> 01:13:30.590
那么它在

01:13:30.590 --> 01:13:31.310
仔细上让我里面

01:13:31.310 --> 01:13:32.990
它就会把Z式直接设置为

01:13:34.350 --> 01:13:35.390
你这个东西

01:13:36.830 --> 01:13:37.550
还有一种协法

01:13:38.190 --> 01:13:38.990
是使用BAND

01:13:39.550 --> 01:13:40.750
BAND里面传一个东西

01:13:40.750 --> 01:13:41.710
它也是Z式

01:13:41.710 --> 01:13:42.350
但是它会

01:13:42.350 --> 01:13:43.550
它不会立即调用函数

01:13:43.550 --> 01:13:44.350
它不会立即调用

01:13:44.350 --> 01:13:45.550
它会返回一个新函数

01:13:46.110 --> 01:13:47.950
当你去调用新函数的时候

01:13:50.240 --> 01:13:51.440
它会使用这个Z式

01:13:52.320 --> 01:13:53.120
这个为Z式

01:13:54.320 --> 01:13:55.760
啊其实也是跟调用有关系

01:13:56.720 --> 01:13:57.520
咱们有

01:13:57.520 --> 01:13:58.160
我记得有

01:13:59.440 --> 01:14:01.520
有时候我们上那个微客

01:14:01.520 --> 01:14:03.200
下午两点钟那个微客

01:14:03.200 --> 01:14:04.000
我记得

01:14:04.000 --> 01:14:05.680
咱们韩刚老师都讲过

01:14:05.680 --> 01:14:06.800
熟悉BAND

01:14:06.800 --> 01:14:08.080
自己实现一个BAND

01:14:08.080 --> 01:14:08.560
函数

01:14:08.560 --> 01:14:09.200
你实现过

01:14:09.200 --> 01:14:09.760
那就就明白

01:14:09.760 --> 01:14:10.480
它是怎么做的

01:14:11.040 --> 01:14:12.560
其实也是跟调用有关系

01:14:13.280 --> 01:14:14.160
那么这个

01:14:14.160 --> 01:14:15.040
如果说用这种方式

01:14:15.040 --> 01:14:15.760
调用函数

01:14:15.760 --> 01:14:16.480
函数里面的Z式

01:14:16.480 --> 01:14:16.960
指向谁

01:14:17.520 --> 01:14:19.840
指向你这里指定的Z式

01:14:22.420 --> 01:14:22.660
好

01:14:24.260 --> 01:14:24.820
拿说啊

01:14:25.540 --> 01:14:26.340
我们这里呢

01:14:27.620 --> 01:14:28.020
percent

01:14:28.580 --> 01:14:29.940
我用这种方式来调用

01:14:31.380 --> 01:14:32.820
扣一个啥呀

01:14:32.820 --> 01:14:33.620
扣一个123

01:14:35.790 --> 01:14:36.990
那这个Z式就指向

01:14:37.710 --> 01:14:38.590
数字123

01:14:38.590 --> 01:14:40.030
不过它会把它变成包装内

01:14:40.030 --> 01:14:41.070
啊包装内

01:14:41.070 --> 01:14:42.270
呃包装对象

01:14:42.270 --> 01:14:43.790
那包装内形是啥呢

01:14:43.790 --> 01:14:45.790
又不是我们这些客的东西了啊

01:14:45.790 --> 01:14:47.070
这是其处部分的

01:14:47.070 --> 01:14:48.510
那如果说你该传那个字幕刷

01:14:49.550 --> 01:14:50.350
那这个Z式呢

01:14:50.350 --> 01:14:51.230
还有指向字幕刷

01:14:51.870 --> 01:14:52.590
就这么简单

01:14:52.590 --> 01:14:53.550
而不太是一样的

01:14:54.510 --> 01:14:55.630
那BAND呢

01:14:55.630 --> 01:14:56.670
也是一样的

01:14:56.830 --> 01:14:57.390
BAND的不是

01:14:57.390 --> 01:14:58.670
不过它不是立即执行

01:14:58.670 --> 01:14:59.710
你看现在没有执行

01:15:00.190 --> 01:15:01.550
它会返回一个新函数

01:15:02.350 --> 01:15:02.990
对不对

01:15:02.990 --> 01:15:03.630
一个新函数

01:15:04.590 --> 01:15:05.390
那就M吧

01:15:06.270 --> 01:15:06.670
然后呢

01:15:06.670 --> 01:15:08.910
你将来无论你怎么去调用

01:15:08.910 --> 01:15:10.030
这个新函数

01:15:10.030 --> 01:15:11.390
它Z式都是指向这个

01:15:13.150 --> 01:15:13.470
对呀

01:15:13.470 --> 01:15:14.830
Z式都是指向这个

01:15:14.830 --> 01:15:15.630
马上回不信鞋

01:15:15.630 --> 01:15:16.350
那我这样子呢

01:15:19.900 --> 01:15:20.860
那我这样调用

01:15:20.860 --> 01:15:22.540
它Z式不应该指向它吗

01:15:24.300 --> 01:15:26.300
使用BAND时得到了新函数

01:15:26.300 --> 01:15:27.900
无法通过其他方式

01:15:27.900 --> 01:15:28.940
再次修改Z式

01:15:31.630 --> 01:15:32.270
它还是这个

01:15:33.310 --> 01:15:34.270
它不能再修改Z式

01:15:34.270 --> 01:15:36.030
因为之前已经绑定好了

01:15:36.030 --> 01:15:36.830
那么后续要用的时候

01:15:36.830 --> 01:15:37.870
都是用这个Z式

01:15:38.910 --> 01:15:39.470
知道意思吧

01:15:39.470 --> 01:15:40.270
就这么个意思

01:15:40.270 --> 01:15:40.830
BAND以后

01:15:40.830 --> 01:15:41.950
你们学由Rx的时候

01:15:43.070 --> 01:15:43.550
会使用

01:15:44.990 --> 01:15:46.830
那不信鞋了

01:15:46.830 --> 01:15:48.670
我一定要来弄死它

01:15:50.510 --> 01:15:51.630
我对BAND的这个函数

01:15:51.630 --> 01:15:52.590
再次用扩

01:15:52.590 --> 01:15:53.230
能改吗

01:15:53.230 --> 01:15:53.710
不能改

01:15:54.910 --> 01:15:55.790
还是这个

01:15:55.790 --> 01:15:57.230
但是有一种例外

01:15:57.230 --> 01:15:57.950
就是你6

01:15:58.670 --> 01:15:59.470
6就不一样了

01:16:00.430 --> 01:16:01.950
6就变成了

01:16:01.950 --> 01:16:03.310
空队向

01:16:03.310 --> 01:16:04.350
所以说

01:16:04.350 --> 01:16:05.310
但6除外

01:16:05.310 --> 01:16:06.750
这是注意点

01:16:06.750 --> 01:16:07.790
第一个注意点

01:16:07.790 --> 01:16:09.390
可能它不太会考虑这个

01:16:09.390 --> 01:16:11.390
因为这个东西太细了

01:16:11.390 --> 01:16:13.070
甚至甚至很多面试官

01:16:13.070 --> 01:16:14.030
他自己都不知道

01:16:14.030 --> 01:16:15.710
所以他可能不太会考虑这个

01:16:15.710 --> 01:16:17.470
但是你知道一点

01:16:17.470 --> 01:16:20.190
至少知道有那么个印象

01:16:20.190 --> 01:16:21.470
还是可以的

01:16:21.470 --> 01:16:22.990
还有一个点呢

01:16:22.990 --> 01:16:23.390
就是

01:16:23.390 --> 01:16:25.070
如果说你传的

01:16:25.070 --> 01:16:26.350
这里传的是NOW

01:16:26.350 --> 01:16:28.510
或者是undefined

01:16:29.230 --> 01:16:30.830
那么这种情况怎么来处理

01:16:32.670 --> 01:16:33.470
这里传的是NOW

01:16:33.470 --> 01:16:34.430
undefined怎么来处理

01:16:35.550 --> 01:16:37.870
如果函数是非严格模式

01:16:37.870 --> 01:16:38.910
就这个函数不在

01:16:38.910 --> 01:16:39.870
严格模式下边

01:16:39.870 --> 01:16:40.750
什么叫严格模式

01:16:41.870 --> 01:16:42.990
这又是NOW的知识了

01:16:44.750 --> 01:16:46.270
知识真的得踏踏实实学

01:16:46.270 --> 01:16:47.630
不然的话要弄很多东西

01:16:48.270 --> 01:16:49.310
严格模式不在我们这个

01:16:49.310 --> 01:16:50.590
这个讨论范围之内

01:16:50.590 --> 01:16:51.390
那么我们这里函数

01:16:51.390 --> 01:16:53.070
都是非严格模式

01:16:53.630 --> 01:16:55.710
如果说你的函数是非严格模式

01:16:55.710 --> 01:16:56.910
使用这些东西的时候

01:16:56.990 --> 01:16:58.750
传入了是NOW或者是undefined

01:16:58.750 --> 01:16:59.950
相当于是传入全局

01:17:00.750 --> 01:17:02.590
相当于是传入全局

01:17:02.590 --> 01:17:03.870
就相当于是传了一个Windows

01:17:09.410 --> 01:17:10.530
相当于是传了一个Windows

01:17:10.530 --> 01:17:11.970
但是如果说你是严格模式

01:17:11.970 --> 01:17:13.170
那你传的实际上就是实际上

01:17:15.090 --> 01:17:18.050
这是关于ZS

01:17:20.980 --> 01:17:22.340
看看什么问题

01:17:22.340 --> 01:17:22.900
能听懂吗

01:17:24.500 --> 01:17:25.460
这个ZS能听懂吗

01:17:26.100 --> 01:17:26.900
记住关键点

01:17:28.420 --> 01:17:30.340
调用的时候确定ZS

01:17:31.140 --> 01:17:33.220
永远在调用的时候确定ZS

01:17:34.100 --> 01:17:34.980
没有例外

01:17:34.980 --> 01:17:35.780
没有任何例外

01:17:39.540 --> 01:17:42.580
有没有同学对尖头函数有疑问

01:17:44.580 --> 01:17:45.460
NOW也是调用

01:17:45.460 --> 01:17:46.260
NOW也是调用

01:17:47.620 --> 01:17:48.660
NOW也是调用函数

01:17:52.980 --> 01:17:53.700
有同学学院

01:17:53.700 --> 01:17:55.700
我昨天看到有同学学到ES6了

01:17:56.820 --> 01:18:00.740
那可能对尖头函数有点疑问

01:18:00.740 --> 01:18:01.860
什么叫尖头函数

01:18:01.860 --> 01:18:02.820
这是ES6的东西

01:18:02.820 --> 01:18:03.780
看一下就明白了

01:18:04.500 --> 01:18:06.580
它就是一种简易的函数写法

01:18:06.580 --> 01:18:08.740
你看比方说我们写个函数表达式

01:18:08.740 --> 01:18:10.340
A和B返回一个A加B

01:18:11.620 --> 01:18:12.500
过去是这样写的

01:18:12.500 --> 01:18:12.740
对吧

01:18:12.740 --> 01:18:13.700
这个单码都看了都满

01:18:14.580 --> 01:18:15.940
然后ES6

01:18:15.940 --> 01:18:18.180
它可以让你把函数表达式

01:18:18.180 --> 01:18:19.780
所以是函数表达式

01:18:20.660 --> 01:18:21.860
写成下面那种格式

01:18:22.980 --> 01:18:25.220
看上去是不是更加清爽简洁

01:18:25.220 --> 01:18:26.340
这是参数

01:18:26.340 --> 01:18:27.060
一个尖头

01:18:27.620 --> 01:18:28.420
这是函数体

01:18:29.540 --> 01:18:30.900
效果都是一样的

01:18:30.900 --> 01:18:32.020
都是一样的

01:18:32.180 --> 01:18:33.860
上面那个跟下面那个效果是一样的

01:18:34.820 --> 01:18:36.980
只是它下面这个更加清爽简洁而已

01:18:38.100 --> 01:18:38.820
而且尖头函数呢

01:18:38.820 --> 01:18:39.700
有些情况下

01:18:39.700 --> 01:18:41.540
甚至还可以省略这个大过河

01:18:41.540 --> 01:18:42.900
不过我们现在不用管这个

01:18:43.700 --> 01:18:44.980
我现在要说Z式的问题

01:18:47.070 --> 01:18:47.790
记住一句话

01:18:48.990 --> 01:18:50.350
尖头函数没有Z式

01:18:50.910 --> 01:18:51.870
没有Ogument

01:18:51.870 --> 01:18:53.230
这两个东西都没有

01:18:53.230 --> 01:18:54.030
是真的没有

01:18:55.230 --> 01:18:56.270
也就是说尖头函数

01:18:56.270 --> 01:18:57.790
有没有执行让它文优

01:18:57.790 --> 01:18:58.830
但它没有Z式

01:18:58.830 --> 01:18:59.870
尖头函数没有这个东西

01:19:00.750 --> 01:19:01.550
那里就琢磨完

01:19:02.510 --> 01:19:03.870
尖头函数没有Z式

01:19:04.430 --> 01:19:06.990
那如果说你在尖头函数里边使用的Z是怎么办

01:19:15.090 --> 01:19:16.370
比方说这是个尖头函数

01:19:16.370 --> 01:19:17.090
这里没有参数

01:19:17.090 --> 01:19:17.490
对吧

01:19:17.490 --> 01:19:18.050
这是函数体

01:19:18.050 --> 01:19:19.490
那我在这里使用的Z是怎么办

01:19:20.690 --> 01:19:22.130
我看是不是学过作用预念

01:19:23.970 --> 01:19:25.090
是不是学过作用预念

01:19:26.130 --> 01:19:27.650
作用预念我们昨天怎么说的

01:19:28.210 --> 01:19:31.200
是不是这个函数定义的时候

01:19:31.200 --> 01:19:32.400
有一个作用预念

01:19:32.400 --> 01:19:35.600
它指向当前的指形上下文

01:19:36.400 --> 01:19:38.000
这里的Z式是尖头函数的吗

01:19:38.000 --> 01:19:38.480
不是

01:19:39.440 --> 01:19:41.200
是谁的Z是Person的Z

01:19:43.040 --> 01:19:44.000
用的是它的Z

01:19:44.720 --> 01:19:46.240
所以你要看怎么去调用它的

01:19:47.120 --> 01:19:47.920
怎么去调用它

01:19:47.920 --> 01:19:49.680
那么这个Z式就指向谁

01:19:50.800 --> 01:19:51.360
懂的意思吗

01:19:52.240 --> 01:19:54.000
怎么调用它的Z式指向谁

01:19:54.000 --> 01:19:55.360
表示你用这种方式调用它的

01:19:56.240 --> 01:19:57.200
那这个Z式指向谁

01:19:57.200 --> 01:19:58.000
指向的是Windows

01:19:58.880 --> 01:19:59.200
是吧

01:20:02.000 --> 01:20:03.440
你就记住它没有Z式就行了

01:20:07.950 --> 01:20:09.230
没有调用这个M吧

01:20:09.950 --> 01:20:10.510
就调用

01:20:15.980 --> 01:20:16.780
所以指向Windows

01:20:17.020 --> 01:20:17.420
为什么

01:20:17.420 --> 01:20:18.540
因为Person里面是

01:20:19.100 --> 01:20:20.140
这样调用Person

01:20:20.140 --> 01:20:21.900
那Person里面的Z式是指向Windows的

01:20:22.300 --> 01:20:24.060
所以它电团还说里面又没有Z式

01:20:24.060 --> 01:20:25.180
那只能用外面的Z式

01:20:25.500 --> 01:20:26.540
那它那个Z式指向Windows

01:20:26.540 --> 01:20:27.260
那就Windows变

01:20:28.780 --> 01:20:29.340
懂的意思吗

01:20:30.540 --> 01:20:32.300
那些电团还说是不支持什么

01:20:32.300 --> 01:20:34.460
call or apply啊这些东西都不支持的

01:20:35.340 --> 01:20:36.460
除了没有Z式之外

01:20:36.460 --> 01:20:37.020
它还没有

01:20:37.020 --> 01:20:37.900
它这个东西也没有

01:20:38.380 --> 01:20:38.940
Oggy名字

01:20:40.220 --> 01:20:40.780
Oggy名字

01:20:40.780 --> 01:20:41.660
这个玩意它也没有

01:20:41.660 --> 01:20:42.620
电团还说也没有

01:20:42.620 --> 01:20:44.140
它用的是外面的Oggy名字

01:20:45.260 --> 01:20:46.220
就这个东西有趣了

01:20:46.300 --> 01:20:47.180
有其他不影响

01:20:47.180 --> 01:20:48.220
好 我们来看一下

01:20:48.220 --> 01:20:49.180
电视指向的面术题

01:20:50.700 --> 01:20:52.380
这是室员的面术题

01:21:05.840 --> 01:21:06.640
好 看一下啊

01:21:09.760 --> 01:21:11.040
这个面子里面是在绕里

01:21:11.040 --> 01:21:11.600
它在绕里

01:21:12.240 --> 01:21:12.960
但是你不要怕

01:21:15.330 --> 01:21:17.410
说有这么一个制服创

01:21:18.610 --> 01:21:19.170
11

01:21:19.970 --> 01:21:21.410
ob键呢是一个对象

01:21:21.410 --> 01:21:22.610
它里面一个属性

01:21:22.610 --> 01:21:24.770
substr是2

01:21:24.770 --> 01:21:26.130
然后呢有一个函数

01:21:26.130 --> 01:21:27.730
这个函数的Z式现在能确定吗

01:21:30.080 --> 01:21:30.640
能确定吗

01:21:30.640 --> 01:21:31.440
肯定确定不了

01:21:32.080 --> 01:21:32.800
没调用

01:21:32.800 --> 01:21:33.760
谁也确定不了

01:21:33.760 --> 01:21:34.880
神仙来的都确定不了

01:21:35.840 --> 01:21:37.840
好 接下来做了这么一件事

01:21:38.560 --> 01:21:40.080
这里有一个立即执行函数

01:21:40.080 --> 01:21:40.720
能看出来吗

01:21:41.200 --> 01:21:42.320
这是一个箭头函数

01:21:44.160 --> 01:21:46.000
然后呢立即执行

01:21:47.200 --> 01:21:47.600
对吧

01:21:49.360 --> 01:21:50.400
那我在箭头函数里面

01:21:50.400 --> 01:21:51.760
有没有用Z式啊

01:21:51.760 --> 01:21:52.640
有没有用Z式

01:21:53.360 --> 01:21:54.240
没有用Z式啊

01:21:54.240 --> 01:21:54.960
我就一看到

01:21:54.960 --> 01:21:56.000
你在这个代码里面

01:21:56.000 --> 01:21:57.040
哪里看到Z式的

01:21:57.680 --> 01:21:58.960
没有用Z式的啊

01:21:59.680 --> 01:22:01.040
Z式是在哪里用的

01:22:01.040 --> 01:22:02.800
是在这个函数里用的

01:22:02.800 --> 01:22:04.320
那跟箭头函数有关系吗

01:22:05.040 --> 01:22:06.000
一毛钱关系都没有

01:22:06.000 --> 01:22:06.640
说有个箭头函数

01:22:06.640 --> 01:22:07.600
写的跟那些是一样的

01:22:08.160 --> 01:22:08.880
有啥区别呢

01:22:08.880 --> 01:22:09.680
没有任何区别

01:22:11.520 --> 01:22:12.080
懂吗

01:22:12.080 --> 01:22:13.520
这里边是没有用Z式的

01:22:13.520 --> 01:22:14.640
Z式是在这里边用的

01:22:14.640 --> 01:22:15.520
所以说你要看

01:22:15.520 --> 01:22:16.880
看这个Z式指向谁

01:22:16.880 --> 01:22:17.360
要看什么

01:22:17.360 --> 01:22:18.960
要看这个函数是怎么调用的

01:22:19.600 --> 01:22:20.480
跟这个有关系吗

01:22:20.480 --> 01:22:21.040
没有关系

01:22:21.760 --> 01:22:23.600
关系是看这个函数怎么调用的

01:22:23.600 --> 01:22:25.040
那你看这个函数怎么调用的

01:22:25.040 --> 01:22:26.880
怎么通过ob界调用的

01:22:27.840 --> 01:22:29.200
那么通过ob界的调用的

01:22:29.200 --> 01:22:30.400
那这个Z式指向谁

01:22:30.400 --> 01:22:31.440
Z式调用指向谁

01:22:31.440 --> 01:22:32.480
指向那个是ob界啊

01:22:33.760 --> 01:22:34.800
那么输出这个Z式

01:22:34.800 --> 01:22:35.680
ob界的什么

01:22:35.680 --> 01:22:37.360
sub-str是不是输出2

01:22:38.000 --> 01:22:39.120
说Z开始输出2

01:22:40.400 --> 01:22:40.960
毫无疑问

01:22:41.920 --> 01:22:42.880
那就遭遇输出2

01:22:44.320 --> 01:22:45.760
你们下去自己再做一下

01:22:45.760 --> 01:22:46.400
不是下招了

01:22:47.120 --> 01:22:48.320
好 接下来一个这个有意思

01:22:48.320 --> 01:22:49.200
这个特别有意思

01:22:53.120 --> 01:22:54.800
这个玩意它在照理的

01:22:55.520 --> 01:22:56.080
就看你

01:22:57.600 --> 01:22:58.880
这是个表达式的知识

01:22:59.840 --> 01:23:00.720
这个玩意

01:23:00.720 --> 01:23:02.880
把这个玩意再负责给自己

01:23:02.880 --> 01:23:04.240
那比如说疯那么

01:23:04.240 --> 01:23:05.360
预杀好负责的呢

01:23:06.320 --> 01:23:06.720
不一样

01:23:07.600 --> 01:23:08.000
为什么

01:23:08.640 --> 01:23:10.240
因为你这样子一旦完

01:23:10.240 --> 01:23:11.600
这样子一负责

01:23:11.600 --> 01:23:13.280
整个这个货号里边变成了一个什么

01:23:13.280 --> 01:23:14.560
变成了一个表达式的

01:23:16.720 --> 01:23:17.120
同学们

01:23:17.760 --> 01:23:19.120
负责语句表达式

01:23:19.120 --> 01:23:19.600
知道吗

01:23:24.500 --> 01:23:25.540
这不是负责语句啊

01:23:25.540 --> 01:23:27.460
这是辩量生命语句

01:23:27.460 --> 01:23:28.980
负责语句也等于3

01:23:31.200 --> 01:23:32.800
是不是这个表达式返回3

01:23:33.920 --> 01:23:34.560
也等于

01:23:35.840 --> 01:23:36.320
知识串

01:23:37.040 --> 01:23:38.800
这个表达式返回知识串

01:23:39.440 --> 01:23:40.640
这是负责语句

01:23:41.280 --> 01:23:42.960
所以说这样子一搞

01:23:42.960 --> 01:23:44.080
那么这个货号里边

01:23:44.080 --> 01:23:45.360
是不是这个表达式

01:23:45.360 --> 01:23:47.200
这个表达式返回什么

01:23:47.200 --> 01:23:48.320
返回这个函数

01:23:51.380 --> 01:23:52.420
懂得意思吗

01:23:52.420 --> 01:23:53.540
那就相当于是这里

01:23:53.540 --> 01:23:54.740
就直接写了这个函数

01:23:54.740 --> 01:23:55.860
就把这个函数放在了

01:23:57.540 --> 01:23:58.100
就这个意思

01:23:58.100 --> 01:23:59.060
它返回的是这个函数

01:23:59.940 --> 01:24:01.140
那么这里再调用它

01:24:01.940 --> 01:24:03.860
是不是相当于是直接调用这个函数

01:24:04.740 --> 01:24:06.260
因此由于这个函数

01:24:06.260 --> 01:24:07.700
是直接调用这个Z是指向谁

01:24:07.700 --> 01:24:08.340
指向温斗

01:24:08.820 --> 01:24:10.660
那么温斗里边说这个东西等于1

01:24:11.860 --> 01:24:13.060
所以这个是输出1

01:24:17.310 --> 01:24:19.070
然后就是OB借

01:24:19.070 --> 01:24:19.710
修B个

01:24:19.710 --> 01:24:20.910
那么直接找到这个函数

01:24:20.910 --> 01:24:21.870
要使用扣

01:24:22.910 --> 01:24:23.870
给它传那个什么

01:24:23.870 --> 01:24:24.750
传那个S

01:24:24.750 --> 01:24:26.510
STR是不是传那个它

01:24:26.510 --> 01:24:26.990
它是什么

01:24:26.990 --> 01:24:27.710
它是制服串

01:24:28.430 --> 01:24:30.430
把制服串作为Z是传进去了

01:24:31.390 --> 01:24:32.510
那么这个Z是指向谁

01:24:33.870 --> 01:24:35.150
现在这个Z是指向谁

01:24:35.150 --> 01:24:36.110
指向这个制服串

01:24:37.550 --> 01:24:39.710
那么制服串里边有没有修B个这个方法了

01:24:41.660 --> 01:24:42.140
你看一下

01:24:42.940 --> 01:24:43.980
修B个

01:24:45.020 --> 01:24:45.500
没有

01:24:45.500 --> 01:24:45.900
对吧

01:24:46.940 --> 01:24:47.900
那第三个

01:24:47.900 --> 01:24:48.380
OND犯

01:24:50.460 --> 01:24:51.420
2EOND犯

01:24:56.450 --> 01:24:57.810
那第一个是2

01:24:58.370 --> 01:24:59.890
不能不能在这里执行

01:24:59.890 --> 01:25:00.530
不能在那个

01:25:01.170 --> 01:25:01.970
漏的里边执行

01:25:05.570 --> 01:25:06.210
哦哦哦

01:25:06.210 --> 01:25:07.170
哦不是修B个方法

01:25:07.170 --> 01:25:08.770
是STR的方法

01:25:08.850 --> 01:25:09.970
这是制服串有这个方法

01:25:10.690 --> 01:25:11.250
不好意思啊

01:25:11.250 --> 01:25:11.650
这里

01:25:12.770 --> 01:25:13.650
看漏了

01:25:13.650 --> 01:25:14.930
制服串里边是有这个方法的

01:25:15.890 --> 01:25:16.690
它指向制服串

01:25:16.690 --> 01:25:18.050
制服串里边是有这个函数的

01:25:18.050 --> 01:25:18.690
SOPSG

01:25:18.690 --> 01:25:19.090
对吧

01:25:19.650 --> 01:25:20.850
绝系指制服串

01:25:20.850 --> 01:25:22.050
说的第三个是一个方式

01:25:22.610 --> 01:25:23.650
是制服串的方式

01:25:27.150 --> 01:25:28.030
2E方式

01:25:32.670 --> 01:25:33.710
就这道题

01:25:33.710 --> 01:25:34.670
关键是这一句话

01:25:34.670 --> 01:25:35.630
这一句话要看明白

01:25:35.630 --> 01:25:36.670
它到底

01:25:36.670 --> 01:25:37.630
它想怎么玩呢

01:25:38.670 --> 01:25:40.030
不要轻易的被它玩了

01:25:40.670 --> 01:25:42.110
好 下来美图得到面试题

01:25:46.780 --> 01:25:47.180
来吧

01:25:49.280 --> 01:25:49.920
Z是啥

01:25:49.920 --> 01:25:50.480
不知道

01:25:50.480 --> 01:25:51.120
我也不知道

01:25:51.120 --> 01:25:52.080
我都没有调用A

01:25:52.080 --> 01:25:52.720
没有调用A

01:25:52.720 --> 01:25:53.440
我都不知道A是啥

01:25:54.160 --> 01:25:54.720
然后B

01:25:55.200 --> 01:25:56.000
这里Z是啥

01:25:56.000 --> 01:25:56.400
不知道

01:25:57.120 --> 01:25:58.320
没有调用就不知道

01:25:58.320 --> 01:25:58.880
没有

01:25:58.880 --> 01:26:00.240
这里的Z是B的Z

01:26:00.240 --> 01:26:01.200
但是B还没有调用

01:26:01.200 --> 01:26:02.160
我就不知道Z是啥

01:26:02.800 --> 01:26:03.200
好

01:26:03.440 --> 01:26:04.240
好 这里

01:26:04.240 --> 01:26:04.800
我也不知道

01:26:04.800 --> 01:26:05.680
现在B都还没有调用

01:26:05.680 --> 01:26:06.000
对吧

01:26:06.000 --> 01:26:06.400
好来

01:26:06.880 --> 01:26:08.400
B点B的Z

01:26:09.120 --> 01:26:11.200
把这个函数绑定一个Z

01:26:11.680 --> 01:26:12.560
这里的Z是啥

01:26:12.560 --> 01:26:13.360
是Windows

01:26:13.360 --> 01:26:14.560
那么也就是D

01:26:14.560 --> 01:26:16.080
D里边的Z是指向啥

01:26:16.080 --> 01:26:16.640
指向Windows

01:26:17.600 --> 01:26:18.960
得到一个新函数D

01:26:18.960 --> 01:26:20.480
D的Z是指向啥

01:26:20.480 --> 01:26:21.040
指向这个

01:26:21.040 --> 01:26:21.280
对吧

01:26:21.280 --> 01:26:22.080
这个Z是

01:26:22.080 --> 01:26:22.560
就是Windows

01:26:22.560 --> 01:26:23.520
全举

01:26:23.520 --> 01:26:24.560
全举代码里边的Z

01:26:24.560 --> 01:26:25.760
是不是指向Windows

01:26:25.760 --> 01:26:27.040
所以这里的D

01:26:27.520 --> 01:26:28.240
这个函数

01:26:28.240 --> 01:26:29.760
这个D的函数就是B这个函数

01:26:29.760 --> 01:26:30.560
不过它调用的时候

01:26:30.560 --> 01:26:32.160
它的Z是指向Windows

01:26:32.160 --> 01:26:33.040
是吧 讲过的

01:26:33.040 --> 01:26:33.680
它绑定的

01:26:33.680 --> 01:26:36.400
把B的Z绑定成了什么Windows

01:26:36.960 --> 01:26:38.080
得到一个新函数

01:26:38.080 --> 01:26:39.280
一会儿调用D

01:26:39.280 --> 01:26:40.160
那就是Windows

01:26:40.160 --> 01:26:40.400
好

01:26:40.400 --> 01:26:40.960
OB借

01:26:42.240 --> 01:26:42.960
然后

01:26:42.960 --> 01:26:43.680
调用的时候

01:26:43.680 --> 01:26:44.800
OB借点A

01:26:44.800 --> 01:26:45.600
到这个A是啥

01:26:45.600 --> 01:26:46.400
是这个函数

01:26:47.040 --> 01:26:47.760
怎么调用的

01:26:47.760 --> 01:26:48.960
OB借点A

01:26:48.960 --> 01:26:50.640
那么这个A里边的Z是指向啥

01:26:52.800 --> 01:26:53.760
OB借点A

01:26:53.760 --> 01:26:54.320
指向啥

01:26:54.320 --> 01:26:55.200
A里边的Z是

01:26:55.200 --> 01:26:56.160
指向的是OB借

01:26:58.560 --> 01:26:59.440
就确定了

01:26:59.440 --> 01:26:59.920
对吧

01:26:59.920 --> 01:27:01.120
好 接下来我们来看

01:27:01.120 --> 01:27:02.480
A里边怎么调用的呢

01:27:02.480 --> 01:27:03.840
是用D点扩

01:27:03.840 --> 01:27:05.840
D是通过Band得到的Z

01:27:05.840 --> 01:27:06.400
对吧

01:27:06.400 --> 01:27:06.880
所以它

01:27:08.240 --> 01:27:09.520
改变Z是有效吗

01:27:09.520 --> 01:27:09.920
无效

01:27:11.520 --> 01:27:12.880
改变Z是无效

01:27:12.880 --> 01:27:13.680
我们刚才说了是吧

01:27:13.680 --> 01:27:15.680
Band的Z是不能改变的

01:27:17.440 --> 01:27:18.320
通过这种方式去

01:27:18.320 --> 01:27:20.320
想改变Z是别想了

01:27:20.320 --> 01:27:21.520
所以说这个D

01:27:21.520 --> 01:27:22.640
这句话会导致D

01:27:22.640 --> 01:27:23.760
这个函数值想

01:27:23.760 --> 01:27:24.800
D就是B嘛

01:27:24.800 --> 01:27:25.120
对吧

01:27:25.120 --> 01:27:26.320
会导致这个函数值想

01:27:26.320 --> 01:27:27.520
但是Z是

01:27:27.520 --> 01:27:29.200
仍然是指向Windows

01:27:29.200 --> 01:27:30.240
无效

01:27:30.240 --> 01:27:31.360
改变Z是无效

01:27:31.360 --> 01:27:33.600
因为D是来自于绑定Z的结果

01:27:33.600 --> 01:27:34.800
懂了意思吧

01:27:34.800 --> 01:27:35.920
所以说现在运行B

01:27:35.920 --> 01:27:36.240
好

01:27:36.240 --> 01:27:37.120
那么现在就B

01:27:37.120 --> 01:27:38.320
B的Z是指向啥

01:27:38.320 --> 01:27:39.440
指向的是Windows

01:27:39.440 --> 01:27:41.600
B就是指向Windows

01:27:41.600 --> 01:27:42.640
是吧

01:27:42.640 --> 01:27:43.440
调用D嘛

01:27:43.440 --> 01:27:44.800
调用D就是调用B嘛

01:27:44.800 --> 01:27:47.200
而D的Z是被绑定为Windows

01:27:47.520 --> 01:27:48.240
调用B的时候

01:27:48.240 --> 01:27:49.440
它就是Windows

01:27:49.440 --> 01:27:49.520
好

01:27:49.520 --> 01:27:50.800
又来

01:27:50.800 --> 01:27:52.720
我们记一笔吧

01:27:52.720 --> 01:27:54.480
这个时候指向

01:27:54.480 --> 01:27:55.040
调用B

01:27:55.040 --> 01:27:57.200
那指向的就是Windows

01:27:57.200 --> 01:27:57.360
好

01:27:57.360 --> 01:27:58.400
这里定义了一个函数

01:27:58.400 --> 01:27:59.360
CA一箭头函数

01:27:59.360 --> 01:28:00.400
箭头函数就没有这一数

01:28:00.400 --> 01:28:02.720
就不用去分析它的这一数是啥了

01:28:02.720 --> 01:28:02.920
好

01:28:02.920 --> 01:28:05.280
然后使用C Call

01:28:05.280 --> 01:28:07.280
给它传了一个乱七八糟的玩意儿

01:28:07.280 --> 01:28:07.920
有用吗

01:28:07.920 --> 01:28:08.880
没用

01:28:08.880 --> 01:28:10.320
为什么没用

01:28:10.320 --> 01:28:13.200
箭头函数不支持更改这一数

01:28:13.200 --> 01:28:13.720
不支持

01:28:13.720 --> 01:28:14.320
它没有这一数

01:28:14.320 --> 01:28:14.960
你改来看去

01:28:14.960 --> 01:28:15.840
改一改怎么改嘛

01:28:15.840 --> 01:28:16.800
没法改

01:28:16.800 --> 01:28:17.760
它都没有这一数

01:28:17.760 --> 01:28:19.600
所以说调不调用调用

01:28:19.600 --> 01:28:20.640
但是这句话

01:28:20.640 --> 01:28:22.480
跟你直接调用C是一样的

01:28:22.480 --> 01:28:23.440
反正它没有这一数

01:28:23.440 --> 01:28:25.680
你管理怎么去调用它

01:28:25.680 --> 01:28:26.960
所以说这个Z是啥

01:28:26.960 --> 01:28:28.160
Z就是Windows

01:28:28.160 --> 01:28:29.680
Windows里边i是多少

01:28:29.680 --> 01:28:30.280
i是多少

01:28:30.280 --> 01:28:32.400
0

01:28:32.400 --> 01:28:35.100
数数0

01:28:35.100 --> 01:28:37.300
绕了一大圈对吧

01:28:37.300 --> 01:28:37.820
数数啥

01:28:37.820 --> 01:28:41.720
数数0

01:28:41.720 --> 01:28:45.860
要留蓝器印象

01:28:45.860 --> 01:28:47.740
数数0

01:28:47.740 --> 01:28:48.580
其实最终的就是

01:28:48.580 --> 01:28:49.260
如果说这个的话

01:28:49.260 --> 01:28:50.380
要换成选择器的话

01:28:51.180 --> 01:28:52.100
三个选项

01:28:52.100 --> 01:28:53.660
MD-DAN的0

01:28:53.660 --> 01:28:54.300
10

01:28:54.300 --> 01:28:54.540
对吧

01:28:54.540 --> 01:28:55.260
就是三个选项

01:28:56.700 --> 01:28:57.260
等这种听到

01:28:57.260 --> 01:28:59.380
它就会用这种形式来考虑

01:29:05.700 --> 01:29:06.740
这不说你当然有方法

01:29:06.740 --> 01:29:09.140
你没用过字无穿的方法

01:29:09.140 --> 01:29:09.940
应该用过吧

01:29:09.940 --> 01:29:10.940
这里边方法多了

01:29:10.940 --> 01:29:12.100
对吧

01:29:12.100 --> 01:29:14.980
Replace

01:29:14.980 --> 01:29:16.780
Substituted

01:29:16.780 --> 01:29:18.020
对吧

01:29:18.020 --> 01:29:19.420
多

01:29:19.420 --> 01:29:21.060
That's nice

01:29:21.060 --> 01:29:24.460
都是方法

01:29:24.460 --> 01:29:25.460
好了

01:29:25.460 --> 01:29:26.900
那么

01:29:26.940 --> 01:29:28.260
至此呢

01:29:28.260 --> 01:29:30.100
我们原型链Z

01:29:31.700 --> 01:29:32.300
也讲完了

01:29:33.660 --> 01:29:35.300
通过咱们三天的学习

01:29:35.300 --> 01:29:35.580
对

01:29:35.580 --> 01:29:36.180
包装内

01:29:36.180 --> 01:29:36.980
包装内

01:29:36.980 --> 01:29:39.860
他也设计是原始类型吗

01:29:39.860 --> 01:29:40.700
也要使用方法

01:29:40.700 --> 01:29:42.220
他肯定要把它变成堆箱

01:29:43.620 --> 01:29:44.940
通过咱们三天的学习

01:29:44.940 --> 01:29:46.300
搞定了这么六个知识点

01:29:47.380 --> 01:29:49.700
这六个知识点的是介石里面

01:29:49.700 --> 01:29:51.620
特别是介石基础部分

01:29:51.620 --> 01:29:53.980
非常重要的六个知识点

01:29:53.980 --> 01:29:56.380
当然他不是全部的知识点

01:29:56.380 --> 01:29:58.260
还有后边很多

01:29:58.260 --> 01:29:58.620
但是呢

01:29:58.620 --> 01:30:00.780
我们搞定一个就少了一个

01:30:00.780 --> 01:30:05.950
至少以后这六个东西不会在困扰里了

01:30:05.950 --> 01:30:07.670
如果说有一天听了之后

01:30:07.670 --> 01:30:09.270
原老师或老师忘记

01:30:09.270 --> 01:30:10.190
忘记很正常

01:30:10.190 --> 01:30:12.550
我都经常忘记很正常

01:30:12.550 --> 01:30:13.710
但是你忘记了过后

01:30:13.710 --> 01:30:15.310
是很容易把它捡回来的

01:30:16.470 --> 01:30:17.510
但是权力条件

01:30:17.510 --> 01:30:17.870
第一

01:30:17.870 --> 01:30:18.670
你要听懂了

01:30:18.670 --> 01:30:19.590
真正听懂了

01:30:19.590 --> 01:30:20.230
第二

01:30:20.230 --> 01:30:22.630
你要去经过咱们的练习

01:30:22.630 --> 01:30:23.630
就做了一题

01:30:23.630 --> 01:30:24.430
好好练习一下

01:30:24.430 --> 01:30:25.070
最好了

01:30:26.030 --> 01:30:26.670
我跟你说

01:30:26.670 --> 01:30:28.070
同学们好像不是很机器

01:30:28.070 --> 01:30:28.790
在群里边

01:30:30.190 --> 01:30:30.990
我说在群里边

01:30:30.990 --> 01:30:32.350
至最好自己出一些题

01:30:32.350 --> 01:30:36.110
互相给大家出一些题

01:30:37.070 --> 01:30:38.790
然后加深一下印象

01:30:38.790 --> 01:30:39.950
你只要做了这些事

01:30:39.950 --> 01:30:41.270
随便忘

01:30:41.270 --> 01:30:42.110
忘了过后几分钟

01:30:42.110 --> 01:30:42.870
可能就捡起来了

01:30:43.990 --> 01:30:44.950
但是如果说

01:30:44.950 --> 01:30:46.790
你不知道这些东西

01:30:46.790 --> 01:30:47.990
压根就没有听说过

01:30:47.990 --> 01:30:48.670
那就麻烦了

01:30:50.150 --> 01:30:51.030
你没有听说过

01:30:51.030 --> 01:30:52.750
你就不觉得这里是一个问题

01:30:52.750 --> 01:30:53.430
同学们

01:30:53.430 --> 01:30:54.630
我最担心的是什么

01:30:54.710 --> 01:30:57.150
我最担心的不是有问题的同学

01:30:57.150 --> 01:30:59.390
我最担心的是没有问题的同学

01:30:59.390 --> 01:31:00.430
认为自己没有问题

01:31:00.430 --> 01:31:01.390
那是最大的问题

01:31:03.190 --> 01:31:06.110
没有问题的同学问题是最多的

01:31:06.110 --> 01:31:06.910
有问题的同学

01:31:06.910 --> 01:31:08.670
其实我并不是很担心

01:31:08.670 --> 01:31:10.270
因为他知道自己劝学在哪

01:31:10.270 --> 01:31:12.510
他会想办法解决

01:31:12.510 --> 01:31:13.310
没有问题麻烦

01:31:13.310 --> 01:31:14.790
他就不知道自己问题在哪

01:31:14.790 --> 01:31:15.750
他就有问题多的瞎使

01:31:17.350 --> 01:31:17.750
好了

01:31:17.750 --> 01:31:18.910
同学们

01:31:18.910 --> 01:31:20.150
这三天的时间希望

01:31:22.230 --> 01:31:23.190
给大家有所收获

01:31:24.630 --> 01:31:25.350
这些东西呢

01:31:25.350 --> 01:31:27.470
都是咱们前段非常重要的知识

01:31:27.470 --> 01:31:28.550
路得一步一步走

01:31:28.550 --> 01:31:29.830
犯得一口饿吃

01:31:29.830 --> 01:31:30.510
有些东西呢

01:31:30.510 --> 01:31:33.510
我们可能捡约他花的时间长一点

01:31:33.510 --> 01:31:34.310
但是有些东西呢

01:31:34.310 --> 01:31:35.990
其实几句话就可以搞得清楚

01:31:35.990 --> 01:31:37.070
比方说像这些

01:31:37.070 --> 01:31:38.510
就是这个东西呢

01:31:38.510 --> 01:31:41.030
我们你只要把一夜十五掌握好了

01:31:41.030 --> 01:31:42.470
几句话其实你也明白了

01:31:42.470 --> 01:31:44.430
你也知道该怎么去写了

01:31:44.430 --> 01:31:45.390
你基础越好

01:31:45.390 --> 01:31:46.190
越学到后边

01:31:46.190 --> 01:31:48.710
其实你学习东西就越快

01:31:48.710 --> 01:31:50.510
但是前面一定要把基础打好

01:31:50.510 --> 01:31:51.830
你前面基础差得越多

01:31:51.830 --> 01:31:54.310
后边学习举步为先

01:31:54.310 --> 01:31:55.790
你会发现到处是问题

01:31:55.790 --> 01:31:57.710
你还以为是后边框架他来的问题

01:31:57.710 --> 01:31:58.430
其实不是

01:31:58.430 --> 01:31:59.630
其实全是前面的问题

