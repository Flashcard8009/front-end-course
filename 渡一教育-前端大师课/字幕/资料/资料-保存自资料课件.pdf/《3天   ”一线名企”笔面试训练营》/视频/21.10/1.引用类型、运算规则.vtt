WEBVTT

00:00.000 --> 00:06.760
好 呃 首先说一下 咱们这几天呢 讲什么呢 讲主要是讲解释部分的面试题

00:07.680 --> 00:11.880
我这里呢 花点时间 给大家准备了这么一个思维导图

00:12.800 --> 00:17.280
这导图同意没需要的话 我一会就可以上课之后啊 就给发达 发达群里边

00:18.080 --> 00:23.120
这思维导图呢 就大概罗练了以下 咱们前端要完成高薪就业

00:23.720 --> 00:29.000
大概的话 需要哪些知识点 你需要掌握哪些知识点啊

00:30.000 --> 00:32.440
发达出来的话 大概就这样子啊 写的

00:33.720 --> 00:36.280
整体上的覆盖的面呢 是比较全的了

00:37.040 --> 00:45.720
因为我们在去准备一些面试题的时候啊 呃 袁总也老实说 我们这个前端啊 好是卷得越来越厉害了 其实

00:46.280 --> 00:47.760
我个人觉得不是那么回事

00:48.720 --> 00:52.440
因为前端他本身这个行业啊 他的特点就是东西都

00:53.360 --> 00:58.440
每个东西呢 他不像后端那么复杂 但是呢 他东西就是读 可是他的前端这个行业的特点啊

00:58.920 --> 01:05.800
除了考察的面呢 就比较的过啊 从基础部分开始 到后边的网络以及框架部分 包括浏览器

01:06.160 --> 01:10.640
他考察的面特别广 那么将来同学们在做这些面试题的时候呢

01:12.520 --> 01:19.320
不是说每一个公司在考察力的时候 他会把整个的知识面具细无疑的全部考察到

01:19.680 --> 01:22.080
不太可能啊 这样子的话 那里可能在那里

01:22.880 --> 01:25.880
一个公司做面试题的话 那可能就是要做一天都做不完

01:26.360 --> 01:32.000
他不太可能 他会挑一些他觉得我这家公司觉得重要的知识点来进行考察

01:32.960 --> 01:40.240
这个点呢 就会导致了每个公司 他认为的重要的知识点不一样 因为每个公司他要求的业务能力他就不一样

01:40.680 --> 01:44.320
他做的方业务方向就不一样 要求的技术点呢也不一样

01:45.000 --> 01:51.320
那咱们作为一个前端开发者 为了拿高薪怎么办呢 最好的办法就是全都来吧

01:51.960 --> 01:57.160
全部都来吧 你能学就尽量的全部把学会 其实这些知识点呢

01:58.240 --> 02:06.120
我们度疑后边的课程都是有讲的啊 这里可以给给给同学们透露一个消息 咱们度疑呢 现在我正在负责

02:07.200 --> 02:15.280
做一套完整的比面试训练体系出来啊 正在说啊 如果说有星期的同学的话啊 应该

02:16.120 --> 02:24.120
可以赶得上 好了 这就是咱们的整个前端的知识点体系 那么我们这几天讲啥呢 主要是讲这么几个点

02:24.600 --> 02:30.040
它是属于介石部分的 你要说我这几天的时间把这些全部讲完了 它不太现实啊

02:30.520 --> 02:36.880
我们讲的是介石部分这么几个点 而这几个点呢 也是在面试体中高频出现的

02:37.840 --> 02:41.520
啊 我们每一天讲两个知识点啊 三天时间

02:42.520 --> 02:50.520
然后呢 我跟同学们说一下 像这些知识点 它会考察你 考察到什么程度了 每个公司的要求 那又是不一样的

02:51.520 --> 02:58.520
如果说是一些中小型企业的话 它可能考察的比较简单一点啊 我们觉得我们前端卷卷

02:58.520 --> 03:05.520
其实如果说你去一些中小型公司去面试的话 他考察你过难的知识点 那确实有连卷

03:05.520 --> 03:13.520
但是呢 如果说你去大厂面试 或者是去高 你要追求高薪就业的话 考察这些知识点一点儿不愿

03:14.520 --> 03:21.520
有同学讲过呢 那袁老师 那我平时做开发的时候 我没有注意这些知识点啊 我不会这些东西我照样可以开发

03:22.520 --> 03:30.520
啊 那是因为你写的是一些简单的功能 简单的业务代码 而你要追求高薪的话 你肯定不能写这些代码

03:30.520 --> 03:40.520
比方说你去追求进入大厂 大厂对你的要求是什么呀 要求的是你将来要能够写框架 要能够写通用组件

03:41.520 --> 03:50.520
只要你写的东西变得通用了 那么这个事呢 直接从几何倍数的增加 复杂度 指数型的增加 那就增加的不是一清半解

03:51.520 --> 03:55.520
那么这复杂度增加了 这些知识呢 自然而然会派上用场

03:56.520 --> 04:05.520
好了 那么话不多说 我们今天晚上开始我们的学习 我们今天晚上讲啥呢 就讲这两个 一个是预算规则 一个是值和引用

04:06.520 --> 04:12.520
我们先来看值和引用 其实这些东西呢 可能同学们或多或少啊 接触过一些

04:13.520 --> 04:17.520
但是了解的透不透彻呢 这就很难说了啊 听到之后呢 大家应该就霍然开朗了

04:18.520 --> 04:19.520
好 第一个值和引用

04:20.520 --> 04:24.520
这个说的是啥呢 我们从一段代码开始说吧

04:26.520 --> 04:32.520
这个代码呢 就非常简单 我们这里呢 定义了一个变量 这个变量呢 给它复制为一个对象

04:33.520 --> 04:36.520
对象里面有两个属性A等于1 D等于2

04:38.520 --> 04:40.520
好 那么这件事

04:41.520 --> 04:47.520
它到底发生了什么事呢 我不知道同学们对这段代码 这句代码的理解程度如何啊

04:48.520 --> 04:50.520
首先我问大家这么一个问题

04:51.520 --> 04:59.520
如果说我这里写个OB阶等于OB阶 请问我这里输出OB阶 第二OB阶

05:01.520 --> 05:09.470
它会输出什么样的结果 两个选项 一个是对象 一个是OB蛋的

05:10.470 --> 05:15.780
它会输出什么呀 它会输出一个对象还是OB蛋的呢

05:16.780 --> 05:20.780
啊 这里看 这里边就会存在一些问题

05:21.780 --> 05:25.780
所以说大厂它就考察了这些知识点的时候 它会考察得非常非常细致

05:26.780 --> 05:32.780
它一定要清楚 你这一块知识点是模模糊糊的 大概了解的还是彻底了解

05:33.780 --> 05:38.780
你只有彻底了解的 你才能够去应对大厂的一面视频 没有任何取消的办法

05:39.780 --> 05:42.780
这一块它输出的是OB蛋的 就这么神奇

05:42.780 --> 05:47.780
那为什么会出现这种现象呢 我们就要解释一下 这里到底发生了什么事

05:48.780 --> 05:51.780
我们从头来一遍 首先我们看另外一段代码

05:52.780 --> 05:58.780
我这里有两个变量 A等于E B等于A 它发生了什么事 我们先看这段代码

05:59.780 --> 06:04.780
它发生了什么事呢 我们用一张图来进行描述 我把这一块结个图

06:05.780 --> 06:15.270
我们这里的第一句代码是A等于E 那么这个A等于E是什么意思呢

06:16.270 --> 06:22.270
E是一个什么数字类型 在我们介石里边有这么几种类型 一个叫做原始类型

06:23.270 --> 06:30.270
它包含哪些呢 包含数字 number 包含字符创 包含 Boolean, Boole, True, Force

06:31.270 --> 06:36.270
包含Now 包含OB蛋 我们把它称之为原始类型

06:37.270 --> 06:40.270
除了这原始类型之外呢 还有一种类型叫对象类型

06:41.270 --> 06:44.270
对象类型呢 只有一个就是对象

06:45.270 --> 06:49.270
当我们介石里边的对象呢 它包含这么几种 一种的就是普通对象

06:50.270 --> 06:54.270
一种的就是函数 函数本质上也是对象

06:55.270 --> 06:59.270
然后呢 还包含什么呢 还包含一个数组 数组它本身也是对象

07:00.270 --> 07:05.270
我们把这些东西统称为对象类型 除了对象类型之外 其他都是原始类型

07:06.270 --> 07:09.270
那么我们首先看这个代码 它把E复制给一个变量

07:10.270 --> 07:14.270
我们众所周知 变量其实就是一块内存空间

07:15.270 --> 07:16.270
就是一块内存空间

07:17.270 --> 07:20.270
那么这个变量里边存啥呢 一块内存嘛 它多少存点东西吧

07:21.270 --> 07:24.270
那么这个变量里边存啥呢 就是你给它复的值

07:25.270 --> 07:27.270
你给它复的值是什么 复的值就是E 对吧

07:28.270 --> 07:29.270
E是一个什么 原始类型

07:30.270 --> 07:32.270
针对原始类型 它是直接把数据

07:33.270 --> 07:36.270
管它是字符创 还是数字 还是 Boolean, Boolean 无所谓

07:37.270 --> 07:39.270
你只要给它的是原始类型

07:40.270 --> 07:43.270
那么它就直接把数据存到这个内存空间里边去了

07:44.270 --> 07:45.270
就这么简单

07:46.270 --> 07:52.270
于是现在我们看到的这个A里边就包含了一个E 数字E

07:53.270 --> 07:56.270
接下来我们把A复制给B 接下来就发生这么一件事

07:57.270 --> 07:59.270
现在又开辟了一块内存空间B

08:01.840 --> 08:04.840
我们把A复制给B 注意在GS里边

08:04.840 --> 08:07.840
会以很多地方会出现数据的传递

08:08.840 --> 08:11.840
什么叫数据传递 就是数据从一个地方传到另一个地方

08:12.840 --> 08:14.840
复制就是数据传递的一种方式

08:15.840 --> 08:17.840
那其中我们其实还有很多种数据传递方式

08:18.840 --> 08:20.840
包括什么呢 包括函数

08:21.840 --> 08:22.840
比如说你来一个函数

08:24.840 --> 08:25.840
AD

08:26.840 --> 08:27.840
RECORN A加D

08:28.840 --> 08:30.840
那么这里的雕用函数把A传进去 B传进去

08:31.840 --> 08:32.840
那么这里也有数据传递

08:32.840 --> 08:37.840
它把这个A的值 这个A的值传给参数A

08:38.840 --> 08:39.840
把这个B的值传给参数B

08:40.840 --> 08:43.840
变量就是数据传递发生在很多的地方

08:44.840 --> 08:47.840
复制以及我们的函数调用都会发生数据传递

08:48.840 --> 08:52.840
记住了同学们 今天晚上遇到了第一个重要的理解

08:53.840 --> 08:56.840
所有数在介事语言中

08:56.840 --> 08:59.840
所有的数据传递全部都是复制张贴

08:59.840 --> 09:01.840
你给我记死了 把这个值传点

09:02.840 --> 09:05.840
所有的数据传递全部都是复制张贴

09:05.840 --> 09:07.840
没有任何特殊例外的情况

09:08.840 --> 09:10.840
有没有例外呢 严格来说有一点例外

09:11.840 --> 09:12.840
但是跟同学们现在没有什么关系

09:13.840 --> 09:15.840
将来你们学到魔画画的时候

09:16.840 --> 09:17.840
那个地方有一点点例外

09:18.840 --> 09:20.840
其他的任何时候全都是复制张贴

09:20.840 --> 09:22.840
什么叫复制张贴 非常简单

09:22.840 --> 09:24.840
你这个A那边有个E传给B

09:24.840 --> 09:26.840
那就是把A那边的东西复制张贴给B

09:27.840 --> 09:28.840
就这么简单就完成了

09:29.840 --> 09:30.840
所以说面对这种情况

09:31.840 --> 09:32.840
如果说你后边去改动这个B

09:33.840 --> 09:34.840
B加加

09:35.840 --> 09:36.840
然后我们来输出A和B

09:36.840 --> 09:38.840
那么自然而然你们会得到1和2

09:38.840 --> 09:40.840
对吧 为什么会得到这样的结果呢

09:40.840 --> 09:42.840
因为你B加加只是加了这块的一层空间

09:42.840 --> 09:43.840
加成2了

09:44.840 --> 09:45.840
A变变变 没变

09:45.840 --> 09:46.840
1 2

09:46.840 --> 09:47.840
所以说最终结果了

09:47.840 --> 09:48.840
输出1和2

09:48.840 --> 09:50.840
这个代码大家肯定是没有任何问题的

09:50.840 --> 09:51.840
这个代码比较简单

09:51.840 --> 09:53.840
好 现在我们再回过头来

09:53.840 --> 09:55.840
看上面的代码如何来迎接

09:55.840 --> 10:02.150
上面这个代码是把一个对象传接OB界

10:02.150 --> 10:04.150
那么这个玩意有什么理解呢

10:04.150 --> 10:05.150
我们把这个复制一下

10:09.780 --> 10:15.780
那么这个代码有什么理解呢

10:15.780 --> 10:17.780
你要这么看这个代码

10:17.780 --> 10:20.780
对这个代码的理解是模模糊糊的

10:21.780 --> 10:24.780
首先我们的表达式运算

10:24.780 --> 10:26.780
一定是从右到左的

10:26.780 --> 10:27.780
为什么呢

10:27.780 --> 10:29.780
因为这是一个复制预据

10:29.780 --> 10:31.780
把右边的复制给左边

10:31.780 --> 10:34.780
一定是从右到左来进行运算

10:34.780 --> 10:36.780
好 那么我们先来算什么

10:36.780 --> 10:37.780
先来算右边的

10:37.780 --> 10:39.780
现在算这一坨

10:39.780 --> 10:40.780
这一坨在干嘛呢

10:40.780 --> 10:44.780
这一坨代码你别认为它是没有意义的

10:44.780 --> 10:45.780
它是有意义的

10:45.780 --> 10:47.780
就不看前面的复制

10:47.780 --> 10:48.780
就看这一坨

10:48.780 --> 10:49.780
这个代码什么意义呢

10:49.780 --> 10:52.780
它是开辟一块内存空间

10:52.780 --> 10:54.780
在哪呢 随便在哪

10:54.780 --> 10:57.780
这个内存空间里边有两个属性

10:57.780 --> 10:58.780
于是你可以这样认为

10:58.780 --> 11:00.780
它有一块内存空间

11:00.780 --> 11:02.780
这个内存空间有两个属性

11:02.780 --> 11:05.780
第一个属性是A 它的值是1

11:05.780 --> 11:08.780
第二个属性是B 它的值是2

11:08.780 --> 11:09.780
要这么理解

11:09.780 --> 11:11.780
实际上这里有两个属性

11:11.780 --> 11:13.780
那么这两个属性

11:13.780 --> 11:15.780
它们共同组成了一块内存空间

11:15.780 --> 11:19.780
这是我刚刚圈这个地方

11:19.780 --> 11:20.780
它做的事

11:20.780 --> 11:22.780
它是开辟了一块新的内存空间

11:22.780 --> 11:25.780
然后把它的内存空间地址

11:25.780 --> 11:28.780
复制给这个变量OBG

11:28.780 --> 11:31.780
所以说我们现在看到的变量OBG里边

11:31.780 --> 11:32.780
它保存的是啥呢

11:32.780 --> 11:34.780
它保存的不是这个对象

11:34.780 --> 11:37.780
保存的是对象的一个地址

11:37.780 --> 11:38.780
所以有的时候

11:38.780 --> 11:39.780
我们可以简单地图上画的话

11:39.780 --> 11:41.780
那么我们就可以认为

11:41.780 --> 11:42.780
这个地址记录的是什么呢

11:42.780 --> 11:43.780
记录的就是

11:43.780 --> 11:45.780
这一个内存空间的地址

11:45.780 --> 11:46.780
懂了意思吧

11:46.780 --> 11:47.780
相当于是时候拿个纸条

11:47.780 --> 11:49.780
这个纸条记录到的

11:49.780 --> 11:51.780
哪条间 门牌号在哪

11:51.780 --> 11:52.780
然后通过这个地址

11:52.780 --> 11:54.780
是不是可以找到这个对象了

11:54.780 --> 11:56.780
因此我们有的时候画图

11:56.780 --> 11:58.780
所以通过这个连接

11:58.780 --> 11:59.780
给它连过去

11:59.780 --> 12:01.780
表示我们这一块呢

12:01.780 --> 12:06.780
是有这么一个指向的关系

12:06.780 --> 12:07.780
好 通过这个地址

12:07.780 --> 12:08.780
是不是可以找到对象

12:08.780 --> 12:10.780
属性A 属性B都可以找到

12:10.780 --> 12:12.780
就这么个意思

12:12.780 --> 12:14.780
好 那么现在我们问题来了

12:14.780 --> 12:15.780
为什么那个

12:15.780 --> 12:16.780
我们刚才说的

12:16.780 --> 12:18.780
原式内形是直接放到这里边的

12:18.780 --> 12:19.780
而我们的对象

12:19.780 --> 12:21.780
是用这种方式来放的呢

12:21.780 --> 12:24.780
就是既也是原它的规则

12:24.780 --> 12:27.780
我们通常把它叫做直内象

12:27.780 --> 12:28.780
而对象内象呢

12:28.780 --> 12:30.780
通常把它叫做引用内象

12:30.780 --> 12:31.780
引用的意识呢

12:31.780 --> 12:34.780
我们就可以认为是地址的意识

12:34.780 --> 12:36.780
就是我对边上里边只保存地址

12:36.780 --> 12:38.780
因此它最终出来的内存结构图呢

12:38.780 --> 12:39.780
是这个样子的

12:39.780 --> 12:41.780
好 那同学说

12:41.780 --> 12:42.780
那这个往下怎么解释

12:42.780 --> 12:43.780
刚才那个现象呢

12:43.780 --> 12:45.780
来一个解释一下这个现象

12:45.780 --> 12:48.780
好 那么我们来解释一下这个现象

12:48.780 --> 12:49.780
为什么它 这个OB界

12:49.780 --> 12:53.220
它是Anglican

12:53.220 --> 12:56.660
好 我们再来从头来一次啊

12:56.660 --> 13:00.660
首先我们从右向左来进行移刷

13:00.660 --> 13:03.660
从右向左一开始没有这个边量

13:03.660 --> 13:04.660
右边是什么呢

13:04.660 --> 13:06.660
右边是生存了一块内存空间

13:06.660 --> 13:07.660
它有三个属性

13:07.660 --> 13:09.660
一个是A 一个是B

13:09.660 --> 13:12.660
一个是OB界

13:12.660 --> 13:13.660
B

13:17.940 --> 13:18.940
B

13:18.940 --> 13:20.940
然后一个是OB界

13:20.940 --> 13:22.940
好 那么请问

13:22.940 --> 13:23.940
这个OB界的值是什么

13:23.940 --> 13:25.940
它OB界的值独的是啥

13:25.940 --> 13:27.940
独的是这个OB界

13:27.940 --> 13:28.940
现在有OB界这个边量吗

13:28.940 --> 13:29.940
现在没有

13:29.940 --> 13:31.940
因为现在还没有完成复职

13:31.940 --> 13:33.940
还在创建这个对象

13:33.940 --> 13:34.940
懂了意思吧

13:34.940 --> 13:35.940
除了这里的值呢

13:35.940 --> 13:36.940
是Anglican

13:36.940 --> 13:41.310
然后这个对象创建完成

13:41.310 --> 13:43.310
接下来才是完成复职

13:43.310 --> 13:44.310
完成复职的时候

13:44.310 --> 13:47.310
然后现在在生存一块内存空间

13:47.310 --> 13:50.310
它的叫做OB界

13:50.310 --> 13:51.310
然后呢

13:51.310 --> 13:52.310
里边保存一个地址

13:52.310 --> 13:55.310
这个地址指向这一块对象

13:55.310 --> 13:56.310
所以说有的时候

13:56.310 --> 13:57.310
我们简单化的话

13:57.310 --> 14:00.310
是一个箭头连过去

14:00.310 --> 14:01.310
因此呢

14:01.310 --> 14:02.310
我们打印OB界

14:02.310 --> 14:04.310
第二OB界

14:04.310 --> 14:05.310
通过这个地址

14:05.310 --> 14:06.310
去找了个属性OB界

14:06.310 --> 14:07.310
它里边是咋

14:07.310 --> 14:08.310
是咋子

14:08.310 --> 14:10.310
这一块你能理解啊

14:10.310 --> 14:12.310
以前我遇到过

14:12.310 --> 14:13.310
有些东西面试体

14:13.310 --> 14:16.940
还有出过这种桃体

14:16.940 --> 14:18.940
没问题了QA1

14:18.940 --> 14:24.240
这里有问题吧

14:24.240 --> 14:27.240
有问题就问问题

14:27.240 --> 14:29.240
养房同学有什么问题

14:29.240 --> 14:31.680
这问题在哪

14:31.680 --> 14:33.680
所以说同学们要

14:33.680 --> 14:34.680
摒弃之前那种

14:34.680 --> 14:36.680
模糊不清的那种理解

14:36.680 --> 14:37.680
这个代码你要这样理解

14:37.680 --> 14:39.680
要分成两段来看

14:39.680 --> 14:40.680
第一段

14:40.680 --> 14:41.680
创建对象

14:41.680 --> 14:43.680
把这个内存给我弄出来

14:43.680 --> 14:45.680
弄出来过后就这个样子

14:45.680 --> 14:48.680
这个时候还没有变量

14:48.680 --> 14:49.680
没有变量

14:49.680 --> 14:53.950
那变了只当当事上的地方

14:53.950 --> 14:54.950
好然后

14:54.950 --> 14:56.950
然后再把这个对象

14:56.950 --> 14:57.950
对象现在出来了对吧

14:57.950 --> 14:58.950
然后再把对象地址

14:58.950 --> 15:00.950
复职给这个变量

15:00.950 --> 15:01.950
是吧

15:01.950 --> 15:03.950
盧本文同学说reference error

15:03.950 --> 15:05.950
undefend搞不清

15:05.950 --> 15:07.950
这两个就没有任何关系

15:07.950 --> 15:08.950
你说reference

15:08.950 --> 15:10.950
要引用错误是吧

15:10.950 --> 15:13.950
你说的引用错误是指杀啊

15:13.950 --> 15:14.950
undefend是

15:14.950 --> 15:15.950
GS里面一个内形

15:15.950 --> 15:17.950
reference error是一个错误

15:17.950 --> 15:20.950
一个内形跟一个错误搞不清

15:20.950 --> 15:22.950
有问题在哪

15:22.950 --> 15:24.950
要不然好好组织一下

15:24.950 --> 15:25.950
语言

15:25.950 --> 15:26.950
他的问题

15:26.950 --> 15:28.950
完整问出来

15:29.950 --> 15:30.950
这是我们现在搞清楚

15:30.950 --> 15:31.950
第一个东西

15:31.950 --> 15:34.950
好现在我们再来看一个段代码

15:34.950 --> 15:35.950
好那同学

15:35.950 --> 15:37.950
那你这样子我倒是理解了

15:37.950 --> 15:38.950
以这个对象啊

15:38.950 --> 15:39.950
地址保存在这

15:39.950 --> 15:41.950
那如果说

15:41.950 --> 15:44.950
我的代码是这样子的呢

15:44.950 --> 15:46.950
我的代码你看着啊

15:46.950 --> 15:48.950
我的代码a等于1

15:48.950 --> 15:49.950
这个没得说

15:49.950 --> 15:51.950
然后呢接下来有一个

15:51.950 --> 15:52.950
配吧

15:52.950 --> 15:53.950
随便来一个

15:53.950 --> 15:54.950
b等于2

15:54.950 --> 15:55.950
哎然后是你怎么用图

15:55.950 --> 15:57.950
来解释这个代码呢

15:57.950 --> 15:59.950
这个代码该怎么去理解呢

15:59.950 --> 16:00.950
啊你刚才说

16:00.950 --> 16:01.950
整个对象是一个地址

16:01.950 --> 16:03.950
保存到这个边疆里边去了

16:03.950 --> 16:05.950
那这个代码你这又一个对象

16:05.950 --> 16:07.950
那他的地址在哪呢

16:07.950 --> 16:10.950
好咱们来看一下这个代码的东西

16:10.950 --> 16:11.950
所以说我们学知识啊

16:11.950 --> 16:13.950
一定要把东西理解准确

16:13.950 --> 16:14.950
理解准确过后

16:14.950 --> 16:16.950
这些面词题随便怎么绕弯

16:16.950 --> 16:18.950
他都不会考到你了

16:18.950 --> 16:19.950
还是一样

16:19.950 --> 16:21.950
最开始的时候

16:21.950 --> 16:22.950
做什么

16:22.950 --> 16:24.950
做这个对象创建的工作

16:24.950 --> 16:26.950
先把个对象创建好了再说

16:26.950 --> 16:28.950
你不要说负负什么负责

16:28.950 --> 16:29.950
现在还没有负责

16:29.950 --> 16:31.950
先把对象创建好

16:31.950 --> 16:33.950
好创建对象就是开闭一块六分空间

16:33.950 --> 16:34.950
然后a等于

16:34.950 --> 16:36.950
接下来是另外一个属性

16:36.950 --> 16:37.950
k

16:37.950 --> 16:39.950
k等于什么呢

16:39.950 --> 16:40.950
你看啊

16:40.950 --> 16:41.950
k等于啥呢

16:41.950 --> 16:43.950
他又等于一个对象

16:43.950 --> 16:45.950
是不是又要创建对象

16:45.950 --> 16:47.950
哎创建对象

16:47.950 --> 16:48.950
同学们一定记住

16:48.950 --> 16:50.950
牢牢的印在自己的脑海里边

16:50.950 --> 16:52.950
一旦出现创建对象

16:52.950 --> 16:54.950
那一定是百分之百的

16:54.950 --> 16:56.950
没有任何商量的

16:56.950 --> 16:58.950
一个新的内存空间诞生了

16:58.950 --> 17:00.950
它里边有一个属性

17:00.950 --> 17:02.950
b等于2

17:02.950 --> 17:04.950
这就是创建对象

17:04.950 --> 17:05.950
那么这一段单码解释了啥

17:05.950 --> 17:07.950
解释了我现在里边的圈圈

17:07.950 --> 17:09.950
对象创建完成

17:09.950 --> 17:11.950
然后把对象的地址

17:11.950 --> 17:12.950
复制给谁

17:12.950 --> 17:14.950
复制给这个属性k

17:14.950 --> 17:16.950
所以说属性k里面存的是啥

17:16.950 --> 17:17.950
存的是一个地址

17:17.950 --> 17:19.950
那我直接用箭头了啊

17:19.950 --> 17:21.950
属性k存的是一个地址

17:21.950 --> 17:23.950
它指向这个新的对象

17:23.950 --> 17:25.950
懂得意思了吧

17:27.950 --> 17:29.950
就这么个意思

17:29.950 --> 17:31.950
就形成了这么一种结构

17:31.950 --> 17:32.950
实际上这里有几个对象

17:32.950 --> 17:34.950
实际上我们平时说就一个对象

17:34.950 --> 17:36.950
但是实际上它有两个对象

17:36.950 --> 17:37.950
一个是这个对象

17:37.950 --> 17:39.950
一个是这个对象

17:39.950 --> 17:42.950
然后对象创建工作完成

17:42.950 --> 17:44.950
接下来来一个变量

17:44.950 --> 17:46.950
这个变量呢

17:46.950 --> 17:48.950
名字叫做obj

17:48.950 --> 17:50.950
这个变量存的是什么呢

17:50.950 --> 17:52.950
存的是这个对象的地址

17:52.950 --> 17:53.950
对吧

17:53.950 --> 17:54.950
两个属性嘛

17:54.950 --> 17:55.950
一个a一个k

17:55.950 --> 17:56.950
说这个对象的地址

17:56.950 --> 17:57.950
把这个对象的地址

17:57.950 --> 17:58.950
放到这里边

17:58.950 --> 17:59.950
然后呢

17:59.950 --> 18:02.950
这里边它自然而然就指向这个对象

18:02.950 --> 18:03.950
这里边

18:03.950 --> 18:04.950
它这个变量里面

18:04.950 --> 18:05.950
就存的是一个什么

18:05.950 --> 18:06.950
存的是一个地址

18:06.950 --> 18:10.390
它就指向这个对象

18:10.390 --> 18:12.390
它就形成了这么一种结构

18:12.390 --> 18:13.390
所以说我们有的时候呢

18:13.390 --> 18:14.390
去用

18:14.390 --> 18:16.390
用这个objk.b

18:16.390 --> 18:17.390
可不可以呢

18:17.390 --> 18:18.390
当然可以

18:18.390 --> 18:19.390
它怎么找的呢

18:19.390 --> 18:20.390
你看啊

18:20.390 --> 18:21.390
我们比方说我们这样用

18:21.390 --> 18:23.390
objk.b

18:23.390 --> 18:24.390
你看objk.b

18:24.390 --> 18:26.390
是不是可以找到

18:26.390 --> 18:28.390
这个对象

18:28.390 --> 18:29.390
而这个对象表k

18:29.390 --> 18:31.390
是不是可以找到它的属性k

18:31.390 --> 18:33.390
而它的k是不是一个对象

18:33.390 --> 18:35.390
对象是不是又找到这个对象呢

18:35.390 --> 18:36.390
对象里边表逼

18:36.390 --> 18:37.390
就找到它了

18:37.390 --> 18:38.390
对吧

18:38.390 --> 18:39.390
一开始呢

18:39.390 --> 18:40.390
你可能觉得

18:40.390 --> 18:41.390
跟我平时的理解

18:41.390 --> 18:42.390
好像不太一样

18:42.390 --> 18:43.390
感觉不太一样

18:43.390 --> 18:44.390
对吧

18:44.390 --> 18:45.390
或者说我平时

18:45.390 --> 18:46.390
根本没有这样的理解

18:46.390 --> 18:47.390
但是慢慢就习惯了

18:47.390 --> 18:48.390
像我的话

18:48.390 --> 18:49.390
早就已经形成条件反射了

18:49.390 --> 18:51.390
就脑袋里边的不用去画图了

18:51.390 --> 18:53.390
直接就形成这么一张结构

18:53.390 --> 18:55.390
就这么一种结构

18:55.390 --> 18:56.390
首先

18:56.390 --> 18:57.390
首先我们这里

18:57.390 --> 18:59.390
要做那种值和引用的面试题

18:59.390 --> 19:00.390
首先你第一点

19:00.390 --> 19:02.390
你首先要搞清楚

19:02.390 --> 19:03.390
对象啊值啊

19:03.390 --> 19:05.390
它的内存空间是怎么分布的

19:05.390 --> 19:07.390
它是怎么来点的

19:07.390 --> 19:08.390
只要你看到对象

19:08.390 --> 19:09.390
它保存了一定是

19:09.390 --> 19:10.390
无论它在什么地方

19:10.390 --> 19:12.390
保存了一定是地址

19:12.390 --> 19:14.390
这个地址只像这个内存空间

19:14.390 --> 19:15.390
只要你看到值

19:15.390 --> 19:17.390
就是直接贴到这儿

19:17.390 --> 19:19.390
好 接下来再来看

19:19.390 --> 19:20.390
那如果说

19:20.390 --> 19:21.390
它继续写代码

19:21.390 --> 19:23.390
我把右定一个新的辨量

19:23.390 --> 19:25.390
obj2

19:25.390 --> 19:27.390
等于obj

19:27.390 --> 19:28.390
然后呢

19:28.390 --> 19:33.390
我针对把这个obj2.a加加

19:33.390 --> 19:34.390
我做了这么一件事

19:34.390 --> 19:36.390
这又是另外一段代码

19:36.390 --> 19:40.020
下面的这段代码

19:40.020 --> 19:42.020
这段代码又在做什么呢

19:42.020 --> 19:44.020
我们来研究一下

19:44.020 --> 19:46.020
现在我要把obj

19:46.020 --> 19:48.020
就这里边的东西

19:48.020 --> 19:52.340
复制给谁一个新的辨量

19:52.340 --> 19:55.340
一个新的辨量叫做obj2

19:55.340 --> 19:57.340
那么它是怎么复制的呢

19:57.340 --> 19:58.340
我刚才说了

19:58.340 --> 20:00.340
所有的辨量复制

20:00.340 --> 20:03.340
都是复制粘贴

20:03.340 --> 20:04.340
那么相当于是什么呢

20:04.340 --> 20:06.340
把obj这里边的东西

20:06.340 --> 20:09.340
复制粘贴到obj2

20:09.340 --> 20:10.340
那这里边啥东西

20:10.340 --> 20:11.340
这里边只有一个地址

20:11.340 --> 20:13.340
存的就是一个地址

20:13.340 --> 20:15.340
那么这里边存的也是地址

20:15.340 --> 20:16.340
那这里边的地址

20:16.340 --> 20:17.340
复制粘贴过来

20:17.340 --> 20:18.340
那么你想一想这个道理

20:18.340 --> 20:19.340
它的地址只像这儿

20:19.340 --> 20:20.340
那它的地址

20:20.340 --> 20:21.340
是不是也得只像这儿

20:21.340 --> 20:22.340
对吧

20:22.340 --> 20:23.340
那这个毫无疑问

20:23.340 --> 20:25.340
它的地址也应该只像这儿

20:27.340 --> 20:28.340
所以说呢

20:28.340 --> 20:30.340
obj和obj2

20:30.340 --> 20:31.340
这两个辨量一样吗

20:31.340 --> 20:32.340
不一样

20:32.340 --> 20:33.340
他们里边

20:33.340 --> 20:35.340
他们是独立的内存空间

20:35.340 --> 20:37.340
就是obj的内存空间

20:37.340 --> 20:39.340
跟obj2的内存空间

20:39.340 --> 20:40.340
是独立的

20:40.340 --> 20:41.340
但是

20:41.340 --> 20:43.340
他们里边存的地址

20:43.340 --> 20:44.340
是一样的

20:44.340 --> 20:45.340
他们只像同一个

20:45.340 --> 20:46.340
对象的地址

20:46.340 --> 20:48.340
因此你后边针对

20:48.340 --> 20:49.340
通过obj2

20:49.340 --> 20:50.340
把a加1了

20:50.340 --> 20:52.340
obj2把a加1了

20:52.340 --> 20:53.340
所以这里变成2了

20:53.340 --> 20:54.340
那这里变成2了

20:54.340 --> 20:55.340
那obj

20:55.340 --> 20:56.340
是不是obj变成2了

20:56.340 --> 20:57.340
不是

20:57.340 --> 20:58.340
是obj里面地址

20:58.340 --> 20:59.340
只像了这个对象

20:59.340 --> 21:00.340
它的a变成2了

21:00.340 --> 21:01.340
所以说我们最后

21:01.340 --> 21:02.340
如果说起你去打印

21:02.340 --> 21:04.340
obj2

21:04.340 --> 21:05.340
obj2

21:05.340 --> 21:06.340
obj2

21:06.340 --> 21:07.340
obj2

21:07.340 --> 21:08.340
他们是同一块内存空间

21:08.340 --> 21:10.340
因此你去找

21:10.340 --> 21:12.340
输出obj2

21:12.340 --> 21:13.340
obj2

21:13.340 --> 21:15.340
他们一定是一样的

21:15.340 --> 21:16.340
那两个都是2

21:16.340 --> 21:17.340
都改变

21:17.340 --> 21:18.340
就是这个原因

21:19.340 --> 21:20.340
好

21:20.340 --> 21:21.340
那么我们再来一点

21:21.340 --> 21:22.340
稍微绕一点

21:22.340 --> 21:23.340
接下来

21:23.340 --> 21:26.710
我做这么一件事

21:26.710 --> 21:28.710
我对这个ob

21:28.710 --> 21:30.710
我在a加加之前

21:30.710 --> 21:32.710
我把obj2

21:32.710 --> 21:34.710
重新附近

21:34.710 --> 21:36.710
为一个新的对象

21:37.710 --> 21:40.710
让它等于a2

21:41.710 --> 21:42.710
好 同学们

21:43.710 --> 21:44.710
来

21:44.710 --> 21:45.710
我们来看一下

21:45.710 --> 21:52.890
这个代码

21:52.890 --> 21:53.890
这个代码

21:53.890 --> 21:54.890
最终会输出

21:54.890 --> 21:55.890
怎么样的结果呢

21:55.890 --> 22:03.100
是2个2吗

22:03.100 --> 22:05.100
还是1个1

22:05.100 --> 22:10.940
1个2呢

22:10.940 --> 22:11.940
好 这里是不是

22:11.940 --> 22:12.940
1个1

22:12.940 --> 22:13.940
1个2了

22:13.940 --> 22:14.940
我们先把这个道理搞清楚

22:14.940 --> 22:15.940
我们再来看这个面试题

22:15.940 --> 22:17.940
道理搞清楚过后

22:17.940 --> 22:18.940
再看面试题就明白

22:18.940 --> 22:19.940
就什么都明白了

22:19.940 --> 22:21.940
然后这里就是变成1和2了

22:21.940 --> 22:22.940
那为什么会变成1和呢

22:22.940 --> 22:24.940
我们还是用内存图来解释

22:25.940 --> 22:26.940
当你熟练之后

22:26.940 --> 22:28.940
你就不用画内存图了

22:29.940 --> 22:30.940
好

22:30.940 --> 22:32.940
再看

22:32.940 --> 22:33.940
首先第一步

22:33.940 --> 22:34.940
obj负责给obj2

22:34.940 --> 22:35.940
是一样的

22:35.940 --> 22:36.940
还是这样的吧

22:36.940 --> 22:37.940
一开始a是1

22:38.940 --> 22:39.940
好 接下来

22:39.940 --> 22:41.940
我把obj2重新复制了

22:41.940 --> 22:42.940
来看

22:42.940 --> 22:44.940
是不是又来了一次

22:44.940 --> 22:46.940
刚才是怎么说的

22:46.940 --> 22:47.940
只要你看到这个东西

22:47.940 --> 22:51.940
那一定是在创建一个新的对象

22:51.940 --> 22:54.940
那于是一个新的对象产生了

22:54.940 --> 22:55.940
这对象里边

22:55.940 --> 22:56.940
只有一个属性

22:56.940 --> 22:58.940
就是a等于2

22:58.940 --> 22:59.940
跟它之前有关系吗

22:59.940 --> 23:01.940
一毛钱关系都没有

23:01.940 --> 23:03.940
然后把这个新的对象复制给谁

23:03.940 --> 23:05.940
复制给obj2

23:05.940 --> 23:07.940
所以obj2以前的地址是指向这的

23:07.940 --> 23:09.940
但是这一个复制

23:09.940 --> 23:10.940
就改变了它的地址

23:10.940 --> 23:12.940
它的地址被覆盖掉了

23:12.940 --> 23:13.940
变成一个新的地址了

23:13.940 --> 23:15.940
这个新的地址指向谁

23:15.940 --> 23:16.940
指向这的

23:17.940 --> 23:18.940
所以说这个时候

23:19.940 --> 23:20.940
obja

23:20.940 --> 23:21.940
a.a

23:21.940 --> 23:23.940
和obj2.a

23:24.940 --> 23:25.940
没有什么关系的

23:25.940 --> 23:27.940
然后它在a加加变成3

23:28.940 --> 23:30.940
所以得到结果是1

23:30.940 --> 23:32.940
输出obj2.a

23:32.940 --> 23:33.940
1

23:33.940 --> 23:34.940
obj2.a

23:34.940 --> 23:35.940
3

23:35.940 --> 23:38.440
好

23:38.440 --> 23:39.440
这是讲到目前为止

23:39.440 --> 23:41.440
讲到目前为止没问题吧

23:41.440 --> 23:42.440
目前为止没问题的话

23:42.440 --> 23:44.440
其实你同意

23:44.440 --> 23:46.440
可得其他的所有的问题

23:46.440 --> 23:47.440
应该没了

23:47.440 --> 23:48.440
理论上应该没了

23:48.440 --> 23:50.440
但是我们还要多训练一下

23:50.440 --> 23:51.440
看一下有没有什么问题

23:51.440 --> 23:52.440
没问题

23:56.610 --> 23:58.610
一问题同学就把问题描述出来

23:59.610 --> 24:00.610
因为你打个二的话

24:00.610 --> 24:02.610
我也不可能从头到尾再给哪一边

24:03.610 --> 24:05.610
把主要的你激动的问题

24:05.610 --> 24:06.610
哪里没听懂

24:06.610 --> 24:07.610
你说一下

24:07.610 --> 24:08.610
好

24:08.610 --> 24:09.610
那没问题的话

24:09.610 --> 24:10.610
咱们就开始绕了

24:10.610 --> 24:11.610
绕来了

24:11.610 --> 24:13.610
接下来我就开始各种绕了

24:14.610 --> 24:16.610
我怎么来绕这个东西呢

24:18.610 --> 24:19.610
我来吧

24:19.610 --> 24:24.670
这样子吧

24:24.670 --> 24:26.670
首先来这么绕一下

24:27.670 --> 24:28.670
obj

24:29.670 --> 24:31.670
obj.a

24:32.670 --> 24:33.670
ar

24:33.670 --> 24:35.670
2k

24:36.670 --> 24:37.670
0

24:37.670 --> 24:38.670
2k.b

24:38.670 --> 24:39.670
加加

24:39.670 --> 24:41.670
然后ar1

24:41.670 --> 24:43.670
2b加加

24:44.670 --> 24:45.670
好

24:45.670 --> 24:49.670
然后我输出ar0.k.b

24:49.670 --> 24:53.670
然后再输出ar1.b

24:53.670 --> 24:56.670
然后再输出obj.k.b

24:56.670 --> 24:58.670
其实我要问的是

24:58.670 --> 25:00.670
这三个b是不是一样的

25:00.670 --> 25:08.500
这三个b是不是一样的

25:08.500 --> 25:10.500
你就告诉我是不是一样的就行了

25:10.500 --> 25:26.670
是不是一样的

25:26.670 --> 25:27.670
那肯定是一样的嘛

25:27.670 --> 25:28.670
对吧

25:28.670 --> 25:29.670
那肯定是一样的

25:29.670 --> 25:30.670
为什么呢

25:30.670 --> 25:31.670
你看一下这个obj

25:31.670 --> 25:32.670
你就这样子看

25:32.670 --> 25:33.670
最简单的看法

25:33.670 --> 25:35.670
obj是不是对象

25:35.670 --> 25:36.670
它是不是对象

25:36.670 --> 25:37.670
它是不是对象

25:37.670 --> 25:38.670
那这里传过来

25:38.670 --> 25:39.670
传到输主的第一项

25:39.670 --> 25:41.670
一定是地址

25:41.670 --> 25:43.670
k是不是对象

25:43.670 --> 25:44.670
一定是对象

25:44.670 --> 25:46.670
它传过来的一定是地址

25:46.670 --> 25:47.670
所以说输主里面

25:47.670 --> 25:48.670
包含了保存了两个东西

25:48.670 --> 25:49.670
保存了两个是啥

25:49.670 --> 25:50.670
两个都是地址

25:50.670 --> 25:51.670
用内存图画出来的话

25:51.670 --> 25:55.180
就这样子

25:55.180 --> 25:56.180
内存图画出来

25:56.180 --> 25:58.180
这就是ar2了

25:58.180 --> 25:59.180
这个ar2呢

25:59.180 --> 26:00.180
它本身是个输主

26:00.180 --> 26:01.180
输主是不是对象

26:01.180 --> 26:02.180
它输主又是个对象

26:02.180 --> 26:03.180
你看

26:03.180 --> 26:05.180
就这一段来嘛

26:05.180 --> 26:08.180
到底在干嘛

26:08.180 --> 26:09.180
像蜀链

26:09.180 --> 26:10.180
你开始不看蜀链的时候

26:10.180 --> 26:11.180
觉得有点糟

26:11.180 --> 26:12.180
其实蜀链过后

26:12.180 --> 26:14.180
就很好分析的

26:14.180 --> 26:15.180
它是一个输主嘛

26:15.180 --> 26:16.180
首先

26:16.180 --> 26:17.180
输主它肯定也是对象

26:17.180 --> 26:18.180
输主也是一种对象

26:18.180 --> 26:20.180
它都不能算特殊的对象

26:20.180 --> 26:21.180
它就是对象

26:21.180 --> 26:22.180
输主的属性是什么

26:22.180 --> 26:23.180
属性是数字嘛

26:23.180 --> 26:24.180
0

26:24.180 --> 26:25.180
1

26:25.180 --> 26:26.180
对吧

26:26.180 --> 26:27.180
这是它的属性名

26:27.180 --> 26:28.180
属性的值呢

26:28.180 --> 26:29.180
第一个值是什么

26:29.180 --> 26:30.180
ob借

26:30.180 --> 26:31.180
所以把这个地址

26:31.180 --> 26:33.180
复制粘贴到这儿了

26:33.180 --> 26:35.180
那么这个地方是不是地址

26:35.180 --> 26:36.180
那既然是地址

26:36.180 --> 26:37.180
是不是应该指向这儿

26:37.180 --> 26:38.180
指向这个对象

26:38.180 --> 26:39.180
对吧

26:39.180 --> 26:40.180
这个没问题吧

26:40.180 --> 26:41.180
好

26:41.180 --> 26:42.180
然后呢

26:42.180 --> 26:43.180
ob借点k

26:43.180 --> 26:44.180
作为

26:44.180 --> 26:45.180
输主的第二项

26:45.180 --> 26:46.180
那第二项是不是

26:46.180 --> 26:47.180
也在这个地址

26:47.180 --> 26:48.180
因为k是什么

26:48.180 --> 26:49.180
k也是对象

26:49.180 --> 26:50.180
那对象不能是地址

26:50.180 --> 26:51.180
吗

26:51.180 --> 26:52.180
k的地址是不是这个

26:52.180 --> 26:53.180
是不是这个玩意

26:53.180 --> 26:54.180
那把这个地址

26:54.180 --> 26:55.180
复制粘贴到第二项

26:55.180 --> 26:57.180
是不是这里也是个地址

26:57.180 --> 26:59.180
它的内存图就是这个样子的

26:59.180 --> 27:01.180
那么这个地址指向这儿

27:01.180 --> 27:03.180
输主的第一项

27:03.180 --> 27:05.180
输主的第一项

27:05.180 --> 27:06.180
指向

27:06.180 --> 27:07.180
上面这个对象

27:07.180 --> 27:08.180
输主的第二项

27:08.180 --> 27:09.180
指向

27:09.180 --> 27:10.180
这个对象

27:10.180 --> 27:11.180
就这么简单

27:11.180 --> 27:12.180
那么整个输主

27:12.180 --> 27:13.180
也是一个地址

27:13.180 --> 27:15.180
因此AR那边也是个地址

27:15.180 --> 27:16.180
它的地址呢

27:16.180 --> 27:17.180
指向这个输主

27:17.180 --> 27:18.180
对吧

27:18.180 --> 27:19.180
那我们来看吧

27:19.180 --> 27:20.180
像说看着图挺到的

27:20.180 --> 27:21.180
其实根本就不用画图

27:21.180 --> 27:22.180
熟练了过后

27:22.180 --> 27:23.180
根本就不用画图

27:23.180 --> 27:24.180
因为知道这个对象团体

27:24.180 --> 27:25.180
它一定是地址

27:25.180 --> 27:27.180
那么AR的地零向

27:27.180 --> 27:28.180
找到AR的地零向

27:28.180 --> 27:29.180
是不是第一项

27:29.180 --> 27:31.180
然后找到K

27:31.180 --> 27:33.180
那K是不是这个对象的K

27:33.180 --> 27:34.180
对吧

27:34.180 --> 27:35.180
然后通过K的地址

27:35.180 --> 27:36.180
就找到谁

27:36.180 --> 27:37.180
找到这个B

27:37.180 --> 27:38.180
你看吧

27:38.180 --> 27:39.180
看那个图

27:39.180 --> 27:40.180
他们是不是一个东西

27:40.180 --> 27:41.180
肯定是一个东西

27:41.180 --> 27:42.180
通过OB接点

27:42.180 --> 27:43.180
K一点B

27:43.180 --> 27:45.180
和通过AR0点

27:45.180 --> 27:46.180
K点B

27:46.180 --> 27:48.180
和通过AR1点B

27:48.180 --> 27:49.180
是不是一个东西

27:49.180 --> 27:50.180
所以长来长去

27:50.180 --> 27:51.180
加来加去

27:51.180 --> 27:52.180
加的都是一个B

27:52.180 --> 27:53.180
对吧

27:53.180 --> 27:54.180
所以说你就把这个B

27:54.180 --> 27:55.180
加两次就完事了

27:55.180 --> 27:56.180
就是全部都是4

27:57.180 --> 27:58.180
全部都是4

28:00.180 --> 28:01.180
好 咱们再来一招

28:01.180 --> 28:02.180
就来一招

28:02.180 --> 28:03.180
只要你把这个东西

28:03.180 --> 28:04.180
原地搞清楚过

28:04.180 --> 28:05.180
它随便怎么着呢

28:05.180 --> 28:06.180
好 看第三项

28:06.180 --> 28:07.180
第三项呢

28:07.180 --> 28:08.180
我给它来一个这个

28:09.180 --> 28:10.180
OB接点

28:10.180 --> 28:11.180
K点B

28:11.180 --> 28:14.810
那么现在我问你的是

28:14.810 --> 28:15.810
OB接

28:15.810 --> 28:16.810
第二

28:16.810 --> 28:17.810
对

28:17.810 --> 28:18.810
AR2

28:18.810 --> 28:19.810
这个玩意儿

28:19.810 --> 28:21.810
跟前边是不是一样的

28:21.810 --> 28:25.660
这个玩意儿

28:25.660 --> 28:29.350
是不是一样的

28:29.350 --> 28:31.350
这就不一样了

28:31.350 --> 28:32.350
为啥不一样了呢

28:32.350 --> 28:33.350
因为你这个B

28:33.350 --> 28:34.350
是什么玩意儿

28:34.350 --> 28:35.350
B是不是对象

28:35.350 --> 28:36.350
它不是对象

28:36.350 --> 28:37.350
它是原式值

28:37.350 --> 28:39.350
而原式值的传递

28:39.350 --> 28:40.350
那就是直接

28:40.350 --> 28:41.350
copy过来

28:41.350 --> 28:42.350
copy的不是地址

28:42.350 --> 28:44.350
copy的就是原式的值

28:44.350 --> 28:45.350
所以说

28:45.350 --> 28:46.350
这一块东西

28:46.350 --> 28:47.350
跟前边的一些

28:47.350 --> 28:48.350
对象里面东西

28:48.350 --> 28:49.350
已经脱离关系了

28:49.350 --> 28:51.350
如果说你用内存图来画的话

28:51.350 --> 28:52.350
怎么来画呢

28:53.350 --> 28:54.350
把这个地方

28:54.350 --> 28:55.350
来 几个图

28:55.350 --> 29:04.200
好 然后看

29:04.200 --> 29:06.200
前面都是一样的

29:06.200 --> 29:07.200
然后这里

29:07.200 --> 29:08.200
数组又多了一项

29:08.200 --> 29:10.200
第二 下面这一项

29:10.200 --> 29:12.510
二

29:12.510 --> 29:13.510
AR2是什么呀

29:13.510 --> 29:15.510
把谁复制给这第二项的

29:15.510 --> 29:16.510
把OB接点

29:16.510 --> 29:17.510
K点B

29:17.510 --> 29:18.510
是不是把它复制过来

29:18.510 --> 29:19.510
它的值是什么

29:19.510 --> 29:20.510
像你把这个空间的

29:20.510 --> 29:22.510
AR2复制粘贴到这

29:22.510 --> 29:23.510
因为它不是地址

29:23.510 --> 29:24.510
它就是一个值

29:24.510 --> 29:26.510
所以这里就是AR2

29:26.510 --> 29:27.510
因此你在前面

29:27.510 --> 29:28.510
动来动去

29:28.510 --> 29:29.510
这个B改来改去

29:29.510 --> 29:30.510
跟它有关系吗

29:30.510 --> 29:31.510
跟它就没有关系了

29:32.510 --> 29:33.510
懂得意思吗

29:33.510 --> 29:35.510
所以说你掌握好

29:35.510 --> 29:36.510
这个窍门之后

29:36.510 --> 29:38.510
你看这些题啊

29:38.510 --> 29:39.510
其实都挺简单的

29:39.510 --> 29:41.510
只要是对象传递

29:41.510 --> 29:42.510
传递的权是地址

29:42.510 --> 29:44.510
只要是值传递之

29:44.510 --> 29:45.510
因为

29:45.510 --> 29:46.510
为什么对象传递

29:46.510 --> 29:47.510
就是存的是地址

29:47.510 --> 29:48.510
因为它里面存的就是地址

29:48.510 --> 29:49.510
这里面存的地址

29:49.510 --> 29:50.510
复制粘贴过来就是地址

29:50.510 --> 29:52.510
这里边

29:52.510 --> 29:53.510
这个K存的是地址

29:53.510 --> 29:54.510
对吧

29:54.510 --> 29:55.510
把K的值复制粘贴过来

29:55.510 --> 29:56.510
它就是地址

29:56.510 --> 29:57.510
就这么简单

29:58.510 --> 29:59.510
那么值呢

29:59.510 --> 30:00.510
因为它存的是值

30:00.510 --> 30:02.510
它复制粘贴过来就是值

30:02.510 --> 30:03.510
好

30:03.510 --> 30:08.530
然后咱们再来看啊

30:08.530 --> 30:10.530
比方说

30:10.530 --> 30:11.530
我这么来

30:11.530 --> 30:13.530
我写一个函数

30:13.530 --> 30:21.540
那么来一个函数

30:21.540 --> 30:23.540
我看怎么弄

30:23.540 --> 30:30.180
这个函数的

30:30.180 --> 30:32.180
第一项

30:32.180 --> 30:34.180
下下

30:34.180 --> 30:36.180
然后雕用这个函数

30:36.180 --> 30:38.180
把传一个数组进去

30:38.180 --> 30:41.180
obj.kdb

30:41.180 --> 30:42.180
好

30:42.180 --> 30:43.180
雕用完了之后

30:43.180 --> 30:46.750
我们来输出obj.kdb

30:46.750 --> 30:47.750
来吧

30:47.750 --> 30:54.070
看一下这个输出什么

30:54.070 --> 30:57.790
多少啊

30:57.790 --> 30:58.790
二是吧

30:58.790 --> 30:59.790
非常好啊

30:59.790 --> 31:01.790
我看努奔卫同学

31:01.790 --> 31:02.790
还有其他同学

31:02.790 --> 31:03.790
安全同学

31:03.790 --> 31:04.790
id同学

31:04.790 --> 31:05.790
都已经掌握到敲门了

31:05.790 --> 31:06.790
对不对

31:06.790 --> 31:07.790
其实你看的是什么呢

31:07.790 --> 31:08.790
看的就是

31:08.790 --> 31:09.790
它传的到底是什么

31:09.790 --> 31:11.790
你不要管那些乱七八糟的

31:11.790 --> 31:12.790
你就看什么呢

31:12.790 --> 31:14.790
看这个玩意

31:14.790 --> 31:15.790
传的是啥呀

31:15.790 --> 31:17.790
它传的是一个值

31:17.790 --> 31:19.790
它是把二传过去了

31:19.790 --> 31:20.790
对吧

31:20.790 --> 31:21.790
传的不是对象啊

31:21.790 --> 31:23.790
传的是一个什么值

31:23.790 --> 31:25.790
那么就跟这里的情况是一样的

31:25.790 --> 31:27.790
把这个值复制粘贴到某一个地方去了

31:27.790 --> 31:28.790
好

31:28.790 --> 31:29.790
因此呢

31:29.790 --> 31:30.790
你这里改变了

31:30.790 --> 31:32.790
是另外一块内存空间的值

31:32.790 --> 31:34.790
改变的不是这个b

31:34.790 --> 31:35.790
懂了意思吗

31:35.790 --> 31:36.790
它传的是值

31:36.790 --> 31:37.790
但是如果说

31:37.790 --> 31:43.090
你这个代码是这样的写的

31:43.090 --> 31:44.090
那就肯定有变了

31:44.090 --> 31:45.090
为什么

31:45.090 --> 31:46.090
因为k传的

31:46.090 --> 31:47.090
是什么

31:47.090 --> 31:48.090
k传的是地值

31:48.090 --> 31:50.090
说这里的k是书主的

31:50.090 --> 31:51.090
你这样的认为

31:51.090 --> 31:52.090
书主的第1项

31:52.090 --> 31:54.090
跟这个k是一模一样的

31:54.090 --> 31:56.090
书主的第1项

31:56.090 --> 31:57.090
就指向的是

31:57.090 --> 31:59.090
这一块东西

31:59.090 --> 32:01.090
指向的是同一个对象

32:01.090 --> 32:02.090
ob借点k

32:02.090 --> 32:03.090
跟书主的第1项

32:03.090 --> 32:05.090
是一个东西

32:05.090 --> 32:06.090
懂得意思吧

32:06.090 --> 32:07.090
所以说你

32:07.090 --> 32:08.090
通过书主的第1项去改变这个b

32:08.090 --> 32:10.090
那么这里的b也会变

32:10.090 --> 32:11.090
因为它传的是地值

32:11.090 --> 32:12.090
你就这样的看

32:12.090 --> 32:14.090
其实很容易理解

32:14.090 --> 32:15.090
好

32:15.090 --> 32:16.090
我们再来

32:16.090 --> 32:17.090
再来

32:18.090 --> 32:19.090
我们先把

32:19.090 --> 32:20.090
先把前边的

32:20.090 --> 32:21.090
删掉

32:21.090 --> 32:22.090
然后我这里的

32:22.090 --> 32:23.090
书主里边

32:23.090 --> 32:24.090
我给它

32:25.090 --> 32:26.090
这样子来

32:26.090 --> 32:32.050
这边

32:32.050 --> 32:41.060
我外面有一个书主

32:41.060 --> 32:42.060
看一下这道题

32:42.060 --> 32:46.930
书主多少

32:46.930 --> 32:49.560
把这道题

32:49.560 --> 32:50.560
做完了过后

32:50.560 --> 32:51.560
我们就在装编室提了

32:51.560 --> 32:56.180
说多少

32:58.180 --> 33:01.130
因为别的

33:01.130 --> 33:04.500
可能不能是3

33:04.500 --> 33:05.500
得是2

33:05.500 --> 33:06.500
这个地方得是2

33:06.500 --> 33:07.500
那为什么

33:07.500 --> 33:08.500
这题又变成2了

33:08.500 --> 33:09.500
还是一样的方式

33:09.500 --> 33:10.500
来分析

33:11.500 --> 33:12.500
来吧

33:12.500 --> 33:13.500
我们这里

33:13.500 --> 33:14.500
其实有两个东西

33:14.500 --> 33:15.500
一个是变量

33:15.500 --> 33:16.500
一个是参数

33:16.500 --> 33:17.500
所以它名字一样

33:17.500 --> 33:19.500
实际上是不一样的东西

33:19.500 --> 33:20.500
只是名字长得一样而已

33:20.500 --> 33:21.500
好

33:21.500 --> 33:22.500
所以说这里的

33:22.500 --> 33:23.500
代码了

33:23.500 --> 33:24.500
我们要这样来看

33:24.500 --> 33:31.850
把整个复制一下

33:31.850 --> 33:32.850
几个图

33:32.850 --> 33:35.670
站过来

33:35.670 --> 33:36.670
好

33:36.670 --> 33:37.670
把这边去掉

33:37.670 --> 33:42.030
这样子

33:42.030 --> 33:43.030
把这边去掉

33:43.030 --> 33:44.030
去掉

33:45.030 --> 33:46.030
去掉

33:46.030 --> 33:47.030
去掉

33:47.030 --> 33:48.030
去掉

33:48.030 --> 33:54.570
来吧

33:55.570 --> 33:56.570
我们这里有两个东西

33:56.570 --> 33:57.570
一个是AR

33:57.570 --> 33:58.570
外面的AR

33:58.570 --> 33:59.570
一个是参数AR

33:59.570 --> 34:01.570
它们是不一样的东西

34:01.570 --> 34:02.570
好

34:02.570 --> 34:03.570
首先代码运行到这

34:03.570 --> 34:04.570
运行到这

34:05.570 --> 34:06.570
干嘛

34:06.570 --> 34:07.570
是不是创建一个数组

34:07.570 --> 34:08.570
第一项为1

34:08.570 --> 34:09.570
第二项为2

34:09.570 --> 34:10.570
那么数组就出来了

34:10.570 --> 34:11.570
数组本质上就是个对象

34:11.570 --> 34:12.570
第一项为1

34:12.570 --> 34:13.570
第二项为2

34:13.570 --> 34:14.570
它们存的都是值

34:14.570 --> 34:15.570
都是原式值

34:15.570 --> 34:16.570
数组出来了

34:16.570 --> 34:18.570
把这个数组复制给谁

34:18.570 --> 34:19.570
复制给这个AR

34:19.570 --> 34:20.570
所以AR里边

34:20.570 --> 34:21.570
应该有个什么

34:21.570 --> 34:22.570
有个地址

34:22.570 --> 34:23.570
指向这个数组

34:23.570 --> 34:24.570
这个没问题吧

34:24.570 --> 34:25.570
好

34:25.570 --> 34:27.570
接下来调用函数master

34:27.570 --> 34:28.570
调用函数的时候

34:28.570 --> 34:29.570
把AR传进去

34:29.570 --> 34:30.570
传的是什么

34:30.570 --> 34:31.570
传的是地址

34:31.570 --> 34:32.570
它这边存的就是地址

34:32.570 --> 34:33.570
传的是地址

34:33.570 --> 34:34.570
传给谁

34:34.570 --> 34:36.570
传给这个参数AR

34:36.570 --> 34:37.570
那么参数AR里边

34:37.570 --> 34:39.570
之外有同样一个地址

34:39.570 --> 34:40.570
同样的地址

34:40.570 --> 34:41.570
但是接下来

34:41.570 --> 34:43.570
你看我做了什么事

34:43.570 --> 34:44.570
接下来

34:44.570 --> 34:46.570
我对这个参数重新复制

34:46.570 --> 34:48.570
是不是一个新的对象产生了

34:48.570 --> 34:49.570
对不对

34:49.570 --> 34:51.570
一个新的数组产生了

34:51.570 --> 34:53.570
这个数组有三项

34:53.570 --> 34:56.570
0,1,2

34:56.570 --> 34:57.570
有三项

34:57.570 --> 34:59.570
然后把这个新的地址复制

34:59.570 --> 35:01.570
重新复制给参数AR

35:01.570 --> 35:03.570
说参数AR的地址变了

35:03.570 --> 35:04.570
变成了哈了

35:04.570 --> 35:06.570
他们两个又不再是一个东西了

35:06.570 --> 35:08.570
所以让你认识这些体

35:08.570 --> 35:10.570
你一定要搞清楚

35:10.570 --> 35:11.570
传来传去

35:11.570 --> 35:12.570
他们都是不同的

35:12.570 --> 35:13.570
两块的一群空间

35:13.570 --> 35:14.570
他们之所以一样

35:14.570 --> 35:16.570
是因为他们两个地方

35:16.570 --> 35:17.570
两个那群空间

35:17.570 --> 35:18.570
存的地地址是一样的

35:18.570 --> 35:20.570
他们都拿到同一个纸条

35:20.570 --> 35:22.570
这个纸条上写的同一个

35:22.570 --> 35:23.570
同一个街道

35:23.570 --> 35:24.570
同一个门台号

35:24.570 --> 35:25.570
只是这样子

35:25.570 --> 35:27.570
但是你一旦对它重新复制

35:27.570 --> 35:29.570
就意味着

35:29.570 --> 35:31.570
把这个地址给改了

35:31.570 --> 35:33.570
它不再是原来的一个地址

35:33.570 --> 35:35.570
把纸条上的地址给磨了

35:35.570 --> 35:37.570
但是他们仍然是两个纸条

35:37.570 --> 35:38.570
懂了意思吧

35:38.570 --> 35:39.570
所以说你改它

35:39.570 --> 35:40.570
改来改去没用了

35:40.570 --> 35:41.570
你给它重新复制之后

35:41.570 --> 35:42.570
再改就没用了

35:42.570 --> 35:44.570
它以前还是两个

35:44.570 --> 35:45.570
所以说这里运行出来

35:45.570 --> 35:47.570
肯定是二

35:47.570 --> 35:48.570
听到了没

35:48.570 --> 35:49.570
这个一定要搞清楚

35:49.570 --> 35:51.570
一定要搞清楚

35:51.570 --> 35:53.570
好接下来

35:53.570 --> 35:55.570
我们来玩面试体了

35:55.570 --> 35:57.570
指头引用地道体

36:02.830 --> 36:03.830
看一下地道体

36:03.830 --> 36:04.830
今天绕来绕去

36:04.830 --> 36:09.100
还给绕了很多的玩

36:09.100 --> 36:11.100
其实它怎么绕里都无所谓的

36:11.100 --> 36:13.100
我们怎么来看这道体呢

36:13.100 --> 36:16.740
我们先来看一下

36:16.740 --> 36:18.740
我先用简单的讲法来讲一下

36:18.740 --> 36:19.740
简单讲法如果听不懂的话

36:19.740 --> 36:20.740
我再给你画这个

36:20.740 --> 36:22.740
详细的内存图

36:22.740 --> 36:23.740
有一个对象

36:23.740 --> 36:24.740
对象里面

36:24.740 --> 36:26.740
然后这里有一个对象

36:26.740 --> 36:27.740
你只要看到对象

36:27.740 --> 36:28.740
那就是地址

36:28.740 --> 36:29.740
这个K里面存的地址

36:29.740 --> 36:31.740
它里面存的是地址

36:31.740 --> 36:32.740
这里有两块内存空间

36:32.740 --> 36:33.740
它一块

36:33.740 --> 36:34.740
它一块

36:34.740 --> 36:36.740
然后把-k

36:37.740 --> 36:38.740
-k

36:38.740 --> 36:39.740
复制给谁

36:39.740 --> 36:40.740
复制给这个包

36:40.740 --> 36:41.740
来吧

36:41.740 --> 36:43.740
用笔记来记一下

36:43.740 --> 36:44.740
然后复

36:44.740 --> 36:46.740
里面有个地址

36:47.740 --> 36:49.740
然后把-k

36:49.740 --> 36:50.740
K是不是地址

36:50.740 --> 36:52.740
K也是地址

36:52.740 --> 36:53.740
是这个对象的地址

36:53.740 --> 36:55.740
把这个地址复制给谁

36:55.740 --> 36:56.740
复制给包

36:56.740 --> 36:57.740
那么这个包里面

36:57.740 --> 36:58.740
复制地址

36:58.740 --> 36:59.740
对吧

36:59.740 --> 37:02.740
地址我们就认为地址K

37:02.740 --> 37:05.740
这样子来记录

37:05.740 --> 37:07.740
然后我们把-n加加

37:07.740 --> 37:09.740
是不是加的就是这个n

37:09.740 --> 37:11.740
加的是不是这个n

37:11.740 --> 37:12.740
因此我们现在目前

37:12.740 --> 37:14.740
其实我们目前就这个对象

37:14.740 --> 37:16.740
没有别的对象了

37:16.740 --> 37:21.580
目前就这个对象

37:21.580 --> 37:23.580
然后-n加加

37:23.580 --> 37:25.580
是不是加了这个n变成1

37:25.580 --> 37:27.580
好又来

37:27.580 --> 37:29.580
创建一个新的对象

37:29.580 --> 37:30.580
以后你看到这种代码

37:30.580 --> 37:31.580
什么两个中国号

37:31.580 --> 37:32.580
两个大国号

37:32.580 --> 37:34.580
一定是一个新的东西产生了

37:34.580 --> 37:37.580
创建一个新的对象

37:37.580 --> 37:38.580
这个新的对象里边

37:38.580 --> 37:39.580
一个n

37:39.580 --> 37:43.660
n等于10

37:43.660 --> 37:44.660
大长一点吧

37:44.660 --> 37:45.660
一个新的对象

37:45.660 --> 37:47.660
然后新的对象给谁

37:47.660 --> 37:49.660
给这个包

37:49.660 --> 37:50.660
对吧

37:50.660 --> 37:51.660
重新给包复制

37:51.660 --> 37:52.660
所以包的地址又变了

37:52.660 --> 37:53.660
它不但是地址K了

37:53.660 --> 37:54.660
变成了地址

37:54.660 --> 37:55.660
对吧

37:55.660 --> 37:57.660
就是个新的对象

37:57.660 --> 37:58.660
好接下来

37:58.660 --> 37:59.660
通过包的n加加

37:59.660 --> 38:00.660
加的是谁

38:00.660 --> 38:03.660
加的是这个新的对象

38:03.660 --> 38:05.660
然后再把这个复制

38:05.660 --> 38:06.660
复制这个玩意

38:06.660 --> 38:09.660
复.n复制给包

38:09.660 --> 38:10.660
复.n是什么

38:10.660 --> 38:11.660
n是一个值

38:11.660 --> 38:12.660
把这个值复制给谁

38:12.660 --> 38:15.660
复制给这个包

38:15.660 --> 38:16.660
包变成什么了

38:16.660 --> 38:17.660
变成不是地址了

38:17.660 --> 38:18.660
对吧

38:18.660 --> 38:19.660
它把这个0复制给谁了

38:19.660 --> 38:20.660
0复制给包了

38:20.660 --> 38:21.660
变成一个数字了

38:21.660 --> 38:22.660
变成0了

38:22.660 --> 38:23.660
它不是地址了

38:23.660 --> 38:24.660
然后包加加

38:24.660 --> 38:25.660
加的是谁

38:25.660 --> 38:26.660
加的是这个0

38:26.660 --> 38:27.660
然后输出什么

38:27.660 --> 38:28.660
复.n

38:28.660 --> 38:29.660
输了啥

38:29.660 --> 38:30.660
输了0

38:30.660 --> 38:31.660
复.k.n

38:31.660 --> 38:32.660
输出啥

38:32.660 --> 38:35.680
输出1

38:35.680 --> 38:37.680
我看一下

38:37.680 --> 38:42.140
哪里写错了

38:42.140 --> 38:43.140
哪里写错了

38:43.140 --> 38:46.140
这个n是加了1了

38:46.140 --> 38:50.970
这个地方变成10了

38:50.970 --> 38:52.970
包.n加

38:52.970 --> 38:54.970
包.n加加

38:54.970 --> 38:55.970
加的是这个

38:55.970 --> 38:57.970
11

38:57.970 --> 39:00.970
然后复.n

39:00.970 --> 39:01.970
复.n

39:01.970 --> 39:03.970
复制给包

39:03.970 --> 39:05.970
包变成0

39:05.970 --> 39:09.280
包加加

39:09.280 --> 39:11.280
没问题

39:11.280 --> 39:12.280
没问题

39:12.280 --> 39:14.280
哪一步看错了

39:14.280 --> 39:18.740
11那里不是吗

39:18.740 --> 39:20.740
11那里肯定是

39:20.740 --> 39:25.180
是一个新的

39:25.180 --> 39:27.180
我看到了

39:27.180 --> 39:28.180
我看到了

39:28.180 --> 39:30.180
少了一行

39:30.180 --> 39:31.180
我少看到一行

39:31.180 --> 39:32.180
少看到一行

39:32.180 --> 39:34.180
做这问题还得小心

39:34.180 --> 39:35.180
还真得小心

39:35.180 --> 39:36.180
到这一行

39:36.180 --> 39:37.180
上面的一行是没问题的

39:37.180 --> 39:39.180
这里是个地址星

39:39.180 --> 39:40.180
地址星

39:40.180 --> 39:41.180
没问题的

39:41.180 --> 39:43.180
这个新的地址给了8

39:43.180 --> 39:44.180
然后

39:44.180 --> 39:46.180
这个这句话

39:46.180 --> 39:48.180
新的地址给了8

39:48.180 --> 39:50.180
然后把复给包

39:50.180 --> 39:51.180
多了这么一行

39:51.180 --> 39:52.180
我这里看到

39:52.180 --> 39:53.180
复给包

39:53.180 --> 39:54.180
那么这一行是什么意思呢

39:54.180 --> 39:56.180
就是把这个对象的地址

39:56.180 --> 39:58.180
复就是这个对象的地址

39:58.180 --> 39:59.180
把这个地址又给了

39:59.180 --> 40:00.180
包了

40:00.180 --> 40:01.180
所以他们又指向同一个对象

40:01.180 --> 40:03.180
他变了一下又回来了

40:03.180 --> 40:05.180
然后再把他N加加

40:05.180 --> 40:06.180
加了就是谁

40:06.180 --> 40:07.180
加了是谁个N

40:07.180 --> 40:10.180
所以东叔叔的是11

40:10.180 --> 40:12.180
如果说你这里比较熟练的话

40:12.180 --> 40:14.180
你就可以用这种方式来分析

40:14.180 --> 40:15.180
如果说你不熟练的话

40:15.180 --> 40:16.180
我建议啊

40:16.180 --> 40:18.180
前边你做这种题

40:18.180 --> 40:19.180
看上去

40:19.180 --> 40:20.180
到处给你搞的

40:20.180 --> 40:22.180
什么引用直传地啊

40:22.180 --> 40:23.180
这种题

40:23.180 --> 40:25.180
如果说你不熟练

40:25.180 --> 40:26.180
你怕自己犯错

40:26.180 --> 40:27.180
怕自己做错

40:27.180 --> 40:28.180
可以拿出指

40:28.180 --> 40:29.180
何比

40:29.180 --> 40:30.180
用我刚才那种方式

40:30.180 --> 40:33.180
把那个内存图给他画出来

40:33.180 --> 40:34.180
画出来之后

40:34.180 --> 40:35.180
你就非常非常清楚了

40:35.180 --> 40:36.180
他到底是怎么做的

40:36.180 --> 40:38.180
一步一步是怎么演化的

40:38.180 --> 40:39.180
就非常清楚了

40:39.180 --> 40:40.180
到后面熟练了之后

40:40.180 --> 40:41.180
你可以用我这种方式

40:41.180 --> 40:43.180
就是潦草的记录一下

40:43.180 --> 40:45.180
基本上也就清楚他这么做的

40:45.180 --> 40:46.180
好

40:46.180 --> 40:47.180
朋友那我这里需不需要

40:47.180 --> 40:49.180
用内存图给大家画一下

40:49.180 --> 40:50.180
需要的话

40:50.180 --> 40:51.180
Q个1

40:51.180 --> 40:59.640
不需要的话Q个2

40:59.640 --> 41:00.640
不需要了是吧

41:00.640 --> 41:01.640
好

41:01.640 --> 41:04.660
大家看第二题

41:04.660 --> 41:05.660
第二题

41:05.660 --> 41:06.660
其实道理是一样的

41:06.660 --> 41:07.660
他就是用了数组

41:07.660 --> 41:09.660
用了函数来造理

41:09.660 --> 41:11.660
道理是一样的

41:11.660 --> 41:12.660
好

41:12.660 --> 41:13.660
咱们来做一下这个题吧

41:13.660 --> 41:15.660
同样的可以跟我一起做

41:15.660 --> 41:17.660
首先这里产生了一个对象

41:17.660 --> 41:19.660
这个对象里面是一个n

41:19.660 --> 41:21.660
n等于1

41:21.660 --> 41:22.660
都是一个对象

41:22.660 --> 41:23.660
这个对象的地址呢

41:23.660 --> 41:24.660
我就姑且认为了

41:24.660 --> 41:26.660
这个对象的地址是地址1

41:26.660 --> 41:29.660
把这个地址1

41:29.660 --> 41:30.660
复字给复

41:30.660 --> 41:31.660
复里面是不是地址1

41:31.660 --> 41:32.660
是不是这个对象的地址

41:32.660 --> 41:33.660
没问题吧

41:33.660 --> 41:34.660
好

41:34.660 --> 41:35.660
大家来

41:35.660 --> 41:36.660
AR

41:36.660 --> 41:37.660
AR又是个什么玩意呢

41:37.660 --> 41:40.660
AR是一个数组

41:40.660 --> 41:41.660
这里个数组

41:41.660 --> 41:42.660
数组的第一项是谁

41:42.660 --> 41:43.660
第一项是复

41:43.660 --> 41:44.660
复是啥

41:44.660 --> 41:45.660
复是地址1

41:45.660 --> 41:46.660
所以说数组的第一项

41:46.660 --> 41:48.660
实际上是个地址1

41:48.660 --> 41:49.660
这数组

41:49.660 --> 41:50.660
好

41:50.660 --> 41:51.660
数组本身也有个地址

41:51.660 --> 41:53.660
这是地址2

41:53.660 --> 41:56.660
就是数组地址

41:56.660 --> 41:57.660
做这种题的时候

41:57.660 --> 41:58.660
就记录一下

41:58.660 --> 41:59.660
因为有些点

41:59.660 --> 42:00.660
它一看上去

42:00.660 --> 42:01.660
它又是给你绕圈圈

42:01.660 --> 42:02.660
那就好好把记录一下

42:02.660 --> 42:03.660
这是数组地址

42:04.660 --> 42:05.660
好

42:05.660 --> 42:06.660
来吧

42:06.660 --> 42:07.660
有三个函数

42:07.660 --> 42:08.660
这三个函数不管它

42:08.660 --> 42:09.660
首先调用第1个函数

42:09.660 --> 42:10.660
Messor1

42:10.660 --> 42:12.660
把ARR传进去

42:12.660 --> 42:15.660
那么这个参数ARR

42:15.660 --> 42:17.660
参数ARR

42:17.660 --> 42:19.660
它里面记录的是啥呀

42:19.660 --> 42:22.660
记录的就是ARR的数组地址

42:22.660 --> 42:23.660
是不是就是它

42:23.660 --> 42:24.660
ARR传进去

42:24.660 --> 42:26.660
传给它

42:26.660 --> 42:28.660
ARR传递的这个

42:28.660 --> 42:31.660
ARR传递的这个

42:31.660 --> 42:32.660
参数ARR

42:33.660 --> 42:34.660
就把地址传过去了

42:34.660 --> 42:35.660
就参数ARR

42:35.660 --> 42:36.660
数组地址

42:36.660 --> 42:37.660
好 接下来就开始玩了

42:37.660 --> 42:38.660
各种玩意

42:38.660 --> 42:39.660
然后呢

42:39.660 --> 42:40.660
把这个数组的第1项

42:40.660 --> 42:41.660
数组的第1项是啥

42:41.660 --> 42:43.660
不就是这个玩意吗

42:43.660 --> 42:44.660
给谁

42:44.660 --> 42:45.660
给一个变量

42:45.660 --> 42:46.660
叫bar

42:46.660 --> 42:47.660
bar还有出来了

42:47.660 --> 42:48.660
bar里面存的是啥

42:48.660 --> 42:50.660
把这个地址1给bar了

42:50.660 --> 42:52.660
bar是不是就是地址1

42:52.660 --> 42:53.660
对吧

42:53.660 --> 42:54.660
好 又来

42:54.660 --> 42:57.660
ARR铺洗bar

42:57.660 --> 42:58.660
啥意思呢

42:58.660 --> 42:59.660
是不是把ARR

42:59.660 --> 43:00.660
是不是个数组

43:00.660 --> 43:01.660
在这个数组里面

43:01.660 --> 43:02.660
加一下

43:02.660 --> 43:03.660
加谁

43:03.660 --> 43:04.660
加bar

43:04.660 --> 43:05.660
bar是啥

43:05.660 --> 43:08.540
bar是地址1

43:08.540 --> 43:10.540
加成这个样子了

43:10.540 --> 43:11.540
然后接下来

43:11.540 --> 43:13.540
bar点n加加

43:13.540 --> 43:14.540
bar是啥

43:14.540 --> 43:15.540
bar是地址1

43:15.540 --> 43:16.540
地址1是啥

43:16.540 --> 43:17.540
只有这个玩意

43:17.540 --> 43:18.540
n加加

43:18.540 --> 43:19.540
这里有2

43:19.540 --> 43:21.540
好 又来

43:21.540 --> 43:22.540
好 这里开始

43:22.540 --> 43:23.540
来我心里的

43:23.540 --> 43:25.540
这在干嘛呀

43:25.540 --> 43:26.540
这在干嘛

43:26.540 --> 43:28.540
在创建一个新数组

43:28.540 --> 43:29.540
你看是不是看到中货号了

43:29.540 --> 43:30.540
看到中货号

43:30.540 --> 43:31.540
看到大货号

43:31.540 --> 43:32.540
创建对象

43:32.540 --> 43:33.540
创建新数组

43:33.540 --> 43:35.540
这是一个新数组

43:35.540 --> 43:37.540
新数组地址

43:37.540 --> 43:38.540
好 一个新数组

43:38.540 --> 43:39.540
新数组只有一项

43:39.540 --> 43:40.540
一项是啥

43:40.540 --> 43:41.540
是bar

43:41.540 --> 43:43.540
那bar一直1

43:43.540 --> 43:44.540
好 又来

43:44.540 --> 43:46.540
ARR又铺洗bar

43:46.540 --> 43:47.540
ARR是现在是啥

43:47.540 --> 43:49.540
ARR是这个残属ARR

43:49.540 --> 43:51.540
它就变成新数组地址了

43:51.540 --> 43:52.540
刚才那个复职过后

43:52.540 --> 43:53.540
变成新数组地址了

43:53.540 --> 43:55.540
就这句话复职完了过后

43:55.540 --> 43:56.540
好 新数组地址

43:56.540 --> 43:57.540
是不是这个数组

43:57.540 --> 43:58.540
数组里面

43:58.540 --> 43:59.540
又加了一下

43:59.540 --> 44:00.540
加了谁

44:01.540 --> 44:03.540
各种而已

44:03.540 --> 44:04.540
好 然后呢

44:04.540 --> 44:05.540
但是你用这种方式

44:05.540 --> 44:06.540
去记录就不会出问题

44:06.540 --> 44:07.540
不管它怎么而已

44:07.540 --> 44:09.540
好 找到这个数组的第二项

44:09.540 --> 44:10.540
找到这一项

44:10.540 --> 44:11.540
这一项是啥

44:11.540 --> 44:12.540
地址1

44:12.540 --> 44:13.540
给它的N加加

44:13.540 --> 44:14.540
给它的N加加

44:14.540 --> 44:15.540
是不是还是加到

44:15.540 --> 44:17.540
同一个对象上面去了

44:17.540 --> 44:18.540
对不对

44:18.540 --> 44:20.540
它地址是一样的嘛

44:20.540 --> 44:21.540
还是加到

44:21.540 --> 44:22.540
同一个对象上面去了

44:22.540 --> 44:24.540
这个函数就运行完了

44:24.540 --> 44:25.540
运行完了之后

44:25.540 --> 44:26.540
这个对象是这个鬼地址

44:26.540 --> 44:27.540
鬼样子

44:27.540 --> 44:28.540
然后呢

44:28.540 --> 44:29.540
这些新数组就没了

44:29.540 --> 44:30.540
函数运行完了嘛

44:30.540 --> 44:32.540
这些举步边的就消失了

44:32.540 --> 44:33.540
这个8没了

44:33.540 --> 44:34.540
这个函数没了

44:34.540 --> 44:37.980
新数组也没了

44:37.980 --> 44:38.980
好 第二个

44:38.980 --> 44:39.980
函数2

44:39.980 --> 44:40.980
函数也把负传进去

44:40.980 --> 44:41.980
负是啥

44:41.980 --> 44:43.980
负是地址1

44:43.980 --> 44:44.980
就把地址1传进去

44:44.980 --> 44:45.980
传给谁

44:45.980 --> 44:49.580
传给这个函数负

44:49.580 --> 44:50.580
函数负

44:50.580 --> 44:52.580
是不是也是地址1

44:52.580 --> 44:53.580
好

44:53.580 --> 44:54.580
然后通过这个函数负

44:54.580 --> 44:55.580
去点N加加

44:55.580 --> 44:57.580
是不是变成4的

44:57.580 --> 44:58.580
方法2里没了

44:58.580 --> 44:59.580
方法3

44:59.580 --> 45:01.580
把负点N传进去

45:01.580 --> 45:02.580
负点N是啥

45:02.580 --> 45:04.580
负点N是一个数字

45:04.580 --> 45:05.580
4传给谁

45:05.580 --> 45:06.580
传给参数N

45:06.580 --> 45:08.580
那么这个N的指示是啥

45:08.580 --> 45:10.580
是把这个数字负质担开过来

45:10.580 --> 45:12.580
这是参数N

45:12.580 --> 45:14.580
然后接下来N加加加

45:14.580 --> 45:15.580
加的是谁

45:15.580 --> 45:16.580
加的是这个参数

45:16.580 --> 45:17.580
好

45:17.580 --> 45:19.580
方法3运行结束

45:19.580 --> 45:21.580
运行结束

45:21.580 --> 45:23.580
最后输出什么

45:23.580 --> 45:24.580
负点N

45:24.580 --> 45:26.580
负点N是不是4

45:26.580 --> 45:28.580
然后输出AR点N

45:28.580 --> 45:31.950
是不是长度为2

45:31.950 --> 45:35.260
4和2

45:35.260 --> 45:38.260
这就是军东的练书题

45:38.260 --> 45:39.260
搞这些练书题

45:39.260 --> 45:41.260
我还是飞到挺多的形式的

45:41.260 --> 45:43.260
通过各种渠道

45:43.260 --> 45:44.260
你可以看到大厂的练书题

45:44.260 --> 45:46.260
也不过如此

45:46.260 --> 45:47.260
绕来绕去也就绕了

45:47.260 --> 45:48.260
这么一点点东西

45:48.260 --> 45:50.260
它其实你就按照这种方式

45:50.260 --> 45:51.260
去分析

45:51.260 --> 45:52.260
你肯定要打扫

45:52.260 --> 45:53.260
这个玩意

45:53.260 --> 45:54.260
你看到这种代码

45:54.260 --> 45:55.260
你千万不要在老代

45:55.260 --> 45:56.260
这边去想

45:56.260 --> 45:57.260
它比完蛋了

45:57.260 --> 45:58.260
一定要把记录一下

45:58.260 --> 45:59.260
因为绕来绕去

45:59.260 --> 46:00.260
你都不知道绕到哪去

46:00.260 --> 46:02.260
它就是在故意绕里的

46:03.260 --> 46:05.260
总之通过这种方式

46:05.260 --> 46:06.260
来分析的出来

46:06.260 --> 46:07.260
整个过程

46:08.260 --> 46:09.260
虽然说比较繁术

46:09.260 --> 46:10.260
比较绕

46:10.260 --> 46:12.260
但是每一步的分析

46:12.260 --> 46:13.260
有没有同学

46:13.260 --> 46:14.260
有问题的

46:14.260 --> 46:15.260
哪一步有问题

46:16.260 --> 46:17.260
可以现在问

46:17.260 --> 46:19.260
我觉得应该都是没问题的

46:19.260 --> 46:20.260
因为跟前面讲的

46:20.260 --> 46:21.260
都是没有区别的

46:23.260 --> 46:24.260
你只要记录

46:24.260 --> 46:25.260
对象船就是地址

46:25.260 --> 46:26.260
船地就是地址

46:27.260 --> 46:28.260
直就是直接复制人体

46:30.260 --> 46:31.260
其实对象船地

46:31.260 --> 46:32.260
也是复制人体

46:32.260 --> 46:34.260
只是复制人体的是地址

46:34.260 --> 46:36.830
好

46:36.830 --> 46:38.830
接下来看第三题

46:38.830 --> 46:43.320
字节的

46:44.320 --> 46:45.320
也是那恶心里的

46:45.320 --> 46:46.320
不过这个点了

46:46.320 --> 46:47.320
恶心的时候

46:47.320 --> 46:48.320
它顺带

46:48.320 --> 46:49.320
接待了一些API的恶心

46:51.320 --> 46:52.320
又来一开始

46:52.320 --> 46:53.320
有个对象产生了

46:53.320 --> 46:54.320
它的对象里边有个

46:54.320 --> 46:55.320
属性8

46:55.320 --> 46:56.320
等于1

46:58.320 --> 46:59.320
就这个东西

47:00.320 --> 47:01.320
然后给谁复制

47:01.320 --> 47:02.320
给这个复复制

47:03.320 --> 47:04.320
是一个地址

47:04.320 --> 47:06.320
我们认为是地址1吗

47:06.320 --> 47:07.320
地址1

47:07.320 --> 47:08.320
那么都是地址1

47:09.320 --> 47:10.320
接下来一个数组又来了

47:10.320 --> 47:11.320
这个数组

47:11.320 --> 47:13.320
它前地向为1

47:13.320 --> 47:14.320
第二向为2

47:14.320 --> 47:15.320
第三向复制它

47:15.320 --> 47:16.320
复制地址

47:18.320 --> 47:19.320
对吧

47:19.320 --> 47:20.320
这个数组本身也有个地址

47:20.320 --> 47:21.320
对吧

47:21.320 --> 47:22.320
数组是对象

47:22.320 --> 47:23.320
它是地址2

47:23.320 --> 47:24.320
一个数组地址

47:24.320 --> 47:25.320
然后就写个数组地址

47:25.320 --> 47:26.320
地址

47:27.320 --> 47:28.320
给谁呢

47:28.320 --> 47:29.320
给这个变量

47:29.320 --> 47:30.320
AR1

47:30.320 --> 47:32.320
数组地址

47:33.320 --> 47:34.320
没问题吧

47:34.320 --> 47:35.320
好

47:35.320 --> 47:36.320
目前是这么个鬼样子

47:36.320 --> 47:37.320
好

47:37.320 --> 47:38.320
接下来

47:38.320 --> 47:39.320
这个函数

47:39.320 --> 47:40.320
是nice

47:40.320 --> 47:42.320
知不知道这个函数

47:42.320 --> 47:43.320
这个函数在干嘛

47:43.320 --> 47:45.320
在解许数组

47:45.320 --> 47:46.320
注意啊

47:46.320 --> 47:47.320
这个函数

47:47.320 --> 47:48.320
说这就考验你们

47:48.320 --> 47:50.320
平时的一些基本空

47:50.320 --> 47:51.320
积累了

47:51.320 --> 47:52.320
这个函数

47:52.320 --> 47:54.320
你去翻一翻

47:54.320 --> 47:55.320
不知道你们之前学的是

47:55.320 --> 47:56.320
什么校成

47:56.320 --> 47:57.320
翻一翻这个函数的

47:57.320 --> 47:59.320
官方定义

47:59.320 --> 48:00.320
得到了

48:00.320 --> 48:01.320
它不会改变元数组

48:01.320 --> 48:03.320
它不元数组不动

48:03.320 --> 48:06.320
而是反回一个新数组

48:06.320 --> 48:07.320
这个新数组

48:07.320 --> 48:08.320
是结局的结构

48:08.320 --> 48:09.320
所以说

48:09.320 --> 48:10.320
这里一定产生了

48:10.320 --> 48:11.320
一个新的数组

48:11.320 --> 48:13.320
元数组没动

48:13.320 --> 48:15.320
新数组

48:15.320 --> 48:16.320
第一项

48:16.320 --> 48:17.320
为元数组的第二项

48:17.320 --> 48:18.320
就结去吧

48:18.320 --> 48:19.320
把这个样子

48:19.320 --> 48:20.320
像数字单贴过来

48:20.320 --> 48:21.320
就这样子

48:21.320 --> 48:22.320
然后这里说

48:22.320 --> 48:23.320
既然有个新的数组

48:23.320 --> 48:24.320
是一个新的地址

48:24.320 --> 48:26.320
新数组地址

48:26.320 --> 48:27.320
对吧

48:27.320 --> 48:28.320
然后把这个新数组地址

48:28.320 --> 48:29.320
复制给谁

48:29.320 --> 48:30.320
复制给AR2

48:34.490 --> 48:35.490
小人里面以后学什么

48:35.490 --> 48:36.490
ES5

48:36.490 --> 48:37.490
这些发生了

48:37.490 --> 48:38.490
添加了很多的数组API

48:38.490 --> 48:39.490
像什么Map

48:39.490 --> 48:40.490
Filter

48:40.490 --> 48:42.490
Reduce

48:45.490 --> 48:46.490
Filter

48:46.490 --> 48:48.490
还有Flex

48:48.490 --> 48:49.490
这些东西

48:49.490 --> 48:50.490
这些新中的数组

48:50.490 --> 48:51.490
还说

48:51.490 --> 48:53.490
它都不会改变元数组

48:53.490 --> 48:57.310
它都是给你反回一个新数组

48:57.310 --> 48:58.310
接下来

48:58.310 --> 48:59.310
开始来玩吧

48:59.310 --> 49:00.310
其实后面的玩法

49:00.310 --> 49:01.310
基本上都懂了

49:01.310 --> 49:02.310
你只要能够把

49:02.310 --> 49:03.310
这个东西分析出来

49:03.310 --> 49:04.310
基本上就没

49:04.310 --> 49:05.310
提过了

49:05.310 --> 49:06.310
AR2

49:06.310 --> 49:07.310
新数组地址

49:07.310 --> 49:08.310
找到第一项

49:08.310 --> 49:09.310
加加

49:09.310 --> 49:10.310
把这个变成3

49:11.310 --> 49:13.310
然后找到新数组的

49:13.310 --> 49:15.310
新数组的第二项

49:15.310 --> 49:16.310
找到这个玩意

49:16.310 --> 49:17.310
这个玩意

49:17.310 --> 49:18.310
这个玩意是什么

49:18.310 --> 49:19.310
是不是这个地址1

49:19.310 --> 49:20.310
是不是这个东西

49:20.310 --> 49:21.310
把这个82加加

49:21.310 --> 49:22.310
变成2

49:22.310 --> 49:23.310
然后下一

49:23.310 --> 49:24.310
第七行

49:24.310 --> 49:25.310
第七行

49:25.310 --> 49:26.310
付点8加加

49:26.310 --> 49:27.310
付是什么

49:27.310 --> 49:28.310
付是地址1

49:28.310 --> 49:29.310
然后8加加变成3

49:29.310 --> 49:31.310
然后AR1

49:31.310 --> 49:32.310
2

49:32.310 --> 49:33.310
AR1

49:34.310 --> 49:35.310
就这个

49:35.310 --> 49:36.310
原来的数组

49:36.310 --> 49:37.310
2是不是这个地址

49:37.310 --> 49:38.310
然后呢是找到

49:38.310 --> 49:39.310
这个BAR加1

49:39.310 --> 49:40.310
4

49:41.310 --> 49:42.310
然后问你

49:42.310 --> 49:43.310
现在就问你

49:43.310 --> 49:47.310
AR1的第二项

49:47.310 --> 49:51.690
AR1的第二项

49:51.690 --> 49:53.690
等不等于

49:53.690 --> 49:56.690
AR2的地理零项

49:56.690 --> 49:57.690
不等吧

49:57.690 --> 49:58.690
对吧

49:58.690 --> 49:59.690
这第一项是2嘛

49:59.690 --> 50:00.690
第二项是2

50:00.690 --> 50:02.690
这个地理零项是3

50:02.690 --> 50:04.690
2和3不等吧

50:04.690 --> 50:10.300
所以第一个为Force

50:10.300 --> 50:11.300
好

50:11.300 --> 50:12.300
下一个

50:12.300 --> 50:14.300
问你AR1的

50:14.300 --> 50:16.300
第3项

50:16.300 --> 50:17.300
就这个东西

50:17.300 --> 50:18.300
等不等于

50:18.300 --> 50:19.300
第二个数组的

50:19.300 --> 50:20.300
第二项呢

50:20.300 --> 50:21.300
两个都是一样的地址

50:21.300 --> 50:22.300
对吧

50:22.300 --> 50:23.300
那等着呀

50:25.300 --> 50:26.300
好

50:26.300 --> 50:27.300
问你

50:27.300 --> 50:28.300
输出付点8

50:28.300 --> 50:29.300
是不是输出4

50:29.300 --> 50:30.300
得到结果就是Force

50:30.300 --> 50:31.300
4

50:33.300 --> 50:35.300
也是不是也不够如此

50:35.300 --> 50:37.300
对吧

50:37.300 --> 50:38.300
对某一大场

50:38.300 --> 50:39.300
他考虑提的时候啊

50:39.300 --> 50:40.300
所谓的同学说

50:40.300 --> 50:42.300
他考虑提的时候

50:42.300 --> 50:43.300
很多时候

50:43.300 --> 50:44.300
他是综合考察

50:44.300 --> 50:46.300
他不会单考一个知识点

50:46.300 --> 50:47.300
有没有单考一个知识点呢

50:47.300 --> 50:48.300
有

50:48.300 --> 50:49.300
比较像像这种

50:49.300 --> 50:51.300
他单考某一个知识点

50:51.300 --> 50:52.300
有

50:52.300 --> 50:53.300
但是呢

50:53.300 --> 50:54.300
有的是

50:54.300 --> 50:55.300
更多的时候

50:55.300 --> 50:56.300
他是综合考察

50:56.300 --> 50:57.300
综合考察里面

50:57.300 --> 50:58.300
就包含了很多的知识点

50:58.300 --> 51:00.300
包括我们这几天讲的

51:00.300 --> 51:01.300
还有这几天没有讲到的

51:01.300 --> 51:03.300
他可能都会考察的

51:03.300 --> 51:04.300
那么考察的时候

51:04.300 --> 51:05.300
其实你只要把

51:06.300 --> 51:08.300
无非就是比方考10个周深链

51:08.300 --> 51:09.300
你只要把这10个周深链

51:09.300 --> 51:10.300
搞透透的

51:10.300 --> 51:11.300
他也就这样子了

51:11.300 --> 51:13.300
他又玩不出什么新闻的花样了

51:13.300 --> 51:16.300
因为接式本质也就这样子了

51:16.300 --> 51:17.300
好了

51:17.300 --> 51:20.810
这就是这么三道面试题

51:20.810 --> 51:22.810
可以给他推荐一般

51:22.810 --> 51:23.810
值和引用

51:23.810 --> 51:25.810
到这种程度就OK了

51:25.810 --> 51:27.810
因为再深的话

51:27.810 --> 51:28.810
你就要了解

51:28.810 --> 51:29.810
为一般引擎的缘码

51:29.810 --> 51:30.810
那就不是一个量级的

51:30.810 --> 51:32.810
当然前段还不会这样子考虑的

51:32.810 --> 51:34.810
到这就可以了

51:34.810 --> 51:37.810
值和引用到这就通了

51:37.810 --> 51:38.810
有问题吧

51:38.810 --> 51:40.810
你只要能够画出这个内存图

51:40.810 --> 51:41.810
就再不计

51:41.810 --> 51:42.810
你觉得自己招不过来

51:42.810 --> 51:44.810
再不计你就像我这样子

51:44.810 --> 51:45.810
画出内存图

51:45.810 --> 51:47.810
那绝对是万物一时

51:47.810 --> 51:49.810
没有比这个更底层了

51:49.810 --> 51:51.810
到这就结束了

51:51.810 --> 51:52.810
好了

51:52.810 --> 51:54.810
这是值和引用

51:54.810 --> 51:56.810
接下来是运算规则

51:56.810 --> 52:00.120
运算规则

52:00.120 --> 52:03.120
介石里面的这些运算规则

52:03.120 --> 52:04.120
可以说

52:04.120 --> 52:05.120
我们说的好听一点

52:05.120 --> 52:06.120
叫做feature

52:06.120 --> 52:08.120
是介石的一种特性

52:08.120 --> 52:09.120
特征

52:09.120 --> 52:10.120
说到难听一点

52:10.120 --> 52:12.120
就是这个语言很粗

52:12.120 --> 52:14.120
它做成了这个鬼样子

52:14.120 --> 52:15.120
但是现在能不能改呢

52:15.120 --> 52:16.120
现在想不想改

52:16.120 --> 52:17.120
特别想改

52:17.120 --> 52:20.120
全世界的前段开发的都想改

52:20.120 --> 52:21.120
不要这样子玩了

52:21.120 --> 52:22.120
要玩死人了

52:22.120 --> 52:24.120
但是能不能改呢

52:24.120 --> 52:25.120
不能改

52:25.120 --> 52:27.120
你改了以前的程序

52:27.120 --> 52:28.120
就玩不了了

52:28.120 --> 52:29.120
就跑不起来了

52:29.120 --> 52:30.120
就要抱错了

52:30.120 --> 52:31.120
说没法改

52:31.120 --> 52:33.120
他为了兼容以前

52:33.120 --> 52:35.120
就造成这么一个鬼样子

52:35.120 --> 52:37.120
因此在我们前段开发的时候

52:37.120 --> 52:40.120
特别特别强调规范

52:40.120 --> 52:43.120
虽然说这些代码你可以写

52:43.120 --> 52:45.120
但是有些东西最好不要写

52:45.120 --> 52:47.120
你们以后学到前段的

52:47.120 --> 52:48.120
工程化的时候

52:48.120 --> 52:50.120
有些东西叫eslit

52:50.120 --> 52:52.120
它就强调代码风格

52:52.120 --> 52:53.120
有些代码里根本就不要碰的

52:53.120 --> 52:54.120
像什么两个等号

52:54.120 --> 52:56.120
根本不应该在你的程序里面出现

52:56.120 --> 52:57.120
我不知道这里边有多少同学

52:57.120 --> 52:59.120
喜欢用两个等号

52:59.120 --> 53:02.120
用等号的时候一定要用三个

53:02.120 --> 53:04.120
为什么两个点号不要出现了

53:04.120 --> 53:05.120
以后就知道两个等号

53:05.120 --> 53:06.120
有多种新的

53:06.120 --> 53:08.120
可会造成各种各样的八个

53:08.120 --> 53:10.120
运算规则

53:10.120 --> 53:12.120
运算规则是考什么呢

53:12.120 --> 53:14.120
就考虑各种运算符

53:14.120 --> 53:16.120
什么夹减成熟

53:16.120 --> 53:18.120
什么求鱼

53:18.120 --> 53:20.120
夹夹减减

53:20.120 --> 53:22.120
还有包括一些等号

53:22.120 --> 53:23.120
两个等号 三个等号

53:23.120 --> 53:25.120
鱼 小鱼

53:25.120 --> 53:27.120
并且 货则

53:27.120 --> 53:29.120
这些都是运算规则

53:29.120 --> 53:31.120
所考察的

53:31.120 --> 53:32.120
这些规则不是很简单吗

53:32.120 --> 53:34.120
夹减成熟谁不会呢

53:34.120 --> 53:36.120
就是因为鸡也是这个语言

53:36.120 --> 53:37.120
它恶心

53:37.120 --> 53:39.120
它恶心什么程度呢

53:39.120 --> 53:40.120
它那个数学

53:40.120 --> 53:42.120
这些夹减成熟的符号

53:42.120 --> 53:44.120
可以用到任何类型

53:44.120 --> 53:45.120
那么这里呢

53:45.120 --> 53:46.120
我打开浏览器了

53:46.120 --> 53:48.430
别忘了

53:48.430 --> 53:50.430
你在别的语言里面

53:50.430 --> 53:51.430
能看到这个东西吗

53:51.430 --> 53:52.430
这啥玩意

53:52.430 --> 53:53.430
在鸡也是这样

53:53.430 --> 53:54.430
可以

53:54.430 --> 53:55.430
有问题

53:55.430 --> 53:57.430
你能看到这个东西吗

53:57.430 --> 53:58.430
这啥玩意

53:58.430 --> 53:59.430
在鸡也是这样

53:59.430 --> 54:00.430
可以

54:00.430 --> 54:01.430
它都不会爆错的

54:01.430 --> 54:02.430
它都会正常运行

54:02.430 --> 54:03.430
那么运算规则

54:03.430 --> 54:04.430
考虑的是什么呢

54:04.430 --> 54:05.430
考虑的就是

54:05.430 --> 54:06.430
各种恶心的

54:06.430 --> 54:07.430
这些运算符

54:07.430 --> 54:08.430
叠在一起

54:08.430 --> 54:10.430
问你它的结果是啥

54:10.430 --> 54:12.430
那么这种题怎么做

54:12.430 --> 54:15.510
我给大家准备了

54:15.510 --> 54:18.950
一个思维导图

54:18.950 --> 54:20.950
以后给大家发下来

54:20.950 --> 54:21.950
说这种题

54:21.950 --> 54:23.950
你背是背不住的

54:23.950 --> 54:25.950
你没发背

54:25.950 --> 54:27.950
它的规则很多

54:27.950 --> 54:29.950
那怎么做呢

54:29.950 --> 54:30.950
听我说

54:30.950 --> 54:32.950
今天晚上我讲完了之后

54:32.950 --> 54:34.950
我会先讲这个思维导图

54:34.950 --> 54:35.950
怎么去用

54:35.950 --> 54:37.950
你怎么来用这个思维导图

54:37.950 --> 54:39.950
讲完了之后

54:39.950 --> 54:40.950
那么下来大家

54:40.950 --> 54:42.950
可以充分发挥各自

54:42.950 --> 54:43.950
每个同学的想象力

54:43.950 --> 54:44.950
我觉得你们的想象力

54:44.950 --> 54:45.950
肯定比我丰富

54:45.950 --> 54:46.950
都是年轻人

54:46.950 --> 54:47.950
对吧

54:47.950 --> 54:48.950
你们在群里表里

54:48.950 --> 54:49.950
给我随便来

54:49.950 --> 54:51.950
就给其他同学出题

54:51.950 --> 54:52.950
相互出题

54:52.950 --> 54:53.950
或者是自己给自己出题

54:53.950 --> 54:55.950
怎么恶心怎么出

54:55.950 --> 54:57.950
然后看一下

54:57.950 --> 54:58.950
能不能回答得出来

54:58.950 --> 54:59.950
你会发现

54:59.950 --> 55:00.950
今天晚上我讲了之后

55:00.950 --> 55:01.950
你任何的运输

55:01.950 --> 55:02.950
管你是什么玩意

55:02.950 --> 55:03.950
我都能给你回答出来

55:03.950 --> 55:05.950
他到底的结果是什么

55:05.950 --> 55:06.950
靠着是什么

55:06.950 --> 55:07.950
靠着就是个查阅

55:07.950 --> 55:08.950
查阅这个思维导图

55:08.950 --> 55:09.950
这个思维导图

55:09.950 --> 55:10.950
你用了一段时间

55:10.950 --> 55:11.950
你用鼠了

55:11.950 --> 55:12.950
做那种面试题

55:12.950 --> 55:13.950
做多了

55:13.950 --> 55:14.950
用鼠了

55:14.950 --> 55:15.950
你不用

55:15.950 --> 55:16.950
你可以扔掉了

55:16.950 --> 55:17.950
因为你已经非常熟悉了

55:17.950 --> 55:18.950
当然

55:18.950 --> 55:19.950
过了一段时间

55:19.950 --> 55:20.950
没有用

55:20.950 --> 55:21.950
也忘了

55:21.950 --> 55:22.950
很正常

55:22.950 --> 55:23.950
这个思维导图

55:23.950 --> 55:25.950
是我周一周二写的

55:25.950 --> 55:26.950
但是现在我基本上

55:26.950 --> 55:28.950
已经忘了差不多了

55:28.950 --> 55:29.950
所以说你们最好

55:29.950 --> 55:30.950
在面试之前

55:30.950 --> 55:31.950
把它过一遍

55:31.950 --> 55:33.950
然后加成一下印象

55:33.950 --> 55:34.950
现在我们来看一下

55:34.950 --> 55:36.950
这个思维导图怎么用

55:36.950 --> 55:38.950
这个思维导图里面有两个

55:38.950 --> 55:39.950
两个东西

55:39.950 --> 55:40.950
一个是运算

55:40.950 --> 55:41.950
一个是转换

55:41.950 --> 55:42.950
运算是什么呢

55:42.950 --> 55:43.950
就是这些符号

55:43.950 --> 55:44.950
什么夹剪成熟啊

55:44.950 --> 55:45.950
求鱼啊

55:45.950 --> 55:47.950
或者并且大鱼

55:47.950 --> 55:48.950
小鱼等号

55:48.950 --> 55:50.950
都是运算符号

55:50.950 --> 55:51.950
你看

55:51.950 --> 55:52.950
我都给分成类的

55:52.950 --> 55:53.950
算数运算

55:53.950 --> 55:54.950
夹剪成熟

55:54.950 --> 55:55.950
求鱼

55:55.950 --> 55:56.950
比较运算

55:56.950 --> 55:57.950
大鱼小鱼

55:57.950 --> 55:58.950
逻辑运算

55:58.950 --> 55:59.950
飞

55:59.950 --> 56:00.950
并且

56:00.950 --> 56:01.950
或者

56:01.950 --> 56:03.950
三目运算

56:03.950 --> 56:04.950
运算符号

56:04.950 --> 56:06.950
它是怎么运算的

56:06.950 --> 56:07.950
查证

56:07.950 --> 56:09.950
在运算的过程中

56:09.950 --> 56:12.950
有可能会遇到转换

56:12.950 --> 56:13.950
就是一个类型

56:13.950 --> 56:14.950
转换成另一个类型

56:14.950 --> 56:16.950
转换的规则

56:16.950 --> 56:17.950
看这

56:17.950 --> 56:18.950
咱们来试一下

56:18.950 --> 56:19.950
看这个好不好用

56:19.950 --> 56:21.950
好不好使

56:21.950 --> 56:22.950
来吧

56:22.950 --> 56:24.950
我们比方说

56:24.950 --> 56:26.950
我们来一个简单的

56:26.950 --> 56:27.950
来一个简单的

56:27.950 --> 56:30.950
去加上force

56:30.950 --> 56:32.950
来一个简单的

56:32.950 --> 56:33.950
好

56:33.950 --> 56:34.950
那么这个怎么来用呢

56:34.950 --> 56:35.950
首先看什么

56:35.950 --> 56:36.950
我这里几个字

56:36.950 --> 56:43.340
首先看这个玩意

56:43.340 --> 56:44.340
符号

56:44.340 --> 56:45.340
首先看运算这里

56:45.340 --> 56:46.340
跟哪个符号匹配的

56:46.340 --> 56:47.340
是不是算数运算

56:47.340 --> 56:48.340
有加吗

56:48.340 --> 56:50.340
好你把这个展开

56:50.340 --> 56:51.340
它告诉你

56:51.340 --> 56:53.340
所有的算数运算

56:53.340 --> 56:55.340
都必须要转换成

56:55.340 --> 56:56.340
原始类型

56:56.340 --> 56:58.340
左右两端必须是

56:58.340 --> 56:59.340
原始类型

56:59.340 --> 57:01.340
这里是不是原始类型

57:01.340 --> 57:02.340
是吗

57:02.340 --> 57:03.340
布尔吗

57:03.340 --> 57:04.340
是不是原始类型

57:04.340 --> 57:05.340
肯定是吗

57:05.340 --> 57:06.340
对不对

57:06.340 --> 57:07.340
不用管了

57:07.340 --> 57:09.340
接下来继续往后看

57:09.340 --> 57:11.340
那怎么算的呢

57:11.340 --> 57:14.650
有两种特殊情况

57:14.650 --> 57:15.650
只要不是特殊情况

57:15.650 --> 57:17.650
那就是全部转换成数字

57:17.650 --> 57:18.650
然后运算

57:18.650 --> 57:20.650
那么我看一下特殊情况

57:20.650 --> 57:21.650
特殊情况就是

57:21.650 --> 57:22.650
有一端是制服串

57:22.650 --> 57:23.650
有没有呢

57:23.650 --> 57:24.650
没有

57:24.650 --> 57:25.650
还有一个就是

57:25.650 --> 57:26.650
有一个是NAN

57:26.650 --> 57:27.650
有没有NAN呢

57:27.650 --> 57:28.650
没有

57:28.650 --> 57:30.650
转换成数字

57:30.650 --> 57:31.650
然后运算

57:31.650 --> 57:33.650
那么我们来转换成数字

57:33.650 --> 57:34.650
怎么转换成数字呢

57:34.650 --> 57:35.650
看这边

57:35.650 --> 57:36.650
转换

57:36.650 --> 57:38.650
打开

57:38.650 --> 57:39.650
怎么转换成数字

57:39.650 --> 57:40.650
你看

57:40.650 --> 57:42.650
原始转数字

57:42.650 --> 57:43.650
其他的原始类型

57:43.650 --> 57:44.650
转换成数字

57:44.650 --> 57:45.650
它的规则是什么

57:45.650 --> 57:47.650
处为1

57:47.650 --> 57:48.650
forced为0

57:48.650 --> 57:49.650
后边不用看了

57:49.650 --> 57:50.650
也就是说

57:50.650 --> 57:51.650
这个表达数是什么

57:51.650 --> 57:53.650
就是1加上0

57:53.650 --> 57:55.650
这个表达数的结果

57:55.650 --> 57:56.650
是不是出来了

57:56.650 --> 57:57.650
就是1

57:57.650 --> 58:01.090
我们再来一个例子

58:01.090 --> 58:03.090
反复来确认

58:03.090 --> 58:05.090
到底好不好用

58:05.090 --> 58:07.090
我们来一个加

58:07.090 --> 58:09.090
这个东西

58:09.090 --> 58:11.090
这个玩意它是怎么算的

58:11.090 --> 58:20.370
首先来看运算

58:20.370 --> 58:21.370
哪个运算

58:21.370 --> 58:22.370
算数运算

58:22.370 --> 58:24.370
因为有加

58:24.370 --> 58:25.370
加在前面什么意思

58:25.370 --> 58:26.370
表示正号

58:26.370 --> 58:27.370
正负的意思

58:27.370 --> 58:28.370
加在前面的意思

58:28.370 --> 58:30.370
表示正号

58:30.370 --> 58:32.370
算数运算

58:32.370 --> 58:34.370
算数运算

58:34.370 --> 58:35.370
干嘛

58:35.370 --> 58:37.370
转换成原始类型

58:37.370 --> 58:39.370
那么现在一个哲学问题来了

58:39.370 --> 58:43.320
这两个通货号是不是原始类型

58:43.320 --> 58:45.320
这个玩意是不是原始类型

58:45.320 --> 58:47.320
肯定不是

58:47.320 --> 58:48.320
你不是

58:48.320 --> 58:49.320
你就不要够谈

58:49.320 --> 58:51.320
你再够谈运算的资格都没有

58:51.320 --> 58:53.320
谈都不要谈这个事

58:53.320 --> 58:55.320
你够捐过变成原始类型再说

58:55.320 --> 58:56.320
那怎么变呢

58:56.320 --> 58:57.320
它下面转弯

58:57.320 --> 58:59.890
多一项

58:59.890 --> 59:00.890
因为我们非原始类型

59:00.890 --> 59:01.890
只能是对象

59:01.890 --> 59:02.890
介石里面

59:02.890 --> 59:03.890
没有别的了

59:03.890 --> 59:04.890
只能是对象

59:04.890 --> 59:05.890
对象

59:05.890 --> 59:07.890
转成原始怎么转

59:08.890 --> 59:09.890
打开

59:09.890 --> 59:10.890
首先

59:10.890 --> 59:12.890
调用这个对象的value

59:12.890 --> 59:16.930
方法

59:16.930 --> 59:17.930
这是一个数组

59:17.930 --> 59:19.930
它里面的方法叫value

59:19.930 --> 59:20.930
全每个对象都有

59:20.930 --> 59:22.930
每个对象都有这个方法

59:22.930 --> 59:24.930
调用这个方法

59:24.930 --> 59:25.930
好

59:25.930 --> 59:26.930
这个方法调用了之后

59:26.930 --> 59:27.930
一般来说

59:27.930 --> 59:29.930
只要你没有特殊处理

59:29.930 --> 59:30.930
一般来说

59:30.930 --> 59:31.930
它反回来就是这个对象本身

59:31.930 --> 59:32.930
你用这个数组

59:32.930 --> 59:33.930
调用这个value

59:33.930 --> 59:34.930
得到的结果

59:34.930 --> 59:35.930
还是这个数组

59:35.930 --> 59:37.930
所以你调没调都是一样的

59:37.930 --> 59:38.930
这是第一步

59:38.930 --> 59:39.930
但是它这一步一定会经过

59:39.930 --> 59:40.930
这一步

59:40.930 --> 59:42.930
调用value

59:42.930 --> 59:43.930
得到的结果

59:43.930 --> 59:44.930
看一下下面

59:44.930 --> 59:46.930
如果说得到的结果是对象

59:46.930 --> 59:47.930
还是对象

59:47.930 --> 59:48.930
你看

59:48.930 --> 59:49.930
我调了value过后

59:49.930 --> 59:50.930
得到的结果

59:50.930 --> 59:51.930
是不是还是对象

59:51.930 --> 59:52.930
还是一个数组

59:52.930 --> 59:55.930
那继续调用这个对象的图示讯

59:55.930 --> 59:56.930
相当于是什么呢

59:56.930 --> 59:58.930
相当于我先调了一个value

59:58.930 --> 59:59.930
我得到的结果

59:59.930 --> 01:00:00.930
还是对象

01:00:00.930 --> 01:00:01.930
还是对象的话

01:00:01.930 --> 01:00:05.140
我就调图示讯

01:00:05.140 --> 01:00:06.140
现在是不是对象了

01:00:06.140 --> 01:00:07.140
现在就不是了

01:00:07.140 --> 01:00:08.140
变成什么了

01:00:08.140 --> 01:00:10.140
变成了数组

01:00:10.140 --> 01:00:12.140
数组转成 转成这个样子

01:00:12.140 --> 01:00:14.140
同学们应该知道了

01:00:14.140 --> 01:00:16.140
我给你写个数组了

01:00:18.140 --> 01:00:19.140
其实就是你们

01:00:19.140 --> 01:00:21.140
用console log打印出来的结果

01:00:21.140 --> 01:00:24.220
懂吗

01:00:24.220 --> 01:00:25.220
懂得意思吗

01:00:25.220 --> 01:00:27.220
数组转成制服圈就是这样子

01:00:27.220 --> 01:00:29.220
图示讯

01:00:29.220 --> 01:00:30.220
好 所以说得到的结果是什么呢

01:00:30.220 --> 01:00:34.220
得到的结果是一个空制服圈

01:00:34.220 --> 01:00:35.220
那么有意思呢

01:00:35.220 --> 01:00:36.220
刚才那个问题

01:00:36.220 --> 01:00:38.220
转化成了什么呢

01:00:38.220 --> 01:00:39.220
这个问题

01:00:39.220 --> 01:00:41.220
就转化成了这个问题了

01:00:41.220 --> 01:00:46.100
转化成了这个问题了

01:00:46.100 --> 01:00:47.100
对吧

01:00:47.100 --> 01:00:48.100
那么现在我们来看这个问题

01:00:48.100 --> 01:00:49.100
这个问题可以玩了吗

01:00:49.100 --> 01:00:50.100
就可以玩了

01:00:50.100 --> 01:00:51.100
回到这

01:00:51.100 --> 01:00:53.100
好 现在变成原式内容了

01:00:53.100 --> 01:00:54.100
对吧

01:00:54.100 --> 01:00:55.100
我们来看一下

01:00:55.100 --> 01:00:57.100
是不是特殊情况啊

01:00:57.100 --> 01:00:58.100
不是

01:00:58.100 --> 01:00:59.100
特殊情况是x加y

01:00:59.100 --> 01:01:01.100
它是不是x加y

01:01:01.100 --> 01:01:02.100
不是

01:01:02.100 --> 01:01:03.100
它是加号出现前面

01:01:03.100 --> 01:01:04.100
是个正好

01:01:04.100 --> 01:01:05.100
是不是有nn

01:01:05.100 --> 01:01:06.100
没有nn

01:01:07.100 --> 01:01:08.100
干嘛

01:01:08.100 --> 01:01:09.100
转成数字

01:01:09.100 --> 01:01:10.100
然后运算

01:01:10.100 --> 01:01:11.100
好

01:01:11.100 --> 01:01:12.100
那转成数字

01:01:12.100 --> 01:01:13.100
干了

01:01:13.100 --> 01:01:15.100
制服圈怎么转数字呢

01:01:15.100 --> 01:01:16.100
原式转数字

01:01:16.100 --> 01:01:18.100
然制服圈

01:01:18.100 --> 01:01:20.100
空制服圈

01:01:20.100 --> 01:01:21.100
这个吗

01:01:21.100 --> 01:01:22.100
空制服圈是吗

01:01:22.100 --> 01:01:23.100
转成什么

01:01:23.100 --> 01:01:24.100
转成0

01:01:24.100 --> 01:01:27.380
好

01:01:27.380 --> 01:01:28.380
那么现在

01:01:28.380 --> 01:01:30.380
也就是这个空制服圈

01:01:30.380 --> 01:01:31.380
是不是相当于转成什么

01:01:31.380 --> 01:01:32.380
转成0

01:01:32.380 --> 01:01:35.380
因此这个地方就等于0

01:01:35.380 --> 01:01:36.380
就是它为什么

01:01:36.380 --> 01:01:37.380
它会出现0

01:01:37.380 --> 01:01:38.380
0是怎么来的

01:01:38.380 --> 01:01:40.380
就这么来的

01:01:40.380 --> 01:01:42.380
懂了意思吧

01:01:43.380 --> 01:01:44.380
你不要去背

01:01:44.380 --> 01:01:45.380
你背不住的

01:01:45.380 --> 01:01:46.380
同学们

01:01:46.380 --> 01:01:48.380
我都背不住

01:01:48.380 --> 01:01:49.380
不要去背

01:01:49.380 --> 01:01:50.380
查

01:01:50.380 --> 01:01:53.380
你只要通过查这个玩意儿

01:01:53.380 --> 01:01:55.380
能够得到正确的结果

01:01:55.380 --> 01:01:56.380
可以了

01:01:56.380 --> 01:01:57.380
当你查了很多次过后

01:01:57.380 --> 01:01:59.380
你自然就熟悉了

01:01:59.380 --> 01:02:00.380
咱们做软件开发

01:02:00.380 --> 01:02:01.380
千万不要去背

01:02:01.380 --> 01:02:03.380
你只要学会怎么去查

01:02:03.380 --> 01:02:04.380
就可以了

01:02:04.380 --> 01:02:05.380
知道吧

01:02:05.380 --> 01:02:06.380
这个玩意儿你是背不住的啊

01:02:06.380 --> 01:02:07.380
好

01:02:07.380 --> 01:02:10.650
咱们再来

01:02:10.650 --> 01:02:11.650
这个玩意儿

01:02:11.650 --> 01:02:13.650
它为什么又是nn

01:02:13.650 --> 01:02:14.650
解释一下这个现象的

01:02:14.650 --> 01:02:15.650
为什么是nn

01:02:15.650 --> 01:02:16.650
来吧 又来吧

01:02:16.650 --> 01:02:18.650
多查几世纪慢慢就知道了

01:02:18.650 --> 01:02:19.650
你看

01:02:19.650 --> 01:02:21.650
这个东西先过转发是什么

01:02:21.650 --> 01:02:22.650
先过转发的原式类型再说

01:02:22.650 --> 01:02:24.650
转发的原式类型是不是又来了

01:02:24.650 --> 01:02:25.650
先调用Value

01:02:25.650 --> 01:02:26.650
再调用ToStream

01:02:26.650 --> 01:02:27.650
来吧

01:02:27.650 --> 01:02:28.650
这个玩意儿

01:02:28.650 --> 01:02:29.650
调用Value

01:02:29.650 --> 01:02:30.650
有对象

01:02:32.650 --> 01:02:33.650
然后呢

01:02:33.650 --> 01:02:35.650
ovgetToValue

01:02:36.650 --> 01:02:38.650
再调用ToStream

01:02:38.650 --> 01:02:40.650
它的到处是什么呀

01:02:40.650 --> 01:02:42.650
是不是这个东西

01:02:42.650 --> 01:02:43.650
对吧

01:02:43.650 --> 01:02:44.650
就这么一个字不错

01:02:44.650 --> 01:02:45.650
所以说这个玩意儿就相当于是

01:02:45.650 --> 01:02:46.650
这么一个玩意儿

01:02:48.650 --> 01:02:49.650
好

01:02:49.650 --> 01:02:50.650
那么又是不是又来

01:02:50.650 --> 01:02:52.650
这个字不错的转发能数字吧

01:02:52.650 --> 01:02:53.650
因为按照我们刚才的规则

01:02:53.650 --> 01:02:54.650
变成原式类型了

01:02:54.650 --> 01:02:55.650
但是

01:02:55.650 --> 01:02:56.650
你得转发能数字

01:02:56.650 --> 01:02:57.650
好

01:02:57.650 --> 01:02:58.650
然后又来

01:02:58.650 --> 01:02:59.650
字不错转发能数字

01:02:59.650 --> 01:03:00.650
空字不错

01:03:00.650 --> 01:03:01.650
那就是0

01:03:01.650 --> 01:03:02.650
它不是空字不错

01:03:03.650 --> 01:03:04.650
去掉以后

01:03:04.650 --> 01:03:05.650
直接给我去掉

01:03:06.650 --> 01:03:08.650
去掉过后是不是数字

01:03:08.650 --> 01:03:09.650
不是数字

01:03:09.650 --> 01:03:13.410
不是数字就是nn

01:03:13.410 --> 01:03:14.410
好

01:03:14.410 --> 01:03:15.410
那么我们先看

01:03:15.410 --> 01:03:16.410
是不是特殊情况

01:03:16.410 --> 01:03:17.410
NAN和任何类型的运算

01:03:17.410 --> 01:03:18.410
得到的还是NAN

01:03:18.410 --> 01:03:20.410
因此这里得到的是NAN

01:03:20.410 --> 01:03:21.410
就这么来的

01:03:22.410 --> 01:03:23.410
好

01:03:23.410 --> 01:03:24.410
那么我们就可以继续来啊

01:03:24.410 --> 01:03:25.410
继续来玩

01:03:26.410 --> 01:03:27.410
这就可以玩很多东西了

01:03:28.410 --> 01:03:29.410
比方说我们现在有

01:03:29.410 --> 01:03:31.410
我有一个对象是这么写的

01:03:44.470 --> 01:03:45.470
就这样

01:03:45.470 --> 01:03:46.470
都不要属性的

01:03:55.640 --> 01:03:57.640
然后我输出ovget加银

01:04:02.060 --> 01:04:03.060
输出啥呀

01:04:04.060 --> 01:04:05.060
来吧

01:04:05.060 --> 01:04:06.060
我又来吧

01:04:06.060 --> 01:04:08.060
来用这个流程来分析

01:04:09.060 --> 01:04:15.920
几个读

01:04:15.920 --> 01:04:17.920
已经说出正确答案了

01:04:17.920 --> 01:04:18.920
首先这是个加号

01:04:18.920 --> 01:04:19.920
加号是不是算数运算

01:04:19.920 --> 01:04:20.920
算数运算干嘛

01:04:20.920 --> 01:04:22.920
转换成原式类型

01:04:22.920 --> 01:04:23.920
本来就是原式类型

01:04:23.920 --> 01:04:24.920
就是ovget的问题了

01:04:24.920 --> 01:04:26.920
ovget你给我变成原式类型

01:04:26.920 --> 01:04:28.920
变原式类型怎么变

01:04:28.920 --> 01:04:29.920
首先调用白柳

01:04:29.920 --> 01:04:31.920
调用完白柳之后

01:04:32.920 --> 01:04:34.920
是不是对象了

01:04:34.920 --> 01:04:35.920
得到了的是3

01:04:36.920 --> 01:04:37.920
3是不是对象

01:04:37.920 --> 01:04:38.920
不是了

01:04:38.920 --> 01:04:39.920
3就是原式类型了

01:04:39.920 --> 01:04:41.920
所以说停止后边流程

01:04:41.920 --> 01:04:42.920
后边流程不走了

01:04:42.920 --> 01:04:44.920
那直接就是3加银

01:04:45.920 --> 01:04:46.920
就这么简单

01:04:46.920 --> 01:04:47.920
得到的结果是多少

01:04:47.920 --> 01:04:48.920
4

01:04:48.920 --> 01:04:49.920
所以这个结果就是4

01:04:52.550 --> 01:04:53.550
那如果说你返回的不是3

01:04:53.550 --> 01:04:54.550
返回的实验室呢

01:04:55.550 --> 01:04:56.550
那又不一样了

01:04:56.550 --> 01:04:58.550
你返回的是Z过后呢

01:04:58.550 --> 01:05:00.550
ovget加银

01:05:00.550 --> 01:05:01.550
ovget要转换成原式类型

01:05:01.550 --> 01:05:03.550
原式类型返回的是怎么Z

01:05:03.550 --> 01:05:04.550
Z就是ovget

01:05:04.550 --> 01:05:05.550
就是它自己

01:05:06.550 --> 01:05:07.550
那怎么办

01:05:07.550 --> 01:05:08.550
得到了还是

01:05:08.550 --> 01:05:09.550
比起还是对象

01:05:09.550 --> 01:05:10.550
还对象的话

01:05:10.550 --> 01:05:11.550
继续没完

01:05:11.550 --> 01:05:12.550
这就是没完

01:05:13.550 --> 01:05:14.550
得到结果是4

01:05:16.990 --> 01:05:17.990
得到结果是多少

01:05:17.990 --> 01:05:18.990
最后4加银就是5

01:05:21.300 --> 01:05:23.300
那如果说我这里返回的是这个呢

01:05:23.300 --> 01:05:24.300
返回的是字符串式的

01:05:24.300 --> 01:05:25.300
那一样的吗

01:05:25.300 --> 01:05:26.300
你交往那个图形过后

01:05:26.300 --> 01:05:27.300
变成字符串式的

01:05:27.300 --> 01:05:28.300
字符串式

01:05:28.300 --> 01:05:29.300
左右两端

01:05:29.300 --> 01:05:30.300
有一颗是字符串

01:05:30.300 --> 01:05:31.300
是不是变成字符串的评阶了

01:05:31.300 --> 01:05:33.300
变成4加银了

01:05:33.300 --> 01:05:35.300
把1转成字符串来进行评阶

01:05:35.300 --> 01:05:36.300
变成4加银

01:05:37.300 --> 01:05:38.300
就这么

01:05:38.300 --> 01:05:39.300
这4是1

01:05:39.300 --> 01:05:40.300
不叫4是1

01:05:40.300 --> 01:05:41.300
叫41

01:05:41.300 --> 01:05:42.300
字符串嘛

01:05:42.300 --> 01:05:43.300
就这么来看

01:05:44.300 --> 01:05:45.300
那如果说你和图形返回的

01:05:45.300 --> 01:05:46.300
还是对象呢

01:05:51.640 --> 01:05:52.640
返回的还是对象呢

01:05:52.640 --> 01:05:53.640
那就看我这个规则

01:05:55.950 --> 01:05:56.950
得到的还是对象

01:05:56.950 --> 01:05:57.950
你就是抱错了

01:05:57.950 --> 01:05:58.950
你把它逼得没糟了

01:05:59.950 --> 01:06:00.950
因为它玩不了了

01:06:00.950 --> 01:06:01.950
这个事情已经玩不了了

01:06:01.950 --> 01:06:02.950
你看怎么玩吧

01:06:02.950 --> 01:06:03.950
这个事情

01:06:03.950 --> 01:06:04.950
没怕玩了

01:06:04.950 --> 01:06:05.950
这个事情

01:06:05.950 --> 01:06:06.950
玩不了了

01:06:06.950 --> 01:06:07.950
所以说

01:06:07.950 --> 01:06:08.950
抱错了

01:06:08.950 --> 01:06:09.950
无法把这个OBG

01:06:09.950 --> 01:06:10.950
把这个对象

01:06:10.950 --> 01:06:12.950
转换成原始的字

01:06:12.950 --> 01:06:13.950
转换不了

01:06:13.950 --> 01:06:14.950
就玩不了了

01:06:14.950 --> 01:06:15.950
抱错了

01:06:15.950 --> 01:06:16.950
懂了意思吧

01:06:16.950 --> 01:06:17.950
所以说你看到这个

01:06:17.950 --> 01:06:18.950
用这个思维导致

01:06:18.950 --> 01:06:19.950
去做任何的

01:06:20.950 --> 01:06:22.950
就是运算规则的体

01:06:22.950 --> 01:06:23.950
都没有任何问题

01:06:23.950 --> 01:06:24.950
那比方说再来

01:06:25.950 --> 01:06:27.950
我的图书写没写

01:06:27.950 --> 01:06:37.250
那像我现在说的是啥

01:06:37.250 --> 01:06:38.250
现在说的是啥

01:06:38.250 --> 01:06:44.020
说的是啥

01:06:44.020 --> 01:06:45.020
说的是1

01:06:47.460 --> 01:06:48.460
说的是1是吧

01:06:48.460 --> 01:06:49.460
嗯

01:06:49.460 --> 01:06:50.460
现在说的是1

01:06:50.460 --> 01:06:51.460
说的是1

01:06:51.460 --> 01:06:52.460
为什么说是1呢

01:06:52.460 --> 01:06:53.460
首先调问它的

01:06:53.460 --> 01:06:54.460
OBG调问它的value

01:06:54.460 --> 01:06:55.460
得到什么

01:06:55.460 --> 01:06:56.460
得到是数组

01:06:56.460 --> 01:06:57.460
数组是不是对象

01:06:57.460 --> 01:06:58.460
是对象吗

01:06:58.460 --> 01:06:59.460
没玩啊

01:06:59.460 --> 01:07:00.460
那接下来就调用这个数

01:07:00.460 --> 01:07:01.460
反回这个对象

01:07:01.460 --> 01:07:03.460
反回这个数组的图书写

01:07:03.460 --> 01:07:04.460
那么这个玩意的图书写

01:07:04.460 --> 01:07:05.460
是不是就是

01:07:05.460 --> 01:07:06.460
看了过的

01:07:06.460 --> 01:07:07.460
就这个玩意

01:07:07.460 --> 01:07:08.460
好

01:07:08.460 --> 01:07:09.460
那么左右两端

01:07:09.460 --> 01:07:10.460
有一个是制服串

01:07:10.460 --> 01:07:11.460
说制服串拼接

01:07:11.460 --> 01:07:13.460
得到的结果是1

01:07:13.460 --> 01:07:15.460
并且它是一个制服串

01:07:15.460 --> 01:07:16.460
这是一个制服串

01:07:16.460 --> 01:07:17.460
得到的结果是这个

01:07:17.460 --> 01:07:19.460
是一个制服串的1

01:07:19.460 --> 01:07:20.460
不是一个数字的1

01:07:21.460 --> 01:07:22.460
嗯

01:07:23.460 --> 01:07:24.460
这样

01:07:24.460 --> 01:07:27.220
看一下啊

01:07:27.220 --> 01:07:28.220
value

01:07:29.220 --> 01:07:30.220
反回一个数组

01:07:35.020 --> 01:07:36.020
哎呦

01:07:36.020 --> 01:07:37.020
哎呦哎呦哎呦

01:07:37.020 --> 01:07:39.020
不对不对不对不对不对

01:07:39.020 --> 01:07:40.020
不对

01:07:40.020 --> 01:07:41.020
这个地方是调用的

01:07:41.020 --> 01:07:43.020
OBG的图书写啊

01:07:43.020 --> 01:07:45.020
调用的是OBG的图书写

01:07:45.020 --> 01:07:47.020
它不是数组的图书写

01:07:48.020 --> 01:07:49.020
你看啊

01:07:49.020 --> 01:07:51.020
这就说错了

01:07:51.020 --> 01:07:52.020
调用的是OBG的图书写啊

01:07:52.020 --> 01:07:54.020
跟这里的版本没关系

01:07:54.020 --> 01:07:56.020
这里说写错了

01:07:57.020 --> 01:07:58.020
调用

01:07:59.020 --> 01:08:03.020
原来对象的图书写

01:08:04.020 --> 01:08:06.020
啊是这啊是这

01:08:06.020 --> 01:08:09.940
OBG

01:08:10.940 --> 01:08:11.940
不是个对象吗

01:08:11.940 --> 01:08:13.940
OBG是对象了

01:08:13.940 --> 01:08:14.940
是对象了

01:08:14.940 --> 01:08:15.940
怎么了

01:08:15.940 --> 01:08:16.940
是对象怎么了

01:08:16.940 --> 01:08:17.940
它先调用value

01:08:17.940 --> 01:08:19.940
value得不到原式的值

01:08:19.940 --> 01:08:21.940
然后还再调用它的图书写

01:08:21.940 --> 01:08:22.940
这里我说错了啊

01:08:22.940 --> 01:08:24.940
不是调用这个反回的数组的图书写

01:08:24.940 --> 01:08:26.940
调用的是它的图书写

01:08:26.940 --> 01:08:27.940
还是它的图书写

01:08:27.940 --> 01:08:28.940
所以得到了试

01:08:28.940 --> 01:08:29.940
刚才得到了试

01:08:29.940 --> 01:08:31.940
为什么是这个呢

01:08:31.940 --> 01:08:32.940
为什么是这个呢

01:08:32.940 --> 01:08:33.940
因为它的图书写我没有改

01:08:33.940 --> 01:08:34.940
没有改的话

01:08:34.940 --> 01:08:36.940
没人得到的就是这么一个支付串

01:08:36.940 --> 01:08:37.940
所以得到的是这个

01:08:37.940 --> 01:08:42.210
然后再拼接上1

01:08:42.210 --> 01:08:43.210
把1变成

01:08:43.210 --> 01:08:45.210
变成一个支付串

01:08:45.210 --> 01:08:47.210
变成了这个东西的

01:08:49.210 --> 01:08:50.210
好 接下来

01:08:50.210 --> 01:08:51.210
我们来尝试的啊

01:08:51.210 --> 01:08:53.210
开始来做这一点的

01:08:53.210 --> 01:08:54.210
值和引用的电视题

01:08:54.210 --> 01:08:55.210
这个题呢

01:08:55.210 --> 01:08:57.210
我

01:08:57.210 --> 01:08:58.210
预算规则的面试题

01:08:58.210 --> 01:08:59.210
这个题呢

01:08:59.210 --> 01:09:00.210
我不打算一个一个讲完

01:09:00.210 --> 01:09:02.210
我讲一些比较有代表性的

01:09:02.210 --> 01:09:03.210
好吧

01:09:03.210 --> 01:09:04.210
剩下的东西呢

01:09:04.210 --> 01:09:05.210
大家可以按照我课堂上

01:09:05.210 --> 01:09:06.210
讲的那种规则

01:09:06.210 --> 01:09:07.210
自己去查阅

01:09:07.210 --> 01:09:08.210
也可以下来之后

01:09:08.210 --> 01:09:09.210
我强烈建议大家下来之后啊

01:09:09.210 --> 01:09:12.210
同学们在群里边互相出题

01:09:12.210 --> 01:09:14.210
各种耳性的题都可以

01:09:14.210 --> 01:09:16.210
然后来

01:09:16.210 --> 01:09:24.000
训练自己的这些规则

01:09:24.000 --> 01:09:25.000
是吧

01:09:25.000 --> 01:09:27.000
OPG的Prototype TOSGIN

01:09:27.000 --> 01:09:29.000
就会得到OPG的TAP

01:09:29.000 --> 01:09:30.000
我们用的TOSGIN

01:09:30.000 --> 01:09:32.000
是OPG的Prototype TOSGIN

01:09:32.000 --> 01:09:33.000
用的都是它

01:09:33.000 --> 01:09:36.780
好来吧

01:09:36.780 --> 01:09:38.780
直传的参数不一样

01:09:38.780 --> 01:09:43.120
有些对象呢

01:09:43.120 --> 01:09:44.120
他给大家重写过了

01:09:44.120 --> 01:09:45.120
比方说像素主

01:09:45.120 --> 01:09:46.120
给大家重写过了

01:09:46.120 --> 01:09:48.120
好咱们来看这儿

01:09:48.120 --> 01:09:50.120
看什么呢

01:09:50.120 --> 01:09:52.120
看一点

01:09:52.120 --> 01:09:53.120
稍微点难度的吧

01:09:53.120 --> 01:09:54.120
这个

01:09:54.120 --> 01:09:55.120
这也是比较经典的

01:09:55.120 --> 01:09:56.120
经典的

01:09:56.120 --> 01:09:57.120
经常出现在各种面试题

01:09:57.120 --> 01:09:58.120
这边的

01:09:58.120 --> 01:09:59.120
两个大过号

01:09:59.120 --> 01:10:00.120
加一个中过号

01:10:00.120 --> 01:10:03.690
这到底

01:10:04.690 --> 01:10:06.690
就这个玩意

01:10:06.690 --> 01:10:08.690
这个题怎么分析呢

01:10:08.690 --> 01:10:11.580
好

01:10:11.580 --> 01:10:12.580
这个题呢

01:10:12.580 --> 01:10:13.580
可能结过了

01:10:13.580 --> 01:10:15.580
并不是大家认为的

01:10:15.580 --> 01:10:16.580
我们

01:10:16.580 --> 01:10:17.580
正常人的话

01:10:17.580 --> 01:10:19.580
应该是这样子分析的

01:10:19.580 --> 01:10:20.580
就是左右两端呢

01:10:20.580 --> 01:10:21.580
它都是

01:10:21.580 --> 01:10:22.580
不是一个原始值

01:10:22.580 --> 01:10:23.580
所以说我这个

01:10:23.580 --> 01:10:24.580
尝试的把它

01:10:24.580 --> 01:10:25.580
转换成原始值

01:10:25.580 --> 01:10:26.580
这个玩意

01:10:26.580 --> 01:10:27.580
转换成原始值

01:10:27.580 --> 01:10:28.580
是不是刚才已经分析过了

01:10:28.580 --> 01:10:30.580
转换出来的是NAN

01:10:30.580 --> 01:10:31.580
转换数字

01:10:31.580 --> 01:10:33.580
最多是得到的结果是NAN

01:10:33.580 --> 01:10:34.580
那么这个

01:10:34.580 --> 01:10:36.580
数组呢得到的结果是0

01:10:36.580 --> 01:10:37.580
是吧

01:10:37.580 --> 01:10:38.580
所以说这个最终结果呢

01:10:38.580 --> 01:10:41.580
应该是一个NAN才对

01:10:41.580 --> 01:10:43.580
因为NAN跟任何数值运算都是NAN

01:10:43.580 --> 01:10:44.580
但是呢

01:10:44.580 --> 01:10:45.580
奇怪的是

01:10:45.580 --> 01:10:46.580
它是0

01:10:46.580 --> 01:10:48.580
为什么它会是0呢

01:10:48.580 --> 01:10:49.580
这个代码

01:10:49.580 --> 01:10:50.580
我稍微换一种格式

01:10:50.580 --> 01:10:52.580
你就明白了

01:10:52.580 --> 01:10:53.580
这个代码的格式

01:10:53.580 --> 01:10:55.580
是这样子的

01:10:55.580 --> 01:11:01.260
这里是没有空格的啊

01:11:01.260 --> 01:11:02.260
浏览器

01:11:02.260 --> 01:11:03.260
它把这个代码

01:11:03.260 --> 01:11:05.260
看成了这个样子

01:11:05.260 --> 01:11:06.260
它认为

01:11:06.260 --> 01:11:07.260
上面的两个大过号

01:11:07.260 --> 01:11:09.260
不是对象

01:11:09.260 --> 01:11:11.260
而是一个代码段

01:11:11.260 --> 01:11:12.260
你们知道在纪念室里边

01:11:12.260 --> 01:11:13.260
是可以写这种代码的

01:11:13.260 --> 01:11:14.260
知道了

01:11:14.260 --> 01:11:17.210
在纪念室里边

01:11:17.210 --> 01:11:18.210
可以写这种代码

01:11:18.210 --> 01:11:20.900
比方说

01:11:20.900 --> 01:11:21.900
你可以在这里写两个

01:11:21.900 --> 01:11:22.900
华货号是啥都没有

01:11:22.900 --> 01:11:23.900
没有衣服

01:11:23.900 --> 01:11:24.900
没有判断

01:11:24.900 --> 01:11:25.900
没有负

01:11:25.900 --> 01:11:26.900
但是你可以写这种代码

01:11:26.900 --> 01:11:27.900
没问题了

01:11:27.900 --> 01:11:29.900
表示一个代码段

01:11:29.900 --> 01:11:30.900
这里是个代码段

01:11:30.900 --> 01:11:31.900
就这么个意思

01:11:31.900 --> 01:11:32.900
所以说

01:11:32.900 --> 01:11:33.900
这两个华货号

01:11:33.900 --> 01:11:35.900
它认为这个只是一个代码段而已

01:11:35.900 --> 01:11:36.900
它并不是一个对象

01:11:36.900 --> 01:11:37.900
懂了意思吧

01:11:37.900 --> 01:11:38.900
所以说它最终

01:11:38.900 --> 01:11:39.900
求的是什么

01:11:39.900 --> 01:11:40.900
求的是这个的值

01:11:40.900 --> 01:11:41.900
这个值

01:11:41.900 --> 01:11:42.900
我们之前是不是求过

01:11:42.900 --> 01:11:43.900
得到的是零

01:11:43.900 --> 01:11:44.900
这里有一个小知识

01:11:44.900 --> 01:11:45.900
所以说

01:11:45.900 --> 01:11:46.900
这个地方

01:11:46.900 --> 01:11:47.900
这个玩意得到的是零

01:11:47.900 --> 01:11:49.900
然后接下来反过来

01:11:49.900 --> 01:11:53.340
反过来

01:11:53.340 --> 01:11:57.810
反过来就不一样了

01:11:57.810 --> 01:11:59.810
反过来之后呢

01:11:59.810 --> 01:12:00.810
得到结果是什么呢

01:12:00.810 --> 01:12:01.810
得到结果就是

01:12:01.810 --> 01:12:04.810
得到结果是那个

01:12:04.810 --> 01:12:08.250
怎么是这个呢

01:12:08.250 --> 01:12:09.250
是你

01:12:09.250 --> 01:12:10.250
对了

01:12:10.250 --> 01:12:11.250
对了

01:12:11.250 --> 01:12:12.250
变成字符这儿拼接了

01:12:12.250 --> 01:12:13.250
那为什么变成这样子呢

01:12:13.250 --> 01:12:15.250
你看

01:12:15.250 --> 01:12:17.250
这个玩意

01:12:17.250 --> 01:12:18.250
左边的中货号

01:12:18.250 --> 01:12:19.250
得到结果是什么呢

01:12:19.250 --> 01:12:20.250
首先是个加号

01:12:20.250 --> 01:12:21.250
左右两个人都不是一个

01:12:21.250 --> 01:12:22.250
不是一个

01:12:22.250 --> 01:12:23.250
原式类小

01:12:23.250 --> 01:12:24.250
需要转换

01:12:24.250 --> 01:12:25.250
那么

01:12:25.250 --> 01:12:26.250
这个玩意

01:12:26.250 --> 01:12:27.250
转换的原式类小是啥

01:12:27.250 --> 01:12:28.250
不是数字

01:12:28.250 --> 01:12:29.250
转换的原式类小

01:12:29.250 --> 01:12:30.250
原式类小

01:12:30.250 --> 01:12:31.250
是不是空字不串

01:12:31.250 --> 01:12:32.250
对

01:12:32.250 --> 01:12:34.250
是不是空字不串

01:12:34.250 --> 01:12:35.250
然后

01:12:35.250 --> 01:12:36.250
这个玩意

01:12:36.250 --> 01:12:37.250
转换的原式类小是啥

01:12:37.250 --> 01:12:38.250
原式类小

01:12:38.250 --> 01:12:41.010
是不是这个玩意

01:12:41.010 --> 01:12:42.010
是不是拼接

01:12:42.010 --> 01:12:44.010
拼接出来就变成这样子了

01:12:44.010 --> 01:12:45.010
所以说这个面试体

01:12:45.010 --> 01:12:47.010
经常会遇到这种

01:12:47.010 --> 01:12:48.010
为你这个玩意

01:12:48.010 --> 01:12:50.010
又反过来

01:12:50.010 --> 01:12:52.010
反过来

01:12:52.010 --> 01:12:53.010
这个玩意

01:12:53.010 --> 01:12:54.010
它们是不一样的

01:12:54.010 --> 01:12:55.010
好

01:12:55.010 --> 01:12:56.010
再来看

01:12:56.010 --> 01:12:58.010
这里

01:12:58.010 --> 01:13:00.010
有这么一个

01:13:00.010 --> 01:13:05.050
把它扩起来

01:13:05.050 --> 01:13:06.050
扩起来

01:13:06.050 --> 01:13:08.050
扩起来又是啥呢

01:13:08.050 --> 01:13:09.050
扩起来又正常

01:13:09.050 --> 01:13:10.050
为什么扩起来

01:13:10.050 --> 01:13:11.050
就正常了

01:13:11.050 --> 01:13:12.050
因为

01:13:12.050 --> 01:13:15.050
刚才没有扩起来的时候

01:13:15.050 --> 01:13:16.050
它不认为

01:13:16.050 --> 01:13:17.050
这个整体

01:13:17.050 --> 01:13:19.050
它认为前面是一段代

01:13:19.050 --> 01:13:20.050
只是里面没有写

01:13:20.050 --> 01:13:22.050
然后后边是一个正号

01:13:22.050 --> 01:13:23.050
数组

01:13:23.050 --> 01:13:25.050
但是你一旦把它扩起来过来

01:13:25.050 --> 01:13:26.050
它就变成一个整体

01:13:26.050 --> 01:13:27.050
变成一个表达式了

01:13:27.050 --> 01:13:28.050
懂得意思吗

01:13:28.050 --> 01:13:30.050
所以它把它变成一个对象了

01:13:30.050 --> 01:13:31.050
就是它接的是解释器

01:13:31.050 --> 01:13:33.050
它这样理解的

01:13:33.050 --> 01:13:34.050
就是接着

01:13:34.050 --> 01:13:36.050
它有一些地方比较怪异

01:13:36.050 --> 01:13:37.050
那么这个就跟刚才

01:13:37.050 --> 01:13:38.050
是一样的

01:13:38.050 --> 01:13:39.050
这个玩意

01:13:39.050 --> 01:13:40.050
转换的原式类小

01:13:40.050 --> 01:13:41.050
就是凹不解释

01:13:41.050 --> 01:13:42.050
然后加上一个数组

01:13:42.050 --> 01:13:43.050
就变成了空字不串

01:13:43.050 --> 01:13:44.050
数组是个空字不串

01:13:44.050 --> 01:13:45.050
就变成这样子

01:13:46.050 --> 01:13:47.050
然后呢

01:13:47.050 --> 01:13:48.050
我看一下

01:13:51.050 --> 01:13:52.050
这个

01:13:52.050 --> 01:13:57.110
看一下这个玩意

01:13:57.110 --> 01:14:00.740
这个玩意由于加号

01:14:00.740 --> 01:14:01.740
出现在它前边

01:14:01.740 --> 01:14:03.740
所以说它跑不了了

01:14:03.740 --> 01:14:04.740
就跟我们

01:14:04.740 --> 01:14:05.740
刚才可以看到

01:14:05.740 --> 01:14:06.740
直接加号出来的

01:14:06.740 --> 01:14:07.740
这里是一样的

01:14:07.740 --> 01:14:08.740
我们之前分析过

01:14:08.740 --> 01:14:09.740
这是一个NN

01:14:09.740 --> 01:14:11.740
那么这个加

01:14:11.740 --> 01:14:12.740
加

01:14:12.740 --> 01:14:13.740
是不是等于

01:14:13.740 --> 01:14:14.740
解

01:14:15.740 --> 01:14:17.740
我们先算这个加解

01:14:17.740 --> 01:14:18.740
这个玩意得到是

01:14:18.740 --> 01:14:19.740
N

01:14:19.740 --> 01:14:20.740
这个玩意得到是什么

01:14:20.740 --> 01:14:21.740
NAN

01:14:21.740 --> 01:14:22.740
好 现在我们又到

01:14:22.740 --> 01:14:23.740
一个新的运算符

01:14:24.740 --> 01:14:25.740
两个等号

01:14:25.740 --> 01:14:26.740
是吧 两个等号

01:14:26.740 --> 01:14:27.740
看看 看这

01:14:27.740 --> 01:14:28.740
比较运算符

01:14:28.740 --> 01:14:29.740
哪个

01:14:29.740 --> 01:14:30.740
两个等号

01:14:30.740 --> 01:14:31.740
两个等号你看一个

01:14:31.740 --> 01:14:32.740
多少种情况

01:14:32.740 --> 01:14:33.740
三个等号只有两种情况

01:14:33.740 --> 01:14:34.740
两个等号

01:14:34.740 --> 01:14:35.740
有这么多的情况

01:14:35.740 --> 01:14:37.740
两端存在NAN

01:14:37.740 --> 01:14:38.740
一定为Force

01:14:39.740 --> 01:14:40.740
两个等号

01:14:40.740 --> 01:14:42.740
两端存在NAN

01:14:42.740 --> 01:14:43.740
一定为Force

01:14:43.740 --> 01:14:44.740
所有的表达是

01:14:44.740 --> 01:14:47.180
一定为Force

01:14:48.180 --> 01:14:49.180
接下来看这

01:14:50.180 --> 01:14:51.180
看这个

01:14:52.180 --> 01:14:53.180
这个是啥意思

01:14:53.180 --> 01:14:55.180
看上去好像我们的

01:14:55.180 --> 01:14:56.180
辅述的理解

01:14:56.180 --> 01:14:57.180
就是一个对象

01:14:57.180 --> 01:14:58.180
一个空对象

01:14:58.180 --> 01:14:59.180
我想读他的属性

01:14:59.180 --> 01:15:00.180
A

01:15:00.180 --> 01:15:01.180
但是实际上

01:15:01.180 --> 01:15:02.180
这个代码

01:15:02.180 --> 01:15:04.180
是要抱错的

01:15:04.180 --> 01:15:05.180
与法错误

01:15:05.180 --> 01:15:06.180
因为他又把这个玩意

01:15:06.180 --> 01:15:07.180
认为是一个代码断了

01:15:07.180 --> 01:15:09.180
他又认为他是一个代码断了

01:15:09.180 --> 01:15:10.180
突然出现一个

01:15:10.180 --> 01:15:11.180
A

01:15:11.180 --> 01:15:12.180
是啥意思

01:15:12.180 --> 01:15:13.180
他看不懂

01:15:13.180 --> 01:15:14.180
他要抱错

01:15:14.180 --> 01:15:15.180
但是

01:15:15.180 --> 01:15:16.180
如果说你这样子

01:15:16.180 --> 01:15:17.180
他就不抱错了

01:15:18.180 --> 01:15:19.180
把他看成一个整体

01:15:19.180 --> 01:15:20.180
就不抱错了

01:15:21.180 --> 01:15:22.180
这里有个小

01:15:22.180 --> 01:15:23.180
看一下别的

01:15:25.180 --> 01:15:26.180
来个这个吧

01:15:26.180 --> 01:15:29.970
更多了

01:15:29.970 --> 01:15:30.970
你们下来去玩

01:15:30.970 --> 01:15:32.970
按这个思维导图来弄

01:15:32.970 --> 01:15:33.970
好 又来看这个

01:15:34.970 --> 01:15:35.970
这里我把他扩了一下

01:15:35.970 --> 01:15:36.970
扩了一下

01:15:36.970 --> 01:15:37.970
他又不会认为

01:15:37.970 --> 01:15:38.970
他是一个代码断了

01:15:38.970 --> 01:15:39.970
表示一个表达式

01:15:39.970 --> 01:15:40.970
这是个表达式

01:15:40.970 --> 01:15:41.970
那只能是对象了

01:15:41.970 --> 01:15:42.970
一个空对象

01:15:42.970 --> 01:15:43.970
空对象里面的属性

01:15:43.970 --> 01:15:44.970
A 是不是就ND

01:15:45.970 --> 01:15:46.970
是不是就ND犯的

01:15:47.970 --> 01:15:48.970
是不是ND犯的

01:15:48.970 --> 01:15:49.970
前面就是ND犯的

01:15:51.970 --> 01:15:52.970
然后成立一个什么呢

01:15:52.970 --> 01:15:53.970
成立一个

01:15:54.970 --> 01:15:55.970
数组

01:15:55.970 --> 01:15:56.970
好 那么这个惩罚

01:15:56.970 --> 01:15:57.970
是不是数学运算

01:15:57.970 --> 01:15:58.970
数学运算

01:15:58.970 --> 01:15:59.970
特殊情况的排不上了

01:15:59.970 --> 01:16:00.970
对吧 惩罚

01:16:01.970 --> 01:16:02.970
先转换的原式内容再说

01:16:02.970 --> 01:16:03.970
这个玩意

01:16:03.970 --> 01:16:04.970
转换的原式内容

01:16:04.970 --> 01:16:05.970
是不是就是

01:16:06.970 --> 01:16:07.970
空之不串

01:16:07.970 --> 01:16:08.970
好 空之不串

01:16:08.970 --> 01:16:09.970
由于它不是加号

01:16:09.970 --> 01:16:10.970
如果说加号的话

01:16:10.970 --> 01:16:11.970
就之不串凭结了

01:16:11.970 --> 01:16:12.970
它不是加号

01:16:12.970 --> 01:16:13.970
它是乘号

01:16:13.970 --> 01:16:14.970
乘号的话

01:16:14.970 --> 01:16:15.970
只能把它转回来的数字

01:16:15.970 --> 01:16:16.970
就变成0

01:16:16.970 --> 01:16:17.970
那就是ND犯的

01:16:17.970 --> 01:16:18.970
成立0

01:16:18.970 --> 01:16:19.970
那么ND犯的

01:16:19.970 --> 01:16:20.970
也要转换的数字

01:16:20.970 --> 01:16:21.970
好 那就接下来设计到

01:16:21.970 --> 01:16:23.970
ND犯的怎么转换的数字呢

01:16:23.970 --> 01:16:24.970
NAN

01:16:24.970 --> 01:16:27.970
ND犯的转换的数字就是NAN

01:16:27.970 --> 01:16:29.970
那么NAN跟任何数字相乘

01:16:29.970 --> 01:16:30.970
都等于0

01:16:30.970 --> 01:16:31.970
你看着

01:16:31.970 --> 01:16:32.970
NAN跟任何类型的运算

01:16:32.970 --> 01:16:33.970
得到的还是NAN

01:16:33.970 --> 01:16:39.840
所以结果就是NAN

01:16:39.840 --> 01:16:40.840
好 又来

01:16:41.840 --> 01:16:42.840
这个玩意

01:16:42.840 --> 01:16:43.840
好 可能说

01:16:43.840 --> 01:16:45.840
这个玩意是有开发价值的

01:16:45.840 --> 01:16:46.840
你别瞧瞧

01:16:46.840 --> 01:16:48.840
这个玩意是有开发价值的

01:16:51.150 --> 01:16:53.150
这个玩意是啥意思呢

01:16:54.150 --> 01:16:55.150
两个感叹号

01:16:55.150 --> 01:17:01.150
一个两个大国号

01:17:01.150 --> 01:17:02.150
这是什么东西啊

01:17:03.150 --> 01:17:05.150
好 这里又是要运算

01:17:05.150 --> 01:17:06.150
我们来看

01:17:06.150 --> 01:17:07.150
感叹号看到了

01:17:07.150 --> 01:17:08.150
是不是看到了

01:17:08.150 --> 01:17:09.150
逻辑运算

01:17:09.150 --> 01:17:10.150
看到了

01:17:11.150 --> 01:17:12.150
啥都别想

01:17:12.150 --> 01:17:15.150
全都给我弄成布尔再说

01:17:15.150 --> 01:17:16.150
你看

01:17:16.150 --> 01:17:17.150
我们这里实际上是用两段

01:17:17.150 --> 01:17:19.150
首先把它变

01:17:19.150 --> 01:17:20.150
它来一次感叹号

01:17:20.150 --> 01:17:22.150
然后再把这个感叹号的结果

01:17:22.150 --> 01:17:23.150
再来一次感叹号

01:17:23.150 --> 01:17:24.150
有这么个意思

01:17:24.150 --> 01:17:25.150
第一段

01:17:25.150 --> 01:17:27.150
感叹号是不是取反

01:17:27.150 --> 01:17:28.150
那么这个玩意

01:17:28.150 --> 01:17:29.150
不是布尔

01:17:29.150 --> 01:17:30.150
不管你是对象

01:17:30.150 --> 01:17:31.150
还是什么制服处

01:17:31.150 --> 01:17:32.150
数字啊

01:17:32.150 --> 01:17:33.150
全部给我转换的布尔

01:17:33.150 --> 01:17:34.150
怎么转

01:17:34.150 --> 01:17:35.150
看下面转换

01:17:35.150 --> 01:17:36.150
所有的东西

01:17:36.150 --> 01:17:37.150
转换的布尔是怎么转的

01:17:38.150 --> 01:17:39.150
你自己去对吧

01:17:39.150 --> 01:17:40.150
自己去对

01:17:40.150 --> 01:17:41.150
这是个啥

01:17:41.150 --> 01:17:42.150
这是个对象

01:17:42.150 --> 01:17:43.150
对象一定是处

01:17:43.150 --> 01:17:44.150
不管你是数组

01:17:44.150 --> 01:17:45.150
还是什么乱七八糟的玩意

01:17:45.150 --> 01:17:46.150
一定是处

01:17:46.150 --> 01:17:47.150
那么处取反

01:17:47.150 --> 01:17:48.150
是不是变成Force

01:17:48.150 --> 01:17:50.150
是不是变成Force

01:17:51.150 --> 01:17:52.150
好 然后外面

01:17:52.150 --> 01:17:53.150
前面还有一个感叹号

01:17:53.150 --> 01:17:54.150
多了

01:17:54.150 --> 01:17:55.150
有个感叹号取反

01:17:55.150 --> 01:17:56.150
所以变成True

01:17:56.150 --> 01:17:57.150
对吧

01:17:57.150 --> 01:17:58.150
所以得到True

01:17:58.150 --> 01:17:59.150
那么这个玩意

01:17:59.150 --> 01:18:00.150
到底有什么用

01:18:00.150 --> 01:18:01.150
跟我们开发

01:18:01.150 --> 01:18:02.150
到底有什么关系

01:18:02.150 --> 01:18:03.150
很有用

01:18:03.150 --> 01:18:04.150
有的时候

01:18:04.150 --> 01:18:05.150
你写这么一个函数

01:18:05.150 --> 01:18:06.150
当然了

01:18:06.150 --> 01:18:07.150
如果说你做一些简单的开发的话

01:18:07.150 --> 01:18:08.150
可能用不上

01:18:08.150 --> 01:18:09.150
你写一个函数

01:18:09.150 --> 01:18:10.150
这个函数

01:18:10.150 --> 01:18:11.150
可能会有一些

01:18:11.150 --> 01:18:15.720
要传一些参数进来

01:18:15.720 --> 01:18:16.720
你现在要知道

01:18:16.720 --> 01:18:17.720
有一个参数

01:18:17.720 --> 01:18:19.720
到底传没传

01:18:19.720 --> 01:18:20.720
传了

01:18:20.720 --> 01:18:22.720
就认为它是True

01:18:22.720 --> 01:18:23.720
没传

01:18:23.720 --> 01:18:24.720
比方就这个参数吧

01:18:24.720 --> 01:18:25.720
我想知道

01:18:25.720 --> 01:18:27.720
这个参数到底传没传

01:18:27.720 --> 01:18:28.720
传了

01:18:28.720 --> 01:18:29.720
我就认为是True

01:18:29.720 --> 01:18:30.720
没传

01:18:30.720 --> 01:18:31.720
我就认为是Force

01:18:31.720 --> 01:18:32.720
假设

01:18:32.720 --> 01:18:33.720
假设这个参数是个对象

01:18:33.720 --> 01:18:35.720
那我怎么来写这个代码呢

01:18:35.720 --> 01:18:37.720
我可能要做一个判断

01:18:37.720 --> 01:18:39.720
衣服是不是等于啥啥啥

01:18:39.720 --> 01:18:41.720
一个非常简单的调拉式

01:18:41.720 --> 01:18:42.720
就是这个Obs

01:18:42.720 --> 01:18:46.950
意思

01:18:49.950 --> 01:18:50.950
意思

01:18:50.950 --> 01:18:51.950
叫什么呢

01:18:51.950 --> 01:18:52.950
传递

01:18:52.950 --> 01:18:53.950
好像这么多

01:18:54.950 --> 01:18:55.950
开始吧

01:18:57.950 --> 01:18:58.950
那么这里呢

01:18:58.950 --> 01:19:00.950
我就可以通过一个简单的表达式

01:19:00.950 --> 01:19:01.950
就知道这个参数

01:19:01.950 --> 01:19:03.950
可以把它变成一个布尔类型

01:19:03.950 --> 01:19:04.950
看一下

01:19:04.950 --> 01:19:05.950
没事

01:19:05.950 --> 01:19:10.100
我只要传了

01:19:11.100 --> 01:19:13.100
那么它不到99992

01:19:13.100 --> 01:19:14.100
我只要没传

01:19:15.100 --> 01:19:16.100
别说就是OND犯的吧

01:19:16.100 --> 01:19:17.100
到99994

01:19:17.100 --> 01:19:19.100
我就不用去写判断了

01:19:19.100 --> 01:19:21.100
你写判断可不可以

01:19:21.100 --> 01:19:22.100
但这种表达

01:19:22.100 --> 01:19:23.100
更加简洁

01:19:24.100 --> 01:19:25.100
好

01:19:25.100 --> 01:19:26.100
那么这是第一道题

01:19:26.100 --> 01:19:27.100
第二道题

01:19:27.100 --> 01:19:29.100
我们来看腾讯的这道题

01:19:29.100 --> 01:19:30.100
这道题就是

01:19:30.100 --> 01:19:31.100
考验你那个

01:19:31.100 --> 01:19:33.100
两个等号有多么噁心

01:19:33.100 --> 01:19:34.100
所以说以后

01:19:34.100 --> 01:19:35.100
就不要用两个等号了

01:19:35.100 --> 01:19:37.100
我们来看一下有多噁心

01:19:37.100 --> 01:19:38.100
两个等号

01:19:38.100 --> 01:19:39.100
我把这个地方

01:19:39.100 --> 01:19:40.100
干脆就

01:19:40.100 --> 01:19:41.100
代码直接解读吧

01:19:41.100 --> 01:19:43.410
这些东西

01:19:43.410 --> 01:19:45.410
其实你们都不用听我讲

01:19:45.410 --> 01:19:46.410
你们下来去看

01:19:46.410 --> 01:19:47.410
应该都能看得懂

01:19:47.410 --> 01:19:48.410
有了这个思维导徒

01:19:48.410 --> 01:19:49.410
但是我们最好

01:19:49.410 --> 01:19:53.680
再做一些鞏固吧

01:19:53.680 --> 01:19:54.680
这是个比较运算

01:19:54.680 --> 01:19:55.680
零和空置不算比较运算

01:19:55.680 --> 01:19:56.680
比较运算

01:19:56.680 --> 01:19:57.680
看什么

01:19:57.680 --> 01:19:58.680
我们来看一下

01:19:58.680 --> 01:19:59.680
到底是两个等号

01:19:59.680 --> 01:20:00.680
三个等号

01:20:00.680 --> 01:20:01.680
两个等号

01:20:01.680 --> 01:20:02.680
两端内形相同

01:20:02.680 --> 01:20:03.680
相同吗

01:20:03.680 --> 01:20:04.680
不相同

01:20:04.680 --> 01:20:05.680
一个数字

01:20:05.680 --> 01:20:06.680
一个字母圈

01:20:06.680 --> 01:20:07.680
看第二个

01:20:07.680 --> 01:20:08.680
两端是不是都是

01:20:08.680 --> 01:20:09.680
原式内形

01:20:09.680 --> 01:20:10.680
是不是原式内形

01:20:10.680 --> 01:20:11.680
是原式内形

01:20:11.680 --> 01:20:12.680
原式内形

01:20:12.680 --> 01:20:13.680
转换的数字

01:20:13.680 --> 01:20:14.680
之前就知道

01:20:14.680 --> 01:20:15.680
零转了

01:20:15.680 --> 01:20:16.680
你们不用转了

01:20:16.680 --> 01:20:17.680
空置不算

01:20:17.680 --> 01:20:18.680
转换的数字是多少

01:20:18.680 --> 01:20:19.680
是零

01:20:19.680 --> 01:20:20.680
所以说

01:20:20.680 --> 01:20:21.680
第一个

01:20:21.680 --> 01:20:22.680
为处

01:20:22.680 --> 01:20:23.680
想想

01:20:23.680 --> 01:20:24.680
很噁心吧

01:20:24.680 --> 01:20:26.680
打这个玩意儿为处

01:20:27.680 --> 01:20:28.680
来吧

01:20:28.680 --> 01:20:29.680
你是不是等于

01:20:29.680 --> 01:20:30.680
字母圈零呢

01:20:30.680 --> 01:20:31.680
还是一样

01:20:31.680 --> 01:20:32.680
两端都是原式内形

01:20:32.680 --> 01:20:33.680
转换的数字

01:20:33.680 --> 01:20:34.680
那么字母圈

01:20:34.680 --> 01:20:35.680
转数字

01:20:35.680 --> 01:20:36.680
是不是直接把一个

01:20:36.680 --> 01:20:37.680
如果说空置不算

01:20:37.680 --> 01:20:38.680
就是零

01:20:38.680 --> 01:20:39.680
直接把引号去掉

01:20:39.680 --> 01:20:40.680
引号去掉是不是

01:20:40.680 --> 01:20:41.680
还是零

01:20:41.680 --> 01:20:42.680
对吧

01:20:42.680 --> 01:20:43.680
那就没问题

01:20:43.680 --> 01:20:44.680
所以说

01:20:44.680 --> 01:20:45.680
它这个也是

01:20:45.680 --> 01:20:48.250
为真的

01:20:48.250 --> 01:20:49.250
千万不要去

01:20:49.250 --> 01:20:50.250
用两个等号

01:20:50.250 --> 01:20:52.250
然后二是不是等于处呢

01:20:52.250 --> 01:20:53.250
我们来就来看

01:20:53.250 --> 01:20:55.250
二是不是等于处

01:20:55.250 --> 01:20:57.250
两端都是原式内形

01:20:57.250 --> 01:20:58.250
数字

01:20:58.250 --> 01:21:00.250
二

01:21:00.250 --> 01:21:01.250
处讲算数字是多少

01:21:01.250 --> 01:21:03.250
处讲算数字是一

01:21:03.250 --> 01:21:04.250
之前我们已经看到过了

01:21:04.250 --> 01:21:06.250
说的这个是force

01:21:06.250 --> 01:21:08.250
二是不是等于处

01:21:08.250 --> 01:21:09.250
force

01:21:09.250 --> 01:21:14.460
那么二是不是等于force呢

01:21:14.460 --> 01:21:15.460
二是不是等于force呢

01:21:15.460 --> 01:21:16.460
那个force

01:21:16.460 --> 01:21:17.460
转换的数字是零

01:21:17.460 --> 01:21:19.460
所以二也不等于force

01:21:19.460 --> 01:21:20.460
二不等于处

01:21:20.460 --> 01:21:22.460
也不等于force

01:21:22.460 --> 01:21:23.460
然后又来看

01:21:23.460 --> 01:21:24.460
那个force

01:21:24.460 --> 01:21:27.460
是不是等于force呢

01:21:27.460 --> 01:21:29.460
我都快开销了

01:21:29.460 --> 01:21:30.460
然后两端都是

01:21:30.460 --> 01:21:31.460
原式内形

01:21:31.460 --> 01:21:32.460
转换的数字

01:21:32.460 --> 01:21:33.460
然后force

01:21:33.460 --> 01:21:35.460
转换的数字是零

01:21:35.460 --> 01:21:36.460
那个支部车

01:21:36.460 --> 01:21:37.460
转换的数字是什么呢

01:21:37.460 --> 01:21:39.460
是这个只能是NAN

01:21:39.460 --> 01:21:40.460
对吧

01:21:40.460 --> 01:21:41.460
那么这里要看另外一个了

01:21:41.460 --> 01:21:43.460
转换NAN之后

01:21:43.460 --> 01:21:44.460
特殊情况

01:21:44.460 --> 01:21:45.460
两端存在NAN

01:21:45.460 --> 01:21:46.460
一定是force

01:21:46.460 --> 01:21:48.460
说这个玩意儿是force

01:21:48.460 --> 01:21:50.460
这个玩意儿

01:21:50.460 --> 01:21:52.460
这个玩意儿

01:21:52.460 --> 01:21:53.460
这个玩意儿是force

01:21:53.460 --> 01:21:54.460
好

01:21:54.460 --> 01:21:55.460
又来force

01:21:55.460 --> 01:21:59.960
是不是等于零呢

01:21:59.960 --> 01:22:01.960
然后两端都是原式内形

01:22:01.960 --> 01:22:02.960
所以说转换

01:22:02.960 --> 01:22:03.960
转换的什么呢

01:22:03.960 --> 01:22:04.960
转换的那个数字

01:22:04.960 --> 01:22:05.960
force

01:22:05.960 --> 01:22:06.960
转换的数字是零

01:22:06.960 --> 01:22:07.960
零转换的数字呢

01:22:07.960 --> 01:22:09.960
是零

01:22:09.960 --> 01:22:11.960
这个是ok的

01:22:11.960 --> 01:22:12.960
Q

01:22:12.960 --> 01:22:13.960
好 又来force

01:22:13.960 --> 01:22:15.960
是不是等于

01:22:15.960 --> 01:22:17.960
undefined的呢

01:22:17.960 --> 01:22:18.960
对吧

01:22:18.960 --> 01:22:19.960
你把那个思维导渡看多了

01:22:19.960 --> 01:22:21.960
你慢慢都可以脱离它了

01:22:21.960 --> 01:22:22.960
两端都是原式内形

01:22:22.960 --> 01:22:23.960
转换的数字

01:22:23.960 --> 01:22:24.960
force

01:22:24.960 --> 01:22:25.960
转换的数字是零

01:22:25.960 --> 01:22:26.960
转换的数字是多少呢

01:22:26.960 --> 01:22:27.960
看这

01:22:27.960 --> 01:22:30.530
NAN

01:22:30.530 --> 01:22:31.530
那NAN

01:22:31.530 --> 01:22:32.530
两端只要存在

01:22:32.530 --> 01:22:33.530
NAN

01:22:33.530 --> 01:22:34.530
那就是force

01:22:34.530 --> 01:22:35.530
说这个force

01:22:35.530 --> 01:22:37.530
等于undefined

01:22:37.530 --> 01:22:42.500
那就是force

01:22:42.500 --> 01:22:45.500
force是不是等于now呢

01:22:45.500 --> 01:22:47.500
force转换的数字是零

01:22:47.500 --> 01:22:49.500
now转换的数字呢

01:22:49.500 --> 01:22:50.500
也是零

01:22:50.500 --> 01:22:51.500
所以说

01:22:51.500 --> 01:22:53.500
这里呢又是相等的

01:22:53.500 --> 01:22:54.500
这个两个等号

01:22:54.500 --> 01:22:55.500
恶心的要命

01:22:55.500 --> 01:22:58.500
now是不是等于undefined的呢

01:22:58.500 --> 01:23:00.500
为什么呢

01:23:00.500 --> 01:23:01.500
这里有特殊情况

01:23:01.500 --> 01:23:02.500
undefined的和now

01:23:02.500 --> 01:23:04.500
只有与自身比较

01:23:04.500 --> 01:23:06.500
或者是互相比较的时候

01:23:06.500 --> 01:23:08.500
会返回处

01:23:08.500 --> 01:23:10.500
只有与自身比较

01:23:10.500 --> 01:23:11.500
或者是互相比较的时候

01:23:11.500 --> 01:23:12.500
会返回处

01:23:12.500 --> 01:23:13.500
所以说这里返回的又是处

01:23:13.500 --> 01:23:15.500
那最后一个更恶心

01:23:15.500 --> 01:23:16.500
他问你是这个玩意儿

01:23:16.500 --> 01:23:20.840
空格斜杠T

01:23:20.840 --> 01:23:21.840
斜杠R

01:23:21.840 --> 01:23:22.840
斜杠N

01:23:22.840 --> 01:23:23.840
然后等于0

01:23:23.840 --> 01:23:28.790
这里还有一个空格

01:23:28.790 --> 01:23:29.790
那么这里

01:23:29.790 --> 01:23:30.790
两端都是原式内形

01:23:30.790 --> 01:23:31.790
转换的数字

01:23:31.790 --> 01:23:32.790
转换的数字是啥呀

01:23:32.790 --> 01:23:34.790
你看这里规则

01:23:34.790 --> 01:23:36.790
空制服串

01:23:36.790 --> 01:23:37.790
含空白制服

01:23:37.790 --> 01:23:38.790
什么叫空白制服

01:23:38.790 --> 01:23:39.790
制表服

01:23:39.790 --> 01:23:40.790
斜杠T

01:23:40.790 --> 01:23:41.790
回车服

01:23:41.790 --> 01:23:42.790
斜杠R

01:23:42.790 --> 01:23:43.790
换行服

01:23:43.790 --> 01:23:44.790
斜杠N

01:23:44.790 --> 01:23:45.790
都是空白制服

01:23:45.790 --> 01:23:46.790
所以说

01:23:46.790 --> 01:23:47.790
这有前面一串空白制服

01:23:47.790 --> 01:23:48.790
转换的数字

01:23:48.790 --> 01:23:49.790
还是0

01:23:49.790 --> 01:23:50.790
0等于0

01:23:50.790 --> 01:23:52.790
所以说是处

01:23:52.790 --> 01:23:53.790
这就是为什么

01:23:53.790 --> 01:23:55.790
你们以后不要去用那个

01:23:55.790 --> 01:23:56.790
这种两个等号

01:23:56.790 --> 01:23:58.790
就这么一个原因

01:23:58.790 --> 01:23:59.790
好 又来吧

01:23:59.790 --> 01:24:00.790
看这吧

01:24:01.790 --> 01:24:02.790
我就看一个

01:24:02.790 --> 01:24:03.790
就看一个就行了

01:24:03.790 --> 01:24:05.790
这个就这个表老师吧

01:24:05.790 --> 01:24:09.870
NOW加NOW

01:24:09.870 --> 01:24:11.870
首先算加法

01:24:11.870 --> 01:24:12.870
先不着急个等号

01:24:12.870 --> 01:24:13.870
先算加法

01:24:13.870 --> 01:24:15.870
加法的时候

01:24:15.870 --> 01:24:16.870
是不是左右两端

01:24:16.870 --> 01:24:17.870
都得是原式内形

01:24:17.870 --> 01:24:18.870
那都是原式内形

01:24:18.870 --> 01:24:19.870
没问题

01:24:19.870 --> 01:24:20.870
那么原式内形

01:24:20.870 --> 01:24:21.870
又没有制服串的

01:24:21.870 --> 01:24:22.870
转换的数字

01:24:22.870 --> 01:24:23.870
NOW

01:24:23.870 --> 01:24:24.870
转换的数字是0

01:24:24.870 --> 01:24:25.870
这边就是0

01:24:26.870 --> 01:24:27.870
好 那这边又来

01:24:27.870 --> 01:24:28.870
ND犯的

01:24:29.870 --> 01:24:30.870
ND犯的转换的数字

01:24:30.870 --> 01:24:31.870
NN

01:24:33.870 --> 01:24:34.870
ND犯的转换的数字

01:24:35.870 --> 01:24:36.870
NN加NN

01:24:36.870 --> 01:24:37.870
那肯定说还是NN

01:24:38.870 --> 01:24:40.870
两个之间是否相等

01:24:40.870 --> 01:24:41.870
这个规则

01:24:41.870 --> 01:24:43.870
只要有异端有NN

01:24:43.870 --> 01:24:44.870
那么一定不相等

01:24:44.870 --> 01:24:46.870
所以说这个地方为FORCE

01:24:47.870 --> 01:24:51.570
这个表老师为FORCE

01:24:51.570 --> 01:24:52.570
好

01:24:52.570 --> 01:24:53.570
就看下面那道题

01:24:55.570 --> 01:24:56.570
正好听到

01:24:56.570 --> 01:24:57.570
其实我们刚才已经

01:24:57.570 --> 01:24:58.570
演算过了

01:24:58.570 --> 01:24:59.570
对吧

01:24:59.570 --> 01:25:00.570
来看一下吧

01:25:00.570 --> 01:25:02.570
这行动方法一道面是里

01:25:02.570 --> 01:25:03.570
它就是用

01:25:03.570 --> 01:25:05.570
TOOSGUN来玩力

01:25:06.570 --> 01:25:07.570
有两个对象在做什么呢

01:25:07.570 --> 01:25:08.570
首先把这个玩意

01:25:08.570 --> 01:25:09.570
先算出来

01:25:09.570 --> 01:25:10.570
因为这个优先级比较高

01:25:10.570 --> 01:25:12.570
先把它算出来

01:25:12.570 --> 01:25:13.570
那么它算它的时候

01:25:13.570 --> 01:25:14.570
你首先算这个玩意

01:25:15.570 --> 01:25:16.570
OVG2

01:25:16.570 --> 01:25:17.570
先算这个玩意

01:25:17.570 --> 01:25:18.570
那么这个玩意

01:25:18.570 --> 01:25:19.570
出现个感叹号

01:25:19.570 --> 01:25:20.570
感叹号是不是要

01:25:20.570 --> 01:25:21.570
把它变成布尔

01:25:22.570 --> 01:25:23.570
是不是要把它变成布尔

01:25:23.570 --> 01:25:25.570
那么这个玩意变布尔是啥

01:25:26.570 --> 01:25:27.570
要运行TOOSGUN吗

01:25:27.570 --> 01:25:28.570
需要吗

01:25:28.570 --> 01:25:29.570
不需要

01:25:29.570 --> 01:25:30.570
为什么呢

01:25:30.570 --> 01:25:31.570
因为所有内形

01:25:31.570 --> 01:25:32.570
转布尔一步到位

01:25:33.570 --> 01:25:34.570
对象就直接是TOOSGUN

01:25:34.570 --> 01:25:35.570
所以说跟那个

01:25:35.570 --> 01:25:36.570
TOOSGUN有关系吗

01:25:36.570 --> 01:25:37.570
一毛钱关系都没有

01:25:37.570 --> 01:25:38.570
因此这里呢

01:25:38.570 --> 01:25:39.570
就直接是TOOSGUN

01:25:39.570 --> 01:25:40.570
TOOSGUN再把它变成一个

01:25:40.570 --> 01:25:41.570
什么感叹号

01:25:41.570 --> 01:25:42.570
变成一个FORCE

01:25:43.570 --> 01:25:44.570
懂了意思吗

01:25:44.570 --> 01:25:45.570
所以说

01:25:45.570 --> 01:25:46.570
这个单码就直接是一个FORCE

01:25:46.570 --> 01:25:47.570
那么就是前面的

01:25:47.570 --> 01:25:49.570
OVG1加上FORCE

01:25:50.570 --> 01:25:51.570
OVG1是啥玩意

01:25:51.570 --> 01:25:52.570
OVG1

01:25:53.570 --> 01:25:55.570
它做的是加法

01:25:55.570 --> 01:25:56.570
所以说呢

01:25:56.570 --> 01:25:57.570
要转换成原始内形

01:25:57.570 --> 01:25:58.570
那么做加法

01:25:58.570 --> 01:26:00.570
转原始内形的时候

01:26:00.570 --> 01:26:01.570
那么怎么转呢

01:26:02.570 --> 01:26:03.570
这样转

01:26:03.570 --> 01:26:04.570
先调用BIO

01:26:04.570 --> 01:26:05.570
BIO得到结果是什么呢

01:26:05.570 --> 01:26:06.570
得到结果是3

01:26:06.570 --> 01:26:08.570
因为已经拿到原始的值了

01:26:08.570 --> 01:26:09.570
原始是拿到

01:26:09.570 --> 01:26:10.570
不会调用TOOSGUN的

01:26:10.570 --> 01:26:12.570
所以说得到结果就是3

01:26:12.570 --> 01:26:13.570
3加上FORCE

01:26:13.570 --> 01:26:14.570
这些都好了

01:26:14.570 --> 01:26:15.570
FORCE转换成数字0

01:26:15.570 --> 01:26:16.570
于是得到予3加0

01:26:16.570 --> 01:26:19.460
得予3

01:26:19.460 --> 01:26:20.460
解释半天

01:26:22.460 --> 01:26:23.460
对呀

01:26:24.460 --> 01:26:27.860
不错了

01:26:28.860 --> 01:26:29.860
不好意思

01:26:29.860 --> 01:26:30.860
不好意思

01:26:30.860 --> 01:26:32.860
我这里第一个取反算错了

01:26:32.860 --> 01:26:33.860
这个是TOO

01:26:35.860 --> 01:26:36.860
这个地方是FORCE

01:26:36.860 --> 01:26:38.860
就是前面这个是FORCE

01:26:38.860 --> 01:26:39.860
OVG2

01:26:39.860 --> 01:26:40.860
这个是FORCE

01:26:41.860 --> 01:26:42.860
还是一样

01:26:42.860 --> 01:26:43.860
它不会调用TOOSGUN

01:26:43.860 --> 01:26:44.860
调用TOOSGUN的话

01:26:44.860 --> 01:26:45.860
它就算它就不一样了

01:26:45.860 --> 01:26:46.860
那么这个是FORCE

01:26:46.860 --> 01:26:47.860
这个是FORCE

01:26:47.860 --> 01:26:48.860
然后在前面

01:26:48.860 --> 01:26:49.860
再加一个感叹号

01:26:49.860 --> 01:26:50.860
是TOO

01:26:50.860 --> 01:26:51.860
这里是对象

01:26:51.860 --> 01:26:52.860
只要记住

01:26:52.860 --> 01:26:53.860
这里是对象的话

01:26:53.860 --> 01:26:54.860
经过两个感叹号

01:26:54.860 --> 01:26:55.860
已经得到的结果一定是TOO

01:26:55.860 --> 01:26:56.860
一定是TOO

01:26:56.860 --> 01:26:57.860
那么这相当于是

01:26:57.860 --> 01:26:58.860
3加上0

01:27:00.860 --> 01:27:01.860
得到的结果是4

01:27:01.860 --> 01:27:02.860
注意啊

01:27:02.860 --> 01:27:03.860
这个TOOSGUN

01:27:03.860 --> 01:27:05.860
它是不产与运算的

01:27:05.860 --> 01:27:06.860
这个TOOSGUN

01:27:06.860 --> 01:27:07.860
是不产与运算的

01:27:07.860 --> 01:27:08.860
没看见没

01:27:08.860 --> 01:27:12.510
它没有打赢出这句话

01:27:13.510 --> 01:27:14.510
除了这道题

01:27:14.510 --> 01:27:15.510
有了咱们的

01:27:15.510 --> 01:27:16.510
这个思维导图

01:27:16.510 --> 01:27:17.510
剩下的事情

01:27:17.510 --> 01:27:18.510
就是你小心一点

01:27:18.510 --> 01:27:19.510
不要看错题

01:27:19.510 --> 01:27:21.510
不要像我这样子

01:27:21.510 --> 01:27:23.510
看错一个符号

01:27:23.510 --> 01:27:25.510
或者是少算了一个符号

01:27:25.510 --> 01:27:26.510
剩下的事情就小心了

01:27:26.510 --> 01:27:27.510
就没有任何问题了

01:27:29.510 --> 01:27:30.510
有朋友在问

01:27:30.510 --> 01:27:31.510
你们可以给我出题

01:27:31.510 --> 01:27:32.510
你们现在

01:27:32.510 --> 01:27:33.510
图图

01:27:33.510 --> 01:27:35.510
ざー是多少

01:27:35.510 --> 01:27:36.510
FORCE

01:27:36.510 --> 01:27:38.510
就 love 两个这个号箱

01:27:38.510 --> 01:27:39.510
别叫

01:27:40.510 --> 01:27:41.510
要想装成的原� Der

01:27:41.510 --> 01:27:42.510
不想

01:27:42.510 --> 01:27:43.510
起这种名字

01:27:43.510 --> 01:27:44.510
那么

01:27:44.510 --> 01:27:45.510
powder

01:27:45.510 --> 01:27:47.510
方式

01:27:48.510 --> 01:27:52.720
习姿

01:27:58.300 --> 01:27:59.300
缓

01:28:04.420 --> 01:28:05.420
何文

01:28:05.420 --> 01:28:06.520
直有

01:28:07.520 --> 01:28:08.420
字

01:28:10.420 --> 01:28:11.420
卢

01:28:11.420 --> 01:28:12.420
卢

01:28:13.420 --> 01:28:38.420
特殊情况,安迪凡德和拉奥只有与自身比较的时候才会返回处,其他的比较都会返回Force,他不是前面那个规则了,他不是前面那个规则了,他是一个特殊情况了。

01:28:38.420 --> 01:29:08.420
拉奥和安迪凡德只有与自身比较或者是相互比较的时候才会返回处,所以说你会发现Force等于拉奥吗?Force,处等于拉奥吗?Force,0等于拉奥吗?Force,1等于拉奥吗?Force,懂了吗?0等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪凡德吗?Force,1等于安迪

01:29:08.420 --> 01:29:19.420
Force等于安迪凡德吗?Force,2等于安迪凡德吗?Force,安迪凡德只有与自身比较或者是与拉奥比较的时候才会返回处

01:29:19.420 --> 01:29:30.420
注意这是2个等号啊,3个等号就没有这些乱七八糟的问题了啊,3个等号极其简单你看一下就知道了,内形和直必须相同,否则的话就一定是Force

01:29:30.420 --> 01:29:51.310
只有一种特殊情况,两张存在NNN已经是Force,没有其他的了,两个等号是特别恶心的啊,特别恶心,但是你首先你根据我这个思维老徒来说看,第二个不要像我这样子看漏了啊,不要忘记特殊情况看漏了,就没啥了,就没啥了

01:29:51.310 --> 01:30:04.310
希望今天晚上我们学了之后,同学们在群里边多来一点这种提议啊,你们自己去创造一些怎么恶心怎么来,反复的去验证咱们这个过程

01:30:04.310 --> 01:30:10.310
放心啊,这个过程写的肯定是没有什么问题的,我都是按照官方文道把中介出来的

01:30:11.310 --> 01:30:40.620
好了,今天的直视录分我们就讲完了,讲了两点,一个是职合引用,职合引用抓住关键点,就是这个内存图,内存图画熟练了,你就可以脱离这个内存图了,就可以像我上课那样子,直接用哪一个槽膏纸记一下,但是一定不要忘记,之后做面试题的时候不要忘记在槽膏纸上画一画,记一记

01:30:40.620 --> 01:30:50.620
否则的话特别容易出错,第二就是运算规则,按照咱们的思维导图一步一步去推,但是不要像我上课那样子啊,看仔细一点

01:30:50.620 --> 01:30:57.620
这避免出错,因为我思维导图没问题,这个题只要出了没问题,那么结果就一定是,应该是对的

01:30:57.620 --> 01:31:00.620
那如果说错的话,就可能有些地方看漏了

