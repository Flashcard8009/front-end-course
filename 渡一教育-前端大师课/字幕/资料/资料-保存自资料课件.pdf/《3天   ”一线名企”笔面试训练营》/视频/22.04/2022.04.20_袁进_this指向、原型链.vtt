WEBVTT

00:00.000 --> 00:06.000
好 咱们集团到了最后一天了

00:06.000 --> 00:13.000
说一下 首先在同学们帮袁老师在群里边呼吁一下

00:13.000 --> 00:17.000
让同学们过来上课 有始有终

00:17.000 --> 00:22.000
我们有三天时间也不长 坚持下去

00:22.000 --> 00:26.000
这三天的内容呢

00:26.000 --> 00:30.000
实话实说 我们在后期的课程里边

00:30.000 --> 00:33.000
凡是涉及到咱们这三天的内容啊

00:33.000 --> 00:37.000
其实三天时间肯定是吸收不完的

00:37.000 --> 00:44.000
大部分同学都可能需要至少一周的时间去吸收这一部分知识

00:44.000 --> 00:49.000
但是毕竟是集训营 也只有三天

00:49.000 --> 00:55.000
所以我想着吧 同学们既然来到这集训营

00:55.000 --> 01:01.000
大部分同学都是对技术有追求的 至少对薪资是有追求的同学

01:01.000 --> 01:04.000
那么这对问同学呢 我尽量给你们多给你们一点东西啊

01:04.000 --> 01:08.000
多给一点干货 但是不是说这三天的内容

01:08.000 --> 01:11.000
你们只需要三天时间就可以搞得定的

01:11.000 --> 01:15.000
下来过后 如果你觉得这一块东西还比较模糊的话

01:15.000 --> 01:19.000
怎么办 看回放 看笔记 看我的课件

01:19.000 --> 01:24.000
或者是看咱们的底面试题 好好的去消化一下

01:24.000 --> 01:30.000
像我们这个行业呢 认真听讲 老师讲是一方面

01:30.000 --> 01:34.000
另一方面呢 也需要同学们自己去操作一下

01:34.000 --> 01:38.000
我常常打一些比方说

01:38.000 --> 01:43.000
我们学技术开发 老师是起个什么样的作用呢

01:43.000 --> 01:47.000
老师好像就是健身房那边的私教一样

01:47.000 --> 01:51.000
他告诉你一个标准的动作应该怎么去做

01:51.000 --> 01:56.000
正确的训练方式应该是什么 科学的训练方式应该是什么

01:56.000 --> 02:00.000
但是呢 你听懂了之后没用啊 你还得自己去操作

02:00.000 --> 02:05.000
你自己去体验 也好必说我们去学一些厨艺 对吧

02:05.000 --> 02:08.000
做一些手工 老师会告诉你这个东西该怎么做

02:08.000 --> 02:12.000
但是呢 最终还是要你自己去亲自的去做一下

02:12.000 --> 02:16.000
去分析一下 去想一下 这样子才能达到最好的学习效果

02:16.000 --> 02:21.500
不能光去听 光去听的话 效果是很不好的

02:21.500 --> 02:24.500
好 老我这就直接开了吧

02:24.500 --> 02:31.200
今天晚上我们讲另外两颗知识 一个是圆形链

02:31.200 --> 02:36.200
一个是Z的指向 这个两颗知识基本上是

02:36.200 --> 02:41.200
前端的笔面是必考的内容

02:41.200 --> 02:45.200
无论是大厂小厂 都会考这两方面的内容

02:45.200 --> 02:51.200
对于初学者而言 这两方面内容确实是有一点难度

02:51.200 --> 02:54.200
但是也是必须要经历的

02:54.200 --> 02:57.200
这两方面的内容还不能说像之前的

02:57.200 --> 03:02.200
像我们昨天讲的那些什么作用预念啊 计算规则啊

03:02.200 --> 03:06.200
还有那个一些东西 他可以放到后边

03:06.200 --> 03:09.200
笔包啊 像这些东西 可以放到后边再学习

03:09.200 --> 03:12.200
但是有一些内容的话 尽管它很难

03:12.200 --> 03:15.200
它也得在前边把它搞定

03:15.200 --> 03:19.200
其实我们整个纪念式的学习 就是我们整个前端的学习

03:19.200 --> 03:24.020
它大概的难度曲线就是这个样子的

03:24.020 --> 03:29.020
只要你过了这个山峰 就没有太多的难度了

03:29.020 --> 03:32.020
那前边说啥呢 前边是ATM和CSS

03:32.020 --> 03:38.020
介石就在这一块 特别是介石的前期学习就在这一块

03:38.020 --> 03:43.020
包括什么循环 数组 对象 函数 这些比较麻烦的地方

03:43.020 --> 03:47.020
包括一些核心的概念 像什么圆形链Z是指向

03:47.020 --> 03:49.020
这些玩意儿都在这一里

03:49.020 --> 03:53.020
后边反而同学们觉得可能比较难的地方

03:53.020 --> 03:58.020
像什么多么操作啊 什么各种对象里边的各种方法

03:58.020 --> 04:01.020
什么制服圈里边各种方法 日期里边各种方法

04:01.020 --> 04:05.020
难度是非常之低的 它没有什么难度的

04:05.020 --> 04:07.020
如果说你觉得这一块有难度

04:07.020 --> 04:09.020
往往是在这一块出了问题了

04:09.020 --> 04:13.020
新问题加旧问题一起跑到这一块来了

04:13.020 --> 04:16.020
所以呢 整个前端的学习就是这样子

04:16.020 --> 04:20.020
你唯一或者说你非常需要重视的地方

04:20.020 --> 04:24.020
也就是在这个区域 这个区域呢

04:24.020 --> 04:27.020
是需要我们做很多很多的工作

04:27.020 --> 04:29.020
才能去搞得定的啊

04:29.020 --> 04:32.020
好 说回来啊 圆形链

04:32.020 --> 04:34.020
那么什么叫圆形链呢

04:34.020 --> 04:36.020
你要了解什么叫圆形链

04:36.020 --> 04:39.020
你得首先知道什么叫圆形

04:39.020 --> 04:42.020
因为这个链啊 它就是一个链条

04:42.020 --> 04:44.020
圆形形成了链条

04:44.020 --> 04:46.020
所以你得首先知道什么叫圆形

04:46.020 --> 04:48.020
什么叫圆形呢 加碑有一段代码

04:48.020 --> 04:53.400
大家看一下啊 这段代码

04:53.400 --> 04:56.400
这段是看上去就是有一个构造函数

04:56.400 --> 04:59.400
然后给它传了一个两个参数

04:59.400 --> 05:01.400
我想问一下啊

05:01.400 --> 05:03.400
这里边有没有同学不知道

05:03.400 --> 05:04.400
什么叫构造函数的

05:04.400 --> 05:11.910
如果说不知道的话 打个一

05:11.910 --> 05:13.910
有没有同学不知道的

05:13.910 --> 05:16.910
都知道是吧 OK

05:16.910 --> 05:17.910
那么这次一个构造函数

05:17.910 --> 05:19.910
传了两个参数进来

05:19.910 --> 05:21.910
然后我把它就一个什么

05:21.910 --> 05:23.910
一个姓一个名

05:23.910 --> 05:25.910
把它保存到对象的属性里边去了

05:25.910 --> 05:28.910
然后我给它加了一个属性叫Fulling

05:28.910 --> 05:31.910
它表示姓和名拼接

05:31.910 --> 05:33.910
中间加了一个空格

05:33.910 --> 05:35.910
然后呢 这里写了这么一个东西

05:35.910 --> 05:37.910
User的Prototype

05:37.910 --> 05:38.910
然后一个东西

05:38.910 --> 05:40.910
好像给某一个东西在设置属性

05:40.910 --> 05:41.910
看到没

05:41.910 --> 05:43.910
给什么东西设置属性

05:43.910 --> 05:44.910
给这个玩意儿

05:44.910 --> 05:46.910
这个玩意儿到底是啥啊

05:46.910 --> 05:48.910
给它设置了一个函数

05:48.910 --> 05:50.910
这里又来一次

05:50.910 --> 05:52.910
给它某一个东西设置了一个属性

05:52.910 --> 05:54.910
然后呢 设置了一个函数

05:54.910 --> 05:56.910
这两个函数还是比较好看出来的

05:56.910 --> 05:57.910
做什么事呢

05:57.910 --> 05:58.910
就是打个招呼

05:58.910 --> 06:00.910
一个是用中文的方式

06:00.910 --> 06:02.910
一个是用英文的方式

06:02.910 --> 06:06.220
然后接下来我又使用了

06:06.220 --> 06:08.220
这种方式来调用函数一个New

06:08.220 --> 06:10.220
去调用一个User函数

06:10.220 --> 06:12.220
这是个函数嘛

06:12.220 --> 06:14.220
对吧 传了两个参数进去

06:14.220 --> 06:16.220
那加了这个New又是什么意思呢

06:17.220 --> 06:18.220
我还会发现

06:18.220 --> 06:19.220
这个产生了一个东西

06:19.220 --> 06:20.220
这个东西里边

06:20.220 --> 06:21.220
又可以调用这个say hi

06:21.220 --> 06:22.220
看到半天

06:22.220 --> 06:23.220
这个代码的可能

06:23.220 --> 06:25.220
对于很多同学而言

06:25.220 --> 06:27.220
是

06:27.220 --> 06:30.220
有一些奇奇怪怪的东西在里边

06:30.220 --> 06:33.220
那么我们接下来就来解释

06:33.220 --> 06:36.220
这段代码它到底发生了什么事

06:36.220 --> 06:38.220
这个图

06:38.220 --> 06:40.220
下面我们用了一张图

06:40.220 --> 06:42.220
来描述这段代码

06:42.220 --> 06:43.220
它到底在说什么

06:43.220 --> 06:45.220
我稍微把它说小一点

06:47.220 --> 06:49.220
好 放这

06:49.220 --> 06:50.220
我们可以看到

06:50.220 --> 06:53.220
我们这里先看这个代码

06:53.220 --> 06:55.220
New了一个User

06:55.220 --> 06:59.220
然后把它保存到了变量U1里边

06:59.220 --> 07:02.220
这里又New了一个User

07:02.220 --> 07:06.220
然后把它保存到变量U2里边

07:06.220 --> 07:07.220
看到没 是不是这两个代码

07:07.220 --> 07:08.220
我们先看这

07:08.220 --> 07:10.220
那么这两个代码实际上是什么意思呢

07:10.220 --> 07:13.220
我们User是一个构造函数

07:13.220 --> 07:15.220
构造函数是不是用来创建对象的

07:16.220 --> 07:17.220
怎么来创建对象

07:17.220 --> 07:19.220
通过一个New关键字

07:19.220 --> 07:20.220
就可以创建对象

07:20.220 --> 07:22.220
于是我们这里创建了两个对象

07:22.220 --> 07:25.220
U1和U2

07:25.220 --> 07:28.220
两个关键字6

07:28.220 --> 07:30.220
这两个对象里边有什么属性呢

07:30.220 --> 07:32.220
我们就要看构造函数里边

07:32.220 --> 07:33.220
是怎么写的了

07:33.220 --> 07:35.220
就看它里边是怎么写的了

07:35.220 --> 07:37.220
经过这个函数的运行

07:37.220 --> 07:39.220
我们会往个对象里边

07:39.220 --> 07:41.220
放了一个属性Forsename

07:41.220 --> 07:43.220
放了另外一个属性Narsename

07:43.220 --> 07:45.220
再放了一个属性Forname

07:45.220 --> 07:48.220
于是这两个对象里边是有三个属性

07:48.220 --> 07:51.220
每个对象都有自己的三个属性

07:51.220 --> 07:53.220
现在我们明白了

07:53.220 --> 07:57.220
这两句代码就是在创建对象

07:57.220 --> 07:59.220
然后经过构造函数之后

07:59.220 --> 08:02.220
它就往里边加了三个属性

08:02.220 --> 08:04.220
这一份没问题吧

08:04.220 --> 08:05.220
这一份没问题

08:05.220 --> 08:08.220
你们懂构造函数的话就比较方便了

08:08.220 --> 08:12.500
然后我们再往下看

08:12.500 --> 08:14.500
User有一个叫做

08:14.500 --> 08:16.500
User是函数本身

08:16.500 --> 08:18.500
它有一个属性叫做Prototype

08:18.500 --> 08:21.500
这个属性翻译过来的话就是圆形

08:21.500 --> 08:24.500
这里有一个规则需要大家记住

08:24.500 --> 08:28.500
就是所有的函数

08:28.500 --> 08:32.500
它都有一个圆形对象

08:32.500 --> 08:33.500
Prototype

08:33.500 --> 08:35.500
每一个函数都有

08:35.500 --> 08:37.500
并不是说我只有构造函数才有

08:37.500 --> 08:41.500
每一个函数它都会有一个Prototype

08:41.500 --> 08:42.500
这么一个对象

08:42.500 --> 08:44.500
这个对象是什么东西呢

08:44.500 --> 08:45.500
它就是一个空对象

08:45.500 --> 08:48.500
你可以把它理解为就是一个空对象

08:48.500 --> 08:50.500
我们如何来印证这一点呢

08:50.500 --> 08:52.500
我打开一个浏览器

08:52.500 --> 08:55.500
它的控制台比方说

08:55.500 --> 08:58.500
我们随便的去写一个函数

08:58.500 --> 09:00.500
方形

09:00.500 --> 09:02.500
这点是一个函数吧

09:02.500 --> 09:06.500
那么A里边A是一个函数

09:06.500 --> 09:10.500
但是函数的本质也是对象

09:10.500 --> 09:11.500
知道吧

09:11.500 --> 09:16.500
函数的本质是对象

09:16.500 --> 09:19.500
这跟别的语言有一些区别

09:19.500 --> 09:20.500
这也就是语言里面

09:20.500 --> 09:23.500
函数是一等公鸣

09:23.500 --> 09:26.500
所以它的操作方式跟对象本质是一样的

09:26.500 --> 09:28.500
也就是说我可以意味着啥呢

09:28.500 --> 09:31.500
我可以意味着往里边加属性K等于1

09:31.500 --> 09:32.500
你看把它当成对象来使用

09:32.500 --> 09:34.500
可不可以可以

09:34.500 --> 09:36.500
接得122随便写

09:36.500 --> 09:37.500
然后你可以得到

09:37.500 --> 09:39.500
这个对象里面有个属性K

09:39.500 --> 09:41.500
这对象里面有个属性K

09:41.500 --> 09:42.500
看那边

09:42.500 --> 09:43.500
是就是这样子的

09:43.500 --> 09:47.500
所以函数的本质它就是一个对象

09:47.500 --> 09:49.500
这在我们好像在第一天的课程里边

09:49.500 --> 09:50.500
也给大家提过的

09:50.500 --> 09:52.500
像什么

09:52.500 --> 09:54.500
我们介石里面分成两种类型

09:54.500 --> 09:55.500
一个是原始类型

09:55.500 --> 09:57.500
一个是引用类型

09:57.500 --> 09:59.500
引用类型只有一个就是对象

09:59.500 --> 10:01.500
因为函数的数组

10:01.500 --> 10:03.500
它们都是对象

10:03.500 --> 10:05.500
函数的本质就是对象

10:05.500 --> 10:07.500
函数跟对象有没有区别

10:07.500 --> 10:09.500
有一些区别

10:09.500 --> 10:10.500
最本质的区别就是

10:10.500 --> 10:12.500
函数可以调用对象不能调用

10:12.500 --> 10:14.500
函数你可以用这种方式

10:14.500 --> 10:15.500
不要用它

10:15.500 --> 10:17.500
但是对象的普通对象就不能

10:17.500 --> 10:20.500
其他的没有什么区别

10:20.500 --> 10:23.500
那么这个S是一个函数

10:23.500 --> 10:25.500
我们刚才有个结论是什么

10:25.500 --> 10:28.500
每一个函数它都会自带

10:28.500 --> 10:30.500
天生自带一个属性

10:30.500 --> 10:33.500
叫做Prototype

10:33.500 --> 10:35.500
这个属性是什么东西呢

10:35.500 --> 10:38.500
是一个普通对象

10:38.500 --> 10:40.500
你看这个玩意不就是个对象

10:40.500 --> 10:43.500
一个普通对象展开它之后

10:43.500 --> 10:45.500
你会看到它里边没有什么属性

10:45.500 --> 10:46.500
它倒是有一个属性

10:46.500 --> 10:48.500
这个属性都不用去管它

10:48.500 --> 10:50.500
至少现在不用去管它

10:50.500 --> 10:51.500
这个玩意就不用管了

10:51.500 --> 10:53.500
这个玩意我以后要说的

10:53.500 --> 10:56.500
你可以认为它就是一个空对象

10:56.500 --> 10:58.500
里边没东西

10:58.500 --> 11:01.500
然后我们回到这张图来

11:01.500 --> 11:04.500
User它写了这个函数之后

11:04.500 --> 11:05.500
由于它是一个对象

11:05.500 --> 11:07.500
所以说它自带一个属性

11:07.500 --> 11:08.500
叫Prototype

11:08.500 --> 11:09.500
这是什么

11:09.500 --> 11:10.500
这是一个普通对象

11:10.500 --> 11:12.500
它不是函数

11:12.500 --> 11:14.500
我现在框这一部分不是函数

11:14.500 --> 11:16.500
它是一个普通对象

11:16.500 --> 11:18.500
那我们可不可以往普通对象里边

11:18.500 --> 11:19.500
加属性啊

11:19.500 --> 11:20.500
是不是可以

11:20.500 --> 11:23.500
我加了一个C hi

11:23.500 --> 11:25.500
又加了一个C hi e n

11:25.500 --> 11:27.500
English

11:27.500 --> 11:28.500
于是呢

11:28.500 --> 11:30.500
它这个对象里边

11:30.500 --> 11:32.500
是不是加了这两个东西呢

11:32.500 --> 11:34.500
加了这两个了

11:34.500 --> 11:35.500
看到没

11:35.500 --> 11:37.500
两个都是函数

11:37.500 --> 11:39.500
于是让我们至少现在看懂了

11:39.500 --> 11:41.500
这个结构了

11:41.500 --> 11:44.500
一个函数它有一个圆形对象

11:44.500 --> 11:46.500
这些对象有啥用啊别着急

11:46.500 --> 11:50.130
一个函数有一个圆形对象

11:50.130 --> 11:53.130
里边可以自由的放置一些东西

11:53.130 --> 11:54.130
随便放

11:54.130 --> 11:55.130
就像一个储物间一样

11:55.130 --> 11:57.130
你往里边扔东西就完事了

11:57.130 --> 11:59.130
这个函数呢

11:59.130 --> 12:01.130
你也可以把它当成斗罩函数

12:01.130 --> 12:02.130
来用6来调用

12:02.130 --> 12:05.130
这样子可以创建很多的对象

12:05.130 --> 12:06.130
通过的构造函数

12:06.130 --> 12:08.130
可以创建一些别的对象

12:08.130 --> 12:11.130
U1U2

12:11.130 --> 12:14.130
好 接下来再往下看

12:14.130 --> 12:18.130
我们现在要解释这个东西到底是啥

12:18.130 --> 12:20.130
这里又有一个规则了

12:20.130 --> 12:25.130
就是通过这个6关键字

12:25.130 --> 12:28.130
通过这个6关键字

12:28.130 --> 12:31.130
去雕用一个函数

12:31.130 --> 12:34.130
创建了一个对象

12:34.130 --> 12:36.130
这个时候解释

12:36.130 --> 12:38.130
它会自动的去完成一件事

12:38.130 --> 12:39.130
你不用做任何操作

12:39.130 --> 12:41.130
它自动完成的

12:41.130 --> 12:45.130
就是让这个对象里边

12:45.130 --> 12:47.130
有一个特殊的属性

12:47.130 --> 12:49.130
这个属性非常特殊

12:49.130 --> 12:51.130
它的属性名字叫做两个下滑线

12:51.130 --> 12:53.130
现在名字好像改了

12:53.130 --> 12:55.130
但是显示的时候好像改了

12:55.130 --> 12:57.130
但是我们就可以用这种名字来写

12:57.130 --> 12:59.130
两个下滑线

12:59.130 --> 13:01.130
两个下滑线结尾

13:01.130 --> 13:03.130
中间一个叫做proto

13:03.130 --> 13:05.130
一个非常特殊的

13:05.130 --> 13:07.130
这个东西其实叫做内部属性

13:07.130 --> 13:10.130
也是最好不要自己在单码中使用的

13:10.130 --> 13:12.130
尽管现在单码还开放给你使用

13:12.130 --> 13:14.130
但是现在官方已经建议你

13:14.130 --> 13:16.130
不要去使用这个属性

13:16.130 --> 13:18.130
但它确实存在

13:18.130 --> 13:20.130
它会可以自动生成一个这么一个属性

13:20.130 --> 13:22.130
这个属性还有一个名字

13:22.130 --> 13:25.130
叫做引式元形

13:25.130 --> 13:31.490
引式元形

13:32.490 --> 13:34.490
刚才我们看到韩数

13:34.490 --> 13:36.490
每个韩数都有元形

13:36.490 --> 13:39.490
这个玩意儿它叫引式元形

13:39.490 --> 13:41.490
这个引式元形它是一个属性

13:41.490 --> 13:43.490
它指向谁呢

13:43.490 --> 13:45.490
它指向的是

13:45.490 --> 13:48.490
它指向的是

13:48.490 --> 13:50.490
韩数的元形

13:50.490 --> 13:51.490
就这个玩意儿

13:51.490 --> 13:54.490
它指向的是这个韩数的元形

13:54.490 --> 13:58.570
好好体会一下

13:58.570 --> 14:00.570
它为什么指向的是这个韩数的元形

14:00.570 --> 14:02.570
是因为是这个对象

14:02.570 --> 14:05.570
是通过New

14:05.570 --> 14:08.570
这个韩数创建出来的

14:08.570 --> 14:10.570
所以它的引式元形

14:10.570 --> 14:13.570
会自动的指向

14:13.570 --> 14:15.570
这个韩数的元形

14:15.570 --> 14:19.650
那么现在我们有了一个

14:19.650 --> 14:21.650
初步的感觉了

14:21.650 --> 14:22.650
再总结一下

14:22.650 --> 14:24.650
韩数都会自带一个元形对象

14:24.650 --> 14:26.650
它是个普通对象

14:26.650 --> 14:28.650
你不可以放任何东西

14:28.650 --> 14:30.650
韩数可以通过New来调用

14:30.650 --> 14:33.650
会创建一个新的对象

14:33.650 --> 14:34.650
这个新的对象

14:34.650 --> 14:35.650
它有一个引式元形

14:35.650 --> 14:37.650
会自动的指向

14:37.650 --> 14:39.650
韩数的元形

14:39.650 --> 14:40.650
好

14:40.650 --> 14:43.650
那么这里有什么用呢

14:43.650 --> 14:45.650
这有什么用呢

14:45.650 --> 14:47.650
那么这里又会产生一个规则

14:47.650 --> 14:49.650
就是

14:49.650 --> 14:51.650
当我们去使用一个对象

14:51.650 --> 14:53.650
成员的时候

14:53.650 --> 14:54.650
比方说U1

14:54.650 --> 14:56.650
我要使用它的一个成员

14:56.650 --> 14:58.650
叫做first name

14:58.650 --> 14:59.650
所以找到这个玩意儿

14:59.650 --> 15:00.650
这个没问题吧

15:00.650 --> 15:01.650
但是如果说

15:01.650 --> 15:03.650
我使用的成员叫做say hi

15:03.650 --> 15:05.650
比方你看这

15:05.650 --> 15:07.650
我用U1调用这个say hi

15:07.650 --> 15:09.650
那么这个时候

15:09.650 --> 15:11.650
U1它自己有没有这个属性吗

15:11.650 --> 15:13.650
它没有

15:13.650 --> 15:14.650
没有怎么办呢

15:14.650 --> 15:15.650
它会自动的在

15:15.650 --> 15:18.650
引式元形上去找

15:18.650 --> 15:19.650
也找到了

15:19.650 --> 15:21.650
这里是不是有say hi

15:21.650 --> 15:23.650
于是这个代码是有效的

15:23.650 --> 15:24.650
同学们

15:24.650 --> 15:25.650
这个代码是有效的

15:25.650 --> 15:26.650
为什么有效

15:26.650 --> 15:28.650
因为它可以使用

15:28.650 --> 15:30.650
引式元形它的东西

15:30.650 --> 15:32.650
它自动寻找的

15:32.650 --> 15:34.650
好,咱们来试一下

15:34.650 --> 15:36.650
用个代码直接来运行看一下

15:36.650 --> 15:38.650
肯定是没问题的

15:38.650 --> 15:41.650
比方说我们这里建立一个

15:41.650 --> 15:43.650
1.js

15:43.650 --> 15:45.650
好,就这个代码

15:45.650 --> 15:46.650
你看我们这句话

15:46.650 --> 15:47.650
如果说

15:47.650 --> 15:49.650
跟我们刚才理论不相符的话

15:49.650 --> 15:51.650
那么这个代码是要抱错的

15:51.650 --> 15:52.650
为什么

15:52.650 --> 15:54.650
因为U1上边是没有

15:54.650 --> 15:56.650
这个say hi这个属性的

15:56.650 --> 15:57.650
是没有这个say hi的

15:57.650 --> 15:58.650
它有first name

15:59.650 --> 16:01.650
它没有这个say hi

16:01.650 --> 16:03.650
但是它哪里有呢

16:03.650 --> 16:06.650
它的引式元形上有

16:06.650 --> 16:13.670
把这个图再解过来

16:13.670 --> 16:15.670
哪里有,是不是这里有

16:15.670 --> 16:17.670
而这里有一个引式元形

16:17.670 --> 16:18.670
会指过来

16:18.670 --> 16:19.670
好,我们来看一下

16:19.670 --> 16:21.670
它能不能运行成功

16:21.670 --> 16:22.670
运行

16:22.670 --> 16:23.670
你会发现

16:23.670 --> 16:24.670
这两个函数都能得到

16:24.670 --> 16:26.670
正确的运行

16:26.670 --> 16:27.670
多了

16:27.670 --> 16:28.670
好,那么这是

16:28.670 --> 16:30.670
我们一个初步的认识

16:30.670 --> 16:31.670
我们会认识到

16:31.670 --> 16:33.670
原形引式元形

16:33.670 --> 16:34.670
普通对象

16:34.670 --> 16:35.670
通过韩式中间的对象

16:35.670 --> 16:37.670
到底是怎么回事了

16:37.670 --> 16:39.670
好,咱们接着往下看

16:39.670 --> 16:45.390
什么叫做原形链

16:45.390 --> 16:47.390
这里有一些

16:47.390 --> 16:52.390
有一个关键的理论

16:52.390 --> 16:54.390
你把这个认识清楚了

16:54.390 --> 16:56.390
其实你后面都可以推倒出来了

16:56.390 --> 16:58.390
我们整个原形链

16:58.390 --> 17:00.390
最终会化成这么一张图

17:00.390 --> 17:02.390
化出来就是这么一张图

17:02.390 --> 17:04.390
就这张图

17:04.390 --> 17:06.390
但是这张图

17:06.390 --> 17:07.390
同学们不需要去记

17:07.390 --> 17:08.390
你也记不住

17:08.390 --> 17:09.390
这里边这么多箭头

17:09.390 --> 17:11.390
这么多东西你记不住的

17:11.390 --> 17:13.390
但是我告诉同学们

17:13.390 --> 17:15.390
你只要理解到前面的东西

17:15.390 --> 17:17.390
这张图你是可以自己推倒出来的

17:17.390 --> 17:19.390
自己就推倒

17:19.390 --> 17:21.390
好,我们来看一下这里

17:21.390 --> 17:23.390
有一个重要的理论就是

17:23.390 --> 17:25.390
所有的对象

17:25.390 --> 17:27.390
都是通过6一个

17:27.390 --> 17:28.390
韩数的方式

17:28.390 --> 17:30.390
创建的

17:30.390 --> 17:32.390
那有时候不对

17:32.390 --> 17:34.390
你怎么能这样说呢

17:34.390 --> 17:36.390
比方说我们平时写对象怎么写的

17:36.390 --> 17:38.390
我们平时写对象是这样写的

17:38.390 --> 17:42.390
那你说我哪里使用的6呢

17:42.390 --> 17:44.390
我哪里使用的6呢

17:44.390 --> 17:45.390
没必没有对吧

17:45.390 --> 17:47.390
我给他写一些属性

17:47.390 --> 17:51.390
实际上这是对象的减变写法

17:51.390 --> 17:53.390
它实际上写的是什么呢

17:53.390 --> 17:55.390
实际上它的代码是这样子的

17:55.390 --> 17:58.390
6的一个object

17:59.390 --> 18:00.390
object说什么

18:00.390 --> 18:01.390
是一个韩数

18:01.390 --> 18:03.390
我们来看一下object说什么

18:03.390 --> 18:05.390
这里以前还经常出这个面试题

18:05.390 --> 18:07.390
现在都还有公司在出这个面试题

18:07.390 --> 18:13.390
尽管现在看起来这个面试题已经很小了

18:13.390 --> 18:15.390
这个玩意得到啥

18:15.390 --> 18:16.390
同学们

18:16.390 --> 18:26.140
这个玩意得到啥

18:26.140 --> 18:32.110
还怕不敢说吗

18:32.110 --> 18:34.110
来吧,勇敢一点

18:34.110 --> 18:40.690
得到啥

18:40.690 --> 18:42.690
得到的是一个方式

18:42.690 --> 18:45.690
它是一个韩数

18:45.690 --> 18:46.690
为什么是韩数呢

18:46.690 --> 18:47.690
你看这吧

18:47.690 --> 18:49.690
6会不会只能跟韩数

18:49.690 --> 18:51.690
它不能跟别的玩意儿

18:51.690 --> 18:53.690
创建一个对象

18:53.690 --> 18:55.690
那么这种写法等效率

18:55.690 --> 18:56.690
我们来写一下

18:56.690 --> 18:58.690
6一个object

18:58.690 --> 19:01.690
是不是得到一个对象了

19:01.690 --> 19:03.690
给你直接写一个

19:03.690 --> 19:05.690
这个东西

19:05.690 --> 19:07.690
是不是也是一个对象

19:07.690 --> 19:09.690
这两个效果是一样的

19:09.690 --> 19:11.690
是完全一样的

19:11.690 --> 19:12.690
那么上面这个代码

19:12.690 --> 19:13.690
就相当于是

19:13.690 --> 19:15.690
你创建了一个新对象

19:15.690 --> 19:16.690
然后呢

19:16.690 --> 19:17.690
给它的属性NAM

19:17.690 --> 19:19.690
复制为jom

19:19.690 --> 19:21.690
给它的AZ

19:21.690 --> 19:22.690
复制为30

19:22.690 --> 19:24.690
就相当于是这个代码

19:24.690 --> 19:26.690
解释清楚了吧

19:26.690 --> 19:28.690
这个对象不就是6出来的吗

19:28.690 --> 19:30.690
所有的对象

19:30.690 --> 19:32.690
全部都是6出来的

19:32.690 --> 19:34.690
那就说对

19:34.690 --> 19:35.690
那输主呢

19:35.690 --> 19:36.690
输主得是对象吗

19:36.690 --> 19:38.690
输主又是怎么6出来的呢

19:38.690 --> 19:40.690
比如说我们有一个array

19:40.690 --> 19:42.690
我给它写一个

19:42.690 --> 19:44.690
1234

19:44.690 --> 19:46.690
这又是怎么6出来的呢

19:46.690 --> 19:48.690
它没有写6啊

19:48.690 --> 19:50.690
这也是为了简变你的输写

19:50.690 --> 19:53.690
它实际上的代码是这样子的

19:53.690 --> 19:55.690
6的一个array

19:55.690 --> 19:56.690
可以看出

19:56.690 --> 19:58.690
这个玩意不也得是函数吗

19:58.690 --> 19:59.690
对吧

19:59.690 --> 20:01.690
然后1234

20:01.690 --> 20:03.690
得到这么一个输主对象

20:03.690 --> 20:06.690
这才是它的真实的写法

20:06.690 --> 20:08.690
这是它的简洁写法

20:08.690 --> 20:09.690
我们来试一下

20:09.690 --> 20:11.690
你有一个array

20:11.690 --> 20:13.690
1234

20:13.690 --> 20:16.690
你看是不是得到一个输主

20:16.690 --> 20:18.690
你直接写一个输主

20:18.690 --> 20:19.690
1234

20:19.690 --> 20:20.690
是不是还是得到一个输主

20:20.690 --> 20:22.690
这两个是一模一样的

20:22.690 --> 20:26.450
懂了意思吗

20:26.450 --> 20:28.450
好

20:28.450 --> 20:30.450
那还有一种情况

20:30.450 --> 20:32.760
好

20:32.760 --> 20:34.760
一定要找一个反例出来的

20:34.760 --> 20:35.760
好

20:35.760 --> 20:38.760
哪怕你原来是你刚才说那个

20:38.760 --> 20:41.760
函数不也是对象吗

20:41.760 --> 20:43.760
你函数也是对象

20:43.760 --> 20:45.760
比方说我有写一个

20:45.760 --> 20:49.390
球合的函数

20:49.390 --> 20:50.390
对吧

20:50.390 --> 20:53.390
返回一个a加b

20:53.390 --> 20:54.390
这不是函数吗

20:54.390 --> 20:56.390
函数也得是个对象啊

20:56.390 --> 20:59.390
这个地方我也没有使用6啊

20:59.390 --> 21:01.390
一样的

21:01.390 --> 21:04.390
这个玩意也是为了简变你的输写

21:04.390 --> 21:07.390
它实际上的代码是这样子的

21:07.390 --> 21:15.090
实际上是这样子的

21:15.090 --> 21:17.090
参数a

21:17.090 --> 21:18.090
参数b

21:19.090 --> 21:20.090
函数提里边

21:20.090 --> 21:22.090
Return a加b

21:22.090 --> 21:23.090
咱们再试一下

21:23.090 --> 21:28.380
这个玩意能球合吗

21:28.380 --> 21:30.380
它还真能球合

21:30.380 --> 21:31.380
它还真是一个函数

21:31.380 --> 21:34.380
只过我们平时不推荐使用这种写法

21:34.380 --> 21:35.380
于是呢

21:35.380 --> 21:36.380
这种写法呢

21:36.380 --> 21:38.380
不好阅读

21:38.380 --> 21:40.380
不是一个正常人写出来的

21:40.380 --> 21:41.380
另外呢

21:41.380 --> 21:42.380
这种写法呢

21:42.380 --> 21:43.380
会有一些效率问题

21:43.380 --> 21:46.380
它跟那个违反引擎的编译有关系

21:46.380 --> 21:48.380
我们推荐用上面的写法

21:48.380 --> 21:50.380
或者是用函数声明的写法

21:50.380 --> 21:52.380
我给你们说的就是

21:52.380 --> 21:56.380
函数也是通过6来创建的

21:56.380 --> 21:58.380
这个没有异议的吧

21:58.380 --> 22:00.380
所有的对象都是通过6

22:00.380 --> 22:03.380
一个函数的方式来创建的

22:03.380 --> 22:04.380
那么接下来呢

22:04.380 --> 22:07.380
我给大家看一下

22:07.380 --> 22:08.380
这张大码

22:08.380 --> 22:21.210
这张大码会形成一个什么样的结构

22:21.210 --> 22:23.210
你看啊

22:23.210 --> 22:24.210
首先看这里

22:24.210 --> 22:26.210
有一个函数叫user

22:26.210 --> 22:28.210
之前写过那个函数

22:28.210 --> 22:29.210
user

22:29.210 --> 22:31.210
这个函数在这

22:31.210 --> 22:32.210
然后通过

22:32.210 --> 22:35.210
它里面不得有一个圆形吗

22:35.210 --> 22:38.210
是它的属性prototype

22:38.210 --> 22:40.210
我们的知识是连着的

22:40.210 --> 22:41.210
一叫认真听

22:41.210 --> 22:43.210
它有一个圆形

22:43.210 --> 22:45.210
属性得到的是什么呢

22:45.210 --> 22:47.210
得到的是一个空对象

22:47.210 --> 22:48.210
对吧

22:48.210 --> 22:49.210
然后呢

22:49.210 --> 22:51.210
可以通过一个6关键字

22:51.210 --> 22:53.210
产生一个新对象

22:53.210 --> 22:54.210
叫u1

22:54.210 --> 22:56.210
放到u1里面去了

22:56.210 --> 22:58.210
好 那么由于它是通过

22:58.210 --> 23:00.210
6一个u2来产生的

23:00.210 --> 23:03.210
所以

23:03.210 --> 23:06.210
它有会有一个隐释圆形

23:06.210 --> 23:08.210
指向谁

23:08.210 --> 23:11.210
指向函数的圆形

23:11.210 --> 23:12.210
于是

23:12.210 --> 23:15.210
这就形成了一个三角关系

23:15.210 --> 23:16.210
我常说

23:16.210 --> 23:18.210
我们学圆形链这一块

23:18.210 --> 23:20.210
你看上去复杂

23:20.210 --> 23:22.210
其实你只要搞清楚了

23:22.210 --> 23:23.210
这个三角关系

23:23.210 --> 23:24.210
然后呢

23:24.210 --> 23:25.210
根据我刚才说的

23:25.210 --> 23:28.210
一切对象都是6出来的

23:28.210 --> 23:31.210
你就能推导出所有的东西了

23:31.210 --> 23:32.210
圆形链

23:32.210 --> 23:34.210
圆形和圆形链这一块

23:34.210 --> 23:36.210
没有任何题

23:36.210 --> 23:38.210
可以难道理的

23:38.210 --> 23:40.210
你只要能推导出来

23:40.210 --> 23:42.210
你只需要知道这个三角关系

23:42.210 --> 23:43.210
以及

23:43.210 --> 23:44.210
刚才我说的

23:44.210 --> 23:45.210
6

23:45.210 --> 23:46.210
所有对象都是6出来的

23:46.210 --> 23:49.900
你可以推导出所有东西了

23:49.900 --> 23:51.900
好 然后我们再来看

23:51.900 --> 23:53.900
这个u2

23:53.900 --> 23:55.900
它是通过这样的方式来创建对象的

23:55.900 --> 23:56.900
那么这种方式

23:56.900 --> 23:57.900
我们知道

23:57.900 --> 23:59.900
它实际上是6了一个Object车

23:59.900 --> 24:01.900
好 我们来看一下这个关系

24:01.900 --> 24:03.900
Object车是一个函数

24:03.900 --> 24:05.900
那么这个u2怎么来的

24:05.900 --> 24:07.900
是不是6了一个Object车产生的

24:07.900 --> 24:09.900
那么这种是一个简洁的写法

24:09.900 --> 24:10.900
那么u2

24:10.900 --> 24:11.900
是不是有个u2

24:11.900 --> 24:12.900
6了一个Object车

24:12.900 --> 24:14.900
那么Object车是函数

24:14.900 --> 24:16.900
它不得有圆形吗

24:16.900 --> 24:17.900
是吧

24:17.900 --> 24:19.900
得有一个圆形

24:19.900 --> 24:22.900
然后u2是6一个Object车出来的

24:22.900 --> 24:25.900
那么u2是不是得有一个隐式圆形

24:25.900 --> 24:28.900
指向这个函数的圆形

24:28.900 --> 24:29.900
因为6它出来的

24:29.900 --> 24:30.900
6的是谁

24:30.900 --> 24:31.900
还有指向谁的圆形

24:31.900 --> 24:32.900
指向它

24:32.900 --> 24:34.900
所以也形成了一个三角关系

24:34.900 --> 24:35.900
对吧

24:35.900 --> 24:37.900
也是一个三角关系

24:37.900 --> 24:40.900
好 其实我们可以再写一些代码

24:40.900 --> 24:42.900
来验证这一点

24:42.900 --> 24:44.900
比方说

24:44.900 --> 24:46.900
我们就在这

24:46.900 --> 24:50.900
我们写一个Object

24:50.900 --> 24:51.900
这个是啥意思

24:51.900 --> 24:52.900
这个是啥意思

24:52.900 --> 24:54.900
不就是一个6的一个Object了

24:54.900 --> 24:57.900
那么根据三角关系的话

24:57.900 --> 24:59.900
这个Object不得有一个

24:59.900 --> 25:00.900
两个下滑线proto

25:00.900 --> 25:01.900
对吧

25:01.900 --> 25:03.900
不得有一个这个东西吗

25:03.900 --> 25:07.900
这个东西是不是跟Object车

25:07.900 --> 25:10.900
的proto type是一样的呢

25:10.900 --> 25:11.900
是不是一样的呢

25:11.900 --> 25:17.710
我们看一下刚才那个图

25:17.710 --> 25:20.710
它还没结

25:20.710 --> 25:21.710
这里的结个图

25:21.710 --> 25:25.280
你看是不是一样的

25:25.280 --> 25:26.280
是不是一样的

25:26.280 --> 25:28.280
那么这个Object相当于是这个

25:28.280 --> 25:30.280
它的影视圆形

25:30.280 --> 25:32.850
在这

25:32.850 --> 25:34.850
这个才的圆形

25:34.850 --> 25:35.850
是不是也是这样

25:35.850 --> 25:36.850
两个一个东西

25:36.850 --> 25:37.850
那么它一定是q

25:37.850 --> 25:38.850
我们看一下

25:38.850 --> 25:40.850
就是q

25:40.850 --> 25:41.850
对吧

25:41.850 --> 25:42.850
就是这么简单

25:42.850 --> 25:44.850
它会形成这样的一个三角关系

25:44.850 --> 25:46.850
其实你去检查这个对象的时候

25:46.850 --> 25:47.850
你会发现

25:47.850 --> 25:48.850
它里边展开之后

25:48.850 --> 25:50.850
它里边有个这个东西

25:50.850 --> 25:52.850
它在控制台里边

25:52.850 --> 25:53.850
给你写的这个东西

25:53.850 --> 25:54.850
这个东西是啥

25:54.850 --> 25:55.850
它就是

25:55.850 --> 26:00.820
就是这个玩意儿

26:00.820 --> 26:01.820
这个玩意儿

26:01.820 --> 26:02.820
就是这个玩意儿

26:02.820 --> 26:03.820
以前呢

26:03.820 --> 26:05.820
在一些旧版本的浏览器里边

26:05.820 --> 26:06.820
它显示的就是这个符号

26:06.820 --> 26:07.820
它现在显示出来了

26:07.820 --> 26:09.820
可以用到这种符号

26:09.820 --> 26:11.820
两个中过号开始

26:11.820 --> 26:12.820
两个中过号结尾

26:12.820 --> 26:14.820
在控制台里边

26:14.820 --> 26:15.820
调试的时候

26:15.820 --> 26:16.820
它是一个

26:16.820 --> 26:18.820
内部属性

26:18.820 --> 26:19.820
就是你不能使用的

26:19.820 --> 26:20.820
你不能说我去访问

26:20.820 --> 26:21.820
这个属性

26:21.820 --> 26:22.820
你访问不到的

26:22.820 --> 26:23.820
你去用这样的属性名

26:23.820 --> 26:24.820
去访问

26:24.820 --> 26:25.820
去访问不到的

26:25.820 --> 26:26.820
但是目前还仍然

26:26.820 --> 26:27.820
可以用这种方式

26:27.820 --> 26:28.820
来访问这个属性

26:28.820 --> 26:30.820
可能在过一些时间

26:30.820 --> 26:32.820
浏览器就完全禁止了

26:32.820 --> 26:33.820
不准定去访问这个属性了

26:33.820 --> 26:35.820
但是它并不是不存在

26:35.820 --> 26:36.820
它就算有一天

26:36.820 --> 26:37.820
它不允许的访问

26:37.820 --> 26:38.820
它仍然存在

26:38.820 --> 26:39.820
只是不希望你去

26:39.820 --> 26:41.820
直接使用它了

26:41.820 --> 26:42.820
这是

26:42.820 --> 26:43.820
它的三角关系

26:43.820 --> 26:44.820
看一下同学们

26:44.820 --> 26:45.820
这一块有没有什么问题

26:45.820 --> 26:46.820
能听到那个三角关系的话

26:46.820 --> 26:47.820
Q个1

26:50.520 --> 26:51.520
有问题的话

26:51.520 --> 26:52.520
打出你的问题

26:52.520 --> 26:58.990
好嘞

26:58.990 --> 26:59.990
好

26:59.990 --> 27:00.990
那么你知道这个

27:00.990 --> 27:01.990
三角关系之后

27:02.990 --> 27:03.990
那今天还有点好玩了

27:04.990 --> 27:05.990
同学们有没有想过

27:05.990 --> 27:06.990
一个问题

27:09.990 --> 27:13.300
它是哪来的呢

27:13.300 --> 27:15.300
我们来一个

27:15.300 --> 27:17.300
明征探柯兰

27:18.300 --> 27:20.300
因为同学们发现一个

27:20.300 --> 27:22.300
隐藏的现象

27:23.300 --> 27:25.300
所有的对象

27:26.300 --> 27:28.300
都是溜出来的

27:28.300 --> 27:29.300
刚才我们说了

27:29.300 --> 27:30.300
也验证了

27:31.300 --> 27:33.300
所有的

27:36.580 --> 27:38.580
所有溜出来的

27:38.580 --> 27:39.580
对象

27:39.580 --> 27:42.580
都有影视圆形

27:42.580 --> 27:44.580
就是有这个

27:45.580 --> 27:46.580
好

27:46.580 --> 27:47.580
现在接下来就是

27:47.580 --> 27:48.580
高中还是初中的

27:48.580 --> 27:49.580
一个逻辑体了

27:49.580 --> 27:52.580
是不是能够得出一个结论

27:53.580 --> 27:55.580
所有

27:55.580 --> 27:58.580
对象都有影视圆形

27:59.580 --> 28:01.580
能不能得出这个结论

28:01.580 --> 28:03.580
你们觉得按照逻辑来讲

28:04.580 --> 28:06.580
都不需要什么

28:06.580 --> 28:07.580
代码的支持

28:07.580 --> 28:09.580
都不需要技术支持

28:09.580 --> 28:10.580
觉得能不能得出

28:10.580 --> 28:11.580
这样一个结论

28:11.580 --> 28:16.360
是不是可以

28:16.360 --> 28:18.360
你让学过逻辑

28:18.360 --> 28:20.360
学的同学

28:20.360 --> 28:21.360
来看这个问题

28:21.360 --> 28:22.360
他没有学过代码

28:22.360 --> 28:24.360
他都能得出这个结论

28:24.360 --> 28:26.360
那也就意味着啥呢

28:27.360 --> 28:28.360
既然所有对象

28:28.360 --> 28:30.360
都有影视圆形

28:30.360 --> 28:32.360
它也是一对象

28:32.360 --> 28:33.360
圆形是不是对象

28:33.360 --> 28:35.360
这个玩意不是对象吗

28:35.360 --> 28:38.360
它不得也有影视圆形吗

28:39.360 --> 28:40.360
除了它之外

28:40.360 --> 28:42.360
然后这个游热这个圆形

28:43.360 --> 28:44.360
它不是对象吗

28:45.360 --> 28:47.360
它不也得有影视圆形吗

28:48.360 --> 28:49.360
对不对

28:49.360 --> 28:50.360
那么它的影视圆形

28:50.360 --> 28:52.360
是不是还可以往上画

28:52.360 --> 28:53.360
画箭头

28:53.360 --> 28:54.360
它的影视圆形

28:54.360 --> 28:55.360
指向谁呢

28:56.360 --> 28:57.360
接下来我们开始

28:57.360 --> 28:58.360
全是逻辑了

28:58.360 --> 28:59.360
后边

28:59.360 --> 29:00.360
后边图会越来越复杂

29:00.360 --> 29:01.360
越来越多

29:01.360 --> 29:04.360
但是全是可以推倒的

29:04.360 --> 29:07.360
像我们那个初中高中

29:07.360 --> 29:09.360
学习物理啊

29:09.360 --> 29:10.360
数学

29:10.360 --> 29:12.360
特别是数学的定理

29:12.360 --> 29:14.360
我们只需要知道功力

29:14.360 --> 29:15.360
是不是很多东西

29:15.360 --> 29:16.360
是不是都可以推倒出来

29:16.360 --> 29:17.360
功力和定理

29:17.360 --> 29:19.360
都可以得出推论

29:19.360 --> 29:20.360
那么这个玩意

29:20.360 --> 29:21.360
它是对象

29:21.360 --> 29:23.360
它的影视圆形是啥

29:23.360 --> 29:24.360
那就要看

29:24.360 --> 29:26.360
这个东西是哪来的了

29:27.360 --> 29:28.360
我们知道

29:28.360 --> 29:29.360
每一个对象都是溜出来的

29:29.360 --> 29:30.360
这个玩意

29:30.360 --> 29:32.360
圆形是怎么来的呢

29:32.360 --> 29:33.360
圆形

29:33.360 --> 29:35.360
它也是溜出来的

29:35.360 --> 29:37.360
只说这个过程呢

29:37.360 --> 29:39.360
浏览器就直接帮你做了

29:39.360 --> 29:40.360
你不知道

29:40.360 --> 29:42.360
它就是一个普通对象

29:42.360 --> 29:43.360
你可以把认为

29:43.360 --> 29:45.360
圆形就是一个普通对象

29:46.360 --> 29:49.360
比如User.prototype

29:49.360 --> 29:51.360
它就是一个普通对象

29:51.360 --> 29:53.360
那既然是一个普通对象的话

29:53.360 --> 29:55.360
是不是溜了一个什么

29:55.360 --> 29:56.360
它溜了这么一个东西

29:56.360 --> 29:58.360
那也就意味着

29:58.360 --> 30:00.360
下边这张图就出现了

30:00.360 --> 30:02.360
我把这两幅图就合在一起了

30:02.360 --> 30:04.360
之前好像是独立的

30:04.360 --> 30:05.360
没有关系的

30:05.360 --> 30:06.360
实际上是有关系的

30:06.360 --> 30:08.360
你看啊

30:08.360 --> 30:10.360
我通过溜一个User

30:10.360 --> 30:11.360
得到U1

30:11.360 --> 30:12.360
U1不得有一个影视圆形吗

30:12.360 --> 30:13.360
你看这一部分

30:13.360 --> 30:14.360
是不是三辆关系

30:15.360 --> 30:17.360
那么刚才画的三辆关系

30:17.360 --> 30:19.360
然后我们再

30:19.360 --> 30:21.360
它在圆形

30:21.360 --> 30:22.360
这个圆形

30:22.360 --> 30:23.360
它不也是溜出来的吗

30:23.360 --> 30:24.360
溜的是谁

30:24.360 --> 30:25.360
溜的是OP这个社

30:25.360 --> 30:27.360
OP这个社有一个圆形

30:27.360 --> 30:28.360
那它的影视圆形

30:28.360 --> 30:30.360
是不是要指向OP的圆形

30:30.360 --> 30:34.380
这个不又是一个三辆关系吗

30:34.380 --> 30:35.380
对不对

30:35.380 --> 30:36.380
不也是一个三辆关系吗

30:36.380 --> 30:38.380
你一部分一部分想就想通了

30:38.380 --> 30:40.380
所以说我说这一颗

30:40.380 --> 30:41.380
就圆形练这一块

30:41.380 --> 30:42.380
别看上去复杂

30:42.380 --> 30:44.380
你只要能画出三辆关系

30:44.380 --> 30:45.380
当你画不出来三辆关系

30:45.380 --> 30:46.380
那就没办法了

30:46.380 --> 30:48.380
你只要能画得出来三辆关系

30:48.380 --> 30:53.200
一个一个去推都能推到出来

30:53.200 --> 30:54.200
好

30:54.200 --> 30:55.200
然后

30:55.200 --> 30:57.200
这里有一个特殊点

30:57.200 --> 30:59.200
就是OP这个社的圆形

30:59.200 --> 31:00.200
它也是对象啊

31:00.200 --> 31:02.200
那它的影视圆形指向谁呢

31:02.200 --> 31:03.200
这是一个特殊点

31:03.200 --> 31:05.200
在我们的链条里面

31:05.200 --> 31:08.200
有那么两三个特殊点

31:08.200 --> 31:10.200
这是其中一个特殊点

31:10.200 --> 31:12.200
有点违反规则了

31:12.200 --> 31:14.200
它的影视圆形指向大了

31:14.200 --> 31:15.200
没有了

31:15.200 --> 31:17.200
不然的话就是无穷无尽

31:17.200 --> 31:18.200
无穷无尽的

31:18.200 --> 31:20.200
因为它就先升级

31:20.200 --> 31:21.200
还是先有弹

31:21.200 --> 31:22.200
还是先有急的问题了

31:22.200 --> 31:23.200
懂了意思吗

31:23.200 --> 31:24.200
好

31:24.200 --> 31:26.200
那么这个圆形练是什么

31:26.200 --> 31:28.200
圆形练就是这一块

31:29.200 --> 31:31.200
这一块就是圆形练

31:31.200 --> 31:33.200
为什么要说也是圆形练呢

31:33.200 --> 31:36.200
其实这个道理是这样子的

31:36.200 --> 31:39.200
当我去找这个U1的属性的时候

31:39.200 --> 31:41.200
它看一下自己有没有

31:41.200 --> 31:42.200
如果自己没有的话

31:42.200 --> 31:44.200
就会从链条上去找

31:44.200 --> 31:46.200
看一下U这个圆形上有没有

31:46.200 --> 31:47.200
是不是之前

31:47.200 --> 31:49.200
演示过这个C害方法

31:49.200 --> 31:52.200
这里如果说还没有的话

31:52.200 --> 31:54.200
它继续往上找

31:54.200 --> 31:56.200
看这里有没有

31:56.200 --> 31:58.200
这里还没有的话就没有了

31:58.200 --> 31:59.200
就包戳了

31:59.200 --> 32:01.200
所以它会顺着这个链条

32:01.200 --> 32:02.200
一次往上找

32:02.200 --> 32:04.200
这就是圆形练

32:04.200 --> 32:06.200
所以圆形练实际上是什么链条

32:06.200 --> 32:08.200
是一个对象的

32:08.200 --> 32:12.200
影视圆形形成的链条

32:12.200 --> 32:14.200
叫做圆形练

32:14.200 --> 32:16.200
我们又来验证一下

32:16.200 --> 32:18.200
来验证一下

32:18.200 --> 32:21.200
比方说我们去看一下

32:21.200 --> 32:23.200
我们写个函数吧

32:23.200 --> 32:24.200
U字

32:26.200 --> 32:28.200
然后我们得到一个U

32:28.200 --> 32:30.200
6一个U字

32:30.200 --> 32:33.200
首先我们来看一下U

32:33.200 --> 32:36.200
这个U它不就是这个东西吗

32:36.200 --> 32:38.200
它不就是个U1吗

32:38.200 --> 32:40.200
把个图

32:40.200 --> 32:44.150
结一个

32:44.150 --> 32:45.150
它不就是个U1吗

32:45.150 --> 32:47.150
U1里面说有个影视圆形

32:47.150 --> 32:48.150
对吧

32:48.150 --> 32:50.150
它指向谁指向U字的圆形

32:50.150 --> 32:54.230
你看它这里已经写出来了

32:54.230 --> 32:55.230
它有影视圆形

32:55.230 --> 32:56.230
指向的是谁

32:56.230 --> 32:58.230
指向的是U字的圆形

32:58.230 --> 33:01.230
U字的圆形里面也有一个影视圆形

33:01.230 --> 33:02.230
看到没

33:02.230 --> 33:03.230
它指向谁

33:03.230 --> 33:06.230
你看这里有一个Prototype

33:06.230 --> 33:08.230
指向的是Object的圆形

33:08.230 --> 33:09.230
Object的圆形里面

33:09.230 --> 33:10.230
是不是有很多东西

33:10.230 --> 33:12.230
一大堆东西

33:12.230 --> 33:14.230
然后再看Object的圆形里面

33:14.230 --> 33:16.230
它有没有Prototype呢

33:16.230 --> 33:18.230
它里面就没有了

33:18.230 --> 33:21.230
它里面是不是没有Prototype了

33:21.230 --> 33:22.230
对吧

33:22.230 --> 33:23.230
没有了

33:23.230 --> 33:26.230
那么就是这个链条就出来了

33:26.230 --> 33:28.230
再印证一下

33:28.230 --> 33:31.230
我们看一下U里面有没有属性

33:31.230 --> 33:33.230
Toolstream

33:33.230 --> 33:34.230
没有吧

33:34.230 --> 33:36.230
这里面有没有属性Toolstream

33:36.230 --> 33:37.230
没有

33:37.230 --> 33:38.230
那么这里面

33:38.230 --> 33:39.230
圆形里面有没有Toolstream

33:39.230 --> 33:40.230
也没有

33:40.230 --> 33:42.230
但是Object的圆形里面

33:42.230 --> 33:44.230
这一部分是不是有Toolstream

33:44.230 --> 33:45.230
我们知道

33:45.230 --> 33:46.230
这里面

33:46.230 --> 33:47.230
你得知道这一点

33:47.230 --> 33:48.230
如果说不知道怎么办

33:48.230 --> 33:49.230
我们来看一下吧

33:49.230 --> 33:51.230
Object的圆形里面有Prototype

33:51.230 --> 33:53.230
里面有Toolstream

33:53.230 --> 33:54.230
还有没有呢

33:54.230 --> 33:55.230
是不是有

33:56.230 --> 33:57.230
那么也就意味着

33:57.230 --> 34:01.230
我U也可以使用Toolstream

34:01.230 --> 34:02.230
你看

34:02.230 --> 34:03.230
它本来没有这个函数的

34:03.230 --> 34:04.230
它仍然可以使用

34:04.230 --> 34:05.230
为什么

34:05.230 --> 34:06.230
因为它形成链条了

34:06.230 --> 34:07.230
它自己没有

34:07.230 --> 34:08.230
从这儿找

34:08.230 --> 34:09.230
这里没有

34:09.230 --> 34:10.230
从这儿找

34:10.230 --> 34:11.230
这里面有

34:11.230 --> 34:12.230
它都可以使用

34:12.230 --> 34:14.230
懂这个意思吧

34:14.230 --> 34:15.230
这一块能听懂吗

34:15.230 --> 34:16.230
听懂的话

34:16.230 --> 34:17.230
同学QQE

34:27.740 --> 34:29.740
其实这一点

34:29.740 --> 34:31.740
我们也可以得出一个推论

34:32.740 --> 34:33.740
就是说

34:34.740 --> 34:35.740
既然

34:35.740 --> 34:36.740
那些我们自己写的函数

34:36.740 --> 34:37.740
都是我们自己写的函数

34:37.740 --> 34:38.740
对吧

34:38.740 --> 34:39.740
自己写的函数

34:39.740 --> 34:40.740
不都有圆形吗

34:40.740 --> 34:42.740
它那个圆形的隐尸圆形

34:42.740 --> 34:43.740
都指向这个吧

34:43.740 --> 34:44.740
是不是这样子

34:44.740 --> 34:45.740
只要你不去动它

34:45.740 --> 34:47.740
它就是这样子

34:47.740 --> 34:48.740
那确实

34:48.740 --> 34:50.740
只要你自己写的函数

34:50.740 --> 34:52.740
它一定是有圆形的

34:52.740 --> 34:53.740
那么这个圆形

34:53.740 --> 34:54.740
它一定

34:54.740 --> 34:55.740
它有一个隐尸圆形

34:55.740 --> 34:56.740
会指向Object的圆形

34:56.740 --> 34:57.740
就意味着

34:58.740 --> 35:00.740
你通过所有的

35:00.740 --> 35:01.740
构造函数

35:02.740 --> 35:03.740
去溜出来的东西

35:04.740 --> 35:06.740
它一直往上涨

35:06.740 --> 35:07.740
它就能够

35:07.740 --> 35:09.740
找到Object的圆形

35:10.740 --> 35:11.740
这也就意味着

35:11.740 --> 35:12.740
你就会发现

35:12.740 --> 35:14.740
像什么

35:14.740 --> 35:16.740
你刚刚订了一个有软

35:16.740 --> 35:17.740
你订一些别的构造函数

35:17.740 --> 35:18.740
它都是这个样子的

35:19.740 --> 35:20.740
都是这个样子的

35:20.740 --> 35:21.740
比方说我们

35:21.740 --> 35:22.740
订一个

35:24.740 --> 35:25.740
溜一个

35:25.740 --> 35:26.740
2A

35:28.740 --> 35:30.740
就溜一个2A吧

35:30.740 --> 35:32.740
我们直接写个数数

35:33.740 --> 35:34.740
但是

35:35.740 --> 35:36.740
ARR里面有没有出现

35:37.740 --> 35:38.740
有

35:38.740 --> 35:39.740
为什么

35:39.740 --> 35:40.740
这个ARR

35:40.740 --> 35:42.740
你就可以把2A

35:42.740 --> 35:44.740
看成是这个东西

35:44.740 --> 35:45.740
对吧

35:45.740 --> 35:46.740
ARR里看成是这个东西

35:46.740 --> 35:47.740
它往上涨

35:47.740 --> 35:48.740
还是会找到Object的圆形

35:50.740 --> 35:51.740
对吧

35:51.740 --> 35:52.740
就这么道理

35:52.740 --> 35:53.740
然后

35:53.740 --> 35:54.740
我们再看一下2A

35:54.740 --> 35:55.740
就是有些东西

35:55.740 --> 35:56.740
就可以分析出来了

35:56.740 --> 35:58.740
为什么我们要学原理

35:59.740 --> 36:00.740
因为原理

36:00.740 --> 36:01.740
你掌握清楚了

36:01.740 --> 36:02.740
很多东西

36:02.740 --> 36:03.740
你是不用去背的

36:03.740 --> 36:05.740
你是可以分析出来的

36:05.740 --> 36:07.740
就是我们学技术

36:07.740 --> 36:08.740
你不能像

36:08.740 --> 36:09.740
学什么历史

36:09.740 --> 36:11.740
政治一样去背

36:11.740 --> 36:13.740
你应该像学数学

36:13.740 --> 36:14.740
学物理一样

36:14.740 --> 36:16.740
去找了它的逻辑和方法

36:16.740 --> 36:18.740
有了逻辑和方法支撑之后

36:18.740 --> 36:19.740
你可以解决所有的问题

36:19.740 --> 36:21.740
就像我们学加法一样

36:21.740 --> 36:22.740
你没有必要把

36:22.740 --> 36:24.740
全世界所有的数字

36:24.740 --> 36:26.740
每个数字的加写得有多少

36:26.740 --> 36:27.740
全部把背下来

36:27.740 --> 36:28.740
你只需要知道

36:28.740 --> 36:30.740
十亿内的加法就可以了

36:30.740 --> 36:32.740
后边我们就用逻辑去推

36:32.740 --> 36:33.740
那么就可以搞定世界上

36:33.740 --> 36:34.740
所有的加法

36:34.740 --> 36:36.740
那么这里也是一样的

36:36.740 --> 36:37.740
我们有的这些理论

36:37.740 --> 36:39.740
很多东西都可以推导出来

36:39.740 --> 36:40.740
比方说

36:40.740 --> 36:41.740
我们看一下个2A

36:41.740 --> 36:43.740
Toolstream

36:43.740 --> 36:44.740
得到的是什么

36:44.740 --> 36:46.740
得到的是这种格式

36:47.740 --> 36:49.740
好像跟我刚才那个U里边的

36:49.740 --> 36:51.740
Toolstream得到的格式不一样

36:51.740 --> 36:52.740
看到没

36:52.740 --> 36:54.740
就格式不一样

36:55.740 --> 36:58.740
我们就可能会有一些猜测

36:58.740 --> 37:01.740
这个Array里边的Toolstream

37:01.740 --> 37:03.740
是不是这里的Toolstream

37:03.740 --> 37:05.740
你如何去验证

37:05.740 --> 37:07.740
如何验证的很简单

37:07.740 --> 37:08.740
我就看一下

37:08.740 --> 37:09.740
首先我们看一下U

37:09.740 --> 37:10.740
U的Toolstream

37:10.740 --> 37:12.740
是不是等于

37:12.740 --> 37:15.740
Objects的Prototype的Toolstream

37:15.740 --> 37:16.740
是不是想等

37:16.740 --> 37:17.740
想等吧

37:17.740 --> 37:18.740
说明什么

37:18.740 --> 37:20.740
说明U用的这个Toolstream

37:20.740 --> 37:21.740
用的是谁呢

37:21.740 --> 37:24.740
用的是Objects的原型里面的Toolstream

37:24.740 --> 37:25.740
他找啊找啊找

37:25.740 --> 37:27.740
自己没有这里没有这里有了

37:27.740 --> 37:28.740
用的是他

37:28.740 --> 37:30.740
说他两个一定是相等的

37:30.740 --> 37:32.740
那么再看一下Array

37:32.740 --> 37:34.740
Toolstream

37:34.740 --> 37:36.740
等于Objects

37:36.740 --> 37:37.740
Prototype

37:37.740 --> 37:39.740
Toolstream

37:39.740 --> 37:41.740
是Force

37:41.740 --> 37:43.740
说明了啥

37:43.740 --> 37:46.740
你说还能说明啥

37:46.740 --> 37:47.740
还能说明啥

37:47.740 --> 37:49.740
说明Array还用的不是这

37:49.740 --> 37:50.740
那说明啥

37:50.740 --> 37:52.740
说明他一定在这

37:52.740 --> 37:53.740
或者在这

37:53.740 --> 37:55.740
把他找到了

37:55.740 --> 37:56.740
对不对

37:56.740 --> 37:58.740
他就没有继续往上找了

37:58.740 --> 38:00.740
那他在在哪呢

38:00.740 --> 38:01.740
他在这

38:01.740 --> 38:05.180
Array里边在这

38:05.180 --> 38:07.180
好我来试一下看一下

38:07.180 --> 38:08.180
又来验证一下

38:08.180 --> 38:09.180
Array你打开

38:09.180 --> 38:10.180
他其实你看得很清楚

38:10.180 --> 38:11.180
这一部分呢

38:11.180 --> 38:12.180
就是他自己带

38:12.180 --> 38:13.180
自己的属性

38:13.180 --> 38:14.180
就是这里的属性

38:14.180 --> 38:15.180
这里的属性有Toolstream吗

38:15.180 --> 38:16.180
没有

38:16.180 --> 38:17.180
好我们把它展开

38:17.180 --> 38:18.180
展开之后呢

38:18.180 --> 38:20.180
你会看到他这里边

38:20.180 --> 38:22.180
是有一个Toolstream的

38:22.180 --> 38:24.180
看到没

38:24.180 --> 38:25.180
说明在在哪

38:25.180 --> 38:26.180
在这

38:26.180 --> 38:28.690
懂了吗

38:28.690 --> 38:29.690
也就意味着呢

38:29.690 --> 38:30.690
你往Array里边的

38:30.690 --> 38:31.690
元象里边加东西

38:31.690 --> 38:34.690
就可以被所有的属性

38:34.690 --> 38:36.690
被所有的属主所共享

38:36.690 --> 38:37.690
你只要在Array里边

38:37.690 --> 38:39.690
这个地方加东西

38:39.690 --> 38:40.690
那么所有的属主

38:40.690 --> 38:44.690
他都会有这个腾愿了

38:44.690 --> 38:47.690
这是

38:47.690 --> 38:50.690
这个逻辑

38:50.690 --> 38:54.060
好接下来我们继续

38:54.060 --> 38:55.060
其实

38:55.060 --> 38:56.060
其实原型念这一块

38:56.060 --> 38:58.060
我都已经讲完了说实话

38:58.060 --> 38:59.060
你只要学了三角关系

38:59.060 --> 39:01.060
你就已经学完了

39:01.060 --> 39:02.060
后边的东西我去全

39:02.060 --> 39:04.060
告诉你们怎么去推倒的

39:04.060 --> 39:06.060
后边你们下来过后

39:06.060 --> 39:08.060
你这一块下来怎么去消化

39:08.060 --> 39:09.060
你不要去看这个

39:09.060 --> 39:11.060
不要去看后边这个

39:11.060 --> 39:12.060
你只需要看这个

39:12.060 --> 39:14.060
三角关系

39:14.060 --> 39:17.060
以及好好的去理解我这句话

39:17.060 --> 39:19.060
一切都可以推倒出来

39:19.060 --> 39:21.060
然后记住几个特殊点

39:21.060 --> 39:24.060
一共就好像就两个特殊点

39:24.060 --> 39:26.060
没有别的特殊点了

39:26.060 --> 39:27.060
好接下来我们又来想

39:27.060 --> 39:29.060
这个图还没完

39:29.060 --> 39:30.060
这个图就完了吗

39:30.060 --> 39:31.060
还没完

39:31.060 --> 39:32.060
这个完了

39:32.060 --> 39:33.060
你看这个是对象吗

39:33.060 --> 39:34.060
有影视

39:34.060 --> 39:35.060
这个是对象吗

39:35.060 --> 39:36.060
有影视元凶

39:36.060 --> 39:37.060
这个是对象有影视

39:37.060 --> 39:40.060
它是特殊的暗貌

39:40.060 --> 39:43.060
你这个函数不也是对象吗

39:43.060 --> 39:45.060
函数是不是对象

39:45.060 --> 39:46.060
是对象

39:46.060 --> 39:48.060
那你的影视元凶在哪呢

39:48.060 --> 39:50.060
我没看到

39:50.060 --> 39:53.060
于是一推一推

39:53.060 --> 39:56.060
你会发现最终的图就变成这个样子

39:56.060 --> 39:58.060
你看这里

39:58.060 --> 40:01.060
这一部分是不是就刚上我们的图

40:01.060 --> 40:02.060
一模一样的吧

40:02.060 --> 40:03.060
没有任何区别吗

40:03.060 --> 40:05.060
你好好看一下

40:05.060 --> 40:07.060
资金一函数就是某个U字

40:07.060 --> 40:09.060
或者是Array

40:09.060 --> 40:11.060
都在这

40:11.060 --> 40:14.060
它可以通过6来创建一个实力

40:14.060 --> 40:16.060
它又会有影视元凶

40:16.060 --> 40:18.060
形成一个链条

40:18.060 --> 40:22.060
我们先来看一下资金一函数

40:22.060 --> 40:24.060
资金一函数哪来的

40:24.060 --> 40:26.060
它又要形成三角关系了

40:26.060 --> 40:28.060
因为它总得有一个6

40:28.060 --> 40:29.060
它必须得6出来

40:29.060 --> 40:30.060
创建了

40:30.060 --> 40:31.060
它6的是谁

40:31.060 --> 40:33.060
6的是方形

40:33.060 --> 40:34.060
是吗

40:34.060 --> 40:35.060
刚才说过的

40:35.060 --> 40:37.060
6的是这个东西

40:37.060 --> 40:39.060
所以说

40:39.060 --> 40:43.060
这个玩意6出来一个资金一函数

40:43.060 --> 40:44.060
那么

40:44.060 --> 40:46.060
它不得也有影视

40:46.060 --> 40:48.060
它不得也有那个圆形吗

40:48.060 --> 40:50.060
它也有圆形

40:50.060 --> 40:51.060
看到没

40:51.060 --> 40:53.380
方形的圆形

40:53.380 --> 40:55.380
没问题吧

40:55.380 --> 40:57.380
然后呢

40:57.380 --> 40:59.380
资金一函数是通过它来6出来

40:59.380 --> 41:01.380
又形成三角关系了

41:01.380 --> 41:03.380
它不得也有影视圆形吗

41:03.380 --> 41:05.380
指向方形的圆形

41:05.380 --> 41:07.380
这个三角关系就出来了

41:07.380 --> 41:10.070
好

41:10.070 --> 41:13.070
那么这个R不接扯其实是一样的

41:13.070 --> 41:15.070
R不接扯是哪来的

41:15.070 --> 41:17.070
6的一个方形出来的

41:17.070 --> 41:21.700
然后R不接扯

41:21.700 --> 41:23.700
它的影视圆形

41:23.700 --> 41:26.700
不也在指向方形的圆形吗

41:26.700 --> 41:29.700
这螺旋是不是就出来了

41:29.700 --> 41:31.700
那么这个方形的圆形

41:31.700 --> 41:33.700
它不得是对象吗

41:33.700 --> 41:34.700
它又哪来的呢

41:34.700 --> 41:37.700
它是R不接扯出来的

41:37.700 --> 41:41.270
那它的影视圆形

41:41.270 --> 41:44.270
不应该指向R不接扯的圆形吗

41:44.270 --> 41:46.270
全都是可以推的

41:46.270 --> 41:47.270
你要去背这个

41:47.270 --> 41:48.270
我的天啊

41:48.270 --> 41:49.270
我反正背不下来

41:49.270 --> 41:50.270
这些图啊

41:50.270 --> 41:52.270
我是怎么给你画的

41:52.270 --> 41:54.270
我就先画一个三角关系

41:54.270 --> 41:55.270
指定也还属实力

41:55.270 --> 41:57.270
圆形的三角关系就出来了

41:57.270 --> 41:58.270
我就想这个哪来的

41:58.270 --> 41:59.270
6它出来的

41:59.270 --> 42:01.270
这个三角关系就出来了

42:01.270 --> 42:02.270
它哪来的

42:02.270 --> 42:03.270
它出来的

42:03.270 --> 42:05.270
那么这个里的三角关系就出来了

42:05.270 --> 42:06.270
它哪来的

42:06.270 --> 42:07.270
它6它出来的

42:07.270 --> 42:08.270
所以这个三角关系就出来了

42:08.270 --> 42:10.270
我就是这样画的

42:10.270 --> 42:11.270
我背不下来的

42:11.270 --> 42:14.270
这玩意一背就非常容易出错的

42:14.270 --> 42:16.270
当你按这个三角关系一个个去画

42:16.270 --> 42:19.270
找到每一个点的三角关系

42:19.270 --> 42:21.270
就可以了

42:21.270 --> 42:22.270
那么记住几个特殊点

42:22.270 --> 42:23.270
一个就是这里

42:23.270 --> 42:24.270
它是哪好

42:24.270 --> 42:25.270
它没有

42:25.270 --> 42:26.270
它没有

42:26.270 --> 42:27.270
往上再没有圆形了

42:27.270 --> 42:29.270
另外一个特殊点就是

42:29.270 --> 42:32.270
它是哪来的呢

42:32.270 --> 42:34.270
你别管了

42:34.270 --> 42:35.270
你可以认为

42:35.270 --> 42:37.270
是介石引擎启动的时候

42:37.270 --> 42:39.270
因为介石引擎启动的时候

42:39.270 --> 42:40.270
它会做一些准备工作

42:40.270 --> 42:44.270
它就已经把这个东西安进去了

42:44.270 --> 42:45.270
它不难的话

42:45.270 --> 42:46.270
就是先升机

42:46.270 --> 42:47.270
还是先有机

42:47.270 --> 42:48.270
还是先有单的问题了

42:48.270 --> 42:50.270
它是一开始就有的

42:50.270 --> 42:51.270
它是哪来的

42:51.270 --> 42:53.270
你别管

42:53.270 --> 42:54.270
然后它的引擎圆形

42:54.270 --> 42:56.270
指向自己的圆形

42:56.270 --> 42:57.270
这一个比较特殊

42:57.270 --> 42:59.270
它的引擎圆形指向自己

42:59.270 --> 43:01.270
就这几个特殊点

43:01.270 --> 43:03.270
因为它不知道它自己哪来的

43:03.270 --> 43:04.270
它一开始就有

43:04.270 --> 43:06.270
那么引擎圆形没法指

43:06.270 --> 43:09.270
它也不会去溜别的东西出来

43:09.270 --> 43:11.270
所以呢

43:11.270 --> 43:13.270
它的引擎圆形指向自己的圆形

43:13.270 --> 43:15.270
其他没啥

43:15.270 --> 43:16.270
这就是完整的圆形

43:16.270 --> 43:18.270
圆形链的图

43:18.270 --> 43:21.270
你只要能够把这个图画出来

43:21.270 --> 43:22.270
圆形链这一块的题

43:22.270 --> 43:24.270
你是无敌的

43:24.270 --> 43:27.270
管它什么大厂小厂

43:27.270 --> 43:29.270
管它的月薪那个30K

43:29.270 --> 43:31.270
还是10K

43:31.270 --> 43:32.270
还是50K

43:32.270 --> 43:34.270
反正只要考到圆形链

43:34.270 --> 43:36.270
你就是无敌的

43:36.270 --> 43:37.270
这个图一说多复杂呢

43:37.270 --> 43:39.270
也不多复杂

43:39.270 --> 43:40.270
它就是通过三角关系

43:40.270 --> 43:43.270
一块一块一块一块的把推到出来

43:43.270 --> 43:44.270
然后我们来看一下这个题

43:44.270 --> 43:46.270
这个图怎么去解

43:46.270 --> 43:49.970
怎么去解题

43:49.970 --> 43:50.970
这里顺便说一下

43:50.970 --> 43:52.970
在ES6出来之后

43:52.970 --> 43:53.970
它提供了一个关键字

43:53.970 --> 43:55.970
叫Instance

43:55.970 --> 43:58.970
因为题里边可能会考到

43:58.970 --> 44:00.970
它实际上考的就是圆形链的东西

44:00.970 --> 44:02.970
其实圆形链里边还会

44:02.970 --> 44:04.970
涉及到一些函数方法

44:04.970 --> 44:05.970
因为时间关系

44:05.970 --> 44:07.970
实在是没有时间来讲

44:07.970 --> 44:09.970
但是已经可以解决很多问题了

44:09.970 --> 44:11.970
比方说A instance of B

44:11.970 --> 44:13.970
它会返回一个布尔

44:13.970 --> 44:14.970
真或者是假

44:14.970 --> 44:15.970
它表示什么意思呢

44:15.970 --> 44:18.970
表示首先B必须是一个函数

44:18.970 --> 44:20.970
B必须是一个函数

44:20.970 --> 44:22.970
它检查的是谁

44:22.970 --> 44:24.970
检查的是A的圆形链上

44:24.970 --> 44:27.970
是否存在B的圆形

44:27.970 --> 44:31.970
比方说我们这里写的是user

44:31.970 --> 44:33.970
user勾到函数

44:33.970 --> 44:34.970
这里是一个U

44:34.970 --> 44:38.970
我说U是不是instance of user

44:38.970 --> 44:43.500
画得不好

44:43.500 --> 44:44.500
那怎么来看呢

44:44.500 --> 44:48.500
就看这个U的圆形链上

44:48.500 --> 44:51.500
有没有user的圆形

44:51.500 --> 44:53.500
U的话就是true

44:53.500 --> 44:56.500
没有的话就是force

44:56.500 --> 44:59.500
其实我们平时写代码的话

44:59.500 --> 45:01.500
你不用去绕那么多圈

45:01.500 --> 45:04.500
我们平时这句话是有一个标准的读法

45:04.500 --> 45:07.500
A是不是B

45:07.500 --> 45:09.500
它就是个标准的读法

45:09.500 --> 45:11.500
比方说我们这样子写

45:11.500 --> 45:18.500
U is tensor user

45:18.500 --> 45:19.500
表示什么意思呢

45:19.500 --> 45:25.500
这句话的意思就是U是不是user

45:25.500 --> 45:27.500
这个U是不是一个用户

45:27.500 --> 45:28.500
就这么个意思

45:28.500 --> 45:32.500
我说写的是U is tensor object成了

45:32.500 --> 45:36.500
我们把它读作U是不是对象

45:37.500 --> 45:39.500
这样子更加容易判断出来

45:39.500 --> 45:42.500
这个东西到底我们判断的到底是啥

45:42.500 --> 45:44.500
最终判断的还是圆形链

45:44.500 --> 45:46.500
这是它的技术的角度去讲解

45:46.500 --> 45:49.500
它从代码的阅读的角度去讲解的话

45:49.500 --> 45:51.500
这样子更加容易阅读

45:51.500 --> 45:52.500
好吧

45:52.500 --> 45:54.500
那么接下来我们就看题了

45:54.500 --> 46:00.620
圆形链

46:00.620 --> 46:02.620
来吧

46:02.620 --> 46:04.620
开幕雷机

46:04.620 --> 46:06.620
地牢体

46:06.620 --> 46:09.620
来吧别怕

46:09.620 --> 46:11.620
所以搞修这个东西到底是啥

46:11.620 --> 46:12.620
U2是啥

46:12.620 --> 46:15.000
是这个

46:15.000 --> 46:16.000
然后呢

46:16.000 --> 46:17.000
往这里边加了一个啥

46:17.000 --> 46:18.000
加了一个say hello

46:18.000 --> 46:20.000
我用s代代题吧

46:20.000 --> 46:22.000
这个say hello

46:22.000 --> 46:26.000
然后是U1

46:26.000 --> 46:28.000
U1就是这里的实例

46:28.000 --> 46:29.000
U2

46:29.000 --> 46:31.000
那么就还有一个U2

46:31.000 --> 46:33.000
U2在这里

46:33.000 --> 46:34.000
有个实例

46:34.000 --> 46:35.000
它的结构是一样的

46:35.000 --> 46:37.000
留了一个U2出来

46:37.000 --> 46:40.000
就形成这么一种结构了

46:41.000 --> 46:44.000
然后是U1.say hello

46:44.000 --> 46:47.000
是不是等于U2.say hello

46:47.000 --> 46:49.000
U1里边有没有say hello

46:49.000 --> 46:50.000
没有啊

46:50.000 --> 46:52.000
它自己能没有属性

46:52.000 --> 46:53.000
它只能从哪儿找

46:53.000 --> 46:54.000
从这儿找

46:54.000 --> 46:55.000
这里边有没有say hello

46:55.000 --> 46:57.000
有啊

46:57.000 --> 46:59.000
那么U1的say hello

46:59.000 --> 47:00.000
跟U2

47:00.000 --> 47:02.000
U2这里说还有一个实例

47:02.000 --> 47:03.000
它的影视圆形

47:03.000 --> 47:04.000
是不是也是一样的

47:04.000 --> 47:06.000
跟U1是一样的

47:06.000 --> 47:08.000
第一个是不是 true

47:09.000 --> 47:11.000
记录一下

47:11.000 --> 47:17.320
接下来下一个

47:17.320 --> 47:19.320
User.prototype

47:19.320 --> 47:21.320
User.prototype

47:21.320 --> 47:22.320
就这个玩意儿

47:22.320 --> 47:24.320
是不是等于

47:24.320 --> 47:26.320
Function.prototype

47:26.320 --> 47:28.320
托一下

47:28.320 --> 47:35.020
稍微说小一点吧

47:35.020 --> 47:39.700
这样子

47:39.700 --> 47:41.700
User.prototype

47:41.700 --> 47:42.700
就这东西

47:42.700 --> 47:45.700
是不是等于Function.prototype

47:45.700 --> 47:49.140
两个肯定不一样嘛

47:49.140 --> 47:51.140
说这个地方是force

47:51.140 --> 47:53.140
第二句话 force

47:53.140 --> 47:54.140
第三个

47:54.140 --> 47:57.140
User.影视圆形

47:57.140 --> 47:59.140
User的影视圆形

47:59.140 --> 48:00.140
这个

48:00.140 --> 48:03.140
是不是等于Function.prototype

48:03.140 --> 48:05.140
是不是等于它的影视圆形

48:05.140 --> 48:06.140
它的圆形

48:06.140 --> 48:07.140
说相等的

48:07.140 --> 48:08.140
两个都是一个东西

48:08.140 --> 48:09.140
说 true

48:09.140 --> 48:11.140
User.prototype是无敌的

48:11.140 --> 48:12.140
然后下一个

48:12.140 --> 48:14.140
User的影视圆形

48:14.140 --> 48:15.140
这个

48:15.140 --> 48:17.140
是不是等于Function.影视圆形呢

48:17.140 --> 48:19.140
Function.影视圆形

48:19.140 --> 48:21.140
这是个特殊指向圆形

48:21.140 --> 48:23.140
是一个东西

48:23.140 --> 48:25.140
true

48:25.140 --> 48:31.720
下一句话

48:31.720 --> 48:33.720
User.prototype

48:33.720 --> 48:35.720
User.prototype

48:35.720 --> 48:37.720
这个

48:37.720 --> 48:39.720
是不是等于User.prototype

48:39.720 --> 48:41.720
User.prototype

48:41.720 --> 48:43.720
User.prototype

48:43.720 --> 48:45.720
User.prototype

48:45.720 --> 48:49.860
User.prototype

48:49.860 --> 48:51.860
User.prototype

48:51.860 --> 48:53.860
User.prototype

48:54.860 --> 48:56.860
那两个肯定是不一样的

48:56.860 --> 48:58.860
肯定是不一样的

48:58.860 --> 48:59.860
那么这里呢

48:59.860 --> 49:03.430
是

49:03.430 --> 49:07.380
Function.影视圆形

49:07.380 --> 49:09.380
Function.prototype

49:09.380 --> 49:10.380
影视圆形

49:10.380 --> 49:12.380
是不是等于User.prototype

49:12.380 --> 49:13.380
User.prototype

49:13.380 --> 49:14.380
User.prototype

49:14.380 --> 49:15.380
User.prototype

49:15.380 --> 49:16.380
不也是这个吗

49:16.380 --> 49:18.380
是不是也是这个

49:18.380 --> 49:19.380
好

49:19.380 --> 49:20.380
然后两个都是相等

49:22.380 --> 49:24.380
又来

49:25.380 --> 49:36.790
说小一点

49:36.790 --> 49:38.790
下一句很长

49:38.790 --> 49:41.790
它的圆形的影视圆形

49:41.790 --> 49:43.790
它的圆形的

49:43.790 --> 49:46.790
影视圆形的链条找到了它了

49:46.790 --> 49:47.790
是不等于

49:47.790 --> 49:48.790
User.prototype

49:48.790 --> 49:50.790
圆形的影视圆形

49:50.790 --> 49:51.790
User.prototype

49:51.790 --> 49:52.790
User.prototype

49:52.790 --> 49:53.790
User.prototype

49:53.790 --> 49:54.790
User.prototype

49:54.790 --> 49:56.790
这个圆形的影视圆形

49:56.790 --> 49:58.790
这两个肯定不相等

49:58.790 --> 50:00.790
所以这个玩意是 false

50:00.790 --> 50:02.790
再下一个

50:02.790 --> 50:04.790
影视圆形的影视圆形就是刚才这个

50:04.790 --> 50:06.790
然后是不等于Object的圆形

50:06.790 --> 50:08.790
这两个是相等的

50:08.790 --> 50:10.790
从这个链条去查

50:10.790 --> 50:12.790
就查出来了

50:12.790 --> 50:13.790
最终呢

50:13.790 --> 50:17.230
我们这个提的答案就这了

50:17.230 --> 50:18.230
运行看一下

50:18.230 --> 50:23.080
是不是一样呢

50:23.080 --> 50:25.080
肯定是一样的

50:25.080 --> 50:29.670
好 这是第一题

50:29.670 --> 50:31.670
这是第一题

50:32.670 --> 50:33.670
然后下一道题

50:33.670 --> 50:37.560
第二题

50:37.560 --> 50:38.560
都是字节的一道题

50:38.560 --> 50:39.560
我们来看一下字节的道题

50:39.560 --> 50:41.560
到底有多难吗

50:41.560 --> 50:42.560
一共就试就代吧

50:42.560 --> 50:45.560
它就在考理圆形链

50:45.560 --> 50:47.560
我们看有多恐怖吗

50:47.560 --> 50:49.560
恶体一点都不恐怖

50:49.560 --> 50:50.560
首先

50:50.560 --> 50:54.560
这个玩意是啥的得搞清楚

50:54.560 --> 50:55.560
这个玩意是啥呢

50:55.560 --> 50:58.560
它是溜一个Object出来的

50:58.560 --> 51:01.560
是不是溜了一个Object出来的

51:01.560 --> 51:02.560
有这么一个东西

51:02.560 --> 51:03.560
它是溜了一个Object出来的

51:03.560 --> 51:05.560
那不会形成三角关系吗

51:05.560 --> 51:07.560
那这个东西是溜了一个Object出来的

51:07.560 --> 51:10.560
那是不是它的隐私圆形要指向这样

51:10.560 --> 51:11.560
对吧

51:11.560 --> 51:13.560
那肯定的

51:13.560 --> 51:15.560
那因此它是Object的词

51:15.560 --> 51:16.560
其实我们这个玩意

51:16.560 --> 51:18.560
你读的可以读的出来

51:18.560 --> 51:19.560
怎么读的呢

51:19.560 --> 51:20.560
就是说

51:20.560 --> 51:21.560
读的方式就是

51:21.560 --> 51:22.560
这个玩意是不是一个对象

51:22.560 --> 51:23.560
它肯定是对象嘛

51:23.560 --> 51:24.560
对吧

51:24.560 --> 51:25.560
但是我们还是用技术的角度来分析

51:25.560 --> 51:27.560
那就是圆形链的

51:27.560 --> 51:28.560
那就这个玩意

51:28.560 --> 51:29.560
就这个东西

51:29.560 --> 51:31.560
它的圆形链条上

51:31.560 --> 51:33.560
有没有Object的圆形呢

51:33.560 --> 51:35.560
它链条就这么大

51:35.560 --> 51:36.560
对吧

51:36.560 --> 51:37.560
里边是不是有Object的圆形

51:37.560 --> 51:38.560
有吗

51:38.560 --> 51:39.560
说第一个的就是

51:41.560 --> 51:42.560
你会发现大厂的面子

51:42.560 --> 51:43.560
你只要搞清楚了

51:43.560 --> 51:44.560
这搞清楚了

51:44.560 --> 51:45.560
非不要太多的劲

51:45.560 --> 51:46.560
你只要搞清楚了

51:46.560 --> 51:48.560
你就没问题了

51:48.560 --> 51:50.560
然后这个

51:50.560 --> 51:53.560
这个玩意的图示菌

51:53.560 --> 51:55.560
是啥呀

51:55.560 --> 51:56.560
这玩意的图示菌

51:56.560 --> 51:58.560
不就是这里边的图示菌吗

51:58.560 --> 52:00.560
这里边不有一个图示菌函数吗

52:00.560 --> 52:01.560
好

52:01.560 --> 52:03.560
那这一块你就好好看了

52:03.560 --> 52:05.560
你其实你要用约读的方式来说的话

52:05.560 --> 52:07.560
很容易判断出来

52:07.560 --> 52:09.560
就是这个图示菌

52:09.560 --> 52:10.560
是不是函数

52:10.560 --> 52:12.560
它肯定是吗

52:12.560 --> 52:13.560
图示菌是不是函数

52:13.560 --> 52:14.560
肯定是吗

52:14.560 --> 52:15.560
对吧

52:15.560 --> 52:17.560
那我们要用圆形链来分析的话

52:17.560 --> 52:19.560
也比较简单

52:19.560 --> 52:20.560
就这个玩意是一个图示菌

52:20.560 --> 52:21.560
图示菌在这里边

52:21.560 --> 52:23.560
但是它是一个函数

52:23.560 --> 52:24.560
函数是哪来的

52:24.560 --> 52:26.560
你把它当成自定义函数

52:26.560 --> 52:27.560
函数哪来的

52:27.560 --> 52:29.560
6的方形

52:29.560 --> 52:32.560
6的方形创建到函数

52:32.560 --> 52:34.560
图示菌也是函数吗

52:34.560 --> 52:36.560
就是6都是方形

52:36.560 --> 52:40.560
那么它的隐私圆形不应该指向这吗

52:40.560 --> 52:43.560
它链条上是不是有这个方形的圆形

52:43.560 --> 52:44.560
OK的呀

52:44.560 --> 52:45.560
没问题的呀

52:45.560 --> 52:48.560
所以第二个呢也是出

52:48.560 --> 52:50.560
第三个

52:50.560 --> 52:52.560
R不这个车

52:52.560 --> 52:54.560
是不是函数

52:54.560 --> 52:55.560
一看就知道了

52:55.560 --> 52:56.560
肯定是函数对吧

52:56.560 --> 52:58.560
所以说你平时用那种

52:58.560 --> 52:59.560
约读的方式

53:00.560 --> 53:03.560
97 98都没有什么问题

53:03.560 --> 53:04.560
就是帕拉1%

53:04.560 --> 53:05.560
2%

53:05.560 --> 53:07.560
R不这个车是函数肯定是

53:07.560 --> 53:09.560
那怎么看的圆形链

53:09.560 --> 53:10.560
这个玩意哪来的

53:10.560 --> 53:12.560
6的是方形

53:12.560 --> 53:13.560
6的是方形

53:13.560 --> 53:16.560
那它的隐私圆形不应该指向这吗

53:16.560 --> 53:17.560
所以它的圆形链条上

53:17.560 --> 53:19.560
一定有方形的圆形

53:19.560 --> 53:23.580
所以这个也是出

53:23.580 --> 53:25.580
再反过来

53:25.580 --> 53:27.580
方形是不是对象

53:27.580 --> 53:29.580
函数是不是对象

53:29.580 --> 53:32.340
函数是不是对象

53:33.340 --> 53:35.340
函数肯定是对象

53:35.340 --> 53:37.340
我们说的所有都是对象

53:37.340 --> 53:38.340
函数肯定是对象

53:38.340 --> 53:39.340
所以这个也是出

53:39.340 --> 53:41.340
那我们从圆形链怎么分析

53:41.340 --> 53:42.340
方形它的表特殊

53:42.340 --> 53:44.340
它不是通过6得来的

53:44.340 --> 53:47.340
它是介绍直行隐形启动的时候

53:47.340 --> 53:49.340
直接安进去的

53:49.340 --> 53:51.340
总的有个东西吧一开始

53:51.340 --> 53:52.340
安进去过后

53:52.340 --> 53:54.340
它就会形成一个链条

53:54.340 --> 53:55.340
它的隐私圆形比较特殊

53:55.340 --> 53:57.340
它指向自己的圆形

53:57.340 --> 53:59.340
然后它的链条是什么呢

53:59.340 --> 54:01.340
链条这里有个隐私圆形指过来

54:01.340 --> 54:03.340
你会发现它有一个OBG的圆形

54:03.340 --> 54:04.340
看到没

54:04.340 --> 54:06.340
所以它的链条上有OBG的圆形

54:06.340 --> 54:08.340
那它肯定也是出

54:08.340 --> 54:11.340
说四个值它都是出

54:11.340 --> 54:15.670
你说多复杂了

54:15.670 --> 54:16.670
也就这么样

54:16.670 --> 54:17.670
这么回事了

54:17.670 --> 54:19.670
再看一下一个京东的

54:22.670 --> 54:26.330
来吧

54:26.330 --> 54:29.330
方形里面加了一个A等于E

54:30.330 --> 54:31.330
它说哪里加的

54:31.330 --> 54:32.330
往这里加的

54:32.330 --> 54:34.330
加的是啥

54:34.330 --> 54:35.330
A等于E

54:37.330 --> 54:38.330
然后呢

54:38.330 --> 54:41.330
OBG的圆形里边加了一个B

54:41.330 --> 54:42.330
等于R

54:42.330 --> 54:43.330
这里边加了一个B

54:43.330 --> 54:45.330
等于R

54:45.330 --> 54:47.330
你说要做到哪儿加的

54:47.330 --> 54:49.330
其实你做多了的话

54:49.330 --> 54:50.330
这东西你搞熟了

54:50.330 --> 54:52.330
你都不用画图了

54:52.330 --> 54:54.330
因为脑袋里边都有自己

54:54.330 --> 54:55.330
都有图了

54:55.330 --> 54:57.330
然后来定义那个字定义还说A

54:57.330 --> 54:59.330
那就是个字定义还说A

54:59.330 --> 55:01.330
就是这个玩意儿

55:02.330 --> 55:04.330
然后呢溜了一个A

55:04.330 --> 55:06.330
那个溜的个A就在这儿

55:07.330 --> 55:08.330
好

55:08.330 --> 55:09.330
这里是属性

55:09.330 --> 55:10.330
换个颜色吧

55:11.330 --> 55:12.330
换个颜色的了

55:12.330 --> 55:14.330
这是A

55:15.330 --> 55:16.330
画得不好

55:17.330 --> 55:18.330
讲究看

55:18.330 --> 55:21.330
然后A点A

55:21.330 --> 55:23.330
A点A是啥

55:23.330 --> 55:25.330
找这个A的属性A

55:25.330 --> 55:26.330
它里面有属性吗

55:26.330 --> 55:27.330
啥属性都没有

55:27.330 --> 55:28.330
那粘条上找呗

55:28.330 --> 55:30.330
粘条上这里有属性A吗

55:30.330 --> 55:31.330
没有

55:31.330 --> 55:32.330
这里有属性A吗

55:32.330 --> 55:33.330
没有

55:34.330 --> 55:35.330
第一个是啥

55:35.330 --> 55:37.330
第一个是undefined

55:37.330 --> 55:40.830
再看第二个

55:40.830 --> 55:41.830
A点B

55:41.830 --> 55:42.830
它里面有B吗

55:42.830 --> 55:43.830
没有B

55:43.830 --> 55:44.830
它这里面有B吗

55:44.830 --> 55:45.830
没有B

55:45.830 --> 55:46.830
这里面有B

55:46.830 --> 55:47.830
结果是多少

55:47.830 --> 55:48.830
2

55:48.830 --> 55:50.830
所以得到2

55:50.830 --> 55:51.830
然后下一个

55:51.830 --> 55:53.830
大写的A点A

55:53.830 --> 55:55.830
得到是这个玩意儿里面的属性

55:55.830 --> 55:56.830
它这边有属性吗

55:56.830 --> 55:57.830
没有

55:57.830 --> 55:58.830
粘条上找

55:58.830 --> 56:00.830
粘条上有A吗

56:00.830 --> 56:02.830
有一个A

56:02.830 --> 56:03.830
是多少

56:03.830 --> 56:04.830
1

56:04.830 --> 56:06.830
那就是1

56:06.830 --> 56:07.830
好下来一个

56:07.830 --> 56:08.830
A点B

56:08.830 --> 56:09.830
它里面有B吗

56:09.830 --> 56:10.830
没有

56:10.830 --> 56:11.830
粘条上找

56:11.830 --> 56:12.830
有B吗

56:12.830 --> 56:13.830
没有

56:13.830 --> 56:14.830
粘条上找

56:14.830 --> 56:15.830
有B吗

56:15.830 --> 56:16.830
有

56:16.830 --> 56:17.830
你看这个粘条

56:17.830 --> 56:18.830
你是原型的粘条

56:18.830 --> 56:21.140
有B吗

56:21.140 --> 56:22.140
有2

56:22.140 --> 56:25.650
得到结果就是

56:25.650 --> 56:26.650
这个

56:26.650 --> 56:27.650
怎么复杂的

56:27.650 --> 56:29.650
你只要能画出这个图

56:29.650 --> 56:30.650
原型粘这一块

56:30.650 --> 56:32.650
当然你如果说能够再配合

56:32.650 --> 56:33.650
我们

56:33.650 --> 56:34.650
后边要学习的

56:34.650 --> 56:36.650
以后要学习的一些

56:36.650 --> 56:37.650
跟原型链相关的一些

56:37.650 --> 56:38.650
API

56:38.650 --> 56:39.650
它做这种题是无敌的

56:39.650 --> 56:40.650
真的就是无敌的

56:40.650 --> 56:42.650
它还能怎么样吗

56:42.650 --> 56:43.650
它只能做到这样子的

56:43.650 --> 56:44.650
它在网上

56:44.650 --> 56:45.650
我伸动

56:45.650 --> 56:47.650
挖去挖V8隐形的

56:47.650 --> 56:48.650
到现年

56:48.650 --> 56:50.650
你们去挖那个

56:50.650 --> 56:52.650
没有这个必要

56:52.650 --> 56:56.050
好吧

56:56.050 --> 56:57.050
这就是第一部分

56:57.050 --> 56:58.050
原型

56:58.050 --> 56:59.050
原型链

56:59.050 --> 57:02.420
就玩这个东西

57:02.420 --> 57:03.420
好

57:03.420 --> 57:04.420
这一块能听懂吗

57:04.420 --> 57:05.420
能听懂

57:05.420 --> 57:08.420
等下来还稍好去消化

57:08.420 --> 57:09.420
我喝喝水

57:09.420 --> 57:13.080
好

57:13.080 --> 57:14.080
第二部分

57:15.080 --> 57:19.380
第二部分

57:19.380 --> 57:24.220
Z的指向

57:24.220 --> 57:26.220
Z的指向

57:26.220 --> 57:31.690
你只要记住一句话

57:31.690 --> 57:33.690
寒树中的Z

57:34.690 --> 57:36.690
只能

57:36.690 --> 57:39.690
在寒树雕用的时候

57:39.690 --> 57:40.690
才能确定

57:40.690 --> 57:44.260
凡来复去读一下那句话

57:44.260 --> 57:46.260
寒树中的Z

57:46.260 --> 57:50.260
只能在寒树雕用的时候

57:50.260 --> 57:51.260
才能确定

57:51.260 --> 57:53.260
只能

57:54.260 --> 57:57.260
所以不要再去问这种问题了

57:57.260 --> 58:02.620
我问一下同学们

58:02.620 --> 58:11.820
这里边的Z是指向谁

58:12.820 --> 58:14.820
这里边的Z是指向谁

58:15.820 --> 58:23.160
因为同学知道

58:23.160 --> 58:24.160
指向谁

58:32.410 --> 58:33.410
对了

58:33.410 --> 58:35.410
不确定

58:35.410 --> 58:37.410
他不确定

58:37.410 --> 58:38.410
不知道指向谁

58:38.410 --> 58:39.410
为什么不知道

58:39.410 --> 58:41.410
我雕用了吗

58:41.410 --> 58:42.410
我有雕用他吗

58:42.410 --> 58:44.410
没有吧

58:44.410 --> 58:45.410
没有雕用他

58:45.410 --> 58:46.410
那他没有雕用

58:46.410 --> 58:48.410
我咋知道指向谁

58:48.410 --> 58:49.410
我可能第一次雕用

58:49.410 --> 58:50.410
这么雕用

58:50.410 --> 58:51.410
他只想有一个东西

58:51.410 --> 58:53.410
我下一次雕用那么雕用

58:53.410 --> 58:55.410
他又指向别的东西了

58:55.410 --> 58:58.410
只有在雕用的时候

58:58.410 --> 59:00.410
就Z的指向确定了

59:00.410 --> 59:03.410
我根本这样子再说直白一点

59:03.410 --> 59:05.410
昨天我们不是学了那个

59:05.410 --> 59:07.410
叫做

59:07.410 --> 59:09.410
执行上下文吗

59:09.410 --> 59:11.410
执行上下文里边

59:11.410 --> 59:13.410
我们只想了谁

59:13.410 --> 59:17.360
只想了AO

59:17.360 --> 59:18.360
就是我们说那个

59:18.360 --> 59:19.360
登革跑步的时候

59:19.360 --> 59:21.360
是不是要做一些准备

59:21.360 --> 59:23.360
其中一个重要的准备

59:23.360 --> 59:24.360
就准备AO

59:24.360 --> 59:26.360
其实还有别的准备

59:26.360 --> 59:28.360
还有什么准备

59:28.360 --> 59:31.800
确定Z是指向

59:31.800 --> 59:32.800
他说我们

59:32.800 --> 59:34.800
昨天说那个执行上下文

59:34.800 --> 59:35.800
是什么时候

59:35.800 --> 59:36.800
创建的执行上下文

59:36.800 --> 59:40.800
是在雕用函数的时候

59:40.800 --> 59:42.800
Z的指向什么时候才能确定

59:42.800 --> 59:44.800
只有在雕用函数的时候

59:44.800 --> 59:45.800
才能确定

59:45.800 --> 59:47.800
没雕用不能确定

59:47.800 --> 59:51.110
这个一定要牢牢记住

59:51.110 --> 59:53.110
所以说我们只需要关注

59:53.110 --> 59:55.110
有哪些雕用情况

59:55.110 --> 59:56.110
是不是就完了

59:56.110 --> 59:57.110
这样雕用

59:57.110 --> 59:58.110
他的Z是指向谁

59:58.110 --> 59:59.110
另外一种雕用

59:59.110 --> 01:00:00.110
他Z是指向谁

01:00:00.110 --> 01:00:03.420
只需要关注这个就行了

01:00:03.420 --> 01:00:04.420
我们来看一下

01:00:04.420 --> 01:00:05.420
有哪些情况呢

01:00:06.420 --> 01:00:09.950
有四种情况

01:00:09.950 --> 01:00:11.950
然后记住一些关键点

01:00:11.950 --> 01:00:13.950
可能有些比较特殊的

01:00:13.950 --> 01:00:14.950
容易考虑的

01:00:14.950 --> 01:00:15.950
容易耳心理的

01:00:15.950 --> 01:00:16.950
其他都是比较正常的

01:00:16.950 --> 01:00:18.950
就平时写代码的时候

01:00:18.950 --> 01:00:20.950
只有这四种情况

01:00:20.950 --> 01:00:22.950
一个是全局对象温斗

01:00:22.950 --> 01:00:23.950
指向谁

01:00:23.950 --> 01:00:24.950
全局对象温斗

01:00:24.950 --> 01:00:25.950
什么情况下

01:00:25.950 --> 01:00:26.950
会指向全局对象温斗

01:00:26.950 --> 01:00:28.950
一个是雕用函数

01:00:28.950 --> 01:00:30.950
直接雕用

01:00:30.950 --> 01:00:31.950
就前面写个函数

01:00:31.950 --> 01:00:32.950
后面直接雕用

01:00:32.950 --> 01:00:34.950
这种情况他就会指向

01:00:34.950 --> 01:00:36.950
这个函数里边的Z

01:00:36.950 --> 01:00:38.950
就会指向全局对象温斗

01:00:39.950 --> 01:00:41.950
那也就意味着

01:00:41.950 --> 01:00:42.950
比方说

01:00:42.950 --> 01:00:43.950
我这里呢

01:00:43.950 --> 01:00:44.950
就输出Z吧

01:00:44.950 --> 01:00:46.950
我也不去搞那些花里胡哨的

01:00:47.950 --> 01:00:49.950
我们在那浏览器里面运行

01:00:49.950 --> 01:00:50.950
现在就不能在那个

01:00:50.950 --> 01:00:52.950
漏的环境里面运行了

01:00:52.950 --> 01:00:53.950
不要在漏的环境里面运行了

01:00:53.950 --> 01:00:55.950
我这里是在漏的环境里面

01:00:55.950 --> 01:00:57.950
你们以后要学新漏的的

01:00:57.950 --> 01:00:58.950
因为漏的环境

01:00:58.950 --> 01:00:59.950
跟浏览器环境

01:00:59.950 --> 01:01:01.950
在Z最方便的

01:01:01.950 --> 01:01:02.950
有一些细微的区别

01:01:02.950 --> 01:01:03.950
区别倒不是很大

01:01:03.950 --> 01:01:05.950
但是会影响我们作题

01:01:05.950 --> 01:01:06.950
我这里有个函数

01:01:06.950 --> 01:01:07.950
Z

01:01:07.950 --> 01:01:08.950
Z是指向谁

01:01:08.950 --> 01:01:09.950
不知道

01:01:09.950 --> 01:01:10.950
我没有必要用它

01:01:10.950 --> 01:01:11.950
如果说直接掉到Z

01:01:11.950 --> 01:01:12.950
你看Z是指向谁

01:01:12.950 --> 01:01:13.950
指向温斗

01:01:13.950 --> 01:01:15.950
对吧

01:01:15.950 --> 01:01:16.950
这是

01:01:16.950 --> 01:01:17.950
那么还有什么情况下

01:01:17.950 --> 01:01:18.950
会指向温斗呢

01:01:18.950 --> 01:01:20.950
还有就是你直接写Z

01:01:21.950 --> 01:01:23.950
只在全局里面使用Z

01:01:23.950 --> 01:01:25.950
它会指向温斗

01:01:25.950 --> 01:01:26.950
它没有函数

01:01:26.950 --> 01:01:28.950
它直接指向温斗

01:01:28.950 --> 01:01:31.950
这种情况它是指向温斗的

01:01:31.950 --> 01:01:33.950
你别以为一个大写字母了

01:01:33.950 --> 01:01:35.950
它就变成了什么一个新对象了

01:01:36.950 --> 01:01:37.950
好

01:01:37.950 --> 01:01:39.950
第二种调用方式

01:01:39.950 --> 01:01:40.950
通过啥啥啥

01:01:40.950 --> 01:01:42.950
点啥啥啥

01:01:42.950 --> 01:01:44.950
这个是个函数

01:01:44.950 --> 01:01:46.950
前面可能一坨

01:01:46.950 --> 01:01:48.950
比方说我们前面可能有多种写法

01:01:49.950 --> 01:01:51.950
前面可能是OB界点M

01:01:51.950 --> 01:01:53.950
那么这个M里面的Z

01:01:53.950 --> 01:01:54.950
指向谁

01:01:54.950 --> 01:01:55.950
指向OB界

01:01:55.950 --> 01:01:57.950
OB界点A

01:01:57.950 --> 01:01:58.950
点B

01:01:58.950 --> 01:01:59.950
点C

01:01:59.950 --> 01:02:00.950
点D

01:02:00.950 --> 01:02:01.950
点E

01:02:02.950 --> 01:02:03.950
这个函数里面

01:02:03.950 --> 01:02:04.950
它的Z是指向谁

01:02:04.950 --> 01:02:05.950
指向Z

01:02:06.950 --> 01:02:08.950
指向这个表达式的结果

01:02:08.950 --> 01:02:09.950
再说直白点

01:02:09.950 --> 01:02:10.950
指向F

01:02:10.950 --> 01:02:11.950
指向这里

01:02:11.950 --> 01:02:12.950
它属性A的

01:02:12.950 --> 01:02:13.950
属性B的

01:02:13.950 --> 01:02:14.950
它属性C的

01:02:14.950 --> 01:02:15.950
属性D的

01:02:15.950 --> 01:02:16.950
属性E的

01:02:16.950 --> 01:02:17.950
属性F

01:02:17.950 --> 01:02:19.950
指向的是个属性F

01:02:19.950 --> 01:02:21.950
看你怎么去调用它

01:02:22.950 --> 01:02:23.950
那么这就解释了

01:02:23.950 --> 01:02:26.950
刚才我们这个点

01:02:26.950 --> 01:02:28.950
比方说我们这里

01:02:28.950 --> 01:02:30.950
在User里面写一个Prototab

01:02:30.950 --> 01:02:32.950
点Test

01:02:32.950 --> 01:02:36.900
而且这么一个玩意

01:02:36.900 --> 01:02:37.900
说出Z

01:02:38.900 --> 01:02:40.900
它这里的Z是指向谁

01:02:40.900 --> 01:02:41.900
我又来问大家

01:02:41.900 --> 01:02:43.900
这里的Z是指向谁

01:02:43.900 --> 01:02:50.380
来

01:02:50.380 --> 01:02:55.380
想一想

01:03:00.860 --> 01:03:04.300
不要被我绕进去了

01:03:04.300 --> 01:03:06.300
我调用了吗

01:03:06.300 --> 01:03:07.300
我没调用吗

01:03:08.300 --> 01:03:09.300
没调用它

01:03:10.300 --> 01:03:12.300
也不能确定

01:03:12.300 --> 01:03:14.300
那就看这个函数打调用的

01:03:14.300 --> 01:03:16.300
我们在浏览器里面

01:03:16.300 --> 01:03:18.300
把东西写出来

01:03:18.300 --> 01:03:20.300
接下来我们看吧

01:03:20.300 --> 01:03:22.300
如果说我创建一个User

01:03:22.300 --> 01:03:24.300
留一个User

01:03:24.300 --> 01:03:25.300
我怎么调用呢

01:03:25.300 --> 01:03:26.300
因为我们知道有隐私原型存在

01:03:26.300 --> 01:03:28.300
所以说它这里可以直接调用Test

01:03:28.300 --> 01:03:29.300
这个说过了

01:03:29.300 --> 01:03:30.300
三角关系

01:03:30.300 --> 01:03:32.300
它里面有隐私原型指向

01:03:32.300 --> 01:03:34.300
这里面有Test函数

01:03:34.300 --> 01:03:35.300
那这个Z是指向谁

01:03:35.300 --> 01:03:36.300
它就指向这个U

01:03:36.300 --> 01:03:37.300
你看

01:03:37.300 --> 01:03:38.300
是不是得到这个U

01:03:38.300 --> 01:03:39.300
它输出了是吧

01:03:39.300 --> 01:03:40.300
输出了这个Z

01:03:40.300 --> 01:03:42.300
它不是得到个U吗

01:03:43.300 --> 01:03:45.300
如果说

01:03:45.300 --> 01:03:47.300
我用这种方式来调用

01:03:47.300 --> 01:03:53.300
User.frototap.test

01:03:53.300 --> 01:03:54.300
可以吗

01:03:54.300 --> 01:03:55.300
肯定是可以

01:03:55.300 --> 01:03:57.300
我把它放到Prototype里面

01:03:57.300 --> 01:03:58.300
那这样点

01:03:58.300 --> 01:04:00.300
它会指向内的

01:04:00.300 --> 01:04:02.300
指向User的

01:04:02.300 --> 01:04:03.300
原型对象

01:04:03.300 --> 01:04:04.300
你看

01:04:04.300 --> 01:04:07.300
原型对象里面不有个Test吗

01:04:07.300 --> 01:04:09.300
所以说完全看

01:04:09.300 --> 01:04:10.300
这个函数怎么调用的

01:04:11.300 --> 01:04:13.300
或者我就这样子来玩

01:04:13.300 --> 01:04:14.300
我把那个

01:04:14.300 --> 01:04:15.300
你看说文法

01:04:15.300 --> 01:04:16.300
特别特别多

01:04:16.300 --> 01:04:19.300
介石是一个非常灵活的语言

01:04:19.300 --> 01:04:20.300
Test

01:04:20.300 --> 01:04:21.300
它不是一个函数

01:04:21.300 --> 01:04:22.300
对吧

01:04:22.300 --> 01:04:23.300
我们刚才写的Test

01:04:23.300 --> 01:04:24.300
这个函数

01:04:24.300 --> 01:04:25.300
我把它保持到变量T里边

01:04:25.300 --> 01:04:27.300
我单独的去调用T

01:04:27.300 --> 01:04:28.300
它又指向谁了

01:04:28.300 --> 01:04:29.300
你看它怎么调用

01:04:29.300 --> 01:04:30.300
它这样的调用的

01:04:30.300 --> 01:04:31.300
它指向谁

01:04:31.300 --> 01:04:32.300
指向Windows

01:04:32.300 --> 01:04:34.300
你不知道它指向谁

01:04:34.300 --> 01:04:36.300
所以说介石

01:04:36.300 --> 01:04:37.300
它的灵活性

01:04:37.300 --> 01:04:38.300
也带来了一些问题

01:04:38.300 --> 01:04:42.300
就是老师出问题

01:04:42.300 --> 01:04:43.300
你只要函数

01:04:43.300 --> 01:04:44.300
设计到Test

01:04:44.300 --> 01:04:46.300
你没有按照它想的方式

01:04:46.300 --> 01:04:47.300
去调用

01:04:47.300 --> 01:04:49.300
它可能就会出问题

01:04:49.300 --> 01:04:50.300
我们这样子写的

01:04:50.300 --> 01:04:52.300
就希望说

01:04:52.300 --> 01:04:54.300
你就老老实实调用

01:04:54.300 --> 01:04:57.300
你就做个正常人吧

01:04:57.300 --> 01:04:59.300
有人不当要去当狗

01:04:59.300 --> 01:05:01.300
你就这样调用

01:05:01.300 --> 01:05:02.300
行不行

01:05:02.300 --> 01:05:03.300
你一定要去搞那些花出来

01:05:03.300 --> 01:05:04.300
搞那些花出来

01:05:04.300 --> 01:05:05.300
就导致在Test的

01:05:05.300 --> 01:05:07.300
指向乱七八糟

01:05:08.300 --> 01:05:10.300
但是有些人他就要搞玩花

01:05:10.300 --> 01:05:11.300
那玩花的话

01:05:11.300 --> 01:05:12.300
Test肯定要乱

01:05:12.300 --> 01:05:13.300
没办法

01:05:13.300 --> 01:05:15.300
介石就是这么一回事

01:05:15.300 --> 01:05:17.810
就是这样的

01:05:17.810 --> 01:05:19.810
第二种情况

01:05:19.810 --> 01:05:20.810
通过SATA

01:05:20.810 --> 01:05:21.810
对象去调用

01:05:21.810 --> 01:05:23.810
它就指向最近的调用者

01:05:23.810 --> 01:05:24.810
谁在调用它

01:05:24.810 --> 01:05:25.810
是指向谁

01:05:25.810 --> 01:05:26.810
好 下一种情况

01:05:26.810 --> 01:05:28.810
New

01:05:28.810 --> 01:05:33.120
这就一定是指向一个新对象

01:05:33.120 --> 01:05:34.120
这个玩意

01:05:34.120 --> 01:05:35.120
你们学过构造函数

01:05:35.120 --> 01:05:36.120
都知道

01:05:36.120 --> 01:05:37.120
同一个New

01:05:37.120 --> 01:05:38.120
当它当成构造函数

01:05:38.120 --> 01:05:39.120
在调用的时候

01:05:39.120 --> 01:05:41.120
一个函数M里面的东西

01:05:41.120 --> 01:05:43.120
它有一定指向新对象

01:05:43.120 --> 01:05:44.120
这就不说了

01:05:44.120 --> 01:05:46.120
你们都知道构造函数

01:05:46.120 --> 01:05:48.120
还有这种情况

01:05:48.120 --> 01:05:49.120
绑定者

01:05:49.120 --> 01:05:50.120
是什么意思呢

01:05:50.120 --> 01:05:51.120
就是有的时候

01:05:51.120 --> 01:05:53.120
我们可能调用函数

01:05:53.120 --> 01:05:55.120
不一定是

01:05:55.120 --> 01:05:57.120
用一个函数名字

01:05:57.120 --> 01:05:59.120
加上两个小型号来调用

01:05:59.120 --> 01:06:01.120
我们可能用这种方式来调用

01:06:01.120 --> 01:06:03.120
那么

01:06:03.120 --> 01:06:05.120
这三种方式

01:06:05.120 --> 01:06:07.120
都可以手动的更改

01:06:07.120 --> 01:06:10.120
Z的指向

01:06:10.120 --> 01:06:12.120
比方说M4的函数

01:06:12.120 --> 01:06:13.120
我这样调用函数

01:06:13.120 --> 01:06:15.120
可不可以M点Core

01:06:15.120 --> 01:06:17.120
Core什么就是调用的意思

01:06:17.120 --> 01:06:18.120
Core是哪的

01:06:18.120 --> 01:06:20.120
其实Core在这

01:06:21.120 --> 01:06:23.120
Core在这

01:06:23.120 --> 01:06:24.120
在这里边

01:06:24.120 --> 01:06:25.120
每个函数

01:06:25.120 --> 01:06:26.120
它里面都有Core方法

01:06:26.120 --> 01:06:28.120
因为它在这

01:06:28.120 --> 01:06:30.120
每个函数里面都有Apply方法

01:06:30.120 --> 01:06:31.120
因为它在这

01:06:31.120 --> 01:06:33.120
每个函数里面都有Band的方法

01:06:33.120 --> 01:06:35.120
因为它在这

01:06:35.120 --> 01:06:36.120
那么这里

01:06:36.120 --> 01:06:37.120
你看

01:06:37.120 --> 01:06:38.120
任何函数都有Core

01:06:38.120 --> 01:06:40.120
任何函数都有Apply

01:06:40.120 --> 01:06:42.120
任何函数都有Band

01:06:42.120 --> 01:06:44.120
就是这个原因

01:06:44.120 --> 01:06:46.120
这三个函数的作用就是

01:06:46.120 --> 01:06:47.120
来更改Z的指向

01:06:47.120 --> 01:06:49.120
就是你手动指定

01:06:49.120 --> 01:06:50.120
哪里

01:06:50.120 --> 01:06:52.120
这种手动指定的

01:06:52.120 --> 01:06:53.120
那就对大了

01:06:53.120 --> 01:06:54.120
你指定谁

01:06:54.120 --> 01:06:55.120
它就调用谁

01:06:55.120 --> 01:06:56.120
什么意思

01:06:56.120 --> 01:06:57.120
你传一个东西进去

01:06:57.120 --> 01:06:58.120
那么

01:06:58.120 --> 01:07:00.120
我就运行这个函数

01:07:00.120 --> 01:07:01.120
运行的期间

01:07:01.120 --> 01:07:03.120
我的Z是指向它

01:07:04.120 --> 01:07:06.120
你传一个东西进去

01:07:06.120 --> 01:07:07.120
我就运行这个函数

01:07:07.120 --> 01:07:09.120
运行期间的Z

01:07:09.120 --> 01:07:11.120
指向它

01:07:11.120 --> 01:07:14.620
这两个有啥区别呢

01:07:14.620 --> 01:07:16.620
这两个玩意有啥区别呢

01:07:16.620 --> 01:07:17.620
这两个玩意

01:07:17.620 --> 01:07:18.620
如果说你指传一个Z

01:07:18.620 --> 01:07:19.620
它没有区别

01:07:19.620 --> 01:07:20.620
都一样的

01:07:21.620 --> 01:07:22.620
但是后续参数

01:07:22.620 --> 01:07:23.620
可能不一样

01:07:23.620 --> 01:07:24.620
这个玩意不知道你们

01:07:25.620 --> 01:07:27.620
之前也没有学习过

01:07:28.620 --> 01:07:30.620
简单说一下吧

01:07:30.620 --> 01:07:32.620
信息量非常密集

01:07:32.620 --> 01:07:33.620
这几天的课程

01:07:33.620 --> 01:07:35.620
你们下去要好好消化

01:07:35.620 --> 01:07:37.620
因为集训营嘛

01:07:37.620 --> 01:07:38.620
而且呢

01:07:38.620 --> 01:07:39.620
是介绍讲

01:07:39.620 --> 01:07:40.620
比面试的集训营

01:07:40.620 --> 01:07:42.620
我尽量多给你们一点

01:07:42.620 --> 01:07:44.620
然后你们下来慢慢就消化

01:07:45.620 --> 01:07:47.620
正常按照那个

01:07:47.620 --> 01:07:48.620
正常的上课节奏的话

01:07:48.620 --> 01:07:49.620
肯定是

01:07:49.620 --> 01:07:50.620
这是好几天的课程

01:07:50.620 --> 01:07:51.620
或者说一天

01:07:51.620 --> 01:07:52.620
就要搞定的

01:07:52.620 --> 01:07:54.620
那肯定是不行的

01:07:54.620 --> 01:07:55.620
好

01:07:55.620 --> 01:07:56.620
那么这里比方说

01:07:56.620 --> 01:07:59.620
是有一个函数吧

01:07:59.620 --> 01:08:01.620
我就随便下这个函数

01:08:03.620 --> 01:08:06.620
我就输出一个ZS

01:08:06.620 --> 01:08:07.620
A和B

01:08:07.620 --> 01:08:08.620
就这么简单

01:08:08.620 --> 01:08:09.620
输出这三个

01:08:09.620 --> 01:08:11.620
然后我怎么

01:08:11.620 --> 01:08:13.620
我用那个扣来调用

01:08:13.620 --> 01:08:14.620
扣

01:08:14.620 --> 01:08:18.190
说要传个ZS

01:08:18.190 --> 01:08:20.190
说要传个ZS

01:08:20.190 --> 01:08:22.190
ZS我就传1

01:08:22.190 --> 01:08:24.190
表现你ZS的绑定就是1

01:08:24.190 --> 01:08:26.190
把1作为ZS来走一遍

01:08:26.190 --> 01:08:28.190
那ZS变成1了

01:08:28.190 --> 01:08:29.190
好

01:08:29.190 --> 01:08:30.190
A和B呢

01:08:30.190 --> 01:08:32.190
我就传23

01:08:32.190 --> 01:08:33.190
好看一下

01:08:34.190 --> 01:08:35.190
运行

01:08:35.190 --> 01:08:36.190
是1

01:08:36.190 --> 01:08:37.190
23

01:08:37.190 --> 01:08:38.190
好

01:08:38.190 --> 01:08:39.190
那么这里还有一个小细节

01:08:39.190 --> 01:08:41.190
它会把你的原式内形

01:08:41.190 --> 01:08:43.190
因为1是原式内形

01:08:43.190 --> 01:08:45.190
而ZS呢

01:08:45.190 --> 01:08:47.190
它要把它转为对象

01:08:47.190 --> 01:08:49.190
它把它做成包装内形对象

01:08:49.190 --> 01:08:50.190
那有的人说

01:08:50.190 --> 01:08:51.190
什么叫包装内形

01:08:51.190 --> 01:08:52.190
什么叫原式内形

01:08:52.190 --> 01:08:54.190
那真的是讲不完了

01:08:54.190 --> 01:08:56.190
然后我把基础过程来看一下

01:08:57.190 --> 01:08:58.190
好

01:08:58.190 --> 01:08:59.190
那么这是

01:08:59.190 --> 01:09:01.190
这一颗

01:09:01.190 --> 01:09:02.190
而Ply有什么区别呢

01:09:02.190 --> 01:09:04.190
而Ply的区别就站在这里

01:09:04.190 --> 01:09:06.190
第一个ZS的指向还是

01:09:06.190 --> 01:09:07.190
第一个参数

01:09:07.190 --> 01:09:08.190
作为ZS

01:09:08.190 --> 01:09:09.190
想传啥传啥

01:09:09.190 --> 01:09:10.190
无所谓

01:09:10.190 --> 01:09:12.190
关键是后边

01:09:12.190 --> 01:09:13.190
后边你要把后边的参数

01:09:13.190 --> 01:09:14.190
包到一个

01:09:14.190 --> 01:09:15.190
中复号里边

01:09:15.190 --> 01:09:17.190
用数组来传进去

01:09:17.190 --> 01:09:18.190
它就这个区别

01:09:18.190 --> 01:09:20.190
后就是一次来

01:09:20.190 --> 01:09:22.190
罗列后边的参数

01:09:22.190 --> 01:09:23.190
而Ply呢

01:09:23.190 --> 01:09:24.190
就是直接把参数

01:09:24.190 --> 01:09:25.190
放到数组里边

01:09:25.190 --> 01:09:26.190
结果都是一样的

01:09:26.190 --> 01:09:27.190
把2给A

01:09:27.190 --> 01:09:28.190
3呢给B

01:09:28.190 --> 01:09:29.190
这下边也是一样

01:09:29.190 --> 01:09:30.190
把2给A

01:09:30.190 --> 01:09:31.190
3给B

01:09:33.190 --> 01:09:34.190
其他没有区别

01:09:35.190 --> 01:09:36.190
懂了吗

01:09:36.190 --> 01:09:37.190
就是Call和而Ply

01:09:38.190 --> 01:09:39.190
那么这两个东西

01:09:39.190 --> 01:09:40.190
都是可以更改

01:09:40.190 --> 01:09:42.190
手动的去指定ZS

01:09:43.190 --> 01:09:44.190
好

01:09:44.190 --> 01:09:46.190
然后还有一个方法叫做Band

01:09:47.190 --> 01:09:48.190
Band

01:09:48.190 --> 01:09:49.190
这个玩意儿

01:09:49.190 --> 01:09:51.190
也可以手动指定ZS

01:09:51.190 --> 01:09:52.190
比如指定一个E

01:09:55.190 --> 01:09:56.190
然后它会反

01:09:56.190 --> 01:09:57.190
这个玩意儿

01:09:57.190 --> 01:09:58.190
它的特殊点就代表

01:09:58.190 --> 01:10:00.190
它会反回一个新方法

01:10:00.190 --> 01:10:01.190
用一个NewTest

01:10:01.190 --> 01:10:03.190
一个新函数

01:10:03.190 --> 01:10:04.190
这个玩意儿

01:10:04.190 --> 01:10:05.190
会得到一个新函数

01:10:05.190 --> 01:10:07.190
得到新函数

01:10:07.190 --> 01:10:10.190
新的函数ZS

01:10:10.190 --> 01:10:15.100
被固定了

01:10:15.100 --> 01:10:16.100
那么这个函数的ZS

01:10:16.100 --> 01:10:17.100
是可以确定的

01:10:17.100 --> 01:10:18.100
是谁啊

01:10:18.100 --> 01:10:19.100
是1

01:10:19.100 --> 01:10:21.100
我们要用一个新函数

01:10:21.100 --> 01:10:23.100
要用那个NewTest

01:10:23.100 --> 01:10:24.100
来传一个2和3

01:10:24.100 --> 01:10:25.100
这2和3

01:10:25.100 --> 01:10:26.100
就传给A和B了

01:10:26.100 --> 01:10:27.100
看到没

01:10:27.100 --> 01:10:29.100
这2和3

01:10:29.100 --> 01:10:30.100
2

01:10:30.100 --> 01:10:31.100
3

01:10:31.100 --> 01:10:32.100
就传给A和B了

01:10:32.100 --> 01:10:33.100
然后ZS

01:10:33.100 --> 01:10:35.100
由于之前就固定好了

01:10:35.100 --> 01:10:36.100
固定为1了

01:10:36.100 --> 01:10:37.100
所以说

01:10:37.100 --> 01:10:38.100
得到了还是1

01:10:38.100 --> 01:10:39.100
2

01:10:39.100 --> 01:10:40.100
3

01:10:40.100 --> 01:10:41.100
这是Band

01:10:41.100 --> 01:10:43.100
这里就有疑问了

01:10:43.100 --> 01:10:45.100
不是说

01:10:45.100 --> 01:10:48.100
我们ZS的指向取决于啥

01:10:48.100 --> 01:10:49.100
取决于函数的调用吗

01:10:49.100 --> 01:10:50.100
你看你

01:10:50.100 --> 01:10:51.100
这里是这样调用的

01:10:51.100 --> 01:10:52.100
但是ZS

01:10:52.100 --> 01:10:54.100
应该指向Windows才对

01:10:55.100 --> 01:10:56.100
刚才说了

01:10:56.100 --> 01:10:58.100
是不是有什么特殊情况

01:10:58.100 --> 01:10:59.100
没有特殊情况

01:11:00.100 --> 01:11:01.100
最后我们没办法

01:11:01.100 --> 01:11:02.100
再去多讲了

01:11:02.100 --> 01:11:03.100
时间的关系

01:11:04.100 --> 01:11:05.100
同时多关注我们

01:11:05.100 --> 01:11:06.100
杜一的课程

01:11:06.100 --> 01:11:07.100
有的时候

01:11:07.100 --> 01:11:09.100
我们下午会有一些微客

01:11:09.100 --> 01:11:10.100
我们有的时候

01:11:10.100 --> 01:11:11.100
微客里边

01:11:11.100 --> 01:11:12.100
还有包括我们群里边

01:11:12.100 --> 01:11:14.100
还有很多的美日议题

01:11:14.100 --> 01:11:15.100
我都记得

01:11:15.100 --> 01:11:17.100
我的印象都不只一次的

01:11:17.100 --> 01:11:19.100
有老师讲到这个了

01:11:19.100 --> 01:11:21.100
Band他到底是怎么做的

01:11:21.100 --> 01:11:22.100
让你去

01:11:22.100 --> 01:11:23.100
我们还

01:11:23.100 --> 01:11:24.100
实现了一次Band的原码

01:11:24.100 --> 01:11:26.100
就我自己熟悉一个Band出来

01:11:26.100 --> 01:11:27.100
又知道了他为什么

01:11:27.100 --> 01:11:28.100
会有这样的现象

01:11:29.100 --> 01:11:30.100
实际上

01:11:30.100 --> 01:11:32.100
他调这个函数

01:11:33.100 --> 01:11:35.100
不是直接运行的这个函数

01:11:35.100 --> 01:11:37.100
简单给你们说一下就行了

01:11:37.100 --> 01:11:41.020
那么就

01:11:41.020 --> 01:11:42.020
以前就只需要知道

01:11:42.020 --> 01:11:43.020
Band他在一开始

01:11:43.020 --> 01:11:44.020
在Band的时候

01:11:44.020 --> 01:11:45.020
他虽然这一步

01:11:45.020 --> 01:11:46.020
没有执行函数

01:11:46.020 --> 01:11:47.020
他不像Core

01:11:47.020 --> 01:11:48.020
不像Alpine

01:11:48.020 --> 01:11:49.020
他会执行函数

01:11:49.020 --> 01:11:50.020
他这里没有执行函数

01:11:50.020 --> 01:11:52.020
他会返回一个新函数

01:11:52.020 --> 01:11:54.020
但这个新函数的ZS

01:11:54.020 --> 01:11:55.020
被固定了

01:11:56.020 --> 01:11:58.020
改不了了

01:11:59.020 --> 01:12:01.020
这是这一块

01:12:02.020 --> 01:12:03.020
那么最后

01:12:04.020 --> 01:12:06.020
知道一个就是注意点就行了

01:12:06.020 --> 01:12:08.020
以及一个监统函数就行了

01:12:09.020 --> 01:12:10.020
注意点就是

01:12:10.020 --> 01:12:11.020
使用Band的时候

01:12:11.020 --> 01:12:12.020
得到了新函数

01:12:12.020 --> 01:12:14.020
无法通过其他方式

01:12:14.020 --> 01:12:15.020
再次修改ZS

01:12:15.020 --> 01:12:16.020
但是6除外

01:12:16.020 --> 01:12:17.020
啥意思

01:12:17.020 --> 01:12:18.020
就是你这里

01:12:18.020 --> 01:12:19.020
这个函数哪来的

01:12:19.020 --> 01:12:21.020
通过Band来得到的

01:12:21.020 --> 01:12:22.020
那么你能不能通过

01:12:22.020 --> 01:12:23.020
这种方式来修改

01:12:28.140 --> 01:12:29.140
然后把变成一个

01:12:29.140 --> 01:12:30.140
制服串ZS

01:12:30.140 --> 01:12:31.140
可不可以

01:12:32.140 --> 01:12:33.140
不行

01:12:35.140 --> 01:12:36.140
不行

01:12:36.140 --> 01:12:37.140
还是不行

01:12:37.140 --> 01:12:39.140
你改不了ZS的

01:12:40.140 --> 01:12:41.140
而不但也是一样

01:12:41.140 --> 01:12:42.140
改不了了

01:12:42.140 --> 01:12:44.140
但是可以通过6来修改

01:12:45.140 --> 01:12:47.140
就是你通过6一个

01:12:47.140 --> 01:12:48.140
New Test

01:12:48.140 --> 01:12:50.140
可以通过这种方式来修改

01:12:53.140 --> 01:12:54.140
你看

01:12:54.140 --> 01:12:55.140
变成了一个对象了

01:12:55.140 --> 01:12:57.140
变成了Test对象了

01:12:57.140 --> 01:12:58.140
后面是2和3

01:12:59.140 --> 01:13:01.140
这是一个很神奇的现象

01:13:01.140 --> 01:13:02.140
这是

01:13:02.140 --> 01:13:03.140
第一个注意点

01:13:04.140 --> 01:13:05.140
有的时候面试

01:13:05.140 --> 01:13:06.140
它就那么丢端

01:13:06.140 --> 01:13:07.140
不是我想搞的

01:13:07.140 --> 01:13:09.140
面试它就那么丢端

01:13:09.140 --> 01:13:10.140
所以我必须要说

01:13:10.140 --> 01:13:11.140
第二个

01:13:11.140 --> 01:13:14.140
如果函数是非严格模式

01:13:16.140 --> 01:13:17.140
那这里没法去多扯

01:13:17.140 --> 01:13:18.140
什么严格模式的

01:13:18.140 --> 01:13:20.140
那又是另外一颗指示的

01:13:20.140 --> 01:13:21.140
它面试的时候

01:13:21.140 --> 01:13:23.140
它会终合来考

01:13:23.140 --> 01:13:24.140
那你就必须要掌握

01:13:24.140 --> 01:13:25.140
更多的指示的

01:13:26.140 --> 01:13:27.140
我们这里就

01:13:27.140 --> 01:13:28.140
当然说我们就是

01:13:28.140 --> 01:13:29.140
非严格模式

01:13:29.140 --> 01:13:30.140
当使用这些东西的时候

01:13:30.140 --> 01:13:31.140
什么core

01:13:31.140 --> 01:13:32.140
而playband的时候

01:13:32.140 --> 01:13:33.140
如果说你传入

01:13:33.140 --> 01:13:35.140
now或是undefend作为this

01:13:35.140 --> 01:13:37.140
就相当于

01:13:37.140 --> 01:13:41.350
传入的是全局对象

01:13:41.350 --> 01:13:42.350
几个韩数

01:13:42.350 --> 01:13:43.350
user

01:13:44.350 --> 01:13:49.200
输出this

01:13:49.200 --> 01:13:50.200
好比方说这个韩数

01:13:50.200 --> 01:13:52.200
我们用core

01:13:52.200 --> 01:13:54.200
将传了一个undefend的进去

01:13:55.200 --> 01:13:56.200
啥意思

01:13:56.200 --> 01:13:58.200
你去运行这个韩数

01:13:58.200 --> 01:14:00.200
用undefend作为this

01:14:00.200 --> 01:14:01.200
它理你吗

01:14:01.200 --> 01:14:02.200
它不理你

01:14:02.200 --> 01:14:04.200
因为你传入undefend

01:14:04.200 --> 01:14:05.200
就相当于是

01:14:05.200 --> 01:14:07.200
传入的是window

01:14:07.200 --> 01:14:09.200
它认为this是window

01:14:09.200 --> 01:14:13.090
如果再传一个now

01:14:13.090 --> 01:14:15.090
它仍然认为是window

01:14:15.090 --> 01:14:17.090
这是非严格模式

01:14:17.090 --> 01:14:18.090
严格模式的话

01:14:18.090 --> 01:14:20.090
你传上市场

01:14:20.090 --> 01:14:22.090
严格模式我们这里就不扯了

01:14:22.090 --> 01:14:23.090
好吧这是

01:14:23.090 --> 01:14:26.090
两种小的注意点

01:14:27.090 --> 01:14:28.090
好然后下面这个箭头

01:14:28.090 --> 01:14:29.090
还说箭头

01:14:29.090 --> 01:14:30.090
还说是es6的

01:14:30.090 --> 01:14:31.090
因为为什么要讲箭头

01:14:31.090 --> 01:14:32.090
还说

01:14:32.090 --> 01:14:33.090
因为箭头

01:14:33.090 --> 01:14:34.090
还是跟this也有关系

01:14:34.090 --> 01:14:35.090
你就记住一个

01:14:35.090 --> 01:14:36.090
箭头还说

01:14:36.090 --> 01:14:38.090
看一下这个就行了

01:14:38.090 --> 01:14:39.090
简单的认识一下箭头

01:14:39.090 --> 01:14:40.090
还说

01:14:40.090 --> 01:14:41.090
因为这里没有办法

01:14:41.090 --> 01:14:42.090
可以从头到尾去讲箭头

01:14:42.090 --> 01:14:43.090
还说了

01:14:43.090 --> 01:14:44.090
简单的认识一下箭头

01:14:44.090 --> 01:14:45.090
还说

01:14:45.090 --> 01:14:46.090
就是我们的韩数杂写的

01:14:46.090 --> 01:14:47.090
就韩数表达是

01:14:47.090 --> 01:14:48.090
一个方形

01:14:48.090 --> 01:14:49.090
参数参数

01:14:49.090 --> 01:14:51.090
然后这是韩数体

01:14:51.090 --> 01:14:52.090
箭头还说

01:14:52.090 --> 01:14:54.090
可以把它简化成

01:14:54.090 --> 01:14:55.090
这样子

01:14:55.090 --> 01:14:56.090
格式给它简化掉

01:14:56.090 --> 01:14:57.090
两个参数

01:14:57.090 --> 01:14:58.090
a和b

01:14:58.090 --> 01:14:59.090
一个箭头

01:14:59.090 --> 01:15:00.090
一个等号

01:15:00.090 --> 01:15:01.090
一个大鱼

01:15:01.090 --> 01:15:02.090
箭头

01:15:02.090 --> 01:15:03.090
然后都是韩数体

01:15:03.090 --> 01:15:04.090
是一样的

01:15:04.090 --> 01:15:06.090
把方形关键字去掉了

01:15:06.090 --> 01:15:07.090
然后

01:15:07.090 --> 01:15:10.090
韩数体写字是一样的

01:15:10.090 --> 01:15:11.090
能够做

01:15:11.090 --> 01:15:13.090
今天晚上的题就行了

01:15:13.090 --> 01:15:15.090
但是有一个地方有区别

01:15:15.090 --> 01:15:16.090
就是箭头

01:15:16.090 --> 01:15:18.090
韩数是没有this的

01:15:18.090 --> 01:15:19.090
没有this

01:15:19.090 --> 01:15:20.090
没有argument

01:15:20.090 --> 01:15:22.090
真没有

01:15:22.090 --> 01:15:24.090
韩数里面不都有this吗

01:15:24.090 --> 01:15:26.090
箭头还说没有

01:15:26.090 --> 01:15:28.090
箭头还说是没有的

01:15:28.090 --> 01:15:29.090
所以箭头还说里边

01:15:29.090 --> 01:15:30.090
它没有this

01:15:30.090 --> 01:15:31.090
它是不是说

01:15:31.090 --> 01:15:32.090
它不能用this

01:15:32.090 --> 01:15:33.090
不是

01:15:33.090 --> 01:15:34.090
它能用this

01:15:34.090 --> 01:15:36.090
它用的是外边的

01:15:36.090 --> 01:15:37.090
还记得我们昨天讲的

01:15:37.090 --> 01:15:38.090
作用语练吗

01:15:38.090 --> 01:15:40.090
它自己没有去用外边的

01:15:40.090 --> 01:15:41.090
对吧

01:15:41.090 --> 01:15:42.090
所以说

01:15:42.090 --> 01:15:43.090
箭头还说有这么一个特点

01:15:43.090 --> 01:15:44.090
因此

01:15:44.090 --> 01:15:45.090
它

01:15:45.090 --> 01:15:46.090
如果它在箭头还说

01:15:46.090 --> 01:15:47.090
使用this的话

01:15:47.090 --> 01:15:49.090
使用的是作用语练上的this

01:15:49.090 --> 01:15:50.090
完了

01:15:50.090 --> 01:15:51.090
这就是我们今天讲的

01:15:51.090 --> 01:15:52.090
this指向和变训练

01:15:52.090 --> 01:15:53.090
那么接下来

01:15:53.090 --> 01:15:57.230
就是this指向的题

01:15:57.230 --> 01:15:58.230
好 我们来看一下

01:15:58.230 --> 01:15:59.230
这个试源

01:15:59.230 --> 01:16:00.230
试源的

01:16:00.230 --> 01:16:05.720
这边是题

01:16:05.720 --> 01:16:06.720
里面有意思

01:16:07.720 --> 01:16:08.720
这要提到关键点

01:16:08.720 --> 01:16:09.720
在这个东西

01:16:10.720 --> 01:16:12.720
这玩意它是结合了表达式

01:16:12.720 --> 01:16:14.720
结合了列式指向

01:16:15.720 --> 01:16:16.720
结合了

01:16:18.720 --> 01:16:19.720
结合了啥

01:16:19.720 --> 01:16:20.720
我也没啥了

01:16:20.720 --> 01:16:21.720
好 咱们来看一下

01:16:26.220 --> 01:16:28.220
这玩意是一

01:16:29.220 --> 01:16:30.220
一个字不错

01:16:30.220 --> 01:16:31.220
全局的

01:16:31.220 --> 01:16:32.220
是吧

01:16:33.220 --> 01:16:34.220
我们知道

01:16:34.220 --> 01:16:35.220
全局对向上

01:16:35.220 --> 01:16:36.220
全局

01:16:37.220 --> 01:16:38.220
对向上有个啥

01:16:38.220 --> 01:16:41.790
有一个

01:16:41.790 --> 01:16:42.790
加了一个属性

01:16:42.790 --> 01:16:44.790
叫做substr

01:16:44.790 --> 01:16:45.790
是一个字不错

01:16:45.790 --> 01:16:51.340
然后下边这句话

01:16:51.340 --> 01:16:52.340
创建一个ob键

01:16:53.340 --> 01:16:55.340
这个ob键里边

01:16:55.340 --> 01:16:56.340
有一些属性

01:16:56.340 --> 01:16:57.340
那么ob键

01:16:57.340 --> 01:16:59.340
有一个什么substr

01:16:59.340 --> 01:17:00.340
等于什么2

01:17:00.340 --> 01:17:02.340
还有一个函数

01:17:02.340 --> 01:17:03.340
因为它这个玩意

01:17:03.340 --> 01:17:04.340
名字一样

01:17:04.340 --> 01:17:05.340
它就典型的是什么

01:17:05.340 --> 01:17:07.340
要考虑这个玩意

01:17:07.340 --> 01:17:08.340
然后这个函数

01:17:08.340 --> 01:17:09.340
是输出z

01:17:09.340 --> 01:17:10.340
是第2

01:17:10.340 --> 01:17:11.340
这个东西

01:17:11.340 --> 01:17:12.340
Z是指向谁不知道

01:17:12.340 --> 01:17:13.340
现在还没调用

01:17:13.340 --> 01:17:14.340
好 接下来

01:17:15.340 --> 01:17:17.340
写了一个立即执行的简单

01:17:17.340 --> 01:17:18.340
这要看懂了

01:17:18.340 --> 01:17:20.340
这是一个箭头函数

01:17:20.340 --> 01:17:22.340
它没有参数

01:17:22.340 --> 01:17:24.340
这是箭头函数的函数体

01:17:24.340 --> 01:17:25.340
对吧

01:17:25.340 --> 01:17:26.340
这种写法

01:17:26.340 --> 01:17:31.320
其实就相当于是这样的写法

01:17:31.320 --> 01:17:33.320
就相当于是立即执行函数

01:17:33.320 --> 01:17:37.850
它把写成箭头函数的格式了

01:17:37.850 --> 01:17:39.850
你看到箭头函数

01:17:39.850 --> 01:17:40.850
这是Z的指向

01:17:40.850 --> 01:17:41.850
应该有变化

01:17:41.850 --> 01:17:45.480
不要受干扰

01:17:45.480 --> 01:17:47.480
看谁的Z是指向

01:17:47.480 --> 01:17:49.480
就看那个Z是所在的函数

01:17:49.480 --> 01:17:51.480
是怎么运行的

01:17:51.480 --> 01:17:53.480
Z是在哪个函数

01:17:53.480 --> 01:17:54.480
修别的

01:17:54.480 --> 01:17:55.480
这个函数咋运行的

01:17:55.480 --> 01:17:57.480
OB借得修别的

01:17:57.480 --> 01:17:58.480
那还用说吗

01:17:58.480 --> 01:18:00.480
这个函数里边的Z是指向谁

01:18:00.480 --> 01:18:02.480
指向OB借

01:18:03.480 --> 01:18:04.480
好 运行这个函数

01:18:04.480 --> 01:18:05.480
Z是啥

01:18:05.480 --> 01:18:06.480
Z是OB借

01:18:06.480 --> 01:18:08.480
输出STR

01:18:08.480 --> 01:18:09.480
输出啥

01:18:09.480 --> 01:18:10.480
输出R

01:18:10.480 --> 01:18:12.480
你别管其他的

01:18:12.480 --> 01:18:14.480
你要看这个Z是指向谁

01:18:14.480 --> 01:18:15.480
就看他是咋运行的

01:18:15.480 --> 01:18:16.480
就完事了

01:18:16.480 --> 01:18:17.480
跟其他没关系

01:18:17.480 --> 01:18:19.480
好 那么我们就看到

01:18:19.480 --> 01:18:20.480
这个地方呢

01:18:20.480 --> 01:18:21.480
输出几

01:18:21.480 --> 01:18:22.480
输出R

01:18:22.480 --> 01:18:23.480
好 接下来是

01:18:23.480 --> 01:18:24.480
下面这句话

01:18:24.480 --> 01:18:25.480
下面是特别刁砖

01:18:25.480 --> 01:18:31.030
这句话是啥意思

01:18:32.030 --> 01:18:33.030
你首先要搞清楚

01:18:33.030 --> 01:18:35.030
这个是个负质

01:18:35.030 --> 01:18:37.030
表达式

01:18:37.030 --> 01:18:39.030
我现在又有点担心了

01:18:39.030 --> 01:18:41.030
你们以前的指示

01:18:41.030 --> 01:18:43.030
如果说是东平七城

01:18:43.030 --> 01:18:44.030
对表达式

01:18:44.030 --> 01:18:46.030
认识的不够清楚

01:18:46.030 --> 01:18:48.030
那你对表达式

01:18:48.030 --> 01:18:49.030
认识不够清楚的话

01:18:50.030 --> 01:18:51.030
因为表达式是一块

01:18:51.030 --> 01:18:53.030
很重要很重要的指示

01:18:53.030 --> 01:18:57.180
每个表达式都有返回类型

01:18:57.180 --> 01:18:58.180
比方说我们譬如说

01:18:58.180 --> 01:19:00.180
1加1是一个表达式

01:19:00.180 --> 01:19:02.180
它的返回类型是什么呢

01:19:02.180 --> 01:19:04.180
返回类型是

01:19:04.180 --> 01:19:05.180
number 是一个数字

01:19:05.180 --> 01:19:06.180
返回值是什么呢

01:19:06.180 --> 01:19:09.740
返回值为2

01:19:09.740 --> 01:19:10.740
我们说

01:19:10.740 --> 01:19:12.740
1并且2是一个表达式

01:19:12.740 --> 01:19:14.740
它的返回类型是什么呢

01:19:14.740 --> 01:19:15.740
返回类型要么是它

01:19:15.740 --> 01:19:16.740
要么是它

01:19:16.740 --> 01:19:18.740
那就看那个求

01:19:18.740 --> 01:19:20.740
求真求假的结果

01:19:20.740 --> 01:19:21.740
那么它为真

01:19:21.740 --> 01:19:22.740
那么继续往后求

01:19:22.740 --> 01:19:23.740
那么返回的

01:19:23.740 --> 01:19:24.740
返回的仍然是数字

01:19:24.740 --> 01:19:25.740
返回的值是什么

01:19:25.740 --> 01:19:27.740
返回值是2

01:19:27.740 --> 01:19:31.780
所以说这个东西

01:19:31.780 --> 01:19:33.780
然后我就没办法

01:19:33.780 --> 01:19:34.780
确定你们

01:19:34.780 --> 01:19:35.780
之前的表达式有没有问题的

01:19:35.780 --> 01:19:37.780
我现在就直接说了

01:19:37.780 --> 01:19:39.780
这个是一个负值表达式

01:19:39.780 --> 01:19:41.780
负值表达式有一个规则

01:19:41.780 --> 01:19:44.780
整个表达式返回什么

01:19:44.780 --> 01:19:47.780
返回所负的值

01:19:47.780 --> 01:19:49.780
所负的值是啥呀

01:19:49.780 --> 01:19:50.780
是一个函数

01:19:50.780 --> 01:19:51.780
那么整个表达式

01:19:52.780 --> 01:19:54.780
整个表达式得到了

01:19:54.780 --> 01:19:55.780
就是一个函数修辟

01:19:55.780 --> 01:19:59.100
其实这个玩意

01:19:59.100 --> 01:20:02.920
你们把这个放到浏览器里边

01:20:02.920 --> 01:20:04.920
代码

01:20:04.920 --> 01:20:06.920
其他的不切

01:20:06.920 --> 01:20:07.920
就这个代码

01:20:07.920 --> 01:20:08.920
我们来看一下

01:20:08.920 --> 01:20:10.920
obj.修辟等于

01:20:10.920 --> 01:20:11.920
obj.修辟

01:20:11.920 --> 01:20:12.920
都是个负值表达式

01:20:12.920 --> 01:20:14.920
你看整个表达式返回什么

01:20:14.920 --> 01:20:17.920
返回的是就是那个函数

01:20:17.920 --> 01:20:18.920
所以呢

01:20:18.920 --> 01:20:20.920
你这个代码一看就

01:20:20.920 --> 01:20:21.920
现在就明白了

01:20:21.920 --> 01:20:22.920
想要的是这里

01:20:22.920 --> 01:20:24.920
直接放了这个函数

01:20:24.920 --> 01:20:26.920
把这个函数放走了

01:20:26.920 --> 01:20:27.920
然后要执行它

01:20:27.920 --> 01:20:30.920
那是不是就相当于直接执行函数

01:20:30.920 --> 01:20:32.920
就有这项立即执行函数的意思的

01:20:32.920 --> 01:20:33.920
对吧

01:20:33.920 --> 01:20:35.920
相当于就直接执行函数

01:20:35.920 --> 01:20:36.920
那么这个函数是直接执行的

01:20:36.920 --> 01:20:37.920
那这意思还要说吗

01:20:37.920 --> 01:20:38.920
那肯定是指向这

01:20:38.920 --> 01:20:40.920
指向Windows

01:20:41.920 --> 01:20:42.920
好 再下句话

01:20:42.920 --> 01:20:44.920
obj.修辟.core

01:20:44.920 --> 01:20:46.920
手动的指定类似

01:20:46.920 --> 01:20:50.680
手动的

01:20:50.680 --> 01:20:52.680
指定类似

01:20:53.680 --> 01:20:54.680
为啥呀

01:20:54.680 --> 01:20:55.680
为这个

01:20:56.680 --> 01:20:57.680
那么这里面的

01:20:57.680 --> 01:20:58.680
意思指向谁

01:20:58.680 --> 01:20:59.680
那就指向这个

01:20:59.680 --> 01:21:01.680
这个意思就指向这个

01:21:01.680 --> 01:21:02.680
而这个有没有

01:21:02.680 --> 01:21:03.680
substr

01:21:04.680 --> 01:21:06.680
那就设计到标准库了

01:21:06.680 --> 01:21:07.680
就是很多种知识

01:21:07.680 --> 01:21:09.680
它是连着的

01:21:09.680 --> 01:21:11.680
它不是孤立的

01:21:11.680 --> 01:21:12.680
就是我这些

01:21:12.680 --> 01:21:14.680
为了让你们学习这些知识

01:21:14.680 --> 01:21:16.680
我把好了题

01:21:16.680 --> 01:21:17.680
有些题目还稍微做了

01:21:17.680 --> 01:21:19.680
一些简单的修辟

01:21:19.680 --> 01:21:21.680
就避免一些其他的知识干了

01:21:21.680 --> 01:21:22.680
但是还是没办法

01:21:22.680 --> 01:21:24.680
这题都是综合性的

01:21:24.680 --> 01:21:27.180
那么这是一个制服串

01:21:27.180 --> 01:21:29.180
制服串里面是有这个方法的

01:21:29.180 --> 01:21:31.180
这是叫制服串结局

01:21:31.180 --> 01:21:33.180
我们来看一下吧

01:21:33.180 --> 01:21:35.180
制服串的元雄里面

01:21:35.180 --> 01:21:36.180
Prototype

01:21:36.180 --> 01:21:37.180
是有这个方法的

01:21:37.180 --> 01:21:38.180
你看

01:21:38.180 --> 01:21:40.180
这是一个函数

01:21:40.180 --> 01:21:41.180
说所有的制服串

01:21:41.180 --> 01:21:43.180
它都有这个方法

01:21:43.180 --> 01:21:44.180
因此呢

01:21:44.180 --> 01:21:45.180
Z是啥

01:21:45.180 --> 01:21:46.180
是制服串

01:21:46.180 --> 01:21:47.180
制服串里面有没有这个方法

01:21:47.180 --> 01:21:48.180
有

01:21:48.180 --> 01:21:49.180
它是一个函数

01:21:49.180 --> 01:21:52.620
就说输出的结果就是这个

01:21:52.620 --> 01:21:53.620
WINDOW

01:21:53.620 --> 01:21:54.620
一个函数

01:21:55.620 --> 01:21:59.730
看一下

01:21:59.730 --> 01:22:03.510
2

01:22:03.510 --> 01:22:05.510
不好意思

01:22:05.510 --> 01:22:06.510
这里是WINDOW

01:22:06.510 --> 01:22:07.510
Z是指向WINDOW

01:22:07.510 --> 01:22:08.510
WINDOW里面

01:22:08.510 --> 01:22:09.510
权力对象里面

01:22:09.510 --> 01:22:11.510
不是只有一个Sub-STR吗

01:22:11.510 --> 01:22:13.510
是一个制服串1对吧

01:22:13.510 --> 01:22:14.510
Z是WINDOW

01:22:14.510 --> 01:22:16.510
那么WINDOW里面有一个制服串1

01:22:16.510 --> 01:22:18.510
所以这里是2,1

01:22:18.510 --> 01:22:19.510
所以做这种题小心一点

01:22:19.510 --> 01:22:20.510
打破你自己知道

01:22:20.510 --> 01:22:21.510
都要小心一点

01:22:21.510 --> 01:22:24.530
好

01:22:24.530 --> 01:22:26.530
这是第二题

01:22:26.530 --> 01:22:30.420
美图的

01:22:30.420 --> 01:22:31.420
又是Z

01:22:32.420 --> 01:22:35.050
来吧

01:22:35.050 --> 01:22:37.050
权局里面有个i

01:22:37.050 --> 01:22:39.050
然后A

01:22:39.050 --> 01:22:40.050
A是个函数

01:22:40.050 --> 01:22:41.050
还没运行

01:22:41.050 --> 01:22:42.050
B是函数

01:22:42.050 --> 01:22:43.050
还没运行

01:22:43.050 --> 01:22:45.050
没运行可以折起来

01:22:45.050 --> 01:22:46.050
然后接下来

01:22:46.050 --> 01:22:47.050
D

01:22:47.050 --> 01:22:48.050
我们来分析一下

01:22:48.050 --> 01:22:49.050
D这个函数

01:22:49.050 --> 01:22:50.050
它来自于哪呢

01:22:50.050 --> 01:22:51.050
它就是B的函数

01:22:51.050 --> 01:22:52.050
BAND了谁

01:22:52.050 --> 01:22:53.050
BAND了Z

01:22:53.050 --> 01:22:55.050
现在这个Z是指向谁

01:22:55.050 --> 01:22:56.050
好看清楚

01:22:56.050 --> 01:22:58.050
这是权局的Z

01:22:58.050 --> 01:22:59.050
权局的Z是谁

01:22:59.050 --> 01:23:00.050
WINDOW

01:23:00.050 --> 01:23:01.050
那就意味着

01:23:01.050 --> 01:23:02.050
D这个函数

01:23:02.050 --> 01:23:03.050
它就绑定了WINDOW

01:23:03.050 --> 01:23:06.680
我稍微把它记一下

01:23:06.680 --> 01:23:07.680
WINDOW

01:23:07.680 --> 01:23:08.680
免得一会忘了

01:23:08.680 --> 01:23:09.680
D是一个函数

01:23:09.680 --> 01:23:10.680
一会儿掉用的时候

01:23:10.680 --> 01:23:11.680
它就绑定了WINDOW

01:23:11.680 --> 01:23:13.680
它的Z是一定指向WINDOW

01:23:13.680 --> 01:23:15.680
除分你用6去掉用它

01:23:15.680 --> 01:23:17.680
就我们这里说的规则

01:23:17.680 --> 01:23:22.680
得到的新函数

01:23:22.680 --> 01:23:23.680
无法修改Z

01:23:23.680 --> 01:23:29.680
它是6除外

01:23:29.680 --> 01:23:30.680
下面有个OB界

01:23:30.680 --> 01:23:31.680
然后A

01:23:31.680 --> 01:23:32.680
这个函数

01:23:32.680 --> 01:23:33.680
A复制的属性A

01:23:33.680 --> 01:23:35.680
所以说OB界的A

01:23:35.680 --> 01:23:37.680
它也是这个函数

01:23:37.680 --> 01:23:38.680
复制过去了

01:23:38.680 --> 01:23:40.680
来运行了

01:23:40.680 --> 01:23:42.680
OB界点A

01:23:42.680 --> 01:23:43.680
那么这样子运行

01:23:43.680 --> 01:23:44.680
还用说吗

01:23:44.680 --> 01:23:46.680
A里边的Z是指向谁

01:23:46.680 --> 01:23:47.680
指向OB界

01:23:47.680 --> 01:23:48.680
指向这个

01:23:48.680 --> 01:23:50.680
对吧

01:23:50.680 --> 01:23:51.680
OB界点A

01:23:51.680 --> 01:23:52.680
A是啥

01:23:52.680 --> 01:23:53.680
A就是这个函数

01:23:53.680 --> 01:23:54.680
那么这个函数的运行期间

01:23:54.680 --> 01:23:55.680
Z是指向谁

01:23:55.680 --> 01:23:56.680
指向OB界

01:23:56.680 --> 01:23:57.680
好

01:23:57.680 --> 01:23:59.680
那么接下来

01:23:59.680 --> 01:24:00.680
所以说

01:24:00.680 --> 01:24:01.680
Z里边的Z是指向谁

01:24:01.680 --> 01:24:02.680
指向的是OB界

01:24:02.680 --> 01:24:04.680
指向的是它

01:24:04.680 --> 01:24:05.680
但是我怎么来调问呢

01:24:05.680 --> 01:24:08.680
我是用D点扩Z

01:24:08.680 --> 01:24:11.060
D是啥

01:24:12.060 --> 01:24:14.060
已经绑定过Z了

01:24:14.060 --> 01:24:17.060
它绑定的是Windows

01:24:17.060 --> 01:24:19.060
我们通过Band的

01:24:19.060 --> 01:24:20.060
到了函数

01:24:20.060 --> 01:24:21.060
是无法通过

01:24:21.060 --> 01:24:23.060
这种方式来修改Z的

01:24:23.060 --> 01:24:24.060
所以说D

01:24:24.060 --> 01:24:25.060
它运不运行

01:24:25.060 --> 01:24:27.060
D会运行

01:24:27.060 --> 01:24:28.060
但是Z

01:24:28.060 --> 01:24:30.060
并不会修改为

01:24:30.060 --> 01:24:31.060
这里的Z

01:24:31.060 --> 01:24:32.060
这里的Z是谁

01:24:32.060 --> 01:24:33.060
搞清楚

01:24:33.060 --> 01:24:34.060
这里的Z是谁

01:24:34.060 --> 01:24:35.060
这里的Z是OB界

01:24:35.060 --> 01:24:37.060
但是D里边的Z是谁

01:24:37.060 --> 01:24:39.060
D里边的Z是Windows

01:24:39.060 --> 01:24:41.060
D里边的Z

01:24:41.060 --> 01:24:42.060
是Windows

01:24:42.060 --> 01:24:43.060
因为它之前被绑定过了

01:24:43.060 --> 01:24:45.060
它修改不了

01:24:45.060 --> 01:24:46.060
如果说是普通函数的话

01:24:46.060 --> 01:24:47.060
就能够修改了

01:24:47.060 --> 01:24:48.060
但它不是普通函数

01:24:48.060 --> 01:24:49.060
它是Band得到的

01:24:49.060 --> 01:24:52.060
它修改不了

01:24:52.060 --> 01:24:53.060
懂了一下

01:24:53.060 --> 01:24:55.060
所以呢

01:24:55.060 --> 01:24:56.060
现在开始运行啥

01:24:56.060 --> 01:24:57.060
运行函数D

01:24:57.060 --> 01:24:58.060
运行函数D

01:24:58.060 --> 01:24:59.060
实际上就是运行函数B

01:24:59.060 --> 01:25:00.060
但是你要注意

01:25:00.060 --> 01:25:01.060
再重申一次

01:25:01.060 --> 01:25:03.060
D由于是Band的过的

01:25:03.060 --> 01:25:04.060
所以它里边的Z

01:25:04.060 --> 01:25:05.060
现在运行D的时候

01:25:05.060 --> 01:25:06.060
它里边的Z

01:25:06.060 --> 01:25:08.060
仍然指向Windows

01:25:09.060 --> 01:25:10.060
不然的话

01:25:10.060 --> 01:25:11.060
就后面是全错了

01:25:12.060 --> 01:25:14.690
来吧

01:25:19.130 --> 01:25:20.130
这里呢

01:25:20.130 --> 01:25:21.130
有一个函数

01:25:21.130 --> 01:25:22.130
C是一个啥

01:25:22.130 --> 01:25:24.130
是一个箭头函数

01:25:24.130 --> 01:25:26.130
箭头函数是没有Z的

01:25:26.130 --> 01:25:27.130
没有Z

01:25:31.140 --> 01:25:32.140
然后呢

01:25:32.140 --> 01:25:33.140
通过箭头函数扩

01:25:33.140 --> 01:25:34.140
然后

01:25:34.140 --> 01:25:35.140
又通过扩这种方式

01:25:35.140 --> 01:25:38.650
去雕用函数

01:25:38.650 --> 01:25:39.650
通过扩这种方式

01:25:39.650 --> 01:25:40.650
雕用函数

01:25:40.650 --> 01:25:41.650
但是不好意思

01:25:41.650 --> 01:25:43.650
箭头函数没有Z

01:25:43.650 --> 01:25:45.650
这种方式是无效的

01:25:45.650 --> 01:25:47.650
没有Z

01:25:47.650 --> 01:25:48.650
都没有

01:25:48.650 --> 01:25:49.650
好

01:25:49.650 --> 01:25:51.650
最终要输出的就是这东西了

01:25:51.650 --> 01:25:52.650
箭头函数里边

01:25:52.650 --> 01:25:54.650
要运行输出什么Z

01:25:54.650 --> 01:25:55.650
叫i

01:25:55.650 --> 01:25:56.650
那么现在要分析了

01:25:56.650 --> 01:25:57.650
Z到底是啥

01:25:57.650 --> 01:25:59.650
由于它是箭头函数

01:25:59.650 --> 01:26:00.650
它里边没有Z

01:26:00.650 --> 01:26:01.650
没有Z是用的是谁的Z

01:26:01.650 --> 01:26:03.650
用的是外层B

01:26:03.650 --> 01:26:04.650
这个函数的Z

01:26:04.650 --> 01:26:05.650
作用预练

01:26:05.650 --> 01:26:07.650
自己没有用外层

01:26:07.650 --> 01:26:09.650
外层的Z是啥呢

01:26:09.650 --> 01:26:11.650
是Windows

01:26:11.650 --> 01:26:12.650
Windows里面的i是啥

01:26:12.650 --> 01:26:13.650
是0

01:26:13.650 --> 01:26:14.650
最终招来招去

01:26:14.650 --> 01:26:16.650
它就给你输出一个0

01:26:16.650 --> 01:26:17.650
这是这个

01:26:17.650 --> 01:26:18.650
不对

01:26:18.650 --> 01:26:19.650
这是这个漏的环境

01:26:19.650 --> 01:26:21.650
没有到浏览器环境里面去

01:26:21.650 --> 01:26:22.650
招来招去

01:26:22.650 --> 01:26:24.650
它就给你输出一个0

01:26:24.650 --> 01:26:26.650
这道题的关键点就在于

01:26:26.650 --> 01:26:27.650
你要搞清楚它到底是0

01:26:27.650 --> 01:26:28.650
还是10

01:26:28.650 --> 01:26:29.650
还是什么

01:26:29.650 --> 01:26:30.650
NG犯的之类的

01:26:30.650 --> 01:26:31.650
要搞清楚

01:26:31.650 --> 01:26:36.150
这是这道题

01:26:36.150 --> 01:26:37.150
这道题

01:26:37.150 --> 01:26:41.380
没图的道题

01:26:41.380 --> 01:26:42.380
最后一道题

01:26:42.380 --> 01:26:45.380
Z是指向

01:26:45.380 --> 01:26:51.040
小米的题

01:26:51.040 --> 01:26:53.040
有一个Person

01:26:53.040 --> 01:26:55.040
不要先入为主

01:26:55.040 --> 01:26:56.040
这个字母大起来

01:26:56.040 --> 01:26:57.040
应该是够着海

01:26:57.040 --> 01:26:58.040
所以Z是指向新对象

01:26:58.040 --> 01:26:59.040
拉不一定的

01:26:59.040 --> 01:27:01.040
然后一个圆形方法

01:27:01.040 --> 01:27:04.040
接下来来看

01:27:04.040 --> 01:27:07.420
这道题好有意思

01:27:07.420 --> 01:27:08.420
这道题好有意思

01:27:08.420 --> 01:27:09.420
这道题

01:27:09.420 --> 01:27:10.420
来看

01:27:10.420 --> 01:27:11.420
New的一个Person

01:27:11.420 --> 01:27:13.420
这时候得到一个新对象了

01:27:13.420 --> 01:27:14.420
因为这里面的Z

01:27:14.420 --> 01:27:15.420
肯定是指向新对象了

01:27:15.420 --> 01:27:17.420
从我New的方式来调用

01:27:17.420 --> 01:27:18.420
那么得到一个新对象

01:27:19.420 --> 01:27:20.420
这个玩意

01:27:20.420 --> 01:27:21.420
看了一个整体

01:27:21.420 --> 01:27:22.420
都是个表达式

01:27:22.420 --> 01:27:24.420
创建了一个新对象

01:27:24.420 --> 01:27:26.420
年龄为18岁

01:27:26.420 --> 01:27:28.420
然后 say my age

01:27:28.420 --> 01:27:31.420
这是一个再正常不过的

01:27:31.420 --> 01:27:34.420
再频频无奇的调用了

01:27:34.420 --> 01:27:35.420
那这里面的Z

01:27:35.420 --> 01:27:38.420
它一定是指向了新对象

01:27:38.420 --> 01:27:39.420
对吧

01:27:39.420 --> 01:27:40.420
叉叉叉叉

01:27:40.420 --> 01:27:41.420
然后第二啥啥啥

01:27:41.420 --> 01:27:43.420
它一定是指向这个

01:27:43.420 --> 01:27:44.420
所以

01:27:44.420 --> 01:27:45.420
A级为多少呢

01:27:45.420 --> 01:27:46.420
A级为18

01:27:46.420 --> 01:27:47.420
这个毫无疑问

01:27:47.420 --> 01:27:48.420
第一个毫无疑问

01:27:48.420 --> 01:27:49.420
是吧

01:27:49.420 --> 01:27:50.420
第一个都做错了

01:27:50.420 --> 01:27:52.420
问题大了

01:27:52.420 --> 01:27:53.420
好

01:27:53.420 --> 01:27:54.420
接下来

01:27:54.420 --> 01:27:57.420
Person.prototypeCmyA级

01:27:57.420 --> 01:27:58.420
是不是找到它

01:27:58.420 --> 01:28:01.420
通过它来用call的方式来调用

01:28:01.420 --> 01:28:03.420
是不是手动的绑定Z式

01:28:03.420 --> 01:28:07.420
传到这么一个东西

01:28:07.420 --> 01:28:09.420
接下来有一个

01:28:09.420 --> 01:28:12.420
基础问题要问大家了

01:28:12.420 --> 01:28:14.420
这个表达式

01:28:14.420 --> 01:28:16.420
返回的是啥

01:28:16.420 --> 01:28:18.420
因为你返回的是1

01:28:18.420 --> 01:28:20.420
那么这里就传入一个1

01:28:20.420 --> 01:28:21.420
你返回的是2

01:28:21.420 --> 01:28:22.420
这里就传入一个2

01:28:22.420 --> 01:28:23.420
你返回的是一个对象

01:28:23.420 --> 01:28:24.420
这里就传入一个对象

01:28:24.420 --> 01:28:25.420
你返回的是NOW undefined

01:28:25.420 --> 01:28:26.420
传入的是NOW undefined

01:28:26.420 --> 01:28:28.420
它很关键的

01:28:28.420 --> 01:28:30.420
它返回的是啥

01:28:30.420 --> 01:28:32.420
没有人知道吗

01:28:32.420 --> 01:28:33.420
你是不是听晕了

01:28:33.420 --> 01:28:36.420
是不是有点听晕了

01:28:36.420 --> 01:28:48.630
你说我稍讲一点的

01:28:48.630 --> 01:28:50.630
机会难得

01:28:50.630 --> 01:29:01.940
这个表达式

01:29:02.940 --> 01:29:04.940
机会难得

01:29:04.940 --> 01:29:06.940
我又想你多一点能讲一些东西

01:29:06.940 --> 01:29:07.940
讲多

01:29:07.940 --> 01:29:09.940
你每下台也一定要好好去消化

01:29:09.940 --> 01:29:18.120
你就告诉我这个反处返回啥

01:29:18.120 --> 01:29:21.880
这个反处返回啥

01:29:21.880 --> 01:29:22.880
它反处只能是undefined

01:29:22.880 --> 01:29:24.880
它里面有没有return一句

01:29:24.880 --> 01:29:25.880
没有return一句

01:29:25.880 --> 01:29:27.880
它反处只能是undefined的

01:29:27.880 --> 01:29:28.880
为什么我把这个

01:29:28.880 --> 01:29:30.880
还说名字变成Person

01:29:30.880 --> 01:29:32.880
它就得返回一个对象呢

01:29:32.880 --> 01:29:34.880
因为它名字变了

01:29:34.880 --> 01:29:36.880
不要被干扰

01:29:36.880 --> 01:29:37.880
它这个玩意只能是undefined

01:29:37.880 --> 01:29:39.880
这是一个普通函数的要用

01:29:39.880 --> 01:29:40.880
看它的return一句

01:29:40.880 --> 01:29:41.880
它都没有return一句

01:29:41.880 --> 01:29:43.880
所以说这里传入的是啥

01:29:43.880 --> 01:29:45.880
传入的是undefined

01:29:45.880 --> 01:29:46.880
意思就是说

01:29:46.880 --> 01:29:48.880
我在运行这个函数

01:29:48.880 --> 01:29:50.880
你的Z应该指向谁啊

01:29:50.880 --> 01:29:52.880
指向的是undefined

01:29:52.880 --> 01:30:06.110
那之前咋说的

01:30:06.110 --> 01:30:07.110
所以

01:30:07.110 --> 01:30:09.110
第二次必要用

01:30:09.110 --> 01:30:12.110
这里传入的就是undefined

01:30:12.110 --> 01:30:15.110
那就相当于Z是指向谁

01:30:15.110 --> 01:30:18.110
指向全局

01:30:18.110 --> 01:30:20.110
指向的是全局

01:30:20.110 --> 01:30:21.110
那么指向的全局

01:30:21.110 --> 01:30:22.110
那这里是啥

01:30:22.110 --> 01:30:23.110
window

01:30:23.110 --> 01:30:25.110
window里面有没有A级

01:30:25.110 --> 01:30:26.110
没有

01:30:26.110 --> 01:30:27.110
那就是undefined

01:30:27.110 --> 01:30:31.190
不是爆错啊

01:30:31.190 --> 01:30:33.190
这句话不是爆错

01:30:33.190 --> 01:30:34.190
如果说你认为

01:30:34.190 --> 01:30:35.190
Z是指向undefined的话

01:30:35.190 --> 01:30:36.190
这里就爆错了

01:30:36.190 --> 01:30:37.190
它没有爆错

01:30:37.190 --> 01:30:38.190
这是undefined的

01:30:38.190 --> 01:30:40.190
第三句话

01:30:40.190 --> 01:30:44.190
通过prototype say myA级

01:30:44.190 --> 01:30:46.190
那么Z是指向谁

01:30:46.190 --> 01:30:50.400
指向Prototype

01:30:50.400 --> 01:30:52.400
Prototype里面有A

01:30:52.400 --> 01:30:54.400
Z是指向这个

01:30:54.400 --> 01:30:56.400
那么它里面有A级吗

01:30:56.400 --> 01:30:58.400
它里面肯定是没有A级的

01:30:58.400 --> 01:31:01.400
所以第三个它也是undefined

01:31:01.400 --> 01:31:06.380
接下来再来

01:31:06.380 --> 01:31:07.380
这个话要callZ

01:31:07.380 --> 01:31:09.380
这个Z是指向谁

01:31:09.380 --> 01:31:10.380
指向window

01:31:10.380 --> 01:31:11.380
在全局里面使用Z

01:31:11.380 --> 01:31:12.380
就指向window

01:31:12.380 --> 01:31:16.780
那么window里面

01:31:16.780 --> 01:31:17.780
这道题是不是

01:31:17.780 --> 01:31:19.780
我少写了什么东西

01:31:19.780 --> 01:31:20.780
是不是window里面

01:31:20.780 --> 01:31:25.370
应该还有个A级才对啊

01:31:25.370 --> 01:31:27.370
天啊

01:31:27.370 --> 01:31:33.560
这道题好阴险

01:31:33.560 --> 01:31:35.560
真的好阴险

01:31:35.560 --> 01:31:37.560
这里确实传统undefined

01:31:37.560 --> 01:31:38.560
但是你这个函数

01:31:38.560 --> 01:31:40.560
还是要执行一遍对吧

01:31:40.560 --> 01:31:42.560
你首先你这样调用函数

01:31:42.560 --> 01:31:44.560
我们先把这个函数运行的再说

01:31:44.560 --> 01:31:46.560
percent这个函数运行的再说

01:31:46.560 --> 01:31:47.560
percent这个函数运行

01:31:47.560 --> 01:31:49.560
因为我不是通过6来调用的

01:31:49.560 --> 01:31:51.560
我是直接调用的这个函数

01:31:51.560 --> 01:31:52.560
先说这儿

01:31:52.560 --> 01:31:53.560
先不要说这下面

01:31:53.560 --> 01:31:54.560
先说这儿

01:31:54.560 --> 01:31:55.560
这里的Z是指向谁

01:31:55.560 --> 01:31:57.560
指向的是window对吧

01:31:58.560 --> 01:31:59.560
先看这儿

01:31:59.560 --> 01:32:01.560
我先把这个函数调用一遍

01:32:01.560 --> 01:32:02.560
走一遍

01:32:02.560 --> 01:32:04.560
这个题好阴险

01:32:05.560 --> 01:32:07.560
这里它里面有一个Z

01:32:07.560 --> 01:32:08.560
这个Z是指向谁

01:32:08.560 --> 01:32:09.560
指向window

01:32:09.560 --> 01:32:10.560
因为我是直接调用的

01:32:10.560 --> 01:32:11.560
能理解吧

01:32:11.560 --> 01:32:13.560
那么相当于是我给window里面

01:32:13.560 --> 01:32:15.560
加了一个A级等于18

01:32:15.560 --> 01:32:16.560
对吧

01:32:16.560 --> 01:32:17.560
传了一个18进来

01:32:17.560 --> 01:32:18.560
这是18

01:32:18.560 --> 01:32:20.560
那么把个18给谁

01:32:20.560 --> 01:32:21.560
给window里面的A级

01:32:21.560 --> 01:32:22.560
所以这句话运行完了过

01:32:22.560 --> 01:32:26.560
和window里面是有一个A级的

01:32:26.560 --> 01:32:27.560
18

01:32:27.560 --> 01:32:29.560
window里面一开始没有

01:32:29.560 --> 01:32:30.560
现在有了

01:32:30.560 --> 01:32:32.560
然后这个函数运行完了

01:32:32.560 --> 01:32:33.560
它会有一个返回值

01:32:33.560 --> 01:32:34.560
返回值是return的东西

01:32:34.560 --> 01:32:36.560
return有没有return没有

01:32:36.560 --> 01:32:38.560
那么传入的是undefend

01:32:38.560 --> 01:32:40.560
于是这个函数的Z是

01:32:41.560 --> 01:32:42.560
也是window

01:32:42.560 --> 01:32:44.560
因为它传入的是undefend

01:32:45.560 --> 01:32:46.560
输出了谁

01:32:46.560 --> 01:32:47.560
window里面的A级

01:32:47.560 --> 01:32:48.560
输出了也是18

01:32:48.560 --> 01:32:49.560
神奇吧

01:32:51.560 --> 01:32:52.560
太陰险了

01:32:52.560 --> 01:32:54.560
然后在这里

01:32:54.560 --> 01:32:55.560
这里肯定是undefend

01:32:55.560 --> 01:32:57.560
这里的Z是指向的是Prototype

01:32:57.560 --> 01:32:59.560
这里面没有东西

01:32:59.560 --> 01:33:00.560
第三个还是undefend

01:33:00.560 --> 01:33:01.560
第四个

01:33:01.560 --> 01:33:03.560
我说这什么意思呢

01:33:03.560 --> 01:33:05.560
然后这里callZ

01:33:05.560 --> 01:33:06.560
这个Z是指向谁

01:33:06.560 --> 01:33:07.560
全具的Z是指向window

01:33:07.560 --> 01:33:09.560
那么与说再运行函数

01:33:09.560 --> 01:33:11.560
它的Z是指向谁

01:33:11.560 --> 01:33:12.560
只要window

01:33:12.560 --> 01:33:13.560
在window里面

01:33:13.560 --> 01:33:14.560
还是18

01:33:14.560 --> 01:33:15.560
还是这里18

01:33:16.560 --> 01:33:17.560
太陰险了

01:33:17.560 --> 01:33:19.560
它就把我绕进去了

01:33:20.560 --> 01:33:22.560
于是变成这个样子了

01:33:23.560 --> 01:33:24.560
还没

01:33:29.300 --> 01:33:31.300
这就是关于Z的指向

01:33:35.300 --> 01:33:36.300
同样

01:33:36.300 --> 01:33:37.300
我看

01:33:38.300 --> 01:33:39.300
可能有些东西

01:33:39.300 --> 01:33:41.300
没怎么听得很明白

01:33:41.300 --> 01:33:43.300
下来慢慢去消化吧

01:33:43.300 --> 01:33:44.300
慢慢去消化

01:33:44.300 --> 01:33:45.300
这三天的课程

01:33:45.300 --> 01:33:47.300
估计得够理消化一段时间了

01:33:47.300 --> 01:33:48.300
消化个一周

01:33:49.300 --> 01:33:50.300
然后

01:33:50.300 --> 01:33:52.300
你要是理消了

01:33:52.300 --> 01:33:54.300
这个收获是蛮丰富的

01:33:54.300 --> 01:33:56.300
因为你只要通过一周的时间

01:33:56.300 --> 01:33:57.300
至少

01:33:57.300 --> 01:33:58.300
在高薪面

01:33:58.300 --> 01:33:59.300
比面式的过程中

01:33:59.300 --> 01:34:00.300
不知道

01:34:00.300 --> 01:34:01.300
第一天的时候给大家发面发

01:34:01.300 --> 01:34:02.300
那个

01:34:02.300 --> 01:34:03.300
看那个思维导图

01:34:03.300 --> 01:34:04.300
对吧

01:34:04.300 --> 01:34:05.300
有很多的很多的知识点

01:34:06.300 --> 01:34:08.300
搞定一个就少一个

01:34:08.300 --> 01:34:10.300
你可以这样子想吗

01:34:10.300 --> 01:34:11.300
搞定一个知识点

01:34:11.300 --> 01:34:12.300
你就多了

01:34:13.300 --> 01:34:14.300
咬上百块钱

01:34:14.300 --> 01:34:15.300
每个月

01:34:15.300 --> 01:34:16.300
可以吧

01:34:16.300 --> 01:34:17.300
还可以的对吧

01:34:17.300 --> 01:34:18.300
完全滑得来的

01:34:18.300 --> 01:34:20.300
一看大厂的

01:34:20.300 --> 01:34:22.300
这些高薪比面式体

01:34:22.300 --> 01:34:23.300
也就这样

01:34:23.300 --> 01:34:25.300
你肯定是可以搞定的

01:34:25.300 --> 01:34:27.300
需要大厂的肯定是要

