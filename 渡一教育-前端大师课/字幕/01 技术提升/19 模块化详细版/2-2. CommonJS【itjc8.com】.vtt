WEBVTT

00:00.620 --> 00:03.620
好 上节课咱们安装了漏了解释

00:03.620 --> 00:06.620
好 这节课咱们就学习了common解释了

00:06.620 --> 00:09.620
因为我们安装漏了解释的目的就是在学习common解释

00:09.620 --> 00:13.620
我们要知道在漏了解释里边呢

00:13.620 --> 00:16.620
因为它由于它只有一个入口文件

00:16.620 --> 00:19.620
就是我们启动的时候只能启动一个解释文件

00:19.620 --> 00:22.620
而开发一个大型的应用的话

00:22.620 --> 00:24.620
不管是开发大型应用还是小型应用

00:24.620 --> 00:26.620
一个文件肯定是不够的

00:26.620 --> 00:28.620
那么肯定会设计到多个文件来配合

00:28.620 --> 00:31.620
然后完成整个应用的功能

00:31.620 --> 00:34.620
那么这个时候呢就需要模块画了

00:34.620 --> 00:36.620
因为你不是一个文件

00:36.620 --> 00:37.620
每个文件就把当成一个模块

00:37.620 --> 00:38.620
当成一个功能块的话

00:38.620 --> 00:39.620
它需要多个文件来配合

00:39.620 --> 00:41.620
那就需要多个模块

00:41.620 --> 00:43.620
那么这些模块之间怎么来互相引用

00:43.620 --> 00:47.620
我用你利用它怎么来管理这个复杂的关系

00:47.620 --> 00:49.620
那么这就是模块画要做的事情

00:49.620 --> 00:51.620
因此呢 漏的解释呢

00:51.620 --> 00:54.620
它对模块画的需求要比浏览器要大得多

00:54.620 --> 00:55.620
因为浏览器里边呢

00:55.620 --> 00:57.620
它可以用多个解释文件吧

00:57.620 --> 00:59.620
虽然说恶心一点啊

00:59.620 --> 01:01.620
会造成全局别量的污染

01:01.620 --> 01:03.620
还造成各种各样的问题

01:03.620 --> 01:05.620
这些问题我们之前都讲过了

01:05.620 --> 01:07.620
但是呢 它至少还可以用

01:07.620 --> 01:09.620
但是漏的解释里边就不行了

01:09.620 --> 01:11.620
因为它只能启动一个文件

01:11.620 --> 01:13.620
而我们开发的时候呢

01:13.620 --> 01:14.620
肯定要设计多个文件

01:14.620 --> 01:16.620
那么就必须要有一个模块画

01:16.620 --> 01:18.620
来管理这种异蛋

01:18.620 --> 01:20.620
比方说下面这张图

01:20.620 --> 01:22.620
比方说几个例子

01:22.620 --> 01:24.620
我们这个应用里边有五个文件

01:24.620 --> 01:25.620
我们的启动文件是

01:25.620 --> 01:27.620
启动文件是index.js

01:27.620 --> 01:29.620
然后还有其他别的功能的文件

01:29.620 --> 01:32.620
比如说A.js, B.js, C, D

01:32.620 --> 01:33.620
那么这些GS呢

01:33.620 --> 01:35.620
它们各自有各自的功能

01:35.620 --> 01:37.620
并且它们会形成一种依赖关系

01:37.620 --> 01:40.620
比方说我们在启动入口文件里边

01:40.620 --> 01:42.620
我们要用到A.js里边的东西

01:42.620 --> 01:44.620
又要用到C.js里边的东西

01:44.620 --> 01:46.620
该怎么去用

01:46.620 --> 01:48.620
A.js呢 它又要用到B.js

01:48.620 --> 01:49.620
和D.js

01:49.620 --> 01:50.620
那么这又该怎么去用

01:50.620 --> 01:52.620
怎么来形成这种关系

01:52.620 --> 01:54.620
这就是模块画

01:54.620 --> 01:56.620
它需要规范的一个问题

01:56.620 --> 01:58.620
由于Note.js刚刚发布的时候

01:58.620 --> 02:00.620
我们之前讲过历史

02:00.620 --> 02:02.620
那个时候前端还没有

02:02.620 --> 02:05.620
统一的官方的模块画规范

02:05.620 --> 02:06.620
那么这个时候

02:06.620 --> 02:08.620
就会出现一些民间的规范

02:08.620 --> 02:10.620
因此它最终选择的模块画规范

02:10.620 --> 02:12.620
是社区提供的

02:12.620 --> 02:14.620
不是官方的common.js

02:14.620 --> 02:16.620
它把common.js作为

02:16.620 --> 02:18.620
模块画的规范

02:18.620 --> 02:20.620
而我们这一刻呢

02:20.620 --> 02:21.620
要学习common.js

02:21.620 --> 02:23.620
之前呢 首先认识两个

02:23.620 --> 02:24.620
重要的概念

02:24.620 --> 02:25.620
一个是模块的导出

02:25.620 --> 02:27.620
一个是模块的导入

02:27.620 --> 02:28.620
这两个概念呢

02:28.620 --> 02:30.620
它贯穿我们整个

02:30.620 --> 02:32.620
模块画学习的过程

02:32.620 --> 02:33.620
就说我们这两个概念

02:33.620 --> 02:34.620
学习了之后呢

02:34.620 --> 02:35.620
不管是我们

02:35.620 --> 02:37.620
这一节课学的common.js也好

02:37.620 --> 02:38.620
还是呢

02:38.620 --> 02:40.620
我们后续学的什么AMD啊

02:40.620 --> 02:42.620
CMD啊 以及ES6的官方模块画

02:42.620 --> 02:43.620
标准

02:43.620 --> 02:44.620
不管什么学习

02:44.620 --> 02:46.620
什么样的模块画

02:46.620 --> 02:47.620
那么他们的

02:47.620 --> 02:48.620
都有这两个概念

02:48.620 --> 02:50.620
都有个模块的导出和模块的导入

02:50.620 --> 02:52.620
那么什么叫做模块的导出呢

02:52.620 --> 02:54.620
我们来看一下啊

02:54.620 --> 02:57.620
我们如果说要理解模块导出的话

02:57.620 --> 02:58.620
你首先的理解

02:58.620 --> 03:00.620
什么叫做模块

03:00.620 --> 03:01.620
啥叫模块呢

03:01.620 --> 03:02.620
我们可以认为

03:02.620 --> 03:03.620
一个模块呢

03:03.620 --> 03:05.620
就是一个介石文件

03:05.620 --> 03:07.620
一个介石文件就是一个模块

03:07.620 --> 03:08.620
这个文件呢

03:08.620 --> 03:09.620
它实现了一部分功能

03:09.620 --> 03:11.620
并且隐藏了

03:11.620 --> 03:13.620
自己的内部实现

03:13.620 --> 03:14.620
同时呢

03:14.620 --> 03:15.620
提供了一些接口

03:15.620 --> 03:17.620
共其他模块使用

03:17.620 --> 03:19.620
那这个东西怎么理解呢

03:19.620 --> 03:20.620
比方说啊

03:20.620 --> 03:21.620
比方说举个例子

03:21.620 --> 03:23.620
我这里呢写上一个文件

03:23.620 --> 03:25.620
写上一个啥呀

03:25.620 --> 03:26.620
比方说写上一个UTO吧

03:26.620 --> 03:27.620
一个工具

03:27.620 --> 03:28.620
第二介石

03:28.620 --> 03:29.620
写上这么一个文件

03:29.620 --> 03:30.620
这个文件里面呢

03:30.620 --> 03:32.620
我们写上

03:32.620 --> 03:34.620
写上这么一个函数

03:34.620 --> 03:35.620
写上一个函数

03:35.620 --> 03:36.620
这个函数的功能呢

03:36.620 --> 03:38.620
是每一次得到一个

03:38.620 --> 03:40.620
得到一个数字

03:40.620 --> 03:41.620
这个数字呢

03:41.620 --> 03:42.620
比之前得到的数字

03:42.620 --> 03:43.620
要增加一个

03:43.620 --> 03:45.620
比方说我们这写出来就明白了

03:45.620 --> 03:46.620
get

03:46.620 --> 03:47.620
number

03:47.620 --> 03:48.620
得到一个数字

03:48.620 --> 03:50.620
这是一个函数

03:50.620 --> 03:51.620
这个函数呢

03:51.620 --> 03:52.620
它返回的是什么呢

03:52.620 --> 03:54.620
返回的是一个数字

03:54.620 --> 03:55.620
比方说

03:55.620 --> 03:57.620
第一次调用的这个函数的时候呢

03:57.620 --> 03:58.620
返回的是0

03:58.620 --> 03:59.620
第二次调用的时候呢

03:59.620 --> 04:00.620
返回的是1

04:00.620 --> 04:01.620
第二次三次调用的时候呢

04:01.620 --> 04:02.620
返回的是2

04:02.620 --> 04:04.620
比方说有这么一个函数

04:04.620 --> 04:06.620
那么这个函数该怎么写呢

04:06.620 --> 04:07.620
你肯定不能在这里

04:07.620 --> 04:09.620
你肯定不能在这里定一个变量

04:09.620 --> 04:11.620
从0开始吧

04:11.620 --> 04:12.620
每一次加1

04:12.620 --> 04:14.620
然后返回

04:14.620 --> 04:16.620
你肯定不能这样子定一

04:16.620 --> 04:17.620
为什么呢

04:17.620 --> 04:18.620
的话

04:18.620 --> 04:19.620
每一次调用函数

04:19.620 --> 04:21.620
它都是同样的一个变量

04:21.620 --> 04:22.620
那么我们一般会怎么另一呢

04:22.620 --> 04:23.620
我们可以这样子写

04:23.620 --> 04:25.620
把这个变量写出去

04:25.620 --> 04:26.620
写出去

04:26.620 --> 04:28.620
这样子是不是形成全局变量了

04:28.620 --> 04:29.620
对吧

04:29.620 --> 04:30.620
是不是形成全局变量了

04:30.620 --> 04:31.620
那么这个变量呢

04:31.620 --> 04:32.620
每次调用函数的时候

04:32.620 --> 04:33.620
是不是加1

04:33.620 --> 04:34.620
然后再返回

04:34.620 --> 04:35.620
那么这样子没问题了

04:35.620 --> 04:36.620
对吧

04:36.620 --> 04:37.620
没问题吧

04:37.620 --> 04:38.620
我们再输出一下

04:38.620 --> 04:39.620
get

04:39.620 --> 04:40.620
number

04:41.620 --> 04:42.620
我们假设

04:42.620 --> 04:44.620
把它当成入口文件

04:44.620 --> 04:46.620
调用了4次

04:47.620 --> 04:48.620
load

04:51.620 --> 04:52.620
实际上

04:52.620 --> 04:53.620
这里还可以不用给后维

04:53.620 --> 04:54.620
不用给get是后维

04:54.620 --> 04:56.620
它会自动把后维给加上

04:56.620 --> 04:57.620
那么我们看到

04:57.620 --> 04:58.620
它输出了什么

04:58.620 --> 04:59.620
1234

04:59.620 --> 05:00.620
没问题吧

05:00.620 --> 05:02.620
这就是我们这个地方

05:02.620 --> 05:04.620
比方说要实现成功了

05:04.620 --> 05:05.620
那么我们刚才

05:05.620 --> 05:06.620
把它当成入口文件

05:06.620 --> 05:08.620
如果它不是入口文件

05:08.620 --> 05:09.620
它只是形成一个模块

05:09.620 --> 05:11.620
它要被其他文件所使用

05:11.620 --> 05:13.620
被其他模块所使用

05:13.620 --> 05:14.620
那么这个时候

05:14.620 --> 05:15.620
你要考虑到一个问题

05:15.620 --> 05:16.620
就是这个模块里面

05:16.620 --> 05:18.620
可能有很多代码

05:18.620 --> 05:19.620
有一些东西

05:19.620 --> 05:21.620
我是希望别人使用的

05:21.620 --> 05:22.620
有一些东西

05:22.620 --> 05:23.620
我是不希望别人使用的

05:23.620 --> 05:24.620
比方说

05:24.620 --> 05:25.620
像这个函数

05:25.620 --> 05:26.620
这个函数

05:26.620 --> 05:28.620
是不是比希望别人使用

05:28.620 --> 05:29.620
我希望别人能够使用这个函数

05:29.620 --> 05:30.620
不然的话

05:30.620 --> 05:31.620
我写个模块干嘛呢

05:31.620 --> 05:32.620
我写这个模块

05:32.620 --> 05:34.620
就是来提供这么一个函数

05:34.620 --> 05:35.620
这么一个功能的

05:35.620 --> 05:36.620
我希望把这个函数

05:36.620 --> 05:37.620
包露出去

05:37.620 --> 05:39.620
这是我们要包露的那种

05:39.620 --> 05:41.620
要包露

05:41.620 --> 05:43.620
给外部的

05:43.620 --> 05:44.620
接口

05:44.620 --> 05:45.620
什么叫接口

05:45.620 --> 05:46.620
就是一些数据

05:46.620 --> 05:47.620
堆箱

05:47.620 --> 05:48.620
函数

05:48.620 --> 05:50.620
我们希望给外面使用的东西

05:50.620 --> 05:51.620
这是接口

05:51.620 --> 05:53.620
我要包露给外部的接口

05:53.620 --> 05:55.620
我们希望外面能够使用这个函数

05:55.620 --> 05:56.620
但是有一些东西

05:56.620 --> 05:58.620
我们是不希望给外面使用的

05:58.620 --> 05:59.620
比方说像这个东西

05:59.620 --> 06:00.620
我不希望外面

06:00.620 --> 06:01.620
能够访问到这个东西

06:01.620 --> 06:02.620
需要

06:02.620 --> 06:06.620
这就是需要隐藏的内部实现

06:06.620 --> 06:07.620
就是这个模块

06:07.620 --> 06:08.620
对于整个这个文件

06:08.620 --> 06:09.620
整个这个模块而言

06:09.620 --> 06:10.620
我们这一部分

06:10.620 --> 06:11.620
是希望包露给外面的

06:11.620 --> 06:12.620
这一部分

06:12.620 --> 06:13.620
希望隐藏起来

06:13.620 --> 06:15.620
不要给外面使用的

06:15.620 --> 06:16.620
因为包露出去

06:16.620 --> 06:17.620
那么多干嘛

06:17.620 --> 06:18.620
造成了一些东西的污染

06:18.620 --> 06:19.620
而且让整个接口

06:19.620 --> 06:20.620
变得非常复杂

06:20.620 --> 06:21.620
我们只需要

06:21.620 --> 06:22.620
外面使用这个就行了

06:22.620 --> 06:23.620
对吧

06:23.620 --> 06:24.620
那么这种情况下

06:24.620 --> 06:25.620
就需要模块化

06:25.620 --> 06:26.620
来解决这个问题

06:26.620 --> 06:28.620
它怎么来隐藏自己

06:28.620 --> 06:29.620
就怎么来包露

06:29.620 --> 06:30.620
给外面使用

06:30.620 --> 06:31.620
所以说模块

06:31.620 --> 06:32.620
它有两个核心的要数

06:32.620 --> 06:33.620
一个是隐藏

06:33.620 --> 06:34.620
一个是包露

06:34.620 --> 06:35.620
隐藏的是什么呢

06:35.620 --> 06:36.620
实际内部的实现

06:36.620 --> 06:38.620
不希望外面使用的

06:38.620 --> 06:39.620
包露的是什么呢

06:39.620 --> 06:41.620
是希望外面使用的

06:42.620 --> 06:43.620
任何一个

06:43.620 --> 06:44.620
正常的模块化标准

06:44.620 --> 06:46.620
宏观是什么C语言

06:46.620 --> 06:48.620
加拿亚C下谱

06:48.620 --> 06:49.620
他们都有这样的一个

06:49.620 --> 06:50.620
现象

06:50.620 --> 06:51.620
都有这个样的现象

06:51.620 --> 06:52.620
它怎么去隐藏

06:52.620 --> 06:54.620
怎么去包露

06:54.620 --> 06:55.620
任何一个正常的

06:55.620 --> 06:56.620
模块化标准

06:56.620 --> 06:58.620
都应该默认

06:58.620 --> 07:00.620
隐藏模块中的

07:00.620 --> 07:01.620
所有实现

07:01.620 --> 07:02.620
而通过一些

07:02.620 --> 07:04.620
语法或API调用

07:04.620 --> 07:06.620
来包露接口

07:06.620 --> 07:07.620
这句话怎么意思呢

07:07.620 --> 07:08.620
就是说

07:08.620 --> 07:09.620
如果说你是一个

07:09.620 --> 07:10.620
正常的模块化

07:10.620 --> 07:11.620
不是那么奇葩

07:11.620 --> 07:12.620
那么你都应该

07:12.620 --> 07:14.620
按照这种模式来做

07:14.620 --> 07:15.620
就是默认情况下

07:15.620 --> 07:17.620
这些东西全部是隐藏的

07:17.620 --> 07:18.620
全部隐藏

07:18.620 --> 07:19.620
以外边

07:19.620 --> 07:21.620
其他模块想使用的东西

07:21.620 --> 07:22.620
一个都用不了

07:22.620 --> 07:24.620
都是内部的实现

07:24.620 --> 07:26.620
包括这些边量

07:26.620 --> 07:27.620
函数

07:27.620 --> 07:28.620
都不会造成任何的

07:28.620 --> 07:30.620
全局的污染

07:30.620 --> 07:31.620
不会造成任何的污染

07:31.620 --> 07:32.620
都是内部的实现

07:32.620 --> 07:34.620
那么外边要使用的时候

07:34.620 --> 07:36.620
我要包露给外边使用的时候

07:36.620 --> 07:39.620
要通过一些特殊的语法

07:39.620 --> 07:41.620
或者是一些API

07:41.620 --> 07:42.620
API什么调用函数

07:42.620 --> 07:45.620
或者是给某个对象负责之类的东西

07:45.620 --> 07:47.620
通过一些特定的方式

07:47.620 --> 07:48.620
来包露给外面

07:48.620 --> 07:49.620
比方说现在我没有

07:49.620 --> 07:50.620
使用特定的方式

07:50.620 --> 07:51.620
那么这个模块里边

07:51.620 --> 07:52.620
这两个东西

07:52.620 --> 07:54.620
全部都是隐藏的

07:54.620 --> 07:55.620
这是默认情况

07:55.620 --> 07:57.620
要通过一些特殊语法

07:57.620 --> 07:58.620
来包露接口

07:58.620 --> 07:59.620
那么这下面一张图

07:59.620 --> 08:00.620
大家可以看一下

08:00.620 --> 08:01.620
通过这张图

08:01.620 --> 08:03.620
大家可以更加容易的理解出

08:03.620 --> 08:04.620
一个模块

08:04.620 --> 08:05.620
它怎么运作呢

08:05.620 --> 08:06.620
比方说这是一个模块

08:06.620 --> 08:07.620
Utl.js

08:07.620 --> 08:08.620
比方说这是个模块

08:08.620 --> 08:10.620
那么它自己有很多的内部实现

08:10.620 --> 08:11.620
我需要隐藏起来

08:11.620 --> 08:13.620
我不希望外面能够使用

08:13.620 --> 08:15.620
另外我希望外面使用的东西

08:15.620 --> 08:18.620
我通过某种方式把包露出去

08:18.620 --> 08:20.620
当然它可能会包换多个东西

08:20.620 --> 08:21.620
比方说一个函数

08:21.620 --> 08:22.620
我可以包露出去

08:22.620 --> 08:24.620
我可以包露出去一个对象

08:24.620 --> 08:25.620
我不解一个对象

08:25.620 --> 08:27.620
也可以包露出去一个

08:27.620 --> 08:29.620
就是字幕串

08:29.620 --> 08:30.620
都可以

08:30.620 --> 08:32.620
包露任何东西都可以

08:32.620 --> 08:33.620
有可能我需要包露多个东西

08:33.620 --> 08:34.620
都没问题

08:34.620 --> 08:36.620
这就是一个模块

08:36.620 --> 08:37.620
要解决这样的问题

08:37.620 --> 08:38.620
它怎么来隐藏

08:38.620 --> 08:40.620
又怎么来包露

08:40.620 --> 08:41.620
那么我们把

08:41.620 --> 08:43.620
包露接口的过程

08:43.620 --> 08:46.620
称之为模块的导出

08:46.620 --> 08:48.620
以后我们就会学习怎么来包露了

08:48.620 --> 08:50.620
整个包露的过程就是

08:50.620 --> 08:51.620
模块的导出

08:51.620 --> 08:52.620
比方说我们要把这个东西

08:52.620 --> 08:54.620
我们要把这个东西

08:54.620 --> 08:55.620
包露出去

08:55.620 --> 08:56.620
我们就说

08:56.620 --> 08:57.620
我要把这个东西导出

08:57.620 --> 08:58.620
没了意思吗

08:58.620 --> 09:00.620
这是模块导出是什么意思

09:00.620 --> 09:02.620
导出是给外面用

09:02.620 --> 09:04.620
这就是模块导出的概念

09:04.620 --> 09:06.620
那么什么叫模块导入呢

09:06.620 --> 09:07.620
那就很简单了

09:07.620 --> 09:08.620
一个模块

09:08.620 --> 09:09.620
它肯定包住了一些东西

09:09.620 --> 09:10.620
对吧

09:10.620 --> 09:11.620
那么我们要用这个模块的时候

09:11.620 --> 09:12.620
怎么样用

09:12.620 --> 09:14.620
它包露出来的东西

09:14.620 --> 09:15.620
这就是导入

09:15.620 --> 09:17.620
需要使用一个模块的时候

09:17.620 --> 09:18.620
如果说你

09:18.620 --> 09:20.620
肯定是使用的是

09:20.620 --> 09:21.620
该模块包住的部分

09:21.620 --> 09:23.620
那么这就是导出的部分

09:23.620 --> 09:24.620
那么隐藏的部分

09:24.620 --> 09:25.620
是永远无法使用的

09:25.620 --> 09:26.620
我们把

09:26.620 --> 09:28.620
通过某种语法

09:28.620 --> 09:29.620
或者API

09:29.620 --> 09:30.620
通过某种方式

09:30.620 --> 09:32.620
去使用一个模块

09:32.620 --> 09:33.620
把这个过程

09:33.620 --> 09:34.620
叫做模块的导入

09:34.620 --> 09:35.620
就这么个概念

09:35.620 --> 09:36.620
我要用它

09:36.620 --> 09:37.620
我肯定要用它

09:37.620 --> 09:38.620
包住出来的东西

09:38.620 --> 09:39.620
我怎么去用它

09:39.620 --> 09:40.620
包住出来的东西

09:40.620 --> 09:41.620
这个过程就是叫做

09:41.620 --> 09:42.620
模块的导入

09:42.620 --> 09:43.620
这是两个概念

09:43.620 --> 09:45.620
模块的导出和导入

09:45.620 --> 09:46.620
好

09:46.620 --> 09:47.620
接下来我们来看一下

09:47.620 --> 09:49.620
CommonJets规范里面

09:49.620 --> 09:50.620
它怎么来规定

09:50.620 --> 09:51.620
我怎么来导出一个模块

09:51.620 --> 09:53.620
怎么来导入一个模块

09:53.620 --> 09:54.620
其实CommonJets

09:54.620 --> 09:56.620
是一个非常非常简单

09:56.620 --> 09:58.620
简洁的一个规范

09:58.620 --> 10:00.620
它里面那种真不多

10:00.620 --> 10:01.620
我们来看一下

10:01.620 --> 10:02.620
它里面的规范

10:02.620 --> 10:03.620
那种

10:03.620 --> 10:04.620
它说CommonJets

10:04.620 --> 10:06.620
它规范规定

10:06.620 --> 10:08.620
我应该使用Export

10:08.620 --> 10:11.620
这种方式来导出模块

10:11.620 --> 10:13.620
应该使用Require

10:13.620 --> 10:14.620
来导入模块

10:14.620 --> 10:15.620
如果说你要导出

10:15.620 --> 10:16.620
你要包住给外面使用

10:16.620 --> 10:18.620
那么你可以使用Export

10:18.620 --> 10:19.620
具体怎么使用

10:19.620 --> 10:20.620
我们一会再说

10:20.620 --> 10:21.620
你要导入一个模块

10:21.620 --> 10:22.620
你要用这个模块里面的东西

10:22.620 --> 10:23.620
我们使用Require

10:23.620 --> 10:25.620
这种方式来导入模块

10:25.620 --> 10:27.620
具体的东西如下

10:27.620 --> 10:28.620
首先

10:28.620 --> 10:29.620
如果说

10:29.620 --> 10:31.620
一个Jets文件中存在Export

10:31.620 --> 10:32.620
或者是Require

10:32.620 --> 10:34.620
那么这个文件是一个模块

10:34.620 --> 10:35.620
那么CommonJets

10:35.620 --> 10:36.620
就会认为

10:36.620 --> 10:38.620
这个文件就应该是一个模块文件

10:38.620 --> 10:39.620
比方说像这个文件

10:39.620 --> 10:41.620
这个文件是不是一个模块文件呢

10:41.620 --> 10:42.620
不是

10:42.620 --> 10:43.620
它就不是一个模块文件

10:43.620 --> 10:45.620
因为它里面没有用到Export

10:45.620 --> 10:46.620
也没有用到Require

10:46.620 --> 10:47.620
对吧

10:47.620 --> 10:48.620
第二个点

10:48.620 --> 10:50.620
模块内的所有代码

10:50.620 --> 10:52.620
均为隐藏代码

10:52.620 --> 10:53.620
什么叫隐藏代码

10:53.620 --> 10:55.620
就是只有内部可以使用

10:55.620 --> 10:57.620
就是在这个模块内部

10:57.620 --> 10:58.620
像这个变量

10:58.620 --> 10:59.620
这个模块内部可以使用

10:59.620 --> 11:00.620
外边是使用不了的

11:00.620 --> 11:01.620
就是

11:01.620 --> 11:02.620
对外边的

11:02.620 --> 11:03.620
其他模块而言

11:03.620 --> 11:04.620
这个模块

11:04.620 --> 11:06.620
这些东西是隐藏起来的

11:06.620 --> 11:08.620
就是关于这一点

11:08.620 --> 11:09.620
包括什么全局变量

11:09.620 --> 11:10.620
全局函数

11:10.620 --> 11:11.620
这些内容

11:11.620 --> 11:13.620
都不应该对全局变量造成

11:13.620 --> 11:14.620
任何的污染

11:14.620 --> 11:15.620
比方说我们像

11:15.620 --> 11:16.620
在浏览期段

11:16.620 --> 11:17.620
你定一个变量

11:17.620 --> 11:18.620
用这种方式定一个变量

11:18.620 --> 11:20.620
那肯定对全局造成污染了

11:20.620 --> 11:21.620
对吧

11:21.620 --> 11:22.620
它会附着在Window下面

11:22.620 --> 11:23.620
但是在mode

11:23.620 --> 11:24.620
在nodeJets

11:24.620 --> 11:25.620
CommonJets

11:25.620 --> 11:26.620
这种规范下面

11:26.620 --> 11:27.620
它就不会

11:27.620 --> 11:29.620
它就不会暴露给外面

11:29.620 --> 11:30.620
没有什么意思

11:30.620 --> 11:32.620
就是模人都是隐藏的

11:32.620 --> 11:33.620
模人都是隐藏的

11:33.620 --> 11:34.620
但是

11:34.620 --> 11:36.620
这个var的关键字

11:36.620 --> 11:37.620
还是尽量不要使用

11:37.620 --> 11:38.620
因为它毕竟有

11:38.620 --> 11:40.620
虽然说没有污染全局

11:40.620 --> 11:42.620
但是它毕竟有提升

11:42.620 --> 11:43.620
有比较变量提升

11:43.620 --> 11:44.620
所以我们尽量

11:44.620 --> 11:45.620
应该还是使用net

11:45.620 --> 11:46.620
应该net

11:46.620 --> 11:47.620
当然聊前提

11:47.620 --> 11:48.620
聊学习ES6

11:48.620 --> 11:49.620
因为我这个课

11:49.620 --> 11:51.620
要希望

11:51.620 --> 11:52.620
不管你是什么基础

11:52.620 --> 11:53.620
我希望

11:53.620 --> 11:54.620
只要你学到Jets

11:54.620 --> 11:55.620
我希望都能听得懂

11:55.620 --> 11:56.620
因此我这里

11:56.620 --> 11:57.620
尽量的

11:57.620 --> 11:58.620
不用ES6的东西

11:59.620 --> 12:01.620
这是关于第二点

12:01.620 --> 12:02.620
第三点

12:02.620 --> 12:04.620
就是具体来说了

12:04.620 --> 12:06.620
具体该怎么来暴露呢

12:06.620 --> 12:08.620
如果说一个模块

12:08.620 --> 12:09.620
需要暴露一些东西

12:09.620 --> 12:10.620
给外面使用

12:10.620 --> 12:12.620
那么需要通过exports

12:12.620 --> 12:13.620
来导出

12:13.620 --> 12:14.620
exports是什么呢

12:14.620 --> 12:16.620
是一个空的对象

12:16.620 --> 12:17.620
你可以为该对象

12:17.620 --> 12:19.620
添加任何需要导出的内容

12:19.620 --> 12:20.620
这就有意思了

12:20.620 --> 12:21.620
比方说

12:21.620 --> 12:23.620
我要暴露这个东西

12:23.620 --> 12:24.620
给外面

12:24.620 --> 12:25.620
我希望把这个寒数

12:25.620 --> 12:26.620
暴露给外面来使用

12:26.620 --> 12:27.620
那怎么办

12:27.620 --> 12:29.620
我可以使用这种方式

12:29.620 --> 12:31.620
exports

12:31.620 --> 12:33.620
exports

12:33.620 --> 12:34.620
注意

12:34.620 --> 12:35.620
后面给s

12:35.620 --> 12:36.620
然后呢

12:36.620 --> 12:37.620
它是一个空对象

12:37.620 --> 12:39.620
你可以认为exports

12:39.620 --> 12:40.620
它是什么呢

12:40.620 --> 12:41.620
是一个空对象

12:41.620 --> 12:42.620
你可以认为

12:42.620 --> 12:43.620
它是这么一个东西

12:43.620 --> 12:44.620
那么你可以

12:44.620 --> 12:45.620
往对象里边

12:45.620 --> 12:46.620
添加任何东西

12:46.620 --> 12:47.620
你往对象里边

12:47.620 --> 12:48.620
添加的东西

12:48.620 --> 12:49.620
它就是要导出的东西

12:49.620 --> 12:50.620
因为它最终

12:50.620 --> 12:51.620
它导出的是什么呢

12:51.620 --> 12:52.620
导出的就是

12:52.620 --> 12:53.620
整个对象

12:53.620 --> 12:55.620
它会把整个对象导出

12:55.620 --> 12:56.620
那么比方说

12:56.620 --> 12:57.620
我们这个exports

12:57.620 --> 12:58.620
第2

12:58.620 --> 12:59.620
什么呢

12:59.620 --> 13:00.620
第2

13:00.620 --> 13:01.620
get number

13:01.620 --> 13:02.620
比方说

13:02.620 --> 13:03.620
这样子写

13:03.620 --> 13:04.620
什么意思呢

13:04.620 --> 13:05.620
这样子写到过后

13:05.620 --> 13:06.620
那么这个exports

13:06.620 --> 13:07.620
它变成什么了

13:07.620 --> 13:09.620
我们打个注释

13:10.620 --> 13:11.620
这个exports

13:11.620 --> 13:12.620
它变成什么了

13:12.620 --> 13:13.620
exports

13:13.620 --> 13:14.620
它变成这么一个东西了

13:15.620 --> 13:16.620
这里边

13:16.620 --> 13:17.620
是不是有get number属性了

13:17.620 --> 13:18.620
对吧

13:18.620 --> 13:19.620
一个加了一个属性

13:19.620 --> 13:20.620
它本来是个空对象的

13:20.620 --> 13:21.620
一个加了一个属性

13:21.620 --> 13:22.620
这个属性等于什么

13:22.620 --> 13:23.620
是不是等于这个

13:23.620 --> 13:24.620
是不是等于这个

13:26.620 --> 13:27.620
相当于是这样子的

13:27.620 --> 13:28.620
对吧

13:28.620 --> 13:29.620
是不是相当于把这个函数

13:29.620 --> 13:31.620
就给对象里边的属性复制了

13:31.620 --> 13:32.620
没问题吧

13:33.620 --> 13:35.620
当然你也可以怎么写

13:35.620 --> 13:37.620
你也可以把这个东西写过来

13:39.620 --> 13:43.060
你是不是可以这样子写

13:43.060 --> 13:44.060
这样子写也可以暴露

13:44.060 --> 13:45.060
对吧

13:45.060 --> 13:46.060
一样的

13:46.060 --> 13:47.060
甚至你可以把它写成个

13:47.060 --> 13:48.060
匿名函数都无所谓

13:49.060 --> 13:51.060
这样子写也没问题

13:51.060 --> 13:52.060
没啥意思吗

13:52.060 --> 13:53.060
总之你要暴露什么东西

13:53.060 --> 13:55.060
那就给它相应的属性复制

13:55.060 --> 13:56.060
随便什么属性

13:56.060 --> 13:57.060
按下什么属性就是什么属性

13:57.060 --> 13:58.060
名字都无所谓

13:59.060 --> 14:00.060
比方说再来

14:00.060 --> 14:01.060
再来

14:01.060 --> 14:02.060
我们又写一句话

14:02.060 --> 14:03.060
export 第二个什么

14:03.060 --> 14:05.060
abc 等于123

14:05.060 --> 14:07.060
暴露一个数据

14:07.060 --> 14:08.060
一个数据 一个长量

14:08.060 --> 14:09.060
123

14:09.060 --> 14:10.060
请问一下

14:10.060 --> 14:11.060
可以

14:11.060 --> 14:12.060
那么这样子一来

14:12.060 --> 14:13.060
这个export变成什么样子了

14:13.060 --> 14:15.060
把这个复制一下

14:15.060 --> 14:18.700
它就变成了这个样子

14:18.700 --> 14:19.700
这里是个函数

14:19.700 --> 14:21.700
fn 表示个函数

14:21.700 --> 14:22.700
这里是个函数

14:22.700 --> 14:24.700
然后那一个就是abc

14:24.700 --> 14:25.700
变成了123

14:25.700 --> 14:26.700
没啥意思吗

14:26.700 --> 14:27.700
那么这个对象

14:27.700 --> 14:29.700
它就是最终导出的东西

14:29.700 --> 14:30.700
它会把整个对象导出

14:30.700 --> 14:32.700
因此你只需要在对象里边

14:32.700 --> 14:33.700
加上任何你想要导出的东西

14:33.700 --> 14:34.700
就完事了

14:34.700 --> 14:36.700
这是common介绍规范

14:36.700 --> 14:37.700
它要做的事情

14:38.700 --> 14:40.700
这就是如何来导出一个模块

14:41.700 --> 14:43.700
那么如何来导入一个模块呢

14:43.700 --> 14:44.700
就什么意思呢

14:44.700 --> 14:45.700
就在其他模块里边

14:45.700 --> 14:46.700
或者是其他入口文件

14:46.700 --> 14:48.700
或者是什么文件里边

14:48.700 --> 14:49.700
你要使用别的

14:49.700 --> 14:51.700
别人写的模块

14:51.700 --> 14:52.700
不是别人写的

14:52.700 --> 14:54.700
就是使用其他模块

14:54.700 --> 14:55.700
那你怎么去使用呢

14:55.700 --> 14:56.700
看着

14:56.700 --> 14:57.700
我们在这里

14:57.700 --> 14:59.700
比方说建立一个index

14:59.700 --> 15:00.700
调介石

15:00.700 --> 15:01.700
我们通常会使用index

15:01.700 --> 15:02.700
调介石

15:02.700 --> 15:04.700
表示一个入口文件

15:04.700 --> 15:06.700
那么我们这里

15:06.700 --> 15:07.700
比方说

15:07.700 --> 15:11.070
我们这里有自己的代码

15:11.070 --> 15:13.070
count等于1

15:13.070 --> 15:15.070
我现在问大家一个问题

15:15.070 --> 15:16.070
这个count等于1

15:16.070 --> 15:17.070
跟这边的count

15:17.070 --> 15:19.070
会不会造成冲突

15:19.070 --> 15:20.070
会不会

15:20.070 --> 15:21.070
不会

15:22.070 --> 15:23.070
为什么不会呢

15:23.070 --> 15:24.070
因为这里的count

15:24.070 --> 15:26.070
是一个模块里边的count

15:26.070 --> 15:27.070
这个count

15:27.070 --> 15:30.070
是内部隐藏的东西

15:30.070 --> 15:31.070
外面是使用不了的

15:31.070 --> 15:32.070
所以说

15:32.070 --> 15:33.070
在这个模块里边

15:33.070 --> 15:34.070
跟这个模块里边

15:34.070 --> 15:35.070
是两个模块

15:35.070 --> 15:36.070
它们各自有各自内部的东西

15:36.070 --> 15:37.070
所以说不会造成

15:37.070 --> 15:39.070
任何名称的冲突

15:39.070 --> 15:40.070
以后我们会讲解

15:40.070 --> 15:41.070
common件是具体

15:41.070 --> 15:42.070
是怎么来操作

15:42.070 --> 15:45.070
让它们避免这个问题的

15:45.070 --> 15:46.070
我们以后会详心讲解

15:46.070 --> 15:47.070
那么这里

15:47.070 --> 15:48.070
先大概认识一下

15:48.070 --> 15:49.070
那么这些名称

15:49.070 --> 15:50.070
它是不会造成冲突的

15:50.070 --> 15:51.070
那比方说

15:51.070 --> 15:53.070
我们在这个index.js里边

15:53.070 --> 15:55.070
要使用这个utl里边的东西

15:55.070 --> 15:56.070
那怎么来使用呢

15:56.070 --> 15:57.070
它不是导出两个东西

15:57.070 --> 15:58.070
对吧

15:58.070 --> 15:59.070
导出相当于导出一个对象

15:59.070 --> 16:00.070
这个对象里边有两个属性

16:00.070 --> 16:03.070
那么怎么来导入这个对象呢

16:03.070 --> 16:04.070
怎么来导入呢

16:04.070 --> 16:05.070
你可以通过这种方式

16:05.070 --> 16:07.070
叫做require

16:07.070 --> 16:09.070
require

16:09.070 --> 16:10.070
你要导入的时候

16:10.070 --> 16:12.070
是通过require实现的

16:12.070 --> 16:13.070
require是啥呢

16:13.070 --> 16:14.070
是一个函数

16:14.070 --> 16:16.070
这个函数有一个参数

16:16.070 --> 16:18.070
就是你的模块的路径

16:18.070 --> 16:20.070
比方说我们这里写require

16:20.070 --> 16:21.070
是一个函数

16:21.070 --> 16:23.070
那么这个函数里边有个参数

16:23.070 --> 16:25.070
这里边写上模块的路径

16:25.070 --> 16:26.070
是个支付串

16:26.070 --> 16:27.070
路径那里

16:27.070 --> 16:28.070
这边你就写相对路径就行了

16:28.070 --> 16:29.070
比方说我们这里

16:29.070 --> 16:30.070
导入的是哪个模块呢

16:30.070 --> 16:32.070
导入的是utl.js

16:32.070 --> 16:33.070
第2写抗

16:33.070 --> 16:36.070
utl.js

16:36.070 --> 16:37.070
另外这一次

16:37.070 --> 16:39.070
通过这种方式来导入一个模块

16:39.070 --> 16:41.070
那么这个函数

16:41.070 --> 16:42.070
它肯定有个返回结果

16:42.070 --> 16:44.070
这个函数返回的是什么呢

16:44.070 --> 16:45.070
返回的就是

16:45.070 --> 16:47.070
这个模块里边

16:47.070 --> 16:49.070
导出的那个对象

16:49.070 --> 16:50.070
这个模块导出的是什么

16:50.070 --> 16:51.070
导出的是这个玩意

16:51.070 --> 16:52.070
对吧 是一个对象

16:52.070 --> 16:54.070
因为export是个对象

16:54.070 --> 16:56.070
你往那个export里边加东西

16:56.070 --> 16:57.070
就是往对象里边加东西

16:57.070 --> 17:00.070
这种导出的就是一个export对象

17:00.070 --> 17:01.070
那么这里边呢

17:01.070 --> 17:02.070
它返回的是什么呢

17:02.070 --> 17:05.070
返回的就是一个export对象

17:05.070 --> 17:06.070
因此呢

17:06.070 --> 17:07.070
你这里可以用个变量来接收

17:07.070 --> 17:09.070
比方说变量名字随便你取

17:09.070 --> 17:10.070
随便你取一个名字

17:10.070 --> 17:12.070
比方说你取一个

17:12.070 --> 17:14.070
utl.js

17:14.070 --> 17:15.070
随便取一个

17:15.070 --> 17:17.070
不是说你必须要取这个跟模块

17:17.070 --> 17:18.070
跟那个文件名字一样

17:18.070 --> 17:19.070
没关系

17:19.070 --> 17:20.070
随便取的下去都可以

17:20.070 --> 17:21.070
因为它反

17:21.070 --> 17:22.070
这是个函数返回

17:22.070 --> 17:23.070
函数返回

17:23.070 --> 17:25.070
是不是可以用任何一个变量来接收

17:25.070 --> 17:26.070
对吧

17:26.070 --> 17:28.070
好 我们来输出一下这个utl

17:28.070 --> 17:29.070
输出一下

17:29.070 --> 17:30.070
你看一下

17:31.070 --> 17:32.070
load index

17:32.070 --> 17:34.070
我们现在运行的是啥

17:34.070 --> 17:36.070
运行的是这个index.js

17:36.070 --> 17:38.070
看没 运行的是这个index.js

17:38.070 --> 17:39.070
好 我们再回车

17:39.070 --> 17:40.070
你看一下

17:40.070 --> 17:42.070
得到了是不是个对象

17:42.070 --> 17:43.070
对吧 就是个对象

17:43.070 --> 17:44.070
里面有两个东西

17:44.070 --> 17:45.070
一个是get number

17:45.070 --> 17:46.070
一个是什么abc

17:46.070 --> 17:47.070
对吧

17:47.070 --> 17:48.070
没问题吧

17:48.070 --> 17:49.070
那么当然你要调用这个函数

17:49.070 --> 17:50.070
怎么调用

17:50.070 --> 17:51.070
你去调用

17:51.070 --> 17:52.070
utl.js

17:52.070 --> 17:53.070
get number

17:53.070 --> 17:54.070
对吧

17:54.070 --> 17:55.070
调用就行了

17:55.070 --> 17:57.070
你看 调用三次

17:57.070 --> 17:59.070
对吧 是得到一二三

17:59.070 --> 18:00.070
对吧

18:00.070 --> 18:01.070
没问题吧

18:01.070 --> 18:03.070
但是呢 你在这里面

18:03.070 --> 18:04.070
能不能访问到什么

18:04.070 --> 18:05.070
能不能访问到这个

18:05.070 --> 18:07.070
能不能访问到cont

18:07.070 --> 18:08.070
就是个函

18:08.070 --> 18:09.070
它没有导出的部分

18:09.070 --> 18:10.070
能不能访问

18:10.070 --> 18:11.070
肯定是不能访问的

18:11.070 --> 18:12.070
因为它没有暴露出去

18:12.070 --> 18:14.070
只能带着对象里面加的东西

18:14.070 --> 18:15.070
它只加了这两个

18:15.070 --> 18:17.070
因此外面只能访问这两个

18:17.070 --> 18:18.070
原来的意思

18:19.070 --> 18:20.070
能听懂吧

18:20.070 --> 18:21.070
应该没问题

18:21.070 --> 18:22.070
我们来看一下吧

18:22.070 --> 18:24.380
你看 是不是indefend

18:24.380 --> 18:26.380
对象里面这个属性是没有的

18:27.380 --> 18:28.380
那么这种方式

18:28.380 --> 18:29.380
有好在什么地方

18:29.380 --> 18:30.380
这种方式

18:30.380 --> 18:31.380
这种方式就可以解决

18:31.380 --> 18:33.380
权局变量无展的问题

18:33.380 --> 18:34.380
一看以前

18:34.380 --> 18:35.380
我们用什么立即执行函数

18:35.380 --> 18:36.380
都解决不了

18:36.380 --> 18:37.380
为什么

18:37.380 --> 18:38.380
因为我们以前用

18:38.380 --> 18:39.380
立即执行函数

18:39.380 --> 18:40.380
它有个问题就是

18:40.380 --> 18:41.380
有些要暴露的地方怎么办

18:41.380 --> 18:43.380
你暴露的地方始终要导出去

18:43.380 --> 18:44.380
你要给它形成一个名字

18:44.380 --> 18:46.380
但是这种情况就不会

18:46.380 --> 18:48.380
因为你导入的时候

18:48.380 --> 18:49.380
你才给它取名字

18:50.380 --> 18:51.380
你导入的时候才给它取名字

18:51.380 --> 18:52.380
你想去什么名字

18:52.380 --> 18:53.380
取什么名字

18:53.380 --> 18:54.380
那么这个时候

18:54.380 --> 18:55.380
就不会形成冲突了

18:55.380 --> 18:57.380
因为在这个文件里边

18:57.380 --> 18:58.380
那么我们以后解决

18:58.380 --> 18:59.380
就是要搞定什么

18:59.380 --> 19:00.380
变量冲突的问题

19:00.380 --> 19:02.380
只看这一个模块里边

19:02.380 --> 19:03.380
也没有冲突就行了

19:03.380 --> 19:04.380
就单个模块里边

19:04.380 --> 19:05.380
也没有冲突

19:05.380 --> 19:06.380
那么单个模块

19:06.380 --> 19:07.380
由于它代码比较少

19:07.380 --> 19:09.380
你很容易解决冲突的

19:09.380 --> 19:10.380
那么如果说你这个名字

19:10.380 --> 19:11.380
比较少

19:11.380 --> 19:13.380
我这里边已经有了一个变量了

19:13.380 --> 19:14.380
已经有了一个变量了

19:14.380 --> 19:15.380
叫UTO

19:15.380 --> 19:17.380
我不管它是啥

19:17.380 --> 19:18.380
已经有个变量了

19:18.380 --> 19:20.380
那么这里随便花一个名字就行了

19:20.380 --> 19:23.380
你随便花一个名字就完事了

19:23.380 --> 19:24.380
对不对

19:24.380 --> 19:25.380
你想去什么名字

19:25.380 --> 19:26.380
取什么名字

19:26.380 --> 19:28.380
比方说在另一个文件里边

19:28.380 --> 19:29.380
你又要使用UTO文件

19:29.380 --> 19:31.380
那么你可以换别的名字

19:31.380 --> 19:33.380
在导入的时候

19:33.380 --> 19:34.380
不要那意思

19:34.380 --> 19:35.380
所以说现在的名字

19:35.380 --> 19:36.380
就不会冲突了

19:36.380 --> 19:37.380
因为我是在导入的时候

19:37.380 --> 19:38.380
再给它取名字

19:38.380 --> 19:39.380
导出的时候

19:39.380 --> 19:40.380
是不取名字的

19:40.380 --> 19:41.380
我这里的名字

19:41.380 --> 19:43.380
只是对象内部的东西

19:43.380 --> 19:44.380
你看我这里的名字

19:44.380 --> 19:46.380
只是对象内部的东西

19:46.380 --> 19:47.380
内部的属性

19:47.380 --> 19:48.380
而我这边导入的时候

19:48.380 --> 19:50.380
导入的是整个对象

19:50.380 --> 19:52.380
我给整个对象取一个名字

19:52.380 --> 19:53.380
保存到这个变量里面

19:53.380 --> 19:55.380
相当于是海朔的反回的

19:55.380 --> 19:56.380
就是导出了那种

19:56.380 --> 19:58.380
导出了一个匿名对象

19:58.380 --> 20:00.380
应该没问题吧

20:00.380 --> 20:02.380
这就是这种方式

20:02.380 --> 20:04.380
当然这个required的地方

20:04.380 --> 20:06.380
你可以用在任何

20:06.380 --> 20:07.380
当成表达是

20:07.380 --> 20:08.380
用在任何地方

20:08.380 --> 20:09.380
都可以

20:09.380 --> 20:10.380
因为它就是一个

20:10.380 --> 20:11.380
普普通通的方法

20:11.380 --> 20:12.380
它反回的是什么

20:12.380 --> 20:13.380
反回的就是模块

20:13.380 --> 20:14.380
导出了对象

20:14.380 --> 20:15.380
那么这里你看

20:15.380 --> 20:16.380
可不可以这样子写

20:16.380 --> 20:18.380
可不可以这样子写

20:18.380 --> 20:19.380
可不可以

20:19.380 --> 20:20.380
当然可以

20:20.380 --> 20:21.380
当然可以

20:21.380 --> 20:22.380
怎么写都可以

20:22.380 --> 20:23.380
导入这个模块

20:23.380 --> 20:24.380
导入这个模块

20:24.380 --> 20:25.380
就是得到了什么

20:25.380 --> 20:26.380
得到的就是模块对象

20:26.380 --> 20:27.380
对吧

20:27.380 --> 20:28.380
是不是就是个模块对象

20:28.380 --> 20:29.380
对吧

20:29.380 --> 20:30.380
OK

20:30.380 --> 20:31.380
那么这里这样子写

20:31.380 --> 20:32.380
也没有任何问题

20:32.380 --> 20:33.380
看一下吧

20:33.380 --> 20:34.380
是不是没有任何问题

20:36.380 --> 20:37.380
OK

20:38.380 --> 20:40.380
关于这个common.js规范

20:40.380 --> 20:41.380
他里边说了那种

20:41.380 --> 20:42.380
那么这个规范

20:42.380 --> 20:43.380
放到load.js里边

20:43.380 --> 20:45.380
他要对这个规范进行实现

20:45.380 --> 20:46.380
我们来看一下

20:46.380 --> 20:47.380
load.js里边

20:47.380 --> 20:49.380
如何他是怎么来实现的

20:49.380 --> 20:50.380
大概介绍一下

20:50.380 --> 20:51.380
因为这些东西

20:51.380 --> 20:52.380
有可能面试的时候

20:52.380 --> 20:53.380
可能会问到

20:53.380 --> 20:55.380
我们一个个说

20:55.380 --> 20:57.380
第一个

20:57.380 --> 21:00.380
为了保证高效的执行

21:00.380 --> 21:03.380
并且仅加在必要的模块

21:03.380 --> 21:05.380
load.js

21:05.380 --> 21:07.380
就执行到require寒树的时候

21:07.380 --> 21:09.380
才会加载并执行模块

21:09.380 --> 21:10.380
什么意思呢

21:10.380 --> 21:11.380
这是啥意思呢

21:11.380 --> 21:13.380
看着啊

21:13.380 --> 21:14.380
比方说我把这东西

21:14.380 --> 21:16.380
全部注射了

21:16.380 --> 21:18.380
我这个工程里边写了

21:18.380 --> 21:19.380
是不是写了

21:19.380 --> 21:20.380
两个模块

21:20.380 --> 21:21.380
一个是index.js

21:21.380 --> 21:22.380
一个是utl.js

21:22.380 --> 21:23.380
对吧

21:23.380 --> 21:24.380
是不是有两个模块

21:24.380 --> 21:25.380
我们运行的时候

21:25.380 --> 21:27.380
运行的是谁

21:27.380 --> 21:28.380
看着啊

21:28.380 --> 21:29.380
我们运行的时候

21:29.380 --> 21:30.380
运行的是谁

21:30.380 --> 21:33.380
运行的是index.js

21:33.380 --> 21:34.380
那么你看一下

21:34.380 --> 21:36.380
index.js运行的过程中

21:36.380 --> 21:38.380
有没有用到require寒树

21:38.380 --> 21:40.380
下面都注射掉了

21:40.380 --> 21:41.380
没有

21:41.380 --> 21:42.380
没有的话

21:42.380 --> 21:43.380
这个模块执行吗

21:43.380 --> 21:44.380
这个模块完全不执行

21:44.380 --> 21:45.380
就跟他没有

21:45.380 --> 21:47.380
它是一样的

21:47.380 --> 21:48.380
啥都没有

21:48.380 --> 21:49.380
没输出吗

21:49.380 --> 21:51.380
这个模块是不是完全不执行

21:51.380 --> 21:52.380
没问题吧

21:52.380 --> 21:53.380
比方说我们的模块里边

21:53.380 --> 21:55.380
加一句话

21:55.380 --> 21:59.380
Utl模块执行了

21:59.380 --> 22:00.380
咱们来看一下

22:00.380 --> 22:01.380
这个模块有没有执行

22:01.380 --> 22:04.270
有没有执行

22:04.270 --> 22:05.270
肯定没有执行

22:05.270 --> 22:06.270
对吧

22:06.270 --> 22:07.270
因为我们运行的是

22:07.270 --> 22:08.270
index.js

22:08.270 --> 22:09.270
index.js并没有用到这个模块

22:09.270 --> 22:12.270
它并没有运行这个require

22:12.270 --> 22:13.270
用到这个模块

22:13.270 --> 22:14.270
所以它不会执行

22:14.270 --> 22:16.270
这个就是第1个点的意思

22:16.270 --> 22:17.270
那么反过来

22:17.270 --> 22:19.270
如果说你用到这个模块

22:19.270 --> 22:20.270
那么这个模块执行

22:20.270 --> 22:21.270
肯定执行

22:21.270 --> 22:23.270
你看Utl模块执行了

22:23.270 --> 22:24.270
那么说明这里

22:24.270 --> 22:25.270
是不是用到这个模块

22:25.270 --> 22:27.270
那么在运行这个require寒树的时候

22:27.270 --> 22:28.270
你可以认为

22:28.270 --> 22:29.270
它做到这么件事

22:29.270 --> 22:31.270
运行这个require寒树

22:31.270 --> 22:32.270
做了什么事呢

22:32.270 --> 22:33.270
它在内部

22:33.270 --> 22:35.270
去读取到你这里给的路径

22:35.270 --> 22:36.270
给的路径

22:36.270 --> 22:37.270
那么读取到这个js

22:37.270 --> 22:39.270
然后把这个js运行一遍

22:39.270 --> 22:40.270
运行一遍

22:40.270 --> 22:41.270
并且把这个js

22:41.270 --> 22:43.270
里边导出的那种

22:43.270 --> 22:44.270
形成一个对象

22:44.270 --> 22:45.270
然后把这个对象

22:45.270 --> 22:47.270
作为这个寒树的返回结果

22:47.270 --> 22:49.270
它就做了这么一件事

22:49.270 --> 22:50.270
再来一次

22:50.270 --> 22:51.270
那个街市做了什么事

22:51.270 --> 22:52.270
require寒树

22:52.270 --> 22:54.270
它首先找到这个路径

22:54.270 --> 22:55.270
这个路径存不存在

22:55.270 --> 22:56.270
如果说你写错了

22:56.270 --> 22:58.270
那肯定它爆出

22:58.270 --> 22:59.270
它说什么呢

22:59.270 --> 23:00.270
它这个模块找不到

23:00.270 --> 23:02.270
以后你们会经常

23:02.270 --> 23:03.270
发现这种错误

23:03.270 --> 23:06.270
它说什么

23:06.270 --> 23:07.270
模块

23:07.270 --> 23:08.270
不能找到模块

23:08.270 --> 23:09.270
这个东西找不到

23:09.270 --> 23:10.270
找不到

23:10.270 --> 23:12.270
如果它能找到的话

23:12.270 --> 23:13.270
它就把这个js里边的东西

23:13.270 --> 23:14.270
执行一遍

23:14.270 --> 23:16.270
然后把它导出的那种

23:16.270 --> 23:18.270
作为寒树的返回

23:18.270 --> 23:20.270
它就做了这么一件事

23:20.270 --> 23:21.270
所以说我们的模块

23:21.270 --> 23:22.270
要不要执行

23:22.270 --> 23:23.270
取决用

23:23.270 --> 23:24.270
要不要用它

23:24.270 --> 23:25.270
用它的时候才执行

23:25.270 --> 23:27.270
当然我这里只是演示的

23:27.270 --> 23:28.270
index的街市

23:28.270 --> 23:29.270
用这个模块

23:29.270 --> 23:30.270
就它用它

23:30.270 --> 23:32.270
那么它能不能用别的模块

23:32.270 --> 23:33.270
当然也可以

23:33.270 --> 23:34.270
你要用的时候就用require

23:34.270 --> 23:36.270
它就会把那个模块的东西

23:36.270 --> 23:37.270
导入

23:37.270 --> 23:38.270
就这么个回事

23:38.270 --> 23:40.270
然后还有一个细节

23:40.270 --> 23:41.270
大家注意一下

23:41.270 --> 23:43.270
我这里毕竟你不要忘说了

23:43.270 --> 23:44.270
毕竟你不要忘说了

23:44.270 --> 23:46.270
这个细节大家注意

23:47.270 --> 23:49.270
就是导入模块

23:50.270 --> 23:53.270
在low的介石中

23:53.270 --> 23:54.270
这个东西common介石

23:54.270 --> 23:55.270
并没有

23:55.270 --> 23:57.270
其实它对这一部分

23:57.270 --> 23:58.270
也有规范

23:58.270 --> 23:59.270
我们这里简单说一下

23:59.270 --> 24:00.270
因为这个东西

24:00.270 --> 24:02.270
涉及到后边NPM的内容

24:02.270 --> 24:03.270
那是另外一门客

24:03.270 --> 24:05.270
我们这里简单说一下

24:05.270 --> 24:07.270
目前在low的介石中

24:07.270 --> 24:09.270
导入模块

24:10.270 --> 24:13.270
使用相对路径

24:13.270 --> 24:15.270
你看这里是不是相对路径

24:15.270 --> 24:16.270
从当前的目录出发

24:16.270 --> 24:19.270
并且必须以

24:19.270 --> 24:21.270
点儿斜杠

24:21.270 --> 24:23.270
或点儿斜杠开头

24:23.270 --> 24:24.270
点儿斜杠什么

24:24.270 --> 24:25.270
反回上级目录

24:25.270 --> 24:26.270
比如说有些模块

24:26.270 --> 24:27.270
它不在这个目录下面

24:27.270 --> 24:28.270
在上级目录

24:28.270 --> 24:30.270
那么你可以用点儿斜杠开头

24:30.270 --> 24:31.270
必须要使用这种方式

24:31.270 --> 24:33.270
你能不能把这个点儿斜杠去掉

24:33.270 --> 24:35.270
如果说在浏览器环境里面

24:35.270 --> 24:36.270
无所谓

24:36.270 --> 24:37.270
浏览器对路径的要求

24:37.270 --> 24:39.270
你去掉点儿斜杠是可以承认的

24:39.270 --> 24:41.270
但是在common介石里面是不行的

24:41.270 --> 24:42.270
它不允许你去掉

24:42.270 --> 24:43.270
去掉有别的含义

24:43.270 --> 24:45.270
去掉过后是有别的含义的

24:45.270 --> 24:48.580
我们这里重新运行

24:48.580 --> 24:49.580
看一下

24:49.580 --> 24:51.580
如果我们去掉会发生什么事

24:51.580 --> 24:53.580
这里我们low的

24:53.580 --> 24:55.580
index有点介石

24:55.580 --> 24:56.580
它告诉你什么

24:56.580 --> 24:58.580
它说找不到这个模块

24:58.580 --> 24:59.580
找不到

24:59.580 --> 25:01.580
因此不能去掉

25:01.580 --> 25:03.580
去掉之后是什么含义

25:03.580 --> 25:04.580
它又有什么样的特点

25:04.580 --> 25:07.580
不去掉跟去掉有什么样的区别

25:07.580 --> 25:08.580
我们以后

25:08.580 --> 25:11.580
在NPM的课程里面再详细介绍

25:11.580 --> 25:13.580
我们这里不做详细介绍了

25:13.580 --> 25:14.580
我们只需要知道

25:14.580 --> 25:16.580
我们在common介石里面

25:16.580 --> 25:17.580
导入模块的时候

25:17.580 --> 25:19.580
一定要把点儿斜杠加上

25:19.580 --> 25:20.580
如果返回上级目录

25:20.580 --> 25:22.580
就是点儿斜杠

25:22.580 --> 25:24.580
这就是相对独信

25:24.580 --> 25:26.580
OK

25:26.580 --> 25:28.580
这是关于这个点

25:28.580 --> 25:29.580
第二点

25:29.580 --> 25:30.580
我们就是设计到一个

25:30.580 --> 25:32.580
common介石在low的介石里面

25:32.580 --> 25:33.580
它是怎么把实现的

25:33.580 --> 25:34.580
因为common介石

25:34.580 --> 25:36.580
它其实只是一个规范

25:36.580 --> 25:38.580
它就说你应该怎么样导出

25:38.580 --> 25:39.580
应该怎么样导入

25:39.580 --> 25:41.580
它没有做任何实现

25:41.580 --> 25:42.580
怎么实现的

25:42.580 --> 25:43.580
实在low的介石里面

25:43.580 --> 25:44.580
把它进行实现的

25:44.580 --> 25:46.580
你说用export导出

25:46.580 --> 25:48.580
我该怎么样才能实现这个功能呢

25:48.580 --> 25:50.580
你说要隐藏内部实现

25:50.580 --> 25:52.580
我怎么才能把它隐藏起来

25:52.580 --> 25:53.580
不污染全局边量呢

25:53.580 --> 25:55.580
它要去做一些处理

25:55.580 --> 25:56.580
它怎么处理的呢

25:56.580 --> 25:57.580
回来看一下

25:57.580 --> 26:00.580
它为了隐藏模块中的代码

26:00.580 --> 26:02.580
low的介石在执行模块的时候

26:02.580 --> 26:04.580
它不会直接执行

26:04.580 --> 26:06.580
它会把模块里面的所有代码

26:06.580 --> 26:08.580
放到一个函数里面执行

26:08.580 --> 26:10.580
目前你可以认为

26:10.580 --> 26:12.580
它是一个匿名函数

26:12.580 --> 26:14.580
因为你把它放到函数里面

26:14.580 --> 26:15.580
执行过后

26:15.580 --> 26:17.580
它是不会污染全局边量的

26:17.580 --> 26:19.580
它是不会污染全局边量的

26:19.580 --> 26:20.580
比方说像我们刚才

26:20.580 --> 26:22.580
UTO里面的代码

26:22.580 --> 26:23.580
这些代码

26:23.580 --> 26:24.580
你看这里是不是定义了

26:24.580 --> 26:25.580
全局边量

26:25.580 --> 26:27.580
但是当我们在导入它的时候

26:27.580 --> 26:29.580
导入这个模块的时候

26:29.580 --> 26:32.580
它不会把它当成全局边量来使用

26:32.580 --> 26:34.580
它不会把它当成全局代码

26:34.580 --> 26:35.580
它会怎么样呢

26:35.580 --> 26:37.580
它会把这些代码放到一个函数里面执行

26:37.580 --> 26:38.580
你可以认为它是匿名函数

26:38.580 --> 26:40.580
当然实际上不是

26:41.580 --> 26:42.580
具体的实现

26:42.580 --> 26:45.580
我们这门客来一步去设计

26:45.580 --> 26:46.580
我们就大概说一下

26:46.580 --> 26:47.580
那么这样子一来

26:47.580 --> 26:49.580
它是不是就不是全局边量了

26:49.580 --> 26:51.580
它就不会造成污染了

26:51.580 --> 26:53.580
它会把它当成一个全局

26:53.580 --> 26:56.580
把它掏到一个函数里面去执行

26:57.580 --> 26:58.580
所以说它为什么

26:58.580 --> 26:59.580
这些东西都可以隐藏起来

26:59.580 --> 27:01.580
都可以不被外面访问到

27:01.580 --> 27:04.580
就是因为它放到了一个函数内部

27:05.580 --> 27:07.580
这是它如何来隐藏的

27:07.580 --> 27:09.580
那么它如何来导出的呢

27:09.580 --> 27:11.580
它是做了这么一个处理

27:11.580 --> 27:13.580
在模块开始执行前

27:13.580 --> 27:15.580
它初识化了一个东西

27:15.580 --> 27:16.580
有一个码旧对象

27:16.580 --> 27:17.580
这个对象哪来的呢

27:17.580 --> 27:18.580
你不用管

27:18.580 --> 27:19.580
你不用管它哪来的

27:19.580 --> 27:20.580
它内部处理的

27:20.580 --> 27:21.580
那么这个对象里面

27:21.580 --> 27:23.580
有一个属性叫做Export

27:23.580 --> 27:26.580
它把它初识化为了一个空对象

27:27.580 --> 27:28.580
而这个东西

27:28.580 --> 27:31.580
它就是我们模块要导出的值

27:31.580 --> 27:33.580
你可以认为就是这个函数的繁绘值

27:34.580 --> 27:37.580
为了方便开发着编辑的导出

27:37.580 --> 27:38.580
弄的结实在初识化

27:38.580 --> 27:40.580
MAR9.export之后

27:40.580 --> 27:42.580
又声明了一个变量Export

27:42.580 --> 27:44.580
等于MAR9.export

27:44.580 --> 27:45.580
啥意思

27:45.580 --> 27:46.580
啥意思呢

27:46.580 --> 27:47.580
它是这个意思

27:48.580 --> 27:49.580
看下面带吧

27:49.580 --> 27:50.580
会来这里看吗

27:50.580 --> 27:55.240
我们来这里看

27:57.240 --> 27:59.240
我们把它用一个伪带码的形式

27:59.240 --> 28:01.240
当然这些写出来肯定是没用的

28:01.240 --> 28:02.240
我们就说一下

28:02.240 --> 28:05.680
它内部是怎么来处理的

28:05.680 --> 28:07.680
先做一个立即执行函数

28:07.680 --> 28:09.680
所以先做一个立即执行函数

28:09.680 --> 28:11.680
这个函数执行完了过后

28:11.680 --> 28:13.680
会得到一个东西

28:13.680 --> 28:14.680
我们先不着急

28:14.680 --> 28:16.680
那么这个立即执行函数里边

28:16.680 --> 28:17.680
它把这一带

28:17.680 --> 28:18.680
我们模块的一个带码

28:18.680 --> 28:19.680
全部放到函数里面执行

28:19.680 --> 28:20.680
所以保证隐藏了

28:20.680 --> 28:22.680
这东西是不是全部隐藏了

28:22.680 --> 28:23.680
然后这个函数里

28:23.680 --> 28:24.680
它有一个参数

28:24.680 --> 28:25.680
叫做MAR9

28:25.680 --> 28:26.680
有个参数

28:26.680 --> 28:27.680
这个参数哪来的

28:27.680 --> 28:28.680
你不用管

28:28.680 --> 28:29.680
它是内部给你注入的

28:29.680 --> 28:30.680
你不用管

28:30.680 --> 28:31.680
那么这个MAR9

28:31.680 --> 28:32.680
它是个对象

28:33.680 --> 28:34.680
你可以认为它就是个对象

28:34.680 --> 28:36.680
它里面有一个属性Export

28:36.680 --> 28:38.680
这个属性在最一开始的时候

28:38.680 --> 28:40.680
它把它初识化为一个对象

28:40.680 --> 28:42.680
然后它又写了一个

28:42.680 --> 28:45.680
又写定了一个变量Export

28:45.680 --> 28:48.680
它等于MAR9.export

28:50.680 --> 28:51.680
它做了这么一件事

28:51.680 --> 28:52.680
你看一下

28:52.680 --> 28:54.680
然后最后它返回的是什么呢

28:54.680 --> 28:56.680
你可以认为这个函数返回的

28:56.680 --> 28:58.680
就是MAR9.export

28:58.680 --> 29:00.680
当然它内部它不是这么实现的

29:00.680 --> 29:02.680
不过你现在目前这样子理解是最简单的

29:02.680 --> 29:04.680
而且是没有任何问题的

29:06.680 --> 29:07.680
看一下

29:07.680 --> 29:08.680
它其实意识就是这个意思

29:08.680 --> 29:10.680
只不过它具体的带码

29:10.680 --> 29:12.680
写法上的不是这样子写的

29:12.680 --> 29:14.680
那么咱们来看一下

29:14.680 --> 29:16.680
你看这是我们的模块带码

29:16.680 --> 29:18.680
这是我们自己写的带码

29:18.680 --> 29:19.680
它把我们带码放到哪呢

29:19.680 --> 29:20.680
放到一个函数里面了

29:20.680 --> 29:22.680
就保证这些东西是隐藏的

29:22.680 --> 29:24.680
我们在这里面定义的任何变量是隐藏的

29:24.680 --> 29:25.680
那导出怎么导出呢

29:25.680 --> 29:27.680
你看它最终返回的是什么

29:27.680 --> 29:29.680
是不是返回了这个东西

29:29.680 --> 29:31.680
所以说你要导出的东西

29:31.680 --> 29:33.680
就一定要往这个东西里面加

29:33.680 --> 29:35.680
是不是这个意思

29:35.680 --> 29:36.680
你要导出的东西

29:36.680 --> 29:38.680
是不是就一定要往这个东西里面加

29:38.680 --> 29:41.680
而且它为了让你方便的导出

29:41.680 --> 29:43.680
它又把这个东西复制给了这个变量

29:43.680 --> 29:45.680
那你是不是这个变量就是一个空队象

29:45.680 --> 29:47.680
这个变量是不是就是一个空队象

29:47.680 --> 29:49.680
那么你仔细往往这个变量里面加东西

29:49.680 --> 29:50.680
就完事了

29:50.680 --> 29:52.680
你看我往这个变量里面

29:52.680 --> 29:53.680
你看我们在这里

29:53.680 --> 29:54.680
为什么可以使用export

29:54.680 --> 29:55.680
因为它这个环境里面

29:55.680 --> 29:57.680
给你加了一个变量叫export

29:57.680 --> 29:59.680
为什么可以使用就是这个原因

29:59.680 --> 30:01.680
我们在export里面加了一些数据

30:01.680 --> 30:02.680
加了一些东西

30:02.680 --> 30:04.680
是不是就往这个对象里面加东西

30:04.680 --> 30:06.680
那么最终它返回了这个对象

30:06.680 --> 30:09.680
是不是就是我们要导出的那种

30:09.680 --> 30:10.680
没问题吧

30:10.680 --> 30:12.680
那么我们到时候在require的时候

30:12.680 --> 30:14.680
实际上它运行的是它

30:14.680 --> 30:15.680
运行的就是这个立即执行函数

30:15.680 --> 30:17.680
运行完了过后把它返回来结果

30:17.680 --> 30:19.680
作为这个函数的结果返回

30:19.680 --> 30:21.680
它就是做了这么一件事

30:21.680 --> 30:23.680
就做了这么一件事

30:23.680 --> 30:24.680
那么你知道这个远

30:24.680 --> 30:26.680
好好看一下一个代码

30:26.680 --> 30:28.680
你知道这个远离过后

30:28.680 --> 30:29.680
你会发现

30:29.680 --> 30:31.680
我们在load.js里面

30:31.680 --> 30:33.680
要实现common.js标准

30:33.680 --> 30:34.680
要做模块的导出

30:34.680 --> 30:36.680
其实有很多种方式

30:36.680 --> 30:37.680
第一种方式是什么呢

30:37.680 --> 30:39.680
是使用export的方式

30:39.680 --> 30:41.680
往它里面加属性导出

30:41.680 --> 30:43.680
往这里面加属性导出

30:43.680 --> 30:45.680
另一种方式是什么呢

30:45.680 --> 30:47.680
直接往margeau.export里面

30:47.680 --> 30:49.680
加属性导出

30:49.680 --> 30:50.680
行不行

30:50.680 --> 30:51.680
也可以

30:51.680 --> 30:54.440
好 咱们来试一下

30:54.440 --> 30:56.440
把属性导出

30:56.440 --> 30:58.440
好 你看着

30:58.440 --> 31:02.440
我们在这里使用margeau.export

31:02.440 --> 31:04.440
因为这两个东西是一个东西

31:04.440 --> 31:06.440
看没

31:06.440 --> 31:08.440
这样子可不可以

31:08.440 --> 31:09.440
对比一下上面

31:09.440 --> 31:11.440
这两个东西是一个东西

31:11.440 --> 31:12.440
是不是一个东西

31:12.440 --> 31:13.440
当然是一个东西

31:13.440 --> 31:15.440
我们在这里面加属性导出

31:15.440 --> 31:17.440
咱们来试一下

31:17.440 --> 31:20.440
好

31:20.440 --> 31:22.440
然后让我看一下

31:22.440 --> 31:29.440
在这里面我们使用load.index

31:29.440 --> 31:31.440
你看 是不是模块主型

31:31.440 --> 31:32.440
而且我们还可以用

31:32.440 --> 31:34.440
把下面加上

31:34.440 --> 31:36.440
abc

31:36.440 --> 31:39.440
完成abc

31:39.440 --> 31:42.440
abc

31:42.440 --> 31:44.440
看一下

31:44.440 --> 31:45.440
能不能用

31:45.440 --> 31:46.440
还是可以用

31:46.440 --> 31:47.440
是一样的 看到没

31:47.440 --> 31:48.440
所以这个东西

31:48.440 --> 31:49.440
你要理解它的原理

31:49.440 --> 31:50.440
它原理就是这样子

31:50.440 --> 31:51.440
你理解它的原理过后

31:51.440 --> 31:52.440
面试题

31:52.440 --> 31:53.440
面试题告诉你

31:53.440 --> 31:55.440
很容易在这个地方道理

31:55.440 --> 31:57.440
很容易在这个地方道理

31:57.440 --> 31:59.440
它就要考察你

31:59.440 --> 32:00.440
知不知道margeau.export

32:00.440 --> 32:01.440
和export的区别

32:01.440 --> 32:02.440
它就是

32:02.440 --> 32:03.440
其实没啥区别

32:03.440 --> 32:05.440
其实他们两个是一个东西

32:05.440 --> 32:07.440
只不过它最后返回的是什么

32:07.440 --> 32:09.440
返回的是margeau.export

32:09.440 --> 32:11.440
因为他们是指向的同一个对象

32:11.440 --> 32:12.440
所以说你改动它

32:12.440 --> 32:14.440
其实也就改动了它

32:14.440 --> 32:15.440
最终导出的是它

32:15.440 --> 32:16.440
对吧

32:16.440 --> 32:17.440
你用这种写法写

32:17.440 --> 32:18.440
是不是也没问题

32:18.440 --> 32:19.440
也没问题

32:19.440 --> 32:21.440
好 那么我们再来看

32:21.440 --> 32:23.440
那我能不能用这种写法写

32:23.440 --> 32:27.780
我能不能用这种写法写呢

32:27.780 --> 32:31.780
margeau.export

32:31.780 --> 32:32.780
能不能用这种写法呢

32:32.780 --> 32:33.780
我直接把它复制为一个对象

32:33.780 --> 32:35.780
直接给它复制

32:35.780 --> 32:37.780
你看一开始不是给它复制为空对象吗

32:37.780 --> 32:38.780
我重新给它复制

32:38.780 --> 32:40.780
我在我的模块代码里边

32:40.780 --> 32:42.780
重新给它重新复制

32:42.780 --> 32:43.780
可不可以呢

32:43.780 --> 32:44.780
当然也可以

32:44.780 --> 32:45.780
你看一看

32:45.780 --> 32:47.780
咱们又给它写上一个get number

32:48.780 --> 32:49.780
get number

32:49.780 --> 32:50.780
分析

32:51.780 --> 32:52.780
一样的

32:53.780 --> 32:57.050
这是一个函数

32:59.050 --> 33:01.050
然后abc

33:01.050 --> 33:02.050
12

33:02.050 --> 33:03.050
abc

33:03.050 --> 33:04.050
123

33:04.050 --> 33:05.050
这样子写可不可以呢

33:05.050 --> 33:06.050
一样的

33:06.050 --> 33:07.050
也可以

33:07.050 --> 33:08.050
也可以

33:08.050 --> 33:11.050
比方说咱们运行

33:11.050 --> 33:12.050
运行

33:12.050 --> 33:13.050
你看

33:13.050 --> 33:14.050
是不是一样的

33:14.050 --> 33:15.050
对吧

33:15.050 --> 33:16.050
一样的

33:16.050 --> 33:17.050
但是呢

33:17.050 --> 33:18.050
这种写法呢

33:18.050 --> 33:19.050
你会发现

33:19.050 --> 33:20.050
这种写法呢

33:20.050 --> 33:21.050
会产生一点点影响

33:21.050 --> 33:22.050
怎么影响呢

33:22.050 --> 33:24.050
因为你给它重新复制了

33:24.050 --> 33:26.050
它是不是指向新的对象了

33:26.050 --> 33:28.050
是不是指向新的对象了

33:28.050 --> 33:29.050
没问题吧

33:29.050 --> 33:30.050
是不是指向新的对象了

33:30.050 --> 33:31.050
那么现在呢

33:31.050 --> 33:33.050
这个margeau.export

33:33.050 --> 33:34.050
跟这个export

33:34.050 --> 33:35.050
是不是指向同一个对象

33:35.050 --> 33:36.050
你在这里

33:36.050 --> 33:37.050
在这一部分

33:37.050 --> 33:39.050
给它重新复制了

33:39.050 --> 33:41.050
在模块里面给它重新复制了

33:41.050 --> 33:42.050
那么我们的模块大脑

33:42.050 --> 33:43.050
全部在中间

33:43.050 --> 33:44.050
全部在中间

33:44.050 --> 33:46.050
那么你给它重新复制呢

33:46.050 --> 33:47.050
那么现在的export

33:47.050 --> 33:48.050
跟它是不是

33:48.050 --> 33:50.050
就不再指向一个对象了

33:50.050 --> 33:51.050
咱们来验证这个点

33:51.050 --> 33:53.050
我们在导出之前

33:53.050 --> 33:54.050
我们在这个export

33:54.050 --> 33:56.050
给它复制之前

33:56.050 --> 33:57.050
我们先输出一次

33:57.050 --> 33:58.050
先输出什么呢

33:58.050 --> 34:01.050
先输出一下margeau.export

34:01.050 --> 34:03.050
是不是等于export

34:04.050 --> 34:05.050
这两个东西是不是相等

34:05.050 --> 34:07.050
然后在运行的这句话之后

34:07.050 --> 34:08.050
再输出一下

34:08.050 --> 34:09.050
是不是相等

34:09.050 --> 34:10.050
我们来看一下

34:10.050 --> 34:11.050
我们来看一下

34:11.050 --> 34:13.050
因为我们要运行这个模块

34:13.050 --> 34:14.050
这个模块大脑都会运行的

34:14.050 --> 34:16.050
运行

34:16.050 --> 34:17.050
你看

34:17.050 --> 34:18.050
第一个是true

34:18.050 --> 34:19.050
第二个是不是变成forged

34:19.050 --> 34:20.050
对吧

34:20.050 --> 34:21.050
你看

34:21.050 --> 34:22.050
如果你知道的原理过后

34:22.050 --> 34:23.050
它怎么绕理

34:23.050 --> 34:24.050
它都绕不到

34:24.050 --> 34:25.050
都绕不到理

34:25.050 --> 34:26.050
因为现在的

34:26.050 --> 34:27.050
你看

34:27.050 --> 34:28.050
现在的export

34:28.050 --> 34:29.050
是不是还是一个空对象

34:29.050 --> 34:30.050
但是这个东西

34:30.050 --> 34:31.050
是不是已经重新复制为

34:31.050 --> 34:32.050
一个新的对象

34:32.050 --> 34:33.050
已经有那种了

34:33.050 --> 34:34.050
最终导出的是啥

34:34.050 --> 34:35.050
导出的是它

34:35.050 --> 34:36.050
你们

34:36.050 --> 34:37.050
这意思

34:37.050 --> 34:38.050
好

34:38.050 --> 34:39.050
那么比方说

34:39.050 --> 34:40.050
再来

34:40.050 --> 34:41.050
再来

34:41.050 --> 34:42.050
那如果说

34:42.050 --> 34:43.050
我在这后边

34:43.050 --> 34:44.050
再写上一个export

34:44.050 --> 34:45.050
第二

34:45.050 --> 34:47.050
bcd

34:47.050 --> 34:49.050
等于456

34:49.050 --> 34:51.050
那么我们请问

34:51.050 --> 34:52.050
请问大家一个问题

34:52.050 --> 34:53.050
把这个去掉

34:53.050 --> 34:54.050
去掉

34:54.050 --> 34:56.620
这个去掉

34:58.620 --> 34:59.620
把这个

34:59.620 --> 35:00.620
该上的就删了

35:00.620 --> 35:03.500
该上删掉

35:05.500 --> 35:07.500
那么请问大家一个问题

35:07.500 --> 35:09.500
我这边导入模块的时候

35:09.500 --> 35:10.500
当然我们平时写的

35:10.500 --> 35:11.500
谁会这样子写的

35:11.500 --> 35:12.500
不是在绕自己吗

35:12.500 --> 35:14.500
没必要这样子写

35:14.500 --> 35:15.500
我就问一下

35:15.500 --> 35:16.500
大家这个问题

35:17.500 --> 35:18.500
就说我这里

35:18.500 --> 35:20.500
在导入的时候

35:20.500 --> 35:22.500
我这里导入之后

35:22.500 --> 35:24.500
我们输出abc点

35:24.500 --> 35:26.500
或者这叫做ut

35:26.500 --> 35:28.500
比方说输出输入

35:30.500 --> 35:32.500
输出ut有点

35:32.500 --> 35:34.500
bcd

35:34.500 --> 35:35.500
来看一下

35:35.500 --> 35:37.500
我们输出的是ut有点bcd

35:37.500 --> 35:38.500
输出多少

35:40.500 --> 35:41.500
输出多少

35:42.500 --> 35:43.500
好

35:43.500 --> 35:44.500
咱们来看一下

35:44.500 --> 35:48.200
输出undefend

35:48.200 --> 35:50.200
为什么输出undefend

35:50.200 --> 35:52.200
再看一下它的原理

35:52.200 --> 35:54.200
它最终返回的是什么

35:54.200 --> 35:56.200
返回的是margeau.export

35:56.200 --> 35:58.200
当你如果说那在这一部分代码里边

35:58.200 --> 36:00.200
对它进行重新复制了

36:00.200 --> 36:02.200
那么就意味着 margeau.export

36:02.200 --> 36:03.200
跟这个export

36:03.200 --> 36:04.200
已经没有任何关系了

36:04.200 --> 36:06.200
所以没有任何关系了

36:06.200 --> 36:08.200
那么这个时候

36:08.200 --> 36:10.200
你在export里面做的任何东西

36:10.200 --> 36:11.200
都无效了

36:11.200 --> 36:12.200
都没有任何意义了

36:12.200 --> 36:14.200
你还在意是吧

36:14.200 --> 36:15.200
所以说

36:15.200 --> 36:16.200
这一块

36:16.200 --> 36:18.200
大家要注意一下

36:18.200 --> 36:19.200
它的实现原理

36:19.200 --> 36:20.200
其实没机航代码

36:20.200 --> 36:21.200
你看一下就明白了

36:21.200 --> 36:22.200
它最终返回的是它

36:22.200 --> 36:23.200
只不过

36:23.200 --> 36:24.200
它在前面做了一个处理

36:24.200 --> 36:25.200
定义了一个辩量export

36:25.200 --> 36:27.200
等于它而已

36:27.200 --> 36:28.200
那么我们平时

36:28.200 --> 36:30.200
用这个模块的话导出

36:30.200 --> 36:31.200
一般用啥呢

36:31.200 --> 36:32.200
看个人习惯

36:32.200 --> 36:35.200
我比较习惯于用这种方式

36:35.200 --> 36:37.200
我比较喜欢用这种方式

36:37.200 --> 36:38.200
就是我给它重新复制

36:38.200 --> 36:40.200
我要复制啥都可以

36:40.200 --> 36:41.200
比方说我要复制

36:41.200 --> 36:43.200
哪怕我要导出一个支付串都可以

36:43.200 --> 36:45.200
我要导出一个支付串都可以

36:45.200 --> 36:46.200
那么这样子

36:46.200 --> 36:47.200
我们来看一下

36:47.200 --> 36:49.200
输出这个邮件

36:49.200 --> 36:51.200
这一点是一个export做不到的

36:51.200 --> 36:52.200
它做不到的

36:52.200 --> 36:54.200
它只能在里面复制

36:54.200 --> 36:56.640
你看

36:56.640 --> 36:57.640
是不是导入这个模块

36:57.640 --> 36:58.640
这个模块本身就是个支付串

36:58.640 --> 36:59.640
它导出的就一个支付串

36:59.640 --> 37:01.640
它就不是一个对象

37:01.640 --> 37:04.640
这种方式更加灵活

37:04.640 --> 37:05.640
功能更加强大

37:05.640 --> 37:07.640
我比较喜欢于这种方式

37:08.640 --> 37:10.640
有些人可能喜欢

37:11.640 --> 37:12.640
喜欢用这种方式

37:12.640 --> 37:14.640
但这种方式有很多注意事项

37:14.640 --> 37:15.640
第一个注意事项

37:15.640 --> 37:16.640
你不能给它重新复制

37:16.640 --> 37:18.640
你是不能给它重新复制的

37:18.640 --> 37:20.640
把export复制为456

37:20.640 --> 37:21.640
可以吗

37:21.640 --> 37:22.640
来我们看一下

37:22.640 --> 37:24.640
我就写这么一句话

37:24.640 --> 37:26.640
把export复制为456

37:26.640 --> 37:27.640
可不可以

37:27.640 --> 37:30.980
咱们试一下

37:30.980 --> 37:31.980
得到什么

37:31.980 --> 37:32.980
得到是不是还是对象

37:32.980 --> 37:34.980
它不是456

37:34.980 --> 37:35.980
还是对象

37:35.980 --> 37:36.980
为什么呢

37:36.980 --> 37:37.980
看那个带

37:37.980 --> 37:38.980
返回的是

37:38.980 --> 37:39.980
返回的是margeau.export

37:39.980 --> 37:41.980
你把它重新复制的有用吗

37:41.980 --> 37:43.980
把它重新复制的有用吗

37:43.980 --> 37:44.980
没用

37:44.980 --> 37:45.980
所以说

37:45.980 --> 37:47.980
我们如果利用这种方式的话

37:47.980 --> 37:48.980
千万注意

37:48.980 --> 37:49.980
不要给它重新复制

37:49.980 --> 37:50.980
没有任何意义

37:50.980 --> 37:51.980
因为最终导述的不并不是它

37:51.980 --> 37:52.980
并不是它

37:52.980 --> 37:53.980
所以说

37:53.980 --> 37:55.980
我平时喜欢用这种方式

37:55.980 --> 37:58.980
margeau.export

37:58.980 --> 37:59.980
用这种方式来导出

37:59.980 --> 38:01.980
而且是直接给它重新复制

38:01.980 --> 38:03.980
而且这种写法

38:03.980 --> 38:05.980
我一般只写一次

38:05.980 --> 38:07.980
为什么只写一次呢

38:07.980 --> 38:09.980
一些都是没意义

38:09.980 --> 38:11.980
因为我都给它重新复制的

38:11.980 --> 38:12.980
我在最后

38:12.980 --> 38:13.980
我的模块写完了之后

38:13.980 --> 38:14.980
我最后

38:14.980 --> 38:16.980
我把我需要导出的东西

38:16.980 --> 38:17.980
就全部写到这儿

38:17.980 --> 38:18.980
需要导出哪些东西

38:18.980 --> 38:19.980
哪些东西就全部写到这儿

38:19.980 --> 38:20.980
当然有的时候

38:20.980 --> 38:21.980
如果导出

38:21.980 --> 38:22.980
只是一个

38:22.980 --> 38:23.980
如果只导出一个函数的话

38:23.980 --> 38:25.980
我甚至可以这样子写

38:25.980 --> 38:26.980
导出某一个函数

38:26.980 --> 38:27.980
某一个函数

38:27.980 --> 38:28.980
我甚至可以这样子写

38:28.980 --> 38:29.980
那么这边

38:29.980 --> 38:30.980
得到的结果

38:30.980 --> 38:31.980
是不是就是个函数了

38:31.980 --> 38:32.980
这边导出啥

38:32.980 --> 38:33.980
就是啥

38:33.980 --> 38:35.980
因为你给它复制的话

38:35.980 --> 38:37.980
给它复制为啥

38:37.980 --> 38:38.980
那么这边就导入啥

38:38.980 --> 38:39.980
是不是更加好理解

38:39.980 --> 38:41.980
更加好理解一点

38:41.980 --> 38:42.980
看个人的习惯

38:42.980 --> 38:45.980
总之你理解原理就行了

38:45.980 --> 38:47.980
这是关于这一块

38:47.980 --> 38:49.980
最后一个点

38:49.980 --> 38:52.980
为了避免反复

38:52.980 --> 38:54.980
夹载一个模块

38:54.980 --> 38:56.980
load.js开启的模块缓存

38:56.980 --> 38:57.980
model是开启的

38:57.980 --> 38:58.980
能不能关闭

38:58.980 --> 38:59.980
能关闭

38:59.980 --> 39:00.980
只不过了

39:00.980 --> 39:01.980
我现在不想告诉大家

39:01.980 --> 39:02.980
怎么关闭

39:03.980 --> 39:05.980
如果夹载的模块

39:05.980 --> 39:06.980
已经被夹载过了

39:06.980 --> 39:09.980
会自动使用之前的导出结果

39:09.980 --> 39:10.980
这是怎么意思呢

39:10.980 --> 39:11.980
你看

39:12.980 --> 39:13.980
我这里能比方说

39:13.980 --> 39:15.980
导出一个对象

39:15.980 --> 39:20.120
在这上面写上

39:20.120 --> 39:21.120
输出这么一句话

39:23.120 --> 39:25.120
模块执行了

39:27.120 --> 39:28.120
UTO

39:28.120 --> 39:29.120
模块执行了

39:29.120 --> 39:30.120
说这么一句话

39:30.120 --> 39:31.120
导出一个对象

39:31.120 --> 39:33.120
对象里面有个啥呢

39:33.120 --> 39:34.120
有一个

39:35.120 --> 39:36.120
我一二三

39:36.120 --> 39:37.120
随便写

39:37.120 --> 39:39.120
就导出这么一个模块

39:40.120 --> 39:42.120
然后在这边导入

39:42.120 --> 39:43.120
在这边导入

39:43.120 --> 39:44.120
我们刚才已经演示过了

39:44.120 --> 39:45.120
这边导入

39:45.120 --> 39:46.120
能不能导入多次

39:46.120 --> 39:47.120
当然可以随便导出去

39:47.120 --> 39:48.120
无所谓

39:48.120 --> 39:49.120
不要导入一

39:49.120 --> 39:51.120
导入第二次

39:51.120 --> 39:53.120
甚至有可能在这个模块

39:53.120 --> 39:54.120
又要用到别的模块

39:54.120 --> 39:56.120
别的模块又要用到这个模块

39:56.120 --> 39:57.120
都有可能

39:57.120 --> 39:59.120
这个UTO模块

39:59.120 --> 40:01.120
可能会被多次使用

40:02.120 --> 40:03.120
有可能会被多次使用

40:03.120 --> 40:05.120
比如说这个index里面

40:05.120 --> 40:06.120
拿一个吧

40:06.120 --> 40:07.120
b.js

40:07.120 --> 40:08.120
b.js里面

40:08.120 --> 40:09.120
他又用

40:09.120 --> 40:10.120
有自己的东西

40:10.120 --> 40:11.120
他有自己的东西

40:11.120 --> 40:12.120
同时

40:12.120 --> 40:14.120
他要用到这个UTO模块

40:14.120 --> 40:15.120
比如说b.js里面

40:17.120 --> 40:18.120
也有一个UTO

40:18.120 --> 40:19.120
require

40:21.120 --> 40:22.120
叫斜杠UTO

40:23.120 --> 40:24.120
也有一个UTO

40:24.120 --> 40:25.120
然后我们这里

40:28.120 --> 40:31.120
输出了U.abc

40:31.120 --> 40:32.120
U.abc

40:33.120 --> 40:34.120
是不是有两个模块

40:34.120 --> 40:35.120
b.js

40:35.120 --> 40:36.120
UTO.js

40:36.120 --> 40:38.120
要用到UTO

40:38.120 --> 40:39.120
b依赖UTO

40:39.120 --> 40:40.120
那么这种方式

40:40.120 --> 40:42.120
是不是可以清晰的看到依赖关系

40:42.120 --> 40:43.120
我这里面要用到这个东西

40:43.120 --> 40:44.120
自然就导入了

40:45.120 --> 40:46.120
那么这里

40:46.120 --> 40:47.120
index里面

40:47.120 --> 40:48.120
我们要导入UTO

40:48.120 --> 40:49.120
导入了两次

40:49.120 --> 40:50.120
同时

40:50.120 --> 40:52.120
又导入了b这个模块

40:52.120 --> 40:53.120
b这个模块

40:53.120 --> 40:54.120
是不是没有导出

40:55.120 --> 40:56.120
看一下

40:56.120 --> 40:57.120
b这个模块

40:57.120 --> 40:58.120
是不是没有导出

40:58.120 --> 41:00.120
没有导出的时候

41:00.120 --> 41:01.120
它导出了什么

41:01.120 --> 41:02.120
导出的就是个空对相

41:02.120 --> 41:03.120
你看这个代码

41:03.120 --> 41:04.120
一看就看明白了

41:04.120 --> 41:06.120
没有导出导出的就是个空对相

41:06.120 --> 41:07.120
当然那你就

41:07.120 --> 41:08.120
没有导出的话

41:08.120 --> 41:10.120
你就不用去

41:10.120 --> 41:11.120
接受它了

41:11.120 --> 41:12.120
空对相有什么好解决的

41:12.120 --> 41:14.120
我们就直接导入就行了

41:15.120 --> 41:16.120
b

41:16.120 --> 41:17.120
b里面

41:17.120 --> 41:18.120
输出一下

41:18.120 --> 41:21.520
输出一下

41:21.520 --> 41:22.520
b模块

41:23.520 --> 41:24.520
执行了

41:24.520 --> 41:25.520
b模块执行了

41:26.520 --> 41:27.520
咱们来index里面看一下

41:27.520 --> 41:29.520
那么现在就形成这么一个关系

41:30.520 --> 41:31.520
看一下

41:31.520 --> 41:32.520
现在形成什么关系呢

41:32.520 --> 41:34.520
index是谁要依赖谁

41:34.520 --> 41:36.520
是不是依赖b.js

41:36.520 --> 41:38.520
依赖还依赖UTO.js

41:38.520 --> 41:39.520
他们都要用到这两个模块

41:39.520 --> 41:40.520
B里面要依赖谁

41:40.520 --> 41:42.520
又要依赖UTO.js

41:42.520 --> 41:44.520
什么形成这么一个依赖关系

41:44.520 --> 41:46.520
你看一下

41:46.520 --> 41:47.520
在运行的过程中

41:47.520 --> 41:48.520
那么这个UTO.js

41:48.520 --> 41:50.520
是不是会被运行多次呢

41:50.520 --> 41:52.520
看上去好像是的

41:52.520 --> 41:54.520
看上去好像会被运行多次

41:54.520 --> 41:56.520
实际上我们来运行一下看一下

41:57.520 --> 41:58.520
index

42:00.520 --> 42:01.520
你看

42:01.520 --> 42:02.520
两个模块

42:02.520 --> 42:04.520
是不是每个模块只执行了一次

42:04.520 --> 42:05.520
对吧

42:05.520 --> 42:06.520
只执行了一次

42:06.520 --> 42:07.520
那是怎么回事呢

42:07.520 --> 42:08.520
那就是我们这里说的

42:08.520 --> 42:10.520
他为了提高执行效率

42:10.520 --> 42:11.520
他会进行缓存

42:11.520 --> 42:13.520
因为他每一次看到这个模块

42:13.520 --> 42:15.520
他是不是都要去找文件

42:15.520 --> 42:16.520
而找文件

42:16.520 --> 42:19.520
读文件的过程是比较耗时的

42:19.520 --> 42:21.520
因为文件是在磁盘里边

42:21.520 --> 42:22.520
它不在内存里边

42:22.520 --> 42:24.520
你要在磁盘里边把它读出来

42:24.520 --> 42:25.520
是比较耗时的

42:26.520 --> 42:28.520
因此他为了提高效率

42:28.520 --> 42:30.520
他不会在每一次加载模块的时候

42:30.520 --> 42:31.520
都去找一次文件

42:31.520 --> 42:32.520
都去把这个文件运行一次

42:32.520 --> 42:33.520
他不会

42:33.520 --> 42:35.520
他只有在第一次

42:35.520 --> 42:36.520
比较到这里

42:36.520 --> 42:37.520
运行index

42:37.520 --> 42:38.520
对吧

42:38.520 --> 42:39.520
运行index

42:39.520 --> 42:41.520
他看到index要用这个模块

42:41.520 --> 42:43.520
这个模块缓存里面有没有呢

42:43.520 --> 42:44.520
好像没有

42:44.520 --> 42:45.520
没有的话我干嘛

42:45.520 --> 42:46.520
只能去找这个文件了

42:46.520 --> 42:47.520
找这个文件

42:47.520 --> 42:48.520
把文件找出来

42:48.520 --> 42:49.520
然后把它封装到一个

42:49.520 --> 42:50.520
函数环境里边

42:50.520 --> 42:51.520
运行完了过后

42:51.520 --> 42:53.520
把这个东西返回

42:53.520 --> 42:54.520
返回对象了

42:54.520 --> 42:56.520
同时他马上就把对象

42:56.520 --> 42:57.520
缓存起来

42:57.520 --> 42:59.520
就把这个东西缓存起来

42:59.520 --> 43:00.520
缓存起来

43:00.520 --> 43:01.520
然后呢

43:01.520 --> 43:03.520
你第二次再去找这个模块的时候

43:03.520 --> 43:04.520
他发现已经有缓存了

43:04.520 --> 43:06.520
他就把之前的缓存对象

43:06.520 --> 43:08.520
就把之前这个玩意儿

43:08.520 --> 43:09.520
直接给你

43:09.520 --> 43:10.520
就直接给你

43:10.520 --> 43:11.520
没啥意思嘛

43:11.520 --> 43:13.520
所以说如果说你在这里输出

43:13.520 --> 43:15.520
UTO1

43:15.520 --> 43:17.520
是不是等于UTO2呢

43:17.520 --> 43:18.520
又要输出

43:18.520 --> 43:20.520
你会发现两个对象是一样的

43:20.520 --> 43:21.520
是Q

43:21.520 --> 43:22.520
因为它有缓存

43:22.520 --> 43:23.520
是Q

43:24.520 --> 43:26.520
然后又去夹载B这个模块

43:26.520 --> 43:27.520
B这个模块

43:27.520 --> 43:28.520
它有没有缓存

43:28.520 --> 43:29.520
B这个模块没缓存

43:29.520 --> 43:31.520
它就进入B来执行

43:31.520 --> 43:33.520
因此输出了B执行了

43:33.520 --> 43:35.520
然后B里边又要用到UTO

43:35.520 --> 43:37.520
发现UTO有缓存

43:37.520 --> 43:39.520
它就会把缓存的结果直接返回

43:39.520 --> 43:41.520
这样的提高执行效率

43:41.520 --> 43:42.520
没啥意思吧

43:42.520 --> 43:43.520
OK

43:43.520 --> 43:45.520
缓存它不会当成什么问题的

43:45.520 --> 43:46.520
大家放心使用就行了

43:46.520 --> 43:47.520
只是给大家说一下

43:47.520 --> 43:49.520
它有缓存的现象

43:49.520 --> 43:50.520
因此你在模块里边

43:50.520 --> 43:52.520
比方说你做一些权娟的输出

43:52.520 --> 43:54.520
你不能认为这个输出

43:54.520 --> 43:56.520
它会每一次用这个模块

43:56.520 --> 43:57.520
它就会执行一次

43:57.520 --> 43:58.520
不会的

43:58.520 --> 43:59.520
它只会执行一次

43:59.520 --> 44:01.520
因此模块里边的权娟代码

44:01.520 --> 44:03.520
像这些权娟代码

44:03.520 --> 44:05.520
你可以认为它只执行一次

44:05.520 --> 44:06.520
因为它有缓存

44:07.520 --> 44:08.520
好吧

44:08.520 --> 44:10.520
这是关于这一块

44:10.520 --> 44:11.520
当然在这下面

44:11.520 --> 44:13.520
如果说你输出多次

44:14.520 --> 44:16.520
你输出多次这个B

44:16.520 --> 44:18.520
还是一样的

44:18.520 --> 44:20.520
是不是只执行了一次

44:20.520 --> 44:21.520
OK

44:21.520 --> 44:23.520
这是关于模块

44:23.520 --> 44:25.520
漏的阶视你的模块

44:25.520 --> 44:26.520
是不是非常简单

44:26.520 --> 44:27.520
导出

44:27.520 --> 44:28.520
以后你就可以分文件写了

44:28.520 --> 44:30.520
不同的文件写一分不分功能

44:30.520 --> 44:32.520
而且大家放心大难的写

44:32.520 --> 44:33.520
它不会污染权娟变量的

44:33.520 --> 44:35.520
哪怕你用关键字WAR

44:35.520 --> 44:36.520
它都不会污染权娟变量

44:36.520 --> 44:38.520
因为它是在喊出内部执行的

44:38.520 --> 44:39.520
你要导出

44:39.520 --> 44:41.520
就给这个Marge

44:41.520 --> 44:43.520
就给这个Marge Exports复制

44:43.520 --> 44:45.520
或者是用别的复制方式

44:45.520 --> 44:46.520
都可以

44:46.520 --> 44:47.520
我们之前都讲过了

44:47.520 --> 44:48.520
两种方式都可以

44:48.520 --> 44:50.520
只要把这个东西理解清楚就行了

44:50.520 --> 44:52.520
就是关于

44:52.520 --> 44:54.520
拷门件式模块化

44:54.520 --> 44:56.520
那么下一个我们还是用模块化

44:56.520 --> 44:57.520
做一些练习

44:57.520 --> 44:58.520
来鞏固一下

