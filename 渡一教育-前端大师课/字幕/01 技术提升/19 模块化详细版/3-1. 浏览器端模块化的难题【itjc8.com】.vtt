WEBVTT

00:00.880 --> 00:03.880
上一章咱们讲了CommonJets

00:04.880 --> 00:08.880
这一章咱们讲另外两个模块化的规范

00:08.880 --> 00:11.880
一个是AMD 一个是CMD

00:11.880 --> 00:15.880
其实这两个东西他们本身已经没有那么重要了

00:15.880 --> 00:21.880
因为现在自从ES6的模块化规范出来之后

00:21.880 --> 00:24.880
AMD和CMD这种两种规范不太使用了

00:24.880 --> 00:26.880
基本上没有人用了

00:26.880 --> 00:31.880
那么这一章呢 终点在哪呢 终点在这结合

00:31.880 --> 00:35.880
这结合我们不会具体的讲AMD和CMD规范

00:35.880 --> 00:39.880
而讲的是AMD和CMD这两种规范

00:39.880 --> 00:43.880
它为什么会出现 讲的是它的历史原因

00:43.880 --> 00:46.880
它为什么我们有了CommonJets规范之后

00:46.880 --> 00:49.880
不把它直接就放到浏览器端 为什么又放不了

00:49.880 --> 00:51.880
那么又到了什么问题

00:51.880 --> 00:54.880
那么为什么需要AMD和CMD出来解决这个问题

00:54.880 --> 00:57.880
你只有了解了这一点之后

00:57.880 --> 01:00.880
你再学习 之后我们再学习ES6模块化的时候

01:00.880 --> 01:04.880
你才能理解 为什么CommonJets是多好的一个东西

01:04.880 --> 01:07.880
为什么到了浏览器端就要换一个规范

01:07.880 --> 01:10.880
你才能理解 好 所以我们终点在这结合

01:10.880 --> 01:13.880
其实这结合讲完了之后 后边这几节课

01:13.880 --> 01:15.880
我们会具体的讲AMD和CMD

01:15.880 --> 01:18.880
后边的这几节课 重要程度就没有那么高了

01:18.880 --> 01:22.880
大家听一听了解一下 有这么一段历史也就差不多了

01:23.880 --> 01:25.880
那么我们输回到这结课

01:25.880 --> 01:29.880
这结课们讲啥呢 讲的就是浏览器端

01:29.880 --> 01:32.880
为什么实现模块化会比较困难

01:32.880 --> 01:34.880
还遇到了什么样的难题

01:34.880 --> 01:38.880
因为我们上一节课 上一张我们讲到了CommonJets

01:38.880 --> 01:41.880
CommonJets和模块化规范在node那一端

01:41.880 --> 01:44.880
已经实现得非常非常舒服了 实现得非常理想了

01:44.880 --> 01:47.880
而且大家也可以看到 有了模块化规范之后

01:47.880 --> 01:50.880
我们写代码了 可以把代码的拆分成各个模块

01:50.880 --> 01:53.880
拆分得很细 也边于我们的附用

01:53.880 --> 01:56.880
为我们编写一些大型的应用 电竞的基础

01:56.880 --> 01:59.880
那么在node结课端 它们成功了

01:59.880 --> 02:02.880
成功了之后 那么就肯定有开发在想

02:02.880 --> 02:05.880
这么好的东西 为什么我不把它搬到浏览器这一端呢

02:05.880 --> 02:09.880
我们以前在浏览器端写代码 都还是利用脚本

02:09.880 --> 02:13.880
这样子一个一个去执行 对吧 引用到页面里边

02:13.880 --> 02:15.880
那么我们能不能像node那样子

02:15.880 --> 02:18.880
页面上就引用一个入口文件

02:18.880 --> 02:21.880
那个入口文件呢 去用模块化的方式

02:21.880 --> 02:24.880
去导入其他文件 就形成这么一个过程了

02:24.880 --> 02:27.880
我再来看一个PBT吧 我再随便画一下

02:27.880 --> 02:31.880
之前我们是这样子 对吧

02:31.880 --> 02:35.880
我们去运行页面 页面去夹载GS

02:35.880 --> 02:38.880
去夹载GS 那么现在GS我们只夹载一个

02:38.880 --> 02:40.880
我能不能像node那样子做

02:40.880 --> 02:43.880
页面上我就会夹载一个 把它称之为入口文件

02:43.880 --> 02:47.880
让这个入口文件 比如我们这里写上一个index.gs

02:47.880 --> 02:49.880
页面上只夹载一个入口文件

02:49.880 --> 02:51.880
那么让这个入口文件用模块化

02:51.880 --> 02:56.880
像commonGS那样 用require去导入其他的模块

02:56.880 --> 02:59.880
能不能这样子干呢 想得挺好

02:59.880 --> 03:01.880
但是会遇到一些问题

03:01.880 --> 03:04.880
那么我们这里可能看一下遇到了什么样的问题

03:04.880 --> 03:06.880
好 我们看一下

03:06.880 --> 03:11.880
你要理解在浏览器端使用commonGS的模块化的方式

03:11.880 --> 03:14.880
遇到了问题 你要能理解它的话

03:14.880 --> 03:16.880
你就必须要理解commonGS

03:16.880 --> 03:20.880
它在node端会是怎么样工作的

03:20.880 --> 03:21.880
好 咱们来看一下

03:21.880 --> 03:23.880
我们在nodeGS里面

03:23.880 --> 03:25.880
我们导入一个模块用的是什么

03:25.880 --> 03:26.880
是不是用了require

03:26.880 --> 03:28.880
这里面写的是什么 写的是模块图径

03:28.880 --> 03:30.880
对不对 我们用这种方式来导入一个模块

03:30.880 --> 03:33.880
那么导入模块的时候node它会做什么事情呢

03:33.880 --> 03:35.880
会做以下两件事

03:35.880 --> 03:37.880
当然我这里不考虑缓存

03:37.880 --> 03:40.880
第一次夹载模块的时候它没有缓存

03:40.880 --> 03:42.880
那么它会做以下两件事

03:43.880 --> 03:45.880
node它会通过模块路径

03:45.880 --> 03:49.880
在本机去找到相应的文件

03:49.880 --> 03:51.880
并且读取文件的一种

03:51.880 --> 03:53.880
好 咱们看一下

03:53.880 --> 03:56.880
我们当时在本机上写了一些文件

03:56.880 --> 03:59.880
index,poker,test,utl

03:59.880 --> 04:01.880
这些都是模块文件

04:01.880 --> 04:03.880
那么我们启动index.GS的时候

04:03.880 --> 04:04.880
当我们去引用

04:04.880 --> 04:07.880
当我们导入utl这个模块的时候

04:07.880 --> 04:08.880
它干嘛呢

04:08.880 --> 04:10.880
因为node是在本机运行的

04:10.880 --> 04:12.880
就在当前的电脑上运行的

04:12.880 --> 04:14.880
它会从这个电脑上

04:14.880 --> 04:17.880
去找到我们的其他的模块文件

04:17.880 --> 04:19.880
这个找的过程是很简单的

04:19.880 --> 04:21.880
根据我们当前的启动文件的路径

04:21.880 --> 04:23.880
去找到对应的模块文件

04:23.880 --> 04:24.880
对不对

04:24.880 --> 04:25.880
这是它第一件事

04:25.880 --> 04:26.880
把文件的内容读出来

04:26.880 --> 04:29.880
就把这一块内容全部把它读出来

04:29.880 --> 04:31.880
读出来之后还又做了什么事呢

04:31.880 --> 04:33.880
它会把这个文件的内容

04:33.880 --> 04:36.880
里边的代码放到一个函数环境里边去执行

04:36.880 --> 04:38.880
这也是我们之前讲过的

04:38.880 --> 04:39.880
我们把它放到一个匿名

04:39.880 --> 04:41.880
我们把它当成一个匿名函数

04:41.880 --> 04:44.880
在函数并且把函数执行后

04:44.880 --> 04:46.880
把这个代码执行后

04:46.880 --> 04:48.880
把个module叫export的值

04:48.880 --> 04:50.880
当成导出的内容

04:50.880 --> 04:53.880
也就是作为require函数的反馈结果

04:53.880 --> 04:55.880
这也是我们上节课讲的

04:55.880 --> 04:57.880
我们以前之前node

04:57.880 --> 05:00.880
它之所以能够实现common介石

05:00.880 --> 05:02.880
是因为它做了这么两件事

05:02.880 --> 05:03.880
它为了实现common介石

05:03.880 --> 05:05.880
它做了这么两件事

05:05.880 --> 05:07.880
正是因为这两个步骤

05:07.880 --> 05:09.880
使得common介石在node端

05:09.880 --> 05:11.880
可以被良好的支持

05:11.880 --> 05:13.880
因为node它开发node的环境的时候

05:13.880 --> 05:16.880
它引入了模块化标准就是common介石

05:16.880 --> 05:18.880
它就完全按照common介石那种理念

05:18.880 --> 05:20.880
把它实现了

05:20.880 --> 05:22.880
其实这一点有一个细节

05:22.880 --> 05:24.880
我们之前没有讲到

05:24.880 --> 05:25.880
我们在这里说一下

05:25.880 --> 05:27.880
说common介石是同步的

05:27.880 --> 05:29.880
为什么叫同步呢

05:29.880 --> 05:31.880
是因为我们这两件事情必须要

05:31.880 --> 05:33.880
做完了之后代码才会继续执行

05:33.880 --> 05:34.880
啥意思呢

05:34.880 --> 05:36.880
我们看这里

05:36.880 --> 05:38.880
我们以前用的common介石node端

05:38.880 --> 05:40.880
你看这个代码

05:40.880 --> 05:41.880
下边这一行代码

05:41.880 --> 05:42.880
是不是必须要等到

05:42.880 --> 05:44.880
上面这一行代码执行完了之后

05:44.880 --> 05:45.880
才会执行

05:45.880 --> 05:47.880
而上边这一行代码

05:47.880 --> 05:49.880
是不是要做刚才我们说的那两件事

05:49.880 --> 05:50.880
读取文件

05:50.880 --> 05:51.880
找到文件

05:51.880 --> 05:52.880
读取文件内容

05:52.880 --> 05:54.880
把文件内容放到一个函数环境里面执行

05:54.880 --> 05:55.880
执行完了

05:55.880 --> 05:57.880
把majoo叫export

05:57.880 --> 05:59.880
把majoo叫export的值

05:59.880 --> 06:02.880
把它作为模块的导出内容

06:02.880 --> 06:04.880
作为require函数的返回值

06:04.880 --> 06:06.880
返回过后用变量来接收

06:06.880 --> 06:08.880
然后才会继续往后面运行

06:08.880 --> 06:09.880
对不对

06:09.880 --> 06:11.880
所以说我们认为呢

06:11.880 --> 06:13.880
这个require它不是异步的

06:13.880 --> 06:14.880
它不是说我不等立的

06:14.880 --> 06:15.880
不等立的

06:15.880 --> 06:16.880
不等立读文件

06:16.880 --> 06:17.880
我继续往后面运行

06:17.880 --> 06:18.880
没有这种说法

06:18.880 --> 06:19.880
它是同步的

06:19.880 --> 06:21.880
它一定要等到好完了之后

06:21.880 --> 06:22.880
才会执行

06:22.880 --> 06:25.880
这是它的common介石这么一个特点

06:25.880 --> 06:27.880
可能有很多人就开在想了

06:27.880 --> 06:29.880
这样是不是有效率问题

06:29.880 --> 06:30.880
对不对

06:30.880 --> 06:31.880
想法很好

06:31.880 --> 06:33.880
咱们继续往后看

06:33.880 --> 06:35.880
由于它是同步的

06:35.880 --> 06:37.880
于是把它放到浏览器端的时候

06:37.880 --> 06:39.880
就会出严重的问题了

06:39.880 --> 06:41.880
什么严重的问题呢

06:41.880 --> 06:42.880
下面有两点

06:42.880 --> 06:44.880
这两点就刚好对应到

06:44.880 --> 06:46.880
node解决这个问题的这两点

06:46.880 --> 06:48.880
好 咱们来看一下

06:48.880 --> 06:49.880
第一个问题

06:49.880 --> 06:51.880
第一个遇到的挑战

06:51.880 --> 06:53.880
就是浏览器要加载介石文件

06:53.880 --> 06:55.880
可跟node不一样

06:55.880 --> 06:57.880
node是在本机运行的

06:57.880 --> 06:58.880
对吧

06:58.880 --> 06:59.880
我们通过一个命令

06:59.880 --> 07:00.880
直接在本机运行的

07:00.880 --> 07:01.880
这些文件全部在本机

07:01.880 --> 07:03.880
从本机去读文件

07:03.880 --> 07:05.880
速度是很坏的

07:05.880 --> 07:07.880
但是在浏览器这一端就不一样了

07:07.880 --> 07:09.880
浏览器这一端你还要

07:09.880 --> 07:11.880
做这么一件事的话就麻烦了

07:11.880 --> 07:14.880
比方说我们在这里随便写一个

07:14.880 --> 07:16.880
写个index.get

07:16.880 --> 07:17.880
一面文件

07:17.880 --> 07:19.880
它有一个入口文件

07:19.880 --> 07:21.880
比方说index.get

07:21.880 --> 07:22.880
比方说

07:22.880 --> 07:23.880
当然这些东西是没法运行的

07:23.880 --> 07:25.880
因为浏览器端没法支持common介石

07:25.880 --> 07:27.880
我们去引用介石文件

07:27.880 --> 07:28.880
当成入口文件

07:28.880 --> 07:30.880
在入口文件里面

07:30.880 --> 07:31.880
用了require

07:31.880 --> 07:33.880
比方说

07:33.880 --> 07:34.880
就假设能用

07:34.880 --> 07:36.880
我们看一下会出什么样的问题

07:36.880 --> 07:38.880
用到了adder.js

07:38.880 --> 07:40.880
在adder.js里面

07:40.880 --> 07:43.880
又用到了b.js

07:43.880 --> 07:45.880
没什么意思吗

07:45.880 --> 07:47.880
用到了b.js

07:47.880 --> 07:49.880
b.js里面我就不写了

07:49.880 --> 07:51.880
那么现在的浏览器端

07:51.880 --> 07:53.880
为什么不能这样子用了

07:53.880 --> 07:55.880
是因为我们的浏览器写的

07:55.880 --> 07:56.880
这些頁面

07:56.880 --> 07:58.880
介石文件

07:58.880 --> 07:59.880
css文件

07:59.880 --> 08:02.880
最终是要放到浮览器上的

08:02.880 --> 08:05.880
让用户通过浏览器来访问

08:05.880 --> 08:06.880
对吧

08:06.880 --> 08:07.880
它不是在本机运行的

08:07.880 --> 08:09.880
它是在浮览器的一段

08:09.880 --> 08:11.880
于是它会出现这么一种格式

08:11.880 --> 08:13.880
给它画个图

08:13.880 --> 08:16.880
我们写的这些文件

08:16.880 --> 08:18.880
什么adder.js

08:18.880 --> 08:20.880
index.get

08:20.880 --> 08:22.880
还有什么adder.js

08:22.880 --> 08:23.880
b.get

08:23.880 --> 08:24.880
所以全部在浮览器上

08:24.880 --> 08:26.880
这些东西全部在浮览器

08:31.050 --> 08:32.050
得远程浮览器

08:32.050 --> 08:33.050
对我们写完

08:33.050 --> 08:34.050
开发完了之后

08:34.050 --> 08:36.050
会把它部署到远程浮览器

08:36.050 --> 08:38.050
肯定很多同学都不知道怎么部署

08:38.050 --> 08:39.050
不着急

08:39.050 --> 08:41.050
我们以后学了浮览器开发之后

08:41.050 --> 08:42.050
就会告诉你怎么部署

08:42.050 --> 08:44.050
那么现在你也只需要知道

08:44.050 --> 08:45.050
我们写的这些东西

08:45.050 --> 08:46.050
不是在本机运行的

08:46.050 --> 08:49.050
而是要把它放到浮览器上面

08:49.050 --> 08:51.050
然后拥护这一端有个什么

08:51.050 --> 08:53.050
只有一个东西就是浏览器

08:53.050 --> 08:54.050
你看拥护的电脑上

08:54.050 --> 08:55.050
它有这些文件吗

08:55.050 --> 08:56.050
啥都没有

08:56.050 --> 08:59.050
它只有一个浏览器

08:59.050 --> 09:00.050
那么它怎么运行的

09:00.050 --> 09:01.050
比方说浏览器

09:01.050 --> 09:02.050
它通过一个请求地址

09:02.050 --> 09:04.050
比如说3w.sasa

09:04.050 --> 09:06.050
那么它就可以拿到

09:06.050 --> 09:08.050
就可以拿到这个页面

09:08.050 --> 09:13.090
画个箭头

09:13.090 --> 09:14.090
它就可以拿到

09:14.090 --> 09:15.090
它去请求这个页面

09:15.090 --> 09:17.090
那么服务器就会

09:17.090 --> 09:18.090
把这个页面的什么

09:18.090 --> 09:20.090
页面的ATM代码给它

09:20.090 --> 09:21.090
对吧

09:21.090 --> 09:22.090
它就会把这个代码给它

09:22.090 --> 09:23.090
这第二步

09:23.090 --> 09:25.090
它会把这个页面代码

09:25.090 --> 09:27.090
就是页面的ATM代码给它

09:27.090 --> 09:28.090
给浏览器

09:28.090 --> 09:29.090
浏览器干嘛

09:29.090 --> 09:31.090
是不是把这个页面渲染出来

09:31.090 --> 09:32.090
一渲染的时候

09:32.090 --> 09:33.090
它是不是发现

09:33.090 --> 09:34.090
我现在要去读哪个

09:34.090 --> 09:36.090
是不是读IN这个设定

09:36.090 --> 09:37.090
JS文件

09:37.090 --> 09:38.090
那么现在我去读IN这个设定

09:38.090 --> 09:39.090
JS文件

09:39.090 --> 09:42.090
于是浏览器它又发出请求

09:42.090 --> 09:44.090
又发出一个请求

09:44.090 --> 09:46.090
去读IN这个设定的JS文件

09:46.090 --> 09:47.090
为什么

09:47.090 --> 09:48.090
因为在ATM页面里边

09:48.090 --> 09:50.090
它要引用IN这个设定的JS

09:50.090 --> 09:52.090
浏览器它又会发动请求

09:52.090 --> 09:54.090
去读IN这个设定的JS

09:54.090 --> 09:55.090
对吧

09:55.090 --> 09:56.090
那么继续

09:57.090 --> 09:58.090
然后服务器又把

09:58.090 --> 10:00.090
IN这个设定的JS文件

10:00.090 --> 10:01.090
又返回给它

10:01.090 --> 10:02.090
你看

10:02.090 --> 10:03.090
这个过程是不是请求了

10:03.090 --> 10:04.090
请求了两次

10:04.090 --> 10:05.090
对吧

10:05.090 --> 10:06.090
改请求两次就要请求两次

10:06.090 --> 10:07.090
那没办法

10:07.090 --> 10:08.090
你浏览器里边

10:08.090 --> 10:10.090
引用了IN这个设定的JS

10:10.090 --> 10:11.090
肯定要请求两次

10:11.090 --> 10:12.090
没问题

10:12.090 --> 10:13.090
这个过程都还没问题

10:13.090 --> 10:15.090
那么接下来我们继续看

10:15.090 --> 10:16.090
接下来就出问题了

10:16.090 --> 10:18.090
我们IN这个设定的JS

10:18.090 --> 10:20.090
放到给了浏览器过后

10:20.090 --> 10:21.090
浏览器是不是要执行这个JS

10:21.090 --> 10:22.090
好

10:22.090 --> 10:23.090
来

10:23.090 --> 10:24.090
它开始来执行这个JS

10:24.090 --> 10:26.090
执行JS的过程中

10:26.090 --> 10:27.090
那你就遇到问题了

10:27.090 --> 10:29.090
比方说我们这里上边

10:29.090 --> 10:31.090
一大堆代码

10:31.090 --> 10:34.090
一大堆代码

10:34.090 --> 10:35.090
然后呢

10:35.090 --> 10:37.090
这里呢又是一大堆代码

10:37.090 --> 10:39.090
一大堆代码

10:39.090 --> 10:42.090
在中间我们去引用了AdderJS

10:42.090 --> 10:43.090
对吧

10:43.090 --> 10:44.090
在中间引用

10:44.090 --> 10:45.090
一开始执行一大堆代码

10:45.090 --> 10:46.090
没问题

10:46.090 --> 10:47.090
执行到这句话的时候

10:47.090 --> 10:48.090
它要找干嘛

10:48.090 --> 10:51.090
它要读取AdderJS文件的内容

10:51.090 --> 10:52.090
对吧

10:52.090 --> 10:53.090
CommonJS就是这样的规判

10:53.090 --> 10:54.090
它这里导入

10:54.090 --> 10:56.090
它要读取AdderJS的内容

10:56.090 --> 10:58.090
但是呢你会发现一个问题

10:58.090 --> 11:01.090
我这浏览器端有AdderJS吗

11:01.090 --> 11:02.090
没有

11:02.090 --> 11:03.090
它只有啥

11:03.090 --> 11:04.090
只把之前的頁面读过来了

11:04.090 --> 11:06.090
把Index的AdderJS读过来了

11:06.090 --> 11:07.090
AdderJS在哪

11:07.090 --> 11:08.090
没有

11:08.090 --> 11:09.090
没有干嘛

11:09.090 --> 11:10.090
是不是要用远程

11:10.090 --> 11:12.090
再去请求AdderJS

11:12.090 --> 11:14.090
对不对

11:14.090 --> 11:15.090
就要这样做

11:15.090 --> 11:16.090
要用远程

11:16.090 --> 11:18.090
再去请求AdderJS

11:18.090 --> 11:20.090
然后再把AdderJS的东西都拿过来

11:20.090 --> 11:21.090
对不对

11:21.090 --> 11:22.090
那么这个过程

11:22.090 --> 11:23.090
大家就看

11:23.090 --> 11:25.090
上面的四个键都不用看了

11:25.090 --> 11:26.090
就在Index的AdderJS

11:26.090 --> 11:27.090
就在这个JS文件

11:27.090 --> 11:28.090
运行的过程中

11:28.090 --> 11:29.090
它要用到AdderJS

11:29.090 --> 11:31.090
是不是要去把AdderJS请求过来

11:31.090 --> 11:32.090
对不对

11:32.090 --> 11:33.090
那么这个过程

11:33.090 --> 11:35.090
我把它变成红色

11:35.090 --> 11:38.090
这个过程是比较耗时的

11:38.090 --> 11:41.090
因为它跟我们的那个

11:41.090 --> 11:42.090
在这

11:42.090 --> 11:44.090
跟我们之前的CommonJS不一样了

11:44.090 --> 11:46.090
CommonJS就要本级读取

11:46.090 --> 11:48.090
虽然说在磁盘上读取文件

11:48.090 --> 11:50.090
速度肯定没有在内存里面读取快

11:50.090 --> 11:53.090
但是呢它至少没有那么的慢

11:53.090 --> 11:54.090
并且有缓存

11:54.090 --> 11:55.090
读一次就完事了

11:55.090 --> 11:57.090
但是呢到了浏览期段就不一样了

11:57.090 --> 11:59.090
浏览期段它不是本地读取

11:59.090 --> 12:01.090
它要跑到远程去读取

12:01.090 --> 12:03.090
远程去读的话

12:03.090 --> 12:04.090
如果说你在页面上

12:04.090 --> 12:06.090
直接把AdderJS引用进来

12:06.090 --> 12:07.090
那还好说

12:07.090 --> 12:08.090
实际上这个东西

12:08.090 --> 12:10.090
这个情况还好一点

12:10.090 --> 12:11.090
这个还好说

12:11.090 --> 12:12.090
因为呢我

12:12.090 --> 12:13.090
反正要夹在这两个JS文件

12:13.090 --> 12:14.090
我一开始夹在

12:14.090 --> 12:16.090
他们互不赶早直接寄就行了

12:16.090 --> 12:17.090
对吧

12:17.090 --> 12:19.090
如果说你在Index的JS里边

12:19.090 --> 12:21.090
你给我写成这种格式就麻烦了

12:21.090 --> 12:22.090
为什么

12:22.090 --> 12:24.090
因为CommonJS是同步的

12:24.090 --> 12:26.090
它在这里必须要等

12:26.090 --> 12:28.090
这是同步代码

12:28.090 --> 12:30.090
它必须要等待

12:30.090 --> 12:33.090
那么这个等待过程是不是非常非常漫长

12:33.090 --> 12:35.090
因为有远程的传输

12:35.090 --> 12:37.090
有远程的数据传输

12:37.090 --> 12:38.090
它要去请求这个A

12:38.090 --> 12:39.090
然后A要返回给它

12:39.090 --> 12:40.090
是不是有远程传输

12:40.090 --> 12:42.090
那就比本地读文件

12:42.090 --> 12:45.090
要慢得多

12:45.090 --> 12:47.090
而且呢遇到网络不好的情况下

12:47.090 --> 12:48.090
可能要传输很久

12:48.090 --> 12:50.090
那么这种情况下

12:50.090 --> 12:52.090
你看一下这里的代码能等吗

12:52.090 --> 12:53.090
如果说后面还有很多的事情要做

12:53.090 --> 12:55.090
那么这一代码是不是全部在等着

12:55.090 --> 12:56.090
对吧

12:56.090 --> 12:57.090
全部在等着

12:57.090 --> 13:00.090
那么就会造成浏览器的卡使

13:00.090 --> 13:01.090
就会一直卡使

13:01.090 --> 13:03.090
因为它这个代码一直执行不出来

13:03.090 --> 13:04.090
一直要等

13:04.090 --> 13:06.090
那么后面的代码全部在等

13:06.090 --> 13:07.090
就会当成浏览器卡使

13:07.090 --> 13:08.090
没有这意思吗

13:08.090 --> 13:11.090
所以说呢由于CommonJS

13:11.090 --> 13:13.090
根本的原因在这

13:13.090 --> 13:15.090
由于CommonJS是同步的

13:15.090 --> 13:16.090
浏览器端呢

13:16.090 --> 13:19.090
它要加在这个文件的速度太慢了

13:19.090 --> 13:21.090
它没有本地加在文件的速度那么快

13:21.090 --> 13:22.090
所以说呢

13:22.090 --> 13:25.090
这就会极大的降低运行性的

13:25.090 --> 13:28.090
因此这次CommonJS在浏览器端

13:28.090 --> 13:29.090
遇到了第一个主案

13:29.090 --> 13:31.090
第二个主案

13:31.090 --> 13:32.090
就是说

13:32.090 --> 13:34.090
我们当时的NodeJS

13:34.090 --> 13:36.090
它要完成的CommonJS

13:36.090 --> 13:38.090
要把实现它怎么做的呢

13:38.090 --> 13:40.090
它是把文件代码读出来

13:40.090 --> 13:42.090
放到一个函数环境里面执行

13:42.090 --> 13:44.090
也就是Node它本身就做了这么一件事

13:44.090 --> 13:46.090
但是当我浏览器端就不一样了

13:46.090 --> 13:48.090
浏览器厂商呢

13:48.090 --> 13:50.090
它需要支持这么一件事

13:50.090 --> 13:52.090
就是说我要实现CommonJS

13:52.090 --> 13:53.090
那么需要浏览器厂商呢

13:53.090 --> 13:56.090
你把你的浏览器的底层代码改一下

13:56.090 --> 13:58.090
如果说我用Require去读取一个文件

13:58.090 --> 14:00.090
我们先不考虑什么

14:00.090 --> 14:01.090
远程传输慢不慢

14:01.090 --> 14:03.090
同步的问题先不考虑

14:03.090 --> 14:04.090
那么就算是慢

14:04.090 --> 14:05.090
我等着吧

14:05.090 --> 14:06.090
我又等着

14:06.090 --> 14:08.090
你把文件的内容拿到之后呢

14:08.090 --> 14:10.090
你得浏览器得把这些文件的内容

14:10.090 --> 14:12.090
放到一个函数环境里面执行

14:12.090 --> 14:14.090
就像Node那样子

14:14.090 --> 14:15.090
但是呢

14:15.090 --> 14:17.090
浏览器厂商它不愿意提供支持

14:17.090 --> 14:18.090
为什么呢

14:18.090 --> 14:20.090
有很多的复杂的原因

14:20.090 --> 14:21.090
其中一个原因的就是

14:21.090 --> 14:22.090
因为CommonJS呢

14:22.090 --> 14:24.090
它属于社区规范

14:24.090 --> 14:25.090
民间的规范

14:25.090 --> 14:27.090
它并非官方标准

14:27.090 --> 14:28.090
而浏览器呢

14:28.090 --> 14:30.090
它要支持的是官方标准

14:30.090 --> 14:32.090
你民间的标准它不认的

14:32.090 --> 14:33.090
所以说呢

14:33.090 --> 14:35.090
浏览器厂商不愿意提供这样的支持

14:35.090 --> 14:36.090
就这两个原因

14:36.090 --> 14:38.090
就导致了CommonJS

14:38.090 --> 14:40.090
在浏览器端就很麻烦了

14:40.090 --> 14:41.090
第一个原因

14:41.090 --> 14:43.090
远程传输的原因

14:43.090 --> 14:44.090
远程传输过来

14:44.090 --> 14:45.090
需要耗时

14:45.090 --> 14:46.090
而CommonJS

14:46.090 --> 14:47.090
它的规范里面是同步的

14:47.090 --> 14:48.090
这里的导入是同步的

14:48.090 --> 14:50.090
那么浏览器等不了那么久

14:50.090 --> 14:52.090
会造成大规模代码的组设

14:52.090 --> 14:53.090
第二个原因呢

14:53.090 --> 14:56.090
是浏览器厂商不愿意把那个就是

14:56.090 --> 14:57.090
实现去

14:57.090 --> 14:58.090
实现那个CommonJS规范

14:58.090 --> 14:59.090
不愿意把文件的内容

14:59.090 --> 15:01.090
放到韩束环境里面执行

15:01.090 --> 15:03.090
那么这两个原因呢

15:03.090 --> 15:04.090
就阻碍了CommonJS

15:04.090 --> 15:07.090
在浏览器这一端的发展

15:07.090 --> 15:08.090
那么有问题呢

15:08.090 --> 15:09.090
肯定有解决办法

15:09.090 --> 15:11.090
怎么解决呢

15:11.090 --> 15:12.090
当时呢

15:12.090 --> 15:14.090
ES6的模块化还没有出来

15:14.090 --> 15:15.090
官方都还没有发话

15:15.090 --> 15:16.090
你们自己玩

15:16.090 --> 15:17.090
你们先玩着

15:17.090 --> 15:19.090
我先考虑清楚了再说

15:19.090 --> 15:20.090
于是呢

15:20.090 --> 15:22.090
社区里面就开始在讨论了

15:22.090 --> 15:23.090
那么既然浏览器

15:23.090 --> 15:25.090
突然遇到了这么一些问题

15:25.090 --> 15:27.090
我们能不能自己重新定一个规范

15:27.090 --> 15:29.090
也不需要浏览器厂商的参与了

15:29.090 --> 15:31.090
我们自己来定一个规范

15:31.090 --> 15:32.090
你的规范或者是写个什么

15:32.090 --> 15:34.090
JS文件就要实现了

15:34.090 --> 15:35.090
能不能这样做呢

15:35.090 --> 15:36.090
可以

15:38.090 --> 15:39.090
这就代表了

15:39.090 --> 15:41.090
我们浏览器的模块化

15:41.090 --> 15:43.090
在最开始的时候呢

15:43.090 --> 15:45.090
需要一些社区来解决

15:45.090 --> 15:46.090
它其实

15:46.090 --> 15:47.090
原理很简单

15:47.090 --> 15:49.090
我们后边讲到什么AMD

15:49.090 --> 15:50.090
CMD

15:50.090 --> 15:51.090
他们的原理呢

15:51.090 --> 15:53.090
都是使用了下面两点原理

15:54.090 --> 15:55.090
哪家的原理呢

15:55.090 --> 15:56.090
第一个

15:56.090 --> 15:58.090
你不是远程家在JS吗

15:58.090 --> 16:00.090
远程家在不是很浪费时间吗

16:00.090 --> 16:01.090
如果说同步的话

16:01.090 --> 16:03.090
会导致后边弹码全部卡着

16:03.090 --> 16:04.090
对吧

16:04.090 --> 16:05.090
有同步的问题

16:05.090 --> 16:07.090
那么你把它做成一步就不就完了吗

16:07.090 --> 16:08.090
对吧

16:08.090 --> 16:09.090
我又不是必须要

16:09.090 --> 16:10.090
使用CommonJS规范

16:10.090 --> 16:11.090
CommonJS规范必须要

16:11.090 --> 16:12.090
要求它是同步的

16:12.090 --> 16:14.090
但是我不去用它

16:14.090 --> 16:15.090
我自己订规范

16:15.090 --> 16:16.090
这规范是异步的

16:16.090 --> 16:18.090
就是我家在导致一个东西过后

16:18.090 --> 16:19.090
它是异步的

16:19.090 --> 16:21.090
比方说我们家在完了过后

16:21.090 --> 16:22.090
用一个回调就完了

16:22.090 --> 16:24.090
就有点类似于阿迦克斯请求

16:24.090 --> 16:25.090
就比方说

16:25.090 --> 16:26.090
举个下举个例子

16:26.090 --> 16:27.090
我们比方说这样子

16:27.090 --> 16:30.090
你远程去够夹在JS

16:30.090 --> 16:31.090
夹在完了过后

16:31.090 --> 16:33.090
去运行这个回调函数

16:33.090 --> 16:35.090
不就完了吗

16:35.090 --> 16:36.090
不就完了吗

16:36.090 --> 16:38.090
我就用这种模式来做什么

16:38.090 --> 16:39.090
那么就是

16:39.090 --> 16:41.090
它可以指定这么一种规范

16:41.090 --> 16:42.090
没了意思吗

16:42.090 --> 16:43.090
第二个

16:43.090 --> 16:45.090
你不是要解决

16:45.090 --> 16:47.090
那个模块代码

16:47.090 --> 16:49.090
它必须要放到函数环境里边吗

16:49.090 --> 16:51.090
当你在编写这个模块的时候

16:51.090 --> 16:52.090
你就不要按照

16:52.090 --> 16:54.090
CommonJS那种直接编写方式

16:54.090 --> 16:56.090
我们之前CommonJS里面

16:56.090 --> 16:57.090
是不是直接编写到模块代码

16:57.090 --> 16:58.090
直接写的

16:58.090 --> 17:00.090
这东西自动就隐藏了

17:00.090 --> 17:02.090
自动就放到函数环境里面执行了

17:02.090 --> 17:03.090
那我现在没法自动

17:03.090 --> 17:04.090
因为浏览器不支持

17:04.090 --> 17:05.090
厂商不支持

17:05.090 --> 17:06.090
那没法自动怎么办

17:06.090 --> 17:07.090
我手动呗

17:07.090 --> 17:08.090
我写模块的时候

17:08.090 --> 17:09.090
就直接放到函数里边

17:09.090 --> 17:11.090
按照某种规范

17:11.090 --> 17:12.090
放到函数里边

17:12.090 --> 17:13.090
不就解决了吗

17:13.090 --> 17:16.090
就解决的办法非常的简单粗暴

17:16.090 --> 17:18.090
很容易解决

17:18.090 --> 17:19.090
其实没有那么难

17:19.090 --> 17:20.090
没有那么难

17:20.090 --> 17:22.090
只需要脱离这个CommonJS规范

17:22.090 --> 17:24.090
自己去做一个新的规范出来

17:24.090 --> 17:27.090
于是基于这样的简单有效的时度

17:27.090 --> 17:29.090
就出现了AMD和CMD规范

17:29.090 --> 17:31.090
这两个规范都有效的解决

17:31.090 --> 17:33.090
浏览器模块的问题

17:33.090 --> 17:34.090
咱们这一张

17:34.090 --> 17:36.090
后面就简单的给大家介绍一下

17:36.090 --> 17:38.090
AMD和CMD

17:38.090 --> 17:39.090
因为这两个规范

17:39.090 --> 17:40.090
现在几乎是不打用了

17:40.090 --> 17:42.090
所以说我们简单介绍一下就行了

17:42.090 --> 17:43.090
这就是这一颗

17:43.090 --> 17:45.090
不过这一颗是非常重要的

17:45.090 --> 17:47.090
你必须要理解AMD规范和CMD规范

17:47.090 --> 17:48.090
是怎么出来的

17:48.090 --> 17:50.090
它一定是CommonJS遇到问题的

17:50.090 --> 17:51.090
如果说CommonJS没问题的话

17:51.090 --> 17:52.090
我干嘛不直接用它呢

17:52.090 --> 17:55.090
大家实现大和解大统一多好了

17:55.090 --> 17:57.090
就是因为它有问题在浏览器端

17:57.090 --> 18:00.090
所以说我们用到了AMD和CMD

18:00.090 --> 18:02.090
给大家解释一下

18:02.090 --> 18:04.090
我们下节课开始来学习AMD

