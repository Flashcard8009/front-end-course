WEBVTT

00:00.750 --> 00:05.350
咱们这个课呢 叫做模块化 又是你们新的课程了

00:05.350 --> 00:11.150
这个课呢 我们要学习这门课啊 我们之前得有一些基础知识

00:11.150 --> 00:17.950
什么基础知识呢 咱们要学习这个模块化的课程啊 得有一些基础知识

00:17.950 --> 00:21.350
首先呢 你得学过itema和CSS 这个没啥好说的

00:21.350 --> 00:26.350
然后呢 你得学习javascript的基础啊 javascript的基础 你得学习了

00:26.750 --> 00:35.750
然后呢 你最好啊 最好能够掌握s6啊 最好不强制要求啊 不强制要求啊 最好能够掌握

00:36.350 --> 00:41.150
如果说你没有学习过es6的话 能不能学这门课呢 也能学啊 也能学 但是呢

00:41.950 --> 00:46.550
效果上呢 肯定没有学到es6那么好啊 所以说你最好了能够掌握es6

00:48.150 --> 00:55.950
啊 这门课呢 它首先呢 是非常简单啊 整个课程呢 大家学习起来 时间也没那么长啊 也非常简单内容

00:57.350 --> 01:06.350
但是呢 它非常重要 特别特别的重要 因为这门课呢 是你通向前端工程化的一个门户

01:07.150 --> 01:15.750
就我们之前呢 做学前端呢 学的都是做的是一些页面的效果 对吧 做一些页面什么换什么的 就是轮波图啊

01:16.550 --> 01:23.950
学习了一些简单的阿迦克斯请求啊 那么做一个表格啊 做一个漂浮的广告啊之类的 都做一些页面效果

01:24.670 --> 01:37.470
等到了你学了模块化之后呢 你就能真正的具备了做大型应用的基础了啊 如果没有模块化的话 你写大型应用能不能写呢 能写 但是呢 写的过程呢 非常痛苦 非常的困难

01:38.110 --> 01:48.630
有了模块化之后呢 你再写大型应用的时候呢 你就有了一定的基础了啊 包括我们后边学什么vpec啊 学什么vue啊reactor 这些东西呢 他们的根基

01:49.030 --> 01:53.870
都是建立在模块化的基础上的 说模块化这门课非常重要

01:54.350 --> 01:56.870
但他同时非常简单啊 不要有什么心理压力

01:57.870 --> 02:04.990
好 这节课呢 我是对我们这门课啊 已经了模块化的发展史呢 做一个介绍啊 算是一个概述

02:05.550 --> 02:13.830
因为有些同学呢 学一个模块化啊 他不知道这个东西怎么来的 学了半天 这对怎么出现的 为什么莫名其妙的就出现这个模块化了呢

02:14.430 --> 02:23.830
他是有一定的历史远远的 我们把这些核心的历史的发展给他介绍一下呢 你就知道了 模块化他是怎么产生的了啊 他能解决什么样的问题

02:24.950 --> 02:30.830
好 我这里呢 把GS的发展呢 分为了四个阶段啊 但我这是我的话分啊

02:31.550 --> 02:36.790
纯粹是我个人想的话分 我通过这样的话分了 大家好理解 好 我们一个个说啊 随便第一阶段

02:37.550 --> 02:44.110
第一阶段呢 就是GS语言的诞生啊 我做这个课件呢 其实已经写的非常详细了啊 我们把这个课件看一遍

02:45.030 --> 02:50.910
就是我们在GS语言刚刚开始的时候呢 他的目标其实很简单

02:51.150 --> 02:59.950
啊 他仅仅是为了实现一面动作一些小效果 比方说一个漂浮的广告 或者是一张图片 鼠标一上去的图片变大了啊

03:00.430 --> 03:04.310
或者是一个超链接指上去的变个颜色 他就是为了做这么一些小的效果

03:04.950 --> 03:08.150
所以说那个时候呢 一个页面呢 他用到的介式

03:08.750 --> 03:16.670
代码呢 可能只有几十行啊 上百行或者是几百行的代码就差不多了 因为这些小的效果呢 本身呢 并不复杂

03:17.150 --> 03:20.710
要写的代码量了也很少 所以说这种情况下呢

03:21.750 --> 03:27.830
介式语言呢 所以我们都知道啊 介式语言他仅用了十天时间 对吧 十天时间就把这个语言做出来了

03:28.150 --> 03:32.230
所以说他里边肯定有不少的缺陷 仓促做出来的语言 肯定有不少的缺陷

03:32.670 --> 03:36.910
那么这些缺陷呢 往往会被大家有一点忽略 因为程序太简单了

03:37.630 --> 03:42.550
规模太小了 只要你开发的时候呢 小心谨慎 往往不会造成什么问题

03:42.870 --> 03:47.910
因为这个时候呢 介式语言还没有能够 还不具备能够开发大型应用的

03:48.630 --> 03:54.310
这么一个基础 还不具备 而且呢 我们平时也不会用 那个时候还不会用介式语言开发大型

03:54.630 --> 03:55.150
大型应用

03:56.310 --> 04:03.110
那么这个时候呢 当然他也不存在专业的前段工程师 那个时候不存在那种说法 什么前段工程师 没有这个说法

04:03.830 --> 04:07.030
因为他做的事情太少了啊 因为这个写的代码量也很少

04:07.430 --> 04:14.110
所以说呢 这一部分工作呢 往往是由后端开发人员顺带完成的 那个时候呢 还不叫后端开发人员

04:14.550 --> 04:21.270
就叫软件工程师啊 就叫软件工程师 所以说他就顺带完成了 开发后端的过程中 我们就把顺带完成了

04:22.110 --> 04:29.150
这是第一个阶段啊 第一个阶段呢 我们发生了一些大事啊 我们简单看一下啊 就是首先是96年了

04:29.670 --> 04:36.630
这个什么公司啊 王景公司的let's game 他把这个他发明的这个介式语言提交给欧洲的一个标准组织

04:36.870 --> 04:41.270
就是我们现在知道的啊 叫 acma 啊 叫做欧洲计算机制造商协会

04:42.110 --> 04:51.510
提交这个组织干嘛呢 他希望了 把这个语言形成一套标准啊 毕竟也是个语言嘛 虽然说 虽然说当时这个语言呢 只能在浏览器环境里面运行

04:51.750 --> 04:57.830
但是他毕竟是个语言啊 他希望了 把它做成一个标准啊 提交给欧洲制造商协会啊 不过这个协会呢

04:58.630 --> 05:07.470
对这个介式语言啊 他的可能没有那么重视吧啊 所以他制定标准的过程呢 比较缓慢啊 我们后续可以看到

05:08.230 --> 05:15.110
然后呢 另外一件大事呢 是在1998年啊 王景公司 我们知道第一次浏览器大战 王景公司和微软浏览器

05:15.350 --> 05:24.750
IE之间发生那个第一次浏览器大战 那么王景公司实力了 对吧 啊 竞争失败 然后宣告 宣告破产啊 被美国的一家公司收购了

05:25.190 --> 05:28.510
好 这是第一阶段发生大事啊 好 接下来我们看第二阶段

05:29.590 --> 05:36.150
不着急啊 第二阶段的是班学的一个事件的发生 是在1998年

05:37.070 --> 05:39.630
啊 就是在王景公司宣告破产那一年

05:40.470 --> 05:45.830
阿加克斯出现了啊 这个技术呢 最早是由微软提出的啊 微软的其中一个部门提出的

05:46.390 --> 05:53.470
阿加克斯他解决了什么问题呢 他解决了一个问题就是啊 当然你要学习这么克力得学习过阿加克斯啊 不然的话 你看不懂这一块

05:54.030 --> 06:02.990
阿加克斯的出现他解决了什么问题呢 他解决了一个问题就是 浏览器之间啊 浏览器跟服务器之间要进行交互 以前呢 只能靠刷新页面

06:03.430 --> 06:09.950
然后我点击个超链接说刷新页面了 对吧 打开了一个页面 只能浏览器本身跟服务器之间发生交互

06:10.430 --> 06:15.950
他没有办法用解识语言向服务器发送一个请求 然后得到服务器的反悔结果

06:16.470 --> 06:23.430
啊 他不做不到 那么阿加克斯出现过后就可以做到了 那么这个时候呢 解识语言呢 他就有更强的功能了

06:23.870 --> 06:34.150
他不仅可以完成一些页面效果 同时呢 还可以向服务器发送请求 拿到服务器那边的数据啊 你当然你在学习过阿加克斯语言 你才知道我来说什么

06:34.990 --> 06:37.470
不是语言啊 阿加克斯是这么技术 你才知道我来说什么

06:38.350 --> 06:45.910
好 那么这样 这样子一种情况出现过后呢 解识语言呢 他逐步的在浏览器中 扮演了更加重要的角色了

06:46.070 --> 06:52.150
就不像以前那么简单的 我能够发生 我能够做一个效果出来就行了 不需要跟服务器之间有任何的交互

06:52.430 --> 06:55.790
那么阿加克斯出现之后呢 我们逐步的就可能会带有些之后

06:56.990 --> 07:04.510
比方说我们一个页面中只改变一部分数据啊 比如说这个表这个列表里边 要往要往这个列表里边加一项

07:04.830 --> 07:11.910
加一项是不是要提交表来提交到服务器 对吧 那么我们不希望到页面刷新了 没有必要让他刷新 我们直接用介石

07:12.270 --> 07:18.870
获取到你闻闷框里边填的新的那个数据 然后把他用介石发送给服务器 页面就不会刷新

07:19.350 --> 07:25.430
然后从服务器得到响应结果 再用介石语言往这个列表里边加一项 对吧 就可以做到了

07:25.990 --> 07:30.710
所以说呢介石呢他扮演了更加丰富的角色了 他可以跟服务器之间进行交互了

07:31.710 --> 07:39.870
那么这样子一来呢 他就可以使我们用户的流量页面的体验呢就更好啊 当然你学习过阿加克斯呢 你自然而然知道什么意思

07:40.710 --> 07:45.910
这样子一来呢 同时也带来一个问题 就是介石代码的数量开始增长了

07:46.590 --> 07:55.710
不像以前我们只做一个小的效果 写不了多少行代码 像我们我给大家讲 平时讲的一个公开直播课里边啊 像代码就是平时写一些效果 也不会用了阿加克斯

07:55.950 --> 08:02.510
那么这些效果呢 其实你看到每一个一个半小时的公开直播课也就是100100来行代码 对吧 并不多

08:02.870 --> 08:07.030
啊 但是呢 加入了阿加克斯之后呢 代码数量就开始增长了

08:07.830 --> 08:16.950
从最初的几百行代码到了后面的几万哈 前端的程序呢 开始逐渐 逐渐变得复杂 因为很多时候呢 后端开发的都想 哎 这个东西呢

08:17.590 --> 08:28.350
为了让用户体验的更好 我们可能不喜欢刷新页面 那么自然而然 需要把这这件这个功能呢 放到前端来做啊 前端来 向服务器发动请求 来达到数据 哎 那么

08:29.230 --> 08:32.030
在前端进行处理 说代码量的自然会增加

08:32.510 --> 08:39.710
啊 那么这个时候呢 后端开发者呢 开始觉得压力增大了 你看我平时呢 比较多我以前也是后端开发者啊

08:40.470 --> 08:45.630
我以最早的时候出来工作的时候呢 还要做一些前端 前端开发 因为那个时候呢

08:47.230 --> 08:49.950
前端开发的几乎是没有 几乎是没有 很少

08:50.790 --> 08:57.990
所以我们写着后端代码 本来我们在解决服务器的一些复杂问题 解决完了过后呢 我还要去写前端的戒是问题

08:58.470 --> 09:06.510
这些戒是代码的以前很很少 无所谓 我写就写了吧 但是到我工作的时候呢 代码就已经比较多了啊 那个时候代码 因为有阿迦克斯存在了

09:06.710 --> 09:11.710
说代码比较多了 那么那个时候呢 后端开发者的压力呢 主要增加了 他吃不消了

09:12.390 --> 09:15.190
承担不了这么多的工作 那么这个时候呢

09:16.030 --> 09:21.910
就有一些公司呢 就开始来招募一些专业的前端开发者 这个时候就已经开始来招募了

09:22.430 --> 09:28.910
像我工作的时候呢 就第一家公司 第一家公司的时候 当时就有有有专业的前端开发者

09:29.390 --> 09:36.190
不过那个时候呢 前端开发者的他待遇呢 很低 非常非常低 我当时我就不说具体数额了吧

09:36.510 --> 09:39.910
就说当时的前端开发者呢 普遍上吧

09:40.550 --> 09:44.470
他的待遇 心智待遇水平呢 相当于是后端开发者的一半 有的还不到

09:45.190 --> 09:49.590
待遇非常非常低 因为那个时候呢 前端开对前端开发者的要求非常非常简单

09:50.030 --> 09:55.710
就是你要会程序逻辑就行了 你会阿家各自寻求 你学的基本的程序逻辑 就可以做开发了

09:56.110 --> 09:59.390
就可以做开发了 因为那个时候呢 虽然前端的工作量呢

10:00.670 --> 10:07.590
比以前大多了 但是跟后端比起来 那完全是没法比的 工作量还是不够 另外呢 他的复杂度呢 也是不够的

10:08.630 --> 10:12.630
因此呢 所以说对前端开发者 他成了的开发任务呢 对后端开发来说

10:13.070 --> 10:15.150
还是比较简单 还是比较简单

10:16.150 --> 10:21.310
很多时候呢 公司里边 甚至我遇到 我遇到一个有趣的现象 就是我认识一个朋友

10:21.750 --> 10:27.030
他之前是做前台的 是一个女生 女孩子 他做前台的 他觉得前台待遇

10:27.630 --> 10:33.430
待遇不高啊 当时呢 那是一家开发公司 那么就就问他 要不要转个行啊 要不要去做一个

10:34.030 --> 10:39.230
做一个开发 觉得开发太难了 没关系 我们内部培训里吧 就用了三周

10:40.230 --> 10:45.350
三周 四周左右的时间 有一个月吧 一个月左右的时间就可以把他培养成可以写代码

10:45.750 --> 10:53.230
就非常非常简单 并不复杂 虽然待遇上呢 没有那个后端开发那么高 但是呢 毕竟比他做前台要高一点

10:54.070 --> 10:58.550
所以说他可以满足前端开发需要了 因此当时呢 前端开发了还比较简单

10:59.510 --> 11:03.870
根本原因在哪呢 根本原因呢 是前端呢 他无法

11:04.870 --> 11:10.030
进一步扩张了 无法进一步扩张了 他的规模只能到这 他又遇到一个瓶颈

11:10.430 --> 11:18.150
这个瓶颈是怎么带来的呢 因为他有几个问题没有解决 这几个问题会严重的限制前端程序的规模

11:19.070 --> 11:25.670
啊 一定是比以前更强了啊 以前做一些小的效果肯定是比这个更强 但是呢 你要形成后端那样的规模

11:26.150 --> 11:32.190
还不够啊 还不够 那么他怎么 为什么会支援他规模进一步扩大呢 他本来是可以继续扩大的

11:32.670 --> 11:35.670
但是呢 有这么有这么几个问题没有解决 第一个问题

11:36.150 --> 11:39.390
前面两个问题是实在是当时是实在是解决不了 没法解决

11:39.910 --> 11:44.710
第一个就是 因为我们写的介石代码在哪里执行的 是不是在浏览器里边执行的

11:45.550 --> 11:48.670
但是浏览器的执行的介石的速度太慢了

11:49.510 --> 11:54.910
效率太低了啊 因为那个时候呢 没有更好的介石执行引擎出现

11:55.590 --> 11:59.950
像那个时候基本上都是使用的i1浏览器对吧 我们大部分都使用的i1浏览器 像什么

12:00.550 --> 12:04.750
包括一些国内的一些山寨浏览器 他们也使用的是i1的内核

12:05.350 --> 12:08.350
所以说 执行起来的速度太慢了

12:08.950 --> 12:15.350
就是你把很多任务放到前端去做 没有后端做得高啊 后端在浮览器上 浮览我们都配好了配置的

12:15.590 --> 12:23.430
都是浮览环境 浮览的执行效率非常非常高 而且呢 这些浮览的什么加把语言啊 包括什么PAP语言啊 都比较成熟了

12:23.710 --> 12:27.710
他的执行效率都经过不断的优化了 所以他们的执行效率是非常高的

12:27.990 --> 12:36.830
就比不上这些语言的执行效率 所以很多复杂的事情呢 我们不愿意放到前端来做 还是希望在后端给他构建完成 然后直接把结果扔给前端就完事了

12:37.990 --> 12:38.990
好 第二个问题呢是

12:40.350 --> 12:51.070
用户端的电脑配置不足 就那个时候呢 那个时候我都还没开开开就是这个执行慢的时候啊 我其实我出来工作的时候都已经是解决了这个执行速度问题了啊

12:51.790 --> 12:57.870
然后呢 这个电脑配置不足的问题也解决了 但是在以前在我出来工作之前啊 那个时候呢 电脑配置还不足

12:58.670 --> 13:07.350
就还没有出现过很好的cpu 很高的内存都还没有打两种出现 当时的内存我记得我出来的时候 我在度大学的时候

13:07.670 --> 13:10.830
一级的内存就算是比较大的了啊 一级的内存比较大的了

13:11.950 --> 13:15.230
所以当时内存呢 受到电脑一些硬件资源的约束了

13:15.710 --> 13:21.950
我把一些复杂的任务交给前端去执行的 会导致拥护电脑卡顿啊 就说如果说你

13:22.990 --> 13:27.910
大家可能体会不到啊 就我们那个时候 有的时候上一些网站的时候 他可能写了很多的介石代码

13:28.230 --> 13:33.950
加上本来本来介石代码执行的速度就慢 加上电脑的配置一不足就导致了这个意面经常卡死

13:34.470 --> 13:37.990
现在可能有的时候你们还会遇到啊 一些流量器一面

13:39.190 --> 13:42.830
就是看着看着就卡死了 卡死的原因呢 很大程度上的原因就是因为他

13:43.110 --> 13:48.230
代码里边有些东西呢不合理啊 写的不合理 那么以前的哪怕你写合理的代码

13:49.510 --> 13:57.710
也会因为用户的电脑配置不足 导致用户的电脑卡死 卡顿 那么如果说你想啊 用户去留战一个页面 那个这个页面非常非常卡

13:58.270 --> 14:02.350
他对这个页面还有兴趣吗 不管你写是什么内容 我都没有任何兴趣了

14:02.750 --> 14:10.870
所以说呢 这也是会制约前端的发展 然后很多公司呢 他不愿意把这些复杂的东西呢放到前端来做 就是因为前面两个原因

14:11.710 --> 14:18.630
当然还有第三个原因啊 第三个原因当时以前的都还不是重点 因为前两个原因把限制死了 没办法 改变不了

14:19.190 --> 14:22.990
所以第三个原因呢 当时呢 还不是个重点 我们来看一下吧 第三个原因是

14:23.550 --> 14:27.630
如果说前端的规模进一步扩大 就会导致更多的代码 这是一定的

14:28.350 --> 14:34.830
更多代码的文一定会分文件 对吧 你不能把所有代码全部 几十万行代码器 写到一个文件里面 那太恐怖了 没法维护

14:35.310 --> 14:42.070
所以说我们一定会分分成不同的节式文件来写 那么不同的节式文件来写的话 就有一个严重的问题 就是权局变量污染

14:42.830 --> 14:47.950
对吧 我在其中一个节式里边定义了一个权局变量 那另一个节式里边我是不是还得想

14:48.670 --> 14:53.670
呃 我写这个节式文件的时候呢 我定一个权局变量 我之前有没有定义过呢

14:54.350 --> 15:02.310
定义过了会不会造成冲突呢 所以脑袋都想想烂了的 这样子 带来的开发压力太大了 不要你之前写了

15:03.270 --> 15:08.830
因为一个大型工程里边 往往会有很多很多的文件啊 上百个文件都有可能 比方你之前写了100个节式文件

15:09.350 --> 15:14.350
每个文件里边超过一万行代 不说一万行吧 超过一千行代吗 一千行代吗

15:15.070 --> 15:20.510
没问题吧 好 那么你现在写在写第101个文件 我现在问你

15:21.310 --> 15:24.430
前面的文件里边有哪些权局变量你还能记得吗

15:25.390 --> 15:31.950
你没法记得了 记不得了 这个东西太恐怖了 所以说当时的以前要解决这个问题的很麻烦很麻烦

15:32.310 --> 15:37.150
有些公司提出了一种命名规范 我每一个模块就是每一个文件啊

15:37.430 --> 15:42.390
我们可以认为每一个文件就是代表了一块功能啊 一个功能的就是一个模块啊 我们可以这样的想象

15:43.470 --> 15:47.390
模块画模块画嘛 就是分文件啊 分成一个一个模块一个一个功能来

15:48.550 --> 15:52.750
进行开发啊 而且呢 不同的模块是可以交给不同的开发里面开发的

15:53.470 --> 15:58.910
那么现在你要想啊 有些有些公司还开始来想办法做一些什么命名规范啊 比方说我这个模块

15:59.110 --> 16:05.030
我前面呢 要写上个模块名 然后一个下滑线 然后呢 写个就是变量名 通过这种方式来解决啊

16:05.430 --> 16:12.790
不过写的写的也挺烦的 真的是挺烦的 因为一个一向那么多变量 每一个权局变量 我们都要去这样子搞 是不是特别麻烦

16:13.950 --> 16:21.910
啊 有些人说 那我们能不能用什么立即执行函数呢 对吧 我们知道啊 用立即执行函数呢 可以把变量的约束在函数内部啊 我们看一下吧

16:23.190 --> 16:23.710
我们这里

16:25.150 --> 16:28.190
我们写一个立即执行函数 我就用那个

16:29.030 --> 16:30.030
以前的节式写的啊

16:31.310 --> 16:33.070
当然用ES6的函数也可以

16:35.030 --> 16:39.590
当然用有了ES6过后呢 我一会就会知道了 根本就用不上这些东西了

16:40.310 --> 16:47.150
好 那么这个 我们写个把把这些变量的放到这个模块里面 对吧 模块里面 这样子能不能解决呢 也没法解决

16:47.870 --> 16:56.710
因为你每一个模块你写了过后 不是说你你直信断代码就完了 你可能会提供一些函数啊 提供一些对象给其他模块使用 对吧

16:57.110 --> 17:04.430
你是不是得提供一些对象和函数给其他模块使用 对不对 那你怎么一般的 你是不是也得把这个模块

17:04.950 --> 17:16.710
内部要希望外面使用的东西暴露出来 对吧 是不是要暴露出来 因此呢 你是不是要返回一个东西 对吧 返回 比方说返回一个对象之类的啊 返回对象 那么这个对象呢 我们在这里用用一个东西来接收

17:17.310 --> 17:17.710
比方说

17:19.350 --> 17:26.110
一 对吧 是不是要用这种方式来接收 那么模块里写多了 这种暴露出去的东西是不是也有可能会聪明

17:27.230 --> 17:33.830
一模块少的话 无所谓 就是代码量小的时候呢 很多问题它不存在 一旦代码量到了一定级一边的时候

17:34.390 --> 17:42.430
就受不了了 这样的问题就必须要解决了 你看这样子是不是还是要聪明 对吧 这又是个全局编辖嘛 对吧 就很尴尬这个问题

17:42.990 --> 17:45.270
全局编辖污染没法解决不了

17:46.230 --> 17:51.910
另外一个呢 就是依赖关系混乱 这是个更更加牢火的问题了 这种问题呢你们肯定是没体会过

17:52.910 --> 17:56.990
如果你们以后了 将来也不太会有机会体会到了 因为这些问题都现在都解决了

17:58.030 --> 18:05.150
以前没解决 什么叫依赖关系混乱呢 就是说我们开发一个大型的项目的时候呢 由于前段代码比较多

18:05.670 --> 18:15.190
我们是不是要分成很多个文件 对吧 而且呢 我们可能还会用到一些第三方库 比方说接query啊 比方说nodex啊 比方说mockjess啊之类的 乱七八糟的一大堆第三方库

18:16.190 --> 18:25.270
那么有这么多的jess文件 谁依赖谁 这是个关系是非常麻烦的一个问题 那么比方说现在我们有100个jess文件

18:28.390 --> 18:33.750
分别为啊 分别为我们就讲什么啊 从f1到f100 100个jess文件

18:35.350 --> 18:42.310
那么这里边的依赖关系你理得清楚吗 你理不清楚啊 比方说啊 我比方随便举个例子啊 比方说

18:43.110 --> 18:49.910
f2呢 它要用到f1里边的东西啊 它依赖f1 那么就认为f2依赖f1

18:50.630 --> 19:01.750
然后呢 f5呢 它要依赖f2里边的东西 又要依赖f4里边的东西 比方说啊 就随便举个例子嘛啊 比方说呢f

19:02.150 --> 19:06.950
f100啊 f50 它要依赖啊依赖f6

19:07.670 --> 19:15.590
啊和f3里边的东西啊 f3呢 又要依赖f9里边的东西啊 比方说就随便举个例子

19:16.070 --> 19:22.710
那么这种复杂 文件一读 这种复杂的依赖关系把你搞得天荒乱坠啊 滚头就是就是

19:23.270 --> 19:24.950
要不也搞得就是特别特别痛苦

19:26.390 --> 19:33.830
那么这个问题呢会导致一个怎么结果呢 就是你在页面上去引用jess的时候 你搞不清楚哪个要先引用哪个要后引用

19:34.070 --> 19:42.150
你搞不清楚了啊 有的时候呢 两个模块还可能相互依赖啊 相互依赖 比如f2里边提供一些东西 f1里边要用

19:42.470 --> 19:46.950
f1里边提供东西 f2要用 那这个东西完全没办法了 就完全没办法了

19:47.590 --> 19:51.750
那像这些东西 就是循环依赖的问题 对吧 循环依赖的问题就完全没办法

19:52.550 --> 19:57.350
那么这个时候呢 你去在页面上引用jess 那么这个时候还得拆分把f2

19:57.670 --> 20:00.870
一带东西和f1里面的一带东西 可能还要拆分出去形成一个

20:01.350 --> 20:06.870
f0啊 等等等等 通过这些手段还能解决 就特别特别困难 解决这些依赖关系

20:07.110 --> 20:08.630
文件一多就会出现这样的问题

20:09.430 --> 20:15.110
那么这些问题呢 根本原因都是因为jess它没有模块化

20:16.070 --> 20:21.350
模块化就是专门来解决这种问题的 什么叫模块化 就是把不同的功能分到不同的文件

20:21.510 --> 20:26.390
并且呢 并且呢 文件之间形成一个良好的依赖关系 一个非常清晰的依赖关系

20:26.630 --> 20:29.350
并且呢 每一个模块里边它不会造成污染

20:29.830 --> 20:33.110
就我这个模块里边写的任何东西 你外面的模块都不能用

20:34.550 --> 20:39.670
不会造成污染 但是我希望你用的东西你可以用 就这么神奇啊 这就是模块化

20:40.630 --> 20:46.870
每一个语言 他要形成一个规模 能够做规模化的开发 他一定要有模块化 然后加碼语言

20:47.750 --> 20:50.550
有模块化 对吧 叫做什么 叫包 对不对

20:51.030 --> 20:55.350
sharp语言有模块化 对吧 叫做什么 动态链接库 对不对

20:55.830 --> 21:03.110
或者也可以叫做命名空间啊 弄动态链接库里边有命名空间 对吧 都有相应的方案 但是jess语言没有

21:04.070 --> 21:05.910
没有 他就会造成这样的问题

21:06.310 --> 21:10.470
那当然有些朋友说jess语言不是有命名空间吗 那是我们给他取的名字啊

21:11.110 --> 21:15.190
没有这种 你那个命名空间跟sharp的命名空间是两把刷 两把刷

21:17.350 --> 21:22.550
好 那么这是这三个原因啊 当然前面就是我们在第二阶段的时候呢

21:23.270 --> 21:26.630
至于他发展的是前两个原因 当然还有第三个原因

21:27.750 --> 21:35.430
那么这三个原因呢 就像阿卡流氏之中 对吧 致命的缺陷成为前端开发 规制补去的阴影和原罪

21:35.830 --> 21:40.790
大家都认为jess语言写不了大成绪 不就是这三个原因吗 还有啥其他原因

21:41.670 --> 21:46.790
那么这个时候呢 前端呢 他就处在一个非常尴尬的境地上

21:47.670 --> 21:52.790
就是说 我现在呢 有能力啊 我有理论上呢 我是能够进一步发展的

21:52.790 --> 21:56.950
因为我有了 阿卡流氏可以跟服务器端交互了 很多东西确实可以放到前端来做了

21:57.270 --> 22:00.630
但是呢 有于这三个原因 我又不能太大 这个规模又不能太大

22:01.190 --> 22:05.190
他就形成了一个非常非常尴尬的境地 就是很多时候呢 公司做决定

22:05.350 --> 22:08.230
这一块 我到底要放到后端开发 还要放到前端开发

22:08.630 --> 22:10.550
拿不准的时候怎么办 拿不准的时候放后端吧

22:11.750 --> 22:16.550
安全保险一点 就是有的时候呢 对前端总是束手束脚的这种感觉

22:18.070 --> 22:23.430
也就是为什么在这个阶段 他没有办法形成前后端分离模式 形成不了

22:23.590 --> 22:28.790
因为前端没有办法做太多的事情 什么叫前后端分离模式 就是现在大家看到的

22:28.950 --> 22:32.630
你们学的阿卡流氏 就是后端只给你提供什么 提供API

22:33.430 --> 22:37.670
啥都没有啊 啥都没有 什么东西都是前端来搞定 前端自己搞定

22:38.630 --> 22:44.310
什么勾件 页面啊 页面能够各种变化啊 终端 还要就是那个

22:44.550 --> 22:49.430
你要应用到手机端啊 应用到桌面应用程序啊 这些东西全部不管 后端全部不管

22:49.670 --> 22:52.550
后端跟界面没有任何关系 他就给你提供数据

22:53.190 --> 22:57.190
你请求这个地址 我给你拖数据 请求这个地址给我一些参数 我给你拖数据

22:57.270 --> 23:00.790
这就是后端要干的事情 这是现代啊 一千没有办法

23:01.430 --> 23:05.670
以前得干这么干吗 以前得要这样做的话 前端是不是要承担太多的事情了

23:06.310 --> 23:10.630
勾件页面都要让前端完成 就页面有哪些元素 这些元素怎么一个个打起来的

23:10.870 --> 23:13.830
这些元素怎么变化的 全部要前端完成 前端受不了

23:15.030 --> 23:22.950
前端受不了了 所以说以前呢 前端分离了很难实现 就是因为前端他不能承担太过于复杂的开发需求

23:23.190 --> 23:24.190
因为这些问题存在

23:25.350 --> 23:31.830
好 那么我们看一下第二阶段的大事件啊 首先呢我们刚才看到了啊 就是王继流烂期退出市场之后呢

23:32.550 --> 23:37.910
只剩下一个独秒了的啊 挨一个流烂期 制霸市场 制霸市场过后呢 微软干了一件非常

23:38.710 --> 23:43.030
牛逼的事情啊 他基本上基本上就是解除了整个流烂期的开发团队了

23:43.670 --> 23:48.550
因此呢 挨一流烂期的后面只是做一些简单的维护 基本上不再更新了啊 基本上不再更新了

23:48.790 --> 23:50.070
这也导致了流烂期

23:50.550 --> 23:54.150
流烂期的长期没有变化 当时呢微软内部都一直认为

23:54.470 --> 24:00.950
我们现在的挨一流流烂期啊 已经是最牛逼的流烂期了啊 不用再更新了啊 以后也不会有流烂期在发展了

24:01.110 --> 24:03.830
他们居然天真的这样认为啊 所以说

24:04.630 --> 24:11.350
流烂期的长期一直挺制不前 对这个前端的整个环境来说也是一直 肯定是不好的啊 也会 这也是

24:11.750 --> 24:14.630
一个间接的原因导致了前端一直挺制不前的原因

24:15.430 --> 24:18.870
然后呢 还有一个原因就是那个acma script的组织啊

24:19.430 --> 24:23.030
他是在1998年我记得啊 发布了这个es2.0版本

24:24.230 --> 24:28.950
然后呢 就一直没有新版本出来了啊 中间呢 他有一次呢 他在制定es4

24:29.350 --> 24:31.830
但是es4呢 由于里边有些东西呢

24:32.310 --> 24:37.910
没有经过就是严格的去论证 所以说呢 他最终还是没有发布啊 导致es4.0流产

24:38.230 --> 24:44.870
导致的这个界势语言的10年前既不是就是语言标准 语言层面的标准层面啊 就语言标准层面

24:45.110 --> 24:47.110
10年间呢 基本上是毫无变化

24:48.070 --> 24:49.750
啊 这也是导致了这段时间

24:50.870 --> 24:54.390
本来是有心往前走 前端 但是走不动啊 就这个原因

24:55.110 --> 25:00.630
然后呢 08年的时候 到时候发生的这样比较好的事 就是es5发布了

25:00.870 --> 25:05.990
es5发布呢 你看 是不是10年了 对吧 98年发布的es2.0

25:07.030 --> 25:12.790
啊 99年发布的3.0 我记得啊 好像是 99年发布的3.0 4.0流产嘛

25:13.030 --> 25:16.950
然后呢 2008年发布的是es5 那么这个es5呢

25:17.910 --> 25:19.830
你说他有多大变化呢

25:20.790 --> 25:23.670
谈不上 你说他没有变化呢 又解决了一些问题

25:23.670 --> 25:29.590
说说这个es5呢 虽然是一个很重要的版本啊 但是他仅解决了一些界势 api不足的问题

25:29.830 --> 25:36.230
比方说像什么数组里边 以前呢 没有什么一些 比方说什么feature的一些方法 map这一方法 对吧

25:36.550 --> 25:41.910
那么es5给他提供了啊 就解决了这些问题啊 以前没有什么es5的严格模式现在有了 对吧

25:42.310 --> 25:47.830
啊 就解决了这么一些问题啊 他没有解决一些语法层面的各种问题都还没有解决

25:48.070 --> 25:49.590
那是es6去解决的

25:50.710 --> 25:55.030
啊 这是第二阶段啊 前段处一个非常尴尬的地位 他有心发展发展不动

25:55.990 --> 25:59.430
好了 到了第三个阶段啊 终于我们可以看到一时曙光了

26:00.550 --> 26:03.110
我们时间呢 继续往前推移 到了08年

26:04.550 --> 26:10.390
谷歌呢 他的v8引擎发布 我们知道v8引擎呢 是一个ges直行引擎 我们的ges代码呢

26:10.390 --> 26:13.270
可以通过这个引擎 这个引擎可以直行我们写的ges代码

26:13.590 --> 26:14.870
他嵌入到浏览器里边

26:15.670 --> 26:19.510
这个引擎很厉害啊 你们听过诚哥的ges技术课程都知道对吧

26:20.230 --> 26:25.030
他是可以把ges直行速度推上了 推到什么 推到跟后端语言辟媒的程度了

26:25.830 --> 26:30.310
啊 我们一直认为ges语言他直行速度不快 是一个语言本身的问题

26:30.310 --> 26:35.270
因为他是个ges型语言 ges型语言他一定不如编译型语言直行的快 对吧

26:35.670 --> 26:40.710
哎 v8引擎颠覆掉了你的认知 你会发现这个v8引擎的存在

26:40.710 --> 26:45.430
可以把这个ges语言的直行速度跟编译型语言都可以辟媒了

26:46.230 --> 26:49.670
啊 因此呢 这个引擎的发布是一个震撼性的

26:49.990 --> 26:53.670
啊 是一个跨时来的发布 那么这一个引擎的发布呢

26:55.030 --> 27:02.150
也是间接或者说更加直接 更加直接的说就是直接导致了后边ges语言飞速发展啊

27:02.150 --> 27:05.190
一个就是有一个就是环境基础

27:06.310 --> 27:11.510
好 另外一件事就是摩尔定律大家都知道对吧 美国12个月到48个月

27:12.550 --> 27:15.190
咱们同样的一个成本上的芯片

27:16.070 --> 27:20.310
让它的元元期间的数量会翻倍啊 这摩尔定律

27:21.030 --> 27:26.230
摩尔定律呢 它的持续发酵导致呢 就是我们个人电脑的配置呢 开始飞略什么

27:26.230 --> 27:31.830
i3处理器 i5 i7对吧 一些跨时代的处理器都相继出现了

27:31.830 --> 27:34.710
那么而且呢 内存的价格越来越便宜啊 不过

27:35.590 --> 27:39.910
去年啊 还有什么原因啊 我不知道 内存价格也突然短时间的涨了一波

27:40.550 --> 27:44.950
就整体上啊 不从时间的 整体上来看 我们会发现了内存的

27:45.910 --> 27:47.750
价格呢 会越来越 就是越来越便宜

27:48.470 --> 27:52.630
那么个人电脑的配置开始飞略 于是呢 前两个问题是不是就解决了

27:53.510 --> 27:57.270
介绍执行输入贪漫的问题和用户端电脑配置不足的问题是不是就解决了

27:58.150 --> 28:00.070
那么现在的就 就是

28:00.870 --> 28:05.590
横在前端和规模化开发之间的就剩下一个东西了

28:06.150 --> 28:08.150
就剩下一堵墙了 就什么墙呢

28:08.790 --> 28:12.230
就是全局变量污染和依赖混乱的问题 就我们刚才讲的

28:12.950 --> 28:17.830
你写代码写多了 会导致这些变量有重复 全局变量有重复

28:18.230 --> 28:20.870
那么代码写多了 文件多了 一代关系怎么来处理

28:21.830 --> 28:25.830
就剩下这个问题了 只要你把这个问题解决了 前端跟

28:26.150 --> 28:30.310
到了那个规模化开发之间就没有任何障碍了 就可以直接往前走了

28:33.350 --> 28:38.070
所以说呢 我们现在呢 到了第三阶段 由于这两个问题的解决

28:39.030 --> 28:41.030
我们只需要解决这个问题就行了

28:41.510 --> 28:46.230
而这个问题怎么解决了 那么就是要依托于前端模化化

28:46.550 --> 28:49.750
而这个问题我们刚才说了 就是模化化 模化化就是在解决这个问题的

28:49.990 --> 28:52.230
把不同的功能写到不同的文件形成一个个模块

28:52.550 --> 28:57.270
模块之间呢 内部的东西呢 外面是用不了的 还不会造成污染

28:57.830 --> 29:01.670
而且模块有模块之间 他们的关系呢是非常明确的

29:02.390 --> 29:04.390
这就是模化化要解决的事情

29:05.110 --> 29:10.390
所以说我们现在最后一个问题就是 只要有了模块化 前端就可以飞出了发展了

29:11.430 --> 29:14.950
那么这个时候呢 很多的前端开发者呢 就在设计中开始讨论了啊

29:15.190 --> 29:19.990
开始想办法 怎么来把模块化引入到前端里边去

29:20.790 --> 29:27.830
那么这个时候呢 发生了一件事 就是08年呢 有个小伙啊 这个词叫rander就怎么多啊

29:28.150 --> 29:28.950
就这个小伙子啊

29:29.910 --> 29:31.670
把他叫rand

29:32.230 --> 29:34.870
这个小伙子呢 他正在为一件事的交存案而

29:35.350 --> 29:37.670
他要做啥呢 他们公司呢 他是要

29:37.910 --> 29:39.910
他们公司呢 是在做一个微博服务器的公司

29:41.030 --> 29:47.350
啊 别写微博服务器 什么叫微博服务器呢 我给他简单解释一下嘛 因为你们现在呢 还没有学习后端啊 这是后端的东西

29:47.830 --> 29:52.790
就说我们平时请求服务器 对吧 你看我们比方写个地址啊 我们请求服务器

29:55.240 --> 29:58.760
啊 这个地址 比方说我们写到新端嘛 新端一个服务器

30:00.950 --> 30:06.630
我们这里一个端口啊 端口 比方说80啊 我们知道默认端口就是80 对吧 你不写端口的话 就是80端口

30:07.110 --> 30:08.150
好 然后呢

30:09.190 --> 30:14.470
呃 请求新浪的新闻啊 比方说我们请求这个地址啊 随便下去个地址

30:14.950 --> 30:19.990
那么这个请求会发送到哪儿去 所以发送到新浪的服务器 是不是会收到这个请求

30:20.470 --> 30:22.230
对吧 好 新浪的服务器

30:23.750 --> 30:25.270
服务器会收到请求

30:26.230 --> 30:30.310
为什么是新浪不是百度的服务器呢 因为你前面通过域名来限制的 对吧

30:30.630 --> 30:33.830
这个请求它只会到达新浪的对应服务器 它会收到这个请求

30:34.310 --> 30:38.630
啊 当然这个收到请求的过程是非常非常复杂的啊 我们简单来说一下说一下就行了

30:39.190 --> 30:41.270
我们简单解释一下什么叫为补服务器就行了

30:41.750 --> 30:48.550
那么服务 新浪的服务器你可以想象的是什么呢 就是一台电脑啊 只不过呢 跟我们电脑长得不太一样啊 他只有一个主机没有解释器

30:48.790 --> 30:53.430
而且那个主机呢 跟我们平时看到的电脑主机箱啊 也不太一样啊 我们

30:53.670 --> 30:57.430
就可以把 但是可以把它理解为就是一台电脑啊 新浪服务器的

30:57.750 --> 30:59.510
新浪的服务器就是台电脑啊

31:00.150 --> 31:01.110
它收到这个请求

31:01.750 --> 31:04.950
那么这个电脑上是不是要可以运行很多程序 对吧

31:05.430 --> 31:08.470
电脑上可以运行啥 是不是可以运行浏览器 是个程序吗

31:08.870 --> 31:14.150
可以运行什么微信 是个程序吗 可以运行QQ 是不是个程序吗 当然服务器上一般不会

31:14.390 --> 31:18.710
能不能运行这个 肯定是可以的啊 只不过服务器它一般不运行这些东西 运行这些干嘛的

31:19.270 --> 31:23.750
服务器是未来处理请求的 一般是来处理请求的

31:23.990 --> 31:28.790
但是它是一台电脑 那么这台电脑上是不是可以安装各种各样的应用程序

31:29.430 --> 31:32.470
其中有一个应用程序 他在干这么一件事

31:33.590 --> 31:35.430
有一个应用程序

31:36.390 --> 31:38.790
他干什么事呢 他在不断的监听

31:40.950 --> 31:44.310
在做以下的事情

31:45.430 --> 31:48.310
那么他做什么事情呢 第一个事情 他在不断的监听

31:48.950 --> 31:50.470
监听什么 8年端口

31:51.030 --> 31:54.630
就是说你请求到了我这个服务器 我这个服务器呢 可以监听各种各样的端口

31:55.510 --> 31:58.390
我其中一个端口呢 我们是8年 对吧 你请求的是8年

31:58.390 --> 32:01.270
那么我在不停的监听8年端口 你这里写的是8年

32:01.830 --> 32:05.430
那么是不是被这个应用程序截获到了 对吧 如果你写的是800

32:05.910 --> 32:09.110
我这个应用程序 他又没有监听800端口 那么我就截获不到

32:09.590 --> 32:12.470
所以说 他是服务器有一个相应的程序 在不断的听

32:12.710 --> 32:14.470
有没有人来啦 有没有人来敲门

32:15.590 --> 32:17.830
如果发现有人来敲门 然后将

32:19.670 --> 32:25.830
将请求进行分析 各种分析处理 那么具体的分析方式

32:25.830 --> 32:29.430
具体的分析方式呢 我们就不再做详细调讨论了

32:29.910 --> 32:34.870
然后将分析的结果 将分析的结果交给

32:36.470 --> 32:41.270
交给相应的程序进行处理

32:42.230 --> 32:45.270
分析出来的有些结果 有些数据分析出来的 比方说吧

32:45.510 --> 32:47.990
分析出来的处理的路径是这个路径

32:49.830 --> 32:54.630
我这里呢 把这个路径解析出来 我们可能会交给PHP程序来处理

32:54.630 --> 32:56.550
又可能会交给加把程序来处理

32:57.510 --> 33:00.790
输不准 管他怎么分析的 总是他进行分析

33:00.790 --> 33:03.430
分析的结果他会交给相应的程序来进行处理

33:03.910 --> 33:06.070
那么这个相应的程序可能是一个PHP

33:07.190 --> 33:11.910
可能是加把来进行处理

33:12.870 --> 33:23.110
然后把这些程序处理的结果返还给客户端

33:23.110 --> 33:27.510
就是加把程序或者是PHP程序 他处理完了 处理完了总有一个结果吧

33:27.510 --> 33:29.110
那么交给客户端

33:29.110 --> 33:30.710
那么这个程序再做这么一件事

33:30.710 --> 33:32.550
那么这个程序叫什么呢?

33:32.550 --> 33:33.990
这个程序就叫Web服务器

33:35.990 --> 33:40.310
所以说你Web服务了 我们可以简单的把它称之为Web服务

33:40.710 --> 33:41.750
互联网服务

33:41.750 --> 33:47.670
那么这个东西相当于是连接请求和具体的处理程序之间的一个桥量

33:47.670 --> 33:50.390
你请求的是谁交给谁的 交给他的

33:50.390 --> 33:56.310
他做了一些处理之后 比如说一些安全验证 权限验证之类的东西

33:56.310 --> 34:02.150
做了一些处理之后把这个请求交给相应的就是代码来进行处理

34:02.150 --> 34:07.750
那么我们平时说开发服务器 实际上是在这一步 开发的是这个东西

34:07.830 --> 34:11.030
我们用夹法开发一个程序 用PACP开发一个程序

34:11.030 --> 34:13.670
把它安装到相应的Web服务上

34:13.670 --> 34:17.350
然后Web服务也受到请求过后 把它交给这些程序来处理

34:17.350 --> 34:21.510
相当于是我们说服务器开发是在做这么一些事 对吧

34:21.510 --> 34:23.190
而这个家伙呢 他在干嘛呢?

34:23.190 --> 34:26.550
这个家伙是在开发Web服务器 他在开发这么一个东西

34:26.550 --> 34:29.110
他在开发这么一个东西

34:29.110 --> 34:31.350
但是呢 他为什么要自己写呢?

34:31.350 --> 34:33.830
因为当时呢 实际上市面上是有一些很沉

34:33.830 --> 34:36.950
非常非常成熟的Web服务器的

34:37.030 --> 34:39.670
比方说什么微软的IS

34:39.670 --> 34:44.310
或者是家伙里边的Web服务器Tomcat 对吧

34:44.310 --> 34:46.470
都有一些比较成熟的Web服务器了

34:46.470 --> 34:49.110
他为什么还要自己去写一个Web服务呢?

34:49.110 --> 34:51.590
他为什么要去写这么一个程序呢?

34:51.590 --> 34:54.070
是因为他呢 他有一个需求就是

34:54.070 --> 35:00.550
他的手写的 他需要有搭建一个高性能的Web服务

35:00.550 --> 35:03.110
性能要求非常非常高

35:03.110 --> 35:04.550
实际上呢 他们当时来做一件事呢

35:04.950 --> 35:09.910
不断的要进行 就是那个跟磁盘之间进行读取

35:09.910 --> 35:12.310
因为知道读磁盘是比较慢的 对吧

35:12.310 --> 35:17.030
读磁盘 因为磁盘运转速度肯定是没有内存快的

35:17.030 --> 35:19.670
我们把读磁盘叫做IO

35:19.670 --> 35:23.590
他有很高的 就是对IO的读写操作有很高的性能要求

35:23.590 --> 35:26.710
那么一般的Web服务器达不到这样的性能要求

35:26.710 --> 35:29.350
满足不了 所以说他必须要自己写

35:29.350 --> 35:31.190
那么他通过他的分析呢

35:31.190 --> 35:33.430
如果说你要实现高性能

35:33.510 --> 35:36.630
那么有一个条件就是 想来想去只有这么一个办法

35:36.630 --> 35:38.150
就是减少现成

35:38.150 --> 35:40.070
我们知道每一个应用程序打开之后呢

35:40.070 --> 35:41.830
他就会读建一个进程 对吧

35:41.830 --> 35:42.310
进程在这儿

35:44.470 --> 35:45.270
我们看一下 对吧

35:45.270 --> 35:47.110
这些东西都是进程 对吧

35:47.110 --> 35:48.470
都是进程

35:48.470 --> 35:50.470
那么他需要搭建每个应用程序呢

35:50.470 --> 35:51.830
他都会占用一个进程

35:52.950 --> 35:54.070
每个进程里边呢

35:54.070 --> 35:55.110
就是每个应用程序里边

35:55.110 --> 35:56.710
他有很多事情要做

35:56.710 --> 35:57.550
很多事情要做

35:57.550 --> 35:58.990
比方那个浏览器里边

35:58.990 --> 36:00.230
浏览器里边有些事情要做

36:00.230 --> 36:01.750
要确然一面吗

36:01.830 --> 36:03.350
要执行GS吧

36:03.350 --> 36:04.510
比方说你启动计时器

36:04.510 --> 36:05.790
是不是要有一个计时器现成的

36:05.790 --> 36:07.110
要去启动计时器

36:07.110 --> 36:09.710
如果说你听过我之前讲ES6的

36:09.710 --> 36:11.790
那个关于事件驱动的话

36:11.790 --> 36:12.790
事件循环的话

36:12.790 --> 36:15.230
就知道浏览器里边实际上有很多现成的

36:15.230 --> 36:16.390
每个现成要管一件事

36:16.390 --> 36:17.830
他们可以同时进行

36:17.830 --> 36:19.870
同时使用计算仪式支援

36:21.070 --> 36:22.670
那么为什么说要实现高性能

36:22.670 --> 36:23.950
必须要减少现成的

36:23.950 --> 36:24.950
不是说一定

36:26.190 --> 36:28.430
不是说完全把现成减少到一

36:28.430 --> 36:29.110
不是这个意思

36:29.110 --> 36:30.950
只是尽量减少

36:30.950 --> 36:32.390
为什么说要减少现成

36:32.390 --> 36:34.070
因为现成它本身

36:34.070 --> 36:36.870
增加一个额外的现成会带来开销

36:36.870 --> 36:39.350
而且在现成与现成之间切换

36:39.350 --> 36:41.470
也会带来高额的开销

36:41.470 --> 36:43.430
而且现成一多了

36:43.430 --> 36:45.830
它为了避免不同的现成

36:45.830 --> 36:46.990
使用同一块资源

36:48.990 --> 36:50.710
为了避免这种情况

36:50.710 --> 36:52.750
它要给一些资源的家属

36:52.750 --> 36:54.030
这又会带来开销

36:54.030 --> 36:55.430
这东西你听不懂没关系

36:55.430 --> 36:56.430
你总之就知道

36:56.430 --> 36:56.950
现成多了

36:56.950 --> 36:58.510
它一定会带来更高的开销

36:59.510 --> 37:00.990
那么这种情况下

37:00.990 --> 37:02.430
如果说你要实现高性能的话

37:02.430 --> 37:04.070
就必须要减少现成

37:04.070 --> 37:06.070
那要减少现成的话

37:06.070 --> 37:09.070
目前有一种成熟的处理方案

37:09.070 --> 37:11.070
就是用异布

37:11.070 --> 37:12.430
比方说我就一个现成

37:12.430 --> 37:14.310
你们知道介石

37:14.310 --> 37:16.430
介石语言是运行在单现成上面的

37:16.430 --> 37:16.910
对吧

37:16.910 --> 37:19.070
不过现在ATM5出来之后了

37:19.070 --> 37:20.070
API出来之后了

37:20.070 --> 37:22.070
它也可以在多个现成里面运行的

37:22.070 --> 37:23.630
只不过我们平常的传统的介石

37:23.630 --> 37:25.510
是运行在单现成上面的

37:25.510 --> 37:26.870
因此就相当于是一个饭店

37:26.870 --> 37:28.230
只有一个服务员

37:28.390 --> 37:29.510
当他需要等的时候

37:29.510 --> 37:30.270
他就不等了

37:30.270 --> 37:31.670
他就去做其他事情

37:31.670 --> 37:32.630
当那边做完了过后

37:32.630 --> 37:33.950
比方说来的一个客人

37:33.950 --> 37:35.390
我要

37:35.390 --> 37:36.830
我们就用这个解释

37:36.830 --> 37:37.750
什么叫多现成

37:37.750 --> 37:39.510
多现成就是一个饭店

37:39.510 --> 37:40.750
一个餐馆

37:40.750 --> 37:42.030
他有多个服务员

37:42.030 --> 37:44.710
每个服务员就盯着他自己的桌子

37:44.710 --> 37:46.870
就服务那一桌的客人就行了

37:46.870 --> 37:49.310
没事的时候他就来点闲着

37:49.310 --> 37:51.270
那么这个是不是有效率的浪费

37:51.270 --> 37:51.470
对吧

37:51.470 --> 37:53.470
有些服务员确实没事

37:53.470 --> 37:54.670
他就闲着

37:54.670 --> 37:57.310
那什么叫单一现成的异布处理方案呢

37:57.310 --> 38:00.750
比方说我这个饭店我只请一个服务员

38:00.750 --> 38:01.510
他忙个钥匙

38:01.510 --> 38:03.750
但是他是保和型工作

38:03.750 --> 38:05.310
比方来了一个客人

38:05.310 --> 38:06.270
我不用等

38:06.270 --> 38:08.070
我先给你指向你那里去做

38:08.070 --> 38:09.670
然后马上去忙别的事情

38:09.670 --> 38:10.550
好等你做下过后

38:10.550 --> 38:12.190
我马上过来问你

38:12.190 --> 38:13.150
你需要点什么

38:13.150 --> 38:13.910
他就来点

38:13.910 --> 38:14.790
点了菜过后

38:14.790 --> 38:16.150
我马上把这个菜交给厨房

38:16.150 --> 38:17.350
我又去忙别的事情

38:17.350 --> 38:19.310
就接在其他的客人

38:19.310 --> 38:19.670
好

38:19.670 --> 38:21.510
那么当厨房把这个东西做完了之后

38:21.510 --> 38:22.870
我马上把这个东西

38:22.870 --> 38:25.150
把这个菜端给这个相应的客人

38:25.150 --> 38:25.430
对吧

38:25.430 --> 38:26.950
就是一个人在那里忙

38:26.950 --> 38:28.270
这是异布的解决方案

38:28.270 --> 38:30.870
就是我不用去守着一件事做完

38:30.870 --> 38:32.310
我完全可以做别的事

38:32.310 --> 38:34.030
等他等那件事发生了

38:34.030 --> 38:36.190
到某一个阶段的时候

38:36.190 --> 38:37.270
我通过回调

38:37.270 --> 38:39.110
通过什么样的方式等等

38:39.110 --> 38:41.270
我们就可以来进一步处理

38:41.270 --> 38:43.430
就比方说我们在节点室里边

38:43.430 --> 38:44.630
不是写这个东西吗

38:44.630 --> 38:45.190
经常写的

38:45.190 --> 38:45.590
对吧

38:45.590 --> 38:47.510
是Timeout

38:47.510 --> 38:50.950
这就是一个典型的异布场景

38:50.950 --> 38:53.910
我等一秒钟去做一件事

38:53.910 --> 38:55.350
比方说我们输出一个东西

38:55.350 --> 38:57.110
等一秒钟去输出

38:57.110 --> 38:59.870
那既然是执行引擎

38:59.870 --> 39:02.030
是在这里啥等吗

39:02.030 --> 39:02.950
是在这里啥等吗

39:02.950 --> 39:04.510
肯定不是

39:04.510 --> 39:05.470
他就通知一下

39:05.470 --> 39:07.710
既然是刘烂琴内部的现成

39:07.710 --> 39:08.790
你去够计时

39:08.790 --> 39:09.830
寄一秒钟

39:09.830 --> 39:10.990
到了时间通知我

39:10.990 --> 39:12.670
我马上就忙别的事情去了

39:12.670 --> 39:15.070
所以说后边的代码是不是一次执行

39:15.070 --> 39:17.270
后面不会主色

39:17.270 --> 39:18.830
他不会等着这里完成

39:18.830 --> 39:20.710
然后才去做后面的事情

39:20.710 --> 39:21.510
后面不会主色

39:21.510 --> 39:23.350
继续往后做事

39:23.350 --> 39:25.030
当到达一秒钟之后

39:25.150 --> 39:26.510
到了一秒钟之后

39:26.510 --> 39:28.710
那边计时的现成会通知我

39:28.710 --> 39:29.590
通知我过后

39:29.590 --> 39:30.870
我这个执行引擎

39:30.870 --> 39:33.430
我这个执行现成

39:33.430 --> 39:35.870
那么才转过头来去执行这个函数

39:35.870 --> 39:37.150
所以我们平时说的是什么

39:37.150 --> 39:41.150
GS是一个单线程的语言

39:41.150 --> 39:44.350
指的是GS的执行现成是单线程的

39:44.350 --> 39:46.670
不代表这个刘烂琴里边是单线程的

39:46.670 --> 39:48.310
不代表刘烂琴是单线程的

39:48.310 --> 39:52.710
他指的是执行语言的现成是单线程的

39:52.710 --> 39:54.710
只不过现在ATM5出来之后

39:54.750 --> 39:55.990
也可以把执行现成的

39:55.990 --> 39:57.830
都再去讲而外的现成了

39:57.830 --> 39:58.550
也可以的

40:00.270 --> 40:02.350
总之我们要实现高性能的话

40:02.350 --> 40:05.150
那么异布是一种非常非常好的处理方案

40:05.150 --> 40:07.390
这是所有都不能达成共识的

40:08.750 --> 40:09.590
那么这个时候

40:10.350 --> 40:11.390
这个小伙子

40:11.390 --> 40:12.390
那么他就打算

40:12.390 --> 40:15.950
自己用语言和涉压加来编写这个微博服务

40:15.950 --> 40:20.550
来实现一个就是异布的处理方案

40:20.550 --> 40:22.910
用一个异布的处理方案来管理微博服务

40:22.950 --> 40:25.150
但是这个过程实在是太痛苦了

40:25.150 --> 40:26.630
因为他相当于是从头到尾

40:26.630 --> 40:28.710
勾件一个别人都没有勾件出来的东西

40:28.710 --> 40:29.870
然后全部重新写一遍

40:29.870 --> 40:30.430
那个微博服务

40:30.430 --> 40:31.110
太痛苦了

40:32.110 --> 40:34.110
就在他一层末端的时候

40:34.110 --> 40:35.910
那么谷歌的微博引擎发布

40:35.910 --> 40:36.670
引擎他的注意

40:37.910 --> 40:38.950
他突然发现

40:38.950 --> 40:42.670
我这个GS不就是最好的微博服务语言吗

40:42.670 --> 40:45.110
我就用GS来写这个微博服务步行吗

40:45.110 --> 40:45.750
因为为什么呢

40:45.750 --> 40:47.110
因为GS执行引擎

40:47.110 --> 40:48.950
他单线程就是单线程的

40:48.950 --> 40:50.270
并且是基于异布的

40:50.270 --> 40:51.510
是不是完美的解决了

40:51.510 --> 40:52.390
对吧

40:52.390 --> 40:54.310
但是GS有个问题就是

40:54.310 --> 40:56.150
他以前的执行引擎不好

40:56.150 --> 40:58.790
导致了GS的运行速度太慢了

40:58.790 --> 41:00.470
但是现在有了微博

41:00.470 --> 41:02.790
微博就解决了执行速度的问题

41:02.790 --> 41:04.230
而且我是服务器环境

41:04.230 --> 41:05.750
服务器环境根本就不用考虑

41:05.750 --> 41:07.190
什么刻骨断配置的问题了

41:07.190 --> 41:07.550
服务器

41:07.550 --> 41:08.790
我就你按用什么配置

41:08.790 --> 41:09.630
你自己去配对吧

41:09.630 --> 41:11.390
花花钱多少的问题

41:11.390 --> 41:12.670
所以说呢

41:12.670 --> 41:15.350
而且这个微博引擎是谷歌公司发布的

41:15.350 --> 41:15.910
对吧

41:15.910 --> 41:17.750
谷歌公司是一个相技术质利

41:17.750 --> 41:18.990
相当雄厚的公司

41:18.990 --> 41:21.430
而且谷歌公司非常重视这个微博

41:21.470 --> 41:25.110
它后期一定会不断的优化微博引擎

41:25.110 --> 41:26.790
所以说GS的执行速度会越来越快

41:26.790 --> 41:28.150
越来越快

41:28.150 --> 41:29.750
而且它就自己不用优化了

41:29.750 --> 41:30.470
就是服务器

41:30.470 --> 41:32.510
就是我如果说我解个服务器

41:32.510 --> 41:33.910
微博服务

41:33.910 --> 41:35.150
我就用解释比安心

41:35.150 --> 41:37.110
搭载一个微博引擎去执行

41:37.110 --> 41:38.390
那么这样子一来了

41:38.390 --> 41:39.310
我后边说

41:39.310 --> 41:41.670
我又不用去维护这个服务器了

41:41.670 --> 41:43.710
或者说很少去维护它

41:43.710 --> 41:46.270
只要谷歌优化了微博

41:46.270 --> 41:49.550
我换一个马上把这个优化换过来就行了

41:49.550 --> 41:51.310
而且微博引擎是开源的

41:51.350 --> 41:52.350
我想改地别的代码

41:52.350 --> 41:53.030
我改动一下

41:53.030 --> 41:54.750
有些不太满足我的需要

41:54.750 --> 41:56.150
我稍微改一下就行了

41:56.150 --> 41:57.110
不是又省钱

41:57.110 --> 41:57.670
又省利的

41:57.670 --> 41:58.430
有这种好事

41:58.430 --> 42:00.030
我干嘛要去自己一些的

42:00.030 --> 42:02.110
所以说它就直接

42:02.110 --> 42:03.990
它经过的反复的论证之后

42:03.990 --> 42:05.190
觉得这个可行

42:05.190 --> 42:08.230
于是它就基于开源的违法引擎

42:08.230 --> 42:10.110
把原代码稍微做了一些改动

42:10.110 --> 42:14.550
变快速的完成了整个微博服务项目

42:14.550 --> 42:17.350
于是它在2009年的时候

42:17.350 --> 42:19.750
其实只用了半年不到的时间

42:19.750 --> 42:21.190
它就推出了这个项目

42:21.230 --> 42:22.670
把它命名为漏的解释

42:22.670 --> 42:24.630
这种漏的解释在单身

42:24.630 --> 42:26.110
漏的解释实际上是什么

42:26.110 --> 42:27.670
实际上你可以认为

42:27.670 --> 42:29.710
它就是一个微博服务

42:29.710 --> 42:31.510
你可以认为它其实本质

42:31.510 --> 42:32.910
你可以把它看错次

42:32.910 --> 42:35.950
就是可以提供微博服务的这么一个东西

42:35.950 --> 42:36.790
那么它可以运行什么

42:36.790 --> 42:38.270
它可以运行解释

42:38.270 --> 42:40.910
因为它内部搭载了一个微博引擎

42:40.910 --> 42:43.110
所以它可以运行解释语言

42:43.110 --> 42:45.190
从此以后不得了了

42:45.190 --> 42:50.510
解释语言第一次堂堂正正的入住后端

42:50.510 --> 42:52.470
以前的解释语言全是在浏览器里面

42:52.470 --> 42:55.390
我们以前一直认为解释这个玩意

42:55.390 --> 42:56.590
不就是个玩具语言吗

42:56.590 --> 42:57.190
对吧

42:57.190 --> 42:58.390
它的权限很少

42:58.390 --> 42:59.830
因为浏览器该先制的

42:59.830 --> 43:00.630
这样不能做

43:00.630 --> 43:01.390
内样不能做

43:01.390 --> 43:01.830
对吧

43:01.830 --> 43:04.110
并不是这个语言本身的原罪

43:04.110 --> 43:05.790
这个语言本身是没问题的

43:05.790 --> 43:08.270
只是浏览器没有给它提供API

43:08.270 --> 43:09.310
它不让它做这个

43:09.310 --> 43:10.070
不让它做那个

43:10.070 --> 43:10.270
对吧

43:10.270 --> 43:12.710
因为它要保护用户的隐私

43:12.710 --> 43:14.150
比方说读取文件

43:14.150 --> 43:14.750
它不能做

43:14.750 --> 43:16.510
并不是这个语言本身的问题

43:16.510 --> 43:18.190
是浏览器该先制的

43:18.190 --> 43:19.990
但是这个语言你会发现

43:19.990 --> 43:22.270
它现在入住后端过后啥都能做了

43:22.270 --> 43:23.070
加碼能做的事情

43:23.070 --> 43:24.510
它都能做

43:24.510 --> 43:27.470
它可以调用各种底层的东西都可以调用

43:27.470 --> 43:28.510
什么读文件

43:28.510 --> 43:31.190
读文件那种随便用

43:31.190 --> 43:35.910
于是解释语言不再是一个玩具语言了

43:35.910 --> 43:38.750
它不再是只能附属于浏览器的

43:38.750 --> 43:40.390
它现在已经从实现上

43:40.390 --> 43:41.830
都已经进入了后端了

43:41.830 --> 43:42.550
对吧

43:42.550 --> 43:44.870
就进入了服务器了

43:44.870 --> 43:46.630
也是从此刻开始

43:46.630 --> 43:47.710
人们认识到

43:47.790 --> 43:48.910
这个GS

43:48.910 --> 43:50.350
我们把乘习惯了

43:50.350 --> 43:51.070
乘GS对吧

43:51.070 --> 43:53.070
其实标准一点说法是ES

43:53.070 --> 43:53.950
语言标准

43:53.950 --> 43:54.910
这个语言

43:54.910 --> 43:56.350
它是一个真正的语言了

43:56.350 --> 43:58.310
它不依附于任何东西

43:58.310 --> 44:00.390
它只要在

44:00.390 --> 44:02.230
给它提供一个运行环境

44:02.230 --> 44:03.670
我们把它叫做运行时

44:03.670 --> 44:05.470
装探或者是要输出程序

44:05.470 --> 44:07.110
那么它只要给它提供一个环境

44:07.110 --> 44:08.830
这个环境里面有个引擎可以执行

44:08.830 --> 44:10.590
那它就可以执行

44:10.590 --> 44:12.070
下面我给它画了两张图

44:12.070 --> 44:13.630
大家看一下

44:13.630 --> 44:15.910
这个图对你理解这个GS语言

44:15.910 --> 44:17.550
本身是很重要的

44:17.590 --> 44:20.110
已经浏览器和路德解释的关系

44:20.110 --> 44:22.110
我们要运行的程序最底层

44:22.110 --> 44:24.310
最终肯定是要交给机转机硬件的

44:24.310 --> 44:26.110
比方说CPU

44:26.110 --> 44:26.510
立存

44:26.510 --> 44:26.750
对吧

44:26.750 --> 44:29.150
要把这些指令交给机转机硬件

44:29.150 --> 44:30.750
是谁把这些指令交给它的

44:30.750 --> 44:32.190
是操作系统

44:32.190 --> 44:33.150
操作系统在

44:33.150 --> 44:34.590
比方说我们Windows的操作系统也好

44:34.590 --> 44:35.910
Linux的操作系统也好

44:35.910 --> 44:37.230
总之有个操作系统

44:37.230 --> 44:40.390
操作系统在管理硬件

44:40.390 --> 44:42.190
你不能直接跟硬件打交道

44:42.190 --> 44:45.070
只有操作系统才可以直接管理硬件

44:45.070 --> 44:46.110
那么操作系统

44:46.190 --> 44:47.550
它又给你提供了一些的API

44:47.550 --> 44:48.710
比方API怎么理解

44:48.710 --> 44:49.870
你可以理解过一些方法

44:49.870 --> 44:52.910
一些函数或者是一些对象之类的东西

44:52.910 --> 44:54.790
它给你提供了一些函数和对象

44:54.790 --> 44:57.230
那么你可以控制操作系统的行为

44:57.230 --> 44:59.830
比方说我要打开一个文件夹

44:59.830 --> 45:02.710
我要删除一个文件等等

45:02.710 --> 45:03.870
这些是操作系统

45:03.870 --> 45:05.070
比方说我打开一个窗口

45:05.070 --> 45:05.510
对吧

45:05.510 --> 45:08.430
我要获取一个窗口里边的进程ID等等

45:08.430 --> 45:11.150
这些操作系统里边给你提供的一些方法

45:11.150 --> 45:13.990
或者是对象给你提供出来

45:13.990 --> 45:16.110
那么我们上面就是应用程序了

45:16.110 --> 45:17.710
操作系统上面就是应用程序

45:17.710 --> 45:20.870
比方说我们的流烂器就是一个应用程序

45:20.870 --> 45:21.990
每个应用程序的操作系统

45:21.990 --> 45:23.030
会给它分配一个进程

45:23.030 --> 45:24.750
让它进行给它一堆的支援

45:24.750 --> 45:28.190
内存支援和CPU支援让它去运行

45:28.190 --> 45:30.030
那么这些应用程序

45:30.030 --> 45:31.750
比方说我们这里以流烂器为例

45:31.750 --> 45:32.990
流烂器就是一个应用程序

45:32.990 --> 45:33.710
你们要安装的

45:33.710 --> 45:34.070
对吧

45:34.070 --> 45:34.790
比方说谷歌流烂器

45:34.790 --> 45:36.430
你们是不是要下载安装

45:36.430 --> 45:36.710
对吧

45:36.710 --> 45:38.310
这些都是应用程序

45:38.310 --> 45:39.430
那么在流烂器里边

45:39.430 --> 45:41.070
我们以谷歌流烂器为例

45:41.110 --> 45:42.190
在流烂器里边

45:42.190 --> 45:44.150
它的应用程序里边搭载了哪些东西呢

45:44.150 --> 45:46.390
一个是当然它里边有很多东西

45:46.390 --> 45:47.190
其中有两个

45:47.190 --> 45:48.630
一个是V8引擎

45:49.830 --> 45:50.630
V8引擎干嘛的

45:51.830 --> 45:53.030
是否执行GS代码的

45:53.550 --> 45:53.830
对吧

45:54.870 --> 45:55.190
好

45:55.190 --> 45:55.710
还有个什么

45:55.710 --> 45:56.790
还有一个Web API

45:56.790 --> 45:59.510
Web API就是流烂器内部给提供的

45:59.510 --> 46:00.150
有GS

46:00.790 --> 46:02.190
就是比方说像什么

46:02.190 --> 46:02.550
像这个

46:03.630 --> 46:04.990
像什么在Timeout这个函数

46:04.990 --> 46:06.510
就是Web API里边的东西

46:06.510 --> 46:07.310
提供一些接口

46:07.310 --> 46:09.870
可以被GS应用程序调用的

46:09.870 --> 46:11.670
比方说什么阿加克斯里边的什么

46:12.950 --> 46:13.590
XML

46:13.590 --> 46:15.470
ATDP

46:15.470 --> 46:15.990
REQUEST

46:15.990 --> 46:16.390
对吧

46:16.390 --> 46:17.910
这么一个构造函数

46:17.910 --> 46:20.670
这构造函数也是Web API给它提供的

46:20.870 --> 46:21.270
对吧

46:21.870 --> 46:24.150
有了V8引擎有了Web API

46:24.150 --> 46:24.990
我们可以在干嘛

46:24.990 --> 46:27.470
我们就可以写GS语言

46:27.470 --> 46:28.910
把这个GS语言交给谁

46:28.910 --> 46:30.310
交给流烂器

46:30.310 --> 46:33.630
流烂器的V8引擎就可以把我们的GS语言

46:33.630 --> 46:35.110
转换成为

46:35.110 --> 46:36.430
比方说底层代码

46:36.430 --> 46:38.910
比方说操作系统可以执行的代码

46:38.910 --> 46:39.390
对吧

46:39.590 --> 46:41.270
然后可以执行的代码

46:41.270 --> 46:43.310
然后把我们里边使用了什么

46:43.310 --> 46:44.590
诸如SET

46:44.590 --> 46:45.790
Timeout

46:45.790 --> 46:47.470
什么ATMXML

46:47.470 --> 46:48.030
ATDP

46:48.030 --> 46:49.110
REQUEST这些东西

46:49.110 --> 46:50.070
对吧

46:50.070 --> 46:51.150
交给Web API

46:51.150 --> 46:53.790
那么它也会把它翻译成相应的

46:53.790 --> 46:56.990
相应的就是操作系统指令

46:56.990 --> 46:59.390
那么把这些指令再交给操作系统

46:59.390 --> 47:01.910
操作系统的交给那个技能硬件

47:01.910 --> 47:03.830
然后硬件给它一个操作系统一个结果

47:03.830 --> 47:05.030
操作系统给流烂器个结果

47:05.030 --> 47:06.350
流烂器给GS个结果

47:06.350 --> 47:07.710
大概就这样子

47:07.710 --> 47:08.790
没什么

47:08.990 --> 47:10.350
大概就这样子

47:10.350 --> 47:12.590
所以说我们介石语言程序

47:12.590 --> 47:13.750
要运行出来

47:13.750 --> 47:14.710
关键是什么

47:14.710 --> 47:16.950
关键是要给它一个环境

47:16.950 --> 47:19.590
这个环境能够理解我们的介石程序

47:19.590 --> 47:20.630
写的是啥

47:20.630 --> 47:22.710
它能够把它翻译过去

47:22.710 --> 47:24.790
而且给它提供了一些API

47:24.790 --> 47:26.470
可以给它提供一些增强的功能

47:26.470 --> 47:28.110
比方流烂器里边给它提供了一些

47:28.110 --> 47:29.350
什么可以计时

47:29.350 --> 47:30.390
可以再控制台输出

47:30.390 --> 47:32.710
这些都是流烂器提供的

47:32.710 --> 47:34.670
V8引擎的只负责解释程序

47:34.670 --> 47:36.190
没什么意思吗

47:36.190 --> 47:38.550
所以你首先你要搞清楚

47:38.590 --> 47:40.950
我们写了GS程序

47:40.950 --> 47:43.550
不是说它只能在流烂器里边运行

47:43.550 --> 47:44.870
我们学了程序

47:44.870 --> 47:46.270
还包括两个部分

47:46.270 --> 47:52.170
一个部分叫做Akma script

47:52.170 --> 47:54.650
叫做Akma script

47:59.650 --> 48:01.610
就是ES我们平时说的ES

48:01.610 --> 48:03.010
ES规定了什么

48:03.010 --> 48:04.930
规定了这个语言语法什么样的东西

48:04.930 --> 48:06.850
比方说你循环该怎么写

48:06.850 --> 48:08.650
你定一个辩量该怎么写

48:08.650 --> 48:11.170
有些基本类型比方说数组

48:11.210 --> 48:14.130
数组里边应该有哪些方法

48:14.130 --> 48:16.330
它只提供这么些东西

48:16.330 --> 48:19.490
那么其他的APS什么多么对象

48:19.490 --> 48:23.850
这些东西是属于运行环境给它提供的

48:23.850 --> 48:24.930
像我们的多么对象在哪

48:24.930 --> 48:26.810
是在这一块

48:26.810 --> 48:27.570
如果没有这一块

48:27.570 --> 48:28.530
你还能使用多么对象

48:28.530 --> 48:29.970
你不能使用了

48:29.970 --> 48:32.170
但是你ES标准里面的东西

48:32.170 --> 48:33.050
你是可以使用的

48:33.050 --> 48:33.970
比方怎么写循环

48:33.970 --> 48:35.250
你是可以使用的

48:35.250 --> 48:37.730
没什么意思吗

48:37.730 --> 48:39.570
那么流烂器可以这样办

48:39.570 --> 48:41.010
那么漏的接式也可以这样办

48:41.050 --> 48:42.050
你看那个图计就知道

48:42.050 --> 48:44.290
漏的接式跟接式关系了

48:44.290 --> 48:46.170
漏的接式为什么是平台

48:46.170 --> 48:49.130
是因为它本身不是语言

48:49.130 --> 48:51.010
它是用来执行接式语言的

48:51.010 --> 48:52.570
它里面搭载了一个V8引擎

48:52.570 --> 48:53.050
对吧

48:53.050 --> 48:54.970
漏的接式它也是用了这个V8引擎

48:54.970 --> 48:58.210
只不过它不再给你提供流烂器的API了

48:58.210 --> 49:00.690
什么多么对象你在漏的接式里面能用吗

49:00.690 --> 49:01.650
用不了

49:01.650 --> 49:03.210
它不给你提供流烂器的API了

49:03.210 --> 49:04.530
因为它是服务器环境

49:04.530 --> 49:06.490
它不需要流烂器的API

49:06.490 --> 49:08.410
它可以提供的是漏的API

49:08.410 --> 49:09.850
当然这个漏的API里面的东西

49:09.970 --> 49:13.130
你们以后会专门去学习漏的接式

49:13.130 --> 49:14.970
你们以后会详细地学习到

49:14.970 --> 49:16.890
我们这门课要不要讲漏的接式

49:16.890 --> 49:17.610
肯定要讲

49:17.610 --> 49:18.290
以后你就知道了

49:18.290 --> 49:19.410
为什么要讲漏的接式

49:19.410 --> 49:20.850
但讲得非常非常基础

49:20.850 --> 49:23.290
不太会过漏的去设计到

49:23.290 --> 49:25.250
漏的接式里面的API

49:25.250 --> 49:26.610
你们以后学服务端的时候

49:26.610 --> 49:27.650
那就会设计到了

49:27.650 --> 49:29.010
所以你们以后学漏的接式

49:29.010 --> 49:31.650
其实很简单

49:31.650 --> 49:34.650
这一部分是完全一样的

49:34.650 --> 49:35.250
为什么呢

49:35.250 --> 49:37.810
因为V8引擎它解释执行接式语言的时候

49:37.850 --> 49:39.810
就看你满不满的语发规则

49:39.810 --> 49:40.450
满足了过后

49:40.450 --> 49:42.730
我把你语发规则给你翻译过来

49:42.730 --> 49:43.450
所以这一部分

49:43.450 --> 49:47.090
一页是课程里边的所有东西都是可以用的

49:47.090 --> 49:47.970
不同的是什么呢

49:47.970 --> 49:51.290
不同的是WebAPI里面的东西没有了

49:51.290 --> 49:55.490
WebAPI里面像什么多目对象没了

49:55.490 --> 49:56.170
SetterMouse

49:56.170 --> 49:58.890
Setinterval这些东西没了

49:58.890 --> 49:59.490
不过呢

49:59.490 --> 50:03.090
NoteAPI里面也给你构建了一些类似的东西

50:03.090 --> 50:05.810
一样差不多类似的东西

50:05.810 --> 50:07.010
像什么ConceptLog

50:07.570 --> 50:09.570
控制台输出没了

50:09.570 --> 50:11.850
不过Note接式的NoteAPI里面

50:11.850 --> 50:13.770
给你构建了一个一模一样的

50:13.770 --> 50:15.650
但是它们一定是

50:15.650 --> 50:17.290
肯定是实现的是不一样的

50:17.290 --> 50:19.490
实现内部的实现是不一样的

50:19.490 --> 50:20.650
没了意思吗

50:20.650 --> 50:23.330
这是关于Note接式和浏览器

50:23.330 --> 50:26.690
它们无非就是两个GES的运行环境而已

50:26.690 --> 50:27.530
环境不一样

50:27.530 --> 50:29.570
把这张图看懂

50:29.570 --> 50:31.970
那么现在人们就开始清晰地认识到了

50:31.970 --> 50:34.770
GES其实就是一个语言

50:34.810 --> 50:36.330
它可以一只要给它一个环境

50:36.330 --> 50:37.490
它就能执行

50:37.490 --> 50:40.050
并不是说你必须要在浏览器里面执行

50:40.050 --> 50:42.330
那么于是GES语言

50:42.330 --> 50:46.290
真正从概念上跟浏览器之间就分开了

50:46.290 --> 50:47.050
就把它分开了

50:49.010 --> 50:51.570
而且Note接式的诞生

50:51.570 --> 50:53.410
还标志了另外一个问题

50:53.410 --> 50:55.330
就是它把我们GES里面

50:55.330 --> 50:57.050
刚才我们说了最后一个问题

50:57.050 --> 50:57.890
放到台前了

50:57.890 --> 51:01.570
就是关于全局辩量污染和依赖混乱的问题

51:01.570 --> 51:02.730
它把它放到台前了

51:02.730 --> 51:03.970
为什么呢

51:03.970 --> 51:07.410
因为Note接式是要开发服务器端

51:08.770 --> 51:11.250
服务器端开发已经非常非常承受了

51:11.250 --> 51:13.370
比方说像加瓦PHP C下

51:14.570 --> 51:15.730
甚至C加加C

51:15.730 --> 51:17.690
然后现在用C加C

51:17.690 --> 51:19.010
用来开发服务器很少了

51:19.850 --> 51:21.890
但是服务器开发这个问题

51:21.890 --> 51:23.530
一定是非常非常成熟的一个问题了

51:24.570 --> 51:27.450
那么这个在这么成熟的领域下边

51:27.450 --> 51:30.250
如果你连模块化都没有

51:30.250 --> 51:31.770
那谈什么服务器开发

51:31.770 --> 51:32.930
服务器开发一定是里面

51:32.970 --> 51:34.650
肯定要遇到很多复杂的问题

51:34.650 --> 51:36.170
你没有模块化

51:36.170 --> 51:38.730
你连分文件分模块都办不到

51:38.730 --> 51:41.530
你连还有什么全局辩量污染和依赖混乱

51:41.530 --> 51:43.730
那种基本问题都没有解决

51:43.730 --> 51:46.810
你想用GES去开发后端

51:46.810 --> 51:48.050
那是吃人说梦

51:48.050 --> 51:48.810
对吧

51:48.810 --> 51:49.650
所以说呢

51:49.650 --> 51:51.210
B现在就必须要解

51:51.210 --> 51:53.490
Note接式要想真正的应用起来

51:53.490 --> 51:54.330
就必须要解决

51:54.330 --> 51:55.770
GES里面这个问题

51:55.770 --> 51:57.530
有全局辩量污染和依赖混乱

51:57.530 --> 51:58.530
也就是模块化的问题

51:59.490 --> 52:00.250
所以说

52:01.250 --> 52:04.530
于是经过社区的激烈讨论

52:04.530 --> 52:06.250
就必须要形成一种方案

52:06.250 --> 52:08.370
最终会形成了一个模块化的方案

52:08.370 --> 52:11.250
就是目前我们鼎鼎大名的common介石

52:11.250 --> 52:12.850
那么我们common介石是啥东西

52:12.850 --> 52:15.650
就是一个模块化的方案

52:15.650 --> 52:17.130
就是一个模块化方案

52:17.130 --> 52:20.370
我们或者说把它称之为模块化的标准

52:20.370 --> 52:23.170
就是你该怎么样来实现模块化

52:23.170 --> 52:24.890
实现出来的我该怎么去用

52:25.650 --> 52:27.890
比如我们加碼里面

52:27.890 --> 52:29.170
加碼里面我们用什么

52:30.290 --> 52:31.410
用package对吧

52:31.410 --> 52:32.490
打包

52:32.490 --> 52:33.730
用这个指令打包

52:33.730 --> 52:35.290
用什么import导入

52:35.290 --> 52:35.650
对吧

52:35.650 --> 52:36.570
就是加碼里面

52:36.570 --> 52:38.330
是用这种方式来实现模块化

52:38.330 --> 52:39.890
那么GES应该怎么实现的

52:39.890 --> 52:41.250
它里面有哪些细节呢

52:41.250 --> 52:43.370
那么这些都需要形成标准

52:43.370 --> 52:44.450
我们先不说实现

52:44.450 --> 52:46.010
我们先要形成一个共识

52:46.010 --> 52:47.330
形成一个标准

52:47.330 --> 52:49.170
那么以为这个标准之后

52:49.170 --> 52:52.770
我们才能把它去把它实现

52:52.810 --> 52:55.210
commonGES就是一个模块化标准

52:55.210 --> 52:58.690
通过这个标准就可以彻底解决这两个问题

52:58.690 --> 53:00.730
这两个问题其实就是模块化就可以解决了

53:00.730 --> 53:01.570
形成一个标准

53:01.570 --> 53:03.810
共识之后就可以解决这个问题了

53:03.810 --> 53:05.090
那么有了标准之后

53:05.090 --> 53:06.530
马上就要实现了

53:06.530 --> 53:07.890
loaderGES很快就实现了

53:07.890 --> 53:09.570
commonGES的标准

53:09.570 --> 53:11.930
于是loaderGES就成为了

53:11.930 --> 53:16.250
第一个为GES语言实现模块化的平台

53:16.250 --> 53:16.890
它是个平台

53:16.890 --> 53:17.930
它来执行GES语言

53:17.970 --> 53:23.010
并且为GES语言提供了模块化的实现

53:23.010 --> 53:24.730
遵循了commonGES标准

53:26.250 --> 53:29.050
就为前端接下来的训谋方展

53:29.050 --> 53:30.490
电竞实现的基础

53:30.490 --> 53:31.690
因为它真的实现了

53:31.690 --> 53:32.410
它不是空谈

53:32.410 --> 53:33.410
把它是已经实现了

53:34.370 --> 53:35.490
这个时候能够发现

53:35.490 --> 53:39.010
原来前端真的可以做大规模的应用

53:39.010 --> 53:40.330
不再是纸上坛冰了

53:40.330 --> 53:41.450
别人已经实现了

53:41.450 --> 53:43.650
已经可以分成模块来实现了

53:43.650 --> 53:45.810
所以我们这门客讲模块化

53:45.810 --> 53:47.210
就必须要讲到的GES

53:47.210 --> 53:49.370
为什么?因为我们要讲commonGES

53:49.370 --> 53:51.170
commonGES就在运行的loaderGES

53:51.170 --> 53:51.930
这个环境下面

53:53.330 --> 53:56.930
我们再来最后来看一下第三阶段发生大事情

53:56.930 --> 53:58.010
v8发布

53:58.010 --> 54:04.490
然后IE这个货基本上就被逐渐被火葡和谷歌残事了

54:04.490 --> 54:06.330
然后09年loaderGES发布

54:06.330 --> 54:08.410
并附带了commonGES模块化标准

54:09.490 --> 54:10.890
好,接下来我们看第四阶段

54:10.890 --> 54:11.850
就是最后阶段了

54:11.850 --> 54:15.170
就是我们从这个时间点开始

54:15.170 --> 54:18.050
到我们现金

54:18.090 --> 54:19.410
commonGES的出现了

54:19.410 --> 54:21.570
打开了前端开发者的思路

54:22.690 --> 54:25.250
突然发现我们以前很难想象的事情

54:25.250 --> 54:26.530
现在已经别人已经实现了

54:26.530 --> 54:28.090
已经在拥有了

54:28.090 --> 54:29.450
我们往往说

54:29.450 --> 54:31.850
我们想象应该走在实际上的前沿

54:31.850 --> 54:32.170
对吧

54:32.170 --> 54:33.890
我们虽然说现在很多东西没实现

54:33.890 --> 54:36.050
但是我们应该大量的想象

54:36.050 --> 54:37.850
我们以前想都不敢想的事情

54:37.850 --> 54:38.890
别人已经实现了

54:38.890 --> 54:40.530
那我们还有什么不敢想的呢

54:40.530 --> 54:42.370
于是很多的

54:43.650 --> 54:47.570
就是开发者和一些厂商都开始来畅想这个GES

54:47.610 --> 54:50.050
首先有个最简单的问题

54:50.050 --> 54:51.970
就是你后端漏的GES

54:51.970 --> 54:53.770
在这个环境里边

54:53.770 --> 54:56.410
在这个环境里边你支持了模块化

54:56.410 --> 54:58.810
但是浏览器环境里边还没支持

54:58.810 --> 55:00.570
浏览器它没有支持模块化

55:00.570 --> 55:03.210
那么你既然后端可以支持模块化

55:03.210 --> 55:05.330
那么浏览器为什么就不行了

55:05.330 --> 55:07.130
于是有人就开始想办法

55:07.130 --> 55:09.330
能不能把这个commonGES的规范

55:09.330 --> 55:11.410
运用到浏览器里边了

55:11.410 --> 55:12.890
后来发现了

55:12.890 --> 55:14.690
这里边有很多很多的困难

55:14.690 --> 55:15.850
那么具体是什么困难

55:15.850 --> 55:17.530
我们以后学了commonGES

55:17.530 --> 55:19.850
之后我们再来讨论

55:19.850 --> 55:21.530
但是肯定是有办法的

55:21.530 --> 55:23.010
于是有些开发者就想

55:23.010 --> 55:23.690
那么既然的

55:23.690 --> 55:26.330
你commonGES运用到浏览器

55:26.330 --> 55:26.770
比较困难

55:26.770 --> 55:30.170
你在漏的环境里边很简单

55:30.170 --> 55:30.970
其实困难在哪里

55:30.970 --> 55:32.370
困难就是因为

55:32.370 --> 55:34.530
我们后面来讲

55:34.530 --> 55:37.370
那么我们干嘛不重新定一个标准出来了

55:37.370 --> 55:38.730
一定要用你的commonGES吗

55:38.730 --> 55:41.610
commonGES不也是社区讨论出来的吗

55:41.610 --> 55:44.010
我们就重新换一种方案就行了

55:44.010 --> 55:47.250
于是很快一个新的方案就出炉了

55:47.330 --> 55:49.290
就是AMD这个规范

55:49.290 --> 55:50.610
这个规范它解决的问题

55:50.610 --> 55:52.210
也跟commonGES是一样的

55:52.210 --> 55:53.930
还是解决魔幌化

55:53.930 --> 55:57.930
不过它非常能够适合浏览器的环境

55:57.930 --> 56:00.050
完全贴合浏览器的环境

56:00.050 --> 56:02.690
所以说我们在浏览器一端

56:02.690 --> 56:03.890
要实现魔幌化的话

56:03.890 --> 56:05.770
我们就可以使用AMD

56:05.770 --> 56:07.650
相继的CMD又出现了

56:07.650 --> 56:10.170
CMD对AMD进行了一些改进

56:10.170 --> 56:11.250
使它更加好用

56:11.250 --> 56:13.650
更加不容易出问题

56:13.650 --> 56:15.610
然后这些行为又受到了

56:15.650 --> 56:17.090
ACMA官方的关注

56:17.090 --> 56:19.850
你看你们自己的玩得很嗨

56:19.850 --> 56:21.010
民间都玩得这么嗨

56:21.010 --> 56:23.250
我们官方不能完全无动于衷

56:23.250 --> 56:24.730
魔幌化已经提上日程了

56:24.730 --> 56:28.130
所以说在2015年

56:28.130 --> 56:29.490
ACMA script的重要版本

56:29.490 --> 56:30.810
就是ES6发布

56:30.810 --> 56:32.490
那么它里边又直接附带了

56:32.490 --> 56:33.370
一个魔幌化解决方案

56:33.370 --> 56:35.930
就是官方的魔幌化解决方案

56:35.930 --> 56:38.250
我们把它称之为ES6魔幌化

56:38.250 --> 56:40.010
当然ES6魔幌化出来之后

56:40.850 --> 56:42.810
这个玩意基本上退出了

56:42.810 --> 56:43.970
这个玩意基本上退出了

56:43.970 --> 56:45.010
所以我们课程里面

56:45.050 --> 56:46.050
讲不讲这两个玩意

56:46.050 --> 56:47.770
讲只不过讲的比较简略

56:47.770 --> 56:50.730
因为这两个玩意就已经不再是主流了

56:50.730 --> 56:52.530
我们目前在浏览期一端

56:52.530 --> 56:53.610
要实现魔幌化

56:53.610 --> 56:56.130
我们都使用ES6魔幌化

56:56.130 --> 56:57.570
那么common介石的魔幌化

56:57.570 --> 56:58.890
标准还学不学呢

56:58.890 --> 56:59.650
这么重要呢

56:59.650 --> 57:00.530
很重要

57:00.530 --> 57:01.410
为啥呢

57:01.410 --> 57:03.410
因为漏的介石至今

57:03.410 --> 57:07.890
到现在都还不支持ES6魔幌化

57:07.890 --> 57:09.690
漏的介石都还不支持

57:09.690 --> 57:11.370
我记得我几年前

57:11.370 --> 57:12.730
漏的介石一直在说

57:12.730 --> 57:14.330
ES6魔幌化是标准

57:14.330 --> 57:15.290
我们一定要支持

57:15.290 --> 57:17.010
结果到现在都没支持

57:18.290 --> 57:20.330
我希望了你们看到这个视频的时候

57:21.170 --> 57:22.810
我不知道你们什么时候能看到这个视频

57:23.330 --> 57:24.770
我希望你们看到这个视频的时候

57:24.770 --> 57:25.410
漏的介石

57:25.410 --> 57:26.530
希望它支持了

57:26.530 --> 57:27.530
希望吧

57:28.610 --> 57:30.210
所以说我们common介石还是得学

57:30.210 --> 57:31.290
因为在漏的介石里面

57:31.290 --> 57:33.410
环境里面我们必须要用它

57:34.250 --> 57:35.210
从此以后

57:35.210 --> 57:37.730
魔幌化就形成了介石本身的特色

57:37.730 --> 57:39.170
因为官方支持的

57:39.170 --> 57:41.570
它就变成了语言内部的标准了

57:41.570 --> 57:43.810
所以说语言本身它就支持魔幌化了

57:44.090 --> 57:45.770
它就有了魔幌化的标准

57:45.770 --> 57:48.730
于是这么语言终于可以堂堂正正的

57:48.730 --> 57:50.250
和其他语言较量了

57:50.250 --> 57:52.850
不要说以前你别在反玻璃

57:52.850 --> 57:54.890
你说介石语言这样好那样好

57:54.890 --> 57:56.170
你们有魔幌化吗

57:56.170 --> 57:57.650
你们连分魔幌化都是做不到

57:57.650 --> 57:59.610
你们怎么来写规模化的应用程序

57:59.610 --> 58:01.050
你们怎么去写复杂的应用

58:01.050 --> 58:02.210
怎么写大型应用

58:02.210 --> 58:03.330
你做不到

58:03.330 --> 58:05.170
但是现在语言本身有了魔幌化了

58:05.170 --> 58:06.890
就可以一争了

58:06.890 --> 58:07.890
没什么意思

58:08.970 --> 58:10.610
也是因为这个原因

58:11.610 --> 58:14.930
很多厂商看到了魔幌化

58:14.930 --> 58:17.330
有的开发者或者厂商

58:17.330 --> 58:18.610
是在ES6发布之前

58:18.610 --> 58:20.170
就看到了魔幌化了

58:20.170 --> 58:23.330
就已经解决这个魔幌化是着万的事情了

58:23.330 --> 58:25.930
那么他就预计到介石有无穷的潜力

58:25.930 --> 58:29.290
于是这些事就有了下面这些事

58:29.290 --> 58:30.130
简单看一下

58:30.130 --> 58:32.570
这都是你们以后可能要接触的

58:32.570 --> 58:35.530
既然介石可以编写大型应用

58:36.210 --> 58:39.730
那么自然也需要像其他语言那样子

58:39.850 --> 58:41.050
有复杂解决方案了

58:41.050 --> 58:42.410
因为以前不能编写大型应用

58:42.410 --> 58:43.290
以前没有魔幌化

58:43.290 --> 58:43.850
对吧

58:43.850 --> 58:45.570
没法编写大型应用

58:45.570 --> 58:46.970
所以说现在可以了

58:46.970 --> 58:47.530
现在可以

58:47.530 --> 58:48.690
那么自然而单

58:48.690 --> 58:52.050
会有一些大型应用遇到的一些通用的问题

58:52.050 --> 58:53.610
那么比方说框架问题

58:53.610 --> 58:55.610
我们比方说编写一些复杂应用

58:55.610 --> 58:56.450
编写某一个方面

58:56.450 --> 58:58.010
解决某一个方面的复杂问题

58:58.010 --> 58:59.970
那么我们可能会需要一个框架

58:59.970 --> 59:01.770
那么这些框架就相应出现了

59:01.770 --> 59:02.770
什么安格拉

59:02.770 --> 59:05.810
Reax VU就相应出现了

59:05.810 --> 59:07.090
还有什么后端的框架

59:07.090 --> 59:08.570
Express你们以后都要学

59:08.650 --> 59:09.770
TOA这些框架

59:09.770 --> 59:11.010
后端框架也出现了

59:11.010 --> 59:12.170
什么数据过驱动

59:12.170 --> 59:13.570
软件发达都出现了

59:14.730 --> 59:16.010
第二个

59:16.010 --> 59:17.850
要开发大型应用的话

59:17.850 --> 59:20.570
肯定中间有很多的小的问题需要解决

59:21.570 --> 59:22.570
那么这些小的问题

59:22.570 --> 59:24.450
我们需要用到一些第三方库

59:24.450 --> 59:26.250
需要一些第三方库的知识

59:26.250 --> 59:28.410
比方说像什么测试的库

59:28.410 --> 59:30.730
像什么一些工具库等等

59:30.730 --> 59:32.850
一些加密库之类的

59:32.850 --> 59:35.370
需要一些使用的第三方库的知识

59:35.370 --> 59:36.770
那么这么多的第三方库

59:36.770 --> 59:37.970
我们要进行管理

59:38.050 --> 59:39.970
那么这也是个工程化的问题

59:39.970 --> 59:40.970
那么怎么办

59:40.970 --> 59:45.050
我们后边要学习的是NPM包管理器

59:45.050 --> 59:48.130
它能很方便的管理我们工程中

59:48.130 --> 59:49.650
用到了第三方库

59:49.650 --> 59:51.090
包括什么版本管理

59:51.090 --> 59:52.850
更新一样之类的东西就非常方便

59:54.530 --> 59:56.530
而且我们第三方库用了多了

59:56.530 --> 59:58.530
代码逐渐增多了之后

59:58.530 --> 01:00:01.090
我们需要一些能打包部署的工具

01:00:01.090 --> 01:00:01.930
我们后边会讲

01:00:01.930 --> 01:00:03.890
WePAC的一些构建工具

01:00:03.890 --> 01:00:05.850
它能解决另外一部分问题

01:00:05.850 --> 01:00:07.930
这些都是伴随着工程化

01:00:07.930 --> 01:00:10.130
就是规模化的进程出现的

01:00:11.130 --> 01:00:13.330
然后又有人开始想

01:00:13.330 --> 01:00:16.330
既然咱们GS可以放到服务器环境

01:00:16.330 --> 01:00:18.490
为什么就不能放到其他环境呢

01:00:18.490 --> 01:00:19.330
你现在可以看

01:00:19.330 --> 01:00:21.210
GS可以在浏览器运行了吗

01:00:21.210 --> 01:00:22.810
可以在服务器运行了吗

01:00:22.810 --> 01:00:24.930
那为什么不能在桌面运行了

01:00:24.930 --> 01:00:28.050
于是Electron发布

01:00:28.050 --> 01:00:29.370
它可以使用GS语言

01:00:29.370 --> 01:00:30.890
开发桌面应用程序

01:00:30.890 --> 01:00:31.970
比方说QQ

01:00:31.970 --> 01:00:34.370
像我们的VSCode这个东西

01:00:34.370 --> 01:00:35.730
这是不是个桌面应用程序

01:00:35.770 --> 01:00:37.690
这就是个桌面应用程序

01:00:37.690 --> 01:00:38.610
这个玩意儿

01:00:38.610 --> 01:00:39.690
它就是用这个玩意儿

01:00:39.690 --> 01:00:41.130
就是用它开发的

01:00:41.130 --> 01:00:43.370
就是用GS写的

01:00:43.370 --> 01:00:44.090
还有什么

01:00:44.090 --> 01:00:46.050
我们可以要编写一段端应用程序

01:00:46.050 --> 01:00:46.250
对吧

01:00:46.250 --> 01:00:48.210
我们介绍的应用端应用端也可以

01:00:48.210 --> 01:00:49.050
于是rn

01:00:49.050 --> 01:00:51.650
还有什么vuex等一些技术就出现了

01:00:51.650 --> 01:00:53.290
那么我们可以使用GS语言

01:00:53.290 --> 01:00:55.650
编写手机端应用程序了

01:00:55.650 --> 01:00:57.210
还包括什么

01:00:57.210 --> 01:00:58.490
各种小程序

01:00:58.490 --> 01:00:59.930
我们微信小程序

01:00:59.930 --> 01:01:01.010
支付宝小程序

01:01:01.010 --> 01:01:01.970
这些的

01:01:01.970 --> 01:01:03.890
我们可以使用GS编写一些

01:01:03.890 --> 01:01:06.210
支付于其他应用的小程序

01:01:06.210 --> 01:01:07.370
你学到GS过后

01:01:07.370 --> 01:01:09.170
很多事情都可以做了

01:01:09.170 --> 01:01:10.170
还不仅如此

01:01:10.170 --> 01:01:11.810
还有我们以后想象不到的

01:01:11.810 --> 01:01:14.370
目前还有很多的厂商都在致力于

01:01:14.370 --> 01:01:16.930
将GS应用到其他的终端设备

01:01:16.930 --> 01:01:18.250
比方说什么VR

01:01:18.250 --> 01:01:18.730
举个例子

01:01:18.730 --> 01:01:19.610
下距的例子

01:01:19.610 --> 01:01:21.650
比方说什么扯载系统

01:01:21.650 --> 01:01:22.930
智能冰箱

01:01:22.930 --> 01:01:23.770
智能微波炉

01:01:23.770 --> 01:01:25.330
智能马桶之类的东西

01:01:25.330 --> 01:01:27.610
我们是不是将来都可以用GS呢

01:01:27.610 --> 01:01:30.410
我们有无限的想象空间

01:01:30.410 --> 01:01:32.810
什么叫做大前端生态

01:01:32.810 --> 01:01:33.890
大前端生态什么意思

01:01:33.890 --> 01:01:35.930
就是所有跟人打交道的

01:01:35.930 --> 01:01:36.730
跟客户

01:01:36.730 --> 01:01:38.010
中端的客户打交道的

01:01:38.010 --> 01:01:39.290
所有的设备

01:01:39.290 --> 01:01:41.370
都可以用前端语言来书写

01:01:41.370 --> 01:01:42.970
就大前端

01:01:42.970 --> 01:01:44.890
原来的意思

01:01:44.890 --> 01:01:47.210
我们可以看到有这么多的

01:01:47.210 --> 01:01:48.890
一人激动的这些

01:01:48.890 --> 01:01:50.570
发展前景

01:01:50.570 --> 01:01:51.930
最终的原因都是它

01:01:51.930 --> 01:01:53.450
最终的原因都是因为

01:01:53.450 --> 01:01:55.370
模块化的出现

01:01:55.370 --> 01:01:56.730
模块化的出现

01:01:56.730 --> 01:02:00.850
是GS通向大型应用的最后一堵墙

01:02:00.850 --> 01:02:02.090
这堵墙

01:02:02.170 --> 01:02:04.210
不应该说最后一堵墙

01:02:04.210 --> 01:02:08.090
这是应该是将最后一堵墙倒它的力量

01:02:09.610 --> 01:02:11.050
有了模块化之后

01:02:11.050 --> 01:02:13.290
GS就可以通向大型应用了

01:02:13.290 --> 01:02:14.490
学好模块化

01:02:14.490 --> 01:02:15.890
我们就具备了

01:02:15.890 --> 01:02:18.250
编写大型应用的基本功

01:02:18.250 --> 01:02:20.690
所以说模块化对大家是非常重要的

01:02:20.690 --> 01:02:23.090
我也花了这么多时间

01:02:23.090 --> 01:02:23.850
给大家解释了

01:02:23.850 --> 01:02:26.210
模块化是怎么样形成的

01:02:26.210 --> 01:02:27.570
为什么这么重要

01:02:27.570 --> 01:02:29.370
以及我们这门课

01:02:29.370 --> 01:02:31.290
要学习哪些模块化

01:02:31.330 --> 01:02:32.810
要学习哪些

01:02:32.810 --> 01:02:34.370
common.js

01:02:34.370 --> 01:02:35.610
哪些重点

01:02:35.610 --> 01:02:37.930
还有什么AMD

01:02:37.930 --> 01:02:38.650
CMD

01:02:38.650 --> 01:02:39.890
这些都是非重点

01:02:39.890 --> 01:02:41.490
还有什么ES6

01:02:43.650 --> 01:02:46.850
这是模块化重点

01:02:46.850 --> 01:02:47.850
为什么这两个重点

01:02:47.850 --> 01:02:50.890
因为这两个至今我们在大量的使用

01:02:50.890 --> 01:02:51.890
这两个

01:02:51.890 --> 01:02:54.930
由于目前基本上已经被ES6模块化挤压了

01:02:54.930 --> 01:02:55.610
所以说这两个

01:02:55.610 --> 01:02:57.170
我们了解就行了

01:02:57.170 --> 01:02:59.330
我会简单的介绍一下

01:02:59.330 --> 01:03:00.810
这门课的东西很少

01:03:00.890 --> 01:03:01.370
并不多

01:03:01.370 --> 01:03:02.850
这两个模块化的学习也很简单

01:03:02.850 --> 01:03:04.290
但是它非常重要

01:03:04.290 --> 01:03:04.850
好了

01:03:04.850 --> 01:03:07.210
这是关于模块化的概述

01:03:07.210 --> 01:03:08.130
多花了一些时间

01:03:08.130 --> 01:03:09.090
希望大家能够明白

01:03:09.090 --> 01:03:10.970
这个技术的演化的过程

01:03:10.970 --> 01:03:13.890
以及模块化的历史地位

01:03:13.890 --> 01:03:15.250
那么下一集和开始

01:03:15.250 --> 01:03:17.890
我们就开始从common.js开始学习了

01:03:17.890 --> 01:03:19.730
就从这里

01:03:19.730 --> 01:03:21.010
从这里开始学习了

01:03:21.010 --> 01:03:21.970
那么要学这个东西

01:03:21.970 --> 01:03:23.170
肯定要先讲一下

01:03:23.170 --> 01:03:24.010
漏了几件事

01:03:24.010 --> 01:03:24.770
不到底慢慢来

