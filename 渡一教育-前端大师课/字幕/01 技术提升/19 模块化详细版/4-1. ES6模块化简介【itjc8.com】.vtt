WEBVTT

00:00.690 --> 00:04.690
咱们这门课有两个重点

00:04.690 --> 00:07.690
一个是common.js 这个是必须要掌握的

00:07.690 --> 00:11.690
另外一个就是咱们这一张ES6的模块画

00:11.690 --> 00:15.690
这一张和common.js遥相呼应

00:15.690 --> 00:22.690
最终会形成你们之后学习webpack来门技术的基础

00:22.690 --> 00:29.690
ES6模块画其实它的出现就已经参照了很多的模块画标准了

00:30.690 --> 00:35.690
在ES6之前不是有什么CMD、AMD、common.js

00:35.690 --> 00:38.690
或者是一些其他里没有经过的模块画标准

00:38.690 --> 00:41.690
有这么多模块画标准作为参考的

00:41.690 --> 00:45.690
ACMA组织在2015年它随着ES6发布

00:45.690 --> 00:48.690
它同时就发布了官方的模块画标准

00:48.690 --> 00:51.690
那么这个时候呢 浏览系场上终于有活可以干了

00:51.690 --> 00:54.690
它除了要支持ES6的很多特性之外

00:54.690 --> 00:57.690
同时要支持ES6的模块画标准

00:57.690 --> 01:00.690
那么我们后边把它称之为ES6模块画

01:00.690 --> 01:03.690
或者叫做官方模块画标准

01:03.690 --> 01:05.690
我们这一课就简单几句话

01:05.690 --> 01:07.690
介绍一下ES6的模块画

01:07.690 --> 01:11.690
同时给大家介绍一下官方是怎么去思考问题的

01:11.690 --> 01:14.690
ES6的模块画它具有以下这么一些特点

01:14.690 --> 01:19.690
这些特点都是在参照了很多的模块画标准之后

01:19.690 --> 01:21.690
自己琢磨出来的 官方琢磨出来的

01:21.690 --> 01:24.690
第一个呢 它使用的是

01:24.690 --> 01:27.690
依赖预生民的方式导入模块

01:27.690 --> 01:31.690
这是啥意思啊 我们来看一下common.js

01:31.690 --> 01:36.690
common.js这种生民方式 随便找一个吧

01:36.690 --> 01:39.690
common.js这种生民方式呢

01:39.690 --> 01:42.690
它就不是依赖预生民

01:42.690 --> 01:45.690
因为你看啊 这个index的介绍是入口文件

01:45.690 --> 01:47.690
这个模块呢 它依赖哪个模块

01:47.690 --> 01:50.690
依赖这个模块 同时又依赖这个模块

01:50.690 --> 01:52.690
对吧 它是不是依赖这两个模块

01:52.690 --> 01:56.690
那么它依赖的过程 它在单码的运行过程中

01:56.690 --> 01:59.690
运行到一般的时候 才把那个模块导入进来

01:59.690 --> 02:02.690
看没 那么这种写法呢

02:02.690 --> 02:06.690
这种规范的叫做依赖延迟生民

02:06.690 --> 02:10.690
依赖延迟生民

02:10.690 --> 02:12.690
就是我不是一开始我就说

02:12.690 --> 02:14.690
我这个文件就依赖它 依赖它

02:14.690 --> 02:16.690
一开始没有说 而是运行的过程中

02:16.690 --> 02:19.690
我才把那个生民 把这个依赖写进去

02:19.690 --> 02:22.690
这叫依赖延迟生民

02:22.690 --> 02:24.690
延迟生民的好处在哪呢

02:24.690 --> 02:27.690
我们这里顺便说一下吧

02:27.690 --> 02:31.690
依赖延迟生民

02:31.690 --> 02:34.690
它的好处 优点

02:34.690 --> 02:36.690
优点在哪呢

02:36.690 --> 02:40.690
某些时候可以提高效率

02:40.690 --> 02:41.690
可以提高效率

02:41.690 --> 02:42.690
比方说我们有的时候呢

02:42.690 --> 02:44.690
可能会写出这么一种代码

02:44.690 --> 02:48.690
就是判断 什么什么条件满足的时候

02:48.690 --> 02:51.690
满足的时候我再去执行一个模块

02:51.690 --> 02:53.690
比方说这个模块

02:53.690 --> 02:55.690
L是不满足的时候

02:55.690 --> 02:57.690
我去执行另外一个模块

02:57.690 --> 03:01.690
那么这个依赖是不是不确定的

03:01.690 --> 03:02.690
对吧

03:02.690 --> 03:04.690
那么在这种时候呢

03:04.690 --> 03:06.690
如果说你使用依赖延迟生民

03:06.690 --> 03:08.690
这种模块标准的话

03:08.690 --> 03:09.690
那么它有助于提高效率

03:09.690 --> 03:10.690
比方说我这里呢

03:10.690 --> 03:11.690
要么就使用A模块

03:11.690 --> 03:12.690
要么就使用B模块

03:12.690 --> 03:14.690
我不会两个模块都使用

03:14.690 --> 03:16.690
我就不会把两个模块倒入进来

03:16.690 --> 03:19.690
这叫依赖延迟生民

03:19.690 --> 03:22.690
那么什么叫依赖寓意生民呢

03:22.690 --> 03:25.690
寓意生民是什么呢

03:25.690 --> 03:28.690
我先把这个延迟生民缺点说出来

03:28.690 --> 03:29.690
缺点说出来

03:29.690 --> 03:30.690
缺陷

03:30.690 --> 03:34.690
缺陷就是无法在一开始

03:34.690 --> 03:37.690
确定模块依赖关系

03:37.690 --> 03:40.690
依赖关系可能比较模糊

03:40.690 --> 03:41.690
相对比较模糊

03:41.690 --> 03:43.690
比以前肯定好多了

03:43.690 --> 03:45.690
相对比较模糊

03:45.690 --> 03:47.690
就是你无法通过一个文件

03:47.690 --> 03:49.690
最开始就能看出这个模块

03:49.690 --> 03:50.690
依赖哪些模块

03:50.690 --> 03:51.690
依赖比较模糊

03:51.690 --> 03:53.690
这是依赖延迟生民

03:53.690 --> 03:56.690
另外一种就是依赖寓意生民

03:56.690 --> 03:58.690
依赖寓意生民

03:58.690 --> 04:00.690
你懂这个意思吗

04:00.690 --> 04:04.690
依赖寓意生民

04:04.690 --> 04:06.690
那么它的优点在于

04:06.690 --> 04:07.690
那就是刚好相反了

04:07.690 --> 04:08.690
刚好相反了

04:08.690 --> 04:09.690
优点在于什么呢

04:09.690 --> 04:12.690
在一开始的时候就可以确定

04:12.690 --> 04:15.690
模块依赖关系

04:15.690 --> 04:16.690
非常的精准

04:16.690 --> 04:19.690
比方说哪个东西是依赖寓意生民的

04:19.690 --> 04:20.690
AMD规范

04:20.690 --> 04:21.690
它就是依赖寓意生民

04:21.690 --> 04:22.690
你看一下

04:22.690 --> 04:23.690
是不是在敌翻的时候

04:23.690 --> 04:25.690
一开始就把你要依赖的全部写出来

04:25.690 --> 04:27.690
我不管你什么情况

04:27.690 --> 04:28.690
比方说像这种情况

04:28.690 --> 04:30.690
你某些时候依赖A

04:30.690 --> 04:31.690
某些时候依赖B

04:31.690 --> 04:32.690
做不到

04:32.690 --> 04:33.690
你要用AMD规范的话

04:33.690 --> 04:35.690
你必须要把A也依赖进来

04:35.690 --> 04:36.690
B也依赖进来

04:36.690 --> 04:38.690
只要一开始要依赖生民依赖

04:38.690 --> 04:39.690
那么具体的情况下

04:39.690 --> 04:41.690
就是你要不要用

04:41.690 --> 04:42.690
那是另外一回事

04:42.690 --> 04:44.690
但是依赖必须要一开始要生命

04:44.690 --> 04:46.690
这叫依赖

04:46.690 --> 04:48.690
就是依赖寓意生民

04:48.690 --> 04:49.690
一开始就必须要生命

04:49.690 --> 04:51.690
它的缺陷自然很明显

04:51.690 --> 04:53.690
缺点

04:53.690 --> 04:55.690
缺点就是

04:55.690 --> 04:58.690
需要某些时候

04:58.690 --> 05:01.690
效率较低

05:04.690 --> 05:06.690
那么这个两个方案

05:06.690 --> 05:07.690
它肯定要选择一个

05:07.690 --> 05:08.690
不可能两个方案都选择的

05:08.690 --> 05:09.690
它只能选择一个

05:09.690 --> 05:11.690
那么到底选择哪一个呢

05:11.690 --> 05:13.690
它最终选择的是依赖寓意生民

05:13.690 --> 05:16.690
其实依赖寓意生民这种方式

05:16.690 --> 05:18.690
有助于提高代码的阅读

05:18.690 --> 05:21.690
有助于我们后续维护代码

05:21.690 --> 05:23.690
但是它可能执行效率

05:23.690 --> 05:25.690
在某些时候比较低一点

05:25.690 --> 05:27.690
就比方向这种时候就比较低一点

05:27.690 --> 05:29.690
那么这种效率低

05:29.690 --> 05:31.690
不是语言考虑的问题

05:31.690 --> 05:33.690
就是做语言标准的人

05:33.690 --> 05:35.690
他不可给你考虑什么效率问题的

05:35.690 --> 05:36.690
他只考虑的规不规范

05:36.690 --> 05:37.690
该不该这样做

05:37.690 --> 05:38.690
所以说从官方的角度来说

05:38.690 --> 05:41.690
他要确定语言标准

05:41.690 --> 05:42.690
那么他不考虑效率

05:42.690 --> 05:44.690
效率是你们后续什么

05:44.690 --> 05:45.690
第三方厂商啊

05:45.690 --> 05:46.690
浏览器厂商啊

05:46.690 --> 05:47.690
或者是一些社群

05:47.690 --> 05:49.690
你们要去解决的问题

05:49.690 --> 05:51.690
效率交给你们来解决

05:51.690 --> 05:53.690
那后来有没有办法解决呢

05:53.690 --> 05:54.690
有办法

05:54.690 --> 05:56.690
那么就不是这个课的内容了

05:56.690 --> 05:58.690
就是我们后续的构建工具

05:58.690 --> 05:59.690
那一块可以解决这个问题

05:59.690 --> 06:00.690
我们后续再说

06:00.690 --> 06:02.690
那么他只考虑语言层面

06:02.690 --> 06:03.690
因此他认为

06:03.690 --> 06:05.690
依赖寓意生民对这个语言本身

06:05.690 --> 06:07.690
这这个语法层面本身

06:07.690 --> 06:10.690
是更加有助于提高语言的考虑读性

06:10.690 --> 06:12.690
而且有助于后续维护代码的

06:12.690 --> 06:14.690
所以他从这个点考虑

06:14.690 --> 06:16.690
他使用的是依赖寓意生民

06:16.690 --> 06:17.690
这是他的考虑方式

06:17.690 --> 06:19.690
而且包括了很多的后端语言

06:19.690 --> 06:20.690
像什么加瓦啊

06:20.690 --> 06:21.690
SHAPE啊

06:21.690 --> 06:22.690
这些东西呢

06:22.690 --> 06:25.690
他们都是使用的是依赖寓意生民

06:25.690 --> 06:27.690
他们其实都是考虑到这一点

06:27.690 --> 06:29.690
考虑到语言本身层面的东西

06:29.690 --> 06:31.690
因此他最终选择的是

06:31.690 --> 06:32.690
使用依赖寓意生民

06:32.690 --> 06:33.690
也就是说

06:33.690 --> 06:35.690
类似于AMD那种方式

06:35.690 --> 06:36.690
当然肯定

06:36.690 --> 06:37.690
协发上肯定不一样

06:37.690 --> 06:38.690
要不要一个优雅的多

06:38.690 --> 06:39.690
好

06:39.690 --> 06:40.690
第二种呢

06:40.690 --> 06:42.690
是灵活的多种导入导出方式

06:42.690 --> 06:44.690
他这个东西参考的是谁呢

06:44.690 --> 06:46.690
参考的是CommonJS

06:46.690 --> 06:48.690
他发现了CommonJS里面

06:48.690 --> 06:50.690
导出的方式呢

06:50.690 --> 06:52.690
单一且冲突

06:52.690 --> 06:53.690
比如什么意思呢

06:53.690 --> 06:54.690
就是说你看这

06:54.690 --> 06:55.690
我们这里随便找一个

06:55.690 --> 06:56.690
导出

06:56.690 --> 06:58.690
在那个就是CommonJS里面

06:58.690 --> 06:59.690
导出

06:59.690 --> 07:01.690
是不是可以用Major.export

07:01.690 --> 07:02.690
对吧

07:02.690 --> 07:03.690
这种用法是不是只能用一次

07:03.690 --> 07:04.690
而且呢

07:04.690 --> 07:05.690
还可以用啥

07:05.690 --> 07:06.690
还可以用export

07:06.690 --> 07:07.690
第二什么什么什么

07:07.690 --> 07:08.690
给它复制对吧

07:08.690 --> 07:10.690
给它复制export

07:10.690 --> 07:12.690
第二

07:12.690 --> 07:13.690
咋给它复制

07:13.690 --> 07:14.690
可以用这两种方式

07:14.690 --> 07:15.690
这两种方式

07:15.690 --> 07:16.690
只能选其中一种

07:16.690 --> 07:18.690
它不能两种同时存在

07:18.690 --> 07:20.690
那么它降低了灵活度

07:20.690 --> 07:21.690
降低了灵活度

07:21.690 --> 07:22.690
因此呢

07:22.690 --> 07:24.690
在那个ES6官方标准里边

07:24.690 --> 07:26.690
它两种方式

07:26.690 --> 07:28.690
多种导出方式都支持

07:28.690 --> 07:30.690
那么自然而然

07:30.690 --> 07:32.690
它对应多种导入方式

07:32.690 --> 07:34.690
因此它提供了灵活的导出

07:34.690 --> 07:35.690
和导入方式

07:35.690 --> 07:36.690
另外呢

07:36.690 --> 07:37.690
它对路径的规

07:37.690 --> 07:38.690
路径的写法

07:38.690 --> 07:39.690
也做出了规范

07:39.690 --> 07:41.690
像CommonJS里面

07:41.690 --> 07:42.690
不是规定

07:42.690 --> 07:43.690
你路径必须要有

07:43.690 --> 07:44.690
以底儿的鞋杠开头

07:44.690 --> 07:45.690
必须要以底儿的鞋杠开头

07:45.690 --> 07:46.690
对吧

07:46.690 --> 07:48.690
否则的话就有其他含义

07:48.690 --> 07:49.690
那么AMD

07:49.690 --> 07:50.690
CMD

07:50.690 --> 07:51.690
它其实又没有

07:51.690 --> 07:53.690
这方面路径的规范了

07:53.690 --> 07:55.690
或者说有别的其他规范了

07:55.690 --> 07:56.690
那么路径的规范

07:56.690 --> 07:57.690
是比较模糊的

07:57.690 --> 07:59.690
那么在ES6的官方标准里边

08:00.690 --> 08:01.690
它可以做出明确的表示

08:01.690 --> 08:03.690
所有的路径必须以底儿鞋杠

08:03.690 --> 08:05.690
或者是底儿的鞋杠开头

08:05.690 --> 08:07.690
必须这个开头

08:07.690 --> 08:09.690
那么就做出了明确的约束了

08:09.690 --> 08:11.690
就简单说的这两句

08:11.690 --> 08:14.690
这是ES6模块化的一个简介

08:14.690 --> 08:15.690
其实我说这几句话

08:15.690 --> 08:16.690
主要是告诉大家

08:16.690 --> 08:17.690
给大家一种感觉

08:17.690 --> 08:19.690
就是官方它是考虑的问题

08:19.690 --> 08:21.690
它考虑的可能比较远

08:21.690 --> 08:22.690
它考虑的远

08:22.690 --> 08:23.690
而且它有些问题

08:23.690 --> 08:24.690
它是故意忽略的

08:24.690 --> 08:25.690
它不是说它不知道

08:25.690 --> 08:26.690
有什么效率问题

08:26.690 --> 08:27.690
它知道

08:27.690 --> 08:28.690
知道

08:28.690 --> 08:29.690
但是关它的事

08:29.690 --> 08:30.690
因为它这些效率问题

08:30.690 --> 08:32.690
是具体的实现过程

08:32.690 --> 08:33.690
你要去考虑的

08:33.690 --> 08:34.690
而我定标准的过程

08:34.690 --> 08:35.690
我不考虑

08:35.690 --> 08:37.690
它只要能够论证

08:37.690 --> 08:38.690
这个效率问题是可以解决的

08:38.690 --> 08:40.690
那么就OK了

08:40.690 --> 08:42.690
它就不需要管其他事情了

08:42.690 --> 08:44.690
这是关于ES6的模块化标准

08:44.690 --> 08:46.690
作为一个简单的概念

08:46.690 --> 08:47.690
当然现在我们都还不

08:47.690 --> 08:48.690
涉及到鞋带

08:48.690 --> 08:49.690
下几个开始

08:49.690 --> 08:51.690
再慢慢来聊ES6模块化

08:51.690 --> 08:54.690
具有什么样的一些规范特点

